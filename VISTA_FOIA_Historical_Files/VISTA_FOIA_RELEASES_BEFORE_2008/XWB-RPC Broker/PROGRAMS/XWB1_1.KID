KIDS Distribution saved on Sep 18, 1997@15:48:52
RPC Broker version 1.1
**KIDS**:RPC BROKER 1.1^

**INSTALL NAME**
RPC BROKER 1.1
"BLD",193,0)
RPC BROKER 1.1^RPC BROKER^0^2970918^y
"BLD",193,1,0)
^^1^1^2970918^
"BLD",193,1,1,0)
RPC BROKER version 1.1
"BLD",193,4,0)
^9.64PA^8994.1^2
"BLD",193,4,8994,0)
8994
"BLD",193,4,8994,222)
y^y^f^^^^n
"BLD",193,4,8994.1,0)
8994.1
"BLD",193,4,8994.1,222)
y^y^f^^^^n
"BLD",193,4,"B",8994,8994)

"BLD",193,4,"B",8994.1,8994.1)

"BLD",193,"ABNS",0)
^9.66A^1^1
"BLD",193,"ABNS",1,0)
XWB
"BLD",193,"ABNS",1,1,0)
^9.661A^^
"BLD",193,"ABNS","B","XWB",1)

"BLD",193,"ABPKG")
n^y^G.RPC BROKER DEVELOPMENT@ISC-SF.VA.GOV
"BLD",193,"KRN",0)
^9.67PA^771^19
"BLD",193,"KRN",.4,0)
.4
"BLD",193,"KRN",.4,"NM",0)
^9.68A^1^1
"BLD",193,"KRN",.4,"NM",1,0)
XWB SEND API    FILE #8994^8994^0
"BLD",193,"KRN",.4,"NM","B","XWB SEND API    FILE #8994",1)

"BLD",193,"KRN",.401,0)
.401
"BLD",193,"KRN",.401,"NM",0)
^9.68A^^
"BLD",193,"KRN",.402,0)
.402
"BLD",193,"KRN",.402,"NM",0)
^9.68A^^
"BLD",193,"KRN",.403,0)
.403
"BLD",193,"KRN",.403,"NM",0)
^9.68A^^
"BLD",193,"KRN",.5,0)
.5
"BLD",193,"KRN",.84,0)
.84
"BLD",193,"KRN",3.6,0)
3.6
"BLD",193,"KRN",3.8,0)
3.8
"BLD",193,"KRN",9.2,0)
9.2
"BLD",193,"KRN",9.8,0)
9.8
"BLD",193,"KRN",9.8,"NM",0)
^9.68A^15^11
"BLD",193,"KRN",9.8,"NM",1,0)
XWBBRK^^0^B31134815
"BLD",193,"KRN",9.8,"NM",2,0)
XWBBRK2^^0^B18071177
"BLD",193,"KRN",9.8,"NM",3,0)
XWBFM^^0^B1414006
"BLD",193,"KRN",9.8,"NM",4,0)
XWBTCPC^^0^B39524820
"BLD",193,"KRN",9.8,"NM",6,0)
XWBTCPL^^0^B29185139
"BLD",193,"KRN",9.8,"NM",7,0)
XWBTCP^^0^B36717922
"BLD",193,"KRN",9.8,"NM",10,0)
XWBZ1^^0^B1884371
"BLD",193,"KRN",9.8,"NM",12,0)
XWBLIB^^0^B1021966
"BLD",193,"KRN",9.8,"NM",13,0)
XWBSEC^^0^B2182413
"BLD",193,"KRN",9.8,"NM",14,0)
XWBCAGNT^^0^B5264624
"BLD",193,"KRN",9.8,"NM",15,0)
XWBEXMPL^^0^B2477687
"BLD",193,"KRN",9.8,"NM","B","XWBBRK",1)

"BLD",193,"KRN",9.8,"NM","B","XWBBRK2",2)

"BLD",193,"KRN",9.8,"NM","B","XWBCAGNT",14)

"BLD",193,"KRN",9.8,"NM","B","XWBEXMPL",15)

"BLD",193,"KRN",9.8,"NM","B","XWBFM",3)

"BLD",193,"KRN",9.8,"NM","B","XWBLIB",12)

"BLD",193,"KRN",9.8,"NM","B","XWBSEC",13)

"BLD",193,"KRN",9.8,"NM","B","XWBTCP",7)

"BLD",193,"KRN",9.8,"NM","B","XWBTCPC",4)

"BLD",193,"KRN",9.8,"NM","B","XWBTCPL",6)

"BLD",193,"KRN",9.8,"NM","B","XWBZ1",10)

"BLD",193,"KRN",19,0)
19
"BLD",193,"KRN",19,"NM",0)
^9.68A^5^4
"BLD",193,"KRN",19,"NM",1,0)
XWB EGCHO^^0
"BLD",193,"KRN",19,"NM",3,0)
XWB LISTENER STARTER^^0
"BLD",193,"KRN",19,"NM",4,0)
XWB RPC TEST^^0
"BLD",193,"KRN",19,"NM",5,0)
XWB BROKER EXAMPLE^^0
"BLD",193,"KRN",19,"NM","B","XWB BROKER EXAMPLE",5)

"BLD",193,"KRN",19,"NM","B","XWB EGCHO",1)

"BLD",193,"KRN",19,"NM","B","XWB LISTENER STARTER",3)

"BLD",193,"KRN",19,"NM","B","XWB RPC TEST",4)

"BLD",193,"KRN",19.1,0)
19.1
"BLD",193,"KRN",19.1,"NM",0)
^9.68A^^
"BLD",193,"KRN",101,0)
101
"BLD",193,"KRN",409.61,0)
409.61
"BLD",193,"KRN",771,0)
771
"BLD",193,"KRN",869.2,0)
869.2
"BLD",193,"KRN",870,0)
870
"BLD",193,"KRN",8994,0)
8994
"BLD",193,"KRN",8994,"NM",0)
^9.68A^29^14
"BLD",193,"KRN",8994,"NM",8,0)
XWB FILE LIST^^0
"BLD",193,"KRN",8994,"NM",9,0)
XWB FILENAME CHECK^^0
"BLD",193,"KRN",8994,"NM",10,0)
XWB GET VARIABLE VALUE^^0
"BLD",193,"KRN",8994,"NM",19,0)
XWB CREATE CONTEXT^^0
"BLD",193,"KRN",8994,"NM",20,0)
XWB RPC LIST^^0
"BLD",193,"KRN",8994,"NM",21,0)
XWB EGCHO BIG LIST^^0
"BLD",193,"KRN",8994,"NM",22,0)
XWB EGCHO LIST^^0
"BLD",193,"KRN",8994,"NM",23,0)
XWB EGCHO MEMO^^0
"BLD",193,"KRN",8994,"NM",24,0)
XWB EGCHO SORT LIST^^0
"BLD",193,"KRN",8994,"NM",25,0)
XWB EGCHO STRING^^0
"BLD",193,"KRN",8994,"NM",26,0)
XWB EXAMPLE ECHO STRING^^0
"BLD",193,"KRN",8994,"NM",27,0)
XWB EXAMPLE GET LIST^^0
"BLD",193,"KRN",8994,"NM",28,0)
XWB EXAMPLE SORT NUMBERS^^0
"BLD",193,"KRN",8994,"NM",29,0)
XWB EXAMPLE WPTEXT^^0
"BLD",193,"KRN",8994,"NM","B","XWB CREATE CONTEXT",19)

"BLD",193,"KRN",8994,"NM","B","XWB EGCHO BIG LIST",21)

"BLD",193,"KRN",8994,"NM","B","XWB EGCHO LIST",22)

"BLD",193,"KRN",8994,"NM","B","XWB EGCHO MEMO",23)

"BLD",193,"KRN",8994,"NM","B","XWB EGCHO SORT LIST",24)

"BLD",193,"KRN",8994,"NM","B","XWB EGCHO STRING",25)

"BLD",193,"KRN",8994,"NM","B","XWB EXAMPLE ECHO STRING",26)

"BLD",193,"KRN",8994,"NM","B","XWB EXAMPLE GET LIST",27)

"BLD",193,"KRN",8994,"NM","B","XWB EXAMPLE SORT NUMBERS",28)

"BLD",193,"KRN",8994,"NM","B","XWB EXAMPLE WPTEXT",29)

"BLD",193,"KRN",8994,"NM","B","XWB FILE LIST",8)

"BLD",193,"KRN",8994,"NM","B","XWB FILENAME CHECK",9)

"BLD",193,"KRN",8994,"NM","B","XWB GET VARIABLE VALUE",10)

"BLD",193,"KRN",8994,"NM","B","XWB RPC LIST",20)

"BLD",193,"KRN",8995,0)
8995
"BLD",193,"KRN",8995,"NM",0)
^9.68A^^
"BLD",193,"KRN","B",.4,.4)

"BLD",193,"KRN","B",.401,.401)

"BLD",193,"KRN","B",.402,.402)

"BLD",193,"KRN","B",.403,.403)

"BLD",193,"KRN","B",.5,.5)

"BLD",193,"KRN","B",.84,.84)

"BLD",193,"KRN","B",3.6,3.6)

"BLD",193,"KRN","B",3.8,3.8)

"BLD",193,"KRN","B",9.2,9.2)

"BLD",193,"KRN","B",9.8,9.8)

"BLD",193,"KRN","B",19,19)

"BLD",193,"KRN","B",19.1,19.1)

"BLD",193,"KRN","B",101,101)

"BLD",193,"KRN","B",409.61,409.61)

"BLD",193,"KRN","B",771,771)

"BLD",193,"KRN","B",869.2,869.2)

"BLD",193,"KRN","B",870,870)

"BLD",193,"KRN","B",8994,8994)

"BLD",193,"KRN","B",8995,8995)

"BLD",193,"QUES",0)
^9.62^^
"BLD",193,"REQB",0)
^9.611^^0
"FIA",8994)
REMOTE PROCEDURE
"FIA",8994,0)
^XWB(8994,
"FIA",8994,0,0)
8994
"FIA",8994,0,1)
y^y^f^^^^n
"FIA",8994,0,10)

"FIA",8994,0,11)

"FIA",8994,0,"RLRO")

"FIA",8994,0,"VR")
1.1^RPC BROKER
"FIA",8994,8994)
0
"FIA",8994,8994.01)
0
"FIA",8994,8994.02)
0
"FIA",8994,8994.021)
0
"FIA",8994,8994.03)
0
"FIA",8994.1)
RPC BROKER SITE PARAMETERS
"FIA",8994.1,0)
^XWB(8994.1,
"FIA",8994.1,0,0)
8994.1P
"FIA",8994.1,0,1)
y^y^f^^^^n
"FIA",8994.1,0,10)

"FIA",8994.1,0,11)

"FIA",8994.1,0,"RLRO")

"FIA",8994.1,0,"VR")
1.1^RPC BROKER
"FIA",8994.1,8994.1)
0
"FIA",8994.1,8994.17)
0
"FIA",8994.1,8994.171)
0
"KRN",.4,621,-1)
0^1
"KRN",.4,621,0)
XWB SEND API^2950202^^8994^^^^1
"KRN",.4,621,1,0)
^.41^2^2
"KRN",.4,621,1,1,0)
8994^1^^^^2950202^
"KRN",.4,621,1,1,"F",0)
^.411^9^9
"KRN",.4,621,1,1,"F",1,0)
.01
"KRN",.4,621,1,1,"F",2,0)
.02
"KRN",.4,621,1,1,"F",3,0)
.03
"KRN",.4,621,1,1,"F",4,0)
.04
"KRN",.4,621,1,1,"F",5,0)
.05
"KRN",.4,621,1,1,"F",6,0)
.06
"KRN",.4,621,1,1,"F",7,0)
.07
"KRN",.4,621,1,1,"F",8,0)
1
"KRN",.4,621,1,1,"F",9,0)
3
"KRN",.4,621,1,2,0)
8994.02^2^8994^3^INPUT PARAMETER^2950202^
"KRN",.4,621,1,2,"F",0)
^.411^5^5
"KRN",.4,621,1,2,"F",1,0)
.01
"KRN",.4,621,1,2,"F",2,0)
.02
"KRN",.4,621,1,2,"F",3,0)
.03
"KRN",.4,621,1,2,"F",4,0)
.04
"KRN",.4,621,1,2,"F",5,0)
1
"KRN",.4,621,1,"B",8994,1)

"KRN",.4,621,1,"B",8994.02,2)

"KRN",.4,621,"F",2)
S DIFGT="XWB SEND API",DIFGBFN=8994 D FG^DIFGB;X
"KRN",19,1358,-1)
0^1
"KRN",19,1358,0)
XWB EGCHO^RPC BROKER DEMO/TEST^^B^^^^^^^^
"KRN",19,1358,99.1)
57181,41237
"KRN",19,1358,"RPC",0)
^19.05P^6^6
"KRN",19,1358,"RPC",1,0)
XWB EGCHO LIST
"KRN",19,1358,"RPC",2,0)
XWB EGCHO BIG LIST
"KRN",19,1358,"RPC",3,0)
XWB EGCHO STRING
"KRN",19,1358,"RPC",4,0)
XWB EGCHO MEMO
"KRN",19,1358,"RPC",5,0)
XWB EGCHO SORT LIST
"KRN",19,1358,"RPC",6,0)
XWB GET VARIABLE VALUE
"KRN",19,1358,"U")
RPC BROKER DEMO/TEST
"KRN",19,1420,-1)
0^3
"KRN",19,1420,0)
XWB LISTENER STARTER^Start RPC Broker Listeners^^R^^^^^^^^
"KRN",19,1420,25)
STRTALL^XWBTCP
"KRN",19,1420,200.9)
s
"KRN",19,1420,"U")
START RPC BROKER LISTENERS
"KRN",19,1509,-1)
0^4
"KRN",19,1509,0)
XWB RPC TEST^RPC ^^B^^^^^^^^
"KRN",19,1509,"RPC",0)
^19.05P^2^2
"KRN",19,1509,"RPC",1,0)
XWB GET VARIABLE VALUE
"KRN",19,1509,"RPC",2,0)
XWB EGCHO STRING
"KRN",19,1509,"U")
RPC
"KRN",19,1512,-1)
0^5
"KRN",19,1512,0)
XWB BROKER EXAMPLE^RPC BROKER PROGRAMMING EXAMPLE^^^^^^^^^^
"KRN",19,1512,1,0)
^^21^21^2970903^
"KRN",19,1512,1,1,0)
This option is the RPC Boroker Example appliation context.  RPC Broker
"KRN",19,1512,1,2,0)
Example exists as a teaching tool for someone learning to program using
"KRN",19,1512,1,3,0)
VA Remote Procedure Broker.  The entire application consists of this option,
"KRN",19,1512,1,4,0)
XWBEXMPL routine and
"KRN",19,1512,1,5,0)

"KRN",19,1512,1,6,0)
Remote procedures:
"KRN",19,1512,1,7,0)
     XWB EXAMPLE ECHO STRING
"KRN",19,1512,1,8,0)
     XWB EXAMPLE GET LIST
"KRN",19,1512,1,9,0)
     XWB EXAMPLE SORT NUMBERS
"KRN",19,1512,1,10,0)
     XWB EXAMPLE WPTEXT
"KRN",19,1512,1,11,0)
     XWB GET VARIABLE VALUE
"KRN",19,1512,1,12,0)

"KRN",19,1512,1,13,0)
Delphi Object Pascal source files:
"KRN",19,1512,1,14,0)
     BrokerExample.DPR
"KRN",19,1512,1,15,0)
     BrokerExampleFrm.DFM
"KRN",19,1512,1,16,0)
     BrokerExampleFrm.PAS
"KRN",19,1512,1,17,0)
     BrokerExampleAboutFrm.DFM
"KRN",19,1512,1,18,0)
     BrokerExampleAboutFrm.PAS
"KRN",19,1512,1,19,0)

"KRN",19,1512,1,20,0)
Standard VistA infrastructure including Kernel, ToolKit, FileMan and RPC
"KRN",19,1512,1,21,0)
Broker, is required of course.
"KRN",19,1512,"U")
RPC BROKER PROGRAMMING EXAMPLE
"KRN",8994,1,-1)
0^25
"KRN",8994,1,0)
XWB EGCHO STRING^ECHO1^XWBZ1^1^R
"KRN",8994,1,1,0)
^^2^2^2970825^^
"KRN",8994,1,1,1,0)
This RPC receives a string which will be sent right back to the client.
"KRN",8994,1,1,2,0)
It exists for support of EGcho - Broker demonstration program.
"KRN",8994,1,2,0)
^8994.02A^1^1
"KRN",8994,1,2,1,0)
INP^1^255
"KRN",8994,1,2,"B","INP",1)

"KRN",8994,3,-1)
0^22
"KRN",8994,3,0)
XWB EGCHO LIST^LIST^XWBZ1^2^R
"KRN",8994,3,1,0)
^^2^2^2970825^
"KRN",8994,3,1,1,0)
This RPC brings back a small list of elements to the client.  It exists for
"KRN",8994,3,1,2,0)
support of EGcho - Broker demonstration program.
"KRN",8994,4,-1)
0^21
"KRN",8994,4,0)
XWB EGCHO BIG LIST^BIG^XWBZ1^4^R^^^1
"KRN",8994,4,1,0)
^^2^2^2970825^
"KRN",8994,4,1,1,0)
This RPC brings back a lot of meaningless data to the client.  It exists for
"KRN",8994,4,1,2,0)
support of EGcho - Broker demonstration program.
"KRN",8994,5,-1)
0^24
"KRN",8994,5,0)
XWB EGCHO SORT LIST^SRT^XWBZ1^2^R
"KRN",8994,5,1,0)
^^2^2^2970825^^^
"KRN",8994,5,1,1,0)
Sorts a given numeric array, starting from HI or LO
"KRN",8994,5,1,2,0)
It exists for support of EGcho - Broker demonstration program.
"KRN",8994,5,2,0)
^8994.02A^2^2
"KRN",8994,5,2,1,0)
DIRECTION^1^2^1^1
"KRN",8994,5,2,1,1,0)
^^1^1^2970328^^
"KRN",8994,5,2,1,1,1,0)
The string LO or HI
"KRN",8994,5,2,2,0)
ARRAY^2^^^2
"KRN",8994,5,2,2,1,0)
^^2^2^2970328^^
"KRN",8994,5,2,2,1,1,0)
The array of numbers.  Pass using . syntax
"KRN",8994,5,2,2,1,2,0)
X(12)="",X(23)="",... for example
"KRN",8994,5,2,"B","ARRAY",2)

"KRN",8994,5,2,"B","DIRECTION",1)

"KRN",8994,5,2,"PARAMSEQ",1,1)

"KRN",8994,5,2,"PARAMSEQ",2,2)

"KRN",8994,5,3,0)
^^1^1^2970328^^
"KRN",8994,5,3,1,0)
Sorted array
"KRN",8994,6,-1)
0^23
"KRN",8994,6,0)
XWB EGCHO MEMO^MEMO^XWBZ1^4^R^^^1
"KRN",8994,6,1,0)
^^2^2^2970825^
"KRN",8994,6,1,1,0)
This RPC accepts text from a client which it will send right back to the
"KRN",8994,6,1,2,0)
client.  It exists for support of EGcho - Broker demonstration program.
"KRN",8994,7,-1)
0^8
"KRN",8994,7,0)
XWB FILE LIST^FILELIST^XWBFM^2^R
"KRN",8994,7,2,0)
^8994.02A^1^1
"KRN",8994,7,2,1,0)
START^1
"KRN",8994,7,2,"B","START",1)

"KRN",8994,8,-1)
0^9
"KRN",8994,8,0)
XWB FILENAME CHECK^FILECHK^XWBFM^1^R
"KRN",8994,8,2,0)
^8994.02A^2^2
"KRN",8994,8,2,1,0)
START^1
"KRN",8994,8,2,2,0)
FNAME
"KRN",8994,8,2,"B","FNAME",2)

"KRN",8994,8,2,"B","START",1)

"KRN",8994,9,-1)
0^20
"KRN",8994,9,0)
XWB RPC LIST^APILIST^XWBFM^2^R
"KRN",8994,9,1,0)
^^1^1^2970825^
"KRN",8994,9,1,1,0)
Returns a list of remote procedures from the REMOTE PROCEDURE file.
"KRN",8994,9,2,0)
^8994.02A^1^1
"KRN",8994,9,2,1,0)
START^1
"KRN",8994,9,2,"B","START",1)

"KRN",8994,10,-1)
0^10
"KRN",8994,10,0)
XWB GET VARIABLE VALUE^VARVAL^XWBLIB^1^P
"KRN",8994,10,1,0)
^^3^3^2970825^
"KRN",8994,10,1,1,0)
This RPC accepts the name of a variable which will be evaluated and its
"KRN",8994,10,1,2,0)
value returned to the server.  For example, this RPC may be called with
"KRN",8994,10,1,3,0)
a parameter like DUZ which will be returned as 123456.
"KRN",8994,94,-1)
0^19
"KRN",8994,94,0)
XWB CREATE CONTEXT^CRCONTXT^XWBSEC^1^R
"KRN",8994,94,1,0)
^^18^18^2970825^
"KRN",8994,94,1,1,0)
Establishes context on the server, which will be checked by the Broker before
"KRN",8994,94,1,2,0)
executing any other remote procedure.  Since context is nothing more than a
"KRN",8994,94,1,3,0)
client/server "B"-type option in the OPTION file (#19), standard MenuMan
"KRN",8994,94,1,4,0)
security is applied in establishing a context.  Therefore, a context option
"KRN",8994,94,1,5,0)
can be granted to user(s) exactly the same way as regular options are done
"KRN",8994,94,1,6,0)
using MenuMan.
"KRN",8994,94,1,7,0)

"KRN",8994,94,1,8,0)
A context can not be established for the following reasons:
"KRN",8994,94,1,9,0)

"KRN",8994,94,1,10,0)
       · The user has no access to that option
"KRN",8994,94,1,11,0)

"KRN",8994,94,1,12,0)
       · The option is temporarily out of order
"KRN",8994,94,1,13,0)

"KRN",8994,94,1,14,0)
An application can switch from one context to another as often as it needs to.
"KRN",8994,94,1,15,0)
Each time a context is created the previous context is overwritten.
"KRN",8994,94,1,16,0)

"KRN",8994,94,1,17,0)
For more information on creating a context and the overall Broker security
"KRN",8994,94,1,18,0)
see Broker on-line help documentation.
"KRN",8994,116,-1)
0^26
"KRN",8994,116,0)
XWB EXAMPLE ECHO STRING^ECHOSTR^XWBEXMPL^1^R
"KRN",8994,116,1,0)
^^2^2^2970902^^^
"KRN",8994,116,1,1,0)
This RPC receives a string which will be sent right back to the client.
"KRN",8994,116,1,2,0)
It exists for support of RPC Broker Example program.
"KRN",8994,116,2,0)
^8994.02A^2^2
"KRN",8994,116,2,1,0)
INP^1^255
"KRN",8994,116,2,2,0)
STR^1
"KRN",8994,116,2,"B","INP",1)

"KRN",8994,116,2,"B","STR",2)

"KRN",8994,117,-1)
0^27
"KRN",8994,117,0)
XWB EXAMPLE GET LIST^GETLIST^XWBEXMPL^4^R^^^1
"KRN",8994,117,1,0)
^^3^3^2970902^^
"KRN",8994,117,1,1,0)
This RPC brings back a list of elements to the client.  The user can request
"KRN",8994,117,1,2,0)
either a number of lines or a number of Kilobytes of data to be returned.
"KRN",8994,117,1,3,0)
This RPC exists support of RPC Broker Example program.
"KRN",8994,117,2,0)
^8994.02A^2^2
"KRN",8994,117,2,1,0)
ITEMS^1^^1
"KRN",8994,117,2,1,1,0)
^^3^3^2970902^
"KRN",8994,117,2,1,1,1,0)
This parameter can be only one of two values:
"KRN",8994,117,2,1,1,2,0)
  LINES     - RPC will return a number of lines
"KRN",8994,117,2,1,1,3,0)
  KILOBYTES - RPC will return a number of kilobytes of data
"KRN",8994,117,2,2,0)
QUANTITY^1
"KRN",8994,117,2,2,1,0)
^^1^1^2970902^
"KRN",8994,117,2,2,1,1,0)
Either a number of lines or a number of kilobytes to send back.
"KRN",8994,117,2,"B","ITEMS",1)

"KRN",8994,117,2,"B","QUANTITY",2)

"KRN",8994,119,-1)
0^29
"KRN",8994,119,0)
XWB EXAMPLE WPTEXT^WPTEXT^XWBEXMPL^3^R^^^0
"KRN",8994,120,-1)
0^28
"KRN",8994,120,0)
XWB EXAMPLE SORT NUMBERS^SORTNUM^XWBEXMPL^2^R^^^1
"ORD",5,.4)
.4;5;;;EDEOUT^DIFROMSO(.4,DA,"",XPDA);FPRE^DIFROMSI(.4,"",XPDA);EPRE^DIFROMSI(.4,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.4,DA,"",XPDA);DEL^DIFROMSK(.4,"",%)
"ORD",5,.4,0)
PRINT TEMPLATE
"ORD",16,8994)
8994;16;1;;;;;;;RPCDEL^XPDIA1
"ORD",16,8994,0)
REMOTE PROCEDURE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",285,-1)
1^1
"PKG",285,0)
RPC BROKER^XWB^Remote Procedure Call Broker
"PKG",285,1,0)
^^9^9^2950915^^
"PKG",285,1,1,0)
Remote Procedure Call (RPC) Broker is the software that provides Decentralized
"PKG",285,1,2,0)
Hospital Computer Program (DHCP) its client/server architecture.  The RPC
"PKG",285,1,3,0)
Broker allows workstations running client applications to access DHCP data and
"PKG",285,1,4,0)
methods.
"PKG",285,1,5,0)

"PKG",285,1,6,0)
RPC Broker has a client module which runs on the workstation and a server
"PKG",285,1,7,0)
module which runs on the host computer where the data and business rules
"PKG",285,1,8,0)
reside.  On the client side the Broker works between the applications and the
"PKG",285,1,9,0)
transport protocol.
"PKG",285,5)
San Francisco
"PKG",285,20,0)
^9.402P^^
"PKG",285,22,0)
^9.49I^1^1
"PKG",285,22,1,0)
1.1^2970918
"PKG",285,22,1,1,0)
^^1^1^2970918
"PKG",285,22,1,1,1,0)
RPC BROKER version 1.1
"PKG",285,"DEV")
Enrique Gomez
"PKG",285,"VERSION")
1.1
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
11
"RTN","XWBBRK")
0^1^B31134815
"RTN","XWBBRK",1,0)
XWBBRK ;ISC-SF/EG - DHCP BROKER PROTOYPE ;08/20/96  14:30
"RTN","XWBBRK",2,0)
 ;;1.1;RPC BROKER;;Mar 28, 1997
"RTN","XWBBRK",3,0)
 ;
"RTN","XWBBRK",4,0)
PRSP(P) ;Parse Protocol
"RTN","XWBBRK",5,0)
 ;M Extrinsic Function
"RTN","XWBBRK",6,0)
 ;
"RTN","XWBBRK",7,0)
 ;Inputs
"RTN","XWBBRK",8,0)
 ;P        Protocol string with the form
"RTN","XWBBRK",9,0)
 ;         Protocol := Protocol Header^Message where
"RTN","XWBBRK",10,0)
 ;         Protocol Header := LLLWKID;WINH;PRCH;WISH;MESG
"RTN","XWBBRK",11,0)
 ;           LLL  := length of protocol header (3 numeric)
"RTN","XWBBRK",12,0)
 ;           WKID := Workstation ID (ALPHA)
"RTN","XWBBRK",13,0)
 ;           WINH := Window handle (ALPHA)
"RTN","XWBBRK",14,0)
 ;           PRCH := Process handle (ALPHA)
"RTN","XWBBRK",15,0)
 ;           WISH := Window server handle (ALPHA)
"RTN","XWBBRK",16,0)
 ;           MESG := Unparsed message
"RTN","XWBBRK",17,0)
 ;Outputs
"RTN","XWBBRK",18,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",19,0)
 ;
"RTN","XWBBRK",20,0)
 N ERR,C,M,R,X,U
"RTN","XWBBRK",21,0)
 S U="U",R=0,C=";",ERR=0,M=512 ;Maximum buffer input
"RTN","XWBBRK",22,0)
 IF $E(P,1,5)="{XWB}" S P=$E(P,6,$L(P)) ;drop out prefix
"RTN","XWBBRK",23,0)
 IF '+$G(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",24,0)
 IF +ERR=0 D
"RTN","XWBBRK",25,0)
 . S XWB(R,"LENG")=+$E(P,1,3)
"RTN","XWBBRK",26,0)
 . S X=$E(P,4,XWB(R,"LENG")+3)
"RTN","XWBBRK",27,0)
 . S XWB(R,"MESG")=$E(P,XWB(R,"LENG")+4,M)
"RTN","XWBBRK",28,0)
 . S XWB(R,"WKID")=$P(X,C)
"RTN","XWBBRK",29,0)
 . S XWB(R,"WINH")=$P(X,C,2)
"RTN","XWBBRK",30,0)
 . S XWB(R,"PRCH")=$P(X,C,3)
"RTN","XWBBRK",31,0)
 . S XWB(R,"WISH")=$P(X,C,4)
"RTN","XWBBRK",32,0)
 Q ERR
"RTN","XWBBRK",33,0)
 ;
"RTN","XWBBRK",34,0)
PRSM(P) ;Parse message
"RTN","XWBBRK",35,0)
 ;M Extrinsic Function
"RTN","XWBBRK",36,0)
 ;
"RTN","XWBBRK",37,0)
 ;Inputs
"RTN","XWBBRK",38,0)
 ;P        Message string with the form
"RTN","XWBBRK",39,0)
 ;         Message := Header^Content
"RTN","XWBBRK",40,0)
 ;           Header  := LLL;FLAG
"RTN","XWBBRK",41,0)
 ;             LLL     := length of entire message (3 numeric)
"RTN","XWBBRK",42,0)
 ;             FLAG    := 1 indicates variables follow
"RTN","XWBBRK",43,0)
 ;           Content := Contains API call information
"RTN","XWBBRK",44,0)
 ;Outputs
"RTN","XWBBRK",45,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",46,0)
 N C,ERR,M,R,X,U
"RTN","XWBBRK",47,0)
 S U="^",R=1,C=";",ERR=0,M=512 ;Max buffer
"RTN","XWBBRK",48,0)
 IF '+$G(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",49,0)
 IF +ERR=0 D
"RTN","XWBBRK",50,0)
 . S XWB(R,"LENG")=+$E(P,1,5)
"RTN","XWBBRK",51,0)
 . S XWB(R,"FLAG")=$E(P,6,6)
"RTN","XWBBRK",52,0)
 . S XWB(R,"TEXT")=$E(P,7,M)
"RTN","XWBBRK",53,0)
 Q ERR
"RTN","XWBBRK",54,0)
 ;
"RTN","XWBBRK",55,0)
PRSA(P) ;Parse API information, get calling info
"RTN","XWBBRK",56,0)
 ;M Extrinsic Function
"RTN","XWBBRK",57,0)
 ;Inputs
"RTN","XWBBRK",58,0)
 ;P        Content := API Name^Param string
"RTN","XWBBRK",59,0)
 ;           API     := .01 field of API file
"RTN","XWBBRK",60,0)
 ;           Param   := Parameter information
"RTN","XWBBRK",61,0)
 ;Outputs
"RTN","XWBBRK",62,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",63,0)
 ;
"RTN","XWBBRK",64,0)
 N C,DR,ERR,M,R,T,X,U
"RTN","XWBBRK",65,0)
 S U="^",R=2,C=";",ERR=0,M=512 ;Max buffer
"RTN","XWBBRK",66,0)
 IF '+$L(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",67,0)
 IF +ERR=0 D
"RTN","XWBBRK",68,0)
 . S XWB(R,"CAPI")=$P(P,U)
"RTN","XWBBRK",69,0)
 . S XWB(R,"PARM")=$E(P,$F(P,U),M)
"RTN","XWBBRK",70,0)
 . S T=$O(^XWB(8994,"B",XWB(R,"CAPI"),0))
"RTN","XWBBRK",71,0)
 . S T(0)=$G(^XWB(8994,T,0))
"RTN","XWBBRK",72,0)
 . S XWB(R,"NAME")=$P(T(0),"^")
"RTN","XWBBRK",73,0)
 . S XWB(R,"RTAG")=$P(T(0),"^",2)
"RTN","XWBBRK",74,0)
 . S XWB(R,"RNAM")=$P(T(0),"^",3)
"RTN","XWBBRK",75,0)
 . S XWBPTYPE=$P(T(0),"^",4)
"RTN","XWBBRK",76,0)
 . S XWBWRAP=+$P(T(0),"^",8)
"RTN","XWBBRK",77,0)
 Q ERR
"RTN","XWBBRK",78,0)
 ;
"RTN","XWBBRK",79,0)
PRSB(P) ;Parse Parameter information
"RTN","XWBBRK",80,0)
 ;M Extrinsic Function
"RTN","XWBBRK",81,0)
 ;Inputs
"RTN","XWBBRK",82,0)
 ;P        Param   := M parameter list
"RTN","XWBBRK",83,0)
 ;           Param   := LLL,Name,Value
"RTN","XWBBRK",84,0)
 ;             LLL     := length of variable name and value
"RTN","XWBBRK",85,0)
 ;             Name    := name of M variable
"RTN","XWBBRK",86,0)
 ;             Value   := a string
"RTN","XWBBRK",87,0)
 ;Outputs
"RTN","XWBBRK",88,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",89,0)
 ;
"RTN","XWBBRK",90,0)
 N A,ERR,F,FL,I,K,L,M,P1,P2,P3,P4,P5,MAXP,R
"RTN","XWBBRK",91,0)
 S R=3,MAXP=+$E(P,1,5)
"RTN","XWBBRK",92,0)
 S P1=$E(P,6,MAXP+5) ;only param string
"RTN","XWBBRK",93,0)
 S ERR=0,F=3,M=512
"RTN","XWBBRK",94,0)
 IF '+$D(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",95,0)
 S FL=+$G(XWB(1,"FLAG"))
"RTN","XWBBRK",96,0)
 S I=0
"RTN","XWBBRK",97,0)
 IF '+ERR D
"RTN","XWBBRK",98,0)
 . ;IF 'FL S P1=$E(P,F+1,MAXP) Q
"RTN","XWBBRK",99,0)
 . IF 'FL,+MAXP=0 S P1="",ERR=1 Q
"RTN","XWBBRK",100,0)
 . F  D  Q:P1=""
"RTN","XWBBRK",101,0)
 . . Q:P1=""
"RTN","XWBBRK",102,0)
 . . S L=+$E(P1,1,3)-1
"RTN","XWBBRK",103,0)
 . . S P3=+$E(P1,4,4)
"RTN","XWBBRK",104,0)
 . . S P1=$E(P1,5,MAXP)
"RTN","XWBBRK",105,0)
 . . S XWB(R,"P",I)=$S(P3'=1:$E(P1,1,L),1:$$GETV($E(P1,1,L)))
"RTN","XWBBRK",106,0)
 . . IF FL=1 D
"RTN","XWBBRK",107,0)
 . . . S A=$$OARY^XWBBRK2,XWBARY=A
"RTN","XWBBRK",108,0)
 . . . S XWB(R,"P",I)=$$CREF^XWBBRK2(A,XWB(R,"P",I))
"RTN","XWBBRK",109,0)
 . . S P1=$E(P1,L+1,MAXP)
"RTN","XWBBRK",110,0)
 . . S K=I,I=I+1
"RTN","XWBBRK",111,0)
 . IF 'FL Q
"RTN","XWBBRK",112,0)
 . S P3=P
"RTN","XWBBRK",113,0)
 . S L=+$E(P3,1,5)
"RTN","XWBBRK",114,0)
 . S P1=$E(P3,F+3,L+F)
"RTN","XWBBRK",115,0)
 . ;IF FL=1 S P1=$$CREF^XWBBRK2(A,P1) ;convert array ref to namespace ref
"RTN","XWBBRK",116,0)
 . S P2=$E(P3,L+F+3,M)
"RTN","XWBBRK",117,0)
 . ;instantiate array
"RTN","XWBBRK",118,0)
 . ;S DM=0
"RTN","XWBBRK",119,0)
 . F  D  Q:+L=0
"RTN","XWBBRK",120,0)
 . . S L=$$BREAD(3) Q:+L=0  S P3=$$BREAD(L)
"RTN","XWBBRK",121,0)
 . . S L=$$BREAD(3) IF +L'=0 S P4=$$BREAD(L)
"RTN","XWBBRK",122,0)
 . . IF +L=0 Q
"RTN","XWBBRK",123,0)
 . . ;E  S L=3,P4=$$BREAD(L) IF P4=0 S P4=""
"RTN","XWBBRK",124,0)
 . . IF P3=0,P4=0 S L=0 Q
"RTN","XWBBRK",125,0)
 . . IF FL=1 D LINST(A,P3,P4)
"RTN","XWBBRK",126,0)
 . . IF FL=2 D GINST
"RTN","XWBBRK",127,0)
 . . ;S DM=DM+1
"RTN","XWBBRK",128,0)
 IF ERR Q P1
"RTN","XWBBRK",129,0)
 S P1=""
"RTN","XWBBRK",130,0)
 D  Q P1
"RTN","XWBBRK",131,0)
 . F I=0:1:K D
"RTN","XWBBRK",132,0)
 . . IF FL,$E(XWB(R,"P",I),1,1)="." D  Q
"RTN","XWBBRK",133,0)
 . . . S P1=P1_"."_$E(XWB(R,"P",I),2,$L(XWB(R,"P",I)))
"RTN","XWBBRK",134,0)
 . . . IF I'=K S P1=P1_","
"RTN","XWBBRK",135,0)
 . . S P1=P1_"XWB("_R_",""P"","_I_")"
"RTN","XWBBRK",136,0)
 . . IF I'=K S P1=P1_","
"RTN","XWBBRK",137,0)
 IF '+ERR Q P1
"RTN","XWBBRK",138,0)
 Q ERR
"RTN","XWBBRK",139,0)
 ;
"RTN","XWBBRK",140,0)
BREAD(L) ;read tcp buffer, L is length
"RTN","XWBBRK",141,0)
 N E,X,DONE
"RTN","XWBBRK",142,0)
 S (E,DONE)=0
"RTN","XWBBRK",143,0)
 R X#L:XWBTIME
"RTN","XWBBRK",144,0)
 S E=X
"RTN","XWBBRK",145,0)
 IF $L(E)<L F  D  Q:'DONE
"RTN","XWBBRK",146,0)
 . IF $L(E)=L S DONE=1 Q
"RTN","XWBBRK",147,0)
 . R X#(L-$L(E)):XWBTIME
"RTN","XWBBRK",148,0)
 . S E=E_X
"RTN","XWBBRK",149,0)
 Q E
"RTN","XWBBRK",150,0)
 ;
"RTN","XWBBRK",151,0)
CALLP(XWBP,P,DEBUG) ;make API call using Protocol string
"RTN","XWBBRK",152,0)
 N ERR,S
"RTN","XWBBRK",153,0)
 S ERR=0
"RTN","XWBBRK",154,0)
 IF '$D(DEBUG) S DEBUG=0
"RTN","XWBBRK",155,0)
 IF 'DEBUG D:$D(XRTL) T0^%ZOSV ;start RTL
"RTN","XWBBRK",156,0)
 S ERR=$$PRSP^XWBBRK(P)
"RTN","XWBBRK",157,0)
 IF '+ERR S ERR=$$PRSM^XWBBRK(XWB(0,"MESG"))
"RTN","XWBBRK",158,0)
 IF '+ERR S ERR=$$PRSA^XWBBRK(XWB(1,"TEXT"))
"RTN","XWBBRK",159,0)
 IF '+ERR S S=$$PRSB^XWBBRK(XWB(2,"PARM"))
"RTN","XWBBRK",160,0)
 ;IF (+S=0)!(+S>0) D
"RTN","XWBBRK",161,0)
 D CHKPRMIT^XWBSEC(XWB(2,"CAPI")) ;checks if RPC allowed to run
"RTN","XWBBRK",162,0)
 S:$L(XWBSEC) ERR="-1^"_XWBSEC
"RTN","XWBBRK",163,0)
 IF 'DEBUG S:$D(XRT0) XRTN="RPC BROKER READ/PARSE" D:$D(XRT0) T1^%ZOSV ;stop RTL
"RTN","XWBBRK",164,0)
 IF '+ERR,(+S=0)!(+S>0) D
"RTN","XWBBRK",165,0)
 . D CAPI^XWBBRK2(.XWBP,XWB(2,"RTAG"),XWB(2,"RNAM"),S)
"RTN","XWBBRK",166,0)
 IF 'DEBUG K XWB
"RTN","XWBBRK",167,0)
 IF $D(XWBARY) K @XWBARY,XWBARY
"RTN","XWBBRK",168,0)
 Q
"RTN","XWBBRK",169,0)
 ;
"RTN","XWBBRK",170,0)
LINST(A,X,XWBY) ;instantiate local array
"RTN","XWBBRK",171,0)
 IF XWBY=$C(1) S XWBY=""
"RTN","XWBBRK",172,0)
 S X=A_"("_X_")"
"RTN","XWBBRK",173,0)
 S @X=XWBY
"RTN","XWBBRK",174,0)
 Q
"RTN","XWBBRK",175,0)
GINST ;instantiate global
"RTN","XWBBRK",176,0)
 N DONE,N,T,T1
"RTN","XWBBRK",177,0)
 S (DONE,I)=0
"RTN","XWBBRK",178,0)
 ;find piece with global ref - recover $C(44)
"RTN","XWBBRK",179,0)
 S REF=$TR(REF,$C(23),$C(44))
"RTN","XWBBRK",180,0)
 F  D  Q:DONE
"RTN","XWBBRK",181,0)
 . S N=$NA(^TMP("XWB",$J,$P($H,",",2)))
"RTN","XWBBRK",182,0)
 . S XWB("FRM")=REF
"RTN","XWBBRK",183,0)
 . S XWB("TO")=N
"RTN","XWBBRK",184,0)
 . IF '$D(@N) S DONE=1 Q
"RTN","XWBBRK",185,0)
 ;loop through all and instantiate
"RTN","XWBBRK",186,0)
 S DONE=0
"RTN","XWBBRK",187,0)
 F  D  Q:DONE
"RTN","XWBBRK",188,0)
 . S T=$E(@REF@(I),4,M)
"RTN","XWBBRK",189,0)
 . IF T="" S DONE=1 Q
"RTN","XWBBRK",190,0)
 . S @N@("XWB")="" ;set naked indicator
"RTN","XWBBRK",191,0)
 . S @T
"RTN","XWBBRK",192,0)
 . S I=I+1
"RTN","XWBBRK",193,0)
 K @N@("XWB")
"RTN","XWBBRK",194,0)
 Q
"RTN","XWBBRK",195,0)
 ;
"RTN","XWBBRK",196,0)
GETV(V) ;get value of V - reference parameter
"RTN","XWBBRK",197,0)
 N X
"RTN","XWBBRK",198,0)
 S X=V
"RTN","XWBBRK",199,0)
 IF $E(X,1,2)="$$" Q ""
"RTN","XWBBRK",200,0)
 IF $C(34,36)[$E(V) X "S V="_$$VCHK(V)
"RTN","XWBBRK",201,0)
 E  S V=@V
"RTN","XWBBRK",202,0)
 Q V
"RTN","XWBBRK",203,0)
 ;
"RTN","XWBBRK",204,0)
VCHK(S) ;Parse string for first argument
"RTN","XWBBRK",205,0)
 N C,I,P
"RTN","XWBBRK",206,0)
 F I=1:1 S C=$E(S,I) D VCHKP:C="(",VCHKQ:C=$C(34) Q:" ,"[C
"RTN","XWBBRK",207,0)
 Q $E(S,1,I-1)
"RTN","XWBBRK",208,0)
VCHKP S P=1 ;Find closing paren
"RTN","XWBBRK",209,0)
 F I=I+1:1 S C=$E(S,I) Q:P=0!(C="")  I "()"""[C D VCHKQ:C=$C(34) S P=P+$S("("[C:1,")"[C:-1,1:0)
"RTN","XWBBRK",210,0)
 Q
"RTN","XWBBRK",211,0)
VCHKQ ;Find closing quote
"RTN","XWBBRK",212,0)
 F I=I+1:1 S C=$E(S,I) Q:C=""!(C=$C(34))
"RTN","XWBBRK",213,0)
 Q
"RTN","XWBBRK2")
0^2^B18071177
"RTN","XWBBRK2",1,0)
XWBBRK2 ;ISC-SF/EG - DHCP BROKER PROTOYPE [ 02/08/95  2:57 PM ] ;08/20/96  14:59
"RTN","XWBBRK2",2,0)
 ;;1.1;RPC BROKER;;Mar 28, 1997
"RTN","XWBBRK2",3,0)
CAPI(XWBY,TAG,NAM,PAR) ;make API call
"RTN","XWBBRK2",4,0)
 N R,T,DX,DY
"RTN","XWBBRK2",5,0)
 IF XWB(1,"FLAG")=2 D
"RTN","XWBBRK2",6,0)
 . S PAR=$P(PAR,XWB("FRM"))_XWB("TO")_$P(PAR,XWB("FRM"),2)
"RTN","XWBBRK2",7,0)
 S R=$S(PAR'=+PAR&(PAR=""):TAG_"^"_NAM_"(.XWBY)",1:TAG_"^"_NAM_"(.XWBY,"_PAR_")")
"RTN","XWBBRK2",8,0)
 D:$D(XRTL) T0^%ZOSV ;start RTL
"RTN","XWBBRK2",9,0)
 U XWBNULL
"RTN","XWBBRK2",10,0)
 D @R
"RTN","XWBBRK2",11,0)
 S:$D(XRT0) XRTN=XWB(2,"NAME") D:$D(XRT0) T1^%ZOSV ;stop RTL
"RTN","XWBBRK2",12,0)
 ;once call is completed, write buffer should be empty, make it so!
"RTN","XWBBRK2",13,0)
 U XWBNULL S DX=0,DY=0 X ^%ZOSF("XY")
"RTN","XWBBRK2",14,0)
 U XWBTDEV
"RTN","XWBBRK2",15,0)
 Q
"RTN","XWBBRK2",16,0)
 ;
"RTN","XWBBRK2",17,0)
BHDR(WKID,WINH,PRCH,WISH) ;Build a protocol header
"RTN","XWBBRK2",18,0)
 N S,L
"RTN","XWBBRK2",19,0)
 S S=""
"RTN","XWBBRK2",20,0)
 S S=WKID_";"_WINH_";"_PRCH_";"_WISH_";"
"RTN","XWBBRK2",21,0)
 S L=$L(S)
"RTN","XWBBRK2",22,0)
 S S=$E("000"_L,$L(L)+1,$L(L)+3)_S
"RTN","XWBBRK2",23,0)
 Q S
"RTN","XWBBRK2",24,0)
 ;
"RTN","XWBBRK2",25,0)
BARY(A,R,V) ;add array elements+values to storage array
"RTN","XWBBRK2",26,0)
 IF A'["XWBS" Q "-1^ARRAY NAME MUST BE XWBS"
"RTN","XWBBRK2",27,0)
 S @A@(R)=V
"RTN","XWBBRK2",28,0)
 Q 0
"RTN","XWBBRK2",29,0)
 ;
"RTN","XWBBRK2",30,0)
BLDB(P) ;Build formatted string
"RTN","XWBBRK2",31,0)
 N L
"RTN","XWBBRK2",32,0)
 S L=$L(P)
"RTN","XWBBRK2",33,0)
 Q $E("000"_L,$L(L)+1,$L(L)+3)_P
"RTN","XWBBRK2",34,0)
 ;
"RTN","XWBBRK2",35,0)
BLDA(N,P) ;Build API string
"RTN","XWBBRK2",36,0)
 ;M Extrinsic Function
"RTN","XWBBRK2",37,0)
 ;Inputs
"RTN","XWBBRK2",38,0)
 ;N        API name
"RTN","XWBBRK2",39,0)
 ;P        Comma delimited parameter string
"RTN","XWBBRK2",40,0)
 ;Outputs
"RTN","XWBBRK2",41,0)
 ;String   API string if successful, "-1^Text" if error
"RTN","XWBBRK2",42,0)
 ;
"RTN","XWBBRK2",43,0)
 N I,F,L,T,U,T1,T2
"RTN","XWBBRK2",44,0)
 IF '+$D(N) Q "-1^Required input reference is NULL"
"RTN","XWBBRK2",45,0)
 S U="^"
"RTN","XWBBRK2",46,0)
 S (F,T,Y)=0
"RTN","XWBBRK2",47,0)
 IF '$D(P) S P=""
"RTN","XWBBRK2",48,0)
 IF P'="" D
"RTN","XWBBRK2",49,0)
 . S L=$L(P)-$L($TR(P,$C(44)))+1
"RTN","XWBBRK2",50,0)
 . IF L=0 S L=1
"RTN","XWBBRK2",51,0)
 . F I=1:1:L D  Q:T
"RTN","XWBBRK2",52,0)
 . . S T1=$P(P,",",I)
"RTN","XWBBRK2",53,0)
 . . S T2=$E(T1,1,1)="."
"RTN","XWBBRK2",54,0)
 . . IF T1=+T1 Q
"RTN","XWBBRK2",55,0)
 . . IF $E(T1,1,1)="^" S F=2,T=1 Q
"RTN","XWBBRK2",56,0)
 . . ;IF $E(T1,1,5)="$NA(^" S F=2,T=1 Q
"RTN","XWBBRK2",57,0)
 . . IF T2&($E(T1,2,$L(T1))?.ANP) S F=1,T=1 Q
"RTN","XWBBRK2",58,0)
 ;IF P?.ANP1"."1A.ANP S F=1
"RTN","XWBBRK2",59,0)
 S P=$$BLDB(P)
"RTN","XWBBRK2",60,0)
 S L=$L(P)+$L(P)-3
"RTN","XWBBRK2",61,0)
 S P=F_N_U_P
"RTN","XWBBRK2",62,0)
 S L=$L(P)
"RTN","XWBBRK2",63,0)
 Q $E("000"_L,$L(L)+1,$L(L)+3)_P
"RTN","XWBBRK2",64,0)
 ;
"RTN","XWBBRK2",65,0)
BLDS(R) ;Build a parameter string from an array
"RTN","XWBBRK2",66,0)
 N L,T,Y
"RTN","XWBBRK2",67,0)
 S Y=""
"RTN","XWBBRK2",68,0)
 F  D  Q:R=""
"RTN","XWBBRK2",69,0)
 . S R=$Q(@R)
"RTN","XWBBRK2",70,0)
 . IF R="" Q
"RTN","XWBBRK2",71,0)
 . S L=$L(R)+$L(@R)+1
"RTN","XWBBRK2",72,0)
 . S T=@R
"RTN","XWBBRK2",73,0)
 . S T=$TR(T,$C(44),$C(23))
"RTN","XWBBRK2",74,0)
 . S Y=Y_$E("000"_L,$L(L)+1,$L(L)+3)_R_"="_T
"RTN","XWBBRK2",75,0)
 Q Y_"000"
"RTN","XWBBRK2",76,0)
 ;
"RTN","XWBBRK2",77,0)
BLDU(R) ;Build a parameter string from a scalar
"RTN","XWBBRK2",78,0)
 N DONE,L,N,N1,P1
"RTN","XWBBRK2",79,0)
 IF R=+R Q R
"RTN","XWBBRK2",80,0)
 S N=$F(R,$C(34))
"RTN","XWBBRK2",81,0)
 IF N=0 Q $C(34)_R_$C(34)
"RTN","XWBBRK2",82,0)
 S P1=$E(R,1,N-2)
"RTN","XWBBRK2",83,0)
 S (L,DONE)=0
"RTN","XWBBRK2",84,0)
 F  D  Q:DONE
"RTN","XWBBRK2",85,0)
 . S N1=$F(R,$C(34),N)
"RTN","XWBBRK2",86,0)
 . IF N1=0 S L=$L(R)+2,N1=L
"RTN","XWBBRK2",87,0)
 . S P1=P1_$C(34,34)_$E(R,N,N1-2)
"RTN","XWBBRK2",88,0)
 . IF N1=L S DONE=1,P1=$C(34)_P1_$C(34) Q
"RTN","XWBBRK2",89,0)
 . S N=N1
"RTN","XWBBRK2",90,0)
 Q $TR(P1,$C(44),$C(23))
"RTN","XWBBRK2",91,0)
 ;
"RTN","XWBBRK2",92,0)
BLDG(R) ;build a parameter string from a global reference
"RTN","XWBBRK2",93,0)
 N I,L,L1,M,T,T1,T2,Y
"RTN","XWBBRK2",94,0)
 K ^TMP("XWB",$J)
"RTN","XWBBRK2",95,0)
 IF '$D(R) Q "-1^Reference does not exist"
"RTN","XWBBRK2",96,0)
 S Y=$NA(^TMP("XWB",$J,$P($H,",",2)))
"RTN","XWBBRK2",97,0)
 S I=0
"RTN","XWBBRK2",98,0)
 S M=512
"RTN","XWBBRK2",99,0)
 S T1=$P(R,")")
"RTN","XWBBRK2",100,0)
 S L1=$L($P(R,"("))
"RTN","XWBBRK2",101,0)
 F  D  Q:R=""
"RTN","XWBBRK2",102,0)
 . S R=$Q(@R)
"RTN","XWBBRK2",103,0)
 . S T2=$F(R,"(")
"RTN","XWBBRK2",104,0)
 . IF R=""!(R'[T1) Q
"RTN","XWBBRK2",105,0)
 . S L=$L(R)+$L(@R)-L1
"RTN","XWBBRK2",106,0)
 . S T=@R
"RTN","XWBBRK2",107,0)
 . S T=$TR(T,$C(44),$C(23))
"RTN","XWBBRK2",108,0)
 . S @Y@(I)=$E("000"_L,$L(L)+1,$L(L)+3)_"^("_$E(R,T2,M)_"="_$$BLDU(T)
"RTN","XWBBRK2",109,0)
 . S I=I+1
"RTN","XWBBRK2",110,0)
 S @Y@(I)="000"
"RTN","XWBBRK2",111,0)
 S Y=$TR(Y,$C(44),$C(23))
"RTN","XWBBRK2",112,0)
 Q Y
"RTN","XWBBRK2",113,0)
 ;
"RTN","XWBBRK2",114,0)
OARY() ;create storage array
"RTN","XWBBRK2",115,0)
 N A,DONE,I
"RTN","XWBBRK2",116,0)
 S (DONE,I)=0
"RTN","XWBBRK2",117,0)
 F I=1:1 D  Q:DONE
"RTN","XWBBRK2",118,0)
 . S A="XWBS"_I
"RTN","XWBBRK2",119,0)
 . K @A ;temp fix for single array
"RTN","XWBBRK2",120,0)
 . IF '$D(@A) S DONE=1
"RTN","XWBBRK2",121,0)
 ;S Y("XWBS")=A
"RTN","XWBBRK2",122,0)
 S @A="" ;set naked
"RTN","XWBBRK2",123,0)
 Q A
"RTN","XWBBRK2",124,0)
 ;
"RTN","XWBBRK2",125,0)
CREF(R,P) ;Convert array contained in P to reference A
"RTN","XWBBRK2",126,0)
 N I,X,DONE,F1,S
"RTN","XWBBRK2",127,0)
 S DONE=0
"RTN","XWBBRK2",128,0)
 S S=""
"RTN","XWBBRK2",129,0)
 F I=1:1  D  Q:DONE
"RTN","XWBBRK2",130,0)
 . IF $P(P,",",I)="" S DONE=1 Q
"RTN","XWBBRK2",131,0)
 . S X(I)=$P(P,",",I)
"RTN","XWBBRK2",132,0)
 . IF X(I)?1"."1A.E D
"RTN","XWBBRK2",133,0)
 . . S F1=$F(X(I),".")
"RTN","XWBBRK2",134,0)
 . . S X(I)="."_R
"RTN","XWBBRK2",135,0)
 . S S=S_X(I)_","
"RTN","XWBBRK2",136,0)
 Q $E(S,1,$L(S)-1)
"RTN","XWBBRK2",137,0)
 ;
"RTN","XWBBRK2",138,0)
GETP(P) ;returns various parameters out of the Protocol string
"RTN","XWBBRK2",139,0)
 N M,T,XWB
"RTN","XWBBRK2",140,0)
 S M=512
"RTN","XWBBRK2",141,0)
 S T=$$PRSP^XWBBRK(P)
"RTN","XWBBRK2",142,0)
 IF '+T D
"RTN","XWBBRK2",143,0)
 . S T=$$PRSM^XWBBRK(XWB(0,"MESG"))
"RTN","XWBBRK2",144,0)
 . IF '+T S T=XWB(0,"WKID")_";"_XWB(0,"WINH")_";"_XWB(0,"PRCH")_";"_XWB(0,"WISH")_";"_$P(XWB(1,"TEXT"),"^")
"RTN","XWBBRK2",145,0)
 Q T
"RTN","XWBBRK2",146,0)
 ;
"RTN","XWBBRK2",147,0)
CALLM(X,P,DEBUG) ;make call using Message string
"RTN","XWBBRK2",148,0)
 N ERR,S
"RTN","XWBBRK2",149,0)
 S X="",ERR=0
"RTN","XWBBRK2",150,0)
 S ERR=$$PRSM^XWBBRK(P)
"RTN","XWBBRK2",151,0)
 IF '+ERR S ERR=$$PRSA^XWBBRK(XWB(1,"TEXT"))
"RTN","XWBBRK2",152,0)
 IF '+ERR S S=$$PRSB^XWBBRK(XWB(2,"PARM"))
"RTN","XWBBRK2",153,0)
 IF (+S=0)!(+S>0) D
"RTN","XWBBRK2",154,0)
 . D CAPI(.X,XWB(2,"RTAG"),XWB(2,"RNAM"),S)
"RTN","XWBBRK2",155,0)
 IF 'DEBUG K XWB
"RTN","XWBBRK2",156,0)
 K @(X("XWBS")),X("XWBS")
"RTN","XWBBRK2",157,0)
 Q
"RTN","XWBBRK2",158,0)
 ;
"RTN","XWBBRK2",159,0)
CALLA(X,P,DEBUG) ;make call using API string
"RTN","XWBBRK2",160,0)
 N ERR,S
"RTN","XWBBRK2",161,0)
 S X="",ERR=0
"RTN","XWBBRK2",162,0)
 S ERR=$$PRSA^XWBBRK(P)
"RTN","XWBBRK2",163,0)
 IF '+ERR S S=$$PRSB^XWBBRK(XWB(2,"PARM"))
"RTN","XWBBRK2",164,0)
 IF (+S=0)!(+S>0) D
"RTN","XWBBRK2",165,0)
 . D CAPI(.X,XWB(2,"RTAG"),XWB(2,"RNAM"),S)
"RTN","XWBBRK2",166,0)
 IF 'DEBUG K XWB
"RTN","XWBBRK2",167,0)
 K @(X("XWBS")),X("XWBS")
"RTN","XWBBRK2",168,0)
 Q
"RTN","XWBBRK2",169,0)
 ;
"RTN","XWBBRK2",170,0)
TRANSPRT() ;Determine the Transport Method
"RTN","XWBBRK2",171,0)
 ;DDP is local :=0
"RTN","XWBBRK2",172,0)
 ;TCP/IP is remote :=1
"RTN","XWBBRK2",173,0)
 ;Serial/RS-232 is remote :=2
"RTN","XWBBRK2",174,0)
 Q 1
"RTN","XWBBRK2",175,0)
 ;Q 0 ;Do DDP for Now
"RTN","XWBCAGNT")
0^14^B5264624
"RTN","XWBCAGNT",1,0)
XWBCAGNT ;ISC-SF/EG,RWF - Connect to Remote TCP Client Agent ;09/18/97  14:16
"RTN","XWBCAGNT",2,0)
 ;;1.1;RPC BROKER;;Mar 28, 1997
"RTN","XWBCAGNT",3,0)
 Q
"RTN","XWBCAGNT",4,0)
 ;
"RTN","XWBCAGNT",5,0)
CMD(XWBRET,QUES,PARAM) ;Call daemon and get responce <e.f.>
"RTN","XWBCAGNT",6,0)
 N IPA,SOCK S XWBRET="",IPA=$G(IO("IP")),SOCK=9200 Q:IPA="" 0
"RTN","XWBCAGNT",7,0)
 I $G(IO)="" D HOME^%ZIS
"RTN","XWBCAGNT",8,0)
 D CALL^%ZISTCP(IPA,SOCK,3) I POP Q 0
"RTN","XWBCAGNT",9,0)
 D SEND(QUES,$G(PARAM)),REC(.XWBRET)
"RTN","XWBCAGNT",10,0)
 D CLOSE^%ZISTCP
"RTN","XWBCAGNT",11,0)
 Q 1
"RTN","XWBCAGNT",12,0)
 ;
"RTN","XWBCAGNT",13,0)
OPEN(IP,SKT) ; - connect to remote <extrinsic function>
"RTN","XWBCAGNT",14,0)
 D HOME^%ZIS:'$D(IO(0)),SAVDEV^%ZISUTL("XWBCAGENT HOME")
"RTN","XWBCAGNT",15,0)
 D CALL^%ZISTCP(IP,SKT,3)
"RTN","XWBCAGNT",16,0)
 Q
"RTN","XWBCAGNT",17,0)
 ;
"RTN","XWBCAGNT",18,0)
SEND(S,P) ; - send message <procedure>
"RTN","XWBCAGNT",19,0)
 N $ETRAP S $ETRAP="S $EC="""" Q"
"RTN","XWBCAGNT",20,0)
 S S=$$SETMSG(S,$G(P))
"RTN","XWBCAGNT",21,0)
 U IO W S,!
"RTN","XWBCAGNT",22,0)
 Q
"RTN","XWBCAGNT",23,0)
 ;
"RTN","XWBCAGNT",24,0)
REC(BODY) ; - receive message <extrinsic function>
"RTN","XWBCAGNT",25,0)
 N LEN,Y
"RTN","XWBCAGNT",26,0)
 U IO S BODY("HDR")="~",BODY("HDR")=$$SREAD(5) ; -- get header
"RTN","XWBCAGNT",27,0)
 Q:BODY("HDR")'="{XWB}"  ; -- quit if no responce
"RTN","XWBCAGNT",28,0)
 S LEN=$$SREAD(5),BODY("ID")=$$SREAD(+LEN) ; -- get PID
"RTN","XWBCAGNT",29,0)
 S LEN=$$SREAD(5),BODY(0)=$$SREAD(+LEN) ; -- get rpc name
"RTN","XWBCAGNT",30,0)
 S LEN=$$SREAD(5) D:+LEN BREAD(+LEN,.BODY) ; -- get rpc parameter
"RTN","XWBCAGNT",31,0)
 S LEN=$$SREAD(1) ; -- read terminator
"RTN","XWBCAGNT",32,0)
 Q
"RTN","XWBCAGNT",33,0)
 ;
"RTN","XWBCAGNT",34,0)
SETMSG(S,PAR) ; - format message <extrinsic function>
"RTN","XWBCAGNT",35,0)
 N L,F,PID
"RTN","XWBCAGNT",36,0)
 IF ('$D(S))!('$D(PAR)) Q ""
"RTN","XWBCAGNT",37,0)
 S F=100000
"RTN","XWBCAGNT",38,0)
 S PID=$J
"RTN","XWBCAGNT",39,0)
 S L=$L(PID)
"RTN","XWBCAGNT",40,0)
 S PID=$E(F+L,2,6)_PID
"RTN","XWBCAGNT",41,0)
 S L=$L(S),S=$E(F+L,2,6)_S
"RTN","XWBCAGNT",42,0)
 S L=$L(PAR),PAR=$E(F+L,2,6)_PAR
"RTN","XWBCAGNT",43,0)
 Q "{XWB}"_PID_S_PAR_$C(23)
"RTN","XWBCAGNT",44,0)
 ;
"RTN","XWBCAGNT",45,0)
CLOSE ; - close device <procedure>
"RTN","XWBCAGNT",46,0)
 D CLOSE^%ZISTCP,USE^%ZISUTL("XWBCAGENT HOME"),RMDEV^%ZISUTL("XWBCAGENT HOME")
"RTN","XWBCAGNT",47,0)
 Q
"RTN","XWBCAGNT",48,0)
 ;
"RTN","XWBCAGNT",49,0)
BREAD(L,B) ;read tcp buffer, L is length <extrinsic function>
"RTN","XWBCAGNT",50,0)
 N E,X,T,DONE,XWBTIME,Y,IX,$ETRAP S $ETRAP="S $EC="""" Q"
"RTN","XWBCAGNT",51,0)
 S (T,E,DONE)=0,XWBTIME=35,IX=1,B=L,L=$S(L<256:L,1:128) Q:L'>0 ""
"RTN","XWBCAGNT",52,0)
BR2 R X#L:XWBTIME
"RTN","XWBCAGNT",53,0)
 S E=X
"RTN","XWBCAGNT",54,0)
 IF $L(E)<L F  D  Q:DONE
"RTN","XWBCAGNT",55,0)
 . IF $L(E)=L S DONE=1 Q
"RTN","XWBCAGNT",56,0)
 . R X#(L-$L(E)):XWBTIME
"RTN","XWBCAGNT",57,0)
 . S E=E_X
"RTN","XWBCAGNT",58,0)
 S B(IX)=E,T=T+$L(E)
"RTN","XWBCAGNT",59,0)
 I T'=B S L=$S(B-T>255:128,1:B-T),IX=IX+1 G BR2
"RTN","XWBCAGNT",60,0)
 Q
"RTN","XWBCAGNT",61,0)
 ;
"RTN","XWBCAGNT",62,0)
SREAD(L) ;read short tcp buffer, L is length <extrinsic function>
"RTN","XWBCAGNT",63,0)
 N C,E,X,DONE,XWBTIME,$ETRAP S $ETRAP="S $EC="""" Q """""
"RTN","XWBCAGNT",64,0)
 S (C,E,DONE)=0,XWBTIME=35 Q:L'>0 ""
"RTN","XWBCAGNT",65,0)
 R X#L:XWBTIME
"RTN","XWBCAGNT",66,0)
 S E=X IF $L(E)<L R X#(L-$L(E)):XWBTIME S E=E_X
"RTN","XWBCAGNT",67,0)
 Q E
"RTN","XWBCAGNT",68,0)
 ;
"RTN","XWBEXMPL")
0^15^B2477687
"RTN","XWBEXMPL",1,0)
XWBEXMPL ;ISC-SF/VYD - RPC BROKER EXAMPLE ;09/02/97  16:47
"RTN","XWBEXMPL",2,0)
 ;;1.1;RPC BROKER;;Mar 28, 1997
"RTN","XWBEXMPL",3,0)
ECHOSTR(RESULT,OSTRING) ;receive string and return it
"RTN","XWBEXMPL",4,0)
 S RESULT=OSTRING
"RTN","XWBEXMPL",5,0)
 Q
"RTN","XWBEXMPL",6,0)
 ;
"RTN","XWBEXMPL",7,0)
 ;
"RTN","XWBEXMPL",8,0)
GETLIST(RESULT,WHAT,QTY) ; -- return list
"RTN","XWBEXMPL",9,0)
 ;WHAT - LINES or KILOBYTES, QTY - number of lines of kilobytes
"RTN","XWBEXMPL",10,0)
 ;here the resulting list can get quite large - use global structure
"RTN","XWBEXMPL",11,0)
 N I,J                    ;looping vars
"RTN","XWBEXMPL",12,0)
 K ^TMP($J,"XWB RESULTS") ;clean out temporary storage
"RTN","XWBEXMPL",13,0)
 I WHAT="LINES" D         ;lines requested
"RTN","XWBEXMPL",14,0)
 . F I=1:1:QTY D
"RTN","XWBEXMPL",15,0)
 . . S ^TMP($J,"XWB RESULTS",I)="Line #"_I
"RTN","XWBEXMPL",16,0)
 ;
"RTN","XWBEXMPL",17,0)
 E  D                     ;kilobytes of data requested
"RTN","XWBEXMPL",18,0)
 . F I=1:1:QTY D
"RTN","XWBEXMPL",19,0)
 . . F J=1:1:64 D         ;64 lines * 16 chars = 1K
"RTN","XWBEXMPL",20,0)
 . . . S ^TMP($J,"XWB RESULTS",I*100+J)=$E(I_"-Kilobyte******",1,16)
"RTN","XWBEXMPL",21,0)
 ;
"RTN","XWBEXMPL",22,0)
 S RESULT=$NA(^TMP($J,"XWB RESULTS")) ;give Broker data root
"RTN","XWBEXMPL",23,0)
 Q
"RTN","XWBEXMPL",24,0)
 ;
"RTN","XWBEXMPL",25,0)
 ;
"RTN","XWBEXMPL",26,0)
WPTEXT(RESULT) ;return word processing text
"RTN","XWBEXMPL",27,0)
 N TEXT
"RTN","XWBEXMPL",28,0)
 ;use DBS call to get REMOTE PROCEDURE file description
"RTN","XWBEXMPL",29,0)
 D FILE^DID(8994,"","DESCRIPTION","TEXT")
"RTN","XWBEXMPL",30,0)
 M RESULT=TEXT("DESCRIPTION")
"RTN","XWBEXMPL",31,0)
 Q
"RTN","XWBEXMPL",32,0)
 ;
"RTN","XWBEXMPL",33,0)
 ;
"RTN","XWBEXMPL",34,0)
SORTNUM(RESULT,DIRCTN,ARRAY) ; -- sort numbers and return sorted
"RTN","XWBEXMPL",35,0)
 ;DIRCTN - direction to sort in HI or LO
"RTN","XWBEXMPL",36,0)
 ;ARRAY - array of numbers to sort
"RTN","XWBEXMPL",37,0)
 N I
"RTN","XWBEXMPL",38,0)
 IF DIRCTN="LO" D        ;sort LOW -> HIGH
"RTN","XWBEXMPL",39,0)
 . S I="" F  S I=$O(ARRAY(I)) Q:I=""  D
"RTN","XWBEXMPL",40,0)
 . . S RESULT(I)=I
"RTN","XWBEXMPL",41,0)
 E  D                    ;sort HIGH -> LOW
"RTN","XWBEXMPL",42,0)
 . S I="" F  S I=$O(ARRAY(I)) Q:I=""  D
"RTN","XWBEXMPL",43,0)
 . . S RESULT(99999999-I)=I
"RTN","XWBEXMPL",44,0)
 Q
"RTN","XWBFM")
0^3^B1414006
"RTN","XWBFM",1,0)
XWBFM ;SFISC/VYD - Broker FileMan connectivity ;08/14/95  16:31
"RTN","XWBFM",2,0)
 ;;1.1;RPC BROKER;;Mar 28, 1997
"RTN","XWBFM",3,0)
FIELDLST(RESULT,FNUM) ;retrieve a list of top-level fields of passed file
"RTN","XWBFM",4,0)
 ;and return it in RESLUT
"RTN","XWBFM",5,0)
 ;**** Note: requires FileMan v 21 with NEW DD RETRIEVER VER 1.0 patch
"RTN","XWBFM",6,0)
 N %
"RTN","XWBFM",7,0)
 D FILE^DID(FNUM,"T","FIELDS","^TMP($J)","JUNK")
"RTN","XWBFM",8,0)
 S %="" F  S %=$O(^TMP($J,"FIELDS",%)) Q:%=""  D
"RTN","XWBFM",9,0)
 . S RESULT(%)=$P(^(%),U)_"   ["_$P(^(%),U,2)_"]"
"RTN","XWBFM",10,0)
 K ^TMP($J)
"RTN","XWBFM",11,0)
 Q
"RTN","XWBFM",12,0)
 ;
"RTN","XWBFM",13,0)
FILELIST(RESULT,START) ;retrieve a list and return it in RESLUT
"RTN","XWBFM",14,0)
 N %
"RTN","XWBFM",15,0)
 D LIST^DIC(1,"","","P","","",START)
"RTN","XWBFM",16,0)
 S %=0 F  S %=$O(^TMP("DILIST",$J,%)) Q:%=""  D
"RTN","XWBFM",17,0)
 . S RESULT(%)=$P(^(%,0),U)_"   ["_$P(^(0),U,2)_"]"
"RTN","XWBFM",18,0)
 K ^TMP("DILIST",$J)  ;clean up
"RTN","XWBFM",19,0)
 Q
"RTN","XWBFM",20,0)
 ;
"RTN","XWBFM",21,0)
APILIST(RESULT,START) ;retrieve a list and return it in RESLUT
"RTN","XWBFM",22,0)
 N %
"RTN","XWBFM",23,0)
 D LIST^DIC(8994,"",".02;.03","P","","",START)
"RTN","XWBFM",24,0)
 S %=0 F  S %=$O(^TMP("DILIST",$J,%)) Q:%=""  D
"RTN","XWBFM",25,0)
 . S RESULT(%)=$P(^(%,0),U)_"   ["_$P(^(0),U,3,4)_"]"
"RTN","XWBFM",26,0)
 K ^TMP("DILIST",$J)  ;clean up
"RTN","XWBFM",27,0)
 Q
"RTN","XWBFM",28,0)
 ;
"RTN","XWBFM",29,0)
FILECHK(RESULT,FNAME) ;checks if the FNAME file exists.  If found, return IEN
"RTN","XWBFM",30,0)
 S RESULT=$$FIND1^DIC(1,"","O",FNAME)
"RTN","XWBFM",31,0)
 Q
"RTN","XWBLIB")
0^12^B1021966
"RTN","XWBLIB",1,0)
XWBLIB ;SFISC/VYD - Various remote procedure library ;08/28/97  12:38
"RTN","XWBLIB",2,0)
 ;;1.1;RPC BROKER;;Mar 28, 1997
"RTN","XWBLIB",3,0)
 Q
"RTN","XWBLIB",4,0)
 ;
"RTN","XWBLIB",5,0)
BROKER() ;EF. Running under the Broker
"RTN","XWBLIB",6,0)
 Q $D(XWBOS)
"RTN","XWBLIB",7,0)
 ;
"RTN","XWBLIB",8,0)
RTRNFMT(X,WRAP) ;EF. set the RPC return type and wrap flag
"RTN","XWBLIB",9,0)
 N Y
"RTN","XWBLIB",10,0)
 S:$D(WRAP) XWBWRAP=+WRAP
"RTN","XWBLIB",11,0)
 S X=$G(X)
"RTN","XWBLIB",12,0)
 IF X=+X,X>0,X<6 S XWBPTYPE=X Q X
"RTN","XWBLIB",13,0)
 S X=$$UP^XLFSTR(X)
"RTN","XWBLIB",14,0)
 S X=$S(X="SINGLE VALUE":1,X="ARRAY":2,X="WORD PROCESSING":3,X="GLOBAL ARRAY":4,X="GLOBAL INSTANCE":5,1:0)
"RTN","XWBLIB",15,0)
 IF X=0 Q 0
"RTN","XWBLIB",16,0)
 S XWBPTYPE=X
"RTN","XWBLIB",17,0)
 Q X
"RTN","XWBLIB",18,0)
 ;
"RTN","XWBLIB",19,0)
VARVAL(RESULT,VARIABLE) ;returns value of passed in variable
"RTN","XWBLIB",20,0)
 S RESULT=VARIABLE ;can do this with the REFERENCE type parameter
"RTN","XWBLIB",21,0)
 Q
"RTN","XWBLIB",22,0)
 ;See GETV^XWBBRK for how we get the REFERENCE type parameter
"RTN","XWBSEC")
0^13^B2182413
"RTN","XWBSEC",1,0)
XWBSEC ;SFISC/VYD - RPC BROKER ;05/13/96  15:39
"RTN","XWBSEC",2,0)
 ;;1.1;RPC BROKER;;Mar 28, 1997
"RTN","XWBSEC",3,0)
CHKPRMIT(XWBRP) ;checks to see if remote procedure is permited to run
"RTN","XWBSEC",4,0)
 ;Input:  XWBRP - Remote procedure to check
"RTN","XWBSEC",5,0)
 Q:$$KCHK^XUSRB("XUPROGMODE")
"RTN","XWBSEC",6,0)
 N ERR,XWBPRMIT,XWBALLOW
"RTN","XWBSEC",7,0)
 S U="^",XWBSEC="" ;clear
"RTN","XWBSEC",8,0)
 ;I $E(XWBRP,1,3)'="XUS",XWBRP'="XWB CREATE CONTEXT",XWBRP'="XWB RPC LIST" D  ;check exemptions
"RTN","XWBSEC",9,0)
 ;
"RTN","XWBSEC",10,0)
 ;In the beginning, when no DUZ is defined and no context exist, setup
"RTN","XWBSEC",11,0)
 ;default signon context
"RTN","XWBSEC",12,0)
 S:'$G(DUZ) DUZ=0,XQY0="XUS SIGNON"   ;set up default context
"RTN","XWBSEC",13,0)
 ;
"RTN","XWBSEC",14,0)
 I XWBRP'="XWB CREATE CONTEXT",XWBRP'="XWB RPC LIST" D  ;check exemptions
"RTN","XWBSEC",15,0)
 . I $D(XQY0) D
"RTN","XWBSEC",16,0)
 . . S XWBALLOW=$$CHK^XQCS(DUZ,$P(XQY0,U),XWBRP)         ;do the check
"RTN","XWBSEC",17,0)
 . . S:'XWBALLOW XWBSEC=XWBALLOW
"RTN","XWBSEC",18,0)
 . E  S XWBSEC="Application context has not been created!"
"RTN","XWBSEC",19,0)
 Q
"RTN","XWBSEC",20,0)
 ;
"RTN","XWBSEC",21,0)
 ;
"RTN","XWBSEC",22,0)
CRCONTXT(RESULT,OPTION) ;creates context for the passed in option
"RTN","XWBSEC",23,0)
 I $$KCHK^XUSRB("XUPROGMODE") S RESULT=1 Q
"RTN","XWBSEC",24,0)
 S RESULT=0
"RTN","XWBSEC",25,0)
 K XQY0
"RTN","XWBSEC",26,0)
 S OPTION=$$DECRYP^XUSRB1(OPTION)
"RTN","XWBSEC",27,0)
 S RESULT=$$CHK^XQCS(DUZ,OPTION)
"RTN","XWBSEC",28,0)
 I RESULT S XQY0=OPTION
"RTN","XWBSEC",29,0)
 E  S XWBSEC=RESULT
"RTN","XWBSEC",30,0)
 Q
"RTN","XWBSEC",31,0)
 ;
"RTN","XWBSEC",32,0)
 ;
"RTN","XWBSEC",33,0)
STATE(%) ;Return a state value
"RTN","XWBSEC",34,0)
 Q:'$L($G(%)) $G(XWBSTATE)
"RTN","XWBSEC",35,0)
 Q $G(XWBSTATE(%))
"RTN","XWBSEC",36,0)
 ;
"RTN","XWBSEC",37,0)
 ;
"RTN","XWBSEC",38,0)
SET(%,VALUE) ;Set the state variable
"RTN","XWBSEC",39,0)
 I $G(%)="" S XWBSTATE=VALUE
"RTN","XWBSEC",40,0)
 S XWBSTATE(%)=VALUE
"RTN","XWBSEC",41,0)
 Q
"RTN","XWBSEC",42,0)
KILL(%) ;Kill state variable
"RTN","XWBSEC",43,0)
 I $L($G(%)) K XWBSTATE(%)
"RTN","XWBSEC",44,0)
 Q
"RTN","XWBTCP")
0^7^B36717922
"RTN","XWBTCP",1,0)
XWBTCP ;ISC-SF/EG - Control TCP listener [ 12/04/94  3:20 PM ] ;8/27/97  16:32
"RTN","XWBTCP",2,0)
 ;;1.1;RPC BROKER;;Mar 28, 1997
"RTN","XWBTCP",3,0)
 ;
"RTN","XWBTCP",4,0)
EN ; -- entry point for interactive use
"RTN","XWBTCP",5,0)
 N X1,X2,XWBTDBG,XWBIP
"RTN","XWBTCP",6,0)
 S XWBIP=""
"RTN","XWBTCP",7,0)
 S:$G(IO("IP"))]"" XWBIP=IO("IP")
"RTN","XWBTCP",8,0)
 W !,"Enter client address: "_XWBIP_"//" R X1:300 Q:'$T  Q:X1="^"
"RTN","XWBTCP",9,0)
 W !,"   Enter client port: " R X2:300 Q:'$T  Q:X2="^"
"RTN","XWBTCP",10,0)
 W ! S XWBTDBG=""
"RTN","XWBTCP",11,0)
 IF X1="" S X1=XWBIP
"RTN","XWBTCP",12,0)
 IF X1'="" D EN^XWBTCPC(X1,X2,"")
"RTN","XWBTCP",13,0)
 Q
"RTN","XWBTCP",14,0)
 ;
"RTN","XWBTCP",15,0)
 ;
"RTN","XWBTCP",16,0)
STATXFRM(STATUS) ;Port STATUS field output transform
"RTN","XWBTCP",17,0)
 ;Don't recall why I needed this entry point.  If in future decide to
"RTN","XWBTCP",18,0)
 ;use it, simply enter "D STATXFRM^XWBTCP(Y)" for the output x-form
"RTN","XWBTCP",19,0)
 ;of the STATUS field.
"RTN","XWBTCP",20,0)
 W !,"Output Transform!",!
"RTN","XWBTCP",21,0)
 W STATUS,!
"RTN","XWBTCP",22,0)
 Q
"RTN","XWBTCP",23,0)
 ;
"RTN","XWBTCP",24,0)
 ;
"RTN","XWBTCP",25,0)
STATSCRN(XWBNEW) ;Port STATUS field screen
"RTN","XWBTCP",26,0)
 ;DA: FileMan DA array.  See STATCHG tag bellow for detailed descr.
"RTN","XWBTCP",27,0)
 ;XWBCUR: Current value of STATUS field
"RTN","XWBTCP",28,0)
 ;XWBNEW: New/requested value of STATUS field
"RTN","XWBTCP",29,0)
 ;        The domain for XWBCUR and XWBNEW is the same as for the
"RTN","XWBTCP",30,0)
 ;        ACTION variable, described at STATCHG tag bellow.
"RTN","XWBTCP",31,0)
 N C,XWBCUR,RESULT
"RTN","XWBTCP",32,0)
 S C=","
"RTN","XWBTCP",33,0)
 S XWBCUR=$$GET1^DIQ(8994.171,DA_C_DA(1)_C_DA(2)_C,"STATUS","I")
"RTN","XWBTCP",34,0)
 S RESULT=0
"RTN","XWBTCP",35,0)
 I XWBCUR=3,XWBNEW=4 S RESULT=1 ;if stopping a running listener
"RTN","XWBTCP",36,0)
 I XWBCUR=6,XWBNEW=1 S RESULT=1 ;if starting a stopped listener
"RTN","XWBTCP",37,0)
 ;    the next two cases are most usefull whenever some error occurs
"RTN","XWBTCP",38,0)
 ;    and the STATUS field is stuck in STARTING or RUNNING state
"RTN","XWBTCP",39,0)
 I XWBCUR=2,XWBNEW=3 S RESULT=1 ;change to RUNNING if it's starting
"RTN","XWBTCP",40,0)
 I XWBCUR=5,XWBNEW=6 S RESULT=1 ;change to STOPPED if it's stopping
"RTN","XWBTCP",41,0)
 Q RESULT
"RTN","XWBTCP",42,0)
 ;
"RTN","XWBTCP",43,0)
 ;
"RTN","XWBTCP",44,0)
STATCHG(DA,ACTION) ;STATUS field X-ref SET logic
"RTN","XWBTCP",45,0)
 ;DA: FileMan DA array
"RTN","XWBTCP",46,0)
 ;  DA    =IEN of the port
"RTN","XWBTCP",47,0)
 ;  DA(1) =IEN of the BOX-VOLUME
"RTN","XWBTCP",48,0)
 ;  DA(2) =IEN of site/domain
"RTN","XWBTCP",49,0)
 ;ACTION: Requested value for the STATUS field.  Possible values are:
"RTN","XWBTCP",50,0)
 ;  1 = START, 2 = STARTING, 3 = RUNNING,
"RTN","XWBTCP",51,0)
 ;  4 = STOP,  5 = STOPPING, 6 = STOPPED
"RTN","XWBTCP",52,0)
 N C,ZTCPU,ZTUCI,XWBPORT,XWBFDA
"RTN","XWBTCP",53,0)
 S C=","
"RTN","XWBTCP",54,0)
 ;
"RTN","XWBTCP",55,0)
 I ACTION=1!(ACTION=4) D
"RTN","XWBTCP",56,0)
 . S ZTCPU=$$GET1^DIQ(8994.17,DA(1)_C_DA(2)_C,"BOX-VOLUME PAIR")
"RTN","XWBTCP",57,0)
 . S XWBPORT=$$GET1^DIQ(8994.171,DA_C_DA(1)_C_DA(2)_C,"PORT")
"RTN","XWBTCP",58,0)
 . ;S ZTUCI=$$GET1^DIQ(8994.171,DA_C_DA(1)_C_DA(2)_C,"UCI")
"RTN","XWBTCP",59,0)
 . ;UCI is no longer derived from the file, but comes from current
"RTN","XWBTCP",60,0)
 . ;environment.  The reason for that is it makes no sense to start
"RTN","XWBTCP",61,0)
 . ;a listener in a UCI where ^XWB can't be reached to change status.
"RTN","XWBTCP",62,0)
 . D GETENV^%ZOSV
"RTN","XWBTCP",63,0)
 . S ZTUCI=$P(Y,U),ZTIO="",ZTREQ="@",ZTDTH=$H ;run it ASAP
"RTN","XWBTCP",64,0)
 . I ACTION=1 D    ; -- START listener
"RTN","XWBTCP",65,0)
 . . S ZTDESC="RPC Broker Listener START on "_ZTUCI_"-"_ZTCPU_", port "_XWBPORT
"RTN","XWBTCP",66,0)
 . . S ZTRTN="EN^XWBTCPL("_XWBPORT_")"
"RTN","XWBTCP",67,0)
 . E  D            ; -- STOP listener
"RTN","XWBTCP",68,0)
 . . S ZTDESC="RPC Broker Listener STOP on "_ZTUCI_"-"_ZTCPU_", port "_XWBPORT
"RTN","XWBTCP",69,0)
 . . S ZTRTN="STOP^XWBTCP("_XWBPORT_")"
"RTN","XWBTCP",70,0)
 . D EN^DDIOL("Task: "_ZTDESC,"","!?10") ;inform user
"RTN","XWBTCP",71,0)
 . D ^%ZTLOAD      ; queue it
"RTN","XWBTCP",72,0)
 . D EN^DDIOL("has been queued as task "_ZTSK,"","!?10") ;inform user
"RTN","XWBTCP",73,0)
 . ; --  change STATUS from START to STARTING or from STOP to STOPPING
"RTN","XWBTCP",74,0)
 . D FDA^DILF(8994.171,DA_C_DA(1)_C_DA(2)_C,1,"R",ACTION+1,"XWBFDA")
"RTN","XWBTCP",75,0)
 . D FILE^DIE("K","XWBFDA")
"RTN","XWBTCP",76,0)
 Q
"RTN","XWBTCP",77,0)
 ;
"RTN","XWBTCP",78,0)
 ;
"RTN","XWBTCP",79,0)
STRT(XWBTSKT) ;start TCP Listener.  Interactive entry point
"RTN","XWBTCP",80,0)
 N IP,REF,Y,%
"RTN","XWBTCP",81,0)
 S U="^" D HOME^%ZIS
"RTN","XWBTCP",82,0)
 W "Start TCP Listener...",!
"RTN","XWBTCP",83,0)
 X ^%ZOSF("UCI") S REF=Y
"RTN","XWBTCP",84,0)
 S IP="0.0.0.0" ;get server IP at some point
"RTN","XWBTCP",85,0)
 IF $G(XWBTSKT)="" S XWBTSKT=9000 ;default service port is 9000
"RTN","XWBTCP",86,0)
 ;
"RTN","XWBTCP",87,0)
 ; -- see if 'running flag' for listener is set
"RTN","XWBTCP",88,0)
 I '$$SEMAPHOR^XWBTCPL(XWBTSKT,"LOCK") W "TCP Listener on port "_XWBTSKT_" appears to be running already.",! Q
"RTN","XWBTCP",89,0)
 S %=$$SEMAPHOR^XWBTCPL(XWBTSKT,"UNLOCK")
"RTN","XWBTCP",90,0)
 ;
"RTN","XWBTCP",91,0)
 ; -- set stop flag to false and start the listener
"RTN","XWBTCP",92,0)
 ;S ^XWB(IP,REF,XWBTSKT,"STOP")=""
"RTN","XWBTCP",93,0)
 S ^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")=""  ;record problem marker
"RTN","XWBTCP",94,0)
 J EN^XWBTCPL(XWBTSKT)::5 ;Used in place of TaskMan, Need to start on any node.
"RTN","XWBTCP",95,0)
 I '$T W "Unable to run TCP Listener in background.",! Q
"RTN","XWBTCP",96,0)
 F %=1:1:5 D  Q:%=0
"RTN","XWBTCP",97,0)
 . W "Checking if TCP Listener has started...",!
"RTN","XWBTCP",98,0)
 . H 3
"RTN","XWBTCP",99,0)
 . L +^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")
"RTN","XWBTCP",100,0)
 . S:'$D(^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")) %=0
"RTN","XWBTCP",101,0)
 . L -^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")
"RTN","XWBTCP",102,0)
 I $D(^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")) D
"RTN","XWBTCP",103,0)
 . W !,"TCP Listener could not be started!",!
"RTN","XWBTCP",104,0)
 . W "Check if port "_XWBTSKT_" is busy on this CPU.",!
"RTN","XWBTCP",105,0)
 . K ^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")   ;clear marker
"RTN","XWBTCP",106,0)
 E  W "TCP Listener started successfully."
"RTN","XWBTCP",107,0)
 Q
"RTN","XWBTCP",108,0)
 ;
"RTN","XWBTCP",109,0)
 ;
"RTN","XWBTCP",110,0)
STRTALL ;XWB LISTENER STARTER option entry point
"RTN","XWBTCP",111,0)
 ;here all listener entries in RPC Broker Site Parameters file that
"RTN","XWBTCP",112,0)
 ;have CONTROLLED BY LISTENER STARTER set to 1/Yes will be started.
"RTN","XWBTCP",113,0)
 N E,LSTN,LSTNID,LSTNIENS,PORTID,XWBSCR,XWBDA
"RTN","XWBTCP",114,0)
 ;XWBDA: Namespaced FileMan DA array
"RTN","XWBTCP",115,0)
 ;  XWBDA    =IEN of the port
"RTN","XWBTCP",116,0)
 ;  XWBDA(1) =IEN of the BOX-VOLUME
"RTN","XWBTCP",117,0)
 ;  XWBDA(2) =IEN of site/domain
"RTN","XWBTCP",118,0)
 S E=""
"RTN","XWBTCP",119,0)
 S XWBDA(2)=1 ;hard set IEN of site/domain
"RTN","XWBTCP",120,0)
 ; -- screen out RUNNING (STATUS=3) listeners and those that aren't controlled by XWB LISTENER STARTER option.
"RTN","XWBTCP",121,0)
 S XWBSCR="I $P(^(0),U,2)'=3,$P(^(0),U,4)"
"RTN","XWBTCP",122,0)
 ; -- get top level listners box-volume
"RTN","XWBTCP",123,0)
 D LIST^DIC(8994.17,",1,",E,E,E,E,E,E,E,E,$NA(LSTN("LSTNR")))
"RTN","XWBTCP",124,0)
 S LSTNID=""
"RTN","XWBTCP",125,0)
 F  S LSTNID=$O(LSTN("LSTNR","DILIST",1,LSTNID)) Q:LSTNID=""  D
"RTN","XWBTCP",126,0)
 . S XWBDA(1)=LSTN("LSTNR","DILIST",2,LSTNID) ;IEN of each listener
"RTN","XWBTCP",127,0)
 . S LSTNIENS=","_XWBDA(1)_","_XWBDA(2)_","
"RTN","XWBTCP",128,0)
 . D LIST^DIC(8994.171,LSTNIENS,E,"P",E,E,E,E,XWBSCR,E,$NA(LSTN("PORT")))
"RTN","XWBTCP",129,0)
 . S PORTID=0
"RTN","XWBTCP",130,0)
 . F  S PORTID=$O(LSTN("PORT","DILIST",PORTID)) Q:PORTID=""  D
"RTN","XWBTCP",131,0)
 . . ;W !,"--------------",! ZW LSTN
"RTN","XWBTCP",132,0)
 . . S XWBDA=$P(LSTN("PORT","DILIST",PORTID,0),U,2)
"RTN","XWBTCP",133,0)
 . . ;W !,"========",! ZW XWBDA
"RTN","XWBTCP",134,0)
 . . D STATCHG(.XWBDA,1) ;use STATUS field X-ref SET logic to queue up start of a listener
"RTN","XWBTCP",135,0)
 Q
"RTN","XWBTCP",136,0)
 ;
"RTN","XWBTCP",137,0)
 ;
"RTN","XWBTCP",138,0)
STOP(XWBTSKT) ;stop TCP Listener.  Interactive and TaskMan entry point
"RTN","XWBTCP",139,0)
 N IP,REF,X,DEV,XWBOS,XWBIP  ;**1**
"RTN","XWBTCP",140,0)
 S U="^" D HOME^%ZIS
"RTN","XWBTCP",141,0)
 W "Stop TCP Listener...",!
"RTN","XWBTCP",142,0)
 X ^%ZOSF("UCI") S REF=Y
"RTN","XWBTCP",143,0)
 S IP="0.0.0.0" ;get server IP
"RTN","XWBTCP",144,0)
 IF $G(XWBTSKT)="" S XWBTSKT=9000 ;default service port is 9000
"RTN","XWBTCP",145,0)
 ;
"RTN","XWBTCP",146,0)
 S XWBOS=$S(^%ZOSF("OS")["DSM":"DSM",^("OS")["MSM":"MSM",^("OS")["OpenM":"OpenM",1:"") ;RWF
"RTN","XWBTCP",147,0)
 ;
"RTN","XWBTCP",148,0)
 ; -- make sure the listener is running
"RTN","XWBTCP",149,0)
 ;L +^XWB(IP,REF,XWBTSKT,"RUNNING"):1
"RTN","XWBTCP",150,0)
 ;D GETENV^%ZOSV ;get Y=UCI^VOL^NODE^BOXLOOKUP of current system
"RTN","XWBTCP",151,0)
 ;L +^%ZIS(8994.171,"RPCB Listener",$P(Y,U,2),$P(Y,U),$P(Y,U,3),XWBTSKT):1
"RTN","XWBTCP",152,0)
 ;I $T D  Q
"RTN","XWBTCP",153,0)
 I $$SEMAPHOR^XWBTCPL(XWBTSKT,"LOCK") D  Q
"RTN","XWBTCP",154,0)
 . S %=$$SEMAPHOR^XWBTCPL(XWBTSKT,"UNLOCK")
"RTN","XWBTCP",155,0)
 . D EN^DDIOL("TCP Listener does not appear to be running.")
"RTN","XWBTCP",156,0)
 ;
"RTN","XWBTCP",157,0)
 ; -- set the stop flag
"RTN","XWBTCP",158,0)
 ;S ^XWB(IP,REF,XWBTSKT,"STOP")=1
"RTN","XWBTCP",159,0)
 ;
"RTN","XWBTCP",160,0)
 ; -- send the shutdown message to the TCP Listener process
"RTN","XWBTCP",161,0)
 ;    using loopback address
"RTN","XWBTCP",162,0)
 S XWBIP="127.0.0.1"
"RTN","XWBTCP",163,0)
 D CALL^%ZISTCP("127.0.0.1",XWBTSKT) U IO
"RTN","XWBTCP",164,0)
 ;
"RTN","XWBTCP",165,0)
 S X=$T(+2),X=$P(X,";;",2),X=$P(X,";")
"RTN","XWBTCP",166,0)
 IF X="" S X=0
"RTN","XWBTCP",167,0)
 S X=$C($L(X))_X
"RTN","XWBTCP",168,0)
 W "{XWB}00020|"_X_"00011TCPshutdown",!
"RTN","XWBTCP",169,0)
 ;W "{XWB}00011TCPshutdown",!  ;**1**
"RTN","XWBTCP",170,0)
 R X#3:5
"RTN","XWBTCP",171,0)
 D CLOSE^%ZISTCP
"RTN","XWBTCP",172,0)
 ;D EN^DDIOL("TCP Listener Response to Shutdown Request: "_X)  ;**1**
"RTN","XWBTCP",173,0)
 IF X="ack" D EN^DDIOL("TCP Listener has been shutdown.")  ;**1**
"RTN","XWBTCP",174,0)
 ELSE  D EN^DDIOL("Shutdown Failed!")  ;**1**
"RTN","XWBTCP",175,0)
 ;change process name
"RTN","XWBTCP",176,0)
 D CHPRN^XWBTCPC($J)
"RTN","XWBTCP",177,0)
 Q
"RTN","XWBTCPC")
0^4^B39524820
"RTN","XWBTCPC",1,0)
XWBTCPC ;ISC-SF/EG/VYD - TCP/IP PROCESS HANDLER ;8/28/97  16:24
"RTN","XWBTCPC",2,0)
 ;;1.1;RPC BROKER;;Mar 28, 1997
"RTN","XWBTCPC",3,0)
 ;Based on:
"RTN","XWBTCPC",4,0)
 ;XQORTCPH ;SLC/KCM - Service TCP Messages [ 12/04/94  9:06 PM ]
"RTN","XWBTCPC",5,0)
 ;Modified by ISC-SF/EG
"RTN","XWBTCPC",6,0)
 ; 0. No longer supports old style OERR messages
"RTN","XWBTCPC",7,0)
 ; 1. Makes call to RPC  broker
"RTN","XWBTCPC",8,0)
 ; 2. Handles MSM Server under Windows NT
"RTN","XWBTCPC",9,0)
 ; 3. Handles MSM under Unix - same as DSM
"RTN","XWBTCPC",10,0)
 ; 4. Result of an rpc call can be a closed form of global
"RTN","XWBTCPC",11,0)
 ; 5. Can receive a large local array, within limits of job
"RTN","XWBTCPC",12,0)
 ;    partition size.
"RTN","XWBTCPC",13,0)
 ; 6. Sets default device to NULL device prior to call, restores
"RTN","XWBTCPC",14,0)
 ;    at termination.  Prevents garbage from 'talking' calls.
"RTN","XWBTCPC",15,0)
 ; 7. All reads have a timeout.
"RTN","XWBTCPC",16,0)
 ; 8. Intro message is sent when first connected.
"RTN","XWBTCPC",17,0)
 ; 9. Uses callback model to connect to client
"RTN","XWBTCPC",18,0)
 ;
"RTN","XWBTCPC",19,0)
MSM ;entry point for MSERVER service - used by MSM
"RTN","XWBTCPC",20,0)
 N XWBVER,LEN,MSG,X
"RTN","XWBTCPC",21,0)
 S XWBVER=0
"RTN","XWBTCPC",22,0)
 R LEN#11:3600 IF $E(LEN,1,5)'="{XWB}" D  Q  ;bad client, abort
"RTN","XWBTCPC",23,0)
 . W "RPC broker disconnect!",!
"RTN","XWBTCPC",24,0)
 . C 56
"RTN","XWBTCPC",25,0)
 . Q
"RTN","XWBTCPC",26,0)
 IF $E(LEN,11,11)="|" D
"RTN","XWBTCPC",27,0)
 . R X#1:60
"RTN","XWBTCPC",28,0)
 . R XWBVER#$A(X):60
"RTN","XWBTCPC",29,0)
 . R LEN#5:60
"RTN","XWBTCPC",30,0)
 . R MSG#LEN:60
"RTN","XWBTCPC",31,0)
 . Q
"RTN","XWBTCPC",32,0)
 ELSE  S X=$E(LEN,11,11),LEN=$E(LEN,6,10)-1 R MSG#LEN:60 S MSG=X_MSG
"RTN","XWBTCPC",33,0)
 IF $P(MSG,"^")="TCPconnect" D
"RTN","XWBTCPC",34,0)
 . D SNDERR W "accept",$C(4),!
"RTN","XWBTCPC",35,0)
 . C 56
"RTN","XWBTCPC",36,0)
 . D EN($P(MSG,"^",2),$P(MSG,"^",3),$P(X,"^"),XWBVER,$P(MSG,"^",4))
"RTN","XWBTCPC",37,0)
 IF $P(MSG,"^")="TCPdebug" D
"RTN","XWBTCPC",38,0)
 . D SNDERR W "accept",$C(4),!
"RTN","XWBTCPC",39,0)
 C 56
"RTN","XWBTCPC",40,0)
 Q
"RTN","XWBTCPC",41,0)
 ;
"RTN","XWBTCPC",42,0)
EN(XWBTIP,XWBTSKT,DUZ,XWBVER,XWBCLMAN) ; -- Main entry point
"RTN","XWBTCPC",43,0)
 N TYPE,XWBTBUF,XWBTBUF1,XWBTDEV,XWBTLEN,XWBTOS,XWBTRTN,XWBWRAP
"RTN","XWBTCPC",44,0)
 N X,XWBL,XWB1,XWB2,Y,XWBTIME,XWBPTYPE,XWBPLEN,XWBNULL,XWBODEV
"RTN","XWBTCPC",45,0)
 N XWBERROR,XWBSEC ;new error variable available to rpc calls
"RTN","XWBTCPC",46,0)
 N XRTL,IO,IOP,L,XWBAPVER
"RTN","XWBTCPC",47,0)
 ;
"RTN","XWBTCPC",48,0)
 S XWBCLMAN=$G(XWBCLMAN)
"RTN","XWBTCPC",49,0)
 S XWBOS=$S(^%ZOSF("OS")["DSM":"DSM",^("OS")["UNIX":"UNIX",^("OS")["OpenM":"OpenM",1:"MSM")
"RTN","XWBTCPC",50,0)
 IF $$NEWERR^%ZTER S $ETRAP="D ^%ZTER H"
"RTN","XWBTCPC",51,0)
 E  S X="^%ZTER",@^%ZOSF("TRAP")
"RTN","XWBTCPC",52,0)
 K XRTL IF XWBOS="DSM" S XRTL=1 ;log response time data for DSM
"RTN","XWBTCPC",53,0)
 S XWBTIME=1
"RTN","XWBTCPC",54,0)
 ;call client on new port
"RTN","XWBTCPC",55,0)
 ;IF XWBOS="DSM" O XWBTSKT:(TCPCHAN:ADDRESS=XWBTIP:SHARE)
"RTN","XWBTCPC",56,0)
 ;IF XWBOS="MSM"!(XWBOS="UNIX") O 56 U 56::"TCP" W /SOCKET(XWBTIP,XWBTSKT)
"RTN","XWBTCPC",57,0)
 ;IF XWBOS="OpenM" S XWBTDEV="|TCP|"_XWBTSKT O XWBTDEV:(XWBTIP:XWBTSKT:"ST":$C(13,10):512:512) ;RWF
"RTN","XWBTCPC",58,0)
 ;Use Kernel to open the connection back to the client
"RTN","XWBTCPC",59,0)
 D CALL^%ZISTCP(XWBTIP,XWBTSKT) Q:POP  S XWBTDEV=IO,IO(0)=IO
"RTN","XWBTCPC",60,0)
 ;
"RTN","XWBTCPC",61,0)
 ;setup null device "NULL"
"RTN","XWBTCPC",62,0)
 ;D OPEN^%ZISUTL("XWBNULL","NULL","0") ;Need to suppress HOME device
"RTN","XWBTCPC",63,0)
 ;S XWBNULL=IO
"RTN","XWBTCPC",64,0)
 IF XWBOS="DSM" S XWBNULL="_NLA0:" O XWBNULL S (IO,IO(0))=XWBNULL,IOT="TRM",IOST="P-OTHER",IOST(0)=0
"RTN","XWBTCPC",65,0)
 ELSE  S IOP="NULL" D ^%ZIS S XWBNULL=IO
"RTN","XWBTCPC",66,0)
 ;change process name
"RTN","XWBTCPC",67,0)
 D CHPRN("ip"_$P(XWBTIP,".",3,4)_":"_XWBTSKT)
"RTN","XWBTCPC",68,0)
RESTART IF $$NEWERR^%ZTER N $ESTACK S $ETRAP="S %ZTER11S=$STACK D ETRAP^XWBTCPC"
"RTN","XWBTCPC",69,0)
 E  S X="ETRAP^XWBTCPC",@^%ZOSF("TRAP")
"RTN","XWBTCPC",70,0)
 S DIQUIET=1,U="^" D DT^DICRW
"RTN","XWBTCPC",71,0)
 U XWBTDEV D MAIN
"RTN","XWBTCPC",72,0)
 ;Turn off the error for the exit
"RTN","XWBTCPC",73,0)
 IF $$NEWERR^%ZTER S $ETRAP=""
"RTN","XWBTCPC",74,0)
 E  S X="",@^%ZOSF("TRAP")
"RTN","XWBTCPC",75,0)
 I $G(DUZ) D LOGOUT^XUSRB
"RTN","XWBTCPC",76,0)
 K XWBR,XWBARY
"RTN","XWBTCPC",77,0)
 C XWBTDEV
"RTN","XWBTCPC",78,0)
 D USE^%ZISUTL("XWBNULL"),CLOSE^%ZISUTL
"RTN","XWBTCPC",79,0)
 Q
"RTN","XWBTCPC",80,0)
 ;
"RTN","XWBTCPC",81,0)
MAIN ; -- main message processing loop
"RTN","XWBTCPC",82,0)
 F  D  Q:XWBTBUF="#BYE#"
"RTN","XWBTCPC",83,0)
 . S XWBAPVER=0
"RTN","XWBTCPC",84,0)
 . ;
"RTN","XWBTCPC",85,0)
 . ; -- read client request
"RTN","XWBTCPC",86,0)
 . R XWBTBUF#11:36000 IF '$T S XWBTBUF="#BYE#" D SNDERR W XWBTBUF,$C(4),! Q
"RTN","XWBTCPC",87,0)
 . S TYPE=$S($E(XWBTBUF,1,5)="{XWB}":1,1:0)
"RTN","XWBTCPC",88,0)
 . I 'TYPE S XWBTBUF="#BYE#" D SNDERR W XWBTBUF,$C(4),! Q
"RTN","XWBTCPC",89,0)
 . S XWBTLEN=$E(XWBTBUF,6,10)
"RTN","XWBTCPC",90,0)
 . S L=$E(XWBTBUF,11,11) IF L="|" R L#1:60 S L=$A(L) R XWBAPVER#L:60 R XWBTBUF#5:60
"RTN","XWBTCPC",91,0)
 . E  R XWBTBUF#4:60 S XWBTBUF=L_XWBTBUF
"RTN","XWBTCPC",92,0)
 . S XWBPLEN=XWBTBUF
"RTN","XWBTCPC",93,0)
 . R XWBTBUF#XWBPLEN:XWBTIME
"RTN","XWBTCPC",94,0)
 . I $P(XWBTBUF,U)="TCPconnect" D  Q
"RTN","XWBTCPC",95,0)
 . . D SNDERR W "accept",$C(4),!  ;Ack
"RTN","XWBTCPC",96,0)
 . IF TYPE D
"RTN","XWBTCPC",97,0)
 . . K XWBR,XWBARY
"RTN","XWBTCPC",98,0)
 . . IF XWBTBUF="#BYE#" D SNDERR W "#BYE#",$C(4),! Q  ; -- clean disconnect
"RTN","XWBTCPC",99,0)
 . . S XWBTLEN=XWBTLEN-15
"RTN","XWBTCPC",100,0)
 . . D CALLP^XWBBRK(.XWBR,XWBTBUF)
"RTN","XWBTCPC",101,0)
 . . S XWBPTYPE=$S('$D(XWBPTYPE):1,XWBPTYPE<1:1,XWBPTYPE>6:1,1:XWBPTYPE)
"RTN","XWBTCPC",102,0)
 . IF XWBTBUF="#BYE#" Q
"RTN","XWBTCPC",103,0)
 . U XWBTDEV
"RTN","XWBTCPC",104,0)
 . D SNDERR
"RTN","XWBTCPC",105,0)
 . D:$D(XRTL) T0^%ZOSV ;start RTL
"RTN","XWBTCPC",106,0)
 . IF XWBOS="DSM"!(XWBOS="UNIX")!(XWBOS="OpenM") D SNDDSM ;RWF
"RTN","XWBTCPC",107,0)
 . IF XWBOS="MSM" D SND
"RTN","XWBTCPC",108,0)
 . S XWBSEC=""
"RTN","XWBTCPC",109,0)
 . W $C(4),! ;send eot and flush buffer
"RTN","XWBTCPC",110,0)
 . S:$D(XRT0) XRTN="RPC BROKER WRITE" D:$D(XRT0) T1^%ZOSV ;stop RTL
"RTN","XWBTCPC",111,0)
 Q  ;End Of Main
"RTN","XWBTCPC",112,0)
 ;
"RTN","XWBTCPC",113,0)
SNDERR ;send error information
"RTN","XWBTCPC",114,0)
 ;XWBSEC is the security packet, XWBERROR is application packet
"RTN","XWBTCPC",115,0)
 N X
"RTN","XWBTCPC",116,0)
 S X=$G(XWBSEC)
"RTN","XWBTCPC",117,0)
 W $C($L(X))_X W:($X+$L(X)+1)>512 !
"RTN","XWBTCPC",118,0)
 S X=$G(XWBERROR)
"RTN","XWBTCPC",119,0)
 W $C($L(X))_X W:($X+$L(X)+1)>512 !
"RTN","XWBTCPC",120,0)
 S XWBERROR="" ;clears parameters
"RTN","XWBTCPC",121,0)
 Q
"RTN","XWBTCPC",122,0)
 ;
"RTN","XWBTCPC",123,0)
SND ; -- Send data (all except DSM)
"RTN","XWBTCPC",124,0)
 N I,T
"RTN","XWBTCPC",125,0)
 ;
"RTN","XWBTCPC",126,0)
 ; -- error or abort occurred, send null
"RTN","XWBTCPC",127,0)
 IF $L(XWBSEC)>0 W "" Q
"RTN","XWBTCPC",128,0)
 ; -- single value
"RTN","XWBTCPC",129,0)
 IF XWBPTYPE=1 S XWBR=$G(XWBR) W XWBR Q
"RTN","XWBTCPC",130,0)
 ; -- table delimited by CR+LF
"RTN","XWBTCPC",131,0)
 IF XWBPTYPE=2 D  Q
"RTN","XWBTCPC",132,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  W XWBR(I),$C(13,10)
"RTN","XWBTCPC",133,0)
 ; -- word processing
"RTN","XWBTCPC",134,0)
 IF XWBPTYPE=3 D  Q
"RTN","XWBTCPC",135,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  W XWBR(I) W:XWBWRAP $C(13,10)
"RTN","XWBTCPC",136,0)
 ; -- global array
"RTN","XWBTCPC",137,0)
 IF XWBPTYPE=4 D  Q
"RTN","XWBTCPC",138,0)
 . S I=$G(XWBR) Q:I=""  S T=$E(I,1,$L(I)-1) W:$D(@I)>10 @I F  S I=$Q(@I) Q:I=""!(I'[T)  W @I W:XWBWRAP $C(13,10)
"RTN","XWBTCPC",139,0)
 . IF $D(@XWBR) K @XWBR
"RTN","XWBTCPC",140,0)
 ; -- global instance
"RTN","XWBTCPC",141,0)
 IF XWBPTYPE=5 S XWBR=$G(@XWBR) W XWBR Q
"RTN","XWBTCPC",142,0)
 ; -- variable length records
"RTN","XWBTCPC",143,0)
 IF XWBPTYPE=6 S I="" F  S I=$O(XWBR(I)) Q:I=""  W $C($L(XWBR(I))),XWBR(I)
"RTN","XWBTCPC",144,0)
 Q
"RTN","XWBTCPC",145,0)
SNDDSM ; -- send data for DSM (requires buffer flush (!) every 509 chars)
"RTN","XWBTCPC",146,0)
 N I,T
"RTN","XWBTCPC",147,0)
 ;
"RTN","XWBTCPC",148,0)
 ; -- error or abort occurred, send null
"RTN","XWBTCPC",149,0)
 IF $L(XWBSEC)>0 W "" Q
"RTN","XWBTCPC",150,0)
 ; -- single value
"RTN","XWBTCPC",151,0)
 IF XWBPTYPE=1 S XWBR=$G(XWBR) W XWBR Q
"RTN","XWBTCPC",152,0)
 ; -- table delimited by CR+LF
"RTN","XWBTCPC",153,0)
 IF XWBPTYPE=2 D  Q
"RTN","XWBTCPC",154,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  W:($X+$L(XWBR(I)))>509 ! W XWBR(I),$C(13,10)
"RTN","XWBTCPC",155,0)
 ; -- word processing
"RTN","XWBTCPC",156,0)
 IF XWBPTYPE=3 D  Q
"RTN","XWBTCPC",157,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  W:($X+$L(XWBR(I)))>509 ! W XWBR(I) W:XWBWRAP $C(13,10)
"RTN","XWBTCPC",158,0)
 ; -- global array
"RTN","XWBTCPC",159,0)
 IF XWBPTYPE=4 D  Q
"RTN","XWBTCPC",160,0)
 . S I=$G(XWBR) Q:I=""  S T=$E(I,1,$L(I)-1) W:$D(@I)>10 @I F  S I=$Q(@I) Q:I=""!(I'[T)  W:($X+$L(@I))>509 ! W @I W:XWBWRAP&(@I'=$C(13,10)) $C(13,10)
"RTN","XWBTCPC",161,0)
 . IF $D(@XWBR) K @XWBR
"RTN","XWBTCPC",162,0)
 ; -- global instance
"RTN","XWBTCPC",163,0)
 IF XWBPTYPE=5 S XWBR=$G(@XWBR) W XWBR Q
"RTN","XWBTCPC",164,0)
 ; -- variable length records
"RTN","XWBTCPC",165,0)
 IF XWBPTYPE=6 S I="" F  S I=$O(XWBR(I)) Q:I=""  W:($X+$L(XWBR(I)))>509 ! W $C($L(XWBR(I))),XWBR(I)
"RTN","XWBTCPC",166,0)
 Q
"RTN","XWBTCPC",167,0)
 ;
"RTN","XWBTCPC",168,0)
ETRAP ; -- on trapped error, send error info to client
"RTN","XWBTCPC",169,0)
 N XWBERR
"RTN","XWBTCPC",170,0)
 S XWBERR=$C(24)_"M  ERROR="_$$EC^%ZOSV_$C(13,10)_"LAST REF="_$$LGR^%ZOSV_$C(4)
"RTN","XWBTCPC",171,0)
 ;Turn off trapping during trap.
"RTN","XWBTCPC",172,0)
 IF $$NEWERR^%ZTER S $ETRAP=""
"RTN","XWBTCPC",173,0)
 E  S X="",@^%ZOSF("TRAP")
"RTN","XWBTCPC",174,0)
 U XWBTDEV
"RTN","XWBTCPC",175,0)
 D ^%ZTER ;%ZTER clears $ZE and $ZCODE
"RTN","XWBTCPC",176,0)
 IF XWBOS="DSM" D
"RTN","XWBTCPC",177,0)
 . I $D(XWBTLEN),XWBTLEN,XWBERR'["SYSTEM-F" D SNDERR W XWBERR,!
"RTN","XWBTCPC",178,0)
 IF XWBOS'="DSM" D
"RTN","XWBTCPC",179,0)
 . D SNDERR W XWBERR,!
"RTN","XWBTCPC",180,0)
 I (XWBERR["READERR")!(XWBERR["DISCON")!(XWBERR["SYSTEM-F") D:$G(DUZ) LOGOUT^XUSRB HALT
"RTN","XWBTCPC",181,0)
 I '$$NEWERR^%ZTER G RESTART
"RTN","XWBTCPC",182,0)
 S $ETRAP="Q:($ESTACK&'$QUIT)  Q:$ESTACK 0 S $ECODE="""" G RESTART",$ECODE=",U99,"
"RTN","XWBTCPC",183,0)
 Q
"RTN","XWBTCPC",184,0)
 ;
"RTN","XWBTCPC",185,0)
STYPE(X,WRAP) ;For backward compatability only
"RTN","XWBTCPC",186,0)
 I $D(WRAP) Q $$RTRNFMT^XWBLIB($G(X),WRAP)
"RTN","XWBTCPC",187,0)
 Q $$RTRNFMT^XWBLIB(X)
"RTN","XWBTCPC",188,0)
 ;
"RTN","XWBTCPC",189,0)
BREAD(L) ;read tcp buffer, L is length
"RTN","XWBTCPC",190,0)
 N E,X,DONE
"RTN","XWBTCPC",191,0)
 S (E,DONE)=0
"RTN","XWBTCPC",192,0)
 R X#L:XWBTIME
"RTN","XWBTCPC",193,0)
 S E=X
"RTN","XWBTCPC",194,0)
 IF $L(E)<L F  D  Q:'DONE
"RTN","XWBTCPC",195,0)
 . IF $L(E)=L S DONE=1 Q
"RTN","XWBTCPC",196,0)
 . R X#(L-$L(E)):XWBTIME
"RTN","XWBTCPC",197,0)
 . S E=E_X
"RTN","XWBTCPC",198,0)
 Q E
"RTN","XWBTCPC",199,0)
 ;
"RTN","XWBTCPC",200,0)
CHPRN(N) ;change process name
"RTN","XWBTCPC",201,0)
 ;Change process name to N
"RTN","XWBTCPC",202,0)
 D SETNM^%ZOSV($E(N,1,15))
"RTN","XWBTCPC",203,0)
 Q
"RTN","XWBTCPC",204,0)
 ;
"RTN","XWBTCPL")
0^6^B29185139
"RTN","XWBTCPL",1,0)
XWBTCPL ;SLC/KCM - Listener for TCP connects ;09/08/97  10:07
"RTN","XWBTCPL",2,0)
 ;;1.1;RPC BROKER;;Mar 28, 1997
"RTN","XWBTCPL",3,0)
 ;ISC-SF/EG - DHCP Broker
"RTN","XWBTCPL",4,0)
 ;
"RTN","XWBTCPL",5,0)
 ; This routine is the background process that listens for client
"RTN","XWBTCPL",6,0)
 ; requests to connect to M.  When a request is received, This
"RTN","XWBTCPL",7,0)
 ; procedure will job a s small routine to listen for new requests
"RTN","XWBTCPL",8,0)
 ; on the known service port.
"RTN","XWBTCPL",9,0)
 ;
"RTN","XWBTCPL",10,0)
 ; This job may be started in the background with:  D STRT^XWBTCP(PORT)
"RTN","XWBTCPL",11,0)
 ;
"RTN","XWBTCPL",12,0)
 ; When running, this job may be stopped with:      D STOP^XWBTCP(PORT)
"RTN","XWBTCPL",13,0)
 ;
"RTN","XWBTCPL",14,0)
 ; Where port is the known service port to listen for connections
"RTN","XWBTCPL",15,0)
 ;
"RTN","XWBTCPL",16,0)
EN(XWBTSKT) ; -- accept clients and start the individual message handler
"RTN","XWBTCPL",17,0)
 N IP,REF,RETRY,XWBVER
"RTN","XWBTCPL",18,0)
 S U="^"
"RTN","XWBTCPL",19,0)
 S RETRY="START"
"RTN","XWBTCPL",20,0)
 X ^%ZOSF("UCI") S REF=Y
"RTN","XWBTCPL",21,0)
 S IP="0.0.0.0" ;get server IP
"RTN","XWBTCPL",22,0)
 IF $G(XWBTSKT)="" S XWBTSKT=9000 ; default service port
"RTN","XWBTCPL",23,0)
 S XWBTDEV=XWBTSKT
"RTN","XWBTCPL",24,0)
 ;
"RTN","XWBTCPL",25,0)
 D SETNM^%ZOSV($E("RPCB_Port:"_XWBTSKT,1,15)) ;change process name
"RTN","XWBTCPL",26,0)
 N LEN,MSG,XWBOS,DONE,DSMTCP,X
"RTN","XWBTCPL",27,0)
 ; -- check the TCP stop parameter
"RTN","XWBTCPL",28,0)
 ;IF $G(^XWB(IP,REF,XWBTSKT,"STOP")) K ^XWB(IP,REF,XWBTSKT) Q   ; -- change to param file later ***
"RTN","XWBTCPL",29,0)
 Q:'$$SEMAPHOR(XWBTSKT,"LOCK")  ; -- quit if job is already running
"RTN","XWBTCPL",30,0)
 ;
"RTN","XWBTCPL",31,0)
 D UPDTREC(XWBTSKT,3) ;updt RPC BROKER SITE PARAMETER record as RUNNING
"RTN","XWBTCPL",32,0)
 ;
"RTN","XWBTCPL",33,0)
RESTART ;
"RTN","XWBTCPL",34,0)
 S DONE=0
"RTN","XWBTCPL",35,0)
 S XWBOS=$S(^%ZOSF("OS")["DSM":"DSM",^("OS")["MSM":"MSM",^("OS")["OpenM":"OpenM",1:"")
"RTN","XWBTCPL",36,0)
 IF $$NEWERR^%ZTER N $ESTACK S $ETRAP="D ETRAP^XWBTCPL"
"RTN","XWBTCPL",37,0)
 E  S X="ETRAP^XWBTCPL",@^%ZOSF("TRAP")
"RTN","XWBTCPL",38,0)
 ;
"RTN","XWBTCPL",39,0)
 ; -- check the TCP stop parameter
"RTN","XWBTCPL",40,0)
 ;IF $G(^XWB(IP,REF,XWBTSKT,"STOP")) K ^XWB(IP,REF,XWBTSKT) Q   ; -- change to param file later ***
"RTN","XWBTCPL",41,0)
 ;
"RTN","XWBTCPL",42,0)
 I XWBOS="DSM" O XWBTSKT:TCPCHAN:5 ;Open listener
"RTN","XWBTCPL",43,0)
 F  D  Q:DONE
"RTN","XWBTCPL",44,0)
 . L +^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")
"RTN","XWBTCPL",45,0)
 . K ^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")   ;clear problem marker
"RTN","XWBTCPL",46,0)
 . L -^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")
"RTN","XWBTCPL",47,0)
 . ; -- listen for connect & get the initial message from the client
"RTN","XWBTCPL",48,0)
 . I XWBOS="DSM" U XWBTSKT
"RTN","XWBTCPL",49,0)
 . I XWBOS="MSM" S XWBTDEV=56 O 56 U 56::"TCP" W /SOCKET("",XWBTSKT)
"RTN","XWBTCPL",50,0)
 . I XWBOS="OpenM" S XWBTDEV="|TCP|"_XWBTSKT O XWBTDEV:(:XWBTSKT:"AT") U XWBTDEV R *X
"RTN","XWBTCPL",51,0)
 . S XWBVER=0
"RTN","XWBTCPL",52,0)
 . R LEN#11:3600 IF $E(LEN,1,5)'="{XWB}" Q
"RTN","XWBTCPL",53,0)
 . IF $E(LEN,11,11)="|" D
"RTN","XWBTCPL",54,0)
 . . R X#1:60
"RTN","XWBTCPL",55,0)
 . . R XWBVER#$A(X):60
"RTN","XWBTCPL",56,0)
 . . R LEN#5:60
"RTN","XWBTCPL",57,0)
 . . R MSG#LEN:60
"RTN","XWBTCPL",58,0)
 . ELSE  S X=$E(LEN,11,11),LEN=$E(LEN,6,10)-1 R MSG#LEN:60 S MSG=X_MSG
"RTN","XWBTCPL",59,0)
 . ; -- msg should be:  action^client IP^client port^token
"RTN","XWBTCPL",60,0)
 . ;
"RTN","XWBTCPL",61,0)
 . ; -- if the action is TCPconnect (usual case)
"RTN","XWBTCPL",62,0)
 . I $P(MSG,"^")="TCPconnect" D
"RTN","XWBTCPL",63,0)
 . . ;-- decrypt token
"RTN","XWBTCPL",64,0)
 . . N X,%T S X="",%T=0
"RTN","XWBTCPL",65,0)
 . . ;Job a Server
"RTN","XWBTCPL",66,0)
 . . IF XWBOS="DSM" J EN^XWBTCPC($P(MSG,"^",2),$P(MSG,"^",3),$P(X,"^"),XWBVER,$P(MSG,"^",4)):OPTION="/SYMBOL=100000":5 S %T=$T
"RTN","XWBTCPL",67,0)
 . . IF XWBOS="MSM" J EN^XWBTCPC($P(MSG,"^",2),$P(MSG,"^",3),$P(X,"^"),XWBVER,$P(MSG,"^",4)):100000:5 S %T=$T
"RTN","XWBTCPL",68,0)
 . . I XWBOS="OpenM" J EN^XWBTCPC($P(MSG,"^",2),$P(MSG,"^",3),$P(X,"^"),XWBVER,$P(MSG,"^",4))::5 S %T=$T
"RTN","XWBTCPL",69,0)
 . . I %T D SNDERR W "accept",$C(4),!
"RTN","XWBTCPL",70,0)
 . . E  D SNDERR W "reject",$C(4),! S ^TMP("TCP",$P($H,",",2))="REJECT"
"RTN","XWBTCPL",71,0)
 . ;
"RTN","XWBTCPL",72,0)
 . ; -- if the action is TCPdebug (when msg handler run interactively)
"RTN","XWBTCPL",73,0)
 . I $P(MSG,"^")="TCPdebug" D SNDERR W "accept",$C(4),!
"RTN","XWBTCPL",74,0)
 . ;
"RTN","XWBTCPL",75,0)
 . ; -- if the action is TCPshutdown, this listener will quit if the
"RTN","XWBTCPL",76,0)
 . ;    stop flag has been set.  This request comes from an M process.
"RTN","XWBTCPL",77,0)
 . I $P(MSG,"^")="TCPshutdown" S DONE=1 W "ack",!
"RTN","XWBTCPL",78,0)
 . ;Now release the connection.
"RTN","XWBTCPL",79,0)
 . I XWBOS="DSM" U XWBTSKT:DISCONNECT ; release this socket
"RTN","XWBTCPL",80,0)
 . I XWBOS="MSM" C 56
"RTN","XWBTCPL",81,0)
 . I XWBOS="OpenM" C XWBTDEV
"RTN","XWBTCPL",82,0)
 . Q
"RTN","XWBTCPL",83,0)
 ; -- loop end
"RTN","XWBTCPL",84,0)
 ;
"RTN","XWBTCPL",85,0)
 IF XWBOS="DSM" C XWBTSKT
"RTN","XWBTCPL",86,0)
 S %=$$SEMAPHOR(XWBTSKT,"UNLOCK") ; destroy 'running flag'
"RTN","XWBTCPL",87,0)
 ;K ^XWB(IP,REF,XWBTSKT,"STOP")
"RTN","XWBTCPL",88,0)
 D UPDTREC(XWBTSKT,6) ;updt RPC BROKER SITE PARAMETER record as STOPPED
"RTN","XWBTCPL",89,0)
 Q
"RTN","XWBTCPL",90,0)
 ;
"RTN","XWBTCPL",91,0)
ETRAP   ; -- on trapped error, send error info to client
"RTN","XWBTCPL",92,0)
 N XWBERR
"RTN","XWBTCPL",93,0)
 S XWBERR=$C(24)_"M  ERROR="_$$EC^%ZOSV_$C(13,10)_"LAST REF="_$$LGR^%ZOSV_$C(4)
"RTN","XWBTCPL",94,0)
 D ^%ZTER ;Record it
"RTN","XWBTCPL",95,0)
 S RETRY=$G(RETRY)+1 H 3
"RTN","XWBTCPL",96,0)
 IF RETRY=5 H  ;give up trying, server should not restart
"RTN","XWBTCPL",97,0)
 IF $$NEWERR^%ZTER S $ETRAP="Q:($ESTACK&'$QUIT)  Q:$ESTACK 0 S $ECODE="""" G RESTART^XWBTCPL"
"RTN","XWBTCPL",98,0)
 IF XWBOS="DSM" D
"RTN","XWBTCPL",99,0)
 . I $D(XWBTLEN),XWBTLEN,XWBERR'["SYSTEM-F" D SNDERR W XWBERR
"RTN","XWBTCPL",100,0)
 IF XWBOS'="DSM" D  G RESTART
"RTN","XWBTCPL",101,0)
 . D SNDERR W XWBERR
"RTN","XWBTCPL",102,0)
 S $ECODE=",U1," Q  ;Pass error up to pop stack.
"RTN","XWBTCPL",103,0)
 ;
"RTN","XWBTCPL",104,0)
SNDERR ;send error information
"RTN","XWBTCPL",105,0)
 ;XWBSEC is the security packet, XWBERROR is application packet
"RTN","XWBTCPL",106,0)
 N X
"RTN","XWBTCPL",107,0)
 S X=$G(XWBSEC)
"RTN","XWBTCPL",108,0)
 W $C($L(X))_X
"RTN","XWBTCPL",109,0)
 S X=$G(XWBERROR)
"RTN","XWBTCPL",110,0)
 W $C($L(X))_X W !
"RTN","XWBTCPL",111,0)
 S XWBERROR="" ;clears parameters
"RTN","XWBTCPL",112,0)
 Q
"RTN","XWBTCPL",113,0)
 ;
"RTN","XWBTCPL",114,0)
UPDTREC(XWBTSKT,STATE,XWBENV) ; -- update STATUS field and ^%ZIS X-ref of the
"RTN","XWBTCPL",115,0)
 ;RPC BROKER SITE PARAMETER file
"RTN","XWBTCPL",116,0)
 ;XWBTSKT: listener port
"RTN","XWBTCPL",117,0)
 N C,XWBOXIEN,XWBPOIEN,XWBFDA
"RTN","XWBTCPL",118,0)
 S C=",",U="^"
"RTN","XWBTCPL",119,0)
 I $G(XWBENV)'="" S Y=XWBENV
"RTN","XWBTCPL",120,0)
 E  D GETENV^%ZOSV ;get Y=UCI^VOL^NODE^BOXLOOKUP of current system
"RTN","XWBTCPL",121,0)
 ;I STATE=3 S ^%ZIS(8994.171,"RPCB Listener",$P(Y,U,2),$P(Y,U),$P(Y,U,4),XWBTSKT)=$J
"RTN","XWBTCPL",122,0)
 ;I STATE=6 K ^%ZIS(8994.171,"RPCB Listener",$P(Y,U,2),$P(Y,U),$P(Y,U,4),XWBTSKT)
"RTN","XWBTCPL",123,0)
 ;
"RTN","XWBTCPL",124,0)
 S XWBOXIEN=$$FIND1^DIC(8994.17,",1,","",$P(Y,U,4)) ;find rec for box
"RTN","XWBTCPL",125,0)
 S XWBPOIEN=$$FIND1^DIC(8994.171,C_XWBOXIEN_",1,","",XWBTSKT)
"RTN","XWBTCPL",126,0)
 D:XWBPOIEN>0  ;update STATUS field if entry was found
"RTN","XWBTCPL",127,0)
 . D FDA^DILF(8994.171,XWBPOIEN_C_XWBOXIEN_C_1_C,1,"R",STATE,"XWBFDA")
"RTN","XWBTCPL",128,0)
 . D FILE^DIE("","XWBFDA")
"RTN","XWBTCPL",129,0)
 Q
"RTN","XWBTCPL",130,0)
 ;
"RTN","XWBTCPL",131,0)
 ;
"RTN","XWBTCPL",132,0)
SEMAPHOR(XWBTSKT,XWBACT) ;Lock/Unlock listener semaphore
"RTN","XWBTCPL",133,0)
 ;XWBTSKT: listener port, XWBACT: "LOCK" | "UNLOCK" action to perform
"RTN","XWBTCPL",134,0)
 ;if LOCK is requested, it will be attempted with 1 sec timeout and if
"RTN","XWBTCPL",135,0)
 ;lock was obtained RESULT will be 1, otherwise it will be 0.  For
"RTN","XWBTCPL",136,0)
 ;unlock RESULT will always be 1.
"RTN","XWBTCPL",137,0)
 N RESULT
"RTN","XWBTCPL",138,0)
 S U="^",RESULT=1
"RTN","XWBTCPL",139,0)
 D GETENV^%ZOSV ;get Y=UCI^VOL^NODE^BOXLOOKUP of current system
"RTN","XWBTCPL",140,0)
 I XWBACT="LOCK" D
"RTN","XWBTCPL",141,0)
 . L +^%ZIS(8994.171,"RPCB Listener",$P(Y,U,2),$P(Y,U),$P(Y,U,4),XWBTSKT):1
"RTN","XWBTCPL",142,0)
 . S RESULT=$T
"RTN","XWBTCPL",143,0)
 E  L -^%ZIS(8994.171,"RPCB Listener",$P(Y,U,2),$P(Y,U),$P(Y,U,4),XWBTSKT)
"RTN","XWBTCPL",144,0)
 Q RESULT
"RTN","XWBZ1")
0^10^B1884371
"RTN","XWBZ1",1,0)
XWBZ1 ;ISC-SF/EG - DHCP BROKER PROTOYPE TESTER [ 02/22/95  11:07 PM ] ;03/28/97  14:50
"RTN","XWBZ1",2,0)
 ;;1.1;RPC BROKER;;Mar 28, 1997
"RTN","XWBZ1",3,0)
ECHO1(Y,X) ;don't call direct
"RTN","XWBZ1",4,0)
 S Y=X
"RTN","XWBZ1",5,0)
 Q
"RTN","XWBZ1",6,0)
 ;
"RTN","XWBZ1",7,0)
GLOB1(Y,N) ;callback for global parameter - don't call direct
"RTN","XWBZ1",8,0)
 S Y=$NA(@N)
"RTN","XWBZ1",9,0)
 Q
"RTN","XWBZ1",10,0)
 ;
"RTN","XWBZ1",11,0)
LIST(Y) ; -- return list box with 28 entries
"RTN","XWBZ1",12,0)
 N I
"RTN","XWBZ1",13,0)
 F I=1:1:28 S Y(I)="List Item #"_I
"RTN","XWBZ1",14,0)
 Q
"RTN","XWBZ1",15,0)
 ;
"RTN","XWBZ1",16,0)
WP(Y) ; -- return text a word processing (50 lines)
"RTN","XWBZ1",17,0)
 N I
"RTN","XWBZ1",18,0)
 F I=1:1:50 S Y(I)="The quick brown fox jumped over the lazy dog."
"RTN","XWBZ1",19,0)
 S Y(51)="End of document."
"RTN","XWBZ1",20,0)
 Q
"RTN","XWBZ1",21,0)
 ;
"RTN","XWBZ1",22,0)
BIG(Y) ; -- send a 32K string
"RTN","XWBZ1",23,0)
 N I,Z
"RTN","XWBZ1",24,0)
 S $P(Z,"D",16)=""
"RTN","XWBZ1",25,0)
 K ^TMP($J,"XWBBIG")
"RTN","XWBZ1",26,0)
 F I=1:1:2048 S ^TMP($J,"XWBBIG",I)=Z
"RTN","XWBZ1",27,0)
 S Y=$NA(^TMP($J,"XWBBIG"))
"RTN","XWBZ1",28,0)
 Q
"RTN","XWBZ1",29,0)
 ;
"RTN","XWBZ1",30,0)
SRT(Y,D,X) ; -- sort array x and return in y
"RTN","XWBZ1",31,0)
 N I,K,T
"RTN","XWBZ1",32,0)
 S K=""
"RTN","XWBZ1",33,0)
 IF D="LO" D  Q
"RTN","XWBZ1",34,0)
 . F I=1:1 D  Q:K=""
"RTN","XWBZ1",35,0)
 . . S K=$O(X(K)) Q:K=""
"RTN","XWBZ1",36,0)
 . . S Y(I)=K
"RTN","XWBZ1",37,0)
 IF D="HI" D
"RTN","XWBZ1",38,0)
 . F I=1:1 D  Q:K=""
"RTN","XWBZ1",39,0)
 . . S K=$O(X(K)) Q:K=""
"RTN","XWBZ1",40,0)
 . . S T(99999999-I)=K
"RTN","XWBZ1",41,0)
 . S K=0
"RTN","XWBZ1",42,0)
 . F I=1:1 D  Q:K=""
"RTN","XWBZ1",43,0)
 . . S K=$O(T(K)) Q:K=""
"RTN","XWBZ1",44,0)
 . . S Y(I)=T(K)
"RTN","XWBZ1",45,0)
 Q
"RTN","XWBZ1",46,0)
 ;
"RTN","XWBZ1",47,0)
MEMO(Y,X) ;
"RTN","XWBZ1",48,0)
 K ^TMP("EG",$J,"MEMO")
"RTN","XWBZ1",49,0)
 S ^TMP("EG",$J,"MEMO",-9000)="DHCP RECEIVED:"
"RTN","XWBZ1",50,0)
 M ^TMP("EG",$J,"MEMO")=X
"RTN","XWBZ1",51,0)
 S Y=$NA(^TMP("EG",$J,"MEMO"))
"RTN","XWBZ1",52,0)
 Q
"RTN","XWBZ1",53,0)
 ;
"SEC","^DIC",8994,8994,0,"AUDIT")
@
"SEC","^DIC",8994,8994,0,"DD")
@
"SEC","^DIC",8994,8994,0,"DEL")
@
"SEC","^DIC",8994,8994,0,"LAYGO")
@
"SEC","^DIC",8994,8994,0,"RD")
@
"SEC","^DIC",8994,8994,0,"WR")
@
"SEC","^DIC",8994.1,8994.1,0,"AUDIT")
@
"SEC","^DIC",8994.1,8994.1,0,"DD")
@
"SEC","^DIC",8994.1,8994.1,0,"DEL")
@
"SEC","^DIC",8994.1,8994.1,0,"LAYGO")
@
"SEC","^DIC",8994.1,8994.1,0,"RD")
@
"SEC","^DIC",8994.1,8994.1,0,"WR")
@
"VER")
8^21.0
"^DD",8994,8994,0)
FIELD^^3^11
"^DD",8994,8994,0,"DDA")
N
"^DD",8994,8994,0,"DT")
2970807
"^DD",8994,8994,0,"IX","B",8994,.01)

"^DD",8994,8994,0,"NM","REMOTE PROCEDURE")

"^DD",8994,8994,0,"PT",19.05,.01)

"^DD",8994,8994,0,"VRPK")
RPC BROKER
"^DD",8994,8994,.01,0)
NAME^RF^^0;1^K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E) X
"^DD",8994,8994,.01,1,0)
^.1
"^DD",8994,8994,.01,1,1,0)
8994^B
"^DD",8994,8994,.01,1,1,1)
S ^XWB(8994,"B",$E(X,1,30),DA)=""
"^DD",8994,8994,.01,1,1,2)
K ^XWB(8994,"B",$E(X,1,30),DA)
"^DD",8994,8994,.01,3)
NAME MUST BE 3-30 CHARACTERS, NOT NUMERIC OR STARTING WITH PUNCTUATION
"^DD",8994,8994,.02,0)
TAG^F^^0;2^K:$L(X)>8!($L(X)<1) X
"^DD",8994,8994,.02,3)
Enter the TAG to be used as the entry point for the routine.  Leave this field empty if a TAG is not required.
"^DD",8994,8994,.02,"DT")
2941213
"^DD",8994,8994,.03,0)
ROUTINE^RF^^0;3^K:$L(X)>8!($L(X)<3)!'(X?1U1.7UN) X
"^DD",8994,8994,.03,3)
This is the name of the routine used by this API
"^DD",8994,8994,.03,"DT")
2941213
"^DD",8994,8994,.04,0)
RETURN VALUE TYPE^RS^1:SINGLE VALUE;2:ARRAY;3:WORD PROCESSING;4:GLOBAL ARRAY;5:GLOBAL INSTANCE;^0;4^Q
"^DD",8994,8994,.04,3)
Select the appropriate value to indicate what type of value will be returned by the API.
"^DD",8994,8994,.04,21,0)
^^49^49^2970904^^^^
"^DD",8994,8994,.04,21,1,0)
This field tells RPC Broker how to process the resulting data from the call.
"^DD",8994,8994,.04,21,2,0)

"^DD",8994,8994,.04,21,3,0)
SINGLE VALUE: Broker will return the value of the return parameter (first
"^DD",8994,8994,.04,21,4,0)
   parameter in the formal list).  For example,
"^DD",8994,8994,.04,21,5,0)
       TAG(RESULT)     ;
"^DD",8994,8994,.04,21,6,0)
               S RESULT="DOE, JOHN"
"^DD",8994,8994,.04,21,7,0)
               Q
"^DD",8994,8994,.04,21,8,0)

"^DD",8994,8994,.04,21,9,0)
ARRAY: Using $ORDER Broker will traverse the return parameter (first
"^DD",8994,8994,.04,21,10,0)
   parameter in the formal list), returning all elements of the array.
"^DD",8994,8994,.04,21,11,0)
   For example,
"^DD",8994,8994,.04,21,12,0)
       TAG(RESULT)     ;
"^DD",8994,8994,.04,21,13,0)
               S RESULT(1)="ONE"
"^DD",8994,8994,.04,21,14,0)
               S RESULT(2)="TWO"
"^DD",8994,8994,.04,21,15,0)
               Q
"^DD",8994,8994,.04,21,16,0)

"^DD",8994,8994,.04,21,17,0)
WORD PROCESSING: This type is treated exactly the same way as the ARRAY,
"^DD",8994,8994,.04,21,18,0)
   with one exception that the WORD WRAP ON field is used to
"^DD",8994,8994,.04,21,19,0)
   control whether each line returned is terminated with CR + LF characters.
"^DD",8994,8994,.04,21,20,0)
   See WORD WRAP ON field description for more information.
"^DD",8994,8994,.04,21,21,0)

"^DD",8994,8994,.04,21,22,0)
GLOBAL ARRAY: Return value parameter should be set to a closed global
"^DD",8994,8994,.04,21,23,0)
   reference in ^TMP. The global's data nodes will be traversed using
"^DD",8994,8994,.04,21,24,0)
   $QUERY, and all data values on global nodes descendant from the global
"^DD",8994,8994,.04,21,25,0)
   reference are returned.  This type is especially useful for returning data
"^DD",8994,8994,.04,21,26,0)
   from VA FileMan word processing fields, where each line is on a
"^DD",8994,8994,.04,21,27,0)
   0-subscripted node.
"^DD",8994,8994,.04,21,28,0)

"^DD",8994,8994,.04,21,29,0)
   Important: The global reference you pass is killed by the Broker at the
"^DD",8994,8994,.04,21,30,0)
              end of RPC Execution as part of RPC cleanup. Do not pass a
"^DD",8994,8994,.04,21,31,0)
              global reference that is not in ^TMP or that should not be
"^DD",8994,8994,.04,21,32,0)
              killed.
"^DD",8994,8994,.04,21,33,0)

"^DD",8994,8994,.04,21,34,0)
   This type is useful for returning large amounts of data to the client,
"^DD",8994,8994,.04,21,35,0)
   where using the ARRAY type can exceed the symbol table limit and crash
"^DD",8994,8994,.04,21,36,0)
   your RPC.
"^DD",8994,8994,.04,21,37,0)

"^DD",8994,8994,.04,21,38,0)
   For example, to return sign-on introductory text you could do this,
"^DD",8994,8994,.04,21,39,0)
       TAG(RESULT)     ;
"^DD",8994,8994,.04,21,40,0)
               M RESULT=^XTV(8989.3,1,"INTRO")
"^DD",8994,8994,.04,21,41,0)
               K RESULT(0)  ;this node is not needed
"^DD",8994,8994,.04,21,42,0)
               Q
"^DD",8994,8994,.04,21,43,0)

"^DD",8994,8994,.04,21,44,0)
GLOBAL INSTANCE: Using this type Broker will return the value of a global
"^DD",8994,8994,.04,21,45,0)
   node.  For example the following code will return the whole 0th node
"^DD",8994,8994,.04,21,46,0)
   from the NEW PERSON file for the current user.
"^DD",8994,8994,.04,21,47,0)
       TAG(RESULT)     ;
"^DD",8994,8994,.04,21,48,0)
               S RESULT=$NA(^VA(200,DUZ,0))
"^DD",8994,8994,.04,21,49,0)
               Q
"^DD",8994,8994,.04,"DT")
2950712
"^DD",8994,8994,.05,0)
AVAILABILITY^S^P:PUBLIC;S:SUBSCRIPTION;A:AGREEMENT;R:RESTRICTED;^0;5^Q
"^DD",8994,8994,.05,3)
Select the appropriate indicator of the availability of this API as PUBLIC (general), SUBSCRIPTION (need to subscribe), AGREEMENT required, or RESTRICTED to the developing package.
"^DD",8994,8994,.05,21,0)
^^19^19^2941213^
"^DD",8994,8994,.05,21,1,0)
This field is used to indicate the availability of the API to various
"^DD",8994,8994,.05,21,2,0)
users.
"^DD",8994,8994,.05,21,3,0)

"^DD",8994,8994,.05,21,4,0)
PUBLIC indicates that the API is available for general use by any package,
"^DD",8994,8994,.05,21,5,0)
and it is not necessary to either indicate that the API is being used or
"^DD",8994,8994,.05,21,6,0)
to request permission to use it.
"^DD",8994,8994,.05,21,7,0)

"^DD",8994,8994,.05,21,8,0)
SUBSCRIPTION indicates that the API is available to those packages that
"^DD",8994,8994,.05,21,9,0)
wish to use it, BUT the package needs to indicate that it is using the API
"^DD",8994,8994,.05,21,10,0)
or subscribing to it.
"^DD",8994,8994,.05,21,11,0)

"^DD",8994,8994,.05,21,12,0)
AGREEMENT indicates that the API is available to packages, other than the
"^DD",8994,8994,.05,21,13,0)
developing package, only by means of an integration agreement on its
"^DD",8994,8994,.05,21,14,0)
usage.
"^DD",8994,8994,.05,21,15,0)

"^DD",8994,8994,.05,21,16,0)
RESTRICTED indicates that the API is not available for reference by any
"^DD",8994,8994,.05,21,17,0)
package other than the package which developed it.  Entry of the input and
"^DD",8994,8994,.05,21,18,0)
return parameter information is at the option of the developing package in
"^DD",8994,8994,.05,21,19,0)
this case.
"^DD",8994,8994,.05,"DT")
2941213
"^DD",8994,8994,.06,0)
INACTIVE^S^1:INACTIVE;^0;6^Q
"^DD",8994,8994,.06,3)
Enter 1 or I only if this API is currently inactive and not available for use.
"^DD",8994,8994,.06,21,0)
^^2^2^2941213^
"^DD",8994,8994,.06,21,1,0)
This field is used to indicate that the API is not available for any usage
"^DD",8994,8994,.06,21,2,0)
for some reason.
"^DD",8994,8994,.06,"DT")
2941213
"^DD",8994,8994,.07,0)
CLIENT MANAGER^S^1:YES;^0;7^Q
"^DD",8994,8994,.07,3)
Enter 1 or YES if this API requires other configuration information related to transmission to the client.
"^DD",8994,8994,.07,21,0)
^^4^4^2970905^^^
"^DD",8994,8994,.07,21,1,0)
This field is used to identify those APIs which may be initiated to
"^DD",8994,8994,.07,21,2,0)
control the client or to send data to the client unrelated to requests
"^DD",8994,8994,.07,21,3,0)
from the client.  These actions usually require additional information on
"^DD",8994,8994,.07,21,4,0)
the configuration which is present.
"^DD",8994,8994,.07,"DT")
2941215
"^DD",8994,8994,.08,0)
WORD WRAP ON^S^0:FALSE;1:TRUE;^0;8^Q
"^DD",8994,8994,.08,21,0)
^^9^9^2970904^^^^
"^DD",8994,8994,.08,21,1,0)
Affects GLOBAL ARRAY and WORD PROCESSING return value types only. If set to
"^DD",8994,8994,.08,21,2,0)
FALSE, all data values are returned in a single concatenated string in
"^DD",8994,8994,.08,21,3,0)
Results[0]. If set to TRUE, each array node on the M side is returned as a
"^DD",8994,8994,.08,21,4,0)
distinct array item in the Results property of the TRPCBroker.
"^DD",8994,8994,.08,21,5,0)

"^DD",8994,8994,.08,21,6,0)
If you're returning some text to the client and you'd rather let the
"^DD",8994,8994,.08,21,7,0)
memo box of the client control the wrapping of lines, set WORD WRAP ON
"^DD",8994,8994,.08,21,8,0)
to FALSE.  On the other hand, if you want to preserve line breaks as they
"^DD",8994,8994,.08,21,9,0)
exist on the server, set WORD WRAP ON to TRUE.
"^DD",8994,8994,.08,"DT")
2950804
"^DD",8994,8994,1,0)
DESCRIPTION^8994.01^^1;0
"^DD",8994,8994,2,0)
INPUT PARAMETER^8994.02A^^2;0
"^DD",8994,8994,2,21,0)
^^4^4^2970807^^^^
"^DD",8994,8994,2,21,1,0)
Input parameter is what RPC Broker passes into your remote procedure.  The
"^DD",8994,8994,2,21,2,0)
name that you may call the input parameter has no special meaning to the
"^DD",8994,8994,2,21,3,0)
Broker.  However, you should choose a name that best describes the data
"^DD",8994,8994,2,21,4,0)
that the parameter is used for.
"^DD",8994,8994,3,0)
RETURN PARAMETER DESCRIPTION^8994.03^^3;0
"^DD",8994,8994.01,0)
DESCRIPTION SUB-FIELD^^.01^1
"^DD",8994,8994.01,0,"DT")
2941213
"^DD",8994,8994.01,0,"NM","DESCRIPTION")

"^DD",8994,8994.01,0,"UP")
8994
"^DD",8994,8994.01,.01,0)
DESCRIPTION^WL^^0;1^Q
"^DD",8994,8994.01,.01,3)
Please enter a brief description of the purpose of this API
"^DD",8994,8994.01,.01,21,0)
^^2^2^2941213^
"^DD",8994,8994.01,.01,21,1,0)
This field is a word processing field for describing the purpose of the
"^DD",8994,8994.01,.01,21,2,0)
API.
"^DD",8994,8994.01,.01,"DT")
2941213
"^DD",8994,8994.02,0)
INPUT PARAMETER SUB-FIELD^^.05^6
"^DD",8994,8994.02,0,"DT")
2970807
"^DD",8994,8994.02,0,"IX","B",8994.02,.01)

"^DD",8994,8994.02,0,"IX","PARAMSEQ",8994.02,.05)

"^DD",8994,8994.02,0,"NM","INPUT PARAMETER")

"^DD",8994,8994.02,0,"UP")
8994
"^DD",8994,8994.02,.01,0)
INPUT PARAMETER^MF^^0;1^K:$L(X)>30!($L(X)<3) X
"^DD",8994,8994.02,.01,1,0)
^.1
"^DD",8994,8994.02,.01,1,1,0)
8994.02^B
"^DD",8994,8994.02,.01,1,1,1)
S ^XWB(8994,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",8994,8994.02,.01,1,1,2)
K ^XWB(8994,DA(1),2,"B",$E(X,1,30),DA)
"^DD",8994,8994.02,.01,3)
Answer must be 3-30 characters in length.
"^DD",8994,8994.02,.01,21,0)
^^1^1^2941213^
"^DD",8994,8994.02,.01,21,1,0)
This field is used to identify an input parameter for the API.
"^DD",8994,8994.02,.01,"DT")
2941213
"^DD",8994,8994.02,.02,0)
PARAMETER TYPE^S^1:LITERAL;2:LIST;3:WORD PROCESSING;4:REFERENCE;^0;2^Q
"^DD",8994,8994.02,.02,3)
Select the appropriate value indicating whether the parameter is a literal, a list, a reference or a word processing string.
"^DD",8994,8994.02,.02,21,0)
^^4^4^2970807^
"^DD",8994,8994.02,.02,21,1,0)
This field is used to indicate the type (Literal, List, Reference, or Word
"^DD",8994,8994.02,.02,21,2,0)
Processing entry) of value passed by this parameter.  The Literal, List,
"^DD",8994,8994.02,.02,21,3,0)
and Reference types correspond to the TParamType of the same name.  A Word
"^DD",8994,8994.02,.02,21,4,0)
Processing type would also be a List TParamType.
"^DD",8994,8994.02,.02,23,0)
^^5^5^2970807^^^^
"^DD",8994,8994.02,.02,23,1,0)
Currently, this field is used only for documenting the RPC's input
"^DD",8994,8994.02,.02,23,2,0)
parameters.
"^DD",8994,8994.02,.02,23,3,0)

"^DD",8994,8994.02,.02,23,4,0)
In version 1.0 of the RPC Broker the Literal type was called Single Value
"^DD",8994,8994.02,.02,23,5,0)
and the List type was called Array.
"^DD",8994,8994.02,.02,"DT")
2970807
"^DD",8994,8994.02,.03,0)
MAXIMUM DATA LENGTH^NJ5,0^^0;3^K:+X'=X!(X>32000)!(X<1)!(X?.E1"."1N.N) X
"^DD",8994,8994.02,.03,3)
Indicate the maximum length of the parameter, type a Number between 1 and 32000, 0 Decimal Digits
"^DD",8994,8994.02,.03,21,0)
^^2^2^2941213^
"^DD",8994,8994.02,.03,21,1,0)
This field indicates the maximum length that would be expected for the
"^DD",8994,8994.02,.03,21,2,0)
parameter value.
"^DD",8994,8994.02,.03,"DT")
2941213
"^DD",8994,8994.02,.04,0)
REQUIRED^S^1:YES;0:NO;^0;4^Q
"^DD",8994,8994.02,.04,3)
This field is used to indicate when an input parameter is required in the API call.
"^DD",8994,8994.02,.04,21,0)
^^2^2^2941215^
"^DD",8994,8994.02,.04,21,1,0)
This field is used to indicate that the input parameter is a required
"^DD",8994,8994.02,.04,21,2,0)
argument in the API call.
"^DD",8994,8994.02,.04,"DT")
2941215
"^DD",8994,8994.02,.05,0)
SEQUENCE NUMBER^NJ2,0^^0;5^K:+X'=X!(X>30)!(X<1)!(X?.E1"."1N.N) X
"^DD",8994,8994.02,.05,1,0)
^.1
"^DD",8994,8994.02,.05,1,1,0)
8994.02^PARAMSEQ
"^DD",8994,8994.02,.05,1,1,1)
S ^XWB(8994,DA(1),2,"PARAMSEQ",$E(X,1,30),DA)=""
"^DD",8994,8994.02,.05,1,1,2)
K ^XWB(8994,DA(1),2,"PARAMSEQ",$E(X,1,30),DA)
"^DD",8994,8994.02,.05,1,1,"DT")
2970328
"^DD",8994,8994.02,.05,3)
Type a Number between 1 and 30, 0 Decimal Digits
"^DD",8994,8994.02,.05,21,0)
^^14^14^2970327^
"^DD",8994,8994.02,.05,21,1,0)
This number should correspond to the position of this parameter in the
"^DD",8994,8994.02,.05,21,2,0)
formal list of the function.  Consider that the return parameter that
"^DD",8994,8994.02,.05,21,3,0)
Broker passes in, by reference, is the very first parameter with the
"^DD",8994,8994.02,.05,21,4,0)
sequence number of 0.  The next parameter is the first application-supplied
"^DD",8994,8994.02,.05,21,5,0)
parameter with the sequence of 1.
"^DD",8994,8994.02,.05,21,6,0)

"^DD",8994,8994.02,.05,21,7,0)
Example:
"^DD",8994,8994.02,.05,21,8,0)

"^DD",8994,8994.02,.05,21,9,0)
  Your entry point may look like:
"^DD",8994,8994.02,.05,21,10,0)

"^DD",8994,8994.02,.05,21,11,0)
    EN(RESULT,USER,DATE)       ;this will do something
"^DD",8994,8994.02,.05,21,12,0)

"^DD",8994,8994.02,.05,21,13,0)
      In this case the parameter corresponding to USER should have sequence
"^DD",8994,8994.02,.05,21,14,0)
      number 1 and the DATE parameter should be 2.
"^DD",8994,8994.02,.05,"DT")
2970328
"^DD",8994,8994.02,1,0)
DESCRIPTION^8994.021^^1;0
"^DD",8994,8994.021,0)
DESCRIPTION SUB-FIELD^^.01^1
"^DD",8994,8994.021,0,"DT")
2941213
"^DD",8994,8994.021,0,"NM","DESCRIPTION")

"^DD",8994,8994.021,0,"UP")
8994.02
"^DD",8994,8994.021,.01,0)
DESCRIPTION^WL^^0;1^Q
"^DD",8994,8994.021,.01,3)
Please enter a brief description of this input parameter.
"^DD",8994,8994.021,.01,21,0)
^^2^2^2941213^
"^DD",8994,8994.021,.01,21,1,0)
This field is used for a description of the meaning or function of the
"^DD",8994,8994.021,.01,21,2,0)
input parameter.
"^DD",8994,8994.021,.01,"DT")
2941213
"^DD",8994,8994.03,0)
RETURN PARAMETER DESCRIPTION SUB-FIELD^^.01^1
"^DD",8994,8994.03,0,"DT")
2941213
"^DD",8994,8994.03,0,"NM","RETURN PARAMETER DESCRIPTION")

"^DD",8994,8994.03,0,"UP")
8994
"^DD",8994,8994.03,.01,0)
RETURN PARAMETER DESCRIPTION^WL^^0;1^Q
"^DD",8994,8994.03,.01,3)
Enter a brief description of the return value from this API
"^DD",8994,8994.03,.01,21,0)
^^2^2^2941213^
"^DD",8994,8994.03,.01,21,1,0)
This field is used to obtain a brief description of the return parameter
"^DD",8994,8994.03,.01,21,2,0)
and what it represents.
"^DD",8994,8994.03,.01,"DT")
2941213
"^DD",8994.1,8994.1,0)
FIELD^^7^2
"^DD",8994.1,8994.1,0,"DDA")
N
"^DD",8994.1,8994.1,0,"DT")
2961016
"^DD",8994.1,8994.1,0,"IX","B",8994.1,.01)

"^DD",8994.1,8994.1,0,"IX","C",8994.171,1)

"^DD",8994.1,8994.1,0,"NM","RPC BROKER SITE PARAMETERS")

"^DD",8994.1,8994.1,.01,0)
DOMAIN NAME^RP4.2'X^DIC(4.2,^0;1^S DINUM=1
"^DD",8994.1,8994.1,.01,1,0)
^.1
"^DD",8994.1,8994.1,.01,1,1,0)
8994.1^B
"^DD",8994.1,8994.1,.01,1,1,1)
S ^XWB(8994.1,"B",$E(X,1,30),DA)=""
"^DD",8994.1,8994.1,.01,1,1,2)
K ^XWB(8994.1,"B",$E(X,1,30),DA)
"^DD",8994.1,8994.1,.01,3)

"^DD",8994.1,8994.1,.01,21,0)
^^4^4^2960829^^^^
"^DD",8994.1,8994.1,.01,21,1,0)
This is the name of this installation of the RPC Broker, as it is known
"^DD",8994.1,8994.1,.01,21,2,0)
to the rest of the network. It must appear in the DOMAIN file.
"^DD",8994.1,8994.1,.01,21,3,0)
This name applies to all CPUs or Volume sets which access this ^XWB
"^DD",8994.1,8994.1,.01,21,4,0)
global.
"^DD",8994.1,8994.1,.01,"DT")
2960829
"^DD",8994.1,8994.1,7,0)
LISTENER^8994.17P^^7;0
"^DD",8994.1,8994.1,7,21,0)
^^4^4^2961016^^^^
"^DD",8994.1,8994.1,7,21,1,0)
This field contains all the information that the Broker needs to run a
"^DD",8994.1,8994.1,7,21,2,0)
background process, which accepts incoming connection requests.  The listener
"^DD",8994.1,8994.1,7,21,3,0)
doesn't execute the client's RPCs.  The listener starts up other processes
"^DD",8994.1,8994.1,7,21,4,0)
as handlers, which run RPCs.
"^DD",8994.1,8994.17,0)
LISTENER SUB-FIELD^^1^2
"^DD",8994.1,8994.17,0,"DT")
2961016
"^DD",8994.1,8994.17,0,"IX","B",8994.17,.01)

"^DD",8994.1,8994.17,0,"NM","LISTENER")

"^DD",8994.1,8994.17,0,"UP")
8994.1
"^DD",8994.1,8994.17,.01,0)
BOX-VOLUME PAIR^*P14.7'^%ZIS(14.7,^0;1^S DIC("S")="I $G(XWBCHK)=""ALLOW""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",8994.1,8994.17,.01,1,0)
^.1
"^DD",8994.1,8994.17,.01,1,1,0)
8994.17^B
"^DD",8994.1,8994.17,.01,1,1,1)
S ^XWB(8994.1,DA(1),7,"B",$E(X,1,30),DA)=""
"^DD",8994.1,8994.17,.01,1,1,2)
K ^XWB(8994.1,DA(1),7,"B",$E(X,1,30),DA)
"^DD",8994.1,8994.17,.01,12)
Knowing how to set XWBCHK before editing this field should reduce the likelihood of inappropriate entries.
"^DD",8994.1,8994.17,.01,12.1)
S DIC("S")="I $G(XWBCHK)=""I KNOW WHAT I'M DOING"""
"^DD",8994.1,8994.17,.01,21,0)
^^1^1^2961016^^^^
"^DD",8994.1,8994.17,.01,21,1,0)
This field determines on what CPU and volume set the listener should run.
"^DD",8994.1,8994.17,.01,"DEL",1,0)
I $G(XWBCHK)'="ALLOW"
"^DD",8994.1,8994.17,.01,"DT")
2961016
"^DD",8994.1,8994.17,1,0)
PORT^8994.171^^1;0
"^DD",8994.1,8994.17,1,21,0)
^^10^10^2961016^^^^
"^DD",8994.1,8994.17,1,21,1,0)
This is the TCP/IP port that the listener should monitor for incoming
"^DD",8994.1,8994.17,1,21,2,0)
connection requests.  This is the port which a client should use to
"^DD",8994.1,8994.17,1,21,3,0)
connect to a server.
"^DD",8994.1,8994.17,1,21,4,0)

"^DD",8994.1,8994.17,1,21,5,0)
Don't use a port that is already in use on the CPU where you want to run
"^DD",8994.1,8994.17,1,21,6,0)
the listener.  No two processes can share the same TCP/IP port on the
"^DD",8994.1,8994.17,1,21,7,0)
same CPU.
"^DD",8994.1,8994.17,1,21,8,0)

"^DD",8994.1,8994.17,1,21,9,0)
Typically, port numbers bellow 5000 are reserved for various common TCP/IP
"^DD",8994.1,8994.17,1,21,10,0)
services.  So you should use port numbers above 5000.
"^DD",8994.1,8994.171,0)
PORT SUB-FIELD^^2^4
"^DD",8994.1,8994.171,0,"DT")
2961011
"^DD",8994.1,8994.171,0,"IX","B",8994.171,.01)

"^DD",8994.1,8994.171,0,"NM","PORT")

"^DD",8994.1,8994.171,0,"UP")
8994.17
"^DD",8994.1,8994.171,.01,0)
PORT^NJ4,0^^0;1^K:+X'=X!(X>9999)!(X<9000)!(X?.E1"."1N.N) X
"^DD",8994.1,8994.171,.01,1,0)
^.1
"^DD",8994.1,8994.171,.01,1,1,0)
8994.171^B
"^DD",8994.1,8994.171,.01,1,1,1)
S ^XWB(8994.1,DA(2),7,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",8994.1,8994.171,.01,1,1,2)
K ^XWB(8994.1,DA(2),7,DA(1),1,"B",$E(X,1,30),DA)
"^DD",8994.1,8994.171,.01,1,2,0)
^^TRIGGER^8994.171^1
"^DD",8994.1,8994.171,.01,1,2,1)
K DIV S DIV=X,D0=DA(2),DIV(0)=D0,D1=DA(1),DIV(1)=D1,D2=DA,DIV(2)=D2 S Y(1)=$S($D(^XWB(8994.1,D0,7,D1,1,D2,0)):^(0),1:"") S X=$P(Y(1),U,2),X=X S DIU=X K Y S X=DIV S X="6" X ^DD(8994.171,.01,1,2,1.4)
"^DD",8994.1,8994.171,.01,1,2,1.4)
S DIH=$S($D(^XWB(8994.1,DIV(0),7,DIV(1),1,DIV(2),0)):^(0),1:""),DIV=X S $P(^(0),U,2)=DIV,DIH=8994.171,DIG=1 D ^DICR:$O(^DD(DIH,DIG,1,0))>0
"^DD",8994.1,8994.171,.01,1,2,2)
Q
"^DD",8994.1,8994.171,.01,1,2,"%D",0)
^^6^6^2960829^^
"^DD",8994.1,8994.171,.01,1,2,"%D",1,0)
This TRIGGER Xref initializes the STATUS field of the newly entered port
"^DD",8994.1,8994.171,.01,1,2,"%D",2,0)
to 6 (internal value of STOPPED).
"^DD",8994.1,8994.171,.01,1,2,"%D",3,0)

"^DD",8994.1,8994.171,.01,1,2,"%D",4,0)
This Xref is on the PORT (.01) field of the PORT (1) multiple.
"^DD",8994.1,8994.171,.01,1,2,"%D",5,0)
The SET logic is "6".
"^DD",8994.1,8994.171,.01,1,2,"%D",6,0)
No KILL logic.
"^DD",8994.1,8994.171,.01,1,2,"CREATE VALUE")
"6"
"^DD",8994.1,8994.171,.01,1,2,"DELETE VALUE")
NO EFFECT
"^DD",8994.1,8994.171,.01,1,2,"DT")
2960829
"^DD",8994.1,8994.171,.01,1,2,"FIELD")
STATUS
"^DD",8994.1,8994.171,.01,3)
Type a Number between 9000 and 9999, 0 Decimal Digits
"^DD",8994.1,8994.171,.01,"DT")
2960829
"^DD",8994.1,8994.171,.5,0)
*UCI^F^^0;3^K:$L(X)>10!($L(X)<1) X
"^DD",8994.1,8994.171,.5,3)
Answer must be 1-10 characters in length.
"^DD",8994.1,8994.171,.5,21,0)
^^2^2^2961016^^^
"^DD",8994.1,8994.171,.5,21,1,0)
This is the UCI in which the Broker Listener should run for the port
"^DD",8994.1,8994.171,.5,21,2,0)
you are currently editing.
"^DD",8994.1,8994.171,.5,"DT")
2961016
"^DD",8994.1,8994.171,1,0)
STATUS^*S^1:START;2:STARTING;3:RUNNING;4:STOP;5:STOPPING;6:STOPPED;^0;2^Q
"^DD",8994.1,8994.171,1,1,0)
^.1
"^DD",8994.1,8994.171,1,1,1,0)
8994.1^C^MUMPS
"^DD",8994.1,8994.171,1,1,1,1)
D STATCHG^XWBTCP(.DA,X)
"^DD",8994.1,8994.171,1,1,1,2)
Q
"^DD",8994.1,8994.171,1,1,1,"DT")
2960829
"^DD",8994.1,8994.171,1,5,1,0)
8994.171^.01^2
"^DD",8994.1,8994.171,1,12)
You can only set STATUS to START or STOP.  All other settings are controlled by the RPC Broker itself.
"^DD",8994.1,8994.171,1,12.1)
S DIC("S")="I $$STATSCRN^XWBTCP(Y)"
"^DD",8994.1,8994.171,1,"DT")
2960930
"^DD",8994.1,8994.171,2,0)
CONTROLLED BY LISTENER STARTER^S^0:NO;1:YES;^0;4^Q
"^DD",8994.1,8994.171,2,21,0)
^^9^9^2961016^^^
"^DD",8994.1,8994.171,2,21,1,0)
If you want the Broker listener to start listening on this CPU-port-UCI
"^DD",8994.1,8994.171,2,21,2,0)
when the XWB LISTENER STARTER option is run, enter YES.  All of the
"^DD",8994.1,8994.171,2,21,3,0)
listener entries in this file that have CONTROLLED BY LISTENER STARTER
"^DD",8994.1,8994.171,2,21,4,0)
set to YES will be started when XWB LISTENER STARTER option is run.
"^DD",8994.1,8994.171,2,21,5,0)

"^DD",8994.1,8994.171,2,21,6,0)
Hint: XWB LISTENER STARTER option may be used to start all of the listeners
"^DD",8994.1,8994.171,2,21,7,0)
      you need automatically when the Task Manager is started.  Use the
"^DD",8994.1,8994.171,2,21,8,0)
      Schedule/Unschedule Options option.  In the SPECIAL QUEUEING field
"^DD",8994.1,8994.171,2,21,9,0)
      enter STARTUP.  Leave all other fields empty.
"^DD",8994.1,8994.171,2,"DT")
2961011
"^DIC",8994,8994,0)
REMOTE PROCEDURE^8994
"^DIC",8994,8994,0,"GL")
^XWB(8994,
"^DIC",8994,8994,"%D",0)
^^20^20^2970411^^^^
"^DIC",8994,8994,"%D",1,0)
This file is used as a repository of server-based procedures in the context
"^DIC",8994,8994,"%D",2,0)
of the Client/Server architecture.  By using the Remote Procedure Call (RPC)
"^DIC",8994,8994,"%D",3,0)
Broker, applications running on client workstations can invoke (call) the
"^DIC",8994,8994,"%D",4,0)
procedures in this file to be executed by the server and the results will be
"^DIC",8994,8994,"%D",5,0)
returned to the client application.
"^DIC",8994,8994,"%D",6,0)

"^DIC",8994,8994,"%D",7,0)
Each remote procedure entry is associated with an entry point (ROUTINE with
"^DIC",8994,8994,"%D",8,0)
optional TAG).  Calls to these procedures can include parameters of different
"^DIC",8994,8994,"%D",9,0)
value types.  The resulting value of the call can be either a string, a list
"^DIC",8994,8994,"%D",10,0)
of strings or a word processing string as indicated by the RETURN VALUE TYPE
"^DIC",8994,8994,"%D",11,0)
field (.04).
"^DIC",8994,8994,"%D",12,0)

"^DIC",8994,8994,"%D",13,0)
The remote procedure may be available for use by anyone or its use may be
"^DIC",8994,8994,"%D",14,0)
restricted to one or more application.  The range of availability is indicated
"^DIC",8994,8994,"%D",15,0)
by the AVAILABILITY field.  IF THERE IS NO ENTRY IN THE AVAILABILITY FIELD,
"^DIC",8994,8994,"%D",16,0)
then the procedure is assumed to be PUBLIC.
"^DIC",8994,8994,"%D",17,0)

"^DIC",8994,8994,"%D",18,0)
A remote procedure may be removed from service for a period of time by setting
"^DIC",8994,8994,"%D",19,0)
the INACTIVE field.  A request for use of a procedure which is marked inactive
"^DIC",8994,8994,"%D",20,0)
will result in an error being returned to the originating application.
"^DIC",8994,"B","REMOTE PROCEDURE",8994)

"^DIC",8994.1,8994.1,0)
RPC BROKER SITE PARAMETERS^8994.1
"^DIC",8994.1,8994.1,0,"GL")
^XWB(8994.1,
"^DIC",8994.1,8994.1,"%",0)
^1.005^1^1
"^DIC",8994.1,8994.1,"%",1,0)
XWB
"^DIC",8994.1,8994.1,"%","B","XWB",1)

"^DIC",8994.1,8994.1,"%D",0)
^^2^2^2960829^^^
"^DIC",8994.1,8994.1,"%D",1,0)
This file holds the site parameters for this installation of the RPC Broker.
"^DIC",8994.1,8994.1,"%D",2,0)
It will have only one entry -- the domain name of the installation site.
"^DIC",8994.1,"B","RPC BROKER SITE PARAMETERS",8994.1)

**END**
**END**

