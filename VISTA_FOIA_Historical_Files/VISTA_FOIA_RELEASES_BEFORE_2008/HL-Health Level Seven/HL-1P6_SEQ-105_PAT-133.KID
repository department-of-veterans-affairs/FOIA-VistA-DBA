Released HL*1.6*133 SEQ #105
Extracted from mail message
**KIDS**:HL*1.6*133^

**INSTALL NAME**
HL*1.6*133
"BLD",955,0)
HL*1.6*133^HEALTH LEVEL SEVEN^0^3060913^y
"BLD",955,1,0)
^^2^2^3060627^
"BLD",955,1,1,0)
See the NPM for a complete description of this patch.
"BLD",955,1,2,0)

"BLD",955,4,0)
^9.64PA^870^1
"BLD",955,4,870,0)
870
"BLD",955,4,870,2,0)
^9.641^870^1
"BLD",955,4,870,2,870,0)
HL LOGICAL LINK  (File-top level)
"BLD",955,4,870,2,870,1,0)
^9.6411^200.022^1
"BLD",955,4,870,2,870,1,200.022,0)
CLOSE BEFORE RE-TRANSMISSION
"BLD",955,4,870,222)
y^n^p^^^^n^^n
"BLD",955,4,870,224)

"BLD",955,4,"APDD",870,870)

"BLD",955,4,"APDD",870,870,200.022)

"BLD",955,4,"B",870,870)

"BLD",955,6.3)
13
"BLD",955,"KRN",0)
^9.67PA^8989.52^19
"BLD",955,"KRN",.4,0)
.4
"BLD",955,"KRN",.4,"NM",0)
^9.68A^^
"BLD",955,"KRN",.401,0)
.401
"BLD",955,"KRN",.402,0)
.402
"BLD",955,"KRN",.403,0)
.403
"BLD",955,"KRN",.5,0)
.5
"BLD",955,"KRN",.84,0)
.84
"BLD",955,"KRN",3.6,0)
3.6
"BLD",955,"KRN",3.8,0)
3.8
"BLD",955,"KRN",9.2,0)
9.2
"BLD",955,"KRN",9.8,0)
9.8
"BLD",955,"KRN",9.8,"NM",0)
^9.68A^22^21
"BLD",955,"KRN",9.8,"NM",1,0)
HLMA^^0^B41676692
"BLD",955,"KRN",9.8,"NM",2,0)
HLMA1^^0^B8748290
"BLD",955,"KRN",9.8,"NM",3,0)
HLCSHDR1^^0^B57541761
"BLD",955,"KRN",9.8,"NM",4,0)
HLCSTCP3^^0^B4549114
"BLD",955,"KRN",9.8,"NM",5,0)
HLTP^^0^B8013244
"BLD",955,"KRN",9.8,"NM",6,0)
HLTP1^^0^B8076588
"BLD",955,"KRN",9.8,"NM",7,0)
HLTP3^^0^B73884339
"BLD",955,"KRN",9.8,"NM",8,0)
HLOAPI^^0^B35965894
"BLD",955,"KRN",9.8,"NM",9,0)
HLOAPI2^^0^B37578775
"BLD",955,"KRN",9.8,"NM",10,0)
HLCSTCP^^0^B33765852
"BLD",955,"KRN",9.8,"NM",11,0)
HLCSTCP1^^0^B31809732
"BLD",955,"KRN",9.8,"NM",12,0)
HLCSTCP2^^0^B63043745
"BLD",955,"KRN",9.8,"NM",14,0)
HLTPCK1^^0^B37602285
"BLD",955,"KRN",9.8,"NM",15,0)
HLTPCK2^^0^B40614402
"BLD",955,"KRN",9.8,"NM",16,0)
HLTPCK2A^^0^B28058257
"BLD",955,"KRN",9.8,"NM",17,0)
HLOPRS^^0^B30775930
"BLD",955,"KRN",9.8,"NM",18,0)
HLOPRS1^^0^B19727557
"BLD",955,"KRN",9.8,"NM",19,0)
HLOAPI3^^0^B43853464
"BLD",955,"KRN",9.8,"NM",20,0)
HLTPCK2B^^0^B64470063
"BLD",955,"KRN",9.8,"NM",21,0)
HLOCLNT2^^0^B29898713
"BLD",955,"KRN",9.8,"NM",22,0)
HLOSRVR1^^0^B60360938
"BLD",955,"KRN",9.8,"NM","B","HLCSHDR1",3)

"BLD",955,"KRN",9.8,"NM","B","HLCSTCP",10)

"BLD",955,"KRN",9.8,"NM","B","HLCSTCP1",11)

"BLD",955,"KRN",9.8,"NM","B","HLCSTCP2",12)

"BLD",955,"KRN",9.8,"NM","B","HLCSTCP3",4)

"BLD",955,"KRN",9.8,"NM","B","HLMA",1)

"BLD",955,"KRN",9.8,"NM","B","HLMA1",2)

"BLD",955,"KRN",9.8,"NM","B","HLOAPI",8)

"BLD",955,"KRN",9.8,"NM","B","HLOAPI2",9)

"BLD",955,"KRN",9.8,"NM","B","HLOAPI3",19)

"BLD",955,"KRN",9.8,"NM","B","HLOCLNT2",21)

"BLD",955,"KRN",9.8,"NM","B","HLOPRS",17)

"BLD",955,"KRN",9.8,"NM","B","HLOPRS1",18)

"BLD",955,"KRN",9.8,"NM","B","HLOSRVR1",22)

"BLD",955,"KRN",9.8,"NM","B","HLTP",5)

"BLD",955,"KRN",9.8,"NM","B","HLTP1",6)

"BLD",955,"KRN",9.8,"NM","B","HLTP3",7)

"BLD",955,"KRN",9.8,"NM","B","HLTPCK1",14)

"BLD",955,"KRN",9.8,"NM","B","HLTPCK2",15)

"BLD",955,"KRN",9.8,"NM","B","HLTPCK2A",16)

"BLD",955,"KRN",9.8,"NM","B","HLTPCK2B",20)

"BLD",955,"KRN",19,0)
19
"BLD",955,"KRN",19,"NM",0)
^9.68A^^
"BLD",955,"KRN",19.1,0)
19.1
"BLD",955,"KRN",101,0)
101
"BLD",955,"KRN",409.61,0)
409.61
"BLD",955,"KRN",771,0)
771
"BLD",955,"KRN",870,0)
870
"BLD",955,"KRN",8989.51,0)
8989.51
"BLD",955,"KRN",8989.52,0)
8989.52
"BLD",955,"KRN",8994,0)
8994
"BLD",955,"KRN","B",.4,.4)

"BLD",955,"KRN","B",.401,.401)

"BLD",955,"KRN","B",.402,.402)

"BLD",955,"KRN","B",.403,.403)

"BLD",955,"KRN","B",.5,.5)

"BLD",955,"KRN","B",.84,.84)

"BLD",955,"KRN","B",3.6,3.6)

"BLD",955,"KRN","B",3.8,3.8)

"BLD",955,"KRN","B",9.2,9.2)

"BLD",955,"KRN","B",9.8,9.8)

"BLD",955,"KRN","B",19,19)

"BLD",955,"KRN","B",19.1,19.1)

"BLD",955,"KRN","B",101,101)

"BLD",955,"KRN","B",409.61,409.61)

"BLD",955,"KRN","B",771,771)

"BLD",955,"KRN","B",870,870)

"BLD",955,"KRN","B",8989.51,8989.51)

"BLD",955,"KRN","B",8989.52,8989.52)

"BLD",955,"KRN","B",8994,8994)

"BLD",955,"QUES",0)
^9.62^^
"BLD",955,"REQB",0)
^9.611^4^2
"BLD",955,"REQB",3,0)
HL*1.6*120^2
"BLD",955,"REQB",4,0)
HL*1.6*131^2
"BLD",955,"REQB","B","HL*1.6*120",3)

"BLD",955,"REQB","B","HL*1.6*131",4)

"FIA",870)
HL LOGICAL LINK
"FIA",870,0)
^HLCS(870,
"FIA",870,0,0)
870
"FIA",870,0,1)
y^n^p^^^^n^^n
"FIA",870,0,10)

"FIA",870,0,11)

"FIA",870,0,"RLRO")

"FIA",870,0,"VR")
1.6^HL
"FIA",870,870)
1
"FIA",870,870,200.022)

"MBREQ")
0
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
133^3060913
"PKG",9,22,1,"PAH",1,1,0)
^^2^2^3060913
"PKG",9,22,1,"PAH",1,1,1,0)
See the NPM for a complete description of this patch.
"PKG",9,22,1,"PAH",1,1,2,0)

"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
21
"RTN","HLCSHDR1")
0^3^B57541761^B53997699
"RTN","HLCSHDR1",1,0)
HLCSHDR1 ;SFIRMFO/RSD - Make HL7 header for TCP ;09/13/2006
"RTN","HLCSHDR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,57,59,72,80,93,120,133**;Oct 13, 1995;Build 13
"RTN","HLCSHDR1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSHDR1",4,0)
HEADER(IEN,CLIENT,HLERROR) ; Create an HL7 MSH segment
"RTN","HLCSHDR1",5,0)
 ;
"RTN","HLCSHDR1",6,0)
 ;Input  : IEN - Pointer to entry in Message Administration file (#773)
"RTN","HLCSHDR1",7,0)
 ;               that HL7 MSH segment is being built for
"RTN","HLCSHDR1",8,0)
 ;         CLIENT - IEN of the receiving application
"RTN","HLCSHDR1",9,0)
 ;         HLERROR - Variable to return possible error text in
"RTN","HLCSHDR1",10,0)
 ;                   (pass by reference - only used when needed)
"RTN","HLCSHDR1",11,0)
 ;
"RTN","HLCSHDR1",12,0)
 ;Output : HLHDR(1) - HL7 MSH segment
"RTN","HLCSHDR1",13,0)
 ;         HLHDR(2) - Continuation of HL7 MSH segment (if needed)
"RTN","HLCSHDR1",14,0)
 ;         HLHDR(3) - Continuation of HL7 MSH segment (if needed)
"RTN","HLCSHDR1",15,0)
 ;
"RTN","HLCSHDR1",16,0)
 ;Notes  : HLERROR will only be defined [on output] if an error occurs
"RTN","HLCSHDR1",17,0)
 ;       : HLHDR() will not be defined [on output] if an error occurs
"RTN","HLCSHDR1",18,0)
 ;       : HLHDR(2) & HLHDR(3) are continuation [or roll-over] nodes
"RTN","HLCSHDR1",19,0)
 ;         and will only be used/defined when needed
"RTN","HLCSHDR1",20,0)
 ;
"RTN","HLCSHDR1",21,0)
 N ACKTO,ACCACK,APPACK,CHILD,CLNTAPP,CLNTFAC,CNTRY,EC,EVNTYPE,FS,HLDATE,HLHDRI,HLHDRL,HLID,HLPID,MSGTYPE,PROT,PROTS,SECURITY,SEND,SERAPP,SERFAC,TXTP,TXTP0,X,MSGEVN
"RTN","HLCSHDR1",22,0)
 N COMFLAG ; patch HL*1.6*120
"RTN","HLCSHDR1",23,0)
 S HLERROR=""
"RTN","HLCSHDR1",24,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLCSHDR1",25,0)
 D VAR Q:$G(HLERROR)]""
"RTN","HLCSHDR1",26,0)
 ; The following line commented by HL*1.6*72
"RTN","HLCSHDR1",27,0)
 ;I $D(^HLMA(IEN)) S $P(^HLMA(IEN,0),U,13)=MSGTYPE,$P(^HLMA(IEN,0),U,14)=$G(EVNTYPE)
"RTN","HLCSHDR1",28,0)
 ;Append event type
"RTN","HLCSHDR1",29,0)
 I $G(EVNTYPE)]"" S MSGTYPE=MSGTYPE_$E(EC,1)_EVNTYPE
"RTN","HLCSHDR1",30,0)
 ;Append message structure component
"RTN","HLCSHDR1",31,0)
 I $G(EVNTYPE)]"",$G(MSGEVN)]"" S MSGTYPE=MSGTYPE_$E(EC,1)_MSGEVN
"RTN","HLCSHDR1",32,0)
 ;Build MSH array
"RTN","HLCSHDR1",33,0)
 D RESET^HLCSHDR3 ;HL*1.6*93
"RTN","HLCSHDR1",34,0)
 ;
"RTN","HLCSHDR1",35,0)
 ; patch HL*1.6*120 start
"RTN","HLCSHDR1",36,0)
 ; escape delimiters for SERAPP and CLNTAPP
"RTN","HLCSHDR1",37,0)
 ; escape component separator if the field is not consisted
"RTN","HLCSHDR1",38,0)
 ; of 3 components
"RTN","HLCSHDR1",39,0)
 S EC(1)=$E(EC,1)
"RTN","HLCSHDR1",40,0)
 S EC(2)=$E(EC,2)
"RTN","HLCSHDR1",41,0)
 S EC(3)=$E(EC,3)
"RTN","HLCSHDR1",42,0)
 S EC(4)=$E(EC,4)
"RTN","HLCSHDR1",43,0)
 S COMFLAG=1
"RTN","HLCSHDR1",44,0)
 I $L(SERAPP,$E(EC,1))=3 S COMFLAG=0
"RTN","HLCSHDR1",45,0)
 I (SERAPP[FS)!(SERAPP[EC(1))!(SERAPP[EC(2))!(SERAPP[EC(3))!(SERAPP[EC(4)) D
"RTN","HLCSHDR1",46,0)
 . S SERAPP=$$ESCAPE(SERAPP,COMFLAG)
"RTN","HLCSHDR1",47,0)
 S COMFLAG=1
"RTN","HLCSHDR1",48,0)
 I $L(CLNTAPP,$E(EC,1))=3 S COMFLAG=0
"RTN","HLCSHDR1",49,0)
 I (CLNTAPP[FS)!(CLNTAPP[EC(1))!(CLNTAPP[EC(2))!(CLNTAPP[EC(3))!(CLNTAPP[EC(4)) D
"RTN","HLCSHDR1",50,0)
 . S CLNTAPP=$$ESCAPE(CLNTAPP,COMFLAG)
"RTN","HLCSHDR1",51,0)
 ; patch HL*1.6*120 end
"RTN","HLCSHDR1",52,0)
 ;
"RTN","HLCSHDR1",53,0)
 S HLHDRI=1,HLHDR(1)="MSH"_FS_EC_FS_SERAPP,HLHDRL=$L(HLHDR(1))
"RTN","HLCSHDR1",54,0)
 F X=SERFAC,CLNTAPP,CLNTFAC,HLDATE,SECURITY,MSGTYPE,HLID,HLPID,$P(PROT,U,9),"",$G(^HL(772,TXTP,1)),ACCACK,APPACK,CNTRY D MSH(X)
"RTN","HLCSHDR1",55,0)
 ;in preceeding line, "" is for sequence number - not supported
"RTN","HLCSHDR1",56,0)
 Q
"RTN","HLCSHDR1",57,0)
 ;
"RTN","HLCSHDR1",58,0)
MSH(X) ;add X to HLHDR
"RTN","HLCSHDR1",59,0)
 S:HLHDRL+$L(X)>245 HLHDRI=HLHDRI+1,HLHDR(HLHDRI)=""
"RTN","HLCSHDR1",60,0)
 S HLHDR(HLHDRI)=HLHDR(HLHDRI)_FS_X,HLHDRL=$L(HLHDR(HLHDRI))
"RTN","HLCSHDR1",61,0)
 Q
"RTN","HLCSHDR1",62,0)
BHSHDR(IEN,CLIENT,HLERROR) ; Create Batch Header Segment
"RTN","HLCSHDR1",63,0)
 ; The BHS has 12 segments, of which 4 are blank.
"RTN","HLCSHDR1",64,0)
 ; INPUT: IEN - IEN of entry in file #772
"RTN","HLCSHDR1",65,0)
 ; OUTPUT: HLHDR(1) and HLHDR(2) - the two lines with the 12 segs.
"RTN","HLCSHDR1",66,0)
 ;   ready for adding to a message directly.
"RTN","HLCSHDR1",67,0)
 N ACKTO,ACCACK,ACKMID,APPACK,BNAME,BSTATUS,BTACK,CHILD,CLNTAPP ;HL*1.6*80
"RTN","HLCSHDR1",68,0)
 N CLNTFAC,CNTRY,EC,EVNTYPE,FS,HLDATE,HLHDRI,HLHDRL,HLID,HLPID ;HL*1.6*80 - added HLPID
"RTN","HLCSHDR1",69,0)
 N PROT,PROTS,SECURITY,SEND,SERAPP,SERFAC,TXTP,TXTP0,X ;HL*1.6*80
"RTN","HLCSHDR1",70,0)
 N COMFLAG ; patch HL*1.6*120
"RTN","HLCSHDR1",71,0)
 S HLERROR=""
"RTN","HLCSHDR1",72,0)
 ;
"RTN","HLCSHDR1",73,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLCSHDR1",74,0)
 D VAR Q:$G(HLERROR)]""
"RTN","HLCSHDR1",75,0)
 ; The following line commented by HL*1.6*72
"RTN","HLCSHDR1",76,0)
 ;I $D(^HLMA(IEN)) S $P(^HLMA(IEN,0),U,13)=MSGTYPE,$P(^HLMA(IEN,0),U,14)=$G(EVNTYPE)
"RTN","HLCSHDR1",77,0)
 ;
"RTN","HLCSHDR1",78,0)
 ;Append event type
"RTN","HLCSHDR1",79,0)
 I $G(EVNTYPE)]"" S MSGTYPE=MSGTYPE_$E(EC,2)_EVNTYPE,(ACKMID,BTACK)=""
"RTN","HLCSHDR1",80,0)
 ;batch/name/id/type(#9)=null~process ID~msg type|evnt type~version~CA~AA
"RTN","HLCSHDR1",81,0)
 S BNAME=$E(EC,1)_HLPID_$E(EC,1)_MSGTYPE_$E(EC,1)_$P(PROT,U,9)_$E(EC,1)_ACCACK_$E(EC,1)_APPACK ;HL*1.6*80
"RTN","HLCSHDR1",82,0)
 ;for batch ACK
"RTN","HLCSHDR1",83,0)
 I ACKTO D  S BTACK=X_$E(EC,1)_$P(BSTATUS,U,3)
"RTN","HLCSHDR1",84,0)
 . ;get msg id and status of message that is being ACKed
"RTN","HLCSHDR1",85,0)
 . S ACKMID=$P($G(^HLMA(ACKTO,0)),U,2),BSTATUS=$G(^HLMA(ACKTO,"P")) ;HL*1.6*80
"RTN","HLCSHDR1",86,0)
 . ;set type of ACK based on status
"RTN","HLCSHDR1",87,0)
 . S X=$S(ACKMID="":"AR",(BSTATUS>3)&(BSTATUS<8):"AE",1:"AA")
"RTN","HLCSHDR1",88,0)
 ;
"RTN","HLCSHDR1",89,0)
 D RESET^HLCSHDR3 ;HL*1.6*93
"RTN","HLCSHDR1",90,0)
 ;
"RTN","HLCSHDR1",91,0)
 ; patch HL*1.6*120 start
"RTN","HLCSHDR1",92,0)
 ; escape delimiters for SERAPP and CLNTAPP
"RTN","HLCSHDR1",93,0)
 ; escape component separator if the field is not consisted
"RTN","HLCSHDR1",94,0)
 ; of 3 components
"RTN","HLCSHDR1",95,0)
 S EC(1)=$E(EC,1)
"RTN","HLCSHDR1",96,0)
 S EC(2)=$E(EC,2)
"RTN","HLCSHDR1",97,0)
 S EC(3)=$E(EC,3)
"RTN","HLCSHDR1",98,0)
 S EC(4)=$E(EC,4)
"RTN","HLCSHDR1",99,0)
 S COMFLAG=1
"RTN","HLCSHDR1",100,0)
 I $L(SERAPP,$E(EC,1))=3 S COMFLAG=0
"RTN","HLCSHDR1",101,0)
 I (SERAPP[FS)!(SERAPP[EC(1))!(SERAPP[EC(2))!(SERAPP[EC(3))!(SERAPP[EC(4)) D
"RTN","HLCSHDR1",102,0)
 . S SERAPP=$$ESCAPE(SERAPP,COMFLAG)
"RTN","HLCSHDR1",103,0)
 S COMFLAG=1
"RTN","HLCSHDR1",104,0)
 I $L(CLNTAPP,$E(EC,1))=3 S COMFLAG=0
"RTN","HLCSHDR1",105,0)
 I (CLNTAPP[FS)!(CLNTAPP[EC(1))!(CLNTAPP[EC(2))!(CLNTAPP[EC(3))!(CLNTAPP[EC(4)) D
"RTN","HLCSHDR1",106,0)
 . S CLNTAPP=$$ESCAPE(CLNTAPP,COMFLAG)
"RTN","HLCSHDR1",107,0)
 ; patch HL*1.6*120 end
"RTN","HLCSHDR1",108,0)
 ;
"RTN","HLCSHDR1",109,0)
 S HLHDRI=1,HLHDR(1)="BHS"_FS_EC_FS_SERAPP,HLHDRL=$L(HLHDR(1))
"RTN","HLCSHDR1",110,0)
 F X=SERFAC,CLNTAPP,CLNTFAC,HLDATE,SECURITY,BNAME,BTACK,HLID,ACKMID D MSH(X)
"RTN","HLCSHDR1",111,0)
 Q
"RTN","HLCSHDR1",112,0)
VAR ;Check input
"RTN","HLCSHDR1",113,0)
 N APPPRM,HLPROTS,HLPROT
"RTN","HLCSHDR1",114,0)
 S IEN=+$G(IEN)
"RTN","HLCSHDR1",115,0)
 I '$G(^HLMA(IEN,0)) S HLERROR="Valid pointer to Message Administration file (#772) not passed" Q
"RTN","HLCSHDR1",116,0)
 I '$G(CLIENT) S HLERROR="Could not determine receiving application" Q
"RTN","HLCSHDR1",117,0)
 ;Get child, text pointer,text entry, and sending app.
"RTN","HLCSHDR1",118,0)
 S CHILD=$G(^HLMA(IEN,0)),SEND=+$P($G(^(0)),U,11),TXTP=+CHILD,TXTP0=$G(^HL(772,TXTP,0))
"RTN","HLCSHDR1",119,0)
 I ('SEND) S HLERROR="Could not determine sending application" Q
"RTN","HLCSHDR1",120,0)
 ;Get info for sending & receiving applications
"RTN","HLCSHDR1",121,0)
 D APPPRM^HLUTIL2(CLIENT),APPPRM^HLUTIL2(SEND)
"RTN","HLCSHDR1",122,0)
 ;Get name of sending application, facility, and country
"RTN","HLCSHDR1",123,0)
 S SERAPP=$P(APPPRM(SEND,0),U),SERFAC=$P(APPPRM(SEND,0),U,2),CNTRY=$P(APPPRM(SEND,0),U,3)
"RTN","HLCSHDR1",124,0)
 ;Get name of receiving application and facility
"RTN","HLCSHDR1",125,0)
 S CLNTAPP=$P(APPPRM(CLIENT,0),U),CLNTFAC=$P(APPPRM(CLIENT,0),U,2)
"RTN","HLCSHDR1",126,0)
 ;
"RTN","HLCSHDR1",127,0)
 ; patch HL*1.6*120
"RTN","HLCSHDR1",128,0)
 ; for dynamic addressing, overide the receiving facility from the
"RTN","HLCSHDR1",129,0)
 ; 3rd component of HLL("LINKS") array
"RTN","HLCSHDR1",130,0)
 I $G(HLP("REC-FACILITY"))]"" S CLNTFAC=HLP("REC-FACILITY")
"RTN","HLCSHDR1",131,0)
 ;
"RTN","HLCSHDR1",132,0)
 ;Get field separator & encoding characters
"RTN","HLCSHDR1",133,0)
 S FS=APPPRM(SEND,"FS"),EC=APPPRM(SEND,"EC")
"RTN","HLCSHDR1",134,0)
 S:(EC="") EC="~|\&" S:(FS="") FS="^"
"RTN","HLCSHDR1",135,0)
 ;Determine if it's a response/ACK to another message
"RTN","HLCSHDR1",136,0)
 S ACKTO=+$P(CHILD,U,10)
"RTN","HLCSHDR1",137,0)
 ;subscriber protocol is from child (file 773)
"RTN","HLCSHDR1",138,0)
 ;If response, get MType from subscriber
"RTN","HLCSHDR1",139,0)
 S HLPROTS=+$P(CHILD,U,8)
"RTN","HLCSHDR1",140,0)
 S PROTS=$$TYPE^HLUTIL2(HLPROTS)
"RTN","HLCSHDR1",141,0)
 I ACKTO S MSGTYPE=$P(PROTS,U,10),EVNTYPE=$P(PROTS,U,3),MSGEVN=$P(PROTS,U,4)
"RTN","HLCSHDR1",142,0)
 ;Get accept ack & application ack type (based on server protocol) it
"RTN","HLCSHDR1",143,0)
 ; is always in file 772, TXPT0
"RTN","HLCSHDR1",144,0)
 ;If original message, get MT from Event Driver Protocol
"RTN","HLCSHDR1",145,0)
 S HLPROT=+$P(TXTP0,U,10)
"RTN","HLCSHDR1",146,0)
 S PROT=$$TYPE^HLUTIL2(HLPROT)
"RTN","HLCSHDR1",147,0)
 S:'ACKTO MSGTYPE=$P(PROT,U,2),EVNTYPE=$P(PROT,U,3),MSGEVN=$P(PROT,U,4)
"RTN","HLCSHDR1",148,0)
 S ACCACK=$P(PROT,U,7),APPACK=$P(PROT,U,8)
"RTN","HLCSHDR1",149,0)
PID ;Processing ID
"RTN","HLCSHDR1",150,0)
 ;I PID not 'debug' get from site params
"RTN","HLCSHDR1",151,0)
 ;If event driver set to 'debug' get from protocol
"RTN","HLCSHDR1",152,0)
 ;'production' or 'training' comes from site params
"RTN","HLCSHDR1",153,0)
 S HLPID=$P(PROT,U,5)
"RTN","HLCSHDR1",154,0)
 I $G(HLPID)'="D" S HLPID=$P(HLPARAM,U,3)
"RTN","HLCSHDR1",155,0)
 ;
"RTN","HLCSHDR1",156,0)
 ; patch HL*1.6*120: to include processing mode
"RTN","HLCSHDR1",157,0)
 I $G(HLP("PMOD"))]"",($G(HLTYPE)="M") D
"RTN","HLCSHDR1",158,0)
 . S HLPID=HLPID_$E($G(EC),1)_HLP("PMOD")
"RTN","HLCSHDR1",159,0)
 ;
"RTN","HLCSHDR1",160,0)
 I $G(HLPID)="" S HLERROR="Missing processing ID Site parameter."
"RTN","HLCSHDR1",161,0)
 ;acknowledgements have no application ack, link open no commit ack
"RTN","HLCSHDR1",162,0)
 I ACKTO S:APPACK]"" APPACK="NE" S:ACCACK]""&$G(HLTCPO) ACCACK="NE"
"RTN","HLCSHDR1",163,0)
 ;Get date/time, Message ID, and security
"RTN","HLCSHDR1",164,0)
 S HLDATE=+TXTP0,HLDATE=$$FMTHL7^XLFDT(HLDATE),HLID=$P(CHILD,U,2),SECURITY=$P(CHILD,U,9)
"RTN","HLCSHDR1",165,0)
HDR23 ;generate extended facility field info based on 'facility required'
"RTN","HLCSHDR1",166,0)
 ;default format is INSTITUTION_HLCS_DOMAIN_HLCS_'DNS'
"RTN","HLCSHDR1",167,0)
 ;application parameter entry overrides default
"RTN","HLCSHDR1",168,0)
 N HLEP773,HLS773
"RTN","HLCSHDR1",169,0)
 S SERFAC=$G(SERFAC),CLNTFAC=$G(CLNTFAC)
"RTN","HLCSHDR1",170,0)
 S HLEP773=+$G(^ORD(101,HLPROTS,773))
"RTN","HLCSHDR1",171,0)
 S HLS773=+$P($G(^ORD(101,HLPROTS,773)),U,2)
"RTN","HLCSHDR1",172,0)
 Q:'HLEP773&('HLS773)
"RTN","HLCSHDR1",173,0)
 D GEN^HLCSHDR2
"RTN","HLCSHDR1",174,0)
 I ACKTO D  Q
"RTN","HLCSHDR1",175,0)
 .;Find original message
"RTN","HLCSHDR1",176,0)
 .S X=$G(^HLMA(ACKTO,"MSH",1,0)) ;Find header in TCP nodes
"RTN","HLCSHDR1",177,0)
 .I X["MSH" D
"RTN","HLCSHDR1",178,0)
 ..;
"RTN","HLCSHDR1",179,0)
 ..; patch HL*1.6*120 start
"RTN","HLCSHDR1",180,0)
 .. N HLEC
"RTN","HLCSHDR1",181,0)
 ..S HLFS=$E(X,4),HLEC=$E(X,5)
"RTN","HLCSHDR1",182,0)
 ..S SENDFAC=$P(X,HLFS,4),RECFAC=$P(X,HLFS,6) ;from original msg
"RTN","HLCSHDR1",183,0)
 ..S CLNTFAC=SENDFAC,SERFAC=RECFAC ;reverse facility info
"RTN","HLCSHDR1",184,0)
 ..S EC("COMPONENT")=$E($G(EC),1)
"RTN","HLCSHDR1",185,0)
 ..I $L(EC("COMPONENT"))=1,$L(HLEC)=1,EC("COMPONENT")'=HLEC D
"RTN","HLCSHDR1",186,0)
 ... ; change the the component separator in the sending and
"RTN","HLCSHDR1",187,0)
 ... ; receiving facilities for the outgoing message
"RTN","HLCSHDR1",188,0)
 ... S CLNTFAC=$TR(CLNTFAC,HLEC,EC("COMPONENT"))
"RTN","HLCSHDR1",189,0)
 ... S SERFAC=$TR(SERFAC,HLEC,EC("COMPONENT"))
"RTN","HLCSHDR1",190,0)
 ; patch HL*1.6*120 end
"RTN","HLCSHDR1",191,0)
 ;
"RTN","HLCSHDR1",192,0)
 I HLEP773,SERFAC="" D EP^HLCSHDR2
"RTN","HLCSHDR1",193,0)
 I HLS773,CLNTFAC="" D S^HLCSHDR2
"RTN","HLCSHDR1",194,0)
 Q
"RTN","HLCSHDR1",195,0)
 ;
"RTN","HLCSHDR1",196,0)
ESCAPE(INPUT,COMPONET) ;
"RTN","HLCSHDR1",197,0)
 ; patch HL*1.6*120 - escape delimiters:
"RTN","HLCSHDR1",198,0)
 ; - field separator
"RTN","HLCSHDR1",199,0)
 ; - component separator
"RTN","HLCSHDR1",200,0)
 ; - repetition separator
"RTN","HLCSHDR1",201,0)
 ; - escape character
"RTN","HLCSHDR1",202,0)
 ; - subcomponent separator
"RTN","HLCSHDR1",203,0)
 ;
"RTN","HLCSHDR1",204,0)
 ; input: 
"RTN","HLCSHDR1",205,0)
 ;     INPUT - string data to be escaped
"RTN","HLCSHDR1",206,0)
 ;  COMPONET - if 1, escape component separator
"RTN","HLCSHDR1",207,0)
 ;             if 0, do not escape component separator
"RTN","HLCSHDR1",208,0)
 ;        FS - field separator character
"RTN","HLCSHDR1",209,0)
 ;        EC - encoding characters 
"RTN","HLCSHDR1",210,0)
 ; result: return the escaped string
"RTN","HLCSHDR1",211,0)
 ;
"RTN","HLCSHDR1",212,0)
 N HLDATA,HLESCAPE,HLI,HLCHAR,HLEN,HLOUT,COMFLAG
"RTN","HLCSHDR1",213,0)
 S HLDATA=$G(INPUT)
"RTN","HLCSHDR1",214,0)
 S COMFLAG=$G(COMPONET)
"RTN","HLCSHDR1",215,0)
 Q:$L($G(FS))'=1 HLDATA
"RTN","HLCSHDR1",216,0)
 ;
"RTN","HLCSHDR1",217,0)
 ; patch HL*1.6*133
"RTN","HLCSHDR1",218,0)
 ; Q:$L($G(EC))'=4 HLDATA
"RTN","HLCSHDR1",219,0)
 Q:($L($G(EC))<3) HLDATA
"RTN","HLCSHDR1",220,0)
 Q:HLDATA']"" HLDATA
"RTN","HLCSHDR1",221,0)
 ;
"RTN","HLCSHDR1",222,0)
 S HLESCAPE=FS_EC
"RTN","HLCSHDR1",223,0)
 S HLESCAPE("F")=FS
"RTN","HLCSHDR1",224,0)
 S HLESCAPE("S")=$E(EC,1)
"RTN","HLCSHDR1",225,0)
 S HLESCAPE("R")=$E(EC,2)
"RTN","HLCSHDR1",226,0)
 S HLESCAPE("E")=$E(EC,3)
"RTN","HLCSHDR1",227,0)
 S HLESCAPE("T")=$E(EC,4)
"RTN","HLCSHDR1",228,0)
 S HLEN=$L(HLDATA)
"RTN","HLCSHDR1",229,0)
 S HLOUT=""
"RTN","HLCSHDR1",230,0)
 F HLI=1:1:HLEN D
"RTN","HLCSHDR1",231,0)
 . S HLCHAR=$E(HLDATA,HLI)
"RTN","HLCSHDR1",232,0)
 . I HLESCAPE[HLCHAR D  Q
"RTN","HLCSHDR1",233,0)
 .. I HLCHAR=HLESCAPE("F") S HLOUT=HLOUT_HLESCAPE("E")_"F"_HLESCAPE("E") Q
"RTN","HLCSHDR1",234,0)
 .. I HLCHAR=HLESCAPE("S") D  Q
"RTN","HLCSHDR1",235,0)
 ... I COMFLAG=1 S HLOUT=HLOUT_HLESCAPE("E")_"S"_HLESCAPE("E") Q
"RTN","HLCSHDR1",236,0)
 ... S HLOUT=HLOUT_HLCHAR
"RTN","HLCSHDR1",237,0)
 .. I HLCHAR=HLESCAPE("R") S HLOUT=HLOUT_HLESCAPE("E")_"R"_HLESCAPE("E") Q
"RTN","HLCSHDR1",238,0)
 .. I HLCHAR=HLESCAPE("E") S HLOUT=HLOUT_HLESCAPE("E")_"E"_HLESCAPE("E") Q
"RTN","HLCSHDR1",239,0)
 .. I HLCHAR=HLESCAPE("T") S HLOUT=HLOUT_HLESCAPE("E")_"T"_HLESCAPE("E") Q
"RTN","HLCSHDR1",240,0)
 . ;
"RTN","HLCSHDR1",241,0)
 . S HLOUT=HLOUT_HLCHAR
"RTN","HLCSHDR1",242,0)
 Q HLOUT
"RTN","HLCSTCP")
0^10^B33765852^B32053075
"RTN","HLCSTCP",1,0)
HLCSTCP ;SFIRMFO/TNV-ALB/JFP,PKE - (TCP/IP) MLLP ;09/13/2006
"RTN","HLCSTCP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,49,57,58,64,84,109,133**;Oct 13, 1995;Build 13
"RTN","HLCSTCP",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP",4,0)
 ; 
"RTN","HLCSTCP",5,0)
 ; This is an implementation of the HL7 Minimal Lower Layer Protocol
"RTN","HLCSTCP",6,0)
 ;
"RTN","HLCSTCP",7,0)
 ;taskman entry/startup option, HLDP defined in menu entry,
"RTN","HLCSTCP",8,0)
 Q:'$D(HLDP)
"RTN","HLCSTCP",9,0)
 N HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL
"RTN","HLCSTCP",10,0)
 ;HLCSOUT= 1-error
"RTN","HLCSTCP",11,0)
 I '$$INIT D EXITS("Init Error") Q
"RTN","HLCSTCP",12,0)
 ; Start the client
"RTN","HLCSTCP",13,0)
 I $G(HLTCPCS)="C" D  Q
"RTN","HLCSTCP",14,0)
 . ; identify process for ^%SY
"RTN","HLCSTCP",15,0)
 . D SETNM^%ZOSV($E("HLClnt:"_HLDP,1,15))
"RTN","HLCSTCP",16,0)
 . D ST1
"RTN","HLCSTCP",17,0)
 . F  D ^HLCSTCP2 Q:$$STOP!$G(HLCSOUT)
"RTN","HLCSTCP",18,0)
 . I $G(HLCSOUT)=1 D MON("Error") H 1 Q
"RTN","HLCSTCP",19,0)
 . I $G(HLCSOUT)=2 D EXITS("Inactive") Q
"RTN","HLCSTCP",20,0)
 . D EXITS("Shutdown")
"RTN","HLCSTCP",21,0)
 ;
"RTN","HLCSTCP",22,0)
 ; identify process for ^%SY
"RTN","HLCSTCP",23,0)
 D SETNM^%ZOSV($E("HLSrv:"_HLDP,1,15))
"RTN","HLCSTCP",24,0)
 ;HLCSFAIL=1 port failed to open
"RTN","HLCSTCP",25,0)
 S HLCSFAIL=1
"RTN","HLCSTCP",26,0)
 ;single threaded listener
"RTN","HLCSTCP",27,0)
 I $G(HLTCPCS)="S" D  Q
"RTN","HLCSTCP",28,0)
 . D ST1,MON("Listen"),LISTEN^%ZISTCP(HLTCPORT,"SERVER^HLCSTCP("""_HLDP_""")")
"RTN","HLCSTCP",29,0)
 . ;couldn't open listener port
"RTN","HLCSTCP",30,0)
 . I HLCSFAIL D EXITS("Openfail") Q
"RTN","HLCSTCP",31,0)
 ;
"RTN","HLCSTCP",32,0)
 ;multi-threaded listener (OpenM)
"RTN","HLCSTCP",33,0)
 I $G(HLTCPCS)="M",^%ZOSF("OS")["OpenM" D  Q
"RTN","HLCSTCP",34,0)
 . D ST1,MON("Listen"),LISTEN^%ZISTCPS(HLTCPORT,"SERVERS^HLCSTCP("""_HLDP_""")")
"RTN","HLCSTCP",35,0)
 Q
"RTN","HLCSTCP",36,0)
 ;
"RTN","HLCSTCP",37,0)
SERVER(HLDP) ; single server using Taskman
"RTN","HLCSTCP",38,0)
 S HLCSFAIL=0
"RTN","HLCSTCP",39,0)
 I '$$INIT D EXITS("Init error") Q
"RTN","HLCSTCP",40,0)
 D ^HLCSTCP1
"RTN","HLCSTCP",41,0)
 I $$STOP D CLOSE^%ZISTCP,EXITS("Shutdown") S IO("C")="" Q
"RTN","HLCSTCP",42,0)
 Q:$G(HLCSOUT)=1
"RTN","HLCSTCP",43,0)
 D MON("Idle")
"RTN","HLCSTCP",44,0)
 Q
"RTN","HLCSTCP",45,0)
 ;
"RTN","HLCSTCP",46,0)
SERVERS(HLDP) ; Multi-threaded server using Taskman
"RTN","HLCSTCP",47,0)
 I '$$INIT D EXITS("Init error") Q
"RTN","HLCSTCP",48,0)
 G LISTEN
"RTN","HLCSTCP",49,0)
 ;
"RTN","HLCSTCP",50,0)
 ;multiple process servers, called from an external utility
"RTN","HLCSTCP",51,0)
MSM ;MSM entry point, called from User-Defined Services
"RTN","HLCSTCP",52,0)
 ;HLDP=ien in the HL LOWER LEVEL PROTOCOL PARAMETER file for the
"RTN","HLCSTCP",53,0)
 ;HL7 Multi-Threaded SERVER
"RTN","HLCSTCP",54,0)
 S (IO,IO(0))=$P
"RTN","HLCSTCP",55,0)
 G LISTEN
"RTN","HLCSTCP",56,0)
 ;
"RTN","HLCSTCP",57,0)
CACHEVMS(%) ;Cache'/VMS tcpip/ucx entry point, called from HLSEVEN.COM file,
"RTN","HLCSTCP",58,0)
 ;listener,  % = HLDP
"RTN","HLCSTCP",59,0)
 I $G(%)="" D ^%ZTER Q
"RTN","HLCSTCP",60,0)
 S IO="SYS$NET",HLDP=%
"RTN","HLCSTCP",61,0)
 S IO(0)="_NLA0:" O IO(0) ;Setup null device
"RTN","HLCSTCP",62,0)
 ; **Cache'/VMS specific code**
"RTN","HLCSTCP",63,0)
 O IO::5 E  D MON("Openfail") Q
"RTN","HLCSTCP",64,0)
 X "U IO:(::""-M"")" ;Packet mode like DSM
"RTN","HLCSTCP",65,0)
 D LISTEN C IO Q
"RTN","HLCSTCP",66,0)
 ;
"RTN","HLCSTCP",67,0)
EN ;vms ucx entry point, called from HLSEVEN.COM file,
"RTN","HLCSTCP",68,0)
 ;listener,  % = device^HLDP
"RTN","HLCSTCP",69,0)
 I $G(%)="" D ^%ZTER Q
"RTN","HLCSTCP",70,0)
 S IO="SYS$NET",U="^",HLDP=$P(%,U,2)
"RTN","HLCSTCP",71,0)
 S IO(0)="_NLA0:" O IO(0) ;Setup null device
"RTN","HLCSTCP",72,0)
 ; **VMS specific code, need to share device**
"RTN","HLCSTCP",73,0)
 O IO:(TCPDEV):60 E  D MON("Openfail") Q
"RTN","HLCSTCP",74,0)
LISTEN ;
"RTN","HLCSTCP",75,0)
 N HLLSTN,HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL
"RTN","HLCSTCP",76,0)
 I '$$INIT D ^%ZTER Q
"RTN","HLCSTCP",77,0)
 ; identify process for ^%SY
"RTN","HLCSTCP",78,0)
 D SETNM^%ZOSV($E("HLSrv:"_HLDP,1,15))
"RTN","HLCSTCP",79,0)
 ;HLLSTN used to identify a listener to tag MON
"RTN","HLCSTCP",80,0)
 S HLLSTN=1
"RTN","HLCSTCP",81,0)
 ;increment job count, run server
"RTN","HLCSTCP",82,0)
 D UPDT(1),^HLCSTCP1,EXITM
"RTN","HLCSTCP",83,0)
 Q
"RTN","HLCSTCP",84,0)
 ;
"RTN","HLCSTCP",85,0)
DCOPEN(HLDP) ;open direct connect - called from HLMA2
"RTN","HLCSTCP",86,0)
 Q:'$$INIT 0
"RTN","HLCSTCP",87,0)
 Q:HLTCPADD=""!(HLTCPORT="") 0
"RTN","HLCSTCP",88,0)
 Q:'$$OPEN^HLCSTCP2 0
"RTN","HLCSTCP",89,0)
 Q 1
"RTN","HLCSTCP",90,0)
 ;
"RTN","HLCSTCP",91,0)
INIT() ; Initialize Variables
"RTN","HLCSTCP",92,0)
 ; HLDP should be set to the IEN or name of Logical Link, file 870
"RTN","HLCSTCP",93,0)
 S HLOS=$P($G(^%ZOSF("OS")),"^")
"RTN","HLCSTCP",94,0)
 N DA,DIQUIET,DR,TMP,X,Y
"RTN","HLCSTCP",95,0)
 S DIQUIET=1
"RTN","HLCSTCP",96,0)
 D DT^DICRW
"RTN","HLCSTCP",97,0)
 I 'HLDP S HLDP=$O(^HLCS(870,"B",HLDP,0)) I 'HLDP Q 0
"RTN","HLCSTCP",98,0)
 S DA=HLDP
"RTN","HLCSTCP",99,0)
 S DR="200.02;200.021;200.022;200.03;200.04;200.05;200.09;400.01;400.02;400.03;400.04;400.05"
"RTN","HLCSTCP",100,0)
 D GETS^DIQ(870,DA,DR,"IN","TMP","TMP")
"RTN","HLCSTCP",101,0)
 ;
"RTN","HLCSTCP",102,0)
 I $D(TMP("DIERR")) QUIT 0
"RTN","HLCSTCP",103,0)
 ; -- re-transmit attempts
"RTN","HLCSTCP",104,0)
 S HLDRETR=+$G(TMP(870,DA_",",200.02,"I"))
"RTN","HLCSTCP",105,0)
 S HLDRETR("CLOSE")=+$G(TMP(870,DA_",",200.022,"I"))
"RTN","HLCSTCP",106,0)
 ; -- exceed re-transmit action
"RTN","HLCSTCP",107,0)
 S HLRETRA=$G(TMP(870,DA_",",200.021,"I"))
"RTN","HLCSTCP",108,0)
 ; -- block size
"RTN","HLCSTCP",109,0)
 S HLDBSIZE=+$G(TMP(870,DA_",",200.03,"I"))
"RTN","HLCSTCP",110,0)
 ; -- read timeout
"RTN","HLCSTCP",111,0)
 S HLDREAD=+$G(TMP(870,DA_",",200.04,"I"))
"RTN","HLCSTCP",112,0)
 ; -- ack timeout
"RTN","HLCSTCP",113,0)
 S HLDBACK=+$G(TMP(870,DA_",",200.05,"I"))
"RTN","HLCSTCP",114,0)
 ; -- uni-directional wait
"RTN","HLCSTCP",115,0)
 S HLDWAIT=$G(TMP(870,DA_",",200.09,"I"))
"RTN","HLCSTCP",116,0)
 ; -- tcp address
"RTN","HLCSTCP",117,0)
 S HLTCPADD=$G(TMP(870,DA_",",400.01,"I"))
"RTN","HLCSTCP",118,0)
 ; -- tcp port
"RTN","HLCSTCP",119,0)
 S HLTCPORT=$G(TMP(870,DA_",",400.02,"I"))
"RTN","HLCSTCP",120,0)
 ; -- tcp/ip service type
"RTN","HLCSTCP",121,0)
 S HLTCPCS=$G(TMP(870,DA_",",400.03,"I"))
"RTN","HLCSTCP",122,0)
 ; -- link persistence
"RTN","HLCSTCP",123,0)
 S HLTCPLNK=$G(TMP(870,DA_",",400.04,"I"))
"RTN","HLCSTCP",124,0)
 ; -- retention
"RTN","HLCSTCP",125,0)
 S HLTCPRET=$G(TMP(870,DA_",",400.05,"I"))
"RTN","HLCSTCP",126,0)
 ;
"RTN","HLCSTCP",127,0)
 ; -- set defaults in case something's not set
"RTN","HLCSTCP",128,0)
 S:HLDREAD=0 HLDREAD=10
"RTN","HLCSTCP",129,0)
 S:HLDBACK=0 HLDBACK=60
"RTN","HLCSTCP",130,0)
 S:HLDBSIZE=0 HLDBSIZE=245
"RTN","HLCSTCP",131,0)
 S:HLDRETR=0 HLDRETR=5
"RTN","HLCSTCP",132,0)
 S:HLTCPRET="" X=$P($$PARAM^HLCS2,U,12),HLTCPRET=$S(X:X,1:15)
"RTN","HLCSTCP",133,0)
 ;
"RTN","HLCSTCP",134,0)
 Q 1
"RTN","HLCSTCP",135,0)
 ;
"RTN","HLCSTCP",136,0)
ST1 ;record startup in 870 for single server
"RTN","HLCSTCP",137,0)
 ;4=status 9=Time Started, 10=Time Stopped, 11=Task Number 
"RTN","HLCSTCP",138,0)
 ;14=Shutdown LLP, 3=LLP Online, 18=Gross Errors
"RTN","HLCSTCP",139,0)
 N HLJ,X
"RTN","HLCSTCP",140,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",141,0)
 S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCSTCP",142,0)
 S @X@(4)="Init",(@X@(10),@X@(18))="@",@X@(14)=0
"RTN","HLCSTCP",143,0)
 I HLTCPCS["C" S @X@(3)=$S(HLTCPLNK["Y":"PC",1:"NC")
"RTN","HLCSTCP",144,0)
 E  S @X@(3)=$S(HLTCPCS["S":"SS",HLTCPCS["M":"MS",1:"")
"RTN","HLCSTCP",145,0)
 I @X@(3)'="NC" S @X@(9)=$$NOW^XLFDT
"RTN","HLCSTCP",146,0)
 S:$G(ZTSK) @X@(11)=ZTSK
"RTN","HLCSTCP",147,0)
 D FILE^HLDIE("","HLJ","","ST1","HLCSTCP") ;HL*1.6*109
"RTN","HLCSTCP",148,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",149,0)
 Q
"RTN","HLCSTCP",150,0)
 ;
"RTN","HLCSTCP",151,0)
MON(Y) ;Display current state & check for shutdown
"RTN","HLCSTCP",152,0)
 ;don't display for multiple server
"RTN","HLCSTCP",153,0)
 Q:$G(HLLSTN)
"RTN","HLCSTCP",154,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",155,0)
 S $P(^HLCS(870,HLDP,0),U,5)=Y
"RTN","HLCSTCP",156,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",157,0)
 Q:'$D(HLTRACE)
"RTN","HLCSTCP",158,0)
 N X U IO(0)
"RTN","HLCSTCP",159,0)
 W !,"IN State: ",Y
"RTN","HLCSTCP",160,0)
 I '$$STOP D
"RTN","HLCSTCP",161,0)
 . R !,"Type Q to Quit: ",X#1:1
"RTN","HLCSTCP",162,0)
 . I $L(X),"Qq"[X S $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP",163,0)
 U IO
"RTN","HLCSTCP",164,0)
 Q
"RTN","HLCSTCP",165,0)
UPDT(Y) ;update job count for multiple servers,X=1 increment
"RTN","HLCSTCP",166,0)
 N HLJ,X
"RTN","HLCSTCP",167,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",168,0)
 S X=+$P(^HLCS(870,HLDP,0),U,5),$P(^(0),U,5)=$S(Y:X+1,1:X-1)_" server"
"RTN","HLCSTCP",169,0)
 ;if incrementing, set the Device Type field to Multi-Server
"RTN","HLCSTCP",170,0)
 I X S HLJ(870,HLDP_",",3)="MS" D FILE^HLDIE("","HLJ","","UPDT","HLCSTCP") ;HL*1.6*109
"RTN","HLCSTCP",171,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",172,0)
 Q
"RTN","HLCSTCP",173,0)
STOP() ;stop flag set
"RTN","HLCSTCP",174,0)
 N X
"RTN","HLCSTCP",175,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",176,0)
 S X=+$P(^HLCS(870,HLDP,0),U,15)
"RTN","HLCSTCP",177,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",178,0)
 Q X
"RTN","HLCSTCP",179,0)
 ;
"RTN","HLCSTCP",180,0)
LLCNT(DP,Y,Z) ;update Logical Link counters
"RTN","HLCSTCP",181,0)
 ;DP=ien of Logical Link in file 870
"RTN","HLCSTCP",182,0)
 ;Y: 1=msg rec, 2=msg proc, 3=msg to send, 4=msg sent
"RTN","HLCSTCP",183,0)
 ;Z: ""=add to counter, 1=subtract from counter
"RTN","HLCSTCP",184,0)
 Q:'$D(^HLCS(870,+$G(DP),0))!('$G(Y))
"RTN","HLCSTCP",185,0)
 N P,X
"RTN","HLCSTCP",186,0)
 S P=$S(Y<3:"IN",1:"OUT")_" QUEUE "_$S(Y#2:"BACK",1:"FRONT")_" POINTER"
"RTN","HLCSTCP",187,0)
 F  L +^HLCS(870,DP,P):2 Q:$T
"RTN","HLCSTCP",188,0)
 S X=+$G(^HLCS(870,DP,P)),^(P)=X+$S($G(Z):-1,1:1)
"RTN","HLCSTCP",189,0)
 L -^HLCS(870,DP,P)
"RTN","HLCSTCP",190,0)
 Q
"RTN","HLCSTCP",191,0)
SDFLD ; set Shutdown? field to yes
"RTN","HLCSTCP",192,0)
 Q:'$G(HLDP)
"RTN","HLCSTCP",193,0)
 N HLJ,X
"RTN","HLCSTCP",194,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",195,0)
 ;14=Shutdown LLP?
"RTN","HLCSTCP",196,0)
 S HLJ(870,HLDP_",",14)=1
"RTN","HLCSTCP",197,0)
 D FILE^HLDIE("","HLJ","","SDFLD","HLCSTCP") ;HL*1.6*109
"RTN","HLCSTCP",198,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",199,0)
 Q
"RTN","HLCSTCP",200,0)
 ;
"RTN","HLCSTCP",201,0)
EXITS(Y) ; Single service shutdown and cleans up
"RTN","HLCSTCP",202,0)
 N HLJ,X
"RTN","HLCSTCP",203,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",204,0)
 ;4=status,10=Time Stopped,9=Time Started,11=Task Number
"RTN","HLCSTCP",205,0)
 S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCSTCP",206,0)
 S @X@(4)=Y,@X@(11)="@"
"RTN","HLCSTCP",207,0)
 S:$G(HLCSOUT)'=2 @X@(10)=$$NOW^XLFDT,@X@(9)="@"
"RTN","HLCSTCP",208,0)
 D FILE^HLDIE("","HLJ","","EXITS","HLCSTCP") ; HL*1.6*109
"RTN","HLCSTCP",209,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",210,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLCSTCP",211,0)
 Q
"RTN","HLCSTCP",212,0)
 ;
"RTN","HLCSTCP",213,0)
EXITM ;Multiple service shutdown and clean up
"RTN","HLCSTCP",214,0)
 D UPDT(0)
"RTN","HLCSTCP",215,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLCSTCP",216,0)
 Q
"RTN","HLCSTCP1")
0^11^B31809732^B29359116
"RTN","HLCSTCP1",1,0)
HLCSTCP1 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;09/13/2006
"RTN","HLCSTCP1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,64,71,133**;JUL 17,1995;Build 13
"RTN","HLCSTCP1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP1",4,0)
 ;Receiver
"RTN","HLCSTCP1",5,0)
 ;connection is initiated by sender and listener accepts connection
"RTN","HLCSTCP1",6,0)
 ;and calls this routine
"RTN","HLCSTCP1",7,0)
 ;
"RTN","HLCSTCP1",8,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP1"
"RTN","HLCSTCP1",9,0)
 N HLMIEN,HLASTMSG
"RTN","HLCSTCP1",10,0)
 D MON^HLCSTCP("Open")
"RTN","HLCSTCP1",11,0)
 K ^TMP("HLCSTCP",$J,0)
"RTN","HLCSTCP1",12,0)
 S HLMIEN=0,HLASTMSG=""
"RTN","HLCSTCP1",13,0)
 F  D  Q:$$STOP^HLCSTCP  I 'HLMIEN D MON^HLCSTCP("Idle") H 3
"RTN","HLCSTCP1",14,0)
 . S HLMIEN=$$READ
"RTN","HLCSTCP1",15,0)
 . Q:'HLMIEN
"RTN","HLCSTCP1",16,0)
 . D PROCESS
"RTN","HLCSTCP1",17,0)
 Q
"RTN","HLCSTCP1",18,0)
 ;
"RTN","HLCSTCP1",19,0)
PROCESS ;check message and reply
"RTN","HLCSTCP1",20,0)
 ;HLDP=LL in 870, update monitor, received msg.
"RTN","HLCSTCP1",21,0)
 N HLTCP,HLTCPI,HLTCPO
"RTN","HLCSTCP1",22,0)
 S HLTCP="",HLTCPO=HLDP,HLTCPI=+HLMIEN
"RTN","HLCSTCP1",23,0)
 ;update monitor, msg. received
"RTN","HLCSTCP1",24,0)
 D LLCNT^HLCSTCP(HLDP,1)
"RTN","HLCSTCP1",25,0)
 D NEW^HLTP3(HLMIEN)
"RTN","HLCSTCP1",26,0)
 ;update monitor, msg. processed
"RTN","HLCSTCP1",27,0)
 D LLCNT^HLCSTCP(HLDP,2)
"RTN","HLCSTCP1",28,0)
 Q
"RTN","HLCSTCP1",29,0)
 ;
"RTN","HLCSTCP1",30,0)
READ() ;read 1 message, returns ien in 773^ien in 772 for message
"RTN","HLCSTCP1",31,0)
 D MON^HLCSTCP("Reading")
"RTN","HLCSTCP1",32,0)
 N HLDB,HLDT,HLDEND,HLACKWT,HLDSTRT,HLHDR,HLIND1,HLINE,HLMSG,HLRDOUT,HLRS,HLX,X
"RTN","HLCSTCP1",33,0)
 ;HLDSTRT=start char., HLDEND=end char., HLRS=record seperator
"RTN","HLCSTCP1",34,0)
 S HLDSTRT=$C(11),HLDEND=$C(28),HLRS=$C(13)
"RTN","HLCSTCP1",35,0)
 ;HLRDOUT=exit read loop, HLINE=line count, HLIND1=ien 773^ien 772
"RTN","HLCSTCP1",36,0)
 ;HLHDR=have a header, ^TMP(...)=excess from last read, HLACKWT=wait for ack
"RTN","HLCSTCP1",37,0)
 S (HLRDOUT,HLINE,HLIND1,HLHDR)=0,HLX=$G(^TMP("HLCSTCP",$J,0)),HLACKWT=HLDBACK
"RTN","HLCSTCP1",38,0)
 K ^TMP("HLCSTCP",$J,0)
"RTN","HLCSTCP1",39,0)
 F  D RDBLK Q:HLRDOUT
"RTN","HLCSTCP1",40,0)
 ;save any excess for next time
"RTN","HLCSTCP1",41,0)
 S:$L(HLX) ^TMP("HLCSTCP",$J,0)=HLX
"RTN","HLCSTCP1",42,0)
 I +HLIND1,'$P(HLIND1,U,3) D DELMSG(HLIND1) S HLIND1=0
"RTN","HLCSTCP1",43,0)
 Q HLIND1
"RTN","HLCSTCP1",44,0)
 ;
"RTN","HLCSTCP1",45,0)
RDBLK S HLDB=HLDBSIZE-$L(HLX)
"RTN","HLCSTCP1",46,0)
 U IO R X#HLDB:HLDREAD
"RTN","HLCSTCP1",47,0)
 ;switch to null device if opened to prevent 'leakage'
"RTN","HLCSTCP1",48,0)
 I $G(IO(0))'="",$G(IO(0))'=IO U IO(0)
"RTN","HLCSTCP1",49,0)
 ; timedout, check ack timeout, clean up
"RTN","HLCSTCP1",50,0)
 I '$T,X="",HLX="" S HLACKWT=HLACKWT-HLDREAD D:HLACKWT<0&'HLHDR CLEAN Q
"RTN","HLCSTCP1",51,0)
 ;data stream: <sb>dddd<cr><eb><cr>
"RTN","HLCSTCP1",52,0)
 ;add incoming line to what wasn't processed in last read
"RTN","HLCSTCP1",53,0)
 S HLX=$G(HLX)_X
"RTN","HLCSTCP1",54,0)
 ; look for segment= <CR>
"RTN","HLCSTCP1",55,0)
 F  Q:HLX'[HLRS  D  Q:HLRDOUT
"RTN","HLCSTCP1",56,0)
 . ; Get the first piece, save the rest of the line
"RTN","HLCSTCP1",57,0)
 . S HLINE=HLINE+1,HLMSG(HLINE,0)=$P(HLX,HLRS),HLX=$P(HLX,HLRS,2,999)
"RTN","HLCSTCP1",58,0)
 . ; check for start block, Quit if no ien
"RTN","HLCSTCP1",59,0)
 . I HLMSG(HLINE,0)[HLDSTRT!HLHDR D  Q
"RTN","HLCSTCP1",60,0)
 .. D:HLMSG(HLINE,0)[HLDSTRT
"RTN","HLCSTCP1",61,0)
 ... S X=$L(HLMSG(HLINE,0),HLDSTRT)
"RTN","HLCSTCP1",62,0)
 ... S:X>2 HLMSG(HLINE,0)=HLDSTRT_$P(HLMSG(HLINE,0),HLDSTRT,X)
"RTN","HLCSTCP1",63,0)
 ... S HLMSG(HLINE,0)=$P(HLMSG(HLINE,0),HLDSTRT,2)
"RTN","HLCSTCP1",64,0)
 ... D RESET:(HLINE>1)
"RTN","HLCSTCP1",65,0)
 .. ;ping message
"RTN","HLCSTCP1",66,0)
 .. I $E(HLMSG(1,0),1,9)="MSH^PING^" D PING Q
"RTN","HLCSTCP1",67,0)
 .. ; get next ien to store
"RTN","HLCSTCP1",68,0)
 .. D MIEN
"RTN","HLCSTCP1",69,0)
 .. K HLMSG
"RTN","HLCSTCP1",70,0)
 .. S (HLINE,HLHDR)=0
"RTN","HLCSTCP1",71,0)
 . ; check for end block; HLMSG(HLINE) = <eb><cr>
"RTN","HLCSTCP1",72,0)
 . I HLMSG(HLINE,0)[HLDEND D
"RTN","HLCSTCP1",73,0)
 .. ;no msg. ien
"RTN","HLCSTCP1",74,0)
 .. Q:'HLIND1
"RTN","HLCSTCP1",75,0)
 .. ; Kill just the last line
"RTN","HLCSTCP1",76,0)
 .. K HLMSG(HLINE,0) S HLINE=HLINE-1
"RTN","HLCSTCP1",77,0)
 .. ; move into 772
"RTN","HLCSTCP1",78,0)
 .. D SAVE(.HLMSG,"^HL(772,"_+$P(HLIND1,U,2)_",""IN"")")
"RTN","HLCSTCP1",79,0)
 .. ;mark that end block has been received
"RTN","HLCSTCP1",80,0)
 .. ;HLIND1=ien in 773^ien in 772^1 if end block was received
"RTN","HLCSTCP1",81,0)
 .. S $P(HLIND1,U,3)=1
"RTN","HLCSTCP1",82,0)
 .. ;reset variables for next message
"RTN","HLCSTCP1",83,0)
 .. D CLEAN
"RTN","HLCSTCP1",84,0)
 . ;add blank line for carriage return
"RTN","HLCSTCP1",85,0)
 . I HLINE'=0,HLMSG(HLINE,0)]"" S HLINE=HLINE+1,HLMSG(HLINE,0)=""
"RTN","HLCSTCP1",86,0)
 Q:HLRDOUT
"RTN","HLCSTCP1",87,0)
 ;If the line is long and no <CR> move it into the array. 
"RTN","HLCSTCP1",88,0)
 I ($L(HLX)=HLDBSIZE),(HLX'[HLRS),(HLX'[HLDEND),(HLX'[HLDSTRT) D  Q
"RTN","HLCSTCP1",89,0)
 . S HLINE=HLINE+1,HLMSG(HLINE,0)=HLX,HLX=""
"RTN","HLCSTCP1",90,0)
 ;have start block but no record seperator
"RTN","HLCSTCP1",91,0)
 I HLX[HLDSTRT D  Q
"RTN","HLCSTCP1",92,0)
 . ;check for more than 1 start block
"RTN","HLCSTCP1",93,0)
 . S X=$L(HLX,HLDSTRT) S:X>2 HLX=HLDSTRT_$P(HLX,HLDSTRT,X)
"RTN","HLCSTCP1",94,0)
 . S:$L($P(HLX,HLDSTRT,2))>8 HLINE=HLINE+1,HLMSG(HLINE,0)=$P(HLX,HLDSTRT,2),HLX="",HLHDR=1
"RTN","HLCSTCP1",95,0)
 . D RESET:(HLHDR&(HLINE>1))
"RTN","HLCSTCP1",96,0)
 ;if no ien, then we don't have start block, reset
"RTN","HLCSTCP1",97,0)
 I 'HLIND1 D CLEAN Q
"RTN","HLCSTCP1",98,0)
 ; big message-merge from local to global every 100 lines
"RTN","HLCSTCP1",99,0)
 I (HLINE-$O(HLMSG(0)))>100 D
"RTN","HLCSTCP1",100,0)
 . M ^HL(772,+$P(HLIND1,U,2),"IN")=HLMSG
"RTN","HLCSTCP1",101,0)
 . ; reset working array
"RTN","HLCSTCP1",102,0)
 . K HLMSG
"RTN","HLCSTCP1",103,0)
 Q
"RTN","HLCSTCP1",104,0)
 ;
"RTN","HLCSTCP1",105,0)
SAVE(SRC,DEST) ;save into global & set top node
"RTN","HLCSTCP1",106,0)
 ;SRC=source array (passed by ref.), DEST=destination global
"RTN","HLCSTCP1",107,0)
 M @DEST=SRC
"RTN","HLCSTCP1",108,0)
 S @DEST@(0)="^^"_HLINE_"^"_HLINE_"^"_DT_"^"
"RTN","HLCSTCP1",109,0)
 Q
"RTN","HLCSTCP1",110,0)
 ;
"RTN","HLCSTCP1",111,0)
DELMSG(HLMAMT) ;delete message from Message Administration/Message Text files.
"RTN","HLCSTCP1",112,0)
 N DIK,DA
"RTN","HLCSTCP1",113,0)
 S DA=+HLMAMT,DIK="^HLMA("
"RTN","HLCSTCP1",114,0)
 D ^DIK
"RTN","HLCSTCP1",115,0)
 S DA=$P(HLMAMT,U,2),DIK="^HL(772,"
"RTN","HLCSTCP1",116,0)
 D ^DIK
"RTN","HLCSTCP1",117,0)
 Q
"RTN","HLCSTCP1",118,0)
MIEN ; sets HLIND1=ien in 773^ien in 772 for message
"RTN","HLCSTCP1",119,0)
 N HLMID,X
"RTN","HLCSTCP1",120,0)
 I HLIND1 D
"RTN","HLCSTCP1",121,0)
 . S:'$G(^HLMA(+HLIND1,0)) HLIND1=0
"RTN","HLCSTCP1",122,0)
 . S:'$G(^HL(772,+$P(HLIND1,U,2),0)) HLIND1=0
"RTN","HLCSTCP1",123,0)
 ;msg. id is 10th of MSH & 11th for BSH or FSH
"RTN","HLCSTCP1",124,0)
 S X=10+($E(HLMSG(1,0),1,3)'="MSH"),HLMID=$$PMSH(.HLMSG,X)
"RTN","HLCSTCP1",125,0)
 ;if HLIND1 is set, kill old message, use HLIND1 for new
"RTN","HLCSTCP1",126,0)
 ;message, it means we never got end block for 1st msg.
"RTN","HLCSTCP1",127,0)
 I HLIND1 D  Q
"RTN","HLCSTCP1",128,0)
 . ;get pointer to 772, kill header
"RTN","HLCSTCP1",129,0)
 . K ^HLMA(+HLIND1,"MSH")
"RTN","HLCSTCP1",130,0)
 . I $D(^HL(772,+$P(HLIND1,U,2),"IN")) K ^("IN")
"RTN","HLCSTCP1",131,0)
 . S X=$$MAID^HLTF(+HLIND1,HLMID)
"RTN","HLCSTCP1",132,0)
 . D SAVE(.HLMSG,"^HLMA("_+HLIND1_",""MSH"")")
"RTN","HLCSTCP1",133,0)
 . S:$P(HLIND1,U,3) $P(HLIND1,U,3)=""
"RTN","HLCSTCP1",134,0)
 D TCP^HLTF(.HLMID,.X,.HLDT)
"RTN","HLCSTCP1",135,0)
 I 'X D  Q
"RTN","HLCSTCP1",136,0)
 . ;error - record and reset array
"RTN","HLCSTCP1",137,0)
 . ;killing HLLSTN will allow MON^HLCSTCP to work with multi-server
"RTN","HLCSTCP1",138,0)
 . D CLEAN K HLLSTN
"RTN","HLCSTCP1",139,0)
 . ;error 100=LLP Could not Enqueue the Message, reset array
"RTN","HLCSTCP1",140,0)
 . D MONITOR^HLCSDR2(100,19,HLDP),MON^HLCSTCP("ERROR") H 30
"RTN","HLCSTCP1",141,0)
 ;HLIND1=ien in 773^ien in 772
"RTN","HLCSTCP1",142,0)
 S HLIND1=X_U_+$G(^HLMA(X,0))
"RTN","HLCSTCP1",143,0)
 ;save MSH into 773
"RTN","HLCSTCP1",144,0)
 D SAVE(.HLMSG,"^HLMA("_+HLIND1_",""MSH"")")
"RTN","HLCSTCP1",145,0)
 Q
"RTN","HLCSTCP1",146,0)
 ;
"RTN","HLCSTCP1",147,0)
PMSH(MSH,P) ;get piece P from MSH array (passed by ref.)
"RTN","HLCSTCP1",148,0)
 N FS,I,L,L1,L2,X,Y
"RTN","HLCSTCP1",149,0)
 S FS=$E(MSH(1,0),4),(L2,Y)=0,X=""
"RTN","HLCSTCP1",150,0)
 F I=1:1 S L1=$L($G(MSH(I,0)),FS),L=L1+Y-1 D  Q:$L(X)!'$D(MSH(I,0))
"RTN","HLCSTCP1",151,0)
 . S:L1=1 L=L+1
"RTN","HLCSTCP1",152,0)
 . S:P'>L X=$P($G(MSH(I-1,0)),FS,P-L2)_$P($G(MSH(I,0)),FS,(P-Y))
"RTN","HLCSTCP1",153,0)
 . S L2=Y,Y=L
"RTN","HLCSTCP1",154,0)
 Q X
"RTN","HLCSTCP1",155,0)
 ;
"RTN","HLCSTCP1",156,0)
PING ;process PING message
"RTN","HLCSTCP1",157,0)
 S X=HLMSG(1,0)
"RTN","HLCSTCP1",158,0)
 I X[HLDEND U IO W X,! I $G(IO(0))'="",$G(IO(0))'=IO U IO(0) ;switch to null device if opened to prevent 'leakage'
"RTN","HLCSTCP1",159,0)
 ;
"RTN","HLCSTCP1",160,0)
CLEAN ;reset var. for next message
"RTN","HLCSTCP1",161,0)
 K HLMSG
"RTN","HLCSTCP1",162,0)
 S HLINE=0,HLRDOUT=1
"RTN","HLCSTCP1",163,0)
 Q
"RTN","HLCSTCP1",164,0)
 ;
"RTN","HLCSTCP1",165,0)
ERROR ; Error trap for disconnect error and return back to the read loop.
"RTN","HLCSTCP1",166,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLCSTCP1",167,0)
 I $$EC^%ZOSV["READ"!($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D UNWIND^%ZTER Q
"RTN","HLCSTCP1",168,0)
 I $$EC^%ZOSV["WRITE" D CC("Wr-err") D UNWIND^%ZTER Q
"RTN","HLCSTCP1",169,0)
 S HLCSOUT=1 D ^%ZTER,CC("Error")
"RTN","HLCSTCP1",170,0)
 D UNWIND^%ZTER
"RTN","HLCSTCP1",171,0)
 Q
"RTN","HLCSTCP1",172,0)
 ;
"RTN","HLCSTCP1",173,0)
CC(X) ;cleanup and close
"RTN","HLCSTCP1",174,0)
 D MON^HLCSTCP(X)
"RTN","HLCSTCP1",175,0)
 H 2
"RTN","HLCSTCP1",176,0)
 Q
"RTN","HLCSTCP1",177,0)
RESET ;reset info as a result of no end block
"RTN","HLCSTCP1",178,0)
 N %
"RTN","HLCSTCP1",179,0)
 S HLMSG(1,0)=HLMSG(HLINE,0)
"RTN","HLCSTCP1",180,0)
 F %=2:1:HLINE K HLMSG(%,0)
"RTN","HLCSTCP1",181,0)
 S HLINE=1
"RTN","HLCSTCP1",182,0)
 Q
"RTN","HLCSTCP2")
0^12^B63043745^B55298525
"RTN","HLCSTCP2",1,0)
HLCSTCP2 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;09/13/2006
"RTN","HLCSTCP2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,49,57,63,64,66,67,76,77,87,109,133**;Oct 13,1995;Build 13
"RTN","HLCSTCP2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP2",4,0)
 ;Sender 
"RTN","HLCSTCP2",5,0)
 ;Request connection, send outbound message(s) delimited by MLLP
"RTN","HLCSTCP2",6,0)
 ;Input : HLDP=Logical Link to use
"RTN","HLCSTCP2",7,0)
 ; Set up error trap
"RTN","HLCSTCP2",8,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",9,0)
 N HLMSG,HLPORT,HLRETRY,HLRETMG,HLTCPO,POP
"RTN","HLCSTCP2",10,0)
 ;HLRETRY=number of retranmission for this link,HLRETMG=alert sent
"RTN","HLCSTCP2",11,0)
 S HLTCPO=HLDP,HLMSG="",(HLRETRY,HLRETMG)=0
"RTN","HLCSTCP2",12,0)
 ;
"RTN","HLCSTCP2",13,0)
 ;set IO(0) to the null device
"RTN","HLCSTCP2",14,0)
 S IO(0)=$S(^%ZOSF("OS")["OpenM":$S($$OS^%ZOSV()["VMS":"_NLA0:",$$OS^%ZOSV()["UNIX":"/dev/null",1:$P),^%ZOSF("OS")["DSM":"_NLA0:",1:$P)
"RTN","HLCSTCP2",15,0)
 O IO(0) U IO(0)
"RTN","HLCSTCP2",16,0)
 ;
"RTN","HLCSTCP2",17,0)
 ;persistent conection, open connection first, HLPORT=open port
"RTN","HLCSTCP2",18,0)
 I $G(HLTCPLNK)["Y" F  Q:$$OPEN  G EXIT:$$STOP^HLCSTCP H 1
"RTN","HLCSTCP2",19,0)
 F  D QUE Q:$$STOP^HLCSTCP  D:'HLMSG  Q:$G(HLCSOUT)
"RTN","HLCSTCP2",20,0)
 . ;no messages to send
"RTN","HLCSTCP2",21,0)
 . D MON^HLCSTCP("Idle") H 3
"RTN","HLCSTCP2",22,0)
 . ;persistent connection, no retention
"RTN","HLCSTCP2",23,0)
 . Q:$G(HLTCPLNK)["Y"
"RTN","HLCSTCP2",24,0)
 . D MON^HLCSTCP("Retention")
"RTN","HLCSTCP2",25,0)
 . N % I 0
"RTN","HLCSTCP2",26,0)
 . ;if message comes in or ask to stop
"RTN","HLCSTCP2",27,0)
 . F %=1:1:HLTCPRET H 1 I $$STOP^HLCSTCP!$O(^HLMA("AC","O",HLDP,0)) Q
"RTN","HLCSTCP2",28,0)
 . E  S HLCSOUT=2 Q
"RTN","HLCSTCP2",29,0)
 . Q:$$STOP^HLCSTCP
"RTN","HLCSTCP2",30,0)
 . D MON^HLCSTCP("Idle")
"RTN","HLCSTCP2",31,0)
 ;Close port
"RTN","HLCSTCP2",32,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",33,0)
EXIT Q
"RTN","HLCSTCP2",34,0)
 ;
"RTN","HLCSTCP2",35,0)
QUE ; -- Check "OUT" queue for processing IF there is a message do it
"RTN","HLCSTCP2",36,0)
 ; and then check the link if it open or not
"RTN","HLCSTCP2",37,0)
 N HL,HLN,HLARR,HLHDR,HLI,HLJ,HLMSA,HLRESP,HLRESLT,HLRETRM,HLTCP,HLTCPI,X,Z,HLREREAD
"RTN","HLCSTCP2",38,0)
 D MON^HLCSTCP("Check out")
"RTN","HLCSTCP2",39,0)
 ;HLMSG=next msg, set at tag DONE
"RTN","HLCSTCP2",40,0)
 I 'HLMSG S HLMSG=+$O(^HLMA("AC","O",HLDP,0)),HLRETRY=0 Q:'HLMSG
"RTN","HLCSTCP2",41,0)
 ;
"RTN","HLCSTCP2",42,0)
 ;**109**
"RTN","HLCSTCP2",43,0)
 ;Temporarily lock ^HLMA to flush buffer and ensure edits are complete
"RTN","HLCSTCP2",44,0)
 ;L +^HLMA(HLMSG):1 I '$T S HLMSG=0 Q
"RTN","HLCSTCP2",45,0)
 ;L -^HLMA(HLMSG)
"RTN","HLCSTCP2",46,0)
 ;
"RTN","HLCSTCP2",47,0)
 S HLI=+$G(^HLMA(HLMSG,0)),HLJ=$O(^("MSH",0)),HLTCP=""
"RTN","HLCSTCP2",48,0)
 ;don't have message text or MSH, kill x-ref and decrement 'to send'
"RTN","HLCSTCP2",49,0)
 I 'HLI!'HLJ K ^HLMA("AC","O",HLDP,HLMSG) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",50,0)
 ;update msg status to 'being transmitted'; if cancelled decrement link and quit
"RTN","HLCSTCP2",51,0)
 I '$$CHKMSG(1.5) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",52,0)
 ;number of retransmissions for message
"RTN","HLCSTCP2",53,0)
 S HLRETRM=+$P(^HLMA(HLMSG,"P"),U,5)
"RTN","HLCSTCP2",54,0)
 ;retries exceeded, HLRETRA:action i=ignore, r=restart, s=shutdown
"RTN","HLCSTCP2",55,0)
 ;quit if restart or shutdown, link is going down
"RTN","HLCSTCP2",56,0)
 I HLRETRY>HLDRETR D  Q:"I"'[HLRETRA
"RTN","HLCSTCP2",57,0)
 . D MON^HLCSTCP("Error")
"RTN","HLCSTCP2",58,0)
 . ;only 1 alert per link up time, don't send if restart
"RTN","HLCSTCP2",59,0)
 . D:'HLRETMG&(HLRETRA'="R")
"RTN","HLCSTCP2",60,0)
 .. ;send alert
"RTN","HLCSTCP2",61,0)
 .. N XQA,XQAMSG,XQAOPT,XQAROU,XQAID,Z
"RTN","HLCSTCP2",62,0)
 .. ;get mailgroup from file 869.3
"RTN","HLCSTCP2",63,0)
 .. S HLRETMG=1,Z=$P($$PARAM^HLCS2,U,8) Q:Z=""
"RTN","HLCSTCP2",64,0)
 .. S XQA("G."_Z)="",XQAMSG=$$HTE^XLFDT($H,2)_" HL7 LL "_$P(^HLCS(870,HLDP,0),U)_" exceeded retries. LL will "_$S(HLRETRA="S":"shutdown.",HLRETRA="R":"restart.",1:"keep trying.")
"RTN","HLCSTCP2",65,0)
 .. D SETUP^XQALERT
"RTN","HLCSTCP2",66,0)
 . ;quit if action is ignore
"RTN","HLCSTCP2",67,0)
 . Q:"I"[HLRETRA
"RTN","HLCSTCP2",68,0)
 . ;this will shutdown this link
"RTN","HLCSTCP2",69,0)
 . S HLCSOUT=1
"RTN","HLCSTCP2",70,0)
 . ;action is shutdown, set shutdown flag so LM won't restart
"RTN","HLCSTCP2",71,0)
 . S:HLRETRA="S" $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP2",72,0)
 . D STATUS^HLTF0(HLMSG,4,103,"LLP Exceeded Retry Param")
"RTN","HLCSTCP2",73,0)
 I '$$OPEN Q
"RTN","HLCSTCP2",74,0)
 D MON^HLCSTCP("Send")
"RTN","HLCSTCP2",75,0)
 ; -- data passed in global array, success=1
"RTN","HLCSTCP2",76,0)
 I $$WRITE(HLMSG)<0 Q
"RTN","HLCSTCP2",77,0)
 S (HLTCP,HLTCPI)=HLMSG,HLRETRY=HLRETRY+1,HLRETRM=HLRETRM+1
"RTN","HLCSTCP2",78,0)
 ;update status to awaiting response, decrement link if cancelled
"RTN","HLCSTCP2",79,0)
 I '$$CHKMSG(1.7) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",80,0)
 ;set transmission count, get ACKTIMEOUT override
"RTN","HLCSTCP2",81,0)
 S $P(^HLMA(HLMSG,"P"),U,5)=HLRETRM I $P(^("P"),U,7) S HLN("ACKTIME")=+$P(^("P"),U,7)
"RTN","HLCSTCP2",82,0)
 ;get header of message just sent
"RTN","HLCSTCP2",83,0)
 K HLJ M HLJ=^HLMA(HLMSG,"MSH")
"RTN","HLCSTCP2",84,0)
 ;first component of sending app.
"RTN","HLCSTCP2",85,0)
 S HLN("ECH")=$$P^HLTPCK2(.HLJ,2),HLN("SAN")=$P($$P^HLTPCK2(.HLJ,3),$E(HLN("ECH")))
"RTN","HLCSTCP2",86,0)
 ;msg type, msg. id, commit ack, and app. ack parameter
"RTN","HLCSTCP2",87,0)
 S HLN("TYPE")=$$P^HLTPCK2(.HLJ,1),HLN("MID")=$$P^HLTPCK2(.HLJ,10),HLN("ACAT")=$$P^HLTPCK2(.HLJ,15),HLN("APAT")=$$P^HLTPCK2(.HLJ,16)
"RTN","HLCSTCP2",88,0)
 ;MSA segment, message is a response, can't have an a. ack.
"RTN","HLCSTCP2",89,0)
 S Z=$$MSA^HLTP3(+^HLMA(HLMSG,0)) I Z]"" S:HLN("ACAT")="" HLN("ACAT")="NE" S HLN("APAT")="NE"
"RTN","HLCSTCP2",90,0)
 ;for batch/file with commit ack, reset c. ack and a. ack variables
"RTN","HLCSTCP2",91,0)
 I "BHS,FHS"[HLN("TYPE") S Z=$E(HLJ(1,0),5),X=$$P^HLTPCK2(.HLJ,9),HLN("ACAT")=$P(X,Z,5),HLN("APAT")=$P(X,Z,6),HLN("MID")=$$P^HLTPCK2(.HLJ,11)
"RTN","HLCSTCP2",92,0)
 ;get event protocol
"RTN","HLCSTCP2",93,0)
 S HLN("EID")=+$P(^HLMA(HLMSG,0),U,8),X=$G(^ORD(101,HLN("EID"),770))
"RTN","HLCSTCP2",94,0)
 ;set link counter to msg sent
"RTN","HLCSTCP2",95,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSTCP2",96,0)
 ;commit and app. ack is never, update status to complete and hang UNI-DIRECTIONAL WAIT
"RTN","HLCSTCP2",97,0)
 I HLN("ACAT")="NE",HLN("APAT")="NE" D  Q
"RTN","HLCSTCP2",98,0)
 .D DONE(3)
"RTN","HLCSTCP2",99,0)
 .;
"RTN","HLCSTCP2",100,0)
 .;
"RTN","HLCSTCP2",101,0)
 .H $G(HLDWAIT)
"RTN","HLCSTCP2",102,0)
 ;
"RTN","HLCSTCP2",103,0)
 ;do structure is to stack error
"RTN","HLCSTCP2",104,0)
 D
"RTN","HLCSTCP2",105,0)
 . N $ETRAP,$ESTACK S $ETRAP="D RDERR^HLCSTCP2"
"RTN","HLCSTCP2",106,0)
 . ;HL*1.6*87: Read acknowledgement.  
"RTN","HLCSTCP2",107,0)
 . ;Loop to re-read from buffer when receiving incorrect ack.
"RTN","HLCSTCP2",108,0)
 . F  D  Q:'+$G(HLREREAD)
"RTN","HLCSTCP2",109,0)
 .. S HLREREAD=1
"RTN","HLCSTCP2",110,0)
 .. ;override ack timeout
"RTN","HLCSTCP2",111,0)
 .. I $G(HLN("ACKTIME")) N HLDBACK S HLDBACK=HLN("ACKTIME")
"RTN","HLCSTCP2",112,0)
 .. ;check for response, quit if no-response, msg will be resent
"RTN","HLCSTCP2",113,0)
 .. ;HLRESP=ien 773^ien 772 for response message
"RTN","HLCSTCP2",114,0)
 .. S HLRESP=$$READ^HLCSTCP1()
"RTN","HLCSTCP2",115,0)
 .. ;if no response, decrement counter and quit
"RTN","HLCSTCP2",116,0)
 .. I 'HLRESP D  Q
"RTN","HLCSTCP2",117,0)
 ...D LLCNT^HLCSTCP(HLDP,4,1)
"RTN","HLCSTCP2",118,0)
 ...S HLREREAD="0^No Response"
"RTN","HLCSTCP2",119,0)
 ...;check if the port needs to be closed and re-opened before the next re-transmission attempt
"RTN","HLCSTCP2",120,0)
 ...I $G(HLDRETRY("CLOSE")) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",121,0)
 .. ;X 0=re-read msg, 1=commit ack, 3=app ack success, 4=error
"RTN","HLCSTCP2",122,0)
 .. S X=$$RSP^HLTP31(HLRESP,.HLN)
"RTN","HLCSTCP2",123,0)
 .. ;X=0, re-read msg. Incorrect ack (bad MSH,MSA,msg id,or sending app)
"RTN","HLCSTCP2",124,0)
 .. Q:'X 
"RTN","HLCSTCP2",125,0)
 .. ;commit ack - done
"RTN","HLCSTCP2",126,0)
 .. I X=1 D  S HLREREAD="0^Commit Ack" Q
"RTN","HLCSTCP2",127,0)
 ... ;don't need app. ack, set status to complete
"RTN","HLCSTCP2",128,0)
 ... I "NE"[HLN("APAT") D  Q
"RTN","HLCSTCP2",129,0)
 ....D DONE(3)
"RTN","HLCSTCP2",130,0)
 ....;
"RTN","HLCSTCP2",131,0)
 ... ;response is deferred, set status to awaiting ack
"RTN","HLCSTCP2",132,0)
 ... D DONE(2)
"RTN","HLCSTCP2",133,0)
 ...;
"RTN","HLCSTCP2",134,0)
 .. ;Error, HLRESLT=error number^error message from HLTP3
"RTN","HLCSTCP2",135,0)
 .. I X=4 D  Q
"RTN","HLCSTCP2",136,0)
 ... D DONE(4,+$G(HLRESLT),$P($G(HLRESLT),U,2))
"RTN","HLCSTCP2",137,0)
 ...;
"RTN","HLCSTCP2",138,0)
 ... S HLREREAD="0^Error"
"RTN","HLCSTCP2",139,0)
 .. ;app ack was successful
"RTN","HLCSTCP2",140,0)
 .. D DONE(3) S HLREREAD="0^App Ack"
"RTN","HLCSTCP2",141,0)
 ..;
"RTN","HLCSTCP2",142,0)
 Q
"RTN","HLCSTCP2",143,0)
 ;
"RTN","HLCSTCP2",144,0)
DCSEND ;direct connect
"RTN","HLCSTCP2",145,0)
 ; Set up error trap
"RTN","HLCSTCP2",146,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",147,0)
 ;override ack timeout
"RTN","HLCSTCP2",148,0)
 I $G(HLP("ACKTIME")) N HLDBACK S HLDBACK=HLP("ACKTIME")
"RTN","HLCSTCP2",149,0)
 I $$WRITE(HLMSG)<0 D:$G(HLERROR)]""  Q  ;HL*1.6*77
"RTN","HLCSTCP2",150,0)
 .  D STATUS^HLTF0(HLMSG,4,$P(HLERROR,"^"),$P(HLERROR,"^",2),1) ;HL*1.6*77
"RTN","HLCSTCP2",151,0)
 .  D LLCNT^HLCSTCP(HLDP,3,1)
"RTN","HLCSTCP2",152,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSTCP2",153,0)
 ;do structure is to stack error
"RTN","HLCSTCP2",154,0)
 D
"RTN","HLCSTCP2",155,0)
 . N $ETRAP,$ESTACK S $ETRAP="D RDERR^HLCSTCP2"
"RTN","HLCSTCP2",156,0)
 . ;HLRESP=ien 773^ien 772 for response message
"RTN","HLCSTCP2",157,0)
 . S HLRESP=$$READ^HLCSTCP1()
"RTN","HLCSTCP2",158,0)
 ;
"RTN","HLCSTCP2",159,0)
 D DONE(3):$G(HLRESP),DONE(4,108,$S($G(HLERROR)]"":$P(HLERROR,"^",2),1:"No response")):'$G(HLRESP)
"RTN","HLCSTCP2",160,0)
 I $G(HLERROR)']"" D
"RTN","HLCSTCP2",161,0)
 .D MON^HLCSTCP("Idle")
"RTN","HLCSTCP2",162,0)
 .I '$G(HLRESP) S HLERROR="108^No response"
"RTN","HLCSTCP2",163,0)
 ;Close port
"RTN","HLCSTCP2",164,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",165,0)
 Q
"RTN","HLCSTCP2",166,0)
 ;
"RTN","HLCSTCP2",167,0)
DONE(ST,ERR,ERRMSG) ;set status to complete
"RTN","HLCSTCP2",168,0)
 ;ST=status, ERR=error ien, ERRMSG=error msg
"RTN","HLCSTCP2",169,0)
 D STATUS^HLTF0(HLMSG,ST,$G(ERR),$G(ERRMSG),1)
"RTN","HLCSTCP2",170,0)
 ;
"RTN","HLCSTCP2",171,0)
 ;**109**
"RTN","HLCSTCP2",172,0)
 D DEQUE^HLCSREP(HLDP,"O",HLMSG)
"RTN","HLCSTCP2",173,0)
 ;
"RTN","HLCSTCP2",174,0)
 ;check for more msg.
"RTN","HLCSTCP2",175,0)
 I $G(HLPRIO)'="I" S HLMSG=+$O(^HLMA("AC","O",HLDP,0)),HLRETRY=0
"RTN","HLCSTCP2",176,0)
 Q
"RTN","HLCSTCP2",177,0)
 ;
"RTN","HLCSTCP2",178,0)
CHKMSG(HLI) ;check status of message and update if not cancelled
"RTN","HLCSTCP2",179,0)
 ;input: HLI=new status, HLMSG=ien of msg in 773
"RTN","HLCSTCP2",180,0)
 ;returns 1=msg was updated, 0=msg has been canceled
"RTN","HLCSTCP2",181,0)
 N X
"RTN","HLCSTCP2",182,0)
 ;
"RTN","HLCSTCP2",183,0)
 ;**109**
"RTN","HLCSTCP2",184,0)
 ;F  L +^HLMA(HLMSG,"P"):1 Q:$T  H 1
"RTN","HLCSTCP2",185,0)
 ;
"RTN","HLCSTCP2",186,0)
 ;
"RTN","HLCSTCP2",187,0)
 ; New HL*1.6*77 code starting here...
"RTN","HLCSTCP2",188,0)
 I '$D(^HLMA(HLMSG,"P")) D  Q 0
"RTN","HLCSTCP2",189,0)
 .  S HLERROR="2^Missing status field"
"RTN","HLCSTCP2",190,0)
 .  D STATUS^HLTF0(HLMSG,4,$P(HLERROR,U),$P(HLERROR,U,2),1)
"RTN","HLCSTCP2",191,0)
 .;
"RTN","HLCSTCP2",192,0)
 .;**109**
"RTN","HLCSTCP2",193,0)
 . D DEQUE^HLCSREP(HLDP,"O",HLMSG)
"RTN","HLCSTCP2",194,0)
 .;L -^HLMA(HLMSG,"P")
"RTN","HLCSTCP2",195,0)
 ;**end 109**
"RTN","HLCSTCP2",196,0)
 ;
"RTN","HLCSTCP2",197,0)
 ; End of HL*1.6*77 modifications
"RTN","HLCSTCP2",198,0)
 ;
"RTN","HLCSTCP2",199,0)
 ;get status, quit if msg was cancelled
"RTN","HLCSTCP2",200,0)
 ;
"RTN","HLCSTCP2",201,0)
 ;**109**
"RTN","HLCSTCP2",202,0)
 ;S X=+^HLMA(HLMSG,"P") I X=3 L -^HLMA(HLMSG,"P") Q 0
"RTN","HLCSTCP2",203,0)
 S X=+^HLMA(HLMSG,"P") Q:X=3 0
"RTN","HLCSTCP2",204,0)
 ;
"RTN","HLCSTCP2",205,0)
 ;update status if it is different
"RTN","HLCSTCP2",206,0)
 I $G(HLI),HLI'=X D STATUS^HLTF0(HLMSG,HLI)
"RTN","HLCSTCP2",207,0)
 ;
"RTN","HLCSTCP2",208,0)
 ;**109**
"RTN","HLCSTCP2",209,0)
 ;L -^HLMA(HLMSG,"P")
"RTN","HLCSTCP2",210,0)
 ;
"RTN","HLCSTCP2",211,0)
 Q 1
"RTN","HLCSTCP2",212,0)
 ;
"RTN","HLCSTCP2",213,0)
WRITE(HLDA) ; write message in HL7 format
"RTN","HLCSTCP2",214,0)
 ;  HLDA       - ien of message in 773
"RTN","HLCSTCP2",215,0)
 ;             - start block $C(11)
"RTN","HLCSTCP2",216,0)
 ;             - end block $C(28)
"RTN","HLCSTCP2",217,0)
 ;             - record separator $C(13)
"RTN","HLCSTCP2",218,0)
 ;Output(s): 1 - Successful
"RTN","HLCSTCP2",219,0)
 ;           -1 - Unsuccessful
"RTN","HLCSTCP2",220,0)
 ;
"RTN","HLCSTCP2",221,0)
 N HLDA2,HLAR,HLI,LINENO,X
"RTN","HLCSTCP2",222,0)
 ;set error trap, used when called from HLTP3
"RTN","HLCSTCP2",223,0)
 ;
"RTN","HLCSTCP2",224,0)
 ; New HL*1.6*77 code starts here...
"RTN","HLCSTCP2",225,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",226,0)
 I $G(^HLMA(HLDA,0))'>0 D  Q -1
"RTN","HLCSTCP2",227,0)
 .  S HLERROR="2^Message Text pointer missing"
"RTN","HLCSTCP2",228,0)
 S HLDA2=+$G(^HLMA(HLDA,0))
"RTN","HLCSTCP2",229,0)
 ; End of HL*1.6*77 modifications...
"RTN","HLCSTCP2",230,0)
 ;
"RTN","HLCSTCP2",231,0)
 Q:'$G(^HLMA(HLDA,0)) -1 ;HL*1.6*77
"RTN","HLCSTCP2",232,0)
 ; header is in ^HLMA(, message is in ^HL(772,
"RTN","HLCSTCP2",233,0)
 S LINENO=1,HLI=0,HLAR="^HLMA(HLDA,""MSH"")"
"RTN","HLCSTCP2",234,0)
 U IO
"RTN","HLCSTCP2",235,0)
 D  W $C(13) S HLAR="^HL(772,HLDA2,""IN"")",HLI=0 D
"RTN","HLCSTCP2",236,0)
 . F  S HLI=$O(@HLAR@(HLI)) Q:'HLI  S X=$G(^(HLI,0)) D
"RTN","HLCSTCP2",237,0)
 .. ;first line, need start block char.
"RTN","HLCSTCP2",238,0)
 .. S:LINENO=1 X=$C(11)_X
"RTN","HLCSTCP2",239,0)
 .. I X]"" W X,!
"RTN","HLCSTCP2",240,0)
 .. ;send CR for blank lines
"RTN","HLCSTCP2",241,0)
 .. I X="" W $C(13)
"RTN","HLCSTCP2",242,0)
 .. S LINENO=LINENO+1
"RTN","HLCSTCP2",243,0)
 ; Sends end block for this message
"RTN","HLCSTCP2",244,0)
 S X=$C(28)_$C(13)
"RTN","HLCSTCP2",245,0)
 U IO W X,!
"RTN","HLCSTCP2",246,0)
 I $G(IO(0))'="",$G(IO(0))'=IO U IO(0) ;switch to null device if opened to prevent 'leakage'
"RTN","HLCSTCP2",247,0)
 Q 1
"RTN","HLCSTCP2",248,0)
 ;
"RTN","HLCSTCP2",249,0)
OPEN() ; -- Open TCP/IP device (Client)
"RTN","HLCSTCP2",250,0)
 ;HLPORT=port, defined only if port is open
"RTN","HLCSTCP2",251,0)
 ;HLPORTA=number of attempted opens
"RTN","HLCSTCP2",252,0)
 I $D(HLPORT) S IO=HLPORT D  Q 1
"RTN","HLCSTCP2",253,0)
 . U IO
"RTN","HLCSTCP2",254,0)
 . I HLOS["OpenM" X "U IO:(::""-M"")" ;use packet mode on Cache'
"RTN","HLCSTCP2",255,0)
 N HLDOM,HLI,HLIP,HLPORTA
"RTN","HLCSTCP2",256,0)
 G OPENA^HLCSTCP3
"RTN","HLCSTCP2",257,0)
 ;
"RTN","HLCSTCP2",258,0)
RDERR D RDERR^HLCSTCP4 Q  ; Exceeded 10,000 bytes, so split on 12/2/03-LJA
"RTN","HLCSTCP2",259,0)
ERROR D ERROR^HLCSTCP4 Q  ; Exceeded 10,000 bytes, so split on 12/2/03-LJA
"RTN","HLCSTCP2",260,0)
 ;
"RTN","HLCSTCP2",261,0)
CC(X) ;cleanup and close
"RTN","HLCSTCP2",262,0)
 D MON^HLCSTCP(X)
"RTN","HLCSTCP2",263,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",264,0)
 H 2
"RTN","HLCSTCP2",265,0)
 Q
"RTN","HLCSTCP3")
0^4^B4549114^B3590592
"RTN","HLCSTCP3",1,0)
HLCSTCP3 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;09/13/2006
"RTN","HLCSTCP3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**76,77,133**;OCT 13, 1995;Build 13
"RTN","HLCSTCP3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP3",4,0)
 ;
"RTN","HLCSTCP3",5,0)
OPENA I $G(HLMSG),$D(^HLMA(HLMSG,"P")) S HLPORTA=+$P(^("P"),U,6)
"RTN","HLCSTCP3",6,0)
 D MON^HLCSTCP("Open")
"RTN","HLCSTCP3",7,0)
 S POP=1
"RTN","HLCSTCP3",8,0)
 I $G(HLDIRECT("OPEN TIMEOUT")) D
"RTN","HLCSTCP3",9,0)
 .S HLI=1
"RTN","HLCSTCP3",10,0)
 .D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLDIRECT("OPEN TIMEOUT"))
"RTN","HLCSTCP3",11,0)
 E  D
"RTN","HLCSTCP3",12,0)
 .F HLI=1:1:HLDRETR D CALL^%ZISTCP(HLTCPADD,HLTCPORT) Q:'POP
"RTN","HLCSTCP3",13,0)
 ;set # of opens back in msg
"RTN","HLCSTCP3",14,0)
 I $G(HLMSG),$D(^HLMA(HLMSG,"P")) S $P(^("P"),U,6)=HLPORTA+HLI
"RTN","HLCSTCP3",15,0)
 ;device open
"RTN","HLCSTCP3",16,0)
 I 'POP S HLPORT=IO D  Q $S($G(HLERROR)]"":0,1:1)
"RTN","HLCSTCP3",17,0)
 . N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2" ;HL*1.6*77
"RTN","HLCSTCP3",18,0)
 . ;if address came from DNS, set back into LL
"RTN","HLCSTCP3",19,0)
 . I $D(HLIP) S $P(^HLCS(870,HLDP,400),U)=HLTCPADD
"RTN","HLCSTCP3",20,0)
 . ; write and read to check if still open
"RTN","HLCSTCP3",21,0)
 . Q:HLOS'["OpenM"  X "U IO:(::""-M"")" ; must be Cache/NT + use packet mode
"RTN","HLCSTCP3",22,0)
 . Q:$P(^HLCS(870,HLDP,400),U,7)'="Y"  ; must want to SAY HELO
"RTN","HLCSTCP3",23,0)
 . U IO W "HELO "_$$KSP^XUPARAM("WHERE"),! R X:1
"RTN","HLCSTCP3",24,0)
 ;openfail-try DNS lookup
"RTN","HLCSTCP3",25,0)
 I '$D(HLDOM) S HLDOM=+$P(^HLCS(870,HLDP,0),U,7),HLDOM=$P($G(^DIC(4.2,HLDOM,0)),U) D:HLDOM]"" DNS
"RTN","HLCSTCP3",26,0)
 ;HLIP=ip add. from DNS call, get first one and try open again
"RTN","HLCSTCP3",27,0)
 I $D(HLIP) S HLTCPADD=$P(HLIP,","),HLIP=$P(HLIP,",",2,99) G:HLTCPADD OPENA
"RTN","HLCSTCP3",28,0)
 ;open error
"RTN","HLCSTCP3",29,0)
 I $G(HLDIRECT("OPEN TIMEOUT")) D
"RTN","HLCSTCP3",30,0)
 .D MON^HLCSTCP("Openfail")
"RTN","HLCSTCP3",31,0)
 .I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP3",32,0)
 E  D
"RTN","HLCSTCP3",33,0)
 .D CC^HLCSTCP2("Openfail") H 3
"RTN","HLCSTCP3",34,0)
 Q 0
"RTN","HLCSTCP3",35,0)
 ;
"RTN","HLCSTCP3",36,0)
 ;following code was removed, site's complained of to many alerts
"RTN","HLCSTCP3",37,0)
 ;couldn't open, send 1 alert
"RTN","HLCSTCP3",38,0)
 ;I '$G(HLPORTA) D
"RTN","HLCSTCP3",39,0)
 ;. ;send alert
"RTN","HLCSTCP3",40,0)
 ;. N XQA,XQAMSG,XQAOPT,XQAROU,XQAID,Z
"RTN","HLCSTCP3",41,0)
 ;. ;get mailgroup from file 869.3
"RTN","HLCSTCP3",42,0)
 ;. S Z=$P($$PARAM^HLCS2,U,8),HLPORTA="" Q:Z=""
"RTN","HLCSTCP3",43,0)
 ;. S XQA("G."_Z)="",XQAMSG=$$HTE^XLFDT($H,2)_" Logical Link "_$P(^HLCS(870,HLDP,0),U)_" exceeded Open Retries."
"RTN","HLCSTCP3",44,0)
 ;. D SETUP^XQALERT
"RTN","HLCSTCP3",45,0)
 ;open error
"RTN","HLCSTCP3",46,0)
 ;D CC("Openfail") H 3
"RTN","HLCSTCP3",47,0)
 ;Q 0
"RTN","HLCSTCP3",48,0)
 ;
"RTN","HLCSTCP3",49,0)
 ;
"RTN","HLCSTCP3",50,0)
DNS ;VA domains must have "med" inserted.
"RTN","HLCSTCP3",51,0)
 ;All domains must use port 5000 and are prepended with "HL7"
"RTN","HLCSTCP3",52,0)
 ;non-VA DNS lookups will succeed if site uses port 5000 and 
"RTN","HLCSTCP3",53,0)
 ;configure their local DNS with "HL7.yourdomain.com" and entries
"RTN","HLCSTCP3",54,0)
 ;are created in the logical link file and domain file.
"RTN","HLCSTCP3",55,0)
 D MON^HLCSTCP("DNS Lkup")
"RTN","HLCSTCP3",56,0)
 I HLDOM["VA.GOV"&(HLDOM'[".MED.") S HLDOM=$P(HLDOM,".VA.GOV")_".MED.VA.GOV"
"RTN","HLCSTCP3",57,0)
 I HLTCPORT=5000 S HLDOM="HL7."_HLDOM
"RTN","HLCSTCP3",58,0)
 I HLTCPORT=5500 S HLDOM="MPI."_HLDOM
"RTN","HLCSTCP3",59,0)
 S HLIP=$$ADDRESS^XLFNSLK(HLDOM)
"RTN","HLCSTCP3",60,0)
 K:HLIP="" HLIP
"RTN","HLCSTCP3",61,0)
 Q
"RTN","HLCSTCP3",62,0)
 ;
"RTN","HLMA")
0^1^B41676692^B36491876
"RTN","HLMA",1,0)
HLMA ;AISC/SAW-Message Administration Module ;09/13/2006
"RTN","HLMA",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,58,63,66,82,91,109,115,133**;Oct 13, 1995;Build 13
"RTN","HLMA",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLMA",4,0)
GENERATE(HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLMTIEN,HLP) ;
"RTN","HLMA",5,0)
 ;Entry point to generate a deferred message
"RTN","HLMA",6,0)
 ;
"RTN","HLMA",7,0)
 ;This is a subroutine call with parameter passing.  It returns a
"RTN","HLMA",8,0)
 ;value in the variable HLRESLT with 1 to 3 pieces separated by uparrows
"RTN","HLMA",9,0)
 ;as follows:  1st message ID^error code^error description
"RTN","HLMA",10,0)
 ;If no error occurs, only the first piece is returned equal to a unique
"RTN","HLMA",11,0)
 ;ID for the 1st message.  If message was sent to more than 1 subscriber
"RTN","HLMA",12,0)
 ;than the other message IDs will be in the array HLRESLT(n)=ID
"RTN","HLMA",13,0)
 ;Otherwise, three pieces are returned with the
"RTN","HLMA",14,0)
 ;first piece equal to the message ID, if one was assigned, otherwise 0
"RTN","HLMA",15,0)
 ;
"RTN","HLMA",16,0)
 ;Required Input Parameters
"RTN","HLMA",17,0)
 ;     HLEID = Name or IEN of event driver protocol in the Protocol file
"RTN","HLMA",18,0)
 ;  HLARYTYP = Array type.  One of the following codes:
"RTN","HLMA",19,0)
 ;               LM = local array containing a single message
"RTN","HLMA",20,0)
 ;               LB = local array containig a batch of messages
"RTN","HLMA",21,0)
 ;               GM = global array containing a single message
"RTN","HLMA",22,0)
 ;               GB = global array containing a batch of messages
"RTN","HLMA",23,0)
 ;  HLFORMAT = Format of array, 1 for pre-formatted in HL7 format,
"RTN","HLMA",24,0)
 ;               otherwise 0
"RTN","HLMA",25,0)
 ;NOTE:  The parameter HLRESLT must be passed by reference
"RTN","HLMA",26,0)
 ;   HLRESLT = The variable that will be returned to the calling
"RTN","HLMA",27,0)
 ;               application as descibed above
"RTN","HLMA",28,0)
 ;Optional Parameters
"RTN","HLMA",29,0)
 ;   HLMTIEN = IEN of entry in Message Text file where the message
"RTN","HLMA",30,0)
 ;               being generated is to be stored.  This parameter is
"RTN","HLMA",31,0)
 ;               only passed for a batch type message
"RTN","HLMA",32,0)
 ;NOTE:  The parameter HLP used for the following parameters must be
"RTN","HLMA",33,0)
 ;       passed by reference
"RTN","HLMA",34,0)
 ;  HLP("SECURITY") = A 1 to 40 character string
"RTN","HLMA",35,0)
 ;   HLP("CONTPTR") = Continuation pointer, a 1 to 180 character string
"RTN","HLMA",36,0)
 ; HLP("NAMESPACE") = Passed in by application namespace - HL*1.6*91
"RTN","HLMA",37,0)
 ;
"RTN","HLMA",38,0)
 ;can't have link open when generating new message
"RTN","HLMA",39,0)
 N HLTCP,HLTCPO,HLPRIO,HLMIDAR
"RTN","HLMA",40,0)
 S HLPRIO="D"
"RTN","HLMA",41,0)
 S HLRESLT=""
"RTN","HLMA",42,0)
 ;Check for required parameters
"RTN","HLMA",43,0)
CONT I $G(HLEID)']""!($G(HLARYTYP)']"")!($G(HLFORMAT)']"") S HLRESLT="0^7^"_$G(^HL(771.7,7,0))_" at GENERATE^HLMA entry point" G EXIT
"RTN","HLMA",44,0)
 I 'HLEID S HLEID=$O(^ORD(101,"B",HLEID,0)) I 'HLEID S HLRESLT="0^1^"_$G(^HL(771.7,1,0)) G EXIT
"RTN","HLMA",45,0)
 N HLRESLT1,HLRESLTA S (HLRESLTA,HLRESLT1)=""
"RTN","HLMA",46,0)
 I "GL"'[$E(HLARYTYP) S HLRESLT="0^4^"_$G(^HL(771.7,4,0)) G EXIT
"RTN","HLMA",47,0)
 I $L($G(HLP("SECURITY")))>40 S HLRESLT="0^6^"_$G(^HL(771.7,6,0)) G EXIT
"RTN","HLMA",48,0)
 I $L($G(HLP("CONTPTR")))>180 S HLRESLT="0^11^"_$G(^HL(771.7,11,0)) G EXIT
"RTN","HLMA",49,0)
 I $D(HLL("LINKS")) D  G:$G(HLRESLT)]"" EXIT
"RTN","HLMA",50,0)
 . N I,HLPNAM,HLPIEN,HLLNAM,HLLIEN
"RTN","HLMA",51,0)
 . S I=0
"RTN","HLMA",52,0)
 . F  S I=$O(HLL("LINKS",I)) Q:'I  D  Q:$G(HLRESLT)]""
"RTN","HLMA",53,0)
 . . S HLPNAM=$P(HLL("LINKS",I),U)
"RTN","HLMA",54,0)
 . . S HLPIEN=+$O(^ORD(101,"B",HLPNAM,0))
"RTN","HLMA",55,0)
 . . I $P($G(^ORD(101,HLPIEN,0)),U,4)'="S" S HLRESLT="0^15^Invalid Subscriber Protocol in HLL('LINKS'): "_HLL("LINKS",I) Q
"RTN","HLMA",56,0)
 . . S HLLNAM=$P(HLL("LINKS",I),U,2)
"RTN","HLMA",57,0)
 . . S HLLIEN=+$O(^HLCS(870,"B",HLLNAM,0))
"RTN","HLMA",58,0)
 . . I '$D(^HLCS(870,HLLIEN,0)) S HLRESLT="0^15^Invalid HL Node in HLL('LINKS'): "_HLL("LINKS",I) Q
"RTN","HLMA",59,0)
 ;Extract data from Protocol file
"RTN","HLMA",60,0)
 D EVENT^HLUTIL1(HLEID,"15,20,771",.HLN)
"RTN","HLMA",61,0)
 S HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15))
"RTN","HLMA",62,0)
 S HLP("GROUTINE")=$G(HLN(771)) K HLN I HLP("GROUTINE")']"",'HLFORMAT S HLRESLT="0^3^"_$G(^HL(771.7,3,0)) G EXIT
"RTN","HLMA",63,0)
 ;Create message ID and Message Text IEN if Message Text IEN not
"RTN","HLMA",64,0)
 ;previously created ('$G(HLMTIEN))
"RTN","HLMA",65,0)
 I '$G(HLMTIEN) D CREATE^HLTF(.HLMID,.HLMTIEN,.HLDT,.HLDT1)
"RTN","HLMA",66,0)
 ;Get message ID if Message Text IEN already created
"RTN","HLMA",67,0)
 I '$G(HLMID) D
"RTN","HLMA",68,0)
 .S HLDT=$G(^HL(772,HLMTIEN,0)),HLMID=$P(HLDT,"^",6),HLDT=+HLDT
"RTN","HLMA",69,0)
 .S HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLMA",70,0)
 S HLMIDAR=0,HLRESLT=HLMID,HLP("DT")=HLDT,HLP("DTM")=HLDT1
"RTN","HLMA",71,0)
 ;Execute entry action for event driver protocol
"RTN","HLMA",72,0)
 I HLENROU]"" X HLENROU
"RTN","HLMA",73,0)
 ;Invoke transaction processor
"RTN","HLMA",74,0)
 K HLDT,HLDT1,HLENROU
"RTN","HLMA",75,0)
 D GENERATE^HLTP(HLMID,HLMTIEN,HLEID,HLARYTYP,HLFORMAT,.HLRESLT1,.HLP)
"RTN","HLMA",76,0)
 ;HLMIDAR is array of message IDs, only set for broadcast messages
"RTN","HLMA",77,0)
 I HLMIDAR K HLMIDAR("N") M HLRESLT=HLMIDAR
"RTN","HLMA",78,0)
 S HLRESLT=HLRESLT_"^"_HLRESLT1
"RTN","HLMA",79,0)
 ;Execute exit action for event driver protocol
"RTN","HLMA",80,0)
 I HLEXROU]"" X HLEXROU
"RTN","HLMA",81,0)
EXIT ;Update status if Message Text file entry has been created
"RTN","HLMA",82,0)
 K HLTCP
"RTN","HLMA",83,0)
 I $D(HLMTIEN) D STATUS^HLTF0(HLMTIEN,$S($P(HLRESLT,"^",2):4,1:3),$S($P(HLRESLT,"^",2):$P(HLRESLT,"^",2),1:""),$S($P(HLRESLT,"^",2):$P(HLRESLT,"^",3),1:""))
"RTN","HLMA",84,0)
 K HLDT,HLDT1,HLMID,HLRESLT1,HLENROU,HLEXROU
"RTN","HLMA",85,0)
 Q
"RTN","HLMA",86,0)
DIRECT(HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLMTIENO,HLP) ;
"RTN","HLMA",87,0)
 ;Entry point to generate an immediate message, must be TCP Logical Link
"RTN","HLMA",88,0)
 ;Input:
"RTN","HLMA",89,0)
 ;  The same as GENERATE,with one additional subscript to the HLP input array:
"RTN","HLMA",90,0)
 ; 
"RTN","HLMA",91,0)
 ;  HLP("OPEN TIMEOUT") (optional, pass by reference) a number between 
"RTN","HLMA",92,0)
 ;    1 and 120 that specifies how many seconds the DIRECT CONNECT should
"RTN","HLMA",93,0)
 ;    try to open a connection before failing.  It is killed upon completion.
"RTN","HLMA",94,0)
 ; 
"RTN","HLMA",95,0)
 N HLTCP,HLTCPO,HLPRIO,HLSAN,HLN,HLMIDAR,HLMTIENR,ZMID,HLDIRECT
"RTN","HLMA",96,0)
 S HLRESLT=""
"RTN","HLMA",97,0)
 ;HLMTIENO=ien passed in, batch message
"RTN","HLMA",98,0)
 S HLMTIEN=$G(HLMTIENO)
"RTN","HLMA",99,0)
 I $G(HLP("OPEN TIMEOUT")),((HLP("OPEN TIMEOUT")\1)'=+HLP("OPEN TIMEOUT"))!HLP("OPEN TIMEOUT")>120 Q "0^4^INVALID OPEN TIMEOUT PARAMETER"
"RTN","HLMA",100,0)
 I $G(HLP("OPEN TIMEOUT")) D
"RTN","HLMA",101,0)
 .S HLDIRECT("OPEN TIMEOUT")=HLP("OPEN TIMEOUT")
"RTN","HLMA",102,0)
 .K HLP("OPEN TIMEOUT")
"RTN","HLMA",103,0)
 K HL,HLMTIENO
"RTN","HLMA",104,0)
 D INIT^HLFNC2(HLEID,.HL)
"RTN","HLMA",105,0)
 I $G(HL) S HLRESLT="0^"_HL Q
"RTN","HLMA",106,0)
 S HLPRIO="I" D CONT
"RTN","HLMA",107,0)
 ;HLMTIENO=original msg. ien in file 772, HLMTIENR=response ien set in HLMA2
"RTN","HLMA",108,0)
 S HLMTIENO=HLMTIEN,HLMTIEN=$G(HLMTIENR)
"RTN","HLMA",109,0)
 ;Set special HL variables
"RTN","HLMA",110,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLMA",111,0)
 Q
"RTN","HLMA",112,0)
 ;
"RTN","HLMA",113,0)
CLOSE(LOGLINK) ;close connection that was open in tag DIRECT
"RTN","HLMA",114,0)
 Q
"RTN","HLMA",115,0)
PING ;ping another VAMC to test Link
"RTN","HLMA",116,0)
 ;set HLQUIET =1 to skip writes
"RTN","HLMA",117,0)
 ;look for HLTPUT to get turnaround time over network.
"RTN","HLMA",118,0)
 N DA,DIC,HLDP,HLDPNM,HLDPDM,HLCSOUT,HLDBSIZE,HLDREAD,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL,HLPARAM
"RTN","HLMA",119,0)
 N HCS,HCSCMD,HLCS,HCSDAT,HCSER,HCSEXIT,HCSTRACE,HLDT1,HLDRETR,HLRETRA,HLDBACK,HLDWAIT,HLTCPCS,INPUT,OUTPUT,POP,X,Y,HLX1,HLX2
"RTN","HLMA",120,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA",121,0)
 S HLCS="",HCSTRACE="C: ",POP=1,INPUT="INPUT",OUTPUT="OUTPUT"
"RTN","HLMA",122,0)
 S DIC="^HLCS(870,",DIC(0)="QEAMZ"
"RTN","HLMA",123,0)
 D ^DIC Q:Y<0
"RTN","HLMA",124,0)
 S HLDP=+Y,HLDPNM=Y(0,0),HLDPDM=$P($$PARAM^HLCS2,U,2)
"RTN","HLMA",125,0)
 ;I $P($G(^HLCS(870,HLDP,400)),U)="" W !,"Missing IP Address" Q
"RTN","HLMA",126,0)
 D SETUP^HLCSAC G:HLCS PINGQ
"RTN","HLMA",127,0)
 ;PING header=MSH^PING^domain^PING^logical link^datetime
"RTN","HLMA",128,0)
 S INPUT(1)="MSH^PING^"_HLDPDM_"^PING^"_HLDPNM_"^"_$$HTE^XLFDT($H)
"RTN","HLMA",129,0)
 D OPEN^HLCSAC
"RTN","HLMA",130,0)
 I HLCS D DNS G:HLCS PINGQ
"RTN","HLMA",131,0)
 D
"RTN","HLMA",132,0)
 . N $ETRAP,$ESTACK S $ETRAP="D PINGERR^HLMA"
"RTN","HLMA",133,0)
 . ;non-standard HL7 header; start block,header,end block
"RTN","HLMA",134,0)
 . S HLX1=$H
"RTN","HLMA",135,0)
 . W $C(11)_INPUT(1)_$C(28)_$C(13),! ;HL*1.6*115, restored ! char
"RTN","HLMA",136,0)
 . ;read response
"RTN","HLMA",137,0)
 . R X:HLDREAD
"RTN","HLMA",138,0)
 . S HLX2=$H
"RTN","HLMA",139,0)
 . S X=$P(X,$C(28)),HLCS=$S(X=INPUT(1):"PING worked",X="":"No response",1:"Incorrect response")
"RTN","HLMA",140,0)
 . ;Get roundtrip time
"RTN","HLMA",141,0)
 . K HLTPUT I X]"" S HLTPUT=$$HDIFF^XLFDT(HLX2,HLX1,2)
"RTN","HLMA",142,0)
 D CLOSE^%ZISTCP
"RTN","HLMA",143,0)
PINGQ ;write back status and quit
"RTN","HLMA",144,0)
 I 'HLQUIET W !,HLCS,!
"RTN","HLMA",145,0)
 Q
"RTN","HLMA",146,0)
PINGERR ;process errors from PING
"RTN","HLMA",147,0)
 S $ETRAP="G UNWIND^%ZTER",HLCS="-1^Error"
"RTN","HLMA",148,0)
 ;I $ZE["READ" S HLCS="-1^Error during read"
"RTN","HLMA",149,0)
 ;I $ZE["WRITE" S HLCS="-1^Error during write"
"RTN","HLMA",150,0)
 ; HL*1.6*115, SACC compliance
"RTN","HLMA",151,0)
 I $$EC^%ZOSV["READ" S HLCS="-1^Error during read"
"RTN","HLMA",152,0)
 I $$EC^%ZOSV["WRITE" S HLCS="-1^Error during write"
"RTN","HLMA",153,0)
 G UNWIND^%ZTER
"RTN","HLMA",154,0)
DNS ;
"RTN","HLMA",155,0)
 ;openfail-try DNS lookup-Link must contain point to Domain Name
"RTN","HLMA",156,0)
 S POP=$G(POP)
"RTN","HLMA",157,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA",158,0)
 I 'HLQUIET W !,"Calling DNS"
"RTN","HLMA",159,0)
 N HLDOM,HLIP S HLCS=""
"RTN","HLMA",160,0)
 S HLDOM=$P(^HLCS(870,HLDP,0),U,7)
"RTN","HLMA",161,0)
 I 'HLDOM,'HLQUIET W !,"Domain Unknown" Q
"RTN","HLMA",162,0)
 I HLDOM S HLDOM=$P(^DIC(4.2,HLDOM,0),U)
"RTN","HLMA",163,0)
 I HLDOM]"" D  Q:'POP
"RTN","HLMA",164,0)
 . I HLDOM["VA.GOV"&(HLDOM'[".MED.") S HLDOM=$P(HLDOM,".VA.GOV")_".MED.VA.GOV"
"RTN","HLMA",165,0)
 . I HLTCPORT=5000 S HLDOM="HL7."_HLDOM
"RTN","HLMA",166,0)
 . I HLTCPORT=5500 S HLDOM="MPI."_HLDOM
"RTN","HLMA",167,0)
 . I 'HLQUIET W !,"Domain, "_HLDOM
"RTN","HLMA",168,0)
 . I 'HLQUIET W !,"Port: ",HLTCPORT
"RTN","HLMA",169,0)
 . S HLIP=$$ADDRESS^XLFNSLK(HLDOM)
"RTN","HLMA",170,0)
 . I HLIP]"",'HLQUIET W !,"DNS Returned: ",HLIP
"RTN","HLMA",171,0)
 . I HLIP]"" D
"RTN","HLMA",172,0)
 . . ;If more than one IP returned, try each, cache successful open
"RTN","HLMA",173,0)
 . . N HLI,HLJ,HLIP1
"RTN","HLMA",174,0)
 . . F HLJ=1:1:$L(HLIP,",") D  Q:'POP
"RTN","HLMA",175,0)
 . . . S HLIP1=$P(HLIP,",",HLJ)
"RTN","HLMA",176,0)
 . . . F HLI=1:1:HLDRETR W:'HLQUIET !,"Trying ",HLIP1 D CALL^%ZISTCP(HLIP1,HLTCPORT,1) Q:'POP
"RTN","HLMA",177,0)
 . . . I 'POP S $P(^HLCS(870,HLDP,400),U)=HLIP1
"RTN","HLMA",178,0)
 . . . U IO
"RTN","HLMA",179,0)
 I POP S HLCS="-1^DNS Lookup Failed"
"RTN","HLMA1")
0^2^B8748290^B8481428
"RTN","HLMA1",1,0)
HLMA1 ;AISC/SAW-Message Administration Module (Cont'd) ;09/13/2006
"RTN","HLMA1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,91,109,108,133**;Oct 13, 1995;Build 13
"RTN","HLMA1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLMA1",4,0)
GENACK(HLEID,HLMTIENS,HLEIDS,HLARYTYP,HLFORMAT,HLRESLTA,HLMTIENA,HLP) ;
"RTN","HLMA1",5,0)
 ;Entry point to generate an acknowledgement message
"RTN","HLMA1",6,0)
 ;
"RTN","HLMA1",7,0)
 ;This is a subroutine call with parameter passing.  It returns a value
"RTN","HLMA1",8,0)
 ;in the variable HLRESLTA of null if no error occurs, or the following
"RTN","HLMA1",9,0)
 ;two piece value if an error occurs:  error code^error description
"RTN","HLMA1",10,0)
 ;
"RTN","HLMA1",11,0)
 ;Required Input Parameters
"RTN","HLMA1",12,0)
 ;     HLEID = IEN of event driver protocol from the Protocol file
"RTN","HLMA1",13,0)
 ;  HLMTIENS = IEN of entry in Message Text file for subscriber
"RTN","HLMA1",14,0)
 ;               application
"RTN","HLMA1",15,0)
 ;    HLEIDS = IEN of subscriber event from the Protocol file
"RTN","HLMA1",16,0)
 ;  HLARYTYP = Array type.  One of the following codes:
"RTN","HLMA1",17,0)
 ;               LM = local array containing a single message
"RTN","HLMA1",18,0)
 ;               LB = local array containig a batch of messages
"RTN","HLMA1",19,0)
 ;               GM = global array containing a single message
"RTN","HLMA1",20,0)
 ;               GB = global array containing a batch of messages
"RTN","HLMA1",21,0)
 ;  HLFORMAT = Format of array, 1 for pre-formatted in HL7 format,
"RTN","HLMA1",22,0)
 ;               otherwise 0
"RTN","HLMA1",23,0)
 ;NOTE:  The parameter HLRESLTA must be passed by reference
"RTN","HLMA1",24,0)
 ;  HLRESLTA = The variable that will be returned to the calling
"RTN","HLMA1",25,0)
 ;               application as descibed above
"RTN","HLMA1",26,0)
 ;Optional Parameters
"RTN","HLMA1",27,0)
 ;  HLMTIENA = IEN of entry in Message Text file where the
"RTN","HLMA1",28,0)
 ;               acknowledgement message will be stored.  This
"RTN","HLMA1",29,0)
 ;               parameter is only passed for a batch acknowledgment
"RTN","HLMA1",30,0)
 ;  HLP("SECURITY") = A 1 to 40 character string
"RTN","HLMA1",31,0)
 ; HLP("NAMESPACE") = Passed in by application namespace - HL*1.6*91
"RTN","HLMA1",32,0)
 ;
"RTN","HLMA1",33,0)
 ;
"RTN","HLMA1",34,0)
 ;HLRESLTA is to return the results and should not be initially defined
"RTN","HLMA1",35,0)
 N HLRESLT
"RTN","HLMA1",36,0)
 S HLRESLT=""
"RTN","HLMA1",37,0)
 K HLRESLTA
"RTN","HLMA1",38,0)
 ;
"RTN","HLMA1",39,0)
 ;Check for required parameters
"RTN","HLMA1",40,0)
 I $G(HLEIDS)']""!('$G(HLMTIENS))!($G(HLARYTYP)']"")!($G(HLFORMAT)']"") S HLRESLTA="0^7^"_$G(^HL(771.7,7,0))_" at GENACK^HLMA1 entry point" G EXIT
"RTN","HLMA1",41,0)
 I 'HLEIDS S HLEIDS=$O(^ORD(101,"B",HLEIDS,0)) I 'HLEIDS S HLRESLTA="0^1^"_$G(^HL(771.7,1,0)) G EXIT
"RTN","HLMA1",42,0)
 ;Extract data from Protocol file
"RTN","HLMA1",43,0)
 D EVENT^HLUTIL1(HLEIDS,"15,20,772",.HLN)
"RTN","HLMA1",44,0)
 N HLEXROU,HLMIDAR
"RTN","HLMA1",45,0)
 S HLMIDAR=0,HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15))
"RTN","HLMA1",46,0)
 S HLP("GROUTINE")=$G(HLN(772)) K HLN I HLP("GROUTINE")']"",'HLFORMAT S HLRESLTA="0^3^"_$G(^HL(771.7,3,0)) G EXIT
"RTN","HLMA1",47,0)
 I "GL"'[$E($G(HLARYTYP)) S HLRESLTA="0^4^"_$G(^HL(771.7,4,0)) G EXIT
"RTN","HLMA1",48,0)
 I '$D(HLP("SECURITY")) S HLP("SECURITY")=""
"RTN","HLMA1",49,0)
 I $L(HLP("SECURITY"))>40 S HLRESLTA="0^6^"_$G(^HL(771.7,6,0)) G EXIT
"RTN","HLMA1",50,0)
 ;$D(HLTCP) tcp connection will be used
"RTN","HLMA1",51,0)
 I $D(HLTCP) D GENACK^HLTP4 G EXIT
"RTN","HLMA1",52,0)
 ;Create message ID and Message Text IEN if Message Text IEN not
"RTN","HLMA1",53,0)
 ;previously created ('$G(HLMTIENA))
"RTN","HLMA1",54,0)
 I '$G(HLMTIENA) D CREATE^HLTF(.HLMIDA,.HLMTIENA,.HLDTA,.HLDT1A)
"RTN","HLMA1",55,0)
 ;Get message ID if Message Text IEN not already created
"RTN","HLMA1",56,0)
 I '$G(HLMIDA) D
"RTN","HLMA1",57,0)
 .S HLDTA=$G(^HL(772,HLMTIENA,0))
"RTN","HLMA1",58,0)
 .S HLDT1A=$$HLDATE^HLFNC(+HLDTA),HLMIDA=$P(HLDTA,"^",6),HLDTA=+HLDTA
"RTN","HLMA1",59,0)
 S HLRESLTA=HLMIDA,HLP("DTM")=HLDT1A,HLP("DT")=HLDTA,HLP("MTIENS")=HLMTIENS,HLP("EID")=HLEID
"RTN","HLMA1",60,0)
 ;Execute entry action for subscriber protocol
"RTN","HLMA1",61,0)
 I HLENROU]"" X HLENROU
"RTN","HLMA1",62,0)
 ;Invoke transaction processor to generate acknowledgement
"RTN","HLMA1",63,0)
 K HLDTA,HLDT1A,HLEID,HLENROU,HLMTIENS
"RTN","HLMA1",64,0)
 S HLRESLT=""
"RTN","HLMA1",65,0)
 D GENACK^HLTP1(HLMIDA,HLMTIENA,HLEIDS,HLARYTYP,HLFORMAT,.HLRESLT,.HLP)
"RTN","HLMA1",66,0)
 ;HLMIDAR is array of message IDs, only set for broadcast messages
"RTN","HLMA1",67,0)
 I HLMIDAR K HLMIDAR("N") M HLRESLTA=HLMIDAR
"RTN","HLMA1",68,0)
 S HLRESLTA=HLRESLTA_"^"_HLRESLT
"RTN","HLMA1",69,0)
 ;Update status to Awaiting Acknowledgement or Error in Transmission
"RTN","HLMA1",70,0)
 D STATUS^HLTF0(HLMTIENA,$S($P(HLRESLTA,"^",2):4,1:3),$S($P(HLRESLTA,"^",2):$P(HLRESLTA,"^",2),1:""),$S($P(HLRESLTA,"^",2):$P(HLRESLTA,"^",3),1:""))
"RTN","HLMA1",71,0)
 ;Execute exit action for subscriber protocol
"RTN","HLMA1",72,0)
 X:HLEXROU]"" HLEXROU
"RTN","HLMA1",73,0)
EXIT K HLDTA,HLDT1A,HLMIDA,HLENROU,HLEXROU
"RTN","HLMA1",74,0)
 Q
"RTN","HLOAPI")
0^8^B35965894^B35456611
"RTN","HLOAPI",1,0)
HLOAPI ;ALB/CJM-HL7 - Developer API's for sending & receiving messages ;09/13/2006
"RTN","HLOAPI",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,133**;Oct 13, 1995;Build 13
"RTN","HLOAPI",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI",4,0)
 ;
"RTN","HLOAPI",5,0)
NEWMSG(PARMS,HLMSTATE,ERROR) ;
"RTN","HLOAPI",6,0)
 ;Starts a new message.  
"RTN","HLOAPI",7,0)
 ;Input: 
"RTN","HLOAPI",8,0)
 ;   PARMS( *pass by reference*
"RTN","HLOAPI",9,0)
 ;     "COUNTRY")=3 character country code (optional)
"RTN","HLOAPI",10,0)
 ;     "CONTINUATION POINTER" -indicates a fragmented message
"RTN","HLOAPI",11,0)
 ;     "EVENT")=3 character event type (required)
"RTN","HLOAPI",12,0)
 ;     "FIELD SEPARATOR")=field separator (optional, defaults to "|")
"RTN","HLOAPI",13,0)
 ;     "ENCODING CHARACTERS")= 4 HL7 encoding characters (optional,defaults to "^~\&")
"RTN","HLOAPI",14,0)
 ;     "MESSAGE STRUCTURE" - MSH 9, component 3 - a code from the standard HL7 table (optional)
"RTN","HLOAPI",15,0)
 ;     "MESSAGE TYPE")=3 character message type (required)
"RTN","HLOAPI",16,0)
 ;     "PROCESSING MODE" - MSH 11, component 2 - a 1 character code (optional)
"RTN","HLOAPI",17,0)
 ;     "VERSION")=the HL7 Version ID, for example, "2.4" (optional, defaults to 2.4)
"RTN","HLOAPI",18,0)
 ;Output:
"RTN","HLOAPI",19,0)
 ;  Function- returns 1 on success, 0 on failure
"RTN","HLOAPI",20,0)
 ;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",21,0)
 ;  PARMS - left defined when the function returns
"RTN","HLOAPI",22,0)
 ;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",23,0)
 ;
"RTN","HLOAPI",24,0)
 ;
"RTN","HLOAPI",25,0)
 N DATA,I,SYSTEM,SUCCESS
"RTN","HLOAPI",26,0)
 S SUCCESS=0
"RTN","HLOAPI",27,0)
 K ERROR,HLMSTATE
"RTN","HLOAPI",28,0)
 D
"RTN","HLOAPI",29,0)
 .I $L($G(PARMS("PROCESSING MODE"))),$L(PARMS("PROCESSING MODE"))'=1 S ERROR="INVALID PROCESSING MODE" Q
"RTN","HLOAPI",30,0)
 .I $L($G(PARMS("COUNTRY"))),$L(PARMS("COUNTRY"))'=3 S ERROR="INVALID COUNTRY CODE" Q
"RTN","HLOAPI",31,0)
 .I $L($G(PARMS("EVENT")))'=3 S ERROR="INVALID EVENT CODE" Q
"RTN","HLOAPI",32,0)
 .I $L($G(PARMS("MESSAGE TYPE")))'=3 S ERROR="INVALID MESSAGE TYPE" Q
"RTN","HLOAPI",33,0)
 .I $L($G(PARMS("ENCODING CHARACTERS"))),$L(PARMS("ENCODING CHARACTERS"))'=4 S ERROR="INVALID ENCODING CHARACTERS" Q
"RTN","HLOAPI",34,0)
 .I $L($G(PARMS("FIELD SEPARATOR"))),$L(PARMS("FIELD SEPARATOR"))'=1 S ERROR="INVALID FIELD SEPARATOR" Q
"RTN","HLOAPI",35,0)
 .I '$L($G(PARMS("FIELD SEPARATOR"))) S PARMS("FIELD SEPARATOR")="|"
"RTN","HLOAPI",36,0)
 .I '$L($G(PARMS("ENCODING CHARACTERS"))) S PARMS("ENCODING CHARACTERS")="^~\&"
"RTN","HLOAPI",37,0)
 .I $G(PARMS("VERSION"))="" S PARMS("VERSION")="2.4"
"RTN","HLOAPI",38,0)
 .I ($L($G(PARMS("VERSION")))>20) S ERROR="VERSION > 20 CHARACTERS" Q
"RTN","HLOAPI",39,0)
 .F I="MESSAGE TYPE","EVENT","COUNTRY","FIELD SEPARATOR","ENCODING CHARACTERS","VERSION","CONTINUATION POINTER","MESSAGE STRUCTURE","PROCESSING MODE" S HLMSTATE("HDR",I)=$G(PARMS(I))
"RTN","HLOAPI",40,0)
 .S HLMSTATE("BATCH")=0 ;not a batch
"RTN","HLOAPI",41,0)
 .S HLMSTATE("DIRECTION")="OUT"
"RTN","HLOAPI",42,0)
 .S HLMSTATE("IEN")=""
"RTN","HLOAPI",43,0)
 .S HLMSTATE("BODY")="" ;record not yet created
"RTN","HLOAPI",44,0)
 .S HLMSTATE("CURRENT SEGMENT")=0 ;no segments cached
"RTN","HLOAPI",45,0)
 .S HLMSTATE("UNSTORED LINES")=0 ;nothing in cache
"RTN","HLOAPI",46,0)
 .S HLMSTATE("LINE COUNT")=0
"RTN","HLOAPI",47,0)
 .D GETSYS(.HLMSTATE)
"RTN","HLOAPI",48,0)
 .S SUCCESS=1
"RTN","HLOAPI",49,0)
 Q SUCCESS
"RTN","HLOAPI",50,0)
 ;
"RTN","HLOAPI",51,0)
NEWBATCH(PARMS,HLMSTATE,ERROR) ;
"RTN","HLOAPI",52,0)
 ;Starts a new batch message.  
"RTN","HLOAPI",53,0)
 ;Input: 
"RTN","HLOAPI",54,0)
 ;  PARMS( *pass by reference*
"RTN","HLOAPI",55,0)
 ;   "COUNTRY")=3 character country code (optional)
"RTN","HLOAPI",56,0)
 ;   "FIELD SEPARATOR")=field separator (optional, defaults to "|")
"RTN","HLOAPI",57,0)
 ;   "ENCODING CHARACTERS")= 4 HL7 encoding characters (optional,defaults to "^~\&") 
"RTN","HLOAPI",58,0)
 ;   "VERSION")=the HL7 Version ID, for example, "2.4" (optional, defaults to 2.4)
"RTN","HLOAPI",59,0)
 ;Output:
"RTN","HLOAPI",60,0)
 ;  Function - returns 1 on success, 0 on failure
"RTN","HLOAPI",61,0)
 ;  PARMS - left defined when the function returns
"RTN","HLOAPI",62,0)
 ;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",63,0)
 ;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",64,0)
 ;
"RTN","HLOAPI",65,0)
 ;
"RTN","HLOAPI",66,0)
 N DATA,I,SYSTEM,SUCCESS
"RTN","HLOAPI",67,0)
 S SUCCESS=0
"RTN","HLOAPI",68,0)
 K ERROR,HLMSTATE
"RTN","HLOAPI",69,0)
 D
"RTN","HLOAPI",70,0)
 .I $L($G(PARMS("COUNTRY"))),$L(PARMS("COUNTRY"))'=3 S ERROR="INVALID COUNTRY CODE" Q
"RTN","HLOAPI",71,0)
 .I $L($G(PARMS("ENCODING CHARACTERS"))),$L(PARMS("ENCODING CHARACTERS"))'=4 S ERROR="INVALID ENCODING CHARACTERS" Q
"RTN","HLOAPI",72,0)
 .I $L($G(PARMS("FIELD SEPARATOR"))),$L(PARMS("FIELD SEPARATOR"))'=1 S ERROR="INVALID FIELD SEPARATOR" Q
"RTN","HLOAPI",73,0)
 .I '$L($G(PARMS("FIELD SEPARATOR"))) S PARMS("FIELD SEPARATOR")="|"
"RTN","HLOAPI",74,0)
 .I '$L($G(PARMS("ENCODING CHARACTERS"))) S PARMS("ENCODING CHARACTERS")="^~\&"
"RTN","HLOAPI",75,0)
 .I $G(PARMS("VERSION"))="" S PARMS("VERSION")="2.4"
"RTN","HLOAPI",76,0)
 .I ($L(PARMS("VERSION"))>20) S ERROR="VERSION > 20 CHARACTERS" Q
"RTN","HLOAPI",77,0)
 .F I="COUNTRY","FIELD SEPARATOR","ENCODING CHARACTERS","VERSION" S HLMSTATE("HDR",I)=$G(PARMS(I))
"RTN","HLOAPI",78,0)
 .S HLMSTATE("IEN")=""
"RTN","HLOAPI",79,0)
 .S HLMSTATE("BODY")="" ;msg not yet stored
"RTN","HLOAPI",80,0)
 .S HLMSTATE("BATCH")=1
"RTN","HLOAPI",81,0)
 .S HLMSTATE("DIRECTION")="OUT"
"RTN","HLOAPI",82,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0 ;no messages in batch
"RTN","HLOAPI",83,0)
 .S HLMSTATE("CURRENT SEGMENT")=0 ;no segments in cache
"RTN","HLOAPI",84,0)
 .S HLMSTATE("UNSTORED LINES")=0 ;nothing in cache
"RTN","HLOAPI",85,0)
 .S HLMSTATE("LINE COUNT")=0 ;no lines within message stored
"RTN","HLOAPI",86,0)
 .D GETSYS(.HLMSTATE)
"RTN","HLOAPI",87,0)
 .S SUCCESS=1
"RTN","HLOAPI",88,0)
 Q SUCCESS
"RTN","HLOAPI",89,0)
 ;
"RTN","HLOAPI",90,0)
SET(SEG,VALUE,FIELD,COMP,SUBCOMP,REP) ;
"RTN","HLOAPI",91,0)
 ;Sets a value to the array SEG(), used for building segments.
"RTN","HLOAPI",92,0)
 ;Input:
"RTN","HLOAPI",93,0)
 ; SEG - (required, pass by reference) - this is the array where the segment is being built.
"RTN","HLOAPI",94,0)
 ; VALUE - the individual value to be set into the segment
"RTN","HLOAPI",95,0)
 ; FIELD - the sequence # of the field (optional, defaults to 0)
"RTN","HLOAPI",96,0)
 ;     *NOTE: FIELD=0 is used to denote the segment type.
"RTN","HLOAPI",97,0)
 ; COMP - the # of the component (optional, defaults to 1)
"RTN","HLOAPI",98,0)
 ; SUBCOMP - the # of the subcomponent (optional, defaults to 1)
"RTN","HLOAPI",99,0)
 ; REP - the occurrence# (optional, defaults to 1)  For a non-repeating field, the occurrence # need not be provided, because it would be 1.
"RTN","HLOAPI",100,0)
 ;Output: 
"RTN","HLOAPI",101,0)
 ;  SEG array
"RTN","HLOAPI",102,0)
 ;
"RTN","HLOAPI",103,0)
 ;  Example:
"RTN","HLOAPI",104,0)
 ;    D SET(.SEG,"MSA",0) creates an MSA segment 
"RTN","HLOAPI",105,0)
 ;    D SET(.SEG,"AE",1) will place the value into the array position
"RTN","HLOAPI",106,0)
 ;    reserved for the 1st field,1st occurence,1st comp,1st subcomp
"RTN","HLOAPI",107,0)
 ;
"RTN","HLOAPI",108,0)
 ;Implementation Note - This format is used for the segment array built by calls to SET: SEGMENT(<SEQ #>,<occurrence #>,<component #>,<subcomponent #>)=<subcomponent value> 
"RTN","HLOAPI",109,0)
 ;
"RTN","HLOAPI",110,0)
 S:'$G(FIELD) FIELD=0
"RTN","HLOAPI",111,0)
 S:'$G(COMP) COMP=1
"RTN","HLOAPI",112,0)
 S:'$G(SUBCOMP) SUBCOMP=1
"RTN","HLOAPI",113,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI",114,0)
 S SEG(FIELD,REP,COMP,SUBCOMP)=$G(VALUE)
"RTN","HLOAPI",115,0)
 Q
"RTN","HLOAPI",116,0)
 ;
"RTN","HLOAPI",117,0)
ADDSEG(HLMSTATE,SEG,ERROR) ;Adds a segment to the message.
"RTN","HLOAPI",118,0)
 ;Input:
"RTN","HLOAPI",119,0)
 ;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",120,0)
 ;  SEG() - (pass by reference, required) Contains the data.  It must be built by calls to SET prior to calling $$ADDSEG.
"RTN","HLOAPI",121,0)
 ;
"RTN","HLOAPI",122,0)
 ;Note#1:  The message control segments, including the MSH and BHS segments, are added automatically.
"RTN","HLOAPI",123,0)
 ;Note#2:  The 0th field must be a 3 character segment type
"RTN","HLOAPI",124,0)
 ;Note#3: ***SEG is killed upon successfully adding the segment***
"RTN","HLOAPI",125,0)
 ;
"RTN","HLOAPI",126,0)
 ;Output:
"RTN","HLOAPI",127,0)
 ;   HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.
"RTN","HLOAPI",128,0)
 ;  FUNCTION - returns 1 on success, 0 on failure
"RTN","HLOAPI",129,0)
 ;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",130,0)
 ;
"RTN","HLOAPI",131,0)
 ;
"RTN","HLOAPI",132,0)
 K ERROR
"RTN","HLOAPI",133,0)
 N TOARY,TYPE
"RTN","HLOAPI",134,0)
 ;
"RTN","HLOAPI",135,0)
 S TYPE=$G(SEG(0,1,1,1)) ;segment type
"RTN","HLOAPI",136,0)
 ;
"RTN","HLOAPI",137,0)
 ;if a 'generic' app ack MSA was built, add it as the first segment before this one
"RTN","HLOAPI",138,0)
 I $D(HLMSTATE("MSA")) D
"RTN","HLOAPI",139,0)
 .I TYPE'="MSA" S TOARY(1)=HLMSTATE("MSA") D ADDSEG^HLOMSG(.HLMSTATE,.TOARY) K TOARY
"RTN","HLOAPI",140,0)
 .K HLMSTATE("MSA")
"RTN","HLOAPI",141,0)
 ;
"RTN","HLOAPI",142,0)
 I ($L(TYPE)'=3) S ERROR="INVALID SEGMENT TYPE" Q 0
"RTN","HLOAPI",143,0)
 I (TYPE="MSH")!(TYPE="BHS")!(TYPE="BTS")!(TYPE="FHS")!(TYPE="FTS") S ERROR="INVALID SEGMENT TYPE" Q 0
"RTN","HLOAPI",144,0)
 I HLMSTATE("BATCH"),'HLMSTATE("BATCH","CURRENT MESSAGE") S ERROR="NO MESSAGES IN BATCH, SO SEGMENTS NOT ALLOWED" Q 0
"RTN","HLOAPI",145,0)
 I $$BUILDSEG^HLOPBLD(.HLMSTATE,.SEG,.TOARY,.ERROR) D ADDSEG^HLOMSG(.HLMSTATE,.TOARY) K SEG Q 1
"RTN","HLOAPI",146,0)
 Q 0
"RTN","HLOAPI",147,0)
 ;
"RTN","HLOAPI",148,0)
ADDMSG(HLMSTATE,PARMS,ERROR) ;
"RTN","HLOAPI",149,0)
 ;Begins a new message in the batch.
"RTN","HLOAPI",150,0)
 ;Input:
"RTN","HLOAPI",151,0)
 ;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",152,0)
 ;  PARMS( *pass by reference*
"RTN","HLOAPI",153,0)
 ;    "EVENT")=3 character event type (required)
"RTN","HLOAPI",154,0)
 ;    "MESSAGE TYPE")=3 character message type (required)
"RTN","HLOAPI",155,0)
 ;
"RTN","HLOAPI",156,0)
 ;Output:
"RTN","HLOAPI",157,0)
 ;   FUNCTION - returns 1 on success, 0 on failure
"RTN","HLOAPI",158,0)
 ;   HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.
"RTN","HLOAPI",159,0)
 ;   PARMS - left defined when this function returns
"RTN","HLOAPI",160,0)
 ;   ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",161,0)
 ;
"RTN","HLOAPI",162,0)
 N I
"RTN","HLOAPI",163,0)
 K ERROR
"RTN","HLOAPI",164,0)
 ;if a 'generic' app ack MSA was built, add it as the first segment before this one
"RTN","HLOAPI",165,0)
 I $D(HLMSTATE("MSA")) D
"RTN","HLOAPI",166,0)
 .I TYPE'="MSA" N TOARY M TOARY=HLMSTATE("MSA") D ADDSEG^HLOMSG(.HLMSTATE,.TOARY) K TOARY
"RTN","HLOAPI",167,0)
 .K HLMSTATE("MSA")
"RTN","HLOAPI",168,0)
 I $L($G(PARMS("EVENT")))'=3 S ERROR="EVENT TYPE INVALID" Q 0
"RTN","HLOAPI",169,0)
 I $L($G(PARMS("MESSAGE TYPE")))'=3 S ERROR="MESSAGE TYPE INVALID" Q 0
"RTN","HLOAPI",170,0)
 D ADDMSG^HLOMSG(.HLMSTATE,.PARMS)
"RTN","HLOAPI",171,0)
 Q 1
"RTN","HLOAPI",172,0)
 ;
"RTN","HLOAPI",173,0)
GETSYS(HLMSTATE) ;
"RTN","HLOAPI",174,0)
 N SYS,SUB
"RTN","HLOAPI",175,0)
 D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOAPI",176,0)
 F SUB="DOMAIN","STATION","PROCESSING ID","MAXSTRING","ERROR PURGE","NORMAL PURGE","PORT" S HLMSTATE("SYSTEM",SUB)=SYS(SUB)
"RTN","HLOAPI",177,0)
 S HLMSTATE("SYSTEM","BUFFER")=SYS("USER BUFFER")
"RTN","HLOAPI",178,0)
 Q
"RTN","HLOAPI",179,0)
 ;
"RTN","HLOAPI",180,0)
MOVEMSG(HLMSTATE,ARY) ;
"RTN","HLOAPI",181,0)
 ;If a message was built in the 'old' way, and resides in an array, this  routine will move it into file 777 (HL7 Message Body)
"RTN","HLOAPI",182,0)
 ;Input:
"RTN","HLOAPI",183,0)
 ;  HLMSTATE (pass by reference) the array created by calling $$NEWMSG or $$NEWBATCH
"RTN","HLOAPI",184,0)
 ;  ARY - is the name of the array, local or global, where the message was built, used to reference the array by indirection.
"RTN","HLOAPI",185,0)
 ;
"RTN","HLOAPI",186,0)
 N I S I=0
"RTN","HLOAPI",187,0)
 F  S I=$O(@ARY@(I)) Q:'I  D
"RTN","HLOAPI",188,0)
 .N SEG,J,J2
"RTN","HLOAPI",189,0)
 .S J=0,J2=1
"RTN","HLOAPI",190,0)
 .S SEG(J2)=@ARY@(I)
"RTN","HLOAPI",191,0)
 .F  S J=$O(@ARY@(I,J)) Q:'J  S J2=J2+1,SEG(J2)=@ARY@(I,J)
"RTN","HLOAPI",192,0)
 .I 'HLMSTATE("BATCH") D
"RTN","HLOAPI",193,0)
 ..D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOAPI",194,0)
 .E  D
"RTN","HLOAPI",195,0)
 ..I $E(SEG(1),1,3)="MSH" D
"RTN","HLOAPI",196,0)
 ...D SPLITHDR^HLOSRVR1(.SEG)
"RTN","HLOAPI",197,0)
 ...D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOAPI",198,0)
 ..E  D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOAPI",199,0)
 ;
"RTN","HLOAPI",200,0)
 ;signal SENDACK^HLOAPI2 that the application built its own msg
"RTN","HLOAPI",201,0)
 K HLMSTATE("MSA")
"RTN","HLOAPI",202,0)
 Q
"RTN","HLOAPI2")
0^9^B37578775^B36169512
"RTN","HLOAPI2",1,0)
HLOAPI2 ;ALB/CJM-HL7 - Developer API's for sending application acks ;09/13/2006
"RTN","HLOAPI2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131,133**;Oct 13, 1995;Build 13
"RTN","HLOAPI2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI2",4,0)
 ;
"RTN","HLOAPI2",5,0)
ACK(HLMSTATE,PARMS,ACK,ERROR) ;Default behavior is to return a general
"RTN","HLOAPI2",6,0)
 ;application ack. The application may optionally specify the message
"RTN","HLOAPI2",7,0)
 ;type and event or call $$ADDSEG^HLOAPI to add segments.
"RTN","HLOAPI2",8,0)
 ;A generic MSA segment (components 1-3) is added automatically IF the
"RTN","HLOAPI2",9,0)
 ;application doesn't call $$ADDSEG^HLOAPI to add an MSA segment as the
"RTN","HLOAPI2",10,0)
 ;FIRST segment following the header.
"RTN","HLOAPI2",11,0)
 ;$$SENDACK must be called when the ack is completed. The return
"RTN","HLOAPI2",12,0)
 ;destination is determined automatically from the original message
"RTN","HLOAPI2",13,0)
 ;
"RTN","HLOAPI2",14,0)
 ;This API should NOT be called for batch messages, use $$BATCHACK instead.
"RTN","HLOAPI2",15,0)
 ;Input:
"RTN","HLOAPI2",16,0)
 ;  HLMSTATE (pass by reference, required) the array obtained by calling $$STARTMSG^HLOPRS when parsing the original message 
"RTN","HLOAPI2",17,0)
 ;  PARMS (pass by reference) These subscripts may be defined:
"RTN","HLOAPI2",18,0)
 ;    "ACK CODE" (required) MSA1[ {AA,AE,AR}
"RTN","HLOAPI2",19,0)
 ;    "ERROR MESSAGE" - MSA3, should be used only if AE or AR
"RTN","HLOAPI2",20,0)
 ;    "ACCEPT ACK RESPONSE" - the <tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI2",21,0)
 ;    "ACCEPT ACK TYPE" - {AL,NE} (optional, defaults to AL)
"RTN","HLOAPI2",22,0)
 ;    "CONTINUATION POINTER" (optional)indicates a fragmented message
"RTN","HLOAPI2",23,0)
 ;    "COUNTRY" - the 3 character country code (optional)
"RTN","HLOAPI2",24,0)
 ;    "EVENT" - the 3 character event type (optional, defaults to the event code of the original message)
"RTN","HLOAPI2",25,0)
 ;     "ENCODING CHARACTERS" - the four HL7 encoding characters (optional,defaults to "^~\&"
"RTN","HLOAPI2",26,0)
 ;    "FAILURE RESPONSE" (optional) the <tag>^<routine> that the sending application routine should execute if the transmission of the message fails, i.e., the message can not be sent or a requested commit ack is not received.
"RTN","HLOAPI2",27,0)
 ;    "FIELD SEPARATOR" - field separator (optional, defaults to "|")
"RTN","HLOAPI2",28,0)
 ;    "MESSAGE TYPE" - if not defined, ACK is used
"RTN","HLOAPI2",29,0)
 ;    "MESSAGE STRUCTURE" (optional)
"RTN","HLOAPI2",30,0)
 ;    "QUEUE" - (optional) An application can name its own private queue (a string under 20 characters,namespaced). The default is the name of the queue of the original message
"RTN","HLOAPI2",31,0)
 ;    "SECURITY" (optional) security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI2",32,0)
 ;    "VERSION" - the HL7 Version ID (optional, defaults to 2.4)
"RTN","HLOAPI2",33,0)
 ;Output:
"RTN","HLOAPI2",34,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI2",35,0)
 ;  PARMS - left undefined when the function returns
"RTN","HLOAPI2",36,0)
 ;  ACK (pass by reference, required) the acknowledgment message being built.
"RTN","HLOAPI2",37,0)
 ;  ERROR (pass by reference) error msg
"RTN","HLOAPI2",38,0)
 N I,SEG,TOLINK,SUCCESS
"RTN","HLOAPI2",39,0)
 S SUCCESS=0,ERROR=""
"RTN","HLOAPI2",40,0)
 ;
"RTN","HLOAPI2",41,0)
 D
"RTN","HLOAPI2",42,0)
 .N PORT
"RTN","HLOAPI2",43,0)
 .I $G(PARMS("ACK CODE"))'="AA",$G(PARMS("ACK CODE"))'="AE",$G(PARMS("ACK CODE"))'="AR" S ERROR="INVALID ACK CODE" Q
"RTN","HLOAPI2",44,0)
 .;
"RTN","HLOAPI2",45,0)
 .I '$G(HLMSTATE("IEN")) S ERROR="ORIGINAL MESSAGE TO ACKNOWLEDGE IS NOT IDENTIFIED" Q
"RTN","HLOAPI2",46,0)
 .I $G(HLMSTATE("BATCH")) S ERROR="BATCH ACKNOWLEDGMENTS MUST USE $$BATCHACK^HLOAPI3" Q
"RTN","HLOAPI2",47,0)
 .;
"RTN","HLOAPI2",48,0)
 .I $G(HLMSTATE("HDR","MESSAGE CONTROL ID"))="" S ERROR="MESSAGE CONTROL ID MUST EXIST TO RETURN AN APPLICATION ACK" Q
"RTN","HLOAPI2",49,0)
 .S PARMS("MESSAGE TYPE")=$G(PARMS("MESSAGE TYPE"),"ACK")
"RTN","HLOAPI2",50,0)
 .S:PARMS("MESSAGE TYPE")="ACK" PARMS("MESSAGE STRUCTURE")="ACK"
"RTN","HLOAPI2",51,0)
 .S PARMS("EVENT")=$G(PARMS("EVENT"),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOAPI2",52,0)
 .I $$NEWMSG^HLOAPI(.PARMS,.ACK)  ;can't fail!
"RTN","HLOAPI2",53,0)
 .;
"RTN","HLOAPI2",54,0)
 .;if the return link can not be determined, the HL Logical Link file has a problem that must be fixed at the site
"RTN","HLOAPI2",55,0)
 .S PORT=$P(HLMSTATE("HDR","SENDING FACILITY",2),":",2)
"RTN","HLOAPI2",56,0)
 .S TOLINK=$$ACKLINK(.HLMSTATE)
"RTN","HLOAPI2",57,0)
 .I TOLINK="" S ERROR="TRANSMISSION LINK FOR APPLICATION ACK CANNOT BE DETERMINED" Q
"RTN","HLOAPI2",58,0)
 .I 'PORT S PORT=$$PORT2^HLOTLNK(TOLINK)
"RTN","HLOAPI2",59,0)
 .;
"RTN","HLOAPI2",60,0)
 .S ACK("HDR","APP ACK TYPE")="NE"
"RTN","HLOAPI2",61,0)
 .S ACK("HDR","ACCEPT ACK TYPE")=$G(PARMS("ACCEPT ACK TYPE"),"AL")
"RTN","HLOAPI2",62,0)
 .S ACK("STATUS","QUEUE")=$G(PARMS("QUEUE"),$G(HLMSTATE("STATUS","QUEUE")))
"RTN","HLOAPI2",63,0)
 .S ACK("STATUS","PORT")=PORT
"RTN","HLOAPI2",64,0)
 .S ACK("HDR","SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI2",65,0)
 .S ACK("HDR","SENDING APPLICATION")=$G(HLMSTATE("HDR","RECEIVING APPLICATION"))
"RTN","HLOAPI2",66,0)
 .S ACK("HDR","RECEIVING APPLICATION")=$G(HLMSTATE("HDR","SENDING APPLICATION"))
"RTN","HLOAPI2",67,0)
 .F I=1:1:3 S ACK("HDR","RECEIVING FACILITY",I)=$G(HLMSTATE("HDR","SENDING FACILITY",I))
"RTN","HLOAPI2",68,0)
 .S ACK("ACK TO","STATUS")=$S(PARMS("ACK CODE")="AA":"SU",1:"AE")
"RTN","HLOAPI2",69,0)
 .S ACK("ACK TO")=$G(HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOAPI2",70,0)
 .S ACK("ACK TO","IEN")=HLMSTATE("IEN")
"RTN","HLOAPI2",71,0)
 .S ACK("STATUS","LINK NAME")=TOLINK
"RTN","HLOAPI2",72,0)
 .S ACK("LINE COUNT")=0
"RTN","HLOAPI2",73,0)
 .S ACK("MSA")="MSA"_ACK("HDR","FIELD SEPARATOR")_PARMS("ACK CODE")_ACK("HDR","FIELD SEPARATOR")_$G(HLMSTATE("HDR","MESSAGE CONTROL ID"))_ACK("HDR","FIELD SEPARATOR")_$G(PARMS("ERROR MESSAGE"))
"RTN","HLOAPI2",74,0)
 .S SUCCESS=1
"RTN","HLOAPI2",75,0)
 K PARMS
"RTN","HLOAPI2",76,0)
 K:'SUCCESS ACK
"RTN","HLOAPI2",77,0)
 Q SUCCESS
"RTN","HLOAPI2",78,0)
 ;
"RTN","HLOAPI2",79,0)
SENDACK(ACK,ERROR) ;This is used to signal that an application acknowledgment is complete.
"RTN","HLOAPI2",80,0)
 ;Input:
"RTN","HLOAPI2",81,0)
 ;  ACK (pass by reference,required) An array that contains the acknowledgment msg
"RTN","HLOAPI2",82,0)
 ;Output:
"RTN","HLOAPI2",83,0)
 ; Function returns 1 on success, 0 on failure
"RTN","HLOAPI2",84,0)
 ; ERROR (pass by reference) error msg
"RTN","HLOAPI2",85,0)
 ;
"RTN","HLOAPI2",86,0)
 N SEG
"RTN","HLOAPI2",87,0)
 ;if the application added its own MSA, then the ACK("MSA") node was killed
"RTN","HLOAPI2",88,0)
 I $D(ACK("MSA")) S SEG(1)=ACK("MSA") D ADDSEG^HLOMSG(.ACK,.SEG)
"RTN","HLOAPI2",89,0)
 ;
"RTN","HLOAPI2",90,0)
 I $$SEND^HLOAPI1(.ACK,.ERROR) Q 1
"RTN","HLOAPI2",91,0)
 Q 0
"RTN","HLOAPI2",92,0)
 ;
"RTN","HLOAPI2",93,0)
ACKLINK(HLMSTATE) ;
"RTN","HLOAPI2",94,0)
 ;Finds the link to return the application ack to.
"RTN","HLOAPI2",95,0)
 N LINK
"RTN","HLOAPI2",96,0)
 S LINK=$$RTRNLNK^HLOAPP($G(HLMSTATE("HDR","RECEIVING APPLICATION")))
"RTN","HLOAPI2",97,0)
 Q:LINK]"" LINK
"RTN","HLOAPI2",98,0)
 S LINK=$$RTRNLNK^HLOTLNK($G(HLMSTATE("HDR","SENDING FACILITY",1)),$G(HLMSTATE("HDR","SENDING FACILITY",2)),$G(HLMSTATE("HDR","SENDING FACILITY",3)))
"RTN","HLOAPI2",99,0)
 Q LINK
"RTN","HLOAPI2",100,0)
 ;
"RTN","HLOAPI2",101,0)
CHKPARMS(HLMSTATE,PARMS,ERROR) ;
"RTN","HLOAPI2",102,0)
 N LEN,SARY,HARY
"RTN","HLOAPI2",103,0)
 ;
"RTN","HLOAPI2",104,0)
 ;shortcut to reference the header sub-array
"RTN","HLOAPI2",105,0)
 S HARY="HLMSTATE(""HDR"")"
"RTN","HLOAPI2",106,0)
 ;
"RTN","HLOAPI2",107,0)
 ;shortcut to reference the status sub-array
"RTN","HLOAPI2",108,0)
 S SARY="HLMSTATE(""STATUS"")"
"RTN","HLOAPI2",109,0)
 ;
"RTN","HLOAPI2",110,0)
 S ERROR=""
"RTN","HLOAPI2",111,0)
 I $G(PARMS("ACCEPT ACK TYPE"))="" S PARMS("ACCEPT ACK TYPE")="AL"
"RTN","HLOAPI2",112,0)
 I $G(PARMS("APP ACK TYPE"))="" S PARMS("APP ACK TYPE")="NE"
"RTN","HLOAPI2",113,0)
 I PARMS("ACCEPT ACK TYPE")'="NE",PARMS("ACCEPT ACK TYPE")'="AL" S ERROR="INVALID ACCEPT ACKNOWLEDGMENT TYPE"
"RTN","HLOAPI2",114,0)
 I PARMS("APP ACK TYPE")'="NE",PARMS("APP ACK TYPE")'="AL" S ERROR="INVALID APPLICATION ACKNOWLEDGMENT TYPE"
"RTN","HLOAPI2",115,0)
 S LEN=$L($G(PARMS("QUEUE")))
"RTN","HLOAPI2",116,0)
 I $G(PARMS("QUEUE"))["^" S ERROR="QUEUE NAME MAY NOT CONTAIN '^'"
"RTN","HLOAPI2",117,0)
 I LEN>20 S ERROR="QUEUE PARAMETER IS MAX 20 LENGTH",PARMS("QUEUE")=$E(PARMS("QUEUE"),1,20)
"RTN","HLOAPI2",118,0)
 I 'LEN S PARMS("QUEUE")="DEFAULT"
"RTN","HLOAPI2",119,0)
 I $G(PARMS("SENDING APPLICATION"))="" D
"RTN","HLOAPI2",120,0)
 .S ERROR="SENDING APPLICATION IS REQUIRED"
"RTN","HLOAPI2",121,0)
 .S PARMS("SENDING APPLICATION")=""
"RTN","HLOAPI2",122,0)
 E  D
"RTN","HLOAPI2",123,0)
 .I '$D(^HLD(779.2,"C",PARMS("SENDING APPLICATION"))) S ERROR="SENDING APPLICATION NOT FOUND IN THE HLO APPLICATION REGISTRY"
"RTN","HLOAPI2",124,0)
 ;
"RTN","HLOAPI2",125,0)
 ;move parameters into HLMSTATE
"RTN","HLOAPI2",126,0)
 S @HARY@("ACCEPT ACK TYPE")=PARMS("ACCEPT ACK TYPE")
"RTN","HLOAPI2",127,0)
 S @HARY@("APP ACK TYPE")=PARMS("APP ACK TYPE")
"RTN","HLOAPI2",128,0)
 S @HARY@("SENDING APPLICATION")=$E(PARMS("SENDING APPLICATION"),1,60)
"RTN","HLOAPI2",129,0)
 S @HARY@("SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI2",130,0)
 S @SARY@("APP ACK RESPONSE")=$G(PARMS("APP ACK RESPONSE"))
"RTN","HLOAPI2",131,0)
 S @SARY@("ACCEPT ACK RESPONSE")=$G(PARMS("ACCEPT ACK RESPONSE"))
"RTN","HLOAPI2",132,0)
 S @SARY@("FAILURE RESPONSE")=$G(PARMS("FAILURE RESPONSE"))
"RTN","HLOAPI2",133,0)
 S @SARY@("QUEUE")=PARMS("QUEUE")
"RTN","HLOAPI2",134,0)
 Q:$L(ERROR) 0
"RTN","HLOAPI2",135,0)
 Q 1
"RTN","HLOAPI2",136,0)
 ;
"RTN","HLOAPI2",137,0)
SETCODE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI2",138,0)
 ;Implements SETCNE and SETCWE
"RTN","HLOAPI2",139,0)
 ;
"RTN","HLOAPI2",140,0)
 N SUB,VAR
"RTN","HLOAPI2",141,0)
 Q:'$G(FIELD)
"RTN","HLOAPI2",142,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI2",143,0)
 I '$G(COMP) D
"RTN","HLOAPI2",144,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI2",145,0)
 E  D
"RTN","HLOAPI2",146,0)
 .S VAR="SUB"
"RTN","HLOAPI2",147,0)
 S @VAR=1,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ID"))
"RTN","HLOAPI2",148,0)
 S @VAR=2,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("TEXT"))
"RTN","HLOAPI2",149,0)
 S @VAR=3,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("SYSTEM"))
"RTN","HLOAPI2",150,0)
 S @VAR=4,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ALTERNATE ID"))
"RTN","HLOAPI2",151,0)
 S @VAR=5,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ALTERNATE TEXT"))
"RTN","HLOAPI2",152,0)
 S @VAR=6,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ALTERNATE SYSTEM"))
"RTN","HLOAPI2",153,0)
 S @VAR=7,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("SYSTEM VERSION"))
"RTN","HLOAPI2",154,0)
 S @VAR=8,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ALTERNATE SYSTEM VERSION"))
"RTN","HLOAPI2",155,0)
 S @VAR=9,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ORIGINAL TEXT"))
"RTN","HLOAPI2",156,0)
 Q
"RTN","HLOAPI3")
0^19^B43853464^B30983602
"RTN","HLOAPI3",1,0)
HLOAPI3 ;ALB/CJM-HL7 - Developer API's for sending application acks ;09/13/2006
"RTN","HLOAPI3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,133**;Oct 13, 1995;Build 13
"RTN","HLOAPI3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI3",4,0)
 ;
"RTN","HLOAPI3",5,0)
BATCHACK(HLMSTATE,PARMS,ACK,ERROR) ;Starts a batch message that is the response to a batch message. Individual acks are placed in the batch by calling $$ADDACK.
"RTN","HLOAPI3",6,0)
 ;$$SENDACK^HLOAPI2 must be called when the batch of acks is complete. The return destination is determined automatically from the original message.
"RTN","HLOAPI3",7,0)
 ;
"RTN","HLOAPI3",8,0)
 ;Input:
"RTN","HLOAPI3",9,0)
 ;  HLMSTATE (pass by reference, required) the array obtained by calling $$STARTMSG^HLOPRS when parsing the original message 
"RTN","HLOAPI3",10,0)
 ;  PARMS (optional, pass by reference) These subscripts may be defined:
"RTN","HLOAPI3",11,0)
 ;    "ACCEPT ACK RESPONSE")=<tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI3",12,0)
 ;    "ACCEPT ACK TYPE") = <AL,NE> (optional, defaults to AL)
"RTN","HLOAPI3",13,0)
 ;    "COUNTRY") - a 3 character country code from the HL7 standard table (optional)
"RTN","HLOAPI3",14,0)
 ;     "ENCODING CHARACTERS" - the 4 HL7 encoding characters (optional,defaults to "^~\&"
"RTN","HLOAPI3",15,0)
 ;    "FAILURE RESPONSE" (optional) the <tag>^<routine> that the sending application routine should execute if the transmission of the message fails, i.e., the message can not be sent or a requested commit ack is not received.
"RTN","HLOAPI3",16,0)
 ;     "FIELD SEPARATOR" - the field separator (optional, defaults to "|")
"RTN","HLOAPI3",17,0)
 ;     "QUEUE" (optional) An application can name a private queue (a string under 20 characters, namespaced). The default is the name of the queue of the original message
"RTN","HLOAPI3",18,0)
 ;     "SECURITY" - security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI3",19,0)
 ;    "VERSION" - the HL7 Version ID (optional, defaults to 2.4)
"RTN","HLOAPI3",20,0)
 ;Output:
"RTN","HLOAPI3",21,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",22,0)
 ;  PARMS - left undefined upon completion
"RTN","HLOAPI3",23,0)
 ;  ACK (pass by reference, required) the batch acknowledgment message being built.
"RTN","HLOAPI3",24,0)
 ;  ERROR (pass by reference) error message
"RTN","HLOAPI3",25,0)
 N I,TOLINK,SUCCESS
"RTN","HLOAPI3",26,0)
 S SUCCESS=0
"RTN","HLOAPI3",27,0)
 ;
"RTN","HLOAPI3",28,0)
 D
"RTN","HLOAPI3",29,0)
 .N PORT
"RTN","HLOAPI3",30,0)
 .I '$G(HLMSTATE("IEN")) S ERROR="ORIGINAL MESSAGE TO ACKNOWLEDGMENT IS NOT IDENTIFIED" Q
"RTN","HLOAPI3",31,0)
 .;if the return link can not be determined, the HL Logical Link file has a problem
"RTN","HLOAPI3",32,0)
 .S TOLINK=$$ACKLINK^HLOAPI2(.HLMSTATE)
"RTN","HLOAPI3",33,0)
 .I TOLINK="" S ERROR="TRANSMISSION LINK FOR APPLICATION ACK CANNOT BE DETERMINED" Q
"RTN","HLOAPI3",34,0)
 .S PORT=$P(HLMSTATE("HDR","SENDING FACILITY",2),":",2)
"RTN","HLOAPI3",35,0)
 .I 'PORT S PORT=$$PORT2^HLOTLNK(TOLINK)
"RTN","HLOAPI3",36,0)
 .;
"RTN","HLOAPI3",37,0)
 .I $$NEWBATCH^HLOAPI(.PARMS,.ACK)  ;can't fail!
"RTN","HLOAPI3",38,0)
 .S ACK("STATUS","QUEUE")=$G(PARMS("QUEUE"),$G(HLMSTATE("STATUS","QUEUE")))
"RTN","HLOAPI3",39,0)
 .S ACK("STATUS","PORT")=PORT
"RTN","HLOAPI3",40,0)
 .S ACK("HDR","SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI3",41,0)
 .S ACK("HDR","SENDING APPLICATION")=$G(HLMSTATE("HDR","RECEIVING APPLICATION"))
"RTN","HLOAPI3",42,0)
 .S ACK("HDR","RECEIVING APPLICATION")=$G(HLMSTATE("HDR","SENDING APPLICATION"))
"RTN","HLOAPI3",43,0)
 .F I=1:1:3 S ACK("HDR","RECEIVING FACILITY",I)=$G(HLMSTATE("HDR","SENDING FACILITY",I))
"RTN","HLOAPI3",44,0)
 .S ACK("HDR","APP ACK TYPE")="NE"
"RTN","HLOAPI3",45,0)
 .S ACK("HDR","ACCEPT ACK TYPE")=$G(PARMS("ACCEPT ACK TYPE"),"AL")
"RTN","HLOAPI3",46,0)
 .S ACK("ACK TO")=$G(HLMSTATE("HDR","BATCH CONTROL ID"))
"RTN","HLOAPI3",47,0)
 .S ACK("ACK TO","IEN")=HLMSTATE("IEN")
"RTN","HLOAPI3",48,0)
 .S ACK("ACK TO","BODY")=$G(HLMSTATE("BODY"))
"RTN","HLOAPI3",49,0)
 .S ACK("STATUS","LINK NAME")=TOLINK
"RTN","HLOAPI3",50,0)
 .S ACK("LINE COUNT")=0
"RTN","HLOAPI3",51,0)
 .S SUCCESS=1
"RTN","HLOAPI3",52,0)
 K PARMS
"RTN","HLOAPI3",53,0)
 Q SUCCESS
"RTN","HLOAPI3",54,0)
 ;
"RTN","HLOAPI3",55,0)
ADDACK(ACK,PARMS,ERROR) ;This API adds an application acknowledgment to a batch
"RTN","HLOAPI3",56,0)
 ;of acknowledgments that was started by calling $$BATCHACK.
"RTN","HLOAPI3",57,0)
 ;The Default behavior is to return a general application ack.
"RTN","HLOAPI3",58,0)
 ;The application may optionally specify the message
"RTN","HLOAPI3",59,0)
 ;type and event and/or call $$ADDSEG^HLOAPI to add segments.
"RTN","HLOAPI3",60,0)
 ;A generic MSA segment (components 1-3) will be added automatically
"RTN","HLOAPI3",61,0)
 ;if the application doesn't call $$ADDSEG^HLOAPI to add an MSA segment
"RTN","HLOAPI3",62,0)
 ;as the FIRST segment following the MSH segment.
"RTN","HLOAPI3",63,0)
 ;$$SENDACK^HLOAPI2 must be called when the batch is complete.
"RTN","HLOAPI3",64,0)
 ;
"RTN","HLOAPI3",65,0)
 ;Input:
"RTN","HLOAPI3",66,0)
 ;  ACK (pass by reference,required) the batch of acks that is being built 
"RTN","HLOAPI3",67,0)
 ;  PARMS (pass by reference) These subscripts may be defined:
"RTN","HLOAPI3",68,0)
 ;    "ACK CODE" (required) MSA1[ {AA,AE,AR}
"RTN","HLOAPI3",69,0)
 ;    "ERROR MESSAGE" (optional) MSA3, should be used only if AE or AR
"RTN","HLOAPI3",70,0)
 ;    "EVENT" - 3 character event type (optional, defaults to the event code of the original message)
"RTN","HLOAPI3",71,0)
 ;    "MESSAGE CONTROL ID" (required) this is the message control id of the original individual message within the batch which is being acknowledged
"RTN","HLOAPI3",72,0)
 ;    "MESSAGE STRUCTURE" (optional)
"RTN","HLOAPI3",73,0)
 ;    "MESSAGE TYPE" (optional, defaults to ACK)
"RTN","HLOAPI3",74,0)
 ;    "SECURITY" (optional) security information to include in the header segment SEQ 8
"RTN","HLOAPI3",75,0)
 ;Output:
"RTN","HLOAPI3",76,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",77,0)
 ;  ACK (pass by reference, required) The batch, updated with another ack
"RTN","HLOAPI3",78,0)
 ;  PARMS  - left undefined when this function returns
"RTN","HLOAPI3",79,0)
 ;  ERROR (pass by reference) error msg
"RTN","HLOAPI3",80,0)
 ;
"RTN","HLOAPI3",81,0)
 N SUB,SUCCESS
"RTN","HLOAPI3",82,0)
 S SUCCESS=0
"RTN","HLOAPI3",83,0)
 D
"RTN","HLOAPI3",84,0)
 .I $G(PARMS("ACK CODE"))'="AA",$G(PARMS("ACK CODE"))'="AE",$G(PARMS("ACK CODE"))'="AR" S ERROR="INVALID ACK CODE" Q
"RTN","HLOAPI3",85,0)
 .;
"RTN","HLOAPI3",86,0)
 .I $G(PARMS("MESSAGE CONTROL ID"))="" S ERROR="MESSAGE CONTROL ID MUST EXIST TO RETURN AN APPLICATION ACK" Q
"RTN","HLOAPI3",87,0)
 .S SUB=""
"RTN","HLOAPI3",88,0)
 .F  S SUB=$O(^HLB("AE",PARMS("MESSAGE CONTROL ID"),SUB)) Q:SUB=""  I $P(SUB,"^")=ACK("ACK TO","IEN"),$P(SUB,"^",2) S PARMS("ACK TO","IEN")=SUB Q
"RTN","HLOAPI3",89,0)
 .S PARMS("MESSAGE TYPE")=$G(PARMS("MESSAGE TYPE"),"ACK")
"RTN","HLOAPI3",90,0)
 .S:PARMS("MESSAGE TYPE")="ACK" PARMS("MESSAGE STRUCTURE")="ACK"
"RTN","HLOAPI3",91,0)
 .S PARMS("EVENT")=$G(PARMS("EVENT"))
"RTN","HLOAPI3",92,0)
 .I PARMS("EVENT")="",ACK("ACK TO","BODY"),$P(SUB,"^",2) S PARMS("EVENT")=$P($G(^HLA(ACK("ACK TO","BODY"),2,$P(SUB,"^",2),0)),"^",3)
"RTN","HLOAPI3",93,0)
 .S PARMS("ACK TO")=PARMS("MESSAGE CONTROL ID")
"RTN","HLOAPI3",94,0)
 .S PARMS("ACK TO","STATUS")=$S(PARMS("ACK CODE")="AA":"SU",1:"AE")
"RTN","HLOAPI3",95,0)
 .Q:'$$ADDMSG^HLOAPI(.ACK,.PARMS,.ERROR)
"RTN","HLOAPI3",96,0)
 .S ACK("MSA")="MSA|"_PARMS("ACK CODE")_"|"_PARMS("MESSAGE CONTROL ID")_"|"_$G(PARMS("ERROR MESSAGE"))
"RTN","HLOAPI3",97,0)
 .S SUCCESS=1
"RTN","HLOAPI3",98,0)
 K PARMS
"RTN","HLOAPI3",99,0)
 Q SUCCESS
"RTN","HLOAPI3",100,0)
 ;
"RTN","HLOAPI3",101,0)
RESEND(MSGIEN,ERROR) ;
"RTN","HLOAPI3",102,0)
 ;Description: This message will re-transmit an out-going message.  It
"RTN","HLOAPI3",103,0)
 ;does this by making a copy of the message, reusing all the original
"RTN","HLOAPI3",104,0)
 ;parameters. Then the message is placed on the same out-going queue.
"RTN","HLOAPI3",105,0)
 ;
"RTN","HLOAPI3",106,0)
 ;Input:
"RTN","HLOAPI3",107,0)
 ;  MSGIEN - the ien (file #778) of the message that is to be sent
"RTN","HLOAPI3",108,0)
 ;Output:
"RTN","HLOAPI3",109,0)
 ;  Function returns the ien of the message in file 778 on success, 0 on failure
"RTN","HLOAPI3",110,0)
 ;  ERROR (pass by reference, optional) - on failure, will contain an error message
"RTN","HLOAPI3",111,0)
 ;
"RTN","HLOAPI3",112,0)
 N MSG,SUB,HDR
"RTN","HLOAPI3",113,0)
 I '$$STARTMSG^HLOPRS(.MSG,MSGIEN) S ERROR="MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",114,0)
 I MSG("DIRECTION")'="OUT" S ERROR="MESSAGE IS NOT OUTGOING" Q 0
"RTN","HLOAPI3",115,0)
 I MSG("STATUS","LINK NAME")="" S ERROR="LINK NOT DEFINED" Q 0
"RTN","HLOAPI3",116,0)
 F SUB="ID","IEN","DT/TM","ACK BY","STATUS" S MSG(SUB)=""
"RTN","HLOAPI3",117,0)
 F SUB="PURGE" K MSG("STATUS",SUB)
"RTN","HLOAPI3",118,0)
 D GETSYS^HLOAPI(.MSG)
"RTN","HLOAPI3",119,0)
 I $$SAVEMSG^HLOF778(.MSG) D OUTQUE^HLOQUE(MSG("STATUS","LINK NAME"),$G(MSG("STATUS","PORT")),MSG("STATUS","QUEUE"),MSG("IEN")) Q +MSG("IEN")
"RTN","HLOAPI3",120,0)
 Q 0
"RTN","HLOAPI3",121,0)
 ;
"RTN","HLOAPI3",122,0)
SETPURGE(MSGIEN,TIME) ;
"RTN","HLOAPI3",123,0)
 ;Resets the purge date/time.
"RTN","HLOAPI3",124,0)
 ;Input:
"RTN","HLOAPI3",125,0)
 ;   MSGIEN (required) ien of the message, file #778
"RTN","HLOAPI3",126,0)
 ;   TIME (optional) dt/time to set the purge time to, defaults to NOW
"RTN","HLOAPI3",127,0)
 ;Output:
"RTN","HLOAPI3",128,0)
 ;   Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",129,0)
 N NODE,OLDTIME,HLDIR
"RTN","HLOAPI3",130,0)
 Q:'$G(MSGIEN) 0
"RTN","HLOAPI3",131,0)
 S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOAPI3",132,0)
 Q:NODE="" 0
"RTN","HLOAPI3",133,0)
 S OLDTIME=$P(NODE,"^",9)
"RTN","HLOAPI3",134,0)
 S:'$G(TIME) TIME=$$NOW^XLFDT
"RTN","HLOAPI3",135,0)
 S HLDIR=$S($E($P(NODE,"^",4))="I":"IN",1:"OUT")
"RTN","HLOAPI3",136,0)
 K:OLDTIME ^HLB("AD",HLDIR,OLDTIME,MSGIEN)
"RTN","HLOAPI3",137,0)
 S $P(^HLB(MSGIEN,0),"^",9)=TIME
"RTN","HLOAPI3",138,0)
 S ^HLB("AD",HLDIR,TIME,MSGIEN)=""
"RTN","HLOAPI3",139,0)
 Q 1
"RTN","HLOAPI3",140,0)
 ;
"RTN","HLOAPI3",141,0)
REPROC(MSGIEN,ERROR) ;
"RTN","HLOAPI3",142,0)
 ;Description: This message will re-process an incoming message by placing it on the appropriate incoming queue. If successful the message is set to be purged.
"RTN","HLOAPI3",143,0)
 ;
"RTN","HLOAPI3",144,0)
 ;Input:
"RTN","HLOAPI3",145,0)
 ;  MSGIEN - the ien (file #778) of the message that is to be processed
"RTN","HLOAPI3",146,0)
 ;Output:
"RTN","HLOAPI3",147,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",148,0)
 ;  ERROR (pass by reference, optional) - on failure, will contain an error message
"RTN","HLOAPI3",149,0)
 ;
"RTN","HLOAPI3",150,0)
 N MSG,HDR,ACTION,QUEUE,FROM
"RTN","HLOAPI3",151,0)
 ;
"RTN","HLOAPI3",152,0)
 I '$$STARTMSG^HLOPRS(.MSG,MSGIEN) S ERROR="MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",153,0)
 I MSG("DIRECTION")'="IN" S ERROR="MESSAGE IS NOT INCOMING" Q 0
"RTN","HLOAPI3",154,0)
 M HDR=MSG("HDR")
"RTN","HLOAPI3",155,0)
 I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE),$G(MSG("ACK TO"))="" S ERROR="RECEIVING APPLICATION NOT DEFINED"
"RTN","HLOAPI3",156,0)
 ;If this message references an earlier message, get the action specified by the original message
"RTN","HLOAPI3",157,0)
 I $G(MSG("ACK TO"))]"" D
"RTN","HLOAPI3",158,0)
 .N NODE,IEN
"RTN","HLOAPI3",159,0)
 .S IEN=$O(^HLB("B",$P(MSG("ACK TO"),"-"),0))
"RTN","HLOAPI3",160,0)
 .S:IEN NODE=$G(^HLB(IEN,0))
"RTN","HLOAPI3",161,0)
 .I ($P(NODE,"^",11)]"") S ACTION=$P(NODE,"^",10,11),QUEUE=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")
"RTN","HLOAPI3",162,0)
 I ACTION="" S ERROR="ORIGINAL MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",163,0)
 S FROM=$S(MSG("HDR","SENDING FACILITY",2)]"":MSG("HDR","SENDING FACILITY",2),1:MSG("HDR","SENDING FACILITY",1))
"RTN","HLOAPI3",164,0)
 D INQUE^HLOQUE(FROM,QUEUE,MSGIEN,ACTION,1)
"RTN","HLOAPI3",165,0)
 Q 1
"RTN","HLOAPI3",166,0)
 ;
"RTN","HLOAPI3",167,0)
PROCNOW(MSGIEN,PURGE,ERROR) ;
"RTN","HLOAPI3",168,0)
 ;Description: This message will re-process an incoming message immediately.
"RTN","HLOAPI3",169,0)
 ;
"RTN","HLOAPI3",170,0)
 ;Input:
"RTN","HLOAPI3",171,0)
 ;  MSGIEN - the ien (file #778) of the message that is to be processed
"RTN","HLOAPI3",172,0)
 ;Output:
"RTN","HLOAPI3",173,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",174,0)
 ;  PURGE (optional) a date/time to purge the message
"RTN","HLOAPI3",175,0)
 ;  ERROR (pass by reference, optional) - on failure, will contain an error message
"RTN","HLOAPI3",176,0)
 ;
"RTN","HLOAPI3",177,0)
 N MSG,HDR,ACTION,MCODE,HLMSGIEN
"RTN","HLOAPI3",178,0)
 ;
"RTN","HLOAPI3",179,0)
 S ERROR=""
"RTN","HLOAPI3",180,0)
 I '$$STARTMSG^HLOPRS(.MSG,MSGIEN) S ERROR="MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",181,0)
 I MSG("DIRECTION")'="IN" S ERROR="MESSAGE IS NOT INCOMING" Q 0
"RTN","HLOAPI3",182,0)
 M HDR=MSG("HDR")
"RTN","HLOAPI3",183,0)
 I '$$ACTION^HLOAPP(.HDR,.ACTION),'$G(MSG("ACK TO IEN")) S ERROR="RECEIVING APPLICATION NOT DEFINED" Q 0
"RTN","HLOAPI3",184,0)
 ;If this msg is an ack to an earlier message, get the action specified by the original message
"RTN","HLOAPI3",185,0)
 I $G(ACTION)="",$G(MSG("ACK TO IEN")) S ACTION=$P($G(^HLB(+MSG("ACK TO IEN"),0)),"^",10,11) I $P(ACTION,"^",2)="" S ERROR="ORIGINAL MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",186,0)
 D:$G(PURGE)
"RTN","HLOAPI3",187,0)
 .K:MSG("STATUS","PURGE") ^HLB("AD","IN",MSG("STATUS","PURGE"),MSGIEN)
"RTN","HLOAPI3",188,0)
 .S $P(^HLB(MSGIEN,0),"^",9)=PURGE
"RTN","HLOAPI3",189,0)
 .S ^HLB("AD","IN",PURGE,MSGIEN)=""
"RTN","HLOAPI3",190,0)
 .I $G(MSG("ACK TO IEN")),$D(^HLB(MSG("ACK TO IEN"),0)) K ^HLB("AD","OUT",MSG("STATUS","PURGE"),MSG("ACK TO IEN")) S $P(^HLB(MSG("ACK TO IEN"),0),"^",9)=PURGE,^HLB("AD","OUT",PURGE,MSG("ACK TO IEN"))=""
"RTN","HLOAPI3",191,0)
 S HLMSGIEN=MSGIEN
"RTN","HLOAPI3",192,0)
 S $P(^HLB(MSGIEN,0),"^",19)=1
"RTN","HLOAPI3",193,0)
 S MCODE="D "_ACTION
"RTN","HLOAPI3",194,0)
 X MCODE
"RTN","HLOAPI3",195,0)
 Q 1
"RTN","HLOCLNT2")
0^21^B29898713^B30513205
"RTN","HLOCLNT2",1,0)
HLOCLNT2 ;ALB/CJM- Performs message updates for the client - 10/4/94 1pm ;09/13/2006
"RTN","HLOCLNT2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,133**;Oct 13, 1995;Build 13
"RTN","HLOCLNT2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT2",4,0)
 ;
"RTN","HLOCLNT2",5,0)
GETWORK(WORK) ;
"RTN","HLOCLNT2",6,0)
 ;
"RTN","HLOCLNT2",7,0)
 N OLD,DOLLARJ,SUCCESS,NOW
"RTN","HLOCLNT2",8,0)
 S SUCCESS=0
"RTN","HLOCLNT2",9,0)
 S NOW=$$NOW^XLFDT
"RTN","HLOCLNT2",10,0)
 S (OLD,DOLLARJ)=$G(WORK("DOLLARJ"))
"RTN","HLOCLNT2",11,0)
 F  S DOLLARJ=$O(^HLTMP("CLIENT UPDATES",DOLLARJ)) Q:DOLLARJ=""  D  Q:SUCCESS
"RTN","HLOCLNT2",12,0)
 .L +^HLTMP("CLIENT UPDATES",DOLLARJ):0
"RTN","HLOCLNT2",13,0)
 .Q:'$T
"RTN","HLOCLNT2",14,0)
 .N TIME S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,""))
"RTN","HLOCLNT2",15,0)
 .I $$FMDIFF^XLFDT(NOW,TIME,2)<2 L -^HLTMP("CLIENT UPDATES",DOLLARJ) Q
"RTN","HLOCLNT2",16,0)
 .S SUCCESS=1
"RTN","HLOCLNT2",17,0)
 ;
"RTN","HLOCLNT2",18,0)
 I OLD'="",'SUCCESS F  S DOLLARJ=$O(^HLTMP("CLIENT UPDATES",DOLLARJ)) Q:DOLLARJ=""  Q:DOLLARJ>OLD  D  Q:SUCCESS
"RTN","HLOCLNT2",19,0)
 .L +^HLTMP("CLIENT UPDATES",DOLLARJ):0
"RTN","HLOCLNT2",20,0)
 .Q:'$T
"RTN","HLOCLNT2",21,0)
 .N TIME S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,""))
"RTN","HLOCLNT2",22,0)
 .I $$FMDIFF^XLFDT(NOW,TIME,2)<2 L -^HLTMP("CLIENT UPDATES",DOLLARJ) Q
"RTN","HLOCLNT2",23,0)
 .S SUCCESS=1
"RTN","HLOCLNT2",24,0)
 S WORK("DOLLARJ")=DOLLARJ,WORK("NOW")=NOW
"RTN","HLOCLNT2",25,0)
 Q $S($L(WORK("DOLLARJ")):1,1:0)
"RTN","HLOCLNT2",26,0)
 ;
"RTN","HLOCLNT2",27,0)
DOWORK(WORK) ;
"RTN","HLOCLNT2",28,0)
 ;
"RTN","HLOCLNT2",29,0)
 N DOLLARJ,TIME,IEN,PARMS,SYSTEM
"RTN","HLOCLNT2",30,0)
 S TIME=""
"RTN","HLOCLNT2",31,0)
 S DOLLARJ=WORK("DOLLARJ")
"RTN","HLOCLNT2",32,0)
 D SYSPARMS^HLOSITE(.SYSTEM)
"RTN","HLOCLNT2",33,0)
 F  S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME)) Q:TIME=""  Q:$$FMDIFF^XLFDT(WORK("NOW"),TIME,2)<2  D
"RTN","HLOCLNT2",34,0)
 .S IEN=0
"RTN","HLOCLNT2",35,0)
 .F  S IEN=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN)) Q:'IEN  D
"RTN","HLOCLNT2",36,0)
 ..N NODE
"RTN","HLOCLNT2",37,0)
 ..S NODE=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN))
"RTN","HLOCLNT2",38,0)
 ..S PARMS("LINK")=$P(NODE,"^")
"RTN","HLOCLNT2",39,0)
 ..S PARMS("QUEUE")=$P(NODE,"^",2)
"RTN","HLOCLNT2",40,0)
 ..S PARMS("STATUS")=$P(NODE,"^",3)
"RTN","HLOCLNT2",41,0)
 ..S PARMS("PURGE TYPE")=$P(NODE,"^",4)
"RTN","HLOCLNT2",42,0)
 ..S PARMS("ACK TO IEN")=+$P($P(NODE,"^",4),"-",2)
"RTN","HLOCLNT2",43,0)
 ..S PARMS("ACCEPT ACK")=$P(NODE,"^",5)
"RTN","HLOCLNT2",44,0)
 ..S PARMS("RECEIVING APP")=$P(NODE,"^",6)
"RTN","HLOCLNT2",45,0)
 ..S:PARMS("RECEIVING APP")="" PARMS("RECEIVING APP")="UNKNOWN RECEIVING APPLICATION"
"RTN","HLOCLNT2",46,0)
 ..S PARMS("MSA")=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN,"MSA"))
"RTN","HLOCLNT2",47,0)
 ..S PARMS("ACTION")=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN,"ACTION"))
"RTN","HLOCLNT2",48,0)
 ..D UPDATE(IEN,TIME,.PARMS)
"RTN","HLOCLNT2",49,0)
 ..K ^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN)
"RTN","HLOCLNT2",50,0)
 L -^HLTMP("CLIENT UPDATES",DOLLARJ)
"RTN","HLOCLNT2",51,0)
 Q
"RTN","HLOCLNT2",52,0)
 ;
"RTN","HLOCLNT2",53,0)
UPDATE(MSGIEN,TIME,PARMS) ;
"RTN","HLOCLNT2",54,0)
 S:PARMS("STATUS")]"" $P(^HLB(MSGIEN,0),"^",20)=PARMS("STATUS")
"RTN","HLOCLNT2",55,0)
 S:PARMS("STATUS")="SE" ^HLB("ERRORS","SE",PARMS("RECEIVING APP"),TIME,MSGIEN)=""
"RTN","HLOCLNT2",56,0)
 S:PARMS("STATUS")="AE" ^HLB("ERRORS","AE",PARMS("RECEIVING APP"),TIME,MSGIEN_"^")=""
"RTN","HLOCLNT2",57,0)
 S:PARMS("ACCEPT ACK") $P(^HLB(MSGIEN,0),"^",17)=PARMS("ACCEPT ACK")
"RTN","HLOCLNT2",58,0)
 S $P(^HLB(MSGIEN,0),"^",16)=TIME
"RTN","HLOCLNT2",59,0)
 S:PARMS("MSA")]"" ^HLB(MSGIEN,4)=TIME_"^"_PARMS("MSA")
"RTN","HLOCLNT2",60,0)
 I PARMS("PURGE TYPE"),PARMS("ACTION")="" D
"RTN","HLOCLNT2",61,0)
 .;don't set purge if going on the infiler - let infiler do it
"RTN","HLOCLNT2",62,0)
 .N PTIME
"RTN","HLOCLNT2",63,0)
 .S:(PARMS("PURGE TYPE")=2) PTIME=$$FMADD^XLFDT(TIME,SYSTEM("ERROR PURGE")) ;error purge is in days
"RTN","HLOCLNT2",64,0)
 .S:(PARMS("PURGE TYPE")'=2) PTIME=$$FMADD^XLFDT(TIME,,SYSTEM("NORMAL PURGE")) ;normal purge is in hours
"RTN","HLOCLNT2",65,0)
 .S $P(^HLB(MSGIEN,0),"^",9)=PTIME,^HLB("AD","OUT",PTIME,MSGIEN)=""
"RTN","HLOCLNT2",66,0)
 .I PARMS("ACK TO IEN"),$D(^HLB(PARMS("ACK TO IEN"),0)) S $P(^HLB(PARMS("ACK TO IEN"),0),"^",9)=PTIME,^HLB("AD","OUT",PTIME,PARMS("ACK TO IEN"))=""
"RTN","HLOCLNT2",67,0)
 D:PARMS("ACTION")]""
"RTN","HLOCLNT2",68,0)
 .N PURGE
"RTN","HLOCLNT2",69,0)
 .S PURGE=$S(PARMS("PURGE TYPE"):1,1:0)
"RTN","HLOCLNT2",70,0)
 .S:PARMS("ACK TO IEN") PURGE("ACKTOIEN")=PARMS("ACK TO IEN")
"RTN","HLOCLNT2",71,0)
 .D INQUE^HLOQUE(PARMS("LINK"),PARMS("QUEUE"),MSGIEN,PARMS("ACTION"),.PURGE)
"RTN","HLOCLNT2",72,0)
 Q
"RTN","HLOCLNT2",73,0)
 ;
"RTN","HLOCLNT2",74,0)
GETMSG(IEN,MSG) ;
"RTN","HLOCLNT2",75,0)
 ;
"RTN","HLOCLNT2",76,0)
 ;Description: given the message ien=MSGIEN (required), it returns the MSG array containing information about the message, defined below.
"RTN","HLOCLNT2",77,0)
 ;Input:
"RTN","HLOCLNT2",78,0)
 ;  IEN - the ien of the message in file 778
"RTN","HLOCLNT2",79,0)
 ;Output:
"RTN","HLOCLNT2",80,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT2",81,0)
 ;  MSG (pass by reference, required) These are the subscripts returned:
"RTN","HLOCLNT2",82,0)
 ;    "ACCEPT ACK RESPONSE" - if the sending app requested notification of the accept ack, this is the routine to perform
"RTN","HLOCLNT2",83,0)
 ;    "ACKTOIEN" - if this is an app ack to a message not in a batch, this is the ien of the original message
"RTN","HLOCLNT2",84,0)
 ;    "BATCH"  = 1 if this is a batch message, 0  if not
"RTN","HLOCLNT2",85,0)
 ;    "CURRENT MESSAGE" - defined only for batch messages -  a counterused during building and parsing messages to indicate the current message.  It will be set to 0 initially.
"RTN","HLOCLNT2",86,0)
 ;    "BODY" - ptr to file 778 which contains the body of the message.
"RTN","HLOCLNT2",87,0)
 ;    "LINE COUNT" -  a counter used during writing of the
"RTN","HLOCLNT2",88,0)
 ;     messages to indicate the current line. For
"RTN","HLOCLNT2",89,0)
 ;     batch messages where each message within the batch is stored
"RTN","HLOCLNT2",90,0)
 ;     separately, this field indicates the position within the current
"RTN","HLOCLNT2",91,0)
 ;     individual message
"RTN","HLOCLNT2",92,0)
 ;    "HDR" at these lower subscripts:
"RTN","HLOCLNT2",93,0)
 ;       1    - components 1-6
"RTN","HLOCLNT2",94,0)
 ;       2    - components 7-end
"RTN","HLOCLNT2",95,0)
 ;       "ACCEPT ACK TYPE" = "AL" or "NE"
"RTN","HLOCLNT2",96,0)
 ;       "APP ACK TYPE" = "AL" or "NE"
"RTN","HLOCLNT2",97,0)
 ;       "MESSAGE CONTROL ID" - defined if NOT batch
"RTN","HLOCLNT2",98,0)
 ;       "BATCH CONTROL ID" - defined if batch
"RTN","HLOCLNT2",99,0)
 ;
"RTN","HLOCLNT2",100,0)
 ;    "ID" - message id from the header
"RTN","HLOCLNT2",101,0)
 ;    "IEN" - ien, file 778
"RTN","HLOCLNT2",102,0)
 ;
"RTN","HLOCLNT2",103,0)
 K MSG
"RTN","HLOCLNT2",104,0)
 Q:'$G(IEN) 0
"RTN","HLOCLNT2",105,0)
 N NODE,FS,CS,REP,SUBCOMP,ESCAPE
"RTN","HLOCLNT2",106,0)
 S MSG("IEN")=IEN
"RTN","HLOCLNT2",107,0)
 S NODE=$G(^HLB(IEN,0))
"RTN","HLOCLNT2",108,0)
 S MSG("BODY")=$P(NODE,"^",2)
"RTN","HLOCLNT2",109,0)
 S MSG("ID")=$P(NODE,"^")
"RTN","HLOCLNT2",110,0)
 Q:'MSG("BODY") 0
"RTN","HLOCLNT2",111,0)
 S MSG("STATUS","ACCEPTED")=$P(NODE,"^",17)
"RTN","HLOCLNT2",112,0)
 S MSG("DT/TM")=$P(NODE,"^",16)
"RTN","HLOCLNT2",113,0)
 S MSG("STATUS","QUEUE")=$P(NODE,"^",6)
"RTN","HLOCLNT2",114,0)
 I MSG("STATUS","QUEUE")="" S MSG("STATUS","QUEUE")="DEFAULT"
"RTN","HLOCLNT2",115,0)
 S MSG("ACCEPT ACK RESPONSE")=$P(NODE,"^",12,13)
"RTN","HLOCLNT2",116,0)
 I MSG("ACCEPT ACK RESPONSE")="^" S MSG("ACCEPT ACK RESPONSE")=""
"RTN","HLOCLNT2",117,0)
 ;
"RTN","HLOCLNT2",118,0)
 S MSG("BATCH")=+$P($G(^HLA(MSG("BODY"),0)),"^",2)
"RTN","HLOCLNT2",119,0)
 I MSG("BATCH") D
"RTN","HLOCLNT2",120,0)
 .S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOCLNT2",121,0)
 E  D
"RTN","HLOCLNT2",122,0)
 .N ACKTO
"RTN","HLOCLNT2",123,0)
 .S ACKTO=$P(NODE,"^",3)
"RTN","HLOCLNT2",124,0)
 .I ACKTO]"" S ACKTO=$$ACKTOIEN^HLOMSG1(MSG("ID"),ACKTO)
"RTN","HLOCLNT2",125,0)
 .I ACKTO,+ACKTO=ACKTO S MSG("ACK TO IEN")=ACKTO
"RTN","HLOCLNT2",126,0)
 S MSG("LINE COUNT")=0
"RTN","HLOCLNT2",127,0)
 S MSG("HDR",1)=$G(^HLB(IEN,1))
"RTN","HLOCLNT2",128,0)
 S MSG("HDR",2)=$G(^HLB(IEN,2))
"RTN","HLOCLNT2",129,0)
 S FS=$E(MSG("HDR",1),4)
"RTN","HLOCLNT2",130,0)
 S CS=$E(MSG("HDR",1),5)
"RTN","HLOCLNT2",131,0)
 S REP=$E(MSG("HDR",1),6)
"RTN","HLOCLNT2",132,0)
 S ESCAPE=$E(MSG("HDR",1),7)
"RTN","HLOCLNT2",133,0)
 S SUBCOMP=$E(MSG("HDR",1),8)
"RTN","HLOCLNT2",134,0)
 S MSG("HDR","FIELD SEPARATOR")=FS
"RTN","HLOCLNT2",135,0)
 S MSG("HDR","SENDING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(MSG("HDR",1),FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOCLNT2",136,0)
 S MSG("HDR","RECEIVING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(MSG("HDR",1),FS,5),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOCLNT2",137,0)
 I 'MSG("BATCH") D
"RTN","HLOCLNT2",138,0)
 .S MSG("HDR","MESSAGE TYPE")=$P($P(MSG("HDR",2),FS,4),CS)
"RTN","HLOCLNT2",139,0)
 .S MSG("HDR","EVENT")=$P($P(MSG("HDR",2),FS,4),CS,2)
"RTN","HLOCLNT2",140,0)
 .S MSG("HDR","ACCEPT ACK TYPE")=$E($P(MSG("HDR",2),FS,10),1,2)
"RTN","HLOCLNT2",141,0)
 .S MSG("HDR","APP ACK TYPE")=$E($P(MSG("HDR",2),FS,11),1,2)
"RTN","HLOCLNT2",142,0)
 .S MSG("HDR","MESSAGE CONTROL ID")=MSG("ID")
"RTN","HLOCLNT2",143,0)
 E  D
"RTN","HLOCLNT2",144,0)
 .S MSG("HDR","BATCH CONTROL ID")=MSG("ID")
"RTN","HLOCLNT2",145,0)
 .S MSG("HDR","ACCEPT ACK TYPE")=$E($P($P(MSG("HDR",2),FS,4),"ACCEPT ACK TYPE=",2),1,2)
"RTN","HLOCLNT2",146,0)
 .S MSG("HDR","APP ACK TYPE")=$E($P($P(MSG("HDR",2),FS,4),"APP ACK TYPE=",2),1,2)
"RTN","HLOCLNT2",147,0)
 Q 1
"RTN","HLOPRS")
0^17^B30775930^B30060156
"RTN","HLOPRS",1,0)
HLOPRS ;IRMFO-ALB/CJM -RTNs for parsing messages;03/24/2004  14:43 ;09/13/2006
"RTN","HLOPRS",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**118,126,133**;Oct 13, 1995;Build 13
"RTN","HLOPRS",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPRS",4,0)
 ;
"RTN","HLOPRS",5,0)
STARTMSG(MSG,IEN,HDR) ;
"RTN","HLOPRS",6,0)
 ;Description:  This function begins the parsing of the message, parsing
"RTN","HLOPRS",7,0)
 ;the header and returning the individual values in the array HDR().
"RTN","HLOPRS",8,0)
 ;Input: 
"RTN","HLOPRS",9,0)
 ;  IEN - The internal entry number of the message in file 778.
"RTN","HLOPRS",10,0)
 ;Output:
"RTN","HLOPRS",11,0)
 ;  Function returns 1 on success, 0 on failure.  Failure would indicate that the message was not found.
"RTN","HLOPRS",12,0)
 ;  MSG - (pass by reference, required) This array is used by the HL7 package to track the progress of parsing the message.  The application MUST NOT touch it!
"RTN","HLOPRS",13,0)
 ;  HDR (pass by reference, optional)   This array contains the results of parsing the message header.
"RTN","HLOPRS",14,0)
 K MSG,HDR
"RTN","HLOPRS",15,0)
 Q:'$G(IEN) 0
"RTN","HLOPRS",16,0)
 Q:'$$GETMSG^HLOMSG(IEN,.MSG) 0
"RTN","HLOPRS",17,0)
 M HDR=MSG("HDR")
"RTN","HLOPRS",18,0)
 Q:'$$PARSEHDR(.HDR) 0
"RTN","HLOPRS",19,0)
 M MSG("HDR")=HDR
"RTN","HLOPRS",20,0)
 Q 1
"RTN","HLOPRS",21,0)
 ;
"RTN","HLOPRS",22,0)
NEXTSEG(MSG,SEG) ;
"RTN","HLOPRS",23,0)
 ;Description:  Advances parsing to the next segment and returns the parsed values from that segment.
"RTN","HLOPRS",24,0)
 ;Input:
"RTN","HLOPRS",25,0)
 ;  MSG - (pass by reference, required) This array is used by the HL7 package to track the current position in the message.  The application MUST NOT touch it!
"RTN","HLOPRS",26,0)
 ;Output:
"RTN","HLOPRS",27,0)
 ;  Function  returns 1 on success, 0 if there are no more segments in this message.  For batch messages, a return value of 0 does not preclude the possibility that there are additional individual messages within the batch.
"RTN","HLOPRS",28,0)
 ;  MSG - (pass by reference, required)
"RTN","HLOPRS",29,0)
 ;  SEG - (pass by reference, required)  The segment is returned in this array.
"RTN","HLOPRS",30,0)
 ;
"RTN","HLOPRS",31,0)
 N TEMP,CODES
"RTN","HLOPRS",32,0)
 K SEG
"RTN","HLOPRS",33,0)
 I '$$HLNEXT^HLOMSG(.MSG,.TEMP) Q 0
"RTN","HLOPRS",34,0)
 S CODES=MSG("HDR","ENCODING CHARACTERS")
"RTN","HLOPRS",35,0)
 Q $$PARSE^HLOPRS1(MSG("HDR","FIELD SEPARATOR"),$E(CODES,2),$E(CODES,1),$E(CODES,4),$E(CODES,3),.TEMP,.SEG)
"RTN","HLOPRS",36,0)
 ;
"RTN","HLOPRS",37,0)
NEXTMSG(MSG,MSH) ;
"RTN","HLOPRS",38,0)
 ;Description:  Advances to the next message within the batch, with the MSH segment returned.
"RTN","HLOPRS",39,0)
 ;Input:
"RTN","HLOPRS",40,0)
 ; MSG (pass by reference, required) This array is used by the HL7 package to track the current position in the message.  The application MUST NOT touch it!
"RTN","HLOPRS",41,0)
 ;OUTPUT:
"RTN","HLOPRS",42,0)
 ;  Function returns 1 on success, 0 if there are no more messages
"RTN","HLOPRS",43,0)
 ;  MSG - (pass by reference)
"RTN","HLOPRS",44,0)
 ;  MSH - (pass by reference, required) Returns the parsed message header
"RTN","HLOPRS",45,0)
 ;
"RTN","HLOPRS",46,0)
 K MSH
"RTN","HLOPRS",47,0)
 N NODE
"RTN","HLOPRS",48,0)
 Q:'$$NEXTMSG^HLOMSG(.MSG,.MSH) 0
"RTN","HLOPRS",49,0)
 Q:'$$PARSEHDR(.MSH) 0
"RTN","HLOPRS",50,0)
 S MSG("BATCH","CURRENT MESSAGE","EVENT")=MSH("EVENT")
"RTN","HLOPRS",51,0)
 S MSG("BATCH","CURRENT MESSAGE","MESSAGE CONTROL ID")=MSH("MESSAGE CONTROL ID")
"RTN","HLOPRS",52,0)
 S NODE=$G(^HLB(MSG("IEN"),3,MSG("BATCH","CURRENT MESSAGE"),0))
"RTN","HLOPRS",53,0)
 S MSG("BATCH","CURRENT MESSAGE","ACK TO")=$P(NODE,"^",3)
"RTN","HLOPRS",54,0)
 S MSG("BATCH","CURRENT MESSAGE","ACK BY")=$P(NODE,"^",4)
"RTN","HLOPRS",55,0)
 ;
"RTN","HLOPRS",56,0)
 I MSG("BATCH","CURRENT MESSAGE","ACK TO")]"" S MSG("BATCH","CURRENT MESSAGE","ACK TO IEN")=$$ACKTOIEN^HLOMSG1(MSG("MESSAGE CONTROL ID"),MSG("BATCH","CURRENT MESSAGE","ACK TO"))
"RTN","HLOPRS",57,0)
 I MSG("BATCH","CURRENT MESSAGE","ACK BY")]"" S MSG("BATCH","CURRENT MESSAGE","ACK BY IEN")=$$ACKBYIEN^HLOMSG1(MSG("MESSAGE CONTROL ID"),MSG("BATCH","CURRENT MESSAGE","ACK BY"))
"RTN","HLOPRS",58,0)
 ;
"RTN","HLOPRS",59,0)
 Q 1
"RTN","HLOPRS",60,0)
 ;
"RTN","HLOPRS",61,0)
PARSEHDR(HDR) ;
"RTN","HLOPRS",62,0)
 ;Parses the segment (HDR, pass by reference) into the HDR() array using meaningful subscripts.
"RTN","HLOPRS",63,0)
 ;Input:
"RTN","HLOPRS",64,0)
 ;  HDR (pass by reference, required) contains the segment in the format HDR(1),HDR(2), etc..
"RTN","HLOPRS",65,0)
 ;Output:
"RTN","HLOPRS",66,0)
 ;  HDR (pass by reference, required) This array will contain all the individual values.  Also will contain HDR(1) with components 1-6 and HDR(2) with components 1-end
"RTN","HLOPRS",67,0)
 ;  Function - returns 1 if the segment is indeed an MSH or BHS segment, 0 otherwise
"RTN","HLOPRS",68,0)
 ;
"RTN","HLOPRS",69,0)
 N VALUE,FS,CS,REP,SUBCOMP,ESCAPE
"RTN","HLOPRS",70,0)
 S VALUE=$E(HDR(1),1,3)
"RTN","HLOPRS",71,0)
 I VALUE'="MSH",VALUE'="BHS" Q 0
"RTN","HLOPRS",72,0)
 S HDR("SEGMENT TYPE")=VALUE
"RTN","HLOPRS",73,0)
 S FS=$E(HDR(1),4)
"RTN","HLOPRS",74,0)
 Q:FS="" 0
"RTN","HLOPRS",75,0)
 S HDR("ENCODING CHARACTERS")=$P(HDR(1),FS,2)
"RTN","HLOPRS",76,0)
 S CS=$E(HDR("ENCODING CHARACTERS"),1)
"RTN","HLOPRS",77,0)
 S REP=$E(HDR("ENCODING CHARACTERS"),2)
"RTN","HLOPRS",78,0)
 S ESCAPE=$E(HDR("ENCODING CHARACTERS"),3)
"RTN","HLOPRS",79,0)
 S SUBCOMP=$E(HDR("ENCODING CHARACTERS"),4)
"RTN","HLOPRS",80,0)
 Q:REP="" 0
"RTN","HLOPRS",81,0)
 S HDR("FIELD SEPARATOR")=FS
"RTN","HLOPRS",82,0)
 S HDR("COMPONENT SEPARATOR")=CS
"RTN","HLOPRS",83,0)
 S HDR("REPETITION SEPARATOR")=REP
"RTN","HLOPRS",84,0)
 S HDR("ESCAPE CHARACTER")=ESCAPE
"RTN","HLOPRS",85,0)
 S HDR("SUBCOMPONENT SEPARATOR")=SUBCOMP
"RTN","HLOPRS",86,0)
 S HDR("SENDING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(HDR(1),FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",87,0)
 S VALUE=$P(HDR(1),FS,4)
"RTN","HLOPRS",88,0)
 S HDR("SENDING FACILITY",1)=$P(VALUE,CS)
"RTN","HLOPRS",89,0)
 S HDR("SENDING FACILITY",2)=$$DESCAPE^HLOPRS1($P(VALUE,CS,2),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",90,0)
 S HDR("SENDING FACILITY",3)=$P(VALUE,CS,3)
"RTN","HLOPRS",91,0)
 S HDR("RECEIVING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(HDR(1),FS,5),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",92,0)
 S VALUE=$P(HDR(1),FS,6)
"RTN","HLOPRS",93,0)
 S HDR("RECEIVING FACILITY",1)=$P(VALUE,CS)
"RTN","HLOPRS",94,0)
 S HDR("RECEIVING FACILITY",2)=$$DESCAPE^HLOPRS1($P(VALUE,CS,2),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",95,0)
 S HDR("RECEIVING FACILITY",3)=$P(VALUE,CS,3)
"RTN","HLOPRS",96,0)
 S HDR("DT/TM OF MESSAGE")=$$FMDATE^HLFNC($P($P(HDR(2),FS,2),CS))
"RTN","HLOPRS",97,0)
 S HDR("SECURITY")=$$DESCAPE^HLOPRS1($P($P(HDR(2),FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",98,0)
 ;
"RTN","HLOPRS",99,0)
 I HDR("SEGMENT TYPE")="MSH" D
"RTN","HLOPRS",100,0)
 .S VALUE=$P(HDR(2),FS,4)
"RTN","HLOPRS",101,0)
 .S HDR("MESSAGE TYPE")=$P(VALUE,CS)
"RTN","HLOPRS",102,0)
 .S HDR("EVENT")=$P(VALUE,CS,2)
"RTN","HLOPRS",103,0)
 .S HDR("MESSAGE STRUCTURE")=$P(VALUE,CS,3)
"RTN","HLOPRS",104,0)
 .S HDR("MESSAGE CONTROL ID")=$P($P(HDR(2),FS,5),CS)
"RTN","HLOPRS",105,0)
 .S VALUE=$P(HDR(2),FS,6)
"RTN","HLOPRS",106,0)
 .S HDR("PROCESSING ID")=$P(VALUE,CS)
"RTN","HLOPRS",107,0)
 .S HDR("PROCESSING MODE")=$P(VALUE,CS,2)
"RTN","HLOPRS",108,0)
 .S HDR("VERSION")=$$DESCAPE^HLOPRS1($P($P(HDR(2),FS,7),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",109,0)
 .S HDR("CONTINUATION POINTER")=$P($P(HDR(2),FS,9),CS)
"RTN","HLOPRS",110,0)
 .S HDR("ACCEPT ACK TYPE")=$P($P(HDR(2),FS,10),CS)
"RTN","HLOPRS",111,0)
 .S HDR("APP ACK TYPE")=$P($P(HDR(2),FS,11),CS)
"RTN","HLOPRS",112,0)
 .S HDR("COUNTRY")=$P($P(HDR(2),FS,12),CS)
"RTN","HLOPRS",113,0)
 ;
"RTN","HLOPRS",114,0)
 I HDR("SEGMENT TYPE")="BHS" D
"RTN","HLOPRS",115,0)
 .S VALUE=$P(HDR(2),FS,4)
"RTN","HLOPRS",116,0)
 .S HDR("BATCH NAME/ID/TYPE")=$$DESCAPE^HLOPRS1(VALUE,FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",117,0)
 .S HDR("PROCESSING ID")=$E($P(VALUE,"PROCESSING ID=",2),1)
"RTN","HLOPRS",118,0)
 .S HDR("ACCEPT ACK TYPE")=$E($P(VALUE,"ACCEPT ACK TYPE=",2),1,2)
"RTN","HLOPRS",119,0)
 .S HDR("APP ACK TYPE")=$E($P(VALUE,"APP ACK TYPE=",2),1,2)
"RTN","HLOPRS",120,0)
 .S HDR("BATCH COMMENT")=$$DESCAPE^HLOPRS1($P(HDR(2),FS,5),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",121,0)
 .S HDR("BATCH CONTROL ID")=$P($P(HDR(2),FS,6),CS)
"RTN","HLOPRS",122,0)
 .S HDR("REFERENCE BATCH CONTROL ID")=$P($P(HDR(2),FS,7),CS)
"RTN","HLOPRS",123,0)
 .;
"RTN","HLOPRS",124,0)
 Q 1
"RTN","HLOPRS",125,0)
 ;
"RTN","HLOPRS",126,0)
GET(SEG,FIELD,COMP,SUBCOMP,REP) ;
"RTN","HLOPRS",127,0)
 ;This function gets a specified value from a segment that was parsed by
"RTN","HLOPRS",128,0)
 ;$$NEXTSEG. The FIELD,COMP,SUBCOMP,REP parameters are optional - if not
"RTN","HLOPRS",129,0)
 ;specified, they default to 1.
"RTN","HLOPRS",130,0)
 ;  Example:
"RTN","HLOPRS",131,0)
 ;    $$GET^HLOPRS(.SEG,1) will return the value of the first field, first
"RTN","HLOPRS",132,0)
 ;  component, first subcomponent, in the first occurrence of field #1.  
"RTN","HLOPRS",133,0)
 ;Input:
"RTN","HLOPRS",134,0)
 ;SEG - (required, pass by reference) - this is the array where the parsed segment was placed by $$NEXTSEG
"RTN","HLOPRS",135,0)
 ;FIELD - the sequence # of the field (optional, defaults to 1)
"RTN","HLOPRS",136,0)
 ;COMP - the # of the component (optional, defaults to 1)
"RTN","HLOPRS",137,0)
 ;SUBCOMP - the # of the subcomponent (optional, defaults to 1)
"RTN","HLOPRS",138,0)
 ;REP - the occurrence# (optional, defaults to 1)  For a non-repeating field, the occurrence # need not be provided, because it would be 1.
"RTN","HLOPRS",139,0)
 ;Output:
"RTN","HLOPRS",140,0)
 ;  Function returns the requested value on success, "" if not valued.
"RTN","HLOPRS",141,0)
 ;
"RTN","HLOPRS",142,0)
 ;allow the segment type to be obtained via field #0 (shorthand)
"RTN","HLOPRS",143,0)
 I $D(FIELD),$G(FIELD)=0 Q $G(SEG("SEGMENT TYPE"))
"RTN","HLOPRS",144,0)
 S:'$G(FIELD) FIELD=1
"RTN","HLOPRS",145,0)
 ;
"RTN","HLOPRS",146,0)
 ;for MSH or BHS, SEQ#1 is the  field separator
"RTN","HLOPRS",147,0)
 I FIELD=1,$G(SEG("SEGMENT TYPE"))="MSH"!($G(SEG("SEGMENT TYPE"))="BHS"),$G(REP)<2,$G(COMP)<2,$G(SUBCOMP)<2 Q SEG("FIELD SEPARATOR")
"RTN","HLOPRS",148,0)
 I FIELD=1,$G(SEG("SEGMENT TYPE"))="MSH"!($G(SEG("SEGMENT TYPE"))="BHS") Q ""
"RTN","HLOPRS",149,0)
 ;
"RTN","HLOPRS",150,0)
 ;For segments other than MSH or BHS, the first subscript in the SEG array needs to be incremented by 1, because SEG(1,1,1,1) is taken by the segment type, which technically isn't a field. (for convenience,we call it SEQ=0).  
"RTN","HLOPRS",151,0)
 I $G(SEG("SEGMENT TYPE"))'="BHS",$G(SEG("SEGMENT TYPE"))'="MSH" S FIELD=FIELD+1
"RTN","HLOPRS",152,0)
 S:'$G(COMP) COMP=1
"RTN","HLOPRS",153,0)
 S:'$G(SUBCOMP) SUBCOMP=1
"RTN","HLOPRS",154,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS",155,0)
 Q $G(SEG(FIELD,REP,COMP,SUBCOMP))
"RTN","HLOPRS",156,0)
 ;
"RTN","HLOPRS1")
0^18^B19727557^B19358044
"RTN","HLOPRS1",1,0)
HLOPRS1 ;IRMFO-ALB/CJM -RTNs for parsing messages (continued);03/24/2004  14:43 ;09/13/2006
"RTN","HLOPRS1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**118,131,133**;Oct 13, 1995;Build 13
"RTN","HLOPRS1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPRS1",4,0)
 ;
"RTN","HLOPRS1",5,0)
PARSE(FIELD,REP,COMP,SUBCOMP,ESCAPE,SEG,TO) ;
"RTN","HLOPRS1",6,0)
 ;Parses the segment stored in SEG(1),SEG(2),... into TO()
"RTN","HLOPRS1",7,0)
 ;Input:
"RTN","HLOPRS1",8,0)
 ;  FIELD - field separator
"RTN","HLOPRS1",9,0)
 ;  REP - field repetition separator
"RTN","HLOPRS1",10,0)
 ;  COMP - component separator
"RTN","HLOPRS1",11,0)
 ;  SUBCOMP - subcomponent separator
"RTN","HLOPRS1",12,0)
 ;  ESCAPE - escape character
"RTN","HLOPRS1",13,0)
 ;  SEG - (pass by reference) the array holding the unparsed segment.
"RTN","HLOPRS1",14,0)
 ;Output:
"RTN","HLOPRS1",15,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOPRS1",16,0)
 ;  TO - (pass by reference) - the parsed values
"RTN","HLOPRS1",17,0)
 ;  SEG- This input variable is deleted during the processing.  If it is needs to be retained, pass in a copy!
"RTN","HLOPRS1",18,0)
 ;
"RTN","HLOPRS1",19,0)
 N VALUE,CHAR,COUNTS
"RTN","HLOPRS1",20,0)
 K TO
"RTN","HLOPRS1",21,0)
 Q:$L($G(FIELD))'=1 0
"RTN","HLOPRS1",22,0)
 Q:$L($G(REP))'=1 0
"RTN","HLOPRS1",23,0)
 Q:$L($G(COMP))'=1 0
"RTN","HLOPRS1",24,0)
 Q:'$D(SUBCOMP) 0
"RTN","HLOPRS1",25,0)
 Q:'$D(SEG) 0
"RTN","HLOPRS1",26,0)
 S COUNTS("FIELD")=1
"RTN","HLOPRS1",27,0)
 S COUNTS("REP")=1
"RTN","HLOPRS1",28,0)
 S COUNTS("COMP")=1
"RTN","HLOPRS1",29,0)
 S COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",30,0)
 S VALUE=""
"RTN","HLOPRS1",31,0)
 S SEG("LINE")=$O(SEG(0)),SEG("CHAR")=0
"RTN","HLOPRS1",32,0)
 F  S CHAR=$$NEXTCHAR(.SEG) D  Q:'$L(CHAR)
"RTN","HLOPRS1",33,0)
 .I '$L(CHAR) D  Q
"RTN","HLOPRS1",34,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=VALUE
"RTN","HLOPRS1",35,0)
 .E  I CHAR=FIELD D  Q
"RTN","HLOPRS1",36,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",37,0)
 ..S COUNTS("FIELD")=COUNTS("FIELD")+1,COUNTS("REP")=1,COUNTS("COMP")=1,COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",38,0)
 .E  I CHAR=REP D  Q
"RTN","HLOPRS1",39,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",40,0)
 ..S COUNTS("REP")=COUNTS("REP")+1,COUNTS("COMP")=1,COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",41,0)
 .E  I CHAR=COMP D  Q
"RTN","HLOPRS1",42,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",43,0)
 ..S COUNTS("COMP")=COUNTS("COMP")+1,COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",44,0)
 .E  I CHAR=SUBCOMP D  Q
"RTN","HLOPRS1",45,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",46,0)
 ..S COUNTS("SUBCOMP")=COUNTS("SUBCOMP")+1
"RTN","HLOPRS1",47,0)
 .E  S VALUE=VALUE_CHAR
"RTN","HLOPRS1",48,0)
 S TO("SEGMENT TYPE")=$G(TO(1,1,1,1))
"RTN","HLOPRS1",49,0)
 I (TO("SEGMENT TYPE")="BHS")!(TO("SEGMENT TYPE")="MSH") S TO("FIELD SEPARATOR")=FIELD
"RTN","HLOPRS1",50,0)
 Q 1
"RTN","HLOPRS1",51,0)
 ;
"RTN","HLOPRS1",52,0)
NEXTCHAR(SEG) ;
"RTN","HLOPRS1",53,0)
 ;returns the next character in the segment array
"RTN","HLOPRS1",54,0)
 ;
"RTN","HLOPRS1",55,0)
 Q:'SEG("LINE") ""
"RTN","HLOPRS1",56,0)
 N RET
"RTN","HLOPRS1",57,0)
 S SEG("CHAR")=SEG("CHAR")+1
"RTN","HLOPRS1",58,0)
 S RET=$E(SEG(SEG("LINE")),SEG("CHAR"))
"RTN","HLOPRS1",59,0)
 Q:RET]"" RET
"RTN","HLOPRS1",60,0)
 S SEG("LINE")=$O(SEG(SEG("LINE")))
"RTN","HLOPRS1",61,0)
 I SEG("LINE") S SEG("CHAR")=1 Q $E(SEG(SEG("LINE")))
"RTN","HLOPRS1",62,0)
 Q ""
"RTN","HLOPRS1",63,0)
 ;
"RTN","HLOPRS1",64,0)
DESCAPE(VALUE,FIELD,COMP,SUBCOMP,REP,ESCAPE) ;
"RTN","HLOPRS1",65,0)
 ;Replaces the escape sequences with the corresponding encoding character and returns the result as the function value
"RTN","HLOPRS1",66,0)
 ;
"RTN","HLOPRS1",67,0)
 Q:ESCAPE="" VALUE
"RTN","HLOPRS1",68,0)
 N NEWSTRNG,SUBSTRNG,SET,LEN,I,SUBLEN,CHAR
"RTN","HLOPRS1",69,0)
 S (NEWSTRNG,SUBSTRNG,SUBLEN)=""
"RTN","HLOPRS1",70,0)
 S SET="FSTRE"
"RTN","HLOPRS1",71,0)
 S LEN=$L(VALUE)
"RTN","HLOPRS1",72,0)
 F I=1:1:LEN S SUBSTRNG=SUBSTRNG_$E(VALUE,I),SUBLEN=SUBLEN+1 D:SUBLEN=3
"RTN","HLOPRS1",73,0)
 .S CHAR=$E(SUBSTRNG,2)
"RTN","HLOPRS1",74,0)
 .I $E(SUBSTRNG,1)=ESCAPE,$E(SUBSTRNG,3)=ESCAPE,SET[CHAR D
"RTN","HLOPRS1",75,0)
 ..I CHAR="F" S NEWSTRNG=NEWSTRNG_FIELD,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",76,0)
 ..I CHAR="S" S NEWSTRNG=NEWSTRNG_COMP,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",77,0)
 ..I CHAR="T" S NEWSTRNG=NEWSTRNG_SUBCOMP,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",78,0)
 ..I CHAR="R" S NEWSTRNG=NEWSTRNG_REP,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",79,0)
 ..I CHAR="E" S NEWSTRNG=NEWSTRNG_ESCAPE,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",80,0)
 .E  S NEWSTRNG=NEWSTRNG_$E(SUBSTRNG),SUBSTRNG=$E(SUBSTRNG,2,3),SUBLEN=2
"RTN","HLOPRS1",81,0)
 Q NEWSTRNG_SUBSTRNG
"RTN","HLOPRS1",82,0)
 ;
"RTN","HLOPRS1",83,0)
GETCODE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS1",84,0)
 ;Implements GETCNE and GETCWE
"RTN","HLOPRS1",85,0)
 ;
"RTN","HLOPRS1",86,0)
 N SUB,VAR
"RTN","HLOPRS1",87,0)
 Q:'$G(FIELD)
"RTN","HLOPRS1",88,0)
 I '$G(COMP) D
"RTN","HLOPRS1",89,0)
 .S VAR="COMP",SUB=1
"RTN","HLOPRS1",90,0)
 E  D
"RTN","HLOPRS1",91,0)
 .S VAR="SUB"
"RTN","HLOPRS1",92,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS1",93,0)
 S @VAR=1,VALUE("ID")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",94,0)
 S @VAR=2,VALUE("TEXT")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",95,0)
 S @VAR=3,VALUE("SYSTEM")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",96,0)
 S @VAR=4,VALUE("ALTERNATE ID")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",97,0)
 S @VAR=5,VALUE("ALTERNATE TEXT")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",98,0)
 S @VAR=6,VALUE("ALTERNATE SYSTEM")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,RE)
"RTN","HLOPRS1",99,0)
 S @VAR=7,VALUE("SYSTEM VERSION")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",100,0)
 S @VAR=8,VALUE("ALTERNATE SYSTEM VERSION")=$$GET^HLOPRS(.SEG,FIELD,COM)
"RTN","HLOPRS1",101,0)
 S @VAR=9,VALUE("ORIGINAL TEXT")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",102,0)
 Q
"RTN","HLOSRVR1")
0^22^B60360938^B63396021
"RTN","HLOSRVR1",1,0)
HLOSRVR1 ;IRMFO-ALB/CJM - Reading messages, sending acks;03/24/2004  14:43 ;09/13/2006
"RTN","HLOSRVR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,133**;Oct 13, 1995;Build 13
"RTN","HLOSRVR1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR1",4,0)
 ;
"RTN","HLOSRVR1",5,0)
READMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR1",6,0)
 ;This function uses the services provided by the transport layer to receive a message.  The header is parsed. Does these checks:
"RTN","HLOSRVR1",7,0)
 ; 1) Duplicate?
"RTN","HLOSRVR1",8,0)
 ; 2) Wrong Receiving Facility?
"RTN","HLOSRVR1",9,0)
 ; 3) Can the Receiving App accept this message, based message type & event?
"RTN","HLOSRVR1",10,0)
 ; 4) Processing ID must match the receiving system
"RTN","HLOSRVR1",11,0)
 ; 5) Must have an ID
"RTN","HLOSRVR1",12,0)
 ; 6) Header must be BHS or MSH
"RTN","HLOSRVR1",13,0)
 ;
"RTN","HLOSRVR1",14,0)
 ;Output:
"RTN","HLOSRVR1",15,0)
 ;  Function returns 1 if the message was read fully, 0 otherwise
"RTN","HLOSRVR1",16,0)
 ;  HLMSTATE (pass by reference) the message.  It will include the fields for the return ack in HLMSTATE("MSA")
"RTN","HLOSRVR1",17,0)
 ;
"RTN","HLOSRVR1",18,0)
 N ACK,SEG,STORE,I
"RTN","HLOSRVR1",19,0)
 ;
"RTN","HLOSRVR1",20,0)
 S STORE=1
"RTN","HLOSRVR1",21,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.SEG) 0
"RTN","HLOSRVR1",22,0)
 D SPLITHDR(.SEG)
"RTN","HLOSRVR1",23,0)
 ;
"RTN","HLOSRVR1",24,0)
 ;parse the header, stop if unsuccessful because the server cannot know what to do next
"RTN","HLOSRVR1",25,0)
 I '$$PARSEHDR^HLOPRS(.SEG) D  Q 0
"RTN","HLOSRVR1",26,0)
 .S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOSRVR1",27,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",28,0)
 D NEWMSG^HLOSRVR2(.HLCSTATE,.HLMSTATE,.SEG)
"RTN","HLOSRVR1",29,0)
 I HLMSTATE("ID")="" D
"RTN","HLOSRVR1",30,0)
 .S STORE=0
"RTN","HLOSRVR1",31,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" S HLMSTATE("MSA",1)="CE",HLMSTATE("MSA",3)="CONTROL ID MISSING"
"RTN","HLOSRVR1",32,0)
 I STORE,$$DUP(.HLMSTATE) S STORE=0
"RTN","HLOSRVR1",33,0)
 ;
"RTN","HLOSRVR1",34,0)
 ;if the message is not to be stored, just read it and discard the segments
"RTN","HLOSRVR1",35,0)
 I 'STORE D
"RTN","HLOSRVR1",36,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)
"RTN","HLOSRVR1",37,0)
 ;
"RTN","HLOSRVR1",38,0)
 ;else the message is to be stored
"RTN","HLOSRVR1",39,0)
 E  D
"RTN","HLOSRVR1",40,0)
 .N FS
"RTN","HLOSRVR1",41,0)
 .S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOSRVR1",42,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOSRVR1",43,0)
 ..N MSA,SEGTYPE,OLDMSGID,CODE,IEN,NEWMSGID
"RTN","HLOSRVR1",44,0)
 ..S SEGTYPE=$E($E(SEG(1),1,3)_$E($G(SEG(2)),1,2),1,3)
"RTN","HLOSRVR1",45,0)
 ..I SEGTYPE="MSA" D
"RTN","HLOSRVR1",46,0)
 ...S MSA=SEG(1)_$G(SEG(2))_$G(SEG(3))
"RTN","HLOSRVR1",47,0)
 ...S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2)
"RTN","HLOSRVR1",48,0)
 ...I $E(CODE,1)'="A" S SEGTYPE="" Q
"RTN","HLOSRVR1",49,0)
 ...S:$P(OLDMSGID,"-")]"" IEN=$O(^HLB("B",$P(OLDMSGID,"-"),0))
"RTN","HLOSRVR1",50,0)
 ...S:$G(IEN) IEN=IEN_"^"_$P(OLDMSGID,"-",2)
"RTN","HLOSRVR1",51,0)
 ..I 'HLMSTATE("BATCH") D
"RTN","HLOSRVR1",52,0)
 ...D:SEGTYPE="MSA"
"RTN","HLOSRVR1",53,0)
 ....S HLMSTATE("ACK TO")=OLDMSGID
"RTN","HLOSRVR1",54,0)
 ....S HLMSTATE("ACK TO","ACK BY")=HLMSTATE("ID")
"RTN","HLOSRVR1",55,0)
 ....S HLMSTATE("ACK TO","STATUS")=$S(CODE="AA":"SU",1:"AE")
"RTN","HLOSRVR1",56,0)
 ....S:$D(IEN) HLMSTATE("ACK TO","IEN")=IEN
"RTN","HLOSRVR1",57,0)
 ...D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",58,0)
 ..E  D  ;batch
"RTN","HLOSRVR1",59,0)
 ...I SEGTYPE="MSH" D
"RTN","HLOSRVR1",60,0)
 ....D SPLITHDR(.SEG)
"RTN","HLOSRVR1",61,0)
 ....S NEWMSGID=$P(SEG(2),FS,5)
"RTN","HLOSRVR1",62,0)
 ....D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",63,0)
 ...E  D  ;not MSH
"RTN","HLOSRVR1",64,0)
 ....D:SEGTYPE="MSA"
"RTN","HLOSRVR1",65,0)
 .....N SUBIEN S SUBIEN=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOSRVR1",66,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN)=OLDMSGID
"RTN","HLOSRVR1",67,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"ACK BY")=NEWMSGID
"RTN","HLOSRVR1",68,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"STATUS")=$S(CODE="AA":"SU",1:"AE")
"RTN","HLOSRVR1",69,0)
 .....S:$D(IEN) HLMSTATE("BATCH","ACK TO",SUBIEN,"IEN")=IEN
"RTN","HLOSRVR1",70,0)
 ....D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",71,0)
 .I HLMSTATE("UNSTORED LINES"),HLCSTATE("MESSAGE ENDED"),$$SAVEMSG^HLOF778(.HLMSTATE)
"RTN","HLOSRVR1",72,0)
 ;
"RTN","HLOSRVR1",73,0)
 I STORE,'HLCSTATE("MESSAGE ENDED") D
"RTN","HLOSRVR1",74,0)
 .;reading failed before the end, there is no need to keep anything
"RTN","HLOSRVR1",75,0)
 .D:HLMSTATE("IEN") DEL778(HLMSTATE("IEN")) D:HLMSTATE("BODY") DEL777(HLMSTATE("BODY"))
"RTN","HLOSRVR1",76,0)
 .S HLMSTATE("IEN")="",HLMSTATE("BODY")=""
"RTN","HLOSRVR1",77,0)
 E  D:STORE
"RTN","HLOSRVR1",78,0)
 .D CHECKMSG(.HLMSTATE)
"RTN","HLOSRVR1",79,0)
 .D ADDAC(.HLMSTATE) ;so that future duplicates can be detected
"RTN","HLOSRVR1",80,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR1",81,0)
 ;
"RTN","HLOSRVR1",82,0)
 D:'HLCSTATE("MESSAGE ENDED") CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",83,0)
 Q HLCSTATE("MESSAGE ENDED")
"RTN","HLOSRVR1",84,0)
 ;
"RTN","HLOSRVR1",85,0)
ADDAC(HLMSTATE) ;adds the AC xref for the message that was just received
"RTN","HLOSRVR1",86,0)
 ;The AC xref allows duplicates to be detected.
"RTN","HLOSRVR1",87,0)
 ;
"RTN","HLOSRVR1",88,0)
 N FROM
"RTN","HLOSRVR1",89,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",90,0)
 S ^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR1",91,0)
 Q
"RTN","HLOSRVR1",92,0)
 ;
"RTN","HLOSRVR1",93,0)
DUP(HLMSTATE) ;
"RTN","HLOSRVR1",94,0)
 ;Function returns 1 if the message is a duplicate and its ack (if requested) is found, 0 otherwise
"RTN","HLOSRVR1",95,0)
 ;Input:
"RTN","HLOSRVR1",96,0)
 ; HLMSTATE (pass by reference) the message being read
"RTN","HLOSRVR1",97,0)
 ;Output:
"RTN","HLOSRVR1",98,0)
 ;  Function returns 1 if the message is a duplicate, 0 otherwise
"RTN","HLOSRVR1",99,0)
 ;  HLMSTATE (pass by reference) IF the message is a duplicate:
"RTN","HLOSRVR1",100,0)
 ;     returns the prior MSA segment in HLMSTATE("MSA")
"RTN","HLOSRVR1",101,0)
 ;!!!! put back if original mode implemented
"RTN","HLOSRVR1",102,0)
 ;     If original mode returns the ien of the app ack in HLMSTATE("ACK BY IEN")
"RTN","HLOSRVR1",103,0)
 ;
"RTN","HLOSRVR1",104,0)
 N IEN,FROM,DUP
"RTN","HLOSRVR1",105,0)
 S (IEN,DUP)=0
"RTN","HLOSRVR1",106,0)
 ;
"RTN","HLOSRVR1",107,0)
 ;no way to determine!  Bad header will be rejected
"RTN","HLOSRVR1",108,0)
 Q:(HLMSTATE("ID")="") 0
"RTN","HLOSRVR1",109,0)
 ;
"RTN","HLOSRVR1",110,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",111,0)
 F  S IEN=$O(^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),IEN)) Q:'IEN  D  Q:DUP
"RTN","HLOSRVR1",112,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="NE" S DUP=1 Q
"RTN","HLOSRVR1",113,0)
 .;need the MSA to return
"RTN","HLOSRVR1",114,0)
 .D  Q
"RTN","HLOSRVR1",115,0)
 ..N NODE
"RTN","HLOSRVR1",116,0)
 ..S NODE=$P($G(^HLB(IEN,4)),"^",3,10)
"RTN","HLOSRVR1",117,0)
 ..S HLMSTATE("MSA",1)=$P(NODE,"|",2)
"RTN","HLOSRVR1",118,0)
 ..Q:$L(HLMSTATE("MSA",1))'=2
"RTN","HLOSRVR1",119,0)
 ..S HLMSTATE("MSA",2)=$P(NODE,"|",3)
"RTN","HLOSRVR1",120,0)
 ..S HLMSTATE("MSA",3)=$P(NODE,"|",4,10)
"RTN","HLOSRVR1",121,0)
 ..S DUP=1
"RTN","HLOSRVR1",122,0)
 ;
"RTN","HLOSRVR1",123,0)
 Q DUP
"RTN","HLOSRVR1",124,0)
 ;
"RTN","HLOSRVR1",125,0)
CHECKMSG(HLMSTATE) ;
"RTN","HLOSRVR1",126,0)
 ;Checks the header & MSA segment, sets HLMSTATE("STATUS","ACTION") if the message needs to be passed, determines if completion status should be set
"RTN","HLOSRVR1",127,0)
 ;Input:
"RTN","HLOSRVR1",128,0)
 ;  HLMSTATE("HDR") - the parsed header segment
"RTN","HLOSRVR1",129,0)
 ;Output:
"RTN","HLOSRVR1",130,0)
 ;  HLMSTATE("STATUS")="SE" if an error is detected
"RTN","HLOSRVR1",131,0)
 ;  HLMSTATE("STATUS","QUEUE") queue to put the message on
"RTN","HLOSRVR1",132,0)
 ;  HLMSTATE("STATUS","ACTION")  <tag^rtn> that is the processing routine for the receiving application
"RTN","HLOSRVR1",133,0)
 ;  HLMSTATE("MSA") - MSA(1)=accept code to be returned, MSA(3)= error txt
"RTN","HLOSRVR1",134,0)
 ;
"RTN","HLOSRVR1",135,0)
 N WANTACK,PASS,ACTION,QUEUE
"RTN","HLOSRVR1",136,0)
 M HDR=HLMSTATE("HDR")
"RTN","HLOSRVR1",137,0)
 I HDR("ACCEPT ACK TYPE")="NE",'HLMSTATE("ORIGINAL MODE") D
"RTN","HLOSRVR1",138,0)
 .S WANTACK=0
"RTN","HLOSRVR1",139,0)
 E  D
"RTN","HLOSRVR1",140,0)
 .S WANTACK=1
"RTN","HLOSRVR1",141,0)
 I HLMSTATE("ORIGINAL MODE") S HLMSTATE("MSA",1)="AE",HLMSTATE("MSA",3)="THIS INTERFACE DOES NOT IMPLEMENT ORIGINAL MODE APPLICATION ACKOWLEDGMENTS",HLMSTATE("STATUS")="SE" Q
"RTN","HLOSRVR1",142,0)
 I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE),$G(HLMSTATE("ACK TO"))="" S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="SE" Q
"RTN","HLOSRVR1",143,0)
 S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",144,0)
 ;
"RTN","HLOSRVR1",145,0)
 ;If this is an application ack, does the original message exist?
"RTN","HLOSRVR1",146,0)
 I $G(HLMSTATE("ACK TO"))]"" D  Q:HLMSTATE("STATUS")="SE"
"RTN","HLOSRVR1",147,0)
 .N NODE
"RTN","HLOSRVR1",148,0)
 .S:+$G(HLMSTATE("ACK TO","IEN")) NODE=$G(^HLB(+HLMSTATE("ACK TO","IEN"),0))
"RTN","HLOSRVR1",149,0)
 .I $G(NODE)="" S HLMSTATE("STATUS")="SE",HLMSTATE("ACK TO","IEN")=""  S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE TO APPLICATION ACKNOWLEDGMENT NOT FOUND" Q
"RTN","HLOSRVR1",150,0)
 .I ($P(NODE,"^",11)]"") S HLMSTATE("STATUS","ACTION")=$P(NODE,"^",10,11),HLMSTATE("STATUS","QUEUE")=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")
"RTN","HLOSRVR1",151,0)
 ;
"RTN","HLOSRVR1",152,0)
 I HDR("PROCESSING ID")'=HLCSTATE("SYSTEM","PROCESSING ID") S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("STATUS")="SE",HLMSTATE("MSA",3)="SYSTEM PROCESSING ID="_HLCSTATE("SYSTEM","PROCESSING ID") Q
"RTN","HLOSRVR1",153,0)
 ;
"RTN","HLOSRVR1",154,0)
 ;
"RTN","HLOSRVR1",155,0)
 ;wrong receiving facility?  This is hard to check if the sender is not VistA, because the HL7 standard permits different coding systems to be used. This check is only for DNS or station number.
"RTN","HLOSRVR1",156,0)
 S PASS=0
"RTN","HLOSRVR1",157,0)
 D
"RTN","HLOSRVR1",158,0)
 .;if its an ack to an existing message, don't check the receiving facility
"RTN","HLOSRVR1",159,0)
 .I $G(HLMSTATE("ACK TO"))]"" S PASS=1 Q
"RTN","HLOSRVR1",160,0)
 .I HDR("RECEIVING FACILITY",1)=HLCSTATE("SYSTEM","STATION") S PASS=1 Q
"RTN","HLOSRVR1",161,0)
 .I HDR("RECEIVING FACILITY",3)'="DNS" S PASS=1 Q
"RTN","HLOSRVR1",162,0)
 .I HDR("RECEIVING FACILITY",2)="" S PASS=1 Q
"RTN","HLOSRVR1",163,0)
 .I $P(HDR("RECEIVING FACILITY",2),":")[HLCSTATE("SYSTEM","DOMAIN") S PASS=1 Q
"RTN","HLOSRVR1",164,0)
 .I HLCSTATE("SYSTEM","DOMAIN")[$P(HDR("RECEIVING FACILITY",2),":") S PASS=1 Q
"RTN","HLOSRVR1",165,0)
 I 'PASS S HLMSTATE("STATUS")="SE",HLMSTATE("MSA",3)="RECEIVING FACILITY IS "_HLCSTATE("SYSTEM","DOMAIN") S:WANTACK HLMSTATE("MSA",1)="CE"
"RTN","HLOSRVR1",166,0)
 I PASS,WANTACK S HLMSTATE("MSA",1)="CA"
"RTN","HLOSRVR1",167,0)
 Q
"RTN","HLOSRVR1",168,0)
 ;
"RTN","HLOSRVR1",169,0)
DEL777(IEN777) ;delete a record from file 777 where the read did not complete
"RTN","HLOSRVR1",170,0)
 ;
"RTN","HLOSRVR1",171,0)
 K ^HLA(IEN777,0)
"RTN","HLOSRVR1",172,0)
 Q
"RTN","HLOSRVR1",173,0)
DEL778(IEN778) ;delete a record from file 778 where the read did not complete
"RTN","HLOSRVR1",174,0)
 ;
"RTN","HLOSRVR1",175,0)
 K ^HLB(IEN778,0)
"RTN","HLOSRVR1",176,0)
 Q
"RTN","HLOSRVR1",177,0)
 ;
"RTN","HLOSRVR1",178,0)
SPLITHDR(HDR) ;
"RTN","HLOSRVR1",179,0)
 ;splits hdr segment into two lines, first being just components 1-6
"RTN","HLOSRVR1",180,0)
 ;
"RTN","HLOSRVR1",181,0)
 N TEMP,FS
"RTN","HLOSRVR1",182,0)
 D SQUISH(.HDR)
"RTN","HLOSRVR1",183,0)
 S FS=$E($G(HDR(1)),4)
"RTN","HLOSRVR1",184,0)
 S TEMP(1)=$P($G(HDR(1)),FS,1,6)
"RTN","HLOSRVR1",185,0)
 S TEMP(2)=""
"RTN","HLOSRVR1",186,0)
 I $L(TEMP(1))<$L($G(HDR(1))) S TEMP(2)=FS_$P($G(HDR(1)),FS,7,20)
"RTN","HLOSRVR1",187,0)
 S HDR(2)=TEMP(2)_$G(HDR(2))
"RTN","HLOSRVR1",188,0)
 S HDR(1)=TEMP(1)
"RTN","HLOSRVR1",189,0)
 Q
"RTN","HLOSRVR1",190,0)
 ;
"RTN","HLOSRVR1",191,0)
SQUISH(SEG) ;
"RTN","HLOSRVR1",192,0)
 ;reformat the segment array into full lines
"RTN","HLOSRVR1",193,0)
 ;
"RTN","HLOSRVR1",194,0)
 ;nothing to do if less than 2 lines
"RTN","HLOSRVR1",195,0)
 Q:'$O(SEG(1))
"RTN","HLOSRVR1",196,0)
 ;
"RTN","HLOSRVR1",197,0)
 N A,I,J,K,MAX,COUNT,LEN
"RTN","HLOSRVR1",198,0)
 S MAX=$S($G(HLCSTATE("SYSTEM","MAXSTRING"))>256:HLCSTATE("SYSTEM","MAXSTRING"),1:256)
"RTN","HLOSRVR1",199,0)
 S (COUNT,I)=0,J=1
"RTN","HLOSRVR1",200,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOSRVR1",201,0)
 .S LEN=$L(SEG(I))
"RTN","HLOSRVR1",202,0)
 .F K=1:1:LEN D
"RTN","HLOSRVR1",203,0)
 ..S A(J)=$G(A(J))_$E(SEG(I),K)
"RTN","HLOSRVR1",204,0)
 ..S COUNT=COUNT+1
"RTN","HLOSRVR1",205,0)
 ..I (COUNT>(MAX-1)) S COUNT=0,J=J+1
"RTN","HLOSRVR1",206,0)
 K SEG
"RTN","HLOSRVR1",207,0)
 M SEG=A
"RTN","HLOSRVR1",208,0)
 Q
"RTN","HLOSRVR1",209,0)
 ;
"RTN","HLOSRVR1",210,0)
ERROR ;error trap
"RTN","HLOSRVR1",211,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOSRVR1",212,0)
 D END^HLOSRVR
"RTN","HLOSRVR1",213,0)
 ;
"RTN","HLOSRVR1",214,0)
 ;while debugging quit on all errors
"RTN","HLOSRVR1",215,0)
 I $G(^HLTMP("LOG ALL ERRORS")) D ^%ZTER QUIT
"RTN","HLOSRVR1",216,0)
 ;
"RTN","HLOSRVR1",217,0)
 ;don't log these common errors
"RTN","HLOSRVR1",218,0)
 I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D
"RTN","HLOSRVR1",219,0)
 .;
"RTN","HLOSRVR1",220,0)
 E  D
"RTN","HLOSRVR1",221,0)
 .D ^%ZTER
"RTN","HLOSRVR1",222,0)
 ;
"RTN","HLOSRVR1",223,0)
 ;concurrent server connections (multi-listener) should stop execution, only a single server may continue
"RTN","HLOSRVR1",224,0)
 Q:$P($G(HLCSTATE("LINK","SERVER")),"^",2)'="S"
"RTN","HLOSRVR1",225,0)
 ;
"RTN","HLOSRVR1",226,0)
 ;a lot of errors of the same time may indicate an endless loop, so keep a count
"RTN","HLOSRVR1",227,0)
 S ^TMP("HL7 ERRORS",$J,$ECODE)=$G(^TMP("HL7 ERRORS",$J,$ECODE))+1
"RTN","HLOSRVR1",228,0)
 ;
"RTN","HLOSRVR1",229,0)
 I ($G(^TMP("HL7 ERRORS",$J,$ECODE))>100) K ^TMP("HL7 ERRORS",$J) QUIT
"RTN","HLOSRVR1",230,0)
 ;
"RTN","HLOSRVR1",231,0)
 ;resume execution for the single listener
"RTN","HLOSRVR1",232,0)
 D UNWIND^%ZTER
"RTN","HLOSRVR1",233,0)
 Q
"RTN","HLTP")
0^5^B8013244^B7725388
"RTN","HLTP",1,0)
HLTP ;AISC/SAW-Transaction Processor Module ;09/13/2006
"RTN","HLTP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**14,43,133**;Oct 13, 1995;Build 13
"RTN","HLTP",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTP",4,0)
GENERATE(HLMID,HLMTIEN,HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLP) ;Generate an
"RTN","HLTP",5,0)
 ;outgoing message
"RTN","HLTP",6,0)
 ;
"RTN","HLTP",7,0)
 ;This is a subroutine call with parameter passing.  It returns a value
"RTN","HLTP",8,0)
 ;in the variable HLRESLT of null if no error occurs, or the following
"RTN","HLTP",9,0)
 ;two piece value if an error occurs:  error code^error description
"RTN","HLTP",10,0)
 ;
"RTN","HLTP",11,0)
 ;Required Input Parameters
"RTN","HLTP",12,0)
 ;     HLMID = Message ID of message being generated
"RTN","HLTP",13,0)
 ;   HLMTIEN = IEN in Message Text file where message being generated
"RTN","HLTP",14,0)
 ;               will be stored
"RTN","HLTP",15,0)
 ;     HLEID = IEN of event driver protocol in the Protocol file
"RTN","HLTP",16,0)
 ;  HLARYTYP = Array type.  One of the following codes:
"RTN","HLTP",17,0)
 ;               LM = local array containing a single message
"RTN","HLTP",18,0)
 ;               LB = local array containig a batch of messages
"RTN","HLTP",19,0)
 ;               GM = global array containing a single message
"RTN","HLTP",20,0)
 ;               GB = global array containing a batch of messages
"RTN","HLTP",21,0)
 ;  HLFORMAT = Format of array, 1 for pre-formatted in HL7 format,
"RTN","HLTP",22,0)
 ;               otherwise 0
"RTN","HLTP",23,0)
 ;NOTE:  The parameter HLRESLT must be passed by reference
"RTN","HLTP",24,0)
 ;   HLRESLT = The variable that will be returned to the calling
"RTN","HLTP",25,0)
 ;               application as descibed above
"RTN","HLTP",26,0)
 ;Optional Parameters
"RTN","HLTP",27,0)
 ;  HLP("SECURITY") = A 1 to 40 character string
"RTN","HLTP",28,0)
 ;   HLP("CONTPTR") = Continuation pointer, a 1 to 180 character string
"RTN","HLTP",29,0)
 ;  HLP("GROUTINE") = The M code to execute to generate the HL7 message
"RTN","HLTP",30,0)
 ;
"RTN","HLTP",31,0)
 S HLRESLT=""
"RTN","HLTP",32,0)
 ;
"RTN","HLTP",33,0)
 ;Check for required parameters
"RTN","HLTP",34,0)
 I '$G(HLMID)!('$G(HLMTIEN))!('$G(HLEID))!($G(HLARYTYP)']"")!($G(HLFORMAT)']"") S HLRESLT="7^"_$G(^HL(771.7,7,0))_" at GENERATE^HLTP entry point" G EXIT
"RTN","HLTP",35,0)
 ;Extract data from file 101 and store in separate variables
"RTN","HLTP",36,0)
 D EVENT^HLUTIL1(HLEID,770,.HLN) S HLSAN=$P($G(^HL(771,+$P(HLN(770),"^"),0)),"^"),HLQ=""""""
"RTN","HLTP",37,0)
 S HLP("MSGTYPE")=$E(HLARYTYP,2)
"RTN","HLTP",38,0)
 ;Update zero node of Message Text file
"RTN","HLTP",39,0)
 D UPDATE^HLTF0(HLMTIEN,HLMTIEN,"O",HLEID,"",+$P(HLN(770),"^"),HLPRIO,"","",.HLP)
"RTN","HLTP",40,0)
 ;Update status to Being Generated
"RTN","HLTP",41,0)
 D STATUS^HLTF0(HLMTIEN,8)
"RTN","HLTP",42,0)
 ;Check that local/global array exists and store in Message Text file
"RTN","HLTP",43,0)
 ; if pre-compiled
"RTN","HLTP",44,0)
 I HLFORMAT D  I +$G(HLRESLT) G EXIT
"RTN","HLTP",45,0)
 .I $E(HLARYTYP)="G" D  I +$G(HLRESLT) D STATUS^HLTF0(HLMTIEN,4,+HLRESLT) Q
"RTN","HLTP",46,0)
 ..I $O(^TMP("HLS",$J,0))']"" S HLRESLT="8^"_$G(^HL(771.7,8,0)) Q
"RTN","HLTP",47,0)
 ..D MERGE^HLTF1("G",HLMTIEN,"HLS")
"RTN","HLTP",48,0)
 .I $E(HLARYTYP)="L" D  I +$G(HLRESLT) D STATUS^HLTF0(HLMTIEN,4,+HLRESLT) Q
"RTN","HLTP",49,0)
 ..I $O(HLA("HLS",0))']"" S HLRESLT="8^"_$G(^HL(771.7,8,0)) Q
"RTN","HLTP",50,0)
 ..D MERGE^HLTF1("L",HLMTIEN,"HLS")
"RTN","HLTP",51,0)
 ;If array is not pre-compiled, call message generation routine
"RTN","HLTP",52,0)
 I 'HLFORMAT N HLERR D  I $D(HLERR) S HLRESLT="9^"_HLERR D STATUS^HLTF0(HLMTIEN,4,9,HLERR) G EXIT
"RTN","HLTP",53,0)
 .S HLP("GROUTINE")=HLP("GROUTINE")_"("_HLMID_","_HLMTIEN_","_HLQ_HLARYTYP_HLQ_","_HLSAN_","_$P($G(^HL(771.2,$P(HLN(770),"^",3),0)),"^")_","_$P($G(^HL(779.001,$P(HLN(770),"^",4),0)),"^")_","_HLQ_$TR($P(HLN(770),"^",6),"id","ID")_HLQ_")"
"RTN","HLTP",54,0)
 .X HLP("GROUTINE")
"RTN","HLTP",55,0)
 ;**CIRN**
"RTN","HLTP",56,0)
 S ZMID=HLMID ; Save original parent message IEN
"RTN","HLTP",57,0)
 I $D(HLL("LINKS")),HLPRIO'="I" D FWD^HLCS2 K HLL
"RTN","HLTP",58,0)
 ;Invoke communication server module to
"RTN","HLTP",59,0)
 ;send message to subscribers
"RTN","HLTP",60,0)
 ;K HLARYTYP,HLFORMAT,HLN,HLP,HLQ
"RTN","HLTP",61,0)
 D SEND^HLCS(HLMTIEN,HLEID,.HLRESLT)
"RTN","HLTP",62,0)
EXIT Q
"RTN","HLTP1")
0^6^B8076588^B7810520
"RTN","HLTP1",1,0)
HLTP1 ;AISC/SAW-Transaction Processor Module (Cont'd) ;09/13/2006
"RTN","HLTP1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**34,47,91,133**;Oct 13, 1995;Build 13
"RTN","HLTP1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTP1",4,0)
GENACK(HLMIDA,HLMTIENA,HLEIDS,HLARYTYP,HLFORMAT,HLRESLTA,HLP) ;
"RTN","HLTP1",5,0)
 ;Entry point to generate an acknowledgement message
"RTN","HLTP1",6,0)
 ;
"RTN","HLTP1",7,0)
 ;This is a subroutine call with parameter passing.  It returns a value
"RTN","HLTP1",8,0)
 ;in the variable HLRESLTA of null if no error occurs, or the following
"RTN","HLTP1",9,0)
 ;two piece value if an error occurs:  error code^error description
"RTN","HLTP1",10,0)
 ;
"RTN","HLTP1",11,0)
 ;Required Input Parameters
"RTN","HLTP1",12,0)
 ;    HLMIDA = Message ID of aknowledgement message
"RTN","HLTP1",13,0)
 ;  HLMTIENA = IEN of entry in Message Text file where acknowledgement
"RTN","HLTP1",14,0)
 ;               message will be stored
"RTN","HLTP1",15,0)
 ;    HLEIDS = IEN of subscriber protocol from the Protocol file
"RTN","HLTP1",16,0)
 ;  HLARYTYP = Array type.  One of the following codes:
"RTN","HLTP1",17,0)
 ;               LM = local array containing a single message
"RTN","HLTP1",18,0)
 ;               LB = local array containig a batch of messages
"RTN","HLTP1",19,0)
 ;               GM = global array containing a single message
"RTN","HLTP1",20,0)
 ;               GB = global array containing a batch of messages
"RTN","HLTP1",21,0)
 ;  HLFORMAT = Format of array, 1 for pre-formatted in HL7 format,
"RTN","HLTP1",22,0)
 ;               otherwise 0
"RTN","HLTP1",23,0)
 ;NOTE:  The variable HLRESLTA must be passed by reference
"RTN","HLTP1",24,0)
 ;  HLRESLTA = The variable that will be returned to the calling
"RTN","HLTP1",25,0)
 ;               application as descibed above
"RTN","HLTP1",26,0)
 ;Optional Parameters
"RTN","HLTP1",27,0)
 ;  HLP("SECURITY") = A 1 to 40 character string
"RTN","HLTP1",28,0)
 ;  HLP("GROUTINE") = The M code to execute to generate the
"RTN","HLTP1",29,0)
 ;                      acknowledgement message
"RTN","HLTP1",30,0)
 ;     HLP("MSACK") = 1 if this acknowledgment message is being
"RTN","HLTP1",31,0)
 ;                      generated by the Messaging System
"RTN","HLTP1",32,0)
 ; HLP("NAMESPACE") = Passed in by application namespace - HL*1.6*91
"RTN","HLTP1",33,0)
 ;
"RTN","HLTP1",34,0)
 S HLRESLTA=""
"RTN","HLTP1",35,0)
 ;
"RTN","HLTP1",36,0)
 ;Check for required parameters
"RTN","HLTP1",37,0)
 I '$G(HLMIDA)!('$G(HLMTIENA))!('$G(HLEIDS))!($G(HLARYTYP)']"")!($G(HLFORMAT)']"") S HLRESLTA="7^"_$G(^HL(771.7,7,0))_" at GENACK^HLTP1 entry point" G EXIT
"RTN","HLTP1",38,0)
 ;Extract data from file 101 and store in separate variables
"RTN","HLTP1",39,0)
 D EVENT^HLUTIL1(HLEIDS,770,.HLN)
"RTN","HLTP1",40,0)
 S HLSAN=$P($G(^HL(771,+$P(HLN(770),"^",2),0)),"^"),HLQ=""""""
"RTN","HLTP1",41,0)
 S HLP("MSGTYPE")=$E(HLARYTYP,2)
"RTN","HLTP1",42,0)
 ;Update zero node of Message Text file
"RTN","HLTP1",43,0)
 D UPDATE^HLTF0(HLMTIENA,HLP("MTIENS"),"O",HLEIDS,"",$P(HLN(770),"^",2),"",$P($G(^HL(772,HLP("MTIENS"),0)),"^",8),"",.HLP)
"RTN","HLTP1",44,0)
 ;Update status to Being Generated
"RTN","HLTP1",45,0)
 D STATUS^HLTF0(HLMTIENA,8)
"RTN","HLTP1",46,0)
 ;Check that local/global array exists and store in Message Text file
"RTN","HLTP1",47,0)
 ; if pre-compiled
"RTN","HLTP1",48,0)
 I HLFORMAT D  I (+$G(HLRESLTA)) D STATUS^HLTF0(HLMTIENA,4,+HLRESLTA) G EXIT
"RTN","HLTP1",49,0)
 .I $E(HLARYTYP)="G" D
"RTN","HLTP1",50,0)
 ..I $O(^TMP("HLA",$J,0))']"" S HLRESLTA="8^"_$G(^HL(771.7,8,0)) Q
"RTN","HLTP1",51,0)
 ..D MERGE^HLTF1("G",HLMTIENA,"HLA")
"RTN","HLTP1",52,0)
 .I $E(HLARYTYP)="L" D
"RTN","HLTP1",53,0)
 ..I $O(HLA("HLA",0))']"" S HLRESLTA="8^"_$G(^HL(771.7,8,0)) Q
"RTN","HLTP1",54,0)
 ..D MERGE^HLTF1("L",HLMTIENA,"HLA")
"RTN","HLTP1",55,0)
 ;If array is not pre-compiled, call message generation routine
"RTN","HLTP1",56,0)
 I 'HLFORMAT N HLERR D  I $D(HLERR) S HLRESLTA="9^"_HLERR D STATUS^HLTF0(HLMTIENA,4,9,HLERR) G EXIT
"RTN","HLTP1",57,0)
 .S HLP("GROUTINE")=HLP("GROUTINE")_"("_HLMIDA_","_HLMTIENA_","_HLQ_HLARYTYP_HLQ_","_HLSAN_","_$P($G(^HL(771.2,$P(HLN(770),"^",3),0)),"^")_","_$P($G(^HL(779.001,$P(HLN(770),"^",4),0)),"^")_","_HLQ_$TR($P(HLN(770),"^",6),"id","ID")_HLQ_")"
"RTN","HLTP1",58,0)
 .X HLP("GROUTINE")
"RTN","HLTP1",59,0)
 ;Invoke communication server module to send message to subscribers
"RTN","HLTP1",60,0)
 K HLARYTYP,HLFORMAT,HLQ
"RTN","HLTP1",61,0)
 D SENDACK^HLCS(HLMTIENA,HLP("EID"),HLEIDS,.HLRESLTA) ;,$G(HLP("MSACK")))
"RTN","HLTP1",62,0)
EXIT K HLQ,HLSAN
"RTN","HLTP1",63,0)
 Q
"RTN","HLTP3")
0^7^B73884339^B72235579
"RTN","HLTP3",1,0)
HLTP3 ;SFIRMFO/RSD - Transaction Processor for TCP ;09/13/2006
"RTN","HLTP3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,58,59,66,69,109,115,108,116,117,125,120,133**;Oct 13, 1995;Build 13
"RTN","HLTP3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTP3",4,0)
 ;
"RTN","HLTP3",5,0)
 Q
"RTN","HLTP3",6,0)
NEW(X) ;process new msg. ien in 773^msg. ien in 772
"RTN","HLTP3",7,0)
 ;HLMTIENS=ien in #773, msg header; HLMTIEN=ien in #772, msg text
"RTN","HLTP3",8,0)
 ;HLHDRO=original header;  HLHDR=response header
"RTN","HLTP3",9,0)
 ;set error trap
"RTN","HLTP3",10,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP3",11,0)
 N HL,HLEID,HLEIDS,HLERR,HLHDR,HLHDRO,HLMTIEN,HLMTIENS,HLJ,HLMSA,HLQUIT,HLNODE,HLNEXT,HLRESLTA,HLDONE1,HLASTRSP,HLRESLT
"RTN","HLTP3",12,0)
 S HLRESLT=""
"RTN","HLTP3",13,0)
 D INIT^HLTP3A
"RTN","HLTP3",14,0)
 ;error with header, return commit/app reject
"RTN","HLTP3",15,0)
 I $G(HLRESLT) D  Q
"RTN","HLTP3",16,0)
 . ;set status & unlock record
"RTN","HLTP3",17,0)
 . D STATUS^HLTF0(HLMTIENS,4,,,1),EXIT
"RTN","HLTP3",18,0)
 . ;quit if no commit or app ack
"RTN","HLTP3",19,0)
 . I $G(HL("ACAT"))="NE",$G(HL("APAT"))="NE" Q
"RTN","HLTP3",20,0)
 . S X=$S($G(HL("ACAT"))="AL":"CR",1:"AR")
"RTN","HLTP3",21,0)
 . ;HLTCP=ien of acknowledgment msg. from ACK^HLTP4
"RTN","HLTP3",22,0)
 . D ACK^HLTP4(X,$P(HLRESLT,U,2)) Q:'$G(HLTCP)
"RTN","HLTP3",23,0)
 . ;write ack back over connection
"RTN","HLTP3",24,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",25,0)
 . ;update counter to sent
"RTN","HLTP3",26,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",27,0)
 . ;update status of ack to complete
"RTN","HLTP3",28,0)
 . D STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",29,0)
 ;
"RTN","HLTP3",30,0)
 ;check for duplicate msg., use rec. app and msg. id x-ref
"RTN","HLTP3",31,0)
 ; patch HL*1.6*120
"RTN","HLTP3",32,0)
 ; I $L($G(HL("MID"))),$G(HL("RAP")) S X=$O(^HLMA("AH",HL("RAP"),HL("MID"),0)) D  Q:'$D(HLMTIENS)
"RTN","HLTP3",33,0)
 I $G(HL("MID"))]"",$G(HL("RAP")) S X=$O(^HLMA("AH",HL("RAP"),HL("MID"),0)) D  Q:'$D(HLMTIENS)
"RTN","HLTP3",34,0)
 . ;HLASTMSG=last ien received during this connection
"RTN","HLTP3",35,0)
 . ;if no duplicate, save msg. ien and quit
"RTN","HLTP3",36,0)
 . I X=HLMTIENS!'X S HLASTMSG=HLMTIENS Q
"RTN","HLTP3",37,0)
 . N MSH,OIENS
"RTN","HLTP3",38,0)
 . S (OIENS,Y)=X D  S Y=HLMTIENS D
"RTN","HLTP3",39,0)
 .. ;combine MSH into single string
"RTN","HLTP3",40,0)
 .. S MSH(Y)="",I=0 F  S I=$O(^HLMA(Y,"MSH",I)) Q:'I  S MSH(Y)=MSH(Y)_$G(^(I,0))
"RTN","HLTP3",41,0)
 .; patch 117 & 125, check if identical
"RTN","HLTP3",42,0)
 .I MSH(HLMTIENS)'=MSH(OIENS) S HLASTMSG=HLMTIENS Q
"RTN","HLTP3",43,0)
 .;
"RTN","HLTP3",44,0)
 . ;msg is duplicate, set status as duplicate
"RTN","HLTP3",45,0)
 . D STATUS^HLTF0(HLMTIENS,4,109,"Duplicate with ien "_OIENS,1),EXIT
"RTN","HLTP3",46,0)
 . ;msg was resent during this connection, ignore it.
"RTN","HLTP3",47,0)
 . I HLASTMSG=HLMTIENS K HLMTIENS Q
"RTN","HLTP3",48,0)
 . ;find original response and send back
"RTN","HLTP3",49,0)
 . S HLASTRSP=$O(^HLMA("AF",OIENS,OIENS))
"RTN","HLTP3",50,0)
 ;
"RTN","HLTP3",51,0)
 ;Quit if this is acknowledgment to acknowledgement message
"RTN","HLTP3",52,0)
 I $G(HL("ACK")) D  Q
"RTN","HLTP3",53,0)
 . ;Update status of original acknowledgment message to successfully
"RTN","HLTP3",54,0)
 . D STATUS^HLTF0(HL("MTIENS"),3,,,1),STATUS^HLTF0(HLMTIENS,3,,,1)
"RTN","HLTP3",55,0)
 . ;unlock record
"RTN","HLTP3",56,0)
 . D EXIT
"RTN","HLTP3",57,0)
 ;
"RTN","HLTP3",58,0)
 ;enhance ack., send commit, quit if not an ack, msg will be processed by filer
"RTN","HLTP3",59,0)
 I $G(HL("ACAT"))="AL" D  Q:'$G(HL("MTIENS"))
"RTN","HLTP3",60,0)
 . ;msg is a resend, HLASTRSP=ien of original response
"RTN","HLTP3",61,0)
 .I $G(HLASTRSP) D
"RTN","HLTP3",62,0)
 ..S HLTCP=HLASTRSP
"RTN","HLTP3",63,0)
 ..D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",64,0)
 . E  D  Q:'$G(HLTCP)
"RTN","HLTP3",65,0)
 ..D ACK^HLTP4("CA") ;**109** LLCNT^HLCSTCP(HLDP,3) called in ACK^HLTP4
"RTN","HLTP3",66,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",67,0)
 . D LLCNT^HLCSTCP(HLDP,4),STATUS^HLTF0(HLTCP,3,,,1):'$G(HLASTRSP)
"RTN","HLTP3",68,0)
 . S HLTCP=""
"RTN","HLTP3",69,0)
 . ;if not an ack, set status to awaiting processing **109** and put on in queue
"RTN","HLTP3",70,0)
 . I '$G(HL("MTIENS")),'$G(HLASTRSP) D STATUS^HLTF0(HLMTIENS,9),EXIT,SETINQUE^HLTP31
"RTN","HLTP3",71,0)
 ;
"RTN","HLTP3",72,0)
 ;enhance ack., no commit & no app ack
"RTN","HLTP3",73,0)
 I $G(HL("ACAT"))="NE",$G(HL("APAT"))="NE" D  Q
"RTN","HLTP3",74,0)
 . ;set status to awaiting processing, **109** and put on in queue
"RTN","HLTP3",75,0)
 . I '$G(HLASTRSP) D STATUS^HLTF0(HLMTIENS,9),EXIT,SETINQUE^HLTP31
"RTN","HLTP3",76,0)
 ;
"RTN","HLTP3",77,0)
 ; patch HL*1.6*120 start
"RTN","HLTP3",78,0)
 ;resending old response, msg is a resend
"RTN","HLTP3",79,0)
 ; I $G(HLASTRSP) S HLTCP=HLASTRSP G ACK
"RTN","HLTP3",80,0)
 ; do not re-send duplicate message when $G(HL("ACAT"))="AL"
"RTN","HLTP3",81,0)
 I $G(HLASTRSP),$G(HL("ACAT"))'="AL" S HLTCP=HLASTRSP G ACK
"RTN","HLTP3",82,0)
 ; quit if duplicate
"RTN","HLTP3",83,0)
 Q:$G(HLASTRSP)
"RTN","HLTP3",84,0)
 ; patch HL*1.6*120 end
"RTN","HLTP3",85,0)
 ;
"RTN","HLTP3",86,0)
CONT ;continue processing an enhance ack msg. called from DEFACK
"RTN","HLTP3",87,0)
 ;Set special HL variables for processing rtn
"RTN","HLTP3",88,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLTP3",89,0)
 ;
"RTN","HLTP3",90,0)
 ; message is an acknowledgement, HLMSA=ack code^id^text
"RTN","HLTP3",91,0)
 I ($G(HLMSA)]"") D  Q
"RTN","HLTP3",92,0)
 . ;X=1 if ack ok, 0=reject of error
"RTN","HLTP3",93,0)
 . S X=$E(HLMSA,2)="A"
"RTN","HLTP3",94,0)
 . ;Update status of original subscriber message and remove it from the out-going queue
"RTN","HLTP3",95,0)
 . D STATUS^HLTF0(HL("MTIENS"),$S(X:3,1:4),"",$S(X:"",1:$P(HLMSA,HL("FS"),3)),1)
"RTN","HLTP3",96,0)
 . D DEQUE^HLCSREP($P($G(^HLMA(HL("MTIENS"),0)),"^",7),"O",HL("MTIENS"))
"RTN","HLTP3",97,0)
 . D
"RTN","HLTP3",98,0)
 .. N HLTCP ;New variable to update status in file #772.
"RTN","HLTP3",99,0)
 ..;
"RTN","HLTP3",100,0)
 ..;**108**
"RTN","HLTP3",101,0)
 .. N TEMP
"RTN","HLTP3",102,0)
 .. S TEMP=HLMTIENS
"RTN","HLTP3",103,0)
 .. N HLMTIENS
"RTN","HLTP3",104,0)
 .. S HLMTIENS=TEMP
"RTN","HLTP3",105,0)
 ..;**END 108**
"RTN","HLTP3",106,0)
 ..;
"RTN","HLTP3",107,0)
 .. D PROCACK^HLTP2(HLMTIEN,HL("EID"),.HLRESLT,.HL)
"RTN","HLTP3",108,0)
 . ;update status of incoming to complete & unlock
"RTN","HLTP3",109,0)
 . D STATUS^HLTF0(HLMTIENS,$S($G(HLRESLT):4,1:3),$S($G(HLRESLT):+$G(HLRESLT),1:""),$S($G(HLRESLT):$P(HLRESLT,U,2),1:""),1),EXIT
"RTN","HLTP3",110,0)
 ;
"RTN","HLTP3",111,0)
 ;get entry action, exit action and processing routine
"RTN","HLTP3",112,0)
 K HLHDR,HLLD0,HLLD1,HLMSA
"RTN","HLTP3",113,0)
 I HL("EIDS")="",$G(HLEIDS)]"" S HL("EIDS")=HLEIDS ;**CIRN**
"RTN","HLTP3",114,0)
 D EVENT^HLUTIL1(HL("EIDS"),"15,20,771",.HLN)
"RTN","HLTP3",115,0)
 S HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15)),HLPROU=$G(HLN(771))
"RTN","HLTP3",116,0)
 ;quit if no processing routine,update status and quit
"RTN","HLTP3",117,0)
 I HLPROU']"" S HLRESLT="10^"_$G(^HL(771.7,10,0)) D STATUS^HLTF0(HLMTIENS,3,,,1),EXIT Q
"RTN","HLTP3",118,0)
 ;HLORNOD=subscriber protocol for Fileman auditing, ien;global ref
"RTN","HLTP3",119,0)
 N HLORNODD S HLORNOD=HL("EIDS")_";ORD(101,"
"RTN","HLTP3",120,0)
 ;Execute entry action of client protocol
"RTN","HLTP3",121,0)
 X:HLENROU]"" HLENROU K HLENROU,HLDONE1
"RTN","HLTP3",122,0)
 ;
"RTN","HLTP3",123,0)
 ;Execute processing routine
"RTN","HLTP3",124,0)
 X HLPROU S HLRESLT=0 S:($D(HLERR)) HLRESLT="9^"_HLERR
"RTN","HLTP3",125,0)
 ;update status of incoming to complete & unlock
"RTN","HLTP3",126,0)
 D STATUS^HLTF0(HLMTIENS,$S(HLRESLT:4,1:3),$S(HLRESLT:+HLRESLT,1:""),$S(HLRESLT:$P(HLRESLT,U,2),1:""),1,$S($G(HLERR("SKIP_EVENT"))=1:1,1:0)),EXIT
"RTN","HLTP3",127,0)
 ;HLTCPO=link open, HLTCP=ien of acknowledgment msg. from GENACK
"RTN","HLTP3",128,0)
ACK I $G(HLTCPO),$G(HLTCP) D  Q
"RTN","HLTP3",129,0)
 . D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",130,0)
 . ;write ack back over open tcp link
"RTN","HLTP3",131,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",132,0)
 . ;update status of ack to complete
"RTN","HLTP3",133,0)
 . D:'$G(HLASTRSP) STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",134,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",135,0)
 Q
"RTN","HLTP3",136,0)
 ;
"RTN","HLTP3",137,0)
DEFACK(HLDP,X) ;process the deferred application ack, called from HLCSIN
"RTN","HLTP3",138,0)
 ;HLDP=logical link, X=ien in file 773
"RTN","HLTP3",139,0)
 ;
"RTN","HLTP3",140,0)
 ; patch HL*1.6*120 start
"RTN","HLTP3",141,0)
 ; clean variables except Kernel related variables
"RTN","HLTP3",142,0)
 D
"RTN","HLTP3",143,0)
 . ; protect variables defined in STARTIN^HLCSIN
"RTN","HLTP3",144,0)
 . N HLFLG,HLEXIT,HLPTRFLR
"RTN","HLTP3",145,0)
 . ; protect variables defined in DEFACK^HLCSIN
"RTN","HLTP3",146,0)
 . N HLXX,HLD0,HLPCT
"RTN","HLTP3",147,0)
 . ; protect input parameters of this sub-routine
"RTN","HLTP3",148,0)
 . N HLDP,X
"RTN","HLTP3",149,0)
 . D KILL^XUSCLEAN
"RTN","HLTP3",150,0)
 ; patch HL*1.6*120 end
"RTN","HLTP3",151,0)
 ;
"RTN","HLTP3",152,0)
 ;set error trap
"RTN","HLTP3",153,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP3",154,0)
 N HLERR     ;patch HL*1.6*109
"RTN","HLTP3",155,0)
 Q:'$G(HLDP)!'$G(X)  Q:'$G(^HLMA(X,0))
"RTN","HLTP3",156,0)
 ;**109 START**
"RTN","HLTP3",157,0)
 Q:'$D(^HLMA("AC","I",HLDP,X))
"RTN","HLTP3",158,0)
 ;**109 END**
"RTN","HLTP3",159,0)
 ;
"RTN","HLTP3",160,0)
 N HL,HLA,HLD0,HLEID,HLEIDS,HLHDR,HLHDRO,HLMTIEN,HLMTIENS,HLJ,HLMSA,HLN,HLQUIT,HLNODE,HLNEXT,HLRESLT,HLRESLTA,HLTCP,HLXX,Z,HLDONE1
"RTN","HLTP3",161,0)
 ;setup variables
"RTN","HLTP3",162,0)
 S HLMTIENS=X,X=^HLMA(HLMTIENS,0),HLMTIEN=+$P(X,U),HL("MID")=$P(X,U,2),HL("MTIENS")=$P(X,U,10),HL("LL")=$P(X,U,7),HLTCP="",HL("Q")=""""""
"RTN","HLTP3",163,0)
 S HL("EIDS")=$P(X,U,8),HL("SAP")=$P(X,U,11),HL("RAP")=$P(X,U,12),HL("MTP")=$P(X,U,13),HL("ETP")=$P(X,U,14)
"RTN","HLTP3",164,0)
 S:$P(X,U,15) HL("MTP_ETP")=$P(X,U,15)
"RTN","HLTP3",165,0)
 S:HL("SAP") HL("SAN")=$P($G(^HL(771,HL("SAP"),0)),U) S:HL("RAP") HL("RAN")=$P($G(^HL(771,HL("RAP"),0)),U)
"RTN","HLTP3",166,0)
 S:HL("MTP") HL("MTN")=$P($G(^HL(771.2,HL("MTP"),0)),U) S:HL("ETP") HL("ETN")=$P($G(^HL(779.001,HL("ETP"),0)),U)
"RTN","HLTP3",167,0)
 S:$G(HL("MTP_ETP")) HL("MTN_ETN")=$P($G(^HL(779.005,HL("MTP_ETP"),0)),U)
"RTN","HLTP3",168,0)
 S HL("EID")=$P($G(^HL(772,HLMTIEN,0)),U,10)
"RTN","HLTP3",169,0)
 M HLHDRO=^HLMA(HLMTIENS,"MSH")
"RTN","HLTP3",170,0)
 ; if no header quit
"RTN","HLTP3",171,0)
 ;**109**
"RTN","HLTP3",172,0)
 ;I '$O(HLHDRO(0)) L -^HLMA(HLMTIENS) Q
"RTN","HLTP3",173,0)
 Q:'$O(HLHDRO(0))
"RTN","HLTP3",174,0)
 ;
"RTN","HLTP3",175,0)
 S HL("FS")=$E(HLHDRO(1,0),4),HL("ECH")=$$P^HLTPCK2(.HLHDRO,2),HL("SFN")=$$P^HLTPCK2(.HLHDRO,4),HL("RFN")=$$P^HLTPCK2(.HLHDRO,6),HL("DTM")=$$P^HLTPCK2(.HLHDRO,7)
"RTN","HLTP3",176,0)
 ;
"RTN","HLTP3",177,0)
 ; patch HL*1.6*109 start
"RTN","HLTP3",178,0)
 ; quit if ien of #772 is not defined
"RTN","HLTP3",179,0)
 Q:'HLMTIEN
"RTN","HLTP3",180,0)
 ; quit if field separator is not defined
"RTN","HLTP3",181,0)
 Q:HL("FS")=""
"RTN","HLTP3",182,0)
 ; patch HL*1.6*109 end
"RTN","HLTP3",183,0)
 ;
"RTN","HLTP3",184,0)
 S X=$$P^HLTPCK2(.HLHDRO,1)
"RTN","HLTP3",185,0)
 ;
"RTN","HLTP3",186,0)
 ; patch HL*1.6*120 start
"RTN","HLTP3",187,0)
 I X="MSH" D
"RTN","HLTP3",188,0)
 . S HL("PID")=$$P^HLTPCK2(.HLHDRO,11),HL("VER")=$$P^HLTPCK2(.HLHDRO,12),HL("APAT")=$$P^HLTPCK2(.HLHDRO,16),HL("CC")=$$P^HLTPCK2(.HLHDRO,17)
"RTN","HLTP3",189,0)
 . ;
"RTN","HLTP3",190,0)
 . ; 2nd component is Processing mode
"RTN","HLTP3",191,0)
 . S HL("PMOD")=$P(HL("PID"),$E(HL("ECH"),1),2)
"RTN","HLTP3",192,0)
 . ; first component is Processing id
"RTN","HLTP3",193,0)
 . S HL("PID")=$P(HL("PID"),$E(HL("ECH"),1))
"RTN","HLTP3",194,0)
 ;
"RTN","HLTP3",195,0)
 I X'="MSH" D
"RTN","HLTP3",196,0)
 . S X=$$P^HLTPCK2(.HLHDRO,9),Z=$E(HL("ECH")),HL("PID")=$P(X,Z,2),HL("VER")=$P(X,Z,4)
"RTN","HLTP3",197,0)
 . ;
"RTN","HLTP3",198,0)
 . ; original implementation incorrectly treats repetition separator as
"RTN","HLTP3",199,0)
 . ; subcomponent separator
"RTN","HLTP3",200,0)
 . I $E(HL("ECH"),2)]"",X[$E(HL("ECH"),2) D
"RTN","HLTP3",201,0)
 .. S HL("SUB-COMPONENT")=$E(HL("ECH"),2)
"RTN","HLTP3",202,0)
 . ; if subcomponent separator is correctly applied
"RTN","HLTP3",203,0)
 . I $E(HL("ECH"),4)]"",X[$E(HL("ECH"),4) D
"RTN","HLTP3",204,0)
 .. S HL("SUB-COMPONENT")=$E(HL("ECH"),4)
"RTN","HLTP3",205,0)
 . ;
"RTN","HLTP3",206,0)
 . I $D(HL("SUB-COMPONENT")),HL("PID")[HL("SUB-COMPONENT") D
"RTN","HLTP3",207,0)
 .. ; 2nd sub-component is Processing mode
"RTN","HLTP3",208,0)
 .. S HL("PMOD")=$P(HL("PID"),HL("SUB-COMPONENT"),2)
"RTN","HLTP3",209,0)
 .. ; first sub-component is Processing id
"RTN","HLTP3",210,0)
 .. S HL("PID")=$P(HL("PID"),HL("SUB-COMPONENT"))
"RTN","HLTP3",211,0)
 . ; patch HL*1.6*120 end
"RTN","HLTP3",212,0)
 . ;
"RTN","HLTP3",213,0)
 . Q:$$P^HLTPCK2(.HLHDRO,10)=""
"RTN","HLTP3",214,0)
 . ;HLMSA=ack code^id^text
"RTN","HLTP3",215,0)
 . S HLMSA=$P($$P^HLTPCK2(.HLHDRO,10),$E(HL("ECH")),1),$P(HLMSA,HL("FS"),2)=$$P^HLTPCK2(.HLHDRO,12),$P(HLMSA,HL("FS"),3)=$P($$P^HLTPCK2(.HLHDRO,10),$E(HL("ECH")),2),HL("MSAID")=$P(HLMSA,HL("FS"),2)
"RTN","HLTP3",216,0)
 ;
"RTN","HLTP3",217,0)
 ; HL*1.6*108
"RTN","HLTP3",218,0)
 ; quit if this is a commit ack
"RTN","HLTP3",219,0)
 I $P($G(^HL(772,HLMTIEN,"IN",1,0)),HL("FS"),1)="MSA",$E($P($G(^HL(772,HLMTIEN,"IN",1,0)),HL("FS"),2))="C" Q
"RTN","HLTP3",220,0)
 ; ** 
"RTN","HLTP3",221,0)
 ;
"RTN","HLTP3",222,0)
 ;**  HL*1.6*117 **
"RTN","HLTP3",223,0)
 K HLL("SET FOR APP ACK"),HLL("LINKS")
"RTN","HLTP3",224,0)
 ;** END HL*1.6*117 **
"RTN","HLTP3",225,0)
 ;
"RTN","HLTP3",226,0)
 D CONT
"RTN","HLTP3",227,0)
 Q
"RTN","HLTP3",228,0)
 ;
"RTN","HLTP3",229,0)
MSA(Y) ;Y=ien in 772, returns MSA segment
"RTN","HLTP3",230,0)
 ;ack code^msg being ack id^text
"RTN","HLTP3",231,0)
 N X
"RTN","HLTP3",232,0)
 S X=$G(^HL(772,Y,"IN",1,0)),X=$S($E(X,1,3)="MSA":$E(X,5,999),1:"")
"RTN","HLTP3",233,0)
 Q X
"RTN","HLTP3",234,0)
 ;
"RTN","HLTP3",235,0)
ERROR ;error trap
"RTN","HLTP3",236,0)
 D ^%ZTER
"RTN","HLTP3",237,0)
 I $G(HLMTIENS),$D(^HLMA(HLMTIENS,0)) D STATUS^HLTF0(HLMTIENS,4,,,1),EXIT
"RTN","HLTP3",238,0)
 ;*109* release all locks created by inbound filer
"RTN","HLTP3",239,0)
 L -^HLMA("AC","I",+$G(HLXX))
"RTN","HLTP3",240,0)
 G UNWIND^%ZTER
"RTN","HLTP3",241,0)
 ;
"RTN","HLTP3",242,0)
 ;
"RTN","HLTP3",243,0)
EXIT ;unlock
"RTN","HLTP3",244,0)
 I $G(HLMTIENS) L -^HLMA(HLMTIENS)
"RTN","HLTP3",245,0)
 Q
"RTN","HLTP3",246,0)
 ;
"RTN","HLTP3",247,0)
ONAC(IEN773) ;
"RTN","HLTP3",248,0)
 ;Returns 1 if the message is on the "AC","I" xref
"RTN","HLTP3",249,0)
 ;Returns 0 otherwise
"RTN","HLTP3",250,0)
 ;
"RTN","HLTP3",251,0)
 N LINK
"RTN","HLTP3",252,0)
 S LINK=$P($G(^HLMA(IEN773,0)),"^",17)
"RTN","HLTP3",253,0)
 Q:'LINK 0
"RTN","HLTP3",254,0)
 Q $D(^HLMA("AC","I",LINK,IEN773))
"RTN","HLTPCK1")
0^14^B37602285^B31754890
"RTN","HLTPCK1",1,0)
HLTPCK1 ;AISC/SAW-Header Validation Routine (non-TCP link) ;09/13/2006
"RTN","HLTPCK1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**8,36,59,120,133**;Oct 13, 1995;Build 13
"RTN","HLTPCK1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTPCK1",4,0)
CHK(HDR,ARY,MSA) ;Validate Data in Header Segment (MSH, BHS or FHS) of
"RTN","HLTPCK1",5,0)
 ;an HL7 Message through non-TCP link
"RTN","HLTPCK1",6,0)
 ;
"RTN","HLTPCK1",7,0)
 ;This entry point is a subroutine call with parameter passing that
"RTN","HLTPCK1",8,0)
 ;will return an array (ARY()) consisting of values extracted from
"RTN","HLTPCK1",9,0)
 ;the message header segment subscripted by the mnemonics for each of
"RTN","HLTPCK1",10,0)
 ;the message header fields and components
"RTN","HLTPCK1",11,0)
 ;If an error is encountered during validation, the array parameter
"RTN","HLTPCK1",12,0)
 ;(ARY) will be set equal to two pieces, error #^error text
"RTN","HLTPCK1",13,0)
 ;
"RTN","HLTPCK1",14,0)
 ;Required input parameters:
"RTN","HLTPCK1",15,0)
 ;  HDR = Message header segment
"RTN","HLTPCK1",16,0)
 ;
"RTN","HLTPCK1",17,0)
 ;  ARY = The array in which the message header values will be
"RTN","HLTPCK1",18,0)
 ;          returned
"RTN","HLTPCK1",19,0)
 ;  Note:  The ARY parameter must be passed by reference
"RTN","HLTPCK1",20,0)
 ;
"RTN","HLTPCK1",21,0)
 ;Optional input parameter:
"RTN","HLTPCK1",22,0)
 ;  MSA = A variable which contains the message acknowledgement values:
"RTN","HLTPCK1",23,0)
 ;          acknowledgement code^message control ID^text message
"RTN","HLTPCK1",24,0)
 ;
"RTN","HLTPCK1",25,0)
 ;Check for required parameters
"RTN","HLTPCK1",26,0)
 N ERR S ERR=""
"RTN","HLTPCK1",27,0)
 I $G(HDR)']"" S ERR="7^"_$G(^HL(771.7,7,0))_" at CHK^HLTPCK1 entry point" G EXIT
"RTN","HLTPCK1",28,0)
 N ECH,HLN,FS,X,X1,X2
"RTN","HLTPCK1",29,0)
 S ARY="",ARY("Q")=""""""
"RTN","HLTPCK1",30,0)
 ;
"RTN","HLTPCK1",31,0)
 ;Validate field separator and encoding characters
"RTN","HLTPCK1",32,0)
 S (ARY("FS"),FS)=$E(HDR,4)
"RTN","HLTPCK1",33,0)
 I FS']"" S ERR="Field Separator Missing" G EXIT
"RTN","HLTPCK1",34,0)
 I FS?.C S ERR="Invalid Field Separator" G EXIT
"RTN","HLTPCK1",35,0)
 S (ARY("ECH"),ECH)=$P(HDR,FS,2)
"RTN","HLTPCK1",36,0)
 I ECH']"" S ERR="Encoding Characters Missing" G EXIT
"RTN","HLTPCK1",37,0)
 I ECH?.C S ERR="Invalid Encoding Characters" G EXIT
"RTN","HLTPCK1",38,0)
 ;
"RTN","HLTPCK1",39,0)
 ; patch HL*1.6*120 start
"RTN","HLTPCK1",40,0)
 ; patch HL*1.6*133
"RTN","HLTPCK1",41,0)
 ; escape and sub-component characters are optional
"RTN","HLTPCK1",42,0)
 ; I $L(ECH)'=4 S ERR="Invalid Encoding Characters" G EXIT
"RTN","HLTPCK1",43,0)
 I $L(ECH)<1 S ERR="Invalid Encoding Characters" G EXIT
"RTN","HLTPCK1",44,0)
 S ECH(1)=$E(ECH)
"RTN","HLTPCK1",45,0)
 S ECH(2)=$E(ECH,2)
"RTN","HLTPCK1",46,0)
 S ECH(3)=$E(ECH,3)
"RTN","HLTPCK1",47,0)
 S ECH(4)=$E(ECH,4)
"RTN","HLTPCK1",48,0)
 S ARY("HDR")=HDR
"RTN","HLTPCK1",49,0)
 S ARY("HDR-1")=$E(HDR,1,3)
"RTN","HLTPCK1",50,0)
 ;
"RTN","HLTPCK1",51,0)
 ;Validate Message Header Type
"RTN","HLTPCK1",52,0)
 ; I "FHS,BHS,MSH"'[$E(HDR,1,3) S ERR="Invalid Message Header Segment" G EXIT
"RTN","HLTPCK1",53,0)
 I "FHS,BHS,MSH"'[ARY("HDR-1") S ERR="Invalid Message Header" G EXIT
"RTN","HLTPCK1",54,0)
 ;
"RTN","HLTPCK1",55,0)
 ;Extract data from message header segment
"RTN","HLTPCK1",56,0)
 ; I $E(HDR,1,3)="BHS"!($E(HDR,1,3)="FHS") D
"RTN","HLTPCK1",57,0)
 I ARY("HDR-1")="BHS"!(ARY("HDR-1")="FHS") D
"RTN","HLTPCK1",58,0)
 . ;S ARY("DTM")=$P(HDR,FS,7),ARY("MID")=$P(HDR,FS,11),X=$P(HDR,FS,9),ARY("PID")=$P(X,$E(ECH),2),ARY("MTN")=$P($P(X,$E(ECH),3),$E(ECH,2)),ARY("ETN")=$P($P(X,$E(ECH),3),$E(ECH,2),2),ARY("VER")=$P(X,$E(ECH),4)
"RTN","HLTPCK1",59,0)
 . S ARY("DTM")=$P(HDR,FS,7)
"RTN","HLTPCK1",60,0)
 . S ARY("MID")=$P(HDR,FS,11)
"RTN","HLTPCK1",61,0)
 . S ARY("PID")=""
"RTN","HLTPCK1",62,0)
 . S ARY("MTN")=""
"RTN","HLTPCK1",63,0)
 . S ARY("ETN")=""
"RTN","HLTPCK1",64,0)
 . S ARY("VER")=""
"RTN","HLTPCK1",65,0)
 . ;
"RTN","HLTPCK1",66,0)
 . ; BHS-9, Batch name/ID/type:
"RTN","HLTPCK1",67,0)
 . ; 2nd component: Processing id <sub> Processing mode
"RTN","HLTPCK1",68,0)
 . ; 3rd component: message type <sub> event type
"RTN","HLTPCK1",69,0)
 . ; 4th component: version
"RTN","HLTPCK1",70,0)
 . S X=$P(HDR,FS,9)
"RTN","HLTPCK1",71,0)
 . I X]"" D
"RTN","HLTPCK1",72,0)
 .. S ARY("HDR-9")=X
"RTN","HLTPCK1",73,0)
 .. ; original implementation incorrectly treats repetition separator as
"RTN","HLTPCK1",74,0)
 .. ; subcomponent separator
"RTN","HLTPCK1",75,0)
 .. S ECH("SUB-COMPONENT")=ECH(2)
"RTN","HLTPCK1",76,0)
 .. ; if subcomponent separator is correctly applied
"RTN","HLTPCK1",77,0)
 .. ; patch HL*1.6*133
"RTN","HLTPCK1",78,0)
 .. ; I X[ECH(4) S ECH("SUB-COMPONENT")=ECH(4)
"RTN","HLTPCK1",79,0)
 .. I ECH(4)]"",X[ECH(4) S ECH("SUB-COMPONENT")=ECH(4)
"RTN","HLTPCK1",80,0)
 .. ;
"RTN","HLTPCK1",81,0)
 .. S ARY("PID")=$P(X,ECH(1),2)
"RTN","HLTPCK1",82,0)
 .. ; patch HL*1.6*133
"RTN","HLTPCK1",83,0)
 .. ; I ARY("PID")[ECH("SUB-COMPONENT") D
"RTN","HLTPCK1",84,0)
 .. I ECH("SUB-COMPONENT")]"",ARY("PID")[ECH("SUB-COMPONENT") D
"RTN","HLTPCK1",85,0)
 ... ; 2nd sub-component is Processing mode
"RTN","HLTPCK1",86,0)
 ... S ARY("PMOD")=$P(ARY("PID"),ECH("SUB-COMPONENT"),2)
"RTN","HLTPCK1",87,0)
 ... ; first sub-component is Processing id
"RTN","HLTPCK1",88,0)
 ... S ARY("PID")=$P(ARY("PID"),ECH("SUB-COMPONENT"))
"RTN","HLTPCK1",89,0)
 .. ;
"RTN","HLTPCK1",90,0)
 .. S ARY("MTN")=$P(X,ECH(1),3)
"RTN","HLTPCK1",91,0)
 .. ; 2nd sub-component is event type
"RTN","HLTPCK1",92,0)
 .. ;
"RTN","HLTPCK1",93,0)
 .. ; patch HL*1.6*133 start
"RTN","HLTPCK1",94,0)
 .. ; S ARY("ETN")=$P(ARY("MTN"),ECH("SUB-COMPONENT"),2)
"RTN","HLTPCK1",95,0)
 .. I ECH("SUB-COMPONENT")]"" D
"RTN","HLTPCK1",96,0)
 ... S ARY("ETN")=$P(ARY("MTN"),ECH("SUB-COMPONENT"),2)
"RTN","HLTPCK1",97,0)
 .. ; 1st sub-component is message type
"RTN","HLTPCK1",98,0)
 .. ; S ARY("MTN")=$P(ARY("MTN"),ECH("SUB-COMPONENT"))
"RTN","HLTPCK1",99,0)
 .. I ECH("SUB-COMPONENT")]"" D
"RTN","HLTPCK1",100,0)
 ... S ARY("MTN")=$P(ARY("MTN"),ECH("SUB-COMPONENT"))
"RTN","HLTPCK1",101,0)
 .. ; patch HL*1.6*133 end
"RTN","HLTPCK1",102,0)
 .. ;
"RTN","HLTPCK1",103,0)
 .. S ARY("VER")=$P(X,ECH(1),4)
"RTN","HLTPCK1",104,0)
 . ;
"RTN","HLTPCK1",105,0)
 . ; BHS-10, batch comment
"RTN","HLTPCK1",106,0)
 . ; S:$P(HDR,FS,10)]"" MSA=$P($P(HDR,FS,10),$E(ECH),1),$P(MSA,FS,2)=$P(HDR,FS,12),$P(MSA,FS,3)=$P($P(HDR,FS,10),$E(ECH),2)
"RTN","HLTPCK1",107,0)
 . ; first component: MSA-1, acknowledgment code
"RTN","HLTPCK1",108,0)
 . ; 2nd component: MSA-3, text message
"RTN","HLTPCK1",109,0)
 . ;
"RTN","HLTPCK1",110,0)
 . S X=$P(HDR,FS,10)
"RTN","HLTPCK1",111,0)
 . I X]"" D
"RTN","HLTPCK1",112,0)
 .. S ARY("HDR-10")=X
"RTN","HLTPCK1",113,0)
 .. ; MSA-1, acknowledgment code: AA,AE,AR,CA,CE,CR
"RTN","HLTPCK1",114,0)
 .. S MSA=$P(X,ECH(1),1)
"RTN","HLTPCK1",115,0)
 .. ; MSA-2 and BHS-12, reference batch control id
"RTN","HLTPCK1",116,0)
 .. S $P(MSA,FS,2)=$P(HDR,FS,12)
"RTN","HLTPCK1",117,0)
 .. ; MSA-3, text message
"RTN","HLTPCK1",118,0)
 .. S $P(MSA,FS,3)=$P(X,ECH(1),2)
"RTN","HLTPCK1",119,0)
 . ; Reference Batch Control ID
"RTN","HLTPCK1",120,0)
 . S:$P(HDR,FS,12)]"" ARY("HDR-12")=$P(HDR,FS,12)
"RTN","HLTPCK1",121,0)
 ;
"RTN","HLTPCK1",122,0)
 ; I $E(HDR,1,3)="MSH" D
"RTN","HLTPCK1",123,0)
 I ARY("HDR-1")="MSH" D
"RTN","HLTPCK1",124,0)
 . ;S ARY("DTM")=$P(HDR,FS,7),ARY("MID")=$P(HDR,FS,10),ARY("PID")=$P(HDR,FS,11),ARY("MTN")=$P($P(HDR,FS,9),$E(ECH)),ARY("ETN")=$P($P(HDR,FS,9),$E(ECH),2),ARY("VER")=$P(HDR,FS,12)
"RTN","HLTPCK1",125,0)
 . S ARY("DTM")=$P(HDR,FS,7)
"RTN","HLTPCK1",126,0)
 . S ARY("MID")=$P(HDR,FS,10)
"RTN","HLTPCK1",127,0)
 . S ARY("PID")=$P(HDR,FS,11)
"RTN","HLTPCK1",128,0)
 . S ARY("MTN")=$P($P(HDR,FS,9),ECH(1))
"RTN","HLTPCK1",129,0)
 . S ARY("ETN")=$P($P(HDR,FS,9),ECH(1),2)
"RTN","HLTPCK1",130,0)
 . S ARY("VER")=$P(HDR,FS,12)
"RTN","HLTPCK1",131,0)
 . ;
"RTN","HLTPCK1",132,0)
 . ; 2nd sub-component is Processing mode
"RTN","HLTPCK1",133,0)
 . I ARY("PID")[ECH(1) D
"RTN","HLTPCK1",134,0)
 .. S ARY("PMOD")=$P(ARY("PID"),ECH(1),2)
"RTN","HLTPCK1",135,0)
 .. ; first sub-component is Processing id
"RTN","HLTPCK1",136,0)
 .. S ARY("PID")=$P(ARY("PID"),ECH(1))
"RTN","HLTPCK1",137,0)
 . ;
"RTN","HLTPCK1",138,0)
 . ; S:$P($P(HDR,FS,9),$E(ECH),3)]"" ARY("MTN_ETN")=$P($P(HDR,FS,9),$E(ECH),3)
"RTN","HLTPCK1",139,0)
 .I $P($P(HDR,FS,9),ECH(1),3)]"" D
"RTN","HLTPCK1",140,0)
 .. S ARY("MTN_ETN")=$P($P(HDR,FS,9),ECH(1),3)
"RTN","HLTPCK1",141,0)
 . ;
"RTN","HLTPCK1",142,0)
 . ; fields 13 and 14
"RTN","HLTPCK1",143,0)
 . S:$P(HDR,FS,13)]"" ARY("MSH-13")=$P(HDR,FS,13)
"RTN","HLTPCK1",144,0)
 . S:$P(HDR,FS,14)]"" ARY("MSH-14")=$P(HDR,FS,14)
"RTN","HLTPCK1",145,0)
 . ;
"RTN","HLTPCK1",146,0)
 . ; S:$P(HDR,FS,15)]"" ARY("ACAT")=$P(HDR,FS,15) S:$P(HDR,FS,16)]"" ARY("APAT")=$P(HDR,FS,16) S:$P(HDR,FS,17)]"" ARY("CC")=$P(HDR,FS,17)
"RTN","HLTPCK1",147,0)
 . S:$P(HDR,FS,15)]"" ARY("ACAT")=$P(HDR,FS,15)
"RTN","HLTPCK1",148,0)
 . S:$P(HDR,FS,16)]"" ARY("APAT")=$P(HDR,FS,16)
"RTN","HLTPCK1",149,0)
 . S:$P(HDR,FS,17)]"" ARY("CC")=$P(HDR,FS,17)
"RTN","HLTPCK1",150,0)
 . ;
"RTN","HLTPCK1",151,0)
 . ; fields 18,19,20 and 21
"RTN","HLTPCK1",152,0)
 . S:$P(HDR,FS,18)]"" ARY("MSH-18")=$P(HDR,FS,18)
"RTN","HLTPCK1",153,0)
 . S:$P(HDR,FS,19)]"" ARY("MSH-19")=$P(HDR,FS,19)
"RTN","HLTPCK1",154,0)
 . S:$P(HDR,FS,20)]"" ARY("MSH-20")=$P(HDR,FS,20)
"RTN","HLTPCK1",155,0)
 . S:$P(HDR,FS,21)]"" ARY("MSH-21")=$P(HDR,FS,21)
"RTN","HLTPCK1",156,0)
 K:$G(MSA)']"" MSA
"RTN","HLTPCK1",157,0)
 ;
"RTN","HLTPCK1",158,0)
 S ARY("RAF")=$P(HDR,FS,6)  ; receiving facility
"RTN","HLTPCK1",159,0)
 S ARY("SAF")=$P(HDR,FS,4)  ; sending facility
"RTN","HLTPCK1",160,0)
 ;
"RTN","HLTPCK1",161,0)
 ;Invoke continuation routine to perform remaining validation checks
"RTN","HLTPCK1",162,0)
 D ^HLTPCK1A
"RTN","HLTPCK1",163,0)
 ;
"RTN","HLTPCK1",164,0)
EXIT ;
"RTN","HLTPCK1",165,0)
 ; the maximum length of field #772,22 (Error Message) is 200
"RTN","HLTPCK1",166,0)
 I ERR]"" D
"RTN","HLTPCK1",167,0)
 . S ERR=$E(ERR,1,200)
"RTN","HLTPCK1",168,0)
 . S ARY=$S('ERR:"13^"_ERR,1:ERR)
"RTN","HLTPCK1",169,0)
 ; patch HL*1.6*120 end
"RTN","HLTPCK1",170,0)
 Q
"RTN","HLTPCK2")
0^15^B40614402^B34416614
"RTN","HLTPCK2",1,0)
HLTPCK2 ;SF/RSD - Message Header Validation (TCP Link) ;09/13/2006
"RTN","HLTPCK2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,59,120,133**;Oct 13, 1995;Build 13
"RTN","HLTPCK2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTPCK2",4,0)
CHK(HDR,ARY,MSA) ;
"RTN","HLTPCK2",5,0)
 ;Validate Data in Header Segment (MSH, BHS or FHS) of an HL7 Message
"RTN","HLTPCK2",6,0)
 ; through TCP link.
"RTN","HLTPCK2",7,0)
 ;
"RTN","HLTPCK2",8,0)
 ;This entry point is a subroutine call with parameter passing that
"RTN","HLTPCK2",9,0)
 ;will return an array (ARY()) consisting of values extracted from
"RTN","HLTPCK2",10,0)
 ;the message header segment subscripted by the mnemonics for each of
"RTN","HLTPCK2",11,0)
 ;the message header fields and components.
"RTN","HLTPCK2",12,0)
 ;The message header can be multiple line longer than 255 characters.
"RTN","HLTPCK2",13,0)
 ;HDR is an array that is passed by reference.
"RTN","HLTPCK2",14,0)
 ;If an error is encountered during validation, the array parameter
"RTN","HLTPCK2",15,0)
 ;(ARY) will be set equal to two pieces, error #^error text.
"RTN","HLTPCK2",16,0)
 ;
"RTN","HLTPCK2",17,0)
 ;Required input parameters
"RTN","HLTPCK2",18,0)
 ;  HDR = Message header array, HDR(1,0)=segment (passed by reference)
"RTN","HLTPCK2",19,0)
 ;
"RTN","HLTPCK2",20,0)
 ;  ARY = The array in which the message header values will be
"RTN","HLTPCK2",21,0)
 ;          returned (passed by reference)
"RTN","HLTPCK2",22,0)
 ;
"RTN","HLTPCK2",23,0)
 ;Optional input parameter
"RTN","HLTPCK2",24,0)
 ;  MSA = A variable which contains the message acknowledgement values:
"RTN","HLTPCK2",25,0)
 ;          acknowledgement code^message control ID^text message. Passed
"RTN","HLTPCK2",26,0)
 ;          by reference so that Batch msg. can set this here.
"RTN","HLTPCK2",27,0)
 ;
"RTN","HLTPCK2",28,0)
 ;Check for required parameters
"RTN","HLTPCK2",29,0)
 N ERR S ERR=""
"RTN","HLTPCK2",30,0)
 I $D(HDR)<10 S ERR="7^"_$G(^HL(771.7,7,0))_" at CHK^HLTPCK2" G EXIT
"RTN","HLTPCK2",31,0)
 N ECH,HLN,FS,X,X1,X2
"RTN","HLTPCK2",32,0)
 S ARY="",ARY("Q")=""""""
"RTN","HLTPCK2",33,0)
 ;
"RTN","HLTPCK2",34,0)
 ;Validate field separator and encoding characters
"RTN","HLTPCK2",35,0)
 S (ARY("FS"),FS)=$E(HDR(1,0),4)
"RTN","HLTPCK2",36,0)
 I FS']"" S ERR="Field Separator Missing" G EXIT
"RTN","HLTPCK2",37,0)
 I FS?.C S ERR="Invalid Field Separator" G EXIT
"RTN","HLTPCK2",38,0)
 S (ARY("ECH"),ECH)=$$P(.HDR,2)
"RTN","HLTPCK2",39,0)
 I ECH']"" S ERR="Encoding Characters Missing" G EXIT
"RTN","HLTPCK2",40,0)
 I ECH?.C S ERR="Invalid Encoding Characters" G EXIT
"RTN","HLTPCK2",41,0)
 ;
"RTN","HLTPCK2",42,0)
 ; patch HL*1.6*120 start
"RTN","HLTPCK2",43,0)
 ; patch HL*1.6*133
"RTN","HLTPCK2",44,0)
 ; escape and sub-component characters are optional
"RTN","HLTPCK2",45,0)
 ; I $L(ECH)'=4 S ERR="Invalid Encoding Characters" G EXIT
"RTN","HLTPCK2",46,0)
 I $L(ECH)<1 S ERR="Invalid Encoding Characters" G EXIT
"RTN","HLTPCK2",47,0)
 S ECH(1)=$E(ECH)
"RTN","HLTPCK2",48,0)
 S ECH(2)=$E(ECH,2)
"RTN","HLTPCK2",49,0)
 S ECH(3)=$E(ECH,3)
"RTN","HLTPCK2",50,0)
 S ECH(4)=$E(ECH,4)
"RTN","HLTPCK2",51,0)
 M ARY("HDR")=HDR
"RTN","HLTPCK2",52,0)
 ;
"RTN","HLTPCK2",53,0)
 ;Validate Message Header Type
"RTN","HLTPCK2",54,0)
 S (ARY("TYPE"),X)=$$P(.HDR,1)
"RTN","HLTPCK2",55,0)
 S ARY("HDR-1")=X
"RTN","HLTPCK2",56,0)
 I X=""!("FHS,BHS,MSH"'[X) S ERR="Invalid Message Header" G EXIT
"RTN","HLTPCK2",57,0)
 ;
"RTN","HLTPCK2",58,0)
 ;Extract data from message header segment
"RTN","HLTPCK2",59,0)
 ; S ARY("SAN")=$$P(.HDR,3),ARY("SFN")=$$P(.HDR,4),ARY("RAN")=$$P(.HDR,5),ARY("RFN")=$$P(.HDR,6),ARY("DTM")=$$P(.HDR,7)
"RTN","HLTPCK2",60,0)
 S ARY("SAN")=$$P(.HDR,3)
"RTN","HLTPCK2",61,0)
 S ARY("SFN")=$$P(.HDR,4)
"RTN","HLTPCK2",62,0)
 S ARY("RAN")=$$P(.HDR,5)
"RTN","HLTPCK2",63,0)
 S ARY("RFN")=$$P(.HDR,6)
"RTN","HLTPCK2",64,0)
 S ARY("DTM")=$$P(.HDR,7)
"RTN","HLTPCK2",65,0)
 ;
"RTN","HLTPCK2",66,0)
 I X="BHS"!(X="FHS") D
"RTN","HLTPCK2",67,0)
 . ; S ARY("MID")=$$P(.HDR,11),X=$$P(.HDR,9),ARY("PID")=$P(X,$E(ECH),2)
"RTN","HLTPCK2",68,0)
 . ;
"RTN","HLTPCK2",69,0)
 . S ARY("MID")=$$P(.HDR,11)
"RTN","HLTPCK2",70,0)
 . ;
"RTN","HLTPCK2",71,0)
 . ; BHS-9, Batch name/ID/Type:
"RTN","HLTPCK2",72,0)
 . ; 2nd component: Processing ID <sub> Processing Mode
"RTN","HLTPCK2",73,0)
 . ; 3rd component: Message Type <sub> Event Type
"RTN","HLTPCK2",74,0)
 . ; 4th component: Version ID
"RTN","HLTPCK2",75,0)
 . ; 5th component: Accept Acknowledgment Type
"RTN","HLTPCK2",76,0)
 . ; 6th component: Application Acknowledgment Type
"RTN","HLTPCK2",77,0)
 . S X=$$P(.HDR,9)
"RTN","HLTPCK2",78,0)
 . S:X]"" ARY("HDR-9")=X
"RTN","HLTPCK2",79,0)
 . ; original implementation incorrectly treats repetition separator as
"RTN","HLTPCK2",80,0)
 . ; subcomponent separator
"RTN","HLTPCK2",81,0)
 . S ECH("SUB-COMPONENT")=ECH(2)
"RTN","HLTPCK2",82,0)
 . ; if subcomponent separator is correctly applied
"RTN","HLTPCK2",83,0)
 . ; patch HL*1.6*133
"RTN","HLTPCK2",84,0)
 . ; I X[ECH(4) S ECH("SUB-COMPONENT")=ECH(4)
"RTN","HLTPCK2",85,0)
 . I ECH(4)]"",X[ECH(4) S ECH("SUB-COMPONENT")=ECH(4)
"RTN","HLTPCK2",86,0)
 . ;
"RTN","HLTPCK2",87,0)
 . S ARY("PID")=$P(X,ECH(1),2)
"RTN","HLTPCK2",88,0)
 . ; patch HL*1.6*133
"RTN","HLTPCK2",89,0)
 . ; I ARY("PID")[ECH("SUB-COMPONENT") D
"RTN","HLTPCK2",90,0)
 . I ECH("SUB-COMPONENT")]"",ARY("PID")[ECH("SUB-COMPONENT") D
"RTN","HLTPCK2",91,0)
 .. ; 2nd sub-component is Processing mode
"RTN","HLTPCK2",92,0)
 .. S ARY("PMOD")=$P(ARY("PID"),ECH("SUB-COMPONENT"),2)
"RTN","HLTPCK2",93,0)
 .. ; first sub-component is Processing id
"RTN","HLTPCK2",94,0)
 .. S ARY("PID")=$P(ARY("PID"),ECH("SUB-COMPONENT"))
"RTN","HLTPCK2",95,0)
 . ;
"RTN","HLTPCK2",96,0)
 . ; S ARY("MTN")=$P($P(X,$E(ECH),3),$E(ECH,2)),ARY("ETN")=$P($P(X,$E(ECH),3),$E(ECH,2),2)
"RTN","HLTPCK2",97,0)
 . ;
"RTN","HLTPCK2",98,0)
 . S ARY("MTN")=$P(X,ECH(1),3)
"RTN","HLTPCK2",99,0)
 . ; 2nd sub-component is event type
"RTN","HLTPCK2",100,0)
 . ;
"RTN","HLTPCK2",101,0)
 . ; patch HL*1.6*133 start
"RTN","HLTPCK2",102,0)
 . S ARY("ETN")=""
"RTN","HLTPCK2",103,0)
 . ; S ARY("ETN")=$P(ARY("MTN"),ECH("SUB-COMPONENT"),2)
"RTN","HLTPCK2",104,0)
 . I ECH("SUB-COMPONENT")]"" D
"RTN","HLTPCK2",105,0)
 .. S ARY("ETN")=$P(ARY("MTN"),ECH("SUB-COMPONENT"),2)
"RTN","HLTPCK2",106,0)
 . ; 1st sub-component is message type
"RTN","HLTPCK2",107,0)
 . ; S ARY("MTN")=$P(ARY("MTN"),ECH("SUB-COMPONENT"))
"RTN","HLTPCK2",108,0)
 . I ECH("SUB-COMPONENT")]"" D
"RTN","HLTPCK2",109,0)
 .. S ARY("MTN")=$P(ARY("MTN"),ECH("SUB-COMPONENT"))
"RTN","HLTPCK2",110,0)
 . ; patch HL*1.6*133 end
"RTN","HLTPCK2",111,0)
 . ;
"RTN","HLTPCK2",112,0)
 . ; S ARY("VER")=$P(X,$E(ECH),4),ARY("ACAT")=$P(X,$E(ECH),5),ARY("APAT")=$P(X,$E(ECH),6)
"RTN","HLTPCK2",113,0)
 . S ARY("VER")=$P(X,ECH(1),4)
"RTN","HLTPCK2",114,0)
 . S:$P(X,ECH(1),5)]"" ARY("ACAT")=$P(X,ECH(1),5)
"RTN","HLTPCK2",115,0)
 . S:$P(X,ECH(1),6)]"" ARY("APAT")=$P(X,ECH(1),6)
"RTN","HLTPCK2",116,0)
 . ;
"RTN","HLTPCK2",117,0)
 . ; BHS-10, batch comment
"RTN","HLTPCK2",118,0)
 . ; first component: MSA-1, acknowledgment code
"RTN","HLTPCK2",119,0)
 . ; 2nd component: MSA-3, text message
"RTN","HLTPCK2",120,0)
 . ; S:$$P(.HDR,10)]"" MSA=$P($$P(.HDR,10),$E(ECH),1),$P(MSA,FS,2)=$$P(.HDR,12),$P(MSA,FS,3)=$P($$P(.HDR,10),$E(ECH),2)
"RTN","HLTPCK2",121,0)
 . ;
"RTN","HLTPCK2",122,0)
 . S X=$$P(.HDR,10)
"RTN","HLTPCK2",123,0)
 . I X]"" D
"RTN","HLTPCK2",124,0)
 .. S ARY("HDR-10")=X
"RTN","HLTPCK2",125,0)
 .. ; MSA-1, acknowledgment code: AA,AE,AR,CA,CE,or CR
"RTN","HLTPCK2",126,0)
 .. S MSA=$P(X,ECH(1),1)
"RTN","HLTPCK2",127,0)
 .. ; MSA-2 and BHS-12, reference batch control id
"RTN","HLTPCK2",128,0)
 .. S $P(MSA,FS,2)=$$P(.HDR,12)
"RTN","HLTPCK2",129,0)
 .. ; MSA-3, text message
"RTN","HLTPCK2",130,0)
 .. S $P(MSA,FS,3)=$P(X,ECH(1),2)
"RTN","HLTPCK2",131,0)
 . ;
"RTN","HLTPCK2",132,0)
 . ; Reference Batch Control ID
"RTN","HLTPCK2",133,0)
 . S:$$P(.HDR,12)]"" ARY("HDR-12")=$$P(.HDR,12)
"RTN","HLTPCK2",134,0)
 ;
"RTN","HLTPCK2",135,0)
 ; I $$P(.HDR,1)="MSH" D
"RTN","HLTPCK2",136,0)
 I ARY("HDR-1")="MSH" D
"RTN","HLTPCK2",137,0)
 . ; S ARY("MID")=$$P(.HDR,10),ARY("PID")=$$P(.HDR,11),ARY("MTN")=$P($$P(.HDR,9),$E(ECH)),ARY("ETN")=$P($$P(.HDR,9),$E(ECH),2),ARY("VER")=$$P(.HDR,12)
"RTN","HLTPCK2",138,0)
 . S ARY("MID")=$$P(.HDR,10)
"RTN","HLTPCK2",139,0)
 . S ARY("PID")=$$P(.HDR,11)
"RTN","HLTPCK2",140,0)
 . S X=$$P(.HDR,9)
"RTN","HLTPCK2",141,0)
 . S ARY("MTN")=$P(X,ECH(1))
"RTN","HLTPCK2",142,0)
 . S ARY("ETN")=$P(X,ECH(1),2)
"RTN","HLTPCK2",143,0)
 . ;
"RTN","HLTPCK2",144,0)
 . ; S:$P($$P(.HDR,9),$E(ECH),3)'="" ARY("MTN_ETN")=$P($$P(.HDR,9),$E(ECH),3)
"RTN","HLTPCK2",145,0)
 . S:$P(X,ECH(1),3)]"" ARY("MTN_ETN")=$P(X,ECH(1),3)
"RTN","HLTPCK2",146,0)
 . ;
"RTN","HLTPCK2",147,0)
 . I ARY("PID")[ECH(1) D
"RTN","HLTPCK2",148,0)
 .. ; 2nd component is Processing mode
"RTN","HLTPCK2",149,0)
 .. S ARY("PMOD")=$P(ARY("PID"),ECH(1),2)
"RTN","HLTPCK2",150,0)
 .. ; first component is Processing id
"RTN","HLTPCK2",151,0)
 .. S ARY("PID")=$P(ARY("PID"),ECH(1))
"RTN","HLTPCK2",152,0)
 . ;
"RTN","HLTPCK2",153,0)
 . S ARY("VER")=$$P(.HDR,12)
"RTN","HLTPCK2",154,0)
 . ;
"RTN","HLTPCK2",155,0)
 . ; fields 13 and 14
"RTN","HLTPCK2",156,0)
 . S:$$P(.HDR,13)]"" ARY("MSH-13")=$$P(.HDR,13)
"RTN","HLTPCK2",157,0)
 . S:$$P(.HDR,14)]"" ARY("MSH-14")=$$P(.HDR,14)
"RTN","HLTPCK2",158,0)
 . ;
"RTN","HLTPCK2",159,0)
 . ; S:$$P(.HDR,15)]"" ARY("ACAT")=$$P(.HDR,15) S:$$P(.HDR,16)]"" ARY("APAT")=$$P(.HDR,16) S:$$P(.HDR,17)]"" ARY("CC")=$$P(.HDR,17)
"RTN","HLTPCK2",160,0)
 . S:$$P(.HDR,15)]"" ARY("ACAT")=$$P(.HDR,15)
"RTN","HLTPCK2",161,0)
 . S:$$P(.HDR,16)]"" ARY("APAT")=$$P(.HDR,16)
"RTN","HLTPCK2",162,0)
 . S:$$P(.HDR,17)]"" ARY("CC")=$$P(.HDR,17)
"RTN","HLTPCK2",163,0)
 . ;
"RTN","HLTPCK2",164,0)
 . ; fields 18,19,20 and 21
"RTN","HLTPCK2",165,0)
 . S:$$P(.HDR,18)]"" ARY("MSH-18")=$$P(.HDR,18)
"RTN","HLTPCK2",166,0)
 . S:$$P(.HDR,19)]"" ARY("MSH-19")=$$P(.HDR,19)
"RTN","HLTPCK2",167,0)
 . S:$$P(.HDR,20)]"" ARY("MSH-20")=$$P(.HDR,20)
"RTN","HLTPCK2",168,0)
 . S:$$P(.HDR,21)]"" ARY("MSH-21")=$$P(.HDR,21)
"RTN","HLTPCK2",169,0)
 ;
"RTN","HLTPCK2",170,0)
 ;Invoke continuation routine to perform remaining validation checks
"RTN","HLTPCK2",171,0)
 D ^HLTPCK2A
"RTN","HLTPCK2",172,0)
EXIT ;
"RTN","HLTPCK2",173,0)
 ; patch HL*1.6*120
"RTN","HLTPCK2",174,0)
 ; the maximum length of field #773,22 (Error Message) is 200
"RTN","HLTPCK2",175,0)
 I ERR]"" D
"RTN","HLTPCK2",176,0)
 . S ERR=$E(ERR,1,200)
"RTN","HLTPCK2",177,0)
 . S ARY=$S('ERR:"13^"_ERR,1:ERR)
"RTN","HLTPCK2",178,0)
 ; patch HL*1.6*120 end
"RTN","HLTPCK2",179,0)
 Q
"RTN","HLTPCK2",180,0)
 ;
"RTN","HLTPCK2",181,0)
P(MSH,P) ;get piece P from MSH array (passed by ref.)
"RTN","HLTPCK2",182,0)
 N FS,I,L,L1,L2,X,Y
"RTN","HLTPCK2",183,0)
 S FS=$E(MSH(1,0),4),(L2,Y)=0,X=""
"RTN","HLTPCK2",184,0)
 F I=1:1 S L1=$L($G(MSH(I,0)),FS),L=L1+Y-1 D  Q:$L(X)!'$D(MSH(I,0))
"RTN","HLTPCK2",185,0)
 . S:L1=1 L=L+1
"RTN","HLTPCK2",186,0)
 . S:P'>L X=$P($G(MSH(I-1,0)),FS,P-L2)_$P($G(MSH(I,0)),FS,(P-Y))
"RTN","HLTPCK2",187,0)
 . S L2=Y,Y=L
"RTN","HLTPCK2",188,0)
 Q X
"RTN","HLTPCK2",189,0)
 ;
"RTN","HLTPCK2A")
0^16^B28058257^B27212258
"RTN","HLTPCK2A",1,0)
HLTPCK2A ;SF/RSD - Message Header Validation (Con't) ;09/13/2006
"RTN","HLTPCK2A",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,57,59,66,108,120,133**;Oct 13, 1995;Build 13
"RTN","HLTPCK2A",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTPCK2A",4,0)
 S ERR=""
"RTN","HLTPCK2A",5,0)
 S HLPARAM=$$PARAM^HLCS2,HLDOM=$P(HLPARAM,U,2),HLINSTN=$P(HLPARAM,U,6)
"RTN","HLTPCK2A",6,0)
MT ;Validate message type
"RTN","HLTPCK2A",7,0)
 I (ARY("MTN")="") S:(ERR="") ERR="Invalid Message Type" Q
"RTN","HLTPCK2A",8,0)
 S ARY("MTP")=0
"RTN","HLTPCK2A",9,0)
 S:(ARY("MTN")'="") ARY("MTP")=+$O(^HL(771.2,"B",ARY("MTN"),0))
"RTN","HLTPCK2A",10,0)
 I ('ARY("MTP")) S:(ERR="") ERR="Invalid Message Type" Q
"RTN","HLTPCK2A",11,0)
 ;
"RTN","HLTPCK2A",12,0)
AT ;Determine if message is an acknowledgement type
"RTN","HLTPCK2A",13,0)
 I (("ACK,ADR,MCF,MFK,MFR,ORF,ORR,RRA,RRD,RRE,RRG,TBR"[ARY("MTN"))&($G(MSA)="")) S:(ERR="") ERR="MSA Segment Missing" Q
"RTN","HLTPCK2A",14,0)
 ;commit ack, quit
"RTN","HLTPCK2A",15,0)
 I $E($G(MSA))="C" D  Q
"RTN","HLTPCK2A",16,0)
 . ;find original msg.
"RTN","HLTPCK2A",17,0)
 . S ARY("MSAID")=$P(MSA,FS,2),ARY("MTIENS")=0
"RTN","HLTPCK2A",18,0)
 . I ARY("MSAID")="" S:(ERR="") ERR="Invalid Message Control ID in MSA Segment - No Message ID " Q
"RTN","HLTPCK2A",19,0)
 . F  S ARY("MTIENS")=+$O(^HLMA("C",ARY("MSAID"),ARY("MTIENS"))) Q:'ARY("MTIENS")!($P($G(^HLMA(ARY("MTIENS"),0)),U,3)="O")
"RTN","HLTPCK2A",20,0)
 . I 'ARY("MTIENS") S:(ERR="") ERR="Invalid Message Control ID in MSA Segment - No message IEN in ""C"" x-ref" Q
"RTN","HLTPCK2A",21,0)
 . Q
"RTN","HLTPCK2A",22,0)
AAT ;Validate accept ack type and application ack type
"RTN","HLTPCK2A",23,0)
 I ($G(ARY("ACAT"))'="") I ("AL,NE,ER,SU"'[ARY("ACAT")) S:(ERR="") ERR="Invalid accept ack type" Q
"RTN","HLTPCK2A",24,0)
 I ($G(ARY("APAT"))'="") I ("AL,NE,ER,SU"'[ARY("APAT")) S:(ERR="") ERR="Invalid application ack type" Q
"RTN","HLTPCK2A",25,0)
 ;
"RTN","HLTPCK2A",26,0)
 ;
"RTN","HLTPCK2A",27,0)
RA ;Validate receiving application
"RTN","HLTPCK2A",28,0)
 I (ARY("RAN")']"") S:(ERR="") ERR="Invalid Receiving Application" Q
"RTN","HLTPCK2A",29,0)
 S ARY("RAP")=0
"RTN","HLTPCK2A",30,0)
 S:ARY("RAN")]"" ARY("RAP")=+$O(^HL(771,"B",$E(ARY("RAN"),1,30),0))
"RTN","HLTPCK2A",31,0)
 I 'ARY("RAP"),ARY("RAN")'="" D
"RTN","HLTPCK2A",32,0)
 .S X=$$UPPER^HLFNC(ARY("RAN"))
"RTN","HLTPCK2A",33,0)
 .S ARY("RAP")=+$O(^HL(771,"B",$E(ARY("RAN"),1,30),0))
"RTN","HLTPCK2A",34,0)
 ;
"RTN","HLTPCK2A",35,0)
 ; patch HL*1.6*120 start
"RTN","HLTPCK2A",36,0)
 I ($L(ARY("RAN"),ECH(1))>1) D
"RTN","HLTPCK2A",37,0)
 . S ARY("RAN-SUB1")=$P(ARY("RAN"),ECH(1))
"RTN","HLTPCK2A",38,0)
 . S ARY("RAN-SUB2")=$P(ARY("RAN"),ECH(1),2)
"RTN","HLTPCK2A",39,0)
 . S ARY("RAN-SUB3")=$P(ARY("RAN"),ECH(1),3)
"RTN","HLTPCK2A",40,0)
 . I 'ARY("RAP"),ARY("RAN-SUB1")]"" D
"RTN","HLTPCK2A",41,0)
 .. S ARY("RAP")=+$O(^HL(771,"B",$E(ARY("RAN-SUB1"),1,30),0))
"RTN","HLTPCK2A",42,0)
 . I ARY("RAN-SUB1")[ECH(3) D
"RTN","HLTPCK2A",43,0)
 .. S ARY("RAN-SUB1-DEESCAPE")=$$DEESCAPE(ARY("RAN-SUB1"))
"RTN","HLTPCK2A",44,0)
 . I ARY("RAN-SUB2")[ECH(3) D
"RTN","HLTPCK2A",45,0)
 .. S ARY("RAN-SUB2-DEESCAPE")=$$DEESCAPE(ARY("RAN-SUB2"))
"RTN","HLTPCK2A",46,0)
 . I ARY("RAN-SUB3")[ECH(3) D
"RTN","HLTPCK2A",47,0)
 .. S ARY("RAN-SUB3-DEESCAPE")=$$DEESCAPE(ARY("RAN-SUB3"))
"RTN","HLTPCK2A",48,0)
 . I 'ARY("RAP"),$G(ARY("RAN-SUB1-DEESCAPE"))]"" D
"RTN","HLTPCK2A",49,0)
 .. S ARY("RAP")=+$O(^HL(771,"B",$E(ARY("RAN-SUB1-DEESCAPE"),1,30),0))
"RTN","HLTPCK2A",50,0)
 I ARY("RAN")[ECH(3) D
"RTN","HLTPCK2A",51,0)
 . S ARY("RAN-DEESCAPE")=$$DEESCAPE(ARY("RAN"))
"RTN","HLTPCK2A",52,0)
 I 'ARY("RAP"),$G(ARY("RAN-DEESCAPE"))]"" D
"RTN","HLTPCK2A",53,0)
 . S ARY("RAP")=+$O(^HL(771,"B",$E(ARY("RAN-DEESCAPE"),1,30),0))
"RTN","HLTPCK2A",54,0)
 ; patch HL*1.6*120 end
"RTN","HLTPCK2A",55,0)
 ;
"RTN","HLTPCK2A",56,0)
 I ('ARY("RAP")) S:(ERR="") ERR="Invalid Receiving Application" Q
"RTN","HLTPCK2A",57,0)
 S X2=$G(^HL(771,ARY("RAP"),0))
"RTN","HLTPCK2A",58,0)
 I (X2="") S:(ERR="") ERR="Invalid Receiving Application" Q
"RTN","HLTPCK2A",59,0)
 I ($P(X2,"^",2)'="a") S:(ERR="") ERR="Receiving Application is Inactive" Q
"RTN","HLTPCK2A",60,0)
 ;
"RTN","HLTPCK2A",61,0)
SA ;Validate sending application
"RTN","HLTPCK2A",62,0)
 I (ARY("SAN")']"") S:(ERR="") ERR="Invalid Sending Application" Q
"RTN","HLTPCK2A",63,0)
 S ARY("SAP")=0
"RTN","HLTPCK2A",64,0)
 S:(ARY("SAN")]"") ARY("SAP")=+$O(^HL(771,"B",$E(ARY("SAN"),1,30),0))
"RTN","HLTPCK2A",65,0)
 I (('ARY("SAP"))&(ARY("SAN")'="")) D
"RTN","HLTPCK2A",66,0)
 .S X=$$UPPER^HLFNC(ARY("SAN"))
"RTN","HLTPCK2A",67,0)
 .S ARY("SAP")=+$O(^HL(771,"B",$E(ARY("SAN"),1,30),0))
"RTN","HLTPCK2A",68,0)
 ;
"RTN","HLTPCK2A",69,0)
 ; patch HL*1.6*120 start
"RTN","HLTPCK2A",70,0)
 I ($L(ARY("SAN"),ECH(1))>1) D
"RTN","HLTPCK2A",71,0)
 . S ARY("SAN-SUB1")=$P(ARY("SAN"),ECH(1))
"RTN","HLTPCK2A",72,0)
 . S ARY("SAN-SUB2")=$P(ARY("SAN"),ECH(1),2)
"RTN","HLTPCK2A",73,0)
 . S ARY("SAN-SUB3")=$P(ARY("SAN"),ECH(1),3)
"RTN","HLTPCK2A",74,0)
 . I 'ARY("SAP"),ARY("SAN-SUB1")]"" D
"RTN","HLTPCK2A",75,0)
 .. S ARY("SAP")=+$O(^HL(771,"B",$E(ARY("SAN-SUB1"),1,30),0))
"RTN","HLTPCK2A",76,0)
 . I ARY("SAN-SUB1")[ECH(3) D
"RTN","HLTPCK2A",77,0)
 .. S ARY("SAN-SUB1-DEESCAPE")=$$DEESCAPE(ARY("SAN-SUB1"))
"RTN","HLTPCK2A",78,0)
 . I ARY("SAN-SUB2")[ECH(3) D
"RTN","HLTPCK2A",79,0)
 .. S ARY("SAN-SUB2-DEESCAPE")=$$DEESCAPE(ARY("SAN-SUB2"))
"RTN","HLTPCK2A",80,0)
 . I ARY("SAN-SUB3")[ECH(3) D
"RTN","HLTPCK2A",81,0)
 .. S ARY("SAN-SUB3-DEESCAPE")=$$DEESCAPE(ARY("SAN-SUB3"))
"RTN","HLTPCK2A",82,0)
 . I 'ARY("SAP"),$G(ARY("SAN-SUB1-DEESCAPE"))]"" D
"RTN","HLTPCK2A",83,0)
 .. S ARY("SAP")=+$O(^HL(771,"B",$E(ARY("SAN-SUB1-DEESCAPE"),1,30),0))
"RTN","HLTPCK2A",84,0)
 I ARY("SAN")[ECH(3) D
"RTN","HLTPCK2A",85,0)
 . S ARY("SAN-DEESCAPE")=$$DEESCAPE(ARY("SAN"))
"RTN","HLTPCK2A",86,0)
 I 'ARY("SAP"),$G(ARY("SAN-DEESCAPE"))]"" D
"RTN","HLTPCK2A",87,0)
 . S ARY("SAP")=+$O(^HL(771,"B",$E(ARY("SAN-DEESCAPE"),1,30),0))
"RTN","HLTPCK2A",88,0)
 ; patch HL*1.6*120 end
"RTN","HLTPCK2A",89,0)
 ;
"RTN","HLTPCK2A",90,0)
 I ('ARY("SAP")) S:(ERR="") ERR="Invalid Sending Application" Q
"RTN","HLTPCK2A",91,0)
 ;
"RTN","HLTPCK2A",92,0)
VN ;Validate version number
"RTN","HLTPCK2A",93,0)
 I (ARY("VER")="") S:(ERR="") ERR="Missing HL7 Version" Q
"RTN","HLTPCK2A",94,0)
 S X=0
"RTN","HLTPCK2A",95,0)
 S:(ARY("VER")'="") X=+$O(^HL(771.5,"B",ARY("VER"),0))
"RTN","HLTPCK2A",96,0)
 S ARY("VEP")=X
"RTN","HLTPCK2A",97,0)
 I ('X) S:(ERR="") ERR="Invalid HL7 Version" Q
"RTN","HLTPCK2A",98,0)
 ;I (X'=$P($G(HLN(770)),"^",10)) S:(ERR="") ERR="Invalid HL7 Version for Receiving Application" Q
"RTN","HLTPCK2A",99,0)
 ;
"RTN","HLTPCK2A",100,0)
ET ;Event Type Checks
"RTN","HLTPCK2A",101,0)
 ;
"RTN","HLTPCK2A",102,0)
 ;I ARY("ETN")="",ARY("VER")>2.1,$G(MSA)'="" D
"RTN","HLTPCK2A",103,0)
 ;. ;N Z,ZEP,ZP
"RTN","HLTPCK2A",104,0)
 ;. ;S Z=0 I $P(MSA,FS,2)]"" S Z=+$O(^HLMA("C",$P(MSA,FS,2),0))
"RTN","HLTPCK2A",105,0)
 ;. ;I '$G(^HLMA(Z,0)) S:(ERR="") ERR="Original Outgoing Message not found" Q
"RTN","HLTPCK2A",106,0)
 ;. ;S ZEP=$P(^HLMA(Z,0),U,8)
"RTN","HLTPCK2A",107,0)
 ;. ;I 'ZEP S:(ERR="") ERR="Event Protocol pointer (field #773,8) missing" Q
"RTN","HLTPCK2A",108,0)
 ;. ;S ZP=$G(^ORD(101,ZEP,770)),ARY("ETN")=$P($G(^HL(779.001,+$P(ZP,U,4),0)),U)
"RTN","HLTPCK2A",109,0)
 ;
"RTN","HLTPCK2A",110,0)
 ;Validate event type
"RTN","HLTPCK2A",111,0)
 I (ARY("ETN")=""),ARY("VER")>2.1,$G(MSA)="" S ERR="Event Type Required" Q
"RTN","HLTPCK2A",112,0)
 S ARY("ETP")=0
"RTN","HLTPCK2A",113,0)
 S:(ARY("ETN")'="") ARY("ETP")=+$O(^HL(779.001,"B",ARY("ETN"),0))
"RTN","HLTPCK2A",114,0)
 I $G(MSA)="",ARY("VER")>2.1,('ARY("ETP")) S ERR="Invalid Event Type" Q
"RTN","HLTPCK2A",115,0)
 ;
"RTN","HLTPCK2A",116,0)
 D ^HLTPCK2B
"RTN","HLTPCK2A",117,0)
 Q
"RTN","HLTPCK2A",118,0)
DEESCAPE(INPUT) ;
"RTN","HLTPCK2A",119,0)
 ; patch HL*1.6*120 - de-escape delimiters
"RTN","HLTPCK2A",120,0)
 ; (assuming "\" is the escape character):
"RTN","HLTPCK2A",121,0)
 ; - field separator (de-escape from \F\)
"RTN","HLTPCK2A",122,0)
 ; - component separator (de-escape from \S\)
"RTN","HLTPCK2A",123,0)
 ; - repetition separator (de-escape from \R\)
"RTN","HLTPCK2A",124,0)
 ; - escape character (de-escape from \E\)
"RTN","HLTPCK2A",125,0)
 ; - subcomponent separator (de-escape from \T\)
"RTN","HLTPCK2A",126,0)
 ; \F\ will be de-escaped only if the length of FS is 1.
"RTN","HLTPCK2A",127,0)
 ;
"RTN","HLTPCK2A",128,0)
 ; input:
"RTN","HLTPCK2A",129,0)
 ; INPUT - input string to be de-escaped
"RTN","HLTPCK2A",130,0)
 ; FS - field separator
"RTN","HLTPCK2A",131,0)
 ; ECH - encoding characters
"RTN","HLTPCK2A",132,0)
 ; 
"RTN","HLTPCK2A",133,0)
 ; output: de-escaped string
"RTN","HLTPCK2A",134,0)
 ;
"RTN","HLTPCK2A",135,0)
 N HLDATA,HLESCAPE,HLI,HLCHAR,HLCHAR23,HLEN,HLOUT
"RTN","HLTPCK2A",136,0)
 S HLDATA=$G(INPUT)
"RTN","HLTPCK2A",137,0)
 Q:HLDATA']"" HLDATA
"RTN","HLTPCK2A",138,0)
 ;
"RTN","HLTPCK2A",139,0)
 ; patch HL*1.6*133
"RTN","HLTPCK2A",140,0)
 Q:$L($G(ECH))<3 HLDATA
"RTN","HLTPCK2A",141,0)
 ;
"RTN","HLTPCK2A",142,0)
 S ECH(1)=$E(ECH,1)
"RTN","HLTPCK2A",143,0)
 S ECH(2)=$E(ECH,2)
"RTN","HLTPCK2A",144,0)
 S ECH(3)=$E(ECH,3)
"RTN","HLTPCK2A",145,0)
 S ECH(4)=$E(ECH,4)
"RTN","HLTPCK2A",146,0)
 ;
"RTN","HLTPCK2A",147,0)
 S HLEN=$L(HLDATA)
"RTN","HLTPCK2A",148,0)
 S HLOUT=""
"RTN","HLTPCK2A",149,0)
 F HLI=1:1:HLEN D
"RTN","HLTPCK2A",150,0)
 . S HLCHAR=$E(HLDATA,HLI)
"RTN","HLTPCK2A",151,0)
 . I HLCHAR=ECH(3) D
"RTN","HLTPCK2A",152,0)
 . S HLCHAR23=$E(HLDATA,HLI+1,HLI+2)
"RTN","HLTPCK2A",153,0)
 . I $L($G(FS))=1,(HLCHAR23=("F"_ECH(3))) D  Q
"RTN","HLTPCK2A",154,0)
 .. S HLOUT=HLOUT_FS
"RTN","HLTPCK2A",155,0)
 .. S HLI=HLI+2
"RTN","HLTPCK2A",156,0)
 . I HLCHAR23=("S"_ECH(3)) D  Q
"RTN","HLTPCK2A",157,0)
 .. S HLOUT=HLOUT_ECH(1)
"RTN","HLTPCK2A",158,0)
 .. S HLI=HLI+2
"RTN","HLTPCK2A",159,0)
 . I HLCHAR23=("R"_ECH(3)) D  Q
"RTN","HLTPCK2A",160,0)
 .. S HLOUT=HLOUT_ECH(2)
"RTN","HLTPCK2A",161,0)
 .. S HLI=HLI+2
"RTN","HLTPCK2A",162,0)
 . I HLCHAR23=("E"_ECH(3)) D  Q
"RTN","HLTPCK2A",163,0)
 .. S HLOUT=HLOUT_ECH(3)
"RTN","HLTPCK2A",164,0)
 .. S HLI=HLI+2
"RTN","HLTPCK2A",165,0)
 . I $L($G(ECH))>3,(HLCHAR23=("T"_ECH(3))) D  Q
"RTN","HLTPCK2A",166,0)
 .. S HLOUT=HLOUT_ECH(4)
"RTN","HLTPCK2A",167,0)
 .. S HLI=HLI+2
"RTN","HLTPCK2A",168,0)
 . S HLOUT=HLOUT_HLCHAR
"RTN","HLTPCK2A",169,0)
 ;
"RTN","HLTPCK2A",170,0)
 Q HLOUT
"RTN","HLTPCK2B")
0^20^B64470063^B63390233
"RTN","HLTPCK2B",1,0)
HLTPCK2B ;OIFO-O/RJH - Message Header Validation (Con't) ;09/13/2006
"RTN","HLTPCK2B",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**120,133**;Oct 13, 1995;Build 13
"RTN","HLTPCK2B",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTPCK2B",4,0)
 ;
"RTN","HLTPCK2B",5,0)
 ; splitted from HLTPCK2A
"RTN","HLTPCK2B",6,0)
 ; to be called from HLTPCK2A
"RTN","HLTPCK2B",7,0)
 ;
"RTN","HLTPCK2B",8,0)
MS ;Check for Message Structure Code
"RTN","HLTPCK2B",9,0)
 I $G(ARY("MTN_ETN"))'="" D
"RTN","HLTPCK2B",10,0)
 . S ARY("MTP_ETP")=0
"RTN","HLTPCK2B",11,0)
 . S ARY("MTP_ETP")=+$O(^HL(779.005,"B",ARY("MTN_ETN"),0))
"RTN","HLTPCK2B",12,0)
 . I ('ARY("MTP_ETP")) S:(ERR="") ERR="Invalid Message Structure Code" Q
"RTN","HLTPCK2B",13,0)
 ;
"RTN","HLTPCK2B",14,0)
 ;Get server and client Protocols
"RTN","HLTPCK2B",15,0)
MSA ;if ack, then get information and quit, we don't need to respond
"RTN","HLTPCK2B",16,0)
 I $G(MSA)]"" D  Q
"RTN","HLTPCK2B",17,0)
 . ;Message is an acknowledgement, find original message
"RTN","HLTPCK2B",18,0)
 . S ARY("MSAID")=$P(MSA,FS,2),ARY("MTIENS")=0
"RTN","HLTPCK2B",19,0)
 . I ARY("MSAID")="" S:(ERR="") ERR="Invalid Message Control ID in MSA Segment - No Message ID" Q
"RTN","HLTPCK2B",20,0)
 . F  S ARY("MTIENS")=+$O(^HLMA("AH",ARY("SAP"),ARY("MSAID"),ARY("MTIENS"))) Q:'ARY("MTIENS")!($P($G(^HLMA(ARY("MTIENS"),0)),U,3)="O")
"RTN","HLTPCK2B",21,0)
 . I 'ARY("MTIENS") S:(ERR="") ERR="Invalid Message Control ID in MSA Segment - No message IEN in ""AH"" x-ref" Q
"RTN","HLTPCK2B",22,0)
 . ;get subscriber protocol and ack. to (show if this is an ack to an ack)
"RTN","HLTPCK2B",23,0)
 . S X=$G(^HLMA(ARY("MTIENS"),0)),ARY("EIDS")=$P(X,U,8),ARY("ACK")=$P(X,U,10)
"RTN","HLTPCK2B",24,0)
 . ;if no subscriber protocol then response msg. is invalid
"RTN","HLTPCK2B",25,0)
 . I ('ARY("EIDS")) S:(ERR="") ERR="Invalid Message Control ID in MSA Segment - No Subscr. IEN in 773" Q
"RTN","HLTPCK2B",26,0)
 . ;get message text ien in file 772 and server protocol, 'EID'
"RTN","HLTPCK2B",27,0)
 . S ARY("MTIEN")=+X,X=$G(^HL(772,+X,0)),ARY("EID")=$P(X,U,10)
"RTN","HLTPCK2B",28,0)
 . I ('ARY("EID")) S:(ERR="") ERR="Event Protocol not found" Q
"RTN","HLTPCK2B",29,0)
 . D EVENT^HLUTIL1(ARY("EIDS"),"770,773",.HLN)
"RTN","HLTPCK2B",30,0)
 ;
"RTN","HLTPCK2B",31,0)
 ;Find Server Protocol - based on sending application, message type,
"RTN","HLTPCK2B",32,0)
 ;event type and version ID
"RTN","HLTPCK2B",33,0)
 I ARY("ETP") S ARY("EID")=+$O(^ORD(101,"AHL1",ARY("SAP"),ARY("MTP"),ARY("ETP"),ARY("VEP"),0))
"RTN","HLTPCK2B",34,0)
 ;
"RTN","HLTPCK2B",35,0)
 ;Find Server Protocol - based on sending application, message type,
"RTN","HLTPCK2B",36,0)
 ;and version ID
"RTN","HLTPCK2B",37,0)
 I 'ARY("ETP") S ARY("EID")=+$O(^ORD(101,"AHL21",ARY("SAP"),ARY("MTP"),ARY("VEP"),0))
"RTN","HLTPCK2B",38,0)
 ;
"RTN","HLTPCK2B",39,0)
 I ('ARY("EID")) S:(ERR="") ERR="Event Protocol not found" Q
"RTN","HLTPCK2B",40,0)
 ;Find Client Protocol - in ITEM multiple of Server Protocol
"RTN","HLTPCK2B",41,0)
 S ARY("EIDS")=0
"RTN","HLTPCK2B",42,0)
 F  S ARY("EIDS")=+$O(^ORD(101,ARY("EID"),775,"B",ARY("EIDS"))) Q:'ARY("EIDS")!($P($G(^ORD(101,ARY("EIDS"),770)),U,2)=ARY("RAP"))
"RTN","HLTPCK2B",43,0)
 I 'ARY("EIDS") S ERR="Invalid Receiving Application for this Event" Q
"RTN","HLTPCK2B",44,0)
 D EVENT^HLUTIL1(ARY("EIDS"),"770,773",.HLN)
"RTN","HLTPCK2B",45,0)
 ;
"RTN","HLTPCK2B",46,0)
LLP ;Get logical link pointer
"RTN","HLTPCK2B",47,0)
 S ARY("LL")=$P($G(HLN(770)),"^",7)
"RTN","HLTPCK2B",48,0)
 ;
"RTN","HLTPCK2B",49,0)
FAC ;Get sending/rec facility, validate if necessary
"RTN","HLTPCK2B",50,0)
 ;
"RTN","HLTPCK2B",51,0)
 S HLCS=$E(ECH,1) ;Get component separator
"RTN","HLTPCK2B",52,0)
 S ARY("RAF")=$$P^HLTPCK2(.HDR,6) ;Receiving Facility
"RTN","HLTPCK2B",53,0)
 S ARY("SAF")=$$P^HLTPCK2(.HDR,4) ;Sending Facility
"RTN","HLTPCK2B",54,0)
 ;Get sending/receiving facility from Application Parameter file(771)
"RTN","HLTPCK2B",55,0)
 S HL771SF=$P($G(^HL(771,ARY("SAP"),0)),U,3)
"RTN","HLTPCK2B",56,0)
 S HL771RF=$P($G(^HL(771,ARY("RAP"),0)),U,3)
"RTN","HLTPCK2B",57,0)
 ;Sending/Receiving facility required?
"RTN","HLTPCK2B",58,0)
 S X=$G(^ORD(101,ARY("EIDS"),773))
"RTN","HLTPCK2B",59,0)
 S HLSFREQ=+X,HLRFREQ=+$P(X,U,2)
"RTN","HLTPCK2B",60,0)
RF ;Validate Receiving Facility
"RTN","HLTPCK2B",61,0)
 I HLRFREQ D
"RTN","HLTPCK2B",62,0)
 .I ARY("RAF")="" S:ERR="" ERR="Missing required receiving facility"
"RTN","HLTPCK2B",63,0)
 .I HL771RF]"" D  Q
"RTN","HLTPCK2B",64,0)
 ..;Facility data in 771 overrides data in site paramter file
"RTN","HLTPCK2B",65,0)
 ..Q
"RTN","HLTPCK2B",66,0)
 .;Check against local default value (site parameters)
"RTN","HLTPCK2B",67,0)
 .Q:ARY("RAF")=(HLINSTN_HLCS_HLDOM_HLCS_"DNS")
"RTN","HLTPCK2B",68,0)
 .;
"RTN","HLTPCK2B",69,0)
 .; patch HL*1.6*120 start
"RTN","HLTPCK2B",70,0)
 .; I $P(ARY("RAF"),HLCS)=HLINSTN,$P(ARY("RAF"),HLCS,3)="DNS" D  Q
"RTN","HLTPCK2B",71,0)
 . I $P(ARY("RAF"),HLCS,3)="DNS" D  Q
"RTN","HLTPCK2B",72,0)
 .. N ERROR,HLDOMP1,HLDOMP2
"RTN","HLTPCK2B",73,0)
 .. ; S HLDOMP1=$P(ARY("RAF"),HLCS,2),HLDOMP1=$$FIND1^DIC(4.2,"","BMX",HLDOMP1,"B^C","","ERROR")
"RTN","HLTPCK2B",74,0)
 .. S HLDOMP1=$P(ARY("RAF"),HLCS,2)
"RTN","HLTPCK2B",75,0)
 .. ;
"RTN","HLTPCK2B",76,0)
 .. ; assume the format is <domain>:<port #>
"RTN","HLTPCK2B",77,0)
 .. I HLDOMP1[":" S ARY("RAF-PORT")=$P(HLDOMP1,":",2)
"RTN","HLTPCK2B",78,0)
 .. S HLDOMP1=$P(HLDOMP1,":")
"RTN","HLTPCK2B",79,0)
 .. S ARY("RAF-DOMAIN")=HLDOMP1
"RTN","HLTPCK2B",80,0)
 .. ;
"RTN","HLTPCK2B",81,0)
 .. ; if first piece of domain is "HL7." or "MPI.", remove it
"RTN","HLTPCK2B",82,0)
 .. I ($E(HLDOMP1,1,4)="HL7.")!($E(HLDOMP1,1,4)="MPI.") D
"RTN","HLTPCK2B",83,0)
 ... S HLDOMP1=$P(HLDOMP1,".",2,99)
"RTN","HLTPCK2B",84,0)
 .. S HLDOMP1=$$FIND1^DIC(4.2,"","BMX",HLDOMP1,"B^C","","ERROR")
"RTN","HLTPCK2B",85,0)
 .. S HLDOMP2=HLDOM,HLDOMP2=$$FIND1^DIC(4.2,"","BMX",HLDOMP2,"B^C","","ERROR")
"RTN","HLTPCK2B",86,0)
 .. I HLDOMP1&HLDOMP2&(HLDOMP1=HLDOMP2) Q
"RTN","HLTPCK2B",87,0)
 .. ;
"RTN","HLTPCK2B",88,0)
 .. ; check DNS domain and ip address
"RTN","HLTPCK2B",89,0)
 .. ;initialize variable, HLDOMP("FLAG")
"RTN","HLTPCK2B",90,0)
 .. S HLDOMP("FLAG")=0
"RTN","HLTPCK2B",91,0)
 .. I ARY("RAF-DOMAIN")]"" D
"RTN","HLTPCK2B",92,0)
 ... ;
"RTN","HLTPCK2B",93,0)
 ... ; match DNS domain
"RTN","HLTPCK2B",94,0)
 ... I $D(^HLCS(870,"DNS",ARY("RAF-DOMAIN"))) D  Q
"RTN","HLTPCK2B",95,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",96,0)
 .... S ARY("RAF-LL")=+$O(^HLCS(870,"DNS",ARY("RAF-DOMAIN"),0))
"RTN","HLTPCK2B",97,0)
 ... I $D(^HLCS(870,"DNS",$$UP^XLFSTR(ARY("RAF-DOMAIN")))) D  Q
"RTN","HLTPCK2B",98,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",99,0)
 .... S ARY("RAF-LL")=+$O(^HLCS(870,"DNS",$$UP^XLFSTR(ARY("RAF-DOMAIN")),0))
"RTN","HLTPCK2B",100,0)
 ... I $D(^HLCS(870,"DNS",$$LOW^XLFSTR(ARY("RAF-DOMAIN")))) D  Q
"RTN","HLTPCK2B",101,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",102,0)
 .... S ARY("RAF-LL")=+$O(^HLCS(870,"DNS",$$LOW^XLFSTR(ARY("RAF-DOMAIN")),0))
"RTN","HLTPCK2B",103,0)
 ... ;
"RTN","HLTPCK2B",104,0)
 ... ; match ip address
"RTN","HLTPCK2B",105,0)
 ... I $D(^HLCS(870,"IP",ARY("RAF-DOMAIN"))) D  Q
"RTN","HLTPCK2B",106,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",107,0)
 .... S ARY("RAF-LL")=+$O(^HLCS(870,"IP",ARY("RAF-DOMAIN"),0))
"RTN","HLTPCK2B",108,0)
 .. Q:HLDOMP("FLAG")=1
"RTN","HLTPCK2B",109,0)
 .. I $P(ARY("RAF"),HLCS)=HLINSTN Q
"RTN","HLTPCK2B",110,0)
 .. ;
"RTN","HLTPCK2B",111,0)
 .. S:ERR="" ERR="Receiving Facility mismatch."
"RTN","HLTPCK2B",112,0)
 . I $P(ARY("RAF"),HLCS)=HLINSTN Q
"RTN","HLTPCK2B",113,0)
 . S:ERR="" ERR="Receiving Facility mismatch."
"RTN","HLTPCK2B",114,0)
 ; patch HL*1.6*120 end
"RTN","HLTPCK2B",115,0)
 ;
"RTN","HLTPCK2B",116,0)
SF ;Validate Sending Facility
"RTN","HLTPCK2B",117,0)
 I HLSFREQ D
"RTN","HLTPCK2B",118,0)
 .I ARY("SAF")="" S:ERR="" ERR="Missing required sending facility"
"RTN","HLTPCK2B",119,0)
 .I HL771SF]"" D  Q
"RTN","HLTPCK2B",120,0)
 ..;Check for facility data in 771
"RTN","HLTPCK2B",121,0)
 ..Q
"RTN","HLTPCK2B",122,0)
 .;If default value was sent, validate that DOMAIN RESOLVES TO LOGICAL LINK
"RTN","HLTPCK2B",123,0)
 .;If so, use this instead of Protocol definition for return path
"RTN","HLTPCK2B",124,0)
 .;
"RTN","HLTPCK2B",125,0)
 .; patch HL*1.6*120 start
"RTN","HLTPCK2B",126,0)
 . N HLDOMP
"RTN","HLTPCK2B",127,0)
 . ; S HLDOMP=$P(ARY("SAF"),HLCS,2),HLDOMP=$$FIND1^DIC(4.2,"","BMX",HLDOMP,"B^C","","ERROR")
"RTN","HLTPCK2B",128,0)
 . S HLDOMP=$P(ARY("SAF"),HLCS,2)
"RTN","HLTPCK2B",129,0)
 . ;
"RTN","HLTPCK2B",130,0)
 . ; assume the format is <domain>:<port #>
"RTN","HLTPCK2B",131,0)
 . I HLDOMP[":" S ARY("SAF-PORT")=$P(HLDOMP,":",2)
"RTN","HLTPCK2B",132,0)
 . S HLDOMP=$P(HLDOMP,":")
"RTN","HLTPCK2B",133,0)
 . S ARY("SAF-DOMAIN")=HLDOMP
"RTN","HLTPCK2B",134,0)
 . ;
"RTN","HLTPCK2B",135,0)
 . ; if first piece of domain is "HL7." or "MPI.", remove it
"RTN","HLTPCK2B",136,0)
 . I ($E(HLDOMP,1,4)="HL7.")!($E(HLDOMP,1,4)="MPI.") D
"RTN","HLTPCK2B",137,0)
 .. S HLDOMP=$P(HLDOMP,".",2,99)
"RTN","HLTPCK2B",138,0)
 . S HLDOMP=$$FIND1^DIC(4.2,"","BMX",HLDOMP,"B^C","","ERROR")
"RTN","HLTPCK2B",139,0)
 .;Note: This expects a unique domain in domain file. Multiple entries will fail
"RTN","HLTPCK2B",140,0)
 . ; I 'HLDOMP S:ERR="" ERR="Unrecognized/ambiguous domain in sending facility"
"RTN","HLTPCK2B",141,0)
 . ;
"RTN","HLTPCK2B",142,0)
 . ; check DNS domain and ip address
"RTN","HLTPCK2B",143,0)
 . I 'HLDOMP D
"RTN","HLTPCK2B",144,0)
 .. ;
"RTN","HLTPCK2B",145,0)
 .. ;initialize variable, HLDOMP("FLAG")
"RTN","HLTPCK2B",146,0)
 .. S HLDOMP("FLAG")=0
"RTN","HLTPCK2B",147,0)
 .. I ARY("SAF-DOMAIN")]"" D
"RTN","HLTPCK2B",148,0)
 ... ;
"RTN","HLTPCK2B",149,0)
 ... ; match DNS domain
"RTN","HLTPCK2B",150,0)
 ... I $D(^HLCS(870,"DNS",ARY("SAF-DOMAIN"))) D  Q
"RTN","HLTPCK2B",151,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",152,0)
 .... S ARY("SAF-LL")=+$O(^HLCS(870,"DNS",ARY("SAF-DOMAIN"),0))
"RTN","HLTPCK2B",153,0)
 ... I $D(^HLCS(870,"DNS",$$UP^XLFSTR(ARY("SAF-DOMAIN")))) D  Q
"RTN","HLTPCK2B",154,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",155,0)
 .... S ARY("SAF-LL")=+$O(^HLCS(870,"DNS",$$UP^XLFSTR(ARY("SAF-DOMAIN")),0))
"RTN","HLTPCK2B",156,0)
 ... I $D(^HLCS(870,"DNS",$$LOW^XLFSTR(ARY("SAF-DOMAIN")))) D  Q
"RTN","HLTPCK2B",157,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",158,0)
 .... S ARY("SAF-LL")=+$O(^HLCS(870,"DNS",$$LOW^XLFSTR(ARY("SAF-DOMAIN")),0))
"RTN","HLTPCK2B",159,0)
 ... ;
"RTN","HLTPCK2B",160,0)
 ... ; match ip address
"RTN","HLTPCK2B",161,0)
 ... I $D(^HLCS(870,"IP",ARY("SAF-DOMAIN"))) D  Q
"RTN","HLTPCK2B",162,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",163,0)
 .... S ARY("SAF-LL")=+$O(^HLCS(870,"IP",ARY("SAF-DOMAIN"),0))
"RTN","HLTPCK2B",164,0)
 .. Q:HLDOMP("FLAG")=1
"RTN","HLTPCK2B",165,0)
 .. ; quit if 1st component defined
"RTN","HLTPCK2B",166,0)
 .. S ARY("SAF-COMPONENT1")=$P(ARY("SAF"),HLCS,1)
"RTN","HLTPCK2B",167,0)
 .. Q:ARY("SAF-COMPONENT1")]""
"RTN","HLTPCK2B",168,0)
 .. S:ERR="" ERR="Receiving Facility mismatch."
"RTN","HLTPCK2B",169,0)
 . ; patch HL*1.6*120 end
"RTN","HLTPCK2B",170,0)
 . ;
"RTN","HLTPCK2B",171,0)
 .Q:HLDOMP=$P(HLPARAM,U)  ;This is local app to app
"RTN","HLTPCK2B",172,0)
 .I HLDOMP N HLNK S HLNK=+$O(^HLCS(870,"D",HLDOMP,0))
"RTN","HLTPCK2B",173,0)
 .I $G(HLNK) S ARY("LL")=HLNK
"RTN","HLTPCK2B",174,0)
 ;
"RTN","HLTPCK2B",175,0)
PID ;Validate processing ID
"RTN","HLTPCK2B",176,0)
 I ("DTP"'[ARY("PID")) S:(ERR="") ERR="Invalid HL7 Processing ID"
"RTN","HLTPCK2B",177,0)
 S HLPID=$P(HLPARAM,U,3) ;site param
"RTN","HLTPCK2B",178,0)
 S X=$G(^ORD(101,ARY("EID"),770)),X=$P(X,U,6) ;event driver
"RTN","HLTPCK2B",179,0)
 ;If message is 'debug' then event driver must be 'debug.'
"RTN","HLTPCK2B",180,0)
 ;If message is 'test' or 'production', then site param must match
"RTN","HLTPCK2B",181,0)
 I ARY("PID")="D"&(X'="D") S:ERR="" ERR="Processing ID Mismatch with Event Driver"
"RTN","HLTPCK2B",182,0)
 I ARY("PID")'="D"&(HLPID'=ARY("PID")) S:ERR="" ERR="Processing ID Mismatch with Site Parameters"
"RTN","HLTPCK2B",183,0)
 ;
"RTN","HLTPCK2B",184,0)
SEC ;Validate security field - access code and electronic signature
"RTN","HLTPCK2B",185,0)
 I ($P($G(HLN(773)),"^",3)) D
"RTN","HLTPCK2B",186,0)
 .S X=$P($$P^HLTPCK2(.HDR,8),$E(ECH))
"RTN","HLTPCK2B",187,0)
 .S X=$$UPPER^HLFNC(X)
"RTN","HLTPCK2B",188,0)
 .D ^XUSHSH
"RTN","HLTPCK2B",189,0)
 .I X="",(MSA="") S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK2B",190,0)
 .S ARY("DUZ")=0
"RTN","HLTPCK2B",191,0)
 .S:(X'="") ARY("DUZ")=+$O(^VA(200,"A",X,0))
"RTN","HLTPCK2B",192,0)
 .I ('ARY("DUZ")) S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK2B",193,0)
 .I (($P($G(^VA(200,ARY("DUZ"),.1)),"^")="")&('$D(MSA))) S ARY("DUZ")=0 S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK2B",194,0)
 .S X=$P($$P^HLTPCK2(.HDR,8),$E(ECH),3) I (X'="") D
"RTN","HLTPCK2B",195,0)
 ..S X1=$G(^VA(200,ARY("DUZ"),20))
"RTN","HLTPCK2B",196,0)
 ..I (X1="") S:(ERR="") ERR="No Signature Code on File" Q
"RTN","HLTPCK2B",197,0)
 ..S X=$$UPPER^HLFNC(X)
"RTN","HLTPCK2B",198,0)
 ..D HASH^XUSHSHP
"RTN","HLTPCK2B",199,0)
 ..I ((X'=$P(X1,"^",4))!($P(X1,"^",2)="")) S:(ERR="") ERR="Invalid Electronic Signature Code" Q
"RTN","HLTPCK2B",200,0)
 ..S ARY("ESIG")=$P(X1,"^",2)
"RTN","HLTPCK2B",201,0)
 I $D(ARY) M HLREC=ARY
"RTN","HLTPCK2B",202,0)
 Q
"VER")
8.0^22.0
"^DD",870,870,200.022,0)
CLOSE BEFORE RE-TRANSMISSION^S^1:YES;^200;11^Q
"^DD",870,870,200.022,3)
Enter YES if the TCP device should always be closed and re-opened before another re-transmission attempt.
"^DD",870,870,200.022,21,0)
^^6^6^3060629^^
"^DD",870,870,200.022,21,1,0)
Re-transmitting a message over the same open connection may cause a
"^DD",870,870,200.022,21,2,0)
synchronization problem for some applications.  Setting this field to YES
"^DD",870,870,200.022,21,3,0)
will cause the TCP connection to always be closed after a READ timeout or other
"^DD",870,870,200.022,21,4,0)
communication failure.  Instead, a new connection will be opened before
"^DD",870,870,200.022,21,5,0)
attempting to re-transmit the message.
"^DD",870,870,200.022,21,6,0)

"^DD",870,870,200.022,"DT")
3060629
"BLD",955,6)
^105
**END**
**END**
