KIDS Distribution saved on Feb 23, 2004@11:37:43
Immunology Case Registries v3.0
**KIDS**:ROR*1.0*5^

**INSTALL NAME**
ROR*1.0*5
"BLD",4001,0)
ROR*1.0*5^CLINICAL CASE REGISTRIES^0^3040223^y
"BLD",4001,1,0)
^^2^2^3040209^
"BLD",4001,1,1,0)
This build introduces Immunology Case Registry v3.0 and several fixes for 
"BLD",4001,1,2,0)
the the Clinical Case Registries.
"BLD",4001,4,0)
^9.64PA^798.9^16
"BLD",4001,4,798,0)
798
"BLD",4001,4,798,222)
y^n^f^^^^n
"BLD",4001,4,798.1,0)
798.1
"BLD",4001,4,798.1,222)
y^n^f^^y^^y^m^n
"BLD",4001,4,798.1,224)
I $E($P($G(^ROR(798.1,Y,0)),U),1,6)="VA ICR"
"BLD",4001,4,798.2,0)
798.2
"BLD",4001,4,798.2,222)
n^n^f^^n^^y^o^n
"BLD",4001,4,798.2,224)
I $E($P($G(^ROR(798.2,Y,0)),U),1,6)="VA ICR"
"BLD",4001,4,798.3,0)
798.3
"BLD",4001,4,798.3,222)
y^n^f^^^^n^o^
"BLD",4001,4,798.3,224)

"BLD",4001,4,798.4,0)
798.4
"BLD",4001,4,798.4,222)
y^n^f^^^^n
"BLD",4001,4,798.5,0)
798.5
"BLD",4001,4,798.5,222)
y^n^f^^^^n
"BLD",4001,4,798.7,0)
798.7
"BLD",4001,4,798.7,222)
y^n^f^^^^n
"BLD",4001,4,798.8,0)
798.8
"BLD",4001,4,798.8,222)
y^y^f^^^^n
"BLD",4001,4,798.9,0)
798.9
"BLD",4001,4,798.9,222)
y^n^f^^n^^y^m^n
"BLD",4001,4,798.9,224)
I $E($P($G(^ROR(798.9,Y,0)),U),1,6)="VA ICR"
"BLD",4001,4,799.1,0)
799.1
"BLD",4001,4,799.1,222)
y^n^f^^y^^y^o^n
"BLD",4001,4,799.31,0)
799.31
"BLD",4001,4,799.31,222)
y^y^f^^n^^y^o^n
"BLD",4001,4,799.33,0)
799.33
"BLD",4001,4,799.33,222)
y^y^f^^n^^y^o^n
"BLD",4001,4,799.34,0)
799.34
"BLD",4001,4,799.34,222)
y^y^f^^n^^y^o^n
"BLD",4001,4,799.4,0)
799.4
"BLD",4001,4,799.4,222)
y^y^f^^^^n
"BLD",4001,4,799.49,0)
799.49
"BLD",4001,4,799.49,222)
y^y^f^^n^^y^o^n
"BLD",4001,4,799.51,0)
799.51
"BLD",4001,4,799.51,222)
y^y^f^^y^^y^o^n
"BLD",4001,4,799.51,224)
I $$GET1^DIQ(799.51,Y,.02)="VA ICR"
"BLD",4001,4,"B",798,798)

"BLD",4001,4,"B",798.1,798.1)

"BLD",4001,4,"B",798.2,798.2)

"BLD",4001,4,"B",798.3,798.3)

"BLD",4001,4,"B",798.4,798.4)

"BLD",4001,4,"B",798.5,798.5)

"BLD",4001,4,"B",798.7,798.7)

"BLD",4001,4,"B",798.8,798.8)

"BLD",4001,4,"B",798.9,798.9)

"BLD",4001,4,"B",799.1,799.1)

"BLD",4001,4,"B",799.31,799.31)

"BLD",4001,4,"B",799.33,799.33)

"BLD",4001,4,"B",799.34,799.34)

"BLD",4001,4,"B",799.4,799.4)

"BLD",4001,4,"B",799.49,799.49)

"BLD",4001,4,"B",799.51,799.51)

"BLD",4001,"ABPKG")
n
"BLD",4001,"INI")
PRE^RORP005
"BLD",4001,"INIT")
POS^RORP005
"BLD",4001,"KRN",0)
^9.67PA^8989.52^19
"BLD",4001,"KRN",.4,0)
.4
"BLD",4001,"KRN",.401,0)
.401
"BLD",4001,"KRN",.402,0)
.402
"BLD",4001,"KRN",.402,"NM",0)
^9.68A^2^2
"BLD",4001,"KRN",.402,"NM",1,0)
RORMNT AWAITING ACK    FILE #798.1^798.1^1^
"BLD",4001,"KRN",.402,"NM",2,0)
RORMNT EDIT REG PARAMS    FILE #798.1^798.1^0
"BLD",4001,"KRN",.402,"NM","B","RORMNT AWAITING ACK    FILE #798.1",1)

"BLD",4001,"KRN",.402,"NM","B","RORMNT EDIT REG PARAMS    FILE #798.1",2)

"BLD",4001,"KRN",.403,0)
.403
"BLD",4001,"KRN",.5,0)
.5
"BLD",4001,"KRN",.5,"NM",0)
^9.68A^1^1
"BLD",4001,"KRN",.5,"NM",1,0)
RORPTSTATUS^^0
"BLD",4001,"KRN",.5,"NM","B","RORPTSTATUS",1)

"BLD",4001,"KRN",.84,0)
.84
"BLD",4001,"KRN",.84,"NM",0)
^9.68A^58^57
"BLD",4001,"KRN",.84,"NM",1,0)
7980000.003^^0
"BLD",4001,"KRN",.84,"NM",2,0)
7981000^^0
"BLD",4001,"KRN",.84,"NM",3,0)
7981001.001^^0
"BLD",4001,"KRN",.84,"NM",5,0)
7980000.004^^0
"BLD",4001,"KRN",.84,"NM",6,0)
7980000.005^^0
"BLD",4001,"KRN",.84,"NM",7,0)
7980000.006^^0
"BLD",4001,"KRN",.84,"NM",8,0)
7980000.007^^0
"BLD",4001,"KRN",.84,"NM",9,0)
7980000.008^^0
"BLD",4001,"KRN",.84,"NM",10,0)
7980000.009^^0
"BLD",4001,"KRN",.84,"NM",11,0)
7980000.01^^0
"BLD",4001,"KRN",.84,"NM",12,0)
7980000.011^^0
"BLD",4001,"KRN",.84,"NM",13,0)
7980000.012^^0
"BLD",4001,"KRN",.84,"NM",14,0)
7980000.013^^0
"BLD",4001,"KRN",.84,"NM",15,0)
7980000.014^^0
"BLD",4001,"KRN",.84,"NM",16,0)
7981999.001^^0
"BLD",4001,"KRN",.84,"NM",17,0)
7981999.002^^0
"BLD",4001,"KRN",.84,"NM",18,0)
7980000.015^^0
"BLD",4001,"KRN",.84,"NM",19,0)
7981002.001^^0
"BLD",4001,"KRN",.84,"NM",20,0)
7981000.002^^0
"BLD",4001,"KRN",.84,"NM",21,0)
7981003.001^^0
"BLD",4001,"KRN",.84,"NM",22,0)
7980000.016^^0
"BLD",4001,"KRN",.84,"NM",23,0)
7981004.001^^0
"BLD",4001,"KRN",.84,"NM",24,0)
7981007.001^^0
"BLD",4001,"KRN",.84,"NM",25,0)
7981010.001^^0
"BLD",4001,"KRN",.84,"NM",26,0)
7981007.002^^0
"BLD",4001,"KRN",.84,"NM",27,0)
7980000.017^^0
"BLD",4001,"KRN",.84,"NM",28,0)
7981998.001^^0
"BLD",4001,"KRN",.84,"NM",29,0)
7980000.018^^0
"BLD",4001,"KRN",.84,"NM",30,0)
7981005.001^^0
"BLD",4001,"KRN",.84,"NM",31,0)
7980000.019^^0
"BLD",4001,"KRN",.84,"NM",32,0)
7981006.001^^0
"BLD",4001,"KRN",.84,"NM",33,0)
7981013.001^^0
"BLD",4001,"KRN",.84,"NM",34,0)
7981012.001^^0
"BLD",4001,"KRN",.84,"NM",35,0)
7981997.001^^0
"BLD",4001,"KRN",.84,"NM",36,0)
7981996.001^^0
"BLD",4001,"KRN",.84,"NM",37,0)
7981014.001^^0
"BLD",4001,"KRN",.84,"NM",38,0)
7981995.001^^0
"BLD",4001,"KRN",.84,"NM",39,0)
7981008.001^^0
"BLD",4001,"KRN",.84,"NM",40,0)
7981011.001^^0
"BLD",4001,"KRN",.84,"NM",41,0)
7981009.001^^0
"BLD",4001,"KRN",.84,"NM",42,0)
7981001.002^^0
"BLD",4001,"KRN",.84,"NM",43,0)
7981002.002^^0
"BLD",4001,"KRN",.84,"NM",44,0)
7981003.002^^0
"BLD",4001,"KRN",.84,"NM",45,0)
7981004.002^^0
"BLD",4001,"KRN",.84,"NM",46,0)
7981008.002^^0
"BLD",4001,"KRN",.84,"NM",47,0)
7981010.002^^0
"BLD",4001,"KRN",.84,"NM",48,0)
7981011.002^^0
"BLD",4001,"KRN",.84,"NM",49,0)
7981012.002^^0
"BLD",4001,"KRN",.84,"NM",50,0)
7981013.002^^0
"BLD",4001,"KRN",.84,"NM",51,0)
7981014.002^^0
"BLD",4001,"KRN",.84,"NM",52,0)
7981005.002^^0
"BLD",4001,"KRN",.84,"NM",53,0)
7981006.002^^0
"BLD",4001,"KRN",.84,"NM",54,0)
7981009.002^^0
"BLD",4001,"KRN",.84,"NM",55,0)
7981997.002^^0
"BLD",4001,"KRN",.84,"NM",56,0)
7980000.02^^0
"BLD",4001,"KRN",.84,"NM",57,0)
7980000.021^^0
"BLD",4001,"KRN",.84,"NM",58,0)
7980000.022^^0
"BLD",4001,"KRN",.84,"NM","B",7980000.003,1)

"BLD",4001,"KRN",.84,"NM","B",7980000.004,5)

"BLD",4001,"KRN",.84,"NM","B",7980000.005,6)

"BLD",4001,"KRN",.84,"NM","B",7980000.006,7)

"BLD",4001,"KRN",.84,"NM","B",7980000.007,8)

"BLD",4001,"KRN",.84,"NM","B",7980000.008,9)

"BLD",4001,"KRN",.84,"NM","B",7980000.009,10)

"BLD",4001,"KRN",.84,"NM","B",7980000.01,11)

"BLD",4001,"KRN",.84,"NM","B",7980000.011,12)

"BLD",4001,"KRN",.84,"NM","B",7980000.012,13)

"BLD",4001,"KRN",.84,"NM","B",7980000.013,14)

"BLD",4001,"KRN",.84,"NM","B",7980000.014,15)

"BLD",4001,"KRN",.84,"NM","B",7980000.015,18)

"BLD",4001,"KRN",.84,"NM","B",7980000.016,22)

"BLD",4001,"KRN",.84,"NM","B",7980000.017,27)

"BLD",4001,"KRN",.84,"NM","B",7980000.018,29)

"BLD",4001,"KRN",.84,"NM","B",7980000.019,31)

"BLD",4001,"KRN",.84,"NM","B",7980000.02,56)

"BLD",4001,"KRN",.84,"NM","B",7980000.021,57)

"BLD",4001,"KRN",.84,"NM","B",7980000.022,58)

"BLD",4001,"KRN",.84,"NM","B",7981000,2)

"BLD",4001,"KRN",.84,"NM","B",7981000.002,20)

"BLD",4001,"KRN",.84,"NM","B",7981001.001,3)

"BLD",4001,"KRN",.84,"NM","B",7981001.002,42)

"BLD",4001,"KRN",.84,"NM","B",7981002.001,19)

"BLD",4001,"KRN",.84,"NM","B",7981002.002,43)

"BLD",4001,"KRN",.84,"NM","B",7981003.001,21)

"BLD",4001,"KRN",.84,"NM","B",7981003.002,44)

"BLD",4001,"KRN",.84,"NM","B",7981004.001,23)

"BLD",4001,"KRN",.84,"NM","B",7981004.002,45)

"BLD",4001,"KRN",.84,"NM","B",7981005.001,30)

"BLD",4001,"KRN",.84,"NM","B",7981005.002,52)

"BLD",4001,"KRN",.84,"NM","B",7981006.001,32)

"BLD",4001,"KRN",.84,"NM","B",7981006.002,53)

"BLD",4001,"KRN",.84,"NM","B",7981007.001,24)

"BLD",4001,"KRN",.84,"NM","B",7981007.002,26)

"BLD",4001,"KRN",.84,"NM","B",7981008.001,39)

"BLD",4001,"KRN",.84,"NM","B",7981008.002,46)

"BLD",4001,"KRN",.84,"NM","B",7981009.001,41)

"BLD",4001,"KRN",.84,"NM","B",7981009.002,54)

"BLD",4001,"KRN",.84,"NM","B",7981010.001,25)

"BLD",4001,"KRN",.84,"NM","B",7981010.002,47)

"BLD",4001,"KRN",.84,"NM","B",7981011.001,40)

"BLD",4001,"KRN",.84,"NM","B",7981011.002,48)

"BLD",4001,"KRN",.84,"NM","B",7981012.001,34)

"BLD",4001,"KRN",.84,"NM","B",7981012.002,49)

"BLD",4001,"KRN",.84,"NM","B",7981013.001,33)

"BLD",4001,"KRN",.84,"NM","B",7981013.002,50)

"BLD",4001,"KRN",.84,"NM","B",7981014.001,37)

"BLD",4001,"KRN",.84,"NM","B",7981014.002,51)

"BLD",4001,"KRN",.84,"NM","B",7981995.001,38)

"BLD",4001,"KRN",.84,"NM","B",7981996.001,36)

"BLD",4001,"KRN",.84,"NM","B",7981997.001,35)

"BLD",4001,"KRN",.84,"NM","B",7981997.002,55)

"BLD",4001,"KRN",.84,"NM","B",7981998.001,28)

"BLD",4001,"KRN",.84,"NM","B",7981999.001,16)

"BLD",4001,"KRN",.84,"NM","B",7981999.002,17)

"BLD",4001,"KRN",3.6,0)
3.6
"BLD",4001,"KRN",3.8,0)
3.8
"BLD",4001,"KRN",3.8,"NM",0)
^9.68A^^0
"BLD",4001,"KRN",9.2,0)
9.2
"BLD",4001,"KRN",9.2,"NM",0)
^9.68A^^
"BLD",4001,"KRN",9.8,0)
9.8
"BLD",4001,"KRN",9.8,"NM",0)
^9.68A^183^173
"BLD",4001,"KRN",9.8,"NM",1,0)
RORTSK^^0^B20559181
"BLD",4001,"KRN",9.8,"NM",2,0)
RORTSK01^^0^B50638834
"BLD",4001,"KRN",9.8,"NM",3,0)
RORRP010^^0^B11316186
"BLD",4001,"KRN",9.8,"NM",4,0)
RORTSK02^^0^B26620629
"BLD",4001,"KRN",9.8,"NM",5,0)
RORTSK03^^0^B7170805
"BLD",4001,"KRN",9.8,"NM",6,0)
RORUTL08^^0^B17859176
"BLD",4001,"KRN",9.8,"NM",7,0)
RORERR20^^0^B58895933
"BLD",4001,"KRN",9.8,"NM",8,0)
ROREXT02^^0^B27066170
"BLD",4001,"KRN",9.8,"NM",9,0)
RORLOG^^0^B44679259
"BLD",4001,"KRN",9.8,"NM",10,0)
RORRP007^^0^B35145083
"BLD",4001,"KRN",9.8,"NM",11,0)
RORRP011^^0^B10493824
"BLD",4001,"KRN",9.8,"NM",12,0)
RORRP012^^0^B16492346
"BLD",4001,"KRN",9.8,"NM",13,0)
RORRP013^^0^B25493831
"BLD",4001,"KRN",9.8,"NM",14,0)
RORRP014^^0^B7729423
"BLD",4001,"KRN",9.8,"NM",15,0)
RORTSK10^^0^B36852620
"BLD",4001,"KRN",9.8,"NM",16,0)
RORTSK11^^0^B18028292
"BLD",4001,"KRN",9.8,"NM",17,0)
RORUTL03^^0^B21936813
"BLD",4001,"KRN",9.8,"NM",18,0)
RORDD^^0^B34441882
"BLD",4001,"KRN",9.8,"NM",19,0)
ROREXPR^^0^B10188914
"BLD",4001,"KRN",9.8,"NM",20,0)
ROREXT^^0^B33228384
"BLD",4001,"KRN",9.8,"NM",22,0)
RORICR02^^0^B6337333
"BLD",4001,"KRN",9.8,"NM",23,0)
RORICR01^^0^B6137970
"BLD",4001,"KRN",9.8,"NM",24,0)
RORUPP02^^0^B13632896
"BLD",4001,"KRN",9.8,"NM",25,0)
ROR^^0^B18134268
"BLD",4001,"KRN",9.8,"NM",27,0)
RORRP015^^0^B22373114
"BLD",4001,"KRN",9.8,"NM",28,0)
RORRP016^^0^B6790521
"BLD",4001,"KRN",9.8,"NM",29,0)
RORRP017^^0^B12973623
"BLD",4001,"KRN",9.8,"NM",30,0)
RORUPD^^0^B30110127
"BLD",4001,"KRN",9.8,"NM",32,0)
RORX001^^0^B38640459
"BLD",4001,"KRN",9.8,"NM",33,0)
RORX002^^0^B20256983
"BLD",4001,"KRN",9.8,"NM",34,0)
RORDD01^^0^B1880531
"BLD",4001,"KRN",9.8,"NM",35,0)
RORP005^^0^B63504061
"BLD",4001,"KRN",9.8,"NM",36,0)
RORRP018^^0^B6225205
"BLD",4001,"KRN",9.8,"NM",37,0)
RORHL03^^0^B31127289
"BLD",4001,"KRN",9.8,"NM",38,0)
RORHL04^^0^B30377980
"BLD",4001,"KRN",9.8,"NM",39,0)
RORHL07^^0^B23072597
"BLD",4001,"KRN",9.8,"NM",40,0)
RORHL08^^0^B21198580
"BLD",4001,"KRN",9.8,"NM",41,0)
RORHL09^^0^B56024606
"BLD",4001,"KRN",9.8,"NM",42,0)
RORHL10^^0^B59986020
"BLD",4001,"KRN",9.8,"NM",43,0)
RORHL11^^0^B41807698
"BLD",4001,"KRN",9.8,"NM",44,0)
RORHL12^^0^B8931261
"BLD",4001,"KRN",9.8,"NM",45,0)
RORHL13^^0^B18586045
"BLD",4001,"KRN",9.8,"NM",46,0)
RORHL14^^0^B30913194
"BLD",4001,"KRN",9.8,"NM",47,0)
RORHL15^^0^B38971403
"BLD",4001,"KRN",9.8,"NM",49,0)
RORRP019^^0^B22286689
"BLD",4001,"KRN",9.8,"NM",50,0)
RORRP020^^0^B32201134
"BLD",4001,"KRN",9.8,"NM",51,0)
RORRP021^^0^B14656437
"BLD",4001,"KRN",9.8,"NM",52,0)
RORLOG01^^0^B10659311
"BLD",4001,"KRN",9.8,"NM",54,0)
RORP005B^^0^B43947159
"BLD",4001,"KRN",9.8,"NM",55,0)
ROR01^^0^B15130
"BLD",4001,"KRN",9.8,"NM",56,0)
ROREXT01^^0^B21361325
"BLD",4001,"KRN",9.8,"NM",57,0)
RORREP01^^0^B47036282
"BLD",4001,"KRN",9.8,"NM",58,0)
RORREP02^^0^B52930103
"BLD",4001,"KRN",9.8,"NM",59,0)
RORRP022^^0^B4139255
"BLD",4001,"KRN",9.8,"NM",60,0)
RORX003^^0^B20228315
"BLD",4001,"KRN",9.8,"NM",61,0)
RORRP023^^0^B10243108
"BLD",4001,"KRN",9.8,"NM",62,0)
RORRP024^^0^B18249929
"BLD",4001,"KRN",9.8,"NM",63,0)
RORRP025^^0^B32323014
"BLD",4001,"KRN",9.8,"NM",64,0)
RORERR^^0^B25277669
"BLD",4001,"KRN",9.8,"NM",65,0)
RORRP026^^0^B66003716
"BLD",4001,"KRN",9.8,"NM",66,0)
RORRP027^^0^B51376445
"BLD",4001,"KRN",9.8,"NM",67,0)
RORHL031^^0^B40976171
"BLD",4001,"KRN",9.8,"NM",68,0)
RORHL081^^0^B43279413
"BLD",4001,"KRN",9.8,"NM",69,0)
RORRP029^^0^B6656524
"BLD",4001,"KRN",9.8,"NM",70,0)
RORHL21^^0^B4958953
"BLD",4001,"KRN",9.8,"NM",72,0)
RORICREX^^0^B19025318
"BLD",4001,"KRN",9.8,"NM",73,0)
RORUTL09^^0^B6779484
"BLD",4001,"KRN",9.8,"NM",74,0)
RORACK^^0^B16804227
"BLD",4001,"KRN",9.8,"NM",75,0)
ROR02^^0^B8243
"BLD",4001,"KRN",9.8,"NM",76,0)
ROR10^^0^B26490729
"BLD",4001,"KRN",9.8,"NM",77,0)
RORUTL05^^0^B55183638
"BLD",4001,"KRN",9.8,"NM",78,0)
RORRP5^^0^B3695414
"BLD",4001,"KRN",9.8,"NM",79,0)
RORVM001^^0^B2351863
"BLD",4001,"KRN",9.8,"NM",80,0)
RORACK01^^0^B41951107
"BLD",4001,"KRN",9.8,"NM",81,0)
RORERR10^^0^B27111394
"BLD",4001,"KRN",9.8,"NM",82,0)
RORERR11^^0^B62772035
"BLD",4001,"KRN",9.8,"NM",83,0)
RORERR12^^0^B41180056
"BLD",4001,"KRN",9.8,"NM",84,0)
RORX004^^0^B27546159
"BLD",4001,"KRN",9.8,"NM",85,0)
ROREXTUT^^0^B44618156
"BLD",4001,"KRN",9.8,"NM",86,0)
RORHDT04^^0^B37521395
"BLD",4001,"KRN",9.8,"NM",87,0)
RORHL7^^0^B45330050
"BLD",4001,"KRN",9.8,"NM",88,0)
RORHL02^^0^B44443526
"BLD",4001,"KRN",9.8,"NM",89,0)
RORHLUT1^^0^B5697776
"BLD",4001,"KRN",9.8,"NM",90,0)
RORUTL02^^0^B37515307
"BLD",4001,"KRN",9.8,"NM",91,0)
RORHL01^^0^B10737410
"BLD",4001,"KRN",9.8,"NM",92,0)
RORHL06^^0^B23712300
"BLD",4001,"KRN",9.8,"NM",93,0)
RORHL05^^0^B6723296
"BLD",4001,"KRN",9.8,"NM",94,0)
RORHL16^^0^B12940115
"BLD",4001,"KRN",9.8,"NM",95,0)
RORHL7A^^0^B8190977
"BLD",4001,"KRN",9.8,"NM",96,0)
RORSET01^^0^B16336609
"BLD",4001,"KRN",9.8,"NM",97,0)
RORUTL07^^0^B10278972
"BLD",4001,"KRN",9.8,"NM",98,0)
RORSETU1^^0^B9739381
"BLD",4001,"KRN",9.8,"NM",99,0)
ROREVT01^^0^B5877686
"BLD",4001,"KRN",9.8,"NM",100,0)
RORUTL01^^0^B29789111
"BLD",4001,"KRN",9.8,"NM",101,0)
RORRP2^^0^B21486692
"BLD",4001,"KRN",9.8,"NM",102,0)
RORX007A^^0^B13263174
"BLD",4001,"KRN",9.8,"NM",103,0)
RORRP030^^0^B34670382
"BLD",4001,"KRN",9.8,"NM",104,0)
RORRP031^^0^B31717159
"BLD",4001,"KRN",9.8,"NM",105,0)
RORRP032^^0^B31692650
"BLD",4001,"KRN",9.8,"NM",106,0)
RORRP033^^0^B30175350
"BLD",4001,"KRN",9.8,"NM",107,0)
RORUTL10^^0^B40583539
"BLD",4001,"KRN",9.8,"NM",108,0)
RORUTL06^^0^B61311339
"BLD",4001,"KRN",9.8,"NM",109,0)
RORXU001^^0^B12637299
"BLD",4001,"KRN",9.8,"NM",110,0)
RORRP4^^0^B19948124
"BLD",4001,"KRN",9.8,"NM",111,0)
RORLOCK^^0^B21824053
"BLD",4001,"KRN",9.8,"NM",112,0)
RORRP034^^0^B16495366
"BLD",4001,"KRN",9.8,"NM",113,0)
RORHL121^^0^B77104692
"BLD",4001,"KRN",9.8,"NM",114,0)
RORUTL11^^0^B2472015
"BLD",4001,"KRN",9.8,"NM",115,0)
RORHDT01^^0^B8374312
"BLD",4001,"KRN",9.8,"NM",116,0)
RORHDT02^^0^B3488704
"BLD",4001,"KRN",9.8,"NM",117,0)
RORHDT03^^0^B23015205
"BLD",4001,"KRN",9.8,"NM",118,0)
RORHDT05^^0^B13041348
"BLD",4001,"KRN",9.8,"NM",119,0)
RORHDTAC^^0^B12268128
"BLD",4001,"KRN",9.8,"NM",120,0)
RORHDTUT^^0^B26725557
"BLD",4001,"KRN",9.8,"NM",121,0)
RORSETU2^^0^B11438784
"BLD",4001,"KRN",9.8,"NM",122,0)
RORUPD01^^0^B64834418
"BLD",4001,"KRN",9.8,"NM",123,0)
RORUPD04^^0^B32348134
"BLD",4001,"KRN",9.8,"NM",124,0)
RORUPD05^^0^B45537239
"BLD",4001,"KRN",9.8,"NM",125,0)
RORUPD08^^0^B18491466
"BLD",4001,"KRN",9.8,"NM",126,0)
RORUPD50^^0^B12929200
"BLD",4001,"KRN",9.8,"NM",127,0)
RORUPD51^^0^B25850083
"BLD",4001,"KRN",9.8,"NM",128,0)
RORUPDUT^^0^B46426812
"BLD",4001,"KRN",9.8,"NM",129,0)
RORUPEX^^0^B14367646
"BLD",4001,"KRN",9.8,"NM",130,0)
RORUPP01^^0^B14228263
"BLD",4001,"KRN",9.8,"NM",131,0)
RORUPR1^^0^B69074484
"BLD",4001,"KRN",9.8,"NM",132,0)
RORKIDS^^0^B35442305
"BLD",4001,"KRN",9.8,"NM",133,0)
RORUPD09^^0^B8417015
"BLD",4001,"KRN",9.8,"NM",134,0)
RORUPR^^0^B27116050
"BLD",4001,"KRN",9.8,"NM",135,0)
RORPUT01^^0^B36828175
"BLD",4001,"KRN",9.8,"NM",136,0)
RORX000^^0^B4541569
"BLD",4001,"KRN",9.8,"NM",138,0)
RORX010^^0^B36480677
"BLD",4001,"KRN",9.8,"NM",139,0)
RORAPI01^^0^B8592008
"BLD",4001,"KRN",9.8,"NM",140,0)
RORXU002^^0^B50867342
"BLD",4001,"KRN",9.8,"NM",142,0)
RORXU003^^0^B56989100
"BLD",4001,"KRN",9.8,"NM",143,0)
RORXU005^^0^B10608819
"BLD",4001,"KRN",9.8,"NM",145,0)
RORX007^^0^B61153947
"BLD",4001,"KRN",9.8,"NM",146,0)
RORICRUT^^0^B843657
"BLD",4001,"KRN",9.8,"NM",147,0)
RORX005^^0^B15608297
"BLD",4001,"KRN",9.8,"NM",148,0)
RORXU004^^0^B860897
"BLD",4001,"KRN",9.8,"NM",149,0)
RORX005A^^0^B41714803
"BLD",4001,"KRN",9.8,"NM",150,0)
RORUPD06^^0^B11384765
"BLD",4001,"KRN",9.8,"NM",151,0)
RORHL17^^0^B34047121
"BLD",4001,"KRN",9.8,"NM",152,0)
RORX005C^^0^B72977604
"BLD",4001,"KRN",9.8,"NM",153,0)
RORX005B^^0^B41086248
"BLD",4001,"KRN",9.8,"NM",154,0)
RORX005U^^0^B533108
"BLD",4001,"KRN",9.8,"NM",155,0)
RORX006^^0^B11208079
"BLD",4001,"KRN",9.8,"NM",156,0)
RORXU006^^0^B24074439
"BLD",4001,"KRN",9.8,"NM",157,0)
RORX006A^^0^B34713272
"BLD",4001,"KRN",9.8,"NM",158,0)
RORX006C^^0^B22092254
"BLD",4001,"KRN",9.8,"NM",159,0)
RORX013^^0^B9020068
"BLD",4001,"KRN",9.8,"NM",160,0)
RORX013A^^0^B50024432
"BLD",4001,"KRN",9.8,"NM",161,0)
RORX013C^^0^B10582758
"BLD",4001,"KRN",9.8,"NM",162,0)
RORX012^^0^B10720831
"BLD",4001,"KRN",9.8,"NM",163,0)
RORX008^^0^B9126284
"BLD",4001,"KRN",9.8,"NM",164,0)
RORX014^^0^B10017478
"BLD",4001,"KRN",9.8,"NM",166,0)
RORX009^^0^B15466475
"BLD",4001,"KRN",9.8,"NM",167,0)
RORX011^^0^B44205168
"BLD",4001,"KRN",9.8,"NM",168,0)
RORUTL14^^0^B9079803
"BLD",4001,"KRN",9.8,"NM",169,0)
RORUTL15^^0^B30459716
"BLD",4001,"KRN",9.8,"NM",170,0)
RORUTL16^^0^B10030242
"BLD",4001,"KRN",9.8,"NM",171,0)
RORX012A^^0^B31881502
"BLD",4001,"KRN",9.8,"NM",172,0)
RORX014A^^0^B28744511
"BLD",4001,"KRN",9.8,"NM",173,0)
RORXU007^^0^B35921513
"BLD",4001,"KRN",9.8,"NM",174,0)
RORX008A^^0^B26936017
"BLD",4001,"KRN",9.8,"NM",175,0)
RORX009A^^0^B38249020
"BLD",4001,"KRN",9.8,"NM",176,0)
RORX009C^^0^B39303150
"BLD",4001,"KRN",9.8,"NM",177,0)
RORX003A^^0^B34213708
"BLD",4001,"KRN",9.8,"NM",178,0)
RORHL071^^0^B20781846
"BLD",4001,"KRN",9.8,"NM",179,0)
RORRP035^^0^B5599356
"BLD",4001,"KRN",9.8,"NM",180,0)
RORUTL17^^0^B53261399
"BLD",4001,"KRN",9.8,"NM",181,0)
RORICR03^^0^B34960427
"BLD",4001,"KRN",9.8,"NM",182,0)
RORNTEG^^0^B19482341
"BLD",4001,"KRN",9.8,"NM",183,0)
RORNTEG0^^0^B4128249
"BLD",4001,"KRN",9.8,"NM","B","ROR",25)

"BLD",4001,"KRN",9.8,"NM","B","ROR01",55)

"BLD",4001,"KRN",9.8,"NM","B","ROR02",75)

"BLD",4001,"KRN",9.8,"NM","B","ROR10",76)

"BLD",4001,"KRN",9.8,"NM","B","RORACK",74)

"BLD",4001,"KRN",9.8,"NM","B","RORACK01",80)

"BLD",4001,"KRN",9.8,"NM","B","RORAPI01",139)

"BLD",4001,"KRN",9.8,"NM","B","RORDD",18)

"BLD",4001,"KRN",9.8,"NM","B","RORDD01",34)

"BLD",4001,"KRN",9.8,"NM","B","RORERR",64)

"BLD",4001,"KRN",9.8,"NM","B","RORERR10",81)

"BLD",4001,"KRN",9.8,"NM","B","RORERR11",82)

"BLD",4001,"KRN",9.8,"NM","B","RORERR12",83)

"BLD",4001,"KRN",9.8,"NM","B","RORERR20",7)

"BLD",4001,"KRN",9.8,"NM","B","ROREVT01",99)

"BLD",4001,"KRN",9.8,"NM","B","ROREXPR",19)

"BLD",4001,"KRN",9.8,"NM","B","ROREXT",20)

"BLD",4001,"KRN",9.8,"NM","B","ROREXT01",56)

"BLD",4001,"KRN",9.8,"NM","B","ROREXT02",8)

"BLD",4001,"KRN",9.8,"NM","B","ROREXTUT",85)

"BLD",4001,"KRN",9.8,"NM","B","RORHDT01",115)

"BLD",4001,"KRN",9.8,"NM","B","RORHDT02",116)

"BLD",4001,"KRN",9.8,"NM","B","RORHDT03",117)

"BLD",4001,"KRN",9.8,"NM","B","RORHDT04",86)

"BLD",4001,"KRN",9.8,"NM","B","RORHDT05",118)

"BLD",4001,"KRN",9.8,"NM","B","RORHDTAC",119)

"BLD",4001,"KRN",9.8,"NM","B","RORHDTUT",120)

"BLD",4001,"KRN",9.8,"NM","B","RORHL01",91)

"BLD",4001,"KRN",9.8,"NM","B","RORHL02",88)

"BLD",4001,"KRN",9.8,"NM","B","RORHL03",37)

"BLD",4001,"KRN",9.8,"NM","B","RORHL031",67)

"BLD",4001,"KRN",9.8,"NM","B","RORHL04",38)

"BLD",4001,"KRN",9.8,"NM","B","RORHL05",93)

"BLD",4001,"KRN",9.8,"NM","B","RORHL06",92)

"BLD",4001,"KRN",9.8,"NM","B","RORHL07",39)

"BLD",4001,"KRN",9.8,"NM","B","RORHL071",178)

"BLD",4001,"KRN",9.8,"NM","B","RORHL08",40)

"BLD",4001,"KRN",9.8,"NM","B","RORHL081",68)

"BLD",4001,"KRN",9.8,"NM","B","RORHL09",41)

"BLD",4001,"KRN",9.8,"NM","B","RORHL10",42)

"BLD",4001,"KRN",9.8,"NM","B","RORHL11",43)

"BLD",4001,"KRN",9.8,"NM","B","RORHL12",44)

"BLD",4001,"KRN",9.8,"NM","B","RORHL121",113)

"BLD",4001,"KRN",9.8,"NM","B","RORHL13",45)

"BLD",4001,"KRN",9.8,"NM","B","RORHL14",46)

"BLD",4001,"KRN",9.8,"NM","B","RORHL15",47)

"BLD",4001,"KRN",9.8,"NM","B","RORHL16",94)

"BLD",4001,"KRN",9.8,"NM","B","RORHL17",151)

"BLD",4001,"KRN",9.8,"NM","B","RORHL21",70)

"BLD",4001,"KRN",9.8,"NM","B","RORHL7",87)

"BLD",4001,"KRN",9.8,"NM","B","RORHL7A",95)

"BLD",4001,"KRN",9.8,"NM","B","RORHLUT1",89)

"BLD",4001,"KRN",9.8,"NM","B","RORICR01",23)

"BLD",4001,"KRN",9.8,"NM","B","RORICR02",22)

"BLD",4001,"KRN",9.8,"NM","B","RORICR03",181)

"BLD",4001,"KRN",9.8,"NM","B","RORICREX",72)

"BLD",4001,"KRN",9.8,"NM","B","RORICRUT",146)

"BLD",4001,"KRN",9.8,"NM","B","RORKIDS",132)

"BLD",4001,"KRN",9.8,"NM","B","RORLOCK",111)

"BLD",4001,"KRN",9.8,"NM","B","RORLOG",9)

"BLD",4001,"KRN",9.8,"NM","B","RORLOG01",52)

"BLD",4001,"KRN",9.8,"NM","B","RORNTEG",182)

"BLD",4001,"KRN",9.8,"NM","B","RORNTEG0",183)

"BLD",4001,"KRN",9.8,"NM","B","RORP005",35)

"BLD",4001,"KRN",9.8,"NM","B","RORP005B",54)

"BLD",4001,"KRN",9.8,"NM","B","RORPUT01",135)

"BLD",4001,"KRN",9.8,"NM","B","RORREP01",57)

"BLD",4001,"KRN",9.8,"NM","B","RORREP02",58)

"BLD",4001,"KRN",9.8,"NM","B","RORRP007",10)

"BLD",4001,"KRN",9.8,"NM","B","RORRP010",3)

"BLD",4001,"KRN",9.8,"NM","B","RORRP011",11)

"BLD",4001,"KRN",9.8,"NM","B","RORRP012",12)

"BLD",4001,"KRN",9.8,"NM","B","RORRP013",13)

"BLD",4001,"KRN",9.8,"NM","B","RORRP014",14)

"BLD",4001,"KRN",9.8,"NM","B","RORRP015",27)

"BLD",4001,"KRN",9.8,"NM","B","RORRP016",28)

"BLD",4001,"KRN",9.8,"NM","B","RORRP017",29)

"BLD",4001,"KRN",9.8,"NM","B","RORRP018",36)

"BLD",4001,"KRN",9.8,"NM","B","RORRP019",49)

"BLD",4001,"KRN",9.8,"NM","B","RORRP020",50)

"BLD",4001,"KRN",9.8,"NM","B","RORRP021",51)

"BLD",4001,"KRN",9.8,"NM","B","RORRP022",59)

"BLD",4001,"KRN",9.8,"NM","B","RORRP023",61)

"BLD",4001,"KRN",9.8,"NM","B","RORRP024",62)

"BLD",4001,"KRN",9.8,"NM","B","RORRP025",63)

"BLD",4001,"KRN",9.8,"NM","B","RORRP026",65)

"BLD",4001,"KRN",9.8,"NM","B","RORRP027",66)

"BLD",4001,"KRN",9.8,"NM","B","RORRP029",69)

"BLD",4001,"KRN",9.8,"NM","B","RORRP030",103)

"BLD",4001,"KRN",9.8,"NM","B","RORRP031",104)

"BLD",4001,"KRN",9.8,"NM","B","RORRP032",105)

"BLD",4001,"KRN",9.8,"NM","B","RORRP033",106)

"BLD",4001,"KRN",9.8,"NM","B","RORRP034",112)

"BLD",4001,"KRN",9.8,"NM","B","RORRP035",179)

"BLD",4001,"KRN",9.8,"NM","B","RORRP2",101)

"BLD",4001,"KRN",9.8,"NM","B","RORRP4",110)

"BLD",4001,"KRN",9.8,"NM","B","RORRP5",78)

"BLD",4001,"KRN",9.8,"NM","B","RORSET01",96)

"BLD",4001,"KRN",9.8,"NM","B","RORSETU1",98)

"BLD",4001,"KRN",9.8,"NM","B","RORSETU2",121)

"BLD",4001,"KRN",9.8,"NM","B","RORTSK",1)

"BLD",4001,"KRN",9.8,"NM","B","RORTSK01",2)

"BLD",4001,"KRN",9.8,"NM","B","RORTSK02",4)

"BLD",4001,"KRN",9.8,"NM","B","RORTSK03",5)

"BLD",4001,"KRN",9.8,"NM","B","RORTSK10",15)

"BLD",4001,"KRN",9.8,"NM","B","RORTSK11",16)

"BLD",4001,"KRN",9.8,"NM","B","RORUPD",30)

"BLD",4001,"KRN",9.8,"NM","B","RORUPD01",122)

"BLD",4001,"KRN",9.8,"NM","B","RORUPD04",123)

"BLD",4001,"KRN",9.8,"NM","B","RORUPD05",124)

"BLD",4001,"KRN",9.8,"NM","B","RORUPD06",150)

"BLD",4001,"KRN",9.8,"NM","B","RORUPD08",125)

"BLD",4001,"KRN",9.8,"NM","B","RORUPD09",133)

"BLD",4001,"KRN",9.8,"NM","B","RORUPD50",126)

"BLD",4001,"KRN",9.8,"NM","B","RORUPD51",127)

"BLD",4001,"KRN",9.8,"NM","B","RORUPDUT",128)

"BLD",4001,"KRN",9.8,"NM","B","RORUPEX",129)

"BLD",4001,"KRN",9.8,"NM","B","RORUPP01",130)

"BLD",4001,"KRN",9.8,"NM","B","RORUPP02",24)

"BLD",4001,"KRN",9.8,"NM","B","RORUPR",134)

"BLD",4001,"KRN",9.8,"NM","B","RORUPR1",131)

"BLD",4001,"KRN",9.8,"NM","B","RORUTL01",100)

"BLD",4001,"KRN",9.8,"NM","B","RORUTL02",90)

"BLD",4001,"KRN",9.8,"NM","B","RORUTL03",17)

"BLD",4001,"KRN",9.8,"NM","B","RORUTL05",77)

"BLD",4001,"KRN",9.8,"NM","B","RORUTL06",108)

"BLD",4001,"KRN",9.8,"NM","B","RORUTL07",97)

"BLD",4001,"KRN",9.8,"NM","B","RORUTL08",6)

"BLD",4001,"KRN",9.8,"NM","B","RORUTL09",73)

"BLD",4001,"KRN",9.8,"NM","B","RORUTL10",107)

"BLD",4001,"KRN",9.8,"NM","B","RORUTL11",114)

"BLD",4001,"KRN",9.8,"NM","B","RORUTL14",168)

"BLD",4001,"KRN",9.8,"NM","B","RORUTL15",169)

"BLD",4001,"KRN",9.8,"NM","B","RORUTL16",170)

"BLD",4001,"KRN",9.8,"NM","B","RORUTL17",180)

"BLD",4001,"KRN",9.8,"NM","B","RORVM001",79)

"BLD",4001,"KRN",9.8,"NM","B","RORX000",136)

"BLD",4001,"KRN",9.8,"NM","B","RORX001",32)

"BLD",4001,"KRN",9.8,"NM","B","RORX002",33)

"BLD",4001,"KRN",9.8,"NM","B","RORX003",60)

"BLD",4001,"KRN",9.8,"NM","B","RORX003A",177)

"BLD",4001,"KRN",9.8,"NM","B","RORX004",84)

"BLD",4001,"KRN",9.8,"NM","B","RORX005",147)

"BLD",4001,"KRN",9.8,"NM","B","RORX005A",149)

"BLD",4001,"KRN",9.8,"NM","B","RORX005B",153)

"BLD",4001,"KRN",9.8,"NM","B","RORX005C",152)

"BLD",4001,"KRN",9.8,"NM","B","RORX005U",154)

"BLD",4001,"KRN",9.8,"NM","B","RORX006",155)

"BLD",4001,"KRN",9.8,"NM","B","RORX006A",157)

"BLD",4001,"KRN",9.8,"NM","B","RORX006C",158)

"BLD",4001,"KRN",9.8,"NM","B","RORX007",145)

"BLD",4001,"KRN",9.8,"NM","B","RORX007A",102)

"BLD",4001,"KRN",9.8,"NM","B","RORX008",163)

"BLD",4001,"KRN",9.8,"NM","B","RORX008A",174)

"BLD",4001,"KRN",9.8,"NM","B","RORX009",166)

"BLD",4001,"KRN",9.8,"NM","B","RORX009A",175)

"BLD",4001,"KRN",9.8,"NM","B","RORX009C",176)

"BLD",4001,"KRN",9.8,"NM","B","RORX010",138)

"BLD",4001,"KRN",9.8,"NM","B","RORX011",167)

"BLD",4001,"KRN",9.8,"NM","B","RORX012",162)

"BLD",4001,"KRN",9.8,"NM","B","RORX012A",171)

"BLD",4001,"KRN",9.8,"NM","B","RORX013",159)

"BLD",4001,"KRN",9.8,"NM","B","RORX013A",160)

"BLD",4001,"KRN",9.8,"NM","B","RORX013C",161)

"BLD",4001,"KRN",9.8,"NM","B","RORX014",164)

"BLD",4001,"KRN",9.8,"NM","B","RORX014A",172)

"BLD",4001,"KRN",9.8,"NM","B","RORXU001",109)

"BLD",4001,"KRN",9.8,"NM","B","RORXU002",140)

"BLD",4001,"KRN",9.8,"NM","B","RORXU003",142)

"BLD",4001,"KRN",9.8,"NM","B","RORXU004",148)

"BLD",4001,"KRN",9.8,"NM","B","RORXU005",143)

"BLD",4001,"KRN",9.8,"NM","B","RORXU006",156)

"BLD",4001,"KRN",9.8,"NM","B","RORXU007",173)

"BLD",4001,"KRN",19,0)
19
"BLD",4001,"KRN",19,"NM",0)
^9.68A^7^7
"BLD",4001,"KRN",19,"NM",1,0)
ROR GUI^^0
"BLD",4001,"KRN",19,"NM",2,0)
RORMNT ACL REINDEX^^0^
"BLD",4001,"KRN",19,"NM",3,0)
RORMNT MAIN^^2
"BLD",4001,"KRN",19,"NM",4,0)
RORMNT AWAITING ACK^^0
"BLD",4001,"KRN",19,"NM",5,0)
ROR SETUP^^0
"BLD",4001,"KRN",19,"NM",6,0)
ROR SETUP HEPC^^1^
"BLD",4001,"KRN",19,"NM",7,0)
RORICR VERSION COMPARISON^^0
"BLD",4001,"KRN",19,"NM","B","ROR GUI",1)

"BLD",4001,"KRN",19,"NM","B","ROR SETUP",5)

"BLD",4001,"KRN",19,"NM","B","ROR SETUP HEPC",6)

"BLD",4001,"KRN",19,"NM","B","RORICR VERSION COMPARISON",7)

"BLD",4001,"KRN",19,"NM","B","RORMNT ACL REINDEX",2)

"BLD",4001,"KRN",19,"NM","B","RORMNT AWAITING ACK",4)

"BLD",4001,"KRN",19,"NM","B","RORMNT MAIN",3)

"BLD",4001,"KRN",19.1,0)
19.1
"BLD",4001,"KRN",19.1,"NM",0)
^9.68A^2^2
"BLD",4001,"KRN",19.1,"NM",1,0)
ROR VA ICR ADMIN^^0
"BLD",4001,"KRN",19.1,"NM",2,0)
ROR VA ICR USER^^0
"BLD",4001,"KRN",19.1,"NM","B","ROR VA ICR ADMIN",1)

"BLD",4001,"KRN",19.1,"NM","B","ROR VA ICR USER",2)

"BLD",4001,"KRN",101,0)
101
"BLD",4001,"KRN",101,"NM",0)
^9.68A^2^2
"BLD",4001,"KRN",101,"NM",1,0)
RORICR-SITE-DRIVER^^0
"BLD",4001,"KRN",101,"NM",2,0)
RORICR-SITE-SUBSCRIBER^^0
"BLD",4001,"KRN",101,"NM","B","RORICR-SITE-DRIVER",1)

"BLD",4001,"KRN",101,"NM","B","RORICR-SITE-SUBSCRIBER",2)

"BLD",4001,"KRN",409.61,0)
409.61
"BLD",4001,"KRN",771,0)
771
"BLD",4001,"KRN",771,"NM",0)
^9.68A^^
"BLD",4001,"KRN",870,0)
870
"BLD",4001,"KRN",870,"NM",0)
^9.68A^1^1
"BLD",4001,"KRN",870,"NM",1,0)
RORICR SND^^0
"BLD",4001,"KRN",870,"NM","B","RORICR SND",1)

"BLD",4001,"KRN",8989.51,0)
8989.51
"BLD",4001,"KRN",8989.51,"NM",0)
^9.68A^1^1
"BLD",4001,"KRN",8989.51,"NM",1,0)
ROR GUI PARAMETER^^0
"BLD",4001,"KRN",8989.51,"NM","B","ROR GUI PARAMETER",1)

"BLD",4001,"KRN",8989.52,0)
8989.52
"BLD",4001,"KRN",8994,0)
8994
"BLD",4001,"KRN",8994,"NM",0)
^9.68A^47^45
"BLD",4001,"KRN",8994,"NM",2,0)
ROR LOG GET ACCESS VIOLATIONS^^0
"BLD",4001,"KRN",8994,"NM",3,0)
ROR LOG GET LIST^^0
"BLD",4001,"KRN",8994,"NM",4,0)
ROR LOG GET MESSAGES^^0
"BLD",4001,"KRN",8994,"NM",5,0)
ROR TASK DELETE^^0
"BLD",4001,"KRN",8994,"NM",6,0)
ROR TASK INFO^^0
"BLD",4001,"KRN",8994,"NM",7,0)
ROR TASK LIST^^0
"BLD",4001,"KRN",8994,"NM",8,0)
ROR GET REGISTRY INFO^^0
"BLD",4001,"KRN",8994,"NM",10,0)
ROR GUI PARAMETER GET^^0
"BLD",4001,"KRN",8994,"NM",11,0)
ROR GUI PARAMETER SET^^0
"BLD",4001,"KRN",8994,"NM",12,0)
ROR GUI ACCESS^^0
"BLD",4001,"KRN",8994,"NM",13,0)
ROR REPORT RETRIEVE^^0
"BLD",4001,"KRN",8994,"NM",14,0)
ROR REPORT SCHEDULE^^0
"BLD",4001,"KRN",8994,"NM",15,0)
ROR REPORTS AVAILABLE^^0
"BLD",4001,"KRN",8994,"NM",16,0)
ROR LIST DIVISIONS^^0
"BLD",4001,"KRN",8994,"NM",17,0)
ROR LIST HOSPITAL LOCATIONS^^0
"BLD",4001,"KRN",8994,"NM",18,0)
ROR LIST ICD-9^^0
"BLD",4001,"KRN",8994,"NM",19,0)
ROR LIST VA DRUG CLASSES^^0
"BLD",4001,"KRN",8994,"NM",20,0)
ROR LOG INFO^^0
"BLD",4001,"KRN",8994,"NM",21,0)
ROR REPORT STYLESHEET^^0
"BLD",4001,"KRN",8994,"NM",22,0)
ROR LIST PATIENTS^^0
"BLD",4001,"KRN",8994,"NM",23,0)
ROR PATIENT SELECTION RULES^^0
"BLD",4001,"KRN",8994,"NM",24,0)
ROR LIST LABORATORY TESTS^^0
"BLD",4001,"KRN",8994,"NM",25,0)
ROR LIST ITEMS^^0
"BLD",4001,"KRN",8994,"NM",26,0)
ROR LIST COORDINATORS^^0
"BLD",4001,"KRN",8994,"NM",27,0)
ROR UPDATE COORDINATORS^^0
"BLD",4001,"KRN",8994,"NM",28,0)
ROR LIST VISTA USERS^^0
"BLD",4001,"KRN",8994,"NM",29,0)
ROR LIST REGISTRY USERS^^0
"BLD",4001,"KRN",8994,"NM",30,0)
RORICR CDC LOAD^^0
"BLD",4001,"KRN",8994,"NM",31,0)
ROR LIST STATES^^0
"BLD",4001,"KRN",8994,"NM",32,0)
RORICR CDC SAVE^^0
"BLD",4001,"KRN",8994,"NM",33,0)
ROR GET USER INFO^^0
"BLD",4001,"KRN",8994,"NM",34,0)
ROR PATIENT GET DATA^^0
"BLD",4001,"KRN",8994,"NM",35,0)
ROR PATIENT (IN)ACTIVATE^^0
"BLD",4001,"KRN",8994,"NM",36,0)
ROR PATIENT DELETE^^0
"BLD",4001,"KRN",8994,"NM",37,0)
ROR LIST LOCAL LAB TESTS^^0
"BLD",4001,"KRN",8994,"NM",38,0)
ROR UPDATE LOCAL LAB TESTS^^0
"BLD",4001,"KRN",8994,"NM",39,0)
ROR LIST LOCAL DRUGS^^0
"BLD",4001,"KRN",8994,"NM",40,0)
ROR UPDATE LOCAL DRUGS^^0
"BLD",4001,"KRN",8994,"NM",41,0)
ROR LIST DRUGS^^0
"BLD",4001,"KRN",8994,"NM",42,0)
RORICR PATIENT LOAD^^0
"BLD",4001,"KRN",8994,"NM",43,0)
RORICR PATIENT SAVE^^0
"BLD",4001,"KRN",8994,"NM",44,0)
RORICR PATIENT CANCEL^^0
"BLD",4001,"KRN",8994,"NM",45,0)
RORICR CDC CANCEL^^0
"BLD",4001,"KRN",8994,"NM",46,0)
ROR TASK VALIDATE RESCHEDULING^^0
"BLD",4001,"KRN",8994,"NM",47,0)
ROR LIST GENERIC DRUGS^^0
"BLD",4001,"KRN",8994,"NM","B","ROR GET REGISTRY INFO",8)

"BLD",4001,"KRN",8994,"NM","B","ROR GET USER INFO",33)

"BLD",4001,"KRN",8994,"NM","B","ROR GUI ACCESS",12)

"BLD",4001,"KRN",8994,"NM","B","ROR GUI PARAMETER GET",10)

"BLD",4001,"KRN",8994,"NM","B","ROR GUI PARAMETER SET",11)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST COORDINATORS",26)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST DIVISIONS",16)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST DRUGS",41)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST GENERIC DRUGS",47)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST HOSPITAL LOCATIONS",17)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST ICD-9",18)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST ITEMS",25)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST LABORATORY TESTS",24)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST LOCAL DRUGS",39)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST LOCAL LAB TESTS",37)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST PATIENTS",22)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST REGISTRY USERS",29)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST STATES",31)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST VA DRUG CLASSES",19)

"BLD",4001,"KRN",8994,"NM","B","ROR LIST VISTA USERS",28)

"BLD",4001,"KRN",8994,"NM","B","ROR LOG GET ACCESS VIOLATIONS",2)

"BLD",4001,"KRN",8994,"NM","B","ROR LOG GET LIST",3)

"BLD",4001,"KRN",8994,"NM","B","ROR LOG GET MESSAGES",4)

"BLD",4001,"KRN",8994,"NM","B","ROR LOG INFO",20)

"BLD",4001,"KRN",8994,"NM","B","ROR PATIENT (IN)ACTIVATE",35)

"BLD",4001,"KRN",8994,"NM","B","ROR PATIENT DELETE",36)

"BLD",4001,"KRN",8994,"NM","B","ROR PATIENT GET DATA",34)

"BLD",4001,"KRN",8994,"NM","B","ROR PATIENT SELECTION RULES",23)

"BLD",4001,"KRN",8994,"NM","B","ROR REPORT RETRIEVE",13)

"BLD",4001,"KRN",8994,"NM","B","ROR REPORT SCHEDULE",14)

"BLD",4001,"KRN",8994,"NM","B","ROR REPORT STYLESHEET",21)

"BLD",4001,"KRN",8994,"NM","B","ROR REPORTS AVAILABLE",15)

"BLD",4001,"KRN",8994,"NM","B","ROR TASK DELETE",5)

"BLD",4001,"KRN",8994,"NM","B","ROR TASK INFO",6)

"BLD",4001,"KRN",8994,"NM","B","ROR TASK LIST",7)

"BLD",4001,"KRN",8994,"NM","B","ROR TASK VALIDATE RESCHEDULING",46)

"BLD",4001,"KRN",8994,"NM","B","ROR UPDATE COORDINATORS",27)

"BLD",4001,"KRN",8994,"NM","B","ROR UPDATE LOCAL DRUGS",40)

"BLD",4001,"KRN",8994,"NM","B","ROR UPDATE LOCAL LAB TESTS",38)

"BLD",4001,"KRN",8994,"NM","B","RORICR CDC CANCEL",45)

"BLD",4001,"KRN",8994,"NM","B","RORICR CDC LOAD",30)

"BLD",4001,"KRN",8994,"NM","B","RORICR CDC SAVE",32)

"BLD",4001,"KRN",8994,"NM","B","RORICR PATIENT CANCEL",44)

"BLD",4001,"KRN",8994,"NM","B","RORICR PATIENT LOAD",42)

"BLD",4001,"KRN",8994,"NM","B","RORICR PATIENT SAVE",43)

"BLD",4001,"KRN","B",.4,.4)

"BLD",4001,"KRN","B",.401,.401)

"BLD",4001,"KRN","B",.402,.402)

"BLD",4001,"KRN","B",.403,.403)

"BLD",4001,"KRN","B",.5,.5)

"BLD",4001,"KRN","B",.84,.84)

"BLD",4001,"KRN","B",3.6,3.6)

"BLD",4001,"KRN","B",3.8,3.8)

"BLD",4001,"KRN","B",9.2,9.2)

"BLD",4001,"KRN","B",9.8,9.8)

"BLD",4001,"KRN","B",19,19)

"BLD",4001,"KRN","B",19.1,19.1)

"BLD",4001,"KRN","B",101,101)

"BLD",4001,"KRN","B",409.61,409.61)

"BLD",4001,"KRN","B",771,771)

"BLD",4001,"KRN","B",870,870)

"BLD",4001,"KRN","B",8989.51,8989.51)

"BLD",4001,"KRN","B",8989.52,8989.52)

"BLD",4001,"KRN","B",8994,8994)

"BLD",4001,"PRE")
RORP005
"BLD",4001,"PRET")
PTR^RORP005
"BLD",4001,"QUES",0)
^9.62^6^6
"BLD",4001,"QUES",1,0)
POS05 SETUP
"BLD",4001,"QUES",1,1)
Y
"BLD",4001,"QUES",1,"A")
Schedule the registry setup task
"BLD",4001,"QUES",1,"B")

"BLD",4001,"QUES",1,"M")
S DIR("B")=$S($$PATCH^XPDUTL("ROR*1*5"):"NO",1:"YES")
"BLD",4001,"QUES",1,"Q")
  Enter either 'Y' or 'N'.
"BLD",4001,"QUES",1,"Q1",0)
^^17^17^3040209^
"BLD",4001,"QUES",1,"Q1",1,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"BLD",4001,"QUES",1,"Q1",2,0)
  After the software is installed, the registry must be
"BLD",4001,"QUES",1,"Q1",3,0)
  populated with the patients that have HIV/AIDS related data.
"BLD",4001,"QUES",1,"Q1",4,0)
  The registry setup task populates the registry and performs
"BLD",4001,"QUES",1,"Q1",5,0)
  other implementation steps. If you are installing this patch
"BLD",4001,"QUES",1,"Q1",6,0)
  for the first time, you must answer YES.
"BLD",4001,"QUES",1,"Q1",7,0)
 
"BLD",4001,"QUES",1,"Q1",8,0)
  When the initial registry population is complete, you will
"BLD",4001,"QUES",1,"Q1",9,0)
  receive a VistA alert. Only after that you can add the name
"BLD",4001,"QUES",1,"Q1",10,0)
  of the registry (VA ICR) to the nightly task (the [ROR TASK]
"BLD",4001,"QUES",1,"Q1",11,0)
  option) parameter.
"BLD",4001,"QUES",1,"Q1",12,0)
 
"BLD",4001,"QUES",1,"Q1",13,0)
  If you are reinstalling the patch and initial registry
"BLD",4001,"QUES",1,"Q1",14,0)
  population has been done already, the answer depends on the
"BLD",4001,"QUES",1,"Q1",15,0)
  reason for the reinstallation and the instructions, which 
"BLD",4001,"QUES",1,"Q1",16,0)
  you have probably been given.
"BLD",4001,"QUES",1,"Q1",17,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"BLD",4001,"QUES",2,0)
POS10 MAXNTSK
"BLD",4001,"QUES",2,1)
N^0:10:0
"BLD",4001,"QUES",2,"A")
Maximum number of registry update subtasks
"BLD",4001,"QUES",2,"B")
5
"BLD",4001,"QUES",2,"M")
K:'$G(XPDQUES("POS05 SETUP")) DIR,XPDQUES("POS10 MAXNTSK")
"BLD",4001,"QUES",2,"Q")
  Enter a number between 0 and 10, 0 decimal digits.
"BLD",4001,"QUES",2,"Q1",0)
^^5^5^3030606^^
"BLD",4001,"QUES",2,"Q1",1,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"BLD",4001,"QUES",2,"Q1",2,0)
  During the initial registry population performed by the
"BLD",4001,"QUES",2,"Q1",3,0)
  registry setup task several registry update subtask can be
"BLD",4001,"QUES",2,"Q1",4,0)
  scheduled to speed up the process.
"BLD",4001,"QUES",2,"Q1",5,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"BLD",4001,"QUES",3,0)
POS15 SUSPEND
"BLD",4001,"QUES",3,1)
Y
"BLD",4001,"QUES",3,"A")
Suspend the post-install during the peak hours
"BLD",4001,"QUES",3,"B")
YES
"BLD",4001,"QUES",3,"M")
K:$G(XPDQUES("POS10 MAXNTSK"))<2 DIR,XPDQUES("POS15 SUSPEND")
"BLD",4001,"QUES",3,"Q")
  Enter either 'Y' or 'N'.
"BLD",4001,"QUES",3,"Q1",0)
^^12^12^3030606^^
"BLD",4001,"QUES",3,"Q1",1,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"BLD",4001,"QUES",3,"Q1",2,0)
  If you answer YES to this question, registry update subtasks
"BLD",4001,"QUES",3,"Q1",3,0)
  that populate the registry will be suspended during the peak
"BLD",4001,"QUES",3,"Q1",4,0)
  weekday hours to conserve the CPU resources.
"BLD",4001,"QUES",3,"Q1",5,0)
 
"BLD",4001,"QUES",3,"Q1",6,0)
  The tasks will not be suspended on weekends and holidays.
"BLD",4001,"QUES",3,"Q1",7,0)
  If the initial registry update runs in the single-task mode,
"BLD",4001,"QUES",3,"Q1",8,0)
  it will never be suspended.
"BLD",4001,"QUES",3,"Q1",9,0)
 
"BLD",4001,"QUES",3,"Q1",10,0)
  Two additional prompts will be displayed asking you to enter
"BLD",4001,"QUES",3,"Q1",11,0)
  start and end time of the suspension.
"BLD",4001,"QUES",3,"Q1",12,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"BLD",4001,"QUES",4,0)
POS20 SUSPEND BEGIN
"BLD",4001,"QUES",4,1)
D^::R
"BLD",4001,"QUES",4,"A")
Suspension start time
"BLD",4001,"QUES",4,"B")
6:00AM
"BLD",4001,"QUES",4,"M")
K:'$G(XPDQUES("POS15 SUSPEND")) DIR
"BLD",4001,"QUES",4,"Q")
  Enter time of the day (e.g. 8AM).
"BLD",4001,"QUES",4,"Q1",0)
^^6^6^3030606^
"BLD",4001,"QUES",4,"Q1",1,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"BLD",4001,"QUES",4,"Q1",2,0)
  Registry update subtasks will be suspended after this time 
"BLD",4001,"QUES",4,"Q1",3,0)
  every day except the weekends and holidays. However, they 
"BLD",4001,"QUES",4,"Q1",4,0)
  will be checking for a stop request every hour during the
"BLD",4001,"QUES",4,"Q1",5,0)
  suspension.
"BLD",4001,"QUES",4,"Q1",6,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"BLD",4001,"QUES",5,0)
POS25 SUSPEND END
"BLD",4001,"QUES",5,1)
D^::R
"BLD",4001,"QUES",5,"A")
Suspension end time
"BLD",4001,"QUES",5,"B")
8:00PM
"BLD",4001,"QUES",5,"M")
K:'$G(XPDQUES("POS15 SUSPEND")) DIR
"BLD",4001,"QUES",5,"Q")
  Enter time of the day (e.g. 5PM).
"BLD",4001,"QUES",5,"Q1",0)
^^5^5^3030609^^
"BLD",4001,"QUES",5,"Q1",1,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"BLD",4001,"QUES",5,"Q1",2,0)
  The registry update subtasks will be resumed at this time 
"BLD",4001,"QUES",5,"Q1",3,0)
  every day. The suspension end time must be later than the
"BLD",4001,"QUES",5,"Q1",4,0)
  suspension start time.
"BLD",4001,"QUES",5,"Q1",5,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"BLD",4001,"QUES",6,0)
POS30 CONFIRMATION
"BLD",4001,"QUES",6,1)
Y^^S:$$UP^XLFSTR($TR(X," "))?1"N".E X="^",(DUOUT,DIRUT)=1
"BLD",4001,"QUES",6,"A")
Are you sure
"BLD",4001,"QUES",6,"M")
D CONFTXT^RORP005 K:'$G(XPDQUES("POS05 SETUP")) DIR
"BLD",4001,"QUES",6,"Q")
  Enter 'Y' to continue or 'N' to cancel the installation.
"BLD",4001,"QUES",6,"Q1",0)
^^7^7^3040209^
"BLD",4001,"QUES",6,"Q1",1,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"BLD",4001,"QUES",6,"Q1",2,0)
  It is not possible to correct the value of the parameters 
"BLD",4001,"QUES",6,"Q1",3,0)
  unless the installation is restarted. If you have entered 
"BLD",4001,"QUES",6,"Q1",4,0)
  something incorrectly, cancel the installation (do not 
"BLD",4001,"QUES",6,"Q1",5,0)
  remove the Transport Global) and start it again using the 
"BLD",4001,"QUES",6,"Q1",6,0)
  Install Package(s) option.
"BLD",4001,"QUES",6,"Q1",7,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"BLD",4001,"QUES","B","POS05 SETUP",1)

"BLD",4001,"QUES","B","POS10 MAXNTSK",2)

"BLD",4001,"QUES","B","POS15 SUSPEND",3)

"BLD",4001,"QUES","B","POS20 SUSPEND BEGIN",4)

"BLD",4001,"QUES","B","POS25 SUSPEND END",5)

"BLD",4001,"QUES","B","POS30 CONFIRMATION",6)

"BLD",4001,"REQB",0)
^9.611^5^5
"BLD",4001,"REQB",1,0)
ROR*1.0*4^2
"BLD",4001,"REQB",2,0)
SD*5.3*131^2
"BLD",4001,"REQB",3,0)
LA*5.2*69^2
"BLD",4001,"REQB",4,0)
MC*2.3*34^2
"BLD",4001,"REQB",5,0)
PSN*4.0*79^2
"BLD",4001,"REQB","B","LA*5.2*69",3)

"BLD",4001,"REQB","B","MC*2.3*34",4)

"BLD",4001,"REQB","B","PSN*4.0*79",5)

"BLD",4001,"REQB","B","ROR*1.0*4",1)

"BLD",4001,"REQB","B","SD*5.3*131",2)

"DATA",798.1,2,0)
VA ICR^2850101^2850101^Immunology Case Registry^5475^1^^^^0^1^GAVRILOV,SERGUEI@FORUM.VA.GOV^^1
"DATA",798.1,2,1,0)
^798.13^5^5
"DATA",798.1,2,1,1,0)
VA ICR PROBLEM
"DATA",798.1,2,1,2,0)
VA ICR PTF
"DATA",798.1,2,1,3,0)
VA ICR VPOV
"DATA",798.1,2,1,4,0)
VA ICR LAB
"DATA",798.1,2,1,5,0)
VA ICR 2.1 CONVERSION
"DATA",798.1,2,4)
$$PREUPD^RORICR02
"DATA",798.1,2,5)
$$POSTUPD^RORICR03
"DATA",798.1,2,6,0)
^798.19I^35^35
"DATA",798.1,2,6,1,0)
PID^^5
"DATA",798.1,2,6,2,0)
ZSP^^5
"DATA",798.1,2,6,3,0)
ZRD^^5
"DATA",798.1,2,6,4,0)
PV1^^3
"DATA",798.1,2,6,5,0)
PV1^^2
"DATA",798.1,2,6,6,0)
CSR^^5
"DATA",798.1,2,6,6,1)

"DATA",798.1,2,6,7,0)
CSP^^5
"DATA",798.1,2,6,8,0)
CSS^^5
"DATA",798.1,2,6,8,1)

"DATA",798.1,2,6,9,0)
OBR^^11
"DATA",798.1,2,6,10,0)
OBX^^11
"DATA",798.1,2,6,11,0)
OBR^^4
"DATA",798.1,2,6,12,0)
OBX^^4
"DATA",798.1,2,6,13,0)
OBR^^7
"DATA",798.1,2,6,14,0)
OBR^^9
"DATA",798.1,2,6,15,0)
OBX^^9
"DATA",798.1,2,6,16,0)
OBR^^10
"DATA",798.1,2,6,17,0)
OBX^^10
"DATA",798.1,2,6,18,0)
OBR^^12
"DATA",798.1,2,6,19,0)
OBX^^12
"DATA",798.1,2,6,20,0)
OBR^^13
"DATA",798.1,2,6,21,0)
OBX^^13
"DATA",798.1,2,6,22,0)
OBR^^14
"DATA",798.1,2,6,23,0)
OBX^^14
"DATA",798.1,2,6,24,0)
OBR^^1
"DATA",798.1,2,6,25,0)
OBX^^1
"DATA",798.1,2,6,26,0)
ORC^^6
"DATA",798.1,2,6,27,0)
RXE^^6
"DATA",798.1,2,6,28,0)
OBR^^15
"DATA",798.1,2,6,29,0)
OBX^^15
"DATA",798.1,2,6,30,0)
OBR^^3
"DATA",798.1,2,6,31,0)
OBR^^2
"DATA",798.1,2,6,32,0)
OBX^^3
"DATA",798.1,2,6,33,0)
OBX^^2
"DATA",798.1,2,6,34,0)
OBX^^16
"DATA",798.1,2,6,35,0)
OBR^^16
"DATA",798.1,2,7)
$$MESSAGE^RORICREX
"DATA",798.1,2,8,0)
^798.112I^1^1
"DATA",798.1,2,8,1,0)
*^^CH
"DATA",798.1,2,9)
5488^5^2^CCRAutoNotification@med.va.gov
"DATA",798.1,2,10,0)
^798.114P^^0
"DATA",798.1,2,11)
7^1
"DATA",798.1,2,12,0)
^798.117^^0
"DATA",798.1,2,13,0)
^798.116A^^0
"DATA",798.1,2,14)
^
"DATA",798.1,2,18,0)
^798.118^2^2
"DATA",798.1,2,18,1,0)
ROR VA ICR USER
"DATA",798.1,2,18,2,0)
ROR VA ICR ADMIN
"DATA",798.1,2,19)
^
"DATA",798.1,2,21)
2850101^^^
"DATA",798.1,2,21.03)

"DATA",798.1,2,27)
1,2,3,4,5,6,7,8,9,10,11,12,13,14
"DATA",798.1,2,28,0)
^798.128PI^^0
"DATA",798.1,2,29,0)
^798.129P^^0
"DATA",798.2,14,0)
VA ICR PTF^45^ICR ICD-9 code in the PTF file^1
"DATA",798.2,14,1)
$$PTFRULE^RORUPD09(",V08.,042.,042.0,042.1,042.2,042.9,043.0,043.2,043.3,043.9,044.0,044.9,079.53,795.71,795.8,")
"DATA",798.2,14,4,0)
^798.26^11^11
"DATA",798.2,14,4,1,0)
101^E
"DATA",798.2,14,4,2,0)
102^E
"DATA",798.2,14,4,3,0)
103^E
"DATA",798.2,14,4,4,0)
104^E
"DATA",798.2,14,4,5,0)
105^E
"DATA",798.2,14,4,6,0)
106^E
"DATA",798.2,14,4,7,0)
107^E
"DATA",798.2,14,4,8,0)
108^E
"DATA",798.2,14,4,9,0)
109^E
"DATA",798.2,14,4,10,0)
110^E
"DATA",798.2,14,4,11,0)
111^E
"DATA",798.2,15,0)
VA ICR PROBLEM^9000011^ICR ICD-9 in the Problem List^1
"DATA",798.2,15,1)
",V08.,042.,042.0,042.1,042.2,042.9,043.0,043.2,043.3,043.9,044.0,044.9,079.53,795.71,795.8,"[(","_{E:DIAGNOSIS}_",")
"DATA",798.2,16,0)
VA ICR VPOV^9000010.07^ICR ICD-9 code in V POV file^1
"DATA",798.2,16,1)
",V08.,042.,042.0,042.1,042.2,042.9,043.0,043.2,043.3,043.9,044.0,044.9,079.53,795.71,795.8,"[(","_{E:POV}_",")
"DATA",798.2,16,3,0)
^798.25^1^1^3030507^^^^
"DATA",798.2,16,3,1,0)
 
"DATA",798.2,17,0)
VA ICR LAB^63^ICR Lab Results^1
"DATA",798.2,17,1)
{LS:VA ICR}
"DATA",798.2,18,0)
VA ICR 2.1 CONVERSION^2^Converted from ICR 2.1^1
"DATA",798.2,18,1)
0
"DATA",798.9,4,0)
VA ICR^^1
"DATA",798.9,4,1,0)
^798.92^24^22
"DATA",798.9,4,1,1,0)
29327^^6
"DATA",798.9,4,1,4,0)
31201^^0
"DATA",798.9,4,1,5,0)
32571^^0
"DATA",798.9,4,1,6,0)
32602^^0
"DATA",798.9,4,1,7,0)
33866^^0
"DATA",798.9,4,1,8,0)
5223^^6
"DATA",798.9,4,1,9,0)
5224^^6
"DATA",798.9,4,1,10,0)
5225^^6
"DATA",798.9,4,1,11,0)
5220^^6
"DATA",798.9,4,1,12,0)
5221^^6
"DATA",798.9,4,1,13,0)
7917^^6
"DATA",798.9,4,1,14,0)
7918^^6
"DATA",798.9,4,1,15,0)
7919^^6
"DATA",798.9,4,1,16,0)
29893^^0
"DATA",798.9,4,1,17,0)
14092^^6
"DATA",798.9,4,1,18,0)
16974^^6
"DATA",798.9,4,1,19,0)
21007^^6
"DATA",798.9,4,1,20,0)
22356^^6
"DATA",798.9,4,1,21,0)
22357^^6
"DATA",798.9,4,1,22,0)
22358^^6
"DATA",798.9,4,1,23,0)
30361^^0
"DATA",798.9,4,1,24,0)
16975^^6
"DATA",799.1,1,0)
Manually Entered/Confirmed in Error^1^1^1^
"DATA",799.1,2,0)
Miscoded ICD-9 Diagnosis^1^1^2
"DATA",799.1,3,0)
No evidence of chronic infection (includes False + screen)^1^1^3^
"DATA",799.1,4,0)
Care elsewhere^1^1^4^
"DATA",799.1,5,0)
Ab (+) and/or viral load (+) from another VA (untreated)^2^1^1
"DATA",799.1,6,0)
Ab (+) and/or viral load (+) from outside VA (untreated)^2^1^2
"DATA",799.1,7,0)
Patient previously diagnosed and treated within VA^2^1^3
"DATA",799.1,8,0)
Patient previously diagnosed and treated outside VA^2^1^4
"DATA",799.1,9,0)
Other^2^1^5
"DATA",799.1,10,0)
Manually Entered/Confirmed in Error^1^2^1
"DATA",799.1,11,0)
Miscoded ICD-9 Diagnosis^1^2^2
"DATA",799.1,16,0)
Other^2^2^99
"DATA",799.1,17,0)
CD4 Count^3^2^1
"DATA",799.1,18,0)
CD4 %^3^2^2
"DATA",799.1,19,0)
Viral Load^3^2^3
"DATA",799.1,20,0)
Default^4^2^99
"DATA",799.1,21,0)
Patient previously diagnosed within VA^2^2^3
"DATA",799.1,22,0)
Patient previously diagnosed outside VA^2^2^4
"DATA",799.1,24,0)
Other^1^1^99
"DATA",799.1,25,0)
Other^1^2^99
"DATA",799.1,26,0)
No evidence of chronic infection (includes False + screen)^1^2^3
"DATA",799.31,1,0)
REPORT
"DATA",799.31,2,0)
PARAMETERS
"DATA",799.31,3,0)
PATIENTS
"DATA",799.31,4,0)
CAREONLY
"DATA",799.31,5,0)
PATIENT
"DATA",799.31,6,0)
CATSPLIT
"DATA",799.31,7,0)
COLSPAN
"DATA",799.31,8,0)
ARV
"DATA",799.31,9,0)
NAME
"DATA",799.31,10,0)
DOB
"DATA",799.31,11,0)
DOD
"DATA",799.31,12,0)
COMPLETE
"DATA",799.31,13,0)
COUNT
"DATA",799.31,14,0)
DE_BEFORE
"DATA",799.31,15,0)
DATE
"DATA",799.31,16,0)
DE_DURING
"DATA",799.31,17,0)
HIV
"DATA",799.31,18,0)
ACTIVE
"DATA",799.31,19,0)
DFN
"DATA",799.31,20,0)
ICN
"DATA",799.31,21,0)
ID
"DATA",799.31,22,0)
INACTIVE
"DATA",799.31,23,0)
NEW
"DATA",799.31,24,0)
NOTSEEN
"DATA",799.31,25,0)
SELRULES
"DATA",799.31,26,0)
RULE
"DATA",799.31,27,0)
SSN
"DATA",799.31,28,0)
CSSN
"DATA",799.31,29,0)
AIDSTAT
"DATA",799.31,30,0)
ALIVE
"DATA",799.31,31,0)
AGE
"DATA",799.31,32,0)
ENTDT
"DATA",799.31,33,0)
INADT
"DATA",799.31,34,0)
PRIMELIG
"DATA",799.31,35,0)
RACE
"DATA",799.31,36,0)
READT
"DATA",799.31,37,0)
REIMBLVL
"DATA",799.31,38,0)
RISK
"DATA",799.31,39,0)
SEX
"DATA",799.31,40,0)
DE_AFTER
"DATA",799.31,41,0)
UTIL
"DATA",799.31,42,0)
CD4OPT
"DATA",799.31,43,0)
CLINICS
"DATA",799.31,44,0)
CLINIC
"DATA",799.31,45,0)
CUTOFF
"DATA",799.31,46,0)
DATE_RANGE
"DATA",799.31,47,0)
DIVISION
"DATA",799.31,48,0)
DIVISIONS
"DATA",799.31,49,0)
DRUGS
"DATA",799.31,50,0)
FIELDS
"DATA",799.31,51,0)
ICD9LST
"DATA",799.31,52,0)
ICD9
"DATA",799.31,53,0)
LABTESTS
"DATA",799.31,54,0)
LT
"DATA",799.31,55,0)
MAXUTNUM
"DATA",799.31,57,0)
MINRPNUM
"DATA",799.31,58,0)
OPTIONS
"DATA",799.31,59,0)
REGIEN
"DATA",799.31,60,0)
VIRAL_LOAD
"DATA",799.31,61,0)
LOW
"DATA",799.31,62,0)
HIGH
"DATA",799.31,63,0)
START
"DATA",799.31,64,0)
END
"DATA",799.31,65,0)
PARAMETER
"DATA",799.31,66,0)
TASK_DESCR
"DATA",799.31,67,0)
REGNAME
"DATA",799.31,69,0)
COLUMN
"DATA",799.31,70,0)
TITLE
"DATA",799.31,71,0)
HEADER
"DATA",799.31,72,0)
DESCR
"DATA",799.31,73,0)
LAST4
"DATA",799.31,74,0)
TASK_NUMBER
"DATA",799.31,75,0)
UPDATED_UNTIL
"DATA",799.31,76,0)
EXTRACTED_UNTIL
"DATA",799.31,77,0)
WARD
"DATA",799.31,78,0)
ADMDT
"DATA",799.31,79,0)
LOS
"DATA",799.31,80,0)
LOSFYTD
"DATA",799.31,81,0)
CATEGORY
"DATA",799.31,82,0)
SUMMARY
"DATA",799.31,83,0)
RACES
"DATA",799.31,84,0)
RISK_FACTORS
"DATA",799.31,85,0)
RACE_SUMMARY
"DATA",799.31,86,0)
SEX_SUMMARY
"DATA",799.31,87,0)
REIMBLVL_SUMMARY
"DATA",799.31,88,0)
AGE_SUMMARY
"DATA",799.31,89,0)
SEEN
"DATA",799.31,90,0)
SEEN_SUMMARY
"DATA",799.31,91,0)
LSNDT
"DATA",799.31,92,0)
CPT
"DATA",799.31,93,0)
QNTY
"DATA",799.31,94,0)
TOTAL
"DATA",799.31,95,0)
UNIQUE
"DATA",799.31,96,0)
PATIENT_SUMMARY
"DATA",799.31,97,0)
PROCEDURE
"DATA",799.31,98,0)
PROCEDURES
"DATA",799.31,99,0)
GROUP
"DATA",799.31,100,0)
RESULT
"DATA",799.31,101,0)
INARSN
"DATA",799.31,102,0)
REARSN
"DATA",799.31,103,0)
UTIL_CODES
"DATA",799.31,104,0)
INPATIENT
"DATA",799.31,105,0)
OUTPATIENTS
"DATA",799.31,106,0)
INPATIENTS
"DATA",799.31,107,0)
VISITS
"DATA",799.31,108,0)
STOPS
"DATA",799.31,109,0)
BEDSECTIONS
"DATA",799.31,110,0)
BEDSECTION
"DATA",799.31,111,0)
ITEM
"DATA",799.31,112,0)
STOP
"DATA",799.31,113,0)
CODE
"DATA",799.31,114,0)
STAYS
"DATA",799.31,115,0)
ND
"DATA",799.31,116,0)
NP
"DATA",799.31,117,0)
NSC
"DATA",799.31,118,0)
ALOS
"DATA",799.31,119,0)
MLOS
"DATA",799.31,120,0)
NV
"DATA",799.31,121,0)
DISPENSED
"DATA",799.31,122,0)
GENERIC
"DATA",799.31,123,0)
AIDS
"DATA",799.31,124,0)
ALL
"DATA",799.31,125,0)
OLD
"DATA",799.31,126,0)
OUTPATIENT
"DATA",799.31,127,0)
PTF
"DATA",799.31,128,0)
RANGE
"DATA",799.31,129,0)
ROWSPAN
"DATA",799.31,130,0)
TABLE
"DATA",799.31,131,0)
TYPE
"DATA",799.31,132,0)
USE
"DATA",799.31,133,0)
VARXCLS
"DATA",799.31,134,0)
VALUE
"DATA",799.31,135,0)
WIDTH
"DATA",799.31,136,0)
NDS
"DATA",799.31,137,0)
HIGHUTIL
"DATA",799.31,138,0)
DAYS
"DATA",799.31,139,0)
NOBS
"DATA",799.31,140,0)
HU_VISITS
"DATA",799.31,141,0)
HU_STAYS
"DATA",799.31,142,0)
HU_DAYS
"DATA",799.31,143,0)
NO
"DATA",799.31,144,0)
NR
"DATA",799.31,145,0)
NDT
"DATA",799.31,146,0)
MAXNRPP
"DATA",799.31,147,0)
ORDERS
"DATA",799.31,148,0)
VARDUMP
"DATA",799.31,149,0)
MAXNP
"DATA",799.31,150,0)
NC
"DATA",799.31,151,0)
DIAG
"DATA",799.31,152,0)
NDC
"DATA",799.31,153,0)
PTICDL
"DATA",799.31,154,0)
LAB
"DATA",799.31,155,0)
PHARMACY
"DATA",799.31,156,0)
DRUG
"DATA",799.31,157,0)
VARXCL
"DATA",799.31,158,0)
AIDSNOARV
"DATA",799.31,159,0)
ARVSMRY
"DATA",799.31,160,0)
PTLIST
"DATA",799.31,161,0)
COMPLEX
"DATA",799.31,162,0)
BASIC
"DATA",799.31,163,0)
PTLRL
"DATA",799.31,164,0)
PTRXL
"DATA",799.31,165,0)
RXCOMB
"DATA",799.31,166,0)
RXCOMBLST
"DATA",799.31,167,0)
TBLDEF
"DATA",799.31,168,0)
NST
"DATA",799.31,169,0)
NSS
"DATA",799.31,170,0)
NPR
"DATA",799.31,171,0)
NDP
"DATA",799.31,172,0)
FOOTER
"DATA",799.31,173,0)
INVESTIG
"DATA",799.31,174,0)
NPBASIC
"DATA",799.31,175,0)
NPCOMPLEX
"DATA",799.31,176,0)
NPARV
"DATA",799.31,177,0)
NPHIV
"DATA",799.31,178,0)
NPAIDS
"DATA",799.31,179,0)
FILLTYPE
"DATA",799.31,180,0)
ORDER
"DATA",799.31,181,0)
FILLS
"DATA",799.31,182,0)
DOSES
"DATA",799.31,183,0)
NF
"DATA",799.31,184,0)
HU_FILLS
"DATA",799.31,185,0)
HU_DOSES
"DATA",799.31,186,0)
NRX
"DATA",799.31,187,0)
NOTES
"DATA",799.31,188,0)
AGE_BASE_DATE
"DATA",799.31,189,0)
ROOM-BED
"DATA",799.31,190,0)
DAYSPLY
"DATA",799.31,191,0)
HU_STOPS
"DATA",799.31,192,0)
RESULTS
"DATA",799.31,193,0)
DRUGS_FILLS
"DATA",799.31,194,0)
DRUGS_DOSES
"DATA",799.33,1,0)
Lab
"DATA",799.33,2,0)
Outpatient
"DATA",799.33,3,0)
Inpatient
"DATA",799.33,4,0)
Radiology
"DATA",799.33,5,0)
Patient
"DATA",799.33,6,0)
Pharmacy
"DATA",799.33,7,0)
Autopsy
"DATA",799.33,8,0)
Liver Biopsy
"DATA",799.33,9,0)
Surgical Pathology
"DATA",799.33,10,0)
Cytopathology
"DATA",799.33,11,0)
Microbiology
"DATA",799.33,12,0)
EKG
"DATA",799.33,13,0)
Allergy
"DATA",799.33,14,0)
IV
"DATA",799.33,15,0)
Vitals
"DATA",799.33,16,0)
Problem List
"DATA",799.34,1,0)
List of Registry Patients^1^^1^^^^^1
"DATA",799.34,1,1)
10,20,32
"DATA",799.34,1,10.01)
$$REGPTLST^RORX001
"DATA",799.34,1,11,0)
^^2^2^3031209^
"DATA",799.34,1,11,1,0)
DATE_RANGE=YEAR
"DATA",799.34,1,11,2,0)
PATIENTS=ACTIVE
"DATA",799.34,1,12,0)
^^1^1^3031119^
"DATA",799.34,1,12,1,0)
PATIENTS=NAME
"DATA",799.34,2,0)
Current Inpatient List^1^^2^^^^^1
"DATA",799.34,2,1)
14
"DATA",799.34,2,10.01)
$$INPTLST^RORX002
"DATA",799.34,2,12,0)
^^1^1^3031119^
"DATA",799.34,2,12,1,0)
PATIENTS=NAME
"DATA",799.34,3,0)
General Utilization and Demographics^1^^3^^^^^1
"DATA",799.34,3,1)
10,22,24,62,30
"DATA",799.34,3,10.01)
$$UTLDMG^RORX003
"DATA",799.34,3,11,0)
^^3^3^3031209^
"DATA",799.34,3,11,1,0)
DATE_RANGE=YEAR
"DATA",799.34,3,11,2,0)
OPTIONS=COMPLETE
"DATA",799.34,3,11,3,0)
PATIENTS=DE_BEFORE,DE_DURING,DE_AFTER,HIV,AIDS
"DATA",799.34,3,12,0)
^^1^1^3031119^
"DATA",799.34,3,12,1,0)
PATIENTS=NAME
"DATA",799.34,4,0)
Clinic Follow Up^1^^4^^^^^1
"DATA",799.34,4,1)
10,22,24,60,110,80,50
"DATA",799.34,4,10.01)
$$CLNFLWUP^RORX004
"DATA",799.34,4,11,0)
^^4^4^3031209^
"DATA",799.34,4,11,1,0)
CLINICS=ALL
"DATA",799.34,4,11,2,0)
DATE_RANGE=YEAR
"DATA",799.34,4,11,3,0)
OPTIONS=SUMMARY
"DATA",799.34,4,11,4,0)
PATIENTS=DE_BEFORE,DE_DURING,DE_AFTER,HIV,AIDS,SEEN
"DATA",799.34,4,12,0)
^799.3412^1^1^3031119^^
"DATA",799.34,4,12,1,0)
PATIENTS=NAME
"DATA",799.34,5,0)
Inpatient and Outpatient Utilization^1^^5^^^^^1
"DATA",799.34,5,1)
10,22,24,170,26,110,46,34
"DATA",799.34,5,10.01)
$$IPOPUTL^RORX005
"DATA",799.34,5,11,0)
^^4^4^3031209^
"DATA",799.34,5,11,1,0)
DATE_RANGE=YEAR
"DATA",799.34,5,11,2,0)
DIVISIONS=ALL
"DATA",799.34,5,11,3,0)
MAXUTNUM=10
"DATA",799.34,5,11,4,0)
PATIENTS=DE_BEFORE,DE_DURING,DE_AFTER,INPATIENT,OUTPATIENT,AIDS,HIV
"DATA",799.34,5,12,0)
^^8^8^3031205^
"DATA",799.34,5,12,1,0)
BEDSECTIONS=NAME
"DATA",799.34,5,12,2,0)
CLINICS=STOP
"DATA",799.34,5,12,3,0)
HU_DAYS=ND:DESC 
"DATA",799.34,5,12,4,0)
HU_STAYS=NST:DESC
"DATA",799.34,5,12,5,0)
HU_STOPS=NSC:DESC
"DATA",799.34,5,12,6,0)
NOBS=NAME
"DATA",799.34,5,12,7,0)
STAYS=NST:DESC
"DATA",799.34,5,12,8,0)
STOPS=NSC:DESC
"DATA",799.34,6,0)
Lab Utilization^1^^6^^^^^1
"DATA",799.34,6,1)
10,22,24,110,120,52
"DATA",799.34,6,10.01)
$$LABUTL^RORX006
"DATA",799.34,6,11,0)
^799.3411^5^5^3040113^^^
"DATA",799.34,6,11,1,0)
DATE_RANGE=YEAR
"DATA",799.34,6,11,2,0)
LABTESTS=ALL
"DATA",799.34,6,11,3,0)
MAXUTNUM=10
"DATA",799.34,6,11,4,0)
MINRPNUM=1
"DATA",799.34,6,11,5,0)
PATIENTS=DE_BEFORE,DE_DURING,DE_AFTER,AIDS,HIV
"DATA",799.34,6,12,0)
^799.3412^3^3^3040113^^
"DATA",799.34,6,12,1,0)
LABTESTS=NAME
"DATA",799.34,6,12,2,0)
PATIENTS=NR:DESC
"DATA",799.34,6,12,3,0)
RESULTS=NR:DESC
"DATA",799.34,7,0)
Radiology Utilization^1^^7^^^^^1
"DATA",799.34,7,1)
10,22,24,110,120,100
"DATA",799.34,7,10.01)
$$RADUTL^RORX007
"DATA",799.34,7,11,0)
^799.3411^4^4^3040113^^^
"DATA",799.34,7,11,1,0)
DATE_RANGE=YEAR
"DATA",799.34,7,11,2,0)
MAXUTNUM=10
"DATA",799.34,7,11,3,0)
MINRPNUM=1
"DATA",799.34,7,11,4,0)
PATIENTS=DE_BEFORE,DE_DURING,DE_AFTER,AIDS,HIV
"DATA",799.34,7,12,0)
^799.3412^2^2^3040113^^
"DATA",799.34,7,12,1,0)
PATIENTS=TOTAL:DESC
"DATA",799.34,7,12,2,0)
PROCEDURES=NAME
"DATA",799.34,8,0)
VERA Reimbursement Report^1^^8^^^^^1
"DATA",799.34,8,1)
10,22,24,28,84,56,100
"DATA",799.34,8,10.01)
$$ARVREIMB^RORX008
"DATA",799.34,8,11,0)
^^3^3^3031209^
"DATA",799.34,8,11,1,0)
DATE_RANGE=YEAR
"DATA",799.34,8,11,2,0)
DRUGS=INVESTIG
"DATA",799.34,8,11,3,0)
PATIENTS=DE_BEFORE,DE_DURING,DE_AFTER,AIDS,HIV
"DATA",799.34,8,12,0)
^^2^2^3031120^
"DATA",799.34,8,12,1,0)
DRUGS=NAME
"DATA",799.34,8,12,2,0)
PATIENTS=NAME
"DATA",799.34,9,0)
Pharmacy Prescription Utilization^1^^9^^^^^1
"DATA",799.34,9,1)
10,22,24,170,26,110,46,84,44,40
"DATA",799.34,9,10.01)
$$RXUTIL^RORX009
"DATA",799.34,9,11,0)
^799.3411^5^5^3031209^^
"DATA",799.34,9,11,1,0)
DATE_RANGE=YEAR
"DATA",799.34,9,11,2,0)
DRUGS=GENERIC
"DATA",799.34,9,11,3,0)
MAXUTNUM=10
"DATA",799.34,9,11,4,0)
PATIENTS=DE_BEFORE,DE_DURING,DE_AFTER,AIDS,HIV,INPATIENT,OUTPATIENT
"DATA",799.34,9,11,5,0)
VADRUGCLS=ALL
"DATA",799.34,9,12,0)
^^2^2^3031209^
"DATA",799.34,9,12,1,0)
DRUGS=NAME
"DATA",799.34,9,12,2,0)
PATIENTS=NAME
"DATA",799.34,10,0)
HIV Viral Load and CD4 by Range^1^^10^^^^^1
"DATA",799.34,10,1)
10,24,48
"DATA",799.34,10,10.01)
$$VRLCD4^RORX010
"DATA",799.34,10,11,0)
^799.3411^4^4^3031209^
"DATA",799.34,10,11,1,0)
CD4OPT=1^0
"DATA",799.34,10,11,2,0)
DATE_RANGE=YEAR
"DATA",799.34,10,11,3,0)
PATIENTS=HIV,AIDS
"DATA",799.34,10,11,4,0)
VIRAL_LOAD=1^0
"DATA",799.34,10,12,0)
^^2^2^3031119^
"DATA",799.34,10,12,1,0)
PATIENTS=NAME
"DATA",799.34,10,12,2,0)
PTLRL=GROUP
"DATA",799.34,11,0)
Patient Drug History^1^^11^^^^^1
"DATA",799.34,11,1)
10,170,26,140,41
"DATA",799.34,11,10.01)
$$RXHIST^RORX011
"DATA",799.34,11,11,0)
^^3^3^3031209^
"DATA",799.34,11,11,1,0)
DATE_RANGE=YEAR
"DATA",799.34,11,11,2,0)
DRUGS=ALL
"DATA",799.34,11,11,3,0)
PATIENTS=INPATIENT,OUTPATIENT
"DATA",799.34,12,0)
Combined RX and Lab Report^1^^12^^^^^1
"DATA",799.34,12,1)
10,22,24,64,84,54,44,52
"DATA",799.34,12,10.01)
$$RXANDLAB^RORX012
"DATA",799.34,12,11,0)
^^5^5^3031209^
"DATA",799.34,12,11,1,0)
DATE_RANGE=YEAR
"DATA",799.34,12,11,2,0)
DRUGS=GENERIC
"DATA",799.34,12,11,3,0)
LABTESTS=ALL
"DATA",799.34,12,11,4,0)
OPTIONS=LAB,PHARMACY
"DATA",799.34,12,11,5,0)
PATIENTS=DE_BEFORE,DE_DURING,DE_AFTER,HIV,AIDS
"DATA",799.34,12,12,0)
^799.3412^3^3^3031205^^^^
"DATA",799.34,12,12,1,0)
PATIENTS=NAME
"DATA",799.34,12,12,2,0)
PTLRL=DATE
"DATA",799.34,12,12,3,0)
PTRXL=NAME
"DATA",799.34,13,0)
Diagnosis Code Report^1^^13^^^^^1
"DATA",799.34,13,1)
10,22,24,62,58
"DATA",799.34,13,10.01)
$$ICD9LST^RORX013
"DATA",799.34,13,11,0)
^^4^4^3031209^
"DATA",799.34,13,11,1,0)
DATE_RANGE=YEAR
"DATA",799.34,13,11,2,0)
ICD9LST=ALL
"DATA",799.34,13,11,3,0)
OPTIONS=COMPLETE
"DATA",799.34,13,11,4,0)
PATIENTS=DE_BEFORE,DE_DURING,DE_AFTER,HIV,AIDS
"DATA",799.34,13,12,0)
^799.3412^3^3^3031119^^^
"DATA",799.34,13,12,1,0)
ICD9LST=CODE
"DATA",799.34,13,12,2,0)
PATIENTS=NAME
"DATA",799.34,13,12,3,0)
PTICDL=CODE
"DATA",799.34,14,0)
ARV Combination Report^1^^14^^^^^1
"DATA",799.34,14,1)
10,22,24,170,26,62,84,56,100
"DATA",799.34,14,10.01)
$$ARVCOMB^RORX014
"DATA",799.34,14,11,0)
^799.3411^3^3^3031209^^
"DATA",799.34,14,11,1,0)
DATE_RANGE=YEAR
"DATA",799.34,14,11,2,0)
OPTIONS=COMPLETE
"DATA",799.34,14,11,3,0)
PATIENTS=DE_BEFORE,DE_DURING,DE_AFTER,HIV,AIDS,INPATIENT,OUTPATIENT
"DATA",799.34,14,12,0)
^799.3412^3^3^3031209^^^
"DATA",799.34,14,12,1,0)
DRUGS=NAME
"DATA",799.34,14,12,2,0)
PATIENTS=NAME
"DATA",799.34,14,12,3,0)
RXCOMBLST=NP:DESC
"DATA",799.49,1,0)
CANDIDIASIS, B, T, OR L^1:Definitive^1
"DATA",799.49,1,1)
Candidiasis, bronchi, trachea, or lungs
"DATA",799.49,1,2,0)
^799.492^7^7^3030507^^
"DATA",799.49,1,2,1,0)
Definitive Diagnostic Method:
"DATA",799.49,1,2,2,0)
 
"DATA",799.49,1,2,3,0)
Gross inspection by endoscopy or autopsy, or 
"DATA",799.49,1,2,4,0)
microscopy (histology or cytology) on a specimen
"DATA",799.49,1,2,5,0)
obtained directly from the tissues affected
"DATA",799.49,1,2,6,0)
(including scrapings from the mucosal surface),
"DATA",799.49,1,2,7,0)
not from a culture.
"DATA",799.49,2,0)
CANDIDIASIS, ESOPHAGEAL^1:Definitive;2:Presumptive^2
"DATA",799.49,2,1)
Candidiasis, esophageal
"DATA",799.49,2,2,0)
^799.492^7^7^3030507^^
"DATA",799.49,2,2,1,0)
Definitive Diagnostic Method:
"DATA",799.49,2,2,2,0)
 
"DATA",799.49,2,2,3,0)
Gross inspection by endoscopy or autopsy, or 
"DATA",799.49,2,2,4,0)
microscopy (histology or cytology) on a specimen
"DATA",799.49,2,2,5,0)
obtained directly from the tissues affected
"DATA",799.49,2,2,6,0)
(including scrapings from the mucosal surface),
"DATA",799.49,2,2,7,0)
not from a culture.
"DATA",799.49,3,0)
CARCINOMA, INVASIVE CERVICAL^1:Definitive^3
"DATA",799.49,3,1)
Carcinoma, invasive cervical
"DATA",799.49,4,0)
COCCIDIOIDOMYCOSIS, DIS/EXTRAP^1:Definitive^4
"DATA",799.49,4,1)
Coccidioidomycosis, disseminated or extrapulmonary
"DATA",799.49,4,2,0)
^799.492^6^6^3030507^^
"DATA",799.49,4,2,1,0)
Definitive Diagnostic Method:
"DATA",799.49,4,2,2,0)
 
"DATA",799.49,4,2,3,0)
Microscopy (histology or cytology), culture, or 
"DATA",799.49,4,2,4,0)
detection of antigen in a specimen obtained
"DATA",799.49,4,2,5,0)
directly from the tissues affected or a fluid from
"DATA",799.49,4,2,6,0)
those tissues.
"DATA",799.49,5,0)
CRYPTOCOCCOSIS, EXTRAPULMONARY^1:Definitive^5
"DATA",799.49,5,1)
Cryptococcosis, extrapulmonary
"DATA",799.49,5,2,0)
^799.492^6^6^3030507^^
"DATA",799.49,5,2,1,0)
Definitive Diagnostic Method:
"DATA",799.49,5,2,2,0)
 
"DATA",799.49,5,2,3,0)
Microscopy (histology or cytology), culture, or 
"DATA",799.49,5,2,4,0)
detection of antigen in a specimen obtained
"DATA",799.49,5,2,5,0)
directly from the tissues affected or a fluid from
"DATA",799.49,5,2,6,0)
those tissues.
"DATA",799.49,6,0)
CRYPTOSPORIDIOSIS, CHRONIC^1:Definitive^6
"DATA",799.49,6,1)
Cryptosporidiosis, chronic intestinal (>1mo.Duration)
"DATA",799.49,6,2,0)
^799.492^2^2^3030507^^
"DATA",799.49,6,2,1,0)
Definitive Diagnostic Method: Microscopy
"DATA",799.49,6,2,2,0)
(histology or cytology).
"DATA",799.49,7,0)
CYTOMEGALOVIRUS DISEASE^1:Definitive^7
"DATA",799.49,7,1)
Cytomegalovirus disease (other than liver, spleen, or nodes)
"DATA",799.49,7,2,0)
^^2^2^3030507^
"DATA",799.49,7,2,1,0)
Definitive Diagnostic Method: Microscopy 
"DATA",799.49,7,2,2,0)
(histology or cytology).
"DATA",799.49,8,0)
CYTOMEGALOVIRUS RETINITIS^1:Definitive;2:Presumptive^8
"DATA",799.49,8,1)
Cytomegalovirus retinitis (with loss of vision)
"DATA",799.49,8,2,0)
^799.492^2^2^3030507^^
"DATA",799.49,8,2,1,0)
Definitive Diagnostic Method: Microscopy 
"DATA",799.49,8,2,2,0)
(histology or cytology).
"DATA",799.49,9,0)
HIV ENCEPHALOPATHY^1:Definitive^9
"DATA",799.49,9,1)
HIV encephalopathy
"DATA",799.49,9,2,0)
^799.492^15^15^3030507^^
"DATA",799.49,9,2,1,0)
Definitive Diagnostic Method:
"DATA",799.49,9,2,2,0)
 
"DATA",799.49,9,2,3,0)
NOTE: The method of diagnosis described here is 
"DATA",799.49,9,2,4,0)
not truly definitive but is sufficiently rigorous
"DATA",799.49,9,2,5,0)
for surveillance purposes.
"DATA",799.49,9,2,6,0)
  
"DATA",799.49,9,2,7,0)
Clinical findings of disabling cognitive and/or
"DATA",799.49,9,2,8,0)
motor dysfunction interfering with occupation or
"DATA",799.49,9,2,9,0)
activities of daily living, in the absence of a
"DATA",799.49,9,2,10,0)
concurrent illness or condition other than HIV
"DATA",799.49,9,2,11,0)
infection that could explain the findings.  
"DATA",799.49,9,2,12,0)
Methods to rule out such concurrent illnesses and
"DATA",799.49,9,2,13,0)
conditions must include cerebrospinal fluid
"DATA",799.49,9,2,14,0)
examination and either brain imaging (computed
"DATA",799.49,9,2,15,0)
tomography or magnetic resonance) or autopsy.
"DATA",799.49,10,0)
HERPES SIMPLEX^1:Definitive^10
"DATA",799.49,10,1)
Herpes simplex chronic ulcer(s) (>1mo.duration); or bronchitis, pneumonitis or esophagitis
"DATA",799.49,10,2,0)
^799.492^6^6^3030507^^
"DATA",799.49,10,2,1,0)
Definitive Diagnostic Method:
"DATA",799.49,10,2,2,0)
 
"DATA",799.49,10,2,3,0)
Microscopy (histology or cytology), culture, or 
"DATA",799.49,10,2,4,0)
detection of antigen in a specimen obtained
"DATA",799.49,10,2,5,0)
directly from the tissues affected or a fluid from
"DATA",799.49,10,2,6,0)
those tissues.
"DATA",799.49,11,0)
HISTOPLASMOSIS, DIS/EXTRAP^1:Definitive^11
"DATA",799.49,11,1)
Histoplasmosis, disseminated or extrapulmonary
"DATA",799.49,11,2,0)
^799.492^6^6^3030507^^
"DATA",799.49,11,2,1,0)
Definitive Diagnostic Method:
"DATA",799.49,11,2,2,0)
 
"DATA",799.49,11,2,3,0)
Microscopy (histology or cytology), culture, or 
"DATA",799.49,11,2,4,0)
detection of antigen in a specimen obtained
"DATA",799.49,11,2,5,0)
directly from the tissues affected or a fluid from
"DATA",799.49,11,2,6,0)
those tissues.
"DATA",799.49,12,0)
ISOSPORIASIS, CHRONIC INTEST^1:Definitive^12
"DATA",799.49,12,1)
Isosporiasis, chronic intestinal (>1mo.duration)
"DATA",799.49,12,2,0)
^799.492^2^2^3030507^^
"DATA",799.49,12,2,1,0)
Definitive Diagnostic Method: Microscopy
"DATA",799.49,12,2,2,0)
(histology or cytology).
"DATA",799.49,13,0)
KAPOSI'S SARCOMA^1:Definitive;2:Presumptive^13
"DATA",799.49,13,1)
Kaposi's sarcoma
"DATA",799.49,13,2,0)
^799.492^2^2^3030507^^
"DATA",799.49,13,2,1,0)
Definitive Diagnostic Method: Microscopy 
"DATA",799.49,13,2,2,0)
(histology or cytology).
"DATA",799.49,14,0)
LYMPHOMA, BURKITT'S^1:Definitive^14
"DATA",799.49,14,1)
Lymphoma, Burkitt's (or equivalent term)
"DATA",799.49,14,2,0)
^799.492^2^2^3030507^^
"DATA",799.49,14,2,1,0)
Definitive Diagnostic Method: Microscopy 
"DATA",799.49,14,2,2,0)
(histology or cytology).
"DATA",799.49,15,0)
LYMPHOMA, IMMUNOBLASTIC^1:Definitive^15
"DATA",799.49,15,1)
Lymphoma, immunoblastic (or equivalent term)
"DATA",799.49,15,2,0)
^799.492^2^2^3030507^^
"DATA",799.49,15,2,1,0)
Definitive Diagnostic Method: Microscopy 
"DATA",799.49,15,2,2,0)
(histology or cytology).
"DATA",799.49,16,0)
LYMPHOMA, PRIMARY IN BRAIN^1:Definitive^16
"DATA",799.49,16,1)
Lymphoma, primary in brain
"DATA",799.49,16,2,0)
^799.492^2^2^3030507^^
"DATA",799.49,16,2,1,0)
Definitive Diagnostic Method: Microscopy 
"DATA",799.49,16,2,2,0)
(histology or cytology).
"DATA",799.49,17,0)
MYCOBACTERIUM AVIUM COMPLEX^1:Definitive;2:Presumptive^17
"DATA",799.49,17,1)
Mycobacterium avium complex or M.kansasii, disseminated or extrapulmonary
"DATA",799.49,17,2,0)
^799.492^1^1^3030507^^
"DATA",799.49,17,2,1,0)
Definitive Diagnostic Method: Culture.
"DATA",799.49,18,0)
M. TUBERCULOSIS, PULMONARY^1:Definitive;2:Presumptive^18
"DATA",799.49,18,1)
M.Tuberculosis, pulmonary*
"DATA",799.49,19,0)
M TUBERCULOSIS, DIS/EXTRAP^1:Definitive;2:Presumptive^19
"DATA",799.49,19,1)
M.Tuberculosis, disseminated or extrapulmonary*
"DATA",799.49,19,2,0)
^799.492^1^1^3030507^^
"DATA",799.49,19,2,1,0)
Definitive Diagnostic Method: Culture.
"DATA",799.49,20,0)
MYCOBACTERIUM^1:Definitive;2:Presumptive^20
"DATA",799.49,20,1)
Mycobacterium, of other species or unidentified species, disseminated for extrapulmonary
"DATA",799.49,20,2,0)
^799.492^1^1^3030507^^
"DATA",799.49,20,2,1,0)
Definitive Diagnostic Method: Culture.
"DATA",799.49,21,0)
PNEUMOCYSTIS CARINII PNEUMONIA^1:Definitive;2:Presumptive^21
"DATA",799.49,21,1)
Pneumocystis carinii pneumonia
"DATA",799.49,21,2,0)
^799.492^2^2^3030507^^
"DATA",799.49,21,2,1,0)
Definitive Diagnostic Method: Microscopy 
"DATA",799.49,21,2,2,0)
(histology or cytology).
"DATA",799.49,22,0)
PNEUMONIA, RECURRENT IN 12 MO^1:Definitive;2:Presumptive^22
"DATA",799.49,22,1)
Pneumonia, recurrent, in 12mo. period
"DATA",799.49,23,0)
PROGRESSIVE MULTIFOCAL LEUKO^1:Definitive^23
"DATA",799.49,23,1)
Progressive multifocal leukoencephalopathy
"DATA",799.49,23,2,0)
^799.492^2^2^3030507^^
"DATA",799.49,23,2,1,0)
Definitive Diagnostic Method: Microscopy 
"DATA",799.49,23,2,2,0)
(histology or cytology).
"DATA",799.49,24,0)
SALMONELLA SEPTICEMIA, RECURR^1:Definitive^24
"DATA",799.49,24,1)
Salmonella septicemia, recurrent
"DATA",799.49,24,2,0)
^799.492^1^1^3030507^^
"DATA",799.49,24,2,1,0)
Definitive Diagnostic Method: Culture.
"DATA",799.49,25,0)
TOXOPLASMOSIS OF BRAIN^1:Definitive;2:Presumptive^25
"DATA",799.49,25,1)
Toxoplasmosis of brain
"DATA",799.49,25,2,0)
^799.492^2^2^3030507^^
"DATA",799.49,25,2,1,0)
Definitive Diagnostic Method: Microscopy 
"DATA",799.49,25,2,2,0)
(histology or cytology).
"DATA",799.49,26,0)
WASTING SYNDROME DUE TO HIV^1:Definitive^26
"DATA",799.49,26,1)
Wasting syndrome due to HIV
"DATA",799.49,26,2,0)
^799.492^15^15^3030507^^
"DATA",799.49,26,2,1,0)
Definitive Diagnostic Method:
"DATA",799.49,26,2,2,0)
 
"DATA",799.49,26,2,3,0)
NOTE:  The method of diagnosis described here is 
"DATA",799.49,26,2,4,0)
not truly definitive but is sufficiently rigorous
"DATA",799.49,26,2,5,0)
for surveillance purposes.
"DATA",799.49,26,2,6,0)
 
"DATA",799.49,26,2,7,0)
Findings of profound involuntary weight loss 
"DATA",799.49,26,2,8,0)
(more than 10% of baseline body weight) plus
"DATA",799.49,26,2,9,0)
either chronic diarrhea (>/2 loose stools per day
"DATA",799.49,26,2,10,0)
for >/30 days) or chronic weakness and documented
"DATA",799.49,26,2,11,0)
fever (for >/30 days, intermittent or constant) in
"DATA",799.49,26,2,12,0)
the absence of a concurrent illness or condition 
"DATA",799.49,26,2,13,0)
other than HIV infection that could explain the
"DATA",799.49,26,2,14,0)
findings (e.g., cancer, tuberculosis,
"DATA",799.49,26,2,15,0)
cryptosporidious, or other specific enteritis).
"DATA",799.51,1,0)
ABACAVIR^2^20^3535^^^^^1
"DATA",799.51,3,0)
AMPRENAVIR^2^20^3568^^^^^1
"DATA",799.51,4,0)
DELAVIRDINE^2^20^3395^^^^^1
"DATA",799.51,5,0)
DIDANOSINE^2^20^2576^^^^^1
"DATA",799.51,6,0)
EFAVIRENZ^2^20^3528^^^^^1
"DATA",799.51,7,0)
INDINAVIR^2^20^3350^^^^^1
"DATA",799.51,8,0)
LAMIVUDINE^2^20^3315^^^^^1
"DATA",799.51,9,0)
NELFINAVIR^2^20^3394^^^^^1
"DATA",799.51,10,0)
NEVIRAPINE^2^20^3377^^^^^1
"DATA",799.51,11,0)
RITONAVIR^2^20^3349^^^^^1
"DATA",799.51,12,0)
SAQUINAVIR^2^20^3316^^^^^1
"DATA",799.51,13,0)
STAVUDINE (dT4)^2^20^3225^^^^^1
"DATA",799.51,14,0)
ZALCITABINE^2^20^2270^^^^^1
"DATA",799.51,15,0)
ZIDOVUDINE^2^20^2147^^^^^1
"DATA",799.51,16,0)
LAMIVUDINE/ZIDOVUDINE^2^20^3465^^^^^1
"DATA",799.51,17,0)
LOPINAVIR/RITONAVIR^2^20^3660^^^^^1
"DATA",799.51,21,0)
TENOFOVIR^2^20^3724^^^^^1
"DATA",799.51,22,0)
ABACAVIR/LAMIVUDINE/ZIDOVUDINE^2^20^3677^^^^^1
"DATA",799.51,23,0)
ENFUVIRTIDE^2^20^3864
"DATA",799.51,24,0)
ATAZANAVIR^2^20^3890
"DATA",799.51,25,0)
EMTRICITABINE^2^20^3888
"DATA",799.51,26,0)
FOSAMPRENAVIR^2^20^3918^^^^^1
"FIA",798)
ROR LOCAL REGISTRY
"FIA",798,0)
^RORDATA(798,
"FIA",798,0,0)
798PAs
"FIA",798,0,1)
y^n^f^^^^n
"FIA",798,0,10)

"FIA",798,0,11)

"FIA",798,0,"RLRO")

"FIA",798,0,"VR")
1.0^ROR
"FIA",798,798)
0
"FIA",798,798.01)
0
"FIA",798.1)
ROR REGISTRY PARAMETERS
"FIA",798.1,0)
^ROR(798.1,
"FIA",798.1,0,0)
798.1Is
"FIA",798.1,0,1)
y^n^f^^y^^y^m^n
"FIA",798.1,0,10)

"FIA",798.1,0,11)
I $E($P($G(^ROR(798.1,Y,0)),U),1,6)="VA ICR"
"FIA",798.1,0,"RLRO")

"FIA",798.1,0,"VR")
1.0^ROR
"FIA",798.1,798.1)
0
"FIA",798.1,798.11)
0
"FIA",798.1,798.112)
0
"FIA",798.1,798.114)
0
"FIA",798.1,798.116)
0
"FIA",798.1,798.117)
0
"FIA",798.1,798.118)
0
"FIA",798.1,798.128)
0
"FIA",798.1,798.129)
0
"FIA",798.1,798.13)
0
"FIA",798.1,798.15)
0
"FIA",798.1,798.19)
0
"FIA",798.2)
ROR SELECTION RULE
"FIA",798.2,0)
^ROR(798.2,
"FIA",798.2,0,0)
798.2I
"FIA",798.2,0,1)
n^n^f^^n^^y^o^n
"FIA",798.2,0,10)

"FIA",798.2,0,11)
I $E($P($G(^ROR(798.2,Y,0)),U),1,6)="VA ICR"
"FIA",798.2,0,"RLRO")

"FIA",798.2,0,"VR")
1.0^ROR
"FIA",798.2,798.2)
0
"FIA",798.2,798.25)
0
"FIA",798.2,798.26)
0
"FIA",798.3)
ROR PENDING PATIENT
"FIA",798.3,0)
^RORDATA(798.3,
"FIA",798.3,0,0)
798.3P
"FIA",798.3,0,1)
y^n^f^^^^n^o^
"FIA",798.3,0,10)

"FIA",798.3,0,11)

"FIA",798.3,0,"RLRO")

"FIA",798.3,0,"VR")
1.0^ROR
"FIA",798.3,798.3)
0
"FIA",798.3,798.31)
0
"FIA",798.3,798.32)
0
"FIA",798.4)
ROR PATIENT
"FIA",798.4,0)
^RORDATA(798.4,
"FIA",798.4,0,0)
798.4Ps
"FIA",798.4,0,1)
y^n^f^^^^n
"FIA",798.4,0,10)

"FIA",798.4,0,11)

"FIA",798.4,0,"RLRO")

"FIA",798.4,0,"VR")
1.0^ROR
"FIA",798.4,798.4)
0
"FIA",798.5)
ROR HDT TASK
"FIA",798.5,0)
^RORDATA(798.5,
"FIA",798.5,0,0)
798.5
"FIA",798.5,0,1)
y^n^f^^^^n
"FIA",798.5,0,10)

"FIA",798.5,0,11)

"FIA",798.5,0,"RLRO")

"FIA",798.5,0,"VR")
1.0^ROR
"FIA",798.5,798.5)
0
"FIA",798.5,798.53)
0
"FIA",798.7)
ROR LOG
"FIA",798.7,0)
^RORDATA(798.7,
"FIA",798.7,0,0)
798.7Ds
"FIA",798.7,0,1)
y^n^f^^^^n
"FIA",798.7,0,10)

"FIA",798.7,0,11)

"FIA",798.7,0,"RLRO")

"FIA",798.7,0,"VR")
1.0^ROR
"FIA",798.7,798.7)
0
"FIA",798.7,798.73)
0
"FIA",798.7,798.74)
0
"FIA",798.7,798.744)
0
"FIA",798.8)
ROR TASK
"FIA",798.8,0)
^RORDATA(798.8,
"FIA",798.8,0,0)
798.8s
"FIA",798.8,0,1)
y^y^f^^^^n
"FIA",798.8,0,10)

"FIA",798.8,0,11)

"FIA",798.8,0,"RLRO")

"FIA",798.8,0,"VR")
1.0^ROR
"FIA",798.8,798.8)
0
"FIA",798.8,798.83)
0
"FIA",798.8,798.87)
0
"FIA",798.8,798.872)
0
"FIA",798.8,798.873)
0
"FIA",798.9)
ROR LAB SEARCH
"FIA",798.9,0)
^ROR(798.9,
"FIA",798.9,0,0)
798.9
"FIA",798.9,0,1)
y^n^f^^n^^y^m^n
"FIA",798.9,0,10)

"FIA",798.9,0,11)
I $E($P($G(^ROR(798.9,Y,0)),U),1,6)="VA ICR"
"FIA",798.9,0,"RLRO")

"FIA",798.9,0,"VR")
1.0^ROR
"FIA",798.9,798.9)
0
"FIA",798.9,798.92)
0
"FIA",799.1)
ROR LIST ITEM
"FIA",799.1,0)
^ROR(799.1,
"FIA",799.1,0,0)
799.1
"FIA",799.1,0,1)
y^n^f^^y^^y^o^n
"FIA",799.1,0,10)

"FIA",799.1,0,11)

"FIA",799.1,0,"RLRO")

"FIA",799.1,0,"VR")
1.0^ROR
"FIA",799.1,799.1)
0
"FIA",799.31)
ROR XML ITEM
"FIA",799.31,0)
^ROR(799.31,
"FIA",799.31,0,0)
799.31
"FIA",799.31,0,1)
y^y^f^^n^^y^o^n
"FIA",799.31,0,10)

"FIA",799.31,0,11)

"FIA",799.31,0,"RLRO")

"FIA",799.31,0,"VR")
1.0^ROR
"FIA",799.31,799.31)
0
"FIA",799.33)
ROR DATA AREA
"FIA",799.33,0)
^ROR(799.33,
"FIA",799.33,0,0)
799.33
"FIA",799.33,0,1)
y^y^f^^n^^y^o^n
"FIA",799.33,0,10)

"FIA",799.33,0,11)

"FIA",799.33,0,"RLRO")

"FIA",799.33,0,"VR")
1.0^ROR
"FIA",799.33,799.33)
0
"FIA",799.34)
ROR REPORT PARAMETERS
"FIA",799.34,0)
^ROR(799.34,
"FIA",799.34,0,0)
799.34I
"FIA",799.34,0,1)
y^y^f^^n^^y^o^n
"FIA",799.34,0,10)

"FIA",799.34,0,11)

"FIA",799.34,0,"RLRO")

"FIA",799.34,0,"VR")
1.0^ROR
"FIA",799.34,799.34)
0
"FIA",799.34,799.3411)
0
"FIA",799.34,799.3412)
0
"FIA",799.4)
ROR ICR STUDY
"FIA",799.4,0)
^RORDATA(799.4,
"FIA",799.4,0,0)
799.4Ps
"FIA",799.4,0,1)
y^y^f^^^^n
"FIA",799.4,0,10)

"FIA",799.4,0,11)

"FIA",799.4,0,"RLRO")

"FIA",799.4,0,"VR")
1.0^ROR
"FIA",799.4,799.4)
0
"FIA",799.4,799.41)
0
"FIA",799.4,799.425)
0
"FIA",799.49)
ROR AIDS INDICATOR DISEASE
"FIA",799.49,0)
^ROR(799.49,
"FIA",799.49,0,0)
799.49I
"FIA",799.49,0,1)
y^y^f^^n^^y^o^n
"FIA",799.49,0,10)

"FIA",799.49,0,11)

"FIA",799.49,0,"RLRO")

"FIA",799.49,0,"VR")
1.0^ROR
"FIA",799.49,799.49)
0
"FIA",799.49,799.492)
0
"FIA",799.51)
ROR GENERIC DRUG
"FIA",799.51,0)
^ROR(799.51,
"FIA",799.51,0,0)
799.51
"FIA",799.51,0,1)
y^y^f^^y^^y^o^n
"FIA",799.51,0,10)

"FIA",799.51,0,11)
I $$GET1^DIQ(799.51,Y,.02)="VA ICR"
"FIA",799.51,0,"RLRO")

"FIA",799.51,0,"VR")
1.0^ROR
"FIA",799.51,799.51)
0
"FRV1",798.1,"2,6,1,0",3)
Patient
"FRV1",798.1,"2,6,1,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,10,0",3)
Microbiology
"FRV1",798.1,"2,6,10,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,11,0",3)
Radiology
"FRV1",798.1,"2,6,11,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,12,0",3)
Radiology
"FRV1",798.1,"2,6,12,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,13,0",3)
Autopsy
"FRV1",798.1,"2,6,13,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,14,0",3)
Surgical Pathology
"FRV1",798.1,"2,6,14,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,15,0",3)
Surgical Pathology
"FRV1",798.1,"2,6,15,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,16,0",3)
Cytopathology
"FRV1",798.1,"2,6,16,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,17,0",3)
Cytopathology
"FRV1",798.1,"2,6,17,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,18,0",3)
EKG
"FRV1",798.1,"2,6,18,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,19,0",3)
EKG
"FRV1",798.1,"2,6,19,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,2,0",3)
Patient
"FRV1",798.1,"2,6,2,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,20,0",3)
Allergy
"FRV1",798.1,"2,6,20,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,21,0",3)
Allergy
"FRV1",798.1,"2,6,21,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,22,0",3)
IV
"FRV1",798.1,"2,6,22,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,23,0",3)
IV
"FRV1",798.1,"2,6,23,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,24,0",3)
Lab
"FRV1",798.1,"2,6,24,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,25,0",3)
Lab
"FRV1",798.1,"2,6,25,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,26,0",3)
Pharmacy
"FRV1",798.1,"2,6,26,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,27,0",3)
Pharmacy
"FRV1",798.1,"2,6,27,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,28,0",3)
Vitals
"FRV1",798.1,"2,6,28,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,29,0",3)
Vitals
"FRV1",798.1,"2,6,29,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,3,0",3)
Patient
"FRV1",798.1,"2,6,3,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,30,0",3)
Inpatient
"FRV1",798.1,"2,6,30,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,31,0",3)
Outpatient
"FRV1",798.1,"2,6,31,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,32,0",3)
Inpatient
"FRV1",798.1,"2,6,32,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,33,0",3)
Outpatient
"FRV1",798.1,"2,6,33,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,34,0",3)
Problem List
"FRV1",798.1,"2,6,34,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,35,0",3)
Problem List
"FRV1",798.1,"2,6,35,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,4,0",3)
Inpatient
"FRV1",798.1,"2,6,4,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,5,0",3)
Outpatient
"FRV1",798.1,"2,6,5,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,6,0",3)
Patient
"FRV1",798.1,"2,6,6,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,7,0",3)
Patient
"FRV1",798.1,"2,6,7,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,8,0",3)
Patient
"FRV1",798.1,"2,6,8,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,6,9,0",3)
Microbiology
"FRV1",798.1,"2,6,9,0",3,"F")
;ROR(799.33,
"FRV1",798.1,"2,9",1)
RORICR-SITE-DRIVER
"FRV1",798.1,"2,9",1,"F")
;ORD(101,
"INI")
PRE^RORP005
"INIT")
POS^RORP005
"IX",798,798,"ADELETE",0)
798^ADELETE^Deletes the data associated with the registry record^MU^^F^^I^798^^^^^A
"IX",798,798,"ADELETE",.1,0)
^^10^10^3030428^
"IX",798,798,"ADELETE",.1,1,0)
The "ADELETE" cross-reference is used to delete 
"IX",798,798,"ADELETE",.1,2,0)
the records of other files associated with the 
"IX",798,798,"ADELETE",.1,3,0)
main registry record being deleted from the ROR
"IX",798,798,"ADELETE",.1,4,0)
LOCAL REGISTRY file (#798).
"IX",798,798,"ADELETE",.1,5,0)
 
"IX",798,798,"ADELETE",.1,6,0)
The cross-reference logic calls the DEL798^RORDD01
"IX",798,798,"ADELETE",.1,7,0)
procedure, which tries to delete the corresponding
"IX",798,798,"ADELETE",.1,8,0)
records from the ROR ICR STUDY (#799.4), ROR
"IX",798,798,"ADELETE",.1,9,0)
PATIENT (#798.4) and ROR PENDING PATIENT (#798.3)
"IX",798,798,"ADELETE",.1,10,0)
files.
"IX",798,798,"ADELETE",1)
Q
"IX",798,798,"ADELETE",2)
D DEL798^RORDD01(DA,X1(1))
"IX",798,798,"ADELETE",2.4)
S X=($G(X2(1))="")
"IX",798,798,"ADELETE",11.1,0)
^.114IA^1^1
"IX",798,798,"ADELETE",11.1,1,0)
1^F^798^.01^^^F
"IX",798,798,"ADEM",0)
798^ADEM^Sets the date of last demographic update^MU^^F^^I^798^^^^^A
"IX",798,798,"ADEM",1)
D FILE^RORDD01(798,DA_",",4.1,$$NOW^XLFDT)
"IX",798,798,"ADEM",1.4)
S X=(X(1)>0)
"IX",798,798,"ADEM",2)
Q
"IX",798,798,"ADEM",11.1,0)
^.114IA^1^1
"IX",798,798,"ADEM",11.1,1,0)
1^F^798^4^^^
"IX",798,798,"ALOC",0)
798^ALOC^Sets the date of last local date modification^MU^^F^^I^798^^^^^A
"IX",798,798,"ALOC",1)
D FILE^RORDD01(798,DA_",",5.1,$$NOW^XLFDT)
"IX",798,798,"ALOC",1.4)
S X=(X(1)>0)
"IX",798,798,"ALOC",2)
Q
"IX",798,798,"ALOC",11.1,0)
^.114IA^1^1
"IX",798,798,"ALOC",11.1,1,0)
1^F^798^5^^^
"IX",798,798,"ANP",0)
798^ANP^Patients with the special status^R^^R^IR^I^798^^^^^S
"IX",798,798,"ANP",.1,0)
^^15^15^3030428^
"IX",798,798,"ANP",.1,1,0)
This cross-reference lists the registry patients 
"IX",798,798,"ANP",.1,2,0)
with the special status (the value of the NEW
"IX",798,798,"ANP",.1,3,0)
PATIENT field is greater than 0). The 
"IX",798,798,"ANP",.1,4,0)
cross-reference has the following structure:
"IX",798,798,"ANP",.1,5,0)
 
"IX",798,798,"ANP",.1,6,0)
 ^RORDATA(798,"ANP",<Registry>,<Patient>,IEN)
"IX",798,798,"ANP",.1,7,0)
 
"IX",798,798,"ANP",.1,8,0)
The <Registry> is the registry IEN (IEN of the 
"IX",798,798,"ANP",.1,9,0)
registry parameters record in the ROR REGISTRY
"IX",798,798,"ANP",.1,10,0)
PARAMETERS file) concatenated with the "#" so that
"IX",798,798,"ANP",.1,11,0)
the LIST^DIC can be used to retrieve the records
"IX",798,798,"ANP",.1,12,0)
associated with the particular registry.
"IX",798,798,"ANP",.1,13,0)
 
"IX",798,798,"ANP",.1,14,0)
The <Patient> is the IEN of the patient's record 
"IX",798,798,"ANP",.1,15,0)
in the ROR PATIENT file.
"IX",798,798,"ANP",1)
S ^RORDATA(798,"ANP",X(3),X(4),DA)=""
"IX",798,798,"ANP",1.4)
S X=(X(2)>0)
"IX",798,798,"ANP",2)
K ^RORDATA(798,"ANP",X(3),X(4),DA)
"IX",798,798,"ANP",2.5)
K ^RORDATA(798,"ANP")
"IX",798,798,"ANP",11.1,0)
^.114IA^4^4
"IX",798,798,"ANP",11.1,1,0)
1^F^798^.02^^^
"IX",798,798,"ANP",11.1,2,0)
2^F^798^3^^^
"IX",798,798,"ANP",11.1,3,0)
3^C^^^^1^F
"IX",798,798,"ANP",11.1,3,1.5)
S X=$S(X(1)'="":X(1)_"#",1:"")
"IX",798,798,"ANP",11.1,4,0)
4^F^798^.01^^2^F
"IX",798,798,"ARD",0)
798^ARD^Registry & Date Entered^R^^R^IR^I^798^^^^^S
"IX",798,798,"ARD",.1,0)
^^2^2^3030714^
"IX",798,798,"ARD",.1,1,0)
This cross-reference can be used to search for
"IX",798,798,"ARD",.1,2,0)
recently added patients.
"IX",798,798,"ARD",1)
S ^RORDATA(798,"ARD",X(2),X(3),DA)=""
"IX",798,798,"ARD",2)
K ^RORDATA(798,"ARD",X(2),X(3),DA)
"IX",798,798,"ARD",2.5)
K ^RORDATA(798,"ARD")
"IX",798,798,"ARD",11.1,0)
^.114IA^4^3
"IX",798,798,"ARD",11.1,1,0)
1^F^798^.02^^^F
"IX",798,798,"ARD",11.1,1,4)

"IX",798,798,"ARD",11.1,3,0)
3^F^798^1^^2^F
"IX",798,798,"ARD",11.1,4,0)
2^C^^^^1
"IX",798,798,"ARD",11.1,4,1.5)
S X=$S(X(1)'="":X(1)_"#",1:"")
"IX",798,798,"KEY",0)
798^KEY^Uniqueness Index for Key 'A' of File #798^R^^R^IR^I^798^^^^^LS
"IX",798,798,"KEY",.1,0)
^^3^3^3011005^
"IX",798,798,"KEY",.1,1,0)
This index guarantees uniqueness of the patient 
"IX",798,798,"KEY",.1,2,0)
record in the particular registry and allows to 
"IX",798,798,"KEY",.1,3,0)
easily find this record.
"IX",798,798,"KEY",1)
S ^RORDATA(798,"KEY",X(1),X(2),DA)=""
"IX",798,798,"KEY",2)
K ^RORDATA(798,"KEY",X(1),X(2),DA)
"IX",798,798,"KEY",2.5)
K ^RORDATA(798,"KEY")
"IX",798,798,"KEY",11.1,0)
^.114IA^2^2
"IX",798,798,"KEY",11.1,1,0)
1^F^798^.01^^1
"IX",798,798,"KEY",11.1,2,0)
2^F^798^.02^^2
"IX",798.1,798.1,"B",0)
798.1^B^Uniqueness Index for the "A" Key of the File # 798.1^R^^F^IR^I^798.1^^^^^LS
"IX",798.1,798.1,"B",1)
S ^ROR(798.1,"B",X,DA)=""
"IX",798.1,798.1,"B",2)
K ^ROR(798.1,"B",X,DA)
"IX",798.1,798.1,"B",2.5)
K ^ROR(798.1,"B")
"IX",798.1,798.1,"B",11.1,0)
^.114IA^1^1
"IX",798.1,798.1,"B",11.1,1,0)
1^F^798.1^.01^^1
"IX",798.1,798.128,"G",0)
798.128^G^Lab Group and Local Test Name^R^^R^IR^I^798.128^^^^^LS
"IX",798.1,798.128,"G",1)
S ^ROR(798.1,DA(1),28,"G",X(1),X(2),DA)=""
"IX",798.1,798.128,"G",2)
K ^ROR(798.1,DA(1),28,"G",X(1),X(2),DA)
"IX",798.1,798.128,"G",2.5)
K ^ROR(798.1,DA(1),28,"G")
"IX",798.1,798.128,"G",11.1,0)
^.114IA^3^2
"IX",798.1,798.128,"G",11.1,1,0)
1^F^798.128^.02^^1^F
"IX",798.1,798.128,"G",11.1,1,2)

"IX",798.1,798.128,"G",11.1,1,3)

"IX",798.1,798.128,"G",11.1,3,0)
2^F^798.128^.01^^2^F
"IX",798.1,798.128,"G",11.1,3,3)

"IX",798.1,798.129,"G",0)
798.129^G^Drug Group and Local Drug Name^R^^R^IR^I^798.129^^^^^LS
"IX",798.1,798.129,"G",1)
S ^ROR(798.1,DA(1),29,"G",X(1),X(2),DA)=""
"IX",798.1,798.129,"G",2)
K ^ROR(798.1,DA(1),29,"G",X(1),X(2),DA)
"IX",798.1,798.129,"G",2.5)
K ^ROR(798.1,DA(1),29,"G")
"IX",798.1,798.129,"G",11.1,0)
^.114IA^3^2
"IX",798.1,798.129,"G",11.1,1,0)
1^F^798.129^.02^^1^F
"IX",798.1,798.129,"G",11.1,1,3)

"IX",798.1,798.129,"G",11.1,3,0)
2^F^798.129^.01^^2^F
"IX",798.1,798.129,"G",11.1,3,3)

"IX",798.1,798.13,"B",0)
798.13^B^Uniqueness Index for the "A" Key of Subfile #798.13^R^^F^IR^I^798.13^^^^^LS
"IX",798.1,798.13,"B",1)
S ^ROR(798.1,DA(1),1,"B",X,DA)=""
"IX",798.1,798.13,"B",2)
K ^ROR(798.1,DA(1),1,"B",X,DA)
"IX",798.1,798.13,"B",2.5)
K ^ROR(798.1,DA(1),1,"B")
"IX",798.1,798.13,"B",11.1,0)
^.114IA^1^1
"IX",798.1,798.13,"B",11.1,1,0)
1^F^798.13^.01^^1
"IX",798.1,798.19,"KEY",0)
798.19^KEY^Uniqueness Index for the "A" Key of Subfile #798.19^R^^R^IR^I^798.19^^^^^LS
"IX",798.1,798.19,"KEY",1)
S ^ROR(798.1,DA(1),6,"KEY",X(1),X(2),DA)=""
"IX",798.1,798.19,"KEY",2)
K ^ROR(798.1,DA(1),6,"KEY",X(1),X(2),DA)
"IX",798.1,798.19,"KEY",2.5)
K ^ROR(798.1,DA(1),6,"KEY")
"IX",798.1,798.19,"KEY",11.1,0)
^.114IA^2^2
"IX",798.1,798.19,"KEY",11.1,1,0)
1^F^798.19^.02^^1
"IX",798.1,798.19,"KEY",11.1,2,0)
2^F^798.19^.01^^2
"IX",798.2,798.2,"B",0)
798.2^B^Uniqueness Index for the "A" Key of File #798.2^R^^F^IR^I^798.2^^^^^LS
"IX",798.2,798.2,"B",1)
S ^ROR(798.2,"B",X,DA)=""
"IX",798.2,798.2,"B",2)
K ^ROR(798.2,"B",X,DA)
"IX",798.2,798.2,"B",2.5)
K ^ROR(798.2,"B")
"IX",798.2,798.2,"B",11.1,0)
^.114IA^1^1
"IX",798.2,798.2,"B",11.1,1,0)
1^F^798.2^.01^^1
"IX",798.2,798.26,"B",0)
798.26^B^Uniqueness Index for the "A" Key of Subfile #798.26^R^^F^IR^I^798.26^^^^^LS
"IX",798.2,798.26,"B",1)
S ^ROR(798.2,DA(1),4,"B",X,DA)=""
"IX",798.2,798.26,"B",2)
K ^ROR(798.2,DA(1),4,"B",X,DA)
"IX",798.2,798.26,"B",2.5)
K ^ROR(798.2,DA(1),4,"B")
"IX",798.2,798.26,"B",11.1,0)
^.114IA^1^1
"IX",798.2,798.26,"B",11.1,1,0)
1^F^798.26^.01^^1
"IX",798.3,798.31,"B",0)
798.31^B^Uniqueness Index for the "A" key of Subfile #798.31^R^^F^IR^I^798.31^^^^^LS
"IX",798.3,798.31,"B",1)
S ^RORDATA(798.3,DA(1),1,"B",X,DA)=""
"IX",798.3,798.31,"B",2)
K ^RORDATA(798.3,DA(1),1,"B",X,DA)
"IX",798.3,798.31,"B",2.5)
K ^RORDATA(798.3,DA(1),1,"B")
"IX",798.3,798.31,"B",11.1,0)
^.114IA^1^1
"IX",798.3,798.31,"B",11.1,1,0)
1^F^798.31^.01^^1
"IX",798.3,798.32,"AD",0)
798.32^AD^Data Area, Date^MU^^R^IR^I^798.32^^^^^S
"IX",798.3,798.32,"AD",1)
S ^RORDATA(798.3,DA(1),2,"AD",X(1),X(2)\1,DA)=""
"IX",798.3,798.32,"AD",2)
K ^RORDATA(798.3,DA(1),2,"AD",X(1),X(2)\1,DA)
"IX",798.3,798.32,"AD",2.5)
K ^RORDATA(798.3,DA(1),2,"AD")
"IX",798.3,798.32,"AD",11.1,0)
^.114IA^2^2
"IX",798.3,798.32,"AD",11.1,1,0)
1^F^798.32^1^^1^F
"IX",798.3,798.32,"AD",11.1,2,0)
2^F^798.32^2^^2^F
"IX",798.3,798.32,"AT",0)
798.32^AT^Data Area, Timestamp^R^^R^IR^I^798.32^^^^^S
"IX",798.3,798.32,"AT",1)
S ^RORDATA(798.3,DA(1),2,"AT",X(1),X(2),DA)=""
"IX",798.3,798.32,"AT",2)
K ^RORDATA(798.3,DA(1),2,"AT",X(1),X(2),DA)
"IX",798.3,798.32,"AT",2.5)
K ^RORDATA(798.3,DA(1),2,"AT")
"IX",798.3,798.32,"AT",11.1,0)
^.114IA^2^2
"IX",798.3,798.32,"AT",11.1,1,0)
1^F^798.32^1^^1^F
"IX",798.3,798.32,"AT",11.1,2,0)
2^F^798.32^.01^^2^F
"IX",798.5,798.5,"C",0)
798.5^C^Uniqueness Index for the "A" Key of File #798.5^R^^R^IR^I^798.5^^^^^LS
"IX",798.5,798.5,"C",1)
S ^RORDATA(798.5,"C",X(1),X(2),DA)=""
"IX",798.5,798.5,"C",2)
K ^RORDATA(798.5,"C",X(1),X(2),DA)
"IX",798.5,798.5,"C",2.5)
K ^RORDATA(798.5,"C")
"IX",798.5,798.5,"C",11.1,0)
^.114IA^2^2
"IX",798.5,798.5,"C",11.1,1,0)
1^F^798.5^.02^^1
"IX",798.5,798.5,"C",11.1,2,0)
2^F^798.5^.01^^2
"IX",798.5,798.5,"DF",0)
798.5^DF^Uniqueness Index for the "B" Key of File #798.5^R^^R^IR^I^798.5^^^^^LS
"IX",798.5,798.5,"DF",1)
S ^RORDATA(798.5,"DF",X(1),X(2),DA)=""
"IX",798.5,798.5,"DF",2)
K ^RORDATA(798.5,"DF",X(1),X(2),DA)
"IX",798.5,798.5,"DF",2.5)
K ^RORDATA(798.5,"DF")
"IX",798.5,798.5,"DF",11.1,0)
^.114IA^2^2
"IX",798.5,798.5,"DF",11.1,1,0)
1^F^798.5^.02^^1
"IX",798.5,798.5,"DF",11.1,2,0)
2^F^798.5^1.01^^2
"IX",798.7,798.7,"ARD",0)
798.7^ARD^Registry & Start date^R^^R^IR^W^798.73^^^^^S
"IX",798.7,798.7,"ARD",.1,0)
^^2^2^3011011^^
"IX",798.7,798.7,"ARD",.1,1,0)
This index can be used to get a chronological list
"IX",798.7,798.7,"ARD",.1,2,0)
of logs associated with the particular registry.
"IX",798.7,798.7,"ARD",1)
S ^RORDATA(798.7,"ARD",X(1),X(2),DA(1),DA)=""
"IX",798.7,798.7,"ARD",2)
K ^RORDATA(798.7,"ARD",X(1),X(2),DA(1),DA)
"IX",798.7,798.7,"ARD",2.5)
K ^RORDATA(798.7,"ARD")
"IX",798.7,798.7,"ARD",11.1,0)
^.114IA^2^2
"IX",798.7,798.7,"ARD",11.1,1,0)
1^F^798.73^.01^^1^F
"IX",798.7,798.7,"ARD",11.1,2,0)
2^C^^^^2
"IX",798.7,798.7,"ARD",11.1,2,1.5)
S X=$P($G(^RORDATA(798.7,DA(1),0)),U)
"IX",798.8,798.87,"APSR",0)
798.87^APSR^Sort Elements^MU^^R^IR^I^798.87^^^^^S
"IX",798.8,798.87,"APSR",.1,0)
^^20^20^3030502^
"IX",798.8,798.87,"APSR",.1,1,0)
 
"IX",798.8,798.87,"APSR",.1,2,0)
 IEN  Element (int)   Parent IEN  Value
"IX",798.8,798.87,"APSR",.1,3,0)
 ---  --------------  ----------  ------------
"IX",798.8,798.87,"APSR",.1,4,0)
   1  REPORT    ( 1)          0
"IX",798.8,798.87,"APSR",.1,5,0)
   2   PATIENTS ( 3)          1
"IX",798.8,798.87,"APSR",.1,6,0)
   3    PATIENT ( 5)          2
"IX",798.8,798.87,"APSR",.1,7,0)
   4     NAME   ( 9)          3   "DOU, JOHN"
"IX",798.8,798.87,"APSR",.1,8,0)
   5     DOB    (10)          3   "1950/03/25"
"IX",798.8,798.87,"APSR",.1,9,0)
   6    PATIENT ( 5)          2
"IX",798.8,798.87,"APSR",.1,10,0)
   7     NAME   ( 9)          6   "SMITH, BOB"
"IX",798.8,798.87,"APSR",.1,11,0)
   8     DOB    (10)          6   "1935/10/05"
"IX",798.8,798.87,"APSR",.1,12,0)
 
"IX",798.8,798.87,"APSR",.1,13,0)
 
"IX",798.8,798.87,"APSR",.1,14,0)
        Parent  Element
"IX",798.8,798.87,"APSR",.1,15,0)
         IEN     (int)   IEN
"IX",798.8,798.87,"APSR",.1,16,0)
        ------  -------  ---
"IX",798.8,798.87,"APSR",.1,17,0)
 "APSR",  3,       9,     4
"IX",798.8,798.87,"APSR",.1,18,0)
 "APSR",  3,      10,     5
"IX",798.8,798.87,"APSR",.1,19,0)
 "APSR",  6,       9,     7
"IX",798.8,798.87,"APSR",.1,20,0)
 "APSR",  6,      10,     8
"IX",798.8,798.87,"APSR",1)
S ^RORDATA(798.8,DA(1),"RI","APSR",X(1),X(2),DA)=""
"IX",798.8,798.87,"APSR",1.4)
S X=(X(3)>0)
"IX",798.8,798.87,"APSR",2)
K ^RORDATA(798.8,DA(1),"RI","APSR",X(1),X(2),DA)
"IX",798.8,798.87,"APSR",2.4)

"IX",798.8,798.87,"APSR",2.5)
K ^RORDATA(798.8,DA(1),"RI","APSR")
"IX",798.8,798.87,"APSR",11.1,0)
^.114IA^4^3
"IX",798.8,798.87,"APSR",11.1,1,0)
1^F^798.87^.02^^1^F
"IX",798.8,798.87,"APSR",11.1,2,0)
2^F^798.87^.01^^2^F
"IX",798.8,798.87,"APSR",11.1,4,0)
3^F^798.87^.03^^^F
"IX",798.8,798.87,"APSV0",0)
798.87^APSV0^Preserves the sequence of the report elements^MU^^F^IR^I^798.87^^^^^S
"IX",798.8,798.87,"APSV0",.1,0)
^^10^10^3030502^
"IX",798.8,798.87,"APSV0",.1,1,0)
The APSV0 index allows to render the report
"IX",798.8,798.87,"APSV0",.1,2,0)
elements into the XML tags in the same sequence as
"IX",798.8,798.87,"APSV0",.1,3,0)
those elements were created by the report builder.
"IX",798.8,798.87,"APSV0",.1,4,0)
 
"IX",798.8,798.87,"APSV0",.1,5,0)
The APSV0 and APSV1 indexes work together and the
"IX",798.8,798.87,"APSV0",.1,6,0)
entries of both indexes are created under the same
"IX",798.8,798.87,"APSV0",.1,7,0)
"APSV" subscript.
"IX",798.8,798.87,"APSV0",.1,8,0)
 
"IX",798.8,798.87,"APSV0",.1,9,0)
See the description of the APSV1 index for more 
"IX",798.8,798.87,"APSV0",.1,10,0)
details.
"IX",798.8,798.87,"APSV0",1)
S ^RORDATA(798.8,DA(1),"RI","APSV",+X(1),0," ",DA)=""
"IX",798.8,798.87,"APSV0",2)
K ^RORDATA(798.8,DA(1),"RI","APSV",+X(1),0," ",DA)
"IX",798.8,798.87,"APSV0",2.5)

"IX",798.8,798.87,"APSV0",11.1,0)
^.114IA^1^1
"IX",798.8,798.87,"APSV0",11.1,1,0)
1^F^798.87^.02^^^F
"IX",798.8,798.87,"APSV1",0)
798.87^APSV1^Sorts the XML report on the server^MU^^R^IR^I^798.87^^^^^S
"IX",798.8,798.87,"APSV1",.1,0)
^^162^162^3030505^
"IX",798.8,798.87,"APSV1",.1,1,0)
The APSV1 index allows to sort the XML reports on 
"IX",798.8,798.87,"APSV1",.1,2,0)
the server side. 
"IX",798.8,798.87,"APSV1",.1,3,0)
 
"IX",798.8,798.87,"APSV1",.1,4,0)
The APSV0 and APSV1 indexes work together and the
"IX",798.8,798.87,"APSV1",.1,5,0)
entries of both indexes are created under the same
"IX",798.8,798.87,"APSV1",.1,6,0)
"APSV" subscript.
"IX",798.8,798.87,"APSV1",.1,7,0)
 
"IX",798.8,798.87,"APSV1",.1,8,0)
The resulting index actually consists of several 
"IX",798.8,798.87,"APSV1",.1,9,0)
sub-indexes (lists). Each index sorts the items
"IX",798.8,798.87,"APSV1",.1,10,0)
that comprise different parts of the XML document.
"IX",798.8,798.87,"APSV1",.1,11,0)
 
"IX",798.8,798.87,"APSV1",.1,12,0)
The index has the following structure:
"IX",798.8,798.87,"APSV1",.1,13,0)
 
"IX",798.8,798.87,"APSV1",.1,14,0)
 ^RORDATA(798.8,Task,"RI",
"IX",798.8,798.87,"APSV1",.1,15,0)
    "APSV",List,Sort,ItemValue,ItemIEN) = ""
"IX",798.8,798.87,"APSV1",.1,16,0)
 
"IX",798.8,798.87,"APSV1",.1,17,0)
'Task' is the IEN of the main task record (it is
"IX",798.8,798.87,"APSV1",.1,18,0)
equal to the task number).
"IX",798.8,798.87,"APSV1",.1,19,0)
 
"IX",798.8,798.87,"APSV1",.1,20,0)
'List' is the IEN of the list.
"IX",798.8,798.87,"APSV1",.1,21,0)
 
"IX",798.8,798.87,"APSV1",.1,22,0)
'Sort' is the sorting mode. It is the internal 
"IX",798.8,798.87,"APSV1",.1,23,0)
value of the REPORT ELEMENT field (the IEN of the
"IX",798.8,798.87,"APSV1",.1,24,0)
XML element in the ROR XML ELEMENT file). Each
"IX",798.8,798.87,"APSV1",.1,25,0)
list can be sorted in different ways. The APSV0
"IX",798.8,798.87,"APSV1",.1,26,0)
index always uses 0 as the value of this
"IX",798.8,798.87,"APSV1",.1,27,0)
subscript.
"IX",798.8,798.87,"APSV1",.1,28,0)
 
"IX",798.8,798.87,"APSV1",.1,29,0)
'ItemValue' is the value of the list item. The
"IX",798.8,798.87,"APSV1",.1,30,0)
APSV0 index always uses " " as the value of this
"IX",798.8,798.87,"APSV1",.1,31,0)
subscript.
"IX",798.8,798.87,"APSV1",.1,32,0)
 
"IX",798.8,798.87,"APSV1",.1,33,0)
'ItemIEN' is the IEN of the list item.
"IX",798.8,798.87,"APSV1",.1,34,0)
 
"IX",798.8,798.87,"APSV1",.1,35,0)
To clarify, below is an example of some sample 
"IX",798.8,798.87,"APSV1",.1,36,0)
content of the REPORT ELEMENT multiple:
"IX",798.8,798.87,"APSV1",.1,37,0)
 
"IX",798.8,798.87,"APSV1",.1,38,0)
 IEN  Element (int)   Parent IEN  Value
"IX",798.8,798.87,"APSV1",.1,39,0)
 ---  --------------  ----------  ------------
"IX",798.8,798.87,"APSV1",.1,40,0)
   1  REPORT    ( 1)         0
"IX",798.8,798.87,"APSV1",.1,41,0)
   2   PATIENTS ( 3)         1
"IX",798.8,798.87,"APSV1",.1,42,0)
   3    PATIENT ( 5)         2
"IX",798.8,798.87,"APSV1",.1,43,0)
   4     NAME   ( 9)         3    "DOU, JOHN"
"IX",798.8,798.87,"APSV1",.1,44,0)
   5     DOB    (10)         3    "1950/03/25"
"IX",798.8,798.87,"APSV1",.1,45,0)
   6    PATIENT ( 5)         2   
"IX",798.8,798.87,"APSV1",.1,46,0)
   7     NAME   ( 9)         6    "SMITH, BOB"
"IX",798.8,798.87,"APSV1",.1,47,0)
   8     DOB    (10)         6    "1935/10/05"
"IX",798.8,798.87,"APSV1",.1,48,0)
 
"IX",798.8,798.87,"APSV1",.1,49,0)
      Table 1. Sample Report Elements
"IX",798.8,798.87,"APSV1",.1,50,0)
 
"IX",798.8,798.87,"APSV1",.1,51,0)
The element names are indented to emphasize the 
"IX",798.8,798.87,"APSV1",.1,52,0)
hierarchical structure of the document.
"IX",798.8,798.87,"APSV1",.1,53,0)
 
"IX",798.8,798.87,"APSV1",.1,54,0)
The numbers in parentheses after the element names
"IX",798.8,798.87,"APSV1",.1,55,0)
represent the internal values of the REPORT 
"IX",798.8,798.87,"APSV1",.1,56,0)
ELEMENT field (the IEN's in the ROR XML ELEMENT
"IX",798.8,798.87,"APSV1",.1,57,0)
file).
"IX",798.8,798.87,"APSV1",.1,58,0)
 
"IX",798.8,798.87,"APSV1",.1,59,0)
Several lists can be isolated from this example:
"IX",798.8,798.87,"APSV1",.1,60,0)
 
"IX",798.8,798.87,"APSV1",.1,61,0)
  #   List      Items
"IX",798.8,798.87,"APSV1",.1,62,0)
 ---  -------   -------------------------------
"IX",798.8,798.87,"APSV1",.1,63,0)
  1   REPORT    PATIENTS
"IX",798.8,798.87,"APSV1",.1,64,0)
  2   PATIENTS  PATIENT, PATIENT
"IX",798.8,798.87,"APSV1",.1,65,0)
  3   PATIENT   NAME, DOB
"IX",798.8,798.87,"APSV1",.1,66,0)
  4   PATIENT   NAME, DOB
"IX",798.8,798.87,"APSV1",.1,67,0)
 
"IX",798.8,798.87,"APSV1",.1,68,0)
  5   PATIENTS  "DOU, JOHN", "SMITH, BOB"
"IX",798.8,798.87,"APSV1",.1,69,0)
  6   PATIENTS  "1935/10/05", "1950/03/25"
"IX",798.8,798.87,"APSV1",.1,70,0)
 
"IX",798.8,798.87,"APSV1",.1,71,0)
      Table 2. The Lists
"IX",798.8,798.87,"APSV1",.1,72,0)
 
"IX",798.8,798.87,"APSV1",.1,73,0)
The first four lists contain just the report
"IX",798.8,798.87,"APSV1",.1,74,0)
elements themselves. They are used to render the
"IX",798.8,798.87,"APSV1",.1,75,0)
elements into the XML tags in the same sequence as
"IX",798.8,798.87,"APSV1",.1,76,0)
the elements were created by the report builder.
"IX",798.8,798.87,"APSV1",.1,77,0)
For example, the <DOB> tag will always follow the
"IX",798.8,798.87,"APSV1",.1,78,0)
<NAME> tag.
"IX",798.8,798.87,"APSV1",.1,79,0)
 
"IX",798.8,798.87,"APSV1",.1,80,0)
The logic of the APSV0 index handles these
"IX",798.8,798.87,"APSV1",.1,81,0)
sub-indexes. They always have 0 as the sorting
"IX",798.8,798.87,"APSV1",.1,82,0)
mode and " " as the item value.
"IX",798.8,798.87,"APSV1",.1,83,0)
 
"IX",798.8,798.87,"APSV1",.1,84,0)
The last two sub-indexes are handled by the logic
"IX",798.8,798.87,"APSV1",.1,85,0)
of the "APSV1" index. As illustrated in the
"IX",798.8,798.87,"APSV1",.1,86,0)
example, the lists are associated with the
"IX",798.8,798.87,"APSV1",.1,87,0)
PATIENTS element, they are comprised from the
"IX",798.8,798.87,"APSV1",.1,88,0)
PATIENT elements, and are sorted by the values of
"IX",798.8,798.87,"APSV1",.1,89,0)
the NAME and DOB elements. Three levels of the
"IX",798.8,798.87,"APSV1",.1,90,0)
hierarchy are covered by each of these
"IX",798.8,798.87,"APSV1",.1,91,0)
sub-indexes.
"IX",798.8,798.87,"APSV1",.1,92,0)
 
"IX",798.8,798.87,"APSV1",.1,93,0)
Let us look at the corresponding index. The 
"IX",798.8,798.87,"APSV1",.1,94,0)
numbers in the first column indicate the 
"IX",798.8,798.87,"APSV1",.1,95,0)
corresponding lists from Table 2. The sub-indexes
"IX",798.8,798.87,"APSV1",.1,96,0)
are separated by empty lines:
"IX",798.8,798.87,"APSV1",.1,97,0)
 
"IX",798.8,798.87,"APSV1",.1,98,0)
  #         List  Sort   ItemValue     ItemIEN
"IX",798.8,798.87,"APSV1",.1,99,0)
 ---        ----  ----  -------------  -------
"IX",798.8,798.87,"APSV1",.1,100,0)
  1  "APSV",  1,    0,  " ",              2)
"IX",798.8,798.87,"APSV1",.1,101,0)
 
"IX",798.8,798.87,"APSV1",.1,102,0)
  2  "APSV",  2,    0,  " ",              3)
"IX",798.8,798.87,"APSV1",.1,103,0)
  2  "APSV",  2,    0,  " ",              6)
"IX",798.8,798.87,"APSV1",.1,104,0)
 
"IX",798.8,798.87,"APSV1",.1,105,0)
  5  "APSV",  2,    9,  "DOU, JOHN",      3)
"IX",798.8,798.87,"APSV1",.1,106,0)
  5  "APSV",  2,    9,  "SMITH, BOB",     6)
"IX",798.8,798.87,"APSV1",.1,107,0)
 
"IX",798.8,798.87,"APSV1",.1,108,0)
  6  "APSV",  2,   10,  "1935/10/05",     6)
"IX",798.8,798.87,"APSV1",.1,109,0)
  6  "APSV",  2,   10,  "1950/03/25",     3)
"IX",798.8,798.87,"APSV1",.1,110,0)
 
"IX",798.8,798.87,"APSV1",.1,111,0)
  3  "APSV",  3,    0,  " ",              4)
"IX",798.8,798.87,"APSV1",.1,112,0)
  3  "APSV",  3,    0,  " ",              5)
"IX",798.8,798.87,"APSV1",.1,113,0)
 
"IX",798.8,798.87,"APSV1",.1,114,0)
  4  "APSV",  6,    0,  " ",              7)
"IX",798.8,798.87,"APSV1",.1,115,0)
  4  "APSV",  6,    0,  " ",              8)
"IX",798.8,798.87,"APSV1",.1,116,0)
 
"IX",798.8,798.87,"APSV1",.1,117,0)
Let us look more closely at the first entry of the
"IX",798.8,798.87,"APSV1",.1,118,0)
sub-index #5 (also see Table 1):
"IX",798.8,798.87,"APSV1",.1,119,0)
 
"IX",798.8,798.87,"APSV1",.1,120,0)
 2  is the IEN of the REPORTS element in the
"IX",798.8,798.87,"APSV1",.1,121,0)
    REPORT ELEMENT multiple;
"IX",798.8,798.87,"APSV1",.1,122,0)
 
"IX",798.8,798.87,"APSV1",.1,123,0)
 9  is the sorting mode (the IEN of the NAME
"IX",798.8,798.87,"APSV1",.1,124,0)
    element in the ROR XML ELEMENT file);
"IX",798.8,798.87,"APSV1",.1,125,0)
 
"IX",798.8,798.87,"APSV1",.1,126,0)
 "DOU, JOHN"
"IX",798.8,798.87,"APSV1",.1,127,0)
    is the value of the NAME element;
"IX",798.8,798.87,"APSV1",.1,128,0)
 
"IX",798.8,798.87,"APSV1",.1,129,0)
 3  is the IEN of the corresponding PATIENT
"IX",798.8,798.87,"APSV1",.1,130,0)
    element in the REPORT ELEMENT multiple.
"IX",798.8,798.87,"APSV1",.1,131,0)
 
"IX",798.8,798.87,"APSV1",.1,132,0)
If the sort mode 9 (NAME) is used then the
"IX",798.8,798.87,"APSV1",.1,133,0)
resulting XML document will look like this:
"IX",798.8,798.87,"APSV1",.1,134,0)
 
"IX",798.8,798.87,"APSV1",.1,135,0)
 <REPORT>
"IX",798.8,798.87,"APSV1",.1,136,0)
  <PATIENTS>
"IX",798.8,798.87,"APSV1",.1,137,0)
   <PATIENT>
"IX",798.8,798.87,"APSV1",.1,138,0)
    <NAME>DOU, JOHN"</NAME>
"IX",798.8,798.87,"APSV1",.1,139,0)
    <DOB>950/03/25</DOB>
"IX",798.8,798.87,"APSV1",.1,140,0)
   </PATIENT>
"IX",798.8,798.87,"APSV1",.1,141,0)
   <PATIENT>
"IX",798.8,798.87,"APSV1",.1,142,0)
    <NAME>SMITH, BOB</NAME>
"IX",798.8,798.87,"APSV1",.1,143,0)
    <DOB>1935/10/05</DOB>
"IX",798.8,798.87,"APSV1",.1,144,0)
   </PATIENT>
"IX",798.8,798.87,"APSV1",.1,145,0)
  </PATIENTS>
"IX",798.8,798.87,"APSV1",.1,146,0)
 </REPORT>
"IX",798.8,798.87,"APSV1",.1,147,0)
 
"IX",798.8,798.87,"APSV1",.1,148,0)
If the sort mode 10 (DOB) is used, the resulting
"IX",798.8,798.87,"APSV1",.1,149,0)
XML document will look as follow:
"IX",798.8,798.87,"APSV1",.1,150,0)
 
"IX",798.8,798.87,"APSV1",.1,151,0)
 <REPORT>
"IX",798.8,798.87,"APSV1",.1,152,0)
  <PATIENTS>
"IX",798.8,798.87,"APSV1",.1,153,0)
   <PATIENT>
"IX",798.8,798.87,"APSV1",.1,154,0)
    <NAME>SMITH, BOB</NAME>
"IX",798.8,798.87,"APSV1",.1,155,0)
    <DOB>1935/10/05</DOB>
"IX",798.8,798.87,"APSV1",.1,156,0)
   </PATIENT>
"IX",798.8,798.87,"APSV1",.1,157,0)
   <PATIENT>
"IX",798.8,798.87,"APSV1",.1,158,0)
    <NAME>DOU, JOHN"</NAME>
"IX",798.8,798.87,"APSV1",.1,159,0)
    <DOB>950/03/25</DOB>
"IX",798.8,798.87,"APSV1",.1,160,0)
   </PATIENT>
"IX",798.8,798.87,"APSV1",.1,161,0)
  </PATIENTS>
"IX",798.8,798.87,"APSV1",.1,162,0)
 </REPORT>
"IX",798.8,798.87,"APSV1",1)
S ^RORDATA(798.8,DA(1),"RI","APSV",X(2),X(3),X(6),X(1))=""
"IX",798.8,798.87,"APSV1",1.4)
S X=(X(5)>0)
"IX",798.8,798.87,"APSV1",2)
K ^RORDATA(798.8,DA(1),"RI","APSV",X(2),X(3),X(6),X(1))
"IX",798.8,798.87,"APSV1",2.5)

"IX",798.8,798.87,"APSV1",11.1,0)
^.114IA^10^6
"IX",798.8,798.87,"APSV1",11.1,1,0)
1^F^798.87^.02^^4^F
"IX",798.8,798.87,"APSV1",11.1,2,0)
2^C^^^^1
"IX",798.8,798.87,"APSV1",11.1,2,1.5)
S X=$S(X(1)>0:$P($G(^RORDATA(798.8,DA(1),"RI",X(1),0)),U,2),1:"")
"IX",798.8,798.87,"APSV1",11.1,6,0)
6^C^^^30^3
"IX",798.8,798.87,"APSV1",11.1,6,1.5)
S X=$$SORTBY^RORDD01(X(5),X(4))
"IX",798.8,798.87,"APSV1",11.1,8,0)
3^F^798.87^.01^^2^F
"IX",798.8,798.87,"APSV1",11.1,9,0)
4^F^798.87^1^30^^F
"IX",798.8,798.87,"APSV1",11.1,10,0)
5^F^798.87^.03^^^
"IX",798.8,798.87,"APSV1",11.1,10,3)

"IX",798.9,798.9,"B",0)
798.9^B^Uniqueness Index for the "A" Key of File #798.9^R^^F^IR^I^798.9^^^^^LS
"IX",798.9,798.9,"B",1)
S ^ROR(798.9,"B",X,DA)=""
"IX",798.9,798.9,"B",2)
K ^ROR(798.9,"B",X,DA)
"IX",798.9,798.9,"B",2.5)
K ^ROR(798.9,"B")
"IX",798.9,798.9,"B",11.1,0)
^.114IA^1^1
"IX",798.9,798.9,"B",11.1,1,0)
1^F^798.9^.01^^1
"IX",799.1,799.1,"KEY",0)
799.1^KEY^Uniqueness Index for the "A" Key of File #799.1^R^^R^IR^I^799.1^^^^^LS
"IX",799.1,799.1,"KEY",1)
S ^ROR(799.1,"KEY",X(1),X(2),X(3),DA)=""
"IX",799.1,799.1,"KEY",2)
K ^ROR(799.1,"KEY",X(1),X(2),X(3),DA)
"IX",799.1,799.1,"KEY",2.5)
K ^ROR(799.1,"KEY")
"IX",799.1,799.1,"KEY",11.1,0)
^.114IA^3^3
"IX",799.1,799.1,"KEY",11.1,1,0)
1^F^799.1^.02^^1
"IX",799.1,799.1,"KEY",11.1,2,0)
2^F^799.1^.03^^2
"IX",799.1,799.1,"KEY",11.1,3,0)
3^F^799.1^.04^^3
"IX",799.34,799.34,"KEY",0)
799.34^KEY^Uniqueness Index for Key 'A' of File #799.34^R^^F^IR^I^799.34^^^^^LS
"IX",799.34,799.34,"KEY",1)
S ^ROR(799.34,"KEY",X,DA)=""
"IX",799.34,799.34,"KEY",2)
K ^ROR(799.34,"KEY",X,DA)
"IX",799.34,799.34,"KEY",2.5)
K ^ROR(799.34,"KEY")
"IX",799.34,799.34,"KEY",11.1,0)
^.114IA^1^1
"IX",799.34,799.34,"KEY",11.1,1,0)
1^F^799.34^.04^^1
"IX",799.4,799.41,"AD",0)
799.41^AD^Date of diagnosis^R^^R^IR^I^799.41^^^^^S
"IX",799.4,799.41,"AD",.1,0)
^^2^2^3030507^
"IX",799.4,799.41,"AD",.1,1,0)
This index sorts the AIDS indicator diseases by
"IX",799.4,799.41,"AD",.1,2,0)
the dates when they were diagnosed.
"IX",799.4,799.41,"AD",1)
S ^RORDATA(799.4,DA(1),10,"AD",X(2),DA)=""
"IX",799.4,799.41,"AD",1.4)
S X=(X(1)'="")
"IX",799.4,799.41,"AD",2)
K ^RORDATA(799.4,DA(1),10,"AD",X(2),DA)
"IX",799.4,799.41,"AD",2.5)
K ^RORDATA(799.4,DA(1),10,"AD")
"IX",799.4,799.41,"AD",11.1,0)
^.114IA^2^2
"IX",799.4,799.41,"AD",11.1,1,0)
1^F^799.41^.02^^^F
"IX",799.4,799.41,"AD",11.1,2,0)
2^F^799.41^.03^^1^F
"IX",799.51,799.51,"ARDG",0)
799.51^ARDG^Registry & Drug Group^R^^R^IR^I^799.51^^^^^S
"IX",799.51,799.51,"ARDG",1)
S ^ROR(799.51,"ARDG",X(2),X(3),DA)=""
"IX",799.51,799.51,"ARDG",2)
K ^ROR(799.51,"ARDG",X(2),X(3),DA)
"IX",799.51,799.51,"ARDG",2.5)
K ^ROR(799.51,"ARDG")
"IX",799.51,799.51,"ARDG",11.1,0)
^.114IA^3^3
"IX",799.51,799.51,"ARDG",11.1,1,0)
1^F^799.51^.02^^^F
"IX",799.51,799.51,"ARDG",11.1,2,0)
3^F^799.51^.04^^2^F
"IX",799.51,799.51,"ARDG",11.1,3,0)
2^C^^^^1
"IX",799.51,799.51,"ARDG",11.1,3,1.5)
S X=$S(X(1)'="":X(1)_"#",1:"")
"IX",799.51,799.51,"KEY",0)
799.51^KEY^Registry, Drug Group, Generic Drug^R^^R^IR^I^799.51^^^^^LS
"IX",799.51,799.51,"KEY",1)
S ^ROR(799.51,"KEY",X(1),X(2),X(3),DA)=""
"IX",799.51,799.51,"KEY",2)
K ^ROR(799.51,"KEY",X(1),X(2),X(3),DA)
"IX",799.51,799.51,"KEY",2.5)
K ^ROR(799.51,"KEY")
"IX",799.51,799.51,"KEY",11.1,0)
^.114IA^3^3
"IX",799.51,799.51,"KEY",11.1,1,0)
1^F^799.51^.02^^1
"IX",799.51,799.51,"KEY",11.1,2,0)
2^F^799.51^.03^^2
"IX",799.51,799.51,"KEY",11.1,3,0)
3^F^799.51^.04^^3
"KEY",798,798,"A",0)
798^A^P^100
"KEY",798,798,"A",2,0)
^.312IA^2^2
"KEY",798,798,"A",2,1,0)
.01^798^1
"KEY",798,798,"A",2,2,0)
.02^798^2
"KEY",798.1,798.1,"A",0)
798.1^A^P^101
"KEY",798.1,798.1,"A",2,0)
^.312IA^1^1
"KEY",798.1,798.1,"A",2,1,0)
.01^798.1^1
"KEY",798.1,798.128,"G",0)
798.128^G^P^247
"KEY",798.1,798.128,"G",2,0)
^.312IA^2^2
"KEY",798.1,798.128,"G",2,1,0)
.02^798.128^1
"KEY",798.1,798.128,"G",2,2,0)
.01^798.128^2
"KEY",798.1,798.129,"G",0)
798.129^G^P^258
"KEY",798.1,798.129,"G",2,0)
^.312IA^2^2
"KEY",798.1,798.129,"G",2,1,0)
.02^798.129^1
"KEY",798.1,798.129,"G",2,2,0)
.01^798.129^2
"KEY",798.1,798.13,"A",0)
798.13^A^P^102
"KEY",798.1,798.13,"A",2,0)
^.312IA^1^1
"KEY",798.1,798.13,"A",2,1,0)
.01^798.13^1
"KEY",798.1,798.19,"A",0)
798.19^A^P^113
"KEY",798.1,798.19,"A",2,0)
^.312IA^2^2
"KEY",798.1,798.19,"A",2,1,0)
.02^798.19^1
"KEY",798.1,798.19,"A",2,2,0)
.01^798.19^2
"KEY",798.2,798.2,"A",0)
798.2^A^P^103
"KEY",798.2,798.2,"A",2,0)
^.312IA^1^1
"KEY",798.2,798.2,"A",2,1,0)
.01^798.2^1
"KEY",798.2,798.26,"A",0)
798.26^A^P^104
"KEY",798.2,798.26,"A",2,0)
^.312IA^1^1
"KEY",798.2,798.26,"A",2,1,0)
.01^798.26^1
"KEY",798.3,798.31,"A",0)
798.31^A^P^162
"KEY",798.3,798.31,"A",2,0)
^.312IA^1^1
"KEY",798.3,798.31,"A",2,1,0)
.01^798.31^1
"KEY",798.5,798.5,"A",0)
798.5^A^P^144
"KEY",798.5,798.5,"A",2,0)
^.312IA^2^2
"KEY",798.5,798.5,"A",2,1,0)
.02^798.5^1
"KEY",798.5,798.5,"A",2,2,0)
.01^798.5^2
"KEY",798.5,798.5,"B",0)
798.5^B^S^145
"KEY",798.5,798.5,"B",2,0)
^.312IA^2^2
"KEY",798.5,798.5,"B",2,1,0)
.02^798.5^1
"KEY",798.5,798.5,"B",2,2,0)
1.01^798.5^2
"KEY",798.9,798.9,"A",0)
798.9^A^P^117
"KEY",798.9,798.9,"A",2,0)
^.312IA^1^1
"KEY",798.9,798.9,"A",2,1,0)
.01^798.9^1
"KEY",799.1,799.1,"A",0)
799.1^A^P^143
"KEY",799.1,799.1,"A",2,0)
^.312IA^3^3
"KEY",799.1,799.1,"A",2,1,0)
.02^799.1^1
"KEY",799.1,799.1,"A",2,2,0)
.03^799.1^2
"KEY",799.1,799.1,"A",2,3,0)
.04^799.1^3
"KEY",799.34,799.34,"A",0)
799.34^A^P^301
"KEY",799.34,799.34,"A",2,0)
^.312IA^1^1
"KEY",799.34,799.34,"A",2,1,0)
.04^799.34^1
"KEY",799.51,799.51,"A",0)
799.51^A^P^294
"KEY",799.51,799.51,"A",2,0)
^.312IA^3^3
"KEY",799.51,799.51,"A",2,1,0)
.02^799.51^1
"KEY",799.51,799.51,"A",2,2,0)
.03^799.51^2
"KEY",799.51,799.51,"A",2,3,0)
.04^799.51^3
"KEYPTR",798,798,"A")
798^KEY
"KEYPTR",798.1,798.1,"A")
798.1^B
"KEYPTR",798.1,798.128,"G")
798.128^G
"KEYPTR",798.1,798.129,"G")
798.129^G
"KEYPTR",798.1,798.13,"A")
798.13^B
"KEYPTR",798.1,798.19,"A")
798.19^KEY
"KEYPTR",798.2,798.2,"A")
798.2^B
"KEYPTR",798.2,798.26,"A")
798.26^B
"KEYPTR",798.3,798.31,"A")
798.31^B
"KEYPTR",798.5,798.5,"A")
798.5^C
"KEYPTR",798.5,798.5,"B")
798.5^DF
"KEYPTR",798.9,798.9,"A")
798.9^B
"KEYPTR",799.1,799.1,"A")
799.1^KEY
"KEYPTR",799.34,799.34,"A")
799.34^KEY
"KEYPTR",799.51,799.51,"A")
799.51^KEY
"KRN",.402,2099,-1)
0^2
"KRN",.402,2099,0)
RORMNT EDIT REG PARAMS^3030424.1422^^798.1^^@^3040211
"KRN",.402,2099,"%D",0)
^.4021^2^2^3030424^^^
"KRN",.402,2099,"%D",1,0)
This template is used by the [RORMNT EDIT REG PARAMS] menu option to
"KRN",.402,2099,"%D",2,0)
review/edit the registry parameters.
"KRN",.402,2099,"DIAB",1,1,798.11,0)
ALL
"KRN",.402,2099,"DIAB",1,1,798.114,0)
ALL
"KRN",.402,2099,"DR",1,798.1)
1;2;7;8;8.1;11;14;15.1;15.9;13.2;25;13.1;
"KRN",.402,2099,"DR",2,798.11)
.01
"KRN",.402,2099,"DR",2,798.114)
.01
"KRN",.402,2146,-1)
1^1
"KRN",.402,2146,0)
RORMNT AWAITING ACK    FILE #798.1
"KRN",.5,221,-1)
0^1
"KRN",.5,221,0)
RORPTSTATUS
"KRN",.5,221,1)
S X=$S(X>0:+$P($G(^RORDATA(798,+X,0)),U),1:0),X=$S(X'>0:9,$P($G(^RORDATA(798.4,X,1)),U,4)>0:2,1:1)
"KRN",.5,221,3)
1
"KRN",.5,221,9)
Returns patient's status (1-Alive, 2-Dead, 9-Unknown)
"KRN",.84,7980000.003,-1)
0^1
"KRN",.84,7980000.003,0)
7980000.003^1^^CLINICAL CASE REGISTRIES^Access Violation Message
"KRN",.84,7980000.003,2,0)
^.844^2^2^3030708^^^
"KRN",.84,7980000.003,2,1,0)
YOU ARE NOT ALLOWED TO ACCESS THE CLINICAL CASE REGISTRIES FILES!
"KRN",.84,7980000.003,2,2,0)
SEE YOUR REGISTRY COORDINATOR FOR THE PROPER SECURITY KEYS.
"KRN",.84,7980000.003,5,0)
^.841^1^1
"KRN",.84,7980000.003,5,1,0)
RORDD^ACCESS
"KRN",.84,7980000.003,5,"B","RORDD",1)

"KRN",.84,7980000.004,-1)
0^5
"KRN",.84,7980000.004,0)
7980000.004^2^y^CLINICAL CASE REGISTRIES^Status of the HL7 Message
"KRN",.84,7980000.004,2,0)
^.844^9^9^3030929^^^
"KRN",.84,7980000.004,2,1,0)
  Message ID....... |ID|
"KRN",.84,7980000.004,2,2,0)
  Message status... |STATUS|
"KRN",.84,7980000.004,2,3,0)
  Status updated... |UPDATED|
"KRN",.84,7980000.004,2,4,0)
  Error message.... |ERRMSG|
"KRN",.84,7980000.004,2,5,0)
  Error type....... |ERRTYPE|
"KRN",.84,7980000.004,2,6,0)
  # of retries..... |RETRIES|
"KRN",.84,7980000.004,2,7,0)
  Queue position... |QPOS|
"KRN",.84,7980000.004,2,8,0)
  # Open failed.... |OPENFAIL|
"KRN",.84,7980000.004,2,9,0)
  ACK timeout...... |ACK|
"KRN",.84,7980000.004,3,0)
^.845^9^9
"KRN",.84,7980000.004,3,1,0)
ID
"KRN",.84,7980000.004,3,2,0)
STATUS
"KRN",.84,7980000.004,3,3,0)
UPDATED
"KRN",.84,7980000.004,3,4,0)
ERRMSG
"KRN",.84,7980000.004,3,5,0)
RETRIES
"KRN",.84,7980000.004,3,6,0)
QPOS
"KRN",.84,7980000.004,3,7,0)
OPENFAIL
"KRN",.84,7980000.004,3,8,0)
ACK
"KRN",.84,7980000.004,3,9,0)
ERRTYPE
"KRN",.84,7980000.004,5,0)
^.841^1^1
"KRN",.84,7980000.004,5,1,0)
RORUTL05^MSG7STS
"KRN",.84,7980000.004,5,"B","RORUTL05",1)

"KRN",.84,7980000.005,-1)
0^6
"KRN",.84,7980000.005,0)
7980000.005^2^y^CLINICAL CASE REGISTRIES^National HL7 Notification
"KRN",.84,7980000.005,2,0)
^.844^38^38^3040115^^^^
"KRN",.84,7980000.005,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7980000.005,2,2,0)
<HL7_PROBLEM>
"KRN",.84,7980000.005,2,3,0)
  <DESCRIPTION>
"KRN",.84,7980000.005,2,4,0)
    The application acknowledgement for the HL7 message #|ID|
"KRN",.84,7980000.005,2,5,0)
    (generated by the '|REGISTRY|') has not been received by
"KRN",.84,7980000.005,2,6,0)
    the '|STNAME|' after |NOR| attempt(s) to resend the message.
"KRN",.84,7980000.005,2,7,0)
    Please coordinate actions of the site and the Austin Automation
"KRN",.84,7980000.005,2,8,0)
    Center (AAC) and fix the problem as soon as possible.
"KRN",.84,7980000.005,2,9,0)
  </DESCRIPTION>
"KRN",.84,7980000.005,2,10,0)
  <STATION>
"KRN",.84,7980000.005,2,11,0)
    <NUMBER>|STNUM|</NUMBER>
"KRN",.84,7980000.005,2,12,0)
    <NAME>|STNAME|</NAME>
"KRN",.84,7980000.005,2,13,0)
  </STATION>
"KRN",.84,7980000.005,2,14,0)
  <REGISTRY>|REGISTRY|</REGISTRY>
"KRN",.84,7980000.005,2,15,0)
  <MESSAGE_STATUS>
"KRN",.84,7980000.005,2,16,0)
    <DESCRIPTION>
"KRN",.84,7980000.005,2,17,0)
      Message ID....... |ID|
"KRN",.84,7980000.005,2,18,0)
      Message status... |STATUS|
"KRN",.84,7980000.005,2,19,0)
      Status updated... |UPDATED|
"KRN",.84,7980000.005,2,20,0)
      Error message.... |ERRMSG|
"KRN",.84,7980000.005,2,21,0)
      Error type....... |ERRTYPE|
"KRN",.84,7980000.005,2,22,0)
      # of retries..... |RETRIES|
"KRN",.84,7980000.005,2,23,0)
      Queue position... |QPOS|
"KRN",.84,7980000.005,2,24,0)
      # Open failed.... |OPENFAIL|
"KRN",.84,7980000.005,2,25,0)
      ACK timeout...... |ACK|
"KRN",.84,7980000.005,2,26,0)
    </DESCRIPTION>
"KRN",.84,7980000.005,2,27,0)
    <MSGID>|ID|</MSGID>
"KRN",.84,7980000.005,2,28,0)
    <STATUS>|STATUS|</STATUS>
"KRN",.84,7980000.005,2,29,0)
    <STATUS_CODE>|STATCODE|</STATUS_CODE>
"KRN",.84,7980000.005,2,30,0)
    <STATUS_UPDATED>|STATUPD|</STATUS_UPDATED>
"KRN",.84,7980000.005,2,31,0)
    <ERRMSG>|ERRMSG|</ERRMSG>
"KRN",.84,7980000.005,2,32,0)
    <ERRTYPE>|ERRTYPE|</ERRTYPE>
"KRN",.84,7980000.005,2,33,0)
    <RETRIES>|RETRIES|</RETRIES>
"KRN",.84,7980000.005,2,34,0)
    <QPOS>|QPOS|</QPOS>
"KRN",.84,7980000.005,2,35,0)
    <OPENFAIL>|OPENFAIL|</OPENFAIL>
"KRN",.84,7980000.005,2,36,0)
    <ACKTO>|ACK|</ACKTO>
"KRN",.84,7980000.005,2,37,0)
  </MESSAGE_STATUS>
"KRN",.84,7980000.005,2,38,0)
</HL7_PROBLEM>
"KRN",.84,7980000.005,3,0)
^.845^15^15
"KRN",.84,7980000.005,3,1,0)
ID
"KRN",.84,7980000.005,3,2,0)
STATUS
"KRN",.84,7980000.005,3,3,0)
UPDATED
"KRN",.84,7980000.005,3,4,0)
ERRMSG
"KRN",.84,7980000.005,3,5,0)
RETRIES
"KRN",.84,7980000.005,3,6,0)
QPOS
"KRN",.84,7980000.005,3,7,0)
OPENFAIL
"KRN",.84,7980000.005,3,8,0)
ACK
"KRN",.84,7980000.005,3,9,0)
REGISTRY
"KRN",.84,7980000.005,3,10,0)
STNAME
"KRN",.84,7980000.005,3,11,0)
NOR
"KRN",.84,7980000.005,3,12,0)
STNUM
"KRN",.84,7980000.005,3,13,0)
ERRTYPE
"KRN",.84,7980000.005,3,14,0)
STATCODE
"KRN",.84,7980000.005,3,15,0)
STATUPD
"KRN",.84,7980000.005,5,0)
^.841^1^1
"KRN",.84,7980000.005,5,1,0)
RORUTL05^MSG7STS
"KRN",.84,7980000.005,5,"B","RORUTL05",1)

"KRN",.84,7980000.006,-1)
0^7
"KRN",.84,7980000.006,0)
7980000.006^2^y^CLINICAL CASE REGISTRIES^Local HL7 Problem Notification
"KRN",.84,7980000.006,2,0)
^.844^15^15^3030424^^
"KRN",.84,7980000.006,2,1,0)
The application acknowledgement for the HL7 message #|ID|
"KRN",.84,7980000.006,2,2,0)
(generated by the '|REGISTRY|') has not been received after
"KRN",.84,7980000.006,2,3,0)
|NOR| attempt(s) to resend the message. Please contact the
"KRN",.84,7980000.006,2,4,0)
IRM personnel and the Austin Automation Center (AAC) and
"KRN",.84,7980000.006,2,5,0)
investigate the problem as soon as possible!
"KRN",.84,7980000.006,2,6,0)
 
"KRN",.84,7980000.006,2,7,0)
  Message ID....... |ID|
"KRN",.84,7980000.006,2,8,0)
  Message status... |STATUS|
"KRN",.84,7980000.006,2,9,0)
  Status updated... |UPDATED|
"KRN",.84,7980000.006,2,10,0)
  Error message.... |ERRMSG|
"KRN",.84,7980000.006,2,11,0)
  Error type....... |ERRTYPE|
"KRN",.84,7980000.006,2,12,0)
  # of retries..... |RETRIES|
"KRN",.84,7980000.006,2,13,0)
  Queue position... |QPOS|
"KRN",.84,7980000.006,2,14,0)
  # Open failed.... |OPENFAIL|
"KRN",.84,7980000.006,2,15,0)
  ACK timeout...... |ACK|
"KRN",.84,7980000.006,3,0)
^.845^8^8
"KRN",.84,7980000.006,3,1,0)
ID
"KRN",.84,7980000.006,3,2,0)
STATUS
"KRN",.84,7980000.006,3,3,0)
UPDATED
"KRN",.84,7980000.006,3,4,0)
ERRMSG
"KRN",.84,7980000.006,3,5,0)
RETRIES
"KRN",.84,7980000.006,3,6,0)
QPOS
"KRN",.84,7980000.006,3,7,0)
OPENFAIL
"KRN",.84,7980000.006,3,8,0)
ACK
"KRN",.84,7980000.006,5,0)
^.841^1^1
"KRN",.84,7980000.006,5,1,0)
RORUTL05^MSG7STS
"KRN",.84,7980000.006,5,"B","RORUTL05",1)

"KRN",.84,7980000.007,-1)
0^8
"KRN",.84,7980000.007,0)
7980000.007^3^^CLINICAL CASE REGISTRIES^Re-index the ACL xref
"KRN",.84,7980000.007,2,0)
^.844^6^6^3030606^^^
"KRN",.84,7980000.007,2,1,0)
The "ACL" cross-reference of the ROR REGISTRY PARAMETERS file (#798.1)
"KRN",.84,7980000.007,2,2,0)
should be rebuilt after changes in the allocation of the security keys
"KRN",.84,7980000.007,2,3,0)
associated with any registry. Usually, this is done by the nightly task
"KRN",.84,7980000.007,2,4,0)
(the [ROR TASK] option).  However, if you want the changes to be in effect
"KRN",.84,7980000.007,2,5,0)
immediately, you should rebuild this cross-reference manually.
"KRN",.84,7980000.007,2,6,0)
Enter either 'Y' or 'N'.
"KRN",.84,7980000.007,5,0)
^.841^1^1
"KRN",.84,7980000.007,5,1,0)
RORVM001^RNDXACL
"KRN",.84,7980000.007,5,"B","RORVM001",1)

"KRN",.84,7980000.008,-1)
0^9
"KRN",.84,7980000.008,0)
7980000.008^3^^CLINICAL CASE REGISTRIES^Schedule the registry setup?
"KRN",.84,7980000.008,2,0)
^^18^18^3030609^
"KRN",.84,7980000.008,2,1,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.008,2,2,0)
  After the software is installed, the registry must be
"KRN",.84,7980000.008,2,3,0)
  populated with the patients that have HIV/AIDS related data.
"KRN",.84,7980000.008,2,4,0)
  The registry setup task populates the registry and performs
"KRN",.84,7980000.008,2,5,0)
  other implementation steps. If you are installing the 
"KRN",.84,7980000.008,2,6,0)
  software for the first time, you must answer YES.
"KRN",.84,7980000.008,2,7,0)
 
"KRN",.84,7980000.008,2,8,0)
  When the initial registry population is complete, you will
"KRN",.84,7980000.008,2,9,0)
  received a VistA alert. Only after that you can add the name
"KRN",.84,7980000.008,2,10,0)
  of the registry (VA ICR) to the nightly task (the [ROR TASK]
"KRN",.84,7980000.008,2,11,0)
  option) parameter.
"KRN",.84,7980000.008,2,12,0)
 
"KRN",.84,7980000.008,2,13,0)
  If you are reinstalling the software and initial registry
"KRN",.84,7980000.008,2,14,0)
  population has been done already, the answer depends on the
"KRN",.84,7980000.008,2,15,0)
  reason for the reinstallation and the instructions, which 
"KRN",.84,7980000.008,2,16,0)
  you have probably been given.
"KRN",.84,7980000.008,2,17,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.008,2,18,0)
  Enter either 'Y' or 'N'.
"KRN",.84,7980000.008,5,0)
^.841^1^1
"KRN",.84,7980000.008,5,1,0)
RORSETU1
"KRN",.84,7980000.008,5,"B","RORSETU1",1)

"KRN",.84,7980000.009,-1)
0^10
"KRN",.84,7980000.009,0)
7980000.009^3^^CLINICAL CASE REGISTRIES^Maximum number of subtasks?
"KRN",.84,7980000.009,2,0)
^^6^6^3030606^
"KRN",.84,7980000.009,2,1,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.009,2,2,0)
  During the initial registry population performed by the
"KRN",.84,7980000.009,2,3,0)
  registry setup task several registry update subtask can be
"KRN",.84,7980000.009,2,4,0)
  scheduled to speed up the process.
"KRN",.84,7980000.009,2,5,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.009,2,6,0)
  Enter a number between 0 and 10, 0 decimal digits.
"KRN",.84,7980000.009,5,0)
^.841^1^1
"KRN",.84,7980000.009,5,1,0)
RORSETU1
"KRN",.84,7980000.009,5,"B","RORSETU1",1)

"KRN",.84,7980000.01,-1)
0^11
"KRN",.84,7980000.01,0)
7980000.01^3^^CLINICAL CASE REGISTRIES^Suspend the task(s)?
"KRN",.84,7980000.01,2,0)
^^13^13^3030606^
"KRN",.84,7980000.01,2,1,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.01,2,2,0)
  If you answer YES to this question, registry update subtasks
"KRN",.84,7980000.01,2,3,0)
  that populate the registry will be suspended during the peak
"KRN",.84,7980000.01,2,4,0)
  weekday hours to conserve the CPU resources.
"KRN",.84,7980000.01,2,5,0)
 
"KRN",.84,7980000.01,2,6,0)
  The tasks will not be suspended on weekends and holidays.
"KRN",.84,7980000.01,2,7,0)
  If the initial registry update runs in the single-task mode,
"KRN",.84,7980000.01,2,8,0)
  it will never be suspended.
"KRN",.84,7980000.01,2,9,0)
 
"KRN",.84,7980000.01,2,10,0)
  Two additional prompts will be displayed asking you to enter
"KRN",.84,7980000.01,2,11,0)
  start and end time of the suspension.
"KRN",.84,7980000.01,2,12,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.01,2,13,0)
  Enter either 'Y' or 'N'.
"KRN",.84,7980000.01,5,0)
^.841^1^1
"KRN",.84,7980000.01,5,1,0)
RORSETU1
"KRN",.84,7980000.01,5,"B","RORSETU1",1)

"KRN",.84,7980000.011,-1)
0^12
"KRN",.84,7980000.011,0)
7980000.011^3^^CLINICAL CASE REGISTRIES^Suspension start time?
"KRN",.84,7980000.011,2,0)
^^7^7^3030606^
"KRN",.84,7980000.011,2,1,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.011,2,2,0)
  Registry update subtasks will be suspended after this time 
"KRN",.84,7980000.011,2,3,0)
  every day except the weekends and holidays. However, they 
"KRN",.84,7980000.011,2,4,0)
  will be checking for a stop request every hour during the
"KRN",.84,7980000.011,2,5,0)
  suspension.
"KRN",.84,7980000.011,2,6,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.011,2,7,0)
  Enter time of the day (e.g. 8AM).
"KRN",.84,7980000.011,5,0)
^.841^1^1
"KRN",.84,7980000.011,5,1,0)
RORSETU1
"KRN",.84,7980000.011,5,"B","RORSETU1",1)

"KRN",.84,7980000.012,-1)
0^13
"KRN",.84,7980000.012,0)
7980000.012^3^^CLINICAL CASE REGISTRIES^Suspension end time?
"KRN",.84,7980000.012,2,0)
^^6^6^3030606^
"KRN",.84,7980000.012,2,1,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.012,2,2,0)
  The registry update subtasks will be resumed at this time 
"KRN",.84,7980000.012,2,3,0)
  every day. The suspension end time must be later than the
"KRN",.84,7980000.012,2,4,0)
  suspension start time.
"KRN",.84,7980000.012,2,5,0)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.012,2,6,0)
  Enter time of the day (e.g. 5PM).
"KRN",.84,7980000.012,5,0)
^.841^1^1
"KRN",.84,7980000.012,5,1,0)
RORSETU1
"KRN",.84,7980000.012,5,"B","RORSETU1",1)

"KRN",.84,7980000.013,-1)
0^14
"KRN",.84,7980000.013,0)
7980000.013^2^y^CLINICAL CASE REGISTRIES^Check the diagnosis
"KRN",.84,7980000.013,2,0)
^.844^9^9^3030708^^
"KRN",.84,7980000.013,2,1,0)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.013,2,2,0)
A record of the |REGISTRY| has been inactivated.
"KRN",.84,7980000.013,2,3,0)
 
"KRN",.84,7980000.013,2,4,0)
  Patient: |NAME| (|LAST4|)
"KRN",.84,7980000.013,2,5,0)
 
"KRN",.84,7980000.013,2,6,0)
However, the patient has an ICD-9 code(s) or test result(s) consistent
"KRN",.84,7980000.013,2,7,0)
with the registry. Please make sure that the patient has the correct
"KRN",.84,7980000.013,2,8,0)
diagnosis in the medical record.
"KRN",.84,7980000.013,2,9,0)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.013,3,0)
^.845^4^3
"KRN",.84,7980000.013,3,1,0)
REGISTRY^Registry Name
"KRN",.84,7980000.013,3,2,0)
NAME^Patient Name
"KRN",.84,7980000.013,3,4,0)
LAST4^Last 4 digits of the SSN
"KRN",.84,7980000.014,-1)
0^15
"KRN",.84,7980000.014,0)
7980000.014^2^y^CLINICAL CASE REGISTRIES^Add appropriate ICD-9 codes
"KRN",.84,7980000.014,2,0)
^.844^8^8^3031028^^
"KRN",.84,7980000.014,2,1,0)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.014,2,2,0)
A record of the |REGISTRY| has been (re)activated.
"KRN",.84,7980000.014,2,3,0)
 
"KRN",.84,7980000.014,2,4,0)
Patient: |NAME| (|LAST4|)
"KRN",.84,7980000.014,2,5,0)
 
"KRN",.84,7980000.014,2,6,0)
Please ensure that you add the appropriate ICD-9 code(s) to the Problem
"KRN",.84,7980000.014,2,7,0)
List for this patient.
"KRN",.84,7980000.014,2,8,0)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.014,3,0)
^.845^2^2
"KRN",.84,7980000.014,3,1,0)
NAME^Patient Name
"KRN",.84,7980000.014,3,2,0)
LAST4^Last 4 digits of the SSN
"KRN",.84,7980000.015,-1)
0^18
"KRN",.84,7980000.015,0)
7980000.015^2^y^CLINICAL CASE REGISTRIES^Access Violation Alert
"KRN",.84,7980000.015,2,0)
^.844^6^6^3031028^^
"KRN",.84,7980000.015,2,1,0)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.015,2,2,0)
An attempt of unauthorized access to the Clinical Case Registries data
"KRN",.84,7980000.015,2,3,0)
has been made on |DATETIME|.
"KRN",.84,7980000.015,2,4,0)
 
"KRN",.84,7980000.015,2,5,0)
Violator: |USERNAME| (DUZ=|DUZ|)
"KRN",.84,7980000.015,2,6,0)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.015,3,0)
^.845^4^3
"KRN",.84,7980000.015,3,2,0)
USERNAME
"KRN",.84,7980000.015,3,3,0)
DATETIME
"KRN",.84,7980000.015,3,4,0)
DUZ
"KRN",.84,7980000.015,5,0)
^.841^1^1
"KRN",.84,7980000.015,5,1,0)
RORLOG^ACVIOLTN
"KRN",.84,7980000.015,5,"B","RORLOG",1)

"KRN",.84,7980000.016,-1)
0^22
"KRN",.84,7980000.016,0)
7980000.016^2^y^CLINICAL CASE REGISTRIES^List of Risk factors
"KRN",.84,7980000.016,2,0)
^.844^13^13^3030917^^^^
"KRN",.84,7980000.016,2,1,0)
<RISK ID="1" COUNT="|1|">Sex with Male</RISK>
"KRN",.84,7980000.016,2,2,0)
<RISK ID="2" COUNT="|2|">Sex with Female</RISK>
"KRN",.84,7980000.016,2,3,0)
<RISK ID="3" COUNT="|3|">Injected Nonprescription Drug(s)</RISK>
"KRN",.84,7980000.016,2,4,0)
<RISK ID="4" COUNT="|4|">Received Clotting Factor for Hemophilia/Coagulation Disorder</RISK>
"KRN",.84,7980000.016,2,5,0)
<RISK ID="5" COUNT="|5|">Heterosexual Relations with Bisexual Male</RISK>
"KRN",.84,7980000.016,2,6,0)
<RISK ID="6" COUNT="|6|">Heterosexual Relations with Intravenous Drug user</RISK>
"KRN",.84,7980000.016,2,7,0)
<RISK ID="7" COUNT="|7|">Heterosexual Relations with Person with Hemophilia/Coagulation Disorder</RISK>
"KRN",.84,7980000.016,2,8,0)
<RISK ID="8" COUNT="|8|">Heterosexual Relations with Transfusion Recipient with HIV</RISK>
"KRN",.84,7980000.016,2,9,0)
<RISK ID="9" COUNT="|9|">Heterosexual Relations with Transplant Recipient with HIV</RISK>
"KRN",.84,7980000.016,2,10,0)
<RISK ID="10" COUNT="|10|">Heterosexual Relations with Person with AIDS/HIV infection</RISK>
"KRN",.84,7980000.016,2,11,0)
<RISK ID="11" COUNT="|11|">Received Transfusions Other than Clotting Factor</RISK>
"KRN",.84,7980000.016,2,12,0)
<RISK ID="12" COUNT="|12|">Received Transplant or Artificial Insemination</RISK>
"KRN",.84,7980000.016,2,13,0)
<RISK ID="13" COUNT="|13|">Worked in Healthcare or Laboratory</RISK>
"KRN",.84,7980000.017,-1)
0^27
"KRN",.84,7980000.017,0)
7980000.017^2^y^CLINICAL CASE REGISTRIES^List of Utilization Types
"KRN",.84,7980000.017,2,0)
^.844^11^11^3040112^
"KRN",.84,7980000.017,2,1,0)
<UTIL ID="A" COUNT="|A|">Allergy</UTIL>
"KRN",.84,7980000.017,2,2,0)
<UTIL ID="C" COUNT="|C|">Cythopatology</UTIL>
"KRN",.84,7980000.017,2,3,0)
<UTIL ID="I" COUNT="|I|">Inpatient Data</UTIL>
"KRN",.84,7980000.017,2,4,0)
<UTIL ID="IP" COUNT="|IP|">Inpatient Pharmacy</UTIL>
"KRN",.84,7980000.017,2,5,0)
<UTIL ID="IV" COUNT="|IV|">IV Drugs</UTIL>
"KRN",.84,7980000.017,2,6,0)
<UTIL ID="L" COUNT="|L|">Laboratory</UTIL>
"KRN",.84,7980000.017,2,7,0)
<UTIL ID="M" COUNT="|M|">Microbiology</UTIL>
"KRN",.84,7980000.017,2,8,0)
<UTIL ID="O" COUNT="|O|">Outpatient Clinic Stop</UTIL>
"KRN",.84,7980000.017,2,9,0)
<UTIL ID="OP" COUNT="|OP|">Outpatient Pharmacy</UTIL>
"KRN",.84,7980000.017,2,10,0)
<UTIL ID="R" COUNT="|R|">Radiology</UTIL>
"KRN",.84,7980000.017,2,11,0)
<UTIL ID="SP" COUNT="|SP|">Surgical Pathology</UTIL>
"KRN",.84,7980000.017,3,0)
^.845^11^11
"KRN",.84,7980000.017,3,1,0)
A
"KRN",.84,7980000.017,3,2,0)
C
"KRN",.84,7980000.017,3,3,0)
I
"KRN",.84,7980000.017,3,4,0)
IP
"KRN",.84,7980000.017,3,5,0)
IV
"KRN",.84,7980000.017,3,6,0)
L
"KRN",.84,7980000.017,3,7,0)
M
"KRN",.84,7980000.017,3,8,0)
O
"KRN",.84,7980000.017,3,9,0)
OP
"KRN",.84,7980000.017,3,10,0)
R
"KRN",.84,7980000.017,3,11,0)
SP
"KRN",.84,7980000.018,-1)
0^29
"KRN",.84,7980000.018,0)
7980000.018^2^^CLINICAL CASE REGISTRIES^Report options
"KRN",.84,7980000.018,2,0)
^^67^67^3031205^
"KRN",.84,7980000.018,2,1,0)
INACTIVE,ACTIVE
"KRN",.84,7980000.018,2,2,0)
        Inactive
"KRN",.84,7980000.018,2,3,0)
        Active
"KRN",.84,7980000.018,2,4,0)
        Both Active and Inactive
"KRN",.84,7980000.018,2,5,0)
 
"KRN",.84,7980000.018,2,6,0)
DE_BEFORE,DE_DURING,DE_AFTER
"KRN",.84,7980000.018,2,7,0)
        Added before the date range
"KRN",.84,7980000.018,2,8,0)
        Added during the date range
"KRN",.84,7980000.018,2,9,0)
        Added before and during the date range
"KRN",.84,7980000.018,2,10,0)
        Added after the date range
"KRN",.84,7980000.018,2,11,0)
        Added before and after the date range 
"KRN",.84,7980000.018,2,12,0)
        Added during and after the date range
"KRN",.84,7980000.018,2,13,0)
        Added on any date
"KRN",.84,7980000.018,2,14,0)
 
"KRN",.84,7980000.018,2,15,0)
INPATIENT,OUTPATIENT
"KRN",.84,7980000.018,2,16,0)
        Inpatient
"KRN",.84,7980000.018,2,17,0)
        Outpatient
"KRN",.84,7980000.018,2,18,0)
        Both Inpatients and Outpatients
"KRN",.84,7980000.018,2,19,0)
 
"KRN",.84,7980000.018,2,20,0)
NOTSEEN,SEEN
"KRN",.84,7980000.018,2,21,0)
        Not Seen
"KRN",.84,7980000.018,2,22,0)
        Seen
"KRN",.84,7980000.018,2,23,0)
        Both Seen and Not Seen
"KRN",.84,7980000.018,2,24,0)
 
"KRN",.84,7980000.018,2,25,0)
HIV,AIDS
"KRN",.84,7980000.018,2,26,0)
        HIV+ (no AIDS OI)
"KRN",.84,7980000.018,2,27,0)
        AIDS OI
"KRN",.84,7980000.018,2,28,0)
        Both HIV+ (no AIDS OI) and AIDS OI
"KRN",.84,7980000.018,2,29,0)
 
"KRN",.84,7980000.018,2,30,0)
PHARMACY,LAB
"KRN",.84,7980000.018,2,31,0)
        Pharmacy Data
"KRN",.84,7980000.018,2,32,0)
        Lab Data
"KRN",.84,7980000.018,2,33,0)
        Both Pharmacy and Lab Data
"KRN",.84,7980000.018,2,34,0)
 
"KRN",.84,7980000.018,2,35,0)
BASIC,COMPLEX
"KRN",.84,7980000.018,2,36,0)
        Basic Care
"KRN",.84,7980000.018,2,37,0)
        Complex Care
"KRN",.84,7980000.018,2,38,0)
        Both Basic and Complex Care
"KRN",.84,7980000.018,2,39,0)
 
"KRN",.84,7980000.018,2,40,0)
ARVSMRY
"KRN",.84,7980000.018,2,41,0)
        Summary ARV Use Table
"KRN",.84,7980000.018,2,42,0)
 
"KRN",.84,7980000.018,2,43,0)
PTLIST
"KRN",.84,7980000.018,2,44,0)
        List of Patients
"KRN",.84,7980000.018,2,45,0)
 
"KRN",.84,7980000.018,2,46,0)
CAREONLY
"KRN",.84,7980000.018,2,47,0)
        Treated Only
"KRN",.84,7980000.018,2,48,0)
 
"KRN",.84,7980000.018,2,49,0)
CATSPLIT
"KRN",.84,7980000.018,2,50,0)
        Split by Category
"KRN",.84,7980000.018,2,51,0)
 
"KRN",.84,7980000.018,2,52,0)
COMPLETE
"KRN",.84,7980000.018,2,53,0)
        Complete Report
"KRN",.84,7980000.018,2,54,0)
 
"KRN",.84,7980000.018,2,55,0)
SUMMARY
"KRN",.84,7980000.018,2,56,0)
        Summary
"KRN",.84,7980000.018,2,57,0)
 
"KRN",.84,7980000.018,2,58,0)
GENERIC
"KRN",.84,7980000.018,2,59,0)
        Generic Drugs
"KRN",.84,7980000.018,2,60,0)
 
"KRN",.84,7980000.018,2,61,0)
DISPENSED
"KRN",.84,7980000.018,2,62,0)
        Dispensed Drugs
"KRN",.84,7980000.018,2,63,0)
 
"KRN",.84,7980000.018,2,64,0)
ARV,INVESTIG
"KRN",.84,7980000.018,2,65,0)
        Include ARV Drugs
"KRN",.84,7980000.018,2,66,0)
        Include Investigational Drugs
"KRN",.84,7980000.018,2,67,0)
        Include ARV and Investigational Drugs
"KRN",.84,7980000.018,5,0)
^.841^1^1
"KRN",.84,7980000.018,5,1,0)
RORXU002^OPTXT
"KRN",.84,7980000.018,5,"B","RORXU002",1)

"KRN",.84,7980000.019,-1)
0^31
"KRN",.84,7980000.019,0)
7980000.019^2^y^CLINICAL CASE REGISTRIES^Alert: Task has finished
"KRN",.84,7980000.019,2,0)
^^6^6^3031028^
"KRN",.84,7980000.019,2,1,0)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.019,2,2,0)
Your task/report scheduled from the Clinical Case Registries GUI
"KRN",.84,7980000.019,2,3,0)
application has finished. You can view the results using the Task
"KRN",.84,7980000.019,2,4,0)
Manager page of the main window of the GUI.
"KRN",.84,7980000.019,2,5,0)
Task description: '|TASKDESCR|'
"KRN",.84,7980000.019,2,6,0)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"KRN",.84,7980000.019,3,0)
^.845^1^1
"KRN",.84,7980000.019,3,1,0)
TASKDESCR
"KRN",.84,7980000.019,5,0)
^.841^1^1
"KRN",.84,7980000.019,5,1,0)
RORTSK01^ALERTRTN
"KRN",.84,7980000.019,5,"B","RORTSK01",1)

"KRN",.84,7980000.02,-1)
0^56
"KRN",.84,7980000.02,0)
7980000.02^1^^CLINICAL CASE REGISTRIES^Registry has not been populated
"KRN",.84,7980000.02,2,0)
^^4^4^3040113^
"KRN",.84,7980000.02,2,1,0)
The registry must be populated by the registry setup option [ROR 
"KRN",.84,7980000.02,2,2,0)
SETUP]. Only when the initial population of the registry is complete
"KRN",.84,7980000.02,2,3,0)
you can add its name to the list of the registries to be updated by
"KRN",.84,7980000.02,2,4,0)
the nightly task.
"KRN",.84,7980000.02,5,0)
^.841^1^1
"KRN",.84,7980000.02,5,1,0)
RORUTL02^ARLST
"KRN",.84,7980000.02,5,"B","RORUTL02",1)

"KRN",.84,7980000.021,-1)
0^57
"KRN",.84,7980000.021,0)
7980000.021^2^y^CLINICAL CASE REGISTRIES^Registry Status Notification (1)
"KRN",.84,7980000.021,2,0)
^^16^16^3040115^
"KRN",.84,7980000.021,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7980000.021,2,2,0)
<REGISTRY_INFO>
"KRN",.84,7980000.021,2,3,0)
<STATION>
"KRN",.84,7980000.021,2,4,0)
  <NUMBER>|STNUM|</NUMBER>
"KRN",.84,7980000.021,2,5,0)
  <NAME>|STNAME|</NAME>
"KRN",.84,7980000.021,2,6,0)
</STATION>
"KRN",.84,7980000.021,2,7,0)
<REGISTRY>|REGISTRY|</REGISTRY>
"KRN",.84,7980000.021,2,8,0)
<DATE>|DATE|</DATE>
"KRN",.84,7980000.021,2,9,0)
<UPDATED_UNTIL>|UPDATED_UNTIL|</UPDATED_UNTIL>
"KRN",.84,7980000.021,2,10,0)
<EXTRACTED_UNTIL>|EXTRACTED_UNTIL|</EXTRACTED_UNTIL>
"KRN",.84,7980000.021,2,11,0)
<RETRIES>|RETRIES|</RETRIES>
"KRN",.84,7980000.021,2,12,0)
<DTACKMIN>|DTACKMIN|</DTACKMIN>
"KRN",.84,7980000.021,2,13,0)
<DTACKMAX>|DTACKMAX|</DTACKMAX>
"KRN",.84,7980000.021,2,14,0)
<NPT>|NPT|</NPT>
"KRN",.84,7980000.021,2,15,0)
<NPA>|NPA|</NPA>
"KRN",.84,7980000.021,2,16,0)
<NPP>|NPP|</NPP>
"KRN",.84,7980000.021,3,0)
^.845^12^4
"KRN",.84,7980000.021,3,5,0)
RETRIES^
"KRN",.84,7980000.021,3,9,0)
REGISTRY
"KRN",.84,7980000.021,3,10,0)
STNAME
"KRN",.84,7980000.021,3,12,0)
STNUM
"KRN",.84,7980000.021,5,0)
^.841^1^1
"KRN",.84,7980000.021,5,1,0)
RORSETU3^SENDINFO
"KRN",.84,7980000.021,5,"B","RORSETU3",1)

"KRN",.84,7980000.022,-1)
0^58
"KRN",.84,7980000.022,0)
7980000.022^2^^CLINICAL CASE REGISTRIES^Registry Status Notification (2)
"KRN",.84,7980000.022,2,0)
^^1^1^3040115^
"KRN",.84,7980000.022,2,1,0)
</REGISTRY_INFO>
"KRN",.84,7980000.022,5,0)
^.841^1^1
"KRN",.84,7980000.022,5,1,0)
RORSETU3^SENDINFO
"KRN",.84,7980000.022,5,"B","RORSETU3",1)

"KRN",.84,7981000,-1)
0^2
"KRN",.84,7981000,0)
7981000^2^^CLINICAL CASE REGISTRIES^Default XSL stylesheet
"KRN",.84,7981000,2,0)
^.844^112^112^3031113^^
"KRN",.84,7981000,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981000,2,2,0)
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
"KRN",.84,7981000,2,3,0)
<xsl:output method="html" indent="no" encoding="iso-8859-1"/>
"KRN",.84,7981000,2,4,0)
<xsl:strip-space elements="*"/>
"KRN",.84,7981000,2,5,0)
 
"KRN",.84,7981000,2,6,0)
<xsl:template match="/">
"KRN",.84,7981000,2,7,0)
 <HTML>
"KRN",.84,7981000,2,8,0)
  <HEAD>
"KRN",.84,7981000,2,9,0)
   <TITLE>Clinical Case Registries Report</TITLE>
"KRN",.84,7981000,2,10,0)
  </HEAD>
"KRN",.84,7981000,2,11,0)
  <BODY>
"KRN",.84,7981000,2,12,0)
   <TABLE BORDER="1" WIDTH="100%" CELLSPACING="1">
"KRN",.84,7981000,2,13,0)
    <TR><TD ALIGN="CENTER" BGCOLOR="YELLOW">
"KRN",.84,7981000,2,14,0)
     <B>UNDER CONSTRUCTION</B>
"KRN",.84,7981000,2,15,0)
    </TD></TR>
"KRN",.84,7981000,2,16,0)
    <TR><TD>
"KRN",.84,7981000,2,17,0)
     <UL>
"KRN",.84,7981000,2,18,0)
      <xsl:apply-templates/>
"KRN",.84,7981000,2,19,0)
     </UL>
"KRN",.84,7981000,2,20,0)
    </TD></TR>
"KRN",.84,7981000,2,21,0)
   </TABLE>
"KRN",.84,7981000,2,22,0)
  </BODY>
"KRN",.84,7981000,2,23,0)
 </HTML>
"KRN",.84,7981000,2,24,0)
</xsl:template>
"KRN",.84,7981000,2,25,0)
 
"KRN",.84,7981000,2,26,0)
<xsl:template name="open">
"KRN",.84,7981000,2,27,0)
 <xsl:param name="slash"/>
"KRN",.84,7981000,2,28,0)
 <FONT color="blue">&lt;</FONT><FONT><xsl:attribute name="color">
"KRN",.84,7981000,2,29,0)
  <xsl:choose>
"KRN",.84,7981000,2,30,0)
   <xsl:when test="xsl:*">#990099</xsl:when>
"KRN",.84,7981000,2,31,0)
   <xsl:otherwise>#990000</xsl:otherwise>
"KRN",.84,7981000,2,32,0)
  </xsl:choose>
"KRN",.84,7981000,2,33,0)
 </xsl:attribute><xsl:value-of select="name(.)"/></FONT><xsl:apply-templates select="@*"/><FONT color="blue"><xsl:value-of select="$slash"/>&gt;</FONT>
"KRN",.84,7981000,2,34,0)
</xsl:template>
"KRN",.84,7981000,2,35,0)
 
"KRN",.84,7981000,2,36,0)
<xsl:template name="close">
"KRN",.84,7981000,2,37,0)
 <FONT color="blue">&lt;/</FONT><FONT><xsl:attribute name="color">
"KRN",.84,7981000,2,38,0)
  <xsl:choose>
"KRN",.84,7981000,2,39,0)
   <xsl:when test="xsl:*">#990099</xsl:when>
"KRN",.84,7981000,2,40,0)
   <xsl:otherwise>#990000</xsl:otherwise>
"KRN",.84,7981000,2,41,0)
  </xsl:choose>
"KRN",.84,7981000,2,42,0)
 </xsl:attribute><xsl:value-of select="name(.)"/></FONT><FONT color="blue">&gt;</FONT>
"KRN",.84,7981000,2,43,0)
</xsl:template>
"KRN",.84,7981000,2,44,0)
 
"KRN",.84,7981000,2,45,0)
<!-- Template for pis not handled elsewhere -->
"KRN",.84,7981000,2,46,0)
<xsl:template match="processing-instruction()">
"KRN",.84,7981000,2,47,0)
 <FONT color="blue">&lt;?<xsl:value-of select="name(.)"/> <xsl:value-of select="."/>?&gt;</FONT><BR/>
"KRN",.84,7981000,2,48,0)
</xsl:template>
"KRN",.84,7981000,2,49,0)
 
"KRN",.84,7981000,2,50,0)
<!-- Template for attributes not handled elsewhere -->
"KRN",.84,7981000,2,51,0)
<xsl:template match="@*">
"KRN",.84,7981000,2,52,0)
 <FONT color="#990000"><xsl:text> </xsl:text><xsl:value-of select="name(.)"/></FONT>
"KRN",.84,7981000,2,53,0)
 <FONT color="blue">="</FONT><B><xsl:value-of select="."/></B><FONT color="blue">"</FONT>
"KRN",.84,7981000,2,54,0)
</xsl:template>
"KRN",.84,7981000,2,55,0)
 
"KRN",.84,7981000,2,56,0)
<!-- Template for text nodes -->
"KRN",.84,7981000,2,57,0)
<xsl:template match="text()">
"KRN",.84,7981000,2,58,0)
 <xsl:choose>
"KRN",.84,7981000,2,59,0)
  <xsl:when test="name(.) = '#cdata-section'">
"KRN",.84,7981000,2,60,0)
   <xsl:call-template name="cdata"/>
"KRN",.84,7981000,2,61,0)
  </xsl:when>
"KRN",.84,7981000,2,62,0)
  <xsl:otherwise>
"KRN",.84,7981000,2,63,0)
   <B><xsl:value-of select="."/></B><BR/>
"KRN",.84,7981000,2,64,0)
  </xsl:otherwise>
"KRN",.84,7981000,2,65,0)
 </xsl:choose>
"KRN",.84,7981000,2,66,0)
</xsl:template>
"KRN",.84,7981000,2,67,0)
  
"KRN",.84,7981000,2,68,0)
<!-- Template for comment nodes -->
"KRN",.84,7981000,2,69,0)
<xsl:template match="comment()">
"KRN",.84,7981000,2,70,0)
 <FONT color="blue">&lt;!--</FONT><BR/>
"KRN",.84,7981000,2,71,0)
 <FONT color="#888888"><SMALL><PRE><xsl:value-of select="."/></PRE></SMALL></FONT><BR/>
"KRN",.84,7981000,2,72,0)
 <FONT color="blue">--&gt;</FONT><BR/>
"KRN",.84,7981000,2,73,0)
</xsl:template>
"KRN",.84,7981000,2,74,0)
 
"KRN",.84,7981000,2,75,0)
<!-- Template for cdata nodes -->
"KRN",.84,7981000,2,76,0)
<xsl:template name="cdata">
"KRN",.84,7981000,2,77,0)
 <FONT color="blue">&lt;![CDATA[</FONT><BR/>
"KRN",.84,7981000,2,78,0)
 <SMALL><PRE><xsl:value-of select="."/></PRE></SMALL><BR/>
"KRN",.84,7981000,2,79,0)
 <FONT color="blue">]]&gt;</FONT><BR/>
"KRN",.84,7981000,2,80,0)
</xsl:template>
"KRN",.84,7981000,2,81,0)
  
"KRN",.84,7981000,2,82,0)
<!-- Template for elements with comment, pi and/or cdata children
"KRN",.84,7981000,2,83,0)
<xsl:template match="*[comment() or processing-instruction() or cdata()]">
"KRN",.84,7981000,2,84,0)
 <xsl:call-template name="open">
"KRN",.84,7981000,2,85,0)
 <UL>
"KRN",.84,7981000,2,86,0)
  <xsl:apply-templates/>
"KRN",.84,7981000,2,87,0)
 </UL>
"KRN",.84,7981000,2,88,0)
 <xsl:call-template name="close"><BR/>
"KRN",.84,7981000,2,89,0)
</xsl:template> -->
"KRN",.84,7981000,2,90,0)
 
"KRN",.84,7981000,2,91,0)
<!-- Template for elements with only text children -->
"KRN",.84,7981000,2,92,0)
<xsl:template match="*[text() and not(comment() or processing-instruction() or *)]">
"KRN",.84,7981000,2,93,0)
 <xsl:call-template name="open"/><B><xsl:value-of select="."/></B><xsl:call-template name="close"/><BR/>
"KRN",.84,7981000,2,94,0)
</xsl:template>
"KRN",.84,7981000,2,95,0)
 
"KRN",.84,7981000,2,96,0)
<!-- Template for elements with element children -->
"KRN",.84,7981000,2,97,0)
<xsl:template match="*[*]">
"KRN",.84,7981000,2,98,0)
 <xsl:call-template name="open"/>
"KRN",.84,7981000,2,99,0)
 <UL>
"KRN",.84,7981000,2,100,0)
  <xsl:apply-templates/>
"KRN",.84,7981000,2,101,0)
 </UL>
"KRN",.84,7981000,2,102,0)
 <xsl:call-template name="close"/><BR/>
"KRN",.84,7981000,2,103,0)
</xsl:template>
"KRN",.84,7981000,2,104,0)
 
"KRN",.84,7981000,2,105,0)
<!-- Template for elements not handled elsewhere (leaf nodes) -->
"KRN",.84,7981000,2,106,0)
<xsl:template match="*">
"KRN",.84,7981000,2,107,0)
 <xsl:call-template name="open">
"KRN",.84,7981000,2,108,0)
  <xsl:with-param name="slash" select="'/'"/>
"KRN",.84,7981000,2,109,0)
 </xsl:call-template><BR/>
"KRN",.84,7981000,2,110,0)
</xsl:template>
"KRN",.84,7981000,2,111,0)
 
"KRN",.84,7981000,2,112,0)
</xsl:stylesheet>
"KRN",.84,7981000,5,0)
^.841^1^1
"KRN",.84,7981000,5,1,0)
RORRP011^GETXSL
"KRN",.84,7981000,5,"B","RORRP011",1)

"KRN",.84,7981000.002,-1)
0^20
"KRN",.84,7981000.002,0)
7981000.002^2^^CLINICAL CASE REGISTRIES^Default XSL Stylesheet (CSV)
"KRN",.84,7981000.002,2,0)
^.844^15^15^3031212^^
"KRN",.84,7981000.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981000.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981000.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981000.002,2,4,0)
>
"KRN",.84,7981000.002,2,5,0)
 
"KRN",.84,7981000.002,2,6,0)
<xsl:import href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981000.002,2,7,0)
 
"KRN",.84,7981000.002,2,8,0)
<xsl:output method="text" encoding="iso-8859-1"/>
"KRN",.84,7981000.002,2,9,0)
<xsl:strip-space elements="*"/>
"KRN",.84,7981000.002,2,10,0)
 
"KRN",.84,7981000.002,2,11,0)
<xsl:template match="/">
"KRN",.84,7981000.002,2,12,0)
 <xsl:apply-templates select="/REPORT"/> 
"KRN",.84,7981000.002,2,13,0)
</xsl:template>
"KRN",.84,7981000.002,2,14,0)
  
"KRN",.84,7981000.002,2,15,0)
</xsl:stylesheet>
"KRN",.84,7981001.001,-1)
0^3
"KRN",.84,7981001.001,0)
7981001.001^2^^CLINICAL CASE REGISTRIES^List of Registry Patients (HTML)
"KRN",.84,7981001.001,2,0)
^.844^79^79^3040202^^
"KRN",.84,7981001.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981001.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981001.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981001.001,2,4,0)
>
"KRN",.84,7981001.001,2,5,0)
 
"KRN",.84,7981001.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   --> 
"KRN",.84,7981001.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981001.001,2,8,0)
<xsl:include href="template://report/997/1"/>  <!-- Patients -->
"KRN",.84,7981001.001,2,9,0)
 
"KRN",.84,7981001.001,2,10,0)
<xsl:template match="/">
"KRN",.84,7981001.001,2,11,0)
 <html>
"KRN",.84,7981001.001,2,12,0)
  <head>
"KRN",.84,7981001.001,2,13,0)
   <title>List of Registry Patients</title>
"KRN",.84,7981001.001,2,14,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981001.001,2,15,0)
  </head>
"KRN",.84,7981001.001,2,16,0)
  <body>
"KRN",.84,7981001.001,2,17,0)
   <h1>List of Registry Patients</h1>
"KRN",.84,7981001.001,2,18,0)
   <xsl:call-template name="ReportHeader"/>
"KRN",.84,7981001.001,2,19,0)
   <div style="page-break-before:always">
"KRN",.84,7981001.001,2,20,0)
    <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981001.001,2,21,0)
   </div>
"KRN",.84,7981001.001,2,22,0)
  </body>
"KRN",.84,7981001.001,2,23,0)
 </html>
"KRN",.84,7981001.001,2,24,0)
</xsl:template>
"KRN",.84,7981001.001,2,25,0)
 
"KRN",.84,7981001.001,2,26,0)
<!--[ COLUMN HEADERS ]--> 
"KRN",.84,7981001.001,2,27,0)
 
"KRN",.84,7981001.001,2,28,0)
<xsl:template match="COLUMN[@NAME='INADT']">
"KRN",.84,7981001.001,2,29,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981001.001,2,30,0)
  <xsl:with-param name="title" select="'Inactivation Date'"/>
"KRN",.84,7981001.001,2,31,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981001.001,2,32,0)
 </xsl:call-template>
"KRN",.84,7981001.001,2,33,0)
</xsl:template>
"KRN",.84,7981001.001,2,34,0)
 
"KRN",.84,7981001.001,2,35,0)
<xsl:template match="COLUMN[@NAME='INARSN']">
"KRN",.84,7981001.001,2,36,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981001.001,2,37,0)
  <xsl:with-param name="title" select="'Inactivation Reason'"/>                 
"KRN",.84,7981001.001,2,38,0)
 </xsl:call-template>
"KRN",.84,7981001.001,2,39,0)
</xsl:template>
"KRN",.84,7981001.001,2,40,0)
 
"KRN",.84,7981001.001,2,41,0)
<xsl:template match="COLUMN[@NAME='READT']">
"KRN",.84,7981001.001,2,42,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981001.001,2,43,0)
  <xsl:with-param name="title" select="'Reactivation Date'"/>              
"KRN",.84,7981001.001,2,44,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981001.001,2,45,0)
 </xsl:call-template>
"KRN",.84,7981001.001,2,46,0)
</xsl:template>
"KRN",.84,7981001.001,2,47,0)
 
"KRN",.84,7981001.001,2,48,0)
<xsl:template match="COLUMN[@NAME='SELRULES']">
"KRN",.84,7981001.001,2,49,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981001.001,2,50,0)
  <xsl:with-param name="title" select="'Reasons'"/>
"KRN",.84,7981001.001,2,51,0)
  <xsl:with-param name="sort" select="''"/>                   
"KRN",.84,7981001.001,2,52,0)
 </xsl:call-template>
"KRN",.84,7981001.001,2,53,0)
</xsl:template>
"KRN",.84,7981001.001,2,54,0)
 
"KRN",.84,7981001.001,2,55,0)
<!--[ CELL VALUES ]--> 
"KRN",.84,7981001.001,2,56,0)
 
"KRN",.84,7981001.001,2,57,0)
<xsl:template match="PATIENT/INADT">
"KRN",.84,7981001.001,2,58,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981001.001,2,59,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981001.001,2,60,0)
 </xsl:call-template>
"KRN",.84,7981001.001,2,61,0)
</xsl:template>
"KRN",.84,7981001.001,2,62,0)
 
"KRN",.84,7981001.001,2,63,0)
<xsl:template match="PATIENT/READT">
"KRN",.84,7981001.001,2,64,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981001.001,2,65,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981001.001,2,66,0)
 </xsl:call-template>
"KRN",.84,7981001.001,2,67,0)
</xsl:template>
"KRN",.84,7981001.001,2,68,0)
 
"KRN",.84,7981001.001,2,69,0)
<xsl:template match="PATIENT/SELRULES">
"KRN",.84,7981001.001,2,70,0)
 <td class="aLeft">
"KRN",.84,7981001.001,2,71,0)
  <xsl:for-each select="RULE">
"KRN",.84,7981001.001,2,72,0)
   <xsl:value-of select="@DESCR"/>
"KRN",.84,7981001.001,2,73,0)
   <xsl:if test="@DESCR=''"><xsl:text>&#160;</xsl:text></xsl:if>
"KRN",.84,7981001.001,2,74,0)
   <br/>
"KRN",.84,7981001.001,2,75,0)
  </xsl:for-each>
"KRN",.84,7981001.001,2,76,0)
 </td>
"KRN",.84,7981001.001,2,77,0)
</xsl:template>
"KRN",.84,7981001.001,2,78,0)
 
"KRN",.84,7981001.001,2,79,0)
</xsl:stylesheet>
"KRN",.84,7981001.002,-1)
0^42
"KRN",.84,7981001.002,0)
7981001.002^2^^CLINICAL CASE REGISTRIES^List of Registry Patients (CSV)
"KRN",.84,7981001.002,2,0)
^.844^14^14^3040202^^
"KRN",.84,7981001.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981001.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981001.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981001.002,2,4,0)
>
"KRN",.84,7981001.002,2,5,0)
 
"KRN",.84,7981001.002,2,6,0)
<xsl:import  href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981001.002,2,7,0)
<xsl:include href="template://report/997/2"/>  <!-- Patients -->
"KRN",.84,7981001.002,2,8,0)
 
"KRN",.84,7981001.002,2,9,0)
<xsl:template match="/">
"KRN",.84,7981001.002,2,10,0)
 <xsl:text>List of Registry Patients</xsl:text>
"KRN",.84,7981001.002,2,11,0)
 <xsl:apply-templates select="/REPORT/PATIENTS"/> 
"KRN",.84,7981001.002,2,12,0)
</xsl:template>
"KRN",.84,7981001.002,2,13,0)
  
"KRN",.84,7981001.002,2,14,0)
</xsl:stylesheet>
"KRN",.84,7981002.001,-1)
0^19
"KRN",.84,7981002.001,0)
7981002.001^2^^CLINICAL CASE REGISTRIES^Current Inpatient List (HTML)
"KRN",.84,7981002.001,2,0)
^^42^42^3031212^
"KRN",.84,7981002.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981002.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981002.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981002.001,2,4,0)
>
"KRN",.84,7981002.001,2,5,0)
 
"KRN",.84,7981002.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   -->
"KRN",.84,7981002.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981002.001,2,8,0)
<xsl:include href="template://report/997/1"/>  <!-- Patients -->
"KRN",.84,7981002.001,2,9,0)
 
"KRN",.84,7981002.001,2,10,0)
<xsl:template match="/">
"KRN",.84,7981002.001,2,11,0)
 <html>
"KRN",.84,7981002.001,2,12,0)
  <head>
"KRN",.84,7981002.001,2,13,0)
   <title>Current Inpatient List</title>
"KRN",.84,7981002.001,2,14,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981002.001,2,15,0)
  </head>
"KRN",.84,7981002.001,2,16,0)
  <body>
"KRN",.84,7981002.001,2,17,0)
   <h1>Current Inpatient List</h1>
"KRN",.84,7981002.001,2,18,0)
   <xsl:call-template name="ReportHeader"/>
"KRN",.84,7981002.001,2,19,0)
   <div style="page-break-before:always">
"KRN",.84,7981002.001,2,20,0)
    <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981002.001,2,21,0)
   </div>
"KRN",.84,7981002.001,2,22,0)
  </body>
"KRN",.84,7981002.001,2,23,0)
 </html>
"KRN",.84,7981002.001,2,24,0)
</xsl:template>
"KRN",.84,7981002.001,2,25,0)
 
"KRN",.84,7981002.001,2,26,0)
<!--[ COLUMN HEADERS ]--> 
"KRN",.84,7981002.001,2,27,0)
 
"KRN",.84,7981002.001,2,28,0)
<xsl:template match="COLUMN[@NAME='ROOM-BED']">
"KRN",.84,7981002.001,2,29,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981002.001,2,30,0)
  <xsl:with-param name="title" select="'Room-Bed'"/>
"KRN",.84,7981002.001,2,31,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981002.001,2,32,0)
 </xsl:call-template>
"KRN",.84,7981002.001,2,33,0)
</xsl:template>
"KRN",.84,7981002.001,2,34,0)
 
"KRN",.84,7981002.001,2,35,0)
<xsl:template match="COLUMN[@NAME='WARD']">
"KRN",.84,7981002.001,2,36,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981002.001,2,37,0)
  <xsl:with-param name="title" select="'Ward'"/>
"KRN",.84,7981002.001,2,38,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981002.001,2,39,0)
 </xsl:call-template>
"KRN",.84,7981002.001,2,40,0)
</xsl:template>
"KRN",.84,7981002.001,2,41,0)
 
"KRN",.84,7981002.001,2,42,0)
</xsl:stylesheet>
"KRN",.84,7981002.002,-1)
0^43
"KRN",.84,7981002.002,0)
7981002.002^2^^CLINICAL CASE REGISTRIES^Current Inpatient List (CSV)
"KRN",.84,7981002.002,2,0)
^^27^27^3031212^
"KRN",.84,7981002.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981002.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981002.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981002.002,2,4,0)
>
"KRN",.84,7981002.002,2,5,0)
 
"KRN",.84,7981002.002,2,6,0)
<xsl:import href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981002.002,2,7,0)
 
"KRN",.84,7981002.002,2,8,0)
<xsl:template match="/">
"KRN",.84,7981002.002,2,9,0)
 <xsl:text>Current Inpatient List</xsl:text>
"KRN",.84,7981002.002,2,10,0)
 <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981002.002,2,11,0)
</xsl:template>
"KRN",.84,7981002.002,2,12,0)
 
"KRN",.84,7981002.002,2,13,0)
<!--[ COLUMN HEADERS ]--> 
"KRN",.84,7981002.002,2,14,0)
 
"KRN",.84,7981002.002,2,15,0)
<xsl:template match="COLUMN[@NAME='ROOM-BED']">
"KRN",.84,7981002.002,2,16,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981002.002,2,17,0)
  <xsl:with-param name="title" select="'Room-Bed'"/>
"KRN",.84,7981002.002,2,18,0)
 </xsl:call-template>
"KRN",.84,7981002.002,2,19,0)
</xsl:template>
"KRN",.84,7981002.002,2,20,0)
 
"KRN",.84,7981002.002,2,21,0)
<xsl:template match="COLUMN[@NAME='WARD']">
"KRN",.84,7981002.002,2,22,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981002.002,2,23,0)
  <xsl:with-param name="title" select="'Ward'"/>
"KRN",.84,7981002.002,2,24,0)
 </xsl:call-template>
"KRN",.84,7981002.002,2,25,0)
</xsl:template>
"KRN",.84,7981002.002,2,26,0)
 
"KRN",.84,7981002.002,2,27,0)
</xsl:stylesheet>
"KRN",.84,7981003.001,-1)
0^21
"KRN",.84,7981003.001,0)
7981003.001^2^^CLINICAL CASE REGISTRIES^General Utiliz. and Demogr. (HTML)
"KRN",.84,7981003.001,2,0)
^.844^211^211^3040112^^
"KRN",.84,7981003.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981003.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981003.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981003.001,2,4,0)
>
"KRN",.84,7981003.001,2,5,0)
 
"KRN",.84,7981003.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   --> 
"KRN",.84,7981003.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981003.001,2,8,0)
<xsl:include href="template://report/997/1"/>  <!-- Patients -->            
"KRN",.84,7981003.001,2,9,0)
 
"KRN",.84,7981003.001,2,10,0)
<xsl:template match="/">
"KRN",.84,7981003.001,2,11,0)
 <xsl:variable name="sum" select="/REPORT/SUMMARY"/>
"KRN",.84,7981003.001,2,12,0)
 <xsl:variable name="wide_summaries" 
"KRN",.84,7981003.001,2,13,0)
      select="$sum/RISK_FACTORS|$sum/RACE_SUMMARY|$sum/UTIL_CODES"/>
"KRN",.84,7981003.001,2,14,0)
 <xsl:variable name="narrow_summaries"
"KRN",.84,7981003.001,2,15,0)
      select="$sum/SEX_SUMMARY|$sum/REIMBLVL_SUMMARY|$sum/AGE_SUMMARY"/>
"KRN",.84,7981003.001,2,16,0)
 <html>
"KRN",.84,7981003.001,2,17,0)
  <head>
"KRN",.84,7981003.001,2,18,0)
   <title>General Utilization and Demographics</title>
"KRN",.84,7981003.001,2,19,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981003.001,2,20,0)
  </head>
"KRN",.84,7981003.001,2,21,0)
  <body>
"KRN",.84,7981003.001,2,22,0)
   <h1>General Utilization and Demographics</h1>
"KRN",.84,7981003.001,2,23,0)
   <xsl:call-template name="ReportHeader"/>
"KRN",.84,7981003.001,2,24,0)
   <xsl:if test="/REPORT/PATIENTS/*[1]">
"KRN",.84,7981003.001,2,25,0)
    <div style="page-break-before:always">
"KRN",.84,7981003.001,2,26,0)
     <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981003.001,2,27,0)
    </div>
"KRN",.84,7981003.001,2,28,0)
   </xsl:if>
"KRN",.84,7981003.001,2,29,0)
   <xsl:if test="$sum/*[1]">
"KRN",.84,7981003.001,2,30,0)
    <div class="reportSummary">
"KRN",.84,7981003.001,2,31,0)
     <xsl:if test="$wide_summaries">
"KRN",.84,7981003.001,2,32,0)
      <div style="float:left; width:68%; margin-right:1%">
"KRN",.84,7981003.001,2,33,0)
       <xsl:apply-templates select="$wide_summaries"/>
"KRN",.84,7981003.001,2,34,0)
      </div>
"KRN",.84,7981003.001,2,35,0)
     </xsl:if>
"KRN",.84,7981003.001,2,36,0)
     <xsl:if test="$narrow_summaries">
"KRN",.84,7981003.001,2,37,0)
      <div style="float:left; width:30%">
"KRN",.84,7981003.001,2,38,0)
       <xsl:apply-templates select="$narrow_summaries"/>
"KRN",.84,7981003.001,2,39,0)
      </div>
"KRN",.84,7981003.001,2,40,0)
     </xsl:if>
"KRN",.84,7981003.001,2,41,0)
    </div>
"KRN",.84,7981003.001,2,42,0)
   </xsl:if>
"KRN",.84,7981003.001,2,43,0)
  </body>
"KRN",.84,7981003.001,2,44,0)
 </html>
"KRN",.84,7981003.001,2,45,0)
</xsl:template>
"KRN",.84,7981003.001,2,46,0)
 
"KRN",.84,7981003.001,2,47,0)
<!--[ UTILITIES ]-->
"KRN",.84,7981003.001,2,48,0)
 
"KRN",.84,7981003.001,2,49,0)
<xsl:template name="SummaryLine">
"KRN",.84,7981003.001,2,50,0)
 <xsl:param name="line" select="."/>
"KRN",.84,7981003.001,2,51,0)
 <td class="aLeft"><xsl:value-of select="$line"/></td>
"KRN",.84,7981003.001,2,52,0)
 <td>
"KRN",.84,7981003.001,2,53,0)
  <xsl:value-of select="$line/@COUNT"/>
"KRN",.84,7981003.001,2,54,0)
  <xsl:if test="$line/@COUNT=''">&#160;</xsl:if>
"KRN",.84,7981003.001,2,55,0)
 </td>
"KRN",.84,7981003.001,2,56,0)
</xsl:template>
"KRN",.84,7981003.001,2,57,0)
 
"KRN",.84,7981003.001,2,58,0)
<!--[ COLUMN HEADERS ]-->
"KRN",.84,7981003.001,2,59,0)
 
"KRN",.84,7981003.001,2,60,0)
<xsl:template match="COLUMN[@NAME='REIMBLVL']">
"KRN",.84,7981003.001,2,61,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981003.001,2,62,0)
  <xsl:with-param name="title" select="'Reimbursement Level'"/>
"KRN",.84,7981003.001,2,63,0)
  <xsl:with-param name="width" select="'5%'"/>
"KRN",.84,7981003.001,2,64,0)
 </xsl:call-template>
"KRN",.84,7981003.001,2,65,0)
</xsl:template>
"KRN",.84,7981003.001,2,66,0)
 
"KRN",.84,7981003.001,2,67,0)
<xsl:template match="COLUMN[@NAME='RISK']">
"KRN",.84,7981003.001,2,68,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981003.001,2,69,0)
  <xsl:with-param name="title" select="'Risk Factors'"/>
"KRN",.84,7981003.001,2,70,0)
  <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981003.001,2,71,0)
 </xsl:call-template>
"KRN",.84,7981003.001,2,72,0)
</xsl:template>
"KRN",.84,7981003.001,2,73,0)
 
"KRN",.84,7981003.001,2,74,0)
<xsl:template match="COLUMN[@NAME='UTIL']">
"KRN",.84,7981003.001,2,75,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981003.001,2,76,0)
  <xsl:with-param name="title" select="'Utilization'"/>
"KRN",.84,7981003.001,2,77,0)
  <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981003.001,2,78,0)
 </xsl:call-template>
"KRN",.84,7981003.001,2,79,0)
</xsl:template>
"KRN",.84,7981003.001,2,80,0)
 
"KRN",.84,7981003.001,2,81,0)
<!--[ SUMMARY TABLES ]--> 
"KRN",.84,7981003.001,2,82,0)
 
"KRN",.84,7981003.001,2,83,0)
<xsl:template match="SUMMARY/AGE_SUMMARY">
"KRN",.84,7981003.001,2,84,0)
 <xsl:param name="summary" select="."/>
"KRN",.84,7981003.001,2,85,0)
 <xsl:if test="$summary/*[1]">
"KRN",.84,7981003.001,2,86,0)
  <table cellpadding="3" cellspacing="0">
"KRN",.84,7981003.001,2,87,0)
   <caption>Age Summary</caption>
"KRN",.84,7981003.001,2,88,0)
   <thead>
"KRN",.84,7981003.001,2,89,0)
    <tr>
"KRN",.84,7981003.001,2,90,0)
     <th>Age</th>
"KRN",.84,7981003.001,2,91,0)
     <th width="30">Count<br/>(Value)</th>
"KRN",.84,7981003.001,2,92,0)
    </tr>
"KRN",.84,7981003.001,2,93,0)
   </thead>
"KRN",.84,7981003.001,2,94,0)
   <tbody>
"KRN",.84,7981003.001,2,95,0)
    <xsl:for-each select="$summary/AGE">
"KRN",.84,7981003.001,2,96,0)
     <tr><xsl:call-template name="SummaryLine"/></tr>
"KRN",.84,7981003.001,2,97,0)
    </xsl:for-each>
"KRN",.84,7981003.001,2,98,0)
   </tbody>
"KRN",.84,7981003.001,2,99,0)
  </table>
"KRN",.84,7981003.001,2,100,0)
 </xsl:if>
"KRN",.84,7981003.001,2,101,0)
</xsl:template>
"KRN",.84,7981003.001,2,102,0)
 
"KRN",.84,7981003.001,2,103,0)
<xsl:template match="SUMMARY/RACE_SUMMARY">
"KRN",.84,7981003.001,2,104,0)
 <xsl:param name="summary" select="."/>
"KRN",.84,7981003.001,2,105,0)
 <xsl:if test="$summary/*[1]">
"KRN",.84,7981003.001,2,106,0)
  <table cellpadding="3" cellspacing="0">
"KRN",.84,7981003.001,2,107,0)
   <caption>Race Summary</caption>
"KRN",.84,7981003.001,2,108,0)
   <thead>
"KRN",.84,7981003.001,2,109,0)
    <tr>
"KRN",.84,7981003.001,2,110,0)
     <th>Race</th>
"KRN",.84,7981003.001,2,111,0)
     <th width="30">Count</th>
"KRN",.84,7981003.001,2,112,0)
    </tr>
"KRN",.84,7981003.001,2,113,0)
   </thead>
"KRN",.84,7981003.001,2,114,0)
   <tbody>
"KRN",.84,7981003.001,2,115,0)
    <xsl:for-each select="$summary/RACE">
"KRN",.84,7981003.001,2,116,0)
     <tr><xsl:call-template name="SummaryLine"/></tr>
"KRN",.84,7981003.001,2,117,0)
    </xsl:for-each>
"KRN",.84,7981003.001,2,118,0)
   </tbody>
"KRN",.84,7981003.001,2,119,0)
  </table>
"KRN",.84,7981003.001,2,120,0)
 </xsl:if>
"KRN",.84,7981003.001,2,121,0)
</xsl:template>
"KRN",.84,7981003.001,2,122,0)
 
"KRN",.84,7981003.001,2,123,0)
<xsl:template match="SUMMARY/REIMBLVL_SUMMARY">
"KRN",.84,7981003.001,2,124,0)
 <xsl:param name="summary" select="."/>
"KRN",.84,7981003.001,2,125,0)
 <xsl:if test="$summary/*[1]">
"KRN",.84,7981003.001,2,126,0)
  <table cellpadding="3" cellspacing="0">
"KRN",.84,7981003.001,2,127,0)
   <caption>Reimbursement Level Summary</caption>
"KRN",.84,7981003.001,2,128,0)
   <thead>
"KRN",.84,7981003.001,2,129,0)
    <tr>
"KRN",.84,7981003.001,2,130,0)
     <th>Level</th>
"KRN",.84,7981003.001,2,131,0)
     <th width="30">Count</th>
"KRN",.84,7981003.001,2,132,0)
    </tr>
"KRN",.84,7981003.001,2,133,0)
   </thead>
"KRN",.84,7981003.001,2,134,0)
   <tbody>
"KRN",.84,7981003.001,2,135,0)
    <xsl:for-each select="$summary/REIMBLVL">
"KRN",.84,7981003.001,2,136,0)
     <tr><xsl:call-template name="SummaryLine"/></tr>
"KRN",.84,7981003.001,2,137,0)
    </xsl:for-each>
"KRN",.84,7981003.001,2,138,0)
   </tbody>
"KRN",.84,7981003.001,2,139,0)
  </table>
"KRN",.84,7981003.001,2,140,0)
 </xsl:if>
"KRN",.84,7981003.001,2,141,0)
</xsl:template>
"KRN",.84,7981003.001,2,142,0)
 
"KRN",.84,7981003.001,2,143,0)
<xsl:template match="SUMMARY/RISK_FACTORS">
"KRN",.84,7981003.001,2,144,0)
 <xsl:param name="summary" select="."/>
"KRN",.84,7981003.001,2,145,0)
 <xsl:if test="$summary/*[1]">
"KRN",.84,7981003.001,2,146,0)
  <table cellpadding="3" cellspacing="0">
"KRN",.84,7981003.001,2,147,0)
   <caption>Risk Factors</caption>
"KRN",.84,7981003.001,2,148,0)
   <thead>
"KRN",.84,7981003.001,2,149,0)
    <tr>
"KRN",.84,7981003.001,2,150,0)
     <th width="30">Code</th>
"KRN",.84,7981003.001,2,151,0)
     <th>Description</th>
"KRN",.84,7981003.001,2,152,0)
     <th width="30">Count</th>
"KRN",.84,7981003.001,2,153,0)
    </tr>
"KRN",.84,7981003.001,2,154,0)
   </thead>
"KRN",.84,7981003.001,2,155,0)
   <tbody>
"KRN",.84,7981003.001,2,156,0)
    <xsl:for-each select="$summary/RISK">
"KRN",.84,7981003.001,2,157,0)
     <tr>
"KRN",.84,7981003.001,2,158,0)
      <td align="center"><xsl:value-of select="@ID"/></td>
"KRN",.84,7981003.001,2,159,0)
      <xsl:call-template name="SummaryLine"/>
"KRN",.84,7981003.001,2,160,0)
     </tr>
"KRN",.84,7981003.001,2,161,0)
    </xsl:for-each>
"KRN",.84,7981003.001,2,162,0)
   </tbody>
"KRN",.84,7981003.001,2,163,0)
  </table>
"KRN",.84,7981003.001,2,164,0)
 </xsl:if>
"KRN",.84,7981003.001,2,165,0)
</xsl:template>
"KRN",.84,7981003.001,2,166,0)
 
"KRN",.84,7981003.001,2,167,0)
<xsl:template match="SUMMARY/SEX_SUMMARY">
"KRN",.84,7981003.001,2,168,0)
 <xsl:param name="summary" select="."/>
"KRN",.84,7981003.001,2,169,0)
 <xsl:if test="$summary/*[1]">
"KRN",.84,7981003.001,2,170,0)
  <table cellpadding="3" cellspacing="0">
"KRN",.84,7981003.001,2,171,0)
   <caption>Sex Summary</caption>
"KRN",.84,7981003.001,2,172,0)
   <thead>
"KRN",.84,7981003.001,2,173,0)
    <tr>
"KRN",.84,7981003.001,2,174,0)
     <th>Sex</th>
"KRN",.84,7981003.001,2,175,0)
     <th width="30">Count</th>
"KRN",.84,7981003.001,2,176,0)
    </tr>
"KRN",.84,7981003.001,2,177,0)
   </thead>
"KRN",.84,7981003.001,2,178,0)
   <tbody>
"KRN",.84,7981003.001,2,179,0)
    <xsl:for-each select="$summary/SEX">
"KRN",.84,7981003.001,2,180,0)
     <tr><xsl:call-template name="SummaryLine"/></tr>
"KRN",.84,7981003.001,2,181,0)
    </xsl:for-each>
"KRN",.84,7981003.001,2,182,0)
   </tbody>
"KRN",.84,7981003.001,2,183,0)
  </table>
"KRN",.84,7981003.001,2,184,0)
 </xsl:if>
"KRN",.84,7981003.001,2,185,0)
</xsl:template>
"KRN",.84,7981003.001,2,186,0)
 
"KRN",.84,7981003.001,2,187,0)
<xsl:template match="SUMMARY/UTIL_CODES">
"KRN",.84,7981003.001,2,188,0)
 <xsl:param name="summary" select="."/>
"KRN",.84,7981003.001,2,189,0)
 <xsl:if test="$summary/*[1]">
"KRN",.84,7981003.001,2,190,0)
  <table cellpadding="3" cellspacing="0">
"KRN",.84,7981003.001,2,191,0)
   <caption>Utilization</caption>
"KRN",.84,7981003.001,2,192,0)
   <thead>
"KRN",.84,7981003.001,2,193,0)
    <tr>
"KRN",.84,7981003.001,2,194,0)
     <th width="30">Code</th>
"KRN",.84,7981003.001,2,195,0)
     <th>Description</th>
"KRN",.84,7981003.001,2,196,0)
     <th width="30">Count</th>
"KRN",.84,7981003.001,2,197,0)
    </tr>
"KRN",.84,7981003.001,2,198,0)
   </thead>
"KRN",.84,7981003.001,2,199,0)
   <tbody>
"KRN",.84,7981003.001,2,200,0)
    <xsl:for-each select="$summary/UTIL">
"KRN",.84,7981003.001,2,201,0)
     <tr>
"KRN",.84,7981003.001,2,202,0)
      <td align="center"><xsl:value-of select="@ID"/></td>
"KRN",.84,7981003.001,2,203,0)
      <xsl:call-template name="SummaryLine"/>
"KRN",.84,7981003.001,2,204,0)
     </tr>
"KRN",.84,7981003.001,2,205,0)
    </xsl:for-each>
"KRN",.84,7981003.001,2,206,0)
   </tbody>
"KRN",.84,7981003.001,2,207,0)
  </table>
"KRN",.84,7981003.001,2,208,0)
 </xsl:if>
"KRN",.84,7981003.001,2,209,0)
</xsl:template>
"KRN",.84,7981003.001,2,210,0)
 
"KRN",.84,7981003.001,2,211,0)
</xsl:stylesheet>
"KRN",.84,7981003.002,-1)
0^44
"KRN",.84,7981003.002,0)
7981003.002^2^^CLINICAL CASE REGISTRIES^General Utiliz. and Demogr. (CSV)
"KRN",.84,7981003.002,2,0)
^^135^135^3031212^
"KRN",.84,7981003.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981003.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981003.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981003.002,2,4,0)
>
"KRN",.84,7981003.002,2,5,0)
 
"KRN",.84,7981003.002,2,6,0)
<xsl:import  href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981003.002,2,7,0)
<xsl:include href="template://report/997/2"/>  <!-- Patients -->
"KRN",.84,7981003.002,2,8,0)
 
"KRN",.84,7981003.002,2,9,0)
<xsl:template match="/">
"KRN",.84,7981003.002,2,10,0)
 <xsl:text>General Utilization and Demographics (Patients)</xsl:text>
"KRN",.84,7981003.002,2,11,0)
 <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981003.002,2,12,0)
 <xsl:value-of select="$FILESWITCH"/>
"KRN",.84,7981003.002,2,13,0)
 <xsl:text>General Utilization and Demographics (Summary)</xsl:text>
"KRN",.84,7981003.002,2,14,0)
 <xsl:call-template name="ReportSummary"/>
"KRN",.84,7981003.002,2,15,0)
</xsl:template>
"KRN",.84,7981003.002,2,16,0)
 
"KRN",.84,7981003.002,2,17,0)
<!--[ UTILITIES ]-->
"KRN",.84,7981003.002,2,18,0)
 
"KRN",.84,7981003.002,2,19,0)
<xsl:template name="SummaryLine">
"KRN",.84,7981003.002,2,20,0)
 <xsl:param name="line" select="."/>
"KRN",.84,7981003.002,2,21,0)
 <xsl:value-of select="$line/@ID"/>
"KRN",.84,7981003.002,2,22,0)
 <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981003.002,2,23,0)
 <xsl:value-of select="$line"/>
"KRN",.84,7981003.002,2,24,0)
 <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981003.002,2,25,0)
 <xsl:value-of select="$line/@COUNT"/>
"KRN",.84,7981003.002,2,26,0)
 <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,27,0)
</xsl:template>
"KRN",.84,7981003.002,2,28,0)
 
"KRN",.84,7981003.002,2,29,0)
<!--[ COLUMN HEADERS ]-->
"KRN",.84,7981003.002,2,30,0)
 
"KRN",.84,7981003.002,2,31,0)
<xsl:template match="COLUMN[@NAME='REIMBLVL']">
"KRN",.84,7981003.002,2,32,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981003.002,2,33,0)
  <xsl:with-param name="title" select="'Reimbursement Level'"/>
"KRN",.84,7981003.002,2,34,0)
 </xsl:call-template>
"KRN",.84,7981003.002,2,35,0)
</xsl:template>
"KRN",.84,7981003.002,2,36,0)
 
"KRN",.84,7981003.002,2,37,0)
<xsl:template match="COLUMN[@NAME='RISK']">
"KRN",.84,7981003.002,2,38,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981003.002,2,39,0)
  <xsl:with-param name="title" select="'Risk Factors'"/>
"KRN",.84,7981003.002,2,40,0)
 </xsl:call-template>
"KRN",.84,7981003.002,2,41,0)
</xsl:template>
"KRN",.84,7981003.002,2,42,0)
 
"KRN",.84,7981003.002,2,43,0)
<xsl:template match="COLUMN[@NAME='UTIL']">
"KRN",.84,7981003.002,2,44,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981003.002,2,45,0)
  <xsl:with-param name="title" select="'Utilization'"/>
"KRN",.84,7981003.002,2,46,0)
 </xsl:call-template>
"KRN",.84,7981003.002,2,47,0)
</xsl:template>
"KRN",.84,7981003.002,2,48,0)
 
"KRN",.84,7981003.002,2,49,0)
<!--[ SUMMARY TABLES ]--> 
"KRN",.84,7981003.002,2,50,0)
 
"KRN",.84,7981003.002,2,51,0)
<xsl:template match="SUMMARY/AGE_SUMMARY">
"KRN",.84,7981003.002,2,52,0)
 <xsl:param name="summary" select="."/>
"KRN",.84,7981003.002,2,53,0)
 <xsl:if test="$summary/*[1]">
"KRN",.84,7981003.002,2,54,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,55,0)
  <xsl:text>[Age Summary]</xsl:text>
"KRN",.84,7981003.002,2,56,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,57,0)
  <xsl:text>,Age,Count (Value)</xsl:text>
"KRN",.84,7981003.002,2,58,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,59,0)
  <xsl:for-each select="$summary/AGE">
"KRN",.84,7981003.002,2,60,0)
   <xsl:call-template name="SummaryLine"/>
"KRN",.84,7981003.002,2,61,0)
  </xsl:for-each>
"KRN",.84,7981003.002,2,62,0)
 </xsl:if>
"KRN",.84,7981003.002,2,63,0)
</xsl:template>
"KRN",.84,7981003.002,2,64,0)
 
"KRN",.84,7981003.002,2,65,0)
<xsl:template match="SUMMARY/RACE_SUMMARY">
"KRN",.84,7981003.002,2,66,0)
 <xsl:param name="summary" select="."/>
"KRN",.84,7981003.002,2,67,0)
 <xsl:if test="$summary/*[1]">
"KRN",.84,7981003.002,2,68,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,69,0)
  <xsl:text>[Race Summary]</xsl:text>
"KRN",.84,7981003.002,2,70,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,71,0)
  <xsl:text>,Race,Count</xsl:text>
"KRN",.84,7981003.002,2,72,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,73,0)
  <xsl:for-each select="$summary/RACE">
"KRN",.84,7981003.002,2,74,0)
   <xsl:call-template name="SummaryLine"/>
"KRN",.84,7981003.002,2,75,0)
  </xsl:for-each>
"KRN",.84,7981003.002,2,76,0)
 </xsl:if>
"KRN",.84,7981003.002,2,77,0)
</xsl:template>
"KRN",.84,7981003.002,2,78,0)
 
"KRN",.84,7981003.002,2,79,0)
<xsl:template match="SUMMARY/REIMBLVL_SUMMARY">
"KRN",.84,7981003.002,2,80,0)
 <xsl:param name="summary" select="."/>
"KRN",.84,7981003.002,2,81,0)
 <xsl:if test="$summary/*[1]">
"KRN",.84,7981003.002,2,82,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,83,0)
  <xsl:text>[Reimbursement Level Summary]</xsl:text>
"KRN",.84,7981003.002,2,84,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,85,0)
  <xsl:text>,Level,Count</xsl:text>
"KRN",.84,7981003.002,2,86,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,87,0)
  <xsl:for-each select="$summary/REIMBLVL">
"KRN",.84,7981003.002,2,88,0)
   <xsl:call-template name="SummaryLine"/>
"KRN",.84,7981003.002,2,89,0)
  </xsl:for-each>
"KRN",.84,7981003.002,2,90,0)
 </xsl:if>
"KRN",.84,7981003.002,2,91,0)
</xsl:template>
"KRN",.84,7981003.002,2,92,0)
 
"KRN",.84,7981003.002,2,93,0)
<xsl:template match="SUMMARY/RISK_FACTORS">
"KRN",.84,7981003.002,2,94,0)
 <xsl:param name="summary" select="."/>
"KRN",.84,7981003.002,2,95,0)
 <xsl:if test="$summary/*[1]">
"KRN",.84,7981003.002,2,96,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,97,0)
  <xsl:text>[Risk Factors]</xsl:text>
"KRN",.84,7981003.002,2,98,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,99,0)
  <xsl:text>Code,Description,Count</xsl:text>
"KRN",.84,7981003.002,2,100,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,101,0)
  <xsl:for-each select="$summary/RISK">
"KRN",.84,7981003.002,2,102,0)
   <xsl:call-template name="SummaryLine"/>
"KRN",.84,7981003.002,2,103,0)
  </xsl:for-each>
"KRN",.84,7981003.002,2,104,0)
 </xsl:if>
"KRN",.84,7981003.002,2,105,0)
</xsl:template>
"KRN",.84,7981003.002,2,106,0)
 
"KRN",.84,7981003.002,2,107,0)
<xsl:template match="SUMMARY/SEX_SUMMARY">
"KRN",.84,7981003.002,2,108,0)
 <xsl:param name="summary" select="."/>
"KRN",.84,7981003.002,2,109,0)
 <xsl:if test="$summary/*[1]">
"KRN",.84,7981003.002,2,110,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,111,0)
  <xsl:text>[Sex Summary]</xsl:text>
"KRN",.84,7981003.002,2,112,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,113,0)
  <xsl:text>,Sex,Count</xsl:text>
"KRN",.84,7981003.002,2,114,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,115,0)
  <xsl:for-each select="$summary/SEX">
"KRN",.84,7981003.002,2,116,0)
   <xsl:call-template name="SummaryLine"/>
"KRN",.84,7981003.002,2,117,0)
  </xsl:for-each>
"KRN",.84,7981003.002,2,118,0)
 </xsl:if>
"KRN",.84,7981003.002,2,119,0)
</xsl:template>
"KRN",.84,7981003.002,2,120,0)
 
"KRN",.84,7981003.002,2,121,0)
<xsl:template match="SUMMARY/UTIL_CODES">
"KRN",.84,7981003.002,2,122,0)
 <xsl:param name="summary" select="."/>
"KRN",.84,7981003.002,2,123,0)
 <xsl:if test="$summary/*[1]">
"KRN",.84,7981003.002,2,124,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,125,0)
  <xsl:text>[Utilization]</xsl:text>
"KRN",.84,7981003.002,2,126,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,127,0)
  <xsl:text>Code,Description,Count</xsl:text>
"KRN",.84,7981003.002,2,128,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981003.002,2,129,0)
  <xsl:for-each select="$summary/UTIL">
"KRN",.84,7981003.002,2,130,0)
   <xsl:call-template name="SummaryLine"/>
"KRN",.84,7981003.002,2,131,0)
  </xsl:for-each>
"KRN",.84,7981003.002,2,132,0)
 </xsl:if>
"KRN",.84,7981003.002,2,133,0)
</xsl:template>
"KRN",.84,7981003.002,2,134,0)
 
"KRN",.84,7981003.002,2,135,0)
</xsl:stylesheet>
"KRN",.84,7981004.001,-1)
0^23
"KRN",.84,7981004.001,0)
7981004.001^2^^CLINICAL CASE REGISTRIES^Clinic Follow Up (HTML)
"KRN",.84,7981004.001,2,0)
^^89^89^3031212^
"KRN",.84,7981004.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981004.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981004.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981004.001,2,4,0)
>
"KRN",.84,7981004.001,2,5,0)
 
"KRN",.84,7981004.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   --> 
"KRN",.84,7981004.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981004.001,2,8,0)
 
"KRN",.84,7981004.001,2,9,0)
<xsl:template match="/">
"KRN",.84,7981004.001,2,10,0)
 <html>
"KRN",.84,7981004.001,2,11,0)
  <head>
"KRN",.84,7981004.001,2,12,0)
   <title>Clinic Follow Up</title>
"KRN",.84,7981004.001,2,13,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981004.001,2,14,0)
  </head>
"KRN",.84,7981004.001,2,15,0)
  <body>
"KRN",.84,7981004.001,2,16,0)
   <h1>Clinic Follow Up</h1>
"KRN",.84,7981004.001,2,17,0)
   <xsl:call-template name="ReportHeader"/>
"KRN",.84,7981004.001,2,18,0)
   <div style="page-break-before:always">
"KRN",.84,7981004.001,2,19,0)
    <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981004.001,2,20,0)
   </div>
"KRN",.84,7981004.001,2,21,0)
   <xsl:call-template name="ReportSummary"/>
"KRN",.84,7981004.001,2,22,0)
  </body>
"KRN",.84,7981004.001,2,23,0)
 </html>
"KRN",.84,7981004.001,2,24,0)
</xsl:template>
"KRN",.84,7981004.001,2,25,0)
 
"KRN",.84,7981004.001,2,26,0)
<!--[ UTILITIES ]-->
"KRN",.84,7981004.001,2,27,0)
 
"KRN",.84,7981004.001,2,28,0)
<xsl:template name="SummaryLine">
"KRN",.84,7981004.001,2,29,0)
 <xsl:param name="line" select="."/>
"KRN",.84,7981004.001,2,30,0)
 <td class="aLeft"><xsl:value-of select="$line"/></td>
"KRN",.84,7981004.001,2,31,0)
 <td>
"KRN",.84,7981004.001,2,32,0)
  <xsl:value-of select="$line/@COUNT"/>
"KRN",.84,7981004.001,2,33,0)
  <xsl:if test="$line/@COUNT=''">&#160;</xsl:if>
"KRN",.84,7981004.001,2,34,0)
 </td>
"KRN",.84,7981004.001,2,35,0)
</xsl:template>
"KRN",.84,7981004.001,2,36,0)
 
"KRN",.84,7981004.001,2,37,0)
<!--[ COLUMN HEADERS ]-->
"KRN",.84,7981004.001,2,38,0)
 
"KRN",.84,7981004.001,2,39,0)
<xsl:template match="COLUMN[@NAME='LSNDT']">
"KRN",.84,7981004.001,2,40,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981004.001,2,41,0)
  <xsl:with-param name="title" select="'Last Seen Date'"/>
"KRN",.84,7981004.001,2,42,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981004.001,2,43,0)
 </xsl:call-template>
"KRN",.84,7981004.001,2,44,0)
</xsl:template>
"KRN",.84,7981004.001,2,45,0)
 
"KRN",.84,7981004.001,2,46,0)
<xsl:template match="COLUMN[@NAME='SEEN']">
"KRN",.84,7981004.001,2,47,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981004.001,2,48,0)
  <xsl:with-param name="title" select="'Seen'"/>
"KRN",.84,7981004.001,2,49,0)
  <xsl:with-param name="width" select="'5%'"/>
"KRN",.84,7981004.001,2,50,0)
 </xsl:call-template>
"KRN",.84,7981004.001,2,51,0)
</xsl:template>
"KRN",.84,7981004.001,2,52,0)
 
"KRN",.84,7981004.001,2,53,0)
<!--[ CELL VALUES ]-->
"KRN",.84,7981004.001,2,54,0)
 
"KRN",.84,7981004.001,2,55,0)
<xsl:template match="PATIENT/LSNDT">
"KRN",.84,7981004.001,2,56,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981004.001,2,57,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981004.001,2,58,0)
 </xsl:call-template>
"KRN",.84,7981004.001,2,59,0)
</xsl:template>
"KRN",.84,7981004.001,2,60,0)
 
"KRN",.84,7981004.001,2,61,0)
<xsl:template match="PATIENT/SEEN">
"KRN",.84,7981004.001,2,62,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981004.001,2,63,0)
  <xsl:with-param name="yesno" select="1"/>
"KRN",.84,7981004.001,2,64,0)
 </xsl:call-template>
"KRN",.84,7981004.001,2,65,0)
</xsl:template>
"KRN",.84,7981004.001,2,66,0)
 
"KRN",.84,7981004.001,2,67,0)
<!--[ SUMMARY TABLES ]-->
"KRN",.84,7981004.001,2,68,0)
 
"KRN",.84,7981004.001,2,69,0)
<xsl:template match="SUMMARY/PATIENT_SUMMARY">
"KRN",.84,7981004.001,2,70,0)
 <xsl:param name="summary" select="."/>
"KRN",.84,7981004.001,2,71,0)
 <xsl:if test="$summary/*[1]">
"KRN",.84,7981004.001,2,72,0)
  <table width="30%" cellpadding="3" cellspacing="0">
"KRN",.84,7981004.001,2,73,0)
   <caption>Summary</caption>
"KRN",.84,7981004.001,2,74,0)
   <thead>
"KRN",.84,7981004.001,2,75,0)
    <tr>
"KRN",.84,7981004.001,2,76,0)
     <th>Item</th>
"KRN",.84,7981004.001,2,77,0)
     <th width="30">Count</th>
"KRN",.84,7981004.001,2,78,0)
    </tr>
"KRN",.84,7981004.001,2,79,0)
   </thead>
"KRN",.84,7981004.001,2,80,0)
   <tbody>
"KRN",.84,7981004.001,2,81,0)
    <xsl:for-each select="$summary/*">
"KRN",.84,7981004.001,2,82,0)
     <tr><xsl:call-template name="SummaryLine"/></tr>
"KRN",.84,7981004.001,2,83,0)
    </xsl:for-each>
"KRN",.84,7981004.001,2,84,0)
   </tbody>
"KRN",.84,7981004.001,2,85,0)
  </table>
"KRN",.84,7981004.001,2,86,0)
 </xsl:if>
"KRN",.84,7981004.001,2,87,0)
</xsl:template>
"KRN",.84,7981004.001,2,88,0)
 
"KRN",.84,7981004.001,2,89,0)
</xsl:stylesheet>
"KRN",.84,7981004.002,-1)
0^45
"KRN",.84,7981004.002,0)
7981004.002^2^^CLINICAL CASE REGISTRIES^Clinic Follow Up (CSV)
"KRN",.84,7981004.002,2,0)
^^41^41^3031212^
"KRN",.84,7981004.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981004.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981004.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981004.002,2,4,0)
>
"KRN",.84,7981004.002,2,5,0)
 
"KRN",.84,7981004.002,2,6,0)
<xsl:import href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981004.002,2,7,0)
 
"KRN",.84,7981004.002,2,8,0)
<xsl:template match="/">
"KRN",.84,7981004.002,2,9,0)
 <xsl:text>Clinic Follow Up</xsl:text>
"KRN",.84,7981004.002,2,10,0)
 <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981004.002,2,11,0)
</xsl:template>
"KRN",.84,7981004.002,2,12,0)
 
"KRN",.84,7981004.002,2,13,0)
<!--[ COLUMN HEADERS ]-->
"KRN",.84,7981004.002,2,14,0)
 
"KRN",.84,7981004.002,2,15,0)
<xsl:template match="COLUMN[@NAME='LSNDT']">
"KRN",.84,7981004.002,2,16,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981004.002,2,17,0)
  <xsl:with-param name="title" select="'Last Seen Date'"/>
"KRN",.84,7981004.002,2,18,0)
 </xsl:call-template>
"KRN",.84,7981004.002,2,19,0)
</xsl:template>
"KRN",.84,7981004.002,2,20,0)
 
"KRN",.84,7981004.002,2,21,0)
<xsl:template match="COLUMN[@NAME='SEEN']">
"KRN",.84,7981004.002,2,22,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981004.002,2,23,0)
  <xsl:with-param name="title" select="'Seen'"/>
"KRN",.84,7981004.002,2,24,0)
 </xsl:call-template>
"KRN",.84,7981004.002,2,25,0)
</xsl:template>
"KRN",.84,7981004.002,2,26,0)
 
"KRN",.84,7981004.002,2,27,0)
<!--[ CELL VALUES ]-->
"KRN",.84,7981004.002,2,28,0)
 
"KRN",.84,7981004.002,2,29,0)
<xsl:template match="PATIENT/LSNDT">
"KRN",.84,7981004.002,2,30,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981004.002,2,31,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981004.002,2,32,0)
 </xsl:call-template>
"KRN",.84,7981004.002,2,33,0)
</xsl:template>
"KRN",.84,7981004.002,2,34,0)
 
"KRN",.84,7981004.002,2,35,0)
<xsl:template match="PATIENT/SEEN">
"KRN",.84,7981004.002,2,36,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981004.002,2,37,0)
  <xsl:with-param name="yesno" select="1"/>
"KRN",.84,7981004.002,2,38,0)
 </xsl:call-template>
"KRN",.84,7981004.002,2,39,0)
</xsl:template>
"KRN",.84,7981004.002,2,40,0)
 
"KRN",.84,7981004.002,2,41,0)
</xsl:stylesheet>
"KRN",.84,7981005.001,-1)
0^30
"KRN",.84,7981005.001,0)
7981005.001^2^^CLINICAL CASE REGISTRIES^Inpatient & Outpatient Utilization (HTML)
"KRN",.84,7981005.001,2,0)
^^299^299^3040210^
"KRN",.84,7981005.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981005.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981005.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981005.001,2,4,0)
>
"KRN",.84,7981005.001,2,5,0)
 
"KRN",.84,7981005.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   --> 
"KRN",.84,7981005.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981005.001,2,8,0)
 
"KRN",.84,7981005.001,2,9,0)
<xsl:template match="/">
"KRN",.84,7981005.001,2,10,0)
 <html>
"KRN",.84,7981005.001,2,11,0)
  <head>
"KRN",.84,7981005.001,2,12,0)
   <title>Inpatient and Outpatient Utilization</title>
"KRN",.84,7981005.001,2,13,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981005.001,2,14,0)
  </head>
"KRN",.84,7981005.001,2,15,0)
  <body>
"KRN",.84,7981005.001,2,16,0)
   <h1>Inpatient and Outpatient Utilization</h1>
"KRN",.84,7981005.001,2,17,0)
   <xsl:call-template name="ReportHeader"/>
"KRN",.84,7981005.001,2,18,0)
   <xsl:apply-templates select="/REPORT/CATEGORY"/>
"KRN",.84,7981005.001,2,19,0)
   <xsl:if test="not(/REPORT/CATEGORY[1])">
"KRN",.84,7981005.001,2,20,0)
    <xsl:call-template name="TableNoData"/>
"KRN",.84,7981005.001,2,21,0)
   </xsl:if>
"KRN",.84,7981005.001,2,22,0)
  </body>
"KRN",.84,7981005.001,2,23,0)
 </html>
"KRN",.84,7981005.001,2,24,0)
</xsl:template>
"KRN",.84,7981005.001,2,25,0)
 
"KRN",.84,7981005.001,2,26,0)
<xsl:template match="REPORT/CATEGORY">
"KRN",.84,7981005.001,2,27,0)
 <xsl:if test="OUTPATIENTS">
"KRN",.84,7981005.001,2,28,0)
  <div style="page-break-before:always">
"KRN",.84,7981005.001,2,29,0)
   <h2>Selected Outpatient Activity<br/><xsl:value-of select="NAME"/></h2>
"KRN",.84,7981005.001,2,30,0)
   <xsl:call-template name="OutpatientSummary"/>
"KRN",.84,7981005.001,2,31,0)
   <xsl:apply-templates select="OUTPATIENTS"/>
"KRN",.84,7981005.001,2,32,0)
  </div>
"KRN",.84,7981005.001,2,33,0)
 </xsl:if>
"KRN",.84,7981005.001,2,34,0)
 <xsl:if test="INPATIENTS">
"KRN",.84,7981005.001,2,35,0)
  <div style="page-break-before:always">
"KRN",.84,7981005.001,2,36,0)
   <h2>Selected Inpatient Activity<br/><xsl:value-of select="NAME"/></h2>
"KRN",.84,7981005.001,2,37,0)
   <xsl:call-template name="InpatientSummary"/>
"KRN",.84,7981005.001,2,38,0)
   <xsl:apply-templates select="INPATIENTS"/>
"KRN",.84,7981005.001,2,39,0)
  </div>
"KRN",.84,7981005.001,2,40,0)
 </xsl:if>
"KRN",.84,7981005.001,2,41,0)
 <xsl:if test="HIGHUTIL">
"KRN",.84,7981005.001,2,42,0)
  <div style="page-break-before:always">
"KRN",.84,7981005.001,2,43,0)
   <h2>Highest Utilization<br/><xsl:value-of select="NAME"/></h2>
"KRN",.84,7981005.001,2,44,0)
   <xsl:apply-templates select="HIGHUTIL"/>
"KRN",.84,7981005.001,2,45,0)
  </div>
"KRN",.84,7981005.001,2,46,0)
 </xsl:if>
"KRN",.84,7981005.001,2,47,0)
</xsl:template>
"KRN",.84,7981005.001,2,48,0)
 
"KRN",.84,7981005.001,2,49,0)
<xsl:template match="HIGHUTIL/*">
"KRN",.84,7981005.001,2,50,0)
 <xsl:variable name="name" select="name(.)"/>
"KRN",.84,7981005.001,2,51,0)
 <xsl:choose>
"KRN",.84,7981005.001,2,52,0)
  <xsl:when test="$name='HU_STOPS'">
"KRN",.84,7981005.001,2,53,0)
   <h3><xsl:call-template name="HUPatientsHeader"/> by number of stop codes</h3>
"KRN",.84,7981005.001,2,54,0)
   <xsl:call-template name="DataGrid"/>
"KRN",.84,7981005.001,2,55,0)
  </xsl:when>
"KRN",.84,7981005.001,2,56,0)
  <xsl:when test="$name='HU_STAYS'">
"KRN",.84,7981005.001,2,57,0)
   <h3><xsl:call-template name="HUPatientsHeader"/> by number of stays</h3>
"KRN",.84,7981005.001,2,58,0)
   <xsl:call-template name="DataGrid"/>
"KRN",.84,7981005.001,2,59,0)
  </xsl:when>
"KRN",.84,7981005.001,2,60,0)
  <xsl:when test="$name='HU_DAYS'">
"KRN",.84,7981005.001,2,61,0)
   <h3><xsl:call-template name="HUPatientsHeader"/> by number of days</h3>
"KRN",.84,7981005.001,2,62,0)
   <xsl:call-template name="DataGrid"/>
"KRN",.84,7981005.001,2,63,0)
  </xsl:when>
"KRN",.84,7981005.001,2,64,0)
  <xsl:otherwise></xsl:otherwise>
"KRN",.84,7981005.001,2,65,0)
 </xsl:choose>
"KRN",.84,7981005.001,2,66,0)
</xsl:template>
"KRN",.84,7981005.001,2,67,0)
 
"KRN",.84,7981005.001,2,68,0)
<xsl:template match="INPATIENTS/*">
"KRN",.84,7981005.001,2,69,0)
 <xsl:variable name="name" select="name(.)"/>
"KRN",.84,7981005.001,2,70,0)
 <xsl:choose>
"KRN",.84,7981005.001,2,71,0)
  <xsl:when test="$name='STAYS'">
"KRN",.84,7981005.001,2,72,0)
   <br clear="both"/>
"KRN",.84,7981005.001,2,73,0)
   <xsl:call-template name="DataGrid">
"KRN",.84,7981005.001,2,74,0)
    <xsl:with-param name="divstyle" select="'width:50%'"/>
"KRN",.84,7981005.001,2,75,0)
   </xsl:call-template>
"KRN",.84,7981005.001,2,76,0)
  </xsl:when>
"KRN",.84,7981005.001,2,77,0)
  <xsl:when test="$name='BEDSECTIONS'">
"KRN",.84,7981005.001,2,78,0)
   <h3>Distribution of Utilization among Bed Sections</h3>
"KRN",.84,7981005.001,2,79,0)
   <div>
"KRN",.84,7981005.001,2,80,0)
    Because of hospital stays split among multiple bed sections,
"KRN",.84,7981005.001,2,81,0)
    information by bed section may not match the totals for complete
"KRN",.84,7981005.001,2,82,0)
    hospital stays presented in the summary and highest utilization tables.
"KRN",.84,7981005.001,2,83,0)
   </div>
"KRN",.84,7981005.001,2,84,0)
   <xsl:call-template name="DataGrid"/>
"KRN",.84,7981005.001,2,85,0)
  </xsl:when>
"KRN",.84,7981005.001,2,86,0)
  <xsl:when test="$name='NOBS'">
"KRN",.84,7981005.001,2,87,0)
   <h3>Occurrences of Missing Bed Section ID</h3>
"KRN",.84,7981005.001,2,88,0)
   <xsl:call-template name="DataGrid"/>
"KRN",.84,7981005.001,2,89,0)
  </xsl:when>
"KRN",.84,7981005.001,2,90,0)
  <xsl:otherwise></xsl:otherwise>
"KRN",.84,7981005.001,2,91,0)
 </xsl:choose>
"KRN",.84,7981005.001,2,92,0)
</xsl:template>
"KRN",.84,7981005.001,2,93,0)
 
"KRN",.84,7981005.001,2,94,0)
<xsl:template match="OUTPATIENTS/*">
"KRN",.84,7981005.001,2,95,0)
 <xsl:variable name="name" select="name(.)"/>
"KRN",.84,7981005.001,2,96,0)
 <xsl:choose>
"KRN",.84,7981005.001,2,97,0)
  <xsl:when test="$name='STOPS'">
"KRN",.84,7981005.001,2,98,0)
   <br clear="both"/>
"KRN",.84,7981005.001,2,99,0)
   <xsl:call-template name="DataGrid">
"KRN",.84,7981005.001,2,100,0)
    <xsl:with-param name="divstyle" select="'width:50%'"/>
"KRN",.84,7981005.001,2,101,0)
   </xsl:call-template>
"KRN",.84,7981005.001,2,102,0)
  </xsl:when>
"KRN",.84,7981005.001,2,103,0)
  <xsl:when test="$name='CLINICS'">
"KRN",.84,7981005.001,2,104,0)
   <h3>Distribution of Utilization among Clinics</h3>
"KRN",.84,7981005.001,2,105,0)
   <xsl:call-template name="DataGrid"/>
"KRN",.84,7981005.001,2,106,0)
  </xsl:when>
"KRN",.84,7981005.001,2,107,0)
  <xsl:otherwise></xsl:otherwise>
"KRN",.84,7981005.001,2,108,0)
 </xsl:choose>
"KRN",.84,7981005.001,2,109,0)
</xsl:template>
"KRN",.84,7981005.001,2,110,0)
 
"KRN",.84,7981005.001,2,111,0)
<!--[ UTILITIES ]-->
"KRN",.84,7981005.001,2,112,0)
 
"KRN",.84,7981005.001,2,113,0)
<xsl:template name="InpatientSummary">
"KRN",.84,7981005.001,2,114,0)
 <xsl:param name="category" select="."/>
"KRN",.84,7981005.001,2,115,0)
 <xsl:variable name="IP" select="$category/INPATIENTS"/>
"KRN",.84,7981005.001,2,116,0)
 <table width="100%" cellpadding="5" cellspacing="0">
"KRN",.84,7981005.001,2,117,0)
  <thead>
"KRN",.84,7981005.001,2,118,0)
   <tr>
"KRN",.84,7981005.001,2,119,0)
    <th width="16%">Number of Patients</th>
"KRN",.84,7981005.001,2,120,0)
    <th width="16%">Number of Stays</th>
"KRN",.84,7981005.001,2,121,0)
    <th width="16%">Number of Days</th>
"KRN",.84,7981005.001,2,122,0)
    <th width="16%">Median Length of Stay (MLOS)</th>
"KRN",.84,7981005.001,2,123,0)
    <th width="16%">Average Length of Stay</th>
"KRN",.84,7981005.001,2,124,0)
    <th width="16%">Number of Short Stays</th>
"KRN",.84,7981005.001,2,125,0)
   </tr>
"KRN",.84,7981005.001,2,126,0)
  </thead>
"KRN",.84,7981005.001,2,127,0)
  <tbody>
"KRN",.84,7981005.001,2,128,0)
   <tr>
"KRN",.84,7981005.001,2,129,0)
    <td><xsl:value-of select="$IP/NP"/></td>
"KRN",.84,7981005.001,2,130,0)
    <td><xsl:value-of select="$IP/NST"/></td>
"KRN",.84,7981005.001,2,131,0)
    <td><xsl:value-of select="$IP/ND"/></td>
"KRN",.84,7981005.001,2,132,0)
    <td><xsl:value-of select="$IP/MLOS"/></td>
"KRN",.84,7981005.001,2,133,0)
    <td><xsl:value-of select="$IP/ALOS"/></td>
"KRN",.84,7981005.001,2,134,0)
    <td><xsl:value-of select="$IP/NSS"/></td>
"KRN",.84,7981005.001,2,135,0)
   </tr>
"KRN",.84,7981005.001,2,136,0)
  </tbody>
"KRN",.84,7981005.001,2,137,0)
 </table>
"KRN",.84,7981005.001,2,138,0)
</xsl:template>
"KRN",.84,7981005.001,2,139,0)
 
"KRN",.84,7981005.001,2,140,0)
<xsl:template name="OutpatientSummary">
"KRN",.84,7981005.001,2,141,0)
 <xsl:param name="category" select="."/>
"KRN",.84,7981005.001,2,142,0)
 <xsl:variable name="OP" select="$category/OUTPATIENTS"/>
"KRN",.84,7981005.001,2,143,0)
 <xsl:text>
"KRN",.84,7981005.001,2,144,0)
  A total of 1.00 visit is given for outpatient activity on a given date.
"KRN",.84,7981005.001,2,145,0)
  A 'stop' is credited for each entry of a stop code, while a 'visit' is
"KRN",.84,7981005.001,2,146,0)
  split among each stop credited on a given date. Thus, a single visit with
"KRN",.84,7981005.001,2,147,0)
  two stop codes credited will show as 0.5 visit for each stop code. 
"KRN",.84,7981005.001,2,148,0)
 </xsl:text>
"KRN",.84,7981005.001,2,149,0)
 <br/>
"KRN",.84,7981005.001,2,150,0)
 <table width="100%" cellpadding="5" cellspacing="0">
"KRN",.84,7981005.001,2,151,0)
  <thead>
"KRN",.84,7981005.001,2,152,0)
   <tr>
"KRN",.84,7981005.001,2,153,0)
    <th width="33%">Number of Patients</th>
"KRN",.84,7981005.001,2,154,0)
    <th width="33%">Number of Visits</th>
"KRN",.84,7981005.001,2,155,0)
    <th width="33%">Number of Stops</th>
"KRN",.84,7981005.001,2,156,0)
   </tr>
"KRN",.84,7981005.001,2,157,0)
  </thead>
"KRN",.84,7981005.001,2,158,0)
  <tbody>
"KRN",.84,7981005.001,2,159,0)
   <tr>
"KRN",.84,7981005.001,2,160,0)
    <td><xsl:value-of select="$OP/NP"/></td>
"KRN",.84,7981005.001,2,161,0)
    <td><xsl:value-of select="$OP/NV"/></td>
"KRN",.84,7981005.001,2,162,0)
    <td><xsl:value-of select="$OP/NSC"/></td>
"KRN",.84,7981005.001,2,163,0)
   </tr>
"KRN",.84,7981005.001,2,164,0)
  </tbody>
"KRN",.84,7981005.001,2,165,0)
 </table>
"KRN",.84,7981005.001,2,166,0)
</xsl:template>
"KRN",.84,7981005.001,2,167,0)
 
"KRN",.84,7981005.001,2,168,0)
<!--[ COLUMN HEADERS ]-->
"KRN",.84,7981005.001,2,169,0)
 
"KRN",.84,7981005.001,2,170,0)
<xsl:template match="TBLDEF[@NAME='NOBS']/COLUMN[@NAME='DATE']">
"KRN",.84,7981005.001,2,171,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,172,0)
  <xsl:with-param name="title" select="'Movement Date'"/>
"KRN",.84,7981005.001,2,173,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981005.001,2,174,0)
 </xsl:call-template>
"KRN",.84,7981005.001,2,175,0)
</xsl:template>
"KRN",.84,7981005.001,2,176,0)
 
"KRN",.84,7981005.001,2,177,0)
<xsl:template match="COLUMN[@NAME='MLOS']">
"KRN",.84,7981005.001,2,178,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,179,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981005.001,2,180,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981005.001,2,181,0)
 </xsl:call-template>
"KRN",.84,7981005.001,2,182,0)
</xsl:template>
"KRN",.84,7981005.001,2,183,0)
 
"KRN",.84,7981005.001,2,184,0)
<xsl:template match="COLUMN[@NAME='NAME']">
"KRN",.84,7981005.001,2,185,0)
 <xsl:variable name="tblname" select="../@NAME"/>
"KRN",.84,7981005.001,2,186,0)
 <xsl:choose>
"KRN",.84,7981005.001,2,187,0)
  <xsl:when test="$tblname='BEDSECTIONS'">
"KRN",.84,7981005.001,2,188,0)
   <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,189,0)
    <xsl:with-param name="title" select="'Bed Section'"/>
"KRN",.84,7981005.001,2,190,0)
   </xsl:call-template> 
"KRN",.84,7981005.001,2,191,0)
  </xsl:when>
"KRN",.84,7981005.001,2,192,0)
  <xsl:when test="$tblname='CLINICS'">
"KRN",.84,7981005.001,2,193,0)
   <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,194,0)
    <xsl:with-param name="title" select="'Clinic'"/>
"KRN",.84,7981005.001,2,195,0)
   </xsl:call-template> 
"KRN",.84,7981005.001,2,196,0)
  </xsl:when>
"KRN",.84,7981005.001,2,197,0)
  <xsl:when test="contains($tblname,'HU_') or ($tblname='NOBS')">
"KRN",.84,7981005.001,2,198,0)
   <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,199,0)
    <xsl:with-param name="title" select="'Patient Name'"/>
"KRN",.84,7981005.001,2,200,0)
   </xsl:call-template> 
"KRN",.84,7981005.001,2,201,0)
  </xsl:when>
"KRN",.84,7981005.001,2,202,0)
  <xsl:otherwise>
"KRN",.84,7981005.001,2,203,0)
   <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,204,0)
    <xsl:with-param name="title" select="'Name'"/>
"KRN",.84,7981005.001,2,205,0)
   </xsl:call-template> 
"KRN",.84,7981005.001,2,206,0)
  </xsl:otherwise>
"KRN",.84,7981005.001,2,207,0)
 </xsl:choose>
"KRN",.84,7981005.001,2,208,0)
</xsl:template>
"KRN",.84,7981005.001,2,209,0)
 
"KRN",.84,7981005.001,2,210,0)
<xsl:template match="COLUMN[@NAME='ND']">
"KRN",.84,7981005.001,2,211,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,212,0)
  <xsl:with-param name="title" select="'Number of Days'"/>
"KRN",.84,7981005.001,2,213,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981005.001,2,214,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981005.001,2,215,0)
 </xsl:call-template>
"KRN",.84,7981005.001,2,216,0)
</xsl:template>
"KRN",.84,7981005.001,2,217,0)
 
"KRN",.84,7981005.001,2,218,0)
<xsl:template match="COLUMN[@NAME='NDS']">
"KRN",.84,7981005.001,2,219,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,220,0)
  <xsl:with-param name="title" select="'Number of Different Stops'"/>
"KRN",.84,7981005.001,2,221,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981005.001,2,222,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981005.001,2,223,0)
 </xsl:call-template>
"KRN",.84,7981005.001,2,224,0)
</xsl:template>
"KRN",.84,7981005.001,2,225,0)
 
"KRN",.84,7981005.001,2,226,0)
<xsl:template match="COLUMN[@NAME='NP']">
"KRN",.84,7981005.001,2,227,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,228,0)
  <xsl:with-param name="title" select="'Number of Patients'"/>
"KRN",.84,7981005.001,2,229,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981005.001,2,230,0)
 </xsl:call-template>
"KRN",.84,7981005.001,2,231,0)
</xsl:template>
"KRN",.84,7981005.001,2,232,0)
 
"KRN",.84,7981005.001,2,233,0)
<xsl:template match="COLUMN[@NAME='NSC']">
"KRN",.84,7981005.001,2,234,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,235,0)
  <xsl:with-param name="title" select="'Number of Stops'"/>
"KRN",.84,7981005.001,2,236,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981005.001,2,237,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981005.001,2,238,0)
 </xsl:call-template>
"KRN",.84,7981005.001,2,239,0)
</xsl:template>
"KRN",.84,7981005.001,2,240,0)
 
"KRN",.84,7981005.001,2,241,0)
<xsl:template match="COLUMN[@NAME='NSS']">
"KRN",.84,7981005.001,2,242,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,243,0)
  <xsl:with-param name="title" select="'Number of Short Stays'"/>
"KRN",.84,7981005.001,2,244,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981005.001,2,245,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981005.001,2,246,0)
 </xsl:call-template>
"KRN",.84,7981005.001,2,247,0)
</xsl:template>
"KRN",.84,7981005.001,2,248,0)
 
"KRN",.84,7981005.001,2,249,0)
<xsl:template match="COLUMN[@NAME='NST']">
"KRN",.84,7981005.001,2,250,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,251,0)
  <xsl:with-param name="title" select="'Number of Stays'"/>
"KRN",.84,7981005.001,2,252,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981005.001,2,253,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981005.001,2,254,0)
 </xsl:call-template>
"KRN",.84,7981005.001,2,255,0)
</xsl:template>
"KRN",.84,7981005.001,2,256,0)
 
"KRN",.84,7981005.001,2,257,0)
<xsl:template match="COLUMN[@NAME='NV']">
"KRN",.84,7981005.001,2,258,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,259,0)
  <xsl:with-param name="title" select="'Number of Visits'"/>
"KRN",.84,7981005.001,2,260,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981005.001,2,261,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981005.001,2,262,0)
 </xsl:call-template>
"KRN",.84,7981005.001,2,263,0)
</xsl:template>
"KRN",.84,7981005.001,2,264,0)
 
"KRN",.84,7981005.001,2,265,0)
<xsl:template match="COLUMN[@NAME='PTF']">
"KRN",.84,7981005.001,2,266,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,267,0)
  <xsl:with-param name="title" select="'PTF#'"/>
"KRN",.84,7981005.001,2,268,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981005.001,2,269,0)
 </xsl:call-template>
"KRN",.84,7981005.001,2,270,0)
</xsl:template>
"KRN",.84,7981005.001,2,271,0)
 
"KRN",.84,7981005.001,2,272,0)
<xsl:template match="COLUMN[@NAME='STOP']">
"KRN",.84,7981005.001,2,273,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.001,2,274,0)
  <xsl:with-param name="title" select="'Stop Code'"/>
"KRN",.84,7981005.001,2,275,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981005.001,2,276,0)
 </xsl:call-template>
"KRN",.84,7981005.001,2,277,0)
</xsl:template>
"KRN",.84,7981005.001,2,278,0)
 
"KRN",.84,7981005.001,2,279,0)
<!--[ CELL VALUES ]-->
"KRN",.84,7981005.001,2,280,0)
 
"KRN",.84,7981005.001,2,281,0)
<xsl:template match="NOBS/PATIENT/DATE">
"KRN",.84,7981005.001,2,282,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981005.001,2,283,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981005.001,2,284,0)
 </xsl:call-template>
"KRN",.84,7981005.001,2,285,0)
</xsl:template>
"KRN",.84,7981005.001,2,286,0)
 
"KRN",.84,7981005.001,2,287,0)
<!--[ REPORT PARAMETERS ]-->
"KRN",.84,7981005.001,2,288,0)
 
"KRN",.84,7981005.001,2,289,0)
<xsl:template match="PARAMETERS/MAXUTNUM">
"KRN",.84,7981005.001,2,290,0)
 <tr>
"KRN",.84,7981005.001,2,291,0)
  <th scope="row">MaxUtil:&#160;</th>
"KRN",.84,7981005.001,2,292,0)
  <td>
"KRN",.84,7981005.001,2,293,0)
   <xsl:value-of select="."/>
"KRN",.84,7981005.001,2,294,0)
   (maximum number of patients with highest utilization to display)
"KRN",.84,7981005.001,2,295,0)
  </td>
"KRN",.84,7981005.001,2,296,0)
 </tr>
"KRN",.84,7981005.001,2,297,0)
</xsl:template>
"KRN",.84,7981005.001,2,298,0)
 
"KRN",.84,7981005.001,2,299,0)
</xsl:stylesheet>
"KRN",.84,7981005.002,-1)
0^52
"KRN",.84,7981005.002,0)
7981005.002^2^^CLINICAL CASE REGISTRIES^Inpatient & Outpatient Utilization (CSV)
"KRN",.84,7981005.002,2,0)
^^153^153^3040210^
"KRN",.84,7981005.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981005.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981005.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981005.002,2,4,0)
>
"KRN",.84,7981005.002,2,5,0)
 
"KRN",.84,7981005.002,2,6,0)
<xsl:import href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981005.002,2,7,0)
 
"KRN",.84,7981005.002,2,8,0)
<xsl:variable name="UTILIZATION_HEADER"
"KRN",.84,7981005.002,2,9,0)
     select="'Inpatient and Outpatient Utilization'"/>
"KRN",.84,7981005.002,2,10,0)
 
"KRN",.84,7981005.002,2,11,0)
<xsl:template match="/">
"KRN",.84,7981005.002,2,12,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981005.002,2,13,0)
  <xsl:with-param name="subttl" select="'Stops'"/>
"KRN",.84,7981005.002,2,14,0)
  <xsl:with-param name="table" select="'STOPS'"/>
"KRN",.84,7981005.002,2,15,0)
  <xsl:with-param name="parent" select="'OUTPATIENTS'"/>
"KRN",.84,7981005.002,2,16,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,17,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981005.002,2,18,0)
  <xsl:with-param name="subttl"
"KRN",.84,7981005.002,2,19,0)
       select="'Distribution of Utilization among Clinics'"/>
"KRN",.84,7981005.002,2,20,0)
  <xsl:with-param name="table" select="'CLINICS'"/>
"KRN",.84,7981005.002,2,21,0)
  <xsl:with-param name="parent" select="'OUTPATIENTS'"/>
"KRN",.84,7981005.002,2,22,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,23,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981005.002,2,24,0)
  <xsl:with-param name="subttl" select="'Stays'"/>
"KRN",.84,7981005.002,2,25,0)
  <xsl:with-param name="table" select="'STAYS'"/>
"KRN",.84,7981005.002,2,26,0)
  <xsl:with-param name="parent" select="'INPATIENTS'"/>
"KRN",.84,7981005.002,2,27,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,28,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981005.002,2,29,0)
  <xsl:with-param name="subttl"
"KRN",.84,7981005.002,2,30,0)
       select="'Distribution of Utilization among Bed Sections'"/>
"KRN",.84,7981005.002,2,31,0)
  <xsl:with-param name="table" select="'BEDSECTIONS'"/>
"KRN",.84,7981005.002,2,32,0)
  <xsl:with-param name="parent" select="'INPATIENTS'"/>
"KRN",.84,7981005.002,2,33,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,34,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981005.002,2,35,0)
  <xsl:with-param name="subttl"
"KRN",.84,7981005.002,2,36,0)
       select="'Occurrences of Missing Bed Section ID'"/>
"KRN",.84,7981005.002,2,37,0)
  <xsl:with-param name="table" select="'NOBS'"/>
"KRN",.84,7981005.002,2,38,0)
  <xsl:with-param name="parent" select="'INPATIENTS'"/>
"KRN",.84,7981005.002,2,39,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,40,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981005.002,2,41,0)
  <xsl:with-param name="subttl" select="'Highest Utilization of Stop Codes'"/>
"KRN",.84,7981005.002,2,42,0)
  <xsl:with-param name="table" select="'HU_STOPS'"/>
"KRN",.84,7981005.002,2,43,0)
  <xsl:with-param name="parent" select="'HIGHUTIL'"/>
"KRN",.84,7981005.002,2,44,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,45,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981005.002,2,46,0)
  <xsl:with-param name="subttl" select="'Highest Number of Stays'"/>
"KRN",.84,7981005.002,2,47,0)
  <xsl:with-param name="table" select="'HU_STAYS'"/>
"KRN",.84,7981005.002,2,48,0)
  <xsl:with-param name="parent" select="'HIGHUTIL'"/>
"KRN",.84,7981005.002,2,49,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,50,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981005.002,2,51,0)
  <xsl:with-param name="subttl" select="'Highest Number of Days'"/>
"KRN",.84,7981005.002,2,52,0)
  <xsl:with-param name="table" select="'HU_DAYS'"/>
"KRN",.84,7981005.002,2,53,0)
  <xsl:with-param name="parent" select="'HIGHUTIL'"/>
"KRN",.84,7981005.002,2,54,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,55,0)
</xsl:template>
"KRN",.84,7981005.002,2,56,0)
 
"KRN",.84,7981005.002,2,57,0)
<!--[ COLUMN HEADERS ]-->
"KRN",.84,7981005.002,2,58,0)
 
"KRN",.84,7981005.002,2,59,0)
<xsl:template match="TBLDEF[@NAME='NOBS']/COLUMN[@NAME='DATE']">
"KRN",.84,7981005.002,2,60,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.002,2,61,0)
  <xsl:with-param name="title" select="'Movement Date'"/>
"KRN",.84,7981005.002,2,62,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,63,0)
</xsl:template>
"KRN",.84,7981005.002,2,64,0)
 
"KRN",.84,7981005.002,2,65,0)
<xsl:template match="COLUMN[@NAME='NAME']">
"KRN",.84,7981005.002,2,66,0)
 <xsl:variable name="tblname" select="../@NAME"/>
"KRN",.84,7981005.002,2,67,0)
 <xsl:choose>
"KRN",.84,7981005.002,2,68,0)
  <xsl:when test="$tblname='BEDSECTIONS'">
"KRN",.84,7981005.002,2,69,0)
   <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.002,2,70,0)
    <xsl:with-param name="title" select="'Bed Section'"/>
"KRN",.84,7981005.002,2,71,0)
   </xsl:call-template> 
"KRN",.84,7981005.002,2,72,0)
  </xsl:when>
"KRN",.84,7981005.002,2,73,0)
  <xsl:when test="$tblname='CLINICS'">
"KRN",.84,7981005.002,2,74,0)
   <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.002,2,75,0)
    <xsl:with-param name="title" select="'Clinic'"/>
"KRN",.84,7981005.002,2,76,0)
   </xsl:call-template> 
"KRN",.84,7981005.002,2,77,0)
  </xsl:when>
"KRN",.84,7981005.002,2,78,0)
  <xsl:when test="contains($tblname,'HU_') or ($tblname='NOBS')">
"KRN",.84,7981005.002,2,79,0)
   <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.002,2,80,0)
    <xsl:with-param name="title" select="'Patient Name'"/>
"KRN",.84,7981005.002,2,81,0)
   </xsl:call-template> 
"KRN",.84,7981005.002,2,82,0)
  </xsl:when>
"KRN",.84,7981005.002,2,83,0)
  <xsl:otherwise>
"KRN",.84,7981005.002,2,84,0)
   <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.002,2,85,0)
    <xsl:with-param name="title" select="'Name'"/>
"KRN",.84,7981005.002,2,86,0)
   </xsl:call-template> 
"KRN",.84,7981005.002,2,87,0)
  </xsl:otherwise>
"KRN",.84,7981005.002,2,88,0)
 </xsl:choose>
"KRN",.84,7981005.002,2,89,0)
</xsl:template>
"KRN",.84,7981005.002,2,90,0)
 
"KRN",.84,7981005.002,2,91,0)
<xsl:template match="COLUMN[@NAME='ND']">
"KRN",.84,7981005.002,2,92,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.002,2,93,0)
  <xsl:with-param name="title" select="'Number of Days'"/>
"KRN",.84,7981005.002,2,94,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,95,0)
</xsl:template>
"KRN",.84,7981005.002,2,96,0)
 
"KRN",.84,7981005.002,2,97,0)
<xsl:template match="COLUMN[@NAME='NDS']">
"KRN",.84,7981005.002,2,98,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.002,2,99,0)
  <xsl:with-param name="title" select="'Number of Different Stops'"/>
"KRN",.84,7981005.002,2,100,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,101,0)
</xsl:template>
"KRN",.84,7981005.002,2,102,0)
 
"KRN",.84,7981005.002,2,103,0)
<xsl:template match="COLUMN[@NAME='NP']">
"KRN",.84,7981005.002,2,104,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.002,2,105,0)
  <xsl:with-param name="title" select="'Number of Patients'"/>
"KRN",.84,7981005.002,2,106,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,107,0)
</xsl:template>
"KRN",.84,7981005.002,2,108,0)
 
"KRN",.84,7981005.002,2,109,0)
<xsl:template match="COLUMN[@NAME='NSC']">
"KRN",.84,7981005.002,2,110,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.002,2,111,0)
  <xsl:with-param name="title" select="'Number of Stops'"/>
"KRN",.84,7981005.002,2,112,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,113,0)
</xsl:template>
"KRN",.84,7981005.002,2,114,0)
 
"KRN",.84,7981005.002,2,115,0)
<xsl:template match="COLUMN[@NAME='NSS']">
"KRN",.84,7981005.002,2,116,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.002,2,117,0)
  <xsl:with-param name="title" select="'Number of Short Stays'"/>
"KRN",.84,7981005.002,2,118,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,119,0)
</xsl:template>
"KRN",.84,7981005.002,2,120,0)
 
"KRN",.84,7981005.002,2,121,0)
<xsl:template match="COLUMN[@NAME='NST']">
"KRN",.84,7981005.002,2,122,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.002,2,123,0)
  <xsl:with-param name="title" select="'Number of Stays'"/>
"KRN",.84,7981005.002,2,124,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,125,0)
</xsl:template>
"KRN",.84,7981005.002,2,126,0)
 
"KRN",.84,7981005.002,2,127,0)
<xsl:template match="COLUMN[@NAME='NV']">
"KRN",.84,7981005.002,2,128,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.002,2,129,0)
  <xsl:with-param name="title" select="'Number of Visits'"/>
"KRN",.84,7981005.002,2,130,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,131,0)
</xsl:template>
"KRN",.84,7981005.002,2,132,0)
 
"KRN",.84,7981005.002,2,133,0)
<xsl:template match="COLUMN[@NAME='PTF']">
"KRN",.84,7981005.002,2,134,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.002,2,135,0)
  <xsl:with-param name="title" select="'PTF#'"/>
"KRN",.84,7981005.002,2,136,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,137,0)
</xsl:template>
"KRN",.84,7981005.002,2,138,0)
 
"KRN",.84,7981005.002,2,139,0)
<xsl:template match="COLUMN[@NAME='STOP']">
"KRN",.84,7981005.002,2,140,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981005.002,2,141,0)
  <xsl:with-param name="title" select="'Stop Code'"/>
"KRN",.84,7981005.002,2,142,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,143,0)
</xsl:template>
"KRN",.84,7981005.002,2,144,0)
 
"KRN",.84,7981005.002,2,145,0)
<!--[ CELL VALUES ]-->
"KRN",.84,7981005.002,2,146,0)
 
"KRN",.84,7981005.002,2,147,0)
<xsl:template match="NOBS/PATIENT/DATE">
"KRN",.84,7981005.002,2,148,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981005.002,2,149,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981005.002,2,150,0)
 </xsl:call-template>
"KRN",.84,7981005.002,2,151,0)
</xsl:template>
"KRN",.84,7981005.002,2,152,0)
 
"KRN",.84,7981005.002,2,153,0)
</xsl:stylesheet>
"KRN",.84,7981006.001,-1)
0^32
"KRN",.84,7981006.001,0)
7981006.001^2^^CLINICAL CASE REGISTRIES^Laboratory Utilization (HTML)
"KRN",.84,7981006.001,2,0)
^^165^165^3040112^
"KRN",.84,7981006.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981006.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981006.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981006.001,2,4,0)
>
"KRN",.84,7981006.001,2,5,0)
 
"KRN",.84,7981006.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   --> 
"KRN",.84,7981006.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981006.001,2,8,0)
<xsl:include href="template://report/995/1"/>  <!-- Lab Data -->
"KRN",.84,7981006.001,2,9,0)
 
"KRN",.84,7981006.001,2,10,0)
<xsl:template match="/">
"KRN",.84,7981006.001,2,11,0)
 <html>
"KRN",.84,7981006.001,2,12,0)
  <head>
"KRN",.84,7981006.001,2,13,0)
   <title>Laboratory Utilization</title>
"KRN",.84,7981006.001,2,14,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981006.001,2,15,0)
  </head>
"KRN",.84,7981006.001,2,16,0)
  <body>
"KRN",.84,7981006.001,2,17,0)
   <h1>Laboratory Utilization</h1>
"KRN",.84,7981006.001,2,18,0)
   <xsl:call-template name="ReportHeader"/>
"KRN",.84,7981006.001,2,19,0)
   <xsl:apply-templates select="/REPORT/CATEGORY"/>
"KRN",.84,7981006.001,2,20,0)
   <xsl:if test="not(/REPORT/CATEGORY[1])">
"KRN",.84,7981006.001,2,21,0)
    <xsl:call-template name="TableNoData"/>
"KRN",.84,7981006.001,2,22,0)
   </xsl:if>
"KRN",.84,7981006.001,2,23,0)
  </body>
"KRN",.84,7981006.001,2,24,0)
 </html>
"KRN",.84,7981006.001,2,25,0)
</xsl:template>
"KRN",.84,7981006.001,2,26,0)
 
"KRN",.84,7981006.001,2,27,0)
<xsl:template match="REPORT/CATEGORY">
"KRN",.84,7981006.001,2,28,0)
 <div style="page-break-before:always">
"KRN",.84,7981006.001,2,29,0)
  <h2><xsl:value-of select="NAME"/></h2>
"KRN",.84,7981006.001,2,30,0)
  <xsl:call-template name="CategorySummary"/>
"KRN",.84,7981006.001,2,31,0)
  <xsl:apply-templates select="RESULTS"/>
"KRN",.84,7981006.001,2,32,0)
  <xsl:apply-templates select="LABTESTS"/>
"KRN",.84,7981006.001,2,33,0)
  <xsl:apply-templates select="PATIENTS"/>
"KRN",.84,7981006.001,2,34,0)
 </div>
"KRN",.84,7981006.001,2,35,0)
</xsl:template>
"KRN",.84,7981006.001,2,36,0)
 
"KRN",.84,7981006.001,2,37,0)
<!--[ TABLES ]-->
"KRN",.84,7981006.001,2,38,0)
 
"KRN",.84,7981006.001,2,39,0)
<xsl:template match="CATEGORY/LABTESTS">
"KRN",.84,7981006.001,2,40,0)
 <xsl:variable name="minrpnum" select="/REPORT/PARAMETERS/MINRPNUM"/>
"KRN",.84,7981006.001,2,41,0)
 <h3>
"KRN",.84,7981006.001,2,42,0)
  Laboratory tests performed
"KRN",.84,7981006.001,2,43,0)
  <xsl:choose>
"KRN",.84,7981006.001,2,44,0)
   <xsl:when test="$minrpnum>1">
"KRN",.84,7981006.001,2,45,0)
    <xsl:value-of select="$minrpnum"/> times or more
"KRN",.84,7981006.001,2,46,0)
   </xsl:when>
"KRN",.84,7981006.001,2,47,0)
   <xsl:otherwise>at least once</xsl:otherwise>
"KRN",.84,7981006.001,2,48,0)
  </xsl:choose>
"KRN",.84,7981006.001,2,49,0)
 </h3>
"KRN",.84,7981006.001,2,50,0)
 <xsl:call-template name="DataGrid"/>
"KRN",.84,7981006.001,2,51,0)
</xsl:template>
"KRN",.84,7981006.001,2,52,0)
 
"KRN",.84,7981006.001,2,53,0)
<xsl:template match="CATEGORY/PATIENTS">
"KRN",.84,7981006.001,2,54,0)
 <h3><xsl:call-template name="HUPatientsHeader"/> by number of results</h3>
"KRN",.84,7981006.001,2,55,0)
 <xsl:call-template name="DataGrid"/>
"KRN",.84,7981006.001,2,56,0)
</xsl:template>
"KRN",.84,7981006.001,2,57,0)
 
"KRN",.84,7981006.001,2,58,0)
<xsl:template match="CATEGORY/RESULTS">
"KRN",.84,7981006.001,2,59,0)
 <br clear="both"/>
"KRN",.84,7981006.001,2,60,0)
 <xsl:call-template name="DataGrid">
"KRN",.84,7981006.001,2,61,0)
  <xsl:with-param name="divstyle" select="'width:50%'"/>
"KRN",.84,7981006.001,2,62,0)
 </xsl:call-template>
"KRN",.84,7981006.001,2,63,0)
</xsl:template>
"KRN",.84,7981006.001,2,64,0)
 
"KRN",.84,7981006.001,2,65,0)
<!--[ UTILITIES ]-->
"KRN",.84,7981006.001,2,66,0)
 
"KRN",.84,7981006.001,2,67,0)
<xsl:template name="CategorySummary">
"KRN",.84,7981006.001,2,68,0)
 <xsl:param name="category" select="."/>
"KRN",.84,7981006.001,2,69,0)
 <table width="100%" cellpadding="5" cellspacing="0">
"KRN",.84,7981006.001,2,70,0)
  <thead>
"KRN",.84,7981006.001,2,71,0)
   <tr>
"KRN",.84,7981006.001,2,72,0)
    <th width="25%">Number of Patients</th>
"KRN",.84,7981006.001,2,73,0)
    <th width="25%">Number of Orders</th>
"KRN",.84,7981006.001,2,74,0)
    <th width="25%">Number of Results</th>
"KRN",.84,7981006.001,2,75,0)
    <th width="25%">Number of Different Tests</th>
"KRN",.84,7981006.001,2,76,0)
   </tr>
"KRN",.84,7981006.001,2,77,0)
  </thead>
"KRN",.84,7981006.001,2,78,0)
  <tbody>
"KRN",.84,7981006.001,2,79,0)
   <tr>
"KRN",.84,7981006.001,2,80,0)
    <td><xsl:value-of select="$category/NP"/></td>
"KRN",.84,7981006.001,2,81,0)
    <td><xsl:value-of select="$category/NO"/></td>
"KRN",.84,7981006.001,2,82,0)
    <td><xsl:value-of select="$category/NR"/></td>
"KRN",.84,7981006.001,2,83,0)
    <td><xsl:value-of select="$category/NDT"/></td>
"KRN",.84,7981006.001,2,84,0)
   </tr>
"KRN",.84,7981006.001,2,85,0)
  </tbody>
"KRN",.84,7981006.001,2,86,0)
 </table>
"KRN",.84,7981006.001,2,87,0)
</xsl:template>
"KRN",.84,7981006.001,2,88,0)
 
"KRN",.84,7981006.001,2,89,0)
<!--[ COLUMN HEADERS ]-->
"KRN",.84,7981006.001,2,90,0)
 
"KRN",.84,7981006.001,2,91,0)
<xsl:template match="COLUMN[@NAME='MAXNP']">
"KRN",.84,7981006.001,2,92,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981006.001,2,93,0)
  <xsl:with-param name="title"
"KRN",.84,7981006.001,2,94,0)
       select="'Number of Patients with Max. Utilization'"/>
"KRN",.84,7981006.001,2,95,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981006.001,2,96,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981006.001,2,97,0)
 </xsl:call-template>
"KRN",.84,7981006.001,2,98,0)
</xsl:template>
"KRN",.84,7981006.001,2,99,0)
 
"KRN",.84,7981006.001,2,100,0)
<xsl:template match="COLUMN[@NAME='MAXNRPP']">
"KRN",.84,7981006.001,2,101,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981006.001,2,102,0)
  <xsl:with-param name="title"
"KRN",.84,7981006.001,2,103,0)
       select="'Maximum Number of Results per Patient'"/>
"KRN",.84,7981006.001,2,104,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981006.001,2,105,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981006.001,2,106,0)
 </xsl:call-template>
"KRN",.84,7981006.001,2,107,0)
</xsl:template>
"KRN",.84,7981006.001,2,108,0)
 
"KRN",.84,7981006.001,2,109,0)
<xsl:template match="COLUMN[@NAME='NDT']">
"KRN",.84,7981006.001,2,110,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981006.001,2,111,0)
  <xsl:with-param name="title" select="'Number of Different Tests'"/>
"KRN",.84,7981006.001,2,112,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981006.001,2,113,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981006.001,2,114,0)
 </xsl:call-template>
"KRN",.84,7981006.001,2,115,0)
</xsl:template>
"KRN",.84,7981006.001,2,116,0)
 
"KRN",.84,7981006.001,2,117,0)
<xsl:template match="COLUMN[@NAME='NO']">
"KRN",.84,7981006.001,2,118,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981006.001,2,119,0)
  <xsl:with-param name="title" select="'Number of Orders'"/>
"KRN",.84,7981006.001,2,120,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981006.001,2,121,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981006.001,2,122,0)
 </xsl:call-template>
"KRN",.84,7981006.001,2,123,0)
</xsl:template>
"KRN",.84,7981006.001,2,124,0)
 
"KRN",.84,7981006.001,2,125,0)
<xsl:template match="COLUMN[@NAME='NP']">
"KRN",.84,7981006.001,2,126,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981006.001,2,127,0)
  <xsl:with-param name="title" select="'Number of Patients'"/>
"KRN",.84,7981006.001,2,128,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981006.001,2,129,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981006.001,2,130,0)
 </xsl:call-template>
"KRN",.84,7981006.001,2,131,0)
</xsl:template>
"KRN",.84,7981006.001,2,132,0)
 
"KRN",.84,7981006.001,2,133,0)
<xsl:template match="COLUMN[@NAME='NR']">
"KRN",.84,7981006.001,2,134,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981006.001,2,135,0)
  <xsl:with-param name="title" select="'Number of Results'"/>
"KRN",.84,7981006.001,2,136,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981006.001,2,137,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981006.001,2,138,0)
 </xsl:call-template>
"KRN",.84,7981006.001,2,139,0)
</xsl:template>
"KRN",.84,7981006.001,2,140,0)
 
"KRN",.84,7981006.001,2,141,0)
 
"KRN",.84,7981006.001,2,142,0)
<!--[ REPORT PARAMETERS ]-->
"KRN",.84,7981006.001,2,143,0)
 
"KRN",.84,7981006.001,2,144,0)
<xsl:template match="PARAMETERS/MAXUTNUM">
"KRN",.84,7981006.001,2,145,0)
 <tr>
"KRN",.84,7981006.001,2,146,0)
  <th scope="row">MaxUtil:&#160;</th>
"KRN",.84,7981006.001,2,147,0)
  <td>
"KRN",.84,7981006.001,2,148,0)
   <xsl:value-of select="."/>
"KRN",.84,7981006.001,2,149,0)
   (maximum number of patients with highest utilization to display)
"KRN",.84,7981006.001,2,150,0)
  </td>
"KRN",.84,7981006.001,2,151,0)
 </tr>
"KRN",.84,7981006.001,2,152,0)
</xsl:template>
"KRN",.84,7981006.001,2,153,0)
 
"KRN",.84,7981006.001,2,154,0)
<xsl:template match="PARAMETERS/MINRPNUM">
"KRN",.84,7981006.001,2,155,0)
 <tr>
"KRN",.84,7981006.001,2,156,0)
  <th scope="row">MinTest:&#160;</th>
"KRN",.84,7981006.001,2,157,0)
  <td>
"KRN",.84,7981006.001,2,158,0)
   <xsl:value-of select="."/>
"KRN",.84,7981006.001,2,159,0)
   (minimum number of times a Lab test should be performed
"KRN",.84,7981006.001,2,160,0)
   to be included in the report)
"KRN",.84,7981006.001,2,161,0)
  </td>
"KRN",.84,7981006.001,2,162,0)
 </tr>
"KRN",.84,7981006.001,2,163,0)
</xsl:template>
"KRN",.84,7981006.001,2,164,0)
 
"KRN",.84,7981006.001,2,165,0)
</xsl:stylesheet>
"KRN",.84,7981006.002,-1)
0^53
"KRN",.84,7981006.002,0)
7981006.002^2^^CLINICAL CASE REGISTRIES^Laboratory Utilization (CSV)
"KRN",.84,7981006.002,2,0)
^^66^66^3031212^
"KRN",.84,7981006.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981006.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981006.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981006.002,2,4,0)
>
"KRN",.84,7981006.002,2,5,0)
 
"KRN",.84,7981006.002,2,6,0)
<xsl:import href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981006.002,2,7,0)
 
"KRN",.84,7981006.002,2,8,0)
<xsl:variable name="UTILIZATION_HEADER"                                         
"KRN",.84,7981006.002,2,9,0)
     select="'Laboratory Utilization'"/>
"KRN",.84,7981006.002,2,10,0)
 
"KRN",.84,7981006.002,2,11,0)
<xsl:template match="/">
"KRN",.84,7981006.002,2,12,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981006.002,2,13,0)
  <xsl:with-param name="subttl" select="'Results'"/>
"KRN",.84,7981006.002,2,14,0)
  <xsl:with-param name="table" select="'RESULTS'"/>
"KRN",.84,7981006.002,2,15,0)
 </xsl:call-template>
"KRN",.84,7981006.002,2,16,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981006.002,2,17,0)
  <xsl:with-param name="subttl" select="'Laboratory Tests'"/>
"KRN",.84,7981006.002,2,18,0)
  <xsl:with-param name="table" select="'LABTESTS'"/>
"KRN",.84,7981006.002,2,19,0)
 </xsl:call-template>
"KRN",.84,7981006.002,2,20,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981006.002,2,21,0)
  <xsl:with-param name="subttl" select="'Patients with Highest Utilization'"/>
"KRN",.84,7981006.002,2,22,0)
  <xsl:with-param name="table" select="'PATIENTS'"/>
"KRN",.84,7981006.002,2,23,0)
 </xsl:call-template>
"KRN",.84,7981006.002,2,24,0)
</xsl:template>
"KRN",.84,7981006.002,2,25,0)
 
"KRN",.84,7981006.002,2,26,0)
<!--[ COLUMN HEADERS ]-->
"KRN",.84,7981006.002,2,27,0)
 
"KRN",.84,7981006.002,2,28,0)
<xsl:template match="COLUMN[@NAME='MAXNP']">
"KRN",.84,7981006.002,2,29,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981006.002,2,30,0)
  <xsl:with-param name="title"
"KRN",.84,7981006.002,2,31,0)
       select="'Number of Patients with Max. Utilization'"/>
"KRN",.84,7981006.002,2,32,0)
 </xsl:call-template>
"KRN",.84,7981006.002,2,33,0)
</xsl:template>
"KRN",.84,7981006.002,2,34,0)
 
"KRN",.84,7981006.002,2,35,0)
<xsl:template match="COLUMN[@NAME='MAXNRPP']">
"KRN",.84,7981006.002,2,36,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981006.002,2,37,0)
  <xsl:with-param name="title"
"KRN",.84,7981006.002,2,38,0)
       select="'Maximum Number of Results per Patient'"/>
"KRN",.84,7981006.002,2,39,0)
 </xsl:call-template>
"KRN",.84,7981006.002,2,40,0)
</xsl:template>
"KRN",.84,7981006.002,2,41,0)
 
"KRN",.84,7981006.002,2,42,0)
<xsl:template match="COLUMN[@NAME='NDT']">
"KRN",.84,7981006.002,2,43,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981006.002,2,44,0)
  <xsl:with-param name="title" select="'Number of Different Tests'"/>
"KRN",.84,7981006.002,2,45,0)
 </xsl:call-template>
"KRN",.84,7981006.002,2,46,0)
</xsl:template>
"KRN",.84,7981006.002,2,47,0)
 
"KRN",.84,7981006.002,2,48,0)
<xsl:template match="COLUMN[@NAME='NO']">
"KRN",.84,7981006.002,2,49,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981006.002,2,50,0)
  <xsl:with-param name="title" select="'Number of Orders'"/>
"KRN",.84,7981006.002,2,51,0)
 </xsl:call-template>
"KRN",.84,7981006.002,2,52,0)
</xsl:template>
"KRN",.84,7981006.002,2,53,0)
 
"KRN",.84,7981006.002,2,54,0)
<xsl:template match="COLUMN[@NAME='NP']">
"KRN",.84,7981006.002,2,55,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981006.002,2,56,0)
  <xsl:with-param name="title" select="'Number of Patients'"/>
"KRN",.84,7981006.002,2,57,0)
 </xsl:call-template>
"KRN",.84,7981006.002,2,58,0)
</xsl:template>
"KRN",.84,7981006.002,2,59,0)
 
"KRN",.84,7981006.002,2,60,0)
<xsl:template match="COLUMN[@NAME='NR']">
"KRN",.84,7981006.002,2,61,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981006.002,2,62,0)
  <xsl:with-param name="title" select="'Number of Results'"/>
"KRN",.84,7981006.002,2,63,0)
 </xsl:call-template>
"KRN",.84,7981006.002,2,64,0)
</xsl:template>
"KRN",.84,7981006.002,2,65,0)
 
"KRN",.84,7981006.002,2,66,0)
</xsl:stylesheet>
"KRN",.84,7981007.001,-1)
0^24
"KRN",.84,7981007.001,0)
7981007.001^2^^CLINICAL CASE REGISTRIES^Radiology Utilization (HTML)
"KRN",.84,7981007.001,2,0)
^^132^132^3040112^
"KRN",.84,7981007.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981007.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981007.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981007.001,2,4,0)
>
"KRN",.84,7981007.001,2,5,0)
 
"KRN",.84,7981007.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   --> 
"KRN",.84,7981007.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981007.001,2,8,0)
 
"KRN",.84,7981007.001,2,9,0)
<xsl:template match="/">
"KRN",.84,7981007.001,2,10,0)
 <html>
"KRN",.84,7981007.001,2,11,0)
  <head>
"KRN",.84,7981007.001,2,12,0)
   <title>Radiology Utilization</title>
"KRN",.84,7981007.001,2,13,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981007.001,2,14,0)
  </head>
"KRN",.84,7981007.001,2,15,0)
  <body>
"KRN",.84,7981007.001,2,16,0)
   <h1>Radiology Utilization</h1>
"KRN",.84,7981007.001,2,17,0)
   <xsl:call-template name="ReportHeader"/>
"KRN",.84,7981007.001,2,18,0)
   <xsl:apply-templates select="/REPORT/CATEGORY"/>
"KRN",.84,7981007.001,2,19,0)
   <xsl:if test="not(/REPORT/CATEGORY[1])">
"KRN",.84,7981007.001,2,20,0)
    <xsl:call-template name="TableNoData"/>
"KRN",.84,7981007.001,2,21,0)
   </xsl:if>
"KRN",.84,7981007.001,2,22,0)
  </body>
"KRN",.84,7981007.001,2,23,0)
 </html>
"KRN",.84,7981007.001,2,24,0)
</xsl:template>
"KRN",.84,7981007.001,2,25,0)
 
"KRN",.84,7981007.001,2,26,0)
<xsl:template match="REPORT/CATEGORY">
"KRN",.84,7981007.001,2,27,0)
 <div style="page-break-before:always">
"KRN",.84,7981007.001,2,28,0)
  <h2><xsl:value-of select="NAME"/></h2>
"KRN",.84,7981007.001,2,29,0)
  <xsl:call-template name="CategorySummary"/>
"KRN",.84,7981007.001,2,30,0)
  <xsl:apply-templates select="PROCEDURES"/>
"KRN",.84,7981007.001,2,31,0)
  <xsl:apply-templates select="PATIENTS"/>
"KRN",.84,7981007.001,2,32,0)
 </div>
"KRN",.84,7981007.001,2,33,0)
</xsl:template>
"KRN",.84,7981007.001,2,34,0)
 
"KRN",.84,7981007.001,2,35,0)
<xsl:template match="CATEGORY/PATIENTS">
"KRN",.84,7981007.001,2,36,0)
 <h3><xsl:call-template name="HUPatientsHeader"/> by number of procedures</h3>
"KRN",.84,7981007.001,2,37,0)
 <xsl:call-template name="DataGrid"/>
"KRN",.84,7981007.001,2,38,0)
</xsl:template>
"KRN",.84,7981007.001,2,39,0)
 
"KRN",.84,7981007.001,2,40,0)
<xsl:template match="CATEGORY/PROCEDURES">
"KRN",.84,7981007.001,2,41,0)
 <xsl:variable name="minrpnum" select="/REPORT/PARAMETERS/MINRPNUM"/>
"KRN",.84,7981007.001,2,42,0)
 <h3>
"KRN",.84,7981007.001,2,43,0)
  Procedures performed
"KRN",.84,7981007.001,2,44,0)
  <xsl:choose>
"KRN",.84,7981007.001,2,45,0)
   <xsl:when test="$minrpnum>1">
"KRN",.84,7981007.001,2,46,0)
    <xsl:value-of select="$minrpnum"/> times or more
"KRN",.84,7981007.001,2,47,0)
   </xsl:when>
"KRN",.84,7981007.001,2,48,0)
   <xsl:otherwise>at least once</xsl:otherwise>
"KRN",.84,7981007.001,2,49,0)
  </xsl:choose>
"KRN",.84,7981007.001,2,50,0)
 </h3>
"KRN",.84,7981007.001,2,51,0)
 <xsl:call-template name="DataGrid"/>
"KRN",.84,7981007.001,2,52,0)
</xsl:template>
"KRN",.84,7981007.001,2,53,0)
 
"KRN",.84,7981007.001,2,54,0)
<!--[ UTILITIES ]-->
"KRN",.84,7981007.001,2,55,0)
 
"KRN",.84,7981007.001,2,56,0)
<xsl:template name="CategorySummary">
"KRN",.84,7981007.001,2,57,0)
 <xsl:param name="category" select="."/>
"KRN",.84,7981007.001,2,58,0)
 <table width="100%" cellpadding="5" cellspacing="0">
"KRN",.84,7981007.001,2,59,0)
  <thead>
"KRN",.84,7981007.001,2,60,0)
   <tr>
"KRN",.84,7981007.001,2,61,0)
    <th width="33%">Number of Patients</th>
"KRN",.84,7981007.001,2,62,0)
    <th width="33%">Number of Procedures</th>
"KRN",.84,7981007.001,2,63,0)
    <th width="33%">Number of Different Procedures</th>
"KRN",.84,7981007.001,2,64,0)
   </tr>
"KRN",.84,7981007.001,2,65,0)
  </thead>
"KRN",.84,7981007.001,2,66,0)
  <tbody>
"KRN",.84,7981007.001,2,67,0)
   <tr>
"KRN",.84,7981007.001,2,68,0)
    <td><xsl:value-of select="$category/NP"/></td>
"KRN",.84,7981007.001,2,69,0)
    <td><xsl:value-of select="$category/NPR"/></td>
"KRN",.84,7981007.001,2,70,0)
    <td><xsl:value-of select="$category/NDP"/></td>
"KRN",.84,7981007.001,2,71,0)
   </tr>
"KRN",.84,7981007.001,2,72,0)
  </tbody>
"KRN",.84,7981007.001,2,73,0)
 </table>
"KRN",.84,7981007.001,2,74,0)
</xsl:template>
"KRN",.84,7981007.001,2,75,0)
 
"KRN",.84,7981007.001,2,76,0)
<!--[ COLUMN HEADERS ]-->
"KRN",.84,7981007.001,2,77,0)
 
"KRN",.84,7981007.001,2,78,0)
<xsl:template match="COLUMN[@NAME='CPT']">
"KRN",.84,7981007.001,2,79,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981007.001,2,80,0)
  <xsl:with-param name="title" select="'CPT'"/>
"KRN",.84,7981007.001,2,81,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981007.001,2,82,0)
 </xsl:call-template>
"KRN",.84,7981007.001,2,83,0)
</xsl:template>
"KRN",.84,7981007.001,2,84,0)
 
"KRN",.84,7981007.001,2,85,0)
<xsl:template match="COLUMN[@NAME='PATIENTS']">
"KRN",.84,7981007.001,2,86,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981007.001,2,87,0)
  <xsl:with-param name="title" select="'Number of Patients'"/>
"KRN",.84,7981007.001,2,88,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981007.001,2,89,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981007.001,2,90,0)
 </xsl:call-template>
"KRN",.84,7981007.001,2,91,0)
</xsl:template>
"KRN",.84,7981007.001,2,92,0)
 
"KRN",.84,7981007.001,2,93,0)
<xsl:template match="COLUMN[@NAME='TOTAL']">
"KRN",.84,7981007.001,2,94,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981007.001,2,95,0)
  <xsl:with-param name="title" select="'Number of Procedures'"/>
"KRN",.84,7981007.001,2,96,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981007.001,2,97,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981007.001,2,98,0)
 </xsl:call-template>
"KRN",.84,7981007.001,2,99,0)
</xsl:template>
"KRN",.84,7981007.001,2,100,0)
 
"KRN",.84,7981007.001,2,101,0)
<xsl:template match="COLUMN[@NAME='UNIQUE']">
"KRN",.84,7981007.001,2,102,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981007.001,2,103,0)
  <xsl:with-param name="title" select="'Number of Different Procedures'"/>
"KRN",.84,7981007.001,2,104,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981007.001,2,105,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981007.001,2,106,0)
 </xsl:call-template>
"KRN",.84,7981007.001,2,107,0)
</xsl:template>
"KRN",.84,7981007.001,2,108,0)
 
"KRN",.84,7981007.001,2,109,0)
<!--[ REPORT PARAMETERS ]-->
"KRN",.84,7981007.001,2,110,0)
 
"KRN",.84,7981007.001,2,111,0)
<xsl:template match="PARAMETERS/MAXUTNUM">
"KRN",.84,7981007.001,2,112,0)
 <tr>
"KRN",.84,7981007.001,2,113,0)
  <th scope="row">MaxUtil:&#160;</th>
"KRN",.84,7981007.001,2,114,0)
  <td>
"KRN",.84,7981007.001,2,115,0)
   <xsl:value-of select="."/>
"KRN",.84,7981007.001,2,116,0)
   (maximum number of patients with highest utilization to display)
"KRN",.84,7981007.001,2,117,0)
  </td>
"KRN",.84,7981007.001,2,118,0)
 </tr>
"KRN",.84,7981007.001,2,119,0)
</xsl:template>
"KRN",.84,7981007.001,2,120,0)
 
"KRN",.84,7981007.001,2,121,0)
<xsl:template match="PARAMETERS/MINRPNUM">
"KRN",.84,7981007.001,2,122,0)
 <tr>
"KRN",.84,7981007.001,2,123,0)
  <th scope="row">MinProc:&#160;</th>
"KRN",.84,7981007.001,2,124,0)
  <td>
"KRN",.84,7981007.001,2,125,0)
   <xsl:value-of select="."/>
"KRN",.84,7981007.001,2,126,0)
   (minimum number of times a procedure should be performed
"KRN",.84,7981007.001,2,127,0)
   to be included in the report)
"KRN",.84,7981007.001,2,128,0)
  </td>
"KRN",.84,7981007.001,2,129,0)
 </tr>
"KRN",.84,7981007.001,2,130,0)
</xsl:template>
"KRN",.84,7981007.001,2,131,0)
 
"KRN",.84,7981007.001,2,132,0)
</xsl:stylesheet>
"KRN",.84,7981007.002,-1)
0^26
"KRN",.84,7981007.002,0)
7981007.002^2^^CLINICAL CASE REGISTRIES^Radiology Utilization (CSV)
"KRN",.84,7981007.002,2,0)
^.844^48^48^3031212^^
"KRN",.84,7981007.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981007.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981007.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981007.002,2,4,0)
>
"KRN",.84,7981007.002,2,5,0)
 
"KRN",.84,7981007.002,2,6,0)
<xsl:import href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981007.002,2,7,0)
 
"KRN",.84,7981007.002,2,8,0)
<xsl:variable name="UTILIZATION_HEADER"                                         
"KRN",.84,7981007.002,2,9,0)
     select="'Radiology Utilization'"/>
"KRN",.84,7981007.002,2,10,0)
 
"KRN",.84,7981007.002,2,11,0)
<xsl:template match="/">
"KRN",.84,7981007.002,2,12,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981007.002,2,13,0)
  <xsl:with-param name="subttl" select="'Procedures'"/>
"KRN",.84,7981007.002,2,14,0)
  <xsl:with-param name="table" select="'PROCEDURES'"/>
"KRN",.84,7981007.002,2,15,0)
 </xsl:call-template>
"KRN",.84,7981007.002,2,16,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981007.002,2,17,0)
  <xsl:with-param name="subttl" select="'Patients with highest utilization'"/>
"KRN",.84,7981007.002,2,18,0)
  <xsl:with-param name="table" select="'PATIENTS'"/>
"KRN",.84,7981007.002,2,19,0)
 </xsl:call-template>
"KRN",.84,7981007.002,2,20,0)
</xsl:template>
"KRN",.84,7981007.002,2,21,0)
 
"KRN",.84,7981007.002,2,22,0)
<!--[ COLUMN HEADERS ]-->
"KRN",.84,7981007.002,2,23,0)
 
"KRN",.84,7981007.002,2,24,0)
<xsl:template match="COLUMN[@NAME='CPT']">
"KRN",.84,7981007.002,2,25,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981007.002,2,26,0)
  <xsl:with-param name="title" select="'CPT'"/>
"KRN",.84,7981007.002,2,27,0)
 </xsl:call-template>
"KRN",.84,7981007.002,2,28,0)
</xsl:template>
"KRN",.84,7981007.002,2,29,0)
 
"KRN",.84,7981007.002,2,30,0)
<xsl:template match="COLUMN[@NAME='PATIENTS']">
"KRN",.84,7981007.002,2,31,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981007.002,2,32,0)
  <xsl:with-param name="title" select="'Number of Patients'"/>
"KRN",.84,7981007.002,2,33,0)
 </xsl:call-template>
"KRN",.84,7981007.002,2,34,0)
</xsl:template>
"KRN",.84,7981007.002,2,35,0)
 
"KRN",.84,7981007.002,2,36,0)
<xsl:template match="COLUMN[@NAME='TOTAL']">
"KRN",.84,7981007.002,2,37,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981007.002,2,38,0)
  <xsl:with-param name="title" select="'Number of Procedures'"/>
"KRN",.84,7981007.002,2,39,0)
 </xsl:call-template>
"KRN",.84,7981007.002,2,40,0)
</xsl:template>
"KRN",.84,7981007.002,2,41,0)
 
"KRN",.84,7981007.002,2,42,0)
<xsl:template match="COLUMN[@NAME='UNIQUE']">
"KRN",.84,7981007.002,2,43,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981007.002,2,44,0)
  <xsl:with-param name="title" select="'Number of Different Procedures'"/>
"KRN",.84,7981007.002,2,45,0)
 </xsl:call-template>
"KRN",.84,7981007.002,2,46,0)
</xsl:template>
"KRN",.84,7981007.002,2,47,0)
 
"KRN",.84,7981007.002,2,48,0)
</xsl:stylesheet>
"KRN",.84,7981008.001,-1)
0^39
"KRN",.84,7981008.001,0)
7981008.001^2^^CLINICAL CASE REGISTRIES^VERA Reimbursement Report (HTML)
"KRN",.84,7981008.001,2,0)
^.844^108^108^3031212^
"KRN",.84,7981008.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981008.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981008.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981008.001,2,4,0)
>
"KRN",.84,7981008.001,2,5,0)
 
"KRN",.84,7981008.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   --> 
"KRN",.84,7981008.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981008.001,2,8,0)
<xsl:import  href="template://report/996/1"/>  <!-- Pharmacy -->
"KRN",.84,7981008.001,2,9,0)
 
"KRN",.84,7981008.001,2,10,0)
<xsl:template match="/">
"KRN",.84,7981008.001,2,11,0)
 <html>
"KRN",.84,7981008.001,2,12,0)
  <head>
"KRN",.84,7981008.001,2,13,0)
   <title>VERA Reimbursement Report</title>
"KRN",.84,7981008.001,2,14,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981008.001,2,15,0)
  </head>
"KRN",.84,7981008.001,2,16,0)
  <body>
"KRN",.84,7981008.001,2,17,0)
   <h1>VERA Reimbursement Report</h1>
"KRN",.84,7981008.001,2,18,0)
   <xsl:call-template name="ReportHeader"/>
"KRN",.84,7981008.001,2,19,0)
   <div style="page-break-before:always">
"KRN",.84,7981008.001,2,20,0)
    <xsl:call-template name="ReportSummary"/>
"KRN",.84,7981008.001,2,21,0)
    <xsl:apply-templates select="/REPORT/DRUGS"/>
"KRN",.84,7981008.001,2,22,0)
    <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981008.001,2,23,0)
   </div>
"KRN",.84,7981008.001,2,24,0)
  </body>
"KRN",.84,7981008.001,2,25,0)
 </html>
"KRN",.84,7981008.001,2,26,0)
</xsl:template>
"KRN",.84,7981008.001,2,27,0)
 
"KRN",.84,7981008.001,2,28,0)
<xsl:template match="REPORT/DRUGS">
"KRN",.84,7981008.001,2,29,0)
 <h2>ARV Drugs</h2>
"KRN",.84,7981008.001,2,30,0)
 <xsl:call-template name="DataGrid"/>
"KRN",.84,7981008.001,2,31,0)
</xsl:template>
"KRN",.84,7981008.001,2,32,0)
 
"KRN",.84,7981008.001,2,33,0)
<xsl:template match="REPORT/PATIENTS">
"KRN",.84,7981008.001,2,34,0)
 <h2>Patients</h2>
"KRN",.84,7981008.001,2,35,0)
 <xsl:call-template name="DataGrid"/>
"KRN",.84,7981008.001,2,36,0)
</xsl:template>
"KRN",.84,7981008.001,2,37,0)
 
"KRN",.84,7981008.001,2,38,0)
<!--[ TABLE HEADERS ]-->
"KRN",.84,7981008.001,2,39,0)
 
"KRN",.84,7981008.001,2,40,0)
<xsl:template match="COLUMN[@NAME='ARV']">
"KRN",.84,7981008.001,2,41,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981008.001,2,42,0)
  <xsl:with-param name="title" select="'ARV Drugs'"/>
"KRN",.84,7981008.001,2,43,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981008.001,2,44,0)
 </xsl:call-template>
"KRN",.84,7981008.001,2,45,0)
</xsl:template>
"KRN",.84,7981008.001,2,46,0)
 
"KRN",.84,7981008.001,2,47,0)
<xsl:template match="COLUMN[@NAME='COMPLEX']">
"KRN",.84,7981008.001,2,48,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981008.001,2,49,0)
  <xsl:with-param name="title" select="'Complex Care'"/>
"KRN",.84,7981008.001,2,50,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981008.001,2,51,0)
 </xsl:call-template>
"KRN",.84,7981008.001,2,52,0)
</xsl:template>
"KRN",.84,7981008.001,2,53,0)
 
"KRN",.84,7981008.001,2,54,0)
<xsl:template match="COLUMN[@NAME='NP']">
"KRN",.84,7981008.001,2,55,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981008.001,2,56,0)
  <xsl:with-param name="title" select="'Number of Patients'"/>
"KRN",.84,7981008.001,2,57,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981008.001,2,58,0)
 </xsl:call-template>
"KRN",.84,7981008.001,2,59,0)
</xsl:template>
"KRN",.84,7981008.001,2,60,0)
 
"KRN",.84,7981008.001,2,61,0)
<xsl:template match="COLUMN[@NAME='NPAIDS']">
"KRN",.84,7981008.001,2,62,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981008.001,2,63,0)
  <xsl:with-param name="title" select="'Number of AIDS OI Patients'"/>
"KRN",.84,7981008.001,2,64,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981008.001,2,65,0)
 </xsl:call-template>
"KRN",.84,7981008.001,2,66,0)
</xsl:template>
"KRN",.84,7981008.001,2,67,0)
 
"KRN",.84,7981008.001,2,68,0)
<xsl:template match="COLUMN[@NAME='NPHIV']">
"KRN",.84,7981008.001,2,69,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981008.001,2,70,0)
  <xsl:with-param name="title"
"KRN",.84,7981008.001,2,71,0)
                  select="'Number of HIV+ (no AIDS OI) Patients'"/>
"KRN",.84,7981008.001,2,72,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981008.001,2,73,0)
 </xsl:call-template>
"KRN",.84,7981008.001,2,74,0)
</xsl:template>
"KRN",.84,7981008.001,2,75,0)
 
"KRN",.84,7981008.001,2,76,0)
<!--[ TABLE CELLS ]-->
"KRN",.84,7981008.001,2,77,0)
 
"KRN",.84,7981008.001,2,78,0)
<xsl:template match="PATIENT/ARV|PATIENT/COMPLEX">
"KRN",.84,7981008.001,2,79,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981008.001,2,80,0)
  <xsl:with-param name="yesno" select="1"/>
"KRN",.84,7981008.001,2,81,0)
 </xsl:call-template>
"KRN",.84,7981008.001,2,82,0)
</xsl:template>
"KRN",.84,7981008.001,2,83,0)
 
"KRN",.84,7981008.001,2,84,0)
<!--[ UTILITIES ]-->
"KRN",.84,7981008.001,2,85,0)
 
"KRN",.84,7981008.001,2,86,0)
<xsl:template name="ReportSummary">
"KRN",.84,7981008.001,2,87,0)
 <xsl:param name="summary" select="/REPORT/SUMMARY"/>
"KRN",.84,7981008.001,2,88,0)
 <table width="100%" cellpadding="5" cellspacing="0">
"KRN",.84,7981008.001,2,89,0)
  <thead>
"KRN",.84,7981008.001,2,90,0)
   <tr>
"KRN",.84,7981008.001,2,91,0)
    <th width="25%">Number of Patients</th>
"KRN",.84,7981008.001,2,92,0)
    <th width="25%">Number of Basic Care Patients</th>
"KRN",.84,7981008.001,2,93,0)
    <th width="25%">Number of Complex Care Patients</th>
"KRN",.84,7981008.001,2,94,0)
    <th width="25%">Number of Patients Received ARV Drugs</th>
"KRN",.84,7981008.001,2,95,0)
   </tr>
"KRN",.84,7981008.001,2,96,0)
  </thead>
"KRN",.84,7981008.001,2,97,0)
  <tbody>
"KRN",.84,7981008.001,2,98,0)
   <tr>
"KRN",.84,7981008.001,2,99,0)
    <td><xsl:value-of select="$summary/NP"/></td>
"KRN",.84,7981008.001,2,100,0)
    <td><xsl:value-of select="$summary/NPBASIC"/></td>
"KRN",.84,7981008.001,2,101,0)
    <td><xsl:value-of select="$summary/NPCOMPLEX"/></td>
"KRN",.84,7981008.001,2,102,0)
    <td><xsl:value-of select="$summary/NPARV"/></td>
"KRN",.84,7981008.001,2,103,0)
   </tr>
"KRN",.84,7981008.001,2,104,0)
  </tbody>
"KRN",.84,7981008.001,2,105,0)
 </table>
"KRN",.84,7981008.001,2,106,0)
</xsl:template>
"KRN",.84,7981008.001,2,107,0)
 
"KRN",.84,7981008.001,2,108,0)
</xsl:stylesheet>
"KRN",.84,7981008.002,-1)
0^46
"KRN",.84,7981008.002,0)
7981008.002^2^^CLINICAL CASE REGISTRIES^VERA Reimbursement Report (CSV)
"KRN",.84,7981008.002,2,0)
^.844^66^66^3031212^
"KRN",.84,7981008.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981008.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981008.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981008.002,2,4,0)
>
"KRN",.84,7981008.002,2,5,0)
 
"KRN",.84,7981008.002,2,6,0)
<xsl:import href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981008.002,2,7,0)
 
"KRN",.84,7981008.002,2,8,0)
<xsl:template match="/">
"KRN",.84,7981008.002,2,9,0)
 <xsl:apply-templates select="/REPORT/DRUGS"/>
"KRN",.84,7981008.002,2,10,0)
 <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981008.002,2,11,0)
</xsl:template>
"KRN",.84,7981008.002,2,12,0)
 
"KRN",.84,7981008.002,2,13,0)
<xsl:template match="REPORT/DRUGS">
"KRN",.84,7981008.002,2,14,0)
 <xsl:text>VERA Reimbursement Report (ARV Drugs)</xsl:text>
"KRN",.84,7981008.002,2,15,0)
 <xsl:call-template name="DataGrid"/>
"KRN",.84,7981008.002,2,16,0)
 <xsl:value-of select="$FILESWITCH"/>
"KRN",.84,7981008.002,2,17,0)
</xsl:template>
"KRN",.84,7981008.002,2,18,0)
 
"KRN",.84,7981008.002,2,19,0)
<xsl:template match="REPORT/PATIENTS">
"KRN",.84,7981008.002,2,20,0)
 <xsl:text>VERA Reimbursement Report (Patients)</xsl:text>
"KRN",.84,7981008.002,2,21,0)
 <xsl:call-template name="DataGrid"/>
"KRN",.84,7981008.002,2,22,0)
 <xsl:value-of select="$FILESWITCH"/>
"KRN",.84,7981008.002,2,23,0)
</xsl:template>
"KRN",.84,7981008.002,2,24,0)
 
"KRN",.84,7981008.002,2,25,0)
<!--[ TABLE HEADERS ]-->
"KRN",.84,7981008.002,2,26,0)
 
"KRN",.84,7981008.002,2,27,0)
<xsl:template match="COLUMN[@NAME='ARV']">
"KRN",.84,7981008.002,2,28,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981008.002,2,29,0)
  <xsl:with-param name="title" select="'ARV Drugs'"/>
"KRN",.84,7981008.002,2,30,0)
 </xsl:call-template>
"KRN",.84,7981008.002,2,31,0)
</xsl:template>
"KRN",.84,7981008.002,2,32,0)
 
"KRN",.84,7981008.002,2,33,0)
<xsl:template match="COLUMN[@NAME='COMPLEX']">
"KRN",.84,7981008.002,2,34,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981008.002,2,35,0)
  <xsl:with-param name="title" select="'Complex Care'"/>
"KRN",.84,7981008.002,2,36,0)
 </xsl:call-template>
"KRN",.84,7981008.002,2,37,0)
</xsl:template>
"KRN",.84,7981008.002,2,38,0)
 
"KRN",.84,7981008.002,2,39,0)
<xsl:template match="COLUMN[@NAME='NP']">
"KRN",.84,7981008.002,2,40,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981008.002,2,41,0)
  <xsl:with-param name="title" select="'Number of Patients'"/>
"KRN",.84,7981008.002,2,42,0)
 </xsl:call-template>
"KRN",.84,7981008.002,2,43,0)
</xsl:template>
"KRN",.84,7981008.002,2,44,0)
 
"KRN",.84,7981008.002,2,45,0)
<xsl:template match="COLUMN[@NAME='NPAIDS']">
"KRN",.84,7981008.002,2,46,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981008.002,2,47,0)
  <xsl:with-param name="title" select="'Number of AIDS OI Patients'"/>
"KRN",.84,7981008.002,2,48,0)
 </xsl:call-template>
"KRN",.84,7981008.002,2,49,0)
</xsl:template>
"KRN",.84,7981008.002,2,50,0)
 
"KRN",.84,7981008.002,2,51,0)
<xsl:template match="COLUMN[@NAME='NPHIV']">
"KRN",.84,7981008.002,2,52,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981008.002,2,53,0)
  <xsl:with-param name="title"
"KRN",.84,7981008.002,2,54,0)
                  select="'Number of HIV+ (no AIDS OI) Patients'"/>
"KRN",.84,7981008.002,2,55,0)
 </xsl:call-template>
"KRN",.84,7981008.002,2,56,0)
</xsl:template>
"KRN",.84,7981008.002,2,57,0)
 
"KRN",.84,7981008.002,2,58,0)
<!--[ TABLE CELLS ]-->
"KRN",.84,7981008.002,2,59,0)
 
"KRN",.84,7981008.002,2,60,0)
<xsl:template match="PATIENT/ARV|PATIENT/COMPLEX">
"KRN",.84,7981008.002,2,61,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981008.002,2,62,0)
  <xsl:with-param name="yesno" select="1"/>
"KRN",.84,7981008.002,2,63,0)
 </xsl:call-template>
"KRN",.84,7981008.002,2,64,0)
</xsl:template>
"KRN",.84,7981008.002,2,65,0)
 
"KRN",.84,7981008.002,2,66,0)
</xsl:stylesheet>
"KRN",.84,7981009.001,-1)
0^41
"KRN",.84,7981009.001,0)
7981009.001^2^^CLINICAL CASE REGISTRIES^Pharmacy Prescription Utilization (HTML)
"KRN",.84,7981009.001,2,0)
^.844^207^207^3040112^
"KRN",.84,7981009.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981009.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981009.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981009.001,2,4,0)
>
"KRN",.84,7981009.001,2,5,0)
 
"KRN",.84,7981009.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   --> 
"KRN",.84,7981009.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981009.001,2,8,0)
<xsl:import  href="template://report/996/1"/>  <!-- Pharmacy -->
"KRN",.84,7981009.001,2,9,0)
 
"KRN",.84,7981009.001,2,10,0)
<xsl:template match="/">
"KRN",.84,7981009.001,2,11,0)
 <html>
"KRN",.84,7981009.001,2,12,0)
  <head>
"KRN",.84,7981009.001,2,13,0)
   <title>Pharmacy Prescription Utilization</title>
"KRN",.84,7981009.001,2,14,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981009.001,2,15,0)
  </head>
"KRN",.84,7981009.001,2,16,0)
  <body>
"KRN",.84,7981009.001,2,17,0)
   <h1>Pharmacy Prescription Utilization</h1>
"KRN",.84,7981009.001,2,18,0)
   <xsl:call-template name="ReportHeader"/>
"KRN",.84,7981009.001,2,19,0)
   <xsl:apply-templates select="/REPORT/CATEGORY"/>
"KRN",.84,7981009.001,2,20,0)
   <xsl:if test="not(/REPORT/CATEGORY[1])">
"KRN",.84,7981009.001,2,21,0)
    <xsl:call-template name="TableNoData"/>
"KRN",.84,7981009.001,2,22,0)
   </xsl:if>
"KRN",.84,7981009.001,2,23,0)
  </body>
"KRN",.84,7981009.001,2,24,0)
 </html>
"KRN",.84,7981009.001,2,25,0)
</xsl:template>
"KRN",.84,7981009.001,2,26,0)
 
"KRN",.84,7981009.001,2,27,0)
<xsl:template match="REPORT/CATEGORY">
"KRN",.84,7981009.001,2,28,0)
 <xsl:if test="OUTPATIENTS">
"KRN",.84,7981009.001,2,29,0)
  <div style="page-break-before:always">
"KRN",.84,7981009.001,2,30,0)
   <h2>Selected Outpatient Activity<br/><xsl:value-of select="NAME"/></h2>
"KRN",.84,7981009.001,2,31,0)
   <xsl:call-template name="OutpatientSummary"/>
"KRN",.84,7981009.001,2,32,0)
   <xsl:apply-templates select="OUTPATIENTS"/>
"KRN",.84,7981009.001,2,33,0)
  </div>
"KRN",.84,7981009.001,2,34,0)
 </xsl:if>
"KRN",.84,7981009.001,2,35,0)
 <xsl:if test="INPATIENTS">
"KRN",.84,7981009.001,2,36,0)
  <div style="page-break-before:always">
"KRN",.84,7981009.001,2,37,0)
   <h2>Selected Inpatient Activity<br/><xsl:value-of select="NAME"/></h2>
"KRN",.84,7981009.001,2,38,0)
   <xsl:call-template name="InpatientSummary"/>
"KRN",.84,7981009.001,2,39,0)
   <xsl:apply-templates select="INPATIENTS"/>
"KRN",.84,7981009.001,2,40,0)
  </div>
"KRN",.84,7981009.001,2,41,0)
 </xsl:if>
"KRN",.84,7981009.001,2,42,0)
</xsl:template>
"KRN",.84,7981009.001,2,43,0)
 
"KRN",.84,7981009.001,2,44,0)
<xsl:template match="INPATIENTS/*">
"KRN",.84,7981009.001,2,45,0)
 <xsl:variable name="name" select="name(.)"/>
"KRN",.84,7981009.001,2,46,0)
 <xsl:choose>
"KRN",.84,7981009.001,2,47,0)
  <xsl:when test="$name='DOSES'">
"KRN",.84,7981009.001,2,48,0)
   <br clear="both"/>
"KRN",.84,7981009.001,2,49,0)
   <xsl:call-template name="DataGrid">
"KRN",.84,7981009.001,2,50,0)
    <xsl:with-param name="divstyle" select="'width:50%'"/>
"KRN",.84,7981009.001,2,51,0)
   </xsl:call-template>
"KRN",.84,7981009.001,2,52,0)
  </xsl:when>
"KRN",.84,7981009.001,2,53,0)
  <xsl:when test="$name='DRUGS'">
"KRN",.84,7981009.001,2,54,0)
   <h3>Inpatient Drugs</h3>
"KRN",.84,7981009.001,2,55,0)
   <xsl:call-template name="DataGrid"/>
"KRN",.84,7981009.001,2,56,0)
  </xsl:when>
"KRN",.84,7981009.001,2,57,0)
  <xsl:when test="$name='HU_DOSES'">
"KRN",.84,7981009.001,2,58,0)
   <h3><xsl:call-template name="HUPatientsHeader"/> by number of doses</h3>
"KRN",.84,7981009.001,2,59,0)
   <xsl:call-template name="DataGrid"/>
"KRN",.84,7981009.001,2,60,0)
  </xsl:when>
"KRN",.84,7981009.001,2,61,0)
 </xsl:choose>
"KRN",.84,7981009.001,2,62,0)
</xsl:template>
"KRN",.84,7981009.001,2,63,0)
 
"KRN",.84,7981009.001,2,64,0)
<xsl:template match="OUTPATIENTS/*">
"KRN",.84,7981009.001,2,65,0)
 <xsl:variable name="name" select="name(.)"/>
"KRN",.84,7981009.001,2,66,0)
 <xsl:choose>
"KRN",.84,7981009.001,2,67,0)
  <xsl:when test="$name='FILLS'">
"KRN",.84,7981009.001,2,68,0)
   <br clear="both"/>
"KRN",.84,7981009.001,2,69,0)
   <xsl:call-template name="DataGrid">
"KRN",.84,7981009.001,2,70,0)
    <xsl:with-param name="divstyle" select="'width:50%'"/>
"KRN",.84,7981009.001,2,71,0)
   </xsl:call-template>
"KRN",.84,7981009.001,2,72,0)
  </xsl:when>
"KRN",.84,7981009.001,2,73,0)
  <xsl:when test="$name='DRUGS'">
"KRN",.84,7981009.001,2,74,0)
   <h3>Outpatient Drugs</h3>
"KRN",.84,7981009.001,2,75,0)
   <xsl:call-template name="DataGrid"/>
"KRN",.84,7981009.001,2,76,0)
  </xsl:when>
"KRN",.84,7981009.001,2,77,0)
  <xsl:when test="$name='HU_FILLS'">
"KRN",.84,7981009.001,2,78,0)
   <h3><xsl:call-template name="HUPatientsHeader"/> by number of fills</h3>
"KRN",.84,7981009.001,2,79,0)
   <xsl:call-template name="DataGrid"/>
"KRN",.84,7981009.001,2,80,0)
  </xsl:when>
"KRN",.84,7981009.001,2,81,0)
 </xsl:choose>
"KRN",.84,7981009.001,2,82,0)
</xsl:template>
"KRN",.84,7981009.001,2,83,0)
 
"KRN",.84,7981009.001,2,84,0)
<!--[ UTILITIES ]-->
"KRN",.84,7981009.001,2,85,0)
 
"KRN",.84,7981009.001,2,86,0)
<xsl:template name="InpatientSummary">
"KRN",.84,7981009.001,2,87,0)
 <xsl:param name="category" select="."/>
"KRN",.84,7981009.001,2,88,0)
 <xsl:variable name="IP" select="$category/INPATIENTS"/>
"KRN",.84,7981009.001,2,89,0)
 <table width="100%" cellpadding="5" cellspacing="0">
"KRN",.84,7981009.001,2,90,0)
  <thead>
"KRN",.84,7981009.001,2,91,0)
   <tr>
"KRN",.84,7981009.001,2,92,0)
    <th width="33%">Number of Patients</th>
"KRN",.84,7981009.001,2,93,0)
    <th width="33%">Number of Doses</th>
"KRN",.84,7981009.001,2,94,0)
    <th width="33%">Number of Different Drugs</th>
"KRN",.84,7981009.001,2,95,0)
   </tr>
"KRN",.84,7981009.001,2,96,0)
  </thead>
"KRN",.84,7981009.001,2,97,0)
  <tbody>
"KRN",.84,7981009.001,2,98,0)
   <tr>
"KRN",.84,7981009.001,2,99,0)
    <td><xsl:value-of select="$IP/NP"/></td>
"KRN",.84,7981009.001,2,100,0)
    <td><xsl:value-of select="$IP/NRX"/></td>
"KRN",.84,7981009.001,2,101,0)
    <td><xsl:value-of select="$IP/ND"/></td>
"KRN",.84,7981009.001,2,102,0)
   </tr>
"KRN",.84,7981009.001,2,103,0)
  </tbody>
"KRN",.84,7981009.001,2,104,0)
 </table>
"KRN",.84,7981009.001,2,105,0)
</xsl:template>
"KRN",.84,7981009.001,2,106,0)
 
"KRN",.84,7981009.001,2,107,0)
<xsl:template name="OutpatientSummary">
"KRN",.84,7981009.001,2,108,0)
 <xsl:param name="category" select="."/>
"KRN",.84,7981009.001,2,109,0)
 <xsl:variable name="OP" select="$category/OUTPATIENTS"/>
"KRN",.84,7981009.001,2,110,0)
 <table width="100%" cellpadding="5" cellspacing="0">
"KRN",.84,7981009.001,2,111,0)
  <thead>
"KRN",.84,7981009.001,2,112,0)
   <tr>
"KRN",.84,7981009.001,2,113,0)
    <th width="33%">Number of Patients</th>
"KRN",.84,7981009.001,2,114,0)
    <th width="33%">Number of Fills</th>
"KRN",.84,7981009.001,2,115,0)
    <th width="33%">Number of Different Drugs</th>
"KRN",.84,7981009.001,2,116,0)
   </tr>
"KRN",.84,7981009.001,2,117,0)
  </thead>
"KRN",.84,7981009.001,2,118,0)
  <tbody>
"KRN",.84,7981009.001,2,119,0)
   <tr>
"KRN",.84,7981009.001,2,120,0)
    <td><xsl:value-of select="$OP/NP"/></td>
"KRN",.84,7981009.001,2,121,0)
    <td><xsl:value-of select="$OP/NRX"/></td>
"KRN",.84,7981009.001,2,122,0)
    <td><xsl:value-of select="$OP/ND"/></td>
"KRN",.84,7981009.001,2,123,0)
   </tr>
"KRN",.84,7981009.001,2,124,0)
  </tbody>
"KRN",.84,7981009.001,2,125,0)
 </table>
"KRN",.84,7981009.001,2,126,0)
</xsl:template>
"KRN",.84,7981009.001,2,127,0)
 
"KRN",.84,7981009.001,2,128,0)
<!--[ COLUMN HEADERS ]-->
"KRN",.84,7981009.001,2,129,0)
 
"KRN",.84,7981009.001,2,130,0)
<xsl:template match="COLUMN[@NAME='MAXNP']">
"KRN",.84,7981009.001,2,131,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981009.001,2,132,0)
  <xsl:with-param name="title"
"KRN",.84,7981009.001,2,133,0)
       select="'Number of Patients with Max. Utilization'"/>
"KRN",.84,7981009.001,2,134,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981009.001,2,135,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981009.001,2,136,0)
 </xsl:call-template>
"KRN",.84,7981009.001,2,137,0)
</xsl:template>
"KRN",.84,7981009.001,2,138,0)
 
"KRN",.84,7981009.001,2,139,0)
<xsl:template match="COLUMN[@NAME='MAXNRPP']">
"KRN",.84,7981009.001,2,140,0)
 <xsl:variable name="tblname" select="../@NAME"/>
"KRN",.84,7981009.001,2,141,0)
 <xsl:variable name="title">
"KRN",.84,7981009.001,2,142,0)
  <xsl:text>Maximum Number of </xsl:text>
"KRN",.84,7981009.001,2,143,0)
  <xsl:choose>
"KRN",.84,7981009.001,2,144,0)
   <xsl:when test="contains($tblname,'DOSE')">Doses</xsl:when>
"KRN",.84,7981009.001,2,145,0)
   <xsl:when test="contains($tblname,'FILL')">Fills</xsl:when>
"KRN",.84,7981009.001,2,146,0)
   <xsl:otherwise>Doses/Fills</xsl:otherwise>
"KRN",.84,7981009.001,2,147,0)
  </xsl:choose>
"KRN",.84,7981009.001,2,148,0)
  <xsl:text> per Patient</xsl:text>
"KRN",.84,7981009.001,2,149,0)
 </xsl:variable>
"KRN",.84,7981009.001,2,150,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981009.001,2,151,0)
  <xsl:with-param name="title" select="$title"/>
"KRN",.84,7981009.001,2,152,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981009.001,2,153,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981009.001,2,154,0)
 </xsl:call-template>
"KRN",.84,7981009.001,2,155,0)
</xsl:template>
"KRN",.84,7981009.001,2,156,0)
 
"KRN",.84,7981009.001,2,157,0)
<xsl:template match="TBLDEF[contains(@NAME,'HU_')]/COLUMN[@NAME='NAME']">
"KRN",.84,7981009.001,2,158,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981009.001,2,159,0)
  <xsl:with-param name="title" select="'Patient Name'"/>
"KRN",.84,7981009.001,2,160,0)
 </xsl:call-template>
"KRN",.84,7981009.001,2,161,0)
</xsl:template>
"KRN",.84,7981009.001,2,162,0)
 
"KRN",.84,7981009.001,2,163,0)
<xsl:template match="COLUMN[@NAME='ND']">
"KRN",.84,7981009.001,2,164,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981009.001,2,165,0)
  <xsl:with-param name="title" select="'Number of Different Drugs'"/>
"KRN",.84,7981009.001,2,166,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981009.001,2,167,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981009.001,2,168,0)
 </xsl:call-template>
"KRN",.84,7981009.001,2,169,0)
</xsl:template>
"KRN",.84,7981009.001,2,170,0)
 
"KRN",.84,7981009.001,2,171,0)
<xsl:template match="COLUMN[@NAME='NP']">
"KRN",.84,7981009.001,2,172,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981009.001,2,173,0)
  <xsl:with-param name="title" select="'Number of Patients'"/>
"KRN",.84,7981009.001,2,174,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981009.001,2,175,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981009.001,2,176,0)
 </xsl:call-template>
"KRN",.84,7981009.001,2,177,0)
</xsl:template>
"KRN",.84,7981009.001,2,178,0)
 
"KRN",.84,7981009.001,2,179,0)
<xsl:template match="COLUMN[@NAME='NRX']">
"KRN",.84,7981009.001,2,180,0)
 <xsl:variable name="tblname" select="../@NAME"/>
"KRN",.84,7981009.001,2,181,0)
 <xsl:variable name="title">
"KRN",.84,7981009.001,2,182,0)
  <xsl:choose>
"KRN",.84,7981009.001,2,183,0)
   <xsl:when test="contains($tblname,'DOSE')">Number of Doses</xsl:when>
"KRN",.84,7981009.001,2,184,0)
   <xsl:when test="contains($tblname,'FILL')">Number of Fills</xsl:when>
"KRN",.84,7981009.001,2,185,0)
   <xsl:otherwise>Number of Doses/Fills</xsl:otherwise>
"KRN",.84,7981009.001,2,186,0)
  </xsl:choose>
"KRN",.84,7981009.001,2,187,0)
 </xsl:variable>
"KRN",.84,7981009.001,2,188,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981009.001,2,189,0)
  <xsl:with-param name="title" select="$title"/>
"KRN",.84,7981009.001,2,190,0)
  <xsl:with-param name="sortmode" select="':DESC'"/>
"KRN",.84,7981009.001,2,191,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981009.001,2,192,0)
 </xsl:call-template> 
"KRN",.84,7981009.001,2,193,0)
</xsl:template>
"KRN",.84,7981009.001,2,194,0)
 
"KRN",.84,7981009.001,2,195,0)
<!--[ REPORT PARAMETERS ]-->
"KRN",.84,7981009.001,2,196,0)
 
"KRN",.84,7981009.001,2,197,0)
<xsl:template match="PARAMETERS/MAXUTNUM">
"KRN",.84,7981009.001,2,198,0)
 <tr>
"KRN",.84,7981009.001,2,199,0)
  <th scope="row">MaxUtil:&#160;</th>
"KRN",.84,7981009.001,2,200,0)
  <td>
"KRN",.84,7981009.001,2,201,0)
   <xsl:value-of select="."/>
"KRN",.84,7981009.001,2,202,0)
   (maximum number of patients with highest utilization to display)
"KRN",.84,7981009.001,2,203,0)
  </td>
"KRN",.84,7981009.001,2,204,0)
 </tr>
"KRN",.84,7981009.001,2,205,0)
</xsl:template>
"KRN",.84,7981009.001,2,206,0)
 
"KRN",.84,7981009.001,2,207,0)
</xsl:stylesheet>
"KRN",.84,7981009.002,-1)
0^54
"KRN",.84,7981009.002,0)
7981009.002^2^^CLINICAL CASE REGISTRIES^Pharmacy Prescription Utilization (CSV)
"KRN",.84,7981009.002,2,0)
^.844^101^101^3031212^^
"KRN",.84,7981009.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981009.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981009.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981009.002,2,4,0)
>
"KRN",.84,7981009.002,2,5,0)
 
"KRN",.84,7981009.002,2,6,0)
<xsl:import href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981009.002,2,7,0)
 
"KRN",.84,7981009.002,2,8,0)
<xsl:variable name="UTILIZATION_HEADER"                                         
"KRN",.84,7981009.002,2,9,0)
     select="'Pharmacy Prescription Utilization'"/>
"KRN",.84,7981009.002,2,10,0)
 
"KRN",.84,7981009.002,2,11,0)
<xsl:template match="/">
"KRN",.84,7981009.002,2,12,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981009.002,2,13,0)
  <xsl:with-param name="subttl" select="'Fills'"/>
"KRN",.84,7981009.002,2,14,0)
  <xsl:with-param name="table" select="'FILLS'"/>
"KRN",.84,7981009.002,2,15,0)
  <xsl:with-param name="parent" select="'OUTPATIENTS'"/>
"KRN",.84,7981009.002,2,16,0)
 </xsl:call-template>
"KRN",.84,7981009.002,2,17,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981009.002,2,18,0)
  <xsl:with-param name="subttl" select="'Outpatient Drugs'"/>
"KRN",.84,7981009.002,2,19,0)
  <xsl:with-param name="table" select="'DRUGS'"/>
"KRN",.84,7981009.002,2,20,0)
  <xsl:with-param name="parent" select="'OUTPATIENTS'"/>
"KRN",.84,7981009.002,2,21,0)
 </xsl:call-template>
"KRN",.84,7981009.002,2,22,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981009.002,2,23,0)
  <xsl:with-param name="subttl"
"KRN",.84,7981009.002,2,24,0)
       select="'Patients with Highest Utilization of Fills'"/>
"KRN",.84,7981009.002,2,25,0)
  <xsl:with-param name="table" select="'HU_FILLS'"/>
"KRN",.84,7981009.002,2,26,0)
  <xsl:with-param name="parent" select="'OUTPATIENTS'"/>
"KRN",.84,7981009.002,2,27,0)
 </xsl:call-template>
"KRN",.84,7981009.002,2,28,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981009.002,2,29,0)
  <xsl:with-param name="subttl" select="'Doses'"/>
"KRN",.84,7981009.002,2,30,0)
  <xsl:with-param name="table" select="'DOSES'"/>
"KRN",.84,7981009.002,2,31,0)
  <xsl:with-param name="parent" select="'INPATIENTS'"/>
"KRN",.84,7981009.002,2,32,0)
 </xsl:call-template>
"KRN",.84,7981009.002,2,33,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981009.002,2,34,0)
  <xsl:with-param name="subttl" select="'Inpatient Drugs'"/>
"KRN",.84,7981009.002,2,35,0)
  <xsl:with-param name="table" select="'DRUGS'"/>
"KRN",.84,7981009.002,2,36,0)
  <xsl:with-param name="parent" select="'INPATIENTS'"/>
"KRN",.84,7981009.002,2,37,0)
 </xsl:call-template>
"KRN",.84,7981009.002,2,38,0)
 <xsl:call-template name="UtilizationSection">
"KRN",.84,7981009.002,2,39,0)
  <xsl:with-param name="subttl"
"KRN",.84,7981009.002,2,40,0)
       select="'Patients with Highest Utilization of Doses'"/>
"KRN",.84,7981009.002,2,41,0)
  <xsl:with-param name="table" select="'HU_DOSES'"/>
"KRN",.84,7981009.002,2,42,0)
  <xsl:with-param name="parent" select="'INPATIENTS'"/>
"KRN",.84,7981009.002,2,43,0)
 </xsl:call-template>
"KRN",.84,7981009.002,2,44,0)
</xsl:template>
"KRN",.84,7981009.002,2,45,0)
 
"KRN",.84,7981009.002,2,46,0)
<!--[ COLUMN HEADERS ]-->
"KRN",.84,7981009.002,2,47,0)
 
"KRN",.84,7981009.002,2,48,0)
<xsl:template match="COLUMN[@NAME='MAXNP']">
"KRN",.84,7981009.002,2,49,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981009.002,2,50,0)
  <xsl:with-param name="title"
"KRN",.84,7981009.002,2,51,0)
       select="'Number of Patients with Max. Utilization'"/>
"KRN",.84,7981009.002,2,52,0)
 </xsl:call-template>
"KRN",.84,7981009.002,2,53,0)
</xsl:template>
"KRN",.84,7981009.002,2,54,0)
 
"KRN",.84,7981009.002,2,55,0)
<xsl:template match="COLUMN[@NAME='MAXNRPP']">
"KRN",.84,7981009.002,2,56,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981009.002,2,57,0)
  <xsl:with-param name="title"
"KRN",.84,7981009.002,2,58,0)
       select="'Maximum Number of Doses/Fills per Patient'"/>
"KRN",.84,7981009.002,2,59,0)
 </xsl:call-template>
"KRN",.84,7981009.002,2,60,0)
</xsl:template>
"KRN",.84,7981009.002,2,61,0)
 
"KRN",.84,7981009.002,2,62,0)
<xsl:template match="TBLDEF[contains(@NAME,'HU_')]/COLUMN[@NAME='NAME']">
"KRN",.84,7981009.002,2,63,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981009.002,2,64,0)
  <xsl:with-param name="title" select="'Patient Name'"/>
"KRN",.84,7981009.002,2,65,0)
 </xsl:call-template>
"KRN",.84,7981009.002,2,66,0)
</xsl:template>
"KRN",.84,7981009.002,2,67,0)
 
"KRN",.84,7981009.002,2,68,0)
<xsl:template match="COLUMN[@NAME='ND']">
"KRN",.84,7981009.002,2,69,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981009.002,2,70,0)
  <xsl:with-param name="title" select="'Number of Different Drugs'"/>
"KRN",.84,7981009.002,2,71,0)
 </xsl:call-template>
"KRN",.84,7981009.002,2,72,0)
</xsl:template>
"KRN",.84,7981009.002,2,73,0)
 
"KRN",.84,7981009.002,2,74,0)
<xsl:template match="COLUMN[@NAME='NP']">
"KRN",.84,7981009.002,2,75,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981009.002,2,76,0)
  <xsl:with-param name="title" select="'Number of Patients'"/>
"KRN",.84,7981009.002,2,77,0)
 </xsl:call-template>
"KRN",.84,7981009.002,2,78,0)
</xsl:template>
"KRN",.84,7981009.002,2,79,0)
 
"KRN",.84,7981009.002,2,80,0)
<xsl:template match="COLUMN[@NAME='NRX']">
"KRN",.84,7981009.002,2,81,0)
 <xsl:variable name="tblname" select="../@NAME"/>
"KRN",.84,7981009.002,2,82,0)
 <xsl:choose>
"KRN",.84,7981009.002,2,83,0)
  <xsl:when test="contains($tblname,'DOSE')">
"KRN",.84,7981009.002,2,84,0)
   <xsl:call-template name="ColumnHeader">
"KRN",.84,7981009.002,2,85,0)
    <xsl:with-param name="title" select="'Number of Doses'"/>
"KRN",.84,7981009.002,2,86,0)
   </xsl:call-template> 
"KRN",.84,7981009.002,2,87,0)
  </xsl:when>
"KRN",.84,7981009.002,2,88,0)
  <xsl:when test="contains($tblname,'FILL')">
"KRN",.84,7981009.002,2,89,0)
   <xsl:call-template name="ColumnHeader">
"KRN",.84,7981009.002,2,90,0)
    <xsl:with-param name="title" select="'Number of Fills'"/>
"KRN",.84,7981009.002,2,91,0)
   </xsl:call-template> 
"KRN",.84,7981009.002,2,92,0)
  </xsl:when>
"KRN",.84,7981009.002,2,93,0)
  <xsl:otherwise>
"KRN",.84,7981009.002,2,94,0)
   <xsl:call-template name="ColumnHeader">
"KRN",.84,7981009.002,2,95,0)
    <xsl:with-param name="title" select="'Number of Doses/Fills'"/>
"KRN",.84,7981009.002,2,96,0)
   </xsl:call-template> 
"KRN",.84,7981009.002,2,97,0)
  </xsl:otherwise>
"KRN",.84,7981009.002,2,98,0)
 </xsl:choose>
"KRN",.84,7981009.002,2,99,0)
</xsl:template>
"KRN",.84,7981009.002,2,100,0)
 
"KRN",.84,7981009.002,2,101,0)
</xsl:stylesheet>
"KRN",.84,7981010.001,-1)
0^25
"KRN",.84,7981010.001,0)
7981010.001^2^^CLINICAL CASE REGISTRIES^HIV Viral Load and CD4 by Range (HTML)
"KRN",.84,7981010.001,2,0)
^^99^99^3040202^
"KRN",.84,7981010.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981010.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981010.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981010.001,2,4,0)
>
"KRN",.84,7981010.001,2,5,0)
 
"KRN",.84,7981010.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   --> 
"KRN",.84,7981010.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981010.001,2,8,0)
<xsl:include href="template://report/997/1"/>  <!-- Patients -->            
"KRN",.84,7981010.001,2,9,0)
<xsl:include href="template://report/995/1"/>  <!-- Lab Data -->
"KRN",.84,7981010.001,2,10,0)
 
"KRN",.84,7981010.001,2,11,0)
<xsl:template match="/">
"KRN",.84,7981010.001,2,12,0)
 <html>
"KRN",.84,7981010.001,2,13,0)
  <head>
"KRN",.84,7981010.001,2,14,0)
   <title>HIV Viral Load and CD4 by Range</title>
"KRN",.84,7981010.001,2,15,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981010.001,2,16,0)
  </head>
"KRN",.84,7981010.001,2,17,0)
  <body>
"KRN",.84,7981010.001,2,18,0)
   <h1>HIV Viral Load and CD4 by Range</h1>
"KRN",.84,7981010.001,2,19,0)
   <xsl:call-template name="ReportHeader"/>
"KRN",.84,7981010.001,2,20,0)
   <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981010.001,2,21,0)
  </body>
"KRN",.84,7981010.001,2,22,0)
 </html>
"KRN",.84,7981010.001,2,23,0)
</xsl:template>
"KRN",.84,7981010.001,2,24,0)
 
"KRN",.84,7981010.001,2,25,0)
<xsl:template match="REPORT/PATIENTS">
"KRN",.84,7981010.001,2,26,0)
 <div style="page-break-before:always">
"KRN",.84,7981010.001,2,27,0)
  <xsl:call-template name="DataGrid">
"KRN",.84,7981010.001,2,28,0)
   <xsl:with-param name="scroll" select="descendant::LT[31]"/>
"KRN",.84,7981010.001,2,29,0)
  </xsl:call-template>
"KRN",.84,7981010.001,2,30,0)
 </div>
"KRN",.84,7981010.001,2,31,0)
</xsl:template>
"KRN",.84,7981010.001,2,32,0)
 
"KRN",.84,7981010.001,2,33,0)
<!--[ TABLE HEADER ]-->
"KRN",.84,7981010.001,2,34,0)
 
"KRN",.84,7981010.001,2,35,0)
<xsl:template match="TBLDEF[@NAME='PATIENTS']/@HEADER">
"KRN",.84,7981010.001,2,36,0)
 <xsl:variable name="PTLRL" select="../COLUMN[@NAME='PTLRL']"/>
"KRN",.84,7981010.001,2,37,0)
 <thead>
"KRN",.84,7981010.001,2,38,0)
  <tr>
"KRN",.84,7981010.001,2,39,0)
   <xsl:call-template name="BasicPatientHeader">
"KRN",.84,7981010.001,2,40,0)
    <xsl:with-param name="claids" select="0"/>
"KRN",.84,7981010.001,2,41,0)
    <xsl:with-param name="rowspan" select="2"/>
"KRN",.84,7981010.001,2,42,0)
   </xsl:call-template>
"KRN",.84,7981010.001,2,43,0)
   <xsl:call-template name="ColumnHeader">
"KRN",.84,7981010.001,2,44,0)
    <xsl:with-param name="column" select="$PTLRL"/>
"KRN",.84,7981010.001,2,45,0)
    <xsl:with-param name="colspan" select="4"/>
"KRN",.84,7981010.001,2,46,0)
    <xsl:with-param name="title" select="'Laboratory Tests'"/>                                  
"KRN",.84,7981010.001,2,47,0)
    <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981010.001,2,48,0)
    <xsl:with-param name="width" select="'60%'"/>
"KRN",.84,7981010.001,2,49,0)
   </xsl:call-template>
"KRN",.84,7981010.001,2,50,0)
  </tr>
"KRN",.84,7981010.001,2,51,0)
  <tr>
"KRN",.84,7981010.001,2,52,0)
   <xsl:call-template name="BasicLRHeader">
"KRN",.84,7981010.001,2,53,0)
    <xsl:with-param name="group" select="1"/>
"KRN",.84,7981010.001,2,54,0)
   </xsl:call-template>
"KRN",.84,7981010.001,2,55,0)
  </tr>
"KRN",.84,7981010.001,2,56,0)
 </thead>
"KRN",.84,7981010.001,2,57,0)
</xsl:template>
"KRN",.84,7981010.001,2,58,0)
 
"KRN",.84,7981010.001,2,59,0)
<!--[ TABLE CELLS ]-->
"KRN",.84,7981010.001,2,60,0)
 
"KRN",.84,7981010.001,2,61,0)
<xsl:template match="PATIENTS/PATIENT">
"KRN",.84,7981010.001,2,62,0)
 <xsl:variable name="rowspan" select="count(PTLRL/LT)"/>
"KRN",.84,7981010.001,2,63,0)
 <tr>
"KRN",.84,7981010.001,2,64,0)
  <xsl:call-template name="BasicPatientData">
"KRN",.84,7981010.001,2,65,0)
   <xsl:with-param name="claids" select="0"/>
"KRN",.84,7981010.001,2,66,0)
   <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981010.001,2,67,0)
  </xsl:call-template>
"KRN",.84,7981010.001,2,68,0)
  <xsl:for-each select="PTLRL/LT[1]">
"KRN",.84,7981010.001,2,69,0)
   <xsl:call-template name="BasicLRData">
"KRN",.84,7981010.001,2,70,0)
    <xsl:with-param name="group" select="1"/>
"KRN",.84,7981010.001,2,71,0)
   </xsl:call-template>
"KRN",.84,7981010.001,2,72,0)
  </xsl:for-each>
"KRN",.84,7981010.001,2,73,0)
 </tr>
"KRN",.84,7981010.001,2,74,0)
 <xsl:for-each select="PTLRL/LT[position()>1]">
"KRN",.84,7981010.001,2,75,0)
  <tr>
"KRN",.84,7981010.001,2,76,0)
   <xsl:call-template name="BasicLRData">
"KRN",.84,7981010.001,2,77,0)
    <xsl:with-param name="group" select="1"/>
"KRN",.84,7981010.001,2,78,0)
   </xsl:call-template>
"KRN",.84,7981010.001,2,79,0)
  </tr>
"KRN",.84,7981010.001,2,80,0)
 </xsl:for-each>
"KRN",.84,7981010.001,2,81,0)
</xsl:template>
"KRN",.84,7981010.001,2,82,0)
 
"KRN",.84,7981010.001,2,83,0)
<!--[ REPORT PARAMETERS ]-->
"KRN",.84,7981010.001,2,84,0)
 
"KRN",.84,7981010.001,2,85,0)
<xsl:template match="PARAMETERS/CD4OPT">
"KRN",.84,7981010.001,2,86,0)
 <tr>
"KRN",.84,7981010.001,2,87,0)
  <th scope="row">CD4:&#160;</th>
"KRN",.84,7981010.001,2,88,0)
  <td><xsl:value-of select="."/></td>
"KRN",.84,7981010.001,2,89,0)
 </tr>
"KRN",.84,7981010.001,2,90,0)
</xsl:template>
"KRN",.84,7981010.001,2,91,0)
 
"KRN",.84,7981010.001,2,92,0)
<xsl:template match="PARAMETERS/VIRAL_LOAD"> 
"KRN",.84,7981010.001,2,93,0)
 <tr>
"KRN",.84,7981010.001,2,94,0)
  <th scope="row">Viral Load:&#160;</th>    
"KRN",.84,7981010.001,2,95,0)
  <td><xsl:value-of select="."/></td>
"KRN",.84,7981010.001,2,96,0)
 </tr>
"KRN",.84,7981010.001,2,97,0)
</xsl:template>
"KRN",.84,7981010.001,2,98,0)
 
"KRN",.84,7981010.001,2,99,0)
</xsl:stylesheet>
"KRN",.84,7981010.002,-1)
0^47
"KRN",.84,7981010.002,0)
7981010.002^2^^CLINICAL CASE REGISTRIES^HIV Viral Load and CD4 by Range (CSV)
"KRN",.84,7981010.002,2,0)
^^40^40^3040202^
"KRN",.84,7981010.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981010.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981010.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981010.002,2,4,0)
>
"KRN",.84,7981010.002,2,5,0)
 
"KRN",.84,7981010.002,2,6,0)
<xsl:import href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981010.002,2,7,0)
 
"KRN",.84,7981010.002,2,8,0)
<xsl:template match="/">
"KRN",.84,7981010.002,2,9,0)
 <xsl:text>HIV Viral Load and CD4 by Range</xsl:text>
"KRN",.84,7981010.002,2,10,0)
 <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981010.002,2,11,0)
</xsl:template>
"KRN",.84,7981010.002,2,12,0)
 
"KRN",.84,7981010.002,2,13,0)
<xsl:template match="PATIENTS/PATIENT">
"KRN",.84,7981010.002,2,14,0)
 <xsl:variable name="ptname" select="NAME"/>
"KRN",.84,7981010.002,2,15,0)
 <xsl:variable name="ssn" select="LAST4"/>
"KRN",.84,7981010.002,2,16,0)
 <xsl:for-each select="PTLRL/LT">
"KRN",.84,7981010.002,2,17,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981010.002,2,18,0)
   <xsl:with-param name="value" select="$ptname"/>
"KRN",.84,7981010.002,2,19,0)
  </xsl:call-template>
"KRN",.84,7981010.002,2,20,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981010.002,2,21,0)
   <xsl:with-param name="value" select="$ssn"/>
"KRN",.84,7981010.002,2,22,0)
  </xsl:call-template>
"KRN",.84,7981010.002,2,23,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981010.002,2,24,0)
   <xsl:with-param name="value" select="GROUP"/>
"KRN",.84,7981010.002,2,25,0)
  </xsl:call-template>
"KRN",.84,7981010.002,2,26,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981010.002,2,27,0)
   <xsl:with-param name="value" select="DATE"/>
"KRN",.84,7981010.002,2,28,0)
   <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981010.002,2,29,0)
  </xsl:call-template>
"KRN",.84,7981010.002,2,30,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981010.002,2,31,0)
   <xsl:with-param name="value" select="NAME"/>
"KRN",.84,7981010.002,2,32,0)
  </xsl:call-template>
"KRN",.84,7981010.002,2,33,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981010.002,2,34,0)
   <xsl:with-param name="value" select="RESULT"/>
"KRN",.84,7981010.002,2,35,0)
  </xsl:call-template>
"KRN",.84,7981010.002,2,36,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981010.002,2,37,0)
 </xsl:for-each>
"KRN",.84,7981010.002,2,38,0)
</xsl:template>
"KRN",.84,7981010.002,2,39,0)
 
"KRN",.84,7981010.002,2,40,0)
</xsl:stylesheet>
"KRN",.84,7981011.001,-1)
0^40
"KRN",.84,7981011.001,0)
7981011.001^2^^CLINICAL CASE REGISTRIES^Patient Drug History (HTML)
"KRN",.84,7981011.001,2,0)
^^110^110^3031212^
"KRN",.84,7981011.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981011.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981011.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981011.001,2,4,0)
>
"KRN",.84,7981011.001,2,5,0)
 
"KRN",.84,7981011.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   --> 
"KRN",.84,7981011.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981011.001,2,8,0)
<xsl:import  href="template://report/997/1"/>  <!-- Patients -->
"KRN",.84,7981011.001,2,9,0)
<xsl:include href="template://report/996/1"/>  <!-- Pharmacy -->
"KRN",.84,7981011.001,2,10,0)
 
"KRN",.84,7981011.001,2,11,0)
<xsl:template match="/">
"KRN",.84,7981011.001,2,12,0)
 <html>
"KRN",.84,7981011.001,2,13,0)
  <head>
"KRN",.84,7981011.001,2,14,0)
   <title>Patient Drug History</title>
"KRN",.84,7981011.001,2,15,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981011.001,2,16,0)
  </head>
"KRN",.84,7981011.001,2,17,0)
  <body>
"KRN",.84,7981011.001,2,18,0)
   <h1>Patient Drug History</h1>
"KRN",.84,7981011.001,2,19,0)
   <xsl:call-template name="ReportHeader"/> 
"KRN",.84,7981011.001,2,20,0)
   <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981011.001,2,21,0)
  </body>
"KRN",.84,7981011.001,2,22,0)
 </html>
"KRN",.84,7981011.001,2,23,0)
</xsl:template>
"KRN",.84,7981011.001,2,24,0)
 
"KRN",.84,7981011.001,2,25,0)
<xsl:template match="PATIENTS/PATIENT">
"KRN",.84,7981011.001,2,26,0)
 <div style="page-break-before:always">
"KRN",.84,7981011.001,2,27,0)
  <h2><xsl:value-of select="NAME"/></h2>
"KRN",.84,7981011.001,2,28,0)
  <table width="50%" cellpadding="5" cellspacing="0">
"KRN",.84,7981011.001,2,29,0)
   <tr>
"KRN",.84,7981011.001,2,30,0)
    <th width="33%">SSN</th>
"KRN",.84,7981011.001,2,31,0)
    <th width="33%">Date of Birth</th>
"KRN",.84,7981011.001,2,32,0)
    <th width="33%">Age</th>
"KRN",.84,7981011.001,2,33,0)
   </tr>
"KRN",.84,7981011.001,2,34,0)
   <tr>
"KRN",.84,7981011.001,2,35,0)
    <xsl:call-template name="TableCell">
"KRN",.84,7981011.001,2,36,0)
     <xsl:with-param name="value" select="LAST4"/>
"KRN",.84,7981011.001,2,37,0)
    </xsl:call-template>
"KRN",.84,7981011.001,2,38,0)
    <xsl:call-template name="TableCell">
"KRN",.84,7981011.001,2,39,0)
     <xsl:with-param name="value" select="DOB"/>
"KRN",.84,7981011.001,2,40,0)
     <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981011.001,2,41,0)
    </xsl:call-template>
"KRN",.84,7981011.001,2,42,0)
    <xsl:call-template name="TableCell">
"KRN",.84,7981011.001,2,43,0)
     <xsl:with-param name="value" select="AGE"/>
"KRN",.84,7981011.001,2,44,0)
    </xsl:call-template>
"KRN",.84,7981011.001,2,45,0)
   </tr>
"KRN",.84,7981011.001,2,46,0)
  </table>
"KRN",.84,7981011.001,2,47,0)
  <h3>Drug History</h3>
"KRN",.84,7981011.001,2,48,0)
  <xsl:apply-templates select="PTRXL"/>
"KRN",.84,7981011.001,2,49,0)
 </div>
"KRN",.84,7981011.001,2,50,0)
</xsl:template>
"KRN",.84,7981011.001,2,51,0)
 
"KRN",.84,7981011.001,2,52,0)
<!--[ TABLE HEADERS ]-->
"KRN",.84,7981011.001,2,53,0)
 
"KRN",.84,7981011.001,2,54,0)
<xsl:template match="COLUMN[@NAME='DATE']">
"KRN",.84,7981011.001,2,55,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981011.001,2,56,0)
  <xsl:with-param name="title" select="'Date'"/>
"KRN",.84,7981011.001,2,57,0)
  <xsl:with-param name="width" select="'5%'"/>
"KRN",.84,7981011.001,2,58,0)
 </xsl:call-template>
"KRN",.84,7981011.001,2,59,0)
</xsl:template>
"KRN",.84,7981011.001,2,60,0)
 
"KRN",.84,7981011.001,2,61,0)
<xsl:template match="COLUMN[@NAME='DAYSPLY']">
"KRN",.84,7981011.001,2,62,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981011.001,2,63,0)
  <xsl:with-param name="title" select="'Days Supply'"/>
"KRN",.84,7981011.001,2,64,0)
  <xsl:with-param name="width" select="'7%'"/>
"KRN",.84,7981011.001,2,65,0)
 </xsl:call-template>
"KRN",.84,7981011.001,2,66,0)
</xsl:template>
"KRN",.84,7981011.001,2,67,0)
 
"KRN",.84,7981011.001,2,68,0)
<xsl:template match="COLUMN[@NAME='FILLTYPE']">
"KRN",.84,7981011.001,2,69,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981011.001,2,70,0)
  <xsl:with-param name="title" select="'Fill Type'"/>
"KRN",.84,7981011.001,2,71,0)
  <xsl:with-param name="width" select="'5%'"/>
"KRN",.84,7981011.001,2,72,0)
 </xsl:call-template>
"KRN",.84,7981011.001,2,73,0)
</xsl:template>
"KRN",.84,7981011.001,2,74,0)
 
"KRN",.84,7981011.001,2,75,0)
<xsl:template match="COLUMN[@NAME='GENERIC']">
"KRN",.84,7981011.001,2,76,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981011.001,2,77,0)
  <xsl:with-param name="title" select="'Generic Name'"/>
"KRN",.84,7981011.001,2,78,0)
 </xsl:call-template>
"KRN",.84,7981011.001,2,79,0)
</xsl:template>
"KRN",.84,7981011.001,2,80,0)
 
"KRN",.84,7981011.001,2,81,0)
<xsl:template match="COLUMN[@NAME='ORDER']">
"KRN",.84,7981011.001,2,82,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981011.001,2,83,0)
  <xsl:with-param name="title" select="'Rx#'"/>
"KRN",.84,7981011.001,2,84,0)
  <xsl:with-param name="width" select="'5%'"/>
"KRN",.84,7981011.001,2,85,0)
  <xsl:with-param name="sort" select="'PTRXL=ORDER'"/>
"KRN",.84,7981011.001,2,86,0)
 </xsl:call-template>
"KRN",.84,7981011.001,2,87,0)
</xsl:template>
"KRN",.84,7981011.001,2,88,0)
 
"KRN",.84,7981011.001,2,89,0)
<xsl:template match="COLUMN[@NAME='TYPE']">
"KRN",.84,7981011.001,2,90,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981011.001,2,91,0)
  <xsl:with-param name="title" select="'Type'"/>
"KRN",.84,7981011.001,2,92,0)
  <xsl:with-param name="width" select="'5%'"/>
"KRN",.84,7981011.001,2,93,0)
 </xsl:call-template>
"KRN",.84,7981011.001,2,94,0)
</xsl:template>
"KRN",.84,7981011.001,2,95,0)
 
"KRN",.84,7981011.001,2,96,0)
<!--[ TABLE CELLS ]-->
"KRN",.84,7981011.001,2,97,0)
 
"KRN",.84,7981011.001,2,98,0)
<xsl:template match="DRUG/DATE">
"KRN",.84,7981011.001,2,99,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981011.001,2,100,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981011.001,2,101,0)
 </xsl:call-template>
"KRN",.84,7981011.001,2,102,0)
</xsl:template>
"KRN",.84,7981011.001,2,103,0)
 
"KRN",.84,7981011.001,2,104,0)
<xsl:template match="DRUG/GENERIC">
"KRN",.84,7981011.001,2,105,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981011.001,2,106,0)
  <xsl:with-param name="class" select="'aLeft'"/>
"KRN",.84,7981011.001,2,107,0)
 </xsl:call-template>
"KRN",.84,7981011.001,2,108,0)
</xsl:template>
"KRN",.84,7981011.001,2,109,0)
 
"KRN",.84,7981011.001,2,110,0)
</xsl:stylesheet>
"KRN",.84,7981011.002,-1)
0^48
"KRN",.84,7981011.002,0)
7981011.002^2^^CLINICAL CASE REGISTRIES^Patient Drug History (CSV)
"KRN",.84,7981011.002,2,0)
^^82^82^3031212^
"KRN",.84,7981011.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981011.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981011.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981011.002,2,4,0)
>
"KRN",.84,7981011.002,2,5,0)
 
"KRN",.84,7981011.002,2,6,0)
<xsl:import  href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981011.002,2,7,0)
<xsl:include href="template://report/997/2"/>  <!-- Patients -->
"KRN",.84,7981011.002,2,8,0)
 
"KRN",.84,7981011.002,2,9,0)
<xsl:template match="/">
"KRN",.84,7981011.002,2,10,0)
 <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981011.002,2,11,0)
</xsl:template>
"KRN",.84,7981011.002,2,12,0)
 
"KRN",.84,7981011.002,2,13,0)
<xsl:template match="PATIENTS/PATIENT">
"KRN",.84,7981011.002,2,14,0)
 <xsl:text>Patient Drug History</xsl:text>
"KRN",.84,7981011.002,2,15,0)
 <xsl:value-of select="$CRLF"/>
"KRN",.84,7981011.002,2,16,0)
 <xsl:text>Patient Name,SSN,Date of Birth,Age</xsl:text>
"KRN",.84,7981011.002,2,17,0)
 <xsl:value-of select="$CRLF"/>
"KRN",.84,7981011.002,2,18,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981011.002,2,19,0)
  <xsl:with-param name="value" select="NAME"/>
"KRN",.84,7981011.002,2,20,0)
 </xsl:call-template>
"KRN",.84,7981011.002,2,21,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981011.002,2,22,0)
  <xsl:with-param name="value" select="LAST4"/>
"KRN",.84,7981011.002,2,23,0)
 </xsl:call-template>
"KRN",.84,7981011.002,2,24,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981011.002,2,25,0)
  <xsl:with-param name="value" select="DOB"/>
"KRN",.84,7981011.002,2,26,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981011.002,2,27,0)
 </xsl:call-template>
"KRN",.84,7981011.002,2,28,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981011.002,2,29,0)
  <xsl:with-param name="value" select="AGE"/>
"KRN",.84,7981011.002,2,30,0)
 </xsl:call-template>
"KRN",.84,7981011.002,2,31,0)
 <xsl:value-of select="$CRLF"/>
"KRN",.84,7981011.002,2,32,0)
 <xsl:apply-templates select="PTRXL"/>
"KRN",.84,7981011.002,2,33,0)
 <xsl:value-of select="$FILESWITCH"/>
"KRN",.84,7981011.002,2,34,0)
</xsl:template>
"KRN",.84,7981011.002,2,35,0)
 
"KRN",.84,7981011.002,2,36,0)
<!--[ TABLE HEADERS ]-->
"KRN",.84,7981011.002,2,37,0)
 
"KRN",.84,7981011.002,2,38,0)
<xsl:template match="COLUMN[@NAME='DATE']">
"KRN",.84,7981011.002,2,39,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981011.002,2,40,0)
  <xsl:with-param name="title" select="'Date'"/>
"KRN",.84,7981011.002,2,41,0)
 </xsl:call-template>
"KRN",.84,7981011.002,2,42,0)
</xsl:template>
"KRN",.84,7981011.002,2,43,0)
 
"KRN",.84,7981011.002,2,44,0)
<xsl:template match="COLUMN[@NAME='DAYSPLY']">
"KRN",.84,7981011.002,2,45,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981011.002,2,46,0)
  <xsl:with-param name="title" select="'Days Supply'"/>
"KRN",.84,7981011.002,2,47,0)
 </xsl:call-template>
"KRN",.84,7981011.002,2,48,0)
</xsl:template>
"KRN",.84,7981011.002,2,49,0)
 
"KRN",.84,7981011.002,2,50,0)
<xsl:template match="COLUMN[@NAME='FILLTYPE']">
"KRN",.84,7981011.002,2,51,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981011.002,2,52,0)
  <xsl:with-param name="title" select="'Fill Type'"/>
"KRN",.84,7981011.002,2,53,0)
 </xsl:call-template>
"KRN",.84,7981011.002,2,54,0)
</xsl:template>
"KRN",.84,7981011.002,2,55,0)
 
"KRN",.84,7981011.002,2,56,0)
<xsl:template match="COLUMN[@NAME='GENERIC']">
"KRN",.84,7981011.002,2,57,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981011.002,2,58,0)
  <xsl:with-param name="title" select="'Generic Name'"/>
"KRN",.84,7981011.002,2,59,0)
 </xsl:call-template>
"KRN",.84,7981011.002,2,60,0)
</xsl:template>
"KRN",.84,7981011.002,2,61,0)
 
"KRN",.84,7981011.002,2,62,0)
<xsl:template match="COLUMN[@NAME='ORDER']">
"KRN",.84,7981011.002,2,63,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981011.002,2,64,0)
  <xsl:with-param name="title" select="'Rx#'"/>
"KRN",.84,7981011.002,2,65,0)
 </xsl:call-template>
"KRN",.84,7981011.002,2,66,0)
</xsl:template>
"KRN",.84,7981011.002,2,67,0)
 
"KRN",.84,7981011.002,2,68,0)
<xsl:template match="COLUMN[@NAME='TYPE']">
"KRN",.84,7981011.002,2,69,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981011.002,2,70,0)
  <xsl:with-param name="title" select="'Type'"/>
"KRN",.84,7981011.002,2,71,0)
 </xsl:call-template>
"KRN",.84,7981011.002,2,72,0)
</xsl:template>
"KRN",.84,7981011.002,2,73,0)
 
"KRN",.84,7981011.002,2,74,0)
<!--[ TABLE CELLS ]-->
"KRN",.84,7981011.002,2,75,0)
 
"KRN",.84,7981011.002,2,76,0)
<xsl:template match="DRUG/DATE">
"KRN",.84,7981011.002,2,77,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981011.002,2,78,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981011.002,2,79,0)
 </xsl:call-template>
"KRN",.84,7981011.002,2,80,0)
</xsl:template>
"KRN",.84,7981011.002,2,81,0)
 
"KRN",.84,7981011.002,2,82,0)
</xsl:stylesheet>
"KRN",.84,7981012.001,-1)
0^34
"KRN",.84,7981012.001,0)
7981012.001^2^^CLINICAL CASE REGISTRIES^Combined RX and Lab Report (HTML)
"KRN",.84,7981012.001,2,0)
^^193^193^3031212^
"KRN",.84,7981012.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981012.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981012.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981012.001,2,4,0)
>
"KRN",.84,7981012.001,2,5,0)
 
"KRN",.84,7981012.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   --> 
"KRN",.84,7981012.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981012.001,2,8,0)
<xsl:include href="template://report/997/1"/>  <!-- Patients -->            
"KRN",.84,7981012.001,2,9,0)
<xsl:include href="template://report/996/1"/>  <!-- Pharmacy -->
"KRN",.84,7981012.001,2,10,0)
<xsl:include href="template://report/995/1"/>  <!-- Lab Data -->
"KRN",.84,7981012.001,2,11,0)
 
"KRN",.84,7981012.001,2,12,0)
<xsl:template match="/">
"KRN",.84,7981012.001,2,13,0)
 <html>
"KRN",.84,7981012.001,2,14,0)
  <head>
"KRN",.84,7981012.001,2,15,0)
   <title>Combined RX and Lab Report</title>
"KRN",.84,7981012.001,2,16,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981012.001,2,17,0)
  </head>
"KRN",.84,7981012.001,2,18,0)
  <body>
"KRN",.84,7981012.001,2,19,0)
   <h1>Combined RX and Lab Report</h1>
"KRN",.84,7981012.001,2,20,0)
   <xsl:call-template name="ReportHeader"/>
"KRN",.84,7981012.001,2,21,0)
   <xsl:if test="/REPORT/PARAMETERS/OPTIONS/@PHARMACY">
"KRN",.84,7981012.001,2,22,0)
    <xsl:apply-templates select="/REPORT/PATIENTS" mode="DRUGS"/>
"KRN",.84,7981012.001,2,23,0)
   </xsl:if>
"KRN",.84,7981012.001,2,24,0)
   <xsl:if test="/REPORT/PARAMETERS/OPTIONS/@LAB">
"KRN",.84,7981012.001,2,25,0)
    <xsl:apply-templates select="/REPORT/PATIENTS" mode="LABTESTS"/>
"KRN",.84,7981012.001,2,26,0)
   </xsl:if>
"KRN",.84,7981012.001,2,27,0)
  </body>
"KRN",.84,7981012.001,2,28,0)
 </html>
"KRN",.84,7981012.001,2,29,0)
</xsl:template>
"KRN",.84,7981012.001,2,30,0)
 
"KRN",.84,7981012.001,2,31,0)
<!--[ TABLES ]-->
"KRN",.84,7981012.001,2,32,0)
 
"KRN",.84,7981012.001,2,33,0)
<xsl:template match="REPORT/PATIENTS" mode="DRUGS">
"KRN",.84,7981012.001,2,34,0)
 <div style="page-break-before:always">
"KRN",.84,7981012.001,2,35,0)
  <h2>Drugs</h2>
"KRN",.84,7981012.001,2,36,0)
  <xsl:choose>
"KRN",.84,7981012.001,2,37,0)
   <xsl:when test="PATIENT[1]">
"KRN",.84,7981012.001,2,38,0)
    <div>
"KRN",.84,7981012.001,2,39,0)
    <xsl:call-template name="MakeScrollable">
"KRN",.84,7981012.001,2,40,0)
     <xsl:with-param name="condition" select="descendant::DRUG[31]"/>
"KRN",.84,7981012.001,2,41,0)
    </xsl:call-template>
"KRN",.84,7981012.001,2,42,0)
     <table class="dataGrid" cellpadding="5" cellspacing="0">
"KRN",.84,7981012.001,2,43,0)
      <thead>
"KRN",.84,7981012.001,2,44,0)
       <tr>
"KRN",.84,7981012.001,2,45,0)
        <xsl:call-template name="BasicPatientHeader">
"KRN",.84,7981012.001,2,46,0)
         <xsl:with-param name="tblname" select="'PATIENTS'"/>
"KRN",.84,7981012.001,2,47,0)
         <xsl:with-param name="rowspan" select="2"/>
"KRN",.84,7981012.001,2,48,0)
        </xsl:call-template>
"KRN",.84,7981012.001,2,49,0)
        <xsl:call-template name="ColumnHeader">
"KRN",.84,7981012.001,2,50,0)
         <xsl:with-param name="title" select="'Drug Name'"/>
"KRN",.84,7981012.001,2,51,0)
         <xsl:with-param name="sort" select="'PTRXL=NAME'"/>
"KRN",.84,7981012.001,2,52,0)
        </xsl:call-template>
"KRN",.84,7981012.001,2,53,0)
       </tr>
"KRN",.84,7981012.001,2,54,0)
      </thead>
"KRN",.84,7981012.001,2,55,0)
      <xsl:call-template name="DataGridFooter">
"KRN",.84,7981012.001,2,56,0)
       <xsl:with-param name="colspan" select="5"/>
"KRN",.84,7981012.001,2,57,0)
      </xsl:call-template>
"KRN",.84,7981012.001,2,58,0)
      <tbody>
"KRN",.84,7981012.001,2,59,0)
       <xsl:for-each select="PATIENT">
"KRN",.84,7981012.001,2,60,0)
        <xsl:call-template name="PatientDrugData"/>
"KRN",.84,7981012.001,2,61,0)
       </xsl:for-each>
"KRN",.84,7981012.001,2,62,0)
      </tbody>
"KRN",.84,7981012.001,2,63,0)
     </table>
"KRN",.84,7981012.001,2,64,0)
    </div>
"KRN",.84,7981012.001,2,65,0)
   </xsl:when>
"KRN",.84,7981012.001,2,66,0)
   <xsl:otherwise>
"KRN",.84,7981012.001,2,67,0)
    <xsl:call-template name="TableNoData"/>
"KRN",.84,7981012.001,2,68,0)
   </xsl:otherwise>
"KRN",.84,7981012.001,2,69,0)
  </xsl:choose>
"KRN",.84,7981012.001,2,70,0)
 </div>
"KRN",.84,7981012.001,2,71,0)
</xsl:template>
"KRN",.84,7981012.001,2,72,0)
 
"KRN",.84,7981012.001,2,73,0)
<xsl:template match="REPORT/PATIENTS" mode="LABTESTS">
"KRN",.84,7981012.001,2,74,0)
 <div style="page-break-before:always">
"KRN",.84,7981012.001,2,75,0)
  <h2>Lab Results</h2>
"KRN",.84,7981012.001,2,76,0)
  <xsl:choose>
"KRN",.84,7981012.001,2,77,0)
   <xsl:when test="PATIENT[1]">
"KRN",.84,7981012.001,2,78,0)
    <div>
"KRN",.84,7981012.001,2,79,0)
    <xsl:call-template name="MakeScrollable">
"KRN",.84,7981012.001,2,80,0)
     <xsl:with-param name="condition" select="descendant::LT[31]"/>
"KRN",.84,7981012.001,2,81,0)
    </xsl:call-template>
"KRN",.84,7981012.001,2,82,0)
     <table class="dataGrid" cellpadding="5" cellspacing="0">
"KRN",.84,7981012.001,2,83,0)
      <thead>
"KRN",.84,7981012.001,2,84,0)
       <tr>
"KRN",.84,7981012.001,2,85,0)
        <xsl:call-template name="BasicPatientHeader">
"KRN",.84,7981012.001,2,86,0)
         <xsl:with-param name="rowspan" select="2"/>
"KRN",.84,7981012.001,2,87,0)
        </xsl:call-template>
"KRN",.84,7981012.001,2,88,0)
        <xsl:call-template name="ColumnHeader">
"KRN",.84,7981012.001,2,89,0)
         <xsl:with-param name="title" select="'Lab Results'"/>
"KRN",.84,7981012.001,2,90,0)
         <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981012.001,2,91,0)
         <xsl:with-param name="width" select="'55%'"/>
"KRN",.84,7981012.001,2,92,0)
         <xsl:with-param name="colspan" select="4"/>
"KRN",.84,7981012.001,2,93,0)
        </xsl:call-template>
"KRN",.84,7981012.001,2,94,0)
       </tr>
"KRN",.84,7981012.001,2,95,0)
       <tr>
"KRN",.84,7981012.001,2,96,0)
        <xsl:call-template name="BasicLRHeader"/>
"KRN",.84,7981012.001,2,97,0)
       </tr>
"KRN",.84,7981012.001,2,98,0)
      </thead>
"KRN",.84,7981012.001,2,99,0)
      <xsl:call-template name="DataGridFooter">
"KRN",.84,7981012.001,2,100,0)
       <xsl:with-param name="colspan" select="7"/>
"KRN",.84,7981012.001,2,101,0)
      </xsl:call-template>
"KRN",.84,7981012.001,2,102,0)
      <tbody>
"KRN",.84,7981012.001,2,103,0)
       <xsl:for-each select="PATIENT">
"KRN",.84,7981012.001,2,104,0)
        <xsl:call-template name="PatientLabData"/>
"KRN",.84,7981012.001,2,105,0)
       </xsl:for-each>
"KRN",.84,7981012.001,2,106,0)
      </tbody>
"KRN",.84,7981012.001,2,107,0)
     </table>
"KRN",.84,7981012.001,2,108,0)
    </div>
"KRN",.84,7981012.001,2,109,0)
   </xsl:when>
"KRN",.84,7981012.001,2,110,0)
   <xsl:otherwise>
"KRN",.84,7981012.001,2,111,0)
    <xsl:call-template name="TableNoData"/>
"KRN",.84,7981012.001,2,112,0)
   </xsl:otherwise>
"KRN",.84,7981012.001,2,113,0)
  </xsl:choose>
"KRN",.84,7981012.001,2,114,0)
 </div>
"KRN",.84,7981012.001,2,115,0)
</xsl:template>
"KRN",.84,7981012.001,2,116,0)
 
"KRN",.84,7981012.001,2,117,0)
<!--[ UTILITIES ]-->
"KRN",.84,7981012.001,2,118,0)
 
"KRN",.84,7981012.001,2,119,0)
<xsl:template name="DrugData">
"KRN",.84,7981012.001,2,120,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981012.001,2,121,0)
  <xsl:with-param name="value" select="NAME"/>
"KRN",.84,7981012.001,2,122,0)
  <xsl:with-param name="class" select="'aLeft'"/>
"KRN",.84,7981012.001,2,123,0)
 </xsl:call-template>
"KRN",.84,7981012.001,2,124,0)
</xsl:template>
"KRN",.84,7981012.001,2,125,0)
 
"KRN",.84,7981012.001,2,126,0)
<xsl:template name="PatientData">
"KRN",.84,7981012.001,2,127,0)
 <xsl:param name="rowspan" select="1"/>
"KRN",.84,7981012.001,2,128,0)
 <xsl:param name="ref"/>
"KRN",.84,7981012.001,2,129,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981012.001,2,130,0)
  <xsl:with-param name="value" select="position()"/>
"KRN",.84,7981012.001,2,131,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981012.001,2,132,0)
 </xsl:call-template>
"KRN",.84,7981012.001,2,133,0)
 <td class="aLeft">
"KRN",.84,7981012.001,2,134,0)
  <xsl:attribute name="rowspan">
"KRN",.84,7981012.001,2,135,0)
   <xsl:value-of select="$rowspan"/>
"KRN",.84,7981012.001,2,136,0)
  </xsl:attribute>
"KRN",.84,7981012.001,2,137,0)
  <xsl:call-template name="HyperLink">
"KRN",.84,7981012.001,2,138,0)
   <xsl:with-param name="text" select="NAME"/>
"KRN",.84,7981012.001,2,139,0)
   <xsl:with-param name="name"
"KRN",.84,7981012.001,2,140,0)
        select="concat(substring-before($ref,'^'),position())"/>
"KRN",.84,7981012.001,2,141,0)
   <xsl:with-param name="href"
"KRN",.84,7981012.001,2,142,0)
        select="concat(substring-after($ref,'^'),position())"/>
"KRN",.84,7981012.001,2,143,0)
   <xsl:with-param name="keep" select="1"/>
"KRN",.84,7981012.001,2,144,0)
  </xsl:call-template>
"KRN",.84,7981012.001,2,145,0)
 </td>
"KRN",.84,7981012.001,2,146,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981012.001,2,147,0)
  <xsl:with-param name="value" select="LAST4"/>
"KRN",.84,7981012.001,2,148,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981012.001,2,149,0)
 </xsl:call-template>
"KRN",.84,7981012.001,2,150,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981012.001,2,151,0)
  <xsl:with-param name="value" select="AIDSTAT"/>
"KRN",.84,7981012.001,2,152,0)
  <xsl:with-param name="yesno" select="1"/>
"KRN",.84,7981012.001,2,153,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981012.001,2,154,0)
 </xsl:call-template>
"KRN",.84,7981012.001,2,155,0)
</xsl:template>
"KRN",.84,7981012.001,2,156,0)
 
"KRN",.84,7981012.001,2,157,0)
<xsl:template name="PatientDrugData">
"KRN",.84,7981012.001,2,158,0)
 <xsl:variable name="rowspan" select="count(PTRXL/DRUG)"/>
"KRN",.84,7981012.001,2,159,0)
 <tr>
"KRN",.84,7981012.001,2,160,0)
  <xsl:call-template name="PatientData">
"KRN",.84,7981012.001,2,161,0)
   <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981012.001,2,162,0)
   <xsl:with-param name="ref" select="'RX^#LR'"/>
"KRN",.84,7981012.001,2,163,0)
  </xsl:call-template>
"KRN",.84,7981012.001,2,164,0)
  <xsl:for-each select="PTRXL/DRUG[1]">
"KRN",.84,7981012.001,2,165,0)
   <xsl:call-template name="DrugData"/>
"KRN",.84,7981012.001,2,166,0)
  </xsl:for-each>
"KRN",.84,7981012.001,2,167,0)
 </tr>
"KRN",.84,7981012.001,2,168,0)
 <xsl:for-each select="PTRXL/DRUG[position()>1]">
"KRN",.84,7981012.001,2,169,0)
  <tr>
"KRN",.84,7981012.001,2,170,0)
   <xsl:call-template name="DrugData"/>
"KRN",.84,7981012.001,2,171,0)
  </tr>
"KRN",.84,7981012.001,2,172,0)
 </xsl:for-each>
"KRN",.84,7981012.001,2,173,0)
</xsl:template>
"KRN",.84,7981012.001,2,174,0)
 
"KRN",.84,7981012.001,2,175,0)
<xsl:template name="PatientLabData">
"KRN",.84,7981012.001,2,176,0)
 <xsl:variable name="rowspan" select="count(PTLRL/LT)"/>
"KRN",.84,7981012.001,2,177,0)
 <tr>
"KRN",.84,7981012.001,2,178,0)
  <xsl:call-template name="PatientData">
"KRN",.84,7981012.001,2,179,0)
   <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981012.001,2,180,0)
   <xsl:with-param name="ref" select="'LR^#RX'"/>
"KRN",.84,7981012.001,2,181,0)
  </xsl:call-template>
"KRN",.84,7981012.001,2,182,0)
  <xsl:for-each select="PTLRL/LT[1]">
"KRN",.84,7981012.001,2,183,0)
   <xsl:call-template name="BasicLRData"/>
"KRN",.84,7981012.001,2,184,0)
  </xsl:for-each>
"KRN",.84,7981012.001,2,185,0)
 </tr>
"KRN",.84,7981012.001,2,186,0)
 <xsl:for-each select="PTLRL/LT[position()>1]">
"KRN",.84,7981012.001,2,187,0)
  <tr>
"KRN",.84,7981012.001,2,188,0)
   <xsl:call-template name="BasicLRData"/>
"KRN",.84,7981012.001,2,189,0)
  </tr>
"KRN",.84,7981012.001,2,190,0)
 </xsl:for-each>
"KRN",.84,7981012.001,2,191,0)
</xsl:template>
"KRN",.84,7981012.001,2,192,0)
 
"KRN",.84,7981012.001,2,193,0)
</xsl:stylesheet>
"KRN",.84,7981012.002,-1)
0^49
"KRN",.84,7981012.002,0)
7981012.002^2^^CLINICAL CASE REGISTRIES^Combined RX and Lab Report (CSV)
"KRN",.84,7981012.002,2,0)
^^79^79^3031212^
"KRN",.84,7981012.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981012.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981012.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981012.002,2,4,0)
>
"KRN",.84,7981012.002,2,5,0)
 
"KRN",.84,7981012.002,2,6,0)
<xsl:import  href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981012.002,2,7,0)
<xsl:include href="template://report/997/2"/>  <!-- Patients -->
"KRN",.84,7981012.002,2,8,0)
 
"KRN",.84,7981012.002,2,9,0)
<xsl:template match="/">
"KRN",.84,7981012.002,2,10,0)
 <xsl:if test="/REPORT/PARAMETERS/OPTIONS/@PHARMACY">
"KRN",.84,7981012.002,2,11,0)
  <xsl:text>Combined RX and Lab Report (Drugs)</xsl:text>
"KRN",.84,7981012.002,2,12,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981012.002,2,13,0)
  <xsl:text>Patient Name,SSN,AIDS OI,Drug Name</xsl:text>
"KRN",.84,7981012.002,2,14,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981012.002,2,15,0)
  <xsl:apply-templates select="/REPORT/PATIENTS/PATIENT" mode="DRUGS"/>
"KRN",.84,7981012.002,2,16,0)
  <xsl:value-of select="$FILESWITCH"/>
"KRN",.84,7981012.002,2,17,0)
 </xsl:if>
"KRN",.84,7981012.002,2,18,0)
 <xsl:if test="/REPORT/PARAMETERS/OPTIONS/@LAB">
"KRN",.84,7981012.002,2,19,0)
  <xsl:text>Combined RX and Lab Report (Lab Results)</xsl:text>
"KRN",.84,7981012.002,2,20,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981012.002,2,21,0)
  <xsl:text>Patient Name,SSN,AIDS OI,Date,Test Name,Result</xsl:text>
"KRN",.84,7981012.002,2,22,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981012.002,2,23,0)
  <xsl:apply-templates select="/REPORT/PATIENTS/PATIENT" mode="LABS"/>
"KRN",.84,7981012.002,2,24,0)
  <xsl:value-of select="$FILESWITCH"/>
"KRN",.84,7981012.002,2,25,0)
 </xsl:if>
"KRN",.84,7981012.002,2,26,0)
</xsl:template>
"KRN",.84,7981012.002,2,27,0)
 
"KRN",.84,7981012.002,2,28,0)
<xsl:template match="PATIENTS/PATIENT" mode="DRUGS">
"KRN",.84,7981012.002,2,29,0)
 <xsl:variable name="ptname" select="NAME"/>
"KRN",.84,7981012.002,2,30,0)
 <xsl:variable name="ssn" select="LAST4"/>
"KRN",.84,7981012.002,2,31,0)
 <xsl:variable name="aidstat" select="AIDSTAT"/>
"KRN",.84,7981012.002,2,32,0)
 <xsl:for-each select="PTRXL/DRUG">
"KRN",.84,7981012.002,2,33,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981012.002,2,34,0)
   <xsl:with-param name="value" select="$ptname"/>
"KRN",.84,7981012.002,2,35,0)
  </xsl:call-template>
"KRN",.84,7981012.002,2,36,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981012.002,2,37,0)
   <xsl:with-param name="value" select="$ssn"/>
"KRN",.84,7981012.002,2,38,0)
  </xsl:call-template>
"KRN",.84,7981012.002,2,39,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981012.002,2,40,0)
   <xsl:with-param name="value" select="$aidstat"/>
"KRN",.84,7981012.002,2,41,0)
   <xsl:with-param name="yesno" select="1"/>
"KRN",.84,7981012.002,2,42,0)
  </xsl:call-template>
"KRN",.84,7981012.002,2,43,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981012.002,2,44,0)
   <xsl:with-param name="value" select="NAME"/>
"KRN",.84,7981012.002,2,45,0)
  </xsl:call-template>
"KRN",.84,7981012.002,2,46,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981012.002,2,47,0)
 </xsl:for-each>
"KRN",.84,7981012.002,2,48,0)
</xsl:template>
"KRN",.84,7981012.002,2,49,0)
 
"KRN",.84,7981012.002,2,50,0)
<xsl:template match="PATIENTS/PATIENT" mode="LABS">
"KRN",.84,7981012.002,2,51,0)
 <xsl:variable name="ptname" select="NAME"/>
"KRN",.84,7981012.002,2,52,0)
 <xsl:variable name="ssn" select="LAST4"/>
"KRN",.84,7981012.002,2,53,0)
 <xsl:variable name="aidstat" select="AIDSTAT"/>
"KRN",.84,7981012.002,2,54,0)
 <xsl:for-each select="PTLRL/LT">
"KRN",.84,7981012.002,2,55,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981012.002,2,56,0)
   <xsl:with-param name="value" select="$ptname"/>
"KRN",.84,7981012.002,2,57,0)
  </xsl:call-template>
"KRN",.84,7981012.002,2,58,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981012.002,2,59,0)
   <xsl:with-param name="value" select="$ssn"/>
"KRN",.84,7981012.002,2,60,0)
  </xsl:call-template>
"KRN",.84,7981012.002,2,61,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981012.002,2,62,0)
   <xsl:with-param name="value" select="$aidstat"/>
"KRN",.84,7981012.002,2,63,0)
   <xsl:with-param name="yesno" select="1"/>
"KRN",.84,7981012.002,2,64,0)
  </xsl:call-template>
"KRN",.84,7981012.002,2,65,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981012.002,2,66,0)
   <xsl:with-param name="value" select="DATE"/>
"KRN",.84,7981012.002,2,67,0)
   <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981012.002,2,68,0)
  </xsl:call-template>
"KRN",.84,7981012.002,2,69,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981012.002,2,70,0)
   <xsl:with-param name="value" select="NAME"/>
"KRN",.84,7981012.002,2,71,0)
  </xsl:call-template>
"KRN",.84,7981012.002,2,72,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981012.002,2,73,0)
   <xsl:with-param name="value" select="RESULT"/>
"KRN",.84,7981012.002,2,74,0)
  </xsl:call-template>
"KRN",.84,7981012.002,2,75,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981012.002,2,76,0)
 </xsl:for-each>
"KRN",.84,7981012.002,2,77,0)
</xsl:template>
"KRN",.84,7981012.002,2,78,0)
 
"KRN",.84,7981012.002,2,79,0)
</xsl:stylesheet>
"KRN",.84,7981013.001,-1)
0^33
"KRN",.84,7981013.001,0)
7981013.001^2^^CLINICAL CASE REGISTRIES^Diagnosis Code Report (HTML)
"KRN",.84,7981013.001,2,0)
^^163^163^3031212^
"KRN",.84,7981013.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981013.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981013.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981013.001,2,4,0)
>
"KRN",.84,7981013.001,2,5,0)
 
"KRN",.84,7981013.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   --> 
"KRN",.84,7981013.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981013.001,2,8,0)
 
"KRN",.84,7981013.001,2,9,0)
<xsl:template match="/">
"KRN",.84,7981013.001,2,10,0)
 <html>
"KRN",.84,7981013.001,2,11,0)
  <head>
"KRN",.84,7981013.001,2,12,0)
   <title>Diagnosis Code Report</title>
"KRN",.84,7981013.001,2,13,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981013.001,2,14,0)
  </head>
"KRN",.84,7981013.001,2,15,0)
  <body>
"KRN",.84,7981013.001,2,16,0)
   <h1>Diagnosis Code Report</h1>
"KRN",.84,7981013.001,2,17,0)
   <xsl:call-template name="ReportHeader"/>
"KRN",.84,7981013.001,2,18,0)
   <div style="page-break-before:always">
"KRN",.84,7981013.001,2,19,0)
    <xsl:call-template name="ReportSummary"/>
"KRN",.84,7981013.001,2,20,0)
    <xsl:apply-templates select="/REPORT/ICD9LST"/>
"KRN",.84,7981013.001,2,21,0)
   </div>
"KRN",.84,7981013.001,2,22,0)
   <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981013.001,2,23,0)
  </body>
"KRN",.84,7981013.001,2,24,0)
 </html>
"KRN",.84,7981013.001,2,25,0)
</xsl:template>
"KRN",.84,7981013.001,2,26,0)
 
"KRN",.84,7981013.001,2,27,0)
<xsl:template match="REPORT/ICD9LST">
"KRN",.84,7981013.001,2,28,0)
 <h2>ICD-9 Codes</h2>
"KRN",.84,7981013.001,2,29,0)
 <xsl:call-template name="DataGrid"/>
"KRN",.84,7981013.001,2,30,0)
</xsl:template>
"KRN",.84,7981013.001,2,31,0)
 
"KRN",.84,7981013.001,2,32,0)
<xsl:template match="REPORT/PATIENTS">
"KRN",.84,7981013.001,2,33,0)
 <div style="page-break-before:always">
"KRN",.84,7981013.001,2,34,0)
  <h2>Patients</h2>
"KRN",.84,7981013.001,2,35,0)
  <xsl:call-template name="DataGrid">
"KRN",.84,7981013.001,2,36,0)
   <xsl:with-param name="scroll" select="descendant::ICD9[31]"/>
"KRN",.84,7981013.001,2,37,0)
  </xsl:call-template>
"KRN",.84,7981013.001,2,38,0)
 </div>
"KRN",.84,7981013.001,2,39,0)
</xsl:template>
"KRN",.84,7981013.001,2,40,0)
 
"KRN",.84,7981013.001,2,41,0)
<!--[ TABLE HEADERS ]-->
"KRN",.84,7981013.001,2,42,0)
 
"KRN",.84,7981013.001,2,43,0)
<xsl:template match="HEADER/TBLDEF[@NAME='PATIENTS']/@HEADER">
"KRN",.84,7981013.001,2,44,0)
 <xsl:variable name="PTICDL" select="../COLUMN[@NAME='PTICDL']"/>
"KRN",.84,7981013.001,2,45,0)
 <thead>
"KRN",.84,7981013.001,2,46,0)
  <tr>
"KRN",.84,7981013.001,2,47,0)
   <xsl:apply-templates select="../COLUMN[@NAME!='PTICDL']">
"KRN",.84,7981013.001,2,48,0)
    <xsl:with-param name="rowspan" select="2"/>
"KRN",.84,7981013.001,2,49,0)
   </xsl:apply-templates>
"KRN",.84,7981013.001,2,50,0)
   <xsl:call-template name="ColumnHeader">
"KRN",.84,7981013.001,2,51,0)
    <xsl:with-param name="column" select="$PTICDL"/>
"KRN",.84,7981013.001,2,52,0)
    <xsl:with-param name="title" select="'ICD-9'"/>                 
"KRN",.84,7981013.001,2,53,0)
    <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981013.001,2,54,0)
    <xsl:with-param name="width" select="'50%'"/>
"KRN",.84,7981013.001,2,55,0)
    <xsl:with-param name="colspan" select="3"/>
"KRN",.84,7981013.001,2,56,0)
   </xsl:call-template>
"KRN",.84,7981013.001,2,57,0)
  </tr>
"KRN",.84,7981013.001,2,58,0)
  <tr>
"KRN",.84,7981013.001,2,59,0)
   <xsl:apply-templates select="$PTICDL/*"/>
"KRN",.84,7981013.001,2,60,0)
  </tr>
"KRN",.84,7981013.001,2,61,0)
 </thead>
"KRN",.84,7981013.001,2,62,0)
</xsl:template>
"KRN",.84,7981013.001,2,63,0)
 
"KRN",.84,7981013.001,2,64,0)
<xsl:template match="COLUMN[@NAME='CODE']">
"KRN",.84,7981013.001,2,65,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981013.001,2,66,0)
  <xsl:with-param name="title" select="'Code'"/>
"KRN",.84,7981013.001,2,67,0)
  <xsl:with-param name="width" select="'5%'"/>
"KRN",.84,7981013.001,2,68,0)
 </xsl:call-template>
"KRN",.84,7981013.001,2,69,0)
</xsl:template>
"KRN",.84,7981013.001,2,70,0)
 
"KRN",.84,7981013.001,2,71,0)
<xsl:template match="COLUMN[@NAME='DATE']">
"KRN",.84,7981013.001,2,72,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981013.001,2,73,0)
  <xsl:with-param name="title" select="'Date'"/>
"KRN",.84,7981013.001,2,74,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981013.001,2,75,0)
 </xsl:call-template>
"KRN",.84,7981013.001,2,76,0)
</xsl:template>
"KRN",.84,7981013.001,2,77,0)
 
"KRN",.84,7981013.001,2,78,0)
<xsl:template match="COLUMN[@NAME='DIAG']">
"KRN",.84,7981013.001,2,79,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981013.001,2,80,0)
  <xsl:with-param name="title" select="'Diagnosis'"/>
"KRN",.84,7981013.001,2,81,0)
 </xsl:call-template>
"KRN",.84,7981013.001,2,82,0)
</xsl:template>
"KRN",.84,7981013.001,2,83,0)
 
"KRN",.84,7981013.001,2,84,0)
<xsl:template match="COLUMN[@NAME='NC']">
"KRN",.84,7981013.001,2,85,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981013.001,2,86,0)
  <xsl:with-param name="title" select="'Number of Codes'"/>
"KRN",.84,7981013.001,2,87,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981013.001,2,88,0)
 </xsl:call-template>
"KRN",.84,7981013.001,2,89,0)
</xsl:template>
"KRN",.84,7981013.001,2,90,0)
 
"KRN",.84,7981013.001,2,91,0)
<xsl:template match="COLUMN[@NAME='NP']">
"KRN",.84,7981013.001,2,92,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981013.001,2,93,0)
  <xsl:with-param name="title" select="'Number of Patients'"/>
"KRN",.84,7981013.001,2,94,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981013.001,2,95,0)
 </xsl:call-template>
"KRN",.84,7981013.001,2,96,0)
</xsl:template>
"KRN",.84,7981013.001,2,97,0)
 
"KRN",.84,7981013.001,2,98,0)
<!--[ TABLE CELLS ]-->
"KRN",.84,7981013.001,2,99,0)
 
"KRN",.84,7981013.001,2,100,0)
<xsl:template match="PATIENTS/PATIENT">
"KRN",.84,7981013.001,2,101,0)
 <xsl:variable name="rowspan" select="count(PTICDL/ICD9)"/>
"KRN",.84,7981013.001,2,102,0)
 <tr>
"KRN",.84,7981013.001,2,103,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981013.001,2,104,0)
   <xsl:with-param name="value" select="position()"/>
"KRN",.84,7981013.001,2,105,0)
   <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981013.001,2,106,0)
  </xsl:call-template>
"KRN",.84,7981013.001,2,107,0)
   <xsl:apply-templates select="*[name(.)!='PTICDL']">
"KRN",.84,7981013.001,2,108,0)
   <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981013.001,2,109,0)
  </xsl:apply-templates>
"KRN",.84,7981013.001,2,110,0)
  <xsl:for-each select="PTICDL/ICD9[1]">
"KRN",.84,7981013.001,2,111,0)
   <xsl:call-template name="ICD9Data"/>
"KRN",.84,7981013.001,2,112,0)
  </xsl:for-each>
"KRN",.84,7981013.001,2,113,0)
 </tr>
"KRN",.84,7981013.001,2,114,0)
 <xsl:for-each select="PTICDL/ICD9[position()>1]">
"KRN",.84,7981013.001,2,115,0)
  <tr>
"KRN",.84,7981013.001,2,116,0)
   <xsl:call-template name="ICD9Data"/>
"KRN",.84,7981013.001,2,117,0)
  </tr>
"KRN",.84,7981013.001,2,118,0)
 </xsl:for-each>
"KRN",.84,7981013.001,2,119,0)
</xsl:template>
"KRN",.84,7981013.001,2,120,0)
 
"KRN",.84,7981013.001,2,121,0)
<xsl:template match="DIAG">
"KRN",.84,7981013.001,2,122,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981013.001,2,123,0)
  <xsl:with-param name="class" select="'aLeft'"/>
"KRN",.84,7981013.001,2,124,0)
 </xsl:call-template>
"KRN",.84,7981013.001,2,125,0)
</xsl:template>
"KRN",.84,7981013.001,2,126,0)
 
"KRN",.84,7981013.001,2,127,0)
<!--[ UTILITIES ]-->
"KRN",.84,7981013.001,2,128,0)
 
"KRN",.84,7981013.001,2,129,0)
<xsl:template name="ICD9Data">
"KRN",.84,7981013.001,2,130,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981013.001,2,131,0)
  <xsl:with-param name="value" select="CODE"/>
"KRN",.84,7981013.001,2,132,0)
 </xsl:call-template>
"KRN",.84,7981013.001,2,133,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981013.001,2,134,0)
  <xsl:with-param name="value" select="DIAG"/>
"KRN",.84,7981013.001,2,135,0)
  <xsl:with-param name="class" select="'aLeft'"/>
"KRN",.84,7981013.001,2,136,0)
 </xsl:call-template>
"KRN",.84,7981013.001,2,137,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981013.001,2,138,0)
  <xsl:with-param name="value" select="DATE"/>
"KRN",.84,7981013.001,2,139,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981013.001,2,140,0)
 </xsl:call-template>
"KRN",.84,7981013.001,2,141,0)
</xsl:template>
"KRN",.84,7981013.001,2,142,0)
 
"KRN",.84,7981013.001,2,143,0)
<xsl:template name="ReportSummary">
"KRN",.84,7981013.001,2,144,0)
 <xsl:param name="summary" select="/REPORT/SUMMARY"/>
"KRN",.84,7981013.001,2,145,0)
 <table width="100%" cellpadding="5" cellspacing="0">
"KRN",.84,7981013.001,2,146,0)
  <thead>
"KRN",.84,7981013.001,2,147,0)
   <tr>
"KRN",.84,7981013.001,2,148,0)
    <th width="33%">Number of Patients</th>
"KRN",.84,7981013.001,2,149,0)
    <th width="33%">Number of Codes</th>
"KRN",.84,7981013.001,2,150,0)
    <th width="33%">Number of Different Codes </th>
"KRN",.84,7981013.001,2,151,0)
   </tr>
"KRN",.84,7981013.001,2,152,0)
  </thead>
"KRN",.84,7981013.001,2,153,0)
  <tbody>
"KRN",.84,7981013.001,2,154,0)
   <tr>
"KRN",.84,7981013.001,2,155,0)
    <td><xsl:value-of select="$summary/NP"/></td>
"KRN",.84,7981013.001,2,156,0)
    <td><xsl:value-of select="$summary/NC"/></td>
"KRN",.84,7981013.001,2,157,0)
    <td><xsl:value-of select="$summary/NDC"/></td>
"KRN",.84,7981013.001,2,158,0)
   </tr>
"KRN",.84,7981013.001,2,159,0)
  </tbody>
"KRN",.84,7981013.001,2,160,0)
 </table>
"KRN",.84,7981013.001,2,161,0)
</xsl:template>
"KRN",.84,7981013.001,2,162,0)
 
"KRN",.84,7981013.001,2,163,0)
</xsl:stylesheet>
"KRN",.84,7981013.002,-1)
0^50
"KRN",.84,7981013.002,0)
7981013.002^2^^CLINICAL CASE REGISTRIES^Diagnosis Code Report (CSV)
"KRN",.84,7981013.002,2,0)
^^86^86^3031212^
"KRN",.84,7981013.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981013.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981013.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981013.002,2,4,0)
>
"KRN",.84,7981013.002,2,5,0)
 
"KRN",.84,7981013.002,2,6,0)
<xsl:import href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981013.002,2,7,0)
 
"KRN",.84,7981013.002,2,8,0)
<xsl:template match="/">
"KRN",.84,7981013.002,2,9,0)
 <xsl:apply-templates select="/REPORT/ICD9LST"/>
"KRN",.84,7981013.002,2,10,0)
 <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981013.002,2,11,0)
</xsl:template>
"KRN",.84,7981013.002,2,12,0)
 
"KRN",.84,7981013.002,2,13,0)
<xsl:template match="REPORT/ICD9LST">
"KRN",.84,7981013.002,2,14,0)
 <xsl:text>Diagnosis Code Report (ICD-9 Codes)</xsl:text>
"KRN",.84,7981013.002,2,15,0)
 <xsl:call-template name="DataGrid"/>
"KRN",.84,7981013.002,2,16,0)
 <xsl:value-of select="$FILESWITCH"/>
"KRN",.84,7981013.002,2,17,0)
</xsl:template>
"KRN",.84,7981013.002,2,18,0)
 
"KRN",.84,7981013.002,2,19,0)
<xsl:template match="REPORT/PATIENTS">
"KRN",.84,7981013.002,2,20,0)
 <xsl:text>Diagnosis Code Report (Patients)</xsl:text>
"KRN",.84,7981013.002,2,21,0)
 <xsl:call-template name="DataGrid"/>
"KRN",.84,7981013.002,2,22,0)
 <xsl:value-of select="$FILESWITCH"/>
"KRN",.84,7981013.002,2,23,0)
</xsl:template>
"KRN",.84,7981013.002,2,24,0)
 
"KRN",.84,7981013.002,2,25,0)
<xsl:template match="PATIENTS/PATIENT">
"KRN",.84,7981013.002,2,26,0)
 <xsl:variable name="ptname" select="NAME"/>
"KRN",.84,7981013.002,2,27,0)
 <xsl:variable name="ssn" select="LAST4"/>
"KRN",.84,7981013.002,2,28,0)
 <xsl:variable name="aidstat" select="AIDSTAT"/>
"KRN",.84,7981013.002,2,29,0)
 <xsl:for-each select="PTICDL/ICD9">
"KRN",.84,7981013.002,2,30,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981013.002,2,31,0)
   <xsl:with-param name="value" select="$ptname"/>
"KRN",.84,7981013.002,2,32,0)
  </xsl:call-template>
"KRN",.84,7981013.002,2,33,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981013.002,2,34,0)
   <xsl:with-param name="value" select="$ssn"/>
"KRN",.84,7981013.002,2,35,0)
  </xsl:call-template>
"KRN",.84,7981013.002,2,36,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981013.002,2,37,0)
   <xsl:with-param name="value" select="$aidstat"/>
"KRN",.84,7981013.002,2,38,0)
   <xsl:with-param name="yesno" select="1"/>
"KRN",.84,7981013.002,2,39,0)
  </xsl:call-template>
"KRN",.84,7981013.002,2,40,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981013.002,2,41,0)
   <xsl:with-param name="value" select="CODE"/>
"KRN",.84,7981013.002,2,42,0)
  </xsl:call-template>
"KRN",.84,7981013.002,2,43,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981013.002,2,44,0)
   <xsl:with-param name="value" select="DIAG"/>
"KRN",.84,7981013.002,2,45,0)
  </xsl:call-template>
"KRN",.84,7981013.002,2,46,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981013.002,2,47,0)
   <xsl:with-param name="value" select="DATE"/>
"KRN",.84,7981013.002,2,48,0)
   <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981013.002,2,49,0)
  </xsl:call-template>
"KRN",.84,7981013.002,2,50,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981013.002,2,51,0)
 </xsl:for-each>
"KRN",.84,7981013.002,2,52,0)
</xsl:template>
"KRN",.84,7981013.002,2,53,0)
 
"KRN",.84,7981013.002,2,54,0)
<!--[ TABLE HEADERS ]-->
"KRN",.84,7981013.002,2,55,0)
 
"KRN",.84,7981013.002,2,56,0)
<xsl:template match="COLUMN[@NAME='CODE']">
"KRN",.84,7981013.002,2,57,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981013.002,2,58,0)
  <xsl:with-param name="title" select="'Code'"/>
"KRN",.84,7981013.002,2,59,0)
 </xsl:call-template>
"KRN",.84,7981013.002,2,60,0)
</xsl:template>
"KRN",.84,7981013.002,2,61,0)
 
"KRN",.84,7981013.002,2,62,0)
<xsl:template match="COLUMN[@NAME='DATE']">
"KRN",.84,7981013.002,2,63,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981013.002,2,64,0)
  <xsl:with-param name="title" select="'Date'"/>
"KRN",.84,7981013.002,2,65,0)
 </xsl:call-template>
"KRN",.84,7981013.002,2,66,0)
</xsl:template>
"KRN",.84,7981013.002,2,67,0)
 
"KRN",.84,7981013.002,2,68,0)
<xsl:template match="COLUMN[@NAME='DIAG']">
"KRN",.84,7981013.002,2,69,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981013.002,2,70,0)
  <xsl:with-param name="title" select="'Diagnosis'"/>
"KRN",.84,7981013.002,2,71,0)
 </xsl:call-template>
"KRN",.84,7981013.002,2,72,0)
</xsl:template>
"KRN",.84,7981013.002,2,73,0)
 
"KRN",.84,7981013.002,2,74,0)
<xsl:template match="COLUMN[@NAME='NC']">
"KRN",.84,7981013.002,2,75,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981013.002,2,76,0)
  <xsl:with-param name="title" select="'Number of Codes'"/>
"KRN",.84,7981013.002,2,77,0)
 </xsl:call-template>
"KRN",.84,7981013.002,2,78,0)
</xsl:template>
"KRN",.84,7981013.002,2,79,0)
 
"KRN",.84,7981013.002,2,80,0)
<xsl:template match="COLUMN[@NAME='NP']">
"KRN",.84,7981013.002,2,81,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981013.002,2,82,0)
  <xsl:with-param name="title" select="'Number of Patients'"/>
"KRN",.84,7981013.002,2,83,0)
 </xsl:call-template>
"KRN",.84,7981013.002,2,84,0)
</xsl:template>
"KRN",.84,7981013.002,2,85,0)
 
"KRN",.84,7981013.002,2,86,0)
</xsl:stylesheet>
"KRN",.84,7981014.001,-1)
0^37
"KRN",.84,7981014.001,0)
7981014.001^2^^CLINICAL CASE REGISTRIES^ARV Combination Report (HTML)
"KRN",.84,7981014.001,2,0)
^^122^122^3040112^
"KRN",.84,7981014.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981014.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981014.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981014.001,2,4,0)
>
"KRN",.84,7981014.001,2,5,0)
 
"KRN",.84,7981014.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   --> 
"KRN",.84,7981014.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981014.001,2,8,0)
<xsl:include href="template://report/997/1"/>  <!-- Patients -->            
"KRN",.84,7981014.001,2,9,0)
<xsl:include href="template://report/996/1"/>  <!-- Pharmacy -->
"KRN",.84,7981014.001,2,10,0)
 
"KRN",.84,7981014.001,2,11,0)
<xsl:variable name="complete" select="/REPORT/PARAMETERS/OPTIONS/@COMPLETE"/>
"KRN",.84,7981014.001,2,12,0)
 
"KRN",.84,7981014.001,2,13,0)
<xsl:template match="/">
"KRN",.84,7981014.001,2,14,0)
 <html>
"KRN",.84,7981014.001,2,15,0)
  <head>
"KRN",.84,7981014.001,2,16,0)
   <title>ARV Combination Report</title>
"KRN",.84,7981014.001,2,17,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981014.001,2,18,0)
   <style type="text/css">
"KRN",.84,7981014.001,2,19,0)
    td.DrugComb {
"KRN",.84,7981014.001,2,20,0)
     font-weight: bold;
"KRN",.84,7981014.001,2,21,0)
     text-align: left;
"KRN",.84,7981014.001,2,22,0)
     background-color: #EEEEEE;
"KRN",.84,7981014.001,2,23,0)
    }
"KRN",.84,7981014.001,2,24,0)
   </style>
"KRN",.84,7981014.001,2,25,0)
  </head>
"KRN",.84,7981014.001,2,26,0)
  <body>
"KRN",.84,7981014.001,2,27,0)
   <h1>ARV Combination Report</h1>
"KRN",.84,7981014.001,2,28,0)
   <xsl:call-template name="ReportHeader"/>
"KRN",.84,7981014.001,2,29,0)
   <div style="page-break-before:always">
"KRN",.84,7981014.001,2,30,0)
    <xsl:apply-templates select="/REPORT/RXCOMBLST"/>
"KRN",.84,7981014.001,2,31,0)
   </div>
"KRN",.84,7981014.001,2,32,0)
  </body>
"KRN",.84,7981014.001,2,33,0)
 </html>
"KRN",.84,7981014.001,2,34,0)
</xsl:template>
"KRN",.84,7981014.001,2,35,0)
 
"KRN",.84,7981014.001,2,36,0)
<xsl:template match="RXCOMBLST">
"KRN",.84,7981014.001,2,37,0)
 <xsl:call-template name="DataGrid">
"KRN",.84,7981014.001,2,38,0)
  <xsl:with-param name="scroll" select="*[31] or descendant::PATIENT[31]"/>
"KRN",.84,7981014.001,2,39,0)
 </xsl:call-template>
"KRN",.84,7981014.001,2,40,0)
</xsl:template>
"KRN",.84,7981014.001,2,41,0)
 
"KRN",.84,7981014.001,2,42,0)
<xsl:template match="HEADER/TBLDEF[@NAME='RXCOMBLST']/@HEADER">
"KRN",.84,7981014.001,2,43,0)
 <thead>
"KRN",.84,7981014.001,2,44,0)
  <xsl:choose>
"KRN",.84,7981014.001,2,45,0)
   <xsl:when test="$complete">
"KRN",.84,7981014.001,2,46,0)
    <tr>
"KRN",.84,7981014.001,2,47,0)
     <xsl:call-template name="ColumnHeader">
"KRN",.84,7981014.001,2,48,0)
      <xsl:with-param name="title" select="'Number of Patients'"/>
"KRN",.84,7981014.001,2,49,0)
      <xsl:with-param name="rowspan" select="2"/>
"KRN",.84,7981014.001,2,50,0)
      <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981014.001,2,51,0)
     </xsl:call-template>
"KRN",.84,7981014.001,2,52,0)
     <xsl:call-template name="ColumnHeader">
"KRN",.84,7981014.001,2,53,0)
      <xsl:with-param name="title" select="'Combination of Drugs'"/>
"KRN",.84,7981014.001,2,54,0)
      <xsl:with-param name="colspan" select="3"/>
"KRN",.84,7981014.001,2,55,0)
      <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981014.001,2,56,0)
     </xsl:call-template>
"KRN",.84,7981014.001,2,57,0)
    </tr>
"KRN",.84,7981014.001,2,58,0)
    <tr>
"KRN",.84,7981014.001,2,59,0)
     <xsl:call-template name="BasicPatientHeader">
"KRN",.84,7981014.001,2,60,0)
      <xsl:with-param name="seqnum" select="0"/>
"KRN",.84,7981014.001,2,61,0)
     </xsl:call-template>
"KRN",.84,7981014.001,2,62,0)
    </tr>
"KRN",.84,7981014.001,2,63,0)
   </xsl:when>
"KRN",.84,7981014.001,2,64,0)
   <xsl:otherwise>
"KRN",.84,7981014.001,2,65,0)
    <tr>
"KRN",.84,7981014.001,2,66,0)
     <xsl:call-template name="ColumnHeader">
"KRN",.84,7981014.001,2,67,0)
      <xsl:with-param name="title" select="'Number of Patients'"/>
"KRN",.84,7981014.001,2,68,0)
      <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981014.001,2,69,0)
     </xsl:call-template>
"KRN",.84,7981014.001,2,70,0)
     <xsl:call-template name="ColumnHeader">
"KRN",.84,7981014.001,2,71,0)
      <xsl:with-param name="title" select="'Combination of Drugs'"/>
"KRN",.84,7981014.001,2,72,0)
      <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981014.001,2,73,0)
     </xsl:call-template>
"KRN",.84,7981014.001,2,74,0)
    </tr>
"KRN",.84,7981014.001,2,75,0)
   </xsl:otherwise>
"KRN",.84,7981014.001,2,76,0)
  </xsl:choose>
"KRN",.84,7981014.001,2,77,0)
 </thead>
"KRN",.84,7981014.001,2,78,0)
</xsl:template>
"KRN",.84,7981014.001,2,79,0)
 
"KRN",.84,7981014.001,2,80,0)
<xsl:template match="RXCOMBLST/RXCOMB">
"KRN",.84,7981014.001,2,81,0)
 <xsl:choose>
"KRN",.84,7981014.001,2,82,0)
  <xsl:when test="$complete">
"KRN",.84,7981014.001,2,83,0)
   <xsl:variable name="rowspan" select="count(PATIENTS/PATIENT)+1"/>
"KRN",.84,7981014.001,2,84,0)
   <tr>
"KRN",.84,7981014.001,2,85,0)
    <xsl:call-template name="TableCell">
"KRN",.84,7981014.001,2,86,0)
     <xsl:with-param name="value" select="NP"/>
"KRN",.84,7981014.001,2,87,0)
     <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981014.001,2,88,0)
     <xsl:with-param name="width" select="'5%'"/>
"KRN",.84,7981014.001,2,89,0)
    </xsl:call-template>
"KRN",.84,7981014.001,2,90,0)
    <td class="DrugComb" colspan="3">
"KRN",.84,7981014.001,2,91,0)
     <xsl:call-template name="DrugCombination"/>
"KRN",.84,7981014.001,2,92,0)
    </td>
"KRN",.84,7981014.001,2,93,0)
   </tr>
"KRN",.84,7981014.001,2,94,0)
   <xsl:for-each select="PATIENTS/PATIENT">
"KRN",.84,7981014.001,2,95,0)
    <tr>
"KRN",.84,7981014.001,2,96,0)
     <xsl:call-template name="BasicPatientData">
"KRN",.84,7981014.001,2,97,0)
      <xsl:with-param name="seqnum" select="0"/>
"KRN",.84,7981014.001,2,98,0)
     </xsl:call-template>
"KRN",.84,7981014.001,2,99,0)
    </tr>
"KRN",.84,7981014.001,2,100,0)
   </xsl:for-each>
"KRN",.84,7981014.001,2,101,0)
  </xsl:when>
"KRN",.84,7981014.001,2,102,0)
  <xsl:otherwise>
"KRN",.84,7981014.001,2,103,0)
   <tr>
"KRN",.84,7981014.001,2,104,0)
    <xsl:call-template name="TableCell">
"KRN",.84,7981014.001,2,105,0)
     <xsl:with-param name="value" select="NP"/>
"KRN",.84,7981014.001,2,106,0)
     <xsl:with-param name="width" select="'5%'"/>
"KRN",.84,7981014.001,2,107,0)
    </xsl:call-template>
"KRN",.84,7981014.001,2,108,0)
    <td class="aLeft">
"KRN",.84,7981014.001,2,109,0)
     <xsl:call-template name="DrugCombination"/>
"KRN",.84,7981014.001,2,110,0)
    </td>
"KRN",.84,7981014.001,2,111,0)
   </tr>
"KRN",.84,7981014.001,2,112,0)
  </xsl:otherwise>
"KRN",.84,7981014.001,2,113,0)
 </xsl:choose>
"KRN",.84,7981014.001,2,114,0)
</xsl:template>
"KRN",.84,7981014.001,2,115,0)
 
"KRN",.84,7981014.001,2,116,0)
<xsl:template name="DrugCombination">
"KRN",.84,7981014.001,2,117,0)
 <xsl:for-each select="DRUGS/NAME">
"KRN",.84,7981014.001,2,118,0)
  <xsl:if test="position()>1">; </xsl:if><xsl:value-of select="."/>
"KRN",.84,7981014.001,2,119,0)
 </xsl:for-each>
"KRN",.84,7981014.001,2,120,0)
</xsl:template>
"KRN",.84,7981014.001,2,121,0)
 
"KRN",.84,7981014.001,2,122,0)
</xsl:stylesheet>
"KRN",.84,7981014.002,-1)
0^51
"KRN",.84,7981014.002,0)
7981014.002^2^^CLINICAL CASE REGISTRIES^ARV Combination Report (CSV)
"KRN",.84,7981014.002,2,0)
^^69^69^3031212^
"KRN",.84,7981014.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981014.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981014.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981014.002,2,4,0)
>
"KRN",.84,7981014.002,2,5,0)
 
"KRN",.84,7981014.002,2,6,0)
<xsl:import href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981014.002,2,7,0)
  
"KRN",.84,7981014.002,2,8,0)
<xsl:variable name="complete" select="/REPORT/PARAMETERS/OPTIONS/@COMPLETE"/>
"KRN",.84,7981014.002,2,9,0)
 
"KRN",.84,7981014.002,2,10,0)
<xsl:template match="/">
"KRN",.84,7981014.002,2,11,0)
 <xsl:text>ARV Combination Report</xsl:text>
"KRN",.84,7981014.002,2,12,0)
 <xsl:value-of select="$CRLF"/>
"KRN",.84,7981014.002,2,13,0)
 <xsl:text>Number of Patients,Combination of Drugs</xsl:text>
"KRN",.84,7981014.002,2,14,0)
 <xsl:if test="$complete">
"KRN",.84,7981014.002,2,15,0)
  <xsl:text>,Patient Name,SSN,AIDS OI</xsl:text>
"KRN",.84,7981014.002,2,16,0)
 </xsl:if>
"KRN",.84,7981014.002,2,17,0)
 <xsl:value-of select="$CRLF"/>
"KRN",.84,7981014.002,2,18,0)
 <xsl:apply-templates select="/REPORT/RXCOMBLST/RXCOMB"/>
"KRN",.84,7981014.002,2,19,0)
 <xsl:if test="not(/REPORT/RXCOMBLST/RXCOMB[1])">
"KRN",.84,7981014.002,2,20,0)
  <xsl:call-template name="TableNoData"/>
"KRN",.84,7981014.002,2,21,0)
 </xsl:if>
"KRN",.84,7981014.002,2,22,0)
</xsl:template>
"KRN",.84,7981014.002,2,23,0)
 
"KRN",.84,7981014.002,2,24,0)
<xsl:template match="RXCOMBLST/RXCOMB">
"KRN",.84,7981014.002,2,25,0)
 <xsl:choose>
"KRN",.84,7981014.002,2,26,0)
  <xsl:when test="$complete">
"KRN",.84,7981014.002,2,27,0)
   <xsl:variable name="np" select="NP"/>
"KRN",.84,7981014.002,2,28,0)
   <xsl:variable name="drugs" select="DRUGS"/>
"KRN",.84,7981014.002,2,29,0)
   <xsl:for-each select="PATIENTS/PATIENT">
"KRN",.84,7981014.002,2,30,0)
    <xsl:call-template name="TableCell">
"KRN",.84,7981014.002,2,31,0)
     <xsl:with-param name="value" select="$np"/>
"KRN",.84,7981014.002,2,32,0)
    </xsl:call-template>
"KRN",.84,7981014.002,2,33,0)
    <xsl:call-template name="DrugCombination">
"KRN",.84,7981014.002,2,34,0)
     <xsl:with-param name="drugs" select="$drugs"/>
"KRN",.84,7981014.002,2,35,0)
    </xsl:call-template>
"KRN",.84,7981014.002,2,36,0)
    <xsl:call-template name="TableCell">
"KRN",.84,7981014.002,2,37,0)
     <xsl:with-param name="value" select="NAME"/>
"KRN",.84,7981014.002,2,38,0)
    </xsl:call-template>
"KRN",.84,7981014.002,2,39,0)
    <xsl:call-template name="TableCell">
"KRN",.84,7981014.002,2,40,0)
     <xsl:with-param name="value" select="LAST4"/>
"KRN",.84,7981014.002,2,41,0)
    </xsl:call-template>
"KRN",.84,7981014.002,2,42,0)
    <xsl:call-template name="TableCell">
"KRN",.84,7981014.002,2,43,0)
     <xsl:with-param name="value" select="AIDSTAT"/>
"KRN",.84,7981014.002,2,44,0)
     <xsl:with-param name="yesno" select="1"/>
"KRN",.84,7981014.002,2,45,0)
    </xsl:call-template>
"KRN",.84,7981014.002,2,46,0)
    <xsl:value-of select="$CRLF"/>
"KRN",.84,7981014.002,2,47,0)
   </xsl:for-each>
"KRN",.84,7981014.002,2,48,0)
  </xsl:when>
"KRN",.84,7981014.002,2,49,0)
  <xsl:otherwise>
"KRN",.84,7981014.002,2,50,0)
   <xsl:call-template name="TableCell">
"KRN",.84,7981014.002,2,51,0)
    <xsl:with-param name="value" select="NP"/>
"KRN",.84,7981014.002,2,52,0)
   </xsl:call-template>
"KRN",.84,7981014.002,2,53,0)
   <xsl:call-template name="DrugCombination"/>
"KRN",.84,7981014.002,2,54,0)
   <xsl:value-of select="$CRLF"/>
"KRN",.84,7981014.002,2,55,0)
  </xsl:otherwise>
"KRN",.84,7981014.002,2,56,0)
 </xsl:choose>
"KRN",.84,7981014.002,2,57,0)
</xsl:template>
"KRN",.84,7981014.002,2,58,0)
 
"KRN",.84,7981014.002,2,59,0)
<xsl:template name="DrugCombination">
"KRN",.84,7981014.002,2,60,0)
 <xsl:param name="drugs" select="DRUGS"/>
"KRN",.84,7981014.002,2,61,0)
 <xsl:text>&quot;</xsl:text>
"KRN",.84,7981014.002,2,62,0)
 <xsl:for-each select="$drugs/NAME">
"KRN",.84,7981014.002,2,63,0)
  <xsl:if test="position()>1">; </xsl:if>
"KRN",.84,7981014.002,2,64,0)
  <xsl:call-template name="DoubleQuotes"/>
"KRN",.84,7981014.002,2,65,0)
 </xsl:for-each>
"KRN",.84,7981014.002,2,66,0)
 <xsl:text>&quot;,</xsl:text>
"KRN",.84,7981014.002,2,67,0)
</xsl:template>
"KRN",.84,7981014.002,2,68,0)
 
"KRN",.84,7981014.002,2,69,0)
</xsl:stylesheet>
"KRN",.84,7981995.001,-1)
0^38
"KRN",.84,7981995.001,0)
7981995.001^2^^CLINICAL CASE REGISTRIES^Lab data templates (HTML)
"KRN",.84,7981995.001,2,0)
^.844^62^62^3031211^^^^
"KRN",.84,7981995.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981995.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981995.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981995.001,2,4,0)
>
"KRN",.84,7981995.001,2,5,0)
 
"KRN",.84,7981995.001,2,6,0)
<!--[ UTILITIES ]-->
"KRN",.84,7981995.001,2,7,0)
 
"KRN",.84,7981995.001,2,8,0)
<xsl:template name="BasicLRHeader">
"KRN",.84,7981995.001,2,9,0)
 <xsl:param name="group" select="0"/>
"KRN",.84,7981995.001,2,10,0)
 <xsl:param name="tblname" select="'PTLRL'"/>
"KRN",.84,7981995.001,2,11,0)
 <xsl:if test="$group">
"KRN",.84,7981995.001,2,12,0)
  <xsl:call-template name="ColumnHeader">
"KRN",.84,7981995.001,2,13,0)
   <xsl:with-param name="sort" select="concat($tblname,'=GROUP')"/>
"KRN",.84,7981995.001,2,14,0)
   <xsl:with-param name="title" select="'Group'"/>
"KRN",.84,7981995.001,2,15,0)
   <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981995.001,2,16,0)
  </xsl:call-template>
"KRN",.84,7981995.001,2,17,0)
 </xsl:if>
"KRN",.84,7981995.001,2,18,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981995.001,2,19,0)
  <xsl:with-param name="sort" select="concat($tblname,'=DATE')"/>
"KRN",.84,7981995.001,2,20,0)
  <xsl:with-param name="title" select="'Date'"/>    
"KRN",.84,7981995.001,2,21,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981995.001,2,22,0)
 </xsl:call-template>
"KRN",.84,7981995.001,2,23,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981995.001,2,24,0)
  <xsl:with-param name="sort" select="concat($tblname,'=NAME')"/>
"KRN",.84,7981995.001,2,25,0)
  <xsl:with-param name="title" select="'Test Name'"/>    
"KRN",.84,7981995.001,2,26,0)
 </xsl:call-template>
"KRN",.84,7981995.001,2,27,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981995.001,2,28,0)
  <xsl:with-param name="sort" select="concat($tblname,'=RESULT')"/>
"KRN",.84,7981995.001,2,29,0)
  <xsl:with-param name="title" select="'Result'"/>
"KRN",.84,7981995.001,2,30,0)
  <xsl:with-param name="width" select="'10%'"/>
"KRN",.84,7981995.001,2,31,0)
 </xsl:call-template>
"KRN",.84,7981995.001,2,32,0)
</xsl:template>
"KRN",.84,7981995.001,2,33,0)
 
"KRN",.84,7981995.001,2,34,0)
<xsl:template name="BasicLRData">
"KRN",.84,7981995.001,2,35,0)
 <xsl:param name="group" select="0"/>
"KRN",.84,7981995.001,2,36,0)
 <xsl:if test="$group">
"KRN",.84,7981995.001,2,37,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981995.001,2,38,0)
   <xsl:with-param name="value" select="GROUP"/>
"KRN",.84,7981995.001,2,39,0)
  </xsl:call-template>
"KRN",.84,7981995.001,2,40,0)
 </xsl:if>
"KRN",.84,7981995.001,2,41,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981995.001,2,42,0)
  <xsl:with-param name="value" select="DATE"/>
"KRN",.84,7981995.001,2,43,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981995.001,2,44,0)
 </xsl:call-template>
"KRN",.84,7981995.001,2,45,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981995.001,2,46,0)
  <xsl:with-param name="class" select="'aLeft'"/>
"KRN",.84,7981995.001,2,47,0)
  <xsl:with-param name="value" select="NAME"/>
"KRN",.84,7981995.001,2,48,0)
 </xsl:call-template>
"KRN",.84,7981995.001,2,49,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981995.001,2,50,0)
  <xsl:with-param name="value" select="RESULT"/>
"KRN",.84,7981995.001,2,51,0)
 </xsl:call-template>
"KRN",.84,7981995.001,2,52,0)
</xsl:template>
"KRN",.84,7981995.001,2,53,0)
 
"KRN",.84,7981995.001,2,54,0)
<!--[ REPORT PARAMETERS ]-->
"KRN",.84,7981995.001,2,55,0)
 
"KRN",.84,7981995.001,2,56,0)
<xsl:template match="PARAMETERS/LABTESTS">
"KRN",.84,7981995.001,2,57,0)
 <xsl:call-template name="ParamsList">
"KRN",.84,7981995.001,2,58,0)
  <xsl:with-param name="heading" select="'Lab Tests'"/>
"KRN",.84,7981995.001,2,59,0)
 </xsl:call-template>
"KRN",.84,7981995.001,2,60,0)
</xsl:template>
"KRN",.84,7981995.001,2,61,0)
 
"KRN",.84,7981995.001,2,62,0)
</xsl:stylesheet>
"KRN",.84,7981996.001,-1)
0^36
"KRN",.84,7981996.001,0)
7981996.001^2^^CLINICAL CASE REGISTRIES^Pharmacy data templates (HTML)
"KRN",.84,7981996.001,2,0)
^^54^54^3040112^
"KRN",.84,7981996.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981996.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981996.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
"KRN",.84,7981996.001,2,4,0)
 
"KRN",.84,7981996.001,2,5,0)
<!--[ TABLE HEADERS ]-->
"KRN",.84,7981996.001,2,6,0)
 
"KRN",.84,7981996.001,2,7,0)
<xsl:template
"KRN",.84,7981996.001,2,8,0)
     match="TBLDEF[starts-with(@NAME,'DRUGS') or @NAME='PTRXL']/COLUMN[@NAME='NAME']">
"KRN",.84,7981996.001,2,9,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981996.001,2,10,0)
  <xsl:with-param name="title" select="'Drug Name'"/>
"KRN",.84,7981996.001,2,11,0)
 </xsl:call-template>
"KRN",.84,7981996.001,2,12,0)
</xsl:template>
"KRN",.84,7981996.001,2,13,0)
 
"KRN",.84,7981996.001,2,14,0)
<!--[ PHARMACY REPORT PARAMETERS ]-->
"KRN",.84,7981996.001,2,15,0)
 
"KRN",.84,7981996.001,2,16,0)
<xsl:template match="PARAMETERS/DRUGS">
"KRN",.84,7981996.001,2,17,0)
 <tr>
"KRN",.84,7981996.001,2,18,0)
  <th scope="row">Drugs:&#160;</th>
"KRN",.84,7981996.001,2,19,0)
  <td>
"KRN",.84,7981996.001,2,20,0)
   <dl>
"KRN",.84,7981996.001,2,21,0)
    <xsl:if test="@DESCR!=''">
"KRN",.84,7981996.001,2,22,0)
     <dt><xsl:value-of select="@DESCR"/></dt>
"KRN",.84,7981996.001,2,23,0)
    </xsl:if>
"KRN",.84,7981996.001,2,24,0)
    <xsl:if test=".='ALL'"><dt>ALL</dt></xsl:if>
"KRN",.84,7981996.001,2,25,0)
    <xsl:for-each select="GROUP">
"KRN",.84,7981996.001,2,26,0)
     <xsl:call-template name="ParamsDrugGroup"/>
"KRN",.84,7981996.001,2,27,0)
    </xsl:for-each>
"KRN",.84,7981996.001,2,28,0)
    <xsl:if test="DRUG[1]">
"KRN",.84,7981996.001,2,29,0)
     <dt><xsl:call-template name="ParamsDrugList"/></dt>
"KRN",.84,7981996.001,2,30,0)
    </xsl:if>
"KRN",.84,7981996.001,2,31,0)
   </dl>
"KRN",.84,7981996.001,2,32,0)
  </td>
"KRN",.84,7981996.001,2,33,0)
 </tr>
"KRN",.84,7981996.001,2,34,0)
</xsl:template>
"KRN",.84,7981996.001,2,35,0)
 
"KRN",.84,7981996.001,2,36,0)
<xsl:template name="ParamsDrugGroup">
"KRN",.84,7981996.001,2,37,0)
 <dt><xsl:value-of select="concat('Drug Group #',position())"/></dt>
"KRN",.84,7981996.001,2,38,0)
 <dd><xsl:call-template name="ParamsDrugList"/></dd>
"KRN",.84,7981996.001,2,39,0)
</xsl:template>
"KRN",.84,7981996.001,2,40,0)
 
"KRN",.84,7981996.001,2,41,0)
<xsl:template name="ParamsDrugList">
"KRN",.84,7981996.001,2,42,0)
 <xsl:for-each select="DRUG">
"KRN",.84,7981996.001,2,43,0)
  <xsl:if test="position()>1"><xsl:text>; </xsl:text></xsl:if>
"KRN",.84,7981996.001,2,44,0)
  <xsl:value-of select="."/>
"KRN",.84,7981996.001,2,45,0)
 </xsl:for-each>
"KRN",.84,7981996.001,2,46,0)
</xsl:template>
"KRN",.84,7981996.001,2,47,0)
 
"KRN",.84,7981996.001,2,48,0)
<xsl:template match="PARAMETERS/VARXCLS">
"KRN",.84,7981996.001,2,49,0)
 <xsl:call-template name="ParamsList">
"KRN",.84,7981996.001,2,50,0)
  <xsl:with-param name="heading" select="'VA Drug Classes'"/>
"KRN",.84,7981996.001,2,51,0)
 </xsl:call-template>
"KRN",.84,7981996.001,2,52,0)
</xsl:template>
"KRN",.84,7981996.001,2,53,0)
 
"KRN",.84,7981996.001,2,54,0)
</xsl:stylesheet>
"KRN",.84,7981997.001,-1)
0^35
"KRN",.84,7981997.001,0)
7981997.001^2^^CLINICAL CASE REGISTRIES^Patient data templates (HTML)
"KRN",.84,7981997.001,2,0)
^^210^210^3031205^
"KRN",.84,7981997.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981997.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981997.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
"KRN",.84,7981997.001,2,4,0)
 
"KRN",.84,7981997.001,2,5,0)
<!--[ UTILITIES ]-->
"KRN",.84,7981997.001,2,6,0)
 
"KRN",.84,7981997.001,2,7,0)
<xsl:template name="BasicPatientHeader">
"KRN",.84,7981997.001,2,8,0)
 <xsl:param name="claids" select="1"/>
"KRN",.84,7981997.001,2,9,0)
 <xsl:param name="rowspan" select="1"/>
"KRN",.84,7981997.001,2,10,0)
 <xsl:param name="seqnum" select="1"/>
"KRN",.84,7981997.001,2,11,0)
 <xsl:param name="tblname" select="'PATIENTS'"/>
"KRN",.84,7981997.001,2,12,0)
 <xsl:if test="$seqnum">
"KRN",.84,7981997.001,2,13,0)
  <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.001,2,14,0)
   <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,15,0)
   <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981997.001,2,16,0)
   <xsl:with-param name="title" select="'#'"/>
"KRN",.84,7981997.001,2,17,0)
   <xsl:with-param name="width" select="'4%'"/>
"KRN",.84,7981997.001,2,18,0)
  </xsl:call-template>
"KRN",.84,7981997.001,2,19,0)
 </xsl:if>
"KRN",.84,7981997.001,2,20,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.001,2,21,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,22,0)
  <xsl:with-param name="sort" select="concat($tblname,'=NAME')"/>
"KRN",.84,7981997.001,2,23,0)
  <xsl:with-param name="title" select="'Patient Name'"/>
"KRN",.84,7981997.001,2,24,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,25,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.001,2,26,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,27,0)
  <xsl:with-param name="sort" select="concat($tblname,'=LAST4')"/>
"KRN",.84,7981997.001,2,28,0)
  <xsl:with-param name="title" select="'SSN'"/>
"KRN",.84,7981997.001,2,29,0)
  <xsl:with-param name="width" select="'7%'"/>
"KRN",.84,7981997.001,2,30,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,31,0)
 <xsl:if test="$claids">
"KRN",.84,7981997.001,2,32,0)
  <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.001,2,33,0)
   <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,34,0)
   <xsl:with-param name="sort" select="concat($tblname,'=AIDSTAT')"/>
"KRN",.84,7981997.001,2,35,0)
   <xsl:with-param name="title" select="'AIDS&#160;OI'"/>
"KRN",.84,7981997.001,2,36,0)
   <xsl:with-param name="width" select="'7%'"/>
"KRN",.84,7981997.001,2,37,0)
  </xsl:call-template>
"KRN",.84,7981997.001,2,38,0)
 </xsl:if>
"KRN",.84,7981997.001,2,39,0)
</xsl:template>
"KRN",.84,7981997.001,2,40,0)
 
"KRN",.84,7981997.001,2,41,0)
<xsl:template name="BasicPatientData">
"KRN",.84,7981997.001,2,42,0)
 <xsl:param name="claids" select="1"/>
"KRN",.84,7981997.001,2,43,0)
 <xsl:param name="rowspan" select="1"/>
"KRN",.84,7981997.001,2,44,0)
 <xsl:param name="seqnum" select="1"/>
"KRN",.84,7981997.001,2,45,0)
 <xsl:if test="$seqnum">
"KRN",.84,7981997.001,2,46,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981997.001,2,47,0)
   <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,48,0)
   <xsl:with-param name="value" select="position()"/>
"KRN",.84,7981997.001,2,49,0)
  </xsl:call-template>
"KRN",.84,7981997.001,2,50,0)
 </xsl:if>
"KRN",.84,7981997.001,2,51,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.001,2,52,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,53,0)
  <xsl:with-param name="value" select="NAME"/>
"KRN",.84,7981997.001,2,54,0)
  <xsl:with-param name="class" select="'aLeft'"/>
"KRN",.84,7981997.001,2,55,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,56,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.001,2,57,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,58,0)
  <xsl:with-param name="value" select="LAST4"/>
"KRN",.84,7981997.001,2,59,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,60,0)
 <xsl:if test="$claids">
"KRN",.84,7981997.001,2,61,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981997.001,2,62,0)
   <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,63,0)
   <xsl:with-param name="value" select="AIDSTAT"/>
"KRN",.84,7981997.001,2,64,0)
   <xsl:with-param name="yesno" select="1"/>
"KRN",.84,7981997.001,2,65,0)
  </xsl:call-template>
"KRN",.84,7981997.001,2,66,0)
 </xsl:if>
"KRN",.84,7981997.001,2,67,0)
</xsl:template>
"KRN",.84,7981997.001,2,68,0)
 
"KRN",.84,7981997.001,2,69,0)
<!--[ PATIENT TABLE HEADINGS ]-->
"KRN",.84,7981997.001,2,70,0)
 
"KRN",.84,7981997.001,2,71,0)
<xsl:template match="COLUMN[@NAME='ADMDT']">
"KRN",.84,7981997.001,2,72,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981997.001,2,73,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.001,2,74,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,75,0)
  <xsl:with-param name="title" select="'Admission Date'"/>
"KRN",.84,7981997.001,2,76,0)
  <xsl:with-param name="width" select="'7%'"/>
"KRN",.84,7981997.001,2,77,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,78,0)
</xsl:template>
"KRN",.84,7981997.001,2,79,0)
 
"KRN",.84,7981997.001,2,80,0)
<xsl:template match="COLUMN[@NAME='AGE']">
"KRN",.84,7981997.001,2,81,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981997.001,2,82,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.001,2,83,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,84,0)
  <xsl:with-param name="title" select="'Age'"/>                 
"KRN",.84,7981997.001,2,85,0)
  <xsl:with-param name="width" select="'5%'"/>
"KRN",.84,7981997.001,2,86,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,87,0)
</xsl:template>
"KRN",.84,7981997.001,2,88,0)
 
"KRN",.84,7981997.001,2,89,0)
<xsl:template match="COLUMN[@NAME='ALIVE']">
"KRN",.84,7981997.001,2,90,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981997.001,2,91,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.001,2,92,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,93,0)
  <xsl:with-param name="title" select="'Alive?'"/>                 
"KRN",.84,7981997.001,2,94,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,95,0)
</xsl:template>
"KRN",.84,7981997.001,2,96,0)
 
"KRN",.84,7981997.001,2,97,0)
<xsl:template match="COLUMN[@NAME='CSSN']">
"KRN",.84,7981997.001,2,98,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981997.001,2,99,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.001,2,100,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,101,0)
  <xsl:with-param name="title" select="'Coded SSN'"/>                      
"KRN",.84,7981997.001,2,102,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,103,0)
</xsl:template>
"KRN",.84,7981997.001,2,104,0)
 
"KRN",.84,7981997.001,2,105,0)
<xsl:template match="COLUMN[@NAME='DOB']">
"KRN",.84,7981997.001,2,106,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981997.001,2,107,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.001,2,108,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,109,0)
  <xsl:with-param name="title" select="'Date of Birth'"/>                  
"KRN",.84,7981997.001,2,110,0)
  <xsl:with-param name="width" select="'7%'"/>
"KRN",.84,7981997.001,2,111,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,112,0)
</xsl:template>
"KRN",.84,7981997.001,2,113,0)
 
"KRN",.84,7981997.001,2,114,0)
<xsl:template match="COLUMN[@NAME='ENTDT']">
"KRN",.84,7981997.001,2,115,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981997.001,2,116,0)
  <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.001,2,117,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,118,0)
   <xsl:with-param name="title" select="'Date Entered'"/>
"KRN",.84,7981997.001,2,119,0)
  <xsl:with-param name="sort" select="'PATIENTS=ENTDT:DESC'"/>                      
"KRN",.84,7981997.001,2,120,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,121,0)
</xsl:template>
"KRN",.84,7981997.001,2,122,0)
 
"KRN",.84,7981997.001,2,123,0)
<xsl:template match="COLUMN[@NAME='PRIMELIG']">
"KRN",.84,7981997.001,2,124,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981997.001,2,125,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.001,2,126,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,127,0)
  <xsl:with-param name="title" select="'Primary Eligibility'"/>
"KRN",.84,7981997.001,2,128,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,129,0)
</xsl:template>
"KRN",.84,7981997.001,2,130,0)
 
"KRN",.84,7981997.001,2,131,0)
<xsl:template match="COLUMN[@NAME='RACE']">
"KRN",.84,7981997.001,2,132,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981997.001,2,133,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.001,2,134,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,135,0)
  <xsl:with-param name="title" select="'Race'"/>
"KRN",.84,7981997.001,2,136,0)
  <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981997.001,2,137,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,138,0)
</xsl:template>
"KRN",.84,7981997.001,2,139,0)
 
"KRN",.84,7981997.001,2,140,0)
<xsl:template match="COLUMN[@NAME='SEX']">
"KRN",.84,7981997.001,2,141,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981997.001,2,142,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.001,2,143,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,144,0)
  <xsl:with-param name="title" select="'Sex'"/>                 
"KRN",.84,7981997.001,2,145,0)
  <xsl:with-param name="width" select="'5%'"/>
"KRN",.84,7981997.001,2,146,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,147,0)
</xsl:template>
"KRN",.84,7981997.001,2,148,0)
 
"KRN",.84,7981997.001,2,149,0)
<!--[ PATIENT TABLE CELLS ]-->
"KRN",.84,7981997.001,2,150,0)
 
"KRN",.84,7981997.001,2,151,0)
<xsl:template match="PATIENT/ADMDT">
"KRN",.84,7981997.001,2,152,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981997.001,2,153,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.001,2,154,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981997.001,2,155,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,156,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,157,0)
</xsl:template>
"KRN",.84,7981997.001,2,158,0)
 
"KRN",.84,7981997.001,2,159,0)
<xsl:template match="PATIENT/ALIVE">
"KRN",.84,7981997.001,2,160,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981997.001,2,161,0)
 <xsl:choose>
"KRN",.84,7981997.001,2,162,0)
  <xsl:when test=".!=''">
"KRN",.84,7981997.001,2,163,0)
   <xsl:call-template name="TableCell">
"KRN",.84,7981997.001,2,164,0)
    <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981997.001,2,165,0)
    <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,166,0)
   </xsl:call-template>
"KRN",.84,7981997.001,2,167,0)
  </xsl:when>
"KRN",.84,7981997.001,2,168,0)
  <xsl:otherwise>
"KRN",.84,7981997.001,2,169,0)
   <xsl:call-template name="TableCell">
"KRN",.84,7981997.001,2,170,0)
    <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,171,0)
    <xsl:with-param name="value" select="'Yes'"/>
"KRN",.84,7981997.001,2,172,0)
   </xsl:call-template>
"KRN",.84,7981997.001,2,173,0)
  </xsl:otherwise>
"KRN",.84,7981997.001,2,174,0)
 </xsl:choose>
"KRN",.84,7981997.001,2,175,0)
</xsl:template>
"KRN",.84,7981997.001,2,176,0)
 
"KRN",.84,7981997.001,2,177,0)
<xsl:template match="PATIENT/DOB">
"KRN",.84,7981997.001,2,178,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981997.001,2,179,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.001,2,180,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981997.001,2,181,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,182,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,183,0)
</xsl:template>
"KRN",.84,7981997.001,2,184,0)
 
"KRN",.84,7981997.001,2,185,0)
<xsl:template match="PATIENT/DOD">
"KRN",.84,7981997.001,2,186,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981997.001,2,187,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.001,2,188,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981997.001,2,189,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,190,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,191,0)
</xsl:template>
"KRN",.84,7981997.001,2,192,0)
 
"KRN",.84,7981997.001,2,193,0)
<xsl:template match="PATIENT/ENTDT">
"KRN",.84,7981997.001,2,194,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981997.001,2,195,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.001,2,196,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981997.001,2,197,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981997.001,2,198,0)
 </xsl:call-template>
"KRN",.84,7981997.001,2,199,0)
</xsl:template>
"KRN",.84,7981997.001,2,200,0)
 
"KRN",.84,7981997.001,2,201,0)
<xsl:template match="PATIENT/RACES">
"KRN",.84,7981997.001,2,202,0)
 <td class="aLeft">
"KRN",.84,7981997.001,2,203,0)
  <xsl:for-each select="RACE">
"KRN",.84,7981997.001,2,204,0)
   <xsl:value-of select="."/>
"KRN",.84,7981997.001,2,205,0)
   <xsl:if test=".=''"><xsl:text>&#160;</xsl:text></xsl:if><br/>
"KRN",.84,7981997.001,2,206,0)
  </xsl:for-each>
"KRN",.84,7981997.001,2,207,0)
 </td>
"KRN",.84,7981997.001,2,208,0)
</xsl:template>
"KRN",.84,7981997.001,2,209,0)
 
"KRN",.84,7981997.001,2,210,0)
</xsl:stylesheet>
"KRN",.84,7981997.002,-1)
0^55
"KRN",.84,7981997.002,0)
7981997.002^2^^CLINICAL CASE REGISTRIES^Patient data templates (CSV)
"KRN",.84,7981997.002,2,0)
^.844^184^184^3040202^^
"KRN",.84,7981997.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981997.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981997.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
"KRN",.84,7981997.002,2,4,0)
 
"KRN",.84,7981997.002,2,5,0)
<!--[ UTILITIES ]-->
"KRN",.84,7981997.002,2,6,0)
 
"KRN",.84,7981997.002,2,7,0)
<xsl:template name="BasicPatientData">
"KRN",.84,7981997.002,2,8,0)
 <xsl:param name="claids" select="1"/>
"KRN",.84,7981997.002,2,9,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.002,2,10,0)
  <xsl:with-param name="value" select="../NAME"/>
"KRN",.84,7981997.002,2,11,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,12,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.002,2,13,0)
  <xsl:with-param name="value" select="../LAST4"/>
"KRN",.84,7981997.002,2,14,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,15,0)
 <xsl:if test="$claids">
"KRN",.84,7981997.002,2,16,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981997.002,2,17,0)
   <xsl:with-param name="value" select="../AIDSTAT"/>
"KRN",.84,7981997.002,2,18,0)
   <xsl:with-param name="yesno" select="1"/>
"KRN",.84,7981997.002,2,19,0)
  </xsl:call-template>
"KRN",.84,7981997.002,2,20,0)
 </xsl:if>
"KRN",.84,7981997.002,2,21,0)
</xsl:template>
"KRN",.84,7981997.002,2,22,0)
 
"KRN",.84,7981997.002,2,23,0)
<!--[ PATIENT TABLE HEADINGS ]-->
"KRN",.84,7981997.002,2,24,0)
 
"KRN",.84,7981997.002,2,25,0)
<xsl:template match="COLUMN[@NAME='ADMDT']">
"KRN",.84,7981997.002,2,26,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.002,2,27,0)
  <xsl:with-param name="title" select="'Admission Date'"/>
"KRN",.84,7981997.002,2,28,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,29,0)
</xsl:template>
"KRN",.84,7981997.002,2,30,0)
 
"KRN",.84,7981997.002,2,31,0)
<xsl:template match="COLUMN[@NAME='AGE']">
"KRN",.84,7981997.002,2,32,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.002,2,33,0)
  <xsl:with-param name="title" select="'Age'"/>                 
"KRN",.84,7981997.002,2,34,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,35,0)
</xsl:template>
"KRN",.84,7981997.002,2,36,0)
 
"KRN",.84,7981997.002,2,37,0)
<xsl:template match="COLUMN[@NAME='ALIVE']">
"KRN",.84,7981997.002,2,38,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.002,2,39,0)
  <xsl:with-param name="title" select="'Alive?'"/>                 
"KRN",.84,7981997.002,2,40,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,41,0)
</xsl:template>
"KRN",.84,7981997.002,2,42,0)
 
"KRN",.84,7981997.002,2,43,0)
<xsl:template match="COLUMN[@NAME='CSSN']">
"KRN",.84,7981997.002,2,44,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.002,2,45,0)
  <xsl:with-param name="title" select="'Coded SSN'"/>                      
"KRN",.84,7981997.002,2,46,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,47,0)
</xsl:template>
"KRN",.84,7981997.002,2,48,0)
 
"KRN",.84,7981997.002,2,49,0)
<xsl:template match="COLUMN[@NAME='DOB']">
"KRN",.84,7981997.002,2,50,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.002,2,51,0)
  <xsl:with-param name="title" select="'Date of Birth'"/>                  
"KRN",.84,7981997.002,2,52,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,53,0)
</xsl:template>
"KRN",.84,7981997.002,2,54,0)
 
"KRN",.84,7981997.002,2,55,0)
<xsl:template match="COLUMN[@NAME='ENTDT']">
"KRN",.84,7981997.002,2,56,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.002,2,57,0)
  <xsl:with-param name="title" select="'Date Entered'"/>
"KRN",.84,7981997.002,2,58,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,59,0)
</xsl:template>
"KRN",.84,7981997.002,2,60,0)
 
"KRN",.84,7981997.002,2,61,0)
<xsl:template match="COLUMN[@NAME='INADT']">
"KRN",.84,7981997.002,2,62,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.002,2,63,0)
  <xsl:with-param name="title" select="'Inactivation Date'"/>
"KRN",.84,7981997.002,2,64,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,65,0)
</xsl:template>
"KRN",.84,7981997.002,2,66,0)
 
"KRN",.84,7981997.002,2,67,0)
<xsl:template match="COLUMN[@NAME='INARSN']">
"KRN",.84,7981997.002,2,68,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.002,2,69,0)
  <xsl:with-param name="title" select="'Inactivation Reason'"/>                 
"KRN",.84,7981997.002,2,70,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,71,0)
</xsl:template>
"KRN",.84,7981997.002,2,72,0)
 
"KRN",.84,7981997.002,2,73,0)
<xsl:template match="COLUMN[@NAME='PRIMELIG']">
"KRN",.84,7981997.002,2,74,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.002,2,75,0)
  <xsl:with-param name="title" select="'Primary Eligibility'"/>
"KRN",.84,7981997.002,2,76,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,77,0)
</xsl:template>
"KRN",.84,7981997.002,2,78,0)
 
"KRN",.84,7981997.002,2,79,0)
<xsl:template match="COLUMN[@NAME='RACE']">
"KRN",.84,7981997.002,2,80,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.002,2,81,0)
  <xsl:with-param name="title" select="'Race'"/>
"KRN",.84,7981997.002,2,82,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,83,0)
</xsl:template>
"KRN",.84,7981997.002,2,84,0)
 
"KRN",.84,7981997.002,2,85,0)
<xsl:template match="COLUMN[@NAME='READT']">
"KRN",.84,7981997.002,2,86,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.002,2,87,0)
  <xsl:with-param name="title" select="'Reactivation Date'"/>              
"KRN",.84,7981997.002,2,88,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,89,0)
</xsl:template>
"KRN",.84,7981997.002,2,90,0)
 
"KRN",.84,7981997.002,2,91,0)
<xsl:template match="COLUMN[@NAME='SELRULES']">
"KRN",.84,7981997.002,2,92,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.002,2,93,0)
  <xsl:with-param name="title" select="'Reasons'"/>
"KRN",.84,7981997.002,2,94,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,95,0)
</xsl:template>
"KRN",.84,7981997.002,2,96,0)
 
"KRN",.84,7981997.002,2,97,0)
<xsl:template match="COLUMN[@NAME='SEX']">
"KRN",.84,7981997.002,2,98,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981997.002,2,99,0)
  <xsl:with-param name="title" select="'Sex'"/>                 
"KRN",.84,7981997.002,2,100,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,101,0)
</xsl:template>
"KRN",.84,7981997.002,2,102,0)
 
"KRN",.84,7981997.002,2,103,0)
<!--[ PATIENT TABLE CELLS ]-->
"KRN",.84,7981997.002,2,104,0)
 
"KRN",.84,7981997.002,2,105,0)
<xsl:template match="PATIENT/ADMDT">
"KRN",.84,7981997.002,2,106,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.002,2,107,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981997.002,2,108,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,109,0)
</xsl:template>
"KRN",.84,7981997.002,2,110,0)
 
"KRN",.84,7981997.002,2,111,0)
<xsl:template match="PATIENT/ALIVE">
"KRN",.84,7981997.002,2,112,0)
 <xsl:choose>
"KRN",.84,7981997.002,2,113,0)
  <xsl:when test=".!=''">
"KRN",.84,7981997.002,2,114,0)
   <xsl:call-template name="TableCell">
"KRN",.84,7981997.002,2,115,0)
    <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981997.002,2,116,0)
   </xsl:call-template>
"KRN",.84,7981997.002,2,117,0)
  </xsl:when>
"KRN",.84,7981997.002,2,118,0)
  <xsl:otherwise>
"KRN",.84,7981997.002,2,119,0)
   <xsl:call-template name="TableCell">
"KRN",.84,7981997.002,2,120,0)
    <xsl:with-param name="value" select="'Yes'"/>
"KRN",.84,7981997.002,2,121,0)
   </xsl:call-template>
"KRN",.84,7981997.002,2,122,0)
  </xsl:otherwise>
"KRN",.84,7981997.002,2,123,0)
 </xsl:choose>
"KRN",.84,7981997.002,2,124,0)
</xsl:template>
"KRN",.84,7981997.002,2,125,0)
 
"KRN",.84,7981997.002,2,126,0)
<xsl:template match="PATIENT/DOB">
"KRN",.84,7981997.002,2,127,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.002,2,128,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981997.002,2,129,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,130,0)
</xsl:template>
"KRN",.84,7981997.002,2,131,0)
 
"KRN",.84,7981997.002,2,132,0)
<xsl:template match="PATIENT/DOD">
"KRN",.84,7981997.002,2,133,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.002,2,134,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981997.002,2,135,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,136,0)
</xsl:template>
"KRN",.84,7981997.002,2,137,0)
 
"KRN",.84,7981997.002,2,138,0)
<xsl:template match="PATIENT/ENTDT">
"KRN",.84,7981997.002,2,139,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.002,2,140,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981997.002,2,141,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,142,0)
</xsl:template>
"KRN",.84,7981997.002,2,143,0)
 
"KRN",.84,7981997.002,2,144,0)
<xsl:template match="PATIENT/INADT">
"KRN",.84,7981997.002,2,145,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.002,2,146,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981997.002,2,147,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,148,0)
</xsl:template>
"KRN",.84,7981997.002,2,149,0)
 
"KRN",.84,7981997.002,2,150,0)
<xsl:template match="PATIENT/READT">
"KRN",.84,7981997.002,2,151,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.002,2,152,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981997.002,2,153,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,154,0)
</xsl:template>
"KRN",.84,7981997.002,2,155,0)
 
"KRN",.84,7981997.002,2,156,0)
<xsl:template match="PATIENT/RACES">
"KRN",.84,7981997.002,2,157,0)
 <xsl:text>&quot;</xsl:text>
"KRN",.84,7981997.002,2,158,0)
 <xsl:for-each select="RACE">
"KRN",.84,7981997.002,2,159,0)
  <xsl:if test="position()>1"><xsl:text>; </xsl:text></xsl:if>
"KRN",.84,7981997.002,2,160,0)
  <xsl:call-template name="DoubleQuotes"/>
"KRN",.84,7981997.002,2,161,0)
 </xsl:for-each>
"KRN",.84,7981997.002,2,162,0)
 <xsl:text>&quot;</xsl:text>
"KRN",.84,7981997.002,2,163,0)
 <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981997.002,2,164,0)
</xsl:template>
"KRN",.84,7981997.002,2,165,0)
 
"KRN",.84,7981997.002,2,166,0)
<xsl:template match="PATIENT/SEEN">
"KRN",.84,7981997.002,2,167,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981997.002,2,168,0)
  <xsl:with-param name="yesno" select="1"/>
"KRN",.84,7981997.002,2,169,0)
 </xsl:call-template>
"KRN",.84,7981997.002,2,170,0)
</xsl:template>
"KRN",.84,7981997.002,2,171,0)
 
"KRN",.84,7981997.002,2,172,0)
<xsl:template match="PATIENT/SELRULES">
"KRN",.84,7981997.002,2,173,0)
 <xsl:text>&quot;</xsl:text>
"KRN",.84,7981997.002,2,174,0)
 <xsl:for-each select="RULE">
"KRN",.84,7981997.002,2,175,0)
  <xsl:if test="position()>1"><xsl:text>; </xsl:text></xsl:if>
"KRN",.84,7981997.002,2,176,0)
  <xsl:call-template name="DoubleQuotes">
"KRN",.84,7981997.002,2,177,0)
   <xsl:with-param name="value" select="@DESCR"/>
"KRN",.84,7981997.002,2,178,0)
  </xsl:call-template>
"KRN",.84,7981997.002,2,179,0)
 </xsl:for-each>
"KRN",.84,7981997.002,2,180,0)
 <xsl:text>&quot;</xsl:text>
"KRN",.84,7981997.002,2,181,0)
 <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981997.002,2,182,0)
</xsl:template>
"KRN",.84,7981997.002,2,183,0)
 
"KRN",.84,7981997.002,2,184,0)
</xsl:stylesheet>
"KRN",.84,7981998.001,-1)
0^28
"KRN",.84,7981998.001,0)
7981998.001^2^^CLINICAL CASE REGISTRIES^CSS and Scripts
"KRN",.84,7981998.001,2,0)
^^146^146^3031219^
"KRN",.84,7981998.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981998.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981998.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981998.001,2,4,0)
>
"KRN",.84,7981998.001,2,5,0)
 
"KRN",.84,7981998.001,2,6,0)
<xsl:template name="StyleSheet">
"KRN",.84,7981998.001,2,7,0)
 
"KRN",.84,7981998.001,2,8,0)
 <script type="text/javascript">
"KRN",.84,7981998.001,2,9,0)
  function windowHeight()
"KRN",.84,7981998.001,2,10,0)
  {
"KRN",.84,7981998.001,2,11,0)
   var wh = 600;
"KRN",.84,7981998.001,2,12,0)
   if (parseInt(navigator.appVersion)>3) {
"KRN",.84,7981998.001,2,13,0)
    if (navigator.appName=="Netscape") {
"KRN",.84,7981998.001,2,14,0)
     wh = window.innerHeight; 
"KRN",.84,7981998.001,2,15,0)
    } 
"KRN",.84,7981998.001,2,16,0)
    if (navigator.appName.indexOf("Microsoft")!=-1) {
"KRN",.84,7981998.001,2,17,0)
     wh = document.body.offsetHeight;
"KRN",.84,7981998.001,2,18,0)
    }
"KRN",.84,7981998.001,2,19,0)
   }
"KRN",.84,7981998.001,2,20,0)
   return wh;
"KRN",.84,7981998.001,2,21,0)
  }
"KRN",.84,7981998.001,2,22,0)
 </script>
"KRN",.84,7981998.001,2,23,0)
 
"KRN",.84,7981998.001,2,24,0)
 <style type="text/css">  /* Default Style Sheet */
"KRN",.84,7981998.001,2,25,0)
 
"KRN",.84,7981998.001,2,26,0)
  body  { text-align: center }
"KRN",.84,7981998.001,2,27,0)
  table { border: 1px solid gray }
"KRN",.84,7981998.001,2,28,0)
  th    { border: 1px solid gray }
"KRN",.84,7981998.001,2,29,0)
  thead { background-color: #E0E0E0 }
"KRN",.84,7981998.001,2,30,0)
  tfoot { background-color: #E0E0E0; font-size: 0px; }
"KRN",.84,7981998.001,2,31,0)
 
"KRN",.84,7981998.001,2,32,0)
  td {
"KRN",.84,7981998.001,2,33,0)
   border: 1px solid gray;
"KRN",.84,7981998.001,2,34,0)
   text-align: center;
"KRN",.84,7981998.001,2,35,0)
   vertical-align: middle;
"KRN",.84,7981998.001,2,36,0)
  }
"KRN",.84,7981998.001,2,37,0)
 
"KRN",.84,7981998.001,2,38,0)
  table caption     { text-align: left; font-weight: bold; } 
"KRN",.84,7981998.001,2,39,0)
  table td.aLeft    { text-align: left }
"KRN",.84,7981998.001,2,40,0)
  table td.aTopLeft { vertical-align: top; text-align: left }
"KRN",.84,7981998.001,2,41,0)
  table td.aTop     { vertical-align: top }
"KRN",.84,7981998.001,2,42,0)
 
"KRN",.84,7981998.001,2,43,0)
  div.reportHeader {
"KRN",.84,7981998.001,2,44,0)
   clear: both;
"KRN",.84,7981998.001,2,45,0)
   width: 100%;
"KRN",.84,7981998.001,2,46,0)
   margin-bottom: 1%;
"KRN",.84,7981998.001,2,47,0)
  }
"KRN",.84,7981998.001,2,48,0)
 
"KRN",.84,7981998.001,2,49,0)
  div.reportHeader table { border: 0 }
"KRN",.84,7981998.001,2,50,0)
  div.reportHeader th { width: 6em }
"KRN",.84,7981998.001,2,51,0)
 
"KRN",.84,7981998.001,2,52,0)
  div.reportHeader td, div.reportHeader th {
"KRN",.84,7981998.001,2,53,0)
   border: 0;
"KRN",.84,7981998.001,2,54,0)
   text-align: left;
"KRN",.84,7981998.001,2,55,0)
   vertical-align:text-top;
"KRN",.84,7981998.001,2,56,0)
  }
"KRN",.84,7981998.001,2,57,0)
 
"KRN",.84,7981998.001,2,58,0)
  div.simpleContainer {
"KRN",.84,7981998.001,2,59,0)
   width:  100%;
"KRN",.84,7981998.001,2,60,0)
   border-top:    1px solid gray;
"KRN",.84,7981998.001,2,61,0)
   border-bottom: 1px solid gray;
"KRN",.84,7981998.001,2,62,0)
   clear: both;
"KRN",.84,7981998.001,2,63,0)
   overflow: visible;
"KRN",.84,7981998.001,2,64,0)
  }
"KRN",.84,7981998.001,2,65,0)
 
"KRN",.84,7981998.001,2,66,0)
  div.scrollableContainer {
"KRN",.84,7981998.001,2,67,0)
   width:  100%;
"KRN",.84,7981998.001,2,68,0)
   height: expression(windowHeight()-200);
"KRN",.84,7981998.001,2,69,0)
   border-top:    1px solid gray;
"KRN",.84,7981998.001,2,70,0)
   border-bottom: 1px solid gray;
"KRN",.84,7981998.001,2,71,0)
   clear: both;
"KRN",.84,7981998.001,2,72,0)
   overflow: auto;
"KRN",.84,7981998.001,2,73,0)
 
"KRN",.84,7981998.001,2,74,0)
   /* Non-standard (IE 5.5+ only) */
"KRN",.84,7981998.001,2,75,0)
   scrollbar-3dlight-color:    #606060;
"KRN",.84,7981998.001,2,76,0)
   scrollbar-arrow-color:      #000000;
"KRN",.84,7981998.001,2,77,0)
   scrollbar-base-color:       #C0C0C0;
"KRN",.84,7981998.001,2,78,0)
   scrollbar-darkshadow-color: #C0C0C0;
"KRN",.84,7981998.001,2,79,0)
   scrollbar-face-color:       #C0C0C0;
"KRN",.84,7981998.001,2,80,0)
   scrollbar-highlight-color:  #C0C0C0;
"KRN",.84,7981998.001,2,81,0)
   scrollbar-shadow-color:     #606060;
"KRN",.84,7981998.001,2,82,0)
  }
"KRN",.84,7981998.001,2,83,0)
 
"KRN",.84,7981998.001,2,84,0)
  table.dataGrid {
"KRN",.84,7981998.001,2,85,0)
   width: 100%;
"KRN",.84,7981998.001,2,86,0)
   border-top:    0px;
"KRN",.84,7981998.001,2,87,0)
   border-bottom: 0px;
"KRN",.84,7981998.001,2,88,0)
  }
"KRN",.84,7981998.001,2,89,0)
 
"KRN",.84,7981998.001,2,90,0)
  /* Fixes the table header in place */
"KRN",.84,7981998.001,2,91,0)
  table.dataGrid thead th, table.dataGrid thead td {
"KRN",.84,7981998.001,2,92,0)
   position: relative;
"KRN",.84,7981998.001,2,93,0)
   top: expression(parentNode.parentNode.parentNode.parentNode.scrollTop);
"KRN",.84,7981998.001,2,94,0)
  }
"KRN",.84,7981998.001,2,95,0)
 
"KRN",.84,7981998.001,2,96,0)
  table.dataGrid td { vertical-align: top }
"KRN",.84,7981998.001,2,97,0)
  table.dataGrid tfoot td { border-top: 0 }
"KRN",.84,7981998.001,2,98,0)
 
"KRN",.84,7981998.001,2,99,0)
  div.reportSummary {
"KRN",.84,7981998.001,2,100,0)
   clear: both;
"KRN",.84,7981998.001,2,101,0)
   width: 100%;
"KRN",.84,7981998.001,2,102,0)
   page-break-before: always;
"KRN",.84,7981998.001,2,103,0)
  }
"KRN",.84,7981998.001,2,104,0)
 
"KRN",.84,7981998.001,2,105,0)
  div.reportSummary table {
"KRN",.84,7981998.001,2,106,0)
   margin-top: 1ex;
"KRN",.84,7981998.001,2,107,0)
   width: 100%;
"KRN",.84,7981998.001,2,108,0)
  }
"KRN",.84,7981998.001,2,109,0)
 
"KRN",.84,7981998.001,2,110,0)
  /*--- Mozilla (Netscape) specific ---*/
"KRN",.84,7981998.001,2,111,0)
 
"KRN",.84,7981998.001,2,112,0)
  /* Any tbody which is a child of table element */
"KRN",.84,7981998.001,2,113,0)
  table.dataGrid > tbody {
"KRN",.84,7981998.001,2,114,0)
   overflow: auto;
"KRN",.84,7981998.001,2,115,0)
   height: 70%;
"KRN",.84,7981998.001,2,116,0)
  }
"KRN",.84,7981998.001,2,117,0)
 
"KRN",.84,7981998.001,2,118,0)
  /* Prevent scrollbar from hiding cell content */
"KRN",.84,7981998.001,2,119,0)
  td:last-child { padding-right: 18px; }
"KRN",.84,7981998.001,2,120,0)
 
"KRN",.84,7981998.001,2,121,0)
 </style>
"KRN",.84,7981998.001,2,122,0)
 
"KRN",.84,7981998.001,2,123,0)
 <style type="text/css" media="print">  /* Print Style Sheet */
"KRN",.84,7981998.001,2,124,0)
 
"KRN",.84,7981998.001,2,125,0)
  div.scrollableContainer {
"KRN",.84,7981998.001,2,126,0)
   overflow: visible;
"KRN",.84,7981998.001,2,127,0)
   border: 0px;
"KRN",.84,7981998.001,2,128,0)
  }
"KRN",.84,7981998.001,2,129,0)
 
"KRN",.84,7981998.001,2,130,0)
  a { text-decoration: none; color: black }
"KRN",.84,7981998.001,2,131,0)
  table.dataGrid { border: solid gray 1px }
"KRN",.84,7981998.001,2,132,0)
  tfoot { display: table-footer-group }
"KRN",.84,7981998.001,2,133,0)
  thead { display: table-header-group }
"KRN",.84,7981998.001,2,134,0)
 
"KRN",.84,7981998.001,2,135,0)
  table.dataGrid thead th, table.dataGrid thead td {
"KRN",.84,7981998.001,2,136,0)
   position: static;
"KRN",.84,7981998.001,2,137,0)
  }
"KRN",.84,7981998.001,2,138,0)
 
"KRN",.84,7981998.001,2,139,0)
  /*--- Mozilla (Netscape) specific ---*/
"KRN",.84,7981998.001,2,140,0)
  table.dataGrid > tbody { overflow: visible }
"KRN",.84,7981998.001,2,141,0)
 
"KRN",.84,7981998.001,2,142,0)
 </style>
"KRN",.84,7981998.001,2,143,0)
 
"KRN",.84,7981998.001,2,144,0)
</xsl:template>
"KRN",.84,7981998.001,2,145,0)
 
"KRN",.84,7981998.001,2,146,0)
</xsl:stylesheet>
"KRN",.84,7981999.001,-1)
0^16
"KRN",.84,7981999.001,0)
7981999.001^2^^CLINICAL CASE REGISTRIES^Common XSL templates (HTML)
"KRN",.84,7981999.001,2,0)
^^611^611^3040112^
"KRN",.84,7981999.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981999.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981999.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
"KRN",.84,7981999.001,2,4,0)
 
"KRN",.84,7981999.001,2,5,0)
<xsl:param name="REMOVE_URLS"/>
"KRN",.84,7981999.001,2,6,0)
 
"KRN",.84,7981999.001,2,7,0)
<xsl:output method="html" indent="yes" encoding="iso-8859-1"/>
"KRN",.84,7981999.001,2,8,0)
<xsl:strip-space elements="*"/>
"KRN",.84,7981999.001,2,9,0)
 
"KRN",.84,7981999.001,2,10,0)
<xsl:template match="REPORT/HEADER//*"></xsl:template>
"KRN",.84,7981999.001,2,11,0)
<xsl:template match="REPORT/PARAMETERS//*"></xsl:template>
"KRN",.84,7981999.001,2,12,0)
 
"KRN",.84,7981999.001,2,13,0)
<xsl:key name="TableDefs" match="/REPORT/HEADER/TBLDEF" use="@NAME"/>
"KRN",.84,7981999.001,2,14,0)
 
"KRN",.84,7981999.001,2,15,0)
<!--
"KRN",.84,7981999.001,2,16,0)
=========================================================================
"KRN",.84,7981999.001,2,17,0)
                                UTILITIES
"KRN",.84,7981999.001,2,18,0)
=========================================================================
"KRN",.84,7981999.001,2,19,0)
-->
"KRN",.84,7981999.001,2,20,0)
 
"KRN",.84,7981999.001,2,21,0)
<!-- Formats the value of table cell -->
"KRN",.84,7981999.001,2,22,0)
 
"KRN",.84,7981999.001,2,23,0)
<xsl:template name="CellValue">
"KRN",.84,7981999.001,2,24,0)
 <xsl:param name="fmdt" select="0"/>
"KRN",.84,7981999.001,2,25,0)
 <xsl:param name="value" select="."/>
"KRN",.84,7981999.001,2,26,0)
 <xsl:param name="yesno" select="0"/>
"KRN",.84,7981999.001,2,27,0)
 <xsl:choose>
"KRN",.84,7981999.001,2,28,0)
  <xsl:when test="string($value)=''">&#160;</xsl:when>
"KRN",.84,7981999.001,2,29,0)
  <xsl:when test="boolean($fmdt)">
"KRN",.84,7981999.001,2,30,0)
   <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,31,0)
    <xsl:with-param name="dt" select="$value"/>
"KRN",.84,7981999.001,2,32,0)
   </xsl:call-template>
"KRN",.84,7981999.001,2,33,0)
  </xsl:when>
"KRN",.84,7981999.001,2,34,0)
  <xsl:when test="boolean($yesno)">
"KRN",.84,7981999.001,2,35,0)
   <xsl:choose>
"KRN",.84,7981999.001,2,36,0)
    <xsl:when test="$value!=0">Yes</xsl:when>
"KRN",.84,7981999.001,2,37,0)
    <xsl:otherwise>No</xsl:otherwise>
"KRN",.84,7981999.001,2,38,0)
   </xsl:choose>
"KRN",.84,7981999.001,2,39,0)
  </xsl:when>
"KRN",.84,7981999.001,2,40,0)
  <xsl:otherwise><xsl:value-of select="$value"/></xsl:otherwise>
"KRN",.84,7981999.001,2,41,0)
 </xsl:choose>
"KRN",.84,7981999.001,2,42,0)
</xsl:template>
"KRN",.84,7981999.001,2,43,0)
 
"KRN",.84,7981999.001,2,44,0)
<!-- Converts the FileMan date/time in printable format -->
"KRN",.84,7981999.001,2,45,0)
 
"KRN",.84,7981999.001,2,46,0)
<xsl:template name="DateTime">
"KRN",.84,7981999.001,2,47,0)
 <xsl:param name="dt" select="."/>
"KRN",.84,7981999.001,2,48,0)
 <!--
"KRN",.84,7981999.001,2,49,0)
     Date (YYYMMDD)
"KRN",.84,7981999.001,2,50,0)
 -->
"KRN",.84,7981999.001,2,51,0)
 <xsl:variable name="date"
"KRN",.84,7981999.001,2,52,0)
               select="substring-before(concat($dt,'.'),'.')"/>
"KRN",.84,7981999.001,2,53,0)
 <xsl:if test="$date!=''">
"KRN",.84,7981999.001,2,54,0)
  <xsl:choose>
"KRN",.84,7981999.001,2,55,0)
   <xsl:when test="string-length($date)=7">
"KRN",.84,7981999.001,2,56,0)
    <xsl:variable name="year"
"KRN",.84,7981999.001,2,57,0)
                  select="string(number(substring($date,1,3))+1700)"/>
"KRN",.84,7981999.001,2,58,0)
    <xsl:variable name="month" select="substring($date,4,2)"/>
"KRN",.84,7981999.001,2,59,0)
    <xsl:variable name="day" select="substring($date,6,2)"/>
"KRN",.84,7981999.001,2,60,0)
    <xsl:choose>
"KRN",.84,7981999.001,2,61,0)
     <xsl:when test="$day!='00'">
"KRN",.84,7981999.001,2,62,0)
      <xsl:value-of select="concat($month,'/',$day,'/',$year)"/>
"KRN",.84,7981999.001,2,63,0)
     </xsl:when>
"KRN",.84,7981999.001,2,64,0)
     <xsl:when test="$month!='00'">
"KRN",.84,7981999.001,2,65,0)
      <xsl:value-of select="concat($month,'/',$year)"/>
"KRN",.84,7981999.001,2,66,0)
     </xsl:when>
"KRN",.84,7981999.001,2,67,0)
     <xsl:otherwise><xsl:value-of select="$year"/></xsl:otherwise>
"KRN",.84,7981999.001,2,68,0)
    </xsl:choose>
"KRN",.84,7981999.001,2,69,0)
   </xsl:when>
"KRN",.84,7981999.001,2,70,0)
   <xsl:otherwise>{error}</xsl:otherwise>
"KRN",.84,7981999.001,2,71,0)
  </xsl:choose>
"KRN",.84,7981999.001,2,72,0)
  <!--
"KRN",.84,7981999.001,2,73,0)
      Time (HHMMSS)
"KRN",.84,7981999.001,2,74,0)
  -->
"KRN",.84,7981999.001,2,75,0)
  <xsl:variable name="time"
"KRN",.84,7981999.001,2,76,0)
                select="concat(substring-after($dt,'.'),'000000')"/>
"KRN",.84,7981999.001,2,77,0)
  <xsl:if test="number($time)>0">
"KRN",.84,7981999.001,2,78,0)
   <xsl:text>@</xsl:text>
"KRN",.84,7981999.001,2,79,0)
   <xsl:value-of select="substring($time,1,2)"/>
"KRN",.84,7981999.001,2,80,0)
   <xsl:text>:</xsl:text>
"KRN",.84,7981999.001,2,81,0)
   <xsl:value-of select="substring($time,3,2)"/>
"KRN",.84,7981999.001,2,82,0)
  </xsl:if>
"KRN",.84,7981999.001,2,83,0)
 </xsl:if>
"KRN",.84,7981999.001,2,84,0)
</xsl:template>
"KRN",.84,7981999.001,2,85,0)
 
"KRN",.84,7981999.001,2,86,0)
<xsl:template name="HUPatientsHeader">
"KRN",.84,7981999.001,2,87,0)
 <xsl:value-of select="/REPORT/PARAMETERS/MAXUTNUM"/>
"KRN",.84,7981999.001,2,88,0)
 <xsl:text> patient(s) with highest utilization</xsl:text>
"KRN",.84,7981999.001,2,89,0)
</xsl:template>
"KRN",.84,7981999.001,2,90,0)
 
"KRN",.84,7981999.001,2,91,0)
<!-- Conditional hyperlink -->
"KRN",.84,7981999.001,2,92,0)
 
"KRN",.84,7981999.001,2,93,0)
<xsl:template name="HyperLink">
"KRN",.84,7981999.001,2,94,0)
 <xsl:param name="href" select="''"/>
"KRN",.84,7981999.001,2,95,0)
 <xsl:param name="keep" select="0"/>
"KRN",.84,7981999.001,2,96,0)
 <xsl:param name="name" select="''"/>
"KRN",.84,7981999.001,2,97,0)
 <xsl:param name="text" select="."/>
"KRN",.84,7981999.001,2,98,0)
 <xsl:choose>
"KRN",.84,7981999.001,2,99,0)
  <xsl:when test="$text=''"><xsl:text>&#160;</xsl:text></xsl:when>
"KRN",.84,7981999.001,2,100,0)
  <xsl:when test="boolean($keep) or not($REMOVE_URLS)">
"KRN",.84,7981999.001,2,101,0)
   <a>
"KRN",.84,7981999.001,2,102,0)
    <xsl:if test="$name!=''">
"KRN",.84,7981999.001,2,103,0)
     <xsl:attribute name="name">
"KRN",.84,7981999.001,2,104,0)
      <xsl:value-of select="$name"/>
"KRN",.84,7981999.001,2,105,0)
     </xsl:attribute>
"KRN",.84,7981999.001,2,106,0)
    </xsl:if>
"KRN",.84,7981999.001,2,107,0)
    <xsl:if test="$href!=''">
"KRN",.84,7981999.001,2,108,0)
     <xsl:attribute name="href">
"KRN",.84,7981999.001,2,109,0)
      <xsl:value-of select="$href"/>
"KRN",.84,7981999.001,2,110,0)
     </xsl:attribute>
"KRN",.84,7981999.001,2,111,0)
    </xsl:if>
"KRN",.84,7981999.001,2,112,0)
    <xsl:value-of select="$text"/>
"KRN",.84,7981999.001,2,113,0)
   </a>
"KRN",.84,7981999.001,2,114,0)
  </xsl:when>
"KRN",.84,7981999.001,2,115,0)
  <xsl:otherwise><xsl:value-of select="$text"/></xsl:otherwise>
"KRN",.84,7981999.001,2,116,0)
 </xsl:choose>
"KRN",.84,7981999.001,2,117,0)
</xsl:template>
"KRN",.84,7981999.001,2,118,0)
 
"KRN",.84,7981999.001,2,119,0)
<!-- Makes the parent container scrollable -->
"KRN",.84,7981999.001,2,120,0)
 
"KRN",.84,7981999.001,2,121,0)
<xsl:template name="MakeScrollable">
"KRN",.84,7981999.001,2,122,0)
 <xsl:param name="condition" select="0"/>
"KRN",.84,7981999.001,2,123,0)
 <xsl:choose>
"KRN",.84,7981999.001,2,124,0)
  <xsl:when test="$condition">
"KRN",.84,7981999.001,2,125,0)
   <xsl:attribute name="class">scrollableContainer</xsl:attribute>
"KRN",.84,7981999.001,2,126,0)
  </xsl:when>
"KRN",.84,7981999.001,2,127,0)
  <xsl:otherwise>
"KRN",.84,7981999.001,2,128,0)
   <xsl:attribute name="class">simpleContainer</xsl:attribute>
"KRN",.84,7981999.001,2,129,0)
  </xsl:otherwise>
"KRN",.84,7981999.001,2,130,0)
 </xsl:choose>
"KRN",.84,7981999.001,2,131,0)
</xsl:template>
"KRN",.84,7981999.001,2,132,0)
 
"KRN",.84,7981999.001,2,133,0)
<!-- Outputs content of the multivalued report parameter -->
"KRN",.84,7981999.001,2,134,0)
 
"KRN",.84,7981999.001,2,135,0)
<xsl:template name="ParamsList">
"KRN",.84,7981999.001,2,136,0)
 <xsl:param name="heading"/>
"KRN",.84,7981999.001,2,137,0)
 <xsl:param name="list" select="."/>
"KRN",.84,7981999.001,2,138,0)
 <tr>
"KRN",.84,7981999.001,2,139,0)
  <th scope="row">
"KRN",.84,7981999.001,2,140,0)
   <xsl:value-of select="concat($heading,':&#160;')"/>
"KRN",.84,7981999.001,2,141,0)
  </th>
"KRN",.84,7981999.001,2,142,0)
  <td>
"KRN",.84,7981999.001,2,143,0)
   <xsl:if test="@DESCR">
"KRN",.84,7981999.001,2,144,0)
    <xsl:value-of select="$list/@DESCR"/><br/>
"KRN",.84,7981999.001,2,145,0)
   </xsl:if>
"KRN",.84,7981999.001,2,146,0)
   <xsl:if test="$list='ALL'">ALL</xsl:if>
"KRN",.84,7981999.001,2,147,0)
   <xsl:for-each select="$list/*">
"KRN",.84,7981999.001,2,148,0)
    <xsl:if test="position()>1"><xsl:text>; </xsl:text></xsl:if>
"KRN",.84,7981999.001,2,149,0)
    <xsl:value-of select="."/>
"KRN",.84,7981999.001,2,150,0)
   </xsl:for-each>
"KRN",.84,7981999.001,2,151,0)
  </td>
"KRN",.84,7981999.001,2,152,0)
 </tr>
"KRN",.84,7981999.001,2,153,0)
</xsl:template>
"KRN",.84,7981999.001,2,154,0)
 
"KRN",.84,7981999.001,2,155,0)
<!-- Outputs singular or plural form of the word -->
"KRN",.84,7981999.001,2,156,0)
 
"KRN",.84,7981999.001,2,157,0)
<xsl:template name="Plural">
"KRN",.84,7981999.001,2,158,0)
 <xsl:param name="qnty" select="0"/>
"KRN",.84,7981999.001,2,159,0)
 <xsl:param name="sq" select="0"/>
"KRN",.84,7981999.001,2,160,0)
 <xsl:param name="word" select="."/>
"KRN",.84,7981999.001,2,161,0)
 <xsl:if test="$sq=0">
"KRN",.84,7981999.001,2,162,0)
  <xsl:value-of select="$qnty"/><xsl:text>&#160;</xsl:text>
"KRN",.84,7981999.001,2,163,0)
 </xsl:if>
"KRN",.84,7981999.001,2,164,0)
 <xsl:choose>
"KRN",.84,7981999.001,2,165,0)
  <xsl:when test="$qnty=1">
"KRN",.84,7981999.001,2,166,0)
   <xsl:value-of select="substring-before($word,'^')"/>
"KRN",.84,7981999.001,2,167,0)
  </xsl:when>
"KRN",.84,7981999.001,2,168,0)
  <xsl:otherwise>
"KRN",.84,7981999.001,2,169,0)
   <xsl:value-of select="substring-after($word,'^')"/>
"KRN",.84,7981999.001,2,170,0)
  </xsl:otherwise>
"KRN",.84,7981999.001,2,171,0)
 </xsl:choose>
"KRN",.84,7981999.001,2,172,0)
</xsl:template>
"KRN",.84,7981999.001,2,173,0)
 
"KRN",.84,7981999.001,2,174,0)
<!-- Formats basic information about the report -->
"KRN",.84,7981999.001,2,175,0)
 
"KRN",.84,7981999.001,2,176,0)
<xsl:template name="ReportInfo">
"KRN",.84,7981999.001,2,177,0)
 <xsl:variable name="HDR" select="/REPORT/HEADER"/>
"KRN",.84,7981999.001,2,178,0)
 <table cellpadding="0" cellspacing="0">
"KRN",.84,7981999.001,2,179,0)
  <tr>
"KRN",.84,7981999.001,2,180,0)
   <th scope="row">Report&#160;Created:&#160;</th>
"KRN",.84,7981999.001,2,181,0)
   <td>
"KRN",.84,7981999.001,2,182,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,183,0)
     <xsl:with-param name="dt" select="$HDR/DATE"/>
"KRN",.84,7981999.001,2,184,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,185,0)
   </td>
"KRN",.84,7981999.001,2,186,0)
  </tr>
"KRN",.84,7981999.001,2,187,0)
  <tr>
"KRN",.84,7981999.001,2,188,0)
   <th scope="row">Task&#160;Number:&#160;</th>
"KRN",.84,7981999.001,2,189,0)
   <td>
"KRN",.84,7981999.001,2,190,0)
    <xsl:call-template name="CellValue">
"KRN",.84,7981999.001,2,191,0)
     <xsl:with-param name="value" select="$HDR/TASK_NUMBER"/>
"KRN",.84,7981999.001,2,192,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,193,0)
   </td>
"KRN",.84,7981999.001,2,194,0)
  </tr>
"KRN",.84,7981999.001,2,195,0)
  <tr>
"KRN",.84,7981999.001,2,196,0)
   <th scope="row">Last&#160;Registry&#160;Update:&#160;</th>
"KRN",.84,7981999.001,2,197,0)
   <td>
"KRN",.84,7981999.001,2,198,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,199,0)
     <xsl:with-param name="dt" select="$HDR/UPDATED_UNTIL"/>
"KRN",.84,7981999.001,2,200,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,201,0)
   </td>
"KRN",.84,7981999.001,2,202,0)
  </tr>
"KRN",.84,7981999.001,2,203,0)
  <tr>
"KRN",.84,7981999.001,2,204,0)
   <th scope="row">Last&#160;Data&#160;Extraction:&#160;</th>
"KRN",.84,7981999.001,2,205,0)
   <td>
"KRN",.84,7981999.001,2,206,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,207,0)
     <xsl:with-param name="dt" select="$HDR/EXTRACTED_UNTIL"/>
"KRN",.84,7981999.001,2,208,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,209,0)
   </td>
"KRN",.84,7981999.001,2,210,0)
  </tr>
"KRN",.84,7981999.001,2,211,0)
 </table>
"KRN",.84,7981999.001,2,212,0)
</xsl:template>
"KRN",.84,7981999.001,2,213,0)
 
"KRN",.84,7981999.001,2,214,0)
<!-- Default report summary -->
"KRN",.84,7981999.001,2,215,0)
 
"KRN",.84,7981999.001,2,216,0)
<xsl:template name="ReportSummary">
"KRN",.84,7981999.001,2,217,0)
 <xsl:variable name="SUMMARY" select="/REPORT/SUMMARY"/>
"KRN",.84,7981999.001,2,218,0)
 <xsl:if test="$SUMMARY/*[1]">
"KRN",.84,7981999.001,2,219,0)
  <div class="reportSummary">
"KRN",.84,7981999.001,2,220,0)
   <xsl:apply-templates select="$SUMMARY"/>
"KRN",.84,7981999.001,2,221,0)
  </div>
"KRN",.84,7981999.001,2,222,0)
 </xsl:if>
"KRN",.84,7981999.001,2,223,0)
</xsl:template>
"KRN",.84,7981999.001,2,224,0)
 
"KRN",.84,7981999.001,2,225,0)
<!-- Indicator of an empty table -->
"KRN",.84,7981999.001,2,226,0)
 
"KRN",.84,7981999.001,2,227,0)
<xsl:template name="TableNoData">
"KRN",.84,7981999.001,2,228,0)
 <table width="100%" cellpadding="5" cellspacing="0">
"KRN",.84,7981999.001,2,229,0)
   <tr><td>No data has been found.</td></tr>
"KRN",.84,7981999.001,2,230,0)
 </table>
"KRN",.84,7981999.001,2,231,0)
</xsl:template>
"KRN",.84,7981999.001,2,232,0)
 
"KRN",.84,7981999.001,2,233,0)
<!--
"KRN",.84,7981999.001,2,234,0)
=========================================================================
"KRN",.84,7981999.001,2,235,0)
                              REPORT HEADER
"KRN",.84,7981999.001,2,236,0)
=========================================================================
"KRN",.84,7981999.001,2,237,0)
-->
"KRN",.84,7981999.001,2,238,0)
 
"KRN",.84,7981999.001,2,239,0)
<xsl:template name="ReportHeader">
"KRN",.84,7981999.001,2,240,0)
 <xsl:variable name="mvplist" select="/REPORT/PARAMETERS/*[*[1]]"/>
"KRN",.84,7981999.001,2,241,0)
 <xsl:variable name="notecnt" select="count(/REPORT/HEADER/NOTES/*)"/>
"KRN",.84,7981999.001,2,242,0)
 <div class="reportHeader">
"KRN",.84,7981999.001,2,243,0)
  <table width="100%" cellpadding="0" cellspacing="0">
"KRN",.84,7981999.001,2,244,0)
   <tr>
"KRN",.84,7981999.001,2,245,0)
    <td style="text-align:left">
"KRN",.84,7981999.001,2,246,0)
     <table cellpadding="0" cellspacing="0">
"KRN",.84,7981999.001,2,247,0)
      <xsl:apply-templates select="/REPORT/PARAMETERS/*[not(*[1])]"/>
"KRN",.84,7981999.001,2,248,0)
     </table>
"KRN",.84,7981999.001,2,249,0)
    </td>
"KRN",.84,7981999.001,2,250,0)
    <td style="text-align:right; padding-left:3%; width:10%">
"KRN",.84,7981999.001,2,251,0)
     <xsl:call-template name="ReportInfo"/>
"KRN",.84,7981999.001,2,252,0)
    </td>
"KRN",.84,7981999.001,2,253,0)
   </tr>
"KRN",.84,7981999.001,2,254,0)
  </table>
"KRN",.84,7981999.001,2,255,0)
  <xsl:if test="$mvplist[1]">
"KRN",.84,7981999.001,2,256,0)
   <table style="width:100%; margin-top:1%" cellpadding="0" cellspacing="0">
"KRN",.84,7981999.001,2,257,0)
    <xsl:apply-templates select="$mvplist"/>
"KRN",.84,7981999.001,2,258,0)
   </table>
"KRN",.84,7981999.001,2,259,0)
  </xsl:if>
"KRN",.84,7981999.001,2,260,0)
  <xsl:if test="/REPORT//PATIENT[1]">
"KRN",.84,7981999.001,2,261,0)
   <div style="margin:10; color: red; font-weight: bold">
"KRN",.84,7981999.001,2,262,0)
    This report contains confidential patient information and must be
"KRN",.84,7981999.001,2,263,0)
    handled in accordance with established policies.
"KRN",.84,7981999.001,2,264,0)
   </div>
"KRN",.84,7981999.001,2,265,0)
  </xsl:if>
"KRN",.84,7981999.001,2,266,0)
  <xsl:if test="$notecnt>0">
"KRN",.84,7981999.001,2,267,0)
   <dl style="text-align:left">
"KRN",.84,7981999.001,2,268,0)
    <xsl:choose>
"KRN",.84,7981999.001,2,269,0)
     <xsl:when test="$notecnt>1">
"KRN",.84,7981999.001,2,270,0)
      <xsl:for-each select="/REPORT/HEADER/NOTES/*">
"KRN",.84,7981999.001,2,271,0)
       <dt>Note #<xsl:value-of select="position()"/>:</dt>
"KRN",.84,7981999.001,2,272,0)
       <dd><xsl:apply-templates select="."/></dd>
"KRN",.84,7981999.001,2,273,0)
      </xsl:for-each>
"KRN",.84,7981999.001,2,274,0)
     </xsl:when>
"KRN",.84,7981999.001,2,275,0)
     <xsl:otherwise>
"KRN",.84,7981999.001,2,276,0)
      <dt>Note:</dt>
"KRN",.84,7981999.001,2,277,0)
      <dd><xsl:apply-templates select="/REPORT/HEADER/NOTES/*"/></dd>
"KRN",.84,7981999.001,2,278,0)
     </xsl:otherwise>
"KRN",.84,7981999.001,2,279,0)
    </xsl:choose>
"KRN",.84,7981999.001,2,280,0)
   </dl>
"KRN",.84,7981999.001,2,281,0)
  </xsl:if>
"KRN",.84,7981999.001,2,282,0)
 </div>
"KRN",.84,7981999.001,2,283,0)
</xsl:template>
"KRN",.84,7981999.001,2,284,0)
 
"KRN",.84,7981999.001,2,285,0)
<xsl:template match="HEADER/NOTES/AGE">
"KRN",.84,7981999.001,2,286,0)
 Age of patients is calculated as of the date when the report is run
"KRN",.84,7981999.001,2,287,0)
 (<xsl:call-template name="DateTime"/>). If a patient died then the
"KRN",.84,7981999.001,2,288,0)
 age is calculated as of date of death.
"KRN",.84,7981999.001,2,289,0)
</xsl:template>
"KRN",.84,7981999.001,2,290,0)
 
"KRN",.84,7981999.001,2,291,0)
<xsl:template match="HEADER/NOTES/AGE_BASE_DATE">
"KRN",.84,7981999.001,2,292,0)
 Age of patients is calculated as of <xsl:call-template name="DateTime"/>,
"KRN",.84,7981999.001,2,293,0)
 which is the middle of the report date range. If a patient was born after
"KRN",.84,7981999.001,2,294,0)
 this date then the field will be empty. If a patient died before this
"KRN",.84,7981999.001,2,295,0)
 date then the age is calculated as of date of death.
"KRN",.84,7981999.001,2,296,0)
</xsl:template>
"KRN",.84,7981999.001,2,297,0)
 
"KRN",.84,7981999.001,2,298,0)
<xsl:template match="PARAMETERS/CLINICS">
"KRN",.84,7981999.001,2,299,0)
 <xsl:call-template name="ParamsList">
"KRN",.84,7981999.001,2,300,0)
  <xsl:with-param name="heading" select="'Clinics'"/>
"KRN",.84,7981999.001,2,301,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,302,0)
</xsl:template>
"KRN",.84,7981999.001,2,303,0)
 
"KRN",.84,7981999.001,2,304,0)
<xsl:template match="PARAMETERS/DATE_RANGE">
"KRN",.84,7981999.001,2,305,0)
 <xsl:if test="@START!=''">
"KRN",.84,7981999.001,2,306,0)
  <tr>
"KRN",.84,7981999.001,2,307,0)
   <th scope="row">Start&#160;Date:&#160;</th>
"KRN",.84,7981999.001,2,308,0)
   <td>
"KRN",.84,7981999.001,2,309,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,310,0)
     <xsl:with-param name="dt" select="@START"/>
"KRN",.84,7981999.001,2,311,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,312,0)
   </td>
"KRN",.84,7981999.001,2,313,0)
  </tr>
"KRN",.84,7981999.001,2,314,0)
 </xsl:if>
"KRN",.84,7981999.001,2,315,0)
 <xsl:if test="@END!=''">
"KRN",.84,7981999.001,2,316,0)
  <tr>
"KRN",.84,7981999.001,2,317,0)
   <th scope="row">End&#160;Date:&#160;</th>
"KRN",.84,7981999.001,2,318,0)
   <td>
"KRN",.84,7981999.001,2,319,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,320,0)
     <xsl:with-param name="dt" select="@END"/>
"KRN",.84,7981999.001,2,321,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,322,0)
   </td>
"KRN",.84,7981999.001,2,323,0)
  </tr>
"KRN",.84,7981999.001,2,324,0)
 </xsl:if>
"KRN",.84,7981999.001,2,325,0)
</xsl:template>
"KRN",.84,7981999.001,2,326,0)
 
"KRN",.84,7981999.001,2,327,0)
<xsl:template match="PARAMETERS/DIVISIONS">
"KRN",.84,7981999.001,2,328,0)
 <xsl:call-template name="ParamsList">
"KRN",.84,7981999.001,2,329,0)
  <xsl:with-param name="heading" select="'Divisions'"/>
"KRN",.84,7981999.001,2,330,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,331,0)
</xsl:template>
"KRN",.84,7981999.001,2,332,0)
 
"KRN",.84,7981999.001,2,333,0)
<xsl:template match="PARAMETERS/ICD9LST">
"KRN",.84,7981999.001,2,334,0)
 <xsl:call-template name="ParamsList">
"KRN",.84,7981999.001,2,335,0)
  <xsl:with-param name="heading" select="'ICD-9'"/>
"KRN",.84,7981999.001,2,336,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,337,0)
</xsl:template>
"KRN",.84,7981999.001,2,338,0)
 
"KRN",.84,7981999.001,2,339,0)
<xsl:template match="PARAMETERS/OPTIONS">
"KRN",.84,7981999.001,2,340,0)
 <tr>
"KRN",.84,7981999.001,2,341,0)
  <th scope="row">Options:&#160;</th>
"KRN",.84,7981999.001,2,342,0)
  <td><xsl:value-of select="."/></td>
"KRN",.84,7981999.001,2,343,0)
 </tr>
"KRN",.84,7981999.001,2,344,0)
</xsl:template>
"KRN",.84,7981999.001,2,345,0)
 
"KRN",.84,7981999.001,2,346,0)
<xsl:template match="PARAMETERS/PATIENTS">
"KRN",.84,7981999.001,2,347,0)
 <tr>
"KRN",.84,7981999.001,2,348,0)
  <th scope="row">Patients:&#160;</th>
"KRN",.84,7981999.001,2,349,0)
  <td><xsl:value-of select="."/></td>
"KRN",.84,7981999.001,2,350,0)
 </tr>
"KRN",.84,7981999.001,2,351,0)
</xsl:template>
"KRN",.84,7981999.001,2,352,0)
 
"KRN",.84,7981999.001,2,353,0)
<xsl:template match="PARAMETERS/REGNAME">
"KRN",.84,7981999.001,2,354,0)
 <tr>
"KRN",.84,7981999.001,2,355,0)
  <th scope="row">Registry:&#160;</th>
"KRN",.84,7981999.001,2,356,0)
  <td><xsl:value-of select="."/></td>
"KRN",.84,7981999.001,2,357,0)
 </tr>
"KRN",.84,7981999.001,2,358,0)
</xsl:template>
"KRN",.84,7981999.001,2,359,0)
 
"KRN",.84,7981999.001,2,360,0)
<!--
"KRN",.84,7981999.001,2,361,0)
=========================================================================
"KRN",.84,7981999.001,2,362,0)
                       DEFAULT DATA GRID TEMPLATES
"KRN",.84,7981999.001,2,363,0)
=========================================================================
"KRN",.84,7981999.001,2,364,0)
-->
"KRN",.84,7981999.001,2,365,0)
 
"KRN",.84,7981999.001,2,366,0)
<xsl:template name="DataGrid" match="*[@TABLE!='']">
"KRN",.84,7981999.001,2,367,0)
 <xsl:param name="divstyle" select="''"/>
"KRN",.84,7981999.001,2,368,0)
 <xsl:param name="scroll" select="*[31]"/>
"KRN",.84,7981999.001,2,369,0)
 <xsl:variable name="tbldef" select="key('TableDefs',@TABLE)"/>
"KRN",.84,7981999.001,2,370,0)
 <xsl:choose>
"KRN",.84,7981999.001,2,371,0)
  <xsl:when test="*[1]">
"KRN",.84,7981999.001,2,372,0)
   <div>
"KRN",.84,7981999.001,2,373,0)
    <xsl:if test="$divstyle!=''">
"KRN",.84,7981999.001,2,374,0)
     <xsl:attribute name="style">
"KRN",.84,7981999.001,2,375,0)
      <xsl:value-of select="$divstyle"/>
"KRN",.84,7981999.001,2,376,0)
     </xsl:attribute>
"KRN",.84,7981999.001,2,377,0)
    </xsl:if>
"KRN",.84,7981999.001,2,378,0)
    <xsl:call-template name="MakeScrollable">
"KRN",.84,7981999.001,2,379,0)
     <xsl:with-param name="condition" select="$scroll"/>
"KRN",.84,7981999.001,2,380,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,381,0)
    <table class="dataGrid" cellpadding="5" cellspacing="0">
"KRN",.84,7981999.001,2,382,0)
     <xsl:apply-templates select="$tbldef/@HEADER"/>
"KRN",.84,7981999.001,2,383,0)
     <xsl:apply-templates select="$tbldef/@FOOTER"/>
"KRN",.84,7981999.001,2,384,0)
     <tbody>
"KRN",.84,7981999.001,2,385,0)
      <xsl:apply-templates select="*">
"KRN",.84,7981999.001,2,386,0)
       <xsl:with-param name="seqnum"
"KRN",.84,7981999.001,2,387,0)
            select="count($tbldef/COLUMN[@NAME='#'])"/>
"KRN",.84,7981999.001,2,388,0)
      </xsl:apply-templates>
"KRN",.84,7981999.001,2,389,0)
     </tbody>
"KRN",.84,7981999.001,2,390,0)
    </table>
"KRN",.84,7981999.001,2,391,0)
   </div>
"KRN",.84,7981999.001,2,392,0)
  </xsl:when>
"KRN",.84,7981999.001,2,393,0)
  <xsl:otherwise>
"KRN",.84,7981999.001,2,394,0)
   <xsl:call-template name="TableNoData"/>
"KRN",.84,7981999.001,2,395,0)
  </xsl:otherwise>
"KRN",.84,7981999.001,2,396,0)
 </xsl:choose>
"KRN",.84,7981999.001,2,397,0)
</xsl:template>
"KRN",.84,7981999.001,2,398,0)
 
"KRN",.84,7981999.001,2,399,0)
<!-- Default data grid header -->
"KRN",.84,7981999.001,2,400,0)
 
"KRN",.84,7981999.001,2,401,0)
<xsl:template match="HEADER/TBLDEF/@HEADER">
"KRN",.84,7981999.001,2,402,0)
 <thead>
"KRN",.84,7981999.001,2,403,0)
  <tr><xsl:apply-templates select="../COLUMN"/></tr>
"KRN",.84,7981999.001,2,404,0)
 </thead>
"KRN",.84,7981999.001,2,405,0)
</xsl:template>
"KRN",.84,7981999.001,2,406,0)
 
"KRN",.84,7981999.001,2,407,0)
<!-- Default column heading cell -->
"KRN",.84,7981999.001,2,408,0)
 
"KRN",.84,7981999.001,2,409,0)
<xsl:template name="ColumnHeader" match="HEADER/TBLDEF/COLUMN">
"KRN",.84,7981999.001,2,410,0)
 <xsl:param name="column" select="."/>
"KRN",.84,7981999.001,2,411,0)
 <xsl:param name="colname" select="$column/@NAME"/>
"KRN",.84,7981999.001,2,412,0)
 <xsl:param name="sortmode"/>
"KRN",.84,7981999.001,2,413,0)
 <xsl:param name="sort" 
"KRN",.84,7981999.001,2,414,0)
      select="concat($column/../@NAME,'=',$colname,$sortmode)"/>
"KRN",.84,7981999.001,2,415,0)
 <xsl:param name="title" select="$colname"/>
"KRN",.84,7981999.001,2,416,0)
 <xsl:param name="colspan" select="0"/>
"KRN",.84,7981999.001,2,417,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,418,0)
 <xsl:param name="style"/>
"KRN",.84,7981999.001,2,419,0)
 <xsl:param name="width"/>
"KRN",.84,7981999.001,2,420,0)
 <th scope="col">
"KRN",.84,7981999.001,2,421,0)
  <xsl:if test="$colspan>1">
"KRN",.84,7981999.001,2,422,0)
   <xsl:attribute name="colspan">
"KRN",.84,7981999.001,2,423,0)
    <xsl:value-of select="$colspan"/>
"KRN",.84,7981999.001,2,424,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,425,0)
  </xsl:if>
"KRN",.84,7981999.001,2,426,0)
  <xsl:if test="$rowspan>1">
"KRN",.84,7981999.001,2,427,0)
   <xsl:attribute name="rowspan">
"KRN",.84,7981999.001,2,428,0)
    <xsl:value-of select="$rowspan"/>
"KRN",.84,7981999.001,2,429,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,430,0)
  </xsl:if>
"KRN",.84,7981999.001,2,431,0)
  <xsl:if test="string($style)!=''">
"KRN",.84,7981999.001,2,432,0)
   <xsl:attribute name="style">
"KRN",.84,7981999.001,2,433,0)
    <xsl:value-of select="$style"/>
"KRN",.84,7981999.001,2,434,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,435,0)
  </xsl:if>
"KRN",.84,7981999.001,2,436,0)
  <xsl:if test="string($width)!=''">
"KRN",.84,7981999.001,2,437,0)
   <xsl:attribute name="width">
"KRN",.84,7981999.001,2,438,0)
    <xsl:value-of select="$width"/>
"KRN",.84,7981999.001,2,439,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,440,0)
  </xsl:if>
"KRN",.84,7981999.001,2,441,0)
  <xsl:choose>
"KRN",.84,7981999.001,2,442,0)
   <xsl:when test="$title=''">&#160;</xsl:when>
"KRN",.84,7981999.001,2,443,0)
   <xsl:when test="($sort!='') and not($REMOVE_URLS)">
"KRN",.84,7981999.001,2,444,0)
    <xsl:element name="a">
"KRN",.84,7981999.001,2,445,0)
     <xsl:attribute name="href">
"KRN",.84,7981999.001,2,446,0)
      <xsl:text>http://vista/report/sort?</xsl:text>
"KRN",.84,7981999.001,2,447,0)
      <xsl:value-of select="$sort"/>
"KRN",.84,7981999.001,2,448,0)
     </xsl:attribute>
"KRN",.84,7981999.001,2,449,0)
     <xsl:value-of select="$title"/>
"KRN",.84,7981999.001,2,450,0)
    </xsl:element>
"KRN",.84,7981999.001,2,451,0)
   </xsl:when>
"KRN",.84,7981999.001,2,452,0)
   <xsl:otherwise><xsl:value-of select="$title"/></xsl:otherwise>
"KRN",.84,7981999.001,2,453,0)
  </xsl:choose>
"KRN",.84,7981999.001,2,454,0)
 </th>
"KRN",.84,7981999.001,2,455,0)
</xsl:template>
"KRN",.84,7981999.001,2,456,0)
 
"KRN",.84,7981999.001,2,457,0)
<!-- Default Footer -->
"KRN",.84,7981999.001,2,458,0)
 
"KRN",.84,7981999.001,2,459,0)
<xsl:template name="DataGridFooter" match="TBLDEF/@FOOTER">
"KRN",.84,7981999.001,2,460,0)
 <xsl:param name="colspan"
"KRN",.84,7981999.001,2,461,0)
      select="count(..//COLUMN[not(child::COLUMN[1])])"/>
"KRN",.84,7981999.001,2,462,0)
 <tfoot><tr><td>
"KRN",.84,7981999.001,2,463,0)
  <xsl:if test="$colspan>1">
"KRN",.84,7981999.001,2,464,0)
   <xsl:attribute name="colspan">
"KRN",.84,7981999.001,2,465,0)
    <xsl:value-of select="$colspan"/>
"KRN",.84,7981999.001,2,466,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,467,0)
  </xsl:if>
"KRN",.84,7981999.001,2,468,0)
  <xsl:text>&#160;</xsl:text>
"KRN",.84,7981999.001,2,469,0)
 </td></tr></tfoot>
"KRN",.84,7981999.001,2,470,0)
</xsl:template>
"KRN",.84,7981999.001,2,471,0)
 
"KRN",.84,7981999.001,2,472,0)
<!-- Default data grid row -->
"KRN",.84,7981999.001,2,473,0)
 
"KRN",.84,7981999.001,2,474,0)
<xsl:template match="*[@TABLE!='']/*">
"KRN",.84,7981999.001,2,475,0)
 <xsl:param name="seqnum" select="0"/>
"KRN",.84,7981999.001,2,476,0)
 <tr>
"KRN",.84,7981999.001,2,477,0)
  <xsl:if test="$seqnum">
"KRN",.84,7981999.001,2,478,0)
   <td><xsl:value-of select="position()"/></td>
"KRN",.84,7981999.001,2,479,0)
  </xsl:if>
"KRN",.84,7981999.001,2,480,0)
  <xsl:apply-templates select="child::*"/>
"KRN",.84,7981999.001,2,481,0)
 </tr>
"KRN",.84,7981999.001,2,482,0)
</xsl:template>
"KRN",.84,7981999.001,2,483,0)
 
"KRN",.84,7981999.001,2,484,0)
<!-- Data grid cell -->
"KRN",.84,7981999.001,2,485,0)
 
"KRN",.84,7981999.001,2,486,0)
<xsl:template name="TableCell" match="*[@TABLE!='']/*/*">
"KRN",.84,7981999.001,2,487,0)
 <xsl:param name="class"/>
"KRN",.84,7981999.001,2,488,0)
 <xsl:param name="colspan" select="0"/>
"KRN",.84,7981999.001,2,489,0)
 <xsl:param name="fmdt" select="0"/>
"KRN",.84,7981999.001,2,490,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,491,0)
 <xsl:param name="style"/>
"KRN",.84,7981999.001,2,492,0)
 <xsl:param name="value" select="."/>
"KRN",.84,7981999.001,2,493,0)
 <xsl:param name="width"/>
"KRN",.84,7981999.001,2,494,0)
 <xsl:param name="yesno" select="0"/>
"KRN",.84,7981999.001,2,495,0)
 <td>
"KRN",.84,7981999.001,2,496,0)
  <xsl:if test="string($class)!=''">
"KRN",.84,7981999.001,2,497,0)
   <xsl:attribute name="class">
"KRN",.84,7981999.001,2,498,0)
    <xsl:value-of select="$class"/>
"KRN",.84,7981999.001,2,499,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,500,0)
  </xsl:if>
"KRN",.84,7981999.001,2,501,0)
  <xsl:if test="$colspan>1">
"KRN",.84,7981999.001,2,502,0)
   <xsl:attribute name="colspan">
"KRN",.84,7981999.001,2,503,0)
    <xsl:value-of select="$colspan"/>
"KRN",.84,7981999.001,2,504,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,505,0)
  </xsl:if>
"KRN",.84,7981999.001,2,506,0)
  <xsl:if test="$rowspan>1">
"KRN",.84,7981999.001,2,507,0)
   <xsl:attribute name="rowspan">
"KRN",.84,7981999.001,2,508,0)
    <xsl:value-of select="$rowspan"/>
"KRN",.84,7981999.001,2,509,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,510,0)
  </xsl:if>
"KRN",.84,7981999.001,2,511,0)
  <xsl:if test="string($style)!=''">
"KRN",.84,7981999.001,2,512,0)
   <xsl:attribute name="style">
"KRN",.84,7981999.001,2,513,0)
    <xsl:value-of select="$style"/>
"KRN",.84,7981999.001,2,514,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,515,0)
  </xsl:if>
"KRN",.84,7981999.001,2,516,0)
  <xsl:if test="string($width)!=''">
"KRN",.84,7981999.001,2,517,0)
   <xsl:attribute name="width">
"KRN",.84,7981999.001,2,518,0)
    <xsl:value-of select="$width"/>
"KRN",.84,7981999.001,2,519,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,520,0)
  </xsl:if>
"KRN",.84,7981999.001,2,521,0)
  <xsl:choose>
"KRN",.84,7981999.001,2,522,0)
   <xsl:when test="string($value)=''">&#160;</xsl:when>
"KRN",.84,7981999.001,2,523,0)
   <xsl:when test="boolean($fmdt)">
"KRN",.84,7981999.001,2,524,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,525,0)
     <xsl:with-param name="dt" select="$value"/>
"KRN",.84,7981999.001,2,526,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,527,0)
   </xsl:when>
"KRN",.84,7981999.001,2,528,0)
   <xsl:when test="boolean($yesno)">
"KRN",.84,7981999.001,2,529,0)
    <xsl:choose>
"KRN",.84,7981999.001,2,530,0)
     <xsl:when test="$value!=0">Yes</xsl:when>
"KRN",.84,7981999.001,2,531,0)
     <xsl:otherwise>No</xsl:otherwise>
"KRN",.84,7981999.001,2,532,0)
    </xsl:choose>
"KRN",.84,7981999.001,2,533,0)
   </xsl:when>
"KRN",.84,7981999.001,2,534,0)
   <xsl:otherwise><xsl:value-of select="$value"/></xsl:otherwise>
"KRN",.84,7981999.001,2,535,0)
  </xsl:choose>
"KRN",.84,7981999.001,2,536,0)
 </td>
"KRN",.84,7981999.001,2,537,0)
</xsl:template>
"KRN",.84,7981999.001,2,538,0)
 
"KRN",.84,7981999.001,2,539,0)
<!-- Default column headingds -->
"KRN",.84,7981999.001,2,540,0)
 
"KRN",.84,7981999.001,2,541,0)
<xsl:template match="TBLDEF/COLUMN[@NAME='#']">
"KRN",.84,7981999.001,2,542,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,543,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.001,2,544,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,545,0)
  <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981999.001,2,546,0)
  <xsl:with-param name="width" select="'4%'"/>
"KRN",.84,7981999.001,2,547,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,548,0)
</xsl:template>
"KRN",.84,7981999.001,2,549,0)
 
"KRN",.84,7981999.001,2,550,0)
<xsl:template match="COLUMN[@NAME='AIDSTAT']">
"KRN",.84,7981999.001,2,551,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,552,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.001,2,553,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,554,0)
  <xsl:with-param name="title" select="'AIDS&#160;OI'"/>
"KRN",.84,7981999.001,2,555,0)
  <xsl:with-param name="width" select="'7%'"/>
"KRN",.84,7981999.001,2,556,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,557,0)
</xsl:template>
"KRN",.84,7981999.001,2,558,0)
 
"KRN",.84,7981999.001,2,559,0)
<xsl:template match="COLUMN[@NAME='DATE']">                                    
"KRN",.84,7981999.001,2,560,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,561,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.001,2,562,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,563,0)
  <xsl:with-param name="title" select="'Date'"/>                               
"KRN",.84,7981999.001,2,564,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981999.001,2,565,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,566,0)
</xsl:template>
"KRN",.84,7981999.001,2,567,0)
 
"KRN",.84,7981999.001,2,568,0)
<xsl:template match="COLUMN[@NAME='LAST4']">
"KRN",.84,7981999.001,2,569,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,570,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.001,2,571,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,572,0)
  <xsl:with-param name="title" select="'SSN'"/>
"KRN",.84,7981999.001,2,573,0)
  <xsl:with-param name="width" select="'7%'"/>
"KRN",.84,7981999.001,2,574,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,575,0)
</xsl:template>
"KRN",.84,7981999.001,2,576,0)
 
"KRN",.84,7981999.001,2,577,0)
<xsl:template match="COLUMN[@NAME='NAME']">
"KRN",.84,7981999.001,2,578,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,579,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.001,2,580,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,581,0)
  <xsl:with-param name="title" select="'Name'"/>
"KRN",.84,7981999.001,2,582,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,583,0)
</xsl:template>
"KRN",.84,7981999.001,2,584,0)
 
"KRN",.84,7981999.001,2,585,0)
<xsl:template match="TBLDEF[@NAME='PATIENTS']/COLUMN[@NAME='NAME']">
"KRN",.84,7981999.001,2,586,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,587,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.001,2,588,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,589,0)
  <xsl:with-param name="title" select="'Patient Name'"/>
"KRN",.84,7981999.001,2,590,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,591,0)
</xsl:template>
"KRN",.84,7981999.001,2,592,0)
 
"KRN",.84,7981999.001,2,593,0)
<!-- Default cells -->
"KRN",.84,7981999.001,2,594,0)
 
"KRN",.84,7981999.001,2,595,0)
<xsl:template match="*[@TABLE!='']/*/NAME">
"KRN",.84,7981999.001,2,596,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,597,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981999.001,2,598,0)
  <xsl:with-param name="class" select="'aLeft'"/>
"KRN",.84,7981999.001,2,599,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,600,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,601,0)
</xsl:template>
"KRN",.84,7981999.001,2,602,0)
 
"KRN",.84,7981999.001,2,603,0)
<xsl:template match="PATIENT/AIDSTAT">
"KRN",.84,7981999.001,2,604,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,605,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981999.001,2,606,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,607,0)
  <xsl:with-param name="yesno" select="1"/>
"KRN",.84,7981999.001,2,608,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,609,0)
</xsl:template>
"KRN",.84,7981999.001,2,610,0)
 
"KRN",.84,7981999.001,2,611,0)
</xsl:stylesheet>
"KRN",.84,7981999.001,3,0)
^.845
"KRN",.84,7981999.002,-1)
0^17
"KRN",.84,7981999.002,0)
7981999.002^2^^CLINICAL CASE REGISTRIES^Common XSL templates (CSV)
"KRN",.84,7981999.002,2,0)
^^300^300^3031212^
"KRN",.84,7981999.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981999.002,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981999.002,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
"KRN",.84,7981999.002,2,4,0)
>
"KRN",.84,7981999.002,2,5,0)
 
"KRN",.84,7981999.002,2,6,0)
<xsl:output method="text" encoding="iso-8859-1"/>
"KRN",.84,7981999.002,2,7,0)
<xsl:strip-space elements="*"/>
"KRN",.84,7981999.002,2,8,0)
 
"KRN",.84,7981999.002,2,9,0)
<xsl:variable name="CRLF"><xsl:text>&#13;&#10;</xsl:text></xsl:variable>
"KRN",.84,7981999.002,2,10,0)
<xsl:variable name="DELIMITER"><xsl:text>,</xsl:text></xsl:variable>
"KRN",.84,7981999.002,2,11,0)
<xsl:variable name="FILESWITCH"><xsl:text>&#127;</xsl:text></xsl:variable>
"KRN",.84,7981999.002,2,12,0)
 
"KRN",.84,7981999.002,2,13,0)
<xsl:key name="TableDefs" match="/REPORT/HEADER/TBLDEF" use="@NAME"/>
"KRN",.84,7981999.002,2,14,0)
 
"KRN",.84,7981999.002,2,15,0)
<xsl:template match="REPORT/HEADER//*"></xsl:template>
"KRN",.84,7981999.002,2,16,0)
<xsl:template match="REPORT/PARAMETERS//*"></xsl:template>
"KRN",.84,7981999.002,2,17,0)
 
"KRN",.84,7981999.002,2,18,0)
<!--
"KRN",.84,7981999.002,2,19,0)
=========================================================================
"KRN",.84,7981999.002,2,20,0)
                                UTILITIES
"KRN",.84,7981999.002,2,21,0)
=========================================================================
"KRN",.84,7981999.002,2,22,0)
-->
"KRN",.84,7981999.002,2,23,0)
 
"KRN",.84,7981999.002,2,24,0)
<!-- Converts the FileMan date/time in printable format -->
"KRN",.84,7981999.002,2,25,0)
 
"KRN",.84,7981999.002,2,26,0)
<xsl:template name="DateTime">
"KRN",.84,7981999.002,2,27,0)
 <xsl:param name="dt"/>
"KRN",.84,7981999.002,2,28,0)
 <!--
"KRN",.84,7981999.002,2,29,0)
     Date (YYYMMDD)
"KRN",.84,7981999.002,2,30,0)
 -->
"KRN",.84,7981999.002,2,31,0)
 <xsl:variable name="date"
"KRN",.84,7981999.002,2,32,0)
               select="substring-before(concat($dt,'.'),'.')"/>
"KRN",.84,7981999.002,2,33,0)
 <xsl:if test="$date!=''">
"KRN",.84,7981999.002,2,34,0)
  <xsl:choose>
"KRN",.84,7981999.002,2,35,0)
   <xsl:when test="string-length($date)=7">
"KRN",.84,7981999.002,2,36,0)
    <xsl:variable name="year" 
"KRN",.84,7981999.002,2,37,0)
                  select="string(number(substring($date,1,3))+1700)"/>
"KRN",.84,7981999.002,2,38,0)
    <xsl:variable name="month" select="substring($date,4,2)"/>
"KRN",.84,7981999.002,2,39,0)
    <xsl:variable name="day" select="substring($date,6,2)"/>
"KRN",.84,7981999.002,2,40,0)
    <xsl:choose>
"KRN",.84,7981999.002,2,41,0)
     <xsl:when test="$day!='00'">
"KRN",.84,7981999.002,2,42,0)
      <xsl:value-of select="concat($month,'/',$day,'/',$year)"/>
"KRN",.84,7981999.002,2,43,0)
     </xsl:when>
"KRN",.84,7981999.002,2,44,0)
     <xsl:when test="$month!='00'">
"KRN",.84,7981999.002,2,45,0)
      <xsl:value-of select="concat($month,'/',$year)"/>
"KRN",.84,7981999.002,2,46,0)
     </xsl:when>
"KRN",.84,7981999.002,2,47,0)
     <xsl:otherwise><xsl:value-of select="$year"/></xsl:otherwise>
"KRN",.84,7981999.002,2,48,0)
    </xsl:choose>
"KRN",.84,7981999.002,2,49,0)
   </xsl:when>
"KRN",.84,7981999.002,2,50,0)
   <xsl:otherwise>{error}</xsl:otherwise>
"KRN",.84,7981999.002,2,51,0)
  </xsl:choose>
"KRN",.84,7981999.002,2,52,0)
  <!--
"KRN",.84,7981999.002,2,53,0)
      Time (HHMMSS)
"KRN",.84,7981999.002,2,54,0)
  -->
"KRN",.84,7981999.002,2,55,0)
  <xsl:variable name="time"
"KRN",.84,7981999.002,2,56,0)
                select="concat(substring-after($dt,'.'),'000000')"/>
"KRN",.84,7981999.002,2,57,0)
  <xsl:if test="number($time)>0">
"KRN",.84,7981999.002,2,58,0)
   <xsl:text> </xsl:text>
"KRN",.84,7981999.002,2,59,0)
   <xsl:value-of select="substring($time,1,2)"/>
"KRN",.84,7981999.002,2,60,0)
   <xsl:text>:</xsl:text>
"KRN",.84,7981999.002,2,61,0)
   <xsl:value-of select="substring($time,3,2)"/>
"KRN",.84,7981999.002,2,62,0)
  </xsl:if>
"KRN",.84,7981999.002,2,63,0)
 </xsl:if>
"KRN",.84,7981999.002,2,64,0)
</xsl:template>
"KRN",.84,7981999.002,2,65,0)
 
"KRN",.84,7981999.002,2,66,0)
<!-- Doubles the double quotes in the provided string -->
"KRN",.84,7981999.002,2,67,0)
 
"KRN",.84,7981999.002,2,68,0)
<xsl:template name="DoubleQuotes">
"KRN",.84,7981999.002,2,69,0)
 <xsl:param name="value" select="."/>
"KRN",.84,7981999.002,2,70,0)
 <xsl:choose>
"KRN",.84,7981999.002,2,71,0)
  <xsl:when test="contains($value,'&quot;')">
"KRN",.84,7981999.002,2,72,0)
   <xsl:value-of select="substring-before($value,'&quot;')"/>
"KRN",.84,7981999.002,2,73,0)
   <xsl:text>&quot;&quot;</xsl:text>
"KRN",.84,7981999.002,2,74,0)
   <xsl:call-template name="DoubleQuotes">
"KRN",.84,7981999.002,2,75,0)
    <xsl:with-param name="value" 
"KRN",.84,7981999.002,2,76,0)
                    select="substring-after($value,'&quot;')"/>
"KRN",.84,7981999.002,2,77,0)
   </xsl:call-template>
"KRN",.84,7981999.002,2,78,0)
  </xsl:when>
"KRN",.84,7981999.002,2,79,0)
  <xsl:otherwise><xsl:value-of select="$value"/></xsl:otherwise>
"KRN",.84,7981999.002,2,80,0)
 </xsl:choose>
"KRN",.84,7981999.002,2,81,0)
</xsl:template>
"KRN",.84,7981999.002,2,82,0)
 
"KRN",.84,7981999.002,2,83,0)
<!-- Quotes the string if it contains commas or double quotes -->
"KRN",.84,7981999.002,2,84,0)
 
"KRN",.84,7981999.002,2,85,0)
<xsl:template name="Quote">
"KRN",.84,7981999.002,2,86,0)
 <xsl:param name="value" select="."/>
"KRN",.84,7981999.002,2,87,0)
 <xsl:choose>
"KRN",.84,7981999.002,2,88,0)
  <xsl:when test="contains($value,$DELIMITER)">
"KRN",.84,7981999.002,2,89,0)
   <xsl:text>&quot;</xsl:text>
"KRN",.84,7981999.002,2,90,0)
   <xsl:value-of select="$value"/>
"KRN",.84,7981999.002,2,91,0)
   <xsl:text>&quot;</xsl:text>
"KRN",.84,7981999.002,2,92,0)
  </xsl:when>
"KRN",.84,7981999.002,2,93,0)
  <xsl:when test="contains($value,'&quot;')">
"KRN",.84,7981999.002,2,94,0)
   <xsl:text>&quot;</xsl:text>
"KRN",.84,7981999.002,2,95,0)
   <xsl:call-template name="DoubleQuotes">
"KRN",.84,7981999.002,2,96,0)
    <xsl:with-param name="value" select="$value"/>
"KRN",.84,7981999.002,2,97,0)
   </xsl:call-template>
"KRN",.84,7981999.002,2,98,0)
   <xsl:text>&quot;</xsl:text>
"KRN",.84,7981999.002,2,99,0)
  </xsl:when>
"KRN",.84,7981999.002,2,100,0)
  <xsl:otherwise><xsl:value-of select="$value"/></xsl:otherwise>
"KRN",.84,7981999.002,2,101,0)
 </xsl:choose>
"KRN",.84,7981999.002,2,102,0)
</xsl:template> 
"KRN",.84,7981999.002,2,103,0)
 
"KRN",.84,7981999.002,2,104,0)
<!-- Default report summary -->
"KRN",.84,7981999.002,2,105,0)
 
"KRN",.84,7981999.002,2,106,0)
<xsl:template name="ReportSummary">
"KRN",.84,7981999.002,2,107,0)
 <xsl:variable name="SUMMARY" select="/REPORT/SUMMARY"/>
"KRN",.84,7981999.002,2,108,0)
 <xsl:if test="$SUMMARY/*[1]">
"KRN",.84,7981999.002,2,109,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981999.002,2,110,0)
  <xsl:apply-templates select="$SUMMARY"/>
"KRN",.84,7981999.002,2,111,0)
 </xsl:if>
"KRN",.84,7981999.002,2,112,0)
</xsl:template>
"KRN",.84,7981999.002,2,113,0)
 
"KRN",.84,7981999.002,2,114,0)
<!-- Empty table indicator -->
"KRN",.84,7981999.002,2,115,0)
 
"KRN",.84,7981999.002,2,116,0)
<xsl:template name="TableNoData">
"KRN",.84,7981999.002,2,117,0)
 <xsl:text>No data has been found.</xsl:text>
"KRN",.84,7981999.002,2,118,0)
 <xsl:value-of select="$CRLF"/>
"KRN",.84,7981999.002,2,119,0)
</xsl:template>
"KRN",.84,7981999.002,2,120,0)
 
"KRN",.84,7981999.002,2,121,0)
<!-- Format the category data in a utilization report -->
"KRN",.84,7981999.002,2,122,0)
 
"KRN",.84,7981999.002,2,123,0)
<xsl:template name="UtilizationCategory">
"KRN",.84,7981999.002,2,124,0)
 <xsl:param name="catname"/>
"KRN",.84,7981999.002,2,125,0)
 <xsl:param name="table"/>
"KRN",.84,7981999.002,2,126,0)
 <xsl:for-each select="$table/*">
"KRN",.84,7981999.002,2,127,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981999.002,2,128,0)
   <xsl:with-param name="value" select="$catname"/>
"KRN",.84,7981999.002,2,129,0)
  </xsl:call-template>
"KRN",.84,7981999.002,2,130,0)
  <xsl:apply-templates select="*"/>
"KRN",.84,7981999.002,2,131,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981999.002,2,132,0)
 </xsl:for-each>
"KRN",.84,7981999.002,2,133,0)
</xsl:template>
"KRN",.84,7981999.002,2,134,0)
 
"KRN",.84,7981999.002,2,135,0)
<!-- Format the section of a utilization report -->
"KRN",.84,7981999.002,2,136,0)
 
"KRN",.84,7981999.002,2,137,0)
<xsl:template name="UtilizationSection">
"KRN",.84,7981999.002,2,138,0)
 <xsl:param name="parent" select="''"/>
"KRN",.84,7981999.002,2,139,0)
 <xsl:param name="subttl"/>
"KRN",.84,7981999.002,2,140,0)
 <xsl:param name="table"/>
"KRN",.84,7981999.002,2,141,0)
 <xsl:variable name="data">
"KRN",.84,7981999.002,2,142,0)
  <xsl:choose>
"KRN",.84,7981999.002,2,143,0)
   <xsl:when test="$parent!=''">
"KRN",.84,7981999.002,2,144,0)
    <xsl:copy-of
"KRN",.84,7981999.002,2,145,0)
         select="/REPORT/CATEGORY/*[name()=$parent]/*[@TABLE=$table]/*[1]"/>
"KRN",.84,7981999.002,2,146,0)
   </xsl:when>
"KRN",.84,7981999.002,2,147,0)
   <xsl:otherwise>
"KRN",.84,7981999.002,2,148,0)
    <xsl:copy-of select="/REPORT/CATEGORY/*[@TABLE=$table]/*[1]"/>
"KRN",.84,7981999.002,2,149,0)
   </xsl:otherwise>
"KRN",.84,7981999.002,2,150,0)
  </xsl:choose>
"KRN",.84,7981999.002,2,151,0)
 </xsl:variable>
"KRN",.84,7981999.002,2,152,0)
 <xsl:if test="$data">
"KRN",.84,7981999.002,2,153,0)
  <xsl:value-of select="$UTILIZATION_HEADER"/>
"KRN",.84,7981999.002,2,154,0)
  <xsl:value-of select="concat(' (',$subttl,')')"/>
"KRN",.84,7981999.002,2,155,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981999.002,2,156,0)
  <xsl:text>Category,</xsl:text>
"KRN",.84,7981999.002,2,157,0)
  <xsl:apply-templates
"KRN",.84,7981999.002,2,158,0)
       select="/REPORT/HEADER/TBLDEF[@NAME=$table]/@HEADER"/>
"KRN",.84,7981999.002,2,159,0)
  <xsl:choose>
"KRN",.84,7981999.002,2,160,0)
   <xsl:when test="$parent!=''">
"KRN",.84,7981999.002,2,161,0)
    <xsl:for-each select="/REPORT/CATEGORY">
"KRN",.84,7981999.002,2,162,0)
     <xsl:call-template name="UtilizationCategory">
"KRN",.84,7981999.002,2,163,0)
      <xsl:with-param name="catname" select="NAME"/>
"KRN",.84,7981999.002,2,164,0)
      <xsl:with-param name="table" select="*[name()=$parent]/*[@TABLE=$table]"/>
"KRN",.84,7981999.002,2,165,0)
     </xsl:call-template>
"KRN",.84,7981999.002,2,166,0)
    </xsl:for-each>
"KRN",.84,7981999.002,2,167,0)
   </xsl:when>
"KRN",.84,7981999.002,2,168,0)
   <xsl:otherwise>
"KRN",.84,7981999.002,2,169,0)
    <xsl:for-each select="/REPORT/CATEGORY">
"KRN",.84,7981999.002,2,170,0)
     <xsl:call-template name="UtilizationCategory">
"KRN",.84,7981999.002,2,171,0)
      <xsl:with-param name="catname" select="NAME"/>
"KRN",.84,7981999.002,2,172,0)
      <xsl:with-param name="table" select="*[@TABLE=$table]"/>
"KRN",.84,7981999.002,2,173,0)
     </xsl:call-template>
"KRN",.84,7981999.002,2,174,0)
    </xsl:for-each>
"KRN",.84,7981999.002,2,175,0)
   </xsl:otherwise>
"KRN",.84,7981999.002,2,176,0)
  </xsl:choose>
"KRN",.84,7981999.002,2,177,0)
  <xsl:value-of select="$FILESWITCH"/>
"KRN",.84,7981999.002,2,178,0)
 </xsl:if>
"KRN",.84,7981999.002,2,179,0)
</xsl:template>
"KRN",.84,7981999.002,2,180,0)
 
"KRN",.84,7981999.002,2,181,0)
<!--
"KRN",.84,7981999.002,2,182,0)
=========================================================================
"KRN",.84,7981999.002,2,183,0)
                       DEFAULT DATA GRID TEMPLATES
"KRN",.84,7981999.002,2,184,0)
=========================================================================
"KRN",.84,7981999.002,2,185,0)
-->
"KRN",.84,7981999.002,2,186,0)
 
"KRN",.84,7981999.002,2,187,0)
<xsl:template name="DataGrid" match="*[@TABLE!='']">
"KRN",.84,7981999.002,2,188,0)
 <xsl:variable name="tbldef" select="key('TableDefs',@TABLE)"/>
"KRN",.84,7981999.002,2,189,0)
 <xsl:value-of select="$CRLF"/>
"KRN",.84,7981999.002,2,190,0)
 <xsl:choose>
"KRN",.84,7981999.002,2,191,0)
  <xsl:when test="*[1]">
"KRN",.84,7981999.002,2,192,0)
   <xsl:apply-templates select="$tbldef/@HEADER"/>
"KRN",.84,7981999.002,2,193,0)
   <xsl:apply-templates select="*"/>
"KRN",.84,7981999.002,2,194,0)
  </xsl:when>
"KRN",.84,7981999.002,2,195,0)
  <xsl:otherwise>
"KRN",.84,7981999.002,2,196,0)
   <xsl:call-template name="TableNoData"/>
"KRN",.84,7981999.002,2,197,0)
  </xsl:otherwise>
"KRN",.84,7981999.002,2,198,0)
 </xsl:choose>
"KRN",.84,7981999.002,2,199,0)
</xsl:template>
"KRN",.84,7981999.002,2,200,0)
 
"KRN",.84,7981999.002,2,201,0)
<!-- Default data grid header -->
"KRN",.84,7981999.002,2,202,0)
 
"KRN",.84,7981999.002,2,203,0)
<xsl:template match="HEADER/TBLDEF/@HEADER">
"KRN",.84,7981999.002,2,204,0)
 <xsl:apply-templates select="..//COLUMN[not(child::COLUMN[1])]"/>
"KRN",.84,7981999.002,2,205,0)
 <xsl:value-of select="$CRLF"/>
"KRN",.84,7981999.002,2,206,0)
</xsl:template>
"KRN",.84,7981999.002,2,207,0)
 
"KRN",.84,7981999.002,2,208,0)
<!-- Default column heading cell -->
"KRN",.84,7981999.002,2,209,0)
 
"KRN",.84,7981999.002,2,210,0)
<xsl:template name="ColumnHeader" match="HEADER/TBLDEF/COLUMN">
"KRN",.84,7981999.002,2,211,0)
 <xsl:param name="column" select="."/>
"KRN",.84,7981999.002,2,212,0)
 <xsl:param name="title" select="$column/@NAME"/>
"KRN",.84,7981999.002,2,213,0)
 <xsl:if test="$title!='#'">
"KRN",.84,7981999.002,2,214,0)
  <xsl:call-template name="Quote">
"KRN",.84,7981999.002,2,215,0)
   <xsl:with-param name="value" select="$title"/>
"KRN",.84,7981999.002,2,216,0)
  </xsl:call-template>
"KRN",.84,7981999.002,2,217,0)
  <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981999.002,2,218,0)
 </xsl:if>
"KRN",.84,7981999.002,2,219,0)
</xsl:template>
"KRN",.84,7981999.002,2,220,0)
 
"KRN",.84,7981999.002,2,221,0)
<!-- Default data grid row -->
"KRN",.84,7981999.002,2,222,0)
 
"KRN",.84,7981999.002,2,223,0)
<xsl:template match="*[@TABLE!='']/*">
"KRN",.84,7981999.002,2,224,0)
 <xsl:param name="seqnum" select="0"/>
"KRN",.84,7981999.002,2,225,0)
 <xsl:if test="$seqnum">
"KRN",.84,7981999.002,2,226,0)
  <xsl:value-of select="position()"/>
"KRN",.84,7981999.002,2,227,0)
  <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981999.002,2,228,0)
 </xsl:if>
"KRN",.84,7981999.002,2,229,0)
 <xsl:apply-templates select="child::*"/>
"KRN",.84,7981999.002,2,230,0)
 <xsl:value-of select="$CRLF"/>
"KRN",.84,7981999.002,2,231,0)
</xsl:template>
"KRN",.84,7981999.002,2,232,0)
 
"KRN",.84,7981999.002,2,233,0)
<!-- Data grid cell -->
"KRN",.84,7981999.002,2,234,0)
 
"KRN",.84,7981999.002,2,235,0)
<xsl:template name="TableCell" match="*[@TABLE!='']/*/*">
"KRN",.84,7981999.002,2,236,0)
 <xsl:param name="fmdt" select="0"/>
"KRN",.84,7981999.002,2,237,0)
 <xsl:param name="value" select="."/>
"KRN",.84,7981999.002,2,238,0)
 <xsl:param name="yesno" select="0"/>
"KRN",.84,7981999.002,2,239,0)
 <xsl:choose>
"KRN",.84,7981999.002,2,240,0)
  <xsl:when test="boolean($fmdt)">
"KRN",.84,7981999.002,2,241,0)
   <xsl:call-template name="DateTime">
"KRN",.84,7981999.002,2,242,0)
    <xsl:with-param name="dt" select="$value"/>
"KRN",.84,7981999.002,2,243,0)
   </xsl:call-template>
"KRN",.84,7981999.002,2,244,0)
  </xsl:when>
"KRN",.84,7981999.002,2,245,0)
  <xsl:when test="boolean($yesno)">
"KRN",.84,7981999.002,2,246,0)
   <xsl:choose>
"KRN",.84,7981999.002,2,247,0)
    <xsl:when test="$value!=0">Yes</xsl:when>
"KRN",.84,7981999.002,2,248,0)
    <xsl:otherwise>No</xsl:otherwise>
"KRN",.84,7981999.002,2,249,0)
   </xsl:choose>
"KRN",.84,7981999.002,2,250,0)
  </xsl:when>
"KRN",.84,7981999.002,2,251,0)
  <xsl:otherwise>
"KRN",.84,7981999.002,2,252,0)
   <xsl:call-template name="Quote">
"KRN",.84,7981999.002,2,253,0)
    <xsl:with-param name="value" select="$value"/>
"KRN",.84,7981999.002,2,254,0)
   </xsl:call-template>
"KRN",.84,7981999.002,2,255,0)
  </xsl:otherwise>
"KRN",.84,7981999.002,2,256,0)
 </xsl:choose>
"KRN",.84,7981999.002,2,257,0)
 <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981999.002,2,258,0)
</xsl:template>
"KRN",.84,7981999.002,2,259,0)
 
"KRN",.84,7981999.002,2,260,0)
<!-- Default column headers -->
"KRN",.84,7981999.002,2,261,0)
 
"KRN",.84,7981999.002,2,262,0)
<xsl:template match="COLUMN[@NAME='AIDSTAT']">
"KRN",.84,7981999.002,2,263,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.002,2,264,0)
  <xsl:with-param name="title" select="'AIDS OI'"/>
"KRN",.84,7981999.002,2,265,0)
 </xsl:call-template>
"KRN",.84,7981999.002,2,266,0)
</xsl:template>
"KRN",.84,7981999.002,2,267,0)
 
"KRN",.84,7981999.002,2,268,0)
<xsl:template match="COLUMN[@NAME='DATE']">
"KRN",.84,7981999.002,2,269,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.002,2,270,0)
  <xsl:with-param name="title" select="'Date'"/>
"KRN",.84,7981999.002,2,271,0)
 </xsl:call-template>
"KRN",.84,7981999.002,2,272,0)
</xsl:template>
"KRN",.84,7981999.002,2,273,0)
 
"KRN",.84,7981999.002,2,274,0)
<xsl:template match="COLUMN[@NAME='LAST4']">
"KRN",.84,7981999.002,2,275,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.002,2,276,0)
  <xsl:with-param name="title" select="'SSN'"/>
"KRN",.84,7981999.002,2,277,0)
 </xsl:call-template>
"KRN",.84,7981999.002,2,278,0)
</xsl:template>
"KRN",.84,7981999.002,2,279,0)
 
"KRN",.84,7981999.002,2,280,0)
<xsl:template match="COLUMN[@NAME='NAME']">
"KRN",.84,7981999.002,2,281,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.002,2,282,0)
  <xsl:with-param name="title" select="'Name'"/>
"KRN",.84,7981999.002,2,283,0)
 </xsl:call-template>
"KRN",.84,7981999.002,2,284,0)
</xsl:template>
"KRN",.84,7981999.002,2,285,0)
 
"KRN",.84,7981999.002,2,286,0)
<xsl:template match="TBLDEF[@NAME='PATIENTS']/COLUMN[@NAME='NAME']">
"KRN",.84,7981999.002,2,287,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.002,2,288,0)
  <xsl:with-param name="title" select="'Patient Name'"/>
"KRN",.84,7981999.002,2,289,0)
 </xsl:call-template>
"KRN",.84,7981999.002,2,290,0)
</xsl:template>
"KRN",.84,7981999.002,2,291,0)
 
"KRN",.84,7981999.002,2,292,0)
<!-- Default cells -->
"KRN",.84,7981999.002,2,293,0)
 
"KRN",.84,7981999.002,2,294,0)
<xsl:template match="PATIENT/AIDSTAT">
"KRN",.84,7981999.002,2,295,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981999.002,2,296,0)
  <xsl:with-param name="yesno" select="1"/>
"KRN",.84,7981999.002,2,297,0)
 </xsl:call-template>
"KRN",.84,7981999.002,2,298,0)
</xsl:template>
"KRN",.84,7981999.002,2,299,0)
 
"KRN",.84,7981999.002,2,300,0)
</xsl:stylesheet>
"KRN",19,11363,-1)
2^3
"KRN",19,11363,0)
RORMNT MAIN^Clinical Case Registries Maintenance^^M^222222227^^^^^^^389
"KRN",19,11363,10,0)
^19.01IP^6^6
"KRN",19,11363,10,2,0)
11365^EAA
"KRN",19,11363,10,2,"^")
RORMNT AWAITING ACK
"KRN",19,11363,10,6,0)
11765^ACL
"KRN",19,11363,10,6,"^")
RORMNT ACL REINDEX
"KRN",19,11363,"U")
CLINICAL CASE REGISTRIES MAINT
"KRN",19,11365,-1)
0^4
"KRN",19,11365,0)
RORMNT AWAITING ACK^Edit 'Awaiting ACK' flag^^R^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11365,1,0)
^19.06^7^7^3030714^^^^
"KRN",19,11365,1,1,0)
 
"KRN",19,11365,1,2,0)
This option can be used for editing the 'AWAITING ACKNOWLEDGEMENT' field
"KRN",19,11365,1,3,0)
in the 'REGISTRY PARAMETERS' file.
"KRN",19,11365,1,4,0)
 
"KRN",19,11365,1,5,0)
If you are absolutely sure that there will be no acknowledgement from the
"KRN",19,11365,1,6,0)
AAC (for example, due a past malfunction), you can delete the value of
"KRN",19,11365,1,7,0)
the field to resume regular data transmissions.
"KRN",19,11365,25)
EDITACK^RORVM001
"KRN",19,11365,30)

"KRN",19,11365,31)

"KRN",19,11365,50)

"KRN",19,11365,51)

"KRN",19,11365,"U")
EDIT 'AWAITING ACK' FLAG
"KRN",19,11616,-1)
0^1
"KRN",19,11616,0)
ROR GUI^Broker Context^^B^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11616,1,0)
^19.06^2^2^3030714^^^^
"KRN",19,11616,1,1,0)
This option holds the references to the package RPC Broker Calls used by
"KRN",19,11616,1,2,0)
the GUI to create an application context (for security purposes).
"KRN",19,11616,99.1)
59458,48458
"KRN",19,11616,200.9)
^y
"KRN",19,11616,"RPC",0)
^19.05P^74^74
"KRN",19,11616,"RPC",1,0)
ROR ACTIVATE INACTIVATE
"KRN",19,11616,"RPC",2,0)
ROR ACTIVATE PATIENT GET
"KRN",19,11616,"RPC",3,0)
ROR EDIT PATIENT GET
"KRN",19,11616,"RPC",4,0)
ROR ENTER EDIT PATIENT
"KRN",19,11616,"RPC",5,0)
ROR IDRUGS PATIENT SET
"KRN",19,11616,"RPC",6,0)
ROR PATIENT SEARCH
"KRN",19,11616,"RPC",7,0)
ROR REG PARAMS GET
"KRN",19,11616,"RPC",8,0)
ROR REPORT
"KRN",19,11616,"RPC",10,0)
XWB GET VARIABLE VALUE
"KRN",19,11616,"RPC",11,0)
ROR ACTIVITY DETAILS
"KRN",19,11616,"RPC",12,0)
ROR ACTIVITY LOG
"KRN",19,11616,"RPC",13,0)
ROR INV DRUGS
"KRN",19,11616,"RPC",14,0)
ROR LOG MESSAGE DETAILS
"KRN",19,11616,"RPC",15,0)
ROR PATIENT CHECKS
"KRN",19,11616,"RPC",16,0)
XUS GET USER INFO
"KRN",19,11616,"RPC",17,0)
XUS KEY CHECK
"KRN",19,11616,"RPC",18,0)
ROR DRUG REPORT
"KRN",19,11616,"RPC",19,0)
XWB DEFERRED RPC
"KRN",19,11616,"RPC",20,0)
XWB DEFERRED CLEAR
"KRN",19,11616,"RPC",21,0)
XWB DEFERRED STATUS
"KRN",19,11616,"RPC",22,0)
XWB DEFERRED GETDATA
"KRN",19,11616,"RPC",23,0)
ROR STORE RPC HANDLE
"KRN",19,11616,"RPC",24,0)
ROR GET RPC HANDLE
"KRN",19,11616,"RPC",25,0)
ROR GET CODE LIST
"KRN",19,11616,"RPC",26,0)
ROR GET GUI PARAMS
"KRN",19,11616,"RPC",27,0)
ROR SET GUI PARAMS
"KRN",19,11616,"RPC",28,0)
ROR CLEAR RPC HANDLE
"KRN",19,11616,"RPC",29,0)
ROR REPORT RETRIEVE
"KRN",19,11616,"RPC",30,0)
ROR GUI ACCESS
"KRN",19,11616,"RPC",31,0)
ROR TASK INFO
"KRN",19,11616,"RPC",32,0)
ROR TASK LIST
"KRN",19,11616,"RPC",33,0)
ROR REPORT SCHEDULE
"KRN",19,11616,"RPC",34,0)
XWB IS RPC AVAILABLE
"KRN",19,11616,"RPC",35,0)
ROR GET REGISTRY INFO
"KRN",19,11616,"RPC",36,0)
ROR LIST REGISTRY USERS
"KRN",19,11616,"RPC",37,0)
ROR GUI PARAMETER GET
"KRN",19,11616,"RPC",38,0)
ROR GUI PARAMETER SET
"KRN",19,11616,"RPC",39,0)
ROR LOG GET ACCESS VIOLATIONS
"KRN",19,11616,"RPC",40,0)
ROR LOG GET LIST
"KRN",19,11616,"RPC",41,0)
ROR LOG GET MESSAGES
"KRN",19,11616,"RPC",42,0)
ROR REPORTS AVAILABLE
"KRN",19,11616,"RPC",43,0)
ROR TASK DELETE
"KRN",19,11616,"RPC",44,0)
ROR REPORT STYLESHEET
"KRN",19,11616,"RPC",45,0)
ROR LIST PATIENTS
"KRN",19,11616,"RPC",46,0)
ROR PATIENT SELECTION RULES
"KRN",19,11616,"RPC",47,0)
ROR LIST DIVISIONS
"KRN",19,11616,"RPC",48,0)
ROR LIST HOSPITAL LOCATIONS
"KRN",19,11616,"RPC",49,0)
ROR LIST ICD-9
"KRN",19,11616,"RPC",50,0)
ROR LIST LABORATORY TESTS
"KRN",19,11616,"RPC",51,0)
ROR LIST VA DRUG CLASSES
"KRN",19,11616,"RPC",52,0)
ROR LIST ITEMS
"KRN",19,11616,"RPC",53,0)
ROR LIST VISTA USERS
"KRN",19,11616,"RPC",54,0)
ROR UPDATE COORDINATORS
"KRN",19,11616,"RPC",55,0)
ROR LIST COORDINATORS
"KRN",19,11616,"RPC",56,0)
ROR LIST STATES
"KRN",19,11616,"RPC",57,0)
RORICR CDC LOAD
"KRN",19,11616,"RPC",58,0)
RORICR CDC SAVE
"KRN",19,11616,"RPC",59,0)
ROR LOG INFO
"KRN",19,11616,"RPC",60,0)
ROR GET USER INFO
"KRN",19,11616,"RPC",61,0)
ROR PATIENT GET DATA
"KRN",19,11616,"RPC",62,0)
ROR PATIENT (IN)ACTIVATE
"KRN",19,11616,"RPC",63,0)
ROR PATIENT DELETE
"KRN",19,11616,"RPC",64,0)
ROR LIST LOCAL LAB TESTS
"KRN",19,11616,"RPC",65,0)
ROR UPDATE LOCAL LAB TESTS
"KRN",19,11616,"RPC",66,0)
ROR UPDATE LOCAL DRUGS
"KRN",19,11616,"RPC",67,0)
ROR LIST LOCAL DRUGS
"KRN",19,11616,"RPC",68,0)
ROR LIST DRUGS
"KRN",19,11616,"RPC",69,0)
RORICR PATIENT LOAD
"KRN",19,11616,"RPC",70,0)
RORICR PATIENT SAVE
"KRN",19,11616,"RPC",71,0)
RORICR PATIENT CANCEL
"KRN",19,11616,"RPC",72,0)
RORICR CDC CANCEL
"KRN",19,11616,"RPC",73,0)
ROR TASK VALIDATE RESCHEDULING
"KRN",19,11616,"RPC",74,0)
ROR LIST GENERIC DRUGS
"KRN",19,11616,"U")
BROKER CONTEXT
"KRN",19,11765,-1)
0^2
"KRN",19,11765,0)
RORMNT ACL REINDEX^Re-index the ACL cross-reference^^R^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11765,1,0)
^19.06^9^9^3030714^^
"KRN",19,11765,1,1,0)
 
"KRN",19,11765,1,2,0)
The 'Re-index the ACL cross-reference' option lets users re-index the
"KRN",19,11765,1,3,0)
"ACL" cross-reference of the ROR REGISTRY PARAMETERS file (#798.1). This
"KRN",19,11765,1,4,0)
cross-reference should be rebuilt after changes in the allocation of the
"KRN",19,11765,1,5,0)
security keys associated with any registry.
"KRN",19,11765,1,6,0)
 
"KRN",19,11765,1,7,0)
Usually, this is done by the nightly task (the [ROR TASK] option).  
"KRN",19,11765,1,8,0)
However, if you want the changes to be in effect immediately, you should
"KRN",19,11765,1,9,0)
rebuild this cross-reference manually.
"KRN",19,11765,2)
y
"KRN",19,11765,10.1)
Reindex the ACL xref
"KRN",19,11765,25)
RNDXACL^RORVM001
"KRN",19,11765,"U")
RE-INDEX THE ACL CROSS-REFEREN
"KRN",19,11776,-1)
0^7
"KRN",19,11776,0)
RORICR VERSION COMPARISON^ICR Version Comparison Report^^R^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11776,1,0)
^19.06^10^10^3030722^^^
"KRN",19,11776,1,1,0)
 
"KRN",19,11776,1,2,0)
This option schedules a task, which generates the version comparison
"KRN",19,11776,1,3,0)
report. The report is used during the installation of the Immunology Case
"KRN",19,11776,1,4,0)
Registry V.3.0 software.
"KRN",19,11776,1,5,0)
 
"KRN",19,11776,1,6,0)
The first part of the report details all living patients that exist within
"KRN",19,11776,1,7,0)
the V.2.1 patient list but are not in the V.3.0 list. The second part of
"KRN",19,11776,1,8,0)
the report details all living patients that exist in the V.3.0 list but do
"KRN",19,11776,1,9,0)
not appear in the V.2.1 list. The third part of the report will list all
"KRN",19,11776,1,10,0)
patients that are both in V.2.1 and V.3.0.
"KRN",19,11776,2)
y
"KRN",19,11776,25)
BEGIN^RORREP01
"KRN",19,11776,200.9)
^y
"KRN",19,11776,"U")
ICR VERSION COMPARISON REPORT
"KRN",19,11794,-1)
0^5
"KRN",19,11794,0)
ROR SETUP^Registry Setup^^R^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11794,1,0)
^19.06^3^3^3030714^^
"KRN",19,11794,1,1,0)
  
"KRN",19,11794,1,2,0)
This option allows the user to enter parameters of the registry setup 
"KRN",19,11794,1,3,0)
process and schedule the task that will populate the registry.
"KRN",19,11794,25)
RORSET01
"KRN",19,11794,200.9)
n^y
"KRN",19,11794,"U")
REGISTRY SETUP
"KRN",19,11967,-1)
1^6
"KRN",19,11967,0)
ROR SETUP HEPC
"KRN",19.1,433,-1)
0^2
"KRN",19.1,433,0)
ROR VA ICR USER^Immunulogy Case Registry User^l
"KRN",19.1,434,-1)
0^1
"KRN",19.1,434,0)
ROR VA ICR ADMIN^Immunology Case Registry Admin^l
"KRN",19.1,434,3,0)
^19.13P^^0
"KRN",101,5488,-1)
0^1
"KRN",101,5488,0)
RORICR-SITE-DRIVER^Immunology Case Registry Client^^E^^^^^^^^
"KRN",101,5488,99)
59343,37135
"KRN",101,5488,770)
ROR SITE^^CSU^C09^25^^^AL^AL^2.3.1^
"KRN",101,5488,772)
D PROCESS^RORACK
"KRN",101,5488,775,0)
^101.0775PA^2^1
"KRN",101,5488,775,2,0)
5489
"KRN",101,5488,775,2,"^")
RORICR-SITE-SUBSCRIBER
"KRN",101,5489,-1)
0^2
"KRN",101,5489,0)
RORICR-SITE-SUBSCRIBER^Immunology Case Registry Server^^S^^^^^^^^
"KRN",101,5489,99)
59343,37135
"KRN",101,5489,770)
^ROR AAC^^C09^^^RORICR SND^^^^ACK
"KRN",101,5489,773)
1^0^0
"KRN",870,59,-1)
0^1
"KRN",870,59,0)
RORICR SND^^TCP^^^^^^^^^^^^^^^^^^10
"KRN",870,59,200)
^^^60^600^^^^^R
"KRN",870,59,400)
10.224.187.7^7001^C^^10^
"KRN",8989.51,4760,-1)
0^1
"KRN",8989.51,4760,0)
ROR GUI PARAMETER^Clinical Case Registries GUI Parameter^1^GUI Parameter^^1
"KRN",8989.51,4760,1)
W
"KRN",8989.51,4760,4,0)
^8989.514^2^2
"KRN",8989.51,4760,4,1,0)
GUI
"KRN",8989.51,4760,4,2,0)
SETTINGS
"KRN",8989.51,4760,4,"B","GUI",1)

"KRN",8989.51,4760,4,"B","SETTINGS",2)

"KRN",8989.51,4760,6)
F
"KRN",8989.51,4760,30,0)
^8989.513I^2^2
"KRN",8989.51,4760,30,1,0)
1^200
"KRN",8989.51,4760,30,2,0)
2^9.4
"KRN",8994,1746,-1)
0^13
"KRN",8994,1746,0)
ROR REPORT RETRIEVE^GETXML^RORRP011^2^R^^^1^1
"KRN",8994,1746,1,0)
^8994.01^2^2^3030620^^^^
"KRN",8994,1746,1,1,0)
The ROR REPORT RETRIEVE remote procedure returns an array that contains
"KRN",8994,1746,1,2,0)
the report (in XML format) generated by the task.
"KRN",8994,1746,2,0)
^8994.02A^4^4
"KRN",8994,1746,2,1,0)
TASK^1^^1^1
"KRN",8994,1746,2,1,1,0)
^^2^2^3030110^
"KRN",8994,1746,2,1,1,1,0)
Task number returned either by the ROR REPORT SCHEDULE or ROR TASK LIST
"KRN",8994,1746,2,1,1,2,0)
remote procedures.
"KRN",8994,1746,2,2,0)
FROM^1^^^2
"KRN",8994,1746,2,2,1,0)
^^24^24^3030110^
"KRN",8994,1746,2,2,1,1,0)
A string that indicates where to start/continue the rendering process. It 
"KRN",8994,1746,2,2,1,2,0)
contains three "^"-pieces:
"KRN",8994,1746,2,2,1,3,0)
 
"KRN",8994,1746,2,2,1,4,0)
  ^1: IEN of the report element
"KRN",8994,1746,2,2,1,5,0)
 
"KRN",8994,1746,2,2,1,6,0)
  ^2: Where exactly the rendering process has stopped
"KRN",8994,1746,2,2,1,7,0)
      (see the $$XMLREP^RORTSK10 function for details)
"KRN",8994,1746,2,2,1,8,0)
 
"KRN",8994,1746,2,2,1,9,0)
  ^3: IEN of the text line (if the 2nd piece = 3)
"KRN",8994,1746,2,2,1,10,0)
 
"KRN",8994,1746,2,2,1,11,0)
To continue the rendering from the point where it stopped during the
"KRN",8994,1746,2,2,1,12,0)
previous call of the remote procedure, just assign the non-empty value
"KRN",8994,1746,2,2,1,13,0)
returned in the RESULT[0] by the previous call.
"KRN",8994,1746,2,2,1,14,0)
 
"KRN",8994,1746,2,2,1,15,0)
By default (if $G(FROM)'>0), the rendering starts from the beginning of 
"KRN",8994,1746,2,2,1,16,0)
the report.
"KRN",8994,1746,2,2,1,17,0)
 
"KRN",8994,1746,2,2,1,18,0)
NOTE: 
"KRN",8994,1746,2,2,1,19,0)
 
"KRN",8994,1746,2,2,1,20,0)
Despite this description, you must not make any assumptions about
"KRN",8994,1746,2,2,1,21,0)
structure of this parameter (it can be changed at any time without
"KRN",8994,1746,2,2,1,22,0)
warning). The only exception is the IEN of the report element. You can
"KRN",8994,1746,2,2,1,23,0)
assign a positive value to this parameter before the call to start the
"KRN",8994,1746,2,2,1,24,0)
rendering from the corresponding element.
"KRN",8994,1746,2,3,0)
MAXSIZE^1^^^3
"KRN",8994,1746,2,3,1,0)
^^13^13^3030307^
"KRN",8994,1746,2,3,1,1,0)
Either the maximum number of lines to retrieve or the maximum size of the
"KRN",8994,1746,2,3,1,2,0)
output in bytes (append the "B" to the number). By default (if
"KRN",8994,1746,2,3,1,3,0)
$G(MAXSIZE)'>0,) the whole report (starting from the point indicated by
"KRN",8994,1746,2,3,1,4,0)
the FROM parameter if it is defined) is retrieved.
"KRN",8994,1746,2,3,1,5,0)
 
"KRN",8994,1746,2,3,1,6,0)
  Examples:
"KRN",8994,1746,2,3,1,7,0)
    500    Retrieve no more that 500 lines
"KRN",8994,1746,2,3,1,8,0)
    4096B  Retrieve no mor than 4Kb
"KRN",8994,1746,2,3,1,9,0)
 
"KRN",8994,1746,2,3,1,10,0)
NOTE: If the "B" suffix is used, the size of the retrieved
"KRN",8994,1746,2,3,1,11,0)
      portion of the document can be somewhat bigger than
"KRN",8994,1746,2,3,1,12,0)
      MAXSIZE! The last line of the chunk is not truncated
"KRN",8994,1746,2,3,1,13,0)
      even if the size will be bigger than MAXSIZE.
"KRN",8994,1746,2,4,0)
SORT^2^^^4
"KRN",8994,1746,2,4,1,0)
^^36^36^3030620^
"KRN",8994,1746,2,4,1,1,0)
The SORT list defines how the different parts of the report are sorted.
"KRN",8994,1746,2,4,1,2,0)
It should be defined as follow:
"KRN",8994,1746,2,4,1,3,0)
 
"KRN",8994,1746,2,4,1,4,0)
  SORT(i)="ParentElementName=SortElementName"
"KRN",8994,1746,2,4,1,5,0)
 
"KRN",8994,1746,2,4,1,6,0)
An optional D[ESC] modifier (the abbreviation of 'descending') can be
"KRN",8994,1746,2,4,1,7,0)
added after the SortElementName. They should be sepearted by the ':'.
"KRN",8994,1746,2,4,1,8,0)
 
"KRN",8994,1746,2,4,1,9,0)
For example, if the report has the following structure:
"KRN",8994,1746,2,4,1,10,0)
 
"KRN",8994,1746,2,4,1,11,0)
  <REPORT>
"KRN",8994,1746,2,4,1,12,0)
    <PATIENT>
"KRN",8994,1746,2,4,1,13,0)
      <NAME> ... </NAME>
"KRN",8994,1746,2,4,1,14,0)
      <DOB> ... </DOB>
"KRN",8994,1746,2,4,1,15,0)
      <SELRULES>
"KRN",8994,1746,2,4,1,16,0)
        <RULE>
"KRN",8994,1746,2,4,1,17,0)
          <NAME> ... </NAME>
"KRN",8994,1746,2,4,1,18,0)
          <DATE> ... </DATE>
"KRN",8994,1746,2,4,1,19,0)
        </RULE>
"KRN",8994,1746,2,4,1,20,0)
        ...
"KRN",8994,1746,2,4,1,21,0)
      </SELRULES>
"KRN",8994,1746,2,4,1,22,0)
    </PATIENT>
"KRN",8994,1746,2,4,1,23,0)
    ...
"KRN",8994,1746,2,4,1,24,0)
  </REPORT>
"KRN",8994,1746,2,4,1,25,0)
 
"KRN",8994,1746,2,4,1,26,0)
and the SORT parameter is defined by the client application as follow:
"KRN",8994,1746,2,4,1,27,0)
 
"KRN",8994,1746,2,4,1,28,0)
  with RPCBroker do begin     
"KRN",8994,1746,2,4,1,29,0)
    Param[3].PType := list; 
"KRN",8994,1746,2,4,1,30,0)
    Param[3].Mult[1] := 'REPORT=NAME';  
"KRN",8994,1746,2,4,1,31,0)
    Param[3].Mult[2] := 'SELRULES=DATE:D';
"KRN",8994,1746,2,4,1,32,0)
  end;
"KRN",8994,1746,2,4,1,33,0)
 
"KRN",8994,1746,2,4,1,34,0)
then the procedure will sort the patients by their names and the selection
"KRN",8994,1746,2,4,1,35,0)
rules for each patient will be sorted by the corresponding dates in 
"KRN",8994,1746,2,4,1,36,0)
descending order.
"KRN",8994,1746,2,"B","FROM",2)

"KRN",8994,1746,2,"B","MAXSIZE",3)

"KRN",8994,1746,2,"B","SORT",4)

"KRN",8994,1746,2,"B","TASK",1)

"KRN",8994,1746,2,"PARAMSEQ",1,1)

"KRN",8994,1746,2,"PARAMSEQ",2,2)

"KRN",8994,1746,2,"PARAMSEQ",3,3)

"KRN",8994,1746,2,"PARAMSEQ",4,4)

"KRN",8994,1746,3,0)
^8994.03^31^31^3030620^^^^
"KRN",8994,1746,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1746,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1746,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1746,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1746,3,5,0)
    
"KRN",8994,1746,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1746,3,7,0)
                          ^01: The last error code
"KRN",8994,1746,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1746,3,9,0)
                                                                      
"KRN",8994,1746,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1746,3,11,0)
                          ^01: Error code
"KRN",8994,1746,3,12,0)
                          ^02: Message
"KRN",8994,1746,3,13,0)
                          ^03: Place of the error
"KRN",8994,1746,3,14,0)
 
"KRN",8994,1746,3,15,0)
Otherwise, it contains either a string that indicates the place where 
"KRN",8994,1746,3,16,0)
the rendering stopped because the maximum number of lines (defined by the 
"KRN",8994,1746,3,17,0)
NUMBER parameter) had been processed or an empty string if the processing 
"KRN",8994,1746,3,18,0)
of the report was completed.
"KRN",8994,1746,3,19,0)
 
"KRN",8994,1746,3,20,0)
You should pass this value (if it is not empty) as the FROM parameter to
"KRN",8994,1746,3,21,0)
subsequent call of the remote procedure if you want to continue the
"KRN",8994,1746,3,22,0)
rendering from the point where it stopped.
"KRN",8994,1746,3,23,0)
 
"KRN",8994,1746,3,24,0)
The subsequent elements of the resulting array (starting from 1) contain
"KRN",8994,1746,3,25,0)
the lines of the report. An element can contain an XML tag, a single-line
"KRN",8994,1746,3,26,0)
value between opening and closing tags or a line of text.
"KRN",8994,1746,3,27,0)
 
"KRN",8994,1746,3,28,0)
NOTE: If the MAXSIZE parameter is not defined or not greater
"KRN",8994,1746,3,29,0)
      than zero (a request for the whole report), the new value
"KRN",8994,1746,3,30,0)
      for the FROM parameter is not returned in the Results[0]
"KRN",8994,1746,3,31,0)
      and the latter contains the first line of the report.
"KRN",8994,1749,-1)
0^14
"KRN",8994,1749,0)
ROR REPORT SCHEDULE^SCHEDREP^RORRP010^2^R^^^1^1
"KRN",8994,1749,1,0)
^8994.01^1^1^3031107^^^^
"KRN",8994,1749,1,1,0)
Schedules the report and returns the task information.
"KRN",8994,1749,2,0)
^8994.02A^5^5
"KRN",8994,1749,2,1,0)
REGIEN^1^^^2
"KRN",8994,1749,2,1,1,0)
^8994.021^2^2^3030220^^
"KRN",8994,1749,2,1,1,1,0)
Registry IEN (if $G(REGIEN)'>0 the task will not be associated with any
"KRN",8994,1749,2,1,1,2,0)
particular registry).
"KRN",8994,1749,2,2,0)
RPTCODE^1^^1^1
"KRN",8994,1749,2,2,1,0)
^8994.021^2^2^3030307^^^
"KRN",8994,1749,2,2,1,1,0)
Code of the report (value of the CODE field of the report descriptor in
"KRN",8994,1749,2,2,1,2,0)
the ROR REPORT file).
"KRN",8994,1749,2,3,0)
ZTDTH^1^^^3
"KRN",8994,1749,2,3,1,0)
^^2^2^3030110^
"KRN",8994,1749,2,3,1,1,0)
Date/time to start the task (external value). By default (if $G(ZDTH)=""),
"KRN",8994,1749,2,3,1,2,0)
the task will be scheduled to run after 3-second pause.
"KRN",8994,1749,2,4,0)
PARAMS^2^^^5
"KRN",8994,1749,2,4,1,0)
^^204^204^3031107^
"KRN",8994,1749,2,4,1,1,0)
A list of name-value pairs of task parameters: PARAMS(name)=value.
"KRN",8994,1749,2,4,1,2,0)
For example:
"KRN",8994,1749,2,4,1,3,0)
 
"KRN",8994,1749,2,4,1,4,0)
  with RPCBroker.Param[4] do
"KRN",8994,1749,2,4,1,5,0)
    begin
"KRN",8994,1749,2,4,1,6,0)
      PType :=list;
"KRN",8994,1749,2,4,1,7,0)
      Mult['"REGIEN"'] := RegInfo.IEN;
"KRN",8994,1749,2,4,1,8,0)
      Mult['"DATE_RANGE"'] := 'YEAR^2003';
"KRN",8994,1749,2,4,1,9,0)
      Mult['"PATIENTS"'] := 'INPATIENT,OUTPATIENT';
"KRN",8994,1749,2,4,1,10,0)
      Mult['"VADRUGCLS(1)"'] := 'IN140';
"KRN",8994,1749,2,4,1,11,0)
      Mult['"VADRUGCLS(2)"'] := 'IN150';
"KRN",8994,1749,2,4,1,12,0)
    end;
"KRN",8994,1749,2,4,1,13,0)
 
"KRN",8994,1749,2,4,1,14,0)
Accepted parameters:
"KRN",8994,1749,2,4,1,15,0)
 
"KRN",8994,1749,2,4,1,16,0)
  CD4OPT        CD4 options
"KRN",8994,1749,2,4,1,17,0)
                  ^01: Include CD4 (0/1)
"KRN",8994,1749,2,4,1,18,0)
                  ^02: Use range   (0/1)
"KRN",8994,1749,2,4,1,19,0)
                  ^03: Low
"KRN",8994,1749,2,4,1,20,0)
                  ^04: High
"KRN",8994,1749,2,4,1,21,0)
 
"KRN",8994,1749,2,4,1,22,0)
                Example (include all):
"KRN",8994,1749,2,4,1,23,0)
                  Mult['"CD4OPT"'] := '1';
"KRN",8994,1749,2,4,1,24,0)
 
"KRN",8994,1749,2,4,1,25,0)
                Example (use range):
"KRN",8994,1749,2,4,1,26,0)
                  Mult['"CD4OPT"'] := '1^1^5000000^9000000';
"KRN",8994,1749,2,4,1,27,0)
 
"KRN",8994,1749,2,4,1,28,0)
  CLINICS       Clinics included in the report
"KRN",8994,1749,2,4,1,29,0)
 
"KRN",8994,1749,2,4,1,30,0)
                Example 1 (all clinics):
"KRN",8994,1749,2,4,1,31,0)
                  Mult['"CLINICS"'] := 'ALL';
"KRN",8994,1749,2,4,1,32,0)
 
"KRN",8994,1749,2,4,1,33,0)
                Example 2 (selected clinics):
"KRN",8994,1749,2,4,1,34,0)
                  for i := 1 to Clinics.Count do
"KRN",8994,1749,2,4,1,35,0)
                    Mult['"CLINICS('+i+')"'] := Clinics[i-1].IEN;
"KRN",8994,1749,2,4,1,36,0)
 
"KRN",8994,1749,2,4,1,37,0)
  DATE_RANGE    Date Range
"KRN",8994,1749,2,4,1,38,0)
 
"KRN",8994,1749,2,4,1,39,0)
                  CUSTOM^StartDate^EndDate (FileMan)
"KRN",8994,1749,2,4,1,40,0)
                  CUTOFF^Cutoff
"KRN",8994,1749,2,4,1,41,0)
                  QUARTER^Quarter^Year^Fiscal
"KRN",8994,1749,2,4,1,42,0)
                  YEAR^Year^Fiscal
"KRN",8994,1749,2,4,1,43,0)
 
"KRN",8994,1749,2,4,1,44,0)
                Examples:
"KRN",8994,1749,2,4,1,45,0)
                  Mult['"DATE_RANGE"'] := 'CUSTOM^3021015^3030201';
"KRN",8994,1749,2,4,1,46,0)
                  Mult['"DATE_RANGE"'] := 'CUTOFF^25';   // 25 days
"KRN",8994,1749,2,4,1,47,0)
                  Mult['"DATE_RANGE"'] := 'CUTOFF^5W';   // 5 weeks
"KRN",8994,1749,2,4,1,48,0)
                  Mult['"DATE_RANGE"'] := 'QUARTER^2^2003';
"KRN",8994,1749,2,4,1,49,0)
                  Mult['"DATE_RANGE"'] := 'YEAR^2003^1'; // Fiscal 2003
"KRN",8994,1749,2,4,1,50,0)
 
"KRN",8994,1749,2,4,1,51,0)
  DIVISIONS     Divisions included in the report
"KRN",8994,1749,2,4,1,52,0)
 
"KRN",8994,1749,2,4,1,53,0)
                Example 1 (all divisions):
"KRN",8994,1749,2,4,1,54,0)
                  Mult['"DIVISIONS"'] := 'ALL';
"KRN",8994,1749,2,4,1,55,0)
 
"KRN",8994,1749,2,4,1,56,0)
                Example 2 (selected divisions):
"KRN",8994,1749,2,4,1,57,0)
                  for i := 1 to Divisions.Count do
"KRN",8994,1749,2,4,1,58,0)
                    Mult['"DIVISIONS('+i+')"'] := Divisions[i-1].IEN;
"KRN",8994,1749,2,4,1,59,0)
 
"KRN",8994,1749,2,4,1,60,0)
  DRUGS         Drugs included in the report:
"KRN",8994,1749,2,4,1,61,0)
 
"KRN",8994,1749,2,4,1,62,0)
    ALL           All drugs
"KRN",8994,1749,2,4,1,63,0)
    ARV           Drugs defined in the ROR GENERIC DRUG file and
"KRN",8994,1749,2,4,1,64,0)
                  the LOCAL DRUG NAME multiple of the file #798.1
"KRN",8994,1749,2,4,1,65,0)
    DISPENSED     Search and/or aggregate dispensed drugs
"KRN",8994,1749,2,4,1,66,0)
    GENERIC       Search and/or aggregate generic drugs
"KRN",8994,1749,2,4,1,67,0)
    VARXCLS       Drugs in the classes defined by
"KRN",8994,1749,2,4,1,68,0)
                  the VADRUGCLS parameter
"KRN",8994,1749,2,4,1,69,0)
 
"KRN",8994,1749,2,4,1,70,0)
                Example 1 (drugs from the registry parameters):
"KRN",8994,1749,2,4,1,71,0)
                  Mult['"DRUGS"'] := 'ARV,AGRDISP';
"KRN",8994,1749,2,4,1,72,0)
 
"KRN",8994,1749,2,4,1,73,0)
                Example 2 (selected drugs):
"KRN",8994,1749,2,4,1,74,0)
                  for i := 1 to Drugs.Count do
"KRN",8994,1749,2,4,1,75,0)
                    Mult['"DRUGS('+i+')"'] := Drugs[i-1].IEN;
"KRN",8994,1749,2,4,1,76,0)
 
"KRN",8994,1749,2,4,1,77,0)
  FIELDS        Additional fields included in the report
"KRN",8994,1749,2,4,1,78,0)
 
"KRN",8994,1749,2,4,1,79,0)
    ACTIVE        Active/Inactive status
"KRN",8994,1749,2,4,1,80,0)
    AIDSTAT       Clinical AIDS status
"KRN",8994,1749,2,4,1,81,0)
    ALIVE         Living status
"KRN",8994,1749,2,4,1,82,0)
    AGE           Patient age
"KRN",8994,1749,2,4,1,83,0)
    CSSN          Coded SSN
"KRN",8994,1749,2,4,1,84,0)
    DOB           Date of birth
"KRN",8994,1749,2,4,1,85,0)
    DOD           Date of death
"KRN",8994,1749,2,4,1,86,0)
    ENTDT         Date added to the registry
"KRN",8994,1749,2,4,1,87,0)
    ICN           Integration Control Number
"KRN",8994,1749,2,4,1,88,0)
    INADT         Date of inactivation
"KRN",8994,1749,2,4,1,89,0)
    INARSN        Reason for inactivation
"KRN",8994,1749,2,4,1,90,0)
    LAST4         Last 4 digits of the SSN
"KRN",8994,1749,2,4,1,91,0)
    PRIMELIG      Primary eligibility
"KRN",8994,1749,2,4,1,92,0)
    RACE          Race(s)
"KRN",8994,1749,2,4,1,93,0)
    READT         Date of reactivation
"KRN",8994,1749,2,4,1,94,0)
    REARSN        Reason for reactivation (supporting evidence)
"KRN",8994,1749,2,4,1,95,0)
    REIMBLVL      Reimbursement level
"KRN",8994,1749,2,4,1,96,0)
    RISK          Risk factors
"KRN",8994,1749,2,4,1,97,0)
    SELRULES      Reason(s) for addition to the registry
"KRN",8994,1749,2,4,1,98,0)
    SEX           Patient sex
"KRN",8994,1749,2,4,1,99,0)
    SSN           Full SSN
"KRN",8994,1749,2,4,1,100,0)
    UTIL          Utilization
"KRN",8994,1749,2,4,1,101,0)
 
"KRN",8994,1749,2,4,1,102,0)
                Example:
"KRN",8994,1749,2,4,1,103,0)
                  Mult['"FIELDS"'] := 'SSN,SEX,ENTDT,SELRULES';
"KRN",8994,1749,2,4,1,104,0)
 
"KRN",8994,1749,2,4,1,105,0)
  ICD9LST       List of ICD-9 codes included in the report
"KRN",8994,1749,2,4,1,106,0)
 
"KRN",8994,1749,2,4,1,107,0)
    ALL           Include all ICD-9 codes
"KRN",8994,1749,2,4,1,108,0)
 
"KRN",8994,1749,2,4,1,109,0)
                Example 1 (all codes):
"KRN",8994,1749,2,4,1,110,0)
                  Mult['"ICD9LST"'] := 'ALL';
"KRN",8994,1749,2,4,1,111,0)
 
"KRN",8994,1749,2,4,1,112,0)
                Example 2 (selected codes):
"KRN",8994,1749,2,4,1,113,0)
                  for i := 1 to ICD9.Count do
"KRN",8994,1749,2,4,1,114,0)
                    Mult['"ICD9LST('+i+')"'] := ICD9[i-1];
"KRN",8994,1749,2,4,1,115,0)
 
"KRN",8994,1749,2,4,1,116,0)
  LABTESTS      Lab tests included in the report
"KRN",8994,1749,2,4,1,117,0)
 
"KRN",8994,1749,2,4,1,118,0)
                Example 1 (all test):
"KRN",8994,1749,2,4,1,119,0)
                  Mult['"LABTESTS"'] := 'ALL';
"KRN",8994,1749,2,4,1,120,0)
 
"KRN",8994,1749,2,4,1,121,0)
                Example 2 (selected tests):
"KRN",8994,1749,2,4,1,122,0)
                  for i := 1 to LabTests.Count do
"KRN",8994,1749,2,4,1,123,0)
                    Mult['"LABTESTS('+i+')"'] := LabTests[i-1].IEN;
"KRN",8994,1749,2,4,1,124,0)
 
"KRN",8994,1749,2,4,1,125,0)
  MAXUTNUM      Number of patients with the highest utilization
"KRN",8994,1749,2,4,1,126,0)
                to be included in the report.
"KRN",8994,1749,2,4,1,127,0)
 
"KRN",8994,1749,2,4,1,128,0)
                Example:
"KRN",8994,1749,2,4,1,129,0)
                  Mult['"MAXUTNUM"'] := '5';
"KRN",8994,1749,2,4,1,130,0)
 
"KRN",8994,1749,2,4,1,131,0)
  MINRPNUM      Minimum number of times that the radiology procedure
"KRN",8994,1749,2,4,1,132,0)
                or Lab test is performed that is required for its
"KRN",8994,1749,2,4,1,133,0)
                inclusion in the report.
"KRN",8994,1749,2,4,1,134,0)
 
"KRN",8994,1749,2,4,1,135,0)
                Example:
"KRN",8994,1749,2,4,1,136,0)
                  Mult['"MINRPNUM"'] := '3';
"KRN",8994,1749,2,4,1,137,0)
 
"KRN",8994,1749,2,4,1,138,0)
  OPTIONS       Report options (separated by commas):
"KRN",8994,1749,2,4,1,139,0)
 
"KRN",8994,1749,2,4,1,140,0)
    AIDSNOARV     Include the list of registry patients with AIDS who
"KRN",8994,1749,2,4,1,141,0)
                  received no ARV drugs during the report time frame
"KRN",8994,1749,2,4,1,142,0)
    ARVLST        Include the list of ARV drugs, which were received
"KRN",8994,1749,2,4,1,143,0)
                  by registry patients during the report time frame
"KRN",8994,1749,2,4,1,144,0)
    ARVPTL        Include the list of registry patients who received
"KRN",8994,1749,2,4,1,145,0)
                  any ARV drugs during the report time frame
"KRN",8994,1749,2,4,1,146,0)
    CATSPLIT      Split by category
"KRN",8994,1749,2,4,1,147,0)
    COMPLETE      Include complete report
"KRN",8994,1749,2,4,1,148,0)
    LAB           Include Lab data
"KRN",8994,1749,2,4,1,149,0)
    PHARMACY      Include pharmacy data
"KRN",8994,1749,2,4,1,150,0)
    SUMMARY       Include summary
"KRN",8994,1749,2,4,1,151,0)
 
"KRN",8994,1749,2,4,1,152,0)
                Example:
"KRN",8994,1749,2,4,1,153,0)
                  Mult['"OPTIONS"'] := 'COMPLETE,SUMMARY';
"KRN",8994,1749,2,4,1,154,0)
 
"KRN",8994,1749,2,4,1,155,0)
  PATIENTS      Include the patients defined by the attributes
"KRN",8994,1749,2,4,1,156,0)
                (separated by commas) in the report:
"KRN",8994,1749,2,4,1,157,0)
 
"KRN",8994,1749,2,4,1,158,0)
    ACTIVE        Active registry patients
"KRN",8994,1749,2,4,1,159,0)
    AIDS          Patients with clinical AIDS status
"KRN",8994,1749,2,4,1,160,0)
    CAREONLY      Include only those patients who have
"KRN",8994,1749,2,4,1,161,0)
                  received care
"KRN",8994,1749,2,4,1,162,0)
    DE_AFTER      Patients added after the report end date
"KRN",8994,1749,2,4,1,163,0)
    DE_BEFORE     Patients added before the report start date
"KRN",8994,1749,2,4,1,164,0)
    DE_DURING     Patietns added during the report time frame
"KRN",8994,1749,2,4,1,165,0)
    HIV           Patients with the HIV+ status
"KRN",8994,1749,2,4,1,166,0)
    INACTIVE      Inactive registry patients
"KRN",8994,1749,2,4,1,167,0)
    INPATIENT     Inpatients
"KRN",8994,1749,2,4,1,168,0)
    NOTSEEN       Patients not seen in the time frame
"KRN",8994,1749,2,4,1,169,0)
    OUTPATIENT    Outpatients
"KRN",8994,1749,2,4,1,170,0)
    SEEN          Patients seen in the provided time frame
"KRN",8994,1749,2,4,1,171,0)
 
"KRN",8994,1749,2,4,1,172,0)
                Example:
"KRN",8994,1749,2,4,1,173,0)
                  Mult['"PATIENTS"'] := 'ACTIVE,NEW,INPATIENT';
"KRN",8994,1749,2,4,1,174,0)
 
"KRN",8994,1749,2,4,1,175,0)
  PTLST         List of selected patients
"KRN",8994,1749,2,4,1,176,0)
 
"KRN",8994,1749,2,4,1,177,0)
                Example:
"KRN",8994,1749,2,4,1,178,0)
                  for i := 1 to Patients.Count do
"KRN",8994,1749,2,4,1,179,0)
                    Mult[i] := 'PTLST('+i+')=' + Patients[i-1].IEN;
"KRN",8994,1749,2,4,1,180,0)
 
"KRN",8994,1749,2,4,1,181,0)
  REGIEN        Registry IEN
"KRN",8994,1749,2,4,1,182,0)
 
"KRN",8994,1749,2,4,1,183,0)
                Example:
"KRN",8994,1749,2,4,1,184,0)
                  Mult['"REGIEN"'] := RegInfo.IEN;
"KRN",8994,1749,2,4,1,185,0)
 
"KRN",8994,1749,2,4,1,186,0)
  TASK_DESCR    Description of the task that generates the report
"KRN",8994,1749,2,4,1,187,0)
 
"KRN",8994,1749,2,4,1,188,0)
  VADRUGCLS     VA drug classes included in the report
"KRN",8994,1749,2,4,1,189,0)
 
"KRN",8994,1749,2,4,1,190,0)
                Example:
"KRN",8994,1749,2,4,1,191,0)
                  Mult['"VADRUGCLS(1)"'] := 'IN140';
"KRN",8994,1749,2,4,1,192,0)
                  Mult['"VADRUGCLS(2)"'] := 'IN150';
"KRN",8994,1749,2,4,1,193,0)
 
"KRN",8994,1749,2,4,1,194,0)
  VIRAL_LOAD    Viral Load options
"KRN",8994,1749,2,4,1,195,0)
                  ^01: Include Viral Load (0/1)
"KRN",8994,1749,2,4,1,196,0)
                  ^02: Use range          (0/1)
"KRN",8994,1749,2,4,1,197,0)
                  ^03: Low
"KRN",8994,1749,2,4,1,198,0)
                  ^04: High
"KRN",8994,1749,2,4,1,199,0)
 
"KRN",8994,1749,2,4,1,200,0)
                Example (include all):
"KRN",8994,1749,2,4,1,201,0)
                  Mult['"VIRAL_LOAD"'] := '1';
"KRN",8994,1749,2,4,1,202,0)
 
"KRN",8994,1749,2,4,1,203,0)
                Example (use range):
"KRN",8994,1749,2,4,1,204,0)
                  Mult['"VIRAL_LOAD"'] := '1^1^3000^100000';
"KRN",8994,1749,2,5,0)
SCHCODE^1^^^4
"KRN",8994,1749,2,5,1,0)
^8994.021^1^1^3031107^^^^
"KRN",8994,1749,2,5,1,1,0)
Rescheduling code ("1D", "1M", "D@12:00", etc).
"KRN",8994,1749,2,"B","PARAMS",4)

"KRN",8994,1749,2,"B","REGIEN",1)

"KRN",8994,1749,2,"B","RPTCODE",2)

"KRN",8994,1749,2,"B","SCHCODE",5)

"KRN",8994,1749,2,"B","ZTDTH",3)

"KRN",8994,1749,2,"PARAMSEQ",1,2)

"KRN",8994,1749,2,"PARAMSEQ",2,1)

"KRN",8994,1749,2,"PARAMSEQ",3,3)

"KRN",8994,1749,2,"PARAMSEQ",4,5)

"KRN",8994,1749,2,"PARAMSEQ",5,4)

"KRN",8994,1749,3,0)
^8994.03^30^30^3031107^^^^
"KRN",8994,1749,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1749,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1749,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1749,3,4,0)
descriptors returned in the subsequent nodes of the Results array.
"KRN",8994,1749,3,5,0)
 
"KRN",8994,1749,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1749,3,7,0)
                          ^01: The last error code (LASTERR)
"KRN",8994,1749,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1749,3,9,0)
 
"KRN",8994,1749,3,10,0)
 
"KRN",8994,1749,3,11,0)
  Results[i]            Error Descriptor
"KRN",8994,1749,3,12,0)
                          ^01: Error code
"KRN",8994,1749,3,13,0)
                          ^02: Message
"KRN",8994,1749,3,14,0)
                          ^03: Place of the error
"KRN",8994,1749,3,15,0)
 
"KRN",8994,1749,3,16,0)
Error descriptors are returned in reverse chronological order (most recent
"KRN",8994,1749,3,17,0)
error first).                                                 
"KRN",8994,1749,3,18,0)
 
"KRN",8994,1749,3,19,0)
Otherwise, the Results[0] contains number of task descriptors returned in
"KRN",8994,1749,3,20,0)
the Results array (always 1) and number of elements that comprise a task
"KRN",8994,1749,3,21,0)
descriptor:
"KRN",8994,1749,3,22,0)
 
"KRN",8994,1749,3,23,0)
  Results[0]            Result Descriptor
"KRN",8994,1749,3,24,0)
                          ^01: 1
"KRN",8994,1749,3,25,0)
                          ^02: Number of elements that comprise a task
"KRN",8994,1749,3,26,0)
                               descriptor (TIN)
"KRN",8994,1749,3,27,0)
 
"KRN",8994,1749,3,28,0)
The subsequent nodes of the Results array (from 1 to TIN) contain the
"KRN",8994,1749,3,29,0)
information about the scheduled task (see the ROR TASK INFO remote 
"KRN",8994,1749,3,30,0)
procedure for more details).
"KRN",8994,1750,-1)
0^6
"KRN",8994,1750,0)
ROR TASK INFO^TASKINFO^RORRP010^2^R^^^1^1
"KRN",8994,1750,1,0)
^8994.01^2^2^3030220^^^
"KRN",8994,1750,1,1,0)
The ROR TASK INFO remote procedure returns the information about the task
"KRN",8994,1750,1,2,0)
started from the GUI.
"KRN",8994,1750,2,0)
^8994.02A^1^1
"KRN",8994,1750,2,1,0)
TASK^1^^1^1
"KRN",8994,1750,2,1,1,0)
^8994.021^1^1^3030220^^^
"KRN",8994,1750,2,1,1,1,0)
A valid task number should be assigned to the TASK parameter.
"KRN",8994,1750,2,"B","TASK",1)

"KRN",8994,1750,2,"PARAMSEQ",1,1)

"KRN",8994,1750,3,0)
^8994.03^42^42^3030425^^
"KRN",8994,1750,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1750,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1750,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1750,3,4,0)
descriptors returned in the subsequent nodes of the Results array.
"KRN",8994,1750,3,5,0)
 
"KRN",8994,1750,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1750,3,7,0)
                          ^01: The last error code (LASTERR)
"KRN",8994,1750,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1750,3,9,0)
 
"KRN",8994,1750,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1750,3,11,0)
                          ^01: Error code
"KRN",8994,1750,3,12,0)
                          ^02: Message
"KRN",8994,1750,3,13,0)
                          ^03: Place of the error
"KRN",8994,1750,3,14,0)
 
"KRN",8994,1750,3,15,0)
Error descriptors are returned in reverse chronological order (most recent
"KRN",8994,1750,3,16,0)
error first).                                                 
"KRN",8994,1750,3,17,0)
 
"KRN",8994,1750,3,18,0)
Otherwise, the Results[0] contains number of task descriptors returned
"KRN",8994,1750,3,19,0)
in the Results array (always 1) and number of elements that comprise a
"KRN",8994,1750,3,20,0)
task descriptor:
"KRN",8994,1750,3,21,0)
 
"KRN",8994,1750,3,22,0)
  Results[0]            Result Descriptor
"KRN",8994,1750,3,23,0)
                          ^01: 1
"KRN",8994,1750,3,24,0)
                          ^02: Number of elements that comprise a task
"KRN",8994,1750,3,25,0)
                               descriptor (TIN)
"KRN",8994,1750,3,26,0)
 
"KRN",8994,1750,3,27,0)
The subsequent nodes of the Results array (from 1 to TIN) contain the
"KRN",8994,1750,3,28,0)
information about the scheduled task:
"KRN",8994,1750,3,29,0)
 
"KRN",8994,1750,3,30,0)
  Results[1]            Task Number
"KRN",8994,1750,3,31,0)
  Results[2]            Task Type           (internal^external)
"KRN",8994,1750,3,32,0)
  Results[3]            Registry            (IEN^Name)
"KRN",8994,1750,3,33,0)
  Results[4]            Report              (Code^Name)
"KRN",8994,1750,3,34,0)
  Results[5]            Task Description
"KRN",8994,1750,3,35,0)
  Results[6]            Task Status         (internal^external)
"KRN",8994,1750,3,36,0)
  Results[7]            Creation Time       (FileMan)
"KRN",8994,1750,3,37,0)
  Results[8]            User                (DUZ^Name)
"KRN",8994,1750,3,38,0)
  Results[9]            Completion Time     (FileMan)
"KRN",8994,1750,3,39,0)
  Results[10]           Progress Percentage
"KRN",8994,1750,3,40,0)
  Results[11]           Scheduled to Run at (FileMan)
"KRN",8994,1750,3,41,0)
  Results[12]           Task Log IEN
"KRN",8994,1750,3,42,0)
  Results[13]           Job Number
"KRN",8994,1751,-1)
0^7
"KRN",8994,1751,0)
ROR TASK LIST^TASKLIST^RORRP010^4^R^^^1^1
"KRN",8994,1751,1,0)
^^2^2^3030220^
"KRN",8994,1751,1,1,0)
The ROR TASK LIST remote procedure returns a list of user's tasks 
"KRN",8994,1751,1,2,0)
scheduled from the GUI.
"KRN",8994,1751,2,0)
^8994.02A^5^3
"KRN",8994,1751,2,1,0)
REGIEN^1^^^1
"KRN",8994,1751,2,1,1,0)
^^5^5^3030220^
"KRN",8994,1751,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the 
"KRN",8994,1751,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1). 
"KRN",8994,1751,2,1,1,3,0)
 
"KRN",8994,1751,2,1,1,4,0)
The tasks associated with the provided registry will be returned by the 
"KRN",8994,1751,2,1,1,5,0)
procere. By default ($G(REGIEN)'>0), all tasks are returned.
"KRN",8994,1751,2,2,0)
TYPE^1^^^2
"KRN",8994,1751,2,2,1,0)
^^4^4^3030220^
"KRN",8994,1751,2,2,1,1,0)
The TYPE parameter defines which tasks (1-Generic, 2-Report) are returned
"KRN",8994,1751,2,2,1,2,0)
by the procedure. See the description of the TYPE field (.02) of the ROR
"KRN",8994,1751,2,2,1,3,0)
TASK file (#798.8) for more details.  By default ($G(TYPE)'>0), all tasks 
"KRN",8994,1751,2,2,1,4,0)
are retrieved.
"KRN",8994,1751,2,5,0)
USER^1^^^3
"KRN",8994,1751,2,5,1,0)
^^3^3^3030220^
"KRN",8994,1751,2,5,1,1,0)
A user IEN (DUZ) can be assigned to the USER parameter. Only tasks
"KRN",8994,1751,2,5,1,2,0)
scheduled by this user are retrieved by the procedure. By default 
"KRN",8994,1751,2,5,1,3,0)
($G(USER)'>0), it utilizes the current user's DUZ.
"KRN",8994,1751,2,"B","REGIEN",1)

"KRN",8994,1751,2,"B","TYPE",2)

"KRN",8994,1751,2,"B","USER",5)

"KRN",8994,1751,2,"PARAMSEQ",1,1)

"KRN",8994,1751,2,"PARAMSEQ",2,2)

"KRN",8994,1751,2,"PARAMSEQ",3,5)

"KRN",8994,1751,3,0)
^8994.03^49^49^3030425^^
"KRN",8994,1751,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1751,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1751,3,3,0)
case, the second piece of the Results[0] will contain number of the error 
"KRN",8994,1751,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1751,3,5,0)
 
"KRN",8994,1751,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1751,3,7,0)
                          ^01: The last error code
"KRN",8994,1751,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1751,3,9,0)
  
"KRN",8994,1751,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1751,3,11,0)
                          ^01: Error code
"KRN",8994,1751,3,12,0)
                          ^02: Message
"KRN",8994,1751,3,13,0)
                          ^03: Place of the error
"KRN",8994,1751,3,14,0)
 
"KRN",8994,1751,3,15,0)
Otherwise, the task descriptors are returned in the RESULTS array (see the
"KRN",8994,1751,3,16,0)
ROR TASK INFO remote procedure for details).
"KRN",8994,1751,3,17,0)
 
"KRN",8994,1751,3,18,0)
  Results[0]            Result Descriptor
"KRN",8994,1751,3,19,0)
                          ^01: Number of task descriptors returned
"KRN",8994,1751,3,20,0)
                               in the Results array (NTSK)
"KRN",8994,1751,3,21,0)
                          ^02: Number of nodes that make a single
"KRN",8994,1751,3,22,0)
                               task descriptor (TIN)
"KRN",8994,1751,3,23,0)
 
"KRN",8994,1751,3,24,0)
  Results[i]            Value returned by the $$TASKINFO^RORTSK
"KRN",8994,1751,3,25,0)
                        function. You can calculate the subscript
"KRN",8994,1751,3,26,0)
                        of the item TI (from 1 to TIN) of the task
"KRN",8994,1751,3,27,0)
                        TN (from 1 to NTSK) using the following
"KRN",8994,1751,3,28,0)
                        formula: i = (TN-1)*TIN+TI.
"KRN",8994,1751,3,29,0)
 
"KRN",8994,1751,3,30,0)
For example, if number of nodes returned by the $$TASKINFO^RORTSK function
"KRN",8994,1751,3,31,0)
for each task is 13 and the RESULTS array contains information about 3
"KRN",8994,1751,3,32,0)
tasks, the following nodes will be defined:
"KRN",8994,1751,3,33,0)
 
"KRN",8994,1751,3,34,0)
  Results[0]  = "3^13"
"KRN",8994,1751,3,35,0)
 
"KRN",8994,1751,3,36,0)
  Results[1]  = Task Number 1
"KRN",8994,1751,3,37,0)
  Results[2]  = Task Type 1 (internal^external)
"KRN",8994,1751,3,38,0)
  ...
"KRN",8994,1751,3,39,0)
  Results[13] = Job Number 1
"KRN",8994,1751,3,40,0)
 
"KRN",8994,1751,3,41,0)
  Results[14] = Task Number 2
"KRN",8994,1751,3,42,0)
  Results[15] = Task Type 2 (internal^external)
"KRN",8994,1751,3,43,0)
  ...
"KRN",8994,1751,3,44,0)
  Results[26] = Job Number 2
"KRN",8994,1751,3,45,0)
 
"KRN",8994,1751,3,46,0)
  Results[27] = Task Number 3
"KRN",8994,1751,3,47,0)
  Results[28] = Task Type 3 (internal^external)
"KRN",8994,1751,3,48,0)
  ...
"KRN",8994,1751,3,49,0)
  Results[39] = Job Number 3
"KRN",8994,1779,-1)
0^12
"KRN",8994,1779,0)
ROR GUI ACCESS^ACREGLST^RORRP013^2^P^^^1^1
"KRN",8994,1779,1,0)
^8994.01^2^2^3030610^^^^
"KRN",8994,1779,1,1,0)
The ROR ACCESS remote procedure returns a list of registries that the 
"KRN",8994,1779,1,2,0)
user has access to (the user has appropriate security keys).
"KRN",8994,1779,2,0)
^8994.02A^1^1
"KRN",8994,1779,2,1,0)
USER^1^^^1
"KRN",8994,1779,2,1,1,0)
^8994.021^2^2^3030610^^^^
"KRN",8994,1779,2,1,1,1,0)
User IEN in the NEW PERSON file. By default (if $G(USER)'>0), the DUZ is
"KRN",8994,1779,2,1,1,2,0)
used).
"KRN",8994,1779,2,"B","USER",1)

"KRN",8994,1779,2,"PARAMSEQ",1,1)

"KRN",8994,1779,3,0)
^8994.03^29^29^3030610^^
"KRN",8994,1779,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1779,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1779,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1779,3,4,0)
descriptors returned in the subsequent nodes of the Results array.
"KRN",8994,1779,3,5,0)
 
"KRN",8994,1779,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1779,3,7,0)
                          ^01: The last error code (LASTERR)
"KRN",8994,1779,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1779,3,9,0)
     
"KRN",8994,1779,3,10,0)
                                                                      
"KRN",8994,1779,3,11,0)
  Results[i]            Error Descriptor
"KRN",8994,1779,3,12,0)
                          ^01: Error code
"KRN",8994,1779,3,13,0)
                          ^02: Message
"KRN",8994,1779,3,14,0)
                          ^03: Place of the error
"KRN",8994,1779,3,15,0)
                                                                      
"KRN",8994,1779,3,16,0)
Error descriptors are returned in reverse chronological order (most recent
"KRN",8994,1779,3,17,0)
error first).                                                 
"KRN",8994,1779,3,18,0)
 
"KRN",8994,1779,3,19,0)
Otherwise, the Results[0] contains number of the registry descriptors
"KRN",8994,1779,3,20,0)
returned in the subsequent nodes of the Results array. If this value is
"KRN",8994,1779,3,21,0)
equal to zero then the user has no access to any registries.
"KRN",8994,1779,3,22,0)
 
"KRN",8994,1779,3,23,0)
  Results[0]            Number of Accessible Registries
"KRN",8994,1779,3,24,0)
 
"KRN",8994,1779,3,25,0)
  Results[i]            Registry Descriptor
"KRN",8994,1779,3,26,0)
                          ^01: Registry IEN
"KRN",8994,1779,3,27,0)
                          ^02: Registry name
"KRN",8994,1779,3,28,0)
                          ^03: Administrator? (0 or 1)
"KRN",8994,1779,3,29,0)
                          ^04: Registry description
"KRN",8994,1780,-1)
0^5
"KRN",8994,1780,0)
ROR TASK DELETE^DELTASK^RORRP010^1^R^^^^1
"KRN",8994,1780,1,0)
^8994.01^1^1^3031202^^
"KRN",8994,1780,1,1,0)
The ROR TASK DELETE remote procedure completely deletes the task.
"KRN",8994,1780,2,0)
^8994.02A^1^1
"KRN",8994,1780,2,1,0)
TASK^1^^1^1
"KRN",8994,1780,2,1,1,0)
^8994.021^1^1^3031202^^
"KRN",8994,1780,2,1,1,1,0)
A valid task number should be assigned to the TASK parameter.
"KRN",8994,1780,2,"B","TASK",1)

"KRN",8994,1780,2,"PARAMSEQ",1,1)

"KRN",8994,1780,3,0)
^8994.03^15^15^3031202^^
"KRN",8994,1780,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1780,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1780,3,3,0)
case, the second piece of the Results[0] will contain number of the error 
"KRN",8994,1780,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1780,3,5,0)
 
"KRN",8994,1780,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1780,3,7,0)
                          ^01: The last error code
"KRN",8994,1780,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1780,3,9,0)
  
"KRN",8994,1780,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1780,3,11,0)
                          ^01: Error code
"KRN",8994,1780,3,12,0)
                          ^02: Message
"KRN",8994,1780,3,13,0)
                          ^03: Place of the error
"KRN",8994,1780,3,14,0)
 
"KRN",8994,1780,3,15,0)
Otherwise, zero is returned in the Results[0].
"KRN",8994,1781,-1)
0^3
"KRN",8994,1781,0)
ROR LOG GET LIST^LOGLIST^RORRP007^4^R^^^1^1
"KRN",8994,1781,1,0)
^8994.01^2^2^3030320^^^^
"KRN",8994,1781,1,1,0)
The ROR LOG GET LIST remote procedure returns a list of logs associated 
"KRN",8994,1781,1,2,0)
with the registry in the provided time frame.
"KRN",8994,1781,2,0)
^8994.02A^3^3
"KRN",8994,1781,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1781,2,1,1,0)
^8994.021^4^4^3030128^^
"KRN",8994,1781,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1781,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1781,2,1,1,3,0)
The output list will contain log activities associated with the registry
"KRN",8994,1781,2,1,1,4,0)
defined by this parameter.
"KRN",8994,1781,2,2,0)
STDT^1^^^2
"KRN",8994,1781,2,2,1,0)
^8994.021^3^3^3030128^^^
"KRN",8994,1781,2,2,1,1,0)
The STDT parameter defines the start date for the search of the log 
"KRN",8994,1781,2,2,1,2,0)
activities. By default (if $G(STDT)'>0), the search starts from the 
"KRN",8994,1781,2,2,1,3,0)
earliest record of the ROR LOG file.
"KRN",8994,1781,2,3,0)
ENDT^1^^^3
"KRN",8994,1781,2,3,1,0)
^8994.021^3^3^3030228^^^^
"KRN",8994,1781,2,3,1,1,0)
The ENDT parameter defines the end date for the search of the log
"KRN",8994,1781,2,3,1,2,0)
activities. By default (if $G(ENDT)'>0), the search continues to the last
"KRN",8994,1781,2,3,1,3,0)
record of the ROR LOG file.
"KRN",8994,1781,2,"B","ENDT",3)

"KRN",8994,1781,2,"B","REGIEN",1)

"KRN",8994,1781,2,"B","STDT",2)

"KRN",8994,1781,2,"PARAMSEQ",1,1)

"KRN",8994,1781,2,"PARAMSEQ",2,2)

"KRN",8994,1781,2,"PARAMSEQ",3,3)

"KRN",8994,1781,3,0)
^^41^41^3030425^
"KRN",8994,1781,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1781,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1781,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1781,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1781,3,5,0)
  
"KRN",8994,1781,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1781,3,7,0)
                          ^01: The last error code
"KRN",8994,1781,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1781,3,9,0)
                                                                      
"KRN",8994,1781,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1781,3,11,0)
                          ^01: Error code
"KRN",8994,1781,3,12,0)
                          ^02: Message
"KRN",8994,1781,3,13,0)
                          ^03: Place of the error
"KRN",8994,1781,3,14,0)
 
"KRN",8994,1781,3,15,0)
Otherwise, the number of logs is returned in the Results[0] and the
"KRN",8994,1781,3,16,0)
subsequent nodes of the Results array contain the information extracted
"KRN",8994,1781,3,17,0)
from the ROR LOG file:
"KRN",8994,1781,3,18,0)
 
"KRN",8994,1781,3,19,0)
  Results[0]            Number of Logs
"KRN",8994,1781,3,20,0)
 
"KRN",8994,1781,3,21,0)
  Results[i]            Log Descriptor
"KRN",8994,1781,3,22,0)
                          ^01: "L"
"KRN",8994,1781,3,23,0)
                          ^02: Log IEN
"KRN",8994,1781,3,24,0)
                          ^03: Activity (ext)
"KRN",8994,1781,3,25,0)
                          ^04: Activity (int)
"KRN",8994,1781,3,26,0)
                          ^05: Start Date/Time (ext)
"KRN",8994,1781,3,27,0)
                          ^06: Contains messages (0/1)
"KRN",8994,1781,3,28,0)
                          ^07: Job Number
"KRN",8994,1781,3,29,0)
                          ^08: End Date/Time (ext)
"KRN",8994,1781,3,30,0)
                          ^09: Number of Processed Patients
"KRN",8994,1781,3,31,0)
                          ^10: Number of Patients with Errors
"KRN",8994,1781,3,32,0)
                          ^11: Processing Rate
"KRN",8994,1781,3,33,0)
 
"KRN",8994,1781,3,34,0)
  Results[...]          Registry Descriptor (optional)
"KRN",8994,1781,3,35,0)
                          ^01: "R"
"KRN",8994,1781,3,36,0)
                          ^02: Registry IEN
"KRN",8994,1781,3,37,0)
                          ^03: Registry Name
"KRN",8994,1781,3,38,0)
 
"KRN",8994,1781,3,39,0)
  Results[i+n]          'End of Log' Marker
"KRN",8994,1781,3,40,0)
                          ^01: "L"
"KRN",8994,1781,3,41,0)
                          ^02: "END"
"KRN",8994,1783,-1)
0^4
"KRN",8994,1783,0)
ROR LOG GET MESSAGES^MSGLIST^RORRP007^4^R^^^1^1
"KRN",8994,1783,1,0)
^8994.01^2^2^3030228^^^
"KRN",8994,1783,1,1,0)
The ROR LOG GET MESSAGES remote procedure returns a list of messages from
"KRN",8994,1783,1,2,0)
the log defined by the parameter.
"KRN",8994,1783,2,0)
^8994.02A^2^1
"KRN",8994,1783,2,2,0)
LOGIEN^1^^1^1
"KRN",8994,1783,2,2,1,0)
^^2^2^3030228^
"KRN",8994,1783,2,2,1,1,0)
The LOGIEN parameter defines the log. It should contain a valid IEN of the
"KRN",8994,1783,2,2,1,2,0)
log record in the ROR LOG file.
"KRN",8994,1783,2,"B","LOGIEN",2)

"KRN",8994,1783,2,"PARAMSEQ",1,2)

"KRN",8994,1783,3,0)
^^40^40^3030425^
"KRN",8994,1783,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1783,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1783,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1783,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1783,3,5,0)
   
"KRN",8994,1783,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1783,3,7,0)
                          ^01: The last error code
"KRN",8994,1783,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1783,3,9,0)
                                                                       
"KRN",8994,1783,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1783,3,11,0)
                          ^01: Error code
"KRN",8994,1783,3,12,0)
                          ^02: Message
"KRN",8994,1783,3,13,0)
                          ^03: Place of the error
"KRN",8994,1783,3,14,0)
 
"KRN",8994,1783,3,15,0)
Otherwise, the number of messages is returned in the Results[0] and the
"KRN",8994,1783,3,16,0)
subsequent nodes of the Results array contain the messages:
"KRN",8994,1783,3,17,0)
 
"KRN",8994,1783,3,18,0)
  Results[0]            Number of Messages
"KRN",8994,1783,3,19,0)
 
"KRN",8994,1783,3,20,0)
  Results[i]            Message Descriptor
"KRN",8994,1783,3,21,0)
                          ^01: "M"
"KRN",8994,1783,3,22,0)
                          ^02: Message IENS
"KRN",8994,1783,3,23,0)
                          ^03: Type (external)
"KRN",8994,1783,3,24,0)
                          ^04: Type (internal)
"KRN",8994,1783,3,25,0)
                          ^05: Date/Time (external)
"KRN",8994,1783,3,26,0)
                          ^06: Has Additional Info (0/1)
"KRN",8994,1783,3,27,0)
                          ^07: Patient Name
"KRN",8994,1783,3,28,0)
                          ^08: Patient IEN (DFN)
"KRN",8994,1783,3,29,0)
 
"KRN",8994,1783,3,30,0)
  Results[i+1]          Message
"KRN",8994,1783,3,31,0)
                          ^01: "T"
"KRN",8994,1783,3,32,0)
                          ^02: Message Text
"KRN",8994,1783,3,33,0)
 
"KRN",8994,1783,3,34,0)
  Results[...]          Line of the ADDITIONAL INFO Text
"KRN",8994,1783,3,35,0)
                          ^01: "A"
"KRN",8994,1783,3,36,0)
                          ^02: Text
"KRN",8994,1783,3,37,0)
                          
"KRN",8994,1783,3,38,0)
  Results[i+n]          'End of Message' Marker
"KRN",8994,1783,3,39,0)
                          ^01: "M"
"KRN",8994,1783,3,40,0)
                          ^02: "END"
"KRN",8994,1784,-1)
0^10
"KRN",8994,1784,0)
ROR GUI PARAMETER GET^GETPARM^RORRP012^2^R^^^1^1
"KRN",8994,1784,1,0)
^8994.01^2^2^3030225^^^
"KRN",8994,1784,1,1,0)
The ROR GUI PARAMETER GET remote procedure retrieves the value of the GUI
"KRN",8994,1784,1,2,0)
parameter.
"KRN",8994,1784,2,0)
^8994.02A^2^2
"KRN",8994,1784,2,1,0)
NAME^1^30^1^1
"KRN",8994,1784,2,1,1,0)
^^1^1^3030129^
"KRN",8994,1784,2,1,1,1,0)
The NAME parameter defines the name of the GUI parameter.
"KRN",8994,1784,2,2,0)
ENTITY^1^30^^2
"KRN",8994,1784,2,2,1,0)
^8994.021^4^4^3030225^^^
"KRN",8994,1784,2,2,1,1,0)
The ENTITY parameter defines the area(s) where the parameter value is
"KRN",8994,1784,2,2,1,2,0)
searched for. By default ($G(ENTITY)=""), the "ALL" value is used (see the
"KRN",8994,1784,2,2,1,3,0)
DBIA #2263 for more details). The other values that are used most often
"KRN",8994,1784,2,2,1,4,0)
are the "USR" (user settings) and the "PKG" (package settings).
"KRN",8994,1784,2,"B","ENTITY",2)

"KRN",8994,1784,2,"B","NAME",1)

"KRN",8994,1784,2,"PARAMSEQ",1,1)

"KRN",8994,1784,2,"PARAMSEQ",2,2)

"KRN",8994,1784,3,0)
^^23^23^3030425^
"KRN",8994,1784,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1784,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1784,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1784,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1784,3,5,0)
   
"KRN",8994,1784,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1784,3,7,0)
                          ^01: The last error code
"KRN",8994,1784,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1784,3,9,0)
                                                                       
"KRN",8994,1784,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1784,3,11,0)
                          ^01: Error code
"KRN",8994,1784,3,12,0)
                          ^02: Message
"KRN",8994,1784,3,13,0)
                          ^03: Place of the error
"KRN",8994,1784,3,14,0)
 
"KRN",8994,1784,3,15,0)
Otherwise, the Results[0] contains 0 and the subsequent node(s) of the
"KRN",8994,1784,3,16,0)
Results array contain the string(s) of parameter value:
"KRN",8994,1784,3,17,0)
 
"KRN",8994,1784,3,18,0)
  Results[0]            0
"KRN",8994,1784,3,19,0)
 
"KRN",8994,1784,3,20,0)
  Results[1]            Value of the single-line parameter or
"KRN",8994,1784,3,21,0)
                        the first line of the text value
"KRN",8994,1784,3,22,0)
 
"KRN",8994,1784,3,23,0)
  Results[...]          Subsequent lines of the text value
"KRN",8994,1785,-1)
0^11
"KRN",8994,1785,0)
ROR GUI PARAMETER SET^SETPARM^RORRP012^1^R^^^^1
"KRN",8994,1785,1,0)
^8994.01^3^3^3030220^^^^
"KRN",8994,1785,1,1,0)
The ROR GUI PARAMETER SET remote procedure stores the parameter value and
"KRN",8994,1785,1,2,0)
associates it with the provided entity (see the DBIA #2263 for more 
"KRN",8994,1785,1,3,0)
details).
"KRN",8994,1785,2,0)
^8994.02A^3^3
"KRN",8994,1785,2,1,0)
NAME^1^30^1^1
"KRN",8994,1785,2,1,1,0)
^^1^1^3030129^
"KRN",8994,1785,2,1,1,1,0)
The NAME parameter defines the name of the GUI parameter.
"KRN",8994,1785,2,2,0)
ENTITY^1^30^^2
"KRN",8994,1785,2,2,1,0)
^^4^4^3030129^
"KRN",8994,1785,2,2,1,1,0)
The ENTITY parameter defines the context that the parameter value is
"KRN",8994,1785,2,2,1,2,0)
associated with. By default ($G(ENTITY)=""), the "USR" (user settings)
"KRN",8994,1785,2,2,1,3,0)
value is used (see the DBIA #2263 for more details). The other value that
"KRN",8994,1785,2,2,1,4,0)
is used most often is the "PKG" (package settings).
"KRN",8994,1785,2,3,0)
VALUE^2^^^3
"KRN",8994,1785,2,3,1,0)
^8994.021^25^25^3030220^^
"KRN",8994,1785,2,3,1,1,0)
The VALUE parameter defines the value of the GUI parameter. It should be
"KRN",8994,1785,2,3,1,2,0)
either a literal (string value) or a list (text value). You can use the 
"KRN",8994,1785,2,3,1,3,0)
"@" value to delete the parameter.
"KRN",8994,1785,2,3,1,4,0)
 
"KRN",8994,1785,2,3,1,5,0)
 NOTE: The list (the Mult property) should not contain
"KRN",8994,1785,2,3,1,6,0)
       the 0 subscript (it will not be stored).
"KRN",8994,1785,2,3,1,7,0)
 
"KRN",8994,1785,2,3,1,8,0)
Example #1 (string value):
"KRN",8994,1785,2,3,1,9,0)
 
"KRN",8994,1785,2,3,1,10,0)
  RPCBroker.Param[0].Value := 'MAIN FORM POS';
"KRN",8994,1785,2,3,1,11,0)
  RPCBroker.Param[0].PType := literal;
"KRN",8994,1785,2,3,1,12,0)
  RPCBroker.Param[1].Value := '';
"KRN",8994,1785,2,3,1,13,0)
  RPCBroker.Param[1].PType := literal;
"KRN",8994,1785,2,3,1,14,0)
  RPCBroker.Param[2].Value := '5,5,400,250';
"KRN",8994,1785,2,3,1,15,0)
  RPCBroker.Param[2].PType := literal;
"KRN",8994,1785,2,3,1,16,0)
 
"KRN",8994,1785,2,3,1,17,0)
Example #2 (text value):
"KRN",8994,1785,2,3,1,18,0)
 
"KRN",8994,1785,2,3,1,19,0)
  RPCBroker.Param[0].Value := 'COM PORT SETTINGS';
"KRN",8994,1785,2,3,1,20,0)
  RPCBroker.Param[0].PType := literal;
"KRN",8994,1785,2,3,1,21,0)
  RPCBroker.Param[1].Value := 'PKG';
"KRN",8994,1785,2,3,1,22,0)
  RPCBroker.Param[1].PType := literal;
"KRN",8994,1785,2,3,1,23,0)
  RPCBroker.Param[2].Mult[1] := 'Port=COM1';
"KRN",8994,1785,2,3,1,24,0)
  RPCBroker.Param[2].Mult[2] := 'Baud=19200';
"KRN",8994,1785,2,3,1,25,0)
  RPCBroker.Param[2].PType := list;
"KRN",8994,1785,2,"B","ENTITY",2)

"KRN",8994,1785,2,"B","NAME",1)

"KRN",8994,1785,2,"B","VALUE",3)

"KRN",8994,1785,2,"PARAMSEQ",1,1)

"KRN",8994,1785,2,"PARAMSEQ",2,2)

"KRN",8994,1785,2,"PARAMSEQ",3,3)

"KRN",8994,1785,3,0)
^^15^15^3030425^
"KRN",8994,1785,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1785,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1785,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1785,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1785,3,5,0)
   
"KRN",8994,1785,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1785,3,7,0)
                          ^01: The last error code
"KRN",8994,1785,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1785,3,9,0)
                                                                       
"KRN",8994,1785,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1785,3,11,0)
                          ^01: Error code
"KRN",8994,1785,3,12,0)
                          ^02: Message
"KRN",8994,1785,3,13,0)
                          ^03: Place of the error
"KRN",8994,1785,3,14,0)
 
"KRN",8994,1785,3,15,0)
Otherwise, the Results[0] contains 0.
"KRN",8994,1786,-1)
0^2
"KRN",8994,1786,0)
ROR LOG GET ACCESS VIOLATIONS^AVLIST^RORRP013^4^A^^^1^1
"KRN",8994,1786,1,0)
^8994.01^2^2^3030220^^^^
"KRN",8994,1786,1,1,0)
The ROR LOG GET ACCESS VIOLATIONS remote procedure returns the list of
"KRN",8994,1786,1,2,0)
access violation events recorded in the provided time frame.
"KRN",8994,1786,2,0)
^8994.02A^3^2
"KRN",8994,1786,2,2,0)
STDT^1^^^1
"KRN",8994,1786,2,2,1,0)
^^3^3^3030130^
"KRN",8994,1786,2,2,1,1,0)
The STDT parameter defines the start date for the search of the events. By
"KRN",8994,1786,2,2,1,2,0)
default (if $G(STDT)'>0), the search starts from the earliest record of
"KRN",8994,1786,2,2,1,3,0)
the ROR LOG file.
"KRN",8994,1786,2,3,0)
ENDT^1^^^2
"KRN",8994,1786,2,3,1,0)
^8994.021^3^3^3030220^^^^
"KRN",8994,1786,2,3,1,1,0)
The ENDT parameter defines the end date for the search of the events. By
"KRN",8994,1786,2,3,1,2,0)
default (if $G(ENDT)'>0), the search continues to the last record of the
"KRN",8994,1786,2,3,1,3,0)
ROR LOG file.
"KRN",8994,1786,2,"B","ENDT",3)

"KRN",8994,1786,2,"B","STDT",2)

"KRN",8994,1786,2,"PARAMSEQ",1,2)

"KRN",8994,1786,2,"PARAMSEQ",2,3)

"KRN",8994,1786,3,0)
^^24^24^3030425^
"KRN",8994,1786,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1786,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1786,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1786,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1786,3,5,0)
    
"KRN",8994,1786,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1786,3,7,0)
                          ^01: The last error code
"KRN",8994,1786,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1786,3,9,0)
                                                                       
"KRN",8994,1786,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1786,3,11,0)
                          ^01: Error code
"KRN",8994,1786,3,12,0)
                          ^02: Message
"KRN",8994,1786,3,13,0)
                          ^03: Place of the error
"KRN",8994,1786,3,14,0)
  
"KRN",8994,1786,3,15,0)
Otherwise, the Results[0] contains number of access violation events and
"KRN",8994,1786,3,16,0)
the subsequent node(s) of the Results array contain the event descriptors:
"KRN",8994,1786,3,17,0)
 
"KRN",8994,1786,3,18,0)
  Results[0]            Number of Access Violations
"KRN",8994,1786,3,19,0)
 
"KRN",8994,1786,3,20,0)
  Results[i]            Access Violation Descriptor
"KRN",8994,1786,3,21,0)
                          ^01: Date/Time (internal)
"KRN",8994,1786,3,22,0)
                          ^02: User Name
"KRN",8994,1786,3,23,0)
                          ^03: User IEN
"KRN",8994,1786,3,24,0)
                          ^04: Message
"KRN",8994,1787,-1)
0^29
"KRN",8994,1787,0)
ROR LIST REGISTRY USERS^USERLIST^RORRP013^4^P^^^1^1
"KRN",8994,1787,1,0)
^8994.01^2^2^3030219^^^
"KRN",8994,1787,1,1,0)
The ROR GET REGISTRY USERS remote procedure returns the list of registry 
"KRN",8994,1787,1,2,0)
users (VistA users who have the appropriate security keys).
"KRN",8994,1787,2,0)
^8994.02A^1^1
"KRN",8994,1787,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1787,2,1,1,0)
^8994.021^2^2^3030219^^^
"KRN",8994,1787,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1787,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1787,2,"B","REGIEN",1)

"KRN",8994,1787,2,"PARAMSEQ",1,1)

"KRN",8994,1787,3,0)
^^25^25^3030425^
"KRN",8994,1787,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1787,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1787,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1787,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1787,3,5,0)
   
"KRN",8994,1787,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1787,3,7,0)
                          ^01: The last error code
"KRN",8994,1787,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1787,3,9,0)
                                                                       
"KRN",8994,1787,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1787,3,11,0)
                          ^01: Error code
"KRN",8994,1787,3,12,0)
                          ^02: Message
"KRN",8994,1787,3,13,0)
                          ^03: Place of the error
"KRN",8994,1787,3,14,0)
 
"KRN",8994,1787,3,15,0)
Otherwise, the number of users is returned in the Results[0] and the
"KRN",8994,1787,3,16,0)
subsequent nodes of the Results array contain the user descriptors:
"KRN",8994,1787,3,17,0)
 
"KRN",8994,1787,3,18,0)
  Results[0]            Number of Users
"KRN",8994,1787,3,19,0)
 
"KRN",8994,1787,3,20,0)
  Results[i]            User Descriptor
"KRN",8994,1787,3,21,0)
                          ^01: User IEN (DUZ)
"KRN",8994,1787,3,22,0)
                          ^02: User Name
"KRN",8994,1787,3,23,0)
                          ^03: User          (0/1)
"KRN",8994,1787,3,24,0)
                          ^04: Administrator (0/1)
"KRN",8994,1787,3,25,0)
                          ^05: IRM           (0/1)
"KRN",8994,1788,-1)
0^8
"KRN",8994,1788,0)
ROR GET REGISTRY INFO^REGINFO^RORRP014^2^P^^^1^1
"KRN",8994,1788,1,0)
^8994.01^2^2^3030425^^
"KRN",8994,1788,1,1,0)
The ROR GET REGISTRY INFO remote procedure returns basic information about
"KRN",8994,1788,1,2,0)
the registry.
"KRN",8994,1788,2,0)
^8994.02A^1^1
"KRN",8994,1788,2,1,0)
REGISTRY^1^^1^1
"KRN",8994,1788,2,1,1,0)
^8994.021^2^2^3030425^^^^
"KRN",8994,1788,2,1,1,1,0)
The REGISTRY parameter should contain either a registry IEN or a registry 
"KRN",8994,1788,2,1,1,2,0)
name.
"KRN",8994,1788,2,"B","REGISTRY",1)

"KRN",8994,1788,2,"PARAMSEQ",1,1)

"KRN",8994,1788,3,0)
^^47^47^3030425^
"KRN",8994,1788,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1788,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1788,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1788,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1788,3,5,0)
 
"KRN",8994,1788,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1788,3,7,0)
                          ^01: The last error code
"KRN",8994,1788,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1788,3,9,0)
 
"KRN",8994,1788,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1788,3,11,0)
                          ^01: Error code
"KRN",8994,1788,3,12,0)
                          ^02: Message
"KRN",8994,1788,3,13,0)
                          ^03: Place of the error
"KRN",8994,1788,3,14,0)
 
"KRN",8994,1788,3,15,0)
Otherwise, zero is returned in the Results[0] and the subsequent nodes of 
"KRN",8994,1788,3,16,0)
the Results array contain the registry information:
"KRN",8994,1788,3,17,0)
 
"KRN",8994,1788,3,18,0)
  Results[0]            0
"KRN",8994,1788,3,19,0)
 
"KRN",8994,1788,3,20,0)
  Results[1]            Registry
"KRN",8994,1788,3,21,0)
                          ^01: IEN
"KRN",8994,1788,3,22,0)
                          ^02: Name
"KRN",8994,1788,3,23,0)
 
"KRN",8994,1788,3,24,0)
  Results[2]            National (0/1)
"KRN",8994,1788,3,25,0)
 
"KRN",8994,1788,3,26,0)
  Results[3]            Registry Description
"KRN",8994,1788,3,27,0)
 
"KRN",8994,1788,3,28,0)
  Results[4]            Last Registry Update Date (FileMan)
"KRN",8994,1788,3,29,0)
 
"KRN",8994,1788,3,30,0)
  Results[5]            Last Data Extraction Date (FileMan)
"KRN",8994,1788,3,31,0)
 
"KRN",8994,1788,3,32,0)
  Results[6]            Number of Patients
"KRN",8994,1788,3,33,0)
 
"KRN",8994,1788,3,34,0)
  Results[7]            Number of Active Patients
"KRN",8994,1788,3,35,0)
 
"KRN",8994,1788,3,36,0)
  Results[8]            Registry Status
"KRN",8994,1788,3,37,0)
                          ^01: Internal value (0-Active, 1-Inactive)
"KRN",8994,1788,3,38,0)
                          ^02: External value
"KRN",8994,1788,3,39,0)
 
"KRN",8994,1788,3,40,0)
  Results[9]            Awaiting Acknowledgement
"KRN",8994,1788,3,41,0)
                          ^01: Date/Time (FileMan)
"KRN",8994,1788,3,42,0)
                          ^02: Message ID
"KRN",8994,1788,3,43,0)
 
"KRN",8994,1788,3,44,0)
  Results[10]           Version Information
"KRN",8994,1788,3,45,0)
                          ^01: Package version
"KRN",8994,1788,3,46,0)
                          ^02: Latest patch number
"KRN",8994,1788,3,47,0)
                          ^03: Date of the latest patch (FileMan)
"KRN",8994,1789,-1)
0^15
"KRN",8994,1789,0)
ROR REPORTS AVAILABLE^RPAVAIL^RORRP011^2^R^^^1^1
"KRN",8994,1789,1,0)
^8994.01^2^2^3031103^^^^
"KRN",8994,1789,1,1,0)
The ROR REPORTS AVAILABLE remote procedure returns a list of reports (and 
"KRN",8994,1789,1,2,0)
their parameters) available for the registry.
"KRN",8994,1789,2,0)
^8994.02A^1^1
"KRN",8994,1789,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1789,2,1,1,0)
^8994.021^4^4^3031103^^^^
"KRN",8994,1789,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1789,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1789,2,1,1,3,0)
The output list will contain reports available for the registry defined by
"KRN",8994,1789,2,1,1,4,0)
this parameter.
"KRN",8994,1789,2,"B","REGIEN",1)

"KRN",8994,1789,2,"PARAMSEQ",1,1)

"KRN",8994,1789,3,0)
^^45^45^3031103^
"KRN",8994,1789,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1789,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1789,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1789,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1789,3,5,0)
   
"KRN",8994,1789,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1789,3,7,0)
                          ^01: The last error code
"KRN",8994,1789,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1789,3,9,0)
                                                                       
"KRN",8994,1789,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1789,3,11,0)
                          ^01: Error code
"KRN",8994,1789,3,12,0)
                          ^02: Message
"KRN",8994,1789,3,13,0)
                          ^03: Place of the error
"KRN",8994,1789,3,14,0)
 
"KRN",8994,1789,3,15,0)
Otherwise, number of reports and number of nodes in each report descriptor
"KRN",8994,1789,3,16,0)
are returned in the Results[0] and the subsequent nodes of the Results
"KRN",8994,1789,3,17,0)
array contain the report parameters extracted from the ROR REPORT
"KRN",8994,1789,3,18,0)
PARAMETERS file (#799.12).
"KRN",8994,1789,3,19,0)
 
"KRN",8994,1789,3,20,0)
  Results[0]            Result Descriptor
"KRN",8994,1789,3,21,0)
                          ^01: Number of report descriptors returned
"KRN",8994,1789,3,22,0)
                               in the Results array (NREP)
"KRN",8994,1789,3,23,0)
                          ^02: Number of nodes that make a single
"KRN",8994,1789,3,24,0)
                               report descriptor (RPN)
"KRN",8994,1789,3,25,0)
 
"KRN",8994,1789,3,26,0)
  Results[1]            Report Name
"KRN",8994,1789,3,27,0)
  Results[2]            Background Processing (0/1)
"KRN",8994,1789,3,28,0)
  Results[3]            reserved
"KRN",8994,1789,3,29,0)
  Results[4]            Report Code
"KRN",8994,1789,3,30,0)
  Results[5]            Report Parameters IEN
"KRN",8994,1789,3,31,0)
  Results[6]            Inactivation Date (FileMan)
"KRN",8994,1789,3,32,0)
  Results[7]            National (0/1)
"KRN",8994,1789,3,33,0)
  Results[8]            List of parameter panels
"KRN",8994,1789,3,34,0)
  Results[9]            Report Builder ($$TAG^ROUTINE)
"KRN",8994,1789,3,35,0)
  Results[10]           Default parameters (NAME=VALUE),
"KRN",8994,1789,3,36,0)
                        separated by '<*>'
"KRN",8994,1789,3,37,0)
  Results[11]           Default sorting modes (TABLE=FIELD),
"KRN",8994,1789,3,38,0)
                        separated by '<*>'
"KRN",8994,1789,3,39,0)
                        
"KRN",8994,1789,3,40,0)
  Results[12]           Report Name
"KRN",8994,1789,3,41,0)
  Results[13]           Background Processing (0/1)
"KRN",8994,1789,3,42,0)
  ...
"KRN",8994,1789,3,43,0)
 
"KRN",8994,1789,3,44,0)
You can calculate the subscript of the item RI (from 1 to RPN) of the
"KRN",8994,1789,3,45,0)
report RN (from 1 to NREP) using the following formula: i = (RN-1)*RPN+RI.
"KRN",8994,1793,-1)
0^16
"KRN",8994,1793,0)
ROR LIST DIVISIONS^DIVLIST^RORRP015^4^R^^^1^1
"KRN",8994,1793,1,0)
^8994.01^2^2^3030226^^^
"KRN",8994,1793,1,1,0)
The ROR LIST DIVISIONS remote procedure returns a list of divisions 
"KRN",8994,1793,1,2,0)
defined in the MEDICAL CENTER DIVISION file (#40.8).
"KRN",8994,1793,2,0)
^8994.02A^4^4
"KRN",8994,1793,2,1,0)
PART^1^30^^1
"KRN",8994,1793,2,1,1,0)
^^1^1^3030225^
"KRN",8994,1793,2,1,1,1,0)
The partial match restriction.
"KRN",8994,1793,2,2,0)
FLAGS^1^^^2
"KRN",8994,1793,2,2,1,0)
^^4^4^3030225^
"KRN",8994,1793,2,2,1,1,0)
Flags that control the execution (can be combined):
"KRN",8994,1793,2,2,1,2,0)
 
"KRN",8994,1793,2,2,1,3,0)
  B  Backwards. Traverses the index in the opposite
"KRN",8994,1793,2,2,1,4,0)
     direction of normal traversal.
"KRN",8994,1793,2,3,0)
NUMBER^1^^^3
"KRN",8994,1793,2,3,1,0)
^^2^2^3030225^
"KRN",8994,1793,2,3,1,1,0)
Maximum number of entries to return. A value of "*" or no value in this 
"KRN",8994,1793,2,3,1,2,0)
parameter designates all entries.
"KRN",8994,1793,2,4,0)
FROM^1^^^4
"KRN",8994,1793,2,4,1,0)
^^13^13^3030226^
"KRN",8994,1793,2,4,1,1,0)
The index entry(s) from which to begin the list
"KRN",8994,1793,2,4,1,2,0)
  ^01: FromName
"KRN",8994,1793,2,4,1,3,0)
  ^02: FromIEN
"KRN",8994,1793,2,4,1,4,0)
 
"KRN",8994,1793,2,4,1,5,0)
For example, a FROM value of "VA" would list entries following VA. You can
"KRN",8994,1793,2,4,1,6,0)
use the 2-nd and 3-rd "^"- pieces of the @RESULTS@(0) node to continue the
"KRN",8994,1793,2,4,1,7,0)
listing in the subsequent procedure calls.
"KRN",8994,1793,2,4,1,8,0)
 
"KRN",8994,1793,2,4,1,9,0)
NOTE: The FROM value itself is not included in the
"KRN",8994,1793,2,4,1,10,0)
      resulting list.
"KRN",8994,1793,2,4,1,11,0)
 
"KRN",8994,1793,2,4,1,12,0)
See description of the LIST^DIC for more details about the PART, NUMBER
"KRN",8994,1793,2,4,1,13,0)
and FROM parameters.
"KRN",8994,1793,2,"B","FLAGS",2)

"KRN",8994,1793,2,"B","FROM",4)

"KRN",8994,1793,2,"B","NUMBER",3)

"KRN",8994,1793,2,"B","PART",1)

"KRN",8994,1793,2,"PARAMSEQ",1,1)

"KRN",8994,1793,2,"PARAMSEQ",2,2)

"KRN",8994,1793,2,"PARAMSEQ",3,3)

"KRN",8994,1793,2,"PARAMSEQ",4,4)

"KRN",8994,1793,3,0)
^^53^53^3030425^
"KRN",8994,1793,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1793,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1793,3,3,0)
case, the second piece of the Results[0] will contain number of the error 
"KRN",8994,1793,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1793,3,5,0)
  
"KRN",8994,1793,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1793,3,7,0)
                          ^01: The last error code
"KRN",8994,1793,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1793,3,9,0)
   
"KRN",8994,1793,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1793,3,11,0)
                          ^01: Error code
"KRN",8994,1793,3,12,0)
                          ^02: Message
"KRN",8994,1793,3,13,0)
                          ^03: Place of the error
"KRN",8994,1793,3,14,0)
 
"KRN",8994,1793,3,15,0)
Otherwise, number of divisions and the value of the FROM parameter for the
"KRN",8994,1793,3,16,0)
next procedure call are returned in the Results[0] and the subsequent
"KRN",8994,1793,3,17,0)
nodes of the global array contain the divisions.
"KRN",8994,1793,3,18,0)
 
"KRN",8994,1793,3,19,0)
  Results[0]          Result Descriptor
"KRN",8994,1793,3,20,0)
                        ^01: Number of divisions
"KRN",8994,1793,3,21,0)
                        ^02: FromName
"KRN",8994,1793,3,22,0)
                        ^03: FromIEN
"KRN",8994,1793,3,23,0)
 
"KRN",8994,1793,3,24,0)
  Results[i]          Division
"KRN",8994,1793,3,25,0)
                        ^01: IEN
"KRN",8994,1793,3,26,0)
                        ^02: Name
"KRN",8994,1793,3,27,0)
                        ^03: Facility Number
"KRN",8994,1793,3,28,0)
                        ^04: Institution IEN
"KRN",8994,1793,3,29,0)
 
"KRN",8994,1793,3,30,0)
Example:
"KRN",8994,1793,3,31,0)
 
"KRN",8994,1793,3,32,0)
  // Get the list of divisions (10 items at a time), which
"KRN",8994,1793,3,33,0)
  // names start with the 'S'
"KRN",8994,1793,3,34,0)
 
"KRN",8994,1793,3,35,0)
  repeat
"KRN",8994,1793,3,36,0)
    with RPCBroker do
"KRN",8994,1793,3,37,0)
      begin
"KRN",8994,1793,3,38,0)
        Param[0].Value := 'S';
"KRN",8994,1793,3,39,0)
        Param[0].PType := literal;
"KRN",8994,1793,3,40,0)
        Param[1].Value := '';
"KRN",8994,1793,3,41,0)
        Param[1].PType := literal;
"KRN",8994,1793,3,42,0)
        Param[2].Value := '10';
"KRN",8994,1793,3,43,0)
        Param[2].PType := literal;
"KRN",8994,1793,3,44,0)
        Param[3].Value := Piece(Results[0],'^',2,3);
"KRN",8994,1793,3,45,0)
        Param[3].PType := literal;
"KRN",8994,1793,3,46,0)
        Call;
"KRN",8994,1793,3,47,0)
      end;
"KRN",8994,1793,3,48,0)
 
"KRN",8994,1793,3,49,0)
    n := StrToIntDef(Piece(Results[0],'^'), 0);
"KRN",8994,1793,3,50,0)
    for i:=1 to n do
"KRN",8994,1793,3,51,0)
      // Process the division record (Results[i])
"KRN",8994,1793,3,52,0)
      ...
"KRN",8994,1793,3,53,0)
  until Piece(Results[0],'^',2) = '';
"KRN",8994,1794,-1)
0^17
"KRN",8994,1794,0)
ROR LIST HOSPITAL LOCATIONS^HLOCLIST^RORRP015^4^R^^^1^1
"KRN",8994,1794,1,0)
^8994.01^3^3^3030226^^
"KRN",8994,1794,1,1,0)
The ROR LIST HOSPITAL LOCATIONS remote procedure returns a list of 
"KRN",8994,1794,1,2,0)
hospital locations (defined in the HOSPITAL LOCATION file), which conform
"KRN",8994,1794,1,3,0)
the criteria.
"KRN",8994,1794,2,0)
^8994.02A^6^6
"KRN",8994,1794,2,1,0)
PART^1^30^^3
"KRN",8994,1794,2,1,1,0)
^8994.021^1^1^3030226^^
"KRN",8994,1794,2,1,1,1,0)
The partial match restriction.
"KRN",8994,1794,2,2,0)
FLAGS^1^^^4
"KRN",8994,1794,2,2,1,0)
^^8^8^3030226^
"KRN",8994,1794,2,2,1,1,0)
Flags that control the execution (can be combined):
"KRN",8994,1794,2,2,1,2,0)
 
"KRN",8994,1794,2,2,1,3,0)
  A  Include active locations (default)
"KRN",8994,1794,2,2,1,4,0)
 
"KRN",8994,1794,2,2,1,5,0)
  B  Backwards. Traverses the index in the opposite
"KRN",8994,1794,2,2,1,6,0)
     direction of normal traversal.
"KRN",8994,1794,2,2,1,7,0)
 
"KRN",8994,1794,2,2,1,8,0)
  I  Include inactive locations
"KRN",8994,1794,2,3,0)
NUMBER^1^^^5
"KRN",8994,1794,2,3,1,0)
^8994.021^2^2^3030226^^
"KRN",8994,1794,2,3,1,1,0)
Maximum number of entries to return. A value of "*" or no value in this 
"KRN",8994,1794,2,3,1,2,0)
parameter designates all entries.
"KRN",8994,1794,2,4,0)
FROM^1^^^6
"KRN",8994,1794,2,4,1,0)
^^13^13^3030226^
"KRN",8994,1794,2,4,1,1,0)
The index entry(s) from which to begin the list
"KRN",8994,1794,2,4,1,2,0)
  ^01: FromName
"KRN",8994,1794,2,4,1,3,0)
  ^02: FromIEN
"KRN",8994,1794,2,4,1,4,0)
 
"KRN",8994,1794,2,4,1,5,0)
For example, a FROM value of "VA" would list entries following VA. You can
"KRN",8994,1794,2,4,1,6,0)
use the 2-nd and 3-rd "^"- pieces of the @RESULTS@(0) node to continue the
"KRN",8994,1794,2,4,1,7,0)
listing in the subsequent procedure calls.
"KRN",8994,1794,2,4,1,8,0)
 
"KRN",8994,1794,2,4,1,9,0)
NOTE: The FROM value itself is not included in the
"KRN",8994,1794,2,4,1,10,0)
      resulting list.
"KRN",8994,1794,2,4,1,11,0)
 
"KRN",8994,1794,2,4,1,12,0)
See description of the LIST^DIC for more details about the PART, NUMBER
"KRN",8994,1794,2,4,1,13,0)
and FROM parameters.
"KRN",8994,1794,2,5,0)
HLTYPES^1^^^1
"KRN",8994,1794,2,5,1,0)
^8994.021^14^14^3030226^^
"KRN",8994,1794,2,5,1,1,0)
List of location types separated by commas (internal values of the TYPE
"KRN",8994,1794,2,5,1,2,0)
field of the HOSPITAL LOCATION file):
"KRN",8994,1794,2,5,1,3,0)
 
"KRN",8994,1794,2,5,1,4,0)
  C   Clinic
"KRN",8994,1794,2,5,1,5,0)
  F   File Area
"KRN",8994,1794,2,5,1,6,0)
  I   Imaging
"KRN",8994,1794,2,5,1,7,0)
  M   Module
"KRN",8994,1794,2,5,1,8,0)
  N   Non-Clinic Stop
"KRN",8994,1794,2,5,1,9,0)
  OR  Operating Room
"KRN",8994,1794,2,5,1,10,0)
  W   Ward
"KRN",8994,1794,2,5,1,11,0)
  Z   Other Location
"KRN",8994,1794,2,5,1,12,0)
 
"KRN",8994,1794,2,5,1,13,0)
Only locations of the types defined by this parameter are selected by the 
"KRN",8994,1794,2,5,1,14,0)
remote procedure. By default ($G(HLTYPES)=""), all locations are selected.
"KRN",8994,1794,2,6,0)
DIVIEN^1^^^2
"KRN",8994,1794,2,6,1,0)
^8994.021^2^2^3030226^^^^
"KRN",8994,1794,2,6,1,1,0)
Division IEN. If this parameter is defined and greater than zero then only
"KRN",8994,1794,2,6,1,2,0)
the locations associated with this division are selected.
"KRN",8994,1794,2,"B","DIVIEN",6)

"KRN",8994,1794,2,"B","FLAGS",2)

"KRN",8994,1794,2,"B","FROM",4)

"KRN",8994,1794,2,"B","HLTYPES",5)

"KRN",8994,1794,2,"B","NUMBER",3)

"KRN",8994,1794,2,"B","PART",1)

"KRN",8994,1794,2,"PARAMSEQ",1,5)

"KRN",8994,1794,2,"PARAMSEQ",2,6)

"KRN",8994,1794,2,"PARAMSEQ",3,1)

"KRN",8994,1794,2,"PARAMSEQ",4,2)

"KRN",8994,1794,2,"PARAMSEQ",5,3)

"KRN",8994,1794,2,"PARAMSEQ",6,4)

"KRN",8994,1794,3,0)
^^33^33^3030425^
"KRN",8994,1794,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1794,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1794,3,3,0)
case, the second piece of the Results[0] will contain number of the error 
"KRN",8994,1794,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1794,3,5,0)
  
"KRN",8994,1794,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1794,3,7,0)
                          ^01: The last error code
"KRN",8994,1794,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1794,3,9,0)
   
"KRN",8994,1794,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1794,3,11,0)
                          ^01: Error code
"KRN",8994,1794,3,12,0)
                          ^02: Message
"KRN",8994,1794,3,13,0)
                          ^03: Place of the error
"KRN",8994,1794,3,14,0)
 
"KRN",8994,1794,3,15,0)
Otherwise, number of hospital locations and the value of the FROM
"KRN",8994,1794,3,16,0)
parameter for the next procedure call are returned in the Results[0] and
"KRN",8994,1794,3,17,0)
the subsequent nodes of the global array contain the locations.
"KRN",8994,1794,3,18,0)
 
"KRN",8994,1794,3,19,0)
  Results[0]          Result Descriptor
"KRN",8994,1794,3,20,0)
                        ^01: Number of locations
"KRN",8994,1794,3,21,0)
                        ^02: FromName
"KRN",8994,1794,3,22,0)
                        ^03: FromIEN
"KRN",8994,1794,3,23,0)
 
"KRN",8994,1794,3,24,0)
  Results[i]          Hospital Location
"KRN",8994,1794,3,25,0)
                        ^01: IEN
"KRN",8994,1794,3,26,0)
                        ^02: Name
"KRN",8994,1794,3,27,0)
                        ^03: Location Type (internal)
"KRN",8994,1794,3,28,0)
                        ^04: Institution IEN
"KRN",8994,1794,3,29,0)
                        ^05: Division IEN
"KRN",8994,1794,3,30,0)
                        ^06: Active (0/1)
"KRN",8994,1794,3,31,0)
 
"KRN",8994,1794,3,32,0)
NOTE: The 6th "^"-piece of the location record (Active) is
"KRN",8994,1794,3,33,0)
      populated only if both "A" and "I" flags are used.
"KRN",8994,1795,-1)
0^18
"KRN",8994,1795,0)
ROR LIST ICD-9^ICD9LIST^RORRP016^4^R^^^1^1
"KRN",8994,1795,1,0)
^8994.01^2^2^3030425^^^
"KRN",8994,1795,1,1,0)
The ROR LIST ICD-9 remote procedure returns a list of ICD-9 codes (defined
"KRN",8994,1795,1,2,0)
in the ICD DIAGNOSIS file), which conform the criteria.
"KRN",8994,1795,2,0)
^8994.02A^4^4
"KRN",8994,1795,2,1,0)
PART^1^30^^1
"KRN",8994,1795,2,1,1,0)
^^1^1^3030226^
"KRN",8994,1795,2,1,1,1,0)
The partial match restriction.
"KRN",8994,1795,2,2,0)
FLAGS^1^^^2
"KRN",8994,1795,2,2,1,0)
^^15^15^3030226^
"KRN",8994,1795,2,2,1,1,0)
Flags that control the execution (can be combined):
"KRN",8994,1795,2,2,1,2,0)
 
"KRN",8994,1795,2,2,1,3,0)
  A  Select active codes (default)
"KRN",8994,1795,2,2,1,4,0)
 
"KRN",8994,1795,2,2,1,5,0)
  B  Backwards. Traverses the index in the opposite
"KRN",8994,1795,2,2,1,6,0)
     direction of normal traversal
"KRN",8994,1795,2,2,1,7,0)
 
"KRN",8994,1795,2,2,1,8,0)
  F  Exclude codes not applicable to females
"KRN",8994,1795,2,2,1,9,0)
 
"KRN",8994,1795,2,2,1,10,0)
  I  Select inactive codes
"KRN",8994,1795,2,2,1,11,0)
 
"KRN",8994,1795,2,2,1,12,0)
  M  Exclude codes not applicable to males
"KRN",8994,1795,2,2,1,13,0)
 
"KRN",8994,1795,2,2,1,14,0)
  P  Select only those codes that are acceptable
"KRN",8994,1795,2,2,1,15,0)
     as primary diagnoses
"KRN",8994,1795,2,3,0)
NUMBER^1^^^3
"KRN",8994,1795,2,3,1,0)
^^2^2^3030226^
"KRN",8994,1795,2,3,1,1,0)
Maximum number of entries to return. A value of "*" or no value in this 
"KRN",8994,1795,2,3,1,2,0)
parameter designates all entries.
"KRN",8994,1795,2,4,0)
FROM^1^^^4
"KRN",8994,1795,2,4,1,0)
^^13^13^3030425^
"KRN",8994,1795,2,4,1,1,0)
The index entry(s) from which to begin the list
"KRN",8994,1795,2,4,1,2,0)
   ^01: FromName
"KRN",8994,1795,2,4,1,3,0)
   ^02: FromIEN
"KRN",8994,1795,2,4,1,4,0)
  
"KRN",8994,1795,2,4,1,5,0)
For example, a FROM value of "18" would list entries following 18. You can
"KRN",8994,1795,2,4,1,6,0)
use the 2-nd and 3-rd "^"- pieces of the Results[0] to continue the
"KRN",8994,1795,2,4,1,7,0)
listing in the subsequent procedure calls.
"KRN",8994,1795,2,4,1,8,0)
  
"KRN",8994,1795,2,4,1,9,0)
NOTE: The FROM value itself is not included in the
"KRN",8994,1795,2,4,1,10,0)
      resulting list.
"KRN",8994,1795,2,4,1,11,0)
  
"KRN",8994,1795,2,4,1,12,0)
See description of the LIST^DIC for more details about the PART, NUMBER 
"KRN",8994,1795,2,4,1,13,0)
and FROM parameters.
"KRN",8994,1795,2,"B","FLAGS",2)

"KRN",8994,1795,2,"B","FROM",4)

"KRN",8994,1795,2,"B","NUMBER",3)

"KRN",8994,1795,2,"B","PART",1)

"KRN",8994,1795,2,"PARAMSEQ",1,1)

"KRN",8994,1795,2,"PARAMSEQ",2,2)

"KRN",8994,1795,2,"PARAMSEQ",3,3)

"KRN",8994,1795,2,"PARAMSEQ",4,4)

"KRN",8994,1795,3,0)
^8994.03^30^30^3030425^^
"KRN",8994,1795,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1795,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1795,3,3,0)
case, the second piece of the Results[0] will contain number of the error 
"KRN",8994,1795,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1795,3,5,0)
  
"KRN",8994,1795,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1795,3,7,0)
                          ^01: The last error code
"KRN",8994,1795,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1795,3,9,0)
   
"KRN",8994,1795,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1795,3,11,0)
                          ^01: Error code
"KRN",8994,1795,3,12,0)
                          ^02: Message
"KRN",8994,1795,3,13,0)
                          ^03: Place of the error
"KRN",8994,1795,3,14,0)
 
"KRN",8994,1795,3,15,0)
Otherwise, number of ICD-9 codes and the value of the FROM parameter for
"KRN",8994,1795,3,16,0)
the next procedure call are returned in the Results[0] and the subsequent
"KRN",8994,1795,3,17,0)
nodes of the global array contain the codes.
"KRN",8994,1795,3,18,0)
  
"KRN",8994,1795,3,19,0)
  Results[0]          Result Descriptor
"KRN",8994,1795,3,20,0)
                        ^01: Number of codes
"KRN",8994,1795,3,21,0)
                        ^02: FromName
"KRN",8994,1795,3,22,0)
                        ^03: FromIEN
"KRN",8994,1795,3,23,0)
 
"KRN",8994,1795,3,24,0)
  Results[i]          ICD-9
"KRN",8994,1795,3,25,0)
                        ^01: IEN
"KRN",8994,1795,3,26,0)
                        ^02: Diagnosis
"KRN",8994,1795,3,27,0)
                        ^03: Code
"KRN",8994,1795,3,28,0)
                        ^04: Use only with Sex
"KRN",8994,1795,3,29,0)
                        ^05: Inactive (""/1)
"KRN",8994,1795,3,30,0)
                        ^06: Inactivation Date (internal)
"KRN",8994,1796,-1)
0^19
"KRN",8994,1796,0)
ROR LIST VA DRUG CLASSES^VACLSLST^RORRP017^4^R^^^1^1
"KRN",8994,1796,1,0)
^8994.01^2^2^3030425^^
"KRN",8994,1796,1,1,0)
The ROR LIST VA DRUG CLASSES remote procedure returns a list of VA drug 
"KRN",8994,1796,1,2,0)
classes (defined in the VA DRUG CLASS file), which conform the criteria.
"KRN",8994,1796,2,0)
^8994.02A^5^5
"KRN",8994,1796,2,1,0)
PARENT^1^^^1
"KRN",8994,1796,2,1,1,0)
^^1^1^3030227^
"KRN",8994,1796,2,1,1,1,0)
Reserved
"KRN",8994,1796,2,2,0)
PART^1^30^^2
"KRN",8994,1796,2,2,1,0)
^^1^1^3030227^
"KRN",8994,1796,2,2,1,1,0)
The partial match restriction.
"KRN",8994,1796,2,3,0)
FLAGS^1^^^3
"KRN",8994,1796,2,3,1,0)
^^4^4^3030227^
"KRN",8994,1796,2,3,1,1,0)
Flags that control the execution (can be combined):
"KRN",8994,1796,2,3,1,2,0)
 
"KRN",8994,1796,2,3,1,3,0)
  B  Backwards. Traverses the index in the opposite
"KRN",8994,1796,2,3,1,4,0)
     direction of normal traversal
"KRN",8994,1796,2,4,0)
NUMBER^1^^^4
"KRN",8994,1796,2,4,1,0)
^^2^2^3030227^
"KRN",8994,1796,2,4,1,1,0)
Maximum number of entries to return. A value of "*" or no value in this
"KRN",8994,1796,2,4,1,2,0)
parameter designates all entries.
"KRN",8994,1796,2,5,0)
FROM^1^^^5
"KRN",8994,1796,2,5,1,0)
^^13^13^3030425^
"KRN",8994,1796,2,5,1,1,0)
The index entry(s) from which to begin the list
"KRN",8994,1796,2,5,1,2,0)
   ^01: FromName
"KRN",8994,1796,2,5,1,3,0)
   ^02: FromIEN
"KRN",8994,1796,2,5,1,4,0)
   
"KRN",8994,1796,2,5,1,5,0)
For example, a FROM value of "XA" would list entries following XA. You can
"KRN",8994,1796,2,5,1,6,0)
use the 2-nd and 3-rd "^"- pieces of the Results[0] to continue the
"KRN",8994,1796,2,5,1,7,0)
listing in the subsequent procedure calls.
"KRN",8994,1796,2,5,1,8,0)
   
"KRN",8994,1796,2,5,1,9,0)
NOTE: The FROM value itself is not included in the
"KRN",8994,1796,2,5,1,10,0)
      resulting list.
"KRN",8994,1796,2,5,1,11,0)
   
"KRN",8994,1796,2,5,1,12,0)
See description of the LIST^DIC for more details about the PART, NUMBER 
"KRN",8994,1796,2,5,1,13,0)
and FROM parameters.
"KRN",8994,1796,2,"B","FLAGS",3)

"KRN",8994,1796,2,"B","FROM",5)

"KRN",8994,1796,2,"B","NUMBER",4)

"KRN",8994,1796,2,"B","PARENT",1)

"KRN",8994,1796,2,"B","PART",2)

"KRN",8994,1796,2,"PARAMSEQ",1,1)

"KRN",8994,1796,2,"PARAMSEQ",2,2)

"KRN",8994,1796,2,"PARAMSEQ",3,3)

"KRN",8994,1796,2,"PARAMSEQ",4,4)

"KRN",8994,1796,2,"PARAMSEQ",5,5)

"KRN",8994,1796,3,0)
^^27^27^3030425^
"KRN",8994,1796,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1796,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1796,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1796,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1796,3,5,0)
   
"KRN",8994,1796,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1796,3,7,0)
                          ^01: The last error code
"KRN",8994,1796,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1796,3,9,0)
   
"KRN",8994,1796,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1796,3,11,0)
                          ^01: Error code
"KRN",8994,1796,3,12,0)
                          ^02: Message
"KRN",8994,1796,3,13,0)
                          ^03: Place of the error
"KRN",8994,1796,3,14,0)
  
"KRN",8994,1796,3,15,0)
Otherwise, number of drug classes and the value of the FROM parameter for
"KRN",8994,1796,3,16,0)
the next procedure call are returned in the Results[0] and the subsequent
"KRN",8994,1796,3,17,0)
nodes of the global array contain the classes.
"KRN",8994,1796,3,18,0)
   
"KRN",8994,1796,3,19,0)
  Results[0]          Result Descriptor
"KRN",8994,1796,3,20,0)
                        ^01: Number of classes
"KRN",8994,1796,3,21,0)
                        ^02: FromName
"KRN",8994,1796,3,22,0)
                        ^03: FromIEN
"KRN",8994,1796,3,23,0)
 
"KRN",8994,1796,3,24,0)
  Results[i]          VA Drug Class
"KRN",8994,1796,3,25,0)
                        ^01: IEN
"KRN",8994,1796,3,26,0)
                        ^02: Classification
"KRN",8994,1796,3,27,0)
                        ^03: Code
"KRN",8994,1797,-1)
0^24
"KRN",8994,1797,0)
ROR LIST LABORATORY TESTS^LABTLIST^RORRP018^4^R^^^1^1
"KRN",8994,1797,1,0)
^8994.01^3^3^3030625^^^^
"KRN",8994,1797,1,1,0)
The ROR LIST LABORATORY TESTS remote procedure returns a list of 
"KRN",8994,1797,1,2,0)
laboratory tests (defined in the LABORATORY TEST file), which conform the 
"KRN",8994,1797,1,3,0)
criteria.
"KRN",8994,1797,2,0)
^8994.02A^5^5
"KRN",8994,1797,2,1,0)
SUBSCR^1^^^1
"KRN",8994,1797,2,1,1,0)
^^14^14^3030227^
"KRN",8994,1797,2,1,1,1,0)
List of test subscripts separated by commas (internal values of the 
"KRN",8994,1797,2,1,1,2,0)
SUBSCRIPT field of the LABORATORY TEST file):
"KRN",8994,1797,2,1,1,3,0)
 
"KRN",8994,1797,2,1,1,4,0)
  AU  Autopsy
"KRN",8994,1797,2,1,1,5,0)
  BB  Blood Bank
"KRN",8994,1797,2,1,1,6,0)
  CH  CHEM, HEM, TOX, SER, RIA, ETC.
"KRN",8994,1797,2,1,1,7,0)
  CY  Cytology
"KRN",8994,1797,2,1,1,8,0)
  EM  Electronic Microscopy
"KRN",8994,1797,2,1,1,9,0)
  MI  Microbiology
"KRN",8994,1797,2,1,1,10,0)
  SP  Surgical Pathology
"KRN",8994,1797,2,1,1,11,0)
  WK  Workload
"KRN",8994,1797,2,1,1,12,0)
  
"KRN",8994,1797,2,1,1,13,0)
Only tests of the types defined by this parameter are selected by the
"KRN",8994,1797,2,1,1,14,0)
remote procedure. By default ($G(SUBSCR)=""), all tests are selected.
"KRN",8994,1797,2,2,0)
PART^1^30^^2
"KRN",8994,1797,2,2,1,0)
^^1^1^3030227^
"KRN",8994,1797,2,2,1,1,0)
The partial match restriction.
"KRN",8994,1797,2,3,0)
FLAGS^1^^^3
"KRN",8994,1797,2,3,1,0)
^^7^7^3030625^
"KRN",8994,1797,2,3,1,1,0)
Flags that control the execution (can be combined):
"KRN",8994,1797,2,3,1,2,0)
 
"KRN",8994,1797,2,3,1,3,0)
  B  Backwards. Traverses the index in the opposite
"KRN",8994,1797,2,3,1,4,0)
     direction of normal traversal.
"KRN",8994,1797,2,3,1,5,0)
 
"KRN",8994,1797,2,3,1,6,0)
  P  Include panels (by default, the panels are
"KRN",8994,1797,2,3,1,7,0)
     excluded from the list)
"KRN",8994,1797,2,4,0)
NUMBER^1^^^4
"KRN",8994,1797,2,4,1,0)
^^2^2^3030227^
"KRN",8994,1797,2,4,1,1,0)
Maximum number of entries to return. A value of "*" or no value in this 
"KRN",8994,1797,2,4,1,2,0)
parameter designates all entries.
"KRN",8994,1797,2,5,0)
FROM^1^^^5
"KRN",8994,1797,2,5,1,0)
^8994.021^13^13^3030625^^
"KRN",8994,1797,2,5,1,1,0)
The index entry(s) from which to begin the list
"KRN",8994,1797,2,5,1,2,0)
  ^01: FromName
"KRN",8994,1797,2,5,1,3,0)
  ^02: FromIEN
"KRN",8994,1797,2,5,1,4,0)
  
"KRN",8994,1797,2,5,1,5,0)
For example, a FROM value of "BI" would list entries following BI. You can
"KRN",8994,1797,2,5,1,6,0)
use the 2-nd and 3-rd "^"- pieces of the Results[0] to continue the
"KRN",8994,1797,2,5,1,7,0)
listing in the subsequent procedure calls.
"KRN",8994,1797,2,5,1,8,0)
  
"KRN",8994,1797,2,5,1,9,0)
NOTE: The FROM value itself is not included in the
"KRN",8994,1797,2,5,1,10,0)
      resulting list.
"KRN",8994,1797,2,5,1,11,0)
  
"KRN",8994,1797,2,5,1,12,0)
See description of the LIST^DIC for more details about the PART, NUMBER
"KRN",8994,1797,2,5,1,13,0)
and FROM parameters.
"KRN",8994,1797,2,"B","FLAGS",3)

"KRN",8994,1797,2,"B","FROM",5)

"KRN",8994,1797,2,"B","NUMBER",4)

"KRN",8994,1797,2,"B","PART",2)

"KRN",8994,1797,2,"B","SUBSCR",1)

"KRN",8994,1797,2,"PARAMSEQ",1,1)

"KRN",8994,1797,2,"PARAMSEQ",2,2)

"KRN",8994,1797,2,"PARAMSEQ",3,3)

"KRN",8994,1797,2,"PARAMSEQ",4,4)

"KRN",8994,1797,2,"PARAMSEQ",5,5)

"KRN",8994,1797,3,0)
^8994.03^27^27^3030625^^
"KRN",8994,1797,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1797,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1797,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1797,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1797,3,5,0)
   
"KRN",8994,1797,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1797,3,7,0)
                          ^01: The last error code
"KRN",8994,1797,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1797,3,9,0)
    
"KRN",8994,1797,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1797,3,11,0)
                          ^01: Error code
"KRN",8994,1797,3,12,0)
                          ^02: Message
"KRN",8994,1797,3,13,0)
                          ^03: Place of the error
"KRN",8994,1797,3,14,0)
 
"KRN",8994,1797,3,15,0)
Otherwise, number of laboratory tests and the value of the FROM parameter
"KRN",8994,1797,3,16,0)
for the next procedure call are returned in the Results[0] and the
"KRN",8994,1797,3,17,0)
subsequent nodes of the global array contain the tests.
"KRN",8994,1797,3,18,0)
  
"KRN",8994,1797,3,19,0)
  Results[0]          Result Descriptor
"KRN",8994,1797,3,20,0)
                        ^01: Number of tests
"KRN",8994,1797,3,21,0)
                        ^02: FromName
"KRN",8994,1797,3,22,0)
                        ^03: FromIEN
"KRN",8994,1797,3,23,0)
 
"KRN",8994,1797,3,24,0)
  Results[i]          Laboratory Test
"KRN",8994,1797,3,25,0)
                        ^01: IEN
"KRN",8994,1797,3,26,0)
                        ^02: Test Name
"KRN",8994,1797,3,27,0)
                        ^03: Subscript (internal)
"KRN",8994,1798,-1)
0^20
"KRN",8994,1798,0)
ROR LOG INFO^LOGINFO^RORRP007^2^R^^^1^1
"KRN",8994,1798,1,0)
^8994.01^1^1^3030228^^
"KRN",8994,1798,1,1,0)
The ROR LOG INFO remote procedure returns the log information.
"KRN",8994,1798,2,0)
^8994.02A^1^1
"KRN",8994,1798,2,1,0)
LOGIEN^1^^1^1
"KRN",8994,1798,2,1,1,0)
^8994.021^1^1^3030228^^
"KRN",8994,1798,2,1,1,1,0)
The LOGIEN parameter defines the log.
"KRN",8994,1798,2,"B","LOGIEN",1)

"KRN",8994,1798,2,"PARAMSEQ",1,1)

"KRN",8994,1798,3,0)
^^22^22^3030425^
"KRN",8994,1798,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1798,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1798,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1798,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1798,3,5,0)
    
"KRN",8994,1798,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1798,3,7,0)
                          ^01: The last error code
"KRN",8994,1798,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1798,3,9,0)
                                                                       
"KRN",8994,1798,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1798,3,11,0)
                          ^01: Error code
"KRN",8994,1798,3,12,0)
                          ^02: Message
"KRN",8994,1798,3,13,0)
                          ^03: Place of the error
"KRN",8994,1798,3,14,0)
 
"KRN",8994,1798,3,15,0)
Otherwise, either 0 (an invalid log IEN or the log does not exist) or 1 is
"KRN",8994,1798,3,16,0)
returned in the Results[0] and the subsequent nodes of the Results array
"KRN",8994,1798,3,17,0)
contain the log information.
"KRN",8994,1798,3,18,0)
 
"KRN",8994,1798,3,19,0)
  Results[0]            0 or 1
"KRN",8994,1798,3,20,0)
 
"KRN",8994,1798,3,21,0)
  Results[i]            See description of the ROR LOG GET LIST
"KRN",8994,1798,3,22,0)
                        remote procedure (if the Results[0] = 1)
"KRN",8994,1799,-1)
0^21
"KRN",8994,1799,0)
ROR REPORT STYLESHEET^GETXSL^RORRP011^4^R^^^1^1
"KRN",8994,1799,1,0)
^^3^3^3030307^
"KRN",8994,1799,1,1,0)
The ROR REPORT STYLESHEET remote procedure retrieves the XSL stylesheet 
"KRN",8994,1799,1,2,0)
associated with the report. If there is no stylesheet available, the 
"KRN",8994,1799,1,3,0)
default one is returned.
"KRN",8994,1799,2,0)
^8994.02A^2^2
"KRN",8994,1799,2,1,0)
RPTCODE^1^^1^1
"KRN",8994,1799,2,1,1,0)
^8994.021^2^2^3030307^^
"KRN",8994,1799,2,1,1,1,0)
Code of the report (value of the CODE field of the report descriptor in
"KRN",8994,1799,2,1,1,2,0)
the ROR REPORT file).
"KRN",8994,1799,2,2,0)
TYPE^1^^^2
"KRN",8994,1799,2,2,1,0)
^^5^5^3030307^
"KRN",8994,1799,2,2,1,1,0)
The TYPE parameter defines the type of requested stylesheet:
"KRN",8994,1799,2,2,1,2,0)
 
"KRN",8994,1799,2,2,1,3,0)
  1  Report preview (default)
"KRN",8994,1799,2,2,1,4,0)
  2  Comma-separated output
"KRN",8994,1799,2,2,1,5,0)
  3  Printer output
"KRN",8994,1799,2,"B","RPTCODE",1)

"KRN",8994,1799,2,"B","TYPE",2)

"KRN",8994,1799,2,"PARAMSEQ",1,1)

"KRN",8994,1799,2,"PARAMSEQ",2,2)

"KRN",8994,1799,3,0)
^^16^16^3030425^
"KRN",8994,1799,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1799,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1799,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1799,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1799,3,5,0)
     
"KRN",8994,1799,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1799,3,7,0)
                          ^01: The last error code
"KRN",8994,1799,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1799,3,9,0)
                                                                      
"KRN",8994,1799,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1799,3,11,0)
                          ^01: Error code
"KRN",8994,1799,3,12,0)
                          ^02: Message
"KRN",8994,1799,3,13,0)
                          ^03: Place of the error
"KRN",8994,1799,3,14,0)
 
"KRN",8994,1799,3,15,0)
Otherwise, the elements of the resulting array (starting from 0) contain
"KRN",8994,1799,3,16,0)
the lines of the XSL stylesheet.
"KRN",8994,1809,-1)
0^46
"KRN",8994,1809,0)
ROR TASK VALIDATE RESCHEDULING^VALIDSCH^RORRP012^2^P^^^1^1
"KRN",8994,1809,1,0)
^8994.01^2^2^3030313^^^^
"KRN",8994,1809,1,1,0)
The ROR TASK VALIDATE RESCHEDULING remote procedure validates the 
"KRN",8994,1809,1,2,0)
rescheduling code and returns the next date/time to run.
"KRN",8994,1809,2,0)
^8994.02A^2^2
"KRN",8994,1809,2,1,0)
SCHCODE^1^^1^1
"KRN",8994,1809,2,1,1,0)
^^1^1^3030313^
"KRN",8994,1809,2,1,1,1,0)
Rescheduling code ("1D", "1M", "D@12:00", etc).
"KRN",8994,1809,2,2,0)
SCHDT^1^^^2
"KRN",8994,1809,2,2,1,0)
^^2^2^3030313^
"KRN",8994,1809,2,2,1,1,0)
Date when a task is scheduled to run for the first time (FileMan). By 
"KRN",8994,1809,2,2,1,2,0)
default (if $G(SCHDT)'>0), the current date/time is used.
"KRN",8994,1809,2,"B","SCHCODE",1)

"KRN",8994,1809,2,"B","SCHDT",2)

"KRN",8994,1809,2,"PARAMSEQ",1,1)

"KRN",8994,1809,2,"PARAMSEQ",2,2)

"KRN",8994,1809,3,0)
^^17^17^3030425^
"KRN",8994,1809,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1809,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1809,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1809,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1809,3,5,0)
  
"KRN",8994,1809,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1809,3,7,0)
                          ^01: The last error code
"KRN",8994,1809,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1809,3,9,0)
  
"KRN",8994,1809,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1809,3,11,0)
                          ^01: Error code
"KRN",8994,1809,3,12,0)
                          ^02: Message
"KRN",8994,1809,3,13,0)
                          ^03: Place of the error
"KRN",8994,1809,3,14,0)
 
"KRN",8994,1809,3,15,0)
Otherwise, either 1 (the rescheduling code is valid) or 0 (the code is not
"KRN",8994,1809,3,16,0)
valid) is returned in the Results[0]. If the code is valid then the next 
"KRN",8994,1809,3,17,0)
date/time to run the task (FileMan) is returned in the Results[1].
"KRN",8994,1810,-1)
0^22
"KRN",8994,1810,0)
ROR LIST PATIENTS^PTLIST^RORRP019^4^R^^^1^1
"KRN",8994,1810,1,0)
^8994.01^3^3^3030425^^^^
"KRN",8994,1810,1,1,0)
The ROR LIST PATIENTS remote procedure returns either a list patients from
"KRN",8994,1810,1,2,0)
the PATIENT file (#2) or a list of registry patients who conform the
"KRN",8994,1810,1,3,0)
provided criteria.
"KRN",8994,1810,2,0)
^8994.02A^6^6
"KRN",8994,1810,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1810,2,1,1,0)
^8994.021^2^2^3030320^^
"KRN",8994,1810,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1810,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1810,2,2,0)
DATE^1^^^2
"KRN",8994,1810,2,2,1,0)
^^3^3^3030320^
"KRN",8994,1810,2,2,1,1,0)
Patients who were added to the registry before the date defined by the
"KRN",8994,1810,2,2,1,2,0)
DATE parameter will be skipped by the query (if the FLAGS parameter
"KRN",8994,1810,2,2,1,3,0)
contains the 'D' flag).
"KRN",8994,1810,2,3,0)
PART^1^30^^3
"KRN",8994,1810,2,3,1,0)
^^8^8^3030320^
"KRN",8994,1810,2,3,1,1,0)
The PART parameter defines the search pattern. It can contain last 4 
"KRN",8994,1810,2,3,1,2,0)
digits of the patient's SSN, the first letter of the patient's last name
"KRN",8994,1810,2,3,1,3,0)
and last four digits of the SSN, the full SSN, or the beginning of the
"KRN",8994,1810,2,3,1,4,0)
patient name.
"KRN",8994,1810,2,3,1,5,0)
 
"KRN",8994,1810,2,3,1,6,0)
If the 'N' or 'P' flag is defined (see the FLAGS parameter), the PART
"KRN",8994,1810,2,3,1,7,0)
parameter should contain either the beginning of the patient name or an
"KRN",8994,1810,2,3,1,8,0)
empty string.
"KRN",8994,1810,2,4,0)
FLAGS^1^^^4
"KRN",8994,1810,2,4,1,0)
^^19^19^3030320^
"KRN",8994,1810,2,4,1,1,0)
Flags that control the execution (can be combined):
"KRN",8994,1810,2,4,1,2,0)
  
"KRN",8994,1810,2,4,1,3,0)
  2  Search in the PATIENT file. By default, the     
"KRN",8994,1810,2,4,1,4,0)
     ROR LOCAL REGISTRY and ROR PATIENT files are
"KRN",8994,1810,2,4,1,5,0)
     queried. This flag overrides the 'D', 'N'
"KRN",8994,1810,2,4,1,6,0)
     and 'P' flags.
"KRN",8994,1810,2,4,1,7,0)
 
"KRN",8994,1810,2,4,1,8,0)
  B  Backwards. Traverses the index in the opposite
"KRN",8994,1810,2,4,1,9,0)
     direction of normal traversal.
"KRN",8994,1810,2,4,1,10,0)
 
"KRN",8994,1810,2,4,1,11,0)
  D  Ignore those patients who were added to the
"KRN",8994,1810,2,4,1,12,0)
     registry before the date defined by the DATE
"KRN",8994,1810,2,4,1,13,0)
     parameter.
"KRN",8994,1810,2,4,1,14,0)
 
"KRN",8994,1810,2,4,1,15,0)
  N  Include only new patients (AUTO or MANUAL)
"KRN",8994,1810,2,4,1,16,0)
 
"KRN",8994,1810,2,4,1,17,0)
  O  Return values of the optional fields
"KRN",8994,1810,2,4,1,18,0)
 
"KRN",8994,1810,2,4,1,19,0)
  P  Include only pending patients
"KRN",8994,1810,2,5,0)
NUMBER^1^^^5
"KRN",8994,1810,2,5,1,0)
^^2^2^3030320^
"KRN",8994,1810,2,5,1,1,0)
Maximum number of entries to return. A value of "*" or no value in this 
"KRN",8994,1810,2,5,1,2,0)
parameter designates all entries that conform the criteria.
"KRN",8994,1810,2,6,0)
FROM^1^^^6
"KRN",8994,1810,2,6,1,0)
^^9^9^3030425^
"KRN",8994,1810,2,6,1,1,0)
The index entry(s) from which to begin the list. Use the pieces of the
"KRN",8994,1810,2,6,1,2,0)
Results[0] (starting from the second one) to continue the listing in the
"KRN",8994,1810,2,6,1,3,0)
subsequent procedure calls.
"KRN",8994,1810,2,6,1,4,0)
 
"KRN",8994,1810,2,6,1,5,0)
NOTE: The FROM value itself is not included in the
"KRN",8994,1810,2,6,1,6,0)
      resulting list.
"KRN",8994,1810,2,6,1,7,0)
 
"KRN",8994,1810,2,6,1,8,0)
See description of the LIST^DIC for more details about the PART, NUMBER
"KRN",8994,1810,2,6,1,9,0)
and FROM parameters.
"KRN",8994,1810,2,"B","DATE",2)

"KRN",8994,1810,2,"B","FLAGS",4)

"KRN",8994,1810,2,"B","FROM",6)

"KRN",8994,1810,2,"B","NUMBER",5)

"KRN",8994,1810,2,"B","PART",3)

"KRN",8994,1810,2,"B","REGIEN",1)

"KRN",8994,1810,2,"PARAMSEQ",1,1)

"KRN",8994,1810,2,"PARAMSEQ",2,2)

"KRN",8994,1810,2,"PARAMSEQ",3,3)

"KRN",8994,1810,2,"PARAMSEQ",4,4)

"KRN",8994,1810,2,"PARAMSEQ",5,5)

"KRN",8994,1810,2,"PARAMSEQ",6,6)

"KRN",8994,1810,3,0)
^^115^115^3030616^
"KRN",8994,1810,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1810,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1810,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1810,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1810,3,5,0)
   
"KRN",8994,1810,3,6,0)
   Results[0]            Result Descriptor
"KRN",8994,1810,3,7,0)
                           ^01: The last error code
"KRN",8994,1810,3,8,0)
                           ^02: Number of the error descriptors
"KRN",8994,1810,3,9,0)
    
"KRN",8994,1810,3,10,0)
   Results[i]            Error Descriptor
"KRN",8994,1810,3,11,0)
                           ^01: Error code
"KRN",8994,1810,3,12,0)
                           ^02: Message
"KRN",8994,1810,3,13,0)
                           ^03: Place of the error
"KRN",8994,1810,3,14,0)
 
"KRN",8994,1810,3,15,0)
Otherwise, number of patients and the value of the FROM parameter for the
"KRN",8994,1810,3,16,0)
next procedure call are returned in the Results[0] and the subsequent
"KRN",8994,1810,3,17,0)
nodes of the Results array contain the patients.
"KRN",8994,1810,3,18,0)
  
"KRN",8994,1810,3,19,0)
  Results[0]            Result Descriptor
"KRN",8994,1810,3,20,0)
                          ^01: Number of patients
"KRN",8994,1810,3,21,0)
                          ^02: Values that comprise the FROM parameter
"KRN",8994,1810,3,22,0)
                          ^nn: for the subsequent call of the procedure
"KRN",8994,1810,3,23,0)
 
"KRN",8994,1810,3,24,0)
  Results[i]            Patient
"KRN",8994,1810,3,25,0)
                          ^01: IEN (DFN)
"KRN",8994,1810,3,26,0)
                          ^02: Name
"KRN",8994,1810,3,27,0)
                          ^03: Date of Birth (FileMan)
"KRN",8994,1810,3,28,0)
                          ^04: SSN
"KRN",8994,1810,3,29,0)
                          ^05: Date of Death (FileMan)
"KRN",8994,1810,3,30,0)
                          ^06: Sex (internal)
"KRN",8994,1810,3,31,0)
 
"KRN",8994,1810,3,32,0)
  Results[i+1]          Optional Fields (these nodes are created only
"KRN",8994,1810,3,33,0)
                        if the FLAGS parameter contains the 'O' flag)
"KRN",8994,1810,3,34,0)
                          ^01: "O" (letter O)
"KRN",8994,1810,3,35,0)
                          ^02: Date Entered (FileMan)
"KRN",8994,1810,3,36,0)
                          ^03: New Patient (internal)
"KRN",8994,1810,3,37,0)
                          ^04: Active (0/1)
"KRN",8994,1810,3,38,0)
                          ^05: Do not Send (0/1)
"KRN",8994,1810,3,39,0)
                          ^06: Data Acknowledged Until (FileMan)
"KRN",8994,1810,3,40,0)
                          ^07: Data Extracted Until (FileMan)
"KRN",8994,1810,3,41,0)
                          ^08: Inactivation Date (FileMan)
"KRN",8994,1810,3,42,0)
                          ^09: Inactivated By (IEN)
"KRN",8994,1810,3,43,0)
                          ^10: Inactivated By (Name)
"KRN",8994,1810,3,44,0)
                          ^11: Reactivation Date (FileMan)
"KRN",8994,1810,3,45,0)
                          ^12: Reactivated By (IEN)
"KRN",8994,1810,3,46,0)
                          ^13: Reactivated By (Name)
"KRN",8994,1810,3,47,0)
                          ^14: Action Flags (see the description below)
"KRN",8994,1810,3,48,0)
                          ^15: Code of inactivation reason
"KRN",8994,1810,3,49,0)
                          ^16: Code of supporting evidence
"KRN",8994,1810,3,50,0)
 
"KRN",8994,1810,3,51,0)
                        The New Patient field can have the following values
"KRN",8994,1810,3,52,0)
                        (see description of the NEW PATIENT field of the
"KRN",8994,1810,3,53,0)
                        ROR LOCAL REGISTRY file for more details):
"KRN",8994,1810,3,54,0)
                            0  No
"KRN",8994,1810,3,55,0)
                            1  Auto
"KRN",8994,1810,3,56,0)
                            2  Manual
"KRN",8994,1810,3,57,0)
                            3  Reactivated
"KRN",8994,1810,3,58,0)
                            4  Pending
"KRN",8994,1810,3,59,0)
 
"KRN",8994,1810,3,60,0)
                        The Action Flags field indicates the actions that
"KRN",8994,1810,3,61,0)
                        can be performed on the patient's record:
"KRN",8994,1810,3,62,0)
                            C  CDC form can be edited/printed
"KRN",8994,1810,3,63,0)
                            D  The record can be deleted
"KRN",8994,1810,3,64,0)
                            E  The record can be edited
"KRN",8994,1810,3,65,0)
                            I  The record can be inactivated
"KRN",8994,1810,3,66,0)
                            O  Read-only mode
"KRN",8994,1810,3,67,0)
                            R  The record can be reactivated
"KRN",8994,1810,3,68,0)
 
"KRN",8994,1810,3,69,0)
Example #1 (search the PATIENT file):
"KRN",8994,1810,3,70,0)
 
"KRN",8994,1810,3,71,0)
  with RPCBroker do
"KRN",8994,1810,3,72,0)
    begin
"KRN",8994,1810,3,73,0)
      Param[0].Value := '2';      // Registry IEN
"KRN",8994,1810,3,74,0)
      Param[0].PType := literal;
"KRN",8994,1810,3,75,0)
      Param[1].Value := '';       // Date
"KRN",8994,1810,3,76,0)
      Param[1].PType := literal;
"KRN",8994,1810,3,77,0)
      Param[2].Value := '3456';   // Last four digits of the SSN
"KRN",8994,1810,3,78,0)
      Param[2].PType := literal;
"KRN",8994,1810,3,79,0)
      Param[3].Value := '2';      // Flags
"KRN",8994,1810,3,80,0)
      Param[3].PType := literal;
"KRN",8994,1810,3,81,0)
      Call;
"KRN",8994,1810,3,82,0)
    end;
"KRN",8994,1810,3,83,0)
 
"KRN",8994,1810,3,84,0)
  The Results array will contain something like this:
"KRN",8994,1810,3,85,0)
 
"KRN",8994,1810,3,86,0)
  Results[0] = '1'
"KRN",8994,1810,3,87,0)
  Results[1] = '162^ATTENDING,PATIENT^3000617^321233456^^M'
"KRN",8994,1810,3,88,0)
 
"KRN",8994,1810,3,89,0)
Example #2 (query the registry):
"KRN",8994,1810,3,90,0)
 
"KRN",8994,1810,3,91,0)
  with RPCBroker do
"KRN",8994,1810,3,92,0)
    begin
"KRN",8994,1810,3,93,0)
      Param[0].Value := '2';      // Registry IEN
"KRN",8994,1810,3,94,0)
      Param[0].PType := literal;
"KRN",8994,1810,3,95,0)
      Param[1].Value := '';       // Date
"KRN",8994,1810,3,96,0)
      Param[1].PType := literal;
"KRN",8994,1810,3,97,0)
      Param[2].Value := 'T';      // Partial match
"KRN",8994,1810,3,98,0)
      Param[2].PType := literal;
"KRN",8994,1810,3,99,0)
      Param[3].Value := 'O';      // Flags
"KRN",8994,1810,3,100,0)
      Param[3].PType := literal;
"KRN",8994,1810,3,101,0)
      Param[4].Value := '3';      // Number
"KRN",8994,1810,3,102,0)
      Param[4].PType := literal;
"KRN",8994,1810,3,103,0)
      Call;
"KRN",8994,1810,3,104,0)
    end;
"KRN",8994,1810,3,105,0)
 
"KRN",8994,1810,3,106,0)
  The Results array will contain something like this (see the Results[0]-
"KRN",8994,1810,3,107,0)
  not all records have been loaded):
"KRN",8994,1810,3,108,0)
 
"KRN",8994,1810,3,109,0)
  Results[0] = '3^TEST,C'
"KRN",8994,1810,3,110,0)
  Results[1] = '1^TEST,A^2610400^107040061P^2931021.08^M'
"KRN",8994,1810,3,111,0)
  Results[2] = 'O^3021025.131352^1^1^0^^3030314'
"KRN",8994,1810,3,112,0)
  Results[3] = '2^TEST,B^2180000^222222222^2940719.135645^M'
"KRN",8994,1810,3,113,0)
  Results[4] = 'O^3021025.131414^1^0^0^^2940819^2940819.135645^^'
"KRN",8994,1810,3,114,0)
  Results[5] = '3^TEST,C^2340701^333333333^2981028.115324^M'
"KRN",8994,1810,3,115,0)
  Results[6] = 'O^3021025.131537^1^0^0^^2981128^2981128.115324^^'
"KRN",8994,1811,-1)
0^23
"KRN",8994,1811,0)
ROR PATIENT SELECTION RULES^PTRULES^RORRP022^2^R^^^1^1
"KRN",8994,1811,1,0)
^8994.01^2^2^3030321^^
"KRN",8994,1811,1,1,0)
The ROR PATIENT SELECTION RULES remote procedure returns a list of 
"KRN",8994,1811,1,2,0)
selection rules that have caused addition of the patient to the registry.
"KRN",8994,1811,2,0)
^8994.02A^2^2
"KRN",8994,1811,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1811,2,1,1,0)
^^2^2^3030321^
"KRN",8994,1811,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1811,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1811,2,2,0)
PATIEN^1^^1^2
"KRN",8994,1811,2,2,1,0)
^8994.021^2^2^3030321^^
"KRN",8994,1811,2,2,1,1,0)
Valid IEN of a registry patient should be assigned to the PATIEN
"KRN",8994,1811,2,2,1,2,0)
parameter.
"KRN",8994,1811,2,"B","PATIEN",2)

"KRN",8994,1811,2,"B","REGIEN",1)

"KRN",8994,1811,2,"PARAMSEQ",1,1)

"KRN",8994,1811,2,"PARAMSEQ",2,2)

"KRN",8994,1811,3,0)
^^27^27^3030425^
"KRN",8994,1811,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1811,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1811,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1811,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1811,3,5,0)
  
"KRN",8994,1811,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1811,3,7,0)
                          ^01: The last error code
"KRN",8994,1811,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1811,3,9,0)
                                                                      
"KRN",8994,1811,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1811,3,11,0)
                          ^01: Error code
"KRN",8994,1811,3,12,0)
                          ^02: Message
"KRN",8994,1811,3,13,0)
                          ^03: Place of the error
"KRN",8994,1811,3,14,0)
 
"KRN",8994,1811,3,15,0)
Otherwise, number of selection rules is returned in the Results[0] and the
"KRN",8994,1811,3,16,0)
subsequent nodes of the array contain the rules.
"KRN",8994,1811,3,17,0)
 
"KRN",8994,1811,3,18,0)
  Results[0]            Number of Selection Rules
"KRN",8994,1811,3,19,0)
 
"KRN",8994,1811,3,20,0)
  Results[i]            Selection Rule
"KRN",8994,1811,3,21,0)
                          ^01: IEN in the SELECTION RULE multiple
"KRN",8994,1811,3,22,0)
                               of the ROR LOCAL REGISTRY file
"KRN",8994,1811,3,23,0)
                          ^02: IEN of the Rule (in the
"KRN",8994,1811,3,24,0)
                               ROR SELECTION RULE file)
"KRN",8994,1811,3,25,0)
                          ^03: Name of the Rule
"KRN",8994,1811,3,26,0)
                          ^04: Date (FileMan)
"KRN",8994,1811,3,27,0)
                          ^05: Short Description
"KRN",8994,1812,-1)
0^25
"KRN",8994,1812,0)
ROR LIST ITEMS^LSTITEMS^RORRP012^2^A^^^1^1
"KRN",8994,1812,1,0)
^8994.01^2^2^3030409^^
"KRN",8994,1812,1,1,0)
The ROR LIST ITEMS remote procedure returns a list of registry-specific 
"KRN",8994,1812,1,2,0)
items from the ROR LIST ITEM file.
"KRN",8994,1812,2,0)
^8994.02A^2^2
"KRN",8994,1812,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1812,2,1,1,0)
^^2^2^3030321^
"KRN",8994,1812,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1812,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1812,2,2,0)
TYPE^1^^1^2
"KRN",8994,1812,2,2,1,0)
^^8^8^3030409^
"KRN",8994,1812,2,2,1,1,0)
The TYPE parameter defines type of the items that should be extracted:
"KRN",8994,1812,2,2,1,2,0)
 
"KRN",8994,1812,2,2,1,3,0)
  1  Reason for inactivation
"KRN",8994,1812,2,2,1,4,0)
  2  Supporting evidence
"KRN",8994,1812,2,2,1,5,0)
  3  Lab Group
"KRN",8994,1812,2,2,1,6,0)
 
"KRN",8994,1812,2,2,1,7,0)
See description of the TYPE field (.02) of the ROR LIST ITEM file (#799.1)
"KRN",8994,1812,2,2,1,8,0)
for more details.
"KRN",8994,1812,2,"B","REGIEN",1)

"KRN",8994,1812,2,"B","TYPE",2)

"KRN",8994,1812,2,"PARAMSEQ",1,1)

"KRN",8994,1812,2,"PARAMSEQ",2,2)

"KRN",8994,1812,3,0)
^^23^23^3030425^
"KRN",8994,1812,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1812,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1812,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1812,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1812,3,5,0)
   
"KRN",8994,1812,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1812,3,7,0)
                          ^01: The last error code
"KRN",8994,1812,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1812,3,9,0)
                                                                      
"KRN",8994,1812,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1812,3,11,0)
                          ^01: Error code
"KRN",8994,1812,3,12,0)
                          ^02: Message
"KRN",8994,1812,3,13,0)
                          ^03: Place of the error
"KRN",8994,1812,3,14,0)
 
"KRN",8994,1812,3,15,0)
Otherwise, number of list items is returned in the Results[0] and the
"KRN",8994,1812,3,16,0)
subsequent nodes of the array contain the items.
"KRN",8994,1812,3,17,0)
  
"KRN",8994,1812,3,18,0)
   Results[0]            Number of Items
"KRN",8994,1812,3,19,0)
  
"KRN",8994,1812,3,20,0)
   Results[i]            List Item
"KRN",8994,1812,3,21,0)
                           ^01: IEN
"KRN",8994,1812,3,22,0)
                           ^02: Text
"KRN",8994,1812,3,23,0)
                           ^03: Code
"KRN",8994,1813,-1)
0^26
"KRN",8994,1813,0)
ROR LIST COORDINATORS^RCLIST^RORRP023^4^P^^^1^1
"KRN",8994,1813,1,0)
^8994.01^3^3^3030624^^^^
"KRN",8994,1813,1,1,0)
The ROR LIST COORDINATORS remote procedure returns a list of registry 
"KRN",8994,1813,1,2,0)
coordinators. The list is retrieved from the COORDINATOR multiple (14) of
"KRN",8994,1813,1,3,0)
the ROR REGISTRY PARAMETERS file (#798.1).
"KRN",8994,1813,2,0)
^8994.02A^1^1
"KRN",8994,1813,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1813,2,1,1,0)
^8994.021^2^2^3030624^^^^
"KRN",8994,1813,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the 
"KRN",8994,1813,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1813,2,"B","REGIEN",1)

"KRN",8994,1813,2,"PARAMSEQ",1,1)

"KRN",8994,1813,3,0)
^8994.03^22^22^3030624^^^
"KRN",8994,1813,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1813,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1813,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1813,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1813,3,5,0)
  
"KRN",8994,1813,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1813,3,7,0)
                          ^01: The last error code
"KRN",8994,1813,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1813,3,9,0)
                                                                      
"KRN",8994,1813,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1813,3,11,0)
                          ^01: Error code
"KRN",8994,1813,3,12,0)
                          ^02: Message
"KRN",8994,1813,3,13,0)
                          ^03: Place of the error
"KRN",8994,1813,3,14,0)
 
"KRN",8994,1813,3,15,0)
Otherwise, number of coordinators is returned in the Results[0] and the 
"KRN",8994,1813,3,16,0)
subsequent nodes of the global array contain the coordinators.
"KRN",8994,1813,3,17,0)
 
"KRN",8994,1813,3,18,0)
  Results[0]            Number of Coordinators
"KRN",8994,1813,3,19,0)
 
"KRN",8994,1813,3,20,0)
  Results[i]            Coordinator's Descriptor
"KRN",8994,1813,3,21,0)
                          ^01: IEN
"KRN",8994,1813,3,22,0)
                          ^02: Name
"KRN",8994,1814,-1)
0^27
"KRN",8994,1814,0)
ROR UPDATE COORDINATORS^RCLUPD^RORRP023^2^R^^^1^1
"KRN",8994,1814,1,0)
^8994.01^3^3^3030409^^
"KRN",8994,1814,1,1,0)
The ROR UPDATE COORDINATORS remote procedure updates the list of registry 
"KRN",8994,1814,1,2,0)
coordinators that is stored in the COORDINATOR (14) multiple of the ROR 
"KRN",8994,1814,1,3,0)
REGISTRY PARAMETERS file (#798.1).
"KRN",8994,1814,2,0)
^8994.02A^2^2
"KRN",8994,1814,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1814,2,1,1,0)
^^2^2^3030409^
"KRN",8994,1814,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the 
"KRN",8994,1814,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1814,2,2,0)
RCLST^2^^1^2
"KRN",8994,1814,2,2,1,0)
^^11^11^3030409^
"KRN",8994,1814,2,2,1,1,0)
The RCLST parameter should be an array containing a list of user IENs
"KRN",8994,1814,2,2,1,2,0)
(DUZs). The corresponding users will be designated as the registry
"KRN",8994,1814,2,2,1,3,0)
coordinators.
"KRN",8994,1814,2,2,1,4,0)
 
"KRN",8994,1814,2,2,1,5,0)
Example:
"KRN",8994,1814,2,2,1,6,0)
  with RPCBroker.Param[1] do
"KRN",8994,1814,2,2,1,7,0)
    begin
"KRN",8994,1814,2,2,1,8,0)
      PType :=list;
"KRN",8994,1814,2,2,1,9,0)
      for i := 1 to Coordinators.Count do
"KRN",8994,1814,2,2,1,10,0)
        Mult[i] := Coordinators[i-1].IEN;
"KRN",8994,1814,2,2,1,11,0)
    end;
"KRN",8994,1814,2,"B","RCLST",2)

"KRN",8994,1814,2,"B","REGIEN",1)

"KRN",8994,1814,2,"PARAMSEQ",1,1)

"KRN",8994,1814,2,"PARAMSEQ",2,2)

"KRN",8994,1814,3,0)
^^15^15^3030425^
"KRN",8994,1814,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1814,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1814,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1814,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1814,3,5,0)
  
"KRN",8994,1814,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1814,3,7,0)
                          ^01: The last error code
"KRN",8994,1814,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1814,3,9,0)
                                                                      
"KRN",8994,1814,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1814,3,11,0)
                          ^01: Error code
"KRN",8994,1814,3,12,0)
                          ^02: Message
"KRN",8994,1814,3,13,0)
                          ^03: Place of the error
"KRN",8994,1814,3,14,0)
 
"KRN",8994,1814,3,15,0)
Otherwise, zero is returned in the Results[0].
"KRN",8994,1815,-1)
0^28
"KRN",8994,1815,0)
ROR LIST VISTA USERS^USERLIST^RORRP024^4^R^^^1^1
"KRN",8994,1815,1,0)
^8994.01^2^2^3040203^^^^
"KRN",8994,1815,1,1,0)
The ROR LIST VISTA USERS remote procedure returns a list of users from the
"KRN",8994,1815,1,2,0)
NEW PERSON file (#200).
"KRN",8994,1815,2,0)
^8994.02A^6^4
"KRN",8994,1815,2,3,0)
PART^1^30^1^1
"KRN",8994,1815,2,3,1,0)
^^2^2^3030409^
"KRN",8994,1815,2,3,1,1,0)
The PART parameter defines the search pattern. It should contain the
"KRN",8994,1815,2,3,1,2,0)
beginning of the user's name.
"KRN",8994,1815,2,4,0)
FLAGS^1^^^2
"KRN",8994,1815,2,4,1,0)
^^9^9^3040203^
"KRN",8994,1815,2,4,1,1,0)
Flags that control the execution (can be combined):
"KRN",8994,1815,2,4,1,2,0)
 
"KRN",8994,1815,2,4,1,3,0)
  B  Backwards. Traverses the index in the opposite
"KRN",8994,1815,2,4,1,4,0)
     direction of normal traversal.
"KRN",8994,1815,2,4,1,5,0)
 
"KRN",8994,1815,2,4,1,6,0)
  D  Get default division for each user
"KRN",8994,1815,2,4,1,7,0)
 
"KRN",8994,1815,2,4,1,8,0)
  P  Select providers only (check for the PROVIDER
"KRN",8994,1815,2,4,1,9,0)
     security key).
"KRN",8994,1815,2,5,0)
NUMBER^1^^^3
"KRN",8994,1815,2,5,1,0)
^8994.021^2^2^3030409^^^
"KRN",8994,1815,2,5,1,1,0)
Maximum number of entries to return. A value of "*" or no value in this 
"KRN",8994,1815,2,5,1,2,0)
parameter designates all entries that conform the criteria.
"KRN",8994,1815,2,6,0)
FROM^1^^^4
"KRN",8994,1815,2,6,1,0)
^8994.021^9^9^3040203^^^
"KRN",8994,1815,2,6,1,1,0)
The index entry(s) from which to begin the list. Use the pieces of the
"KRN",8994,1815,2,6,1,2,0)
Results[0] (starting from the second one) to continue the listing in the
"KRN",8994,1815,2,6,1,3,0)
subsequent procedure calls.
"KRN",8994,1815,2,6,1,4,0)
 
"KRN",8994,1815,2,6,1,5,0)
NOTE: The FROM value itself is not included in the
"KRN",8994,1815,2,6,1,6,0)
      resulting list.
"KRN",8994,1815,2,6,1,7,0)
 
"KRN",8994,1815,2,6,1,8,0)
See description of the LIST^DIC for more details about the PART, NUMBER
"KRN",8994,1815,2,6,1,9,0)
and FROM parameters.
"KRN",8994,1815,2,"B","FLAGS",4)

"KRN",8994,1815,2,"B","FROM",6)

"KRN",8994,1815,2,"B","NUMBER",5)

"KRN",8994,1815,2,"B","PART",3)

"KRN",8994,1815,2,"PARAMSEQ",1,3)

"KRN",8994,1815,2,"PARAMSEQ",2,4)

"KRN",8994,1815,2,"PARAMSEQ",3,5)

"KRN",8994,1815,2,"PARAMSEQ",4,6)

"KRN",8994,1815,3,0)
^^30^30^3040203^
"KRN",8994,1815,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1815,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1815,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1815,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1815,3,5,0)
  
"KRN",8994,1815,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1815,3,7,0)
                          ^01: The last error code
"KRN",8994,1815,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1815,3,9,0)
   
"KRN",8994,1815,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1815,3,11,0)
                          ^01: Error code
"KRN",8994,1815,3,12,0)
                          ^02: Message
"KRN",8994,1815,3,13,0)
                          ^03: Place of the error
"KRN",8994,1815,3,14,0)
 
"KRN",8994,1815,3,15,0)
Otherwise, number of VistA users and the value of the FROM parameter for
"KRN",8994,1815,3,16,0)
the next procedure call are returned in the Results[0] and the subsequent
"KRN",8994,1815,3,17,0)
nodes of the Results array contain the users.
"KRN",8994,1815,3,18,0)
  
"KRN",8994,1815,3,19,0)
  Results[0]            Result Descriptor
"KRN",8994,1815,3,20,0)
                          ^01: Number of users
"KRN",8994,1815,3,21,0)
                          ^02: Values that comprise the FROM parameter
"KRN",8994,1815,3,22,0)
                          ^nn: for the subsequent call of the procedure
"KRN",8994,1815,3,23,0)
 
"KRN",8994,1815,3,24,0)
  Results[i]            VistA User
"KRN",8994,1815,3,25,0)
                          ^01: IEN (DUZ)
"KRN",8994,1815,3,26,0)
                          ^02: Name
"KRN",8994,1815,3,27,0)
                          ^03: Office Phone
"KRN",8994,1815,3,28,0)
                          ^04: Nickname
"KRN",8994,1815,3,29,0)
                          ^06: Default Division IEN  (only if D flag)
"KRN",8994,1815,3,30,0)
                          ^07: Default Division Name (only if D flag)
"KRN",8994,1816,-1)
0^30
"KRN",8994,1816,0)
RORICR CDC LOAD^LOADCDC^RORRP025^2^R^^^1^1
"KRN",8994,1816,1,0)
^8994.01^2^2^3040203^^^^
"KRN",8994,1816,1,1,0)
The RORICR CDC LOAD remote procedure loads the data for the CDC form 
"KRN",8994,1816,1,2,0)
that is edited/printed by the ICR registry.
"KRN",8994,1816,2,0)
^8994.02A^3^3
"KRN",8994,1816,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1816,2,1,1,0)
^^2^2^3030411^
"KRN",8994,1816,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1816,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1816,2,2,0)
PATIEN^1^^1^2
"KRN",8994,1816,2,2,1,0)
^8994.021^1^1^3030716^^^^
"KRN",8994,1816,2,2,1,1,0)
A valid patient IEN (DFN) should be assigned to the PATIEN parameter.
"KRN",8994,1816,2,3,0)
LOCK^1^^^3
"KRN",8994,1816,2,3,1,0)
^8994.021^2^2^3040203^^^
"KRN",8994,1816,2,3,1,1,0)
If this parameter is defined and not zero then the RPC will try to lock
"KRN",8994,1816,2,3,1,2,0)
the registry record before loading the data and will leave it locked.
"KRN",8994,1816,2,"B","LOCK",3)

"KRN",8994,1816,2,"B","PATIEN",2)

"KRN",8994,1816,2,"B","REGIEN",1)

"KRN",8994,1816,2,"PARAMSEQ",1,1)

"KRN",8994,1816,2,"PARAMSEQ",2,2)

"KRN",8994,1816,2,"PARAMSEQ",3,3)

"KRN",8994,1816,3,0)
^^264^264^3040203^
"KRN",8994,1816,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1816,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1816,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1816,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1816,3,5,0)
   
"KRN",8994,1816,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1816,3,7,0)
                          ^01: The last error code
"KRN",8994,1816,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1816,3,9,0)
                                                                      
"KRN",8994,1816,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1816,3,11,0)
                          ^01: Error code
"KRN",8994,1816,3,12,0)
                          ^02: Message
"KRN",8994,1816,3,13,0)
                          ^03: Place of the error
"KRN",8994,1816,3,14,0)
 
"KRN",8994,1816,3,15,0)
If locking was requested (see the LOCK parameter) and the record could not
"KRN",8994,1816,3,16,0)
be locked then the first "^"-piece of the Results[0] would be greater than
"KRN",8994,1816,3,17,0)
0. The Results[0] would contain the lock descriptor and subsequent nodes
"KRN",8994,1816,3,18,0)
of the global array would contain the data (see below). The lock 
"KRN",8994,1816,3,19,0)
descriptor contains information about the process, which owns the most 
"KRN",8994,1816,3,20,0)
recent lock of the record.
"KRN",8994,1816,3,21,0)
 
"KRN",8994,1816,3,22,0)
  Results[0]            Lock Descriptor
"KRN",8994,1816,3,23,0)
                          ^01: Date/Time (FileMan)
"KRN",8994,1816,3,24,0)
                          ^02: User/Process name
"KRN",8994,1816,3,25,0)
                          ^03: User IEN (DUZ)
"KRN",8994,1816,3,26,0)
                          ^04: $JOB
"KRN",8994,1816,3,27,0)
                          ^05: Task number
"KRN",8994,1816,3,28,0)
 
"KRN",8994,1816,3,29,0)
THE DATA ARE LOADED ONLY FOR VIEWING PURPOSES (READ-ONLY)!
"KRN",8994,1816,3,30,0)
 
"KRN",8994,1816,3,31,0)
Otherwise, zero is returned in the Results[0] and the subsequent nodes of
"KRN",8994,1816,3,32,0)
the array contain the data. Some data items are optional (for example, RCE
"KRN",8994,1816,3,33,0)
and ETN). Some other items can be repeated (e.g. AID and CMT).
"KRN",8994,1816,3,34,0)
 
"KRN",8994,1816,3,35,0)
  Results[0]            0
"KRN",8994,1816,3,36,0)
 
"KRN",8994,1816,3,37,0)
  Results[i]            Demographic Information
"KRN",8994,1816,3,38,0)
                          ^01: "DEM"
"KRN",8994,1816,3,39,0)
                          ^02: ""
"KRN",8994,1816,3,40,0)
                          ^03: Patient IEN (DFN)
"KRN",8994,1816,3,41,0)
                          ^04: Patient Name
"KRN",8994,1816,3,42,0)
                          ^05: Date of Birth (FileMan)
"KRN",8994,1816,3,43,0)
                          ^06: SSN
"KRN",8994,1816,3,44,0)
                          ^07: Date of Death (FileMan)
"KRN",8994,1816,3,45,0)
                          ^08: Sex (F/M)
"KRN",8994,1816,3,46,0)
 
"KRN",8994,1816,3,47,0)
  Results[i]            Patient's Address
"KRN",8994,1816,3,48,0)
                          ^01: "ADR"
"KRN",8994,1816,3,49,0)
                          ^02: ""
"KRN",8994,1816,3,50,0)
                          ^03: Address (1)
"KRN",8994,1816,3,51,0)
                          ^04: Address (2)
"KRN",8994,1816,3,52,0)
                          ^05: Address (3)
"KRN",8994,1816,3,53,0)
                          ^06: City
"KRN",8994,1816,3,54,0)
                          ^07: State (IEN)
"KRN",8994,1816,3,55,0)
                          ^08: State (Name)
"KRN",8994,1816,3,56,0)
                          ^09: ZIP
"KRN",8994,1816,3,57,0)
                          ^10: ZIP+4
"KRN",8994,1816,3,58,0)
                          ^11: County (IEN)
"KRN",8994,1816,3,59,0)
                          ^12: County (Name)
"KRN",8994,1816,3,60,0)
                          ^13: Home Phone
"KRN",8994,1816,3,61,0)
 
"KRN",8994,1816,3,62,0)
  Results[i]            Race Information
"KRN",8994,1816,3,63,0)
                          ^01: "RCE"
"KRN",8994,1816,3,64,0)
                          ^02: Race IEN
"KRN",8994,1816,3,65,0)
                          ^03: Race HL7 Value
"KRN",8994,1816,3,66,0)
                          ^04: Race
"KRN",8994,1816,3,67,0)
                          ^05: Collection Method HL7 Value
"KRN",8994,1816,3,68,0)
                          ^06: Collection Method
"KRN",8994,1816,3,69,0)
 
"KRN",8994,1816,3,70,0)
                        Race HL7 Values
"KRN",8994,1816,3,71,0)
                          1002-5  American Indian or Alaska Native
"KRN",8994,1816,3,72,0)
                          2028-9  Asian
"KRN",8994,1816,3,73,0)
                          2054-5  Black or African American
"KRN",8994,1816,3,74,0)
                          0000-0  Declined to Answer
"KRN",8994,1816,3,75,0)
                          2076-8  Native Hawaiian or Pacific Islander
"KRN",8994,1816,3,76,0)
                          9999-4  Unknown by Patient
"KRN",8994,1816,3,77,0)
                          2106-3  White
"KRN",8994,1816,3,78,0)
 
"KRN",8994,1816,3,79,0)
                        Collection Method HL7 Values
"KRN",8994,1816,3,80,0)
                          OBS     Observer
"KRN",8994,1816,3,81,0)
                          PRX     Proxy
"KRN",8994,1816,3,82,0)
                          SLF     Self Identification
"KRN",8994,1816,3,83,0)
                          UNK     Unknown
"KRN",8994,1816,3,84,0)
 
"KRN",8994,1816,3,85,0)
  Results[i]            Ethnicity Information
"KRN",8994,1816,3,86,0)
                          ^01: "ETN"
"KRN",8994,1816,3,87,0)
                          ^02: Ethnicity IEN
"KRN",8994,1816,3,88,0)
                          ^03: Ethnicity HL7 Value
"KRN",8994,1816,3,89,0)
                          ^04: Ethnicity
"KRN",8994,1816,3,90,0)
                          ^05: Collection Method HL7 value
"KRN",8994,1816,3,91,0)
                          ^06: Collection Method
"KRN",8994,1816,3,92,0)
 
"KRN",8994,1816,3,93,0)
                        Ethnicity HL7 Values
"KRN",8994,1816,3,94,0)
                          0000-0  Declined to Answer
"KRN",8994,1816,3,95,0)
                          2135-2  Hispanic or Latino
"KRN",8994,1816,3,96,0)
                          2186-5  Not Hispanic or Latino
"KRN",8994,1816,3,97,0)
                          9999-4  Unknown by Patient
"KRN",8994,1816,3,98,0)
 
"KRN",8994,1816,3,99,0)
  Results[i]            Form Headers
"KRN",8994,1816,3,100,0)
                          ^01: "HDR"
"KRN",8994,1816,3,101,0)
                          ^02: ""
"KRN",8994,1816,3,102,0)
                          ^03: DATE CDC FORM COMPLETED (FileMan)
"KRN",8994,1816,3,103,0)
                          ^04: CDC FORM COMPLETED BY (DUZ)
"KRN",8994,1816,3,104,0)
                          ^05: CDC FORM COMPLETED BY (Name)
"KRN",8994,1816,3,105,0)
                          ^06: Phone number of person completed form
"KRN",8994,1816,3,106,0)
                          ^07: Medical Record Number
"KRN",8994,1816,3,107,0)
 
"KRN",8994,1816,3,108,0)
  Results[i]            CDC Demographics (III)
"KRN",8994,1816,3,109,0)
                          ^01: "CDM"
"KRN",8994,1816,3,110,0)
                          ^02: ""
"KRN",8994,1816,3,111,0)
                          ^03: STATUS AT REPORT {1|2}
"KRN",8994,1816,3,112,0)
                          ^04: AGE AT DIAGNOSIS
"KRN",8994,1816,3,113,0)
                          ^05: PATIENT STATUS {1|2|9}
"KRN",8994,1816,3,114,0)
                          ^06: STATE/TERRITORY OF DEATH
"KRN",8994,1816,3,115,0)
                          ^07: COUNTRY OF BIRTH {1|7|8|9}
"KRN",8994,1816,3,116,0)
                          ^08: DEPENDENCY/OTHER COUNTRY DESCRIPTION
"KRN",8994,1816,3,117,0)
                          ^09: ONSET OF ILLNESS/AIDS- CITY
"KRN",8994,1816,3,118,0)
                          ^10: ONSET OF ILLNESS/AIDS- COUNTY
"KRN",8994,1816,3,119,0)
                          ^11: ONSET OF ILLNESS/AIDS- STATE (IEN)
"KRN",8994,1816,3,120,0)
                          ^12: ONSET OF ILLNESS/AIDS- STATE (Name)
"KRN",8994,1816,3,121,0)
                          ^13: ONSET OF ILLNESS/AIDS- COUNTRY
"KRN",8994,1816,3,122,0)
                          ^14: ONSET OF ILLNESS/AIDS- ZIP
"KRN",8994,1816,3,123,0)
 
"KRN",8994,1816,3,124,0)
  Results[i]            Facility of Diagnosis (IV)
"KRN",8994,1816,3,125,0)
                          ^01: "FD"
"KRN",8994,1816,3,126,0)
                          ^02: ""
"KRN",8994,1816,3,127,0)
                          ^03: AIDS DX - HOSPITAL
"KRN",8994,1816,3,128,0)
                          ^04: AIDS DX - CITY
"KRN",8994,1816,3,129,0)
                          ^05: AIDS DX - STATE (IEN)
"KRN",8994,1816,3,130,0)
                          ^06: AIDS DX - STATE (Name)
"KRN",8994,1816,3,131,0)
                          ^07: AIDS DX - COUNTRY
"KRN",8994,1816,3,132,0)
                          ^08: AIDS DX - FACILITY SETTING {1|2|3|9}
"KRN",8994,1816,3,133,0)
                          ^09: AIDS DX - FACILITY TYPE {01|31|88}
"KRN",8994,1816,3,134,0)
                          ^10: AIDS DX - OTHER FACILITY TYPE
"KRN",8994,1816,3,135,0)
 
"KRN",8994,1816,3,136,0)
  Results[i]            Patient History (V)
"KRN",8994,1816,3,137,0)
                          ^01: "PH"
"KRN",8994,1816,3,138,0)
                          ^02: ""
"KRN",8994,1816,3,139,0)
                          ^03: SEX RELATIONS W/MALE PARTNER   {0|1|9}
"KRN",8994,1816,3,140,0)
                          ^04: SEX RELATIONS W/FEMALE PARTNER {0|1|9}
"KRN",8994,1816,3,141,0)
                          ^05: IV DRUGS AFTER 77 AND PRE HIV  {0|1|9}
"KRN",8994,1816,3,142,0)
                          ^06: REC'D CLOTTING FACTORS         {0|1|9}
"KRN",8994,1816,3,143,0)
                          ^07: TYPE OF HEMOPHILIA             {1|2|8}
"KRN",8994,1816,3,144,0)
                          ^08: OTHER HEMOPHILIA DESCRIPTION
"KRN",8994,1816,3,145,0)
                          ^09: SR WITH IV DRUG USER           {0|1|9}
"KRN",8994,1816,3,146,0)
                          ^10: SR WITH BISEXUAL MAN           {0|1|9}
"KRN",8994,1816,3,147,0)
                          ^11: SR W HEMOPHILIA/COAG DISORDER  {0|1|9}
"KRN",8994,1816,3,148,0)
                          ^12: SR W TRANS RECIPIENT WITH AIDS {0|1|9}
"KRN",8994,1816,3,149,0)
                          ^13: TRANSPLANT RECIP-DOCUMNTD HIV  {0|1|9}
"KRN",8994,1816,3,150,0)
                          ^14: SR W AIDS/HIV INFECTION        {0|1|9}
"KRN",8994,1816,3,151,0)
                          ^15: TRANS AFTER 77 AND BEFORE HIV  {0|1|9}
"KRN",8994,1816,3,152,0)
                          ^16: DATE OF FIRST TRANSFUSION      (MM/YY)
"KRN",8994,1816,3,153,0)
                          ^17: DATE OF LAST TRANSFUSION       (MM/YY)
"KRN",8994,1816,3,154,0)
                          ^18: TRANSPLANT OR ARTIF INSEMIN    {0|1|9}
"KRN",8994,1816,3,155,0)
                          ^19: WORK IN HEALTH CARE OR LAB     {0|1|9}
"KRN",8994,1816,3,156,0)
                          ^20: OCCUPATION
"KRN",8994,1816,3,157,0)
 
"KRN",8994,1816,3,158,0)
  Results[i]            Laboratory Data (VI)
"KRN",8994,1816,3,159,0)
 
"KRN",8994,1816,3,160,0)
                          ^01: "LD1"
"KRN",8994,1816,3,161,0)
                          ^02: ""
"KRN",8994,1816,3,162,0)
                          ^03: HIV-1 EIA                      {0|1|9}
"KRN",8994,1816,3,163,0)
                          ^04: HIV-1 EIA DATE                 (MM/YY)
"KRN",8994,1816,3,164,0)
                          ^05: HIV-1/HIV-2 EIA                {0|1|9}
"KRN",8994,1816,3,165,0)
                          ^06: HIV-1/HIV-2 EIA DATE           (MM/YY)
"KRN",8994,1816,3,166,0)
                          ^07: HIV-1 WESTERN BLOT/IFA         {0|1|8|9}
"KRN",8994,1816,3,167,0)
                          ^08: HIV-1 WESTERN BLOT/IFA DATE    (MM/YY)
"KRN",8994,1816,3,168,0)
                          ^09: OTHER HIV ANTIBODY TEST        {0|1|8|9}
"KRN",8994,1816,3,169,0)
                          ^10: OTHER HIV ANTIBODY TEST DATE   (MM/YY)
"KRN",8994,1816,3,170,0)
                          ^11: OTHER HIV ANTIBODY TEST DESC
"KRN",8994,1816,3,171,0)
                          ^12: Positive HIV Detection Test    {1|2|3}
"KRN",8994,1816,3,172,0)
                          ^13: Date of the HIV Detection test (MM/YY)
"KRN",8994,1816,3,173,0)
                          ^14: TYPE OF OTHER POSITIVE TEST
"KRN",8994,1816,3,174,0)
                          ^15: DATE OTHER POS DETECTION TEST  (MM/YY)
"KRN",8994,1816,3,175,0)
                          ^16: DETECTABLE VIRAL LOAD TEST {11|12|13|18}
"KRN",8994,1816,3,176,0)
                          ^17: DETECTABLE VIRAL LOAD RESULT
"KRN",8994,1816,3,177,0)
                          ^18: DETECTABLE VIRAL LOAD DATE     (MM/YY)
"KRN",8994,1816,3,178,0)
 
"KRN",8994,1816,3,179,0)
                          ^01: "LD2"
"KRN",8994,1816,3,180,0)
                          ^02: ""
"KRN",8994,1816,3,181,0)
                          ^03: TYPE FOR LAST NEG TEST
"KRN",8994,1816,3,182,0)
                          ^04: LAST DOCUMNTD NEG HIV TEST     (MM/YY)
"KRN",8994,1816,3,183,0)
                          ^05: PHYS DOCUMNTD DIAGNOSIS?       {0|1|9}
"KRN",8994,1816,3,184,0)
                          ^06: DATE PHYS DOCUMNTD DIAG        (MM/YY)
"KRN",8994,1816,3,185,0)
                          ^07: CD4+ COUNT FOR CDC
"KRN",8994,1816,3,186,0)
                          ^08: CD4+ COUNT FOR CDC DATE        (MM/YY)
"KRN",8994,1816,3,187,0)
                          ^09: CD4+ PERCENT FOR CDC
"KRN",8994,1816,3,188,0)
                          ^10: CD4+ PERCENT FOR CDC DATE      (MM/YY)
"KRN",8994,1816,3,189,0)
                          ^11: CD4 COUNT FIRST <200
"KRN",8994,1816,3,190,0)
                          ^12: CD4 COUNT FIRST <200 DATE      (MM/YY)
"KRN",8994,1816,3,191,0)
                          ^13: CD4 PERCENT FIRST <14%
"KRN",8994,1816,3,192,0)
                          ^14: CD4 PERCENT FIRST <14% DATE    (MM/YY)
"KRN",8994,1816,3,193,0)
 
"KRN",8994,1816,3,194,0)
  Results[i]            Clinical Status (VIII)
"KRN",8994,1816,3,195,0)
                          ^01: "CS"
"KRN",8994,1816,3,196,0)
                          ^02: ""
"KRN",8994,1816,3,197,0)
                          ^03: RECORD REVIEWED {0|1}
"KRN",8994,1816,3,198,0)
                          ^04: DATE ASYMPTOMATIC              (MM/YY)
"KRN",8994,1816,3,199,0)
                          ^05: DATE SYMPTOMATIC               (MM/YY)
"KRN",8994,1816,3,200,0)
                          ^06: RVCT CASE NO.
"KRN",8994,1816,3,201,0)
                          ^07: IMMUNODEF THAT DISQUALIFIES    {0|1|9}
"KRN",8994,1816,3,202,0)
 
"KRN",8994,1816,3,203,0)
  Results[i]            AIDS Indicator Disease (VIII)
"KRN",8994,1816,3,204,0)
                          ^01: "AID"
"KRN",8994,1816,3,205,0)
                          ^02: Disease Code
"KRN",8994,1816,3,206,0)
                          ^03: Initial Diagnosis              {1|2}
"KRN",8994,1816,3,207,0)
                          ^04: Initial Date                   (MM/YY)
"KRN",8994,1816,3,208,0)
 
"KRN",8994,1816,3,209,0)
                        Disease Codes:
"KRN",8994,1816,3,210,0)
                            1  CANDIDIASIS, B, T, OR L
"KRN",8994,1816,3,211,0)
                            2  CANDIDIASIS, ESOPHAGEAL
"KRN",8994,1816,3,212,0)
                            3  CARCINOMA, INVASIVE CERVICAL
"KRN",8994,1816,3,213,0)
                            4  COCCIDIOIDOMYCOSIS, DIS/EXTRAP
"KRN",8994,1816,3,214,0)
                            5  CRYPTOCOCCOSIS, EXTRAPULMONARY
"KRN",8994,1816,3,215,0)
                            6  CRYPTOSPORIDIOSIS, CHRONIC
"KRN",8994,1816,3,216,0)
                            7  CYTOMEGALOVIRUS DISEASE
"KRN",8994,1816,3,217,0)
                            8  CYTOMEGALOVIRUS RETINITIS
"KRN",8994,1816,3,218,0)
                            9  HIV ENCEPHALOPATHY
"KRN",8994,1816,3,219,0)
                           10  HERPES SIMPLEX
"KRN",8994,1816,3,220,0)
                           11  HISTOPLASMOSIS, DIS/EXTRAP
"KRN",8994,1816,3,221,0)
                           12  ISOSPORIASIS, CHRONIC INTEST
"KRN",8994,1816,3,222,0)
                           13  KAPOSI'S SARCOMA
"KRN",8994,1816,3,223,0)
                           14  LYMPHOMA, BURKITT'S
"KRN",8994,1816,3,224,0)
                           15  LYMPHOMA, IMMUNOBLASTIC
"KRN",8994,1816,3,225,0)
                           16  LYMPHOMA, PRIMARY IN BRAIN
"KRN",8994,1816,3,226,0)
                           17  MYCOBACTERIUM AVIUM COMPLEX
"KRN",8994,1816,3,227,0)
                           18  M. TUBERCULOSIS, PULMONARY
"KRN",8994,1816,3,228,0)
                           19  M TUBERCULOSIS, DIS/EXTRAP
"KRN",8994,1816,3,229,0)
                           20  MYCOBACTERIUM
"KRN",8994,1816,3,230,0)
                           21  PNEUMOCYSTIS CARINII PNEUMONIA
"KRN",8994,1816,3,231,0)
                           22  PNEUMONIA, RECURRENT IN 12 MO
"KRN",8994,1816,3,232,0)
                           23  PROGRESSIVE MULTIFOCAL LEUKO
"KRN",8994,1816,3,233,0)
                           24  SALMONELLA SEPTICEMIA, RECURR
"KRN",8994,1816,3,234,0)
                           25  TOXOPLASMOSIS OF BRAIN
"KRN",8994,1816,3,235,0)
                           26  WASTING SYNDROME DUE TO HIV
"KRN",8994,1816,3,236,0)
 
"KRN",8994,1816,3,237,0)
  Results[i]            Treatment/Services (IX)
"KRN",8994,1816,3,238,0)
 
"KRN",8994,1816,3,239,0)
                          ^01: "TS1"
"KRN",8994,1816,3,240,0)
                          ^02: ""
"KRN",8994,1816,3,241,0)
                          ^03: PATIENT BEEN INFORMED OF HIV   {0|1|9}
"KRN",8994,1816,3,242,0)
                          ^04: PARTNERS NOTIFIED BY           {1|2|3|9}
"KRN",8994,1816,3,243,0)
                          ^05: HIV RELATED MED SERVICES
"KRN",8994,1816,3,244,0)
                          ^06: SUBSTANCE ABUSE TREATMENT      {0|1|8|9}
"KRN",8994,1816,3,245,0)
                          ^07: RCVD ANTI-RETROVIRAL THERAPY   {0|1|9}
"KRN",8994,1816,3,246,0)
                          ^08: RECEIVED PCP PROPHYLAXIS       {0|1|9}
"KRN",8994,1816,3,247,0)
                          ^09: ENROLLED AT CLINCAL TRIAL      {1|2|3|9}
"KRN",8994,1816,3,248,0)
                          ^10: ENROLLED AT CLINIC             {1|2|3|9}
"KRN",8994,1816,3,249,0)
                          ^11: PRIMARY REIMBURSER FOR MED RX {1|2|3|4|7|9}
"KRN",8994,1816,3,250,0)
 
"KRN",8994,1816,3,251,0)
                          ^01: "TS2"
"KRN",8994,1816,3,252,0)
                          ^02: ""    
"KRN",8994,1816,3,253,0)
                          ^03: GYNECOLOGY OR OBSTETRIC CARE   {0|1|9}
"KRN",8994,1816,3,254,0)
                          ^04: CURRENTLY PREGNANT             {0|1|9}
"KRN",8994,1816,3,255,0)
                          ^05: DELIVERED LIVE BORN INFANT     {0|1|9}
"KRN",8994,1816,3,256,0)
                          ^06: CHILD'S DATE OF BIRTH
"KRN",8994,1816,3,257,0)
                          ^07: CHILD'S HOSPITAL OF BIRTH
"KRN",8994,1816,3,258,0)
                          ^08: CHILD'S HOSPITAL - CITY
"KRN",8994,1816,3,259,0)
                          ^09: CHILD'S HOSPITAL - STATE
"KRN",8994,1816,3,260,0)
 
"KRN",8994,1816,3,261,0)
  Results[i]            Comments (X)
"KRN",8994,1816,3,262,0)
                          ^01: "CMT"
"KRN",8994,1816,3,263,0)
                          ^02: [1-3]
"KRN",8994,1816,3,264,0)
                          ^03: Comment
"KRN",8994,1818,-1)
0^31
"KRN",8994,1818,0)
ROR LIST STATES^STATELST^RORRP029^4^R^^^1^1
"KRN",8994,1818,1,0)
^8994.01^2^2^3030425^^
"KRN",8994,1818,1,1,0)
The ROR LIST STATES remote procedure returns a list of states that conform
"KRN",8994,1818,1,2,0)
the search criteria.
"KRN",8994,1818,2,0)
^8994.02A^4^4
"KRN",8994,1818,2,1,0)
PART^1^30^1^1
"KRN",8994,1818,2,1,1,0)
^^4^4^3030414^
"KRN",8994,1818,2,1,1,1,0)
The PART parameter defines the search pattern. If it contains 2 character
"KRN",8994,1818,2,1,1,2,0)
abbreviation of the state and the FLAGS parameter contains "A" then the
"KRN",8994,1818,2,1,1,3,0)
corresponding state is returned (see the FLAGS parameter for more
"KRN",8994,1818,2,1,1,4,0)
details). Otherwise, the regular search among state names is performed.
"KRN",8994,1818,2,2,0)
FLAGS^1^^^2
"KRN",8994,1818,2,2,1,0)
^^10^10^3030414^
"KRN",8994,1818,2,2,1,1,0)
Flags that control the execution (can be combined):
"KRN",8994,1818,2,2,1,2,0)
 
"KRN",8994,1818,2,2,1,3,0)
  A  Enable abbreviation search. If PART contains 2
"KRN",8994,1818,2,2,1,4,0)
     character abbreviation, the corresponding state
"KRN",8994,1818,2,2,1,5,0)
     is returned. If the length of PART parameter is
"KRN",8994,1818,2,2,1,6,0)
     not equal 2 or it does not contain a valid state
"KRN",8994,1818,2,2,1,7,0)
     abbreviation then the regular search is performed.
"KRN",8994,1818,2,2,1,8,0)
 
"KRN",8994,1818,2,2,1,9,0)
  B  Backwards. Traverses the index in the opposite
"KRN",8994,1818,2,2,1,10,0)
     direction of normal traversal.
"KRN",8994,1818,2,3,0)
NUMBER^1^^^3
"KRN",8994,1818,2,3,1,0)
^^2^2^3030414^
"KRN",8994,1818,2,3,1,1,0)
Maximum number of entries to return. A value of "*" or no value in this 
"KRN",8994,1818,2,3,1,2,0)
parameter designates all entries that conform the criteria.
"KRN",8994,1818,2,4,0)
FROM^1^^^4
"KRN",8994,1818,2,4,1,0)
^^9^9^3030425^
"KRN",8994,1818,2,4,1,1,0)
The index entry(s) from which to begin the list. Use the pieces of the
"KRN",8994,1818,2,4,1,2,0)
Results[0] (starting from the second one) to continue the listing in the
"KRN",8994,1818,2,4,1,3,0)
subsequent procedure calls.
"KRN",8994,1818,2,4,1,4,0)
  
"KRN",8994,1818,2,4,1,5,0)
NOTE: The FROM value itself is not included in the
"KRN",8994,1818,2,4,1,6,0)
      resulting list.
"KRN",8994,1818,2,4,1,7,0)
  
"KRN",8994,1818,2,4,1,8,0)
See description of the LIST^DIC for more details about the PART, NUMBER
"KRN",8994,1818,2,4,1,9,0)
and FROM parameters.
"KRN",8994,1818,2,"B","FLAGS",2)

"KRN",8994,1818,2,"B","FROM",4)

"KRN",8994,1818,2,"B","NUMBER",3)

"KRN",8994,1818,2,"B","PART",1)

"KRN",8994,1818,2,"PARAMSEQ",1,1)

"KRN",8994,1818,2,"PARAMSEQ",2,2)

"KRN",8994,1818,2,"PARAMSEQ",3,3)

"KRN",8994,1818,2,"PARAMSEQ",4,4)

"KRN",8994,1818,3,0)
^^28^28^3030425^
"KRN",8994,1818,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1818,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1818,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1818,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1818,3,5,0)
   
"KRN",8994,1818,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1818,3,7,0)
                          ^01: The last error code
"KRN",8994,1818,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1818,3,9,0)
   
"KRN",8994,1818,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1818,3,11,0)
                          ^01: Error code
"KRN",8994,1818,3,12,0)
                          ^02: Message
"KRN",8994,1818,3,13,0)
                          ^03: Place of the error
"KRN",8994,1818,3,14,0)
 
"KRN",8994,1818,3,15,0)
Otherwise, number of states and the value of the FROM parameter for the 
"KRN",8994,1818,3,16,0)
next procedure call are returned in the Results[0] and the subsequent 
"KRN",8994,1818,3,17,0)
nodes of the global array contain the states.
"KRN",8994,1818,3,18,0)
 
"KRN",8994,1818,3,19,0)
  Results[0]            Result Descriptor
"KRN",8994,1818,3,20,0)
                          ^01: Number of states
"KRN",8994,1818,3,21,0)
                          ^02: Values that comprise the FROM
"KRN",8994,1818,3,22,0)
                          ^nn: parameter for the subsequent call
"KRN",8994,1818,3,23,0)
                                                                     
"KRN",8994,1818,3,24,0)
  Results[i]            State
"KRN",8994,1818,3,25,0)
                          ^01: IEN
"KRN",8994,1818,3,26,0)
                          ^02: Name
"KRN",8994,1818,3,27,0)
                          ^03: Abbreviation
"KRN",8994,1818,3,28,0)
                          ^04: VA State Code
"KRN",8994,1819,-1)
0^32
"KRN",8994,1819,0)
RORICR CDC SAVE^SAVECDC^RORRP027^2^R^^^1^1
"KRN",8994,1819,1,0)
^8994.01^2^2^3030415^^^^
"KRN",8994,1819,1,1,0)
The RORICR CDC SAVE remote procedure updates the fields that are used by 
"KRN",8994,1819,1,2,0)
the ICR CDC form.
"KRN",8994,1819,2,0)
^8994.02A^4^4
"KRN",8994,1819,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1819,2,1,1,0)
^8994.021^2^2^3030415^^
"KRN",8994,1819,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1819,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1819,2,2,0)
PATIEN^1^^1^2
"KRN",8994,1819,2,2,1,0)
^8994.021^1^1^3030415^^
"KRN",8994,1819,2,2,1,1,0)
A valid patient IEN (DFN) should be assigned to the PATIEN parameter.
"KRN",8994,1819,2,3,0)
DATA^2^^1^4
"KRN",8994,1819,2,3,1,0)
^^25^25^3030415^
"KRN",8994,1819,2,3,1,1,0)
A list that contains the CDC data in the same format as the output of the
"KRN",8994,1819,2,3,1,2,0)
RORICR CDC LOAD remote procedure (see the RORRP025 routine and description
"KRN",8994,1819,2,3,1,3,0)
of the RPC for more details).
"KRN",8994,1819,2,3,1,4,0)
 
"KRN",8994,1819,2,3,1,5,0)
Example:
"KRN",8994,1819,2,3,1,6,0)
 
"KRN",8994,1819,2,3,1,7,0)
  with RPCBroker.Param[3] do
"KRN",8994,1819,2,3,1,8,0)
    begin
"KRN",8994,1819,2,3,1,9,0)
      PType := list;
"KRN",8994,1819,2,3,1,10,0)
      Mult[1] := 'HDR^^2990622';
"KRN",8994,1819,2,3,1,11,0)
      Mult[2] := 'CDM^^2^22^1^^1^^Westmont^Du Page^17^ILLINOIS^US';
"KRN",8994,1819,2,3,1,12,0)
      ...
"KRN",8994,1819,2,3,1,13,0)
      Mult[n] := 'CMT^1^Just a sample CDC comment';
"KRN",8994,1819,2,3,1,14,0)
    end;
"KRN",8994,1819,2,3,1,15,0)
 
"KRN",8994,1819,2,3,1,16,0)
NOTE #1: The CS data segment must be always included before the
"KRN",8994,1819,2,3,1,17,0)
         AID segments. Otherwise, the latter will be ignored.
"KRN",8994,1819,2,3,1,18,0)
                                                                    
"KRN",8994,1819,2,3,1,19,0)
NOTE #2: Any AIDS indicator disease, which has empty 3rd piece
"KRN",8994,1819,2,3,1,20,0)
         in the corresponding AID segment (or no segment at all),
"KRN",8994,1819,2,3,1,21,0)
         will be removed from the patient record.
"KRN",8994,1819,2,3,1,22,0)
    
"KRN",8994,1819,2,3,1,23,0)
NOTE #3: There should be at least one empty comment (i.e. the
"KRN",8994,1819,2,3,1,24,0)
         "CMT^1" segment) among the data if you want to clear
"KRN",8994,1819,2,3,1,25,0)
         the CDC comments. Otherwise, they will not be updated.
"KRN",8994,1819,2,4,0)
FLAGS^1^^^3
"KRN",8994,1819,2,4,1,0)
^8994.021^4^4^3030415^^^^
"KRN",8994,1819,2,4,1,1,0)
Flags that control the execution (can be combined):
"KRN",8994,1819,2,4,1,2,0)
 
"KRN",8994,1819,2,4,1,3,0)
  H  Update the patient history. If this flag is
"KRN",8994,1819,2,4,1,4,0)
     not provided, the PH data segment is ignored.
"KRN",8994,1819,2,"B","DATA",3)

"KRN",8994,1819,2,"B","FLAGS",4)

"KRN",8994,1819,2,"B","PATIEN",2)

"KRN",8994,1819,2,"B","REGIEN",1)

"KRN",8994,1819,2,"PARAMSEQ",1,1)

"KRN",8994,1819,2,"PARAMSEQ",2,2)

"KRN",8994,1819,2,"PARAMSEQ",3,4)

"KRN",8994,1819,2,"PARAMSEQ",4,3)

"KRN",8994,1819,3,0)
^^21^21^3030425^
"KRN",8994,1819,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1819,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1819,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1819,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1819,3,5,0)
   
"KRN",8994,1819,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1819,3,7,0)
                          ^01: The last error code
"KRN",8994,1819,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1819,3,9,0)
                                                                      
"KRN",8994,1819,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1819,3,11,0)
                          ^01: Error code
"KRN",8994,1819,3,12,0)
                          ^02: Message
"KRN",8994,1819,3,13,0)
                          ^03: Place of the error
"KRN",8994,1819,3,14,0)
 
"KRN",8994,1819,3,15,0)
A positive value of the first "^"-piece of the Results[0] indicates an
"KRN",8994,1819,3,16,0)
error in the CDC data. The value is the number of the erroneous piece of
"KRN",8994,1819,3,17,0)
the data segment whose name is returned in the second piece of the
"KRN",8994,1819,3,18,0)
Results[0]. For example, the "11^CDM" means that the 11th piece of the CDM
"KRN",8994,1819,3,19,0)
data segment (ONSET OF ILLNESS/AIDS- STATE) contains an invalid value.
"KRN",8994,1819,3,20,0)
    
"KRN",8994,1819,3,21,0)
Otherwise, zero is returned in the Results[0].
"KRN",8994,1852,-1)
0^33
"KRN",8994,1852,0)
ROR GET USER INFO^USERINFO^RORRP024^2^R^^^1^1
"KRN",8994,1852,1,0)
^8994.01^2^2^3040203^^^^
"KRN",8994,1852,1,1,0)
The ROR GET USER INFO remote procedure returns basic information about the
"KRN",8994,1852,1,2,0)
user.
"KRN",8994,1852,2,0)
^8994.02A^1^1
"KRN",8994,1852,2,1,0)
USER^1^^^1
"KRN",8994,1852,2,1,1,0)
^8994.021^2^2^3040203^^^
"KRN",8994,1852,2,1,1,1,0)
User IEN in the NEW PERSON file. By default (if $G(USER)'>0), the DUZ is
"KRN",8994,1852,2,1,1,2,0)
used).
"KRN",8994,1852,2,"B","USER",1)

"KRN",8994,1852,2,"PARAMSEQ",1,1)

"KRN",8994,1852,3,0)
^8994.03^28^28^3040203^^
"KRN",8994,1852,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1852,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1852,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1852,3,4,0)
descriptors returned in the subsequent nodes of the Results array.
"KRN",8994,1852,3,5,0)
 
"KRN",8994,1852,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1852,3,7,0)
                          ^01: The last error code (LASTERR)
"KRN",8994,1852,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1852,3,9,0)
 
"KRN",8994,1852,3,10,0)
 
"KRN",8994,1852,3,11,0)
  Results[i]            Error Descriptor
"KRN",8994,1852,3,12,0)
                          ^01: Error code
"KRN",8994,1852,3,13,0)
                          ^02: Message
"KRN",8994,1852,3,14,0)
                          ^03: Place of the error
"KRN",8994,1852,3,15,0)
 
"KRN",8994,1852,3,16,0)
Error descriptors are returned in reverse chronological order (most recent
"KRN",8994,1852,3,17,0)
error first).
"KRN",8994,1852,3,18,0)
 
"KRN",8994,1852,3,19,0)
Otherwise, the user info is returned in the Results[0].
"KRN",8994,1852,3,20,0)
 
"KRN",8994,1852,3,21,0)
  Results[0]            User Info
"KRN",8994,1852,3,22,0)
                          ^01: IEN
"KRN",8994,1852,3,23,0)
                          ^02: Name
"KRN",8994,1852,3,24,0)
                          ^03: Office Phone
"KRN",8994,1852,3,25,0)
                          ^04: Nickname
"KRN",8994,1852,3,26,0)
                          ^05: Read Timeout
"KRN",8994,1852,3,27,0)
                          ^06: Default Division IEN
"KRN",8994,1852,3,28,0)
                          ^07: Default Division Name
"KRN",8994,1853,-1)
0^34
"KRN",8994,1853,0)
ROR PATIENT GET DATA^GETPTDAT^RORRP021^2^R^^^1^1
"KRN",8994,1853,1,0)
^8994.01^2^2^3030626^^^^
"KRN",8994,1853,1,1,0)
The ROR GET PATIENT DATA remote procedure returns patient's data from the 
"KRN",8994,1853,1,2,0)
PATIENT file and (optionally) the registry record.
"KRN",8994,1853,2,0)
^8994.02A^3^3
"KRN",8994,1853,2,1,0)
PATIEN^1^^1^1
"KRN",8994,1853,2,1,1,0)
^^1^1^3030613^
"KRN",8994,1853,2,1,1,1,0)
A valid patient IEN (DFN) should be assigned to the PATIEN parameter.
"KRN",8994,1853,2,2,0)
FLAGS^1^^^2
"KRN",8994,1853,2,2,1,0)
^^5^5^3030613^
"KRN",8994,1853,2,2,1,1,0)
Flags that control the execution (can be combined):
"KRN",8994,1853,2,2,1,2,0)
 
"KRN",8994,1853,2,2,1,3,0)
  A  Load the patient's address
"KRN",8994,1853,2,2,1,4,0)
  E  Load the ethnicity information
"KRN",8994,1853,2,2,1,5,0)
  R  Load the race information
"KRN",8994,1853,2,3,0)
REGIEN^1^^^3
"KRN",8994,1853,2,3,1,0)
^8994.021^7^7^3030626^^^^
"KRN",8994,1853,2,3,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1853,2,3,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1853,2,3,1,3,0)
 
"KRN",8994,1853,2,3,1,4,0)
If this parameter is defined and its value is greater than 0 then the
"KRN",8994,1853,2,3,1,5,0)
"PRD" segment with the basic patient's registry data will be returned.
"KRN",8994,1853,2,3,1,6,0)
If the patient is not in the registry then an empty "PRD" segment will
"KRN",8994,1853,2,3,1,7,0)
be returned anyway.
"KRN",8994,1853,2,"B","FLAGS",2)

"KRN",8994,1853,2,"B","PATIEN",1)

"KRN",8994,1853,2,"B","REGIEN",3)

"KRN",8994,1853,2,"PARAMSEQ",1,1)

"KRN",8994,1853,2,"PARAMSEQ",2,2)

"KRN",8994,1853,2,"PARAMSEQ",3,3)

"KRN",8994,1853,3,0)
^8994.03^108^108^3030626^^^
"KRN",8994,1853,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1853,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1853,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1853,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1853,3,5,0)
  
"KRN",8994,1853,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1853,3,7,0)
                          ^01: The last error code
"KRN",8994,1853,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1853,3,9,0)
   
"KRN",8994,1853,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1853,3,11,0)
                          ^01: Error code
"KRN",8994,1853,3,12,0)
                          ^02: Message
"KRN",8994,1853,3,13,0)
                          ^03: Place of the error
"KRN",8994,1853,3,14,0)
 
"KRN",8994,1853,3,15,0)
Otherwise, zero is returned in the Results[0] and subsequent nodes 
"KRN",8994,1853,3,16,0)
contain the patient's data.
"KRN",8994,1853,3,17,0)
 
"KRN",8994,1853,3,18,0)
  Results[0]            0
"KRN",8994,1853,3,19,0)
 
"KRN",8994,1853,3,20,0)
  Results[i]            Demographic Information
"KRN",8994,1853,3,21,0)
                          ^01: "DEM"
"KRN",8994,1853,3,22,0)
                          ^02: ""
"KRN",8994,1853,3,23,0)
                          ^03: Patient IEN (DFN)
"KRN",8994,1853,3,24,0)
                          ^04: Patient Name
"KRN",8994,1853,3,25,0)
                          ^05: Date of Birth (FileMan)
"KRN",8994,1853,3,26,0)
                          ^06: SSN
"KRN",8994,1853,3,27,0)
                          ^07: Date of Death (FileMan)
"KRN",8994,1853,3,28,0)
                          ^08: Sex (F/M)
"KRN",8994,1853,3,29,0)
 
"KRN",8994,1853,3,30,0)
  Results[i]            Patient's Address
"KRN",8994,1853,3,31,0)
                          ^01: "ADR"
"KRN",8994,1853,3,32,0)
                          ^02: ""
"KRN",8994,1853,3,33,0)
                          ^03: Address (1)
"KRN",8994,1853,3,34,0)
                          ^04: Address (2)
"KRN",8994,1853,3,35,0)
                          ^05: Address (3)
"KRN",8994,1853,3,36,0)
                          ^06: City
"KRN",8994,1853,3,37,0)
                          ^07: State (IEN)
"KRN",8994,1853,3,38,0)
                          ^08: State (Name)
"KRN",8994,1853,3,39,0)
                          ^09: ZIP
"KRN",8994,1853,3,40,0)
                          ^10: ZIP+4
"KRN",8994,1853,3,41,0)
                          ^11: County (IEN)
"KRN",8994,1853,3,42,0)
                          ^12: County (Name)
"KRN",8994,1853,3,43,0)
                          ^13: Home Phone
"KRN",8994,1853,3,44,0)
 
"KRN",8994,1853,3,45,0)
  Results[i]            Race Information
"KRN",8994,1853,3,46,0)
                          ^01: "RCE"
"KRN",8994,1853,3,47,0)
                          ^02: Race IEN
"KRN",8994,1853,3,48,0)
                          ^03: Race HL7 Value
"KRN",8994,1853,3,49,0)
                          ^04: Race
"KRN",8994,1853,3,50,0)
                          ^05: Collection Method HL7 Value
"KRN",8994,1853,3,51,0)
                          ^06: Collection Method
"KRN",8994,1853,3,52,0)
 
"KRN",8994,1853,3,53,0)
                        Race HL7 Values
"KRN",8994,1853,3,54,0)
                          1002-5  American Indian or Alaska Native
"KRN",8994,1853,3,55,0)
                          2028-9  Asian
"KRN",8994,1853,3,56,0)
                          2054-5  Black or African American
"KRN",8994,1853,3,57,0)
                          0000-0  Declined to Answer
"KRN",8994,1853,3,58,0)
                          2076-8  Native Hawaiian or Pacific Islander
"KRN",8994,1853,3,59,0)
                          9999-4  Unknown by Patient
"KRN",8994,1853,3,60,0)
                          2106-3  White
"KRN",8994,1853,3,61,0)
 
"KRN",8994,1853,3,62,0)
                        Collection Method HL7 Values
"KRN",8994,1853,3,63,0)
                          OBS     Observer
"KRN",8994,1853,3,64,0)
                          PRX     Proxy
"KRN",8994,1853,3,65,0)
                          SLF     Self Identification
"KRN",8994,1853,3,66,0)
                          UNK     Unknown
"KRN",8994,1853,3,67,0)
 
"KRN",8994,1853,3,68,0)
  Results[i]            Ethnicity Information
"KRN",8994,1853,3,69,0)
                          ^01: "ETN"
"KRN",8994,1853,3,70,0)
                          ^02: Ethnicity IEN
"KRN",8994,1853,3,71,0)
                          ^03: Ethnicity HL7 Value
"KRN",8994,1853,3,72,0)
                          ^04: Ethnicity
"KRN",8994,1853,3,73,0)
                          ^05: Collection Method HL7 value
"KRN",8994,1853,3,74,0)
                          ^06: Collection Method
"KRN",8994,1853,3,75,0)
 
"KRN",8994,1853,3,76,0)
                        Ethnicity HL7 Values
"KRN",8994,1853,3,77,0)
                          0000-0  Declined to Answer
"KRN",8994,1853,3,78,0)
                          2135-2  Hispanic or Latino
"KRN",8994,1853,3,79,0)
                          2186-5  Not Hispanic or Latino
"KRN",8994,1853,3,80,0)
                          9999-4  Unknown by Patient
"KRN",8994,1853,3,81,0)
 
"KRN",8994,1853,3,82,0)
  Results[i]            Patient's Registry Data
"KRN",8994,1853,3,83,0)
                          ^01: "PRD"
"KRN",8994,1853,3,84,0)
                          ^02: ""
"KRN",8994,1853,3,85,0)
                          ^03: Date Entered (FileMan)
"KRN",8994,1853,3,86,0)
                          ^04: New Patient (internal)
"KRN",8994,1853,3,87,0)
                          ^05: Active (0/1)
"KRN",8994,1853,3,88,0)
                          ^06: Do not Send (0/1)
"KRN",8994,1853,3,89,0)
                          ^07: Data Acknowledged Until (FileMan)
"KRN",8994,1853,3,90,0)
                          ^08: Data Extracted Until (FileMan)
"KRN",8994,1853,3,91,0)
                          ^09: Inactivation Date (FileMan)
"KRN",8994,1853,3,92,0)
                          ^10: Inactivated By (IEN)
"KRN",8994,1853,3,93,0)
                          ^11: Inactivated By (Name)
"KRN",8994,1853,3,94,0)
                          ^12: Reactivation Date (FileMan)
"KRN",8994,1853,3,95,0)
                          ^13: Reactivated By (IEN)
"KRN",8994,1853,3,96,0)
                          ^14: Reactivated By (Name)
"KRN",8994,1853,3,97,0)
                          ^15: Action Flags (see the description below)
"KRN",8994,1853,3,98,0)
                          ^16: Code of inactivation reason
"KRN",8994,1853,3,99,0)
                          ^17: Code of supporting evidence
"KRN",8994,1853,3,100,0)
 
"KRN",8994,1853,3,101,0)
                        The Action Flags field indicates the actions that
"KRN",8994,1853,3,102,0)
                        can be performed on the patient's record:
"KRN",8994,1853,3,103,0)
                            C  CDC form can be edited/printed
"KRN",8994,1853,3,104,0)
                            D  The record can be deleted
"KRN",8994,1853,3,105,0)
                            E  The record can be edited
"KRN",8994,1853,3,106,0)
                            I  The record can be inactivated
"KRN",8994,1853,3,107,0)
                            O  Read-only mode
"KRN",8994,1853,3,108,0)
                            R  The record can be reactivated
"KRN",8994,1854,-1)
0^35
"KRN",8994,1854,0)
ROR PATIENT (IN)ACTIVATE^UPDATE^RORRP030^2^R^^^1^1
"KRN",8994,1854,1,0)
^8994.01^3^3^3030624^^^^
"KRN",8994,1854,1,1,0)
The ROR PATIENT (IN)ACTIVATE remote procedure inactivates/reactivates the
"KRN",8994,1854,1,2,0)
patient's record in the registry. If no data has been sent to the AAC, the
"KRN",8994,1854,1,3,0)
record is deleted from the registry instead of inactivation.
"KRN",8994,1854,2,0)
^8994.02A^4^4
"KRN",8994,1854,2,1,0)
RORDFN^1^^1^2
"KRN",8994,1854,2,1,1,0)
^8994.021^1^1^3030617^^^^
"KRN",8994,1854,2,1,1,1,0)
A valid patient IEN (DFN) should be assigned to the RORDFN parameter.
"KRN",8994,1854,2,2,0)
REGIEN^1^^1^1
"KRN",8994,1854,2,2,1,0)
^^2^2^3030617^
"KRN",8994,1854,2,2,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1854,2,2,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1854,2,3,0)
ACTION^1^1^1^3
"KRN",8994,1854,2,3,1,0)
^^5^5^3030617^
"KRN",8994,1854,2,3,1,1,0)
The value of the ACTION parameter determines the action performed on the 
"KRN",8994,1854,2,3,1,2,0)
patient's record:
"KRN",8994,1854,2,3,1,3,0)
 
"KRN",8994,1854,2,3,1,4,0)
  I  Inactivate the record
"KRN",8994,1854,2,3,1,5,0)
  R  Reactivate the record
"KRN",8994,1854,2,4,0)
REASON^1^^1^4
"KRN",8994,1854,2,4,1,0)
^8994.021^3^3^3030617^^^
"KRN",8994,1854,2,4,1,1,0)
The REASON parameter should contain either a code of the Reason for
"KRN",8994,1854,2,4,1,2,0)
Inactivation if the ACTION parameter is equal to "I" or a code of the 
"KRN",8994,1854,2,4,1,3,0)
Supporting Evidence if the ACTION parameter has the "R" value.
"KRN",8994,1854,2,"B","ACTION",3)

"KRN",8994,1854,2,"B","REASON",4)

"KRN",8994,1854,2,"B","REGIEN",2)

"KRN",8994,1854,2,"B","RORDFN",1)

"KRN",8994,1854,2,"PARAMSEQ",1,2)

"KRN",8994,1854,2,"PARAMSEQ",2,1)

"KRN",8994,1854,2,"PARAMSEQ",3,3)

"KRN",8994,1854,2,"PARAMSEQ",4,4)

"KRN",8994,1854,3,0)
^8994.03^20^20^3030617^^^^
"KRN",8994,1854,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1854,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1854,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1854,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1854,3,5,0)
   
"KRN",8994,1854,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1854,3,7,0)
                          ^01: The last error code
"KRN",8994,1854,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1854,3,9,0)
   
"KRN",8994,1854,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1854,3,11,0)
                          ^01: Error code
"KRN",8994,1854,3,12,0)
                          ^02: Message
"KRN",8994,1854,3,13,0)
                          ^03: Place of the error
"KRN",8994,1854,3,14,0)
  
"KRN",8994,1854,3,15,0)
Otherwise, the following codes can be returned in the Results[0]:
"KRN",8994,1854,3,16,0)
 
"KRN",8994,1854,3,17,0)
  0  Requested action is redundant
"KRN",8994,1854,3,18,0)
  1  The record has been inactivated
"KRN",8994,1854,3,19,0)
  2  The record has been reactivated
"KRN",8994,1854,3,20,0)
  9  The record has been deleted
"KRN",8994,1855,-1)
0^36
"KRN",8994,1855,0)
ROR PATIENT DELETE^DELETE^RORRP030^2^R^^^1^1
"KRN",8994,1855,1,0)
^8994.01^3^3^3030624^^
"KRN",8994,1855,1,1,0)
The ROR PATIENT DELETE remote procedure deletes the patient's record from
"KRN",8994,1855,1,2,0)
the registry. If any data has already been sent to the AAC, the record is
"KRN",8994,1855,1,3,0)
not deleted and an error code is returned.
"KRN",8994,1855,2,0)
^8994.02A^3^3
"KRN",8994,1855,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1855,2,1,1,0)
^^2^2^3030624^
"KRN",8994,1855,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1855,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1855,2,2,0)
RORDFN^1^^1^2
"KRN",8994,1855,2,2,1,0)
^^1^1^3030624^
"KRN",8994,1855,2,2,1,1,0)
A valid patient IEN (DFN) should be assigned to the RORDFN parameter.
"KRN",8994,1855,2,3,0)
FORCE^1^^^3
"KRN",8994,1855,2,3,1,0)
^^3^3^3030624^
"KRN",8994,1855,2,3,1,1,0)
If the FORCE parameter is defined and greater than 0 then the patient's 
"KRN",8994,1855,2,3,1,2,0)
record will be deleted from the registry even if some data has been sent 
"KRN",8994,1855,2,3,1,3,0)
to the AAC already. BE VERY CAREFUL WITH THIS!
"KRN",8994,1855,2,"B","FORCE",3)

"KRN",8994,1855,2,"B","REGIEN",1)

"KRN",8994,1855,2,"B","RORDFN",2)

"KRN",8994,1855,2,"PARAMSEQ",1,1)

"KRN",8994,1855,2,"PARAMSEQ",2,2)

"KRN",8994,1855,2,"PARAMSEQ",3,3)

"KRN",8994,1855,3,0)
^8994.03^18^18^3030624^^
"KRN",8994,1855,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1855,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1855,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1855,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1855,3,5,0)
   
"KRN",8994,1855,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1855,3,7,0)
                          ^01: The last error code
"KRN",8994,1855,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1855,3,9,0)
   
"KRN",8994,1855,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1855,3,11,0)
                          ^01: Error code
"KRN",8994,1855,3,12,0)
                          ^02: Message
"KRN",8994,1855,3,13,0)
                          ^03: Place of the error
"KRN",8994,1855,3,14,0)
  
"KRN",8994,1855,3,15,0)
Otherwise, the following codes can be returned in the Results[0]:
"KRN",8994,1855,3,16,0)
 
"KRN",8994,1855,3,17,0)
  0  The record cannot be deleted
"KRN",8994,1855,3,18,0)
  9  The record has been deleted
"KRN",8994,1856,-1)
0^37
"KRN",8994,1856,0)
ROR LIST LOCAL LAB TESTS^LTLIST^RORRP031^4^A^^^1^1
"KRN",8994,1856,1,0)
^^3^3^3030625^
"KRN",8994,1856,1,1,0)
The ROR LIST LOCAL LAB TESTS remote procedure returns a list of local lab 
"KRN",8994,1856,1,2,0)
tests, which are referenced by the LOCAL TEST NAME multiple (28) of the
"KRN",8994,1856,1,3,0)
ROR REGISTRY PARAMETERS file (#798.1).
"KRN",8994,1856,2,0)
^8994.02A^2^2
"KRN",8994,1856,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1856,2,1,1,0)
^^2^2^3030624^
"KRN",8994,1856,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the 
"KRN",8994,1856,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1856,2,2,0)
GROUP^1^^^2
"KRN",8994,1856,2,2,1,0)
^8994.021^3^3^3030625^^^
"KRN",8994,1856,2,2,1,1,0)
If this parameter is defined and not zero, it should contain a valid code
"KRN",8994,1856,2,2,1,2,0)
of the Lab Group. In this case, only the tests associated with this group
"KRN",8994,1856,2,2,1,3,0)
will be returned.
"KRN",8994,1856,2,"B","GROUP",2)

"KRN",8994,1856,2,"B","REGIEN",1)

"KRN",8994,1856,2,"PARAMSEQ",1,1)

"KRN",8994,1856,2,"PARAMSEQ",2,2)

"KRN",8994,1856,3,0)
^8994.03^24^24^3030625^^^
"KRN",8994,1856,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1856,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1856,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1856,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1856,3,5,0)
  
"KRN",8994,1856,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1856,3,7,0)
                          ^01: The last error code
"KRN",8994,1856,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1856,3,9,0)
                                                                      
"KRN",8994,1856,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1856,3,11,0)
                          ^01: Error code
"KRN",8994,1856,3,12,0)
                          ^02: Message
"KRN",8994,1856,3,13,0)
                          ^03: Place of the error
"KRN",8994,1856,3,14,0)
 
"KRN",8994,1856,3,15,0)
Otherwise, number of lab tests is returned in the Results[0] and the 
"KRN",8994,1856,3,16,0)
subsequent nodes of the global array contain the tests.
"KRN",8994,1856,3,17,0)
 
"KRN",8994,1856,3,18,0)
  Results[0]            Number of Local Tests
"KRN",8994,1856,3,19,0)
 
"KRN",8994,1856,3,20,0)
  Results[i]            Test Descriptor
"KRN",8994,1856,3,21,0)
                          ^01: IEN in the LOCAL TEST NAME multiple
"KRN",8994,1856,3,22,0)
                          ^02: Local test name
"KRN",8994,1856,3,23,0)
                          ^03: IEN of the local test (in the file #60)
"KRN",8994,1856,3,24,0)
                          ^04: Code of the Lab Group
"KRN",8994,1857,-1)
0^38
"KRN",8994,1857,0)
ROR UPDATE LOCAL LAB TESTS^LTLUPD^RORRP031^2^R^^^1^1
"KRN",8994,1857,1,0)
^^3^3^3030625^
"KRN",8994,1857,1,1,0)
The ROR UPDATE LOCAL LAB TESTS remote procedure updates the list of local
"KRN",8994,1857,1,2,0)
Lab test names, which is stored in the LOCAL TEST NAME (28) multiple of
"KRN",8994,1857,1,3,0)
the ROR REGISTRY PARAMETERS file (#798.1).
"KRN",8994,1857,2,0)
^8994.02A^3^3
"KRN",8994,1857,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1857,2,1,1,0)
^^2^2^3030625^
"KRN",8994,1857,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the 
"KRN",8994,1857,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1857,2,2,0)
LTLST^2^^1^3
"KRN",8994,1857,2,2,1,0)
^^17^17^3030625^
"KRN",8994,1857,2,2,1,1,0)
The LTLST parameter should be an array containing a list of laboratory 
"KRN",8994,1857,2,2,1,2,0)
test IEN's and Lab Group codes. An item of the list should have the 
"KRN",8994,1857,2,2,1,3,0)
following format:
"KRN",8994,1857,2,2,1,4,0)
 
"KRN",8994,1857,2,2,1,5,0)
  ^01: Ignored
"KRN",8994,1857,2,2,1,6,0)
  ^02: Ignored
"KRN",8994,1857,2,2,1,7,0)
  ^03: IEN of the local test (in file #60)
"KRN",8994,1857,2,2,1,8,0)
  ^04: Code of the Lab Group
"KRN",8994,1857,2,2,1,9,0)
       (see also the GROUP parameter)
"KRN",8994,1857,2,2,1,10,0)
  
"KRN",8994,1857,2,2,1,11,0)
Example:
"KRN",8994,1857,2,2,1,12,0)
  with RPCBroker.Param[1] do
"KRN",8994,1857,2,2,1,13,0)
    begin
"KRN",8994,1857,2,2,1,14,0)
      PType :=list;
"KRN",8994,1857,2,2,1,15,0)
      for i := 1 to Tests.Count do
"KRN",8994,1857,2,2,1,16,0)
        Mult[i] := '^^' + Tests[i-1].TestIEN + '^' + Tests[i-1].GroupCode;
"KRN",8994,1857,2,2,1,17,0)
    end;
"KRN",8994,1857,2,3,0)
GROUP^1^^1^2
"KRN",8994,1857,2,3,1,0)
^8994.021^8^8^3030625^^^
"KRN",8994,1857,2,3,1,1,0)
If the GROUP parameter is equal to 0 then every item of the LTLST must 
"KRN",8994,1857,2,3,1,2,0)
contain a valid group code. If ane mpty list is passed into the RPC then 
"KRN",8994,1857,2,3,1,3,0)
ALL records will be deleted from the LOCAL TEST NAME multiple.
"KRN",8994,1857,2,3,1,4,0)
 
"KRN",8994,1857,2,3,1,5,0)
If this parameter is not zero then it should contain a valid group code.
"KRN",8994,1857,2,3,1,6,0)
All records of the LTLST will be associated with this group. If an empty
"KRN",8994,1857,2,3,1,7,0)
list is passed into the RPC then only records associated with this group
"KRN",8994,1857,2,3,1,8,0)
will be deleted from the multiple.
"KRN",8994,1857,2,"B","GROUP",3)

"KRN",8994,1857,2,"B","LTLST",2)

"KRN",8994,1857,2,"B","REGIEN",1)

"KRN",8994,1857,2,"PARAMSEQ",1,1)

"KRN",8994,1857,2,"PARAMSEQ",2,3)

"KRN",8994,1857,2,"PARAMSEQ",3,2)

"KRN",8994,1857,3,0)
^8994.03^15^15^3030625^^^^
"KRN",8994,1857,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1857,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1857,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1857,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1857,3,5,0)
  
"KRN",8994,1857,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1857,3,7,0)
                          ^01: The last error code
"KRN",8994,1857,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1857,3,9,0)
                                                                      
"KRN",8994,1857,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1857,3,11,0)
                          ^01: Error code
"KRN",8994,1857,3,12,0)
                          ^02: Message
"KRN",8994,1857,3,13,0)
                          ^03: Place of the error
"KRN",8994,1857,3,14,0)
 
"KRN",8994,1857,3,15,0)
Otherwise, zero is returned in the Results[0].
"KRN",8994,1858,-1)
0^39
"KRN",8994,1858,0)
ROR LIST LOCAL DRUGS^LDLIST^RORRP032^4^A^^^1^1
"KRN",8994,1858,1,0)
^8994.01^3^3^3030625^^
"KRN",8994,1858,1,1,0)
The ROR LIST LOCAL DRUGS remote procedure returns a list of local drugs, 
"KRN",8994,1858,1,2,0)
which are referenced by the LOCAL DRUG NAME multiple (29) of the ROR
"KRN",8994,1858,1,3,0)
REGISTRY PARAMETERS file (#798.1).
"KRN",8994,1858,2,0)
^8994.02A^2^2
"KRN",8994,1858,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1858,2,1,1,0)
^8994.021^2^2^3030625^^
"KRN",8994,1858,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the 
"KRN",8994,1858,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1858,2,2,0)
GROUP^1^^^2
"KRN",8994,1858,2,2,1,0)
^^3^3^3030625^
"KRN",8994,1858,2,2,1,1,0)
If this parameter is defined and not zero, it should contain a valid code
"KRN",8994,1858,2,2,1,2,0)
of the Drug Group. In this case, only the drugs associated with this group
"KRN",8994,1858,2,2,1,3,0)
will be returned.
"KRN",8994,1858,2,"B","GROUP",2)

"KRN",8994,1858,2,"B","REGIEN",1)

"KRN",8994,1858,2,"PARAMSEQ",1,1)

"KRN",8994,1858,2,"PARAMSEQ",2,2)

"KRN",8994,1858,3,0)
^8994.03^24^24^3030625^^
"KRN",8994,1858,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1858,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1858,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1858,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1858,3,5,0)
  
"KRN",8994,1858,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1858,3,7,0)
                          ^01: The last error code
"KRN",8994,1858,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1858,3,9,0)
                                                                      
"KRN",8994,1858,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1858,3,11,0)
                          ^01: Error code
"KRN",8994,1858,3,12,0)
                          ^02: Message
"KRN",8994,1858,3,13,0)
                          ^03: Place of the error
"KRN",8994,1858,3,14,0)
 
"KRN",8994,1858,3,15,0)
Otherwise, number of drugs is returned in the Results[0] and the 
"KRN",8994,1858,3,16,0)
subsequent nodes of the global array contain the drugs.
"KRN",8994,1858,3,17,0)
 
"KRN",8994,1858,3,18,0)
  Results[0]            Number of Drugs
"KRN",8994,1858,3,19,0)
 
"KRN",8994,1858,3,20,0)
  Results[i]            Drug Descriptor
"KRN",8994,1858,3,21,0)
                          ^01: IEN in the LOCAL DRUG NAME multiple
"KRN",8994,1858,3,22,0)
                          ^02: Local drug name
"KRN",8994,1858,3,23,0)
                          ^03: IEN of the local drug (in the file #50)
"KRN",8994,1858,3,24,0)
                          ^04: Code of the Drug Group
"KRN",8994,1859,-1)
0^40
"KRN",8994,1859,0)
ROR UPDATE LOCAL DRUGS^LDLUPD^RORRP032^2^R^^^1^1
"KRN",8994,1859,1,0)
^^3^3^3030625^
"KRN",8994,1859,1,1,0)
The ROR UPDATE LOCAL DRUGS remote procedure updates the list of local drug
"KRN",8994,1859,1,2,0)
names, which is stored in the LOCAL DRUG NAME (29) multiple of the ROR
"KRN",8994,1859,1,3,0)
REGISTRY PARAMETERS file (#798.1).
"KRN",8994,1859,2,0)
^8994.02A^3^3
"KRN",8994,1859,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1859,2,1,1,0)
^^2^2^3030625^
"KRN",8994,1859,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the 
"KRN",8994,1859,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1859,2,2,0)
LDLST^2^^1^3
"KRN",8994,1859,2,2,1,0)
^^16^16^3030625^
"KRN",8994,1859,2,2,1,1,0)
The LDLST parameter should be an array containing a list of drug IEN's and
"KRN",8994,1859,2,2,1,2,0)
Drug Group codes. An item of the list should have the following format:
"KRN",8994,1859,2,2,1,3,0)
 
"KRN",8994,1859,2,2,1,4,0)
  ^01: Ignored
"KRN",8994,1859,2,2,1,5,0)
  ^02: Ignored
"KRN",8994,1859,2,2,1,6,0)
  ^03: IEN of the local drug (in file #50)
"KRN",8994,1859,2,2,1,7,0)
  ^04: Code of the Drug Group
"KRN",8994,1859,2,2,1,8,0)
       (see also the GROUP parameter)
"KRN",8994,1859,2,2,1,9,0)
  
"KRN",8994,1859,2,2,1,10,0)
Example:
"KRN",8994,1859,2,2,1,11,0)
  with RPCBroker.Param[1] do
"KRN",8994,1859,2,2,1,12,0)
    begin
"KRN",8994,1859,2,2,1,13,0)
      PType :=list;
"KRN",8994,1859,2,2,1,14,0)
      for i := 1 to Drugs.Count do
"KRN",8994,1859,2,2,1,15,0)
        Mult[i] := '^^' + Drugs[i-1].DrugIEN + '^' + Drugs[i-1].GroupCode;
"KRN",8994,1859,2,2,1,16,0)
    end;
"KRN",8994,1859,2,3,0)
GROUP^1^^1^2
"KRN",8994,1859,2,3,1,0)
^^8^8^3030625^
"KRN",8994,1859,2,3,1,1,0)
If the GROUP parameter is equal to 0 then every item of the LDLST must 
"KRN",8994,1859,2,3,1,2,0)
contain a valid group code. If ane mpty list is passed into the RPC then 
"KRN",8994,1859,2,3,1,3,0)
ALL records will be deleted from the LOCAL DRUG NAME multiple.
"KRN",8994,1859,2,3,1,4,0)
 
"KRN",8994,1859,2,3,1,5,0)
If this parameter is not zero then it should contain a valid group code.
"KRN",8994,1859,2,3,1,6,0)
All records of the LDLST will be associated with this group. If an empty
"KRN",8994,1859,2,3,1,7,0)
list is passed into the RPC then only records associated with this group
"KRN",8994,1859,2,3,1,8,0)
will be deleted from the multiple.
"KRN",8994,1859,2,"B","GROUP",3)

"KRN",8994,1859,2,"B","LDLST",2)

"KRN",8994,1859,2,"B","REGIEN",1)

"KRN",8994,1859,2,"PARAMSEQ",1,1)

"KRN",8994,1859,2,"PARAMSEQ",2,3)

"KRN",8994,1859,2,"PARAMSEQ",3,2)

"KRN",8994,1859,3,0)
^^15^15^3030625^
"KRN",8994,1859,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1859,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1859,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1859,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1859,3,5,0)
  
"KRN",8994,1859,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1859,3,7,0)
                          ^01: The last error code
"KRN",8994,1859,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1859,3,9,0)
                                                                      
"KRN",8994,1859,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1859,3,11,0)
                          ^01: Error code
"KRN",8994,1859,3,12,0)
                          ^02: Message
"KRN",8994,1859,3,13,0)
                          ^03: Place of the error
"KRN",8994,1859,3,14,0)
 
"KRN",8994,1859,3,15,0)
Otherwise, zero is returned in the Results[0].
"KRN",8994,1860,-1)
0^41
"KRN",8994,1860,0)
ROR LIST DRUGS^DRUGLIST^RORRP017^4^R^^^1^1
"KRN",8994,1860,1,0)
^8994.01^2^2^3031110^^
"KRN",8994,1860,1,1,0)
The ROR LIST DRUGS remote procedure returns a list of drugs (defined in
"KRN",8994,1860,1,2,0)
the DRUG file), which conform the criteria.
"KRN",8994,1860,2,0)
^8994.02A^5^4
"KRN",8994,1860,2,2,0)
PART^1^30^^1
"KRN",8994,1860,2,2,1,0)
^8994.021^1^1^3030626^^
"KRN",8994,1860,2,2,1,1,0)
The partial match restriction.
"KRN",8994,1860,2,3,0)
FLAGS^1^^^2
"KRN",8994,1860,2,3,1,0)
^^8^8^3031110^
"KRN",8994,1860,2,3,1,1,0)
Flags that control the execution (can be combined):
"KRN",8994,1860,2,3,1,2,0)
 
"KRN",8994,1860,2,3,1,3,0)
  B  Backwards. Traverses the index in the opposite
"KRN",8994,1860,2,3,1,4,0)
     direction of normal traversal
"KRN",8994,1860,2,3,1,5,0)
 
"KRN",8994,1860,2,3,1,6,0)
  G  Retrive generic drugs (from file #50.6).
"KRN",8994,1860,2,3,1,7,0)
     Otherwise, list of dispensed drugs (from
"KRN",8994,1860,2,3,1,8,0)
     file #50) is retrived.
"KRN",8994,1860,2,4,0)
NUMBER^1^^^3
"KRN",8994,1860,2,4,1,0)
^8994.021^2^2^3030626^^
"KRN",8994,1860,2,4,1,1,0)
Maximum number of entries to return. A value of "*" or no value in this
"KRN",8994,1860,2,4,1,2,0)
parameter designates all entries.
"KRN",8994,1860,2,5,0)
FROM^1^^^4
"KRN",8994,1860,2,5,1,0)
^8994.021^13^13^3031110^^^^
"KRN",8994,1860,2,5,1,1,0)
The index entry(s) from which to begin the list
"KRN",8994,1860,2,5,1,2,0)
   ^01: FromName
"KRN",8994,1860,2,5,1,3,0)
   ^02: FromIEN
"KRN",8994,1860,2,5,1,4,0)
   
"KRN",8994,1860,2,5,1,5,0)
For example, a FROM value of "XA" would list entries following XA. You can
"KRN",8994,1860,2,5,1,6,0)
use the 2-nd and 3-rd "^"- pieces of the Results[0] to continue the
"KRN",8994,1860,2,5,1,7,0)
listing in the subsequent procedure calls.
"KRN",8994,1860,2,5,1,8,0)
   
"KRN",8994,1860,2,5,1,9,0)
NOTE: The FROM value itself is not included in the
"KRN",8994,1860,2,5,1,10,0)
      resulting list.
"KRN",8994,1860,2,5,1,11,0)
   
"KRN",8994,1860,2,5,1,12,0)
See description of the LIST^DIC for more details about the PART, NUMBER 
"KRN",8994,1860,2,5,1,13,0)
and FROM parameters.
"KRN",8994,1860,2,"B","FLAGS",3)

"KRN",8994,1860,2,"B","FROM",5)

"KRN",8994,1860,2,"B","NUMBER",4)

"KRN",8994,1860,2,"B","PART",2)

"KRN",8994,1860,2,"PARAMSEQ",1,2)

"KRN",8994,1860,2,"PARAMSEQ",2,3)

"KRN",8994,1860,2,"PARAMSEQ",3,4)

"KRN",8994,1860,2,"PARAMSEQ",4,5)

"KRN",8994,1860,3,0)
^8994.03^27^27^3031110^^
"KRN",8994,1860,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that 
"KRN",8994,1860,3,2,0)
an error occurred during the execution of the remote procedure. In this 
"KRN",8994,1860,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1860,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1860,3,5,0)
   
"KRN",8994,1860,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1860,3,7,0)
                          ^01: The last error code
"KRN",8994,1860,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1860,3,9,0)
   
"KRN",8994,1860,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1860,3,11,0)
                          ^01: Error code
"KRN",8994,1860,3,12,0)
                          ^02: Message
"KRN",8994,1860,3,13,0)
                          ^03: Place of the error
"KRN",8994,1860,3,14,0)
  
"KRN",8994,1860,3,15,0)
Otherwise, number of drugs and the value of the FROM parameter for the
"KRN",8994,1860,3,16,0)
next procedure call are returned in the Results[0] and the subsequent
"KRN",8994,1860,3,17,0)
nodes of the global array contain the drugs.
"KRN",8994,1860,3,18,0)
   
"KRN",8994,1860,3,19,0)
  Results[0]          Result Descriptor
"KRN",8994,1860,3,20,0)
                        ^01: Number of drugs
"KRN",8994,1860,3,21,0)
                        ^02: FromName
"KRN",8994,1860,3,22,0)
                        ^03: FromIEN
"KRN",8994,1860,3,23,0)
 
"KRN",8994,1860,3,24,0)
  Results[i]          Drug
"KRN",8994,1860,3,25,0)
                        ^01: IEN in the DRUG file (#50)
"KRN",8994,1860,3,26,0)
                        ^02: Generic Name
"KRN",8994,1860,3,27,0)
                        ^03: VA Drug Class
"KRN",8994,1861,-1)
0^42
"KRN",8994,1861,0)
RORICR PATIENT LOAD^LOAD^RORRP033^4^R^^^1^1
"KRN",8994,1861,1,0)
^8994.01^2^2^3030715^^^^
"KRN",8994,1861,1,1,0)
The RORICR PATIENT LOAD remote procedure loads the patient's data from the
"KRN",8994,1861,1,2,0)
ICR registry and prepares the record for editing.
"KRN",8994,1861,2,0)
^8994.02A^3^3
"KRN",8994,1861,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1861,2,1,1,0)
^8994.021^2^2^3030703^^^
"KRN",8994,1861,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1861,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1861,2,2,0)
PATIEN^1^^1^2
"KRN",8994,1861,2,2,1,0)
^8994.021^1^1^3030715^^^^
"KRN",8994,1861,2,2,1,1,0)
A valid patient IEN (DFN) should be assigned to the PATIEN parameter.
"KRN",8994,1861,2,3,0)
LOCK^1^^^3
"KRN",8994,1861,2,3,1,0)
^^2^2^3030715^
"KRN",8994,1861,2,3,1,1,0)
If this parameter is defined and not zero then the RPC will try to lock
"KRN",8994,1861,2,3,1,2,0)
the registry record before loading the data and will leave it locked.
"KRN",8994,1861,2,"B","LOCK",3)

"KRN",8994,1861,2,"B","PATIEN",2)

"KRN",8994,1861,2,"B","REGIEN",1)

"KRN",8994,1861,2,"PARAMSEQ",1,1)

"KRN",8994,1861,2,"PARAMSEQ",2,2)

"KRN",8994,1861,2,"PARAMSEQ",3,3)

"KRN",8994,1861,3,0)
^^109^109^3030716^
"KRN",8994,1861,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1861,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1861,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1861,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1861,3,5,0)
   
"KRN",8994,1861,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1861,3,7,0)
                          ^01: The last error code
"KRN",8994,1861,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1861,3,9,0)
                                                                      
"KRN",8994,1861,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1861,3,11,0)
                          ^01: Error code
"KRN",8994,1861,3,12,0)
                          ^02: Message
"KRN",8994,1861,3,13,0)
                          ^03: Place of the error
"KRN",8994,1861,3,14,0)
 
"KRN",8994,1861,3,15,0)
If locking was requested (see the LOCK parameter) and the record could not
"KRN",8994,1861,3,16,0)
be locked then the first "^"-piece of the Results[0] would be greater than
"KRN",8994,1861,3,17,0)
0. The Results[0] would contain the lock descriptor and subsequent nodes
"KRN",8994,1861,3,18,0)
of the global array would contain the data (see below). The lock 
"KRN",8994,1861,3,19,0)
descriptor contains information about the process, which owns the most 
"KRN",8994,1861,3,20,0)
recent lock of the record. The "O" flag (read-only) would also be added to
"KRN",8994,1861,3,21,0)
the 15th field of the "PRD" segment.
"KRN",8994,1861,3,22,0)
 
"KRN",8994,1861,3,23,0)
  Results[0]            Lock Descriptor
"KRN",8994,1861,3,24,0)
                          ^01: Date/Time (FileMan)
"KRN",8994,1861,3,25,0)
                          ^02: User/Process name
"KRN",8994,1861,3,26,0)
                          ^03: User IEN (DUZ)
"KRN",8994,1861,3,27,0)
                          ^04: $JOB
"KRN",8994,1861,3,28,0)
                          ^05: Task number
"KRN",8994,1861,3,29,0)
 
"KRN",8994,1861,3,30,0)
THE DATA ARE LOADED ONLY FOR VIEWING PURPOSES (READ-ONLY)!
"KRN",8994,1861,3,31,0)
 
"KRN",8994,1861,3,32,0)
Otherwise, zero is returned in the Results[0] and the subsequent nodes of
"KRN",8994,1861,3,33,0)
the array contain the data.
"KRN",8994,1861,3,34,0)
 
"KRN",8994,1861,3,35,0)
  Results[0]            0
"KRN",8994,1861,3,36,0)
 
"KRN",8994,1861,3,37,0)
  Results[i]            Demographic Information
"KRN",8994,1861,3,38,0)
                          ^01: "DEM"
"KRN",8994,1861,3,39,0)
                          ^02: ""
"KRN",8994,1861,3,40,0)
                          ^03: Patient IEN (DFN)
"KRN",8994,1861,3,41,0)
                          ^04: Patient Name
"KRN",8994,1861,3,42,0)
                          ^05: Date of Birth (FileMan)
"KRN",8994,1861,3,43,0)
                          ^06: SSN
"KRN",8994,1861,3,44,0)
                          ^07: Date of Death (FileMan)
"KRN",8994,1861,3,45,0)
                          ^08: Sex (F/M)
"KRN",8994,1861,3,46,0)
 
"KRN",8994,1861,3,47,0)
  Results[i]            Basic Registry Data
"KRN",8994,1861,3,48,0)
                          ^01: "PRD"
"KRN",8994,1861,3,49,0)
                          ^02: ""
"KRN",8994,1861,3,50,0)
                          ^03: Date Entered (FileMan)
"KRN",8994,1861,3,51,0)
                          ^04: New Patient (internal)
"KRN",8994,1861,3,52,0)
                          ^05: Active (0/1)
"KRN",8994,1861,3,53,0)
                          ^06: Do not Send (0/1)
"KRN",8994,1861,3,54,0)
                          ^07: Data Acknowledged Until (FileMan)
"KRN",8994,1861,3,55,0)
                          ^08: Data Extracted Until (FileMan)
"KRN",8994,1861,3,56,0)
                          ^09: Inactivation Date (FileMan)
"KRN",8994,1861,3,57,0)
                          ^10: Inactivated By (IEN)
"KRN",8994,1861,3,58,0)
                          ^11: Inactivated By (Name)
"KRN",8994,1861,3,59,0)
                          ^12: Reactivation Date (FileMan)
"KRN",8994,1861,3,60,0)
                          ^13: Reactivated By (IEN)
"KRN",8994,1861,3,61,0)
                          ^14: Reactivated By (Name)
"KRN",8994,1861,3,62,0)
                          ^15: Action Flags
"KRN",8994,1861,3,63,0)
                          ^16: Code of inactivation reason
"KRN",8994,1861,3,64,0)
                          ^17: Code of supporting evidence
"KRN",8994,1861,3,65,0)
 
"KRN",8994,1861,3,66,0)
  Results[i]            Patient History (risk factors)
"KRN",8994,1861,3,67,0)
                          ^01: "PH"
"KRN",8994,1861,3,68,0)
                          ^02: ""
"KRN",8994,1861,3,69,0)
                          ^03: SEX RELATIONS W/MALE PARTNER   {0|1|9}
"KRN",8994,1861,3,70,0)
                          ^04: SEX RELATIONS W/FEMALE PARTNER {0|1|9}
"KRN",8994,1861,3,71,0)
                          ^05: IV DRUGS AFTER 77 AND PRE HIV  {0|1|9}
"KRN",8994,1861,3,72,0)
                          ^06: REC'D CLOTTING FACTORS         {0|1|9}
"KRN",8994,1861,3,73,0)
                          ^07: TYPE OF HEMOPHILIA             {1|2|8}
"KRN",8994,1861,3,74,0)
                          ^08: OTHER HEMOPHILIA DESCRIPTION
"KRN",8994,1861,3,75,0)
                          ^09: SR WITH IV DRUG USER           {0|1|9}
"KRN",8994,1861,3,76,0)
                          ^10: SR WITH BISEXUAL MAN           {0|1|9}
"KRN",8994,1861,3,77,0)
                          ^11: SR W HEMOPHILIA/COAG DISORDER  {0|1|9}
"KRN",8994,1861,3,78,0)
                          ^12: SR W TRANS RECIPIENT WITH AIDS {0|1|9}
"KRN",8994,1861,3,79,0)
                          ^13: TRANSPLANT RECIP-DOCUMNTD HIV  {0|1|9}
"KRN",8994,1861,3,80,0)
                          ^14: SR W AIDS/HIV INFECTION        {0|1|9}
"KRN",8994,1861,3,81,0)
                          ^15: TRANS AFTER 77 AND BEFORE HIV  {0|1|9}
"KRN",8994,1861,3,82,0)
                          ^16: DATE OF FIRST TRANSFUSION      (MM/YY)
"KRN",8994,1861,3,83,0)
                          ^17: DATE OF LAST TRANSFUSION       (MM/YY)
"KRN",8994,1861,3,84,0)
                          ^18: TRANSPLANT OR ARTIF INSEMIN    {0|1|9}
"KRN",8994,1861,3,85,0)
                          ^19: WORK IN HEALTH CARE OR LAB     {0|1|9}
"KRN",8994,1861,3,86,0)
                          ^20: OCCUPATION
"KRN",8994,1861,3,87,0)
 
"KRN",8994,1861,3,88,0)
  Results[i]            CD4 and Viral Load results
"KRN",8994,1861,3,89,0)
                          ^01: "LTR"
"KRN",8994,1861,3,90,0)
                          ^02: Result IEN (inverted date/time)
"KRN",8994,1861,3,91,0)
                          ^03: Date/time of the test (FileMan)
"KRN",8994,1861,3,92,0)
                          ^04: Result
"KRN",8994,1861,3,93,0)
                          ^05: Test IEN (in file #60)
"KRN",8994,1861,3,94,0)
                          ^06: Test name
"KRN",8994,1861,3,95,0)
                          ^07: Code of the group
"KRN",8994,1861,3,96,0)
                          ^08: Group name
"KRN",8994,1861,3,97,0)
 
"KRN",8994,1861,3,98,0)
  Results[i]            Registry Data
"KRN",8994,1861,3,99,0)
                          ^01: "ICR"
"KRN",8994,1861,3,100,0)
                          ^02: ""
"KRN",8994,1861,3,101,0)
                          ^03: Clinical AIDS                  {0|1}
"KRN",8994,1861,3,102,0)
                          ^04: Date of Clinical AIDS (FileMan)
"KRN",8994,1861,3,103,0)
                          ^05: Code of the Supporting Evidence
"KRN",8994,1861,3,104,0)
                          ^06: Date of last CD4
"KRN",8994,1861,3,105,0)
                          ^07: Last CD4
"KRN",8994,1861,3,106,0)
                          ^08: Date of lowest CD4
"KRN",8994,1861,3,107,0)
                          ^09: Lowest CD4
"KRN",8994,1861,3,108,0)
                          ^10: Date of lowest CD4 %
"KRN",8994,1861,3,109,0)
                          ^11: Lowest CD4 %
"KRN",8994,1862,-1)
0^43
"KRN",8994,1862,0)
RORICR PATIENT SAVE^SAVE^RORRP034^2^R^^^1^1
"KRN",8994,1862,1,0)
^8994.01^2^2^3030707^
"KRN",8994,1862,1,1,0)
The RORICR PATIENT SAVE remote procedure updates the patient's record in
"KRN",8994,1862,1,2,0)
the registry (or creates one).
"KRN",8994,1862,2,0)
^8994.02A^3^3
"KRN",8994,1862,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1862,2,1,1,0)
^8994.021^2^2^3030707^^^
"KRN",8994,1862,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1862,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1862,2,2,0)
PATIEN^1^^1^2
"KRN",8994,1862,2,2,1,0)
^8994.021^1^1^3030707^^^
"KRN",8994,1862,2,2,1,1,0)
A valid patient IEN (DFN) should be assigned to the PATIEN parameter.
"KRN",8994,1862,2,3,0)
DATA^2^^1^3
"KRN",8994,1862,2,3,1,0)
^^30^30^3030707^
"KRN",8994,1862,2,3,1,1,0)
A list that contains the data in the same format as the output of the
"KRN",8994,1862,2,3,1,2,0)
RORICR PATIENT LOAD remote procedure. Only PH and ICR segments are
"KRN",8994,1862,2,3,1,3,0)
processed; the others are ignored.
"KRN",8994,1862,2,3,1,4,0)
 
"KRN",8994,1862,2,3,1,5,0)
Example:
"KRN",8994,1862,2,3,1,6,0)
 
"KRN",8994,1862,2,3,1,7,0)
  with RPCBroker do
"KRN",8994,1862,2,3,1,8,0)
    begin
"KRN",8994,1862,2,3,1,9,0)
      RemoteProcedure:= 'RORICR PATIENT LOAD';
"KRN",8994,1862,2,3,1,10,0)
      Param[0].Value := RegistryIEN;
"KRN",8994,1862,2,3,1,11,0)
      Param[0].PType := literal;
"KRN",8994,1862,2,3,1,12,0)
      Param[1].Value := DFN;
"KRN",8994,1862,2,3,1,13,0)
      Param[1].PType := literal;
"KRN",8994,1862,2,3,1,14,0)
      lstCall(PatientData);     // Load the data
"KRN",8994,1862,2,3,1,15,0)
 
"KRN",8994,1862,2,3,1,16,0)
      ...                       // Edit the data
"KRN",8994,1862,2,3,1,17,0)
 
"KRN",8994,1862,2,3,1,18,0)
      RemoteProcedure:= 'RORICR PATIENT SAVE';
"KRN",8994,1862,2,3,1,19,0)
      Param[0].Value := RegistryIEN;
"KRN",8994,1862,2,3,1,20,0)
      Param[0].PType := literal;
"KRN",8994,1862,2,3,1,21,0)
      Param[1].Value := DFN;
"KRN",8994,1862,2,3,1,22,0)
      Param[1].PType := literal;
"KRN",8994,1862,2,3,1,23,0)
      Param[2].PType := list;
"KRN",8994,1862,2,3,1,24,0)
      Param[2].Mult.Assign(PatientData);
"KRN",8994,1862,2,3,1,25,0)
      Call;                     // Save the data
"KRN",8994,1862,2,3,1,26,0)
   end;
"KRN",8994,1862,2,3,1,27,0)
 
"KRN",8994,1862,2,3,1,28,0)
NOTE: Only those items of the list are processed
"KRN",8994,1862,2,3,1,29,0)
      that have numeric subscripts greater than 0;
"KRN",8994,1862,2,3,1,30,0)
      all others are ignored.
"KRN",8994,1862,2,"B","DATA",3)

"KRN",8994,1862,2,"B","PATIEN",2)

"KRN",8994,1862,2,"B","REGIEN",1)

"KRN",8994,1862,2,"PARAMSEQ",1,1)

"KRN",8994,1862,2,"PARAMSEQ",2,2)

"KRN",8994,1862,2,"PARAMSEQ",3,3)

"KRN",8994,1862,3,0)
^^21^21^3030707^
"KRN",8994,1862,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1862,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1862,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1862,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1862,3,5,0)
   
"KRN",8994,1862,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1862,3,7,0)
                          ^01: The last error code
"KRN",8994,1862,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1862,3,9,0)
                                                                      
"KRN",8994,1862,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1862,3,11,0)
                          ^01: Error code
"KRN",8994,1862,3,12,0)
                          ^02: Message
"KRN",8994,1862,3,13,0)
                          ^03: Place of the error
"KRN",8994,1862,3,14,0)
 
"KRN",8994,1862,3,15,0)
A positive value of the first "^"-piece of the Results[0] indicates an
"KRN",8994,1862,3,16,0)
error in the CDC data. The value is the number of the erroneous piece of
"KRN",8994,1862,3,17,0)
the data segment whose name is returned in the second piece of the
"KRN",8994,1862,3,18,0)
Results[0]. For example, the "16^PH" means that the 16th piece of the PH
"KRN",8994,1862,3,19,0)
data segment (DATE OF FIRST TRANSFUSION) contains an invalid value.
"KRN",8994,1862,3,20,0)
    
"KRN",8994,1862,3,21,0)
Otherwise, zero is returned in the Results[0].
"KRN",8994,1868,-1)
0^44
"KRN",8994,1868,0)
RORICR PATIENT CANCEL^CANCEL^RORRP034^2^R^^^1^1
"KRN",8994,1868,1,0)
^8994.01^3^3^3030715^
"KRN",8994,1868,1,1,0)
The RORICR PATIENT CANCEL remote procedure cancels the editing process 
"KRN",8994,1868,1,2,0)
initiated by the RORICR PATIENT LOAD remote procedure (see the LOCK 
"KRN",8994,1868,1,3,0)
parameter) and unlocks the registry records.
"KRN",8994,1868,2,0)
^8994.02A^2^2
"KRN",8994,1868,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1868,2,1,1,0)
^8994.021^2^2^3030707^^^
"KRN",8994,1868,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1868,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1868,2,2,0)
PATIEN^1^^1^2
"KRN",8994,1868,2,2,1,0)
^8994.021^1^1^3030707^^^
"KRN",8994,1868,2,2,1,1,0)
A valid patient IEN (DFN) should be assigned to the PATIEN parameter.
"KRN",8994,1868,2,"B","PATIEN",2)

"KRN",8994,1868,2,"B","REGIEN",1)

"KRN",8994,1868,2,"PARAMSEQ",1,1)

"KRN",8994,1868,2,"PARAMSEQ",2,2)

"KRN",8994,1868,3,0)
^^15^15^3030715^
"KRN",8994,1868,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1868,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1868,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1868,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1868,3,5,0)
   
"KRN",8994,1868,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1868,3,7,0)
                          ^01: The last error code
"KRN",8994,1868,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1868,3,9,0)
                                                                      
"KRN",8994,1868,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1868,3,11,0)
                          ^01: Error code
"KRN",8994,1868,3,12,0)
                          ^02: Message
"KRN",8994,1868,3,13,0)
                          ^03: Place of the error
"KRN",8994,1868,3,14,0)
    
"KRN",8994,1868,3,15,0)
Otherwise, zero is returned in the Results[0].
"KRN",8994,1869,-1)
0^45
"KRN",8994,1869,0)
RORICR CDC CANCEL^CANCEL^RORRP027^2^R^^^1^1
"KRN",8994,1869,1,0)
^^3^3^3030716^
"KRN",8994,1869,1,1,0)
The RORICR CDC CANCEL remote procedure cancels the editing process 
"KRN",8994,1869,1,2,0)
initiated by the RORICR CDC LOAD remote procedure (see the LOCK parameter)
"KRN",8994,1869,1,3,0)
and unlocks the registry records.
"KRN",8994,1869,2,0)
^8994.02A^2^2
"KRN",8994,1869,2,1,0)
REGIEN^1^^1^1
"KRN",8994,1869,2,1,1,0)
^8994.021^2^2^3030707^^^
"KRN",8994,1869,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the
"KRN",8994,1869,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,1869,2,2,0)
PATIEN^1^^1^2
"KRN",8994,1869,2,2,1,0)
^8994.021^1^1^3030716^^^^
"KRN",8994,1869,2,2,1,1,0)
A valid patient IEN (DFN) should be assigned to the PATIEN parameter.
"KRN",8994,1869,2,"B","PATIEN",2)

"KRN",8994,1869,2,"B","REGIEN",1)

"KRN",8994,1869,2,"PARAMSEQ",1,1)

"KRN",8994,1869,2,"PARAMSEQ",2,2)

"KRN",8994,1869,3,0)
^8994.03^15^15^3030716^^
"KRN",8994,1869,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,1869,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,1869,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,1869,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,1869,3,5,0)
   
"KRN",8994,1869,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,1869,3,7,0)
                          ^01: The last error code
"KRN",8994,1869,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,1869,3,9,0)
                                                                      
"KRN",8994,1869,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,1869,3,11,0)
                          ^01: Error code
"KRN",8994,1869,3,12,0)
                          ^02: Message
"KRN",8994,1869,3,13,0)
                          ^03: Place of the error
"KRN",8994,1869,3,14,0)
    
"KRN",8994,1869,3,15,0)
Otherwise, zero is returned in the Results[0].
"KRN",8994,2001,-1)
0^47
"KRN",8994,2001,0)
ROR LIST GENERIC DRUGS^GDLIST^RORRP035^4^A^^^1^1
"KRN",8994,2001,1,0)
^^2^2^3040114^
"KRN",8994,2001,1,1,0)
The ROR LIST GENERIC DRUGS remote procedure returns a list of generic
"KRN",8994,2001,1,2,0)
drugs, which are referenced by the ROR GENERIC DRUG file (#799.51).
"KRN",8994,2001,2,0)
^8994.02A^2^2
"KRN",8994,2001,2,1,0)
REGIEN^1^^1^1
"KRN",8994,2001,2,1,1,0)
^8994.021^2^2^3030625^^
"KRN",8994,2001,2,1,1,1,0)
The REGIEN parameter should contain a valid registry IEN (IEN of the 
"KRN",8994,2001,2,1,1,2,0)
registry parameters record in the ROR REGISTRY PARAMETERS file #798.1).
"KRN",8994,2001,2,2,0)
GROUP^1^^^2
"KRN",8994,2001,2,2,1,0)
^8994.021^3^3^3040114^^
"KRN",8994,2001,2,2,1,1,0)
If this parameter is defined and not zero, it should contain a valid code
"KRN",8994,2001,2,2,1,2,0)
of the Drug Group. In this case, only the drugs associated with this group
"KRN",8994,2001,2,2,1,3,0)
will be returned.
"KRN",8994,2001,2,"B","GROUP",2)

"KRN",8994,2001,2,"B","REGIEN",1)

"KRN",8994,2001,2,"PARAMSEQ",1,1)

"KRN",8994,2001,2,"PARAMSEQ",2,2)

"KRN",8994,2001,3,0)
^^24^24^3040114^
"KRN",8994,2001,3,1,0)
A negative value of the first "^"-piece of the Results[0] indicates that
"KRN",8994,2001,3,2,0)
an error occurred during the execution of the remote procedure. In this
"KRN",8994,2001,3,3,0)
case, the second piece of the Results[0] will contain number of the error
"KRN",8994,2001,3,4,0)
descriptors returned in the subsequent nodes of the Results array:
"KRN",8994,2001,3,5,0)
  
"KRN",8994,2001,3,6,0)
  Results[0]            Result Descriptor
"KRN",8994,2001,3,7,0)
                          ^01: The last error code
"KRN",8994,2001,3,8,0)
                          ^02: Number of the error descriptors
"KRN",8994,2001,3,9,0)
                                                                      
"KRN",8994,2001,3,10,0)
  Results[i]            Error Descriptor
"KRN",8994,2001,3,11,0)
                          ^01: Error code
"KRN",8994,2001,3,12,0)
                          ^02: Message
"KRN",8994,2001,3,13,0)
                          ^03: Place of the error
"KRN",8994,2001,3,14,0)
 
"KRN",8994,2001,3,15,0)
Otherwise, number of drugs is returned in the Results[0] and the 
"KRN",8994,2001,3,16,0)
subsequent nodes of the global array contain the drugs.
"KRN",8994,2001,3,17,0)
 
"KRN",8994,2001,3,18,0)
  Results[0]            Number of Drugs
"KRN",8994,2001,3,19,0)
 
"KRN",8994,2001,3,20,0)
  Results[i]            Drug Descriptor
"KRN",8994,2001,3,21,0)
                          ^01: IEN in the ROR GENERIC DRUG file
"KRN",8994,2001,3,22,0)
                          ^02: Generic drug name
"KRN",8994,2001,3,23,0)
                          ^03: IEN of the generic drug (in the file #50.6)
"KRN",8994,2001,3,24,0)
                          ^04: Code of the Drug Group (see file #799.51)
"MBREQ")
0
"ORD",3,19.1)
19.1;3;1;;KEY^XPDTA1;;;KEYF2^XPDIA1;;KEYDEL^XPDIA1
"ORD",3,19.1,0)
SECURITY KEY
"ORD",4,.5)
.5;4;;;EDEOUT^DIFROMSO(.5,DA,"",XPDA);FPRE^DIFROMSI(.5,"",XPDA);EPRE^DIFROMSI(.5,DA,"",XPDA,"",OLDA);;EPOST^DIFROMSI(.5,DA,"",XPDA)
"ORD",4,.5,0)
FUNCTION
"ORD",7,.402)
.402;7;;;EDEOUT^DIFROMSO(.402,DA,"",XPDA);FPRE^DIFROMSI(.402,"",XPDA);EPRE^DIFROMSI(.402,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.402,DA,"",XPDA);DEL^DIFROMSK(.402,"",%)
"ORD",7,.402,0)
INPUT TEMPLATE
"ORD",9,.84)
.84;9;;;EDEOUT^DIFROMSO(.84,DA,"",XPDA);FPRE^DIFROMSI(.84,"",XPDA);EPRE^DIFROMSI(.84,DA,"",XPDA,"",OLDA);;EPOST^DIFROMSI(.84,DA,"",XPDA);DEL^DIFROMSK(.84,"",%)
"ORD",9,.84,0)
DIALOG
"ORD",13,870)
870;13;1;;HLLL^XPDTA1;;HLLLE^XPDIA1;;;HLLLDEL^XPDIA1(%)
"ORD",13,870,0)
HL LOGICAL LINK
"ORD",15,101)
101;15;;;PRO^XPDTA;PROF1^XPDIA;PROE1^XPDIA;PROF2^XPDIA;;PRODEL^XPDIA
"ORD",15,101,0)
PROTOCOL
"ORD",16,8994)
8994;16;1;;;;;;;RPCDEL^XPDIA1
"ORD",16,8994,0)
REMOTE PROCEDURE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"ORD",20,8989.51)
8989.51;20;;;PAR1E1^XPDTA2;PAR1F1^XPDIA3;PAR1E1^XPDIA3;PAR1F2^XPDIA3;;PAR1DEL^XPDIA3(%)
"ORD",20,8989.51,0)
PARAMETER DEFINITION
"PGL",798.1,9,1,13)
PROTOCOL^*P101'X^ORD(101,^9;1^Q:$$VAEDT^RORDD(798.1,$G(DA))  S DIC("S")="S D=$G(^(0)) I $E($P(D,U),1,3)=""ROR"",$P(D,U,4)=""E""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"PGL",798.128,0,2,.02)
LAB GROUP^R*P799.1'X^ROR(799.1,^0;2^S DIC("S")="S D=$G(^(0)) I $P(D,U,2)=3,$P(D,U,3)="_DA(1) D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"PGL",798.129,0,2,.02)
DRUG GROUP^R*P799.1'X^ROR(799.1,^0;2^S DIC("S")="S D=$G(^(0)) I $P(D,U,2)=4,$P(D,U,3)="_DA(1) D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"PGL",798.19,0,3,.02)
DATA AREA^RP799.33'X^ROR(799.33,^0;3^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))
"PKG",389,-1)
1^1
"PKG",389,0)
CLINICAL CASE REGISTRIES^ROR^CLINICAL CASE REGISTRIES
"PKG",389,20,0)
^9.402P^^
"PKG",389,22,0)
^9.49I^1^1
"PKG",389,22,1,0)
1.0^3020515^3020726^222222227
"PKG",389,22,1,"PAH",1,0)
5^3040223^222222227
"PKG",389,22,1,"PAH",1,1,0)
^^2^2^3040223
"PKG",389,22,1,"PAH",1,1,1,0)
This build introduces Immunology Case Registry v3.0 and several fixes for 
"PKG",389,22,1,"PAH",1,1,2,0)
the the Clinical Case Registries.
"PRE")
RORP005
"QUES","POS05 SETUP",0)
Y
"QUES","POS05 SETUP","?")
  Enter either 'Y' or 'N'.
"QUES","POS05 SETUP","?",1)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"QUES","POS05 SETUP","?",2)
  After the software is installed, the registry must be
"QUES","POS05 SETUP","?",3)
  populated with the patients that have HIV/AIDS related data.
"QUES","POS05 SETUP","?",4)
  The registry setup task populates the registry and performs
"QUES","POS05 SETUP","?",5)
  other implementation steps. If you are installing this patch
"QUES","POS05 SETUP","?",6)
  for the first time, you must answer YES.
"QUES","POS05 SETUP","?",7)
 
"QUES","POS05 SETUP","?",8)
  When the initial registry population is complete, you will
"QUES","POS05 SETUP","?",9)
  receive a VistA alert. Only after that you can add the name
"QUES","POS05 SETUP","?",10)
  of the registry (VA ICR) to the nightly task (the [ROR TASK]
"QUES","POS05 SETUP","?",11)
  option) parameter.
"QUES","POS05 SETUP","?",12)
 
"QUES","POS05 SETUP","?",13)
  If you are reinstalling the patch and initial registry
"QUES","POS05 SETUP","?",14)
  population has been done already, the answer depends on the
"QUES","POS05 SETUP","?",15)
  reason for the reinstallation and the instructions, which 
"QUES","POS05 SETUP","?",16)
  you have probably been given.
"QUES","POS05 SETUP","?",17)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"QUES","POS05 SETUP","A")
Schedule the registry setup task
"QUES","POS05 SETUP","B")

"QUES","POS05 SETUP","M")
S DIR("B")=$S($$PATCH^XPDUTL("ROR*1*5"):"NO",1:"YES")
"QUES","POS10 MAXNTSK",0)
N^0:10:0
"QUES","POS10 MAXNTSK","?")
  Enter a number between 0 and 10, 0 decimal digits.
"QUES","POS10 MAXNTSK","?",1)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"QUES","POS10 MAXNTSK","?",2)
  During the initial registry population performed by the
"QUES","POS10 MAXNTSK","?",3)
  registry setup task several registry update subtask can be
"QUES","POS10 MAXNTSK","?",4)
  scheduled to speed up the process.
"QUES","POS10 MAXNTSK","?",5)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"QUES","POS10 MAXNTSK","A")
Maximum number of registry update subtasks
"QUES","POS10 MAXNTSK","B")
5
"QUES","POS10 MAXNTSK","M")
K:'$G(XPDQUES("POS05 SETUP")) DIR,XPDQUES("POS10 MAXNTSK")
"QUES","POS15 SUSPEND",0)
Y
"QUES","POS15 SUSPEND","?")
  Enter either 'Y' or 'N'.
"QUES","POS15 SUSPEND","?",1)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"QUES","POS15 SUSPEND","?",2)
  If you answer YES to this question, registry update subtasks
"QUES","POS15 SUSPEND","?",3)
  that populate the registry will be suspended during the peak
"QUES","POS15 SUSPEND","?",4)
  weekday hours to conserve the CPU resources.
"QUES","POS15 SUSPEND","?",5)
 
"QUES","POS15 SUSPEND","?",6)
  The tasks will not be suspended on weekends and holidays.
"QUES","POS15 SUSPEND","?",7)
  If the initial registry update runs in the single-task mode,
"QUES","POS15 SUSPEND","?",8)
  it will never be suspended.
"QUES","POS15 SUSPEND","?",9)
 
"QUES","POS15 SUSPEND","?",10)
  Two additional prompts will be displayed asking you to enter
"QUES","POS15 SUSPEND","?",11)
  start and end time of the suspension.
"QUES","POS15 SUSPEND","?",12)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"QUES","POS15 SUSPEND","A")
Suspend the post-install during the peak hours
"QUES","POS15 SUSPEND","B")
YES
"QUES","POS15 SUSPEND","M")
K:$G(XPDQUES("POS10 MAXNTSK"))<2 DIR,XPDQUES("POS15 SUSPEND")
"QUES","POS20 SUSPEND BEGIN",0)
D^::R
"QUES","POS20 SUSPEND BEGIN","?")
  Enter time of the day (e.g. 8AM).
"QUES","POS20 SUSPEND BEGIN","?",1)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"QUES","POS20 SUSPEND BEGIN","?",2)
  Registry update subtasks will be suspended after this time 
"QUES","POS20 SUSPEND BEGIN","?",3)
  every day except the weekends and holidays. However, they 
"QUES","POS20 SUSPEND BEGIN","?",4)
  will be checking for a stop request every hour during the
"QUES","POS20 SUSPEND BEGIN","?",5)
  suspension.
"QUES","POS20 SUSPEND BEGIN","?",6)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"QUES","POS20 SUSPEND BEGIN","A")
Suspension start time
"QUES","POS20 SUSPEND BEGIN","B")
6:00AM
"QUES","POS20 SUSPEND BEGIN","M")
K:'$G(XPDQUES("POS15 SUSPEND")) DIR
"QUES","POS25 SUSPEND END",0)
D^::R
"QUES","POS25 SUSPEND END","?")
  Enter time of the day (e.g. 5PM).
"QUES","POS25 SUSPEND END","?",1)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"QUES","POS25 SUSPEND END","?",2)
  The registry update subtasks will be resumed at this time 
"QUES","POS25 SUSPEND END","?",3)
  every day. The suspension end time must be later than the
"QUES","POS25 SUSPEND END","?",4)
  suspension start time.
"QUES","POS25 SUSPEND END","?",5)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"QUES","POS25 SUSPEND END","A")
Suspension end time
"QUES","POS25 SUSPEND END","B")
8:00PM
"QUES","POS25 SUSPEND END","M")
K:'$G(XPDQUES("POS15 SUSPEND")) DIR
"QUES","POS30 CONFIRMATION",0)
Y^^S:$$UP^XLFSTR($TR(X," "))?1"N".E X="^",(DUOUT,DIRUT)=1
"QUES","POS30 CONFIRMATION","?")
  Enter 'Y' to continue or 'N' to cancel the installation.
"QUES","POS30 CONFIRMATION","?",1)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"QUES","POS30 CONFIRMATION","?",2)
  It is not possible to correct the value of the parameters 
"QUES","POS30 CONFIRMATION","?",3)
  unless the installation is restarted. If you have entered 
"QUES","POS30 CONFIRMATION","?",4)
  something incorrectly, cancel the installation (do not 
"QUES","POS30 CONFIRMATION","?",5)
  remove the Transport Global) and start it again using the 
"QUES","POS30 CONFIRMATION","?",6)
  Install Package(s) option.
"QUES","POS30 CONFIRMATION","?",7)
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"QUES","POS30 CONFIRMATION","A")
Are you sure
"QUES","POS30 CONFIRMATION","M")
D CONFTXT^RORP005 K:'$G(XPDQUES("POS05 SETUP")) DIR
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
173
"RTN","ROR")
0^25^B18134268
"RTN","ROR",1,0)
ROR ;HCIOFO/SG - CLINICAL CASE REGISTRIES ; 1/9/04 10:10am
"RTN","ROR",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3,5**;May 14, 2002
"RTN","ROR",3,0)
 ;
"RTN","ROR",4,0)
 ; LOCAL VARIABLE ------ DESCRIPTION
"RTN","ROR",5,0)
 ;
"RTN","ROR",6,0)
 ; RORCACHE              In-memory cache
"RTN","ROR",7,0)
 ; RORERRDL              Default error location
"RTN","ROR",8,0)
 ; RORERROR              Error processing data
"RTN","ROR",9,0)
 ; RORPARM               Task-wide constants and variables
"RTN","ROR",10,0)
 ;
"RTN","ROR",11,0)
 ; See the source code of the ^ROR02 routine for more details.
"RTN","ROR",12,0)
 ;
"RTN","ROR",13,0)
 ; ROREXT                Regular data extraction    (See ^ROREXT)
"RTN","ROR",14,0)
 ; RORHDT                Historical data extraction (See ^RORHDT)
"RTN","ROR",15,0)
 ; RORLOG                Log subsystem data         (See ^RORLOG)
"RTN","ROR",16,0)
 ; RORUPD                Registry update parameters (See ^RORUPD)
"RTN","ROR",17,0)
 ;
"RTN","ROR",18,0)
 ; TEMPORARY NODE ------ DESCRIPTION
"RTN","ROR",19,0)
 ;
"RTN","ROR",20,0)
 ; ^TMP("RORACK")        Control data of acknowledgement processing
"RTN","ROR",21,0)
 ; ^TMP("RORHDT")        Control data of historical data extraction
"RTN","ROR",22,0)
 ; ^TMP("RORTMP")        Temporary storage
"RTN","ROR",23,0)
 ; ^TMP("RORUPD")        Registry update temporary data
"RTN","ROR",24,0)
 ;
"RTN","ROR",25,0)
 ; ^TMP(rtn_name)        Temporary storage used by the rtn_name
"RTN","ROR",26,0)
 ;                       routine (mostly, the RPC's)
"RTN","ROR",27,0)
 ;
"RTN","ROR",28,0)
 ; ^XTMP("RORHDT")       Control data of historical data extraction
"RTN","ROR",29,0)
 ; ^XTMP("RORUPDJ")      Registry update temporary data (multitask)
"RTN","ROR",30,0)
 ; ^XTMP("RORUPDR")      Registry update temporary data (installation)
"RTN","ROR",31,0)
 ;
"RTN","ROR",32,0)
 ; See detailed description of the temporary global nodes in
"RTN","ROR",33,0)
 ; the source code of the ^ROR01 routine.
"RTN","ROR",34,0)
 ;
"RTN","ROR",35,0)
 ; NAMESPACE ----------- DESCRIPTION
"RTN","ROR",36,0)
 ;
"RTN","ROR",37,0)
 ; RORACK*               Acknowldgement processing
"RTN","ROR",38,0)
 ; RORAPI*               Supported APIs
"RTN","ROR",39,0)
 ; RORDD*                Routines used by the Data Dictionary
"RTN","ROR",40,0)
 ; RORERR*               Error processing
"RTN","ROR",41,0)
 ; ROREVT*               Event protocols
"RTN","ROR",42,0)
 ; ROREX*                Regular data extraction & transmission
"RTN","ROR",43,0)
 ; RORHDT*               Historical data extraction
"RTN","ROR",44,0)
 ; RORHL*                HL7
"RTN","ROR",45,0)
 ; RORICR*               ICR-specific call-back routines
"RTN","ROR",46,0)
 ; RORKIDS*              Low-level installation utilities (KIDS)
"RTN","ROR",47,0)
 ; RORLOCK*              Locks and transactions
"RTN","ROR",48,0)
 ; RORLOG*               Error recording
"RTN","ROR",49,0)
 ;
"RTN","ROR",50,0)
 ; RORPnnn               Patch installation routines (KIDS)
"RTN","ROR",51,0)
 ;                         nnn - patch number
"RTN","ROR",52,0)
 ; RORPEnnn              Environment check routines (deprecated)
"RTN","ROR",53,0)
 ; RORPOnnn              Post-install routines      (deprecated)
"RTN","ROR",54,0)
 ; RORPRnnn              Pre-install routines       (deprecated)
"RTN","ROR",55,0)
 ; RORPUT*               High-level installation utilities
"RTN","ROR",56,0)
 ;
"RTN","ROR",57,0)
 ; RORREP*               Roll-and-scroll reports
"RTN","ROR",58,0)
 ; RORRP*                Remote procedures
"RTN","ROR",59,0)
 ; RORSET*               Setup routines
"RTN","ROR",60,0)
 ; RORTXT*               Text resource routines
"RTN","ROR",61,0)
 ; RORUP*                Registry update
"RTN","ROR",62,0)
 ; RORUTL*               Utilities
"RTN","ROR",63,0)
 ; RORVM*                Entry points for VistA menu options
"RTN","ROR",64,0)
 ; RORX*                 XML reports
"RTN","ROR",65,0)
 ;
"RTN","ROR",66,0)
 ; MENU OPTION --------- DESCRIPTION
"RTN","ROR",67,0)
 ;
"RTN","ROR",68,0)
 ; [ROR TASK]            Registry update and data extraction option
"RTN","ROR",69,0)
 ;                       (must be scheduled; do not run it directly)
"RTN","ROR",70,0)
 ; [ROR SETUP HEPC]      Setup the HepC registry
"RTN","ROR",71,0)
 ; [RORHDT MAIN]         Historical data extraction menu
"RTN","ROR",72,0)
 ; [RORMNT MAIN]         Maintenance menu
"RTN","ROR",73,0)
 ;
"RTN","ROR",74,0)
 ; SPECIAL ENTRY POINT - DESCRIPTION
"RTN","ROR",75,0)
 ;
"RTN","ROR",76,0)
 ;    START^RORTSITE     Prepares test sites for going live
"RTN","ROR",77,0)
 ;         ^RORUTL06     Registry definition validator
"RTN","ROR",78,0)
 ; DISTPREP^RORUTL06     Prepares registry parameters for KIDS distr.
"RTN","ROR",79,0)
 ;   PRTMDE^RORUTL06     Prints the data element metadata
"RTN","ROR",80,0)
 ;
"RTN","ROR",81,0)
 ;  EXTRACT^RORUTL07     Data extraction & transmission in debug mode
"RTN","ROR",82,0)
 ;   UPDATE^RORUTL07     Registry update in debug mode
"RTN","ROR",83,0)
 ;
"RTN","ROR",84,0)
 ; INITIALS ------------ DEVELOPER
"RTN","ROR",85,0)
 ;
"RTN","ROR",86,0)
 ; BH                    Brent Hicks
"RTN","ROR",87,0)
 ; CRT                   Cameron Taylor
"RTN","ROR",88,0)
 ; SG                    Sergey Gavrilov
"RTN","ROR",89,0)
 ;
"RTN","ROR",90,0)
 Q
"RTN","ROR",91,0)
 ;
"RTN","ROR",92,0)
 ;***** REGISTRY UPDATE AND DATA EXTRACTION TASK
"RTN","ROR",93,0)
 ;
"RTN","ROR",94,0)
 ; ZTQPARAM      String that contains a list of registry names
"RTN","ROR",95,0)
 ;               separated by commas. You must define the list as
"RTN","ROR",96,0)
 ;               a value of the TASK PARAMETERS field during
"RTN","ROR",97,0)
 ;               scheduling of the [ROR TASK] option that uses
"RTN","ROR",98,0)
 ;               this entry point.
"RTN","ROR",99,0)
 ;
"RTN","ROR",100,0)
 ; The following task parameters are optional. They can be defined
"RTN","ROR",101,0)
 ; on the second page of the option scheduling form as the pairs of
"RTN","ROR",102,0)
 ; variable names and values. See description of the ROR TASK option
"RTN","ROR",103,0)
 ; for more details regarding these parameters.
"RTN","ROR",104,0)
 ;
"RTN","ROR",105,0)
 ; [RORFLCLR]    Clear flags to control processing.
"RTN","ROR",106,0)
 ; [RORFLSET]    Set flags to control processing.
"RTN","ROR",107,0)
 ;
"RTN","ROR",108,0)
 ;                 D  Run the task(s) in Debug Mode #1
"RTN","ROR",109,0)
 ;
"RTN","ROR",110,0)
 ;                 E  Use the event references (file #798.3)
"RTN","ROR",111,0)
 ;
"RTN","ROR",112,0)
 ;                 X  Suspend the data extraction task in the
"RTN","ROR",113,0)
 ;                    same way as the registry update
"RTN","ROR",114,0)
 ;
"RTN","ROR",115,0)
 ; [RORMNTSK]    Maximum number of the registry update subtasks.
"RTN","ROR",116,0)
 ;               The default value of the parameter is "2-3-AUTO".
"RTN","ROR",117,0)
 ;
"RTN","ROR",118,0)
 ; [RORSUSP]     Suspension parameters of the registry update and
"RTN","ROR",119,0)
 ;               data extraction subtasks. The subtasks are not
"RTN","ROR",120,0)
 ;               suspended by default.
"RTN","ROR",121,0)
 ;
"RTN","ROR",122,0)
 ;               If you want to suspend data extraction subtask(s)
"RTN","ROR",123,0)
 ;               also, the flag "X" should be included in the value
"RTN","ROR",124,0)
 ;               of the RORFLSET parameters.
"RTN","ROR",125,0)
 ;
"RTN","ROR",126,0)
TASK ;
"RTN","ROR",127,0)
 N RORERROR      ; Error processing data
"RTN","ROR",128,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","ROR",129,0)
 N RORPARM       ; Application parameters
"RTN","ROR",130,0)
 ;
"RTN","ROR",131,0)
 N CNT,I,RC,REGLST,REGNAME,RGEXLST,RORERRDL  K ZTREQ
"RTN","ROR",132,0)
 ;--- Initialize constants and variables
"RTN","ROR",133,0)
 D INIT^RORUTL01("ROR",1)
"RTN","ROR",134,0)
 D CLEAR^RORERR("TASK^ROR",1)
"RTN","ROR",135,0)
 ;--- Open a new log
"RTN","ROR",136,0)
 S RC=$$SETUP^RORLOG(),RC=$$OPEN^RORLOG(,,"ROR TASK STARTED")
"RTN","ROR",137,0)
 ;--- Check the task parameters and force the <UNDEF>
"RTN","ROR",138,0)
 ;--- error if any of them has an invalid value
"RTN","ROR",139,0)
 I $$TASKPRMS^ROR10(.REGLST)<0  K ZTQPARAM  S RC=ZTQPARAM
"RTN","ROR",140,0)
 ;--- Associate the log with the registries
"RTN","ROR",141,0)
 S RC=$$SETRGLST^RORLOG(.REGLST)
"RTN","ROR",142,0)
 ;
"RTN","ROR",143,0)
 ;--- Debug mode
"RTN","ROR",144,0)
 S:$G(RORFLSET)["D" RORPARM("DEBUG")=1
"RTN","ROR",145,0)
 ;
"RTN","ROR",146,0)
 ;--- Rebuild the "ACL" cross-reference
"RTN","ROR",147,0)
 S RC=$$RNDXACL^RORUTL11()
"RTN","ROR",148,0)
 ;--- Check the application acknowledgements
"RTN","ROR",149,0)
 S RC=$$CHECKACK^ROR10(.REGLST)
"RTN","ROR",150,0)
 ;
"RTN","ROR",151,0)
 ;--- Update the registries
"RTN","ROR",152,0)
 S RC=$$UPDATE^RORUPD(.REGLST,.RGEXLST,RORMNTSK,RORSUSP,RORFLCLR,RORFLSET)
"RTN","ROR",153,0)
 ;--- Process the errors
"RTN","ROR",154,0)
 I RC<0  D  G:RC<0 ABORT
"RTN","ROR",155,0)
 . ;--- Quit if stop is requested (via the TaskMan User option)
"RTN","ROR",156,0)
 . I RC=-42  D ALERT^RORUTL01(.REGLST,-42)  S ZTSTOP=1  Q
"RTN","ROR",157,0)
 . ;--- Do not send the alert for some warnings
"RTN","ROR",158,0)
 . I RC=-28  S RC=0  Q
"RTN","ROR",159,0)
 . ;--- Send the alert in case of other errors/warnings
"RTN","ROR",160,0)
 . D ALERT^RORUTL01(.REGLST,-43,,,,"registry update")
"RTN","ROR",161,0)
 . S RC=0
"RTN","ROR",162,0)
 ;
"RTN","ROR",163,0)
 ;--- Mark registry records 3 weeks after the installation so that
"RTN","ROR",164,0)
 ;    the local registry data and demographic data will be resent
"RTN","ROR",165,0)
 ;--- to restore the data overwritten with the historical data
"RTN","ROR",166,0)
 S RC=$$REMARK^RORUTL05(.RGEXLST,21)
"RTN","ROR",167,0)
 ;
"RTN","ROR",168,0)
 ;--- Schedule the data extraction task(s)
"RTN","ROR",169,0)
 S REGNAME=""  K ZTSAVE
"RTN","ROR",170,0)
 F CNT=1:1  S REGNAME=$O(RGEXLST(REGNAME))  Q:REGNAME=""  D
"RTN","ROR",171,0)
 . S ZTRTN="TASK^ROREXT",ZTIO=""
"RTN","ROR",172,0)
 . S ZTDTH=$$FMADD^XLFDT($$NOW^XLFDT,,,,(CNT-1)*30)
"RTN","ROR",173,0)
 . S ZTDESC="Data Extraction ("_REGNAME_")"
"RTN","ROR",174,0)
 . S ZTSAVE("RORREG")=REGNAME
"RTN","ROR",175,0)
 . S ZTSAVE("RORFLCLR")="",ZTSAVE("RORFLSET")=""
"RTN","ROR",176,0)
 . S ZTSAVE("RORSUSP")=""
"RTN","ROR",177,0)
 . D ^%ZTLOAD
"RTN","ROR",178,0)
 ;
"RTN","ROR",179,0)
 ;--- Purge the old tasks
"RTN","ROR",180,0)
 S RC=$$PURGE^RORTSK02(14)
"RTN","ROR",181,0)
 ;--- Purge the old logs
"RTN","ROR",182,0)
 S RC=$$PURGE^RORLOG01(14)
"RTN","ROR",183,0)
 ;--- Purge the old event references
"RTN","ROR",184,0)
 S RC=$$EPDATE^RORUTL05()
"RTN","ROR",185,0)
 S:RC>0 RC=$$PURGE^RORUPP02(RC)
"RTN","ROR",186,0)
 ;---
"RTN","ROR",187,0)
 S ZTREQ="@"
"RTN","ROR",188,0)
ABORT ;
"RTN","ROR",189,0)
 S I=$S($G(ZTREQ)="@":"COMPLETED",1:"ABORTED")
"RTN","ROR",190,0)
 D CLOSE^RORLOG("ROR TASK "_I)
"RTN","ROR",191,0)
 Q
"RTN","ROR01")
0^55^B15130
"RTN","ROR01",1,0)
ROR01 ;HCIOFO/SG - CLINICAL CASE REGISTRIES (TEMP. GLOBALS) ; 4/8/03 9:08am
"RTN","ROR01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","ROR01",3,0)
 ;
"RTN","ROR01",4,0)
 ; ^TMP("RORACK") ------ CONTROL DATA OF ACKNOWLEDGEMENT PROCESSING
"RTN","ROR01",5,0)
 ;
"RTN","ROR01",6,0)
 ; ^TMP("RORACK",$J,
"RTN","ROR01",7,0)
 ;   "PR",IEN)           List of IENs of registry records that
"RTN","ROR01",8,0)
 ;                       acknowledgements have been processed for.
"RTN","ROR01",9,0)
 ;
"RTN","ROR01",10,0)
 ; ^TMP("RORHDT") ------ CONTROL DATA OF HISTORICAL DATA EXTRACTION
"RTN","ROR01",11,0)
 ;
"RTN","ROR01",12,0)
 ; ^TMP("RORHDT",$J,
"RTN","ROR01",13,0)
 ;   "PR",               List of IENs of registry records processed
"RTN","ROR01",14,0)
 ;                       in the re-extraction section of function
"RTN","ROR01",15,0)
 ;                       $$EXTRACT^RORHDT04.
"RTN","ROR01",16,0)
 ;     IEN)              Return code of the record processing. If this
"RTN","ROR01",17,0)
 ;                       value is less than zero, data extraction was
"RTN","ROR01",18,0)
 ;                       not successful again.
"RTN","ROR01",19,0)
 ;
"RTN","ROR01",20,0)
 ; ^TMP("RORTMP",$J) --- TEMPORARY STORAGE
"RTN","ROR01",21,0)
 ;
"RTN","ROR01",22,0)
 ; ^TMP("RORUPD") ------ REGISTRY UPDATE TEMPORARY DATA
"RTN","ROR01",23,0)
 ;
"RTN","ROR01",24,0)
 ; ^TMP("RORUPD",$J,
"RTN","ROR01",25,0)
 ;
"RTN","ROR01",26,0)
 ;   1,File#,
"RTN","ROR01",27,0)
 ;     "S",Rule Name)    List of selection rules
"RTN","ROR01",28,0)
 ;     "F",DataCode,     List of data elements to load
"RTN","ROR01",29,0)
 ;       "E")            If expression implementing the selection
"RTN","ROR01",30,0)
 ;                       rule references an external value of the
"RTN","ROR01",31,0)
 ;                       element, the "E" sub-node will be defined.
"RTN","ROR01",32,0)
 ;       "I")            If expression implementing the selection
"RTN","ROR01",33,0)
 ;                       rule references an internal value of the
"RTN","ROR01",34,0)
 ;                       element, the "I" sub-node will be defined.
"RTN","ROR01",35,0)
 ;
"RTN","ROR01",36,0)
 ;   2,Registry#)        Registry Name
"RTN","ROR01",37,0)
 ;
"RTN","ROR01",38,0)
 ;   3,Rule Name,        Selection rule descriptor
"RTN","ROR01",39,0)
 ;                         ^1: Rule#
"RTN","ROR01",40,0)
 ;                         ^2: File Number
"RTN","ROR01",41,0)
 ;                         ^3: 1 if already processed, otherwise
"RTN","ROR01",42,0)
 ;                             empty string
"RTN","ROR01",43,0)
 ;                         ^4: 1 if registry should be updated (in
"RTN","ROR01",44,0)
 ;                             case of matched condition, of course)
"RTN","ROR01",45,0)
 ;     1)                MUMPS function entry point
"RTN","ROR01",46,0)
 ;     2,Registry#)      List of affected registries
"RTN","ROR01",47,0)
 ;     3,Rule Name)      List of rules that this rule depend on
"RTN","ROR01",48,0)
 ;
"RTN","ROR01",49,0)
 ;   4,LabSearch#)       List of Lab search IENs
"RTN","ROR01",50,0)
 ;
"RTN","ROR01",51,0)
 ;   "LS",
"RTN","ROR01",52,0)
 ;     Result Code,
"RTN","ROR01",53,0)
 ;       LabSearch#,
"RTN","ROR01",54,0)
 ;         Seq#)         Condition to check the result
"RTN","ROR01",55,0)
 ;                         ^1: Indicator
"RTN","ROR01",56,0)
 ;                         ^2: Indicated Value
"RTN","ROR01",57,0)
 ;
"RTN","ROR01",58,0)
 ;   "U",Patient#,       This node is defined if the patient has been 
"RTN","ROR01",59,0)
 ;                       processed
"RTN","ROR01",60,0)
 ;     2,Registry#,      This node is defined if the registry should
"RTN","ROR01",61,0)
 ;                       be updated
"RTN","ROR01",62,0)
 ;       Rule#)          Trigger date of the rule
"RTN","ROR01",63,0)
 ;
"RTN","ROR01",64,0)
 ; ^XTMP("RORHDT"_) ---- CONTROL DATA OF HISTORICAL DATA EXTRACTION
"RTN","ROR01",65,0)
 ;
"RTN","ROR01",66,0)
 ; ^XTMP("RORHDT"_Registry#,
"RTN","ROR01",67,0)
 ;   0)                  Node descriptor
"RTN","ROR01",68,0)
 ;                         ^1: purge date  (FileMan)
"RTN","ROR01",69,0)
 ;                         ^2: create date (FileMan)
"RTN","ROR01",70,0)
 ;                         ^3: description
"RTN","ROR01",71,0)
 ;
"RTN","ROR01",72,0)
 ;   "T",Task#)          This node is LOCKed by the historical data
"RTN","ROR01",73,0)
 ;                       extraction task while it is running. If a
"RTN","ROR01",74,0)
 ;                       non-zero value is asssigned to this node
"RTN","ROR01",75,0)
 ;                       during task execution, the task will stop.
"RTN","ROR01",76,0)
 ;
"RTN","ROR01",77,0)
 ; ^XTMP("RORUPD"_) ---- REGISTRY UPDATE TEMPORARY DATA (MULTITASK)
"RTN","ROR01",78,0)
 ;
"RTN","ROR01",79,0)
 ;                       If the registry update starts in the
"RTN","ROR01",80,0)
 ;                       multitask mode, all temporary data from the
"RTN","ROR01",81,0)
 ;                       ^TMP("RORUPD",$J) node is merged to this
"RTN","ROR01",82,0)
 ;                       node so that it will be available for all
"RTN","ROR01",83,0)
 ;                       registry update subtasks.
"RTN","ROR01",84,0)
 ;
"RTN","ROR01",85,0)
 ; ^XTMP("RORUPDJ"_$J,
"RTN","ROR01",86,0)
 ;                       If the regular registry update is run in the
"RTN","ROR01",87,0)
 ;                       multitask mode, the ^XTMP("RORUPDJ"_$J) node
"RTN","ROR01",88,0)
 ;                       is used. $J is the job number of the main
"RTN","ROR01",89,0)
 ;                       registry update task.
"RTN","ROR01",90,0)
 ;
"RTN","ROR01",91,0)
 ; ^XTMP("RORUPDR"_Registry#,
"RTN","ROR01",92,0)
 ;                       During the initial registry population
"RTN","ROR01",93,0)
 ;                       (performed by the post-install routines),
"RTN","ROR01",94,0)
 ;                       the ^XTMP("RORUPDR"_Registry#) node is used.
"RTN","ROR01",95,0)
 ;                       The list of processed patients (the "U"
"RTN","ROR01",96,0)
 ;                       subscript) is used to restart the process
"RTN","ROR01",97,0)
 ;                       after an error or a crash.
"RTN","ROR01",98,0)
 ;
"RTN","ROR01",99,0)
 ;   0)                  Node descriptor
"RTN","ROR01",100,0)
 ;                         ^1: purge date  (FileMan)
"RTN","ROR01",101,0)
 ;                         ^2: create date (FileMan)
"RTN","ROR01",102,0)
 ;                         ^3: description
"RTN","ROR01",103,0)
 ;
"RTN","ROR01",104,0)
 ;   "T",Task#)          This node is LOCKed while the (sub)task is
"RTN","ROR01",105,0)
 ;                       running (subscript of the main task is 0).
"RTN","ROR01",106,0)
 ;
"RTN","ROR01",107,0)
 ;                       Otherwise, "S" means that the subtask has
"RTN","ROR01",108,0)
 ;                       been scheduled but not started yet.
"RTN","ROR01",109,0)
 ;
"RTN","ROR01",110,0)
 ;                       A negative value of the non-locked node
"RTN","ROR01",111,0)
 ;                       represents the error code (for example,
"RTN","ROR01",112,0)
 ;                       -60 means that the subtask has crashed).
"RTN","ROR01",113,0)
 ;
"RTN","ROR01",114,0)
 ;                       Non-negative value of the node means that
"RTN","ROR01",115,0)
 ;                       the subtask has been completed. The value
"RTN","ROR01",116,0)
 ;                       has the following structure:
"RTN","ROR01",117,0)
 ;                         ^1: Number of processed patients
"RTN","ROR01",118,0)
 ;                         ^2: Number of patients processed with
"RTN","ROR01",119,0)
 ;                             errors
"RTN","ROR01",120,0)
 ;
"RTN","ROR01",121,0)
 Q
"RTN","ROR02")
0^75^B8243
"RTN","ROR02",1,0)
ROR02 ;HCIOFO/SG - CLINICAL CASE REGISTRIES (VARIABLES) ; 10/20/03 9:03am
"RTN","ROR02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","ROR02",3,0)
 ;
"RTN","ROR02",4,0)
 ; RORCACHE ------------ IN-MEMORY CACHE
"RTN","ROR02",5,0)
 ;
"RTN","ROR02",6,0)
 ; RORCACHE(
"RTN","ROR02",7,0)
 ;   "XMLENT",...)       XML elements and attributes
"RTN","ROR02",8,0)
 ;                       (see the $$XEC^RORTSK11 function)
"RTN","ROR02",9,0)
 ;
"RTN","ROR02",10,0)
 ; RORERRDL ------------ DEFAULT ERROR LOCATION
"RTN","ROR02",11,0)
 ;
"RTN","ROR02",12,0)
 ; RORERROR ------------ ERROR PROCESSING DATA
"RTN","ROR02",13,0)
 ;
"RTN","ROR02",14,0)
 ; RORERROR("ES",        Index of the top of the stack
"RTN","ROR02",15,0)
 ;   Index,                ^1: Error code
"RTN","ROR02",16,0)
 ;                         ^2: Message text
"RTN","ROR02",17,0)
 ;     1)                Place of the error (LABEL^ROUTINE)
"RTN","ROR02",18,0)
 ;     2,Seq#)           Additional information (opt'l)
"RTN","ROR02",19,0)
 ;
"RTN","ROR02",20,0)
 ; RORERROR("DBS",       The $$DBS^RORERR function stores a list of
"RTN","ROR02",21,0)
 ;   ErrCode)            FileMan DBS error codes here (as subnodes).
"RTN","ROR02",22,0)
 ;
"RTN","ROR02",23,0)
 ; RORPARM ------------- PACKAGE-WIDE CONSTANTS AND VARIABLES
"RTN","ROR02",24,0)
 ;
"RTN","ROR02",25,0)
 ; RORPARM("DEBUG")      Debug mode (opt'l):
"RTN","ROR02",26,0)
 ;                         0  Disabled (default)
"RTN","ROR02",27,0)
 ;                         1  Enabled
"RTN","ROR02",28,0)
 ;                         2  Enabled; and all messages are not only
"RTN","ROR02",29,0)
 ;                            logged but displayed on the screen too
"RTN","ROR02",30,0)
 ;                         3  The same as 2 but registry update or
"RTN","ROR02",31,0)
 ;                            data extraction is aborted immediately
"RTN","ROR02",32,0)
 ;                            after processing a patient with errors
"RTN","ROR02",33,0)
 ;
"RTN","ROR02",34,0)
 ; RORPARM("DEVELOPER")  If this node is defined and not zero,
"RTN","ROR02",35,0)
 ;                       national definitions (registry parameters,
"RTN","ROR02",36,0)
 ;                       selection rules, etc) can be edited.
"RTN","ROR02",37,0)
 ;                       Otherwise, editing is prohibited.
"RTN","ROR02",38,0)
 ;
"RTN","ROR02",39,0)
 ; RORPARM("ERR")        Enable/disable extended error processing:
"RTN","ROR02",40,0)
 ;                         0  Disabled (default)
"RTN","ROR02",41,0)
 ;                         1  Enabled
"RTN","ROR02",42,0)
 ;
"RTN","ROR02",43,0)
 ; RORPARM("KIDS",       This node is defined and non-zero only during
"RTN","ROR02",44,0)
 ;                       the KIDS installation process:
"RTN","ROR02",45,0)
 ;                         1  Pre-install
"RTN","ROR02",46,0)
 ;                         2  Post-install
"RTN","ROR02",47,0)
 ;   ParamName)          Value of an installation parameter
"RTN","ROR02",48,0)
 ;
"RTN","ROR02",49,0)
 ; RORPARM("LOG",        Enable/disable log collection:
"RTN","ROR02",50,0)
 ;                         0  Disabled (default)
"RTN","ROR02",51,0)
 ;                         1  Enabled
"RTN","ROR02",52,0)
 ;   Type)               Enable (1) collection of only particular
"RTN","ROR02",53,0)
 ;                       events (optional, all events by default)
"RTN","ROR02",54,0)
 ;                       See the LOG EVENTS field in the ROR REGISTRY
"RTN","ROR02",55,0)
 ;                       PARAMETERS file #798.1 for possible values.
"RTN","ROR02",56,0)
 ;
"RTN","ROR02",57,0)
 ; RORPARM("SETUP")      This node is defined and non-zero only
"RTN","ROR02",58,0)
 ;                       during the registry setup.
"RTN","ROR02",59,0)
 ;
"RTN","ROR02",60,0)
 Q
"RTN","ROR10")
0^76^B26490729
"RTN","ROR10",1,0)
ROR10 ;HCIOFO/SG - NIGHTLY TASK UTILITIES ; 12/15/03 7:38am
"RTN","ROR10",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","ROR10",3,0)
 ;
"RTN","ROR10",4,0)
 Q
"RTN","ROR10",5,0)
 ;
"RTN","ROR10",6,0)
 ;***** DISPLAYS THE ALERT DETAILS FOR MISSING ACK
"RTN","ROR10",7,0)
ALERT ;
"RTN","ROR10",8,0)
 Q:$G(XQADATA)=""
"RTN","ROR10",9,0)
 N I,MSGID,MSGSTAT,PARAMS,INFO,TMP
"RTN","ROR10",10,0)
 ;--- Get and prepare the parameters
"RTN","ROR10",11,0)
 S MSGID=$P(XQADATA,"^")
"RTN","ROR10",12,0)
 S PARAMS("REGISTRY")=$P(XQADATA,"^",2)
"RTN","ROR10",13,0)
 S PARAMS("NOR")=$P(XQADATA,"^",3)
"RTN","ROR10",14,0)
 S MSGSTAT=$P(XQADATA,"^",5,999)
"RTN","ROR10",15,0)
 ;--- Load and format the text
"RTN","ROR10",16,0)
 D MSG7STS^RORUTL05(MSGID,.INFO,,7980000.006,.PARAMS,MSGSTAT)
"RTN","ROR10",17,0)
 ;--- Display the text
"RTN","ROR10",18,0)
 S I=""  W !!
"RTN","ROR10",19,0)
 F  S I=$O(INFO(I))  Q:I=""  W INFO(I),!
"RTN","ROR10",20,0)
 Q
"RTN","ROR10",21,0)
 ;
"RTN","ROR10",22,0)
 ;***** CHECKS THE APPLICATION ACKNOWLEDGEMENTS
"RTN","ROR10",23,0)
 ;
"RTN","ROR10",24,0)
 ; .REGLST       Reference to a local array containing
"RTN","ROR10",25,0)
 ;               registry names as subscripts
"RTN","ROR10",26,0)
 ;
"RTN","ROR10",27,0)
 ; Return values:
"RTN","ROR10",28,0)
 ;       <0  Error code
"RTN","ROR10",29,0)
 ;        0  Ok
"RTN","ROR10",30,0)
 ;
"RTN","ROR10",31,0)
CHECKACK(REGLST) ;
"RTN","ROR10",32,0)
 N AWD,CLRACK,EXPDT,IENS,MSGID,MSGSTAT,NOW,RC
"RTN","ROR10",33,0)
 N REGIEN,REGNAME,RORBUF,RORFDA,RORMSG,TMP
"RTN","ROR10",34,0)
 S NOW=$$NOW^XLFDT
"RTN","ROR10",35,0)
 ;---
"RTN","ROR10",36,0)
 S REGNAME=""
"RTN","ROR10",37,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D
"RTN","ROR10",38,0)
 . K RORBUF,RORFDA,RORMSG
"RTN","ROR10",39,0)
 . ;--- Get the registry IEN and parameters
"RTN","ROR10",40,0)
 . S REGIEN=$$REGIEN^RORUTL02(REGNAME,"2.2I;2.3I;2.5I;15.9I",.RORBUF)
"RTN","ROR10",41,0)
 . Q:REGIEN'>0  Q:'$G(RORBUF("DILIST","ID",1,2.2))
"RTN","ROR10",42,0)
 . ;--- Check the expiration date/time
"RTN","ROR10",43,0)
 . S AWD=$G(RORBUF("DILIST","ID",1,15.9))
"RTN","ROR10",44,0)
 . S:(AWD="")!(AWD<0) AWD=1
"RTN","ROR10",45,0)
 . S EXPDT=$$FMADD^XLFDT(RORBUF("DILIST","ID",1,2.2),AWD)
"RTN","ROR10",46,0)
 . Q:EXPDT>NOW
"RTN","ROR10",47,0)
 . ;--- Requeue/cancel the last HL7 message
"RTN","ROR10",48,0)
 . S MSGID=$G(RORBUF("DILIST","ID",1,2.3))
"RTN","ROR10",49,0)
 . S CLRACK=$$REQUEUE(MSGID,.MSGSTAT)
"RTN","ROR10",50,0)
 . ;--- Notify the AAC and local coordinators
"RTN","ROR10",51,0)
 . S TMP=$$NOTIFY(MSGID,REGIEN,MSGSTAT)
"RTN","ROR10",52,0)
 . ;--- If the last message has been re-queued, increment the number
"RTN","ROR10",53,0)
 . ;    of retries and update the AWAITING ACKNOWLEDGEMENT field with
"RTN","ROR10",54,0)
 . ;    the current date/time. Otherwise, clear the 'Awaiting ACK'
"RTN","ROR10",55,0)
 . ;    flag (LAST MESSAGE ID field is also cleared by the trigger
"RTN","ROR10",56,0)
 . ;--- associated with the AWAITING ACKNOWLEDGEMENT feild).
"RTN","ROR10",57,0)
 . S IENS=REGIEN_","
"RTN","ROR10",58,0)
 . I 'CLRACK  D
"RTN","ROR10",59,0)
 . . S RORFDA(798.1,IENS,2.2)=$$NOW^XLFDT
"RTN","ROR10",60,0)
 . . S RORFDA(798.1,IENS,2.5)=$G(RORBUF("DILIST","ID",1,2.5))+1
"RTN","ROR10",61,0)
 . E  S RORFDA(798.1,IENS,2.2)="@"
"RTN","ROR10",62,0)
 . ;--- Update the registry parameters
"RTN","ROR10",63,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","ROR10",64,0)
 . I $G(DIERR)  D  Q
"RTN","ROR10",65,0)
 . . S TMP=$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","ROR10",66,0)
 Q 0
"RTN","ROR10",67,0)
 ;
"RTN","ROR10",68,0)
 ;***** NOTIFIES THE AAC AND LOCAL COORDINATORS
"RTN","ROR10",69,0)
 ;
"RTN","ROR10",70,0)
 ; MSGID         HL7 message ID
"RTN","ROR10",71,0)
 ;
"RTN","ROR10",72,0)
 ; REGIEN        Registry IEN
"RTN","ROR10",73,0)
 ;
"RTN","ROR10",74,0)
 ; [MSGSTAT]     HL7 message status (result value of the
"RTN","ROR10",75,0)
 ;               $$MSGSTAT^HLUTIL function)
"RTN","ROR10",76,0)
 ;
"RTN","ROR10",77,0)
 ; Return values:
"RTN","ROR10",78,0)
 ;       <0  Error code
"RTN","ROR10",79,0)
 ;        0  Ok
"RTN","ROR10",80,0)
 ;       >0  Notifications were sent
"RTN","ROR10",81,0)
 ;
"RTN","ROR10",82,0)
NOTIFY(MSGID,REGIEN,MSGSTAT) ;
"RTN","ROR10",83,0)
 N ALNOR,EMAIL,IENS,NOR,RC,RORBUF,RORMSG,TMP
"RTN","ROR10",84,0)
 S IENS=REGIEN_","
"RTN","ROR10",85,0)
 ;--- Load the notification parameters
"RTN","ROR10",86,0)
 D GETS^DIQ(798.1,IENS,".01;2.5;13.2;13.3",,"RORBUF","RORMSG")
"RTN","ROR10",87,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","ROR10",88,0)
 ;--- Check if the notification should be sent
"RTN","ROR10",89,0)
 S NOR=+$G(RORBUF(798.1,IENS,2.5))    ; Number of Retries
"RTN","ROR10",90,0)
 S ALNOR=+$G(RORBUF(798.1,IENS,13.2)) ; # of Retries for Alert
"RTN","ROR10",91,0)
 S EMAIL=$G(RORBUF(798.1,IENS,13.3))  ; Notification e-mail
"RTN","ROR10",92,0)
 Q:$S(ALNOR'>0:1,1:NOR#ALNOR) 0
"RTN","ROR10",93,0)
 ;---
"RTN","ROR10",94,0)
 N PARAMS,XMCHAN,XMDUZ,XMLOC,XMSUB,XMTEXT,XMY,XMZ
"RTN","ROR10",95,0)
 S:$G(MSGSTAT)="" MSGSTAT=$$MSGSTAT^HLUTIL(MSGID)
"RTN","ROR10",96,0)
 S PARAMS("REGISTRY")=$G(RORBUF(798.1,IENS,.01))
"RTN","ROR10",97,0)
 S PARAMS("NOR")=NOR
"RTN","ROR10",98,0)
 ;--- Send an alert to the local coordinators
"RTN","ROR10",99,0)
 S TMP=MSGID_U_PARAMS("REGISTRY")_U_NOR_U_U_MSGSTAT
"RTN","ROR10",100,0)
 D ALERT^RORUTL01(PARAMS("REGISTRY"),-67,"ALERT^ROR10",TMP,,NOR)
"RTN","ROR10",101,0)
 ;--- Record an error message
"RTN","ROR10",102,0)
 D MSG7STS^RORUTL05(MSGID,.RORINFO,,7980000.006,.PARAMS,MSGSTAT)
"RTN","ROR10",103,0)
 S TMP=$$MSG^RORERR20(-67,.TYPE,,NOR)
"RTN","ROR10",104,0)
 D LOG^RORLOG(TYPE,TMP,,.RORINFO)  K RORINFO
"RTN","ROR10",105,0)
 ;--- Send an e-mail to the national mail group
"RTN","ROR10",106,0)
 D:EMAIL'=""
"RTN","ROR10",107,0)
 . S XMDUZ=.5,XMY(EMAIL)=""  K RORBUF
"RTN","ROR10",108,0)
 . S XMSUB="ROR: HL7 PROBLEM"
"RTN","ROR10",109,0)
 . D MSG7STS^RORUTL05(MSGID,.RORBUF,,7980000.005,.PARAMS,MSGSTAT)
"RTN","ROR10",110,0)
 . S XMTEXT="RORBUF("
"RTN","ROR10",111,0)
 . D ^XMD
"RTN","ROR10",112,0)
 ;---
"RTN","ROR10",113,0)
 Q 1
"RTN","ROR10",114,0)
 ;
"RTN","ROR10",115,0)
 ;***** REQUEUES/CANCELS THE LAST HL7 MESSAGE
"RTN","ROR10",116,0)
 ;
"RTN","ROR10",117,0)
 ; REGIEN        Registry IEN
"RTN","ROR10",118,0)
 ;
"RTN","ROR10",119,0)
 ; [.MSGSTAT]    Refrence to a local variable where the status
"RTN","ROR10",120,0)
 ;               of the message (before requeuing/cancellation)
"RTN","ROR10",121,0)
 ;               is returned to
"RTN","ROR10",122,0)
 ;
"RTN","ROR10",123,0)
 ; Return values:
"RTN","ROR10",124,0)
 ;       <0  Error code
"RTN","ROR10",125,0)
 ;        0  Ok
"RTN","ROR10",126,0)
 ;        1  The 'Awaiting ACK' flag should be reset
"RTN","ROR10",127,0)
 ;
"RTN","ROR10",128,0)
REQUEUE(MSGID,MSGSTAT) ;
"RTN","ROR10",129,0)
 N RORINFO,TEXT,TYPE
"RTN","ROR10",130,0)
 ;--- Check if the message exists
"RTN","ROR10",131,0)
 Q:MSGID="" 1
"RTN","ROR10",132,0)
 S MSGSTAT=$$MSGSTAT^HLUTIL(MSGID)
"RTN","ROR10",133,0)
 Q:MSGSTAT'>0 1
"RTN","ROR10",134,0)
 ;--- Try to requeue the last HL7 message.
"RTN","ROR10",135,0)
 ;--- If this cannot be doen, cancel the message
"RTN","ROR10",136,0)
 I '$$MSGACT^HLUTIL(MSGID,2)  D  Q 1
"RTN","ROR10",137,0)
 . Q:'$$MSGACT^HLUTIL(MSGID,1)
"RTN","ROR10",138,0)
 . ;--- Record the message about the cancellation
"RTN","ROR10",139,0)
 . S TEXT=$$MSG^RORERR20(-94,.TYPE,,MSGID)
"RTN","ROR10",140,0)
 . D LOG^RORLOG(TYPE,TEXT,,.RORINFO)
"RTN","ROR10",141,0)
 ;--- Record the message about requeuing
"RTN","ROR10",142,0)
 S TEXT=$$MSG^RORERR20(-93,.TYPE,,MSGID)
"RTN","ROR10",143,0)
 D LOG^RORLOG(TYPE,TEXT,,.RORINFO)
"RTN","ROR10",144,0)
 Q 0
"RTN","ROR10",145,0)
 ;
"RTN","ROR10",146,0)
 ;***** PROCESSES THE TASK PARAMETERS
"RTN","ROR10",147,0)
 ;
"RTN","ROR10",148,0)
 ; .REGLST       Reference to a local variable where the list of
"RTN","ROR10",149,0)
 ;               registry names is returned to
"RTN","ROR10",150,0)
 ;
"RTN","ROR10",151,0)
 ; Return values:
"RTN","ROR10",152,0)
 ;       <0  Error code
"RTN","ROR10",153,0)
 ;        0  Ok
"RTN","ROR10",154,0)
 ;
"RTN","ROR10",155,0)
TASKPRMS(REGLST) ;
"RTN","ROR10",156,0)
 N %DT,DTOUT,INFO,REGNAME,TMP,X,Y
"RTN","ROR10",157,0)
 I $G(ZTQPARAM)?." "  D  Q RC
"RTN","ROR10",158,0)
 . D TEXT^RORTXT(7980000.001,.INFO)
"RTN","ROR10",159,0)
 . S RC=$$ERROR^RORERR(-88,,.INFO,,"TASK PARAMETERS")
"RTN","ROR10",160,0)
 ;--- Flags
"RTN","ROR10",161,0)
 S RORFLCLR=$G(RORFLCLR)
"RTN","ROR10",162,0)
 S RORFLSET=$G(RORFLSET)
"RTN","ROR10",163,0)
 ;--- Maximum number of subtasks
"RTN","ROR10",164,0)
 S RORMNTSK=$S($G(RORMNTSK)'="":$TR(RORMNTSK,"-","^"),1:"2^3^AUTO")
"RTN","ROR10",165,0)
 ;--- Suspension parameters
"RTN","ROR10",166,0)
 I $G(RORSUSP)'=""  D
"RTN","ROR10",167,0)
 . S TMP=RORSUSP,RORSUSP=""
"RTN","ROR10",168,0)
 . F I=1,2  D  S:$G(Y)>0 $P(RORSUSP,"^",I)=Y#1
"RTN","ROR10",169,0)
 . . S X=$P(TMP,"-",I),%DT="R"  D ^%DT
"RTN","ROR10",170,0)
 E  S RORSUSP=""
"RTN","ROR10",171,0)
 ;--- Extract registry names from the task parameters
"RTN","ROR10",172,0)
 F I=1:1  S REGNAME=$P(ZTQPARAM,",",I)  Q:REGNAME=""  D
"RTN","ROR10",173,0)
 . S REGNAME=$$TRIM^XLFSTR(REGNAME)
"RTN","ROR10",174,0)
 . S:REGNAME'="" REGLST(REGNAME)=""
"RTN","ROR10",175,0)
 Q 0
"RTN","RORACK")
0^74^B16804227
"RTN","RORACK",1,0)
RORACK ;HCIOFO/SG - ACKNOWLEDGEMENT PROCESSING ; 2/4/04 9:49am
"RTN","RORACK",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3,5**;May 14, 2002
"RTN","RORACK",3,0)
 ;
"RTN","RORACK",4,0)
 Q
"RTN","RORACK",5,0)
 ;
"RTN","RORACK",6,0)
 ;***** PROCESSES THE BATCH HEADER OF THE ACKNOWLEDGEMENT
"RTN","RORACK",7,0)
 ;
"RTN","RORACK",8,0)
 ; .REGLST       Reference to a local variable where the list of
"RTN","RORACK",9,0)
 ;               registries associated with the original batch
"RTN","RORACK",10,0)
 ;               message will be returned to. The list will have
"RTN","RORACK",11,0)
 ;               the following structure:
"RTN","RORACK",12,0)
 ;
"RTN","RORACK",13,0)
 ;                 REGLST(RegistryName)=RegistryIEN^BatchID^Date
"RTN","RORACK",14,0)
 ;
"RTN","RORACK",15,0)
 ; Return Values:
"RTN","RORACK",16,0)
 ;        <0  Error Code
"RTN","RORACK",17,0)
 ;         0  Ok
"RTN","RORACK",18,0)
 ;
"RTN","RORACK",19,0)
HEADER(REGLST) ;
"RTN","RORACK",20,0)
 N CS,FS,I,PROCID,RC,REFMID,REGNAME,RORBUF,RORMSG,TMP
"RTN","RORACK",21,0)
 K REGLST
"RTN","RORACK",22,0)
 ;--- Get the BHS segment
"RTN","RORACK",23,0)
 X HLNEXT
"RTN","RORACK",24,0)
 I (HLQUIT'>0)!($E($G(HLNODE),1,3)'="BHS")  D  Q RC
"RTN","RORACK",25,0)
 . S RC=$$ERROR^RORERR(-68)
"RTN","RORACK",26,0)
 S RORBUF=HLNODE,I=""
"RTN","RORACK",27,0)
 F  S I=$O(HLNODE(I))  Q:I=""  S RORBUF=RORBUF_HLNODE(I)
"RTN","RORACK",28,0)
 S FS=$E(RORBUF,4),CS=$E($P(RORBUF,FS,2),1)
"RTN","RORACK",29,0)
 ;--- Load the batch parameters
"RTN","RORACK",30,0)
 S PROCID=$P($P(RORBUF,FS,9),CS,2)
"RTN","RORACK",31,0)
 S REFMID=$P(RORBUF,FS,12)
"RTN","RORACK",32,0)
 ;--- Record some of the parameters
"RTN","RORACK",33,0)
 K RORMSG
"RTN","RORACK",34,0)
 S RORMSG(1)="Message IEN:  "_$G(HLMTIENS)
"RTN","RORACK",35,0)
 S RORMSG(2)="Message ID:   "_$G(HL("MID"))
"RTN","RORACK",36,0)
 S TMP=$$HL7TFM^XLFDT($G(HL("DTM")))
"RTN","RORACK",37,0)
 S RORMSG(3)="Message Date: "_$$FMTE^XLFDT(TMP)
"RTN","RORACK",38,0)
 S RORMSG(4)="Reference ID: "_REFMID
"RTN","RORACK",39,0)
 D LOG^RORLOG(2,"Processing the HL7 batch message",,.RORMSG)
"RTN","RORACK",40,0)
 K RORMSG
"RTN","RORACK",41,0)
 ;--- Check the Processing ID and quit if not 'Production'
"RTN","RORACK",42,0)
 S I=$$UP^XLFSTR(PROCID)
"RTN","RORACK",43,0)
 I I'="P"  D  Q RC
"RTN","RORACK",44,0)
 . S TMP=$S(I="D":"debug",I="T":"training",1:"unknown")
"RTN","RORACK",45,0)
 . S RC=$$ERROR^RORERR(-90,,,,TMP)
"RTN","RORACK",46,0)
 ;--- Get a list of registries associated with the batch and
"RTN","RORACK",47,0)
 ;--- awaiting application acknowledgements
"RTN","RORACK",48,0)
 S TMP="@;.01;2.1;2.2I",I="I $P($G(^(0)),U,9)"
"RTN","RORACK",49,0)
 D FIND^DIC(798.1,,TMP,"UX",REFMID,,"AM",I,,"RORBUF","RORMSG")
"RTN","RORACK",50,0)
 Q:$G(DIERR)>0 $$DBS^RORERR("RORMSG",-9,,,798.1)
"RTN","RORACK",51,0)
 I $G(RORBUF("DILIST",0))'>0  D  Q RC
"RTN","RORACK",52,0)
 . S TMP="Message ID: "_$G(HL("MID"))
"RTN","RORACK",53,0)
 . S RC=$$ERROR^RORERR(-73,,TMP)
"RTN","RORACK",54,0)
 ;--- Compile the list of registries
"RTN","RORACK",55,0)
 S I=""
"RTN","RORACK",56,0)
 F  S I=$O(RORBUF("DILIST","ID",I))  Q:I=""  D
"RTN","RORACK",57,0)
 . S REGNAME=$G(RORBUF("DILIST","ID",I,.01))  Q:REGNAME=""
"RTN","RORACK",58,0)
 . S $P(REGLST(REGNAME),U,1)=$G(RORBUF("DILIST",2,I))
"RTN","RORACK",59,0)
 . S $P(REGLST(REGNAME),U,2)=$G(RORBUF("DILIST","ID",I,2.1))
"RTN","RORACK",60,0)
 . S $P(REGLST(REGNAME),U,3)=$G(RORBUF("DILIST","ID",I,2.2))
"RTN","RORACK",61,0)
 Q 0
"RTN","RORACK",62,0)
 ;
"RTN","RORACK",63,0)
 ;***** PROCESSES HL7 APPLICATION ACKNOWLEDGEMENT
"RTN","RORACK",64,0)
PROCESS ;
"RTN","RORACK",65,0)
 N RORERROR      ; Error processing data
"RTN","RORACK",66,0)
 N RORERRDL      ; Default error location
"RTN","RORACK",67,0)
 N RORLOG        ; Log susbsystem data
"RTN","RORACK",68,0)
 N RORPARM       ; Application parameters
"RTN","RORACK",69,0)
 ;
"RTN","RORACK",70,0)
 N RC,REGLST,TMP
"RTN","RORACK",71,0)
 D INIT^RORUTL01("RORACK"),CLEAR^RORERR("PROCESS^RORACK")
"RTN","RORACK",72,0)
 ;S RORPARM("DEBUG")=1 ; Remove the first ';' to run in debug mode
"RTN","RORACK",73,0)
 S RORPARM("LOG")=1
"RTN","RORACK",74,0)
 ;--- If the DUZ is not properly defined then try to get
"RTN","RORACK",75,0)
 ;--- identifier of any user who has the ROR VA IRM key
"RTN","RORACK",76,0)
 S:$G(DUZ)'>0 DUZ=+$O(^XUSEC("ROR VA IRM",""))
"RTN","RORACK",77,0)
 ;--- Open a new log
"RTN","RORACK",78,0)
 S TMP=$$OPEN^RORLOG(,3,"ACKNOWLEDGEMENT PROCESSING STARTED")
"RTN","RORACK",79,0)
 D
"RTN","RORACK",80,0)
 . ;--- Process the batch header
"RTN","RORACK",81,0)
 . S RC=$$HEADER(.REGLST)            Q:RC<0
"RTN","RORACK",82,0)
 . ;--- Associate the log with the registries
"RTN","RORACK",83,0)
 . S RC=$$SETRGLST^RORLOG(.REGLST)
"RTN","RORACK",84,0)
 . S:RC<0 RORPARM("LOG")=1
"RTN","RORACK",85,0)
 . ;--- Process the acknowldgements
"RTN","RORACK",86,0)
 . S RC=$$PROCMSG^RORACK01(.REGLST)  Q:RC<0
"RTN","RORACK",87,0)
 . S RC=$$PROCREM^RORACK01(.REGLST)  Q:RC<0
"RTN","RORACK",88,0)
 ;--- Process the errors and update registry parameters
"RTN","RORACK",89,0)
 I (RC'=-73)&(RC'=-90)  D
"RTN","RORACK",90,0)
 . S:RC<0 HLERR="RORACK: Error Code: "_RC
"RTN","RORACK",91,0)
 . S TMP=$$UPDPARMS(.REGLST)
"RTN","RORACK",92,0)
 . I TMP<0  S:RC'<0 RC=TMP
"RTN","RORACK",93,0)
 ;--- Statistics & Cleanup
"RTN","RORACK",94,0)
 S TMP="ACKNOWLEDGEMENT PROCESSING "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","RORACK",95,0)
 D CLOSE^RORLOG(TMP)
"RTN","RORACK",96,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("RORACK")
"RTN","RORACK",97,0)
 Q
"RTN","RORACK",98,0)
 ;
"RTN","RORACK",99,0)
 ;***** UPDATES REGISTRY PARAMETERS
"RTN","RORACK",100,0)
 ;
"RTN","RORACK",101,0)
 ; .REGLST       Reference to a local variable containing a list
"RTN","RORACK",102,0)
 ;               of registries (registry names as the subscripts
"RTN","RORACK",103,0)
 ;               and registry IENs as the values).
"RTN","RORACK",104,0)
 ;
"RTN","RORACK",105,0)
 ; Return Values:
"RTN","RORACK",106,0)
 ;        <0  Error Code
"RTN","RORACK",107,0)
 ;         0  Ok
"RTN","RORACK",108,0)
 ;
"RTN","RORACK",109,0)
UPDPARMS(REGLST) ;
"RTN","RORACK",110,0)
 N IR,RC,REGIENS,RORFDA,RORMSG
"RTN","RORACK",111,0)
 S IR="",RC=0
"RTN","RORACK",112,0)
 F  S IR=$O(REGLST(IR))  Q:IR=""  D  Q:RC<0
"RTN","RORACK",113,0)
 . S REGIENS=+REGLST(IR)_","  Q:REGIENS'>0
"RTN","RORACK",114,0)
 . ;--- The LAST MESSAGE ID field is also cleared by the trigger
"RTN","RORACK",115,0)
 . ;--- associated with the AWAITING ACKNOWLEDGEMENT feild (2.2)
"RTN","RORACK",116,0)
 . S RORFDA(798.1,REGIENS,2.2)="@"  ; AWAITING ACKNOWLEDGEMENT
"RTN","RORACK",117,0)
 . S RORFDA(798.1,REGIENS,2.5)="@"  ; NUMBER OF RETRIES
"RTN","RORACK",118,0)
 . ;--- Update the registry parameters
"RTN","RORACK",119,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORACK",120,0)
 . S RC=$$DBS^RORERR("RORMSG",-9)
"RTN","RORACK",121,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORACK01")
0^80^B41951107
"RTN","RORACK01",1,0)
RORACK01 ;HCIOFO/SG - ACKNOWLEDGEMENT PROCESSING ; 7/21/03 10:04am
"RTN","RORACK01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORACK01",3,0)
 ;
"RTN","RORACK01",4,0)
 Q
"RTN","RORACK01",5,0)
 ;
"RTN","RORACK01",6,0)
 ;***** RECORDS ERROR CODE AND LOCATION
"RTN","RORACK01",7,0)
 ;
"RTN","RORACK01",8,0)
 ; ERRLOC        Error code and location from the ERR segment
"RTN","RORACK01",9,0)
 ; PATIEN        Patient IEN
"RTN","RORACK01",10,0)
 ;
"RTN","RORACK01",11,0)
 ; Return Values:
"RTN","RORACK01",12,0)
 ;        <0  Error Code
"RTN","RORACK01",13,0)
 ;        >0  IEN of the registry record
"RTN","RORACK01",14,0)
 ;
"RTN","RORACK01",15,0)
ERR(ERRLOC,PATIEN) ;
"RTN","RORACK01",16,0)
 N CS,ERR,FLD,II,INFO,MSG,SCS,SEG,SQN,TMP,TYPE
"RTN","RORACK01",17,0)
 S CS=$E($G(HL("ECH")),1),SCS=$E($G(HL("ECH")),4)
"RTN","RORACK01",18,0)
 Q:(CS="")!(SCS="") $$ERROR^RORERR(-40,,,,"HL")
"RTN","RORACK01",19,0)
 S II=0,TYPE=6
"RTN","RORACK01",20,0)
 ;--- Extracts the information
"RTN","RORACK01",21,0)
 S SEG=$P(ERRLOC,CS,1)
"RTN","RORACK01",22,0)
 S SQN=$P(ERRLOC,CS,2)
"RTN","RORACK01",23,0)
 S FLD=$P(ERRLOC,CS,3)
"RTN","RORACK01",24,0)
 S ERR=$P(ERRLOC,CS,4)
"RTN","RORACK01",25,0)
 ;--- Prepare HL7 information
"RTN","RORACK01",26,0)
 S TMP=""
"RTN","RORACK01",27,0)
 S:SEG'="" TMP=TMP_", Segment: '"_SEG_"'"
"RTN","RORACK01",28,0)
 S:SQN TMP=TMP_", Sequence#: "_+SQN
"RTN","RORACK01",29,0)
 S:FLD TMP=TMP_", Field#: "_+FLD
"RTN","RORACK01",30,0)
 S:TMP'="" II=II+1,INFO(II)="HL7 INFO: "_$P(TMP,", ",2,999)
"RTN","RORACK01",31,0)
 ;--- Prepare the message and error location data
"RTN","RORACK01",32,0)
 I ERR?1.8UN.(1":".E)  D
"RTN","RORACK01",33,0)
 . S MSG=$$MSG^RORERR10($P(ERR,":"),.TYPE)
"RTN","RORACK01",34,0)
 . ;
"RTN","RORACK01",35,0)
 . I "OBR,OBX,NTE"[SEG  D  Q
"RTN","RORACK01",36,0)
 . . S TMP=$P(ERR,":",2)  D:TMP'=""
"RTN","RORACK01",37,0)
 . . . S II=II+1,INFO(II)="Placer Order Number: '"_TMP_"'"
"RTN","RORACK01",38,0)
 . . S TMP=$P(ERR,":",3)  D:TMP'=""
"RTN","RORACK01",39,0)
 . . . S TMP=$$FMTE^XLFDT($$HL7TFM^XLFDT(TMP))
"RTN","RORACK01",40,0)
 . . . S II=II+1,INFO(II)="Date/Time of Transaction: "_TMP
"RTN","RORACK01",41,0)
 . ;
"RTN","RORACK01",42,0)
 . I "ORC,RXE"[SEG  D  Q
"RTN","RORACK01",43,0)
 . . S TMP=$P(ERR,":",2)  D:TMP'=""
"RTN","RORACK01",44,0)
 . . . S II=II+1,INFO(II)="Filler Order Number: '"_TMP_"'"
"RTN","RORACK01",45,0)
 . . S TMP=$P(ERR,":",3)  D:TMP'=""
"RTN","RORACK01",46,0)
 . . . S TMP=$$FMTE^XLFDT($$HL7TFM^XLFDT(TMP))
"RTN","RORACK01",47,0)
 . . . S II=II+1,INFO(II)="Observation Date/Time: "_TMP
"RTN","RORACK01",48,0)
 . ;
"RTN","RORACK01",49,0)
 E  S MSG=ERR
"RTN","RORACK01",50,0)
 ;--- Record the error
"RTN","RORACK01",51,0)
 S:$G(MSG)="" MSG="Unknown error"
"RTN","RORACK01",52,0)
 D LOG^RORLOG(TYPE,MSG,$G(PATIEN),.INFO)
"RTN","RORACK01",53,0)
 Q 0
"RTN","RORACK01",54,0)
 ;
"RTN","RORACK01",55,0)
 ;***** ANALYZES THE ERROR CODE
"RTN","RORACK01",56,0)
 ;
"RTN","RORACK01",57,0)
 ; .RC           Error code (it can be modified inside the function)
"RTN","RORACK01",58,0)
 ;
"RTN","RORACK01",59,0)
 ; Return Values:
"RTN","RORACK01",60,0)
 ;         0  Continue
"RTN","RORACK01",61,0)
 ;         1  Stop and exit
"RTN","RORACK01",62,0)
 ;
"RTN","RORACK01",63,0)
EXIT(RC) ;
"RTN","RORACK01",64,0)
 Q:RC'<0 0
"RTN","RORACK01",65,0)
 S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORACK01",66,0)
 Q RC<0
"RTN","RORACK01",67,0)
 ;
"RTN","RORACK01",68,0)
 ;***** FINDS THE REGISTRY RECORD BY THE HL7 MESSAGE ID
"RTN","RORACK01",69,0)
 ;
"RTN","RORACK01",70,0)
 ; MSGID         HL7 message ID
"RTN","RORACK01",71,0)
 ; .PATIEN       Patient IEN is returned via this parameter
"RTN","RORACK01",72,0)
 ; .REGIEN       Registry IEN is returned via this parameter
"RTN","RORACK01",73,0)
 ;
"RTN","RORACK01",74,0)
 ; Return Values:
"RTN","RORACK01",75,0)
 ;        <0  Error Code
"RTN","RORACK01",76,0)
 ;        >0  IEN of the registry record
"RTN","RORACK01",77,0)
 ;
"RTN","RORACK01",78,0)
FINDREC(MSGID,PATIEN,REGIEN) ;
"RTN","RORACK01",79,0)
 N IEN,RC,RORBUF,RORMSG,TMP
"RTN","RORACK01",80,0)
 ;--- Find the registry record
"RTN","RORACK01",81,0)
 D FIND^DIC(798,,".01I;.02I","QUX",MSGID,2,"AM",,,"RORBUF","RORMSG")
"RTN","RORACK01",82,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798)
"RTN","RORACK01",83,0)
 S TMP=+$G(RORBUF("DILIST",0))
"RTN","RORACK01",84,0)
 Q:TMP<1 $$ERROR^RORERR(-52,,,,MSGID)
"RTN","RORACK01",85,0)
 Q:TMP>1 $$ERROR^RORERR(-39,,,,MSGID)
"RTN","RORACK01",86,0)
 ;--- Get the data
"RTN","RORACK01",87,0)
 S IEN=RORBUF("DILIST",2,1)
"RTN","RORACK01",88,0)
 S PATIEN=$G(RORBUF("DILIST","ID",1,.01))
"RTN","RORACK01",89,0)
 S REGIEN=$G(RORBUF("DILIST","ID",1,.02))
"RTN","RORACK01",90,0)
 Q IEN
"RTN","RORACK01",91,0)
 ;
"RTN","RORACK01",92,0)
 ;***** PROCESSES HL7 BATCH OF ACKNOWLEDGEMENTS
"RTN","RORACK01",93,0)
 ;
"RTN","RORACK01",94,0)
 ; .REGLST       Reference to a local variable containing the list
"RTN","RORACK01",95,0)
 ;               of registries associated with the original batch
"RTN","RORACK01",96,0)
 ;               message. The list must have the following structure:
"RTN","RORACK01",97,0)
 ;
"RTN","RORACK01",98,0)
 ;                 REGLST(RegistryName)=RegistryIEN^BatchID^Date
"RTN","RORACK01",99,0)
 ;
"RTN","RORACK01",100,0)
 ; This function should be called only from the acknowledgement
"RTN","RORACK01",101,0)
 ; processing routine.
"RTN","RORACK01",102,0)
 ;
"RTN","RORACK01",103,0)
 ; Global node ^TMP("DILIST",$J) is used by this function.
"RTN","RORACK01",104,0)
 ;
"RTN","RORACK01",105,0)
 ; Return Values:
"RTN","RORACK01",106,0)
 ;        <0  Error Code
"RTN","RORACK01",107,0)
 ;         0  Ok
"RTN","RORACK01",108,0)
 ;
"RTN","RORACK01",109,0)
PROCMSG(REGLST) ;
"RTN","RORACK01",110,0)
 N ACKCODE,BTS,CS,DTMSG,FS,IEN,MSACNT,MSGID,NEXT,PATIEN,RC,REGIEN,RILST,TMP
"RTN","RORACK01",111,0)
 S FS=$G(HL("FS")),CS=$E($G(HL("ECH")),1)
"RTN","RORACK01",112,0)
 Q:(FS="")!(CS="") $$ERROR^RORERR(-40,,,,"HL")
"RTN","RORACK01",113,0)
 K ^TMP("RORACK",$J,"PR")
"RTN","RORACK01",114,0)
 ;--- Compile a list of registry IENs and message dates
"RTN","RORACK01",115,0)
 S TMP=""
"RTN","RORACK01",116,0)
 F  S TMP=$O(REGLST(TMP))  Q:TMP=""  D
"RTN","RORACK01",117,0)
 . S IEN=+REGLST(TMP)  Q:IEN'>0
"RTN","RORACK01",118,0)
 . S DTMSG=$P(REGLST(TMP),U,3)
"RTN","RORACK01",119,0)
 . S:DTMSG>0 RILST(IEN)=DTMSG
"RTN","RORACK01",120,0)
 ;--- Process acknowledgement messages
"RTN","RORACK01",121,0)
 S RC=0,NEXT=1,(BTS,MSACNT)=0
"RTN","RORACK01",122,0)
 F  X:NEXT HLNEXT  Q:HLQUIT'>0  D  Q:BTS!$$EXIT(.RC)
"RTN","RORACK01",123,0)
 . S NEXT=1
"RTN","RORACK01",124,0)
 . I $P(HLNODE,FS)="BTS"  S BTS=+$P(HLNODE,FS,2)  Q
"RTN","RORACK01",125,0)
 . Q:$P(HLNODE,FS)'="MSA"
"RTN","RORACK01",126,0)
 . S MSACNT=MSACNT+1
"RTN","RORACK01",127,0)
 . S ACKCODE=$P(HLNODE,FS,2),MSGID=$P(HLNODE,FS,3)
"RTN","RORACK01",128,0)
 . Q:$P(MSGID,"-")=""
"RTN","RORACK01",129,0)
 . ;--- Find the registry record
"RTN","RORACK01",130,0)
 . S IEN=$$FINDREC(MSGID,.PATIEN,.REGIEN)
"RTN","RORACK01",131,0)
 . I IEN<0  S RC=IEN  Q
"RTN","RORACK01",132,0)
 . S ^TMP("RORACK",$J,"PR",IEN)=""
"RTN","RORACK01",133,0)
 . S DTMSG=+$G(RILST(+REGIEN))
"RTN","RORACK01",134,0)
 . Q:DTMSG'>0
"RTN","RORACK01",135,0)
 . ;--- Analyze the MSA segment and record the message
"RTN","RORACK01",136,0)
 . I ACKCODE="AA"  S RC=$$UPDRREC(IEN,DTMSG)    Q
"RTN","RORACK01",137,0)
 . I ACKCODE="AR"  S RC=$$UPDRREC(IEN,DTMSG,1)  Q
"RTN","RORACK01",138,0)
 . S TMP=$P(HLNODE,FS,4)
"RTN","RORACK01",139,0)
 . D:'(TMP?." ") LOG^RORLOG(6,TMP,PATIEN)
"RTN","RORACK01",140,0)
 . ;--- Record content of the ERR segments
"RTN","RORACK01",141,0)
 . S NEXT=0
"RTN","RORACK01",142,0)
 . F  X HLNEXT  Q:HLQUIT'>0  Q:$P(HLNODE,FS)'="ERR"  D
"RTN","RORACK01",143,0)
 . . S TMP=$$ERR($P(HLNODE,FS,2),PATIEN)
"RTN","RORACK01",144,0)
 ;--- Check if the actual number of messages in the batch is
"RTN","RORACK01",145,0)
 ;--- the same as that from the BTS-2 field
"RTN","RORACK01",146,0)
 I RC'<0  D:BTS'=MSACNT
"RTN","RORACK01",147,0)
 . S TMP="HL7 Batch Message ID: "_$G(HL("MID"))
"RTN","RORACK01",148,0)
 . S RC=$$ERROR^RORERR(-74,,TMP)
"RTN","RORACK01",149,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORACK01",150,0)
 ;
"RTN","RORACK01",151,0)
 ;***** PROCESSES REMAINING REGISTRY RECORDS
"RTN","RORACK01",152,0)
 ;
"RTN","RORACK01",153,0)
 ; .REGLST       Reference to a local variable containing the list
"RTN","RORACK01",154,0)
 ;               of registries associated with the original batch
"RTN","RORACK01",155,0)
 ;               message. The list must have the following structure:
"RTN","RORACK01",156,0)
 ;
"RTN","RORACK01",157,0)
 ;                 REGLST(RegistryName)=RegistryIEN^BatchID^Date
"RTN","RORACK01",158,0)
 ;
"RTN","RORACK01",159,0)
 ; Return Values:
"RTN","RORACK01",160,0)
 ;        <0  Error Code
"RTN","RORACK01",161,0)
 ;         0  Ok
"RTN","RORACK01",162,0)
 ;
"RTN","RORACK01",163,0)
PROCREM(REGLST) ;
"RTN","RORACK01",164,0)
 N BATCHID,BIDLST,DTMSG,IEN,IR,RC,RORMSG,TMP
"RTN","RORACK01",165,0)
 ;--- Compile a list of batch message IDs
"RTN","RORACK01",166,0)
 S IR=""
"RTN","RORACK01",167,0)
 F  S IR=$O(REGLST(IR))  Q:IR=""  D
"RTN","RORACK01",168,0)
 . S TMP=$P(REGLST(IR),U,2)  Q:TMP=""
"RTN","RORACK01",169,0)
 . S DTMSG=$P(REGLST(IR),U,3)
"RTN","RORACK01",170,0)
 . S:DTMSG>0 BIDLST(TMP)=DTMSG
"RTN","RORACK01",171,0)
 ;--- Acnowledge all remaining messages of the batches
"RTN","RORACK01",172,0)
 S BATCHID="",RC=0
"RTN","RORACK01",173,0)
 F  S BATCHID=$O(BIDLST(BATCHID))  Q:BATCHID=""  D  Q:RC<0
"RTN","RORACK01",174,0)
 . S TMP=BATCHID_"-"
"RTN","RORACK01",175,0)
 . D LIST^DIC(798,,"@","U",,TMP,TMP,"AM",,,,"RORMSG")
"RTN","RORACK01",176,0)
 . I $G(DIERR)  D  Q
"RTN","RORACK01",177,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,798)
"RTN","RORACK01",178,0)
 . S DTMSG=+BIDLST(BATCHID)
"RTN","RORACK01",179,0)
 . S IR=""
"RTN","RORACK01",180,0)
 . F  S IR=$O(^TMP("DILIST",$J,2,IR))  Q:IR=""  D  Q:$$EXIT(.RC)
"RTN","RORACK01",181,0)
 . . S IEN=^TMP("DILIST",$J,2,IR)
"RTN","RORACK01",182,0)
 . . S:'$D(^TMP("RORACK",$J,"PR",IEN)) RC=$$UPDRREC(IEN,DTMSG)
"RTN","RORACK01",183,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORACK01",184,0)
 ;
"RTN","RORACK01",185,0)
 ;***** UPDATES REGISTRY RECORD
"RTN","RORACK01",186,0)
 ;
"RTN","RORACK01",187,0)
 ; IEN           IEN of the local registry record
"RTN","RORACK01",188,0)
 ; DTMSG         Date/time when the original HL7 message was sent
"RTN","RORACK01",189,0)
 ; [REJECT]      Non-zero value indicates that the message was
"RTN","RORACK01",190,0)
 ;               rejected for reasons unrelated to the content or
"RTN","RORACK01",191,0)
 ;               format (0 by default)
"RTN","RORACK01",192,0)
 ;
"RTN","RORACK01",193,0)
 ; Return Values:
"RTN","RORACK01",194,0)
 ;        <0  Error Code
"RTN","RORACK01",195,0)
 ;         0  Ok
"RTN","RORACK01",196,0)
 ;
"RTN","RORACK01",197,0)
UPDRREC(IEN,DTMSG,REJECT) ;
"RTN","RORACK01",198,0)
 N IENS,RC,RORBUF,RORFDA,RORMSG,TMP
"RTN","RORACK01",199,0)
 S IENS=IEN_","
"RTN","RORACK01",200,0)
 I '$G(REJECT)  S RC=0  D  Q:RC<0 RC
"RTN","RORACK01",201,0)
 . ;--- Load data from the registry record
"RTN","RORACK01",202,0)
 . D GETS^DIQ(798,IENS,"4.1;5.1;9.1;9.2","I","RORBUF","RORMSG")
"RTN","RORACK01",203,0)
 . I $G(DIERR)  D  Q
"RTN","RORACK01",204,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","RORACK01",205,0)
 . ;--- Reset flags and update dates
"RTN","RORACK01",206,0)
 . S RORFDA(798,IENS,3)="@"   ; New Patient
"RTN","RORACK01",207,0)
 . S TMP=$G(RORBUF(798,IENS,9.2,"I"))
"RTN","RORACK01",208,0)
 . S:TMP>$G(RORBUF(798,IENS,9.1,"I")) RORFDA(798,IENS,9.1)=TMP
"RTN","RORACK01",209,0)
 . ;--- Do not reset the UPDATE DEMOGRAPHICS field if the demographic
"RTN","RORACK01",210,0)
 . ;--- data was updated again after the message had been sent
"RTN","RORACK01",211,0)
 . S:DTMSG>$G(RORFDA(798,IENS,4.1,"I")) RORFDA(798,IENS,4)="@"
"RTN","RORACK01",212,0)
 . ;--- Do not reset the UPDATE LOCAL REGISTRY DATA field if the local
"RTN","RORACK01",213,0)
 . ;--- data was updated again after the message had been sent
"RTN","RORACK01",214,0)
 . S:DTMSG>$G(RORFDA(798,IENS,5.1,"I")) RORFDA(798,IENS,5)="@"
"RTN","RORACK01",215,0)
 S RORFDA(798,IENS,10)="@"    ; Last message ID
"RTN","RORACK01",216,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORACK01",217,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","RORACK01",218,0)
 Q 0
"RTN","RORAPI01")
0^139^B8592008
"RTN","RORAPI01",1,0)
RORAPI01 ;HCIOFO/SG - CLINICAL REGISTRIES API ; 7/25/03 10:33am
"RTN","RORAPI01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3,5**;May 14, 2002
"RTN","RORAPI01",3,0)
 ;
"RTN","RORAPI01",4,0)
 ;***** EXAMPLE
"RTN","RORAPI01",5,0)
 ;
"RTN","RORAPI01",6,0)
 N IDSC,INCTVDT,RC
"RTN","RORAPI01",7,0)
 W !!,"Patients",!
"RTN","RORAPI01",8,0)
 S RC=$$PATITER^RORAPI01(.IDSC,"VA HEPC")
"RTN","RORAPI01",9,0)
 I RC<0  W "RC= ",RC,!  Q
"RTN","RORAPI01",10,0)
 F  S RC=$$NEXTPAT^RORAPI01(.IDSC)  Q:RC'>0  D
"RTN","RORAPI01",11,0)
 . S INCTVDT=$P(RC,"^",2)
"RTN","RORAPI01",12,0)
 . W !,$J(+RC,10),$S(INCTVDT:"  "_INCTVDT,1:"")
"RTN","RORAPI01",13,0)
 ;
"RTN","RORAPI01",14,0)
 W !!,"Registries",!
"RTN","RORAPI01",15,0)
 S RC=$$REGITER^RORAPI01(.IDSC,2)
"RTN","RORAPI01",16,0)
 I RC<0  W "RC= ",RC,!  Q
"RTN","RORAPI01",17,0)
 F  S RC=$$NEXTREG^RORAPI01(.IDSC)  Q:RC'>0  D
"RTN","RORAPI01",18,0)
 . S INCTVDT=$P(RC,"^",2)
"RTN","RORAPI01",19,0)
 . W !,$J(+RC,10),$S(INCTVDT:"  "_INCTVDT,1:"")
"RTN","RORAPI01",20,0)
 Q
"RTN","RORAPI01",21,0)
 ;
"RTN","RORAPI01",22,0)
 ;***** RETURNS THE NEXT PATIENT IN THE REGISTRY
"RTN","RORAPI01",23,0)
 ;
"RTN","RORAPI01",24,0)
 ; .IDESC        Reference to the iterator descriptor created
"RTN","RORAPI01",25,0)
 ;               by PATITER^RORAPI01
"RTN","RORAPI01",26,0)
 ;
"RTN","RORAPI01",27,0)
 ; Return Values:
"RTN","RORAPI01",28,0)
 ;       <0  Error code
"RTN","RORAPI01",29,0)
 ;       ""  No more patients in the registry
"RTN","RORAPI01",30,0)
 ;       >0  Patient IEN^Inactivation Date
"RTN","RORAPI01",31,0)
 ;
"RTN","RORAPI01",32,0)
NEXTPAT(IDESC) ;
"RTN","RORAPI01",33,0)
 N BUF,INDT,RC
"RTN","RORAPI01",34,0)
 S RC=0
"RTN","RORAPI01",35,0)
 F  D  Q:RC
"RTN","RORAPI01",36,0)
 . ; Get an IEN of the next record in the registry
"RTN","RORAPI01",37,0)
 . S IDESC("IEN")=$O(^RORDATA(798,"AC",IDESC("REGIEN"),IDESC("IEN")))
"RTN","RORAPI01",38,0)
 . I IDESC("IEN")'>0  S RC="1^END"  Q
"RTN","RORAPI01",39,0)
 . ;--- Load values of the fields
"RTN","RORAPI01",40,0)
 . S BUF=$G(^RORDATA(798,IDESC("IEN"),0)),INDT=$P(BUF,U,4)
"RTN","RORAPI01",41,0)
 . ;--- Screen records
"RTN","RORAPI01",42,0)
 . I $$ACTIVE^RORDD(IDESC("IEN"))  S:IDESC("ACT") RC=$P(BUF,U)
"RTN","RORAPI01",43,0)
 . E  S:IDESC("INACT") RC=$P(BUF,U)_"^"_INDT
"RTN","RORAPI01",44,0)
 Q $S(RC="1^END":"",1:RC)
"RTN","RORAPI01",45,0)
 ;
"RTN","RORAPI01",46,0)
 ;***** RETURNS THE NEXT REGISTRY FOR THE PATIENT
"RTN","RORAPI01",47,0)
 ;
"RTN","RORAPI01",48,0)
 ; .IDESC        Reference to the iterator descriptor created
"RTN","RORAPI01",49,0)
 ;               by REGITER^RORAPI01
"RTN","RORAPI01",50,0)
 ;
"RTN","RORAPI01",51,0)
 ; Return Values:
"RTN","RORAPI01",52,0)
 ;       <0  Error code
"RTN","RORAPI01",53,0)
 ;       ""  No more registries for the patient
"RTN","RORAPI01",54,0)
 ;       >0  Registry IEN^Inactivation Date
"RTN","RORAPI01",55,0)
 ;
"RTN","RORAPI01",56,0)
NEXTREG(IDESC) ;
"RTN","RORAPI01",57,0)
 N BUF,INDT,RC
"RTN","RORAPI01",58,0)
 S RC=0
"RTN","RORAPI01",59,0)
 F  D  Q:RC
"RTN","RORAPI01",60,0)
 . ; Get an IEN of the next record in the registry
"RTN","RORAPI01",61,0)
 . S IDESC("IEN")=$O(^RORDATA(798,"B",IDESC("PATIEN"),IDESC("IEN")))
"RTN","RORAPI01",62,0)
 . I IDESC("IEN")'>0  S RC="1^END"  Q
"RTN","RORAPI01",63,0)
 . ;--- Load values of the fields
"RTN","RORAPI01",64,0)
 . S BUF=$G(^RORDATA(798,IDESC("IEN"),0)),INDT=$P(BUF,U,4)
"RTN","RORAPI01",65,0)
 . ;--- Screen records
"RTN","RORAPI01",66,0)
 . I $$ACTIVE^RORDD(IDESC("IEN"))  S:IDESC("ACT") RC=$P(BUF,U,2)
"RTN","RORAPI01",67,0)
 . E  S:IDESC("INACT") RC=$P(BUF,U,2)_"^"_INDT
"RTN","RORAPI01",68,0)
 Q $S(RC="1^END":"",1:RC)
"RTN","RORAPI01",69,0)
 ;
"RTN","RORAPI01",70,0)
 ;***** CREATES AN ITERATOR OF PATIENTS IN THE REGISTRY
"RTN","RORAPI01",71,0)
 ;
"RTN","RORAPI01",72,0)
 ; .IDESC        Reference to a local variable where an iterator
"RTN","RORAPI01",73,0)
 ;               descriptor will be created
"RTN","RORAPI01",74,0)
 ; REGNAME       Registry name
"RTN","RORAPI01",75,0)
 ; [MODE]        Bit flags that define iteration mode (3 by default)
"RTN","RORAPI01",76,0)
 ;                 1  Active patients
"RTN","RORAPI01",77,0)
 ;                 2  Inactive patients
"RTN","RORAPI01",78,0)
 ;
"RTN","RORAPI01",79,0)
 ; Return Values:
"RTN","RORAPI01",80,0)
 ;       <0  Error code
"RTN","RORAPI01",81,0)
 ;        0  Ok
"RTN","RORAPI01",82,0)
 ;
"RTN","RORAPI01",83,0)
PATITER(IDESC,REGNAME,MODE) ;
"RTN","RORAPI01",84,0)
 N REGIEN  K IDESC
"RTN","RORAPI01",85,0)
 ;--- Get an IEN of the Registry Parameters
"RTN","RORAPI01",86,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORAPI01",87,0)
 Q:REGIEN<0 REGIEN
"RTN","RORAPI01",88,0)
 ;--- Setup the descriptor
"RTN","RORAPI01",89,0)
 S MODE=$S($G(MODE):MODE,1:3)
"RTN","RORAPI01",90,0)
 S IDESC("REGNAME")=REGNAME
"RTN","RORAPI01",91,0)
 S IDESC("REGIEN")=REGIEN
"RTN","RORAPI01",92,0)
 S IDESC("ACT")=MODE#2
"RTN","RORAPI01",93,0)
 S IDESC("INACT")=MODE\2#2
"RTN","RORAPI01",94,0)
 S IDESC("ROOT")=$$ROOT^DILFD(798,"",1)
"RTN","RORAPI01",95,0)
 S IDESC("IEN")=0
"RTN","RORAPI01",96,0)
 Q 0
"RTN","RORAPI01",97,0)
 ;
"RTN","RORAPI01",98,0)
 ;***** CREATES AN ITERATOR OF THE PATIENT REGISTRIES
"RTN","RORAPI01",99,0)
 ;
"RTN","RORAPI01",100,0)
 ; .IDESC        Reference to a local variable where an iterator
"RTN","RORAPI01",101,0)
 ;               descriptor will be created
"RTN","RORAPI01",102,0)
 ; PATIEN        Patient IEN
"RTN","RORAPI01",103,0)
 ; [MODE]        Bit flags that define iteration mode (3 by default)
"RTN","RORAPI01",104,0)
 ;                 1  Registries where the patient is active
"RTN","RORAPI01",105,0)
 ;                 2  Registries where the patient is inactive
"RTN","RORAPI01",106,0)
 ;
"RTN","RORAPI01",107,0)
 ; Return Values:
"RTN","RORAPI01",108,0)
 ;       <0  Error code
"RTN","RORAPI01",109,0)
 ;        0  Ok
"RTN","RORAPI01",110,0)
 ;
"RTN","RORAPI01",111,0)
REGITER(IDESC,PATIEN,MODE) ;
"RTN","RORAPI01",112,0)
 K IDESC
"RTN","RORAPI01",113,0)
 ;--- Setup the descriptor
"RTN","RORAPI01",114,0)
 S MODE=$S($G(MODE):MODE,1:3)
"RTN","RORAPI01",115,0)
 S IDESC("PATIEN")=PATIEN
"RTN","RORAPI01",116,0)
 S IDESC("ACT")=MODE#2
"RTN","RORAPI01",117,0)
 S IDESC("INACT")=MODE\2#2
"RTN","RORAPI01",118,0)
 S IDESC("ROOT")=$$ROOT^DILFD(798,"",1)
"RTN","RORAPI01",119,0)
 S IDESC("IEN")=0
"RTN","RORAPI01",120,0)
 Q 0
"RTN","RORDD")
0^18^B34441882
"RTN","RORDD",1,0)
RORDD ;HCIOFO/SG - DATA DICTIONARY UTILITIES ; 10/28/03 8:43am
"RTN","RORDD",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORDD",3,0)
 ;
"RTN","RORDD",4,0)
 Q
"RTN","RORDD",5,0)
 ;
"RTN","RORDD",6,0)
 ;***** CHECKS USER KEYS AND LOGS ATTEMPTS OF UNAUTHORIZED ACCESS
"RTN","RORDD",7,0)
 ;
"RTN","RORDD",8,0)
 ; FILE          File number
"RTN","RORDD",9,0)
 ;
"RTN","RORDD",10,0)
 ; [REGISTRY]    Either a registry name or a registry IEN.
"RTN","RORDD",11,0)
 ;               By default ($G(REGISTRY)=""), the function checks if
"RTN","RORDD",12,0)
 ;               the user has any Clinical Case Registries keys.
"RTN","RORDD",13,0)
 ;
"RTN","RORDD",14,0)
 ; [STRICT]      If this parameter is defined and not zero then an
"RTN","RORDD",15,0)
 ;               access violation event is recorded even if the user
"RTN","RORDD",16,0)
 ;               has other Clinical Case Registries keys.
"RTN","RORDD",17,0)
 ;
"RTN","RORDD",18,0)
 ;               This mode can be used to restrict access to a file,
"RTN","RORDD",19,0)
 ;               which is solely associated with a single registry
"RTN","RORDD",20,0)
 ;               (for example, the ROR ICR STUDY file).
"RTN","RORDD",21,0)
 ;
"RTN","RORDD",22,0)
 ; Return Values:
"RTN","RORDD",23,0)
 ;        0  Access denied
"RTN","RORDD",24,0)
 ;        1  Access granted
"RTN","RORDD",25,0)
 ;
"RTN","RORDD",26,0)
ACCESS(FILE,REGISTRY,STRICT) ;
"RTN","RORDD",27,0)
 Q:$G(DUZ)'>0 0               ; Unknown user
"RTN","RORDD",28,0)
 Q:$E($G(XPDNM),1,3)="ROR" 1  ; KIDS
"RTN","RORDD",29,0)
 N ANYKEY,REGKEY
"RTN","RORDD",30,0)
 S (REGKEY,ANYKEY)=1
"RTN","RORDD",31,0)
 ;--- Check the user's security keys
"RTN","RORDD",32,0)
 I $G(REGISTRY)'=""  D:$D(^ROR(798.1,"ACL",DUZ,REGISTRY))<10
"RTN","RORDD",33,0)
 . Q:$D(^XUSEC("ROR VA IRM",DUZ))
"RTN","RORDD",34,0)
 . S REGKEY=0,ANYKEY=($D(^ROR(798.1,"ACL",DUZ))>1)
"RTN","RORDD",35,0)
 E  D:$D(^ROR(798.1,"ACL",DUZ))<10
"RTN","RORDD",36,0)
 . S:'$D(^XUSEC("ROR VA IRM",DUZ)) (REGKEY,ANYKEY)=0
"RTN","RORDD",37,0)
 Q:REGKEY 1
"RTN","RORDD",38,0)
 ;--- Do not record an access violation event if the user has
"RTN","RORDD",39,0)
 ;    any Clinical Case Registries key and the "strict" mode
"RTN","RORDD",40,0)
 ;--- has not been requested by the caller.
"RTN","RORDD",41,0)
 I '$G(STRICT)  Q:ANYKEY 0
"RTN","RORDD",42,0)
 N RORMSG,X
"RTN","RORDD",43,0)
 ;--- Record the access violation event (if the API is available)
"RTN","RORDD",44,0)
 S X="RORLOG"  X ^%ZOSF("TEST")
"RTN","RORDD",45,0)
 I $T  D  D ACVIOLTN^RORLOG(X,$G(REGISTRY))
"RTN","RORDD",46,0)
 . S X="Attempt of unauthorized access to the file #"_FILE
"RTN","RORDD",47,0)
 ;--- Display the message (if the current device is a display)
"RTN","RORDD",48,0)
 I $E($G(IOST),1,2)="C-"  D  H 4
"RTN","RORDD",49,0)
 . D TEXT^RORTXT(7980000.003,.RORMSG)
"RTN","RORDD",50,0)
 . W !!!  S X=""
"RTN","RORDD",51,0)
 . F  S X=$O(RORMSG(X))  Q:X=""  D
"RTN","RORDD",52,0)
 . . W ?($G(IOM,80)-$L(RORMSG(X))\2),RORMSG(X),!
"RTN","RORDD",53,0)
 ;--- Log Off the user (if not an RPC Broker session)
"RTN","RORDD",54,0)
 D:'$$BROKER^XWBLIB H^XUS
"RTN","RORDD",55,0)
 Q 0
"RTN","RORDD",56,0)
 ;
"RTN","RORDD",57,0)
 ;***** "ACL" CROSS-REFERENCE UTILITIES
"RTN","RORDD",58,0)
 ;
"RTN","RORDD",59,0)
 ; These two procedures are used by the kill and set logic of the
"RTN","RORDD",60,0)
 ; "ACL" cross-reference (MUMPS type) of the .01 field of the SECURITY
"RTN","RORDD",61,0)
 ; KEY multiple of the ROR REGISTRY PARAMETERS file (#798.1).
"RTN","RORDD",62,0)
 ;
"RTN","RORDD",63,0)
 ; FileMan initializes the X variable (name of the security key) and
"RTN","RORDD",64,0)
 ; the DA array before calling these procedures.
"RTN","RORDD",65,0)
 ;
"RTN","RORDD",66,0)
ACLKILL ;
"RTN","RORDD",67,0)
 N RORDUZ,RORREG
"RTN","RORDD",68,0)
 S RORREG=$P($G(^ROR(798.1,DA(1),0)),U)
"RTN","RORDD",69,0)
 S RORDUZ=""
"RTN","RORDD",70,0)
 F  S RORDUZ=$O(^XUSEC(X,RORDUZ))  Q:RORDUZ=""  D
"RTN","RORDD",71,0)
 . K ^ROR(798.1,"ACL",RORDUZ,DA(1),X,DA)
"RTN","RORDD",72,0)
 . K:RORREG'="" ^ROR(798.1,"ACL",RORDUZ,RORREG,X,DA)
"RTN","RORDD",73,0)
 Q
"RTN","RORDD",74,0)
 ;
"RTN","RORDD",75,0)
ACLSET ;
"RTN","RORDD",76,0)
 N RORDUZ,RORREG
"RTN","RORDD",77,0)
 S RORREG=$P($G(^ROR(798.1,DA(1),0)),U)
"RTN","RORDD",78,0)
 S RORDUZ=""
"RTN","RORDD",79,0)
 F  S RORDUZ=$O(^XUSEC(X,RORDUZ))  Q:RORDUZ=""  D
"RTN","RORDD",80,0)
 . S ^ROR(798.1,"ACL",RORDUZ,DA(1),X,DA)=""
"RTN","RORDD",81,0)
 . S:RORREG'="" ^ROR(798.1,"ACL",RORDUZ,RORREG,X,DA)=""
"RTN","RORDD",82,0)
 Q
"RTN","RORDD",83,0)
 ;
"RTN","RORDD",84,0)
 ;***** CHECKS IF THE REGISTRY RECORD IS ACTIVE
"RTN","RORDD",85,0)
 ;
"RTN","RORDD",86,0)
 ; IEN           IEN of the registry record
"RTN","RORDD",87,0)
 ;
"RTN","RORDD",88,0)
 ; [CHKDT]       Date/Time for status calculation. The
"RTN","RORDD",89,0)
 ;               current Date/Time is used by default.
"RTN","RORDD",90,0)
 ;
"RTN","RORDD",91,0)
 ; [.REASON]     Reason for inactivation is returned via this
"RTN","RORDD",92,0)
 ;               parameter (if the record is inactive):
"RTN","RORDD",93,0)
 ;                 -1  Pending patient
"RTN","RORDD",94,0)
 ;                  0  Active or deceased
"RTN","RORDD",95,0)
 ;                 >0  Code of inactivation reason
"RTN","RORDD",96,0)
 ;
"RTN","RORDD",97,0)
 ; Return Values:
"RTN","RORDD",98,0)
 ;        0  The record is inactive
"RTN","RORDD",99,0)
 ;        1  The record is active
"RTN","RORDD",100,0)
 ;
"RTN","RORDD",101,0)
ACTIVE(IEN,CHKDT,REASON) ;
"RTN","RORDD",102,0)
 N BUF0,INACTDT
"RTN","RORDD",103,0)
 S BUF0=$G(^RORDATA(798,+IEN,0))
"RTN","RORDD",104,0)
 I $P(BUF0,U,5)=4  S REASON=-1  Q 0  ; NEW PATIENT: PENDING
"RTN","RORDD",105,0)
 ;---
"RTN","RORDD",106,0)
 S INACTDT=+$P(BUF0,U,4),REASON=0  Q:INACTDT'>0 1
"RTN","RORDD",107,0)
 ;---
"RTN","RORDD",108,0)
 S:$G(CHKDT)'>0 CHKDT=$$NOW^XLFDT
"RTN","RORDD",109,0)
 I INACTDT'>CHKDT,INACTDT'<$P(BUF0,U,11)  S REASON=+$P(BUF0,U,13)  Q 0
"RTN","RORDD",110,0)
 Q 1
"RTN","RORDD",111,0)
 ;
"RTN","RORDD",112,0)
 ;***** DISPLAYS A LIST OF APIs DEFINED IN THE SUBFILE #799.23
"RTN","RORDD",113,0)
 ;
"RTN","RORDD",114,0)
 ; IEN           IEN of the current record of the file #799.2
"RTN","RORDD",115,0)
 ;
"RTN","RORDD",116,0)
APILST(IEN) ;
"RTN","RORDD",117,0)
 N D,DIC,DLAYGO,DZ,RORMSG
"RTN","RORDD",118,0)
 S DIC=$$ROOT^DILFD(799.23,","_(+IEN)_",")  Q:DIC=""
"RTN","RORDD",119,0)
 S D=$$GET1^DID(799.23,.01,,"FIELD LENGTH",,"RORMSG")
"RTN","RORDD",120,0)
 D EN^DDIOL($J(1,D),,"?2"),EN^DDIOL("GETS^DIQ",,"?10")
"RTN","RORDD",121,0)
 S DIC(0)="",D="B",DZ="??"
"RTN","RORDD",122,0)
 S DIC("W")="D EN^DDIOL($P(^(0),U,3)_""^""_$P(^(0),U,2),,""?10"")"
"RTN","RORDD",123,0)
 D DQ^DICQ
"RTN","RORDD",124,0)
 Q
"RTN","RORDD",125,0)
 ;
"RTN","RORDD",126,0)
 ;***** VALIDATES A NAME OF THE CALLBACK FUNCTION
"RTN","RORDD",127,0)
 ;
"RTN","RORDD",128,0)
 ; MNFP          Minimal number of formal parameters (opt'l).
"RTN","RORDD",129,0)
 ;               If this parameter has a value greater than 1, the
"RTN","RORDD",130,0)
 ;               function makes very simple check of the number of
"RTN","RORDD",131,0)
 ;               formal parameters in the source code.
"RTN","RORDD",132,0)
 ;
"RTN","RORDD",133,0)
 ; This function is intended for use in the input transforms
"RTN","RORDD",134,0)
 ; of registry definition fields. It kills the X variable if it
"RTN","RORDD",135,0)
 ; contains illegal value.
"RTN","RORDD",136,0)
 ;
"RTN","RORDD",137,0)
 ; The function does not allow to use '%' in the routine and
"RTN","RORDD",138,0)
 ; tag names (this is prohibited by VistA SAC).
"RTN","RORDD",139,0)
 ;
"RTN","RORDD",140,0)
 ; If the function cannot obtain the source code of the callback
"RTN","RORDD",141,0)
 ; function (because the code does not exist yet or has been stripped)
"RTN","RORDD",142,0)
 ; or there are not enough formal parameters in the definition of the
"RTN","RORDD",143,0)
 ; function, it issues a warning but does not reject the value.
"RTN","RORDD",144,0)
 ;
"RTN","RORDD",145,0)
 ; Return Values:
"RTN","RORDD",146,0)
 ;        0  Ok
"RTN","RORDD",147,0)
 ;        1  Illegal name (X is killed)
"RTN","RORDD",148,0)
 ;
"RTN","RORDD",149,0)
EP(MNFP) ;
"RTN","RORDD",150,0)
 Q:$G(X)="" 0
"RTN","RORDD",151,0)
 N ENTPNT,TMP
"RTN","RORDD",152,0)
 ;--- Check if the value has the "$$TAG^ROUTINE" format
"RTN","RORDD",153,0)
 I '(X?2"$"1.8UN1"^"1.8UN)  K X  Q 1
"RTN","RORDD",154,0)
 ;--- Check if the routine exists
"RTN","RORDD",155,0)
 S ENTPNT=X,X=$P(X,U,2)
"RTN","RORDD",156,0)
 X ^%ZOSF("TEST")  E  D  K X  Q 1
"RTN","RORDD",157,0)
 . D EN^DDIOL("The '"_X_"' routine does not exist!")
"RTN","RORDD",158,0)
 S X=ENTPNT
"RTN","RORDD",159,0)
 ;--- Skip the enhanced checks when verifying fields
"RTN","RORDD",160,0)
 Q:$G(DIUTIL)="VERIFY FIELDS" 0
"RTN","RORDD",161,0)
 ;--- Get the line of source code
"RTN","RORDD",162,0)
 S ENTPNT=$P(X,"$$",2),TMP=$TR($P($T(@ENTPNT),";")," ")
"RTN","RORDD",163,0)
 ;--- Display a warning if there is no source line
"RTN","RORDD",164,0)
 I TMP=""  D  Q 0
"RTN","RORDD",165,0)
 . S TMP="Make sure that the '"_$P(ENTPNT,U)_"' tag"
"RTN","RORDD",166,0)
 . D EN^DDIOL(TMP_" exists in the '"_$P(ENTPNT,U,2)_"' routine.")
"RTN","RORDD",167,0)
 ;--- Display a warning if there are not enough formal parameters
"RTN","RORDD",168,0)
 I $G(MNFP)>1,$L(TMP,",")<MNFP  D  Q 0
"RTN","RORDD",169,0)
 . S TMP="Make sure that the entry point has at least "_MNFP
"RTN","RORDD",170,0)
 . D EN^DDIOL(TMP_" formal parameter(s).")
"RTN","RORDD",171,0)
 Q 0
"RTN","RORDD",172,0)
 ;
"RTN","RORDD",173,0)
 ;***** VALIDATES A SELECTION RULE EXPRESSION
"RTN","RORDD",174,0)
 ;
"RTN","RORDD",175,0)
 ; FILE          File number that the expression is associated with
"RTN","RORDD",176,0)
 ;
"RTN","RORDD",177,0)
 ; This function is intended for use in the input transforms
"RTN","RORDD",178,0)
 ; of registry definition fields. It kills the X variable if
"RTN","RORDD",179,0)
 ; it contains an illegal value.
"RTN","RORDD",180,0)
 ;
"RTN","RORDD",181,0)
 ; Return Values:
"RTN","RORDD",182,0)
 ;        0  Ok
"RTN","RORDD",183,0)
 ;        1  Illegal expression (X is killed)
"RTN","RORDD",184,0)
 ;
"RTN","RORDD",185,0)
EXPR(FILE) ;
"RTN","RORDD",186,0)
 Q:($G(FILE)'>0)!($G(X)="") 0
"RTN","RORDD",187,0)
 N EXPR,RC,RESULT,RORERROR,RORLOG,RORPARM,TMP
"RTN","RORDD",188,0)
 ;--- Check if the parser routine exists in the UCI
"RTN","RORDD",189,0)
 S EXPR=X,X="RORUPEX"  X ^%ZOSF("TEST")  S X=EXPR  E  Q 0
"RTN","RORDD",190,0)
 ;--- Parse and validate the expression
"RTN","RORDD",191,0)
 S RC=$$PARSER^RORUPEX(FILE,X,.RESULT)
"RTN","RORDD",192,0)
 Q:RC'<0 0  K X
"RTN","RORDD",193,0)
 ;--- Field does not exist
"RTN","RORDD",194,0)
 I RC=-7   D  Q 1
"RTN","RORDD",195,0)
 . S TMP="One of the referenced fields"
"RTN","RORDD",196,0)
 . D EN^DDIOL(TMP_" does not exist in the file #"_FILE_"!")
"RTN","RORDD",197,0)
 ;--- Syntax error in the expression
"RTN","RORDD",198,0)
 I RC=-21  D  Q 1
"RTN","RORDD",199,0)
 . D EN^DDIOL("Invalid expression: '"_EXPR_"'")
"RTN","RORDD",200,0)
 . D EN^DDIOL("Parsed to: '"_$G(RESULT)_"' ")
"RTN","RORDD",201,0)
 ;--- File does not exist
"RTN","RORDD",202,0)
 I RC=-58  D  Q 1
"RTN","RORDD",203,0)
 . D EN^DDIOL("Referenced file #"_FILE_" does not exist!")
"RTN","RORDD",204,0)
 Q 1
"RTN","RORDD",205,0)
 ;
"RTN","RORDD",206,0)
 ;***** CHECKS IF A FIELD OF A NATIONAL DEFINITION CAN BE DELETED
"RTN","RORDD",207,0)
 ;
"RTN","RORDD",208,0)
 ; FILE          Top-level file number
"RTN","RORDD",209,0)
 ; [IEN]         IEN of the current record of the top-level file
"RTN","RORDD",210,0)
 ; [FIELD]       Number of the NATIONAL field.
"RTN","RORDD",211,0)
 ;               If value of this parameter less than zero, local
"RTN","RORDD",212,0)
 ;               modifications of all records will be prohibited.
"RTN","RORDD",213,0)
 ;               By default, the .09 field is used.
"RTN","RORDD",214,0)
 ;
"RTN","RORDD",215,0)
 ; This function is intended for use in the "DEL" node logic
"RTN","RORDD",216,0)
 ; of registry definition fields.
"RTN","RORDD",217,0)
 ;
"RTN","RORDD",218,0)
 ; Return Values:
"RTN","RORDD",219,0)
 ;        0  The value of the field can be deleted
"RTN","RORDD",220,0)
 ;        1  Deletion is prohibited
"RTN","RORDD",221,0)
 ;
"RTN","RORDD",222,0)
VADEL(FILE,IEN,FIELD) ;
"RTN","RORDD",223,0)
 Q:$G(XPDNM)'="" 0
"RTN","RORDD",224,0)
 ;--- An authorized developer can delete anything
"RTN","RORDD",225,0)
 Q:$G(RORPARM("DEVELOPER")) 0
"RTN","RORDD",226,0)
 ;--- Check if the registry definition is a national one
"RTN","RORDD",227,0)
 N RC,RORMSG
"RTN","RORDD",228,0)
 I $G(FIELD)'<0  S RC=0  D:$G(IEN)>0  Q:'RC 0
"RTN","RORDD",229,0)
 . S:'$G(FIELD) FIELD=.09
"RTN","RORDD",230,0)
 . S RC=$$GET1^DIQ(FILE,IEN_",",FIELD,"I",,"RORMSG")
"RTN","RORDD",231,0)
 D EN^DDIOL("You cannot edit a national registry definition!")
"RTN","RORDD",232,0)
 Q 1
"RTN","RORDD",233,0)
 ;
"RTN","RORDD",234,0)
 ;***** CHECKS IF A FIELD OF A NATIONAL DEFINITION CAN BE EDITED
"RTN","RORDD",235,0)
 ;
"RTN","RORDD",236,0)
 ; FILE          Top-level file number
"RTN","RORDD",237,0)
 ; [IEN]         IEN of the current record of the top-level file
"RTN","RORDD",238,0)
 ; [FIELD]       Number of the NATIONAL field.
"RTN","RORDD",239,0)
 ;               If value of this parameter less than zero, local
"RTN","RORDD",240,0)
 ;               modifications of all records will be prohibited.
"RTN","RORDD",241,0)
 ;               By default, the .09 field is used.
"RTN","RORDD",242,0)
 ;
"RTN","RORDD",243,0)
 ; This function is intended for use in the input transforms
"RTN","RORDD",244,0)
 ; of registry definition fields. It kills the X variable if
"RTN","RORDD",245,0)
 ; it contains illegal value.
"RTN","RORDD",246,0)
 ;
"RTN","RORDD",247,0)
 ; Return Values:
"RTN","RORDD",248,0)
 ;        0  The field can be edited
"RTN","RORDD",249,0)
 ;        1  Editing is prohibited (X is killed)
"RTN","RORDD",250,0)
 ;
"RTN","RORDD",251,0)
VAEDT(FILE,IEN,FIELD) ;
"RTN","RORDD",252,0)
 Q:($G(DIUTIL)="VERIFY FIELDS")!($G(XPDNM)'="") 0
"RTN","RORDD",253,0)
 ;--- An authorized developer can edit anything
"RTN","RORDD",254,0)
 Q:$G(RORPARM("DEVELOPER")) 0
"RTN","RORDD",255,0)
 ;--- Check if the registry definition is a national one
"RTN","RORDD",256,0)
 N RC,RORMSG
"RTN","RORDD",257,0)
 I $G(FIELD)'<0  S RC=0  D:$G(IEN)>0  Q:'RC 0
"RTN","RORDD",258,0)
 . S:'$G(FIELD) FIELD=.09
"RTN","RORDD",259,0)
 . S RC=$$GET1^DIQ(FILE,IEN_",",FIELD,"I",,"RORMSG")
"RTN","RORDD",260,0)
 K X
"RTN","RORDD",261,0)
 D EN^DDIOL("You cannot edit a national registry definition!")
"RTN","RORDD",262,0)
 Q 1
"RTN","RORDD01")
0^34^B1880531
"RTN","RORDD01",1,0)
RORDD01 ;HCIOFO/SG - DATA DICTIONARY UTILITIES ; 8/19/03 4:10pm
"RTN","RORDD01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORDD01",3,0)
 ;
"RTN","RORDD01",4,0)
 Q
"RTN","RORDD01",5,0)
 ;
"RTN","RORDD01",6,0)
 ;***** DELETES THE DATA ASSOCIATED WITH THE MAIN REGISTRY RECORD
"RTN","RORDD01",7,0)
 ;
"RTN","RORDD01",8,0)
 ; IEN           IEN of the registry record (file #798)
"RTN","RORDD01",9,0)
 ; PATIEN        Patient IEN
"RTN","RORDD01",10,0)
 ;
"RTN","RORDD01",11,0)
DEL798(IEN,PATIEN) ;
"RTN","RORDD01",12,0)
 N DA,DIK,I,PTDEL
"RTN","RORDD01",13,0)
 ;--- Delete the ICR record from the ROR ICR STUDY file (#799.4)
"RTN","RORDD01",14,0)
 I $D(^RORDATA(799.4,IEN))  S DIK="^RORDATA(799.4,",DA=IEN  D ^DIK
"RTN","RORDD01",15,0)
 ;--- Check if the patient is added to more than one registry
"RTN","RORDD01",16,0)
 S I="",PTDEL=1
"RTN","RORDD01",17,0)
 F  S I=$O(^RORDATA(798,"B",PATIEN,I))  Q:I=""  S:I'=IEN PTDEL=0
"RTN","RORDD01",18,0)
 ;--- Delete corresponding patient's records
"RTN","RORDD01",19,0)
 D:PTDEL
"RTN","RORDD01",20,0)
 . ;--- Delete the record from the ROR PATIENT file
"RTN","RORDD01",21,0)
 . S DIK="^RORDATA(798.4,",DA=PATIEN  D ^DIK
"RTN","RORDD01",22,0)
 . ;--- Delete the record from the ROR PENDING PATIENT file
"RTN","RORDD01",23,0)
 . S DIK="^RORDATA(798.3,",DA=PATIEN  D ^DIK
"RTN","RORDD01",24,0)
 Q
"RTN","RORDD01",25,0)
 ;
"RTN","RORDD01",26,0)
 ;***** STORE THE VALUE INTO THE FIELD
"RTN","RORDD01",27,0)
 ;
"RTN","RORDD01",28,0)
 ; FILE          Sub(file) number
"RTN","RORDD01",29,0)
 ; IENS          IENS of the record
"RTN","RORDD01",30,0)
 ; FIELD         Field number
"RTN","RORDD01",31,0)
 ; VALUE         Internal value to be assigned
"RTN","RORDD01",32,0)
 ;
"RTN","RORDD01",33,0)
FILE(FILE,IENS,FIELD,VALUE) ;
"RTN","RORDD01",34,0)
 N ROR8FDA,ROR8MSG
"RTN","RORDD01",35,0)
 S ROR8FDA(+FILE,IENS,+FIELD)=VALUE
"RTN","RORDD01",36,0)
 D FILE^DIE(,"ROR8FDA","ROR8MSG")
"RTN","RORDD01",37,0)
 Q
"RTN","RORDD01",38,0)
 ;
"RTN","RORDD01",39,0)
 ;***** GENERATES THE INDEX VALUE OF THE REPORT ELEMENT
"RTN","RORDD01",40,0)
 ;
"RTN","RORDD01",41,0)
 ; MODE          Sort mode (see the SORT BY field of the REPORT
"RTN","RORDD01",42,0)
 ;               ELEMENT multiple of the ROR TASK file for details)
"RTN","RORDD01",43,0)
 ; VAL           Value of the report element
"RTN","RORDD01",44,0)
 ;
"RTN","RORDD01",45,0)
SORTBY(MODE,VAL) ;
"RTN","RORDD01",46,0)
 Q $S(MODE=3:+VAL,VAL="":" ",MODE=2:$E(VAL,1,29)_" ",1:$E(VAL,1,30))
"RTN","RORERR")
0^64^B25277669
"RTN","RORERR",1,0)
RORERR ;HCIOFO/SG - ERROR PROCESSING  ; 11/20/03 9:44am
"RTN","RORERR",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3,5**;May 14, 2002
"RTN","RORERR",3,0)
 ;
"RTN","RORERR",4,0)
 Q
"RTN","RORERR",5,0)
 ;
"RTN","RORERR",6,0)
 ;***** INITIALIZES THE ERROR STACK
"RTN","RORERR",7,0)
 ;
"RTN","RORERR",8,0)
 ; [DEFLOC]      Default error location
"RTN","RORERR",9,0)
 ; [ENABLE]      Enable extended error processing
"RTN","RORERR",10,0)
 ; 
"RTN","RORERR",11,0)
 ; Do not forget to NEW the RORERRDL variable before calling
"RTN","RORERR",12,0)
 ; this procedure!
"RTN","RORERR",13,0)
 ;
"RTN","RORERR",14,0)
CLEAR(DEFLOC,ENABLE) ;
"RTN","RORERR",15,0)
 S:$D(ENABLE) RORPARM("ERR")=+$G(ENABLE)
"RTN","RORERR",16,0)
 I $G(RORPARM("ERR"))  K RORERROR("ES")  S:$D(DEFLOC) RORERRDL=DEFLOC
"RTN","RORERR",17,0)
 D CLEAN^DILF
"RTN","RORERR",18,0)
 Q
"RTN","RORERR",19,0)
 ;
"RTN","RORERR",20,0)
 ;***** CHECKS THE ERRORS AFTER A FILEMAN DBS CALL
"RTN","RORERR",21,0)
 ;
"RTN","RORERR",22,0)
 ; ROR8MSG       Closed reference of the error messages array
"RTN","RORERR",23,0)
 ;               (from DBS calls)
"RTN","RORERR",24,0)
 ; [ERRCODE]     Error code to assign
"RTN","RORERR",25,0)
 ; [PLACE]       Location of the error (see the $$ERROR)
"RTN","RORERR",26,0)
 ; [PATIEN]      Patient IEN
"RTN","RORERR",27,0)
 ; [FILE]        File number used in the DBS call
"RTN","RORERR",28,0)
 ; [IENS]        IENS used in the DBS call
"RTN","RORERR",29,0)
 ;
"RTN","RORERR",30,0)
 ; The $$DBS^RORERR function checks the DIERR and @ROR8MSG variables
"RTN","RORERR",31,0)
 ; for errors after a FileMan DBS call.
"RTN","RORERR",32,0)
 ; 
"RTN","RORERR",33,0)
 ; Return Values:
"RTN","RORERR",34,0)
 ;
"RTN","RORERR",35,0)
 ; If there are no errors found, it returns an empty string.
"RTN","RORERR",36,0)
 ; In case of errors, the result depends on value of the ERRCODE
"RTN","RORERR",37,0)
 ; parameter:
"RTN","RORERR",38,0)
 ;
"RTN","RORERR",39,0)
 ; If ERRCODE is omitted or equals 0, the function returns a string
"RTN","RORERR",40,0)
 ; containing the list of error codes separated by comma.
"RTN","RORERR",41,0)
 ; 
"RTN","RORERR",42,0)
 ; If ERRCODE is not zero, the $$ERROR^RORERR function is called and
"RTN","RORERR",43,0)
 ; its return value is returned.
"RTN","RORERR",44,0)
 ;
"RTN","RORERR",45,0)
 ; NOTE: This entry point can also be called as a procedure:
"RTN","RORERR",46,0)
 ;       D DBS^RORERR(...) if you do not need its return value.
"RTN","RORERR",47,0)
 ;
"RTN","RORERR",48,0)
DBS(ROR8MSG,ERRCODE,PLACE,PATIEN,FILE,IENS) ;
"RTN","RORERR",49,0)
 K RORERROR("DBS")
"RTN","RORERR",50,0)
 I '$G(DIERR)  Q:$QUIT ""  Q
"RTN","RORERR",51,0)
 N ERRLST,ERRNODE,I,MSGTEXT
"RTN","RORERR",52,0)
 S ERRNODE=$S($G(ROR8MSG)'="":$NA(@ROR8MSG@("DIERR")),1:$NA(^TMP("DIERR",$J)))
"RTN","RORERR",53,0)
 I $D(@ERRNODE)<10  Q:$QUIT ""  Q
"RTN","RORERR",54,0)
 ;--- Get a list of errors
"RTN","RORERR",55,0)
 S I=0
"RTN","RORERR",56,0)
 F  S I=$O(@ERRNODE@("E",I))  Q:'I  S RORERROR("DBS",I)=""
"RTN","RORERR",57,0)
 ;--- Return a list of errors
"RTN","RORERR",58,0)
 I '$G(ERRCODE)  D  Q:$QUIT $P(ERRLST,",",2,99)  Q
"RTN","RORERR",59,0)
 . S ERRLST="",I=0
"RTN","RORERR",60,0)
 . F  S I=$O(RORERROR("DBS",I))  Q:'I  S ERRLST=ERRLST_","_I
"RTN","RORERR",61,0)
 . D CLEAN^DILF
"RTN","RORERR",62,0)
 ;--- Record/display the error message
"RTN","RORERR",63,0)
 D MSG^DIALOG("AE",.MSGTEXT,,,$G(ROR8MSG)),CLEAN^DILF
"RTN","RORERR",64,0)
 S I=$S($G(FILE):"; File #"_FILE,1:"")
"RTN","RORERR",65,0)
 S:$G(IENS)'="" I=I_"; IENS: """_IENS_""""
"RTN","RORERR",66,0)
 S I=$$ERROR(ERRCODE,.PLACE,.MSGTEXT,.PATIEN,I)
"RTN","RORERR",67,0)
 Q:$QUIT I  Q
"RTN","RORERR",68,0)
 ;
"RTN","RORERR",69,0)
 ;***** SETS DEFAULT ERROR LOCATION
"RTN","RORERR",70,0)
 ;
"RTN","RORERR",71,0)
 ; DEFLOC        Default error location
"RTN","RORERR",72,0)
 ; 
"RTN","RORERR",73,0)
 ; Do not forget to NEW the RORERRDL variable before calling
"RTN","RORERR",74,0)
 ; this procedure!
"RTN","RORERR",75,0)
 ;
"RTN","RORERR",76,0)
DFLTLOC(DEFLOC) ;
"RTN","RORERR",77,0)
 I $G(RORPARM("ERR"))  S RORERRDL=DEFLOC
"RTN","RORERR",78,0)
 D CLEAN^DILF
"RTN","RORERR",79,0)
 Q
"RTN","RORERR",80,0)
 ;
"RTN","RORERR",81,0)
 ;***** DISPLAYS CONTENT OF THE ERROR STACK
"RTN","RORERR",82,0)
DSPSTK() ;
"RTN","RORERR",83,0)
 Q:'$G(RORPARM("ERR"))!($D(RORERROR("ES"))<10)
"RTN","RORERR",84,0)
 N EPTR,I,TMP
"RTN","RORERR",85,0)
 D DSPSTKL("Err   Message Text",1)
"RTN","RORERR",86,0)
 D DSPSTKL("      Additional info")
"RTN","RORERR",87,0)
 S EPTR=""
"RTN","RORERR",88,0)
 F  S EPTR=$O(RORERROR("ES",EPTR))  Q:EPTR=""  D
"RTN","RORERR",89,0)
 . S TMP=RORERROR("ES",EPTR)
"RTN","RORERR",90,0)
 . D DSPSTKL($J(+TMP,4)_"  "_$P(TMP,U,2),1)
"RTN","RORERR",91,0)
 . S TMP=$G(RORERROR("ES",EPTR,1))
"RTN","RORERR",92,0)
 . D:TMP'="" DSPSTKL("      Location: "_TMP)
"RTN","RORERR",93,0)
 . S I=""
"RTN","RORERR",94,0)
 . F  S I=$O(RORERROR("ES",EPTR,2,I))  Q:I=""  D
"RTN","RORERR",95,0)
 . . D DSPSTKL("      "_RORERROR("ES",EPTR,2,I))
"RTN","RORERR",96,0)
 Q
"RTN","RORERR",97,0)
 ;
"RTN","RORERR",98,0)
 ; MSG           Message to display
"RTN","RORERR",99,0)
 ; [SKIP]        Skip a line before the output
"RTN","RORERR",100,0)
 ;
"RTN","RORERR",101,0)
DSPSTKL(MSG,SKIP) ;
"RTN","RORERR",102,0)
 I '$G(RORPARM("KIDS"))  W:$G(SKIP) !  W MSG,!  Q
"RTN","RORERR",103,0)
 I $G(SKIP)  D BMES^XPDUTL(MSG)  Q
"RTN","RORERR",104,0)
 D MES^XPDUTL(MSG)
"RTN","RORERR",105,0)
 Q
"RTN","RORERR",106,0)
 ;
"RTN","RORERR",107,0)
 ;***** PUTS THE ERROR IN THE ERROR STACK AND LOG FILE
"RTN","RORERR",108,0)
 ;
"RTN","RORERR",109,0)
 ; ERRCODE       Error code. Debug messages, information messages,
"RTN","RORERR",110,0)
 ;               data quality warnings and warnings are not placed
"RTN","RORERR",111,0)
 ;               into the stack. However, they are logged and
"RTN","RORERR",112,0)
 ;               displayed if this is enabled.
"RTN","RORERR",113,0)
 ;
"RTN","RORERR",114,0)
 ; [PLACE]       Location of the error (TAG^ROUTINE).
"RTN","RORERR",115,0)
 ;
"RTN","RORERR",116,0)
 ;               If the parameter is undefined then the location is
"RTN","RORERR",117,0)
 ;               extracted from the stack (see description of the
"RTN","RORERR",118,0)
 ;               $STACK function for more details).
"RTN","RORERR",119,0)
 ;
"RTN","RORERR",120,0)
 ;               If an empty string is used as a value of the
"RTN","RORERR",121,0)
 ;               parameter then the default location is used
"RTN","RORERR",122,0)
 ;               (that has been set by CLEAR or DFLTLOC).
"RTN","RORERR",123,0)
 ;
"RTN","RORERR",124,0)
 ; [[.]RORINFO]  Optional additional information (either a string or
"RTN","RORERR",125,0)
 ;               a reference to a local array that contains strings
"RTN","RORERR",126,0)
 ;               prepared for storing in a word processing field)
"RTN","RORERR",127,0)
 ;
"RTN","RORERR",128,0)
 ; [PATIEN]      Patient IEN
"RTN","RORERR",129,0)
 ;
"RTN","RORERR",130,0)
 ; [ARG2-ARG5]   Optional parameters as for $$MSG^RORERR20
"RTN","RORERR",131,0)
 ;               (|1| is substituted by the value of the PATIEN)
"RTN","RORERR",132,0)
 ;
"RTN","RORERR",133,0)
 ; Return Values:
"RTN","RORERR",134,0)
 ;       <0  Error code (value of the ERRCODE)
"RTN","RORERR",135,0)
 ;        0  Ok (if ERRCOCE'<0)
"RTN","RORERR",136,0)
 ;
"RTN","RORERR",137,0)
 ; NOTE: This entry point can also be called as a procedure:
"RTN","RORERR",138,0)
 ;       D ERROR^RORERR(...) if you do not need its return value.
"RTN","RORERR",139,0)
 ;
"RTN","RORERR",140,0)
ERROR(ERRCODE,PLACE,RORINFO,PATIEN,ARG2,ARG3,ARG4,ARG5) ;
"RTN","RORERR",141,0)
 I ERRCODE'<0  Q:$QUIT 0  Q
"RTN","RORERR",142,0)
 N IR,SL,MSG,TOP,TYPE
"RTN","RORERR",143,0)
 D:'$D(PLACE)
"RTN","RORERR",144,0)
 . S SL=$STACK(-1)-1
"RTN","RORERR",145,0)
 . F  Q:SL'>0  D  Q:'(PLACE["^RORERR")  S SL=SL-1
"RTN","RORERR",146,0)
 . . S PLACE=$P($STACK(SL,"PLACE")," ")
"RTN","RORERR",147,0)
 S:$G(PLACE)="" PLACE=$G(RORERRDL)
"RTN","RORERR",148,0)
 I $D(RORINFO)=1  S IR=RORINFO  K RORINFO  S RORINFO(1)=IR,IR=1
"RTN","RORERR",149,0)
 E  S IR=$O(RORINFO(""),-1)
"RTN","RORERR",150,0)
 S MSG=$$MSG^RORERR20(+ERRCODE,.TYPE,.PATIEN,.ARG2,.ARG3,.ARG4,.ARG5)
"RTN","RORERR",151,0)
 ;--- Put the error to the error stack
"RTN","RORERR",152,0)
 D:$G(RORPARM("ERR"))&(TYPE>4)
"RTN","RORERR",153,0)
 . S (RORERROR("ES"),TOP)=$G(RORERROR("ES"))+1
"RTN","RORERR",154,0)
 . S RORERROR("ES",TOP)=+ERRCODE_U_MSG
"RTN","RORERR",155,0)
 . S RORERROR("ES",TOP,1)=PLACE
"RTN","RORERR",156,0)
 . M:$D(RORINFO) RORERROR("ES",TOP,2)=RORINFO
"RTN","RORERR",157,0)
 ;--- Log the message
"RTN","RORERR",158,0)
 S:PLACE'="" IR=IR+1,RORINFO(IR)="Location: "_PLACE
"RTN","RORERR",159,0)
 D LOG^RORLOG(TYPE,MSG,$G(PATIEN),.RORINFO),CLEAN^DILF
"RTN","RORERR",160,0)
 Q:$QUIT ERRCODE  Q
"RTN","RORERR",161,0)
 ;
"RTN","RORERR",162,0)
 ;***** CHECKS FOR INVALID POINTER ERROR
"RTN","RORERR",163,0)
 ;
"RTN","RORERR",164,0)
 ; FILE          Number of the 'pointed from' file
"RTN","RORERR",165,0)
 ; IENS          IENS of the record of the file
"RTN","RORERR",166,0)
 ; FIELD         Number of the pointer field
"RTN","RORERR",167,0)
 ; [PLACE]       Location of the error (see the $$ERROR)
"RTN","RORERR",168,0)
 ; [PATIEN]      Patient IEN
"RTN","RORERR",169,0)
 ; [ERRCODE]     Error code to assign (-79 by default)
"RTN","RORERR",170,0)
 ;
"RTN","RORERR",171,0)
 ; The $$INVLDPTR^RORERR function checks the list of latest FileMan
"RTN","RORERR",172,0)
 ; DBS error codes for the pointer errors.
"RTN","RORERR",173,0)
 ; 
"RTN","RORERR",174,0)
 ; Return Values:
"RTN","RORERR",175,0)
 ;
"RTN","RORERR",176,0)
 ; If there are no pointer errors found, the function returns zero.
"RTN","RORERR",177,0)
 ; Otherwise, the $$ERROR^RORERR function is called and its value
"RTN","RORERR",178,0)
 ; is returned (a negative value of the ERRCODE or -79 by default).
"RTN","RORERR",179,0)
 ;
"RTN","RORERR",180,0)
INVLDPTR(FILE,IENS,FIELD,PLACE,PATIEN,ERRCODE) ;
"RTN","RORERR",181,0)
 Q:$D(RORERROR("DBS"))<10 0
"RTN","RORERR",182,0)
 N EC,TMP
"RTN","RORERR",183,0)
 F EC=601,0  Q:$D(RORERROR("DBS",EC))
"RTN","RORERR",184,0)
 Q:'EC 0
"RTN","RORERR",185,0)
 S TMP="File #"_FILE_"; IENS: """_IENS_"""; Field: "_FIELD
"RTN","RORERR",186,0)
 Q $$ERROR($S($G(ERRCODE)<0:ERRCODE,1:-79),$G(PLACE),.TMP,.PATIEN)
"RTN","RORERR",187,0)
 ;
"RTN","RORERR",188,0)
 ;***** RETURNS THE ERROR STACK FOR A REMOTE PROCEDURE
"RTN","RORERR",189,0)
 ;
"RTN","RORERR",190,0)
 ; .RESULT       Reference to a local variable where the error
"RTN","RORERR",191,0)
 ;               descriptors are returned to.
"RTN","RORERR",192,0)
 ;
"RTN","RORERR",193,0)
 ; LASTERR       The last error code
"RTN","RORERR",194,0)
 ;
"RTN","RORERR",195,0)
 ; Return Values:
"RTN","RORERR",196,0)
 ;
"RTN","RORERR",197,0)
 ; RESULT(0)             Result descriptor
"RTN","RORERR",198,0)
 ;                         ^1: The last error code (LASTERR)
"RTN","RORERR",199,0)
 ;                         ^2: Number of the error descriptors
"RTN","RORERR",200,0)
 ;
"RTN","RORERR",201,0)
 ; RESULT(i)             Error descriptor
"RTN","RORERR",202,0)
 ;                         ^1: Error code
"RTN","RORERR",203,0)
 ;                         ^2: Message
"RTN","RORERR",204,0)
 ;                         ^3: Place of the error
"RTN","RORERR",205,0)
 ;
"RTN","RORERR",206,0)
 ; Error descriptors are returned in reverse chronological order
"RTN","RORERR",207,0)
 ; (most recent first).
"RTN","RORERR",208,0)
 ; 
"RTN","RORERR",209,0)
RPCSTK(RESULT,LASTERR) ;
"RTN","RORERR",210,0)
 N CNT,EPTR,TMP
"RTN","RORERR",211,0)
 K RESULT  S RESULT(0)=(+LASTERR)_"^0"
"RTN","RORERR",212,0)
 S TMP=$$RTRNFMT^XWBLIB(2,1)
"RTN","RORERR",213,0)
 Q:$D(RORERROR("ES"))<10
"RTN","RORERR",214,0)
 ;
"RTN","RORERR",215,0)
 S EPTR="",CNT=0
"RTN","RORERR",216,0)
 F  S EPTR=$O(RORERROR("ES",EPTR),-1)  Q:EPTR=""  D
"RTN","RORERR",217,0)
 . S TMP=$G(RORERROR("ES",EPTR)),CNT=CNT+1
"RTN","RORERR",218,0)
 . S RESULT(CNT)=(+TMP)_"^"_$TR($P(TMP,U,2,999),"^","~")
"RTN","RORERR",219,0)
 . S TMP=$G(RORERROR("ES",EPTR,1))
"RTN","RORERR",220,0)
 . S $P(RESULT(CNT),"^",3)=$TR(TMP,"^","~")
"RTN","RORERR",221,0)
 ;
"RTN","RORERR",222,0)
 S $P(RESULT(0),"^",2)=CNT
"RTN","RORERR",223,0)
 K ^TMP("DILIST",$J)
"RTN","RORERR",224,0)
 Q
"RTN","RORERR10")
0^81^B27111394
"RTN","RORERR10",1,0)
RORERR10 ;HCIOFO/SG - AAC ERROR MESSAGES (000000-050000)  ; 5/12/03 8:55am
"RTN","RORERR10",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3,5**;May 14, 2002
"RTN","RORERR10",3,0)
 ;
"RTN","RORERR10",4,0)
 ; Messages with codes greater than 050000 are located
"RTN","RORERR10",5,0)
 ; in the ^RORERR11 routine.
"RTN","RORERR10",6,0)
 ;
"RTN","RORERR10",7,0)
 Q
"RTN","RORERR10",8,0)
 ;
"RTN","RORERR10",9,0)
 ;***** RETURNS TEXT OF THE MESSAGE
"RTN","RORERR10",10,0)
 ;
"RTN","RORERR10",11,0)
 ; ERRCODE       Error code
"RTN","RORERR10",12,0)
 ; [.TYPE]       Type of the error
"RTN","RORERR10",13,0)
 ;
"RTN","RORERR10",14,0)
MSG(ERRCODE,TYPE) ;
"RTN","RORERR10",15,0)
 S TYPE=6
"RTN","RORERR10",16,0)
 Q:'(ERRCODE?1.8UN) "Illegal error code: '"_ERRCODE_"'"
"RTN","RORERR10",17,0)
 N I,MSG
"RTN","RORERR10",18,0)
 S I=ERRCODE_$S(ERRCODE>100000:"^RORERR12",ERRCODE>050000:"^RORERR11",1:"")
"RTN","RORERR10",19,0)
 S MSG=$P($T(@I),";;",2)
"RTN","RORERR10",20,0)
 S I=+$TR($P(MSG,U)," "),MSG=$P(MSG,U,4,999)
"RTN","RORERR10",21,0)
 S:I>0 TYPE=I
"RTN","RORERR10",22,0)
 Q:MSG?." " "Unknown error ("_ERRCODE_")"
"RTN","RORERR10",23,0)
 Q $$TRIM^XLFSTR(MSG)
"RTN","RORERR10",24,0)
 ;
"RTN","RORERR10",25,0)
 ;***** LIST OF THE MESSAGES (THERE SHOULD BE NOTHING AFTER THE LIST!)
"RTN","RORERR10",26,0)
 ;
"RTN","RORERR10",27,0)
 ; Message Type:
"RTN","RORERR10",28,0)
 ;               1  Debug          4  Warning
"RTN","RORERR10",29,0)
 ;               2  Information    5  Database Error
"RTN","RORERR10",30,0)
 ;               3  Data Quality   6  Error
"RTN","RORERR10",31,0)
 ;
"RTN","RORERR10",32,0)
 ;Type Seg Fld  Message Text
"RTN","RORERR10",33,0)
0 ;; 2 ^   ^   ^ Message accepted
"RTN","RORERR10",34,0)
100 ;; 6 ^   ^   ^ Segment sequence error
"RTN","RORERR10",35,0)
101 ;; 6 ^   ^   ^ Required field missing
"RTN","RORERR10",36,0)
102 ;; 6 ^   ^   ^ Data type error
"RTN","RORERR10",37,0)
103 ;; 6 ^   ^   ^ Table value not found
"RTN","RORERR10",38,0)
200 ;; 6 ^   ^   ^ Unsupported message type
"RTN","RORERR10",39,0)
201 ;; 6 ^   ^   ^ Unsupported event code
"RTN","RORERR10",40,0)
202 ;; 6 ^   ^   ^ Unsupported processing ID
"RTN","RORERR10",41,0)
203 ;; 6 ^   ^   ^ Unsupported version ID
"RTN","RORERR10",42,0)
204 ;; 6 ^   ^   ^ Unknown key identifier
"RTN","RORERR10",43,0)
205 ;; 6 ^   ^   ^ Duplicate key identifier
"RTN","RORERR10",44,0)
206 ;; 6 ^   ^   ^ Application record locked
"RTN","RORERR10",45,0)
207 ;; 6 ^   ^   ^ Application internal error
"RTN","RORERR10",46,0)
010201 ;; 6 ^PID^  2^ Non-numeric ICN
"RTN","RORERR10",47,0)
010202 ;; 6 ^PID^  2^ ICN longer than 16 characters
"RTN","RORERR10",48,0)
010301 ;; 6 ^PID^  3^ Non-numeric DFN
"RTN","RORERR10",49,0)
010302 ;; 6 ^PID^  3^ Non-numeric station number
"RTN","RORERR10",50,0)
010303 ;; 6 ^PID^  3^ Station longer than 3 characters
"RTN","RORERR10",51,0)
010501 ;; 6 ^PID^  5^ Non-alphabetic characters in Family Name
"RTN","RORERR10",52,0)
010502 ;; 6 ^PID^  5^ Family name longer than 35 characters
"RTN","RORERR10",53,0)
010503 ;; 6 ^PID^  5^ Non-alphabetic characters in Given Name
"RTN","RORERR10",54,0)
010504 ;; 6 ^PID^  5^ Given name longer than 25 characters
"RTN","RORERR10",55,0)
010505 ;; 6 ^PID^  5^ Non-alphabetic characters in Middle Initial or Name
"RTN","RORERR10",56,0)
010506 ;; 6 ^PID^  5^ Middle Initial or Name longer than 25 characters
"RTN","RORERR10",57,0)
010701 ;; 6 ^PID^  7^ Non-numeric Date of Birth
"RTN","RORERR10",58,0)
010702 ;; 6 ^PID^  7^ Date of Birth formatted incorrectly
"RTN","RORERR10",59,0)
010801 ;; 6 ^PID^  8^ Invalid Sex value
"RTN","RORERR10",60,0)
011001 ;; 6 ^PID^ 10^ Invalid Race indicator
"RTN","RORERR10",61,0)
011002 ;; 6 ^PID^ 10^ Invalid Race Collection Method
"RTN","RORERR10",62,0)
011101 ;; 6 ^PID^ 11^ Invalid Zip Code length
"RTN","RORERR10",63,0)
011102 ;; 6 ^PID^ 11^ Zip Code contains non-numeric characters
"RTN","RORERR10",64,0)
011901 ;; 6 ^PID^ 19^ Non-numeric SSN
"RTN","RORERR10",65,0)
011902 ;; 6 ^PID^ 19^ SSN longer than 9 characters
"RTN","RORERR10",66,0)
011903 ;; 6 ^PID^ 19^ SSN shorter than 9 characters
"RTN","RORERR10",67,0)
011904 ;; 6 ^PID^ 19^ Invalid Pseudo SSN indicator
"RTN","RORERR10",68,0)
012201 ;; 6 ^PID^ 22^ Invalid Ethnicity indicator
"RTN","RORERR10",69,0)
012202 ;; 6 ^PID^ 22^ Invalid Ethnicity collection method
"RTN","RORERR10",70,0)
012901 ;; 6 ^PID^ 29^ Non-numeric Date of Death
"RTN","RORERR10",71,0)
012902 ;; 6 ^PID^ 29^ Date of Death formatted incorrectly
"RTN","RORERR10",72,0)
020201 ;; 6 ^ZSP^  2^ Service Connected Indicator invalid
"RTN","RORERR10",73,0)
020301 ;; 6 ^ZSP^  3^ Service Connected Combined % value non-numeric
"RTN","RORERR10",74,0)
020302 ;; 6 ^ZSP^  3^ Service Connected Combined % over 100
"RTN","RORERR10",75,0)
020401 ;; 6 ^ZSP^  4^ Veteran Era of Service is non alphanumeric
"RTN","RORERR10",76,0)
020402 ;; 6 ^ZSP^  4^ Veteran Era of Service longer than 1 character
"RTN","RORERR10",77,0)
030201 ;; 6 ^ZRD^  2^ Service Connected Codes (Rated Disability) out of bounds
"RTN","RORERR10",78,0)
030301 ;; 6 ^ZRD^  3^ Service Connected % value non-numeric
"RTN","RORERR10",79,0)
030302 ;; 6 ^ZRD^  3^ Service Connected % over 100
"RTN","RORERR10",80,0)
040101 ;; 6 ^CSR^  1^ Registry identifier contains non-alphanumeric characters
"RTN","RORERR10",81,0)
040102 ;; 6 ^CSR^  1^ Registry identifier longer than 30 characters
"RTN","RORERR10",82,0)
040103 ;; 6 ^CSR^  1^ Registry identifier shorter than 3 characters
"RTN","RORERR10",83,0)
040301 ;; 6 ^CSR^  3^ Non-numeric Station number
"RTN","RORERR10",84,0)
040302 ;; 6 ^CSR^  3^ Station longer than 3 characters
"RTN","RORERR10",85,0)
040401 ;; 6 ^CSR^  4^ Non-numeric DFN
"RTN","RORERR10",86,0)
040601 ;; 6 ^CSR^  6^ Date entered into registry has invalid format
"RTN","RORERR10",87,0)
040901 ;; 6 ^CSR^  9^ Date of AIDS (Cat 4) has invalid format
"RTN","RORERR10",88,0)
041001 ;; 6 ^CSR^ 10^ Invalid Hep C supporting evidence field
"RTN","RORERR10",89,0)
041101 ;; 6 ^CSR^ 11^ Date CDC form complete has invalid format
"RTN","RORERR10",90,0)
041201 ;; 6 ^CSR^ 12^ Invalid Risk Factor
"RTN","RORERR10",91,0)
041401 ;; 6 ^CSR^ 14^ Investigational drugs/Medication in profile indicator non-numeric
"RTN","RORERR10",92,0)
041402 ;; 6 ^CSR^ 14^ Investigational drugs/Medication in profile indicator contains too many characters
"RTN","RORERR10",93,0)
041501 ;; 6 ^CSR^ 15^ Inactivation date has invalid format
"RTN","RORERR10",94,0)
041601 ;; 6 ^CSR^ 16^ Invalid Hep C reason for inactivation
"RTN","RORERR11")
0^82^B62772035
"RTN","RORERR11",1,0)
RORERR11 ;HCIOFO/SG - AAC ERROR MESSAGES (050000-100000)  ; 5/12/03 8:53am
"RTN","RORERR11",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORERR11",3,0)
 ;
"RTN","RORERR11",4,0)
 ; Messages with codes less than 050000 are located
"RTN","RORERR11",5,0)
 ; in the ^RORERR10 routine.
"RTN","RORERR11",6,0)
 ;
"RTN","RORERR11",7,0)
 ; Messages with codes greater than 100000 are located
"RTN","RORERR11",8,0)
 ; in the ^RORERR12 routine.
"RTN","RORERR11",9,0)
 ;
"RTN","RORERR11",10,0)
 Q
"RTN","RORERR11",11,0)
 ;
"RTN","RORERR11",12,0)
 ;***** LIST OF THE MESSAGES (THERE SHOULD BE NOTHING AFTER THE LIST!)
"RTN","RORERR11",13,0)
 ;
"RTN","RORERR11",14,0)
 ; Message Type:
"RTN","RORERR11",15,0)
 ;               1  Debug          4  Warning
"RTN","RORERR11",16,0)
 ;               2  Information    5  Database Error
"RTN","RORERR11",17,0)
 ;               3  Data Quality   6  Error
"RTN","RORERR11",18,0)
 ;
"RTN","RORERR11",19,0)
 ;Type Seg Fld  Message Text
"RTN","RORERR11",20,0)
050101 ;; 6 ^CSP^  1^ Invalid new patient field
"RTN","RORERR11",21,0)
050201 ;; 6 ^CSP^  2^ Reactivation date has invalid format
"RTN","RORERR11",22,0)
060201 ;; 6 ^CSS^  2^ Date of last extraction has invalid format
"RTN","RORERR11",23,0)
070301 ;; 6 ^ORC^  3^ Released date/time has invalid format
"RTN","RORERR11",24,0)
071201 ;; 6 ^ORC^ 12^ Non-integer provider ID
"RTN","RORERR11",25,0)
071202 ;; 6 ^ORC^ 12^ Invalid Provider Class Code
"RTN","RORERR11",26,0)
071501 ;; 6 ^ORC^ 15^ Reactivation date has invalid format
"RTN","RORERR11",27,0)
071701 ;; 6 ^ORC^ 17^ Station has invalid length
"RTN","RORERR11",28,0)
071702 ;; 6 ^ORC^ 17^ Station contains non-alphanumeric characters
"RTN","RORERR11",29,0)
080101 ;; 6 ^RXE^  1^ Invalid Schedule
"RTN","RORERR11",30,0)
080201 ;; 6 ^RXE^  2^ NDC code has invalid length
"RTN","RORERR11",31,0)
080202 ;; 6 ^RXE^  2^ Drug name has invalid length
"RTN","RORERR11",32,0)
080203 ;; 6 ^RXE^  2^ VA Drug class has invalid length
"RTN","RORERR11",33,0)
080204 ;; 6 ^RXE^  2^ VA Product name has an invalid length
"RTN","RORERR11",34,0)
080205 ;; 6 ^RXE^  2^ VA drug code out of range
"RTN","RORERR11",35,0)
080401 ;; 6 ^RXE^  4^ Invalid Maximum Number of Refills
"RTN","RORERR11",36,0)
080601 ;; 6 ^RXE^  6^ Invalid Refill Release Date and Time
"RTN","RORERR11",37,0)
080701 ;; 6 ^RXE^  7^ SIG has invalid length
"RTN","RORERR11",38,0)
081001 ;; 6 ^RXE^ 10^ Amount value below valid range
"RTN","RORERR11",39,0)
081002 ;; 6 ^RXE^ 10^ Amount has invalid length
"RTN","RORERR11",40,0)
081003 ;; 6 ^RXE^ 10^ Amount can only have 2 decimal places
"RTN","RORERR11",41,0)
081004 ;; 6 ^RXE^ 10^ Invalid integer value
"RTN","RORERR11",42,0)
081701 ;; 6 ^RXE^ 17^ Invalid Refill Number
"RTN","RORERR11",43,0)
081801 ;; 6 ^RXE^ 18^ Fill date/time has invalid format
"RTN","RORERR11",44,0)
081802 ;; 6 ^RXE^ 18^ Stop date/time has invalid format
"RTN","RORERR11",45,0)
081901 ;; 6 ^RXE^ 19^ Days supply has invalid length
"RTN","RORERR11",46,0)
082001 ;; 6 ^RXE^ 20^ Invalid CMOP indicator
"RTN","RORERR11",47,0)
082101 ;; 6 ^RXE^ 21^ Invalid Clinic Stop Code
"RTN","RORERR11",48,0)
082102 ;; 6 ^RXE^ 21^ Invalid Medication Route
"RTN","RORERR11",49,0)
082201 ;; 6 ^RXE^ 22^ Invalid Last Dispensed Date
"RTN","RORERR11",50,0)
082301 ;; 6 ^RXE^ 23^ Invalid Unit Cost
"RTN","RORERR11",51,0)
082401 ;; 6 ^RXE^ 24^ Non-numeric unit/dose
"RTN","RORERR11",52,0)
082402 ;; 6 ^RXE^ 24^ Unit/dose value out of range
"RTN","RORERR11",53,0)
082403 ;; 6 ^RXE^ 24^ Unit/dose can only have 2 decimal places
"RTN","RORERR11",54,0)
082701 ;; 6 ^RXE^ 27^ Invalid Patient Status
"RTN","RORERR11",55,0)
083001 ;; 6 ^RXE^ 30^ Invalid Mail/Window code
"RTN","RORERR11",56,0)
090301 ;; 6 ^OBR^  3^ Invalid Surgical Pathology Accession Number
"RTN","RORERR11",57,0)
090302 ;; 6 ^OBR^  3^ Invalid Cytopathology Accession Number
"RTN","RORERR11",58,0)
090303 ;; 6 ^OBR^  3^ Invalid Autopsy Accession Number
"RTN","RORERR11",59,0)
090304 ;; 6 ^OBR^  3^ Invalid Radiology Case Number
"RTN","RORERR11",60,0)
090305 ;; 6 ^OBR^  3^ Invalid Lab Accession Number
"RTN","RORERR11",61,0)
090306 ;; 6 ^OBR^  3^ Invalid Lab Name of Test
"RTN","RORERR11",62,0)
090307 ;; 6 ^OBR^  3^ Invalid Microbiology Accession Number
"RTN","RORERR11",63,0)
090308 ;; 6 ^OBR^  3^ Invalid Medical Procedures ID
"RTN","RORERR11",64,0)
090309 ;; 6 ^OBR^  3^ Invalid Allergy IEN
"RTN","RORERR11",65,0)
090310 ;; 6 ^OBR^  3^ Invalid IV Order Number
"RTN","RORERR11",66,0)
090311 ;; 6 ^OBR^  3^ Invalid Problem File NMBR
"RTN","RORERR11",67,0)
090401 ;; 6 ^OBR^  4^ Radiology CPT code does not exist on the CPT-4 Procedure Code File
"RTN","RORERR11",68,0)
090402 ;; 6 ^OBR^  4^ CPT-4 Procedure code longer than 5 characters
"RTN","RORERR11",69,0)
090403 ;; 6 ^OBR^  4^ CPT-4 Procedure code less than 5 characters
"RTN","RORERR11",70,0)
090404 ;; 6 ^OBR^  4^ Invalid procedure code type for CPT-4
"RTN","RORERR11",71,0)
090406 ;; 6 ^OBR^  4^ NLT code shorter than 5 characters
"RTN","RORERR11",72,0)
090407 ;; 6 ^OBR^  4^ NLT code longer than 15 characters
"RTN","RORERR11",73,0)
090408 ;; 6 ^OBR^  4^ Invalid Procedure Name
"RTN","RORERR11",74,0)
090409  ;; 6 ^OBR^  4^ Invalid Vitals Indicator
"RTN","RORERR11",75,0)
090601 ;; 6 ^OBR^  6^ Invalid Medical Procedure Date (RDX)
"RTN","RORERR11",76,0)
090602 ;; 6 ^OBR^  6^ Invalid Problem List Date Entered
"RTN","RORERR11",77,0)
090701 ;; 6 ^OBR^  7^ Liver Biopsy date has invalid format
"RTN","RORERR11",78,0)
090702 ;; 6 ^OBR^  7^ Autopsy date has invalid format
"RTN","RORERR11",79,0)
090703 ;; 6 ^OBR^  7^ Exam date has invalid format
"RTN","RORERR11",80,0)
090704 ;; 6 ^OBR^  7^ Accession date has invalid format
"RTN","RORERR11",81,0)
090705 ;; 6 ^OBR^  7^ Invalid Date of Visit
"RTN","RORERR11",82,0)
090706 ;; 6 ^OBR^  7^ Invalid Surgical Pathology Date
"RTN","RORERR11",83,0)
090707 ;; 6 ^OBR^  7^ Invalid Cytopathology Date
"RTN","RORERR11",84,0)
090708 ;; 6 ^OBR^  7^ Invalid Microbiology Accession Date
"RTN","RORERR11",85,0)
090709 ;; 6 ^OBR^  7^ Invalid Medical Procedures Auto Instrument Data
"RTN","RORERR11",86,0)
090710 ;; 6 ^OBR^  7^ Invalid Allergy Origination Date
"RTN","RORERR11",87,0)
090711 ;; 6 ^OBR^  7^ Invalid IV Start Date
"RTN","RORERR11",88,0)
090712 ;; 6 ^OBR^  7^ Invalid Problem List Date of Onset
"RTN","RORERR11",89,0)
090801 ;; 6 ^OBR^  8^ Invalid Surgical Pathology Date report Completed
"RTN","RORERR11",90,0)
090802 ;; 6 ^OBR^  8^ Invalid IV Stop Date
"RTN","RORERR11",91,0)
090803 ;; 6 ^OBR^  8^ Invalid Problem List Date Resolved
"RTN","RORERR11",92,0)
091101 ;; 6 ^OBR^ 11^ Invalid Microbiology Urine Screen
"RTN","RORERR11",93,0)
091301 ;; 6 ^OBR^ 13^ Invalid Microbiology Source
"RTN","RORERR11",94,0)
091302 ;; 6 ^OBR^ 13^ Invalid Allergy Reactant
"RTN","RORERR11",95,0)
091303 ;; 6 ^OBR^ 13^ Invalid IV Schedule
"RTN","RORERR11",96,0)
091304 ;; 6 ^OBR^ 13^ Invalid Problem List Diagnosis
"RTN","RORERR11",97,0)
091401 ;; 6 ^OBR^ 14^ Invalid Problem List Date Recorded
"RTN","RORERR11",98,0)
091601 ;; 6 ^OBR^ 16^ Non-integer provider ID
"RTN","RORERR11",99,0)
091602 ;; 6 ^OBR^ 16^ Invalid Surgical Pathology Physician
"RTN","RORERR11",100,0)
091603 ;; 6 ^OBR^ 16^ Invalid Radiology Person Class Code
"RTN","RORERR11",101,0)
091604 ;; 6 ^OBR^ 16^ Invalid Allergy Originator
"RTN","RORERR11",102,0)
091605 ;; 6 ^OBR^ 16^ Invalid Allergy Originator Class Code
"RTN","RORERR11",103,0)
091606 ;; 6 ^OBR^ 16^ Invalid Problem List Recording Provider
"RTN","RORERR11",104,0)
091607 ;; 6 ^OBR^ 16^ Invalid Problem List Recording Provider VA Class
"RTN","RORERR11",105,0)
092001 ;; 6 ^OBR^ 20^ Invalid Sample Type
"RTN","RORERR11",106,0)
092002 ;; 6 ^OBR^ 20^ Invalid Allergy Type
"RTN","RORERR11",107,0)
092003 ;; 6 ^OBR^ 20^ Invalid IV Infusion Rate
"RTN","RORERR11",108,0)
092101 ;; 6 ^OBR^ 21^ Invalid Microbiology Sputum Screen
"RTN","RORERR11",109,0)
092201 ;; 6 ^OBR^ 22^ Invalid Problem List Date Last Modified
"RTN","RORERR11",110,0)
092501 ;; 6 ^OBR^ 25^ Invalid Microbiology Sterility Control
"RTN","RORERR11",111,0)
092502 ;; 6 ^OBR^ 25^ Invalid Medical Procedures Confirmation Status
"RTN","RORERR11",112,0)
092503 ;; 6 ^OBR^ 25^ Invalid Allergy Observed/Historical
"RTN","RORERR11",113,0)
092504 ;; 6 ^OBR^ 25^ Invalid Problem List Status
"RTN","RORERR11",114,0)
094001 ;; 6 ^OBR^ 40^ Invalid IV Type 
"RTN","RORERR11",115,0)
094401 ;; 6 ^OBR^ 44^ Liver Biopsy station non-alphanumeric
"RTN","RORERR11",116,0)
094402 ;; 6 ^OBR^ 44^ Liver Biopsy station less than 3 characters long
"RTN","RORERR11",117,0)
094403 ;; 6 ^OBR^ 44^ Liver Biopsy station longer than 7 characters long
"RTN","RORERR11",118,0)
094404 ;; 6 ^OBR^ 44^ Autopsy station non-alphanumeric
"RTN","RORERR11",119,0)
094405 ;; 6 ^OBR^ 44^ Autopsy station less than 3 characters long
"RTN","RORERR11",120,0)
094406 ;; 6 ^OBR^ 44^ Autopsy station longer than 7 characters long
"RTN","RORERR11",121,0)
094407 ;; 6 ^OBR^ 44^ Radiology station non-alphanumeric
"RTN","RORERR11",122,0)
094408 ;; 6 ^OBR^ 44^ Radiology station less than 3 characters long
"RTN","RORERR11",123,0)
094409 ;; 6 ^OBR^ 44^ Radiology station longer than 7 characters long
"RTN","RORERR11",124,0)
094410 ;; 6 ^OBR^ 44^ Lab station non-alphanumeric
"RTN","RORERR11",125,0)
094411 ;; 6 ^OBR^ 44^ Lab station less than 3 characters long
"RTN","RORERR11",126,0)
094412 ;; 6 ^OBR^ 44^ Lab station longer than 7 characters long
"RTN","RORERR11",127,0)
094413 ;; 6 ^OBR^ 44^ Surgical Pathology station non-alphanumeric
"RTN","RORERR11",128,0)
094414 ;; 6 ^OBR^ 44^ Surgical Pathology station less than 3 characters long
"RTN","RORERR11",129,0)
094415 ;; 6 ^OBR^ 44^ Surgical Pathology station longer than 7 characters long
"RTN","RORERR11",130,0)
094416 ;; 6 ^OBR^ 44^ Cytopathology station non-alphanumeric
"RTN","RORERR11",131,0)
094417 ;; 6 ^OBR^ 44^ Cytopathology station less than 3 characters long
"RTN","RORERR11",132,0)
094418 ;; 6 ^OBR^ 44^ Cytopathology station longer than 7 characters long
"RTN","RORERR11",133,0)
094419 ;; 6 ^OBR^ 44^ Microbiology station non-alphanumeric
"RTN","RORERR11",134,0)
094420 ;; 6 ^OBR^ 44^ Microbiology station less than 3 characters long
"RTN","RORERR11",135,0)
094421 ;; 6 ^OBR^ 44^ Microbiology station longer than 7 characters long
"RTN","RORERR11",136,0)
094422 ;; 6 ^OBR^ 44^ Medical Procedures station non-alphanumeric
"RTN","RORERR11",137,0)
094423 ;; 6 ^OBR^ 44^ Medical Procedures station less than 3 characters long
"RTN","RORERR11",138,0)
094424 ;; 6 ^OBR^ 44^ Medical Procedures longer than 7 characters long
"RTN","RORERR11",139,0)
094425 ;; 6 ^OBR^ 44^ IV station non-alphanumeric
"RTN","RORERR11",140,0)
094426 ;; 6 ^OBR^ 44^ IV station less than 3 characters long
"RTN","RORERR11",141,0)
094427 ;; 6 ^OBR^ 44^ IV longer than 7 characters long
"RTN","RORERR12")
0^83^B41180056
"RTN","RORERR12",1,0)
RORERR12 ;HCIOFO/SG - AAC ERROR MESSAGES (100000-150000)  ; 5/12/03 8:53am
"RTN","RORERR12",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORERR12",3,0)
 ;
"RTN","RORERR12",4,0)
 ; Messages with codes less than 100000 are located
"RTN","RORERR12",5,0)
 ; in the ^RORERR11 routine.
"RTN","RORERR12",6,0)
 ;
"RTN","RORERR12",7,0)
 Q
"RTN","RORERR12",8,0)
 ;
"RTN","RORERR12",9,0)
 ;***** LIST OF THE MESSAGES (THERE SHOULD BE NOTHING AFTER THE LIST!)
"RTN","RORERR12",10,0)
 ;
"RTN","RORERR12",11,0)
 ; Message Type:
"RTN","RORERR12",12,0)
 ;               1  Debug          4  Warning
"RTN","RORERR12",13,0)
 ;               2  Information    5  Database Error
"RTN","RORERR12",14,0)
 ;               3  Data Quality   6  Error
"RTN","RORERR12",15,0)
 ;
"RTN","RORERR12",16,0)
 ;Type Seg Fld  Message Text
"RTN","RORERR12",17,0)
100301 ;; 6 ^OBX^  3^ Code does not exist within Loinc table
"RTN","RORERR12",18,0)
100302 ;; 6 ^OBX^  3^ NLT code shorter than 5 characters
"RTN","RORERR12",19,0)
100303 ;; 6 ^OBX^  3^ NLT code longer than 15 characters
"RTN","RORERR12",20,0)
100304 ;; 6 ^OBX^  3^ Invalid Vital Type
"RTN","RORERR12",21,0)
100401 ;; 6 ^OBX^  4^ Code Modifier
"RTN","RORERR12",22,0)
100402 ;; 6 ^OBX^  4^ Invalid Note Facility
"RTN","RORERR12",23,0)
100403 ;; 6 ^OBX^  4^ Invalid Note Number
"RTN","RORERR12",24,0)
100404 ;; 6 ^OBX^  4^ Invalid Note Status
"RTN","RORERR12",25,0)
100405  ;; 6 ^OBX^  4^ Invalid IEN
"RTN","RORERR12",26,0)
100501 ;; 6 ^OBX^  5^ Result longer than 60 characters
"RTN","RORERR12",27,0)
100502 ;; 6 ^OBX^  5^ Invalid ICD code
"RTN","RORERR12",28,0)
100503 ;; 6 ^OBX^  5^ Invalid CPT code
"RTN","RORERR12",29,0)
100504 ;; 6 ^OBX^  5^ Invalid Admission Diagnosis
"RTN","RORERR12",30,0)
100505 ;; 6 ^OBX^  5^ Invalid Primary Discharge Diagnosis
"RTN","RORERR12",31,0)
100506 ;; 6 ^OBX^  5^ Invalid Discharge Diagnosis Code(s)
"RTN","RORERR12",32,0)
100507 ;; 6 ^OBX^  5^ Invalid Bed Section Diagnosis Code(s)
"RTN","RORERR12",33,0)
100508 ;; 6 ^OBX^  5^ Invalid Surgical Procedure Code(s)
"RTN","RORERR12",34,0)
100509 ;; 6 ^OBX^  5^ Invalid Other Procedure Code(s)
"RTN","RORERR12",35,0)
100510 ;; 6 ^OBX^  5^ Invalid Surgical Pathology Specimen
"RTN","RORERR12",36,0)
100511 ;; 6 ^OBX^  5^ Invalid Surgical Pathology Brief Clinical History
"RTN","RORERR12",37,0)
100512 ;; 6 ^OBX^  5^ Invalid Surgical Pathology Preoperative Diagnosis
"RTN","RORERR12",38,0)
100513 ;; 6 ^OBX^  5^ Invalid Surgical Pathology Operative Findings
"RTN","RORERR12",39,0)
100514 ;; 6 ^OBX^  5^ Invalid Surgical Pathology Postoperative Findings
"RTN","RORERR12",40,0)
100515 ;; 6 ^OBX^  5^ Invalid Surgical Pathology Gross Description 
"RTN","RORERR12",41,0)
100516 ;; 6 ^OBX^  5^ Invalid Surgical Pathology Microscopic Description
"RTN","RORERR12",42,0)
100517 ;; 6 ^OBX^  5^ Invalid Surgical Pathology Diagnosis
"RTN","RORERR12",43,0)
100518 ;; 6 ^OBX^  5^ Invalid Surgical Pathology ICD Diagnosis
"RTN","RORERR12",44,0)
100519 ;; 6 ^OBX^  5^ Invalid Cytopathology Specimen
"RTN","RORERR12",45,0)
100520 ;; 6 ^OBX^  5^ Invalid Cytopathology Brief Clinical History
"RTN","RORERR12",46,0)
100521 ;; 6 ^OBX^  5^ Invalid Cytopathology Preoperative Diagnosis
"RTN","RORERR12",47,0)
100522 ;; 6 ^OBX^  5^ Invalid Cytopathology Operative Findings
"RTN","RORERR12",48,0)
100523 ;; 6 ^OBX^  5^ Invalid Cytopathology Postoperative Findings
"RTN","RORERR12",49,0)
100524 ;; 6 ^OBX^  5^ Invalid Microscopic Examination
"RTN","RORERR12",50,0)
100525 ;; 6 ^OBX^  5^ Invalid Cytopathology ICD Diagnosis
"RTN","RORERR12",51,0)
100526 ;; 6 ^OBX^  5^ Invalid Radiology Report Text
"RTN","RORERR12",52,0)
100527 ;; 6 ^OBX^  5^ Invalid Radiology Impression Text
"RTN","RORERR12",53,0)
100528 ;; 6 ^OBX^  5^ Invalid Radiology Clinical History
"RTN","RORERR12",54,0)
100529 ;; 6 ^OBX^  5^ Invalid Lab Comments
"RTN","RORERR12",55,0)
100530 ;; 6 ^OBX^  5^ Invalid Microbiology Bact RPT Remark
"RTN","RORERR12",56,0)
100531 ;; 6 ^OBX^  5^ Invalid Microbiology Gram Stain
"RTN","RORERR12",57,0)
100532 ;; 6 ^OBX^  5^ Invalid Microbiology Organism
"RTN","RORERR12",58,0)
100533 ;; 6 ^OBX^  5^ Invalid Microbiology ORGCOM Comment
"RTN","RORERR12",59,0)
100534 ;; 6 ^OBX^  5^ Invalid Microbiology Antibiotic
"RTN","RORERR12",60,0)
100535 ;; 6 ^OBX^  5^ Invalid Microbiology Parasite
"RTN","RORERR12",61,0)
100536 ;; 6 ^OBX^  5^ Invalid Microbiology Stage Codes
"RTN","RORERR12",62,0)
100537 ;; 6 ^OBX^  5^ Invalid Microbiology Parasite Comment
"RTN","RORERR12",63,0)
100538 ;; 6 ^OBX^  5^ Invalid Microbiology Parasite RPT Remark
"RTN","RORERR12",64,0)
100539 ;; 6 ^OBX^  5^ Invalid Microbiology Specimen Comment
"RTN","RORERR12",65,0)
100540 ;; 6 ^OBX^  5^ Invalid Medical Procedures Auto Instrument Diagnosis
"RTN","RORERR12",66,0)
100541 ;; 6 ^OBX^  5^ Invalid Medical Procedures Interpretation (Rhythm)
"RTN","RORERR12",67,0)
100542 ;; 6 ^OBX^  5^ Invalid Allergy Drug Ingredients
"RTN","RORERR12",68,0)
100543 ;; 6 ^OBX^  5^ Invalid Allergy VA Drug Class
"RTN","RORERR12",69,0)
100544 ;; 6 ^OBX^  5^ Invalid Allergy Reactions
"RTN","RORERR12",70,0)
100545 ;; 6 ^OBX^  5^ Invalid IV Other Print Info 
"RTN","RORERR12",71,0)
100546 ;; 6 ^OBX^  5^ Invalid IV Additive
"RTN","RORERR12",72,0)
100547 ;; 6 ^OBX^  5^ Invalid IV Solution
"RTN","RORERR12",73,0)
100548 ;; 6 ^OBX^  5^ Invalid Cytopathology Diagnosis
"RTN","RORERR12",74,0)
100549 ;; 6 ^OBX^  5^ Invalid Problem List Provider Narative
"RTN","RORERR12",75,0)
100550 ;; 6 ^OBX^  5^ Invalid Problem List Problem (Expression)
"RTN","RORERR12",76,0)
100551 ;; 6 ^OBX^  5^ Invalid Problem List Note Narrative
"RTN","RORERR12",77,0)
100552  ;; 6 ^OBX^  5^ Invalid Vitals Rate
"RTN","RORERR12",78,0)
100553  ;; 6 ^OBX^  5^ Invalid Vitals Quality
"RTN","RORERR12",79,0)
100554  ;; 6 ^OBX^  5^ Invalid Vitals Qualifiers
"RTN","RORERR12",80,0)
100601 ;; 6 ^OBX^  6^ Units shorter than 2 characters
"RTN","RORERR12",81,0)
100602 ;; 6 ^OBX^  6^ Units longer than 10 characters
"RTN","RORERR12",82,0)
100603 ;; 6 ^OBX^  6^ Invalid Bed Section
"RTN","RORERR12",83,0)
100604 ;; 6 ^OBX^  6^ Invalid Bed Section/Specialty of Other Procedures
"RTN","RORERR12",84,0)
100605 ;; 6 ^OBX^  6^ Invalid Microbiology Organism Quantity
"RTN","RORERR12",85,0)
100606 ;; 6 ^OBX^  6^ Invalid Microbiology Parasite Quantity
"RTN","RORERR12",86,0)
100607  ;; 6 ^OBX^  6^ Invalid Vitals Unit 
"RTN","RORERR12",87,0)
100701 ;; 6 ^OBX^  7^ Range High longer than 50 characters
"RTN","RORERR12",88,0)
100702 ;; 6 ^OBX^  7^ Range Low longer than 50 characters
"RTN","RORERR12",89,0)
100703 ;; 6 ^OBX^  7^ Invalid Microbiology Antibiotic Mic/Mbc
"RTN","RORERR12",90,0)
100704 ;; 6 ^OBX^  7^ Invalid IV Additive Strength
"RTN","RORERR12",91,0)
100705 ;; 6 ^OBX^  7^ Invalid IV Solution Volume
"RTN","RORERR12",92,0)
100706  ;; 6 ^OBX^  7^ Invalid Vitals Body Mass
"RTN","RORERR12",93,0)
100801 ;; 6 ^OBX^  8^ Invalid Lab Flag on Values
"RTN","RORERR12",94,0)
101201 ;; 6 ^OBX^ 12^ Invalid Bed Section End Date
"RTN","RORERR12",95,0)
101202 ;; 6 ^OBX^ 12^ Invalid Reactions Date Entered
"RTN","RORERR12",96,0)
101401 ;; 6 ^OBX^ 14^ Invalid Bed Section Start Date
"RTN","RORERR12",97,0)
101402 ;; 6 ^OBX^ 14^ Invalid Date of Surgical Procedure
"RTN","RORERR12",98,0)
101403 ;; 6 ^OBX^ 14^ Invalid Date of Other Procedures
"RTN","RORERR12",99,0)
101404  ;; 6 ^OBX^ 14^ Invalid Date of Measurement
"RTN","RORERR12",100,0)
101501 ;; 6 ^OBX^ 15^ Site/specimen shorter than 2 characters
"RTN","RORERR12",101,0)
101502 ;; 6 ^OBX^ 15^ Site/specimen longer than 80 characters
"RTN","RORERR12",102,0)
101601 ;; 6 ^OBX^ 16^ Invalid CPT Procedure Provider
"RTN","RORERR12",103,0)
101602 ;; 6 ^OBX^ 16^ Invalid CPT Provider Class
"RTN","RORERR12",104,0)
110301 ;; 6 ^NTE^  3^ Comment shorter than 1 character
"RTN","RORERR12",105,0)
110302 ;; 6 ^NTE^  3^ Comment longer than 68 characters
"RTN","RORERR12",106,0)
120301 ;; 6 ^PV1^  3^ Non-numeric Station number
"RTN","RORERR12",107,0)
120302 ;; 6 ^PV1^  3^ Station longer than 3 characters
"RTN","RORERR12",108,0)
120303 ;; 6 ^PV1^  3^ Invalid AMIS Clinic Stop Code
"RTN","RORERR12",109,0)
120401 ;; 6 ^PV1^  4^ Invalid Encounter Type
"RTN","RORERR12",110,0)
120601 ;; 6 ^PV1^  6^ Invalid Bed Section at Discharge Date
"RTN","RORERR12",111,0)
120701 ;; 6 ^PV1^  7^ Invalid Provider code
"RTN","RORERR12",112,0)
120702 ;; 6 ^PV1^  7^ Invalid Provider Class
"RTN","RORERR12",113,0)
123601 ;; 6 ^PV1^ 36^ Invalid Type of Disposition 
"RTN","RORERR12",114,0)
124401 ;; 6 ^PV1^ 44^ Invalid Date of Visit
"RTN","RORERR12",115,0)
124501 ;; 6 ^PV1^ 45^ Invalid Discharge Date
"RTN","RORERR12",116,0)
125101 ;; 6 ^PV1^ 51^ Invalid Delete Code
"RTN","RORERR20")
0^7^B58895933
"RTN","RORERR20",1,0)
RORERR20 ;HCIOFO/SG - LIST OF ERROR MESSAGES  ; 1/13/04 3:29pm
"RTN","RORERR20",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3,5**;May 14, 2002
"RTN","RORERR20",3,0)
 ;
"RTN","RORERR20",4,0)
 Q
"RTN","RORERR20",5,0)
 ;
"RTN","RORERR20",6,0)
 ;***** RETURNS THE TEXT OF THE MESSAGE
"RTN","RORERR20",7,0)
 ;
"RTN","RORERR20",8,0)
 ; ERRCODE       Error code
"RTN","RORERR20",9,0)
 ; [.TYPE]       Type of the error
"RTN","RORERR20",10,0)
 ; [ARG1-ARG5]   Optional parameters that substitute the |n| "windows"
"RTN","RORERR20",11,0)
 ;               in the text of the message (for example, the |2| will
"RTN","RORERR20",12,0)
 ;               be substituted by the value of the ARG2).
"RTN","RORERR20",13,0)
 ;
"RTN","RORERR20",14,0)
MSG(ERRCODE,TYPE,ARG1,ARG2,ARG3,ARG4,ARG5) ;
"RTN","RORERR20",15,0)
 S TYPE=6  Q:ERRCODE'<0 ""
"RTN","RORERR20",16,0)
 N ARG,I1,I2,MSG
"RTN","RORERR20",17,0)
 ;--- Get a descriptor of the message
"RTN","RORERR20",18,0)
 S I1=-ERRCODE,MSG=$P($T(MSGLIST+I1),";;",2)
"RTN","RORERR20",19,0)
 S I1=+$TR($P(MSG,U,2)," "),MSG=$P(MSG,U,3,999)
"RTN","RORERR20",20,0)
 S:I1>0 TYPE=I1
"RTN","RORERR20",21,0)
 Q:MSG?." " "Unknown error ("_ERRCODE_")"
"RTN","RORERR20",22,0)
 ;--- Substitute parameters
"RTN","RORERR20",23,0)
 S I1=2
"RTN","RORERR20",24,0)
 F  S I1=$F(MSG,"|",I1-1)  Q:'I1  D
"RTN","RORERR20",25,0)
 . S I2=$F(MSG,"|",I1)  Q:'I2
"RTN","RORERR20",26,0)
 . X "S ARG=$G(ARG"_+$TR($E(MSG,I1,I2-2)," ")_")"
"RTN","RORERR20",27,0)
 . S $E(MSG,I1-1,I2-1)=ARG
"RTN","RORERR20",28,0)
 Q $$TRIM^XLFSTR(MSG)
"RTN","RORERR20",29,0)
 ;
"RTN","RORERR20",30,0)
 ;***** RETURNS TYPE OF THE MESSAGE
"RTN","RORERR20",31,0)
 ;
"RTN","RORERR20",32,0)
 ; ERRCODE       Error code
"RTN","RORERR20",33,0)
 ;
"RTN","RORERR20",34,0)
TYPE(ERRCODE) ;
"RTN","RORERR20",35,0)
 Q:ERRCODE'<0 0
"RTN","RORERR20",36,0)
 N I,TYPE  S I=-ERRCODE
"RTN","RORERR20",37,0)
 S I=$P($T(MSGLIST+I),";;",2),TYPE=+$TR($P(I,U,2)," ")
"RTN","RORERR20",38,0)
 Q $S(TYPE>0:TYPE,1:6)
"RTN","RORERR20",39,0)
 ;
"RTN","RORERR20",40,0)
 ;***** LIST OF THE MESSAGES (THERE SHOULD BE NOTHING AFTER THE LIST!)
"RTN","RORERR20",41,0)
 ;
"RTN","RORERR20",42,0)
 ; The error codes are provided in the table only for clarity.
"RTN","RORERR20",43,0)
 ; Text of the messages are extracted using the $TEXT function and
"RTN","RORERR20",44,0)
 ; absolute values of the ERRCODE parameter.
"RTN","RORERR20",45,0)
 ;
"RTN","RORERR20",46,0)
 ; Message Type:
"RTN","RORERR20",47,0)
 ;               1  Debug          4  Warning
"RTN","RORERR20",48,0)
 ;               2  Information    5  Database Error
"RTN","RORERR20",49,0)
 ;               3  Data Quality   6  Error
"RTN","RORERR20",50,0)
 ;
"RTN","RORERR20",51,0)
MSGLIST ; Code Type  Message Text
"RTN","RORERR20",52,0)
 ;;  -1 ^ 6 ^ Cannot find a descriptor of the registry
"RTN","RORERR20",53,0)
 ;;  -2 ^ 6 ^ Duplicate registry names
"RTN","RORERR20",54,0)
 ;;  -3 ^ 6 ^ Cannot find a descriptor of the rule
"RTN","RORERR20",55,0)
 ;;  -4 ^ 6 ^ Duplicate rule names
"RTN","RORERR20",56,0)
 ;;  -5 ^ 6 ^ Circle rule references
"RTN","RORERR20",57,0)
 ;;  -6 ^ 6 ^ Invalid update entry point: |2|
"RTN","RORERR20",58,0)
 ;;  -7 ^ 6 ^ Field '|2|' not found
"RTN","RORERR20",59,0)
 ;;  -8 ^ 6 ^ Duplicate patients in the registry
"RTN","RORERR20",60,0)
 ;;  -9 ^ 5 ^ FileMan DBS call error(s)|2|
"RTN","RORERR20",61,0)
 ;; -10 ^ 6 ^ Bad registry name: '|2|'
"RTN","RORERR20",62,0)
 ;; -11 ^ 6 ^ Cannot lock the record(s) of |2|
"RTN","RORERR20",63,0)
 ;; -12 ^ 6 ^ Cannot load and prepare lab search data
"RTN","RORERR20",64,0)
 ;; -13 ^ 6 ^ Cannot lock the registries
"RTN","RORERR20",65,0)
 ;; -14 ^ 6 ^ Cannot prepare selection rules
"RTN","RORERR20",66,0)
 ;; -15 ^ 6 ^ Error(s) during processing of the patient data
"RTN","RORERR20",67,0)
 ;; -16 ^ 6 ^ Cannot update demographic data
"RTN","RORERR20",68,0)
 ;; -17 ^ 6 ^ Invalid entry point: '|2|'
"RTN","RORERR20",69,0)
 ;; -18 ^ 6 ^ Routine '|2|' does not exist
"RTN","RORERR20",70,0)
 ;; -19 ^ 6 ^ Cannot load the selection rules
"RTN","RORERR20",71,0)
 ;; -20 ^ 6 ^ Cannot sort the selection rules
"RTN","RORERR20",72,0)
 ;; -21 ^ 6 ^ Syntax error in the expression
"RTN","RORERR20",73,0)
 ;; -22 ^ 6 ^ Cannot prepare data extraction definitions
"RTN","RORERR20",74,0)
 ;; -23 ^ 6 ^ Cannot set up HL7 environment variables
"RTN","RORERR20",75,0)
 ;; -24 ^ 6 ^ Cannot send the batch HL7 message
"RTN","RORERR20",76,0)
 ;; -25 ^ 6 ^ No event driver protocol
"RTN","RORERR20",77,0)
 ;; -26 ^ 3 ^ Neither ICN nor SSN is available
"RTN","RORERR20",78,0)
 ;; -27 ^ 5 ^ Cannot obtain results of the Lab tests
"RTN","RORERR20",79,0)
 ;; -28 ^ 4 ^ No active registries to |2|!
"RTN","RORERR20",80,0)
 ;; -29 ^ 6 ^ Non-existent LOINC code |2| in the registry parameters
"RTN","RORERR20",81,0)
 ;; -30 ^ 5 ^ Duplicate records in the file #95.3 for LOINC code |2|
"RTN","RORERR20",82,0)
 ;; -31 ^ 4 ^ Cannot remove the patient #|1| from the pending list
"RTN","RORERR20",83,0)
 ;; -32 ^ 6 ^ Incorrect data extraction period: '|2|-|3|'
"RTN","RORERR20",84,0)
 ;; -33 ^ 6 ^ Cannot de-queue data extraction task
"RTN","RORERR20",85,0)
 ;; -34 ^ 6 ^ Cannot open an output file
"RTN","RORERR20",86,0)
 ;; -35 ^ 6 ^ Device Handler error
"RTN","RORERR20",87,0)
 ;; -36 ^ 6 ^ Cannot retrieve Patient details (DFN:|1|) from File #|2|
"RTN","RORERR20",88,0)
 ;; -37 ^ 6 ^ Cannot retrieve details of medication
"RTN","RORERR20",89,0)
 ;; -38 ^ 6 ^ Cannot retrieve CPT code
"RTN","RORERR20",90,0)
 ;; -39 ^ 6 ^ Duplicate HL7 message ID in the file #798: '|2|'
"RTN","RORERR20",91,0)
 ;; -40 ^ 6 ^ Undefined variable: '|2|'
"RTN","RORERR20",92,0)
 ;; -41 ^ 2 ^ Registry setup has been completed
"RTN","RORERR20",93,0)
 ;; -42 ^ 4 ^ Task has been interrupted by user or by parent task
"RTN","RORERR20",94,0)
 ;; -43 ^ 6 ^ Error during the |2|. See log files.
"RTN","RORERR20",95,0)
 ;; -44 ^ 6 ^ Invalid extraction entry point: '|2|'
"RTN","RORERR20",96,0)
 ;; -45 ^ 6 ^ Invalid or missing IEN of selection rule
"RTN","RORERR20",97,0)
 ;; -46 ^ 5 ^ Cannot load registry parameters
"RTN","RORERR20",98,0)
 ;; -47 ^ 5 ^ Cannot find the '|2|' drug class
"RTN","RORERR20",99,0)
 ;; -48 ^ 2 ^ Registry '|2|' is inactive
"RTN","RORERR20",100,0)
 ;; -49 ^ 4 ^ Registry '|2|' is awaiting ACK
"RTN","RORERR20",101,0)
 ;; -50 ^ 6 ^ Cannot create the '|2|' checkpoint!
"RTN","RORERR20",102,0)
 ;; -51 ^ 6 ^ Cannot complete the '|2|' checkpoint!
"RTN","RORERR20",103,0)
 ;; -52 ^ 6 ^ Cannot find HL7 message ID in the file #798: '|2|'
"RTN","RORERR20",104,0)
 ;; -53 ^ 6 ^ Cannot enable the '|2|' protocol
"RTN","RORERR20",105,0)
 ;; -54 ^ 6 ^ The '|2|' Lab Search is not defined
"RTN","RORERR20",106,0)
 ;; -55 ^ 4 ^ No indicators are defined for the '|2|' Lab Search
"RTN","RORERR20",107,0)
 ;; -56 ^ 6 ^ Error code '|2|' is returned by the '|3|'
"RTN","RORERR20",108,0)
 ;; -57 ^ 4 ^ Error code '|2|' is returned by the '|3|'
"RTN","RORERR20",109,0)
 ;; -58 ^ 6 ^ File '|2|' not found
"RTN","RORERR20",110,0)
 ;; -59 ^ 3 ^ ICN checksum is shorter than 6 digits
"RTN","RORERR20",111,0)
 ;; -60 ^ 6 ^ Subtask #|2| crashed (see TaskMan logs)
"RTN","RORERR20",112,0)
 ;; -61 ^ 6 ^ Cannot start the registry update in multitask mode
"RTN","RORERR20",113,0)
 ;; -62 ^ 2 ^ Registry Update subtask #|2| has been scheduled
"RTN","RORERR20",114,0)
 ;; -63 ^ 6 ^ Data search in file #|2| is not supported
"RTN","RORERR20",115,0)
 ;; -64 ^ 6 ^ Data element #|3| (file #|2|) is not supported
"RTN","RORERR20",116,0)
 ;; -65 ^ 6 ^ |4| value of element #|3| (file #|2|) is not supported
"RTN","RORERR20",117,0)
 ;; -66 ^ 1 ^ Patient was skipped due to counter in the file #798.3
"RTN","RORERR20",118,0)
 ;; -67 ^ 6 ^ No application ACK after |2| attempt(s) to resend message
"RTN","RORERR20",119,0)
 ;; -68 ^ 6 ^ Invalid header of the HL7 message (or no header at all)
"RTN","RORERR20",120,0)
 ;; -69 ^ 6 ^ Cannot find the data element
"RTN","RORERR20",121,0)
 ;; -70 ^ 6 ^ Duplicate names of the data element
"RTN","RORERR20",122,0)
 ;; -71 ^ 1 ^ User entered the "^"
"RTN","RORERR20",123,0)
 ;; -72 ^ 6 ^ Timeout
"RTN","RORERR20",124,0)
 ;; -73 ^ 4 ^ Invalid or expired applic. acknowledgement was received
"RTN","RORERR20",125,0)
 ;; -74 ^ 6 ^ Number of messages in the batch does not match the BTS
"RTN","RORERR20",126,0)
 ;; -75 ^ 6 ^ Not all four HL7 encoding characters are defined
"RTN","RORERR20",127,0)
 ;; -76 ^ 6 ^ The [|2|] option must not be running during installation
"RTN","RORERR20",128,0)
 ;; -77 ^ 6 ^ Cannot create MailMan message stub
"RTN","RORERR20",129,0)
 ;; -78 ^ 6 ^ Scheduled subtasks have not been started by TaskMan
"RTN","RORERR20",130,0)
 ;; -79 ^ 6 ^ Missing or dangling pointer
"RTN","RORERR20",131,0)
 ;; -80 ^ 6 ^ Cannot find a list item (file #799.1)
"RTN","RORERR20",132,0)
 ;; -81 ^ 6 ^ Duplicate item codes (file #799.1)
"RTN","RORERR20",133,0)
 ;; -82 ^ 6 ^ The task '|2|' cannot be scheduled at '|3|'
"RTN","RORERR20",134,0)
 ;; -83 ^ 6 ^ Cannot find the task #|2| in the ROR TASK file
"RTN","RORERR20",135,0)
 ;; -84 ^ 6 ^ The task #|2| has not responded on the stop request yet
"RTN","RORERR20",136,0)
 ;; -85 ^ 6 ^ Invalid task number: '|2|'
"RTN","RORERR20",137,0)
 ;; -86 ^ 6 ^ Cannot find report parameters (file #799.34)
"RTN","RORERR20",138,0)
 ;; -87 ^ 6 ^ Duplicate report parameters (file #799.34)
"RTN","RORERR20",139,0)
 ;; -88 ^ 6 ^ Parameter |2| has an invalid value: '|3|'
"RTN","RORERR20",140,0)
 ;; -89 ^ 2 ^ No output file has been created
"RTN","RORERR20",141,0)
 ;; -90 ^ 6 ^ Application acknowledgement with |2| processing ID
"RTN","RORERR20",142,0)
 ;; -91 ^ 6 ^ Illegal attempt to access the registries from the GUI
"RTN","RORERR20",143,0)
 ;; -92 ^ 4 ^ Expired 'Awaiting Acknowledgement' flag has been cleared
"RTN","RORERR20",144,0)
 ;; -93 ^ 2 ^ The HL7 message #|2| has been re-queued
"RTN","RORERR20",145,0)
 ;; -94 ^ 4 ^ The HL7 message #|2| has been canceled
"RTN","RORERR20",146,0)
 ;; -95 ^ 3 ^ Invalid value. File: #|2|; IENS: "|3|"; Field(s): |4|
"RTN","RORERR20",147,0)
 ;; -96 ^ 1 ^ reserved
"RTN","RORERR20",148,0)
 ;; -97 ^ 6 ^ The patient is not in the |2|
"RTN","RORERR20",149,0)
 ;; -98 ^ 6 ^ Cannot get closed root name of file #|2| (IENS: |3|)
"RTN","RORERR20",150,0)
 ;; -99 ^ 1 ^ FileMan DBS call error(s)|2|
"RTN","RORERR20",151,0)
 ;;-100 ^ 3 ^ |2| was returned by the |3|
"RTN","RORERR20",152,0)
 ;;-101 ^ 2 ^ Your task #|2| (scheduled from GUI) has finished.
"RTN","RORERR20",153,0)
 ;;-102 ^ 5 ^ Invalid or missing record in the |2| file (IEN: |3|)
"RTN","RORERR20",154,0)
 ;;-103 ^ 6 ^ The registry |2| has not been populated yet.
"RTN","ROREVT01")
0^99^B5877686
"RTN","ROREVT01",1,0)
ROREVT01 ;HCIOFO/SG - EVENT PROTOCOLS  ; 6/9/03 1:50pm
"RTN","ROREVT01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","ROREVT01",3,0)
 ;
"RTN","ROREVT01",4,0)
 ; This routine uses the following IAs:
"RTN","ROREVT01",5,0)
 ;
"RTN","ROREVT01",6,0)
 ; #1181         Subscription to the DGPM MOVEMENT EVENT protocol
"RTN","ROREVT01",7,0)
 ; #1298         Subscription to the PXK VISIT DATA EVENT protocol
"RTN","ROREVT01",8,0)
 ; #3565         Subscription to the LR7O ALL EVSEND RESULTS protocol
"RTN","ROREVT01",9,0)
 ;
"RTN","ROREVT01",10,0)
 Q
"RTN","ROREVT01",11,0)
 ;
"RTN","ROREVT01",12,0)
 ;***** 'ROR EVENT LAB' PROTOCOL IMPLEMENTATION (DATA AREA #1)
"RTN","ROREVT01",13,0)
LAB ;
"RTN","ROREVT01",14,0)
 Q:$G(OREMSG)=""
"RTN","ROREVT01",15,0)
 N BUF,DATE,DONE,FS,I,PATIEN
"RTN","ROREVT01",16,0)
 S I="",DONE="00"
"RTN","ROREVT01",17,0)
 F  S I=$O(@OREMSG@(I))  Q:I=""  D  Q:DONE="11"
"RTN","ROREVT01",18,0)
 . S BUF=$G(@OREMSG@(I))
"RTN","ROREVT01",19,0)
 . ;--- Get the HL7 field separator
"RTN","ROREVT01",20,0)
 . I $G(FS)=""  S:$E(BUF,1,3)="MSH" FS=$E(BUF,4)  Q:$G(FS)=""
"RTN","ROREVT01",21,0)
 . ;--- Get the patient IEN
"RTN","ROREVT01",22,0)
 . I $P(BUF,FS)="PID"  D:'$E(DONE,1)  Q
"RTN","ROREVT01",23,0)
 . . S PATIEN=+$P(BUF,FS,4)              ; PID-3
"RTN","ROREVT01",24,0)
 . . S:PATIEN>0 $E(DONE,1)="1"
"RTN","ROREVT01",25,0)
 . ;--- Get the specimen date
"RTN","ROREVT01",26,0)
 . I $P(BUF,FS)="OBR"  D:'$E(DONE,2)  Q
"RTN","ROREVT01",27,0)
 . . S DATE=$$HL7TFM^XLFDT($P(BUF,FS,8)) ; OBR-7
"RTN","ROREVT01",28,0)
 . . S $E(DONE,2)="1"
"RTN","ROREVT01",29,0)
 ;--- Create the event reference
"RTN","ROREVT01",30,0)
 S:DONE="11" I=$$ADD^RORUPP02(PATIEN,1,DATE)
"RTN","ROREVT01",31,0)
 Q
"RTN","ROREVT01",32,0)
 ;
"RTN","ROREVT01",33,0)
 ;***** RETURNS THE LIST OF PACKAGE EVENT PROTOCOLS
"RTN","ROREVT01",34,0)
 ;
"RTN","ROREVT01",35,0)
 ; .EPLST        Reference to a local variable. The list of
"RTN","ROREVT01",36,0)
 ;               package event protocols will be returned via
"RTN","ROREVT01",37,0)
 ;               this parameter: EPLST(ProtocolName)=""
"RTN","ROREVT01",38,0)
 ;
"RTN","ROREVT01",39,0)
LIST(EPLST) ;
"RTN","ROREVT01",40,0)
 K EPLST
"RTN","ROREVT01",41,0)
 S EPLST("ROR EVENT LAB")=""
"RTN","ROREVT01",42,0)
 S EPLST("ROR EVENT PTF")=""
"RTN","ROREVT01",43,0)
 S EPLST("ROR EVENT VISIT")=""
"RTN","ROREVT01",44,0)
 Q
"RTN","ROREVT01",45,0)
 ;
"RTN","ROREVT01",46,0)
 ;***** 'ROR EVENT PTF' PROTOCOL IMPLEMENTATION (DATA AREA #3)
"RTN","ROREVT01",47,0)
PTF ;
"RTN","ROREVT01",48,0)
 N ADATE,IEN405,PATIEN,PDATE,RC,TRC
"RTN","ROREVT01",49,0)
 S PATIEN=$P($G(DGPMA),"^",3)  Q:PATIEN'>0
"RTN","ROREVT01",50,0)
 ;--- Admissions, transfers and discharges
"RTN","ROREVT01",51,0)
 F TRC=1,2,3  D
"RTN","ROREVT01",52,0)
 . S IEN405=0
"RTN","ROREVT01",53,0)
 . F  S IEN405=$O(^UTILITY("DGPM",$J,TRC,IEN405))  Q:IEN405'>0  D
"RTN","ROREVT01",54,0)
 . . S PDATE=$P($G(^UTILITY("DGPM",$J,TRC,IEN405,"P")),"^")
"RTN","ROREVT01",55,0)
 . . S ADATE=$P($G(^UTILITY("DGPM",$J,TRC,IEN405,"A")),"^")
"RTN","ROREVT01",56,0)
 . . I PDATE>0               S RC=$$ADD^RORUPP02(PATIEN,3,PDATE)
"RTN","ROREVT01",57,0)
 . . I ADATE>0  S:ADATE'=PDATE RC=$$ADD^RORUPP02(PATIEN,3,ADATE)
"RTN","ROREVT01",58,0)
 Q
"RTN","ROREVT01",59,0)
 ;
"RTN","ROREVT01",60,0)
 ;***** 'ROR EVENT VISIT' PROTOCOL IMPLEMENTATION (DATA AREA #2)
"RTN","ROREVT01",61,0)
VISIT ;
"RTN","ROREVT01",62,0)
 N BUF,IEN,PATIEN,RC,VSIEN
"RTN","ROREVT01",63,0)
 S VSIEN=""
"RTN","ROREVT01",64,0)
 F  S VSIEN=$O(^TMP("PXKCO",$J,VSIEN))  Q:VSIEN=""  D
"RTN","ROREVT01",65,0)
 . S IEN=""
"RTN","ROREVT01",66,0)
 . F  S IEN=$O(^TMP("PXKCO",$J,VSIEN,"VST",IEN))  Q:IEN=""  D
"RTN","ROREVT01",67,0)
 . . S BUF=$G(^TMP("PXKCO",$J,VSIEN,"VST",IEN,0,"AFTER"))
"RTN","ROREVT01",68,0)
 . . S PATIEN=$P(BUF,"^",5)  Q:(PATIEN'>0)!$P(BUF,"^",11)
"RTN","ROREVT01",69,0)
 . . ;--- Create the event reference
"RTN","ROREVT01",70,0)
 . . S RC=$$ADD^RORUPP02(PATIEN,2,$P(BUF,"^",2))
"RTN","ROREVT01",71,0)
 Q
"RTN","ROREXPR")
0^19^B10188914
"RTN","ROREXPR",1,0)
ROREXPR ;HCIOFO/SG - PREPARATION FOR DATA EXTRACTION  ; 9/9/03 1:04pm
"RTN","ROREXPR",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3,5**;May 14, 2002
"RTN","ROREXPR",3,0)
 ;
"RTN","ROREXPR",4,0)
 Q
"RTN","ROREXPR",5,0)
 ;
"RTN","ROREXPR",6,0)
 ;***** PREPARES VARIABLES FOR DATA EXTRACTION
"RTN","ROREXPR",7,0)
 ;
"RTN","ROREXPR",8,0)
 ; REGNAME       Registry name
"RTN","ROREXPR",9,0)
 ;
"RTN","ROREXPR",10,0)
 ; [DXBEG]       Data extraction start date (individual start
"RTN","ROREXPR",11,0)
 ;               date for each patient by default).
"RTN","ROREXPR",12,0)
 ;               Time part of the parameter value is ignored.
"RTN","ROREXPR",13,0)
 ;
"RTN","ROREXPR",14,0)
 ; [DXEND]       Data extraction end date (TODAY by default)
"RTN","ROREXPR",15,0)
 ;               Time part of the parameter value is ignored.
"RTN","ROREXPR",16,0)
 ;
"RTN","ROREXPR",17,0)
 ; DXBEG and DXEND parameters may be used only for historical data
"RTN","ROREXPR",18,0)
 ; extraction. Use of these parameters for regular data extraction
"RTN","ROREXPR",19,0)
 ; process will negatively affect the package!
"RTN","ROREXPR",20,0)
 ;
"RTN","ROREXPR",21,0)
 ; Return Values:
"RTN","ROREXPR",22,0)
 ;        0  Ok
"RTN","ROREXPR",23,0)
 ;       <0  Error code
"RTN","ROREXPR",24,0)
 ;
"RTN","ROREXPR",25,0)
PREPARE(REGNAME,DXBEG,DXEND) ;
"RTN","ROREXPR",26,0)
 N DTAREA,IL,IR,RC,REGIEN,RORMSG,SEGNAME,TMP
"RTN","ROREXPR",27,0)
 K RORLRC  F TMP="DXBEG","HL7","LD","MAXHL7SIZE"  K ROREXT(TMP)
"RTN","ROREXPR",28,0)
 S DXBEG=$G(DXBEG)\1,DXEND=$G(DXEND)\1
"RTN","ROREXPR",29,0)
 ;--- Data extraction period
"RTN","ROREXPR",30,0)
 S ROREXT("DXEND")=$S(DXEND>0:DXEND,1:$$DT^XLFDT)
"RTN","ROREXPR",31,0)
 I DXBEG>0  S RC=0  D  Q:RC<0 RC
"RTN","ROREXPR",32,0)
 . S ROREXT("DXBEG")=DXBEG  Q:DXBEG'>ROREXT("DXEND")
"RTN","ROREXPR",33,0)
 . S RC=$$ERROR^RORERR(-32,,,,DXBEG,ROREXT("DXEND"))
"RTN","ROREXPR",34,0)
 ;--- Check if the critical patches are installed
"RTN","ROREXPR",35,0)
 K ROREXT("PATCH")
"RTN","ROREXPR",36,0)
 F TMP="MD*1.0*1","MC*2.3*34"  D
"RTN","ROREXPR",37,0)
 . S:$$PATCH^XPDUTL(TMP) ROREXT("PATCH",TMP)=""
"RTN","ROREXPR",38,0)
 ;--- Get the package version and the latest patch info
"RTN","ROREXPR",39,0)
 S TMP="CLINICAL CASE REGISTRIES"
"RTN","ROREXPR",40,0)
 S ROREXT("VERSION")=$$VERSION^XPDUTL(TMP)_U_$$LAST^XPDUTL(TMP)
"RTN","ROREXPR",41,0)
 ;--- Get the registry IEN and some parameters
"RTN","ROREXPR",42,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME,"7;10;13E;13.1;15.1",.RORBUF)
"RTN","ROREXPR",43,0)
 Q:REGIEN<0 REGIEN
"RTN","ROREXPR",44,0)
 S ROREXT("EXTRDAYS")=$G(RORBUF("DILIST","ID",1,7))
"RTN","ROREXPR",45,0)
 S ROREXT("HL7PROT")=$G(RORBUF("DILIST","ID",1,13))
"RTN","ROREXPR",46,0)
 ;--- Check the HL7 parameters
"RTN","ROREXPR",47,0)
 S RC=$$INIT^RORHL7()  Q:RC<0 RC
"RTN","ROREXPR",48,0)
 ;--- Load maximum message size and convert it into bytes
"RTN","ROREXPR",49,0)
 ;--- (1 Megabyte = 1024 Kb = 1024 * 1024 = 1048576 bytes)
"RTN","ROREXPR",50,0)
 S TMP=+$G(RORBUF("DILIST","ID",1,13.1))
"RTN","ROREXPR",51,0)
 S:TMP>0 ROREXT("MAXHL7SIZE")=(TMP*1048576)\1
"RTN","ROREXPR",52,0)
 ;--- Setup the lag interval (for regular data extraction only)
"RTN","ROREXPR",53,0)
 D:'$G(ROREXT("DXBEG"))
"RTN","ROREXPR",54,0)
 . S TMP=$G(RORBUF("DILIST","ID",1,15.1))
"RTN","ROREXPR",55,0)
 . S ROREXT("LD",1)=$S(TMP>0:TMP,1:1)
"RTN","ROREXPR",56,0)
 ;--- Setup the message builder call-back entry point
"RTN","ROREXPR",57,0)
 S TMP=$$TRIM^XLFSTR($G(RORBUF("DILIST","ID",1,10)))
"RTN","ROREXPR",58,0)
 I TMP'=""  D  Q:RC<0 $$ERROR^RORERR(-44,,REGNAME,,TMP)
"RTN","ROREXPR",59,0)
 . S RC=$$VERIFYEP^RORUTL01(TMP)
"RTN","ROREXPR",60,0)
 . S:RC'<0 ROREXT("MSGBLD")=TMP
"RTN","ROREXPR",61,0)
 ;--- Load and prepare segment descriptors
"RTN","ROREXPR",62,0)
 S TMP=","_REGIEN_","
"RTN","ROREXPR",63,0)
 D LIST^DIC(798.19,TMP,"@;.01;.02I;1","U",,,,"B",,,,"RORMSG")
"RTN","ROREXPR",64,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.19,TMP)
"RTN","ROREXPR",65,0)
 S IR=""
"RTN","ROREXPR",66,0)
 F  S IR=$O(^TMP("DILIST",$J,"ID",IR))  Q:IR=""  D
"RTN","ROREXPR",67,0)
 . S SEGNAME=^TMP("DILIST",$J,"ID",IR,.01)
"RTN","ROREXPR",68,0)
 . S DTAREA=+$G(^TMP("DILIST",$J,"ID",IR,.02))
"RTN","ROREXPR",69,0)
 . S TMP=$G(^TMP("DILIST",$J,"ID",IR,1))
"RTN","ROREXPR",70,0)
 . S $P(ROREXT("HL7",DTAREA,SEGNAME),U,2)=TMP
"RTN","ROREXPR",71,0)
 ;--- Load list of codes of extracted Lab results
"RTN","ROREXPR",72,0)
 S TMP=","_REGIEN_","
"RTN","ROREXPR",73,0)
 D LIST^DIC(798.112,TMP,"@;.01;.02;.03","U",,,,"B",,,,"RORMSG")
"RTN","ROREXPR",74,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.112,TMP)
"RTN","ROREXPR",75,0)
 Q:'$G(^TMP("DILIST",$J,0)) 0
"RTN","ROREXPR",76,0)
 S (IL,IR,RC)=0
"RTN","ROREXPR",77,0)
 F  S IR=$O(^TMP("DILIST",$J,"ID",IR))  Q:IR=""  D  Q:RC
"RTN","ROREXPR",78,0)
 . S TMP=$G(^TMP("DILIST",$J,"ID",IR,.01))
"RTN","ROREXPR",79,0)
 . I TMP="*"  K RORLRC  D  S RORLRC=$S(TMP'="":TMP,1:"*"),RC=1  Q
"RTN","ROREXPR",80,0)
 . . S TMP=$G(^TMP("DILIST",$J,"ID",IR,.03))
"RTN","ROREXPR",81,0)
 . I TMP>0  D  Q:RC<0  S IL=IL+1,RORLRC(IL)=TMP_"^LN"
"RTN","ROREXPR",82,0)
 . . S TMP=$$LNCODE^RORUTL02(TMP)  S:TMP<0 RC=TMP
"RTN","ROREXPR",83,0)
 . S TMP=$G(^TMP("DILIST",$J,"ID",IR,.02))
"RTN","ROREXPR",84,0)
 . S:TMP>0 IL=IL+1,RORLRC(IL)=TMP_"^NLT"
"RTN","ROREXPR",85,0)
 D CLEAN^DILF
"RTN","ROREXPR",86,0)
 Q $S(RC<0:RC,1:0)
"RTN","ROREXT")
0^20^B33228384
"RTN","ROREXT",1,0)
ROREXT ;HCIOFO/SG - DATA EXTRACT & TRANSMISSION ; 9/9/03 1:04pm
"RTN","ROREXT",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","ROREXT",3,0)
 ;
"RTN","ROREXT",4,0)
 ; ROREXT -------------- DATA EXTRACTION DESCRIPTOR
"RTN","ROREXT",5,0)
 ;
"RTN","ROREXT",6,0)
 ; ROREXT("DXBEG")       Start date of the data extraction (opt'l)
"RTN","ROREXT",7,0)
 ;                       If this node is defined and greater than
"RTN","ROREXT",8,0)
 ;                       zero, data extraction starts from this date
"RTN","ROREXT",9,0)
 ;                       (instead of individual start date for each
"RTN","ROREXT",10,0)
 ;                       patient in the registry).
"RTN","ROREXT",11,0)
 ; ROREXT("DXEND")       End date of the data extraction
"RTN","ROREXT",12,0)
 ;                       (these nodes are set by $$PREPARE^ROREXPR).
"RTN","ROREXT",13,0)
 ;
"RTN","ROREXT",14,0)
 ; ROREXT("EXTRDAYS")    Extraction period for a new patient
"RTN","ROREXT",15,0)
 ;
"RTN","ROREXT",16,0)
 ; ROREXT("FLAGS")       Flags to control processing (see the
"RTN","ROREXT",17,0)
 ;                       TASK^ROR for possible values).
"RTN","ROREXT",18,0)
 ;
"RTN","ROREXT",19,0)
 ; ROREXT("HL7",
"RTN","ROREXT",20,0)
 ;   Data Area,          Data area where the segments are used
"RTN","ROREXT",21,0)
 ;                       (see the field .02 of the multiple 9 in the
"RTN","ROREXT",22,0)
 ;                       file #798.1)
"RTN","ROREXT",23,0)
 ;                          1  Patient
"RTN","ROREXT",24,0)
 ;                          2  Laboratory
"RTN","ROREXT",25,0)
 ;                          3  Pharmacy
"RTN","ROREXT",26,0)
 ;                          4  Radiology
"RTN","ROREXT",27,0)
 ;                          5  Inpatient
"RTN","ROREXT",28,0)
 ;                          6  Outpatient
"RTN","ROREXT",29,0)
 ;                          7  Pathology-Autopsy
"RTN","ROREXT",30,0)
 ;                          8  Pathology-Liver Biopsy
"RTN","ROREXT",31,0)
 ;                          9  Pathology-Surgical
"RTN","ROREXT",32,0)
 ;                         10  Pathology-Cyto
"RTN","ROREXT",33,0)
 ;                         11  Microbiology
"RTN","ROREXT",34,0)
 ;                         12  EKG
"RTN","ROREXT",35,0)
 ;                         13  Allergy
"RTN","ROREXT",36,0)
 ;                         14  IV
"RTN","ROREXT",37,0)
 ;     Segment Name)     HL7 segment descriptor
"RTN","ROREXT",38,0)
 ;                         ^1: reserved
"RTN","ROREXT",39,0)
 ;                         ^2: List of fields (separated by commas)
"RTN","ROREXT",40,0)
 ;                             that should be created in the segment.
"RTN","ROREXT",41,0)
 ;
"RTN","ROREXT",42,0)
 ; ROREXT("HL7BUF")      Closed root of the buffer where the HL7
"RTN","ROREXT",43,0)
 ;                       message is constructed. By default, the
"RTN","ROREXT",44,0)
 ;                       ^TMP("HLS",$J) is used.
"RTN","ROREXT",45,0)
 ;
"RTN","ROREXT",46,0)
 ; ROREXT("HL7CNT")      Counter of the messages in the batch
"RTN","ROREXT",47,0)
 ; ROREXT("HL7DT")       Date of the batch message creation (FileMan)
"RTN","ROREXT",48,0)
 ; ROREXT("HL7MID")      Message ID of the "stub" message
"RTN","ROREXT",49,0)
 ; ROREXT("HL7MTIEN")    IEN in the File #772 for the "stub" message
"RTN","ROREXT",50,0)
 ; ROREXT("HL7PROT")     Name of the event driver protocol
"RTN","ROREXT",51,0)
 ;
"RTN","ROREXT",52,0)
 ; ROREXT("HL7PTR")      Subscript of the last occupied sub-node of
"RTN","ROREXT",53,0)
 ;                       the message buffer (see the "HL7BUF").
"RTN","ROREXT",54,0)
 ;                       Value of the variable is incremented before
"RTN","ROREXT",55,0)
 ;                       storing the segment.
"RTN","ROREXT",56,0)
 ;
"RTN","ROREXT",57,0)
 ; ROREXT("HL7SID",
"RTN","ROREXT",58,0)
 ;   SegName)            The next value of the Set ID for this kind
"RTN","ROREXT",59,0)
 ;                       of segments. The $$CREATE^RORHL7 function
"RTN","ROREXT",60,0)
 ;                       resets the Set ID's to 1 for all supported
"RTN","ROREXT",61,0)
 ;                       segments.
"RTN","ROREXT",62,0)
 ;
"RTN","ROREXT",63,0)
 ; ROREXT("HL7SIZE")     Current size of the HL7 batch
"RTN","ROREXT",64,0)
 ;                         ^1: Current size (in bytes)
"RTN","ROREXT",65,0)
 ;                         ^2: 1 if maximum size has been reached
"RTN","ROREXT",66,0)
 ;
"RTN","ROREXT",67,0)
 ; ROREXT("LD",
"RTN","ROREXT",68,0)
 ;   1)                  Number of lag days for the data extraction
"RTN","ROREXT",69,0)
 ;
"RTN","ROREXT",70,0)
 ; ROREXT("MAXHL7SIZE")  Maximum size (in bytes) of an HL7 message
"RTN","ROREXT",71,0)
 ;
"RTN","ROREXT",72,0)
 ; ROREXT("MSGBLD")      Message builder call-back entry point (opt'l)
"RTN","ROREXT",73,0)
 ;
"RTN","ROREXT",74,0)
 ; ROREXT("PATCH",
"RTN","ROREXT",75,0)
 ;   PatchName)          Defined if the patch is installed
"RTN","ROREXT",76,0)
 ;
"RTN","ROREXT",77,0)
 ; ROREXT("SUSPEND")     DATA EXTRACTION SUSPENSION PARAMETERS
"RTN","ROREXT",78,0)
 ;                         ^1: Suspension start time (FileMan)
"RTN","ROREXT",79,0)
 ;                         ^2: Suspension end time (FileMan)
"RTN","ROREXT",80,0)
 ;
"RTN","ROREXT",81,0)
 ;                       For example, to suspend the data extraction
"RTN","ROREXT",82,0)
 ;                       from 7:00 until 18:00 this node should have
"RTN","ROREXT",83,0)
 ;                       the following value: ".07^.18".
"RTN","ROREXT",84,0)
 ;
"RTN","ROREXT",85,0)
 ; ROREXT("VERSION")     ROR version/patch installed at the site
"RTN","ROREXT",86,0)
 ;                         ^1: Version number (e.g. 1.0)
"RTN","ROREXT",87,0)
 ;                         ^2: Latest patch number (e.g. 5)
"RTN","ROREXT",88,0)
 ;                         ^3: Patch installation date (FileMan)
"RTN","ROREXT",89,0)
 ;
"RTN","ROREXT",90,0)
 ; RORHL --------------- HL7 ENVIRONMENT VARIABLES
"RTN","ROREXT",91,0)
 ;
"RTN","ROREXT",92,0)
 ; RORHL                 This local array contains HL7 environment
"RTN","ROREXT",93,0)
 ;                       variables initialized by INIT^HLFNC2 ("FS",
"RTN","ROREXT",94,0)
 ;                       "ECH" and others).
"RTN","ROREXT",95,0)
 ;
"RTN","ROREXT",96,0)
 ; RORLRC -------------- LIST OF EXTRACTED LAB RESULTS
"RTN","ROREXT",97,0)
 ;
"RTN","ROREXT",98,0)
 ; RORLRC(               Either a list of codes of a Lab results to
"RTN","ROREXT",99,0)
 ;                       extract or "*" for all results (see the LA7SC
"RTN","ROREXT",100,0)
 ;                       parameter of the GCPR^LA7QRY entry point)
"RTN","ROREXT",101,0)
 ;   Seq#)               Lab result code
"RTN","ROREXT",102,0)
 ;                         ^1: Result code
"RTN","ROREXT",103,0)
 ;                         ^2: Coding system ("LN" or "NLT")
"RTN","ROREXT",104,0)
 ;
"RTN","ROREXT",105,0)
 Q
"RTN","ROREXT",106,0)
 ;
"RTN","ROREXT",107,0)
 ;***** PRINT SOME DEBUG INFORMATION
"RTN","ROREXT",108,0)
DEBUG1 ;
"RTN","ROREXT",109,0)
 D ZW^RORUTL01("ROREXT","Control Data")
"RTN","ROREXT",110,0)
 D ZW^RORUTL01("RORLRC","Lab Results to extract")
"RTN","ROREXT",111,0)
 W !,"Job number: ",$J,!
"RTN","ROREXT",112,0)
 Q
"RTN","ROREXT",113,0)
 ;
"RTN","ROREXT",114,0)
 ;***** EXTRACTS AND SENDS REGISTRY DATA
"RTN","ROREXT",115,0)
 ;
"RTN","ROREXT",116,0)
 ; REGNAME       Registry name
"RTN","ROREXT",117,0)
 ;
"RTN","ROREXT",118,0)
 ; [DXBEG]       Data extraction start date (individual start
"RTN","ROREXT",119,0)
 ;               date for each patient by default).
"RTN","ROREXT",120,0)
 ;               Time part of the parameter value is ignored.
"RTN","ROREXT",121,0)
 ;
"RTN","ROREXT",122,0)
 ; [SUSPEND]     Subtask suspension parameters:
"RTN","ROREXT",123,0)
 ;               See description of the ROREXT("SUSPEND") node
"RTN","ROREXT",124,0)
 ;               for details.
"RTN","ROREXT",125,0)
 ;
"RTN","ROREXT",126,0)
 ; [CLRFLG]      Clear flags to control processing.
"RTN","ROREXT",127,0)
 ; [SETFLG]      Set flags to control processing.
"RTN","ROREXT",128,0)
 ;               See description of the TASK^ROR for
"RTN","ROREXT",129,0)
 ;               possible values of the flags.
"RTN","ROREXT",130,0)
 ;
"RTN","ROREXT",131,0)
 ; Return Values:
"RTN","ROREXT",132,0)
 ;       <0  Error Code (see MSGLIST^RORERR20)
"RTN","ROREXT",133,0)
 ;        0  Ok
"RTN","ROREXT",134,0)
 ;
"RTN","ROREXT",135,0)
EXTRACT(REGNAME,DXBEG,SUSPEND,CLRFLG,SETFLG) ;
"RTN","ROREXT",136,0)
 N RORERRDL      ; Default error location
"RTN","ROREXT",137,0)
 N ROREXT        ; Data extraction descriptor
"RTN","ROREXT",138,0)
 N RORHL         ; HL7 variables
"RTN","ROREXT",139,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","ROREXT",140,0)
 N RORLRC        ; List of codes of Lab results to be extracted
"RTN","ROREXT",141,0)
 ;
"RTN","ROREXT",142,0)
 N COUNTERS,MID,RC,REGLST,RGLIST,TMP
"RTN","ROREXT",143,0)
 D INIT^RORUTL01("ROREXT"),CLEAR^RORERR("EXTRACT^ROREXT")
"RTN","ROREXT",144,0)
 S RGLIST(REGNAME)=""
"RTN","ROREXT",145,0)
 ;--- Open a new log
"RTN","ROREXT",146,0)
 S TMP=$$SETUP^RORLOG(.RGLIST)
"RTN","ROREXT",147,0)
 S TMP=$$OPEN^RORLOG(.RGLIST,2,"DATA EXTRACTION STARTED")
"RTN","ROREXT",148,0)
 D
"RTN","ROREXT",149,0)
 . ;--- Create a list of active registries
"RTN","ROREXT",150,0)
 . S RC=$$ARLST^RORUTL02(.RGLIST,.REGLST)  Q:RC<0
"RTN","ROREXT",151,0)
 . I $D(REGLST)<10  D  Q
"RTN","ROREXT",152,0)
 . . S RC=$$ERROR^RORERR(-28,,,,"extract data")
"RTN","ROREXT",153,0)
 . ;--- Lock parameters of the registries being processed
"RTN","ROREXT",154,0)
 . S RC=$$LOCKREG^RORUTL02(.REGLST,1,,"DATA EXTRACTION")  Q:RC<0
"RTN","ROREXT",155,0)
 . I 'RC  D  Q
"RTN","ROREXT",156,0)
 . . S RC=$$ERROR^RORERR(-11,,,,"registries being processed")
"RTN","ROREXT",157,0)
 . ;--- Prepare data extraction rules
"RTN","ROREXT",158,0)
 . S RC=$$PREPARE^ROREXPR(REGNAME,$G(DXBEG))
"RTN","ROREXT",159,0)
 . I RC<0  S RC=$$ERROR^RORERR(-22)  Q
"RTN","ROREXT",160,0)
 . ;--- Process the flags
"RTN","ROREXT",161,0)
 . S CLRFLG=$$UP^XLFSTR($G(CLRFLG))
"RTN","ROREXT",162,0)
 . S SETFLG=$$UP^XLFSTR($G(SETFLG))
"RTN","ROREXT",163,0)
 . S ROREXT("FLAGS")=$TR($G(ROREXT("FLAGS")),CLRFLG_SETFLG)_SETFLG
"RTN","ROREXT",164,0)
 . ;--- Enable task suspension if requested
"RTN","ROREXT",165,0)
 . I $G(SUSPEND)  S:ROREXT("FLAGS")["X" ROREXT("SUSPEND")=SUSPEND
"RTN","ROREXT",166,0)
 . ;--- Display the debug information
"RTN","ROREXT",167,0)
 . D:$G(RORPARM("DEBUG"))>1 DEBUG1
"RTN","ROREXT",168,0)
 . ;--- Extract registry data
"RTN","ROREXT",169,0)
 . S RC=$$PROCESS^ROREXT01(REGNAME)  Q:RC<0
"RTN","ROREXT",170,0)
 . S COUNTERS=RC,RC=0
"RTN","ROREXT",171,0)
 . ;--- Send the batch HL7 message
"RTN","ROREXT",172,0)
 . W:$G(RORPARM("DEBUG"))>1 !,"HL7 Batch ID:   ",$G(ROREXT("HL7MID"))
"RTN","ROREXT",173,0)
 . S RC=$$SEND^RORHL7(.MID)  Q:RC<0
"RTN","ROREXT",174,0)
 . I $G(MID)'=""  D  D LOG^RORLOG(2,TMP)
"RTN","ROREXT",175,0)
 . . S TMP="HL7 batch message "_MID_" has been generated"
"RTN","ROREXT",176,0)
 . ;--- Update registry parameters
"RTN","ROREXT",177,0)
 . S TMP=$$TMSTMP^ROREXTUT(.REGLST,$S('RC:$G(MID),1:""))
"RTN","ROREXT",178,0)
 ;
"RTN","ROREXT",179,0)
 ;--- Unlock parameters of processed registries
"RTN","ROREXT",180,0)
 S TMP=$$LOCKREG^RORUTL02(.REGLST,0)
"RTN","ROREXT",181,0)
 ;--- Statistics & Cleanup
"RTN","ROREXT",182,0)
 S TMP="DATA EXTRACTION "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","ROREXT",183,0)
 D CLOSE^RORLOG(TMP,$G(COUNTERS))
"RTN","ROREXT",184,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("ROREXT")
"RTN","ROREXT",185,0)
 Q $S(RC<0:RC,1:0)
"RTN","ROREXT",186,0)
 ;
"RTN","ROREXT",187,0)
 ;***** ENTRY POINT OF DATA EXTRACTION TASK
"RTN","ROREXT",188,0)
 ;
"RTN","ROREXT",189,0)
 ; RORREG        Registry name
"RTN","ROREXT",190,0)
 ;
"RTN","ROREXT",191,0)
 ; [RORFLCLR]    Clear flags to control processing.
"RTN","ROREXT",192,0)
 ; [RORFLSET]    Set flags to control processing.
"RTN","ROREXT",193,0)
 ;               See description of the TASK^ROR for possible
"RTN","ROREXT",194,0)
 ;               values of the flags.
"RTN","ROREXT",195,0)
 ;
"RTN","ROREXT",196,0)
 ; [RORSUSP]     Suspension parameters of the data extraction
"RTN","ROREXT",197,0)
 ;               task. The task is not suspended by default.
"RTN","ROREXT",198,0)
 ;
"RTN","ROREXT",199,0)
TASK ;
"RTN","ROREXT",200,0)
 N RORERROR      ; Error processing data
"RTN","ROREXT",201,0)
 N RORPARM       ; Application parameters
"RTN","ROREXT",202,0)
 ;
"RTN","ROREXT",203,0)
 N RC  K ZTREQ
"RTN","ROREXT",204,0)
 ;--- Force "UNDEF" error if registry name is not defined
"RTN","ROREXT",205,0)
 I $G(RORREG)?." "  K RORREG  S RC=RORREG
"RTN","ROREXT",206,0)
 ;--- Initialize the variables
"RTN","ROREXT",207,0)
 S RORPARM("ERR")=1
"RTN","ROREXT",208,0)
 ;--- Check the task parameters
"RTN","ROREXT",209,0)
 S RORFLCLR=$G(RORFLCLR)
"RTN","ROREXT",210,0)
 S RORFLSET=$G(RORFLSET)
"RTN","ROREXT",211,0)
 S RORSUSP=$S($G(RORSUSP)>0:RORSUSP,1:"")
"RTN","ROREXT",212,0)
 ;--- Debug mode
"RTN","ROREXT",213,0)
 S:RORFLSET["D" RORPARM("DEBUG")=1
"RTN","ROREXT",214,0)
 ;--- Run the data extraction
"RTN","ROREXT",215,0)
 S RC=$$EXTRACT(RORREG,,RORSUSP,RORFLCLR,RORFLSET)
"RTN","ROREXT",216,0)
 S:RC<0 ZTSTOP=1
"RTN","ROREXT",217,0)
 I RC=-42  D ALERT^RORUTL01(RORREG,-42)  Q
"RTN","ROREXT",218,0)
 D:RC<0 ALERT^RORUTL01(RORREG,-43,,,,"data extraction")
"RTN","ROREXT",219,0)
 S ZTREQ="@"
"RTN","ROREXT",220,0)
 Q
"RTN","ROREXT01")
0^56^B21361325
"RTN","ROREXT01",1,0)
ROREXT01 ;HCIOFO/SG - EXTRACTION & TRANSMISSION PROCESS ; 11/26/03 7:46am
"RTN","ROREXT01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,4,5**;May 14, 2002
"RTN","ROREXT01",3,0)
 ;
"RTN","ROREXT01",4,0)
 Q
"RTN","ROREXT01",5,0)
 ;
"RTN","ROREXT01",6,0)
 ;***** SCANS THE REGISTRY AND EXTRACTS THE DATA
"RTN","ROREXT01",7,0)
 ;
"RTN","ROREXT01",8,0)
 ; REGNAME       Registry name
"RTN","ROREXT01",9,0)
 ;
"RTN","ROREXT01",10,0)
 ; Return Values:
"RTN","ROREXT01",11,0)
 ;       <0  Error Code
"RTN","ROREXT01",12,0)
 ;      >=0  Statistics
"RTN","ROREXT01",13,0)
 ;             ^1: Total number of processed patients
"RTN","ROREXT01",14,0)
 ;             ^2: Number of patients processed with errors
"RTN","ROREXT01",15,0)
 ;
"RTN","ROREXT01",16,0)
 ; In normal mode this function processes all patients and returns
"RTN","ROREXT01",17,0)
 ; total number of patients and number of patients processed with
"RTN","ROREXT01",18,0)
 ; errors.
"RTN","ROREXT01",19,0)
 ;
"RTN","ROREXT01",20,0)
 ; However, in debug mode 3 the function stops after the first
"RTN","ROREXT01",21,0)
 ; patient processed with error and returns an error code.
"RTN","ROREXT01",22,0)
 ;
"RTN","ROREXT01",23,0)
PROCESS(REGNAME) ;
"RTN","ROREXT01",24,0)
 N CNT,DTNEXT,ECNT,IENS,IIEN,PATIEN,RC,REGIEN,ROOT,RORBUF,RORMSG,TH
"RTN","ROREXT01",25,0)
 S ROOT=$$ROOT^DILFD(798,,1)
"RTN","ROREXT01",26,0)
 ;--- Get the registry IEN
"RTN","ROREXT01",27,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME,"2.4I",.RORBUF)
"RTN","ROREXT01",28,0)
 Q:REGIEN<0 REGIEN
"RTN","ROREXT01",29,0)
 ;--- Continue from the registry record that follows the last
"RTN","ROREXT01",30,0)
 ;    one processed by the previous data extraction if it hit
"RTN","ROREXT01",31,0)
 ;--- the maximum HL7 message size.
"RTN","ROREXT01",32,0)
 S IIEN=$G(RORBUF("DILIST","ID",1,2.4))
"RTN","ROREXT01",33,0)
 ;--- Loop through the patients of the registry
"RTN","ROREXT01",34,0)
 S (CNT,ECNT,RC)=0
"RTN","ROREXT01",35,0)
 F  S IIEN=$O(@ROOT@("AC",REGIEN,IIEN))  Q:IIEN=""  D  Q:RC
"RTN","ROREXT01",36,0)
 . ;--- For a queued task only
"RTN","ROREXT01",37,0)
 . I $D(ZTQUEUED)  S RC=0  D  Q:RC<0
"RTN","ROREXT01",38,0)
 . . ;--- Check if task stop has been requested
"RTN","ROREXT01",39,0)
 . . I $$S^%ZTLOAD  S RC=$$ERROR^RORERR(-42)  Q
"RTN","ROREXT01",40,0)
 . . ;--- Check if the task should be suspended
"RTN","ROREXT01",41,0)
 . . Q:'$G(ROREXT("SUSPEND"))
"RTN","ROREXT01",42,0)
 . . Q:$$NOW^XLFDT<$G(DTNEXT)
"RTN","ROREXT01",43,0)
 . . Q:'$$SUSPEND(.DTNEXT)
"RTN","ROREXT01",44,0)
 . . ;--- Suspend the task during the peak hours
"RTN","ROREXT01",45,0)
 . . F  D  Q:'TH!(RC<0)
"RTN","ROREXT01",46,0)
 . . . S TH=$$FMDIFF^XLFDT(DTNEXT,$$NOW^XLFDT,2)
"RTN","ROREXT01",47,0)
 . . . I TH<60  S TH=0  Q       ; Do not HANG for less than a
"RTN","ROREXT01",48,0)
 . . . H $S(TH>3600:3600,1:TH)  ; minute and more than an hour
"RTN","ROREXT01",49,0)
 . . . ;--- Check if task stop has been requested
"RTN","ROREXT01",50,0)
 . . . S:$$S^%ZTLOAD RC=$$ERROR^RORERR(-42)
"RTN","ROREXT01",51,0)
 . ;--- Process the registry record
"RTN","ROREXT01",52,0)
 . S CNT=CNT+1
"RTN","ROREXT01",53,0)
 . I $G(RORPARM("DEBUG"))>1  W:$E($G(IOST),1,2)="C-" *13,CNT
"RTN","ROREXT01",54,0)
 . S RC=$$PROCREC(REGIEN,IIEN,.PATIEN)
"RTN","ROREXT01",55,0)
 . ;--- Process the error (if any)
"RTN","ROREXT01",56,0)
 . I RC<0  D  S:$G(RORPARM("DEBUG"))<3 RC=0  Q
"RTN","ROREXT01",57,0)
 . . S ECNT=ECNT+1,RC=$$ERROR^RORERR(-15,,,$G(PATIEN))
"RTN","ROREXT01",58,0)
 . ;--- Check size of the HL7 batch message
"RTN","ROREXT01",59,0)
 . S RC=$$ISMAXSZ^RORHL7()
"RTN","ROREXT01",60,0)
 Q:RC<0 RC
"RTN","ROREXT01",61,0)
 ;--- Record a message to the log if the data extraction has
"RTN","ROREXT01",62,0)
 ;--- hit the maximum HL7 message size.
"RTN","ROREXT01",63,0)
 I IIEN  K RORBUF  D  D LOG^RORLOG(2,RORBUF,,.RORBUF)
"RTN","ROREXT01",64,0)
 . S RORBUF="Size of the HL7 message has reached its upper limit"
"RTN","ROREXT01",65,0)
 . S RORBUF(1)="Remaining data will be sent next time."
"RTN","ROREXT01",66,0)
 ;--- Remember IEN of the last processed registry record if
"RTN","ROREXT01",67,0)
 ;    the data extraction has hit the maximum HL7 message size.
"RTN","ROREXT01",68,0)
 ;--- Otherwise, clear the LAST IEN EXTRACTED field.
"RTN","ROREXT01",69,0)
 K RORBUF  S IENS=REGIEN_","
"RTN","ROREXT01",70,0)
 S RORBUF(798.1,IENS,2.4)=$S(IIEN:IIEN,1:"@")
"RTN","ROREXT01",71,0)
 D FILE^DIE(,"RORBUF","RORMSG")
"RTN","ROREXT01",72,0)
 I $G(DIERR)  D  Q RC
"RTN","ROREXT01",73,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","ROREXT01",74,0)
 ;--- Return number of processed records and number of errors
"RTN","ROREXT01",75,0)
 Q CNT_U_ECNT
"RTN","ROREXT01",76,0)
 ;
"RTN","ROREXT01",77,0)
 ;***** PROCESS THE PATIENT'S RECORD IN THE REGISTRY
"RTN","ROREXT01",78,0)
 ;
"RTN","ROREXT01",79,0)
 ; REGIEN        Registry IEN
"RTN","ROREXT01",80,0)
 ; IIEN          IEN of the patient record in the registry
"RTN","ROREXT01",81,0)
 ; [.PATIEN]     Patient IEN is returned by this parameter
"RTN","ROREXT01",82,0)
 ;
"RTN","ROREXT01",83,0)
 ; Return Values:
"RTN","ROREXT01",84,0)
 ;       <0  Error Code
"RTN","ROREXT01",85,0)
 ;        0  Ok
"RTN","ROREXT01",86,0)
 ;
"RTN","ROREXT01",87,0)
PROCREC(REGIEN,IIEN,PATIEN) ;
"RTN","ROREXT01",88,0)
 N RORERRDL      ; Default error location
"RTN","ROREXT01",89,0)
 ;
"RTN","ROREXT01",90,0)
 N DXDTS,FS,IENS,MSHPTR,RC,RORBUF,RORFDA,RORMSG,RORMSH,TMP
"RTN","ROREXT01",91,0)
 D CLEAR^RORERR("PROCREC^ROREXT01")
"RTN","ROREXT01",92,0)
 S IENS=IIEN_",",PATIEN=0
"RTN","ROREXT01",93,0)
 ;--- Get the registry record data
"RTN","ROREXT01",94,0)
 D GETS^DIQ(798,IENS,".01;11","EI","RORBUF","RORMSG")
"RTN","ROREXT01",95,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","ROREXT01",96,0)
 S PATIEN=RORBUF(798,IENS,.01,"I")
"RTN","ROREXT01",97,0)
 ;--- Skip a record tagged as "DON'T SEND"
"RTN","ROREXT01",98,0)
 Q:$G(RORBUF(798,IENS,11,"I")) 0
"RTN","ROREXT01",99,0)
 ;--- Prepare the data extraction time frames
"RTN","ROREXT01",100,0)
 S RC=$$DXPERIOD^ROREXTUT(.DXDTS,IIEN,PATIEN)
"RTN","ROREXT01",101,0)
 I RC  Q:RC<0 RC  D:$G(RORPARM("DEBUG"))  Q 0
"RTN","ROREXT01",102,0)
 . D LOG^RORLOG(4,"There is no data to extract.",PATIEN)
"RTN","ROREXT01",103,0)
 ;
"RTN","ROREXT01",104,0)
 ;--- Create an HL7 message for the patient
"RTN","ROREXT01",105,0)
 S MSHPTR=$$CREATE^RORHL7(.RORMSH)  Q:MSHPTR<0 MSHPTR
"RTN","ROREXT01",106,0)
 I $G(ROREXT("MSGBLD"))'=""  D
"RTN","ROREXT01",107,0)
 . X "S RC="_ROREXT("MSGBLD")_"(IIEN,PATIEN,.DXDTS)"
"RTN","ROREXT01",108,0)
 E  S RC=$$MESSAGE^ROREXT02(IIEN,PATIEN,.DXDTS)
"RTN","ROREXT01",109,0)
 ;
"RTN","ROREXT01",110,0)
 ;--- Delete the unfinished message from the ^TMP("HLS",$J)
"RTN","ROREXT01",111,0)
 ;    if there is no data to send (RC>0) or there was an error
"RTN","ROREXT01",112,0)
 ;    during the data extraction (RC<0). Return the error code
"RTN","ROREXT01",113,0)
 ;--- in the latter case.
"RTN","ROREXT01",114,0)
 I RC!($O(^TMP("HLS",$J,""),-1)=MSHPTR)  D  Q:RC<0 RC
"RTN","ROREXT01",115,0)
 . D ROLLBACK^RORHL7(MSHPTR)  S:'RC RC=1
"RTN","ROREXT01",116,0)
 ;
"RTN","ROREXT01",117,0)
 K RORFDA,RORMSG
"RTN","ROREXT01",118,0)
 S FS=$E(RORMSH,4),IENS=IIEN_","
"RTN","ROREXT01",119,0)
 ;--- Store the Message ID in the registry record and reset
"RTN","ROREXT01",120,0)
 ;    the CAN BE DELETED flag if some data has been extracted
"RTN","ROREXT01",121,0)
 ;--- and the message for this patient will be sent
"RTN","ROREXT01",122,0)
 I 'RC  D  S RORFDA(798,IENS,12)="@"
"RTN","ROREXT01",123,0)
 . S RORFDA(798,IENS,10)=$P(RORMSH,FS,10)
"RTN","ROREXT01",124,0)
 ;--- Otherwise, populate the MESSAGE ID field with a fake ID
"RTN","ROREXT01",125,0)
 ;    (there is no message for this patient and there will be
"RTN","ROREXT01",126,0)
 ;    no application acknowledgement). This will force the
"RTN","ROREXT01",127,0)
 ;    acknowledgement processing to update the DATA ACKNOWLEDGED
"RTN","ROREXT01",128,0)
 ;    UNTIL field so that the next data extraction process will not
"RTN","ROREXT01",129,0)
 ;--- browse through the data already processed by the previous one.
"RTN","ROREXT01",130,0)
 S:RC RORFDA(798,IENS,10)=ROREXT("HL7MID")_"-0"
"RTN","ROREXT01",131,0)
 ;--- Always update the DATA EXTRACTED UNTIL field
"RTN","ROREXT01",132,0)
 S RORFDA(798,IENS,9.2)=$P(DXDTS,U,2)
"RTN","ROREXT01",133,0)
 ;--- Update the registry record
"RTN","ROREXT01",134,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","ROREXT01",135,0)
 S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,798,IENS)
"RTN","ROREXT01",136,0)
 Q $S(RC<0:RC,1:0)
"RTN","ROREXT01",137,0)
 ;
"RTN","ROREXT01",138,0)
 ;***** CHECKS IF THE TASK SHOULD BE SUSPENDED
"RTN","ROREXT01",139,0)
 ;
"RTN","ROREXT01",140,0)
 ; .DTNEXT       Date/Time of the next event (suspend/resume)
"RTN","ROREXT01",141,0)
 ;               is returned via this parameter
"RTN","ROREXT01",142,0)
 ;
"RTN","ROREXT01",143,0)
 ; Return Values:
"RTN","ROREXT01",144,0)
 ;        0  Continue/Resume
"RTN","ROREXT01",145,0)
 ;        1  Suspend
"RTN","ROREXT01",146,0)
 ;
"RTN","ROREXT01",147,0)
SUSPEND(DTNEXT) ;
"RTN","ROREXT01",148,0)
 N DATE,NOW,SUSPEND,TIME,TS,TR
"RTN","ROREXT01",149,0)
 S TS=$P(ROREXT("SUSPEND"),U,1)
"RTN","ROREXT01",150,0)
 S TR=$P(ROREXT("SUSPEND"),U,2)
"RTN","ROREXT01",151,0)
 S NOW=$$NOW^XLFDT,DATE=NOW\1
"RTN","ROREXT01",152,0)
 ;--- A work day
"RTN","ROREXT01",153,0)
 I $$WDCHK^RORUTL01(DATE)  D  Q SUSPEND
"RTN","ROREXT01",154,0)
 . S TIME=NOW-DATE,SUSPEND=0
"RTN","ROREXT01",155,0)
 . I TIME<TS   S DTNEXT=DATE+TS  Q
"RTN","ROREXT01",156,0)
 . I TIME'<TR  S DTNEXT=$$WDNEXT^RORUTL01(DATE)+TS  Q
"RTN","ROREXT01",157,0)
 . S DTNEXT=DATE+TR,SUSPEND=1
"RTN","ROREXT01",158,0)
 ;--- Saturday, Sunday or Holiday
"RTN","ROREXT01",159,0)
 S DTNEXT=$$WDNEXT^RORUTL01(DATE)+TS
"RTN","ROREXT01",160,0)
 Q 0
"RTN","ROREXT02")
0^8^B27066170
"RTN","ROREXT02",1,0)
ROREXT02 ;HCIOFO/SG - DEFAULT MESSAGE BUILDER ; 1/23/04 3:59pm
"RTN","ROREXT02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","ROREXT02",3,0)
 ;
"RTN","ROREXT02",4,0)
 Q
"RTN","ROREXT02",5,0)
 ;
"RTN","ROREXT02",6,0)
 ;***** EXTRACTS AND PREPARES LABORATORY DATA
"RTN","ROREXT02",7,0)
 ;
"RTN","ROREXT02",8,0)
 ; PATIEN        Patient IEN
"RTN","ROREXT02",9,0)
 ;
"RTN","ROREXT02",10,0)
 ; STDT          Extract from this date
"RTN","ROREXT02",11,0)
 ; ENDT          Extract until this date
"RTN","ROREXT02",12,0)
 ;
"RTN","ROREXT02",13,0)
 ; [HDTMODE]     If this parameter is defined and non-zero, start and
"RTN","ROREXT02",14,0)
 ;               end dates are specimen collection dates. Otherwise,
"RTN","ROREXT02",15,0)
 ;               they are dates of the results.
"RTN","ROREXT02",16,0)
 ;
"RTN","ROREXT02",17,0)
 ; The function uses node ^TMP("RORTMP",$J) as a temporary storage.
"RTN","ROREXT02",18,0)
 ;
"RTN","ROREXT02",19,0)
 ; Return Values:
"RTN","ROREXT02",20,0)
 ;       <0  Error Code
"RTN","ROREXT02",21,0)
 ;        0  Ok
"RTN","ROREXT02",22,0)
 ;
"RTN","ROREXT02",23,0)
LABDATA(PATIEN,STDT,ENDT,HDTMODE) ;
"RTN","ROREXT02",24,0)
 N RC,RORTMP,TMP
"RTN","ROREXT02",25,0)
 S RORTMP=$NA(^TMP("RORTMP",$J))
"RTN","ROREXT02",26,0)
 ;--- Get the Lab results
"RTN","ROREXT02",27,0)
 S TMP=$S($G(HDTMODE):"^CD",1:"^RAD")
"RTN","ROREXT02",28,0)
 S RC=$$LABRSLTS^RORUTL02(PATIEN,STDT_TMP,ENDT_TMP)
"RTN","ROREXT02",29,0)
 Q:RC<0 RC
"RTN","ROREXT02",30,0)
 ;--- Call the Lab data post-processor
"RTN","ROREXT02",31,0)
 S RC=$$LABPROC(RORTMP,PATIEN)
"RTN","ROREXT02",32,0)
 ;---
"RTN","ROREXT02",33,0)
 K @RORTMP
"RTN","ROREXT02",34,0)
 Q $S(RC<0:RC,1:0)
"RTN","ROREXT02",35,0)
 ;
"RTN","ROREXT02",36,0)
 ;***** DEFAULT LABORATORY DATA POST-PROCESSOR
"RTN","ROREXT02",37,0)
 ;
"RTN","ROREXT02",38,0)
 ; ROR8TMP       Closed root of the array (local or global), which
"RTN","ROREXT02",39,0)
 ;               contains the data loaded by the $$GCPR^LA7QRY
"RTN","ROREXT02",40,0)
 ;
"RTN","ROREXT02",41,0)
 ; PATIEN        Patient IEN
"RTN","ROREXT02",42,0)
 ;
"RTN","ROREXT02",43,0)
 ; Return Values:
"RTN","ROREXT02",44,0)
 ;       <0  Error Code
"RTN","ROREXT02",45,0)
 ;        0  Ok
"RTN","ROREXT02",46,0)
 ;
"RTN","ROREXT02",47,0)
LABPROC(ROR8TMP,PATIEN) ;
"RTN","ROREXT02",48,0)
 N BUF,CS,FS,I,J,SEG,SITE
"RTN","ROREXT02",49,0)
 ;--- Extract separators from the MSH segment
"RTN","ROREXT02",50,0)
 S BUF=$G(@ROR8TMP@(1))
"RTN","ROREXT02",51,0)
 S:$E(BUF,1,3)="MSH" FS=$E(BUF,4),CS=$E(BUF,5)
"RTN","ROREXT02",52,0)
 S:$G(FS)="" FS="|"  S:$G(CS)="" CS="^"
"RTN","ROREXT02",53,0)
 ;--- Get the default station number and name
"RTN","ROREXT02",54,0)
 S SITE=$$SITE^RORUTL03(CS)
"RTN","ROREXT02",55,0)
 ;
"RTN","ROREXT02",56,0)
 ;--- Add the results to the message
"RTN","ROREXT02",57,0)
 S I=0
"RTN","ROREXT02",58,0)
 F  S I=$O(@ROR8TMP@(I))  Q:I=""  D
"RTN","ROREXT02",59,0)
 . S SEG(1)=$P(@ROR8TMP@(I),FS)  Q:SEG(1)=""
"RTN","ROREXT02",60,0)
 . ;--- Ignore unnecessary segments
"RTN","ROREXT02",61,0)
 . Q:'$D(ROREXT("HL7",1,SEG(1)))
"RTN","ROREXT02",62,0)
 . ;--- Load the full segment
"RTN","ROREXT02",63,0)
 . D LOAD^RORHL7A(.SEG,ROR8TMP,I)
"RTN","ROREXT02",64,0)
 . ;--- Replace the local station with the default one
"RTN","ROREXT02",65,0)
 . I SEG(1)="OBX"  S:$P($G(SEG(16)),CS)="" SEG(16)=DFLTSITE
"RTN","ROREXT02",66,0)
 . ;--- Store the segment
"RTN","ROREXT02",67,0)
 . D SAVE^RORHL7A(.SEG)
"RTN","ROREXT02",68,0)
 Q 0
"RTN","ROREXT02",69,0)
 ;
"RTN","ROREXT02",70,0)
 ;***** EXTRACTS PATIENT DATA AND CREATES A MESSAGE BODY
"RTN","ROREXT02",71,0)
 ;
"RTN","ROREXT02",72,0)
 ; RORIEN        IEN of the patient record in the registry
"RTN","ROREXT02",73,0)
 ;
"RTN","ROREXT02",74,0)
 ; PATIEN        Patient IEN
"RTN","ROREXT02",75,0)
 ;
"RTN","ROREXT02",76,0)
 ; .DXDTS        Either a single time frame in StartDate^EndDate
"RTN","ROREXT02",77,0)
 ;               format or a reference to a local variable containing
"RTN","ROREXT02",78,0)
 ;               the list of data extraction time frames. The main
"RTN","ROREXT02",79,0)
 ;               time frame should be stored in the root node:
"RTN","ROREXT02",80,0)
 ;
"RTN","ROREXT02",81,0)
 ;  DXDTS(         MainStartDate^MainEndDate  (FileMan)
"RTN","ROREXT02",82,0)
 ;    DataArea,
"RTN","ROREXT02",83,0)
 ;      i)         StartDate^EndDate          (FileMan)
"RTN","ROREXT02",84,0)
 ;
"RTN","ROREXT02",85,0)
 ;               See the $$DXPERIOD^ROREXTUT function for details.
"RTN","ROREXT02",86,0)
 ;
"RTN","ROREXT02",87,0)
 ; [HDTMODE]     This parameter is defined and non-zero during the
"RTN","ROREXT02",88,0)
 ;               historical data extraction.
"RTN","ROREXT02",89,0)
 ;
"RTN","ROREXT02",90,0)
 ; Return Values:
"RTN","ROREXT02",91,0)
 ;       <0  Error Code
"RTN","ROREXT02",92,0)
 ;        0  Ok
"RTN","ROREXT02",93,0)
 ;       >0  Nothing to send
"RTN","ROREXT02",94,0)
 ;
"RTN","ROREXT02",95,0)
MESSAGE(RORIEN,PATIEN,DXDTS,HDTMODE) ;
"RTN","ROREXT02",96,0)
 N RORDEM        ; Update demographics
"RTN","ROREXT02",97,0)
 N RORFDA        ; Array containing values from the registry record
"RTN","ROREXT02",98,0)
 N RORLOC        ; Update local registry data
"RTN","ROREXT02",99,0)
 ;
"RTN","ROREXT02",100,0)
 N DATAPTR,DEMPTR,ENDT,FIELDS,IENS,LOCPTR,RBPTR,RC,RORBUF,RORMSG,RORPTR,STDT
"RTN","ROREXT02",101,0)
 S IENS=RORIEN_",",HDTMODE=+$G(HDTMODE)
"RTN","ROREXT02",102,0)
 ;--- If only the main time frame is provided then
"RTN","ROREXT02",103,0)
 ;--- generate the data-specific ones automatically
"RTN","ROREXT02",104,0)
 I $D(DXDTS)<10  D  D DXMERGE^ROREXTUT(.DXDTS)
"RTN","ROREXT02",105,0)
 . D DXADD^ROREXTUT(.DXDTS,$P(DXDTS,U),$P(DXDTS,U,2),0,1)
"RTN","ROREXT02",106,0)
 S STDT=$P(DXDTS,U),ENDT=$P(DXDTS,U,2)
"RTN","ROREXT02",107,0)
 ;--- Get the registry record data
"RTN","ROREXT02",108,0)
 D GETS^DIQ(798,IENS,"4;5","I","RORFDA","RORMSG")
"RTN","ROREXT02",109,0)
 I $G(DIERR)  D  Q RC
"RTN","ROREXT02",110,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,798,IENS)
"RTN","ROREXT02",111,0)
 S RORDEM=+$G(RORFDA(798,IENS,4,"I"))
"RTN","ROREXT02",112,0)
 S RORLOC=+$G(RORFDA(798,IENS,5,"I"))
"RTN","ROREXT02",113,0)
 ;--- Initialize environment variables
"RTN","ROREXT02",114,0)
 S RC=$$INIT^RORHL7()  Q:RC<0 RC
"RTN","ROREXT02",115,0)
 ;
"RTN","ROREXT02",116,0)
 ;=== Add patient data segments
"RTN","ROREXT02",117,0)
 ;
"RTN","ROREXT02",118,0)
 S DEMPTR=$$PTR^RORHL7
"RTN","ROREXT02",119,0)
 S RC=$$PID^RORHL01(PATIEN)      Q:RC<0 RC
"RTN","ROREXT02",120,0)
 ;--- Period of Servise
"RTN","ROREXT02",121,0)
 I $D(ROREXT("HL7",5,"ZSP"))  D  Q:RC<0 RC
"RTN","ROREXT02",122,0)
 . S RC=$$ZSP^RORHL01(PATIEN)
"RTN","ROREXT02",123,0)
 ;--- Rated Disabilities
"RTN","ROREXT02",124,0)
 I $D(ROREXT("HL7",5,"ZRD"))  D  Q:RC<0 RC
"RTN","ROREXT02",125,0)
 . S RC=$$ZRD^RORHL01(PATIEN)
"RTN","ROREXT02",126,0)
 ;
"RTN","ROREXT02",127,0)
 ;=== Add local registry data segments
"RTN","ROREXT02",128,0)
 ;
"RTN","ROREXT02",129,0)
 S LOCPTR=$$PTR^RORHL7
"RTN","ROREXT02",130,0)
 I $D(ROREXT("HL7",5,"CSR"))  D  Q:RC<0 RC
"RTN","ROREXT02",131,0)
 . S FIELDS=$P(ROREXT("HL7",5,"CSR"),U,2)
"RTN","ROREXT02",132,0)
 . S RC=$$CSR^RORHL02(IENS,FIELDS)
"RTN","ROREXT02",133,0)
 I $D(ROREXT("HL7",5,"CSP"))  D  Q:RC<0 RC
"RTN","ROREXT02",134,0)
 . S FIELDS=$P(ROREXT("HL7",5,"CSP"),U,2)
"RTN","ROREXT02",135,0)
 . S RC=$$CSP^RORHL02(IENS,FIELDS)
"RTN","ROREXT02",136,0)
 I $D(ROREXT("HL7",5,"CSS"))  D  Q:RC<0 RC
"RTN","ROREXT02",137,0)
 . S FIELDS=$P(ROREXT("HL7",5,"CSS"),U,2)
"RTN","ROREXT02",138,0)
 . S RC=$$CSS^RORHL02(IENS,FIELDS)
"RTN","ROREXT02",139,0)
 ;
"RTN","ROREXT02",140,0)
 ;=== Add other encounter data segments
"RTN","ROREXT02",141,0)
 ;
"RTN","ROREXT02",142,0)
 S DATAPTR=$$PTR^RORHL7
"RTN","ROREXT02",143,0)
 ;--- Pharmacy
"RTN","ROREXT02",144,0)
 I $D(ROREXT("HL7",6))>1  D  Q:RC<0 RC
"RTN","ROREXT02",145,0)
 . S RC=$$EN1^RORHL03(PATIEN,STDT,ENDT)
"RTN","ROREXT02",146,0)
 ;--- Radiology
"RTN","ROREXT02",147,0)
 I $D(ROREXT("HL7",4))>1  D  Q:RC<0 RC
"RTN","ROREXT02",148,0)
 . S RC=$$EN1^RORHL04(PATIEN,STDT,ENDT)
"RTN","ROREXT02",149,0)
 ;--- Autopsy
"RTN","ROREXT02",150,0)
 I $D(ROREXT("HL7",7))>1  D  Q:RC<0 RC
"RTN","ROREXT02",151,0)
 . S RC=$$EN1^RORHL05(PATIEN)
"RTN","ROREXT02",152,0)
 ;--- Liver Biopsy
"RTN","ROREXT02",153,0)
 I $D(ROREXT("HL7",8))>1  D  Q:RC<0 RC
"RTN","ROREXT02",154,0)
 . S RC=$$EN1^RORHL06(PATIEN,STDT,ENDT)
"RTN","ROREXT02",155,0)
 ;--- Lab Data
"RTN","ROREXT02",156,0)
 I $D(ROREXT("HL7",1))>1  D  Q:RC<0 RC
"RTN","ROREXT02",157,0)
 . S RC=$$LABDATA(PATIEN,STDT,ENDT,HDTMODE)
"RTN","ROREXT02",158,0)
 ;
"RTN","ROREXT02",159,0)
 ;=== Analyze structure of the message
"RTN","ROREXT02",160,0)
 S RORPTR=$$PTR^RORHL7,RC=0
"RTN","ROREXT02",161,0)
 I RORPTR'>DATAPTR  D
"RTN","ROREXT02",162,0)
 . S RBPTR=RORPTR
"RTN","ROREXT02",163,0)
 . ;--- Do not send local registry data segments if the UPDATE LOCAL
"RTN","ROREXT02",164,0)
 . ;    REGISTRY DATA flag is not set and there is no other
"RTN","ROREXT02",165,0)
 . ;--- VistA data to be sent
"RTN","ROREXT02",166,0)
 . I 'RORLOC!(RORPTR'>LOCPTR)  S RBPTR=LOCPTR  D
"RTN","ROREXT02",167,0)
 . . ;--- Do not send a message containing only the patient data
"RTN","ROREXT02",168,0)
 . . ;--- segments if the UPDATE DEMOGRAPHICS flag is not set
"RTN","ROREXT02",169,0)
 . . S:'RORDEM RBPTR=DEMPTR
"RTN","ROREXT02",170,0)
 . ;--- Delete unnecessary segments
"RTN","ROREXT02",171,0)
 . F  Q:RORPTR'>RBPTR  D  S RORPTR=$O(^TMP("HLS",$J,RORPTR),-1)
"RTN","ROREXT02",172,0)
 . . K ^TMP("HLS",$J,RORPTR)
"RTN","ROREXT02",173,0)
 . S RC=RORPTR'>DEMPTR
"RTN","ROREXT02",174,0)
 Q RC
"RTN","ROREXTUT")
0^85^B44618156
"RTN","ROREXTUT",1,0)
ROREXTUT ;HCIOFO/SG - DATA EXTRACT UTILITIES  ; 12/19/03 1:16pm
"RTN","ROREXTUT",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","ROREXTUT",3,0)
 ;
"RTN","ROREXTUT",4,0)
 Q
"RTN","ROREXTUT",5,0)
 ;
"RTN","ROREXTUT",6,0)
 ;***** CHECKS ACKNOWLEDGEMENT FLAG OF THE REGISTRY
"RTN","ROREXTUT",7,0)
 ;
"RTN","ROREXTUT",8,0)
 ; REGNAME       Registry name
"RTN","ROREXTUT",9,0)
 ;
"RTN","ROREXTUT",10,0)
 ; Return Values:
"RTN","ROREXTUT",11,0)
 ;       <0  Error Code
"RTN","ROREXTUT",12,0)
 ;        0  Ok
"RTN","ROREXTUT",13,0)
 ;        1  The acknowledgement flag is set
"RTN","ROREXTUT",14,0)
 ;
"RTN","ROREXTUT",15,0)
ACKWAIT(REGNAME) ;
"RTN","ROREXTUT",16,0)
 N REGIEN,RC,TMP
"RTN","ROREXTUT",17,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)  Q:REGIEN<0 REGIEN
"RTN","ROREXTUT",18,0)
 S TMP=+$$GET1^DIQ(798.1,REGIEN_",",2.2,"I",,"RORMSG")
"RTN","ROREXTUT",19,0)
 I $G(DIERR)  D  Q RC
"RTN","ROREXTUT",20,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.1,REGIEN)
"RTN","ROREXTUT",21,0)
 Q TMP
"RTN","ROREXTUT",22,0)
 ;
"RTN","ROREXTUT",23,0)
 ;***** ADDS THE TIME FRAME TO THE LIST
"RTN","ROREXTUT",24,0)
 ;
"RTN","ROREXTUT",25,0)
 ; .DXDTS        Reference to a local variable where the
"RTN","ROREXTUT",26,0)
 ;               data extraction time frames are stored.
"RTN","ROREXTUT",27,0)
 ;
"RTN","ROREXTUT",28,0)
 ; STDT          Start date (FileMan)
"RTN","ROREXTUT",29,0)
 ; ENDT          End Date   (FileMan)
"RTN","ROREXTUT",30,0)
 ;
"RTN","ROREXTUT",31,0)
 ; DTAR          Data area code:
"RTN","ROREXTUT",32,0)
 ;                 3  Inpatient
"RTN","ROREXTUT",33,0)
 ;                 6  Pharmacy
"RTN","ROREXTUT",34,0)
 ;
"RTN","ROREXTUT",35,0)
 ; [MAIN]        If this parameter defined and not zero, the time
"RTN","ROREXTUT",36,0)
 ;               frame is considered the main one.
"RTN","ROREXTUT",37,0)
 ;
"RTN","ROREXTUT",38,0)
 ; Variants of positional relationship of the existing time frames
"RTN","ROREXTUT",39,0)
 ; and the one that is being added to the list (STDT-ENDT):
"RTN","ROREXTUT",40,0)
 ;
"RTN","ROREXTUT",41,0)
 ; (1)  +--------TMP                      +----------+
"RTN","ROREXTUT",42,0)
 ;                     STDT--------ENDT
"RTN","ROREXTUT",43,0)
 ;
"RTN","ROREXTUT",44,0)
 ; (2)           +--------TMP
"RTN","ROREXTUT",45,0)
 ;      STDT--------ENDT
"RTN","ROREXTUT",46,0)
 ;
"RTN","ROREXTUT",47,0)
 ; (3)  TMP--------+
"RTN","ROREXTUT",48,0)
 ;           STDT--------ENDT
"RTN","ROREXTUT",49,0)
 ;
"RTN","ROREXTUT",50,0)
 ; (4)         +--------+
"RTN","ROREXTUT",51,0)
 ;      STDT------------------ENDT
"RTN","ROREXTUT",52,0)
 ;
"RTN","ROREXTUT",53,0)
DXADD(DXDTS,STDT,ENDT,DTAR,MAIN) ;
"RTN","ROREXTUT",54,0)
 Q:STDT>ENDT
"RTN","ROREXTUT",55,0)
 S:$G(MAIN) DXDTS=STDT_U_ENDT,DTAR=0
"RTN","ROREXTUT",56,0)
 N DATE,EXIT,TMP
"RTN","ROREXTUT",57,0)
 ;--- Merge the time frames if possible
"RTN","ROREXTUT",58,0)
 S DATE=$O(DXDTS(DTAR,ENDT)),EXIT=0
"RTN","ROREXTUT",59,0)
 F  S DATE=$O(DXDTS(DTAR,DATE),-1)  Q:DATE=""  D  Q:EXIT
"RTN","ROREXTUT",60,0)
 . S TMP=$P(DXDTS(DTAR,DATE),U,2)
"RTN","ROREXTUT",61,0)
 . I TMP<STDT  S EXIT=1  Q          ; (1)
"RTN","ROREXTUT",62,0)
 . S:TMP>ENDT ENDT=TMP              ; (2)
"RTN","ROREXTUT",63,0)
 . S TMP=$P(DXDTS(DTAR,DATE),U)
"RTN","ROREXTUT",64,0)
 . S:TMP<STDT STDT=TMP              ; (3)
"RTN","ROREXTUT",65,0)
 . K DXDTS(DTAR,DATE)
"RTN","ROREXTUT",66,0)
 ;--- Store the new time frame
"RTN","ROREXTUT",67,0)
 S DXDTS(DTAR,STDT)=STDT_U_ENDT
"RTN","ROREXTUT",68,0)
 Q
"RTN","ROREXTUT",69,0)
 ;
"RTN","ROREXTUT",70,0)
 ;***** CALCULATES THE MAIN DATA EXTRACTION TIME FRAME
"RTN","ROREXTUT",71,0)
 ;
"RTN","ROREXTUT",72,0)
 ; .DXDTS        Reference to a local variable where the
"RTN","ROREXTUT",73,0)
 ;               data extraction time frames are stored.
"RTN","ROREXTUT",74,0)
 ;
"RTN","ROREXTUT",75,0)
 ; IEN           IEN of the patient's record in the registry
"RTN","ROREXTUT",76,0)
 ;
"RTN","ROREXTUT",77,0)
 ; Return Values:
"RTN","ROREXTUT",78,0)
 ;        <0  Error Code
"RTN","ROREXTUT",79,0)
 ;         0  Ok
"RTN","ROREXTUT",80,0)
 ;        >0  Skip the patient
"RTN","ROREXTUT",81,0)
 ;
"RTN","ROREXTUT",82,0)
 ; If the special extraction start date for all patients is defined
"RTN","ROREXTUT",83,0)
 ; then it is as the start date of the main time frame. Usually,
"RTN","ROREXTUT",84,0)
 ; this mode is not used. ;-)
"RTN","ROREXTUT",85,0)
 ;
"RTN","ROREXTUT",86,0)
 ; If the field #9.1 of the patient record in the registry (#798)
"RTN","ROREXTUT",87,0)
 ; has a value then this value is used as the styart date of the
"RTN","ROREXTUT",88,0)
 ; main time frame (data have already been extracted until that
"RTN","ROREXTUT",89,0)
 ; date). Usually, this field should be empty for new patients.
"RTN","ROREXTUT",90,0)
 ;
"RTN","ROREXTUT",91,0)
 ; The function tries to get the earliest date when a selection rule
"RTN","ROREXTUT",92,0)
 ; has been triggered for the newly added patient. If the patient has
"RTN","ROREXTUT",93,0)
 ; been added manually and there are no selection rules in the
"RTN","ROREXTUT",94,0)
 ; SELECTION RULE multiple of the registry record then a date when
"RTN","ROREXTUT",95,0)
 ; the patient was added to the registry is used.
"RTN","ROREXTUT",96,0)
 ;
"RTN","ROREXTUT",97,0)
 ; After that, extract period for new patients (value of the field
"RTN","ROREXTUT",98,0)
 ; #7 of the file #798.1) is subtracted from the date and the result
"RTN","ROREXTUT",99,0)
 ; is used as the start date. If the extract period is not set for
"RTN","ROREXTUT",100,0)
 ; the registry then a default value (365) is used.
"RTN","ROREXTUT",101,0)
 ;
"RTN","ROREXTUT",102,0)
DXMAIN(DXDTS,IEN) ;
"RTN","ROREXTUT",103,0)
 N DTENT,ENDT,IENS,INCTVDT,LCH,NEWPAT,RC,RORBUF,RORMSG,STDT,TMP
"RTN","ROREXTUT",104,0)
 S (ENDT,STDT)="",IENS=IEN_",",LCH=0
"RTN","ROREXTUT",105,0)
 ;--- Get the registry record data
"RTN","ROREXTUT",106,0)
 D GETS^DIQ(798,IENS,"1;2;3;4;5;9.1","I","RORBUF","RORMSG")
"RTN","ROREXTUT",107,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","ROREXTUT",108,0)
 S ENDT=$$FMADD^XLFDT(ROREXT("DXEND"),-$G(ROREXT("LD",1)))
"RTN","ROREXTUT",109,0)
 F TMP=3,4,5  S:$G(RORBUF(798,IENS,TMP,"I")) LCH=1
"RTN","ROREXTUT",110,0)
 ;--- Data is not extracted after the inactivation date
"RTN","ROREXTUT",111,0)
 S TMP=$$GET1^DIQ(798,IENS,8,"E",,"RORMSG")
"RTN","ROREXTUT",112,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","ROREXTUT",113,0)
 I 'TMP  D  S:ENDT>INCTVDT ENDT=INCTVDT
"RTN","ROREXTUT",114,0)
 . S INCTVDT=$G(RORBUF(798,IENS,2,"I"))\1
"RTN","ROREXTUT",115,0)
 ;--- Special start date for ALL patients (if defined)
"RTN","ROREXTUT",116,0)
 S STDT=$G(ROREXT("DXBEG"))
"RTN","ROREXTUT",117,0)
 I STDT'>0  D
"RTN","ROREXTUT",118,0)
 . ;--- Start date from the patient's record in the registry
"RTN","ROREXTUT",119,0)
 . S STDT=$G(RORBUF(798,IENS,9.1,"I"))\1  Q:STDT>0
"RTN","ROREXTUT",120,0)
 . ;--- Determine the start date for a newly added patient
"RTN","ROREXTUT",121,0)
 . S DTENT=$G(RORBUF(798,IENS,1,"I"))
"RTN","ROREXTUT",122,0)
 . S NEWPAT=+$G(RORBUF(798,IENS,3,"I"))
"RTN","ROREXTUT",123,0)
 . ;--- Usually, data for 'pending' patients (NEWPAT=4) is not
"RTN","ROREXTUT",124,0)
 . ;    sent to the AAC (see the $$PROCREC^ROREXT01 function).
"RTN","ROREXTUT",125,0)
 . ;    However, this function considers a 'pending' patient as
"RTN","ROREXTUT",126,0)
 . ;--- a usual new one.
"RTN","ROREXTUT",127,0)
 . I (NEWPAT=1)!(NEWPAT=2)!(NEWPAT=4)  D
"RTN","ROREXTUT",128,0)
 . . S TMP=$$ROOT^DILFD(798.01,","_IENS,1)  Q:TMP=""
"RTN","ROREXTUT",129,0)
 . . S STDT=$O(@TMP@("AD","")) ; The earliest selection rule
"RTN","ROREXTUT",130,0)
 . . I STDT'>0  S STDT=DTENT  Q:STDT'>0
"RTN","ROREXTUT",131,0)
 . . S TMP=+$G(ROREXT("EXTRDAYS"))
"RTN","ROREXTUT",132,0)
 . . S STDT=$$FMADD^XLFDT(STDT,-$S(TMP>0:TMP,1:365))\1
"RTN","ROREXTUT",133,0)
 . S:STDT'>0 STDT=DTENT\1
"RTN","ROREXTUT",134,0)
 ;--- Check the dates and add the time frame to the list
"RTN","ROREXTUT",135,0)
 I (STDT'>0)!(ENDT'>0)  D  Q RC
"RTN","ROREXTUT",136,0)
 . S TMP=$$GET1^DIQ(798,IENS,.01,"I",,"RORMSG")
"RTN","ROREXTUT",137,0)
 . S RC=$$ERROR^RORERR(-32,,,TMP,STDT,ENDT)
"RTN","ROREXTUT",138,0)
 S RC=0
"RTN","ROREXTUT",139,0)
 I STDT'<ENDT  S RC=1  S:LCH STDT=ENDT,RC=0
"RTN","ROREXTUT",140,0)
 D:'RC DXADD(.DXDTS,STDT,ENDT,0,1)
"RTN","ROREXTUT",141,0)
 Q RC
"RTN","ROREXTUT",142,0)
 ;
"RTN","ROREXTUT",143,0)
 ;***** MERGES THE MAIN TIME FRAME INTO THE 'DATA-SPECIFIC' LISTS
"RTN","ROREXTUT",144,0)
 ;
"RTN","ROREXTUT",145,0)
 ; .DXDTS        Reference to a local variable where the
"RTN","ROREXTUT",146,0)
 ;               data extraction time frames are stored.
"RTN","ROREXTUT",147,0)
 ;
"RTN","ROREXTUT",148,0)
DXMERGE(DXDTS) ;
"RTN","ROREXTUT",149,0)
 N DTAR
"RTN","ROREXTUT",150,0)
 F DTAR=2,3,6  D DXADD(.DXDTS,$P(DXDTS,U),$P(DXDTS,U,2),DTAR)
"RTN","ROREXTUT",151,0)
 Q
"RTN","ROREXTUT",152,0)
 ;
"RTN","ROREXTUT",153,0)
 ;***** RETURNS THE LISTS OF DATA EXTRACTION PERIODS FOR THE PATIENT
"RTN","ROREXTUT",154,0)
 ;
"RTN","ROREXTUT",155,0)
 ; .DXDTS        Reference to a local variable where the data
"RTN","ROREXTUT",156,0)
 ;               extraction time frames are returned to. The
"RTN","ROREXTUT",157,0)
 ;               main time frame is returned in the root node:
"RTN","ROREXTUT",158,0)
 ;
"RTN","ROREXTUT",159,0)
 ;  DXDTS(         MainStartDate^MainEndDate  (FileMan)
"RTN","ROREXTUT",160,0)
 ;    DataArea,
"RTN","ROREXTUT",161,0)
 ;      i)         StartDate^EndDate          (FileMan)
"RTN","ROREXTUT",162,0)
 ;
"RTN","ROREXTUT",163,0)
 ; IEN           IEN of the patient record in the registry
"RTN","ROREXTUT",164,0)
 ;
"RTN","ROREXTUT",165,0)
 ; PATIEN        Patient IEN
"RTN","ROREXTUT",166,0)
 ;
"RTN","ROREXTUT",167,0)
 ; Return Values:
"RTN","ROREXTUT",168,0)
 ;        <0  Error Code
"RTN","ROREXTUT",169,0)
 ;         0  Ok
"RTN","ROREXTUT",170,0)
 ;        >0  Skip the patient
"RTN","ROREXTUT",171,0)
 ;
"RTN","ROREXTUT",172,0)
DXPERIOD(DXDTS,IEN,PATIEN) ;
"RTN","ROREXTUT",173,0)
 N AREA,ENDT,EVTDT,EVTIEN,NODE,RC,STDT,TMP
"RTN","ROREXTUT",174,0)
 K DXDTS  S DXDTS=""
"RTN","ROREXTUT",175,0)
 ;
"RTN","ROREXTUT",176,0)
 ;=== Main data extraction time frame
"RTN","ROREXTUT",177,0)
 S RC=$$DXMAIN(.DXDTS,IEN)  Q:RC RC
"RTN","ROREXTUT",178,0)
 ;
"RTN","ROREXTUT",179,0)
 ;=== Data-specific protocols (only Inpatient at present)
"RTN","ROREXTUT",180,0)
 S NODE=$NA(^RORDATA(798.3,+PATIEN,2))
"RTN","ROREXTUT",181,0)
 F AREA=3  D
"RTN","ROREXTUT",182,0)
 . ;--- Browse the events in the main time frame
"RTN","ROREXTUT",183,0)
 . S EVTDT=$O(@NODE@("AT",AREA,+DXDTS),-1)
"RTN","ROREXTUT",184,0)
 . S ENDT=+$P(DXDTS,U,2)
"RTN","ROREXTUT",185,0)
 . F  S EVTDT=$O(@NODE@("AT",AREA,EVTDT))  Q:'EVTDT!(EVTDT'<ENDT)  D
"RTN","ROREXTUT",186,0)
 . . S EVTIEN=""
"RTN","ROREXTUT",187,0)
 . . F  S EVTIEN=$O(@NODE@("AT",AREA,EVTDT,EVTIEN))  Q:EVTIEN=""  D
"RTN","ROREXTUT",188,0)
 . . . S TMP=$P($G(@NODE@(EVTIEN,0)),U,3)\1
"RTN","ROREXTUT",189,0)
 . . . D:TMP>0 DXADD(.DXDTS,TMP,$$FMADD^XLFDT(TMP,1),AREA)
"RTN","ROREXTUT",190,0)
 ;
"RTN","ROREXTUT",191,0)
 ;=== Data-specific 'sliding windows'
"RTN","ROREXTUT",192,0)
 ;S STDT=$$FMADD^XLFDT($P(DXDTS,U,1),-30)
"RTN","ROREXTUT",193,0)
 ;S ENDT=$$FMADD^XLFDT($P(DXDTS,U,2),-30)
"RTN","ROREXTUT",194,0)
 ;D DXADD(.DXDTS,STDT,ENDT,6)  ; Pharmacy
"RTN","ROREXTUT",195,0)
 ;
"RTN","ROREXTUT",196,0)
 ;=== Merge the main time frame into the data-specific ones
"RTN","ROREXTUT",197,0)
 D DXMERGE(.DXDTS)
"RTN","ROREXTUT",198,0)
 Q 0
"RTN","ROREXTUT",199,0)
 ;
"RTN","ROREXTUT",200,0)
 ;***** UPDATES DATA EXTRACTION PARAMETERS OF THE REGISTRY
"RTN","ROREXTUT",201,0)
 ;
"RTN","ROREXTUT",202,0)
 ; .REGLST       Reference to a local array containing registry names
"RTN","ROREXTUT",203,0)
 ;               as subscripts and optional registry IENs as values
"RTN","ROREXTUT",204,0)
 ; MID           Batch message ID returned by the GENERATE^HLMA
"RTN","ROREXTUT",205,0)
 ;
"RTN","ROREXTUT",206,0)
 ; Return values:
"RTN","ROREXTUT",207,0)
 ;       <0  Error code
"RTN","ROREXTUT",208,0)
 ;        0  Ok
"RTN","ROREXTUT",209,0)
 ;
"RTN","ROREXTUT",210,0)
TMSTMP(REGLST,MID) ;
"RTN","ROREXTUT",211,0)
 N DATE,RC,REGIEN,REGIENS,REGNAME,RORFDA,RORMSG
"RTN","ROREXTUT",212,0)
 S DATE=ROREXT("DXEND")\1
"RTN","ROREXTUT",213,0)
 S REGNAME="",RC=0
"RTN","ROREXTUT",214,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","ROREXTUT",215,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","ROREXTUT",216,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=+REGIEN  Q
"RTN","ROREXTUT",217,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","ROREXTUT",218,0)
 . S REGIENS=REGIEN_","
"RTN","ROREXTUT",219,0)
 . ;--- Check if the new date until that data has been extracted
"RTN","ROREXTUT",220,0)
 . ;    is greater than that stored in the registry parameters
"RTN","ROREXTUT",221,0)
 . S TMP=$$GET1^DIQ(798.1,REGIENS,2,"I",,"RORMSG")
"RTN","ROREXTUT",222,0)
 . I $G(DIERR)  D  Q
"RTN","ROREXTUT",223,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,798.1,REGIENS)
"RTN","ROREXTUT",224,0)
 . S:DATE>TMP RORFDA(798.1,REGIENS,2)=DATE
"RTN","ROREXTUT",225,0)
 . ;--- Update the Last Batch info only if something has been sent
"RTN","ROREXTUT",226,0)
 . D:$G(MID)'=""
"RTN","ROREXTUT",227,0)
 . . S RORFDA(798.1,REGIENS,2.1)=$G(ROREXT("HL7MID"))
"RTN","ROREXTUT",228,0)
 . . S RORFDA(798.1,REGIENS,2.2)=$$NOW^XLFDT
"RTN","ROREXTUT",229,0)
 . . S RORFDA(798.1,REGIENS,2.3)=MID
"RTN","ROREXTUT",230,0)
 . . ;--- Increment the number of retransmissions
"RTN","ROREXTUT",231,0)
 . . S TMP=$$GET1^DIQ(798.1,REGIENS,2.5,"I",,"RORMSG")
"RTN","ROREXTUT",232,0)
 . . S RORFDA(798.1,REGIENS,2.5)=TMP+1
"RTN","ROREXTUT",233,0)
 . ;--- Update registry parameters
"RTN","ROREXTUT",234,0)
 . Q:$D(RORFDA)<10
"RTN","ROREXTUT",235,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","ROREXTUT",236,0)
 . I $G(DIERR)  D  Q
"RTN","ROREXTUT",237,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,798.1,REGIENS)
"RTN","ROREXTUT",238,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORHDT01")
0^115^B8374312
"RTN","RORHDT01",1,0)
RORHDT01 ;HCIOFO/SG - HISTORICAL DATA EXTRACTION STATUS ; 9/29/03 3:03pm
"RTN","RORHDT01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHDT01",3,0)
 ;
"RTN","RORHDT01",4,0)
 Q
"RTN","RORHDT01",5,0)
 ;
"RTN","RORHDT01",6,0)
 ;***** DISPLAYS A LINE OF THE STATUS TABLE
"RTN","RORHDT01",7,0)
 ;
"RTN","RORHDT01",8,0)
 ; RORBUF        Field values from the record of the file #798.5
"RTN","RORHDT01",9,0)
 ;               returned by LIST^DIC
"RTN","RORHDT01",10,0)
 ;
"RTN","RORHDT01",11,0)
 ; IT            Index in the table
"RTN","RORHDT01",12,0)
 ;
"RTN","RORHDT01",13,0)
DSL(IT) ;
"RTN","RORHDT01",14,0)
 ;;!?2^StartIEN^$J($G(RORBUF("DILIST","ID",IT,.01)),8)
"RTN","RORHDT01",15,0)
 ;;?12^File Name^$G(RORBUF("DILIST","ID",IT,1.01))
"RTN","RORHDT01",16,0)
 ;;?45^Task^$G(RORBUF("DILIST","ID",IT,2.01))
"RTN","RORHDT01",17,0)
 ;;?55^Status^$G(RORBUF("DILIST","ID",IT,2.03))
"RTN","RORHDT01",18,0)
 ;
"RTN","RORHDT01",19,0)
 N I,TMP
"RTN","RORHDT01",20,0)
 ;--- Display the headers
"RTN","RORHDT01",21,0)
 I '$G(IT)  D  Q
"RTN","RORHDT01",22,0)
 . F I=1:1  S TMP=$P($T(DSL+I),";;",2,999)  Q:TMP=""  D
"RTN","RORHDT01",23,0)
 . . W @$TR($P(TMP,"^")," "),$P(TMP,"^",2)
"RTN","RORHDT01",24,0)
 ;--- Display the values
"RTN","RORHDT01",25,0)
 F I=1:1  S TMP=$P($T(DSL+I),";;",2,999)  Q:TMP=""  D
"RTN","RORHDT01",26,0)
 . W @$TR($P(TMP,"^")," "),@$P(TMP,"^",3)
"RTN","RORHDT01",27,0)
 Q
"RTN","RORHDT01",28,0)
 ;
"RTN","RORHDT01",29,0)
 ;***** DISPLAYS THE LATEST TASK LOG
"RTN","RORHDT01",30,0)
 ;
"RTN","RORHDT01",31,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT01",32,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT01",33,0)
 ;
"RTN","RORHDT01",34,0)
 ; Return Values:
"RTN","RORHDT01",35,0)
 ;       <0  Error code
"RTN","RORHDT01",36,0)
 ;        0  Ok
"RTN","RORHDT01",37,0)
 ;
"RTN","RORHDT01",38,0)
LOG(REGIEN,TASKIEN) ;
"RTN","RORHDT01",39,0)
 N IENS,IOP,LOGIEN,RC,RORMSG,TMP
"RTN","RORHDT01",40,0)
 ;--- Get the latest log IEN of the task
"RTN","RORHDT01",41,0)
 S IENS=TASKIEN_","
"RTN","RORHDT01",42,0)
 S LOGIEN=+$$GET1^DIQ(798.5,IENS,2.04,"I",,"RORMSG")
"RTN","RORHDT01",43,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.5,IENS)
"RTN","RORHDT01",44,0)
 ;--- Check if the log exists
"RTN","RORHDT01",45,0)
 I 'LOGIEN!'$D(^RORDATA(798.7,LOGIEN))  D  Q 0
"RTN","RORHDT01",46,0)
 . W !,"Sorry. The log is not available.",!
"RTN","RORHDT01",47,0)
 ;--- Print the log
"RTN","RORHDT01",48,0)
 S L=0,DIC=798.7
"RTN","RORHDT01",49,0)
 S BY="NUMBER;@,4,.01;@",FLDS="[ROR LOG]"
"RTN","RORHDT01",50,0)
 S (FR,TO)=LOGIEN
"RTN","RORHDT01",51,0)
 D EN1^DIP
"RTN","RORHDT01",52,0)
 Q 0
"RTN","RORHDT01",53,0)
 ;
"RTN","RORHDT01",54,0)
 ;***** DISPLAYS DATA EXTRACTION STATUS OF THE REGISTRY
"RTN","RORHDT01",55,0)
 ;
"RTN","RORHDT01",56,0)
 ; RORREG       Registry IEN
"RTN","RORHDT01",57,0)
 ;
"RTN","RORHDT01",58,0)
 ; Return Values:
"RTN","RORHDT01",59,0)
 ;       <0  Error code
"RTN","RORHDT01",60,0)
 ;        0  Ok
"RTN","RORHDT01",61,0)
 ;
"RTN","RORHDT01",62,0)
STATUS(RORREG) ;
"RTN","RORHDT01",63,0)
 N IENS,IT,RC,RORBUF,RORMSG,RUNNING,SCR,TASKIEN,TMP
"RTN","RORHDT01",64,0)
 S IENS=RORREG_","
"RTN","RORHDT01",65,0)
 ;--- Get values from the main record
"RTN","RORHDT01",66,0)
 D GETS^DIQ(798.1,IENS,".01;21.01;21.02;21.03","EI","RORBUF","RORMSG")
"RTN","RORHDT01",67,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","RORHDT01",68,0)
 ;--- Display the registry information
"RTN","RORHDT01",69,0)
 W !,"Registry: ",$G(RORBUF(798.1,IENS,.01,"E"))
"RTN","RORHDT01",70,0)
 W !,"========"
"RTN","RORHDT01",71,0)
 W !,"Start Date: ",$G(RORBUF(798.1,IENS,21.01,"E"))
"RTN","RORHDT01",72,0)
 W ?40,"End Date: ",$G(RORBUF(798.1,IENS,21.02,"E"))
"RTN","RORHDT01",73,0)
 W !,"Output Directory: ",$G(RORBUF(798.1,IENS,21.03,"E"))
"RTN","RORHDT01",74,0)
 ;--- Get a list of tasks
"RTN","RORHDT01",75,0)
 K RORBUF,RORMSG
"RTN","RORHDT01",76,0)
 S TMP="@;.01E;1.01E;2.01;2.02"
"RTN","RORHDT01",77,0)
 S SCR="I $P(^(0),U,2)=RORREG"
"RTN","RORHDT01",78,0)
 D LIST^DIC(798.5,,TMP,"Q",,,RORREG,"C",SCR,,"RORBUF","RORMSG")
"RTN","RORHDT01",79,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.5)
"RTN","RORHDT01",80,0)
 I $G(RORBUF("DILIST",0))<1  D  Q 0
"RTN","RORHDT01",81,0)
 . W !!,?10,"No tasks have been defined",!
"RTN","RORHDT01",82,0)
 ;--- Get status of the tasks
"RTN","RORHDT01",83,0)
 S IT=""
"RTN","RORHDT01",84,0)
 F  S IT=$O(RORBUF("DILIST","ID",IT))  Q:IT=""  D
"RTN","RORHDT01",85,0)
 . S TASKIEN=+RORBUF("DILIST",2,IT)
"RTN","RORHDT01",86,0)
 . S TMP=$$STATUS^RORHDTUT(RORREG,TASKIEN)
"RTN","RORHDT01",87,0)
 . S RORBUF("DILIST","ID",IT,2.03)=$P(TMP,U,2)
"RTN","RORHDT01",88,0)
 ;--- Display the task table
"RTN","RORHDT01",89,0)
 W !  D DSL()  W !
"RTN","RORHDT01",90,0)
 S IT=""
"RTN","RORHDT01",91,0)
 F  S IT=$O(RORBUF("DILIST","ID",IT))  Q:IT=""  D DSL(IT)
"RTN","RORHDT01",92,0)
 W !
"RTN","RORHDT01",93,0)
 Q 0
"RTN","RORHDT02")
0^116^B3488704
"RTN","RORHDT02",1,0)
RORHDT02 ;HCIOFO/SG - CREATE EXTRACTION TASK RECORDS ; 7/21/03 9:17am
"RTN","RORHDT02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORHDT02",3,0)
 ;
"RTN","RORHDT02",4,0)
 Q
"RTN","RORHDT02",5,0)
 ;
"RTN","RORHDT02",6,0)
 ;***** (RE)CREATES THE TASK TABLE
"RTN","RORHDT02",7,0)
 ;
"RTN","RORHDT02",8,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT02",9,0)
 ; [NTSK]        Number of tasks to create
"RTN","RORHDT02",10,0)
 ;
"RTN","RORHDT02",11,0)
 ; Return Values:
"RTN","RORHDT02",12,0)
 ;       <0  Error code
"RTN","RORHDT02",13,0)
 ;        0  Ok
"RTN","RORHDT02",14,0)
 ;        1  Timeout or "^"
"RTN","RORHDT02",15,0)
 ;
"RTN","RORHDT02",16,0)
CREATE(REGIEN,NTSK) ;
"RTN","RORHDT02",17,0)
 N FNAME,HIGHIEN,I,IDL,IENS,LOWIEN,NRE,RORFDA,RORMSG,RRIEN,UI
"RTN","RORHDT02",18,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,X,Y
"RTN","RORHDT02",19,0)
 S X=$P($$SITE^VASITE(),U,3),FNAME="S"_$E(X,1,3)_"T"
"RTN","RORHDT02",20,0)
 S UI='$G(NTSK)
"RTN","RORHDT02",21,0)
 ;--- Count number of records in the registry
"RTN","RORHDT02",22,0)
 W:UI !,"Calculating size of the registry ..."
"RTN","RORHDT02",23,0)
 S NRE=$$REGSIZE^RORUTL02(REGIEN,.LOWIEN,.HIGHIEN)
"RTN","RORHDT02",24,0)
 W:UI *13,"Number of patients in the registry: ",NRE,!
"RTN","RORHDT02",25,0)
 ;--- Ask for a number of data extraction tasks if the registry con-
"RTN","RORHDT02",26,0)
 ;    tains more than 1000 patients. Otherwise, create a single task.
"RTN","RORHDT02",27,0)
 S DIR("A")="Number of data extraction tasks"
"RTN","RORHDT02",28,0)
 I UI,NRE>1000  D  Q:$D(DIRUT) 1  S NTSK=+Y
"RTN","RORHDT02",29,0)
 . S DIR(0)="N^1:12:0"
"RTN","RORHDT02",30,0)
 . S DIR("B")="1"
"RTN","RORHDT02",31,0)
 . D ^DIR  W !
"RTN","RORHDT02",32,0)
 E  S:'$G(NTSK) NTSK=1  W:UI DIR("A")_": ",NTSK,!
"RTN","RORHDT02",33,0)
 ;--- Prepare records in the FDA.
"RTN","RORHDT02",34,0)
 ;    Use 1 instead of LOWIEN as a start value of the RRIEN so that
"RTN","RORHDT02",35,0)
 ;    no records will be missed (just in case)
"RTN","RORHDT02",36,0)
 S RRIEN=1,IDL=(HIGHIEN-LOWIEN)\NTSK,RC=0
"RTN","RORHDT02",37,0)
 S:IDL'>0 NTSK=1
"RTN","RORHDT02",38,0)
 F I=1:1:NTSK  D
"RTN","RORHDT02",39,0)
 . S IENS="+"_I_","
"RTN","RORHDT02",40,0)
 . S RORFDA(798.5,IENS,.01)=RRIEN
"RTN","RORHDT02",41,0)
 . S RORFDA(798.5,IENS,.02)=REGIEN
"RTN","RORHDT02",42,0)
 . S RORFDA(798.5,IENS,1.01)=FNAME_$TR($J(I,2)," ","0")_".HDT"
"RTN","RORHDT02",43,0)
 . S RRIEN=LOWIEN+(I*IDL)
"RTN","RORHDT02",44,0)
 ;--- Ask for the final confirmation
"RTN","RORHDT02",45,0)
 I UI  D  Q:$D(DIRUT)!'$G(Y) 1
"RTN","RORHDT02",46,0)
 . S DIR(0)="Y"
"RTN","RORHDT02",47,0)
 . S DIR("A")="Create the new task table"
"RTN","RORHDT02",48,0)
 . S DIR("B")="NO"
"RTN","RORHDT02",49,0)
 . D ^DIR  W !
"RTN","RORHDT02",50,0)
 ;--- Create the new task table
"RTN","RORHDT02",51,0)
 S RC=$$CLRTTBL^RORHDTUT(REGIEN)  Q:RC<0 RC
"RTN","RORHDT02",52,0)
 D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORHDT02",53,0)
 Q $$DBS^RORERR("RORMSG",-9)
"RTN","RORHDT03")
0^117^B23015205
"RTN","RORHDT03",1,0)
RORHDT03 ;HCIOFO/SG - MANIPULATIONS WITH EXTRACTION TASKS ; 7/21/03 10:06am
"RTN","RORHDT03",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORHDT03",3,0)
 ;
"RTN","RORHDT03",4,0)
 Q
"RTN","RORHDT03",5,0)
 ;
"RTN","RORHDT03",6,0)
 ;***** CHECKS FOR A STOP REQUESTS (TASKMAN & PROPRIETARY)
"RTN","RORHDT03",7,0)
 ;
"RTN","RORHDT03",8,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT03",9,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT03",10,0)
 ;
"RTN","RORHDT03",11,0)
 ; Return Values:
"RTN","RORHDT03",12,0)
 ;        0  Continue running
"RTN","RORHDT03",13,0)
 ;        1  Stop the task
"RTN","RORHDT03",14,0)
 ;
"RTN","RORHDT03",15,0)
CHKSTOP(REGIEN,TASKIEN) ;
"RTN","RORHDT03",16,0)
 S ZTSTOP=$G(^XTMP("RORHDT"_REGIEN,"T",TASKIEN))!$$S^%ZTLOAD
"RTN","RORHDT03",17,0)
 Q ZTSTOP
"RTN","RORHDT03",18,0)
 ;
"RTN","RORHDT03",19,0)
 ;***** STARTS THE DATA EXTRACTION TASK
"RTN","RORHDT03",20,0)
 ;
"RTN","RORHDT03",21,0)
 ; RORREG        Registry IEN
"RTN","RORHDT03",22,0)
 ; RORTASK       Task IEN
"RTN","RORHDT03",23,0)
 ; RORFAM        File Access Mode:
"RTN","RORHDT03",24,0)
 ;                 "A"  Append new messages to the file
"RTN","RORHDT03",25,0)
 ;                 "O"  Overwrite the file
"RTN","RORHDT03",26,0)
 ;                 "N"  Modify file name and create a new file
"RTN","RORHDT03",27,0)
 ; [ZTDTH]       Start date/time
"RTN","RORHDT03",28,0)
 ;
"RTN","RORHDT03",29,0)
 ; Return Values:
"RTN","RORHDT03",30,0)
 ;       <0  Error code
"RTN","RORHDT03",31,0)
 ;        0  Ok
"RTN","RORHDT03",32,0)
 ;        1  Start time has not been entered
"RTN","RORHDT03",33,0)
 ;        2  Already running or pending
"RTN","RORHDT03",34,0)
 ;
"RTN","RORHDT03",35,0)
START(RORREG,RORTASK,RORFAM,ZTDTH) ;
"RTN","RORHDT03",36,0)
 N I,RC,RORDUZ,RORMSG,STATUS,TASKNUM
"RTN","RORHDT03",37,0)
 N ZTCPU,ZTDESC,ZTIO,ZTKIL,ZTPRI,ZTRTN,ZTSAVE,ZTSK,ZTSYNC,ZTUCI
"RTN","RORHDT03",38,0)
 ;--- Uncomment the next line of code if you want that an alert
"RTN","RORHDT03",39,0)
 ;    to be sent to initiator of a task upon its completion
"RTN","RORHDT03",40,0)
 S RORDUZ=$G(DUZ)
"RTN","RORHDT03",41,0)
 ;--- Get a name of the registry
"RTN","RORHDT03",42,0)
 S $P(RORREG,U,2)=$$GET1^DIQ(798.1,RORREG_",",.01,,,"RORMSG")
"RTN","RORHDT03",43,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.1,RORREG)
"RTN","RORHDT03",44,0)
 ;--- Check status of the task
"RTN","RORHDT03",45,0)
 S STATUS=+$$STATUS^RORHDTUT(+RORREG,RORTASK,3)
"RTN","RORHDT03",46,0)
 Q:(STATUS=1)!(STATUS=2) 2
"RTN","RORHDT03",47,0)
 ;--- Start/schedule the task
"RTN","RORHDT03",48,0)
 S ZTRTN="TASK^RORHDT03",ZTIO=""
"RTN","RORHDT03",49,0)
 S ZTDESC="Historical data extraction"
"RTN","RORHDT03",50,0)
 F I="RORDUZ","RORFAM","RORREG","RORTASK"  S ZTSAVE(I)=""
"RTN","RORHDT03",51,0)
 D ^%ZTLOAD  S TASKNUM=$G(ZTSK)
"RTN","RORHDT03",52,0)
 ;--- Update task number
"RTN","RORHDT03",53,0)
 S RC=$$UPDTASK(+RORREG,RORTASK,TASKNUM,"","")
"RTN","RORHDT03",54,0)
 Q $S(TASKNUM:RC,1:1)
"RTN","RORHDT03",55,0)
 ;
"RTN","RORHDT03",56,0)
 ;***** STOPS THE DATA EXTRACTION TASK
"RTN","RORHDT03",57,0)
 ;
"RTN","RORHDT03",58,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT03",59,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT03",60,0)
 ;
"RTN","RORHDT03",61,0)
 ; Return Values:
"RTN","RORHDT03",62,0)
 ;       <0  Error code
"RTN","RORHDT03",63,0)
 ;        0  Ok
"RTN","RORHDT03",64,0)
 ;
"RTN","RORHDT03",65,0)
STOP(REGIEN,TASKIEN) ;
"RTN","RORHDT03",66,0)
 N IENS,RC,STATUS,ZTSK
"RTN","RORHDT03",67,0)
 ;--- Get status of the task
"RTN","RORHDT03",68,0)
 S STATUS=+$$STATUS^RORHDTUT(REGIEN,TASKIEN)
"RTN","RORHDT03",69,0)
 ;--- If task is pending, deque it
"RTN","RORHDT03",70,0)
 I STATUS=1  D  Q RC
"RTN","RORHDT03",71,0)
 . S IENS=TASKIEN_","
"RTN","RORHDT03",72,0)
 . S ZTSK=$$GET1^DIQ(798.5,IENS,2.01,,,"RORMSG")
"RTN","RORHDT03",73,0)
 . I $G(DIERR)  D  Q
"RTN","RORHDT03",74,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,798.5,IENS)
"RTN","RORHDT03",75,0)
 . D DQ^%ZTLOAD
"RTN","RORHDT03",76,0)
 . S RC=$S('$G(ZTSK(0)):$$ERROR^RORERR(-33),1:0)
"RTN","RORHDT03",77,0)
 ;--- If task is running, stop it
"RTN","RORHDT03",78,0)
 I STATUS=2  S ^XTMP("RORHDT"_REGIEN,"T",TASKIEN)=1  Q 0
"RTN","RORHDT03",79,0)
 Q 0
"RTN","RORHDT03",80,0)
 ;
"RTN","RORHDT03",81,0)
 ;***** HISTORICAL DATA EXTRACTION TASK
"RTN","RORHDT03",82,0)
 ;
"RTN","RORHDT03",83,0)
 ; [RORDUZ]      DUZ of a task initiator.
"RTN","RORHDT03",84,0)
 ;               If this variable is defined and greater than zero,
"RTN","RORHDT03",85,0)
 ;               an alert is sent to initiator of a task upon the
"RTN","RORHDT03",86,0)
 ;               task completion.
"RTN","RORHDT03",87,0)
 ;
"RTN","RORHDT03",88,0)
 ; RORFAM        File Access Mode:
"RTN","RORHDT03",89,0)
 ;                 "A"  Append new messages to the file
"RTN","RORHDT03",90,0)
 ;                 "O"  Overwrite the file
"RTN","RORHDT03",91,0)
 ;                 "N"  Modify file name and create a new file
"RTN","RORHDT03",92,0)
 ;
"RTN","RORHDT03",93,0)
 ; RORREG        Registry to process
"RTN","RORHDT03",94,0)
 ;                 ^1: Registry IEN
"RTN","RORHDT03",95,0)
 ;                 ^2: Registry Name
"RTN","RORHDT03",96,0)
 ;
"RTN","RORHDT03",97,0)
 ; RORTASK       IEN of the data extraction task in the ROR HDT
"RTN","RORHDT03",98,0)
 ;               TASK file
"RTN","RORHDT03",99,0)
 ;
"RTN","RORHDT03",100,0)
TASK ;
"RTN","RORHDT03",101,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT03",102,0)
 N RORERROR      ; Error processing data
"RTN","RORHDT03",103,0)
 N RORLOG        ; Log susbsystem data
"RTN","RORHDT03",104,0)
 N RORPARM       ; Application parameters
"RTN","RORHDT03",105,0)
 ;
"RTN","RORHDT03",106,0)
 N COUNTERS,HDTNODE,RC,REGLST,TMP,XQA,XQAFLG,XQAMSG
"RTN","RORHDT03",107,0)
 ;--- Force "UNDEF" error if task parameters are not defined
"RTN","RORHDT03",108,0)
 I '("ANO"[$G(RORFAM))  K RORFAM   S RC=RORFAM
"RTN","RORHDT03",109,0)
 I $G(RORREG)'>0        K RORREG   S RC=RORREG
"RTN","RORHDT03",110,0)
 I $G(RORTASK)'>0       K RORTASK  S RC=RORTASK
"RTN","RORHDT03",111,0)
 ;--- Initialize constants and variables
"RTN","RORHDT03",112,0)
 D INIT^RORUTL01("RORHDT"),CLEAR^RORERR("TASK^RORHDT03")
"RTN","RORHDT03",113,0)
 S HDTNODE=$NA(^XTMP("RORHDT"_+RORREG))
"RTN","RORHDT03",114,0)
 ;S RORPARM("DEBUG")=1 ; Remove the first ';' to start in debug mode
"RTN","RORHDT03",115,0)
 S RORPARM("ERR")=1
"RTN","RORHDT03",116,0)
 S RORPARM("LOG")=1
"RTN","RORHDT03",117,0)
 ;--- Check if the task is running
"RTN","RORHDT03",118,0)
 L +@HDTNODE@("T",RORTASK):3
"RTN","RORHDT03",119,0)
 E  S ZTSTOP=1  Q
"RTN","RORHDT03",120,0)
 K @HDTNODE@("T",RORTASK)
"RTN","RORHDT03",121,0)
 ;--- Update node descriptor in the ^XTMP global
"RTN","RORHDT03",122,0)
 D XTMPHDR^RORUTL01("RORHDT"_+RORREG,30,"TASK-RORHDT03")
"RTN","RORHDT03",123,0)
 ;--- Open a new log
"RTN","RORHDT03",124,0)
 S REGLST($P(RORREG,U,2))=+RORREG
"RTN","RORHDT03",125,0)
 S TMP=$$OPEN^RORLOG(.REGLST,4,"HISTORICAL DATA EXTRACTION STARTED")
"RTN","RORHDT03",126,0)
 K REGLST
"RTN","RORHDT03",127,0)
 ;--- Historical data extraction
"RTN","RORHDT03",128,0)
 D
"RTN","RORHDT03",129,0)
 . S RC=$$UPDTASK(+RORREG,RORTASK,ZTSK,$J,"",$$LOGIEN^RORLOG)  Q:RC<0
"RTN","RORHDT03",130,0)
 . S RC=$$EXTRACT^RORHDT04(RORREG,RORTASK,RORFAM)              Q:RC<0
"RTN","RORHDT03",131,0)
 . S COUNTERS=RC,TMP='$G(ZTSTOP)&'$P(RC,U,2),RC=0
"RTN","RORHDT03",132,0)
 . S TMP=$$UPDTASK(+RORREG,RORTASK,,"",TMP)
"RTN","RORHDT03",133,0)
 ;
"RTN","RORHDT03",134,0)
 ;--- Statistics & Cleanup
"RTN","RORHDT03",135,0)
 S TMP=$S($G(ZTSTOP):"WAS STOPPED",RC<0:"ABORTED",1:"FINISHED")
"RTN","RORHDT03",136,0)
 D CLOSE^RORLOG("HISTORICAL DATA EXTRACTION "_TMP,$G(COUNTERS))
"RTN","RORHDT03",137,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("RORHDT")
"RTN","RORHDT03",138,0)
 ;--- Reset "Running" flag
"RTN","RORHDT03",139,0)
 K @HDTNODE@("T",RORTASK)
"RTN","RORHDT03",140,0)
 L -@HDTNODE@("T",RORTASK)
"RTN","RORHDT03",141,0)
 ;--- Send an alert to the user
"RTN","RORHDT03",142,0)
 I $G(RORDUZ)>0  D  D SETUP^XQALERT
"RTN","RORHDT03",143,0)
 . S XQA(RORDUZ)="",XQAFLG="D"
"RTN","RORHDT03",144,0)
 . S XQAMSG="Historical data extraction task has finished (RC="_RC_")"
"RTN","RORHDT03",145,0)
 S ZTREQ="@"
"RTN","RORHDT03",146,0)
 Q
"RTN","RORHDT03",147,0)
 ;
"RTN","RORHDT03",148,0)
 ;***** UPDATES TASK RECORD
"RTN","RORHDT03",149,0)
 ;
"RTN","RORHDT03",150,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT03",151,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT03",152,0)
 ; [TASKNUM]     Task number
"RTN","RORHDT03",153,0)
 ; [JOBNUM]      Job number
"RTN","RORHDT03",154,0)
 ; [LOGIEN]      IEN of the latest task log
"RTN","RORHDT03",155,0)
 ;
"RTN","RORHDT03",156,0)
 ; The function updates task record fields with values of the
"RTN","RORHDT03",157,0)
 ; parameters. If a parameter is omitted, corresponding field retain
"RTN","RORHDT03",158,0)
 ; its current value.
"RTN","RORHDT03",159,0)
 ;
"RTN","RORHDT03",160,0)
 ; If the JOBNUM parameter is defined and not zero (it means that a
"RTN","RORHDT03",161,0)
 ; new job is being started), the COMPLETED field is always cleared.
"RTN","RORHDT03",162,0)
 ;
"RTN","RORHDT03",163,0)
 ; If the CMPLTD parameter is defined and not zero (the task has been
"RTN","RORHDT03",164,0)
 ; completed successfully), the TASKNUM field is always cleared.
"RTN","RORHDT03",165,0)
 ;
"RTN","RORHDT03",166,0)
 ; Return Values:
"RTN","RORHDT03",167,0)
 ;       <0  Error code
"RTN","RORHDT03",168,0)
 ;        0  Ok
"RTN","RORHDT03",169,0)
 ;
"RTN","RORHDT03",170,0)
UPDTASK(REGIEN,TASKIEN,TASKNUM,JOBNUM,CMPLTD,LOGIEN) ;
"RTN","RORHDT03",171,0)
 N IENS,RORFDA,RORMSG
"RTN","RORHDT03",172,0)
 S IENS=TASKIEN_","
"RTN","RORHDT03",173,0)
 I $D(JOBNUM)#2  D  S:JOBNUM CMPLTD=""
"RTN","RORHDT03",174,0)
 . S RORFDA(798.5,IENS,2.02)=JOBNUM
"RTN","RORHDT03",175,0)
 I $D(CMPLTD)#2  D  S:CMPLTD TASKNUM=""
"RTN","RORHDT03",176,0)
 . S RORFDA(798.5,IENS,2.03)=CMPLTD
"RTN","RORHDT03",177,0)
 S:$D(TASKNUM)#2 RORFDA(798.5,IENS,2.01)=TASKNUM
"RTN","RORHDT03",178,0)
 S:$D(LOGIEN)#2 RORFDA(798.5,IENS,2.04)=LOGIEN
"RTN","RORHDT03",179,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORHDT03",180,0)
 Q $$DBS^RORERR("RORMSG",-9)
"RTN","RORHDT04")
0^86^B37521395
"RTN","RORHDT04",1,0)
RORHDT04 ;HCIOFO/SG - HISTORICAL DATA EXTRACTION PROCESS ; 7/21/03 10:29am
"RTN","RORHDT04",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3,4,5**;May 14, 2002
"RTN","RORHDT04",3,0)
 ;
"RTN","RORHDT04",4,0)
 Q
"RTN","RORHDT04",5,0)
 ;
"RTN","RORHDT04",6,0)
 ;***** DATA EXTRACTION PROCESS
"RTN","RORHDT04",7,0)
 ;
"RTN","RORHDT04",8,0)
 ; REGISTRY      Registry to process
"RTN","RORHDT04",9,0)
 ;                 ^1: Registry IEN
"RTN","RORHDT04",10,0)
 ;                 ^2: Registry Name
"RTN","RORHDT04",11,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT04",12,0)
 ; FAM           File Access Mode
"RTN","RORHDT04",13,0)
 ;
"RTN","RORHDT04",14,0)
 ; Return Values:
"RTN","RORHDT04",15,0)
 ;       <0  Error code
"RTN","RORHDT04",16,0)
 ;      >=0  Statistics
"RTN","RORHDT04",17,0)
 ;             ^1: Total number of processed patients
"RTN","RORHDT04",18,0)
 ;             ^2: Number of patients processed with errors
"RTN","RORHDT04",19,0)
 ;
"RTN","RORHDT04",20,0)
EXTRACT(REGISTRY,TASKIEN,FAM) ;
"RTN","RORHDT04",21,0)
 N RORDATE       ; Date/time when the first registry update finished
"RTN","RORHDT04",22,0)
 N ROREXT        ; Data extraction descriptor
"RTN","RORHDT04",23,0)
 N RORHL         ; HL7 variables
"RTN","RORHDT04",24,0)
 N RORLRC        ; List of codes of Lab results to be extracted
"RTN","RORHDT04",25,0)
 ;
"RTN","RORHDT04",26,0)
 N CNT           ; Number of processed registry records
"RTN","RORHDT04",27,0)
 N ECNT          ; Number of records processed with errors
"RTN","RORHDT04",28,0)
 N FILE          ; Name of the output file
"RTN","RORHDT04",29,0)
 N OUTDIR        ; Name of the output directory
"RTN","RORHDT04",30,0)
 ;
"RTN","RORHDT04",31,0)
 N BDT,EDT,NEXT,POP,RC,REGIEN,REGLST,REGNAME,RRBIEN,RREIEN,STOP,TMP
"RTN","RORHDT04",32,0)
 K ^TMP("RORHDT",$J,"PR"),^TMP("HLS",$J)
"RTN","RORHDT04",33,0)
 S REGNAME=$P(REGISTRY,U,2),(REGLST(REGNAME),REGIEN)=+REGISTRY
"RTN","RORHDT04",34,0)
 S (CNT,ECNT,STOP)=0,RORHDT("BHS")=1
"RTN","RORHDT04",35,0)
 ;--- Load parameters
"RTN","RORHDT04",36,0)
 S RC=$$REGPARM^RORHDT05(REGIEN,.BDT,.EDT,.OUTDIR,.RORDATE)
"RTN","RORHDT04",37,0)
 Q:RC<0 RC
"RTN","RORHDT04",38,0)
 S RC=$$TASKPARM^RORHDT05(REGIEN,TASKIEN,.RRBIEN,.RREIEN,.FILE)
"RTN","RORHDT04",39,0)
 Q:RC<0 RC
"RTN","RORHDT04",40,0)
 ;--- Prepare data extraction rules
"RTN","RORHDT04",41,0)
 S RC=$$PREPARE^ROREXPR(REGNAME,BDT,EDT)
"RTN","RORHDT04",42,0)
 Q:RC<0 $$ERROR^RORERR(-22)
"RTN","RORHDT04",43,0)
 K ROREXT("LD")          ; Do not use lag intervals
"RTN","RORHDT04",44,0)
 K ROREXT("MAXHL7SIZE")  ; Do not limit the size
"RTN","RORHDT04",45,0)
 S RC=$$INIT^RORHL7()  Q:RC<0 RC
"RTN","RORHDT04",46,0)
 ;--- Delete the old output host file(s)
"RTN","RORHDT04",47,0)
 S TMP=$$DELFILES^RORHDT05(OUTDIR,FILE)
"RTN","RORHDT04",48,0)
 ;--- The output file is created by the $$COMMIT^RORHDT05 function
"RTN","RORHDT04",49,0)
 D
"RTN","RORHDT04",50,0)
 . N COMMIT,IEN,NODE,NRTC,PATIEN
"RTN","RORHDT04",51,0)
 . S NRTC=100 ; Number of records to commit
"RTN","RORHDT04",52,0)
 . ;--- Try to re-extract the erroneous records
"RTN","RORHDT04",53,0)
 . S NODE=$$ROOT^DILFD(798.53,","_TASKIEN_",",1)
"RTN","RORHDT04",54,0)
 . S NODE=$NA(@NODE@("B"))
"RTN","RORHDT04",55,0)
 . S IEN=0,RC=0
"RTN","RORHDT04",56,0)
 . F  D  Q:RC!STOP!(IEN="")
"RTN","RORHDT04",57,0)
 . . K ^TMP("HLS",$J)
"RTN","RORHDT04",58,0)
 . . F  S IEN=$O(@NODE@(IEN))  Q:IEN=""  D  Q:RC!'((CNT-ECNT)#NRTC)
"RTN","RORHDT04",59,0)
 . . . S RC=$$CHKSTOP^RORHDT03(REGIEN,TASKIEN)
"RTN","RORHDT04",60,0)
 . . . I RC  S STOP=1  Q
"RTN","RORHDT04",61,0)
 . . . S RC=$$PROCREC(REGIEN,IEN,.PATIEN),CNT=CNT+1
"RTN","RORHDT04",62,0)
 . . . S ^TMP("RORHDT",$J,"PR",IEN)=RC
"RTN","RORHDT04",63,0)
 . . . I RC'<0  S RC=0  Q
"RTN","RORHDT04",64,0)
 . . . ;--- Proccess the error
"RTN","RORHDT04",65,0)
 . . . S RC=$$ERROR^RORERR(-15,,,$G(PATIEN)),ECNT=ECNT+1
"RTN","RORHDT04",66,0)
 . . . S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORHDT04",67,0)
 . . Q:RC<0
"RTN","RORHDT04",68,0)
 . . ;--- Commit the data
"RTN","RORHDT04",69,0)
 . . S TMP=$$COMMIT^RORHDT05(OUTDIR,FILE)
"RTN","RORHDT04",70,0)
 . . S:TMP<0 RC=TMP
"RTN","RORHDT04",71,0)
 . Q:STOP
"RTN","RORHDT04",72,0)
 . ;--- Extract the remaining registry data
"RTN","RORHDT04",73,0)
 . S NODE=$$ROOT^DILFD(798,,1)
"RTN","RORHDT04",74,0)
 . S NODE=$NA(@NODE@("AC",REGIEN))
"RTN","RORHDT04",75,0)
 . S IEN=$S(RRBIEN>0:+$O(@NODE@(RRBIEN),-1),1:0)
"RTN","RORHDT04",76,0)
 . S RC=0
"RTN","RORHDT04",77,0)
 . F  D  Q:RC!STOP!(IEN'>0)
"RTN","RORHDT04",78,0)
 . . K ^TMP("HLS",$J)  S COMMIT=0
"RTN","RORHDT04",79,0)
 . . F  S IEN=$O(@NODE@(IEN))  Q:IEN'>0  D  Q:RC!COMMIT
"RTN","RORHDT04",80,0)
 . . . S RC=$$CHKSTOP^RORHDT03(REGIEN,TASKIEN)
"RTN","RORHDT04",81,0)
 . . . I RC  S STOP=1  Q
"RTN","RORHDT04",82,0)
 . . . I RREIEN>0,IEN'<RREIEN  S IEN="",RC=1  Q
"RTN","RORHDT04",83,0)
 . . . Q:$D(^TMP("RORHDT",$J,"PR",IEN))
"RTN","RORHDT04",84,0)
 . . . S RC=$$PROCREC(REGIEN,IEN,.PATIEN),CNT=CNT+1
"RTN","RORHDT04",85,0)
 . . . I RC'<0  S COMMIT='((CNT-ECNT)#NRTC),RC=0  Q
"RTN","RORHDT04",86,0)
 . . . ;--- Proccess the error
"RTN","RORHDT04",87,0)
 . . . S RC=$$ERROR^RORERR(-15,,,$G(PATIEN)),ECNT=ECNT+1
"RTN","RORHDT04",88,0)
 . . . S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORHDT04",89,0)
 . . . S TMP=$$ADDERR^RORHDT05(REGIEN,TASKIEN,IEN)
"RTN","RORHDT04",90,0)
 . . . S:TMP<0 RC=TMP
"RTN","RORHDT04",91,0)
 . . Q:RC<0
"RTN","RORHDT04",92,0)
 . . ;--- Commit the data
"RTN","RORHDT04",93,0)
 . . S NEXT=$S(COMMIT:$O(@NODE@(IEN)),1:IEN)
"RTN","RORHDT04",94,0)
 . . S TMP=$$COMMIT^RORHDT05(OUTDIR,FILE)
"RTN","RORHDT04",95,0)
 . . S:TMP<0 RC=TMP
"RTN","RORHDT04",96,0)
 ;
"RTN","RORHDT04",97,0)
 ;--- Write the batch trailer segment and close the file if
"RTN","RORHDT04",98,0)
 ;--- the batch is not empty. Otherwise, record a warning.
"RTN","RORHDT04",99,0)
 I '$G(RORHDT("BHS"))  D
"RTN","RORHDT04",100,0)
 . S TMP=$S(ECNT!(RC<0):"Completed with errors",STOP:"Stopped",1:"")
"RTN","RORHDT04",101,0)
 . U IO  W $$BTS^RORHL7($$MSGCNT^RORHL7,TMP),$C(13)
"RTN","RORHDT04",102,0)
 . D CLOSE^%ZISH("HL7FILE")
"RTN","RORHDT04",103,0)
 E  S TMP=$$ERROR^RORERR(-89)
"RTN","RORHDT04",104,0)
 ;--- Update the NEXT RECORD IEN field in the task record
"RTN","RORHDT04",105,0)
 D
"RTN","RORHDT04",106,0)
 . N NODE,RORFDA,RORMSG
"RTN","RORHDT04",107,0)
 . I $D(NEXT)  D:NEXT'>0
"RTN","RORHDT04",108,0)
 . . ;--- If the task completed successfuly, the NEXT RECORD IEN
"RTN","RORHDT04",109,0)
 . . ;    field is set to an empty string. If the task is restarted
"RTN","RORHDT04",110,0)
 . . ;--- afterwards, it will re-extract all data again.
"RTN","RORHDT04",111,0)
 . . I 'ECNT  S NEXT=""  Q
"RTN","RORHDT04",112,0)
 . . ;--- If completed with errors, use IEN of the last record
"RTN","RORHDT04",113,0)
 . . ;--- processed by the task incremented by 1.
"RTN","RORHDT04",114,0)
 . . I RREIEN>0  S NEXT=RREIEN+1  Q
"RTN","RORHDT04",115,0)
 . . ;--- Or the IEN of the last registry record incremented by 1
"RTN","RORHDT04",116,0)
 . . ;--- (in case of the last/single task).
"RTN","RORHDT04",117,0)
 . . S NODE=$$ROOT^DILFD(798,,1)
"RTN","RORHDT04",118,0)
 . . S NEXT=$O(@NODE@("AC",REGIEN,""),-1)+1
"RTN","RORHDT04",119,0)
 . . ;--- When the task is restarted, it will try to re-extract only
"RTN","RORHDT04",120,0)
 . . ;    erroneous records and will not process already extracted
"RTN","RORHDT04",121,0)
 . . ;    data (the IEN will not be less than the RREIEN or the
"RTN","RORHDT04",122,0)
 . . ;--- $ORDER function will not return a value greater than zero).
"RTN","RORHDT04",123,0)
 . E  Q:(RC<0)!ECNT!STOP  S NEXT=""
"RTN","RORHDT04",124,0)
 . ;--- Update the task record
"RTN","RORHDT04",125,0)
 . S RORFDA(798.5,TASKIEN_",",4)=NEXT
"RTN","RORHDT04",126,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORHDT04",127,0)
 . S TMP=$$DBS^RORERR("RORMSG",-9,,,798.5,TASKIEN)
"RTN","RORHDT04",128,0)
 ;--- Cleanup
"RTN","RORHDT04",129,0)
 S:RC'<0 RC=$$CLRERRS^RORHDT05(REGIEN,TASKIEN)
"RTN","RORHDT04",130,0)
 Q $S(RC<0:RC,1:CNT_U_ECNT)
"RTN","RORHDT04",131,0)
 ;
"RTN","RORHDT04",132,0)
 ;***** PROCESSES A RECORD IN THE REGISTRY
"RTN","RORHDT04",133,0)
 ;
"RTN","RORHDT04",134,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT04",135,0)
 ; IEN           IEN of a record in the registry
"RTN","RORHDT04",136,0)
 ; [.PATIEN]     Patient IEN is returned by this parameter
"RTN","RORHDT04",137,0)
 ;
"RTN","RORHDT04",138,0)
 ; Return Values:
"RTN","RORHDT04",139,0)
 ;       <0  Error code
"RTN","RORHDT04",140,0)
 ;        0  Ok
"RTN","RORHDT04",141,0)
 ;        1  Nothing has been extracted
"RTN","RORHDT04",142,0)
 ;
"RTN","RORHDT04",143,0)
PROCREC(REGIEN,IEN,PATIEN) ;
"RTN","RORHDT04",144,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT04",145,0)
 ;
"RTN","RORHDT04",146,0)
 N ACTIVE,BDT,EDT,IENS,INCTVDT,MSHPTR,RC,RORFDA,RORMSG
"RTN","RORHDT04",147,0)
 D CLEAR^RORERR("PROCREC^RORHDT04")
"RTN","RORHDT04",148,0)
 S IENS=IEN_",",PATIEN=0
"RTN","RORHDT04",149,0)
 ;--- Get the registry record data
"RTN","RORHDT04",150,0)
 D GETS^DIQ(798,IENS,".01;1;2;8;11","EI","RORFDA","RORMSG")
"RTN","RORHDT04",151,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","RORHDT04",152,0)
 S PATIEN=RORFDA(798,IENS,.01,"I")
"RTN","RORHDT04",153,0)
 S INCTVDT=$G(RORFDA(798,IENS,2,"I"))\1
"RTN","RORHDT04",154,0)
 S ACTIVE=$G(RORFDA(798,IENS,8,"E"))
"RTN","RORHDT04",155,0)
 ;--- Skip a record tagged as "DON'T SEND"
"RTN","RORHDT04",156,0)
 Q:$G(RORFDA(798,IENS,11,"I")) 0
"RTN","RORHDT04",157,0)
 ;--- Skip the record if it was not added by the first update
"RTN","RORHDT04",158,0)
 I RORDATE  Q:$G(RORFDA(798,IENS,1,"I"))>RORDATE 0
"RTN","RORHDT04",159,0)
 ;--- Prepare extract dates
"RTN","RORHDT04",160,0)
 S BDT=$G(ROREXT("DXBEG")),EDT=$G(ROREXT("DXEND"))
"RTN","RORHDT04",161,0)
 I 'ACTIVE  Q:INCTVDT'>BDT 0  S:EDT>INCTVDT EDT=INCTVDT
"RTN","RORHDT04",162,0)
 ;--- Create HL7 message for the patient
"RTN","RORHDT04",163,0)
 S MSHPTR=$$CREATE^RORHL7()  Q:MSHPTR<0 MSHPTR
"RTN","RORHDT04",164,0)
 I $G(ROREXT("MSGBLD"))'=""  D
"RTN","RORHDT04",165,0)
 . X "S RC="_ROREXT("MSGBLD")_"(IEN,PATIEN,BDT_U_EDT,1)"
"RTN","RORHDT04",166,0)
 E  S RC=$$MESSAGE^ROREXT02(IEN,PATIEN,BDT_U_EDT,1)
"RTN","RORHDT04",167,0)
 ;--- Rollback incomplete message if necessary
"RTN","RORHDT04",168,0)
 S:RC'<0 RC=($O(^TMP("HLS",$J,""),-1)'>MSHPTR)
"RTN","RORHDT04",169,0)
 D:RC ROLLBACK^RORHL7(MSHPTR)
"RTN","RORHDT04",170,0)
 Q RC
"RTN","RORHDT05")
0^118^B13041348
"RTN","RORHDT05",1,0)
RORHDT05 ;HCIOFO/SG - HISTORICAL DATA EXTRACTION FUNCTIONS ; 7/21/03 10:07am
"RTN","RORHDT05",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3,4,5**;May 14, 2002
"RTN","RORHDT05",3,0)
 ;
"RTN","RORHDT05",4,0)
 Q
"RTN","RORHDT05",5,0)
 ;
"RTN","RORHDT05",6,0)
 ;***** ADDS A RECORD TO THE 'ERROR' MULTIPLE OF THE TASK RECORD
"RTN","RORHDT05",7,0)
 ;
"RTN","RORHDT05",8,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT05",9,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT05",10,0)
 ; IEN           IEN of the erroneous registry record
"RTN","RORHDT05",11,0)
 ;
"RTN","RORHDT05",12,0)
 ; Return Values:
"RTN","RORHDT05",13,0)
 ;       <0  Error code
"RTN","RORHDT05",14,0)
 ;        0  Ok
"RTN","RORHDT05",15,0)
 ;
"RTN","RORHDT05",16,0)
ADDERR(REGIEN,TASKIEN,IEN) ;
"RTN","RORHDT05",17,0)
 N IENS,RC,RORFDA,RORIEN,RORMSG
"RTN","RORHDT05",18,0)
 S IENS="+1,"_TASKIEN_",",RORIEN(1)=IEN
"RTN","RORHDT05",19,0)
 S RORFDA(798.53,IENS,.01)=IEN
"RTN","RORHDT05",20,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORHDT05",21,0)
 Q $$DBS^RORERR("RORMSG",-9,,,798.53,IENS)
"RTN","RORHDT05",22,0)
 ;
"RTN","RORHDT05",23,0)
 ;***** DELETES RECORDS FROM THE 'ERROR' MULTIPLE OF THE TASK RECORD
"RTN","RORHDT05",24,0)
 ;
"RTN","RORHDT05",25,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT05",26,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT05",27,0)
 ;
"RTN","RORHDT05",28,0)
 ; This functions deletes all erroneous records from the ERROR
"RTN","RORHDT05",29,0)
 ; multiple of the task record that have been re-extracted without
"RTN","RORHDT05",30,0)
 ; errors. So, there is no reason to keep them anymore.
"RTN","RORHDT05",31,0)
 ;
"RTN","RORHDT05",32,0)
 ; Return Values:
"RTN","RORHDT05",33,0)
 ;       <0  Error code
"RTN","RORHDT05",34,0)
 ;        0  Ok
"RTN","RORHDT05",35,0)
 ;
"RTN","RORHDT05",36,0)
CLRERRS(REGIEN,TASKIEN) ;
"RTN","RORHDT05",37,0)
 N I,IEN,RC,RORFDA,RORMSG,SFI
"RTN","RORHDT05",38,0)
 S SFI=","_TASKIEN_",",RC=0
"RTN","RORHDT05",39,0)
 S IEN=""
"RTN","RORHDT05",40,0)
 F  D  Q:(RC<0)!(IEN="")
"RTN","RORHDT05",41,0)
 . F I=1:1:10  S IEN=$O(^TMP("RORHDT",$J,"PR",IEN))  Q:IEN=""  D
"RTN","RORHDT05",42,0)
 . . S:^TMP("RORHDT",$J,"PR",IEN)'<0 RORFDA(798.53,IEN_SFI,.01)="@"
"RTN","RORHDT05",43,0)
 . Q:$D(RORFDA)<10
"RTN","RORHDT05",44,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORHDT05",45,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,798.53)
"RTN","RORHDT05",46,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORHDT05",47,0)
 ;
"RTN","RORHDT05",48,0)
 ;***** COMMITS HL7 DATA TO THE OUTPUT FILE
"RTN","RORHDT05",49,0)
 ;
"RTN","RORHDT05",50,0)
 ; OUTDIR        Output directory
"RTN","RORHDT05",51,0)
 ; FILE          Output file name
"RTN","RORHDT05",52,0)
 ;
"RTN","RORHDT05",53,0)
 ; Return Values:
"RTN","RORHDT05",54,0)
 ;       <0  Error code
"RTN","RORHDT05",55,0)
 ;        0  Ok
"RTN","RORHDT05",56,0)
 ;
"RTN","RORHDT05",57,0)
COMMIT(OUTDIR,FILE) ;
"RTN","RORHDT05",58,0)
 N CR,I,J,POP,RC
"RTN","RORHDT05",59,0)
 Q:$D(^TMP("HLS",$J))<10 0
"RTN","RORHDT05",60,0)
 S CR=$C(13),RC=0
"RTN","RORHDT05",61,0)
 ;--- Create the file and write the BHS segment (if necessary)
"RTN","RORHDT05",62,0)
 I $G(RORHDT("BHS"))  D  Q:RC<0 RC  K RORHDT("BHS")
"RTN","RORHDT05",63,0)
 . D OPEN^%ZISH("HL7FILE",OUTDIR,FILE,"WB")
"RTN","RORHDT05",64,0)
 . I $G(POP)  S RC=$$ERROR^RORERR(-34,,OUTDIR_FILE)  Q
"RTN","RORHDT05",65,0)
 . S I=$G(ROREXT("HL7DT"))  U IO
"RTN","RORHDT05",66,0)
 . W $$BHS^RORHL7($G(ROREXT("HL7MID")),I,"HISTORICAL DATA"),$C(13)
"RTN","RORHDT05",67,0)
 ;--- Write the segments
"RTN","RORHDT05",68,0)
 S I=0
"RTN","RORHDT05",69,0)
 F  S I=$O(^TMP("HLS",$J,I))  Q:I=""  D
"RTN","RORHDT05",70,0)
 . W ^TMP("HLS",$J,I)  S J=""
"RTN","RORHDT05",71,0)
 . F  S J=$O(^TMP("HLS",$J,I,J))  Q:J=""  W ^(J)
"RTN","RORHDT05",72,0)
 . W CR
"RTN","RORHDT05",73,0)
 Q 0
"RTN","RORHDT05",74,0)
 ;
"RTN","RORHDT05",75,0)
 ;***** DELETES THE OLD OUTPUT HOST FILE(S)
"RTN","RORHDT05",76,0)
 ;
"RTN","RORHDT05",77,0)
 ; OUTDIR        Output directory
"RTN","RORHDT05",78,0)
 ; FILE          Output file name
"RTN","RORHDT05",79,0)
 ;
"RTN","RORHDT05",80,0)
 ; Return Values:
"RTN","RORHDT05",81,0)
 ;       <0  Error code
"RTN","RORHDT05",82,0)
 ;        0  Ok
"RTN","RORHDT05",83,0)
 ;
"RTN","RORHDT05",84,0)
DELFILES(OUTDIR,FILE) ;
"RTN","RORHDT05",85,0)
 N RC,RORDST,RORSRC  Q:FILE="" 0
"RTN","RORHDT05",86,0)
 S RORSRC(FILE_"*")=""
"RTN","RORHDT05",87,0)
 Q:'$$LIST^%ZISH(OUTDIR,"RORSRC","RORDST") 0
"RTN","RORHDT05",88,0)
 I '$$DEL^%ZISH(OUTDIR,"RORDST")  D  Q RC
"RTN","RORHDT05",89,0)
 . S RC=$$ERROR^RORERR(-56,,,,0,"$$DEL^%ZISH")
"RTN","RORHDT05",90,0)
 Q 0
"RTN","RORHDT05",91,0)
 ;
"RTN","RORHDT05",92,0)
 ;***** LOADS REGISTRY PARAMETERS
"RTN","RORHDT05",93,0)
 ;
"RTN","RORHDT05",94,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT05",95,0)
 ; [.BDT]        Start date of the data extract
"RTN","RORHDT05",96,0)
 ; [.EDT]        End date of the data extract
"RTN","RORHDT05",97,0)
 ; [.OUTDIR]     Output directory
"RTN","RORHDT05",98,0)
 ; [.DATE]       Date/time when first registry update finished
"RTN","RORHDT05",99,0)
 ;
"RTN","RORHDT05",100,0)
 ; Return Values:
"RTN","RORHDT05",101,0)
 ;       <0  Error code
"RTN","RORHDT05",102,0)
 ;        0  Ok
"RTN","RORHDT05",103,0)
 ;
"RTN","RORHDT05",104,0)
REGPARM(REGIEN,BDT,EDT,OUTDIR,DATE) ;
"RTN","RORHDT05",105,0)
 N IENS,RC,RORBUF,RORMSG,TMP
"RTN","RORHDT05",106,0)
 S IENS=REGIEN_","
"RTN","RORHDT05",107,0)
 ;--- Get data from the registry descriptor
"RTN","RORHDT05",108,0)
 D GETS^DIQ(798.1,IENS,"21.01;21.02;21.03;21.05","I","RORBUF","RORMSG")
"RTN","RORHDT05",109,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","RORHDT05",110,0)
 S BDT=$G(RORBUF(798.1,IENS,21.01,"I"))
"RTN","RORHDT05",111,0)
 S EDT=$G(RORBUF(798.1,IENS,21.02,"I"))
"RTN","RORHDT05",112,0)
 S OUTDIR=$G(RORBUF(798.1,IENS,21.03,"I"))
"RTN","RORHDT05",113,0)
 S DATE=$G(RORBUF(798.1,IENS,21.05,"I"))
"RTN","RORHDT05",114,0)
 I (BDT'>0)!(EDT'>0)!(BDT>EDT)  D  Q RC
"RTN","RORHDT05",115,0)
 . S RC=$$ERROR^RORERR(-32,,,,BDT,EDT)
"RTN","RORHDT05",116,0)
 Q 0
"RTN","RORHDT05",117,0)
 ;
"RTN","RORHDT05",118,0)
 ;***** LOADS TASK PARAMETERS
"RTN","RORHDT05",119,0)
 ;
"RTN","RORHDT05",120,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT05",121,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT05",122,0)
 ; [.RBIEN]      Start record IEN
"RTN","RORHDT05",123,0)
 ; [.REIEN]      End record IEN
"RTN","RORHDT05",124,0)
 ; [.FILE]       File name
"RTN","RORHDT05",125,0)
 ;
"RTN","RORHDT05",126,0)
 ; Return Values:
"RTN","RORHDT05",127,0)
 ;       <0  Error code
"RTN","RORHDT05",128,0)
 ;        0  Ok
"RTN","RORHDT05",129,0)
 ;
"RTN","RORHDT05",130,0)
TASKPARM(REGIEN,TASKIEN,RBIEN,REIEN,FILE) ;
"RTN","RORHDT05",131,0)
 N IENS,RC,ROOT,RORBUF,RORMSG,TMP
"RTN","RORHDT05",132,0)
 ;--- Load data from the task record
"RTN","RORHDT05",133,0)
 S IENS=TASKIEN_","
"RTN","RORHDT05",134,0)
 D GETS^DIQ(798.5,IENS,".01;1.01;4","I","RORBUF","RORMSG")
"RTN","RORHDT05",135,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.5,IENS)
"RTN","RORHDT05",136,0)
 S RBIEN=$G(RORBUF(798.5,IENS,.01,"I"))
"RTN","RORHDT05",137,0)
 S FILE=$G(RORBUF(798.5,IENS,1.01,"I"))
"RTN","RORHDT05",138,0)
 ;--- Get the end record IEN from the next task record
"RTN","RORHDT05",139,0)
 S ROOT=$$ROOT^DILFD(798.5,,1)
"RTN","RORHDT05",140,0)
 S REIEN=$O(@ROOT@("C",REGIEN,RBIEN))
"RTN","RORHDT05",141,0)
 ;--- If an IEN of the record is available from the previous run,
"RTN","RORHDT05",142,0)
 ;    use it as start record IEN
"RTN","RORHDT05",143,0)
 S TMP=$G(RORBUF(798.5,IENS,4,"I"))
"RTN","RORHDT05",144,0)
 S:TMP>0 RBIEN=TMP
"RTN","RORHDT05",145,0)
 Q 0
"RTN","RORHDTAC")
0^119^B12268128
"RTN","RORHDTAC",1,0)
RORHDTAC ;HCIOFO/SG - DATA EXTRACTION ACTION CONFIRMATIONS ; 7/21/03 9:21am
"RTN","RORHDTAC",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORHDTAC",3,0)
 ;
"RTN","RORHDTAC",4,0)
 Q
"RTN","RORHDTAC",5,0)
 ;
"RTN","RORHDTAC",6,0)
 ;***** CONFIRMATION TO CREATE A NEW TASK TABLE
"RTN","RORHDTAC",7,0)
 ;
"RTN","RORHDTAC",8,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTAC",9,0)
 ;
"RTN","RORHDTAC",10,0)
 ; Return Values:
"RTN","RORHDTAC",11,0)
 ;       <0  Error code
"RTN","RORHDTAC",12,0)
 ;        0  Cancel
"RTN","RORHDTAC",13,0)
 ;        1  Create a table
"RTN","RORHDTAC",14,0)
 ;
"RTN","RORHDTAC",15,0)
CREATE(REGIEN) ;
"RTN","RORHDTAC",16,0)
 N IENS,RC,RORBUF,RORMSG
"RTN","RORHDTAC",17,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,X,Y
"RTN","RORHDTAC",18,0)
 ;--- Display status of the registry
"RTN","RORHDTAC",19,0)
 S RC=$$STATUS^RORHDT01(REGIEN)  Q:RC<0 RC
"RTN","RORHDTAC",20,0)
 ;--- Check if registry task table is not empty
"RTN","RORHDTAC",21,0)
 D FIND^DIC(798.5,,"@","QX",REGIEN,1,"AR",,,"RORBUF","RORMSG")
"RTN","RORHDTAC",22,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.5)
"RTN","RORHDTAC",23,0)
 ;--- Ask for a confirmation to overwrite
"RTN","RORHDTAC",24,0)
 I $G(RORBUF("DILIST",0))>0  D  Q:RC 0
"RTN","RORHDTAC",25,0)
 . K DIR  S DIR(0)="Y"
"RTN","RORHDTAC",26,0)
 . S DIR("A")="Overwrite the existing task table"
"RTN","RORHDTAC",27,0)
 . S DIR("B")="NO"
"RTN","RORHDTAC",28,0)
 . D ^DIR  W !  S RC=$D(DIRUT)!'$G(Y)
"RTN","RORHDTAC",29,0)
 Q 1
"RTN","RORHDTAC",30,0)
 ;
"RTN","RORHDTAC",31,0)
 ;***** CONFIRMATIONS TO START THE TASK
"RTN","RORHDTAC",32,0)
 ;
"RTN","RORHDTAC",33,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTAC",34,0)
 ; TASKIEN       Task IEN
"RTN","RORHDTAC",35,0)
 ; .FAM          File Access Mode is returned via this parameter
"RTN","RORHDTAC",36,0)
 ;
"RTN","RORHDTAC",37,0)
 ; Return Values:
"RTN","RORHDTAC",38,0)
 ;       <0  Error code
"RTN","RORHDTAC",39,0)
 ;        0  Cancel
"RTN","RORHDTAC",40,0)
 ;        1  Start the task
"RTN","RORHDTAC",41,0)
 ;
"RTN","RORHDTAC",42,0)
START(REGIEN,TASKIEN,FAM) ;
"RTN","RORHDTAC",43,0)
 N FILE,OUTDIR,RC,RORDST,RORSRC,STATUS
"RTN","RORHDTAC",44,0)
 N DA,DIDEL,DIE,DIR,DIROUT,DIRUT,DR,DTOUT,DUOUT,X,Y
"RTN","RORHDTAC",45,0)
 S FAM=""
"RTN","RORHDTAC",46,0)
 ;--- Check status of the task
"RTN","RORHDTAC",47,0)
 S STATUS=+$$STATUS^RORHDTUT(REGIEN,TASKIEN)
"RTN","RORHDTAC",48,0)
 I STATUS=1  D  Q:RC $S(RC<0:RC,1:0)
"RTN","RORHDTAC",49,0)
 . K DIR  S DIR(0)="Y"
"RTN","RORHDTAC",50,0)
 . S DIR("A")="The task is pending. Do you want to rescheduled it"
"RTN","RORHDTAC",51,0)
 . S DIR("B")="NO"
"RTN","RORHDTAC",52,0)
 . D ^DIR  W !  S RC=$D(DIRUT)!'$G(Y)
"RTN","RORHDTAC",53,0)
 . S:'RC RC=$$STOP^RORHDT03(REGIEN,TASKIEN)
"RTN","RORHDTAC",54,0)
 I STATUS=2  D  Q 0
"RTN","RORHDTAC",55,0)
 . W !,"The task is running already",!
"RTN","RORHDTAC",56,0)
 I STATUS=100  D  Q:RC 0
"RTN","RORHDTAC",57,0)
 . K DIR  S DIR(0)="Y"
"RTN","RORHDTAC",58,0)
 . S DIR("A")="The task is completed. Do you want to rerun it"
"RTN","RORHDTAC",59,0)
 . S DIR("B")="NO"
"RTN","RORHDTAC",60,0)
 . D ^DIR  W !  S RC=$D(DIRUT)!'$G(Y)
"RTN","RORHDTAC",61,0)
 ;--- Check if the output file exists already
"RTN","RORHDTAC",62,0)
 S RC=$$TASKFILE^RORHDTUT(REGIEN,TASKIEN,.OUTDIR,.FILE)  Q:RC<0 RC
"RTN","RORHDTAC",63,0)
 S RORSRC(FILE)=""
"RTN","RORHDTAC",64,0)
 S RC=$$LIST^%ZISH(OUTDIR,"RORSRC","RORDST")
"RTN","RORHDTAC",65,0)
 I RC,$D(RORDST)>1  D  Q:RC 0
"RTN","RORHDTAC",66,0)
 . K DIR  S DIR(0)="SAB^N:New file;O:Overwrite"
"RTN","RORHDTAC",67,0)
 . S DIR("A",1)="Output file "_FILE_" exists already."
"RTN","RORHDTAC",68,0)
 . S DIR("A")="Overwrite or create a New file? "
"RTN","RORHDTAC",69,0)
 . S DIR("B")=$S(STATUS=101:"Overwrite",1:"New file")
"RTN","RORHDTAC",70,0)
 . D ^DIR  W !  S RC=$D(DIRUT)
"RTN","RORHDTAC",71,0)
 . S:'RC FAM=Y
"RTN","RORHDTAC",72,0)
 ;--- Confirm/modify the new file name
"RTN","RORHDTAC",73,0)
 I FAM["N"  D  Q:RC $S(RC<0:RC,1:0)
"RTN","RORHDTAC",74,0)
 . N RORFDA,RORMSG
"RTN","RORHDTAC",75,0)
 . S RC=$$NEWFILE^RORHDTUT(REGIEN,TASKIEN,.FILE,1)  Q:RC<0
"RTN","RORHDTAC",76,0)
 . K DIR  S DIR(0)="798.5,1.01"
"RTN","RORHDTAC",77,0)
 . S DIR("A")="File Name"
"RTN","RORHDTAC",78,0)
 . S DIR("B")=FILE
"RTN","RORHDTAC",79,0)
 . D ^DIR  W !  I $D(DIRUT)  S RC=1  Q
"RTN","RORHDTAC",80,0)
 . ;--- Store the new file name
"RTN","RORHDTAC",81,0)
 . S RORFDA(798.5,TASKIEN_",",1.01)=Y
"RTN","RORHDTAC",82,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORHDTAC",83,0)
 . S RC=$$DBS^RORERR("RORMSG",-9)
"RTN","RORHDTAC",84,0)
 Q 1
"RTN","RORHDTAC",85,0)
 ;
"RTN","RORHDTAC",86,0)
 ;***** CONFIRMATION TO STOP THE TASK
"RTN","RORHDTAC",87,0)
 ;
"RTN","RORHDTAC",88,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTAC",89,0)
 ; TASKIEN       Task IEN
"RTN","RORHDTAC",90,0)
 ;
"RTN","RORHDTAC",91,0)
 ; Return Values:
"RTN","RORHDTAC",92,0)
 ;       <0  Error code
"RTN","RORHDTAC",93,0)
 ;        0  Cancel
"RTN","RORHDTAC",94,0)
 ;        1  Stop the task
"RTN","RORHDTAC",95,0)
 ;
"RTN","RORHDTAC",96,0)
STOP(REGIEN,TASKIEN) ;
"RTN","RORHDTAC",97,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,STATUS,X,Y,ZTSK
"RTN","RORHDTAC",98,0)
 ;--- Check status of the task
"RTN","RORHDTAC",99,0)
 S STATUS=+$$STATUS^RORHDTUT(REGIEN,TASKIEN)
"RTN","RORHDTAC",100,0)
 Q:(STATUS'=1)&(STATUS'=2) 0 ; Neither running nor pending
"RTN","RORHDTAC",101,0)
 ;--- Get the task number
"RTN","RORHDTAC",102,0)
 S ZTSK=$$GET1^DIQ(798.5,TASKIEN_",",2.01,,,"RORMSG")
"RTN","RORHDTAC",103,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.5,TASKIEN)
"RTN","RORHDTAC",104,0)
 ;--- Ask for the final confirmation
"RTN","RORHDTAC",105,0)
 K DIR  S DIR(0)="Y"
"RTN","RORHDTAC",106,0)
 S DIR("A")=$S(STATUS=2:"Stop",1:"Dequeue")_" the task #"_ZTSK
"RTN","RORHDTAC",107,0)
 S DIR("B")="NO"
"RTN","RORHDTAC",108,0)
 D ^DIR  W !
"RTN","RORHDTAC",109,0)
 Q '$D(DIRUT)&$G(Y)
"RTN","RORHDTUT")
0^120^B26725557
"RTN","RORHDTUT",1,0)
RORHDTUT ;HCIOFO/SG - HISTORICAL DATA EXTRACTION UTILITIES ; 7/21/03 9:23am
"RTN","RORHDTUT",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHDTUT",3,0)
 ;
"RTN","RORHDTUT",4,0)
 Q
"RTN","RORHDTUT",5,0)
 ;
"RTN","RORHDTUT",6,0)
 ;***** DELETES THE REGISTRY TASK RECORDS
"RTN","RORHDTUT",7,0)
 ;
"RTN","RORHDTUT",8,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTUT",9,0)
 ;
"RTN","RORHDTUT",10,0)
 ; Return Values:
"RTN","RORHDTUT",11,0)
 ;       <0  Error code
"RTN","RORHDTUT",12,0)
 ;        0  Ok
"RTN","RORHDTUT",13,0)
 ;
"RTN","RORHDTUT",14,0)
CLRTTBL(REGIEN) ;
"RTN","RORHDTUT",15,0)
 N IENS,IR,RC,RORBUF,RORFDA,RORMSG
"RTN","RORHDTUT",16,0)
 ;--- Load a list of task records
"RTN","RORHDTUT",17,0)
 D FIND^DIC(798.5,,"@","QX",REGIEN,,"AR",,,"RORBUF","RORMSG")
"RTN","RORHDTUT",18,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.5)
"RTN","RORHDTUT",19,0)
 Q:$G(RORBUF("DILIST",0))<1 0
"RTN","RORHDTUT",20,0)
 ;--- Prepare the FDA
"RTN","RORHDTUT",21,0)
 S IR=""
"RTN","RORHDTUT",22,0)
 F  S IR=$O(RORBUF("DILIST",2,IR))  Q:IR=""  D
"RTN","RORHDTUT",23,0)
 . S RORFDA(798.5,RORBUF("DILIST",2,IR)_",",.01)="@"
"RTN","RORHDTUT",24,0)
 ;--- Delete the registry tasks
"RTN","RORHDTUT",25,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORHDTUT",26,0)
 Q $$DBS^RORERR("RORMSG",-9,,,798.5)
"RTN","RORHDTUT",27,0)
 ;
"RTN","RORHDTUT",28,0)
 ;***** GENERATES A NEW UNUSED FILE NAME FOR THE TASK
"RTN","RORHDTUT",29,0)
 ;
"RTN","RORHDTUT",30,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTUT",31,0)
 ; TASKIEN       Task IEN
"RTN","RORHDTUT",32,0)
 ; [.FILE]       New name is returned via this parameter
"RTN","RORHDTUT",33,0)
 ; [GNONLY]      Only generate a new name but do not store it into
"RTN","RORHDTUT",34,0)
 ;               task record
"RTN","RORHDTUT",35,0)
 ;
"RTN","RORHDTUT",36,0)
 ; Return Values:
"RTN","RORHDTUT",37,0)
 ;       <0  Error code
"RTN","RORHDTUT",38,0)
 ;        0  Ok
"RTN","RORHDTUT",39,0)
 ;
"RTN","RORHDTUT",40,0)
NEWFILE(REGIEN,TASKIEN,FILE,GNONLY) ;
"RTN","RORHDTUT",41,0)
 N BASE,EXT,FN,NAME,OUTDIR,RC,RORBUF,RORLST,RORMSG,TMP
"RTN","RORHDTUT",42,0)
 S RC=$$TASKFILE(REGIEN,TASKIEN,.OUTDIR,.FILE)  Q:RC<0 RC
"RTN","RORHDTUT",43,0)
 S BASE=$P($P(FILE,"."),"-"),EXT=$P($P(FILE,".",2),";")
"RTN","RORHDTUT",44,0)
 ;--- Get a list of files in the output directory
"RTN","RORHDTUT",45,0)
 S RORBUF(BASE_"*."_EXT)=""
"RTN","RORHDTUT",46,0)
 Q:'$$LIST^%ZISH(OUTDIR,"RORBUF","RORLST") 0
"RTN","RORHDTUT",47,0)
 Q:$D(RORLST)<10 0
"RTN","RORHDTUT",48,0)
 K RORBUF
"RTN","RORHDTUT",49,0)
 ;--- Generate a new name
"RTN","RORHDTUT",50,0)
 S NAME="",FN=0
"RTN","RORHDTUT",51,0)
 F  S NAME=$O(RORLST(NAME))  Q:NAME=""  D
"RTN","RORHDTUT",52,0)
 . S TMP=+$P(NAME,"-",2)  S:TMP>FN FN=TMP
"RTN","RORHDTUT",53,0)
 S FILE=BASE_"-"_$TR($J(FN+1,2)," ","0")_"."_EXT
"RTN","RORHDTUT",54,0)
 Q:$G(GNONLY) 0
"RTN","RORHDTUT",55,0)
 K RORLST
"RTN","RORHDTUT",56,0)
 ;--- Store it to the task record
"RTN","RORHDTUT",57,0)
 S RORBUF(798.5,TASKIEN_",",1.01)=FILE
"RTN","RORHDTUT",58,0)
 D FILE^DIE(,"RORBUF","RORMSG")
"RTN","RORHDTUT",59,0)
 Q $$DBS^RORERR("RORMSG",-9,,,798.5,TASKIEN)
"RTN","RORHDTUT",60,0)
 ;
"RTN","RORHDTUT",61,0)
 ;***** WAITS FOR [ENTER] FROM THE KEYBOARD
"RTN","RORHDTUT",62,0)
PAUSE ;
"RTN","RORHDTUT",63,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,X,Y
"RTN","RORHDTUT",64,0)
 I IO=IO(0)  D  D ^DIR
"RTN","RORHDTUT",65,0)
 . S DIR(0)="FAO",DIR("A")="Press Enter to continue ..."
"RTN","RORHDTUT",66,0)
 Q
"RTN","RORHDTUT",67,0)
 ;
"RTN","RORHDTUT",68,0)
 ;***** SELECTS A REGISTRY DESCRIPTOR IN THE FILE #798.1
"RTN","RORHDTUT",69,0)
 ;
"RTN","RORHDTUT",70,0)
 ; [.REGNAME]    Registry name is returned via this parameter
"RTN","RORHDTUT",71,0)
 ;
"RTN","RORHDTUT",72,0)
 ; Return Values:
"RTN","RORHDTUT",73,0)
 ;       <0  Error code
"RTN","RORHDTUT",74,0)
 ;       ""  Timeout, "^" entered, or an error in ^DIC
"RTN","RORHDTUT",75,0)
 ;        0  There are no records in the file #798.1
"RTN","RORHDTUT",76,0)
 ;       >0  IEN of the selected registry
"RTN","RORHDTUT",77,0)
 ;
"RTN","RORHDTUT",78,0)
SELREG(REGNAME) ;
"RTN","RORHDTUT",79,0)
 N DA,DIC,DLAYGO,DTOUT,DUOUT,RC,RORBUF,RORMSG,X,Y
"RTN","RORHDTUT",80,0)
 S REGNAME=""
"RTN","RORHDTUT",81,0)
 ;--- If there are less than two records, do not ask a user
"RTN","RORHDTUT",82,0)
 D LIST^DIC(798.1,,"@;.01E",,2,,,"B",,,"RORBUF","RORMSG")
"RTN","RORHDTUT",83,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.1)
"RTN","RORHDTUT",84,0)
 I $G(RORBUF("DILIST",0))<2  D  Q +$G(RORBUF("DILIST",2,1))
"RTN","RORHDTUT",85,0)
 . S REGNAME=$G(RORBUF("DILIST","ID",1,.01))
"RTN","RORHDTUT",86,0)
 ;--- Select a registry
"RTN","RORHDTUT",87,0)
 S DIC=798.1,DIC(0)="AENQZ"
"RTN","RORHDTUT",88,0)
 S DIC("A")="Select a Registry: "
"RTN","RORHDTUT",89,0)
 S DIC("B")=$G(RORHDT("DFLT","REG"))
"RTN","RORHDTUT",90,0)
 D ^DIC  W !
"RTN","RORHDTUT",91,0)
 S:Y>0 (RORHDT("DFLT","REG"),REGNAME)=Y(0,0)
"RTN","RORHDTUT",92,0)
 Q $S($D(DTOUT)!$D(DUOUT):"",Y<0:"",1:+Y)
"RTN","RORHDTUT",93,0)
 ;
"RTN","RORHDTUT",94,0)
 ;***** SELECTS A DATA EXTRACTION TASK
"RTN","RORHDTUT",95,0)
 ;
"RTN","RORHDTUT",96,0)
 ; RORREG        Registry IEN
"RTN","RORHDTUT",97,0)
 ;
"RTN","RORHDTUT",98,0)
 ; Return Values:
"RTN","RORHDTUT",99,0)
 ;       <0  Error code
"RTN","RORHDTUT",100,0)
 ;       ""  Timeout, "^" entered, or an error in the ^DIC
"RTN","RORHDTUT",101,0)
 ;        0  There are no tasks defined in the file #798.5
"RTN","RORHDTUT",102,0)
 ;       >0  IEN of the selected task
"RTN","RORHDTUT",103,0)
 ;
"RTN","RORHDTUT",104,0)
SELTASK(RORREG) ;
"RTN","RORHDTUT",105,0)
 N DA,DIC,DLAYGO,DTOUT,DUOUT,RC,RORBUF,RORMSG,X,Y
"RTN","RORHDTUT",106,0)
 ;--- If there are less than two records, do not ask a user
"RTN","RORHDTUT",107,0)
 D FIND^DIC(798.5,,"@","QX",RORREG,2,"AR",,,"RORBUF","RORMSG")
"RTN","RORHDTUT",108,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.5)
"RTN","RORHDTUT",109,0)
 Q:$G(RORBUF("DILIST",0))<2 +$G(RORBUF("DILIST",2,1))
"RTN","RORHDTUT",110,0)
 ;--- Display status of the tasks
"RTN","RORHDTUT",111,0)
 S RC=$$STATUS^RORHDT01(RORREG)  Q:RC<0 RC
"RTN","RORHDTUT",112,0)
 ;--- Select a task
"RTN","RORHDTUT",113,0)
 S DIC=798.5,DIC(0)="AEQS"
"RTN","RORHDTUT",114,0)
 S DIC("A")="Select a Task: "
"RTN","RORHDTUT",115,0)
 S DIC("B")=$G(RORHDT("DFLT","TSK"))
"RTN","RORHDTUT",116,0)
 S DIC("S")="I $P(^(0),U,2)=RORREG"
"RTN","RORHDTUT",117,0)
 D ^DIC  W !
"RTN","RORHDTUT",118,0)
 S:Y>0 RORHDT("DFLT","TSK")=+Y
"RTN","RORHDTUT",119,0)
 Q $S($D(DTOUT)!$D(DUOUT):"",Y<0:"",1:+Y)
"RTN","RORHDTUT",120,0)
 ;
"RTN","RORHDTUT",121,0)
 ;***** RETURNS STATUS OF THE TASK
"RTN","RORHDTUT",122,0)
 ;
"RTN","RORHDTUT",123,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTUT",124,0)
 ; TASKIEN       Task IEN
"RTN","RORHDTUT",125,0)
 ; [LTO]         LOCK timeout
"RTN","RORHDTUT",126,0)
 ;
"RTN","RORHDTUT",127,0)
 ; Return Values:
"RTN","RORHDTUT",128,0)
 ;       <0  Error code
"RTN","RORHDTUT",129,0)
 ;        0  Unknown Status
"RTN","RORHDTUT",130,0)
 ;       >0  Status (Code^Description)
"RTN","RORHDTUT",131,0)
 ;
"RTN","RORHDTUT",132,0)
 ;               1  Active: Pending
"RTN","RORHDTUT",133,0)
 ;               2  Active: Running
"RTN","RORHDTUT",134,0)
 ;               3  Inactive: Finished
"RTN","RORHDTUT",135,0)
 ;               4  Inactive: Available
"RTN","RORHDTUT",136,0)
 ;               5  Inactive: Interrupted
"RTN","RORHDTUT",137,0)
 ;
"RTN","RORHDTUT",138,0)
 ;             100  Completed
"RTN","RORHDTUT",139,0)
 ;             101  Inactive: Crashed
"RTN","RORHDTUT",140,0)
 ;             102  Completed with Errors
"RTN","RORHDTUT",141,0)
 ;
"RTN","RORHDTUT",142,0)
STATUS(REGIEN,TASKIEN,LTO) ;
"RTN","RORHDTUT",143,0)
 N HDTNODE,IENS,RC,RORBUF,RORMSG,STATUS,ZTSK
"RTN","RORHDTUT",144,0)
 S HDTNODE=$NA(^XTMP("RORHDT"_REGIEN))
"RTN","RORHDTUT",145,0)
 ;---Check if the task is running
"RTN","RORHDTUT",146,0)
 L +@HDTNODE@("T",TASKIEN):$G(LTO)
"RTN","RORHDTUT",147,0)
 E  Q "2^Active: Running"
"RTN","RORHDTUT",148,0)
 L -@HDTNODE@("T",TASKIEN)
"RTN","RORHDTUT",149,0)
 ;--- Load some data from the task record
"RTN","RORHDTUT",150,0)
 S IENS=TASKIEN_","
"RTN","RORHDTUT",151,0)
 D GETS^DIQ(798.5,IENS,"2.01;2.02;2.03","EI","RORBUF","RORMSG")
"RTN","RORHDTUT",152,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.5,IENS)
"RTN","RORHDTUT",153,0)
 ;--- Check the JOB NUMBER and COMPLETED fields
"RTN","RORHDTUT",154,0)
 Q:$G(RORBUF(798.5,IENS,2.03,"I")) "100^Completed"
"RTN","RORHDTUT",155,0)
 Q:$G(RORBUF(798.5,IENS,2.02,"I")) "101^Inactive: Crashed"
"RTN","RORHDTUT",156,0)
 S STATUS=0
"RTN","RORHDTUT",157,0)
 ;--- Try to get status from the Taskman
"RTN","RORHDTUT",158,0)
 S ZTSK=$G(RORBUF(798.5,IENS,2.01,"I"))
"RTN","RORHDTUT",159,0)
 I ZTSK  D  Q:STATUS STATUS
"RTN","RORHDTUT",160,0)
 . D STAT^%ZTLOAD  Q:'$G(ZTSK(0))!'$G(ZTSK(1))
"RTN","RORHDTUT",161,0)
 . S:ZTSK(1)'=2 STATUS=ZTSK(1)_U_ZTSK(2) ; Ignore 'Active:Running'
"RTN","RORHDTUT",162,0)
 ;--- Check the ERROR multiple
"RTN","RORHDTUT",163,0)
 D LIST^DIC(798.53,","_IENS,"@",,1,,,"B",,,"RORBUF","RORMSG")
"RTN","RORHDTUT",164,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.53)
"RTN","RORHDTUT",165,0)
 Q $S($G(RORBUF("DILIST",0))>0:"102^Completed with Errors",1:0)
"RTN","RORHDTUT",166,0)
 ;
"RTN","RORHDTUT",167,0)
 ;***** GETS A NAME OF THE TASK OUTPUT FILE
"RTN","RORHDTUT",168,0)
 ;
"RTN","RORHDTUT",169,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTUT",170,0)
 ; TASKIEN       Task IEN
"RTN","RORHDTUT",171,0)
 ; .OUTDIR       Output directory is returned via this parameter
"RTN","RORHDTUT",172,0)
 ; .FILE         File name is returned via the parameter
"RTN","RORHDTUT",173,0)
 ;
"RTN","RORHDTUT",174,0)
 ; Return Values:
"RTN","RORHDTUT",175,0)
 ;       <0  Error code
"RTN","RORHDTUT",176,0)
 ;        0  Ok
"RTN","RORHDTUT",177,0)
 ;
"RTN","RORHDTUT",178,0)
TASKFILE(REGIEN,TASKIEN,OUTDIR,FILE) ;
"RTN","RORHDTUT",179,0)
 N IENS,RC,RORMSG
"RTN","RORHDTUT",180,0)
 S (OUTDIR,FILE)=""
"RTN","RORHDTUT",181,0)
 ;--- Get the output directory
"RTN","RORHDTUT",182,0)
 S IENS=REGIEN_","
"RTN","RORHDTUT",183,0)
 S OUTDIR=$$GET1^DIQ(798.1,IENS,21.03,,,"RORMSG")
"RTN","RORHDTUT",184,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","RORHDTUT",185,0)
 ;--- Get the file name
"RTN","RORHDTUT",186,0)
 S IENS=TASKIEN_","
"RTN","RORHDTUT",187,0)
 S FILE=$$GET1^DIQ(798.5,IENS,1.01,,,"RORMSG")
"RTN","RORHDTUT",188,0)
 Q $$DBS^RORERR("RORMSG",-9,,,798.5,IENS)
"RTN","RORHDTUT",189,0)
 ;
"RTN","RORHDTUT",190,0)
 ;***** RETURNS TASK JOB NUMBER
"RTN","RORHDTUT",191,0)
 ;
"RTN","RORHDTUT",192,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTUT",193,0)
 ; TASKIEN       Task IEN
"RTN","RORHDTUT",194,0)
 ;
"RTN","RORHDTUT",195,0)
 ; Return Values:
"RTN","RORHDTUT",196,0)
 ;       <0  Error code
"RTN","RORHDTUT",197,0)
 ;        0  Task is not active
"RTN","RORHDTUT",198,0)
 ;       >0  Job number
"RTN","RORHDTUT",199,0)
 ;
"RTN","RORHDTUT",200,0)
TASKJOB(REGIEN,TASKIEN) ;
"RTN","RORHDTUT",201,0)
 N IENS,JOBNUM,RC,RORMSG
"RTN","RORHDTUT",202,0)
 S IENS=TASKIEN_","
"RTN","RORHDTUT",203,0)
 S JOBNUM=+$$GET1^DIQ(798.5,IENS,2.02,"I",,"RORMSG")
"RTN","RORHDTUT",204,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.5,IENS)
"RTN","RORHDTUT",205,0)
 Q JOBNUM
"RTN","RORHL01")
0^91^B10737410
"RTN","RORHL01",1,0)
RORHL01 ;HOIFO/CRT - HL7 PATIENT DATA: PID,ZSP,ZRD ; 2/10/04 8:57am
"RTN","RORHL01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3,5**;May 14, 2002
"RTN","RORHL01",3,0)
 ;
"RTN","RORHL01",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL01",5,0)
 ;
"RTN","RORHL01",6,0)
 ; #263          $$EN^VAFHLPID (controlled)
"RTN","RORHL01",7,0)
 ; #10035        Read access to the PATIENT file (supported)
"RTN","RORHL01",8,0)
 ; #10061        DEM^VADPT (supported)
"RTN","RORHL01",9,0)
 ;
"RTN","RORHL01",10,0)
 ; #???          $$EN^VAFHLZSP
"RTN","RORHL01",11,0)
 ; #???          EN^VAFHLZRD
"RTN","RORHL01",12,0)
 ;
"RTN","RORHL01",13,0)
 Q
"RTN","RORHL01",14,0)
 ;
"RTN","RORHL01",15,0)
 ;***** PID SEGMENT BUILDER
"RTN","RORHL01",16,0)
 ;
"RTN","RORHL01",17,0)
 ; RORDFN        DFN of Patient Record in File #2
"RTN","RORHL01",18,0)
 ;
"RTN","RORHL01",19,0)
 ; Return Values:
"RTN","RORHL01",20,0)
 ;       <0  Error Code
"RTN","RORHL01",21,0)
 ;        0  Ok
"RTN","RORHL01",22,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL01",23,0)
 ;
"RTN","RORHL01",24,0)
PID(RORDFN) ;
"RTN","RORHL01",25,0)
 N CS,ERRCNT,RC,RORFLDS,RORMSG,RORSEG,SCS,TMP,VAFPID
"RTN","RORHL01",26,0)
 S (ERRCNT,RC)=0
"RTN","RORHL01",27,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL01",28,0)
 S CS=$E(HLECH,1),SCS=$E(HLECH,4)
"RTN","RORHL01",29,0)
 ;
"RTN","RORHL01",30,0)
 ;--- Check if the patient exists
"RTN","RORHL01",31,0)
 S RORDFN=+$G(RORDFN)
"RTN","RORHL01",32,0)
 I '$D(^DPT(RORDFN))  D  Q RC
"RTN","RORHL01",33,0)
 . S RC=$$ERROR^RORERR(-36,,,RORDFN,2)
"RTN","RORHL01",34,0)
 ;
"RTN","RORHL01",35,0)
 S RORFLDS="2,3,5,7,8,11,19,22BT,29" ; Default HL7 fields
"RTN","RORHL01",36,0)
 D  ; Either new or old race information
"RTN","RORHL01",37,0)
 . N DFN,VA,VADM,VAHOW,VAROOT  S DFN=RORDFN  D DEM^VADPT
"RTN","RORHL01",38,0)
 . S RORFLDS=RORFLDS_$S($G(VADM(12))>0:",10BT",1:",10")
"RTN","RORHL01",39,0)
 ;
"RTN","RORHL01",40,0)
 ;--- Call Standard PID Segment builder
"RTN","RORHL01",41,0)
 S RORSEG=$$EN^VAFHLPID(RORDFN,RORFLDS)
"RTN","RORHL01",42,0)
 S:$G(VAFPID(1))'="" RORSEG=RORSEG_VAFPID(1)
"RTN","RORHL01",43,0)
 ;
"RTN","RORHL01",44,0)
 ;--- PID-2 ICN
"RTN","RORHL01",45,0)
 S TMP=$$ICN^RORUTL02(RORDFN)
"RTN","RORHL01",46,0)
 I TMP>0  S $P(RORSEG,HLFS,3)=$TR(TMP,"V",CS)_CS_"ISO"_CS_"VAMPI"
"RTN","RORHL01",47,0)
 E  S $P(RORSEG,HLFS,3)=""
"RTN","RORHL01",48,0)
 ;
"RTN","RORHL01",49,0)
 ;--- PID-3 DFN + Old-ICN and Old-SSN if applicable
"RTN","RORHL01",50,0)
 S TMP=$$M10^HLFNC(RORDFN,CS)
"RTN","RORHL01",51,0)
 S $P(TMP,CS,5)="PI"
"RTN","RORHL01",52,0)
 S $P(TMP,CS,6)=$$SITE^RORUTL03(SCS)
"RTN","RORHL01",53,0)
 S $P(RORSEG,HLFS,4)=TMP
"RTN","RORHL01",54,0)
 ;
"RTN","RORHL01",55,0)
 ;--- PID-5 Encrypt Patient Name
"RTN","RORHL01",56,0)
 S $P(RORSEG,HLFS,6)=$$ENCRYPT^RORUTL03($P(RORSEG,HLFS,6))
"RTN","RORHL01",57,0)
 ;
"RTN","RORHL01",58,0)
 ;--- PID-11 Remove Address (leave ZIP only)
"RTN","RORHL01",59,0)
 S $P(RORSEG,HLFS,12)=CS_CS_CS_CS_$E($P($P(RORSEG,HLFS,12),CS,5),1,5)
"RTN","RORHL01",60,0)
 ;
"RTN","RORHL01",61,0)
 ;--- PID-19 Encrypt SSN
"RTN","RORHL01",62,0)
 S $P(RORSEG,HLFS,20)=$$ENCRYPT^RORUTL03($P(RORSEG,HLFS,20))
"RTN","RORHL01",63,0)
 ;
"RTN","RORHL01",64,0)
 ;--- PID-29 Date of Death (not supported by EN^VAFHLPID)
"RTN","RORHL01",65,0)
 S TMP=$$GET1^DIQ(2,RORDFN,.351,"I",,"RORMSG")
"RTN","RORHL01",66,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,RORDFN,2,RORDFN)
"RTN","RORHL01",67,0)
 I TMP'="" S $P(RORSEG,HLFS,30)=$$FM2HL^RORHL7(TMP)
"RTN","RORHL01",68,0)
 ;
"RTN","RORHL01",69,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL01",70,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL01",71,0)
 Q ERRCNT
"RTN","RORHL01",72,0)
 ;
"RTN","RORHL01",73,0)
 ;***** ZSP SEGMENT BUILDER
"RTN","RORHL01",74,0)
 ;
"RTN","RORHL01",75,0)
 ; RORDFN        DFN of Patient Record in File #2
"RTN","RORHL01",76,0)
 ;
"RTN","RORHL01",77,0)
 ; Return Values:
"RTN","RORHL01",78,0)
 ;       <0  Error Code
"RTN","RORHL01",79,0)
 ;        0  Ok
"RTN","RORHL01",80,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL01",81,0)
 ;
"RTN","RORHL01",82,0)
ZSP(RORDFN) ;
"RTN","RORHL01",83,0)
 N RC,RORFLDS,RORSEG
"RTN","RORHL01",84,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL01",85,0)
 S RC=0
"RTN","RORHL01",86,0)
 ;
"RTN","RORHL01",87,0)
 ;--- Check if the patient exists
"RTN","RORHL01",88,0)
 S RORDFN=+$G(RORDFN)
"RTN","RORHL01",89,0)
 I '$D(^DPT(RORDFN))  D  Q RC
"RTN","RORHL01",90,0)
 . S RC=$$ERROR^RORERR(-36,,,RORDFN,2)
"RTN","RORHL01",91,0)
 ;
"RTN","RORHL01",92,0)
 S RORFLDS="1,2,3,4" ; Default HL7 fields
"RTN","RORHL01",93,0)
 ;
"RTN","RORHL01",94,0)
 ;--- Call Standard ZSP Segment Builder
"RTN","RORHL01",95,0)
 S RORSEG=$$EN^VAFHLZSP(RORDFN)
"RTN","RORHL01",96,0)
 ;
"RTN","RORHL01",97,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL01",98,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL01",99,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORHL01",100,0)
 ;
"RTN","RORHL01",101,0)
 ;***** ZRD SEGMENT BUILDER
"RTN","RORHL01",102,0)
 ;
"RTN","RORHL01",103,0)
 ; RORDFN        DFN of Patient Record in File #2
"RTN","RORHL01",104,0)
 ;
"RTN","RORHL01",105,0)
 ; Return Values:
"RTN","RORHL01",106,0)
 ;       <0  Error Code
"RTN","RORHL01",107,0)
 ;        0  Ok
"RTN","RORHL01",108,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL01",109,0)
 ;
"RTN","RORHL01",110,0)
ZRD(RORDFN) ;
"RTN","RORHL01",111,0)
 N I,RC,RORFLDS,RORSEG
"RTN","RORHL01",112,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL01",113,0)
 S RC=0
"RTN","RORHL01",114,0)
 ;
"RTN","RORHL01",115,0)
 ;--- Check if the patient exists
"RTN","RORHL01",116,0)
 S RORDFN=+$G(RORDFN)
"RTN","RORHL01",117,0)
 I '$D(^DPT(RORDFN))  D  Q RC
"RTN","RORHL01",118,0)
 . S RC=$$ERROR^RORERR(-36,,,RORDFN,2)
"RTN","RORHL01",119,0)
 ;
"RTN","RORHL01",120,0)
 S RORFLDS="1,2,3,4" ; Default HL7 fields
"RTN","RORHL01",121,0)
 ;
"RTN","RORHL01",122,0)
 ;--- Call Standard ZRD Segment Builder
"RTN","RORHL01",123,0)
 D EN^VAFHLZRD(RORDFN,RORFLDS,,HLFS,"RORSEG")
"RTN","RORHL01",124,0)
 ;
"RTN","RORHL01",125,0)
 ;--- Store the segment(s) in ^TMP("HLS",$J)
"RTN","RORHL01",126,0)
 S I=""
"RTN","RORHL01",127,0)
 F  S I=$O(RORSEG(I))  Q:I=""  Q:$P($G(RORSEG(I,0)),HLFS,3)=""  D
"RTN","RORHL01",128,0)
 . D SETSEG^RORHL7(RORSEG(I,0))
"RTN","RORHL01",129,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORHL02")
0^88^B44443526
"RTN","RORHL02",1,0)
RORHL02 ;HOIFO/CRT,SG - HL7 REGISTRY DATA: CSP,CSR,CSS ; 10/2/03 7:58am
"RTN","RORHL02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORHL02",3,0)
 ;
"RTN","RORHL02",4,0)
 Q
"RTN","RORHL02",5,0)
 ;
"RTN","RORHL02",6,0)
 ;***** CSP SEGMENT BUILDER
"RTN","RORHL02",7,0)
 ;
"RTN","RORHL02",8,0)
 ; RORIENS       IENS of Patient Record in Registry File
"RTN","RORHL02",9,0)
 ;
"RTN","RORHL02",10,0)
 ; [RORFLDS]     Segment Fields to populate
"RTN","RORHL02",11,0)
 ;               (1,2,3 available)
"RTN","RORHL02",12,0)
 ;
"RTN","RORHL02",13,0)
 ; Return Values:
"RTN","RORHL02",14,0)
 ;       <0  Error Code
"RTN","RORHL02",15,0)
 ;        0  Ok
"RTN","RORHL02",16,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL02",17,0)
 ;
"RTN","RORHL02",18,0)
CSP(RORIENS,RORFLDS) ;
"RTN","RORHL02",19,0)
 N CS,ERRCNT,FLDS,RC,RORMSG,ROROUT,RORSEG,TMP
"RTN","RORHL02",20,0)
 S (ERRCNT,RC)=0
"RTN","RORHL02",21,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL02",22,0)
 S CS=$E(HLECH,1)
"RTN","RORHL02",23,0)
 ;--- Check the parameters
"RTN","RORHL02",24,0)
 S:$E(RORIENS,$L(RORIENS))'="," RORIENS=RORIENS_","
"RTN","RORHL02",25,0)
 ;
"RTN","RORHL02",26,0)
 I $G(RORFLDS)'=""  D
"RTN","RORHL02",27,0)
 . S:$E(RORFLDS)'="," RORFLDS=","_RORFLDS
"RTN","RORHL02",28,0)
 . S:$E(RORFLDS,$L(RORFLDS))'="," RORFLDS=RORFLDS_","
"RTN","RORHL02",29,0)
 E  S RORFLDS=",1,2,3," ; Default HL7 fields
"RTN","RORHL02",30,0)
 ;
"RTN","RORHL02",31,0)
 S FLDS="1;2;3;7"
"RTN","RORHL02",32,0)
 D GETS^DIQ(798,RORIENS,FLDS,"IE","ROROUT","RORMSG")
"RTN","RORHL02",33,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,RORIENS)
"RTN","RORHL02",34,0)
 ;
"RTN","RORHL02",35,0)
 ;--- Initialize the segment
"RTN","RORHL02",36,0)
 S RORSEG="CSP"
"RTN","RORHL02",37,0)
 ;
"RTN","RORHL02",38,0)
 ;--- CSP-1 - New Patient?
"RTN","RORHL02",39,0)
 I RORFLDS[",1,"  D
"RTN","RORHL02",40,0)
 . S TMP=+$G(ROROUT(798,RORIENS,3,"I"))
"RTN","RORHL02",41,0)
 . I TMP>0  S $P(TMP,CS,2)=$G(ROROUT(798,RORIENS,3,"E"))
"RTN","RORHL02",42,0)
 . E  S TMP="0"_CS_"Edit"_CS_"99VA7983"
"RTN","RORHL02",43,0)
 . S $P(RORSEG,HLFS,2)=TMP
"RTN","RORHL02",44,0)
 ;
"RTN","RORHL02",45,0)
 ;--- CSP-2 - Reactivation Date or Registration Date
"RTN","RORHL02",46,0)
 I RORFLDS[",2,"  D  Q:RC<0 RC
"RTN","RORHL02",47,0)
 . S TMP=$G(ROROUT(798,RORIENS,7,"I"))
"RTN","RORHL02",48,0)
 . I TMP'>0  S TMP=$G(ROROUT(798,RORIENS,1,"I"))  I TMP'>0  D  Q
"RTN","RORHL02",49,0)
 . . S RC=$$ERROR^RORERR(-95,,,,798,RORIENS,"1,7")
"RTN","RORHL02",50,0)
 . S $P(RORSEG,HLFS,3)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL02",51,0)
 ;
"RTN","RORHL02",52,0)
 ;--- CSP-3 - Inactivation Date or null
"RTN","RORHL02",53,0)
 I RORFLDS[",3,"  D
"RTN","RORHL02",54,0)
 . S TMP=$G(ROROUT(798,RORIENS,2,"I"))
"RTN","RORHL02",55,0)
 . Q:TMP'>$G(ROROUT(798,RORIENS,7,"I"))
"RTN","RORHL02",56,0)
 . S $P(RORSEG,HLFS,4)=$$FM2HL^RORHL7(TMP)
"RTN","RORHL02",57,0)
 ;
"RTN","RORHL02",58,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL02",59,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL02",60,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL02",61,0)
 ;
"RTN","RORHL02",62,0)
 ;***** CSR SEGMENT BUILDER
"RTN","RORHL02",63,0)
 ;
"RTN","RORHL02",64,0)
 ; RORIENS       IENS of Patient Record in Registry File
"RTN","RORHL02",65,0)
 ;
"RTN","RORHL02",66,0)
 ; [RORFLDS]     Segment Fields to populate
"RTN","RORHL02",67,0)
 ;               (1,3,4,6,9,10,11,14,15,16 available)
"RTN","RORHL02",68,0)
 ;
"RTN","RORHL02",69,0)
 ; Return Values:
"RTN","RORHL02",70,0)
 ;       <0  Error Code
"RTN","RORHL02",71,0)
 ;        0  Ok
"RTN","RORHL02",72,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL02",73,0)
 ;
"RTN","RORHL02",74,0)
CSR(RORIENS,RORFLDS) ;
"RTN","RORHL02",75,0)
 N BUF,CS,ERRCNT,FLDS,RC,RORMSG,ROROUT,RORSEG,RORTXT,SCS,TMP
"RTN","RORHL02",76,0)
 S (ERRCNT,RC)=0
"RTN","RORHL02",77,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL02",78,0)
 S CS=$E(HLECH,1),SCS=$E(HLECH,4)
"RTN","RORHL02",79,0)
 ;--- Check the parameters
"RTN","RORHL02",80,0)
 S:$E(RORIENS,$L(RORIENS))'="," RORIENS=RORIENS_","
"RTN","RORHL02",81,0)
 ;
"RTN","RORHL02",82,0)
 S FLDS=".01;.02;1;2;2.2;6;6.1"
"RTN","RORHL02",83,0)
 D GETS^DIQ(798,RORIENS,FLDS,"IE","ROROUT","RORMSG")
"RTN","RORHL02",84,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,RORIENS)
"RTN","RORHL02",85,0)
 ;
"RTN","RORHL02",86,0)
 I $G(RORFLDS)'=""  D
"RTN","RORHL02",87,0)
 . S:$E(RORFLDS)'="," RORFLDS=","_RORFLDS
"RTN","RORHL02",88,0)
 . S:$E(RORFLDS,$L(RORFLDS))'="," RORFLDS=RORFLDS_","
"RTN","RORHL02",89,0)
 E  S RORFLDS=",1,3,4,6,8,9,10,11,14,15,16," ; Default HL7 fields
"RTN","RORHL02",90,0)
 ;
"RTN","RORHL02",91,0)
 ;--- Initialize the segment
"RTN","RORHL02",92,0)
 S RORSEG="CSR"
"RTN","RORHL02",93,0)
 ;
"RTN","RORHL02",94,0)
 ;--- CSR-1 - Name of the registry and version of the ROR system
"RTN","RORHL02",95,0)
 I RORFLDS[",1,"  D
"RTN","RORHL02",96,0)
 . S TMP="ROR"_SCS_$TR($P(ROREXT("VERSION"),U,1,2),U,SCS)
"RTN","RORHL02",97,0)
 . S $P(RORSEG,HLFS,2)=$G(ROROUT(798,RORIENS,.02,"E"))_CS_"VA"_CS_TMP
"RTN","RORHL02",98,0)
 ;
"RTN","RORHL02",99,0)
 ;--- CSR-3 - Inpatient Division or User Division if fails
"RTN","RORHL02",100,0)
 I RORFLDS[",3,"  D
"RTN","RORHL02",101,0)
 . S $P(RORSEG,HLFS,4)=$$SITE^RORUTL03(CS)
"RTN","RORHL02",102,0)
 ;
"RTN","RORHL02",103,0)
 ;--- CSR-4 - Patient ID
"RTN","RORHL02",104,0)
 I RORFLDS[",4,"  D
"RTN","RORHL02",105,0)
 . S TMP=$$M10^HLFNC(ROROUT(798,RORIENS,.01,"I"),CS)_CS_CS_"PI"
"RTN","RORHL02",106,0)
 . S:TMP>0 $P(RORSEG,HLFS,5)=TMP_CS_$TR($P(RORSEG,HLFS,4),CS,SCS)
"RTN","RORHL02",107,0)
 ;
"RTN","RORHL02",108,0)
 ;--- CSR-6 - Date when entered to the registry
"RTN","RORHL02",109,0)
 I RORFLDS[",6,"  D  Q:RC<0 RC
"RTN","RORHL02",110,0)
 . S TMP=$$FMTHL7^XLFDT($G(ROROUT(798,RORIENS,1,"I"))\1)
"RTN","RORHL02",111,0)
 . I TMP'>0  S RC=$$ERROR^RORERR(-95,,,,798,RORIENS,1)  Q
"RTN","RORHL02",112,0)
 . S $P(RORSEG,HLFS,7)=TMP
"RTN","RORHL02",113,0)
 ;
"RTN","RORHL02",114,0)
 ;--- CSR-9 Date of Category 4 (ICR)
"RTN","RORHL02",115,0)
 I RORFLDS[",9,",$D(^RORDATA(799.4,+RORIENS))>1  D  Q:RC<0 RC
"RTN","RORHL02",116,0)
 . D GETS^DIQ(799.4,RORIENS,".02;.03","I","ROROUT","RORMSG")
"RTN","RORHL02",117,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL02",118,0)
 . . D DBS^RORERR("RORMSG",-9,,,799.4,RORIENS)
"RTN","RORHL02",119,0)
 . Q:'$G(ROROUT(799.4,RORIENS,.02,"I"))
"RTN","RORHL02",120,0)
 . ;---
"RTN","RORHL02",121,0)
 . S TMP=$$FMTHL7^XLFDT($G(ROROUT(799.4,RORIENS,.03,"I")))
"RTN","RORHL02",122,0)
 . ; I TMP'>0  S RC=$$ERROR^RORERR(-95,,,,799.4,RORIENS,.03)  Q
"RTN","RORHL02",123,0)
 . S $P(RORSEG,HLFS,10)=TMP
"RTN","RORHL02",124,0)
 ;
"RTN","RORHL02",125,0)
 ;--- CSR-10 - Supporting Evidence and Reasons Added
"RTN","RORHL02",126,0)
 I RORFLDS[",10,"  D
"RTN","RORHL02",127,0)
 . S $P(RORSEG,HLFS,11)=$$ADREASON^RORHLUT1(RORIENS,CS)
"RTN","RORHL02",128,0)
 ;
"RTN","RORHL02",129,0)
 ;--- CSR-11 - Date CD4 form complete (ICR)
"RTN","RORHL02",130,0)
 I RORFLDS[",11,",$D(^RORDATA(799.4,+RORIENS))>1  D
"RTN","RORHL02",131,0)
 . S TMP=$$GET1^DIQ(799.4,RORIENS,9.01,"I",,"RORMSG")
"RTN","RORHL02",132,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL02",133,0)
 . . D DBS^RORERR("RORMSG",-9,,,799.4,RORIENS)
"RTN","RORHL02",134,0)
 . S $P(RORSEG,HLFS,12)=$$FM2HL^RORHL7(TMP)
"RTN","RORHL02",135,0)
 ;
"RTN","RORHL02",136,0)
 ;--- CSR-14 - Investigational drugs + Medication in Profile
"RTN","RORHL02",137,0)
 I RORFLDS[",14,"  D
"RTN","RORHL02",138,0)
 . N ID,MP
"RTN","RORHL02",139,0)
 . S ID=+$G(ROROUT(798,RORIENS,6,"I"))
"RTN","RORHL02",140,0)
 . S MP=+$G(ROROUT(798,RORIENS,6.1,"I"))
"RTN","RORHL02",141,0)
 . S BUF=ID_MP
"RTN","RORHL02",142,0)
 . S $P(BUF,CS,2)="Investigational Drugs "_$S(ID:"",1:"Not ")_"Used."
"RTN","RORHL02",143,0)
 . I ID  S TMP=$S(MP:"",1:"Not ")  D
"RTN","RORHL02",144,0)
 . . S $P(BUF,CS,2)=$P(BUF,CS,2)_" Medication "_TMP_"in Profile."
"RTN","RORHL02",145,0)
 . S $P(RORSEG,HLFS,15)=BUF_CS_"99VA7986"
"RTN","RORHL02",146,0)
 ;
"RTN","RORHL02",147,0)
 ;--- CSR-15 - Inactivation date
"RTN","RORHL02",148,0)
 I RORFLDS[",15,"  D
"RTN","RORHL02",149,0)
 . S TMP=$G(ROROUT(798,RORIENS,2,"I"))
"RTN","RORHL02",150,0)
 . I TMP'="" S $P(RORSEG,HLFS,16)=$$FM2HL^RORHL7(TMP)
"RTN","RORHL02",151,0)
 ;
"RTN","RORHL02",152,0)
 ;--- CSR-16 - Inactivation Reason
"RTN","RORHL02",153,0)
 I RORFLDS[",16,",$G(ROROUT(798,RORIENS,2.2,"I"))  D
"RTN","RORHL02",154,0)
 . S BUF=$$ITEMCODE^RORUTL09(ROROUT(798,RORIENS,2.2,"I"),.RORTXT)
"RTN","RORHL02",155,0)
 . S $P(BUF,CS,2)=$$ESCAPE^RORHL7(RORTXT)
"RTN","RORHL02",156,0)
 . S $P(BUF,CS,3)="99VA79822"
"RTN","RORHL02",157,0)
 . S:BUF>0 $P(RORSEG,HLFS,17)=BUF
"RTN","RORHL02",158,0)
 ;
"RTN","RORHL02",159,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL02",160,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL02",161,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL02",162,0)
 ;
"RTN","RORHL02",163,0)
 ;***** CSS SEGMENT BUILDER
"RTN","RORHL02",164,0)
 ;
"RTN","RORHL02",165,0)
 ; RORIENS       IENS of Patient Record in Registry File
"RTN","RORHL02",166,0)
 ;
"RTN","RORHL02",167,0)
 ; [RORFLDS]     Segment Fields to populate
"RTN","RORHL02",168,0)
 ;               (1,2,3 available)
"RTN","RORHL02",169,0)
 ;
"RTN","RORHL02",170,0)
 ; Return Values:
"RTN","RORHL02",171,0)
 ;       <0  Error Code
"RTN","RORHL02",172,0)
 ;        0  Ok
"RTN","RORHL02",173,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL02",174,0)
 ;
"RTN","RORHL02",175,0)
CSS(RORIENS,RORFLDS) ;
"RTN","RORHL02",176,0)
 N CS,ERRCNT,RC,REP,RORMSG,RORSEG,TMP
"RTN","RORHL02",177,0)
 S (ERRCNT,RC)=0
"RTN","RORHL02",178,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL02",179,0)
 S CS=$E(HLECH,1),REP=$E(HLECH,2)
"RTN","RORHL02",180,0)
 ;--- Check the parameters
"RTN","RORHL02",181,0)
 S:$E(RORIENS,$L(RORIENS))'="," RORIENS=RORIENS_","
"RTN","RORHL02",182,0)
 ;
"RTN","RORHL02",183,0)
 I RORFLDS'=""  D
"RTN","RORHL02",184,0)
 . S:$E(RORFLDS)'="," RORFLDS=","_RORFLDS
"RTN","RORHL02",185,0)
 . S:$E(RORFLDS,$L(RORFLDS))'="," RORFLDS=RORFLDS_","
"RTN","RORHL02",186,0)
 E  S RORFLDS=",1,2,3," ; Default HL7 fields
"RTN","RORHL02",187,0)
 ;
"RTN","RORHL02",188,0)
 ;--- Initialize the segment
"RTN","RORHL02",189,0)
 S RORSEG="CSS"
"RTN","RORHL02",190,0)
 ;
"RTN","RORHL02",191,0)
 ;--- CSS-1 Required Field. Set to "O"
"RTN","RORHL02",192,0)
 S $P(RORSEG,HLFS,2)="O"_CS_"ONE TIME ONLY"_CS_"L"
"RTN","RORHL02",193,0)
 ;
"RTN","RORHL02",194,0)
 ;--- CSS-2 Last Extract Date
"RTN","RORHL02",195,0)
 I RORFLDS[",2,"  D  Q:RC<0 RC
"RTN","RORHL02",196,0)
 . S TMP=$$GET1^DIQ(798,RORIENS,"#.02:#2","I",,"RORMSG")
"RTN","RORHL02",197,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL02",198,0)
 . . D DBS^RORERR("RORMSG",-9,,,798,RORIENS)
"RTN","RORHL02",199,0)
 . S $P(RORSEG,HLFS,3)=$$FM2HL^RORHL7(TMP)
"RTN","RORHL02",200,0)
 ;
"RTN","RORHL02",201,0)
 ;--- CSS-3 Risk Factors (ICR)
"RTN","RORHL02",202,0)
 I RORFLDS[",3,",$D(^RORDATA(799.4,+RORIENS))>1  D
"RTN","RORHL02",203,0)
 . N CNT,EV,FLD,RFLST,RORBUF,RORQUIT,RORRISK
"RTN","RORHL02",204,0)
 . S RFLST="14.01;14.02;14.03;14.04;14.07;14.08;14.09;14.1;14.11;14.12;14.13;14.16;14.17"
"RTN","RORHL02",205,0)
 . D GETS^DIQ(799.4,RORIENS,RFLST,"I","RORBUF","RORMSG")
"RTN","RORHL02",206,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL02",207,0)
 . . D DBS^RORERR("RORMSG",-9,,,799.4,RORIENS)
"RTN","RORHL02",208,0)
 . ;---
"RTN","RORHL02",209,0)
 . S RORRISK="",RORQUIT=0
"RTN","RORHL02",210,0)
 . F CNT=1:1  S FLD=$P(RFLST,";",CNT)  Q:FLD=""  D:FLD>0  Q:RORQUIT
"RTN","RORHL02",211,0)
 . . S TMP=$G(RORBUF(799.4,RORIENS,FLD,"I"))
"RTN","RORHL02",212,0)
 . . S EV=$S(TMP=0:"NO",TMP=1:"YES",TMP=9:"UNKNOWN",1:"")
"RTN","RORHL02",213,0)
 . . I EV=""  S RORRISK="",RORQUIT=1  Q
"RTN","RORHL02",214,0)
 . . S $P(RORRISK,REP,CNT)=TMP_CS_EV
"RTN","RORHL02",215,0)
 . S $P(RORSEG,HLFS,4)=RORRISK
"RTN","RORHL02",216,0)
 ;
"RTN","RORHL02",217,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL02",218,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL02",219,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL03")
0^37^B31127289
"RTN","RORHL03",1,0)
RORHL03 ;HOIFO/CRT - HL7 PHARMACY: ORC,RXE ; 12/2/03 1:47pm
"RTN","RORHL03",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORHL03",3,0)
 ;
"RTN","RORHL03",4,0)
 ; Routine's RORHL03* use the following IAs:
"RTN","RORHL03",5,0)
 ;
"RTN","RORHL03",6,0)
 ; #93-A         Get stop code from the file #44 (controlled)
"RTN","RORHL03",7,0)
 ; #1878         EN^PSOORDER (supported)
"RTN","RORHL03",8,0)
 ; #2400         OCL^PSOORRL and OEL^PSOORRL (controlled)
"RTN","RORHL03",9,0)
 ; #10060        Read access to file #200 (supported)
"RTN","RORHL03",10,0)
 ; #10090        Read access to file #4 (supported)
"RTN","RORHL03",11,0)
 ;
"RTN","RORHL03",12,0)
 ; #1977         Read access to file #52
"RTN","RORHL03",13,0)
 ; #1876         Read access to file #59
"RTN","RORHL03",14,0)
 ; #2497         Read access to file #55
"RTN","RORHL03",15,0)
 ; #221          Read access to file #50 and #50.68
"RTN","RORHL03",16,0)
 ; #2221         Read access to file 50.607
"RTN","RORHL03",17,0)
 ;
"RTN","RORHL03",18,0)
 ;***** PHARMACY DATA SEGMENT BUILDER
"RTN","RORHL03",19,0)
 ;
"RTN","RORHL03",20,0)
 ; RORDFN        DFN of Patient Record in File #2
"RTN","RORHL03",21,0)
 ;
"RTN","RORHL03",22,0)
 ; RORSTDT       Start Date/Time (Fileman)
"RTN","RORHL03",23,0)
 ; RORENDT       End Date/Time (Fileman)
"RTN","RORHL03",24,0)
 ;
"RTN","RORHL03",25,0)
 ; Return Values:
"RTN","RORHL03",26,0)
 ;       <0  Error Code
"RTN","RORHL03",27,0)
 ;        0  Ok
"RTN","RORHL03",28,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL03",29,0)
 ;
"RTN","RORHL03",30,0)
 ; The function uses the ^TMP("PS",$J) and ^TMP($J,"ROR-PS")
"RTN","RORHL03",31,0)
 ; global nodes.
"RTN","RORHL03",32,0)
 ;
"RTN","RORHL03",33,0)
EN1(RORDFN,RORSTDT,RORENDT) ;
"RTN","RORHL03",34,0)
 N ERRCNT,IEN,IENS,II,RC,RORII,RORINC,RORINDEX,RORMSG,RORORD,RORRXE,RORXII,TMP
"RTN","RORHL03",35,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL03",36,0)
 S (ERRCNT,RC)=0
"RTN","RORHL03",37,0)
 ;
"RTN","RORHL03",38,0)
 ;--- Load the list of prescriptions
"RTN","RORHL03",39,0)
 K ^TMP("PS",$J)
"RTN","RORHL03",40,0)
 D OCL^PSOORRL(RORDFN,RORSTDT,RORENDT)
"RTN","RORHL03",41,0)
 Q:$D(^TMP("PS",$J))<10 0
"RTN","RORHL03",42,0)
 ;
"RTN","RORHL03",43,0)
 ;--- Select the prescriptions
"RTN","RORHL03",44,0)
 K ^TMP($J,"ROR-PS")
"RTN","RORHL03",45,0)
 S RORII=0
"RTN","RORHL03",46,0)
 F  S RORII=$O(^TMP("PS",$J,RORII))  Q:'RORII  D
"RTN","RORHL03",47,0)
 . S RORORD=$P(^TMP("PS",$J,RORII,0),U)
"RTN","RORHL03",48,0)
 . Q:RORORD'>0
"RTN","RORHL03",49,0)
 . S II=$P(RORORD,";"),II=$E(II,$L(II))
"RTN","RORHL03",50,0)
 . Q:'("RUV"[II)
"RTN","RORHL03",51,0)
 . ;---
"RTN","RORHL03",52,0)
 . I "UV"[II   D  Q:(TMP<RORSTDT)!(TMP'<RORENDT)
"RTN","RORHL03",53,0)
 . . S TMP=$P($G(^TMP("PS",$J,RORII,0)),U,15)
"RTN","RORHL03",54,0)
 . I II="R"  D  Q:TMP<RORSTDT
"RTN","RORHL03",55,0)
 . . S TMP=$P($G(^TMP("PS",$J,RORII,0)),U,10)
"RTN","RORHL03",56,0)
 . ;---
"RTN","RORHL03",57,0)
 . ;M ^TMP($J,"ROR-PS",RORII)=^TMP("PS",$J,RORII)
"RTN","RORHL03",58,0)
 . S ^TMP($J,"ROR-PS",RORII,0)=^TMP("PS",$J,RORII,0)
"RTN","RORHL03",59,0)
 K ^TMP("PS",$J)
"RTN","RORHL03",60,0)
 ;
"RTN","RORHL03",61,0)
 ;--- Browse through the list and generate the HL7 segments
"RTN","RORHL03",62,0)
 S RORII=0
"RTN","RORHL03",63,0)
 F  S RORII=$O(^TMP($J,"ROR-PS",RORII))  Q:'RORII  D  Q:RC<0
"RTN","RORHL03",64,0)
 . S RORORD=$P(^TMP($J,"ROR-PS",RORII,0),U)
"RTN","RORHL03",65,0)
 . S RORXII=$P(RORORD,";"),RORXII=$E(RORXII,$L(RORXII))
"RTN","RORHL03",66,0)
 . ;
"RTN","RORHL03",67,0)
 . K ^TMP("PS",$J),RORRXE
"RTN","RORHL03",68,0)
 . D OEL^PSOORRL(RORDFN,RORORD)
"RTN","RORHL03",69,0)
 . Q:$D(^TMP("PS",$J))<10
"RTN","RORHL03",70,0)
 . M RORRXE=^TMP("PS",$J)
"RTN","RORHL03",71,0)
 . K ^TMP("PS",$J)
"RTN","RORHL03",72,0)
 . ;
"RTN","RORHL03",73,0)
 . I RORXII="R" D                ; Outpatient Pharmacy
"RTN","RORHL03",74,0)
 . . D REFILL
"RTN","RORHL03",75,0)
 . . ;--- Check if the original prescription or one of
"RTN","RORHL03",76,0)
 . . ;--- the refills is within date range
"RTN","RORHL03",77,0)
 . . S RORINC=0
"RTN","RORHL03",78,0)
 . . F RORINDEX="REF","PAR" D
"RTN","RORHL03",79,0)
 . . . S II=""
"RTN","RORHL03",80,0)
 . . . F  S II=$O(RORRXE(RORINDEX,II))  Q:II=""  D
"RTN","RORHL03",81,0)
 . . . . S TMP=$P($G(RORRXE(RORINDEX,II,0)),U)
"RTN","RORHL03",82,0)
 . . . . I TMP'<RORSTDT,TMP<RORENDT  S RORINC=1  Q
"RTN","RORHL03",83,0)
 . . . . K RORRXE(RORINDEX,II,0)
"RTN","RORHL03",84,0)
 . . Q:'RORINC
"RTN","RORHL03",85,0)
 . . ;---
"RTN","RORHL03",86,0)
 . . S IEN=+$P(RORORD,";")
"RTN","RORHL03",87,0)
 . . S TMP=$$ORC(IEN,.RORRXE)
"RTN","RORHL03",88,0)
 . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL03",89,0)
 . . S TMP=$$RXE^RORHL031(IEN,.RORRXE)
"RTN","RORHL03",90,0)
 . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL03",91,0)
 . . ;
"RTN","RORHL03",92,0)
 . I RORXII="U" D                        ; Unit Dose Inpatient Pharmacy
"RTN","RORHL03",93,0)
 . . S IENS=+$P(RORORD,";")_","_RORDFN_","
"RTN","RORHL03",94,0)
 . . S TMP=$$ORC^RORHL07(IENS,.RORRXE)
"RTN","RORHL03",95,0)
 . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL03",96,0)
 . . S TMP=$$RXE^RORHL07(IENS,.RORRXE)
"RTN","RORHL03",97,0)
 . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL03",98,0)
 . . ;
"RTN","RORHL03",99,0)
 . I RORXII="V" D                       ; IV Inpatient Pharmacy
"RTN","RORHL03",100,0)
 . . S IENS=+$P(RORORD,";")_","_RORDFN_","
"RTN","RORHL03",101,0)
 . . S TMP=$$ORC^RORHL071(IENS,.RORRXE)
"RTN","RORHL03",102,0)
 . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL03",103,0)
 . . S TMP=$$RXE^RORHL071(IENS,.RORRXE)
"RTN","RORHL03",104,0)
 . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL03",105,0)
 ;
"RTN","RORHL03",106,0)
 K ^TMP($J,"ROR-PS")
"RTN","RORHL03",107,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL03",108,0)
 ;
"RTN","RORHL03",109,0)
 ;***** OUTPATIENT PHARMACY ORC SEGMENT BUILDER
"RTN","RORHL03",110,0)
 ;
"RTN","RORHL03",111,0)
 ; RORIEN        IEN of Record in PrescPN. File #52
"RTN","RORHL03",112,0)
 ;
"RTN","RORHL03",113,0)
 ; .RORORC       Array with info (from OEL^PSOORRL)
"RTN","RORHL03",114,0)
 ;
"RTN","RORHL03",115,0)
 ; Return Values:
"RTN","RORHL03",116,0)
 ;       <0  Error Code
"RTN","RORHL03",117,0)
 ;        0  Ok
"RTN","RORHL03",118,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL03",119,0)
 ;
"RTN","RORHL03",120,0)
ORC(RORIEN,RORORC) ;
"RTN","RORHL03",121,0)
 N BUF,CS,ERRCNT,IEN,IENS59,RC,RORMSG,ROROUT,RORSEG,TMP
"RTN","RORHL03",122,0)
 S (ERRCNT,RC)=0
"RTN","RORHL03",123,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL03",124,0)
 S CS=$E(HLECH,1)
"RTN","RORHL03",125,0)
 ;
"RTN","RORHL03",126,0)
 ;--- Initialize the segment
"RTN","RORHL03",127,0)
 S RORSEG="ORC"
"RTN","RORHL03",128,0)
 ;
"RTN","RORHL03",129,0)
 ;--- ORC-1 - Order Control 
"RTN","RORHL03",130,0)
 S $P(RORSEG,HLFS,2)="NW"
"RTN","RORHL03",131,0)
 ;
"RTN","RORHL03",132,0)
 ;--- ORC-2 - Placer Order #
"RTN","RORHL03",133,0)
 S $P(RORSEG,HLFS,3)=+RORIEN_CS_"OP"
"RTN","RORHL03",134,0)
 ;
"RTN","RORHL03",135,0)
 ;--- ORC-9 - Release Date/Time
"RTN","RORHL03",136,0)
 S TMP=$P($G(RORORC("RXN",0)),U,7)
"RTN","RORHL03",137,0)
 S $P(RORSEG,HLFS,10)=$$FM2HL^RORHL7(TMP)
"RTN","RORHL03",138,0)
 ;
"RTN","RORHL03",139,0)
 ;--- ORC-12 - Provider
"RTN","RORHL03",140,0)
 S BUF=+$P($G(RORORC("P",0)),U)
"RTN","RORHL03",141,0)
 I BUF>0  D
"RTN","RORHL03",142,0)
 . S TMP=$$GET1^DIQ(200,+BUF_",",53.5,"I",,"RORMSG")
"RTN","RORHL03",143,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL03",144,0)
 . . D DBS^RORERR("RORMSG",-99,,,200,+BUF_",")
"RTN","RORHL03",145,0)
 . S:TMP>0 $P(BUF,CS,5)=TMP
"RTN","RORHL03",146,0)
 . S $P(RORSEG,HLFS,13)=BUF
"RTN","RORHL03",147,0)
 ;
"RTN","RORHL03",148,0)
 ;--- ORC-15 - Order Date/Time
"RTN","RORHL03",149,0)
 S TMP=$$FMTHL7^XLFDT($P($G(RORORC(0)),U,5))
"RTN","RORHL03",150,0)
 Q:TMP'>0 $$ERROR^RORERR(-100,,,,"No order date","OEL^PSOORRL")
"RTN","RORHL03",151,0)
 S $P(RORSEG,HLFS,16)=TMP
"RTN","RORHL03",152,0)
 ;
"RTN","RORHL03",153,0)
 ;--- ORC-16 - Control Code Reason
"RTN","RORHL03",154,0)
 S $P(RORSEG,HLFS,17)=CS_CS_CS_CS_"NEW"
"RTN","RORHL03",155,0)
 ;
"RTN","RORHL03",156,0)
 ;--- ORC-17 - Division
"RTN","RORHL03",157,0)
 S $P(RORSEG,HLFS,18)=$$SITE^RORUTL03(CS)
"RTN","RORHL03",158,0)
 S IENS59=+$$GET1^DIQ(52,+RORIEN,20,"I",,"RORMSG")_","
"RTN","RORHL03",159,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL03",160,0)
 . D DBS^RORERR("RORMSG",-99,,,52,+RORIEN)
"RTN","RORHL03",161,0)
 I IENS59>0  D
"RTN","RORHL03",162,0)
 . D GETS^DIQ(59,IENS59,"100","IE","ROROUT","RORMSG")
"RTN","RORHL03",163,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL03",164,0)
 . . D DBS^RORERR("RORMSG",-99,,,59,IENS59)
"RTN","RORHL03",165,0)
 . S IEN=+$G(ROROUT(59,IENS59,100,"I"))
"RTN","RORHL03",166,0)
 . Q:IEN'>0
"RTN","RORHL03",167,0)
 . ;---
"RTN","RORHL03",168,0)
 . S BUF=$$GET1^DIQ(4,IEN_",",99,"I",,"RORMSG")
"RTN","RORHL03",169,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL03",170,0)
 . . D DBS^RORERR("RORMSG",-99,,,4,IEN_",")
"RTN","RORHL03",171,0)
 . Q:BUF=""
"RTN","RORHL03",172,0)
 . S $P(BUF,CS,2)=$$ESCAPE^RORHL7($G(ROROUT(59,IENS59,100,"E")))
"RTN","RORHL03",173,0)
 . S $P(BUF,CS,3)="99VA4"
"RTN","RORHL03",174,0)
 . S $P(RORSEG,HLFS,18)=BUF
"RTN","RORHL03",175,0)
 ;
"RTN","RORHL03",176,0)
 ;--- Store the segment
"RTN","RORHL03",177,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL03",178,0)
 Q ERRCNT
"RTN","RORHL03",179,0)
 ;
"RTN","RORHL03",180,0)
 ;***** MAKES ORIGINAL FILL LIKE REFILLS TO REUSE CODE
"RTN","RORHL03",181,0)
REFILL ;
"RTN","RORHL03",182,0)
 S RORRXE("REF",0,0)=""
"RTN","RORHL03",183,0)
 S $P(RORRXE("REF",0,0),U,1)=$P(RORRXE("RXN",0),U,6)
"RTN","RORHL03",184,0)
 S $P(RORRXE("REF",0,0),U,2)=$P(RORRXE(0),U,7)
"RTN","RORHL03",185,0)
 S $P(RORRXE("REF",0,0),U,3)=$P(RORRXE(0),U,8)
"RTN","RORHL03",186,0)
 S $P(RORRXE("REF",0,0),U,4)=$P(RORRXE("RXN",0),U,7)
"RTN","RORHL03",187,0)
 S $P(RORRXE("REF",0,0),U,5)=$P(RORRXE("RXN",0),U,3)
"RTN","RORHL03",188,0)
 Q
"RTN","RORHL031")
0^67^B40976171
"RTN","RORHL031",1,0)
RORHL031 ;HOIFO/BH - HL7 PHARMACY: UTILITIES ; 10/2/03 1:45pm
"RTN","RORHL031",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL031",3,0)
 ;
"RTN","RORHL031",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL031",5,0)
 ;
"RTN","RORHL031",6,0)
 ; See RORHL03 for RORHL03* IA's.
"RTN","RORHL031",7,0)
 ;
"RTN","RORHL031",8,0)
 Q
"RTN","RORHL031",9,0)
 ;
"RTN","RORHL031",10,0)
 ;***** OUTPATIENT PHARMACY RXE SEGMENT BUILDER
"RTN","RORHL031",11,0)
 ;
"RTN","RORHL031",12,0)
 ; RORIEN        IEN of Record in PrescPN. File #52
"RTN","RORHL031",13,0)
 ;
"RTN","RORHL031",14,0)
 ; .RORRXE       Array with info (from OEL^PSOORRL)
"RTN","RORHL031",15,0)
 ;
"RTN","RORHL031",16,0)
 ; Return Values:
"RTN","RORHL031",17,0)
 ;       <0  Error Code
"RTN","RORHL031",18,0)
 ;        0  Ok
"RTN","RORHL031",19,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL031",20,0)
 ;
"RTN","RORHL031",21,0)
RXE(RORIEN,RORRXE) ;
"RTN","RORHL031",22,0)
 N BUF,CS,ERRCNT,IDGN,II,INDF,J,L,RC,RORCMOP,RORMSG,ROROUT,RORTEST,RORDATA,RORMREF,RORCLIN,RORPRICE,RORSEG,RORSTOP,RORUIN,RORUOUT,RORLST,RORSTAT,RORISIG,RORRELDT,TMP
"RTN","RORHL031",23,0)
 S (ERRCNT,RC)=0
"RTN","RORHL031",24,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL031",25,0)
 S CS=$E(HLECH,1)
"RTN","RORHL031",26,0)
 ;
"RTN","RORHL031",27,0)
 Q:$P($G(RORRXE(0)),U)="" 0
"RTN","RORHL031",28,0)
 ;
"RTN","RORHL031",29,0)
 K ^TMP("PSOR",$J)
"RTN","RORHL031",30,0)
 D EN^PSOORDER(,RORIEN)
"RTN","RORHL031",31,0)
 ;
"RTN","RORHL031",32,0)
 S BUF=$G(^TMP("PSOR",$J,RORIEN,0))
"RTN","RORHL031",33,0)
 S RORMREF=$P(BUF,U,8)            ; # of refills
"RTN","RORHL031",34,0)
 S RORPRICE=$P(BUF,U,10)          ; unit price of drugs
"RTN","RORHL031",35,0)
 ;
"RTN","RORHL031",36,0)
 S BUF=$G(^TMP("PSOR",$J,RORIEN,1))
"RTN","RORHL031",37,0)
 S RORSTAT=$P($P(BUF,U,5),";",1)  ; patient status (internal)
"RTN","RORHL031",38,0)
 S RORSTDE=$P($P(BUF,U,5),";",2)  ; patient status
"RTN","RORHL031",39,0)
 S RORCLIN=+$P(BUF,U,4)           ; clinic
"RTN","RORHL031",40,0)
 ;
"RTN","RORHL031",41,0)
 S (J,RORISIG)="",L=245
"RTN","RORHL031",42,0)
 F  S J=$O(^TMP("PSOR",$J,RORIEN,"SIG1",J))  Q:J=""  D  Q:L'>0
"RTN","RORHL031",43,0)
 . S BUF=$G(^TMP("PSOR",$J,RORIEN,"SIG1",J,0))
"RTN","RORHL031",44,0)
 . S RORISIG=RORISIG_" "_$E(BUF,1,L)
"RTN","RORHL031",45,0)
 . S L=L-$L(BUF)-1  S:L<-1 RORISIG=RORISIG_"..."
"RTN","RORHL031",46,0)
 S RORISIG=$$TRIM^XLFSTR(RORISIG)
"RTN","RORHL031",47,0)
 ;
"RTN","RORHL031",48,0)
 ;--- Get Stop code
"RTN","RORHL031",49,0)
 I RORCLIN>0  D
"RTN","RORHL031",50,0)
 . S RORSTOP=$$GET1^DIQ(44,RORCLIN_",",8,"I",,"RORMSG")
"RTN","RORHL031",51,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL031",52,0)
 . . D DBS^RORERR("RORMSG",-99,,,44,RORCLIN_",")
"RTN","RORHL031",53,0)
 E  S RORSTOP=""
"RTN","RORHL031",54,0)
 ;
"RTN","RORHL031",55,0)
 ;--- Get last dispensed dates
"RTN","RORHL031",56,0)
 D LIST^DIC(52.1,","_RORIEN_",","@;10.1I",,,,,,,,"RORLST","RORMSG")
"RTN","RORHL031",57,0)
 I $G(DIERR)  D  Q RC
"RTN","RORHL031",58,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,52.1,","_RORIEN_",")
"RTN","RORHL031",59,0)
 S J=0  K RORLST("AIEN")
"RTN","RORHL031",60,0)
 F  S J=$O(RORLST("DILIST",2,J))  Q:J=""  D
"RTN","RORHL031",61,0)
 . S TMP=+RORLST("DILIST",2,J)
"RTN","RORHL031",62,0)
 . S:TMP RORLST("AIEN",TMP,J)=""
"RTN","RORHL031",63,0)
 ;
"RTN","RORHL031",64,0)
 ;--- Load the CMOP list
"RTN","RORHL031",65,0)
 D LIST^DIC(52.01,","_RORIEN_",","@;2;3","I",,,,,,,"RORCMOP","RORMSG")
"RTN","RORHL031",66,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL031",67,0)
 . D DBS^RORERR("RORMSG",-99,,,52.01,","_RORIEN_",")
"RTN","RORHL031",68,0)
 S J=0  K RORCMOP("A2")
"RTN","RORHL031",69,0)
 F  S J=$O(RORCMOP("DILIST","ID",J))  Q:J=""  D
"RTN","RORHL031",70,0)
 . Q:$G(RORCMOP("DILIST","ID",J,3))=3
"RTN","RORHL031",71,0)
 . S TMP=$G(RORCMOP("DILIST","ID",J,2))
"RTN","RORHL031",72,0)
 . S:TMP'="" RORCMOP("A2",TMP,J)=""
"RTN","RORHL031",73,0)
 ;
"RTN","RORHL031",74,0)
 F RORINDEX="REF","PAR" D
"RTN","RORHL031",75,0)
 . S II=""
"RTN","RORHL031",76,0)
 . F  S II=$O(RORRXE(RORINDEX,II))  Q:II=""  D  Q:RC<0
"RTN","RORHL031",77,0)
 . . S RORTEST=$G(RORRXE(RORINDEX,II,0))  Q:RORTEST=""
"RTN","RORHL031",78,0)
 . . ;
"RTN","RORHL031",79,0)
 . . ;--- Initialize the segment
"RTN","RORHL031",80,0)
 . . S RORSEG="RXE"
"RTN","RORHL031",81,0)
 . . ;
"RTN","RORHL031",82,0)
 . . ;--- RXE-1 - Quantity/Timing
"RTN","RORHL031",83,0)
 . . S $P(RORSEG,HLFS,2)=""""""
"RTN","RORHL031",84,0)
 . . ;
"RTN","RORHL031",85,0)
 . . ;--- RXE-2 - Give Code
"RTN","RORHL031",86,0)
 . . S IDGN=+$P($G(RORRXE("DD",1,0)),U,3)  ; File #50 IEN
"RTN","RORHL031",87,0)
 . . I IDGN'>0  S IDGN=+$P($G(RORRXE("DD",1,0)),U)  Q:IDGN'>0
"RTN","RORHL031",88,0)
 . . S BUF="",TMP=$$RXE2(IDGN,CS,.BUF)
"RTN","RORHL031",89,0)
 . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL031",90,0)
 . . Q:BUF=""
"RTN","RORHL031",91,0)
 . . S $P(RORSEG,HLFS,3)=BUF
"RTN","RORHL031",92,0)
 . . ;
"RTN","RORHL031",93,0)
 . . ;--- RXE-3 - Give Amount (Min)
"RTN","RORHL031",94,0)
 . . S $P(RORSEG,HLFS,4)=""""""
"RTN","RORHL031",95,0)
 . . ;
"RTN","RORHL031",96,0)
 . . ;--- RXE-4 - Max # of re-fills
"RTN","RORHL031",97,0)
 . . S $P(RORSEG,HLFS,5)=RORMREF
"RTN","RORHL031",98,0)
 . . ;
"RTN","RORHL031",99,0)
 . . ;--- RXE-5 - Give Units
"RTN","RORHL031",100,0)
 . . S INDF=+$$GET1^DIQ(50,IDGN,22,"I",,"RORMSG")    ; File #50.68 IEN
"RTN","RORHL031",101,0)
 . . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL031",102,0)
 . . . D DBS^RORERR("RORMSG",-99,,,50,IDGN)
"RTN","RORHL031",103,0)
 . . I INDF>0  D
"RTN","RORHL031",104,0)
 . . . S RORUIN=$$PROD0^PSNAPIS(,INDF)
"RTN","RORHL031",105,0)
 . . . S RORUIN=$P(RORUIN,U,4)
"RTN","RORHL031",106,0)
 . . . Q:'RORUIN
"RTN","RORHL031",107,0)
 . . . S RORUOUT=$P($G(^PS(50.607,RORUIN,0)),U)
"RTN","RORHL031",108,0)
 . . . S BUF=""
"RTN","RORHL031",109,0)
 . . . S $P(BUF,CS,4)=RORUIN
"RTN","RORHL031",110,0)
 . . . S $P(BUF,CS,5)=$$ESCAPE^RORHL7(RORUOUT)
"RTN","RORHL031",111,0)
 . . . S $P(BUF,CS,6)="99PSU"
"RTN","RORHL031",112,0)
 . . . S $P(RORSEG,HLFS,6)=BUF
"RTN","RORHL031",113,0)
 . . ;
"RTN","RORHL031",114,0)
 . . ;--- RXE-6
"RTN","RORHL031",115,0)
 . . S RORRELDT=""  K ROROUT
"RTN","RORHL031",116,0)
 . . S TMP=$P($G(RORRXE(RORINDEX,II,0)),U,4)
"RTN","RORHL031",117,0)
 . . S RORRELDT=$$FM2HL^RORHL7(TMP)
"RTN","RORHL031",118,0)
 . . S $P(RORSEG,HLFS,7)=RORRELDT
"RTN","RORHL031",119,0)
 . . ;
"RTN","RORHL031",120,0)
 . . ;--- RXE-7 - SIG1
"RTN","RORHL031",121,0)
 . . S $P(RORSEG,HLFS,8)=CS_$$ESCAPE^RORHL7(RORISIG)
"RTN","RORHL031",122,0)
 . . ;
"RTN","RORHL031",123,0)
 . . ;--- RXE-10 - Dispense amount
"RTN","RORHL031",124,0)
 . . S $P(RORSEG,HLFS,11)=$P($G(RORRXE(RORINDEX,II,0)),U,3)
"RTN","RORHL031",125,0)
 . . ;
"RTN","RORHL031",126,0)
 . . ;--- RXE-15 - Refill Indicator
"RTN","RORHL031",127,0)
 . . S $P(RORSEG,HLFS,16)=$S(RORINDEX="REF":1,RORINDEX="PAR":2)
"RTN","RORHL031",128,0)
 . . ;
"RTN","RORHL031",129,0)
 . . ;--- RXE-17 - Refill #
"RTN","RORHL031",130,0)
 . . S $P(RORSEG,HLFS,18)=II
"RTN","RORHL031",131,0)
 . . ;
"RTN","RORHL031",132,0)
 . . ;--- RXE-18 - Fill Date/Time
"RTN","RORHL031",133,0)
 . . S TMP=$P($G(RORRXE(RORINDEX,II,0)),U)
"RTN","RORHL031",134,0)
 . . S $P(RORSEG,HLFS,19)=$$FM2HL^RORHL7(TMP)
"RTN","RORHL031",135,0)
 . . ;
"RTN","RORHL031",136,0)
 . . ;--- RXE-19 - Daily Dose
"RTN","RORHL031",137,0)
 . . S $P(RORSEG,HLFS,20)=$P($G(RORRXE(RORINDEX,II,0)),U,2)
"RTN","RORHL031",138,0)
 . . ;
"RTN","RORHL031",139,0)
 . . ;--- RXE-20 - CMOP
"RTN","RORHL031",140,0)
 . . S $P(RORSEG,HLFS,21)=$S($D(RORCMOP("A2",II)):"Y",1:"N")
"RTN","RORHL031",141,0)
 . . ;
"RTN","RORHL031",142,0)
 . . ;--- RXE-21 - Clinic Stop
"RTN","RORHL031",143,0)
 . . S $P(RORSEG,HLFS,22)=RORSTOP
"RTN","RORHL031",144,0)
 . . ;
"RTN","RORHL031",145,0)
 . . ;--- RXE-22 - Dispense Date
"RTN","RORHL031",146,0)
 . . I 'II  D
"RTN","RORHL031",147,0)
 . . . S TMP=$P($G(RORRXE(0)),U,5)
"RTN","RORHL031",148,0)
 . . . S $P(RORSEG,HLFS,23)=$$FM2HL^RORHL7(TMP)
"RTN","RORHL031",149,0)
 . . E  D
"RTN","RORHL031",150,0)
 . . . S J=$O(RORLST("AIEN",II,""))  Q:J'>0
"RTN","RORHL031",151,0)
 . . . S TMP=$G(RORLST("DILIST","ID",J,10.1))
"RTN","RORHL031",152,0)
 . . . S $P(RORSEG,HLFS,23)=$$FM2HL^RORHL7(TMP)
"RTN","RORHL031",153,0)
 . . ;
"RTN","RORHL031",154,0)
 . . ;--- RXE-23 - Unit Cost
"RTN","RORHL031",155,0)
 . . S $P(RORSEG,HLFS,24)=RORPRICE
"RTN","RORHL031",156,0)
 . . ;
"RTN","RORHL031",157,0)
 . . ;--- RXE-27 - Patient Status
"RTN","RORHL031",158,0)
 . . S $P(RORSEG,HLFS,28)=RORSTAT_CS_RORSTDE
"RTN","RORHL031",159,0)
 . . ;
"RTN","RORHL031",160,0)
 . . ;--- RXE-30 Mail/Window
"RTN","RORHL031",161,0)
 . . S TMP=$P($G(RORRXE(RORINDEX,II,0)),U,5)
"RTN","RORHL031",162,0)
 . . S $P(RORSEG,HLFS,31)=$S(TMP="M":"AD",TMP="W":"TR",1:"")
"RTN","RORHL031",163,0)
 . . ;
"RTN","RORHL031",164,0)
 . . ;--- Store the segment
"RTN","RORHL031",165,0)
 . . D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL031",166,0)
 ;
"RTN","RORHL031",167,0)
 K ^TMP("PSOR",$J)
"RTN","RORHL031",168,0)
 Q ERRCNT
"RTN","RORHL031",169,0)
 ;
"RTN","RORHL031",170,0)
 ;***** CONSTRUCTS THE RXE-2 FIELD (GIVE CODE)
"RTN","RORHL031",171,0)
 ;
"RTN","RORHL031",172,0)
 ; IDGN          IEN of Drug File #50
"RTN","RORHL031",173,0)
 ;
"RTN","RORHL031",174,0)
 ; [CS]          Component Separator (defaults to "^")
"RTN","RORHL031",175,0)
 ;
"RTN","RORHL031",176,0)
 ; .RXE2         Reference to a local variable where the value
"RTN","RORHL031",177,0)
 ;               of the  RXE-2 field is returned
"RTN","RORHL031",178,0)
 ;
"RTN","RORHL031",179,0)
 ; Return Values:
"RTN","RORHL031",180,0)
 ;       <0  Error Code
"RTN","RORHL031",181,0)
 ;        0  Ok
"RTN","RORHL031",182,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL031",183,0)
 ;
"RTN","RORHL031",184,0)
RXE2(IDGN,CS,RXE2) ;
"RTN","RORHL031",185,0)
 N ERRCNT,RC,RORMSG,ROROUT,TMP,TMP1
"RTN","RORHL031",186,0)
 S (ERRCNT,RC)=0,RXE2=""
"RTN","RORHL031",187,0)
 ;
"RTN","RORHL031",188,0)
 S:$G(CS)="" CS="^"
"RTN","RORHL031",189,0)
 S IDGN=+$G(IDGN)_","                                 ; File 50 IEN
"RTN","RORHL031",190,0)
 ;
"RTN","RORHL031",191,0)
 D GETS^DIQ(50,IDGN,".01;2;20;22;27;31","EI","ROROUT","RORMSG")
"RTN","RORHL031",192,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL031",193,0)
 . D DBS^RORERR("RORMSG",-9,,,50,IDGN)
"RTN","RORHL031",194,0)
 ;
"RTN","RORHL031",195,0)
 S $P(RXE2,CS,1)=$G(ROROUT(50,IDGN,31,"E"))      ; NDC
"RTN","RORHL031",196,0)
 ;--- VA Product Name
"RTN","RORHL031",197,0)
 S TMP1=$E($G(ROROUT(50,IDGN,22,"E")),1,64)
"RTN","RORHL031",198,0)
 S $P(RXE2,CS,2)=$$ESCAPE^RORHL7(TMP1)
"RTN","RORHL031",199,0)
 S $P(RXE2,CS,3)="PSNDF"
"RTN","RORHL031",200,0)
 ;
"RTN","RORHL031",201,0)
 S TMP=""
"RTN","RORHL031",202,0)
 S $P(TMP,"-",1)=$G(ROROUT(50,IDGN,20,"I"))      ; VA Drug Code
"RTN","RORHL031",203,0)
 S $P(TMP,"-",2)=$G(ROROUT(50,IDGN,2,"E"))       ; VA Drug Class
"RTN","RORHL031",204,0)
 S:TMP'="-" $P(RXE2,CS,4)=TMP
"RTN","RORHL031",205,0)
 ;--- Drug Name
"RTN","RORHL031",206,0)
 S $P(RXE2,CS,5)=$$ESCAPE^RORHL7($G(ROROUT(50,IDGN,.01,"E")))
"RTN","RORHL031",207,0)
 S $P(RXE2,CS,6)="99PSD"
"RTN","RORHL031",208,0)
 ;
"RTN","RORHL031",209,0)
 S:($P(RXE2,CS,1,2)="^")&($P(RXE2,CS,4,5)="^") RXE2=""
"RTN","RORHL031",210,0)
 Q ERRCNT
"RTN","RORHL04")
0^38^B30377980
"RTN","RORHL04",1,0)
RORHL04 ;HOIFO/CRT,SG - HL7 RADIOLOGY: OBR,OBX ; 10/1/03 2:23pm
"RTN","RORHL04",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3,4,5**;May 14, 2002
"RTN","RORHL04",3,0)
 ;
"RTN","RORHL04",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL04",5,0)
 ;
"RTN","RORHL04",6,0)
 ; #65           Read access to file #70 (controlled)
"RTN","RORHL04",7,0)
 ; #65           Read access to file #70 (controlled)
"RTN","RORHL04",8,0)
 ; #118-B        Read access to file #71 (controlled)
"RTN","RORHL04",9,0)
 ; #118-D        Read access to file #72 (controlled)
"RTN","RORHL04",10,0)
 ; #1995         $$CPT^ICPTCOD (supported)
"RTN","RORHL04",11,0)
 ; #2043         EN1^RAO7PC1 (supported)
"RTN","RORHL04",12,0)
 ; #10060        Read access to the file #200 (supported)
"RTN","RORHL04",13,0)
 ; #10090        Read access to the file #4 (supported)
"RTN","RORHL04",14,0)
 ;
"RTN","RORHL04",15,0)
 ; #15-C         Read access to file #74 (Private)
"RTN","RORHL04",16,0)
 ;
"RTN","RORHL04",17,0)
 Q
"RTN","RORHL04",18,0)
 ;
"RTN","RORHL04",19,0)
 ;***** SEARCHES RADIOLOGY FOR DATA
"RTN","RORHL04",20,0)
 ;
"RTN","RORHL04",21,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL04",22,0)
 ;
"RTN","RORHL04",23,0)
 ; RORSTDT       Start date (FileMan)
"RTN","RORHL04",24,0)
 ; RORENDT       End date   (FileMan)
"RTN","RORHL04",25,0)
 ;
"RTN","RORHL04",26,0)
 ; Return Values:
"RTN","RORHL04",27,0)
 ;       <0  Error code
"RTN","RORHL04",28,0)
 ;        0  Ok
"RTN","RORHL04",29,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL04",30,0)
 ;
"RTN","RORHL04",31,0)
 ; The ^TMP($J,"RAE1") global node is used by the function.
"RTN","RORHL04",32,0)
 ;
"RTN","RORHL04",33,0)
EN1(RORDFN,RORSTDT,RORENDT) ;
"RTN","RORHL04",34,0)
 N CNI,DTI,ERRCNT,EXAMID,IENS,IENS74,RACN0,RC,STR1,TMP
"RTN","RORHL04",35,0)
 S (ERRCNT,RC)=0
"RTN","RORHL04",36,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL04",37,0)
 ;
"RTN","RORHL04",38,0)
 K ^TMP($J,"RAE1")
"RTN","RORHL04",39,0)
 D EN1^RAO7PC1(RORDFN,RORSTDT,RORENDT,999999999)
"RTN","RORHL04",40,0)
 ;
"RTN","RORHL04",41,0)
 S EXAMID=""
"RTN","RORHL04",42,0)
 F  S EXAMID=$O(^TMP($J,"RAE1",RORDFN,EXAMID))  Q:EXAMID=""  D
"RTN","RORHL04",43,0)
 . S DTI=$P(EXAMID,"-"),CNI=$P(EXAMID,"-",2)
"RTN","RORHL04",44,0)
 . S IENS=CNI_","_DTI_","_RORDFN_","
"RTN","RORHL04",45,0)
 . S STR=^TMP($J,"RAE1",RORDFN,EXAMID)
"RTN","RORHL04",46,0)
 . S RACN0=$P(STR,"^",2),IENS74=$P(STR,"^",5)
"RTN","RORHL04",47,0)
 . S TMP=$$OBR(IENS,RACN0)
"RTN","RORHL04",48,0)
 . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL04",49,0)
 . S TMP=$$OBX(IENS,IENS74)
"RTN","RORHL04",50,0)
 . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL04",51,0)
 ;
"RTN","RORHL04",52,0)
 K ^TMP($J,"RAE1")
"RTN","RORHL04",53,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL04",54,0)
 ;
"RTN","RORHL04",55,0)
 ;***** GENERATES THE RADIOLOGY OBR SEGMENT
"RTN","RORHL04",56,0)
 ;
"RTN","RORHL04",57,0)
 ; RORIENS       IENS of the radiology record in the file #70.03
"RTN","RORHL04",58,0)
 ;
"RTN","RORHL04",59,0)
 ; Return Values:
"RTN","RORHL04",60,0)
 ;       <0  Error code
"RTN","RORHL04",61,0)
 ;        0  Ok
"RTN","RORHL04",62,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL04",63,0)
 ;
"RTN","RORHL04",64,0)
OBR(RORIENS,RACN0) ;
"RTN","RORHL04",65,0)
 N BUF,CS,ERRCNT,IENS,IENS7002,RADTE,RC,RORMSG,ROROUT,RORSEG,TMP
"RTN","RORHL04",66,0)
 S (ERRCNT,RC)=0
"RTN","RORHL04",67,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL04",68,0)
 S CS=$E(HLECH,1)
"RTN","RORHL04",69,0)
 ;--- Check the parameters
"RTN","RORHL04",70,0)
 S:$E(RORIENS,$L(RORIENS))'="," RORIENS=RORIENS_","
"RTN","RORHL04",71,0)
 ;
"RTN","RORHL04",72,0)
 D GETS^DIQ(70.03,RORIENS,"2;14","IE","ROROUT","RORMSG")
"RTN","RORHL04",73,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,70.03,RORIENS)
"RTN","RORHL04",74,0)
 S IENS7002=$P(RORIENS,",",2,3)_","
"RTN","RORHL04",75,0)
 D GETS^DIQ(70.02,IENS7002,".01;3","IE","ROROUT","RORMSG")
"RTN","RORHL04",76,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,70.02,IENS7002)
"RTN","RORHL04",77,0)
 ;
"RTN","RORHL04",78,0)
 ;--- Initialize the segment
"RTN","RORHL04",79,0)
 S RORSEG="OBR"
"RTN","RORHL04",80,0)
 ;
"RTN","RORHL04",81,0)
 ;--- OBR-3 - Unique Accession #
"RTN","RORHL04",82,0)
 S BUF=$P(RORIENS,",",2)_"-"_$P(RORIENS,",")
"RTN","RORHL04",83,0)
 S RADTE=$G(ROROUT(70.02,IENS7002,.01,"I"))\1
"RTN","RORHL04",84,0)
 S $P(BUF,CS,2)=$E(RADTE,4,7)_$E(RADTE,2,3)_"-"_+RACN0
"RTN","RORHL04",85,0)
 S $P(BUF,CS,3)="L"
"RTN","RORHL04",86,0)
 S $P(RORSEG,HLFS,4)=BUF
"RTN","RORHL04",87,0)
 ;
"RTN","RORHL04",88,0)
 ;--- OBR-4 - Procedure & CPT Code
"RTN","RORHL04",89,0)
 S IENS=+$G(ROROUT(70.03,RORIENS,2,"I"))_","
"RTN","RORHL04",90,0)
 Q:IENS'>0 $$ERROR^RORERR(-95,,,,70.03,RORIENS,2)
"RTN","RORHL04",91,0)
 S TMP=+$$GET1^DIQ(71,IENS,9,"I",,"RORMSG")
"RTN","RORHL04",92,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,71,IENS)
"RTN","RORHL04",93,0)
 Q:TMP'>0 $$ERROR^RORERR(-95,,,,71,IENS,9)
"RTN","RORHL04",94,0)
 ;---
"RTN","RORHL04",95,0)
 S TMP=$$CPT^ICPTCOD(TMP)
"RTN","RORHL04",96,0)
 Q:TMP<0 $$ERROR^RORERR(-56,,$P(TMP,U,2),,+TMP,"$$CPT^ICPTCOD")
"RTN","RORHL04",97,0)
 S BUF=$P(TMP,U,2)_CS_$$ESCAPE^RORHL7($P(TMP,U,3))_CS_"C4"
"RTN","RORHL04",98,0)
 ;---
"RTN","RORHL04",99,0)
 S $P(BUF,CS,4)=$G(ROROUT(70.03,RORIENS,2,"I"))
"RTN","RORHL04",100,0)
 S $P(BUF,CS,5)=$$ESCAPE^RORHL7($G(ROROUT(70.03,RORIENS,2,"E")))
"RTN","RORHL04",101,0)
 S $P(BUF,CS,6)="99RAP"
"RTN","RORHL04",102,0)
 S $P(RORSEG,HLFS,5)=BUF
"RTN","RORHL04",103,0)
 ;
"RTN","RORHL04",104,0)
 ;--- OBR-7 - Exam Date/Time
"RTN","RORHL04",105,0)
 S TMP=$$FMTHL7^XLFDT($G(ROROUT(70.02,IENS7002,.01,"I")))
"RTN","RORHL04",106,0)
 Q:TMP'>0 $$ERROR^RORERR(-95,,,,70.02,IENS7002,.01)
"RTN","RORHL04",107,0)
 S $P(RORSEG,HLFS,8)=TMP
"RTN","RORHL04",108,0)
 ;
"RTN","RORHL04",109,0)
 ;--- OBR-16 - Requesting Physician
"RTN","RORHL04",110,0)
 S BUF=+$G(ROROUT(70.03,RORIENS,14,"I"))
"RTN","RORHL04",111,0)
 I BUF>0  D
"RTN","RORHL04",112,0)
 . S $P(BUF,CS,5)=$$GET1^DIQ(200,+BUF_",",53.5,"I",,"RORMSG")
"RTN","RORHL04",113,0)
 . I $G(DIERR)  D DBS^RORERR("RORMSG",-99,,,200,+BUF_",")  Q
"RTN","RORHL04",114,0)
 . S $P(RORSEG,HLFS,17)=BUF
"RTN","RORHL04",115,0)
 ;
"RTN","RORHL04",116,0)
 ;--- OBR-24 - Service Section ID
"RTN","RORHL04",117,0)
 S $P(RORSEG,HLFS,25)="RAD"
"RTN","RORHL04",118,0)
 ;
"RTN","RORHL04",119,0)
 ;--- OBR-44 - Division
"RTN","RORHL04",120,0)
 S $P(RORSEG,HLFS,45)=$$SITE1^RORUTL03(CS)
"RTN","RORHL04",121,0)
 S IENS=+$G(ROROUT(70.02,IENS7002,3,"I"))_","
"RTN","RORHL04",122,0)
 I IENS>0  D
"RTN","RORHL04",123,0)
 . S BUF=$$ESCAPE^RORHL7($G(ROROUT(70.02,IENS7002,3,"E")))
"RTN","RORHL04",124,0)
 . S $P(BUF,CS,2)="99VA4"
"RTN","RORHL04",125,0)
 . S $P(BUF,CS,3)=$$GET1^DIQ(4,IENS,99,"I",,"RORMSG")
"RTN","RORHL04",126,0)
 . I $G(DIERR)  D DBS^RORERR("RORMSG",-99,,,4,IENS)  Q
"RTN","RORHL04",127,0)
 . S:$P(BUF,CS,3)'="" $P(RORSEG,HLFS,45)=BUF
"RTN","RORHL04",128,0)
 ;
"RTN","RORHL04",129,0)
 ;--- Store the segment
"RTN","RORHL04",130,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL04",131,0)
 Q ERRCNT
"RTN","RORHL04",132,0)
 ;
"RTN","RORHL04",133,0)
 ;***** GENERATES THE RADIOLOGY OBX SEGMENT
"RTN","RORHL04",134,0)
 ;
"RTN","RORHL04",135,0)
 ; RORIENS       IENS of the radiology record in the file #70.03
"RTN","RORHL04",136,0)
 ;
"RTN","RORHL04",137,0)
 ; Return Values:
"RTN","RORHL04",138,0)
 ;       <0  Error code
"RTN","RORHL04",139,0)
 ;        0  Ok
"RTN","RORHL04",140,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL04",141,0)
 ;
"RTN","RORHL04",142,0)
OBX(RORIENS,IENS74) ;
"RTN","RORHL04",143,0)
 N ERRCNT,RC,RORMSG,ROROUT,RORSEG,RORTXT,TMP
"RTN","RORHL04",144,0)
 S (ERRCNT,RC)=0
"RTN","RORHL04",145,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL04",146,0)
 S CS=$E(HLECH,1)
"RTN","RORHL04",147,0)
 ;--- Check the parameters
"RTN","RORHL04",148,0)
 S:$E(RORIENS,$L(RORIENS))'="," RORIENS=RORIENS_","
"RTN","RORHL04",149,0)
 ;
"RTN","RORHL04",150,0)
 ;--- Initialize the segment
"RTN","RORHL04",151,0)
 S RORSEG="OBX"
"RTN","RORHL04",152,0)
 ;
"RTN","RORHL04",153,0)
 ; OBX-2
"RTN","RORHL04",154,0)
 S $P(RORSEG,HLFS,3)="FT"
"RTN","RORHL04",155,0)
 ;
"RTN","RORHL04",156,0)
 ; OBX-11
"RTN","RORHL04",157,0)
 S $P(RORSEG,HLFS,12)="F"
"RTN","RORHL04",158,0)
 ;
"RTN","RORHL04",159,0)
 ;-- Get the Report Text
"RTN","RORHL04",160,0)
 S TMP=$$GET1^DIQ(74,IENS74,200,,"RORTXT","RORMSG")
"RTN","RORHL04",161,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL04",162,0)
 . D DBS^RORERR("RORMSG",-99,,,74,IENS74)
"RTN","RORHL04",163,0)
 I $D(RORTXT)>1  D  K RORTXT
"RTN","RORHL04",164,0)
 . D LOOP(.RORTXT,"RT"_CS_"Report Text"_CS_"VA080")
"RTN","RORHL04",165,0)
 ;
"RTN","RORHL04",166,0)
 ;--- Get the Impression Report
"RTN","RORHL04",167,0)
 S TMP=$$GET1^DIQ(74,IENS74,300,,"RORTXT","RORMSG")
"RTN","RORHL04",168,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL04",169,0)
 . D DBS^RORERR("RORMSG",-99,,,74,IENS74)
"RTN","RORHL04",170,0)
 I $D(RORTXT)>1  D  K RORTXT
"RTN","RORHL04",171,0)
 . D LOOP(.RORTXT,"IT"_CS_"Impression Text"_CS_"VA080")
"RTN","RORHL04",172,0)
 ;
"RTN","RORHL04",173,0)
 ;--- Get the Clinical History
"RTN","RORHL04",174,0)
 S TMP=$$GET1^DIQ(70.03,RORIENS,400,,"RORTXT","RORMSG")
"RTN","RORHL04",175,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL04",176,0)
 . D DBS^RORERR("RORMSG",-99,,,70.03,RORIENS)
"RTN","RORHL04",177,0)
 I $D(RORTXT)>1  D  K RORTXT
"RTN","RORHL04",178,0)
 . D LOOP(.RORTXT,"CH"_CS_"Clinical History"_CS_"VA080")
"RTN","RORHL04",179,0)
 ;
"RTN","RORHL04",180,0)
 Q ERRCNT
"RTN","RORHL04",181,0)
 ;
"RTN","RORHL04",182,0)
LOOP(RORAR,RORVAL) ;
"RTN","RORHL04",183,0)
 N RORHLS,RORK1
"RTN","RORHL04",184,0)
 S RORK1=""
"RTN","RORHL04",185,0)
 F  S RORK1=$O(RORAR(RORK1))  Q:RORK1=""  D
"RTN","RORHL04",186,0)
 . S $P(RORSEG,HLFS,2)=""
"RTN","RORHL04",187,0)
 . S $P(RORSEG,HLFS,4)=RORVAL
"RTN","RORHL04",188,0)
 . S $P(RORSEG,HLFS,6)=$$ESCAPE^RORHL7(RORAR(RORK1))
"RTN","RORHL04",189,0)
 . D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL04",190,0)
 Q
"RTN","RORHL05")
0^93^B6723296
"RTN","RORHL05",1,0)
RORHL05 ;HOIFO/CRT - HL7 AUTOPSY: OBR ; 10/1/03 2:29pm
"RTN","RORHL05",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORHL05",3,0)
 ;
"RTN","RORHL05",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL05",5,0)
 ;
"RTN","RORHL05",6,0)
 ; #1995         $$CPT^ICPTCOD (supported)
"RTN","RORHL05",7,0)
 ; #2503         LRDFN^LR7OR1 (controlled)
"RTN","RORHL05",8,0)
 ; #3465         Access to autopsy data (private)
"RTN","RORHL05",9,0)
 ; #10040        Read the INSTITUTION field of file #44 (supported)
"RTN","RORHL05",10,0)
 ; #10090        Read access to the file #4 (supported)
"RTN","RORHL05",11,0)
 ;
"RTN","RORHL05",12,0)
 Q
"RTN","RORHL05",13,0)
 ;
"RTN","RORHL05",14,0)
 ;***** SEARCHES FOR AUTOPSY DATA
"RTN","RORHL05",15,0)
 ;
"RTN","RORHL05",16,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL05",17,0)
 ;
"RTN","RORHL05",18,0)
 ; Return Values:
"RTN","RORHL05",19,0)
 ;       <0  Error code
"RTN","RORHL05",20,0)
 ;        0  Ok
"RTN","RORHL05",21,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL05",22,0)
 ;
"RTN","RORHL05",23,0)
EN1(RORDFN) ;
"RTN","RORHL05",24,0)
 N ADATE,ERRCNT,RC,RORLRDFN,RORMSG
"RTN","RORHL05",25,0)
 S (ERRCNT,RC)=0
"RTN","RORHL05",26,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL05",27,0)
 ;
"RTN","RORHL05",28,0)
 ;--- Check if the autopsy has been performed
"RTN","RORHL05",29,0)
 S RORLRDFN=+$$LRDFN^LR7OR1(RORDFN)  Q:'RORLRDFN 0
"RTN","RORHL05",30,0)
 S ADATE=$$GET1^DIQ(63,RORLRDFN_",",11,"I",,"RORMSG")
"RTN","RORHL05",31,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,RORDFN,63,RORLRDFN_",")
"RTN","RORHL05",32,0)
 ;
"RTN","RORHL05",33,0)
 S:ADATE>0 RC=$$OBR(RORLRDFN)
"RTN","RORHL05",34,0)
 ;
"RTN","RORHL05",35,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL05",36,0)
 ;
"RTN","RORHL05",37,0)
 ;***** AUTOPSY OBR SEGMENT BUILDER
"RTN","RORHL05",38,0)
 ;
"RTN","RORHL05",39,0)
 ; RORLRDFN      IEN of Lab Patient Record in File #63
"RTN","RORHL05",40,0)
 ;
"RTN","RORHL05",41,0)
 ; Return Values:
"RTN","RORHL05",42,0)
 ;       <0  Error code
"RTN","RORHL05",43,0)
 ;        0  Ok
"RTN","RORHL05",44,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL05",45,0)
 ;
"RTN","RORHL05",46,0)
OBR(RORLRDFN) ;
"RTN","RORHL05",47,0)
 N BUF,CS,ERRCNT,IEN,IENS63,RC,RORMSG,ROROUT,RORSEG,TMP
"RTN","RORHL05",48,0)
 S (ERRCNT,RC)=0
"RTN","RORHL05",49,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL05",50,0)
 S CS=$E(HLECH,1)
"RTN","RORHL05",51,0)
 ;
"RTN","RORHL05",52,0)
 S IENS63=+$G(RORLRDFN)_","
"RTN","RORHL05",53,0)
 D GETS^DIQ(63,IENS63,"11;12.1;14;14.1","IE","ROROUT","RORMSG")
"RTN","RORHL05",54,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL05",55,0)
 . D DBS^RORERR("RORMSG",-9,,,63,IENS63)
"RTN","RORHL05",56,0)
 ;
"RTN","RORHL05",57,0)
 ;--- Initialize the segment
"RTN","RORHL05",58,0)
 S RORSEG="OBR"
"RTN","RORHL05",59,0)
 ;
"RTN","RORHL05",60,0)
 ;--- OBR-3 - Order #
"RTN","RORHL05",61,0)
 I $G(ROROUT(63,IENS63,14,"E"))=""  D  Q RC
"RTN","RORHL05",62,0)
 . S RC=$$ERROR^RORERR(-95,,,,63,IENS63,14)
"RTN","RORHL05",63,0)
 S $P(RORSEG,HLFS,4)=ROROUT(63,IENS63,14,"E")
"RTN","RORHL05",64,0)
 ;
"RTN","RORHL05",65,0)
 ;--- OBR-4 - CPT Code
"RTN","RORHL05",66,0)
 S BUF=88099,TMP=$$CPT^ICPTCOD(BUF)
"RTN","RORHL05",67,0)
 I TMP<0  D  S ERRCNT=ERRCNT+1
"RTN","RORHL05",68,0)
 . D ERROR^RORERR(-57,,$P(TMP,U,2),,+TMP,"$$CPT^ICPTCOD")
"RTN","RORHL05",69,0)
 S $P(BUF,CS,2)=$$ESCAPE^RORHL7($P(TMP,U,3))
"RTN","RORHL05",70,0)
 S $P(BUF,CS,3)="C4"
"RTN","RORHL05",71,0)
 S $P(RORSEG,HLFS,5)=BUF
"RTN","RORHL05",72,0)
 ;
"RTN","RORHL05",73,0)
 ;--- OBR-7 - Autopsy Date/Time
"RTN","RORHL05",74,0)
 S TMP=$$FMTHL7^XLFDT($G(ROROUT(63,IENS63,11,"I")))
"RTN","RORHL05",75,0)
 Q:TMP'>0 $$ERROR^RORERR(-95,,,,63,IENS63,11)
"RTN","RORHL05",76,0)
 S $P(RORSEG,HLFS,8)=TMP
"RTN","RORHL05",77,0)
 ;
"RTN","RORHL05",78,0)
 ;--- OBR-16 - Ordering Provider
"RTN","RORHL05",79,0)
 S $P(RORSEG,HLFS,17)=$G(ROROUT(63,IENS63,12.1,"I"))
"RTN","RORHL05",80,0)
 ;
"RTN","RORHL05",81,0)
 ;--- OBR-24 - Diagnostic Service ID
"RTN","RORHL05",82,0)
 S $P(RORSEG,HLFS,25)="SP"
"RTN","RORHL05",83,0)
 ;
"RTN","RORHL05",84,0)
 ;--- OBR-44 - Division
"RTN","RORHL05",85,0)
 S TMP=$G(ROROUT(63,IENS63,14.1,"I"))
"RTN","RORHL05",86,0)
 S IEN=$S(TMP'="":+$O(^SC("B",TMP,0)),1:0)
"RTN","RORHL05",87,0)
 S $P(RORSEG,HLFS,45)=$$DIV44^RORHLUT1(IEN,1,CS)
"RTN","RORHL05",88,0)
 ;
"RTN","RORHL05",89,0)
 ;--- Store the segment
"RTN","RORHL05",90,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL05",91,0)
 Q ERRCNT
"RTN","RORHL06")
0^92^B23712300
"RTN","RORHL06",1,0)
RORHL06 ;HOIFO/BH,CRT - HL7 LIVER BIOPSY: OBR,OBX ; 10/1/03 2:57pm
"RTN","RORHL06",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORHL06",3,0)
 ;
"RTN","RORHL06",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL06",5,0)
 ;
"RTN","RORHL06",6,0)
 ; #1995         $$CPT^ICPTCOD (supported)
"RTN","RORHL06",7,0)
 ; #2503         LRDFN^LR7OR1 (controlled)
"RTN","RORHL06",8,0)
 ; #10035        Read access to the PATIENT file (supported)
"RTN","RORHL06",9,0)
 ;
"RTN","RORHL06",10,0)
 Q
"RTN","RORHL06",11,0)
 ;
"RTN","RORHL06",12,0)
 ;***** SEARCHES FOR LIVER BIOPSY DATA
"RTN","RORHL06",13,0)
 ;
"RTN","RORHL06",14,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL06",15,0)
 ;
"RTN","RORHL06",16,0)
 ; RORSTDT       Start Date (FileMan)
"RTN","RORHL06",17,0)
 ; RORENDT       End Date   (FileMan)
"RTN","RORHL06",18,0)
 ;
"RTN","RORHL06",19,0)
 ; Return Values:
"RTN","RORHL06",20,0)
 ;       <0  Error code
"RTN","RORHL06",21,0)
 ;        0  Ok
"RTN","RORHL06",22,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL06",23,0)
 ;
"RTN","RORHL06",24,0)
 ; The function uses the ^UTILITY($J,"W") global node.
"RTN","RORHL06",25,0)
 ;
"RTN","RORHL06",26,0)
EN1(RORDFN,RORSTDT,RORENDT) ;
"RTN","RORHL06",27,0)
 N ERRCNT,FLDS,IDT,IENS,K5,LRDFN,QUIT,RC,SPECIMEN
"RTN","RORHL06",28,0)
 S (ERRCNT,RC)=0
"RTN","RORHL06",29,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL06",30,0)
 ;
"RTN","RORHL06",31,0)
 ;--- Check if the patient exists
"RTN","RORHL06",32,0)
 S RORDFN=+$G(RORDFN)
"RTN","RORHL06",33,0)
 I '$D(^DPT(RORDFN))  D  Q RC
"RTN","RORHL06",34,0)
 . S RC=$$ERROR^RORERR(-36,,,RORDFN,2)
"RTN","RORHL06",35,0)
 ;
"RTN","RORHL06",36,0)
 S LRDFN=+$$LRDFN^LR7OR1(RORDFN)  Q:'LRDFN 0
"RTN","RORHL06",37,0)
 ;
"RTN","RORHL06",38,0)
 S FLDS="1.1;1.4"
"RTN","RORHL06",39,0)
 S RORENDT=$$INVDATE^RORUTL01(RORENDT)
"RTN","RORHL06",40,0)
 S RORSTDT=$$INVDATE^RORUTL01(RORSTDT)
"RTN","RORHL06",41,0)
 ;
"RTN","RORHL06",42,0)
 S IDT=$O(^LR(LRDFN,"SP",RORSTDT))
"RTN","RORHL06",43,0)
 F  S IDT=$O(^LR(LRDFN,"SP",IDT),-1)  Q:'IDT!(IDT'>RORENDT)  D  Q:RC<0
"RTN","RORHL06",44,0)
 . S K5=0,QUIT=0
"RTN","RORHL06",45,0)
 . F  S K5=$O(^LR(LRDFN,"SP",IDT,.1,K5))  Q:'K5  D  Q:QUIT!(RC<0)
"RTN","RORHL06",46,0)
 . . S IENS=K5_","_IDT_","_LRDFN_","
"RTN","RORHL06",47,0)
 . . S SPECIMEN=$$GET1^DIQ(63.812,IENS,.01,"E",,"RORMSG")
"RTN","RORHL06",48,0)
 . . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL06",49,0)
 . . . D DBS^RORERR("RORMSG",-9,,,63.812,IENS)
"RTN","RORHL06",50,0)
 . . I $$UP^XLFSTR(SPECIMEN)["LIVER"  D
"RTN","RORHL06",51,0)
 . . . S IENS=IDT_","_LRDFN_","
"RTN","RORHL06",52,0)
 . . . S TMP=$$OBR(IENS)
"RTN","RORHL06",53,0)
 . . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL06",54,0)
 . . . S TMP=$$OBX(IENS,FLDS)
"RTN","RORHL06",55,0)
 . . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL06",56,0)
 . . . S QUIT=1
"RTN","RORHL06",57,0)
 ;
"RTN","RORHL06",58,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL06",59,0)
 ;
"RTN","RORHL06",60,0)
 ;***** LIVER BIOPSY OBR SEGMENT BUILDER
"RTN","RORHL06",61,0)
 ;
"RTN","RORHL06",62,0)
 ; RORIENS       IENS of Liver Biopsy Record in File #63.08
"RTN","RORHL06",63,0)
 ;
"RTN","RORHL06",64,0)
 ; Return Values:
"RTN","RORHL06",65,0)
 ;       <0  Error code
"RTN","RORHL06",66,0)
 ;        0  Ok
"RTN","RORHL06",67,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL06",68,0)
 ;
"RTN","RORHL06",69,0)
OBR(RORIENS) ;
"RTN","RORHL06",70,0)
 N BUF,CS,ERRCNT,FLDS,IEN,RC,RORMSG,ROROUT,RORSEG,TMP
"RTN","RORHL06",71,0)
 S (ERRCNT,RC)=0
"RTN","RORHL06",72,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL06",73,0)
 S CS=$E(HLECH,1)
"RTN","RORHL06",74,0)
 ;--- Check the parameters
"RTN","RORHL06",75,0)
 S:$E(RORIENS,$L(RORIENS))'="," RORIENS=RORIENS_","
"RTN","RORHL06",76,0)
 ;
"RTN","RORHL06",77,0)
 ;--- Load the data
"RTN","RORHL06",78,0)
 S FLDS=".01;.06;.07;.08"
"RTN","RORHL06",79,0)
 D GETS^DIQ(63.08,RORIENS,FLDS,"IE","ROROUT","RORMSG")
"RTN","RORHL06",80,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL06",81,0)
 . D DBS^RORERR("RORMSG",-9,,,63.08,RORIENS)
"RTN","RORHL06",82,0)
 ;
"RTN","RORHL06",83,0)
 ;--- Initialize the segment
"RTN","RORHL06",84,0)
 S RORSEG="OBR"
"RTN","RORHL06",85,0)
 ;
"RTN","RORHL06",86,0)
 ;--- OBR-3 - Surgical Path Acc #
"RTN","RORHL06",87,0)
 S $P(RORSEG,HLFS,4)=$G(ROROUT(63.08,RORIENS,.06,"E"))
"RTN","RORHL06",88,0)
 ;
"RTN","RORHL06",89,0)
 ;--- OBR-4 - Liver Biopsy CPT Code
"RTN","RORHL06",90,0)
 S BUF=47000,TMP=$$CPT^ICPTCOD(BUF)
"RTN","RORHL06",91,0)
 I TMP<0  D  S ERRCNT=ERRCNT+1,TMP=""
"RTN","RORHL06",92,0)
 . D ERROR^RORERR(-57,,$P(TMP,U,2),,+TMP,"$$CPT^ICPTCOD")
"RTN","RORHL06",93,0)
 S $P(BUF,CS,2)=$$ESCAPE^RORHL7($P(TMP,U,3))
"RTN","RORHL06",94,0)
 S $P(BUF,CS,3)="C4"
"RTN","RORHL06",95,0)
 S $P(RORSEG,HLFS,5)=BUF
"RTN","RORHL06",96,0)
 ;
"RTN","RORHL06",97,0)
 ;--- OBR-7 - Date/Time Specimen Taken
"RTN","RORHL06",98,0)
 S TMP=$G(ROROUT(63.08,RORIENS,.01,"I"))
"RTN","RORHL06",99,0)
 Q:TMP'>0 $$ERROR^RORERR(-95,,,,63.08,RORIENS,.01)
"RTN","RORHL06",100,0)
 S $P(RORSEG,HLFS,8)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL06",101,0)
 ;
"RTN","RORHL06",102,0)
 ;--- OBR-16 - Surgeon/Physician
"RTN","RORHL06",103,0)
 S $P(RORSEG,HLFS,17)=$G(ROROUT(63.08,RORIENS,.07,"I"))
"RTN","RORHL06",104,0)
 ;
"RTN","RORHL06",105,0)
 ;--- OBR-24 - Service Section ID
"RTN","RORHL06",106,0)
 S $P(RORSEG,HLFS,25)="SP"
"RTN","RORHL06",107,0)
 ;
"RTN","RORHL06",108,0)
 ;--- OBR-44 - Division
"RTN","RORHL06",109,0)
 S TMP=$G(ROROUT(63.08,RORIENS,.08,"E"))
"RTN","RORHL06",110,0)
 S IEN=$S(TMP'="":+$O(^SC("B",TMP,0)),1:0)
"RTN","RORHL06",111,0)
 S $P(RORSEG,HLFS,45)=$$DIV44^RORHLUT1(IEN,1,CS)
"RTN","RORHL06",112,0)
 ;
"RTN","RORHL06",113,0)
 ;--- Store the segment
"RTN","RORHL06",114,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL06",115,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL06",116,0)
 ;
"RTN","RORHL06",117,0)
 ;***** LIVER BIOPSY OBX SEGMENT(S) BUILDER
"RTN","RORHL06",118,0)
 ;
"RTN","RORHL06",119,0)
 ; RORIENS       IENS of Liver Biopsy Record in File #63.08
"RTN","RORHL06",120,0)
 ; RORFLDS       List of WP fields to return as OBX'es
"RTN","RORHL06",121,0)
 ;
"RTN","RORHL06",122,0)
 ; Return Values:
"RTN","RORHL06",123,0)
 ;       <0  Error code
"RTN","RORHL06",124,0)
 ;        0  Ok
"RTN","RORHL06",125,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL06",126,0)
 ;
"RTN","RORHL06",127,0)
OBX(RORIENS,RORFLDS) ;
"RTN","RORHL06",128,0)
 N BUF,CS,DIWF,DIWL,DIWR,ERRCNT,FLD,I,RORII,PZ,RC,RORMSG,ROROUT,RORRES,RORSEG,SCS,TMP,X
"RTN","RORHL06",129,0)
 S (ERRCNT,RC)=0
"RTN","RORHL06",130,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL06",131,0)
 S CS=$E(HLECH),SCS=$E(HLECH,4)
"RTN","RORHL06",132,0)
 ;--- Check the parameters
"RTN","RORHL06",133,0)
 S:$E(RORIENS,$L(RORIENS))'="," RORIENS=RORIENS_","
"RTN","RORHL06",134,0)
 ;
"RTN","RORHL06",135,0)
 ;--- Load the data
"RTN","RORHL06",136,0)
 D GETS^DIQ(63.08,RORIENS,RORFLDS,"EI","ROROUT","RORMSG")
"RTN","RORHL06",137,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL06",138,0)
 . D DBS^RORERR("RORMSG",-99,,,63.08,RORIENS)
"RTN","RORHL06",139,0)
 ;
"RTN","RORHL06",140,0)
 ;--- Initialize the segment
"RTN","RORHL06",141,0)
 S RORSEG="OBX"
"RTN","RORHL06",142,0)
 ;
"RTN","RORHL06",143,0)
 ;--- OBX-2
"RTN","RORHL06",144,0)
 S $P(RORSEG,HLFS,3)="FT"
"RTN","RORHL06",145,0)
 ;
"RTN","RORHL06",146,0)
 ;--- OBX-11
"RTN","RORHL06",147,0)
 S $P(RORSEG,HLFS,12)="F"
"RTN","RORHL06",148,0)
 ;
"RTN","RORHL06",149,0)
 F PZ=1:1  S FLD=$P(RORFLDS,";",PZ)  Q:FLD=""  D  Q:RC<0
"RTN","RORHL06",150,0)
 . S BUF=47000,TMP=$$CPT^ICPTCOD(BUF)
"RTN","RORHL06",151,0)
 . I TMP<0  D  S ERRCNT=ERRCNT+1,TMP=""
"RTN","RORHL06",152,0)
 . . D ERROR^RORERR(-57,,$P(TMP,U,2),,+TMP,"$$CPT^ICPTCOD")
"RTN","RORHL06",153,0)
 . S $P(BUF,SCS,2)=$$GET1^DID(63.08,FLD,,"LABEL",,"RORMSG")
"RTN","RORHL06",154,0)
 . S $P(BUF,CS,2)=$$ESCAPE^RORHL7($P(TMP,U,3))
"RTN","RORHL06",155,0)
 . S $P(BUF,CS,3)="C4"
"RTN","RORHL06",156,0)
 . S $P(RORSEG,HLFS,4)=BUF
"RTN","RORHL06",157,0)
 . ;---
"RTN","RORHL06",158,0)
 . K ^UTILITY($J,"W")
"RTN","RORHL06",159,0)
 . S DIWL=1,DIWR=72
"RTN","RORHL06",160,0)
 . S RORII=0
"RTN","RORHL06",161,0)
 . F  S RORII=$O(ROROUT(63.08,RORIENS,FLD,RORII))  Q:'RORII  D
"RTN","RORHL06",162,0)
 . . S X=ROROUT(63.08,RORIENS,FLD,RORII)  D ^DIWP
"RTN","RORHL06",163,0)
 . ;---
"RTN","RORHL06",164,0)
 . S I=0
"RTN","RORHL06",165,0)
 . F  S I=$O(^UTILITY($J,"W",DIWL,I))  Q:'I  D
"RTN","RORHL06",166,0)
 . . S $P(RORSEG,HLFS,6)=$G(^UTILITY($J,"W",DIWL,I,0))
"RTN","RORHL06",167,0)
 . . ;--- Store the segment
"RTN","RORHL06",168,0)
 . . D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL06",169,0)
 ;
"RTN","RORHL06",170,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL07")
0^39^B23072597
"RTN","RORHL07",1,0)
RORHL07 ;HOIFO/BH - HL7 INPATIENT PHARMACY: ORC,RXE ; 10/1/03 3:07pm
"RTN","RORHL07",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORHL07",3,0)
 ;
"RTN","RORHL07",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL07",5,0)
 ;
"RTN","RORHL07",6,0)
 ; Routine's RORHL07* use the following IAs:
"RTN","RORHL07",7,0)
 ;
"RTN","RORHL07",8,0)
 ; #93           Get stop code from the file #44 (controlled)
"RTN","RORHL07",9,0)
 ; #10040        Read the INSTITUTION field of file #44 (supported)
"RTN","RORHL07",10,0)
 ; #10060        Read access to file #200 (supported)
"RTN","RORHL07",11,0)
 ; #10090        Read access to file #4 (supported)
"RTN","RORHL07",12,0)
 ;
"RTN","RORHL07",13,0)
 ; #1977         Read access to file #52
"RTN","RORHL07",14,0)
 ; #1876         Read access to file #59
"RTN","RORHL07",15,0)
 ; #2497         Read access to file #55
"RTN","RORHL07",16,0)
 ; #221          Read access to file #50 and #50.68
"RTN","RORHL07",17,0)
 ; #2221         Read access to file 50.607
"RTN","RORHL07",18,0)
 ;
"RTN","RORHL07",19,0)
 Q
"RTN","RORHL07",20,0)
 ;
"RTN","RORHL07",21,0)
 ;***** INPATIENT PHARMACY ORC SEGMENT BUILDER
"RTN","RORHL07",22,0)
 ;
"RTN","RORHL07",23,0)
 ; RORIENS       IENS of Unit/Dose in subfile #55.06
"RTN","RORHL07",24,0)
 ;
"RTN","RORHL07",25,0)
 ; .RORORC       Array with info (from OEL^PSOORRL)
"RTN","RORHL07",26,0)
 ;
"RTN","RORHL07",27,0)
 ; Return Values:
"RTN","RORHL07",28,0)
 ;       <0  Error Code
"RTN","RORHL07",29,0)
 ;        0  Ok
"RTN","RORHL07",30,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL07",31,0)
 ;
"RTN","RORHL07",32,0)
ORC(RORIENS,RORORC) ;
"RTN","RORHL07",33,0)
 N BUF,CS,ERRCNT,IEN42,IEN44,RC,RORMSG,RORSEG,TMP
"RTN","RORHL07",34,0)
 S (ERRCNT,RC)=0
"RTN","RORHL07",35,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL07",36,0)
 S CS=$E(HLECH,1)
"RTN","RORHL07",37,0)
 ;--- Check the parameters
"RTN","RORHL07",38,0)
 S:$E(RORIENS,$L(RORIENS))'="," RORIENS=RORIENS_","
"RTN","RORHL07",39,0)
 ;
"RTN","RORHL07",40,0)
 ;--- Initialize the segment
"RTN","RORHL07",41,0)
 S RORSEG="ORC"
"RTN","RORHL07",42,0)
 ;
"RTN","RORHL07",43,0)
 ;--- ORC-1 - Order Control 
"RTN","RORHL07",44,0)
 S $P(RORSEG,HLFS,2)="NW"
"RTN","RORHL07",45,0)
 ;
"RTN","RORHL07",46,0)
 ;--- ORC-2 - Placer Order Number
"RTN","RORHL07",47,0)
 S TMP=$$GET1^DIQ(55.06,RORIENS,.01,,,"RORMSG")
"RTN","RORHL07",48,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,55.06,RORIENS)
"RTN","RORHL07",49,0)
 S $P(RORSEG,HLFS,3)=RORDFN_"V"_TMP_CS_"IP"
"RTN","RORHL07",50,0)
 ;
"RTN","RORHL07",51,0)
 ;--- ORC-12 - Provider
"RTN","RORHL07",52,0)
 S BUF=+$P($G(RORORC("P",0)),U)
"RTN","RORHL07",53,0)
 I BUF>0  D
"RTN","RORHL07",54,0)
 . S TMP=$$GET1^DIQ(200,+BUF_",",53.5,"I",,"RORMSG")
"RTN","RORHL07",55,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL07",56,0)
 . . D DBS^RORERR("RORMSG",-99,,,200,+BUF_",")
"RTN","RORHL07",57,0)
 . S:TMP>0 $P(BUF,CS,5)=TMP
"RTN","RORHL07",58,0)
 . S $P(RORSEG,HLFS,13)=BUF
"RTN","RORHL07",59,0)
 ;
"RTN","RORHL07",60,0)
 ;--- ORC-15 - Order Date/Time
"RTN","RORHL07",61,0)
 S TMP=$$FMTHL7^XLFDT($P($G(RORORC(0)),U,5))
"RTN","RORHL07",62,0)
 Q:TMP'>0 $$ERROR^RORERR(-100,,,,"No order date","OEL^PSOORRL")
"RTN","RORHL07",63,0)
 S $P(RORSEG,HLFS,16)=TMP
"RTN","RORHL07",64,0)
 ;
"RTN","RORHL07",65,0)
 ;--- ORC-16 - Control Code Reason
"RTN","RORHL07",66,0)
 S $P(RORSEG,HLFS,17)=CS_CS_CS_CS_"NEW"
"RTN","RORHL07",67,0)
 ;
"RTN","RORHL07",68,0)
 ;--- ORC-17 - Division
"RTN","RORHL07",69,0)
 S IEN42=+$$GET1^DIQ(55.06,RORIENS,9,"I",,"RORMSG")
"RTN","RORHL07",70,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL07",71,0)
 . D DBS^RORERR("RORMSG",-99,,,55.06,RORIENS)
"RTN","RORHL07",72,0)
 I IEN42>0  D
"RTN","RORHL07",73,0)
 . S IEN44=+$$GET1^DIQ(42,IEN42_",",44,"I",,"RORMSG")
"RTN","RORHL07",74,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL07",75,0)
 . . D DBS^RORERR("RORMSG",-99,,,42,IEN42_",")
"RTN","RORHL07",76,0)
 E  S IEN44=0
"RTN","RORHL07",77,0)
 S $P(RORSEG,HLFS,18)=$$DIV44^RORHLUT1(IEN44,2,CS)
"RTN","RORHL07",78,0)
 ;
"RTN","RORHL07",79,0)
 ;--- Store the segment
"RTN","RORHL07",80,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL07",81,0)
 Q ERRCNT
"RTN","RORHL07",82,0)
 ;
"RTN","RORHL07",83,0)
 ;***** INPATIENT PHARMACY RXE SEGMENT BUILDER
"RTN","RORHL07",84,0)
 ;
"RTN","RORHL07",85,0)
 ; RORIENS       IENS of Pharmacy Record in subfile #55.06
"RTN","RORHL07",86,0)
 ; .RORRXE       Array containing info (from OEL^PSJORRL)
"RTN","RORHL07",87,0)
 ;
"RTN","RORHL07",88,0)
 ; Return Values:
"RTN","RORHL07",89,0)
 ;       <0  Error Code
"RTN","RORHL07",90,0)
 ;        0  Ok
"RTN","RORHL07",91,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL07",92,0)
 ;
"RTN","RORHL07",93,0)
RXE(RORIENS,RORRXE) ;
"RTN","RORHL07",94,0)
 N BUF,CS,ERRCNT,IDGN,II,INDF,RC,RORMSG,RORMR,ROROUT,RORUIN,RORUOUT,RORQT,RORSEG,TMP
"RTN","RORHL07",95,0)
 S (ERRCNT,RC)=0
"RTN","RORHL07",96,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL07",97,0)
 S CS=$E(HLECH,1)
"RTN","RORHL07",98,0)
 ;--- Check the parameters
"RTN","RORHL07",99,0)
 S:$E(RORIENS,$L(RORIENS))'="," RORIENS=RORIENS_","
"RTN","RORHL07",100,0)
 ;
"RTN","RORHL07",101,0)
 Q:$P($G(RORRXE(0)),U)="" 0
"RTN","RORHL07",102,0)
 ;
"RTN","RORHL07",103,0)
 ;--- Load the data
"RTN","RORHL07",104,0)
 D GETS^DIQ(55.06,RORIENS,"3;26","E","ROROUT","RORMSG")
"RTN","RORHL07",105,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL07",106,0)
 . D DBS^RORERR("RORMSG",-99,,,55.06,RORIENS)
"RTN","RORHL07",107,0)
 S RORMR=$$ESCAPE^RORHL7($G(ROROUT(55.06,RORIENS,3,"E")))
"RTN","RORHL07",108,0)
 S TMP=$G(ROROUT(55.06,RORIENS,26,"E")),RORQT=""
"RTN","RORHL07",109,0)
 S:TMP'="" $P(RORQT,CS,8)=$$ESCAPE^RORHL7(TMP)
"RTN","RORHL07",110,0)
 ;
"RTN","RORHL07",111,0)
 S II=0
"RTN","RORHL07",112,0)
 F  S II=$O(RORRXE("DD",II)) Q:II=""  D  Q:RC<0
"RTN","RORHL07",113,0)
 . K ROROUT
"RTN","RORHL07",114,0)
 . ;--- Initialize the segment
"RTN","RORHL07",115,0)
 . S RORSEG="RXE"
"RTN","RORHL07",116,0)
 . ;
"RTN","RORHL07",117,0)
 . ;--- RXE-1 - Quantity/Timing
"RTN","RORHL07",118,0)
 . S $P(RORSEG,HLFS,2)=RORQT
"RTN","RORHL07",119,0)
 . ;
"RTN","RORHL07",120,0)
 . ;--- RXE-2 - Give Code
"RTN","RORHL07",121,0)
 . S IDGN=+$P($G(RORRXE("DD",II,0)),U)
"RTN","RORHL07",122,0)
 . S:IDGN'>0 IDGN=+$P($G(RORRXE("DD",II,0)),U,3)  Q:IDGN'>0
"RTN","RORHL07",123,0)
 . S BUF="",TMP=$$RXE2^RORHL031(IDGN,CS,.BUF)
"RTN","RORHL07",124,0)
 . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL07",125,0)
 . Q:BUF=""
"RTN","RORHL07",126,0)
 . S $P(RORSEG,HLFS,3)=BUF
"RTN","RORHL07",127,0)
 . ;
"RTN","RORHL07",128,0)
 . ;--- RXE-3 - Give Amount (Min)
"RTN","RORHL07",129,0)
 . S $P(RORSEG,HLFS,4)=""""""
"RTN","RORHL07",130,0)
 . ;
"RTN","RORHL07",131,0)
 . ;--- RXE-5 - Give Units
"RTN","RORHL07",132,0)
 . S INDF=+$$GET1^DIQ(50,IDGN,22,"I",,"RORMSG")_"," ; File #50.68 IEN
"RTN","RORHL07",133,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL07",134,0)
 . . D DBS^RORERR("RORMSG",-99,,,50,IDGN)
"RTN","RORHL07",135,0)
 . I INDF>0  D
"RTN","RORHL07",136,0)
 . . S RORUIN=$$PROD0^PSNAPIS(,INDF)
"RTN","RORHL07",137,0)
 . . S RORUIN=$P(RORUIN,U,4)
"RTN","RORHL07",138,0)
 . . Q:'RORUIN
"RTN","RORHL07",139,0)
        . . S RORUOUT=$P($G(^PS(50.607,RORUIN,0)),U)
"RTN","RORHL07",140,0)
 . . S BUF=""
"RTN","RORHL07",141,0)
 . . S $P(BUF,CS,4)=RORUIN
"RTN","RORHL07",142,0)
 . . Q:$P(BUF,CS,4)=""
"RTN","RORHL07",143,0)
 . . S $P(BUF,CS,5)=$$ESCAPE^RORHL7(RORUOUT)
"RTN","RORHL07",144,0)
 . . S $P(BUF,CS,6)="99PSU"
"RTN","RORHL07",145,0)
 . . S $P(RORSEG,HLFS,6)=BUF
"RTN","RORHL07",146,0)
 . ;
"RTN","RORHL07",147,0)
 . ;--- RXE-18 - Stop Date/Time
"RTN","RORHL07",148,0)
 . S TMP=$P($G(RORRXE(0)),U,3)
"RTN","RORHL07",149,0)
 . S $P(RORSEG,HLFS,19)=$$FM2HL^RORHL7(TMP)
"RTN","RORHL07",150,0)
 . ;
"RTN","RORHL07",151,0)
 . ;--- RXE-21 - Medication Route
"RTN","RORHL07",152,0)
 . S:RORMR'="" $P(RORSEG,HLFS,22)=RORMR
"RTN","RORHL07",153,0)
 . ;
"RTN","RORHL07",154,0)
 . ;--- RXE-24 - Units per dose
"RTN","RORHL07",155,0)
 . S TMP=$P($G(RORRXE("DD",II,0)),U,2)
"RTN","RORHL07",156,0)
 . S TMP=+TMP
"RTN","RORHL07",157,0)
 . S:TMP'="" $P(RORSEG,HLFS,25)=TMP
"RTN","RORHL07",158,0)
 . ;
"RTN","RORHL07",159,0)
 . ;--- Store the segment
"RTN","RORHL07",160,0)
 . D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL07",161,0)
 ;
"RTN","RORHL07",162,0)
 Q ERRCNT
"RTN","RORHL071")
0^178^B20781846
"RTN","RORHL071",1,0)
RORHL071 ;HOIFO/BH - HL7 IV PHARMACY: ORC,RXE ; 10/1/03 3:07pm
"RTN","RORHL071",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL071",3,0)
 ;
"RTN","RORHL071",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL071",5,0)
 ;
"RTN","RORHL071",6,0)
 ; See RORHL07 for RORHL07* IA's.
"RTN","RORHL071",7,0)
 ;
"RTN","RORHL071",8,0)
 Q
"RTN","RORHL071",9,0)
 ;
"RTN","RORHL071",10,0)
 ;***** IV PHARMACY ORC SEGMENT BUILDER
"RTN","RORHL071",11,0)
 ;
"RTN","RORHL071",12,0)
 ; RORIENS       IENS of IV in subfile #55.01
"RTN","RORHL071",13,0)
 ;
"RTN","RORHL071",14,0)
 ; .RORORC       Array with info (from OEL^PSOORRL)
"RTN","RORHL071",15,0)
 ;
"RTN","RORHL071",16,0)
 ; Return Values:
"RTN","RORHL071",17,0)
 ;       <0  Error Code
"RTN","RORHL071",18,0)
 ;        0  Ok
"RTN","RORHL071",19,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL071",20,0)
 ;
"RTN","RORHL071",21,0)
ORC(RORIENS,RORORC) ;
"RTN","RORHL071",22,0)
 N BUF,CS,ERRCNT,IEN42,IEN44,RC,RORMSG,RORSEG,TMP
"RTN","RORHL071",23,0)
 S (ERRCNT,RC)=0
"RTN","RORHL071",24,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL071",25,0)
 S CS=$E(HLECH,1)
"RTN","RORHL071",26,0)
 ;--- Check the parameters
"RTN","RORHL071",27,0)
 S:$E(RORIENS,$L(RORIENS))'="," RORIENS=RORIENS_","
"RTN","RORHL071",28,0)
 ;
"RTN","RORHL071",29,0)
 ;--- Initialize the segment
"RTN","RORHL071",30,0)
 S RORSEG="ORC"
"RTN","RORHL071",31,0)
 ;
"RTN","RORHL071",32,0)
 ;--- ORC-1 - Order Control 
"RTN","RORHL071",33,0)
 S $P(RORSEG,HLFS,2)="NW"
"RTN","RORHL071",34,0)
 ;
"RTN","RORHL071",35,0)
 ;--- ORC-2 - Placer Order Number
"RTN","RORHL071",36,0)
 S TMP=$$GET1^DIQ(55.01,RORIENS,.01,,,"RORMSG")
"RTN","RORHL071",37,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,55.01,RORIENS)
"RTN","RORHL071",38,0)
 S $P(RORSEG,HLFS,3)=RORDFN_"V"_TMP_CS_"IP"
"RTN","RORHL071",39,0)
 ;
"RTN","RORHL071",40,0)
 ;--- ORC-12 - Provider
"RTN","RORHL071",41,0)
 S BUF=+$P($G(RORORC("P",0)),U)
"RTN","RORHL071",42,0)
 I BUF>0  D
"RTN","RORHL071",43,0)
 . S TMP=$$GET1^DIQ(200,+BUF_",",53.5,"I",,"RORMSG")
"RTN","RORHL071",44,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL071",45,0)
 . . D DBS^RORERR("RORMSG",-99,,,200,+BUF_",")
"RTN","RORHL071",46,0)
 . S:TMP>0 $P(BUF,CS,5)=TMP
"RTN","RORHL071",47,0)
 . S $P(RORSEG,HLFS,13)=BUF
"RTN","RORHL071",48,0)
 ;
"RTN","RORHL071",49,0)
 ;--- ORC-15 - Order Date/Time
"RTN","RORHL071",50,0)
 S TMP=$$FMTHL7^XLFDT($P($G(RORORC(0)),U,5))
"RTN","RORHL071",51,0)
 Q:TMP'>0 $$ERROR^RORERR(-100,,,,"No order date","OEL^PSOORRL")
"RTN","RORHL071",52,0)
 S $P(RORSEG,HLFS,16)=TMP
"RTN","RORHL071",53,0)
 ;
"RTN","RORHL071",54,0)
 ;--- ORC-16 - Control Code Reason
"RTN","RORHL071",55,0)
 S $P(RORSEG,HLFS,17)=CS_CS_CS_CS_"NEW"
"RTN","RORHL071",56,0)
 ;
"RTN","RORHL071",57,0)
 ;--- ORC-17 - Division
"RTN","RORHL071",58,0)
 S IEN42=+$$GET1^DIQ(55.01,RORIENS,9,"I",,"RORMSG")
"RTN","RORHL071",59,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL071",60,0)
 . D DBS^RORERR("RORMSG",-99,,,55.01,RORIENS)
"RTN","RORHL071",61,0)
 I IEN42>0  D
"RTN","RORHL071",62,0)
 . S IEN44=+$$GET1^DIQ(42,IEN42_",",44,"I",,"RORMSG")
"RTN","RORHL071",63,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL071",64,0)
 . . D DBS^RORERR("RORMSG",-99,,,42,IEN42_",")
"RTN","RORHL071",65,0)
 E  S IEN44=0
"RTN","RORHL071",66,0)
 S $P(RORSEG,HLFS,18)=$$DIV44^RORHLUT1(IEN44,2,CS)
"RTN","RORHL071",67,0)
 ;
"RTN","RORHL071",68,0)
 ;--- Store the segment
"RTN","RORHL071",69,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL071",70,0)
 Q ERRCNT
"RTN","RORHL071",71,0)
 ;
"RTN","RORHL071",72,0)
 ;***** IV PHARMACY RXE SEGMENT BUILDER
"RTN","RORHL071",73,0)
 ;
"RTN","RORHL071",74,0)
 ; RORIENS       IENS of Pharmacy Record in subfile #55.01
"RTN","RORHL071",75,0)
 ; .RORRXE       Array containing info (from OEL^PSJORRL)
"RTN","RORHL071",76,0)
 ;
"RTN","RORHL071",77,0)
 ; Return Values:
"RTN","RORHL071",78,0)
 ;       <0  Error Code
"RTN","RORHL071",79,0)
 ;        0  Ok
"RTN","RORHL071",80,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL071",81,0)
 ;
"RTN","RORHL071",82,0)
RXE(RORIENS,RORRXE) ;
"RTN","RORHL071",83,0)
 N BUF,CS,ERRCNT,IDGN,II,INDF,RC,RORMSG,RORMR,ROROUT,RORQT,RORSEG,RORUIN,RORUOUT,TMP
"RTN","RORHL071",84,0)
 S (ERRCNT,RC)=0
"RTN","RORHL071",85,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL071",86,0)
 S CS=$E(HLECH,1)
"RTN","RORHL071",87,0)
 ;--- Check the parameters
"RTN","RORHL071",88,0)
 S:$E(RORIENS,$L(RORIENS))'="," RORIENS=RORIENS_","
"RTN","RORHL071",89,0)
 ;
"RTN","RORHL071",90,0)
 Q:$P($G(RORRXE(0)),U)="" 0
"RTN","RORHL071",91,0)
 ;
"RTN","RORHL071",92,0)
 ;--- Load the data
"RTN","RORHL071",93,0)
 D GETS^DIQ(55.01,RORIENS,"132;.09","E","ROROUT","RORMSG")
"RTN","RORHL071",94,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL071",95,0)
 . D DBS^RORERR("RORMSG",-99,,,55.01,RORIENS)
"RTN","RORHL071",96,0)
 S RORMR=$$ESCAPE^RORHL7($G(ROROUT(55.01,RORIENS,132,"E")))
"RTN","RORHL071",97,0)
 S TMP=$G(ROROUT(55.01,RORIENS,.09,"E")),RORQT=""
"RTN","RORHL071",98,0)
 S:TMP'="" $P(RORQT,CS,8)=$$ESCAPE^RORHL7(TMP)
"RTN","RORHL071",99,0)
 ;
"RTN","RORHL071",100,0)
 S II=0
"RTN","RORHL071",101,0)
 F  S II=$O(RORRXE("DD",II)) Q:II=""  D  Q:RC<0
"RTN","RORHL071",102,0)
 . K ROROUT
"RTN","RORHL071",103,0)
 . ;--- Initialize the segment
"RTN","RORHL071",104,0)
 . S RORSEG="RXE"
"RTN","RORHL071",105,0)
 . ;
"RTN","RORHL071",106,0)
 . ;--- RXE-1 - Quantity/Timing
"RTN","RORHL071",107,0)
 . S $P(RORSEG,HLFS,2)=RORQT
"RTN","RORHL071",108,0)
 . ;
"RTN","RORHL071",109,0)
 . ;--- RXE-2 - Give Code
"RTN","RORHL071",110,0)
 . S IDGN=+$P($G(RORRXE("DD",II,0)),U)
"RTN","RORHL071",111,0)
 . S:IDGN'>0 IDGN=+$P($G(RORRXE("DD",II,0)),U,3)  Q:IDGN'>0
"RTN","RORHL071",112,0)
 . S BUF="",TMP=$$RXE2^RORHL031(IDGN,CS,.BUF)
"RTN","RORHL071",113,0)
 . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL071",114,0)
 . Q:BUF=""
"RTN","RORHL071",115,0)
 . S $P(RORSEG,HLFS,3)=BUF
"RTN","RORHL071",116,0)
 . ;
"RTN","RORHL071",117,0)
 . ;--- RXE-3 - Give Amount (Min)
"RTN","RORHL071",118,0)
 . S $P(RORSEG,HLFS,4)=""""""
"RTN","RORHL071",119,0)
 . ;
"RTN","RORHL071",120,0)
 . ;--- RXE-5 - Give Units
"RTN","RORHL071",121,0)
 . S INDF=+$$GET1^DIQ(50,IDGN,22,"I",,"RORMSG")_"," ; File #50.68 IEN
"RTN","RORHL071",122,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL071",123,0)
 . . D DBS^RORERR("RORMSG",-99,,,50,IDGN)
"RTN","RORHL071",124,0)
 . I INDF>0  D
"RTN","RORHL071",125,0)
 . . S RORUIN=$$PROD0^PSNAPIS(,INDF)
"RTN","RORHL071",126,0)
 . . S RORUIN=$P(RORUIN,U,4)
"RTN","RORHL071",127,0)
 . . S RORUOUT=$P(^PS(50.607,RORUIN,0),U)
"RTN","RORHL071",128,0)
 . . S BUF=""
"RTN","RORHL071",129,0)
 . . S $P(BUF,CS,4)=RORUIN
"RTN","RORHL071",130,0)
 . . Q:$P(BUF,CS,4)=""
"RTN","RORHL071",131,0)
 . . S $P(BUF,CS,5)=$$ESCAPE^RORHL7(RORUOUT)
"RTN","RORHL071",132,0)
 . . S $P(BUF,CS,6)="99PSU"
"RTN","RORHL071",133,0)
 . . S $P(RORSEG,HLFS,6)=BUF
"RTN","RORHL071",134,0)
 . ;
"RTN","RORHL071",135,0)
 . ;--- RXE-18 - Stop Date/Time
"RTN","RORHL071",136,0)
 . S TMP=$P($G(RORRXE(0)),U,3)
"RTN","RORHL071",137,0)
 . S $P(RORSEG,HLFS,19)=$$FM2HL^RORHL7(TMP)
"RTN","RORHL071",138,0)
 . ;
"RTN","RORHL071",139,0)
 . ;--- RXE-21 - Medication Route
"RTN","RORHL071",140,0)
 . S:RORMR'="" $P(RORSEG,HLFS,22)=RORMR
"RTN","RORHL071",141,0)
 . ;
"RTN","RORHL071",142,0)
 . ;--- RXE-24 - Units per dose
"RTN","RORHL071",143,0)
 . S TMP=$P($G(RORRXE("DD",II,0)),U,2)
"RTN","RORHL071",144,0)
 . S TMP=+TMP
"RTN","RORHL071",145,0)
 . S:TMP'="" $P(RORSEG,HLFS,25)=TMP
"RTN","RORHL071",146,0)
 . ;
"RTN","RORHL071",147,0)
 . ;--- Store the segment
"RTN","RORHL071",148,0)
 . D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL071",149,0)
 ;
"RTN","RORHL071",150,0)
 Q ERRCNT
"RTN","RORHL08")
0^40^B21198580
"RTN","RORHL08",1,0)
RORHL08 ;HOIFO/BH - HL7 INPATIENT DATA: PV1,OBR ; 10/1/03 1:29pm
"RTN","RORHL08",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL08",3,0)
 ;
"RTN","RORHL08",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL08",5,0)
 ;
"RTN","RORHL08",6,0)
 ; #92           Read access to the PTF file (controlled)
"RTN","RORHL08",7,0)
 ;
"RTN","RORHL08",8,0)
 Q
"RTN","RORHL08",9,0)
 ;
"RTN","RORHL08",10,0)
 ;***** INPATIENT DATA SEGMENT BUILDER
"RTN","RORHL08",11,0)
 ;
"RTN","RORHL08",12,0)
 ; RORDFN        DFN of Patient Record in File #2
"RTN","RORHL08",13,0)
 ;
"RTN","RORHL08",14,0)
 ; .DXDTS        Reference to a local variable where the
"RTN","RORHL08",15,0)
 ;               data extraction time frames are stored.
"RTN","RORHL08",16,0)
 ;
"RTN","RORHL08",17,0)
 ; RORTY         Set to either "PV1" or "OBR"
"RTN","RORHL08",18,0)
 ;
"RTN","RORHL08",19,0)
 ; Return Values:
"RTN","RORHL08",20,0)
 ;       <0  Error Code
"RTN","RORHL08",21,0)
 ;        0  Ok
"RTN","RORHL08",22,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL08",23,0)
 ;
"RTN","RORHL08",24,0)
 ; The function uses the ^TMP("RORHL08",$J) global node.
"RTN","RORHL08",25,0)
 ;
"RTN","RORHL08",26,0)
EN1(RORDFN,DXDTS,RORTY) ;
"RTN","RORHL08",27,0)
 N ERRCNT,IENS,INIEN,PV1CNT,RC,RORMSG,TMP
"RTN","RORHL08",28,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL08",29,0)
 S (ERRCNT,RC)=0
"RTN","RORHL08",30,0)
 ;
"RTN","RORHL08",31,0)
 ;--- PV1 Segments
"RTN","RORHL08",32,0)
 I RORTY="PV1"  K ^TMP("RORHL08",$J)  D
"RTN","RORHL08",33,0)
 . N DATE,ENDT,IDX,STDT,TYPE
"RTN","RORHL08",34,0)
 . S (IDX,PV1CNT)=0
"RTN","RORHL08",35,0)
 . F  S IDX=$O(DXDTS(3,IDX))  Q:IDX'>0  D  Q:RC<0
"RTN","RORHL08",36,0)
 . . S STDT=$P(DXDTS(3,IDX),U),ENDT=$P(DXDTS(3,IDX),U,2)
"RTN","RORHL08",37,0)
 . . ;---
"RTN","RORHL08",38,0)
 . . S DATE=$O(^DGPT("AAD",RORDFN,STDT),-1)
"RTN","RORHL08",39,0)
 . . F  S DATE=$O(^DGPT("AAD",RORDFN,DATE))  Q:'DATE!(DATE'<ENDT)  D
"RTN","RORHL08",40,0)
 . . . S INIEN=""
"RTN","RORHL08",41,0)
 . . . F  S INIEN=$O(^DGPT("AAD",RORDFN,DATE,INIEN))  Q:'INIEN  D
"RTN","RORHL08",42,0)
 . . . . S IENS=INIEN_","
"RTN","RORHL08",43,0)
 . . . . ;--- Skip census records
"RTN","RORHL08",44,0)
 . . . . S TYPE=$$GET1^DIQ(45,IENS,11,"I",,"RORMSG")
"RTN","RORHL08",45,0)
 . . . . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL08",46,0)
 . . . . . D DBS^RORERR("RORMSG",-9,,RORDFN,45,IENS)
"RTN","RORHL08",47,0)
 . . . . Q:TYPE'="1"
"RTN","RORHL08",48,0)
 . . . . ;--- Generate the PV1 segment
"RTN","RORHL08",49,0)
 . . . . S TMP=$$PV1(INIEN,RORDFN)
"RTN","RORHL08",50,0)
 . . . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL08",51,0)
 . . . . ;--- Reference for the corresponding OBR and OBX segments
"RTN","RORHL08",52,0)
 . . . . S:TMP'="S" PV1CNT=PV1CNT+1,^TMP("RORHL08",$J,PV1CNT)=INIEN
"RTN","RORHL08",53,0)
 ;
"RTN","RORHL08",54,0)
 ;--- OBR and OBX Segments
"RTN","RORHL08",55,0)
 I RORTY="OBR"  D  K ^TMP("RORHL08",$J)
"RTN","RORHL08",56,0)
 . S PV1CNT=0
"RTN","RORHL08",57,0)
 . F  S PV1CNT=$O(^TMP("RORHL08",$J,PV1CNT))  Q:PV1CNT'>0  D
"RTN","RORHL08",58,0)
 . . S INIEN=+$G(^TMP("RORHL08",$J,PV1CNT))  Q:INIEN'>0
"RTN","RORHL08",59,0)
 . . ;---
"RTN","RORHL08",60,0)
 . . S TMP=$$OBR(INIEN,RORDFN)
"RTN","RORHL08",61,0)
 . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL08",62,0)
 . . ;---
"RTN","RORHL08",63,0)
 . . S TMP=$$OBX^RORHL081(INIEN,RORDFN)
"RTN","RORHL08",64,0)
 . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL08",65,0)
 ;
"RTN","RORHL08",66,0)
 ;--- Check for errors
"RTN","RORHL08",67,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL08",68,0)
 ;
"RTN","RORHL08",69,0)
 ;***** PV1 SEGMENT BUILDER (INPATIENT)
"RTN","RORHL08",70,0)
 ;
"RTN","RORHL08",71,0)
 ; RORIEN        IEN of file #45
"RTN","RORHL08",72,0)
 ;
"RTN","RORHL08",73,0)
 ; RORDFN        DFN of Patient Record in File #2
"RTN","RORHL08",74,0)
 ;
"RTN","RORHL08",75,0)
 ; Return Values:
"RTN","RORHL08",76,0)
 ;       <0  Error Code
"RTN","RORHL08",77,0)
 ;        0  Ok
"RTN","RORHL08",78,0)
 ;      "S"  No inpatient data
"RTN","RORHL08",79,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL08",80,0)
 ;
"RTN","RORHL08",81,0)
PV1(RORIEN,RORDFN) ;
"RTN","RORHL08",82,0)
 N BUF,CS,ERRCNT,IENS,RC,RORBUF,RORMSG,RORSEG,TMP
"RTN","RORHL08",83,0)
 S (ERRCNT,RC)=0
"RTN","RORHL08",84,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL08",85,0)
 S CS=$E(HLECH,1)
"RTN","RORHL08",86,0)
 ;
"RTN","RORHL08",87,0)
 ;--- Load the data
"RTN","RORHL08",88,0)
 S IENS=RORIEN_","
"RTN","RORHL08",89,0)
 D GETS^DIQ(45,IENS,"2;70;71;72","I","RORBUF","RORMSG")
"RTN","RORHL08",90,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL08",91,0)
 . D DBS^RORERR("RORMSG",-9,,RORDFN,45,IENS)
"RTN","RORHL08",92,0)
 ;
"RTN","RORHL08",93,0)
 ;--- Initialize the segment
"RTN","RORHL08",94,0)
 S RORSEG="PV1"
"RTN","RORHL08",95,0)
 ;
"RTN","RORHL08",96,0)
 ;--- PV1-2 - Patient Class
"RTN","RORHL08",97,0)
 S $P(RORSEG,HLFS,3)="I"  ; I - Inpatient
"RTN","RORHL08",98,0)
 ;
"RTN","RORHL08",99,0)
 ;--- PV1-3 - Assigned Patient Location
"RTN","RORHL08",100,0)
 S TMP=$E($P($$SITE^VASITE,U,3),1,3)  ; Strip the suffix
"RTN","RORHL08",101,0)
 Q:TMP'>0 $$ERROR^RORERR(-100,,,,"No station number","$$SITE^VASITE")
"RTN","RORHL08",102,0)
 S $P(RORSEG,HLFS,4)=TMP
"RTN","RORHL08",103,0)
 ;
"RTN","RORHL08",104,0)
 ;--- PV1-6 - Prior Patient Location
"RTN","RORHL08",105,0)
 I $G(RORBUF(45,IENS,71,"I"))>0  D
"RTN","RORHL08",106,0)
 . S BUF=""
"RTN","RORHL08",107,0)
 . S $P(BUF,CS,3)=RORBUF(45,IENS,71,"I")
"RTN","RORHL08",108,0)
 . S TMP=$$EXTERNAL^DILFD(45,71,,$P(BUF,CS,3),"RORMSG")
"RTN","RORHL08",109,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL08",110,0)
 . . D DBS^RORERR("RORMSG",-99,,RORDFN,45,IENS)
"RTN","RORHL08",111,0)
 . S $P(BUF,CS,9)=$$ESCAPE^RORHL7(TMP)
"RTN","RORHL08",112,0)
 . S $P(RORSEG,HLFS,7)=BUF
"RTN","RORHL08",113,0)
 ;
"RTN","RORHL08",114,0)
 ;--- PV1-19 - Visit Number (KEY)
"RTN","RORHL08",115,0)
 S $P(RORSEG,HLFS,20)=RORIEN
"RTN","RORHL08",116,0)
 ;
"RTN","RORHL08",117,0)
 ;--- PV1-36 - Discharge Disposition
"RTN","RORHL08",118,0)
 S $P(RORSEG,HLFS,37)=$G(RORBUF(45,IENS,72,"I"))
"RTN","RORHL08",119,0)
 ;
"RTN","RORHL08",120,0)
 ;--- PV1-44 - Admit Date/Time (KEY)
"RTN","RORHL08",121,0)
 S TMP=$$FMTHL7^XLFDT($G(RORBUF(45,IENS,2,"I")))
"RTN","RORHL08",122,0)
 Q:TMP'>0 $$ERROR^RORERR(-95,,,RORDFN,45,IENS,2)
"RTN","RORHL08",123,0)
 S $P(RORSEG,HLFS,45)=TMP
"RTN","RORHL08",124,0)
 ;
"RTN","RORHL08",125,0)
 ;--- PV1-45 - Discharge Date/Time
"RTN","RORHL08",126,0)
 S $P(RORSEG,HLFS,46)=$$FM2HL^RORHL7($G(RORBUF(45,IENS,70,"I")))
"RTN","RORHL08",127,0)
 ;
"RTN","RORHL08",128,0)
 ;--- Store the segment
"RTN","RORHL08",129,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL08",130,0)
 Q ERRCNT
"RTN","RORHL08",131,0)
 ;
"RTN","RORHL08",132,0)
 ;***** OBR SEGMENT BUILDER (INPATIENT)
"RTN","RORHL08",133,0)
 ;
"RTN","RORHL08",134,0)
 ; RORIEN        IEN of file #45
"RTN","RORHL08",135,0)
 ;
"RTN","RORHL08",136,0)
 ; RORDFN        DFN of Patient Record in File #2
"RTN","RORHL08",137,0)
 ;
"RTN","RORHL08",138,0)
 ; Return Values:
"RTN","RORHL08",139,0)
 ;       <0  Error Code
"RTN","RORHL08",140,0)
 ;        0  Ok
"RTN","RORHL08",141,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL08",142,0)
 ;
"RTN","RORHL08",143,0)
OBR(RORIEN,RORDFN) ;
"RTN","RORHL08",144,0)
 N CS,ERRCNT,IENS,OBDT,RC,RORMSG,RORSEG,TMP
"RTN","RORHL08",145,0)
 S (ERRCNT,RC)=0
"RTN","RORHL08",146,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL08",147,0)
 S CS=$E(HLECH,1)
"RTN","RORHL08",148,0)
 ;
"RTN","RORHL08",149,0)
 ;--- Initialize the segment
"RTN","RORHL08",150,0)
 S RORSEG="OBR"
"RTN","RORHL08",151,0)
 ;
"RTN","RORHL08",152,0)
 ;--- OBR-3 - Order Number
"RTN","RORHL08",153,0)
 S $P(RORSEG,HLFS,4)=RORIEN
"RTN","RORHL08",154,0)
 ;
"RTN","RORHL08",155,0)
 ;--- OBR-4 - Universal Service ID
"RTN","RORHL08",156,0)
 S $P(RORSEG,HLFS,5)="IP"_CS_"Inpatient"_CS_"C4"
"RTN","RORHL08",157,0)
 ;
"RTN","RORHL08",158,0)
 ;--- OBR-7 -Observation Date/Time (KEY)
"RTN","RORHL08",159,0)
 S IENS=RORIEN_","
"RTN","RORHL08",160,0)
 S OBDT=$$GET1^DIQ(45,IENS,2,"I",,"RORMSG")
"RTN","RORHL08",161,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,RORDFN,45,IENS)
"RTN","RORHL08",162,0)
 ;---
"RTN","RORHL08",163,0)
 S OBDT=$$FMTHL7^XLFDT(OBDT)
"RTN","RORHL08",164,0)
 Q:OBDT'>0 $$ERROR^RORERR(-95,,,RORDFN,45,IENS,2)
"RTN","RORHL08",165,0)
 S $P(RORSEG,HLFS,8)=OBDT
"RTN","RORHL08",166,0)
 ;
"RTN","RORHL08",167,0)
 ;--- OBR-24 - Diagnostic Service ID
"RTN","RORHL08",168,0)
 S $P(RORSEG,HLFS,25)="PHY"
"RTN","RORHL08",169,0)
 ;
"RTN","RORHL08",170,0)
 ;--- OBR-44 - Division
"RTN","RORHL08",171,0)
 S $P(RORSEG,HLFS,45)=$$SITE1^RORUTL03(CS)
"RTN","RORHL08",172,0)
 ;
"RTN","RORHL08",173,0)
 ;--- Store the segment
"RTN","RORHL08",174,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL08",175,0)
 Q ERRCNT
"RTN","RORHL081")
0^68^B43279413
"RTN","RORHL081",1,0)
RORHL081 ;HOIFO/BH - HL7 INPATIENT DATA: OBX ; 10/1/03 1:26pm
"RTN","RORHL081",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL081",3,0)
 ;
"RTN","RORHL081",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL081",5,0)
 ;
"RTN","RORHL081",6,0)
 ; #92           Read access to the PTF file (Controlled)
"RTN","RORHL081",7,0)
 ;
"RTN","RORHL081",8,0)
 Q
"RTN","RORHL081",9,0)
 ;
"RTN","RORHL081",10,0)
 ;***** OBX SEGMENT(S) BUILDER (INPATIENT)
"RTN","RORHL081",11,0)
 ;
"RTN","RORHL081",12,0)
 ; RORIEN        IEN of file #45
"RTN","RORHL081",13,0)
 ; RORDFN        DFN of Patient Record in File #2
"RTN","RORHL081",14,0)
 ;
"RTN","RORHL081",15,0)
 ; Return Values:
"RTN","RORHL081",16,0)
 ;       <0  Error Code
"RTN","RORHL081",17,0)
 ;        0  Ok
"RTN","RORHL081",18,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL081",19,0)
 ;
"RTN","RORHL081",20,0)
OBX(RORIEN,RORDFN) ;
"RTN","RORHL081",21,0)
 N CS,ERRCNT,RC,RORLST,RORMSG,TMP
"RTN","RORHL081",22,0)
 S (ERRCNT,RC)=0
"RTN","RORHL081",23,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL081",24,0)
 S CS=$E(HLECH)
"RTN","RORHL081",25,0)
 ;
"RTN","RORHL081",26,0)
 ;--- Principal diagnosis
"RTN","RORHL081",27,0)
 S RC=$$PRIN(RORIEN)
"RTN","RORHL081",28,0)
 I RC  S ERRCNT=ERRCNT+1  Q:RC<0 RC
"RTN","RORHL081",29,0)
 ;--- Primary discharge diagnosis
"RTN","RORHL081",30,0)
 S RC=$$PDISCH(RORIEN)
"RTN","RORHL081",31,0)
 I RC  S ERRCNT=ERRCNT+1  Q:RC<0 RC
"RTN","RORHL081",32,0)
 ;--- Discharge diagnosis codes
"RTN","RORHL081",33,0)
 S RC=$$DDIAG(RORIEN)
"RTN","RORHL081",34,0)
 I RC  S ERRCNT=ERRCNT+1  Q:RC<0 RC
"RTN","RORHL081",35,0)
 ;--- Bed section
"RTN","RORHL081",36,0)
 S RC=$$BEDSEC(RORIEN)
"RTN","RORHL081",37,0)
 I RC  S ERRCNT=ERRCNT+1  Q:RC<0 RC
"RTN","RORHL081",38,0)
 ;--- Surgical procedures
"RTN","RORHL081",39,0)
 S RC=$$SURGPRO(RORIEN)
"RTN","RORHL081",40,0)
 I RC  S ERRCNT=ERRCNT+1  Q:RC<0 RC
"RTN","RORHL081",41,0)
 ;--- Other procedures
"RTN","RORHL081",42,0)
 S RC=$$OTRPROC(RORIEN)
"RTN","RORHL081",43,0)
 I RC  S ERRCNT=ERRCNT+1  Q:RC<0 RC
"RTN","RORHL081",44,0)
 ;
"RTN","RORHL081",45,0)
 Q ERRCNT
"RTN","RORHL081",46,0)
 ;
"RTN","RORHL081",47,0)
 ;***** BED SECTION
"RTN","RORHL081",48,0)
BEDSEC(RORIEN) ;
"RTN","RORHL081",49,0)
 N DATE,ERRCNT,FLD,ICDFLST,IEN4502,IENS,IFL,NODE,OID,RORBS,RORBSED,RORBSSD,RORBUF,RORCODE,RORMSG,TMP
"RTN","RORHL081",50,0)
 S ERRCNT=0,ICDFLST="5;6;7;8;9;11;12;13;14;15"
"RTN","RORHL081",51,0)
 S OID="INBED"_CS_"Bedsection Diagnosis"_CS_"VA080"
"RTN","RORHL081",52,0)
 S NODE=$$ROOT^DILFD(45.02,","_RORIEN_",",1)
"RTN","RORHL081",53,0)
 ;---
"RTN","RORHL081",54,0)
 S DATE=$$GET1^DIQ(45,RORIEN_",",2,"I",,"RORMSG")
"RTN","RORHL081",55,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL081",56,0)
 . D DBS^RORERR("RORMSG",-99,,RORDFN,45,RORIEN_",")
"RTN","RORHL081",57,0)
 S (RORBSSD,RORBSED)=$$FM2HL^RORHL7(DATE)
"RTN","RORHL081",58,0)
 ;
"RTN","RORHL081",59,0)
 S DATE=""
"RTN","RORHL081",60,0)
 F  S DATE=$O(@NODE@("AM",DATE))  Q:DATE=""  D
"RTN","RORHL081",61,0)
 . S IEN4502=0
"RTN","RORHL081",62,0)
 . F  S IEN4502=$O(@NODE@("AM",DATE,IEN4502))  Q:IEN4502'>0  D
"RTN","RORHL081",63,0)
 . . S RORBSSD=RORBSED  K RORBUF
"RTN","RORHL081",64,0)
 . . S IENS=IEN4502_","_RORIEN_","
"RTN","RORHL081",65,0)
 . . ;--- Load the data
"RTN","RORHL081",66,0)
 . . D GETS^DIQ(45.02,IENS,"2;10;"_ICDFLST,"EI","RORBUF","RORMSG")
"RTN","RORHL081",67,0)
 . . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL081",68,0)
 . . . D DBS^RORERR("RORMSG",-99,,RORDFN,45.02,IENS)
"RTN","RORHL081",69,0)
 . . ;--- Name of the bed section
"RTN","RORHL081",70,0)
 . . S RORBS=$$ESCAPE^RORHL7($G(RORBUF(45.02,IENS,2,"E")))
"RTN","RORHL081",71,0)
 . . ;--- End date
"RTN","RORHL081",72,0)
 . . S RORBSED=$$FM2HL^RORHL7($G(RORBUF(45.02,IENS,10,"I")))
"RTN","RORHL081",73,0)
 . . ;--- ICD-9 codes
"RTN","RORHL081",74,0)
 . . S RORCODE=""
"RTN","RORHL081",75,0)
 . . F IFL=1:1  S FLD=+$P(ICDFLST,";",IFL)  Q:'FLD  D
"RTN","RORHL081",76,0)
 . . . S TMP=$G(RORBUF(45.02,IENS,FLD,"E"))
"RTN","RORHL081",77,0)
 . . . S:TMP'="" $P(RORCODE,CS,IFL)=TMP
"RTN","RORHL081",78,0)
 . . ;--- Store the segment (if there is at least one ICD-9 code)
"RTN","RORHL081",79,0)
 . . D:RORCODE'="" SETOBX(OID,RORCODE,RORBS,RORBSED,RORBSSD)
"RTN","RORHL081",80,0)
 ;
"RTN","RORHL081",81,0)
 Q ERRCNT
"RTN","RORHL081",82,0)
 ;
"RTN","RORHL081",83,0)
 ;***** DISCHARGE DIAGNOSIS CODES
"RTN","RORHL081",84,0)
DDIAG(RORIEN) ;
"RTN","RORHL081",85,0)
 N ERRCNT,FLD,ICDFLST,IENS,IFL,OID,RORBUF,RORDDIAG,TMP
"RTN","RORHL081",86,0)
 S ERRCNT=0,OID="INDIS"_CS_"Discharge Diagnosis"_CS_"VA080"
"RTN","RORHL081",87,0)
 S ICDFLST="79.16;79.17;79.18;79.19;79.201;79.21;79.22;79.23;79.24"
"RTN","RORHL081",88,0)
 ;--- Load the data
"RTN","RORHL081",89,0)
 S IENS=RORIEN_","
"RTN","RORHL081",90,0)
 D GETS^DIQ(45,IENS,ICDFLST,"E","RORBUF","RORMSG")
"RTN","RORHL081",91,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL081",92,0)
 . D DBS^RORERR("RORMSG",-99,,RORDFN,45,IENS)
"RTN","RORHL081",93,0)
 ;--- ICD-9 codes
"RTN","RORHL081",94,0)
 S RORDDIAG=""
"RTN","RORHL081",95,0)
 F IFL=1:1  S FLD=+$P(ICDFLST,";",IFL)  Q:'FLD  D
"RTN","RORHL081",96,0)
 . S TMP=$G(RORBUF(45,IENS,FLD,"E"))
"RTN","RORHL081",97,0)
 . S:TMP'="" $P(RORDDIAG,CS,IFL)=TMP
"RTN","RORHL081",98,0)
 ;--- Store the segment (if there is at least one ICD-9 code)
"RTN","RORHL081",99,0)
 D:RORDDIAG'="" SETOBX(OID,RORDDIAG)
"RTN","RORHL081",100,0)
 Q ERRCNT
"RTN","RORHL081",101,0)
 ;
"RTN","RORHL081",102,0)
 ;***** OTHER PROCEDURES
"RTN","RORHL081",103,0)
OTRPROC(RORIEN) ;
"RTN","RORHL081",104,0)
 N ERRCNT,FLD,ICDFLST,IEN4505,IENS,IFL,NODE,OID,RORBUF,RORMSG,ROROPBS,ROROPCD,ROROPDTE,TMP
"RTN","RORHL081",105,0)
 S ERRCNT=0,ICDFLST="4;5;6;7;8"
"RTN","RORHL081",106,0)
 S OID="INOTR"_CS_"Other Diagnosis"_CS_"VA080"
"RTN","RORHL081",107,0)
 S NODE=$$ROOT^DILFD(45.05,","_RORIEN_",",1)
"RTN","RORHL081",108,0)
 ;
"RTN","RORHL081",109,0)
 S IEN4505=0
"RTN","RORHL081",110,0)
 F  S IEN4505=$O(@NODE@(IEN4505))  Q:IEN4505'>0  D
"RTN","RORHL081",111,0)
 . S IENS=IEN4505_","_RORIEN_","  K RORBUF
"RTN","RORHL081",112,0)
 . ;--- Load the data
"RTN","RORHL081",113,0)
 . D GETS^DIQ(45.05,IENS,".01;1;"_ICDFLST,"EI","RORBUF","RORMSG")
"RTN","RORHL081",114,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL081",115,0)
 . . D DBS^RORERR("RORMSG",-99,,RORDFN,45.05,IENS)
"RTN","RORHL081",116,0)
 . ;--- Name of the facility
"RTN","RORHL081",117,0)
 . S ROROPBS=$$ESCAPE^RORHL7($G(RORBUF(45.05,IENS,1,"E")))
"RTN","RORHL081",118,0)
 . ;--- Date of the procedure
"RTN","RORHL081",119,0)
 . S ROROPDTE=$$FM2HL^RORHL7($G(RORBUF(45.05,IENS,.01,"I")))
"RTN","RORHL081",120,0)
 . ;--- ICD-9 codes
"RTN","RORHL081",121,0)
 . S ROROPCD=""
"RTN","RORHL081",122,0)
 . F IFL=1:1  S FLD=+$P(ICDFLST,";",IFL)  Q:'FLD  D
"RTN","RORHL081",123,0)
 . . S TMP=$G(RORBUF(45.05,IENS,FLD,"E"))
"RTN","RORHL081",124,0)
 . . S:TMP'="" $P(ROROPCD,CS,IFL)=TMP
"RTN","RORHL081",125,0)
 . ;--- Store the segment (if there is at least one ICD-9 code)
"RTN","RORHL081",126,0)
 . D:ROROPCD'="" SETOBX(OID,ROROPCD,ROROPBS,,ROROPDTE)
"RTN","RORHL081",127,0)
 ;
"RTN","RORHL081",128,0)
 Q ERRCNT
"RTN","RORHL081",129,0)
 ;
"RTN","RORHL081",130,0)
 ;***** PRIMARY DISCHARGE DIAGNOSIS
"RTN","RORHL081",131,0)
PDISCH(IEN) ;
"RTN","RORHL081",132,0)
 N ERRCNT,OID,RORDD,RORMSG,TMP
"RTN","RORHL081",133,0)
 S ERRCNT=0,OID="INPRI"_CS_"Primary Dis. Diagnosis"_CS_"VA080"
"RTN","RORHL081",134,0)
 ;--- Load the data
"RTN","RORHL081",135,0)
 S RORDD=$$GET1^DIQ(45,IEN_",",79,"E",,"RORMSG")
"RTN","RORHL081",136,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL081",137,0)
 . D DBS^RORERR("RORMSG",-99,,RORDFN,45,IEN_",")
"RTN","RORHL081",138,0)
 ;--- Store the segment
"RTN","RORHL081",139,0)
 D:RORDD'="" SETOBX(OID,RORDD)
"RTN","RORHL081",140,0)
 Q ERRCNT
"RTN","RORHL081",141,0)
 ;
"RTN","RORHL081",142,0)
 ;***** PRINCIPAL DIAGNOSIS
"RTN","RORHL081",143,0)
PRIN(IEN) ;
"RTN","RORHL081",144,0)
 N ERRCNT,OID,RORMSG,RORPDIAG,TMP
"RTN","RORHL081",145,0)
 S ERRCNT=0,OID="INAD"_CS_"Admitting Diagnosis"_CS_"VA080"
"RTN","RORHL081",146,0)
 ;--- Load the data
"RTN","RORHL081",147,0)
 S RORPDIAG=$$GET1^DIQ(45,IEN_",",80,"E",,"RORMSG")
"RTN","RORHL081",148,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL081",149,0)
 . D DBS^RORERR("RORMSG",-99,,RORDFN,45,IEN_",")
"RTN","RORHL081",150,0)
 ;--- Store the segment
"RTN","RORHL081",151,0)
 D:RORPDIAG'="" SETOBX(OID,RORPDIAG)
"RTN","RORHL081",152,0)
 Q ERRCNT
"RTN","RORHL081",153,0)
 ;
"RTN","RORHL081",154,0)
 ;*****
"RTN","RORHL081",155,0)
SETOBX(PIECE3,PIECE5,PIECE6,PIECE12,PIECE14) ;
"RTN","RORHL081",156,0)
 N RORSEG
"RTN","RORHL081",157,0)
 S RORSEG="OBX"
"RTN","RORHL081",158,0)
 ;--- OBX-2
"RTN","RORHL081",159,0)
 S $P(RORSEG,HLFS,3)="FT"
"RTN","RORHL081",160,0)
 ;--- OBX-3
"RTN","RORHL081",161,0)
 S $P(RORSEG,HLFS,4)=PIECE3
"RTN","RORHL081",162,0)
 ;--- OBX-5
"RTN","RORHL081",163,0)
 S $P(RORSEG,HLFS,6)=PIECE5
"RTN","RORHL081",164,0)
 ;--- OBX-6
"RTN","RORHL081",165,0)
 S:$G(PIECE6)'="" $P(RORSEG,HLFS,7)=PIECE6
"RTN","RORHL081",166,0)
 ;--- OBX-11
"RTN","RORHL081",167,0)
 S $P(RORSEG,HLFS,12)="F"
"RTN","RORHL081",168,0)
 ;--- OBX-12
"RTN","RORHL081",169,0)
 S:$G(PIECE12)'="" $P(RORSEG,HLFS,13)=PIECE12
"RTN","RORHL081",170,0)
 ;--- OBX-14
"RTN","RORHL081",171,0)
 S:$G(PIECE14)'="" $P(RORSEG,HLFS,15)=PIECE14
"RTN","RORHL081",172,0)
 ;--- Store the segment
"RTN","RORHL081",173,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL081",174,0)
 Q
"RTN","RORHL081",175,0)
 ;
"RTN","RORHL081",176,0)
 ;***** SURGICAL PROCEDURES
"RTN","RORHL081",177,0)
SURGPRO(RORIEN) ;
"RTN","RORHL081",178,0)
 N ERRCNT,FLD,IEN4501,IENS,IFL,NODE,OID,RORBUF,RORMSG,RORSDTE,RORSPCD,SPFLST,TMP
"RTN","RORHL081",179,0)
 S ERRCNT=0,SPFLST="8;9;10;11;12"
"RTN","RORHL081",180,0)
 S OID="INSURG"_CS_"Surgical Procedures"_CS_"VA080"
"RTN","RORHL081",181,0)
 S NODE=$$ROOT^DILFD(45.01,","_RORIEN_",",1)
"RTN","RORHL081",182,0)
 ;
"RTN","RORHL081",183,0)
 S IEN4501=0
"RTN","RORHL081",184,0)
 F  S IEN4501=$O(@NODE@(IEN4501))  Q:IEN4501'>0  D
"RTN","RORHL081",185,0)
 . S IENS=IEN4501_","_RORIEN_","  K RORBUF
"RTN","RORHL081",186,0)
 . ;--- Load the data
"RTN","RORHL081",187,0)
 . D GETS^DIQ(45.01,IENS,".01;"_SPFLST,"EI","RORBUF","RORMSG")
"RTN","RORHL081",188,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL081",189,0)
 . . D DBS^RORERR("RORMSG",-99,,RORDFN,45.01,IENS)
"RTN","RORHL081",190,0)
 . ;--- Date of the procedure
"RTN","RORHL081",191,0)
 . S RORSDTE=$$FM2HL^RORHL7($G(RORBUF(45.01,IENS,.01,"I")))
"RTN","RORHL081",192,0)
 . ;--- Procedure codes
"RTN","RORHL081",193,0)
 . S RORSPCD=""
"RTN","RORHL081",194,0)
 . F IFL=1:1  S FLD=+$P(SPFLST,";",IFL)  Q:'FLD  D
"RTN","RORHL081",195,0)
 . . S TMP=$G(RORBUF(45.01,IENS,FLD,"E"))
"RTN","RORHL081",196,0)
 . . S:TMP'="" $P(RORSPCD,CS,IFL)=TMP
"RTN","RORHL081",197,0)
 . ;--- Store the segment (if there is at least one code)
"RTN","RORHL081",198,0)
 . D:RORSPCD'="" SETOBX(OID,RORSPCD,,,RORSDTE)
"RTN","RORHL081",199,0)
 ;
"RTN","RORHL081",200,0)
 Q ERRCNT
"RTN","RORHL09")
0^41^B56024606
"RTN","RORHL09",1,0)
RORHL09 ;HOIFO/BH - HL7 OUTPATIENT DATA: PV1,OBR,OBX ; 1/30/04 3:46pm
"RTN","RORHL09",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL09",3,0)
 ;
"RTN","RORHL09",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL09",5,0)
 ;
"RTN","RORHL09",6,0)
 ; #1889     Use of the ENCEVENT^PXKENC API
"RTN","RORHL09",7,0)
 ; #3094     Read access to the 'AA' x-ref in the VISIT file (#9000010)
"RTN","RORHL09",8,0)
 ; #93       Get stop code from the file #44 (controlled)
"RTN","RORHL09",9,0)
 ; #10060    Read access to the file #200 (supported)
"RTN","RORHL09",10,0)
 ; #2815     Get CPT code from the file #81 (supported)
"RTN","RORHL09",11,0)
 ; #10082    Get ICD-9 code from the file #80 (supported)
"RTN","RORHL09",12,0)
 ;
"RTN","RORHL09",13,0)
 Q
"RTN","RORHL09",14,0)
 ;
"RTN","RORHL09",15,0)
 ;***** OUTPATIENT DATA SEGMENT BUILDER
"RTN","RORHL09",16,0)
 ;
"RTN","RORHL09",17,0)
 ; RORDFN        DFN of Patient Record in File #2
"RTN","RORHL09",18,0)
 ;
"RTN","RORHL09",19,0)
 ; .DXDTS        Reference to a local variable where the
"RTN","RORHL09",20,0)
 ;               data extraction time frames are stored.
"RTN","RORHL09",21,0)
 ;
"RTN","RORHL09",22,0)
 ; RORTY         Set to either "PV1" or "OBR"
"RTN","RORHL09",23,0)
 ;
"RTN","RORHL09",24,0)
 ; Return Values:
"RTN","RORHL09",25,0)
 ;       <0  Error Code
"RTN","RORHL09",26,0)
 ;        0  Ok
"RTN","RORHL09",27,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL09",28,0)
 ;
"RTN","RORHL09",29,0)
 ; The function uses the ^TMP("RORHL08",$J) and ^TMP("PXKENC",$J)
"RTN","RORHL09",30,0)
 ; global nodes.
"RTN","RORHL09",31,0)
 ;
"RTN","RORHL09",32,0)
EN1(RORDFN,DXDTS,RORTY) ;
"RTN","RORHL09",33,0)
 N ERRCNT,PIEN,PV1CNT,RC
"RTN","RORHL09",34,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL09",35,0)
 S (ERRCNT,RC)=0
"RTN","RORHL09",36,0)
 ;
"RTN","RORHL09",37,0)
 ;--- PV1 Segments
"RTN","RORHL09",38,0)
 I RORTY="PV1"  K ^TMP("PXKENC",$J),^TMP("RORHL09",$J)  D
"RTN","RORHL09",39,0)
 . N IDX,INVDT,ROREND
"RTN","RORHL09",40,0)
 . S (IDX,PV1CNT)=0
"RTN","RORHL09",41,0)
 . F  S IDX=$O(DXDTS(2,IDX))  Q:IDX'>0  D  Q:RC<0
"RTN","RORHL09",42,0)
 . . S INVDT=9999999-$$FMADD^XLFDT($P(DXDTS(2,IDX),U)\1,-1)
"RTN","RORHL09",43,0)
 . . S ROREND=9999999-$P(DXDTS(2,IDX),U,2)
"RTN","RORHL09",44,0)
 . . F  S INVDT=$O(^AUPNVSIT("AA",RORDFN,INVDT),-1)  Q:'INVDT!(INVDT'>ROREND)  D
"RTN","RORHL09",45,0)
 . . . S PIEN=""
"RTN","RORHL09",46,0)
 . . . F  S PIEN=$O(^AUPNVSIT("AA",RORDFN,INVDT,PIEN),-1)  Q:'PIEN  D
"RTN","RORHL09",47,0)
 . . . . S TMP=$$PV1(PIEN,RORDFN)
"RTN","RORHL09",48,0)
 . . . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL09",49,0)
 . . . . ;--- Reference for the corresponding OBR segment
"RTN","RORHL09",50,0)
 . . . . S:TMP'="S" PV1CNT=PV1CNT+1,^TMP("RORHL09",$J,PV1CNT)=PIEN
"RTN","RORHL09",51,0)
 ;
"RTN","RORHL09",52,0)
 ;--- OBR and OBX Segments
"RTN","RORHL09",53,0)
 I RORTY="OBR"  D  K ^TMP("PXKENC",$J),^TMP("RORHL09",$J)
"RTN","RORHL09",54,0)
 . S PV1CNT=0
"RTN","RORHL09",55,0)
 . F  S PV1CNT=$O(^TMP("RORHL09",$J,PV1CNT))  Q:PV1CNT'>0  D
"RTN","RORHL09",56,0)
 . . S PIEN=+$G(^TMP("RORHL09",$J,PV1CNT))  Q:PIEN'>0
"RTN","RORHL09",57,0)
 . . ;---
"RTN","RORHL09",58,0)
 . . S TMP=$$OBR(PIEN,RORDFN)
"RTN","RORHL09",59,0)
 . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL09",60,0)
 . . ;---
"RTN","RORHL09",61,0)
 . . S TMP=$$OBX(PIEN,RORDFN)
"RTN","RORHL09",62,0)
 . . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL09",63,0)
 ;
"RTN","RORHL09",64,0)
 ;--- Check for errors
"RTN","RORHL09",65,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL09",66,0)
 ;
"RTN","RORHL09",67,0)
 ;***** PV1 SEGMENT BUILDER (OUTPATIENT)
"RTN","RORHL09",68,0)
 ;
"RTN","RORHL09",69,0)
 ; RORIEN        IEN of file #9000010
"RTN","RORHL09",70,0)
 ; RORDFN        DFN of Patient Record in File #2
"RTN","RORHL09",71,0)
 ;
"RTN","RORHL09",72,0)
 ; Return Values:
"RTN","RORHL09",73,0)
 ;       <0  Error Code
"RTN","RORHL09",74,0)
 ;        0  Ok
"RTN","RORHL09",75,0)
 ;      "S"  No visit data
"RTN","RORHL09",76,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL09",77,0)
 ;
"RTN","RORHL09",78,0)
PV1(RORIEN,RORDFN) ;
"RTN","RORHL09",79,0)
 N BUF,CLASS,CS,ERRCNT,IENS,KK4,RC,REC,REP,RORCLIN,RORMSG,PRV,TMP,TMP1,VST0
"RTN","RORHL09",80,0)
 S (ERRCNT,RC)=0
"RTN","RORHL09",81,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL09",82,0)
 S CS=$E(HLECH,1),REP=$E(HLECH,2,2)
"RTN","RORHL09",83,0)
 ;
"RTN","RORHL09",84,0)
 ;--- Get Visit Data
"RTN","RORHL09",85,0)
 D ENCEVENT^PXKENC(RORIEN,1)
"RTN","RORHL09",86,0)
 Q:$D(^TMP("PXKENC",$J,RORIEN))<10 "S"
"RTN","RORHL09",87,0)
 S VST0=$G(^TMP("PXKENC",$J,RORIEN,"VST",RORIEN,0))
"RTN","RORHL09",88,0)
 ;
"RTN","RORHL09",89,0)
 ;--- Do not send visits with the following service categories: Daily
"RTN","RORHL09",90,0)
 ;--- Hospitalization (D), Ancillary (X), Chart (C), Not Found (N),
"RTN","RORHL09",91,0)
 ;                    (E), Event Historical, Hospitalization (H).
"RTN","RORHL09",92,0)
 Q:"HEDXNC"[$P(VST0,U,7) "S"
"RTN","RORHL09",93,0)
 ;
"RTN","RORHL09",94,0)
 ;--- Initialize the segment
"RTN","RORHL09",95,0)
 S RORSEG="PV1"
"RTN","RORHL09",96,0)
 ;
"RTN","RORHL09",97,0)
 ;--- PV1-2 - Patient Class
"RTN","RORHL09",98,0)
 S $P(RORSEG,HLFS,3)="O"  ; O - Outpatient
"RTN","RORHL09",99,0)
 ;
"RTN","RORHL09",100,0)
 ;--- PV1-3 - Assigned Patient Location
"RTN","RORHL09",101,0)
 S RORCLIN=+$P(VST0,U,22),BUF=""
"RTN","RORHL09",102,0)
 ;S BUF=$E($P($$SITE^VASITE,U,3),1,3)  ; Strip the suffix
"RTN","RORHL09",103,0)
 ;Q:BUF'>0 $$ERROR^RORERR(-100,,,,"No station number","$$SITE^VASITE")
"RTN","RORHL09",104,0)
 I RORCLIN>0  D
"RTN","RORHL09",105,0)
 . S IENS=RORCLIN_","
"RTN","RORHL09",106,0)
 . S TMP=$$GET1^DIQ(44,IENS,3.5,"I")  Q:TMP'>0
"RTN","RORHL09",107,0)
 . S BUF=$$GET1^DIQ(40.8,TMP,1)       Q:BUF=""
"RTN","RORHL09",108,0)
 . ;---
"RTN","RORHL09",109,0)
 . S TMP=$$GET1^DIQ(44,IENS,8,"I",,"RORMSG")
"RTN","RORHL09",110,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL09",111,0)
 . . D DBS^RORERR("RORMSG",-99,,RORDFN,44,IENS)
"RTN","RORHL09",112,0)
 . S TMP1=$$GET1^DIQ(40.7,TMP_",",1,"I",,"RORMSG")
"RTN","RORHL09",113,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL09",114,0)
 . . D DBS^RORERR("RORMSG",-99,,RORDFN,40.7,TMP_",")
"RTN","RORHL09",115,0)
 . S $P(BUF,CS,6)=TMP1
"RTN","RORHL09",116,0)
 Q:$P(BUF,CS,6)="" "S"  ; No Stop Code
"RTN","RORHL09",117,0)
 S $P(RORSEG,HLFS,4)=BUF
"RTN","RORHL09",118,0)
 ;
"RTN","RORHL09",119,0)
 ; PV1-4  - Admission Type
"RTN","RORHL09",120,0)
 S TMP=$P($G(^TMP("PXKENC",$J,RORIEN,"VST",RORIEN,150)),U,3)
"RTN","RORHL09",121,0)
 S $P(RORSEG,HLFS,5)=TMP
"RTN","RORHL09",122,0)
 ;
"RTN","RORHL09",123,0)
 ;--- PV1-7 - Attending Physician
"RTN","RORHL09",124,0)
 S (KK4,BUF)=""
"RTN","RORHL09",125,0)
 F  S KK4=$O(^TMP("PXKENC",$J,RORIEN,"PRV",KK4))  Q:KK4=""  D
"RTN","RORHL09",126,0)
 . S REC=$G(^TMP("PXKENC",$J,RORIEN,"PRV",KK4,0))
"RTN","RORHL09",127,0)
 . S PRV=+$P(REC,U)  Q:(PRV'>0)!($P(REC,U,4)'="P")
"RTN","RORHL09",128,0)
 . S CLASS=$$GET1^DIQ(200,PRV_",",53.5,"I",,"RORMSG")
"RTN","RORHL09",129,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL09",130,0)
 . . D DBS^RORERR("RORMSG",-99,,RORDFN,200,PRV_",")
"RTN","RORHL09",131,0)
 . S:CLASS>0 $P(PRV,CS,13)=CLASS
"RTN","RORHL09",132,0)
 . S BUF=BUF_REP_PRV
"RTN","RORHL09",133,0)
 S $P(RORSEG,HLFS,8)=$P(BUF,REP,2,999)
"RTN","RORHL09",134,0)
 ;
"RTN","RORHL09",135,0)
 ;--- PV1-19 - Visit Number (KEY)
"RTN","RORHL09",136,0)
 S $P(RORSEG,HLFS,20)=RORIEN
"RTN","RORHL09",137,0)
 ;
"RTN","RORHL09",138,0)
 ;--- PV1-44 - Admit Date/Time (KEY)
"RTN","RORHL09",139,0)
 S TMP=$$FMTHL7^XLFDT($P(VST0,U))
"RTN","RORHL09",140,0)
 I TMP'>0  D  Q RC
"RTN","RORHL09",141,0)
 . S RC=$$ERROR^RORERR(-100,,,,"No admission date","ENCEVENT^PXKENC")
"RTN","RORHL09",142,0)
 S $P(RORSEG,HLFS,45)=TMP
"RTN","RORHL09",143,0)
 ;
"RTN","RORHL09",144,0)
 ;--- PV1-51 - Visit Indicator
"RTN","RORHL09",145,0)
 S TMP=$P(VST0,U,11)
"RTN","RORHL09",146,0)
 S $P(RORSEG,HLFS,51)=$S(TMP'="":TMP,1:0)
"RTN","RORHL09",147,0)
 ;
"RTN","RORHL09",148,0)
 ;--- Store the segment
"RTN","RORHL09",149,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL09",150,0)
 Q ERRCNT
"RTN","RORHL09",151,0)
 ;
"RTN","RORHL09",152,0)
 ;***** OBR SEGMENT BUILDER (OUTPATIENT)
"RTN","RORHL09",153,0)
 ;
"RTN","RORHL09",154,0)
 ; RORIEN        IEN of file #9000010
"RTN","RORHL09",155,0)
 ; RORDFN        DFN of Patient Record in File #2
"RTN","RORHL09",156,0)
 ;
"RTN","RORHL09",157,0)
 ; Return Values:
"RTN","RORHL09",158,0)
 ;       <0  Error Code
"RTN","RORHL09",159,0)
 ;        0  Ok
"RTN","RORHL09",160,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL09",161,0)
 ;
"RTN","RORHL09",162,0)
OBR(RORIEN,RORDFN) ;
"RTN","RORHL09",163,0)
 N BUF,BUF1,CS,ERRCNT,RC,RORCLIN,RORDIV,RORSEG,TMP
"RTN","RORHL09",164,0)
 S (ERRCNT,RC)=0
"RTN","RORHL09",165,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL09",166,0)
 S CS=$E(HLECH,1)
"RTN","RORHL09",167,0)
 ;
"RTN","RORHL09",168,0)
 ;--- Initialize the segment
"RTN","RORHL09",169,0)
 S RORSEG="OBR"
"RTN","RORHL09",170,0)
 ;
"RTN","RORHL09",171,0)
 ;--- OBR-3 - Order Number
"RTN","RORHL09",172,0)
 S $P(RORSEG,HLFS,4)=RORIEN
"RTN","RORHL09",173,0)
 ;
"RTN","RORHL09",174,0)
 ;--- OBR-4 - Universal Service ID
"RTN","RORHL09",175,0)
 S $P(RORSEG,HLFS,5)="OP"_CS_"Outpatient"_CS_"C4"
"RTN","RORHL09",176,0)
 ;
"RTN","RORHL09",177,0)
 S TMP=$G(^TMP("PXKENC",$J,RORIEN,"VST",RORIEN,0))
"RTN","RORHL09",178,0)
 S RORCLIN=$P(TMP,U,22)
"RTN","RORHL09",179,0)
 ;
"RTN","RORHL09",180,0)
 ;--- OBR-7 - Visit Date (KEY)
"RTN","RORHL09",181,0)
 S TMP=$$FMTHL7^XLFDT($P(TMP,U))
"RTN","RORHL09",182,0)
 Q:TMP'>0 $$ERROR^RORERR(-100,,,,"No visit date","ENCEVENT^PXKENC")
"RTN","RORHL09",183,0)
 S $P(RORSEG,HLFS,8)=TMP
"RTN","RORHL09",184,0)
 ;
"RTN","RORHL09",185,0)
 ;--- OBR-24 - Diagnostic Service ID
"RTN","RORHL09",186,0)
 S $P(RORSEG,HLFS,25)="PHY"
"RTN","RORHL09",187,0)
 ;
"RTN","RORHL09",188,0)
 ;--- OBR-44 - Division
"RTN","RORHL09",189,0)
 S BUF1=$$SITE1^RORUTL03(CS)
"RTN","RORHL09",190,0)
 I RORCLIN>0 D
"RTN","RORHL09",191,0)
 . S RORDIV=$$GET1^DIQ(44,RORCLIN,3.5,"I")
"RTN","RORHL09",192,0)
 . Q:RORDIV=""
"RTN","RORHL09",193,0)
 . S RORDIV=$$GET1^DIQ(40.8,RORDIV,1)
"RTN","RORHL09",194,0)
 . Q:RORDIV=""
"RTN","RORHL09",195,0)
 . S BUF1=RORDIV
"RTN","RORHL09",196,0)
 S $P(RORSEG,HLFS,45)=BUF1
"RTN","RORHL09",197,0)
 ;
"RTN","RORHL09",198,0)
 ;--- Store the segment
"RTN","RORHL09",199,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL09",200,0)
 Q ERRCNT
"RTN","RORHL09",201,0)
 ;
"RTN","RORHL09",202,0)
 ;***** OBX SEGMENT BUILDER (OUTPATIENT)
"RTN","RORHL09",203,0)
 ;
"RTN","RORHL09",204,0)
 ; RORIEN        IEN of file #9000010
"RTN","RORHL09",205,0)
 ; RORDFN        DFN of Patient Record in File #2
"RTN","RORHL09",206,0)
 ;
"RTN","RORHL09",207,0)
 ; Return Values:
"RTN","RORHL09",208,0)
 ;       <0  Error Code
"RTN","RORHL09",209,0)
 ;        0  Ok
"RTN","RORHL09",210,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL09",211,0)
 ;
"RTN","RORHL09",212,0)
OBX(RORIEN,RORDFN) ;
"RTN","RORHL09",213,0)
 N CS,ERRCNT,RC,RORLST,RORMSG,RORSEG,TMP
"RTN","RORHL09",214,0)
 S (ERRCNT,RC)=0
"RTN","RORHL09",215,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL09",216,0)
 S CS=$E(HLECH)
"RTN","RORHL09",217,0)
 ;
"RTN","RORHL09",218,0)
 ;--- Procedures
"RTN","RORHL09",219,0)
 I $D(^TMP("PXKENC",$J,RORIEN,"CPT"))>1  D  Q:RC<0 RC
"RTN","RORHL09",220,0)
 . S RC=$$PROCS()  S:RC ERRCNT=ERRCNT+1
"RTN","RORHL09",221,0)
 ;--- Diagnosis codes
"RTN","RORHL09",222,0)
 I $D(^TMP("PXKENC",$J,RORIEN,"POV"))>1  D  Q:RC<0 RC
"RTN","RORHL09",223,0)
 . S RC=$$DIAGS()  S:RC ERRCNT=ERRCNT+1
"RTN","RORHL09",224,0)
 ;
"RTN","RORHL09",225,0)
 Q ERRCNT
"RTN","RORHL09",226,0)
 ; 
"RTN","RORHL09",227,0)
 ;***** PROCESSES PROCEDURES
"RTN","RORHL09",228,0)
PROCS() ;
"RTN","RORHL09",229,0)
 N CLASS,ERRCNT,IEN,K5,OID,PROC,PRV,REC,RORMSG,TMP
"RTN","RORHL09",230,0)
 S ERRCNT=0
"RTN","RORHL09",231,0)
 S OID="OCPT"_CS_"Procedures"_CS_"VA080"
"RTN","RORHL09",232,0)
 S K5=""
"RTN","RORHL09",233,0)
 F  S K5=$O(^TMP("PXKENC",$J,RORIEN,"CPT",K5))  Q:K5=""  D
"RTN","RORHL09",234,0)
 . S REC=$G(^TMP("PXKENC",$J,RORIEN,"CPT",K5,0))
"RTN","RORHL09",235,0)
 . ;---
"RTN","RORHL09",236,0)
 . S IEN=+$P(REC,U)  Q:IEN'>0
"RTN","RORHL09",237,0)
 . S PROC=$$GET1^DIQ(81,IEN_",",.01,"E",,"RORMSG")
"RTN","RORHL09",238,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL09",239,0)
 . . D DBS^RORERR("RORMSG",-99,,RORDFN,81,IEN_",")
"RTN","RORHL09",240,0)
 . Q:PROC=""
"RTN","RORHL09",241,0)
 . ;---
"RTN","RORHL09",242,0)
 . S PRV=+$P($G(^TMP("PXKENC",$J,RORIEN,"CPT",K5,12)),U,4)
"RTN","RORHL09",243,0)
 . Q:PRV'>0
"RTN","RORHL09",244,0)
 . ;---
"RTN","RORHL09",245,0)
 . S CLASS=$$GET1^DIQ(200,PRV_",",53.5,"I",,"RORMSG")
"RTN","RORHL09",246,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL09",247,0)
 . . D DBS^RORERR("RORMSG",-99,,RORDFN,200,PRV_",")
"RTN","RORHL09",248,0)
 . S:CLASS>0 $P(PRV,CS,13)=CLASS
"RTN","RORHL09",249,0)
 . ;---
"RTN","RORHL09",250,0)
 . D SETOBX(OID,PROC,PRV)
"RTN","RORHL09",251,0)
 Q ERRCNT
"RTN","RORHL09",252,0)
 ;
"RTN","RORHL09",253,0)
 ;***** PROCESSES DIAGNOSIS CODES
"RTN","RORHL09",254,0)
DIAGS() ;
"RTN","RORHL09",255,0)
 N DIAG,ERRCNT,IEN,K5,OID,REC,RORMSG,TMP
"RTN","RORHL09",256,0)
 S ERRCNT=0
"RTN","RORHL09",257,0)
 S OID="OICD9"_CS_"Diagnosis"_CS_"VA080"
"RTN","RORHL09",258,0)
 S K5=""
"RTN","RORHL09",259,0)
 F  S K5=$O(^TMP("PXKENC",$J,RORIEN,"POV",K5))  Q:K5=""  D
"RTN","RORHL09",260,0)
 . S REC=^TMP("PXKENC",$J,RORIEN,"POV",K5,0)
"RTN","RORHL09",261,0)
 . ;---
"RTN","RORHL09",262,0)
 . S IEN=+$P(REC,U)  Q:IEN'>0
"RTN","RORHL09",263,0)
 . S DIAG=$$GET1^DIQ(80,IEN_",",.01,"E",,"RORMSG")
"RTN","RORHL09",264,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL09",265,0)
 . . D DBS^RORERR("RORMSG",-99,,RORDFN,80,IEN_",")
"RTN","RORHL09",266,0)
 . ;---
"RTN","RORHL09",267,0)
 . D:DIAG'="" SETOBX(OID,DIAG)
"RTN","RORHL09",268,0)
 Q ERRCNT
"RTN","RORHL09",269,0)
 ;
"RTN","RORHL09",270,0)
 ;***** GENERATES OBX SEGMENT
"RTN","RORHL09",271,0)
SETOBX(PIECE3,PIECE5,PIECE16) ;
"RTN","RORHL09",272,0)
 N RORSEG
"RTN","RORHL09",273,0)
 S RORSEG="OBX"
"RTN","RORHL09",274,0)
 ;--- OBX-2 - Value Type
"RTN","RORHL09",275,0)
 S $P(RORSEG,HLFS,3)="FT"
"RTN","RORHL09",276,0)
 ;--- OBX-3 - Obervation Identifier
"RTN","RORHL09",277,0)
 S $P(RORSEG,HLFS,4)=PIECE3
"RTN","RORHL09",278,0)
 ;--- OBX-5 - Obervation Value
"RTN","RORHL09",279,0)
 S $P(RORSEG,HLFS,6)=PIECE5
"RTN","RORHL09",280,0)
 ;--- OBX-11 - Obervation Result Status
"RTN","RORHL09",281,0)
 S $P(RORSEG,HLFS,12)="F"
"RTN","RORHL09",282,0)
 ;--- OBX-16 - Responsible Observer
"RTN","RORHL09",283,0)
 S:$G(PIECE16)'="" $P(RORSEG,HLFS,17)=PIECE16
"RTN","RORHL09",284,0)
 ;--- Store the segment
"RTN","RORHL09",285,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL09",286,0)
 Q
"RTN","RORHL10")
0^42^B59986020
"RTN","RORHL10",1,0)
RORHL10 ;HOIFO/BH - HL7 SURGICAL PATHOLOGY DATA: OBR,OBX ; 7/21/03 12:50pm
"RTN","RORHL10",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL10",3,0)
 ;
"RTN","RORHL10",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL10",5,0)
 ;
"RTN","RORHL10",6,0)
 ; #DBIA67-C     Read access to the multiple #63.08
"RTN","RORHL10",7,0)
 ; #2503         LRDFN^LR7OR1 (controlled)
"RTN","RORHL10",8,0)
 ;
"RTN","RORHL10",9,0)
 ; #Not released   $$SPATH^LA7UTL03
"RTN","RORHL10",10,0)
 ;
"RTN","RORHL10",11,0)
 Q
"RTN","RORHL10",12,0)
 ;
"RTN","RORHL10",13,0)
 ;***** SEARCHES FOR SURGICAL PATHOLOGY DATA
"RTN","RORHL10",14,0)
 ;
"RTN","RORHL10",15,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL10",16,0)
 ;
"RTN","RORHL10",17,0)
 ; RORSTDT       Start Date (FileMan)
"RTN","RORHL10",18,0)
 ; RORENDT       End Date   (FileMan)
"RTN","RORHL10",19,0)
 ;
"RTN","RORHL10",20,0)
 ; [CDSMODE]     Search the data by:
"RTN","RORHL10",21,0)
 ;                 0  completion/result date (default)
"RTN","RORHL10",22,0)
 ;                 1  specimen collection date
"RTN","RORHL10",23,0)
 ;
"RTN","RORHL10",24,0)
 ; Return Values:
"RTN","RORHL10",25,0)
 ;       <0  Error code
"RTN","RORHL10",26,0)
 ;        0  Ok
"RTN","RORHL10",27,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL10",28,0)
 ;
"RTN","RORHL10",29,0)
EN1(RORDFN,RORSTDT,RORENDT,CDSMODE) ;
"RTN","RORHL10",30,0)
 N ERRCNT,LRDFN,RC
"RTN","RORHL10",31,0)
 S (ERRCNT,RC)=0
"RTN","RORHL10",32,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL10",33,0)
 ;
"RTN","RORHL10",34,0)
 S LRDFN=+$$LRDFN^LR7OR1(RORDFN)  Q:'LRDFN 0
"RTN","RORHL10",35,0)
 ;
"RTN","RORHL10",36,0)
 S RC=$S($G(CDSMODE):$$CD(),1:$$RAD())
"RTN","RORHL10",37,0)
 S:RC ERRCNT=ERRCNT+1
"RTN","RORHL10",38,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL10",39,0)
 ;
"RTN","RORHL10",40,0)
 ;***** SEARCHES BY SPECIMEN COLLECTION DATE
"RTN","RORHL10",41,0)
CD() ;
"RTN","RORHL10",42,0)
 N ENDT,ERRCNT,IDT,STDT
"RTN","RORHL10",43,0)
 S ERRCNT=0
"RTN","RORHL10",44,0)
 S STDT=9999999-RORSTDT
"RTN","RORHL10",45,0)
 S ENDT=9999999-RORENDT
"RTN","RORHL10",46,0)
 ;---
"RTN","RORHL10",47,0)
 S IDT=$O(^LR(LRDFN,"SP",STDT))
"RTN","RORHL10",48,0)
 F  S IDT=$O(^LR(LRDFN,"SP",IDT),-1)  Q:'IDT!(IDT'>ENDT)  D
"RTN","RORHL10",49,0)
 . S:$$OBROBX(IDT,LRDFN) ERRCNT=ERRCNT+1
"RTN","RORHL10",50,0)
 Q ERRCNT
"RTN","RORHL10",51,0)
 ;
"RTN","RORHL10",52,0)
 ;***** SEARCHES BY COMPLETION (RESULT) DATE
"RTN","RORHL10",53,0)
RAD() ;
"RTN","RORHL10",54,0)
 N ERRCNT,IDT,RCDT
"RTN","RORHL10",55,0)
 S ERRCNT=0
"RTN","RORHL10",56,0)
 ;---
"RTN","RORHL10",57,0)
 S IDT=0
"RTN","RORHL10",58,0)
 F  S IDT=$O(^LR(LRDFN,"SP",IDT))  Q:IDT'>0  D
"RTN","RORHL10",59,0)
 . S RCDT=$P($G(^LR(LRDFN,"SP",IDT,0)),U,3)
"RTN","RORHL10",60,0)
 . I RCDT'<RORSTDT,RCDT<RORENDT  S:$$OBROBX(IDT,LRDFN) ERRCNT=ERRCNT+1
"RTN","RORHL10",61,0)
 Q ERRCNT
"RTN","RORHL10",62,0)
 ; 
"RTN","RORHL10",63,0)
 ;***** CREATES OBR AND OBX SEGMENTS
"RTN","RORHL10",64,0)
OBROBX(RORIDT,LRDFN) ;
"RTN","RORHL10",65,0)
 N ERRCNT,RC
"RTN","RORHL10",66,0)
 S ERRCNT=0
"RTN","RORHL10",67,0)
 ;---
"RTN","RORHL10",68,0)
 S RC=$$OBR(RORIDT_","_LRDFN_",")
"RTN","RORHL10",69,0)
 I RC  S ERRCNT=ERRCNT+1  Q:RC<0 RC
"RTN","RORHL10",70,0)
 ;---
"RTN","RORHL10",71,0)
 S RC=$$OBX(LRDFN,RORIDT)
"RTN","RORHL10",72,0)
 I RC  S ERRCNT=ERRCNT+1  Q:RC<0 RC
"RTN","RORHL10",73,0)
 ;---
"RTN","RORHL10",74,0)
 Q ERRCNT
"RTN","RORHL10",75,0)
 ;
"RTN","RORHL10",76,0)
 ;***** OBR SEGMENT BUILDER
"RTN","RORHL10",77,0)
 ;
"RTN","RORHL10",78,0)
 ; RORIENS       IENS of SP Entry
"RTN","RORHL10",79,0)
 ;
"RTN","RORHL10",80,0)
 ; Return Values:
"RTN","RORHL10",81,0)
 ;       <0  Error code
"RTN","RORHL10",82,0)
 ;        0  Ok
"RTN","RORHL10",83,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL10",84,0)
 ;
"RTN","RORHL10",85,0)
OBR(RORIENS) ;
"RTN","RORHL10",86,0)
 N CS,ERRCNT,FLDS,IEN,RC,RORMSG,ROROUT,RORSEG,TMP
"RTN","RORHL10",87,0)
 S (ERRCNT,RC)=0
"RTN","RORHL10",88,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL10",89,0)
 S CS=$E(HLECH,1)
"RTN","RORHL10",90,0)
 ;--- Check the parameters
"RTN","RORHL10",91,0)
 S:$E(RORIENS,$L(RORIENS))'="," RORIENS=RORIENS_","
"RTN","RORHL10",92,0)
 ;
"RTN","RORHL10",93,0)
 ;--- Load the data
"RTN","RORHL10",94,0)
 S FLDS=".01;.03;.06;.07;.08"
"RTN","RORHL10",95,0)
 D GETS^DIQ(63.08,RORIENS,FLDS,"IE","ROROUT","RORMSG")
"RTN","RORHL10",96,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL10",97,0)
 . D DBS^RORERR("RORMSG",-9,,,63.08,RORIENS)
"RTN","RORHL10",98,0)
 ;
"RTN","RORHL10",99,0)
 ;--- Initialize the segment
"RTN","RORHL10",100,0)
 S RORSEG="OBR"
"RTN","RORHL10",101,0)
 ;
"RTN","RORHL10",102,0)
 ;--- OBR-3 - Surgical Pathology Acc #
"RTN","RORHL10",103,0)
 I $G(ROROUT(63.08,RORIENS,.06,"E"))=""  D  Q RC
"RTN","RORHL10",104,0)
 . S RC=$$ERROR^RORERR(-95,,,,63.08,RORIENS,.06)
"RTN","RORHL10",105,0)
 S $P(RORSEG,HLFS,4)=ROROUT(63.08,RORIENS,.06,"E")
"RTN","RORHL10",106,0)
 ;
"RTN","RORHL10",107,0)
 ;--- OBR-4 - SP CPT Code
"RTN","RORHL10",108,0)
 S TMP="88300"
"RTN","RORHL10",109,0)
 S $P(TMP,CS,2)="LEVEL I - SURGICAL PAT"
"RTN","RORHL10",110,0)
 S $P(TMP,CS,3)="C4"
"RTN","RORHL10",111,0)
 S $P(RORSEG,HLFS,5)=TMP
"RTN","RORHL10",112,0)
 ;
"RTN","RORHL10",113,0)
 ;--- OBR-7 - Date/Time Specimen Taken
"RTN","RORHL10",114,0)
 S TMP=$$FMTHL7^XLFDT($G(ROROUT(63.08,RORIENS,.01,"I")))
"RTN","RORHL10",115,0)
 Q:TMP'>0 $$ERROR^RORERR(-95,,,,63.08,RORIENS,.01)
"RTN","RORHL10",116,0)
 S $P(RORSEG,HLFS,8)=TMP
"RTN","RORHL10",117,0)
 ;
"RTN","RORHL10",118,0)
 ;--- OBR-8 - Date Report Completed
"RTN","RORHL10",119,0)
 S TMP=$G(ROROUT(63.08,RORIENS,.03,"I"))
"RTN","RORHL10",120,0)
 S $P(RORSEG,HLFS,9)=$$FM2HL^RORHL7(TMP)
"RTN","RORHL10",121,0)
 ;
"RTN","RORHL10",122,0)
 ;--- OBR-16 - Surgeon/Physican
"RTN","RORHL10",123,0)
 S $P(RORSEG,HLFS,17)=$G(ROROUT(63.08,RORIENS,.07,"I"))
"RTN","RORHL10",124,0)
 ;
"RTN","RORHL10",125,0)
 ;--- OBR-24 - Service Section ID
"RTN","RORHL10",126,0)
 S $P(RORSEG,HLFS,25)="SP"
"RTN","RORHL10",127,0)
 ;
"RTN","RORHL10",128,0)
 ; OBR-44 - Divsion
"RTN","RORHL10",129,0)
 S TMP=$G(ROROUT(63.08,RORIENS,.08,"I"))
"RTN","RORHL10",130,0)
 S IEN=$S(TMP'="":+$O(^SC("B",TMP,0)),1:0)
"RTN","RORHL10",131,0)
 S $P(RORSEG,HLFS,45)=$$DIV44^RORHLUT1(IEN,1,CS)
"RTN","RORHL10",132,0)
 ;
"RTN","RORHL10",133,0)
 ;--- Store the segment
"RTN","RORHL10",134,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL10",135,0)
 Q ERRCNT
"RTN","RORHL10",136,0)
 ;
"RTN","RORHL10",137,0)
 ;***** OBX SEGMENT BUILDER
"RTN","RORHL10",138,0)
 ;
"RTN","RORHL10",139,0)
 ; LRDFN         Patient Lab DFN
"RTN","RORHL10",140,0)
 ; RORIENS       IENS of SP Entry
"RTN","RORHL10",141,0)
 ;
"RTN","RORHL10",142,0)
 ; Return Values:
"RTN","RORHL10",143,0)
 ;       <0  Error code
"RTN","RORHL10",144,0)
 ;        0  Ok
"RTN","RORHL10",145,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL10",146,0)
 ;
"RTN","RORHL10",147,0)
OBX(LRDFN,RORIENS) ;
"RTN","RORHL10",148,0)
 N CS,ERRCNT,RC,RORMSG,ROROUT,RORSEG,RORTMP,TMP
"RTN","RORHL10",149,0)
 S (ERRCNT,RC)=0
"RTN","RORHL10",150,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL10",151,0)
 S CS=$E(HLECH)
"RTN","RORHL10",152,0)
 ;---
"RTN","RORHL10",153,0)
 S RORTMP=$NA(^TMP("RORHL10",$J))  K @RORTMP
"RTN","RORHL10",154,0)
 ;---
"RTN","RORHL10",155,0)
 I $$SPATH^LA7UTL03(LRDFN,RORIENS,RORTMP,"RORMSG")  D
"RTN","RORHL10",156,0)
 . D SPECIMEN
"RTN","RORHL10",157,0)
 . D HIST
"RTN","RORHL10",158,0)
 . D PRED
"RTN","RORHL10",159,0)
 . D OPD
"RTN","RORHL10",160,0)
 . D POSTD
"RTN","RORHL10",161,0)
 . D GROSSD
"RTN","RORHL10",162,0)
 . D MICROD
"RTN","RORHL10",163,0)
 . D SURGPATH
"RTN","RORHL10",164,0)
 . D ICD
"RTN","RORHL10",165,0)
 E  D:$D(RORMSG)>1
"RTN","RORHL10",166,0)
 . N I,INFO  S TMP=""
"RTN","RORHL10",167,0)
 . F I=1:1  S TMP=$O(RORMSG(TMP))  Q:TMP=""  S INFO(I)=RORMSG(TMP)
"RTN","RORHL10",168,0)
 . S RC=$$ERROR^RORERR(-56,,.INFO,,0,"$$SPATH^LA7UTL03")
"RTN","RORHL10",169,0)
 ;---
"RTN","RORHL10",170,0)
 K @RORTMP
"RTN","RORHL10",171,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL10",172,0)
 ;
"RTN","RORHL10",173,0)
 ;***** MAKES SPECIMEN OBX
"RTN","RORHL10",174,0)
SPECIMEN ;
"RTN","RORHL10",175,0)
 N INDEX,RORSPEC,SPECID
"RTN","RORHL10",176,0)
 S INDEX="",SPECID=$$SEGID("SPEC","Specimen",CS)
"RTN","RORHL10",177,0)
 F  S INDEX=$O(@RORTMP@("SPEC",INDEX))  Q:INDEX=""  D
"RTN","RORHL10",178,0)
 . S RORSPEC=@RORTMP@("SPEC",INDEX)
"RTN","RORHL10",179,0)
 . I RORSPEC="" Q
"RTN","RORHL10",180,0)
 . S RORSPEC=$$ESCAPE^RORHL7(RORSPEC)
"RTN","RORHL10",181,0)
 . D SETOBX(SPECID,RORSPEC)
"RTN","RORHL10",182,0)
 Q
"RTN","RORHL10",183,0)
 ;
"RTN","RORHL10",184,0)
 ;*****
"RTN","RORHL10",185,0)
HIST ;
"RTN","RORHL10",186,0)
 N HISTID,INDEX,RORHIST
"RTN","RORHL10",187,0)
 S INDEX="",HISTID=$$SEGID("BCH","Brief clinical History",CS)
"RTN","RORHL10",188,0)
 F  S INDEX=$O(@RORTMP@("CHIS",INDEX))  Q:INDEX=""  D
"RTN","RORHL10",189,0)
 . S RORHIST=@RORTMP@("CHIS",INDEX)
"RTN","RORHL10",190,0)
 . I RORHIST="" Q
"RTN","RORHL10",191,0)
 . S RORHIST=$$ESCAPE^RORHL7(RORHIST)
"RTN","RORHL10",192,0)
 . D SETOBX(HISTID,RORHIST)
"RTN","RORHL10",193,0)
 Q
"RTN","RORHL10",194,0)
 ;
"RTN","RORHL10",195,0)
 ;*****
"RTN","RORHL10",196,0)
PRED ;
"RTN","RORHL10",197,0)
 N INDEX,PREDID,RORPRED
"RTN","RORHL10",198,0)
 S INDEX="",PREDID=$$SEGID("PDIAG","Preoperative Diagnosis",CS)
"RTN","RORHL10",199,0)
 F  S INDEX=$O(@RORTMP@("PREDX",INDEX))  Q:INDEX=""  D
"RTN","RORHL10",200,0)
 . S RORPRED=@RORTMP@("PREDX",INDEX)
"RTN","RORHL10",201,0)
 . I RORPRED="" Q
"RTN","RORHL10",202,0)
 . S RORPRED=$$ESCAPE^RORHL7(RORPRED)
"RTN","RORHL10",203,0)
 . D SETOBX(PREDID,RORPRED)
"RTN","RORHL10",204,0)
 Q
"RTN","RORHL10",205,0)
 ;*****
"RTN","RORHL10",206,0)
OPD ;
"RTN","RORHL10",207,0)
 N INDEX,OPDID,ROROPD
"RTN","RORHL10",208,0)
 S INDEX="",OPDID=$$SEGID("OF","Operative Findings",CS)
"RTN","RORHL10",209,0)
 F  S INDEX=$O(@RORTMP@("OPERDX",INDEX))  Q:INDEX=""  D
"RTN","RORHL10",210,0)
 . S ROROPD=@RORTMP@("OPERDX",INDEX)
"RTN","RORHL10",211,0)
 . I ROROPD="" Q
"RTN","RORHL10",212,0)
 . S ROROPD=$$ESCAPE^RORHL7(ROROPD)
"RTN","RORHL10",213,0)
 . D SETOBX(OPDID,ROROPD)
"RTN","RORHL10",214,0)
 Q
"RTN","RORHL10",215,0)
 ;
"RTN","RORHL10",216,0)
 ;*****
"RTN","RORHL10",217,0)
POSTD ;
"RTN","RORHL10",218,0)
 N INDEX,POSTID,RORPOST
"RTN","RORHL10",219,0)
 S INDEX="",POSTID=$$SEGID("POPDIAG","Postoperative Diagnosis",CS)
"RTN","RORHL10",220,0)
 F  S INDEX=$O(@RORTMP@("POSTDX",INDEX))  Q:INDEX=""  D
"RTN","RORHL10",221,0)
 . S RORPOST=@RORTMP@("POSTDX",INDEX)
"RTN","RORHL10",222,0)
 . I RORPOST="" Q
"RTN","RORHL10",223,0)
 . S RORPOST=$$ESCAPE^RORHL7(RORPOST)
"RTN","RORHL10",224,0)
 . D SETOBX(POSTID,RORPOST)
"RTN","RORHL10",225,0)
 Q
"RTN","RORHL10",226,0)
 ;***** GROSS DESCRIPTION DATA
"RTN","RORHL10",227,0)
GROSSD ;
"RTN","RORHL10",228,0)
 N GROSSID,INDEX,RORGROSS
"RTN","RORHL10",229,0)
 S INDEX="",GROSSID=$$SEGID("GDESC","Gross Decription",CS)
"RTN","RORHL10",230,0)
 F  S INDEX=$O(@RORTMP@("GROSSD",INDEX))  Q:INDEX=""  D
"RTN","RORHL10",231,0)
 . S RORGROSS=@RORTMP@("GROSSD",INDEX)
"RTN","RORHL10",232,0)
 . I RORGROSS="" Q
"RTN","RORHL10",233,0)
 . S RORGROSS=$$ESCAPE^RORHL7(RORGROSS)
"RTN","RORHL10",234,0)
 . D SETOBX(GROSSID,RORGROSS)
"RTN","RORHL10",235,0)
 Q
"RTN","RORHL10",236,0)
 ;
"RTN","RORHL10",237,0)
 ;***** MICROSCOPIC DESCRIPTION DATA
"RTN","RORHL10",238,0)
MICROD ;
"RTN","RORHL10",239,0)
 N INDEX,MICROID,RORMICRO
"RTN","RORHL10",240,0)
 S INDEX="",MICROID=$$SEGID("MDESC","Microscopic Description",CS)
"RTN","RORHL10",241,0)
 F  S INDEX=$O(@RORTMP@("MICROD",INDEX))  Q:INDEX=""  D
"RTN","RORHL10",242,0)
 . S RORMICRO=@RORTMP@("MICROD",INDEX)
"RTN","RORHL10",243,0)
 . I RORMICRO="" Q
"RTN","RORHL10",244,0)
 . S RORMICRO=$$ESCAPE^RORHL7(RORMICRO)
"RTN","RORHL10",245,0)
 . D SETOBX(MICROID,RORMICRO)
"RTN","RORHL10",246,0)
 Q
"RTN","RORHL10",247,0)
 ;
"RTN","RORHL10",248,0)
 ;***** SURGICAL PATHOLOGY
"RTN","RORHL10",249,0)
SURGPATH ;
"RTN","RORHL10",250,0)
 N INDEX,RORSURGP,SURGPID
"RTN","RORHL10",251,0)
 S INDEX=""
"RTN","RORHL10",252,0)
 S SURGPID=$$SEGID("SPDIAG","Surgical Pathology Diagnosis",CS)
"RTN","RORHL10",253,0)
 F  S INDEX=$O(@RORTMP@("SURGP",INDEX))  Q:INDEX=""  D
"RTN","RORHL10",254,0)
 . S RORSURGP=@RORTMP@("SURGP",INDEX)
"RTN","RORHL10",255,0)
 . I RORSURGP="" Q
"RTN","RORHL10",256,0)
 . S RORSURGP=$$ESCAPE^RORHL7(RORSURGP)
"RTN","RORHL10",257,0)
 . D SETOBX(SURGPID,RORSURGP)
"RTN","RORHL10",258,0)
 Q
"RTN","RORHL10",259,0)
 ;
"RTN","RORHL10",260,0)
 ;***** ICD-9
"RTN","RORHL10",261,0)
ICD ;
"RTN","RORHL10",262,0)
 N ICDID,INDEX,RORICD
"RTN","RORHL10",263,0)
 S INDEX="",ICDID=$$SEGID("ICD9","ICD9",CS)
"RTN","RORHL10",264,0)
 F  S INDEX=$O(@RORTMP@("ICD9",INDEX))  Q:INDEX=""  D
"RTN","RORHL10",265,0)
 . S RORICD=@RORTMP@("ICD9",INDEX)
"RTN","RORHL10",266,0)
 . D SETOBX(ICDID,RORICD)
"RTN","RORHL10",267,0)
 Q
"RTN","RORHL10",268,0)
 ;
"RTN","RORHL10",269,0)
 ;***** CONSTRUCTS SEGMENT IDENTIFIER
"RTN","RORHL10",270,0)
SEGID(PONE,PTWO,CS) ;
"RTN","RORHL10",271,0)
 Q PONE_CS_PTWO_CS_"VA080"
"RTN","RORHL10",272,0)
 ;
"RTN","RORHL10",273,0)
 ;***** CREATES AND STORES THE OBX SEGMENT
"RTN","RORHL10",274,0)
SETOBX(PIECE3,PIECE5) ;
"RTN","RORHL10",275,0)
 N RORSEG
"RTN","RORHL10",276,0)
 ;--- Initialize the segment
"RTN","RORHL10",277,0)
 S RORSEG="OBX"
"RTN","RORHL10",278,0)
 ;--- OBX-2
"RTN","RORHL10",279,0)
 S $P(RORSEG,HLFS,3)="FT"
"RTN","RORHL10",280,0)
 ;---
"RTN","RORHL10",281,0)
 S $P(RORSEG,HLFS,4)=PIECE3
"RTN","RORHL10",282,0)
 S $P(RORSEG,HLFS,6)=PIECE5
"RTN","RORHL10",283,0)
 ;--- OBX-11
"RTN","RORHL10",284,0)
 S $P(RORSEG,HLFS,12)="F"
"RTN","RORHL10",285,0)
 ;--- Store the segment
"RTN","RORHL10",286,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL10",287,0)
 Q
"RTN","RORHL11")
0^43^B41807698
"RTN","RORHL11",1,0)
RORHL11 ;HOIFO/BH - HL7 CYTOPATHOLOGY DATA: OBR,OBX ; 10/1/03 2:34pm
"RTN","RORHL11",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL11",3,0)
 ;
"RTN","RORHL11",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL11",5,0)
 ;
"RTN","RORHL11",6,0)
 ; #2503         LRDFN^LR7OR1 (controlled)
"RTN","RORHL11",7,0)
 ;
"RTN","RORHL11",8,0)
 ; #Not Released         $$CYPATH^LA7UTL02
"RTN","RORHL11",9,0)
 ;
"RTN","RORHL11",10,0)
 Q
"RTN","RORHL11",11,0)
 ; ********Under Construction
"RTN","RORHL11",12,0)
 ;
"RTN","RORHL11",13,0)
 ;***** SEARCHES FOR CYTOPATHOLOGY DATA
"RTN","RORHL11",14,0)
 ;
"RTN","RORHL11",15,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL11",16,0)
 ;
"RTN","RORHL11",17,0)
 ; RORSTDT       Start Date (FileMan)
"RTN","RORHL11",18,0)
 ; RORENDT       End Date   (FileMan)
"RTN","RORHL11",19,0)
 ;
"RTN","RORHL11",20,0)
 ; [CDSMODE]     Search the data by:
"RTN","RORHL11",21,0)
 ;                 0  completion/result date (default)
"RTN","RORHL11",22,0)
 ;                 1  specimen collection date
"RTN","RORHL11",23,0)
 ;
"RTN","RORHL11",24,0)
 ; Return Values:
"RTN","RORHL11",25,0)
 ;       <0  Error code
"RTN","RORHL11",26,0)
 ;        0  Ok
"RTN","RORHL11",27,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL11",28,0)
 ;
"RTN","RORHL11",29,0)
 ; The function uses the ^TMP("RORHL11",$J) global node.
"RTN","RORHL11",30,0)
 ;
"RTN","RORHL11",31,0)
EN1(RORDFN,RORSTDT,RORENDT,CDSMODE,RORPTR,RORFILE,HLFS,HLECH) ;
"RTN","RORHL11",32,0)
 N ERRCNT,LRDFN,RC,RORIEN
"RTN","RORHL11",33,0)
 S (ERRCNT,RC)=0
"RTN","RORHL11",34,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL11",35,0)
 ;
"RTN","RORHL11",36,0)
 S LRDFN=+$$LRDFN^LR7OR1(RORDFN)  Q:'LRDFN 0
"RTN","RORHL11",37,0)
 ;
"RTN","RORHL11",38,0)
 S RC=$S($G(CDSMODE):$$CD(),1:$$RAD())
"RTN","RORHL11",39,0)
 S:RC ERRCNT=ERRCNT+1
"RTN","RORHL11",40,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL11",41,0)
 ;
"RTN","RORHL11",42,0)
 ;***** SEARCHES BY SPECIMEN COLLECTION DATE
"RTN","RORHL11",43,0)
CD() ;
"RTN","RORHL11",44,0)
 N ENDT,ERRCNT,IDT,STDT
"RTN","RORHL11",45,0)
 S ERRCNT=0
"RTN","RORHL11",46,0)
 S STDT=9999999-RORSTDT
"RTN","RORHL11",47,0)
 S ENDT=9999999-RORENDT
"RTN","RORHL11",48,0)
 S IDT=$O(^LR(LRDFN,"CY",STDT))
"RTN","RORHL11",49,0)
 F  S IDT=$O(^LR(LRDFN,"CY",IDT),-1)  Q:'IDT!(IDT'>ENDT)  D
"RTN","RORHL11",50,0)
 . S:$$OBROBX(IDT) ERRCNT=ERRCNT+1
"RTN","RORHL11",51,0)
 Q ERRCNT
"RTN","RORHL11",52,0)
 ;
"RTN","RORHL11",53,0)
 ;***** SEARCHES BY COMPLETION (RESULT) DATE
"RTN","RORHL11",54,0)
RAD() ;
"RTN","RORHL11",55,0)
 N ERRCNT,IDT,RCDT
"RTN","RORHL11",56,0)
 S (ERRCNT,IDT)=0
"RTN","RORHL11",57,0)
 F  S IDT=$O(^LR(LRDFN,"CY",IDT))  Q:'IDT  D
"RTN","RORHL11",58,0)
 . S RCDT=$P($G(^LR(LRDFN,"CY",IDT,0)),U,3)
"RTN","RORHL11",59,0)
 . I RCDT'<STDT,RCDT<ENDT  S:$$OBROBX(IDT) ERRCNT=ERRCNT+1
"RTN","RORHL11",60,0)
 Q ERRCNT
"RTN","RORHL11",61,0)
 ;
"RTN","RORHL11",62,0)
 ;***** CREATES OBR AND OBX SEGMENTS
"RTN","RORHL11",63,0)
OBROBX(RORIDT) ;
"RTN","RORHL11",64,0)
 N ERRCNT,RC,RORMSG,RORTMP,TMP
"RTN","RORHL11",65,0)
 S ERRCNT=0
"RTN","RORHL11",66,0)
 ;---
"RTN","RORHL11",67,0)
 S RORTMP=$NA(^TMP("RORHL11",$J))  K @RORTMP
"RTN","RORHL11",68,0)
 ;---
"RTN","RORHL11",69,0)
 I $$CYPATH^LA7UTL02(LRDFN,RORIDT,RORTMP,"RORMSG")  D
"RTN","RORHL11",70,0)
 . S RC=$$OBR(RORTMP,RORIDT)
"RTN","RORHL11",71,0)
 . I RC  S ERRCNT=ERRCNT+1  Q:RC<0
"RTN","RORHL11",72,0)
 . ;---
"RTN","RORHL11",73,0)
 . S RC=$$OBX(RORTMP)
"RTN","RORHL11",74,0)
 . I RC  S ERRCNT=ERRCNT+1  Q:RC<0
"RTN","RORHL11",75,0)
 E  D:$D(RORMSG)>1
"RTN","RORHL11",76,0)
 . N I,INFO  S TMP=""
"RTN","RORHL11",77,0)
 . F I=1:1  S TMP=$O(RORMSG(TMP))  Q:TMP=""  S INFO(I)=RORMSG(TMP)
"RTN","RORHL11",78,0)
 . S RC=$$ERROR^RORERR(-56,,.INFO,,0,"$$CYPATH^LA7UTL02")
"RTN","RORHL11",79,0)
 ;---
"RTN","RORHL11",80,0)
 K @RORTMP
"RTN","RORHL11",81,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL11",82,0)
 ;
"RTN","RORHL11",83,0)
 ;***** CYTOPATHOLOGY OBR SEGMENT BUILDER
"RTN","RORHL11",84,0)
 ;
"RTN","RORHL11",85,0)
 ; RORTMP        Closed root of the array holding lab data
"RTN","RORHL11",86,0)
 ; RORIEN        IEN of Cyto Visit
"RTN","RORHL11",87,0)
 ;
"RTN","RORHL11",88,0)
 ; Return Values:
"RTN","RORHL11",89,0)
 ;       <0  Error code
"RTN","RORHL11",90,0)
 ;        0  Ok
"RTN","RORHL11",91,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL11",92,0)
 ;
"RTN","RORHL11",93,0)
OBR(RORTMP,RORIEN) ;
"RTN","RORHL11",94,0)
 N CS,CPA,ERRCNT,RC,RORSEG,TMP
"RTN","RORHL11",95,0)
 S (ERRCNT,RC)=0
"RTN","RORHL11",96,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL11",97,0)
 S CS=$E(HLECH,1)
"RTN","RORHL11",98,0)
 ;
"RTN","RORHL11",99,0)
 ;--- Initialize the segment
"RTN","RORHL11",100,0)
 S RORSEG="OBR"
"RTN","RORHL11",101,0)
 ;
"RTN","RORHL11",102,0)
 ;--- OBR-3 - Cyto Path Acc #
"RTN","RORHL11",103,0)
 S CPA=$P($G(@RORTMP@("DEMO",RORIEN)),U,2)  Q:CPA="" 0
"RTN","RORHL11",104,0)
 S $P(RORSEG,HLFS,4)=CPA
"RTN","RORHL11",105,0)
 ;
"RTN","RORHL11",106,0)
 ;--- OBR-4
"RTN","RORHL11",107,0)
 S TMP="88108"
"RTN","RORHL11",108,0)
 S $P(TMP,CS,2)="CYTOPATHOLOGY, CONCENT"
"RTN","RORHL11",109,0)
 S $P(TMP,CS,3)="C4"
"RTN","RORHL11",110,0)
 S $P(RORSEG,HLFS,5)=TMP
"RTN","RORHL11",111,0)
 ;
"RTN","RORHL11",112,0)
 ;--- OBR-7 - Date/Time Specimen Taken
"RTN","RORHL11",113,0)
 S TMP=$$FMTHL7^XLFDT($P(@RORTMP@("DEMO",RORIEN),U))
"RTN","RORHL11",114,0)
 I TMP'>0  D  Q RC
"RTN","RORHL11",115,0)
 . S RC=$$ERROR^RORERR(-100,,,,"No specimen date","$$CYPATH^LA7UTL02")
"RTN","RORHL11",116,0)
 S $P(RORSEG,HLFS,8)=TMP
"RTN","RORHL11",117,0)
 ;
"RTN","RORHL11",118,0)
 ;--- OBR-24 - Service Section ID
"RTN","RORHL11",119,0)
 S $P(RORSEG,HLFS,25)="CP"
"RTN","RORHL11",120,0)
 ;
"RTN","RORHL11",121,0)
 ;--- OBR-44 - Divsion
"RTN","RORHL11",122,0)
 S $P(RORSEG,HLFS,45)=$$SITE1^RORUTL03(CS)
"RTN","RORHL11",123,0)
 ;
"RTN","RORHL11",124,0)
 ;--- Store the segment
"RTN","RORHL11",125,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL11",126,0)
 Q ERRCNT
"RTN","RORHL11",127,0)
 ;
"RTN","RORHL11",128,0)
 ;***** CYTOPATHOLOGY OBX SEGMENT BUILDER
"RTN","RORHL11",129,0)
 ;
"RTN","RORHL11",130,0)
 ; RORTMP        Closed root of the array holding lab data
"RTN","RORHL11",131,0)
 ;
"RTN","RORHL11",132,0)
 ; Return Values:
"RTN","RORHL11",133,0)
 ;       <0  Error code
"RTN","RORHL11",134,0)
 ;        0  Ok
"RTN","RORHL11",135,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL11",136,0)
 ;
"RTN","RORHL11",137,0)
OBX(RORTMP) ;
"RTN","RORHL11",138,0)
 N CS,ERRCNT,RC,TMP
"RTN","RORHL11",139,0)
 S (ERRCNT,RC)=0
"RTN","RORHL11",140,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL11",141,0)
 S CS=$E(HLECH)
"RTN","RORHL11",142,0)
 ;
"RTN","RORHL11",143,0)
 D:$D(@RORTMP@("SPEC")) SPECIMEN
"RTN","RORHL11",144,0)
 D:$D(@RORTMP@("CHIS")) HIST
"RTN","RORHL11",145,0)
 D:$D(@RORTMP@("PREDX")) PRED
"RTN","RORHL11",146,0)
 D:$D(@RORTMP@("OPERDX")) OPD
"RTN","RORHL11",147,0)
 D:$D(@RORTMP@("POSTDX")) POSTD
"RTN","RORHL11",148,0)
 D:$D(@RORTMP@("MICRO")) MICRO
"RTN","RORHL11",149,0)
 D:$D(@RORTMP@("CYTODX")) CYTOPATH
"RTN","RORHL11",150,0)
 D:$D(@RORTMP@("ICD9")) ICD
"RTN","RORHL11",151,0)
 ;
"RTN","RORHL11",152,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL11",153,0)
 ;
"RTN","RORHL11",154,0)
 ;***** MAKES SPECIMEN OBX
"RTN","RORHL11",155,0)
SPECIMEN ;
"RTN","RORHL11",156,0)
 N INDEX,RORSPEC,SPECID
"RTN","RORHL11",157,0)
 S SPECID=$$SEGID("SPEC","Specimen",CS)
"RTN","RORHL11",158,0)
 S INDEX=""
"RTN","RORHL11",159,0)
 F  S INDEX=$O(@RORTMP@("SPEC",INDEX))  Q:INDEX=""  D
"RTN","RORHL11",160,0)
 . S RORSPEC=@RORTMP@("SPEC",INDEX)
"RTN","RORHL11",161,0)
 . D SETOBX(SPECID,RORSPEC)
"RTN","RORHL11",162,0)
 Q
"RTN","RORHL11",163,0)
 ;
"RTN","RORHL11",164,0)
 ;*****
"RTN","RORHL11",165,0)
HIST ;
"RTN","RORHL11",166,0)
 N INDEX,HISTID,RORHIST
"RTN","RORHL11",167,0)
 S HISTID=$$SEGID("BCH","Brief clinical History",CS)
"RTN","RORHL11",168,0)
 S INDEX=""
"RTN","RORHL11",169,0)
 F  S INDEX=$O(@RORTMP@("CHIS",INDEX))  Q:INDEX=""  D
"RTN","RORHL11",170,0)
 . S RORHIST=@RORTMP@("CHIS",INDEX)
"RTN","RORHL11",171,0)
 . D SETOBX(HISTID,RORHIST)
"RTN","RORHL11",172,0)
 Q
"RTN","RORHL11",173,0)
 ;
"RTN","RORHL11",174,0)
 ;*****
"RTN","RORHL11",175,0)
PRED ;
"RTN","RORHL11",176,0)
 N INDEX,PREDID,RORPRED
"RTN","RORHL11",177,0)
 S PREDID=$$SEGID("PDIAG","Preoperative Diagnosis",CS)
"RTN","RORHL11",178,0)
 S INDEX=""
"RTN","RORHL11",179,0)
 F  S INDEX=$O(@RORTMP@("PREDX",INDEX))  Q:INDEX=""  D
"RTN","RORHL11",180,0)
 . S RORPRED=@RORTMP@("PREDX",INDEX)
"RTN","RORHL11",181,0)
 . D SETOBX(PREDID,RORPRED)
"RTN","RORHL11",182,0)
 Q
"RTN","RORHL11",183,0)
 ;
"RTN","RORHL11",184,0)
 ;*****
"RTN","RORHL11",185,0)
OPD ;
"RTN","RORHL11",186,0)
 N INDEX,OPDID,ROROPD
"RTN","RORHL11",187,0)
 S OPDID=$$SEGID("OF","Operative Findings",CS)
"RTN","RORHL11",188,0)
 S INDEX=""
"RTN","RORHL11",189,0)
 F  S INDEX=$O(@RORTMP@("OPERDX",INDEX))  Q:INDEX=""  D
"RTN","RORHL11",190,0)
 . S ROROPD=@RORTMP@("OPERDX",INDEX)
"RTN","RORHL11",191,0)
 . D SETOBX(OPDID,ROROPD)
"RTN","RORHL11",192,0)
 Q
"RTN","RORHL11",193,0)
 ;
"RTN","RORHL11",194,0)
 ;*****
"RTN","RORHL11",195,0)
POSTD ;
"RTN","RORHL11",196,0)
 N INDEX,POSTID,RORPOST
"RTN","RORHL11",197,0)
 S POSTID=$$SEGID("POPDIAG","Postoperative Diagnosis",CS)
"RTN","RORHL11",198,0)
 S INDEX=""
"RTN","RORHL11",199,0)
 F  S INDEX=$O(@RORTMP@("POSTDX",INDEX))  Q:INDEX=""  D
"RTN","RORHL11",200,0)
 . S RORPOST=@RORTMP@("POSTDX",INDEX)
"RTN","RORHL11",201,0)
 . D SETOBX(POSTID,RORPOST)
"RTN","RORHL11",202,0)
 Q
"RTN","RORHL11",203,0)
 ;
"RTN","RORHL11",204,0)
MICRO ; *****Microscopic Examination  
"RTN","RORHL11",205,0)
 N INDEX,MICROID,RORMIC
"RTN","RORHL11",206,0)
 S MICROID=$$SEGID("MICRO","Microscopic Examination",CS)
"RTN","RORHL11",207,0)
 S INDEX=""
"RTN","RORHL11",208,0)
 F  S INDEX=$O(@RORTMP@("MICRO",INDEX))  Q:INDEX=""  D
"RTN","RORHL11",209,0)
 . S RORMIC=@RORTMP@("MICRO",INDEX)
"RTN","RORHL11",210,0)
 . D SETOBX(MICROID,RORMIC)
"RTN","RORHL11",211,0)
 Q
"RTN","RORHL11",212,0)
 ;
"RTN","RORHL11",213,0)
 ;
"RTN","RORHL11",214,0)
 ;****** CYTOPATHOLOGY
"RTN","RORHL11",215,0)
CYTOPATH ;
"RTN","RORHL11",216,0)
 N INDEX,RORSURGP,SURGPID
"RTN","RORHL11",217,0)
 S SURGPID=$$SEGID("CDIAG","Cytopathology Diagnosis",CS)
"RTN","RORHL11",218,0)
 S INDEX=""
"RTN","RORHL11",219,0)
 F  S INDEX=$O(@RORTMP@("CYTODX",INDEX))  Q:INDEX=""  D
"RTN","RORHL11",220,0)
 . S RORSURGP=@RORTMP@("CYTODX",INDEX)
"RTN","RORHL11",221,0)
 . D SETOBX(SURGPID,RORSURGP)
"RTN","RORHL11",222,0)
 Q
"RTN","RORHL11",223,0)
 ;
"RTN","RORHL11",224,0)
 ;*****
"RTN","RORHL11",225,0)
ICD ;
"RTN","RORHL11",226,0)
 N ICDID,INDEX,RORICD
"RTN","RORHL11",227,0)
 S ICDID=$$SEGID("ICD9","ICD9",CS)
"RTN","RORHL11",228,0)
 S INDEX=""
"RTN","RORHL11",229,0)
 F  S INDEX=$O(@RORTMP@("ICD9",INDEX))  Q:INDEX=""  D
"RTN","RORHL11",230,0)
 . S RORICD=@RORTMP@("ICD9",INDEX)
"RTN","RORHL11",231,0)
 . D SETOBX(ICDID,RORICD)
"RTN","RORHL11",232,0)
 Q
"RTN","RORHL11",233,0)
 ;
"RTN","RORHL11",234,0)
 ;***** CONSTRUCTS SEGMENT IDENTIFIER
"RTN","RORHL11",235,0)
SEGID(PONE,PTWO,CS) ; Create segment identifier
"RTN","RORHL11",236,0)
 Q PONE_CS_PTWO_CS_"VA080"
"RTN","RORHL11",237,0)
 ;
"RTN","RORHL11",238,0)
 ;***** CREATES AND STORES THE OBX SEGMENT
"RTN","RORHL11",239,0)
SETOBX(PIECE3,PIECE5) ;
"RTN","RORHL11",240,0)
 N RORSEG
"RTN","RORHL11",241,0)
 ;--- Initialize the segment
"RTN","RORHL11",242,0)
 S RORSEG="OBX"
"RTN","RORHL11",243,0)
 ;--- OBX-2
"RTN","RORHL11",244,0)
 S $P(RORSEG,HLFS,3)="FT"
"RTN","RORHL11",245,0)
 ;---
"RTN","RORHL11",246,0)
 S $P(RORSEG,HLFS,4)=PIECE3
"RTN","RORHL11",247,0)
 S $P(RORSEG,HLFS,6)=PIECE5
"RTN","RORHL11",248,0)
 ;--- OBX-11
"RTN","RORHL11",249,0)
 S $P(RORSEG,HLFS,12)="F"
"RTN","RORHL11",250,0)
 ;--- Store the segment
"RTN","RORHL11",251,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL11",252,0)
 Q
"RTN","RORHL12")
0^44^B8931261
"RTN","RORHL12",1,0)
RORHL12 ;HOIFO/BH - HL7 MICROBIOLOGY DATA: OBR,OBX ; 10/1/03 2:40pm
"RTN","RORHL12",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL12",3,0)
 ;
"RTN","RORHL12",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL12",5,0)
 ;
"RTN","RORHL12",6,0)
 ; #2503         LRDFN^LR7OR1 (controlled)
"RTN","RORHL12",7,0)
 ;
"RTN","RORHL12",8,0)
 ; #Not released     $$GETDATA^LA7UTL1A
"RTN","RORHL12",9,0)
 ;
"RTN","RORHL12",10,0)
 Q
"RTN","RORHL12",11,0)
 ;
"RTN","RORHL12",12,0)
 ;***** SEARCHES FOR MICROBIOLOGY DATA
"RTN","RORHL12",13,0)
 ;
"RTN","RORHL12",14,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL12",15,0)
 ;
"RTN","RORHL12",16,0)
 ; RORSTDT       Start Date (FileMan)
"RTN","RORHL12",17,0)
 ; RORENDT       End Date   (FileMan)
"RTN","RORHL12",18,0)
 ;
"RTN","RORHL12",19,0)
 ; [CDSMODE]     Search the data by:
"RTN","RORHL12",20,0)
 ;                 0  completion/result date (default)
"RTN","RORHL12",21,0)
 ;                 1  specimen collection date
"RTN","RORHL12",22,0)
 ;
"RTN","RORHL12",23,0)
 ; Return Values:
"RTN","RORHL12",24,0)
 ;       <0  Error code
"RTN","RORHL12",25,0)
 ;        0  Ok
"RTN","RORHL12",26,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL12",27,0)
 ;
"RTN","RORHL12",28,0)
 ; The function uses the ^TMP("RORHL12",$J) global node.
"RTN","RORHL12",29,0)
 ;
"RTN","RORHL12",30,0)
EN1(RORDFN,RORSTDT,RORENDT,CDSMODE) ;
"RTN","RORHL12",31,0)
 N ERRCNT,LRDFN,RC,RORMIIEN,RORREF,RORTMP,TMP
"RTN","RORHL12",32,0)
 S (ERRCNT,RC)=0
"RTN","RORHL12",33,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL12",34,0)
 ;--- Check the parameters
"RTN","RORHL12",35,0)
 S CDSMODE=$S($G(CDSMODE):"CD",1:"RAD")
"RTN","RORHL12",36,0)
 ;
"RTN","RORHL12",37,0)
 S LRDFN=+$$LRDFN^LR7OR1(RORDFN)  Q:'LRDFN 0
"RTN","RORHL12",38,0)
 S RORTMP=$NA(^TMP("RORHL12",$J))  K @RORTMP
"RTN","RORHL12",39,0)
 ;
"RTN","RORHL12",40,0)
 S TMP=$$GETDATA^LA7UTL1A(LRDFN,RORSTDT,RORENDT,CDSMODE,RORTMP)
"RTN","RORHL12",41,0)
 I TMP<0  D  Q RC
"RTN","RORHL12",42,0)
 . S RC=$$ERROR^RORERR(-56,,$P(TMP,U,2),RORDFN,+TMP,"$$GETDATA^LA7UTL1A")
"RTN","RORHL12",43,0)
 ;
"RTN","RORHL12",44,0)
 S RORMIIEN=""
"RTN","RORHL12",45,0)
 F  S RORMIIEN=$O(@RORTMP@(LRDFN,RORMIIEN))  Q:RORMIIEN=""  D
"RTN","RORHL12",46,0)
 . S RORREF=$NA(@RORTMP@(LRDFN,RORMIIEN))
"RTN","RORHL12",47,0)
 . ;---
"RTN","RORHL12",48,0)
 . S TMP=$$OBR(RORREF)
"RTN","RORHL12",49,0)
 . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL12",50,0)
 . ;---
"RTN","RORHL12",51,0)
 . S TMP=$$OBX^RORHL121(RORREF)
"RTN","RORHL12",52,0)
 . I TMP  S ERRCNT=ERRCNT+1  Q:TMP<0
"RTN","RORHL12",53,0)
 ;
"RTN","RORHL12",54,0)
 K @RORTMP
"RTN","RORHL12",55,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL12",56,0)
 ;
"RTN","RORHL12",57,0)
 ;***** MICROBIOLOGY OBR SEGMENT BUILDER
"RTN","RORHL12",58,0)
 ;
"RTN","RORHL12",59,0)
 ; RORREF        Global reference for MI entry
"RTN","RORHL12",60,0)
 ;
"RTN","RORHL12",61,0)
 ; Return Values:
"RTN","RORHL12",62,0)
 ;       <0  Error code
"RTN","RORHL12",63,0)
 ;        0  Ok
"RTN","RORHL12",64,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL12",65,0)
 ;
"RTN","RORHL12",66,0)
OBR(RORREF) ;
"RTN","RORHL12",67,0)
 N CS,ERRCNT,RC,RORSEG
"RTN","RORHL12",68,0)
 S (ERRCNT,RC)=0
"RTN","RORHL12",69,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL12",70,0)
 S CS=$E(HLECH,1)
"RTN","RORHL12",71,0)
 ;
"RTN","RORHL12",72,0)
 ;--- Initialize the segment
"RTN","RORHL12",73,0)
 S RORSEG="OBR"
"RTN","RORHL12",74,0)
 ;
"RTN","RORHL12",75,0)
 ;--- OBR-3
"RTN","RORHL12",76,0)
 S TMP=$G(@RORREF@(0,.06,"I"))
"RTN","RORHL12",77,0)
 I TMP=""  D  Q RC
"RTN","RORHL12",78,0)
 . S RC=$$ERROR^RORERR(-100,,,,"No accession #","$$GETDATA^LA7UTL1A")
"RTN","RORHL12",79,0)
 S $P(RORSEG,HLFS,4)=TMP
"RTN","RORHL12",80,0)
 ;
"RTN","RORHL12",81,0)
 ;--- OBR-4 - Universal Service ID
"RTN","RORHL12",82,0)
 S $P(RORSEG,HLFS,5)="87999"_CS_"MICROBIOLOGY"_CS_"C4"
"RTN","RORHL12",83,0)
 ;
"RTN","RORHL12",84,0)
 ;--- OBR-7  - Accession Date
"RTN","RORHL12",85,0)
 S TMP=$$FMTHL7^XLFDT($G(@RORREF@(0,.01,"I")))
"RTN","RORHL12",86,0)
 I TMP'>0  D  Q RC
"RTN","RORHL12",87,0)
 . S RC=$$ERROR^RORERR(-100,,,,"No accession date","$$GETDATA^LA7UTL1A")
"RTN","RORHL12",88,0)
 S $P(RORSEG,HLFS,8)=TMP
"RTN","RORHL12",89,0)
 ;
"RTN","RORHL12",90,0)
 ;--- OBR-11 - Specimen Action Code
"RTN","RORHL12",91,0)
 S $P(RORSEG,HLFS,12)=$G(@RORREF@(0,11.57,"I"))
"RTN","RORHL12",92,0)
 ;
"RTN","RORHL12",93,0)
 ;--- OBR-13 - Relevant Clinical Info.
"RTN","RORHL12",94,0)
 S $P(RORSEG,HLFS,14)=$G(@RORREF@(0,.05,"E"))
"RTN","RORHL12",95,0)
 ;
"RTN","RORHL12",96,0)
 ;--- OBR-20 - Filler Field 1
"RTN","RORHL12",97,0)
 S $P(RORSEG,HLFS,21)=$G(@RORREF@(0,.055,"E"))
"RTN","RORHL12",98,0)
 ;
"RTN","RORHL12",99,0)
 ;--- OBR-21 - Filler Field 2
"RTN","RORHL12",100,0)
 S $P(RORSEG,HLFS,22)=$G(@RORREF@(0,11.58,"E"))
"RTN","RORHL12",101,0)
 ;
"RTN","RORHL12",102,0)
 ;--- OBR-24 - Diagnostic Service ID
"RTN","RORHL12",103,0)
 S $P(RORSEG,HLFS,25)="MB"
"RTN","RORHL12",104,0)
 ;
"RTN","RORHL12",105,0)
 ;--- OBR-25 - Result Status
"RTN","RORHL12",106,0)
 S TMP=$G(@RORREF@(0,11.51,"I"))
"RTN","RORHL12",107,0)
 S $P(RORSEG,HLFS,26)=$S(TMP="P":"F",TMP="N":"R",1:"")
"RTN","RORHL12",108,0)
 ;
"RTN","RORHL12",109,0)
 ;--- OBR-44 - Division
"RTN","RORHL12",110,0)
 S $P(RORSEG,HLFS,45)=$$SITE1^RORUTL03(CS)
"RTN","RORHL12",111,0)
 ;
"RTN","RORHL12",112,0)
 ;--- Store the segment
"RTN","RORHL12",113,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL12",114,0)
 Q ERRCNT
"RTN","RORHL12",115,0)
 ;
"RTN","RORHL12",116,0)
 ;
"RTN","RORHL12",117,0)
 ;
"RTN","RORHL121")
0^113^B77104692
"RTN","RORHL121",1,0)
RORHL121 ;HOIFO/BH - HL7 MICROBIOLOGY DATA: OBR,OBX ; 8/20/03 2:48pm
"RTN","RORHL121",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL121",3,0)
 ;
"RTN","RORHL121",4,0)
 ;***** MICROBIOLOGY OBX SEGMENT(S) BUILDER
"RTN","RORHL121",5,0)
 ;
"RTN","RORHL121",6,0)
 ; RORREF        Global reference for MI entry
"RTN","RORHL121",7,0)
 ;
"RTN","RORHL121",8,0)
 ; Return Values:
"RTN","RORHL121",9,0)
 ;       <0  Error code
"RTN","RORHL121",10,0)
 ;        0  Ok
"RTN","RORHL121",11,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL121",12,0)
 ;
"RTN","RORHL121",13,0)
OBX(RORREF) ;
"RTN","RORHL121",14,0)
 N CS,ERRCNT,RORTBST,IEN,RC,RORID,TMP
"RTN","RORHL121",15,0)
 S (ERRCNT,RC)=0
"RTN","RORHL121",16,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL121",17,0)
 S CS=$E(HLECH)
"RTN","RORHL121",18,0)
 ;
"RTN","RORHL121",19,0)
 ;--- Process TB data if Final report
"RTN","RORHL121",20,0)
 S RORTBST=$G(@RORREF@(0,23,"I"))
"RTN","RORHL121",21,0)
 I RORTBST="F" D
"RTN","RORHL121",22,0)
 . S RORID=$$SEGID("AFB-SP","TB Report",CS)
"RTN","RORHL121",23,0)
 . N RORTBDTE,RORTBAFS,RORTBQTY
"RTN","RORHL121",24,0)
 . S RORTBDTE=$G(@RORREF@(0,22,"I"))
"RTN","RORHL121",25,0)
 . I RORTBDTE'="" S RORTBDTE=$$FMTHL7^XLFDT(RORTBDTE)
"RTN","RORHL121",26,0)
 . S RORTBAFS=$G(@RORREF@(0,24,"I"))
"RTN","RORHL121",27,0)
 . S RORTBQTY=$G(@RORREF@(0,25,"I"))
"RTN","RORHL121",28,0)
 . D SETOBX(RORID,,RORTBST,RORTBQTY,RORTBAFS,RORTBDTE)
"RTN","RORHL121",29,0)
 ;
"RTN","RORHL121",30,0)
 ;--- Get Bact RPT Remark Data
"RTN","RORHL121",31,0)
 S RORID=$$SEGID("BACT","Bact",CS)
"RTN","RORHL121",32,0)
 S IEN=""
"RTN","RORHL121",33,0)
 F  S IEN=$O(@RORREF@(4,IEN))  Q:'IEN  D
"RTN","RORHL121",34,0)
 . S TMP=$G(@RORREF@(4,IEN,0,.01,"E"))
"RTN","RORHL121",35,0)
 . D:TMP'="" SETOBX(RORID,,TMP)
"RTN","RORHL121",36,0)
 ;
"RTN","RORHL121",37,0)
 ;--- Get Gram Stain Data
"RTN","RORHL121",38,0)
 S RORID=$$SEGID("GRAM","Gram Stain",CS)
"RTN","RORHL121",39,0)
 S IEN=""
"RTN","RORHL121",40,0)
 F  S IEN=$O(@RORREF@(2,IEN))  Q:'IEN  D
"RTN","RORHL121",41,0)
 . S TMP=$G(@RORREF@(2,IEN,0,.01,"E"))
"RTN","RORHL121",42,0)
 . D:TMP'="" SETOBX(RORID,,TMP)
"RTN","RORHL121",43,0)
 ;
"RTN","RORHL121",44,0)
 D ORGDATA  ; Organism Data
"RTN","RORHL121",45,0)
 D PARDATA  ; Parasite Data
"RTN","RORHL121",46,0)
 D FUNGUS   ; Fungus/Yeast Data
"RTN","RORHL121",47,0)
 D MYCO     ; Mycobacterium Data
"RTN","RORHL121",48,0)
 D VIRUS    ; Virus Data
"RTN","RORHL121",49,0)
 D PARASP   ; Parasitology Smear/Prep
"RTN","RORHL121",50,0)
 D BACSP    ; Bacteriology Smear/Prep
"RTN","RORHL121",51,0)
 D MYCOSP   ; Mycology Smear Prep
"RTN","RORHL121",52,0)
 D VIRORPT  ; Virology RPT Remark
"RTN","RORHL121",53,0)
 ;
"RTN","RORHL121",54,0)
 ;
"RTN","RORHL121",55,0)
 ;--- Parasite Remark
"RTN","RORHL121",56,0)
 S RORID=$$SEGID("PARP","Parasite Remark",CS)
"RTN","RORHL121",57,0)
 S IEN=""
"RTN","RORHL121",58,0)
 F  S IEN=$O(@RORREF@(7,IEN))  Q:IEN=""  D
"RTN","RORHL121",59,0)
 . S TMP=$G(@RORREF@(7,IEN,0,.01,"E"))
"RTN","RORHL121",60,0)
 . D:TMP'="" SETOBX(RORID,,TMP)
"RTN","RORHL121",61,0)
 ;
"RTN","RORHL121",62,0)
 ;--- Specimen Comments
"RTN","RORHL121",63,0)
 S TMP=$G(@RORREF@(0,.99,"E"))
"RTN","RORHL121",64,0)
 I TMP'=""  D  D SETOBX(RORID,,TMP)
"RTN","RORHL121",65,0)
 . S RORID=$$SEGID("COMP","Specimen Comment",CS)
"RTN","RORHL121",66,0)
 ;
"RTN","RORHL121",67,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL121",68,0)
 ;
"RTN","RORHL121",69,0)
VIRORPT ;***** Virology RPT Remark
"RTN","RORHL121",70,0)
 ;
"RTN","RORHL121",71,0)
 N RORVRID,RORVRIEN
"RTN","RORHL121",72,0)
 S RORVRID=$$SEGID("VIRUSR","Virology RPT",CS)
"RTN","RORHL121",73,0)
 ;
"RTN","RORHL121",74,0)
 S RORVRIEN=""
"RTN","RORHL121",75,0)
 F  S RORVRIEN=$O(@RORREF@(18,RORVRIEN))  Q:'RORVRIEN  D
"RTN","RORHL121",76,0)
 . S TMP=$G(@RORREF@(18,RORVRIEN,0,.01,"E"))
"RTN","RORHL121",77,0)
 . Q:TMP=""
"RTN","RORHL121",78,0)
 . D SETOBX(RORVRID,,TMP)
"RTN","RORHL121",79,0)
 Q
"RTN","RORHL121",80,0)
 ;
"RTN","RORHL121",81,0)
MYCOSP ;***** Mycology Smear Prep
"RTN","RORHL121",82,0)
 ;
"RTN","RORHL121",83,0)
 N RORMSPID,RORMSPIN
"RTN","RORHL121",84,0)
 S RORMSPID=$$SEGID("MYCO-SP","Mycology Smear/Prep",CS)
"RTN","RORHL121",85,0)
 ;
"RTN","RORHL121",86,0)
 S RORMSPIN=""
"RTN","RORHL121",87,0)
 F  S RORMSPIN=$O(@RORREF@(15,RORMSPIN))  Q:'RORMSPIN  D
"RTN","RORHL121",88,0)
 . S TMP=$G(@RORREF@(15,RORMSPIN,0,.01,"E"))
"RTN","RORHL121",89,0)
 . Q:TMP=""
"RTN","RORHL121",90,0)
 . D SETOBX(RORMSPID,,TMP)
"RTN","RORHL121",91,0)
 Q
"RTN","RORHL121",92,0)
 ;
"RTN","RORHL121",93,0)
BACSP ;***** Bacteriology Smear/Prep
"RTN","RORHL121",94,0)
 ;
"RTN","RORHL121",95,0)
 N RORBSPID,RORBSP
"RTN","RORHL121",96,0)
 S RORBSPID=$$SEGID("BACT-SP","Bact Smear/Prep",CS)
"RTN","RORHL121",97,0)
 ;
"RTN","RORHL121",98,0)
 S RORBSP=""
"RTN","RORHL121",99,0)
 F  S RORBSP=$O(@RORREF@(25,RORBSP))  Q:'RORBSP  D
"RTN","RORHL121",100,0)
 . S TMP=$G(@RORREF@(25,RORBSP,0,.01,"E"))
"RTN","RORHL121",101,0)
 . Q:TMP=""
"RTN","RORHL121",102,0)
 . D SETOBX(RORBSPID,,TMP)
"RTN","RORHL121",103,0)
 Q
"RTN","RORHL121",104,0)
 ;
"RTN","RORHL121",105,0)
PARASP ;***** Parasitology Smear/Prep
"RTN","RORHL121",106,0)
 ;
"RTN","RORHL121",107,0)
 N RORPSPID,RORPSP
"RTN","RORHL121",108,0)
 S RORPSPID=$$SEGID("PARA-SP","Para Smear/Prep",CS)
"RTN","RORHL121",109,0)
 ;
"RTN","RORHL121",110,0)
 S RORPSP=""
"RTN","RORHL121",111,0)
 F  S RORPSP=$O(@RORREF@(24,RORPSP))  Q:'RORPSP  D
"RTN","RORHL121",112,0)
 . S TMP=$G(@RORREF@(24,RORPSP,0,.01,"E"))
"RTN","RORHL121",113,0)
 . Q:TMP=""
"RTN","RORHL121",114,0)
 . D SETOBX(RORPSPID,,TMP)
"RTN","RORHL121",115,0)
 Q
"RTN","RORHL121",116,0)
 ;
"RTN","RORHL121",117,0)
VIRUS ;***** Virus
"RTN","RORHL121",118,0)
 ;
"RTN","RORHL121",119,0)
 N RORVIRID,RORVIIEN
"RTN","RORHL121",120,0)
 S RORVIRID=$$SEGID("VIRUS","Virus",CS)
"RTN","RORHL121",121,0)
 ;
"RTN","RORHL121",122,0)
 S RORVIIEN=""
"RTN","RORHL121",123,0)
 F  S RORVIIEN=$O(@RORREF@(17,RORVIIEN))  Q:'RORVIIEN  D
"RTN","RORHL121",124,0)
 . S TMP=$G(@RORREF@(17,RORVIIEN,0,.01,"E"))
"RTN","RORHL121",125,0)
 . Q:TMP=""
"RTN","RORHL121",126,0)
 . D SETOBX(RORVIRID,,TMP)
"RTN","RORHL121",127,0)
 Q
"RTN","RORHL121",128,0)
 ;
"RTN","RORHL121",129,0)
 ;
"RTN","RORHL121",130,0)
MYCO ;***** Mycobacterium
"RTN","RORHL121",131,0)
 ;
"RTN","RORHL121",132,0)
 N RORMYD,RORMYD1,RORDF,RORDO,RORMYIEN,RORMYID,RORMYCM,MYIEN,RORMYF,RORMYO
"RTN","RORHL121",133,0)
 S RORMYID=$$SEGID("MYCO","Mycobacterium",CS)
"RTN","RORHL121",134,0)
 S RORMYCM=$$SEGID("MYCOC","Myco Comment",CS)
"RTN","RORHL121",135,0)
 S RORMYF=$$SEGID("MYCOAF","Myco Anti-F",CS)
"RTN","RORHL121",136,0)
 S RORMYO=$$SEGID("MYCOAO","Myco Anti-O",CS)
"RTN","RORHL121",137,0)
 ;
"RTN","RORHL121",138,0)
 S RORMYIEN=""
"RTN","RORHL121",139,0)
 ;
"RTN","RORHL121",140,0)
 F  S RORMYIEN=$O(@RORREF@(12,RORMYIEN))  Q:'RORMYIEN  D
"RTN","RORHL121",141,0)
 . N TMP1
"RTN","RORHL121",142,0)
 . S TMP=$G(@RORREF@(12,RORMYIEN,0,.01,"E"))
"RTN","RORHL121",143,0)
 . Q:TMP=""
"RTN","RORHL121",144,0)
 . D SETOBX(RORMYID,,TMP,$G(@RORREF@(12,RORMYIEN,0,1,"I")))
"RTN","RORHL121",145,0)
 . ;---
"RTN","RORHL121",146,0)
 . S MYIEN=""
"RTN","RORHL121",147,0)
 . F  S MYIEN=$O(@RORREF@(12,RORMYIEN,1,MYIEN))  Q:MYIEN=""  D
"RTN","RORHL121",148,0)
 . . S TMP=$G(@RORREF@(12,RORMYIEN,1,MYIEN,0,.01,"E"))
"RTN","RORHL121",149,0)
 . . D:TMP'="" SETOBX(RORMYCM,,TMP)
"RTN","RORHL121",150,0)
 . ;
"RTN","RORHL121",151,0)
 . S RORMYD=2
"RTN","RORHL121",152,0)
 . F  S RORMYD=$O(@RORREF@(12,RORMYIEN,0,RORMYD)) Q:'RORMYD!(RORMYD'<3)  D
"RTN","RORHL121",153,0)
 . . S TMP=$G(@RORREF@(12,RORMYIEN,0,RORMYD,"I"))
"RTN","RORHL121",154,0)
 . . I TMP="" Q
"RTN","RORHL121",155,0)
 . . S TMP1=$P(TMP,U,2),TMP=$P(TMP,U)
"RTN","RORHL121",156,0)
 . . D SETOBX(RORMYF,,TMP_CS_TMP1)
"RTN","RORHL121",157,0)
 . ;
"RTN","RORHL121",158,0)
 . S RORMYD1=4
"RTN","RORHL121",159,0)
 . F  S RORMYD1=$O(@RORREF@(12,RORMYIEN,0,RORMYD1)) Q:'RORMYD1!(RORMYD1'<56)  D
"RTN","RORHL121",160,0)
 . . S TMP=$G(@RORREF@(12,RORMYIEN,0,RORMYD1,"I"))
"RTN","RORHL121",161,0)
 . . I TMP="" Q
"RTN","RORHL121",162,0)
 . . S TMP1=$P(TMP,U,2),TMP=$P(TMP,U)
"RTN","RORHL121",163,0)
 . . D SETOBX(RORMYO,,TMP_CS_TMP1)
"RTN","RORHL121",164,0)
 . ;
"RTN","RORHL121",165,0)
 ;
"RTN","RORHL121",166,0)
 Q
"RTN","RORHL121",167,0)
 ;
"RTN","RORHL121",168,0)
 ;
"RTN","RORHL121",169,0)
FUNGUS ;***** Process Fungus/Yeast
"RTN","RORHL121",170,0)
 ;
"RTN","RORHL121",171,0)
 N FYIEN,RORFYIEN,RORFYID,RORFYCM
"RTN","RORHL121",172,0)
 ;
"RTN","RORHL121",173,0)
 S RORFYID=$$SEGID("FUNG","Fungus-Yeast",CS)
"RTN","RORHL121",174,0)
 S RORFYCM=$$SEGID("FUNGC","F-Y Comment",CS)
"RTN","RORHL121",175,0)
 S RORFYIEN=""
"RTN","RORHL121",176,0)
 F  S RORFYIEN=$O(@RORREF@(9,RORFYIEN))  Q:'RORFYIEN  D
"RTN","RORHL121",177,0)
 . S TMP=$G(@RORREF@(9,RORFYIEN,0,.01,"E"))
"RTN","RORHL121",178,0)
 . Q:TMP=""
"RTN","RORHL121",179,0)
 . D SETOBX(RORFYID,,TMP,$G(@RORREF@(9,RORFYIEN,0,1,"I")))
"RTN","RORHL121",180,0)
 . ;---
"RTN","RORHL121",181,0)
 . S FYIEN=""
"RTN","RORHL121",182,0)
 . F  S FYIEN=$O(@RORREF@(9,RORFYIEN,1,FYIEN))  Q:FYIEN=""  D
"RTN","RORHL121",183,0)
 . . S TMP=$G(@RORREF@(9,RORFYIEN,1,FYIEN,0,.01,"E"))
"RTN","RORHL121",184,0)
 . . D:TMP'="" SETOBX(RORFYCM,,TMP)
"RTN","RORHL121",185,0)
 ;
"RTN","RORHL121",186,0)
 Q
"RTN","RORHL121",187,0)
 ;
"RTN","RORHL121",188,0)
 ;
"RTN","RORHL121",189,0)
 ;
"RTN","RORHL121",190,0)
 ;***** PROCESSES ORGANISM DATA
"RTN","RORHL121",191,0)
ORGDATA ;
"RTN","RORHL121",192,0)
 N IEN,RORANTID,RORCMID,RORID,RORMBC,RORMIC,RORORIEN,TMP,RORAINX,RORAINX1,RORANTIF,RORANTIO
"RTN","RORHL121",193,0)
 S RORID=$$SEGID("ORG","Organism",CS)
"RTN","RORHL121",194,0)
 S RORCMID=$$SEGID("ORGC","Org Comment",CS)
"RTN","RORHL121",195,0)
 S RORANTID=$$SEGID("ORGA","Org Antibiotic",CS)
"RTN","RORHL121",196,0)
 S RORANTIF=$$SEGID("ORGAF","Org Antibiotic-F",CS)
"RTN","RORHL121",197,0)
 S RORANTIO=$$SEGID("ORGAO","Org Antibiotic-O",CS)
"RTN","RORHL121",198,0)
 ;---
"RTN","RORHL121",199,0)
 S RORORIEN=""
"RTN","RORHL121",200,0)
 F  S RORORIEN=$O(@RORREF@(3,RORORIEN))  Q:'RORORIEN  D
"RTN","RORHL121",201,0)
 . N TMP1
"RTN","RORHL121",202,0)
 . S TMP=$G(@RORREF@(3,RORORIEN,0,.01,"E"))
"RTN","RORHL121",203,0)
 . Q:TMP=""
"RTN","RORHL121",204,0)
 . D SETOBX(RORID,,TMP,$G(@RORREF@(3,RORORIEN,0,1,"I")))
"RTN","RORHL121",205,0)
 . ;---
"RTN","RORHL121",206,0)
 . ;
"RTN","RORHL121",207,0)
 . S RORAINX=2
"RTN","RORHL121",208,0)
 . F  S RORAINX=$O(@RORREF@(3,RORORIEN,0,RORAINX)) Q:'RORAINX!(RORAINX'<3)  D
"RTN","RORHL121",209,0)
 . . S TMP=$G(@RORREF@(3,RORORIEN,0,RORAINX,"I"))
"RTN","RORHL121",210,0)
 . . I TMP="" Q
"RTN","RORHL121",211,0)
 . . S TMP1=$P(TMP,U,2),TMP=$P(TMP,U)
"RTN","RORHL121",212,0)
 . . D SETOBX(RORANTIF,,TMP_CS_TMP1)
"RTN","RORHL121",213,0)
 . ;
"RTN","RORHL121",214,0)
 . S RORAINX1=10
"RTN","RORHL121",215,0)
 . F  S RORAINX1=$O(@RORREF@(3,RORORIEN,0,RORAINX1)) Q:'RORAINX1!(RORAINX1'<160)  D
"RTN","RORHL121",216,0)
 . . S TMP=$G(@RORREF@(3,RORORIEN,0,RORAINX1,"I"))
"RTN","RORHL121",217,0)
 . . I TMP="" Q
"RTN","RORHL121",218,0)
 . . S TMP1=$P(TMP,U,2),TMP=$P(TMP,U)
"RTN","RORHL121",219,0)
 . . D SETOBX(RORANTIO,,TMP_CS_TMP1)
"RTN","RORHL121",220,0)
 . ;
"RTN","RORHL121",221,0)
 . ;---
"RTN","RORHL121",222,0)
 . S IEN=""
"RTN","RORHL121",223,0)
 . F  S IEN=$O(@RORREF@(3,RORORIEN,1,IEN))  Q:IEN=""  D
"RTN","RORHL121",224,0)
 . . S TMP=$G(@RORREF@(3,RORORIEN,1,IEN,0,.01,"E"))
"RTN","RORHL121",225,0)
 . . D:TMP'="" SETOBX(RORCMID,,TMP)
"RTN","RORHL121",226,0)
 . ;---
"RTN","RORHL121",227,0)
 . S IEN=""
"RTN","RORHL121",228,0)
 . F  S IEN=$O(@RORREF@(3,RORORIEN,3,IEN))  Q:IEN=""  D
"RTN","RORHL121",229,0)
 . . S TMP=$G(@RORREF@(3,RORORIEN,3,IEN,0,.01,"E"))
"RTN","RORHL121",230,0)
 . . Q:TMP=""
"RTN","RORHL121",231,0)
 . . S RORMIC=$G(@RORREF@(3,RORORIEN,3,IEN,0,1,"E"))
"RTN","RORHL121",232,0)
 . . S RORMBC=$G(@RORREF@(3,RORORIEN,3,IEN,0,2,"E"))
"RTN","RORHL121",233,0)
 . . D SETOBX(RORANTID,,TMP,,RORMIC_CS_RORMBC)
"RTN","RORHL121",234,0)
 Q
"RTN","RORHL121",235,0)
 ;
"RTN","RORHL121",236,0)
 ;***** PROCESSES PARASITE DATA
"RTN","RORHL121",237,0)
PARDATA ;
"RTN","RORHL121",238,0)
 N IEN,RORPCMID,RORPSID,RORPSIEN,RORSTID,RORSTIEN,RORSTQAN,TMP
"RTN","RORHL121",239,0)
 S RORPSID=$$SEGID("PAR","Parasite",CS)
"RTN","RORHL121",240,0)
 S RORSTID=$$SEGID("PARQ","Stage",CS)
"RTN","RORHL121",241,0)
 S RORPCMID=$$SEGID("PARC","Comment",CS)
"RTN","RORHL121",242,0)
 ;---
"RTN","RORHL121",243,0)
 S RORPSIEN=""
"RTN","RORHL121",244,0)
 F  S RORPSIEN=$O(@RORREF@(6,RORPSIEN))  Q:RORPSIEN=""  D
"RTN","RORHL121",245,0)
 . S TMP=$G(@RORREF@(6,RORPSIEN,"0",".01","E"))
"RTN","RORHL121",246,0)
 . Q:TMP=""
"RTN","RORHL121",247,0)
 . D SETOBX(RORPSID,,TMP)
"RTN","RORHL121",248,0)
 . ;---
"RTN","RORHL121",249,0)
 . S RORSTIEN=""
"RTN","RORHL121",250,0)
 . F  S RORSTIEN=$O(@RORREF@(6,RORPSIEN,1,RORSTIEN)) Q:RORSTIEN=""  D
"RTN","RORHL121",251,0)
 . . S TMP=$G(@RORREF@(6,RORPSIEN,1,RORSTIEN,0,.01,"I"))
"RTN","RORHL121",252,0)
 . . Q:TMP=""
"RTN","RORHL121",253,0)
 . . S RORSTQAN=$G(@RORREF@(6,RORPSIEN,1,RORSTIEN,0,"1","E"))
"RTN","RORHL121",254,0)
 . . D SETOBX(RORSTID,,TMP,RORSTQAN)
"RTN","RORHL121",255,0)
 . . ;---
"RTN","RORHL121",256,0)
 . . S IEN=""
"RTN","RORHL121",257,0)
 . . F  S IEN=$O(@RORREF@(6,RORPSIEN,1,RORSTIEN,1,IEN))  Q:IEN=""  D
"RTN","RORHL121",258,0)
 . . . S TMP=$G(@RORREF@(6,RORPSIEN,1,RORSTIEN,1,IEN,0,.01,"E"))
"RTN","RORHL121",259,0)
 . . . D:TMP'="" SETOBX(RORPCMID,,TMP)
"RTN","RORHL121",260,0)
 Q
"RTN","RORHL121",261,0)
 ;
"RTN","RORHL121",262,0)
 ;***** CREATES SEGMENT IDENTIFIER
"RTN","RORHL121",263,0)
SEGID(PONE,PTWO,CS) ;
"RTN","RORHL121",264,0)
 Q PONE_CS_PTWO_CS_"VA080"
"RTN","RORHL121",265,0)
 ;
"RTN","RORHL121",266,0)
 ;***** CREATES AND STORES THE OBX SEGMENT
"RTN","RORHL121",267,0)
SETOBX(PIECE3,PIECE4,PIECE5,PIECE6,PIECE7,PIECE14) ;
"RTN","RORHL121",268,0)
 N RORSEG
"RTN","RORHL121",269,0)
 I PIECE5["|" S PIECE5=$$ESCAPE^RORHL7(PIECE5)
"RTN","RORHL121",270,0)
 I $G(PIECE(7))'="",PIECE7["|" S PIECE(7)=$$ESCAPE^RORHL7(PIECE7)
"RTN","RORHL121",271,0)
 ;--- Initialize the segment
"RTN","RORHL121",272,0)
 S RORSEG="OBX"
"RTN","RORHL121",273,0)
 ;--- OBX-2
"RTN","RORHL121",274,0)
 S $P(RORSEG,HLFS,3)="FT"
"RTN","RORHL121",275,0)
 ;---
"RTN","RORHL121",276,0)
 S $P(RORSEG,HLFS,4)=PIECE3
"RTN","RORHL121",277,0)
 S:$G(PIECE4)'="" $P(RORSEG,HLFS,5)=PIECE4
"RTN","RORHL121",278,0)
 S $P(RORSEG,HLFS,6)=PIECE5
"RTN","RORHL121",279,0)
 S:$G(PIECE6)'="" $P(RORSEG,HLFS,7)=PIECE6
"RTN","RORHL121",280,0)
 S:$G(PIECE7)'="" $P(RORSEG,HLFS,8)=PIECE7
"RTN","RORHL121",281,0)
 S:$G(PIECE14)'="" $P(RORSEG,HLFS,15)=PIECE14
"RTN","RORHL121",282,0)
 ;--- OBX-11
"RTN","RORHL121",283,0)
 S $P(RORSEG,HLFS,12)="F"
"RTN","RORHL121",284,0)
 ;--- Store the segment
"RTN","RORHL121",285,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL121",286,0)
 Q
"RTN","RORHL13")
0^45^B18586045
"RTN","RORHL13",1,0)
RORHL13 ;HOIFO/BH - HL7 MEDICAL PROCEDURES (EKG): OBR,OBX ; 7/21/03 10:12am
"RTN","RORHL13",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL13",3,0)
 ;
"RTN","RORHL13",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL13",5,0)
 ;
"RTN","RORHL13",6,0)
 ; #3780         GET^MCARAPI (private)
"RTN","RORHL13",7,0)
 ; #3854         GET^MDAPI1 (private)
"RTN","RORHL13",8,0)
 ;
"RTN","RORHL13",9,0)
 Q
"RTN","RORHL13",10,0)
 ;
"RTN","RORHL13",11,0)
 ;***** SEARCHES FOR MEDICAL PROCEDURES (EKG)
"RTN","RORHL13",12,0)
 ;
"RTN","RORHL13",13,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL13",14,0)
 ;
"RTN","RORHL13",15,0)
 ; RORSTDT       Start Date (FileMan)
"RTN","RORHL13",16,0)
 ; RORENDT       End Date   (FileMan)
"RTN","RORHL13",17,0)
 ;
"RTN","RORHL13",18,0)
 ; Return Values:
"RTN","RORHL13",19,0)
 ;       <0  Error code
"RTN","RORHL13",20,0)
 ;        0  Ok
"RTN","RORHL13",21,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL13",22,0)
 ;
"RTN","RORHL13",23,0)
 ; The function uses the ^TMP("RORHL13",$J) global node.
"RTN","RORHL13",24,0)
 ;
"RTN","RORHL13",25,0)
EN1(RORDFN,RORSTDT,RORENDT) ;
"RTN","RORHL13",26,0)
 N ERRCNT,RC,RORESULT,RORIENS,SF,TMP
"RTN","RORHL13",27,0)
 S (ERRCNT,RC)=0
"RTN","RORHL13",28,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL13",29,0)
 ;
"RTN","RORHL13",30,0)
 S RORESULT=$NA(^TMP("RORHL13",$J))  K @RORESULT
"RTN","RORHL13",31,0)
 ;
"RTN","RORHL13",32,0)
 ;--- Check if Clinical Procedures patch has been installed,
"RTN","RORHL13",33,0)
 ;--- if not call the API associated with the Medicine Patch.
"RTN","RORHL13",34,0)
 ;
"RTN","RORHL13",35,0)
 S TMP=".01;.02;11;14;20;21;18"
"RTN","RORHL13",36,0)
 I $D(ROREXT("PATCH","MD*1.0*1"))  D
"RTN","RORHL13",37,0)
 . D GET^MDAPI1(RORESULT,RORDFN,RORSTDT,RORENDT,TMP)
"RTN","RORHL13",38,0)
 E  I $D(ROREXT("PATCH","MC*2.3*34"))  D
"RTN","RORHL13",39,0)
 . D GET^MCARAPI(RORESULT,RORDFN,RORSTDT,RORENDT,TMP)
"RTN","RORHL13",40,0)
 E  Q ERRCNT+1
"RTN","RORHL13",41,0)
 ;
"RTN","RORHL13",42,0)
 ;--- Build the index
"RTN","RORHL13",43,0)
 F SF=691.54  S TMP=""  D
"RTN","RORHL13",44,0)
 . F  S TMP=$O(@RORESULT@(SF,TMP))  Q:TMP=""  D
"RTN","RORHL13",45,0)
 . . S @RORESULT@("A",SF,$P(TMP,",",2)_",",TMP)=""
"RTN","RORHL13",46,0)
 ;
"RTN","RORHL13",47,0)
 ;--- Process the data
"RTN","RORHL13",48,0)
 S RORIENS=""
"RTN","RORHL13",49,0)
 F  S RORIENS=$O(@RORESULT@(691.5,RORIENS))  Q:RORIENS=""  D
"RTN","RORHL13",50,0)
 . S RC=$$OBR(RORIENS)
"RTN","RORHL13",51,0)
 . I RC  S ERRCNT=ERRCNT+1  Q:RC<0
"RTN","RORHL13",52,0)
 . S RC=$$OBX(RORIENS)
"RTN","RORHL13",53,0)
 . I RC  S ERRCNT=ERRCNT+1  Q:RC<0
"RTN","RORHL13",54,0)
 ;
"RTN","RORHL13",55,0)
 K @RORESULT
"RTN","RORHL13",56,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL13",57,0)
 ;
"RTN","RORHL13",58,0)
 ;***** MEDICAL PROCEDURE (EKG) OBR SEGMENT BUILDER
"RTN","RORHL13",59,0)
 ;
"RTN","RORHL13",60,0)
 ; RORIENS       Medical Procedure Record IENS
"RTN","RORHL13",61,0)
 ;
"RTN","RORHL13",62,0)
 ; Return Values:
"RTN","RORHL13",63,0)
 ;       <0  Error code
"RTN","RORHL13",64,0)
 ;        0  Ok
"RTN","RORHL13",65,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL13",66,0)
 ;
"RTN","RORHL13",67,0)
OBR(RORIENS) ;
"RTN","RORHL13",68,0)
 N CS,ERRCNT,IEN,RC,ROROUT,RORSEG,TMP
"RTN","RORHL13",69,0)
 S (ERRCNT,RC)=0
"RTN","RORHL13",70,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL13",71,0)
 S CS=$E(HLECH,1)
"RTN","RORHL13",72,0)
 ;
"RTN","RORHL13",73,0)
 ;--- Initialize the segment
"RTN","RORHL13",74,0)
 S RORSEG="OBR"
"RTN","RORHL13",75,0)
 ;
"RTN","RORHL13",76,0)
 ;--- OBR-3
"RTN","RORHL13",77,0)
 S $P(RORSEG,HLFS,4)=$TR(RORIENS,",")
"RTN","RORHL13",78,0)
 ;
"RTN","RORHL13",79,0)
 ;--- OBR-4 - Universal Service ID
"RTN","RORHL13",80,0)
 S $P(RORSEG,HLFS,5)="93000"_CS_"ELECTROCARDIOGRAM"_CS_"C4"
"RTN","RORHL13",81,0)
 ;
"RTN","RORHL13",82,0)
 ;--- OBR-6 - Requested Date/time
"RTN","RORHL13",83,0)
 S TMP=$$DATE($G(@RORESULT@(691.5,RORIENS,.01,"E")))
"RTN","RORHL13",84,0)
 Q:TMP'>0 $$ERROR^RORERR(-95,,,,691.5,RORIENS,.01)
"RTN","RORHL13",85,0)
 S $P(RORSEG,HLFS,7)=TMP
"RTN","RORHL13",86,0)
 ;
"RTN","RORHL13",87,0)
 ;--- OBR-7 - Observation Date/Time
"RTN","RORHL13",88,0)
 S TMP=$$DATE($G(@RORESULT@(691.5,RORIENS,21,"E")))
"RTN","RORHL13",89,0)
 Q:TMP'>0 $$ERROR^RORERR(-95,,,,691.5,RORIENS,21)
"RTN","RORHL13",90,0)
 S $P(RORSEG,HLFS,8)=TMP
"RTN","RORHL13",91,0)
 ;
"RTN","RORHL13",92,0)
 ;--- OBR-24 - Diagnostic Service ID
"RTN","RORHL13",93,0)
 S $P(RORSEG,HLFS,25)="EC"
"RTN","RORHL13",94,0)
 ;
"RTN","RORHL13",95,0)
 ;--- OBR-25 -
"RTN","RORHL13",96,0)
 S TMP=$G(@RORESULT@(691.5,RORIENS,11,"E"))
"RTN","RORHL13",97,0)
 I TMP'=""  D  S $P(RORSEG,HLFS,26)=TMP
"RTN","RORHL13",98,0)
 . S TMP=$S(TMP="CONFIRMED":"F",TMP="UNCONFIRMED":"R",1:"")
"RTN","RORHL13",99,0)
 ;
"RTN","RORHL13",100,0)
 ;--- OBR-44 - Division
"RTN","RORHL13",101,0)
 S TMP=$G(@RORESULT@(691.5,RORIENS,18,"E"))
"RTN","RORHL13",102,0)
 S IEN=$S(TMP'="":+$O(^SC("B",TMP,0)),1:0)
"RTN","RORHL13",103,0)
 S $P(RORSEG,HLFS,45)=$$DIV44^RORHLUT1(IEN,1,CS)
"RTN","RORHL13",104,0)
 ;
"RTN","RORHL13",105,0)
 ;--- Store the segment
"RTN","RORHL13",106,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL13",107,0)
 Q ERRCNT
"RTN","RORHL13",108,0)
 ;
"RTN","RORHL13",109,0)
 ;***** MEDICAL PROCEDURE (EKG) OBX SEGMENT(S) BUILDER
"RTN","RORHL13",110,0)
 ;
"RTN","RORHL13",111,0)
 ; RORIENS       Medical Procedure Record IENS
"RTN","RORHL13",112,0)
 ;
"RTN","RORHL13",113,0)
 ; Return Values:
"RTN","RORHL13",114,0)
 ;       <0  Error code
"RTN","RORHL13",115,0)
 ;        0  Ok
"RTN","RORHL13",116,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL13",117,0)
 ;
"RTN","RORHL13",118,0)
OBX(RORIENS) ;
"RTN","RORHL13",119,0)
 N CS,ERRCNT,RC,RORID,RORINT,RORKEY,RORMOD,RORSEG,TMP
"RTN","RORHL13",120,0)
 S (ERRCNT,RC)=0
"RTN","RORHL13",121,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL13",122,0)
 S CS=$E(HLECH)
"RTN","RORHL13",123,0)
 ;
"RTN","RORHL13",124,0)
 ;--- Process any interpretation data
"RTN","RORHL13",125,0)
 S RORID="INT"_CS_"Interpretation"_CS_"VA080"
"RTN","RORHL13",126,0)
 S RORKEY=""
"RTN","RORHL13",127,0)
 F  S RORKEY=$O(@RORESULT@("A",691.54,RORIENS,RORKEY))  Q:RORKEY=""  D
"RTN","RORHL13",128,0)
 . S RORINT=$G(@RORESULT@(691.54,RORKEY,.01,"E"))
"RTN","RORHL13",129,0)
 . Q:RORINT=""
"RTN","RORHL13",130,0)
 . S RORMOD=$G(@RORESULT@(691.54,RORKEY,1,"E"))
"RTN","RORHL13",131,0)
 . D SETOBX(RORID,RORMOD,RORINT)
"RTN","RORHL13",132,0)
 ;
"RTN","RORHL13",133,0)
 ;--- Process auto instrument data
"RTN","RORHL13",134,0)
 S RORID="AUTO"_CS_"Auto Instrument"_CS_"VA080"
"RTN","RORHL13",135,0)
 S RORKEY=""
"RTN","RORHL13",136,0)
 F  S RORKEY=$O(@RORESULT@(691.5,RORIENS,20,RORKEY))  Q:RORKEY=""  D
"RTN","RORHL13",137,0)
 . S TMP=$G(@RORESULT@(691.5,RORIENS,20,RORKEY))
"RTN","RORHL13",138,0)
 . D:TMP'="" SETOBX(RORID,,TMP)
"RTN","RORHL13",139,0)
 ;
"RTN","RORHL13",140,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL13",141,0)
 ;
"RTN","RORHL13",142,0)
 ;***** CONVERTS THE DATE FROM EXTERNAL TO HL7 FORMAT
"RTN","RORHL13",143,0)
DATE(DATE) ;
"RTN","RORHL13",144,0)
 N RES
"RTN","RORHL13",145,0)
 D DT^DILF(,$P(DATE,"@"),.RES)
"RTN","RORHL13",146,0)
 Q $$FM2HL^RORHL7($G(RES))
"RTN","RORHL13",147,0)
 ;
"RTN","RORHL13",148,0)
 ;***** CREATES AND STORES THE OBX SEGMENT
"RTN","RORHL13",149,0)
SETOBX(PIECE3,PIECE4,PIECE5) ;
"RTN","RORHL13",150,0)
 N RORSEG
"RTN","RORHL13",151,0)
 S PIECE5=$$ESCAPE^RORHL7(PIECE5)
"RTN","RORHL13",152,0)
 ;--- Initialize the segment
"RTN","RORHL13",153,0)
 S RORSEG="OBX"
"RTN","RORHL13",154,0)
 ;--- OBX-2
"RTN","RORHL13",155,0)
 S $P(RORSEG,HLFS,3)="FT"
"RTN","RORHL13",156,0)
 ;---
"RTN","RORHL13",157,0)
 S $P(RORSEG,HLFS,4)=PIECE3
"RTN","RORHL13",158,0)
 S:$G(PIECE4)'="" $P(RORSEG,HLFS,5)=PIECE4
"RTN","RORHL13",159,0)
 S $P(RORSEG,HLFS,6)=PIECE5
"RTN","RORHL13",160,0)
 ;--- OBX-11
"RTN","RORHL13",161,0)
 S $P(RORSEG,HLFS,12)="F"
"RTN","RORHL13",162,0)
 ;--- Store the segment
"RTN","RORHL13",163,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL13",164,0)
 Q
"RTN","RORHL14")
0^46^B30913194
"RTN","RORHL14",1,0)
RORHL14 ;HOIFO/BH - HL7 ALLERGY DATA: OBR,OBX ; 10/1/03 2:44pm
"RTN","RORHL14",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL14",3,0)
 ;
"RTN","RORHL14",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL14",5,0)
 ;
"RTN","RORHL14",6,0)
 ; #2167         Read access to the file #120.83 (controlled)
"RTN","RORHL14",7,0)
 ; #2473         Read access to the file #50.605 (controlled)
"RTN","RORHL14",8,0)
 ; #2196         Read access to the file #50.416 (controlled)
"RTN","RORHL14",9,0)
 ; #10060        Read access to the file #200 (supported)
"RTN","RORHL14",10,0)
 ;
"RTN","RORHL14",11,0)
 ;
"RTN","RORHL14",12,0)
 Q
"RTN","RORHL14",13,0)
 ;
"RTN","RORHL14",14,0)
 ;***** SEARCHES FOR ALLERGY DATA
"RTN","RORHL14",15,0)
 ;
"RTN","RORHL14",16,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL14",17,0)
 ;
"RTN","RORHL14",18,0)
 ; RORSTDT       Start Date (FileMan)
"RTN","RORHL14",19,0)
 ; RORENDT       End Date   (FileMan)
"RTN","RORHL14",20,0)
 ;
"RTN","RORHL14",21,0)
 ; Return Values:
"RTN","RORHL14",22,0)
 ;       <0  Error code
"RTN","RORHL14",23,0)
 ;        0  Ok
"RTN","RORHL14",24,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL14",25,0)
 ;
"RTN","RORHL14",26,0)
EN1(RORDFN,RORSTDT,RORENDT) ;
"RTN","RORHL14",27,0)
 N ERRCNT,RC,RORARR,RORDTE,RORIEN
"RTN","RORHL14",28,0)
 S (ERRCNT,RC)=0
"RTN","RORHL14",29,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL14",30,0)
 ;
"RTN","RORHL14",31,0)
 S RORDTE=$O(^GMR(120.8,"AODT",RORSTDT),-1)
"RTN","RORHL14",32,0)
 F  S RORDTE=$O(^GMR(120.8,"AODT",RORDTE))  Q:'RORDTE!(RORDTE'<RORENDT)  D
"RTN","RORHL14",33,0)
 . S RORIEN=0
"RTN","RORHL14",34,0)
 . F  S RORIEN=$O(^GMR(120.8,"AODT",RORDTE,RORIEN))  Q:'RORIEN  D
"RTN","RORHL14",35,0)
 . . S:$D(^GMR(120.8,"B",RORDFN,RORIEN)) RORARR(RORIEN)=""
"RTN","RORHL14",36,0)
 Q:$D(RORARR)<10 ERRCNT
"RTN","RORHL14",37,0)
 ;
"RTN","RORHL14",38,0)
 S RORIEN=0
"RTN","RORHL14",39,0)
 F  S RORIEN=$O(RORARR(RORIEN))  Q:'RORIEN  D
"RTN","RORHL14",40,0)
 . S RC=$$OBR(RORIEN,RORDFN)
"RTN","RORHL14",41,0)
 . I RC  S ERRCNT=ERRCNT+1  Q:RC<0
"RTN","RORHL14",42,0)
 . S RC=$$OBX(RORIEN,RORDFN)
"RTN","RORHL14",43,0)
 . I RC  S ERRCNT=ERRCNT+1  Q:RC<0
"RTN","RORHL14",44,0)
 ;
"RTN","RORHL14",45,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL14",46,0)
 ;
"RTN","RORHL14",47,0)
 ;***** ALLERGY OBR SEGMENT BUILDER
"RTN","RORHL14",48,0)
 ;
"RTN","RORHL14",49,0)
 ; RORAIEN       IEN of Allergy entry
"RTN","RORHL14",50,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL14",51,0)
 ;
"RTN","RORHL14",52,0)
 ; Return Values:
"RTN","RORHL14",53,0)
 ;       <0  Error code
"RTN","RORHL14",54,0)
 ;        0  Ok
"RTN","RORHL14",55,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL14",56,0)
 ;
"RTN","RORHL14",57,0)
OBR(RORAIEN,RORDFN) ;
"RTN","RORHL14",58,0)
 N BUF,CS,ERRCNT,RC,RORLST,RORMSG,RORSEG,TMP
"RTN","RORHL14",59,0)
 S (ERRCNT,RC)=0
"RTN","RORHL14",60,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL14",61,0)
 S CS=$E(HLECH,1)
"RTN","RORHL14",62,0)
 ;
"RTN","RORHL14",63,0)
 S RORAIEN=RORAIEN_","
"RTN","RORHL14",64,0)
 D GETS^DIQ(120.8,RORAIEN,".02;3.1;4;5;6","EI","RORLST","RORMSG")
"RTN","RORHL14",65,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL14",66,0)
 . D DBS^RORERR("RORMSG",-9,,RORDFN,120.8,RORAIEN)
"RTN","RORHL14",67,0)
 ;
"RTN","RORHL14",68,0)
 ;--- Initialize the segment
"RTN","RORHL14",69,0)
 S RORSEG="OBR"
"RTN","RORHL14",70,0)
 ;
"RTN","RORHL14",71,0)
 ;--- OBR-3 - IEN of record
"RTN","RORHL14",72,0)
 S $P(RORSEG,HLFS,4)=$P(RORAIEN,",")
"RTN","RORHL14",73,0)
 ;
"RTN","RORHL14",74,0)
 ;--- OBR-4 - Sevice ID
"RTN","RORHL14",75,0)
 S $P(RORSEG,HLFS,5)="95000"_CS_"ALLERGY"_CS_"C4"
"RTN","RORHL14",76,0)
 ;
"RTN","RORHL14",77,0)
 ;--- OBR-7 - Observation Date/Time
"RTN","RORHL14",78,0)
 S TMP=$$FMTHL7^XLFDT($G(RORLST(120.8,RORAIEN,4,"I")))
"RTN","RORHL14",79,0)
 Q:TMP'>0 $$ERROR^RORERR(-95,,,RORDFN,120.8,RORAIEN,4)
"RTN","RORHL14",80,0)
 S $P(RORSEG,HLFS,8)=TMP
"RTN","RORHL14",81,0)
 ;
"RTN","RORHL14",82,0)
 ;--- OBR-13 - Relevant Clinical Info.
"RTN","RORHL14",83,0)
 S $P(RORSEG,HLFS,14)=$G(RORLST(120.8,RORAIEN,.02,"E"))
"RTN","RORHL14",84,0)
 ;
"RTN","RORHL14",85,0)
 ;--- OBR-16 - Ordering Provider
"RTN","RORHL14",86,0)
 S BUF=$G(RORLST(120.8,RORAIEN,5,"I"))
"RTN","RORHL14",87,0)
 I BUF>0  D
"RTN","RORHL14",88,0)
 . S $P(BUF,CS,5)=$$GET1^DIQ(200,+BUF_",",53.5,"I",,"RORMSG")
"RTN","RORHL14",89,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL14",90,0)
 . . D DBS^RORERR("RORMSG",-99,,RORDFN,200,+BUF_",")
"RTN","RORHL14",91,0)
 . S $P(RORSEG,HLFS,17)=BUF
"RTN","RORHL14",92,0)
 ;
"RTN","RORHL14",93,0)
 ;--- OBR-20 - Filler Field 1
"RTN","RORHL14",94,0)
 S $P(RORSEG,HLFS,21)=$G(RORLST(120.8,RORAIEN,3.1,"E"))
"RTN","RORHL14",95,0)
 ;
"RTN","RORHL14",96,0)
 ;--- OBR-24 - Diagnostic Service ID
"RTN","RORHL14",97,0)
 S $P(RORSEG,HLFS,25)="TX"
"RTN","RORHL14",98,0)
 ;
"RTN","RORHL14",99,0)
 ;--- OBR-25 - Result Status
"RTN","RORHL14",100,0)
 S TMP=$G(RORLST(120.8,RORAIEN,6,"E"))
"RTN","RORHL14",101,0)
 I TMP'=""  D  S $P(RORSEG,HLFS,26)=TMP
"RTN","RORHL14",102,0)
 . S TMP=$S(TMP="HISTORICAL":"R",TMP="OBSERVED":"F",1:"")
"RTN","RORHL14",103,0)
 ;
"RTN","RORHL14",104,0)
 ;--- Store the segment
"RTN","RORHL14",105,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL14",106,0)
 Q ERRCNT
"RTN","RORHL14",107,0)
 ;
"RTN","RORHL14",108,0)
 ;***** ALLERGY OBX SEGMENT(S) BUILDER
"RTN","RORHL14",109,0)
 ;
"RTN","RORHL14",110,0)
 ; RORAIEN       IEN of Allergy entry
"RTN","RORHL14",111,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL14",112,0)
 ;
"RTN","RORHL14",113,0)
 ; Return Values:
"RTN","RORHL14",114,0)
 ;       <0  Error code
"RTN","RORHL14",115,0)
 ;        0  Ok
"RTN","RORHL14",116,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL14",117,0)
 ;
"RTN","RORHL14",118,0)
OBX(RORAIEN,RORDFN) ;
"RTN","RORHL14",119,0)
 N CS,DTE,ERRCNT,IEN,RC,REAC,RORID,RORIENS,RORKEY,RORLST,RORMSG,RORSEG,TMP
"RTN","RORHL14",120,0)
 S (ERRCNT,RC)=0,RORIENS=","_RORAIEN_","
"RTN","RORHL14",121,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL14",122,0)
 S CS=$E(HLECH)
"RTN","RORHL14",123,0)
 ;
"RTN","RORHL14",124,0)
 ;=== Ingredients
"RTN","RORHL14",125,0)
 K RORLST,RORMSG
"RTN","RORHL14",126,0)
 D LIST^DIC(120.802,RORIENS,"@;.01","I",,,,,,,"RORLST","RORMSG")
"RTN","RORHL14",127,0)
 I $G(DIERR)  D  Q RC
"RTN","RORHL14",128,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,RORDFN,120.802,RORIENS)
"RTN","RORHL14",129,0)
 S RORID="INGR"_CS_"Ingredients"_CS_"VA080"
"RTN","RORHL14",130,0)
 ;---
"RTN","RORHL14",131,0)
 S RORKEY=0
"RTN","RORHL14",132,0)
 F  S RORKEY=$O(RORLST("DILIST","ID",RORKEY))  Q:'RORKEY  D
"RTN","RORHL14",133,0)
 . S IEN=RORLST("DILIST","ID",RORKEY,.01)  Q:IEN'>0
"RTN","RORHL14",134,0)
 . S TMP=$$GET1^DIQ(50.416,IEN_",",.01,"E",,"RORMSG")
"RTN","RORHL14",135,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL14",136,0)
 . . D DBS^RORERR("RORMSG",-99,,RORDFN,50.416,IEN_",")
"RTN","RORHL14",137,0)
 . D:TMP'="" SETOBX(TMP,RORID)
"RTN","RORHL14",138,0)
 ;
"RTN","RORHL14",139,0)
 ;=== Classes
"RTN","RORHL14",140,0)
 K RORLST,RORMSG
"RTN","RORHL14",141,0)
 D LIST^DIC(120.803,RORIENS,"@;.01","I",,,,,,,"RORLST","RORMSG")
"RTN","RORHL14",142,0)
 I $G(DIERR)  D  Q RC
"RTN","RORHL14",143,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,RORDFN,120.803,RORIENS)
"RTN","RORHL14",144,0)
 S RORID="CLAS"_CS_"Drug Class"_CS_"VA080"
"RTN","RORHL14",145,0)
 ;---
"RTN","RORHL14",146,0)
 S RORKEY=0
"RTN","RORHL14",147,0)
 F  S RORKEY=$O(RORLST("DILIST","ID",RORKEY))  Q:'RORKEY  D
"RTN","RORHL14",148,0)
 . S IEN=RORLST("DILIST","ID",RORKEY,.01)  Q:IEN'>0
"RTN","RORHL14",149,0)
 . S TMP=$$GET1^DIQ(50.605,IEN_",",.01,"E",,"RORMSG")
"RTN","RORHL14",150,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL14",151,0)
 . . D DBS^RORERR("RORMSG",-99,,RORDFN,50.605,IEN_",")
"RTN","RORHL14",152,0)
 . D:TMP'="" SETOBX(TMP,RORID)
"RTN","RORHL14",153,0)
 ;
"RTN","RORHL14",154,0)
 ;=== Reactions
"RTN","RORHL14",155,0)
 K RORLST,RORMSG
"RTN","RORHL14",156,0)
 D LIST^DIC(120.81,RORIENS,"@;.01;3","I",,,,,,,"RORLST","RORMSG")
"RTN","RORHL14",157,0)
 I $G(DIERR)  D  Q RC
"RTN","RORHL14",158,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,RORDFN,120.81,RORIENS)
"RTN","RORHL14",159,0)
 S RORID="RCTS"_CS_"Reactions"_CS_"VA080"
"RTN","RORHL14",160,0)
 ;---
"RTN","RORHL14",161,0)
 S RORKEY=0
"RTN","RORHL14",162,0)
 F  S RORKEY=$O(RORLST("DILIST","ID",RORKEY))  Q:'RORKEY  D
"RTN","RORHL14",163,0)
 . S IEN=RORLST("DILIST","ID",RORKEY,.01)  Q:IEN'>0
"RTN","RORHL14",164,0)
 . S REAC=$$GET1^DIQ(120.83,IEN_",",.01,"E",,"RORMSG")
"RTN","RORHL14",165,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL14",166,0)
 . . D DBS^RORERR("RORMSG",-99,,RORDFN,120.83,IEN_",")
"RTN","RORHL14",167,0)
 . Q:REAC=""
"RTN","RORHL14",168,0)
 . S DTE=$$FM2HL^RORHL7($G(RORLST("DILIST","ID",RORKEY,3)))
"RTN","RORHL14",169,0)
 . D SETOBX(REAC,RORID,DTE)
"RTN","RORHL14",170,0)
 ;
"RTN","RORHL14",171,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL14",172,0)
 ;
"RTN","RORHL14",173,0)
 ;***** CREATES AND STORES THE OBX SEGMENT
"RTN","RORHL14",174,0)
SETOBX(PIECE5,PIECE3,PIECE12) ;
"RTN","RORHL14",175,0)
 N RORSEG
"RTN","RORHL14",176,0)
 ;--- Initialize the segment
"RTN","RORHL14",177,0)
 S RORSEG="OBX"
"RTN","RORHL14",178,0)
 ;--- OBX-2
"RTN","RORHL14",179,0)
 S $P(RORSEG,HLFS,3)="FT"
"RTN","RORHL14",180,0)
 ;---
"RTN","RORHL14",181,0)
 S $P(RORSEG,HLFS,4)=PIECE3
"RTN","RORHL14",182,0)
 S $P(RORSEG,HLFS,6)=PIECE5
"RTN","RORHL14",183,0)
 ;--- OBX-11
"RTN","RORHL14",184,0)
 S $P(RORSEG,HLFS,12)="F"
"RTN","RORHL14",185,0)
 ;---
"RTN","RORHL14",186,0)
 S:$G(PIECE12)'="" $P(RORSEG,HLFS,13)=PIECE12
"RTN","RORHL14",187,0)
 ;--- Store the segment
"RTN","RORHL14",188,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL14",189,0)
 Q
"RTN","RORHL15")
0^47^B38971403
"RTN","RORHL15",1,0)
RORHL15 ;HOIFO/BH - HL7 IV DATA: OBR, OBX ; 10/1/03 2:48pm
"RTN","RORHL15",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL15",3,0)
 ;
"RTN","RORHL15",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL15",5,0)
 ;
"RTN","RORHL15",6,0)
 ; #117          Read access to the file #55 (controlled)
"RTN","RORHL15",7,0)
 ; #436          Read access to the file #52.6 (controlled)
"RTN","RORHL15",8,0)
 ; #437          Read access to the file #52.7 (controlled)
"RTN","RORHL15",9,0)
 ; #2400         OCL^PSOORRL and OEL^PSOORRL (controlled)
"RTN","RORHL15",10,0)
 ;
"RTN","RORHL15",11,0)
 Q
"RTN","RORHL15",12,0)
 ;
"RTN","RORHL15",13,0)
 ;***** SEARCHES FOR IV DATA
"RTN","RORHL15",14,0)
 ;
"RTN","RORHL15",15,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL15",16,0)
 ;
"RTN","RORHL15",17,0)
 ; RORSTDT       Start Date (FileMan)
"RTN","RORHL15",18,0)
 ; RORENDT       End Date   (FileMan)
"RTN","RORHL15",19,0)
 ;
"RTN","RORHL15",20,0)
 ; Return Values:
"RTN","RORHL15",21,0)
 ;       <0  Error code
"RTN","RORHL15",22,0)
 ;        0  Ok
"RTN","RORHL15",23,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL15",24,0)
 ;
"RTN","RORHL15",25,0)
 ; The function uses the ^TMP("PS",$J) and ^TMP($J,"ROR-PS")
"RTN","RORHL15",26,0)
 ; global nodes.
"RTN","RORHL15",27,0)
 ;
"RTN","RORHL15",28,0)
EN1(RORDFN,RORSTDT,RORENDT) ;
"RTN","RORHL15",29,0)
 N ERRCNT,II,RC,RORII,RORORD
"RTN","RORHL15",30,0)
 S (ERRCNT,RC)=0
"RTN","RORHL15",31,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL15",32,0)
 ;
"RTN","RORHL15",33,0)
 ;--- Load the list of prescriptions
"RTN","RORHL15",34,0)
 K ^TMP("PS",$J)
"RTN","RORHL15",35,0)
 D OCL^PSOORRL(RORDFN,RORSTDT,RORENDT)
"RTN","RORHL15",36,0)
 Q:$D(^TMP("PS",$J))<10 0
"RTN","RORHL15",37,0)
 ;
"RTN","RORHL15",38,0)
 ;--- Select the prescriptions
"RTN","RORHL15",39,0)
 K ^TMP($J,"ROR-PS")
"RTN","RORHL15",40,0)
 S RORII=0
"RTN","RORHL15",41,0)
 F  S RORII=$O(^TMP("PS",$J,RORII))  Q:'RORII  D
"RTN","RORHL15",42,0)
 . S RORORD=$P(^TMP("PS",$J,RORII,0),U)
"RTN","RORHL15",43,0)
 . Q:RORORD'>0
"RTN","RORHL15",44,0)
 . S II=$P(RORORD,";"),II=$E(II,$L(II))
"RTN","RORHL15",45,0)
 . Q:II'="V"
"RTN","RORHL15",46,0)
 . ;---
"RTN","RORHL15",47,0)
 . M ^TMP($J,"ROR-PS",RORII)=^TMP("PS",$J,RORII)
"RTN","RORHL15",48,0)
 ;
"RTN","RORHL15",49,0)
 ;--- Browse through the list and generate the HL7 segments
"RTN","RORHL15",50,0)
 S RORII=0
"RTN","RORHL15",51,0)
 F  S RORII=$O(^TMP($J,"ROR-PS",RORII))  Q:'RORII  D
"RTN","RORHL15",52,0)
 . S RORORD=$P(^TMP($J,"ROR-PS",RORII,0),U)
"RTN","RORHL15",53,0)
 . S RORORD=$P(RORORD,";")
"RTN","RORHL15",54,0)
 . S RORORD=$E(RORORD,1,$L(RORORD)-1)
"RTN","RORHL15",55,0)
 . ;---
"RTN","RORHL15",56,0)
 . S TMP=$$OBR(RORORD,RORDFN)
"RTN","RORHL15",57,0)
 . I TMP  S ERRCNT=ERRCNT+1  Q:RC<0
"RTN","RORHL15",58,0)
 . S TMP=$$OBX(RORORD,RORDFN)
"RTN","RORHL15",59,0)
 . I TMP  S ERRCNT=ERRCNT+1  Q:RC<0
"RTN","RORHL15",60,0)
 ;
"RTN","RORHL15",61,0)
 K ^TMP("PS",$J),^TMP($J,"ROR-PS")
"RTN","RORHL15",62,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL15",63,0)
 ;
"RTN","RORHL15",64,0)
 ;***** IV OBR SEGMENT BUILDER
"RTN","RORHL15",65,0)
 ;
"RTN","RORHL15",66,0)
 ; RORORD        Order Number
"RTN","RORHL15",67,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL15",68,0)
 ;
"RTN","RORHL15",69,0)
 ; Return Values:
"RTN","RORHL15",70,0)
 ;       <0  Error code
"RTN","RORHL15",71,0)
 ;        0  Ok
"RTN","RORHL15",72,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL15",73,0)
 ;
"RTN","RORHL15",74,0)
OBR(RORORD,RORDFN) ;
"RTN","RORHL15",75,0)
 N CS,ERRCNT,IEN,RC,RORBUF,RORIENS,RORMSG,RORSEG,TMP,RORSCHED,RORINF
"RTN","RORHL15",76,0)
 S (ERRCNT,RC)=0
"RTN","RORHL15",77,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL15",78,0)
 S CS=$E(HLECH,1)
"RTN","RORHL15",79,0)
 ;
"RTN","RORHL15",80,0)
 S RORIENS=$$GETIENS(RORORD,RORDFN)  Q:'RORIENS 0
"RTN","RORHL15",81,0)
 D GETS^DIQ(55.01,RORIENS,".02;.03;.04;.08;.09;9","IE","RORBUF","RORMSG")
"RTN","RORHL15",82,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL15",83,0)
 . D DBS^RORERR("RORMSG",-9,,RORDFN,55.01,RORIENS)
"RTN","RORHL15",84,0)
 ;
"RTN","RORHL15",85,0)
 ;--- Initialize the segment
"RTN","RORHL15",86,0)
 S RORSEG="OBR"
"RTN","RORHL15",87,0)
 ;
"RTN","RORHL15",88,0)
 ;--- OBR-3 - Order Number
"RTN","RORHL15",89,0)
 S $P(RORSEG,HLFS,4)=RORORD
"RTN","RORHL15",90,0)
 ;
"RTN","RORHL15",91,0)
 ;--- OBR-4 - IV CPT Code
"RTN","RORHL15",92,0)
 S $P(RORSEG,HLFS,5)="90780"_CS_"IV"_CS_"C4"
"RTN","RORHL15",93,0)
 ;
"RTN","RORHL15",94,0)
 ;--- OBR-7 - Start Date
"RTN","RORHL15",95,0)
 S TMP=$$FMTHL7^XLFDT($G(RORBUF(55.01,RORIENS,.02,"I")))
"RTN","RORHL15",96,0)
 Q:TMP'>0 $$ERROR^RORERR(-95,,,RORDFN,55.01,RORIENS,.02)
"RTN","RORHL15",97,0)
 S $P(RORSEG,HLFS,8)=TMP
"RTN","RORHL15",98,0)
 ;
"RTN","RORHL15",99,0)
 ;--- OBR-8 - Stop Date
"RTN","RORHL15",100,0)
 S TMP=$G(RORBUF(55.01,RORIENS,.03,"I"))
"RTN","RORHL15",101,0)
 S $P(RORSEG,HLFS,9)=$$FM2HL^RORHL7(TMP)
"RTN","RORHL15",102,0)
 ;
"RTN","RORHL15",103,0)
 ;--- OBR-13 - Schedule
"RTN","RORHL15",104,0)
 S RORSCHED=$G(RORBUF(55.01,RORIENS,.09,"I"))
"RTN","RORHL15",105,0)
 S RORSCHED=$$ESCAPE^RORHL7(RORSCHED)
"RTN","RORHL15",106,0)
 S $P(RORSEG,HLFS,14)=RORSCHED
"RTN","RORHL15",107,0)
 ;
"RTN","RORHL15",108,0)
 ;--- OBR-20 - Infusion Rate
"RTN","RORHL15",109,0)
 S RORINF=$G(RORBUF(55.01,RORIENS,.08,"I"))
"RTN","RORHL15",110,0)
 S RORINF=$$ESCAPE^RORHL7(RORINF)
"RTN","RORHL15",111,0)
 S $P(RORSEG,HLFS,21)=RORINF
"RTN","RORHL15",112,0)
 ;
"RTN","RORHL15",113,0)
 ;--- OBR-24 - Diagnostic Service ID
"RTN","RORHL15",114,0)
 S $P(RORSEG,HLFS,25)="IMM"
"RTN","RORHL15",115,0)
 ;
"RTN","RORHL15",116,0)
 ;--- OBR-40 - Type
"RTN","RORHL15",117,0)
 S TMP=$G(RORBUF(55.01,RORIENS,.04,"I"))
"RTN","RORHL15",118,0)
 I TMP'=""  D  S $P(RORSEG,HLFS,41)=TMP
"RTN","RORHL15",119,0)
 . S $P(TMP,CS,2)=$G(RORBUF(55.01,RORIENS,.04,"E"))
"RTN","RORHL15",120,0)
 . S $P(TMP,CS,3)="VA"
"RTN","RORHL15",121,0)
 ;
"RTN","RORHL15",122,0)
 ;--- OBR-44 - Division
"RTN","RORHL15",123,0)
 S IEN=+$G(RORBUF(55.01,RORIENS,9,"I"))
"RTN","RORHL15",124,0)
 I IEN>0  D
"RTN","RORHL15",125,0)
 . S IEN=+$$GET1^DIQ(42,IEN_",",44,"I",,"RORMSG")
"RTN","RORHL15",126,0)
 . D:$G(DIERR) DBS^RORERR("RORMSG",-99,,,42,IEN_",")
"RTN","RORHL15",127,0)
 S $P(RORSEG,HLFS,45)=$$DIV44^RORHLUT1(IEN,1,CS)
"RTN","RORHL15",128,0)
 ;
"RTN","RORHL15",129,0)
 ;--- Store the segment
"RTN","RORHL15",130,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL15",131,0)
 Q ERRCNT
"RTN","RORHL15",132,0)
 ;
"RTN","RORHL15",133,0)
 ;***** IV OBX SEGMENT(S) BUILDER
"RTN","RORHL15",134,0)
 ;
"RTN","RORHL15",135,0)
 ; RORORD        Order Number
"RTN","RORHL15",136,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL15",137,0)
 ;
"RTN","RORHL15",138,0)
 ; Return Values:
"RTN","RORHL15",139,0)
 ;       <0  Error code
"RTN","RORHL15",140,0)
 ;        0  Ok
"RTN","RORHL15",141,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL15",142,0)
 ;
"RTN","RORHL15",143,0)
OBX(RORORD,RORDFN) ;
"RTN","RORHL15",144,0)
 N CS,ERRCNT,IEN,RC,RORID,RORIENS,RORKEY,RORLST,RORMSG,TMP
"RTN","RORHL15",145,0)
 S (ERRCNT,RC)=0
"RTN","RORHL15",146,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL15",147,0)
 S CS=$E(HLECH)
"RTN","RORHL15",148,0)
 ;
"RTN","RORHL15",149,0)
 S RORIENS=$$GETIENS(RORORD,RORDFN)  Q:'RORIENS 0
"RTN","RORHL15",150,0)
 ;
"RTN","RORHL15",151,0)
 ;=== Other Print information
"RTN","RORHL15",152,0)
 S TMP=$$GET1^DIQ(55.01,RORIENS,31,"E",,"RORMSG")
"RTN","RORHL15",153,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL15",154,0)
 . D DBS^RORERR("RORMSG",-99,,RORDFN,55.01,RORIENS)
"RTN","RORHL15",155,0)
 I TMP'=""  D  D SETOBX(TMP,RORID)
"RTN","RORHL15",156,0)
 . S RORID="OTPR"_CS_"Other Print info."_CS_"VA080"
"RTN","RORHL15",157,0)
 ;
"RTN","RORHL15",158,0)
 ;=== Additive data
"RTN","RORHL15",159,0)
 K RORMSG,RORLST
"RTN","RORHL15",160,0)
 D LIST^DIC(55.02,","_RORIENS,"@;.01;.02","I",,,,,,,"RORLST","RORMSG")
"RTN","RORHL15",161,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL15",162,0)
 . D DBS^RORERR("RORMSG",-99,,RORDFN,55.02,","_RORIENS)
"RTN","RORHL15",163,0)
 I $D(RORLST)>1  D
"RTN","RORHL15",164,0)
 . N RORAD,RORST
"RTN","RORHL15",165,0)
 . S RORID="ADD"_CS_"Additive"_CS_"VA080"
"RTN","RORHL15",166,0)
 . S RORKEY=""
"RTN","RORHL15",167,0)
 . F  S RORKEY=$O(RORLST("DILIST","ID",RORKEY))  Q:'RORKEY  D
"RTN","RORHL15",168,0)
 . . S IEN=+$G(RORLST("DILIST","ID",RORKEY,.01))  Q:IEN'>0
"RTN","RORHL15",169,0)
 . . S RORAD=$$GET1^DIQ(52.6,IEN_",",.01,"E",,"RORMSG")
"RTN","RORHL15",170,0)
 . . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL15",171,0)
 . . . D DBS^RORERR("RORMSG",-99,,RORDFN,52.6,IEN_",")
"RTN","RORHL15",172,0)
 . . Q:RORAD=""
"RTN","RORHL15",173,0)
 . . S RORST=$G(RORLST("DILIST","ID",RORKEY,.02))
"RTN","RORHL15",174,0)
 . . D SETOBX(RORAD,RORID,RORST)
"RTN","RORHL15",175,0)
 ;
"RTN","RORHL15",176,0)
 ;=== Solution Data
"RTN","RORHL15",177,0)
 K RORMSG,RORLST
"RTN","RORHL15",178,0)
 D LIST^DIC(55.11,","_RORIENS,"@;.01;1","I",,,,,,,"RORLST","RORMSG")
"RTN","RORHL15",179,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL15",180,0)
 . D DBS^RORERR("RORMSG",-99,,,55.11,","_RORIENS)
"RTN","RORHL15",181,0)
 I $D(RORLST)>1  D
"RTN","RORHL15",182,0)
 . N RORSOL,RORVOL
"RTN","RORHL15",183,0)
 . S RORID="SOL"_CS_"Solution"_CS_"VA080"
"RTN","RORHL15",184,0)
 . S RORKEY=""
"RTN","RORHL15",185,0)
 . F  S RORKEY=$O(RORLST("DILIST","ID",RORKEY))  Q:'RORKEY  D
"RTN","RORHL15",186,0)
 . . S IEN=+$G(RORLST("DILIST","ID",RORKEY,.01))  Q:IEN'>0
"RTN","RORHL15",187,0)
 . . S RORSOL=$$GET1^DIQ(52.7,IEN_",",.01,"E",,"RORMSG")
"RTN","RORHL15",188,0)
 . . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORHL15",189,0)
 . . . D DBS^RORERR("RORMSG",-99,,RORDFN,52.7,IEN_",")
"RTN","RORHL15",190,0)
 . . Q:RORSOL=""
"RTN","RORHL15",191,0)
 . . S RORVOL=$G(RORLST("DILIST","ID",RORKEY,1))
"RTN","RORHL15",192,0)
 . . D SETOBX(RORSOL,RORID,RORVOL)
"RTN","RORHL15",193,0)
 ;
"RTN","RORHL15",194,0)
 Q ERRCNT
"RTN","RORHL15",195,0)
 ;
"RTN","RORHL15",196,0)
 ;*****
"RTN","RORHL15",197,0)
GETIENS(RORORD,RORDFN) ;
"RTN","RORHL15",198,0)
 N IEN
"RTN","RORHL15",199,0)
 S IEN=$O(^PS(55,RORDFN,"IV","B",RORORD,""))
"RTN","RORHL15",200,0)
 Q $S(IEN>0:IEN_","_RORDFN_",",1:"")
"RTN","RORHL15",201,0)
 ;
"RTN","RORHL15",202,0)
 ;***** CREATES AND STORES THE OBX SEGMENT
"RTN","RORHL15",203,0)
SETOBX(PIECE5,PIECE3,PIECE7) ;
"RTN","RORHL15",204,0)
 N RORSEG
"RTN","RORHL15",205,0)
 S PIECE5=$$ESCAPE^RORHL7(PIECE5)
"RTN","RORHL15",206,0)
 ;--- Initialize the segment
"RTN","RORHL15",207,0)
 S RORSEG="OBX"
"RTN","RORHL15",208,0)
 ;--- OBX-2
"RTN","RORHL15",209,0)
 S $P(RORSEG,HLFS,3)="FT"
"RTN","RORHL15",210,0)
 ;---
"RTN","RORHL15",211,0)
 S $P(RORSEG,HLFS,4)=PIECE3
"RTN","RORHL15",212,0)
 S $P(RORSEG,HLFS,6)=PIECE5
"RTN","RORHL15",213,0)
 S:$G(PIECE7)'="" $P(RORSEG,HLFS,8)=PIECE7
"RTN","RORHL15",214,0)
 ;--- OBX-11
"RTN","RORHL15",215,0)
 S $P(RORSEG,HLFS,12)="F"
"RTN","RORHL15",216,0)
 ;--- Store the segment
"RTN","RORHL15",217,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL15",218,0)
 Q
"RTN","RORHL16")
0^94^B12940115
"RTN","RORHL16",1,0)
RORHL16 ;HOIFO/BH - HL7 VITALS DATA: OBR,OBX ; 6/9/03 3:04pm
"RTN","RORHL16",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL16",3,0)
 ;
"RTN","RORHL16",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL16",5,0)
 ;
"RTN","RORHL16",6,0)
 ;
"RTN","RORHL16",7,0)
 ; #1446         EN1^GMRVUT0 (controlled)
"RTN","RORHL16",8,0)
 ;
"RTN","RORHL16",9,0)
 Q
"RTN","RORHL16",10,0)
 ;
"RTN","RORHL16",11,0)
 ;***** SEARCHES FOR VITALS DATA
"RTN","RORHL16",12,0)
 ;
"RTN","RORHL16",13,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL16",14,0)
 ;
"RTN","RORHL16",15,0)
 ; RORSTDT       Start Date (FileMan)
"RTN","RORHL16",16,0)
 ; RORENDT       End Date   (FileMan)
"RTN","RORHL16",17,0)
 ;
"RTN","RORHL16",18,0)
 ; Return Values:
"RTN","RORHL16",19,0)
 ;       <0  Error code
"RTN","RORHL16",20,0)
 ;        0  Ok
"RTN","RORHL16",21,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL16",22,0)
 ;
"RTN","RORHL16",23,0)
 ; The function uses ^UTILITY($J,"GMRVD") global node.
"RTN","RORHL16",24,0)
 ;
"RTN","RORHL16",25,0)
EN1(RORDFN,RORSTDT,RORENDT) ;
"RTN","RORHL16",26,0)
 N DFN,GMRVSTR,PAT,RC
"RTN","RORHL16",27,0)
 S (ERRCNT,RC)=0
"RTN","RORHL16",28,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL16",29,0)
 ;
"RTN","RORHL16",30,0)
 ;--- Check to see if the patient has any Vitals data
"RTN","RORHL16",31,0)
 K ^UTILITY($J,"GMRVD")
"RTN","RORHL16",32,0)
 S DFN=RORDFN,GMRVSTR="BP;T;R;P;HT;WT;PN"
"RTN","RORHL16",33,0)
 S GMRVSTR(0)=RORSTDT_"^"_RORENDT_"^999999^0"
"RTN","RORHL16",34,0)
 D EN1^GMRVUT0
"RTN","RORHL16",35,0)
 Q:$D(^UTILITY($J,"GMRVD"))<10 0
"RTN","RORHL16",36,0)
 ;
"RTN","RORHL16",37,0)
 S TMP=$$OBR()
"RTN","RORHL16",38,0)
 I TMP  S ERRCNT=ERRCNT+1  Q:RC<0
"RTN","RORHL16",39,0)
 S TMP=$$OBX()
"RTN","RORHL16",40,0)
 I TMP  S ERRCNT=ERRCNT+1  Q:RC<0
"RTN","RORHL16",41,0)
 ;
"RTN","RORHL16",42,0)
 K ^UTILITY($J,"GMRVD")
"RTN","RORHL16",43,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL16",44,0)
 ;
"RTN","RORHL16",45,0)
 ;***** VITALS OBR SEGMENT BUILDER
"RTN","RORHL16",46,0)
 ;
"RTN","RORHL16",47,0)
 ; Return Values:
"RTN","RORHL16",48,0)
 ;       <0  Error code
"RTN","RORHL16",49,0)
 ;        0  Ok
"RTN","RORHL16",50,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL16",51,0)
 ;
"RTN","RORHL16",52,0)
OBR() ;
"RTN","RORHL16",53,0)
 N CS,ERRCNT,RC,RORSEG
"RTN","RORHL16",54,0)
 S (ERRCNT,RC)=0
"RTN","RORHL16",55,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL16",56,0)
 S CS=$E(HLECH,1)
"RTN","RORHL16",57,0)
 ;
"RTN","RORHL16",58,0)
 ;--- Initialize the segment
"RTN","RORHL16",59,0)
 S RORSEG="OBR"
"RTN","RORHL16",60,0)
 ;
"RTN","RORHL16",61,0)
 ;--- OBR-4 - Vitals CPT Code
"RTN","RORHL16",62,0)
 S $P(RORSEG,HLFS,5)="94150"_CS_"VITAL CAPACITY TEST"_CS_"C4"
"RTN","RORHL16",63,0)
 ;
"RTN","RORHL16",64,0)
 ;--- OBR-24 - Diagnostic Service ID
"RTN","RORHL16",65,0)
 S $P(RORSEG,HLFS,25)="EC"
"RTN","RORHL16",66,0)
 ;
"RTN","RORHL16",67,0)
 ;--- OBR-44 - Division
"RTN","RORHL16",68,0)
 S $P(RORSEG,HLFS,45)=$$SITE1^RORUTL03(CS)
"RTN","RORHL16",69,0)
 ;
"RTN","RORHL16",70,0)
 ;--- Store the segment
"RTN","RORHL16",71,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL16",72,0)
 Q ERRCNT
"RTN","RORHL16",73,0)
 ;
"RTN","RORHL16",74,0)
 ;***** VITALS OBX SEGMENT(S) BUILDER
"RTN","RORHL16",75,0)
 ;
"RTN","RORHL16",76,0)
 ; Return Values:
"RTN","RORHL16",77,0)
 ;       <0  Error code
"RTN","RORHL16",78,0)
 ;        0  Ok
"RTN","RORHL16",79,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL16",80,0)
 ;
"RTN","RORHL16",81,0)
OBX() ;
"RTN","RORHL16",82,0)
 N CS,ERRCNT,RC,OBID
"RTN","RORHL16",83,0)
 S (ERRCNT,RC)=0
"RTN","RORHL16",84,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL16",85,0)
 S CS=$E(HLECH)
"RTN","RORHL16",86,0)
 ;
"RTN","RORHL16",87,0)
 F OBID="BP^Blood Pressue^VA080","T^Tempreture^VA080","R^Respiration^VA080","P^Pulse^VA080","HT^Height^VA080","WT^Weight^VA080","PN^Pain^VA080"  D
"RTN","RORHL16",88,0)
 . D VITALTYP(OBID,CS)
"RTN","RORHL16",89,0)
 ;
"RTN","RORHL16",90,0)
 Q ERRCNT
"RTN","RORHL16",91,0)
 ;
"RTN","RORHL16",92,0)
 ;***** LOOPS THROUGH THE UTILITY GLOBAL FOR VITAL TYPE
"RTN","RORHL16",93,0)
VITALTYP(OBID,CS) ;
"RTN","RORHL16",94,0)
 N BODYMASS,DATA,DTE,IEN,MEASDATE,OBX5,TYPE,UNITS
"RTN","RORHL16",95,0)
 S TYPE=$P(OBID,U)
"RTN","RORHL16",96,0)
 Q:'$D(^UTILITY($J,"GMRVD",TYPE))
"RTN","RORHL16",97,0)
 ;---
"RTN","RORHL16",98,0)
 S DTE=""
"RTN","RORHL16",99,0)
 F  S DTE=$O(^UTILITY($J,"GMRVD",TYPE,DTE))  Q:'DTE  D
"RTN","RORHL16",100,0)
 . S IEN=""
"RTN","RORHL16",101,0)
 . F  S IEN=$O(^UTILITY($J,"GMRVD",TYPE,DTE,IEN))  Q:'IEN  D
"RTN","RORHL16",102,0)
 . . S DATA=^UTILITY($J,"GMRVD",TYPE,DTE,IEN)
"RTN","RORHL16",103,0)
 . . ;
"RTN","RORHL16",104,0)
 . . S MEASDATE=$$FM2HL^RORHL7($P(DATA,U))
"RTN","RORHL16",105,0)
 . . S UNITS=$P(DATA,U,13)
"RTN","RORHL16",106,0)
 . . S BODYMASS=$S(TYPE="WT":$P(DATA,U,14),1:"")
"RTN","RORHL16",107,0)
 . . ;
"RTN","RORHL16",108,0)
 . . S OBX5=$P(DATA,U,8)_CS_$P(DATA,U,11)_CS_$P(DATA,U,17)
"RTN","RORHL16",109,0)
 . . D SETOBX(OBID,IEN,OBX5,UNITS,BODYMASS,MEASDATE)
"RTN","RORHL16",110,0)
 ;
"RTN","RORHL16",111,0)
 Q
"RTN","RORHL16",112,0)
 ;
"RTN","RORHL16",113,0)
 ;*** CREATES AND STORES THE OBX SEGMENT
"RTN","RORHL16",114,0)
SETOBX(PIECE3,PIECE4,PIECE5,PIECE6,PIECE7,PIECE14) ;
"RTN","RORHL16",115,0)
 N RORSEG
"RTN","RORHL16",116,0)
 ;--- Initialize the segment
"RTN","RORHL16",117,0)
 S RORSEG="OBX"
"RTN","RORHL16",118,0)
 ;--- OBX-2
"RTN","RORHL16",119,0)
 S $P(RORSEG,HLFS,3)="FT"
"RTN","RORHL16",120,0)
 ;---
"RTN","RORHL16",121,0)
 S $P(RORSEG,HLFS,4)=PIECE3
"RTN","RORHL16",122,0)
 S $P(RORSEG,HLFS,5)=PIECE4
"RTN","RORHL16",123,0)
 S $P(RORSEG,HLFS,6)=PIECE5
"RTN","RORHL16",124,0)
 S:$G(PIECE6)'="" $P(RORSEG,HLFS,7)=PIECE6
"RTN","RORHL16",125,0)
 S:$G(PIECE7)'="" $P(RORSEG,HLFS,8)=PIECE7
"RTN","RORHL16",126,0)
 S:$G(PIECE14)'="" $P(RORSEG,HLFS,15)=PIECE14
"RTN","RORHL16",127,0)
 ;--- OBX-11
"RTN","RORHL16",128,0)
 S $P(RORSEG,HLFS,12)="F"
"RTN","RORHL16",129,0)
 ;--- Store the segment
"RTN","RORHL16",130,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL16",131,0)
 Q
"RTN","RORHL17")
0^151^B34047121
"RTN","RORHL17",1,0)
RORHL17 ;HOIFO/BH - HL7 Problem List: OBR,OBX ; 10/28/03 8:34am
"RTN","RORHL17",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL17",3,0)
 ;
"RTN","RORHL17",4,0)
 ; This routine uses the following IAs:
"RTN","RORHL17",5,0)
 ;
"RTN","RORHL17",6,0)
 ; #2308         Controlled
"RTN","RORHL17",7,0)
 ;
"RTN","RORHL17",8,0)
 Q
"RTN","RORHL17",9,0)
 ;
"RTN","RORHL17",10,0)
 ;***** SEARCHES FOR Problem List DATA
"RTN","RORHL17",11,0)
 ;
"RTN","RORHL17",12,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL17",13,0)
 ;
"RTN","RORHL17",14,0)
 ; RORSTDT       Start Date (FileMan)
"RTN","RORHL17",15,0)
 ; RORENDT       End Date   (FileMan)
"RTN","RORHL17",16,0)
 ;
"RTN","RORHL17",17,0)
 ; Return Values:
"RTN","RORHL17",18,0)
 ;       <0  Error code
"RTN","RORHL17",19,0)
 ;        0  Ok
"RTN","RORHL17",20,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL17",21,0)
 ;
"RTN","RORHL17",22,0)
 ;
"RTN","RORHL17",23,0)
EN1(RORDFN,RORSTDT,RORENDT) ;
"RTN","RORHL17",24,0)
 N CNT,CS,DFN,DIAG,FACILITY,GMRVSTR,IENS,MDATE,NOTE,NUMBER,PAT,PRONBIEN,RC,REC,REC1,RORARR,RORBUF,RORMSG,STAT,SUB3,SUB5,TMP
"RTN","RORHL17",25,0)
 S (ERRCNT,RC)=0
"RTN","RORHL17",26,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL17",27,0)
 S CS=$E(HLECH,1)
"RTN","RORHL17",28,0)
 ;
"RTN","RORHL17",29,0)
 ;--- Check to see is any problems have been entered/modified after the 
"RTN","RORHL17",30,0)
 ;--- start date
"RTN","RORHL17",31,0)
 ;
"RTN","RORHL17",32,0)
 S MDATE=""
"RTN","RORHL17",33,0)
 S MDATE=$O(^AUPNPROB("MODIFIED",RORDFN,MDATE))
"RTN","RORHL17",34,0)
 I MDATE=""!($P(MDATE,".",1)<RORSTDT) Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL17",35,0)
 ;
"RTN","RORHL17",36,0)
 ;--- Find newly entered problems or modified problems
"RTN","RORHL17",37,0)
 ;
"RTN","RORHL17",38,0)
 S PROBIEN=""
"RTN","RORHL17",39,0)
 F  S PROBIEN=$O(^AUPNPROB("AC",RORDFN,PROBIEN)) Q:'PROBIEN  D
"RTN","RORHL17",40,0)
 . K RORARR
"RTN","RORHL17",41,0)
 . S REC=^AUPNPROB(PROBIEN,0)
"RTN","RORHL17",42,0)
 . S REC1=$G(^AUPNPROB(PROBIEN,1))
"RTN","RORHL17",43,0)
 . S MDATE=$P(REC,U,3)
"RTN","RORHL17",44,0)
 . I MDATE<RORSTDT Q
"RTN","RORHL17",45,0)
 . ;
"RTN","RORHL17",46,0)
 . S RORARR("OBR","FACIL")=$P(REC,U,6)
"RTN","RORHL17",47,0)
 . S RORARR("OBR","NMBR")=$P(REC,U,7)
"RTN","RORHL17",48,0)
 . S RORARR("OBR","COND")=$P(REC1,U,2)
"RTN","RORHL17",49,0)
 . S RORARR("OBR","DE")=$$FMTHL7^XLFDT($P(REC,U,8))
"RTN","RORHL17",50,0)
 . S RORARR("OBR","DOO")=$$CHECK($P(REC,U,13))
"RTN","RORHL17",51,0)
 . S RORARR("OBR","DR")=$$CHECK($P(REC1,U,7))
"RTN","RORHL17",52,0)
 . ;
"RTN","RORHL17",53,0)
 . S DIAG=$$GET1^DIQ(80,$P(REC,U,1)_",",.01,"E",,"RORMSG")
"RTN","RORHL17",54,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL17",55,0)
 . . D DBS^RORERR("RORMSG",-99,,RORDFN,80,$P(REC,U,1)_",")
"RTN","RORHL17",56,0)
 . ;
"RTN","RORHL17",57,0)
 . S RORARR("OBR","DIAG")=DIAG
"RTN","RORHL17",58,0)
 . S RORARR("OBR","DR")=$$FMTHL7^XLFDT($P(REC1,U,9))
"RTN","RORHL17",59,0)
 . S RORARR("OBR","RP")=$P(REC1,U,4)
"RTN","RORHL17",60,0)
 . S RORARR("OBR","DLM")=$$FMTHL7^XLFDT(MDATE)
"RTN","RORHL17",61,0)
 . S RORARR("OBR","ST")=$P(REC,U,12)
"RTN","RORHL17",62,0)
 . ;
"RTN","RORHL17",63,0)
 . S RORARR("OBX","PR")=$$GET1^DIQ(9000011,PROBIEN,.05,"E")
"RTN","RORHL17",64,0)
 . S RORARR("OBX","PROB")=$$GET1^DIQ(9000011,PROBIEN,1.01,"E")
"RTN","RORHL17",65,0)
 . ;
"RTN","RORHL17",66,0)
 . I $D(^AUPNPROB(PROBIEN,11)) D
"RTN","RORHL17",67,0)
 . . S SUB3=0,CNT=0
"RTN","RORHL17",68,0)
 . . F  S SUB3=$O(^AUPNPROB(PROBIEN,11,SUB3)) Q:'SUB3  D
"RTN","RORHL17",69,0)
 . . . S FACILITY=$$GET1^DIQ(9000011.11,SUB3_","_PROBIEN,.01,"E")
"RTN","RORHL17",70,0)
 . . . I FACILITY="" Q
"RTN","RORHL17",71,0)
 . . . S SUB5=0
"RTN","RORHL17",72,0)
 . . . F  S SUB5=$O(^AUPNPROB(PROBIEN,11,SUB3,11,SUB5)) Q:'SUB5  D
"RTN","RORHL17",73,0)
 . . . . S IENS=SUB5_","_SUB3_","_PROBIEN_","
"RTN","RORHL17",74,0)
 . . . . D GETS^DIQ(9000011.1111,IENS,".01;.03;.04","IE","RORBUF")
"RTN","RORHL17",75,0)
 . . . . S NUMBER=RORBUF(9000011.1111,IENS,.01,"E")
"RTN","RORHL17",76,0)
 . . . . S STAT=RORBUF(9000011.1111,IENS,.04,"I")
"RTN","RORHL17",77,0)
 . . . . I STAT="" S STAT="I"
"RTN","RORHL17",78,0)
 . . . . S NOTE=RORBUF(9000011.1111,IENS,.03,"E")
"RTN","RORHL17",79,0)
 . . . . S CNT=CNT+1
"RTN","RORHL17",80,0)
 . . . . S RORARR("OBX","NOTE",CNT)=FACILITY_CS_NUMBER_CS_STAT
"RTN","RORHL17",81,0)
 . . . . S RORARR("OBX","NOTE",CNT,0)=NOTE
"RTN","RORHL17",82,0)
 . ;
"RTN","RORHL17",83,0)
 . S TMP=$$OBR(.RORARR)
"RTN","RORHL17",84,0)
 . I TMP  S ERRCNT=ERRCNT+1  Q:RC<0
"RTN","RORHL17",85,0)
 . S TMP=$$OBX(.RORARR)
"RTN","RORHL17",86,0)
 . I TMP  S ERRCNT=ERRCNT+1  Q:RC<0
"RTN","RORHL17",87,0)
 ;
"RTN","RORHL17",88,0)
 Q $S(RC<0:RC,1:ERRCNT)
"RTN","RORHL17",89,0)
 ;
"RTN","RORHL17",90,0)
 ;***** PROBLEM LIST OBR SEGMENT BUILDER
"RTN","RORHL17",91,0)
 ;
"RTN","RORHL17",92,0)
 ; Return Values:
"RTN","RORHL17",93,0)
 ;       <0  Error code
"RTN","RORHL17",94,0)
 ;        0  Ok
"RTN","RORHL17",95,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL17",96,0)
 ;
"RTN","RORHL17",97,0)
OBR(RORARR) ;
"RTN","RORHL17",98,0)
 N CLASS,CS,ERRCNT,PRV,RC,RORMSG,RORSEG,TMP,TMP1
"RTN","RORHL17",99,0)
 S (ERRCNT,RC)=0
"RTN","RORHL17",100,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL17",101,0)
 S CS=$E(HLECH,1)
"RTN","RORHL17",102,0)
 ;
"RTN","RORHL17",103,0)
 ;--- Initialize the segment
"RTN","RORHL17",104,0)
 S RORSEG="OBR"
"RTN","RORHL17",105,0)
 ;
"RTN","RORHL17",106,0)
 ;--- OBR-3 - Filler Order Number
"RTN","RORHL17",107,0)
 S $P(RORSEG,HLFS,4)=RORARR("OBR","FACIL")_RORARR("OBR","NMBR")
"RTN","RORHL17",108,0)
 ;
"RTN","RORHL17",109,0)
 ;--- OBR-4 - Problem List CPT Code
"RTN","RORHL17",110,0)
 S $P(RORSEG,HLFS,5)="90125"_CS_"HOSPITAL CARE,NEW, INTERMED."_CS_"C4"
"RTN","RORHL17",111,0)
 ;
"RTN","RORHL17",112,0)
 ;--- OBR-6 - Requested Date/time
"RTN","RORHL17",113,0)
 S $P(RORSEG,HLFS,7)=RORARR("OBR","DE")
"RTN","RORHL17",114,0)
 ;
"RTN","RORHL17",115,0)
 ;--- OBR-7 - Observation Date/Time
"RTN","RORHL17",116,0)
 S $P(RORSEG,HLFS,8)=RORARR("OBR","DOO")
"RTN","RORHL17",117,0)
 ;
"RTN","RORHL17",118,0)
 ;--- OBR-8 - Observation End Date/Time
"RTN","RORHL17",119,0)
 S $P(RORSEG,HLFS,9)=RORARR("OBR","DR")
"RTN","RORHL17",120,0)
 ;
"RTN","RORHL17",121,0)
 ;--- OBR-13 -  Relevant Clinical Info.
"RTN","RORHL17",122,0)
 S $P(RORSEG,HLFS,14)=RORARR("OBR","DIAG")
"RTN","RORHL17",123,0)
 ;
"RTN","RORHL17",124,0)
 ;--- OBR-14 - Specimen Received Date/time
"RTN","RORHL17",125,0)
 S $P(RORSEG,HLFS,15)=RORARR("OBR","DR")
"RTN","RORHL17",126,0)
 ;
"RTN","RORHL17",127,0)
 ;--- OBR-16 - Ordering Provider
"RTN","RORHL17",128,0)
 S PRV=RORARR("OBR","RP")
"RTN","RORHL17",129,0)
 ;
"RTN","RORHL17",130,0)
 S CLASS=$$GET1^DIQ(200,PRV_",",53.5,"I",,"RORMSG")
"RTN","RORHL17",131,0)
 I $G(DIERR)  D  S ERRCNT=ERRCNT+1
"RTN","RORHL17",132,0)
 . D DBS^RORERR("RORMSG",-99,,RORDFN,200,PRV_",")
"RTN","RORHL17",133,0)
 ;
"RTN","RORHL17",134,0)
 S $P(PRV,CS,5)=CLASS
"RTN","RORHL17",135,0)
 S $P(RORSEG,HLFS,17)=PRV
"RTN","RORHL17",136,0)
 ;
"RTN","RORHL17",137,0)
 ;--- OBR-20 - Filler Field 1
"RTN","RORHL17",138,0)
 S $P(RORSEG,HLFS,21)=RORARR("OBR","COND")
"RTN","RORHL17",139,0)
 ;
"RTN","RORHL17",140,0)
 ;--- OBR-22 - Results Rpt/Status Change Date/time  
"RTN","RORHL17",141,0)
 S $P(RORSEG,HLFS,23)=RORARR("OBR","DLM")
"RTN","RORHL17",142,0)
 ;
"RTN","RORHL17",143,0)
 ;--- OBR-24 - Diagnostic Service ID
"RTN","RORHL17",144,0)
 S $P(RORSEG,HLFS,25)="TX"
"RTN","RORHL17",145,0)
 ;
"RTN","RORHL17",146,0)
 ;--- OBR-25 - Result Status
"RTN","RORHL17",147,0)
 S TMP1=RORARR("OBR","ST")
"RTN","RORHL17",148,0)
 S TMP=$S(TMP1="A":"F",TMP1="I":"R",1:"")
"RTN","RORHL17",149,0)
 S $P(RORSEG,HLFS,26)=TMP
"RTN","RORHL17",150,0)
 ;
"RTN","RORHL17",151,0)
 ;--- OBR-44 - Division
"RTN","RORHL17",152,0)
 S $P(RORSEG,HLFS,45)=$$SITE1^RORUTL03(CS)
"RTN","RORHL17",153,0)
 ;
"RTN","RORHL17",154,0)
 ;--- Store the segment
"RTN","RORHL17",155,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL17",156,0)
 Q ERRCNT
"RTN","RORHL17",157,0)
 ;
"RTN","RORHL17",158,0)
 ;***** VITALS OBX SEGMENT(S) BUILDER
"RTN","RORHL17",159,0)
 ;
"RTN","RORHL17",160,0)
 ; Return Values:
"RTN","RORHL17",161,0)
 ;       <0  Error code
"RTN","RORHL17",162,0)
 ;        0  Ok
"RTN","RORHL17",163,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL17",164,0)
 ;
"RTN","RORHL17",165,0)
OBX(RORARR) ;
"RTN","RORHL17",166,0)
 N CS,ERRCNT,RC,OBID,OBX5PROB,OBX5PR
"RTN","RORHL17",167,0)
 S (ERRCNT,RC)=0
"RTN","RORHL17",168,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL17",169,0)
 S CS=$E(HLECH)
"RTN","RORHL17",170,0)
 ;
"RTN","RORHL17",171,0)
 I $D(RORARR("OBX","PR")) D
"RTN","RORHL17",172,0)
 . S OBX5PR=RORARR("OBX","PR")
"RTN","RORHL17",173,0)
 . D SETOBX("PRVN"_CS_"Provider Narrative"_CS_"VA080","",OBX5PR)
"RTN","RORHL17",174,0)
 ;
"RTN","RORHL17",175,0)
 I $D(RORARR("OBX","PROB")) D
"RTN","RORHL17",176,0)
 . S OBX5PROB=RORARR("OBX","PROB")
"RTN","RORHL17",177,0)
 . D SETOBX("EXPR"_CS_"Expression"_CS_"VA080","",OBX5PR)
"RTN","RORHL17",178,0)
 ;
"RTN","RORHL17",179,0)
 I $D(RORARR("OBX","NOTE")) D
"RTN","RORHL17",180,0)
 . N INDEX,OBX5NN,STATUS
"RTN","RORHL17",181,0)
 . S INDEX=""
"RTN","RORHL17",182,0)
 . F  S INDEX=$O(RORARR("OBX","NOTE",INDEX)) Q:'INDEX  D
"RTN","RORHL17",183,0)
 . . S REC=RORARR("OBX","NOTE",INDEX)
"RTN","RORHL17",184,0)
 . . S OBX5NN=RORARR("OBX","NOTE",INDEX,0)
"RTN","RORHL17",185,0)
 . . D SETOBX("NOTE"_CS_"Note Narrative"_CS_"VA080",REC,OBX5NN)
"RTN","RORHL17",186,0)
 ;
"RTN","RORHL17",187,0)
 Q ERRCNT
"RTN","RORHL17",188,0)
 ;
"RTN","RORHL17",189,0)
 ;*** CREATES AND STORES THE OBX SEGMENT
"RTN","RORHL17",190,0)
SETOBX(PIECE3,PIECE4,PIECE5) ;
"RTN","RORHL17",191,0)
 N RORSEG
"RTN","RORHL17",192,0)
 ;--- Initialize the segment
"RTN","RORHL17",193,0)
 S RORSEG="OBX"
"RTN","RORHL17",194,0)
 ;--- OBX-2
"RTN","RORHL17",195,0)
 S $P(RORSEG,HLFS,3)="FT"
"RTN","RORHL17",196,0)
 ;--- OBX-3
"RTN","RORHL17",197,0)
 S $P(RORSEG,HLFS,4)=PIECE3
"RTN","RORHL17",198,0)
 ;--- OBX-4
"RTN","RORHL17",199,0)
 I $D(PIECE4) S $P(RORSEG,HLFS,5)=PIECE4
"RTN","RORHL17",200,0)
 ;--- OBX-5
"RTN","RORHL17",201,0)
 S $P(RORSEG,HLFS,6)=PIECE5
"RTN","RORHL17",202,0)
 ;--- OBX-11
"RTN","RORHL17",203,0)
 S $P(RORSEG,HLFS,12)="F"
"RTN","RORHL17",204,0)
 ;--- Store the segment
"RTN","RORHL17",205,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL17",206,0)
 Q
"RTN","RORHL17",207,0)
 ;
"RTN","RORHL17",208,0)
CHECK(ROR1DATE) ;
"RTN","RORHL17",209,0)
 S ROR1DATE=$$FMTHL7^XLFDT(ROR1DATE)
"RTN","RORHL17",210,0)
 I 'ROR1DATE Q ""
"RTN","RORHL17",211,0)
 I $E(ROR1DATE,1,2)="20",$E(ROR1DATE,3,4)>$E(DT,2,3) Q ""
"RTN","RORHL17",212,0)
 I $E(ROR1DATE,7,8)="00" S $E(ROR1DATE,7,8)="01"
"RTN","RORHL17",213,0)
 I $E(ROR1DATE,5,6)="00" S $E(ROR1DATE,5,6)="01"
"RTN","RORHL17",214,0)
 Q ROR1DATE
"RTN","RORHL17",215,0)
 ;
"RTN","RORHL21")
0^70^B4958953
"RTN","RORHL21",1,0)
RORHL21 ;HOIFO/CRT - HL7 PATIENT DATA (ICR): PID ; 10/1/03 1:18pm
"RTN","RORHL21",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL21",3,0)
 ;
"RTN","RORHL21",4,0)
 ;--------------------------------------------------------------------
"RTN","RORHL21",5,0)
 ; Registry: [VA ICR]
"RTN","RORHL21",6,0)
 ;--------------------------------------------------------------------
"RTN","RORHL21",7,0)
 ;
"RTN","RORHL21",8,0)
 ; This routine uses the following IAs:
"RTN","RORHL21",9,0)
 ;
"RTN","RORHL21",10,0)
 ; #263          $$EN^VAFHLPID (controlled)
"RTN","RORHL21",11,0)
 ; #10035        Read access to the PATIENT file (supported)
"RTN","RORHL21",12,0)
 ; #10061        DEM^VADPT (supported)
"RTN","RORHL21",13,0)
 ;
"RTN","RORHL21",14,0)
 Q
"RTN","RORHL21",15,0)
 ;
"RTN","RORHL21",16,0)
 ;***** PID SEGMENT BUILDER
"RTN","RORHL21",17,0)
 ;
"RTN","RORHL21",18,0)
 ; RORDFN        DFN of Patient Record in File #2
"RTN","RORHL21",19,0)
 ;
"RTN","RORHL21",20,0)
 ; Return Values:
"RTN","RORHL21",21,0)
 ;       <0  Error Code
"RTN","RORHL21",22,0)
 ;        0  Ok
"RTN","RORHL21",23,0)
 ;       >0  Non-fatal error(s)
"RTN","RORHL21",24,0)
 ;
"RTN","RORHL21",25,0)
PID(RORDFN) ;
"RTN","RORHL21",26,0)
 N ERRCNT,CS,RC,RORFLDS,RORMSG,RORSEG,SCS,TMP,VAFPID
"RTN","RORHL21",27,0)
 S (ERRCNT,RC)=0
"RTN","RORHL21",28,0)
 S HLFS=$G(RORHL("FS"),"|"),HLECH=$G(RORHL("ECH"),"^~\&")
"RTN","RORHL21",29,0)
 S CS=$E(HLECH,1),SCS=$E(HLECH,4)
"RTN","RORHL21",30,0)
 ;
"RTN","RORHL21",31,0)
 ;--- Check if the patient exists
"RTN","RORHL21",32,0)
 S RORDFN=+$G(RORDFN)
"RTN","RORHL21",33,0)
 I '$D(^DPT(RORDFN))  D  Q RC
"RTN","RORHL21",34,0)
 . S RC=$$ERROR^RORERR(-36,,,RORDFN,2)
"RTN","RORHL21",35,0)
 ;
"RTN","RORHL21",36,0)
 ;--- Check the type of available race data
"RTN","RORHL21",37,0)
 S RORFLDS="2,3,5,7,8,11,19,22BT,29" ; Default HL7 fields
"RTN","RORHL21",38,0)
 D  ; Either new or old race information
"RTN","RORHL21",39,0)
 . N DFN,VA,VADM,VAHOW,VAROOT  S DFN=RORDFN  D DEM^VADPT
"RTN","RORHL21",40,0)
 . S RORFLDS=RORFLDS_$S($G(VADM(12))>0:",10BT",1:",10")
"RTN","RORHL21",41,0)
 ;
"RTN","RORHL21",42,0)
 ;--- Call Standard PID Segment builder
"RTN","RORHL21",43,0)
 S RORSEG=$$EN^VAFHLPID(RORDFN,RORFLDS)
"RTN","RORHL21",44,0)
 S:$G(VAFPID(1))'="" RORSEG=RORSEG_VAFPID(1)
"RTN","RORHL21",45,0)
 ;
"RTN","RORHL21",46,0)
 ;--- PID-2 ICN
"RTN","RORHL21",47,0)
 S TMP=$$ICN^RORUTL02(RORDFN)
"RTN","RORHL21",48,0)
 I TMP>0  S $P(RORSEG,HLFS,3)=$TR(TMP,"V",CS)_CS_"ISO"_CS_"VAMPI"
"RTN","RORHL21",49,0)
 E  S $P(RORSEG,HLFS,3)=""
"RTN","RORHL21",50,0)
 ;
"RTN","RORHL21",51,0)
 ;--- PID-3 DFN and Station Number
"RTN","RORHL21",52,0)
 S TMP=$$M10^HLFNC(RORDFN,CS)
"RTN","RORHL21",53,0)
 S $P(TMP,CS,5)="PI"
"RTN","RORHL21",54,0)
 S $P(TMP,CS,6)=$$SITE^RORUTL03(SCS)
"RTN","RORHL21",55,0)
 S $P(RORSEG,HLFS,4)=TMP
"RTN","RORHL21",56,0)
 ;
"RTN","RORHL21",57,0)
 ;--- PID-5 Remove the Patient Name
"RTN","RORHL21",58,0)
 S $P(RORSEG,HLFS,6)=""
"RTN","RORHL21",59,0)
 ;
"RTN","RORHL21",60,0)
 ;--- PID-11 Remove Address (leave ZIP only)
"RTN","RORHL21",61,0)
 S $P(RORSEG,HLFS,12)=CS_CS_CS_CS_$P($P(RORSEG,HLFS,12),CS,5)
"RTN","RORHL21",62,0)
 ;
"RTN","RORHL21",63,0)
 ;--- PID-19 Encrypt SSN
"RTN","RORHL21",64,0)
 S $P(RORSEG,HLFS,20)=$$XOR^RORUTL03($P(RORSEG,HLFS,20))
"RTN","RORHL21",65,0)
 ;
"RTN","RORHL21",66,0)
 ;--- PID-29 Date of Death (not supported by EN^VAFHLPID)
"RTN","RORHL21",67,0)
 S TMP=$$GET1^DIQ(2,RORDFN,.351,"I",,"RORMSG")
"RTN","RORHL21",68,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,RORDFN,2,RORDFN)
"RTN","RORHL21",69,0)
 S $P(RORSEG,HLFS,30)=$$FM2HL^RORHL7(TMP)
"RTN","RORHL21",70,0)
 ;
"RTN","RORHL21",71,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL21",72,0)
 D SETSEG^RORHL7(.RORSEG)
"RTN","RORHL21",73,0)
 Q ERRCNT
"RTN","RORHL7")
0^87^B45330050
"RTN","RORHL7",1,0)
RORHL7 ;HCIOFO/SG - HL7 UTILITIES ; 8/20/03 3:10pm
"RTN","RORHL7",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORHL7",3,0)
 ;
"RTN","RORHL7",4,0)
 Q
"RTN","RORHL7",5,0)
 ;
"RTN","RORHL7",6,0)
 ;***** RETURNS THE BHS SEGMENT
"RTN","RORHL7",7,0)
 ;
"RTN","RORHL7",8,0)
 ; BID           Batch message ID
"RTN","RORHL7",9,0)
 ;
"RTN","RORHL7",10,0)
 ; [BDT]         Batch message creation time in internal FileMan
"RTN","RORHL7",11,0)
 ;               format (NOW by default)
"RTN","RORHL7",12,0)
 ;
"RTN","RORHL7",13,0)
 ; [COMMENT]     Optional comment
"RTN","RORHL7",14,0)
 ;
"RTN","RORHL7",15,0)
 ; The RORHL local variable must be initialized by the $$INIT^RORHL7
"RTN","RORHL7",16,0)
 ; function before calling this entry point.
"RTN","RORHL7",17,0)
 ;
"RTN","RORHL7",18,0)
BHS(BID,BDT,COMMENT) ;
"RTN","RORHL7",19,0)
 N SEG
"RTN","RORHL7",20,0)
 D BHS^HLFNC3(.RORHL,BID,.SEG)
"RTN","RORHL7",21,0)
 Q:$G(SEG)="" ""
"RTN","RORHL7",22,0)
 ;---
"RTN","RORHL7",23,0)
 S SEG=SEG_$G(SEG(1))
"RTN","RORHL7",24,0)
 S:$G(BDT)'>0 BDT=$$NOW^XLFDT
"RTN","RORHL7",25,0)
 S $P(SEG,RORHL("FS"),7)=$$FMTHL7^XLFDT(BDT)
"RTN","RORHL7",26,0)
 S $P(SEG,RORHL("FS"),10)=$G(COMMENT)
"RTN","RORHL7",27,0)
 Q SEG
"RTN","RORHL7",28,0)
 ;
"RTN","RORHL7",29,0)
 ;***** RETURNS BTS SEGMENT
"RTN","RORHL7",30,0)
 ;
"RTN","RORHL7",31,0)
 ; MSGCNT        Batch message count
"RTN","RORHL7",32,0)
 ; [COMMENT]     Batch comment
"RTN","RORHL7",33,0)
 ;
"RTN","RORHL7",34,0)
 ; The RORHL variable must be initialized by the INIT^HLFNC2 before
"RTN","RORHL7",35,0)
 ; calling this entry point
"RTN","RORHL7",36,0)
 ;
"RTN","RORHL7",37,0)
BTS(MSGCNT,COMMENT) ;
"RTN","RORHL7",38,0)
 Q "BTS"_RORHL("FS")_MSGCNT_RORHL("FS")_$G(COMMENT)
"RTN","RORHL7",39,0)
 ;
"RTN","RORHL7",40,0)
 ;***** CREATES A NEW MESSAGE IN THE BATCH
"RTN","RORHL7",41,0)
 ;
"RTN","RORHL7",42,0)
 ; The function adds a new message header to the batch. If the batch
"RTN","RORHL7",43,0)
 ; does not exist yet, it is created.
"RTN","RORHL7",44,0)
 ;
"RTN","RORHL7",45,0)
 ; [.RORMSH]     Reference to a variable in what a MSH segment of
"RTN","RORHL7",46,0)
 ;               the message is returned.
"RTN","RORHL7",47,0)
 ;
"RTN","RORHL7",48,0)
 ; Return Values:
"RTN","RORHL7",49,0)
 ;        <0  Error Code
"RTN","RORHL7",50,0)
 ;        >0  Index of a subnode of the ^TMP("HLS",$J) that
"RTN","RORHL7",51,0)
 ;            contains the new MSH segment.
"RTN","RORHL7",52,0)
 ;
"RTN","RORHL7",53,0)
 ; MSH segment is returned as a value of the RORMSH parameter. In case
"RTN","RORHL7",54,0)
 ; of a long segment, continuations are returned as subnodes.
"RTN","RORHL7",55,0)
 ;
"RTN","RORHL7",56,0)
 ; Several nodes (HL7*) in ROREXT are set and the ^TMP("HLS",$J) node
"RTN","RORHL7",57,0)
 ; is deleted by this entry point before it creates a new batch.
"RTN","RORHL7",58,0)
 ;
"RTN","RORHL7",59,0)
CREATE(RORMSH) ;
"RTN","RORHL7",60,0)
 N NDX,RC,TMP  K RORMSH
"RTN","RORHL7",61,0)
 Q:$G(ROREXT("HL7PROT"))="" $$ERROR^RORERR(-25)
"RTN","RORHL7",62,0)
 ;--- Create a message stub for the new batch message
"RTN","RORHL7",63,0)
 ;    (if it has not been created before)
"RTN","RORHL7",64,0)
 I '$G(ROREXT("HL7MTIEN"))  D  Q:$G(RC)<0 RC
"RTN","RORHL7",65,0)
 . N RORMID,RORIEN,RORDT
"RTN","RORHL7",66,0)
 . ;--- Set up HL7 environment variables
"RTN","RORHL7",67,0)
 . S RC=$$INIT($NA(^TMP("HLS",$J)))  Q:RC<0
"RTN","RORHL7",68,0)
 . ;--- Create a stub
"RTN","RORHL7",69,0)
 . D CREATE^HLTF(.RORMID,.RORIEN,.RORDT)
"RTN","RORHL7",70,0)
 . ;--- Save parameters of the new batch message
"RTN","RORHL7",71,0)
 . S (ROREXT("HL7CNT"),ROREXT("HL7SIZE"))=0
"RTN","RORHL7",72,0)
 . S ROREXT("HL7DT")=RORDT
"RTN","RORHL7",73,0)
 . S ROREXT("HL7MID")=RORMID
"RTN","RORHL7",74,0)
 . S ROREXT("HL7MTIEN")=RORIEN
"RTN","RORHL7",75,0)
 . ;--- Initialize temporary storage
"RTN","RORHL7",76,0)
 . K ^TMP("HLS",$J)
"RTN","RORHL7",77,0)
 ;--- Initialize the HL7 environment variables
"RTN","RORHL7",78,0)
 S RC=$$INIT()  Q:RC<0 RC
"RTN","RORHL7",79,0)
 S NDX=$G(ROREXT("HL7PTR"))+1
"RTN","RORHL7",80,0)
 ;--- Reset the Set ID's for all supported segments
"RTN","RORHL7",81,0)
 F TMP="OBR","OBX","PV1","ZRD","ZSP"  D
"RTN","RORHL7",82,0)
 . S ROREXT("HL7SID",TMP)=1
"RTN","RORHL7",83,0)
 ;--- Create and store a MSH segment for individual message
"RTN","RORHL7",84,0)
 S ROREXT("HL7CNT")=ROREXT("HL7CNT")+1
"RTN","RORHL7",85,0)
 S TMP=ROREXT("HL7MID")_"-"_ROREXT("HL7CNT")
"RTN","RORHL7",86,0)
 D MSH^HLFNC2(.RORHL,TMP,.RORMSH)
"RTN","RORHL7",87,0)
 M ^TMP("HLS",$J,NDX)=RORMSH
"RTN","RORHL7",88,0)
 S ROREXT("HL7SIZE")=ROREXT("HL7SIZE")+$L(RORMSH)+$L($G(RORMSH(1)))+1
"RTN","RORHL7",89,0)
 S ROREXT("HL7PTR")=NDX
"RTN","RORHL7",90,0)
 Q NDX
"RTN","RORHL7",91,0)
 ;
"RTN","RORHL7",92,0)
 ;***** REPLACES ENCODING CHARACTERS WITH ESCAPE CODES
"RTN","RORHL7",93,0)
 ;
"RTN","RORHL7",94,0)
 ; STR           Source string
"RTN","RORHL7",95,0)
 ;
"RTN","RORHL7",96,0)
 ; The HLFS and HLECH variables must be initialized before
"RTN","RORHL7",97,0)
 ; calling this function (either by the INIT^HLFNC2 or manually).
"RTN","RORHL7",98,0)
 ;
"RTN","RORHL7",99,0)
 ; The function returns the source string with encoding
"RTN","RORHL7",100,0)
 ; characters replaced with corresponding escape codes.
"RTN","RORHL7",101,0)
 ;
"RTN","RORHL7",102,0)
ESCAPE(STR) ;
"RTN","RORHL7",103,0)
 Q:STR="" STR
"RTN","RORHL7",104,0)
 N BUF,ESC,CH,I1,I2,SCLST
"RTN","RORHL7",105,0)
 S SCLST=HLECH_HLFS
"RTN","RORHL7",106,0)
 ;--- Find all occurrences of encoding characters and
"RTN","RORHL7",107,0)
 ;    save their positions to a local array
"RTN","RORHL7",108,0)
 F I1=1:1:5  S CH=$E(SCLST,I1),I2=1  Q:CH=""  D
"RTN","RORHL7",109,0)
 . F  S I2=$F(STR,CH,I2)  Q:'I2  S BUF(I2-1)=I1
"RTN","RORHL7",110,0)
 Q:$D(BUF)<10 STR
"RTN","RORHL7",111,0)
 ;--- Replace encoding characters with escape codes
"RTN","RORHL7",112,0)
 S (BUF,I2)="",ESC=$E(HLECH,3)  S:ESC="" ESC="\"
"RTN","RORHL7",113,0)
 F  S I1=I2,I2=$O(BUF(I2))  Q:I2=""  D
"RTN","RORHL7",114,0)
 . S BUF=BUF_$E(STR,I1+1,I2-1)_ESC_$E("SRETF",BUF(I2))_ESC
"RTN","RORHL7",115,0)
 Q BUF_$E(STR,I1+1,$L(STR))
"RTN","RORHL7",116,0)
 ;
"RTN","RORHL7",117,0)
 ;***** CHECKS THE DATE/TIME AND CONVERTS IT TO HL7 FORMAT
"RTN","RORHL7",118,0)
 ;
"RTN","RORHL7",119,0)
 ; DATE          Date/time in FileMan format
"RTN","RORHL7",120,0)
 ;
"RTN","RORHL7",121,0)
FM2HL(DATE) ;
"RTN","RORHL7",122,0)
 Q:'$G(DATE) """"""
"RTN","RORHL7",123,0)
 S DATE=$$FMTHL7^XLFDT(DATE)
"RTN","RORHL7",124,0)
 Q $S(DATE>0:DATE,1:"")
"RTN","RORHL7",125,0)
 ;
"RTN","RORHL7",126,0)
 ;***** INITIALIZES THE HL7 ENVIRONMENT VARIABLES
"RTN","RORHL7",127,0)
 ;
"RTN","RORHL7",128,0)
 ; [ROR8FILE]    Closed root of the buffer that will be used for
"RTN","RORHL7",129,0)
 ;               construction of the HL7 message.
"RTN","RORHL7",130,0)
 ;
"RTN","RORHL7",131,0)
 ; Return Values:
"RTN","RORHL7",132,0)
 ;        <0  Error Code
"RTN","RORHL7",133,0)
 ;         0  Ok
"RTN","RORHL7",134,0)
 ;
"RTN","RORHL7",135,0)
INIT(ROR8FILE) ;
"RTN","RORHL7",136,0)
 N TMP  K RORHL
"RTN","RORHL7",137,0)
 D INIT^HLFNC2(ROREXT("HL7PROT"),.RORHL)
"RTN","RORHL7",138,0)
 Q:$G(RORHL) $$ERROR^RORERR(-23,,RORHL)
"RTN","RORHL7",139,0)
 S TMP=$G(RORHL("ECH"))
"RTN","RORHL7",140,0)
 Q:$L(TMP)<4 $$ERROR^RORERR(-75)
"RTN","RORHL7",141,0)
 ;--- Initialize the nodes required for the API's
"RTN","RORHL7",142,0)
 S:$G(ROR8FILE)'="" ROREXT("HL7BUF")=ROR8FILE
"RTN","RORHL7",143,0)
 D:$G(ROREXT("HL7BUF"))'=""
"RTN","RORHL7",144,0)
 . S ROREXT("HL7PTR")=+$O(@ROREXT("HL7BUF")@(""),-1)
"RTN","RORHL7",145,0)
 Q 0
"RTN","RORHL7",146,0)
 ;
"RTN","RORHL7",147,0)
 ;***** CHECKS IF MAXIMUM BATCH SIZE IS REACHED
"RTN","RORHL7",148,0)
 ;
"RTN","RORHL7",149,0)
 ; [RESERVE]     Number of bytes reserved in the batch (0 by default)
"RTN","RORHL7",150,0)
 ;
"RTN","RORHL7",151,0)
 ; Return Values:
"RTN","RORHL7",152,0)
 ;         0  Messages can be added to the batch
"RTN","RORHL7",153,0)
 ;         1  Maximum size of the batch has been reached
"RTN","RORHL7",154,0)
 ;
"RTN","RORHL7",155,0)
ISMAXSZ(RESERVE) ;
"RTN","RORHL7",156,0)
 Q:$G(ROREXT("MAXHL7SIZE"))'>0 0
"RTN","RORHL7",157,0)
 Q:($G(ROREXT("HL7SIZE"))+$G(RESERVE))<ROREXT("MAXHL7SIZE") 0
"RTN","RORHL7",158,0)
 S $P(ROREXT("HL7SIZE"),U,2)=1
"RTN","RORHL7",159,0)
 Q 1
"RTN","RORHL7",160,0)
 ;
"RTN","RORHL7",161,0)
 ;***** RETURNS NUMBER OF MESSAGES IN THE CURRENT BATCH
"RTN","RORHL7",162,0)
MSGCNT() ;
"RTN","RORHL7",163,0)
 Q $G(ROREXT("HL7CNT"))
"RTN","RORHL7",164,0)
 ;
"RTN","RORHL7",165,0)
 ;***** RETURNS TEXT EXPLANATIONS OF THE HL7 MESSAGE STATUS
"RTN","RORHL7",166,0)
 ;
"RTN","RORHL7",167,0)
 ; MSGST         Status value returned by the $$MSGSTAT^HLUTIL
"RTN","RORHL7",168,0)
 ;
"RTN","RORHL7",169,0)
MSGSTXT(MSGST) ;
"RTN","RORHL7",170,0)
 N ST  S ST=+MSGST
"RTN","RORHL7",171,0)
 Q:'ST "Message does not exist"
"RTN","RORHL7",172,0)
 Q:ST=1 "Waiting in queue"
"RTN","RORHL7",173,0)
 Q:ST=1.5 "Opening connection"
"RTN","RORHL7",174,0)
 Q:ST=1.7 "Awaiting response"
"RTN","RORHL7",175,0)
 Q:ST=2 "Awaiting application ack"
"RTN","RORHL7",176,0)
 Q:ST=3 "Successfully completed"
"RTN","RORHL7",177,0)
 Q:ST=4 "Error"
"RTN","RORHL7",178,0)
 Q:ST=8 "Being generated"
"RTN","RORHL7",179,0)
 Q:ST=9 "Awaiting processing"
"RTN","RORHL7",180,0)
 Q "Unknown"
"RTN","RORHL7",181,0)
 ;
"RTN","RORHL7",182,0)
 ;***** RETURNS THE POINTER TO LAST SEGMENT IN THE MESSAGE BUFFER
"RTN","RORHL7",183,0)
PTR() Q +$G(ROREXT("HL7PTR"))
"RTN","RORHL7",184,0)
 ;
"RTN","RORHL7",185,0)
 ;***** DELETES AN INCOMPLETE MESSAGE FROM THE ^TMP("HLS",$J)
"RTN","RORHL7",186,0)
 ;
"RTN","RORHL7",187,0)
 ; MSHPTR        An index of the MSH segment in the ^TMP("HLS",$J)
"RTN","RORHL7",188,0)
 ;
"RTN","RORHL7",189,0)
ROLLBACK(MSHPTR) ;
"RTN","RORHL7",190,0)
 N I,I1  S I=+MSHPTR
"RTN","RORHL7",191,0)
 F  Q:I=""  D  S I=$O(^TMP("HLS",$J,I))
"RTN","RORHL7",192,0)
 . ;--- Decrease current size of the batch
"RTN","RORHL7",193,0)
 . S I1=$L($G(^TMP("HLS",$J,I)))
"RTN","RORHL7",194,0)
 . S ROREXT("HL7SIZE")=$G(ROREXT("HL7SIZE"))-I1-1
"RTN","RORHL7",195,0)
 . S I1=""
"RTN","RORHL7",196,0)
 . F  S I1=$O(^TMP("HLS",$J,I,I1))  Q:I1=""  D
"RTN","RORHL7",197,0)
 . . S ROREXT("HL7SIZE")=ROREXT("HL7SIZE")-$L(^TMP("HLS",$J,I,I1))
"RTN","RORHL7",198,0)
 . ;--- Delete the segment
"RTN","RORHL7",199,0)
 . K ^TMP("HLS",$J,I)
"RTN","RORHL7",200,0)
 ;--- Validate current size of the batch
"RTN","RORHL7",201,0)
 S:$G(ROREXT("HL7SIZE"))<0 ROREXT("HL7SIZE")=0
"RTN","RORHL7",202,0)
 ;--- Decrease number of messages in the batch
"RTN","RORHL7",203,0)
 S:$G(ROREXT("HL7CNT"))>0 ROREXT("HL7CNT")=ROREXT("HL7CNT")-1
"RTN","RORHL7",204,0)
 Q
"RTN","RORHL7",205,0)
 ;
"RTN","RORHL7",206,0)
 ;***** SENDS THE BATCH MESSAGE
"RTN","RORHL7",207,0)
 ;
"RTN","RORHL7",208,0)
 ; .MID          Reference to a local variable where the batch
"RTN","RORHL7",209,0)
 ;               message ID (returned by the GENERATE^HLMA) is
"RTN","RORHL7",210,0)
 ;               returned to.
"RTN","RORHL7",211,0)
 ;
"RTN","RORHL7",212,0)
 ; Return Values:
"RTN","RORHL7",213,0)
 ;        <0  Error Code
"RTN","RORHL7",214,0)
 ;         0  Ok
"RTN","RORHL7",215,0)
 ;        >0  There was nothing to send
"RTN","RORHL7",216,0)
 ;
"RTN","RORHL7",217,0)
 ; Several nodes (HL7*) in the ROREXT and the ^TMP("HLS",$J) node
"RTN","RORHL7",218,0)
 ; are deleted by this entry point.
"RTN","RORHL7",219,0)
 ;
"RTN","RORHL7",220,0)
SEND(MID) ;
"RTN","RORHL7",221,0)
 N RC,RORBUF,RORHLP  S MID=""
"RTN","RORHL7",222,0)
 Q:$G(ROREXT("HL7PROT"))="" $$ERROR^RORERR(-25)
"RTN","RORHL7",223,0)
 ;--- Quit if there is nothing to send
"RTN","RORHL7",224,0)
 Q:'$G(ROREXT("HL7MTIEN"))!($D(^TMP("HLS",$J))<10) 1
"RTN","RORHL7",225,0)
 ;--- Set up the HL7 environment variables
"RTN","RORHL7",226,0)
 D INIT^HLFNC2(ROREXT("HL7PROT"),.RORHL)
"RTN","RORHL7",227,0)
 Q:$G(RORHL) $$ERROR^RORERR(-23,,RORHL)
"RTN","RORHL7",228,0)
 ;--- Send the message
"RTN","RORHL7",229,0)
 S RORHLP("NAMESPACE")="ROR"
"RTN","RORHL7",230,0)
 D GENERATE^HLMA(ROREXT("HL7PROT"),"GB",1,.RORBUF,ROREXT("HL7MTIEN"),.RORHLP)
"RTN","RORHL7",231,0)
 ;D DIRECT^HLMA(ROREXT("HL7PROT"),"GB",1,.RORBUF,ROREXT("HL7MTIEN"),.RORHLP)
"RTN","RORHL7",232,0)
 S RC=$S($P(RORBUF,U,2):$$ERROR^RORERR(-24,,RORBUF),1:0)
"RTN","RORHL7",233,0)
 S MID=$P(RORBUF,U)
"RTN","RORHL7",234,0)
 ;--- Cleanup if there is no error or not in debug mode
"RTN","RORHL7",235,0)
 D:'$G(RORPARM("DEBUG"))!(RC'<0)
"RTN","RORHL7",236,0)
 . F TMP="HL7CNT","HL7DT","HL7MTIEN","HL7SIZE"  K ROREXT(TMP)
"RTN","RORHL7",237,0)
 . K ^TMP("HLS",$J)
"RTN","RORHL7",238,0)
 Q RC
"RTN","RORHL7",239,0)
 ;
"RTN","RORHL7",240,0)
 ;***** ASSIGNS THE 'SET ID'
"RTN","RORHL7",241,0)
 ;
"RTN","RORHL7",242,0)
 ; SEGNAME       Name of the HL7 segment
"RTN","RORHL7",243,0)
 ; [DISINC]      Disable increment of the Set ID
"RTN","RORHL7",244,0)
 ;
"RTN","RORHL7",245,0)
 ; Return Values:
"RTN","RORHL7",246,0)
 ;        ""  Not required for this segment
"RTN","RORHL7",247,0)
 ;        >0  Value for the Set ID field
"RTN","RORHL7",248,0)
 ;
"RTN","RORHL7",249,0)
SETID(SEGNAME,DISINC) ;
"RTN","RORHL7",250,0)
 N SETID
"RTN","RORHL7",251,0)
 Q:$G(SEGNAME)="" ""
"RTN","RORHL7",252,0)
 S SETID=+$G(ROREXT("HL7SID",SEGNAME))
"RTN","RORHL7",253,0)
 Q:SETID'>0 ""
"RTN","RORHL7",254,0)
 S:'$G(DISINC) ROREXT("HL7SID",SEGNAME)=SETID+1
"RTN","RORHL7",255,0)
 Q SETID
"RTN","RORHL7",256,0)
 ;
"RTN","RORHL7",257,0)
 ;***** STORES THE SEGMENT INTO THE ^TMP("HLS",$J) BUFFER
"RTN","RORHL7",258,0)
 ;
"RTN","RORHL7",259,0)
 ; SEG           HL7 segment
"RTN","RORHL7",260,0)
 ;
"RTN","RORHL7",261,0)
 ; The SETSEG^RORHL7 procedure stores the HL7 segment into the
"RTN","RORHL7",262,0)
 ; standard HL7 buffer ^TMP("HLS",$J). The <TAB>, <CR> and <LF>
"RTN","RORHL7",263,0)
 ; characters are replaced with spaces. Long segments are split among 
"RTN","RORHL7",264,0)
 ; sub-nodes of the main segment node.
"RTN","RORHL7",265,0)
 ;
"RTN","RORHL7",266,0)
 ; The RORHL array and some nodes of the ROREXT array must be
"RTN","RORHL7",267,0)
 ; initialized (either by the $$INIT^RORHL7 or manually) before
"RTN","RORHL7",268,0)
 ; calling this function.
"RTN","RORHL7",269,0)
 ;
"RTN","RORHL7",270,0)
SETSEG(SEG) ;
"RTN","RORHL7",271,0)
 N I1,I2,MAXLEN,NODE,PTR,PTR1,SID,SL
"RTN","RORHL7",272,0)
 S NODE=ROREXT("HL7BUF"),PTR=$G(ROREXT("HL7PTR"))+1
"RTN","RORHL7",273,0)
 S SL=$L(SEG),MAXLEN=245  K @NODE@(PTR)
"RTN","RORHL7",274,0)
 ;--- Assign the Set ID if necessary
"RTN","RORHL7",275,0)
 S SID=$$SETID($P(SEG,RORHL("FS")))
"RTN","RORHL7",276,0)
 S:SID>0 $P(SEG,RORHL("FS"),2)=SID
"RTN","RORHL7",277,0)
 ;--- Store the segment
"RTN","RORHL7",278,0)
 S @NODE@(PTR)=$TR($E(SEG,1,MAXLEN),$C(9,10,13),"   ")
"RTN","RORHL7",279,0)
 S ROREXT("HL7SIZE")=$G(ROREXT("HL7SIZE"))+SL+1
"RTN","RORHL7",280,0)
 ;--- Split the segment into sub-nodes if necessary
"RTN","RORHL7",281,0)
 D:SL>MAXLEN
"RTN","RORHL7",282,0)
 . S I2=MAXLEN
"RTN","RORHL7",283,0)
 . F PTR1=1:1  S I1=I2+1,I2=I1+MAXLEN-1  Q:I1>SL  D
"RTN","RORHL7",284,0)
 . . S @NODE@(PTR,PTR1)=$TR($E(SEG,I1,I2),$C(9,10,13),"   ")
"RTN","RORHL7",285,0)
 ;--- Save the pointer
"RTN","RORHL7",286,0)
 S ROREXT("HL7PTR")=PTR
"RTN","RORHL7",287,0)
 Q
"RTN","RORHL7A")
0^95^B8190977
"RTN","RORHL7A",1,0)
RORHL7A ;HCIOFO/SG - HL7 UTILITIES ; 6/12/03 3:21pm
"RTN","RORHL7A",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHL7A",3,0)
 ;
"RTN","RORHL7A",4,0)
 Q
"RTN","RORHL7A",5,0)
 ;
"RTN","RORHL7A",6,0)
 ;***** APPENDS THE FIELD VALUE TO THE HL7 SEGMENT
"RTN","RORHL7A",7,0)
 ;
"RTN","RORHL7A",8,0)
 ; VAL           Value of the field (or its part)
"RTN","RORHL7A",9,0)
 ;
"RTN","RORHL7A",10,0)
APPEND(VAL) ;
"RTN","RORHL7A",11,0)
 N BASE,L
"RTN","RORHL7A",12,0)
 S L=$L(VAL)
"RTN","RORHL7A",13,0)
 I L<RORSL  S RORBUF=RORBUF_VAL,RORSL=RORSL-L  Q
"RTN","RORHL7A",14,0)
 ;---
"RTN","RORHL7A",15,0)
 S RORBUF=RORBUF_$E(VAL,1,RORSL),L=L-RORSL
"RTN","RORHL7A",16,0)
 S BASE=1
"RTN","RORHL7A",17,0)
 F  D  Q:L'>0
"RTN","RORHL7A",18,0)
 . I 'RORIS  S @RORNODE@(RORPTR)=RORBUF
"RTN","RORHL7A",19,0)
 . E  S @RORNODE@(RORPTR,RORIS)=RORBUF
"RTN","RORHL7A",20,0)
 . S BASE=BASE+RORSL,RORIS=RORIS+1,RORSL=245
"RTN","RORHL7A",21,0)
 . S RORBUF=$E(VAL,BASE,BASE+RORSL-1),L=L-RORSL
"RTN","RORHL7A",22,0)
 S RORSL=-L
"RTN","RORHL7A",23,0)
 Q
"RTN","RORHL7A",24,0)
 ;
"RTN","RORHL7A",25,0)
 ;***** LOADS THE HL7 FIELD (OR ITS PART) TO THE BUFFER
"RTN","RORHL7A",26,0)
 ;
"RTN","RORHL7A",27,0)
 ; VAL           Value of the field (or its part)
"RTN","RORHL7A",28,0)
 ;
"RTN","RORHL7A",29,0)
 ; FLD           Number of the field in the segment (piece number)
"RTN","RORHL7A",30,0)
 ;
"RTN","RORHL7A",31,0)
FIELD(VAL,FLD) ;
"RTN","RORHL7A",32,0)
 N BASE,L
"RTN","RORHL7A",33,0)
 S:FLD>RORFLD RORFLD=FLD,RORIS=0,RORSL=245
"RTN","RORHL7A",34,0)
 S L=$L(VAL),BASE=1
"RTN","RORHL7A",35,0)
 F RORIS=RORIS:1  D  Q:L'>0
"RTN","RORHL7A",36,0)
 . I 'RORIS  S RORSEG(RORFLD)=$G(RORSEG(RORFLD))_$E(VAL,BASE,BASE+RORSL-1)
"RTN","RORHL7A",37,0)
 . E  S RORSEG(RORFLD,RORIS)=$G(RORSEG(RORFLD,RORIS))_$E(VAL,BASE,BASE+RORSL-1)
"RTN","RORHL7A",38,0)
 . S BASE=BASE+RORSL,L=L-RORSL,RORSL=245
"RTN","RORHL7A",39,0)
 S RORSL=-L
"RTN","RORHL7A",40,0)
 Q
"RTN","RORHL7A",41,0)
 ;
"RTN","RORHL7A",42,0)
 ;***** LOADS THE HL7 SEGMENT TO THE BUFFER
"RTN","RORHL7A",43,0)
 ;
"RTN","RORHL7A",44,0)
 ; .RORSEG       Reference to a local variable where the HL7
"RTN","RORHL7A",45,0)
 ;               fields will be stored. The fields are stored
"RTN","RORHL7A",46,0)
 ;               in the following format:
"RTN","RORHL7A",47,0)
 ;
"RTN","RORHL7A",48,0)
 ;                 RORSEG(FldNum)=FldVal
"RTN","RORHL7A",49,0)
 ;
"RTN","RORHL7A",50,0)
 ;               If the value is longer that 245 characters then
"RTN","RORHL7A",51,0)
 ;               the continuation nodes are created:
"RTN","RORHL7A",52,0)
 ;
"RTN","RORHL7A",53,0)
 ;                 RORSEG(FldNum,#)=FldValCont
"RTN","RORHL7A",54,0)
 ;
"RTN","RORHL7A",55,0)
 ; ROR8SRC       Closed root of the source buffer containing
"RTN","RORHL7A",56,0)
 ;               the HL7 segments
"RTN","RORHL7A",57,0)
 ;
"RTN","RORHL7A",58,0)
 ; ISEG          Subscript of the segment that should be loaded
"RTN","RORHL7A",59,0)
 ;
"RTN","RORHL7A",60,0)
LOAD(RORSEG,ROR8SRC,ISEG) ;
"RTN","RORHL7A",61,0)
 N BUF,FLD,I,IFL,NFL,RORFLD,RORIS,RORSL
"RTN","RORHL7A",62,0)
 S HLFS=$G(RORHL("FS"),"|")  K RORSEG
"RTN","RORHL7A",63,0)
 ;--- Process the main segment
"RTN","RORHL7A",64,0)
 S BUF=$G(@ROR8SRC@(ISEG)),NFL=$L(BUF,HLFS)
"RTN","RORHL7A",65,0)
 F IFL=1:1:NFL  S RORSEG(IFL)=$P(BUF,HLFS,IFL)
"RTN","RORHL7A",66,0)
 Q:$D(@ROR8SRC@(ISEG))<10
"RTN","RORHL7A",67,0)
 ;--- Process the sub-segments
"RTN","RORHL7A",68,0)
 S (FLD,RORFLD)=NFL,RORIS=0,RORSL=245-$L(RORSEG(FLD))
"RTN","RORHL7A",69,0)
 S I=""
"RTN","RORHL7A",70,0)
 F  S I=$O(@ROR8SRC@(ISEG,I))  Q:I=""  D
"RTN","RORHL7A",71,0)
 . S BUF=@ROR8SRC@(ISEG,I),NFL=$L(BUF,HLFS)
"RTN","RORHL7A",72,0)
 . D FIELD($P(BUF,HLFS),FLD)
"RTN","RORHL7A",73,0)
 . F IFL=2:1:NFL  S FLD=FLD+1  D FIELD($P(BUF,HLFS,IFL),FLD)
"RTN","RORHL7A",74,0)
 Q
"RTN","RORHL7A",75,0)
 ;
"RTN","RORHL7A",76,0)
 ;***** STORES THE HL7 SEGMENT
"RTN","RORHL7A",77,0)
 ;
"RTN","RORHL7A",78,0)
 ; .RORSEG       Reference to a local variable where the HL7
"RTN","RORHL7A",79,0)
 ;               fields are stored (loaded by the LOAD^RORHL7A)
"RTN","RORHL7A",80,0)
 ;
"RTN","RORHL7A",81,0)
SAVE(SEGMENT) ;
"RTN","RORHL7A",82,0)
 N RORBUF,FLD,I,NFL,RORIS,RORNODE,RORPTR,RORSL
"RTN","RORHL7A",83,0)
 S RORNODE=ROREXT("HL7BUF"),RORPTR=$G(ROREXT("HL7PTR"))+1
"RTN","RORHL7A",84,0)
 S HLFS=$G(RORHL("FS"),"|")
"RTN","RORHL7A",85,0)
 ;--- Get the segment name
"RTN","RORHL7A",86,0)
 S RORBUF=$G(SEGMENT(1))  Q:RORBUF=""
"RTN","RORHL7A",87,0)
 S RORIS=0,RORSL=245-$L(RORBUF)
"RTN","RORHL7A",88,0)
 S NFL=+$O(SEGMENT(" "),-1)
"RTN","RORHL7A",89,0)
 ;--- Append the fields and save the segment
"RTN","RORHL7A",90,0)
 F FLD=2:1:NFL  D
"RTN","RORHL7A",91,0)
 . D APPEND(HLFS_$G(SEGMENT(FLD)))
"RTN","RORHL7A",92,0)
 . ;--- Process the sub-fields
"RTN","RORHL7A",93,0)
 . S I=""
"RTN","RORHL7A",94,0)
 . F  S I=$O(SEGMENT(FLD,I))  Q:I=""  D APPEND(SEGMENT(FLD,I))
"RTN","RORHL7A",95,0)
 ;--- Flush the buffer if necessary
"RTN","RORHL7A",96,0)
 D:RORBUF'=""
"RTN","RORHL7A",97,0)
 . I 'RORIS  S @RORNODE@(RORPTR)=RORBUF  Q
"RTN","RORHL7A",98,0)
 . S @RORNODE@(RORPTR,RORIS)=RORBUF
"RTN","RORHL7A",99,0)
 S ROREXT("HL7PTR")=RORPTR
"RTN","RORHL7A",100,0)
 Q
"RTN","RORHLUT1")
0^89^B5697776
"RTN","RORHLUT1",1,0)
RORHLUT1 ;HCIOFO/SG - HL7 UTILITIES (HIGH LEVEL) ; 7/21/03 12:52pm
"RTN","RORHLUT1",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORHLUT1",3,0)
 ;
"RTN","RORHLUT1",4,0)
 Q
"RTN","RORHLUT1",5,0)
 ;
"RTN","RORHLUT1",6,0)
 ;***** RETURNS A REASON WHY THE PATIENT HAS BEEN ADDED
"RTN","RORHLUT1",7,0)
 ;
"RTN","RORHLUT1",8,0)
 ; RORIENS       IENS of Patient Record in Registry File
"RTN","RORHLUT1",9,0)
 ;
"RTN","RORHLUT1",10,0)
 ; CS            HL7 component separator
"RTN","RORHLUT1",11,0)
 ;
"RTN","RORHLUT1",12,0)
ADREASON(RORIENS,CS) ;
"RTN","RORHLUT1",13,0)
 N CODE,ICD9,LAB,NAME,NODE,IEN,RORMSG,TMP
"RTN","RORHLUT1",14,0)
 S (CODE,ICD9,LAB)=0
"RTN","RORHLUT1",15,0)
 S NODE=$$ROOT^DILFD(798.01,","_RORIENS,1)
"RTN","RORHLUT1",16,0)
 Q:NODE="" ""
"RTN","RORHLUT1",17,0)
 ;--- Check the names of selection rules
"RTN","RORHLUT1",18,0)
 S IEN=0
"RTN","RORHLUT1",19,0)
 F  S IEN=$O(@NODE@("B",IEN))  Q:IEN'>0  D
"RTN","RORHLUT1",20,0)
 . S NAME=$$GET1^DIQ(798.2,IEN_",",.01,,,"RORMSG")
"RTN","RORHLUT1",21,0)
 . I $G(DIERR)  D  Q
"RTN","RORHLUT1",22,0)
 . . D DBS^RORERR("RORMSG",-9,,,798.2,IEN_",")
"RTN","RORHLUT1",23,0)
 . Q:$E(NAME,1,2)'="VA"
"RTN","RORHLUT1",24,0)
 . I NAME?1.E1" LAB"             S LAB=1   Q
"RTN","RORHLUT1",25,0)
 . I NAME?1.E1" PROBLEM"         S ICD9=1  Q
"RTN","RORHLUT1",26,0)
 . I NAME?1.E1" PTF".1" HIST"    S ICD9=1  Q
"RTN","RORHLUT1",27,0)
 . I NAME?1.E1" VISIT".1" HIST"  S ICD9=1  Q
"RTN","RORHLUT1",28,0)
 . I NAME?1.E1" VPOV"            S ICD9=1  Q
"RTN","RORHLUT1",29,0)
 ;--- Check if the patient has been added automatically
"RTN","RORHLUT1",30,0)
 S NAME="Automatically Added - "
"RTN","RORHLUT1",31,0)
 I ICD9  S CODE=7,NAME=NAME_"ICD9"
"RTN","RORHLUT1",32,0)
 I LAB  S CODE=8  D:ICD9  S NAME=NAME_"Lab"
"RTN","RORHLUT1",33,0)
 . S CODE=9,NAME=NAME_" and "
"RTN","RORHLUT1",34,0)
 ;--- Check the supporting evidence
"RTN","RORHLUT1",35,0)
 D:'CODE
"RTN","RORHLUT1",36,0)
 . S IEN=$$GET1^DIQ(798,RORIENS,3.2,"I",,"RORMSG")
"RTN","RORHLUT1",37,0)
 . I $G(DIERR)  D  Q
"RTN","RORHLUT1",38,0)
 . . D DBS^RORERR("RORMSG",-9,,,798,RORIENS)
"RTN","RORHLUT1",39,0)
 . S:IEN>0 CODE=$$ITEMCODE^RORUTL09(IEN,.NAME)
"RTN","RORHLUT1",40,0)
 ;---
"RTN","RORHLUT1",41,0)
 Q $S(CODE:CODE_CS_$$ESCAPE^RORHL7(NAME)_CS_"99VA79832",1:"")
"RTN","RORHLUT1",42,0)
 ;
"RTN","RORHLUT1",43,0)
 ;***** RETURNS THE HL7 VALUE FOR THE DIVISION FIELD
"RTN","RORHLUT1",44,0)
 ;
"RTN","RORHLUT1",45,0)
 ; IEN44         IEN in the HOSPITAL LOCATION file (#44)
"RTN","RORHLUT1",46,0)
 ;
"RTN","RORHLUT1",47,0)
 ; TYPE          Type of the result:
"RTN","RORHLUT1",48,0)
 ;                 1  Name^99VA4^StNum (OBR)
"RTN","RORHLUT1",49,0)
 ;                 2  StNum^Name^99VA4 (ORC)
"RTN","RORHLUT1",50,0)
 ;
"RTN","RORHLUT1",51,0)
 ; [CS]          Component separator ("^", by default))
"RTN","RORHLUT1",52,0)
 ;
"RTN","RORHLUT1",53,0)
 ; Return Values:
"RTN","RORHLUT1",54,0)
 ;       ""  Error
"RTN","RORHLUT1",55,0)
 ;     '=""  Value of the HL7 field
"RTN","RORHLUT1",56,0)
 ;
"RTN","RORHLUT1",57,0)
DIV44(IEN44,TYPE,CS) ;
"RTN","RORHLUT1",58,0)
 N DIV,IENS4,NAME,RORBUF,RORMSG,STN,TMP
"RTN","RORHLUT1",59,0)
 S:$G(CS)="" CS="^"
"RTN","RORHLUT1",60,0)
 S DIV=$S(TYPE=1:$$SITE1^RORUTL03(CS),TYPE=2:$$SITE^RORUTL03(CS),1:"")
"RTN","RORHLUT1",61,0)
 Q:IEN44'>0 DIV
"RTN","RORHLUT1",62,0)
 ;--- Get the pointer to the INSTITUTION file
"RTN","RORHLUT1",63,0)
 S IENS4=+$$GET1^DIQ(44,IEN44_",",3,"I",,"RORMSG")_","
"RTN","RORHLUT1",64,0)
 I $G(DIERR)  D  Q DIV
"RTN","RORHLUT1",65,0)
 . D DBS^RORERR("RORMSG",-9,,,44,IEN44_",")
"RTN","RORHLUT1",66,0)
 Q:IENS4'>0 DIV
"RTN","RORHLUT1",67,0)
 ;--- Load the station name and number
"RTN","RORHLUT1",68,0)
 D GETS^DIQ(4,IENS4,".01;99",,"RORBUF","RORMSG")
"RTN","RORHLUT1",69,0)
 I $G(DIERR)  D  Q DIV
"RTN","RORHLUT1",70,0)
 . D DBS^RORERR("RORMSG",-9,,,4,IENS4)
"RTN","RORHLUT1",71,0)
 S STN=$E($G(ROROUT(4,IENS4,99)),1,3)
"RTN","RORHLUT1",72,0)
 Q:STN="" DIV
"RTN","RORHLUT1",73,0)
 ;--- Construct the HL7 value
"RTN","RORHLUT1",74,0)
 S NAME=$$ESCAPE^RORHL7($G(RORBUF(4,IENS4,.01)))
"RTN","RORHLUT1",75,0)
 Q:TYPE=1 NAME_CS_"99VA4"_CS_STN
"RTN","RORHLUT1",76,0)
 Q:TYPE=2 STN_CS_NAME_CS_"99VA4"
"RTN","RORHLUT1",77,0)
 ;--- Invalid type
"RTN","RORHLUT1",78,0)
 Q ""
"RTN","RORICR01")
0^23^B6137970
"RTN","RORICR01",1,0)
RORICR01 ;HCIOFO/SG - ICR-SPECIFIC LAB DATA POST-PROCESSOR ; 11/19/03 10:03am
"RTN","RORICR01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORICR01",3,0)
 ;
"RTN","RORICR01",4,0)
 ;--------------------------------------------------------------------
"RTN","RORICR01",5,0)
 ; Registry: [VA ICR]
"RTN","RORICR01",6,0)
 ;--------------------------------------------------------------------
"RTN","RORICR01",7,0)
 Q
"RTN","RORICR01",8,0)
 ;
"RTN","RORICR01",9,0)
 ;***** EXTRACTS AND PREPARES LABORATORY DATA
"RTN","RORICR01",10,0)
 ;
"RTN","RORICR01",11,0)
 ; PATIEN        Patient IEN
"RTN","RORICR01",12,0)
 ;
"RTN","RORICR01",13,0)
 ; STDT          Extract from this date
"RTN","RORICR01",14,0)
 ; ENDT          Extract until this date
"RTN","RORICR01",15,0)
 ;
"RTN","RORICR01",16,0)
 ; [HDTMODE]     If this parameter is defined and non-zero, start and
"RTN","RORICR01",17,0)
 ;               end dates are specimen collection dates. Otherwise,
"RTN","RORICR01",18,0)
 ;               they are dates of the results.
"RTN","RORICR01",19,0)
 ;
"RTN","RORICR01",20,0)
 ; The function uses node ^TMP("RORTMP",$J) as a temporary storage.
"RTN","RORICR01",21,0)
 ;
"RTN","RORICR01",22,0)
 ; Return Values:
"RTN","RORICR01",23,0)
 ;       <0  Error Code
"RTN","RORICR01",24,0)
 ;        0  Ok
"RTN","RORICR01",25,0)
 ;
"RTN","RORICR01",26,0)
LABDATA(PATIEN,STDT,ENDT,HDTMODE) ;
"RTN","RORICR01",27,0)
 N RC,RORTMP,TMP
"RTN","RORICR01",28,0)
 S RORTMP=$NA(^TMP("RORTMP",$J))
"RTN","RORICR01",29,0)
 ;--- Get the Lab results
"RTN","RORICR01",30,0)
 S TMP=$S($G(HDTMODE):"^CD",1:"^RAD")
"RTN","RORICR01",31,0)
 S RC=$$LABRSLTS^RORUTL02(PATIEN,STDT_TMP,ENDT_TMP)
"RTN","RORICR01",32,0)
 Q:RC<0 RC
"RTN","RORICR01",33,0)
 ;--- Call the Lab data post-processor
"RTN","RORICR01",34,0)
 S RC=$$LABPROC(RORTMP,PATIEN)
"RTN","RORICR01",35,0)
 ;---
"RTN","RORICR01",36,0)
 K @RORTMP
"RTN","RORICR01",37,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORICR01",38,0)
 ;
"RTN","RORICR01",39,0)
 ;***** LABORATORY DATA POST-PROCESSOR
"RTN","RORICR01",40,0)
 ;
"RTN","RORICR01",41,0)
 ; ROR8TMP       Closed root of the array (local or global), which
"RTN","RORICR01",42,0)
 ;               contains the data loaded by the $$GCPR^LA7QRY
"RTN","RORICR01",43,0)
 ;
"RTN","RORICR01",44,0)
 ; PATIEN        Patient IEN
"RTN","RORICR01",45,0)
 ;
"RTN","RORICR01",46,0)
 ; Return Values:
"RTN","RORICR01",47,0)
 ;       <0  Error Code
"RTN","RORICR01",48,0)
 ;        0  Ok
"RTN","RORICR01",49,0)
 ;
"RTN","RORICR01",50,0)
LABPROC(ROR8TMP,PATIEN) ;
"RTN","RORICR01",51,0)
 N BUF,CS,DFLTSITE,FS,I,J,LABC,SEG,TMP
"RTN","RORICR01",52,0)
 ;--- Extract separators from the MSH segment
"RTN","RORICR01",53,0)
 S BUF=$G(@ROR8TMP@(1))
"RTN","RORICR01",54,0)
 S:$E(BUF,1,3)="MSH" FS=$E(BUF,4),CS=$E(BUF,5)
"RTN","RORICR01",55,0)
 S:$G(FS)="" FS="|"  S:$G(CS)="" CS="^"
"RTN","RORICR01",56,0)
 ;--- Initialize constants and variables
"RTN","RORICR01",57,0)
 S LABC="LABC"_CS_"Lab Comment"_CS_"VA080"
"RTN","RORICR01",58,0)
 ;--- Get the default station number and name
"RTN","RORICR01",59,0)
 S DFLTSITE=$$SITE^RORUTL03(CS)
"RTN","RORICR01",60,0)
 ;
"RTN","RORICR01",61,0)
 ;--- Add the results to the message
"RTN","RORICR01",62,0)
 S I=0
"RTN","RORICR01",63,0)
 F  S I=$O(@ROR8TMP@(I))  Q:I=""  D
"RTN","RORICR01",64,0)
 . S SEG(1)=$P(@ROR8TMP@(I),FS)  Q:SEG(1)=""
"RTN","RORICR01",65,0)
 . ;--- Ignore unnecessary segments
"RTN","RORICR01",66,0)
 . I SEG(1)'="NTE"  Q:'$D(ROREXT("HL7",1,SEG(1)))
"RTN","RORICR01",67,0)
 . ;--- Load the full segment
"RTN","RORICR01",68,0)
 . D LOAD^RORHL7A(.SEG,ROR8TMP,I)
"RTN","RORICR01",69,0)
 . ;--- Replace the local station with the default one
"RTN","RORICR01",70,0)
 . I SEG(1)="OBX"  S:$P($G(SEG(16)),CS)="" SEG(16)=DFLTSITE
"RTN","RORICR01",71,0)
 . ;--- Leave only the code of the Provider
"RTN","RORICR01",72,0)
 . I SEG(1)="OBR"  S SEG(17)=+$G(SEG(17)),SEG(25)="LAB"
"RTN","RORICR01",73,0)
 . ;--- Replace NTE's with OBX's
"RTN","RORICR01",74,0)
 . D:SEG(1)="NTE"
"RTN","RORICR01",75,0)
 . . K TMP  M TMP=SEG(4)  K SEG
"RTN","RORICR01",76,0)
 . . S SEG(1)="OBX"
"RTN","RORICR01",77,0)
 . . S SEG(2)=$$SETID^RORHL7("OBX")
"RTN","RORICR01",78,0)
 . . S SEG(3)="ST",SEG(4)=LABC,SEG(5)="LCOMM"
"RTN","RORICR01",79,0)
 . . M SEG(6)=TMP
"RTN","RORICR01",80,0)
 . . S SEG(12)="F"
"RTN","RORICR01",81,0)
 . ;--- Store the segment
"RTN","RORICR01",82,0)
 . D SAVE^RORHL7A(.SEG)
"RTN","RORICR01",83,0)
 Q 0
"RTN","RORICR02")
0^22^B6337333
"RTN","RORICR02",1,0)
RORICR02 ;HCIOFO/SG - ICR-SPECIFIC REGISTRY UPDATE CODE ; 1/26/04 8:49am
"RTN","RORICR02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORICR02",3,0)
 ;
"RTN","RORICR02",4,0)
 ; This routine uses the following IAs:
"RTN","RORICR02",5,0)
 ;
"RTN","RORICR02",6,0)
 ; #2762         Check for the patient merge (controlled)
"RTN","RORICR02",7,0)
 ;
"RTN","RORICR02",8,0)
 ;--------------------------------------------------------------------
"RTN","RORICR02",9,0)
 ; Registry: [VA ICR]
"RTN","RORICR02",10,0)
 ;--------------------------------------------------------------------
"RTN","RORICR02",11,0)
 Q
"RTN","RORICR02",12,0)
 ;
"RTN","RORICR02",13,0)
 ;***** CONVERTS ICR 2.1 RECORDS TO ICR 3.0 FORMAT
"RTN","RORICR02",14,0)
 ;
"RTN","RORICR02",15,0)
 ; RORREG        Registry IEN
"RTN","RORICR02",16,0)
 ;
"RTN","RORICR02",17,0)
 ; Return Values:
"RTN","RORICR02",18,0)
 ;       <0  Error Code
"RTN","RORICR02",19,0)
 ;        0  Ok
"RTN","RORICR02",20,0)
 ;
"RTN","RORICR02",21,0)
CONVERT(RORREG) ;
"RTN","RORICR02",22,0)
 N CODE,IMRIEN,PATIEN,RC,REGIEN,RULENAME,RULES,TMP
"RTN","RORICR02",23,0)
 D LOG^RORLOG(2,"ICR 2.1 Conversion")
"RTN","RORICR02",24,0)
 S REGIEN=+RORREG
"RTN","RORICR02",25,0)
 ;--- Prepare the selection rules
"RTN","RORICR02",26,0)
 S RULENAME="VA ICR 2.1 CONVERSION"
"RTN","RORICR02",27,0)
 S TMP=$$SRLIEN^RORUTL02(RULENAME)
"RTN","RORICR02",28,0)
 Q:TMP'>0 $$ERROR^RORERR(-3,,RULENAME)
"RTN","RORICR02",29,0)
 S RULES(1)=TMP_U_DT
"RTN","RORICR02",30,0)
 ;--- Convert the remaining records of ICR v2.1
"RTN","RORICR02",31,0)
 S (IMRIEN,RC)=0
"RTN","RORICR02",32,0)
 F  S IMRIEN=$O(^IMR(158,IMRIEN))  Q:IMRIEN'>0  D  Q:RC<0
"RTN","RORICR02",33,0)
 . S CODE=$P($G(^IMR(158,IMRIEN,0)),U)  Q:CODE'>0
"RTN","RORICR02",34,0)
 . S PATIEN=+$$XOR^RORUTL03(CODE)  Q:PATIEN'>0
"RTN","RORICR02",35,0)
 . ;--- Check if the patient has been merged
"RTN","RORICR02",36,0)
 . S TMP=+$G(^DPT(PATIEN,-9))  S:TMP>0 PATIEN=TMP
"RTN","RORICR02",37,0)
 . ;--- Check if the patient record in the file #2 is valid
"RTN","RORICR02",38,0)
 . Q:$$CHKPTR^RORUTL05(PATIEN)<0
"RTN","RORICR02",39,0)
 . ;--- Quit if the patient has already been added to the new registry
"RTN","RORICR02",40,0)
 . Q:$$PRRIEN^RORUTL01(PATIEN,REGIEN)>0
"RTN","RORICR02",41,0)
 . ;--- Check if the patient is an employee
"RTN","RORICR02",42,0)
 . Q:$$SKIPEMPL^RORUTL02(PATIEN,.REGIEN)
"RTN","RORICR02",43,0)
 . ;--- Add the patient to the new registry
"RTN","RORICR02",44,0)
 . S TMP=$$ADDPAT^RORUPD06(PATIEN,"VA ICR",.RULES)
"RTN","RORICR02",45,0)
 ;---
"RTN","RORICR02",46,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORICR02",47,0)
 ;
"RTN","RORICR02",48,0)
 ;***** AFTER UPDATE CALL-BACK ENTRY POINT
"RTN","RORICR02",49,0)
 ;
"RTN","RORICR02",50,0)
 ; RORIEN        An IEN of the newly added registry record
"RTN","RORICR02",51,0)
 ; PATIEN        Patient IEN
"RTN","RORICR02",52,0)
 ; REGIEN        Registry IEN
"RTN","RORICR02",53,0)
 ;
"RTN","RORICR02",54,0)
 ; Return Values:
"RTN","RORICR02",55,0)
 ;       <0  Error Code
"RTN","RORICR02",56,0)
 ;        0  Ok
"RTN","RORICR02",57,0)
 ;
"RTN","RORICR02",58,0)
POSTUPD(RORIEN,PATIEN,REGIEN) ;
"RTN","RORICR02",59,0)
 N DA,DIK,IENS,RC,RORFDA,RORICR,RORMSG
"RTN","RORICR02",60,0)
 S RORIEN=+$G(RORIEN)  Q:RORIEN'>0 0
"RTN","RORICR02",61,0)
 ;--- Delete the record if it exists by some reason
"RTN","RORICR02",62,0)
 D:$D(^RORDATA(799.4,RORIEN))
"RTN","RORICR02",63,0)
 . S DIK="^RORDATA(799.4,",DA=RORIEN  D ^DIK
"RTN","RORICR02",64,0)
 ;--- Prepare the data
"RTN","RORICR02",65,0)
 S IENS="+1,"
"RTN","RORICR02",66,0)
 S RORFDA(799.4,IENS,.01)=RORIEN
"RTN","RORICR02",67,0)
 S RORICR(1)=RORIEN
"RTN","RORICR02",68,0)
 ;--- Add the record to the ROR ICR STUDY file
"RTN","RORICR02",69,0)
 D UPDATE^DIE(,"RORFDA","RORICR","RORMSG")
"RTN","RORICR02",70,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,799.4,IENS)
"RTN","RORICR02",71,0)
 Q 0
"RTN","RORICR02",72,0)
 ;
"RTN","RORICR02",73,0)
 ;***** BEFORE UPDATE CALL-BACK ENTRY POINT
"RTN","RORICR02",74,0)
 ;
"RTN","RORICR02",75,0)
 ; .FDA          Reference to a local array that contains
"RTN","RORICR02",76,0)
 ;               prepared data for the registry record
"RTN","RORICR02",77,0)
 ; PATIEN        Patient IEN
"RTN","RORICR02",78,0)
 ; REGIEN        Registry IEN
"RTN","RORICR02",79,0)
 ;
"RTN","RORICR02",80,0)
 ; Return Values:
"RTN","RORICR02",81,0)
 ;       <0  Error Code
"RTN","RORICR02",82,0)
 ;        0  Ok
"RTN","RORICR02",83,0)
 ;
"RTN","RORICR02",84,0)
PREUPD(FDA,PATIEN,REGIEN) ;
"RTN","RORICR02",85,0)
 N IENS  S IENS="+1,"
"RTN","RORICR02",86,0)
 S FDA(798,IENS,11)=1  ; DON'T SEND
"RTN","RORICR02",87,0)
 S FDA(798,IENS,3)=4   ; NEW PATIENT (PENDING)
"RTN","RORICR02",88,0)
 Q 0
"RTN","RORICR03")
0^181^B34960427
"RTN","RORICR03",1,0)
RORICR03 ;HCIOFO/SG - CONVERSION OF THE FILE #158 ; 1/20/04 1:50pm
"RTN","RORICR03",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORICR03",3,0)
 ;
"RTN","RORICR03",4,0)
 Q
"RTN","RORICR03",5,0)
 ;
"RTN","RORICR03",6,0)
 ;***** TRANSFERS THE CDC COMMENTS TO THE MULTIPLE #25
"RTN","RORICR03",7,0)
CDCOMM() ;
"RTN","RORICR03",8,0)
 N CNT,I,IENS,RC,RORBUF,RORFDA,RORMSG,TMP
"RTN","RORICR03",9,0)
 S (CNT,RC)=0
"RTN","RORICR03",10,0)
 ;--- Load the old comments (non-empty ones)
"RTN","RORICR03",11,0)
 F I=3,2,1  D
"RTN","RORICR03",12,0)
 . S TMP=$G(^IMR(158,IMRIEN,I+9))
"RTN","RORICR03",13,0)
 . S:(TMP'="")!CNT RORBUF(I,0)=TMP,CNT=CNT+1
"RTN","RORICR03",14,0)
 ;--- Store the comments in the new word processing field
"RTN","RORICR03",15,0)
 D:$D(RORBUF)>1
"RTN","RORICR03",16,0)
 . S IENS=RORIEN_","
"RTN","RORICR03",17,0)
 . S RORFDA(799.4,IENS,25)="RORBUF"
"RTN","RORICR03",18,0)
 . D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORICR03",19,0)
 . I $G(DIERR)  D
"RTN","RORICR03",20,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,799.4,IENS)
"RTN","RORICR03",21,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORICR03",22,0)
 ;
"RTN","RORICR03",23,0)
 ;***** TRANSFERS THE PATIENT'S DATA FROM FILE #158 TO FILE #799.4
"RTN","RORICR03",24,0)
 ;
"RTN","RORICR03",25,0)
 ; IMRIEN        IEN of the IMMUNOLOGY CASE STUDY file record
"RTN","RORICR03",26,0)
 ; RORIEN        IEN of the record of the ROR ICR STUDY file
"RTN","RORICR03",27,0)
 ;
"RTN","RORICR03",28,0)
 ; Return Values:
"RTN","RORICR03",29,0)
 ;       <0  Error code
"RTN","RORICR03",30,0)
 ;        0  Ok
"RTN","RORICR03",31,0)
 ;
"RTN","RORICR03",32,0)
CNVPTDAT(IMRIEN,RORIEN) ;
"RTN","RORICR03",33,0)
 N DA,DIK,RC,RORNODE,TMP
"RTN","RORICR03",34,0)
 S RORNODE=""
"RTN","RORICR03",35,0)
 ;--- Check the parameters
"RTN","RORICR03",36,0)
 I '$D(^IMR(158,IMRIEN,0))  D  Q RC
"RTN","RORICR03",37,0)
 . S RC=$$ERROR^RORERR(-88,,,,"IMRIEN",IMRIEN)
"RTN","RORICR03",38,0)
 I '$D(^RORDATA(799.4,RORIEN,0))  D  Q RC
"RTN","RORICR03",39,0)
 . S RC=$$ERROR^RORERR(-88,,,,"RORIEN",RORIEN)
"RTN","RORICR03",40,0)
 ;---
"RTN","RORICR03",41,0)
 S RORNODE=^RORDATA(799.4,RORIEN,0)
"RTN","RORICR03",42,0)
 D COPY(0,"42>2,23>3")
"RTN","RORICR03",43,0)
 D COPY(1,"7>4")
"RTN","RORICR03",44,0)
 I $P(RORNODE,U,2)=4  D  ; CLINICAL AIDS
"RTN","RORICR03",45,0)
 . S $P(RORNODE,U,2)=1,TMP=$P(RORNODE,U,3)\1
"RTN","RORICR03",46,0)
 . I TMP<1000000  S $P(RORNODE,U,3)=""  Q
"RTN","RORICR03",47,0)
 . S:'$E(TMP,4,5) $E(TMP,4,5)="01"
"RTN","RORICR03",48,0)
 . S:'$E(TMP,6,7) $E(TMP,6,7)="01"
"RTN","RORICR03",49,0)
 . S $P(RORNODE,U,3)=TMP
"RTN","RORICR03",50,0)
 E  S $P(RORNODE,U,2,3)=U
"RTN","RORICR03",51,0)
 D STORE(0)
"RTN","RORICR03",52,0)
 ;---
"RTN","RORICR03",53,0)
 D COPY(1,"6>1,34>5,9>9,10>10,11>11,12>12,13>13,14>14")
"RTN","RORICR03",54,0)
 D COPY(2,"16>4")
"RTN","RORICR03",55,0)
 D COPY(102,"8>7,23>8")
"RTN","RORICR03",56,0)
 D COPY(110,"1>2,2>3")
"RTN","RORICR03",57,0)
 D COPY(112,"5>6")
"RTN","RORICR03",58,0)
 D STORE(9)
"RTN","RORICR03",59,0)
 ;---
"RTN","RORICR03",60,0)
 D COPY(102,"19>5")
"RTN","RORICR03",61,0)
 D COPY(110,"4>1,5>4")
"RTN","RORICR03",62,0)
 D COPY(112,"7>2,8>3")
"RTN","RORICR03",63,0)
 D STORE(11)
"RTN","RORICR03",64,0)
 ;---
"RTN","RORICR03",65,0)
 D COPY(1,"16>2,17>3,18>4")
"RTN","RORICR03",66,0)
 D COPY(2,"54>1")
"RTN","RORICR03",67,0)
 D COPY(102,"10>7")
"RTN","RORICR03",68,0)
 D COPY(110,"16>5")
"RTN","RORICR03",69,0)
 D COPY(112,"6>6")
"RTN","RORICR03",70,0)
 D STORE(12)
"RTN","RORICR03",71,0)
 ;---
"RTN","RORICR03",72,0)
 D COPY(1,"26>3,20>6,28>7,29>8,30>9,31>10,32>12,21>13,22>14,23>15,24>17")
"RTN","RORICR03",73,0)
 D TRANSL(1,19,5,"1,2,3","1,2,8")
"RTN","RORICR03",74,0)
 D COPY(2,"21>1,23>2,53>4,55>18")
"RTN","RORICR03",75,0)
 D COPY(102,"14>16")
"RTN","RORICR03",76,0)
 D COPY(110,"3>11")
"RTN","RORICR03",77,0)
 D STORE(14)
"RTN","RORICR03",78,0)
 ;---
"RTN","RORICR03",79,0)
 D COPY(1,"35>1,36>9")
"RTN","RORICR03",80,0)
 D COPY(2,"49>5"),TRANSL(2,50,7,"P,N,I,U","1,0,8,9")
"RTN","RORICR03",81,0)
 D COPY(102,"20>11")
"RTN","RORICR03",82,0)
 D COPY(108,"27>2,28>6,29>8,30>12")
"RTN","RORICR03",83,0)
 D COPY(110,"17>3,18>4,19>13,20>14")
"RTN","RORICR03",84,0)
 D STORE(16)
"RTN","RORICR03",85,0)
 ;---
"RTN","RORICR03",86,0)
 D COPY(111,"10>1,11>2,12>3,13>4,14>5,1>6,2>7,3>8,4>9")
"RTN","RORICR03",87,0)
 D STORE(18)
"RTN","RORICR03",88,0)
 ;---
"RTN","RORICR03",89,0)
 D COPY(102,"21>1,22>3")
"RTN","RORICR03",90,0)
 D COPY(108,"31>2")
"RTN","RORICR03",91,0)
 D COPY(111,"5>4,6>5,7>6,8>7,9>8")
"RTN","RORICR03",92,0)
 D STORE(20)
"RTN","RORICR03",93,0)
 ;---
"RTN","RORICR03",94,0)
 D COPY(110,"6>1,7>2,8>4,9>5,10>6,11>7,12>8")
"RTN","RORICR03",95,0)
 D COPY(112,"11>3")
"RTN","RORICR03",96,0)
 D STORE(22)
"RTN","RORICR03",97,0)
 ;---
"RTN","RORICR03",98,0)
 D TRANSL(110,13,1,"1,2,9","1,0,9")
"RTN","RORICR03",99,0)
 D TRANSL(110,14,2,"1,2,9","1,0,9")
"RTN","RORICR03",100,0)
 D TRANSL(110,15,3,"1,2,9","1,0,9")
"RTN","RORICR03",101,0)
 D COPY(112,"1>4,2>5,3>6,4>7")
"RTN","RORICR03",102,0)
 D STORE(23)
"RTN","RORICR03",103,0)
 ;---
"RTN","RORICR03",104,0)
 S RC=$$INIDIAGS()  Q:RC<0 RC
"RTN","RORICR03",105,0)
 S RC=$$CDCOMM()  Q:RC<0 RC
"RTN","RORICR03",106,0)
 ;--- Reindex the entry
"RTN","RORICR03",107,0)
 S DIK="^RORDATA(799.4,",DA=RORIEN  D IX1^DIK
"RTN","RORICR03",108,0)
 Q 0
"RTN","RORICR03",109,0)
 ;
"RTN","RORICR03",110,0)
 ;***** COPY THE FIELD DATA
"RTN","RORICR03",111,0)
COPY(SRCN,PTLIST) ;
"RTN","RORICR03",112,0)
 N DSTP,I,SRCP,TMP
"RTN","RORICR03",113,0)
 S:'$D(RORNODE(SRCN)) RORNODE(SRCN)=$G(^IMR(158,IMRIEN,SRCN))
"RTN","RORICR03",114,0)
 F I=1:1  S TMP=$P(PTLIST,",",I)  Q:TMP=""  D
"RTN","RORICR03",115,0)
 . S SRCP=+$P(TMP,">"),DSTP=+$P(TMP,">",2)
"RTN","RORICR03",116,0)
 . S TMP=$P(RORNODE(SRCN),U,SRCP)
"RTN","RORICR03",117,0)
 . S:TMP'="" $P(RORNODE,U,DSTP)=TMP
"RTN","RORICR03",118,0)
 Q
"RTN","RORICR03",119,0)
 ;
"RTN","RORICR03",120,0)
 ;***** TRANSFER INITIAL DIAGNOSES
"RTN","RORICR03",121,0)
INIDIAGS() ;
"RTN","RORICR03",122,0)
 ;;01^2;24^108;1
"RTN","RORICR03",123,0)
 ;;02^2;25^108;2
"RTN","RORICR03",124,0)
 ;;03^102;15^108;3
"RTN","RORICR03",125,0)
 ;;04^2;26^108;4
"RTN","RORICR03",126,0)
 ;;05^2;27^108;5
"RTN","RORICR03",127,0)
 ;;06^2;28^108;6
"RTN","RORICR03",128,0)
 ;;07^2;29^108;7
"RTN","RORICR03",129,0)
 ;;08^2;30^108;8
"RTN","RORICR03",130,0)
 ;;09^2;31^108;9
"RTN","RORICR03",131,0)
 ;;10^2;32^108;10
"RTN","RORICR03",132,0)
 ;;11^2;33^108;11
"RTN","RORICR03",133,0)
 ;;12^2;34^108;12
"RTN","RORICR03",134,0)
 ;;13^2;35^108;13
"RTN","RORICR03",135,0)
 ;;14^1;36^108;14
"RTN","RORICR03",136,0)
 ;;15^2;37^108;15
"RTN","RORICR03",137,0)
 ;;16^2;38^108;16
"RTN","RORICR03",138,0)
 ;;17^2;39^108;17
"RTN","RORICR03",139,0)
 ;;18^102;16^108;18
"RTN","RORICR03",140,0)
 ;;19^2;40^108;19
"RTN","RORICR03",141,0)
 ;;20^2;41^108;20
"RTN","RORICR03",142,0)
 ;;21^2;42^108;21
"RTN","RORICR03",143,0)
 ;;22^102;17^108;22
"RTN","RORICR03",144,0)
 ;;23^2;43^108;23
"RTN","RORICR03",145,0)
 ;;24^2;44^108;24
"RTN","RORICR03",146,0)
 ;;25^2;45^108;25
"RTN","RORICR03",147,0)
 ;;26^2;46^108;26
"RTN","RORICR03",148,0)
 ;
"RTN","RORICR03",149,0)
 N BUF,DATE,DIAG,DIEN,I,IENS,RC,RORFDA,RORILST,RORMSG,TMP
"RTN","RORICR03",150,0)
 K ^RORDATA(799.4,RORIEN,10)  S RC=0
"RTN","RORICR03",151,0)
 ;--- Load the old data nodes (if they have not been loaded yet)
"RTN","RORICR03",152,0)
 F I=2,102,108  D:'$D(RORNODE(I))
"RTN","RORICR03",153,0)
 . S RORNODE(I)=$G(^IMR(158,IMRIEN,I))
"RTN","RORICR03",154,0)
 ;--- Prepare the data
"RTN","RORICR03",155,0)
 F I=1:1  S BUF=$P($T(INIDIAGS+I),";;",2,99)  Q:BUF=""  D
"RTN","RORICR03",156,0)
 . S DIEN=+BUF
"RTN","RORICR03",157,0)
 . S TMP=$P(BUF,U,2),DX=$P(RORNODE(+TMP),U,$P(TMP,";",2))
"RTN","RORICR03",158,0)
 . S DX=$TR(DX,"DPN0","12")  Q:DX=""
"RTN","RORICR03",159,0)
 . S TMP=$P(BUF,U,3),DATE=$P(RORNODE(+TMP),U,$P(TMP,";",2))
"RTN","RORICR03",160,0)
 . ;---
"RTN","RORICR03",161,0)
 . S IENS="+"_I_","_RORIEN_","
"RTN","RORICR03",162,0)
 . S RORFDA(799.41,IENS,.01)=DIEN
"RTN","RORICR03",163,0)
 . S RORFDA(799.41,IENS,.02)=DX
"RTN","RORICR03",164,0)
 . S RORFDA(799.41,IENS,.03)=DATE
"RTN","RORICR03",165,0)
 . S RORILST(I)=DIEN
"RTN","RORICR03",166,0)
 ;--- Store the data
"RTN","RORICR03",167,0)
 D:$D(RORFDA)>1
"RTN","RORICR03",168,0)
 . D UPDATE^DIE(,"RORFDA","RORILST","RORMSG")
"RTN","RORICR03",169,0)
 . I $G(DIERR)  D  Q
"RTN","RORICR03",170,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,799.41)
"RTN","RORICR03",171,0)
 ;---
"RTN","RORICR03",172,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORICR03",173,0)
 ;
"RTN","RORICR03",174,0)
 ;***** TEMPORARY 'AFTER UPDATE' CALL-BACK ENTRY POINT
"RTN","RORICR03",175,0)
 ;
"RTN","RORICR03",176,0)
 ; RORIEN        An IEN of the newly added registry record
"RTN","RORICR03",177,0)
 ; PATIEN        Patient IEN
"RTN","RORICR03",178,0)
 ; REGIEN        Registry IEN
"RTN","RORICR03",179,0)
 ;
"RTN","RORICR03",180,0)
 ; Return Values:
"RTN","RORICR03",181,0)
 ;       <0  Error Code
"RTN","RORICR03",182,0)
 ;        0  Ok
"RTN","RORICR03",183,0)
 ;
"RTN","RORICR03",184,0)
POSTUPD(RORIEN,PATIEN,REGIEN) ;
"RTN","RORICR03",185,0)
 N CODE,IEN158,IENS,RC,RORFDA,RORMSG,TMP
"RTN","RORICR03",186,0)
 ;--- Perform the standard ICR post-update actions
"RTN","RORICR03",187,0)
 S RC=$$POSTUPD^RORICR02(RORIEN,PATIEN,REGIEN)  Q:RC<0 RC
"RTN","RORICR03",188,0)
 ;--- Check if the patient is in the ICR v2.1
"RTN","RORICR03",189,0)
 S CODE=$$XOR^RORUTL03(PATIEN)
"RTN","RORICR03",190,0)
 S IEN158=$O(^IMR(158,"B",CODE,""))  Q:IEN158'>0 0
"RTN","RORICR03",191,0)
 ;--- Populate the DATE ENTERED with the date of first selection rule
"RTN","RORICR03",192,0)
 S IENS=RORIEN_","
"RTN","RORICR03",193,0)
 S TMP=$$ROOT^DILFD(798.01,","_IENS,1),TMP=$O(@TMP@("AD",""))
"RTN","RORICR03",194,0)
 S:TMP>0 RORFDA(798,IENS,1)=TMP
"RTN","RORICR03",195,0)
 ;--- Convert the patient's data
"RTN","RORICR03",196,0)
 D:$$CNVPTDAT(IEN158,RORIEN)'<0
"RTN","RORICR03",197,0)
 . ;--- Replace the 'Pending' flag with 'Auto'
"RTN","RORICR03",198,0)
 . S RORFDA(798,IENS,3)=1    ; NEW PATIENT (PENDING -> AUTO)
"RTN","RORICR03",199,0)
 . S RORFDA(798,IENS,11)="@" ; DON'T SEND
"RTN","RORICR03",200,0)
 ;--- Update the registry record if necessary
"RTN","RORICR03",201,0)
 I $D(RORFDA)>1  D  Q:RC<0 RC
"RTN","RORICR03",202,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORICR03",203,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,798,IENS)
"RTN","RORICR03",204,0)
 ;---
"RTN","RORICR03",205,0)
 Q 0
"RTN","RORICR03",206,0)
 ;
"RTN","RORICR03",207,0)
 ;***** CREATES THE NEW DATA NODE IN THE RECORD OF THE FILE #799.4
"RTN","RORICR03",208,0)
STORE(DSTN) ;
"RTN","RORICR03",209,0)
 K ^RORDATA(799.4,RORIEN,DSTN)
"RTN","RORICR03",210,0)
 S:RORNODE'="" ^RORDATA(799.4,RORIEN,DSTN)=RORNODE
"RTN","RORICR03",211,0)
 S RORNODE=""
"RTN","RORICR03",212,0)
 Q
"RTN","RORICR03",213,0)
 ;
"RTN","RORICR03",214,0)
 ;***** TRANSLATE THE SET OF CODES
"RTN","RORICR03",215,0)
TRANSL(SRCN,SRCP,DSTP,FROM,TO) ;
"RTN","RORICR03",216,0)
 N TMP
"RTN","RORICR03",217,0)
 S:'$D(RORNODE(SRCN)) RORNODE(SRCN)=$G(^IMR(158,IMRIEN,SRCN))
"RTN","RORICR03",218,0)
 S TMP=$P(RORNODE(SRCN),U,SRCP)
"RTN","RORICR03",219,0)
 S:TMP'="" $P(RORNODE,U,DSTP)=$TR(TMP,FROM,TO)
"RTN","RORICR03",220,0)
 Q
"RTN","RORICREX")
0^72^B19025318
"RTN","RORICREX",1,0)
RORICREX ;HCIOFO/SG - ICR-SPECIFIC MESSAGE BUILDER ; 1/24/04 10:32am
"RTN","RORICREX",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORICREX",3,0)
 ;
"RTN","RORICREX",4,0)
 ;--------------------------------------------------------------------
"RTN","RORICREX",5,0)
 ; Registry: [VA ICR]
"RTN","RORICREX",6,0)
 ;--------------------------------------------------------------------
"RTN","RORICREX",7,0)
 Q
"RTN","RORICREX",8,0)
 ;
"RTN","RORICREX",9,0)
 ;***** EXTRACTS PATIENT DATA AND CREATES A MESSAGE BODY
"RTN","RORICREX",10,0)
 ;
"RTN","RORICREX",11,0)
 ; RORIEN        IEN of the patient record in the registry
"RTN","RORICREX",12,0)
 ;
"RTN","RORICREX",13,0)
 ; PATIEN        Patient IEN
"RTN","RORICREX",14,0)
 ;
"RTN","RORICREX",15,0)
 ; .DXDTS        Either a single time frame in StartDate^EndDate
"RTN","RORICREX",16,0)
 ;               format or a reference to a local variable containing
"RTN","RORICREX",17,0)
 ;               the list of data extraction time frames. The main
"RTN","RORICREX",18,0)
 ;               time frame should be stored in the root node:
"RTN","RORICREX",19,0)
 ;
"RTN","RORICREX",20,0)
 ;  DXDTS(         MainStartDate^MainEndDate  (FileMan)
"RTN","RORICREX",21,0)
 ;    DataArea,
"RTN","RORICREX",22,0)
 ;      i)         StartDate^EndDate          (FileMan)
"RTN","RORICREX",23,0)
 ;
"RTN","RORICREX",24,0)
 ;               See the $$DXPERIOD^ROREXTUT function for details.
"RTN","RORICREX",25,0)
 ;
"RTN","RORICREX",26,0)
 ; [HDTMODE]     This parameter is defined and non-zero during the
"RTN","RORICREX",27,0)
 ;               historical data extraction.
"RTN","RORICREX",28,0)
 ;
"RTN","RORICREX",29,0)
 ; Return Values:
"RTN","RORICREX",30,0)
 ;       <0  Error Code
"RTN","RORICREX",31,0)
 ;        0  Ok
"RTN","RORICREX",32,0)
 ;       >0  Nothing to send
"RTN","RORICREX",33,0)
 ;
"RTN","RORICREX",34,0)
MESSAGE(RORIEN,PATIEN,DXDTS,HDTMODE) ;
"RTN","RORICREX",35,0)
 N RORDEM        ; Update demographics
"RTN","RORICREX",36,0)
 N RORFDA        ; Array containing values from the registry record
"RTN","RORICREX",37,0)
 N RORLOC        ; Update local registry data
"RTN","RORICREX",38,0)
 ;
"RTN","RORICREX",39,0)
 N DATAPTR,D1,D2,DEMPTR,ENDT,FIELDS,IDX,IENS,PV1PTR,RBPTR,RC,RORBUF,RORMSG,RORPTR,STDT,TMP
"RTN","RORICREX",40,0)
 S IENS=RORIEN_",",HDTMODE=+$G(HDTMODE)
"RTN","RORICREX",41,0)
 ;--- If only the main time frame is provided then
"RTN","RORICREX",42,0)
 ;--- generate the data-specific ones automatically
"RTN","RORICREX",43,0)
 I $D(DXDTS)<10  D  D DXMERGE^ROREXTUT(.DXDTS)
"RTN","RORICREX",44,0)
 . D DXADD^ROREXTUT(.DXDTS,$P(DXDTS,U),$P(DXDTS,U,2),0,1)
"RTN","RORICREX",45,0)
 S STDT=$P(DXDTS,U),ENDT=$P(DXDTS,U,2)
"RTN","RORICREX",46,0)
 ;--- Get the registry record data
"RTN","RORICREX",47,0)
 D GETS^DIQ(798,IENS,"4;5","I","RORFDA","RORMSG")
"RTN","RORICREX",48,0)
 I $G(DIERR)  D  Q RC
"RTN","RORICREX",49,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,798,IENS)
"RTN","RORICREX",50,0)
 S RORDEM=+$G(RORFDA(798,IENS,4,"I"))
"RTN","RORICREX",51,0)
 S RORLOC=+$G(RORFDA(798,IENS,5,"I"))
"RTN","RORICREX",52,0)
 ;--- Initialize environment variables
"RTN","RORICREX",53,0)
 S RC=$$INIT^RORHL7()  Q:RC<0 RC
"RTN","RORICREX",54,0)
 ;
"RTN","RORICREX",55,0)
 ;=== Add patient data segments
"RTN","RORICREX",56,0)
 ;
"RTN","RORICREX",57,0)
 S DEMPTR=$$PTR^RORHL7
"RTN","RORICREX",58,0)
 S RC=$$PID^RORHL21(PATIEN)      Q:RC<0 RC
"RTN","RORICREX",59,0)
 ;--- Period of Servise
"RTN","RORICREX",60,0)
 I $D(ROREXT("HL7",5,"ZSP"))  D  Q:RC<0 RC
"RTN","RORICREX",61,0)
 . S RC=$$ZSP^RORHL01(PATIEN)
"RTN","RORICREX",62,0)
 ;--- Rated Disabilities
"RTN","RORICREX",63,0)
 I $D(ROREXT("HL7",5,"ZRD"))  D  Q:RC<0 RC
"RTN","RORICREX",64,0)
 . S RC=$$ZRD^RORHL01(PATIEN)
"RTN","RORICREX",65,0)
 ;
"RTN","RORICREX",66,0)
 ;=== Inpatient and Outpatient Encounter Data
"RTN","RORICREX",67,0)
 ;
"RTN","RORICREX",68,0)
 S PV1PTR=$$PTR^RORHL7
"RTN","RORICREX",69,0)
 ;--- Inpatient
"RTN","RORICREX",70,0)
 I $D(ROREXT("HL7",3,"PV1"))  D  Q:RC<0 RC
"RTN","RORICREX",71,0)
 . S RC=$$EN1^RORHL08(PATIEN,.DXDTS,"PV1")
"RTN","RORICREX",72,0)
 ;--- Outpatient
"RTN","RORICREX",73,0)
 I $D(ROREXT("HL7",2,"PV1"))  D  Q:RC<0 RC
"RTN","RORICREX",74,0)
 . S RC=$$EN1^RORHL09(PATIEN,.DXDTS,"PV1")
"RTN","RORICREX",75,0)
 ;---
"RTN","RORICREX",76,0)
 S:$$PTR^RORHL7'>PV1PTR PV1PTR=0
"RTN","RORICREX",77,0)
 ;
"RTN","RORICREX",78,0)
 ;=== Add local registry data segments
"RTN","RORICREX",79,0)
 ;
"RTN","RORICREX",80,0)
 I $D(ROREXT("HL7",5,"CSR"))  D  Q:RC<0 RC
"RTN","RORICREX",81,0)
 . S FIELDS=$P(ROREXT("HL7",5,"CSR"),U,2)
"RTN","RORICREX",82,0)
 . S RC=$$CSR^RORHL02(IENS,FIELDS)
"RTN","RORICREX",83,0)
 I $D(ROREXT("HL7",5,"CSP"))  D  Q:RC<0 RC
"RTN","RORICREX",84,0)
 . S FIELDS=$P(ROREXT("HL7",5,"CSP"),U,2)
"RTN","RORICREX",85,0)
 . S RC=$$CSP^RORHL02(IENS,FIELDS)
"RTN","RORICREX",86,0)
 I $D(ROREXT("HL7",5,"CSS"))  D  Q:RC<0 RC
"RTN","RORICREX",87,0)
 . S FIELDS=$P(ROREXT("HL7",5,"CSS"),U,2)
"RTN","RORICREX",88,0)
 . S RC=$$CSS^RORHL02(IENS,FIELDS)
"RTN","RORICREX",89,0)
 ;
"RTN","RORICREX",90,0)
 ;=== Add other encounter data segments
"RTN","RORICREX",91,0)
 ;
"RTN","RORICREX",92,0)
 S DATAPTR=$$PTR^RORHL7
"RTN","RORICREX",93,0)
 ;---Inpatient
"RTN","RORICREX",94,0)
 I $D(ROREXT("HL7",3,"OBR"))  D  Q:RC<0 RC
"RTN","RORICREX",95,0)
 . S RC=$$EN1^RORHL08(PATIEN,.DXDTS,"OBR")
"RTN","RORICREX",96,0)
 ;--- Outpatient
"RTN","RORICREX",97,0)
 I $D(ROREXT("HL7",2,"OBR"))  D  Q:RC<0 RC
"RTN","RORICREX",98,0)
 . S RC=$$EN1^RORHL09(PATIEN,.DXDTS,"OBR")
"RTN","RORICREX",99,0)
 ;--- Pharmacy
"RTN","RORICREX",100,0)
 I $D(ROREXT("HL7",6))>1  D  Q:RC<0 RC
"RTN","RORICREX",101,0)
 . S IDX=0
"RTN","RORICREX",102,0)
 . F  S IDX=$O(DXDTS(6,IDX))  Q:IDX'>0  D  Q:RC<0
"RTN","RORICREX",103,0)
 . . S D1=$P(DXDTS(6,IDX),U),D2=$P(DXDTS(6,IDX),U,2)
"RTN","RORICREX",104,0)
 . . S RC=$$EN1^RORHL03(PATIEN,D1,D2)
"RTN","RORICREX",105,0)
 ;--- Radiology
"RTN","RORICREX",106,0)
 I $D(ROREXT("HL7",4))>1  D  Q:RC<0 RC
"RTN","RORICREX",107,0)
 . S RC=$$EN1^RORHL04(PATIEN,STDT,ENDT)
"RTN","RORICREX",108,0)
 ;--- Autopsy
"RTN","RORICREX",109,0)
 I $D(ROREXT("HL7",7))>1  D  Q:RC<0 RC
"RTN","RORICREX",110,0)
 . S RC=$$EN1^RORHL05(PATIEN)
"RTN","RORICREX",111,0)
 ;--- Surgical Pathology
"RTN","RORICREX",112,0)
 I $D(ROREXT("HL7",9))>1  D  Q:RC<0 RC
"RTN","RORICREX",113,0)
 . S RC=$$EN1^RORHL10(PATIEN,STDT,ENDT,HDTMODE)
"RTN","RORICREX",114,0)
 ;--- Cytopathology
"RTN","RORICREX",115,0)
 I $D(ROREXT("HL7",10))>1  D  Q:RC<0 RC
"RTN","RORICREX",116,0)
 . S RC=$$EN1^RORHL11(PATIEN,STDT,ENDT,HDTMODE)
"RTN","RORICREX",117,0)
 ;--- Microbiology
"RTN","RORICREX",118,0)
 I $D(ROREXT("HL7",11))>1  D  Q:RC<0 RC
"RTN","RORICREX",119,0)
 . S RC=$$EN1^RORHL12(PATIEN,STDT,ENDT,HDTMODE)
"RTN","RORICREX",120,0)
 ;--- EKG (Medical Procedures)
"RTN","RORICREX",121,0)
 I $D(ROREXT("HL7",12))>1  D  Q:RC<0 RC
"RTN","RORICREX",122,0)
 . S RC=$$EN1^RORHL13(PATIEN,STDT,ENDT)
"RTN","RORICREX",123,0)
 ;--- Allergy
"RTN","RORICREX",124,0)
 I $D(ROREXT("HL7",13))>1  D  Q:RC<0 RC
"RTN","RORICREX",125,0)
 . S RC=$$EN1^RORHL14(PATIEN,STDT,ENDT)
"RTN","RORICREX",126,0)
 ;--- IV
"RTN","RORICREX",127,0)
 I $D(ROREXT("HL7",14))>1  D  Q:RC<0 RC
"RTN","RORICREX",128,0)
 . S RC=$$EN1^RORHL15(PATIEN,STDT,ENDT)
"RTN","RORICREX",129,0)
 ;--- Vitals
"RTN","RORICREX",130,0)
 I $D(ROREXT("HL7",15))>1  D  Q:RC<0 RC
"RTN","RORICREX",131,0)
 . S RC=$$EN1^RORHL16(PATIEN,STDT,ENDT)
"RTN","RORICREX",132,0)
 ;
"RTN","RORICREX",133,0)
 I $D(ROREXT("HL7",16))>1  D  Q:RC<0 RC
"RTN","RORICREX",134,0)
 . S RC=$$EN1^RORHL17(PATIEN,STDT,ENDT)
"RTN","RORICREX",135,0)
 ;
"RTN","RORICREX",136,0)
 ;--- Lab data
"RTN","RORICREX",137,0)
 I $D(ROREXT("HL7",1))>1  D  Q:RC<0 RC
"RTN","RORICREX",138,0)
 . S RC=$$LABDATA^RORICR01(PATIEN,STDT,ENDT,HDTMODE)
"RTN","RORICREX",139,0)
 ;
"RTN","RORICREX",140,0)
 ;=== Analyze structure of the message
"RTN","RORICREX",141,0)
 ;
"RTN","RORICREX",142,0)
 S RORPTR=$$PTR^RORHL7
"RTN","RORICREX",143,0)
 Q $S(RORPTR>DATAPTR:0,PV1PTR:0,RORLOC!RORDEM:RORPTR'>DEMPTR,1:1)
"RTN","RORICRUT")
0^146^B843657
"RTN","RORICRUT",1,0)
RORICRUT ;HCIOFO/SG - ICR UTILITIES ; 12/17/03 8:08am
"RTN","RORICRUT",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORICRUT",3,0)
 ;
"RTN","RORICRUT",4,0)
 Q
"RTN","RORICRUT",5,0)
 ;
"RTN","RORICRUT",6,0)
 ;***** RETURNS THE CATEGORY SUBSCRIPT AND HEADER
"RTN","RORICRUT",7,0)
CAT(I) ;
"RTN","RORICRUT",8,0)
 ;;ALLCATS^AIDS^HIV
"RTN","RORICRUT",9,0)
 ;;All Patients^AIDS OI^HIV+ (no AIDS OI)
"RTN","RORICRUT",10,0)
 ;
"RTN","RORICRUT",11,0)
 Q $P($P($T(CAT+1),";;",2),U,I)_U_$P($P($T(CAT+2),";;",2),U,I)
"RTN","RORICRUT",12,0)
 ;
"RTN","RORICRUT",13,0)
 ;***** RETURNS CLINICAL AIDS STATUS OF THE PATIENT
"RTN","RORICRUT",14,0)
 ;
"RTN","RORICRUT",15,0)
 ; IEN           IEN of the registry record
"RTN","RORICRUT",16,0)
 ;
"RTN","RORICRUT",17,0)
 ; [DATE]        Date that the status should be determined on.
"RTN","RORICRUT",18,0)
 ;
"RTN","RORICRUT",19,0)
 ;               If not defined or not greater than 0 then the
"RTN","RORICRUT",20,0)
 ;               date of Clinical AIDS is not checked.
"RTN","RORICRUT",21,0)
 ;
"RTN","RORICRUT",22,0)
 ; Return Values:
"RTN","RORICRUT",23,0)
 ;        0  No Clinical AIDS
"RTN","RORICRUT",24,0)
 ;        1  Clinical AIDS. The second "^"-piece will
"RTN","RORICRUT",25,0)
 ;           contain the Clinical AIDS date
"RTN","RORICRUT",26,0)
 ;
"RTN","RORICRUT",27,0)
CLINAIDS(IEN,DATE) ;
"RTN","RORICRUT",28,0)
 N X  S X=$P($G(^RORDATA(799.4,+IEN,0)),U,2,3)
"RTN","RORICRUT",29,0)
 Q:'X 0
"RTN","RORICRUT",30,0)
 I $G(DATE)>0  Q:$P(X,U,2)\1>DATE 0
"RTN","RORICRUT",31,0)
 Q "1"_U_$P(X,U,2)
"RTN","RORICRUT",32,0)
 ;
"RTN","RORICRUT",33,0)
 ;***** CHECKS IF THE ICR RECORD EXISTS
"RTN","RORICRUT",34,0)
 ;
"RTN","RORICRUT",35,0)
 ; IEN           IEN of the registry record
"RTN","RORICRUT",36,0)
 ;
"RTN","RORICRUT",37,0)
 ; Return Values:
"RTN","RORICRUT",38,0)
 ;        0  Record does not exist
"RTN","RORICRUT",39,0)
 ;        1  The ICR record exists
"RTN","RORICRUT",40,0)
 ;
"RTN","RORICRUT",41,0)
ICRDEF(IEN) ;
"RTN","RORICRUT",42,0)
 Q $G(^RORDATA(799.4,+IEN,0))>0
"RTN","RORICRUT",43,0)
 ;
"RTN","RORICRUT",44,0)
 ;***** RETURNS NUMBER OF AVAILABLE CATEGORIES
"RTN","RORICRUT",45,0)
NCAT() ;
"RTN","RORICRUT",46,0)
 Q $L($P($T(CAT+1),";;",2),U)
"RTN","RORKIDS")
0^132^B35442305
"RTN","RORKIDS",1,0)
RORKIDS ;HCIOFO/SG - INSTALL UTILITIES (LOW-LEVEL) ; 1/16/04 8:57am
"RTN","RORKIDS",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORKIDS",3,0)
 ;
"RTN","RORKIDS",4,0)
 Q
"RTN","RORKIDS",5,0)
 ;
"RTN","RORKIDS",6,0)
 ;***** DISPLAYS THE MESSAGE IF THE INSTALLATION ABORTS
"RTN","RORKIDS",7,0)
ABTMSG() ;
"RTN","RORKIDS",8,0)
 ;;You can use the Print Log Files [RORMNT PRINT LOGS] option from
"RTN","RORKIDS",9,0)
 ;;the Clinical Case Registries Maintenance [RORMNT MAIN] menu to
"RTN","RORKIDS",10,0)
 ;;review the log file(s). The Install File Print [XPD PRINT INSTALL
"RTN","RORKIDS",11,0)
 ;;FILE] option from the Utilities [XPD UTILITY] can help also.
"RTN","RORKIDS",12,0)
 ;;Please fix the error(s) and restart the installation.
"RTN","RORKIDS",13,0)
 ;;
"RTN","RORKIDS",14,0)
 ;;NOTE: You must have the ROR VA IRM key to be able to access
"RTN","RORKIDS",15,0)
 ;;      the Clinical Case Registries files and view the logs.
"RTN","RORKIDS",16,0)
 ;
"RTN","RORKIDS",17,0)
 N I,INFO,MODE,TMP
"RTN","RORKIDS",18,0)
 S MODE=+$G(RORPARM("KIDS"))
"RTN","RORKIDS",19,0)
 S MODE=$S(MODE=1:"PRE-INSTALL",MODE=2:"POST-INSTALL",1:"")
"RTN","RORKIDS",20,0)
 Q:MODE=""
"RTN","RORKIDS",21,0)
 F I=1:1  S TMP=$T(ABTMSG+I)  Q:TMP'[";;"  S INFO(I)=$P(TMP,";;",2,99)
"RTN","RORKIDS",22,0)
 D BMES("FATAL ERROR(S) DURING THE REGISTRY "_MODE_"!",.INFO)
"RTN","RORKIDS",23,0)
 Q
"RTN","RORKIDS",24,0)
 ;
"RTN","RORKIDS",25,0)
 ;***** SENDS AN ALERT
"RTN","RORKIDS",26,0)
 ;
"RTN","RORKIDS",27,0)
 ; DUZ           DUZ of the addressee
"RTN","RORKIDS",28,0)
 ;
"RTN","RORKIDS",29,0)
 ; MSG           Text of the message or negative error code. The '^'
"RTN","RORKIDS",30,0)
 ;               characters are replaced with spaces in the text.
"RTN","RORKIDS",31,0)
 ;
"RTN","RORKIDS",32,0)
 ; [REGNAME]     Registry name
"RTN","RORKIDS",33,0)
 ;
"RTN","RORKIDS",34,0)
 ; [PATIEN]      Patient IEN
"RTN","RORKIDS",35,0)
 ;
"RTN","RORKIDS",36,0)
 ; [ARG2-ARG5]   Optional parameters as for $$ERROR^RORERR
"RTN","RORKIDS",37,0)
 ;
"RTN","RORKIDS",38,0)
ALERT(DUZ,MSG,REGNAME,PATIEN,ARG2,ARG3,ARG4,ARG5) ;
"RTN","RORKIDS",39,0)
 Q:'$G(DUZ)
"RTN","RORKIDS",40,0)
 N XQA,XQADATA,XQAFLG,XQAMSG,XQAROU,TMP
"RTN","RORKIDS",41,0)
 S XQA(DUZ)=""
"RTN","RORKIDS",42,0)
 ;--- Get text of the error message
"RTN","RORKIDS",43,0)
 I +MSG=MSG  Q:MSG'<0  D
"RTN","RORKIDS",44,0)
 . S MSG=$$MSG^RORERR20(+MSG,,.PATIEN,.ARG2,.ARG3,.ARG4,.ARG5)
"RTN","RORKIDS",45,0)
 S MSG=$TR(MSG,"^","~"),XQAMSG="ROR: ",TMP=70-$L(XQAMSG)-3
"RTN","RORKIDS",46,0)
 S XQAMSG=XQAMSG_$S($L(MSG)>TMP:$E(MSG,1,TMP)_"...",1:MSG)
"RTN","RORKIDS",47,0)
 ;--- Setup alert processing routine
"RTN","RORKIDS",48,0)
 S $P(XQADATA,U,1)=$E(MSG,1,78)
"RTN","RORKIDS",49,0)
 S $P(XQADATA,U,2)=$G(REGNAME)
"RTN","RORKIDS",50,0)
 S $P(XQADATA,U,3)=$G(PATIEN)
"RTN","RORKIDS",51,0)
 S XQAROU="ALERTRTN^RORKIDS"
"RTN","RORKIDS",52,0)
 ;--- Send the alert
"RTN","RORKIDS",53,0)
 S XQAFLG="D"  D SETUP^XQALERT
"RTN","RORKIDS",54,0)
 Q
"RTN","RORKIDS",55,0)
 ;
"RTN","RORKIDS",56,0)
 ;***** ALERT PROCESSING ROUTINE
"RTN","RORKIDS",57,0)
 ;
"RTN","RORKIDS",58,0)
 ; XQADATA       Alert data
"RTN","RORKIDS",59,0)
 ;                 ^1: Message
"RTN","RORKIDS",60,0)
 ;                 ^2: Registry name
"RTN","RORKIDS",61,0)
 ;                 ^3: Patient DFN
"RTN","RORKIDS",62,0)
 ;
"RTN","RORKIDS",63,0)
ALERTRTN ;
"RTN","RORKIDS",64,0)
 ;;Registry Name:
"RTN","RORKIDS",65,0)
 ;;Patient DFN:
"RTN","RORKIDS",66,0)
 ;
"RTN","RORKIDS",67,0)
 Q:$G(XQADATA)=""
"RTN","RORKIDS",68,0)
 N I,TMP
"RTN","RORKIDS",69,0)
 W !!,$P(XQADATA,"^"),!
"RTN","RORKIDS",70,0)
 F I=1:1:2  S TMP=$P(XQADATA,"^",I+1)  D:TMP'=""
"RTN","RORKIDS",71,0)
 . W $P($T(ALERTRTN+I),";;",2),?15,TMP,!
"RTN","RORKIDS",72,0)
 Q
"RTN","RORKIDS",73,0)
 ;
"RTN","RORKIDS",74,0)
 ;***** OUTPUTS THE MESSAGE AND PUTS IT INTO THE LOG
"RTN","RORKIDS",75,0)
BMES(MSG,INFO) ;
"RTN","RORKIDS",76,0)
 N I
"RTN","RORKIDS",77,0)
 D BMES^XPDUTL("   "_MSG)
"RTN","RORKIDS",78,0)
 S I=""
"RTN","RORKIDS",79,0)
 F  S I=$O(INFO(I))  Q:I=""  D MES^XPDUTL("   "_INFO(I))
"RTN","RORKIDS",80,0)
 D LOG^RORLOG(,MSG,,.INFO)
"RTN","RORKIDS",81,0)
 Q
"RTN","RORKIDS",82,0)
 ;
"RTN","RORKIDS",83,0)
 ;***** CHECKS THE SCHEDULED OPTION
"RTN","RORKIDS",84,0)
 ;
"RTN","RORKIDS",85,0)
 ; OPTION        Option name
"RTN","RORKIDS",86,0)
 ;
"RTN","RORKIDS",87,0)
 ; Return Values:
"RTN","RORKIDS",88,0)
 ;       <0  Error code
"RTN","RORKIDS",89,0)
 ;        0  Ok
"RTN","RORKIDS",90,0)
 ;
"RTN","RORKIDS",91,0)
 ; This function can be used in the environment check routines to
"RTN","RORKIDS",92,0)
 ; check if the option is running and/or scheduled to run.
"RTN","RORKIDS",93,0)
 ;
"RTN","RORKIDS",94,0)
 ; The function displays appropriate error messages and warnings
"RTN","RORKIDS",95,0)
 ; using the WRITE command. So, it MUST NOT be called from the
"RTN","RORKIDS",96,0)
 ; pre-install or post-install routines.
"RTN","RORKIDS",97,0)
 ;
"RTN","RORKIDS",98,0)
 ; The function uses the ^UTILITY($J,"W") node (^DIWP and ^DIWW).
"RTN","RORKIDS",99,0)
 ;
"RTN","RORKIDS",100,0)
CHKOPT(OPTION) ;
"RTN","RORKIDS",101,0)
 N DIWF,DIWL,DIWR,RC,RORBUF,RORI,RORSDT,TMP,X,ZTSK
"RTN","RORKIDS",102,0)
 ;--- Check status of the option
"RTN","RORKIDS",103,0)
 D OPTSTAT^XUTMOPT(OPTION,.RORBUF)
"RTN","RORKIDS",104,0)
 S (RC,RORSDT)=0
"RTN","RORKIDS",105,0)
 F RORI=1:1:$G(RORBUF)  K ZTSK  D  I $G(ZTSK(1))=2  S RC=-76  Q
"RTN","RORKIDS",106,0)
 . S ZTSK=$P(RORBUF(RORI),"^")  Q:'ZTSK
"RTN","RORKIDS",107,0)
 . D STAT^%ZTLOAD
"RTN","RORKIDS",108,0)
 . S TMP=$P(RORBUF(RORI),"^",2)
"RTN","RORKIDS",109,0)
 . I TMP>0  S:'RORSDT!(TMP<RORSDT) RORSDT=TMP
"RTN","RORKIDS",110,0)
 ;--- Display an error message if the option is running
"RTN","RORKIDS",111,0)
 I RC  D  Q RC
"RTN","RORKIDS",112,0)
 . W !,$$MSG^RORERR20(RC,,,OPTION),!
"RTN","RORKIDS",113,0)
 ;--- Display an apropriate warning
"RTN","RORKIDS",114,0)
 S DIWL=5,DIWR=$G(IOM,80)-DIWL
"RTN","RORKIDS",115,0)
 K ^UTILITY($J,"W")
"RTN","RORKIDS",116,0)
CM1 I RORSDT>0  D
"RTN","RORKIDS",117,0)
 . ;;"The ["_OPTION_"] option is scheduled to run "_RORSDT_"."
"RTN","RORKIDS",118,0)
 . ;;"If you are going to schedule the installation, please, choose"
"RTN","RORKIDS",119,0)
 . ;;"an appropriate time so that the post-install will either"
"RTN","RORKIDS",120,0)
 . ;;"finish well before the ["_OPTION_"] scheduled time or start"
"RTN","RORKIDS",121,0)
 . ;;"after the option completion."
"RTN","RORKIDS",122,0)
 . ;---
"RTN","RORKIDS",123,0)
 . S RORSDT=$$FMTE^XLFDT(RORSDT)
"RTN","RORKIDS",124,0)
 . S RORSDT="on "_$P(RORSDT,"@")_" at "_$P(RORSDT,"@",2)
"RTN","RORKIDS",125,0)
 . F RORI=1:1  S X=$T(CM1+RORI)  Q:X'[";;"  D
"RTN","RORKIDS",126,0)
 . . X "S X="_$P(X,";;",2)  D ^DIWP
"RTN","RORKIDS",127,0)
CM2 E  D
"RTN","RORKIDS",128,0)
 . ;;"The ["_OPTION_"] option is not scheduled. Do not forget"
"RTN","RORKIDS",129,0)
 . ;;"to schedule it after completion of the installation."
"RTN","RORKIDS",130,0)
 . ;---
"RTN","RORKIDS",131,0)
 . F RORI=1:1  S X=$T(CM2+RORI)  Q:X'[";;"  D
"RTN","RORKIDS",132,0)
 . . X "S X="_$P(X,";;",2)  D ^DIWP
"RTN","RORKIDS",133,0)
 W !  D ^DIWW
"RTN","RORKIDS",134,0)
 Q 0
"RTN","RORKIDS",135,0)
 ;
"RTN","RORKIDS",136,0)
 ;***** PROCESSES THE INSTALL CHECKPOINT
"RTN","RORKIDS",137,0)
 ;
"RTN","RORKIDS",138,0)
 ; CPNAME        Checkpoint name
"RTN","RORKIDS",139,0)
 ;
"RTN","RORKIDS",140,0)
 ; CALLBACK      Callback entry point ($$TAG^ROUTINE). This function
"RTN","RORKIDS",141,0)
 ;               accepts no parameters and must return either 0 if
"RTN","RORKIDS",142,0)
 ;               everything is Ok or a negative error code.
"RTN","RORKIDS",143,0)
 ;
"RTN","RORKIDS",144,0)
 ; [PARAM]       Value to set checkpoint parameter to.
"RTN","RORKIDS",145,0)
 ;
"RTN","RORKIDS",146,0)
 ; The function checks if the checkpoint is completed. If it is not,
"RTN","RORKIDS",147,0)
 ; the callback entry point is XECUTEd. If everything is Ok, the
"RTN","RORKIDS",148,0)
 ; function will complete the checkpoint.
"RTN","RORKIDS",149,0)
 ;
"RTN","RORKIDS",150,0)
 ; Return Values:
"RTN","RORKIDS",151,0)
 ;       <0  Error code
"RTN","RORKIDS",152,0)
 ;        0  Ok
"RTN","RORKIDS",153,0)
 ;
"RTN","RORKIDS",154,0)
CP(CPNAME,CALLBACK,PARAM) ;
"RTN","RORKIDS",155,0)
 N RC
"RTN","RORKIDS",156,0)
 ;--- Verify the checkpoint and quit if it is completed
"RTN","RORKIDS",157,0)
 S RC=$$VERCP^XPDUTL(CPNAME)  Q:RC>0 0
"RTN","RORKIDS",158,0)
 ;--- Create the new checkpoint
"RTN","RORKIDS",159,0)
 I RC<0  D  Q:'RC $$ERROR^RORERR(-50,,,,CPNAME)
"RTN","RORKIDS",160,0)
 . S RC=$$NEWCP^XPDUTL(CPNAME,,.PARAM)
"RTN","RORKIDS",161,0)
 ;--- Reset the KIDS progress bar
"RTN","RORKIDS",162,0)
 S XPDIDTOT=0  D UPDATE^XPDID(0)
"RTN","RORKIDS",163,0)
 ;--- Execute the callback entry point
"RTN","RORKIDS",164,0)
 X "S RC="_CALLBACK  Q:RC<0 RC
"RTN","RORKIDS",165,0)
 ;--- Complete the check point
"RTN","RORKIDS",166,0)
 S RC=$$COMCP^XPDUTL(CPNAME)
"RTN","RORKIDS",167,0)
 Q:'RC $$ERROR^RORERR(-51,,,,CPNAME)
"RTN","RORKIDS",168,0)
 Q 0
"RTN","RORKIDS",169,0)
 ;
"RTN","RORKIDS",170,0)
 ;***** DELETES THE (SUB)FILE DD AND DATA (IF REQUESTED)
"RTN","RORKIDS",171,0)
 ;
"RTN","RORKIDS",172,0)
 ; FILE          File number
"RTN","RORKIDS",173,0)
 ;
"RTN","RORKIDS",174,0)
 ; [FLAGS]       String that contains flags for EN^DIU2:
"RTN","RORKIDS",175,0)
 ;                 "D"  Delete the data as well as the DD
"RTN","RORKIDS",176,0)
 ;                 "E"  Echo back information during deletion
"RTN","RORKIDS",177,0)
 ;                 "S"  Subfile data dictionary is to be deleted
"RTN","RORKIDS",178,0)
 ;                 "T"  Templates are to be deleted
"RTN","RORKIDS",179,0)
 ;
"RTN","RORKIDS",180,0)
 ; [SILENT]      If this parameters is defined and non-zero, the
"RTN","RORKIDS",181,0)
 ;               function will work in "silent" mode.
"RTN","RORKIDS",182,0)
 ;               Nothing (except error messages if debug mode >1 is
"RTN","RORKIDS",183,0)
 ;               enabled) will be displayed on the console or stored
"RTN","RORKIDS",184,0)
 ;               into the INSTALLATION file.
"RTN","RORKIDS",185,0)
 ;
"RTN","RORKIDS",186,0)
 ; Return Values:
"RTN","RORKIDS",187,0)
 ;       <0  Error code
"RTN","RORKIDS",188,0)
 ;        0  Ok
"RTN","RORKIDS",189,0)
 ;
"RTN","RORKIDS",190,0)
 ; NOTE: This entry point can also be called as a procedure:
"RTN","RORKIDS",191,0)
 ;       D DELFILE^RORKIDS(...) if you do not need its return value.
"RTN","RORKIDS",192,0)
 ;
"RTN","RORKIDS",193,0)
DELFILE(FILE,FLAGS,SILENT) ;
"RTN","RORKIDS",194,0)
 I '$$VFILE^DILFD(+FILE)  Q:$QUIT 0  Q
"RTN","RORKIDS",195,0)
 N DIU,FT,RC
"RTN","RORKIDS",196,0)
 S DIU=+FILE,DIU(0)=$G(FLAGS)
"RTN","RORKIDS",197,0)
 I '$G(SILENT)  D
"RTN","RORKIDS",198,0)
 . S FT=$S(DIU(0)["S":"subfile",1:"file")
"RTN","RORKIDS",199,0)
 . D BMES("Deleting the "_FT_" #"_(+FILE)_"...")
"RTN","RORKIDS",200,0)
 D EN^DIU2
"RTN","RORKIDS",201,0)
 D:'$G(SILENT) MES("The "_FT_" has been deleted.")
"RTN","RORKIDS",202,0)
 Q:$QUIT 0  Q
"RTN","RORKIDS",203,0)
 ;
"RTN","RORKIDS",204,0)
 ;***** DELETES FIELD DEFENITIONS FROM THE DD
"RTN","RORKIDS",205,0)
 ;
"RTN","RORKIDS",206,0)
 ; FILE          File number
"RTN","RORKIDS",207,0)
 ;
"RTN","RORKIDS",208,0)
 ; FLDLST        String that contains list of field numbers to
"RTN","RORKIDS",209,0)
 ;               delete (separated with the ';').
"RTN","RORKIDS",210,0)
 ;
"RTN","RORKIDS",211,0)
 ; [SILENT]      If this parameters is defined and non-zero, the
"RTN","RORKIDS",212,0)
 ;               function will work in "silent" mode.
"RTN","RORKIDS",213,0)
 ;               Nothing (except error messages if debug mode >1 is
"RTN","RORKIDS",214,0)
 ;               enabled) will be displayed on the console or stored
"RTN","RORKIDS",215,0)
 ;               into the INSTALLATION file.
"RTN","RORKIDS",216,0)
 ;
"RTN","RORKIDS",217,0)
 ; Return Values:
"RTN","RORKIDS",218,0)
 ;       <0  Error code
"RTN","RORKIDS",219,0)
 ;        0  Ok
"RTN","RORKIDS",220,0)
 ;
"RTN","RORKIDS",221,0)
DELFLDS(FILE,FLDLST,SILENT) ;
"RTN","RORKIDS",222,0)
 Q:'$$VFILE^DILFD(+FILE) 0
"RTN","RORKIDS",223,0)
 N DA,DIK,I,RC,ROOT
"RTN","RORKIDS",224,0)
 D:'$G(SILENT)
"RTN","RORKIDS",225,0)
 . D BMES("Deleting the field definitions...")
"RTN","RORKIDS",226,0)
 . D MES("File #"_(+FILE)_", Fields: '"_FLDLST_"'")
"RTN","RORKIDS",227,0)
 S DA(1)=+FILE,DIK="^DD("_DA(1)_","
"RTN","RORKIDS",228,0)
 F I=1:1  S DA=$P(FLDLST,";",I)  Q:'DA  D ^DIK
"RTN","RORKIDS",229,0)
 D:'$G(SILENT) MES("The definitions have been deleted.")
"RTN","RORKIDS",230,0)
 Q 0
"RTN","RORKIDS",231,0)
 ;
"RTN","RORKIDS",232,0)
 ;***** OUTPUTS THE MESSAGE AND PUTS IT INTO THE LOG
"RTN","RORKIDS",233,0)
MES(MSG,INFO) ;
"RTN","RORKIDS",234,0)
 N I
"RTN","RORKIDS",235,0)
 D MES^XPDUTL("   "_MSG)
"RTN","RORKIDS",236,0)
 S I=""
"RTN","RORKIDS",237,0)
 F  S I=$O(INFO(I))  Q:I=""  D MES^XPDUTL("   "_INFO(I))
"RTN","RORKIDS",238,0)
 D LOG^RORLOG(,MSG,,.INFO)
"RTN","RORKIDS",239,0)
 Q
"RTN","RORKIDS",240,0)
 ;
"RTN","RORKIDS",241,0)
 ;***** RETURNS A VALUE OF THE INSTALLATION PARAMETER
"RTN","RORKIDS",242,0)
 ;
"RTN","RORKIDS",243,0)
 ; NAME          Name of the parameter
"RTN","RORKIDS",244,0)
 ;
"RTN","RORKIDS",245,0)
PARAM(NAME) ;
"RTN","RORKIDS",246,0)
 Q $G(RORPARM("KIDS",NAME))
"RTN","RORKIDS",247,0)
 ;
"RTN","RORKIDS",248,0)
 ;***** UPDATES THE FILE'S PACKAGE REVISION DATA (IF NECESSARY)
"RTN","RORKIDS",249,0)
 ;
"RTN","RORKIDS",250,0)
 ; FILE          File number
"RTN","RORKIDS",251,0)
 ;
"RTN","RORKIDS",252,0)
 ; [PRD]         Package revision data
"RTN","RORKIDS",253,0)
 ;                 ^01: Revision number (N.N)
"RTN","RORKIDS",254,0)
 ;                 ^02: Patch name
"RTN","RORKIDS",255,0)
 ;
"RTN","RORKIDS",256,0)
 ; If this entry point is called as a function, it returns the
"RTN","RORKIDS",257,0)
 ; previous value of the PACKAGE REVISION DATA attribute.
"RTN","RORKIDS",258,0)
 ;
"RTN","RORKIDS",259,0)
PRD(FILE,PRD) ;
"RTN","RORKIDS",260,0)
 N OLDPRD,RORMSG
"RTN","RORKIDS",261,0)
 S OLDPRD=$$GET1^DID(FILE,,,"PACKAGE REVISION DATA",,"RORMSG")
"RTN","RORKIDS",262,0)
 D:$G(PRD)>OLDPRD PRD^DILFD(FILE,PRD)
"RTN","RORKIDS",263,0)
 Q:$QUIT OLDPRD  Q
"RTN","RORLOCK")
0^111^B21824053
"RTN","RORLOCK",1,0)
RORLOCK ;HCIOFO/SG - LOCKS AND TYRANSACTIONS ; 10/1/03 4:36pm
"RTN","RORLOCK",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORLOCK",3,0)
 ;
"RTN","RORLOCK",4,0)
 Q
"RTN","RORLOCK",5,0)
 ;
"RTN","RORLOCK",6,0)
 ;***** FINDS THE LOCK DESCRIPTOR FOR THE GLOBAL NODE
"RTN","RORLOCK",7,0)
LDSC(NODELIST) ;
"RTN","RORLOCK",8,0)
 N DESCR,IENS,L,NDX,NODE,RORMSG,SP,TMP
"RTN","RORLOCK",9,0)
 S:$D(NODELIST)<10 NODELIST(NODELIST)=""
"RTN","RORLOCK",10,0)
 S (DESCR,NODE)=""
"RTN","RORLOCK",11,0)
 F  S NODE=$O(NODELIST(NODE))  Q:NODE=""  D
"RTN","RORLOCK",12,0)
 . ;--- The Node itself
"RTN","RORLOCK",13,0)
 . S SP=$$XLNDX(NODE),TMP=$G(^XTMP("RORLOCK",SP))
"RTN","RORLOCK",14,0)
 . S:TMP>DESCR DESCR=TMP
"RTN","RORLOCK",15,0)
 . ;--- Left Siblings and Ancestors
"RTN","RORLOCK",16,0)
 . S NDX=SP
"RTN","RORLOCK",17,0)
 . F  S NDX=$O(^XTMP("RORLOCK",NDX),-1),L=$L(NDX)  Q:(NDX="")!(NDX'=$E(SP,1,L))  D
"RTN","RORLOCK",18,0)
 . . S TMP=$G(^XTMP("RORLOCK",NDX))  S:TMP>DESCR DESCR=TMP
"RTN","RORLOCK",19,0)
 . ;--- Right Siblings and Descendants
"RTN","RORLOCK",20,0)
 . S NDX=SP,L=$L(SP)
"RTN","RORLOCK",21,0)
 . F  S NDX=$O(^XTMP("RORLOCK",NDX))  Q:(NDX="")!($E(NDX,1,L)'=SP)  D
"RTN","RORLOCK",22,0)
 . . S TMP=$G(^XTMP("RORLOCK",NDX))  S:TMP>DESCR DESCR=TMP
"RTN","RORLOCK",23,0)
 ;--- Prepare the lock descriptor
"RTN","RORLOCK",24,0)
 S:'DESCR $P(DESCR,U)=$$NOW^XLFDT
"RTN","RORLOCK",25,0)
 D:$P(DESCR,U,3)>0
"RTN","RORLOCK",26,0)
 . S IENS=+$P(DESCR,U,3)_","
"RTN","RORLOCK",27,0)
 . S $P(DESCR,U,2)=$$GET1^DIQ(200,IENS,.01,,,"RORMSG")
"RTN","RORLOCK",28,0)
 . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,200,IENS)
"RTN","RORLOCK",29,0)
 S:$P(DESCR,U,2)="" $P(DESCR,U,2)="UNKNOWN USER"
"RTN","RORLOCK",30,0)
 Q DESCR
"RTN","RORLOCK",31,0)
 ;
"RTN","RORLOCK",32,0)
 ;***** LOCKS THE (SUB)FILE, RECORD OR FIELD NODE
"RTN","RORLOCK",33,0)
 ;
"RTN","RORLOCK",34,0)
 ; FILE          File/subfile number
"RTN","RORLOCK",35,0)
 ; [IENS]        IENS of the record or subfile
"RTN","RORLOCK",36,0)
 ; [FIELD]       Field number
"RTN","RORLOCK",37,0)
 ; [TO]          Timeout (1 sec, by default)
"RTN","RORLOCK",38,0)
 ;
"RTN","RORLOCK",39,0)
 ; Return Values:
"RTN","RORLOCK",40,0)
 ;       <0  Error code
"RTN","RORLOCK",41,0)
 ;        0  Ok (the object has been locked)
"RTN","RORLOCK",42,0)
 ;       >0  The object is locked by another user. A lock descriptor
"RTN","RORLOCK",43,0)
 ;           is returned in this case:
"RTN","RORLOCK",44,0)
 ;             ^01: Date/Time (FileMan)
"RTN","RORLOCK",45,0)
 ;             ^02: User/Process name
"RTN","RORLOCK",46,0)
 ;             ^03: User IEN (DUZ)
"RTN","RORLOCK",47,0)
 ;             ^04: $JOB
"RTN","RORLOCK",48,0)
 ;             ^05: Task number
"RTN","RORLOCK",49,0)
 ;
"RTN","RORLOCK",50,0)
 ; If the fourth field is empty then the object is locked by unknown
"RTN","RORLOCK",51,0)
 ; user (see the name in the 2nd field).
"RTN","RORLOCK",52,0)
 ;
"RTN","RORLOCK",53,0)
 ; Otherwise, if the third field is empty then the object is locked
"RTN","RORLOCK",54,0)
 ; by a registry background process (see the name in the 2nd field).
"RTN","RORLOCK",55,0)
 ;
"RTN","RORLOCK",56,0)
LOCK(FILE,IENS,FIELD,TO,NAME) ;
"RTN","RORLOCK",57,0)
 N DESCR,NODELIST,NODE,PI,RC
"RTN","RORLOCK",58,0)
 I $D(FILE)<10  S RC=0  D:$G(FILE)>0  Q RC
"RTN","RORLOCK",59,0)
 . S RC=$$LOCK1(FILE,$G(IENS),$G(FIELD),$G(TO),$G(NAME))
"RTN","RORLOCK",60,0)
 ;--- Compile the list of global nodes
"RTN","RORLOCK",61,0)
 S RC=$$NODELIST(.NODELIST,.FILE,$G(IENS),$G(FIELD))
"RTN","RORLOCK",62,0)
 Q:RC<0 RC  Q:NODELIST="" 0
"RTN","RORLOCK",63,0)
 ;--- Try to lock the object(s)
"RTN","RORLOCK",64,0)
 X "L +("_NODELIST_"):"_$S($G(TO)>0:TO,1:1)  E  Q $$LDSC(.NODELIST)
"RTN","RORLOCK",65,0)
 ;--- Create the lock descriptor(s)
"RTN","RORLOCK",66,0)
 S DESCR=$$NOW^XLFDT_U_$G(NAME)_U_U_$JOB_U_$G(ZTSK)
"RTN","RORLOCK",67,0)
 S:$G(NAME)="" $P(DESCR,U,3)=$G(DUZ)
"RTN","RORLOCK",68,0)
 S NODE=""
"RTN","RORLOCK",69,0)
 F  S NODE=$O(NODELIST(NODE))  Q:NODE=""  D
"RTN","RORLOCK",70,0)
 . S ^XTMP("RORLOCK",$$XLNDX(NODE))=DESCR
"RTN","RORLOCK",71,0)
 Q 0
"RTN","RORLOCK",72,0)
 ;
"RTN","RORLOCK",73,0)
LOCK1(FILE,IENS,FIELD,TO,NAME) ;
"RTN","RORLOCK",74,0)
 N DESCR,NODE
"RTN","RORLOCK",75,0)
 S NODE=$$NODE(FILE,$G(IENS),$G(FIELD))
"RTN","RORLOCK",76,0)
 Q:NODE<0 NODE
"RTN","RORLOCK",77,0)
 ;--- Try to lock the object
"RTN","RORLOCK",78,0)
 L +@NODE:$S($G(TO)>0:TO,1:1)  E  Q $$LDSC(NODE)
"RTN","RORLOCK",79,0)
 ;--- Create the lock descriptor
"RTN","RORLOCK",80,0)
 S DESCR=$$NOW^XLFDT_U_$G(NAME)_U_U_$JOB_U_$G(ZTSK)
"RTN","RORLOCK",81,0)
 S:$G(NAME)="" $P(DESCR,U,3)=$G(DUZ)
"RTN","RORLOCK",82,0)
 S ^XTMP("RORLOCK",$$XLNDX(NODE))=DESCR
"RTN","RORLOCK",83,0)
 Q 0
"RTN","RORLOCK",84,0)
 ;
"RTN","RORLOCK",85,0)
 ;***** RETURNS THE GLOBAL NODE OF THE OBJECT
"RTN","RORLOCK",86,0)
 ;
"RTN","RORLOCK",87,0)
 ; FILE          File/subfile number
"RTN","RORLOCK",88,0)
 ; IENS          IENS of the record or subfile
"RTN","RORLOCK",89,0)
 ; FIELD         Field number
"RTN","RORLOCK",90,0)
 ;
"RTN","RORLOCK",91,0)
 ; Return Values:
"RTN","RORLOCK",92,0)
 ;       <0  Error code
"RTN","RORLOCK",93,0)
 ;           Closed root
"RTN","RORLOCK",94,0)
 ;
"RTN","RORLOCK",95,0)
NODE(FILE,IENS,FIELD) ;
"RTN","RORLOCK",96,0)
 N FGL,IEN,NODE,RC
"RTN","RORLOCK",97,0)
 S IEN=+IENS  S:IEN $P(IENS,",")=""
"RTN","RORLOCK",98,0)
 ;--- Closed root of the (sub)file
"RTN","RORLOCK",99,0)
 S NODE=$$ROOT^DILFD(FILE,IENS,1)
"RTN","RORLOCK",100,0)
 I NODE=""  D  Q RC
"RTN","RORLOCK",101,0)
 . S RC=$$ERROR^RORERR(-98,,,,FILE,IENS)
"RTN","RORLOCK",102,0)
 Q:'IEN NODE
"RTN","RORLOCK",103,0)
 ;--- The record node
"RTN","RORLOCK",104,0)
 S NODE=$NA(@NODE@(IEN))
"RTN","RORLOCK",105,0)
 Q:'FIELD NODE
"RTN","RORLOCK",106,0)
 ;--- Field node
"RTN","RORLOCK",107,0)
 S FGL=$$GET1^DID(FILE,FIELD,,"GLOBAL SUBSCRIPT LOCATION",,"RORMSG")
"RTN","RORLOCK",108,0)
 I $G(DIERR)  D  Q RC
"RTN","RORLOCK",109,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,FILE)
"RTN","RORLOCK",110,0)
 S:$P(FGL,";")'="" NODE=$NA(@NODE@($P(FGL,";")))
"RTN","RORLOCK",111,0)
 Q NODE
"RTN","RORLOCK",112,0)
 ;
"RTN","RORLOCK",113,0)
 ;***** COMPILES THE LIST OF GLOBAL NODES
"RTN","RORLOCK",114,0)
NODELIST(NODELIST,FILE,IENS,FIELD) ;
"RTN","RORLOCK",115,0)
 N NODE,PI,RC  K NODELIST
"RTN","RORLOCK",116,0)
 S NODELIST="",RC=0
"RTN","RORLOCK",117,0)
 ;--- Main object
"RTN","RORLOCK",118,0)
 I $G(FILE)>0  D  Q:RC<0 RC
"RTN","RORLOCK",119,0)
 . S NODE=$$NODE(FILE,IENS,FIELD)
"RTN","RORLOCK",120,0)
 . I NODE<0  S RC=+NODE  Q
"RTN","RORLOCK",121,0)
 . S NODELIST=NODELIST_","_NODE
"RTN","RORLOCK",122,0)
 . S NODELIST(NODE)=""
"RTN","RORLOCK",123,0)
 ;--- Linked objects
"RTN","RORLOCK",124,0)
 S PI="FILE"
"RTN","RORLOCK",125,0)
 F  S PI=$Q(@PI)  Q:PI=""  D  Q:RC<0
"RTN","RORLOCK",126,0)
 . S NODE=$$NODE($QS(PI,1),$QS(PI,2),$QS(PI,3))
"RTN","RORLOCK",127,0)
 . I NODE<0  S RC=+NODE  Q
"RTN","RORLOCK",128,0)
 . S NODELIST=NODELIST_","_NODE
"RTN","RORLOCK",129,0)
 . S NODELIST(NODE)=""
"RTN","RORLOCK",130,0)
 Q:RC<0 RC
"RTN","RORLOCK",131,0)
 ;---
"RTN","RORLOCK",132,0)
 S NODELIST=$P(NODELIST,",",2,999)
"RTN","RORLOCK",133,0)
 Q RC
"RTN","RORLOCK",134,0)
 ;
"RTN","RORLOCK",135,0)
 ;***** GENERATES A TEXT DESCRIPTION FROM THE LOCK DESCRIPTOR
"RTN","RORLOCK",136,0)
 ;
"RTN","RORLOCK",137,0)
 ; LDSC          Lock descriptor returned by the $$LOCK^RORLOCK
"RTN","RORLOCK",138,0)
 ;
"RTN","RORLOCK",139,0)
TEXT(LDSC) ;
"RTN","RORLOCK",140,0)
 N LTEXT
"RTN","RORLOCK",141,0)
 S LTEXT=$P(LDSC,U,2)_" about "_$$FMTE^XLFDT(+LDSC)
"RTN","RORLOCK",142,0)
 S:$P(LDSC,U,4) LTEXT=LTEXT_"; Job #"_$P(LDSC,U,4)
"RTN","RORLOCK",143,0)
 S:$P(LDSC,U,5) LTEXT=LTEXT_"; Task #"_$P(LDSC,U,5)
"RTN","RORLOCK",144,0)
 Q LTEXT
"RTN","RORLOCK",145,0)
 ;
"RTN","RORLOCK",146,0)
 ;***** UNLOCKS THE (SUB)FILE, RECORD OR FIELD NODE
"RTN","RORLOCK",147,0)
 ;
"RTN","RORLOCK",148,0)
 ; FILE          File/subfile number
"RTN","RORLOCK",149,0)
 ; [IENS]        IENS of the record or subfile
"RTN","RORLOCK",150,0)
 ; [FIELD]       Field number
"RTN","RORLOCK",151,0)
 ;
"RTN","RORLOCK",152,0)
 ; Return Values:
"RTN","RORLOCK",153,0)
 ;       <0  Error code
"RTN","RORLOCK",154,0)
 ;        0  Ok
"RTN","RORLOCK",155,0)
 ;
"RTN","RORLOCK",156,0)
 ; NOTE: This entry point can also be called as a procedure:
"RTN","RORLOCK",157,0)
 ;       D UNLOCK^RORLOCK(...) if you do not need its return value.
"RTN","RORLOCK",158,0)
 ;
"RTN","RORLOCK",159,0)
UNLOCK(FILE,IENS,FIELD) ;
"RTN","RORLOCK",160,0)
 N NODELIST,NODE,PI,RC
"RTN","RORLOCK",161,0)
 I $D(FILE)<10  S RC=0  D:$G(FILE)>0  Q:$QUIT RC  Q
"RTN","RORLOCK",162,0)
 . S RC=$$UNLOCK1(FILE,$G(IENS),$G(FIELD))
"RTN","RORLOCK",163,0)
 ;--- Compile the list of global nodes
"RTN","RORLOCK",164,0)
 S RC=$$NODELIST(.NODELIST,.FILE,$G(IENS),$G(FIELD))
"RTN","RORLOCK",165,0)
 I RC<0  Q:$QUIT RC  Q
"RTN","RORLOCK",166,0)
 I NODELIST=""  Q:$QUIT 0  Q
"RTN","RORLOCK",167,0)
 ;--- Remove the lock descriptor(s)
"RTN","RORLOCK",168,0)
 S NODE=""
"RTN","RORLOCK",169,0)
 F  S NODE=$O(NODELIST(NODE))  Q:NODE=""  D
"RTN","RORLOCK",170,0)
 . K ^XTMP("RORLOCK",$$XLNDX(NODE))
"RTN","RORLOCK",171,0)
 ;--- Unlock the object(s)
"RTN","RORLOCK",172,0)
 X "L -("_NODELIST_")"
"RTN","RORLOCK",173,0)
 Q:$QUIT 0  Q
"RTN","RORLOCK",174,0)
 ;
"RTN","RORLOCK",175,0)
UNLOCK1(FILE,IENS,FIELD) ;
"RTN","RORLOCK",176,0)
 N NODE
"RTN","RORLOCK",177,0)
 S NODE=$$NODE(FILE,$G(IENS),$G(FIELD))
"RTN","RORLOCK",178,0)
 Q:NODE<0 NODE
"RTN","RORLOCK",179,0)
 ;--- Remove the lock descriptor
"RTN","RORLOCK",180,0)
 K ^XTMP("RORLOCK",$$XLNDX(NODE))
"RTN","RORLOCK",181,0)
 ;--- Unlock the object
"RTN","RORLOCK",182,0)
 L -@NODE
"RTN","RORLOCK",183,0)
 Q 0
"RTN","RORLOCK",184,0)
 ;
"RTN","RORLOCK",185,0)
 ;***** RETURNS SUBSCRIPT OF THE NODE IN THE DESCRIPTOR TABLE
"RTN","RORLOCK",186,0)
XLNDX(NODE) ;
"RTN","RORLOCK",187,0)
 N L  S L=$L(NODE)
"RTN","RORLOCK",188,0)
 Q $S($E(NODE,L)=")":$E(NODE,1,L-1),1:NODE)
"RTN","RORLOG")
0^9^B44679259
"RTN","RORLOG",1,0)
RORLOG ;HCIOFO/SG - LOG FILE MANAGEMENT ; 2/4/04 9:26am
"RTN","RORLOG",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3,5**;May 14, 2002
"RTN","RORLOG",3,0)
 ;
"RTN","RORLOG",4,0)
 ; RORLOG -------------- CONSTANT & VARIABLES OF THE LOG SUSBSYSTEM
"RTN","RORLOG",5,0)
 ;
"RTN","RORLOG",6,0)
 ; RORLOG("IEN")         IEN of the main record in the ROR LOG file
"RTN","RORLOG",7,0)
 ;
"RTN","RORLOG",8,0)
 ; This routine uses the following IAs:
"RTN","RORLOG",9,0)
 ;
"RTN","RORLOG",10,0)
 ; #10060        Read-only (DBS API) access to the NEW PERSON file
"RTN","RORLOG",11,0)
 ;
"RTN","RORLOG",12,0)
 Q
"RTN","RORLOG",13,0)
 ;
"RTN","RORLOG",14,0)
 ;***** PROCESSES AN ACCESS VIOLATION ALERT
"RTN","RORLOG",15,0)
ACLRTN ;
"RTN","RORLOG",16,0)
 N I,PARAMS,RORBUF
"RTN","RORLOG",17,0)
 ;--- Prepare the parameters
"RTN","RORLOG",18,0)
 S (PARAMS("DUZ"),I)=+$P(XQADATA,U)
"RTN","RORLOG",19,0)
 I I>0  D  K RORBUF
"RTN","RORLOG",20,0)
 . S PARAMS("USERNAME")=$$GET1^DIQ(200,I_",",.01,,,"RORBUF")
"RTN","RORLOG",21,0)
 S:$G(PARAMS("USERNAME"))="" PARAMS("USERNAME")="unknown user"
"RTN","RORLOG",22,0)
 S PARAMS("DATETIME")=$$FMTE^XLFDT($P(XQADATA,U,2))
"RTN","RORLOG",23,0)
 ;--- Generate the text of alert
"RTN","RORLOG",24,0)
 D BLD^DIALOG(7980000.015,.PARAMS,,"RORBUF","S")
"RTN","RORLOG",25,0)
 ;--- Display the alert details
"RTN","RORLOG",26,0)
 S I=0  W !
"RTN","RORLOG",27,0)
 F  S I=$O(RORBUF(I))  Q:I'>0  W !,RORBUF(I)
"RTN","RORLOG",28,0)
 Q
"RTN","RORLOG",29,0)
 ;
"RTN","RORLOG",30,0)
 ;***** RECORDS THE ACCESS VIOLATION EVENT
"RTN","RORLOG",31,0)
 ;
"RTN","RORLOG",32,0)
 ; MSG           Either a negative code of the message or a message
"RTN","RORLOG",33,0)
 ;               text that will be recorded in the log.
"RTN","RORLOG",34,0)
 ;
"RTN","RORLOG",35,0)
 ; [REGISTRY]    Either a registry name or a registry IEN
"RTN","RORLOG",36,0)
 ;               (the log will be associated with this registry)
"RTN","RORLOG",37,0)
 ;
"RTN","RORLOG",38,0)
 ; [ARG2-ARG5]   Optional parameters as for $$MSG^RORERR20
"RTN","RORLOG",39,0)
 ;
"RTN","RORLOG",40,0)
ACVIOLTN(MSG,REGISTRY,ARG2,ARG3,ARG4,ARG5) ;
"RTN","RORLOG",41,0)
 N INFO,RORLOG,RORMSG,RORPARM
"RTN","RORLOG",42,0)
 S REGISTRY=$G(REGISTRY)
"RTN","RORLOG",43,0)
 ;--- Make sure that event recording is enabled
"RTN","RORLOG",44,0)
 S RORPARM("LOG")=1
"RTN","RORLOG",45,0)
 ;--- Get the registry name
"RTN","RORLOG",46,0)
 I (+REGISTRY)=REGISTRY  D:REGISTRY>0
"RTN","RORLOG",47,0)
 . S REGISTRY=$P($G(^ROR(798.1,+REGISTRY,0)),U)
"RTN","RORLOG",48,0)
 ;--- Get the text of the message (if a code is provided)
"RTN","RORLOG",49,0)
 S:(+MSG)=MSG MSG=$$MSG^RORERR20(+MSG,,,.ARG2,.ARG3,.ARG4,.ARG5)
"RTN","RORLOG",50,0)
 ;--- Send an alert to the registry coordinators
"RTN","RORLOG",51,0)
 D:REGISTRY'=""
"RTN","RORLOG",52,0)
 . S INFO=$G(DUZ)_U_$$NOW^XLFDT
"RTN","RORLOG",53,0)
 . D ALERT^RORUTL01(REGISTRY,MSG,"ACLRTN^RORLOG",INFO)
"RTN","RORLOG",54,0)
 ;--- Create a new log and record the message
"RTN","RORLOG",55,0)
 I $$OPEN(REGISTRY,6)'<0  D  D CLOSE()
"RTN","RORLOG",56,0)
 . D:$G(DUZ)>0
"RTN","RORLOG",57,0)
 . . S INFO="Violator: "_$$GET1^DIQ(200,DUZ_",",.01,,,"RORMSG")
"RTN","RORLOG",58,0)
 . . S INFO=INFO_" (DUZ="_DUZ_")"
"RTN","RORLOG",59,0)
 . D LOG(6,MSG,,.INFO)
"RTN","RORLOG",60,0)
 Q
"RTN","RORLOG",61,0)
 ;
"RTN","RORLOG",62,0)
 ;***** CLOSES THE CURRENT LOG
"RTN","RORLOG",63,0)
 ;
"RTN","RORLOG",64,0)
 ; [MESSAGE]     Text of the final message
"RTN","RORLOG",65,0)
 ; [COUNTERS]    Statistic counters
"RTN","RORLOG",66,0)
 ;                 ^1: Total number of processed patients
"RTN","RORLOG",67,0)
 ;                 ^2: Number of patients processed with errors
"RTN","RORLOG",68,0)
 ;
"RTN","RORLOG",69,0)
CLOSE(MESSAGE,COUNTERS) ;
"RTN","RORLOG",70,0)
 Q:$G(RORLOG("IEN"))'>0
"RTN","RORLOG",71,0)
 N BDT,EDT,IENS,RATE,RORFDA,RORINFO,RORMSG,TMP
"RTN","RORLOG",72,0)
 S EDT=$$NOW^XLFDT
"RTN","RORLOG",73,0)
 S IENS=RORLOG("IEN")_","
"RTN","RORLOG",74,0)
 ;--- Prepare statistic data
"RTN","RORLOG",75,0)
 D:$G(COUNTERS)>0
"RTN","RORLOG",76,0)
 . S RORINFO(1)="Patients:     "_+$P(COUNTERS,U)
"RTN","RORLOG",77,0)
 . S RORINFO(2)="Errors:       "_+$P(COUNTERS,U,2)
"RTN","RORLOG",78,0)
 . S BDT=$$GET1^DIQ(798.7,IENS,.01,"I",,"RORMSG")
"RTN","RORLOG",79,0)
 . Q:$G(BDT)'>0
"RTN","RORLOG",80,0)
 . S TMP=$$FMDIFF^XLFDT(EDT,BDT,2)
"RTN","RORLOG",81,0)
 . S RATE=$S(TMP>0:$J(COUNTERS/TMP,0,3),1:"")
"RTN","RORLOG",82,0)
 . S RORINFO(3)="Time (sec):   "_TMP
"RTN","RORLOG",83,0)
 . S:RATE RORINFO(4)="Patients/sec: "_RATE
"RTN","RORLOG",84,0)
 . ;--- Data for the log header
"RTN","RORLOG",85,0)
 . S RORFDA(798.7,IENS,6.01)=$P(COUNTERS,U,1)
"RTN","RORLOG",86,0)
 . S RORFDA(798.7,IENS,6.02)=$P(COUNTERS,U,2)
"RTN","RORLOG",87,0)
 . S:RATE RORFDA(798.7,IENS,6.03)=RATE
"RTN","RORLOG",88,0)
 ;--- Store data in the header and log the final message (if any)
"RTN","RORLOG",89,0)
 S RORFDA(798.7,IENS,5)=EDT
"RTN","RORLOG",90,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORLOG",91,0)
 D:$G(MESSAGE)'="" LOG^RORLOG(,MESSAGE,,.RORINFO)
"RTN","RORLOG",92,0)
 K RORLOG
"RTN","RORLOG",93,0)
 Q
"RTN","RORLOG",94,0)
 ;
"RTN","RORLOG",95,0)
 ;***** PUTS MESSAGE IN THE LOG
"RTN","RORLOG",96,0)
 ;
"RTN","RORLOG",97,0)
 ; [TYPE]        Type of the event:
"RTN","RORLOG",98,0)
 ;                 1  Debug
"RTN","RORLOG",99,0)
 ;                 2  Information
"RTN","RORLOG",100,0)
 ;                 3  Data quality
"RTN","RORLOG",101,0)
 ;                 4  Warning
"RTN","RORLOG",102,0)
 ;                 5  Database error
"RTN","RORLOG",103,0)
 ;                 6  Error
"RTN","RORLOG",104,0)
 ;
"RTN","RORLOG",105,0)
 ;       If value of the parameter is omitted or equals 0, the message
"RTN","RORLOG",106,0)
 ;       is logged as "information" (if log is enabled). This mode is
"RTN","RORLOG",107,0)
 ;       intended for log headers and separators.
"RTN","RORLOG",108,0)
 ;
"RTN","RORLOG",109,0)
 ; MESSAGE       Message text
"RTN","RORLOG",110,0)
 ; [PATIEN]      Patient IEN
"RTN","RORLOG",111,0)
 ;
"RTN","RORLOG",112,0)
 ; [[.]RORINFO]  Optional additional information (either a string or
"RTN","RORLOG",113,0)
 ;               a reference to a local array that contains strings
"RTN","RORLOG",114,0)
 ;               prepared for storing in a word processing field)
"RTN","RORLOG",115,0)
 ;
"RTN","RORLOG",116,0)
LOG(TYPE,MESSAGE,PATIEN,RORINFO) ;
"RTN","RORLOG",117,0)
 ;--- Do not do anything if log is disabled
"RTN","RORLOG",118,0)
 Q:'$G(RORPARM("LOG"))
"RTN","RORLOG",119,0)
 ;--- Check if collection of this kind of event is enabled.
"RTN","RORLOG",120,0)
 ;    Debug messages could be enabled only explicitly.
"RTN","RORLOG",121,0)
 I '$G(TYPE)  S TYPE=2
"RTN","RORLOG",122,0)
 E  I ($D(RORPARM("LOG"))>1)!(TYPE=1)  Q:'$G(RORPARM("LOG",+TYPE))
"RTN","RORLOG",123,0)
 ;---
"RTN","RORLOG",124,0)
 N CURRIO,DATETIME,I,IENS,RC,RORFDA,RORMSG,TMP
"RTN","RORLOG",125,0)
 I $D(RORINFO)=1  S TMP=RORINFO  K RORINFO  S RORINFO(1)=TMP  K TMP
"RTN","RORLOG",126,0)
 S DATETIME=$$NOW^XLFDT
"RTN","RORLOG",127,0)
 ;--- Add a new record to the log (if it has been open)
"RTN","RORLOG",128,0)
 D:$G(RORLOG("IEN"))>0
"RTN","RORLOG",129,0)
 . S IENS="+1,"_RORLOG("IEN")_","
"RTN","RORLOG",130,0)
 . S RORFDA(798.74,IENS,.01)=DATETIME
"RTN","RORLOG",131,0)
 . S RORFDA(798.74,IENS,1)=+TYPE
"RTN","RORLOG",132,0)
 . S RORFDA(798.74,IENS,2)=$E(MESSAGE,1,70)
"RTN","RORLOG",133,0)
 . S:$G(PATIEN) RORFDA(798.74,IENS,3)=+PATIEN
"RTN","RORLOG",134,0)
 . S:$D(RORINFO)>1 RORFDA(798.74,IENS,4)="RORINFO"
"RTN","RORLOG",135,0)
 . D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORLOG",136,0)
 ;--- Display message (if debug mode 2 is enabled)
"RTN","RORLOG",137,0)
 I $G(RORPARM("DEBUG"))>1  U $G(IO(0))  D  U IO
"RTN","RORLOG",138,0)
 . W !,$P($$FMTE^XLFDT(DATETIME,"2FS"),"@",2)_" "_$E(MESSAGE,1,70),!
"RTN","RORLOG",139,0)
 . S I=""
"RTN","RORLOG",140,0)
 . F  S I=$O(RORINFO(I))  Q:I=""  D  W ?9,TMP,!
"RTN","RORLOG",141,0)
 . . S TMP=$G(RORINFO(I))  S:TMP="" TMP=$G(RORINFO(I,0))
"RTN","RORLOG",142,0)
 . W:$G(PATIEN) ?9,"Patient IEN: "_PATIEN,!
"RTN","RORLOG",143,0)
 Q
"RTN","RORLOG",144,0)
 ;
"RTN","RORLOG",145,0)
 ;***** RETURNS AN IEN OF THE CURRENT LOG
"RTN","RORLOG",146,0)
LOGIEN() ;
"RTN","RORLOG",147,0)
 Q +$G(RORLOG("IEN"))
"RTN","RORLOG",148,0)
 ;
"RTN","RORLOG",149,0)
 ;***** OPENS A NEW LOG
"RTN","RORLOG",150,0)
 ;
"RTN","RORLOG",151,0)
 ; [[.]REGLST]   Either name of the registry or reference to a local
"RTN","RORLOG",152,0)
 ;               array containing registry names as subscripts and
"RTN","RORLOG",153,0)
 ;               optional registry IENs as values
"RTN","RORLOG",154,0)
 ;
"RTN","RORLOG",155,0)
 ; [ACTIVITY]    Type of the activity:
"RTN","RORLOG",156,0)
 ;                 0  Other (default)
"RTN","RORLOG",157,0)
 ;                 1  Registry update
"RTN","RORLOG",158,0)
 ;                 2  Data Extract
"RTN","RORLOG",159,0)
 ;                 3  Acknowledgement
"RTN","RORLOG",160,0)
 ;                 4  Hist. Extraction
"RTN","RORLOG",161,0)
 ;                 5  Report
"RTN","RORLOG",162,0)
 ;                 6  Access Violation
"RTN","RORLOG",163,0)
 ;
"RTN","RORLOG",164,0)
 ; [MESSAGE]     Text of the first message
"RTN","RORLOG",165,0)
 ;
"RTN","RORLOG",166,0)
 ; Return Values:
"RTN","RORLOG",167,0)
 ;       <0  Error code
"RTN","RORLOG",168,0)
 ;        0  Ok
"RTN","RORLOG",169,0)
 ;
"RTN","RORLOG",170,0)
OPEN(REGLST,ACTIVITY,MESSAGE) ;
"RTN","RORLOG",171,0)
 Q:'$G(RORPARM("LOG")) 0
"RTN","RORLOG",172,0)
 N I,IENS,RC,REGIEN,REGNAME,RORFDA,RORIEN,RORINFO,RORMSG
"RTN","RORLOG",173,0)
 K RORLOG
"RTN","RORLOG",174,0)
 ;--- Prepare the list of registries
"RTN","RORLOG",175,0)
 I $D(REGLST)=1  S:REGLST'="" REGLST(REGLST)=""
"RTN","RORLOG",176,0)
 S REGNAME="",(I,RC)=0
"RTN","RORLOG",177,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORLOG",178,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORLOG",179,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=REGIEN  Q
"RTN","RORLOG",180,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORLOG",181,0)
 . S I=I+1,RORINFO(I)=REGNAME
"RTN","RORLOG",182,0)
 . S RORFDA(798.73,"+"_(I+10)_",+1,",.01)=REGIEN
"RTN","RORLOG",183,0)
 . S RORIEN(I+10)=REGIEN
"RTN","RORLOG",184,0)
 Q:RC<0 RC
"RTN","RORLOG",185,0)
 ;--- Add a log header (main record) to the ROR LOG file
"RTN","RORLOG",186,0)
 S IENS="+1,"
"RTN","RORLOG",187,0)
 S RORFDA(798.7,IENS,.01)=$$NOW^XLFDT
"RTN","RORLOG",188,0)
 S:$G(ACTIVITY)>0 RORFDA(798.7,IENS,1)=ACTIVITY
"RTN","RORLOG",189,0)
 S RORFDA(798.7,IENS,2)=$J
"RTN","RORLOG",190,0)
 S RORFDA(798.7,IENS,7)=$S($G(DUZ)>0:+DUZ,1:"")
"RTN","RORLOG",191,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORLOG",192,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORLOG",193,0)
 ;--- Initialize variables and write a header (if any)
"RTN","RORLOG",194,0)
 S RORLOG("IEN")=RORIEN(1)
"RTN","RORLOG",195,0)
 D:$G(MESSAGE)'="" LOG(,MESSAGE,,.RORINFO)
"RTN","RORLOG",196,0)
 Q 0
"RTN","RORLOG",197,0)
 ;
"RTN","RORLOG",198,0)
 ;***** REPLACES LIST OF REGISTRIES ASSOCIATED WITH THE CURRENT LOG
"RTN","RORLOG",199,0)
 ;
"RTN","RORLOG",200,0)
 ; [.]REGLST     Either name of the registry or a reference to a local
"RTN","RORLOG",201,0)
 ;               array containing registry names as subscripts and
"RTN","RORLOG",202,0)
 ;               optional registry IENs as values.
"RTN","RORLOG",203,0)
 ;
"RTN","RORLOG",204,0)
 ; [NOLP]        If this parameter is defined and non-zero, the log
"RTN","RORLOG",205,0)
 ;               subsystem parameters will not be updated according
"RTN","RORLOG",206,0)
 ;               to the new list of associated registries.
"RTN","RORLOG",207,0)
 ;
"RTN","RORLOG",208,0)
 ; Return Values:
"RTN","RORLOG",209,0)
 ;       <0  Error code
"RTN","RORLOG",210,0)
 ;        0  Ok
"RTN","RORLOG",211,0)
 ;
"RTN","RORLOG",212,0)
SETRGLST(REGLST,NOLP) ;
"RTN","RORLOG",213,0)
 N I,IENS,RC,REGIEN,RILST,RORBUF,RORFDA,RORIEN,RORMSG
"RTN","RORLOG",214,0)
 S IENS=$$LOGIEN()_","
"RTN","RORLOG",215,0)
 Q:'$G(RORPARM("LOG"))!(IENS'>0) 0
"RTN","RORLOG",216,0)
 ;--- Compile a list of registry IENs (as subscripts)
"RTN","RORLOG",217,0)
 S:$D(REGLST)=1 REGLST(REGLST)=""
"RTN","RORLOG",218,0)
 S I="",RC=0
"RTN","RORLOG",219,0)
 F  S I=$O(REGLST(I))  Q:I=""  D  Q:RC<0
"RTN","RORLOG",220,0)
 . S REGIEN=+$G(REGLST(I))
"RTN","RORLOG",221,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=REGIEN  Q
"RTN","RORLOG",222,0)
 . . S REGIEN=$$REGIEN^RORUTL02(I)
"RTN","RORLOG",223,0)
 . S RILST(REGIEN)=""
"RTN","RORLOG",224,0)
 Q:RC<0 RC
"RTN","RORLOG",225,0)
 ;--- Delete old registries from the multiple of the log record
"RTN","RORLOG",226,0)
 D LIST^DIC(798.73,","_IENS,"@;.01I","U",,,,"B",,,"RORBUF","RORMSG")
"RTN","RORLOG",227,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORLOG",228,0)
 S I=""
"RTN","RORLOG",229,0)
 F  S I=$O(RORBUF("DILIST",2,I))  Q:I=""  D
"RTN","RORLOG",230,0)
 . S REGIEN=RORBUF("DILIST","ID",I,.01)
"RTN","RORLOG",231,0)
 . I $D(RILST(REGIEN))  K RILST(REGIEN)  Q
"RTN","RORLOG",232,0)
 . S RORFDA(798.73,RORBUF("DILIST",2,I)_","_IENS,.01)="@"
"RTN","RORLOG",233,0)
 I $D(RORFDA)>1  D  Q:RC<0 RC
"RTN","RORLOG",234,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORLOG",235,0)
 . S RC=$$DBS^RORERR("RORMSG",-9)
"RTN","RORLOG",236,0)
 ;--- Add new registries to the multiple
"RTN","RORLOG",237,0)
 S REGIEN=""
"RTN","RORLOG",238,0)
 F I=1:1  S REGIEN=$O(RILST(REGIEN))  Q:REGIEN=""  D
"RTN","RORLOG",239,0)
 . S RORFDA(798.73,"+"_I_","_IENS,.01)=REGIEN
"RTN","RORLOG",240,0)
 . S RORIEN(I)=REGIEN
"RTN","RORLOG",241,0)
 I $D(RORFDA)>1  D  Q:RC<0 RC
"RTN","RORLOG",242,0)
 . D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORLOG",243,0)
 . S RC=$$DBS^RORERR("RORMSG",-9)
"RTN","RORLOG",244,0)
 ;--- Reload parameters (if necessary)
"RTN","RORLOG",245,0)
 I '$G(NOLP)  D  Q:RC<0 RC
"RTN","RORLOG",246,0)
 . K RORPARM("LOG")  S RC=$$PARAMS^RORLOG01(.REGLST)
"RTN","RORLOG",247,0)
 Q 0
"RTN","RORLOG",248,0)
 ;
"RTN","RORLOG",249,0)
 ;***** INITIALIZES THE LOG SUBSYSTEM
"RTN","RORLOG",250,0)
 ;
"RTN","RORLOG",251,0)
 ; [[.]REGLST]   Either a reference to a local array containing names
"RTN","RORLOG",252,0)
 ;               of the registries to process (as subscripts) or a
"RTN","RORLOG",253,0)
 ;               string that contains a name of the single registry.
"RTN","RORLOG",254,0)
 ;
"RTN","RORLOG",255,0)
 ; Return Values:
"RTN","RORLOG",256,0)
 ;       <0  Error code
"RTN","RORLOG",257,0)
 ;        0  Ok
"RTN","RORLOG",258,0)
 ;
"RTN","RORLOG",259,0)
SETUP(REGLST) ;
"RTN","RORLOG",260,0)
 K RORPARM("LOG"),RORLOG
"RTN","RORLOG",261,0)
 S:$D(REGLST)=1 REGLST(REGLST)=""
"RTN","RORLOG",262,0)
 Q $$PARAMS^RORLOG01(.REGLST)
"RTN","RORLOG01")
0^52^B10659311
"RTN","RORLOG01",1,0)
RORLOG01 ;HCIOFO/SG - LOG FILE MANAGEMENT (UTILITIES) ; 11/26/03 2:44pm
"RTN","RORLOG01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3,5**;May 14, 2002
"RTN","RORLOG01",3,0)
 ;
"RTN","RORLOG01",4,0)
 Q
"RTN","RORLOG01",5,0)
 ;
"RTN","RORLOG01",6,0)
 ;***** LOADS THE LOG SUBSYSTEM PARAMETERS
"RTN","RORLOG01",7,0)
 ;
"RTN","RORLOG01",8,0)
 ; .RORLST       Reference to a local array containing names
"RTN","RORLOG01",9,0)
 ;               of the registries to process (as subscripts).
"RTN","RORLOG01",10,0)
 ;
"RTN","RORLOG01",11,0)
 ; Return Values:
"RTN","RORLOG01",12,0)
 ;       <0  Error code
"RTN","RORLOG01",13,0)
 ;        0  Ok
"RTN","RORLOG01",14,0)
 ;
"RTN","RORLOG01",15,0)
PARAMS(RORLST) ;
"RTN","RORLOG01",16,0)
 N ENABLE,IENS,IR,IRS,RC,RORBUF,RORMSG,RORSB,SCR,TYPE
"RTN","RORLOG01",17,0)
 ;--- Load a list of parameters of active registries
"RTN","RORLOG01",18,0)
 S SCR="I '$P(^(0),U,7),$D(RORLST($P(^(0),U)))"
"RTN","RORLOG01",19,0)
 D LIST^DIC(798.1,,"@;8I","U","*",,,"B",SCR,,"RORBUF","RORMSG")
"RTN","RORLOG01",20,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORLOG01",21,0)
 I '$G(RORBUF("DILIST",0))  S RORPARM("LOG")=1  Q 0
"RTN","RORLOG01",22,0)
 ;--- Process the list of log parameters
"RTN","RORLOG01",23,0)
 S IR="",RC=0
"RTN","RORLOG01",24,0)
 F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D  Q:RC
"RTN","RORLOG01",25,0)
 . ;--- Check if the log is enabled
"RTN","RORLOG01",26,0)
 . Q:'$G(RORBUF("DILIST","ID",IR,8))
"RTN","RORLOG01",27,0)
 . S ENABLE=1
"RTN","RORLOG01",28,0)
 . ;--- Load a list of event types to log
"RTN","RORLOG01",29,0)
 . S IRS=","_RORBUF("DILIST",2,IR)_","  K RORSB
"RTN","RORLOG01",30,0)
 . D LIST^DIC(798.11,IRS,"@;.01I","U","*",,,"B",,,"RORSB","RORMSG")
"RTN","RORLOG01",31,0)
 . S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0
"RTN","RORLOG01",32,0)
 . ;--- If there are no event types, log all events
"RTN","RORLOG01",33,0)
 . I '$G(RORSB("DILIST",0))  D  Q
"RTN","RORLOG01",34,0)
 . . K RORPARM("LOG")  S RC=1
"RTN","RORLOG01",35,0)
 . ;--- Process the list of event types
"RTN","RORLOG01",36,0)
 . S IRS=""
"RTN","RORLOG01",37,0)
 . F  S IRS=$O(RORSB("DILIST","ID",IRS))  Q:IRS=""  D
"RTN","RORLOG01",38,0)
 . . S TYPE=+$G(RORSB("DILIST","ID",IRS,.01))
"RTN","RORLOG01",39,0)
 . . S:TYPE RORPARM("LOG",TYPE)=1
"RTN","RORLOG01",40,0)
 S:$G(ENABLE) RORPARM("LOG")=1
"RTN","RORLOG01",41,0)
 ;--- If not all types of errors are recorded,
"RTN","RORLOG01",42,0)
 ;    enable recording of the type "Error"
"RTN","RORLOG01",43,0)
 S:$D(RORPARM("LOG"))>1 RORPARM("LOG",6)=1
"RTN","RORLOG01",44,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORLOG01",45,0)
 ;
"RTN","RORLOG01",46,0)
 ;***** PURGES THE OLD LOGS
"RTN","RORLOG01",47,0)
 ;
"RTN","RORLOG01",48,0)
 ; [DKEEP]       Days to keep logs in the file (by default = 31)
"RTN","RORLOG01",49,0)
 ;
"RTN","RORLOG01",50,0)
 ; Return Values:
"RTN","RORLOG01",51,0)
 ;       <0  Error code
"RTN","RORLOG01",52,0)
 ;        0  Ok
"RTN","RORLOG01",53,0)
 ;
"RTN","RORLOG01",54,0)
PURGE(DKEEP) ;
"RTN","RORLOG01",55,0)
 N HDR,IEN,IR,RC,RORFDA,RORFROM,RORMSG
"RTN","RORLOG01",56,0)
 S RORFROM=$$FMADD^XLFDT($$DT^XLFDT,-$G(DKEEP,31))+1
"RTN","RORLOG01",57,0)
 S RC=0
"RTN","RORLOG01",58,0)
 F  D  Q:'$P($G(HDR),U,3)!(RC<0)
"RTN","RORLOG01",59,0)
 . K RORFDA,RORMSG
"RTN","RORLOG01",60,0)
 . ;--- Get the next 10 records
"RTN","RORLOG01",61,0)
 . D LIST^DIC(798.7,,"@","BU",10,.RORFROM,,"B",,,"RORFDA","RORMSG")
"RTN","RORLOG01",62,0)
 . S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0
"RTN","RORLOG01",63,0)
 . ;--- Stop if no records left
"RTN","RORLOG01",64,0)
 . S HDR=$G(RORFDA("DILIST",0))  Q:'HDR
"RTN","RORLOG01",65,0)
 . ;--- Prepare the data
"RTN","RORLOG01",66,0)
 . S IR=""
"RTN","RORLOG01",67,0)
 . F  S IR=$O(RORFDA("DILIST",2,IR),-1)  Q:IR=""  D
"RTN","RORLOG01",68,0)
 . . S IEN=RORFDA("DILIST",2,IR)
"RTN","RORLOG01",69,0)
 . . ;--- Check if the cross-reference entries are valid
"RTN","RORLOG01",70,0)
 . . D XREFCHK(IEN)
"RTN","RORLOG01",71,0)
 . . ;--- Delete the log only if it is not referenced
"RTN","RORLOG01",72,0)
 . . S:'$D(^RORDATA(798.7,"AREF",IEN)) RORFDA(798.7,IEN_",",.01)="@"
"RTN","RORLOG01",73,0)
 . K RORFDA("DILIST")
"RTN","RORLOG01",74,0)
 . Q:$D(RORFDA)<10
"RTN","RORLOG01",75,0)
 . ;--- Delete the records
"RTN","RORLOG01",76,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORLOG01",77,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.7)
"RTN","RORLOG01",78,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORLOG01",79,0)
 ;
"RTN","RORLOG01",80,0)
 ;***** CHECK IF THE LOG IS REALLY REFERENCED
"RTN","RORLOG01",81,0)
 ;
"RTN","RORLOG01",82,0)
 ; LOGIEN        IEN of the log
"RTN","RORLOG01",83,0)
 ;
"RTN","RORLOG01",84,0)
XREFCHK(LOGIEN) ;
"RTN","RORLOG01",85,0)
 N FIELD,FILE,IENS,NODE,RORMSG,TMP
"RTN","RORLOG01",86,0)
 S NODE=$NA(^RORDATA(798.7,"AREF",IEN))
"RTN","RORLOG01",87,0)
 S FILE=""
"RTN","RORLOG01",88,0)
 F  S FILE=$O(@NODE@(FILE))  Q:FILE=""  D
"RTN","RORLOG01",89,0)
 . S IENS=""
"RTN","RORLOG01",90,0)
 . F  S IENS=$O(@NODE@(FILE,IENS))  Q:IENS=""  D
"RTN","RORLOG01",91,0)
 . . S FIELD=""
"RTN","RORLOG01",92,0)
 . . F  S FIELD=$O(@NODE@(FILE,IENS,FIELD))  Q:FIELD=""  D
"RTN","RORLOG01",93,0)
 . . . S TMP=+$$GET1^DIQ(FILE,IENS,FIELD,"I",,"RORMSG")
"RTN","RORLOG01",94,0)
 . . . K:TMP'=LOGIEN @NODE@(FILE,IENS,FIELD)
"RTN","RORLOG01",95,0)
 Q
"RTN","RORNTEG")
0^182^B19482341
"RTN","RORNTEG",1,0)
RORNTEG ;ISC/XTSUMBLD KERNEL - Package checksum checker ; 2/17/04 2:22pm
"RTN","RORNTEG",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3,4,5**;May 14, 2002
"RTN","RORNTEG",3,0)
 ;;7.3;3040130.113651
"RTN","RORNTEG",4,0)
 S XT4="I 1",X=$T(+3) W !!,"Checksum routine created on ",$P(X,";",4)," by KERNEL V",$P(X,";",3),!
"RTN","RORNTEG",5,0)
CONT F XT1=1:1 S XT2=$T(ROU+XT1) Q:XT2=""  S X=$P(XT2," ",1),XT3=$P(XT2,";",3) X XT4 I $T W !,X X ^%ZOSF("TEST") S:'$T XT3=0 X:XT3 ^%ZOSF("RSUM") W ?10,$S('XT3:"Routine not in UCI",XT3'=Y:"Calculated "_$C(7)_Y_", off by "_(Y-XT3),1:"ok")
"RTN","RORNTEG",6,0)
 G CONT^RORNTEG0
"RTN","RORNTEG",7,0)
 K %1,%2,%3,X,Y,XT1,XT2,XT3,XT4 Q
"RTN","RORNTEG",8,0)
ONE S XT4="I $D(^UTILITY($J,X))",X=$T(+3) W !!,"Checksum routine created on ",$P(X,";",4)," by KERNEL V",$P(X,";",3),!
"RTN","RORNTEG",9,0)
 W !,"Check a subset of routines:" K ^UTILITY($J) X ^%ZOSF("RSEL")
"RTN","RORNTEG",10,0)
 W ! G CONT
"RTN","RORNTEG",11,0)
ROU ;;
"RTN","RORNTEG",12,0)
ROR ;;2391687
"RTN","RORNTEG",13,0)
ROR01 ;;1117
"RTN","RORNTEG",14,0)
ROR02 ;;1122
"RTN","RORNTEG",15,0)
ROR10 ;;5784769
"RTN","RORNTEG",16,0)
RORACK ;;4221963
"RTN","RORNTEG",17,0)
RORACK01 ;;6457683
"RTN","RORNTEG",18,0)
RORAPI01 ;;2291186
"RTN","RORNTEG",19,0)
RORDD ;;4886229
"RTN","RORNTEG",20,0)
RORDD01 ;;919515
"RTN","RORNTEG",21,0)
RORERR ;;3863551
"RTN","RORNTEG",22,0)
RORERR10 ;;9157206
"RTN","RORNTEG",23,0)
RORERR11 ;;17589767
"RTN","RORNTEG",24,0)
RORERR12 ;;13407882
"RTN","RORNTEG",25,0)
RORERR20 ;;13404338
"RTN","RORNTEG",26,0)
ROREVT01 ;;2008294
"RTN","RORNTEG",27,0)
ROREXPR ;;3001150
"RTN","RORNTEG",28,0)
ROREXT ;;4234009
"RTN","RORNTEG",29,0)
ROREXT01 ;;4753620
"RTN","RORNTEG",30,0)
ROREXT02 ;;4489200
"RTN","RORNTEG",31,0)
ROREXTUT ;;6225863
"RTN","RORNTEG",32,0)
RORHDT ;;3515691
"RTN","RORNTEG",33,0)
RORHDT01 ;;2383372
"RTN","RORNTEG",34,0)
RORHDT02 ;;1374405
"RTN","RORNTEG",35,0)
RORHDT03 ;;4235780
"RTN","RORNTEG",36,0)
RORHDT04 ;;8306528
"RTN","RORNTEG",37,0)
RORHDT05 ;;2635437
"RTN","RORNTEG",38,0)
RORHDTAC ;;3280350
"RTN","RORNTEG",39,0)
RORHDTUT ;;4563799
"RTN","RORNTEG",40,0)
RORHL01 ;;2652082
"RTN","RORNTEG",41,0)
RORHL02 ;;7393211
"RTN","RORNTEG",42,0)
RORHL03 ;;5320617
"RTN","RORNTEG",43,0)
RORHL031 ;;7722343
"RTN","RORNTEG",44,0)
RORHL04 ;;5194059
"RTN","RORNTEG",45,0)
RORHL05 ;;1858773
"RTN","RORNTEG",46,0)
RORHL06 ;;4487923
"RTN","RORNTEG",47,0)
RORHL07 ;;4109759
"RTN","RORNTEG",48,0)
RORHL071 ;;4090467
"RTN","RORNTEG",49,0)
RORHL08 ;;4376658
"RTN","RORNTEG",50,0)
RORHL081 ;;7681710
"RTN","RORNTEG",51,0)
RORHL09 ;;7090154
"RTN","RORNTEG",52,0)
RORHL10 ;;6706945
"RTN","RORNTEG",53,0)
RORHL11 ;;5142087
"RTN","RORNTEG",54,0)
RORHL12 ;;2274629
"RTN","RORNTEG",55,0)
RORHL121 ;;9997256
"RTN","RORNTEG",56,0)
RORHL13 ;;3432675
"RTN","RORNTEG",57,0)
RORHL14 ;;5434624
"RTN","RORNTEG",58,0)
RORHL15 ;;5689840
"RTN","RORNTEG",59,0)
RORHL16 ;;2973634
"RTN","RORNTEG",60,0)
RORHL17 ;;6078801
"RTN","RORNTEG",61,0)
RORHL21 ;;1631067
"RTN","RORNTEG",62,0)
RORHL7 ;;5115013
"RTN","RORNTEG",63,0)
RORHL7A ;;2252045
"RTN","RORNTEG",64,0)
RORHLUT1 ;;1863278
"RTN","RORNTEG",65,0)
RORICR01 ;;1541289
"RTN","RORNTEG",66,0)
RORICR02 ;;2080214
"RTN","RORNTEG",67,0)
RORICR03 ;;4746011
"RTN","RORNTEG",68,0)
RORICREX ;;3978828
"RTN","RORNTEG",69,0)
RORICRUT ;;362893
"RTN","RORNTEG",70,0)
RORKIDS ;;6161632
"RTN","RORNTEG",71,0)
RORLOCK ;;4131518
"RTN","RORNTEG",72,0)
RORLOG ;;5965990
"RTN","RORNTEG",73,0)
RORLOG01 ;;3182899
"RTN","RORNTEG",74,0)
RORP003 ;;6424519
"RTN","RORNTEG",75,0)
RORP004 ;;1648658
"RTN","RORNTEG",76,0)
RORP005 ;;10769113
"RTN","RORNTEG",77,0)
RORP005B ;;7032438
"RTN","RORNTEG",78,0)
RORPUT01 ;;5495626
"RTN","RORNTEG",79,0)
RORREP01 ;;9015849
"RTN","RORNTEG",80,0)
RORREP02 ;;10910524
"RTN","RORNTEG",81,0)
RORRP007 ;;4488913
"RTN","RORNTEG",82,0)
RORRP010 ;;1854669
"RTN","RORNTEG",83,0)
RORRP011 ;;1877613
"RTN","RORNTEG",84,0)
RORRP012 ;;2671505
"RTN","RORNTEG",85,0)
RORRP013 ;;4685153
"RTN","RORNTEG",86,0)
RORRP014 ;;1851772
"RTN","RORNTEG",87,0)
RORRP015 ;;3365112
"RTN","RORNTEG",88,0)
RORRP016 ;;1339527
"RTN","RORNTEG",89,0)
RORRP017 ;;2082982
"RTN","RORNTEG",90,0)
RORRP018 ;;1399897
"RTN","RORNTEG",91,0)
RORRP019 ;;3371279
"RTN","RORNTEG",92,0)
RORRP020 ;;5106473
"RTN","RORNTEG",93,0)
RORRP021 ;;2207749
"RTN","RORNTEG",94,0)
RORRP022 ;;1246520
"RTN","RORNTEG",95,0)
RORRP023 ;;2273081
"RTN","RORNTEG",96,0)
RORRP024 ;;3769315
"RTN","RORNTEG",97,0)
RORRP025 ;;4917408
"RTN","RORNTEG",98,0)
RORRP026 ;;10022660
"RTN","RORNTEG",99,0)
RORRP027 ;;6640755
"RTN","RORNTEG",100,0)
RORRP029 ;;1527601
"RTN","RORNTEG",101,0)
RORRP030 ;;6111440
"RTN","RORNTEG",102,0)
RORRP031 ;;4897990
"RTN","RORNTEG",103,0)
RORRP032 ;;4897358
"RTN","RORNTEG",104,0)
RORRP033 ;;4204729
"RTN","RORNTEG",105,0)
RORRP034 ;;3265353
"RTN","RORNTEG",106,0)
RORRP035 ;;1615892
"RTN","RORNTEG",107,0)
RORRP1 ;;2796927
"RTN","RORNTEG",108,0)
RORRP10 ;;476541
"RTN","RORNTEG",109,0)
RORRP2 ;;4566009
"RTN","RORNTEG",110,0)
RORRP3 ;;3482249
"RTN","RORNTEG",111,0)
RORRP4 ;;5079227
"RTN","RORNTEG",112,0)
RORRP5 ;;1825009
"RTN","RORNTEG",113,0)
RORRP6 ;;3979336
"RTN","RORNTEG",114,0)
RORRP7 ;;4925487
"RTN","RORNTEG",115,0)
RORRP8 ;;3614530
"RTN","RORNTEG",116,0)
RORRP9 ;;8101985
"RTN","RORNTEG",117,0)
RORSET01 ;;4676823
"RTN","RORNTEG",118,0)
RORSETU1 ;;2833894
"RTN","RORNTEG",119,0)
RORSETU2 ;;2901879
"RTN","RORNTEG",120,0)
RORTSITE ;;4570058
"RTN","RORNTEG",121,0)
RORTSK ;;3791239
"RTN","RORNTEG",122,0)
RORTSK01 ;;7060222
"RTN","RORNTEG",123,0)
RORTSK02 ;;4617240
"RTN","RORNTEG",124,0)
RORTSK03 ;;2086919
"RTN","RORNTEG",125,0)
RORTSK10 ;;5534300
"RTN","RORNTEG",126,0)
RORTSK11 ;;3125173
"RTN","RORNTEG",127,0)
RORTXT ;;141117
"RTN","RORNTEG",128,0)
RORUPD ;;3654485
"RTN","RORNTEG",129,0)
RORUPD01 ;;7989261
"RTN","RORNTEG",130,0)
RORUPD04 ;;5153157
"RTN","RORNTEG",131,0)
RORUPD05 ;;7326307
"RTN","RORNTEG",132,0)
RORUPD06 ;;3084967
"RTN","RORNTEG",133,0)
RORUPD07 ;;2080523
"RTN","RORNTEG",134,0)
RORUPD08 ;;3835247
"RTN","RORNTEG",135,0)
RORUPD09 ;;2534692
"RTN","RORNTEG",136,0)
RORUPD50 ;;3446977
"RTN","RORNTEG",137,0)
RORUPD51 ;;6373941
"RTN","RORNTEG",138,0)
RORUPD52 ;;2583157
"RTN","RORNTEG",139,0)
RORUPDUT ;;7040706
"RTN","RORNTEG",140,0)
RORUPEX ;;3382608
"RTN","RORNTEG",141,0)
RORUPP01 ;;3620688
"RTN","RORNTEG",142,0)
RORUPP02 ;;3149282
"RTN","RORNTEG",143,0)
RORUPR ;;5403597
"RTN","RORNTEG",144,0)
RORUPR1 ;;10865390
"RTN","RORNTEG",145,0)
RORUTL01 ;;4698317
"RTN","RORNTEG",146,0)
RORUTL02 ;;5461265
"RTN","RORNTEG",147,0)
RORUTL03 ;;8322358
"RTN","RORNTEG",148,0)
RORUTL04 ;;2076790
"RTN","RORNTEG",149,0)
RORUTL05 ;;6817092
"RTN","RORNTEG",150,0)
RORUTL06 ;;9119845
"RTN","RORNTEG",151,0)
RORUTL07 ;;2762456
"RTN","RORNTEG",152,0)
RORUTL08 ;;3052928
"RTN","RORNTEG",153,0)
RORUTL09 ;;1836557
"RTN","RORNTEG",154,0)
RORUTL10 ;;5738979
"RTN","RORNTEG",155,0)
RORUTL11 ;;942933
"RTN","RORNTEG",156,0)
RORUTL14 ;;1275115
"RTN","RORNTEG",157,0)
RORUTL15 ;;5565629
"RTN","RORNTEG",158,0)
RORUTL16 ;;1877801
"RTN","RORNTEG",159,0)
RORUTL17 ;;6970941
"RTN","RORNTEG",160,0)
RORVM001 ;;1220339
"RTN","RORNTEG",161,0)
RORX000 ;;2233772
"RTN","RORNTEG",162,0)
RORX001 ;;6923293
"RTN","RORNTEG",163,0)
RORX002 ;;3760280
"RTN","RORNTEG",164,0)
RORX003 ;;4952051
"RTN","RORNTEG",165,0)
RORX003A ;;6293120
"RTN","RORNTEG",166,0)
RORX004 ;;4970351
"RTN","RORNTEG",167,0)
RORX005 ;;2080717
"RTN","RORNTEG",168,0)
RORX005A ;;7139090
"RTN","RORNTEG0")
0^183^B4128249
"RTN","RORNTEG0",1,0)
RORNTEG0 ;ISC/XTSUMBLD KERNEL - Package checksum checker ; 1/30/04 11:42am
"RTN","RORNTEG0",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3,4,5**;May 14, 2002
"RTN","RORNTEG0",3,0)
 ;;7.3;3040130.113651
"RTN","RORNTEG0",4,0)
 S XT4="I 1",X=$T(+3) W !!,"Checksum routine created on ",$P(X,";",4)," by KERNEL V",$P(X,";",3),!
"RTN","RORNTEG0",5,0)
CONT F XT1=1:1 S XT2=$T(ROU+XT1) Q:XT2=""  S X=$P(XT2," ",1),XT3=$P(XT2,";",3) X XT4 I $T W !,X X ^%ZOSF("TEST") S:'$T XT3=0 X:XT3 ^%ZOSF("RSUM") W ?10,$S('XT3:"Routine not in UCI",XT3'=Y:"Calculated "_$C(7)_Y_", off by "_(Y-XT3),1:"ok")
"RTN","RORNTEG0",6,0)
 ;
"RTN","RORNTEG0",7,0)
 K %1,%2,%3,X,Y,XT1,XT2,XT3,XT4 Q
"RTN","RORNTEG0",8,0)
ONE S XT4="I $D(^UTILITY($J,X))",X=$T(+3) W !!,"Checksum routine created on ",$P(X,";",4)," by KERNEL V",$P(X,";",3),!
"RTN","RORNTEG0",9,0)
 W !,"Check a subset of routines:" K ^UTILITY($J) X ^%ZOSF("RSEL")
"RTN","RORNTEG0",10,0)
 W ! G CONT
"RTN","RORNTEG0",11,0)
ROU ;;
"RTN","RORNTEG0",12,0)
RORX005B ;;6769514
"RTN","RORNTEG0",13,0)
RORX005C ;;11147808
"RTN","RORNTEG0",14,0)
RORX005U ;;266710
"RTN","RORNTEG0",15,0)
RORX006 ;;1929501
"RTN","RORNTEG0",16,0)
RORX006A ;;5949892
"RTN","RORNTEG0",17,0)
RORX006C ;;4940545
"RTN","RORNTEG0",18,0)
RORX007 ;;7810802
"RTN","RORNTEG0",19,0)
RORX007A ;;2762724
"RTN","RORNTEG0",20,0)
RORX008 ;;1936486
"RTN","RORNTEG0",21,0)
RORX008A ;;6748545
"RTN","RORNTEG0",22,0)
RORX009 ;;2635430
"RTN","RORNTEG0",23,0)
RORX009A ;;6814376
"RTN","RORNTEG0",24,0)
RORX009C ;;7407361
"RTN","RORNTEG0",25,0)
RORX010 ;;5947630
"RTN","RORNTEG0",26,0)
RORX011 ;;6937846
"RTN","RORNTEG0",27,0)
RORX012 ;;2280944
"RTN","RORNTEG0",28,0)
RORX012A ;;6424353
"RTN","RORNTEG0",29,0)
RORX013 ;;1826953
"RTN","RORNTEG0",30,0)
RORX013A ;;7197965
"RTN","RORNTEG0",31,0)
RORX013C ;;3062651
"RTN","RORNTEG0",32,0)
RORX014 ;;1995239
"RTN","RORNTEG0",33,0)
RORX014A ;;6019953
"RTN","RORNTEG0",34,0)
RORXU001 ;;2415732
"RTN","RORNTEG0",35,0)
RORXU002 ;;7009537
"RTN","RORNTEG0",36,0)
RORXU003 ;;5395052
"RTN","RORNTEG0",37,0)
RORXU004 ;;405249
"RTN","RORNTEG0",38,0)
RORXU005 ;;2334516
"RTN","RORNTEG0",39,0)
RORXU006 ;;4584240
"RTN","RORNTEG0",40,0)
RORXU007 ;;5726275
"RTN","RORP005")
0^35^B63504061
"RTN","RORP005",1,0)
RORP005 ;HCIOFO/SG - PATCH INSTALLATION ROUTINE (ROR*1.0*5) ; 1/23/04 3:04pm
"RTN","RORP005",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORP005",3,0)
 ;
"RTN","RORP005",4,0)
 ;***** ENVIRONMENT CHECK
"RTN","RORP005",5,0)
 N TMP
"RTN","RORP005",6,0)
 I $G(DUZ)'>0  D  S XPDABORT=2  Q
"RTN","RORP005",7,0)
 . W !!,"The DUZ variable must be defined!",!
"RTN","RORP005",8,0)
 ;--- Check the security keys
"RTN","RORP005",9,0)
 I '$D(^XUSEC("IMRA",DUZ))!'$D(^XUSEC("ROR VA IRM",DUZ))  D  Q
"RTN","RORP005",10,0)
 . W !!,"You must have both IMRA and ROR VA IRM security keys!",!
"RTN","RORP005",11,0)
 . S XPDABORT=2
"RTN","RORP005",12,0)
 ;--- Check if at least one of the patches is installed
"RTN","RORP005",13,0)
 S TMP=0
"RTN","RORP005",14,0)
 S:$$PATCH^XPDUTL("MD*1.0*1") TMP=TMP+1
"RTN","RORP005",15,0)
 S:$$PATCH^XPDUTL("MC*2.3*34") TMP=TMP+1
"RTN","RORP005",16,0)
 I 'TMP  D  S XPDABORT=2  Q
"RTN","RORP005",17,0)
 . W !!,"At least one of the following patches must be installed",!
"RTN","RORP005",18,0)
 . W "before installation of this patch: MD*1.0*1 or MC*2.3*34!",!
"RTN","RORP005",19,0)
 ;
"RTN","RORP005",20,0)
 ;--- Installation section
"RTN","RORP005",21,0)
 Q:'$G(XPDENV)
"RTN","RORP005",22,0)
 ;--- Check the scheduled option
"RTN","RORP005",23,0)
 Q:$$CHKOPT^RORKIDS("ROR TASK")<0
"RTN","RORP005",24,0)
 ;--- Idle the event protocols
"RTN","RORP005",25,0)
 K ^ROR(798.1,"AEP")
"RTN","RORP005",26,0)
 Q
"RTN","RORP005",27,0)
 ;
"RTN","RORP005",28,0)
 ;***** GENERATES THE TEXT OF SETUP CONFIRMATION REQUEST
"RTN","RORP005",29,0)
CONFTXT ;
"RTN","RORP005",30,0)
 N SUSP,TMP
"RTN","RORP005",31,0)
 S DIR("A",1)=""
"RTN","RORP005",32,0)
 S DIR("A",2)="  ============================================="
"RTN","RORP005",33,0)
 S TMP=+$G(XPDQUES("POS10 MAXNTSK")),TMP=$S(TMP>0:TMP,1:1)
"RTN","RORP005",34,0)
 S DIR("A",3)="  Number of registry update (sub)tasks... "_TMP
"RTN","RORP005",35,0)
 S TMP=$S($G(XPDQUES("POS15 SUSPEND")):"Yes",1:"No")
"RTN","RORP005",36,0)
 S DIR("A",4)="  Suspend the tasks during peak hours.... "_TMP
"RTN","RORP005",37,0)
 D:$G(XPDQUES("POS15 SUSPEND"))
"RTN","RORP005",38,0)
 . S SUSP=$$SUSP()
"RTN","RORP005",39,0)
 . S TMP=$P($$FMTE^XLFDT(DT+$P(SUSP,U,1),"F"),"@",2)
"RTN","RORP005",40,0)
 . S DIR("A",5)="  Suspend the tasks at................... "_TMP
"RTN","RORP005",41,0)
 . S TMP=$P($$FMTE^XLFDT(DT+$P(SUSP,U,2),"F"),"@",2)
"RTN","RORP005",42,0)
 . S DIR("A",6)="  Resume the tasks at.................... "_TMP
"RTN","RORP005",43,0)
 S TMP=$O(DIR("A",""),-1)+1
"RTN","RORP005",44,0)
 S DIR("A",TMP)="  ============================================="
"RTN","RORP005",45,0)
 S DIR("A",TMP+1)=""
"RTN","RORP005",46,0)
 Q
"RTN","RORP005",47,0)
 ;
"RTN","RORP005",48,0)
 ;***** REMOVES ITEMS FROM THE 'DRUG THERAPY LIST' OF THE 'VA HEPC'
"RTN","RORP005",49,0)
 ;
"RTN","RORP005",50,0)
 ; [RORREG]      Reserved
"RTN","RORP005",51,0)
 ;
"RTN","RORP005",52,0)
 ; Return Values:
"RTN","RORP005",53,0)
 ;       <0  Error code
"RTN","RORP005",54,0)
 ;        0  Ok
"RTN","RORP005",55,0)
 ;
"RTN","RORP005",56,0)
DRUGREM(RORREG) ;
"RTN","RORP005",57,0)
 N REGIEN
"RTN","RORP005",58,0)
 ;--- Get the HEP C registry IEN
"RTN","RORP005",59,0)
 S REGIEN=+$$REGIEN^RORUTL02("VA HEPC")
"RTN","RORP005",60,0)
 Q:REGIEN'>0 REGIEN
"RTN","RORP005",61,0)
 ;--- Remove the drugs
"RTN","RORP005",62,0)
 Q $$DRUGREM^RORPUT01(REGIEN_U_"VA HEPC","REMDRG^RORP005")
"RTN","RORP005",63,0)
 ;
"RTN","RORP005",64,0)
 ;***** ERROR PROCESSING
"RTN","RORP005",65,0)
ERROR ;
"RTN","RORP005",66,0)
 N TMP  S XPDABORT=1
"RTN","RORP005",67,0)
 I $D(ZTQUEUED)  D  D ALERT^RORKIDS(DUZ,-43,REGNAME,,TMP)
"RTN","RORP005",68,0)
 . S TMP=+$G(RORPARM("KIDS"))
"RTN","RORP005",69,0)
 . S TMP=$S(TMP=1:"pre-",TMP=2:"post-",1:"")_"install"
"RTN","RORP005",70,0)
 D DSPSTK^RORERR(),ABTMSG^RORKIDS()
"RTN","RORP005",71,0)
 Q
"RTN","RORP005",72,0)
 ;
"RTN","RORP005",73,0)
 ;***** POST-INSTALL ENTRY POINT
"RTN","RORP005",74,0)
POS ;
"RTN","RORP005",75,0)
 N RORERROR      ; Error processing data
"RTN","RORP005",76,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORP005",77,0)
 N RORPARM       ; Application parameters
"RTN","RORP005",78,0)
 ;
"RTN","RORP005",79,0)
 N RC,REGIEN,REGNAME,RORPRD,TMP
"RTN","RORP005",80,0)
 S RORPARM("DEVELOPER")=1   ; Enable modifications
"RTN","RORP005",81,0)
 S RORPARM("ERR")=1         ; Enable error processing
"RTN","RORP005",82,0)
 S RORPARM("KIDS")=2        ; Post-install indicator
"RTN","RORP005",83,0)
 S RORPARM("LOG")=1         ; Enable error recording
"RTN","RORP005",84,0)
 ;
"RTN","RORP005",85,0)
 S REGNAME="VA ICR"         ; Registry Name
"RTN","RORP005",86,0)
 S RORPRD="1.1^ROR*1*5"     ; Package Revision Data
"RTN","RORP005",87,0)
 ;
"RTN","RORP005",88,0)
 ;--- Re-enable the event protocols (idled by the environment check)
"RTN","RORP005",89,0)
 D
"RTN","RORP005",90,0)
 . N DA,DIK
"RTN","RORP005",91,0)
 . S DIK="^ROR(798.1,",DIK(1)="25^AEP"
"RTN","RORP005",92,0)
 . D ENALL^DIK
"RTN","RORP005",93,0)
 ;
"RTN","RORP005",94,0)
 ;--- Update package revision data for some files
"RTN","RORP005",95,0)
 D PRD^RORKIDS(798.3,RORPRD)   ; ROR PENDING PATIENT
"RTN","RORP005",96,0)
 D PRD^RORKIDS(799.1,RORPRD)   ; ROR LIST ITEM
"RTN","RORP005",97,0)
 D PRD^RORKIDS(799.51,RORPRD)  ; ROR GENERIC DRUG
"RTN","RORP005",98,0)
 ;
"RTN","RORP005",99,0)
 ;--- IEN of the registry
"RTN","RORP005",100,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)  G:REGIEN<0 ERROR
"RTN","RORP005",101,0)
 S RORPARM("KIDS","RORREG")=REGIEN_U_REGNAME
"RTN","RORP005",102,0)
 ;
"RTN","RORP005",103,0)
 ;--- Open a new log
"RTN","RORP005",104,0)
 S TMP=$$OPEN^RORLOG(REGNAME,0,XPDNM_" POST-INSTALL STARTED")
"RTN","RORP005",105,0)
 ;
"RTN","RORP005",106,0)
 ;--- Update the ROR LOCAL REGISTRY file
"RTN","RORP005",107,0)
 I $$PRD^RORKIDS(798)<RORPRD  D  G:RC<0 ERROR
"RTN","RORP005",108,0)
 . ;--- Re-index the new "ARD" index, which replaces the "AD"
"RTN","RORP005",109,0)
 . ;--- cross-reference, and delete the old cross-reference
"RTN","RORP005",110,0)
 . S RC=$$CP^RORKIDS("POS05","$$XREFS^RORP005B")   Q:RC<0
"RTN","RORP005",111,0)
 . ;--- Update the package revision data
"RTN","RORP005",112,0)
 . D PRD^RORKIDS(798,RORPRD)
"RTN","RORP005",113,0)
 ;
"RTN","RORP005",114,0)
 ;--- Update the ROR REGISTRY PARAMETERS file
"RTN","RORP005",115,0)
 I $$PRD^RORKIDS(798.1)<RORPRD  D  G:RC<0 ERROR
"RTN","RORP005",116,0)
 . ;--- Update the HEPC parameters
"RTN","RORP005",117,0)
 . S RC=$$CP^RORKIDS("POS10","$$HEPC^RORP005B")    Q:RC<0
"RTN","RORP005",118,0)
 . ;--- Update the ICR parameters
"RTN","RORP005",119,0)
 . S RC=$$CP^RORKIDS("POS15","$$REGPARM^RORP005B")  Q:RC<0
"RTN","RORP005",120,0)
 . ;--- Update the package revision data
"RTN","RORP005",121,0)
 . D PRD^RORKIDS(798.1,RORPRD)
"RTN","RORP005",122,0)
 ;
"RTN","RORP005",123,0)
 ;--- Restore the CDC definition
"RTN","RORP005",124,0)
 G:$$CP^RORKIDS("POS17","$$CDCDEF^RORP005B")<0 ERROR
"RTN","RORP005",125,0)
 ;
"RTN","RORP005",126,0)
 ;--- Update the DRUG THERAPY LIST multiple for VA HEPC
"RTN","RORP005",127,0)
 G:$$CP^RORKIDS("POS20","$$DRUGREM^RORP005")<0 ERROR
"RTN","RORP005",128,0)
 ;
"RTN","RORP005",129,0)
 ;--- Update the ROR PHARMACY CODE file
"RTN","RORP005",130,0)
 G:$$CP^RORKIDS("POS25","$$IDRUG^RORP005B")<0 ERROR
"RTN","RORP005",131,0)
 ;
"RTN","RORP005",132,0)
 ;--- Convert the Lab Test mapping (from the LAB GROUP NAME multiple
"RTN","RORP005",133,0)
 ;    of the ICR SITE PARAMETERS file) if the LOCAL TEST NAME
"RTN","RORP005",134,0)
 ;--- multiple of the ROR REGISTRY PARAMETERS file is empty
"RTN","RORP005",135,0)
 S TMP=$$ROOT^DILFD(798.128,","_REGIEN_",",1)
"RTN","RORP005",136,0)
 I $O(@TMP@(0))'>0  D  G:RC<0 ERROR
"RTN","RORP005",137,0)
 . S RC=$$CP^RORKIDS("POS30","$$LABMAP^RORP005B")
"RTN","RORP005",138,0)
 ;
"RTN","RORP005",139,0)
 ;--- Schedule the setup task (if necessary)
"RTN","RORP005",140,0)
 D:$G(XPDQUES("POS05 SETUP"))
"RTN","RORP005",141,0)
 . N I,INFO,ZTCPU,ZTDESC,ZTDTH,ZTIO,ZTKIL,ZTPRI,ZTRTN,ZTSAVE
"RTN","RORP005",142,0)
 . N ZTSK,ZTSYNC,ZTUCI
"RTN","RORP005",143,0)
 . S ZTSAVE("RORMNTSK")=+$G(XPDQUES("POS10 MAXNTSK"))
"RTN","RORP005",144,0)
 . S ZTSAVE("RORREG")=REGIEN_U_REGNAME
"RTN","RORP005",145,0)
 . ;--- Suspension parameters
"RTN","RORP005",146,0)
 . S:$G(XPDQUES("POS15 SUSPEND")) ZTSAVE("RORSUSP")=$$SUSP()
"RTN","RORP005",147,0)
 . ;--- If the task suspension is requested then schedule
"RTN","RORP005",148,0)
 . ;    the task to run at the 'suspension end' time today.
"RTN","RORP005",149,0)
 . ;--- Otherwise, it will start after 10 minutes.
"RTN","RORP005",150,0)
 . S ZTDTH=$$FMADD^XLFDT($$NOW^XLFDT,,,10)
"RTN","RORP005",151,0)
 . S TMP=$$DT^XLFDT_$P($G(ZTSAVE("RORSUSP")),U,2)
"RTN","RORP005",152,0)
 . S:TMP>ZTDTH ZTDTH=TMP
"RTN","RORP005",153,0)
 . ;---
"RTN","RORP005",154,0)
 . S ZTRTN="TASK^RORSET01",ZTIO=""
"RTN","RORP005",155,0)
 . S ZTDESC="Registry setup ("_REGNAME_")"
"RTN","RORP005",156,0)
 . D ^%ZTLOAD
"RTN","RORP005",157,0)
 . ;---
"RTN","RORP005",158,0)
SCHERR . I '$G(ZTSK)  D
"RTN","RORP005",159,0)
 . . ;;The registry setup task has NOT been scheduled due to an error.
"RTN","RORP005",160,0)
 . . ;;Please, use the Registry Setup option [ROR SETUP]
"RTN","RORP005",161,0)
 . . ;;to schedule the task after the installation.
"RTN","RORP005",162,0)
 . . ;---
"RTN","RORP005",163,0)
 . . S TMP=$P($T(SCHERR+1),";;",2)
"RTN","RORP005",164,0)
 . . F I=2:1:3  S INFO(I-1)=$P($T(SCHERR+I),";;",2)
"RTN","RORP005",165,0)
 . E  S TMP="The registry setup task #"_ZTSK_" has been scheduled."
"RTN","RORP005",166,0)
 . D BMES^RORKIDS(TMP,.INFO)
"RTN","RORP005",167,0)
 ;
"RTN","RORP005",168,0)
 ;--- Close the log
"RTN","RORP005",169,0)
 D CLOSE^RORLOG(XPDNM_" POST-INSTALL COMPLETED")
"RTN","RORP005",170,0)
 Q
"RTN","RORP005",171,0)
 ;
"RTN","RORP005",172,0)
 ;***** PRE-INSTALL ENTRY POINT
"RTN","RORP005",173,0)
PRE ;
"RTN","RORP005",174,0)
 N RORERROR      ; Error processing data
"RTN","RORP005",175,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORP005",176,0)
 N RORPARM       ; Application parameters
"RTN","RORP005",177,0)
 ;
"RTN","RORP005",178,0)
 N RC,REGIEN,REGNAME,RORPRD,TMP
"RTN","RORP005",179,0)
 S RORPARM("DEVELOPER")=1   ; Enable modifications
"RTN","RORP005",180,0)
 S RORPARM("ERR")=1         ; Enable error processing
"RTN","RORP005",181,0)
 S RORPARM("KIDS")=1        ; Pre-install indicator
"RTN","RORP005",182,0)
 ;
"RTN","RORP005",183,0)
 S REGNAME="VA ICR"         ; Registry Name
"RTN","RORP005",184,0)
 S RORPRD="1.1^ROR*1*5"     ; Package Revision Data
"RTN","RORP005",185,0)
 ;
"RTN","RORP005",186,0)
 ;--- Delete the old ROR GENERIC DRUG file at test sites
"RTN","RORP005",187,0)
 D:$$PRD^RORKIDS(799.51)<RORPRD DELFILE^RORKIDS(799.51,"D")
"RTN","RORP005",188,0)
 ;
"RTN","RORP005",189,0)
 ;--- Delete the subfile DD's, which will be updated by the patch
"RTN","RORP005",190,0)
 D:$$PRD^RORKIDS(798.1)<RORPRD DELFILE^RORKIDS(798.19,"DS")
"RTN","RORP005",191,0)
 D:$$PRD^RORKIDS(798.3)<RORPRD DELFILE^RORKIDS(798.32,"S")
"RTN","RORP005",192,0)
 ;
"RTN","RORP005",193,0)
 ;--- IEN of the registry (when the patch is re-installed)
"RTN","RORP005",194,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORP005",195,0)
 Q:REGIEN'>0
"RTN","RORP005",196,0)
 ;
"RTN","RORP005",197,0)
 ;--- Delete the old ICR reasons and evidences at test sites
"RTN","RORP005",198,0)
 D:$$PRD^RORKIDS(799.1)<RORPRD
"RTN","RORP005",199,0)
 . N CODE,DA,DIK,IEN,NODE
"RTN","RORP005",200,0)
 . S DIK="^ROR(799.1,"
"RTN","RORP005",201,0)
 . F CODE="4^1","1^2","2^2"  D
"RTN","RORP005",202,0)
 . . S NODE=$NA(^ROR(799.1,"KEY",+$P(CODE,U,2),REGIEN,+CODE))
"RTN","RORP005",203,0)
 . . S IEN=""
"RTN","RORP005",204,0)
 . . F  S IEN=$O(@NODE@(IEN))  Q:IEN=""  S DA=IEN  D ^DIK
"RTN","RORP005",205,0)
 Q
"RTN","RORP005",206,0)
 ;
"RTN","RORP005",207,0)
 ;***** PRE-TRANSPORTATION ENTRY POINT
"RTN","RORP005",208,0)
PTR ;
"RTN","RORP005",209,0)
 N IEN,NODE,RC,RORBUF,TMP
"RTN","RORP005",210,0)
 ;--- Copy the CDC definition to the transport global
"RTN","RORP005",211,0)
 D GETPARM^RORRP012(.RORBUF,"ICRCDCDEF","PKG")
"RTN","RORP005",212,0)
 K RORBUF(0)  M @XPDGREF@("RORCDCDEF")=RORBUF
"RTN","RORP005",213,0)
 ;--- Load the HL7 SEGMENT multiple of the VA HEPC
"RTN","RORP005",214,0)
 S IEN=+$$REGIEN^RORUTL02("VA HEPC")
"RTN","RORP005",215,0)
 S NODE=$$ROOT^DILFD(798.19,","_IEN_",",1)
"RTN","RORP005",216,0)
 S IEN=0
"RTN","RORP005",217,0)
 F  S IEN=$O(@NODE@(IEN))  Q:IEN'>0  D
"RTN","RORP005",218,0)
 . S TMP=$G(@NODE@(IEN,0))
"RTN","RORP005",219,0)
 . S:$P(TMP,U,3)&($P(TMP,U)'="") @XPDGREF@("RORHL7SEG",IEN)=TMP
"RTN","RORP005",220,0)
 Q
"RTN","RORP005",221,0)
 ;
"RTN","RORP005",222,0)
 ;***** CALCULATES AND RETURNS THE SUSPENSION TIME FRAME
"RTN","RORP005",223,0)
SUSP() ;
"RTN","RORP005",224,0)
 N SUSP,TMP
"RTN","RORP005",225,0)
 S TMP=$G(XPDQUES("POS20 SUSPEND BEGIN"))#1
"RTN","RORP005",226,0)
 S SUSP=$S(TMP>0:TMP,1:.06)               ; 06:00
"RTN","RORP005",227,0)
 S TMP=$G(XPDQUES("POS25 SUSPEND END"))#1
"RTN","RORP005",228,0)
 S:TMP'>0 TMP=.2                          ;       20:00
"RTN","RORP005",229,0)
 S $P(SUSP,U,2)=TMP
"RTN","RORP005",230,0)
 S:TMP'>SUSP SUSP=".06^.2"                ; 06:00-20:00
"RTN","RORP005",231,0)
 Q SUSP
"RTN","RORP005",232,0)
 ;
"RTN","RORP005",233,0)
 ;***** LIST OF DRUG CODES TO REMOVE
"RTN","RORP005",234,0)
REMDRG ;
"RTN","RORP005",235,0)
 ;; 000004198809, 000004199309, 000004200509, 000004200709
"RTN","RORP005",236,0)
 ;; 000004201009, 000004201109, 000004201209, 000004201607
"RTN","RORP005",237,0)
 ;; 000004201609, 000004201707, 000004201709, 000004690033
"RTN","RORP005",238,0)
 ;; 000085012002, 000085012003, 000085012004, 000085028502
"RTN","RORP005",239,0)
 ;; 000085053901, 000085057102, 000085057106, 000085068901
"RTN","RORP005",240,0)
 ;; 000085076901, 000085092301, 000085095301, 000085111001
"RTN","RORP005",241,0)
 ;; 000085113301, 000085116801, 000085117901, 000085117902
"RTN","RORP005",242,0)
 ;; 000085119101, 000085119102
"RTN","RORP005B")
0^54^B43947159
"RTN","RORP005B",1,0)
RORP005B ;HCIOFO/SG - PATCH INSTALLATION UTILITIES (ROR*1.0*5) ; 1/23/04 3:07pm
"RTN","RORP005B",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORP005B",3,0)
 ;
"RTN","RORP005B",4,0)
 Q
"RTN","RORP005B",5,0)
 ;
"RTN","RORP005B",6,0)
 ;***** RESTORES THE CDC DEFINITION
"RTN","RORP005B",7,0)
 ;
"RTN","RORP005B",8,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORP005B",9,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORP005B",10,0)
 ;
"RTN","RORP005B",11,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORP005B",12,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORP005B",13,0)
 ; sub-nodes of the same name.
"RTN","RORP005B",14,0)
 ;
"RTN","RORP005B",15,0)
 ; Return Values:
"RTN","RORP005B",16,0)
 ;       <0  Error code
"RTN","RORP005B",17,0)
 ;        0  Ok
"RTN","RORP005B",18,0)
 ;
"RTN","RORP005B",19,0)
CDCDEF(RORREG) ;
"RTN","RORP005B",20,0)
 N RC,RESULTS,RORBUF
"RTN","RORP005B",21,0)
 D BMES^RORKIDS("Restoring the CDC definition...")
"RTN","RORP005B",22,0)
 ;--- Restore the definition from the transport global
"RTN","RORP005B",23,0)
 M RORBUF=@XPDGREF@("RORCDCDEF")
"RTN","RORP005B",24,0)
 D SETPARM^RORRP012(.RESULTS,"ICRCDCDEF","PKG",.RORBUF)
"RTN","RORP005B",25,0)
 Q:$G(RESULTS(0))<0 +RESULTS(0)
"RTN","RORP005B",26,0)
 ;--- Success
"RTN","RORP005B",27,0)
 D MES^RORKIDS("The definition has been restored successfully.")
"RTN","RORP005B",28,0)
 Q 0
"RTN","RORP005B",29,0)
 ;
"RTN","RORP005B",30,0)
 ;***** UPDATES THE HEPC REGISTRY PARAMETERS
"RTN","RORP005B",31,0)
 ;
"RTN","RORP005B",32,0)
 ; [RORREG]      Reserved
"RTN","RORP005B",33,0)
 ;
"RTN","RORP005B",34,0)
 ; Return Values:
"RTN","RORP005B",35,0)
 ;       <0  Error code
"RTN","RORP005B",36,0)
 ;        0  Ok
"RTN","RORP005B",37,0)
 ;
"RTN","RORP005B",38,0)
HEPC(RORREG) ;
"RTN","RORP005B",39,0)
 N IT,IENS,RC,REGIEN,RORFDA,RORMSG,TMP
"RTN","RORP005B",40,0)
 D BMES^RORKIDS("Updating HepC registry parameters...")
"RTN","RORP005B",41,0)
 ;--- Get the HEP C registry IEN
"RTN","RORP005B",42,0)
 S REGIEN=+$$REGIEN^RORUTL02("VA HEPC")
"RTN","RORP005B",43,0)
 Q:REGIEN'>0 REGIEN
"RTN","RORP005B",44,0)
 ;--- Update some registry parameters
"RTN","RORP005B",45,0)
 S IENS=REGIEN_","
"RTN","RORP005B",46,0)
 S RORFDA(798.1,IENS,4)="Hepatitis C Registry"
"RTN","RORP005B",47,0)
 S RORFDA(798.1,IENS,13.2)=2
"RTN","RORP005B",48,0)
 S RORFDA(798.1,IENS,13.3)="CCRAutoNotification@med.va.gov"
"RTN","RORP005B",49,0)
 ;--- Prepare content for the HL7 SEGMENT multiple
"RTN","RORP005B",50,0)
 S IT=0
"RTN","RORP005B",51,0)
 F  S IT=$O(@XPDGREF@("RORHL7SEG",IT))  Q:IT'>0  D
"RTN","RORP005B",52,0)
 . S TMP=@XPDGREF@("RORHL7SEG",IT)
"RTN","RORP005B",53,0)
 . S IENS="?+"_IT_","_REGIEN_","
"RTN","RORP005B",54,0)
 . S RORFDA(798.19,IENS,.01)=$P(TMP,U,1)
"RTN","RORP005B",55,0)
 . S RORFDA(798.19,IENS,.02)=$P(TMP,U,3)
"RTN","RORP005B",56,0)
 ;--- Update the registry parameters
"RTN","RORP005B",57,0)
 D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORP005B",58,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.1)
"RTN","RORP005B",59,0)
 ;--- Success
"RTN","RORP005B",60,0)
 D MES^RORKIDS("The parameters have been updated successfully.")
"RTN","RORP005B",61,0)
 Q 0
"RTN","RORP005B",62,0)
 ;
"RTN","RORP005B",63,0)
 ;***** SETS THE POINTER TO THE INVESTIGATIONAL DRUG CLASS IN150
"RTN","RORP005B",64,0)
 ;
"RTN","RORP005B",65,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORP005B",66,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORP005B",67,0)
 ;
"RTN","RORP005B",68,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORP005B",69,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORP005B",70,0)
 ; sub-nodes of the same name.
"RTN","RORP005B",71,0)
 ;
"RTN","RORP005B",72,0)
 ; Return Values:
"RTN","RORP005B",73,0)
 ;       <0  Error code
"RTN","RORP005B",74,0)
 ;        0  Ok
"RTN","RORP005B",75,0)
 ;
"RTN","RORP005B",76,0)
IDRUG(RORREG) ;
"RTN","RORP005B",77,0)
 N IENS,K4,RC,RORFDA,RORMSG
"RTN","RORP005B",78,0)
 D BMES^RORKIDS("Updating the ROR PHARMACY CODE file...")
"RTN","RORP005B",79,0)
 ;--- Get the registry
"RTN","RORP005B",80,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORP005B",81,0)
 ;--- IN150
"RTN","RORP005B",82,0)
 S K4=$O(^PS(50.605,"B","IN150",""))
"RTN","RORP005B",83,0)
 Q:'K4 $$ERROR^RORERR(-47,,,,"IN150")
"RTN","RORP005B",84,0)
 ;--- Create the record
"RTN","RORP005B",85,0)
 S IENS="?+1,"
"RTN","RORP005B",86,0)
 S RORFDA(798.6,IENS,.01)=K4
"RTN","RORP005B",87,0)
 S RORFDA(798.6,IENS,.02)=+RORREG
"RTN","RORP005B",88,0)
 D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORP005B",89,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.6)
"RTN","RORP005B",90,0)
 ;--- Success
"RTN","RORP005B",91,0)
 D MES^RORKIDS("The file has been updated successfully.")
"RTN","RORP005B",92,0)
 Q 0
"RTN","RORP005B",93,0)
 ;
"RTN","RORP005B",94,0)
 ;***** CONVERTS THE LOCAL LAB TEST MAPPING
"RTN","RORP005B",95,0)
 ;
"RTN","RORP005B",96,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORP005B",97,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORP005B",98,0)
 ;
"RTN","RORP005B",99,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORP005B",100,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORP005B",101,0)
 ; sub-nodes of the same name.
"RTN","RORP005B",102,0)
 ;
"RTN","RORP005B",103,0)
 ; Return Values:
"RTN","RORP005B",104,0)
 ;       <0  Error code
"RTN","RORP005B",105,0)
 ;        0  Ok
"RTN","RORP005B",106,0)
 ;
"RTN","RORP005B",107,0)
LABMAP(RORREG) ;
"RTN","RORP005B",108,0)
 N RORDONE       ; List of already processed tests
"RTN","RORP005B",109,0)
 ;
"RTN","RORP005B",110,0)
 N CD4,CD4P,RC,REGIEN,RORBUF,TMP,VL
"RTN","RORP005B",111,0)
 D BMES^RORKIDS("Converting the mapping of local lab tests...")
"RTN","RORP005B",112,0)
 ;--- Get the registry
"RTN","RORP005B",113,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORP005B",114,0)
 S REGIEN=+RORREG
"RTN","RORP005B",115,0)
 ;--- Get the IENs of new Lab Groups
"RTN","RORP005B",116,0)
 S RC=$$ITEMLIST^RORUTL09(3,REGIEN,.RORBUF)  Q:RC<0 RC
"RTN","RORP005B",117,0)
 S CD4=+$G(RORBUF(1)),CD4P=+$G(RORBUF(2)),VL=+$G(RORBUF(3))
"RTN","RORP005B",118,0)
 K RORBUF
"RTN","RORP005B",119,0)
 ;--- Convert the mapping
"RTN","RORP005B",120,0)
 S RC=$$LTCONV(REGIEN,CD4,"CD4","CD4 COUNT (ABSOLUTE)")  Q:RC<0 RC
"RTN","RORP005B",121,0)
 S RC=$$LTCONV(REGIEN,CD4P,"CD4","CD4 PERCENT")          Q:RC<0 RC
"RTN","RORP005B",122,0)
 S RC=$$LTCONV(REGIEN,VL,"VIRAL LOAD")                   Q:RC<0 RC
"RTN","RORP005B",123,0)
 ;--- Success
"RTN","RORP005B",124,0)
 D MES^RORKIDS("The conversion has been completed successfully.")
"RTN","RORP005B",125,0)
 Q 0
"RTN","RORP005B",126,0)
 ;
"RTN","RORP005B",127,0)
 ;***** CONVERTS THE TESTS OF THE PRVIDED GROUP AND TYPE(S)
"RTN","RORP005B",128,0)
 ;
"RTN","RORP005B",129,0)
 ; REGIEN        Registry IEN
"RTN","RORP005B",130,0)
 ;
"RTN","RORP005B",131,0)
 ; NEWGRIEN      IEN of the new Lab Group (in the ROR LIST ITEM file)
"RTN","RORP005B",132,0)
 ;
"RTN","RORP005B",133,0)
 ; OLDGRP        Name of the old group of the Lab tests
"RTN","RORP005B",134,0)
 ;
"RTN","RORP005B",135,0)
 ; [OLDTYPE]     Name of the old test type. If this parameter is
"RTN","RORP005B",136,0)
 ;               undefined or has an empty value then tests of all
"RTN","RORP005B",137,0)
 ;               types are converted.
"RTN","RORP005B",138,0)
 ;
"RTN","RORP005B",139,0)
LTCONV(REGIEN,NEWGRIEN,OLDGRP,OLDTYPE) ;
"RTN","RORP005B",140,0)
 N CNT,GRPIENS,IEN,IENS,IRT,LTIEN,NODE,RC,RORFDA,RORLST,RORMSG,TMP
"RTN","RORP005B",141,0)
 S RC=0
"RTN","RORP005B",142,0)
 ;--- Find the group
"RTN","RORP005B",143,0)
 S IENS=",1,"
"RTN","RORP005B",144,0)
 S IEN=$$FIND1^DIC(158.93,IENS,"BX",OLDGRP,"B",,"RORMSG")
"RTN","RORP005B",145,0)
 I $G(DIERR)  D  Q RC
"RTN","RORP005B",146,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,158.93,IENS)
"RTN","RORP005B",147,0)
 ;--- Quit if the group has not been found
"RTN","RORP005B",148,0)
 I IEN'>0  D  Q 0
"RTN","RORP005B",149,0)
 . D MES^RORKIDS("No '"_OLDGRP_"' tests have been found.")
"RTN","RORP005B",150,0)
 S GRPIENS=","_IEN_IENS
"RTN","RORP005B",151,0)
 ;--- Find the Lab test type(s)
"RTN","RORP005B",152,0)
 I $G(OLDTYPE)'=""  D
"RTN","RORP005B",153,0)
 . D FIND^DIC(158.931,GRPIENS,"@","BX",OLDTYPE,,"B",,,"RORLST","RORMSG")
"RTN","RORP005B",154,0)
 E  D LIST^DIC(158.931,GRPIENS,"@",,,,,"B",,,"RORLST","RORMSG")
"RTN","RORP005B",155,0)
 I $G(DIERR)  D  Q RC
"RTN","RORP005B",156,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,158.931,GRPIENS)
"RTN","RORP005B",157,0)
 ;--- Quit if the test types have not been found
"RTN","RORP005B",158,0)
 I $G(RORLST("DILIST",0))'>0  D  Q 0
"RTN","RORP005B",159,0)
 . S TMP=$S($G(OLDTYPE)'="":OLDTYPE,1:OLDGRP)
"RTN","RORP005B",160,0)
 . D MES^RORKIDS("No '"_TMP_"' tests have been found.")
"RTN","RORP005B",161,0)
 ;--- Browse selected types
"RTN","RORP005B",162,0)
 S (CNT,IRT)=0
"RTN","RORP005B",163,0)
 F  S IRT=$O(RORLST("DILIST",2,IRT))  Q:IRT'>0  D
"RTN","RORP005B",164,0)
 . S IENS=","_RORLST("DILIST",2,IRT)_GRPIENS
"RTN","RORP005B",165,0)
 . S NODE=$$ROOT^DILFD(158.9311,IENS,1)
"RTN","RORP005B",166,0)
 . ;--- Convert the tests
"RTN","RORP005B",167,0)
 . S IEN=0
"RTN","RORP005B",168,0)
 . F  S IEN=$O(@NODE@(IEN))  Q:IEN'>0  D
"RTN","RORP005B",169,0)
 . . ;--- Get the Test IEN (in the file #60)
"RTN","RORP005B",170,0)
 . . S LTIEN=+$P($G(@NODE@(IEN,0)),U)  Q:LTIEN'>0
"RTN","RORP005B",171,0)
 . . ;--- Quit if the test has been processed already
"RTN","RORP005B",172,0)
 . . Q:$D(RORDONE(NEWGRIEN,LTIEN))
"RTN","RORP005B",173,0)
 . . ;--- Prepare the data
"RTN","RORP005B",174,0)
 . . S CNT=CNT+1,IENS="?+"_CNT_","_REGIEN_","
"RTN","RORP005B",175,0)
 . . S RORFDA(798.128,IENS,.01)=LTIEN
"RTN","RORP005B",176,0)
 . . S RORFDA(798.128,IENS,.02)=NEWGRIEN
"RTN","RORP005B",177,0)
 . . ;--- Store the reference to the processed test
"RTN","RORP005B",178,0)
 . . S RORDONE(NEWGRIEN,LTIEN)=""
"RTN","RORP005B",179,0)
 ;--- Update the multiple
"RTN","RORP005B",180,0)
 I $D(RORFDA)>1  D  Q:RC<0 RC
"RTN","RORP005B",181,0)
 . D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORP005B",182,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,798.128)
"RTN","RORP005B",183,0)
 Q 0
"RTN","RORP005B",184,0)
 ;
"RTN","RORP005B",185,0)
 ;***** UPDATES THE ICR REGISTRY PARAMETERS
"RTN","RORP005B",186,0)
 ;
"RTN","RORP005B",187,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORP005B",188,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORP005B",189,0)
 ;
"RTN","RORP005B",190,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORP005B",191,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORP005B",192,0)
 ; sub-nodes of the same name.
"RTN","RORP005B",193,0)
 ;
"RTN","RORP005B",194,0)
 ; Return Values:
"RTN","RORP005B",195,0)
 ;       <0  Error code
"RTN","RORP005B",196,0)
 ;        0  Ok
"RTN","RORP005B",197,0)
 ;
"RTN","RORP005B",198,0)
REGPARM(RORREG) ;
"RTN","RORP005B",199,0)
 N IENS,RC,RORFDA,RORMSG
"RTN","RORP005B",200,0)
 D BMES^RORKIDS("Updating the ICR registry parameters...")
"RTN","RORP005B",201,0)
 ;--- Get the registry
"RTN","RORP005B",202,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORP005B",203,0)
 S IENS=+RORREG_","
"RTN","RORP005B",204,0)
 ;--- Update some fields (mostly for the test sites)
"RTN","RORP005B",205,0)
 S RORFDA(798.1,IENS,6.2)="$$POSTUPD^RORICR03" ; AFTER UPDATE
"RTN","RORP005B",206,0)
 S RORFDA(798.1,IENS,13)="RORICR-SITE-DRIVER"  ; PROTOCOL
"RTN","RORP005B",207,0)
 S RORFDA(798.1,IENS,15.1)=7                   ; LAG DAYS
"RTN","RORP005B",208,0)
 S RORFDA(798.1,IENS,26)="NO"                  ; EXCLUDE EMPLOYEES
"RTN","RORP005B",209,0)
 D FILE^DIE("E","RORFDA","RORMSG")
"RTN","RORP005B",210,0)
 I $G(DIERR)>0  D  Q RC
"RTN","RORP005B",211,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","RORP005B",212,0)
 ;--- Success
"RTN","RORP005B",213,0)
 D MES^RORKIDS("The parameters have been updated successfully.")
"RTN","RORP005B",214,0)
 Q 0
"RTN","RORP005B",215,0)
 ;
"RTN","RORP005B",216,0)
 ;***** UPDATES THE CROSS-REFERENCES
"RTN","RORP005B",217,0)
 ;
"RTN","RORP005B",218,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORP005B",219,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORP005B",220,0)
 ;
"RTN","RORP005B",221,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORP005B",222,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORP005B",223,0)
 ; sub-nodes of the same name.
"RTN","RORP005B",224,0)
 ;
"RTN","RORP005B",225,0)
 ; Return Values:
"RTN","RORP005B",226,0)
 ;       <0  Error code
"RTN","RORP005B",227,0)
 ;        0  Ok
"RTN","RORP005B",228,0)
 ;
"RTN","RORP005B",229,0)
XREFS(RORREG) ;
"RTN","RORP005B",230,0)
 N DA,DIK
"RTN","RORP005B",231,0)
 D BMES^RORKIDS("Re-indexing new cross-references...")
"RTN","RORP005B",232,0)
 ;--- Reindex the "ARD" and "ANP" indexes
"RTN","RORP005B",233,0)
 S DIK=$$ROOT^DILFD(798),DIK(1)=".02^ARD^ANP"
"RTN","RORP005B",234,0)
 D ENALL^DIK
"RTN","RORP005B",235,0)
 ;--- Delete the "AD" cross-reference
"RTN","RORP005B",236,0)
 D DELIX^DDMOD(798,1,1,"K")
"RTN","RORP005B",237,0)
 ;--- Success
"RTN","RORP005B",238,0)
 D MES^RORKIDS("The cross-references have been rebuilt.")
"RTN","RORP005B",239,0)
 Q 0
"RTN","RORPUT01")
0^135^B36828175
"RTN","RORPUT01",1,0)
RORPUT01 ;HCIOFO/SG - EDIT LOINC AND DRUG CODE MULTIPLES ; 9/29/03 3:29pm
"RTN","RORPUT01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3,5**;May 14, 2002
"RTN","RORPUT01",3,0)
 ;
"RTN","RORPUT01",4,0)
 Q
"RTN","RORPUT01",5,0)
 ;
"RTN","RORPUT01",6,0)
 ;***** ADDS THE RECORDS TO THE MULTIPLE
"RTN","RORPUT01",7,0)
 ;
"RTN","RORPUT01",8,0)
 ; REGIEN        Registry IEN
"RTN","RORPUT01",9,0)
 ; SUBFILE       Subfile number
"RTN","RORPUT01",10,0)
 ; LSTREF        Reference to a list or the list itself (see the
"RTN","RORPUT01",11,0)
 ;               $$COMPNEXT^RORPUT01 function for more details).
"RTN","RORPUT01",12,0)
 ;
"RTN","RORPUT01",13,0)
 ; Return Values:
"RTN","RORPUT01",14,0)
 ;       <0  Error code
"RTN","RORPUT01",15,0)
 ;        0  Ok
"RTN","RORPUT01",16,0)
 ;
"RTN","RORPUT01",17,0)
ADD(REGIEN,SUBFILE,LSTREF) ;
"RTN","RORPUT01",18,0)
 N BUF,IENS,ITEM,LI,NEXT,RC,RORFDA,RORMSG,TLI
"RTN","RORPUT01",19,0)
 S NEXT=$$COMPNEXT(LSTREF)  Q:NEXT<0 NEXT
"RTN","RORPUT01",20,0)
 S IENS="?+1,"_(+REGIEN)_",",RC=0
"RTN","RORPUT01",21,0)
 F TLI=1:1  X NEXT  Q:$G(BUF)'[";;"  D  Q:RC<0
"RTN","RORPUT01",22,0)
 . S BUF=$P(BUF,";;",2)
"RTN","RORPUT01",23,0)
 . D MES^RORKIDS(BUF)
"RTN","RORPUT01",24,0)
 . S BUF=$TR(BUF," ")
"RTN","RORPUT01",25,0)
 . F LI=1:1  S ITEM=$P(BUF,",",LI)  Q:ITEM=""  D  Q:RC<0
"RTN","RORPUT01",26,0)
 . . S RORFDA(SUBFILE,IENS,.01)=ITEM
"RTN","RORPUT01",27,0)
 . . D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORPUT01",28,0)
 . . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,SUBFILE,IENS)
"RTN","RORPUT01",29,0)
 Q RC
"RTN","RORPUT01",30,0)
 ;
"RTN","RORPUT01",31,0)
 ;***** COMPILES THE 'NEXT' LOGIC
"RTN","RORPUT01",32,0)
 ;
"RTN","RORPUT01",33,0)
 ; PARAM         Parameter defining the list of codes. It should be
"RTN","RORPUT01",34,0)
 ;               either a list of codes separated by commas or a full
"RTN","RORPUT01",35,0)
 ;               reference (TAG^ROUTINE) to a routine label after
"RTN","RORPUT01",36,0)
 ;               which the list is located. In the latter case, the
"RTN","RORPUT01",37,0)
 ;               list itself should look like this:
"RTN","RORPUT01",38,0)
 ;
"RTN","RORPUT01",39,0)
 ;                         ;
"RTN","RORPUT01",40,0)
 ;                         ;***** SHORT DESCRIPTION OF THE LIST
"RTN","RORPUT01",41,0)
 ;                 LABEL   ;
"RTN","RORPUT01",42,0)
 ;                         ;;  Code1, Code2, ...
"RTN","RORPUT01",43,0)
 ;                         ;;  CodeN, ...
"RTN","RORPUT01",44,0)
 ;                         ;
"RTN","RORPUT01",45,0)
 ;
"RTN","RORPUT01",46,0)
 ;               There should be at least one line that does not
"RTN","RORPUT01",47,0)
 ;               contain ";;" after the list (or no lines at all).
"RTN","RORPUT01",48,0)
 ;
"RTN","RORPUT01",49,0)
 ; Return Values:
"RTN","RORPUT01",50,0)
 ;       <0  Error code
"RTN","RORPUT01",51,0)
 ;       ""  The list is empty
"RTN","RORPUT01",52,0)
 ;     '=""  A string that should be XECUTE'd to get the next
"RTN","RORPUT01",53,0)
 ;           buffer with the list data
"RTN","RORPUT01",54,0)
 ;
"RTN","RORPUT01",55,0)
COMPNEXT(PARAM) ;
"RTN","RORPUT01",56,0)
 N I,N,NEXT,RC  Q:PARAM?." " ""
"RTN","RORPUT01",57,0)
 ;--- Reference to a routine label
"RTN","RORPUT01",58,0)
 I PARAM?1.8UN1"^"1.8UN  D  Q NEXT
"RTN","RORPUT01",59,0)
 . S NEXT="S BUF=$T("_$P(PARAM,U)_"+TLI"_U_$P(PARAM,U,2)_")"
"RTN","RORPUT01",60,0)
 ;--- List of codes separated by commas
"RTN","RORPUT01",61,0)
 S N=$L(PARAM,","),RC=0
"RTN","RORPUT01",62,0)
 F I=1:1:N  I '($P(PARAM,",",I)?." "1.N." ")  S RC=-88  Q
"RTN","RORPUT01",63,0)
 I RC<0,I=N  S:$P(PARAM,",",N)?." " RC=0,N=N-1
"RTN","RORPUT01",64,0)
 I N>0,RC'<0  D  Q NEXT
"RTN","RORPUT01",65,0)
 . S NEXT="S BUF=$P("""_";;"_$P(PARAM,",",1,N)_""",U,TLI)"
"RTN","RORPUT01",66,0)
 ;--- Invalid parameter
"RTN","RORPUT01",67,0)
 Q $$ERROR^RORERR(-88,,,,"List of Codes",PARAM)
"RTN","RORPUT01",68,0)
 ;
"RTN","RORPUT01",69,0)
 ;***** ADDS ITEMS TO 'DRUG THERAPY LIST' MULTIPLE OF FILE #798.1
"RTN","RORPUT01",70,0)
 ;
"RTN","RORPUT01",71,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPUT01",72,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPUT01",73,0)
 ;
"RTN","RORPUT01",74,0)
 ; [RORDRGAD]    Either a list of National Drug Codes separated by
"RTN","RORPUT01",75,0)
 ;               commas or a full reference (TAG^ROUTINE) to a
"RTN","RORPUT01",76,0)
 ;               routine label after which the list is located.
"RTN","RORPUT01",77,0)
 ;
"RTN","RORPUT01",78,0)
 ;               All spaces are removed from the lines of the list.
"RTN","RORPUT01",79,0)
 ;               See the $$COMPNEXT^RORPUT01 function for more
"RTN","RORPUT01",80,0)
 ;               details.
"RTN","RORPUT01",81,0)
 ;
"RTN","RORPUT01",82,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPUT01",83,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPUT01",84,0)
 ; sub-nodes of the same name.
"RTN","RORPUT01",85,0)
 ;
"RTN","RORPUT01",86,0)
 ; Return Values:
"RTN","RORPUT01",87,0)
 ;       <0  Error code
"RTN","RORPUT01",88,0)
 ;        0  Ok
"RTN","RORPUT01",89,0)
 ;
"RTN","RORPUT01",90,0)
DRUGADD(RORREG,RORDRGAD) ;
"RTN","RORPUT01",91,0)
 N RC
"RTN","RORPUT01",92,0)
 D BMES^RORKIDS("Adding new items to the drug list...")
"RTN","RORPUT01",93,0)
 ;--- Get the parameters
"RTN","RORPUT01",94,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPUT01",95,0)
 S:$G(RORDRGAD)="" RORDRGAD=$$PARAM^RORKIDS("RORDRGAD")
"RTN","RORPUT01",96,0)
 ;--- Update the multiple
"RTN","RORPUT01",97,0)
 S RC=$$ADD(+RORREG,798.117,RORDRGAD)  Q:RC<0 RC
"RTN","RORPUT01",98,0)
 ;--- Success
"RTN","RORPUT01",99,0)
 D MES^RORKIDS("The drug list has been updated successfully.")
"RTN","RORPUT01",100,0)
 Q 0
"RTN","RORPUT01",101,0)
 ;
"RTN","RORPUT01",102,0)
 ;***** REMOVES ITEMS FROM 'DRUG THERAPY LIST' MULTIPLE OF FILE #798.1
"RTN","RORPUT01",103,0)
 ;
"RTN","RORPUT01",104,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPUT01",105,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPUT01",106,0)
 ;
"RTN","RORPUT01",107,0)
 ; [RORDRGAD]    Either a list of National Drug Codes separated by
"RTN","RORPUT01",108,0)
 ;               commas or a full reference (TAG^ROUTINE) to a
"RTN","RORPUT01",109,0)
 ;               routine label after which the list is located.
"RTN","RORPUT01",110,0)
 ;
"RTN","RORPUT01",111,0)
 ;               All spaces are removed from the lines of the list.
"RTN","RORPUT01",112,0)
 ;               See the $$COMPNEXT^RORPUT01 function for more
"RTN","RORPUT01",113,0)
 ;               details.
"RTN","RORPUT01",114,0)
 ;
"RTN","RORPUT01",115,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPUT01",116,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPUT01",117,0)
 ; sub-nodes of the same name.
"RTN","RORPUT01",118,0)
 ;
"RTN","RORPUT01",119,0)
 ; Return Values:
"RTN","RORPUT01",120,0)
 ;       <0  Error code
"RTN","RORPUT01",121,0)
 ;        0  Ok
"RTN","RORPUT01",122,0)
 ;
"RTN","RORPUT01",123,0)
DRUGREM(RORREG,RORDRGRM) ;
"RTN","RORPUT01",124,0)
 N RC
"RTN","RORPUT01",125,0)
 D BMES^RORKIDS("Removing obsolete items from the drug list...")
"RTN","RORPUT01",126,0)
 ;--- Get the parameters
"RTN","RORPUT01",127,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPUT01",128,0)
 S:$G(RORDRGRM)="" RORDRGRM=$$PARAM^RORKIDS("RORDRGRM")
"RTN","RORPUT01",129,0)
 ;--- Update the multiple
"RTN","RORPUT01",130,0)
 S RC=$$REMOVE(+RORREG,798.117,RORDRGRM)  Q:RC<0 RC
"RTN","RORPUT01",131,0)
 ;--- Success
"RTN","RORPUT01",132,0)
 D MES^RORKIDS("The drug list has been updated successfully.")
"RTN","RORPUT01",133,0)
 Q 0
"RTN","RORPUT01",134,0)
 ;
"RTN","RORPUT01",135,0)
 ;***** ADDS ITEMS TO 'EXTRACTED RESULT' MULTIPLE OF FILE #798.1
"RTN","RORPUT01",136,0)
 ;
"RTN","RORPUT01",137,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPUT01",138,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPUT01",139,0)
 ;
"RTN","RORPUT01",140,0)
 ; [RORLNCAD]    Either a list of LOINC codes (without check digits)
"RTN","RORPUT01",141,0)
 ;               separated by commas or a full reference (TAG^ROUTINE)
"RTN","RORPUT01",142,0)
 ;               to a routine label after which the list is located.
"RTN","RORPUT01",143,0)
 ;
"RTN","RORPUT01",144,0)
 ;               All spaces are removed from the lines of the list.
"RTN","RORPUT01",145,0)
 ;               See the $$COMPNEXT^RORPUT01 function for more
"RTN","RORPUT01",146,0)
 ;               details.
"RTN","RORPUT01",147,0)
 ;
"RTN","RORPUT01",148,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPUT01",149,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPUT01",150,0)
 ; sub-nodes of the same name.
"RTN","RORPUT01",151,0)
 ;
"RTN","RORPUT01",152,0)
 ; Return Values:
"RTN","RORPUT01",153,0)
 ;       <0  Error code
"RTN","RORPUT01",154,0)
 ;        0  Ok
"RTN","RORPUT01",155,0)
 ;
"RTN","RORPUT01",156,0)
LOINCADD(RORREG,RORLNCAD) ;
"RTN","RORPUT01",157,0)
 N RC
"RTN","RORPUT01",158,0)
 D BMES^RORKIDS("Adding new LOINC codes to the EXTRACTED RESULT multiple...")
"RTN","RORPUT01",159,0)
 ;--- Get the parameters
"RTN","RORPUT01",160,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPUT01",161,0)
 S:$G(RORLNCAD)="" RORLNCAD=$$PARAM^RORKIDS("RORLNCAD")
"RTN","RORPUT01",162,0)
 ;--- Add new LOINC codes
"RTN","RORPUT01",163,0)
 S RC=$$ADD(+RORREG,798.112,RORLNCAD)  Q:RC<0 RC
"RTN","RORPUT01",164,0)
 ;--- Success
"RTN","RORPUT01",165,0)
 D MES^RORKIDS("The LOINC list has been updated successfully.")
"RTN","RORPUT01",166,0)
 Q 0
"RTN","RORPUT01",167,0)
 ;
"RTN","RORPUT01",168,0)
 ;***** REMOVES ITEMS FROM 'EXTRACTED RESULT' MULTIPLE OF FILE #798.1
"RTN","RORPUT01",169,0)
 ;
"RTN","RORPUT01",170,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPUT01",171,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPUT01",172,0)
 ;
"RTN","RORPUT01",173,0)
 ; [RORLNCRM]    Either a list of LOINC codes (without check digits)
"RTN","RORPUT01",174,0)
 ;               separated by commas or a full reference (TAG^ROUTINE)
"RTN","RORPUT01",175,0)
 ;               to a routine label after which the list is located.
"RTN","RORPUT01",176,0)
 ;
"RTN","RORPUT01",177,0)
 ;               All spaces are removed from the lines of the list.
"RTN","RORPUT01",178,0)
 ;               See the $$COMPNEXT^RORPUT01 function for more
"RTN","RORPUT01",179,0)
 ;               details.
"RTN","RORPUT01",180,0)
 ;
"RTN","RORPUT01",181,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPUT01",182,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPUT01",183,0)
 ; sub-nodes of the same name.
"RTN","RORPUT01",184,0)
 ;
"RTN","RORPUT01",185,0)
 ; Return Values:
"RTN","RORPUT01",186,0)
 ;       <0  Error code
"RTN","RORPUT01",187,0)
 ;        0  Ok
"RTN","RORPUT01",188,0)
 ;
"RTN","RORPUT01",189,0)
LOINCREM(RORREG,RORLNCRM) ;
"RTN","RORPUT01",190,0)
 N BUF,DA,DIK,IENS,IR,LCI,LOINC,NEXT,RC,RORBUF,RORMSG,TLI
"RTN","RORPUT01",191,0)
 D BMES^RORKIDS("Removing obsolete codes from the EXTRACTED RESULT multiple...")
"RTN","RORPUT01",192,0)
 ;--- Get the parameters
"RTN","RORPUT01",193,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPUT01",194,0)
 S:$G(RORLNCRM)="" RORLNCRM=$$PARAM^RORKIDS("RORLNCRM")
"RTN","RORPUT01",195,0)
 ;--- Delete unnecessary LOINC codes
"RTN","RORPUT01",196,0)
 S RC=$$REMOVE(+RORREG,798.112,RORLNCRM)  Q:RC<0 RC
"RTN","RORPUT01",197,0)
 ;--- Success
"RTN","RORPUT01",198,0)
 D MES^RORKIDS("The LOINC list has been updated successfully.")
"RTN","RORPUT01",199,0)
 Q 0
"RTN","RORPUT01",200,0)
 ;
"RTN","RORPUT01",201,0)
 ;***** REMOVES THE RECORDS FROM THE MULTIPLE
"RTN","RORPUT01",202,0)
 ;
"RTN","RORPUT01",203,0)
 ; REGIEN        Registry IEN
"RTN","RORPUT01",204,0)
 ; SUBFILE       Subfile number
"RTN","RORPUT01",205,0)
 ; LSTREF        Reference to a list or the list itself (see the
"RTN","RORPUT01",206,0)
 ;               $$COMPNEXT^RORPUT01 function for more details).
"RTN","RORPUT01",207,0)
 ;
"RTN","RORPUT01",208,0)
 ; Return Values:
"RTN","RORPUT01",209,0)
 ;       <0  Error code
"RTN","RORPUT01",210,0)
 ;        0  Ok
"RTN","RORPUT01",211,0)
 ;
"RTN","RORPUT01",212,0)
REMOVE(REGIEN,SUBFILE,LSTREF) ;
"RTN","RORPUT01",213,0)
 N BUF,DA,DIK,IENS,IR,ITEM,LI,NEXT,RC,RORBUF,RORMSG,TLI
"RTN","RORPUT01",214,0)
 S NEXT=$$COMPNEXT(LSTREF)  Q:NEXT<0 NEXT
"RTN","RORPUT01",215,0)
 S IENS=","_(+REGIEN)_",",RC=0
"RTN","RORPUT01",216,0)
 F TLI=1:1  X NEXT  Q:$G(BUF)'[";;"  D  Q:RC<0
"RTN","RORPUT01",217,0)
 . S BUF=$P(BUF,";;",2)
"RTN","RORPUT01",218,0)
 . D MES^RORKIDS(BUF)
"RTN","RORPUT01",219,0)
 . S BUF=$TR(BUF," ")
"RTN","RORPUT01",220,0)
 . F LI=1:1  S ITEM=$P(BUF,",",LI)  Q:ITEM=""  D  Q:RC<0
"RTN","RORPUT01",221,0)
 . . K RORBUF
"RTN","RORPUT01",222,0)
 . . D FIND^DIC(SUBFILE,IENS,"@","QX",ITEM,,"B",,,"RORBUF","RORMSG")
"RTN","RORPUT01",223,0)
 . . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,SUBFILE,IENS)  Q
"RTN","RORPUT01",224,0)
 . . S IR="",DIK=$$ROOT^DILFD(SUBFILE,IENS),DA(1)=+REGIEN
"RTN","RORPUT01",225,0)
 . . F  S IR=$O(RORBUF("DILIST",2,IR))  Q:IR=""  D
"RTN","RORPUT01",226,0)
 . . . S DA=RORBUF("DILIST",2,IR)  D ^DIK
"RTN","RORPUT01",227,0)
 Q RC
"RTN","RORPUT01",228,0)
 ;
"RTN","RORPUT01",229,0)
 ;***** UPDATES (POPULATES) THE LOCAL REGISTRY
"RTN","RORPUT01",230,0)
 ;
"RTN","RORPUT01",231,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPUT01",232,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPUT01",233,0)
 ; [MAXNTSK]     Maximum number of registry update subtasks
"RTN","RORPUT01",234,0)
 ; [SUSPEND]     Suspend update (sub)tasks during the peak hours
"RTN","RORPUT01",235,0)
 ;               (StartTime^EndTime)
"RTN","RORPUT01",236,0)
 ;
"RTN","RORPUT01",237,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPUT01",238,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPUT01",239,0)
 ; sub-nodes of the same name.
"RTN","RORPUT01",240,0)
 ;
"RTN","RORPUT01",241,0)
 ; Return Values:
"RTN","RORPUT01",242,0)
 ;       <0  Error code
"RTN","RORPUT01",243,0)
 ;        0  Ok
"RTN","RORPUT01",244,0)
 ;
"RTN","RORPUT01",245,0)
UPDATE(RORREG,MAXNTSK,SUSPEND) ;
"RTN","RORPUT01",246,0)
 N EC,REGLST
"RTN","RORPUT01",247,0)
 D BMES^RORKIDS("Updating the local registry...")
"RTN","RORPUT01",248,0)
 ;--- Get the parameters
"RTN","RORPUT01",249,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPUT01",250,0)
 S:RORREG REGLST($P(RORREG,U,2))=+RORREG
"RTN","RORPUT01",251,0)
 S:$G(MAXNTSK)="" MAXNTSK=$$PARAM^RORKIDS("MAXNTSK")
"RTN","RORPUT01",252,0)
 S:$G(SUSPEND)="" SUSPEND=$$PARAM^RORKIDS("SUSPEND")
"RTN","RORPUT01",253,0)
 ;--- Update the registry
"RTN","RORPUT01",254,0)
 S RC=$$UPDATE^RORUPD(.REGLST,,MAXNTSK,SUSPEND)  Q:RC<0 RC
"RTN","RORPUT01",255,0)
 ;--- Success
"RTN","RORPUT01",256,0)
 D MES^RORKIDS("Registry update completed.")
"RTN","RORPUT01",257,0)
 Q 0
"RTN","RORREP01")
0^57^B47036282
"RTN","RORREP01",1,0)
RORREP01 ;HOIFO/BH - REGISTRY COMPARISON REPORT ; 7/6/03 4:41pm
"RTN","RORREP01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;March 14, 2003
"RTN","RORREP01",3,0)
 ;
"RTN","RORREP01",4,0)
 ;--------------------------------------------------------------------
"RTN","RORREP01",5,0)
 ; Registry: [VA ICR]
"RTN","RORREP01",6,0)
 ;--------------------------------------------------------------------
"RTN","RORREP01",7,0)
 ;
"RTN","RORREP01",8,0)
 Q
"RTN","RORREP01",9,0)
 ;
"RTN","RORREP01",10,0)
BEGIN ;
"RTN","RORREP01",11,0)
 I '$D(^XUSEC("IMRA",DUZ)) S IMRLOC="RORREP01" D ACESSERR^IMRERR,H^XUS K IMRLOC
"RTN","RORREP01",12,0)
 ;
"RTN","RORREP01",13,0)
 W !,?10,"####################################################"
"RTN","RORREP01",14,0)
 W !,?10,"#",?20,"Local ICR Version Comparison Report      #",?61
"RTN","RORREP01",15,0)
 W !,?10,"####################################################"
"RTN","RORREP01",16,0)
 ;
"RTN","RORREP01",17,0)
 ;
"RTN","RORREP01",18,0)
DEV D IMRDEV^IMREDIT
"RTN","RORREP01",19,0)
 G:POP KILL
"RTN","RORREP01",20,0)
 I '$D(IO("Q")) W @IOF D REP Q
"RTN","RORREP01",21,0)
 I $D(IO("Q")) D  G KILL
"RTN","RORREP01",22,0)
 . S ZTRTN="REP^RORREP01",ZTDESC="Local ICR Version Comparison Report"
"RTN","RORREP01",23,0)
 . S ZTSAVE("*")="",ZTIO=ION_";"_IOM_";"_IOSL
"RTN","RORREP01",24,0)
 . D ^%ZTLOAD K ZTRTN,ZTDESC,ZTSAVE,ZTSK
"RTN","RORREP01",25,0)
 . Q
"RTN","RORREP01",26,0)
 ;
"RTN","RORREP01",27,0)
REP ; Get Data
"RTN","RORREP01",28,0)
 U IO
"RTN","RORREP01",29,0)
 D EN1
"RTN","RORREP01",30,0)
 K CNT
"RTN","RORREP01",31,0)
 ;
"RTN","RORREP01",32,0)
 D PRNT^RORREP02
"RTN","RORREP01",33,0)
CLOSE D ^%ZISC K %ZIS,IOP
"RTN","RORREP01",34,0)
 S:$D(ZTQUEUED) ZTREQ="@"
"RTN","RORREP01",35,0)
 ;
"RTN","RORREP01",36,0)
 ;
"RTN","RORREP01",37,0)
KILL D ^%ZISC
"RTN","RORREP01",38,0)
 K ^TMP("RORREP01",$J)
"RTN","RORREP01",39,0)
 K DTOUT,VAROOT,VAERR,A,DIRUT,I,J,POP,X,X0,X1,Y,Z,D,IMRDTE,IMRFLG,IMRHED,IMRRPG,%I,DISYS,IMRPG
"RTN","RORREP01",40,0)
 D HOME^%ZIS
"RTN","RORREP01",41,0)
 Q
"RTN","RORREP01",42,0)
 ;
"RTN","RORREP01",43,0)
 ; ---------------------------------------------------------------------
"RTN","RORREP01",44,0)
EN1 ;
"RTN","RORREP01",45,0)
 K ^TMP("RORREP01",$J)
"RTN","RORREP01",46,0)
 S CNT=0
"RTN","RORREP01",47,0)
 D VTHREE
"RTN","RORREP01",48,0)
 D VTWO
"RTN","RORREP01",49,0)
 ;
"RTN","RORREP01",50,0)
 D INTWO
"RTN","RORREP01",51,0)
 D INTHREE
"RTN","RORREP01",52,0)
 Q
"RTN","RORREP01",53,0)
 ;
"RTN","RORREP01",54,0)
VTHREE ; Make array of version 3 patients 
"RTN","RORREP01",55,0)
 N ICN,IDSC,NAME,RC,PAT
"RTN","RORREP01",56,0)
 K VTHREE
"RTN","RORREP01",57,0)
 S RC=$$PATITER^RORAPI01(.IDSC,"VA ICR")
"RTN","RORREP01",58,0)
 I RC<0 Q
"RTN","RORREP01",59,0)
 F  S RC=$$NEXTPAT^RORAPI01(.IDSC)  Q:RC'>0  D
"RTN","RORREP01",60,0)
 . S PAT=+RC
"RTN","RORREP01",61,0)
 . S ^TMP("RORREP01",$J,"VTHREE",PAT)=""
"RTN","RORREP01",62,0)
 . S ICN=$$GETICN^MPIF001(PAT)
"RTN","RORREP01",63,0)
 . Q:$L(ICN)'=9
"RTN","RORREP01",64,0)
 . S NAME=$P(^DPT(PAT,0),"^",1)
"RTN","RORREP01",65,0)
 . S ^TMP("RORREP01",$J,"ICN",NAME,PAT)=""
"RTN","RORREP01",66,0)
 Q
"RTN","RORREP01",67,0)
 ;
"RTN","RORREP01",68,0)
 ;
"RTN","RORREP01",69,0)
VTWO ; Make array of version 2.1 patients
"RTN","RORREP01",70,0)
 N ENCODE,PAT,IMRIEN
"RTN","RORREP01",71,0)
 S IMRIEN=0
"RTN","RORREP01",72,0)
 F  S IMRIEN=$O(^IMR(158,IMRIEN)) Q:'IMRIEN  D
"RTN","RORREP01",73,0)
 . S ENCODE=$P(^IMR(158,IMRIEN,0),U)
"RTN","RORREP01",74,0)
 . I ENCODE="" D  Q
"RTN","RORREP01",75,0)
 . . S CNT=CNT+1
"RTN","RORREP01",76,0)
 . . S ^TMP("RORREP01",$J,"ERROR","ENCODE",CNT)="Entry "_IMRIEN_" in file #158 does not have .01 field." Q
"RTN","RORREP01",77,0)
 . S PAT=$$XOR^RORUTL03(ENCODE)
"RTN","RORREP01",78,0)
 . I PAT=0!(PAT="") D  Q
"RTN","RORREP01",79,0)
 . . S CNT=CNT+1
"RTN","RORREP01",80,0)
 . . S ^TMP("RORREP01",$J,"ERROR","ENCODE",CNT)="Could not decode .01 field "_ENCODE_" of file #158."
"RTN","RORREP01",81,0)
 . ;
"RTN","RORREP01",82,0)
 . I $D(^DPT(PAT,-9)) D  Q
"RTN","RORREP01",83,0)
 . . N NEWIEN
"RTN","RORREP01",84,0)
 . . S NEWIEN=^DPT(PAT,-9)
"RTN","RORREP01",85,0)
 . . I NEWIEN="" Q
"RTN","RORREP01",86,0)
 . . I $D(^TMP("RORREP01",$J,"PROC",NEWIEN)) Q
"RTN","RORREP01",87,0)
 . . S ^TMP("RORREP01",$J,"MERGE",NEWIEN)=ENCODE
"RTN","RORREP01",88,0)
 . ;
"RTN","RORREP01",89,0)
 . I $$GET1^DIQ(2,PAT,.01)="" D  Q
"RTN","RORREP01",90,0)
 . . S CNT=CNT+1
"RTN","RORREP01",91,0)
 . . S ^TMP("RORREP01",$J,"ERROR","ENCODE",CNT)="Could not get patient name from patient file IEN "_PAT Q
"RTN","RORREP01",92,0)
 . ;
"RTN","RORREP01",93,0)
 . D VTWO1(PAT,ENCODE)
"RTN","RORREP01",94,0)
 ;
"RTN","RORREP01",95,0)
 I $D(^TMP("RORREP01",$J,"MERGE")) D
"RTN","RORREP01",96,0)
 . N ENC,SUB4 S SUB4=0
"RTN","RORREP01",97,0)
 . F  S SUB4=$O(^TMP("RORREP01",$J,"MERGE",SUB4)) Q:SUB4=""  D
"RTN","RORREP01",98,0)
 . . S ENC=^TMP("RORREP01",$J,"MERGE",SUB4)
"RTN","RORREP01",99,0)
 . . D VTWO1(SUB4,ENC)
"RTN","RORREP01",100,0)
 ;
"RTN","RORREP01",101,0)
 K ^TMP("RORREP01",$J,"PROC"),^TMP("RORREP01",$J,"MERGE")
"RTN","RORREP01",102,0)
 Q
"RTN","RORREP01",103,0)
 ;
"RTN","RORREP01",104,0)
VTWO1(PAT,ENCODE) ;
"RTN","RORREP01",105,0)
 N ICN,SSN
"RTN","RORREP01",106,0)
 I $$GET1^DIQ(2,PAT,.01)="" D  Q
"RTN","RORREP01",107,0)
 . S CNT=CNT+1
"RTN","RORREP01",108,0)
 . S ^TMP("RORREP01",$J,"ERROR","ENCODE",CNT)="Could not get file #2 entry for entry "_ENCODE_" of file #158."
"RTN","RORREP01",109,0)
 ;
"RTN","RORREP01",110,0)
 S ^TMP("RORREP01",$J,"PROC",PAT)=""
"RTN","RORREP01",111,0)
 S ^TMP("RORREP01",$J,"VTWO",PAT)=ENCODE
"RTN","RORREP01",112,0)
 I PAT=7202138 W ENCODE_"***"
"RTN","RORREP01",113,0)
 S ICN=$$GETICN^MPIF001(PAT)
"RTN","RORREP01",114,0)
 Q:$L(ICN)'=9
"RTN","RORREP01",115,0)
 S NAME=$P(^DPT(PAT,0),"^",1)
"RTN","RORREP01",116,0)
 S SSN=$$GET1^DIQ(2,PAT,.09),SSN=$E(SSN,6,9)
"RTN","RORREP01",117,0)
 S ^TMP("RORREP01",$J,"ICN",NAME,PAT)=SSN
"RTN","RORREP01",118,0)
 Q
"RTN","RORREP01",119,0)
 ;
"RTN","RORREP01",120,0)
INTWO ; Patients in version 2.1 and not in three or in both
"RTN","RORREP01",121,0)
 N IEN,NAME,DATE21,RULE,SSN S IEN=0
"RTN","RORREP01",122,0)
 F  S IEN=$O(^TMP("RORREP01",$J,"VTWO",IEN)) Q:IEN=""  D
"RTN","RORREP01",123,0)
 . S NAME=$$GET1^DIQ(2,IEN,.01)
"RTN","RORREP01",124,0)
 . S SSN=$$GET1^DIQ(2,IEN,.09),SSN=$E(SSN,6,9)
"RTN","RORREP01",125,0)
 . S DATE21=$$DATE21(^TMP("RORREP01",$J,"VTWO",IEN))
"RTN","RORREP01",126,0)
 . I '$D(^TMP("RORREP01",$J,"VTHREE",IEN)) D  Q
"RTN","RORREP01",127,0)
 . . S ^TMP("RORREP01",$J,"INTWO",NAME)=DATE21_"^"_SSN
"RTN","RORREP01",128,0)
 . S RULE=$$RULE(IEN) I RULE=0 Q
"RTN","RORREP01",129,0)
 . S ^TMP("RORREP01",$J,"INBOTH",NAME)=RULE_"^"_DATE21_"^"_SSN
"RTN","RORREP01",130,0)
 Q
"RTN","RORREP01",131,0)
 ;
"RTN","RORREP01",132,0)
 ;
"RTN","RORREP01",133,0)
INTHREE ; Patients in version 3.0 and not in two OR in both
"RTN","RORREP01",134,0)
 N DATE21,RULE,IEN,PENDING,NAME,SSN S IEN=0
"RTN","RORREP01",135,0)
 F  S IEN=$O(^TMP("RORREP01",$J,"VTHREE",IEN)) Q:IEN=""  D
"RTN","RORREP01",136,0)
 . S NAME=$$GET1^DIQ(2,IEN,.01)
"RTN","RORREP01",137,0)
 . S SSN=$$GET1^DIQ(2,IEN,.09),SSN=$E(SSN,6,9)
"RTN","RORREP01",138,0)
 . I NAME="" S CNT=CNT+1,^TMP("RORREP01",$J,"ERROR","ROR",CNT)="Can't find Name from patient (#2) file IEN "_IEN_"." Q
"RTN","RORREP01",139,0)
 . ;
"RTN","RORREP01",140,0)
 . S RULE=$$RULE(IEN) I RULE=0 Q
"RTN","RORREP01",141,0)
 . I '$D(^TMP("RORREP01",$J,"VTWO",IEN)) D  Q
"RTN","RORREP01",142,0)
 . . S PENDING=$$PEND(IEN)
"RTN","RORREP01",143,0)
 . . S ^TMP("RORREP01",$J,"INTHREE",NAME)=RULE_"^"_PENDING_"^"_SSN
"RTN","RORREP01",144,0)
 . S DATE21=$$DATE21(^TMP("RORREP01",$J,"VTWO",IEN))
"RTN","RORREP01",145,0)
 . S ^TMP("RORREP01",$J,"INBOTH",NAME)=RULE_"^"_DATE21_"^"_SSN
"RTN","RORREP01",146,0)
 Q
"RTN","RORREP01",147,0)
 ;
"RTN","RORREP01",148,0)
 ;
"RTN","RORREP01",149,0)
DATE21(ENCODE) ; Get date added to ICR 2.1
"RTN","RORREP01",150,0)
 N IMRCAT1,IMRCAT2,IMRCAT3,IMRCAT4,IMRNODE,IMRIEN,IMRDTE,IMRARR
"RTN","RORREP01",151,0)
 S IMRIEN=0
"RTN","RORREP01",152,0)
 S IMRIEN=$O(^IMR(158,"B",ENCODE,IMRIEN))
"RTN","RORREP01",153,0)
 S IMRNODE=^IMR(158,IMRIEN,0)
"RTN","RORREP01",154,0)
 S IMRCAT1=$P(IMRNODE,"^",36) I IMRCAT1'="" S IMRARR(IMRCAT1)=""
"RTN","RORREP01",155,0)
 S IMRCAT2=$P(IMRNODE,"^",44) I IMRCAT2'="" S IMRARR(IMRCAT2)=""
"RTN","RORREP01",156,0)
 S IMRCAT3=$P(IMRNODE,"^",35) I IMRCAT3'="" S IMRARR(IMRCAT3)=""
"RTN","RORREP01",157,0)
 S IMRCAT4=$P(IMRNODE,"^",23) I IMRCAT4'="" S IMRARR(IMRCAT4)=""
"RTN","RORREP01",158,0)
 I '$D(IMRARR) Q "No Cat. Date"
"RTN","RORREP01",159,0)
 S IMRDTE=""
"RTN","RORREP01",160,0)
 S IMRDTE=$O(IMRARR(IMRDTE))
"RTN","RORREP01",161,0)
 S Y=IMRDTE D DD^%DT S IMRDTE=Y
"RTN","RORREP01",162,0)
 Q IMRDTE
"RTN","RORREP01",163,0)
 ;
"RTN","RORREP01",164,0)
 ;
"RTN","RORREP01",165,0)
PEND(IEN) ;
"RTN","RORREP01",166,0)
 N RORIEN,PEND
"RTN","RORREP01",167,0)
 S RORIEN="",PEND="YES"
"RTN","RORREP01",168,0)
 S RORIEN=$O(^RORDATA(798,"KEY",IEN,2,RORIEN))
"RTN","RORREP01",169,0)
 S RES=$P(^RORDATA(798,RORIEN,0),"^",5)
"RTN","RORREP01",170,0)
 I RES'=4 S PEND="NO"
"RTN","RORREP01",171,0)
 Q PEND
"RTN","RORREP01",172,0)
 ;
"RTN","RORREP01",173,0)
 ;
"RTN","RORREP01",174,0)
RULE(IEN) ; Get earliest selction rule 
"RTN","RORREP01",175,0)
 N RORIEN
"RTN","RORREP01",176,0)
 S RORIEN=""
"RTN","RORREP01",177,0)
 S RORIEN=$O(^RORDATA(798,"KEY",IEN,2,RORIEN))
"RTN","RORREP01",178,0)
 I 'RORIEN D  Q 0
"RTN","RORREP01",179,0)
 . S CNT=CNT+1
"RTN","RORREP01",180,0)
 . S ^TMP("RORREP01",$J,"ERROR","ROR",CNT)="Can't find IEN of file #798 record that has a #.01 field of "_IEN_"." Q
"RTN","RORREP01",181,0)
 ;
"RTN","RORREP01",182,0)
 N RULE1,DATE1,SELARR,RORSRIEN,SELDATE,DATA,RULE
"RTN","RORREP01",183,0)
 S RORSRIEN=0
"RTN","RORREP01",184,0)
 F  S RORSRIEN=$O(^RORDATA(798,RORIEN,1,RORSRIEN)) Q:'RORSRIEN  D
"RTN","RORREP01",185,0)
 . S DATA=^RORDATA(798,RORIEN,1,RORSRIEN,0)
"RTN","RORREP01",186,0)
 . S RULE=$P(DATA,"^",1)
"RTN","RORREP01",187,0)
 . S RULE=$$GET1^DIQ(798.2,RULE,.01,"E")
"RTN","RORREP01",188,0)
 . S SELDATE=$P(DATA,"^",2)
"RTN","RORREP01",189,0)
 . S SELARR(SELDATE)=RULE
"RTN","RORREP01",190,0)
 ;
"RTN","RORREP01",191,0)
 I '$D(SELARR) D  Q 0
"RTN","RORREP01",192,0)
 . S CNT=CNT+1
"RTN","RORREP01",193,0)
 . N BUFF,EVID,NME
"RTN","RORREP01",194,0)
 . S NME=$$GET1^DIQ(798,RORIEN,.01,"E")
"RTN","RORREP01",195,0)
 . ;
"RTN","RORREP01",196,0)
 . S EVID=$P(^RORDATA(798,RORIEN,0),U,14)
"RTN","RORREP01",197,0)
 . I 'EVID D
"RTN","RORREP01",198,0)
 . . S BUFF=NME_" is in ROR Local Registry file (#798) but has no selection rules."
"RTN","RORREP01",199,0)
 . . S ^TMP("RORREP01",$J,"ERROR",IEN)=BUFF
"RTN","RORREP01",200,0)
 . I EVID D
"RTN","RORREP01",201,0)
 . . S ^TMP("RORREP01",$J,"ISSUE","EVID",IEN)=NME
"RTN","RORREP01",202,0)
 S DATE1="" S DATE1=$O(SELARR(DATE1))
"RTN","RORREP01",203,0)
 S RULE1=SELARR(DATE1)
"RTN","RORREP01",204,0)
 S Y=DATE1 D DD^%DT S DATE1=Y
"RTN","RORREP01",205,0)
 Q DATE1_"^"_RULE1
"RTN","RORREP01",206,0)
 ;
"RTN","RORREP01",207,0)
 ;
"RTN","RORREP02")
0^58^B52930103
"RTN","RORREP02",1,0)
RORREP02 ;HCIOFO/BH - VERSION COMPARISON REPORT (ICR) ; 7/11/03 1:22pm
"RTN","RORREP02",2,0)
 ;;1.0;Clinical Case Registry;**5**;Mar 09, 2003
"RTN","RORREP02",3,0)
 ;
"RTN","RORREP02",4,0)
 ;--------------------------------------------------------------------
"RTN","RORREP02",5,0)
 ; Registry: [VA ICR]
"RTN","RORREP02",6,0)
 ;--------------------------------------------------------------------
"RTN","RORREP02",7,0)
 ;
"RTN","RORREP02",8,0)
PRNT ;
"RTN","RORREP02",9,0)
 N THREEH
"RTN","RORREP02",10,0)
 S THREEH=1
"RTN","RORREP02",11,0)
 D NOW^%DTC S IMRDTE=%,IMRPG="0"
"RTN","RORREP02",12,0)
 K IMRDONE
"RTN","RORREP02",13,0)
 S Y=IMRDTE D DD^%DT S IMRDTE=Y
"RTN","RORREP02",14,0)
 D LIST("INTWO","Patients in ICR 2.1 and not in ROR:ICR")
"RTN","RORREP02",15,0)
 Q:$D(IMRDONE)
"RTN","RORREP02",16,0)
 D LIST("INTHREE","Patients in ROR:ICR and not in ICR 2.1")
"RTN","RORREP02",17,0)
 Q:$D(IMRDONE)
"RTN","RORREP02",18,0)
 D LIST("INBOTH","Patients in ROR:ICR and in ICR 2.1")
"RTN","RORREP02",19,0)
 Q:$D(IMRDONE)
"RTN","RORREP02",20,0)
 D LEGEND
"RTN","RORREP02",21,0)
 Q:$D(IMRDONE)
"RTN","RORREP02",22,0)
 D ISSUE
"RTN","RORREP02",23,0)
 Q:$D(IMRDONE)
"RTN","RORREP02",24,0)
 D ERROR
"RTN","RORREP02",25,0)
 Q:$D(IMRDONE)
"RTN","RORREP02",26,0)
 D ICNERR
"RTN","RORREP02",27,0)
 K IMRDONE,TMP
"RTN","RORREP02",28,0)
 Q
"RTN","RORREP02",29,0)
 ;
"RTN","RORREP02",30,0)
HEDR ; Header of Report
"RTN","RORREP02",31,0)
 S X="ICR Version Comparison Report"
"RTN","RORREP02",32,0)
 W:$Y>0 @IOF S IMRPG=IMRPG+1
"RTN","RORREP02",33,0)
 W IMRDTE,?72,"Page ",IMRPG,!
"RTN","RORREP02",34,0)
 W !," ",X,!
"RTN","RORREP02",35,0)
 W " ",IMRHED
"RTN","RORREP02",36,0)
 W !!
"RTN","RORREP02",37,0)
 I TYPE="INTWO" D
"RTN","RORREP02",38,0)
 . W "                           Last  Earliest Cat.",!
"RTN","RORREP02",39,0)
 . W "Patient                    Four  Date (v 2.1)",!
"RTN","RORREP02",40,0)
 . W "-------                    ----  -------------",!
"RTN","RORREP02",41,0)
 ;
"RTN","RORREP02",42,0)
 I TYPE="INTHREE" D
"RTN","RORREP02",43,0)
 . I THREEH D
"RTN","RORREP02",44,0)
 . . ;
"RTN","RORREP02",45,0)
 . . W " ** Some of these patients are in a Pending state and need to be either      **"
"RTN","RORREP02",46,0)
 . . W !," ** validated into the ICR registry or deleted via the ICR GUI.  Individual  **"
"RTN","RORREP02",47,0)
 . . W !," ** patient data for pending patients will not be sent to AAC until they are **"
"RTN","RORREP02",48,0)
 . . W !," ** validated into the registry.                                             **"
"RTN","RORREP02",49,0)
 . . W !!
"RTN","RORREP02",50,0)
 . . ;
"RTN","RORREP02",51,0)
 . . S THREEH=0
"RTN","RORREP02",52,0)
 . W "Patient                    Last Earliest Sel.     Location Selection",!
"RTN","RORREP02",53,0)
 . W "                           Four Rule (ROR:ICR)    Rule Found (ROR:ICR)  Pending",!
"RTN","RORREP02",54,0)
 . W "-------                    ---- --------------    --------------------  -------",!
"RTN","RORREP02",55,0)
 .
"RTN","RORREP02",56,0)
 ;
"RTN","RORREP02",57,0)
 I TYPE="INBOTH" D
"RTN","RORREP02",58,0)
 . W "                         Last Earliest Sel.  Location Selection    Earliest Cat.",!
"RTN","RORREP02",59,0)
 . W "Patient                  Four Rule (ROR:ICR) Rule Found (ROR:ICR)  Date (v 2.1)",!
"RTN","RORREP02",60,0)
 . W "-------                  ---- -------------- --------------------- -------------",!
"RTN","RORREP02",61,0)
 Q
"RTN","RORREP02",62,0)
 ;
"RTN","RORREP02",63,0)
EHEAD ;
"RTN","RORREP02",64,0)
 S X="ICR Version Comparison Report"
"RTN","RORREP02",65,0)
 W:$Y>0 @IOF S IMRPG=IMRPG+1
"RTN","RORREP02",66,0)
 W !,IMRDTE,?72,"Page ",IMRPG,!
"RTN","RORREP02",67,0)
 W !,"  Patients with Errors.",!!
"RTN","RORREP02",68,0)
 W " -----------------------",!!
"RTN","RORREP02",69,0)
 ;
"RTN","RORREP02",70,0)
 Q
"RTN","RORREP02",71,0)
 ;
"RTN","RORREP02",72,0)
ENDHEAD ;
"RTN","RORREP02",73,0)
 S X="ICR Version Comparison Report"
"RTN","RORREP02",74,0)
 W:$Y>0 @IOF S IMRPG=IMRPG+1
"RTN","RORREP02",75,0)
 W IMRDTE,?72,"Page ",IMRPG,!
"RTN","RORREP02",76,0)
 W !," ",X,!!
"RTN","RORREP02",77,0)
 ;
"RTN","RORREP02",78,0)
 W !," Legend.",!
"RTN","RORREP02",79,0)
 W " -------",!!
"RTN","RORREP02",80,0)
 W " Code                      Description",!
"RTN","RORREP02",81,0)
 W " ----                      -----------"
"RTN","RORREP02",82,0)
 Q
"RTN","RORREP02",83,0)
 ;
"RTN","RORREP02",84,0)
EVID ;  Heading for patients with no selection rules but with supporting
"RTN","RORREP02",85,0)
 ;  Evidence.
"RTN","RORREP02",86,0)
 S X="ICR Version Comparison Report"
"RTN","RORREP02",87,0)
 W:$Y>0 @IOF S IMRPG=IMRPG+1
"RTN","RORREP02",88,0)
 W IMRDTE,?72,"Page ",IMRPG,!
"RTN","RORREP02",89,0)
 W !," ",X,!
"RTN","RORREP02",90,0)
 W !,"** The following patient(s) are in the ROR Local Registry file (#798) but    **"
"RTN","RORREP02",91,0)
 W !,"** have no selection rules but do have supporting evidence for being         **"
"RTN","RORREP02",92,0)
 W !,"** manually added to the Registry.  Please consider adding HIV disease (042) **"
"RTN","RORREP02",93,0)
 W !,"** to the patient's problem list.                                            **",!
"RTN","RORREP02",94,0)
 Q
"RTN","RORREP02",95,0)
 ;
"RTN","RORREP02",96,0)
ICNHEAD ;
"RTN","RORREP02",97,0)
 S X="ICR Version Comparison Report"
"RTN","RORREP02",98,0)
 W:$Y>0 @IOF S IMRPG=IMRPG+1
"RTN","RORREP02",99,0)
 W IMRDTE,?72,"Page ",IMRPG,!
"RTN","RORREP02",100,0)
 W !," ",X,!!
"RTN","RORREP02",101,0)
 ;
"RTN","RORREP02",102,0)
 W "** The following Patients have local ICN's (Intergration Control Numbers)   **"
"RTN","RORREP02",103,0)
 W !,"** and will not have data extracted and transmitted to the national ICR     **"
"RTN","RORREP02",104,0)
 W !,"** database.  Since your facility's VERA reimbursement is calculated from   **"
"RTN","RORREP02",105,0)
 W !,"** the National database, it is important that these patient records be     **"
"RTN","RORREP02",106,0)
 W !,"** updated by the sites IRM with National ICNs.                             **"
"RTN","RORREP02",107,0)
 W !!
"RTN","RORREP02",108,0)
 W " Name                       Last Four",!
"RTN","RORREP02",109,0)
 W " ----                       ---------"
"RTN","RORREP02",110,0)
 Q
"RTN","RORREP02",111,0)
 ;
"RTN","RORREP02",112,0)
 ;
"RTN","RORREP02",113,0)
LIST(TYPE,IMRHED) ; List patients missing data values
"RTN","RORREP02",114,0)
 D HEDR
"RTN","RORREP02",115,0)
 I '$D(^TMP("RORREP01",$J,TYPE)) D  Q
"RTN","RORREP02",116,0)
 . W !!,"No patients found." D PRTC Q:$D(IMRDONE)
"RTN","RORREP02",117,0)
 N NAME,DTE2,NEWNAME,TWOLOC,TWODATE,LOC3,LOC4,DATE3,BOTHLOC,BOTHDTE,DTE3,DATA,SSN
"RTN","RORREP02",118,0)
 N RORTOTAL
"RTN","RORREP02",119,0)
 Q:$D(IMRDONE)
"RTN","RORREP02",120,0)
 S (NAME,RORTOTAL)=0
"RTN","RORREP02",121,0)
 F  S NAME=$O(^TMP("RORREP01",$J,TYPE,NAME)) Q:NAME=""  D  Q:$D(IMRDONE)
"RTN","RORREP02",122,0)
 . I ($Y+4>IOSL) D PRTC Q:$D(IMRDONE)  D HEDR
"RTN","RORREP02",123,0)
 . S DATA=^TMP("RORREP01",$J,TYPE,NAME)
"RTN","RORREP02",124,0)
 . S NEWNAME=$E(NAME_"                         ",1,27)
"RTN","RORREP02",125,0)
 . I TYPE="INTWO" D
"RTN","RORREP02",126,0)
 . . S SSN=$P(DATA,"^",2)
"RTN","RORREP02",127,0)
 . . S DATA=$P(DATA,"^",1)
"RTN","RORREP02",128,0)
 . . W !,NEWNAME_SSN_"  "_DATA
"RTN","RORREP02",129,0)
 . . S RORTOTAL=RORTOTAL+1
"RTN","RORREP02",130,0)
 . ;
"RTN","RORREP02",131,0)
 . I TYPE="INTHREE" D
"RTN","RORREP02",132,0)
 . . S SSN=$P(DATA,"^",4)
"RTN","RORREP02",133,0)
 . . S DATE3=$P(DATA,"^",1),DATE3=$E(DATE3_"                  ",1,18)
"RTN","RORREP02",134,0)
 . . S LOC3=$P(DATA,"^",2),LOC3=$E(LOC3_"                         ",1,25)
"RTN","RORREP02",135,0)
 . . S LOC4=$P(DATA,"^",3)
"RTN","RORREP02",136,0)
 . . W !,NEWNAME_SSN_" "_DATE3_LOC3_LOC4
"RTN","RORREP02",137,0)
 . . S RORTOTAL=RORTOTAL+1
"RTN","RORREP02",138,0)
 . ;
"RTN","RORREP02",139,0)
 . I TYPE="INBOTH" D
"RTN","RORREP02",140,0)
 . . S SSN=$P(DATA,"^",4)
"RTN","RORREP02",141,0)
 . . S NEWNAME=$E(NEWNAME,1,25)
"RTN","RORREP02",142,0)
 . . S BOTHDTE=$P(DATA,"^",1),BOTHDTE=$E(BOTHDTE_"                  ",1,15)
"RTN","RORREP02",143,0)
 . . S BOTHLOC=$P(DATA,"^",2),BOTHLOC=$E(BOTHLOC_"                         ",1,22)
"RTN","RORREP02",144,0)
 . . S DTE2=$P(DATA,"^",3)
"RTN","RORREP02",145,0)
 . . W !,NEWNAME_SSN_" "_BOTHDTE_BOTHLOC_DTE2
"RTN","RORREP02",146,0)
 . . S RORTOTAL=RORTOTAL+1
"RTN","RORREP02",147,0)
 ;
"RTN","RORREP02",148,0)
 I ($Y+4>IOSL) D PRTC Q:$D(IMRDONE)  D HEDR
"RTN","RORREP02",149,0)
 W !,"Total Patients: "_RORTOTAL
"RTN","RORREP02",150,0)
 ;
"RTN","RORREP02",151,0)
 D PRTC
"RTN","RORREP02",152,0)
 Q
"RTN","RORREP02",153,0)
 ;
"RTN","RORREP02",154,0)
 ;
"RTN","RORREP02",155,0)
LEGEND ;
"RTN","RORREP02",156,0)
 D ENDHEAD
"RTN","RORREP02",157,0)
 W !
"RTN","RORREP02",158,0)
 W !," VA ICR 2.1 CONVERSION     Converted from ICR 2.1"
"RTN","RORREP02",159,0)
 W !," VA ICR LAB                ICR Lab Results"
"RTN","RORREP02",160,0)
 W !," VA ICR PROBLEM            ICR ICD-9 in the Problem List"
"RTN","RORREP02",161,0)
 W !," VA ICR PTF                ICR ICD-9 in the Inpatient File (PTF)"
"RTN","RORREP02",162,0)
 W !," VA ICR VPOV               ICR ICD-9 in the Outpatient File (V POV)"
"RTN","RORREP02",163,0)
 D PRTC
"RTN","RORREP02",164,0)
 Q
"RTN","RORREP02",165,0)
 ;
"RTN","RORREP02",166,0)
ICNERR ;
"RTN","RORREP02",167,0)
 I '$D(^TMP("RORREP01",$J,"ICN")) Q
"RTN","RORREP02",168,0)
 D ICNHEAD
"RTN","RORREP02",169,0)
 N DFN,NAME,SSN
"RTN","RORREP02",170,0)
 S NAME=""
"RTN","RORREP02",171,0)
 F  S NAME=$O(^TMP("RORREP01",$J,"ICN",NAME)) Q:NAME=""  D
"RTN","RORREP02",172,0)
 . S DFN=""
"RTN","RORREP02",173,0)
 . F  S DFN=$O(^TMP("RORREP01",$J,"ICN",NAME,DFN)) Q:'DFN  D
"RTN","RORREP02",174,0)
 . . I ($Y+4>IOSL) D PRTC Q:$D(IMRDONE)  D ICNHEAD
"RTN","RORREP02",175,0)
 . . S SSN=^TMP("RORREP01",$J,"ICN",NAME,DFN)
"RTN","RORREP02",176,0)
 . . W !," ",$E(NAME_"                           ",1,27)_SSN
"RTN","RORREP02",177,0)
 Q
"RTN","RORREP02",178,0)
 ;
"RTN","RORREP02",179,0)
ISSUE ;
"RTN","RORREP02",180,0)
 I '$D(^TMP("RORREP01",$J,"ISSUE","EVID")) Q
"RTN","RORREP02",181,0)
 D EVID
"RTN","RORREP02",182,0)
 N EIEN,NME S EIEN=0
"RTN","RORREP02",183,0)
 F  S EIEN=$O(^TMP("RORREP01",$J,"ISSUE","EVID",EIEN)) Q:'EIEN  D 
"RTN","RORREP02",184,0)
 . I ($Y+4>IOSL) D PRTC Q:$D(IMRDONE)  D EVID
"RTN","RORREP02",185,0)
 . S NME=^TMP("RORREP01",$J,"ISSUE","EVID",EIEN)
"RTN","RORREP02",186,0)
 . W !,NME
"RTN","RORREP02",187,0)
 D PRTC
"RTN","RORREP02",188,0)
 Q
"RTN","RORREP02",189,0)
 ;
"RTN","RORREP02",190,0)
ERROR ;
"RTN","RORREP02",191,0)
 I '$D(^TMP("RORREP01",$J,"ERROR")) Q
"RTN","RORREP02",192,0)
 D EHEAD
"RTN","RORREP02",193,0)
 N CNT,EIEN,BUF,BUF1,BUFP  S EIEN=0
"RTN","RORREP02",194,0)
 F  S EIEN=$O(^TMP("RORREP01",$J,"ERROR",EIEN)) Q:'EIEN  D
"RTN","RORREP02",195,0)
 . I ($Y+4>IOSL) D PRTC Q:$D(IMRDONE)  D EHEAD
"RTN","RORREP02",196,0)
 . S BUFP=^TMP("RORREP01",$J,"ERROR",EIEN)
"RTN","RORREP02",197,0)
 . S BUF=$E(BUFP,1,78),BUF1=$E(BUFP,79,150)
"RTN","RORREP02",198,0)
 . W BUF I BUF1'="" W "-"
"RTN","RORREP02",199,0)
 . W !
"RTN","RORREP02",200,0)
 . W BUF1,!
"RTN","RORREP02",201,0)
 . I BUF1'="" W !
"RTN","RORREP02",202,0)
 ;
"RTN","RORREP02",203,0)
 F TMP="ROR","ENCODE"  D
"RTN","RORREP02",204,0)
 . S CNT=0
"RTN","RORREP02",205,0)
 . F  S CNT=$O(^TMP("RORREP01",$J,"ERROR",TMP,CNT)) Q:'CNT  D
"RTN","RORREP02",206,0)
 . . I ($Y+4>IOSL) D PRTC Q:$D(IMRDONE)  D EHEAD
"RTN","RORREP02",207,0)
 . . S BUFP=^TMP("RORREP01",$J,"ERROR",TMP,CNT)
"RTN","RORREP02",208,0)
 . . S BUF=$E(BUFP,1,78),BUF1=$E(BUFP,79,150)
"RTN","RORREP02",209,0)
 . . W BUF I BUF1'="" W "-"
"RTN","RORREP02",210,0)
 . . W !
"RTN","RORREP02",211,0)
 . . W BUF1,!
"RTN","RORREP02",212,0)
 . . I BUF1'="" W !
"RTN","RORREP02",213,0)
 D PRTC
"RTN","RORREP02",214,0)
 Q
"RTN","RORREP02",215,0)
 ;
"RTN","RORREP02",216,0)
 ;
"RTN","RORREP02",217,0)
PRTC ;press return to continue prompt
"RTN","RORREP02",218,0)
 Q:$E(IOST,1,2)'="C-"!($D(IO("S")))
"RTN","RORREP02",219,0)
 K DIR W ! S DIR(0)="E" D ^DIR K DIR I 'Y S IMRDONE=1
"RTN","RORREP02",220,0)
 Q
"RTN","RORRP007")
0^10^B35145083
"RTN","RORRP007",1,0)
RORRP007 ;HCIOFO/SG - RPC: LOGS & MESSAGES ; 11/22/03 4:21pm
"RTN","RORRP007",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP007",3,0)
 ;
"RTN","RORRP007",4,0)
 Q
"RTN","RORRP007",5,0)
 ;
"RTN","RORRP007",6,0)
 ;***** LOADS THE LOG INFORMATION INTO THE BUFFER
"RTN","RORRP007",7,0)
 ;
"RTN","RORRP007",8,0)
 ; IEN           Log IEN
"RTN","RORRP007",9,0)
 ;
"RTN","RORRP007",10,0)
 ; ROR8DST       Closed root of the destination buffer
"RTN","RORRP007",11,0)
 ;
"RTN","RORRP007",12,0)
 ; [[.]OFFSET]   Offset in the buffer (modified by the function
"RTN","RORRP007",13,0)
 ;               if passed by reference)
"RTN","RORRP007",14,0)
 ;
"RTN","RORRP007",15,0)
 ; Return Values:
"RTN","RORRP007",16,0)
 ;       <0  Error code
"RTN","RORRP007",17,0)
 ;        0  Ok
"RTN","RORRP007",18,0)
 ;       >0  Skip the log
"RTN","RORRP007",19,0)
 ;
"RTN","RORRP007",20,0)
LOAD(IEN,ROR8DST,OFFSET) ;
"RTN","RORRP007",21,0)
 N BUF,IENS,IENS1,RORBUF,RORMSG
"RTN","RORRP007",22,0)
 S IENS=IEN_","  K RORBUF
"RTN","RORRP007",23,0)
 D GETS^DIQ(798.7,IENS,RORFLDS,"EI","RORBUF","RORMSG")
"RTN","RORRP007",24,0)
 Q:$G(DIERR) 1
"RTN","RORRP007",25,0)
 ;--- Skip the 'Access Violation' activities
"RTN","RORRP007",26,0)
 Q:$G(RORBUF(798.7,IENS,1,"I"))=6 2
"RTN","RORRP007",27,0)
 S BUF="L^"_IEN
"RTN","RORRP007",28,0)
 ;--- Activity (external)
"RTN","RORRP007",29,0)
 S $P(BUF,"^",3)=$G(RORBUF(798.7,IENS,1,"E"))
"RTN","RORRP007",30,0)
 ;--- Activity (internal)
"RTN","RORRP007",31,0)
 S $P(BUF,"^",4)=$G(RORBUF(798.7,IENS,1,"I"))
"RTN","RORRP007",32,0)
 ;--- Start Date/Time
"RTN","RORRP007",33,0)
 S $P(BUF,"^",5)=$G(RORBUF(798.7,IENS,.01,"E"))
"RTN","RORRP007",34,0)
 ;--- Contains messages
"RTN","RORRP007",35,0)
 S $P(BUF,"^",6)=($O(^RORDATA(798.7,IEN,2,0))>0)
"RTN","RORRP007",36,0)
 ;--- Job Number
"RTN","RORRP007",37,0)
 S $P(BUF,"^",7)=$G(RORBUF(798.7,IENS,2,"E"))
"RTN","RORRP007",38,0)
 ;--- End Date/Time
"RTN","RORRP007",39,0)
 S $P(BUF,"^",8)=$G(RORBUF(798.7,IENS,5,"E"))
"RTN","RORRP007",40,0)
 ;--- Number of Processed Patients
"RTN","RORRP007",41,0)
 S $P(BUF,"^",9)=$G(RORBUF(798.7,IENS,6.01,"E"))
"RTN","RORRP007",42,0)
 ;--- Number of Patients with Errors
"RTN","RORRP007",43,0)
 S $P(BUF,"^",10)=$G(RORBUF(798.7,IENS,6.02,"E"))
"RTN","RORRP007",44,0)
 ;--- Processing Rate
"RTN","RORRP007",45,0)
 S $P(BUF,"^",11)=$G(RORBUF(798.7,IENS,6.03,"E"))
"RTN","RORRP007",46,0)
 ;--- Add the log descriptor to the output
"RTN","RORRP007",47,0)
 S OFFSET=$G(OFFSET)+1,@ROR8DST@(OFFSET)=BUF
"RTN","RORRP007",48,0)
 ;--- Load the list of registries
"RTN","RORRP007",49,0)
 S IENS1=""
"RTN","RORRP007",50,0)
 F  S IENS1=$O(RORBUF(798.73,IENS1))  Q:IENS1=""  D
"RTN","RORRP007",51,0)
 . S BUF="R^"_$G(RORBUF(798.73,IENS1,.01,"I"))
"RTN","RORRP007",52,0)
 . S $P(BUF,"^",3)=$G(RORBUF(798.73,IENS1,.01,"E"))
"RTN","RORRP007",53,0)
 . ;--- Add the registry descriptor to the output
"RTN","RORRP007",54,0)
 . S OFFSET=OFFSET+1,@ROR8DST@(OFFSET)=BUF
"RTN","RORRP007",55,0)
 ;---Add the 'End of log' marker
"RTN","RORRP007",56,0)
 S OFFSET=OFFSET+1,@ROR8DST@(OFFSET)="L^END"
"RTN","RORRP007",57,0)
 Q 0
"RTN","RORRP007",58,0)
 ;
"RTN","RORRP007",59,0)
 ;***** RETURNS THE LOG INFORMATION
"RTN","RORRP007",60,0)
 ; RPC: [ROR LOG INFO]
"RTN","RORRP007",61,0)
 ;
"RTN","RORRP007",62,0)
 ; .RORRES       Reference to a local variable where the results
"RTN","RORRP007",63,0)
 ;               are returned to.
"RTN","RORRP007",64,0)
 ;
"RTN","RORRP007",65,0)
 ; LOGIEN        Log IEN
"RTN","RORRP007",66,0)
 ;
"RTN","RORRP007",67,0)
 ; Return Values:
"RTN","RORRP007",68,0)
 ;
"RTN","RORRP007",69,0)
 ; A negative value of the first "^"-piece of the RORRES(0) indicates
"RTN","RORRP007",70,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP007",71,0)
 ;
"RTN","RORRP007",72,0)
 ; Otherwise, either 0 (the log does not exist) or 1 is returned
"RTN","RORRP007",73,0)
 ; in the RORRES(0) and the subsequent nodes of the RORRES array
"RTN","RORRP007",74,0)
 ; contain the log information.
"RTN","RORRP007",75,0)
 ; 
"RTN","RORRP007",76,0)
 ; RORRES(0)             0 or 1
"RTN","RORRP007",77,0)
 ;
"RTN","RORRP007",78,0)
 ; RORRES(i)             See description of the LOGLIST^RORRP007
"RTN","RORRP007",79,0)
 ;
"RTN","RORRP007",80,0)
LOGINFO(RORRES,LOGIEN) ;
"RTN","RORRP007",81,0)
 N RC,RORFLDS
"RTN","RORRP007",82,0)
 ;--- Initialize the variables
"RTN","RORRP007",83,0)
 K RORRES  S RORRES(0)=0
"RTN","RORRP007",84,0)
 S RORFLDS=".01;1;2;3*;5;6.01;6.02;6.03"
"RTN","RORRP007",85,0)
 ;--- Check the parameters
"RTN","RORRP007",86,0)
 S LOGIEN=+$G(LOGIEN)  Q:LOGIEN'>0
"RTN","RORRP007",87,0)
 Q:'$D(^RORDATA(798.7,LOGIEN,0))
"RTN","RORRP007",88,0)
 ;--- Load the log information
"RTN","RORRP007",89,0)
 S RC=$$LOAD(LOGIEN,"RORRES")
"RTN","RORRP007",90,0)
 ;--- Check for the errors
"RTN","RORRP007",91,0)
 I 'RC  S RORRES(0)=1
"RTN","RORRP007",92,0)
 E  D:RC<0 RPCSTK^RORERR(.RORRES,RC)
"RTN","RORRP007",93,0)
 Q
"RTN","RORRP007",94,0)
 ;
"RTN","RORRP007",95,0)
 ;***** RETURNS THE LIST OF LOGS
"RTN","RORRP007",96,0)
 ; RPC: [ROR LOG GET LIST]
"RTN","RORRP007",97,0)
 ;
"RTN","RORRP007",98,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP007",99,0)
 ;               are returned to.
"RTN","RORRP007",100,0)
 ;
"RTN","RORRP007",101,0)
 ; REGIEN        Registry IEN
"RTN","RORRP007",102,0)
 ;
"RTN","RORRP007",103,0)
 ; [STDT]        Start date (by default, from the earliest log)
"RTN","RORRP007",104,0)
 ; [ENDT]        End date (by default, to the latest log)
"RTN","RORRP007",105,0)
 ;
"RTN","RORRP007",106,0)
 ; The ^TMP($J,"RORRP007") global node is used by the procedure.
"RTN","RORRP007",107,0)
 ;
"RTN","RORRP007",108,0)
 ; Return Values:
"RTN","RORRP007",109,0)
 ;
"RTN","RORRP007",110,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP007",111,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP007",112,0)
 ;
"RTN","RORRP007",113,0)
 ; Otherwise, number of logs is returned in the @RESULTS@(0) and the
"RTN","RORRP007",114,0)
 ; subsequent nodes of the RESULTS array contain the logs.
"RTN","RORRP007",115,0)
 ; 
"RTN","RORRP007",116,0)
 ; @RESULTS@(0)          Number of logs
"RTN","RORRP007",117,0)
 ;
"RTN","RORRP007",118,0)
 ; @RESULTS@(i)          Log descriptor
"RTN","RORRP007",119,0)
 ;                         ^01: "L"
"RTN","RORRP007",120,0)
 ;                         ^02: Log IEN
"RTN","RORRP007",121,0)
 ;                         ^03: Activity (external)
"RTN","RORRP007",122,0)
 ;                         ^04: Activity (internal)
"RTN","RORRP007",123,0)
 ;                         ^05: Start Date/Time (external)
"RTN","RORRP007",124,0)
 ;                         ^06: Contains messages (0/1)
"RTN","RORRP007",125,0)
 ;                         ^07: Job Number
"RTN","RORRP007",126,0)
 ;                         ^08: End Date/Time (external)
"RTN","RORRP007",127,0)
 ;                         ^09: Number of Processed Patients
"RTN","RORRP007",128,0)
 ;                         ^10: Number of Patients with Errors
"RTN","RORRP007",129,0)
 ;                         ^11: Processing Rate
"RTN","RORRP007",130,0)
 ;
"RTN","RORRP007",131,0)
 ; @RESULTS@(...)        Registry descriptor (optional)
"RTN","RORRP007",132,0)
 ;                         ^01: "R"
"RTN","RORRP007",133,0)
 ;                         ^02: Registry IEN
"RTN","RORRP007",134,0)
 ;                         ^03: Registry Name
"RTN","RORRP007",135,0)
 ;
"RTN","RORRP007",136,0)
 ; @RESULTS@(i+n)        'End of log' marker
"RTN","RORRP007",137,0)
 ;                         ^01: "L"
"RTN","RORRP007",138,0)
 ;                         ^02: "END"
"RTN","RORRP007",139,0)
 ;
"RTN","RORRP007",140,0)
LOGLIST(RESULTS,REGIEN,STDT,ENDT) ;
"RTN","RORRP007",141,0)
 N CNT,DATE,IEN,RORFLDS,RC,XREF
"RTN","RORRP007",142,0)
 D CLEAR^RORERR("LOGLIST^RORRP007",1)
"RTN","RORRP007",143,0)
 S RORFLDS=".01;1;2;3*;5;6.01;6.02;6.03"
"RTN","RORRP007",144,0)
 ;--- Check the parameters
"RTN","RORRP007",145,0)
 I $G(REGIEN)'>0  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP007",146,0)
 . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP007",147,0)
 S REGIEN=+REGIEN,STDT=$G(STDT)\1,ENDT=$G(ENDT)\1
"RTN","RORRP007",148,0)
 S ENDT=$S(ENDT>0:$$FMADD^XLFDT(ENDT,1),1:9999999)
"RTN","RORRP007",149,0)
 ;--- Initialize the variables
"RTN","RORRP007",150,0)
 S XREF=$NA(^RORDATA(798.7,"ARD",REGIEN)),CNT=0
"RTN","RORRP007",151,0)
 K RESULTS  S RESULTS=$NA(^TMP($J,"RORRP007"))  K @RESULTS
"RTN","RORRP007",152,0)
 ;--- Browse through the logs
"RTN","RORRP007",153,0)
 S CNT("L")=0,DATE=ENDT
"RTN","RORRP007",154,0)
 F  S DATE=$O(@XREF@(DATE),-1)  Q:DATE=""  Q:DATE<STDT  D
"RTN","RORRP007",155,0)
 . S IEN=""
"RTN","RORRP007",156,0)
 . F  S IEN=$O(@XREF@(DATE,IEN),-1)  Q:IEN=""  D
"RTN","RORRP007",157,0)
 . . S RC=$$LOAD(IEN,RESULTS,.CNT)
"RTN","RORRP007",158,0)
 . . S:'RC CNT("L")=CNT("L")+1
"RTN","RORRP007",159,0)
 ;--- Number of logs
"RTN","RORRP007",160,0)
 S @RESULTS@(0)=CNT("L")
"RTN","RORRP007",161,0)
 Q
"RTN","RORRP007",162,0)
 ;
"RTN","RORRP007",163,0)
 ;***** RETURNS THE LIST OF MESSAGES
"RTN","RORRP007",164,0)
 ; RPC: [ROR LOG GET MESSAGES]
"RTN","RORRP007",165,0)
 ;
"RTN","RORRP007",166,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP007",167,0)
 ;               are returned to.
"RTN","RORRP007",168,0)
 ;
"RTN","RORRP007",169,0)
 ; LOGIEN        IEN of the log
"RTN","RORRP007",170,0)
 ;
"RTN","RORRP007",171,0)
 ; The ^TMP($J,"RORRP007") global node is used by the procedure.
"RTN","RORRP007",172,0)
 ;
"RTN","RORRP007",173,0)
 ; Return Values:
"RTN","RORRP007",174,0)
 ;
"RTN","RORRP007",175,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP007",176,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP007",177,0)
 ;
"RTN","RORRP007",178,0)
 ; Otherwise, number of messages is returned in the RESULTS(0) and
"RTN","RORRP007",179,0)
 ; the subsequent nodes of the RESULTS array contain the messages.
"RTN","RORRP007",180,0)
 ;
"RTN","RORRP007",181,0)
 ; @RESULTS@(0)          Number of messages
"RTN","RORRP007",182,0)
 ;
"RTN","RORRP007",183,0)
 ; @RESULTS@(i)          Message descriptor
"RTN","RORRP007",184,0)
 ;                         ^01: "M"
"RTN","RORRP007",185,0)
 ;                         ^02: Message IENS
"RTN","RORRP007",186,0)
 ;                         ^03: Type (external)
"RTN","RORRP007",187,0)
 ;                         ^04: Type (internal)
"RTN","RORRP007",188,0)
 ;                         ^05: Date/Time (external)
"RTN","RORRP007",189,0)
 ;                         ^06: Has Additional Info (0/1)
"RTN","RORRP007",190,0)
 ;                         ^07: Patient Name
"RTN","RORRP007",191,0)
 ;                         ^08: Patient IEN (DFN)
"RTN","RORRP007",192,0)
 ;
"RTN","RORRP007",193,0)
 ; @RESULTS@(i+1)        Message
"RTN","RORRP007",194,0)
 ;                         ^01: "T"
"RTN","RORRP007",195,0)
 ;                         ^02: Message Text
"RTN","RORRP007",196,0)
 ;
"RTN","RORRP007",197,0)
 ; @RESULTS@(...)        Line of the ADDITIONAL INFO text
"RTN","RORRP007",198,0)
 ;                         ^01: "A"
"RTN","RORRP007",199,0)
 ;                         ^02: Text
"RTN","RORRP007",200,0)
 ;                         
"RTN","RORRP007",201,0)
 ; @RESULTS@(i+n)        'End of message' marker
"RTN","RORRP007",202,0)
 ;                         ^01: "M"
"RTN","RORRP007",203,0)
 ;                         ^02: "END"
"RTN","RORRP007",204,0)
 ;
"RTN","RORRP007",205,0)
MSGLIST(RESULTS,LOGIEN) ;
"RTN","RORRP007",206,0)
 N CNT,I,IEN,IENS,RC,ROOT,RORBUF,RORMSG
"RTN","RORRP007",207,0)
 D CLEAR^RORERR("MESSAGE^RORRP007",1)
"RTN","RORRP007",208,0)
 ;--- Check the parameters
"RTN","RORRP007",209,0)
 I $G(LOGIEN)'>0  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP007",210,0)
 . S RC=$$ERROR^RORERR(-88,,,,"LOGIEN",$G(LOGIEN))
"RTN","RORRP007",211,0)
 S LOGIEN=+LOGIEN
"RTN","RORRP007",212,0)
 ;--- Initialize the variables
"RTN","RORRP007",213,0)
 S ROOT=$$ROOT^DILFD(798.7,,1),CNT=0
"RTN","RORRP007",214,0)
 K RESULTS  S RESULTS=$NA(^TMP($J,"RORRP007"))  K @RESULTS
"RTN","RORRP007",215,0)
 ;--- Browse through the messages
"RTN","RORRP007",216,0)
 S (CNT("M"),IEN)=0
"RTN","RORRP007",217,0)
 F  S IEN=$O(@ROOT@(LOGIEN,2,IEN))  Q:IEN'>0  D
"RTN","RORRP007",218,0)
 . S IENS=IEN_","_LOGIEN_","  K RORBUF
"RTN","RORRP007",219,0)
 . ;--- Load the message details
"RTN","RORRP007",220,0)
 . D GETS^DIQ(798.74,IENS,".01;1;2;3;4","EI","RORBUF","RORMSG")
"RTN","RORRP007",221,0)
 . Q:$G(DIERR)
"RTN","RORRP007",222,0)
 . S BUF="M^"_IENS
"RTN","RORRP007",223,0)
 . ;--- Type (external)
"RTN","RORRP007",224,0)
 . S $P(BUF,"^",3)=$G(RORBUF(798.74,IENS,1,"E"))
"RTN","RORRP007",225,0)
 . ;--- Type (Internal)
"RTN","RORRP007",226,0)
 . S $P(BUF,"^",4)=$G(RORBUF(798.74,IENS,1,"I"))
"RTN","RORRP007",227,0)
 . ;--- Date/Time
"RTN","RORRP007",228,0)
 . S $P(BUF,"^",5)=$G(RORBUF(798.74,IENS,.01,"E"))
"RTN","RORRP007",229,0)
 . ;--- Has Additional Info
"RTN","RORRP007",230,0)
 . S $P(BUF,"^",6)=($D(RORBUF(798.74,IENS,4))>1)
"RTN","RORRP007",231,0)
 . ;--- Patient Name
"RTN","RORRP007",232,0)
 . S $P(BUF,"^",7)=$G(RORBUF(798.74,IENS,3,"E"))
"RTN","RORRP007",233,0)
 . ;--- Patient IEN (DFN)
"RTN","RORRP007",234,0)
 . S $P(BUF,"^",8)=$G(RORBUF(798.74,IENS,3,"I"))
"RTN","RORRP007",235,0)
 . ;--- Add the descriptor to the output
"RTN","RORRP007",236,0)
 . S CNT=CNT+1,@RESULTS@(CNT)=BUF
"RTN","RORRP007",237,0)
 . ;--- Add the message text to the output
"RTN","RORRP007",238,0)
 . S CNT=CNT+1,@RESULTS@(CNT)="T^"_$G(RORBUF(798.74,IENS,2,"E"))
"RTN","RORRP007",239,0)
 . ;--- Append the ADDITIONAL INFO
"RTN","RORRP007",240,0)
 . S I=0
"RTN","RORRP007",241,0)
 . F  S I=$O(RORBUF(798.74,IENS,4,I))  Q:'I  D
"RTN","RORRP007",242,0)
 . . S CNT=CNT+1,@RESULTS@(CNT)="A^"_RORBUF(798.74,IENS,4,I)
"RTN","RORRP007",243,0)
 . ;---Add the 'End of message' marker
"RTN","RORRP007",244,0)
 . S CNT=CNT+1,@RESULTS@(CNT)="M^END"
"RTN","RORRP007",245,0)
 . S CNT("M")=CNT("M")+1
"RTN","RORRP007",246,0)
 ;--- Number of messages
"RTN","RORRP007",247,0)
 S @RESULTS@(0)=CNT("M")
"RTN","RORRP007",248,0)
 Q
"RTN","RORRP010")
0^3^B11316186
"RTN","RORRP010",1,0)
RORRP010 ;HCIOFO/SG - RPC: TASK MANAGER ; 12/3/03 11:14am
"RTN","RORRP010",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP010",3,0)
 ;
"RTN","RORRP010",4,0)
 Q
"RTN","RORRP010",5,0)
 ;
"RTN","RORRP010",6,0)
 ;***** DELETES THE TASK
"RTN","RORRP010",7,0)
 ; RPC: [ROR TASK DELETE]
"RTN","RORRP010",8,0)
 ;
"RTN","RORRP010",9,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP010",10,0)
 ;               are returned to.
"RTN","RORRP010",11,0)
 ;
"RTN","RORRP010",12,0)
 ; TASK          Task number
"RTN","RORRP010",13,0)
 ;
"RTN","RORRP010",14,0)
 ; Return Values:
"RTN","RORRP010",15,0)
 ;
"RTN","RORRP010",16,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP010",17,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP010",18,0)
 ;
"RTN","RORRP010",19,0)
 ; Otherwise, zero is returned.
"RTN","RORRP010",20,0)
 ;
"RTN","RORRP010",21,0)
DELTASK(RESULTS,TASK) ;
"RTN","RORRP010",22,0)
 N RORERRDL  K RESULTS
"RTN","RORRP010",23,0)
 D CLEAR^RORERR("DELTASK^RORRP010",1)
"RTN","RORRP010",24,0)
 S RESULTS=$$DEQUEUE^RORTSK(TASK,1)
"RTN","RORRP010",25,0)
 D:RESULTS<0 RPCSTK^RORERR(.RESULTS,RESULTS)
"RTN","RORRP010",26,0)
 Q
"RTN","RORRP010",27,0)
 ;
"RTN","RORRP010",28,0)
 ;***** SCHEDULES THE REPORT
"RTN","RORRP010",29,0)
 ; RPC: [ROR REPORT SCHEDULE]
"RTN","RORRP010",30,0)
 ;
"RTN","RORRP010",31,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP010",32,0)
 ;               are returned to.
"RTN","RORRP010",33,0)
 ;
"RTN","RORRP010",34,0)
 ; RPTCODE       Code of the report
"RTN","RORRP010",35,0)
 ;
"RTN","RORRP010",36,0)
 ; [REGIEN]      Registry IEN (if $G(REGIEN)'>0 the task will not
"RTN","RORRP010",37,0)
 ;               be associated with any particular registry).
"RTN","RORRP010",38,0)
 ;
"RTN","RORRP010",39,0)
 ; [ZTDTH]       Date/time to start the task (FileMan). By default
"RTN","RORRP010",40,0)
 ;               (if $G(ZDTH)'>0) the task will be scheduled to run
"RTN","RORRP010",41,0)
 ;               immediately (see the $$CREATE^RORTSK for details).
"RTN","RORRP010",42,0)
 ;
"RTN","RORRP010",43,0)
 ; [SCHCODE]     Rescheduling code for the task. By default (if
"RTN","RORRP010",44,0)
 ;               $G(SCHCODE)=""), the task is executed once. See
"RTN","RORRP010",45,0)
 ;               description of the $$SCH^XLFDT function for
"RTN","RORRP010",46,0)
 ;               possible values of the parameter).
"RTN","RORRP010",47,0)
 ;
"RTN","RORRP010",48,0)
 ; [.PARAMS]     Reference to a local variable containing a list of
"RTN","RORRP010",49,0)
 ;               the name-value pairs of task parameters:
"RTN","RORRP010",50,0)
 ;
"RTN","RORRP010",51,0)
 ;                 PARAMS(name)=value
"RTN","RORRP010",52,0)
 ;
"RTN","RORRP010",53,0)
 ; Return Values:
"RTN","RORRP010",54,0)
 ;
"RTN","RORRP010",55,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP010",56,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP010",57,0)
 ;
"RTN","RORRP010",58,0)
 ; Otherwise, the task descriptor is returned in the RESULTS array
"RTN","RORRP010",59,0)
 ; (see the TASKINFO^RORRP010 entry point for details).
"RTN","RORRP010",60,0)
 ;
"RTN","RORRP010",61,0)
SCHEDREP(RESULTS,RPTCODE,REGIEN,ZTDTH,SCHCODE,PARAMS) ;
"RTN","RORRP010",62,0)
 N RORERRDL,RPINFO,TASK,TMP
"RTN","RORRP010",63,0)
 N ZTCPU,ZTDESC,ZTIO,ZTKIL,ZTPRI,ZTSAVE,ZTSYNC,ZTUCI
"RTN","RORRP010",64,0)
 D CLEAR^RORERR("SCHEDREP^RORRP010",1)
"RTN","RORRP010",65,0)
 S REGIEN=+$G(REGIEN),SCHCODE=$G(SCHCODE)
"RTN","RORRP010",66,0)
 ;--- Get the report parameters
"RTN","RORRP010",67,0)
 S RC=$$RPINFO^RORUTL08(RPTCODE,.RPINFO)
"RTN","RORRP010",68,0)
 I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP010",69,0)
 ;--- Create the task
"RTN","RORRP010",70,0)
 S TASK=$$CREATE^RORTSK(2,RPINFO(9),.PARAMS,REGIEN,RPTCODE,SCHCODE)
"RTN","RORRP010",71,0)
 I TASK<0  D RPCSTK^RORERR(.RESULTS,TASK)  Q
"RTN","RORRP010",72,0)
 ;--- Get the status
"RTN","RORRP010",73,0)
 D TASKINFO(.RESULTS,TASK)
"RTN","RORRP010",74,0)
 Q
"RTN","RORRP010",75,0)
 ;
"RTN","RORRP010",76,0)
 ;***** RETURNS THE TASK INFORMATION
"RTN","RORRP010",77,0)
 ; RPC: [ROR TASK INFO]
"RTN","RORRP010",78,0)
 ;
"RTN","RORRP010",79,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP010",80,0)
 ;               are returned to.
"RTN","RORRP010",81,0)
 ;
"RTN","RORRP010",82,0)
 ; TASK          Task number
"RTN","RORRP010",83,0)
 ;
"RTN","RORRP010",84,0)
 ; Return Values:
"RTN","RORRP010",85,0)
 ;
"RTN","RORRP010",86,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP010",87,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP010",88,0)
 ;
"RTN","RORRP010",89,0)
 ; Otherwise, the task descriptor is returned in the RESULTS array
"RTN","RORRP010",90,0)
 ; (see the $$TASKINFO^RORTSK02 function for more details).
"RTN","RORRP010",91,0)
 ;
"RTN","RORRP010",92,0)
 ; RESULTS(0)            Result Descriptor
"RTN","RORRP010",93,0)
 ;                         ^1: 1
"RTN","RORRP010",94,0)
 ;                         ^2: Number of nodes that make a single
"RTN","RORRP010",95,0)
 ;                             task descriptor (TIN)
"RTN","RORRP010",96,0)
 ;
"RTN","RORRP010",97,0)
 ; RESULTS(1)            Task Number
"RTN","RORRP010",98,0)
 ; RESULTS(2)            Task Type           (internal^external)
"RTN","RORRP010",99,0)
 ; RESULTS(3)            Registry            (IEN^Name)
"RTN","RORRP010",100,0)
 ; RESULTS(4)            Report              (Code^Name)
"RTN","RORRP010",101,0)
 ; RESULTS(5)            Description
"RTN","RORRP010",102,0)
 ; RESULTS(6)            Task Status         (internal^external)
"RTN","RORRP010",103,0)
 ; RESULTS(7)            Creation Time       (internal)
"RTN","RORRP010",104,0)
 ; RESULTS(8)            User                (DUZ^Name)
"RTN","RORRP010",105,0)
 ; RESULTS(9)            Completion Time     (internal)
"RTN","RORRP010",106,0)
 ; RESULTS(10)           Progress Percentage
"RTN","RORRP010",107,0)
 ; RESULTS(11)           Scheduled to Run at (internal)
"RTN","RORRP010",108,0)
 ; RESULTS(12)           Task Log IEN
"RTN","RORRP010",109,0)
 ; RESULTS(13)           Job Number
"RTN","RORRP010",110,0)
 ;
"RTN","RORRP010",111,0)
TASKINFO(RESULTS,TASK) ;
"RTN","RORRP010",112,0)
 N RC,RORERRDL
"RTN","RORRP010",113,0)
 D CLEAR^RORERR("TASKINFO^RORRP010",1)
"RTN","RORRP010",114,0)
 S RC=$$TASKINFO^RORTSK02(TASK,.RESULTS,"EI")
"RTN","RORRP010",115,0)
 I RC'<0  S RESULTS(0)="1^"_$$TIN^RORTSK02
"RTN","RORRP010",116,0)
 E  D RPCSTK^RORERR(.RESULTS,RC)
"RTN","RORRP010",117,0)
 Q
"RTN","RORRP010",118,0)
 ;
"RTN","RORRP010",119,0)
 ;***** RETURNS A LIST OF USER'S TASKS
"RTN","RORRP010",120,0)
 ; RPC: [ROR TASK LIST]
"RTN","RORRP010",121,0)
 ;
"RTN","RORRP010",122,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP010",123,0)
 ;               are returned to.
"RTN","RORRP010",124,0)
 ;
"RTN","RORRP010",125,0)
 ; [REGIEN]      Registry IEN (all registries by default)
"RTN","RORRP010",126,0)
 ; [TYPE]        Task Type (all types by default)
"RTN","RORRP010",127,0)
 ; [USER]        User IEN (DUZ by default)
"RTN","RORRP010",128,0)
 ;
"RTN","RORRP010",129,0)
 ; The ^TMP($J,"RORRP010") global node is used by the procedure.
"RTN","RORRP010",130,0)
 ;
"RTN","RORRP010",131,0)
 ; Return Values:
"RTN","RORRP010",132,0)
 ;
"RTN","RORRP010",133,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP010",134,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP010",135,0)
 ;
"RTN","RORRP010",136,0)
 ; Otherwise, the task descriptors are returned in the RESULTS array
"RTN","RORRP010",137,0)
 ; (see the TASKINFO^RORRP010 entry point for details).
"RTN","RORRP010",138,0)
 ;
"RTN","RORRP010",139,0)
 ; @RESULTS@(0)          Result Descriptor
"RTN","RORRP010",140,0)
 ;                         ^01: Number of task descriptors returned
"RTN","RORRP010",141,0)
 ;                              in the RESULTS array (NTSK)
"RTN","RORRP010",142,0)
 ;                         ^02: Number of nodes that make a single
"RTN","RORRP010",143,0)
 ;                              task descriptor (TIN)
"RTN","RORRP010",144,0)
 ;
"RTN","RORRP010",145,0)
 ; @RESULTS@(i)          Value returned by the $$TASKINFO^RORTSK02
"RTN","RORRP010",146,0)
 ;                       function. You can calculate the subscript
"RTN","RORRP010",147,0)
 ;                       of the item TI (from 1 to TIN) of the task
"RTN","RORRP010",148,0)
 ;                       TN (from 1 to NTSK) using the following
"RTN","RORRP010",149,0)
 ;                       formula: i = (TN-1)*TIN+TI.
"RTN","RORRP010",150,0)
 ;
"RTN","RORRP010",151,0)
 ; For example, if number of nodes returned by the $$TASKINFO^RORTSK02
"RTN","RORRP010",152,0)
 ; function for each task is 13 and the RESULTS array contains
"RTN","RORRP010",153,0)
 ; information about 3 tasks, the following nodes will be defined:
"RTN","RORRP010",154,0)
 ;
"RTN","RORRP010",155,0)
 ;   @RESULTS@(0)  = "3^13"
"RTN","RORRP010",156,0)
 ;
"RTN","RORRP010",157,0)
 ;   @RESULTS@(1)  = Task Number 1
"RTN","RORRP010",158,0)
 ;   @RESULTS@(2)  = Task Type 1 (internal^external)
"RTN","RORRP010",159,0)
 ;   ...
"RTN","RORRP010",160,0)
 ;   @RESULTS@(13) = Job Number 1
"RTN","RORRP010",161,0)
 ;
"RTN","RORRP010",162,0)
 ;   @RESULTS@(14) = Task Number 2
"RTN","RORRP010",163,0)
 ;   @RESULTS@(15) = Task Type 2 (internal^external)
"RTN","RORRP010",164,0)
 ;   ...
"RTN","RORRP010",165,0)
 ;   @RESULTS@(26) = Job Number 2
"RTN","RORRP010",166,0)
 ;
"RTN","RORRP010",167,0)
 ;   @RESULTS@(27) = Task Number 3
"RTN","RORRP010",168,0)
 ;   @RESULTS@(28) = Task Type 3 (internal^external)
"RTN","RORRP010",169,0)
 ;   ...
"RTN","RORRP010",170,0)
 ;   @RESULTS@(39) = Job Number 3
"RTN","RORRP010",171,0)
 ;
"RTN","RORRP010",172,0)
TASKLIST(RESULTS,REGIEN,TYPE,USER) ;
"RTN","RORRP010",173,0)
 N INFO,NTSK,RC,RORERRDL,TASK,TASKLIST,TIN
"RTN","RORRP010",174,0)
 D CLEAR^RORERR("TASKLIST^RORRP010",1)
"RTN","RORRP010",175,0)
 ;--- Initialize the variables
"RTN","RORRP010",176,0)
 K RESULTS  S RESULTS=$NA(^TMP($J,"RORRP010"))  K @RESULTS
"RTN","RORRP010",177,0)
 S TIN=$$TIN^RORTSK02
"RTN","RORRP010",178,0)
 ;--- Get the list of task numbers
"RTN","RORRP010",179,0)
 S RC=$$LIST^RORTSK02(.TASKLIST,$G(REGIEN),$G(TYPE),,,$G(USER))
"RTN","RORRP010",180,0)
 I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP010",181,0)
 ;--- Generate the output list
"RTN","RORRP010",182,0)
 S TASK="",NTSK=0
"RTN","RORRP010",183,0)
 F  S TASK=$O(TASKLIST(TASK))  Q:TASK=""  D
"RTN","RORRP010",184,0)
 . K INFO
"RTN","RORRP010",185,0)
 . S RC=$$TASKINFO^RORTSK02(TASK,.INFO,"EI",NTSK*TIN)  Q:RC<0
"RTN","RORRP010",186,0)
 . M @RESULTS=INFO  S NTSK=NTSK+1
"RTN","RORRP010",187,0)
 S @RESULTS@(0)=NTSK_U_TIN
"RTN","RORRP010",188,0)
 Q
"RTN","RORRP011")
0^11^B10493824
"RTN","RORRP011",1,0)
RORRP011 ;HCIOFO/SG - RPC: TASK MANAGER (REPORTS) ; 12/12/03 3:18pm
"RTN","RORRP011",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP011",3,0)
 ;
"RTN","RORRP011",4,0)
 Q
"RTN","RORRP011",5,0)
 ;
"RTN","RORRP011",6,0)
 ;***** THE REPORT RETRIEVER
"RTN","RORRP011",7,0)
 ; RPC: [ROR REPORT RETRIEVE]
"RTN","RORRP011",8,0)
 ;
"RTN","RORRP011",9,0)
 ; .RORESULT     Reference to a local variable where the report
"RTN","RORRP011",10,0)
 ;               lines are returned to.
"RTN","RORRP011",11,0)
 ;
"RTN","RORRP011",12,0)
 ; TASK          Task number
"RTN","RORRP011",13,0)
 ;
"RTN","RORRP011",14,0)
 ; [FROM]        Where to start/continue the rendering process
"RTN","RORRP011",15,0)
 ;               (see the $$XMLREP^RORTSK10 function for details).
"RTN","RORRP011",16,0)
 ;               By default (if $G(FROM)'>0), the rendering starts
"RTN","RORRP011",17,0)
 ;               from the beginning of the report.
"RTN","RORRP011",18,0)
 ;
"RTN","RORRP011",19,0)
 ; [MAXSIZE]     Either the maximum number of lines to retrieve or
"RTN","RORRP011",20,0)
 ;               the maximum size of the output in bytes (append the
"RTN","RORRP011",21,0)
 ;               "B" to the number). By default (if $G(MAXSIZE)'>0,)
"RTN","RORRP011",22,0)
 ;               the whole report (starting from the point indicated
"RTN","RORRP011",23,0)
 ;               by the FROM parameter if it is defined) is retrieved.
"RTN","RORRP011",24,0)
 ;
"RTN","RORRP011",25,0)
 ; [.SORT]       Sort modes for the report
"RTN","RORRP011",26,0)
 ;
"RTN","RORRP011",27,0)
 ; The ^TMP($J,"RORRP011") global node is used by the procedure.
"RTN","RORRP011",28,0)
 ;
"RTN","RORRP011",29,0)
 ; See the description of the ROR REPORT RETRIEVE remote procedure
"RTN","RORRP011",30,0)
 ; for more details.
"RTN","RORRP011",31,0)
 ;
"RTN","RORRP011",32,0)
 ; Return Values:
"RTN","RORRP011",33,0)
 ;
"RTN","RORRP011",34,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) node
"RTN","RORRP011",35,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for details).
"RTN","RORRP011",36,0)
 ;
"RTN","RORRP011",37,0)
GETXML(RORESULT,TASK,FROM,MAXSIZE,SORT) ;
"RTN","RORRP011",38,0)
 N DST,RC,RORERRDL,TMP  K RORESULT
"RTN","RORRP011",39,0)
 D CLEAR^RORERR("GETXML^RORRP011",1)
"RTN","RORRP011",40,0)
 ;--- Change the type of the result from the ARRAY to
"RTN","RORRP011",41,0)
 ;--- the GLOBAL ARRAY if a long report is suspected.
"RTN","RORRP011",42,0)
 S DST="RORESULT",MAXSIZE=$G(MAXSIZE)
"RTN","RORRP011",43,0)
 S TMP=$S(MAXSIZE["B":+MAXSIZE,1:MAXSIZE*80)
"RTN","RORRP011",44,0)
 I 'TMP!(TMP>16384),$$RTRNFMT^XWBLIB(4,1)  D
"RTN","RORRP011",45,0)
 . S (DST,RORESULT)=$NA(^TMP($J,"RORRP011"))
"RTN","RORRP011",46,0)
 ;--- Render the report into XML
"RTN","RORRP011",47,0)
 S RC=$$XMLREP^RORTSK10(DST,TASK,.SORT,.FROM,MAXSIZE)
"RTN","RORRP011",48,0)
 I RC<0  K @DST  D RPCSTK^RORERR(.RORESULT,RC)  Q
"RTN","RORRP011",49,0)
 ;--- Return the starting point for the next call
"RTN","RORRP011",50,0)
 S:MAXSIZE>0 @DST@(0)=$G(FROM)
"RTN","RORRP011",51,0)
 Q
"RTN","RORRP011",52,0)
 ;
"RTN","RORRP011",53,0)
 ;***** RETURNS THE REPORT STYLESHEET
"RTN","RORRP011",54,0)
 ; RPC: [ROR REPORT STYLESHEET]
"RTN","RORRP011",55,0)
 ;
"RTN","RORRP011",56,0)
 ; .RESULTS      Reference to a local variable where the XSL
"RTN","RORRP011",57,0)
 ;               stylesheet lines are returned to.
"RTN","RORRP011",58,0)
 ;
"RTN","RORRP011",59,0)
 ; RPTCODE       Code of the report
"RTN","RORRP011",60,0)
 ;
"RTN","RORRP011",61,0)
 ; [TYPE]        Type of the stylesheet
"RTN","RORRP011",62,0)
 ;                 1  Report preview (default)
"RTN","RORRP011",63,0)
 ;                 2  Comma-separated output
"RTN","RORRP011",64,0)
 ;                 3  Printer output
"RTN","RORRP011",65,0)
 ;
"RTN","RORRP011",66,0)
 ; The ^TMP($J,"RORRP011") global node is used by the procedure.
"RTN","RORRP011",67,0)
 ;
"RTN","RORRP011",68,0)
 ; Return Values:
"RTN","RORRP011",69,0)
 ;
"RTN","RORRP011",70,0)
 ; A negative value of the first "^"-piece of the @RESULTS@(0) node
"RTN","RORRP011",71,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for details).
"RTN","RORRP011",72,0)
 ;
"RTN","RORRP011",73,0)
GETXSL(RESULTS,RPTCODE,TYPE) ;
"RTN","RORRP011",74,0)
 N DLG,RC,RORERRDL
"RTN","RORRP011",75,0)
 D CLEAR^RORERR("GETXSL^RORRP011",1)
"RTN","RORRP011",76,0)
 K RESULTS  S RESULTS=$NA(^TMP($J,"RORRP011"))  K @RESULTS
"RTN","RORRP011",77,0)
 ;--- Check the parameters
"RTN","RORRP011",78,0)
 S DLG=7981000,TYPE=$S($G(TYPE)>0:TYPE/1000,1:.001)
"RTN","RORRP011",79,0)
 I $G(RPTCODE)>0  S:RPTCODE'>999 DLG=DLG+RPTCODE+TYPE
"RTN","RORRP011",80,0)
 ;--- Load the stylesheet into the buffer
"RTN","RORRP011",81,0)
 D BLD^DIALOG(DLG,,,RESULTS)
"RTN","RORRP011",82,0)
 D:$D(@RESULTS)<10
"RTN","RORRP011",83,0)
 . D BLD^DIALOG(7981000+TYPE,,,RESULTS)
"RTN","RORRP011",84,0)
 . D:$D(@RESULTS)<10 BLD^DIALOG(7981000,,,RESULTS)
"RTN","RORRP011",85,0)
 Q
"RTN","RORRP011",86,0)
 ;
"RTN","RORRP011",87,0)
 ;***** RETURNS A LIST OF AVAILABLE REPORTS AND THEIR PARAMETERS
"RTN","RORRP011",88,0)
 ; ROR: [ROR REPORTS AVAILABLE]
"RTN","RORRP011",89,0)
 ;
"RTN","RORRP011",90,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP011",91,0)
 ;               are returned to.
"RTN","RORRP011",92,0)
 ;
"RTN","RORRP011",93,0)
 ; REGIEN        Registry IEN
"RTN","RORRP011",94,0)
 ;
"RTN","RORRP011",95,0)
 ; Return Values:
"RTN","RORRP011",96,0)
 ;
"RTN","RORRP011",97,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP011",98,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP011",99,0)
 ;
"RTN","RORRP011",100,0)
 ; Otherwise, the report descriptors are returned in the RESULTS array
"RTN","RORRP011",101,0)
 ; (see the $$RPINFO^RORUTL08 entry point for details).
"RTN","RORRP011",102,0)
 ;
"RTN","RORRP011",103,0)
 ; RESULTS(0)            Result Descriptor
"RTN","RORRP011",104,0)
 ;                         ^1: Number of report descriptors returned
"RTN","RORRP011",105,0)
 ;                             in the RESULTS array (NREP)
"RTN","RORRP011",106,0)
 ;                         ^2: Number of nodes that make a single
"RTN","RORRP011",107,0)
 ;                             report descriptor (RPN)
"RTN","RORRP011",108,0)
 ;
"RTN","RORRP011",109,0)
 ; RESULTS(i)            Value returned by the $$RPINFO^RORUTL08
"RTN","RORRP011",110,0)
 ;                       function. You can calculate the subscript
"RTN","RORRP011",111,0)
 ;                       of the item RI (from 1 to RPN) of the report
"RTN","RORRP011",112,0)
 ;                       RN (from 1 to NREP) using the following
"RTN","RORRP011",113,0)
 ;                       formula: i = (RN-1)*RPN+RI.
"RTN","RORRP011",114,0)
 ;
"RTN","RORRP011",115,0)
 ; For example, if number of nodes returned by the $$RPINFO^RORUTL08
"RTN","RORRP011",116,0)
 ; function for each report is 10 and the RESULTS array contains
"RTN","RORRP011",117,0)
 ; information about 3 reports, the following nodes will be defined:
"RTN","RORRP011",118,0)
 ;
"RTN","RORRP011",119,0)
 ;   RESULTS(0)  = "3^11"
"RTN","RORRP011",120,0)
 ;
"RTN","RORRP011",121,0)
 ;   RESULTS(1)  = Report Name 1
"RTN","RORRP011",122,0)
 ;   RESULTS(2)  = Background Processing 1
"RTN","RORRP011",123,0)
 ;   ...
"RTN","RORRP011",124,0)
 ;   RESULTS(11) = Default sorting 1
"RTN","RORRP011",125,0)
 ;
"RTN","RORRP011",126,0)
 ;   RESULTS(12) = Report Name 2
"RTN","RORRP011",127,0)
 ;   RESULTS(13) = Background Processing 2
"RTN","RORRP011",128,0)
 ;   ...
"RTN","RORRP011",129,0)
 ;   RESULTS(22) = Default sorting 2
"RTN","RORRP011",130,0)
 ;
"RTN","RORRP011",131,0)
 ;   RESULTS(23) = Report Name 3
"RTN","RORRP011",132,0)
 ;   RESULTS(24) = Background Processing 3
"RTN","RORRP011",133,0)
 ;   ...
"RTN","RORRP011",134,0)
 ;   RESULTS(33) = Default sorting 3
"RTN","RORRP011",135,0)
 ;
"RTN","RORRP011",136,0)
RPAVAIL(RESULTS,REGIEN) ;
"RTN","RORRP011",137,0)
 N CODE,NAME,NREP,RC,RPLST,RPN
"RTN","RORRP011",138,0)
 D CLEAR^RORERR("RPAVAIL^RORRP011",1)
"RTN","RORRP011",139,0)
 ;--- The the list of available reports
"RTN","RORRP011",140,0)
 S RC=$$RPLIST^RORUTL08(.RPLST,REGIEN)
"RTN","RORRP011",141,0)
 I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP011",142,0)
 ;--- Sort the reports alphabetically
"RTN","RORRP011",143,0)
 S CODE=0
"RTN","RORRP011",144,0)
 F  S CODE=$O(RPLST(CODE))  Q:CODE'>0  D
"RTN","RORRP011",145,0)
 . S NAME=$P(RPLST(CODE),U,2)
"RTN","RORRP011",146,0)
 . S:NAME'="" RPLST("B",NAME,CODE)=""
"RTN","RORRP011",147,0)
 ;--- Get the parameters of the reports
"RTN","RORRP011",148,0)
 S RPN=$$RPN^RORUTL08,(NREP,RC)=0
"RTN","RORRP011",149,0)
 S NAME=""
"RTN","RORRP011",150,0)
 F  S NAME=$O(RPLST("B",NAME))  Q:NAME=""  D  Q:RC<0
"RTN","RORRP011",151,0)
 . S CODE=0
"RTN","RORRP011",152,0)
 . F  S CODE=$O(RPLST("B",NAME,CODE))  Q:CODE'>0  D  Q:RC<0
"RTN","RORRP011",153,0)
 . . S RC=$$RPINFO^RORUTL08(CODE,.RESULTS,"E",NREP*RPN)
"RTN","RORRP011",154,0)
 . . S:RC'<0 NREP=NREP+1
"RTN","RORRP011",155,0)
 ;---
"RTN","RORRP011",156,0)
 I RC'<0  S RESULTS(0)=NREP_U_RPN
"RTN","RORRP011",157,0)
 E  D RPCSTK^RORERR(.RESULTS,RC)
"RTN","RORRP011",158,0)
 Q
"RTN","RORRP012")
0^12^B16492346
"RTN","RORRP012",1,0)
RORRP012 ;HCIOFO/SG - RPC: MISCELLANEOUS ; 9/9/03 9:35am
"RTN","RORRP012",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP012",3,0)
 ;
"RTN","RORRP012",4,0)
 ; This routine uses the following IA's:
"RTN","RORRP012",5,0)
 ;
"RTN","RORRP012",6,0)
 ; #2263         Supported parameter tools (GETWP^XPAR and PUT^XPAR)
"RTN","RORRP012",7,0)
 ;
"RTN","RORRP012",8,0)
 Q
"RTN","RORRP012",9,0)
 ;
"RTN","RORRP012",10,0)
 ;***** RETRIEVES THE VALUE OF THE GUI PARAMETER
"RTN","RORRP012",11,0)
 ; RPC: [ROR GUI PARAMETER GET]
"RTN","RORRP012",12,0)
 ;
"RTN","RORRP012",13,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP012",14,0)
 ;               are returned to.
"RTN","RORRP012",15,0)
 ;
"RTN","RORRP012",16,0)
 ; NAME          Name of the GUI parameter
"RTN","RORRP012",17,0)
 ;
"RTN","RORRP012",18,0)
 ; [ENTITY]      Entity where the parameter value is searched for.
"RTN","RORRP012",19,0)
 ;               By default ($G(ENTITY)=""), the "ALL" value is used
"RTN","RORRP012",20,0)
 ;               (see the DBIA #2263 for more details).
"RTN","RORRP012",21,0)
 ;
"RTN","RORRP012",22,0)
 ; Return Values:
"RTN","RORRP012",23,0)
 ;
"RTN","RORRP012",24,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP012",25,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP012",26,0)
 ;
"RTN","RORRP012",27,0)
 ; Otherwise, the RESULTS(0) will contain 0 and the subsequent nodes
"RTN","RORRP012",28,0)
 ; of the RESULTS array will contain the lines of parameter value.
"RTN","RORRP012",29,0)
 ;
"RTN","RORRP012",30,0)
GETPARM(RESULTS,NAME,ENTITY) ;
"RTN","RORRP012",31,0)
 N CNT,I,RC,RORBUF,RORERRDL,RORMSG  K RESULTS
"RTN","RORRP012",32,0)
 D CLEAR^RORERR("GETPARM^RORRP012",1)
"RTN","RORRP012",33,0)
 S:$G(ENTITY)="" ENTITY="ALL"
"RTN","RORRP012",34,0)
 D GETWP^XPAR(.RORBUF,ENTITY,"ROR GUI PARAMETER",NAME,.RORMSG)
"RTN","RORRP012",35,0)
 I $G(RORMSG)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP012",36,0)
 . S RC=$$ERROR^RORERR(-56,,RORINFO,,+RORMSG,"GETWP^XPAR")
"RTN","RORRP012",37,0)
 S I="",CNT=0
"RTN","RORRP012",38,0)
 F  S I=$O(RORBUF(I))  Q:I=""  D
"RTN","RORRP012",39,0)
 . S CNT=CNT+1,RESULTS(CNT)=RORBUF(I,0)  K RORBUF(I)
"RTN","RORRP012",40,0)
 S RESULTS(0)=0
"RTN","RORRP012",41,0)
 Q
"RTN","RORRP012",42,0)
 ;
"RTN","RORRP012",43,0)
 ;***** RETURNS THE CURRENT DATE/TIME ON THE SERVER
"RTN","RORRP012",44,0)
 ; RPC: [ROR GET SERVER TIME]
"RTN","RORRP012",45,0)
 ;
"RTN","RORRP012",46,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP012",47,0)
 ;               are returned to.
"RTN","RORRP012",48,0)
 ;
"RTN","RORRP012",49,0)
 ; Return Values:
"RTN","RORRP012",50,0)
 ;
"RTN","RORRP012",51,0)
 ; The current dat/time (in internal FileMan format) is returned
"RTN","RORRP012",52,0)
 ; in the RESULTS(1). RESULTS(0) alwais contains 0.
"RTN","RORRP012",53,0)
 ;
"RTN","RORRP012",54,0)
GETSRVDT(RESULTS) ;
"RTN","RORRP012",55,0)
 S RESULTS(0)=0
"RTN","RORRP012",56,0)
 S RESULTS(1)=$$NOW^XLFDT
"RTN","RORRP012",57,0)
 Q
"RTN","RORRP012",58,0)
 ;
"RTN","RORRP012",59,0)
 ;***** RETURNS A LIST OF ITEMS FROM THE 'ROR LIST ITEM' FILE
"RTN","RORRP012",60,0)
 ; RPC: [ROR LIST ITEMS]
"RTN","RORRP012",61,0)
 ;
"RTN","RORRP012",62,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP012",63,0)
 ;               are returned to.
"RTN","RORRP012",64,0)
 ;
"RTN","RORRP012",65,0)
 ; REGIEN        Registry IEN
"RTN","RORRP012",66,0)
 ;
"RTN","RORRP012",67,0)
 ; TYPE          Type of the items:
"RTN","RORRP012",68,0)
 ;                 1  Reason for inactivation
"RTN","RORRP012",69,0)
 ;                 2  Supporting evidence
"RTN","RORRP012",70,0)
 ;                 3  Lab Group
"RTN","RORRP012",71,0)
 ;
"RTN","RORRP012",72,0)
 ; Return Values:
"RTN","RORRP012",73,0)
 ;
"RTN","RORRP012",74,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP012",75,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP012",76,0)
 ; details).
"RTN","RORRP012",77,0)
 ;
"RTN","RORRP012",78,0)
 ; Otherwise, number of items is returned in the RESULTS(0)
"RTN","RORRP012",79,0)
 ; and the subsequent nodes of the array contain the items.
"RTN","RORRP012",80,0)
 ; 
"RTN","RORRP012",81,0)
 ; RESULTS(0)            Number of item
"RTN","RORRP012",82,0)
 ;
"RTN","RORRP012",83,0)
 ; RESULTS(i)            List Item
"RTN","RORRP012",84,0)
 ;                         ^01: IEN
"RTN","RORRP012",85,0)
 ;                         ^02: Text
"RTN","RORRP012",86,0)
 ;                         ^03: Code
"RTN","RORRP012",87,0)
 ;
"RTN","RORRP012",88,0)
LSTITEMS(RESULTS,REGIEN,TYPE) ;
"RTN","RORRP012",89,0)
 N CNT,CODE,ITEMS,RC,RORERRDL
"RTN","RORRP012",90,0)
 D CLEAR^RORERR("LSTITEMS^RORRP012",1)
"RTN","RORRP012",91,0)
 K RESULTS  S RESULTS(0)=0
"RTN","RORRP012",92,0)
 ;--- Check the parameters
"RTN","RORRP012",93,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP012",94,0)
 . ;--- Registry IEN
"RTN","RORRP012",95,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP012",96,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP012",97,0)
 . S REGIEN=+REGIEN
"RTN","RORRP012",98,0)
 . ;--- Type
"RTN","RORRP012",99,0)
 . I $G(TYPE)'>0  D  Q
"RTN","RORRP012",100,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"TYPE",$G(TYPE))
"RTN","RORRP012",101,0)
 . S TYPE=+TYPE
"RTN","RORRP012",102,0)
 ;--- Load the list items
"RTN","RORRP012",103,0)
 S RC=$$ITEMLIST^RORUTL09(TYPE,REGIEN,.ITEMS)
"RTN","RORRP012",104,0)
 ;--- Populate the output array
"RTN","RORRP012",105,0)
 S CODE="",CNT=0
"RTN","RORRP012",106,0)
 F  S CODE=$O(ITEMS(CODE))  Q:CODE=""  D
"RTN","RORRP012",107,0)
 . S CNT=CNT+1,RESULTS(CNT)=$P(ITEMS(CODE),U,1,2)
"RTN","RORRP012",108,0)
 . S $P(RESULTS(CNT),U,3)=CODE
"RTN","RORRP012",109,0)
 S RESULTS(0)=CNT
"RTN","RORRP012",110,0)
 Q
"RTN","RORRP012",111,0)
 ;
"RTN","RORRP012",112,0)
 ;***** STORES THE VALUE OF THE GUI PARAMETER
"RTN","RORRP012",113,0)
 ; RPC: [ROR GUI PARAMETER SET]
"RTN","RORRP012",114,0)
 ;
"RTN","RORRP012",115,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP012",116,0)
 ;               are returned to.
"RTN","RORRP012",117,0)
 ;
"RTN","RORRP012",118,0)
 ; NAME          Name of the GUI parameter
"RTN","RORRP012",119,0)
 ;
"RTN","RORRP012",120,0)
 ; [ENTITY]      Entity that the parameter is associated with.
"RTN","RORRP012",121,0)
 ;               By default ($G(ENTITY)=""), the "USR" value is used
"RTN","RORRP012",122,0)
 ;               (see the DBIA #2263 for more details).
"RTN","RORRP012",123,0)
 ;
"RTN","RORRP012",124,0)
 ; [.]VALUE      Value of the parameter. It should be either a string
"RTN","RORRP012",125,0)
 ;               or a reference to a local array that contains a text
"RTN","RORRP012",126,0)
 ;               (prepared for a word-processing field).
"RTN","RORRP012",127,0)
 ;
"RTN","RORRP012",128,0)
 ;               The local array should not contain the 0 subscript
"RTN","RORRP012",129,0)
 ;               (it will not be stored).
"RTN","RORRP012",130,0)
 ;
"RTN","RORRP012",131,0)
 ;               You can use the "@" value to delete the parameter.
"RTN","RORRP012",132,0)
 ;
"RTN","RORRP012",133,0)
 ; Return Values:
"RTN","RORRP012",134,0)
 ;
"RTN","RORRP012",135,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP012",136,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP012",137,0)
 ;
"RTN","RORRP012",138,0)
 ; Otherwise, the RESULTS(0) will contain 0.
"RTN","RORRP012",139,0)
 ;
"RTN","RORRP012",140,0)
SETPARM(RESULTS,NAME,ENTITY,VALUE) ;
"RTN","RORRP012",141,0)
 N RC,RORERRDL,RORMSG,TMP  K RESULTS
"RTN","RORRP012",142,0)
 D CLEAR^RORERR("SETPARM^RORRP012",1)
"RTN","RORRP012",143,0)
 ;--- Check the parameters
"RTN","RORRP012",144,0)
 I $G(NAME)=""  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP012",145,0)
 . S RC=$$ERROR^RORERR(-88,,,,"NAME",$G(NAME))
"RTN","RORRP012",146,0)
 I '$D(VALUE)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP012",147,0)
 . S RC=$$ERROR^RORERR(-88,,,,"VALUE","<UNDEFINED>")
"RTN","RORRP012",148,0)
 S:$G(ENTITY)="" ENTITY="USR"
"RTN","RORRP012",149,0)
 ;--- Check for single-line parameter
"RTN","RORRP012",150,0)
 I $D(VALUE)=1,VALUE'="@"  S TMP=VALUE  K VALUE  S VALUE(1,0)=TMP
"RTN","RORRP012",151,0)
 ;--- Store the value
"RTN","RORRP012",152,0)
 D PUT^XPAR(ENTITY,"ROR GUI PARAMETER",NAME,.VALUE,.RORMSG)
"RTN","RORRP012",153,0)
 I $G(RORMSG)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP012",154,0)
 . S RC=$$ERROR^RORERR(-56,,RORINFO,,+RORMSG,"PUT^XPAR")
"RTN","RORRP012",155,0)
 S RESULTS=0
"RTN","RORRP012",156,0)
 Q
"RTN","RORRP012",157,0)
 ;
"RTN","RORRP012",158,0)
 ;***** CHECKS IF THE RESCHEDULING CODE IS VALID
"RTN","RORRP012",159,0)
 ; ROR: [ROR TASK VALIDATE RESCHEDULING]
"RTN","RORRP012",160,0)
 ;
"RTN","RORRP012",161,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP012",162,0)
 ;               are returned to.
"RTN","RORRP012",163,0)
 ;
"RTN","RORRP012",164,0)
 ; SCHCODE       Rescheduling code
"RTN","RORRP012",165,0)
 ;
"RTN","RORRP012",166,0)
 ; [SCHDT]       Date when a task is scheduled to run for the
"RTN","RORRP012",167,0)
 ;               first time (FileMan). By default (if $G(SCHDT)'>0),
"RTN","RORRP012",168,0)
 ;               the current date/time is used.
"RTN","RORRP012",169,0)
 ;
"RTN","RORRP012",170,0)
 ; Return Values:
"RTN","RORRP012",171,0)
 ;
"RTN","RORRP012",172,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP012",173,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP012",174,0)
 ;
"RTN","RORRP012",175,0)
 ; Otherwise, either 1 (the rescheduling code is valid) or 0 (the
"RTN","RORRP012",176,0)
 ; code is not valid) is returned in the RESULTS(0). If the code is
"RTN","RORRP012",177,0)
 ; valid then the next date/time to run the task (FileMan format)
"RTN","RORRP012",178,0)
 ; is returned in the RESULTS(1).
"RTN","RORRP012",179,0)
 ;
"RTN","RORRP012",180,0)
VALIDSCH(RESULTS,SCHCODE,SCHDT) ;
"RTN","RORRP012",181,0)
 N NEXT,RORMSG,TMP  K RESULTS
"RTN","RORRP012",182,0)
 I $G(SCHCODE)=""  S RESULTS(0)=1  Q
"RTN","RORRP012",183,0)
 S RESULTS(0)=0
"RTN","RORRP012",184,0)
 ;--- Check if the rescheduling code is correct
"RTN","RORRP012",185,0)
 S:$G(SCHDT)'>0 SCHDT=$$NOW^XLFDT
"RTN","RORRP012",186,0)
 S NEXT=$$SCH^XLFDT(SCHCODE,SCHDT,1)
"RTN","RORRP012",187,0)
 Q:NEXT'>0
"RTN","RORRP012",188,0)
 ;--- Make sure that a task will not be rescheduled in less
"RTN","RORRP012",189,0)
 ;--- than 60 seconds (to be able to delete it if necessary)
"RTN","RORRP012",190,0)
 S TMP=$$SCH^XLFDT(SCHCODE,NEXT,1)
"RTN","RORRP012",191,0)
 S:$$FMDIFF^XLFDT(TMP,NEXT,2)'<60 RESULTS(0)=1,RESULTS(1)=NEXT
"RTN","RORRP012",192,0)
 Q
"RTN","RORRP013")
0^13^B25493831
"RTN","RORRP013",1,0)
RORRP013 ;HCIOFO/SG - RPC: ACCESS & SECURITY ; 1/13/04 3:28pm
"RTN","RORRP013",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP013",3,0)
 ;
"RTN","RORRP013",4,0)
 Q
"RTN","RORRP013",5,0)
 ;
"RTN","RORRP013",6,0)
 ;***** RETURNS A LIST OF REGISTRIES ACCESSIBLE TO THE GUI USER
"RTN","RORRP013",7,0)
 ; RPC: [ROR GUI ACCESS]
"RTN","RORRP013",8,0)
 ;
"RTN","RORRP013",9,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP013",10,0)
 ;               are returned to.
"RTN","RORRP013",11,0)
 ;
"RTN","RORRP013",12,0)
 ; [USER]        User IEN in the NEW PERSON file. By default
"RTN","RORRP013",13,0)
 ;               (if $G(USER)'>0), the DUZ is used).
"RTN","RORRP013",14,0)
 ;
"RTN","RORRP013",15,0)
 ; Return Values:
"RTN","RORRP013",16,0)
 ;
"RTN","RORRP013",17,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP013",18,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP013",19,0)
 ;
"RTN","RORRP013",20,0)
 ; Otherwise, the RESULTS(0) will contain number of the registry
"RTN","RORRP013",21,0)
 ; descriptors returned in the subsequent nodes of the RESULTS array.
"RTN","RORRP013",22,0)
 ; If this value is equal to zero then the user has no access to any
"RTN","RORRP013",23,0)
 ; registries.
"RTN","RORRP013",24,0)
 ; 
"RTN","RORRP013",25,0)
 ; RESULTS(0)            Number of accessible registries
"RTN","RORRP013",26,0)
 ;
"RTN","RORRP013",27,0)
 ; RESULTS(i)            Registry descriptor
"RTN","RORRP013",28,0)
 ;                         ^01: Registry IEN
"RTN","RORRP013",29,0)
 ;                         ^02: Registry name
"RTN","RORRP013",30,0)
 ;                         ^03: Administrator? (0 or 1)
"RTN","RORRP013",31,0)
 ;                         ^04: Short description
"RTN","RORRP013",32,0)
 ;
"RTN","RORRP013",33,0)
ACREGLST(RESULTS,USER) ;
"RTN","RORRP013",34,0)
 N ADMIN,CNT,IENS,KEY,RC,REGIEN,RORBUF,RORERRDL,RORMSG,TMP
"RTN","RORRP013",35,0)
 D CLEAR^RORERR("ACREGLST^RORRP013",1)
"RTN","RORRP013",36,0)
 K RESULTS  S RESULTS(0)=0
"RTN","RORRP013",37,0)
 I $G(USER)'>0  S USER=+$G(DUZ)  Q:USER'>0
"RTN","RORRP013",38,0)
 ;
"RTN","RORRP013",39,0)
 S (CNT,RC,REGIEN)=0
"RTN","RORRP013",40,0)
 F  S REGIEN=$O(^ROR(798.1,"ACL",USER,REGIEN))  Q:REGIEN=""  D  Q:RC<0
"RTN","RORRP013",41,0)
 . Q:REGIEN'>0  S IENS=REGIEN_","  K RORBUF
"RTN","RORRP013",42,0)
 . D GETS^DIQ(798.1,IENS,".01;4",,"RORBUF","RORMSG")
"RTN","RORRP013",43,0)
 . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)  Q
"RTN","RORRP013",44,0)
 . ;--- ??? Until the GUI is ready ???
"RTN","RORRP013",45,0)
 . Q:$G(RORBUF(798.1,IENS,.01))'="VA ICR"
"RTN","RORRP013",46,0)
 . ;--- Add the registry descriptor to the list
"RTN","RORRP013",47,0)
 . S CNT=CNT+1,RESULTS(CNT)=REGIEN_"^"_$G(RORBUF(798.1,IENS,.01))
"RTN","RORRP013",48,0)
 . S $P(RESULTS(CNT),"^",4)=$G(RORBUF(798.1,IENS,4))
"RTN","RORRP013",49,0)
 . ;--- Check if the user has the administrator security key
"RTN","RORRP013",50,0)
 . S KEY="",ADMIN=0
"RTN","RORRP013",51,0)
 . F  S KEY=$O(^ROR(798.1,"ACL",USER,REGIEN,KEY))  Q:KEY=""  D  Q:RC<0
"RTN","RORRP013",52,0)
 . . I KEY?1"ROR"1.E  S:KEY["ADMIN" ADMIN=1
"RTN","RORRP013",53,0)
 . S $P(RESULTS(CNT),"^",3)=ADMIN
"RTN","RORRP013",54,0)
 ;
"RTN","RORRP013",55,0)
 I RC'<0  D:CNT'>0  S RESULTS(0)=CNT
"RTN","RORRP013",56,0)
 . D ACVIOLTN^RORLOG(-91)  ; Record the access violation
"RTN","RORRP013",57,0)
 E  D RPCSTK^RORERR(.RESULTS,RC)
"RTN","RORRP013",58,0)
 Q
"RTN","RORRP013",59,0)
 ;
"RTN","RORRP013",60,0)
 ;***** RETURNS THE LIST OF ACCESS VIOLATIONS
"RTN","RORRP013",61,0)
 ; RPC: [ROR LOG GET ACCESS VIOLATIONS]
"RTN","RORRP013",62,0)
 ;
"RTN","RORRP013",63,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP013",64,0)
 ;               are returned to.
"RTN","RORRP013",65,0)
 ;
"RTN","RORRP013",66,0)
 ; [STDT]        Start date (by default, from the earliest violation)
"RTN","RORRP013",67,0)
 ; [ENDT]        End date (by default, to the latest violation)
"RTN","RORRP013",68,0)
 ;
"RTN","RORRP013",69,0)
 ; The ^TMP($J,"RORRP013") global node is used by the procedure.
"RTN","RORRP013",70,0)
 ;
"RTN","RORRP013",71,0)
 ; Return Values:
"RTN","RORRP013",72,0)
 ;
"RTN","RORRP013",73,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP013",74,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP013",75,0)
 ;
"RTN","RORRP013",76,0)
 ; Otherwise, number of logs is returned in the RESULTS(0) and the
"RTN","RORRP013",77,0)
 ; subsequent nodes of the RESULTS array contain the violations.
"RTN","RORRP013",78,0)
 ; 
"RTN","RORRP013",79,0)
 ; @RESULTS@(0)          Number of access violations
"RTN","RORRP013",80,0)
 ;
"RTN","RORRP013",81,0)
 ; @RESULTS@(i)          Access violation descriptor
"RTN","RORRP013",82,0)
 ;                         ^01: Date/Time (int)
"RTN","RORRP013",83,0)
 ;                         ^02: User Name
"RTN","RORRP013",84,0)
 ;                         ^03: User IEN
"RTN","RORRP013",85,0)
 ;                         ^04: Message
"RTN","RORRP013",86,0)
 ;
"RTN","RORRP013",87,0)
AVLIST(RESULTS,STDT,ENDT) ;
"RTN","RORRP013",88,0)
 N BUF,CNT,DATE,IEN,IENS,RC,ROOT,RORBUF,RORERRDL,RORMSG
"RTN","RORRP013",89,0)
 D CLEAR^RORERR("AVLIST^RORRP013",1)
"RTN","RORRP013",90,0)
 ;--- Check the parameters
"RTN","RORRP013",91,0)
 S STDT=$G(STDT)\1,ENDT=$G(ENDT)\1
"RTN","RORRP013",92,0)
 S ENDT=$S(ENDT>0:$$FMADD^XLFDT(ENDT,1),1:9999999)
"RTN","RORRP013",93,0)
 ;--- Initialize the variables
"RTN","RORRP013",94,0)
 S ROOT=$$ROOT^DILFD(798.7,,1),CNT=0
"RTN","RORRP013",95,0)
 K RESULTS  S RESULTS=$NA(^TMP($J,"RORRP013"))  K @RESULTS
"RTN","RORRP013",96,0)
 ;--- Browse through the logs
"RTN","RORRP013",97,0)
 S DATE=STDT
"RTN","RORRP013",98,0)
 F  S DATE=$O(@ROOT@("B",DATE))  Q:DATE=""  Q:DATE'<ENDT  D
"RTN","RORRP013",99,0)
 . S IEN=0
"RTN","RORRP013",100,0)
 . F  S IEN=$O(@ROOT@("B",DATE,IEN))  Q:IEN'>0  D
"RTN","RORRP013",101,0)
 . . S IENS=IEN_","  K RORBUF
"RTN","RORRP013",102,0)
 . . D GETS^DIQ(798.7,IENS,".01;1;7","EI","RORBUF","RORMSG")
"RTN","RORRP013",103,0)
 . . Q:$G(DIERR)
"RTN","RORRP013",104,0)
 . . ;--- Check for the 'Access Violation' Activity
"RTN","RORRP013",105,0)
 . . Q:$G(RORBUF(798.7,IENS,1,"I"))'=6
"RTN","RORRP013",106,0)
 . . ;--- Date/Time of the event
"RTN","RORRP013",107,0)
 . . S BUF=$G(RORBUF(798.7,IENS,.01,"I"))
"RTN","RORRP013",108,0)
 . . ;--- User Name (ext)
"RTN","RORRP013",109,0)
 . . S $P(BUF,"^",2)=$G(RORBUF(798.7,IENS,7,"E"))
"RTN","RORRP013",110,0)
 . . ;--- User IEN (int)
"RTN","RORRP013",111,0)
 . . S $P(BUF,"^",3)=$G(RORBUF(798.7,IENS,7,"I"))
"RTN","RORRP013",112,0)
 . . ;--- Message
"RTN","RORRP013",113,0)
 . . S $P(BUF,"^",4)=$$GET1^DIQ(798.74,"1,"_IENS,2,,,"RORMSG")
"RTN","RORRP013",114,0)
 . . ;--- Add the record to the output
"RTN","RORRP013",115,0)
 . . S CNT=CNT+1,@RESULTS@(CNT)=BUF
"RTN","RORRP013",116,0)
 ;--- Number of violations
"RTN","RORRP013",117,0)
 S @RESULTS@(0)=CNT
"RTN","RORRP013",118,0)
 Q
"RTN","RORRP013",119,0)
 ;
"RTN","RORRP013",120,0)
 ;***** ADDS THE USERS WHO HAVE THE SECURITY KEY TO THE LIST
"RTN","RORRP013",121,0)
 ;
"RTN","RORRP013",122,0)
 ; KEYNAME       Name of the security key
"RTN","RORRP013",123,0)
 ; ACCESS        Level of the user access to the registry
"RTN","RORRP013",124,0)
 ;               (1-User, 2-Administrator, 3-IRM)
"RTN","RORRP013",125,0)
 ;
"RTN","RORRP013",126,0)
 ; Return Values:
"RTN","RORRP013",127,0)
 ;
"RTN","RORRP013",128,0)
 ; The list is stored in the ^TMP($J,"RORRP013U") global node.
"RTN","RORRP013",129,0)
 ;
"RTN","RORRP013",130,0)
KLIST(KEYNAME,ACCESS) ;
"RTN","RORRP013",131,0)
 N IEN  S IEN=0
"RTN","RORRP013",132,0)
 F  S IEN=$O(^XUSEC(KEYNAME,IEN))  Q:IEN'>0  D
"RTN","RORRP013",133,0)
 . S $P(^TMP($J,"RORRP013U",IEN,0),"^",ACCESS)=1
"RTN","RORRP013",134,0)
 Q
"RTN","RORRP013",135,0)
 ;
"RTN","RORRP013",136,0)
 ;***** RETURNS THE LIST OF REGISTRY USERS
"RTN","RORRP013",137,0)
 ; RPC: [ROR GET REGISTRY USERS]
"RTN","RORRP013",138,0)
 ;
"RTN","RORRP013",139,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP013",140,0)
 ;               are returned to.
"RTN","RORRP013",141,0)
 ;
"RTN","RORRP013",142,0)
 ; REGIEN        Registry IEN
"RTN","RORRP013",143,0)
 ;
"RTN","RORRP013",144,0)
 ; The ^TMP($J,"RORRP013") and ^TMP($J,"RORRP013U") global nodes
"RTN","RORRP013",145,0)
 ; are used by the procedure.
"RTN","RORRP013",146,0)
 ;
"RTN","RORRP013",147,0)
 ; Return Values:
"RTN","RORRP013",148,0)
 ;
"RTN","RORRP013",149,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP013",150,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP013",151,0)
 ;
"RTN","RORRP013",152,0)
 ; Otherwise, number of users is returned in the RESULTS(0) and the
"RTN","RORRP013",153,0)
 ; subsequent nodes of the RESULTS array contain the users.
"RTN","RORRP013",154,0)
 ; 
"RTN","RORRP013",155,0)
 ; @RESULTS@(0)          Number of users
"RTN","RORRP013",156,0)
 ;
"RTN","RORRP013",157,0)
 ; @RESULTS@(i)          User descriptor
"RTN","RORRP013",158,0)
 ;                         ^01: User IEN (DUZ)
"RTN","RORRP013",159,0)
 ;                         ^02: User Name
"RTN","RORRP013",160,0)
 ;                         ^03: User          (0/1)
"RTN","RORRP013",161,0)
 ;                         ^04: Administrator (0/1)
"RTN","RORRP013",162,0)
 ;                         ^05: IRM           (0/1)
"RTN","RORRP013",163,0)
 ;
"RTN","RORRP013",164,0)
USERLIST(RESULTS,REGIEN) ;
"RTN","RORRP013",165,0)
 N ACCESS,ADMIN,CNT,IEN,NAME,RORERRDL,RORMSG
"RTN","RORRP013",166,0)
 D CLEAR^RORERR("USERLIST^RORRP013",1)
"RTN","RORRP013",167,0)
 ;--- Check the parameters
"RTN","RORRP013",168,0)
 I $G(REGIEN)'>0  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP013",169,0)
 . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP013",170,0)
 S REGIEN=+REGIEN
"RTN","RORRP013",171,0)
 ;--- Initialize the variables
"RTN","RORRP013",172,0)
 K ^TMP($J,"RORRP013U")
"RTN","RORRP013",173,0)
 K RESULTS  S RESULTS=$NA(^TMP($J,"RORRP013"))  K @RESULTS
"RTN","RORRP013",174,0)
 ;--- Browse the security keys
"RTN","RORRP013",175,0)
 S NAME=""
"RTN","RORRP013",176,0)
 F  S NAME=$O(^ROR(798.1,REGIEN,18,"B",NAME))  Q:NAME=""  D
"RTN","RORRP013",177,0)
 . S ADMIN=(NAME?1"ROR"1.E)&(NAME["ADMIN")
"RTN","RORRP013",178,0)
 . D KLIST(NAME,$S(ADMIN:2,1:1))
"RTN","RORRP013",179,0)
 ;--- Add the authorized IRM personnel
"RTN","RORRP013",180,0)
 D KLIST("ROR VA IRM",3)
"RTN","RORRP013",181,0)
 ;--- Sort the users by their names
"RTN","RORRP013",182,0)
 S IEN=0
"RTN","RORRP013",183,0)
 F  S IEN=$O(^TMP($J,"RORRP013U",IEN))  Q:IEN'>0  D
"RTN","RORRP013",184,0)
 . S NAME=$$GET1^DIQ(200,IEN_",",.01,,,"RORMSG")
"RTN","RORRP013",185,0)
 . S:NAME'="" ^TMP($J,"RORRP013U","B",NAME,IEN)=""
"RTN","RORRP013",186,0)
 ;--- Generate the output
"RTN","RORRP013",187,0)
 S NAME="",CNT=0
"RTN","RORRP013",188,0)
 F  S NAME=$O(^TMP($J,"RORRP013U","B",NAME)) Q:NAME=""  D
"RTN","RORRP013",189,0)
 . S IEN=0
"RTN","RORRP013",190,0)
 . F  S IEN=$O(^TMP($J,"RORRP013U","B",NAME,IEN)) Q:IEN'>0  D
"RTN","RORRP013",191,0)
 . . S ACCESS=$G(^TMP($J,"RORRP013U",IEN,0))
"RTN","RORRP013",192,0)
 . . S CNT=CNT+1,@RESULTS@(CNT)=IEN_"^"_NAME_"^"_ACCESS
"RTN","RORRP013",193,0)
 S @RESULTS@(0)=CNT
"RTN","RORRP013",194,0)
 ;--- Cleanup
"RTN","RORRP013",195,0)
 K ^TMP($J,"RORRP013U")
"RTN","RORRP013",196,0)
 Q
"RTN","RORRP014")
0^14^B7729423
"RTN","RORRP014",1,0)
RORRP014 ;HCIOFO/SG - RPC: REGISTRY INFO & PARAMETERS ; 4/9/03 10:19am
"RTN","RORRP014",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP014",3,0)
 ;
"RTN","RORRP014",4,0)
 Q
"RTN","RORRP014",5,0)
 ;
"RTN","RORRP014",6,0)
 ;***** RETURNS THE REGISTRY INFORMATION
"RTN","RORRP014",7,0)
 ; RPC: [ROR GET REGISTRY INFO]
"RTN","RORRP014",8,0)
 ;
"RTN","RORRP014",9,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP014",10,0)
 ;               are returned to.
"RTN","RORRP014",11,0)
 ;
"RTN","RORRP014",12,0)
 ; REGISTRY      Either a registry IEN or a registry name
"RTN","RORRP014",13,0)
 ;
"RTN","RORRP014",14,0)
 ; Return Values:
"RTN","RORRP014",15,0)
 ;
"RTN","RORRP014",16,0)
 ; A negative value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP014",17,0)
 ; an error (see the RPCSTK^RORERR procedure for more details).
"RTN","RORRP014",18,0)
 ;
"RTN","RORRP014",19,0)
 ; Otherwise, 0 is returned in the RESULTS(0) and the subsequent
"RTN","RORRP014",20,0)
 ; nodes of the RESULTS array contain the registry information.
"RTN","RORRP014",21,0)
 ; 
"RTN","RORRP014",22,0)
 ; RESULTS(0)            0
"RTN","RORRP014",23,0)
 ;
"RTN","RORRP014",24,0)
 ; RESULTS(1)            Registry
"RTN","RORRP014",25,0)
 ;                         ^01: IEN
"RTN","RORRP014",26,0)
 ;                         ^02: Name
"RTN","RORRP014",27,0)
 ;
"RTN","RORRP014",28,0)
 ; RESULTS(2)            National (0/1)
"RTN","RORRP014",29,0)
 ;
"RTN","RORRP014",30,0)
 ; RESULTS(3)            Registry Description
"RTN","RORRP014",31,0)
 ;
"RTN","RORRP014",32,0)
 ; RESULTS(4)            Last registry update date (int)
"RTN","RORRP014",33,0)
 ;
"RTN","RORRP014",34,0)
 ; RESULTS(5)            Last data extraction date (int)
"RTN","RORRP014",35,0)
 ;
"RTN","RORRP014",36,0)
 ; RESULTS(6)            Number of Patients
"RTN","RORRP014",37,0)
 ;
"RTN","RORRP014",38,0)
 ; RESULTS(7)            Number of Active Patients
"RTN","RORRP014",39,0)
 ;
"RTN","RORRP014",40,0)
 ; RESULTS(8)            Registry Status
"RTN","RORRP014",41,0)
 ;                         ^01: Internal value (0-Active, 1-Inactive)
"RTN","RORRP014",42,0)
 ;                         ^02: External value
"RTN","RORRP014",43,0)
 ;
"RTN","RORRP014",44,0)
 ; RESULTS(9)            Awaiting Acknowledgement
"RTN","RORRP014",45,0)
 ;                         ^01: Date/Time (internal)
"RTN","RORRP014",46,0)
 ;                         ^02: Message ID
"RTN","RORRP014",47,0)
 ;
"RTN","RORRP014",48,0)
 ; RESULTS(10)           Version information
"RTN","RORRP014",49,0)
 ;                         ^01: Package version
"RTN","RORRP014",50,0)
 ;                         ^02: Latest patch number
"RTN","RORRP014",51,0)
 ;                         ^03: Date of the latest patch (int)
"RTN","RORRP014",52,0)
 ;
"RTN","RORRP014",53,0)
REGINFO(RESULTS,REGISTRY) ;
"RTN","RORRP014",54,0)
 N IENS,RC,REGIEN,RORBUF,RORERRDL,RORMSG,TMP
"RTN","RORRP014",55,0)
 D CLEAR^RORERR("REGINFO^RORRP014",1)
"RTN","RORRP014",56,0)
 ;--- Check the parameters
"RTN","RORRP014",57,0)
 S TMP=$$UP^XLFSTR($G(REGISTRY)),REGIEN=+TMP
"RTN","RORRP014",58,0)
 I TMP'=REGIEN  D:TMP?3.UNP
"RTN","RORRP014",59,0)
 . S REGIEN=$$REGIEN^RORUTL02(TMP)
"RTN","RORRP014",60,0)
 . S:REGIEN<0 TMP=$$ERROR^RORERR(REGIEN)
"RTN","RORRP014",61,0)
 I REGIEN'>0  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP014",62,0)
 . S RC=$$ERROR^RORERR(-88,,,,"REGISTRY",$G(REGISTRY))
"RTN","RORRP014",63,0)
 ;--- Initialize the variables
"RTN","RORRP014",64,0)
 K RESULTS
"RTN","RORRP014",65,0)
 ;--- Load the registry info
"RTN","RORRP014",66,0)
 S IENS=REGIEN_",",TMP=".01;.09;1;2;2.2;2.3;4;11;19.1;19.2"
"RTN","RORRP014",67,0)
 D GETS^DIQ(798.1,IENS,TMP,"I","RORBUF","RORMSG")
"RTN","RORRP014",68,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP014",69,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","RORRP014",70,0)
 ;--- Registry IEN and Name
"RTN","RORRP014",71,0)
 S RESULTS(1)=REGIEN_"^"_$G(RORBUF(798.1,IENS,.01,"I"))
"RTN","RORRP014",72,0)
 ;--- National
"RTN","RORRP014",73,0)
 S RESULTS(2)=+$G(RORBUF(798.1,IENS,.09,"I"))
"RTN","RORRP014",74,0)
 ;--- Registry Description
"RTN","RORRP014",75,0)
 S RESULTS(3)=$G(RORBUF(798.1,IENS,4,"I"))
"RTN","RORRP014",76,0)
 ;--- Registry Updated Until
"RTN","RORRP014",77,0)
 S RESULTS(4)=$G(RORBUF(798.1,IENS,1,"I"))
"RTN","RORRP014",78,0)
 ;--- Data Extracted Until
"RTN","RORRP014",79,0)
 S RESULTS(5)=$G(RORBUF(798.1,IENS,2,"I"))
"RTN","RORRP014",80,0)
 ;--- Number of Patients
"RTN","RORRP014",81,0)
 S RESULTS(6)=+$G(RORBUF(798.1,IENS,19.1,"I"))
"RTN","RORRP014",82,0)
 ;--- Number of Active Patients
"RTN","RORRP014",83,0)
 S RESULTS(7)=+$G(RORBUF(798.1,IENS,19.2,"I"))
"RTN","RORRP014",84,0)
 ;--- Registry Status
"RTN","RORRP014",85,0)
 S TMP=+$G(RORBUF(798.1,IENS,11,"I"))
"RTN","RORRP014",86,0)
 S $P(TMP,"^",2)=$$EXTERNAL^DILFD(798.1,11,,TMP,"RORMSG")
"RTN","RORRP014",87,0)
 S RESULTS(8)=TMP
"RTN","RORRP014",88,0)
 ;--- Awaiting Acknowledgement
"RTN","RORRP014",89,0)
 S RESULTS(9)=$G(RORBUF(798.1,IENS,2.2,"I"))
"RTN","RORRP014",90,0)
 S:RESULTS(9)>0 $P(RESULTS(9),"^",2)=$G(RORBUF(798.1,IENS,2.3,"I"))
"RTN","RORRP014",91,0)
 ;--- Version information
"RTN","RORRP014",92,0)
 S TMP="CLINICAL CASE REGISTRIES"
"RTN","RORRP014",93,0)
 S RESULTS(10)=$$VERSION^XPDUTL(TMP),TMP=$$LAST^XPDUTL(TMP)
"RTN","RORRP014",94,0)
 S:TMP>0 $P(RESULTS(10),"^",2,3)=+TMP_"^"_$P(TMP,U,2)
"RTN","RORRP014",95,0)
 ;---
"RTN","RORRP014",96,0)
 S RESULTS(0)=0
"RTN","RORRP014",97,0)
 Q
"RTN","RORRP015")
0^27^B22373114
"RTN","RORRP015",1,0)
RORRP015 ;HCIOFO/SG - RPC: DIVISIONS AND HOSPITAL LOCATIONS ; 9/19/03 1:14pm
"RTN","RORRP015",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP015",3,0)
 ;
"RTN","RORRP015",4,0)
 ; This routine uses the following IAs:
"RTN","RORRP015",5,0)
 ;
"RTN","RORRP015",6,0)
 ; #????         Access to the file #40.8 (???: 3433)
"RTN","RORRP015",7,0)
 ; #1246         WIN^DGPMDDCF (supported)
"RTN","RORRP015",8,0)
 ; #10040        Access to the HOSPITAL LOCATION file (supported)
"RTN","RORRP015",9,0)
 ; #908    ???   Get DIVISION from HOSPITAL LOCATION
"RTN","RORRP015",10,0)
 ;
"RTN","RORRP015",11,0)
 Q
"RTN","RORRP015",12,0)
 ;
"RTN","RORRP015",13,0)
 ;***** CHECKS IF THE HOSPITAL LOCATION IS ACTIVE
"RTN","RORRP015",14,0)
 ;
"RTN","RORRP015",15,0)
 ; LOCIEN        IEN of the hospital location
"RTN","RORRP015",16,0)
 ;
"RTN","RORRP015",17,0)
ACTLOC(LOCIEN) ;
"RTN","RORRP015",18,0)
 N D0,DGPMOS,RDT,X
"RTN","RORRP015",19,0)
 Q:$G(^SC(LOCIEN,"OOS")) 0              ; An OOS entry
"RTN","RORRP015",20,0)
 S D0=+$G(^SC(LOCIEN,42))
"RTN","RORRP015",21,0)
 I D0>0  D WIN^DGPMDDCF  Q 'X           ; Check if ward is inactive
"RTN","RORRP015",22,0)
 S X=$G(^SC(LOCIEN,"I"))  Q:'$P(X,U) 1  ; No inactivation date
"RTN","RORRP015",23,0)
 S RDT=+$P(X,U,2)
"RTN","RORRP015",24,0)
 I DT>$P(X,U)  Q:'RDT!(DT<RDT) 0        ; Check reactivation date
"RTN","RORRP015",25,0)
 Q 1
"RTN","RORRP015",26,0)
 ;
"RTN","RORRP015",27,0)
 ;***** RETURNS THE LIST OF DIVISIONS
"RTN","RORRP015",28,0)
 ; RPC: [ROR LIST DIVISIONS]
"RTN","RORRP015",29,0)
 ;
"RTN","RORRP015",30,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP015",31,0)
 ;               are returned to.
"RTN","RORRP015",32,0)
 ;
"RTN","RORRP015",33,0)
 ; [PART]        The partial match restriction.
"RTN","RORRP015",34,0)
 ;
"RTN","RORRP015",35,0)
 ; [FLAGS]       Flags that control the execution (can be combined)
"RTN","RORRP015",36,0)
 ;                 B  Backwards. Traverses the index in the opposite
"RTN","RORRP015",37,0)
 ;                    direction of normal traversal.
"RTN","RORRP015",38,0)
 ;
"RTN","RORRP015",39,0)
 ; [NUMBER]      Maximum number of entries to return. A value of "*"
"RTN","RORRP015",40,0)
 ;               or no value in this parameter designates all entries.
"RTN","RORRP015",41,0)
 ;
"RTN","RORRP015",42,0)
 ; [FROM]        The index entry(s) from which to begin the list
"RTN","RORRP015",43,0)
 ;                 ^01: FromName
"RTN","RORRP015",44,0)
 ;                 ^02: FromIEN
"RTN","RORRP015",45,0)
 ;
"RTN","RORRP015",46,0)
 ;               For example, a FROM value of "VA" would list entries
"RTN","RORRP015",47,0)
 ;               following VA. You can use the 2-nd and 3-rd "^"-
"RTN","RORRP015",48,0)
 ;               pieces of the @RESULTS@(0) node to continue the
"RTN","RORRP015",49,0)
 ;               listing in the subsequent procedure calls.
"RTN","RORRP015",50,0)
 ;
"RTN","RORRP015",51,0)
 ;               NOTE: The FROM value itself is not included in
"RTN","RORRP015",52,0)
 ;                     the resulting list.
"RTN","RORRP015",53,0)
 ;
"RTN","RORRP015",54,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP015",55,0)
 ;
"RTN","RORRP015",56,0)
 ; See description of the LIST^DIC for more details about the
"RTN","RORRP015",57,0)
 ; PART, NUMBER and FROM parameters.
"RTN","RORRP015",58,0)
 ;
"RTN","RORRP015",59,0)
 ; Return Values:
"RTN","RORRP015",60,0)
 ;
"RTN","RORRP015",61,0)
 ; A negative value of the first "^"-piece of the @RESULTS@(0)
"RTN","RORRP015",62,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP015",63,0)
 ; details).
"RTN","RORRP015",64,0)
 ;
"RTN","RORRP015",65,0)
 ; Otherwise, number of divisions and the value of the FROM parameter
"RTN","RORRP015",66,0)
 ; for the next procedure call are returned in the @RESULTS@(0) and
"RTN","RORRP015",67,0)
 ; the subsequent nodes of the global array contain the divisions.
"RTN","RORRP015",68,0)
 ; 
"RTN","RORRP015",69,0)
 ; @RESULTS@(0)          Result Descriptor
"RTN","RORRP015",70,0)
 ;                         ^01: Number of divisions
"RTN","RORRP015",71,0)
 ;                         ^02: FromName
"RTN","RORRP015",72,0)
 ;                         ^03: FromIEN
"RTN","RORRP015",73,0)
 ;
"RTN","RORRP015",74,0)
 ; @RESULTS@(i)          Division
"RTN","RORRP015",75,0)
 ;                         ^01: IEN
"RTN","RORRP015",76,0)
 ;                         ^02: Name
"RTN","RORRP015",77,0)
 ;                         ^03: Facility Number
"RTN","RORRP015",78,0)
 ;                         ^04: Institution IEN
"RTN","RORRP015",79,0)
 ;
"RTN","RORRP015",80,0)
DIVLIST(RESULTS,PART,FLAGS,NUMBER,FROM) ;
"RTN","RORRP015",81,0)
 N BUF,RC,RORERRDL,RORMSG,TMP
"RTN","RORRP015",82,0)
 D CLEAR^RORERR("DIVLIST^RORRP015",1)
"RTN","RORRP015",83,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP015",84,0)
 ;--- Check the parameters
"RTN","RORRP015",85,0)
 S PART=$G(PART),FLAGS=$G(FLAGS)
"RTN","RORRP015",86,0)
 S NUMBER=$S($G(NUMBER)>0:+NUMBER,1:"*")
"RTN","RORRP015",87,0)
 ;--- Setup the start point
"RTN","RORRP015",88,0)
 I $G(FROM)'=""  D  S FROM=$P(FROM,U)
"RTN","RORRP015",89,0)
 . S:$P(FROM,U,2)>0 FROM("IEN")=+$P(FROM,U,2)
"RTN","RORRP015",90,0)
 ;--- Get the list of divisions
"RTN","RORRP015",91,0)
 S BUF="@;.01;1;.07I",TMP="P"_$S(FLAGS["B":"B",1:"")
"RTN","RORRP015",92,0)
 D LIST^DIC(40.8,,BUF,TMP,NUMBER,.FROM,PART,"B",,,,"RORMSG")
"RTN","RORRP015",93,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP015",94,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,40.8)
"RTN","RORRP015",95,0)
 . K ^TMP("DILIST",$J)
"RTN","RORRP015",96,0)
 ;--- Success
"RTN","RORRP015",97,0)
 S TMP=$G(^TMP("DILIST",$J,0)),BUF=+$P(TMP,U)
"RTN","RORRP015",98,0)
 K ^TMP("DILIST",$J,0)
"RTN","RORRP015",99,0)
 S:$P(TMP,U,3) $P(BUF,U,2,3)=$G(FROM)_U_$G(FROM("IEN"))
"RTN","RORRP015",100,0)
 S @RESULTS@(0)=BUF
"RTN","RORRP015",101,0)
 Q
"RTN","RORRP015",102,0)
 ;
"RTN","RORRP015",103,0)
 ;***** RETURNS THE LIST OF HOSPITAL LOCATIONS
"RTN","RORRP015",104,0)
 ; RPC: [ROR LIST HOSPITAL LOCATIONS]
"RTN","RORRP015",105,0)
 ;
"RTN","RORRP015",106,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP015",107,0)
 ;               are returned to.
"RTN","RORRP015",108,0)
 ;
"RTN","RORRP015",109,0)
 ; [HLTYPES]     List of location types separated by commas (internal
"RTN","RORRP015",110,0)
 ;               values of the TYPE field of the HOSPITAL LOCATION
"RTN","RORRP015",111,0)
 ;               file). Only locations of the types defined by this
"RTN","RORRP015",112,0)
 ;               parameter are selected by the procedure. By default
"RTN","RORRP015",113,0)
 ;               ($G(HLTYPES)=""), all locations are selected.
"RTN","RORRP015",114,0)
 ;
"RTN","RORRP015",115,0)
 ; [DIVIEN]      Division IEN. If this parameter is defined and
"RTN","RORRP015",116,0)
 ;               greater than zero then only the locations associated 
"RTN","RORRP015",117,0)
 ;               with this division will be selected.
"RTN","RORRP015",118,0)
 ;
"RTN","RORRP015",119,0)
 ; [PART]        The partial match restriction.
"RTN","RORRP015",120,0)
 ;
"RTN","RORRP015",121,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORRP015",122,0)
 ;                 A  Include active locations (default)
"RTN","RORRP015",123,0)
 ;                 B  Backwards. Traverses the index in the opposite
"RTN","RORRP015",124,0)
 ;                    direction of normal traversal.
"RTN","RORRP015",125,0)
 ;                 I  Include inactive locations
"RTN","RORRP015",126,0)
 ;
"RTN","RORRP015",127,0)
 ; [NUMBER]      Maximum number of entries to return. A value of "*"
"RTN","RORRP015",128,0)
 ;               or no value in this parameter designates all entries.
"RTN","RORRP015",129,0)
 ;
"RTN","RORRP015",130,0)
 ; [FROM]        The index entry(s) from which to begin the list
"RTN","RORRP015",131,0)
 ;                 ^01: FromName
"RTN","RORRP015",132,0)
 ;                 ^02: FromIEN
"RTN","RORRP015",133,0)
 ;
"RTN","RORRP015",134,0)
 ;               For example, a FROM value of "VA" would list entries
"RTN","RORRP015",135,0)
 ;               following VA. You can use the 2-nd and 3-rd "^"-
"RTN","RORRP015",136,0)
 ;               pieces of the @RESULTS@(0) node to continue the
"RTN","RORRP015",137,0)
 ;               listing in the subsequent procedure calls.
"RTN","RORRP015",138,0)
 ;
"RTN","RORRP015",139,0)
 ;               NOTE: The FROM value itself is not included in
"RTN","RORRP015",140,0)
 ;                     the resulting list.
"RTN","RORRP015",141,0)
 ;
"RTN","RORRP015",142,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP015",143,0)
 ;
"RTN","RORRP015",144,0)
 ; See description of the LIST^DIC for more details about the
"RTN","RORRP015",145,0)
 ; PART, NUMBER and FROM parameters.
"RTN","RORRP015",146,0)
 ;
"RTN","RORRP015",147,0)
 ; Return Values:
"RTN","RORRP015",148,0)
 ;
"RTN","RORRP015",149,0)
 ; A negative value of the first "^"-piece of the @RESULTS@(0)
"RTN","RORRP015",150,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP015",151,0)
 ; details).
"RTN","RORRP015",152,0)
 ;
"RTN","RORRP015",153,0)
 ; Otherwise, number of hospital locations and the value of the
"RTN","RORRP015",154,0)
 ; FROM parameter for the next procedure call are returned in
"RTN","RORRP015",155,0)
 ; the @RESULTS@(0) and the subsequent nodes of the global array
"RTN","RORRP015",156,0)
 ; contain the locations.
"RTN","RORRP015",157,0)
 ; 
"RTN","RORRP015",158,0)
 ; @RESULTS@(0)          Result Descriptor
"RTN","RORRP015",159,0)
 ;                         ^01: Number of locations
"RTN","RORRP015",160,0)
 ;                         ^02: FromName
"RTN","RORRP015",161,0)
 ;                         ^03: FromIEN
"RTN","RORRP015",162,0)
 ;
"RTN","RORRP015",163,0)
 ; @RESULTS@(i)          Hospital Location
"RTN","RORRP015",164,0)
 ;                         ^01: IEN
"RTN","RORRP015",165,0)
 ;                         ^02: Name
"RTN","RORRP015",166,0)
 ;                         ^03: Type (internal)
"RTN","RORRP015",167,0)
 ;                         ^04: Institution IEN
"RTN","RORRP015",168,0)
 ;                         ^05: Division IEN
"RTN","RORRP015",169,0)
 ;                         ^06: Active (0/1)
"RTN","RORRP015",170,0)
 ;
"RTN","RORRP015",171,0)
 ; NOTE: The 6th "^"-piece of the location record (Active) is
"RTN","RORRP015",172,0)
 ;       populated only if both "A" and "I" flags are used.
"RTN","RORRP015",173,0)
 ;
"RTN","RORRP015",174,0)
HLOCLIST(RESULTS,HLTYPES,DIVIEN,PART,FLAGS,NUMBER,FROM) ;
"RTN","RORRP015",175,0)
 N BUF,I,RC,RORERRDL,RORHLT,RORMSG,SCR,TMP
"RTN","RORRP015",176,0)
 D CLEAR^RORERR("HLOCLIST^RORRP015",1)
"RTN","RORRP015",177,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP015",178,0)
 ;--- Check the parameters
"RTN","RORRP015",179,0)
 S HLTYPES=$$UP^XLFSTR($TR($G(HLTYPES)," "))
"RTN","RORRP015",180,0)
 F I=1:1  S TMP=$P(HLTYPES,",",I)  Q:TMP=""  S RORHLT(TMP)=""
"RTN","RORRP015",181,0)
 S DIVIEN=$S($G(DIVIEN)>0:+DIVIEN,1:0)
"RTN","RORRP015",182,0)
 S PART=$G(PART),FLAGS=$G(FLAGS)
"RTN","RORRP015",183,0)
 S NUMBER=$S($G(NUMBER)>0:+NUMBER,1:"*")
"RTN","RORRP015",184,0)
 ;--- If neither "A" nor "I" flag is provided, add the "A" (default)
"RTN","RORRP015",185,0)
 S:$TR(FLAGS,"AI")=FLAGS FLAGS=FLAGS_"A"
"RTN","RORRP015",186,0)
 ;--- Setup the start point
"RTN","RORRP015",187,0)
 I $G(FROM)'=""  D  S FROM=$P(FROM,U)
"RTN","RORRP015",188,0)
 . S:$P(FROM,U,2)>0 FROM("IEN")=+$P(FROM,U,2)
"RTN","RORRP015",189,0)
 ;--- Compile the screen logic (be careful with naked references)
"RTN","RORRP015",190,0)
 S SCR=""
"RTN","RORRP015",191,0)
 D:$D(RORHLT)>1
"RTN","RORRP015",192,0)
 . S SCR=SCR_"S D=$P($G(^(0)),U,3) I D'="""",$D(RORHLT(D)) "
"RTN","RORRP015",193,0)
 S:DIVIEN SCR=SCR_"I $P($G(^(0)),U,15)=DIVIEN "
"RTN","RORRP015",194,0)
 S:FLAGS'["A" SCR=SCR_"I '$$ACTLOC^RORRP015(+Y) "
"RTN","RORRP015",195,0)
 S:FLAGS'["I" SCR=SCR_"I $$ACTLOC^RORRP015(+Y) "
"RTN","RORRP015",196,0)
 ;--- Get the list of locations
"RTN","RORRP015",197,0)
 S BUF="@;.01;2I;3I;3.5I",TMP="P"_$S(FLAGS["B":"B",1:"")
"RTN","RORRP015",198,0)
 D LIST^DIC(44,,BUF,TMP,NUMBER,.FROM,PART,"B",SCR,,,"RORMSG")
"RTN","RORRP015",199,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP015",200,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,44)
"RTN","RORRP015",201,0)
 . K ^TMP("DILIST",$J)
"RTN","RORRP015",202,0)
 ;--- Populate the Active field if both flags are used
"RTN","RORRP015",203,0)
 I FLAGS["I",FLAGS["A"  S I=0  D
"RTN","RORRP015",204,0)
 . F  S I=$O(@RESULTS@(I))  Q:I=""  D
"RTN","RORRP015",205,0)
 . . S $P(@RESULTS@(I,0),U,6)=$$ACTLOC(+@RESULTS@(I,0))
"RTN","RORRP015",206,0)
 ;--- Success
"RTN","RORRP015",207,0)
 S TMP=$G(^TMP("DILIST",$J,0)),BUF=+$P(TMP,U)
"RTN","RORRP015",208,0)
 K ^TMP("DILIST",$J,0)
"RTN","RORRP015",209,0)
 S:$P(TMP,U,3) $P(BUF,U,2,3)=$G(FROM)_U_$G(FROM("IEN"))
"RTN","RORRP015",210,0)
 S @RESULTS@(0)=BUF
"RTN","RORRP015",211,0)
 Q
"RTN","RORRP016")
0^28^B6790521
"RTN","RORRP016",1,0)
RORRP016 ;HCIOFO/SG - RPC: ICD-9 CODES ; 9/19/03 2:03pm
"RTN","RORRP016",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP016",3,0)
 ;
"RTN","RORRP016",4,0)
 ; This routine uses the following IAs:
"RTN","RORRP016",5,0)
 ;
"RTN","RORRP016",6,0)
 ; #10082        Access to the file #80 (supported)
"RTN","RORRP016",7,0)
 ;
"RTN","RORRP016",8,0)
 Q
"RTN","RORRP016",9,0)
 ;
"RTN","RORRP016",10,0)
 ;***** RETURNS THE LIST OF ICD-9 CODES
"RTN","RORRP016",11,0)
 ; RPC: [ROR LIST ICD-9]
"RTN","RORRP016",12,0)
 ;
"RTN","RORRP016",13,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP016",14,0)
 ;               are returned to.
"RTN","RORRP016",15,0)
 ;
"RTN","RORRP016",16,0)
 ; [PART]        The partial match restriction.
"RTN","RORRP016",17,0)
 ;
"RTN","RORRP016",18,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORRP016",19,0)
 ;                 A  Select active codes (default)
"RTN","RORRP016",20,0)
 ;                 B  Backwards. Traverses the index in the opposite
"RTN","RORRP016",21,0)
 ;                    direction of normal traversal
"RTN","RORRP016",22,0)
 ;                 F  Exclude codes not applicable to females
"RTN","RORRP016",23,0)
 ;                 I  Select inactive codes
"RTN","RORRP016",24,0)
 ;                 M  Exclude codes not applicable to males
"RTN","RORRP016",25,0)
 ;                 P  Select only those codes that are acceptable
"RTN","RORRP016",26,0)
 ;                    as primary diagnoses
"RTN","RORRP016",27,0)
 ;
"RTN","RORRP016",28,0)
 ; [NUMBER]      Maximum number of entries to return. A value of "*"
"RTN","RORRP016",29,0)
 ;               or no value in this parameter designates all entries.
"RTN","RORRP016",30,0)
 ;
"RTN","RORRP016",31,0)
 ; [FROM]        The index entry(s) from which to begin the list
"RTN","RORRP016",32,0)
 ;                 ^01: FromName
"RTN","RORRP016",33,0)
 ;                 ^02: FromIEN
"RTN","RORRP016",34,0)
 ;
"RTN","RORRP016",35,0)
 ;               For example, a FROM value of "51" would list entries
"RTN","RORRP016",36,0)
 ;               following 51. You can use the 2-nd and 3-rd "^"-
"RTN","RORRP016",37,0)
 ;               pieces of the @RESULTS@(0) node to continue the
"RTN","RORRP016",38,0)
 ;               listing in the subsequent procedure calls.
"RTN","RORRP016",39,0)
 ;
"RTN","RORRP016",40,0)
 ;               NOTE: The FROM value itself is not included in
"RTN","RORRP016",41,0)
 ;                     the resulting list.
"RTN","RORRP016",42,0)
 ;
"RTN","RORRP016",43,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP016",44,0)
 ;
"RTN","RORRP016",45,0)
 ; See description of the LIST^DIC for more details about the
"RTN","RORRP016",46,0)
 ; PART, NUMBER and FROM parameters.
"RTN","RORRP016",47,0)
 ;
"RTN","RORRP016",48,0)
 ; Return Values:
"RTN","RORRP016",49,0)
 ;
"RTN","RORRP016",50,0)
 ; A negative value of the first "^"-piece of the @RESULTS@(0)
"RTN","RORRP016",51,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP016",52,0)
 ; details).
"RTN","RORRP016",53,0)
 ;
"RTN","RORRP016",54,0)
 ; Otherwise, number of ICD-9 codes and the value of the FROM
"RTN","RORRP016",55,0)
 ; parameter for the next procedure call are returned in the
"RTN","RORRP016",56,0)
 ; @RESULTS@(0) and the subsequent nodes of the global array
"RTN","RORRP016",57,0)
 ; contain the codes.
"RTN","RORRP016",58,0)
 ; 
"RTN","RORRP016",59,0)
 ; @RESULTS@(0)          Result Descriptor
"RTN","RORRP016",60,0)
 ;                         ^01: Number of codes
"RTN","RORRP016",61,0)
 ;                         ^02: FromName
"RTN","RORRP016",62,0)
 ;                         ^03: FromIEN
"RTN","RORRP016",63,0)
 ;
"RTN","RORRP016",64,0)
 ; @RESULTS@(i)          ICD-9
"RTN","RORRP016",65,0)
 ;                         ^01: IEN
"RTN","RORRP016",66,0)
 ;                         ^02: Diagnosis
"RTN","RORRP016",67,0)
 ;                         ^03: Code
"RTN","RORRP016",68,0)
 ;                         ^04: Use only with Sex
"RTN","RORRP016",69,0)
 ;                         ^05: Inactive (""/1)
"RTN","RORRP016",70,0)
 ;                         ^06: Inactivation Date (internal)
"RTN","RORRP016",71,0)
 ;
"RTN","RORRP016",72,0)
ICD9LIST(RESULTS,PART,FLAGS,NUMBER,FROM) ;
"RTN","RORRP016",73,0)
 N BUF,RC,RORERRDL,RORMSG,SCR,TMP
"RTN","RORRP016",74,0)
 D CLEAR^RORERR("ICD9LIST^RORRP016",1)
"RTN","RORRP016",75,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP016",76,0)
 ;--- Check the parameters
"RTN","RORRP016",77,0)
 S PART=$G(PART),FLAGS=$G(FLAGS)
"RTN","RORRP016",78,0)
 S NUMBER=$S($G(NUMBER)>0:+NUMBER,1:"*")
"RTN","RORRP016",79,0)
 ;--- If neither "A" nor "I" flag is provided, add the "A" (default)
"RTN","RORRP016",80,0)
 S:$TR(FLAGS,"AI")=FLAGS FLAGS=FLAGS_"A"
"RTN","RORRP016",81,0)
 ;--- Setup the start point
"RTN","RORRP016",82,0)
 I $G(FROM)'=""  D  S FROM=$P(FROM,U)
"RTN","RORRP016",83,0)
 . S:$P(FROM,U,2)>0 FROM("IEN")=+$P(FROM,U,2)
"RTN","RORRP016",84,0)
 E  S FROM=$S(FLAGS["B":"",1:PART_" ")
"RTN","RORRP016",85,0)
 ;--- Compile the screen logic (be careful with naked references)
"RTN","RORRP016",86,0)
 S SCR=""
"RTN","RORRP016",87,0)
 S:FLAGS'["A" SCR=SCR_"I $P(D,U,9) "
"RTN","RORRP016",88,0)
 S:FLAGS'["I" SCR=SCR_"I '$P(D,U,9) "
"RTN","RORRP016",89,0)
 S:FLAGS["F" SCR=SCR_"I $P(D,U,10)'=""M"" "
"RTN","RORRP016",90,0)
 S:FLAGS["M" SCR=SCR_"I $P(D,U,10)'=""F"" "
"RTN","RORRP016",91,0)
 S:FLAGS["P" SCR=SCR_"I '$P(D,U,4) "
"RTN","RORRP016",92,0)
 S:SCR'="" SCR="S D=$G(^(0)) "_SCR
"RTN","RORRP016",93,0)
 ;--- Get the list of codes
"RTN","RORRP016",94,0)
 S BUF="@;3;.01;9.5I;100I;102I",TMP="P"_$S(FLAGS["B":"B",1:"")
"RTN","RORRP016",95,0)
 D LIST^DIC(80,,BUF,TMP,NUMBER,.FROM,PART,"BA",SCR,,,"RORMSG")
"RTN","RORRP016",96,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP016",97,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,80)
"RTN","RORRP016",98,0)
 . K ^TMP("DILIST",$J)
"RTN","RORRP016",99,0)
 ;--- Success
"RTN","RORRP016",100,0)
 S TMP=$G(^TMP("DILIST",$J,0)),BUF=+$P(TMP,U)
"RTN","RORRP016",101,0)
 K ^TMP("DILIST",$J,0)
"RTN","RORRP016",102,0)
 S:$P(TMP,U,3) $P(BUF,U,2,3)=$G(FROM)_U_$G(FROM("IEN"))
"RTN","RORRP016",103,0)
 S @RESULTS@(0)=BUF
"RTN","RORRP016",104,0)
 Q
"RTN","RORRP017")
0^29^B12973623
"RTN","RORRP017",1,0)
RORRP017 ;HCIOFO/SG - RPC: DRUGS AND CLASSES ; 2/10/04 9:17am
"RTN","RORRP017",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP017",3,0)
 ;
"RTN","RORRP017",4,0)
 ; This routine uses the following IAs:
"RTN","RORRP017",5,0)
 ;
"RTN","RORRP017",6,0)
 ; #???          Access to the file #50.605 (??? 618, 696, 2138, 2472)
"RTN","RORRP017",7,0)
 ; #221-A        Access to the DRUG file (#50)
"RTN","RORRP017",8,0)
 ; #2016         Access to the VA GENERIC file (#50.6)
"RTN","RORRP017",9,0)
 ; #221-A        Cross-references of the DRUG file
"RTN","RORRP017",10,0)
 ;
"RTN","RORRP017",11,0)
 Q
"RTN","RORRP017",12,0)
 ;
"RTN","RORRP017",13,0)
 ;***** RETURNS THE LIST OF DRUGS (DISPENSED OR GENERIC)
"RTN","RORRP017",14,0)
 ; RPC: [ROR LIST DRUGS]
"RTN","RORRP017",15,0)
 ;
"RTN","RORRP017",16,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP017",17,0)
 ;               are returned to.
"RTN","RORRP017",18,0)
 ;
"RTN","RORRP017",19,0)
 ; [PART]        The partial match restriction.
"RTN","RORRP017",20,0)
 ;
"RTN","RORRP017",21,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORRP017",22,0)
 ;                 B  Backwards. Traverses the index in the opposite
"RTN","RORRP017",23,0)
 ;                    direction of normal traversal
"RTN","RORRP017",24,0)
 ;                 G  Retrive generic drugs (from file #50.6).
"RTN","RORRP017",25,0)
 ;                    Otherwise, list of dispensed drugs (from
"RTN","RORRP017",26,0)
 ;                    file #50) is retrived.
"RTN","RORRP017",27,0)
 ;
"RTN","RORRP017",28,0)
 ; [NUMBER]      Maximum number of entries to return. A value of "*"
"RTN","RORRP017",29,0)
 ;               or no value in this parameter designates all entries.
"RTN","RORRP017",30,0)
 ;
"RTN","RORRP017",31,0)
 ; [FROM]        The index entry(s) from which to begin the list
"RTN","RORRP017",32,0)
 ;                 ^01: FromName
"RTN","RORRP017",33,0)
 ;                 ^02: FromIEN
"RTN","RORRP017",34,0)
 ;
"RTN","RORRP017",35,0)
 ;               For example, a FROM value of "AD" would list entries
"RTN","RORRP017",36,0)
 ;               following AD. You can use the 2-nd and 3-rd "^"-
"RTN","RORRP017",37,0)
 ;               pieces of the @RESULTS@(0) node to continue the
"RTN","RORRP017",38,0)
 ;               listing in the subsequent procedure calls.
"RTN","RORRP017",39,0)
 ;
"RTN","RORRP017",40,0)
 ;               NOTE: The FROM value itself is not included in
"RTN","RORRP017",41,0)
 ;                     the resulting list.
"RTN","RORRP017",42,0)
 ;
"RTN","RORRP017",43,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP017",44,0)
 ;
"RTN","RORRP017",45,0)
 ; See description of the LIST^DIC for more details about the
"RTN","RORRP017",46,0)
 ; PART, NUMBER and FROM parameters.
"RTN","RORRP017",47,0)
 ;
"RTN","RORRP017",48,0)
 ; Return Values:
"RTN","RORRP017",49,0)
 ;
"RTN","RORRP017",50,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP017",51,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP017",52,0)
 ; details).
"RTN","RORRP017",53,0)
 ;
"RTN","RORRP017",54,0)
 ; Otherwise, number of drugs and the value of the FROM
"RTN","RORRP017",55,0)
 ; parameter for the next procedure call are returned in the
"RTN","RORRP017",56,0)
 ; @RESULTS@(0) and the subsequent nodes of the global array
"RTN","RORRP017",57,0)
 ; contain the drugs.
"RTN","RORRP017",58,0)
 ; 
"RTN","RORRP017",59,0)
 ; @RESULTS@(0)          Result Descriptor
"RTN","RORRP017",60,0)
 ;                         ^01: Number of drugs
"RTN","RORRP017",61,0)
 ;                         ^02: FromName
"RTN","RORRP017",62,0)
 ;                         ^03: FromIEN
"RTN","RORRP017",63,0)
 ;
"RTN","RORRP017",64,0)
 ; @RESULTS@(i)          Drug
"RTN","RORRP017",65,0)
 ;                         ^01: IEN in the DRUG file (#50)
"RTN","RORRP017",66,0)
 ;                         ^02: Drug Name
"RTN","RORRP017",67,0)
 ;                         ^03: VA Drug Class (only for dispensed)
"RTN","RORRP017",68,0)
 ;
"RTN","RORRP017",69,0)
DRUGLIST(RESULTS,PART,FLAGS,NUMBER,FROM) ;
"RTN","RORRP017",70,0)
 N BUF,I,LFL,RC,RORERRDL,RORMSG,TMP
"RTN","RORRP017",71,0)
 D CLEAR^RORERR("DRUGLIST^RORRP017",1)
"RTN","RORRP017",72,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP017",73,0)
 ;--- Check the parameters
"RTN","RORRP017",74,0)
 S PART=$G(PART),FLAGS=$G(FLAGS)
"RTN","RORRP017",75,0)
 S NUMBER=$S($G(NUMBER)>0:+NUMBER,1:"*")
"RTN","RORRP017",76,0)
 ;--- Setup the start point
"RTN","RORRP017",77,0)
 I $G(FROM)'=""  D  S FROM=$P(FROM,U)
"RTN","RORRP017",78,0)
 . S:$P(FROM,U,2)>0 FROM("IEN")=+$P(FROM,U,2)
"RTN","RORRP017",79,0)
 ;--- Get the list of drugs
"RTN","RORRP017",80,0)
 S LFL="P"_$S(FLAGS["B":"B",1:"")
"RTN","RORRP017",81,0)
 I FLAGS["G"  D  ; Generic
"RTN","RORRP017",82,0)
 . D LIST^DIC(50.6,,"@;.01",LFL,NUMBER,.FROM,PART,"B",,,,"RORMSG")
"RTN","RORRP017",83,0)
 E  D            ; Dispensed
"RTN","RORRP017",84,0)
 . D LIST^DIC(50,,"@;.01;25",LFL,NUMBER,.FROM,PART,"B",,,,"RORMSG")
"RTN","RORRP017",85,0)
 ;--- Check the errors
"RTN","RORRP017",86,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP017",87,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,50)
"RTN","RORRP017",88,0)
 . K ^TMP("DILIST",$J)
"RTN","RORRP017",89,0)
 ;--- Success
"RTN","RORRP017",90,0)
 S TMP=$G(^TMP("DILIST",$J,0)),BUF=+$P(TMP,U)
"RTN","RORRP017",91,0)
 K ^TMP("DILIST",$J,0)
"RTN","RORRP017",92,0)
 S:$P(TMP,U,3) $P(BUF,U,2,3)=$G(FROM)_U_$G(FROM("IEN"))
"RTN","RORRP017",93,0)
 S @RESULTS@(0)=BUF
"RTN","RORRP017",94,0)
 Q
"RTN","RORRP017",95,0)
 ;
"RTN","RORRP017",96,0)
 ;***** RETURNS THE LIST OF VA DRUG CLASSES
"RTN","RORRP017",97,0)
 ; RPC: [ROR LIST VA DRUG CLASSES]
"RTN","RORRP017",98,0)
 ;
"RTN","RORRP017",99,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP017",100,0)
 ;               are returned to.
"RTN","RORRP017",101,0)
 ;
"RTN","RORRP017",102,0)
 ; [PARENT]      Reserved
"RTN","RORRP017",103,0)
 ;
"RTN","RORRP017",104,0)
 ; [PART]        The partial match restriction.
"RTN","RORRP017",105,0)
 ;
"RTN","RORRP017",106,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORRP017",107,0)
 ;                 B  Backwards. Traverses the index in the opposite
"RTN","RORRP017",108,0)
 ;                    direction of normal traversal
"RTN","RORRP017",109,0)
 ;
"RTN","RORRP017",110,0)
 ; [NUMBER]      Maximum number of entries to return. A value of "*"
"RTN","RORRP017",111,0)
 ;               or no value in this parameter designates all entries.
"RTN","RORRP017",112,0)
 ;
"RTN","RORRP017",113,0)
 ; [FROM]        The index entry(s) from which to begin the list
"RTN","RORRP017",114,0)
 ;                 ^01: FromName
"RTN","RORRP017",115,0)
 ;                 ^02: FromIEN
"RTN","RORRP017",116,0)
 ;
"RTN","RORRP017",117,0)
 ;               For example, a FROM value of "AD" would list entries
"RTN","RORRP017",118,0)
 ;               following AD. You can use the 2-nd and 3-rd "^"-
"RTN","RORRP017",119,0)
 ;               pieces of the @RESULTS@(0) node to continue the
"RTN","RORRP017",120,0)
 ;               listing in the subsequent procedure calls.
"RTN","RORRP017",121,0)
 ;
"RTN","RORRP017",122,0)
 ;               NOTE: The FROM value itself is not included in
"RTN","RORRP017",123,0)
 ;                     the resulting list.
"RTN","RORRP017",124,0)
 ;
"RTN","RORRP017",125,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP017",126,0)
 ;
"RTN","RORRP017",127,0)
 ; See description of the LIST^DIC for more details about the
"RTN","RORRP017",128,0)
 ; PART, NUMBER and FROM parameters.
"RTN","RORRP017",129,0)
 ;
"RTN","RORRP017",130,0)
 ; Return Values:
"RTN","RORRP017",131,0)
 ;
"RTN","RORRP017",132,0)
 ; A negative value of the first "^"-piece of the @RESULTS@(0)
"RTN","RORRP017",133,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP017",134,0)
 ; details).
"RTN","RORRP017",135,0)
 ;
"RTN","RORRP017",136,0)
 ; Otherwise, number of drug classes and the value of the FROM
"RTN","RORRP017",137,0)
 ; parameter for the next procedure call are returned in the
"RTN","RORRP017",138,0)
 ; @RESULTS@(0) and the subsequent nodes of the global array
"RTN","RORRP017",139,0)
 ; contain the classes.
"RTN","RORRP017",140,0)
 ; 
"RTN","RORRP017",141,0)
 ; @RESULTS@(0)          Result Descriptor
"RTN","RORRP017",142,0)
 ;                         ^01: Number of classes
"RTN","RORRP017",143,0)
 ;                         ^02: FromName
"RTN","RORRP017",144,0)
 ;                         ^03: FromIEN
"RTN","RORRP017",145,0)
 ;
"RTN","RORRP017",146,0)
 ; @RESULTS@(i)          Drug Class
"RTN","RORRP017",147,0)
 ;                         ^01: IEN
"RTN","RORRP017",148,0)
 ;                         ^02: Classification
"RTN","RORRP017",149,0)
 ;                         ^03: Code
"RTN","RORRP017",150,0)
 ;
"RTN","RORRP017",151,0)
VACLSLST(RESULTS,PARENT,PART,FLAGS,NUMBER,FROM) ;
"RTN","RORRP017",152,0)
 N BUF,RC,RORERRDL,RORMSG,TMP
"RTN","RORRP017",153,0)
 D CLEAR^RORERR("VACLSLST^RORRP017",1)
"RTN","RORRP017",154,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP017",155,0)
 ;--- Check the parameters
"RTN","RORRP017",156,0)
 S PART=$G(PART),FLAGS=$G(FLAGS)
"RTN","RORRP017",157,0)
 S NUMBER=$S($G(NUMBER)>0:+NUMBER,1:"*")
"RTN","RORRP017",158,0)
 ;--- Setup the start point
"RTN","RORRP017",159,0)
 I $G(FROM)'=""  D  S FROM=$P(FROM,U)
"RTN","RORRP017",160,0)
 . S:$P(FROM,U,2)>0 FROM("IEN")=+$P(FROM,U,2)
"RTN","RORRP017",161,0)
 ;--- Get the list of codes
"RTN","RORRP017",162,0)
 S BUF="@;1;.01",TMP="P"_$S(FLAGS["B":"B",1:"")
"RTN","RORRP017",163,0)
 D LIST^DIC(50.605,,BUF,TMP,NUMBER,.FROM,PART,"B",,,,"RORMSG")
"RTN","RORRP017",164,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP017",165,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,50.605)
"RTN","RORRP017",166,0)
 . K ^TMP("DILIST",$J)
"RTN","RORRP017",167,0)
 ;--- Success
"RTN","RORRP017",168,0)
 S TMP=$G(^TMP("DILIST",$J,0)),BUF=+$P(TMP,U)
"RTN","RORRP017",169,0)
 K ^TMP("DILIST",$J,0)
"RTN","RORRP017",170,0)
 S:$P(TMP,U,3) $P(BUF,U,2,3)=$G(FROM)_U_$G(FROM("IEN"))
"RTN","RORRP017",171,0)
 S @RESULTS@(0)=BUF
"RTN","RORRP017",172,0)
 Q
"RTN","RORRP018")
0^36^B6225205
"RTN","RORRP018",1,0)
RORRP018 ;HCIOFO/SG - RPC: LIST OF LAB TESTS ; 2/10/04 8:58am
"RTN","RORRP018",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP018",3,0)
 ;
"RTN","RORRP018",4,0)
 ; This routine uses the following IAs:
"RTN","RORRP018",5,0)
 ;
"RTN","RORRP018",6,0)
 ; #91           Access to the LABORATORY TEST file
"RTN","RORRP018",7,0)
 ;
"RTN","RORRP018",8,0)
 Q
"RTN","RORRP018",9,0)
 ;
"RTN","RORRP018",10,0)
 ;***** RETURNS THE LIST OF LAB TESTS
"RTN","RORRP018",11,0)
 ; RPC: [ROR LIST LABORATORY TESTS]
"RTN","RORRP018",12,0)
 ;
"RTN","RORRP018",13,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP018",14,0)
 ;               are returned to.
"RTN","RORRP018",15,0)
 ;
"RTN","RORRP018",16,0)
 ; [SUBSCR]      List of the test subscripts (separated by commas)
"RTN","RORRP018",17,0)
 ;               to include. By default ($G(SUBSCR)=""), all tests
"RTN","RORRP018",18,0)
 ;               are retrieved.
"RTN","RORRP018",19,0)
 ;
"RTN","RORRP018",20,0)
 ; [PART]        The partial match restriction.
"RTN","RORRP018",21,0)
 ;
"RTN","RORRP018",22,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORRP018",23,0)
 ;                 B  Backwards. Traverses the index in the opposite
"RTN","RORRP018",24,0)
 ;                    direction of normal traversal
"RTN","RORRP018",25,0)
 ;                 P  Include panels (by default, the panels are
"RTN","RORRP018",26,0)
 ;                    excluded from the list)
"RTN","RORRP018",27,0)
 ;
"RTN","RORRP018",28,0)
 ; [NUMBER]      Maximum number of entries to return. A value of "*"
"RTN","RORRP018",29,0)
 ;               or no value in this parameter designates all entries.
"RTN","RORRP018",30,0)
 ;
"RTN","RORRP018",31,0)
 ; [FROM]        The index entry(s) from which to begin the list
"RTN","RORRP018",32,0)
 ;                 ^01: FromName
"RTN","RORRP018",33,0)
 ;                 ^02: FromIEN
"RTN","RORRP018",34,0)
 ;
"RTN","RORRP018",35,0)
 ;               For example, a FROM value of "AD" would list entries
"RTN","RORRP018",36,0)
 ;               following AD. You can use the 2-nd and 3-rd "^"-
"RTN","RORRP018",37,0)
 ;               pieces of the @RESULTS@(0) node to continue the
"RTN","RORRP018",38,0)
 ;               listing in the subsequent procedure calls.
"RTN","RORRP018",39,0)
 ;
"RTN","RORRP018",40,0)
 ;               NOTE: The FROM value itself is not included in
"RTN","RORRP018",41,0)
 ;                     the resulting list.
"RTN","RORRP018",42,0)
 ;
"RTN","RORRP018",43,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP018",44,0)
 ;
"RTN","RORRP018",45,0)
 ; See description of the LIST^DIC for more details about the
"RTN","RORRP018",46,0)
 ; PART, NUMBER and FROM parameters.
"RTN","RORRP018",47,0)
 ;
"RTN","RORRP018",48,0)
 ; Return Values:
"RTN","RORRP018",49,0)
 ;
"RTN","RORRP018",50,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP018",51,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP018",52,0)
 ; details).
"RTN","RORRP018",53,0)
 ;
"RTN","RORRP018",54,0)
 ; Otherwise, number of lab tests and the value of the FROM
"RTN","RORRP018",55,0)
 ; parameter for the next procedure call are returned in the
"RTN","RORRP018",56,0)
 ; @RESULTS@(0) and the subsequent nodes of the global array
"RTN","RORRP018",57,0)
 ; contain the tests.
"RTN","RORRP018",58,0)
 ; 
"RTN","RORRP018",59,0)
 ; @RESULTS@(0)          Result Descriptor
"RTN","RORRP018",60,0)
 ;                         ^01: Number of tests
"RTN","RORRP018",61,0)
 ;                         ^02: FromName
"RTN","RORRP018",62,0)
 ;                         ^03: FromIEN
"RTN","RORRP018",63,0)
 ;
"RTN","RORRP018",64,0)
 ; @RESULTS@(i)          Lab Test
"RTN","RORRP018",65,0)
 ;                         ^01: IEN
"RTN","RORRP018",66,0)
 ;                         ^02: Test Name
"RTN","RORRP018",67,0)
 ;                         ^03: Subscript (internal)
"RTN","RORRP018",68,0)
 ;
"RTN","RORRP018",69,0)
LABTLIST(RESULTS,SUBSCR,PART,FLAGS,NUMBER,FROM) ;
"RTN","RORRP018",70,0)
 N BUF,I,RC,RORERRDL,RORMSG,RORSUBS,SCR,TMP
"RTN","RORRP018",71,0)
 D CLEAR^RORERR("LABTLIST^RORRP018",1)
"RTN","RORRP018",72,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP018",73,0)
 ;--- Check the parameters
"RTN","RORRP018",74,0)
 S SUBSCR=$$UP^XLFSTR($TR($G(SUBSCR)," "))
"RTN","RORRP018",75,0)
 F I=1:1  S TMP=$P(SUBSCR,",",I)  Q:TMP=""  S RORSUBS(TMP)=""
"RTN","RORRP018",76,0)
 S PART=$G(PART),FLAGS=$G(FLAGS)
"RTN","RORRP018",77,0)
 S NUMBER=$S($G(NUMBER)>0:+NUMBER,1:"*")
"RTN","RORRP018",78,0)
 ;--- Setup the start point
"RTN","RORRP018",79,0)
 I $G(FROM)'=""  D  S FROM=$P(FROM,U)
"RTN","RORRP018",80,0)
 . S:$P(FROM,U,2)>0 FROM("IEN")=+$P(FROM,U,2)
"RTN","RORRP018",81,0)
 ;--- Compile the screen logic (be careful with naked references)
"RTN","RORRP018",82,0)
 S SCR=""
"RTN","RORRP018",83,0)
 D:$D(RORSUBS)>0
"RTN","RORRP018",84,0)
 . S SCR=SCR_"S D=$P($G(^(0)),U,4) I D'="""",$D(RORSUBS(D)) "
"RTN","RORRP018",85,0)
 S:FLAGS'["P" SCR=SCR_"I $O(^(2,0))'>0 "  ; Exclude panels
"RTN","RORRP018",86,0)
 ;--- Get the list of tests
"RTN","RORRP018",87,0)
 S BUF="@;.01;4I",TMP="P"_$S(FLAGS["B":"B",1:"")
"RTN","RORRP018",88,0)
 D LIST^DIC(60,,BUF,TMP,NUMBER,.FROM,PART,"B",SCR,,,"RORMSG")
"RTN","RORRP018",89,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP018",90,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,60)
"RTN","RORRP018",91,0)
 . K ^TMP("DILIST",$J)
"RTN","RORRP018",92,0)
 ;--- Success
"RTN","RORRP018",93,0)
 S TMP=$G(^TMP("DILIST",$J,0)),BUF=+$P(TMP,U)
"RTN","RORRP018",94,0)
 K ^TMP("DILIST",$J,0)
"RTN","RORRP018",95,0)
 S:$P(TMP,U,3) $P(BUF,U,2,3)=$G(FROM)_U_$G(FROM("IEN"))
"RTN","RORRP018",96,0)
 S @RESULTS@(0)=BUF
"RTN","RORRP018",97,0)
 Q
"RTN","RORRP019")
0^49^B22286689
"RTN","RORRP019",1,0)
RORRP019 ;HCIOFO/SG - RPC: LIST OF PATIENTS ; 1/16/04 10:59am
"RTN","RORRP019",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP019",3,0)
 ;
"RTN","RORRP019",4,0)
 Q
"RTN","RORRP019",5,0)
 ;
"RTN","RORRP019",6,0)
 ;***** RETURNS THE LIST OF PATIENTS (EITHER FROM #798 OR #2)
"RTN","RORRP019",7,0)
 ; RPC: [ROR LIST PATIENTS]
"RTN","RORRP019",8,0)
 ;
"RTN","RORRP019",9,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP019",10,0)
 ;               are returned to.
"RTN","RORRP019",11,0)
 ;
"RTN","RORRP019",12,0)
 ; REGIEN        Registry IEN
"RTN","RORRP019",13,0)
 ;
"RTN","RORRP019",14,0)
 ; [DATE]        See description of the 'D flag below
"RTN","RORRP019",15,0)
 ;
"RTN","RORRP019",16,0)
 ; [PART]        The search pattern (partial match restriction)
"RTN","RORRP019",17,0)
 ;
"RTN","RORRP019",18,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORRP019",19,0)
 ;                 2  Search in the PATIENT file. By default, the
"RTN","RORRP019",20,0)
 ;                    ROR LOCAL REGISTRY and ROR PATIENT files are
"RTN","RORRP019",21,0)
 ;                    queried. This flag overrides the 'D', 'N' and
"RTN","RORRP019",22,0)
 ;                    'P' flags.
"RTN","RORRP019",23,0)
 ;                 B  Backwards. Traverses the index in the opposite
"RTN","RORRP019",24,0)
 ;                    direction of normal traversal.
"RTN","RORRP019",25,0)
 ;                 D  Ignore those patients who were added to the
"RTN","RORRP019",26,0)
 ;                    registry before the date defined by the DATE
"RTN","RORRP019",27,0)
 ;                    parameter.
"RTN","RORRP019",28,0)
 ;                 N  Include only new patients (AUTO or MANUAL)
"RTN","RORRP019",29,0)
 ;                 O  Add values of the optional fields
"RTN","RORRP019",30,0)
 ;                 P  Include only pending patients
"RTN","RORRP019",31,0)
 ;
"RTN","RORRP019",32,0)
 ; [NUMBER]      Maximum number of entries to return. A value of "*"
"RTN","RORRP019",33,0)
 ;               or no value in this parameter designates all entries.
"RTN","RORRP019",34,0)
 ;
"RTN","RORRP019",35,0)
 ; [FROM]        The index entry(s) from which to begin the list.
"RTN","RORRP019",36,0)
 ;               You should use the pieces of the @RESULTS@(0) node
"RTN","RORRP019",37,0)
 ;               (starting from the second one) to continue the
"RTN","RORRP019",38,0)
 ;               listing in the subsequent procedure calls.
"RTN","RORRP019",39,0)
 ;
"RTN","RORRP019",40,0)
 ;               NOTE: The FROM value itself is not included in
"RTN","RORRP019",41,0)
 ;                     the resulting list.
"RTN","RORRP019",42,0)
 ;
"RTN","RORRP019",43,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP019",44,0)
 ;
"RTN","RORRP019",45,0)
 ; See description of the LIST^DIC for more details about the
"RTN","RORRP019",46,0)
 ; PART, NUMBER and FROM parameters.
"RTN","RORRP019",47,0)
 ;
"RTN","RORRP019",48,0)
 ; Return Values:
"RTN","RORRP019",49,0)
 ;
"RTN","RORRP019",50,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP019",51,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP019",52,0)
 ; details).
"RTN","RORRP019",53,0)
 ;
"RTN","RORRP019",54,0)
 ; Otherwise, number of patients and the value of the FROM
"RTN","RORRP019",55,0)
 ; parameter for the next procedure call are returned in the
"RTN","RORRP019",56,0)
 ; @RESULTS@(0) and the subsequent nodes of the global array
"RTN","RORRP019",57,0)
 ; contain the patients.
"RTN","RORRP019",58,0)
 ; 
"RTN","RORRP019",59,0)
 ; @RESULTS@(0)          Result Descriptor
"RTN","RORRP019",60,0)
 ;                         ^01: Number of patients
"RTN","RORRP019",61,0)
 ;                         ^02: Values that comprise the FROM
"RTN","RORRP019",62,0)
 ;                         ^nn: parameter for the subsequent call
"RTN","RORRP019",63,0)
 ;
"RTN","RORRP019",64,0)
 ; @RESULTS@(i)          Patient
"RTN","RORRP019",65,0)
 ;                         ...  See the $$LOAD2^RORRP020 (RORDEM)
"RTN","RORRP019",66,0)
 ;
"RTN","RORRP019",67,0)
 ; @RESULTS@(i+1)        Optional fields (these nodes are created only
"RTN","RORRP019",68,0)
 ;                       if the FLAGS parameter contains the 'O' flag)
"RTN","RORRP019",69,0)
 ;                         ^01: "O" (letter O)
"RTN","RORRP019",70,0)
 ;                         ...  See the $$LOAD798^RORRP020
"RTN","RORRP019",71,0)
 ;
"RTN","RORRP019",72,0)
PTLIST(RESULTS,REGIEN,DATE,PART,FLAGS,NUMBER,FROM) ;
"RTN","RORRP019",73,0)
 N BUF,I,RC,RORERRDL,TMP
"RTN","RORRP019",74,0)
 D CLEAR^RORERR("PTLIST^RORRP019",1)
"RTN","RORRP019",75,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP019",76,0)
 ;--- Check the parameters
"RTN","RORRP019",77,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP019",78,0)
 . ;--- Registry IEN
"RTN","RORRP019",79,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP019",80,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP019",81,0)
 . S REGIEN=+REGIEN
"RTN","RORRP019",82,0)
 . ;--- Flags
"RTN","RORRP019",83,0)
 . S FLAGS=$$UP^XLFSTR($G(FLAGS)),DATE=+$G(DATE)
"RTN","RORRP019",84,0)
 . S:FLAGS["2" FLAGS=$TR(FLAGS,"DNP")
"RTN","RORRP019",85,0)
 . ;--- Others
"RTN","RORRP019",86,0)
 . S PART=$G(PART),FROM=$G(FROM)
"RTN","RORRP019",87,0)
 . S NUMBER=$S($G(NUMBER)>0:+NUMBER,1:"*")
"RTN","RORRP019",88,0)
 ;--- Setup the start point
"RTN","RORRP019",89,0)
 F I=1:1  S TMP=$P(FROM,U,I)  Q:TMP=""  S FROM(I)=TMP
"RTN","RORRP019",90,0)
 S FROM=$G(FROM(1))
"RTN","RORRP019",91,0)
 ;--- Query the file
"RTN","RORRP019",92,0)
 S RC=0  D
"RTN","RORRP019",93,0)
 . I FLAGS["2"  D  Q
"RTN","RORRP019",94,0)
 . . S RC=$$LST2(REGIEN,PART,FLAGS,NUMBER,.FROM)
"RTN","RORRP019",95,0)
 . I $TR(FLAGS,"NP")'=FLAGS  D  Q
"RTN","RORRP019",96,0)
 . . S RC=$$LST798A(REGIEN,PART,FLAGS,NUMBER,.FROM)
"RTN","RORRP019",97,0)
 . S RC=$$LST798(REGIEN,+DATE,PART,FLAGS,NUMBER,.FROM)
"RTN","RORRP019",98,0)
 ;--- Check for the error(s)
"RTN","RORRP019",99,0)
 I RC<0  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP019",100,0)
 . K ^TMP("DILIST",$J)
"RTN","RORRP019",101,0)
 ;--- Post-processing
"RTN","RORRP019",102,0)
 S RC=$$POSTPROC^RORRP020(RESULTS,REGIEN,FLAGS)
"RTN","RORRP019",103,0)
 I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP019",104,0)
 ;--- Success
"RTN","RORRP019",105,0)
 S TMP=$G(^TMP("DILIST",$J,0)),BUF=+$P(TMP,U)
"RTN","RORRP019",106,0)
 K ^TMP("DILIST",$J,0)
"RTN","RORRP019",107,0)
 I $P(TMP,U,3)  S I=0  D
"RTN","RORRP019",108,0)
 . F  S I=$O(FROM(I))  Q:I'>0  S TMP=FROM(I)  S:TMP'="" BUF=BUF_U_TMP
"RTN","RORRP019",109,0)
 S @RESULTS@(0)=BUF
"RTN","RORRP019",110,0)
 Q
"RTN","RORRP019",111,0)
 ;
"RTN","RORRP019",112,0)
 ;***** QUERIES THE 'PATIENT' FILE (#2)
"RTN","RORRP019",113,0)
 ;
"RTN","RORRP019",114,0)
 ; RORREG        Registry IEN
"RTN","RORRP019",115,0)
 ;
"RTN","RORRP019",116,0)
 ; PART          The partial match restriction
"RTN","RORRP019",117,0)
 ;
"RTN","RORRP019",118,0)
 ; FLAGS         Flags that control the execution
"RTN","RORRP019",119,0)
 ;
"RTN","RORRP019",120,0)
 ; NUMBER        Maximum number of entries to return
"RTN","RORRP019",121,0)
 ;
"RTN","RORRP019",122,0)
 ; .FROM         Reference to a local variable that contains the
"RTN","RORRP019",123,0)
 ;               starting point for the LIST^DIC. The new point is
"RTN","RORRP019",124,0)
 ;               returned in this variable as well.
"RTN","RORRP019",125,0)
 ;
"RTN","RORRP019",126,0)
 ; Return Values:
"RTN","RORRP019",127,0)
 ;       <0  Error code
"RTN","RORRP019",128,0)
 ;        0  Ok
"RTN","RORRP019",129,0)
 ;
"RTN","RORRP019",130,0)
LST2(RORREG,PART,FLAGS,NUMBER,FROM) ;
"RTN","RORRP019",131,0)
 N RC,RORMSG,SCR,TMP,XREF
"RTN","RORRP019",132,0)
 S XREF=$S(PART?4N:"BS",PART?1U4N:"BS5",PART?9N.1"P":"SSN",1:"B")
"RTN","RORRP019",133,0)
 ;--- Compile the screen logic (be careful with naked references)
"RTN","RORRP019",134,0)
 S SCR="I '$$SKIPEMPL^RORUTL02(+Y,.RORREG)"
"RTN","RORRP019",135,0)
 ;--- Get the list of patients
"RTN","RORRP019",136,0)
 S TMP="P"_$S(FLAGS["B":"B",1:"")_$S(XREF="B":"M",1:"")
"RTN","RORRP019",137,0)
 D LIST^DIC(2,,"@",TMP,NUMBER,.FROM,PART,XREF,SCR,,,"RORMSG")
"RTN","RORRP019",138,0)
 S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,2)
"RTN","RORRP019",139,0)
 ;---
"RTN","RORRP019",140,0)
 Q $S($G(RC)<0:RC,1:0)
"RTN","RORRP019",141,0)
 ;
"RTN","RORRP019",142,0)
 ;***** QUERIES THE 'ROR PATIENT' FILE (#798.4)
"RTN","RORRP019",143,0)
 ;
"RTN","RORRP019",144,0)
 ; RORREG        Registry IEN
"RTN","RORRP019",145,0)
 ;
"RTN","RORRP019",146,0)
 ; RORDT         Ignore patietns who were added to the registry
"RTN","RORRP019",147,0)
 ;               before the provided date (if the FLAGS parameter
"RTN","RORRP019",148,0)
 ;               contains the "D" flag)
"RTN","RORRP019",149,0)
 ;
"RTN","RORRP019",150,0)
 ; PART          The partial match restriction
"RTN","RORRP019",151,0)
 ;
"RTN","RORRP019",152,0)
 ; FLAGS         Flags that control the execution
"RTN","RORRP019",153,0)
 ;
"RTN","RORRP019",154,0)
 ; NUMBER        Maximum number of entries to return
"RTN","RORRP019",155,0)
 ;
"RTN","RORRP019",156,0)
 ; .FROM         Reference to a local variable that contains the
"RTN","RORRP019",157,0)
 ;               starting point for the LIST^DIC. The new point is
"RTN","RORRP019",158,0)
 ;               returned in this variable as well.
"RTN","RORRP019",159,0)
 ;
"RTN","RORRP019",160,0)
 ; Return Values:
"RTN","RORRP019",161,0)
 ;       <0  Error code
"RTN","RORRP019",162,0)
 ;        0  Ok
"RTN","RORRP019",163,0)
 ;
"RTN","RORRP019",164,0)
LST798(RORREG,RORDT,PART,FLAGS,NUMBER,FROM) ;
"RTN","RORRP019",165,0)
 N RC,RORMSG,SCR,TMP,XREF
"RTN","RORRP019",166,0)
 S XREF=$S(PART?4N:"BS",PART?1U4N:"BS5",PART?9N.1"P":"SSN",1:"B")
"RTN","RORRP019",167,0)
 ;--- Compile the screen logic (be careful with naked references)
"RTN","RORRP019",168,0)
 S SCR="S D=$O(^RORDATA(798,""KEY"",+Y,RORREG,0)) I D>0 "
"RTN","RORRP019",169,0)
 S:FLAGS["D" SCR=SCR_"I $P($G(^RORDATA(798,D,0)),U,3)'<RORDT "
"RTN","RORRP019",170,0)
 ;--- Get the list of patients
"RTN","RORRP019",171,0)
 S TMP="P"_$S(FLAGS["B":"B",1:"")_$S(XREF="B":"M",1:"")
"RTN","RORRP019",172,0)
 D LIST^DIC(798.4,,"@",TMP,NUMBER,.FROM,PART,XREF,SCR,,,"RORMSG")
"RTN","RORRP019",173,0)
 S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,798.4)
"RTN","RORRP019",174,0)
 ;---
"RTN","RORRP019",175,0)
 Q $S($G(RC)<0:RC,1:0)
"RTN","RORRP019",176,0)
 ;
"RTN","RORRP019",177,0)
 ;***** QUERIES THE 'ROR LOCAL REGISTRY' FILE (#798)
"RTN","RORRP019",178,0)
 ;
"RTN","RORRP019",179,0)
 ; RORREG        Registry IEN
"RTN","RORRP019",180,0)
 ;
"RTN","RORRP019",181,0)
 ; SRCPART       The partial match restriction
"RTN","RORRP019",182,0)
 ;
"RTN","RORRP019",183,0)
 ; FLAGS         Flags that control the execution
"RTN","RORRP019",184,0)
 ;
"RTN","RORRP019",185,0)
 ; NUMBER        Maximum number of entries to return
"RTN","RORRP019",186,0)
 ;
"RTN","RORRP019",187,0)
 ; .FROM         Reference to a local variable that contains the
"RTN","RORRP019",188,0)
 ;               starting point for the LIST^DIC. The new point is
"RTN","RORRP019",189,0)
 ;               returned in this variable as well.
"RTN","RORRP019",190,0)
 ;
"RTN","RORRP019",191,0)
 ; Return Values:
"RTN","RORRP019",192,0)
 ;       <0  Error code
"RTN","RORRP019",193,0)
 ;        0  Ok
"RTN","RORRP019",194,0)
 ;
"RTN","RORRP019",195,0)
LST798A(RORREG,SRCPART,FLAGS,NUMBER,FROM) ;
"RTN","RORRP019",196,0)
 N PART,RC,RORNPS,SCR,TMP
"RTN","RORRP019",197,0)
 S:FLAGS["N" (RORNPS(1),RORNPS(2))=""
"RTN","RORRP019",198,0)
 S:FLAGS["P" RORNPS(4)=""
"RTN","RORRP019",199,0)
 ;--- Prepare the search pattern
"RTN","RORRP019",200,0)
 S PART(1)=RORREG_"#"
"RTN","RORRP019",201,0)
 S PART(2)=$G(SRCPART)
"RTN","RORRP019",202,0)
 ;--- Compile the screen logic (be careful with naked references)
"RTN","RORRP019",203,0)
 S SCR="S D=$P($G(^(0)),U,5) I D>0,$D(RORNPS(D))"
"RTN","RORRP019",204,0)
 ;--- Get the list of patients
"RTN","RORRP019",205,0)
 S TMP="P"_$S(FLAGS["B":"B",1:"")
"RTN","RORRP019",206,0)
 D LIST^DIC(798,,"@;.01I",TMP,NUMBER,.FROM,.PART,"ANP",SCR,,,"RORMSG")
"RTN","RORRP019",207,0)
 S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,798)
"RTN","RORRP019",208,0)
 ;---
"RTN","RORRP019",209,0)
 Q $S($G(RC)<0:RC,1:0)
"RTN","RORRP020")
0^50^B32201134
"RTN","RORRP020",1,0)
RORRP020 ;HCIOFO/SG - RPC: PATIENT DATA UTILITIES ; 1/9/04 12:40pm
"RTN","RORRP020",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP020",3,0)
 ;
"RTN","RORRP020",4,0)
 ; This routine uses the following IAs:
"RTN","RORRP020",5,0)
 ;
"RTN","RORRP020",6,0)
 ; #10035        Fields and x-refs of the PATIENT file (supported)
"RTN","RORRP020",7,0)
 ;
"RTN","RORRP020",8,0)
 Q
"RTN","RORRP020",9,0)
 ;
"RTN","RORRP020",10,0)
 ;***** LOADS THE DATA FROM THE 'PATIENT' FILE (#2)
"RTN","RORRP020",11,0)
 ;
"RTN","RORRP020",12,0)
 ; DFN           Patient IEN
"RTN","RORRP020",13,0)
 ;
"RTN","RORRP020",14,0)
 ; .RORDEM       Reference to a local variable where the demographic
"RTN","RORRP020",15,0)
 ;               information is returned to:
"RTN","RORRP020",16,0)
 ;
"RTN","RORRP020",17,0)
 ;                 ^01: Patient IEN (DFN)
"RTN","RORRP020",18,0)
 ;                 ^02: Patient Name
"RTN","RORRP020",19,0)
 ;                 ^03: Date of Birth (FileMan)
"RTN","RORRP020",20,0)
 ;                 ^04: SSN
"RTN","RORRP020",21,0)
 ;                 ^05: Date of Death (FileMan)
"RTN","RORRP020",22,0)
 ;                 ^06: Sex (F/M)
"RTN","RORRP020",23,0)
 ;
"RTN","RORRP020",24,0)
 ; [.RORADR]     Reference to a local variable where the patient's
"RTN","RORRP020",25,0)
 ;               address is returned to:
"RTN","RORRP020",26,0)
 ;
"RTN","RORRP020",27,0)
 ;                 ^01: Address (1)
"RTN","RORRP020",28,0)
 ;                 ^02: Address (2)
"RTN","RORRP020",29,0)
 ;                 ^03: Address (3)
"RTN","RORRP020",30,0)
 ;                 ^04: City
"RTN","RORRP020",31,0)
 ;                 ^05: State (IEN)
"RTN","RORRP020",32,0)
 ;                 ^06: State (Name)
"RTN","RORRP020",33,0)
 ;                 ^07: ZIP
"RTN","RORRP020",34,0)
 ;                 ^08: ZIP+4
"RTN","RORRP020",35,0)
 ;                 ^09: County (IEN)
"RTN","RORRP020",36,0)
 ;                 ^10: County (Name)
"RTN","RORRP020",37,0)
 ;                 ^11: Home Phone
"RTN","RORRP020",38,0)
 ;
"RTN","RORRP020",39,0)
 ; [.VADM]       Reference to a local array that is populated by
"RTN","RORRP020",40,0)
 ;               the 4^VADM API inside this function
"RTN","RORRP020",41,0)
 ;
"RTN","RORRP020",42,0)
 ; Return Values:
"RTN","RORRP020",43,0)
 ;       <0  Error code
"RTN","RORRP020",44,0)
 ;        0  Ok
"RTN","RORRP020",45,0)
 ;
"RTN","RORRP020",46,0)
LOAD2(DFN,RORDEM,RORADR,VADM) ;
"RTN","RORRP020",47,0)
 N I,VA,VAHOW,VAPA,VAROOT  D 4^VADPT
"RTN","RORRP020",48,0)
 ;--- Demographic information
"RTN","RORRP020",49,0)
 S RORDEM=DFN                          ; DFN
"RTN","RORRP020",50,0)
 S $P(RORDEM,U,2)=$G(VADM(1))          ; Name
"RTN","RORRP020",51,0)
 S $P(RORDEM,U,3)=$P($G(VADM(3)),U)    ; DOB
"RTN","RORRP020",52,0)
 S $P(RORDEM,U,4)=$P($G(VADM(2)),U)    ; SSN
"RTN","RORRP020",53,0)
 S $P(RORDEM,U,5)=$P($G(VADM(6)),U)    ; DOD
"RTN","RORRP020",54,0)
 S $P(RORDEM,U,6)=$P($G(VADM(5)),U)    ; Sex
"RTN","RORRP020",55,0)
 ;--- Patient's address
"RTN","RORRP020",56,0)
 S RORADR=$G(VAPA(1))                  ; Address (1)
"RTN","RORRP020",57,0)
 S $P(RORADR,U,2)=$G(VAPA(2))          ; Address (2)
"RTN","RORRP020",58,0)
 S $P(RORADR,U,3)=$G(VAPA(3))          ; Address (3)
"RTN","RORRP020",59,0)
 S $P(RORADR,U,4)=$G(VAPA(4))          ; City
"RTN","RORRP020",60,0)
 S $P(RORADR,U,5)=$P($G(VAPA(5)),U,1)  ; State IEN
"RTN","RORRP020",61,0)
 S $P(RORADR,U,6)=$P($G(VAPA(5)),U,2)  ; State Name
"RTN","RORRP020",62,0)
 S $P(RORADR,U,7)=$P($G(VAPA(6)),U,1)  ; ZIP
"RTN","RORRP020",63,0)
 S $P(RORADR,U,8)=$P($G(VAPA(6)),U,2)  ; ZIP+4
"RTN","RORRP020",64,0)
 S $P(RORADR,U,9)=$P($G(VAPA(7)),U,1)  ; County IEN
"RTN","RORRP020",65,0)
 S $P(RORADR,U,10)=$P($G(VAPA(7)),U,2) ; County Name
"RTN","RORRP020",66,0)
 S $P(RORADR,U,11)=$G(VAPA(8))         ; Home Phone Number
"RTN","RORRP020",67,0)
 Q 0
"RTN","RORRP020",68,0)
 ;
"RTN","RORRP020",69,0)
 ;***** LOADS THE REGISTRY DATA FOR THE PATIENT
"RTN","RORRP020",70,0)
 ;
"RTN","RORRP020",71,0)
 ; IEN           IEN of the registry record (file #798)
"RTN","RORRP020",72,0)
 ;
"RTN","RORRP020",73,0)
 ; .ROR8DST      Reference to a local variable where the results
"RTN","RORRP020",74,0)
 ;               are returned to:
"RTN","RORRP020",75,0)
 ;
"RTN","RORRP020",76,0)
 ;                 ^01: Date Entered (FileMan)
"RTN","RORRP020",77,0)
 ;                 ^02: New Patient (internal)
"RTN","RORRP020",78,0)
 ;                 ^03: Active (0/1)
"RTN","RORRP020",79,0)
 ;                 ^04: Do not Send (0/1)
"RTN","RORRP020",80,0)
 ;                 ^05: Data Acknowledged Until (FileMan)
"RTN","RORRP020",81,0)
 ;                 ^06: Data Extracted Until (FileMan)
"RTN","RORRP020",82,0)
 ;                 ^07: Inactivation Date (FileMan)
"RTN","RORRP020",83,0)
 ;                 ^08: Inactivated By (IEN)
"RTN","RORRP020",84,0)
 ;                 ^09: Inactivated By (Name)
"RTN","RORRP020",85,0)
 ;                 ^10: Reactivation Date (FileMan)
"RTN","RORRP020",86,0)
 ;                 ^11: Reactivated By (IEN)
"RTN","RORRP020",87,0)
 ;                 ^12: Reactivated By (Name)
"RTN","RORRP020",88,0)
 ;                 ^13: Action Flags (see the description below)
"RTN","RORRP020",89,0)
 ;                 ^14: Code of inactivation reason
"RTN","RORRP020",90,0)
 ;                 ^15: Code of supporting evidence
"RTN","RORRP020",91,0)
 ;
"RTN","RORRP020",92,0)
 ;               The Action Flags field indicates the actions that
"RTN","RORRP020",93,0)
 ;               can be performed on the patient's record in the
"RTN","RORRP020",94,0)
 ;               registry:
"RTN","RORRP020",95,0)
 ;
"RTN","RORRP020",96,0)
 ;                   C  CDC form can be edited/printed (VA ICR)
"RTN","RORRP020",97,0)
 ;                   D  The record can be deleted
"RTN","RORRP020",98,0)
 ;                   E  The record can be edited
"RTN","RORRP020",99,0)
 ;                   I  The record can be inactivated
"RTN","RORRP020",100,0)
 ;                   O  Read-only mode
"RTN","RORRP020",101,0)
 ;                   R  The record can be reactivated
"RTN","RORRP020",102,0)
 ;
"RTN","RORRP020",103,0)
 ; DOD           Date of Death (for deceased patients)
"RTN","RORRP020",104,0)
 ;
"RTN","RORRP020",105,0)
 ; Return Values:
"RTN","RORRP020",106,0)
 ;       <0  Error code
"RTN","RORRP020",107,0)
 ;        0  Ok
"RTN","RORRP020",108,0)
 ;
"RTN","RORRP020",109,0)
LOAD798(IEN,ROR8DST,DOD) ;
"RTN","RORRP020",110,0)
 N CANBEDEL,FLAGS,IENS,RORBUF,RORMSG,TMP
"RTN","RORRP020",111,0)
 S ROR8DST=""
"RTN","RORRP020",112,0)
 ;
"RTN","RORRP020",113,0)
 ;--- Check if the patient is in the registry
"RTN","RORRP020",114,0)
 I (IEN'>0)!($D(^RORDATA(798,+IEN))<10)  D  Q 0
"RTN","RORRP020",115,0)
 . S $P(ROR8DST,U,13)="E"
"RTN","RORRP020",116,0)
 ;
"RTN","RORRP020",117,0)
 ;--- Load internal values from the registry record
"RTN","RORRP020",118,0)
 S IENS=(+IEN)_","
"RTN","RORRP020",119,0)
 D GETS^DIQ(798,IENS,"1;2;2.1;2.2;3;3.2;7;7.1;8;9.1;9.2;11;12","I","RORBUF","RORMSG")
"RTN","RORRP020",120,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","RORRP020",121,0)
 ;
"RTN","RORRP020",122,0)
 ;--- Registry data
"RTN","RORRP020",123,0)
 S ROR8DST=$G(RORBUF(798,IENS,1,"I"))            ; DATE ENTERED
"RTN","RORRP020",124,0)
 S $P(ROR8DST,U,2)=+$G(RORBUF(798,IENS,3,"I"))   ; NEW PATIENT
"RTN","RORRP020",125,0)
 S $P(ROR8DST,U,4)=+$G(RORBUF(798,IENS,11,"I"))  ; DON'T SEND
"RTN","RORRP020",126,0)
 S $P(ROR8DST,U,5)=$G(RORBUF(798,IENS,9.1,"I"))  ; ACKNOWLEDGED UNTIL
"RTN","RORRP020",127,0)
 S $P(ROR8DST,U,6)=$G(RORBUF(798,IENS,9.2,"I"))  ; EXTRACTED UNTIL
"RTN","RORRP020",128,0)
 S CANBEDEL=+$G(RORBUF(798,IENS,12,"I"))         ; CAN BE DELETED
"RTN","RORRP020",129,0)
 ;
"RTN","RORRP020",130,0)
 ;--- Inactivation information
"RTN","RORRP020",131,0)
 S TMP=$G(RORBUF(798,IENS,2,"I"))
"RTN","RORRP020",132,0)
 D:TMP>0
"RTN","RORRP020",133,0)
 . S $P(ROR8DST,U,7)=TMP,TMP=$G(RORBUF(798,IENS,2.1,"I"))
"RTN","RORRP020",134,0)
 . S $P(ROR8DST,U,8,9)=TMP_U_$$EXTERNAL^DILFD(798,2.1,,TMP,"RORMSG")
"RTN","RORRP020",135,0)
 . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,798)
"RTN","RORRP020",136,0)
 . S TMP=$$ITEMCODE^RORUTL09($G(RORBUF(798,IENS,2.2,"I")))
"RTN","RORRP020",137,0)
 . S:TMP>0 $P(ROR8DST,U,14)=TMP
"RTN","RORRP020",138,0)
 ;
"RTN","RORRP020",139,0)
 ;--- Reactivation information
"RTN","RORRP020",140,0)
 S TMP=$G(RORBUF(798,IENS,7,"I"))
"RTN","RORRP020",141,0)
 D:TMP>0
"RTN","RORRP020",142,0)
 . S $P(ROR8DST,U,10)=TMP,TMP=$G(RORBUF(798,IENS,7.1,"I"))
"RTN","RORRP020",143,0)
 . S $P(ROR8DST,U,11,12)=TMP_U_$$EXTERNAL^DILFD(798,7.1,,TMP,"RORMSG")
"RTN","RORRP020",144,0)
 . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,798)
"RTN","RORRP020",145,0)
 ;
"RTN","RORRP020",146,0)
 ;--- Supporting evidence
"RTN","RORRP020",147,0)
 S TMP=$$ITEMCODE^RORUTL09($G(RORBUF(798,IENS,3.2,"I")))
"RTN","RORRP020",148,0)
 S:TMP>0 $P(ROR8DST,U,15)=TMP
"RTN","RORRP020",149,0)
 ;
"RTN","RORRP020",150,0)
 ;--- Check if the patient is active
"RTN","RORRP020",151,0)
 S $P(ROR8DST,U,3)=$$ACTIVE^RORDD(+IENS)
"RTN","RORRP020",152,0)
 ;
"RTN","RORRP020",153,0)
 ;--- Action flags
"RTN","RORRP020",154,0)
 ; The actions and modes are enabled/disabled according to the
"RTN","RORRP020",155,0)
 ; following table:
"RTN","RORRP020",156,0)
 ;---------------------------------------------------------------;
"RTN","RORRP020",157,0)
 ;   Actions    ;              Status of the patient             ;
"RTN","RORRP020",158,0)
 ;     and      ;------------------------------------------------;
"RTN","RORRP020",159,0)
 ;    Modes     ;Not Added;Pending;Active;Inactive;Data Sent;Dead;
"RTN","RORRP020",160,0)
 ;--------------+---------+-------+------+--------+---------+----;
"RTN","RORRP020",161,0)
 ; (C)DC        ;    D    ;   D   ;      ;        ;         ;    ;
"RTN","RORRP020",162,0)
 ; (D)elete     ;    D    ;       ;      ;        ;    D    ;    ;
"RTN","RORRP020",163,0)
 ; (E)dit       ;         ;       ;      ;        ;         ;    ;
"RTN","RORRP020",164,0)
 ; (I)nactivate ;    D    ;   D   ;      ;   D    ;         ; E* ;
"RTN","RORRP020",165,0)
 ; (R)eactivate ;    D    ;   D   ;  D   ;        ;         ; D  ;
"RTN","RORRP020",166,0)
 ; Read (O)nly  ;         ;       ;      ;        ;         ;    ;
"RTN","RORRP020",167,0)
 ;---------------------------------------------------------------;
"RTN","RORRP020",168,0)
 ; D  the action is disabled if at least one of the marked
"RTN","RORRP020",169,0)
 ;    conditions is true;
"RTN","RORRP020",170,0)
 ;
"RTN","RORRP020",171,0)
 ; E  the action is enabled if at least one of the marked
"RTN","RORRP020",172,0)
 ;    conditions is true.
"RTN","RORRP020",173,0)
 ;
"RTN","RORRP020",174,0)
 ; *  If the patient has been automatically inactivated 30 days
"RTN","RORRP020",175,0)
 ;    after the date of death and then it is discovered that
"RTN","RORRP020",176,0)
 ;    he/she has been added to the registry in error, a user
"RTN","RORRP020",177,0)
 ;    will be allowed to manually inactivate this patient again
"RTN","RORRP020",178,0)
 ;    and provide the inactivation reason.
"RTN","RORRP020",179,0)
 ;---
"RTN","RORRP020",180,0)
 D
"RTN","RORRP020",181,0)
 . I $P(ROR8DST,U,2)=4  S FLAGS="DE"  Q    ; Pending
"RTN","RORRP020",182,0)
 . S FLAGS="CEI"
"RTN","RORRP020",183,0)
 . S:CANBEDEL FLAGS=FLAGS_"D"              ; Can be deleted
"RTN","RORRP020",184,0)
 . Q:$P(ROR8DST,U,3)                       ; Active
"RTN","RORRP020",185,0)
 . S:DOD'>0 FLAGS=FLAGS_"R"                ; Alive
"RTN","RORRP020",186,0)
 . S:$P(ROR8DST,U,14) FLAGS=$TR(FLAGS,"I") ; Inactivated manually
"RTN","RORRP020",187,0)
 S $P(ROR8DST,U,13)=FLAGS
"RTN","RORRP020",188,0)
 Q 0
"RTN","RORRP020",189,0)
 ;
"RTN","RORRP020",190,0)
 ;***** PERFORMS THE POST-PROCESSING OF THE LISTS
"RTN","RORRP020",191,0)
 ;
"RTN","RORRP020",192,0)
 ; RESULTS       Closed root of the array that contains the
"RTN","RORRP020",193,0)
 ;               results of the query
"RTN","RORRP020",194,0)
 ;
"RTN","RORRP020",195,0)
 ; REGIEN        Registry IEN
"RTN","RORRP020",196,0)
 ;
"RTN","RORRP020",197,0)
 ; FLAGS         Flags that control the execution
"RTN","RORRP020",198,0)
 ;
"RTN","RORRP020",199,0)
 ; Return Values:
"RTN","RORRP020",200,0)
 ;       <0  Error code
"RTN","RORRP020",201,0)
 ;        0  Ok
"RTN","RORRP020",202,0)
 ;
"RTN","RORRP020",203,0)
POSTPROC(RESULTS,REGIEN,FLAGS) ;
"RTN","RORRP020",204,0)
 N BUF,DOD,FNP,FO,IEN,IR,PATIEN,RC,TMP
"RTN","RORRP020",205,0)
 S FNP=($TR(FLAGS,"NP")'=FLAGS),FO=(FLAGS["O")
"RTN","RORRP020",206,0)
 ;--- Process the resulting records
"RTN","RORRP020",207,0)
 S (IR,RC)=0
"RTN","RORRP020",208,0)
 F  S IR=$O(@RESULTS@(IR))  Q:IR'>0  D  Q:RC<0
"RTN","RORRP020",209,0)
 . S BUF=$G(@RESULTS@(IR,0)),PATIEN=+$P(BUF,U,2)
"RTN","RORRP020",210,0)
 . I PATIEN'>0  S PATIEN=+BUF  Q:PATIEN'>0
"RTN","RORRP020",211,0)
 . ;--- Load the required fields from the PATIENT file
"RTN","RORRP020",212,0)
 . Q:$$LOAD2(PATIEN,.BUF)<0
"RTN","RORRP020",213,0)
 . S DOD=$P(BUF,U,5)
"RTN","RORRP020",214,0)
 . S @RESULTS@(IR,0)=BUF
"RTN","RORRP020",215,0)
 . ;--- Add optional registry fields if necessary
"RTN","RORRP020",216,0)
 . I FO  D  Q:RC<0
"RTN","RORRP020",217,0)
 . . ;--- Get the IEN of the registry record
"RTN","RORRP020",218,0)
 . . S IEN=$$PRRIEN^RORUTL01(PATIEN,REGIEN)
"RTN","RORRP020",219,0)
 . . ;--- Try to load the data from the ROR LOCAL REGISTRY file
"RTN","RORRP020",220,0)
 . . S RC=$$LOAD798(IEN,.BUF,DOD)
"RTN","RORRP020",221,0)
 . . S:RC'<0 @RESULTS@(IR,1)="O^"_BUF
"RTN","RORRP020",222,0)
 ;---
"RTN","RORRP020",223,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORRP021")
0^51^B14656437
"RTN","RORRP021",1,0)
RORRP021 ;HCIOFO/SG - RPC: PATIENT DATA ; 6/26/03 11:08am
"RTN","RORRP021",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP021",3,0)
 ;
"RTN","RORRP021",4,0)
 Q
"RTN","RORRP021",5,0)
 ;
"RTN","RORRP021",6,0)
 ;***** LOADS THE PATIENT DATA
"RTN","RORRP021",7,0)
 ; RPC: [ROR PATIENT GET DATA]
"RTN","RORRP021",8,0)
 ;
"RTN","RORRP021",9,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP021",10,0)
 ;               are returned to.
"RTN","RORRP021",11,0)
 ;
"RTN","RORRP021",12,0)
 ; PATIEN        IEN of the patient (DFN)
"RTN","RORRP021",13,0)
 ;
"RTN","RORRP021",14,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORRP021",15,0)
 ;                 A  Load the patient's address
"RTN","RORRP021",16,0)
 ;                 E  Load the ethnicity information
"RTN","RORRP021",17,0)
 ;                 R  Load the race information
"RTN","RORRP021",18,0)
 ;
"RTN","RORRP021",19,0)
 ; [REGIEN]      Registry IEN.
"RTN","RORRP021",20,0)
 ;               If value of this parameter is greater than 0
"RTN","RORRP021",21,0)
 ;               then the "PRD" segment with the basic patient's
"RTN","RORRP021",22,0)
 ;               registry data will be returned. If the patient
"RTN","RORRP021",23,0)
 ;               is not in the registry then an empty "PRD" segment
"RTN","RORRP021",24,0)
 ;               will be returned anyway.
"RTN","RORRP021",25,0)
 ;
"RTN","RORRP021",26,0)
 ; Return Values:
"RTN","RORRP021",27,0)
 ;
"RTN","RORRP021",28,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP021",29,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP021",30,0)
 ; details).
"RTN","RORRP021",31,0)
 ;
"RTN","RORRP021",32,0)
 ; Otherwise, zero is returned in the RESULTS(0) and the subsequent
"RTN","RORRP021",33,0)
 ; nodes of the array contain the patient's data.
"RTN","RORRP021",34,0)
 ; 
"RTN","RORRP021",35,0)
 ; RESULTS(0)            0
"RTN","RORRP021",36,0)
 ;
"RTN","RORRP021",37,0)
 ; RESULTS(i)            Demographic Information
"RTN","RORRP021",38,0)
 ;                         ^01: "DEM"
"RTN","RORRP021",39,0)
 ;                         ^02: ""
"RTN","RORRP021",40,0)
 ;                         ...  See the $$LOAD2^RORRP020 (RORDEM)
"RTN","RORRP021",41,0)
 ;
"RTN","RORRP021",42,0)
 ; RESULTS(i)            Patient's Address
"RTN","RORRP021",43,0)
 ;                         ^01: "ADR"
"RTN","RORRP021",44,0)
 ;                         ^02: ""
"RTN","RORRP021",45,0)
 ;                         ...  See the $$LOAD2^RORRP020 (RORADR)
"RTN","RORRP021",46,0)
 ;
"RTN","RORRP021",47,0)
 ; RESULTS(i)            Race Information
"RTN","RORRP021",48,0)
 ;                         ^01: "RCE"
"RTN","RORRP021",49,0)
 ;                         ^02: Race IEN
"RTN","RORRP021",50,0)
 ;                         ^03: Race HL7 Value
"RTN","RORRP021",51,0)
 ;                         ^04: Race
"RTN","RORRP021",52,0)
 ;                         ^05: Collection Method HL7 Value
"RTN","RORRP021",53,0)
 ;                         ^06: Collection Method
"RTN","RORRP021",54,0)
 ;
"RTN","RORRP021",55,0)
 ;                       Race HL7 Values
"RTN","RORRP021",56,0)
 ;                         1002-5  American Indian or Alaska Native
"RTN","RORRP021",57,0)
 ;                         2028-9  Asian
"RTN","RORRP021",58,0)
 ;                         2054-5  Black or African American
"RTN","RORRP021",59,0)
 ;                         0000-0  Declined to Answer
"RTN","RORRP021",60,0)
 ;                         2076-8  Native Hawaiian or Pacific Islander
"RTN","RORRP021",61,0)
 ;                         9999-4  Unknown by Patient
"RTN","RORRP021",62,0)
 ;                         2106-3  White
"RTN","RORRP021",63,0)
 ;
"RTN","RORRP021",64,0)
 ;                       Collection Method HL7 Values
"RTN","RORRP021",65,0)
 ;                         OBS     Observer
"RTN","RORRP021",66,0)
 ;                         PRX     Proxy
"RTN","RORRP021",67,0)
 ;                         SLF     Self Identification
"RTN","RORRP021",68,0)
 ;                         UNK     Unknown
"RTN","RORRP021",69,0)
 ;
"RTN","RORRP021",70,0)
 ; RESULTS(i)            Ethnicity Information
"RTN","RORRP021",71,0)
 ;                         ^01: "ETN"
"RTN","RORRP021",72,0)
 ;                         ^02: Ethnicity IEN
"RTN","RORRP021",73,0)
 ;                         ^03: Ethnicity HL7 Value
"RTN","RORRP021",74,0)
 ;                         ^04: Ethnicity
"RTN","RORRP021",75,0)
 ;                         ^05: Collection Method HL7 value
"RTN","RORRP021",76,0)
 ;                         ^06: Collection Method
"RTN","RORRP021",77,0)
 ;
"RTN","RORRP021",78,0)
 ;                       Ethnicity HL7 Values
"RTN","RORRP021",79,0)
 ;                         0000-0  Declined to Answer
"RTN","RORRP021",80,0)
 ;                         2135-2  Hispanic or Latino
"RTN","RORRP021",81,0)
 ;                         2186-5  Not Hispanic or Latino
"RTN","RORRP021",82,0)
 ;                         9999-4  Unknown by Patient
"RTN","RORRP021",83,0)
 ;
"RTN","RORRP021",84,0)
 ; RESULTS(i)            Patient's Registry Data
"RTN","RORRP021",85,0)
 ;                         ^01: "PRD"
"RTN","RORRP021",86,0)
 ;                         ^02: ""
"RTN","RORRP021",87,0)
 ;                         ...  See the $$LOAD798^RORRP020
"RTN","RORRP021",88,0)
 ;
"RTN","RORRP021",89,0)
GETPTDAT(RESULTS,PATIEN,FLAGS,REGIEN) ;
"RTN","RORRP021",90,0)
 N BUF,BUF1,DOD,IEN,RC,RESPTR,RORERRDL,VADM
"RTN","RORRP021",91,0)
 D CLEAR^RORERR("GETPTDAT^RORRP021",1)
"RTN","RORRP021",92,0)
 K RESULTS  S (RESULTS(0),RESPTR)=0
"RTN","RORRP021",93,0)
 ;--- Check the parameters
"RTN","RORRP021",94,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP021",95,0)
 . ;--- Patient IEN
"RTN","RORRP021",96,0)
 . I $G(PATIEN)'>0  D  Q
"RTN","RORRP021",97,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"PATIEN",$G(PATIEN))
"RTN","RORRP021",98,0)
 . S PATIEN=+PATIEN
"RTN","RORRP021",99,0)
 . ;--- Flags
"RTN","RORRP021",100,0)
 . S FLAGS=$$UP^XLFSTR($G(FLAGS))
"RTN","RORRP021",101,0)
 ;--- Load the data from the PATIENT file
"RTN","RORRP021",102,0)
 S RC=$$LOAD2^RORRP020(PATIEN,.BUF,.BUF1,.VADM)
"RTN","RORRP021",103,0)
 I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP021",104,0)
 S DOD=$P(BUF,U,5)
"RTN","RORRP021",105,0)
 ;--- Demographic information and address
"RTN","RORRP021",106,0)
 S RESPTR=RESPTR+1,RESULTS(RESPTR)="DEM^^"_BUF
"RTN","RORRP021",107,0)
 S:FLAGS["A" RESPTR=RESPTR+1,RESULTS(RESPTR)="ADR^^"_BUF1
"RTN","RORRP021",108,0)
 ;--- Race information
"RTN","RORRP021",109,0)
 I FLAGS["R"  D:$G(VADM(12))>0
"RTN","RORRP021",110,0)
 . N I,METHOD,RACE
"RTN","RORRP021",111,0)
 . S I=""
"RTN","RORRP021",112,0)
 . F  S I=$O(VADM(12,I))  Q:I=""  D
"RTN","RORRP021",113,0)
 . . S RACE=$G(VADM(12,I))  Q:RACE'>0
"RTN","RORRP021",114,0)
 . . S METHOD=$G(VADM(12,I,1))
"RTN","RORRP021",115,0)
 . . S BUF="RCE"_U_(+RACE)
"RTN","RORRP021",116,0)
 . . ;--- 
"RTN","RORRP021",117,0)
 . . S $P(BUF,U,3)=$$PTR2CODE^DGUTL4(+RACE,1,2)
"RTN","RORRP021",118,0)
 . . S $P(BUF,U,4)=$P(RACE,U,2)
"RTN","RORRP021",119,0)
 . . S $P(BUF,U,5)=$$PTR2CODE^DGUTL4(+METHOD,3,2)
"RTN","RORRP021",120,0)
 . . S $P(BUF,U,6)=$P(METHOD,U,2)
"RTN","RORRP021",121,0)
 . . ;---
"RTN","RORRP021",122,0)
 . . S RESPTR=RESPTR+1,RESULTS(RESPTR)=BUF
"RTN","RORRP021",123,0)
 ;--- Ethnicity information
"RTN","RORRP021",124,0)
 I FLAGS["E"  D:$G(VADM(11))>0
"RTN","RORRP021",125,0)
 . N ETHN,I,METHOD
"RTN","RORRP021",126,0)
 . S I=""
"RTN","RORRP021",127,0)
 . F  S I=$O(VADM(11,I))  Q:I=""  D
"RTN","RORRP021",128,0)
 . . S ETHN=$G(VADM(11,I))  Q:ETHN'>0
"RTN","RORRP021",129,0)
 . . S METHOD=$G(VADM(11,I,1))
"RTN","RORRP021",130,0)
 . . S BUF="ETN"_U_(+ETHN)
"RTN","RORRP021",131,0)
 . . ;--- 
"RTN","RORRP021",132,0)
 . . S $P(BUF,U,3)=$$PTR2CODE^DGUTL4(+ETHN,2,2)
"RTN","RORRP021",133,0)
 . . S $P(BUF,U,4)=$P(ETHN,U,2)
"RTN","RORRP021",134,0)
 . . S $P(BUF,U,5)=$$PTR2CODE^DGUTL4(+METHOD,3,2)
"RTN","RORRP021",135,0)
 . . S $P(BUF,U,6)=$P(METHOD,U,2)
"RTN","RORRP021",136,0)
 . . ;---
"RTN","RORRP021",137,0)
 . . S RESPTR=RESPTR+1,RESULTS(RESPTR)=BUF
"RTN","RORRP021",138,0)
 ;--- Patient's registry data
"RTN","RORRP021",139,0)
 I $G(REGIEN)>0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP021",140,0)
 . S RESPTR=RESPTR+1
"RTN","RORRP021",141,0)
 . ;--- Get the IEN of the registry record
"RTN","RORRP021",142,0)
 . S IEN=$$PRRIEN^RORUTL01(PATIEN,REGIEN)
"RTN","RORRP021",143,0)
 . ;--- Try to load the data from the ROR LOCAL REGISTRY file
"RTN","RORRP021",144,0)
 . S RC=$$LOAD798^RORRP020(IEN,.BUF,DOD)
"RTN","RORRP021",145,0)
 . S:RC'<0 RESULTS(RESPTR)="PRD^^"_BUF
"RTN","RORRP021",146,0)
 Q
"RTN","RORRP022")
0^59^B4139255
"RTN","RORRP022",1,0)
RORRP022 ;HCIOFO/SG - RPC: SELECTION RULES ; 9/29/03 3:34pm
"RTN","RORRP022",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP022",3,0)
 ;
"RTN","RORRP022",4,0)
 Q
"RTN","RORRP022",5,0)
 ;
"RTN","RORRP022",6,0)
 ;***** LOADS THE SELECTION RULES FROM THE REGISTRY RECORD
"RTN","RORRP022",7,0)
 ; RPC: [ROR PATIENT SELECTION RULES]
"RTN","RORRP022",8,0)
 ;
"RTN","RORRP022",9,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP022",10,0)
 ;               are returned to.
"RTN","RORRP022",11,0)
 ;
"RTN","RORRP022",12,0)
 ; REGIEN        Registry IEN
"RTN","RORRP022",13,0)
 ;
"RTN","RORRP022",14,0)
 ; PATIEN        IEN of the registry patient (DFN)
"RTN","RORRP022",15,0)
 ;
"RTN","RORRP022",16,0)
 ; Return Values:
"RTN","RORRP022",17,0)
 ;
"RTN","RORRP022",18,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP022",19,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP022",20,0)
 ; details).
"RTN","RORRP022",21,0)
 ;
"RTN","RORRP022",22,0)
 ; Otherwise, number of selection rules is returned in the RESULTS(0)
"RTN","RORRP022",23,0)
 ; and the subsequent nodes of the array contain the rules.
"RTN","RORRP022",24,0)
 ; 
"RTN","RORRP022",25,0)
 ; RESULTS(0)            Number of selection rules
"RTN","RORRP022",26,0)
 ;
"RTN","RORRP022",27,0)
 ; RESULTS(i)            Selection Rule
"RTN","RORRP022",28,0)
 ;                         ^01: IEN in the SELECTION RULE multiple
"RTN","RORRP022",29,0)
 ;                              of the ROR LOCAL REGISTRY file
"RTN","RORRP022",30,0)
 ;                         ^02: IEN of the Rule (in the
"RTN","RORRP022",31,0)
 ;                              ROR SELECTION RULE file)
"RTN","RORRP022",32,0)
 ;                         ^03: Name of the Rule
"RTN","RORRP022",33,0)
 ;                         ^04: Date (FileMan)
"RTN","RORRP022",34,0)
 ;                         ^05: Short Description
"RTN","RORRP022",35,0)
 ;
"RTN","RORRP022",36,0)
PTRULES(RESULTS,REGIEN,PATIEN) ;
"RTN","RORRP022",37,0)
 N BUF,CNT,I,IEN,IENS,RC,RORBUF,RORMSG,TMP
"RTN","RORRP022",38,0)
 D CLEAR^RORERR("PTRULES^RORRP022",1)
"RTN","RORRP022",39,0)
 K RESULTS  S RESULTS(0)=0
"RTN","RORRP022",40,0)
 ;--- Check the parameters
"RTN","RORRP022",41,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP022",42,0)
 . ;--- Registry IEN
"RTN","RORRP022",43,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP022",44,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP022",45,0)
 . S REGIEN=+REGIEN
"RTN","RORRP022",46,0)
 . ;--- Patient IEN
"RTN","RORRP022",47,0)
 . I $G(PATIEN)'>0  D  Q
"RTN","RORRP022",48,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"PATIEN",$G(PATIEN))
"RTN","RORRP022",49,0)
 . S PATIEN=+PATIEN
"RTN","RORRP022",50,0)
 ;--- Get the IEN of the registry record
"RTN","RORRP022",51,0)
 S IEN=$$PRRIEN^RORUTL01(PATIEN,REGIEN)  Q:IEN'>0
"RTN","RORRP022",52,0)
 ;--- Load the selection rules
"RTN","RORRP022",53,0)
 S IENS=","_IEN_",",TMP="@;.01I;.01E;1I"
"RTN","RORRP022",54,0)
 D LIST^DIC(798.01,IENS,TMP,"P",,,,"AD",,,"RORBUF","RORMSG")
"RTN","RORRP022",55,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP022",56,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.01,IENS)
"RTN","RORRP022",57,0)
 ;--- Populate the output array
"RTN","RORRP022",58,0)
 S (CNT,I)=0
"RTN","RORRP022",59,0)
 F  S I=$O(RORBUF("DILIST",I))  Q:I'>0  D
"RTN","RORRP022",60,0)
 . S BUF=RORBUF("DILIST",I,0),IEN=+$P(BUF,U,2)  Q:IEN'>0
"RTN","RORRP022",61,0)
 . S CNT=CNT+1,RESULTS(CNT)=BUF
"RTN","RORRP022",62,0)
 . S TMP=$$GET1^DIQ(798.2,IEN_",",4,,,"RORMSG")
"RTN","RORRP022",63,0)
 . S $P(RESULTS(CNT),U,5)=$S(TMP'="":TMP,1:$P(BUF,U,3))
"RTN","RORRP022",64,0)
 S RESULTS(0)=CNT
"RTN","RORRP022",65,0)
 Q
"RTN","RORRP023")
0^61^B10243108
"RTN","RORRP023",1,0)
RORRP023 ;HCIOFO/SG - RPC: REGISTRY COORDINATORS ; 7/16/03 11:25am
"RTN","RORRP023",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP023",3,0)
 ;
"RTN","RORRP023",4,0)
 ; This routine uses the following IAs:
"RTN","RORRP023",5,0)
 ;
"RTN","RORRP023",6,0)
 ; #10060        Read access (FileMan) to the file #200 (supported)
"RTN","RORRP023",7,0)
 ;
"RTN","RORRP023",8,0)
 Q
"RTN","RORRP023",9,0)
 ;
"RTN","RORRP023",10,0)
 ;***** RETURNS THE LIST OF REGISTRY COORDINATORS
"RTN","RORRP023",11,0)
 ; RPC: [ROR LIST COORDINATORS]
"RTN","RORRP023",12,0)
 ;
"RTN","RORRP023",13,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP023",14,0)
 ;               are returned to.
"RTN","RORRP023",15,0)
 ;
"RTN","RORRP023",16,0)
 ; REGIEN        Registry IEN
"RTN","RORRP023",17,0)
 ;
"RTN","RORRP023",18,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP023",19,0)
 ;
"RTN","RORRP023",20,0)
 ; Return Values:
"RTN","RORRP023",21,0)
 ;
"RTN","RORRP023",22,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP023",23,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP023",24,0)
 ; details).
"RTN","RORRP023",25,0)
 ;
"RTN","RORRP023",26,0)
 ; Otherwise, number of coordinators is returned in the
"RTN","RORRP023",27,0)
 ; @RESULTS@(0) and the subsequent nodes of the global array
"RTN","RORRP023",28,0)
 ; contain the coordinators.
"RTN","RORRP023",29,0)
 ; 
"RTN","RORRP023",30,0)
 ; @RESULTS@(0)          Number of Coordinators
"RTN","RORRP023",31,0)
 ;
"RTN","RORRP023",32,0)
 ; @RESULTS@(i)          Coordinator's Descriptor
"RTN","RORRP023",33,0)
 ;                         ^01: IEN
"RTN","RORRP023",34,0)
 ;                         ^02: Name
"RTN","RORRP023",35,0)
 ;
"RTN","RORRP023",36,0)
RCLIST(RESULTS,REGIEN) ;
"RTN","RORRP023",37,0)
 N IENS,RC,RORERRDL,RORMSG,TMP
"RTN","RORRP023",38,0)
 D CLEAR^RORERR("RCLIST^RORRP023",1)
"RTN","RORRP023",39,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP023",40,0)
 ;--- Check the parameters
"RTN","RORRP023",41,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP023",42,0)
 . ;--- Registry IEN
"RTN","RORRP023",43,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP023",44,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP023",45,0)
 . S REGIEN=+REGIEN
"RTN","RORRP023",46,0)
 ;--- Get the list of coordinators
"RTN","RORRP023",47,0)
 S IENS=","_REGIEN_",",TMP="@;.01E"
"RTN","RORRP023",48,0)
 D LIST^DIC(798.114,IENS,TMP,"PU",,,,"B",,,,"RORMSG")
"RTN","RORRP023",49,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP023",50,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.114,IENS)
"RTN","RORRP023",51,0)
 ;--- Success
"RTN","RORRP023",52,0)
 S TMP=+$G(^TMP("DILIST",$J,0))
"RTN","RORRP023",53,0)
 K ^TMP("DILIST",$J,0)  S @RESULTS@(0)=TMP
"RTN","RORRP023",54,0)
 Q
"RTN","RORRP023",55,0)
 ;
"RTN","RORRP023",56,0)
 ;***** UPDATES THE LIST OF REGISTRY COORDINATORS
"RTN","RORRP023",57,0)
 ; RPC: [ROR UPDATE COORDINATORS]
"RTN","RORRP023",58,0)
 ;
"RTN","RORRP023",59,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP023",60,0)
 ;               are returned to.
"RTN","RORRP023",61,0)
 ;
"RTN","RORRP023",62,0)
 ; REGIEN        Registry IEN
"RTN","RORRP023",63,0)
 ;
"RTN","RORRP023",64,0)
 ; .RCLST(       Reference to a local variable that contains
"RTN","RORRP023",65,0)
 ;               a list of registry coordinators
"RTN","RORRP023",66,0)
 ;   i)            User IEN (DUZ)
"RTN","RORRP023",67,0)
 ;
"RTN","RORRP023",68,0)
 ; Return Values:
"RTN","RORRP023",69,0)
 ;
"RTN","RORRP023",70,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP023",71,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP023",72,0)
 ; details).
"RTN","RORRP023",73,0)
 ;
"RTN","RORRP023",74,0)
 ; Otherwise, zero is returned in the RESULTS(0).
"RTN","RORRP023",75,0)
 ;
"RTN","RORRP023",76,0)
RCLUPD(RESULTS,REGIEN,RCLST) ;
"RTN","RORRP023",77,0)
 N DA,DIK,ECNT,IEN,IENS,RC,RCL,ROOT,RORERRDL,RORFDA,RORIEN,RORMSG,TMP
"RTN","RORRP023",78,0)
 D CLEAR^RORERR("RCLUPD^RORRP023",1)  K RESULTS
"RTN","RORRP023",79,0)
 ;--- Check the parameters
"RTN","RORRP023",80,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP023",81,0)
 . ;--- Registry IEN
"RTN","RORRP023",82,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP023",83,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP023",84,0)
 . S REGIEN=+REGIEN
"RTN","RORRP023",85,0)
 ;
"RTN","RORRP023",86,0)
 ;--- Lock the COORDINATOR multiple
"RTN","RORRP023",87,0)
 S IENS=","_REGIEN_","
"RTN","RORRP023",88,0)
 S RC=$$LOCK^RORLOCK(798.114,IENS)
"RTN","RORRP023",89,0)
 I RC  D:RC>0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP023",90,0)
 . S RC=$$ERROR^RORERR(-11,,,,"the COORDINATOR multiple")
"RTN","RORRP023",91,0)
 ;---
"RTN","RORRP023",92,0)
 S ROOT=$$ROOT^DILFD(798.114,IENS,1)
"RTN","RORRP023",93,0)
 ;
"RTN","RORRP023",94,0)
 ;--- Create a list of coordinators' IENs
"RTN","RORRP023",95,0)
 S TMP=""
"RTN","RORRP023",96,0)
 F  S TMP=$O(RCLST(TMP))  Q:TMP=""  D
"RTN","RORRP023",97,0)
 . S IEN=+RCLST(TMP)
"RTN","RORRP023",98,0)
 . S:$$FIND1^DIC(200,,,"`"_IEN,,,"RORMSG")>0 RCL(IEN)=""
"RTN","RORRP023",99,0)
 ;
"RTN","RORRP023",100,0)
 ;--- Delete the coordinators
"RTN","RORRP023",101,0)
 S DIK=$$OREF^DILF(ROOT),DA(1)=REGIEN,DA=0
"RTN","RORRP023",102,0)
 F  S DA=$O(@ROOT@(DA))  Q:DA'>0  D:'$D(RCL(DA)) ^DIK
"RTN","RORRP023",103,0)
 ;--- Update the coordinators
"RTN","RORRP023",104,0)
 S (ECNT,IEN)=0,IENS="?+1,"_REGIEN_","
"RTN","RORRP023",105,0)
 F  S IEN=$O(RCL(IEN))  Q:IEN'>0  D
"RTN","RORRP023",106,0)
 . S RORFDA(798.114,IENS,.01)=IEN
"RTN","RORRP023",107,0)
 . S RORIEN(1)=IEN
"RTN","RORRP023",108,0)
 . D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORRP023",109,0)
 . I $G(DIERR)  D  S ECNT=ECNT+1  Q
"RTN","RORRP023",110,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,798.114,IENS)
"RTN","RORRP023",111,0)
 ;
"RTN","RORRP023",112,0)
 ;--- Unlock the multiple and check for errors
"RTN","RORRP023",113,0)
 D UNLOCK^RORLOCK(798.114,","_REGIEN_",")
"RTN","RORRP023",114,0)
 I ECNT>0  D RPCSTK^RORERR(.RESULTS,-9)  Q
"RTN","RORRP023",115,0)
 ;--- Success
"RTN","RORRP023",116,0)
 S RESULTS(0)=0
"RTN","RORRP023",117,0)
 Q
"RTN","RORRP024")
0^62^B18249929
"RTN","RORRP024",1,0)
RORRP024 ;HCIOFO/SG - RPC: VISTA USERS ; 2/3/04 7:44am
"RTN","RORRP024",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP024",3,0)
 ;
"RTN","RORRP024",4,0)
 ; This routine uses the following IAs:
"RTN","RORRP024",5,0)
 ;
"RTN","RORRP024",6,0)
 ; #10060        Read access (FileMan) to the NEW PERSON file
"RTN","RORRP024",7,0)
 ;
"RTN","RORRP024",8,0)
 Q
"RTN","RORRP024",9,0)
 ;
"RTN","RORRP024",10,0)
 ;***** RETURNS THE DEFAULT DIVISION FOR THE USER
"RTN","RORRP024",11,0)
 ;
"RTN","RORRP024",12,0)
 ; USER          User IEN in file #200 (DUZ)
"RTN","RORRP024",13,0)
 ;
"RTN","RORRP024",14,0)
 ; Return Values:
"RTN","RORRP024",15,0)
 ;      ...  Default Division
"RTN","RORRP024",16,0)
 ;             ^01: IEN (in the INSTITUTION file)
"RTN","RORRP024",17,0)
 ;             ^02: Name
"RTN","RORRP024",18,0)
 ;
"RTN","RORRP024",19,0)
DFLTDIV(USER) ;
"RTN","RORRP024",20,0)
 N DIV,IENS,IR,RORBUF,RORMSG,TMP
"RTN","RORRP024",21,0)
 S IENS=","_(+USER)_",",TMP="@;.01I;.01E;1I"
"RTN","RORRP024",22,0)
 D LIST^DIC(200.02,IENS,TMP,"PQ",,,,"#",,,"RORBUF","RORMSG")
"RTN","RORRP024",23,0)
 D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,200,IENS)
"RTN","RORRP024",24,0)
 S DIV=""
"RTN","RORRP024",25,0)
 ;--- Look for default division
"RTN","RORRP024",26,0)
 D:$G(RORBUF("DILIST",0))>0
"RTN","RORRP024",27,0)
 . S IR=0
"RTN","RORRP024",28,0)
 . F  S IR=$O(RORBUF("DILIST",IR))  Q:IR'>0  D  Q:DIV'=""
"RTN","RORRP024",29,0)
 . . S TMP=$G(RORBUF("DILIST",IR,0))
"RTN","RORRP024",30,0)
 . . S:$P(TMP,U,4) DIV=$P(TMP,U,2,3)
"RTN","RORRP024",31,0)
 . ;--- If name of the default division is not available
"RTN","RORRP024",32,0)
 . ;    and the only division is associated with the user
"RTN","RORRP024",33,0)
 . ;--- then use this division as the default one.
"RTN","RORRP024",34,0)
 . I $P(DIV,U,2)=""  D:RORBUF("DILIST",0)<2
"RTN","RORRP024",35,0)
 . . S DIV=$P($G(RORBUF("DILIST",1,0)),U,2,3)
"RTN","RORRP024",36,0)
 ;--- If default division is not available, use the site
"RTN","RORRP024",37,0)
 Q $S($P(DIV,U,2)'="":DIV,1:$P($$SITE^VASITE(),U,1,2))
"RTN","RORRP024",38,0)
 ;
"RTN","RORRP024",39,0)
 ;***** RETURNS INFORMATION ABOUT THE USER
"RTN","RORRP024",40,0)
 ; RPC: [ROR GET USER IFNO]
"RTN","RORRP024",41,0)
 ;
"RTN","RORRP024",42,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP024",43,0)
 ;               are returned to.
"RTN","RORRP024",44,0)
 ;
"RTN","RORRP024",45,0)
 ; [USER]        User IEN in the NEW PERSON file. By default
"RTN","RORRP024",46,0)
 ;               (if $G(USER)'>0), the DUZ is used).
"RTN","RORRP024",47,0)
 ;
"RTN","RORRP024",48,0)
 ; Return Values:
"RTN","RORRP024",49,0)
 ;
"RTN","RORRP024",50,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP024",51,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP024",52,0)
 ; details).
"RTN","RORRP024",53,0)
 ;
"RTN","RORRP024",54,0)
 ; Otherwise, the user info is returned in the RESULTS(0).
"RTN","RORRP024",55,0)
 ; 
"RTN","RORRP024",56,0)
 ; RESULTS(0)            User Info
"RTN","RORRP024",57,0)
 ;                         ^01: IEN
"RTN","RORRP024",58,0)
 ;                         ^02: Name
"RTN","RORRP024",59,0)
 ;                         ^03: Office Phone
"RTN","RORRP024",60,0)
 ;                         ^04: Nickname
"RTN","RORRP024",61,0)
 ;                         ^05: Read Timeout
"RTN","RORRP024",62,0)
 ;                         ^06: Default Division IEN
"RTN","RORRP024",63,0)
 ;                         ^07: Default Division Name
"RTN","RORRP024",64,0)
 ;
"RTN","RORRP024",65,0)
USERINFO(RESULTS,USER) ;
"RTN","RORRP024",66,0)
 N IENS,RORBUF,RORERRDL,RORMSG,TMP
"RTN","RORRP024",67,0)
 D CLEAR^RORERR("USERINFO^RORRP024",1)
"RTN","RORRP024",68,0)
 K RESULTS  S RESULTS(0)=0
"RTN","RORRP024",69,0)
 I $G(USER)'>0  S USER=+$G(DUZ)  Q:USER'>0
"RTN","RORRP024",70,0)
 ;--- Load the data
"RTN","RORRP024",71,0)
 S IENS=USER_","
"RTN","RORRP024",72,0)
 D GETS^DIQ(200,IENS,".01;.132;13",,"RORBUF","RORMSG")
"RTN","RORRP024",73,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP024",74,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,200)  K ^TMP("DILIST",$J)
"RTN","RORRP024",75,0)
 ;--- Compile the result
"RTN","RORRP024",76,0)
 S RESULTS(0)=USER
"RTN","RORRP024",77,0)
 S $P(RESULTS(0),U,2)=$G(RORBUF(200,IENS,.01))  ; Name
"RTN","RORRP024",78,0)
 S $P(RESULTS(0),U,3)=$G(RORBUF(200,IENS,.132)) ; Office Phone
"RTN","RORRP024",79,0)
 S $P(RESULTS(0),U,4)=$G(RORBUF(200,IENS,13))   ; Nick Name
"RTN","RORRP024",80,0)
 S $P(RESULTS(0),U,5)=$$DTIME^XUP(USER)         ; Read Timeout
"RTN","RORRP024",81,0)
 S TMP=$$DFLTDIV(USER)
"RTN","RORRP024",82,0)
 S $P(RESULTS(0),U,6,7)=$P(TMP,U,1,2)           ; Default Division
"RTN","RORRP024",83,0)
 Q
"RTN","RORRP024",84,0)
 ;
"RTN","RORRP024",85,0)
 ;***** RETURNS THE LIST OF VISTA USERS
"RTN","RORRP024",86,0)
 ; RPC: [ROR LIST VISTA USERS]
"RTN","RORRP024",87,0)
 ;
"RTN","RORRP024",88,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP024",89,0)
 ;               are returned to.
"RTN","RORRP024",90,0)
 ;
"RTN","RORRP024",91,0)
 ; PART          The search pattern (partial match restriction)
"RTN","RORRP024",92,0)
 ;
"RTN","RORRP024",93,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORRP024",94,0)
 ;                 B  Backwards. Traverses the index in the opposite
"RTN","RORRP024",95,0)
 ;                    direction of normal traversal.
"RTN","RORRP024",96,0)
 ;                 D  Get default division for each user
"RTN","RORRP024",97,0)
 ;                 P  Select providers only (check for the PROVIDER
"RTN","RORRP024",98,0)
 ;                    security key)
"RTN","RORRP024",99,0)
 ;
"RTN","RORRP024",100,0)
 ; [NUMBER]      Maximum number of entries to return. A value of "*"
"RTN","RORRP024",101,0)
 ;               or no value in this parameter designates all entries.
"RTN","RORRP024",102,0)
 ;
"RTN","RORRP024",103,0)
 ; [FROM]        The index entry(s) from which to begin the list.
"RTN","RORRP024",104,0)
 ;               You should use the pieces of the @RESULTS@(0) node
"RTN","RORRP024",105,0)
 ;               (starting from the second one) to continue the
"RTN","RORRP024",106,0)
 ;               listing in the subsequent procedure calls.
"RTN","RORRP024",107,0)
 ;
"RTN","RORRP024",108,0)
 ;               NOTE: The FROM value itself is not included in
"RTN","RORRP024",109,0)
 ;                     the resulting list.
"RTN","RORRP024",110,0)
 ;
"RTN","RORRP024",111,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP024",112,0)
 ;
"RTN","RORRP024",113,0)
 ; See description of the LIST^DIC for more details about the
"RTN","RORRP024",114,0)
 ; PART, NUMBER and FROM parameters.
"RTN","RORRP024",115,0)
 ;
"RTN","RORRP024",116,0)
 ; Return Values:
"RTN","RORRP024",117,0)
 ;
"RTN","RORRP024",118,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP024",119,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP024",120,0)
 ; details).
"RTN","RORRP024",121,0)
 ;
"RTN","RORRP024",122,0)
 ; Otherwise, number of VistA users and the value of the FROM
"RTN","RORRP024",123,0)
 ; parameter for the next procedure call are returned in the
"RTN","RORRP024",124,0)
 ; @RESULTS@(0) and the subsequent nodes of the global array
"RTN","RORRP024",125,0)
 ; contain the users.
"RTN","RORRP024",126,0)
 ; 
"RTN","RORRP024",127,0)
 ; @RESULTS@(0)          Result Descriptor
"RTN","RORRP024",128,0)
 ;                         ^01: Number of users
"RTN","RORRP024",129,0)
 ;                         ^02: Values that comprise the FROM
"RTN","RORRP024",130,0)
 ;                         ^nn: parameter for the subsequent call
"RTN","RORRP024",131,0)
 ;
"RTN","RORRP024",132,0)
 ; @RESULTS@(i)          User
"RTN","RORRP024",133,0)
 ;                         ^01: IEN
"RTN","RORRP024",134,0)
 ;                         ^02: Name
"RTN","RORRP024",135,0)
 ;                         ^03: Office Phone
"RTN","RORRP024",136,0)
 ;                         ^04: Nickname
"RTN","RORRP024",137,0)
 ;                         ^05: reserved
"RTN","RORRP024",138,0)
 ;                         ^06: Default Division IEN  (only if D flag)
"RTN","RORRP024",139,0)
 ;                         ^07: Default Division Name (only if D flag)
"RTN","RORRP024",140,0)
 ;
"RTN","RORRP024",141,0)
USERLIST(RESULTS,PART,FLAGS,NUMBER,FROM) ;
"RTN","RORRP024",142,0)
 N BUF,FIELDS,I,RC,RORERRDL,SCR,TMP
"RTN","RORRP024",143,0)
 D CLEAR^RORERR("USERLIST^RORRP024",1)
"RTN","RORRP024",144,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP024",145,0)
 ;--- Check the parameters
"RTN","RORRP024",146,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP024",147,0)
 . ;--- Flags
"RTN","RORRP024",148,0)
 . S FLAGS=$$UP^XLFSTR($G(FLAGS))
"RTN","RORRP024",149,0)
 . ;--- Others
"RTN","RORRP024",150,0)
 . S PART=$G(PART),FROM=$G(FROM)
"RTN","RORRP024",151,0)
 . S NUMBER=$S($G(NUMBER)>0:+NUMBER,1:"*")
"RTN","RORRP024",152,0)
 ;--- Setup the start point
"RTN","RORRP024",153,0)
 F I=1:1  S TMP=$P(FROM,U,I)  Q:TMP=""  S FROM(I)=TMP
"RTN","RORRP024",154,0)
 S FROM=$G(FROM(1))
"RTN","RORRP024",155,0)
 ;--- Compile the screen logic (be careful with naked references)
"RTN","RORRP024",156,0)
 S SCR=""
"RTN","RORRP024",157,0)
 S:FLAGS["P" SCR=SCR_"I $D(^XUSEC(""PROVIDER"",Y))"
"RTN","RORRP024",158,0)
 ;--- Query the file
"RTN","RORRP024",159,0)
 S FIELDS="@;.01;.132;13",TMP="P"_$S(FLAGS["B":"B",1:"")
"RTN","RORRP024",160,0)
 D LIST^DIC(200,,FIELDS,TMP,NUMBER,.FROM,PART,"B",SCR,,,"RORMSG")
"RTN","RORRP024",161,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP024",162,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,200)  K ^TMP("DILIST",$J)
"RTN","RORRP024",163,0)
 ;--- Add default divisions
"RTN","RORRP024",164,0)
 I FLAGS["D"  S I=0  D
"RTN","RORRP024",165,0)
 . F  S I=$O(@RESULTS@(I))  Q:I'>0  D
"RTN","RORRP024",166,0)
 . . S $P(@RESULTS@(I,0),U,6,7)=$P($$DFLTDIV(+@RESULTS@(I,0)),U,1,2)
"RTN","RORRP024",167,0)
 ;--- Success
"RTN","RORRP024",168,0)
 S TMP=$G(^TMP("DILIST",$J,0)),BUF=+$P(TMP,U)
"RTN","RORRP024",169,0)
 K ^TMP("DILIST",$J,0)
"RTN","RORRP024",170,0)
 I $P(TMP,U,3)  S I=0  D
"RTN","RORRP024",171,0)
 . F  S I=$O(FROM(I))  Q:I'>0  S TMP=FROM(I)  S:TMP'="" BUF=BUF_U_TMP
"RTN","RORRP024",172,0)
 S @RESULTS@(0)=BUF
"RTN","RORRP024",173,0)
 Q
"RTN","RORRP025")
0^63^B32323014
"RTN","RORRP025",1,0)
RORRP025 ;HCIOFO/SG - RPC: RORICR CDC LOAD ; 2/3/04 8:11am
"RTN","RORRP025",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP025",3,0)
 ;
"RTN","RORRP025",4,0)
 ; This routine uses the following IAs:
"RTN","RORRP025",5,0)
 ;
"RTN","RORRP025",6,0)
 ; #10060        Read access to the NEW PERSON file (#200)
"RTN","RORRP025",7,0)
 ;
"RTN","RORRP025",8,0)
 ;--------------------------------------------------------------------
"RTN","RORRP025",9,0)
 ; Registry: [VA ICR]
"RTN","RORRP025",10,0)
 ;--------------------------------------------------------------------
"RTN","RORRP025",11,0)
 Q
"RTN","RORRP025",12,0)
 ;
"RTN","RORRP025",13,0)
 ;***** DEMOGRAPHIC INFORMATION (III)
"RTN","RORRP025",14,0)
CDM(IENS) ;
"RTN","RORRP025",15,0)
 N BUF,RC,RORBUF,TMP
"RTN","RORRP025",16,0)
 S BUF="CDM"
"RTN","RORRP025",17,0)
 S RC=$$LOAD^RORRP026(IENS,"CDM^RORRP026",.BUF,.RORBUF)  Q:RC<0 RC
"RTN","RORRP025",18,0)
 ;--- Age at diagnosis
"RTN","RORRP025",19,0)
 S TMP=+$G(RORBUF(799.4,IENS,9.02,"I"))
"RTN","RORRP025",20,0)
 S:TMP=1 $P(BUF,U,4)=$G(RORBUF(799.4,IENS,9.03,"I"))
"RTN","RORRP025",21,0)
 S:TMP=2 $P(BUF,U,4)=$G(RORBUF(799.4,IENS,9.04,"I"))
"RTN","RORRP025",22,0)
 ;--- Country of birth
"RTN","RORRP025",23,0)
 S TMP=+$G(RORBUF(799.4,IENS,9.07,"I"))
"RTN","RORRP025",24,0)
 S:TMP=7 $P(BUF,U,8)=$G(RORBUF(799.4,IENS,9.08,"I"))
"RTN","RORRP025",25,0)
 S:TMP=8 $P(BUF,U,8)=$G(RORBUF(799.4,IENS,9.09,"I"))
"RTN","RORRP025",26,0)
 ;--- Store the data into the result buffer
"RTN","RORRP025",27,0)
 S RORPTR=RORPTR+1,RORDST(RORPTR)=BUF
"RTN","RORRP025",28,0)
 Q 0
"RTN","RORRP025",29,0)
 ;
"RTN","RORRP025",30,0)
 ;***** COMMENTS (X)
"RTN","RORRP025",31,0)
CMT(IENS) ;
"RTN","RORRP025",32,0)
 N BUF,I,RC,RORBUF,RORMSG,TMP
"RTN","RORRP025",33,0)
 S TMP=$$GET1^DIQ(799.4,IENS,25,,"RORBUF","RORMSG")
"RTN","RORRP025",34,0)
 I $G(DIERR)  D  Q RC
"RTN","RORRP025",35,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,799.4,IENS)
"RTN","RORRP025",36,0)
 ;--- Store the data into the result buffer
"RTN","RORRP025",37,0)
 S I=0
"RTN","RORRP025",38,0)
 F  S I=$O(RORBUF(I))  Q:I'>0  D
"RTN","RORRP025",39,0)
 . S RORPTR=RORPTR+1,RORDST(RORPTR)="CMT"_U_I_U_RORBUF(I)
"RTN","RORRP025",40,0)
 Q 0
"RTN","RORRP025",41,0)
 ;
"RTN","RORRP025",42,0)
 ;***** CLINICAL STATUS (VIII)
"RTN","RORRP025",43,0)
CS(IENS) ;
"RTN","RORRP025",44,0)
 N BUF,I,IENS1,RC,RORBUF,RORMSG,TMP
"RTN","RORRP025",45,0)
 S BUF="CS"
"RTN","RORRP025",46,0)
 S RC=$$LOAD^RORRP026(IENS,"CS^RORRP026",.BUF)  Q:RC<0 RC
"RTN","RORRP025",47,0)
 ;--- Store the data into the result buffer
"RTN","RORRP025",48,0)
 S RORPTR=RORPTR+1,RORDST(RORPTR)=BUF
"RTN","RORRP025",49,0)
 ;--- Load the AIDS Indicator diseases
"RTN","RORRP025",50,0)
 S IENS1=","_IENS,TMP="@;.01I;.02I;.03I"
"RTN","RORRP025",51,0)
 D LIST^DIC(799.41,IENS1,TMP,,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORRP025",52,0)
 I $G(DIERR)  D  Q RC
"RTN","RORRP025",53,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,799.41,IENS1)
"RTN","RORRP025",54,0)
 ;--- Process the list
"RTN","RORRP025",55,0)
 S I=0
"RTN","RORRP025",56,0)
 F  S I=$O(RORBUF("DILIST","ID",I))  Q:I'>0  D
"RTN","RORRP025",57,0)
 . S BUF="AID"_U_$G(RORBUF("DILIST","ID",I,.01))
"RTN","RORRP025",58,0)
 . S TMP=$G(RORBUF("DILIST","ID",I,.02))  Q:TMP'>0
"RTN","RORRP025",59,0)
 . S $P(BUF,U,3)=TMP
"RTN","RORRP025",60,0)
 . S $P(BUF,U,4)=$$DATE^RORRP026($G(RORBUF("DILIST","ID",I,.03)))
"RTN","RORRP025",61,0)
 . ;--- Store the data into the result buffer
"RTN","RORRP025",62,0)
 . S RORPTR=RORPTR+1,RORDST(RORPTR)=BUF
"RTN","RORRP025",63,0)
 Q 0
"RTN","RORRP025",64,0)
 ;
"RTN","RORRP025",65,0)
 ;***** PROCESSES THE ERROR(S) AND UNLOCKS THE RECORDS
"RTN","RORRP025",66,0)
ERROR(RESULTS,RC) ;
"RTN","RORRP025",67,0)
 D RPCSTK^RORERR(.RESULTS,RC)
"RTN","RORRP025",68,0)
 D UNLOCK^RORLOCK(.RORLOCK)
"RTN","RORRP025",69,0)
 Q
"RTN","RORRP025",70,0)
 ;
"RTN","RORRP025",71,0)
 ;***** FACILITY OF DIAGNOSIS (IV)
"RTN","RORRP025",72,0)
FD(IENS) ;
"RTN","RORRP025",73,0)
 N BUF,RC,RORBUF,TMP
"RTN","RORRP025",74,0)
 S BUF="FD"
"RTN","RORRP025",75,0)
 S RC=$$LOAD^RORRP026(IENS,"FD^RORRP026",.BUF)  Q:RC<0 RC
"RTN","RORRP025",76,0)
 ;--- Store the data into the result buffer
"RTN","RORRP025",77,0)
 S RORPTR=RORPTR+1,RORDST(RORPTR)=BUF
"RTN","RORRP025",78,0)
 Q 0
"RTN","RORRP025",79,0)
 ;
"RTN","RORRP025",80,0)
 ;***** FORM HEADERS
"RTN","RORRP025",81,0)
HDR(IENS) ;
"RTN","RORRP025",82,0)
 N BUF,IENS200,RC,RORBUF,RORMSG,TMP
"RTN","RORRP025",83,0)
 S BUF="HDR"
"RTN","RORRP025",84,0)
 S RC=$$LOAD^RORRP026(IENS,"HDR^RORRP026",.BUF)  Q:RC<0 RC
"RTN","RORRP025",85,0)
 ;--- Date when the CDC form was completed
"RTN","RORRP025",86,0)
 S:$P(BUF,U,3)="" $P(BUF,U,3)=$$DT^XLFDT
"RTN","RORRP025",87,0)
 ;--- Person who is completing the form
"RTN","RORRP025",88,0)
 S IENS200=DUZ_","
"RTN","RORRP025",89,0)
 D GETS^DIQ(200,IENS200,".01;.132",,"RORBUF","RORMSG")
"RTN","RORRP025",90,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,200,IENS200)
"RTN","RORRP025",91,0)
 S $P(BUF,U,4)=DUZ
"RTN","RORRP025",92,0)
 S $P(BUF,U,5)=$G(RORBUF(200,IENS200,.01))
"RTN","RORRP025",93,0)
 S $P(BUF,U,6)=$G(RORBUF(200,IENS200,.132))
"RTN","RORRP025",94,0)
 ;--- Medical record number (it is the SSN now)
"RTN","RORRP025",95,0)
 S $P(BUF,U,7)=$P($G(RORDST(1)),U,6)
"RTN","RORRP025",96,0)
 ;--- Store the data into the result buffer
"RTN","RORRP025",97,0)
 S RORPTR=RORPTR+1,RORDST(RORPTR)=BUF
"RTN","RORRP025",98,0)
 Q 0
"RTN","RORRP025",99,0)
 ;
"RTN","RORRP025",100,0)
 ;***** LABORATORY DATA (VI)
"RTN","RORRP025",101,0)
LD(IENS) ;
"RTN","RORRP025",102,0)
 N BUF,FLD,RC,RORBUF,TMP
"RTN","RORRP025",103,0)
 S BUF="LD1"
"RTN","RORRP025",104,0)
 S RC=$$LOAD^RORRP026(IENS,"LD1^RORRP026",.BUF,.RORBUF)  Q:RC<0 RC
"RTN","RORRP025",105,0)
 ;--- Positive HIV detection test
"RTN","RORRP025",106,0)
 S FLD=$$PHIVFLD^RORRP026($P(BUF,U,12))
"RTN","RORRP025",107,0)
 S:FLD $P(BUF,U,13)=$$DATE^RORRP026($G(RORBUF(799.4,IENS,FLD,"I")))
"RTN","RORRP025",108,0)
 ;--- Store the data into the result buffer
"RTN","RORRP025",109,0)
 S RORPTR=RORPTR+1,RORDST(RORPTR)=BUF
"RTN","RORRP025",110,0)
 ;--- The second segment
"RTN","RORRP025",111,0)
 S BUF="LD2"
"RTN","RORRP025",112,0)
 S RC=$$LOAD^RORRP026(IENS,"LD2^RORRP026",.BUF)  Q:RC<0 RC
"RTN","RORRP025",113,0)
 ;--- Store the data into the result buffer
"RTN","RORRP025",114,0)
 S RORPTR=RORPTR+1,RORDST(RORPTR)=BUF
"RTN","RORRP025",115,0)
 Q 0
"RTN","RORRP025",116,0)
 ;
"RTN","RORRP025",117,0)
 ;***** LOADS THE ICR CDC DATA
"RTN","RORRP025",118,0)
 ; RPC: [RORICR CDC LOAD]
"RTN","RORRP025",119,0)
 ;
"RTN","RORRP025",120,0)
 ; .RORDST       Reference to a local variable where the results
"RTN","RORRP025",121,0)
 ;               are returned to.
"RTN","RORRP025",122,0)
 ;
"RTN","RORRP025",123,0)
 ; REGIEN        Registry IEN
"RTN","RORRP025",124,0)
 ;
"RTN","RORRP025",125,0)
 ; PATIEN        IEN of the registry patient (DFN)
"RTN","RORRP025",126,0)
 ;
"RTN","RORRP025",127,0)
 ; [LOCK]        Lock the ICR record before loading the data and
"RTN","RORRP025",128,0)
 ;               leave it locked.
"RTN","RORRP025",129,0)
 ;
"RTN","RORRP025",130,0)
 ; Return Values:
"RTN","RORRP025",131,0)
 ;
"RTN","RORRP025",132,0)
 ; A negative value of the first "^"-piece of the RORDST(0)
"RTN","RORRP025",133,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP025",134,0)
 ; details).
"RTN","RORRP025",135,0)
 ;
"RTN","RORRP025",136,0)
 ; If locking was requested (see the LOCK parameter) and the record
"RTN","RORRP025",137,0)
 ; could not be locked then the first "^"-piece of the RORDST(0)
"RTN","RORRP025",138,0)
 ; would be greater than 0. The RORDST(0) would contain the lock
"RTN","RORRP025",139,0)
 ; descriptor and subsequent nodes of the global array would contain
"RTN","RORRP025",140,0)
 ; the data (see below). The lock descriptor contains information
"RTN","RORRP025",141,0)
 ; about the propcess, which owns the most recent lock of the record.
"RTN","RORRP025",142,0)
 ;
"RTN","RORRP025",143,0)
 ; RORDST(0)             Lock Descriptor
"RTN","RORRP025",144,0)
 ;                         ^01: Date/Time (FileMan)
"RTN","RORRP025",145,0)
 ;                         ^02: User/Process name
"RTN","RORRP025",146,0)
 ;                         ^03: User IEN (DUZ)
"RTN","RORRP025",147,0)
 ;                         ^04: $JOB
"RTN","RORRP025",148,0)
 ;                         ^05: Task number
"RTN","RORRP025",149,0)
 ;
"RTN","RORRP025",150,0)
 ; THE DATA ARE LOADED ONLY FOR VIEWING PURPOSES (READ-ONLY)!
"RTN","RORRP025",151,0)
 ;
"RTN","RORRP025",152,0)
 ; Otherwise, zero is returned in the RORDST(0) and the subsequent
"RTN","RORRP025",153,0)
 ; nodes of the array contain the data.
"RTN","RORRP025",154,0)
 ; 
"RTN","RORRP025",155,0)
 ; RORDST(0)             0
"RTN","RORRP025",156,0)
 ;
"RTN","RORRP025",157,0)
 ; RORDST(i)             Data Item
"RTN","RORRP025",158,0)
 ;                         ^01: Type
"RTN","RORRP025",159,0)
 ;                         ^02: Sequential Number or Item Code
"RTN","RORRP025",160,0)
 ;                         ^03: Value
"RTN","RORRP025",161,0)
 ;                         ^04: ...
"RTN","RORRP025",162,0)
 ;
"RTN","RORRP025",163,0)
 ;                       Item Types:
"RTN","RORRP025",164,0)
 ;                         DEM  Demographic Information
"RTN","RORRP025",165,0)
 ;                         ADR  Patient's Address
"RTN","RORRP025",166,0)
 ;                         RCE  Race Information
"RTN","RORRP025",167,0)
 ;                         ETN  Ethnicity Information
"RTN","RORRP025",168,0)
 ;                         HDR  Headers
"RTN","RORRP025",169,0)
 ;                         CDM  CDC Demographics
"RTN","RORRP025",170,0)
 ;                         FD   Facility of Diagnosis
"RTN","RORRP025",171,0)
 ;                         PH   Patient History
"RTN","RORRP025",172,0)
 ;                         LD1  Laboratory Data
"RTN","RORRP025",173,0)
 ;                         LD2  Laboratory Data
"RTN","RORRP025",174,0)
 ;                         CS   Clinical Status
"RTN","RORRP025",175,0)
 ;                         AID  AIDS Indicator Disease
"RTN","RORRP025",176,0)
 ;                         TS1  Treatment/Services
"RTN","RORRP025",177,0)
 ;                         TS2  Treatment/Services
"RTN","RORRP025",178,0)
 ;                         CMT  Comments
"RTN","RORRP025",179,0)
 ;
"RTN","RORRP025",180,0)
 ; See the CDC FIELD TABLE section (CDCFLDS^RORRP026) and the
"RTN","RORRP025",181,0)
 ; description of the RORICR CDC LOAD remote procedure for details.
"RTN","RORRP025",182,0)
 ;
"RTN","RORRP025",183,0)
LOADCDC(RORDST,REGIEN,PATIEN,LOCK) ;
"RTN","RORRP025",184,0)
 N BUF,IEN,RC,RDONLY,RORERRDL,RORLOCK,RORPTR
"RTN","RORRP025",185,0)
 D CLEAR^RORERR("LOADCDC^RORRP025",1)
"RTN","RORRP025",186,0)
 K RORDST  S (RDONLY,RORDST(0))=0
"RTN","RORRP025",187,0)
 ;--- Check the parameters
"RTN","RORRP025",188,0)
 S RC=0  D  I RC<0  D ERROR(.RORDST,RC)  Q
"RTN","RORRP025",189,0)
 . ;--- Registry IEN
"RTN","RORRP025",190,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP025",191,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP025",192,0)
 . S REGIEN=+REGIEN
"RTN","RORRP025",193,0)
 . ;--- Patient IEN
"RTN","RORRP025",194,0)
 . I $G(PATIEN)'>0  D  Q
"RTN","RORRP025",195,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"PATIEN",$G(PATIEN))
"RTN","RORRP025",196,0)
 . S PATIEN=+PATIEN
"RTN","RORRP025",197,0)
 ;
"RTN","RORRP025",198,0)
 ;--- Load the patient's demographic data
"RTN","RORRP025",199,0)
 D GETPTDAT^RORRP021(.RORDST,PATIEN,"AER")
"RTN","RORRP025",200,0)
 Q:$G(RORDST(0))<0
"RTN","RORRP025",201,0)
 S RORPTR=+$O(RORDST(""),-1)
"RTN","RORRP025",202,0)
 ;
"RTN","RORRP025",203,0)
 ;--- Get the IEN of the registry record
"RTN","RORRP025",204,0)
 S IEN=$$PRRIEN^RORUTL01(PATIEN,REGIEN)  Q:IEN'>0
"RTN","RORRP025",205,0)
 S IENS=IEN_","
"RTN","RORRP025",206,0)
 ;
"RTN","RORRP025",207,0)
 ;--- Lock the record
"RTN","RORRP025",208,0)
 I $G(LOCK)  D  I RDONLY<0  D ERROR(.RORDST,+RDONLY)  Q
"RTN","RORRP025",209,0)
 . S RORLOCK(799.4,IENS)=""
"RTN","RORRP025",210,0)
 . S RDONLY=$$LOCK^RORLOCK(799.4,IENS)
"RTN","RORRP025",211,0)
 ;
"RTN","RORRP025",212,0)
 ;--- Create the data segments
"RTN","RORRP025",213,0)
 S RC=0  D  I RC<0  D ERROR(.RORDST,RC)  Q
"RTN","RORRP025",214,0)
 . S RC=$$HDR(IENS)  Q:RC<0
"RTN","RORRP025",215,0)
 . S RC=$$CDM(IENS)  Q:RC<0
"RTN","RORRP025",216,0)
 . S RC=$$FD(IENS)   Q:RC<0
"RTN","RORRP025",217,0)
 . S RC=$$PH(IENS)   Q:RC<0
"RTN","RORRP025",218,0)
 . S RC=$$LD(IENS)   Q:RC<0
"RTN","RORRP025",219,0)
 . S RC=$$CS(IENS)   Q:RC<0
"RTN","RORRP025",220,0)
 . S RC=$$TS(IENS)   Q:RC<0
"RTN","RORRP025",221,0)
 . S RC=$$CMT(IENS)  Q:RC<0
"RTN","RORRP025",222,0)
 ;---
"RTN","RORRP025",223,0)
 S RORDST(0)=RDONLY
"RTN","RORRP025",224,0)
 Q
"RTN","RORRP025",225,0)
 ;
"RTN","RORRP025",226,0)
 ;***** PATIENT HISTORY (V)
"RTN","RORRP025",227,0)
PH(IENS) ;
"RTN","RORRP025",228,0)
 N BUF,RC,RORBUF,TMP
"RTN","RORRP025",229,0)
 S BUF="PH"
"RTN","RORRP025",230,0)
 S RC=$$LOAD^RORRP026(IENS,"PH^RORRP026",.BUF)  Q:RC<0 RC
"RTN","RORRP025",231,0)
 ;--- Store the data into the result buffer
"RTN","RORRP025",232,0)
 S RORPTR=RORPTR+1,RORDST(RORPTR)=BUF
"RTN","RORRP025",233,0)
 Q 0
"RTN","RORRP025",234,0)
 ;
"RTN","RORRP025",235,0)
 ;***** TREATMENT/SERVICES REFERRALS (IX)
"RTN","RORRP025",236,0)
TS(IENS) ;
"RTN","RORRP025",237,0)
 N BUF,RC,RORBUF,TMP
"RTN","RORRP025",238,0)
 S BUF="TS1"
"RTN","RORRP025",239,0)
 S RC=$$LOAD^RORRP026(IENS,"TS1^RORRP026",.BUF)  Q:RC<0 RC
"RTN","RORRP025",240,0)
 ;--- Store the data into the result buffer
"RTN","RORRP025",241,0)
 S RORPTR=RORPTR+1,RORDST(RORPTR)=BUF
"RTN","RORRP025",242,0)
 ;--- The second segment
"RTN","RORRP025",243,0)
 S BUF="TS2"
"RTN","RORRP025",244,0)
 S RC=$$LOAD^RORRP026(IENS,"TS2^RORRP026",.BUF)  Q:RC<0 RC
"RTN","RORRP025",245,0)
 ;--- Store the data into the result buffer
"RTN","RORRP025",246,0)
 S RORPTR=RORPTR+1,RORDST(RORPTR)=BUF
"RTN","RORRP025",247,0)
 Q 0
"RTN","RORRP026")
0^65^B66003716
"RTN","RORRP026",1,0)
RORRP026 ;HCIOFO/SG - RPC: CDC UTILITIES ; 2/3/04 8:04am
"RTN","RORRP026",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP026",3,0)
 ;
"RTN","RORRP026",4,0)
 ;--------------------------------------------------------------------
"RTN","RORRP026",5,0)
 ; Registry: [VA ICR]
"RTN","RORRP026",6,0)
 ;--------------------------------------------------------------------
"RTN","RORRP026",7,0)
 Q
"RTN","RORRP026",8,0)
 ;
"RTN","RORRP026",9,0)
 ;***** POPULATES THE FDA WITH THE CDC DATA
"RTN","RORRP026",10,0)
 ;
"RTN","RORRP026",11,0)
 ; IENS          IENS of the record in the ROR ICR STUDY file
"RTN","RORRP026",12,0)
 ;
"RTN","RORRP026",13,0)
 ; TBLREF        Reference to a field table in the source code
"RTN","RORRP026",14,0)
 ;
"RTN","RORRP026",15,0)
 ; SRCBUF        Source data segment
"RTN","RORRP026",16,0)
 ;
"RTN","RORRP026",17,0)
 ; .FDA          Reference to a local variable where the FDA
"RTN","RORRP026",18,0)
 ;               nodes are created
"RTN","RORRP026",19,0)
 ;
"RTN","RORRP026",20,0)
 ; [.CACHE]      Reference to a local variable where the field
"RTN","RORRP026",21,0)
 ;               lists are cached.
"RTN","RORRP026",22,0)
 ;
"RTN","RORRP026",23,0)
 ; Return Values:
"RTN","RORRP026",24,0)
 ;       <0  Error code
"RTN","RORRP026",25,0)
 ;        0  Ok
"RTN","RORRP026",26,0)
 ;
"RTN","RORRP026",27,0)
CDCFDA(IENS,TBLREF,SRCBUF,RORFDA,CACHE) ;
"RTN","RORRP026",28,0)
 N BUF,FLD,I,POS,RC,RESULT,RORMSG,TGET,TMP,VAL
"RTN","RORRP026",29,0)
 S RC=0
"RTN","RORRP026",30,0)
 ;--- Prepare the fields (if they are not in the cache already)
"RTN","RORRP026",31,0)
 I $D(CACHE("CDCFLDS",TBLREF))<10  D  Q:RC<0 RC
"RTN","RORRP026",32,0)
 . S TGET="S BUF=$T("_$P(TBLREF,"^")_"+I^"_$P(TBLREF,"^",2)_")"
"RTN","RORRP026",33,0)
 . F I=1:1  X TGET  S BUF=$P(BUF,";;",2,999)  Q:BUF=""  D
"RTN","RORRP026",34,0)
 . . S FLD=$TR($P(BUF,U,2)," ")  Q:FLD'>0
"RTN","RORRP026",35,0)
 . . S TMP=+$TR($P(BUF,U)," ")
"RTN","RORRP026",36,0)
 . . I TMP'>0  S CACHE("CDCFLDS",TBLREF,+FLD)=""  Q
"RTN","RORRP026",37,0)
 . . S:FLD["D" TMP=TMP_"D" ; MM/YY field
"RTN","RORRP026",38,0)
 . . S:FLD["R" TMP=TMP_"R" ; Read-only field
"RTN","RORRP026",39,0)
 . . S CACHE("CDCFLDS",TBLREF,+FLD,$S(FLD["E":"E",1:"I"))=TMP
"RTN","RORRP026",40,0)
 ;--- Store the data into the FDA
"RTN","RORRP026",41,0)
 S FLD="",RC=0
"RTN","RORRP026",42,0)
 F  S FLD=$O(CACHE("CDCFLDS",TBLREF,FLD))  Q:FLD=""  D  Q:RC
"RTN","RORRP026",43,0)
 . S POS=$G(CACHE("CDCFLDS",TBLREF,FLD,"I"))
"RTN","RORRP026",44,0)
 . I POS'>0  S POS=$G(CACHE("CDCFLDS",TBLREF,FLD,"E"))  Q:POS'>0
"RTN","RORRP026",45,0)
 . Q:POS["R"  ; Skip read-only fields
"RTN","RORRP026",46,0)
 . S VAL=$P(SRCBUF,U,+POS)
"RTN","RORRP026",47,0)
 . I VAL=""  S RORFDA(799.4,IENS,FLD)=""  Q
"RTN","RORRP026",48,0)
 . ;--- Process the 'YY/MM' date field
"RTN","RORRP026",49,0)
 . I POS["D"  D  Q
"RTN","RORRP026",50,0)
 . . S TMP=$$DATE1(VAL)
"RTN","RORRP026",51,0)
 . . I TMP<0  S RC=(+POS)_U_$P(SRCBUF,U)  Q
"RTN","RORRP026",52,0)
 . . S RORFDA(799.4,IENS,FLD)=TMP
"RTN","RORRP026",53,0)
 . ;--- Precede the internal pointer value with the "`"
"RTN","RORRP026",54,0)
 . I +VAL=VAL  S:$$GET1^DID(799.4,FLD,,"TYPE")="POINTER" VAL="`"_VAL
"RTN","RORRP026",55,0)
 . ;--- Validate the value and store it into the FDA
"RTN","RORRP026",56,0)
 . D VAL^DIE(799.4,IENS,FLD,"FU",VAL,.RESULT,"RORFDA","RORMSG")
"RTN","RORRP026",57,0)
 . S:RESULT="^" RC=(+POS)_U_$P(SRCBUF,U)
"RTN","RORRP026",58,0)
 Q RC
"RTN","RORRP026",59,0)
 ;
"RTN","RORRP026",60,0)
 ;***** FORMATS THE FILEMAN DATE AS 'MM/YY'
"RTN","RORRP026",61,0)
DATE(DATE) ;
"RTN","RORRP026",62,0)
 Q $S(DATE>0:$TR($P($$FMTE^XLFDT(DATE,"3DF"),"/",2,3)," ","0"),1:"")
"RTN","RORRP026",63,0)
 ;
"RTN","RORRP026",64,0)
 ;***** CONVERTS THE 'MM/YY' INTO THE FILEMAN DATE
"RTN","RORRP026",65,0)
DATE1(MMYY) ;
"RTN","RORRP026",66,0)
 Q:$G(MMYY)="" ""
"RTN","RORRP026",67,0)
 N DATE
"RTN","RORRP026",68,0)
 D DT^DILF("EP",$P(MMYY,"/",2),.DATE)
"RTN","RORRP026",69,0)
 I $G(DATE)>0  D  D DT^DILF("P",MMYY,.DATE)
"RTN","RORRP026",70,0)
 . S $P(MMYY,"/",2)=$G(DATE(0))
"RTN","RORRP026",71,0)
 Q $G(DATE,-1)
"RTN","RORRP026",72,0)
 ;
"RTN","RORRP026",73,0)
 ;***** LOADS THE DATA FROM THE 'ROR ICR STUDY' FILE
"RTN","RORRP026",74,0)
 ;
"RTN","RORRP026",75,0)
 ; IENS          IENS of the record in the ROR ICR STUDY file
"RTN","RORRP026",76,0)
 ;
"RTN","RORRP026",77,0)
 ; TBLREF        Reference to a field table in the source code
"RTN","RORRP026",78,0)
 ;
"RTN","RORRP026",79,0)
 ; DSTBUF        Reference to a local variable where the data
"RTN","RORRP026",80,0)
 ;               is returned to
"RTN","RORRP026",81,0)
 ;
"RTN","RORRP026",82,0)
 ; [.RORBUF]     Reference to a local variable where the source
"RTN","RORRP026",83,0)
 ;               field values are returned to (by GETS^DIQ)
"RTN","RORRP026",84,0)
 ;
"RTN","RORRP026",85,0)
 ; [.CACHE]      Reference to a local variable where the field
"RTN","RORRP026",86,0)
 ;               lists are cached.
"RTN","RORRP026",87,0)
 ;
"RTN","RORRP026",88,0)
 ; Return Values:
"RTN","RORRP026",89,0)
 ;       <0  Error code
"RTN","RORRP026",90,0)
 ;        0  Ok
"RTN","RORRP026",91,0)
 ;
"RTN","RORRP026",92,0)
LOAD(IENS,TBLREF,DSTBUF,RORBUF,CACHE) ;
"RTN","RORRP026",93,0)
 N BUF,FLD,I,RC,RORMSG,TGET,TMP
"RTN","RORRP026",94,0)
 S RC=0
"RTN","RORRP026",95,0)
 ;--- Prepare the fields (if they are not in the cache already)
"RTN","RORRP026",96,0)
 I $D(CACHE("CDCFLDS",TBLREF))<10  D  Q:RC<0 RC
"RTN","RORRP026",97,0)
 . S TGET="S BUF=$T("_$P(TBLREF,"^")_"+I^"_$P(TBLREF,"^",2)_")"
"RTN","RORRP026",98,0)
 . F I=1:1  X TGET  S BUF=$P(BUF,";;",2,999)  Q:BUF=""  D
"RTN","RORRP026",99,0)
 . . S FLD=$TR($P(BUF,U,2)," ")  Q:FLD'>0
"RTN","RORRP026",100,0)
 . . S TMP=+$TR($P(BUF,U)," ")
"RTN","RORRP026",101,0)
 . . I TMP'>0  S CACHE("CDCFLDS",TBLREF,+FLD)=""  Q
"RTN","RORRP026",102,0)
 . . S:FLD["D" TMP=TMP_"D"
"RTN","RORRP026",103,0)
 . . S CACHE("CDCFLDS",TBLREF,+FLD,$S(FLD["E":"E",1:"I"))=TMP
"RTN","RORRP026",104,0)
 . ;--- Create the list of fields for the GETS^DIQ
"RTN","RORRP026",105,0)
 . S (CACHE("CDCFLDS",TBLREF),FLD)=""
"RTN","RORRP026",106,0)
 . F  S FLD=$O(CACHE("CDCFLDS",TBLREF,FLD))  Q:FLD=""  D
"RTN","RORRP026",107,0)
 . . S CACHE("CDCFLDS",TBLREF)=CACHE("CDCFLDS",TBLREF)_FLD_";"
"RTN","RORRP026",108,0)
 ;--- Load the data from the file
"RTN","RORRP026",109,0)
 D GETS^DIQ(799.4,IENS,CACHE("CDCFLDS",TBLREF),"EI","RORBUF","RORMSG")
"RTN","RORRP026",110,0)
 I $G(DIERR)  D  Q RC
"RTN","RORRP026",111,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,799.4,IENS)
"RTN","RORRP026",112,0)
 ;--- Store the data into the output buffer
"RTN","RORRP026",113,0)
 S FLD=""
"RTN","RORRP026",114,0)
 F  S FLD=$O(CACHE("CDCFLDS",TBLREF,FLD))  Q:FLD=""  D
"RTN","RORRP026",115,0)
 . S I=""
"RTN","RORRP026",116,0)
 . F  S I=$O(CACHE("CDCFLDS",TBLREF,FLD,I))  Q:I=""  D
"RTN","RORRP026",117,0)
 . . S TMP=CACHE("CDCFLDS",TBLREF,FLD,I)
"RTN","RORRP026",118,0)
 . . I '(TMP["D")  S $P(DSTBUF,U,+TMP)=$G(RORBUF(799.4,IENS,FLD,I))  Q
"RTN","RORRP026",119,0)
 . . S $P(DSTBUF,U,+TMP)=$$DATE($G(RORBUF(799.4,IENS,FLD,"I")))
"RTN","RORRP026",120,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORRP026",121,0)
 ;
"RTN","RORRP026",122,0)
 ;***** RETURNS DATE FIELD NUMBER FOR THE POSITIVE HIV DETECTION TEST
"RTN","RORRP026",123,0)
PHIVFLD(TYPE) ;
"RTN","RORRP026",124,0)
 Q $S(TYPE=1:18.01,TYPE=2:18.02,TYPE=3:18.03,1:0)
"RTN","RORRP026",125,0)
 Q
"RTN","RORRP026",126,0)
 ;
"RTN","RORRP026",127,0)
CDCFLDS ;***** CDC FIELD TABLE
"RTN","RORRP026",128,0)
HDR ;
"RTN","RORRP026",129,0)
 ;;  3 ^  9.01I  ^ DATE CDC FORM COMPLETED
"RTN","RORRP026",130,0)
 ;;  4 ^         ^ CDC FORM COMPLETED BY (DUZ)
"RTN","RORRP026",131,0)
 ;;  5 ^         ^ CDC FORM COMPLETED BY (Name)
"RTN","RORRP026",132,0)
 ;;  6 ^         ^ Phone number of the person completed the form
"RTN","RORRP026",133,0)
CDM ;
"RTN","RORRP026",134,0)
 ;;  3 ^  9.02I  ^ STATUS AT REPORT
"RTN","RORRP026",135,0)
 ;;    ^  9.03I  ^ AGE AT HIV DIAGNOSIS
"RTN","RORRP026",136,0)
 ;;    ^  9.04I  ^ AGE AT AIDS DIAGNOSIS
"RTN","RORRP026",137,0)
 ;;  5 ^  9.9ER  ^ PATIENT STATUS
"RTN","RORRP026",138,0)
 ;;  6 ^  9.06I  ^ STATE/TERRITORY OF DEATH
"RTN","RORRP026",139,0)
 ;;  7 ^  9.07I  ^ COUNTRY OF BIRTH
"RTN","RORRP026",140,0)
 ;;    ^  9.08I  ^ DEPENDENCY OR POSSESSION NAME
"RTN","RORRP026",141,0)
 ;;    ^  9.09I  ^ OTHER COUNTRY DESCRIPTION
"RTN","RORRP026",142,0)
 ;;  9 ^  9.1I   ^ ONSET OF ILLNESS/AIDS- CITY
"RTN","RORRP026",143,0)
 ;; 10 ^  9.11I  ^ ONSET OF ILLNESS/AIDS- COUNTY
"RTN","RORRP026",144,0)
 ;; 11 ^  9.12I  ^ ONSET OF ILLNESS/AIDS- STATE (IEN)
"RTN","RORRP026",145,0)
 ;; 12 ^  9.12E  ^ ONSET OF ILLNESS/AIDS- STATE (Name)
"RTN","RORRP026",146,0)
 ;; 13 ^  9.13I  ^ ONSET OF ILLNESS/AIDS- COUNTRY
"RTN","RORRP026",147,0)
 ;; 14 ^  9.14I  ^ ONSET OF ILLNESS/AIDS- ZIP
"RTN","RORRP026",148,0)
FD ;
"RTN","RORRP026",149,0)
 ;;  3 ^ 12.01I  ^ AIDS DX - HOSPITAL
"RTN","RORRP026",150,0)
 ;;  4 ^ 12.02I  ^ AIDS DX - CITY
"RTN","RORRP026",151,0)
 ;;  5 ^ 12.03I  ^ AIDS DX - STATE (IEN)
"RTN","RORRP026",152,0)
 ;;  6 ^ 12.03E  ^ AIDS DX - STATE (Name)
"RTN","RORRP026",153,0)
 ;;  7 ^ 12.04I  ^ AIDS DX - COUNTRY
"RTN","RORRP026",154,0)
 ;;  8 ^ 12.05I  ^ AIDS DX - FACILITY SETTING
"RTN","RORRP026",155,0)
 ;;  9 ^ 12.06I  ^ AIDS DX - FACILITY TYPE
"RTN","RORRP026",156,0)
 ;; 10 ^ 12.07I  ^ AIDS DX - OTHER FACILITY TYPE
"RTN","RORRP026",157,0)
 ;
"RTN","RORRP026",158,0)
PH ;
"RTN","RORRP026",159,0)
 ;;  3 ^ 14.01I  ^ SEX RELATIONS W/MALE PARTNER
"RTN","RORRP026",160,0)
 ;;  4 ^ 14.02I  ^ SEX RELATIONS W/FEMALE PARTNER
"RTN","RORRP026",161,0)
 ;;  5 ^ 14.03I  ^ IV DRUGS AFTER 77 AND PRE HIV
"RTN","RORRP026",162,0)
 ;;  6 ^ 14.04I  ^ REC'D CLOTTING FACTORS
"RTN","RORRP026",163,0)
 ;;  7 ^ 14.05I  ^ TYPE OF HEMOPHILIA
"RTN","RORRP026",164,0)
 ;;  8 ^ 14.06I  ^ OTHER HEMOPHILIA DESCRIPTION
"RTN","RORRP026",165,0)
 ;;  9 ^ 14.07I  ^ SR WITH IV DRUG USER
"RTN","RORRP026",166,0)
 ;; 10 ^ 14.08I  ^ SR WITH BISEXUAL MAN
"RTN","RORRP026",167,0)
 ;; 11 ^ 14.09I  ^ SR W HEMOPHILIA/COAG DISORDER
"RTN","RORRP026",168,0)
 ;; 12 ^ 14.1I   ^ SR W TRANS RECIPIENT WITH AIDS
"RTN","RORRP026",169,0)
 ;; 13 ^ 14.11I  ^ TRANSPLANT RECIP-DOCUMNTD HIV
"RTN","RORRP026",170,0)
 ;; 14 ^ 14.12I  ^ SR W AIDS/HIV INFECTION
"RTN","RORRP026",171,0)
 ;; 15 ^ 14.13I  ^ TRANS AFTER 77 AND BEFORE HIV
"RTN","RORRP026",172,0)
 ;; 16 ^ 14.14ID ^ DATE OF FIRST TRANSFUSION
"RTN","RORRP026",173,0)
 ;; 17 ^ 14.15ID ^ DATE OF LAST TRANSFUSION
"RTN","RORRP026",174,0)
 ;; 18 ^ 14.16I  ^ TRANSPLANT OR ARTIF INSEMIN
"RTN","RORRP026",175,0)
 ;; 19 ^ 14.17I  ^ WORK IN HEALTH CARE OR LAB
"RTN","RORRP026",176,0)
 ;; 20 ^ 14.18I  ^ OCCUPATION
"RTN","RORRP026",177,0)
LD1 ;
"RTN","RORRP026",178,0)
 ;;  3 ^ 16.01I  ^ HIV-1 EIA
"RTN","RORRP026",179,0)
 ;;  4 ^ 16.02ID ^ HIV-1 EIA DATE
"RTN","RORRP026",180,0)
 ;;  5 ^ 16.03I  ^ HIV-1/HIV-2 EIA
"RTN","RORRP026",181,0)
 ;;  6 ^ 16.04ID ^ HIV-1/HIV-2 EIA DATE
"RTN","RORRP026",182,0)
 ;;  7 ^ 16.05I  ^ HIV-1 WESTERN BLOT/IFA
"RTN","RORRP026",183,0)
 ;;  8 ^ 16.06ID ^ HIV-1 WESTERN BLOT/IFA DATE
"RTN","RORRP026",184,0)
 ;;  9 ^ 16.07I  ^ OTHER HIV ANTIBODY TEST
"RTN","RORRP026",185,0)
 ;; 10 ^ 16.08ID ^ OTHER HIV ANTIBODY TEST DATE
"RTN","RORRP026",186,0)
 ;; 11 ^ 16.09I  ^ OTHER HIV ANTIBODY TEST DESC
"RTN","RORRP026",187,0)
 ;; 12 ^ 18.13I  ^ POSITIVE HIV DETECTION TEST
"RTN","RORRP026",188,0)
 ;;    ^ 18.01I  ^ HIV CULTURE DETECTION TEST
"RTN","RORRP026",189,0)
 ;;    ^ 18.02I  ^ HIV ANTIGEN DETECTION TEST
"RTN","RORRP026",190,0)
 ;;    ^ 18.03I  ^ HIV PCR, DNA, OR RNA PROBE
"RTN","RORRP026",191,0)
 ;; 14 ^ 18.04I  ^ TYPE OF OTHER POSITIVE TEST
"RTN","RORRP026",192,0)
 ;; 15 ^ 18.05ID ^ DATE OTHER POS DETECTION TEST
"RTN","RORRP026",193,0)
 ;; 16 ^ 18.1I   ^ DETECTABLE VIRAL LOAD TEST
"RTN","RORRP026",194,0)
 ;; 17 ^ 18.11I  ^ DETECTABLE VIRAL LOAD RESULT
"RTN","RORRP026",195,0)
 ;; 18 ^ 18.12ID ^ DETECTABLE VIRAL LOAD DATE
"RTN","RORRP026",196,0)
LD2 ;
"RTN","RORRP026",197,0)
 ;;  3 ^ 18.07I  ^ TYPE FOR LAST NEG TEST
"RTN","RORRP026",198,0)
 ;;  4 ^ 18.06ID ^ LAST DOCUMNTD NEG HIV TEST
"RTN","RORRP026",199,0)
 ;;  5 ^ 18.08I  ^ PHYS DOCUMNTD DIAGNOSIS?
"RTN","RORRP026",200,0)
 ;;  6 ^ 18.09ID ^ DATE PHYS DOCUMNTD DIAG
"RTN","RORRP026",201,0)
 ;;  7 ^ 20.01I  ^ CD4+ COUNT FOR CDC
"RTN","RORRP026",202,0)
 ;;  8 ^ 20.02ID ^ CD4+ COUNT FOR CDC DATE
"RTN","RORRP026",203,0)
 ;;  9 ^ 20.03I  ^ CD4+ PERCENT FOR CDC
"RTN","RORRP026",204,0)
 ;; 10 ^ 20.04ID ^ CD4+ PERCENT FOR CDC DATE
"RTN","RORRP026",205,0)
 ;; 11 ^ 20.05I  ^ CD4 COUNT FIRST <200
"RTN","RORRP026",206,0)
 ;; 12 ^ 20.06ID ^ CD4 COUNT FIRST <200 DATE
"RTN","RORRP026",207,0)
 ;; 13 ^ 20.07I  ^ CD4 PERCENT FIRST <14%
"RTN","RORRP026",208,0)
 ;; 14 ^ 20.08ID ^ CD4 PERCENT FIRST <14% DATE
"RTN","RORRP026",209,0)
CS ;
"RTN","RORRP026",210,0)
 ;;  3 ^ 11.01I  ^ RECORD REVIEWED
"RTN","RORRP026",211,0)
 ;;  4 ^ 11.02ID ^ DATE ASYMPTOMATIC
"RTN","RORRP026",212,0)
 ;;  5 ^ 11.03ID ^ DATE SYMPTOMATIC
"RTN","RORRP026",213,0)
 ;;  6 ^ 11.05I  ^ RVCT CASE NO.
"RTN","RORRP026",214,0)
 ;;  7 ^ 11.04I  ^ IMMUNODEF THAT DISQUALIFIES
"RTN","RORRP026",215,0)
TS1 ;
"RTN","RORRP026",216,0)
 ;;  3 ^ 22.01I  ^ PATIENT BEEN INFORMED OF HIV
"RTN","RORRP026",217,0)
 ;;  4 ^ 22.02I  ^ PARTNERS NOTIFIED BY
"RTN","RORRP026",218,0)
 ;;  5 ^ 22.03I  ^ HIV RELATED MED SERVICES
"RTN","RORRP026",219,0)
 ;;  7 ^ 22.04I  ^ RCVD ANTI-RETROVIRAL THERAPY
"RTN","RORRP026",220,0)
 ;;  8 ^ 22.05I  ^ RECEIVED PCP PROPHYLAXIS
"RTN","RORRP026",221,0)
 ;;  9 ^ 22.06I  ^ ENROLLED AT CLINCAL TRIAL
"RTN","RORRP026",222,0)
 ;; 10 ^ 22.07I  ^ ENROLLED AT CLINIC
"RTN","RORRP026",223,0)
 ;; 11 ^ 22.08I  ^ PRIMARY REIMBURSER FOR MED RX
"RTN","RORRP026",224,0)
TS2 ;
"RTN","RORRP026",225,0)
 ;;  3 ^ 23.01I  ^ GYNECOLOGY OR OBSTETRIC CARE
"RTN","RORRP026",226,0)
 ;;  4 ^ 23.02I  ^ CURRENTLY PREGNANT
"RTN","RORRP026",227,0)
 ;;  5 ^ 23.03I  ^ DELIVERED LIVE BORN INFANT
"RTN","RORRP026",228,0)
 ;;  6 ^ 23.04I  ^ CHILD'S DATE OF BIRTH
"RTN","RORRP026",229,0)
 ;;  7 ^ 23.05I  ^ CHILD'S HOSPITAL OF BIRTH
"RTN","RORRP026",230,0)
 ;;  8 ^ 23.06I  ^ CHILD'S HOSPITAL - CITY
"RTN","RORRP026",231,0)
 ;;  9 ^ 23.07I  ^ CHILD'S HOSPITAL - STATE
"RTN","RORRP027")
0^66^B51376445
"RTN","RORRP027",1,0)
RORRP027 ;HCIOFO/SG - RPC: RORICR CDC SAVE ; 1/20/04 2:53pm
"RTN","RORRP027",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP027",3,0)
 ;
"RTN","RORRP027",4,0)
 ;--------------------------------------------------------------------
"RTN","RORRP027",5,0)
 ; Registry: [VA ICR]
"RTN","RORRP027",6,0)
 ;--------------------------------------------------------------------
"RTN","RORRP027",7,0)
 Q
"RTN","RORRP027",8,0)
 ;
"RTN","RORRP027",9,0)
 ;***** AIDS INDICATOR DISEASE (VIII)
"RTN","RORRP027",10,0)
AID(IENS) ;
"RTN","RORRP027",11,0)
 N CODE,RC,TMP
"RTN","RORRP027",12,0)
 S CODE=+$P(RORDATA(RORPTR),U,2)
"RTN","RORRP027",13,0)
 Q:CODE'>0 "2^AID"_U_CODE
"RTN","RORRP027",14,0)
 ;--- Initial diagnosis
"RTN","RORRP027",15,0)
 S RORAILST(CODE)=$P(RORDATA(RORPTR),U,3)
"RTN","RORRP027",16,0)
 ;--- Initial date
"RTN","RORRP027",17,0)
 S TMP=$$DATE1^RORRP026($P(RORDATA(RORPTR),U,4))
"RTN","RORRP027",18,0)
 Q:(TMP<0)!('TMP&RORAILST(CODE)) "4^AID"_U_CODE
"RTN","RORRP027",19,0)
 S $P(RORAILST(CODE),U,2)=TMP
"RTN","RORRP027",20,0)
 Q 0
"RTN","RORRP027",21,0)
 ;
"RTN","RORRP027",22,0)
 ;***** STORES THE AIDS INDICATOR DICEASES INTO THE FDA
"RTN","RORRP027",23,0)
AIDSTORE() ;
"RTN","RORRP027",24,0)
 N CODE,II,NODE,RC,TMP
"RTN","RORRP027",25,0)
 S NODE=$$ROOT^DILFD(799.41,","_IENS,1)
"RTN","RORRP027",26,0)
 S RC=0
"RTN","RORRP027",27,0)
 ;--- Mark the old records for removal
"RTN","RORRP027",28,0)
 S CODE=0
"RTN","RORRP027",29,0)
 F  S CODE=$O(@NODE@(CODE))  Q:CODE'>0  D:'$D(RORAILST(CODE))
"RTN","RORRP027",30,0)
 . S RORFDAFI(799.41,CODE_","_IENS,.01)="@"
"RTN","RORRP027",31,0)
 ;--- Prepare the records to be added/updated
"RTN","RORRP027",32,0)
 S II=+$O(RORIEN(""),-1)
"RTN","RORRP027",33,0)
 S CODE=0
"RTN","RORRP027",34,0)
 F  S CODE=$O(RORAILST(CODE))  Q:CODE'>0  D
"RTN","RORRP027",35,0)
 . ;--- Update the record
"RTN","RORRP027",36,0)
 . I $D(@NODE@(CODE))  D  Q
"RTN","RORRP027",37,0)
 . . S TMP=CODE_","_IENS
"RTN","RORRP027",38,0)
 . . S RORFDAFI(799.41,TMP,.02)=$P(RORAILST(CODE),U,1)
"RTN","RORRP027",39,0)
 . . S RORFDAFI(799.41,TMP,.03)=$P(RORAILST(CODE),U,2)
"RTN","RORRP027",40,0)
 . ;--- Add the record
"RTN","RORRP027",41,0)
 . S II=II+1,RORIEN(II)=CODE,TMP="?+"_II_","_IENS
"RTN","RORRP027",42,0)
 . S RORFDAUP(799.41,TMP,.01)=CODE
"RTN","RORRP027",43,0)
 . S RORFDAUP(799.41,TMP,.02)=$P(RORAILST(CODE),U,1)
"RTN","RORRP027",44,0)
 . S RORFDAUP(799.41,TMP,.03)=$P(RORAILST(CODE),U,2)
"RTN","RORRP027",45,0)
 Q RC
"RTN","RORRP027",46,0)
 ;
"RTN","RORRP027",47,0)
 ;***** CANCELS THE EDITING
"RTN","RORRP027",48,0)
 ; RPC: [RORICR CDC CANCEL]
"RTN","RORRP027",49,0)
 ;
"RTN","RORRP027",50,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP027",51,0)
 ;               are returned to.
"RTN","RORRP027",52,0)
 ;
"RTN","RORRP027",53,0)
 ; REGIEN        Registry IEN
"RTN","RORRP027",54,0)
 ;
"RTN","RORRP027",55,0)
 ; PATIEN        IEN of the registry patient (DFN)
"RTN","RORRP027",56,0)
 ;
"RTN","RORRP027",57,0)
 ; Return Values:
"RTN","RORRP027",58,0)
 ;
"RTN","RORRP027",59,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP027",60,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP027",61,0)
 ; details).
"RTN","RORRP027",62,0)
 ;
"RTN","RORRP027",63,0)
 ; Otherwise, zero is returned in the RESULTS(0).
"RTN","RORRP027",64,0)
 ;
"RTN","RORRP027",65,0)
CANCEL(RESULTS,REGIEN,PATIEN) ;
"RTN","RORRP027",66,0)
 N IENS,RC,RORERRDL
"RTN","RORRP027",67,0)
 D CLEAR^RORERR("CANCEL^RORRP027",1)  K RESULTS
"RTN","RORRP027",68,0)
 ;--- Check the parameters
"RTN","RORRP027",69,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP027",70,0)
 . ;--- Registry IEN
"RTN","RORRP027",71,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP027",72,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP027",73,0)
 . S REGIEN=+REGIEN
"RTN","RORRP027",74,0)
 . ;--- Patient IEN
"RTN","RORRP027",75,0)
 . I $G(PATIEN)'>0  D  Q
"RTN","RORRP027",76,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"PATIEN",$G(PATIEN))
"RTN","RORRP027",77,0)
 . S PATIEN=+PATIEN
"RTN","RORRP027",78,0)
 ;
"RTN","RORRP027",79,0)
 ;--- Get the IENS of the registry record
"RTN","RORRP027",80,0)
 S IENS=$$PRRIEN^RORUTL01(PATIEN,REGIEN)_","
"RTN","RORRP027",81,0)
 ;
"RTN","RORRP027",82,0)
 ;--- Unlock the records
"RTN","RORRP027",83,0)
 I IENS>0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP027",84,0)
 . S RC=$$UNLOCK^RORLOCK(799.4,IENS)
"RTN","RORRP027",85,0)
 S RESULTS(0)=0
"RTN","RORRP027",86,0)
 Q
"RTN","RORRP027",87,0)
 ;
"RTN","RORRP027",88,0)
 ;***** DEMOGRAPHIC INFORMATION (III)
"RTN","RORRP027",89,0)
CDM(IENS) ;
"RTN","RORRP027",90,0)
 N BUF,RC,TMP
"RTN","RORRP027",91,0)
 S BUF=RORDATA(RORPTR)
"RTN","RORRP027",92,0)
 S RC=$$CDCFDA^RORRP026(IENS,"CDM^RORRP026",BUF,.RORFDAFI)
"RTN","RORRP027",93,0)
 Q:RC RC
"RTN","RORRP027",94,0)
 ;--- Default values
"RTN","RORRP027",95,0)
 F TMP=9.04,9.08,9.09  S RORFDAFI(799.4,IENS,TMP)=""
"RTN","RORRP027",96,0)
 ;--- Age at diagnosis
"RTN","RORRP027",97,0)
 S TMP=+$P(BUF,U,3)
"RTN","RORRP027",98,0)
 I TMP  Q:$P(BUF,U,4)'>0 "4^CDM"  D
"RTN","RORRP027",99,0)
 . S:TMP=1 RORFDAFI(799.4,IENS,9.03)=$P(BUF,U,4)
"RTN","RORRP027",100,0)
 . S:TMP=2 RORFDAFI(799.4,IENS,9.04)=$P(BUF,U,4)
"RTN","RORRP027",101,0)
 ;--- Country of birth
"RTN","RORRP027",102,0)
 S TMP=+$P(BUF,U,7)
"RTN","RORRP027",103,0)
 S:TMP=7 RORFDAFI(799.4,IENS,9.08)=$P(BUF,U,8)
"RTN","RORRP027",104,0)
 S:TMP=8 RORFDAFI(799.4,IENS,9.09)=$P(BUF,U,8)
"RTN","RORRP027",105,0)
 Q 0
"RTN","RORRP027",106,0)
 ;
"RTN","RORRP027",107,0)
 ;***** COMMENTS (X)
"RTN","RORRP027",108,0)
CMT(IENS) ;
"RTN","RORRP027",109,0)
 N CNT,NE,PTR,RC,SEG,TMP  K RORCMT
"RTN","RORRP027",110,0)
 ;--- Load the comments
"RTN","RORRP027",111,0)
 S PTR=RORPTR,(CNT,NE,RC)=0
"RTN","RORRP027",112,0)
 F  D  Q:RC!(SEG'="CMT")  S PTR=$O(RORDATA(PTR))  Q:PTR=""
"RTN","RORRP027",113,0)
 . S SEG=$P(RORDATA(PTR),U)  Q:SEG'="CMT"
"RTN","RORRP027",114,0)
 . S RORPTR=PTR  Q:CNT'<3
"RTN","RORRP027",115,0)
 . S TMP=$P(RORDATA(RORPTR),U,3)
"RTN","RORRP027",116,0)
 . S CNT=CNT+1,RORCMT(CNT)=TMP
"RTN","RORRP027",117,0)
 . S:TMP'="" NE=NE+1
"RTN","RORRP027",118,0)
 ;--- Store the reference into the FDA
"RTN","RORRP027",119,0)
 S RORFDAFI(799.4,IENS,25)=$S(NE>0:"RORCMT",1:"@")
"RTN","RORRP027",120,0)
 Q RC
"RTN","RORRP027",121,0)
 ;
"RTN","RORRP027",122,0)
 ;***** CLINICAL STATUS (VIII)
"RTN","RORRP027",123,0)
CS(IENS) ;
"RTN","RORRP027",124,0)
 N RC,TMP
"RTN","RORRP027",125,0)
 S RC=$$CDCFDA^RORRP026(IENS,"CS^RORRP026",RORDATA(RORPTR),.RORFDAFI)
"RTN","RORRP027",126,0)
 Q RC
"RTN","RORRP027",127,0)
 ;
"RTN","RORRP027",128,0)
 ;***** PROCESSES THE ERROR(S) AND UNLOCKS THE RECORDS
"RTN","RORRP027",129,0)
ERROR(RESULTS,RC) ;
"RTN","RORRP027",130,0)
 D RPCSTK^RORERR(.RESULTS,RC)
"RTN","RORRP027",131,0)
 D UNLOCK^RORLOCK(.RORLOCK)
"RTN","RORRP027",132,0)
 Q
"RTN","RORRP027",133,0)
 ;
"RTN","RORRP027",134,0)
 ;***** FACILITY OF DIAGNOSIS (IV)
"RTN","RORRP027",135,0)
FD(IENS) ;
"RTN","RORRP027",136,0)
 N RC,TMP
"RTN","RORRP027",137,0)
 S RC=$$CDCFDA^RORRP026(IENS,"FD^RORRP026",RORDATA(RORPTR),.RORFDAFI)
"RTN","RORRP027",138,0)
 Q RC
"RTN","RORRP027",139,0)
 ;
"RTN","RORRP027",140,0)
 ;***** FORM HEADERS
"RTN","RORRP027",141,0)
HDR(IENS) ;
"RTN","RORRP027",142,0)
 N RC,TMP
"RTN","RORRP027",143,0)
 S RC=$$CDCFDA^RORRP026(IENS,"HDR^RORRP026",RORDATA(RORPTR),.RORFDAFI)
"RTN","RORRP027",144,0)
 ;--- Person who completed the form
"RTN","RORRP027",145,0)
 S RORFDAFI(799.4,IENS,9.05)=DUZ
"RTN","RORRP027",146,0)
 Q RC
"RTN","RORRP027",147,0)
 ;
"RTN","RORRP027",148,0)
 ;***** LABORATORY DATA (VI)
"RTN","RORRP027",149,0)
LD1(IENS) ;
"RTN","RORRP027",150,0)
 N BUF,FLD,DATE,RC,TMP
"RTN","RORRP027",151,0)
 S BUF=RORDATA(RORPTR)
"RTN","RORRP027",152,0)
 S RC=$$CDCFDA^RORRP026(IENS,"LD1^RORRP026",BUF,.RORFDAFI)
"RTN","RORRP027",153,0)
 Q:RC RC
"RTN","RORRP027",154,0)
 ;--- Positive HIV detection test
"RTN","RORRP027",155,0)
 S FLD=$$PHIVFLD^RORRP026($P(BUF,U,12))
"RTN","RORRP027",156,0)
 I FLD  S RC=0  D  Q:RC RC
"RTN","RORRP027",157,0)
 . S DATE=$$DATE1^RORRP026($P(BUF,U,13))
"RTN","RORRP027",158,0)
 . I DATE<0  S RC="13^LD1"  Q
"RTN","RORRP027",159,0)
 . S RORFDAFI(799.4,IENS,FLD)=DATE
"RTN","RORRP027",160,0)
 Q 0
"RTN","RORRP027",161,0)
 ;
"RTN","RORRP027",162,0)
LD2(IENS) ;
"RTN","RORRP027",163,0)
 N RC,TMP
"RTN","RORRP027",164,0)
 S RC=$$CDCFDA^RORRP026(IENS,"LD2^RORRP026",RORDATA(RORPTR),.RORFDAFI)
"RTN","RORRP027",165,0)
 Q RC
"RTN","RORRP027",166,0)
 ;
"RTN","RORRP027",167,0)
 ;***** PATIENT HISTORY (V)
"RTN","RORRP027",168,0)
PH(IENS) ;
"RTN","RORRP027",169,0)
 N RC,TMP
"RTN","RORRP027",170,0)
 S RC=$$CDCFDA^RORRP026(IENS,"PH^RORRP026",RORDATA(RORPTR),.RORFDAFI)
"RTN","RORRP027",171,0)
 Q RC
"RTN","RORRP027",172,0)
 ;
"RTN","RORRP027",173,0)
 ;***** UPDATES THE CDC DATA
"RTN","RORRP027",174,0)
 ; RPC: [RORICR CDC SAVE]
"RTN","RORRP027",175,0)
 ;
"RTN","RORRP027",176,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP027",177,0)
 ;               are returned to.
"RTN","RORRP027",178,0)
 ;
"RTN","RORRP027",179,0)
 ; REGIEN        Registry IEN
"RTN","RORRP027",180,0)
 ;
"RTN","RORRP027",181,0)
 ; PATIEN        IEN of the registry patient (DFN)
"RTN","RORRP027",182,0)
 ;
"RTN","RORRP027",183,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORRP027",184,0)
 ;                 H  Update the patient history. If this flag is
"RTN","RORRP027",185,0)
 ;                    not provided, the PH data segment is ignored.
"RTN","RORRP027",186,0)
 ;
"RTN","RORRP027",187,0)
 ; .RORDATA      Reference to a local array that contains the CDC
"RTN","RORRP027",188,0)
 ;               data in the same format as the output of the RORICR
"RTN","RORRP027",189,0)
 ;               CDC LOAD remote procedure (see the LOADCDC^RORRP025
"RTN","RORRP027",190,0)
 ;               and description of the RPC for more details).
"RTN","RORRP027",191,0)
 ;
"RTN","RORRP027",192,0)
 ; NOTE #1: The CS data segment must be always included before the
"RTN","RORRP027",193,0)
 ;          AID segments. Otherwise, the latter will be ignored.
"RTN","RORRP027",194,0)
 ;
"RTN","RORRP027",195,0)
 ; NOTE #2: Any AIDS indicator disease, which has empty 3rd piece
"RTN","RORRP027",196,0)
 ;          in the corresponding AID segment (or no segment at all),
"RTN","RORRP027",197,0)
 ;          will be removed from the patient record.
"RTN","RORRP027",198,0)
 ;
"RTN","RORRP027",199,0)
 ; NOTE #3: There should be at least one empty comment (i.e. the
"RTN","RORRP027",200,0)
 ;          "CMT^1" segment) among the data if you want to clear
"RTN","RORRP027",201,0)
 ;          the CDC comments. Otherwise, they will not be updated.
"RTN","RORRP027",202,0)
 ;
"RTN","RORRP027",203,0)
 ; Return Values:
"RTN","RORRP027",204,0)
 ;
"RTN","RORRP027",205,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP027",206,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP027",207,0)
 ; details).
"RTN","RORRP027",208,0)
 ;
"RTN","RORRP027",209,0)
 ; Positive value of the first "^"-piece of the RESULTS(0) indicates
"RTN","RORRP027",210,0)
 ; an error in the CDC data. The value is the number of the erroneous
"RTN","RORRP027",211,0)
 ; piece of the data segment whose name is returned in the second
"RTN","RORRP027",212,0)
 ; piece of the RESULTS(0). For example, the "11^CDM" means that the
"RTN","RORRP027",213,0)
 ; 11th piece of the CDM data segment (ONSET OF ILLNESS/AIDS- STATE)
"RTN","RORRP027",214,0)
 ; contains an invalid value.
"RTN","RORRP027",215,0)
 ;
"RTN","RORRP027",216,0)
 ; Otherwise, zero is returned in the RESULTS(0).
"RTN","RORRP027",217,0)
 ;
"RTN","RORRP027",218,0)
SAVECDC(RESULTS,REGIEN,PATIEN,FLAGS,RORDATA) ;
"RTN","RORRP027",219,0)
 N RORAILST      ; List of AIDS indicator diseases
"RTN","RORRP027",220,0)
 N RORCMT        ; Buffer for the CDC comments (WP field)
"RTN","RORRP027",221,0)
 N RORFDAFI      ; FDA for FILE^DIE
"RTN","RORRP027",222,0)
 N RORFDAUP      ; FDA for UPDATE^DIE
"RTN","RORRP027",223,0)
 N RORIEN        ; List of IEN's to be assigned
"RTN","RORRP027",224,0)
 ;
"RTN","RORRP027",225,0)
 N I,IEN,IENS,RC,RORERRDL,RORMSG,RORPTR,SEG,SEGLST
"RTN","RORRP027",226,0)
 D CLEAR^RORERR("SAVECDC^RORRP027",1)
"RTN","RORRP027",227,0)
 K RESULTS  S (RESULTS(0),RORPTR)=0
"RTN","RORRP027",228,0)
 ;--- Check the parameters
"RTN","RORRP027",229,0)
 S RC=0  D  I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP027",230,0)
 . ;--- Registry IEN
"RTN","RORRP027",231,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP027",232,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP027",233,0)
 . S REGIEN=+REGIEN
"RTN","RORRP027",234,0)
 . ;--- Patient IEN
"RTN","RORRP027",235,0)
 . I $G(PATIEN)'>0  D  Q
"RTN","RORRP027",236,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"PATIEN",$G(PATIEN))
"RTN","RORRP027",237,0)
 . S PATIEN=+PATIEN
"RTN","RORRP027",238,0)
 . ;--- Flags
"RTN","RORRP027",239,0)
 . S FLAGS=$$UP^XLFSTR($G(FLAGS))
"RTN","RORRP027",240,0)
 ;
"RTN","RORRP027",241,0)
 ;--- Get IEN of the registry record
"RTN","RORRP027",242,0)
 S IEN=$$PRRIEN^RORUTL01(PATIEN,REGIEN)  Q:IEN'>0
"RTN","RORRP027",243,0)
 S IENS=IEN_","
"RTN","RORRP027",244,0)
 S RORLOCK(799.4,IENS)=""
"RTN","RORRP027",245,0)
 ;
"RTN","RORRP027",246,0)
 ;--- Prepare the data
"RTN","RORRP027",247,0)
 S SEGLST=",HDR,CDM,FD,LD1,LD2,CS,AID,TS1,TS2,CMT,"
"RTN","RORRP027",248,0)
 S:FLAGS["H" SEGLST=SEGLST_"PH,"
"RTN","RORRP027",249,0)
 S (RC,RORPTR)=0
"RTN","RORRP027",250,0)
 F  S RORPTR=$O(RORDATA(RORPTR))  Q:RORPTR'>0  D  Q:RC
"RTN","RORRP027",251,0)
 . S SEG=$TR($P(RORDATA(RORPTR),U)," ")
"RTN","RORRP027",252,0)
 . X:SEGLST[(","_SEG_",") "S RC=$$"_SEG_"(IENS)"
"RTN","RORRP027",253,0)
 I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP027",254,0)
 I RC>0  S RESULTS(0)=RC  Q
"RTN","RORRP027",255,0)
 ;
"RTN","RORRP027",256,0)
 ;--- Process the list of AIDS indicator diseases
"RTN","RORRP027",257,0)
 S RC=$$AIDSTORE()
"RTN","RORRP027",258,0)
 I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP027",259,0)
 ;
"RTN","RORRP027",260,0)
 ;--- Update the record(s)
"RTN","RORRP027",261,0)
 I $D(RORFDAFI)>1  D  I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP027",262,0)
 . D FILE^DIE(,"RORFDAFI","RORMSG")
"RTN","RORRP027",263,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,799.4,IENS)
"RTN","RORRP027",264,0)
 ;--- Add the record(s)
"RTN","RORRP027",265,0)
 I $D(RORFDAUP)>1  D  I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP027",266,0)
 . D UPDATE^DIE(,"RORFDAUP","RORIEN","RORMSG")
"RTN","RORRP027",267,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,799.4,IENS)
"RTN","RORRP027",268,0)
 ;
"RTN","RORRP027",269,0)
 ;--- Unlock the records
"RTN","RORRP027",270,0)
 S RC=$$UNLOCK^RORLOCK(.RORLOCK)
"RTN","RORRP027",271,0)
 I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP027",272,0)
 S RESULTS(0)=0
"RTN","RORRP027",273,0)
 Q
"RTN","RORRP027",274,0)
 ;
"RTN","RORRP027",275,0)
 ;***** TREATMENT/SERVICES REFERRALS (IX)
"RTN","RORRP027",276,0)
TS1(IENS) ;
"RTN","RORRP027",277,0)
 N RC,TMP
"RTN","RORRP027",278,0)
 S RC=$$CDCFDA^RORRP026(IENS,"TS1^RORRP026",RORDATA(RORPTR),.RORFDAFI)
"RTN","RORRP027",279,0)
 Q RC
"RTN","RORRP027",280,0)
 ;
"RTN","RORRP027",281,0)
TS2(IENS) ;
"RTN","RORRP027",282,0)
 N RC,TMP
"RTN","RORRP027",283,0)
 S RC=$$CDCFDA^RORRP026(IENS,"TS2^RORRP026",RORDATA(RORPTR),.RORFDAFI)
"RTN","RORRP027",284,0)
 Q RC
"RTN","RORRP029")
0^69^B6656524
"RTN","RORRP029",1,0)
RORRP029 ;HCIOFO/SG - RPC: ADDRESS UTILITIES ; 4/16/03 9:35am
"RTN","RORRP029",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP029",3,0)
 ;
"RTN","RORRP029",4,0)
 ; This routine uses the following IAs:
"RTN","RORRP029",5,0)
 ;
"RTN","RORRP029",6,0)
 ; #10056        Read access to the STATE file (#5)
"RTN","RORRP029",7,0)
 ;
"RTN","RORRP029",8,0)
 Q
"RTN","RORRP029",9,0)
 ;
"RTN","RORRP029",10,0)
 ;***** RETURNS THE LIST OF STATES
"RTN","RORRP029",11,0)
 ; RPC: [ROR LIST STATES]
"RTN","RORRP029",12,0)
 ;
"RTN","RORRP029",13,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP029",14,0)
 ;               are returned to.
"RTN","RORRP029",15,0)
 ;
"RTN","RORRP029",16,0)
 ; PART          The search pattern (partial match restriction)
"RTN","RORRP029",17,0)
 ;
"RTN","RORRP029",18,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORRP029",19,0)
 ;                 A  Enable abbreviation search (if PART contains 2
"RTN","RORRP029",20,0)
 ;                    character abbreviation, the corresponding state 
"RTN","RORRP029",21,0)
 ;                    is returned. Otherwise, the regular search is
"RTN","RORRP029",22,0)
 ;                    performed).
"RTN","RORRP029",23,0)
 ;                 B  Backwards. Traverses the index in the opposite
"RTN","RORRP029",24,0)
 ;                    direction of normal traversal.
"RTN","RORRP029",25,0)
 ;
"RTN","RORRP029",26,0)
 ; [NUMBER]      Maximum number of entries to return. A value of "*"
"RTN","RORRP029",27,0)
 ;               or no value in this parameter designates all entries.
"RTN","RORRP029",28,0)
 ;
"RTN","RORRP029",29,0)
 ; [FROM]        The index entry(s) from which to begin the list.
"RTN","RORRP029",30,0)
 ;               You should use the pieces of the @RESULTS@(0) node
"RTN","RORRP029",31,0)
 ;               (starting from the second one) to continue the
"RTN","RORRP029",32,0)
 ;               listing in the subsequent procedure calls.
"RTN","RORRP029",33,0)
 ;
"RTN","RORRP029",34,0)
 ;               NOTE: The FROM value itself is not included in
"RTN","RORRP029",35,0)
 ;                     the resulting list.
"RTN","RORRP029",36,0)
 ;
"RTN","RORRP029",37,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP029",38,0)
 ;
"RTN","RORRP029",39,0)
 ; See description of the LIST^DIC for more details about the
"RTN","RORRP029",40,0)
 ; PART, NUMBER and FROM parameters.
"RTN","RORRP029",41,0)
 ;
"RTN","RORRP029",42,0)
 ; Return Values:
"RTN","RORRP029",43,0)
 ;
"RTN","RORRP029",44,0)
 ; A negative value of the first "^"-piece of the @RESULTS@(0)
"RTN","RORRP029",45,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP029",46,0)
 ; details).
"RTN","RORRP029",47,0)
 ;
"RTN","RORRP029",48,0)
 ; Otherwise, number of states and the value of the FROM
"RTN","RORRP029",49,0)
 ; parameter for the next procedure call are returned in the
"RTN","RORRP029",50,0)
 ; @RESULTS@(0) and the subsequent nodes of the global array
"RTN","RORRP029",51,0)
 ; contain the states.
"RTN","RORRP029",52,0)
 ; 
"RTN","RORRP029",53,0)
 ; @RESULTS@(0)          Result Descriptor
"RTN","RORRP029",54,0)
 ;                         ^01: Number of states
"RTN","RORRP029",55,0)
 ;                         ^02: Values that comprise the FROM
"RTN","RORRP029",56,0)
 ;                         ^nn: parameter for the subsequent call
"RTN","RORRP029",57,0)
 ;
"RTN","RORRP029",58,0)
 ; @RESULTS@(i)          State
"RTN","RORRP029",59,0)
 ;                         ^01: IEN
"RTN","RORRP029",60,0)
 ;                         ^02: Name
"RTN","RORRP029",61,0)
 ;                         ^03: Abbreviation
"RTN","RORRP029",62,0)
 ;                         ^04: VA State Code
"RTN","RORRP029",63,0)
 ;
"RTN","RORRP029",64,0)
STATELST(RESULTS,PART,FLAGS,NUMBER,FROM) ;
"RTN","RORRP029",65,0)
 N BUF,FIELDS,I,RC,RORERRDL,TMP
"RTN","RORRP029",66,0)
 D CLEAR^RORERR("STATELST^RORRP029",1)
"RTN","RORRP029",67,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP029",68,0)
 S FIELDS="@;.01;1;2"
"RTN","RORRP029",69,0)
 ;--- Check the parameters
"RTN","RORRP029",70,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP029",71,0)
 . ;--- Flags
"RTN","RORRP029",72,0)
 . S FLAGS=$$UP^XLFSTR($G(FLAGS))
"RTN","RORRP029",73,0)
 . ;--- Others
"RTN","RORRP029",74,0)
 . S PART=$G(PART),FROM=$G(FROM)
"RTN","RORRP029",75,0)
 . S NUMBER=$S($G(NUMBER)>0:+NUMBER,1:"*")
"RTN","RORRP029",76,0)
 ;--- Setup the start point
"RTN","RORRP029",77,0)
 F I=1:1  S TMP=$P(FROM,U,I)  Q:TMP=""  S FROM(I)=TMP
"RTN","RORRP029",78,0)
 S FROM=$G(FROM(1))
"RTN","RORRP029",79,0)
 ;--- Check for the abbreviation
"RTN","RORRP029",80,0)
 S RC=0
"RTN","RORRP029",81,0)
 I FLAGS["A",$L(PART)=2  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP029",82,0)
 . D LIST^DIC(5,,FIELDS,"P",2,,PART,"C",,,,"RORMSG")
"RTN","RORRP029",83,0)
 . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,5)  Q
"RTN","RORRP029",84,0)
 . S:+$G(^TMP("DILIST",$J,0))=1 RC=1
"RTN","RORRP029",85,0)
 ;--- Query the file
"RTN","RORRP029",86,0)
 I 'RC  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP029",87,0)
 . S TMP="P"_$S(FLAGS["B":"B",1:"")
"RTN","RORRP029",88,0)
 . D LIST^DIC(5,,FIELDS,TMP,NUMBER,.FROM,PART,"B",,,,"RORMSG")
"RTN","RORRP029",89,0)
 . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,5)  Q
"RTN","RORRP029",90,0)
 ;--- Success
"RTN","RORRP029",91,0)
 S TMP=$G(^TMP("DILIST",$J,0)),BUF=+$P(TMP,U)
"RTN","RORRP029",92,0)
 K ^TMP("DILIST",$J,0)
"RTN","RORRP029",93,0)
 I $P(TMP,U,3)  S I=0  D
"RTN","RORRP029",94,0)
 . F  S I=$O(FROM(I))  Q:I'>0  S TMP=FROM(I)  S:TMP'="" BUF=BUF_U_TMP
"RTN","RORRP029",95,0)
 S @RESULTS@(0)=BUF
"RTN","RORRP029",96,0)
 Q
"RTN","RORRP030")
0^103^B34670382
"RTN","RORRP030",1,0)
RORRP030 ;HCIOFO/SG - RPC: PATIENT (IN)ACTIVATE/DELETE ; 11/26/03 7:52am
"RTN","RORRP030",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP030",3,0)
 ;
"RTN","RORRP030",4,0)
 Q
"RTN","RORRP030",5,0)
 ;
"RTN","RORRP030",6,0)
 ;***** SENDS THE ALERT TO THE CURRENT USER
"RTN","RORRP030",7,0)
 ;
"RTN","RORRP030",8,0)
 ; DFN           Patient IEN
"RTN","RORRP030",9,0)
 ; DLGNUM        Number of the alert template
"RTN","RORRP030",10,0)
 ;
"RTN","RORRP030",11,0)
ALERT(DFN,DLGNUM) ;
"RTN","RORRP030",12,0)
 N VA,VADM,VAHOW,VAROOT,XQA,XQADATA,XQAMSG,XQAROU
"RTN","RORRP030",13,0)
 D DEM^VADPT
"RTN","RORRP030",14,0)
 S XQADATA=DLGNUM_U_$P(RORREG,U,2)            ; Dialog & Registry name
"RTN","RORRP030",15,0)
 S $P(XQADATA,U,3)=$G(VADM(1))                ; Patient name
"RTN","RORRP030",16,0)
 S $P(XQADATA,U,4)=$E($P($G(VADM(2)),U),6,9)  ; Last 4 of SSN
"RTN","RORRP030",17,0)
 S XQAMSG="Record of Clinical Case Registries has been (in)activated."
"RTN","RORRP030",18,0)
 S XQA(DUZ)="",XQAROU="ALERTRTN^RORRP030"
"RTN","RORRP030",19,0)
 D SETUP^XQALERT
"RTN","RORRP030",20,0)
 Q
"RTN","RORRP030",21,0)
 ;
"RTN","RORRP030",22,0)
 ;***** CALLBACK ENTRY POINT FOR ALERT PROCESSING
"RTN","RORRP030",23,0)
ALERTRTN ;
"RTN","RORRP030",24,0)
 N I,PARAMS,RORBUF
"RTN","RORRP030",25,0)
 ;--- Prepare the parameters
"RTN","RORRP030",26,0)
 S PARAMS("REGISTRY")=$P(XQADATA,U,2)  ; Registry name
"RTN","RORRP030",27,0)
 S PARAMS("NAME")=$P(XQADATA,U,3)      ; Patient name
"RTN","RORRP030",28,0)
 S PARAMS("LAST4")=$P(XQADATA,U,4)     ; Last 4 digits of SSN
"RTN","RORRP030",29,0)
 ;--- Generate the text of alert
"RTN","RORRP030",30,0)
 D BLD^DIALOG(+XQADATA,.PARAMS,,"RORBUF","S")
"RTN","RORRP030",31,0)
 ;--- Display the alert details
"RTN","RORRP030",32,0)
 S I=0  W !
"RTN","RORRP030",33,0)
 F  S I=$O(RORBUF(I))  Q:I'>0  W !,RORBUF(I)
"RTN","RORRP030",34,0)
 Q
"RTN","RORRP030",35,0)
 ;
"RTN","RORRP030",36,0)
 ;***** DELETE THE PATIENT'S RECORD FROM THE REGISTRY
"RTN","RORRP030",37,0)
 ; RPC: [ROR PATIENT DELETE]
"RTN","RORRP030",38,0)
 ;
"RTN","RORRP030",39,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP030",40,0)
 ;               are returned to.
"RTN","RORRP030",41,0)
 ;
"RTN","RORRP030",42,0)
 ; REGIEN        Registry IEN
"RTN","RORRP030",43,0)
 ;
"RTN","RORRP030",44,0)
 ; RORDFN        IEN of the patient
"RTN","RORRP030",45,0)
 ;
"RTN","RORRP030",46,0)
 ; [FORCE]       Force the deletion (even if the data has been
"RTN","RORRP030",47,0)
 ;               sent to the AAC already)
"RTN","RORRP030",48,0)
 ;
"RTN","RORRP030",49,0)
 ; Return Values:
"RTN","RORRP030",50,0)
 ;
"RTN","RORRP030",51,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP030",52,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP030",53,0)
 ; details).
"RTN","RORRP030",54,0)
 ;
"RTN","RORRP030",55,0)
 ; Otherwise, the following codes can be returned in the RESULTS(0):
"RTN","RORRP030",56,0)
 ;
"RTN","RORRP030",57,0)
 ;         0  The record cannot be deleted
"RTN","RORRP030",58,0)
 ;         9  The record has been deleted
"RTN","RORRP030",59,0)
 ;
"RTN","RORRP030",60,0)
DELETE(RESULTS,REGIEN,RORDFN,FORCE) ;
"RTN","RORRP030",61,0)
 N IENS,RC,REGNAME,RORFDA,RORMSG,TMP
"RTN","RORRP030",62,0)
 D CLEAR^RORERR("DELETE^RORRP030",1)
"RTN","RORRP030",63,0)
 K RESULTS  S RESULTS(0)=0
"RTN","RORRP030",64,0)
 ;
"RTN","RORRP030",65,0)
 ;--- Get the registry description/name
"RTN","RORRP030",66,0)
 S TMP=$$REGNAME^RORUTL01(REGIEN)
"RTN","RORRP030",67,0)
 I TMP=""  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP030",68,0)
 . S RC=$$ERROR^RORERR(-1,,,RORDFN)
"RTN","RORRP030",69,0)
 S REGNAME=$S($P(TMP,U,2)'="":$P(TMP,U,2),1:$P(TMP,U))
"RTN","RORRP030",70,0)
 ;
"RTN","RORRP030",71,0)
 ;--- Get IENS of the registry record
"RTN","RORRP030",72,0)
 S IENS=$$PRRIEN^RORUTL01(RORDFN,REGIEN)_","
"RTN","RORRP030",73,0)
 I IENS'>0  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP030",74,0)
 . S RC=$$ERROR^RORERR(-97,,,RORDFN,REGNAME)
"RTN","RORRP030",75,0)
 ;
"RTN","RORRP030",76,0)
 ;--- Check if the data has been sent to the AAC already
"RTN","RORRP030",77,0)
 S TMP=$$GET1^DIQ(798,IENS,12,"I",,"RORMSG")
"RTN","RORRP030",78,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP030",79,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,RORDFN,798,IENS)
"RTN","RORRP030",80,0)
 I '$G(FORCE)  Q:'TMP
"RTN","RORRP030",81,0)
 ;
"RTN","RORRP030",82,0)
 ;--- Delete the record
"RTN","RORRP030",83,0)
 S RORFDA(798,IENS,.01)="@"
"RTN","RORRP030",84,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORRP030",85,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP030",86,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,RORDFN,798,IENS)
"RTN","RORRP030",87,0)
 ;---
"RTN","RORRP030",88,0)
 S RESULTS(0)=9
"RTN","RORRP030",89,0)
 Q
"RTN","RORRP030",90,0)
 ;
"RTN","RORRP030",91,0)
 ;***** INACTIVATES THE PATIENT
"RTN","RORRP030",92,0)
 ;
"RTN","RORRP030",93,0)
 ; IENS          IENS of the registry record
"RTN","RORRP030",94,0)
 ; REASON        IEN of the reason for inactivation
"RTN","RORRP030",95,0)
 ; DATE          Inactivation date
"RTN","RORRP030",96,0)
 ;
"RTN","RORRP030",97,0)
 ; Return Values:
"RTN","RORRP030",98,0)
 ;        <0  Error code
"RTN","RORRP030",99,0)
 ;         1  The record has been inactivated
"RTN","RORRP030",100,0)
 ;         9  The record has been deleted
"RTN","RORRP030",101,0)
 ;
"RTN","RORRP030",102,0)
INACTIV(IENS,REASON,DATE) ;
"RTN","RORRP030",103,0)
 N NODE,RC,RORFDA,RORMSG,DSENT
"RTN","RORRP030",104,0)
 ;--- Check if the data has been sent to the AAC already
"RTN","RORRP030",105,0)
 S DSENT='$$GET1^DIQ(798,IENS,12,"I",,"RORMSG")
"RTN","RORRP030",106,0)
 I $G(DIERR)  D  Q RC
"RTN","RORRP030",107,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,RORDFN,798,IENS)
"RTN","RORRP030",108,0)
 ;--- Prepare the fields
"RTN","RORRP030",109,0)
 I DSENT  D  S RC=1                  ;--- Update the record
"RTN","RORRP030",110,0)
 . S RORFDA(798,IENS,2)=DATE              ; INACTIVATION DATE
"RTN","RORRP030",111,0)
 . S RORFDA(798,IENS,2.1)=DUZ             ; INACTIVATED BY
"RTN","RORRP030",112,0)
 . S RORFDA(798,IENS,2.2)=REASON          ; REASON FOR INACTIVATION
"RTN","RORRP030",113,0)
 . S RORFDA(798,IENS,5)=1                 ; UPDATE LOCAL REGISTRY DATA
"RTN","RORRP030",114,0)
 E  S RORFDA(798,IENS,.01)="@",RC=9  ;--- Delete the record
"RTN","RORRP030",115,0)
 ;--- Update/Delete the registry record
"RTN","RORRP030",116,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORRP030",117,0)
 I $G(DIERR)  D  Q RC
"RTN","RORRP030",118,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,RORDFN,798,IENS)
"RTN","RORRP030",119,0)
 ;--- Send an alert to the user if inactivated patient has been
"RTN","RORRP030",120,0)
 ;--- added to the registry due to triggered selections rules
"RTN","RORRP030",121,0)
 S NODE=$$ROOT^DILFD(798.01,","_IENS,1)
"RTN","RORRP030",122,0)
 D:$O(@NODE@(0))>0 ALERT(RORDFN,7980000.013)
"RTN","RORRP030",123,0)
 Q RC
"RTN","RORRP030",124,0)
 ;
"RTN","RORRP030",125,0)
 ;***** REACTIVATES THE PATIENT
"RTN","RORRP030",126,0)
 ;
"RTN","RORRP030",127,0)
 ; IENS          IENS of the registry record
"RTN","RORRP030",128,0)
 ; REASON        IEN of the supporting evidence
"RTN","RORRP030",129,0)
 ; DATE          Reactivation date
"RTN","RORRP030",130,0)
 ;
"RTN","RORRP030",131,0)
 ; Return Values:
"RTN","RORRP030",132,0)
 ;        <0  Error code
"RTN","RORRP030",133,0)
 ;         2  The record has been reactivated
"RTN","RORRP030",134,0)
 ;
"RTN","RORRP030",135,0)
REACTIV(IENS,REASON,DATE) ;
"RTN","RORRP030",136,0)
 N NODE,RC,RORFDA,RORMSG
"RTN","RORRP030",137,0)
 S RORFDA(798,IENS,3)=3                   ; NEW PATIENT (REACTIVATED)
"RTN","RORRP030",138,0)
 S RORFDA(798,IENS,3.2)=REASON            ; SUPPORTING EVIDENCE
"RTN","RORRP030",139,0)
 S RORFDA(798,IENS,5)=1                   ; UPDATE LOCAL REGISTRY DATA
"RTN","RORRP030",140,0)
 S RORFDA(798,IENS,7)=DATE                ; REACTIVATION DATE
"RTN","RORRP030",141,0)
 S RORFDA(798,IENS,7.1)=DUZ               ; REACTIVATED BY
"RTN","RORRP030",142,0)
 ;--- Update the registry record
"RTN","RORRP030",143,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORRP030",144,0)
 I $G(DIERR)  D  Q RC
"RTN","RORRP030",145,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,RORDFN,798,IENS)
"RTN","RORRP030",146,0)
 ;--- Send an alert to the user if the reactivated patient has no
"RTN","RORRP030",147,0)
 ;--- selection rules that caused his/her addition to the registry
"RTN","RORRP030",148,0)
 S NODE=$$ROOT^DILFD(798.01,","_IENS,1)
"RTN","RORRP030",149,0)
 D:$O(@NODE@(0))'>0 ALERT(RORDFN,7980000.014)
"RTN","RORRP030",150,0)
 Q 2
"RTN","RORRP030",151,0)
 ;
"RTN","RORRP030",152,0)
 ;***** INACTIVATES/REACTIVATES THE PATIENT
"RTN","RORRP030",153,0)
 ; RPC: [ROR PATIENT (IN)ACTIVATE]
"RTN","RORRP030",154,0)
 ;
"RTN","RORRP030",155,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP030",156,0)
 ;               are returned to.
"RTN","RORRP030",157,0)
 ;
"RTN","RORRP030",158,0)
 ; REGIEN        Registry IEN
"RTN","RORRP030",159,0)
 ;
"RTN","RORRP030",160,0)
 ; RORDFN        IEN of the patient
"RTN","RORRP030",161,0)
 ;
"RTN","RORRP030",162,0)
 ; ACTION        Action to be performed
"RTN","RORRP030",163,0)
 ;                 I  Inactivate
"RTN","RORRP030",164,0)
 ;                 R  Reactivate
"RTN","RORRP030",165,0)
 ;
"RTN","RORRP030",166,0)
 ; REASON        Code of the reason for inactivation/reactivation
"RTN","RORRP030",167,0)
 ;
"RTN","RORRP030",168,0)
 ; Return Values:
"RTN","RORRP030",169,0)
 ;
"RTN","RORRP030",170,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP030",171,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP030",172,0)
 ; details).
"RTN","RORRP030",173,0)
 ;
"RTN","RORRP030",174,0)
 ; Otherwise, the following codes can be returned in the RESULTS(0):
"RTN","RORRP030",175,0)
 ;
"RTN","RORRP030",176,0)
 ;         0  Requested action is redundant
"RTN","RORRP030",177,0)
 ;         1  The record has been inactivated
"RTN","RORRP030",178,0)
 ;         2  The record has been reactivated
"RTN","RORRP030",179,0)
 ;         9  The record has been deleted
"RTN","RORRP030",180,0)
 ;
"RTN","RORRP030",181,0)
UPDATE(RESULTS,REGIEN,RORDFN,ACTION,REASON) ;
"RTN","RORRP030",182,0)
 N DATE,IENS,RC,RORMSG,RORREG,RSNIEN,TMP
"RTN","RORRP030",183,0)
 D CLEAR^RORERR("UPDATE^RORRP030",1)
"RTN","RORRP030",184,0)
 K RESULTS  S RESULTS(0)=0
"RTN","RORRP030",185,0)
 ;
"RTN","RORRP030",186,0)
 ;--- Get the registry description/name
"RTN","RORRP030",187,0)
 S TMP=$$REGNAME^RORUTL01(REGIEN)
"RTN","RORRP030",188,0)
 I TMP=""  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP030",189,0)
 . S RC=$$ERROR^RORERR(-1,,,RORDFN)
"RTN","RORRP030",190,0)
 S RORREG=REGIEN_U_$S($P(TMP,U,2)'="":$P(TMP,U,2),1:$P(TMP,U))
"RTN","RORRP030",191,0)
 ;
"RTN","RORRP030",192,0)
 ;--- Get IENS of the registry record
"RTN","RORRP030",193,0)
 S IENS=$$PRRIEN^RORUTL01(RORDFN,REGIEN)_","
"RTN","RORRP030",194,0)
 I IENS'>0  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP030",195,0)
 . S RC=$$ERROR^RORERR(-97,,,RORDFN,$P(RORREG,U,2))
"RTN","RORRP030",196,0)
 ;
"RTN","RORRP030",197,0)
 ;--- Get patient's status and check if the action is redundant
"RTN","RORRP030",198,0)
 S TMP=$$GET1^DIQ(798,IENS,8,,,"RORMSG")
"RTN","RORRP030",199,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP030",200,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,RORDFN,798,IENS)
"RTN","RORRP030",201,0)
 Q:$S(TMP:ACTION="R",1:ACTION="I")
"RTN","RORRP030",202,0)
 ;
"RTN","RORRP030",203,0)
 ;--- Get the IEN of inactivation reason/supporting evidence
"RTN","RORRP030",204,0)
 S TMP=$S(ACTION="I":1,ACTION="R":2,1:0)
"RTN","RORRP030",205,0)
 I TMP'>0  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP030",206,0)
 . S RC=$$ERROR^RORERR(-88,,,RORDFN,"ACTION",ACTION)
"RTN","RORRP030",207,0)
 S RSNIEN=$$ITEMIEN^RORUTL09(TMP,REGIEN,REASON)
"RTN","RORRP030",208,0)
 I RSNIEN'>0  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP030",209,0)
 . S RC=$$ERROR^RORERR(-88,,,RORDFN,"REASON",REASON)
"RTN","RORRP030",210,0)
 ;
"RTN","RORRP030",211,0)
 ;--- Inactivate/Reactivate the record
"RTN","RORRP030",212,0)
 S DATE=$$NOW^XLFDT,RESULTS(0)=0
"RTN","RORRP030",213,0)
 S:ACTION="I" RESULTS(0)=$$INACTIV(IENS,RSNIEN,DATE)
"RTN","RORRP030",214,0)
 S:ACTION="R" RESULTS(0)=$$REACTIV(IENS,RSNIEN,DATE)
"RTN","RORRP030",215,0)
 D:RESULTS(0)<0 RPCSTK^RORERR(.RESULTS,RESULTS)
"RTN","RORRP030",216,0)
 Q
"RTN","RORRP031")
0^104^B31717159
"RTN","RORRP031",1,0)
RORRP031 ;HCIOFO/SG - RPC: LOCAL LAB TEST NAMES ; 2/10/04 8:59am
"RTN","RORRP031",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP031",3,0)
 ;
"RTN","RORRP031",4,0)
 ; This routine uses the following IAs:
"RTN","RORRP031",5,0)
 ;
"RTN","RORRP031",6,0)
 ; #91           Access to the LABORATORY TEST file
"RTN","RORRP031",7,0)
 ;
"RTN","RORRP031",8,0)
 Q
"RTN","RORRP031",9,0)
 ;
"RTN","RORRP031",10,0)
 ;***** PROCESSES THE ERROR(S) AND UNLOCKS THE RECORD(S)
"RTN","RORRP031",11,0)
ERROR(RESULTS,RC) ;
"RTN","RORRP031",12,0)
 D RPCSTK^RORERR(.RESULTS,RC)
"RTN","RORRP031",13,0)
 D UNLOCK^RORLOCK(.RORLOCK)
"RTN","RORRP031",14,0)
 Q
"RTN","RORRP031",15,0)
 ;
"RTN","RORRP031",16,0)
 ;***** RETURNS THE LIST OF LOCAL TEST NAMES
"RTN","RORRP031",17,0)
 ; RPC: [ROR LIST LOCAL LAB TESTS]
"RTN","RORRP031",18,0)
 ;
"RTN","RORRP031",19,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP031",20,0)
 ;               are returned to.
"RTN","RORRP031",21,0)
 ;
"RTN","RORRP031",22,0)
 ; REGIEN        Registry IEN
"RTN","RORRP031",23,0)
 ;
"RTN","RORRP031",24,0)
 ; [GROUP]       Code of the Lab Group. If this parameter is
"RTN","RORRP031",25,0)
 ;               defined and greater than zero then only the tests
"RTN","RORRP031",26,0)
 ;               associated with this group will be returned.
"RTN","RORRP031",27,0)
 ;
"RTN","RORRP031",28,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP031",29,0)
 ;
"RTN","RORRP031",30,0)
 ; Return Values:
"RTN","RORRP031",31,0)
 ;
"RTN","RORRP031",32,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP031",33,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP031",34,0)
 ; details).
"RTN","RORRP031",35,0)
 ;
"RTN","RORRP031",36,0)
 ; Otherwise, number of lab tests is returned in the @RESULTS@(0)
"RTN","RORRP031",37,0)
 ; and the subsequent nodes of the global array contain the tests.
"RTN","RORRP031",38,0)
 ; 
"RTN","RORRP031",39,0)
 ; @RESULTS@(0)          Number of Local Tests
"RTN","RORRP031",40,0)
 ;
"RTN","RORRP031",41,0)
 ; @RESULTS@(i)          Test Descriptor
"RTN","RORRP031",42,0)
 ;                         ^01: IEN in the LOCAL TEST NAME multiple
"RTN","RORRP031",43,0)
 ;                         ^02: Local test name
"RTN","RORRP031",44,0)
 ;                         ^03: IEN of the local test
"RTN","RORRP031",45,0)
 ;                         ^04: Code of the Lab Group
"RTN","RORRP031",46,0)
 ;
"RTN","RORRP031",47,0)
LTLIST(RESULTS,REGIEN,GROUP) ;
"RTN","RORRP031",48,0)
 N GROUPIEN,IENS,IR,RC,RORERRDL,RORMSG,SCR,TMP
"RTN","RORRP031",49,0)
 D CLEAR^RORERR("LTLIST^RORRP031",1)
"RTN","RORRP031",50,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP031",51,0)
 ;
"RTN","RORRP031",52,0)
 ;--- Check the parameters
"RTN","RORRP031",53,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP031",54,0)
 . ;--- Registry IEN
"RTN","RORRP031",55,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP031",56,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP031",57,0)
 . S REGIEN=+REGIEN
"RTN","RORRP031",58,0)
 . ;--- Code of the Lab Group
"RTN","RORRP031",59,0)
 . S GROUP=+$G(GROUP)
"RTN","RORRP031",60,0)
 . S GROUPIEN=$S(GROUP>0:$$ITEMIEN^RORUTL09(3,REGIEN,GROUP),1:0)
"RTN","RORRP031",61,0)
 . I GROUPIEN<0  D  Q
"RTN","RORRP031",62,0)
 . . S RC=$$ERROR^RORERR(GROUPIEN)
"RTN","RORRP031",63,0)
 ;
"RTN","RORRP031",64,0)
 ;--- Compile the screen logic  (be careful with naked references)
"RTN","RORRP031",65,0)
 S SCR=""
"RTN","RORRP031",66,0)
 S:GROUPIEN>0 SCR=SCR_"I $P($G(^(0)),U,2)="_GROUPIEN_" "
"RTN","RORRP031",67,0)
 ;--- Get the list of tests
"RTN","RORRP031",68,0)
 S IENS=","_REGIEN_",",TMP="@;.01E;.01I;.02I"
"RTN","RORRP031",69,0)
 D LIST^DIC(798.128,IENS,TMP,"PU",,,,"B",SCR,,,"RORMSG")
"RTN","RORRP031",70,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP031",71,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.128,IENS)
"RTN","RORRP031",72,0)
 ;
"RTN","RORRP031",73,0)
 ;--- Replace the group IEN's with the group code(s)
"RTN","RORRP031",74,0)
 S (IR,RC)=0
"RTN","RORRP031",75,0)
 F  S IR=$O(@RESULTS@(IR))  Q:IR'>0  D  Q:RC<0
"RTN","RORRP031",76,0)
 . I GROUPIEN>0  S $P(@RESULTS@(IR,0),U,4)=GROUP  Q
"RTN","RORRP031",77,0)
 . S TMP=+$P(@RESULTS@(IR,0),U,4)
"RTN","RORRP031",78,0)
 . I TMP'>0  S $P(@RESULTS@(IR,0),U,4)=""  Q
"RTN","RORRP031",79,0)
 . S RC=$$ITEMCODE^RORUTL09(TMP)
"RTN","RORRP031",80,0)
 . S:RC>0 $P(@RESULTS@(IR,0),U,4)=RC
"RTN","RORRP031",81,0)
 I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP031",82,0)
 ;--- Success
"RTN","RORRP031",83,0)
 S TMP=+$G(^TMP("DILIST",$J,0))
"RTN","RORRP031",84,0)
 K ^TMP("DILIST",$J,0)  S @RESULTS@(0)=TMP
"RTN","RORRP031",85,0)
 Q
"RTN","RORRP031",86,0)
 ;
"RTN","RORRP031",87,0)
 ;***** UPDATES THE LIST OF LOCAL TEST NAMES
"RTN","RORRP031",88,0)
 ; RPC: [ROR UPDATE LOCAL LAB TESTS]
"RTN","RORRP031",89,0)
 ;
"RTN","RORRP031",90,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP031",91,0)
 ;               are returned to.
"RTN","RORRP031",92,0)
 ;
"RTN","RORRP031",93,0)
 ; REGIEN        Registry IEN
"RTN","RORRP031",94,0)
 ;
"RTN","RORRP031",95,0)
 ; GROUP         Code of the Lab Group.
"RTN","RORRP031",96,0)
 ;
"RTN","RORRP031",97,0)
 ;               If this parameter is equal to 0 then every item of
"RTN","RORRP031",98,0)
 ;               the LTLST must contain a valid group code. If an
"RTN","RORRP031",99,0)
 ;               empty list is passed into the RPC then ALL records
"RTN","RORRP031",100,0)
 ;               will be deleted from the LOCAL TEST NAME multiple.
"RTN","RORRP031",101,0)
 ;
"RTN","RORRP031",102,0)
 ;               If this parameter is not zero then it should contain 
"RTN","RORRP031",103,0)
 ;               a valid group code. All records of the LTLST will be 
"RTN","RORRP031",104,0)
 ;               associated with this group. If an empty list is
"RTN","RORRP031",105,0)
 ;               passed into the RPC then only records associated
"RTN","RORRP031",106,0)
 ;               with this group will be deleted from the multiple.
"RTN","RORRP031",107,0)
 ;
"RTN","RORRP031",108,0)
 ; .LTLST(       Reference to a local variable that contains
"RTN","RORRP031",109,0)
 ;               a list of local laboratory tests
"RTN","RORRP031",110,0)
 ;
"RTN","RORRP031",111,0)
 ;   i)          Test Descriptor
"RTN","RORRP031",112,0)
 ;                 ^01: Ignored
"RTN","RORRP031",113,0)
 ;                 ^02: Ignored
"RTN","RORRP031",114,0)
 ;                 ^03: IEN of the local test
"RTN","RORRP031",115,0)
 ;                 ^04: Code of the Lab Group
"RTN","RORRP031",116,0)
 ;                      (see also the GROUP parameter)
"RTN","RORRP031",117,0)
 ;
"RTN","RORRP031",118,0)
 ; Return Values:
"RTN","RORRP031",119,0)
 ;
"RTN","RORRP031",120,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP031",121,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP031",122,0)
 ; details).
"RTN","RORRP031",123,0)
 ;
"RTN","RORRP031",124,0)
 ; Otherwise, zero is returned in the RESULTS(0).
"RTN","RORRP031",125,0)
 ;
"RTN","RORRP031",126,0)
LTLUPD(RESULTS,REGIEN,GROUP,LTLST) ;
"RTN","RORRP031",127,0)
 N DA,DIK,ECNT,GROUPIEN,GRPIEN,IENS,IR,LTL,RC,ROOT,RORERRDL,RORFDA,RORLOCK,RORMSG,TMP,TSTIEN
"RTN","RORRP031",128,0)
 D CLEAR^RORERR("LTLUPD^RORRP031",1)  K RESULTS
"RTN","RORRP031",129,0)
 S ECNT=0
"RTN","RORRP031",130,0)
 ;
"RTN","RORRP031",131,0)
 ;--- Check the parameters
"RTN","RORRP031",132,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP031",133,0)
 . ;--- Registry IEN
"RTN","RORRP031",134,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP031",135,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP031",136,0)
 . S REGIEN=+REGIEN
"RTN","RORRP031",137,0)
 . ;--- Code of the Lab Group
"RTN","RORRP031",138,0)
 . S GROUPIEN=$S($G(GROUP)>0:$$ITEMIEN^RORUTL09(3,REGIEN,GROUP),1:0)
"RTN","RORRP031",139,0)
 . I GROUPIEN<0  D  Q
"RTN","RORRP031",140,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"GROUP",$G(GROUP))
"RTN","RORRP031",141,0)
 . S GROUP=+$G(GROUP)
"RTN","RORRP031",142,0)
 ;
"RTN","RORRP031",143,0)
 ;--- Lock the LOCAL TEST NAME multiple
"RTN","RORRP031",144,0)
 S IENS=","_REGIEN_","
"RTN","RORRP031",145,0)
 S RC=$$LOCK^RORLOCK(798.128,IENS)
"RTN","RORRP031",146,0)
 I RC  D:RC>0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP031",147,0)
 . S RC=$$ERROR^RORERR(-11,,,,"the LOCAL TEST NAME multiple")
"RTN","RORRP031",148,0)
 ;---
"RTN","RORRP031",149,0)
 S RORLOCK(798.128,IENS)=""
"RTN","RORRP031",150,0)
 S ROOT=$$ROOT^DILFD(798.128,IENS,1)
"RTN","RORRP031",151,0)
 ;
"RTN","RORRP031",152,0)
 ;--- Prepare the data
"RTN","RORRP031",153,0)
 S IR="",RC=0
"RTN","RORRP031",154,0)
 F  S IR=$O(LTLST(IR))  Q:IR=""  D  Q:RC<0
"RTN","RORRP031",155,0)
 . ;--- Check if the test is defined in the LABORATORY TEST file
"RTN","RORRP031",156,0)
 . S TSTIEN=+$P(LTLST(IR),U,3)
"RTN","RORRP031",157,0)
 . Q:$$FIND1^DIC(60,,,"`"_TSTIEN,,,"RORMSG")'>0
"RTN","RORRP031",158,0)
 . ;--- Assign the default Group IEN (if the GROUP is provided)
"RTN","RORRP031",159,0)
 . I GROUPIEN>0  S LTL(GROUPIEN,TSTIEN)=""  Q
"RTN","RORRP031",160,0)
 . ;--- Get IEN of the Lab Group
"RTN","RORRP031",161,0)
 . S TMP=+$P(LTLST(IR),U,4)
"RTN","RORRP031",162,0)
 . S GRPIEN=$$ITEMIEN^RORUTL09(3,REGIEN,TMP)
"RTN","RORRP031",163,0)
 . I GRPIEN'>0  D:GRPIEN<0  Q
"RTN","RORRP031",164,0)
 . . S RC=$$ERROR^RORERR(GRPIEN)
"RTN","RORRP031",165,0)
 . ;--- Create the reference
"RTN","RORRP031",166,0)
 . S LTL(GRPIEN,TSTIEN)=""
"RTN","RORRP031",167,0)
 I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP031",168,0)
 ;
"RTN","RORRP031",169,0)
 ;--- Mark the groups to be cleared
"RTN","RORRP031",170,0)
 I GROUPIEN'>0  S GRPIEN=""  D
"RTN","RORRP031",171,0)
 . F  S GRPIEN=$O(@ROOT@("G",GRPIEN))  Q:GRPIEN=""  S LTL(GRPIEN)=""
"RTN","RORRP031",172,0)
 E  S LTL(GROUPIEN)=""
"RTN","RORRP031",173,0)
 ;
"RTN","RORRP031",174,0)
 ;--- Update the multiple
"RTN","RORRP031",175,0)
 S IENS="?+1,"_REGIEN_",",ECNT=0
"RTN","RORRP031",176,0)
 S GRPIEN=""
"RTN","RORRP031",177,0)
 F  S GRPIEN=$O(LTL(GRPIEN))  Q:GRPIEN=""  D
"RTN","RORRP031",178,0)
 . ;--- Delete the old records
"RTN","RORRP031",179,0)
 . S DIK=$$OREF^DILF(ROOT),DA(1)=REGIEN
"RTN","RORRP031",180,0)
 . S TSTIEN=""
"RTN","RORRP031",181,0)
 . F  S TSTIEN=$O(@ROOT@("G",GRPIEN,TSTIEN))  Q:TSTIEN=""  D
"RTN","RORRP031",182,0)
 . . S DA=""
"RTN","RORRP031",183,0)
 . . F  S DA=$O(@ROOT@("G",GRPIEN,TSTIEN,DA))  Q:DA=""  D ^DIK
"RTN","RORRP031",184,0)
 . ;--- Store the new records
"RTN","RORRP031",185,0)
 . S TSTIEN=""
"RTN","RORRP031",186,0)
 . F  S TSTIEN=$O(LTL(GRPIEN,TSTIEN))  Q:TSTIEN=""  D
"RTN","RORRP031",187,0)
 . . S RORFDA(798.128,IENS,.01)=TSTIEN
"RTN","RORRP031",188,0)
 . . S RORFDA(798.128,IENS,.02)=GRPIEN
"RTN","RORRP031",189,0)
 . . D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORRP031",190,0)
 . . I $G(DIERR)  D  S ECNT=ECNT+1  Q
"RTN","RORRP031",191,0)
 . . . D DBS^RORERR("RORMSG",-9,,,798.128,IENS)
"RTN","RORRP031",192,0)
 ;
"RTN","RORRP031",193,0)
 ;--- Unlock the multiple and check for errors
"RTN","RORRP031",194,0)
 D UNLOCK^RORLOCK(798.128,","_REGIEN_",")
"RTN","RORRP031",195,0)
 I ECNT>0  D RPCSTK^RORERR(.RESULTS,-9)  Q
"RTN","RORRP031",196,0)
 ;--- Success
"RTN","RORRP031",197,0)
 S RESULTS(0)=0
"RTN","RORRP031",198,0)
 Q
"RTN","RORRP032")
0^105^B31692650
"RTN","RORRP032",1,0)
RORRP032 ;HCIOFO/SG - RPC: LOCAL DRUG NAMES ; 2/10/04 8:59am
"RTN","RORRP032",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP032",3,0)
 ;
"RTN","RORRP032",4,0)
 ; This routine uses the following IAs:
"RTN","RORRP032",5,0)
 ;
"RTN","RORRP032",6,0)
 ; #221-A       Access to the DRUG file
"RTN","RORRP032",7,0)
 ;
"RTN","RORRP032",8,0)
 Q
"RTN","RORRP032",9,0)
 ;
"RTN","RORRP032",10,0)
 ;***** PROCESSES THE ERROR(S) AND UNLOCKS THE RECORD(S)
"RTN","RORRP032",11,0)
ERROR(RESULTS,RC) ;
"RTN","RORRP032",12,0)
 D RPCSTK^RORERR(.RESULTS,RC)
"RTN","RORRP032",13,0)
 D UNLOCK^RORLOCK(.RORLOCK)
"RTN","RORRP032",14,0)
 Q
"RTN","RORRP032",15,0)
 ;
"RTN","RORRP032",16,0)
 ;***** RETURNS THE LIST OF LOCAL DRUG NAMES
"RTN","RORRP032",17,0)
 ; RPC: [ROR LIST LOCAL DRUGS]
"RTN","RORRP032",18,0)
 ;
"RTN","RORRP032",19,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP032",20,0)
 ;               are returned to.
"RTN","RORRP032",21,0)
 ;
"RTN","RORRP032",22,0)
 ; REGIEN        Registry IEN
"RTN","RORRP032",23,0)
 ;
"RTN","RORRP032",24,0)
 ; [GROUP]       Code of the Drug Group. If this parameter is
"RTN","RORRP032",25,0)
 ;               defined and greater than zero then only the drugs
"RTN","RORRP032",26,0)
 ;               associated with this group will be returned.
"RTN","RORRP032",27,0)
 ;
"RTN","RORRP032",28,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP032",29,0)
 ;
"RTN","RORRP032",30,0)
 ; Return Values:
"RTN","RORRP032",31,0)
 ;
"RTN","RORRP032",32,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP032",33,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP032",34,0)
 ; details).
"RTN","RORRP032",35,0)
 ;
"RTN","RORRP032",36,0)
 ; Otherwise, number of drugs is returned in the @RESULTS@(0) and
"RTN","RORRP032",37,0)
 ; the subsequent nodes of the global array contain the drugs.
"RTN","RORRP032",38,0)
 ; 
"RTN","RORRP032",39,0)
 ; @RESULTS@(0)          Number of Local Drugs
"RTN","RORRP032",40,0)
 ;
"RTN","RORRP032",41,0)
 ; @RESULTS@(i)          Drug Descriptor
"RTN","RORRP032",42,0)
 ;                         ^01: IEN in the LOCAL DRUG NAME multiple
"RTN","RORRP032",43,0)
 ;                         ^02: Local drug name
"RTN","RORRP032",44,0)
 ;                         ^03: IEN of the local drug
"RTN","RORRP032",45,0)
 ;                         ^04: Code of the Drug Group
"RTN","RORRP032",46,0)
 ;
"RTN","RORRP032",47,0)
LDLIST(RESULTS,REGIEN,GROUP) ;
"RTN","RORRP032",48,0)
 N GROUPIEN,IENS,IR,RC,RORERRDL,RORMSG,SCR,TMP
"RTN","RORRP032",49,0)
 D CLEAR^RORERR("LDLIST^RORRP032",1)
"RTN","RORRP032",50,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP032",51,0)
 ;
"RTN","RORRP032",52,0)
 ;--- Check the parameters
"RTN","RORRP032",53,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP032",54,0)
 . ;--- Registry IEN
"RTN","RORRP032",55,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP032",56,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP032",57,0)
 . S REGIEN=+REGIEN
"RTN","RORRP032",58,0)
 . ;--- Code of the Drug Group
"RTN","RORRP032",59,0)
 . S GROUP=+$G(GROUP)
"RTN","RORRP032",60,0)
 . S GROUPIEN=$S(GROUP>0:$$ITEMIEN^RORUTL09(4,REGIEN,GROUP),1:0)
"RTN","RORRP032",61,0)
 . I GROUPIEN<0  D  Q
"RTN","RORRP032",62,0)
 . . S RC=$$ERROR^RORERR(GROUPIEN)
"RTN","RORRP032",63,0)
 ;
"RTN","RORRP032",64,0)
 ;--- Compile the screen logic  (be careful with naked references)
"RTN","RORRP032",65,0)
 S SCR=""
"RTN","RORRP032",66,0)
 S:GROUPIEN>0 SCR=SCR_"I $P($G(^(0)),U,2)="_GROUPIEN_" "
"RTN","RORRP032",67,0)
 ;--- Get the list of drugs
"RTN","RORRP032",68,0)
 S IENS=","_REGIEN_",",TMP="@;.01E;.01I;.02I"
"RTN","RORRP032",69,0)
 D LIST^DIC(798.129,IENS,TMP,"PU",,,,"B",SCR,,,"RORMSG")
"RTN","RORRP032",70,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP032",71,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.129,IENS)
"RTN","RORRP032",72,0)
 ;
"RTN","RORRP032",73,0)
 ;--- Replace the group IEN's with the group code(s)
"RTN","RORRP032",74,0)
 S (IR,RC)=0
"RTN","RORRP032",75,0)
 F  S IR=$O(@RESULTS@(IR))  Q:IR'>0  D  Q:RC<0
"RTN","RORRP032",76,0)
 . I GROUPIEN>0  S $P(@RESULTS@(IR,0),U,4)=GROUP  Q
"RTN","RORRP032",77,0)
 . S TMP=+$P(@RESULTS@(IR,0),U,4)
"RTN","RORRP032",78,0)
 . I TMP'>0  S $P(@RESULTS@(IR,0),U,4)=""  Q
"RTN","RORRP032",79,0)
 . S RC=$$ITEMCODE^RORUTL09(TMP)
"RTN","RORRP032",80,0)
 . S:RC>0 $P(@RESULTS@(IR,0),U,4)=RC
"RTN","RORRP032",81,0)
 I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP032",82,0)
 ;--- Success
"RTN","RORRP032",83,0)
 S TMP=+$G(^TMP("DILIST",$J,0))
"RTN","RORRP032",84,0)
 K ^TMP("DILIST",$J,0)  S @RESULTS@(0)=TMP
"RTN","RORRP032",85,0)
 Q
"RTN","RORRP032",86,0)
 ;
"RTN","RORRP032",87,0)
 ;***** UPDATES THE LIST OF LOCAL DRUG NAMES
"RTN","RORRP032",88,0)
 ; RPC: [ROR UPDATE LOCAL DRUGS]
"RTN","RORRP032",89,0)
 ;
"RTN","RORRP032",90,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP032",91,0)
 ;               are returned to.
"RTN","RORRP032",92,0)
 ;
"RTN","RORRP032",93,0)
 ; REGIEN        Registry IEN
"RTN","RORRP032",94,0)
 ;
"RTN","RORRP032",95,0)
 ; GROUP         Code of the Drug Group.
"RTN","RORRP032",96,0)
 ;
"RTN","RORRP032",97,0)
 ;               If this parameter is equal to 0 then every item of
"RTN","RORRP032",98,0)
 ;               the LDLST must contain a valid group code. If an
"RTN","RORRP032",99,0)
 ;               empty list is passed into the RPC then ALL records
"RTN","RORRP032",100,0)
 ;               will be deleted from the LOCAL DRUG NAME multiple.
"RTN","RORRP032",101,0)
 ;
"RTN","RORRP032",102,0)
 ;               If this parameter is not zero then it should contain 
"RTN","RORRP032",103,0)
 ;               a valid group code. All records of the LDLST will be
"RTN","RORRP032",104,0)
 ;               associated with this group. If an empty list is
"RTN","RORRP032",105,0)
 ;               passed into the RPC then only records associated
"RTN","RORRP032",106,0)
 ;               with this group will be deleted from the multiple.
"RTN","RORRP032",107,0)
 ;
"RTN","RORRP032",108,0)
 ; .LDLST(       Reference to a local variable that contains
"RTN","RORRP032",109,0)
 ;               a list of local drugs
"RTN","RORRP032",110,0)
 ;
"RTN","RORRP032",111,0)
 ;   i)          Test Descriptor
"RTN","RORRP032",112,0)
 ;                 ^01: Ignored
"RTN","RORRP032",113,0)
 ;                 ^02: Ignored
"RTN","RORRP032",114,0)
 ;                 ^03: IEN of the local drug
"RTN","RORRP032",115,0)
 ;                 ^04: Code of the Drug Group
"RTN","RORRP032",116,0)
 ;                      (see also the GROUP parameter)
"RTN","RORRP032",117,0)
 ;
"RTN","RORRP032",118,0)
 ; Return Values:
"RTN","RORRP032",119,0)
 ;
"RTN","RORRP032",120,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP032",121,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP032",122,0)
 ; details).
"RTN","RORRP032",123,0)
 ;
"RTN","RORRP032",124,0)
 ; Otherwise, zero is returned in the RESULTS(0).
"RTN","RORRP032",125,0)
 ;
"RTN","RORRP032",126,0)
LDLUPD(RESULTS,REGIEN,GROUP,LDLST) ;
"RTN","RORRP032",127,0)
 N DA,DIK,DRUGIEN,ECNT,GROUPIEN,GRPIEN,IENS,IR,LDL,RC,ROOT,RORERRDL,RORFDA,RORLOCK,RORMSG,TMP
"RTN","RORRP032",128,0)
 D CLEAR^RORERR("LDLUPD^RORRP032",1)  K RESULTS
"RTN","RORRP032",129,0)
 S ECNT=0
"RTN","RORRP032",130,0)
 ;
"RTN","RORRP032",131,0)
 ;--- Check the parameters
"RTN","RORRP032",132,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP032",133,0)
 . ;--- Registry IEN
"RTN","RORRP032",134,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP032",135,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP032",136,0)
 . S REGIEN=+REGIEN
"RTN","RORRP032",137,0)
 . ;--- Code of the Drug Group
"RTN","RORRP032",138,0)
 . S GROUPIEN=$S($G(GROUP)>0:$$ITEMIEN^RORUTL09(4,REGIEN,GROUP),1:0)
"RTN","RORRP032",139,0)
 . I GROUPIEN<0  D  Q
"RTN","RORRP032",140,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"GROUP",$G(GROUP))
"RTN","RORRP032",141,0)
 . S GROUP=+$G(GROUP)
"RTN","RORRP032",142,0)
 ;
"RTN","RORRP032",143,0)
 ;--- Lock the LOCAL DRUG NAME multiple
"RTN","RORRP032",144,0)
 S IENS=","_REGIEN_","
"RTN","RORRP032",145,0)
 S RC=$$LOCK^RORLOCK(798.129,IENS)
"RTN","RORRP032",146,0)
 I RC  D:RC>0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP032",147,0)
 . S RC=$$ERROR^RORERR(-11,,,,"the LOCAL DRUG NAME multiple")
"RTN","RORRP032",148,0)
 ;---
"RTN","RORRP032",149,0)
 S RORLOCK(798.129,IENS)=""
"RTN","RORRP032",150,0)
 S ROOT=$$ROOT^DILFD(798.129,IENS,1)
"RTN","RORRP032",151,0)
 ;
"RTN","RORRP032",152,0)
 ;--- Prepare the data
"RTN","RORRP032",153,0)
 S IR="",RC=0
"RTN","RORRP032",154,0)
 F  S IR=$O(LDLST(IR))  Q:IR=""  D  Q:RC<0
"RTN","RORRP032",155,0)
 . ;--- Check if the drug is defined in the DRUG file
"RTN","RORRP032",156,0)
 . S DRUGIEN=+$P(LDLST(IR),U,3)
"RTN","RORRP032",157,0)
 . Q:$$FIND1^DIC(50,,,"`"_DRUGIEN,,,"RORMSG")'>0
"RTN","RORRP032",158,0)
 . ;--- Assign the default Group IEN (if the GROUP is provided)
"RTN","RORRP032",159,0)
 . I GROUPIEN>0  S LDL(GROUPIEN,DRUGIEN)=""  Q
"RTN","RORRP032",160,0)
 . ;--- Get IEN of the Drug Group
"RTN","RORRP032",161,0)
 . S TMP=+$P(LDLST(IR),U,4)
"RTN","RORRP032",162,0)
 . S GRPIEN=$$ITEMIEN^RORUTL09(4,REGIEN,TMP)
"RTN","RORRP032",163,0)
 . I GRPIEN'>0  D:GRPIEN<0  Q
"RTN","RORRP032",164,0)
 . . S RC=$$ERROR^RORERR(GRPIEN)
"RTN","RORRP032",165,0)
 . ;--- Create the reference
"RTN","RORRP032",166,0)
 . S LDL(GRPIEN,DRUGIEN)=""
"RTN","RORRP032",167,0)
 I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP032",168,0)
 ;---
"RTN","RORRP032",169,0)
 I GROUPIEN'>0  S GRPIEN=""  D
"RTN","RORRP032",170,0)
 . F  S GRPIEN=$O(@ROOT@("G",GRPIEN))  Q:GRPIEN=""  S LDL(GRPIEN)=""
"RTN","RORRP032",171,0)
 E  S LDL(GROUPIEN)=""
"RTN","RORRP032",172,0)
 ;
"RTN","RORRP032",173,0)
 ;--- Update the multiple
"RTN","RORRP032",174,0)
 S IENS="?+1,"_REGIEN_",",ECNT=0
"RTN","RORRP032",175,0)
 S GRPIEN=""
"RTN","RORRP032",176,0)
 F  S GRPIEN=$O(LDL(GRPIEN))  Q:GRPIEN=""  D
"RTN","RORRP032",177,0)
 . ;--- Delete the old records
"RTN","RORRP032",178,0)
 . S DIK=$$OREF^DILF(ROOT),DA(1)=REGIEN
"RTN","RORRP032",179,0)
 . S DRUGIEN=""
"RTN","RORRP032",180,0)
 . F  S DRUGIEN=$O(@ROOT@("G",GRPIEN,DRUGIEN))  Q:DRUGIEN=""  D
"RTN","RORRP032",181,0)
 . . S DA=""
"RTN","RORRP032",182,0)
 . . F  S DA=$O(@ROOT@("G",GRPIEN,DRUGIEN,DA))  Q:DA=""  D ^DIK
"RTN","RORRP032",183,0)
 . ;--- Store the new records
"RTN","RORRP032",184,0)
 . S DRUGIEN=""
"RTN","RORRP032",185,0)
 . F  S DRUGIEN=$O(LDL(GRPIEN,DRUGIEN))  Q:DRUGIEN=""  D
"RTN","RORRP032",186,0)
 . . S RORFDA(798.129,IENS,.01)=DRUGIEN
"RTN","RORRP032",187,0)
 . . S RORFDA(798.129,IENS,.02)=GRPIEN
"RTN","RORRP032",188,0)
 . . D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORRP032",189,0)
 . . I $G(DIERR)  D  S ECNT=ECNT+1  Q
"RTN","RORRP032",190,0)
 . . . D DBS^RORERR("RORMSG",-9,,,798.129,IENS)
"RTN","RORRP032",191,0)
 ;
"RTN","RORRP032",192,0)
 ;--- Unlock the multiple and check for errors
"RTN","RORRP032",193,0)
 D UNLOCK^RORLOCK(798.129,","_REGIEN_",")
"RTN","RORRP032",194,0)
 I ECNT>0  D RPCSTK^RORERR(.RESULTS,-9)  Q
"RTN","RORRP032",195,0)
 ;--- Success
"RTN","RORRP032",196,0)
 S RESULTS(0)=0
"RTN","RORRP032",197,0)
 Q
"RTN","RORRP033")
0^106^B30175350
"RTN","RORRP033",1,0)
RORRP033 ;HCIOFO/SG - RPC: ICR PATIENT LOAD ; 12/8/03 2:14pm
"RTN","RORRP033",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP033",3,0)
 ;
"RTN","RORRP033",4,0)
 Q
"RTN","RORRP033",5,0)
 ;
"RTN","RORRP033",6,0)
 ;***** PROCESSES THE ERROR(S) AND UNLOCKS THE RECORDS
"RTN","RORRP033",7,0)
ERROR(RESULTS,RC) ;
"RTN","RORRP033",8,0)
 D RPCSTK^RORERR(.RESULTS,RC)
"RTN","RORRP033",9,0)
 D UNLOCK^RORLOCK(.RORLOCK)
"RTN","RORRP033",10,0)
 Q
"RTN","RORRP033",11,0)
 ;
"RTN","RORRP033",12,0)
 ;***** LOADS THE PATIENT'S DATA FOR EDITING
"RTN","RORRP033",13,0)
 ; RPC: [RORICR PATIENT LOAD]
"RTN","RORRP033",14,0)
 ;
"RTN","RORRP033",15,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP033",16,0)
 ;               are returned to.
"RTN","RORRP033",17,0)
 ;
"RTN","RORRP033",18,0)
 ; REGIEN        Registry IEN
"RTN","RORRP033",19,0)
 ;
"RTN","RORRP033",20,0)
 ; PATIEN        IEN of the registry patient (DFN)
"RTN","RORRP033",21,0)
 ;
"RTN","RORRP033",22,0)
 ; [LOCK]        Lock the registry record before loading the data and
"RTN","RORRP033",23,0)
 ;               leave it locked.
"RTN","RORRP033",24,0)
 ;
"RTN","RORRP033",25,0)
 ; The ^TMP("RORRP033",$J) global node is used by the procedure.
"RTN","RORRP033",26,0)
 ;
"RTN","RORRP033",27,0)
 ; Return Values:
"RTN","RORRP033",28,0)
 ;
"RTN","RORRP033",29,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP033",30,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP033",31,0)
 ; details).
"RTN","RORRP033",32,0)
 ;
"RTN","RORRP033",33,0)
 ; If locking was requested (see the LOCK parameter) and the record
"RTN","RORRP033",34,0)
 ; could not be locked then the first "^"-piece of the @RESULTS@(0)
"RTN","RORRP033",35,0)
 ; would be greater than 0. The @RESULTS@(0) would contain the lock
"RTN","RORRP033",36,0)
 ; descriptor and subsequent nodes of the global array would contain
"RTN","RORRP033",37,0)
 ; the data (see below). The lock descriptor contains information
"RTN","RORRP033",38,0)
 ; about the propcess, which owns the most recent lock of the record.
"RTN","RORRP033",39,0)
 ; The "O" flag (read-only) would also be added to the 15th field
"RTN","RORRP033",40,0)
 ; of the "PRD" segment.
"RTN","RORRP033",41,0)
 ;
"RTN","RORRP033",42,0)
 ; @RESULTS@(0)          Lock Descriptor
"RTN","RORRP033",43,0)
 ;                         ^01: Date/Time (FileMan)
"RTN","RORRP033",44,0)
 ;                         ^02: User/Process name
"RTN","RORRP033",45,0)
 ;                         ^03: User IEN (DUZ)
"RTN","RORRP033",46,0)
 ;                         ^04: $JOB
"RTN","RORRP033",47,0)
 ;                         ^05: Task number
"RTN","RORRP033",48,0)
 ;
"RTN","RORRP033",49,0)
 ; THE DATA ARE LOADED ONLY FOR VIEWING PURPOSES (READ-ONLY)!
"RTN","RORRP033",50,0)
 ;
"RTN","RORRP033",51,0)
 ; Otherwise, zero is returned in the @RESULTS@(0) and the
"RTN","RORRP033",52,0)
 ; subsequent nodes of the global array contain the patient's data.
"RTN","RORRP033",53,0)
 ; 
"RTN","RORRP033",54,0)
 ; @RESULTS@(0)          0
"RTN","RORRP033",55,0)
 ;
"RTN","RORRP033",56,0)
 ; @RESULTS@(i)          Demographic data
"RTN","RORRP033",57,0)
 ;                         ^01: "DEM"
"RTN","RORRP033",58,0)
 ;                         ^02: ""
"RTN","RORRP033",59,0)
 ;                         ...  See description of the ROR PATIENT
"RTN","RORRP033",60,0)
 ;                              GET DATA remote procedure
"RTN","RORRP033",61,0)
 ;
"RTN","RORRP033",62,0)
 ; @RESULTS@(i)          Basic registry data
"RTN","RORRP033",63,0)
 ;                         ^01: "PRD"
"RTN","RORRP033",64,0)
 ;                         ^02: ""
"RTN","RORRP033",65,0)
 ;                         ...  See description of the ROR PATIENT
"RTN","RORRP033",66,0)
 ;                              GET DATA remote procedure
"RTN","RORRP033",67,0)
 ;
"RTN","RORRP033",68,0)
 ; @RESULTS@(i)          Patient's history (risk factors)
"RTN","RORRP033",69,0)
 ;                         ^01: "PH"
"RTN","RORRP033",70,0)
 ;                         ^02: ""
"RTN","RORRP033",71,0)
 ;                         ...  See description of the RORICR
"RTN","RORRP033",72,0)
 ;                              CDC LOAD remote procedure
"RTN","RORRP033",73,0)
 ;
"RTN","RORRP033",74,0)
 ; @RESULTS@(i)          CD4 and Viral Load results
"RTN","RORRP033",75,0)
 ;                         ^01: "LTR"
"RTN","RORRP033",76,0)
 ;                         ^02: Result IEN (inverted date/time)
"RTN","RORRP033",77,0)
 ;                         ^03: Date/time of the test (FileMan)
"RTN","RORRP033",78,0)
 ;                         ^04: Result
"RTN","RORRP033",79,0)
 ;                         ^05: Test IEN (in file #60)
"RTN","RORRP033",80,0)
 ;                         ^06: Test name
"RTN","RORRP033",81,0)
 ;                         ^07: Code of the group
"RTN","RORRP033",82,0)
 ;                         ^08: Group name
"RTN","RORRP033",83,0)
 ;
"RTN","RORRP033",84,0)
 ; @RESULTS@(i)          Registry data
"RTN","RORRP033",85,0)
 ;                         ^01: "ICR"
"RTN","RORRP033",86,0)
 ;                         ^02: ""
"RTN","RORRP033",87,0)
 ;                         ^03: Clinical AIDS (0/1)
"RTN","RORRP033",88,0)
 ;                         ^04: Date of Clinical AIDS (FileMan)
"RTN","RORRP033",89,0)
 ;                         ^05: Code of the Supporting Evidence
"RTN","RORRP033",90,0)
 ;                         ^06: Date of last CD4
"RTN","RORRP033",91,0)
 ;                         ^07: Last CD4
"RTN","RORRP033",92,0)
 ;                         ^08: Date of lowest CD4
"RTN","RORRP033",93,0)
 ;                         ^09: Lowest CD4
"RTN","RORRP033",94,0)
 ;                         ^10: Date of lowest CD4 %
"RTN","RORRP033",95,0)
 ;                         ^11: Lowest CD4 %
"RTN","RORRP033",96,0)
 ;
"RTN","RORRP033",97,0)
LOAD(RESULTS,REGIEN,PATIEN,LOCK) ;
"RTN","RORRP033",98,0)
 N I,ICRBUF,IENS,LOCKRC,RC,RESPTR,RORBUF,RORERRDL,RORLOCK,RORMSG,TMP
"RTN","RORRP033",99,0)
 D CLEAR^RORERR("LOAD^RORRP033",1)
"RTN","RORRP033",100,0)
 K RESULTS  S RESULTS=$NA(^TMP("RORRP033",$J))  K @RESULTS
"RTN","RORRP033",101,0)
 S ICRBUF="ICR",LOCKRC=0
"RTN","RORRP033",102,0)
 ;--- Check the parameters
"RTN","RORRP033",103,0)
 S RC=0  D  I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP033",104,0)
 . ;--- Registry IEN
"RTN","RORRP033",105,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP033",106,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP033",107,0)
 . S REGIEN=+REGIEN
"RTN","RORRP033",108,0)
 . ;--- Patient IEN
"RTN","RORRP033",109,0)
 . I $G(PATIEN)'>0  D  Q
"RTN","RORRP033",110,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"PATIEN",$G(PATIEN))
"RTN","RORRP033",111,0)
 . S PATIEN=+PATIEN
"RTN","RORRP033",112,0)
 ;
"RTN","RORRP033",113,0)
 ;--- Get the IENS of the registry record
"RTN","RORRP033",114,0)
 S IENS=$$PRRIEN^RORUTL01(PATIEN,REGIEN)_","
"RTN","RORRP033",115,0)
 ;
"RTN","RORRP033",116,0)
 ;--- Lock the records
"RTN","RORRP033",117,0)
 I $G(LOCK),IENS>0  D  I LOCKRC<0  D ERROR(.RESULTS,+LOCKRC)  Q
"RTN","RORRP033",118,0)
 . S RORLOCK(798,IENS)=""
"RTN","RORRP033",119,0)
 . S RORLOCK(799.4,IENS)=""
"RTN","RORRP033",120,0)
 . S LOCKRC=$$LOCK^RORLOCK(.RORLOCK)
"RTN","RORRP033",121,0)
 ;
"RTN","RORRP033",122,0)
 ;--- Get the patient's data
"RTN","RORRP033",123,0)
 D GETPTDAT^RORRP021(.RORBUF,PATIEN,,REGIEN)
"RTN","RORRP033",124,0)
 I $G(RORBUF(0))<0  D ERROR(.RESULTS,+RORBUF(0))  Q
"RTN","RORRP033",125,0)
 ;---
"RTN","RORRP033",126,0)
 S I=""
"RTN","RORRP033",127,0)
 F  S I=$O(RORBUF(I))  Q:I=""  Q:$P(RORBUF(I),U)="PRD"
"RTN","RORRP033",128,0)
 D:I'=""
"RTN","RORRP033",129,0)
 . S $P(ICRBUF,U,5)=$S(I:$P(RORBUF(I),U,17),1:"")  ; Support. Evidence
"RTN","RORRP033",130,0)
 . S TMP=$P(RORBUF(I),U,15)
"RTN","RORRP033",131,0)
 . I TMP'["O"  S:LOCKRC $P(RORBUF(I),U,15)=TMP_"O" ; Read Only
"RTN","RORRP033",132,0)
 . E  D UNLOCK^RORLOCK(.RORLOCK)  S LOCKRC=0
"RTN","RORRP033",133,0)
 ;---
"RTN","RORRP033",134,0)
 M @RESULTS=RORBUF  S RESPTR=$O(RORBUF(""),-1)
"RTN","RORRP033",135,0)
 K RORBUF
"RTN","RORRP033",136,0)
 ;
"RTN","RORRP033",137,0)
 ;--- Load the ICR data
"RTN","RORRP033",138,0)
 I IENS>0  S RC=0  D  I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP033",139,0)
 . Q:$D(^RORDATA(799.4,+IENS))<10
"RTN","RORRP033",140,0)
 . ;--- Patient's history (risk factors)
"RTN","RORRP033",141,0)
 . S RORBUF="PH"
"RTN","RORRP033",142,0)
 . S RC=$$LOAD^RORRP026(IENS,"PH^RORRP026",.RORBUF)  Q:RC<0
"RTN","RORRP033",143,0)
 . S RESPTR=RESPTR+1,@RESULTS@(RESPTR)=RORBUF
"RTN","RORRP033",144,0)
 . ;--- Other registry data
"RTN","RORRP033",145,0)
 . D GETS^DIQ(799.4,IENS,".02;.03;","I","RORBUF","RORMSG")
"RTN","RORRP033",146,0)
 . I $G(DIERR)  D  Q
"RTN","RORRP033",147,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,799.4,IENS)
"RTN","RORRP033",148,0)
 . S $P(ICRBUF,U,3)=+$G(RORBUF(799.4,IENS,.02,"I"))
"RTN","RORRP033",149,0)
 . S $P(ICRBUF,U,4)=$G(RORBUF(799.4,IENS,.03,"I"))
"RTN","RORRP033",150,0)
 ;
"RTN","RORRP033",151,0)
 ;--- CD4 and Viral Load results
"RTN","RORRP033",152,0)
 K RORBUF  S RORBUF=RESULTS
"RTN","RORRP033",153,0)
 S RORBUF("RORPTR")=RESPTR
"RTN","RORRP033",154,0)
 S RORBUF("RORCB")="$$LOADLT^RORRP033"
"RTN","RORRP033",155,0)
 S TMP=$$LTSEARCH^RORUTL10(PATIEN,+REGIEN,.RORBUF)
"RTN","RORRP033",156,0)
 S RESPTR=RORBUF("RORPTR")
"RTN","RORRP033",157,0)
 S $P(ICRBUF,U,6,7)=$G(RORBUF("LASTCD4"))
"RTN","RORRP033",158,0)
 S $P(ICRBUF,U,8,9)=$G(RORBUF("MINCD4"))
"RTN","RORRP033",159,0)
 S $P(ICRBUF,U,10,11)=$G(RORBUF("MINCD4%"))
"RTN","RORRP033",160,0)
 K RORBUF
"RTN","RORRP033",161,0)
 ;---
"RTN","RORRP033",162,0)
 S RESPTR=RESPTR+1,@RESULTS@(RESPTR)=ICRBUF
"RTN","RORRP033",163,0)
 S @RESULTS@(0)=LOCKRC
"RTN","RORRP033",164,0)
 Q
"RTN","RORRP033",165,0)
 ;
"RTN","RORRP033",166,0)
 ;***** LOADS AND PROCESSES CD4 AND VIRAL LOAD RESULTS
"RTN","RORRP033",167,0)
 ;
"RTN","RORRP033",168,0)
 ; .ROR8DST      Reference to the ROR8DST parameter.
"RTN","RORRP033",169,0)
 ;
"RTN","RORRP033",170,0)
 ; INVDT         IEN of the Lab test (inverted date)
"RTN","RORRP033",171,0)
 ;
"RTN","RORRP033",172,0)
 ; .RESULT       Reference to a local variable, which contains the
"RTN","RORRP033",173,0)
 ;               result in the same format as it is stored into
"RTN","RORRP033",174,0)
 ;               the destination array by default.
"RTN","RORRP033",175,0)
 ;
"RTN","RORRP033",176,0)
 ; Return Values:
"RTN","RORRP033",177,0)
 ;       <0  Error code (the search will be aborted)
"RTN","RORRP033",178,0)
 ;        0  Ok
"RTN","RORRP033",179,0)
 ;        1  Skip this result
"RTN","RORRP033",180,0)
 ;        2  Skip this and all remaining results
"RTN","RORRP033",181,0)
 ;
"RTN","RORRP033",182,0)
LOADLT(ROR8DST,INVDT,RESULT) ;
"RTN","RORRP033",183,0)
 N BUF,GROUP,LTDT,LTVAL,TMP
"RTN","RORRP033",184,0)
 S LTDT=$P($G(RESULT(1)),U,2)    Q:LTDT'>0 1   ; Date of the test
"RTN","RORRP033",185,0)
 S LTVAL=$$TRIM^XLFSTR($P(RESULT(1),U,3))      ; Result value
"RTN","RORRP033",186,0)
 S GROUP=+$P($G(RESULT(2)),U,3)  Q:GROUP'>0 1  ; Code of the group
"RTN","RORRP033",187,0)
 ;--- Create the segment
"RTN","RORRP033",188,0)
 S BUF="LTR"_U_$P(RESULT(1),U)
"RTN","RORRP033",189,0)
 S $P(BUF,U,3,4)=LTDT_U_LTVAL
"RTN","RORRP033",190,0)
 S $P(BUF,U,5,8)=$P(RESULT(2),U,1,4)
"RTN","RORRP033",191,0)
 ;--- CD4 Count (last and lowest)
"RTN","RORRP033",192,0)
 D:GROUP=1
"RTN","RORRP033",193,0)
 . S:LTDT>$G(ROR8DST("LASTCD4")) ROR8DST("LASTCD4")=LTDT_U_LTVAL
"RTN","RORRP033",194,0)
 . Q:'$$NUMERIC^RORUTL05(LTVAL)
"RTN","RORRP033",195,0)
 . S TMP=+$P($G(ROR8DST("MINCD4")),U,2)
"RTN","RORRP033",196,0)
 . S:'TMP!(LTVAL<TMP) ROR8DST("MINCD4")=LTDT_U_LTVAL
"RTN","RORRP033",197,0)
 ;--- CD4 % (lowest)
"RTN","RORRP033",198,0)
 D:GROUP=2
"RTN","RORRP033",199,0)
 . Q:'$$NUMERIC^RORUTL05(LTVAL)
"RTN","RORRP033",200,0)
 . S TMP=+$P($G(ROR8DST("MINCD4%")),U,2)
"RTN","RORRP033",201,0)
 . S:'TMP!(LTVAL<TMP) ROR8DST("MINCD4%")=LTDT_U_LTVAL
"RTN","RORRP033",202,0)
 ;--- Store the segment
"RTN","RORRP033",203,0)
 S ROR8DST("RORPTR")=$G(ROR8DST("RORPTR"))+1
"RTN","RORRP033",204,0)
 S @ROR8DST@(ROR8DST("RORPTR"))=BUF
"RTN","RORRP033",205,0)
 Q 0
"RTN","RORRP034")
0^112^B16495366
"RTN","RORRP034",1,0)
RORRP034 ;HCIOFO/SG - RPC: ICR PATIENT SAVE/CANCEL ; 8/15/03 7:54am
"RTN","RORRP034",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP034",3,0)
 ;
"RTN","RORRP034",4,0)
 Q
"RTN","RORRP034",5,0)
 ;
"RTN","RORRP034",6,0)
 ;***** CANCELS THE EDITING
"RTN","RORRP034",7,0)
 ; RPC: [RORICR PATIENT CANCEL]
"RTN","RORRP034",8,0)
 ;
"RTN","RORRP034",9,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP034",10,0)
 ;               are returned to.
"RTN","RORRP034",11,0)
 ;
"RTN","RORRP034",12,0)
 ; REGIEN        Registry IEN
"RTN","RORRP034",13,0)
 ;
"RTN","RORRP034",14,0)
 ; PATIEN        IEN of the registry patient (DFN)
"RTN","RORRP034",15,0)
 ;
"RTN","RORRP034",16,0)
 ; Return Values:
"RTN","RORRP034",17,0)
 ;
"RTN","RORRP034",18,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP034",19,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP034",20,0)
 ; details).
"RTN","RORRP034",21,0)
 ;
"RTN","RORRP034",22,0)
 ; Otherwise, zero is returned in the RESULTS(0).
"RTN","RORRP034",23,0)
 ;
"RTN","RORRP034",24,0)
CANCEL(RESULTS,REGIEN,PATIEN) ;
"RTN","RORRP034",25,0)
 N IENS,RC,RORERRDL,RORLOCK
"RTN","RORRP034",26,0)
 D CLEAR^RORERR("CANCEL^RORRP033",1)  K RESULTS
"RTN","RORRP034",27,0)
 ;--- Check the parameters
"RTN","RORRP034",28,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP034",29,0)
 . ;--- Registry IEN
"RTN","RORRP034",30,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP034",31,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP034",32,0)
 . S REGIEN=+REGIEN
"RTN","RORRP034",33,0)
 . ;--- Patient IEN
"RTN","RORRP034",34,0)
 . I $G(PATIEN)'>0  D  Q
"RTN","RORRP034",35,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"PATIEN",$G(PATIEN))
"RTN","RORRP034",36,0)
 . S PATIEN=+PATIEN
"RTN","RORRP034",37,0)
 ;
"RTN","RORRP034",38,0)
 ;--- Get the IENS of the registry record
"RTN","RORRP034",39,0)
 S IENS=$$PRRIEN^RORUTL01(PATIEN,REGIEN)_","
"RTN","RORRP034",40,0)
 ;
"RTN","RORRP034",41,0)
 ;--- Unlock the records
"RTN","RORRP034",42,0)
 I IENS>0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP034",43,0)
 . S RORLOCK(798,IENS)=""
"RTN","RORRP034",44,0)
 . S RORLOCK(799.4,IENS)=""
"RTN","RORRP034",45,0)
 . S RC=$$UNLOCK^RORLOCK(.RORLOCK)
"RTN","RORRP034",46,0)
 S RESULTS(0)=0
"RTN","RORRP034",47,0)
 Q
"RTN","RORRP034",48,0)
 ;
"RTN","RORRP034",49,0)
 ;***** PROCESSES THE ERROR(S) AND UNLOCKS THE RECORDS
"RTN","RORRP034",50,0)
ERROR(RESULTS,RC) ;
"RTN","RORRP034",51,0)
 D RPCSTK^RORERR(.RESULTS,RC)
"RTN","RORRP034",52,0)
 D UNLOCK^RORLOCK(.RORLOCK)
"RTN","RORRP034",53,0)
 Q
"RTN","RORRP034",54,0)
 ;
"RTN","RORRP034",55,0)
 ;***** UPDATES THE PATIENT'S DATA
"RTN","RORRP034",56,0)
 ; RPC: [RORICR PATIENT SAVE]
"RTN","RORRP034",57,0)
 ;
"RTN","RORRP034",58,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP034",59,0)
 ;               are returned to.
"RTN","RORRP034",60,0)
 ;
"RTN","RORRP034",61,0)
 ; REGIEN        Registry IEN
"RTN","RORRP034",62,0)
 ;
"RTN","RORRP034",63,0)
 ; PATIEN        IEN of the registry patient (DFN)
"RTN","RORRP034",64,0)
 ;
"RTN","RORRP034",65,0)
 ; .DATA         Reference to a local array that contains the data
"RTN","RORRP034",66,0)
 ;               in the same format as the output of the RORICR
"RTN","RORRP034",67,0)
 ;               PATIENT LOAD remote procedure. Only PH and ICR
"RTN","RORRP034",68,0)
 ;               segments are processed; the others are ignored.
"RTN","RORRP034",69,0)
 ;
"RTN","RORRP034",70,0)
 ; Return Values:
"RTN","RORRP034",71,0)
 ;
"RTN","RORRP034",72,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP034",73,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP034",74,0)
 ; details).
"RTN","RORRP034",75,0)
 ;
"RTN","RORRP034",76,0)
 ; Otherwise, zero is returned in the RESULTS(0).
"RTN","RORRP034",77,0)
 ;
"RTN","RORRP034",78,0)
SAVE(RESULTS,REGIEN,PATIEN,DATA) ;
"RTN","RORRP034",79,0)
 N IENS,RC,RDI,REGNAME,RORERRDL,RORFDA,RORLOCK,RORMSG,SEG,TMP
"RTN","RORRP034",80,0)
 D CLEAR^RORERR("SAVE^RORRP033",1)  K RESULTS
"RTN","RORRP034",81,0)
 ;--- Check the parameters
"RTN","RORRP034",82,0)
 S RC=0  D  I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP034",83,0)
 . ;--- Registry IEN
"RTN","RORRP034",84,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP034",85,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP034",86,0)
 . S REGIEN=+REGIEN
"RTN","RORRP034",87,0)
 . ;--- Patient IEN
"RTN","RORRP034",88,0)
 . I $G(PATIEN)'>0  D  Q
"RTN","RORRP034",89,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"PATIEN",$G(PATIEN))
"RTN","RORRP034",90,0)
 . S PATIEN=+PATIEN
"RTN","RORRP034",91,0)
 ;
"RTN","RORRP034",92,0)
 ;--- Get the IENS of the registry record
"RTN","RORRP034",93,0)
 S IENS=$$PRRIEN^RORUTL01(PATIEN,REGIEN)_","
"RTN","RORRP034",94,0)
 I IENS'>0  S RC=0  D  I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP034",95,0)
 . S REGNAME=$P($$REGNAME^RORUTL01(REGIEN),U)
"RTN","RORRP034",96,0)
 . ;--- Add the patient to the registry
"RTN","RORRP034",97,0)
 . S RC=$$ADDPAT^RORUPD06(PATIEN,REGNAME)  Q:RC<0
"RTN","RORRP034",98,0)
 . ;--- Get the IENS of the registry record
"RTN","RORRP034",99,0)
 . S IENS=$$PRRIEN^RORUTL01(PATIEN,REGIEN)_","
"RTN","RORRP034",100,0)
 . S:IENS'>0 RC=$$ERROR^RORERR(-97,,,PATIEN,REGNAME)
"RTN","RORRP034",101,0)
 S RORLOCK(798,IENS)=""
"RTN","RORRP034",102,0)
 S RORLOCK(799.4,IENS)=""
"RTN","RORRP034",103,0)
 ;
"RTN","RORRP034",104,0)
 ;--- Prepare the data
"RTN","RORRP034",105,0)
 S RDI=0,RC=0
"RTN","RORRP034",106,0)
 F  S RDI=$O(DATA(RDI))  Q:RDI'>0  D  Q:RC
"RTN","RORRP034",107,0)
 . S SEG=$P(DATA(RDI),U)
"RTN","RORRP034",108,0)
 . ;--- Risk factors
"RTN","RORRP034",109,0)
 . I SEG="PH"  D  Q
"RTN","RORRP034",110,0)
 . . S RC=$$CDCFDA^RORRP026(IENS,"PH^RORRP026",DATA(RDI),.RORFDA)
"RTN","RORRP034",111,0)
 . ;--- Registry data
"RTN","RORRP034",112,0)
 . I SEG="ICR"  D  Q
"RTN","RORRP034",113,0)
 . . S TMP=$P(DATA(RDI),U,3)
"RTN","RORRP034",114,0)
 . . S RORFDA(799.4,IENS,.02)=TMP
"RTN","RORRP034",115,0)
 . . S RORFDA(799.4,IENS,.03)=$S(TMP:$P(DATA(RDI),U,4),1:"")
"RTN","RORRP034",116,0)
 . . S TMP=+$P(DATA(RDI),U,5)
"RTN","RORRP034",117,0)
 . . S TMP=$S(TMP>0:$$ITEMIEN^RORUTL09(2,REGIEN,TMP),1:"")
"RTN","RORRP034",118,0)
 . . I TMP<0  S RC="5^ICR"  Q
"RTN","RORRP034",119,0)
 . . S RORFDA(798,IENS,3.2)=TMP
"RTN","RORRP034",120,0)
 ;--- Check for error(s)
"RTN","RORRP034",121,0)
 I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP034",122,0)
 I RC>0  S RESULTS(0)=RC  Q
"RTN","RORRP034",123,0)
 ;
"RTN","RORRP034",124,0)
 ;--- Reset the pending patient indicator
"RTN","RORRP034",125,0)
 D:$$GET1^DIQ(798,IENS,3,"I",,"RORMSG")=4
"RTN","RORRP034",126,0)
 . S RORFDA(798,IENS,11)="@" ; DON'T SEND
"RTN","RORRP034",127,0)
 . S RORFDA(798,IENS,3)=2    ; NEW PATIENT (PENDING -> MANUAL)
"RTN","RORRP034",128,0)
 ;
"RTN","RORRP034",129,0)
 ;--- Update the record(s)
"RTN","RORRP034",130,0)
 I $D(RORFDA)>1  D  I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP034",131,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORRP034",132,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,"798&799.4",IENS)
"RTN","RORRP034",133,0)
 ;
"RTN","RORRP034",134,0)
 ;--- Unlock the records
"RTN","RORRP034",135,0)
 S RC=$$UNLOCK^RORLOCK(.RORLOCK)
"RTN","RORRP034",136,0)
 I RC<0  D ERROR(.RESULTS,RC)  Q
"RTN","RORRP034",137,0)
 S RESULTS(0)=0
"RTN","RORRP034",138,0)
 Q
"RTN","RORRP035")
0^179^B5599356
"RTN","RORRP035",1,0)
RORRP035 ;HCIOFO/SG - RPC: GENERIC DRUG NAMES ; 1/14/04 3:07pm
"RTN","RORRP035",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP035",3,0)
 ;
"RTN","RORRP035",4,0)
 Q
"RTN","RORRP035",5,0)
 ;
"RTN","RORRP035",6,0)
 ;***** RETURNS THE LIST OF GENERIC DRUGS
"RTN","RORRP035",7,0)
 ; RPC: [ROR LIST GENERIC DRUGS]
"RTN","RORRP035",8,0)
 ;
"RTN","RORRP035",9,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP035",10,0)
 ;               are returned to.
"RTN","RORRP035",11,0)
 ;
"RTN","RORRP035",12,0)
 ; REGIEN        Registry IEN
"RTN","RORRP035",13,0)
 ;
"RTN","RORRP035",14,0)
 ; [GROUP]       Code of the Drug Group. If this parameter is
"RTN","RORRP035",15,0)
 ;               defined and greater than zero then only the drugs
"RTN","RORRP035",16,0)
 ;               associated with this group will be returned.
"RTN","RORRP035",17,0)
 ;
"RTN","RORRP035",18,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP035",19,0)
 ;
"RTN","RORRP035",20,0)
 ; Return Values:
"RTN","RORRP035",21,0)
 ;
"RTN","RORRP035",22,0)
 ; A negative value of the first "^"-piece of the RESULTS(0)
"RTN","RORRP035",23,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP035",24,0)
 ; details).
"RTN","RORRP035",25,0)
 ;
"RTN","RORRP035",26,0)
 ; Otherwise, number of drugs is returned in the @RESULTS@(0) and
"RTN","RORRP035",27,0)
 ; the subsequent nodes of the global array contain the drugs.
"RTN","RORRP035",28,0)
 ; 
"RTN","RORRP035",29,0)
 ; @RESULTS@(0)          Number of Local Drugs
"RTN","RORRP035",30,0)
 ;
"RTN","RORRP035",31,0)
 ; @RESULTS@(i)          Drug Descriptor
"RTN","RORRP035",32,0)
 ;                         ^01: IEN in the ROR GENERIC DRUG file
"RTN","RORRP035",33,0)
 ;                         ^02: Generic drug name
"RTN","RORRP035",34,0)
 ;                         ^03: IEN of the generic drug (file #50.6)
"RTN","RORRP035",35,0)
 ;                         ^04: Code of the Drug Group
"RTN","RORRP035",36,0)
 ;
"RTN","RORRP035",37,0)
GDLIST(RESULTS,REGIEN,GROUP) ;
"RTN","RORRP035",38,0)
 N GROUPIEN,IENS,IR,PART,RC,RORERRDL,RORMSG,SCR,TMP
"RTN","RORRP035",39,0)
 D CLEAR^RORERR("GDLIST^RORRP032",1)
"RTN","RORRP035",40,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP035",41,0)
 ;
"RTN","RORRP035",42,0)
 ;--- Check the parameters
"RTN","RORRP035",43,0)
 S RC=0  D  I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP035",44,0)
 . ;--- Registry IEN
"RTN","RORRP035",45,0)
 . I $G(REGIEN)'>0  D  Q
"RTN","RORRP035",46,0)
 . . S RC=$$ERROR^RORERR(-88,,,,"REGIEN",$G(REGIEN))
"RTN","RORRP035",47,0)
 . S REGIEN=+REGIEN
"RTN","RORRP035",48,0)
 . ;--- Code of the Drug Group
"RTN","RORRP035",49,0)
 . S GROUP=+$G(GROUP)
"RTN","RORRP035",50,0)
 . S GROUPIEN=$S(GROUP>0:$$ITEMIEN^RORUTL09(4,REGIEN,GROUP),1:0)
"RTN","RORRP035",51,0)
 . I GROUPIEN<0  D  Q
"RTN","RORRP035",52,0)
 . . S RC=$$ERROR^RORERR(GROUPIEN)
"RTN","RORRP035",53,0)
 ;
"RTN","RORRP035",54,0)
 ;--- Compile the screen logic  (be careful with naked references)
"RTN","RORRP035",55,0)
 S SCR=""
"RTN","RORRP035",56,0)
 S:GROUPIEN>0 SCR=SCR_"I $P($G(^(0)),U,3)="_GROUPIEN_" "
"RTN","RORRP035",57,0)
 ;--- Get the list of drugs
"RTN","RORRP035",58,0)
 S TMP="@;.01E;.01I;.03I",PART(1)=REGIEN_"#"
"RTN","RORRP035",59,0)
 D LIST^DIC(799.51,,TMP,"PU",,,.PART,"ARDG",SCR,,,"RORMSG")
"RTN","RORRP035",60,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP035",61,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.129,IENS)
"RTN","RORRP035",62,0)
 ;
"RTN","RORRP035",63,0)
 ;--- Replace the group IEN's with the group code(s)
"RTN","RORRP035",64,0)
 S (IR,RC)=0
"RTN","RORRP035",65,0)
 F  S IR=$O(@RESULTS@(IR))  Q:IR'>0  D  Q:RC<0
"RTN","RORRP035",66,0)
 . I GROUPIEN>0  S $P(@RESULTS@(IR,0),U,4)=GROUP  Q
"RTN","RORRP035",67,0)
 . S TMP=+$P(@RESULTS@(IR,0),U,4)
"RTN","RORRP035",68,0)
 . I TMP'>0  S $P(@RESULTS@(IR,0),U,4)=""  Q
"RTN","RORRP035",69,0)
 . S RC=$$ITEMCODE^RORUTL09(TMP)
"RTN","RORRP035",70,0)
 . S:RC>0 $P(@RESULTS@(IR,0),U,4)=RC
"RTN","RORRP035",71,0)
 I RC<0  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP035",72,0)
 ;--- Success
"RTN","RORRP035",73,0)
 S TMP=+$G(^TMP("DILIST",$J,0))
"RTN","RORRP035",74,0)
 K ^TMP("DILIST",$J,0)  S @RESULTS@(0)=TMP
"RTN","RORRP035",75,0)
 Q
"RTN","RORRP2")
0^101^B21486692
"RTN","RORRP2",1,0)
RORRP2 ;HOIFO/CRT - CLINICAL REGISTRIES - Remote Procedures ; 6/13/03 8:31am
"RTN","RORRP2",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORRP2",3,0)
 ;
"RTN","RORRP2",4,0)
EN1(RES,RORDPT,RORREG) ; ROR EDIT PATIENT GET
"RTN","RORRP2",5,0)
 ;
"RTN","RORRP2",6,0)
 ; INPUT:  RORDPT: Pateint IEN (File #2) (Req'd)
"RTN","RORRP2",7,0)
 ;         RORREG: Registry Name (File #798.1) (Req'd)
"RTN","RORRP2",8,0)
 ; OUTPUT: RES(1)       = 0 if not on Local Registry, else IEN (File#798)
"RTN","RORRP2",9,0)
 ;         RES(2)       = Evidence of Diag (File#798 Field#3.2)
"RTN","RORRP2",10,0)
 ;         RES(3)       = Investigational Drugs (File#798 Field#6)
"RTN","RORRP2",11,0)
 ;         RES(4-n) = Selection Rule(s) (File#798 Field#3.1)
"RTN","RORRP2",12,0)
 ;
"RTN","RORRP2",13,0)
 N OK,RORULES,CNT
"RTN","RORRP2",14,0)
 ;
"RTN","RORRP2",15,0)
 S (RES(1),RES(2),RES(3))=0
"RTN","RORRP2",16,0)
 S CNT=3
"RTN","RORRP2",17,0)
 ;
"RTN","RORRP2",18,0)
 S RES(1)=$$IEN798(RORDPT,RORREG) ; Registry IEN
"RTN","RORRP2",19,0)
 ;
"RTN","RORRP2",20,0)
 S RES(2)=+$$GET1^DIQ(798,RES(1),3.2,"I") ; Evidence Code
"RTN","RORRP2",21,0)
 ;
"RTN","RORRP2",22,0)
 S RES(3)=+$$GET1^DIQ(798,RES(1),6,"I") ; Invst Drug?
"RTN","RORRP2",23,0)
 ;
"RTN","RORRP2",24,0)
 ; If existing patient get Selection Rule(s), else search from rules
"RTN","RORRP2",25,0)
 I RES(1) D
"RTN","RORRP2",26,0)
 .D RULES(RES(1),.RORULES)
"RTN","RORRP2",27,0)
 .I $D(RORULES) D
"RTN","RORRP2",28,0)
 ..N I S I=0 F  S I=$O(RORULES(I)) Q:'I  D
"RTN","RORRP2",29,0)
 ...S CNT=CNT+1,RES(CNT)=RORULES(I)
"RTN","RORRP2",30,0)
 E  D
"RTN","RORRP2",31,0)
 .S OK=$$UPDPAT^RORUPD06(RORDPT,RORREG,.RORULES,1)
"RTN","RORRP2",32,0)
 .I $D(RORULES) D
"RTN","RORRP2",33,0)
 ..N I
"RTN","RORRP2",34,0)
 ..S I=0 F  S I=$O(RORULES(I)) Q:I=""  D
"RTN","RORRP2",35,0)
 ...S CNT=CNT+1
"RTN","RORRP2",36,0)
 ...S RES(CNT)=$P($G(^ROR(798.2,I,0)),"^",3)_"^"_RORULES(I)_"^"_I
"RTN","RORRP2",37,0)
 ;
"RTN","RORRP2",38,0)
 Q
"RTN","RORRP2",39,0)
 ;
"RTN","RORRP2",40,0)
EN2(RES,RORDPT,RORREG) ; ROR ACTIVATE PATIENT GET
"RTN","RORRP2",41,0)
 ;
"RTN","RORRP2",42,0)
 ; INPUT:  RORDPT: Pateint IEN (File #2) (Req'd)
"RTN","RORRP2",43,0)
 ;         RORREG: Registry Name (File #798.1) (Req'd)
"RTN","RORRP2",44,0)
 ; OUTPUT: RES(1)       = 0 if not on Local Registry, else IEN (File#798)
"RTN","RORRP2",45,0)
 ;         RES(2)       = Date of death in File 2 ^ in File 798.4
"RTN","RORRP2",46,0)
 ;         RES(3)       = Inactivation Date^Reason^Reactivation Date
"RTN","RORRP2",47,0)
 ;         RES(4-n) = Selection Rule(s) (File#798 Field#3.1)
"RTN","RORRP2",48,0)
 ;
"RTN","RORRP2",49,0)
 N RORULES,CNT,RORDOD,RORDOD2,RORX
"RTN","RORRP2",50,0)
 ;
"RTN","RORRP2",51,0)
 S RES(1)=0
"RTN","RORRP2",52,0)
 S (RES(2),RES(3))=""
"RTN","RORRP2",53,0)
 S CNT=3
"RTN","RORRP2",54,0)
 ;
"RTN","RORRP2",55,0)
 S RES(1)=$$IEN798(RORDPT,RORREG) Q:'RES(1)  ; Registry IEN
"RTN","RORRP2",56,0)
 ;
"RTN","RORRP2",57,0)
 S RORDOD2=$$GET1^DIQ(2,RORDPT,.351,"I") ; Date of Death
"RTN","RORRP2",58,0)
 S RORDOD=$$GET1^DIQ(798.4,RORDPT,.351,"I") ; Date of Death
"RTN","RORRP2",59,0)
 S RES(2)=RORDOD2_"^"_RORDOD
"RTN","RORRP2",60,0)
 ;
"RTN","RORRP2",61,0)
 S $P(RES(3),"^",1)=$$GET1^DIQ(798,RES(1),2,"I") ; Inactivation Date
"RTN","RORRP2",62,0)
 S $P(RES(3),"^",2)=$$GET1^DIQ(798,RES(1),2.2,"I") ; Inact Reason
"RTN","RORRP2",63,0)
 S $P(RES(3),"^",3)=$$GET1^DIQ(798,RES(1),7,"I") ; Reactivation Date
"RTN","RORRP2",64,0)
 S $P(RES(3),"^",4)=$$GET1^DIQ(798,RES(1),8) ; Active?
"RTN","RORRP2",65,0)
 ;
"RTN","RORRP2",66,0)
 D RULES(RES(1),.RORULES) ; Selection Rule(s)
"RTN","RORRP2",67,0)
 I $D(RORULES) D
"RTN","RORRP2",68,0)
 .N I S I=0 F  S I=$O(RORULES(I)) Q:'I  D
"RTN","RORRP2",69,0)
 ..S CNT=CNT+1,RES(CNT)=RORULES(I)
"RTN","RORRP2",70,0)
 ;
"RTN","RORRP2",71,0)
 ; Check if deceased in File 798.4 but not in 2 or vice versa
"RTN","RORRP2",72,0)
 I ((RORDOD]"")&(RORDOD2=""))!((RORDOD2]"")&(RORDOD="")) D
"RTN","RORRP2",73,0)
 .S RORX=$$UPDPTDEM^RORUPD51(RORDPT)
"RTN","RORRP2",74,0)
 ;
"RTN","RORRP2",75,0)
 Q
"RTN","RORRP2",76,0)
 ;
"RTN","RORRP2",77,0)
EN3(RES,RORDPT,RORREG,RORIDRUG,RORPROF) ; ROR IDRUGS PATIENT SET
"RTN","RORRP2",78,0)
 ;
"RTN","RORRP2",79,0)
 ; INPUT:  RORDPT:   Pateint IEN (File #2) (Req'd)
"RTN","RORRP2",80,0)
 ;         RORREG:   Registry Name (File #798.1) (Req'd)
"RTN","RORRP2",81,0)
 ;         RORIDRUG: Investigational Drugs (File #798 Field 6) (Req'd)
"RTN","RORRP2",82,0)
 ;         RORPROF:  Medication in Profile (File #798 Field 6.1)
"RTN","RORRP2",83,0)
 ; OUTPUT: RES:      1^Success or 0^Error Message
"RTN","RORRP2",84,0)
 ;
"RTN","RORRP2",85,0)
 N RORFDA,RORIEN,RORMSG
"RTN","RORRP2",86,0)
 ;
"RTN","RORRP2",87,0)
 S RORIEN=$$IEN798(RORDPT,RORREG)
"RTN","RORRP2",88,0)
 I 'RORIEN S RES="0^Failed to find patient in Local Registry" Q
"RTN","RORRP2",89,0)
 S RORIEN=RORIEN_","
"RTN","RORRP2",90,0)
 ;
"RTN","RORRP2",91,0)
 S RORIDRUG=$G(RORIDRUG)
"RTN","RORRP2",92,0)
 S RORIDRUG=$S(RORIDRUG=1:1,$E(RORIDRUG)="Y":1,1:0)
"RTN","RORRP2",93,0)
 S RORPROF=$G(RORPROF)
"RTN","RORRP2",94,0)
 S RORPROF=$S(RORIDRUG=0:"@",$E(RORPROF)="Y":1,1:RORPROF)
"RTN","RORRP2",95,0)
 ;
"RTN","RORRP2",96,0)
 S RORFDA(798,RORIEN,5)=1
"RTN","RORRP2",97,0)
 S RORFDA(798,RORIEN,6)=RORIDRUG
"RTN","RORRP2",98,0)
 S RORFDA(798,RORIEN,6.1)=RORPROF
"RTN","RORRP2",99,0)
 ;
"RTN","RORRP2",100,0)
 D UPDATE^DIE("","RORFDA","","RORMSG")
"RTN","RORRP2",101,0)
 ;
"RTN","RORRP2",102,0)
 I $G(DIERR)'="" S RES=$$CHECK^RORRP1(.RORMSG) Q
"RTN","RORRP2",103,0)
 ;
"RTN","RORRP2",104,0)
 S RES="1^Success"
"RTN","RORRP2",105,0)
 Q
"RTN","RORRP2",106,0)
 ;
"RTN","RORRP2",107,0)
EN4(RES,RORREG) ; Get ROR Registry Parameters - ROR REG PARAMS GET
"RTN","RORRP2",108,0)
 ;
"RTN","RORRP2",109,0)
 ; INPUT:  RORREG: Registry Name (File #798.1) (Req'd)
"RTN","RORRP2",110,0)
 ; OUTPUT: RES(1): 0 if invalid Registry, else IEN (File#798.1)
"RTN","RORRP2",111,0)
 ;         RES(2): Short Description (Field # 4)
"RTN","RORRP2",112,0)
 ;         RES(3): Last Update Date (Field #1)
"RTN","RORRP2",113,0)
 ;         RES(4): Last Extract Date (Field #2)
"RTN","RORRP2",114,0)
 ;         RES(5): # of Active Patients (Field #19.2)
"RTN","RORRP2",115,0)
 ;
"RTN","RORRP2",116,0)
 S RES(1)=+$O(^ROR(798.1,"B",RORREG,0)) Q:'RES(1)
"RTN","RORRP2",117,0)
 ;
"RTN","RORRP2",118,0)
 S RES(2)=$$GET1^DIQ(798.1,RES(1),4) ; Short Description
"RTN","RORRP2",119,0)
 ;
"RTN","RORRP2",120,0)
 S RES(3)=$$GET1^DIQ(798.1,RES(1),1,"I") ; Last Update Date
"RTN","RORRP2",121,0)
 ;
"RTN","RORRP2",122,0)
 S RES(4)=$$GET1^DIQ(798.1,RES(1),2,"I") ; Last Extract Date
"RTN","RORRP2",123,0)
 ;
"RTN","RORRP2",124,0)
 S RES(5)=$$GET1^DIQ(798.1,RES(1),19.2)  ; # of Active Patients
"RTN","RORRP2",125,0)
 ;
"RTN","RORRP2",126,0)
 Q
"RTN","RORRP2",127,0)
 ;
"RTN","RORRP2",128,0)
EN5(RES,RORREG,RORTYP) ; Get ROR Codes
"RTN","RORRP2",129,0)
 ;
"RTN","RORRP2",130,0)
 N CNT,CODE,RC,RORBUF
"RTN","RORRP2",131,0)
 S RORREG=$$REG^RORRP1($G(RORREG))  Q:RORREG'>0
"RTN","RORRP2",132,0)
 S RORTYP=$G(RORTYP)                Q:RORTYP'>0
"RTN","RORRP2",133,0)
 ;
"RTN","RORRP2",134,0)
 Q:$$ITEMLIST^RORUTL09(RORTYP,RORREG,.RORBUF)<0
"RTN","RORRP2",135,0)
 ;
"RTN","RORRP2",136,0)
 S CODE="",CNT=0
"RTN","RORRP2",137,0)
 F  S CODE=$O(RORBUF(CODE))  Q:CODE=""  D
"RTN","RORRP2",138,0)
 . S CNT=CNT+1,RES(CNT)=$P(RORBUF(CODE),"^",1,2)
"RTN","RORRP2",139,0)
 Q
"RTN","RORRP2",140,0)
 ;
"RTN","RORRP2",141,0)
IEN798(RORDPT,RORREG) ; Get File #798 IEN
"RTN","RORRP2",142,0)
 ;
"RTN","RORRP2",143,0)
 N RORRES
"RTN","RORRP2",144,0)
 ;
"RTN","RORRP2",145,0)
 S RORRES=0
"RTN","RORRP2",146,0)
 ;
"RTN","RORRP2",147,0)
 Q:'+RORDPT RORRES
"RTN","RORRP2",148,0)
 ;
"RTN","RORRP2",149,0)
 S RORREG=+$O(^ROR(798.1,"B",RORREG,0)) Q:'RORREG RORRES
"RTN","RORRP2",150,0)
 S RORRES=+$O(^RORDATA(798,"KEY",+RORDPT,+RORREG,0))
"RTN","RORRP2",151,0)
 Q RORRES
"RTN","RORRP2",152,0)
 ;
"RTN","RORRP2",153,0)
RULES(RORIEN,RORULES) ; Get Selection Rules
"RTN","RORRP2",154,0)
 ;
"RTN","RORRP2",155,0)
 ; INPUT: RORIEN - File #798 IEN (Req'd)
"RTN","RORRP2",156,0)
 ;        RORULES  - Name of array to store rules (Req'd) - Pass by ref
"RTN","RORRP2",157,0)
 ;
"RTN","RORRP2",158,0)
 N I
"RTN","RORRP2",159,0)
 ;
"RTN","RORRP2",160,0)
 S I=0 F  S I=$O(^RORDATA(798,RORIEN,1,I)) Q:'I  D
"RTN","RORRP2",161,0)
 .N RORRULE,RORSRIEN,Y
"RTN","RORRP2",162,0)
 .S RORSRIEN=$P($G(^RORDATA(798,RORIEN,1,I,0)),"^",1) Q:'+RORSRIEN
"RTN","RORRP2",163,0)
 .S RORRULE=$P($G(^ROR(798.2,RORSRIEN,0)),"^",3)
"RTN","RORRP2",164,0)
 .S Y=$P($G(^RORDATA(798,RORIEN,1,I,0)),"^",2)
"RTN","RORRP2",165,0)
 .S RORULES(I)=RORRULE_"^"_Y_"^"_RORSRIEN
"RTN","RORRP2",166,0)
 Q
"RTN","RORRP2",167,0)
 ;
"RTN","RORRP4")
0^110^B19948124
"RTN","RORRP4",1,0)
RORRP4 ;HOIFO/BH - RPC: REGISTRY PATIENTS REPORT ; 7/14/03 11:28am
"RTN","RORRP4",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3,5**;May 14, 2002
"RTN","RORRP4",3,0)
 ;
"RTN","RORRP4",4,0)
GETDATA(RESULT,REGISTRY,START,END,MODE,SORTBY,FIELDS) ;
"RTN","RORRP4",5,0)
 ;
"RTN","RORRP4",6,0)
 ; Input: Registry - i.e. "VA HEPC"
"RTN","RORRP4",7,0)
 ;        Start    - Start date for report
"RTN","RORRP4",8,0)
 ;        End      - End date for report
"RTN","RORRP4",9,0)
 ;        Mode     - Either "I","A" or "B" (inactive, active or both)
"RTN","RORRP4",10,0)
 ;        Sortby   - Integer 0-7
"RTN","RORRP4",11,0)
 ;                   0-Name  1-DFN 2-ICN  
"RTN","RORRP4",12,0)
 ;                   3-DOB   4-Date Entered
"RTN","RORRP4",13,0)
 ;                   5-Date Inactivated  6-Date Re-Activated
"RTN","RORRP4",14,0)
 ;                   7-Investigational Drugs
"RTN","RORRP4",15,0)
 ;        Fields   - Delimited string conatining 9 pieces of boolean 
"RTN","RORRP4",16,0)
 ;                   data, these values indicate what fields are wanted
"RTN","RORRP4",17,0)
 ;                   on the user interface.
"RTN","RORRP4",18,0)
 ;                   P1=DFN  P2=ICN
"RTN","RORRP4",19,0)
 ;                   P3=DOB  P4=Date entered into registry 
"RTN","RORRP4",20,0)
 ;                   P5=Date Inactivated  P6=Reason Inactivated  
"RTN","RORRP4",21,0)
 ;                   P7=Date Reactivated  P8=Investigational Drugs
"RTN","RORRP4",22,0)
 ;                   P9=Reason Addes to Reg. 
"RTN","RORRP4",23,0)
 ;
"RTN","RORRP4",24,0)
 N LEN,DOB,DTE,STATUS,RULE,REG,SORT,RSNINACT,XREFNODE
"RTN","RORRP4",25,0)
 S STR=".01;",DTE="",RULE=""
"RTN","RORRP4",26,0)
 ;
"RTN","RORRP4",27,0)
 S SORT=$S(SORTBY=1:"DFN",SORTBY=2:"ICN",SORTBY=3:"DOB",SORTBY=4:"ENTERED",SORTBY=5:"DATEIN",SORTBY=6:"DATERE",SORTBY=7:"DRUGS",1:"NAME")
"RTN","RORRP4",28,0)
 S RESULT=$NA(^TMP("ROR REPORT",$J))
"RTN","RORRP4",29,0)
 S REG=$$REG^RORRP1(REGISTRY)
"RTN","RORRP4",30,0)
 ; Make up string for GETS FM call.
"RTN","RORRP4",31,0)
 I $P(FIELDS,"^",4) S STR=STR_"1;"
"RTN","RORRP4",32,0)
 I $P(FIELDS,"^",5) S STR=STR_"2;"
"RTN","RORRP4",33,0)
 I $P(FIELDS,"^",6) S STR=STR_"2.2;"
"RTN","RORRP4",34,0)
 I $P(FIELDS,"^",7) S STR=STR_"7;"
"RTN","RORRP4",35,0)
 I $P(FIELDS,"^",8) S STR=STR_"6;"
"RTN","RORRP4",36,0)
 I $P(FIELDS,"^",9) S RULE=1
"RTN","RORRP4",37,0)
 S LEN=$L(STR) I $E(STR,LEN,LEN)=";" S STR=$E(STR,1,LEN-1)
"RTN","RORRP4",38,0)
 ;
"RTN","RORRP4",39,0)
 ; If start date specified -1 off to allow for $O.
"RTN","RORRP4",40,0)
 S XREFNODE=$NA(^RORDATA(798,"ARD",REG_"#"))
"RTN","RORRP4",41,0)
 S DTE=$S(START>0:$O(@XREFNODE@(START),-1),1:"")
"RTN","RORRP4",42,0)
 ; If no End value set false 9999999 for Quit logic.
"RTN","RORRP4",43,0)
 I END="" S END=9999999
"RTN","RORRP4",44,0)
 S:$P(END,".",2)="" $P(END,".",2)=235959
"RTN","RORRP4",45,0)
 S CNT=0
"RTN","RORRP4",46,0)
 F  S DTE=$O(@XREFNODE@(DTE))  Q:DTE>END!('DTE)  D
"RTN","RORRP4",47,0)
 . S IEN=""
"RTN","RORRP4",48,0)
 . F  S IEN=$O(@XREFNODE@(DTE,IEN))  Q:'IEN  D
"RTN","RORRP4",49,0)
 . . S ACTIVE=$$GET1^DIQ(798,IEN,8)
"RTN","RORRP4",50,0)
 . . ; If called for Active patients and patient is inactive Quit.
"RTN","RORRP4",51,0)
 . . I MODE="A",'ACTIVE Q
"RTN","RORRP4",52,0)
 . . ; If called for Inactive patients and patient is Active Quit.
"RTN","RORRP4",53,0)
 . . I MODE="I",ACTIVE Q
"RTN","RORRP4",54,0)
 . . ;
"RTN","RORRP4",55,0)
 . . S DFN=$P(^RORDATA(798,IEN,0),U)
"RTN","RORRP4",56,0)
 . . S DOB=$P($G(^RORDATA(798.4,DFN,1)),U,2)
"RTN","RORRP4",57,0)
 . . S DOB=$$FORMAT(DOB)
"RTN","RORRP4",58,0)
 . . S SSN=$P($G(^RORDATA(798.4,DFN,1)),U),SSN=$E(SSN,6,9)
"RTN","RORRP4",59,0)
 . . S ICN=$$ICN^RORUTL02(DFN)
"RTN","RORRP4",60,0)
 . . S ICN=$P(ICN,"V",1)
"RTN","RORRP4",61,0)
 . . S:ICN<0 ICN=""
"RTN","RORRP4",62,0)
 . . ;
"RTN","RORRP4",63,0)
 . . N RORDATA
"RTN","RORRP4",64,0)
 . . D GETS^DIQ(798,IEN_",",STR,"IE","RORDATA")
"RTN","RORRP4",65,0)
 . . ;
"RTN","RORRP4",66,0)
 . . S NAME=RORDATA(798,IEN_",",.01,"E")
"RTN","RORRP4",67,0)
 . . S ENTERED=$P($G(RORDATA(798,IEN_",",1,"I")),".",1)
"RTN","RORRP4",68,0)
 . . I ENTERED'="" S ENTERED=$$FORMAT(ENTERED)
"RTN","RORRP4",69,0)
 . . S DATEIN=$P($G(RORDATA(798,IEN_",",2,"I")),".",1)
"RTN","RORRP4",70,0)
 . . I DATEIN'="" S DATEIN=$$FORMAT(DATEIN)
"RTN","RORRP4",71,0)
 . . S RSNINACT=$G(RORDATA(798,IEN_",",2.2,"E"))
"RTN","RORRP4",72,0)
 . . S DATERE=$P($G(RORDATA(798,IEN_",",7,"I")),".",1)
"RTN","RORRP4",73,0)
 . . I DATERE'="" S DATERE=$$FORMAT(DATERE)
"RTN","RORRP4",74,0)
 . . S DRUGS=$G(RORDATA(798,IEN_",",6,"E")) I DRUGS="" S DRUGS="NO"
"RTN","RORRP4",75,0)
 . . ;
"RTN","RORRP4",76,0)
 . . ; If sort value is undefined quit. 
"RTN","RORRP4",77,0)
 . . S CNT=CNT+1,K4=@SORT I K4="" Q
"RTN","RORRP4",78,0)
 . . S K4=$P(K4,"~",1)
"RTN","RORRP4",79,0)
 . . I SORTBY=3!(SORTBY=4) S K4=9999999-K4
"RTN","RORRP4",80,0)
 . . ;
"RTN","RORRP4",81,0)
 . . N REASON
"RTN","RORRP4",82,0)
 . . S REASON(1)=""
"RTN","RORRP4",83,0)
 . . I RULE D REASON(IEN)
"RTN","RORRP4",84,0)
 . . ;
"RTN","RORRP4",85,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",1)=NAME
"RTN","RORRP4",86,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",2)=SSN
"RTN","RORRP4",87,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",3)=DFN
"RTN","RORRP4",88,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",4)=ICN
"RTN","RORRP4",89,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",5)=$P(DOB,"~",2)
"RTN","RORRP4",90,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",6)=$P(ENTERED,"~",2)
"RTN","RORRP4",91,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",7)=$P(DATEIN,"~",2)
"RTN","RORRP4",92,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",8)=RSNINACT
"RTN","RORRP4",93,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",9)=$P(DATERE,"~",2)
"RTN","RORRP4",94,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",10)=DRUGS
"RTN","RORRP4",95,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",11)=REASON(1) I 'RULE Q
"RTN","RORRP4",96,0)
 . . ;  If no more selection rules for patient Quit
"RTN","RORRP4",97,0)
 . . I $G(REASON(2))="" Q
"RTN","RORRP4",98,0)
 . . ;  Loop through all remaining rules and write to global
"RTN","RORRP4",99,0)
 . . N I S I=1
"RTN","RORRP4",100,0)
 . . F  S I=$O(REASON(I)) Q:'I  D
"RTN","RORRP4",101,0)
 . . . S CNT=CNT+1
"RTN","RORRP4",102,0)
 . . . S $P(@RESULT@(K4,NAME,CNT),"^",11)=REASON(I)
"RTN","RORRP4",103,0)
 . . Q
"RTN","RORRP4",104,0)
 K CNT
"RTN","RORRP4",105,0)
 Q
"RTN","RORRP4",106,0)
 ;
"RTN","RORRP4",107,0)
FORMAT(FDATE) ;  Concatinates passed in FM date with a formatted version of
"RTN","RORRP4",108,0)
 ;          itself.
"RTN","RORRP4",109,0)
 N M,D,Y,C,TC
"RTN","RORRP4",110,0)
 S C=""
"RTN","RORRP4",111,0)
 S M=$E(FDATE,4,5),Y=$E(FDATE,2,3),D=$E(FDATE,6,7)
"RTN","RORRP4",112,0)
 S TC=$E(FDATE,1,1)
"RTN","RORRP4",113,0)
 I TC=1 S C=18
"RTN","RORRP4",114,0)
 I TC=2 S C=19
"RTN","RORRP4",115,0)
 I TC=3 S C=20
"RTN","RORRP4",116,0)
 S FDATE=FDATE_"~"_M_"/"_D_"/"_C_Y
"RTN","RORRP4",117,0)
 Q FDATE
"RTN","RORRP4",118,0)
 ;
"RTN","RORRP4",119,0)
REASON(IEN) ;  Get short description of selection rules passed if none 
"RTN","RORRP4",120,0)
 ;          exist pass back 'Manual entry'.
"RTN","RORRP4",121,0)
 ;
"RTN","RORRP4",122,0)
 N DESC,K4,STR,POINTER,COUNT
"RTN","RORRP4",123,0)
 S K4="0",STR="",COUNT=0,DESC=""
"RTN","RORRP4",124,0)
 S REASON(1)="Manual Entry"
"RTN","RORRP4",125,0)
 F  S K4=$O(^RORDATA(798,IEN,1,K4)) Q:'K4  D
"RTN","RORRP4",126,0)
 . S STR=$G(^RORDATA(798,IEN,1,K4,0)) Q:STR=""
"RTN","RORRP4",127,0)
 . S POINTER=$P(STR,"^",1)
"RTN","RORRP4",128,0)
 . S DESC=$P(^ROR(798.2,POINTER,0),"^",3) Q:DESC=""
"RTN","RORRP4",129,0)
 . S COUNT=COUNT+1
"RTN","RORRP4",130,0)
 . S REASON(COUNT)=DESC
"RTN","RORRP4",131,0)
 . Q
"RTN","RORRP4",132,0)
 Q
"RTN","RORRP4",133,0)
 ;          
"RTN","RORRP4",134,0)
 ;
"RTN","RORRP5")
0^78^B3695414
"RTN","RORRP5",1,0)
RORRP5 ;HOIFO/CRT - Clinical Registries Pateint Search RPC ; 5/19/03 8:22am
"RTN","RORRP5",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORRP5",3,0)
 ;
"RTN","RORRP5",4,0)
EN1(RES,RORREG,RORPART,RORDIR,RORFILE,RORSCRN) ; Return (Partial) Patient List
"RTN","RORRP5",5,0)
 ;
"RTN","RORRP5",6,0)
 ; Remote Procedure: ROR PATIENT SEARCH
"RTN","RORRP5",7,0)
 ; Input: RORREG - Registry Name (Req'd)
"RTN","RORRP5",8,0)
 ;        RORPART - Partial Match (Req'd)
"RTN","RORRP5",9,0)
 ;        RORDIR - Direction. 1 = forward, -1 = back. (Req'd)
"RTN","RORRP5",10,0)
 ;        RORFILE - Search File. 2 or 798 (Req'd)
"RTN","RORRP5",11,0)
 ;        RORSCRN - Date to screen file 798 on (opt'l)
"RTN","RORRP5",12,0)
 ; Output: RES - List of Patients (#2). NAME^SSN^DOB^IEN
"RTN","RORRP5",13,0)
 ;
"RTN","RORRP5",14,0)
 N CNT,I,INDEX,LOOP,SCREEN,RORREG1
"RTN","RORRP5",15,0)
 ;
"RTN","RORRP5",16,0)
 S RES=$NA(^TMP($J,"ROR-SEARCH")) K @RES
"RTN","RORRP5",17,0)
 ;
"RTN","RORRP5",18,0)
 S SCREEN=""
"RTN","RORRP5",19,0)
 S RORREG=$G(RORREG) Q:RORREG=""
"RTN","RORRP5",20,0)
 S RORINDX=$S(RORPART?4N:"BS",RORPART?1U4N:"BS5",RORPART?9N.1"P":"SSN",1:"B")
"RTN","RORRP5",21,0)
 S RORFILE=$S($G(RORFILE)=798:798.4,1:2)
"RTN","RORRP5",22,0)
 S RORDIR=$S(RORDIR="-1":"B",1:"")
"RTN","RORRP5",23,0)
 S RORSCRN=$G(RORSCRN)
"RTN","RORRP5",24,0)
 I RORFILE=798.4 D
"RTN","RORRP5",25,0)
 .S SCREEN="I $$IEN798^RORRP2(+Y,RORREG)"
"RTN","RORRP5",26,0)
 .I RORSCRN'="" S SCREEN=SCREEN_",($P(^RORDATA(798,$$IEN798^RORRP2(+Y,RORREG),0),""^"",3)'<RORSCRN)"
"RTN","RORRP5",27,0)
 ;
"RTN","RORRP5",28,0)
 I RORFILE=2 D
"RTN","RORRP5",29,0)
 .S RORREG1=+$$REG^RORRP1(RORREG)
"RTN","RORRP5",30,0)
 .S SCREEN="I '$$SKIPEMPL^RORUTL02(+Y,.RORREG1)"
"RTN","RORRP5",31,0)
 D LIST^DIC(RORFILE,,"@;.01;.03;.09",RORDIR,,,RORPART,RORINDX,SCREEN,,"^TMP($J,""ROROUT"")","RORMSG")
"RTN","RORRP5",32,0)
 ;
"RTN","RORRP5",33,0)
 S I=0 F  S I=$O(^TMP($J,"ROROUT","DILIST","ID",I)) Q:'I  D
"RTN","RORRP5",34,0)
 .S @RES@(I)=$$ADD(I)
"RTN","RORRP5",35,0)
 ;
"RTN","RORRP5",36,0)
 K ^TMP($J,"ROROUT")
"RTN","RORRP5",37,0)
 ;
"RTN","RORRP5",38,0)
 Q
"RTN","RORRP5",39,0)
 ;
"RTN","RORRP5",40,0)
ADD(J) ;
"RTN","RORRP5",41,0)
 N RESULT
"RTN","RORRP5",42,0)
 ;
"RTN","RORRP5",43,0)
 S $P(RESULT,"^",1)=^TMP($J,"ROROUT","DILIST","ID",J,.01)
"RTN","RORRP5",44,0)
 S $P(RESULT,"^",2)=^TMP($J,"ROROUT","DILIST","ID",J,.09)
"RTN","RORRP5",45,0)
 S $P(RESULT,"^",3)=^TMP($J,"ROROUT","DILIST","ID",J,.03)
"RTN","RORRP5",46,0)
 S $P(RESULT,"^",4)=^TMP($J,"ROROUT","DILIST",2,J)
"RTN","RORRP5",47,0)
 ;
"RTN","RORRP5",48,0)
 Q RESULT
"RTN","RORSET01")
0^96^B16336609
"RTN","RORSET01",1,0)
RORSET01 ;HCIOFO/SG - REGISTRY SETUP ROUTINE (VA HEPC) ; 2/5/04 1:06pm
"RTN","RORSET01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3,5**;May 14, 2002
"RTN","RORSET01",3,0)
 ;
"RTN","RORSET01",4,0)
 ;***** HEPC REGISTRY SETUP
"RTN","RORSET01",5,0)
 ;
"RTN","RORSET01",6,0)
 N RORERROR      ; Error processing data
"RTN","RORSET01",7,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORSET01",8,0)
 N RORPARM       ; Application parameters
"RTN","RORSET01",9,0)
 ;
"RTN","RORSET01",10,0)
 N LSNAME,RC,REGNAME,RORHDT,RORMNTSK,RORREG,RORSUSP,TMP
"RTN","RORSET01",11,0)
 N ZTCPU,ZTDESC,ZTIO,ZTKIL,ZTPRI,ZTRTN,ZTSAVE,ZTSK,ZTSYNC,ZTUCI
"RTN","RORSET01",12,0)
 S RORPARM("ERR")=1         ; Enable error processing
"RTN","RORSET01",13,0)
 S RORPARM("SETUP")=1       ; Registry setup indicator
"RTN","RORSET01",14,0)
 ;
"RTN","RORSET01",15,0)
 ;--- IEN and name of the registry
"RTN","RORSET01",16,0)
 S RORREG=$$SELREG^RORHDTUT(.REGNAME)  G:RORREG<0 ERROR
"RTN","RORSET01",17,0)
 Q:'RORREG
"RTN","RORSET01",18,0)
 S $P(RORREG,U,2)=REGNAME,LSNAME=REGNAME
"RTN","RORSET01",19,0)
 ;
"RTN","RORSET01",20,0)
 ;--- Check the Lab Search
"RTN","RORSET01",21,0)
 I REGNAME="VA HEPC"  D  Q:'RC             G:RC<0 ERROR
"RTN","RORSET01",22,0)
 . S RC=$$LABSRCH^RORSETU2(LSNAME)
"RTN","RORSET01",23,0)
 . S RC=$S(RC=-55:$$LSCONF^RORSETU1(LSNAME),RC<0:RC,1:1)
"RTN","RORSET01",24,0)
 ;
"RTN","RORSET01",25,0)
 ;--- Request setup parameters
"RTN","RORSET01",26,0)
 S RC=$$ASKPARMS^RORSETU1(.RORMNTSK,.RORSUSP)
"RTN","RORSET01",27,0)
 I RC<0  Q:(RC=-71)!(RC=-72)                    G ERROR
"RTN","RORSET01",28,0)
 ;
"RTN","RORSET01",29,0)
 ;--- Schedule the setup task
"RTN","RORSET01",30,0)
 S ZTRTN="TASK^RORSET01",ZTIO=""
"RTN","RORSET01",31,0)
 S ZTDESC="Registry Setup ("_$P(RORREG,U,2)_")"
"RTN","RORSET01",32,0)
 F TMP="RORMNTSK","RORREG","RORSUSP"  S ZTSAVE(TMP)=""
"RTN","RORSET01",33,0)
 D ^%ZTLOAD
"RTN","RORSET01",34,0)
 Q
"RTN","RORSET01",35,0)
ERROR ;--- Display the errors
"RTN","RORSET01",36,0)
 D DSPSTK^RORERR()
"RTN","RORSET01",37,0)
 Q
"RTN","RORSET01",38,0)
 ;
"RTN","RORSET01",39,0)
 ;***** REPLACES THE SELECTION RULES
"RTN","RORSET01",40,0)
 ;
"RTN","RORSET01",41,0)
 ; RORREG        Registry IEN and registry name separated by the '^'
"RTN","RORSET01",42,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORSET01",43,0)
 ; FROM,TO       Codes of the rule groups (1-regular, 2-historical)
"RTN","RORSET01",44,0)
 ;
"RTN","RORSET01",45,0)
 ; Return Values:
"RTN","RORSET01",46,0)
 ;       <0  Error code
"RTN","RORSET01",47,0)
 ;        0  Ok
"RTN","RORSET01",48,0)
 ;
"RTN","RORSET01",49,0)
RULES(RORREG,FROM,TO) ;
"RTN","RORSET01",50,0)
 ;;VA HEPC PTF^VA HEPC PTF HIST
"RTN","RORSET01",51,0)
 ;;VA HEPC VPOV^VA HEPC VISIT HIST
"RTN","RORSET01",52,0)
 ;
"RTN","RORSET01",53,0)
 N I,IEN,IENS,NAMES,RC,RORFDA,RORMSG
"RTN","RORSET01",54,0)
 S IENS=","_(+RORREG)_",",RC=0
"RTN","RORSET01",55,0)
 ;--- Replace the selection rules
"RTN","RORSET01",56,0)
 F I=1,2  D  Q:RC<0
"RTN","RORSET01",57,0)
 . S NAMES=$P($T(RULES+I),";;",2)  Q:NAMES?."^"
"RTN","RORSET01",58,0)
 . S IEN=$$FIND1^DIC(798.13,IENS,"UX",$P(NAMES,U,FROM),"B",,"RORMSG")
"RTN","RORSET01",59,0)
 . Q:IEN=0
"RTN","RORSET01",60,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.13)
"RTN","RORSET01",61,0)
 . Q:RC<0
"RTN","RORSET01",62,0)
 . S RORFDA(798.13,IEN_IENS,.01)=$P(NAMES,U,TO)
"RTN","RORSET01",63,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORSET01",64,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.13,IEN_IENS)
"RTN","RORSET01",65,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORSET01",66,0)
 ;
"RTN","RORSET01",67,0)
 ;***** ENTRY POINT OF THE REGISTRY SETUP TASK
"RTN","RORSET01",68,0)
 ;
"RTN","RORSET01",69,0)
 ; RORMNTSK      Maximum number of the registry update subtasks
"RTN","RORSET01",70,0)
 ; RORREG        RegistryIEN^RegistryName
"RTN","RORSET01",71,0)
 ; RORSUSP       Task suspension time frame (StartTime^EndTime)
"RTN","RORSET01",72,0)
 ;
"RTN","RORSET01",73,0)
TASK ;
"RTN","RORSET01",74,0)
 N RORERROR      ; Error processing data
"RTN","RORSET01",75,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORSET01",76,0)
 N RORPARM       ; Application parameters
"RTN","RORSET01",77,0)
 ;
"RTN","RORSET01",78,0)
 N RC,REGLST,REGNAME,TMP
"RTN","RORSET01",79,0)
 S RORPARM("DEVELOPER")=1   ; Enable modifications
"RTN","RORSET01",80,0)
 S RORPARM("ERR")=1         ; Enable error processing
"RTN","RORSET01",81,0)
 S RORPARM("LOG")=1         ; Enable event recording
"RTN","RORSET01",82,0)
 S RORPARM("SETUP")=1       ; Registry setup indicator
"RTN","RORSET01",83,0)
 ;
"RTN","RORSET01",84,0)
 S REGNAME=$P(RORREG,U,2),REGLST(REGNAME)=+RORREG
"RTN","RORSET01",85,0)
 ;--- Open a new log
"RTN","RORSET01",86,0)
 S RC=$$OPEN^RORLOG(.REGLST,0,"REGISTRY SETUP STARTED")
"RTN","RORSET01",87,0)
 D
"RTN","RORSET01",88,0)
 . ;--- Replace the selection rules with historical ones
"RTN","RORSET01",89,0)
 . I REGNAME="VA HEPC"  S RC=$$RULES(RORREG,1,2)  Q:RC<0
"RTN","RORSET01",90,0)
 . ;--- Populate the registry
"RTN","RORSET01",91,0)
 . S RC=$$UPDATE^RORUPD(.REGLST,,$G(RORMNTSK),$G(RORSUSP),"E")  Q:RC<0
"RTN","RORSET01",92,0)
 . D LOG^RORLOG(2,"The registry has been populated.")
"RTN","RORSET01",93,0)
 . ;--- Convert the ICR 2.1 records
"RTN","RORSET01",94,0)
 . I REGNAME="VA ICR"  D  Q:RC<0
"RTN","RORSET01",95,0)
 . . S RC=$$CONVERT^RORICR02(RORREG)
"RTN","RORSET01",96,0)
 . . ;--- Update number of patients in registry parameters
"RTN","RORSET01",97,0)
 . . S TMP=$$UPDDEM^RORUPD51(.REGLST)
"RTN","RORSET01",98,0)
 . ;--- Setup the registry
"RTN","RORSET01",99,0)
 . S RC=$$PREPARE^RORSETU2(RORREG)  Q:RC<0
"RTN","RORSET01",100,0)
 ;
"RTN","RORSET01",101,0)
 ;--- Restore the regular selection rules
"RTN","RORSET01",102,0)
 D:REGNAME="VA HEPC"
"RTN","RORSET01",103,0)
 . S TMP=$$RULES(RORREG,2,1)  I TMP<0  S:RC'<0 RC=TMP
"RTN","RORSET01",104,0)
 ;--- Close the log
"RTN","RORSET01",105,0)
 S TMP="REGISTRY SETUP "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","RORSET01",106,0)
 D CLOSE^RORLOG(TMP)
"RTN","RORSET01",107,0)
 ;
"RTN","RORSET01",108,0)
 ;--- Send the notification e-mail
"RTN","RORSET01",109,0)
 S:RC'<0 TMP=$$SENDINFO^RORUTL17(+RORREG,,"EP")
"RTN","RORSET01",110,0)
 ;--- Send an alert to the originator of the task
"RTN","RORSET01",111,0)
 S TMP=$S(RC<0:-43,1:-41)
"RTN","RORSET01",112,0)
 D ALERT^RORKIDS(DUZ,TMP,$P(RORREG,U,2),,"registry setup")
"RTN","RORSET01",113,0)
 ;
"RTN","RORSET01",114,0)
 ;--- Cleanup
"RTN","RORSET01",115,0)
 I RC'<0  D  S ZTREQ="@"
"RTN","RORSET01",116,0)
 . K ^XTMP("RORUPDR"_+RORREG)
"RTN","RORSET01",117,0)
 Q
"RTN","RORSETU1")
0^98^B9739381
"RTN","RORSETU1",1,0)
RORSETU1 ;HCIOFO/SG - SETUP UTILITIES (USER INTERFACE) ; 6/10/03 8:28am
"RTN","RORSETU1",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORSETU1",3,0)
 ;
"RTN","RORSETU1",4,0)
 Q
"RTN","RORSETU1",5,0)
 ;
"RTN","RORSETU1",6,0)
 ;***** REQUESTS SETUP PARAMETERS FROM THE USER
"RTN","RORSETU1",7,0)
 ;
"RTN","RORSETU1",8,0)
 ; .MAXNTSK      Maximum number of registry update subtasks is
"RTN","RORSETU1",9,0)
 ;               returned via this parameter
"RTN","RORSETU1",10,0)
 ;
"RTN","RORSETU1",11,0)
 ; .SUSPEND      Start and end times of registry setup suspension
"RTN","RORSETU1",12,0)
 ;               are returned via this parameter
"RTN","RORSETU1",13,0)
 ;
"RTN","RORSETU1",14,0)
 ; Return Values:
"RTN","RORSETU1",15,0)
 ;       <0  Error code
"RTN","RORSETU1",16,0)
 ;        0  Ok
"RTN","RORSETU1",17,0)
 ;
"RTN","RORSETU1",18,0)
ASKPARMS(MAXNTSK,SUSPEND) ;
"RTN","RORSETU1",19,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,RC,X,Y
"RTN","RORSETU1",20,0)
 S MAXNTSK=0,SUSPEND=""
"RTN","RORSETU1",21,0)
 ;---
"RTN","RORSETU1",22,0)
 K DIR  S DIR(0)="N^0:10:0",DIR("B")=5
"RTN","RORSETU1",23,0)
 S DIR("A")="Maximum number of registry update subtasks"
"RTN","RORSETU1",24,0)
 D BLD^DIALOG(7980000.009,,,"DIR(""?"")","S")
"RTN","RORSETU1",25,0)
 D ^DIR
"RTN","RORSETU1",26,0)
 Q:$D(DUOUT) -71  Q:$D(DTOUT) -72
"RTN","RORSETU1",27,0)
 S MAXNTSK=Y
"RTN","RORSETU1",28,0)
 ;---
"RTN","RORSETU1",29,0)
 K DIR  S DIR(0)="Y",DIR("B")="NO"
"RTN","RORSETU1",30,0)
 S DIR("A")="Suspend the post-install during the peak hours"
"RTN","RORSETU1",31,0)
 D BLD^DIALOG(7980000.01,,,"DIR(""?"")","S")
"RTN","RORSETU1",32,0)
 D ^DIR
"RTN","RORSETU1",33,0)
 Q:$D(DUOUT) -71  Q:$D(DTOUT) -72
"RTN","RORSETU1",34,0)
 ;---
"RTN","RORSETU1",35,0)
 S RC=0
"RTN","RORSETU1",36,0)
 F  Q:'$G(Y)  D  Q:RC<0
"RTN","RORSETU1",37,0)
 . K DIR  S DIR(0)="D^::R",DIR("B")="7:00AM"
"RTN","RORSETU1",38,0)
 . S DIR("A")="Suspension start time"
"RTN","RORSETU1",39,0)
 . D BLD^DIALOG(7980000.011,,,"DIR(""?"")","S")
"RTN","RORSETU1",40,0)
 . D ^DIR
"RTN","RORSETU1",41,0)
 . I $D(DUOUT)  S RC=-71  Q
"RTN","RORSETU1",42,0)
 . I $D(DTOUT)  S RC=-72  Q
"RTN","RORSETU1",43,0)
 . S $P(SUSPEND,U,1)=Y#1
"RTN","RORSETU1",44,0)
 . ;---
"RTN","RORSETU1",45,0)
 . K DIR  S DIR(0)="D^::R",DIR("B")="6:00PM"
"RTN","RORSETU1",46,0)
 . S DIR("A")="Suspension end time"
"RTN","RORSETU1",47,0)
 . D BLD^DIALOG(7980000.012,,,"DIR(""?"")","S")
"RTN","RORSETU1",48,0)
 . D ^DIR
"RTN","RORSETU1",49,0)
 . I $D(DUOUT)  S RC=-71  Q
"RTN","RORSETU1",50,0)
 . I $D(DTOUT)  S RC=-72  Q
"RTN","RORSETU1",51,0)
 . S $P(SUSPEND,U,2)=Y#1
"RTN","RORSETU1",52,0)
 . ;---
"RTN","RORSETU1",53,0)
 . I $P(SUSPEND,U,2)>$P(SUSPEND,U,1)  S Y=0  Q
"RTN","RORSETU1",54,0)
 . W " ??",!!,"The end time must be later than the start time.",!
"RTN","RORSETU1",55,0)
 ;---
"RTN","RORSETU1",56,0)
 D:'RC CONFTXT(MAXNTSK,SUSPEND)
"RTN","RORSETU1",57,0)
 ;---
"RTN","RORSETU1",58,0)
 Q RC
"RTN","RORSETU1",59,0)
 ;
"RTN","RORSETU1",60,0)
 ;***** GENERATES THE TEXT OF CONFIRMATION REQUEST
"RTN","RORSETU1",61,0)
 ;
"RTN","RORSETU1",62,0)
 ; MAXNTSK       Maximum number of registry update subtasks
"RTN","RORSETU1",63,0)
 ; SUSPEND       Task suspension parameters
"RTN","RORSETU1",64,0)
 ;
"RTN","RORSETU1",65,0)
CONFTXT(MAXNTSK,SUSPEND) ;
"RTN","RORSETU1",66,0)
 N TMP
"RTN","RORSETU1",67,0)
 W !
"RTN","RORSETU1",68,0)
 W !,"  ============================================="
"RTN","RORSETU1",69,0)
 S TMP=$S(MAXNTSK>0:MAXNTSK,1:1)
"RTN","RORSETU1",70,0)
 W !,"  Number of registry update (sub)tasks... "_TMP
"RTN","RORSETU1",71,0)
 S TMP=$S(SUSPEND:"Yes",1:"No")
"RTN","RORSETU1",72,0)
 W !,"  Suspend the tasks during peak hours.... "_TMP
"RTN","RORSETU1",73,0)
 D:SUSPEND
"RTN","RORSETU1",74,0)
 . S TMP=$P($$FMTE^XLFDT(DT+$P(SUSPEND,U,1),"F"),"@",2)
"RTN","RORSETU1",75,0)
 . W !,"  Suspend the tasks at................... "_TMP
"RTN","RORSETU1",76,0)
 . S TMP=$P($$FMTE^XLFDT(DT+$P(SUSPEND,U,2),"F"),"@",2)
"RTN","RORSETU1",77,0)
 . W !,"  Resume the tasks at.................... "_TMP
"RTN","RORSETU1",78,0)
 W !,"  ============================================="
"RTN","RORSETU1",79,0)
 W !
"RTN","RORSETU1",80,0)
 Q
"RTN","RORSETU1",81,0)
 ;
"RTN","RORSETU1",82,0)
 ;***** ASKS FOR CONFIRMATION IF THERE ARE NO SEARCH INDICATORS
"RTN","RORSETU1",83,0)
 ;
"RTN","RORSETU1",84,0)
 ; LSNAME        Name of the Lab Search
"RTN","RORSETU1",85,0)
 ;
"RTN","RORSETU1",86,0)
 ; Return Values:
"RTN","RORSETU1",87,0)
 ;       <0  Error code
"RTN","RORSETU1",88,0)
 ;        0  Exit the registry setup
"RTN","RORSETU1",89,0)
 ;       >1  Continue the setup
"RTN","RORSETU1",90,0)
 ;
"RTN","RORSETU1",91,0)
LSCONF(LSNAME) ;
"RTN","RORSETU1",92,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,RC,X,Y
"RTN","RORSETU1",93,0)
 S DIR(0)="Y",DIR("B")="NO"
"RTN","RORSETU1",94,0)
 S DIR("A")="Continue the registry setup"
"RTN","RORSETU1",95,0)
 S DIR("A",1)=""
"RTN","RORSETU1",96,0)
 S DIR("A",2)="The '"_LSNAME_"' Lab Search contains no active search indicators."
"RTN","RORSETU1",97,0)
 D ^DIR
"RTN","RORSETU1",98,0)
 Q $S($D(DUOUT):-71,$D(DTOUT):-72,1:+Y)
"RTN","RORSETU2")
0^121^B11438784
"RTN","RORSETU2",1,0)
RORSETU2 ;HCIOFO/SG - SETUP UTILITIES (REGISTRY) ; 1/16/04 10:20am
"RTN","RORSETU2",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORSETU2",3,0)
 ;
"RTN","RORSETU2",4,0)
 Q
"RTN","RORSETU2",5,0)
 ;
"RTN","RORSETU2",6,0)
 ;***** DRAWS THE BOUNDARY BETWEEN HISTORICAL AND REGULAR EXTRACTIONS
"RTN","RORSETU2",7,0)
 ;
"RTN","RORSETU2",8,0)
 ; REGIEN        Registry IEN
"RTN","RORSETU2",9,0)
 ; .BNDRYDT      Date that represents a boundary between historical
"RTN","RORSETU2",10,0)
 ;               data extraction and regular data extracts is returned
"RTN","RORSETU2",11,0)
 ;               via this parameter.
"RTN","RORSETU2",12,0)
 ;
"RTN","RORSETU2",13,0)
 ; Return Values:
"RTN","RORSETU2",14,0)
 ;       <0  Error code
"RTN","RORSETU2",15,0)
 ;      >=0  Statistics
"RTN","RORSETU2",16,0)
 ;             ^1: Total number of processed records
"RTN","RORSETU2",17,0)
 ;             ^2: Number of records processed with errors
"RTN","RORSETU2",18,0)
 ;
"RTN","RORSETU2",19,0)
 ; The function calculates a date that will be a boundary between
"RTN","RORSETU2",20,0)
 ; historical data extraction and regular data extractions. This date
"RTN","RORSETU2",21,0)
 ; is stored to all records of the registry. Moreover, the date is
"RTN","RORSETU2",22,0)
 ; returned as a value of the second parameter.
"RTN","RORSETU2",23,0)
 ;
"RTN","RORSETU2",24,0)
BNDRYDT(REGIEN,BNDRYDT) ;
"RTN","RORSETU2",25,0)
 N CNT,DATE,ECNT,IEN,IENS,LD1,PATIEN,RC,ROOT,RORFDA,RORMSG,TMP
"RTN","RORSETU2",26,0)
 S ROOT=$$ROOT^DILFD(798,,1)
"RTN","RORSETU2",27,0)
 ;--- Get the lag period
"RTN","RORSETU2",28,0)
 S LD1=$$GET1^DIQ(798.1,REGIEN_",",15.1,,,"RORMSG")
"RTN","RORSETU2",29,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORSETU2",30,0)
 ;--- Calculate the date
"RTN","RORSETU2",31,0)
 S BNDRYDT=$$FMADD^XLFDT($$DT^XLFDT,-$S(LD1>0:LD1,1:1)-1)
"RTN","RORSETU2",32,0)
 ;--- Store the date into the records of the registry
"RTN","RORSETU2",33,0)
 S IEN="",(CNT,ECNT)=0
"RTN","RORSETU2",34,0)
 F  S IEN=$O(@ROOT@("AC",REGIEN,IEN))  Q:IEN=""  D
"RTN","RORSETU2",35,0)
 . S CNT=CNT+1,IENS=IEN_",",DATE=BNDRYDT
"RTN","RORSETU2",36,0)
 . ;--- Check the inactivation date
"RTN","RORSETU2",37,0)
 . S TMP=$$GET1^DIQ(798,IENS,2,"I",,"RORMSG")\1
"RTN","RORSETU2",38,0)
 . I $G(DIERR)  D  S ECNT=ECNT+1  Q
"RTN","RORSETU2",39,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9)
"RTN","RORSETU2",40,0)
 . I TMP>0  S:DATE>TMP DATE=TMP
"RTN","RORSETU2",41,0)
 . ;--- Update the record
"RTN","RORSETU2",42,0)
 . S RORFDA(798,IENS,9.1)=DATE
"RTN","RORSETU2",43,0)
 . S RORFDA(798,IENS,9.2)=DATE
"RTN","RORSETU2",44,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORSETU2",45,0)
 . I $G(DIERR)  D  S ECNT=ECNT+1  Q
"RTN","RORSETU2",46,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9)
"RTN","RORSETU2",47,0)
 Q $S(RC<0:-9,1:CNT_U_ECNT)
"RTN","RORSETU2",48,0)
 ;
"RTN","RORSETU2",49,0)
 ;***** CHECKS THE LAB SEARCH CRITERION
"RTN","RORSETU2",50,0)
 ;
"RTN","RORSETU2",51,0)
 ; LSNAME        Name of the Lab search criterion
"RTN","RORSETU2",52,0)
 ;
"RTN","RORSETU2",53,0)
 ; This function uses the ^TMP("DILIST",$J) global node.
"RTN","RORSETU2",54,0)
 ;
"RTN","RORSETU2",55,0)
 ; Return Values:
"RTN","RORSETU2",56,0)
 ;       <0  Error code
"RTN","RORSETU2",57,0)
 ;        0  Ok
"RTN","RORSETU2",58,0)
 ;
"RTN","RORSETU2",59,0)
LABSRCH(LSNAME) ;
"RTN","RORSETU2",60,0)
 N IEN,IENS,IR,LSICNT,RC,RORMSG,TMP
"RTN","RORSETU2",61,0)
 ;--- Find the definition
"RTN","RORSETU2",62,0)
 S IENS=$$FIND1^DIC(798.9,,"X",LSNAME,"B",,"RORMSG")_","
"RTN","RORSETU2",63,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORSETU2",64,0)
 Q:IENS'>0 $$ERROR^RORERR(-54,,,,LSNAME)
"RTN","RORSETU2",65,0)
 ;--- Load the search indicators
"RTN","RORSETU2",66,0)
 D LIST^DIC(798.92,","_IENS,"@;1I",,,,,"B",,,,"RORMSG")
"RTN","RORSETU2",67,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORSETU2",68,0)
 ;--- Check the search indicators
"RTN","RORSETU2",69,0)
 S IR="",LSICNT=0
"RTN","RORSETU2",70,0)
 F  S IR=$O(^TMP("DILIST",$J,"ID",IR))  Q:IR=""  D
"RTN","RORSETU2",71,0)
 . S:$G(^TMP("DILIST",$J,"ID",IR,1))>0 LSICNT=LSICNT+1
"RTN","RORSETU2",72,0)
 ;--- Process the errors (if any)
"RTN","RORSETU2",73,0)
 Q:LSICNT'>0 $$ERROR^RORERR(-55,,,,LSNAME)
"RTN","RORSETU2",74,0)
 Q 0
"RTN","RORSETU2",75,0)
 ;
"RTN","RORSETU2",76,0)
 ;***** PREPARES REGISTRY RECORDS
"RTN","RORSETU2",77,0)
 ;
"RTN","RORSETU2",78,0)
 ; RORREG        Registry IEN and registry name separated by the '^'
"RTN","RORSETU2",79,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORSETU2",80,0)
 ;
"RTN","RORSETU2",81,0)
 ; Return Values:
"RTN","RORSETU2",82,0)
 ;       <0  Error code
"RTN","RORSETU2",83,0)
 ;        0  Ok
"RTN","RORSETU2",84,0)
 ;
"RTN","RORSETU2",85,0)
PREPARE(RORREG) ;
"RTN","RORSETU2",86,0)
 ;;Data extraction boundary (historical/regular) has been established.
"RTN","RORSETU2",87,0)
 ;;Parameters of the historical data extraction have been updated.
"RTN","RORSETU2",88,0)
 ;
"RTN","RORSETU2",89,0)
 N DATE,RC,TMP
"RTN","RORSETU2",90,0)
 ;--- Modify records of the registry
"RTN","RORSETU2",91,0)
 S RC=$$BNDRYDT(+RORREG,.DATE)  Q:RC<0 RC
"RTN","RORSETU2",92,0)
 S TMP="Processed records: "_+RC_", Errors: "_+$P(RC,U,2)
"RTN","RORSETU2",93,0)
 D LOG^RORLOG(2,$P($T(PREPARE+1),";;",2),,TMP)
"RTN","RORSETU2",94,0)
 ;--- Update the registry parameters of historical data extraction
"RTN","RORSETU2",95,0)
 S RC=$$UPDHDTRP(+RORREG,DATE)  Q:RC<0 RC
"RTN","RORSETU2",96,0)
 D LOG^RORLOG(2,$P($T(PREPARE+2),";;",2))
"RTN","RORSETU2",97,0)
 Q 0
"RTN","RORSETU2",98,0)
 ;
"RTN","RORSETU2",99,0)
 ;***** UPDATES REGISTRY PARAMETERS OF THE HISTORICAL DATA EXTRACTION
"RTN","RORSETU2",100,0)
 ;
"RTN","RORSETU2",101,0)
 ; REGIEN        Registry IEN
"RTN","RORSETU2",102,0)
 ; HDTEDT        Date that represents a boundary between historical
"RTN","RORSETU2",103,0)
 ;               data extraction and regular data extracts
"RTN","RORSETU2",104,0)
 ;
"RTN","RORSETU2",105,0)
 ; Return Values:
"RTN","RORSETU2",106,0)
 ;       <0  Error code
"RTN","RORSETU2",107,0)
 ;        0  Ok
"RTN","RORSETU2",108,0)
 ;
"RTN","RORSETU2",109,0)
UPDHDTRP(REGIEN,HDTEDT) ;
"RTN","RORSETU2",110,0)
 N IENS,RC,RORFDA,RORMSG
"RTN","RORSETU2",111,0)
 S IENS=REGIEN_","
"RTN","RORSETU2",112,0)
 ;--- Prepare the data
"RTN","RORSETU2",113,0)
 S RORFDA(798.1,IENS,21.02)=HDTEDT           ; Historical End Date
"RTN","RORSETU2",114,0)
 S RORFDA(798.1,IENS,21.05)=$$NOW^XLFDT      ; Timestamp
"RTN","RORSETU2",115,0)
 ;--- Update historical data extraction parameters
"RTN","RORSETU2",116,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORSETU2",117,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORSETU2",118,0)
 ;--- Create the default data extraction task
"RTN","RORSETU2",119,0)
 S RC=$$CREATE^RORHDT02(REGIEN,1)
"RTN","RORSETU2",120,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORTSK")
0^1^B20559181
"RTN","RORTSK",1,0)
RORTSK ;HCIOFO/SG - TASK MANAGER ; 12/10/03 8:32am
"RTN","RORTSK",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORTSK",3,0)
 ;
"RTN","RORTSK",4,0)
 Q
"RTN","RORTSK",5,0)
 ;
"RTN","RORTSK",6,0)
 ;***** CREATES AND SCHEDULES A TASK
"RTN","RORTSK",7,0)
 ;
"RTN","RORTSK",8,0)
 ; TYPE          Type of the task (1 - Generic, 2 - Report)
"RTN","RORTSK",9,0)
 ;
"RTN","RORTSK",10,0)
 ; ZTRTN         The entry point TaskMan will DO to start the task.
"RTN","RORTSK",11,0)
 ;
"RTN","RORTSK",12,0)
 ;               This parameter can also have the $$TAG^ROUTINE
"RTN","RORTSK",13,0)
 ;               format. In this case, the "proxy task" will be used.
"RTN","RORTSK",14,0)
 ;               The value of the parameter will be saved in the
"RTN","RORTSK",15,0)
 ;               RORTSK("EP") node and the "TASK^RORTSK01" will be
"RTN","RORTSK",16,0)
 ;               assigned to the ZTRTN variable. See the TASK^RORTSK01
"RTN","RORTSK",17,0)
 ;               for more details.
"RTN","RORTSK",18,0)
 ;
"RTN","RORTSK",19,0)
 ; [.PARAMS]     Reference to a local variable that contains a list
"RTN","RORTSK",20,0)
 ;               of name-value pairs of the task parameters.
"RTN","RORTSK",21,0)
 ;               The parameters are passed to the task as sub-nodes
"RTN","RORTSK",22,0)
 ;               of the "PARAMS" node of the RORTSK local variable.
"RTN","RORTSK",23,0)
 ;
"RTN","RORTSK",24,0)
 ; [REGIEN]      Registry IEN (if $G(REGIEN)'>0 the task will not
"RTN","RORTSK",25,0)
 ;               be associated with any particular registry).
"RTN","RORTSK",26,0)
 ;
"RTN","RORTSK",27,0)
 ; [REPORT]      Code of the report (if the TYPE = 2).
"RTN","RORTSK",28,0)
 ;
"RTN","RORTSK",29,0)
 ; [SCHCODE]     Rescheduling code for the task. By default (if
"RTN","RORTSK",30,0)
 ;               $G(SCHCODE)=""), the task is executed once. See
"RTN","RORTSK",31,0)
 ;               description of the $$SCH^XLFDT function for
"RTN","RORTSK",32,0)
 ;               possible values of the parameter).
"RTN","RORTSK",33,0)
 ;
"RTN","RORTSK",34,0)
 ; All other input variables used by the %ZTLOAD (except the ZTRTN)
"RTN","RORTSK",35,0)
 ; can be used to control the task. Modifications of the default
"RTN","RORTSK",36,0)
 ; behavior of some of those variables are described below.
"RTN","RORTSK",37,0)
 ;
"RTN","RORTSK",38,0)
 ; [ZTDESC]      Task description
"RTN","RORTSK",39,0)
 ;
"RTN","RORTSK",40,0)
 ; [ZTDTH]       Date/time to start the task (FileMan). By default
"RTN","RORTSK",41,0)
 ;               (if $G(ZTDTH)=""), the task is scheduled to run
"RTN","RORTSK",42,0)
 ;               with a 3 second delay.
"RTN","RORTSK",43,0)
 ;
"RTN","RORTSK",44,0)
 ; [ZTIO]        Output device. By default (if $G(ZTIO)=""), the
"RTN","RORTSK",45,0)
 ;               task is started without an output device.
"RTN","RORTSK",46,0)
 ;
"RTN","RORTSK",47,0)
 ; [ZTSAVE]      List of variables that should be passed to the task.
"RTN","RORTSK",48,0)
 ;               The CREATE^RORTSK function adds the "RORTSK(" item
"RTN","RORTSK",49,0)
 ;               to the list if the task proxy is requested (see the
"RTN","RORTSK",50,0)
 ;               ZTRTN parameter for details) or the PARAMS parameter
"RTN","RORTSK",51,0)
 ;               is defined.
"RTN","RORTSK",52,0)
 ;
"RTN","RORTSK",53,0)
 ; Return values:
"RTN","RORTSK",54,0)
 ;       <0  Error code
"RTN","RORTSK",55,0)
 ;       >0  Task Number
"RTN","RORTSK",56,0)
 ;
"RTN","RORTSK",57,0)
CREATE(TYPE,ZTRTN,PARAMS,REGIEN,REPORT,SCHCODE) ;
"RTN","RORTSK",58,0)
 N DESCR,IENS,RC,RORFDA,RORIEN,RORMSG,RORTSK,RPTIEN,TMP,ZTSK
"RTN","RORTSK",59,0)
 S (RC,RPTIEN)=0
"RTN","RORTSK",60,0)
 I $G(REGIEN)>0  D  Q:RC<0 RC
"RTN","RORTSK",61,0)
 . I TYPE=2  D  I RPTIEN<0  S RC=RPTIEN  Q
"RTN","RORTSK",62,0)
 . . S RPTIEN=$$RPIEN^RORUTL08(REPORT,.DESCR)
"RTN","RORTSK",63,0)
 E  S REGIEN=0
"RTN","RORTSK",64,0)
 ;--- Task parameters
"RTN","RORTSK",65,0)
 I $D(PARAMS)>1  D  Q:RC<0 RC
"RTN","RORTSK",66,0)
 . S RC=$$PARAMS^RORTSK03(.PARAMS),ZTSAVE("RORTSK(")=""
"RTN","RORTSK",67,0)
 . ;--- If there is the TASK_DESCR parameter in
"RTN","RORTSK",68,0)
 . ;    the list use its value as the task description
"RTN","RORTSK",69,0)
 . ;--- (if the ZTDESC variable is not defined)
"RTN","RORTSK",70,0)
 . S TMP=$G(RORTSK("PARAMS","TASK_DESCR"))
"RTN","RORTSK",71,0)
 . S:TMP'="" DESCR=$E(TMP,1,200)
"RTN","RORTSK",72,0)
 ;--- Registry IEN
"RTN","RORTSK",73,0)
 D:'$D(RORTSK("PARAMS","REGIEN"))
"RTN","RORTSK",74,0)
 . S RORTSK("PARAMS","REGIEN")=+$G(REGIEN)
"RTN","RORTSK",75,0)
 ;--- Prepare the task description
"RTN","RORTSK",76,0)
 I $G(ZTDESC)=""  D  Q:RC<0 RC
"RTN","RORTSK",77,0)
 . I $G(DESCR)'=""  S ZTDESC=DESCR  Q
"RTN","RORTSK",78,0)
 . S DESCR=$$EXTERNAL^DILFD(798.8,.02,,TYPE,"RORMSG")
"RTN","RORTSK",79,0)
 . I $G(DIERR)  D  Q
"RTN","RORTSK",80,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,798.8)
"RTN","RORTSK",81,0)
 . S (DESCR,ZTDESC)=DESCR_" Task started from the GUI"
"RTN","RORTSK",82,0)
 E  S DESCR=ZTDESC
"RTN","RORTSK",83,0)
 S:$L(DESCR)>60 DESCR=$E(DESCR,1,57)_"..."
"RTN","RORTSK",84,0)
 ;--- Check if the task proxy should be used
"RTN","RORTSK",85,0)
 I $E(ZTRTN,1,2)="$$"  D  S ZTRTN="TASK^RORTSK01"
"RTN","RORTSK",86,0)
 . S RORTSK("EP")=ZTRTN,ZTSAVE("RORTSK(")=""
"RTN","RORTSK",87,0)
 . Q:$G(SCHCODE)=""
"RTN","RORTSK",88,0)
 . F TMP="TYPE","REGIEN","REPORT","SCHCODE"  D
"RTN","RORTSK",89,0)
 . . S RORTSK(TMP)=$G(@TMP)
"RTN","RORTSK",90,0)
 ;--- If the task is scheduled to run immediately, postpone the start
"RTN","RORTSK",91,0)
 ;--- for 3 seconds to make sure that the task record is created
"RTN","RORTSK",92,0)
 S TMP=$$NOW^XLFDT
"RTN","RORTSK",93,0)
 I $G(ZTDTH)>0,$$FMDIFF^XLFDT(ZTDTH,TMP,2)>3
"RTN","RORTSK",94,0)
 E  S ZTDTH=$$FMADD^XLFDT(TMP,,,,3)
"RTN","RORTSK",95,0)
 ;--- Schedule the task
"RTN","RORTSK",96,0)
 S:'($D(ZTIO)#10) ZTIO=""
"RTN","RORTSK",97,0)
 D ^%ZTLOAD
"RTN","RORTSK",98,0)
 Q:'$G(ZTSK) $$ERROR^RORERR(-82,,,,ZTRTN,ZTDTH)
"RTN","RORTSK",99,0)
 S RORTSK=ZTSK
"RTN","RORTSK",100,0)
 ;--- Prepare data for the record in the ROR TASK file
"RTN","RORTSK",101,0)
 S IENS="+1,"
"RTN","RORTSK",102,0)
 S (RORFDA(798.8,IENS,.01),RORIEN(1))=RORTSK    ; Task Number
"RTN","RORTSK",103,0)
 S RORFDA(798.8,IENS,.02)=+TYPE                 ; Type
"RTN","RORTSK",104,0)
 D:REGIEN>0
"RTN","RORTSK",105,0)
 . S RORFDA(798.8,IENS,.03)=+REGIEN             ; Registry
"RTN","RORTSK",106,0)
 . S:RPTIEN RORFDA(798.8,IENS,.04)=RPTIEN       ; IEN of report par.
"RTN","RORTSK",107,0)
 S RORFDA(798.8,IENS,.05)=DESCR                 ; Description
"RTN","RORTSK",108,0)
 ;--- Create the record
"RTN","RORTSK",109,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORTSK",110,0)
 I $G(DIERR)  D  Q RC
"RTN","RORTSK",111,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.8,IENS)
"RTN","RORTSK",112,0)
 . ;--- Try to unschedule the task if the record has not been created
"RTN","RORTSK",113,0)
 . S ZTSK=RORTSK  D DQ^%ZTLOAD
"RTN","RORTSK",114,0)
 Q RORTSK
"RTN","RORTSK",115,0)
 ;
"RTN","RORTSK",116,0)
 ;***** DEQUEUES AND/OR DELETES THE TASK
"RTN","RORTSK",117,0)
 ;
"RTN","RORTSK",118,0)
 ; TASK          Task number
"RTN","RORTSK",119,0)
 ;
"RTN","RORTSK",120,0)
 ; [DELETE]      Delete the task from the Taskman and the task
"RTN","RORTSK",121,0)
 ;               record from the ROR TASK file (#798.8) if this
"RTN","RORTSK",122,0)
 ;               parameter has a non-zero value.
"RTN","RORTSK",123,0)
 ;
"RTN","RORTSK",124,0)
 ; Return Values:
"RTN","RORTSK",125,0)
 ;       <0  Error code
"RTN","RORTSK",126,0)
 ;        0  Ok
"RTN","RORTSK",127,0)
 ;        1  No responce from the task
"RTN","RORTSK",128,0)
 ;
"RTN","RORTSK",129,0)
DEQUEUE(TASK,DELETE) ;
"RTN","RORTSK",130,0)
 N DA,DIK,I,RC,STATUS,TASKNODE,ZTSK
"RTN","RORTSK",131,0)
 S STATUS=+$$STATUS^RORTSK02(TASK,,1)
"RTN","RORTSK",132,0)
 I STATUS<0  Q $S(STATUS=-83:0,1:STATUS)
"RTN","RORTSK",133,0)
 S TASKNODE=$NA(^RORDATA(798.8,TASK))
"RTN","RORTSK",134,0)
 ;--- Unschedule the task
"RTN","RORTSK",135,0)
 I STATUS=1  S ZTSK=TASK  D DQ^%ZTLOAD
"RTN","RORTSK",136,0)
 ;--- Stop the task if it is running
"RTN","RORTSK",137,0)
 S STATUS=+$$STATUS^RORTSK02(TASK)
"RTN","RORTSK",138,0)
 S:(STATUS=2)!(STATUS=102) @TASKNODE@("A")=2
"RTN","RORTSK",139,0)
 Q:'$G(DELETE) 0
"RTN","RORTSK",140,0)
 ;--- Wait for a response from the task
"RTN","RORTSK",141,0)
 S STATUS=+$$STATUS^RORTSK02(TASK,3)  Q:STATUS<0 STATUS
"RTN","RORTSK",142,0)
 Q:STATUS=103 1
"RTN","RORTSK",143,0)
 ;--- Kill the REPORT ELEMENT multiple to avoid delays in ^DIK
"RTN","RORTSK",144,0)
 K @TASKNODE@("RI")
"RTN","RORTSK",145,0)
 ;--- Delete the task record
"RTN","RORTSK",146,0)
 S DIK="^RORDATA(798.8,",DA=TASK  D ^DIK
"RTN","RORTSK",147,0)
 Q 0
"RTN","RORTSK",148,0)
 ;
"RTN","RORTSK",149,0)
 ;***** RESUMES THE TASK
"RTN","RORTSK",150,0)
 ;
"RTN","RORTSK",151,0)
 ; TASK          Task number
"RTN","RORTSK",152,0)
 ;
"RTN","RORTSK",153,0)
 ; Return Values:
"RTN","RORTSK",154,0)
 ;       <0  Error code
"RTN","RORTSK",155,0)
 ;        0  Ok
"RTN","RORTSK",156,0)
 ;
"RTN","RORTSK",157,0)
RESUME(TASK) ;
"RTN","RORTSK",158,0)
 N STATUS
"RTN","RORTSK",159,0)
 S STATUS=+$$STATUS^RORTSK02(TASK,,1)  Q:STATUS<0 STATUS
"RTN","RORTSK",160,0)
 K ^RORDATA(798.8,TASK,"A")
"RTN","RORTSK",161,0)
 Q 0
"RTN","RORTSK",162,0)
 ;
"RTN","RORTSK",163,0)
 ;***** SUSPENDS THE TASK
"RTN","RORTSK",164,0)
 ;
"RTN","RORTSK",165,0)
 ; TASK          Task number
"RTN","RORTSK",166,0)
 ;
"RTN","RORTSK",167,0)
 ; Return Values:
"RTN","RORTSK",168,0)
 ;       <0  Error code
"RTN","RORTSK",169,0)
 ;        0  Ok
"RTN","RORTSK",170,0)
 ;
"RTN","RORTSK",171,0)
SUSPEND(TASK) ;
"RTN","RORTSK",172,0)
 N STATUS
"RTN","RORTSK",173,0)
 S STATUS=+$$STATUS^RORTSK02(TASK,,1)  Q:STATUS<0 STATUS
"RTN","RORTSK",174,0)
 S:(STATUS=1)!(STATUS=2) ^RORDATA(798.8,TASK,"A")=1
"RTN","RORTSK",175,0)
 Q 0
"RTN","RORTSK01")
0^2^B50638834
"RTN","RORTSK01",1,0)
RORTSK01 ;HCIOFO/SG - (SUB)TASK UTILITIES ; 1/21/04 9:51am
"RTN","RORTSK01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORTSK01",3,0)
 ;
"RTN","RORTSK01",4,0)
 ; These utilities should be called only from the tasks and subtasks
"RTN","RORTSK01",5,0)
 ; that are created and scheduled by the RORTSK API.
"RTN","RORTSK01",6,0)
 ;
"RTN","RORTSK01",7,0)
 ; The RORTSK local array is passed to the task. If the proxy task
"RTN","RORTSK01",8,0)
 ; is used then it passes this array by reference into the entry
"RTN","RORTSK01",9,0)
 ; point that implements the generic task or report.
"RTN","RORTSK01",10,0)
 ;
"RTN","RORTSK01",11,0)
 ; RORTSK(               Task Number
"RTN","RORTSK01",12,0)
 ;
"RTN","RORTSK01",13,0)
 ;   "PARAMS",...)       Report Parameters
"RTN","RORTSK01",14,0)
 ;   "TPP-PREV")         Previous value of task progress percentage
"RTN","RORTSK01",15,0)
 ;
"RTN","RORTSK01",16,0)
 ; If the proxy task is used, additional nodes are created:
"RTN","RORTSK01",17,0)
 ;
"RTN","RORTSK01",18,0)
 ;   "EP")               Entry Point
"RTN","RORTSK01",19,0)
 ;   "TYPE")             Type of the Task
"RTN","RORTSK01",20,0)
 ;   "REGIEN")           Registry IEN
"RTN","RORTSK01",21,0)
 ;   "REPORT")           Code of the Report
"RTN","RORTSK01",22,0)
 ;   "SCHCODE")          Rescheduling Code
"RTN","RORTSK01",23,0)
 ;
"RTN","RORTSK01",24,0)
 ; See descriptions of the REPORT BUILDER field (10.01) of the
"RTN","RORTSK01",25,0)
 ; ROR REPORT PARAMETERS file (#799.34) and the ROR REPORT SCHEDULE
"RTN","RORTSK01",26,0)
 ; remote procedure for more details.
"RTN","RORTSK01",27,0)
 ;
"RTN","RORTSK01",28,0)
 Q
"RTN","RORTSK01",29,0)
 ;
"RTN","RORTSK01",30,0)
 ;***** ALERT PROCESSING ENTRY POINT
"RTN","RORTSK01",31,0)
ALERTRTN ;
"RTN","RORTSK01",32,0)
 N I,PARAMS,RORBUF
"RTN","RORTSK01",33,0)
 S PARAMS("TASKDESCR")=$G(XQADATA)
"RTN","RORTSK01",34,0)
 D BLD^DIALOG(7980000.019,.PARAMS,,"RORBUF")
"RTN","RORTSK01",35,0)
 S I=""  W !
"RTN","RORTSK01",36,0)
 F  S I=$O(RORBUF(I))  Q:I=""  W !,RORBUF(I)
"RTN","RORTSK01",37,0)
 Q
"RTN","RORTSK01",38,0)
 ;
"RTN","RORTSK01",39,0)
 ;***** (SUB)TASK CLEANUP
"RTN","RORTSK01",40,0)
 ;
"RTN","RORTSK01",41,0)
 ; ERRCODE       Error code of the task
"RTN","RORTSK01",42,0)
 ; [PARENT]      Parent task for the subtask
"RTN","RORTSK01",43,0)
 ;
"RTN","RORTSK01",44,0)
 ; Return Values:
"RTN","RORTSK01",45,0)
 ;       <0  Error code
"RTN","RORTSK01",46,0)
 ;        0  Ok
"RTN","RORTSK01",47,0)
 ;
"RTN","RORTSK01",48,0)
EXIT(ERRCODE,PARENT) ;
"RTN","RORTSK01",49,0)
 N IENS,RC,RORFDA,RORMSG,STATUS,TASKNODE
"RTN","RORTSK01",50,0)
 S RC=0,STATUS=$S(ERRCODE<0:101,1:3),ZTREQ="@"
"RTN","RORTSK01",51,0)
 ;=== SUBTASK
"RTN","RORTSK01",52,0)
 I $G(PARENT)  D  Q RC
"RTN","RORTSK01",53,0)
 . ;--- Not implemented
"RTN","RORTSK01",54,0)
 ;=== TASK
"RTN","RORTSK01",55,0)
 S TASKNODE=$NA(^RORDATA(798.8,RORTSK))
"RTN","RORTSK01",56,0)
 ;--- Send an alert to the user who has started the task
"RTN","RORTSK01",57,0)
 D:$G(DUZ)>0
"RTN","RORTSK01",58,0)
 . N XQA,XQADATA,XQAFLG,XQAMSG,XQAROU
"RTN","RORTSK01",59,0)
 . S XQA(DUZ)="",XQAFLG="D"
"RTN","RORTSK01",60,0)
 . S XQAMSG="ROR: "_$$MSG^RORERR20(-101,,,RORTSK)
"RTN","RORTSK01",61,0)
 . S XQADATA=$$GET1^DIQ(798.8,RORTSK,.05,,,"RORMSG")
"RTN","RORTSK01",62,0)
 . S XQAROU="ALERTRTN^RORTSK01"
"RTN","RORTSK01",63,0)
 . D SETUP^XQALERT
"RTN","RORTSK01",64,0)
 ;--- Update/Delete the task record
"RTN","RORTSK01",65,0)
 S IENS=RORTSK_","
"RTN","RORTSK01",66,0)
 I +$G(@TASKNODE@("A"))'=2  D
"RTN","RORTSK01",67,0)
 . S RORFDA(798.8,IENS,2.01)=STATUS      ; Status
"RTN","RORTSK01",68,0)
 . S RORFDA(798.8,IENS,2.02)=$$NOW^XLFDT ; Completion Time
"RTN","RORTSK01",69,0)
 . S RORFDA(798.8,IENS,2.04)="@"         ; Job Number
"RTN","RORTSK01",70,0)
 . S RORFDA(798.8,IENS,4)="@"            ; Progress
"RTN","RORTSK01",71,0)
 E  S RORFDA(798.8,IENS,.01)="@"
"RTN","RORTSK01",72,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORTSK01",73,0)
 S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,798.8,IENS)
"RTN","RORTSK01",74,0)
 ;--- Cleanup
"RTN","RORTSK01",75,0)
 K @TASKNODE@("A"),@TASKNODE@("T")
"RTN","RORTSK01",76,0)
 L -@TASKNODE@("T",0)
"RTN","RORTSK01",77,0)
 Q RC
"RTN","RORTSK01",78,0)
 ;
"RTN","RORTSK01",79,0)
 ;***** INITIALIZES THE (SUB)TASK
"RTN","RORTSK01",80,0)
 ;
"RTN","RORTSK01",81,0)
 ; TASK          Task number
"RTN","RORTSK01",82,0)
 ; [LOG]         Log IEN (returned by the $$LOGIEN^RORLOG function)
"RTN","RORTSK01",83,0)
 ; [PARENT]      Parent task for the subtask
"RTN","RORTSK01",84,0)
 ;
"RTN","RORTSK01",85,0)
 ; Return Values:
"RTN","RORTSK01",86,0)
 ;       <0  Error code
"RTN","RORTSK01",87,0)
 ;        0  Ok
"RTN","RORTSK01",88,0)
 ;
"RTN","RORTSK01",89,0)
INIT(TASK,LOG,PARENT) ;
"RTN","RORTSK01",90,0)
 N I,RC,RORDTH,RORFDA,RORMSG,TASKNODE
"RTN","RORTSK01",91,0)
 S RORDTH=$G(ZTDTH)  S:RORDTH'>0 RORDTH=$$NOW^XLFDT
"RTN","RORTSK01",92,0)
 S RC=0,RORTSK=+TASK  K RORTSK("PREVTPP")
"RTN","RORTSK01",93,0)
 ;=== SUBTASK
"RTN","RORTSK01",94,0)
 I $G(PARENT)  S RC=0  D  Q RC
"RTN","RORTSK01",95,0)
 . ;--- Not implemented
"RTN","RORTSK01",96,0)
 ;=== TASK
"RTN","RORTSK01",97,0)
 S TASKNODE=$NA(^RORDATA(798.8,RORTSK))
"RTN","RORTSK01",98,0)
 ;--- Schedule the next instance of the task (if requested)
"RTN","RORTSK01",99,0)
 D:$G(RORTSK("SCHCODE"))'=""
"RTN","RORTSK01",100,0)
 . N EP,TYPE,REGIEN,REPORT,SCHCODE
"RTN","RORTSK01",101,0)
 . N ZTCPU,ZTDTH,ZTIO,ZTKIL,ZTPRI,ZTSAVE,ZTSYNC,ZTUCI
"RTN","RORTSK01",102,0)
 . F I="EP","TYPE","REGIEN","REPORT","SCHCODE"  S @I=$G(RORTSK(I))
"RTN","RORTSK01",103,0)
 . Q:(TYPE'>0)!(EP="")
"RTN","RORTSK01",104,0)
 . S ZTDTH=$$SCH^XLFDT(SCHCODE,RORDTH,1)
"RTN","RORTSK01",105,0)
 . S TMP=$$CREATE^RORTSK(TYPE,EP,.RORTSK,REGIEN,REPORT,SCHCODE)
"RTN","RORTSK01",106,0)
 ;--- Wait until the task record is created
"RTN","RORTSK01",107,0)
 S RC=$$TRWAIT(RORTSK)  Q:RC<0 RC
"RTN","RORTSK01",108,0)
 ;--- Lock the task record
"RTN","RORTSK01",109,0)
 L +@TASKNODE@("T",0):5
"RTN","RORTSK01",110,0)
 E  Q $$ERROR^RORERR(-11,,,,"the ROR TASK file")
"RTN","RORTSK01",111,0)
 ;--- Clear the list of subtasks
"RTN","RORTSK01",112,0)
 K @TASKNODE@("T")
"RTN","RORTSK01",113,0)
 ;--- Update the task record
"RTN","RORTSK01",114,0)
 S IENS=RORTSK_","
"RTN","RORTSK01",115,0)
 S RORFDA(798.8,IENS,2.01)=100         ; STATUS = 'Crashed'
"RTN","RORTSK01",116,0)
 S RORFDA(798.8,IENS,2.03)=$G(LOG)     ; Log IEN
"RTN","RORTSK01",117,0)
 S RORFDA(798.8,IENS,2.04)=$J          ; Job Number
"RTN","RORTSK01",118,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORTSK01",119,0)
 S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,798.8,IENS)
"RTN","RORTSK01",120,0)
 Q RC
"RTN","RORTSK01",121,0)
 ;
"RTN","RORTSK01",122,0)
 ;***** TASK CONTROL FUNCTION
"RTN","RORTSK01",123,0)
 ;
"RTN","RORTSK01",124,0)
 ; [TPP]         Task/Section progress (0-1)
"RTN","RORTSK01",125,0)
 ;
"RTN","RORTSK01",126,0)
 ; Return Values:
"RTN","RORTSK01",127,0)
 ;       <0  Error code
"RTN","RORTSK01",128,0)
 ;        0  Ok
"RTN","RORTSK01",129,0)
 ;
"RTN","RORTSK01",130,0)
LOOP(TPP) ;
"RTN","RORTSK01",131,0)
 N ACTION,OFFSET,RC
"RTN","RORTSK01",132,0)
 ;--- Update the task progress percentage
"RTN","RORTSK01",133,0)
 D:$G(TPP)'=""
"RTN","RORTSK01",134,0)
 . I TPP'<0,TPP'>1  D  S TPP=+$J(TPP,0,2)
"RTN","RORTSK01",135,0)
 . . S TPP=TPP*$G(RORTSK("TPP-BASE"),100)+$G(RORTSK("TPP-OFFS"))
"RTN","RORTSK01",136,0)
 . E  S TPP=""
"RTN","RORTSK01",137,0)
 . Q:TPP=$G(RORTSK("TPP-PREV"))
"RTN","RORTSK01",138,0)
 . S (^RORDATA(798.8,RORTSK,"P"),RORTSK("TPP-PREV"))=TPP
"RTN","RORTSK01",139,0)
 ;--- Requested action
"RTN","RORTSK01",140,0)
 S ACTION=$S($$S^%ZTLOAD:2,1:+$G(^RORDATA(798.8,RORTSK,"A")))
"RTN","RORTSK01",141,0)
 Q:'ACTION 0
"RTN","RORTSK01",142,0)
 ;=== SUSPEND THE TASK
"RTN","RORTSK01",143,0)
 I ACTION=1  S RC=0  D  Q RC
"RTN","RORTSK01",144,0)
 . N IENS,RORFDA,RORMSG
"RTN","RORTSK01",145,0)
 . S IENS=RORTSK_","
"RTN","RORTSK01",146,0)
 . ;--- Update the task status
"RTN","RORTSK01",147,0)
 . S RORFDA(798.8,IENS,2.01)=102      ; STATUS = 'Suspended'
"RTN","RORTSK01",148,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORTSK01",149,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,798.8,IENS)
"RTN","RORTSK01",150,0)
 . ;--- Suspension cycle
"RTN","RORTSK01",151,0)
 . F  H 60  D  Q:ACTION'=1
"RTN","RORTSK01",152,0)
 . . S ACTION=$S($$S^%ZTLOAD:2,1:+$G(^RORDATA(798.8,RORTSK,"A")))
"RTN","RORTSK01",153,0)
 . ;--- Restore the default task status
"RTN","RORTSK01",154,0)
 . S RORFDA(798.8,IENS,2.01)=100      ; STATUS = 'Crashed'
"RTN","RORTSK01",155,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORTSK01",156,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,798.8,IENS)
"RTN","RORTSK01",157,0)
 ;=== STOP THE TASK
"RTN","RORTSK01",158,0)
 I ACTION=2  D  Q $$ERROR^RORERR(-42)
"RTN","RORTSK01",159,0)
 . S ZTSTOP=1
"RTN","RORTSK01",160,0)
 Q 0
"RTN","RORTSK01",161,0)
 ;
"RTN","RORTSK01",162,0)
 ;***** RETURNS THE VALUE OF THE TASK PARAMETER
"RTN","RORTSK01",163,0)
PARAM(NAME) ;
"RTN","RORTSK01",164,0)
 Q $G(RORTSK("PARAMS",NAME))
"RTN","RORTSK01",165,0)
 ;
"RTN","RORTSK01",166,0)
 ;***** TASK PROXY
"RTN","RORTSK01",167,0)
 ;
"RTN","RORTSK01",168,0)
 ; RORTSK("EP")  This node must contain name of the task entry point
"RTN","RORTSK01",169,0)
 ;               ($$TAG^ROUTINE). The function should return either
"RTN","RORTSK01",170,0)
 ;               a negative error code or zero.
"RTN","RORTSK01",171,0)
 ;
"RTN","RORTSK01",172,0)
TASK ;
"RTN","RORTSK01",173,0)
 N RORCACHE      ; Cache of element and attribute names
"RTN","RORTSK01",174,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORTSK01",175,0)
 N RORPARM       ; Application parameters
"RTN","RORTSK01",176,0)
 ;
"RTN","RORTSK01",177,0)
 N ACTIVITY,I,INFO,RC,REGLST,RORERRDL,TASKINFO,TMP,TRC
"RTN","RORTSK01",178,0)
 S RORTSK=ZTSK
"RTN","RORTSK01",179,0)
 ;--- Initialize constants and variables
"RTN","RORTSK01",180,0)
 D INIT^RORUTL01("ROR")
"RTN","RORTSK01",181,0)
 ;S RORPARM("DEBUG")=1 ; Remove the first ';' to start in debug mode
"RTN","RORTSK01",182,0)
 S RORPARM("ERR")=1    ; Enable enhanced error processing
"RTN","RORTSK01",183,0)
 S RORPARM("LOG")=1    ; Enable error recording
"RTN","RORTSK01",184,0)
 ;--- Wait until the task record is created
"RTN","RORTSK01",185,0)
 S TMP=$$TRWAIT(RORTSK)
"RTN","RORTSK01",186,0)
 ;--- Get the task information
"RTN","RORTSK01",187,0)
 S TRC=$$TASKINFO^RORTSK02(RORTSK,.TASKINFO,"E")
"RTN","RORTSK01",188,0)
 ;--- Open a task log
"RTN","RORTSK01",189,0)
 S TMP=$P($G(TASKINFO(3)),U,2)  S:TMP'="" REGLST(TMP)=""
"RTN","RORTSK01",190,0)
 S ACTIVITY=$S(+$G(TASKINFO(2))=2:5,1:0)
"RTN","RORTSK01",191,0)
 S TMP=$$SETUP^RORLOG(.REGLST)
"RTN","RORTSK01",192,0)
 S RC=$$OPEN^RORLOG(.REGLST,ACTIVITY,"TASK #"_RORTSK_" STARTED")
"RTN","RORTSK01",193,0)
 ;--- Abort the task if task information was not available
"RTN","RORTSK01",194,0)
 I TRC<0  D:RC'<0  Q
"RTN","RORTSK01",195,0)
 . S TMP=$$ERROR^RORERR(-56,,,,TRC,"$$TASKINFO^RORTSK02")
"RTN","RORTSK01",196,0)
 . D CLOSE^RORLOG("TASK #"_RORTSK_" ABORTED")
"RTN","RORTSK01",197,0)
 D
"RTN","RORTSK01",198,0)
 . ;--- Record the task information (if available)
"RTN","RORTSK01",199,0)
 . S I=0,TMP=$G(TASKINFO(5))
"RTN","RORTSK01",200,0)
 . S:TMP'="" I=I+1,INFO(I)="Description: '"_TMP_"'"
"RTN","RORTSK01",201,0)
 . S TMP=$P($G(TASKINFO(8)),U,2)
"RTN","RORTSK01",202,0)
 . S:TMP'="" I=I+1,INFO(I)="User:        '"_TMP_"'"
"RTN","RORTSK01",203,0)
 . S TMP=$P($G(TASKINFO(4)),U,2)
"RTN","RORTSK01",204,0)
 . S:TMP'="" I=I+1,INFO(I)="Report:      '"_TMP_"'"
"RTN","RORTSK01",205,0)
 . D:I LOG^RORLOG(2,"Task Information",,.INFO)
"RTN","RORTSK01",206,0)
 . ;--- Verify the entry point
"RTN","RORTSK01",207,0)
 . S RC=$$VERIFYEP^RORUTL01($G(RORTSK("EP")),1)  Q:RC<0
"RTN","RORTSK01",208,0)
 . ;--- Initialize the task
"RTN","RORTSK01",209,0)
 . S RC=$$INIT(RORTSK,$$LOGIEN^RORLOG)  Q:RC<0
"RTN","RORTSK01",210,0)
 . K ACTIVITY,INFO,REGLST,TASKINFO,TMP
"RTN","RORTSK01",211,0)
 . ;--- Call the entry point
"RTN","RORTSK01",212,0)
 . X "S TRC="_RORTSK("EP")_"(.RORTSK)"
"RTN","RORTSK01",213,0)
 ;
"RTN","RORTSK01",214,0)
 ;--- Post-processing
"RTN","RORTSK01",215,0)
 S TMP=$$EXIT(TRC)
"RTN","RORTSK01",216,0)
 ;--- Close the log
"RTN","RORTSK01",217,0)
 S TMP="TASK #"_RORTSK_$S(TRC<0:" ABORTED",1:" COMPLETED")
"RTN","RORTSK01",218,0)
 D CLOSE^RORLOG(TMP)
"RTN","RORTSK01",219,0)
 Q
"RTN","RORTSK01",220,0)
 ;
"RTN","RORTSK01",221,0)
 ;***** SETS THE BASE VALUE FOR THE PROGRESS INDICATOR
"RTN","RORTSK01",222,0)
 ;
"RTN","RORTSK01",223,0)
 ; BASE          Base value for the progress indicator (0-100)
"RTN","RORTSK01",224,0)
 ;
"RTN","RORTSK01",225,0)
TPPSETUP(BASE) ;
"RTN","RORTSK01",226,0)
 I $G(BASE)'>0  K RORTSK("TPP-BASE"),RORTSK("TPP-OFFS")  Q
"RTN","RORTSK01",227,0)
 N TMP
"RTN","RORTSK01",228,0)
 S RORTSK("TPP-OFFS")=$G(RORTSK("TPP-OFFS"))+$G(RORTSK("TPP-BASE"))
"RTN","RORTSK01",229,0)
 S TMP=100-$G(RORTSK("TPP-OFFS"))
"RTN","RORTSK01",230,0)
 S RORTSK("TPP-BASE")=$S(BASE<TMP:BASE,1:TMP)
"RTN","RORTSK01",231,0)
 S TMP=$$LOOP(0)
"RTN","RORTSK01",232,0)
 Q
"RTN","RORTSK01",233,0)
 ;
"RTN","RORTSK01",234,0)
 ;***** WAITS UNTIL THE TASK RECORD IS CREATED
"RTN","RORTSK01",235,0)
 ;
"RTN","RORTSK01",236,0)
 ; TASK          Task number
"RTN","RORTSK01",237,0)
 ;
"RTN","RORTSK01",238,0)
 ; Return Values:
"RTN","RORTSK01",239,0)
 ;       <0  Error code
"RTN","RORTSK01",240,0)
 ;        0  Ok
"RTN","RORTSK01",241,0)
 ;
"RTN","RORTSK01",242,0)
TRWAIT(TASK) ;
"RTN","RORTSK01",243,0)
 N I  F I=1:1:5  Q:$D(^RORDATA(798.8,TASK,0))  H 1
"RTN","RORTSK01",244,0)
 Q $S($D(^RORDATA(798.8,TASK,0)):0,1:$$ERROR^RORERR(-83,,,,TASK))
"RTN","RORTSK02")
0^4^B26620629
"RTN","RORTSK02",1,0)
RORTSK02 ;HCIOFO/SG - TASK MANAGER UTILITIES ; 12/3/03 10:25am
"RTN","RORTSK02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORTSK02",3,0)
 ;
"RTN","RORTSK02",4,0)
 Q
"RTN","RORTSK02",5,0)
 ;
"RTN","RORTSK02",6,0)
 ;***** RETURNS A LIST OF USER'S TASKS
"RTN","RORTSK02",7,0)
 ;
"RTN","RORTSK02",8,0)
 ; .TASKLIST     Reference to a local array that the task
"RTN","RORTSK02",9,0)
 ;               list is returned to
"RTN","RORTSK02",10,0)
 ;
"RTN","RORTSK02",11,0)
 ; [REGIEN]      Registry IEN
"RTN","RORTSK02",12,0)
 ;
"RTN","RORTSK02",13,0)
 ; [TYPE]        Type of the task (1 - Generic, 2 - Report)
"RTN","RORTSK02",14,0)
 ;
"RTN","RORTSK02",15,0)
 ; [.FROM]       Where to start/continue the list generation.
"RTN","RORTSK02",16,0)
 ;               By defualt (if $G(FROM)'>0), the extraction starts
"RTN","RORTSK02",17,0)
 ;               from the beginning of the user's task list.
"RTN","RORTSK02",18,0)
 ;
"RTN","RORTSK02",19,0)
 ;               NOTE: The task, which number is passed via this
"RTN","RORTSK02",20,0)
 ;               parameter, is not included in the report.
"RTN","RORTSK02",21,0)
 ;
"RTN","RORTSK02",22,0)
 ;               After the call, this parameter contains the last
"RTN","RORTSK02",23,0)
 ;               extracted task number or an empty string if there
"RTN","RORTSK02",24,0)
 ;               are no more tasks.
"RTN","RORTSK02",25,0)
 ;
"RTN","RORTSK02",26,0)
 ; [NUMBER]      Maximum number of tasks returned by the function.
"RTN","RORTSK02",27,0)
 ;               By default (if $G(NUMBER)'>0), all task numbers
"RTN","RORTSK02",28,0)
 ;               (starting from the point indicated by the FROM
"RTN","RORTSK02",29,0)
 ;               parameter if it is defined) are retrieved.
"RTN","RORTSK02",30,0)
 ;
"RTN","RORTSK02",31,0)
 ; [USER]        A user IEN (DUZ). By default (if $G(USER)'>0),
"RTN","RORTSK02",32,0)
 ;               the curent user's DUZ is used.
"RTN","RORTSK02",33,0)
 ;
"RTN","RORTSK02",34,0)
 ; Return values:
"RTN","RORTSK02",35,0)
 ;       <0  Error code
"RTN","RORTSK02",36,0)
 ;        0  No tasks have been found
"RTN","RORTSK02",37,0)
 ;       >0  Number of tasks
"RTN","RORTSK02",38,0)
 ;
"RTN","RORTSK02",39,0)
LIST(TASKLIST,REGIEN,TYPE,FROM,NUMBER,USER) ;
"RTN","RORTSK02",40,0)
 N DIR,NTSK,RC,ROOT,RORBUF,SCR,TASK  K TASKLIST
"RTN","RORTSK02",41,0)
 S ROOT=$$ROOT^DILFD(798.8,,1)
"RTN","RORTSK02",42,0)
 S USER=$S($G(USER)>0:+USER,1:+$G(DUZ))
"RTN","RORTSK02",43,0)
 S DIR=$S($$UP^XLFSTR($G(NUMBER))["B":-1,1:1)
"RTN","RORTSK02",44,0)
 S NUMBER=$S($G(NUMBER)>0:+NUMBER,1:999999)
"RTN","RORTSK02",45,0)
 ;--- Generate a screen logic
"RTN","RORTSK02",46,0)
 S SCR="I 1"
"RTN","RORTSK02",47,0)
 S:$G(REGIEN)>0 SCR=SCR_","_"$P(RORBUF,U,3)="_(+REGIEN)
"RTN","RORTSK02",48,0)
 S:$G(TYPE)>0 SCR=SCR_","_"$P(RORBUF,U,2)="_(+TYPE)
"RTN","RORTSK02",49,0)
 ;--- Generate the output list
"RTN","RORTSK02",50,0)
 S TASK=$S($G(FROM)>0:FROM,1:""),NTSK=0
"RTN","RORTSK02",51,0)
 F  S TASK=$O(@ROOT@("U",USER,TASK),DIR)  Q:TASK=""  D  Q:NTSK'<NUMBER
"RTN","RORTSK02",52,0)
 . S RORBUF=$G(@ROOT@(TASK,0))  X SCR  E  Q
"RTN","RORTSK02",53,0)
 . S NTSK=NTSK+1,TASKLIST(TASK)=""
"RTN","RORTSK02",54,0)
 S FROM=TASK
"RTN","RORTSK02",55,0)
 Q NTSK
"RTN","RORTSK02",56,0)
 ;
"RTN","RORTSK02",57,0)
 ;***** PURGES THE OLD TASKS
"RTN","RORTSK02",58,0)
 ;
"RTN","RORTSK02",59,0)
 ; [DKEEP]       Days to keep the old tasks (by default = 15)
"RTN","RORTSK02",60,0)
 ;
"RTN","RORTSK02",61,0)
 ; Return Values:
"RTN","RORTSK02",62,0)
 ;       <0  Error code
"RTN","RORTSK02",63,0)
 ;        0  Ok
"RTN","RORTSK02",64,0)
 ;
"RTN","RORTSK02",65,0)
PURGE(DKEEP) ;
"RTN","RORTSK02",66,0)
 N DA,DATE,DIK,FROM,RC,STATUS,TASK,TASKINFO
"RTN","RORTSK02",67,0)
 S ROOT=$$ROOT^DILFD(798.8,,1),DIK=$$OREF^DILF(ROOT)
"RTN","RORTSK02",68,0)
 S FROM=$$FMADD^XLFDT($$DT^XLFDT,1-$G(DKEEP,15))
"RTN","RORTSK02",69,0)
 ;---
"RTN","RORTSK02",70,0)
 S DATE=FROM,RC=0
"RTN","RORTSK02",71,0)
 F  S DATE=$O(@ROOT@("ACDT",DATE),-1)  Q:DATE=""  D
"RTN","RORTSK02",72,0)
 . S TASK=""
"RTN","RORTSK02",73,0)
 . F  S TASK=$O(@ROOT@("ACDT",DATE,TASK),-1)  Q:TASK=""  D
"RTN","RORTSK02",74,0)
 . . Q:$$TASKINFO(TASK,.TASKINFO)<0
"RTN","RORTSK02",75,0)
 . . S STATUS=+TASKINFO(6)
"RTN","RORTSK02",76,0)
 . . ;--- Do not delete pending, running and suspended tasks
"RTN","RORTSK02",77,0)
 . . Q:(STATUS=1)!(STATUS=2)!(STATUS=102)
"RTN","RORTSK02",78,0)
 . . ;--- If task is completed, use its completion
"RTN","RORTSK02",79,0)
 . . ;--- date instead of the creation date
"RTN","RORTSK02",80,0)
 . . I TASKINFO(9)>DATE  Q:TASKINFO(9)'<FROM
"RTN","RORTSK02",81,0)
 . . ;--- Delete the record
"RTN","RORTSK02",82,0)
 . . S DA=TASK  D ^DIK
"RTN","RORTSK02",83,0)
 ;---
"RTN","RORTSK02",84,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORTSK02",85,0)
 ;
"RTN","RORTSK02",86,0)
 ;***** RETURNS STATUS OF THE TASK
"RTN","RORTSK02",87,0)
 ;
"RTN","RORTSK02",88,0)
 ; TASK          Task number
"RTN","RORTSK02",89,0)
 ; [LTO]         LOCK timeout (0 by default)
"RTN","RORTSK02",90,0)
 ; [UNDEF83]     Return the error -83 if there is no task record.
"RTN","RORTSK02",91,0)
 ;               By default (if +$G(UNDEF83)=0), zero is returned.
"RTN","RORTSK02",92,0)
 ;
"RTN","RORTSK02",93,0)
 ; Return Values:
"RTN","RORTSK02",94,0)
 ;       <0  Error code
"RTN","RORTSK02",95,0)
 ;        0  Undefined task/Unknown Status
"RTN","RORTSK02",96,0)
 ;       >0  Status (Code^Description)
"RTN","RORTSK02",97,0)
 ;
"RTN","RORTSK02",98,0)
 ;               1  Active: Pending
"RTN","RORTSK02",99,0)
 ;               2  Active: Running
"RTN","RORTSK02",100,0)
 ;               3  Inactive: Finished
"RTN","RORTSK02",101,0)
 ;               4  Inactive: Available
"RTN","RORTSK02",102,0)
 ;               5  Inactive: Interrupted
"RTN","RORTSK02",103,0)
 ;
"RTN","RORTSK02",104,0)
 ;             100  Inactive: Crashed
"RTN","RORTSK02",105,0)
 ;             101  Inactive: Errors
"RTN","RORTSK02",106,0)
 ;             102  Active: Suspended
"RTN","RORTSK02",107,0)
 ;             103  Active: Stopping
"RTN","RORTSK02",108,0)
 ;
"RTN","RORTSK02",109,0)
STATUS(TASK,LTO,UNDEF83) ;
"RTN","RORTSK02",110,0)
 N ACTION,IENS,RORBUF,RORMSG,STATUS,TASKNODE,TMS,ZTSK
"RTN","RORTSK02",111,0)
 Q:TASK'>0 $$ERROR^RORERR(-85,,,,TASK)
"RTN","RORTSK02",112,0)
 S TASKNODE=$NA(^RORDATA(798.8,TASK))
"RTN","RORTSK02",113,0)
 I '$D(@TASKNODE)  Q:'$G(UNDEF83) 0  D  Q STATUS
"RTN","RORTSK02",114,0)
 . S STATUS=$$ERROR^RORERR(-83,,,,TASK)
"RTN","RORTSK02",115,0)
 ;--- Get internal value of the STATUS feild (2.01)
"RTN","RORTSK02",116,0)
 S STATUS=+$G(@TASKNODE@(2))
"RTN","RORTSK02",117,0)
 ;--- Lock the record and check if the task is running
"RTN","RORTSK02",118,0)
 L +@TASKNODE@("T",0):$G(LTO,0)
"RTN","RORTSK02",119,0)
 E  S TMS=""  D  Q:TMS'="" TMS
"RTN","RORTSK02",120,0)
 . S ACTION=+$G(@TASKNODE@("A"))
"RTN","RORTSK02",121,0)
 . I ACTION=2    S TMS="103^Active: Stopping"   Q
"RTN","RORTSK02",122,0)
 . I STATUS=100  S TMS="2^Active: Running"      Q
"RTN","RORTSK02",123,0)
 . I STATUS=102  S TMS="102^Active: Suspended"  Q
"RTN","RORTSK02",124,0)
 D
"RTN","RORTSK02",125,0)
 . ;--- Try to get status from the Taskman
"RTN","RORTSK02",126,0)
 . S ZTSK=TASK  D STAT^%ZTLOAD
"RTN","RORTSK02",127,0)
 . S TMS=$S($G(ZTSK(0)):+$G(ZTSK(1)),1:0)
"RTN","RORTSK02",128,0)
 . ;--- Pending, Running or Available
"RTN","RORTSK02",129,0)
 . I (TMS=1)!(TMS=2)!(TMS=4)  S STATUS=TMS_U_$G(ZTSK(2))  Q
"RTN","RORTSK02",130,0)
 . ;--- Finished, Interrupted or Undefined
"RTN","RORTSK02",131,0)
 . I 'STATUS  S:TMS STATUS=TMS_U_$G(ZTSK(2))  Q
"RTN","RORTSK02",132,0)
 . ;--- If the task record is not locked and the STATUS field shows
"RTN","RORTSK02",133,0)
 . ;    'Suspended' (102) then the task probably crashed while it
"RTN","RORTSK02",134,0)
 . ;--- was in the suspended state
"RTN","RORTSK02",135,0)
 . S:STATUS=102 STATUS=100
"RTN","RORTSK02",136,0)
 . ;--- Get external value of the STATUS field
"RTN","RORTSK02",137,0)
 . S $P(STATUS,U,2)=$$EXTERNAL^DILFD(798.8,2.01,,STATUS,"RORMSG")
"RTN","RORTSK02",138,0)
 . S:$G(DIERR) STATUS=$$DBS^RORERR("RORMSG",-9,,,798.8)
"RTN","RORTSK02",139,0)
 ;
"RTN","RORTSK02",140,0)
 ;--- Unlock the task record
"RTN","RORTSK02",141,0)
 L -@TASKNODE@("T",0)
"RTN","RORTSK02",142,0)
 Q $TR(STATUS,">",":")
"RTN","RORTSK02",143,0)
 ;
"RTN","RORTSK02",144,0)
 ;***** RETURNS THE TASK INFORMATION
"RTN","RORTSK02",145,0)
 ;
"RTN","RORTSK02",146,0)
 ; TASK          Task number
"RTN","RORTSK02",147,0)
 ;
"RTN","RORTSK02",148,0)
 ; .INFO         Reference to a local variable (output):
"RTN","RORTSK02",149,0)
 ;
"RTN","RORTSK02",150,0)
 ; INFO(
"RTN","RORTSK02",151,0)
 ;   OFFSET+1)           Task Number
"RTN","RORTSK02",152,0)
 ;   OFFSET+2)           Task Type           (internal^external)
"RTN","RORTSK02",153,0)
 ;   OFFSET+3)           Registry            (IEN^Name)
"RTN","RORTSK02",154,0)
 ;   OFFSET+4)           Report              (Code^Name)
"RTN","RORTSK02",155,0)
 ;   OFFSET+5)           Description
"RTN","RORTSK02",156,0)
 ;   OFFSET+6)           Task Status         (internal^external)
"RTN","RORTSK02",157,0)
 ;   OFFSET+7)           Creation Time       (internal)
"RTN","RORTSK02",158,0)
 ;   OFFSET+8)           User                (DUZ^Name)
"RTN","RORTSK02",159,0)
 ;   OFFSET+9)           Completion Time     (internal)
"RTN","RORTSK02",160,0)
 ;   OFFSET+10)          Progress Percentage
"RTN","RORTSK02",161,0)
 ;   OFFSET+11)          Scheduled to Run at (internal)
"RTN","RORTSK02",162,0)
 ;   OFFSET+12)          Task Log IEN
"RTN","RORTSK02",163,0)
 ;   OFFSET+13)          Job Number
"RTN","RORTSK02",164,0)
 ;
"RTN","RORTSK02",165,0)
 ; [FLAGS]       Characters controlling behavior of the function
"RTN","RORTSK02",166,0)
 ;               (they can be combined):
"RTN","RORTSK02",167,0)
 ;                 E  Return external values also (when applicable)
"RTN","RORTSK02",168,0)
 ;
"RTN","RORTSK02",169,0)
 ; [OFFSET]      A number that is added to all subscripts in the
"RTN","RORTSK02",170,0)
 ;               destination array (by default, it is zero).
"RTN","RORTSK02",171,0)
 ;
"RTN","RORTSK02",172,0)
 ; Return Values:
"RTN","RORTSK02",173,0)
 ;       <0  Error code
"RTN","RORTSK02",174,0)
 ;        0  Ok
"RTN","RORTSK02",175,0)
 ;
"RTN","RORTSK02",176,0)
TASKINFO(TASK,INFO,FLAGS,OFFSET) ;
"RTN","RORTSK02",177,0)
 N I,IENS,RORBUF,RORMSG,TMP
"RTN","RORTSK02",178,0)
 S FLAGS=$$UP^XLFSTR($G(FLAGS))
"RTN","RORTSK02",179,0)
 S OFFSET=$S($G(OFFSET)>0:+OFFSET,1:0)
"RTN","RORTSK02",180,0)
 ;--- Clear the output array
"RTN","RORTSK02",181,0)
 K:'OFFSET INFO  S TMP=$$TIN
"RTN","RORTSK02",182,0)
 F I=1:1:TMP  S INFO(OFFSET+I)=""
"RTN","RORTSK02",183,0)
 ;--- Get the task status
"RTN","RORTSK02",184,0)
 S TMP=$$STATUS(TASK,,1)  Q:TMP<0 TMP
"RTN","RORTSK02",185,0)
 S INFO(OFFSET+1)=TASK
"RTN","RORTSK02",186,0)
 S INFO(OFFSET+6)=$S(FLAGS["E":TMP,1:+TMP)
"RTN","RORTSK02",187,0)
 ;--- Load the task record
"RTN","RORTSK02",188,0)
 S IENS=TASK_",",I=$S(FLAGS["E":"EIN",1:"IN")
"RTN","RORTSK02",189,0)
 S TMP=".02;.03;.04;.05;.07;.08;2.02;2.03;2.04;4"
"RTN","RORTSK02",190,0)
 D GETS^DIQ(798.8,IENS,TMP,I,"RORBUF","RORMSG")
"RTN","RORTSK02",191,0)
 I $G(DIERR)  D  Q RC
"RTN","RORTSK02",192,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.8,IENS)
"RTN","RORTSK02",193,0)
 ;--- Format the output array
"RTN","RORTSK02",194,0)
 Q $$FRMTI^RORTSK03(OFFSET,.INFO,IENS,.RORBUF,FLAGS)
"RTN","RORTSK02",195,0)
 ;
"RTN","RORTSK02",196,0)
 ;***** RETURNS NUMBER OF NODES IN THE TASK INFORMATION ARRAY
"RTN","RORTSK02",197,0)
TIN() Q 13
"RTN","RORTSK03")
0^5^B7170805
"RTN","RORTSK03",1,0)
RORTSK03 ;HCIOFO/SG - TASK MANAGER OVERFLOW CODE ; 7/11/03 12:02pm
"RTN","RORTSK03",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORTSK03",3,0)
 ;
"RTN","RORTSK03",4,0)
 Q
"RTN","RORTSK03",5,0)
 ;
"RTN","RORTSK03",6,0)
 ;***** PREPARE THE TASK PARAMETERS
"RTN","RORTSK03",7,0)
 ;
"RTN","RORTSK03",8,0)
 ; .PARAMS       Reference to a local array that contains
"RTN","RORTSK03",9,0)
 ;               the task parameters
"RTN","RORTSK03",10,0)
 ;
"RTN","RORTSK03",11,0)
 ; Return Values:
"RTN","RORTSK03",12,0)
 ;       <0  Error code
"RTN","RORTSK03",13,0)
 ;        0  Ok
"RTN","RORTSK03",14,0)
 ;
"RTN","RORTSK03",15,0)
PARAMS(PARAMS) ;
"RTN","RORTSK03",16,0)
 N I,NAME,NODE,SUBS,TMP
"RTN","RORTSK03",17,0)
 ;--- If the task is rescheduled, the RORTSK local array is
"RTN","RORTSK03",18,0)
 ;    passed via the PARAMS parameter. Therefore, the task
"RTN","RORTSK03",19,0)
 ;    parameters are already prepared and should be just
"RTN","RORTSK03",20,0)
 ;--- copied to the new RORTSK variable.
"RTN","RORTSK03",21,0)
 I $G(PARAMS)>0  M RORTSK("PARAMS")=PARAMS("PARAMS")  Q 0
"RTN","RORTSK03",22,0)
 ;--- Otherwise, prepare the parameters
"RTN","RORTSK03",23,0)
 S I=""
"RTN","RORTSK03",24,0)
 F  S I=$O(PARAMS(I))  Q:I=""  D
"RTN","RORTSK03",25,0)
 . S NAME=$TR($P(PARAMS(I),"=")," ")  Q:NAME=""
"RTN","RORTSK03",26,0)
 . S TMP=$P(NAME,"(")  Q:TMP=""
"RTN","RORTSK03",27,0)
 . S NODE="RORTSK(""PARAMS"","""_TMP_""""
"RTN","RORTSK03",28,0)
 . S TMP=$P(NAME,"(",2,999)
"RTN","RORTSK03",29,0)
 . S NODE=$S(TMP'="":NODE_","_TMP,1:NODE_")")
"RTN","RORTSK03",30,0)
 . S @NODE=$$TRIM^XLFSTR($P(PARAMS(I),"=",2,999))
"RTN","RORTSK03",31,0)
 Q 0
"RTN","RORTSK03",32,0)
 ;
"RTN","RORTSK03",33,0)
 ;***** FORMATS THE TASK INFORMATION FOR $$TASKINFO^RORTSK02
"RTN","RORTSK03",34,0)
 ;
"RTN","RORTSK03",35,0)
 ; OFFSET        Offset for the subscripts
"RTN","RORTSK03",36,0)
 ; .INFO         Reference to a local variable (output):
"RTN","RORTSK03",37,0)
 ; IENS          The second subscript in the RORBUF array
"RTN","RORTSK03",38,0)
 ; .RORBUF       Referrence to a local variable containing output
"RTN","RORTSK03",39,0)
 ;               of the GETS^DIQ procedure
"RTN","RORTSK03",40,0)
 ; FLAGS         Characters controlling behavior of the function
"RTN","RORTSK03",41,0)
 ;
"RTN","RORTSK03",42,0)
 ; Return Values:
"RTN","RORTSK03",43,0)
 ;       <0  Error code
"RTN","RORTSK03",44,0)
 ;        0  Ok
"RTN","RORTSK03",45,0)
 ;
"RTN","RORTSK03",46,0)
FRMTI(OFFSET,INFO,IENS,RORBUF,FLAGS) ;
"RTN","RORTSK03",47,0)
 N I,TMP,ZTCPU,ZTSK
"RTN","RORTSK03",48,0)
 ;--- Task Type
"RTN","RORTSK03",49,0)
 I $G(RORBUF(798.8,IENS,.02,"I"))'=""  D
"RTN","RORTSK03",50,0)
 . S I=OFFSET+2,INFO(I)=RORBUF(798.8,IENS,.02,"I")
"RTN","RORTSK03",51,0)
 . S:FLAGS["E" $P(INFO(I),U,2)=$G(RORBUF(798.8,IENS,.02,"E"))
"RTN","RORTSK03",52,0)
 ;--- Registry
"RTN","RORTSK03",53,0)
 I $G(RORBUF(798.8,IENS,.03,"I"))'=""  D
"RTN","RORTSK03",54,0)
 . S I=OFFSET+3,INFO(I)=RORBUF(798.8,IENS,.03,"I")
"RTN","RORTSK03",55,0)
 . S:FLAGS["E" $P(INFO(I),U,2)=$G(RORBUF(798.8,IENS,.03,"E"))
"RTN","RORTSK03",56,0)
 ;--- Report
"RTN","RORTSK03",57,0)
 S TMP=+$G(RORBUF(798.8,IENS,.04,"I"))
"RTN","RORTSK03",58,0)
 I TMP>0  S TMP=$$RPCODE^RORUTL08(TMP)  I TMP'=""  D
"RTN","RORTSK03",59,0)
 . S I=OFFSET+4,INFO(I)=TMP
"RTN","RORTSK03",60,0)
 . S:FLAGS["E" $P(INFO(I),U,2)=$G(RORBUF(798.8,IENS,.04,"E"))
"RTN","RORTSK03",61,0)
 ;--- Description
"RTN","RORTSK03",62,0)
 S INFO(OFFSET+5)=$G(RORBUF(798.8,IENS,.05,"I"))
"RTN","RORTSK03",63,0)
 ;--- Creation Time
"RTN","RORTSK03",64,0)
 I $G(RORBUF(798.8,IENS,.07,"I"))'=""  D
"RTN","RORTSK03",65,0)
 . S INFO(OFFSET+7)=RORBUF(798.8,IENS,.07,"I")
"RTN","RORTSK03",66,0)
 ;--- User
"RTN","RORTSK03",67,0)
 I $G(RORBUF(798.8,IENS,.08,"I"))'=""  D
"RTN","RORTSK03",68,0)
 . S I=OFFSET+8,INFO(I)=RORBUF(798.8,IENS,.08,"I")
"RTN","RORTSK03",69,0)
 . S:FLAGS["E" $P(INFO(I),U,2)=$G(RORBUF(798.8,IENS,.08,"E"))
"RTN","RORTSK03",70,0)
 ;--- Completion Time
"RTN","RORTSK03",71,0)
 I $G(RORBUF(798.8,IENS,2.02,"I"))'=""  D
"RTN","RORTSK03",72,0)
 . S INFO(OFFSET+9)=RORBUF(798.8,IENS,2.02,"I")
"RTN","RORTSK03",73,0)
 ;--- Progress Percentage
"RTN","RORTSK03",74,0)
 S TMP=$G(RORBUF(798.8,IENS,4,"I"))
"RTN","RORTSK03",75,0)
 S INFO(OFFSET+10)=$S(TMP'="":$J(TMP,0,2),1:"")
"RTN","RORTSK03",76,0)
 ;--- Scheduled to Run at
"RTN","RORTSK03",77,0)
 S ZTSK=TASK  D ISQED^%ZTLOAD
"RTN","RORTSK03",78,0)
 I $G(ZTSK(0)),$D(ZTSK("D"))#10  D
"RTN","RORTSK03",79,0)
 . S INFO(OFFSET+11)=$$HTFM^XLFDT(ZTSK("D"))
"RTN","RORTSK03",80,0)
 ;--- Task Log
"RTN","RORTSK03",81,0)
 S INFO(OFFSET+12)=$G(RORBUF(798.8,IENS,2.03,"I"))
"RTN","RORTSK03",82,0)
 ;--- Job Number
"RTN","RORTSK03",83,0)
 S INFO(OFFSET+13)=$G(RORBUF(798.8,IENS,2.04,"I"))
"RTN","RORTSK03",84,0)
 Q 0
"RTN","RORTSK10")
0^15^B36852620
"RTN","RORTSK10",1,0)
RORTSK10 ;HCIOFO/SG - REPORT RETRIEVING UTILITIES ; 11/17/03 4:37pm
"RTN","RORTSK10",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORTSK10",3,0)
 ;
"RTN","RORTSK10",4,0)
 Q
"RTN","RORTSK10",5,0)
 ;
"RTN","RORTSK10",6,0)
 ;***** TRACES THE PATH FROM THE ELEMENT TO THE ROOT
"RTN","RORTSK10",7,0)
 ;
"RTN","RORTSK10",8,0)
 ; IEN           IEN of the report element
"RTN","RORTSK10",9,0)
 ;
"RTN","RORTSK10",10,0)
 ; .STACK        Reference to a local variable where the path will
"RTN","RORTSK10",11,0)
 ;               be stored to.
"RTN","RORTSK10",12,0)
 ;
"RTN","RORTSK10",13,0)
 ;  STACK                Number of elements in the path (n)
"RTN","RORTSK10",14,0)
 ;  STACK(i)             Identifiers of the elements (i=1 - the source
"RTN","RORTSK10",15,0)
 ;                       element; i=n - the root element)
"RTN","RORTSK10",16,0)
 ;                         ^1: IEN of the report element
"RTN","RORTSK10",17,0)
 ;                         ^2: Where exactly the rendering process
"RTN","RORTSK10",18,0)
 ;                             has stopped (see $$XMLSTR for details)
"RTN","RORTSK10",19,0)
 ;                         ^3: IEN of the text line
"RTN","RORTSK10",20,0)
 ;
"RTN","RORTSK10",21,0)
PATH(IEN,STACK) ;
"RTN","RORTSK10",22,0)
 K STACK  S STACK=0
"RTN","RORTSK10",23,0)
 F  D  Q:IEN'>0
"RTN","RORTSK10",24,0)
 . S STACK=STACK+1,STACK(STACK)=IEN
"RTN","RORTSK10",25,0)
 . S:'$P(IEN,U,2) $P(STACK(STACK),U,2)=4
"RTN","RORTSK10",26,0)
 . S IEN=$P($G(@RORSRC@(+IEN,0)),U,2)
"RTN","RORTSK10",27,0)
 Q
"RTN","RORTSK10",28,0)
 ;
"RTN","RORTSK10",29,0)
 ;***** RENDERS THE REPORT INTO XML
"RTN","RORTSK10",30,0)
 ;
"RTN","RORTSK10",31,0)
 ; ROR8DST       Closed root of the destination buffer
"RTN","RORTSK10",32,0)
 ;
"RTN","RORTSK10",33,0)
 ; TASK          Task number
"RTN","RORTSK10",34,0)
 ;
"RTN","RORTSK10",35,0)
 ; [.SORT]       Sort modes for the report
"RTN","RORTSK10",36,0)
 ;
"RTN","RORTSK10",37,0)
 ; [.FROM]       Where to start/continue the rendering process
"RTN","RORTSK10",38,0)
 ;                 ^1: IEN of the report element
"RTN","RORTSK10",39,0)
 ;                 ^2: Where exactly the rendering process has stopped
"RTN","RORTSK10",40,0)
 ;                     (see the $$XMLSTR function for details)
"RTN","RORTSK10",41,0)
 ;                 ^3: IEN of the text line (if the 2nd piece = 3)
"RTN","RORTSK10",42,0)
 ;
"RTN","RORTSK10",43,0)
 ;               You must not make any assumptions about structure of 
"RTN","RORTSK10",44,0)
 ;               this parameter (it can be changed at any time without
"RTN","RORTSK10",45,0)
 ;               warning). The only exception is the IEN of the report
"RTN","RORTSK10",46,0)
 ;               element. You can assign a positive value to this
"RTN","RORTSK10",47,0)
 ;               parameter before the call to start the rendering from
"RTN","RORTSK10",48,0)
 ;               the corresponding element.
"RTN","RORTSK10",49,0)
 ;
"RTN","RORTSK10",50,0)
 ; [MAXSIZE]     Either the maximum number of lines to retrieve or
"RTN","RORTSK10",51,0)
 ;               the maximum size of the output in bytes (append the
"RTN","RORTSK10",52,0)
 ;               "B" to the number). By default (if $G(MAXSIZE)'>0,)
"RTN","RORTSK10",53,0)
 ;               the whole report (starting from the point indicated
"RTN","RORTSK10",54,0)
 ;               by the FROM parameter if it is defined) is retrieved.
"RTN","RORTSK10",55,0)
 ;
"RTN","RORTSK10",56,0)
 ;               Examples:
"RTN","RORTSK10",57,0)
 ;                 500    Retrieve no more than 500 lines
"RTN","RORTSK10",58,0)
 ;                 4096B  Retrieve no more than 4Kb
"RTN","RORTSK10",59,0)
 ;
"RTN","RORTSK10",60,0)
 ;         NOTE: If the "B" suffix is used, the size of the retrieved
"RTN","RORTSK10",61,0)
 ;               portion of the document can be somewhat bigger than
"RTN","RORTSK10",62,0)
 ;               MAXSIZE! The last line of the chunk is not truncated
"RTN","RORTSK10",63,0)
 ;               even if the size will be bigger than MAXSIZE.
"RTN","RORTSK10",64,0)
 ;
"RTN","RORTSK10",65,0)
 ; Return Values:
"RTN","RORTSK10",66,0)
 ;       <0  Error code
"RTN","RORTSK10",67,0)
 ;        0  Ok
"RTN","RORTSK10",68,0)
 ;       >0  Number of rendered lines
"RTN","RORTSK10",69,0)
 ;
"RTN","RORTSK10",70,0)
 ; If the maximum size (MAXSIZE) is reached, the identifiers
"RTN","RORTSK10",71,0)
 ; of the last item (it has not been added to the output buffer) are
"RTN","RORTSK10",72,0)
 ; returned via the FROM parameter. The next call of the function will
"RTN","RORTSK10",73,0)
 ; continue the rendering process starting from that item.
"RTN","RORTSK10",74,0)
 ;
"RTN","RORTSK10",75,0)
XMLREP(ROR8DST,TASK,SORT,FROM,MAXSIZE) ;
"RTN","RORTSK10",76,0)
 N RORNUM        ; Number of rendered lines of the report
"RTN","RORTSK10",77,0)
 N RORSIZE       ; Size of the output (in bytes)
"RTN","RORTSK10",78,0)
 N RORSORT       ; Sort modes for the report
"RTN","RORTSK10",79,0)
 N RORSTACK      ; Path from the FROM element to the root
"RTN","RORTSK10",80,0)
 N RORSRC        ; Closed root of the source report data
"RTN","RORTSK10",81,0)
 ;
"RTN","RORTSK10",82,0)
 N DIR,I,RC,SORTFLD,SORTLST  K @ROR8DST
"RTN","RORTSK10",83,0)
 S RORSRC=$$ROOT^DILFD(798.87,","_TASK_",",1)
"RTN","RORTSK10",84,0)
 ;--- Setup the size limits
"RTN","RORTSK10",85,0)
 S (RORNUM,RORSIZE)=0
"RTN","RORTSK10",86,0)
 S MAXSIZE=$$UP^XLFSTR($G(MAXSIZE))
"RTN","RORTSK10",87,0)
 I MAXSIZE["B"  S RORNUM(1)=0,RORSIZE(1)=+MAXSIZE
"RTN","RORTSK10",88,0)
 E  S RORNUM(1)=+MAXSIZE,RORSIZE(1)=0
"RTN","RORTSK10",89,0)
 ;--- Setup the starting point
"RTN","RORTSK10",90,0)
 I $G(FROM)>0  D
"RTN","RORTSK10",91,0)
 . S:$P(FROM,U,2)'>0 $P(FROM,U,2)=1
"RTN","RORTSK10",92,0)
 . D PATH(FROM,.RORSTACK)
"RTN","RORTSK10",93,0)
 E  S I=$$XMLSTR("<?xml version=""1.0""?>")
"RTN","RORTSK10",94,0)
 ;--- Setup the sorting
"RTN","RORTSK10",95,0)
 S (FROM,I)=""
"RTN","RORTSK10",96,0)
 F  S I=$O(SORT(I))  Q:I=""  D
"RTN","RORTSK10",97,0)
 . S SORTLST=$P(SORT(I),"=")            Q:SORTLST=""
"RTN","RORTSK10",98,0)
 . S SORTFLD=$P($P(SORT(I),"=",2),":")  Q:SORTFLD=""
"RTN","RORTSK10",99,0)
 . S DIR=$S($P(SORT(I),":",2)?1"D".1"ESC":-1,1:1)
"RTN","RORTSK10",100,0)
 . S RORSORT($$XEC^RORTSK11(SORTLST))=$$XEC^RORTSK11(SORTFLD)_U_DIR
"RTN","RORTSK10",101,0)
 ;--- Get the report
"RTN","RORTSK10",102,0)
 S RC=$$XMLREPI(0,0)
"RTN","RORTSK10",103,0)
 S:RC>0 FROM=$P(RC,U,2)_U_$P(RC,U)_U_$P(RC,U,3)
"RTN","RORTSK10",104,0)
 Q $S(RC'<0:RORNUM,1:RC)
"RTN","RORTSK10",105,0)
 ;
"RTN","RORTSK10",106,0)
 ;***** RECURSIVELY RENDERS THE REPORT INTO XML
"RTN","RORTSK10",107,0)
 ;
"RTN","RORTSK10",108,0)
 ; PARENT        IEN of the parent element
"RTN","RORTSK10",109,0)
 ; PELC          Type of the parent element
"RTN","RORTSK10",110,0)
 ;
"RTN","RORTSK10",111,0)
 ; Return Values:
"RTN","RORTSK10",112,0)
 ;       <0  Error code
"RTN","RORTSK10",113,0)
 ;        0  Ok
"RTN","RORTSK10",114,0)
 ;       >0  Number of rendered lines has reached the limit
"RTN","RORTSK10",115,0)
 ;           (see the $$XMLSTR function for details)
"RTN","RORTSK10",116,0)
 ;
"RTN","RORTSK10",117,0)
XMLREPI(PARENT,PELC) ;
"RTN","RORTSK10",118,0)
 N RORIEN        ; IEN of the report element being processed
"RTN","RORTSK10",119,0)
 ;
"RTN","RORTSK10",120,0)
 N BUF,DIR,LC,ELEMENT,I,LINE,MODE,RC,SVC,TMP,VAL,XREF
"RTN","RORTSK10",121,0)
 I $G(PELC)>0  D
"RTN","RORTSK10",122,0)
 . S BUF=$G(RORSORT(PELC)),SVC=+$P(BUF,U),DIR=$S($P(BUF,U,2)<0:-1,1:1)
"RTN","RORTSK10",123,0)
 E  S SVC=0,DIR=1
"RTN","RORTSK10",124,0)
 S XREF=$NA(@RORSRC@("APSV",PARENT,SVC))
"RTN","RORTSK10",125,0)
 ;--- Use order of creation if the xref is not available
"RTN","RORTSK10",126,0)
 S:$D(@XREF)<10 XREF=$NA(@RORSRC@("APSV",PARENT,0))
"RTN","RORTSK10",127,0)
 ;--- Determine the starting point (FROM)
"RTN","RORTSK10",128,0)
 I $G(RORSTACK)>0  S RC=0  D  Q:RC RC
"RTN","RORTSK10",129,0)
 . S RORIEN=+$P(RORSTACK(RORSTACK),U)
"RTN","RORTSK10",130,0)
 . S MODE=+$P(RORSTACK(RORSTACK),U,2)
"RTN","RORTSK10",131,0)
 . S LINE=+$P(RORSTACK(RORSTACK),U,3)
"RTN","RORTSK10",132,0)
 . S RORSTACK=RORSTACK-1
"RTN","RORTSK10",133,0)
 . S I=+$O(@RORSRC@("APSR",RORIEN,SVC,""))
"RTN","RORTSK10",134,0)
 . I I>0  D
"RTN","RORTSK10",135,0)
 . . S TMP=+$P($G(@RORSRC@(I,0)),U,3)
"RTN","RORTSK10",136,0)
 . . S VAL=$$SORTBY^RORDD01(TMP,$G(@RORSRC@(I,1)))
"RTN","RORTSK10",137,0)
 . E  S VAL=" "
"RTN","RORTSK10",138,0)
 . S RORIEN=$O(@RORSRC@("APSV",PARENT,SVC,VAL,RORIEN),-DIR)
"RTN","RORTSK10",139,0)
 . S VAL=$O(@RORSRC@("APSV",PARENT,SVC,VAL),-DIR)
"RTN","RORTSK10",140,0)
 E  K RORSTACK  S (LINE,MODE)=0,(RORIEN,VAL)=""
"RTN","RORTSK10",141,0)
 ;--- Render the report elements
"RTN","RORTSK10",142,0)
 S RC=0
"RTN","RORTSK10",143,0)
 F  S VAL=$O(@XREF@(VAL),DIR)  Q:VAL=""  D  Q:RC
"RTN","RORTSK10",144,0)
 . F  S RORIEN=$O(@XREF@(VAL,RORIEN),DIR)  Q:RORIEN=""  D  S MODE=0  Q:RC
"RTN","RORTSK10",145,0)
 . . S TMP=$G(@RORSRC@(RORIEN,0))  Q:$P(TMP,U,4)
"RTN","RORTSK10",146,0)
 . . S ELC=+$P(TMP,U)  Q:ELC'>0
"RTN","RORTSK10",147,0)
 . . S ELEMENT=$P(^ROR(799.31,ELC,0),U)
"RTN","RORTSK10",148,0)
 . . S I=0,BUF="<"_ELEMENT
"RTN","RORTSK10",149,0)
 . . ;--- Render the attributes of the element
"RTN","RORTSK10",150,0)
 . . F  S I=$O(@RORSRC@(RORIEN,2,I))  Q:I'>0  D
"RTN","RORTSK10",151,0)
 . . . S TMP=$P(@RORSRC@(RORIEN,2,I,0),U)
"RTN","RORTSK10",152,0)
 . . . S BUF=BUF_" "_$P(^ROR(799.31,TMP,0),U)
"RTN","RORTSK10",153,0)
 . . . S BUF=BUF_"="""_$G(@RORSRC@(RORIEN,2,I,1))_""""
"RTN","RORTSK10",154,0)
 . . ;--- Leaf element (without children)
"RTN","RORTSK10",155,0)
 . . I $D(@RORSRC@("APSV",RORIEN))<10  D  Q
"RTN","RORTSK10",156,0)
 . . . ;--- <ELEMENT...>VALUE</ELEMENT>
"RTN","RORTSK10",157,0)
 . . . S TMP=$G(@RORSRC@(RORIEN,1))
"RTN","RORTSK10",158,0)
 . . . I TMP'=""  D:MODE'>2  Q
"RTN","RORTSK10",159,0)
 . . . . S RC=$$XMLSTR(BUF_">"_TMP_"</"_ELEMENT_">",2)
"RTN","RORTSK10",160,0)
 . . . ;--- <ELEMENT.../>
"RTN","RORTSK10",161,0)
 . . . S I=$O(@RORSRC@(RORIEN,3,0))
"RTN","RORTSK10",162,0)
 . . . I I'>0  S:MODE'>2 RC=$$XMLSTR(BUF_"/>",2)  Q
"RTN","RORTSK10",163,0)
 . . . ;--- <ELEMENT...>
"RTN","RORTSK10",164,0)
 . . . ;    TEXT
"RTN","RORTSK10",165,0)
 . . . ;--- </ELEMENT>
"RTN","RORTSK10",166,0)
 . . . I MODE'>3  D  Q:RC
"RTN","RORTSK10",167,0)
 . . . . S:MODE'>1 RC=$$XMLSTR(BUF_">",1)
"RTN","RORTSK10",168,0)
 . . . . S:LINE>0 I=LINE,LINE=0
"RTN","RORTSK10",169,0)
 . . . . F  Q:RC  D  S I=$O(@RORSRC@(RORIEN,3,I))  Q:I'>0
"RTN","RORTSK10",170,0)
 . . . . . S RC=$$XMLSTR($G(@RORSRC@(RORIEN,3,I,0)),3,I)
"RTN","RORTSK10",171,0)
 . . . S RC=$$XMLSTR("</"_ELEMENT_">",5)
"RTN","RORTSK10",172,0)
 . . ;--- Parent element and all children (recursively)
"RTN","RORTSK10",173,0)
 . . I MODE'>4  D  Q:RC
"RTN","RORTSK10",174,0)
 . . . I MODE'>1  S RC=$$XMLSTR(BUF_">",1)  Q:RC
"RTN","RORTSK10",175,0)
 . . . S RC=$$XMLREPI(RORIEN,ELC)
"RTN","RORTSK10",176,0)
 . . S RC=$$XMLSTR("</"_ELEMENT_">",5)
"RTN","RORTSK10",177,0)
 . S RORIEN=""
"RTN","RORTSK10",178,0)
 Q RC
"RTN","RORTSK10",179,0)
 ;
"RTN","RORTSK10",180,0)
 ;***** APPENDS THE STRING TO THE OUTPUT BUFFER
"RTN","RORTSK10",181,0)
 ;
"RTN","RORTSK10",182,0)
 ; STR           String that should be appended to the document
"RTN","RORTSK10",183,0)
 ; TYPE          Type of the rendered item
"RTN","RORTSK10",184,0)
 ; [LINE]        IEN of the text line
"RTN","RORTSK10",185,0)
 ;
"RTN","RORTSK10",186,0)
 ; Return Values:
"RTN","RORTSK10",187,0)
 ;        0  Ok
"RTN","RORTSK10",188,0)
 ;       >0  Number of rendered lines has reached the limit
"RTN","RORTSK10",189,0)
 ;             ^1: Where exactly the rendering process has stopped
"RTN","RORTSK10",190,0)
 ;                   1  Opening tag
"RTN","RORTSK10",191,0)
 ;                   2  Single value
"RTN","RORTSK10",192,0)
 ;                   3  Multiline text value
"RTN","RORTSK10",193,0)
 ;                   4  Nested tag
"RTN","RORTSK10",194,0)
 ;                   5  Closing tag
"RTN","RORTSK10",195,0)
 ;             ^2: IEN of the report element
"RTN","RORTSK10",196,0)
 ;             ^3: IEN of the text line (if the 1st piece = 3)
"RTN","RORTSK10",197,0)
 ;
"RTN","RORTSK10",198,0)
XMLSTR(STR,TYPE,LINE) ;
"RTN","RORTSK10",199,0)
 N SL  S SL=$L(STR)+2
"RTN","RORTSK10",200,0)
 I RORNUM(1)>0  Q:RORNUM'<RORNUM(1) TYPE_U_RORIEN_U_$G(LINE)
"RTN","RORTSK10",201,0)
 I RORSIZE(1)>0  Q:RORSIZE'<RORSIZE(1) TYPE_U_RORIEN_U_$G(LINE)
"RTN","RORTSK10",202,0)
 S RORNUM=RORNUM+1,@ROR8DST@(RORNUM)=STR
"RTN","RORTSK10",203,0)
 S RORSIZE=RORSIZE+SL
"RTN","RORTSK10",204,0)
 Q 0
"RTN","RORTSK10",205,0)
 ;
"RTN","RORTSK10",206,0)
 ;*****
"RTN","RORTSK10",207,0)
XREFNODE(TASK,PARENT,SORT) ;
"RTN","RORTSK10",208,0)
 N NODE
"RTN","RORTSK10",209,0)
 S NODE=$$ROOT^DILFD(798.87,","_TASK_",",1)
"RTN","RORTSK10",210,0)
 S SORT=$$XEC^RORTSK11(SORT)
"RTN","RORTSK10",211,0)
 Q $S(SORT>0:$NA(@NODE@("APSV",PARENT,SORT)),1:"")
"RTN","RORTSK11")
0^16^B18028292
"RTN","RORTSK11",1,0)
RORTSK11 ;HCIOFO/SG - REPORT CREATION UTILITIES ; 11/20/03 10:26am
"RTN","RORTSK11",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORTSK11",3,0)
 ;
"RTN","RORTSK11",4,0)
 Q
"RTN","RORTSK11",5,0)
 ;
"RTN","RORTSK11",6,0)
 ;***** ADDS THE ATTRIBUTE TO THE ELEMENT
"RTN","RORTSK11",7,0)
 ;
"RTN","RORTSK11",8,0)
 ; TASK          Task number
"RTN","RORTSK11",9,0)
 ;
"RTN","RORTSK11",10,0)
 ; ELMTIEN       IEN of the element
"RTN","RORTSK11",11,0)
 ;
"RTN","RORTSK11",12,0)
 ; NAME          Attribute name
"RTN","RORTSK11",13,0)
 ;
"RTN","RORTSK11",14,0)
 ; VALUE         Value of the attribute
"RTN","RORTSK11",15,0)
 ;
"RTN","RORTSK11",16,0)
 ; The value is automatically encoded by this function.
"RTN","RORTSK11",17,0)
 ; See the $$XMLENC^RORUTL03 function for more details
"RTN","RORTSK11",18,0)
 ;
"RTN","RORTSK11",19,0)
 ; Return Values:
"RTN","RORTSK11",20,0)
 ;       <0  Error code
"RTN","RORTSK11",21,0)
 ;        0  Invalid attribute name
"RTN","RORTSK11",22,0)
 ;       >0  Attribute IEN
"RTN","RORTSK11",23,0)
 ;
"RTN","RORTSK11",24,0)
ADDATTR(TASK,ELMTIEN,NAME,VALUE) ;
"RTN","RORTSK11",25,0)
 N IENS,RC,RORFDA,RORIEN,RORMSG
"RTN","RORTSK11",26,0)
 I $D(^RORDATA(798.8,+TASK,"RI",+ELMTIEN))<10  Q:$QUIT 0  Q
"RTN","RORTSK11",27,0)
 S IENS="?+1,"_(+ELMTIEN)_","_(+TASK)_","
"RTN","RORTSK11",28,0)
 S (RORIEN(1),RORFDA(798.872,IENS,.01))=$$XEC(NAME)
"RTN","RORTSK11",29,0)
 I RORIEN(1)'>0  Q:$QUIT 0  Q
"RTN","RORTSK11",30,0)
 S RORFDA(798.872,IENS,1)=$$XMLENC^RORUTL03(VALUE)
"RTN","RORTSK11",31,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORTSK11",32,0)
 I $G(DIERR)  D  Q:$QUIT RC  Q
"RTN","RORTSK11",33,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.872,IENS)
"RTN","RORTSK11",34,0)
 Q:$QUIT +$G(RORIEN(1))  Q
"RTN","RORTSK11",35,0)
 ;
"RTN","RORTSK11",36,0)
 ;***** ADDS THE TEXT ELEMENT TO THE REPORT
"RTN","RORTSK11",37,0)
 ;
"RTN","RORTSK11",38,0)
 ; TASK          Task number
"RTN","RORTSK11",39,0)
 ;
"RTN","RORTSK11",40,0)
 ; NAME          Element name
"RTN","RORTSK11",41,0)
 ;
"RTN","RORTSK11",42,0)
 ; [.]ROR8TXT    Either a closed root or a reference to an array
"RTN","RORTSK11",43,0)
 ;               that contains the text in word processing format.
"RTN","RORTSK11",44,0)
 ;
"RTN","RORTSK11",45,0)
 ; [PARENT]      IEN of the parent element
"RTN","RORTSK11",46,0)
 ;
"RTN","RORTSK11",47,0)
 ; The text is not encoded by the function. This should be done
"RTN","RORTSK11",48,0)
 ; beforehand (use the $$XMLENC^RORUTL03 function).
"RTN","RORTSK11",49,0)
 ;
"RTN","RORTSK11",50,0)
 ; Return Values:
"RTN","RORTSK11",51,0)
 ;       <0  Error code
"RTN","RORTSK11",52,0)
 ;        0  Invalid element name
"RTN","RORTSK11",53,0)
 ;       >0  IEN of the report element
"RTN","RORTSK11",54,0)
 ;
"RTN","RORTSK11",55,0)
ADDTEXT(TASK,NAME,ROR8TXT,PARENT) ;
"RTN","RORTSK11",56,0)
 N IENS,RC,RORFDA,RORIEN,RORMSG,TMP
"RTN","RORTSK11",57,0)
 S IENS="+1,"_(+TASK)_","
"RTN","RORTSK11",58,0)
 S (RORFDA(798.87,IENS,.01),TMP)=$$XEC(NAME)
"RTN","RORTSK11",59,0)
 I TMP'>0  Q:$QUIT 0  Q
"RTN","RORTSK11",60,0)
 S RORFDA(798.87,IENS,.02)=+$G(PARENT)
"RTN","RORTSK11",61,0)
 S RORFDA(798.87,IENS,3)=$S($D(ROR8TXT)>1:"ROR8TXT",1:ROR8TXT)
"RTN","RORTSK11",62,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORTSK11",63,0)
 I $G(DIERR)  D  Q:$QUIT RC  Q
"RTN","RORTSK11",64,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.87,IENS)
"RTN","RORTSK11",65,0)
 Q:$QUIT +$G(RORIEN(1))  Q
"RTN","RORTSK11",66,0)
 ;
"RTN","RORTSK11",67,0)
 ;***** ADDS THE SINGLE-LINE ELEMENT TO THE REPORT
"RTN","RORTSK11",68,0)
 ;
"RTN","RORTSK11",69,0)
 ; TASK          Task number
"RTN","RORTSK11",70,0)
 ;
"RTN","RORTSK11",71,0)
 ; NAME          Element name
"RTN","RORTSK11",72,0)
 ;
"RTN","RORTSK11",73,0)
 ; VALUE         Value of the element
"RTN","RORTSK11",74,0)
 ;
"RTN","RORTSK11",75,0)
 ; [PARENT]      IEN of the parent element
"RTN","RORTSK11",76,0)
 ;
"RTN","RORTSK11",77,0)
 ; [SORTBY]      Parent element is sorted by the value of the element
"RTN","RORTSK11",78,0)
 ;               that is being added:
"RTN","RORTSK11",79,0)
 ;                 1  Sort "as is"
"RTN","RORTSK11",80,0)
 ;                 2  Sort as strings
"RTN","RORTSK11",81,0)
 ;                 3  Sort as numbers
"RTN","RORTSK11",82,0)
 ;
"RTN","RORTSK11",83,0)
 ; The value is automatically encoded by this function.
"RTN","RORTSK11",84,0)
 ; See the $$XMLENC^RORUTL03 function for more details
"RTN","RORTSK11",85,0)
 ;
"RTN","RORTSK11",86,0)
 ; Return Values:
"RTN","RORTSK11",87,0)
 ;       <0  Error code
"RTN","RORTSK11",88,0)
 ;        0  Invalid element name
"RTN","RORTSK11",89,0)
 ;       >0  IEN of the report element
"RTN","RORTSK11",90,0)
 ;
"RTN","RORTSK11",91,0)
ADDVAL(TASK,NAME,VALUE,PARENT,SORTBY,ID) ;
"RTN","RORTSK11",92,0)
 Q:$G(PARENT)<0
"RTN","RORTSK11",93,0)
 N IENS,RC,RORFDA,RORIEN,RORMSG,TMP
"RTN","RORTSK11",94,0)
 S IENS="+1,"_(+TASK)_","
"RTN","RORTSK11",95,0)
 S (RORFDA(798.87,IENS,.01),TMP)=$$XEC(NAME)
"RTN","RORTSK11",96,0)
 I TMP'>0  Q:$QUIT 0  Q
"RTN","RORTSK11",97,0)
 S RORFDA(798.87,IENS,.02)=+$G(PARENT)
"RTN","RORTSK11",98,0)
 S:$G(SORTBY) RORFDA(798.87,IENS,.03)=SORTBY
"RTN","RORTSK11",99,0)
 S:$G(VALUE)'="" RORFDA(798.87,IENS,1)=$$XMLENC^RORUTL03(VALUE)
"RTN","RORTSK11",100,0)
 D:$G(ID)'=""
"RTN","RORTSK11",101,0)
 . S TMP="+2,"_IENS
"RTN","RORTSK11",102,0)
 . S (RORIEN(2),RORFDA(798.872,TMP,.01))=$$XEC("ID")
"RTN","RORTSK11",103,0)
 . S RORFDA(798.872,TMP,1)=ID
"RTN","RORTSK11",104,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORTSK11",105,0)
 I $G(DIERR)  D  Q:$QUIT RC  Q
"RTN","RORTSK11",106,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.87,IENS)
"RTN","RORTSK11",107,0)
 Q:$QUIT +$G(RORIEN(1))  Q
"RTN","RORTSK11",108,0)
 ;
"RTN","RORTSK11",109,0)
 ;***** UPDATES VALUE OF THE ELEMENT
"RTN","RORTSK11",110,0)
 ;
"RTN","RORTSK11",111,0)
 ; TASK          Task number
"RTN","RORTSK11",112,0)
 ;
"RTN","RORTSK11",113,0)
 ; ELMTIEN       IEN of the element
"RTN","RORTSK11",114,0)
 ;
"RTN","RORTSK11",115,0)
 ; VALUE         Value of the element
"RTN","RORTSK11",116,0)
 ;
"RTN","RORTSK11",117,0)
 ; [SORTBY]      Parent element is sorted by the value of the element
"RTN","RORTSK11",118,0)
 ;               that is being added:
"RTN","RORTSK11",119,0)
 ;                 1  Sort "as is"
"RTN","RORTSK11",120,0)
 ;                 2  Sort as strings
"RTN","RORTSK11",121,0)
 ;                 3  Sort as numbers
"RTN","RORTSK11",122,0)
 ;
"RTN","RORTSK11",123,0)
 ; [IGNORE]      Do not render this element into the resulting XML
"RTN","RORTSK11",124,0)
 ;               document.
"RTN","RORTSK11",125,0)
 ;
"RTN","RORTSK11",126,0)
 ; The value is automatically encoded by this function.
"RTN","RORTSK11",127,0)
 ; See the $$XMLENC^RORUTL03 function for more details
"RTN","RORTSK11",128,0)
 ;
"RTN","RORTSK11",129,0)
 ; Return Values:
"RTN","RORTSK11",130,0)
 ;       <0  Error code
"RTN","RORTSK11",131,0)
 ;       >0  IEN of the report element
"RTN","RORTSK11",132,0)
 ;
"RTN","RORTSK11",133,0)
UPDVAL(TASK,ELMTIEN,VALUE,SORTBY,IGNORE) ;
"RTN","RORTSK11",134,0)
 N IENS,RORFDA,RORIEN,RORMSG,TMP
"RTN","RORTSK11",135,0)
 I $D(^RORDATA(798.8,+TASK,"RI",+ELMTIEN))<10  Q:$QUIT 0  Q
"RTN","RORTSK11",136,0)
 S IENS=(+ELMTIEN)_","_(+TASK)_","
"RTN","RORTSK11",137,0)
 S:$G(SORTBY) RORFDA(798.87,IENS,.03)=SORTBY
"RTN","RORTSK11",138,0)
 S RORFDA(798.87,IENS,.04)=$S($G(IGNORE):1,1:"")
"RTN","RORTSK11",139,0)
 S RORFDA(798.87,IENS,1)=$$XMLENC^RORUTL03($G(VALUE))
"RTN","RORTSK11",140,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORTSK11",141,0)
 I $G(DIERR)  D  Q:$QUIT RC  Q
"RTN","RORTSK11",142,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.87,IENS)
"RTN","RORTSK11",143,0)
 Q:$QUIT +$G(RORIEN(1))  Q
"RTN","RORTSK11",144,0)
 ;
"RTN","RORTSK11",145,0)
 ;***** DUMPS THE VARIABLE
"RTN","RORTSK11",146,0)
 ;
"RTN","RORTSK11",147,0)
 ; TASK          Task number
"RTN","RORTSK11",148,0)
 ;
"RTN","RORTSK11",149,0)
 ; ROOT          Closed root of the variable
"RTN","RORTSK11",150,0)
 ;
"RTN","RORTSK11",151,0)
 ; [PARENT]      IEN of the parent element (0, by default)
"RTN","RORTSK11",152,0)
 ;
"RTN","RORTSK11",153,0)
 ; [NAME]        Element name ("VARDUMP", by default)
"RTN","RORTSK11",154,0)
 ;
"RTN","RORTSK11",155,0)
 ; Return Values:
"RTN","RORTSK11",156,0)
 ;       <0  Error code
"RTN","RORTSK11",157,0)
 ;       >0  IEN of the element
"RTN","RORTSK11",158,0)
 ;
"RTN","RORTSK11",159,0)
VARDUMP(TASK,ROOT,PARENT,NAME) ;
"RTN","RORTSK11",160,0)
 N DUMP,FLT,LFLT,PI
"RTN","RORTSK11",161,0)
 S:$G(NAME)="" NAME="VARDUMP"
"RTN","RORTSK11",162,0)
 S:$G(PARENT)'>0 PARENT=0
"RTN","RORTSK11",163,0)
 ;---
"RTN","RORTSK11",164,0)
 S LFLT=$L(ROOT)
"RTN","RORTSK11",165,0)
 S:$E(ROOT,LFLT)=")" LFLT=LFLT-1
"RTN","RORTSK11",166,0)
 S FLT=$E(ROOT,1,LFLT)
"RTN","RORTSK11",167,0)
 ;---
"RTN","RORTSK11",168,0)
 S DUMP=$$ADDVAL^RORTSK11(TASK,NAME,,PARENT)
"RTN","RORTSK11",169,0)
 I DUMP<0  Q:$QUIT DUMP  Q
"RTN","RORTSK11",170,0)
 S PI=ROOT
"RTN","RORTSK11",171,0)
 F  S PI=$Q(@PI)  Q:$E(PI,1,LFLT)'=FLT  D
"RTN","RORTSK11",172,0)
 . D ADDVAL^RORTSK11(TASK,"ITEM",PI_"="_@PI,DUMP)
"RTN","RORTSK11",173,0)
 Q:$QUIT DUMP  Q
"RTN","RORTSK11",174,0)
 ;
"RTN","RORTSK11",175,0)
 ;***** RETURNS TYPE (CODE) OF THE ELEMENT
"RTN","RORTSK11",176,0)
 ;
"RTN","RORTSK11",177,0)
 ; NAME          Element name
"RTN","RORTSK11",178,0)
 ;
"RTN","RORTSK11",179,0)
XEC(NAME) ;
"RTN","RORTSK11",180,0)
 S:'$D(RORCACHE("XMLENT",NAME)) RORCACHE("XMLENT",NAME)=+$O(^ROR(799.31,"B",$E(NAME,1,30),0))
"RTN","RORTSK11",181,0)
 Q RORCACHE("XMLENT",NAME)
"RTN","RORUPD")
0^30^B30110127
"RTN","RORUPD",1,0)
RORUPD ;HCIOFO/SG - REGISTRY UPDATE ; 7/21/03 10:18am
"RTN","RORUPD",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORUPD",3,0)
 ;
"RTN","RORUPD",4,0)
 ; RORLRC -------------- LIST OF LAB RESULT CODES TO CHECK
"RTN","RORUPD",5,0)
 ;
"RTN","RORUPD",6,0)
 ; RORLRC(Seq#)          Lab result code (see the LA7SC parameter of
"RTN","RORUPD",7,0)
 ;                       the GCPR^LA7QRY entry point)
"RTN","RORUPD",8,0)
 ;                         ^1: Result code
"RTN","RORUPD",9,0)
 ;                         ^2: Coding system ("LN" or "NLT")
"RTN","RORUPD",10,0)
 ;
"RTN","RORUPD",11,0)
 ; RORUPD -------------- REGISTRY UPDATE DESCRIPTOR
"RTN","RORUPD",12,0)
 ;
"RTN","RORUPD",13,0)
 ; RORUPD("DT")          Date/time when update process started
"RTN","RORUPD",14,0)
 ;
"RTN","RORUPD",15,0)
 ; RORUPD("DSBEG")       Start date of the data scan
"RTN","RORUPD",16,0)
 ; RORUPD("DSEND")       End date of the data scan
"RTN","RORUPD",17,0)
 ;                       (these nodes are set by $$PREPARE1^RORUPR)
"RTN","RORUPD",18,0)
 ;
"RTN","RORUPD",19,0)
 ; RORUPD("EETS")        Timestamp of the earliest event reference
"RTN","RORUPD",20,0)
 ;
"RTN","RORUPD",21,0)
 ; RORUPD("ERRCNT")      Counter of errors during processing of the
"RTN","RORUPD",22,0)
 ;                       current patient
"RTN","RORUPD",23,0)
 ;
"RTN","RORUPD",24,0)
 ; RORUPD("FLAGS")       Flags to control processing (see the
"RTN","RORUPD",25,0)
 ;                       TASK^ROR for possible values).
"RTN","RORUPD",26,0)
 ;
"RTN","RORUPD",27,0)
 ; RORUPD("JOB")         Job number of the main task. This node is
"RTN","RORUPD",28,0)
 ;                       defined only if the registry update is
"RTN","RORUPD",29,0)
 ;                       running in the multitask mode.
"RTN","RORUPD",30,0)
 ;
"RTN","RORUPD",31,0)
 ; RORUPD("LD",          Instead of checking data in the interval
"RTN","RORUPD",32,0)
 ;                       from start date till end date, update process
"RTN","RORUPD",33,0)
 ;                       starts checks from the start date minus
"RTN","RORUPD",34,0)
 ;                       appropriate number of lag days. Thus, data
"RTN","RORUPD",35,0)
 ;                       entered retrospectively will not be missed.
"RTN","RORUPD",36,0)
 ;   1)                  Lag days for data examination
"RTN","RORUPD",37,0)
 ;
"RTN","RORUPD",38,0)
 ; RORUPD("LM",          Loop control mode. It defines when to stop
"RTN","RORUPD",39,0)
 ;                       looping through records of the patient:
"RTN","RORUPD",40,0)
 ;                         0  always loop through all records
"RTN","RORUPD",41,0)
 ;                         1  all top level rules have been triggered
"RTN","RORUPD",42,0)
 ;                            for the patient (default)
"RTN","RORUPD",43,0)
 ;                         2  patient has been marked for addition to
"RTN","RORUPD",44,0)
 ;                            all registries being processed
"RTN","RORUPD",45,0)
 ;   1,Rule Name)        Current list of names of top level rules
"RTN","RORUPD",46,0)
 ;   2,Registry#)        Current list of registry IENs
"RTN","RORUPD",47,0)
 ;
"RTN","RORUPD",48,0)
 ; RORUPD("LM1",         STATIC LIST OF TOP LEVEL RULES
"RTN","RORUPD",49,0)
 ;   Rule Name)
"RTN","RORUPD",50,0)
 ;
"RTN","RORUPD",51,0)
 ; RORUPD("LM2",         STATIC LIST OF REGISTRIES
"RTN","RORUPD",52,0)
 ;   Registry#)            ^1: 1 - if the current patient can be added
"RTN","RORUPD",53,0)
 ;                             to the registry; 0 - if the patient is
"RTN","RORUPD",54,0)
 ;                             already in the registry or he/she is
"RTN","RORUPD",55,0)
 ;                             an employee and should be skipped.
"RTN","RORUPD",56,0)
 ;                         ^2: 1 if the employees must not be added
"RTN","RORUPD",57,0)
 ;                             to the registry.
"RTN","RORUPD",58,0)
 ;
"RTN","RORUPD",59,0)
 ; RORUPD("MAXPPCNT")    When counters in the ROR PENDING PATIENT
"RTN","RORUPD",60,0)
 ;                       file reach a value stored in this node, the
"RTN","RORUPD",61,0)
 ;                       corresponding patient will be skipped until
"RTN","RORUPD",62,0)
 ;                       someone fixes the error(s) and resets the
"RTN","RORUPD",63,0)
 ;                       counters to 1.
"RTN","RORUPD",64,0)
 ;
"RTN","RORUPD",65,0)
 ; RORUPD("ROOT",File#)  Closed root of the file
"RTN","RORUPD",66,0)
 ;
"RTN","RORUPD",67,0)
 ; RORUPD("SR",          PREPARED SELECTION RULES
"RTN","RORUPD",68,0)
 ;   File#,              This node is defined if the file should be
"RTN","RORUPD",69,0)
 ;                       processed
"RTN","RORUPD",70,0)
 ;
"RTN","RORUPD",71,0)
 ;     "A",              List of rules that should be applied after
"RTN","RORUPD",72,0)
 ;                       processing sub-files and linked files.
"RTN","RORUPD",73,0)
 ;     "B",              List of rules that should be applied before
"RTN","RORUPD",74,0)
 ;                       processing sub-files and linked files.
"RTN","RORUPD",75,0)
 ;       Seq#,             ^1: Selection Rule Name
"RTN","RORUPD",76,0)
 ;                         ^2: Rule# (Selection Rule IEN)
"RTN","RORUPD",77,0)
 ;                         ^3: 1 if registry should be updated if
"RTN","RORUPD",78,0)
 ;                             the expression evaluated as True
"RTN","RORUPD",79,0)
 ;                             (top-level seelction rule)
"RTN","RORUPD",80,0)
 ;         1)            MUMPS expression that implements the rule
"RTN","RORUPD",81,0)
 ;         2,Registry#)  List of IENs of affected registries
"RTN","RORUPD",82,0)
 ;
"RTN","RORUPD",83,0)
 ;     "F",              A list of data elements that should be loaded
"RTN","RORUPD",84,0)
 ;                       before applying selection rules is created
"RTN","RORUPD",85,0)
 ;                       under this node. The elements are grouped by
"RTN","RORUPD",86,0)
 ;                       the APIs used to load the values.
"RTN","RORUPD",87,0)
 ;       API#,           For API #1 (FileMan GETS^DIQ) this node
"RTN","RORUPD",88,0)
 ;                       contains a list of fields separated by ';'.
"RTN","RORUPD",89,0)
 ;         DataCode,     For data elements associated with the API #1
"RTN","RORUPD",90,0)
 ;                       this node stores the field number.
"RTN","RORUPD",91,0)
 ;           "E")        If an external value of the field should be
"RTN","RORUPD",92,0)
 ;                       loaded, a value of the field 4.1 of the
"RTN","RORUPD",93,0)
 ;                       subfile #799.22 is assigned to this node.
"RTN","RORUPD",94,0)
 ;           "I")        If an internal value of the field should be
"RTN","RORUPD",95,0)
 ;                       loaded, a value of the field 4.2 of the
"RTN","RORUPD",96,0)
 ;                       subfile #799.22 is assigned to this node.
"RTN","RORUPD",97,0)
 ;
"RTN","RORUPD",98,0)
 ; RORUPD("SUSPEND")     SUBTASKS SUSPENSION PARAMETERS
"RTN","RORUPD",99,0)
 ;                         ^1: Suspension start time (FileMan)
"RTN","RORUPD",100,0)
 ;                         ^2: Suspension end time (FileMan)
"RTN","RORUPD",101,0)
 ;
"RTN","RORUPD",102,0)
 ;                       For example, to suspend subtasks from
"RTN","RORUPD",103,0)
 ;                       7:00 until 18:00 this node should have
"RTN","RORUPD",104,0)
 ;                       the following value: ".07^.18".
"RTN","RORUPD",105,0)
 ;
"RTN","RORUPD",106,0)
 ; RORUPD("UPD",         CALL-BACK ENTRY POINTS
"RTN","RORUPD",107,0)
 ;   Registry#,1)        Entry point of a MUMPS external function
"RTN","RORUPD",108,0)
 ;                       that assign values of additional fields to
"RTN","RORUPD",109,0)
 ;                       the registry FDA before registry update
"RTN","RORUPD",110,0)
 ;                       (opt'l).
"RTN","RORUPD",111,0)
 ;   Registry#,2)        Entry point of a MUMPS external function
"RTN","RORUPD",112,0)
 ;                       that is called right after registry update
"RTN","RORUPD",113,0)
 ;                       (opt'l).
"RTN","RORUPD",114,0)
 ;
"RTN","RORUPD",115,0)
 ; RORUPDPI ------------ CLOSED ROOT OF THE TEMPORARY STORAGE
"RTN","RORUPD",116,0)
 ;                       (the ^TMP("RORUPD",$J), ^XTMP("RORUPDJ"_$J)
"RTN","RORUPD",117,0)
 ;                       or ^XTMP("RORUPDR"_Registry#) node)
"RTN","RORUPD",118,0)
 ;
"RTN","RORUPD",119,0)
 ; See also a description of ^XTMP("RORUPD"_) in the ^ROR01 routine.
"RTN","RORUPD",120,0)
 ;
"RTN","RORUPD",121,0)
 Q
"RTN","RORUPD",122,0)
 ;
"RTN","RORUPD",123,0)
 ;***** UPDATES THE REGISTRIES
"RTN","RORUPD",124,0)
 ;
"RTN","RORUPD",125,0)
 ; .RGLIST       Reference to a local array containing
"RTN","RORUPD",126,0)
 ;               registry names as subscripts
"RTN","RORUPD",127,0)
 ;
"RTN","RORUPD",128,0)
 ; [.REGLST]     Reference to a local variable where list of actually
"RTN","RORUPD",129,0)
 ;               processed registries is returned to (registries from
"RTN","RORUPD",130,0)
 ;               the source list except inactive and awaiting
"RTN","RORUPD",131,0)
 ;               acknowledgements). It contains registry names as
"RTN","RORUPD",132,0)
 ;               subscripts and registry IENs as values.
"RTN","RORUPD",133,0)
 ;
"RTN","RORUPD",134,0)
 ; [MAXNTSK]     Maximum number of the data processing subtasks.
"RTN","RORUPD",135,0)
 ;               See description of the $$PROCESS^RORUPD05 function
"RTN","RORUPD",136,0)
 ;               for details.
"RTN","RORUPD",137,0)
 ;
"RTN","RORUPD",138,0)
 ; [SUSPEND]     Subtask suspension parameters:
"RTN","RORUPD",139,0)
 ;               See description of the RORUPD("SUSPEND") node
"RTN","RORUPD",140,0)
 ;               for details.
"RTN","RORUPD",141,0)
 ;
"RTN","RORUPD",142,0)
 ; [CLRFLG]      Clear flags to control processing.
"RTN","RORUPD",143,0)
 ; [SETFLG]      Set flags to control processing.
"RTN","RORUPD",144,0)
 ;               See description of the TASK^ROR for
"RTN","RORUPD",145,0)
 ;               possible values of the flags).
"RTN","RORUPD",146,0)
 ;
"RTN","RORUPD",147,0)
 ; Return Values:
"RTN","RORUPD",148,0)
 ;       <0  Error code (see MSGLIST^RORERR20)
"RTN","RORUPD",149,0)
 ;        0  Ok
"RTN","RORUPD",150,0)
 ;
"RTN","RORUPD",151,0)
UPDATE(RGLIST,REGLST,MAXNTSK,SUSPEND,CLRFLG,SETFLG) ;
"RTN","RORUPD",152,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD",153,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORUPD",154,0)
 N RORLRC        ; List of Lab result codes to check
"RTN","RORUPD",155,0)
 N RORUPD        ; Update descriptor
"RTN","RORUPD",156,0)
 N RORUPDPI      ; Closed root of the temporary storage
"RTN","RORUPD",157,0)
 N RORVALS       ; Calculated values
"RTN","RORUPD",158,0)
 ;
"RTN","RORUPD",159,0)
 N COUNTERS,RC,REGNAME,REGIEN,TMP
"RTN","RORUPD",160,0)
 D INIT^RORUTL01("RORUPD")  K REGLST
"RTN","RORUPD",161,0)
 D CLEAR^RORERR("UPDATE^RORUPD")
"RTN","RORUPD",162,0)
 ;--- Value of the RORUPDPI variable is modified by the
"RTN","RORUPD",163,0)
 ;    $$PROCESS^RORUPD05 function if the registry update
"RTN","RORUPD",164,0)
 ;--- process runs in the multi-task mode.
"RTN","RORUPD",165,0)
 S RORUPDPI=$NA(^TMP("RORUPD",$J))
"RTN","RORUPD",166,0)
 ;--- Open a new log
"RTN","RORUPD",167,0)
 S TMP=$$SETUP^RORLOG(.RGLIST)
"RTN","RORUPD",168,0)
 S TMP=$$OPEN^RORLOG(.RGLIST,1,"REGISTRY UPDATE STARTED")
"RTN","RORUPD",169,0)
 D
"RTN","RORUPD",170,0)
 . ;--- Create a list of active registries
"RTN","RORUPD",171,0)
 . S RC=$$ARLST^RORUTL02(.RGLIST,.REGLST)  Q:RC<0
"RTN","RORUPD",172,0)
 . I $D(REGLST)<10  D  Q
"RTN","RORUPD",173,0)
 . . S RC=$$ERROR^RORERR(-28,,,,"update")
"RTN","RORUPD",174,0)
 . ;--- Lock parameters of the registries being processed
"RTN","RORUPD",175,0)
 . S RC=$$LOCKREG^RORUTL02(.REGLST,1,,"REGISTRY UPDATE")  Q:RC<0
"RTN","RORUPD",176,0)
 . I 'RC  D  K REGLST  Q
"RTN","RORUPD",177,0)
 . . S RC=$$ERROR^RORERR(-11,,,,"registries being processed")
"RTN","RORUPD",178,0)
 . ;--- Prepare selection rules
"RTN","RORUPD",179,0)
 . S:$G(SUSPEND) RORUPD("SUSPEND")=SUSPEND
"RTN","RORUPD",180,0)
 . S RC=$$PREPARE^RORUPR(.REGLST)
"RTN","RORUPD",181,0)
 . I RC<0  S RC=$$ERROR^RORERR(-14)  Q
"RTN","RORUPD",182,0)
 . ;--- Clear/Set the flags (override the default value)
"RTN","RORUPD",183,0)
 . S CLRFLG=$$UP^XLFSTR($G(CLRFLG))
"RTN","RORUPD",184,0)
 . S SETFLG=$$UP^XLFSTR($G(SETFLG))
"RTN","RORUPD",185,0)
 . S RORUPD("FLAGS")=$TR($G(RORUPD("FLAGS")),CLRFLG_SETFLG)_SETFLG
"RTN","RORUPD",186,0)
 . ;--- Display the debug information
"RTN","RORUPD",187,0)
 . D:$G(RORPARM("DEBUG"))>1 DEBUG^RORUPDUT
"RTN","RORUPD",188,0)
 . ;--- Look for new patients and update the registries
"RTN","RORUPD",189,0)
 . S RC=$$PROCESS^RORUPD05($G(MAXNTSK))  Q:RC<0
"RTN","RORUPD",190,0)
 . S COUNTERS=RC
"RTN","RORUPD",191,0)
 . ;--- Update registry parameters
"RTN","RORUPD",192,0)
 . S TMP=$$TMSTMP^RORUPD01(.REGLST)
"RTN","RORUPD",193,0)
 . ;--- Update demographic data
"RTN","RORUPD",194,0)
 . D LOG^RORLOG(,"DEMOGRAPHIC UPDATE STARTED")
"RTN","RORUPD",195,0)
 . S RC=$$UPDDEM^RORUPD51(.REGLST)
"RTN","RORUPD",196,0)
 ;
"RTN","RORUPD",197,0)
 ;--- Unlock parameters of processed registries
"RTN","RORUPD",198,0)
 S TMP=$$LOCKREG^RORUTL02(.REGLST,0)
"RTN","RORUPD",199,0)
 ;--- Statistics & Cleanup
"RTN","RORUPD",200,0)
 S TMP="REGISTRY UPDATE "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","RORUPD",201,0)
 D CLOSE^RORLOG(TMP,$G(COUNTERS))
"RTN","RORUPD",202,0)
 D:'$G(RORPARM("DEBUG"))
"RTN","RORUPD",203,0)
 . D INIT^RORUTL01("RORUPD")
"RTN","RORUPD",204,0)
 . ;--- Do not kill the list of processed patients ("U" subnode)
"RTN","RORUPD",205,0)
 . ;    in case of an error or crash during the initial registry
"RTN","RORUPD",206,0)
 . ;--- population (registry setup).
"RTN","RORUPD",207,0)
 . K:'$G(RORPARM("SETUP"))!(RC'<0) @RORUPDPI
"RTN","RORUPD",208,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPD01")
0^122^B64834418
"RTN","RORUPD01",1,0)
RORUPD01 ;HCIOFO/SG - PROCESSING OF THE FILES  ; 7/21/03 10:19am
"RTN","RORUPD01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3,5**;May 14, 2002
"RTN","RORUPD01",3,0)
 ;
"RTN","RORUPD01",4,0)
 ; This routine uses the following IA's:
"RTN","RORUPD01",5,0)
 ;
"RTN","RORUPD01",6,0)
 ; #3646         $$EMPL^DGSEC4
"RTN","RORUPD01",7,0)
 ; #10035        Browse through IENs of the file #2
"RTN","RORUPD01",8,0)
 ;
"RTN","RORUPD01",9,0)
 Q
"RTN","RORUPD01",10,0)
 ;
"RTN","RORUPD01",11,0)
 ;***** CHECKS FOR A STOP REQUESTS (TASKMAN & PROPRIETARY)
"RTN","RORUPD01",12,0)
 ;
"RTN","RORUPD01",13,0)
 ; Return Values:
"RTN","RORUPD01",14,0)
 ;        0  Continue running
"RTN","RORUPD01",15,0)
 ;        1  Stop the subtask
"RTN","RORUPD01",16,0)
 ;
"RTN","RORUPD01",17,0)
CHKSTOP() ;
"RTN","RORUPD01",18,0)
 Q:'$G(RORUPD("JOB")) $$S^%ZTLOAD
"RTN","RORUPD01",19,0)
 L +@RORUPDPI@("T",0):0
"RTN","RORUPD01",20,0)
 I  L -@RORUPDPI@("T",0)  Q 1
"RTN","RORUPD01",21,0)
 Q $$S^%ZTLOAD
"RTN","RORUPD01",22,0)
 ;
"RTN","RORUPD01",23,0)
 ;***** LOAD DATA ELEMENTS
"RTN","RORUPD01",24,0)
 ;
"RTN","RORUPD01",25,0)
 ; IENS          IENS of the current record
"RTN","RORUPD01",26,0)
 ;
"RTN","RORUPD01",27,0)
 ; Return values:
"RTN","RORUPD01",28,0)
 ;       <0  Error code
"RTN","RORUPD01",29,0)
 ;        0  Ok
"RTN","RORUPD01",30,0)
 ;
"RTN","RORUPD01",31,0)
LOAD(IENS) ;
"RTN","RORUPD01",32,0)
 N RC  S RC=0
"RTN","RORUPD01",33,0)
 ;--- API #1
"RTN","RORUPD01",34,0)
 I $D(RORUPD("SR",2,"F",1))  D  Q:RC<0 RC
"RTN","RORUPD01",35,0)
 . S RC=$$LOADFLDS^RORUPDUT(2,IENS)
"RTN","RORUPD01",36,0)
 ;--- API #2
"RTN","RORUPD01",37,0)
 Q 0
"RTN","RORUPD01",38,0)
 ;
"RTN","RORUPD01",39,0)
 ;***** INITIALIZES LOOP CONTROL LISTS
"RTN","RORUPD01",40,0)
 ;
"RTN","RORUPD01",41,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD01",42,0)
 ;
"RTN","RORUPD01",43,0)
 ; Return Values:
"RTN","RORUPD01",44,0)
 ;       <0  Error code
"RTN","RORUPD01",45,0)
 ;        0  Ok
"RTN","RORUPD01",46,0)
 ;
"RTN","RORUPD01",47,0)
 ; The RORUPD("LM",1,Rule Name) list contains names of the top level
"RTN","RORUPD01",48,0)
 ; rules that have not been triggered by now.
"RTN","RORUPD01",49,0)
 ;
"RTN","RORUPD01",50,0)
 ; The RORUPD("LM",2,Registry#) list contains IENs of the registries
"RTN","RORUPD01",51,0)
 ; that do not contain the patient by now.
"RTN","RORUPD01",52,0)
 ;
"RTN","RORUPD01",53,0)
 ; If the patient is an employee and the registry must not include
"RTN","RORUPD01",54,0)
 ; employees (see the EXCLUDE EMPLOYEES field of the ROR REGISTRY
"RTN","RORUPD01",55,0)
 ; PARAMETERS file), the function initializes the corresponding items
"RTN","RORUPD01",56,0)
 ; of control lists as if the patient were already in the registry.
"RTN","RORUPD01",57,0)
 ; Therefore, the patient will not be added to this registry.
"RTN","RORUPD01",58,0)
 ;
"RTN","RORUPD01",59,0)
LOOPINIT(PATIEN) ;
"RTN","RORUPD01",60,0)
 N I,EMPL,REGIEN
"RTN","RORUPD01",61,0)
 K RORUPD("LM",1),RORUPD("LM",2)
"RTN","RORUPD01",62,0)
 S EMPL=$$EMPL^DGSEC4(PATIEN,"P")
"RTN","RORUPD01",63,0)
 M RORUPD("LM",1)=RORUPD("LM1")
"RTN","RORUPD01",64,0)
 S REGIEN=""
"RTN","RORUPD01",65,0)
 F  S REGIEN=$O(RORUPD("LM2",REGIEN))  Q:REGIEN=""  D
"RTN","RORUPD01",66,0)
 . S $P(RORUPD("LM2",REGIEN),U)=0
"RTN","RORUPD01",67,0)
 . ;--- Check if the patient is already in the registry
"RTN","RORUPD01",68,0)
 . Q:$D(^RORDATA(798,"KEY",PATIEN,REGIEN))
"RTN","RORUPD01",69,0)
 . ;--- Check if the patient is an employee and the
"RTN","RORUPD01",70,0)
 . ;--- employees must not be added to the registry
"RTN","RORUPD01",71,0)
 . I EMPL  Q:$P(RORUPD("LM2",REGIEN),U,2)
"RTN","RORUPD01",72,0)
 . ;--- Initialize the items of control lists
"RTN","RORUPD01",73,0)
 . S $P(RORUPD("LM2",REGIEN),U)=1,RORUPD("LM",2,REGIEN)=""
"RTN","RORUPD01",74,0)
 Q 0
"RTN","RORUPD01",75,0)
 ;
"RTN","RORUPD01",76,0)
 ;***** PROCESS EVERY PATIENT IN THE 'PATIENT' FILE
"RTN","RORUPD01",77,0)
 ;
"RTN","RORUPD01",78,0)
 ; BEGIEN        Start IEN in the PATIENT file
"RTN","RORUPD01",79,0)
 ; ENDIEN        End IEN in the PATIENT file
"RTN","RORUPD01",80,0)
 ;
"RTN","RORUPD01",81,0)
 ; Return Values:
"RTN","RORUPD01",82,0)
 ;       <0  Error code
"RTN","RORUPD01",83,0)
 ;      >=0  Statistics
"RTN","RORUPD01",84,0)
 ;             ^1: Total number of processed patients
"RTN","RORUPD01",85,0)
 ;             ^2: Number of patients processed with errors
"RTN","RORUPD01",86,0)
 ;
"RTN","RORUPD01",87,0)
 ; If there is an error in processing of a patient, routine behavior
"RTN","RORUPD01",88,0)
 ; depends on the mode of execution:
"RTN","RORUPD01",89,0)
 ;
"RTN","RORUPD01",90,0)
 ; In the normal mode program logs the errors, adds a record to the
"RTN","RORUPD01",91,0)
 ; ROR PENDING PATIENT file (#798.3), and continues processing of
"RTN","RORUPD01",92,0)
 ; the remaining patients. Next registry update wil start data scan
"RTN","RORUPD01",93,0)
 ; for this patient from the date stored in the file #798.3.
"RTN","RORUPD01",94,0)
 ;
"RTN","RORUPD01",95,0)
 ; In the debug mode 3 program is aborted if there is an error
"RTN","RORUPD01",96,0)
 ; during processing of a patient.
"RTN","RORUPD01",97,0)
 ;
"RTN","RORUPD01",98,0)
PROCESS(BEGIEN,ENDIEN) ;
"RTN","RORUPD01",99,0)
 N CNT,DTNEXT,ECNT,EXIT,PATIEN,RC,TH,TMP
"RTN","RORUPD01",100,0)
 ;--- Loop through the patients
"RTN","RORUPD01",101,0)
 S:$G(ENDIEN)'>0 ENDIEN=0
"RTN","RORUPD01",102,0)
 S PATIEN=$S($G(BEGIEN)>0:$O(^DPT(BEGIEN),-1),1:0)
"RTN","RORUPD01",103,0)
 S (CNT,ECNT,EXIT,RC)=0
"RTN","RORUPD01",104,0)
 F  S PATIEN=$O(^DPT(PATIEN))  Q:PATIEN'>0  D  Q:EXIT!(RC<0)
"RTN","RORUPD01",105,0)
 . I ENDIEN,PATIEN'<ENDIEN  S EXIT=1  Q
"RTN","RORUPD01",106,0)
 . ;--- For a queued task only
"RTN","RORUPD01",107,0)
 . I $D(ZTQUEUED)  S RC=0  D  Q:RC<0
"RTN","RORUPD01",108,0)
 . . ;--- Check if task stop has been requested
"RTN","RORUPD01",109,0)
 . . I $$CHKSTOP()  S RC=$$ERROR^RORERR(-42)  Q
"RTN","RORUPD01",110,0)
 . . ;--- Check if the task should be suspended
"RTN","RORUPD01",111,0)
 . . Q:'$G(RORUPD("SUSPEND"))
"RTN","RORUPD01",112,0)
 . . Q:$$NOW^XLFDT<$G(DTNEXT)
"RTN","RORUPD01",113,0)
 . . Q:'$$SUSPEND(.DTNEXT)
"RTN","RORUPD01",114,0)
 . . ;--- Suspend the task during the peak hours
"RTN","RORUPD01",115,0)
 . . F  D  Q:'TH!(RC<0)
"RTN","RORUPD01",116,0)
 . . . S TH=$$FMDIFF^XLFDT(DTNEXT,$$NOW^XLFDT,2)
"RTN","RORUPD01",117,0)
 . . . I TH<60  S TH=0  Q       ; Do not HANG for less than a
"RTN","RORUPD01",118,0)
 . . . H $S(TH>3600:3600,1:TH)  ; minute and more than an hour
"RTN","RORUPD01",119,0)
 . . . ;--- Check if task stop has been requested
"RTN","RORUPD01",120,0)
 . . . S:$$CHKSTOP() RC=$$ERROR^RORERR(-42)
"RTN","RORUPD01",121,0)
 . ;--- Update the progress indicator
"RTN","RORUPD01",122,0)
 . S CNT=CNT+1
"RTN","RORUPD01",123,0)
 . I $G(RORPARM("DEBUG"))>1  W:$E($G(IOST),1,2)="C-" *13,CNT
"RTN","RORUPD01",124,0)
 . ;--- Process the patient
"RTN","RORUPD01",125,0)
 . S RC=$$PROCPAT(PATIEN)
"RTN","RORUPD01",126,0)
 . I $G(RORPARM("SETUP"))  D:'(CNT#1000)
"RTN","RORUPD01",127,0)
 . . D LOG^RORLOG(2,"Number of patients processed by now: "_CNT)
"RTN","RORUPD01",128,0)
 . ;--- Process the error (if any)
"RTN","RORUPD01",129,0)
 . I RC<0  D  S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORUPD01",130,0)
 . . I RC=-66  S RC=0  Q        ; Counter in the file #798.3
"RTN","RORUPD01",131,0)
 . . S ECNT=ECNT+1
"RTN","RORUPD01",132,0)
 . . S RC=$$ERROR^RORERR(-15,,,PATIEN)
"RTN","RORUPD01",133,0)
 . . ;--- Create a record in the file #798.3
"RTN","RORUPD01",134,0)
 . . S TMP=$$ADD^RORUPP01(PATIEN,RORUPD("DSBEG"))
"RTN","RORUPD01",135,0)
 . . S:TMP<0 RC=TMP
"RTN","RORUPD01",136,0)
 Q $S(RC<0:RC,1:CNT_"^"_ECNT)
"RTN","RORUPD01",137,0)
 ;
"RTN","RORUPD01",138,0)
 ;***** PROCESSES PATIENT'S DATA (EXCEPT DEMOGRAPHIC DATA)
"RTN","RORUPD01",139,0)
 ;
"RTN","RORUPD01",140,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD01",141,0)
 ; [NOUPD]       Disable registry update (0 by default)
"RTN","RORUPD01",142,0)
 ;
"RTN","RORUPD01",143,0)
 ; Return Values:
"RTN","RORUPD01",144,0)
 ;       <0  Error code
"RTN","RORUPD01",145,0)
 ;        0  Ok
"RTN","RORUPD01",146,0)
 ;
"RTN","RORUPD01",147,0)
 ; If there is a record for the patient in the ROR PENDING PATIENT
"RTN","RORUPD01",148,0)
 ; file (#798.3) and date in that record is less than a value of the
"RTN","RORUPD01",149,0)
 ; RORUPD("DSBEG") then it is used as a start date of the data scan
"RTN","RORUPD01",150,0)
 ; for the patient. Otherwise, the RORUPD("DSBEG") is used.
"RTN","RORUPD01",151,0)
 ;
"RTN","RORUPD01",152,0)
PROCPAT(PATIEN,NOUPD) ;
"RTN","RORUPD01",153,0)
 ;--- Quit if the patient has already been processed
"RTN","RORUPD01",154,0)
 Q:$D(@RORUPDPI@("U",PATIEN)) 0
"RTN","RORUPD01",155,0)
 ;--- Quit if the patient's record has been merged
"RTN","RORUPD01",156,0)
 Q:$G(^DPT(PATIEN,-9)) 0
"RTN","RORUPD01",157,0)
 ;--- Do not update the registries with a "test patient"
"RTN","RORUPD01",158,0)
 I '$G(NOUPD),$$TESTPAT^RORUTL01(PATIEN)  D  Q 0
"RTN","RORUPD01",159,0)
 . S @RORUPDPI@("U",PATIEN)=""
"RTN","RORUPD01",160,0)
 ;
"RTN","RORUPD01",161,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD01",162,0)
 ;
"RTN","RORUPD01",163,0)
 N PATIENS,RC,RLST,RORMSG,SDSDT,TMP,UPDREG,UPDSTART
"RTN","RORUPD01",164,0)
 S PATIENS=PATIEN_","
"RTN","RORUPD01",165,0)
 ;--- Initialize the variables
"RTN","RORUPD01",166,0)
 D CLEAR^RORERR("PROCPAT^RORUPD01"),CLREC^RORUPDUT
"RTN","RORUPD01",167,0)
 K RORVALS ; Clear all calculated values
"RTN","RORUPD01",168,0)
 S RC=$$LOOPINIT(PATIEN)  Q:RC<0 RC
"RTN","RORUPD01",169,0)
 ;
"RTN","RORUPD01",170,0)
 ;--- If the loop control list of registries is empty, the patient
"RTN","RORUPD01",171,0)
 ;    is already in all the registries that we are going to process.
"RTN","RORUPD01",172,0)
 S UPDREG=0
"RTN","RORUPD01",173,0)
 I $D(RORUPD("LM",2))>1  S RC=0  D  G:RC<0 PPEX  S UPDREG='$G(NOUPD)
"RTN","RORUPD01",174,0)
 . ;--- Determine start date of the data scan
"RTN","RORUPD01",175,0)
 . S UPDSTART=RORUPD("DSBEG")
"RTN","RORUPD01",176,0)
 . S SDSDT=$$SDSDATE^RORUPP01(PATIEN)
"RTN","RORUPD01",177,0)
 . I SDSDT<0  S RC=SDSDT  Q
"RTN","RORUPD01",178,0)
 . I SDSDT  S:SDSDT<UPDSTART UPDSTART=SDSDT
"RTN","RORUPD01",179,0)
 . S UPDSTART=$$FMADD^XLFDT(UPDSTART\1,-RORUPD("LD",1))
"RTN","RORUPD01",180,0)
 . ;--- Load necessary data elements
"RTN","RORUPD01",181,0)
 . I $D(RORUPD("SR",2,"F"))>1  D  Q:RC<0
"RTN","RORUPD01",182,0)
 . . S RC=$$LOAD(PATIENS)
"RTN","RORUPD01",183,0)
 . D SETVAL^RORUPDUT("ROR DFN",PATIEN)
"RTN","RORUPD01",184,0)
 . ;--- Apply "before" rules
"RTN","RORUPD01",185,0)
 . S RC=$$APLRULES^RORUPDUT(2,PATIENS,"B")  Q:RC
"RTN","RORUPD01",186,0)
 . ;
"RTN","RORUPD01",187,0)
 . ;--- Process patient data from other VistA files
"RTN","RORUPD01",188,0)
 . I $D(RORUPD("SR",9000010))  D  Q:RC
"RTN","RORUPD01",189,0)
 . . S RC=$$VISIT^RORUPD08(UPDSTART,PATIEN)
"RTN","RORUPD01",190,0)
 . I $D(RORUPD("SR",9000011))  D  Q:RC
"RTN","RORUPD01",191,0)
 . . S RC=$$PROBLEM^RORUPD07(UPDSTART,PATIEN)
"RTN","RORUPD01",192,0)
 . I $D(RORUPD("SR",45))  D       Q:RC
"RTN","RORUPD01",193,0)
 . . S RC=$$PTF^RORUPD09(UPDSTART,PATIEN)
"RTN","RORUPD01",194,0)
 . I $D(RORUPD("SR",63))  D       Q:RC
"RTN","RORUPD01",195,0)
 . . S RC=$$LAB^RORUPD04(UPDSTART,PATIEN)
"RTN","RORUPD01",196,0)
 . ; <--- Insert processing of other files here. Do not forget to add
"RTN","RORUPD01",197,0)
 . ;      definitions of these files into the 'ROR METADATA' file.
"RTN","RORUPD01",198,0)
 . ;
"RTN","RORUPD01",199,0)
 . ;--- Apply "after" rules
"RTN","RORUPD01",200,0)
 . S RC=$$APLRULES^RORUPDUT(2,PATIENS,"A")  Q:RC
"RTN","RORUPD01",201,0)
 ;
"RTN","RORUPD01",202,0)
 ;--- Update the registries if necessary
"RTN","RORUPD01",203,0)
 I UPDREG  S RC=$$UPDREG^RORUPD50(PATIEN)  G:RC<0 PPEX
"RTN","RORUPD01",204,0)
 ;--- Error processing
"RTN","RORUPD01",205,0)
 I $$GETEC^RORUPDUT  D  S RC=-15
"RTN","RORUPD01",206,0)
 . S RLST=$NA(@RORUPDPI@("U",PATIEN,2))
"RTN","RORUPD01",207,0)
 E  S RLST="",RC=0
"RTN","RORUPD01",208,0)
 ;--- If there are records in the file #798.3 for the patient,
"RTN","RORUPD01",209,0)
 ;    remove them (log a warning if cannot remove). If the patient
"RTN","RORUPD01",210,0)
 ;    has been processed with errors, remove only records associated
"RTN","RORUPD01",211,0)
 ;--- with the registries that the patient has been added to.
"RTN","RORUPD01",212,0)
 D:$G(SDSDT)
"RTN","RORUPD01",213,0)
 . S TMP=$$REMOVE^RORUPP01(PATIEN,RLST)
"RTN","RORUPD01",214,0)
 . S:TMP<0 TMP=$$ERROR^RORERR(-31,,,PATIEN)
"RTN","RORUPD01",215,0)
 ;--- Mark the patient as processed
"RTN","RORUPD01",216,0)
 S @RORUPDPI@("U",PATIEN)=""
"RTN","RORUPD01",217,0)
PPEX ;--- Cleanup
"RTN","RORUPD01",218,0)
 D CLRDES^RORUPDUT(2)
"RTN","RORUPD01",219,0)
 Q RC
"RTN","RORUPD01",220,0)
 ;
"RTN","RORUPD01",221,0)
 ;***** CHECKS IF THE TASK SHOULD BE SUSPENDED
"RTN","RORUPD01",222,0)
 ;
"RTN","RORUPD01",223,0)
 ; .DTNEXT       Date/Time of the next event (suspend/resume)
"RTN","RORUPD01",224,0)
 ;               is returned via this parameter
"RTN","RORUPD01",225,0)
 ;
"RTN","RORUPD01",226,0)
 ; Return Values:
"RTN","RORUPD01",227,0)
 ;        0  Continue/Resume
"RTN","RORUPD01",228,0)
 ;        1  Suspend
"RTN","RORUPD01",229,0)
 ;
"RTN","RORUPD01",230,0)
SUSPEND(DTNEXT) ;
"RTN","RORUPD01",231,0)
 N DATE,NOW,SUSPEND,TIME,TS,TR
"RTN","RORUPD01",232,0)
 S TS=$P(RORUPD("SUSPEND"),U,1)
"RTN","RORUPD01",233,0)
 S TR=$P(RORUPD("SUSPEND"),U,2)
"RTN","RORUPD01",234,0)
 S NOW=$$NOW^XLFDT,DATE=NOW\1
"RTN","RORUPD01",235,0)
 ;--- A working day
"RTN","RORUPD01",236,0)
 I $$WDCHK^RORUTL01(DATE)  D  Q SUSPEND
"RTN","RORUPD01",237,0)
 . S TIME=NOW-DATE,SUSPEND=0
"RTN","RORUPD01",238,0)
 . I TIME<TS   S DTNEXT=DATE+TS  Q
"RTN","RORUPD01",239,0)
 . I TIME'<TR  S DTNEXT=$$WDNEXT^RORUTL01(DATE)+TS  Q
"RTN","RORUPD01",240,0)
 . S DTNEXT=DATE+TR,SUSPEND=1
"RTN","RORUPD01",241,0)
 ;--- Saturday, Sunday or Holiday
"RTN","RORUPD01",242,0)
 S DTNEXT=$$WDNEXT^RORUTL01(DATE)+TS
"RTN","RORUPD01",243,0)
 Q 0
"RTN","RORUPD01",244,0)
 ;
"RTN","RORUPD01",245,0)
 ;***** UPDATES REGISTRY UPDATE PARAMETERS
"RTN","RORUPD01",246,0)
 ;
"RTN","RORUPD01",247,0)
 ; .REGLST       Reference to a local array containing registry names
"RTN","RORUPD01",248,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUPD01",249,0)
 ;
"RTN","RORUPD01",250,0)
 ; Return values:
"RTN","RORUPD01",251,0)
 ;       <0  Error code
"RTN","RORUPD01",252,0)
 ;        0  Ok
"RTN","RORUPD01",253,0)
 ;
"RTN","RORUPD01",254,0)
TMSTMP(REGLST) ;
"RTN","RORUPD01",255,0)
 N DATE,RC,REGIEN,REGIENS,REGNAME,RORFDA,RORMSG,TMP
"RTN","RORUPD01",256,0)
 S REGNAME="",RC=0
"RTN","RORUPD01",257,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPD01",258,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUPD01",259,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=+REGIEN  Q
"RTN","RORUPD01",260,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUPD01",261,0)
 . S REGIENS=REGIEN_","
"RTN","RORUPD01",262,0)
 . ;--- Check if the new date until that registry is updated is
"RTN","RORUPD01",263,0)
 . ;    greater than that stored in the registry parameters
"RTN","RORUPD01",264,0)
 . S TMP=$$GET1^DIQ(798.1,REGIENS,1,"I",,"RORMSG")
"RTN","RORUPD01",265,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD01",266,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,798.1,REGIENS)
"RTN","RORUPD01",267,0)
 . S DATE=RORUPD("DSEND")\1
"RTN","RORUPD01",268,0)
 . S:DATE>TMP RORFDA(798.1,REGIENS,1)=DATE
"RTN","RORUPD01",269,0)
 . ;--- Update registry parameters (if necessary)
"RTN","RORUPD01",270,0)
 . Q:$D(RORFDA)<10
"RTN","RORUPD01",271,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUPD01",272,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD01",273,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,798.1,REGIENS)
"RTN","RORUPD01",274,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPD04")
0^123^B32348134
"RTN","RORUPD04",1,0)
RORUPD04 ;HCIOFO/SG - PROCESSING OF THE LAB DATA  ; 12/18/03 3:47pm
"RTN","RORUPD04",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUPD04",3,0)
 ;
"RTN","RORUPD04",4,0)
 ; This routine uses the following IA's:
"RTN","RORUPD04",5,0)
 ;
"RTN","RORUPD04",6,0)
 ; #10035        Access to the field #63 of the file #2
"RTN","RORUPD04",7,0)
 ;
"RTN","RORUPD04",8,0)
 Q
"RTN","RORUPD04",9,0)
 ;
"RTN","RORUPD04",10,0)
 ;***** CHECKS AN INDICATOR CONDITION
"RTN","RORUPD04",11,0)
 ;
"RTN","RORUPD04",12,0)
 ; LSI           Indicator (internal value)
"RTN","RORUPD04",13,0)
 ; VAL           Indicated value
"RTN","RORUPD04",14,0)
 ; .RESULT(      Result value
"RTN","RORUPD04",15,0)
 ;   "RH")       Reference high
"RTN","RORUPD04",16,0)
 ;   "RL")       Reference low
"RTN","RORUPD04",17,0)
 ;
"RTN","RORUPD04",18,0)
 ; Return Values:
"RTN","RORUPD04",19,0)
 ;        0  False
"RTN","RORUPD04",20,0)
 ;       >0  True
"RTN","RORUPD04",21,0)
 ;
"RTN","RORUPD04",22,0)
CHKIND(LSI,VAL,RESULT) ;
"RTN","RORUPD04",23,0)
 S RESULT=$$UP^XLFSTR(RESULT)
"RTN","RORUPD04",24,0)
 ;--- Reference Range
"RTN","RORUPD04",25,0)
 I LSI=1  D  Q LSI
"RTN","RORUPD04",26,0)
 . I $G(RESULT("RL"))'=""  Q:RESULT<RESULT("RL")
"RTN","RORUPD04",27,0)
 . I $G(RESULT("RH"))'=""  Q:RESULT>RESULT("RH")
"RTN","RORUPD04",28,0)
 . S LSI=0
"RTN","RORUPD04",29,0)
 ;--- Positive Result
"RTN","RORUPD04",30,0)
 I LSI=6  Q:RESULT="P" 1  S VAL=0  D  Q VAL
"RTN","RORUPD04",31,0)
 . I RESULT'["POS",RESULT'["REA",RESULT'["DETEC"  Q
"RTN","RORUPD04",32,0)
 . I RESULT'["NEG",RESULT'["NON",RESULT'["IND"  S VAL=1
"RTN","RORUPD04",33,0)
 ;--- Compare to the value
"RTN","RORUPD04",34,0)
 Q:VAL="" 0
"RTN","RORUPD04",35,0)
 I LSI=3  Q (RESULT>VAL)
"RTN","RORUPD04",36,0)
 I LSI=4  Q (RESULT<VAL)
"RTN","RORUPD04",37,0)
 S VAL=$$UP^XLFSTR(VAL)
"RTN","RORUPD04",38,0)
 I LSI=2  Q (RESULT[VAL)
"RTN","RORUPD04",39,0)
 I LSI=5  Q (RESULT=VAL)
"RTN","RORUPD04",40,0)
 Q 0
"RTN","RORUPD04",41,0)
 ;
"RTN","RORUPD04",42,0)
 ;***** PROCESSING OF THE 'LAB DATA' FILE
"RTN","RORUPD04",43,0)
 ;
"RTN","RORUPD04",44,0)
 ; UPDSTART      Date of the earliest update (DO NOT pass by
"RTN","RORUPD04",45,0)
 ;               reference)
"RTN","RORUPD04",46,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD04",47,0)
 ;
"RTN","RORUPD04",48,0)
 ; The function uses ^TMP("RORTMP",$J) node as a temporary storage.
"RTN","RORUPD04",49,0)
 ;
"RTN","RORUPD04",50,0)
 ; Return values:
"RTN","RORUPD04",51,0)
 ;       <0  Error code
"RTN","RORUPD04",52,0)
 ;        0  Continue processing of the current patient
"RTN","RORUPD04",53,0)
 ;        1  Stop processing
"RTN","RORUPD04",54,0)
 ;
"RTN","RORUPD04",55,0)
LAB(UPDSTART,PATIEN) ;
"RTN","RORUPD04",56,0)
 N RORFILE       ; File number
"RTN","RORUPD04",57,0)
 ;
"RTN","RORUPD04",58,0)
 N DM,DSEND,LABIENS,RC,TMP
"RTN","RORUPD04",59,0)
 S RORFILE=63,DSEND=RORUPD("DSEND")
"RTN","RORUPD04",60,0)
 K RORVALS("LS")
"RTN","RORUPD04",61,0)
 ;--- If the start date is more than 60 days in the past, results
"RTN","RORUPD04",62,0)
 ;    should be loaded using collection dates. Otherwise, dates of
"RTN","RORUPD04",63,0)
 ;--- the results are used).
"RTN","RORUPD04",64,0)
 S DM=$S($$FMDIFF^XLFDT(DT,UPDSTART)>60:"^CD",1:"^RAD")
"RTN","RORUPD04",65,0)
 ;--- Check the event references if the events are enabled
"RTN","RORUPD04",66,0)
 I $G(RORUPD("FLAGS"))["E"  D  Q:RC'>0 RC
"RTN","RORUPD04",67,0)
 . S RC=$$GET^RORUPP02(PATIEN,1,.UPDSTART,.DSEND)
"RTN","RORUPD04",68,0)
 . ;--- If dates have been modified according to the event references,
"RTN","RORUPD04",69,0)
 . ;--- they are the collection dates/times.
"RTN","RORUPD04",70,0)
 . S:RC>1 UPDSTART=UPDSTART\1,DSEND=$$FMADD^XLFDT(DSEND\1,1),DM="^CD"
"RTN","RORUPD04",71,0)
 ;---
"RTN","RORUPD04",72,0)
 S RC=0,LABIENS=$$LABREF(PATIEN)_","  Q:LABIENS'>0 0
"RTN","RORUPD04",73,0)
 D
"RTN","RORUPD04",74,0)
 . ;--- Load the Lab results
"RTN","RORUPD04",75,0)
 . S RC=$$LABRSLTS^RORUTL02(PATIEN,UPDSTART_DM,DSEND_DM)
"RTN","RORUPD04",76,0)
 . I RC<0  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD04",77,0)
 . ;--- Process the results
"RTN","RORUPD04",78,0)
 . Q:$$RESULTS(PATIEN)<0
"RTN","RORUPD04",79,0)
 . ;--- Load necessary data elements
"RTN","RORUPD04",80,0)
 . I $D(RORUPD("SR",RORFILE,"F"))>1  D  I TMP<0  D INCEC^RORUPDUT()  Q
"RTN","RORUPD04",81,0)
 . . S TMP=$$LOAD(LABIENS)
"RTN","RORUPD04",82,0)
 . ;--- Apply "before" rules
"RTN","RORUPD04",83,0)
 . S RC=$$APLRULES^RORUPDUT(RORFILE,LABIENS,"B")
"RTN","RORUPD04",84,0)
 . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD04",85,0)
 . ;--- Apply "after" rules
"RTN","RORUPD04",86,0)
 . S RC=$$APLRULES^RORUPDUT(RORFILE,LABIENS,"A")
"RTN","RORUPD04",87,0)
 . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD04",88,0)
 ;
"RTN","RORUPD04",89,0)
 D CLRDES^RORUPDUT(RORFILE)
"RTN","RORUPD04",90,0)
 Q RC
"RTN","RORUPD04",91,0)
 ;
"RTN","RORUPD04",92,0)
 ;***** RETURNS A LAB REFERENCE (IEN IN 'LAB DATA') OF THE PATIENT
"RTN","RORUPD04",93,0)
 ;
"RTN","RORUPD04",94,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD04",95,0)
 ;
"RTN","RORUPD04",96,0)
 ; Return values:
"RTN","RORUPD04",97,0)
 ;       <0  Error code
"RTN","RORUPD04",98,0)
 ;        0  Patient has no laboratory data
"RTN","RORUPD04",99,0)
 ;       >0  IEN of the record in LAB DATA file
"RTN","RORUPD04",100,0)
 ;
"RTN","RORUPD04",101,0)
LABREF(PATIEN) ;
"RTN","RORUPD04",102,0)
 N LABREF,RC,RORMSG
"RTN","RORUPD04",103,0)
 S LABREF=+$$GET1^DIQ(2,PATIEN_",",63,"I",,"RORMSG")
"RTN","RORUPD04",104,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,PATIEN,2)
"RTN","RORUPD04",105,0)
 Q LABREF
"RTN","RORUPD04",106,0)
 ;
"RTN","RORUPD04",107,0)
 ;***** LOAD DATA ELEMENTS
"RTN","RORUPD04",108,0)
 ;
"RTN","RORUPD04",109,0)
 ; IENS          IENS of the current record
"RTN","RORUPD04",110,0)
 ;
"RTN","RORUPD04",111,0)
 ; Return values:
"RTN","RORUPD04",112,0)
 ;       <0  Error code
"RTN","RORUPD04",113,0)
 ;        0  Ok
"RTN","RORUPD04",114,0)
 ;
"RTN","RORUPD04",115,0)
LOAD(IENS) ;
"RTN","RORUPD04",116,0)
 N RC  S RC=0
"RTN","RORUPD04",117,0)
 ;--- API #1
"RTN","RORUPD04",118,0)
 I $D(RORUPD("SR",RORFILE,"F",1))  D  Q:RC<0 RC
"RTN","RORUPD04",119,0)
 . S RC=$$LOADFLDS^RORUPDUT(RORFILE,IENS)
"RTN","RORUPD04",120,0)
 ;--- API #2
"RTN","RORUPD04",121,0)
 Q 0
"RTN","RORUPD04",122,0)
 ;
"RTN","RORUPD04",123,0)
 ;***** EXTRACTS PROPER RESULT CODE FROM THE OBSERVATION ID
"RTN","RORUPD04",124,0)
 ;
"RTN","RORUPD04",125,0)
 ; OID           Observation ID in HL7 format
"RTN","RORUPD04",126,0)
 ; CS            HL7 component separator
"RTN","RORUPD04",127,0)
 ;
"RTN","RORUPD04",128,0)
 ; Return values:
"RTN","RORUPD04",129,0)
 ;           Lab result code (see the LA7SC parameter of
"RTN","RORUPD04",130,0)
 ;           the GCPR^LA7QRY entry point)
"RTN","RORUPD04",131,0)
 ;             ^1: Result code
"RTN","RORUPD04",132,0)
 ;             ^2: Coding system ("LN" or "NLT")
"RTN","RORUPD04",133,0)
 ;           Or an empty string if coding system is unknown or there
"RTN","RORUPD04",134,0)
 ;           are no active search indicators exist for this code.
"RTN","RORUPD04",135,0)
 ;
"RTN","RORUPD04",136,0)
RESCODE(OID,CS) ;
"RTN","RORUPD04",137,0)
 N CODE,I,RESCODE,TYPE
"RTN","RORUPD04",138,0)
 S RESCODE=""
"RTN","RORUPD04",139,0)
 F I=1,4  D  Q:RESCODE'=""
"RTN","RORUPD04",140,0)
 . S CODE=$P(OID,CS,I),TYPE=$P(OID,CS,I+2)             Q:CODE=""
"RTN","RORUPD04",141,0)
 . S TYPE=$S(TYPE="LN":"LN",TYPE="99VA64":"NLT",1:"")  Q:TYPE=""
"RTN","RORUPD04",142,0)
 . ;--- Check if the search indicators exist for this code
"RTN","RORUPD04",143,0)
 . S RESCODE=CODE_U_TYPE
"RTN","RORUPD04",144,0)
 . S:$D(@RORUPDPI@("LS",RESCODE))<10 RESCODE=""
"RTN","RORUPD04",145,0)
 Q RESCODE
"RTN","RORUPD04",146,0)
 ;
"RTN","RORUPD04",147,0)
 ;***** LOADS AND PROCESSES RESULTS OF THE TESTS
"RTN","RORUPD04",148,0)
 ;
"RTN","RORUPD04",149,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD04",150,0)
 ; ^TMP("RORTMP",
"RTN","RORUPD04",151,0)
 ;   $J,...)     HL7 message created by GCPR^LA7QRY
"RTN","RORUPD04",152,0)
 ;
"RTN","RORUPD04",153,0)
 ; Return values:
"RTN","RORUPD04",154,0)
 ;       <0  Error code
"RTN","RORUPD04",155,0)
 ;        0  Ok
"RTN","RORUPD04",156,0)
 ;
"RTN","RORUPD04",157,0)
RESULTS(PATIEN) ;
"RTN","RORUPD04",158,0)
 N DATE,I,ISEG,LSIEN,LSNODE,RC,RESCODE,RESVAL,SEG,SEGTYPE,TMP
"RTN","RORUPD04",159,0)
 N CS,FS,SCS ; HL7 Separators
"RTN","RORUPD04",160,0)
 S ISEG="",RC=0
"RTN","RORUPD04",161,0)
 F  S ISEG=$O(^TMP("RORTMP",$J,ISEG))  Q:ISEG=""  D  Q:RC<0
"RTN","RORUPD04",162,0)
 . S SEG=^TMP("RORTMP",$J,ISEG)
"RTN","RORUPD04",163,0)
 . ;--- Extract separators from the MSH segment
"RTN","RORUPD04",164,0)
 . I $E(SEG,1,3)="MSH"  D  Q
"RTN","RORUPD04",165,0)
 . . S FS=$E(SEG,4),TMP=$P(SEG,FS,2)
"RTN","RORUPD04",166,0)
 . . S CS=$E(TMP,1),SCS=$E(TMP,4)
"RTN","RORUPD04",167,0)
 . ;--- Skip all segments except OBX
"RTN","RORUPD04",168,0)
 . S SEGTYPE=$P(SEG,FS)
"RTN","RORUPD04",169,0)
 . Q:SEGTYPE'="OBX"
"RTN","RORUPD04",170,0)
 . S SEG=$P(SEG,FS,2,999)
"RTN","RORUPD04",171,0)
 . ;--- Get lab result code
"RTN","RORUPD04",172,0)
 . S RESCODE=$$RESCODE($P(SEG,FS,3),CS)  Q:RESCODE=""
"RTN","RORUPD04",173,0)
 . ;--- Load the full segment
"RTN","RORUPD04",174,0)
 . S I=""
"RTN","RORUPD04",175,0)
 . F  S I=$O(^TMP("RORTMP",$J,ISEG,I))  Q:I=""  S SEG=SEG_^(I)
"RTN","RORUPD04",176,0)
 . ;--- Get the result data
"RTN","RORUPD04",177,0)
 . S RESVAL=$P(SEG,FS,5),TMP=$P(SEG,FS,7)
"RTN","RORUPD04",178,0)
 . S RESVAL("RL")=$P(TMP,"-",1) ; Reference Low
"RTN","RORUPD04",179,0)
 . S RESVAL("RH")=$P(TMP,"-",2) ; Reference High
"RTN","RORUPD04",180,0)
 . S DATE=$$HL7TFM^XLFDT($P(SEG,FS,14),"L")\1
"RTN","RORUPD04",181,0)
 . ;--- Analyze the result
"RTN","RORUPD04",182,0)
 . S LSNODE=$NA(@RORUPDPI@("LS",RESCODE))
"RTN","RORUPD04",183,0)
 . S LSIEN=""
"RTN","RORUPD04",184,0)
 . F  S LSIEN=$O(@LSNODE@(LSIEN))  Q:LSIEN=""  D  Q:RC<0
"RTN","RORUPD04",185,0)
 . . S I="",RC=0
"RTN","RORUPD04",186,0)
 . . F  S I=$O(@LSNODE@(LSIEN,I))  Q:I=""  D  Q:RC
"RTN","RORUPD04",187,0)
 . . . S TMP=$G(@LSNODE@(LSIEN,I))
"RTN","RORUPD04",188,0)
 . . . S RC=$$CHKIND(+TMP,$P(TMP,U,2),.RESVAL)
"RTN","RORUPD04",189,0)
 . . Q:RC'>0
"RTN","RORUPD04",190,0)
 . . S TMP=+$G(RORVALS("LS",LSIEN))
"RTN","RORUPD04",191,0)
 . . S:'TMP!(DATE&(DATE<TMP)) RORVALS("LS",LSIEN)=DATE
"RTN","RORUPD04",192,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPD04",193,0)
 ;
"RTN","RORUPD04",194,0)
 ;***** IMPLEMENTATION OF THE SELECTION RULE
"RTN","RORUPD04",195,0)
 ;
"RTN","RORUPD04",196,0)
 ; LSIEN         Lab Search IEN
"RTN","RORUPD04",197,0)
 ;
"RTN","RORUPD04",198,0)
 ; Return values:
"RTN","RORUPD04",199,0)
 ;        0  Skip the patient
"RTN","RORUPD04",200,0)
 ;        1  Add the patient
"RTN","RORUPD04",201,0)
 ;
"RTN","RORUPD04",202,0)
RULE(LSIEN) ;
"RTN","RORUPD04",203,0)
 I $D(RORVALS("LS",LSIEN))  D  Q 1
"RTN","RORUPD04",204,0)
 . N DATE  S DATE=$G(RORVALS("LS",LSIEN))  Q:DATE'>0
"RTN","RORUPD04",205,0)
 . S:DATE<RORVALS("SV","ROR SRDT") RORVALS("SV","ROR SRDT")=DATE
"RTN","RORUPD04",206,0)
 Q 0
"RTN","RORUPD05")
0^124^B45537239
"RTN","RORUPD05",1,0)
RORUPD05 ;HCIOFO/SG - REGISTRY UPDATE (MULTITASK) ; 7/21/03 10:33am
"RTN","RORUPD05",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORUPD05",3,0)
 ;
"RTN","RORUPD05",4,0)
 Q
"RTN","RORUPD05",5,0)
 ;
"RTN","RORUPD05",6,0)
 ;***** MONITORS THE SUBTASKS
"RTN","RORUPD05",7,0)
 ;
"RTN","RORUPD05",8,0)
 ; Return Values:
"RTN","RORUPD05",9,0)
 ;       <0  Error code
"RTN","RORUPD05",10,0)
 ;      >=0  Combined statistics returned by the $$PROCESS^RORUPD01
"RTN","RORUPD05",11,0)
 ;           function of each subtask
"RTN","RORUPD05",12,0)
 ;
"RTN","RORUPD05",13,0)
MONITOR() ;
"RTN","RORUPD05",14,0)
 N CNT,ECNT,EXIT,RC,TASK,TIMEOUT,TSKCNT
"RTN","RORUPD05",15,0)
 S (CNT,ECNT,EXIT)=0,TIMEOUT=600 ; 10hrs = 600*60
"RTN","RORUPD05",16,0)
 F  H 60  D  Q:EXIT
"RTN","RORUPD05",17,0)
 . ;--- Exit if all subtasks finished
"RTN","RORUPD05",18,0)
 . I $D(@RORUPDPI@("T"))<10  S EXIT=1  Q
"RTN","RORUPD05",19,0)
 . ;--- Abort if some of the subtasks have not started during
"RTN","RORUPD05",20,0)
 . ;--- the predefined time frame.
"RTN","RORUPD05",21,0)
 . I TIMEOUT'>0  S EXIT=$$ERROR^RORERR(-78)  Q
"RTN","RORUPD05",22,0)
 . ;--- Check for a request to stop
"RTN","RORUPD05",23,0)
 . I $D(ZTQUEUED),$$S^%ZTLOAD  S EXIT=$$ERROR^RORERR(-42)  Q
"RTN","RORUPD05",24,0)
 . ;--- Browse through the list of subtasks
"RTN","RORUPD05",25,0)
 . S (TASK,TSKCNT)=0
"RTN","RORUPD05",26,0)
 . F  S TASK=$O(@RORUPDPI@("T",TASK))  Q:TASK=""  D
"RTN","RORUPD05",27,0)
 . . S RC=@RORUPDPI@("T",TASK),TSKCNT=TSKCNT+1
"RTN","RORUPD05",28,0)
 . . ;--- Skip a subtask that was scheduled but has not started yet
"RTN","RORUPD05",29,0)
 . . I RC="S"  S TSKCNT=TSKCNT-1  Q
"RTN","RORUPD05",30,0)
 . . ;--- Skip a running subtask
"RTN","RORUPD05",31,0)
 . . L +@RORUPDPI@("T",TASK):0  E  Q
"RTN","RORUPD05",32,0)
 . . L -@RORUPDPI@("T",TASK)
"RTN","RORUPD05",33,0)
 . . ;--- The subtask has crashed
"RTN","RORUPD05",34,0)
 . . I RC=-60  S EXIT=$$ERROR^RORERR(-60,,,,TASK)  Q
"RTN","RORUPD05",35,0)
 . . ;--- Fatal error in the subtask
"RTN","RORUPD05",36,0)
 . . I RC<0  S EXIT=+RC  D  Q
"RTN","RORUPD05",37,0)
 . . . S RC=$$ERROR^RORERR(-56,,,,+RC,"subtask #"_TASK)
"RTN","RORUPD05",38,0)
 . . ;--- The subtask is completed (accumulate the statistics)
"RTN","RORUPD05",39,0)
 . . S CNT=CNT+$P(RC,U),ECNT=ECNT+$P(RC,U,2)
"RTN","RORUPD05",40,0)
 . . K @RORUPDPI@("T",TASK)
"RTN","RORUPD05",41,0)
 . ;--- Timeout timer is ticking only if no subtasks are running
"RTN","RORUPD05",42,0)
 . S:TSKCNT'>0 TIMEOUT=TIMEOUT-1
"RTN","RORUPD05",43,0)
 Q $S(EXIT<0:EXIT,1:CNT_U_ECNT)
"RTN","RORUPD05",44,0)
 ;
"RTN","RORUPD05",45,0)
 ;***** PROCESSES THE DATA (SINGLE TASK OR MULTITASK MODE)
"RTN","RORUPD05",46,0)
 ;
"RTN","RORUPD05",47,0)
 ; [MAXNTSK]     Maximum number of data processing subtasks.
"RTN","RORUPD05",48,0)
 ;               If this parameter is less than 2, all patients
"RTN","RORUPD05",49,0)
 ;               will be processed by the single main task.
"RTN","RORUPD05",50,0)
 ;               Otherwise, all patients can be distributed among
"RTN","RORUPD05",51,0)
 ;               several subtasks.
"RTN","RORUPD05",52,0)
 ;
"RTN","RORUPD05",53,0)
 ;               If "N^M^AUTO" is passed as a value of this parameter
"RTN","RORUPD05",54,0)
 ;               and difference between the end and start dates is
"RTN","RORUPD05",55,0)
 ;               more than M days then N subtasks will be created.
"RTN","RORUPD05",56,0)
 ;
"RTN","RORUPD05",57,0)
 ; Return Values:
"RTN","RORUPD05",58,0)
 ;       <0  Error code
"RTN","RORUPD05",59,0)
 ;      >=0  Statistics returned by the $$MONITOR function
"RTN","RORUPD05",60,0)
 ;
"RTN","RORUPD05",61,0)
 ; The main task will wait for completion of the subtasks. If one
"RTN","RORUPD05",62,0)
 ; of them fails, all other (including the main one) will fail too.
"RTN","RORUPD05",63,0)
 ;
"RTN","RORUPD05",64,0)
PROCESS(MAXNTSK) ;
"RTN","RORUPD05",65,0)
 N COUNTERS,NTSK,OLDPI,RC,SUBSCR,TASKTBL,TMP
"RTN","RORUPD05",66,0)
 ;--- Calculate number of tasks and create the task table
"RTN","RORUPD05",67,0)
 D:$G(MAXNTSK)["AUTO"
"RTN","RORUPD05",68,0)
 . S TMP=$$FMDIFF^XLFDT(RORUPD("DSEND"),RORUPD("DSBEG"),1)
"RTN","RORUPD05",69,0)
 . S MAXNTSK=$S(TMP>$P(MAXNTSK,U,2):+MAXNTSK,1:0)
"RTN","RORUPD05",70,0)
 I $G(MAXNTSK)>1  D  Q:NTSK<0 NTSK
"RTN","RORUPD05",71,0)
 . S NTSK=$$TASKTBL(MAXNTSK,.TASKTBL)
"RTN","RORUPD05",72,0)
 ;--- Process all patients by the main task
"RTN","RORUPD05",73,0)
 I $G(NTSK)<2  D  Q $$PROCESS^RORUPD01()
"RTN","RORUPD05",74,0)
 . K RORUPD("SUSPEND")  ; Never suspend the single task
"RTN","RORUPD05",75,0)
 ;
"RTN","RORUPD05",76,0)
 S RORUPD("JOB")=$J,OLDPI=RORUPDPI
"RTN","RORUPD05",77,0)
 ;--- Initialize the node in the ^XTMP global
"RTN","RORUPD05",78,0)
 I $G(RORPARM("SETUP"))  D
"RTN","RORUPD05",79,0)
 . S SUBSCR="RORUPDR"_+$O(RORUPD("LM2",""))
"RTN","RORUPD05",80,0)
 . S RORUPDPI=$NA(^XTMP(SUBSCR)),I=0
"RTN","RORUPD05",81,0)
 . F  S I=$O(@RORUPDPI@(I))  Q:I=""  K:I'="U" @RORUPDPI@(I)
"RTN","RORUPD05",82,0)
 E  D
"RTN","RORUPD05",83,0)
 . S SUBSCR="RORUPDJ"_$J
"RTN","RORUPD05",84,0)
 . S RORUPDPI=$NA(^XTMP(SUBSCR))
"RTN","RORUPD05",85,0)
 . K @RORUPDPI
"RTN","RORUPD05",86,0)
 D XTMPHDR^RORUTL01(SUBSCR,30,"PROCESS-RORUPD05")
"RTN","RORUPD05",87,0)
 M @RORUPDPI=@OLDPI
"RTN","RORUPD05",88,0)
 ;--- Indicate that the main task is running
"RTN","RORUPD05",89,0)
 L +@RORUPDPI@("T",0):5
"RTN","RORUPD05",90,0)
 E  Q $$ERROR^RORERR(-61)
"RTN","RORUPD05",91,0)
 ;
"RTN","RORUPD05",92,0)
 ;--- Start the subtasks
"RTN","RORUPD05",93,0)
 S RC=$$START(.TASKTBL)
"RTN","RORUPD05",94,0)
 ;--- Monitor the subtasks
"RTN","RORUPD05",95,0)
 S COUNTERS=$S(RC'<0:$$MONITOR(),1:RC)
"RTN","RORUPD05",96,0)
 ;
"RTN","RORUPD05",97,0)
 ;--- Clear "running" flag of the main task
"RTN","RORUPD05",98,0)
 ;    (request all unfinished subtasks to stop)
"RTN","RORUPD05",99,0)
 L -@RORUPDPI@("T",0)
"RTN","RORUPD05",100,0)
 ;--- Cleanup
"RTN","RORUPD05",101,0)
 I COUNTERS<0  D
"RTN","RORUPD05",102,0)
 . N TASK,ZTSK
"RTN","RORUPD05",103,0)
 . ;--- Dequeue subtasks that have not started yet
"RTN","RORUPD05",104,0)
 . S TASK=0
"RTN","RORUPD05",105,0)
 . F  S TASK=$O(@RORUPDPI@("T",TASK))  Q:TASK=""  D
"RTN","RORUPD05",106,0)
 . . S ZTSK=TASK  D DQ^%ZTLOAD
"RTN","RORUPD05",107,0)
 . ;--- Wait for all unfinished subtasks to stop
"RTN","RORUPD05",108,0)
 . L +@RORUPDPI@("T"):300  L -@RORUPDPI@("T")
"RTN","RORUPD05",109,0)
 K @RORUPDPI@("T")
"RTN","RORUPD05",110,0)
 Q COUNTERS
"RTN","RORUPD05",111,0)
 ;
"RTN","RORUPD05",112,0)
 ;***** STARTS THE SUBTASKS
"RTN","RORUPD05",113,0)
 ;
"RTN","RORUPD05",114,0)
 ; .TASKTBL      Reference to a local variable containing the table
"RTN","RORUPD05",115,0)
 ;               of subtask parameters. See the TASKSPLT and TASKTBL
"RTN","RORUPD05",116,0)
 ;               entry points for details.
"RTN","RORUPD05",117,0)
 ;
"RTN","RORUPD05",118,0)
 ; Return Values:
"RTN","RORUPD05",119,0)
 ;       <0  Error code
"RTN","RORUPD05",120,0)
 ;        0  Ok
"RTN","RORUPD05",121,0)
 ;
"RTN","RORUPD05",122,0)
START(TASKTBL) ;
"RTN","RORUPD05",123,0)
 N CNT,I,TYPE,ZTDESC,ZTDTH,ZTIO,ZTPRI,ZTRTN,ZTSAVE,ZTSK
"RTN","RORUPD05",124,0)
 K @RORUPDPI@("T")
"RTN","RORUPD05",125,0)
 ;--- Do not allow subtasks to proceed before everything is ready
"RTN","RORUPD05",126,0)
 L +@RORUPDPI@("T"):5
"RTN","RORUPD05",127,0)
 E  Q $$ERROR^RORERR(-61)
"RTN","RORUPD05",128,0)
 ;--- Start the subtasks
"RTN","RORUPD05",129,0)
 S I=""
"RTN","RORUPD05",130,0)
 F CNT=1:1  S I=$O(TASKTBL(I))  Q:I=""  D
"RTN","RORUPD05",131,0)
 . S ZTRTN="SUBTASK^RORUPD05",ZTIO=""
"RTN","RORUPD05",132,0)
 . S ZTDTH=$$FMADD^XLFDT($$NOW^XLFDT,,,,CNT*30)
"RTN","RORUPD05",133,0)
 . S ZTDESC="Registry Update Subtask ("_$TR(TASKTBL(I),U,"-")_")"
"RTN","RORUPD05",134,0)
 . S ZTSAVE("RORIENS")=TASKTBL(I)
"RTN","RORUPD05",135,0)
 . S ZTSAVE("RORLRC(")=""
"RTN","RORUPD05",136,0)
 . S ZTSAVE("RORPARM(")=""
"RTN","RORUPD05",137,0)
 . S ZTSAVE("RORUPD(")=""
"RTN","RORUPD05",138,0)
 . S ZTSAVE("RORUPDPI")=""
"RTN","RORUPD05",139,0)
 . D ^%ZTLOAD
"RTN","RORUPD05",140,0)
 . ;--- Indicate that the subtask has been scheduled
"RTN","RORUPD05",141,0)
 . S @RORUPDPI@("T",ZTSK)="S"
"RTN","RORUPD05",142,0)
 . S TMP=$$MSG^RORERR20(-62,.TYPE,,ZTSK)
"RTN","RORUPD05",143,0)
 . D LOG^RORLOG(TYPE,TMP)
"RTN","RORUPD05",144,0)
 ;--- The subtasks may proceed now
"RTN","RORUPD05",145,0)
 L -@RORUPDPI@("T")
"RTN","RORUPD05",146,0)
 Q 0
"RTN","RORUPD05",147,0)
 ;
"RTN","RORUPD05",148,0)
 ;***** DATA PROCESSING SUBTASK
"RTN","RORUPD05",149,0)
 ;
"RTN","RORUPD05",150,0)
 ; RORIENS       Diapason of IENs in the 'PATIENT' file
"RTN","RORUPD05",151,0)
 ;                 ^1: Start IEN
"RTN","RORUPD05",152,0)
 ;                 ^2: End IEN
"RTN","RORUPD05",153,0)
 ; RORLRC        List of Lab result codes to check
"RTN","RORUPD05",154,0)
 ; RORPARM       Application parameters
"RTN","RORUPD05",155,0)
 ; RORUPD        Registry update descriptor
"RTN","RORUPD05",156,0)
 ; RORUPDPI      Closed root of the temporary storage
"RTN","RORUPD05",157,0)
 ;
"RTN","RORUPD05",158,0)
SUBTASK ;
"RTN","RORUPD05",159,0)
 N RORERROR      ; Error processing data
"RTN","RORUPD05",160,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORUPD05",161,0)
 ;
"RTN","RORUPD05",162,0)
 N RC,TASK,TMP,TYPE
"RTN","RORUPD05",163,0)
 S TASK=ZTSK
"RTN","RORUPD05",164,0)
 ;--- We are not in the KIDS environment anymore
"RTN","RORUPD05",165,0)
 K RORPARM("KIDS")
"RTN","RORUPD05",166,0)
 ;--- Disable debug output (subtask has no device)
"RTN","RORUPD05",167,0)
 S:$G(RORPARM("DEBUG"))>1 RORPARM("DEBUG")=1
"RTN","RORUPD05",168,0)
 ;--- Indicate that the subtask is running
"RTN","RORUPD05",169,0)
 L +@RORUPDPI@("T",TASK):180
"RTN","RORUPD05",170,0)
 E  S RC=$$ERROR^RORERR(-61)  Q
"RTN","RORUPD05",171,0)
 ;--- Check if the main task is running
"RTN","RORUPD05",172,0)
 L +@RORUPDPI@("T",0):0
"RTN","RORUPD05",173,0)
 I  D
"RTN","RORUPD05",174,0)
 . ;--- Cleanup if the main task is not running
"RTN","RORUPD05",175,0)
 . L -@RORUPDPI@("T",0)
"RTN","RORUPD05",176,0)
 . K @RORUPDPI@("T",TASK)
"RTN","RORUPD05",177,0)
 E  D
"RTN","RORUPD05",178,0)
 . N REGIEN,REGLST
"RTN","RORUPD05",179,0)
 . ;--- Error code that will be in effect if the subtask crashes
"RTN","RORUPD05",180,0)
 . S @RORUPDPI@("T",TASK)=-60
"RTN","RORUPD05",181,0)
 . ;--- Initialize the variables
"RTN","RORUPD05",182,0)
 . D INIT^RORUTL01(),CLEAR^RORERR("SUBTASK^RORUPD05")
"RTN","RORUPD05",183,0)
 . S REGIEN=""
"RTN","RORUPD05",184,0)
 . F  S REGIEN=$O(@RORUPDPI@(2,REGIEN))  Q:REGIEN=""  D
"RTN","RORUPD05",185,0)
 . . S TMP=$P(@RORUPDPI@(2,REGIEN),U)  S:TMP'="" REGLST(TMP)=REGIEN
"RTN","RORUPD05",186,0)
 . S TMP="REGISTRY UPDATE SUBTASK #"_TASK_" STARTED"
"RTN","RORUPD05",187,0)
 . S TMP=$$OPEN^RORLOG(.REGLST,1,TMP)
"RTN","RORUPD05",188,0)
 . ;--- Process the patients from 'Start IEN' to 'End IEN'
"RTN","RORUPD05",189,0)
 . S RC=$$PROCESS^RORUPD01($P(RORIENS,U),$P(RORIENS,U,2))
"RTN","RORUPD05",190,0)
 . ;--- Set the error code returned by the registry update process
"RTN","RORUPD05",191,0)
 . S @RORUPDPI@("T",TASK)=RC
"RTN","RORUPD05",192,0)
 . ;--- Cleanup and error processing
"RTN","RORUPD05",193,0)
 . S:RC=-42 ZTSTOP=1
"RTN","RORUPD05",194,0)
 . S TMP="REGISTRY UPDATE SUBTASK "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","RORUPD05",195,0)
 . D CLOSE^RORLOG(TMP,$S(RC'<0:RC,1:""))
"RTN","RORUPD05",196,0)
 ;--- Clear "running" flag of the subtask
"RTN","RORUPD05",197,0)
 L -@RORUPDPI@("T",TASK)
"RTN","RORUPD05",198,0)
 S ZTREQ="@"
"RTN","RORUPD05",199,0)
 Q
"RTN","RORUPD05",200,0)
 ;
"RTN","RORUPD05",201,0)
 ;***** CALCULATES TABLE OF SUBTASKS
"RTN","RORUPD05",202,0)
 ;
"RTN","RORUPD05",203,0)
 ; MAXNTSK       Maximum number of data processing subtasks
"RTN","RORUPD05",204,0)
 ;
"RTN","RORUPD05",205,0)
 ; .TASKTBL      Reference to a local variable where table of
"RTN","RORUPD05",206,0)
 ;               subtask parameters is returned:
"RTN","RORUPD05",207,0)
 ;
"RTN","RORUPD05",208,0)
 ;               TASKTBL       Number of subtasks
"RTN","RORUPD05",209,0)
 ;               TASKTBL(I)    Subtask parameters
"RTN","RORUPD05",210,0)
 ;                               ^1: Start IEN
"RTN","RORUPD05",211,0)
 ;                               ^2: End IEN
"RTN","RORUPD05",212,0)
 ;
"RTN","RORUPD05",213,0)
 ; Return Values:
"RTN","RORUPD05",214,0)
 ;       <0  Error code
"RTN","RORUPD05",215,0)
 ;        0  Process all data by the main task
"RTN","RORUPD05",216,0)
 ;       >1  Number of subtasks
"RTN","RORUPD05",217,0)
 ;
"RTN","RORUPD05",218,0)
 ; If the PATIENT file contains more than 100,000 records, up to
"RTN","RORUPD05",219,0)
 ; MAXNTSK data processing subtasks may be defined. Otherwise, the
"RTN","RORUPD05",220,0)
 ; data should be processed by the main task.
"RTN","RORUPD05",221,0)
 ;
"RTN","RORUPD05",222,0)
 ; The function uses the ^TMP("RORTMP",$J) global node.
"RTN","RORUPD05",223,0)
 ;
"RTN","RORUPD05",224,0)
TASKTBL(MAXNTSK,RORTBL) ;
"RTN","RORUPD05",225,0)
 N I,IEN,INC,LST,NR
"RTN","RORUPD05",226,0)
 K RORTBL,^TMP("RORTMP",$J)
"RTN","RORUPD05",227,0)
 ;--- Get number of records in the PATIENT file
"RTN","RORUPD05",228,0)
 S NR=$$GET1^DID(2,,,"ENTRIES",,"RORMSG")
"RTN","RORUPD05",229,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9)
"RTN","RORUPD05",230,0)
 Q:NR'>100000 0
"RTN","RORUPD05",231,0)
 ;--- Generate IEN intervals (no more than 300)
"RTN","RORUPD05",232,0)
 S INC=NR\300,NR=0  S:INC<1 INC=1
"RTN","RORUPD05",233,0)
 F IEN=0:INC  S IEN=$O(^DPT(IEN))  Q:IEN'>0  D
"RTN","RORUPD05",234,0)
 . S NR=NR+1,^TMP("RORTMP",$J,NR)=IEN
"RTN","RORUPD05",235,0)
 ;--- Generate the task table
"RTN","RORUPD05",236,0)
 S IEN=1,INC=NR/MAXNTSK
"RTN","RORUPD05",237,0)
 F RORTBL=1:1  D  Q:(RORTBL'<MAXNTSK)!(IEN'>0)
"RTN","RORUPD05",238,0)
 . S RORTBL(RORTBL)=IEN
"RTN","RORUPD05",239,0)
 . S I=$J(RORTBL*INC,0,0),IEN=$G(^TMP("RORTMP",$J,I))
"RTN","RORUPD05",240,0)
 . S $P(RORTBL(RORTBL),U,2)=IEN
"RTN","RORUPD05",241,0)
 K ^TMP("RORTMP",$J)
"RTN","RORUPD05",242,0)
 ;--- Analize the result
"RTN","RORUPD05",243,0)
 I $G(RORTBL)<2  K RORTBL
"RTN","RORUPD05",244,0)
 E  S $P(RORTBL(RORTBL),U,2)=$O(^DPT(" "),-1)
"RTN","RORUPD05",245,0)
 Q +$G(RORTBL)
"RTN","RORUPD06")
0^150^B11384765
"RTN","RORUPD06",1,0)
RORUPD06 ;HCIOFO/SG - REGISTRY UPDATE (MISCELLANEOUS) ; 11/25/03 3:49pm
"RTN","RORUPD06",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3,5**;May 14, 2002
"RTN","RORUPD06",3,0)
 ;
"RTN","RORUPD06",4,0)
 Q
"RTN","RORUPD06",5,0)
 ;
"RTN","RORUPD06",6,0)
 ;***** ADDS THE PATIENT TO THE REGISTRY (UNCONDITIONALLY)
"RTN","RORUPD06",7,0)
 ;
"RTN","RORUPD06",8,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD06",9,0)
 ; REGNAME       Registry name
"RTN","RORUPD06",10,0)
 ; .RULES        Reference to a local array containing list of
"RTN","RORUPD06",11,0)
 ;               triggered selection rules: RULES(n)=RuleIEN^Date
"RTN","RORUPD06",12,0)
 ;
"RTN","RORUPD06",13,0)
 ; Return Values:
"RTN","RORUPD06",14,0)
 ;       <0  Error code (see MSGLIST^RORERR20)
"RTN","RORUPD06",15,0)
 ;        0  Ok
"RTN","RORUPD06",16,0)
 ;
"RTN","RORUPD06",17,0)
ADDPAT(PATIEN,REGNAME,RULES) ;
"RTN","RORUPD06",18,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD06",19,0)
 N RORUPD        ; Update descriptor
"RTN","RORUPD06",20,0)
 N RORUPDPI      ; Closed root of the temporary storage
"RTN","RORUPD06",21,0)
 ;
"RTN","RORUPD06",22,0)
 N I,RC,REGIEN,REGLST,RORLRC,RORSRLST,RULEIEN,VSRLST
"RTN","RORUPD06",23,0)
 D INIT^RORUTL01("RORUPD")
"RTN","RORUPD06",24,0)
 D CLEAR^RORERR("ADDPAT^RORUPD06")
"RTN","RORUPD06",25,0)
 S RORUPDPI=$NA(^TMP("RORUPD",$J))
"RTN","RORUPD06",26,0)
 ;--- Check the registry name
"RTN","RORUPD06",27,0)
 Q:REGNAME?." " $$ERROR^RORERR(-10,,,PATIEN,REGNAME)
"RTN","RORUPD06",28,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)  Q:REGIEN<0 REGIEN
"RTN","RORUPD06",29,0)
 S REGLST(REGNAME)=REGIEN
"RTN","RORUPD06",30,0)
 ;--- Compile a list of IENs of valid selection rules
"RTN","RORUPD06",31,0)
 S I=""
"RTN","RORUPD06",32,0)
 F  S I=$O(^ROR(798.1,REGIEN,1,"B",I))  Q:I=""  D
"RTN","RORUPD06",33,0)
 . S RULEIEN=$$SRLIEN^RORUTL02(I)  S:RULEIEN>0 VSRLST(RULEIEN)=""
"RTN","RORUPD06",34,0)
 ;--- Prepare list of triggered selection rules
"RTN","RORUPD06",35,0)
 S I="",RC=0
"RTN","RORUPD06",36,0)
 F  S I=$O(RULES(I))  Q:I=""  D  Q:RC<0
"RTN","RORUPD06",37,0)
 . S RULEIEN=$P(RULES(I),U)
"RTN","RORUPD06",38,0)
 . I RULEIEN'>0            S RC=$$ERROR^RORERR(-45)  Q
"RTN","RORUPD06",39,0)
 . I '$D(VSRLST(RULEIEN))  S RC=$$ERROR^RORERR(-45)  Q
"RTN","RORUPD06",40,0)
 . S RORSRLST(RULEIEN)=$P(RULES(I),U,2)
"RTN","RORUPD06",41,0)
 Q:RC<0 RC
"RTN","RORUPD06",42,0)
 ;--- Prepare update descriptor
"RTN","RORUPD06",43,0)
 S RC=$$PREPARE1^RORUPR(.REGLST)
"RTN","RORUPD06",44,0)
 Q:RC<0 $$ERROR^RORERR(-14,,,PATIEN)
"RTN","RORUPD06",45,0)
 ;--- Add the patient to the registry
"RTN","RORUPD06",46,0)
 S RC=$$ADDPDATA^RORUPD50(PATIEN)               Q:RC<0 RC
"RTN","RORUPD06",47,0)
 S RC=$$ADD^RORUPD50(PATIEN,REGIEN,"RORSRLST")  Q:RC<0 RC
"RTN","RORUPD06",48,0)
 ;--- Update patient demographic data
"RTN","RORUPD06",49,0)
 S RC=$$UPDPTDEM^RORUPD51(PATIEN)
"RTN","RORUPD06",50,0)
 Q:RC<0 $$ERROR^RORERR(-16,,,PATIEN)
"RTN","RORUPD06",51,0)
 ;--- Cleanup
"RTN","RORUPD06",52,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("RORUPD")
"RTN","RORUPD06",53,0)
 Q 0
"RTN","RORUPD06",54,0)
 ;
"RTN","RORUPD06",55,0)
 ;***** CHECKS/UPDATES THE SINGLE PATIENT IN THE REGISTRY
"RTN","RORUPD06",56,0)
 ;
"RTN","RORUPD06",57,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD06",58,0)
 ; REGNAME       Registry name
"RTN","RORUPD06",59,0)
 ;
"RTN","RORUPD06",60,0)
 ; .UPDBYRUL     Reference to a local array for the list of rules that
"RTN","RORUPD06",61,0)
 ;               the patient is selected by (output). The list has
"RTN","RORUPD06",62,0)
 ;               the following structure: UPDBYRUL(Rule#)=Date, where
"RTN","RORUPD06",63,0)
 ;               "Rule#" is an IEN of the selection rule in the file
"RTN","RORUPD06",64,0)
 ;               #798.2 and "Date" is the date when the patient has
"RTN","RORUPD06",65,0)
 ;               passed the selection rule for the first time.
"RTN","RORUPD06",66,0)
 ;
"RTN","RORUPD06",67,0)
 ; [CHKONLY]     If this optional parameter is undefined (default)
"RTN","RORUPD06",68,0)
 ;               or equals to zero then the function checks a patient
"RTN","RORUPD06",69,0)
 ;               against selection rules and adds him to the registry 
"RTN","RORUPD06",70,0)
 ;               if he passes at least one of the rules.
"RTN","RORUPD06",71,0)
 ;               Otherwise, the patient is only checked against the
"RTN","RORUPD06",72,0)
 ;               rules but registry is not updated.
"RTN","RORUPD06",73,0)
 ;
"RTN","RORUPD06",74,0)
 ; Return Values:
"RTN","RORUPD06",75,0)
 ;       <0  Error code (see MSGLIST^RORERR20)
"RTN","RORUPD06",76,0)
 ;        0  Ok
"RTN","RORUPD06",77,0)
 ;
"RTN","RORUPD06",78,0)
 ; If a local array passed as the UPDBYRUL parameter is undefined
"RTN","RORUPD06",79,0)
 ; after return from the function then the patient has not pass any
"RTN","RORUPD06",80,0)
 ; selection rule.
"RTN","RORUPD06",81,0)
 ;
"RTN","RORUPD06",82,0)
UPDPAT(PATIEN,REGNAME,UPDBYRUL,CHKONLY) ;
"RTN","RORUPD06",83,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD06",84,0)
 N RORLRC        ; List of Lab result codes to check
"RTN","RORUPD06",85,0)
 N RORUPD        ; Update descriptor
"RTN","RORUPD06",86,0)
 N RORUPDPI      ; Closed root of the temporary storage
"RTN","RORUPD06",87,0)
 N RORVALS       ; Calculated values
"RTN","RORUPD06",88,0)
 ;
"RTN","RORUPD06",89,0)
 N RC,REGIEN,REGLST
"RTN","RORUPD06",90,0)
 D INIT^RORUTL01("RORUPD")
"RTN","RORUPD06",91,0)
 D CLEAR^RORERR("UPDPAT^RORUPD06")
"RTN","RORUPD06",92,0)
 S RORUPDPI=$NA(^TMP("RORUPD",$J))
"RTN","RORUPD06",93,0)
 ;--- Check the registry name
"RTN","RORUPD06",94,0)
 Q:REGNAME?." " $$ERROR^RORERR(-10,,,PATIEN,REGNAME)
"RTN","RORUPD06",95,0)
 S REGLST(REGNAME)=""  K UPDBYRUL
"RTN","RORUPD06",96,0)
 ;--- Prepare selection rules
"RTN","RORUPD06",97,0)
 S RC=$$PREPARE^RORUPR(.REGLST)
"RTN","RORUPD06",98,0)
 Q:RC<0 $$ERROR^RORERR(-14,,,PATIEN)
"RTN","RORUPD06",99,0)
 D:$G(RORPARM("DEBUG"))>1 DEBUG^RORUPDUT
"RTN","RORUPD06",100,0)
 ;--- Check the patient and update the registry
"RTN","RORUPD06",101,0)
 S RC=$$PROCPAT^RORUPD01(PATIEN,$G(CHKONLY))
"RTN","RORUPD06",102,0)
 Q:RC<0 $$ERROR^RORERR(-15,,,PATIEN)
"RTN","RORUPD06",103,0)
 ;--- Update patient demographic data
"RTN","RORUPD06",104,0)
 I '$G(CHKONLY)  D  Q:RC<0 $$ERROR^RORERR(-16,,,PATIEN)
"RTN","RORUPD06",105,0)
 . S RC=$$UPDPTDEM^RORUPD51(PATIEN)
"RTN","RORUPD06",106,0)
 ;--- Load the list of triggered rules
"RTN","RORUPD06",107,0)
 S REGIEN=""
"RTN","RORUPD06",108,0)
 F  S REGIEN=$O(@RORUPDPI@("U",PATIEN,2,REGIEN))  Q:REGIEN=""  D
"RTN","RORUPD06",109,0)
 . M UPDBYRUL=@RORUPDPI@("U",PATIEN,2,REGIEN)
"RTN","RORUPD06",110,0)
 ;--- Cleanup
"RTN","RORUPD06",111,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("RORUPD")
"RTN","RORUPD06",112,0)
 Q 0
"RTN","RORUPD08")
0^125^B18491466
"RTN","RORUPD08",1,0)
RORUPD08 ;HCIOFO/SG - PROCESSING OF 'VISIT' & 'V POV' FILES  ; 7/21/03 10:21am
"RTN","RORUPD08",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUPD08",3,0)
 ;
"RTN","RORUPD08",4,0)
 ; This routine uses the following IAs:
"RTN","RORUPD08",5,0)
 ;
"RTN","RORUPD08",6,0)
 ; #1554         POV^PXAPIIB
"RTN","RORUPD08",7,0)
 ; #1905         SELECTED^VSIT
"RTN","RORUPD08",8,0)
 ; #1906         LOOKUP^VSIT
"RTN","RORUPD08",9,0)
 ;
"RTN","RORUPD08",10,0)
 Q
"RTN","RORUPD08",11,0)
 ;
"RTN","RORUPD08",12,0)
 ;***** LOADS 'V POV' DATA ELEMENTS
"RTN","RORUPD08",13,0)
 ;
"RTN","RORUPD08",14,0)
 ; IENS          IENS of the current record
"RTN","RORUPD08",15,0)
 ;
"RTN","RORUPD08",16,0)
 ; Return values:
"RTN","RORUPD08",17,0)
 ;       <0  Error code
"RTN","RORUPD08",18,0)
 ;        0  Ok
"RTN","RORUPD08",19,0)
 ;
"RTN","RORUPD08",20,0)
LOADVPOV(IENS) ;
"RTN","RORUPD08",21,0)
 N RC  S RC=0
"RTN","RORUPD08",22,0)
 ;--- API #1
"RTN","RORUPD08",23,0)
 I $D(RORUPD("SR",RORFILE,"F",1))  D  Q:RC<0 RC
"RTN","RORUPD08",24,0)
 . S RC=$$LOADFLDS^RORUPDUT(RORFILE,IENS)
"RTN","RORUPD08",25,0)
 ;--- API #2
"RTN","RORUPD08",26,0)
 I $D(RORUPD("SR",RORFILE,"F",2))  D  Q:RC<0 RC
"RTN","RORUPD08",27,0)
 . N BUF,DE,IP,RORMSG,TMP,VT
"RTN","RORUPD08",28,0)
 . S BUF=$G(RORVPLST(+IENS)),DE=""
"RTN","RORUPD08",29,0)
 . F  S DE=$O(RORUPD("SR",RORFILE,"F",2,DE))  Q:DE=""  D
"RTN","RORUPD08",30,0)
 . . S VT=""
"RTN","RORUPD08",31,0)
 . . F  S VT=$O(RORUPD("SR",RORFILE,"F",2,DE,VT))  Q:VT=""  D
"RTN","RORUPD08",32,0)
 . . . S IP=+$P(RORUPD("SR",RORFILE,"F",2,DE,VT),U)
"RTN","RORUPD08",33,0)
 . . . S:IP>0 RORVALS("DV",RORFILE,DE,VT)=$P(BUF,U,IP)
"RTN","RORUPD08",34,0)
 . ;--- External value of the POV field (.01)
"RTN","RORUPD08",35,0)
 . I $D(RORUPD("SR",RORFILE,"F",2,112,"E"))  D  Q:RC<0
"RTN","RORUPD08",36,0)
 . . S TMP=$P(BUF,U)_","  Q:TMP'>0
"RTN","RORUPD08",37,0)
 . . S RORVALS("DV",RORFILE,112,"E")=$$GET1^DIQ(80,TMP,.01,,,"RORMSG")
"RTN","RORUPD08",38,0)
 . . I $G(DIERR)  D  Q
"RTN","RORUPD08",39,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,,,80,TMP)
"RTN","RORUPD08",40,0)
 Q 0
"RTN","RORUPD08",41,0)
 ;
"RTN","RORUPD08",42,0)
 ;***** LOAD 'VISIT' DATA ELEMENTS
"RTN","RORUPD08",43,0)
 ;
"RTN","RORUPD08",44,0)
 ; IENS          IENS of the current record
"RTN","RORUPD08",45,0)
 ;
"RTN","RORUPD08",46,0)
 ; Return values:
"RTN","RORUPD08",47,0)
 ;       <0  Error code
"RTN","RORUPD08",48,0)
 ;        0  Ok
"RTN","RORUPD08",49,0)
 ;
"RTN","RORUPD08",50,0)
LOADVSIT(IENS) ;
"RTN","RORUPD08",51,0)
 N RC  S RC=0
"RTN","RORUPD08",52,0)
 ;--- API #1
"RTN","RORUPD08",53,0)
 I $D(RORUPD("SR",RORFILE,"F",1))  D  Q:RC<0 RC
"RTN","RORUPD08",54,0)
 . S RC=$$LOADFLDS^RORUPDUT(RORFILE,IENS)
"RTN","RORUPD08",55,0)
 ;--- API #2
"RTN","RORUPD08",56,0)
 I $D(RORUPD("SR",RORFILE,"F",2))  D  Q:RC<0 RC
"RTN","RORUPD08",57,0)
 . N API,TMP,VSIT
"RTN","RORUPD08",58,0)
 . S TMP=$$LOOKUP^VSIT(+IENS,"B",0)
"RTN","RORUPD08",59,0)
 . I TMP<0  S API="$$LOOKUP^VSIT"  D  Q
"RTN","RORUPD08",60,0)
 . . S RC=$$ERROR^RORERR(-57,,,,TMP,API)
"RTN","RORUPD08",61,0)
 . ;---
"RTN","RORUPD08",62,0)
 Q 0
"RTN","RORUPD08",63,0)
 ;
"RTN","RORUPD08",64,0)
 ;***** PROCESSING OF THE 'VISIT' FILE
"RTN","RORUPD08",65,0)
 ;
"RTN","RORUPD08",66,0)
 ; UPDSTART      Date of the earliest update
"RTN","RORUPD08",67,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD08",68,0)
 ;
"RTN","RORUPD08",69,0)
 ; Return values:
"RTN","RORUPD08",70,0)
 ;       <0  Error code
"RTN","RORUPD08",71,0)
 ;        0  Continue processing of the current patient
"RTN","RORUPD08",72,0)
 ;        1  Stop processing
"RTN","RORUPD08",73,0)
 ;
"RTN","RORUPD08",74,0)
 ; The function uses the ^TMP("VSIT",$J) global node.
"RTN","RORUPD08",75,0)
 ;
"RTN","RORUPD08",76,0)
VISIT(UPDSTART,PATIEN) ;
"RTN","RORUPD08",77,0)
 N RORFILE       ; File number
"RTN","RORUPD08",78,0)
 ;
"RTN","RORUPD08",79,0)
 N DATE,DSEND,IEN,RC,TMP,VISIENS
"RTN","RORUPD08",80,0)
 S RORFILE=9000010,DSEND=RORUPD("DSEND")
"RTN","RORUPD08",81,0)
 ;--- Check the event references if the events are enabled
"RTN","RORUPD08",82,0)
 I $G(RORUPD("FLAGS"))["E"  D  Q:RC'>0 RC
"RTN","RORUPD08",83,0)
 . S RC=$$GET^RORUPP02(PATIEN,2,.UPDSTART,.DSEND)
"RTN","RORUPD08",84,0)
 . S:RC>1 UPDSTART=UPDSTART\1,DSEND=$$FMADD^XLFDT(DSEND\1,1)
"RTN","RORUPD08",85,0)
 ;--- Get a list of visits
"RTN","RORUPD08",86,0)
 D SELECTED^VSIT(PATIEN,UPDSTART,DSEND)
"RTN","RORUPD08",87,0)
 ;
"RTN","RORUPD08",88,0)
 ;--- Browse through the visits
"RTN","RORUPD08",89,0)
 S (IEN,RC)=0
"RTN","RORUPD08",90,0)
 F  S IEN=$O(^TMP("VSIT",$J,IEN))  Q:IEN=""  D  Q:RC
"RTN","RORUPD08",91,0)
 . S VISIENS=IEN_",",TMP=+$O(^TMP("VSIT",$J,IEN,""))
"RTN","RORUPD08",92,0)
 . S DATE=$P($G(^TMP("VSIT",$J,IEN,TMP)),U)
"RTN","RORUPD08",93,0)
 . ;--- Load necessary data elements
"RTN","RORUPD08",94,0)
 . I $D(RORUPD("SR",RORFILE,"F"))>1  D  I TMP<0 D INCEC^RORUPDUT() Q
"RTN","RORUPD08",95,0)
 . . S TMP=$$LOADVSIT(VISIENS)
"RTN","RORUPD08",96,0)
 . ;--- Apply "before" rules
"RTN","RORUPD08",97,0)
 . S RC=$$APLRULES^RORUPDUT(RORFILE,VISIENS,"B",DATE)
"RTN","RORUPD08",98,0)
 . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD08",99,0)
 . ;
"RTN","RORUPD08",100,0)
 . ;--- Process V POV file
"RTN","RORUPD08",101,0)
 . I $D(RORUPD("SR",9000010.07))  D  I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD08",102,0)
 . . S RC=$$VPOV(IEN,DATE)
"RTN","RORUPD08",103,0)
 . ;
"RTN","RORUPD08",104,0)
 . ;--- Apply "after" rules
"RTN","RORUPD08",105,0)
 . S RC=$$APLRULES^RORUPDUT(RORFILE,VISIENS,"A",DATE)
"RTN","RORUPD08",106,0)
 . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD08",107,0)
 ;
"RTN","RORUPD08",108,0)
 K ^TMP("VSIT",$J)
"RTN","RORUPD08",109,0)
 D CLRDES^RORUPDUT(RORFILE)
"RTN","RORUPD08",110,0)
 Q RC
"RTN","RORUPD08",111,0)
 ;
"RTN","RORUPD08",112,0)
 ;***** PROCESSING OF THE 'V POV' FILE
"RTN","RORUPD08",113,0)
 ;
"RTN","RORUPD08",114,0)
 ; VISITIEN      IEN of the visit (in the "VISIT" file)
"RTN","RORUPD08",115,0)
 ; DATE          Visit date
"RTN","RORUPD08",116,0)
 ;
"RTN","RORUPD08",117,0)
 ; Return values:
"RTN","RORUPD08",118,0)
 ;       <0  Error code
"RTN","RORUPD08",119,0)
 ;        0  Continue processing of the current patient
"RTN","RORUPD08",120,0)
 ;        1  Stop processing
"RTN","RORUPD08",121,0)
 ;
"RTN","RORUPD08",122,0)
VPOV(VISITIEN,DATE) ;
"RTN","RORUPD08",123,0)
 N RORFILE       ; File number
"RTN","RORUPD08",124,0)
 N RORVPLST      ; List of records in the file
"RTN","RORUPD08",125,0)
 ;
"RTN","RORUPD08",126,0)
 N IEN,NODE,RC,TMP,VPIENS
"RTN","RORUPD08",127,0)
 S RORFILE=9000010.07
"RTN","RORUPD08",128,0)
 D CLRVALS^RORUPDUT(RORFILE)
"RTN","RORUPD08",129,0)
 ;--- Get a list of records
"RTN","RORUPD08",130,0)
 D POV^PXAPIIB(VISITIEN,.RORVPLST)
"RTN","RORUPD08",131,0)
 ;
"RTN","RORUPD08",132,0)
 S (IEN,RC)=0
"RTN","RORUPD08",133,0)
 F  S IEN=$O(RORVPLST(IEN))  Q:IEN=""  D  Q:RC
"RTN","RORUPD08",134,0)
 . S VPIENS=IEN_","
"RTN","RORUPD08",135,0)
 . ;--- Load necessary data elements
"RTN","RORUPD08",136,0)
 . I $D(RORUPD("SR",RORFILE,"F"))>1  D  I TMP<0 D INCEC^RORUPDUT() Q
"RTN","RORUPD08",137,0)
 . . S TMP=$$LOADVPOV(VPIENS)
"RTN","RORUPD08",138,0)
 . ;--- Apply "before" rules
"RTN","RORUPD08",139,0)
 . S RC=$$APLRULES^RORUPDUT(RORFILE,VPIENS,"B",DATE)
"RTN","RORUPD08",140,0)
 . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD08",141,0)
 . ;--- Apply "after" rules
"RTN","RORUPD08",142,0)
 . S RC=$$APLRULES^RORUPDUT(RORFILE,VPIENS,"A",DATE)
"RTN","RORUPD08",143,0)
 . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD08",144,0)
 ;
"RTN","RORUPD08",145,0)
 D CLRDES^RORUPDUT(RORFILE)
"RTN","RORUPD08",146,0)
 Q RC
"RTN","RORUPD09")
0^133^B8417015
"RTN","RORUPD09",1,0)
RORUPD09 ;HCIOFO/SG - PROCESSING OF THE 'PTF' FILE  ; 7/21/03 10:21am
"RTN","RORUPD09",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUPD09",3,0)
 ;
"RTN","RORUPD09",4,0)
 ; This routine uses the following IAs:
"RTN","RORUPD09",5,0)
 ;
"RTN","RORUPD09",6,0)
 ; #3157         RPC^DGPTFAPI
"RTN","RORUPD09",7,0)
 ; #3545         Access to the "AAD" cross-reference and the field 80
"RTN","RORUPD09",8,0)
 ;
"RTN","RORUPD09",9,0)
 Q
"RTN","RORUPD09",10,0)
 ;
"RTN","RORUPD09",11,0)
 ;***** LOADS DATA ELEMENT VALUES
"RTN","RORUPD09",12,0)
 ;
"RTN","RORUPD09",13,0)
 ; IENS          IENS of the current record
"RTN","RORUPD09",14,0)
 ;
"RTN","RORUPD09",15,0)
 ; Return values:
"RTN","RORUPD09",16,0)
 ;       <0  Error code
"RTN","RORUPD09",17,0)
 ;        0  Ok
"RTN","RORUPD09",18,0)
 ;
"RTN","RORUPD09",19,0)
LOAD(IENS) ;
"RTN","RORUPD09",20,0)
 N RC  S RC=0
"RTN","RORUPD09",21,0)
 ;--- API #1
"RTN","RORUPD09",22,0)
 I $D(RORUPD("SR",RORFILE,"F",1))  D  Q:RC<0 RC
"RTN","RORUPD09",23,0)
 . S RC=$$LOADFLDS^RORUPDUT(RORFILE,IENS)
"RTN","RORUPD09",24,0)
 ;--- API #2
"RTN","RORUPD09",25,0)
 I $D(RORUPD("SR",RORFILE,"F",2))  D  Q:RC<0 RC
"RTN","RORUPD09",26,0)
 . N API,DE,IN,IP,RORBUF,VT
"RTN","RORUPD09",27,0)
 . D RPC^DGPTFAPI(.RORBUF,+IENS)
"RTN","RORUPD09",28,0)
 . I $G(RORBUF(0))<0  S API="RPC^DGPTFAPI"  D  Q
"RTN","RORUPD09",29,0)
 . . S RC=$$ERROR^RORERR(-57,,,,RORBUF(0),API)
"RTN","RORUPD09",30,0)
 . ;---
"RTN","RORUPD09",31,0)
 . S DE=""
"RTN","RORUPD09",32,0)
 . F  S DE=$O(RORUPD("SR",RORFILE,"F",2,DE))  Q:DE=""  D
"RTN","RORUPD09",33,0)
 . . S VT=""
"RTN","RORUPD09",34,0)
 . . F  S VT=$O(RORUPD("SR",RORFILE,"F",2,DE,VT))  Q:VT=""  D
"RTN","RORUPD09",35,0)
 . . . S IP=+$P(RORUPD("SR",RORFILE,"F",2,DE,VT),U,1)  Q:IP'>0
"RTN","RORUPD09",36,0)
 . . . S IN=+$P(RORUPD("SR",RORFILE,"F",2,DE,VT),U,2)
"RTN","RORUPD09",37,0)
 . . . S RORVALS("DV",RORFILE,DE,VT)=$P($G(RORBUF(IN)),U,IP)
"RTN","RORUPD09",38,0)
 Q 0
"RTN","RORUPD09",39,0)
 ;
"RTN","RORUPD09",40,0)
 ;***** PROCESSING OF THE 'PTF' FILE
"RTN","RORUPD09",41,0)
 ;
"RTN","RORUPD09",42,0)
 ; UPDSTART      Date of the earliest update
"RTN","RORUPD09",43,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD09",44,0)
 ;
"RTN","RORUPD09",45,0)
 ; Return values:
"RTN","RORUPD09",46,0)
 ;       <0  Error code
"RTN","RORUPD09",47,0)
 ;        0  Continue processing of the current patient
"RTN","RORUPD09",48,0)
 ;        1  Stop processing
"RTN","RORUPD09",49,0)
 ;
"RTN","RORUPD09",50,0)
PTF(UPDSTART,PATIEN) ;
"RTN","RORUPD09",51,0)
 N RORFILE       ; File number
"RTN","RORUPD09",52,0)
 ;
"RTN","RORUPD09",53,0)
 N ADMDT,ADMIENS,EDT,IEN,NODE,RC,TMP
"RTN","RORUPD09",54,0)
 S RORFILE=45,EDT=RORUPD("DSEND")
"RTN","RORUPD09",55,0)
 ;--- Check the event references if the events are enabled
"RTN","RORUPD09",56,0)
 I $G(RORUPD("FLAGS"))["E"  D  Q:RC'>0 RC
"RTN","RORUPD09",57,0)
 . S RC=$$GET^RORUPP02(PATIEN,3,.UPDSTART,.EDT)
"RTN","RORUPD09",58,0)
 . S:RC>1 UPDSTART=UPDSTART\1,EDT=$$FMADD^XLFDT(EDT\1,1)
"RTN","RORUPD09",59,0)
 ;--- Subtract 1 second from the start date to include
"RTN","RORUPD09",60,0)
 ;    it into the interval
"RTN","RORUPD09",61,0)
 S ADMDT=$$FMADD^XLFDT(UPDSTART,,,,-1)
"RTN","RORUPD09",62,0)
 ;
"RTN","RORUPD09",63,0)
 ;--- Browse through the admissions
"RTN","RORUPD09",64,0)
 S NODE=RORUPD("ROOT",RORFILE),NODE=$NA(@NODE@("AAD",PATIEN))
"RTN","RORUPD09",65,0)
 S RC=0
"RTN","RORUPD09",66,0)
 F  S ADMDT=$O(@NODE@(ADMDT))  Q:(ADMDT="")!(ADMDT'<EDT)  D  Q:RC
"RTN","RORUPD09",67,0)
 . S IEN=""
"RTN","RORUPD09",68,0)
 . F  S IEN=$O(@NODE@(ADMDT,IEN))  Q:IEN=""  D  Q:RC
"RTN","RORUPD09",69,0)
 . . S ADMIENS=IEN_","
"RTN","RORUPD09",70,0)
 . . ;--- Load necessary data elements
"RTN","RORUPD09",71,0)
 . . I $D(RORUPD("SR",RORFILE,"F"))>1  D  I TMP<0 D INCEC^RORUPDUT() Q
"RTN","RORUPD09",72,0)
 . . . S TMP=$$LOAD(ADMIENS)
"RTN","RORUPD09",73,0)
 . . ;--- Apply "before" rules
"RTN","RORUPD09",74,0)
 . . S RC=$$APLRULES^RORUPDUT(RORFILE,ADMIENS,"B",ADMDT)
"RTN","RORUPD09",75,0)
 . . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD09",76,0)
 . . ;--- Apply "after" rules
"RTN","RORUPD09",77,0)
 . . S RC=$$APLRULES^RORUPDUT(RORFILE,ADMIENS,"A",ADMDT)
"RTN","RORUPD09",78,0)
 . . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD09",79,0)
 ;
"RTN","RORUPD09",80,0)
 D CLRDES^RORUPDUT(RORFILE)
"RTN","RORUPD09",81,0)
 Q RC
"RTN","RORUPD09",82,0)
 ;
"RTN","RORUPD09",83,0)
 ;***** IMPLEMENTATION OF THE 'VA HEPC PTF' RULE
"RTN","RORUPD09",84,0)
PTFRULE(ICD) ;
"RTN","RORUPD09",85,0)
 N DATELMT,RC
"RTN","RORUPD09",86,0)
 S RC=0
"RTN","RORUPD09",87,0)
 F DATELMT=111,101,102,103,104,105,106,107,108,109,110  D  Q:RC
"RTN","RORUPD09",88,0)
 . S RC=ICD[(","_$G(RORVALS("DV",45,DATELMT,"E"))_",")
"RTN","RORUPD09",89,0)
 Q RC
"RTN","RORUPD50")
0^126^B12929200
"RTN","RORUPD50",1,0)
RORUPD50 ;HCIOFO/SG - UPDATE THE PATIENT IN THE REGISTRIES  ; 11/25/03 3:45pm
"RTN","RORUPD50",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3,5**;May 14, 2002
"RTN","RORUPD50",3,0)
 ;
"RTN","RORUPD50",4,0)
 Q
"RTN","RORUPD50",5,0)
 ;
"RTN","RORUPD50",6,0)
 ;***** ADDS THE PATIENT TO THE REGISTRY
"RTN","RORUPD50",7,0)
 ;
"RTN","RORUPD50",8,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD50",9,0)
 ; REGIEN        Registry IEN
"RTN","RORUPD50",10,0)
 ;
"RTN","RORUPD50",11,0)
 ; [ROR8RULS]    Closed root of a local array containing list of
"RTN","RORUPD50",12,0)
 ;               triggered selection rules:
"RTN","RORUPD50",13,0)
 ;                 @ROR8RULS@(RuleIEN)=Date
"RTN","RORUPD50",14,0)
 ;               If this parameter is not defined or equals to
"RTN","RORUPD50",15,0)
 ;               an empty string, selection rules are loaded from
"RTN","RORUPD50",16,0)
 ;               corresponding sub-node of the ^TMP("RORUPD",$J,"U").
"RTN","RORUPD50",17,0)
 ;
"RTN","RORUPD50",18,0)
 ; [[.]DOD]      Date of death. If this parameter is undefined,
"RTN","RORUPD50",19,0)
 ;               its value will be taken from the ROR PATIENT file.
"RTN","RORUPD50",20,0)
 ;               If you are going to call this function several times
"RTN","RORUPD50",21,0)
 ;               for the same patient (for different registries),
"RTN","RORUPD50",22,0)
 ;               pass a reference to undefined local variable (the
"RTN","RORUPD50",23,0)
 ;               DOD will be read from the file only once).
"RTN","RORUPD50",24,0)
 ;
"RTN","RORUPD50",25,0)
 ; Return values:
"RTN","RORUPD50",26,0)
 ;       <0  Error code
"RTN","RORUPD50",27,0)
 ;        0  Ok
"RTN","RORUPD50",28,0)
 ;        1  Patient has already existed in the registry
"RTN","RORUPD50",29,0)
 ;
"RTN","RORUPD50",30,0)
ADD(PATIEN,REGIEN,ROR8RULS,DOD) ;
"RTN","RORUPD50",31,0)
 N I,IENS,IENS01,RC,RORFDA,RORIEN,RORMSG,RULEIEN,TMP
"RTN","RORUPD50",32,0)
 ;--- Quit if the patient is already in the registry
"RTN","RORUPD50",33,0)
 Q:$$PRRIEN^RORUTL01(PATIEN,REGIEN)>0 1
"RTN","RORUPD50",34,0)
 ;
"RTN","RORUPD50",35,0)
 ;--- Prepare registry data
"RTN","RORUPD50",36,0)
 K RORFDA  S IENS="+1,"
"RTN","RORUPD50",37,0)
 S RORFDA(798,IENS,.01)=PATIEN           ; Patient Name
"RTN","RORUPD50",38,0)
 S RORFDA(798,IENS,.02)=REGIEN           ; Registry
"RTN","RORUPD50",39,0)
 S RORFDA(798,IENS,3)=1                  ; AUTO
"RTN","RORUPD50",40,0)
 S RORFDA(798,IENS,4)=1                  ; Update Demographics
"RTN","RORUPD50",41,0)
 S RORFDA(798,IENS,5)=1                  ; Update local data
"RTN","RORUPD50",42,0)
 S RORFDA(798,IENS,12)=1                 ; Can be deleted
"RTN","RORUPD50",43,0)
 ;--- Populate the inactivation date field if necessary
"RTN","RORUPD50",44,0)
 S:'($D(DOD)#10) DOD=$$GET1^DIQ(798.4,PATIEN_",",.351,"I",,"RORMSG")
"RTN","RORUPD50",45,0)
 S RORFDA(798,IENS,2)=$$INACTDOD^RORUPDUT(DOD)
"RTN","RORUPD50",46,0)
 ;--- Set the DON'T SEND flag for a "test patient"
"RTN","RORUPD50",47,0)
 S:$$TESTPAT^RORUTL01(PATIEN) RORFDA(798,IENS,11)=1
"RTN","RORUPD50",48,0)
 ;--- Load list of triggered rules
"RTN","RORUPD50",49,0)
 S:$G(ROR8RULS)="" ROR8RULS=$NA(@RORUPDPI@("U",PATIEN,2,REGIEN))
"RTN","RORUPD50",50,0)
 S RULEIEN=""
"RTN","RORUPD50",51,0)
 F I=1:1  S RULEIEN=$O(@ROR8RULS@(RULEIEN))  Q:RULEIEN=""  D
"RTN","RORUPD50",52,0)
 . S IENS01="+"_(1000+I)_","_IENS
"RTN","RORUPD50",53,0)
 . S RORFDA(798.01,IENS01,.01)=RULEIEN
"RTN","RORUPD50",54,0)
 . S RORFDA(798.01,IENS01,1)=$P(@ROR8RULS@(RULEIEN),U)\1
"RTN","RORUPD50",55,0)
 ;
"RTN","RORUPD50",56,0)
 ;--- Registry update transaction
"RTN","RORUPD50",57,0)
 S RC=0  D
"RTN","RORUPD50",58,0)
 . ;--- Call "before update" entry point
"RTN","RORUPD50",59,0)
 . S ENTRY=$G(RORUPD("UPD",REGIEN,1))
"RTN","RORUPD50",60,0)
 . I ENTRY'=""  X "S RC="_ENTRY_"(.RORFDA,PATIEN,REGIEN)"  Q:RC<0
"RTN","RORUPD50",61,0)
 . ;--- Update the registry
"RTN","RORUPD50",62,0)
 . D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORUPD50",63,0)
 . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9)  Q
"RTN","RORUPD50",64,0)
 . ;--- Call "after update" entry point
"RTN","RORUPD50",65,0)
 . S ENTRY=$G(RORUPD("UPD",REGIEN,2))
"RTN","RORUPD50",66,0)
 . I ENTRY'=""  X "S RC="_ENTRY_"(RORIEN(1),PATIEN,REGIEN)"  Q:RC<0
"RTN","RORUPD50",67,0)
 Q:RC'<0 0
"RTN","RORUPD50",68,0)
 ;
"RTN","RORUPD50",69,0)
 ;--- Rollback the update in case of error(s)
"RTN","RORUPD50",70,0)
 N DA,DIK
"RTN","RORUPD50",71,0)
 S DIK=$$ROOT^DILFD(798),DA=$G(RORIEN(1))
"RTN","RORUPD50",72,0)
 D:DA>0 ^DIK
"RTN","RORUPD50",73,0)
 Q RC
"RTN","RORUPD50",74,0)
 ;
"RTN","RORUPD50",75,0)
 ;***** ADDS PATIENT DATA TO THE 'ROR PATIENT' FILE
"RTN","RORUPD50",76,0)
 ;
"RTN","RORUPD50",77,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD50",78,0)
 ;
"RTN","RORUPD50",79,0)
 ; Return values:
"RTN","RORUPD50",80,0)
 ;       <0  Error code
"RTN","RORUPD50",81,0)
 ;        0  Ok
"RTN","RORUPD50",82,0)
 ;        1  Patient data have already existed
"RTN","RORUPD50",83,0)
 ;
"RTN","RORUPD50",84,0)
ADDPDATA(PATIEN) ;
"RTN","RORUPD50",85,0)
 N IENS,RC,RORBUF,RORPAT,RORIEN,RORMSG
"RTN","RORUPD50",86,0)
 ;--- Try to find patient data
"RTN","RORUPD50",87,0)
 D FIND^DIC(798.4,,"@","QUX",PATIEN,1,"B",,,"RORBUF","RORMSG")
"RTN","RORUPD50",88,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.4)
"RTN","RORUPD50",89,0)
 ;--- Patient data already exists in the file
"RTN","RORUPD50",90,0)
 Q:$G(RORBUF("DILIST",0)) 1
"RTN","RORUPD50",91,0)
 ;--- Check if the patient record in the file #2 is valid
"RTN","RORUPD50",92,0)
 S RC=$$CHKPTR^RORUTL05(PATIEN)  Q:RC<0 RC
"RTN","RORUPD50",93,0)
 ;--- Prepare patient data
"RTN","RORUPD50",94,0)
 S IENS="+1,"
"RTN","RORUPD50",95,0)
 S RC=$$PATDATA^RORUPD52(PATIEN_",",.RORPAT,IENS)  Q:RC<0 RC
"RTN","RORUPD50",96,0)
 S RORIEN(1)=PATIEN                      ; IEN of the new record
"RTN","RORUPD50",97,0)
 S RORPAT(798.4,IENS,.01)=PATIEN         ; Patient Name
"RTN","RORUPD50",98,0)
 ;--- Add the patient record to the file
"RTN","RORUPD50",99,0)
 D UPDATE^DIE(,"RORPAT","RORIEN","RORMSG")
"RTN","RORUPD50",100,0)
 I $G(DIERR)  D  Q:RC
"RTN","RORUPD50",101,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,798.4)
"RTN","RORUPD50",102,0)
 Q 0
"RTN","RORUPD50",103,0)
 ;
"RTN","RORUPD50",104,0)
 ;***** ADDS THE PATIENT TO MARKED REGISTRIES
"RTN","RORUPD50",105,0)
 ;
"RTN","RORUPD50",106,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD50",107,0)
 ;
"RTN","RORUPD50",108,0)
 ; Return values:
"RTN","RORUPD50",109,0)
 ;       <0  Error code
"RTN","RORUPD50",110,0)
 ;        0  Patient should not be added to the registry
"RTN","RORUPD50",111,0)
 ;       >0  Patient has been added to the registry
"RTN","RORUPD50",112,0)
 ;
"RTN","RORUPD50",113,0)
UPDREG(PATIEN) ;
"RTN","RORUPD50",114,0)
 N DOD,ENTRY,INCTVDT,RC,REGIEN
"RTN","RORUPD50",115,0)
 ;--- Check if patient should be added to any registry
"RTN","RORUPD50",116,0)
 Q:$D(@RORUPDPI@("U",PATIEN,2))<10 0
"RTN","RORUPD50",117,0)
 ;--- Add patient data
"RTN","RORUPD50",118,0)
 S RC=$$ADDPDATA(PATIEN)  Q:RC<0 RC
"RTN","RORUPD50",119,0)
 ;--- Update all marked registries
"RTN","RORUPD50",120,0)
 S REGIEN="",RC=0
"RTN","RORUPD50",121,0)
 F  D  Q:REGIEN=""  S RC=$$ADD(PATIEN,REGIEN,,.DOD)  Q:RC<0
"RTN","RORUPD50",122,0)
 . S REGIEN=$O(@RORUPDPI@("U",PATIEN,2,REGIEN))
"RTN","RORUPD50",123,0)
 Q $S(RC<0:RC,1:1)
"RTN","RORUPD51")
0^127^B25850083
"RTN","RORUPD51",1,0)
RORUPD51 ;HCIOFO/SG - UPDATE PATIENT'S DEMOGRAPHIC DATA (1) ; 7/25/03 10:36am
"RTN","RORUPD51",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3,5**;May 14, 2002
"RTN","RORUPD51",3,0)
 ;
"RTN","RORUPD51",4,0)
 Q
"RTN","RORUPD51",5,0)
 ;
"RTN","RORUPD51",6,0)
 ;***** MARKS REGISTRIES (UPDATE DEMOGRAPHICS AND INACTIVE DATE)
"RTN","RORUPD51",7,0)
 ;
"RTN","RORUPD51",8,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD51",9,0)
 ; [DOD]         Date of death
"RTN","RORUPD51",10,0)
 ;
"RTN","RORUPD51",11,0)
 ; Return Values:
"RTN","RORUPD51",12,0)
 ;       <0  Error code
"RTN","RORUPD51",13,0)
 ;        0  Ok
"RTN","RORUPD51",14,0)
 ;
"RTN","RORUPD51",15,0)
MARKREGS(PATIEN,DOD) ;
"RTN","RORUPD51",16,0)
 N ACTIVE,ECNT,I,IENS,INACTDT,RC,RI,TMP
"RTN","RORUPD51",17,0)
 N RORBUF,RORFDA,RORMSG,RORSRC
"RTN","RORUPD51",18,0)
 ;--- Compile a list of associated registries
"RTN","RORUPD51",19,0)
 D FIND^DIC(798,,"@","QUX",PATIEN,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPD51",20,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,PATIEN,798)
"RTN","RORUPD51",21,0)
 ;--- Mark patient records of the registries
"RTN","RORUPD51",22,0)
 S RI="",ECNT=0
"RTN","RORUPD51",23,0)
 F  S RI=$O(RORBUF("DILIST",2,RI))  Q:RI=""  D  L -^RORDATA(798,+IENS)
"RTN","RORUPD51",24,0)
 . S IENS=RORBUF("DILIST",2,RI)_","
"RTN","RORUPD51",25,0)
 . K RORFDA,RORSRC
"RTN","RORUPD51",26,0)
 . ;--- Try to lock the record; if this fails, continue anyway
"RTN","RORUPD51",27,0)
 . L +^RORDATA(798,+IENS):1
"RTN","RORUPD51",28,0)
 . ;--- Load the field values
"RTN","RORUPD51",29,0)
 . D GETS^DIQ(798,IENS,"2;2.2;4;8","EI","RORSRC","RORMSG")
"RTN","RORUPD51",30,0)
 . I $G(DIERR)  D  S ECNT=ECNT+1  Q
"RTN","RORUPD51",31,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,798,IENS)
"RTN","RORUPD51",32,0)
 . S ACTIVE=+$G(RORSRC(798,IENS,8,"E"))
"RTN","RORUPD51",33,0)
 . S INACTDT=$G(RORSRC(798,IENS,2,"I"))
"RTN","RORUPD51",34,0)
 . ;--- Update inactivation date only if the DOD parameter
"RTN","RORUPD51",35,0)
 . ;    is defined and the patient has not been inactivated
"RTN","RORUPD51",36,0)
 . ;--- by a reason other than death
"RTN","RORUPD51",37,0)
 . I $D(DOD),'$G(RORSRC(798,IENS,2.2,"I"))  D
"RTN","RORUPD51",38,0)
 . . ;--- Do nothing if the patient is alive and there is no
"RTN","RORUPD51",39,0)
 . . ;--- inactivation date in his record
"RTN","RORUPD51",40,0)
 . . I 'DOD  Q:'INACTDT
"RTN","RORUPD51",41,0)
 . . S (RORFDA(798,IENS,2),INACTDT)=$$INACTDOD^RORUPDUT(DOD)
"RTN","RORUPD51",42,0)
 . . S RORFDA(798,IENS,2.1)="@"
"RTN","RORUPD51",43,0)
 . ;--- Do not mark again if already marked
"RTN","RORUPD51",44,0)
 . I '$G(RORSRC(798,IENS,4,"I"))  S RC=0  D  Q:RC<0
"RTN","RORUPD51",45,0)
 . . ;--- Check the new status of the record if it was
"RTN","RORUPD51",46,0)
 . . ;--- not active before
"RTN","RORUPD51",47,0)
 . . S:'ACTIVE ACTIVE=$$ACTIVE^RORDD(+IENS)
"RTN","RORUPD51",48,0)
 . . ;--- Mark only active (now or before) records
"RTN","RORUPD51",49,0)
 . . S:ACTIVE RORFDA(798,IENS,4)=1
"RTN","RORUPD51",50,0)
 . ;--- Update registry data record
"RTN","RORUPD51",51,0)
 . I $D(RORFDA)>1  S RC=0  D  Q:RC<0
"RTN","RORUPD51",52,0)
 . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUPD51",53,0)
 . . I $G(DIERR)  D  S ECNT=ECNT+1
"RTN","RORUPD51",54,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,798,IENS)
"RTN","RORUPD51",55,0)
 Q $S(ECNT>0:-9,1:0)
"RTN","RORUPD51",56,0)
 ;
"RTN","RORUPD51",57,0)
 ;***** SCANS PATIENTS AND UPDATES DEMOGRAPHIC DATA (IF NECESSARY)
"RTN","RORUPD51",58,0)
 ;
"RTN","RORUPD51",59,0)
 ; .REGLST       Reference to a local array containing
"RTN","RORUPD51",60,0)
 ;               registry names as subscripts
"RTN","RORUPD51",61,0)
 ;
"RTN","RORUPD51",62,0)
 ; Return Values:
"RTN","RORUPD51",63,0)
 ;       <0  Error code
"RTN","RORUPD51",64,0)
 ;        0  Ok
"RTN","RORUPD51",65,0)
 ;
"RTN","RORUPD51",66,0)
UPDDEM(REGLST) ;
"RTN","RORUPD51",67,0)
 N CNT,IR,PATIEN,RC,REGIEN,REGNAME,ROOT,SCR,UPD,UPDCNT
"RTN","RORUPD51",68,0)
 N RORLOR,RORLST,RORMSG
"RTN","RORUPD51",69,0)
 S ROOT=$$ROOT^DILFD(798,,1)
"RTN","RORUPD51",70,0)
 ;--- Compile a list of registry internal entry numbers
"RTN","RORUPD51",71,0)
 S REGNAME="",RC=0
"RTN","RORUPD51",72,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPD51",73,0)
 . S RC=+$G(REGLST(REGNAME))
"RTN","RORUPD51",74,0)
 . S:RC'>0 RC=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUPD51",75,0)
 . S:RC>0 RORLOR(+RC)=""
"RTN","RORUPD51",76,0)
 Q:RC<0 RC
"RTN","RORUPD51",77,0)
 ;--- Loop through the patients of the registries
"RTN","RORUPD51",78,0)
 S PATIEN="",(CNT,RC)=0
"RTN","RORUPD51",79,0)
 F  S PATIEN=$O(@ROOT@("B",PATIEN))  Q:PATIEN=""  D  Q:RC<0
"RTN","RORUPD51",80,0)
 . ;--- Check if task stop has been requested
"RTN","RORUPD51",81,0)
 . I $D(ZTQUEUED),$$S^%ZTLOAD  D  Q
"RTN","RORUPD51",82,0)
 . . S RC=$$ERROR^RORERR(-42)
"RTN","RORUPD51",83,0)
 . S CNT=CNT+1
"RTN","RORUPD51",84,0)
 . I $G(RORPARM("DEBUG"))>1  W:$E($G(IOST),1,2)="C-" *13,CNT
"RTN","RORUPD51",85,0)
 . ;--- Load a list of patient's registry records
"RTN","RORUPD51",86,0)
 . S SCR="S Y=+$P($G(^(0)),U,2) I Y,$D(RORLOR(Y))"
"RTN","RORUPD51",87,0)
 . D FIND^DIC(798,,"@;.02I;2.2I;8E","QUX",PATIEN,,"B",SCR,,"RORLST","RORMSG")
"RTN","RORUPD51",88,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD51",89,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,798)
"RTN","RORUPD51",90,0)
 . ;--- Demographic data should be checked only if at least one of
"RTN","RORUPD51",91,0)
 . ;    the registry records of the patient is either active or the
"RTN","RORUPD51",92,0)
 . ;    REASON FOR INACTIVATION field (798,2.2) has no value (this
"RTN","RORUPD51",93,0)
 . ;    means that the patient has been inactivated because of death).
"RTN","RORUPD51",94,0)
 . S IR="",UPDCNT=0
"RTN","RORUPD51",95,0)
 . F  S IR=$O(RORLST("DILIST","ID",IR))  Q:IR=""  D
"RTN","RORUPD51",96,0)
 . . S UPD=+$G(RORLST("DILIST","ID",IR,8))
"RTN","RORUPD51",97,0)
 . . S REGIEN=+$G(RORLST("DILIST","ID",IR,.02))
"RTN","RORUPD51",98,0)
 . . S CNT(REGIEN,UPD)=$G(CNT(REGIEN,UPD))+1
"RTN","RORUPD51",99,0)
 . . ;---
"RTN","RORUPD51",100,0)
 . . S:'UPD UPD='$G(RORLST("DILIST","ID",IR,2.2))
"RTN","RORUPD51",101,0)
 . . S:UPD UPDCNT=UPDCNT+1
"RTN","RORUPD51",102,0)
 . S:UPDCNT RC=$$UPDPTDEM(PATIEN)
"RTN","RORUPD51",103,0)
 D:RC'<0 UPDRCNT(.CNT)
"RTN","RORUPD51",104,0)
 Q RC
"RTN","RORUPD51",105,0)
 ;
"RTN","RORUPD51",106,0)
 ;***** UPDATES DEMOGRAPHIC DATA OF THE PATIENT (IF NECESSARY)
"RTN","RORUPD51",107,0)
 ;
"RTN","RORUPD51",108,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD51",109,0)
 ;
"RTN","RORUPD51",110,0)
 ; Return Values:
"RTN","RORUPD51",111,0)
 ;       <0  Error code
"RTN","RORUPD51",112,0)
 ;        0  Ok
"RTN","RORUPD51",113,0)
 ;
"RTN","RORUPD51",114,0)
UPDPTDEM(PATIEN) ;
"RTN","RORUPD51",115,0)
 N CF,DOD,IENS,RC,RORMSG,RORPAT
"RTN","RORUPD51",116,0)
 S IENS=PATIEN_",",CF=0
"RTN","RORUPD51",117,0)
 ;--- Try to lock the record of the ROR PATIENT file
"RTN","RORUPD51",118,0)
 L +^RORDATA(798.4,PATIEN):1
"RTN","RORUPD51",119,0)
 E  Q $$ERROR^RORERR(-11,,,PATIEN,"file #798.4")
"RTN","RORUPD51",120,0)
 D
"RTN","RORUPD51",121,0)
 . ;--- Compare demographic data
"RTN","RORUPD51",122,0)
 . S RC=$$PATDATA^RORUPD52(IENS,.RORPAT,IENS,.DOD)  Q:RC<0
"RTN","RORUPD51",123,0)
 . S:RC CF=1
"RTN","RORUPD51",124,0)
 . ;--- Mark registry records of the patient
"RTN","RORUPD51",125,0)
 . I CF  S RC=$$MARKREGS(PATIEN,$G(DOD))  Q:RC<0
"RTN","RORUPD51",126,0)
 . ;--- Update demographic data
"RTN","RORUPD51",127,0)
 . I CF,$D(RORPAT)>1  S RC=0  D  Q:RC<0
"RTN","RORUPD51",128,0)
 . . D FILE^DIE(,"RORPAT","RORMSG")  Q:'$G(DIERR)
"RTN","RORUPD51",129,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,798.4)
"RTN","RORUPD51",130,0)
 ;
"RTN","RORUPD51",131,0)
 L -^RORDATA(798.4,PATIEN)
"RTN","RORUPD51",132,0)
 Q 0
"RTN","RORUPD51",133,0)
 ;
"RTN","RORUPD51",134,0)
 ;***** UPDATES RECORD COUNTERS IN THE 'ROR REGISTRY PARAMETERS' FILE
"RTN","RORUPD51",135,0)
 ;
"RTN","RORUPD51",136,0)
 ; .CNT(         Reference to a local array containg registry
"RTN","RORUPD51",137,0)
 ;               record counters
"RTN","RORUPD51",138,0)
 ;   Registry#,
"RTN","RORUPD51",139,0)
 ;     0)        Number of inactive records
"RTN","RORUPD51",140,0)
 ;     1)        Number of active records
"RTN","RORUPD51",141,0)
 ;
"RTN","RORUPD51",142,0)
UPDRCNT(CNT) ;
"RTN","RORUPD51",143,0)
 N IENS,RC,REGIEN,RORFDA,RORMSG
"RTN","RORUPD51",144,0)
 S REGIEN=0
"RTN","RORUPD51",145,0)
 F  S REGIEN=$O(CNT(REGIEN))  Q:REGIEN=""  D
"RTN","RORUPD51",146,0)
 . S IENS=REGIEN_","
"RTN","RORUPD51",147,0)
 . S RORFDA(798.1,IENS,19.1)=$G(CNT(REGIEN,0))+$G(CNT(REGIEN,1))
"RTN","RORUPD51",148,0)
 . S RORFDA(798.1,IENS,19.2)=$G(CNT(REGIEN,1))
"RTN","RORUPD51",149,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUPD51",150,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD51",151,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,798.1,IENS)
"RTN","RORUPD51",152,0)
 Q
"RTN","RORUPDUT")
0^128^B46426812
"RTN","RORUPDUT",1,0)
RORUPDUT ;HCIOFO/SG - REGISTRY UPDATE UTILITIES  ; 7/21/03 10:23am
"RTN","RORUPDUT",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUPDUT",3,0)
 ;
"RTN","RORUPDUT",4,0)
 ; RORVALS ------------- CALCULATED VALUES
"RTN","RORUPDUT",5,0)
 ;
"RTN","RORUPDUT",6,0)
 ; RORVALS("DV",         VALUES OF THE DATA ELEMENTS
"RTN","RORUPDUT",7,0)
 ;   File#,DataCode,"E") External value
"RTN","RORUPDUT",8,0)
 ;   File#,DataCode,"I") Internal value
"RTN","RORUPDUT",9,0)
 ;
"RTN","RORUPDUT",10,0)
 ; RORVALS("LS",         LIST OF TRIGGERED LAB SEARCHES
"RTN","RORUPDUT",11,0)
 ;   LabSearch#)         Date/time of the observation
"RTN","RORUPDUT",12,0)
 ;
"RTN","RORUPDUT",13,0)
 ; RORVALS("SV",         VALUES OF THE SELECTION RULES
"RTN","RORUPDUT",14,0)
 ;   Rule Name,          Current value
"RTN","RORUPDUT",15,0)
 ;     "AVG")            Average value
"RTN","RORUPDUT",16,0)
 ;     "CNT")            Counter
"RTN","RORUPDUT",17,0)
 ;     "DTF")            Used by the {SDF} and {SDL} macros to store
"RTN","RORUPDUT",18,0)
 ;     "DTL")            the earliest and the latest trigger dates
"RTN","RORUPDUT",19,0)
 ;     "MAX")            Maximum value
"RTN","RORUPDUT",20,0)
 ;     "MIN")            Minimum value
"RTN","RORUPDUT",21,0)
 ;     "SUM")            Total value
"RTN","RORUPDUT",22,0)
 ;
"RTN","RORUPDUT",23,0)
 ; PREPDEFINED NAME ---- VALUE AND DESCRIPTION
"RTN","RORUPDUT",24,0)
 ;
"RTN","RORUPDUT",25,0)
 ; "ROR DFN"             IEN of the patient being processed
"RTN","RORUPDUT",26,0)
 ; "ROR SRDT"            Date when the current selection rule was
"RTN","RORUPDUT",27,0)
 ;                       triggered (it is set by APLRULES^RORUPDUT
"RTN","RORUPDUT",28,0)
 ;                       but could be changed by selection rules).
"RTN","RORUPDUT",29,0)
 ;                       The {GDF} and {GDL} macros modify this
"RTN","RORUPDUT",30,0)
 ;                       value as well.
"RTN","RORUPDUT",31,0)
 ;
"RTN","RORUPDUT",32,0)
 Q
"RTN","RORUPDUT",33,0)
 ;
"RTN","RORUPDUT",34,0)
 ;***** APPLIES SELECTION RULES TO THE RECORD
"RTN","RORUPDUT",35,0)
 ;
"RTN","RORUPDUT",36,0)
 ; FILE          File/Subfile number
"RTN","RORUPDUT",37,0)
 ; IENS          IENS of the current record
"RTN","RORUPDUT",38,0)
 ; MODE          "B" (process before subfiles) or
"RTN","RORUPDUT",39,0)
 ;               "A" (process after subfiles)
"RTN","RORUPDUT",40,0)
 ; [DATE]        Trigger date (TODAY by default)
"RTN","RORUPDUT",41,0)
 ;
"RTN","RORUPDUT",42,0)
 ; Return values:
"RTN","RORUPDUT",43,0)
 ;       <0  Error code
"RTN","RORUPDUT",44,0)
 ;        0  Continue processing of the current patient
"RTN","RORUPDUT",45,0)
 ;        1  Stop looping
"RTN","RORUPDUT",46,0)
 ;
"RTN","RORUPDUT",47,0)
APLRULES(FILE,IENS,MODE,DATE) ;
"RTN","RORUPDUT",48,0)
 N EXPR,HDR,LM,PATIEN,RC,REGIEN,RI,RULENAME,RULENODE
"RTN","RORUPDUT",49,0)
 S:'$G(DATE) DATE=$$DT^XLFDT
"RTN","RORUPDUT",50,0)
 ;--- Loop through the selection rules
"RTN","RORUPDUT",51,0)
 S RI="",RC=0
"RTN","RORUPDUT",52,0)
 F  S RI=$O(RORUPD("SR",FILE,MODE,RI))  Q:RI=""  D  Q:RC<0
"RTN","RORUPDUT",53,0)
 . S RULENODE=$NA(RORUPD("SR",FILE,MODE,RI))
"RTN","RORUPDUT",54,0)
 . S RORVALS("SV","ROR SRDT")=$P(DATE,".")
"RTN","RORUPDUT",55,0)
 . S HDR=$G(@RULENODE),RULENAME=$P(HDR,U)
"RTN","RORUPDUT",56,0)
 . ;--- If a top level rule does not exist in the control list, this
"RTN","RORUPDUT",57,0)
 . ;    rule has been already triggered for the patient. So, there is
"RTN","RORUPDUT",58,0)
 . ;    no need to check it again.
"RTN","RORUPDUT",59,0)
 . I $P(HDR,U,3)  Q:'$D(RORUPD("LM",1,RULENAME))
"RTN","RORUPDUT",60,0)
 . ;--- Compute the expression of the selection rule
"RTN","RORUPDUT",61,0)
 . X "S RC="_@RULENODE@(1)
"RTN","RORUPDUT",62,0)
 . I $P(HDR,U,3)  Q:'RC  D               ; TOP LEVEL RULE
"RTN","RORUPDUT",63,0)
 . . S PATIEN=$$GETVAL("ROR DFN"),REGIEN=""
"RTN","RORUPDUT",64,0)
 . . F  S REGIEN=$O(@RULENODE@(2,REGIEN))  Q:REGIEN=""  D
"RTN","RORUPDUT",65,0)
 . . . ;--- Check if the patient is already in the registry
"RTN","RORUPDUT",66,0)
 . . . Q:'$G(RORUPD("LM2",REGIEN))
"RTN","RORUPDUT",67,0)
 . . . ;--- Save rule name and date for the registry and new patient
"RTN","RORUPDUT",68,0)
 . . . S @RORUPDPI@("U",PATIEN,2,REGIEN,+$P(HDR,U,2))=RORVALS("SV","ROR SRDT")
"RTN","RORUPDUT",69,0)
 . . . ;--- Remove the registry from the control list
"RTN","RORUPDUT",70,0)
 . . . K RORUPD("LM",2,REGIEN)
"RTN","RORUPDUT",71,0)
 . . ;--- Remove the rule from the control list
"RTN","RORUPDUT",72,0)
 . . K RORUPD("LM",1,RULENAME)
"RTN","RORUPDUT",73,0)
 . E  D SETVAL(RULENAME,RC)              ; LOWER LEVEL RULE
"RTN","RORUPDUT",74,0)
 . S RC=0
"RTN","RORUPDUT",75,0)
 S LM=+$G(RORUPD("LM")) ; Loop mode
"RTN","RORUPDUT",76,0)
 ;--- If the loop mode equals 0, continue processing of the patient
"RTN","RORUPDUT",77,0)
 ;    in any case. Otherwise, stop processing if the corresponding
"RTN","RORUPDUT",78,0)
 ;    control list is empty.
"RTN","RORUPDUT",79,0)
 Q $S(RC<0:RC,LM:$D(RORUPD("LM",LM))<10,1:0)
"RTN","RORUPDUT",80,0)
 ;
"RTN","RORUPDUT",81,0)
 ;***** CLEARS DATA ELEMENT VALUES
"RTN","RORUPDUT",82,0)
 ;
"RTN","RORUPDUT",83,0)
 ; FILE          File/Subfile number
"RTN","RORUPDUT",84,0)
 ;
"RTN","RORUPDUT",85,0)
CLRDES(FILE) ;
"RTN","RORUPDUT",86,0)
 K RORVALS("DV",FILE)
"RTN","RORUPDUT",87,0)
 Q
"RTN","RORUPDUT",88,0)
 ;
"RTN","RORUPDUT",89,0)
 ;***** CLEARS VALUE OF THE ERROR COUNTER
"RTN","RORUPDUT",90,0)
CLREC ;
"RTN","RORUPDUT",91,0)
 K RORUPD("ERRCNT")
"RTN","RORUPDUT",92,0)
 Q
"RTN","RORUPDUT",93,0)
 ;
"RTN","RORUPDUT",94,0)
 ;***** CLEARS VALUES OF THE SELECTION RULES ASSOCIATED WITH THE FILE
"RTN","RORUPDUT",95,0)
 ;
"RTN","RORUPDUT",96,0)
 ; FILE          File/Subfile number
"RTN","RORUPDUT",97,0)
 ;
"RTN","RORUPDUT",98,0)
CLRVALS(FILE) ;
"RTN","RORUPDUT",99,0)
 N MODE,RI,RULENAME
"RTN","RORUPDUT",100,0)
 F MODE="B","A"  D
"RTN","RORUPDUT",101,0)
 . S RI=""
"RTN","RORUPDUT",102,0)
 . F  S RI=$O(RORUPD("SR",FILE,MODE,RI))  Q:RI=""  D
"RTN","RORUPDUT",103,0)
 . . S RULENAME=$P($G(RORUPD("SR",FILE,MODE,RI)),U)
"RTN","RORUPDUT",104,0)
 . . K:RULENAME'="" RORVALS("SV",RULENAME)
"RTN","RORUPDUT",105,0)
 Q
"RTN","RORUPDUT",106,0)
 ;
"RTN","RORUPDUT",107,0)
 ;***** RETURNS A CODE OF THE DATA ELEMENT
"RTN","RORUPDUT",108,0)
 ;
"RTN","RORUPDUT",109,0)
 ; FILE          File number
"RTN","RORUPDUT",110,0)
 ; NAME          Name of the data element
"RTN","RORUPDUT",111,0)
 ;
"RTN","RORUPDUT",112,0)
 ; Return values:
"RTN","RORUPDUT",113,0)
 ;       <0  Error code
"RTN","RORUPDUT",114,0)
 ;       >0  Code of the data element
"RTN","RORUPDUT",115,0)
 ;
"RTN","RORUPDUT",116,0)
DATACODE(FILE,NAME) ;
"RTN","RORUPDUT",117,0)
 N IENS,RC,RORBUF,RORMSG
"RTN","RORUPDUT",118,0)
 S IENS=","_FILE_","
"RTN","RORUPDUT",119,0)
 D FIND^DIC(799.22,IENS,"@;.02I","X",NAME,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPDUT",120,0)
 I $G(DIERR)  D  Q RC
"RTN","RORUPDUT",121,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,799.22,IENS)
"RTN","RORUPDUT",122,0)
 S RC=+$G(RORBUF("DILIST",0))
"RTN","RORUPDUT",123,0)
 Q:RC<1 $$ERROR^RORERR(-69,,NAME)
"RTN","RORUPDUT",124,0)
 Q:RC>1 $$ERROR^RORERR(-70,,NAME)
"RTN","RORUPDUT",125,0)
 Q +$G(RORBUF("DILIST","ID",1,.02))
"RTN","RORUPDUT",126,0)
 ;
"RTN","RORUPDUT",127,0)
 ;***** PRINTS SOME DEBUG INFORMATION
"RTN","RORUPDUT",128,0)
DEBUG ;
"RTN","RORUPDUT",129,0)
 N I
"RTN","RORUPDUT",130,0)
 D ZW^RORUTL01($NA(RORUPD("FLAGS")),"Control Flags")
"RTN","RORUPDUT",131,0)
 D ZW^RORUTL01($NA(RORUPD("SR")),"Selection Rules")
"RTN","RORUPDUT",132,0)
 D ZW^RORUTL01($NA(RORUPD("UPD")),"Call-back Entry Points")
"RTN","RORUPDUT",133,0)
 W !,"Control Lists",!!
"RTN","RORUPDUT",134,0)
 F I="LM1","LM2"  D ZW^RORUTL01($NA(RORUPD(I)))
"RTN","RORUPDUT",135,0)
 D ZW^RORUTL01("RORLRC","Lab Results to check")
"RTN","RORUPDUT",136,0)
 W !,"Job number: ",$J,!
"RTN","RORUPDUT",137,0)
 Q
"RTN","RORUPDUT",138,0)
 ;
"RTN","RORUPDUT",139,0)
 ;***** GETS A VALUE OF THE DATA ELEMENT
"RTN","RORUPDUT",140,0)
 ;
"RTN","RORUPDUT",141,0)
 ; FILE          File number
"RTN","RORUPDUT",142,0)
 ; DATELMT       Code of the data element
"RTN","RORUPDUT",143,0)
 ; [TYPE]        Type of the value
"RTN","RORUPDUT",144,0)
 ;                 "E"  External
"RTN","RORUPDUT",145,0)
 ;                 "I"  Internal (default)
"RTN","RORUPDUT",146,0)
 ;
"RTN","RORUPDUT",147,0)
GETDE(FILE,DATELMT,TYPE) ;
"RTN","RORUPDUT",148,0)
 Q $G(RORVALS("DV",FILE,DATELMT,$G(TYPE,"I")))
"RTN","RORUPDUT",149,0)
 ;
"RTN","RORUPDUT",150,0)
 ;***** RETURNS VALUE OF THE ERROR COUNTER
"RTN","RORUPDUT",151,0)
GETEC() ;
"RTN","RORUPDUT",152,0)
 Q +$G(RORUPD("ERRCNT"))
"RTN","RORUPDUT",153,0)
 ;
"RTN","RORUPDUT",154,0)
 ;***** GETS VALUE OF THE SELECTION RULE
"RTN","RORUPDUT",155,0)
 ;
"RTN","RORUPDUT",156,0)
 ; RULENAME      Name of the rule
"RTN","RORUPDUT",157,0)
 ; [PFX]         Prefix of the value
"RTN","RORUPDUT",158,0)
 ;                 ""     Value itself (default)
"RTN","RORUPDUT",159,0)
 ;                 "AVG"  Average value
"RTN","RORUPDUT",160,0)
 ;                 "CNT"  Counter
"RTN","RORUPDUT",161,0)
 ;                 "MAX"  Maximum value
"RTN","RORUPDUT",162,0)
 ;                 "MIN"  Minimum value
"RTN","RORUPDUT",163,0)
 ;                 "SUM"  Total sum
"RTN","RORUPDUT",164,0)
 ;
"RTN","RORUPDUT",165,0)
GETVAL(RULENAME,PFX) ;
"RTN","RORUPDUT",166,0)
 Q $S($G(PFX)="":$G(RORVALS("SV",RULENAME)),1:$G(RORVALS("SV",RULENAME,PFX)))
"RTN","RORUPDUT",167,0)
 ;
"RTN","RORUPDUT",168,0)
 ;***** RETURNS INACTIVATION DATE FOR A DECEASED PATIENT
"RTN","RORUPDUT",169,0)
 ;
"RTN","RORUPDUT",170,0)
 ; DOD           Date of death
"RTN","RORUPDUT",171,0)
 ;
"RTN","RORUPDUT",172,0)
INACTDOD(DOD) ;
"RTN","RORUPDUT",173,0)
 Q $S(DOD:$$FMADD^XLFDT(DOD,31),1:"")
"RTN","RORUPDUT",174,0)
 ;
"RTN","RORUPDUT",175,0)
 ;***** INCREMENTS VALUE OF THE ERROR COUNTER
"RTN","RORUPDUT",176,0)
 ;
"RTN","RORUPDUT",177,0)
 ; [RC]          Reference to a variable containing the error code
"RTN","RORUPDUT",178,0)
 ;
"RTN","RORUPDUT",179,0)
INCEC(RC) ;
"RTN","RORUPDUT",180,0)
 S:$G(RC,-1)<0 RORUPD("ERRCNT")=$G(RORUPD("ERRCNT"))+1,RC=0
"RTN","RORUPDUT",181,0)
 Q
"RTN","RORUPDUT",182,0)
 ;
"RTN","RORUPDUT",183,0)
 ;***** LOADS DATA ELEMENT VALUES FROM CORRESPONDING FIELDS
"RTN","RORUPDUT",184,0)
 ;
"RTN","RORUPDUT",185,0)
 ; FILE          File/Subfile number
"RTN","RORUPDUT",186,0)
 ; IENS          IENS of the current record
"RTN","RORUPDUT",187,0)
 ;
"RTN","RORUPDUT",188,0)
 ; Return values:
"RTN","RORUPDUT",189,0)
 ;       <0  Error code
"RTN","RORUPDUT",190,0)
 ;        0  Ok
"RTN","RORUPDUT",191,0)
 ;
"RTN","RORUPDUT",192,0)
LOADFLDS(FILE,IENS) ;
"RTN","RORUPDUT",193,0)
 N DE,FLD,RC,RORFDA,RORMSG,VT  K RORVALS("DV",FILE)
"RTN","RORUPDUT",194,0)
 S FLD=$G(RORUPD("SR",FILE,"F",1))  Q:FLD="" 0
"RTN","RORUPDUT",195,0)
 ;--- Load the field values
"RTN","RORUPDUT",196,0)
 D GETS^DIQ(FILE,IENS,FLD,"EIN","RORFDA","RORMSG")
"RTN","RORUPDUT",197,0)
 I $G(DIERR)  D  Q RC
"RTN","RORUPDUT",198,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,FILE,IENS)
"RTN","RORUPDUT",199,0)
 ;--- Copy the field values from the FDA
"RTN","RORUPDUT",200,0)
 S DE=""
"RTN","RORUPDUT",201,0)
 F  S DE=$O(RORUPD("SR",FILE,"F",1,DE))  Q:DE=""  D
"RTN","RORUPDUT",202,0)
 . S FLD=+$G(RORUPD("SR",FILE,"F",1,DE))  Q:'FLD
"RTN","RORUPDUT",203,0)
 . S VT=""
"RTN","RORUPDUT",204,0)
 . F  S VT=$O(RORUPD("SR",FILE,"F",1,DE,VT))  Q:VT=""  D
"RTN","RORUPDUT",205,0)
 . . S RORVALS("DV",FILE,DE,VT)=$G(RORFDA(FILE,IENS,FLD,VT))
"RTN","RORUPDUT",206,0)
 Q 0
"RTN","RORUPDUT",207,0)
 ;
"RTN","RORUPDUT",208,0)
 ;***** SETS THE EARLIEST DATE FOR THE RULE
"RTN","RORUPDUT",209,0)
 ;
"RTN","RORUPDUT",210,0)
 ; NAME          Name of the selection rule
"RTN","RORUPDUT",211,0)
 ; COND          Result value of the logical condition
"RTN","RORUPDUT",212,0)
 ;
"RTN","RORUPDUT",213,0)
 ; Return values:
"RTN","RORUPDUT",214,0)
 ;        0  COND equals to zero
"RTN","RORUPDUT",215,0)
 ;        1  COND is not zero
"RTN","RORUPDUT",216,0)
 ;
"RTN","RORUPDUT",217,0)
SDF(NAME,COND) ;
"RTN","RORUPDUT",218,0)
 Q:'$G(COND) 0
"RTN","RORUPDUT",219,0)
 N DATE
"RTN","RORUPDUT",220,0)
 S DATE=$G(RORVALS("SV","ROR SRDT"))
"RTN","RORUPDUT",221,0)
 D:DATE>0
"RTN","RORUPDUT",222,0)
 . I $G(RORVALS("SV",NAME,"DTF"))'>0  D  Q
"RTN","RORUPDUT",223,0)
 . . S RORVALS("SV",NAME,"DTF")=DATE
"RTN","RORUPDUT",224,0)
 . S:DATE<RORVALS("SV",NAME,"DTF") RORVALS("SV",NAME,"DTF")=DATE
"RTN","RORUPDUT",225,0)
 Q 1
"RTN","RORUPDUT",226,0)
 ;
"RTN","RORUPDUT",227,0)
 ;***** SETS THE LATEST DATE FOR THE RULE
"RTN","RORUPDUT",228,0)
 ;
"RTN","RORUPDUT",229,0)
 ; NAME          Name of the selection rule
"RTN","RORUPDUT",230,0)
 ; COND          Result value of the logical condition
"RTN","RORUPDUT",231,0)
 ;
"RTN","RORUPDUT",232,0)
 ; Return values:
"RTN","RORUPDUT",233,0)
 ;        0  COND equals to zero
"RTN","RORUPDUT",234,0)
 ;        1  COND is not zero
"RTN","RORUPDUT",235,0)
 ;
"RTN","RORUPDUT",236,0)
SDL(NAME,COND) ;
"RTN","RORUPDUT",237,0)
 Q:'$G(COND) 0
"RTN","RORUPDUT",238,0)
 N DATE
"RTN","RORUPDUT",239,0)
 S DATE=$G(RORVALS("SV","ROR SRDT"))
"RTN","RORUPDUT",240,0)
 D:DATE>0
"RTN","RORUPDUT",241,0)
 . S:DATE>$G(RORVALS("SV",NAME,"DTL")) RORVALS("SV",NAME,"DTL")=DATE
"RTN","RORUPDUT",242,0)
 Q 1
"RTN","RORUPDUT",243,0)
 ;
"RTN","RORUPDUT",244,0)
 ;***** SETS VALUE OF THE SELECTION RULE
"RTN","RORUPDUT",245,0)
 ;
"RTN","RORUPDUT",246,0)
 ; RULENAME      Name of the rule
"RTN","RORUPDUT",247,0)
 ; VALUE         New value
"RTN","RORUPDUT",248,0)
 ;
"RTN","RORUPDUT",249,0)
SETVAL(RULENAME,VALUE) ;
"RTN","RORUPDUT",250,0)
 S RORVALS("SV",RULENAME)=VALUE
"RTN","RORUPDUT",251,0)
 S RORVALS("SV",RULENAME,"CNT")=$G(RORVALS("SV",RULENAME,"CNT"))+1
"RTN","RORUPDUT",252,0)
 S RORVALS("SV",RULENAME,"SUM")=$G(RORVALS("SV",RULENAME,"SUM"))+VALUE
"RTN","RORUPDUT",253,0)
 S RORVALS("SV",RULENAME,"AVG")=RORVALS("SV",RULENAME,"SUM")/RORVALS("SV",RULENAME,"CNT")
"RTN","RORUPDUT",254,0)
 ;
"RTN","RORUPDUT",255,0)
 I $G(RORVALS("SV",RULENAME,"MIN"))=""  S RORVALS("SV",RULENAME,"MIN")=VALUE
"RTN","RORUPDUT",256,0)
 E   S:VALUE<RORVALS("SV",RULENAME,"MIN") RORVALS("SV",RULENAME,"MIN")=VALUE
"RTN","RORUPDUT",257,0)
 ;
"RTN","RORUPDUT",258,0)
 I $G(RORVALS("SV",RULENAME,"MAX"))=""  S RORVALS("SV",RULENAME,"MAX")=VALUE
"RTN","RORUPDUT",259,0)
 E   S:VALUE>RORVALS("SV",RULENAME,"MAX") RORVALS("SV",RULENAME,"MAX")=VALUE
"RTN","RORUPDUT",260,0)
 Q
"RTN","RORUPDUT",261,0)
 ;
"RTN","RORUPDUT",262,0)
 ;***** GETS THE TRIGGER DATE OF THE RULE
"RTN","RORUPDUT",263,0)
 ;
"RTN","RORUPDUT",264,0)
 ; NAME          Name of the selection rule
"RTN","RORUPDUT",265,0)
 ; PFX           Prefix of the value ("GDF" or "GDL")
"RTN","RORUPDUT",266,0)
 ; COND          Result value of the logical condition
"RTN","RORUPDUT",267,0)
 ;
"RTN","RORUPDUT",268,0)
 ; Return values:
"RTN","RORUPDUT",269,0)
 ;        0  COND equals to zero
"RTN","RORUPDUT",270,0)
 ;        1  COND is not zero
"RTN","RORUPDUT",271,0)
 ;
"RTN","RORUPDUT",272,0)
SRDT(NAME,PFX,COND) ;
"RTN","RORUPDUT",273,0)
 Q:'$G(COND) 0
"RTN","RORUPDUT",274,0)
 N DATE
"RTN","RORUPDUT",275,0)
 S DATE=$G(RORVALS("SV",NAME,$S(PFX="GDL":"DTL",1:"DTF")))
"RTN","RORUPDUT",276,0)
 I DATE  S:DATE<$G(RORVALS("SV","ROR SRDT")) RORVALS("SV","ROR SRDT")=DATE
"RTN","RORUPDUT",277,0)
 Q 1
"RTN","RORUPEX")
0^129^B14367646
"RTN","RORUPEX",1,0)
RORUPEX ;HCIOFO/SG - SELECTION RULE EXPRESSION PARSER  ; 7/21/03 9:47am
"RTN","RORUPEX",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUPEX",3,0)
 ;
"RTN","RORUPEX",4,0)
 Q
"RTN","RORUPEX",5,0)
 ;
"RTN","RORUPEX",6,0)
 ;***** GETS THE NEXT CHARACTER FROM THE EXPRESSION
"RTN","RORUPEX",7,0)
GETCHAR ;
"RTN","RORUPEX",8,0)
 S LOOK=$E(EXPR,EPTR),EPTR=EPTR+1
"RTN","RORUPEX",9,0)
 Q
"RTN","RORUPEX",10,0)
 ;
"RTN","RORUPEX",11,0)
 ;***** TRANSLATES FIELD OR RULE MACRO TO MUMPS CODE
"RTN","RORUPEX",12,0)
 ;
"RTN","RORUPEX",13,0)
 ; The function returns a string containing MUMPS expression
"RTN","RORUPEX",14,0)
 ; that implements the selection rule macro.
"RTN","RORUPEX",15,0)
 ;
"RTN","RORUPEX",16,0)
GETMACRO() ;
"RTN","RORUPEX",17,0)
 ;;AVG,CNT,E,GDF,GDL,I,LS,MAX,MIN,SDF,SDL,SUM
"RTN","RORUPEX",18,0)
 ;
"RTN","RORUPEX",19,0)
 Q:'$$MATCH("{") ""
"RTN","RORUPEX",20,0)
 N BI,BUF,DATELMT,NAME,PFX,PFXLST,RC,RORMSG,SFX,TMP,XCODE
"RTN","RORUPEX",21,0)
 S PFXLST=","_$P($T(GETMACRO+1),";;",2)_","
"RTN","RORUPEX",22,0)
 S BI=1,RC=0
"RTN","RORUPEX",23,0)
 F  D  Q:RC
"RTN","RORUPEX",24,0)
 . I LOOK="}"  D GETCHAR  S RC=1  Q
"RTN","RORUPEX",25,0)
 . I LOOK=":"  D GETCHAR  S BI=BI+1  Q
"RTN","RORUPEX",26,0)
 . I LOOK="{"  D  Q
"RTN","RORUPEX",27,0)
 . . I BI<3  D SNTXERR("GETMACRO^RORUPEX")  S RC=1  Q
"RTN","RORUPEX",28,0)
 . . S BUF(BI)=$G(BUF(BI))_$$GETMACRO()
"RTN","RORUPEX",29,0)
 . S BUF(BI)=$G(BUF(BI))_LOOK
"RTN","RORUPEX",30,0)
 . D GETCHAR
"RTN","RORUPEX",31,0)
 Q:ERRCODE<0 ""
"RTN","RORUPEX",32,0)
 ;--- Get the parts of the macro
"RTN","RORUPEX",33,0)
 S BI=1,(NAME,PFX,SFX)=""
"RTN","RORUPEX",34,0)
 S TMP=$$UP^XLFSTR($$TRIM^XLFSTR($G(BUF(BI))))
"RTN","RORUPEX",35,0)
 S:PFXLST[(","_TMP_",") PFX=TMP,BI=BI+1
"RTN","RORUPEX",36,0)
 S NAME=$$TRIM^XLFSTR($G(BUF(BI))),BI=BI+1
"RTN","RORUPEX",37,0)
 S SFX=$$TRIM^XLFSTR($G(BUF(BI))),BI=BI+1
"RTN","RORUPEX",38,0)
 ;--- Data element value
"RTN","RORUPEX",39,0)
 I (PFX="E")!(PFX="I")  S XCODE=""  D  Q XCODE
"RTN","RORUPEX",40,0)
 . S DATELMT=$S(+NAME=NAME:+NAME,1:$$DATACODE^RORUPDUT(FILE,NAME))
"RTN","RORUPEX",41,0)
 . I DATELMT<0  S ERRCODE=DATELMT  Q
"RTN","RORUPEX",42,0)
 . S XCODE="$G(RORVALS(""DV"","_FILE_","_DATELMT_","""_PFX_"""))"
"RTN","RORUPEX",43,0)
 . S RESULT("F",DATELMT,PFX)=""
"RTN","RORUPEX",44,0)
 ;--- Lab Search (replace a name of the Lab Search with the IEN)
"RTN","RORUPEX",45,0)
 I PFX="LS"  D  Q "$$RULE^RORUPD04("_TMP_")"
"RTN","RORUPEX",46,0)
 . I FILE'=63  D SNTXERR("GETMACRO^RORUPEX")  S TMP=""  Q
"RTN","RORUPEX",47,0)
 . S TMP="I '$P(^(0),U,2)" ; Only Active
"RTN","RORUPEX",48,0)
 . S TMP=+$$FIND1^DIC(798.9,"","X",NAME,"B",TMP,"RORMSG")
"RTN","RORUPEX",49,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.9)
"RTN","RORUPEX",50,0)
 . S:RC<0 ERRCODE=RC,TMP=0
"RTN","RORUPEX",51,0)
 . S:TMP RESULT("L",TMP)=""
"RTN","RORUPEX",52,0)
 ;--- Trigger date macros (set)
"RTN","RORUPEX",53,0)
 I PFX="SDF"  Q "$$SDF^RORUPDUT("""_NAME_""","_SFX_")"
"RTN","RORUPEX",54,0)
 I PFX="SDL"  Q "$$SDL^RORUPDUT("""_NAME_""","_SFX_")"
"RTN","RORUPEX",55,0)
 ;--- Macros processed after this point cannot reference
"RTN","RORUPEX",56,0)
 ;    the rule that they are part of the expression of
"RTN","RORUPEX",57,0)
 S RESULT("R",NAME)=""
"RTN","RORUPEX",58,0)
 ;--- Trigger date macros (get)
"RTN","RORUPEX",59,0)
 I (PFX="GDF")!(PFX="GDL")  D  Q XCODE
"RTN","RORUPEX",60,0)
 . S XCODE="$$SRDT^RORUPDUT("""_NAME_""","""_PFX_""","_SFX_")"
"RTN","RORUPEX",61,0)
 ;--- Value of the selection rule
"RTN","RORUPEX",62,0)
 Q:PFX="" "$G(RORVALS(""SV"","""_NAME_"""))"
"RTN","RORUPEX",63,0)
 Q "$G(RORVALS(""SV"","""_NAME_""","""_PFX_"""))"
"RTN","RORUPEX",64,0)
 ;
"RTN","RORUPEX",65,0)
 ;***** GETS A STRING CONSTANT FROM THE EXPRESSION
"RTN","RORUPEX",66,0)
 ;
"RTN","RORUPEX",67,0)
 ; The function returns a string argument from the expression.
"RTN","RORUPEX",68,0)
 ;
"RTN","RORUPEX",69,0)
GETSTR() ;
"RTN","RORUPEX",70,0)
 Q:'$$MATCH("""") ""
"RTN","RORUPEX",71,0)
 N RC,STR
"RTN","RORUPEX",72,0)
 S STR="",RC=0
"RTN","RORUPEX",73,0)
 F  D  Q:RC
"RTN","RORUPEX",74,0)
 . I LOOK=""""  D  Q:RC
"RTN","RORUPEX",75,0)
 . . D GETCHAR
"RTN","RORUPEX",76,0)
 . . I LOOK'=""""  S RC=1  Q
"RTN","RORUPEX",77,0)
 . . S STR=STR_""""
"RTN","RORUPEX",78,0)
 . S STR=STR_LOOK
"RTN","RORUPEX",79,0)
 . D GETCHAR
"RTN","RORUPEX",80,0)
 Q STR
"RTN","RORUPEX",81,0)
 ;
"RTN","RORUPEX",82,0)
 ;***** INITIALIZES PARSING PROCESS
"RTN","RORUPEX",83,0)
INIT ;
"RTN","RORUPEX",84,0)
 S EPTR=1,ERRCODE=0,RESULT=""
"RTN","RORUPEX",85,0)
 D GETCHAR,SKIPWHT
"RTN","RORUPEX",86,0)
 Q
"RTN","RORUPEX",87,0)
 ;
"RTN","RORUPEX",88,0)
 ;***** COMPARES LOOK-AHEAD CHARACTER TO THE ARGUMENT
"RTN","RORUPEX",89,0)
MATCH(CH) ;
"RTN","RORUPEX",90,0)
 I LOOK=CH  D GETCHAR  Q 1
"RTN","RORUPEX",91,0)
 D SNTXERR("MATCH^RORUPEX")
"RTN","RORUPEX",92,0)
 Q 0
"RTN","RORUPEX",93,0)
 ;
"RTN","RORUPEX",94,0)
 ;***** PARSES THE EXPRESSION
"RTN","RORUPEX",95,0)
 ;
"RTN","RORUPEX",96,0)
 ; FILE          File number
"RTN","RORUPEX",97,0)
 ; EXPR          Source expression
"RTN","RORUPEX",98,0)
 ; .RESULT(      Resulting MUMPS code
"RTN","RORUPEX",99,0)
 ;   "F",        List of data elements to load
"RTN","RORUPEX",100,0)
 ;     DataCode)
"RTN","RORUPEX",101,0)
 ;   "L",LS#)    List of Lab Search IENs
"RTN","RORUPEX",102,0)
 ;   "R",Rule#)  List of rules that this expression depend on
"RTN","RORUPEX",103,0)
 ;
"RTN","RORUPEX",104,0)
 ; Return values:
"RTN","RORUPEX",105,0)
 ;       <0  Error code
"RTN","RORUPEX",106,0)
 ;        0  Ok
"RTN","RORUPEX",107,0)
 ;
"RTN","RORUPEX",108,0)
PARSER(FILE,EXPR,RESULT) ;
"RTN","RORUPEX",109,0)
 N EPTR          ; Current position in the expression
"RTN","RORUPEX",110,0)
 N ERRCODE       ; Error code
"RTN","RORUPEX",111,0)
 N LOOK          ; Look-ahead character
"RTN","RORUPEX",112,0)
 ;
"RTN","RORUPEX",113,0)
 ;--- Check if the file exists and supported
"RTN","RORUPEX",114,0)
 Q:'$$VFILE^DILFD(FILE) $$ERROR^RORERR(-58,"PARSER^RORUPEX",,,FILE)
"RTN","RORUPEX",115,0)
 Q:'$D(^ROR(799.2,FILE)) $$ERROR^RORERR(-63,"PARSER^RORUPEX",,,FILE)
"RTN","RORUPEX",116,0)
 ;--- Parse the expression
"RTN","RORUPEX",117,0)
 D INIT
"RTN","RORUPEX",118,0)
 F  Q:LOOK=""  D  Q:ERRCODE<0
"RTN","RORUPEX",119,0)
 . I LOOK=""""  D  Q
"RTN","RORUPEX",120,0)
 . . S RESULT=RESULT_""""_$$GETSTR()_""""
"RTN","RORUPEX",121,0)
 . I LOOK="{"  D  Q
"RTN","RORUPEX",122,0)
 . . S RESULT=RESULT_$$GETMACRO()
"RTN","RORUPEX",123,0)
 . S RESULT=RESULT_LOOK
"RTN","RORUPEX",124,0)
 . D GETCHAR
"RTN","RORUPEX",125,0)
 ;
"RTN","RORUPEX",126,0)
 Q $S(ERRCODE<0:ERRCODE,1:0)
"RTN","RORUPEX",127,0)
 ;
"RTN","RORUPEX",128,0)
 ;***** PROCESSES A SYNTAX ERROR
"RTN","RORUPEX",129,0)
SNTXERR(PLACE,MSG) ;
"RTN","RORUPEX",130,0)
 N I,INFO  S I=0
"RTN","RORUPEX",131,0)
 S:$G(MSG)'="" I=I+1,INFO(I)=MSG
"RTN","RORUPEX",132,0)
 S I=I+1,INFO(I)="Position: "_EPTR
"RTN","RORUPEX",133,0)
 S:LOOK'="" INFO(I)=INFO(I)_", Character: '"_LOOK_"'"
"RTN","RORUPEX",134,0)
 S ERRCODE=$$ERROR^RORERR(-21,$G(PLACE),.INFO)
"RTN","RORUPEX",135,0)
 Q
"RTN","RORUPEX",136,0)
 ;
"RTN","RORUPEX",137,0)
 ;***** SKIPS WHITE SPACES IN THE EXPRESSION
"RTN","RORUPEX",138,0)
SKIPWHT ;
"RTN","RORUPEX",139,0)
 F  Q:(" "'[LOOK)!(LOOK="")  D GETCHAR
"RTN","RORUPEX",140,0)
 Q
"RTN","RORUPP01")
0^130^B14228263
"RTN","RORUPP01",1,0)
RORUPP01 ;HCIOFO/SG - PENDING PATIENTS (ERRORS)  ; 7/21/03 9:48am
"RTN","RORUPP01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUPP01",3,0)
 ;
"RTN","RORUPP01",4,0)
 ; RORUPD("LM2",         Static list of registries must be defined
"RTN","RORUPP01",5,0)
 ;   Registry#)          if you are going to use these functions.
"RTN","RORUPP01",6,0)
 ;
"RTN","RORUPP01",7,0)
 ; RORUPD("MAXPPCNT")    This node should have a positive value if
"RTN","RORUPP01",8,0)
 ;                       you are going to use these functions.
"RTN","RORUPP01",9,0)
 ;                       Otherwise, 14 will be used by default.
"RTN","RORUPP01",10,0)
 ;
"RTN","RORUPP01",11,0)
 ; See source code of the ^RORUPD routine for detailed description
"RTN","RORUPP01",12,0)
 ; of these nodes.
"RTN","RORUPP01",13,0)
 ;
"RTN","RORUPP01",14,0)
 Q
"RTN","RORUPP01",15,0)
 ;
"RTN","RORUPP01",16,0)
 ;***** ADDS THE REFERENCES TO THE LIST
"RTN","RORUPP01",17,0)
 ;
"RTN","RORUPP01",18,0)
 ; PATIEN        Patient IEN
"RTN","RORUPP01",19,0)
 ; DATE          Date to start next registry update
"RTN","RORUPP01",20,0)
 ;
"RTN","RORUPP01",21,0)
 ; Return Values:
"RTN","RORUPP01",22,0)
 ;       <0  Error code
"RTN","RORUPP01",23,0)
 ;        0  Ok
"RTN","RORUPP01",24,0)
 ;
"RTN","RORUPP01",25,0)
ADD(PATIEN,DATE) ;
"RTN","RORUPP01",26,0)
 N I,IENS,MAXCNT,RC,REGIEN,RORBUF,RORFDA,RORIEN,RORMSG,TMP,URLST
"RTN","RORUPP01",27,0)
 S MAXCNT=$$MAXCNT()
"RTN","RORUPP01",28,0)
 I $D(^RORDATA(798.3,PATIEN,1,"B"))>1  S RC=0  D  Q:RC<0 RC
"RTN","RORUPP01",29,0)
 . ;--- Get a list of existing patient error records
"RTN","RORUPP01",30,0)
 . S IENS=","_PATIEN_",",I="I $D(RORUPD(""LM2"",+$P(^(0),U)))"
"RTN","RORUPP01",31,0)
 . D LIST^DIC(798.31,IENS,"@;.01I;1I;2",,,,,"B",I,,"RORBUF","RORMSG")
"RTN","RORUPP01",32,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPP01",33,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,798.31,IENS)
"RTN","RORUPP01",34,0)
 . Q:'$G(RORBUF("DILIST",0))
"RTN","RORUPP01",35,0)
 . ;--- Prepare FDA for records to update
"RTN","RORUPP01",36,0)
 . S I=""
"RTN","RORUPP01",37,0)
 . F  S I=$O(RORBUF("DILIST",2,I))  Q:I=""  D
"RTN","RORUPP01",38,0)
 . . S REGIEN=+$G(RORBUF("DILIST","ID",I,.01))
"RTN","RORUPP01",39,0)
 . . S URLST(REGIEN)=""
"RTN","RORUPP01",40,0)
 . . Q:$G(RORBUF("DILIST","ID",I,2))'<MAXCNT
"RTN","RORUPP01",41,0)
 . . S IENS=RORBUF("DILIST",2,I)_","_PATIEN_","
"RTN","RORUPP01",42,0)
 . . S TMP=$G(RORBUF("DILIST","ID",I,1))
"RTN","RORUPP01",43,0)
 . . S RORFDA(798.31,IENS,1)=$S(TMP&(TMP<DATE):TMP,1:DATE)
"RTN","RORUPP01",44,0)
 . . S RORFDA(798.31,IENS,2)=$G(RORBUF("DILIST","ID",I,2))+1
"RTN","RORUPP01",45,0)
 . Q:$D(RORFDA)<10
"RTN","RORUPP01",46,0)
 . ;--- Update the records
"RTN","RORUPP01",47,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUPP01",48,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,798.31)
"RTN","RORUPP01",49,0)
 ;--- Prepare FDA for records to create
"RTN","RORUPP01",50,0)
 S REGIEN="",I=1
"RTN","RORUPP01",51,0)
 F  S REGIEN=$O(RORUPD("LM2",REGIEN))  Q:REGIEN=""  D
"RTN","RORUPP01",52,0)
 . Q:$D(URLST(REGIEN))
"RTN","RORUPP01",53,0)
 . S I=I+1,IENS="+"_I_",?+1,"
"RTN","RORUPP01",54,0)
 . S RORFDA(798.31,IENS,.01)=REGIEN
"RTN","RORUPP01",55,0)
 . S RORFDA(798.31,IENS,1)=DATE
"RTN","RORUPP01",56,0)
 . S RORFDA(798.31,IENS,2)=1
"RTN","RORUPP01",57,0)
 ;--- Create the records
"RTN","RORUPP01",58,0)
 I $D(RORFDA)>1  S RC=0  D  Q:RC<0 RC
"RTN","RORUPP01",59,0)
 . S (RORFDA(798.3,"?+1,",.01),RORIEN(1))=PATIEN
"RTN","RORUPP01",60,0)
 . D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORUPP01",61,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,798.31)
"RTN","RORUPP01",62,0)
 Q 0
"RTN","RORUPP01",63,0)
 ;
"RTN","RORUPP01",64,0)
 ;***** RETURNS THE THRESHOLD VALUE OF THE ERROR COUNTER
"RTN","RORUPP01",65,0)
MAXCNT() ;
"RTN","RORUPP01",66,0)
 Q $S($G(RORUPD("MAXPPCNT"))>0:+RORUPD("MAXPPCNT"),1:14)
"RTN","RORUPP01",67,0)
 ;
"RTN","RORUPP01",68,0)
 ;***** REMOVES THE REFERNCES FROM THE LIST
"RTN","RORUPP01",69,0)
 ;
"RTN","RORUPP01",70,0)
 ; PATIEN        Patient IEN
"RTN","RORUPP01",71,0)
 ; [ROR8LST]     Closed root of an array containg list of registry
"RTN","RORUPP01",72,0)
 ;               IENs as subscripts. $NA(RORUPD("LM2")) is used
"RTN","RORUPP01",73,0)
 ;               by default. Only records associated with these
"RTN","RORUPP01",74,0)
 ;               registries will be removed.
"RTN","RORUPP01",75,0)
 ;
"RTN","RORUPP01",76,0)
 ; Return Values:
"RTN","RORUPP01",77,0)
 ;       <0  Error code
"RTN","RORUPP01",78,0)
 ;        0  Ok
"RTN","RORUPP01",79,0)
 ;
"RTN","RORUPP01",80,0)
REMOVE(PATIEN,ROR8LST) ;
"RTN","RORUPP01",81,0)
 Q:$D(^RORDATA(798.3,PATIEN,1,"B"))<10 0
"RTN","RORUPP01",82,0)
 N I,IENS,RC,RORBUF,RORFDA,RORMSG
"RTN","RORUPP01",83,0)
 S:$G(ROR8LST)="" ROR8LST=$NA(RORUPD("LM2"))
"RTN","RORUPP01",84,0)
 S IENS=","_PATIEN_",",I="I $D(@ROR8LST@(+$P(^(0),U)))"
"RTN","RORUPP01",85,0)
 D LIST^DIC(798.31,IENS,"@",,,,,"B",I,,"RORBUF","RORMSG")
"RTN","RORUPP01",86,0)
 I $G(DIERR)  D  Q RC
"RTN","RORUPP01",87,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.31,IENS)
"RTN","RORUPP01",88,0)
 Q:'$G(RORBUF("DILIST",0)) 0
"RTN","RORUPP01",89,0)
 S I=""
"RTN","RORUPP01",90,0)
 F  S I=$O(RORBUF("DILIST",2,I))  Q:I=""  D
"RTN","RORUPP01",91,0)
 . S IENS=RORBUF("DILIST",2,I)_","_PATIEN_","
"RTN","RORUPP01",92,0)
 . S RORFDA(798.31,IENS,.01)="@"
"RTN","RORUPP01",93,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUPP01",94,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.31)
"RTN","RORUPP01",95,0)
 Q 0
"RTN","RORUPP01",96,0)
 ;
"RTN","RORUPP01",97,0)
 ;***** RETURNS START DATE FOR THE DATA SCAN (IF ANY)
"RTN","RORUPP01",98,0)
 ;
"RTN","RORUPP01",99,0)
 ; PATIEN        Patient IEN
"RTN","RORUPP01",100,0)
 ;
"RTN","RORUPP01",101,0)
 ; Return Values:
"RTN","RORUPP01",102,0)
 ;       <0  Error code
"RTN","RORUPP01",103,0)
 ;       ""  There is no date for the patient in the file
"RTN","RORUPP01",104,0)
 ;       >0  Start date
"RTN","RORUPP01",105,0)
 ;
"RTN","RORUPP01",106,0)
SDSDATE(PATIEN) ;
"RTN","RORUPP01",107,0)
 Q:$D(^RORDATA(798.3,PATIEN,1,"B"))<10 ""
"RTN","RORUPP01",108,0)
 N CNT,DATE,I,IENS,MAXCNT,RC,RORBUF,RORMSG,TMP
"RTN","RORUPP01",109,0)
 ;--- Load the pending references (in chronological order)
"RTN","RORUPP01",110,0)
 S IENS=","_PATIEN_",",I="I $D(RORUPD(""LM2"",+$P(^(0),U)))"
"RTN","RORUPP01",111,0)
 D LIST^DIC(798.31,IENS,"@;1I;2",,,,,"AD",I,,"RORBUF","RORMSG")
"RTN","RORUPP01",112,0)
 I $G(DIERR)  D  Q RC
"RTN","RORUPP01",113,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798.31,IENS)
"RTN","RORUPP01",114,0)
 Q:'$G(RORBUF("DILIST",0)) ""
"RTN","RORUPP01",115,0)
 ;--- Get and return the earliest date
"RTN","RORUPP01",116,0)
 S MAXCNT=$$MAXCNT()
"RTN","RORUPP01",117,0)
 S (DATE,I)="",CNT=0
"RTN","RORUPP01",118,0)
 F  S I=$O(RORBUF("DILIST","ID",I))  Q:I=""  D  Q:CNT&DATE
"RTN","RORUPP01",119,0)
 . S:$G(RORBUF("DILIST","ID",I,2))<MAXCNT CNT=CNT+1
"RTN","RORUPP01",120,0)
 . S:'DATE DATE=$G(RORBUF("DILIST","ID",I,1))
"RTN","RORUPP01",121,0)
 Q $S('CNT:$$ERROR^RORERR(-66,,,PATIEN),1:DATE)
"RTN","RORUPP02")
0^24^B13632896
"RTN","RORUPP02",1,0)
RORUPP02 ;HCIOFO/SG - PENDING PATIENTS (EVENTS)  ; 1/5/04 12:36pm
"RTN","RORUPP02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORUPP02",3,0)
 ;
"RTN","RORUPP02",4,0)
 Q
"RTN","RORUPP02",5,0)
 ;
"RTN","RORUPP02",6,0)
 ;***** ADDS THE EVENT REFERENCE
"RTN","RORUPP02",7,0)
 ;
"RTN","RORUPP02",8,0)
 ; PATIEN        Patient IEN
"RTN","RORUPP02",9,0)
 ;
"RTN","RORUPP02",10,0)
 ; AREA          Data area of the event (see the DATA AREA field
"RTN","RORUPP02",11,0)
 ;               of the file #798.3 for details)
"RTN","RORUPP02",12,0)
 ;
"RTN","RORUPP02",13,0)
 ; [DATE]        Date/Time associated with the event (the current
"RTN","RORUPP02",14,0)
 ;               date/time is used by default).
"RTN","RORUPP02",15,0)
 ;
"RTN","RORUPP02",16,0)
 ; Return Values:
"RTN","RORUPP02",17,0)
 ;       <0  Error code
"RTN","RORUPP02",18,0)
 ;        0  Ok
"RTN","RORUPP02",19,0)
 ;
"RTN","RORUPP02",20,0)
ADD(PATIEN,AREA,DATE) ;
"RTN","RORUPP02",21,0)
 N IEN,IENS,RORFDA,RORIEN,RORMSG
"RTN","RORUPP02",22,0)
 S:$G(DATE)'>0 DATE=$$NOW^XLFDT
"RTN","RORUPP02",23,0)
 ;--- Do not record more than one reference per associated date.
"RTN","RORUPP02",24,0)
 ;    Maybe in the future all references will be recorded but we
"RTN","RORUPP02",25,0)
 ;    need only daily precision at the moment. If the reference
"RTN","RORUPP02",26,0)
 ;    exists already, update it with the earlier associated date
"RTN","RORUPP02",27,0)
 ;--- and the latter timestamp if necessary.
"RTN","RORUPP02",28,0)
 S IEN=$O(^RORDATA(798.3,+PATIEN,2,"AD",AREA,DATE\1,""))
"RTN","RORUPP02",29,0)
 I IEN  K DIERR  D  Q $S('$G(DIERR):0,1:-9)
"RTN","RORUPP02",30,0)
 . N BUF,NOW
"RTN","RORUPP02",31,0)
 . S IENS=IEN_","_(+PATIEN)_",",NOW=$$NOW^XLFDT
"RTN","RORUPP02",32,0)
 . S BUF=$G(^RORDATA(798.3,+PATIEN,2,IEN,0))
"RTN","RORUPP02",33,0)
 . S:NOW>$P(BUF,"^") RORFDA(798.32,IENS,.01)=NOW
"RTN","RORUPP02",34,0)
 . S:DATE<$P(BUF,"^",3) RORFDA(798.32,IENS,2)=DATE
"RTN","RORUPP02",35,0)
 . D:$D(RORFDA)>1 FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUPP02",36,0)
 ;--- Create the new event reference
"RTN","RORUPP02",37,0)
 S (RORFDA(798.3,"?+1,",.01),RORIEN(1))=+PATIEN
"RTN","RORUPP02",38,0)
 S IENS="+2,?+1,"
"RTN","RORUPP02",39,0)
 S RORFDA(798.32,IENS,.01)=$$NOW^XLFDT
"RTN","RORUPP02",40,0)
 S RORFDA(798.32,IENS,1)=AREA
"RTN","RORUPP02",41,0)
 S RORFDA(798.32,IENS,2)=DATE
"RTN","RORUPP02",42,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORUPP02",43,0)
 Q $S('$G(DIERR):0,1:-9)
"RTN","RORUPP02",44,0)
 ;
"RTN","RORUPP02",45,0)
 ;***** CHECKS THE EVENTS
"RTN","RORUPP02",46,0)
 ;
"RTN","RORUPP02",47,0)
 ; PATIEN        Patient IEN
"RTN","RORUPP02",48,0)
 ;
"RTN","RORUPP02",49,0)
 ; AREA          Data area of the event (see the DATA AREA field
"RTN","RORUPP02",50,0)
 ;               of the file #798.3 for details)
"RTN","RORUPP02",51,0)
 ;
"RTN","RORUPP02",52,0)
 ; .SDT          Reference to a local variable containing the start
"RTN","RORUPP02",53,0)
 ;               date. The date can be modified by the function and
"RTN","RORUPP02",54,0)
 ;               returned via this parameter.
"RTN","RORUPP02",55,0)
 ;
"RTN","RORUPP02",56,0)
 ; .EDT          Reference to a local variable containing the end
"RTN","RORUPP02",57,0)
 ;               date. The date can be modified by the function and
"RTN","RORUPP02",58,0)
 ;               returned via this parameter.
"RTN","RORUPP02",59,0)
 ;
"RTN","RORUPP02",60,0)
 ; Return Values:
"RTN","RORUPP02",61,0)
 ;       <0  Error code
"RTN","RORUPP02",62,0)
 ;        0  No events (skip)
"RTN","RORUPP02",63,0)
 ;        1  Events have been found (proceed)
"RTN","RORUPP02",64,0)
 ;        2  The same as 1 + dates (SDT & EDT) have been modified
"RTN","RORUPP02",65,0)
 ;
"RTN","RORUPP02",66,0)
GET(PATIEN,AREA,SDT,EDT) ;
"RTN","RORUPP02",67,0)
 N ED,FDTC,FEVT,IEN,NEWEDT,NEWSDT,ROOT,TMP
"RTN","RORUPP02",68,0)
 S ROOT=$NA(^RORDATA(798.3,+PATIEN,2))
"RTN","RORUPP02",69,0)
 S NEWSDT=999999999,NEWEDT=0,(FDTC,FEVT)=0
"RTN","RORUPP02",70,0)
 ;--- If the data search time frame is too wide and some of the
"RTN","RORUPP02",71,0)
 ;    event references have been purged already then the time
"RTN","RORUPP02",72,0)
 ;    frame cannot be shrinked according to the references and the
"RTN","RORUPP02",73,0)
 ;--- patient cannot be skipped if there are no references at all.
"RTN","RORUPP02",74,0)
 S:SDT<$G(RORUPD("EETS")) NEWSDT=SDT,NEWEDT=EDT,FEVT=1
"RTN","RORUPP02",75,0)
 ;--- Browse through the event references
"RTN","RORUPP02",76,0)
 S ED=$O(@ROOT@("AT",AREA,SDT),-1)
"RTN","RORUPP02",77,0)
 F  S ED=$O(@ROOT@("AT",AREA,ED))  Q:(ED="")!(ED'<EDT)  D
"RTN","RORUPP02",78,0)
 . S IEN=""
"RTN","RORUPP02",79,0)
 . F  S IEN=$O(@ROOT@("AT",AREA,ED,IEN))  Q:IEN=""  D
"RTN","RORUPP02",80,0)
 . . S TMP=$P($G(@ROOT@(IEN,0)),"^",3),FEVT=1
"RTN","RORUPP02",81,0)
 . . Q:TMP'>0
"RTN","RORUPP02",82,0)
 . . S:TMP<NEWSDT NEWSDT=TMP,FDTC=1
"RTN","RORUPP02",83,0)
 . . S:TMP>NEWEDT NEWEDT=TMP,FDTC=1
"RTN","RORUPP02",84,0)
 Q:'FEVT 0
"RTN","RORUPP02",85,0)
 I FDTC  S SDT=NEWSDT,EDT=NEWEDT  Q 2
"RTN","RORUPP02",86,0)
 Q 1
"RTN","RORUPP02",87,0)
 ;
"RTN","RORUPP02",88,0)
 ;***** PURGES THE OLD EVENT REFERENCES
"RTN","RORUPP02",89,0)
 ;
"RTN","RORUPP02",90,0)
 ; DATE          Keep the references starting from this date
"RTN","RORUPP02",91,0)
 ;
"RTN","RORUPP02",92,0)
 ; Return Values:
"RTN","RORUPP02",93,0)
 ;       <0  Error code
"RTN","RORUPP02",94,0)
 ;        0  Ok
"RTN","RORUPP02",95,0)
 ;
"RTN","RORUPP02",96,0)
PURGE(DATE) ;
"RTN","RORUPP02",97,0)
 N CNT,DA,DIK,IEN,IEN1,IENS,RC,REINDEX,ROOT,RORFDA,RORMSG
"RTN","RORUPP02",98,0)
 S ROOT=$$ROOT^DILFD(798.3,,1)
"RTN","RORUPP02",99,0)
 S DATE=DATE\1,(CNT,RC)=0
"RTN","RORUPP02",100,0)
 F  S DATE=$O(@ROOT@("AT",DATE),-1)  Q:DATE=""  D  Q:RC<0
"RTN","RORUPP02",101,0)
 . S IEN=""
"RTN","RORUPP02",102,0)
 . F  S IEN=$O(@ROOT@("AT",DATE,IEN))  Q:IEN=""  D  Q:RC<0
"RTN","RORUPP02",103,0)
 . . S IEN1="",REINDEX=0
"RTN","RORUPP02",104,0)
 . . F  S IEN1=$O(@ROOT@("AT",DATE,IEN,IEN1))  Q:IEN1=""  D  Q:RC<0
"RTN","RORUPP02",105,0)
 . . . ;---Check if the corresponding record exists
"RTN","RORUPP02",106,0)
 . . . I '$D(@ROOT@(IEN,2,IEN1,0))  D  Q
"RTN","RORUPP02",107,0)
 . . . . ;--- Delete the "stray" entry from the cross-reference
"RTN","RORUPP02",108,0)
 . . . . K @ROOT@("AT",DATE,IEN,IEN1)
"RTN","RORUPP02",109,0)
 . . . ;--- Delete the record
"RTN","RORUPP02",110,0)
 . . . S IENS=IEN1_","_IEN_","
"RTN","RORUPP02",111,0)
 . . . S RORFDA(798.32,IENS,.01)="@"
"RTN","RORUPP02",112,0)
 . . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUPP02",113,0)
 . . . I $G(DIERR)  D  Q
"RTN","RORUPP02",114,0)
 . . . . S RC=$$DBS^RORERR("RORMSG",-9,,,798.32,IENS)
"RTN","RORUPP02",115,0)
 . . . S CNT=CNT+1
"RTN","RORUPP02",116,0)
 . . ;--- Re-index the main record if necessary
"RTN","RORUPP02",117,0)
 . . I REINDEX  K DA  S DIK=$$OREF^DILF(ROOT),DA=IEN  D IX^DIK
"RTN","RORUPP02",118,0)
 D:CNT>0 LOG^RORLOG(2,CNT_" events were purged from the file #798.3")
"RTN","RORUPP02",119,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR")
0^134^B27116050
"RTN","RORUPR",1,0)
RORUPR ;HCIOFO/SG - SELECTION RULES PREPARATION  ; 7/21/03 10:33am
"RTN","RORUPR",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORUPR",3,0)
 ;
"RTN","RORUPR",4,0)
 Q
"RTN","RORUPR",5,0)
 ;
"RTN","RORUPR",6,0)
 ;***** PREPARES SELECTION RULES AND OTHER DATA
"RTN","RORUPR",7,0)
 ;
"RTN","RORUPR",8,0)
 ; .REGLST       Reference to a local array containing registry names
"RTN","RORUPR",9,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUPR",10,0)
 ; [LMODE]       When stop looping through records of the patient:
"RTN","RORUPR",11,0)
 ;                 0  always loop through all records
"RTN","RORUPR",12,0)
 ;                 1  all top level rules have been triggered (deflt)
"RTN","RORUPR",13,0)
 ;                 2  patient has been marked for addition to all
"RTN","RORUPR",14,0)
 ;                    registries being processed
"RTN","RORUPR",15,0)
 ; [DSBEG]       Start date/time of the data scan (the earliest
"RTN","RORUPR",16,0)
 ;               registry update date by default)
"RTN","RORUPR",17,0)
 ; [DSEND]       End date/time of the data scan (NOW by default)
"RTN","RORUPR",18,0)
 ;
"RTN","RORUPR",19,0)
 ; Return Values:
"RTN","RORUPR",20,0)
 ;        0  Ok
"RTN","RORUPR",21,0)
 ;       <0  Error code
"RTN","RORUPR",22,0)
 ;
"RTN","RORUPR",23,0)
PREPARE(REGLST,LMODE,DSBEG,DSEND) ;
"RTN","RORUPR",24,0)
 N FILE,I,RC
"RTN","RORUPR",25,0)
 ;--- Clear loop control lists
"RTN","RORUPR",26,0)
 K RORUPD("LM")  S RORUPD("LM")=+$G(LMODE,1)
"RTN","RORUPR",27,0)
 ;--- Load registry parameters
"RTN","RORUPR",28,0)
 S RC=$$PREPARE1(.REGLST,$G(DSBEG),$G(DSEND))  Q:RC<0 RC
"RTN","RORUPR",29,0)
 ;--- Load selection rules
"RTN","RORUPR",30,0)
 S RC=$$LOAD^RORUPR1(.REGLST)        Q:RC<0 $$ERROR^RORERR(-19)
"RTN","RORUPR",31,0)
 ;--- Load and prepare Lab search data
"RTN","RORUPR",32,0)
 S RC=$$LABSRCH^RORUPR1()            Q:RC<0 $$ERROR^RORERR(-12)
"RTN","RORUPR",33,0)
 ;--- Sort loaded rules
"RTN","RORUPR",34,0)
 S RC=$$SORT()                       Q:RC<0 $$ERROR^RORERR(-20)
"RTN","RORUPR",35,0)
 ;--- Load and prepare metadata
"RTN","RORUPR",36,0)
 S RC=$$METADATA^RORUPR1()           Q:RC<0 RC
"RTN","RORUPR",37,0)
 Q 0
"RTN","RORUPR",38,0)
 ;
"RTN","RORUPR",39,0)
 ;***** LOADS REGISTRY PARAMETERS
"RTN","RORUPR",40,0)
 ;
"RTN","RORUPR",41,0)
 ; .REGLST       Reference to a local array containing
"RTN","RORUPR",42,0)
 ;               registry names as subscripts
"RTN","RORUPR",43,0)
 ;
"RTN","RORUPR",44,0)
 ; [DSBEG]       Start date of the data scan (the earliest registry
"RTN","RORUPR",45,0)
 ;               update date by default). Time part of the parameter
"RTN","RORUPR",46,0)
 ;               value is ignored.
"RTN","RORUPR",47,0)
 ;
"RTN","RORUPR",48,0)
 ; [DSEND]       End date/time of the data scan (NOW by default).
"RTN","RORUPR",49,0)
 ;
"RTN","RORUPR",50,0)
 ; Return Values:
"RTN","RORUPR",51,0)
 ;        0  Ok
"RTN","RORUPR",52,0)
 ;       <0  Error code
"RTN","RORUPR",53,0)
 ;
"RTN","RORUPR",54,0)
PREPARE1(REGLST,DSBEG,DSEND) ;
"RTN","RORUPR",55,0)
 N DATE,EVTPROT,I,RC,REGIEN,REGNAME,RORBUF,TMP,UPDSTART
"RTN","RORUPR",56,0)
 K RORUPD("LD"),RORUPD("LM2"),RORUPD("UPD")
"RTN","RORUPR",57,0)
 S DSBEG=$G(DSBEG)\1,DSEND=+$G(DSEND)
"RTN","RORUPR",58,0)
 S UPDSTART=$$DT^XLFDT,EVTPROT=0
"RTN","RORUPR",59,0)
 ;---
"RTN","RORUPR",60,0)
 S REGNAME="",RC=0
"RTN","RORUPR",61,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPR",62,0)
 . S TMP="1I;6.1;6.2;15.1;25I;26I"
"RTN","RORUPR",63,0)
 . S REGIEN=$$REGIEN^RORUTL02(REGNAME,TMP,.RORBUF)
"RTN","RORUPR",64,0)
 . I REGIEN'>0  S RC=$$ERROR^RORERR(-46,,REGNAME)  Q
"RTN","RORUPR",65,0)
 . ;--- Add an item to the static list of registries
"RTN","RORUPR",66,0)
 . S RORUPD("LM2",REGIEN)=U_$G(RORBUF("DILIST","ID",1,26))
"RTN","RORUPR",67,0)
 . ;--- Load and verify update entry points
"RTN","RORUPR",68,0)
 . S RC=0
"RTN","RORUPR",69,0)
 . F I=1,2  D  Q:RC<0
"RTN","RORUPR",70,0)
 . . S TMP=$G(RORBUF("DILIST","ID",1,+("6."_I)))
"RTN","RORUPR",71,0)
 . . S TMP=$$TRIM^XLFSTR(TMP)  Q:TMP=""
"RTN","RORUPR",72,0)
 . . S RC=$$VERIFYEP^RORUTL01(TMP)
"RTN","RORUPR",73,0)
 . . S:RC'<0 RORUPD("UPD",REGIEN,I)=TMP
"RTN","RORUPR",74,0)
 . I RC<0  S RC=$$ERROR^RORERR(-6,,REGNAME,,TMP)  Q
"RTN","RORUPR",75,0)
 . ;--- Calculate the earliest update date for the registries
"RTN","RORUPR",76,0)
 . ;    being processed
"RTN","RORUPR",77,0)
 . S DATE=$G(RORBUF("DILIST","ID",1,1))\1
"RTN","RORUPR",78,0)
 . I DATE  S:DATE<UPDSTART UPDSTART=DATE
"RTN","RORUPR",79,0)
 . ;--- Calculate the longest lag interval
"RTN","RORUPR",80,0)
 . S TMP=$G(RORBUF("DILIST","ID",1,15.1))
"RTN","RORUPR",81,0)
 . S:TMP>$G(RORUPD("LD",1)) RORUPD("LD",1)=TMP
"RTN","RORUPR",82,0)
 . ;--- Check if event references should be used
"RTN","RORUPR",83,0)
 . S:$G(RORBUF("DILIST","ID",1,25)) EVTPROT=1
"RTN","RORUPR",84,0)
 Q:RC<0 RC
"RTN","RORUPR",85,0)
 ;--- Check the lag interval
"RTN","RORUPR",86,0)
 S:$G(RORUPD("LD",1))'>0 RORUPD("LD",1)=1
"RTN","RORUPR",87,0)
 ;--- Define data scan period
"RTN","RORUPR",88,0)
 S RORUPD("DT")=$$NOW^XLFDT
"RTN","RORUPR",89,0)
 S RORUPD("DSBEG")=$S(DSBEG:DSBEG,1:UPDSTART)
"RTN","RORUPR",90,0)
 S RORUPD("DSEND")=$S(DSEND:DSEND,1:RORUPD("DT"))
"RTN","RORUPR",91,0)
 ;--- Check if we have event references in the file #798.3
"RTN","RORUPR",92,0)
 S RORUPD("EETS")=$O(^RORDATA(798.3,"AT",""))
"RTN","RORUPR",93,0)
 S:'RORUPD("EETS") EVTPROT=0
"RTN","RORUPR",94,0)
 ;--- Add all necessary flags
"RTN","RORUPR",95,0)
 S RORUPD("FLAGS")=$TR($G(RORUPD("FLAGS")),"E")
"RTN","RORUPR",96,0)
 S:EVTPROT RORUPD("FLAGS")=RORUPD("FLAGS")_"E"
"RTN","RORUPR",97,0)
 Q 0
"RTN","RORUPR",98,0)
 ;
"RTN","RORUPR",99,0)
 ;***** PUTS THE RULE INTO THE LIST
"RTN","RORUPR",100,0)
 ;
"RTN","RORUPR",101,0)
 ; RULENAME      Name of the rule
"RTN","RORUPR",102,0)
 ; MODE          "A" (process after subfiles) or
"RTN","RORUPR",103,0)
 ;               "B" (process before subfiles)
"RTN","RORUPR",104,0)
 ; PARENT        Name of the parent rule
"RTN","RORUPR",105,0)
 ; 
"RTN","RORUPR",106,0)
 ; Return Values:
"RTN","RORUPR",107,0)
 ;        0  Ok
"RTN","RORUPR",108,0)
 ;       <0  Error code
"RTN","RORUPR",109,0)
 ;
"RTN","RORUPR",110,0)
PUTRULE(RULENAME,MODE,PARENT) ;
"RTN","RORUPR",111,0)
 N CODE,DSTNODE,DEPNAME,HDR,FILE,IR,IC
"RTN","RORUPR",112,0)
 S HDR=$G(@RORUPDPI@(3,RULENAME)),FILE=+$P(HDR,U,2)
"RTN","RORUPR",113,0)
 ;--- If the rule has already been processed, try to remove it from
"RTN","RORUPR",114,0)
 ;    the dependency list of the parent rule
"RTN","RORUPR",115,0)
 I $P(HDR,U,3)  D REMOVE(RULENAME,FILE,MODE,$G(PARENT))  Q 0
"RTN","RORUPR",116,0)
 ;--- If the rule is in the list of parent rules already, it has been
"RTN","RORUPR",117,0)
 ;    mentioned ; somewhere above in the current processing path.
"RTN","RORUPR",118,0)
 ;    So, we have "cirle refrenece" (the rule directly or inderectly
"RTN","RORUPR",119,0)
 ;    depends on itself)
"RTN","RORUPR",120,0)
 Q:$D(LSTRUL(RULENAME)) $$ERROR^RORERR(-5,,RULENAME)
"RTN","RORUPR",121,0)
 ;--- Put the rule into the list of parent rules
"RTN","RORUPR",122,0)
 S LSTRUL(RULENAME)=""
"RTN","RORUPR",123,0)
 ;--- Process the rules that this one depends on
"RTN","RORUPR",124,0)
 S DEPNAME=""
"RTN","RORUPR",125,0)
 F  S DEPNAME=$O(@RORUPDPI@(3,RULENAME,3,DEPNAME))  Q:DEPNAME=""  D  Q:RC<0
"RTN","RORUPR",126,0)
 . S RC=$$PUTRULE(DEPNAME,MODE,RULENAME)
"RTN","RORUPR",127,0)
 ;--- Remove the rule from the list of parent rules
"RTN","RORUPR",128,0)
 K LSTRUL(RULENAME)  Q:RC<0 RC
"RTN","RORUPR",129,0)
 ;--- Process the rule (put it in the sorted list of rules) if there
"RTN","RORUPR",130,0)
 ;    are no rules left in its dependency list
"RTN","RORUPR",131,0)
 D:$D(@RORUPDPI@(3,RULENAME,3))<10
"RTN","RORUPR",132,0)
 . S IR=$O(RORUPD("SR",FILE,MODE,""),-1)+1
"RTN","RORUPR",133,0)
 . S DSTNODE=$NA(RORUPD("SR",FILE,MODE,IR))
"RTN","RORUPR",134,0)
 . S @DSTNODE=RULENAME_U_+HDR_U_$P(HDR,U,4)
"RTN","RORUPR",135,0)
 . S @DSTNODE@(1)=@RORUPDPI@(3,RULENAME,1)
"RTN","RORUPR",136,0)
 . M @DSTNODE@(2)=@RORUPDPI@(3,RULENAME,2)
"RTN","RORUPR",137,0)
 . S $P(@RORUPDPI@(3,RULENAME),U,3)=1
"RTN","RORUPR",138,0)
 . ;--- Try to remove the rule from the dependency list of
"RTN","RORUPR",139,0)
 . ;    the parent rule
"RTN","RORUPR",140,0)
 . D REMOVE(RULENAME,FILE,MODE,$G(PARENT))
"RTN","RORUPR",141,0)
 Q 0
"RTN","RORUPR",142,0)
 ;
"RTN","RORUPR",143,0)
 ;***** REMOVES THE RULE FROM THE DEPENDENCY LIST OF THE PARENT RULE
"RTN","RORUPR",144,0)
 ;
"RTN","RORUPR",145,0)
 ; RULENAME      Name of the rule
"RTN","RORUPR",146,0)
 ; FILE          File number
"RTN","RORUPR",147,0)
 ; MODE          "A" (process after subfiles) or
"RTN","RORUPR",148,0)
 ;               "B" (process before subfiles)
"RTN","RORUPR",149,0)
 ; PARENT        Name of the parent rule
"RTN","RORUPR",150,0)
 ;
"RTN","RORUPR",151,0)
 ; During the first pass of the sort ("before" rules) a rule is
"RTN","RORUPR",152,0)
 ; removed from the parent's dependency list only if the rule is
"RTN","RORUPR",153,0)
 ; associated with the same file as its parent.
"RTN","RORUPR",154,0)
 ;
"RTN","RORUPR",155,0)
 ; Rules are always removed from the dependency list during
"RTN","RORUPR",156,0)
 ; the second sort pass ("after" rules").
"RTN","RORUPR",157,0)
 ;
"RTN","RORUPR",158,0)
REMOVE(RULENAME,FILE,MODE,PARENT) ;
"RTN","RORUPR",159,0)
 Q:$G(PARENT)=""
"RTN","RORUPR",160,0)
 K:(+$P($G(@RORUPDPI@(3,PARENT)),U,2)=FILE)!(MODE="A") @RORUPDPI@(3,PARENT,3,RULENAME)
"RTN","RORUPR",161,0)
 Q
"RTN","RORUPR",162,0)
 ;
"RTN","RORUPR",163,0)
 ;***** SORTS SELECTION RULES
"RTN","RORUPR",164,0)
 ;
"RTN","RORUPR",165,0)
 ; Return Values:
"RTN","RORUPR",166,0)
 ;        0  Ok
"RTN","RORUPR",167,0)
 ;       <0  Error code
"RTN","RORUPR",168,0)
 ;
"RTN","RORUPR",169,0)
SORT() ;
"RTN","RORUPR",170,0)
 N LSTRUL        ; List of names of the parent rules above in the path
"RTN","RORUPR",171,0)
 ;
"RTN","RORUPR",172,0)
 N FILE,MODE,RC,RULENAME
"RTN","RORUPR",173,0)
 S RC=0  K RORUPD("SR")
"RTN","RORUPR",174,0)
 ;--- Process "before" selection rules first and then process
"RTN","RORUPR",175,0)
 ;  "after" rules
"RTN","RORUPR",176,0)
 F MODE="B","A"  D  Q:RC
"RTN","RORUPR",177,0)
 . S FILE=""             ; Loop through affected files
"RTN","RORUPR",178,0)
 . F  S FILE=$O(@RORUPDPI@(1,FILE))  Q:FILE=""  D  Q:RC
"RTN","RORUPR",179,0)
 . . S RULENAME=""       ; Loop through top level rules
"RTN","RORUPR",180,0)
 . . F  S RULENAME=$O(@RORUPDPI@(1,FILE,"S",RULENAME))  Q:RULENAME=""  D  Q:RC<0
"RTN","RORUPR",181,0)
 . . . S RC=$$PUTRULE(RULENAME,MODE)
"RTN","RORUPR",182,0)
 ;---
"RTN","RORUPR",183,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1")
0^131^B69074484
"RTN","RORUPR1",1,0)
RORUPR1 ;HCIOFO/SG - SELECTION RULES PREPARATION  ; 10/6/03 3:13pm
"RTN","RORUPR1",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3,5**;May 14, 2002
"RTN","RORUPR1",3,0)
 ;
"RTN","RORUPR1",4,0)
 Q
"RTN","RORUPR1",5,0)
 ;
"RTN","RORUPR1",6,0)
 ;***** MARKS PARENT FILES TO PROCESS
"RTN","RORUPR1",7,0)
 ;
"RTN","RORUPR1",8,0)
 ; This function analyzes file dependencies defined by the 'ROR
"RTN","RORUPR1",9,0)
 ; METADATA' file and guaranties that all necessary files will be
"RTN","RORUPR1",10,0)
 ; processed during the registry update.
"RTN","RORUPR1",11,0)
 ;
"RTN","RORUPR1",12,0)
FILETREE() ;
"RTN","RORUPR1",13,0)
 N FILE,PF,RC
"RTN","RORUPR1",14,0)
 S FILE="",RC=0
"RTN","RORUPR1",15,0)
 F  S FILE=$O(RORUPD("SR",FILE))  Q:FILE=""  D  Q:RC<0
"RTN","RORUPR1",16,0)
 . S PF=+FILE,RC=0
"RTN","RORUPR1",17,0)
 . ;--- Follow a path that leads from this file to
"RTN","RORUPR1",18,0)
 . ;    the root of the "file-processing tree".
"RTN","RORUPR1",19,0)
 . F  D  Q:RC
"RTN","RORUPR1",20,0)
 . . ;--- Check if metadata for the file is defined
"RTN","RORUPR1",21,0)
 . . I '$D(^ROR(799.2,PF))  D  Q
"RTN","RORUPR1",22,0)
 . . . S RC=$$ERROR^RORERR(-63,,,,PF)
"RTN","RORUPR1",23,0)
 . . ;--- Get the number of the parent file
"RTN","RORUPR1",24,0)
 . . S PF=+$$GET1^DIQ(799.2,PF_",",1,"I",,"RORMSG")
"RTN","RORUPR1",25,0)
 . . I $G(DIERR)  D  Q
"RTN","RORUPR1",26,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9)
"RTN","RORUPR1",27,0)
 . . ;--- Stop if the root of the "file-processing tree" has been
"RTN","RORUPR1",28,0)
 . . ;    reached or the file is already marked for processing.
"RTN","RORUPR1",29,0)
 . . ;    Otherwise, mark the file and continue moving up.
"RTN","RORUPR1",30,0)
 . . I 'PF!$D(RORUPD("SR",PF))  S RC=1  Q
"RTN","RORUPR1",31,0)
 . . S RORUPD("SR",PF)=""
"RTN","RORUPR1",32,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1",33,0)
 ;
"RTN","RORUPR1",34,0)
 ;***** RETURNS LEVEL OF THE FILE IN 'THE FILE PROCESSING' TREE
"RTN","RORUPR1",35,0)
 ;
"RTN","RORUPR1",36,0)
 ; FILE          File number
"RTN","RORUPR1",37,0)
 ;
"RTN","RORUPR1",38,0)
FLEVEL(FILE) ;
"RTN","RORUPR1",39,0)
 N LEVEL
"RTN","RORUPR1",40,0)
 S LEVEL=1
"RTN","RORUPR1",41,0)
 F  S FILE=+$P($G(^ROR(799.2,FILE,0)),U,2)  Q:'FILE  S LEVEL=LEVEL+1
"RTN","RORUPR1",42,0)
 Q LEVEL
"RTN","RORUPR1",43,0)
 ;
"RTN","RORUPR1",44,0)
 ;***** LOADS AND PREPARES LAB SEARCH INDICATORS
"RTN","RORUPR1",45,0)
 ;
"RTN","RORUPR1",46,0)
 ; Return Values:
"RTN","RORUPR1",47,0)
 ;        0  Ok
"RTN","RORUPR1",48,0)
 ;       <0  Error code
"RTN","RORUPR1",49,0)
 ;
"RTN","RORUPR1",50,0)
LABSRCH() ;
"RTN","RORUPR1",51,0)
 N I,IND,IR,LRCODE,LSICNT,LSIEN,RC,RORBUF,RORMSG,TMP,VAL
"RTN","RORUPR1",52,0)
 K RORLRC
"RTN","RORUPR1",53,0)
 ;--- Browse through the list of Lab searches
"RTN","RORUPR1",54,0)
 S LSIEN="",RC=0
"RTN","RORUPR1",55,0)
 F  S LSIEN=$O(@RORUPDPI@(4,LSIEN))  Q:LSIEN=""  D  Q:RC<0
"RTN","RORUPR1",56,0)
 . K RORBUF  S TMP=","_LSIEN_","
"RTN","RORUPR1",57,0)
 . D LIST^DIC(798.92,TMP,"@;.01;.02;1I;2",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",58,0)
 . S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0
"RTN","RORUPR1",59,0)
 . ;--- Browse through the list of search indicators
"RTN","RORUPR1",60,0)
 . S IR="",LSICNT=0
"RTN","RORUPR1",61,0)
 . F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D  Q:RC<0
"RTN","RORUPR1",62,0)
 . . K LRCODE
"RTN","RORUPR1",63,0)
 . . ;--- Check if the indicator should be ignored
"RTN","RORUPR1",64,0)
 . . S IND=$G(RORBUF("DILIST","ID",IR,1))  Q:IND'>0
"RTN","RORUPR1",65,0)
 . . ;--- Get the result code (LOINC and/or NLT)
"RTN","RORUPR1",66,0)
 . . S LRCODE=$G(RORBUF("DILIST","ID",IR,.01))
"RTN","RORUPR1",67,0)
 . . I LRCODE>0  D  Q:RC<0  S LRCODE(LRCODE_"^LN")=""
"RTN","RORUPR1",68,0)
 . . . S LRCODE=$$LNCODE^RORUTL02(LRCODE)
"RTN","RORUPR1",69,0)
 . . . S:LRCODE<0 RC=LRCODE
"RTN","RORUPR1",70,0)
 . . S LRCODE=$G(RORBUF("DILIST","ID",IR,.02))
"RTN","RORUPR1",71,0)
 . . S:LRCODE>0 LRCODE(LRCODE_"^NLT")=""
"RTN","RORUPR1",72,0)
 . . M RORLRC("B")=LRCODE
"RTN","RORUPR1",73,0)
 . . ;--- Prepare and store the search indicator
"RTN","RORUPR1",74,0)
 . . S VAL=$G(RORBUF("DILIST","ID",IR,2))
"RTN","RORUPR1",75,0)
 . . I VAL="",IND'=1,IND'=6  Q
"RTN","RORUPR1",76,0)
 . . S LSICNT=LSICNT+1
"RTN","RORUPR1",77,0)
 . . S LRCODE=""
"RTN","RORUPR1",78,0)
 . . F  S LRCODE=$O(LRCODE(LRCODE))  Q:LRCODE=""  D
"RTN","RORUPR1",79,0)
 . . . S I=$O(@RORUPDPI@("LS",LRCODE,LSIEN,""),-1)+1
"RTN","RORUPR1",80,0)
 . . . S @RORUPDPI@("LS",LRCODE,LSIEN,I)=IND_U_VAL
"RTN","RORUPR1",81,0)
 . Q:(RC<0)!(LSICNT>0)
"RTN","RORUPR1",82,0)
 . ;--- Record a warning if no indicators are defined
"RTN","RORUPR1",83,0)
 . S TMP=$$GET1^DIQ(798.9,LSIEN_",",.01,,,"RORMSG")
"RTN","RORUPR1",84,0)
 . S TMP=$$ERROR^RORERR(-55,,,,TMP)
"RTN","RORUPR1",85,0)
 Q:RC<0 RC
"RTN","RORUPR1",86,0)
 ;--- Prepare a list of Lab result codes for GCPR^LA7QRY
"RTN","RORUPR1",87,0)
 S LRCODE=""
"RTN","RORUPR1",88,0)
 F IR=1:1  S LRCODE=$O(RORLRC("B",LRCODE))  Q:LRCODE=""  D
"RTN","RORUPR1",89,0)
 . S RORLRC(IR)=LRCODE
"RTN","RORUPR1",90,0)
 K RORLRC("B")
"RTN","RORUPR1",91,0)
 Q 0
"RTN","RORUPR1",92,0)
 ;
"RTN","RORUPR1",93,0)
 ;***** LOADS SELECTION RULES DATA
"RTN","RORUPR1",94,0)
 ;
"RTN","RORUPR1",95,0)
 ; .REGLST       Reference to a local array containing registry names
"RTN","RORUPR1",96,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUPR1",97,0)
 ;
"RTN","RORUPR1",98,0)
 ; Return Values:
"RTN","RORUPR1",99,0)
 ;        0  Ok
"RTN","RORUPR1",100,0)
 ;       <0  Error code
"RTN","RORUPR1",101,0)
 ;
"RTN","RORUPR1",102,0)
LOAD(REGLST) ;
"RTN","RORUPR1",103,0)
 N I,IENS,RC,REGIEN,REGNAME,RORBUF,RORMSG,RULENAME
"RTN","RORUPR1",104,0)
 K RORUPD("LM1")
"RTN","RORUPR1",105,0)
 S REGNAME="",RC=0
"RTN","RORUPR1",106,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPR1",107,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUPR1",108,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=REGIEN  Q
"RTN","RORUPR1",109,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUPR1",110,0)
 . S @RORUPDPI@(2,REGIEN)=REGNAME
"RTN","RORUPR1",111,0)
 . ;--- Load selection rules
"RTN","RORUPR1",112,0)
 . K RORBUF  S IENS=","_REGIEN_","
"RTN","RORUPR1",113,0)
 . D LIST^DIC(798.13,IENS,"@;.01E","U",,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",114,0)
 . S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0
"RTN","RORUPR1",115,0)
 . S I=""
"RTN","RORUPR1",116,0)
 . F  S I=$O(RORBUF("DILIST","ID",I))  Q:I=""  D  Q:RC<0
"RTN","RORUPR1",117,0)
 . . S RULENAME=RORBUF("DILIST","ID",I,.01)
"RTN","RORUPR1",118,0)
 . . S RC=$$LOADRULE(RULENAME,REGIEN)
"RTN","RORUPR1",119,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1",120,0)
 ;
"RTN","RORUPR1",121,0)
 ;***** LOADS THE SELECTION RULE
"RTN","RORUPR1",122,0)
 ;
"RTN","RORUPR1",123,0)
 ; RULENAME      Name of the rule
"RTN","RORUPR1",124,0)
 ; REGIEN        Registry IEN
"RTN","RORUPR1",125,0)
 ; [LEVEL]       Level of the rule (O for top level rules)
"RTN","RORUPR1",126,0)
 ;
"RTN","RORUPR1",127,0)
 ; Return Values:
"RTN","RORUPR1",128,0)
 ;        0  Ok
"RTN","RORUPR1",129,0)
 ;       <0  Error code
"RTN","RORUPR1",130,0)
 ;
"RTN","RORUPR1",131,0)
LOADRULE(RULENAME,REGIEN,LEVEL) ;
"RTN","RORUPR1",132,0)
 ;--- Quit if the rule has already been loaded
"RTN","RORUPR1",133,0)
 I $D(@RORUPDPI@(3,RULENAME))  D  Q 0
"RTN","RORUPR1",134,0)
 . S @RORUPDPI@(3,RULENAME,2,REGIEN)=""
"RTN","RORUPR1",135,0)
 ;---
"RTN","RORUPR1",136,0)
 N DATELMT,DEPRLC,EXPR,FILE,I,IENS,RORBUF,RORMSG,RULIEN,TMP
"RTN","RORUPR1",137,0)
 ;--- Load the rule data
"RTN","RORUPR1",138,0)
 D FIND^DIC(798.2,,"@;1;2I","X",RULENAME,2,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",139,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORUPR1",140,0)
 Q:$G(RORBUF("DILIST",0))<1 $$ERROR^RORERR(-3,,RULENAME)
"RTN","RORUPR1",141,0)
 Q:$G(RORBUF("DILIST",0))>1 $$ERROR^RORERR(-4,,RULENAME)
"RTN","RORUPR1",142,0)
 S RULIEN=+RORBUF("DILIST",2,1),IENS=","_RULIEN_","
"RTN","RORUPR1",143,0)
 S FILE=+RORBUF("DILIST","ID",1,2)
"RTN","RORUPR1",144,0)
 ;--- Put the rule data into the temporary global
"RTN","RORUPR1",145,0)
 S @RORUPDPI@(1,FILE,"S",RULENAME)=""
"RTN","RORUPR1",146,0)
 S @RORUPDPI@(3,RULENAME)=RULIEN_U_FILE_"^^"_'$G(LEVEL)
"RTN","RORUPR1",147,0)
 S RC=$$PARSER^RORUPEX(FILE,RORBUF("DILIST","ID",1,1),.EXPR)
"RTN","RORUPR1",148,0)
 Q:RC<0 RC
"RTN","RORUPR1",149,0)
 S @RORUPDPI@(3,RULENAME,1)=EXPR
"RTN","RORUPR1",150,0)
 S @RORUPDPI@(3,RULENAME,2,REGIEN)=""
"RTN","RORUPR1",151,0)
 M @RORUPDPI@(1,FILE,"F")=EXPR("F")
"RTN","RORUPR1",152,0)
 S:'$G(LEVEL) RORUPD("LM1",RULENAME)=""
"RTN","RORUPR1",153,0)
 M @RORUPDPI@(4)=EXPR("L")
"RTN","RORUPR1",154,0)
 ;--- Load the rules that this rule depends on
"RTN","RORUPR1",155,0)
 S DEPRLC=""
"RTN","RORUPR1",156,0)
 F  S DEPRLC=$O(EXPR("R",DEPRLC))  Q:DEPRLC=""  D  Q:RC<0
"RTN","RORUPR1",157,0)
 . S RC=$$LOADRULE(DEPRLC,REGIEN,$G(LEVEL)+1)
"RTN","RORUPR1",158,0)
 . S:RC'<0 @RORUPDPI@(3,RULENAME,3,DEPRLC)=""
"RTN","RORUPR1",159,0)
 Q:RC<0 RC
"RTN","RORUPR1",160,0)
 ;--- Load a list of additional data elements
"RTN","RORUPR1",161,0)
 K EXPR,RORBUF,RORMSG
"RTN","RORUPR1",162,0)
 D LIST^DIC(798.26,IENS,"@;.01I;1I",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",163,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORUPR1",164,0)
 S I=""
"RTN","RORUPR1",165,0)
 F  S I=$O(RORBUF("DILIST","ID",I))  Q:I=""  D
"RTN","RORUPR1",166,0)
 . S DATELMT=RORBUF("DILIST","ID",I,.01)
"RTN","RORUPR1",167,0)
 . S TMP=$G(RORBUF("DILIST","ID",I,1))  S:TMP="" TMP="EI"
"RTN","RORUPR1",168,0)
 . S:TMP["E" @RORUPDPI@(1,FILE,"F",DATELMT,"E")=""
"RTN","RORUPR1",169,0)
 . S:TMP["I" @RORUPDPI@(1,FILE,"F",DATELMT,"I")=""
"RTN","RORUPR1",170,0)
 Q 0
"RTN","RORUPR1",171,0)
 ;
"RTN","RORUPR1",172,0)
 ;***** LOADS AND PREPARES THE METADATA
"RTN","RORUPR1",173,0)
METADATA() ;
"RTN","RORUPR1",174,0)
 N API,DATELMT,DEFL,FILE,I,IENS,IS,PIF,RC,ROOT,RORBUF,RORMSG,TMP,VT
"RTN","RORUPR1",175,0)
 S RC=$$FILETREE()  Q:RC<0 RC
"RTN","RORUPR1",176,0)
 S DEFL="@;.02I;1I;4I;4.1;4.2;6I"
"RTN","RORUPR1",177,0)
 ;--- Load and process the metadata
"RTN","RORUPR1",178,0)
 S FILE="",RC=0
"RTN","RORUPR1",179,0)
 F  S FILE=$O(RORUPD("SR",FILE))  Q:FILE=""  D  Q:RC<0
"RTN","RORUPR1",180,0)
 . S IENS=","_FILE_",",PIF=$NA(@RORUPDPI@(1,FILE))
"RTN","RORUPR1",181,0)
 . ;--- Global root of the file
"RTN","RORUPR1",182,0)
 . S RORUPD("ROOT",FILE)=$$ROOT^DILFD(FILE,,1)
"RTN","RORUPR1",183,0)
 . ;--- Associate data elements with APIs
"RTN","RORUPR1",184,0)
 . S DATELMT=""
"RTN","RORUPR1",185,0)
 . F  S DATELMT=$O(@PIF@("F",DATELMT))  Q:DATELMT=""  D  Q:RC<0
"RTN","RORUPR1",186,0)
 . . ;--- Find and load defintion of the data element
"RTN","RORUPR1",187,0)
 . . K RORBUF,RORMSG
"RTN","RORUPR1",188,0)
 . . D FIND^DIC(799.22,IENS,DEFL,"X",DATELMT,,"C",,,"RORBUF","RORMSG")
"RTN","RORUPR1",189,0)
 . . I $G(DIERR)  D  Q
"RTN","RORUPR1",190,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,,,799.22,IENS)
"RTN","RORUPR1",191,0)
 . . ;--- Check if search on this element is supported
"RTN","RORUPR1",192,0)
 . . S API=+$G(RORBUF("DILIST","ID",1,1))
"RTN","RORUPR1",193,0)
 . . I 'API  D  Q
"RTN","RORUPR1",194,0)
 . . . S RC=$$ERROR^RORERR(-64,,,,FILE,DATELMT)
"RTN","RORUPR1",195,0)
 . . ;--- Store the field number (if necessary)
"RTN","RORUPR1",196,0)
 . . I API=1  D  S RORUPD("SR",FILE,"F",API,DATELMT)=TMP
"RTN","RORUPR1",197,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",1,6))
"RTN","RORUPR1",198,0)
 . . ;--- Associate the data element with the API
"RTN","RORUPR1",199,0)
 . . S VT=$G(RORBUF("DILIST","ID",1,4)),RC=0
"RTN","RORUPR1",200,0)
 . . F I="E","I"  I $D(@PIF@("F",DATELMT,I))  D  Q:RC<0
"RTN","RORUPR1",201,0)
 . . . ;--- Check if type of the requested value is supported
"RTN","RORUPR1",202,0)
 . . . I VT'[I  D  Q
"RTN","RORUPR1",203,0)
 . . . . S TMP=$$EXTERNAL^DILFD(799.22,4,,I,"RORMSG")
"RTN","RORUPR1",204,0)
 . . . . S RC=$$ERROR^RORERR(-65,,,,FILE,DATELMT,TMP)
"RTN","RORUPR1",205,0)
 . . . ;--- Add the API-Element pair to the list
"RTN","RORUPR1",206,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",1,$$VTFN(I)))
"RTN","RORUPR1",207,0)
 . . . S RORUPD("SR",FILE,"F",API,DATELMT,I)=TMP
"RTN","RORUPR1",208,0)
 . Q:RC<0
"RTN","RORUPR1",209,0)
 . ;--- Add required elements (if any) to the list
"RTN","RORUPR1",210,0)
 . K RORBUF,RORMSG
"RTN","RORUPR1",211,0)
 . D FIND^DIC(799.22,IENS,DEFL,"X",1,,"AR",,,"RORBUF","RORMSG")
"RTN","RORUPR1",212,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPR1",213,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,799.22,IENS)
"RTN","RORUPR1",214,0)
 . S IS=""
"RTN","RORUPR1",215,0)
 . F  S IS=$O(RORBUF("DILIST","ID",IS))  Q:IS=""  D
"RTN","RORUPR1",216,0)
 . . S DATELMT=+$G(RORBUF("DILIST","ID",IS,.02))  Q:'DATELMT
"RTN","RORUPR1",217,0)
 . . S API=+$G(RORBUF("DILIST","ID",IS,1))        Q:'API
"RTN","RORUPR1",218,0)
 . . S VT=$G(RORBUF("DILIST","ID",IS,4))
"RTN","RORUPR1",219,0)
 . . F I="E","I"  D:VT[I
"RTN","RORUPR1",220,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",IS,$$VTFN(I)))
"RTN","RORUPR1",221,0)
 . . . S RORUPD("SR",FILE,"F",API,DATELMT,I)=TMP
"RTN","RORUPR1",222,0)
 . . ;--- Store the field number (if necessary)
"RTN","RORUPR1",223,0)
 . . I API=1  D  S RORUPD("SR",FILE,"F",API,DATELMT)=TMP
"RTN","RORUPR1",224,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",IS,6))
"RTN","RORUPR1",225,0)
 . ;--- Compile a list of fields (separated by ';') for the GETS^DIQ
"RTN","RORUPR1",226,0)
 . Q:$D(RORUPD("SR",FILE,"F",1))<10
"RTN","RORUPR1",227,0)
 . S (DATELMT,RORBUF)=""
"RTN","RORUPR1",228,0)
 . F  S DATELMT=$O(RORUPD("SR",FILE,"F",1,DATELMT))  Q:DATELMT=""  D
"RTN","RORUPR1",229,0)
 . . S TMP=+$G(RORUPD("SR",FILE,"F",1,DATELMT))
"RTN","RORUPR1",230,0)
 . . S:TMP>0 RORBUF=RORBUF_";"_TMP
"RTN","RORUPR1",231,0)
 . S RORUPD("SR",FILE,"F",1)=$S(RORBUF'="":$P(RORBUF,";",2,999),1:"")
"RTN","RORUPR1",232,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1",233,0)
 ;
"RTN","RORUPR1",234,0)
 ;***** RETURNS FIELD NUMBER OF ADDITIONAL DATA
"RTN","RORUPR1",235,0)
VTFN(VT) ;
"RTN","RORUPR1",236,0)
 Q $S(VT="E":4.1,1:4.2)
"RTN","RORUTL01")
0^100^B29789111
"RTN","RORUTL01",1,0)
RORUTL01 ;HCIOFO/SG - UTILITIES  ; 11/10/03 3:14pm
"RTN","RORUTL01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3,5**;May 14, 2002
"RTN","RORUTL01",3,0)
 ;
"RTN","RORUTL01",4,0)
 ; This routine uses the following IAs:
"RTN","RORUTL01",5,0)
 ;
"RTN","RORUTL01",6,0)
 ; #3301         Access to the .6 field of the file #2
"RTN","RORUTL01",7,0)
 ; #3744         $$TESTPAT^VADPT
"RTN","RORUTL01",8,0)
 ; #10035        Access to the .01 and .09 fields of the file #2
"RTN","RORUTL01",9,0)
 ; #10038        Access to the HOLIDAY file (supported)
"RTN","RORUTL01",10,0)
 Q
"RTN","RORUTL01",11,0)
 ;
"RTN","RORUTL01",12,0)
 ;***** SENDS ALERT TO REGISTRY COORDINATORS
"RTN","RORUTL01",13,0)
 ;
"RTN","RORUTL01",14,0)
 ; [.]REGLST     Either name of the registry or reference to a local
"RTN","RORUTL01",15,0)
 ;               array containing registry names as subscripts and
"RTN","RORUTL01",16,0)
 ;               optional registry IENs as values
"RTN","RORUTL01",17,0)
 ;
"RTN","RORUTL01",18,0)
 ; MSG           Text of the message or negative error code. The '^'
"RTN","RORUTL01",19,0)
 ;               characters are replaced with spaces in the text.
"RTN","RORUTL01",20,0)
 ;
"RTN","RORUTL01",21,0)
 ; [XQAROU]      Indicates a ROUTINE or TAG^ROUTINE to run when
"RTN","RORUTL01",22,0)
 ;               the alert is processed
"RTN","RORUTL01",23,0)
 ;
"RTN","RORUTL01",24,0)
 ; [XQADATA]     Use this to store a package-specific data string,
"RTN","RORUTL01",25,0)
 ;               in any format
"RTN","RORUTL01",26,0)
 ;
"RTN","RORUTL01",27,0)
 ; [PATIEN]      Patient IEN
"RTN","RORUTL01",28,0)
 ;
"RTN","RORUTL01",29,0)
 ; [ARG2-ARG5]   Optional parameters as for the $$ERROR^RORERR
"RTN","RORUTL01",30,0)
 ;
"RTN","RORUTL01",31,0)
ALERT(REGLST,MSG,XQAROU,XQADATA,PATIEN,ARG2,ARG3,ARG4,ARG5) ;
"RTN","RORUTL01",32,0)
 N IR,RC,REGIEN,REGNAME,RORBUF,RORMSG,TMP,XQA,XQAFLG,XQAMSG
"RTN","RORUTL01",33,0)
 ;--- Prepare a list of coordinators
"RTN","RORUTL01",34,0)
 I $D(REGLST)=1  Q:REGLST=""  S REGLST(REGLST)=""
"RTN","RORUTL01",35,0)
 S REGNAME="",RC=0
"RTN","RORUTL01",36,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D
"RTN","RORUTL01",37,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUTL01",38,0)
 . I REGIEN'>0  D  Q:REGIEN'>0
"RTN","RORUTL01",39,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUTL01",40,0)
 . ;--- Load a list of coordinators from the registry parameters
"RTN","RORUTL01",41,0)
 . K RORBUF  S TMP=","_REGIEN_","
"RTN","RORUTL01",42,0)
 . D LIST^DIC(798.114,TMP,"@;.01I","U",,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL01",43,0)
 . S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0
"RTN","RORUTL01",44,0)
 . S IR=""
"RTN","RORUTL01",45,0)
 . F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D
"RTN","RORUTL01",46,0)
 . . S TMP=+$G(RORBUF("DILIST","ID",IR,.01))  S:TMP>0 XQA(TMP)=""
"RTN","RORUTL01",47,0)
 Q:$D(XQA)<10
"RTN","RORUTL01",48,0)
 ;--- Get text of the error message (if necessary)
"RTN","RORUTL01",49,0)
 I +MSG=MSG  Q:MSG'<0  D
"RTN","RORUTL01",50,0)
 . S MSG=$$MSG^RORERR20(+MSG,,.PATIEN,.ARG2,.ARG3,.ARG4,.ARG5)
"RTN","RORUTL01",51,0)
 S MSG=$TR(MSG,"^"," "),XQAMSG="ROR: ",TMP=70-$L(XQAMSG)-3
"RTN","RORUTL01",52,0)
 S XQAMSG=XQAMSG_$S($L(MSG)>TMP:$E(MSG,1,TMP)_"...",1:MSG)
"RTN","RORUTL01",53,0)
 ;--- Setup default alert processing routine
"RTN","RORUTL01",54,0)
 I $G(XQAROU)="",$G(XQADATA)=""  D
"RTN","RORUTL01",55,0)
 . S XQADATA=$E(MSG,1,78)_U_$G(PATIEN)
"RTN","RORUTL01",56,0)
 . S REGNAME=""
"RTN","RORUTL01",57,0)
 . F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D
"RTN","RORUTL01",58,0)
 . . S XQADATA=XQADATA_U_REGNAME
"RTN","RORUTL01",59,0)
 . S XQAROU="ALERTRTN^RORUTL01"
"RTN","RORUTL01",60,0)
 ;--- Send the alert
"RTN","RORUTL01",61,0)
 S XQAFLG="D"  D SETUP^XQALERT
"RTN","RORUTL01",62,0)
 Q
"RTN","RORUTL01",63,0)
 ;
"RTN","RORUTL01",64,0)
 ;***** DEFAULT ALERT PROCESSING ROUTINE
"RTN","RORUTL01",65,0)
 ;
"RTN","RORUTL01",66,0)
 ; XQADATA       Alert data
"RTN","RORUTL01",67,0)
 ;                 ^1: Message
"RTN","RORUTL01",68,0)
 ;                 ^2: Patient DFN
"RTN","RORUTL01",69,0)
 ;                 ^3: Registry name
"RTN","RORUTL01",70,0)
 ;                     ...
"RTN","RORUTL01",71,0)
 ;                 ^N: Registry name
"RTN","RORUTL01",72,0)
 ;
"RTN","RORUTL01",73,0)
ALERTRTN ;
"RTN","RORUTL01",74,0)
 Q:$G(XQADATA)=""
"RTN","RORUTL01",75,0)
 N I,REGNAME
"RTN","RORUTL01",76,0)
 W !!,$P(XQADATA,"^"),!
"RTN","RORUTL01",77,0)
 W:$P(XQADATA,"^",2) "Patient DFN: ",$P(XQADATA,"^",2),!
"RTN","RORUTL01",78,0)
 W "Processed Registries",!
"RTN","RORUTL01",79,0)
 F I=3:1  S REGNAME=$P(XQADATA,"^",I)  Q:REGNAME=""  W ?3,REGNAME,!
"RTN","RORUTL01",80,0)
 Q
"RTN","RORUTL01",81,0)
 ;
"RTN","RORUTL01",82,0)
 ;***** INITIALIZES THE VARIABLES
"RTN","RORUTL01",83,0)
 ;
"RTN","RORUTL01",84,0)
 ; NAMESP        Namespace to kill in the ^TMP global
"RTN","RORUTL01",85,0)
 ;               (must start with "ROR")
"RTN","RORUTL01",86,0)
 ; [XPURGE]      Purge namespaced nodes in the ^XTMP global.
"RTN","RORUTL01",87,0)
 ;               The ^XTMP(NAMESP_$J) node is always killed.
"RTN","RORUTL01",88,0)
 ;
"RTN","RORUTL01",89,0)
INIT(NAMESP,XPURGE) ;
"RTN","RORUTL01",90,0)
 N I,L,NOW  K ^TMP($J)
"RTN","RORUTL01",91,0)
 S:$G(U)="" U="^"  S:'$G(DT) DT=$$DT^XLFDT
"RTN","RORUTL01",92,0)
 Q:$E($G(NAMESP),1,3)'="ROR"
"RTN","RORUTL01",93,0)
 ;--- Kill namespaced nodes in the ^TMP global
"RTN","RORUTL01",94,0)
 S I=NAMESP,L=$L(NAMESP)
"RTN","RORUTL01",95,0)
 F  K ^TMP(I,$J)  S I=$O(^TMP(I))  Q:$E(I,1,L)'=NAMESP
"RTN","RORUTL01",96,0)
 ;--- Purge old namespaced nodes in the ^XTMP global
"RTN","RORUTL01",97,0)
 K ^XTMP(NAMESP_$J)
"RTN","RORUTL01",98,0)
 D:$G(XPURGE)
"RTN","RORUTL01",99,0)
 . S NOW=$$NOW^XLFDT,I=NAMESP,L=$L(NAMESP)
"RTN","RORUTL01",100,0)
 . F  D  S I=$O(^XTMP(I))  Q:$E(I,1,L)'=NAMESP
"RTN","RORUTL01",101,0)
 . . K:$G(^XTMP(I,0))<NOW ^XTMP(I)
"RTN","RORUTL01",102,0)
 Q
"RTN","RORUTL01",103,0)
 ;
"RTN","RORUTL01",104,0)
 ;***** INVERTS THE DATE
"RTN","RORUTL01",105,0)
 ;
"RTN","RORUTL01",106,0)
 ; DATE          Date in FileMan format
"RTN","RORUTL01",107,0)
 ; [MODE]        Mode of inversion
"RTN","RORUTL01",108,0)
 ;                 1  Strip the time BEFORE inversion
"RTN","RORUTL01",109,0)
 ;                 2  Strip the time AFTER inversion
"RTN","RORUTL01",110,0)
 ;                 3  Do not invert the time
"RTN","RORUTL01",111,0)
 ;
"RTN","RORUTL01",112,0)
INVDATE(DATE,MODE) ;
"RTN","RORUTL01",113,0)
 Q:$G(MODE)=1 9999999-$P(DATE,".")
"RTN","RORUTL01",114,0)
 Q:$G(MODE)=2 $P(9999999-DATE,".")
"RTN","RORUTL01",115,0)
 I $G(MODE)=3  Q:$P(DATE,".",2) (9999999-$P(DATE,"."))_"."_+$P(DATE,".",2)
"RTN","RORUTL01",116,0)
 Q 9999999-DATE
"RTN","RORUTL01",117,0)
 ;
"RTN","RORUTL01",118,0)
 ;***** RETURNS THE PATIENT IEN (DFN) FROM THE REGISTRY RECORD
"RTN","RORUTL01",119,0)
 ;
"RTN","RORUTL01",120,0)
 ; IEN           IEN of the registry record
"RTN","RORUTL01",121,0)
 ;
"RTN","RORUTL01",122,0)
PTIEN(IEN) ;
"RTN","RORUTL01",123,0)
 Q +$P($G(^RORDATA(798,+IEN,0)),U)
"RTN","RORUTL01",124,0)
 ;
"RTN","RORUTL01",125,0)
 ;***** RETURNS IEN OF THE PATIENT'S RECORD IN THE REGISTRY
"RTN","RORUTL01",126,0)
 ;
"RTN","RORUTL01",127,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL01",128,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL01",129,0)
 ;
"RTN","RORUTL01",130,0)
 ; Return Values:
"RTN","RORUTL01",131,0)
 ;       ""  The registry record has not been found
"RTN","RORUTL01",132,0)
 ;       >0  IEN of the patient's registry record
"RTN","RORUTL01",133,0)
 ;
"RTN","RORUTL01",134,0)
PRRIEN(PATIEN,REGIEN) ;
"RTN","RORUTL01",135,0)
 Q:(PATIEN'>0)!(REGIEN'>0) 0
"RTN","RORUTL01",136,0)
 Q $O(^RORDATA(798,"KEY",+PATIEN,+REGIEN,0))
"RTN","RORUTL01",137,0)
 ;
"RTN","RORUTL01",138,0)
 ;***** RETURNS NAME AND SHORT DESCRIPTION OF THE REGISTRY
"RTN","RORUTL01",139,0)
 ;
"RTN","RORUTL01",140,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL01",141,0)
 ;
"RTN","RORUTL01",142,0)
 ; Return Values:
"RTN","RORUTL01",143,0)
 ;
"RTN","RORUTL01",144,0)
 ; An empty string is returned in case of an error or if there
"RTN","RORUTL01",145,0)
 ; is no registry with such IEN. Otherwise, the name and short
"RTN","RORUTL01",146,0)
 ; description of the registry separated by "^" are returned.
"RTN","RORUTL01",147,0)
 ;
"RTN","RORUTL01",148,0)
REGNAME(REGIEN) ;
"RTN","RORUTL01",149,0)
 N IENS,NAME,RORBUF,RORMSG
"RTN","RORUTL01",150,0)
 Q:'$D(^ROR(798.1,+REGIEN)) ""
"RTN","RORUTL01",151,0)
 S IENS=+REGIEN_","
"RTN","RORUTL01",152,0)
 D GETS^DIQ(798.1,IENS,".01;4",,"RORBUF","RORMSG")
"RTN","RORUTL01",153,0)
 I $G(DIERR)  D  Q ""
"RTN","RORUTL01",154,0)
 . D DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","RORUTL01",155,0)
 Q RORBUF(798.1,IENS,.01)_U_$G(RORBUF(798.1,IENS,4))
"RTN","RORUTL01",156,0)
 ;
"RTN","RORUTL01",157,0)
 ;***** CHECKS IF THE PATIENT IS A TEST ONE
"RTN","RORUTL01",158,0)
 ;
"RTN","RORUTL01",159,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL01",160,0)
 ;
"RTN","RORUTL01",161,0)
 ; Return Values:
"RTN","RORUTL01",162,0)
 ;        0  The patient is NOT a test patient
"RTN","RORUTL01",163,0)
 ;        1  The patient IS a test patient
"RTN","RORUTL01",164,0)
 ;
"RTN","RORUTL01",165,0)
TESTPAT(PATIEN) ;
"RTN","RORUTL01",166,0)
 Q:$$TESTPAT^VADPT(PATIEN) 1
"RTN","RORUTL01",167,0)
 Q:$E($G(^DPT(PATIEN,0)),1,2)="ZZ" 1  ; NAME starts with "ZZ"
"RTN","RORUTL01",168,0)
 Q 0
"RTN","RORUTL01",169,0)
 ;
"RTN","RORUTL01",170,0)
 ;***** VERIFY THE ENTRY POINT
"RTN","RORUTL01",171,0)
 ;
"RTN","RORUTL01",172,0)
 ; ENTRY         Entry point of the external MUMPS function
"RTN","RORUTL01",173,0)
 ; [RECERR]      Record the errors (do not record by default)
"RTN","RORUTL01",174,0)
 ;
"RTN","RORUTL01",175,0)
 ; Return Values:
"RTN","RORUTL01",176,0)
 ;       -18  Routine does not exist
"RTN","RORUTL01",177,0)
 ;       -17  Invalid entry point
"RTN","RORUTL01",178,0)
 ;         0  Ok
"RTN","RORUTL01",179,0)
 ;
"RTN","RORUTL01",180,0)
VERIFYEP(ENTRY,RECERR) ;
"RTN","RORUTL01",181,0)
 N X
"RTN","RORUTL01",182,0)
 S X="S Y="_ENTRY  D ^DIM
"RTN","RORUTL01",183,0)
 Q:'$D(X) $S($G(RECERR):$$ERROR^RORERR(-17,,,,ENTRY),1:-17)
"RTN","RORUTL01",184,0)
 S X=$P(ENTRY,U,2)
"RTN","RORUTL01",185,0)
 X ^%ZOSF("TEST")  E  Q $S($G(RECERR):$$ERROR^RORERR(-18,,,,X),1:-18)
"RTN","RORUTL01",186,0)
 Q 0
"RTN","RORUTL01",187,0)
 ;
"RTN","RORUTL01",188,0)
 ;***** CHECKS IF THE DATE IS A WORKING DAY
"RTN","RORUTL01",189,0)
 ;
"RTN","RORUTL01",190,0)
 ; DATE          The date to be checked
"RTN","RORUTL01",191,0)
 ;
"RTN","RORUTL01",192,0)
 ; Return Values:
"RTN","RORUTL01",193,0)
 ;        0  Weekend or Holiday
"RTN","RORUTL01",194,0)
 ;        1  Working day
"RTN","RORUTL01",195,0)
 ;
"RTN","RORUTL01",196,0)
WDCHK(DATE) ;
"RTN","RORUTL01",197,0)
 N DOW,RORMSG
"RTN","RORUTL01",198,0)
 ;--- Return zero if Saturday (6) or Sunday (0)
"RTN","RORUTL01",199,0)
 S DOW=$$DOW^XLFDT(DATE,1)  Q:'DOW!(DOW>5) 0
"RTN","RORUTL01",200,0)
 ;--- Return 1 if cannot be found in the HOLIDAY file
"RTN","RORUTL01",201,0)
 Q $$FIND1^DIC(40.5,,"QX",DATE\1,"B",,"RORMSG")'>0
"RTN","RORUTL01",202,0)
 ;
"RTN","RORUTL01",203,0)
 ;***** RETURNS THE NEXT WORKING DAY DATE
"RTN","RORUTL01",204,0)
 ;
"RTN","RORUTL01",205,0)
 ; DATE          The source date
"RTN","RORUTL01",206,0)
 ;
"RTN","RORUTL01",207,0)
 ; The function returns a date of the next working day.
"RTN","RORUTL01",208,0)
 ;
"RTN","RORUTL01",209,0)
WDNEXT(DATE) ;
"RTN","RORUTL01",210,0)
 N DOW,RORMSG
"RTN","RORUTL01",211,0)
 F  D  Q:$$FIND1^DIC(40.5,,"QX",DATE,"B",,"RORMSG")'>0
"RTN","RORUTL01",212,0)
 . S DOW=$$DOW^XLFDT(DATE,1)  S:'DOW DOW=7
"RTN","RORUTL01",213,0)
 . ;--- Get the next day and skip a weekend if necessary
"RTN","RORUTL01",214,0)
 . S DATE=$$FMADD^XLFDT(DATE,$S(DOW<5:1,1:8-DOW))
"RTN","RORUTL01",215,0)
 Q DATE
"RTN","RORUTL01",216,0)
 ;
"RTN","RORUTL01",217,0)
 ;***** CREATES A HEADER OF THE NODE IN THE ^XTMP GLOBAL
"RTN","RORUTL01",218,0)
 ;
"RTN","RORUTL01",219,0)
 ; SUBSCR        Subscript of the node in the ^XTMP global
"RTN","RORUTL01",220,0)
 ; [DKEEP]       Number of days to keep the node (1 by default)
"RTN","RORUTL01",221,0)
 ; [DESCR]       Description of the node
"RTN","RORUTL01",222,0)
 ;
"RTN","RORUTL01",223,0)
XTMPHDR(SUBSCR,DKEEP,DESCR) ;
"RTN","RORUTL01",224,0)
 N DATE  S DATE=$$DT^XLFDT  S:$G(DKEEP)'>0 DKEEP=1
"RTN","RORUTL01",225,0)
 S ^XTMP(SUBSCR,0)=$$FMADD^XLFDT(DATE,DKEEP)_U_DATE_U_$G(DESCR)
"RTN","RORUTL01",226,0)
 Q
"RTN","RORUTL01",227,0)
 ;
"RTN","RORUTL01",228,0)
 ;***** EMULATES AND EXTENDS THE ZWRITE COMMAND :-)
"RTN","RORUTL01",229,0)
 ;
"RTN","RORUTL01",230,0)
 ; ROR8NODE      Closed root of the sub-tree to display
"RTN","RORUTL01",231,0)
 ;               (either local array or global variable)
"RTN","RORUTL01",232,0)
 ; [TITLE]       Title of the output
"RTN","RORUTL01",233,0)
 ;
"RTN","RORUTL01",234,0)
ZW(ROR8NODE,TITLE) ;
"RTN","RORUTL01",235,0)
 Q:ROR8NODE=""  Q:'$D(@ROR8NODE)
"RTN","RORUTL01",236,0)
 N FLT,L,PI  W !
"RTN","RORUTL01",237,0)
 W:$G(TITLE)'="" TITLE,!!
"RTN","RORUTL01",238,0)
 W:$D(@ROR8NODE)#10 ROR8NODE_"="_@ROR8NODE,!
"RTN","RORUTL01",239,0)
 S L=$L(ROR8NODE)  S:$E(ROR8NODE,L)=")" L=L-1
"RTN","RORUTL01",240,0)
 S FLT=$E(ROR8NODE,1,L),PI=ROR8NODE
"RTN","RORUTL01",241,0)
 F  S PI=$Q(@PI)  Q:$E(PI,1,L)'=FLT  W PI_"="_@PI,!
"RTN","RORUTL01",242,0)
 Q
"RTN","RORUTL02")
0^90^B37515307
"RTN","RORUTL02",1,0)
RORUTL02 ;HCIOFO/SG - UTILITIES  ; 1/13/04 11:48am
"RTN","RORUTL02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3,5**;May 14, 2002
"RTN","RORUTL02",3,0)
 ;
"RTN","RORUTL02",4,0)
 ; This routine uses the following IAs:
"RTN","RORUTL02",5,0)
 ;
"RTN","RORUTL02",6,0)
 ; #2701         $$GETICN^MPIF001 Gets ICN (supported)
"RTN","RORUTL02",7,0)
 ; #3556         $$GCPR^LA7QRY
"RTN","RORUTL02",8,0)
 ; #3557         Access to the field .01 and x-ref "B"
"RTN","RORUTL02",9,0)
 ;               of the file 95.3
"RTN","RORUTL02",10,0)
 ; #3646         $$EMPL^DGSEC4
"RTN","RORUTL02",11,0)
 ; #10035        Access to the field #.09 of the file #2
"RTN","RORUTL02",12,0)
 ;
"RTN","RORUTL02",13,0)
 Q
"RTN","RORUTL02",14,0)
 ;
"RTN","RORUTL02",15,0)
 ;***** CREATES A LIST OF ACTIVE REGISTRIES
"RTN","RORUTL02",16,0)
 ;
"RTN","RORUTL02",17,0)
 ; .SRCLST       A source list of registry names (as subscripts)
"RTN","RORUTL02",18,0)
 ; .DSTLST(      A list of names and IENs of active registries
"RTN","RORUTL02",19,0)
 ;   RegName)    Registry IEN
"RTN","RORUTL02",20,0)
 ;
"RTN","RORUTL02",21,0)
 ; Return values:
"RTN","RORUTL02",22,0)
 ;       <0  Error code
"RTN","RORUTL02",23,0)
 ;        0  Ok
"RTN","RORUTL02",24,0)
 ;
"RTN","RORUTL02",25,0)
 ; The function stores names and IENs of those registries from the
"RTN","RORUTL02",26,0)
 ; source list which are active and not awaiting acknowledgements
"RTN","RORUTL02",27,0)
 ; into a local variable passed as the second parameter.
"RTN","RORUTL02",28,0)
 ;
"RTN","RORUTL02",29,0)
 ; Moreover, it records corresponding messages about skipped
"RTN","RORUTL02",30,0)
 ; registries to the current open log.
"RTN","RORUTL02",31,0)
 ;
"RTN","RORUTL02",32,0)
ARLST(SRCLST,DSTLST) ;
"RTN","RORUTL02",33,0)
 N INFO,RC,REGIEN,REGNAME,RORBUF,TMP  K DSTLST
"RTN","RORUTL02",34,0)
 S REGNAME="",RC=0
"RTN","RORUTL02",35,0)
 F  S REGNAME=$O(SRCLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUTL02",36,0)
 . S REGIEN=$$REGIEN(REGNAME,"@;2.2I;11I;21.05I",.RORBUF)
"RTN","RORUTL02",37,0)
 . I REGIEN'>0  D  Q                        ; Error
"RTN","RORUTL02",38,0)
 . . S RC=$$ERROR^RORERR(REGIEN,,REGNAME)
"RTN","RORUTL02",39,0)
 . I $G(RORBUF("DILIST","ID",1,11))  D  Q   ; Inactive
"RTN","RORUTL02",40,0)
 . . D ERROR^RORERR(-48,,,,REGNAME)
"RTN","RORUTL02",41,0)
 . ;--- Check if the registry is awaiting application acknowledgement
"RTN","RORUTL02",42,0)
 . I $G(RORBUF("DILIST","ID",1,2.2))  D  Q
"RTN","RORUTL02",43,0)
 . . D TEXT^RORTXT(7980000.002,.INFO)
"RTN","RORUTL02",44,0)
 . . D ERROR^RORERR(-49,,.INFO,,REGNAME)
"RTN","RORUTL02",45,0)
 . . K INFO
"RTN","RORUTL02",46,0)
 . ;--- Check if the registry has been populated
"RTN","RORUTL02",47,0)
 . I '$G(RORBUF("DILIST","ID",1,21.05)),'$G(RORPARM("SETUP"))  D  Q
"RTN","RORUTL02",48,0)
 . . D TEXT^RORTXT(7980000.02,.INFO)
"RTN","RORUTL02",49,0)
 . . D ERROR^RORERR(-103,,.INFO,,REGNAME)
"RTN","RORUTL02",50,0)
 . . K INFO
"RTN","RORUTL02",51,0)
 . ;--- The registry can be updated
"RTN","RORUTL02",52,0)
 . S DSTLST(REGNAME)=REGIEN
"RTN","RORUTL02",53,0)
 Q RC
"RTN","RORUTL02",54,0)
 ;
"RTN","RORUTL02",55,0)
 ;***** RETURNS A FULL ICN OF THE PATIENT
"RTN","RORUTL02",56,0)
 ;
"RTN","RORUTL02",57,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",58,0)
 ;
"RTN","RORUTL02",59,0)
 ; Return Values:
"RTN","RORUTL02",60,0)
 ;       <0  Error code
"RTN","RORUTL02",61,0)
 ;       ""  ICN has not been assigned
"RTN","RORUTL02",62,0)
 ;       >0  Patient ICN
"RTN","RORUTL02",63,0)
 ;
"RTN","RORUTL02",64,0)
ICN(PATIEN) ;
"RTN","RORUTL02",65,0)
 N ICN,L,TMP
"RTN","RORUTL02",66,0)
 S ICN=$$GETICN^MPIF001(PATIEN)
"RTN","RORUTL02",67,0)
 I ICN'>0  D  Q ""
"RTN","RORUTL02",68,0)
 . S TMP=$$ERROR^RORERR(-57,,$P(ICN,U,2),PATIEN,+ICN,"$$GETICN^MPIF001")
"RTN","RORUTL02",69,0)
 ;--- Validate the checksum (just in case ;-)
"RTN","RORUTL02",70,0)
 S L=$L($P(ICN,"V",2))
"RTN","RORUTL02",71,0)
 Q $S(L<6:$P(ICN,"V")_"V"_$E("000000",1,6-L)_$P(ICN,"V",2),1:ICN)
"RTN","RORUTL02",72,0)
 ;
"RTN","RORUTL02",73,0)
 ;I L<6  D  Q $P(ICN,"V")_"V"_$E("000000",1,6-L)_$P(ICN,"V",2)
"RTN","RORUTL02",74,0)
 ;. S TMP=$$ERROR^RORERR(-59,,,PATIEN)
"RTN","RORUTL02",75,0)
 ;Q ICN
"RTN","RORUTL02",76,0)
 ;
"RTN","RORUTL02",77,0)
 ;***** LOADS THE LAB RESULTS
"RTN","RORUTL02",78,0)
 ;
"RTN","RORUTL02",79,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",80,0)
 ; SDT           Start date of the results
"RTN","RORUTL02",81,0)
 ; EDT           End date of the results
"RTN","RORUTL02",82,0)
 ;
"RTN","RORUTL02",83,0)
 ; Return values:
"RTN","RORUTL02",84,0)
 ;       <0  Error code
"RTN","RORUTL02",85,0)
 ;        0  Ok
"RTN","RORUTL02",86,0)
 ;
"RTN","RORUTL02",87,0)
 ; The function loads Lab results into the ^TMP("RORTMP",$J).
"RTN","RORUTL02",88,0)
 ;
"RTN","RORUTL02",89,0)
LABRSLTS(PATIEN,SDT,EDT) ;
"RTN","RORUTL02",90,0)
 N DST,H7CH,RC,RORMSG,TMP
"RTN","RORUTL02",91,0)
 S DST=$NA(^TMP("RORTMP",$J))  K @DST
"RTN","RORUTL02",92,0)
 I $D(RORLRC)<10  Q:$G(RORLRC)="" 0
"RTN","RORUTL02",93,0)
 ;--- Get the Patient ID (ICN or SSN)
"RTN","RORUTL02",94,0)
 S PTID=$$PTID(PATIEN)  Q:PTID<0 PTID
"RTN","RORUTL02",95,0)
 ;--- Get the Lab data
"RTN","RORUTL02",96,0)
 S H7CH=$G(RORHL("FS"))_$G(RORHL("ECH"))
"RTN","RORUTL02",97,0)
 S RC=$$GCPR^LA7QRY(PTID,SDT,EDT,.RORLRC,"*",.RORMSG,DST,H7CH)
"RTN","RORUTL02",98,0)
 I $D(RORMSG)>1  D
"RTN","RORUTL02",99,0)
 . N ERR,I,LST
"RTN","RORUTL02",100,0)
 . S (ERR,LST)=""
"RTN","RORUTL02",101,0)
 . F I=1:1  S ERR=$O(RORMSG(ERR))  Q:ERR=""  D
"RTN","RORUTL02",102,0)
 . . S LST=LST_","_ERR,TMP=RORMSG(ERR)
"RTN","RORUTL02",103,0)
 . . K RORMSG(ERR)  S RORMSG(I)=TMP
"RTN","RORUTL02",104,0)
 . S LST=$P(LST,",",2,999)  Q:(LST=3)!(LST=99)
"RTN","RORUTL02",105,0)
 . S RC=$$ERROR^RORERR(-27,,.RORMSG,PATIEN)
"RTN","RORUTL02",106,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL02",107,0)
 ;
"RTN","RORUTL02",108,0)
 ;***** RETURNS THE LOINC CODE WITH THE CONTROL DIGIT
"RTN","RORUTL02",109,0)
 ;
"RTN","RORUTL02",110,0)
 ; LNCODE        LOINC code
"RTN","RORUTL02",111,0)
 ;
"RTN","RORUTL02",112,0)
 ; Besides adding a control digit to the LOINC code, the function
"RTN","RORUTL02",113,0)
 ; checks the code against the LAB LOINC file (#95.3).
"RTN","RORUTL02",114,0)
 ;
"RTN","RORUTL02",115,0)
 ; Return values:
"RTN","RORUTL02",116,0)
 ;       <0  Error code
"RTN","RORUTL02",117,0)
 ;       >0  LOINC code with the control digit
"RTN","RORUTL02",118,0)
 ;
"RTN","RORUTL02",119,0)
LNCODE(LNCODE) ;
"RTN","RORUTL02",120,0)
 N RC,RORBUF,RORMSG
"RTN","RORUTL02",121,0)
 D FIND^DIC(95.3,,"@;.01E","X",$P(LNCODE,"-"),2,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL02",122,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,95.3)
"RTN","RORUTL02",123,0)
 I $G(RORBUF("DILIST",0))<1  D  Q RC ; Non-existent code
"RTN","RORUTL02",124,0)
 . S RC=$$ERROR^RORERR(-29,,,,LNCODE)
"RTN","RORUTL02",125,0)
 I $G(RORBUF("DILIST",0))>1  D  Q RC ; Duplicate records
"RTN","RORUTL02",126,0)
 . S RC=$$ERROR^RORERR(-30,,,,LNCODE)
"RTN","RORUTL02",127,0)
 Q RORBUF("DILIST","ID",1,.01)
"RTN","RORUTL02",128,0)
 ;
"RTN","RORUTL02",129,0)
 ;***** LOCK/UNLOCK REGISTRIES BEING PROCESSED
"RTN","RORUTL02",130,0)
 ;
"RTN","RORUTL02",131,0)
 ; .REGLST       Reference to a local array containing registry names 
"RTN","RORUTL02",132,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUTL02",133,0)
 ; [MODE]        0 - Unlock (default), 1 - Lock
"RTN","RORUTL02",134,0)
 ; [TO]          LOCK timeout (3 sec by defualt)
"RTN","RORUTL02",135,0)
 ; [NAME]        Name of the process/task
"RTN","RORUTL02",136,0)
 ;
"RTN","RORUTL02",137,0)
 ; Return Values:
"RTN","RORUTL02",138,0)
 ;       <0  Error code
"RTN","RORUTL02",139,0)
 ;        0  Some of the registries has been locked by another job
"RTN","RORUTL02",140,0)
 ;        1  Ok
"RTN","RORUTL02",141,0)
 ;
"RTN","RORUTL02",142,0)
LOCKREG(REGLST,MODE,TO,NAME) ;
"RTN","RORUTL02",143,0)
 Q:$D(REGLST)<10 1
"RTN","RORUTL02",144,0)
 N LOCKLST,RC,REGIEN,REGNAME
"RTN","RORUTL02",145,0)
 S REGNAME=""
"RTN","RORUTL02",146,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:REGIEN<0
"RTN","RORUTL02",147,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUTL02",148,0)
 . I REGIEN'>0  S REGIEN=$$REGIEN^RORUTL02(REGNAME)  Q:REGIEN'>0
"RTN","RORUTL02",149,0)
 . S LOCKLST(798.1,REGIEN_",")=""
"RTN","RORUTL02",150,0)
 Q:$G(REGIEN)<0 REGIEN
"RTN","RORUTL02",151,0)
 Q:$D(LOCKLST)<10 1
"RTN","RORUTL02",152,0)
 I $G(MODE)  D
"RTN","RORUTL02",153,0)
 . S RC=$$LOCK^RORLOCK(.LOCKLST,,,+$G(TO,3),$G(NAME))
"RTN","RORUTL02",154,0)
 E  S RC=$$UNLOCK^RORLOCK(.LOCKLST)
"RTN","RORUTL02",155,0)
 Q $S('RC:1,RC<0:RC,1:0)
"RTN","RORUTL02",156,0)
 ;
"RTN","RORUTL02",157,0)
 ;***** RETURNS A PATIENT ID (ICN OR SSN)
"RTN","RORUTL02",158,0)
 ;
"RTN","RORUTL02",159,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",160,0)
 ;
"RTN","RORUTL02",161,0)
 ; Return Values:
"RTN","RORUTL02",162,0)
 ;       <0  Error code
"RTN","RORUTL02",163,0)
 ;       ""  Neither ICN nor SSN has been assigned
"RTN","RORUTL02",164,0)
 ;       >0  Patient ICN (or SSN if ICN is not available)
"RTN","RORUTL02",165,0)
 ;
"RTN","RORUTL02",166,0)
PTID(PATIEN) ;
"RTN","RORUTL02",167,0)
 N L,PTID,RC,RORMSG
"RTN","RORUTL02",168,0)
 S PTID=$$GETICN^MPIF001(PATIEN)
"RTN","RORUTL02",169,0)
 I PTID>0  D  Q PTID
"RTN","RORUTL02",170,0)
 . ;--- Validate the checksum (just in case ;-)
"RTN","RORUTL02",171,0)
 . S L=$L($P(PTID,"V",2))  Q:L'<6
"RTN","RORUTL02",172,0)
 . ;S RC=$$ERROR^RORERR(-59,,,PATIEN)
"RTN","RORUTL02",173,0)
 . S $P(PTID,"V",2)=$E("000000",1,6-L)_$P(PTID,"V",2)
"RTN","RORUTL02",174,0)
 ;--- Get SSN if ICN is not available
"RTN","RORUTL02",175,0)
 S PTID=$$GET1^DIQ(2,PATIEN_",",.09,,,"RORMSG")
"RTN","RORUTL02",176,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,PATIEN,2)
"RTN","RORUTL02",177,0)
 Q PTID
"RTN","RORUTL02",178,0)
 ;
"RTN","RORUTL02",179,0)
 ;***** RETURNS IEN OF THE REGISTRY PARAMETERS
"RTN","RORUTL02",180,0)
 ;
"RTN","RORUTL02",181,0)
 ; REGNAME       Name of the registry
"RTN","RORUTL02",182,0)
 ; [FIELDS]      List of fields (separated by semicolons) to load
"RTN","RORUTL02",183,0)
 ; [.RORTRGT]    Reference to a local variable where field values will
"RTN","RORUTL02",184,0)
 ;               be stored by the FIND^DIC call
"RTN","RORUTL02",185,0)
 ;
"RTN","RORUTL02",186,0)
 ; Return Values:
"RTN","RORUTL02",187,0)
 ;       <0  Error code
"RTN","RORUTL02",188,0)
 ;       >0  Registry parameters IEN
"RTN","RORUTL02",189,0)
 ;
"RTN","RORUTL02",190,0)
REGIEN(REGNAME,FIELDS,RORTRGT) ;
"RTN","RORUTL02",191,0)
 N RC,REGIEN,RORMSG  K RORTRGT
"RTN","RORUTL02",192,0)
 D FIND^DIC(798.1,,"@;"_$G(FIELDS),"UX",REGNAME,2,"B",,,"RORTRGT","RORMSG")
"RTN","RORUTL02",193,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.1)
"RTN","RORUTL02",194,0)
 S RC=+$G(RORTRGT("DILIST",0))
"RTN","RORUTL02",195,0)
 Q $S(RC<1:-1,RC>1:-2,1:+RORTRGT("DILIST",2,1))
"RTN","RORUTL02",196,0)
 ;
"RTN","RORUTL02",197,0)
 ;***** RETURNS NUMBER OF RECORDS IN THE REGISTRY
"RTN","RORUTL02",198,0)
 ;
"RTN","RORUTL02",199,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL02",200,0)
 ; [.LOWIEN]     The smallest IEN will be returned via this parameter
"RTN","RORUTL02",201,0)
 ; [.HIGHIEN]    The biggest IEN will be returned via this parameter
"RTN","RORUTL02",202,0)
 ;
"RTN","RORUTL02",203,0)
 ; Return Values:
"RTN","RORUTL02",204,0)
 ;       <0  Error code
"RTN","RORUTL02",205,0)
 ;        0  The registry is empty
"RTN","RORUTL02",206,0)
 ;       >0  Number of records in the registry
"RTN","RORUTL02",207,0)
 ;
"RTN","RORUTL02",208,0)
REGSIZE(REGIEN,LOWIEN,HIGHIEN) ;
"RTN","RORUTL02",209,0)
 N I,NODE,NRE,RC,RORFDA,RORMSG
"RTN","RORUTL02",210,0)
 S NODE=$NA(^RORDATA(798,"AC",REGIEN))
"RTN","RORUTL02",211,0)
 S LOWIEN=$O(@NODE@(""))
"RTN","RORUTL02",212,0)
 S HIGHIEN=$O(@NODE@(""),-1)
"RTN","RORUTL02",213,0)
 ;--- Get number of records from the parameters
"RTN","RORUTL02",214,0)
 S NRE=$$GET1^DIQ(798.1,REGIEN_",",19.1,,,"RORMSG")
"RTN","RORUTL02",215,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.1,REGIEN)
"RTN","RORUTL02",216,0)
 Q:NRE>0 NRE
"RTN","RORUTL02",217,0)
 ;--- Count the records of the registry
"RTN","RORUTL02",218,0)
 S I="",NRE=0
"RTN","RORUTL02",219,0)
 F  S I=$O(@NODE@(I))  Q:I=""  S NRE=NRE+1
"RTN","RORUTL02",220,0)
 ;--- Store the value in the parameters
"RTN","RORUTL02",221,0)
 S RORFDA(798.1,REGIEN_",",19.1)=NRE
"RTN","RORUTL02",222,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUTL02",223,0)
 Q NRE
"RTN","RORUTL02",224,0)
 ;
"RTN","RORUTL02",225,0)
 ;***** CHECKS IF AN EMPLOYEE SHOULD BE SKIPPED
"RTN","RORUTL02",226,0)
 ;
"RTN","RORUTL02",227,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",228,0)
 ;
"RTN","RORUTL02",229,0)
 ; [.]REGIEN     Registry IEN
"RTN","RORUTL02",230,0)
 ;
"RTN","RORUTL02",231,0)
 ;               If you are going to call this function for several
"RTN","RORUTL02",232,0)
 ;               patients in a row (in a cycle), you can pass the
"RTN","RORUTL02",233,0)
 ;               second parameter by reference. This will eliminate
"RTN","RORUTL02",234,0)
 ;               repetitive access to the registry parameters (the
"RTN","RORUTL02",235,0)
 ;               REGIEN("SE") node will be used as a "cache" for the
"RTN","RORUTL02",236,0)
 ;               value of the EXCLUDE EMPLOYEES field).
"RTN","RORUTL02",237,0)
 ;
"RTN","RORUTL02",238,0)
 ; Return Values:
"RTN","RORUTL02",239,0)
 ;        0  Patient can be added to the registry
"RTN","RORUTL02",240,0)
 ;        1  Patient should be skipped
"RTN","RORUTL02",241,0)
 ;
"RTN","RORUTL02",242,0)
 ; The function checks if the patient is an employee and if he/she
"RTN","RORUTL02",243,0)
 ; can be added to the registry (according to the value of the
"RTN","RORUTL02",244,0)
 ; EXCLUDE EMPLOYEES field of the ROR REGISTRY PARAMETERS file).
"RTN","RORUTL02",245,0)
 ;
"RTN","RORUTL02",246,0)
SKIPEMPL(PATIEN,REGIEN) ;
"RTN","RORUTL02",247,0)
 Q:'$$EMPL^DGSEC4(PATIEN,"P") 0
"RTN","RORUTL02",248,0)
 S:'$D(REGIEN("SE")) REGIEN("SE")=+$P($G(^ROR(798.1,+REGIEN,0)),U,10)
"RTN","RORUTL02",249,0)
 Q +REGIEN("SE")
"RTN","RORUTL02",250,0)
 ;
"RTN","RORUTL02",251,0)
 ;***** RETURNS IEN OF THE SELECTION RULE
"RTN","RORUTL02",252,0)
 ;
"RTN","RORUTL02",253,0)
 ; RULENAME      Name of the selection rule
"RTN","RORUTL02",254,0)
 ; [FIELDS]      List of fields (separated by semicolons) to load
"RTN","RORUTL02",255,0)
 ; [.RORTRGT]    Reference to a local variable where field values will
"RTN","RORUTL02",256,0)
 ;               be stored by the FIND^DIC call.
"RTN","RORUTL02",257,0)
 ;
"RTN","RORUTL02",258,0)
 ; Return Values:
"RTN","RORUTL02",259,0)
 ;       <0  Error code
"RTN","RORUTL02",260,0)
 ;       >0  Selection rule IEN
"RTN","RORUTL02",261,0)
 ;
"RTN","RORUTL02",262,0)
SRLIEN(RULENAME,FIELDS,RORTRGT) ;
"RTN","RORUTL02",263,0)
 N RC,RULEIEN,RORMSG  K RORTRGT
"RTN","RORUTL02",264,0)
 D FIND^DIC(798.2,,"@;"_$G(FIELDS),"X",RULENAME,2,"B",,,"RORTRGT","RORMSG")
"RTN","RORUTL02",265,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.2)
"RTN","RORUTL02",266,0)
 S RC=+$G(RORTRGT("DILIST",0))
"RTN","RORUTL02",267,0)
 Q $S(RC<1:-3,RC>1:-4,1:+RORTRGT("DILIST",2,1))
"RTN","RORUTL03")
0^17^B21936813
"RTN","RORUTL03",1,0)
RORUTL03 ;HOIFO/CRT,SG - ENCRYPTION/DECRYPTION ; 7/21/03 12:55pm
"RTN","RORUTL03",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,5**;May 14, 2002
"RTN","RORUTL03",3,0)
 ;
"RTN","RORUTL03",4,0)
 Q
"RTN","RORUTL03",5,0)
 ;
"RTN","RORUTL03",6,0)
 ;***** DECRYPTS THE STRING
"RTN","RORUTL03",7,0)
DECRYPT(S) ;
"RTN","RORUTL03",8,0)
 N ASSOCIX,ASSOCSTR,IDIX,IDSTR
"RTN","RORUTL03",9,0)
 S ASSOCIX=$A($E(S,$L(S)))-31,IDIX=$A($E(S))-31
"RTN","RORUTL03",10,0)
 S ASSOCSTR=$P($T(Z+ASSOCIX),";;",2,99)
"RTN","RORUTL03",11,0)
 S IDSTR=$P($T(Z+IDIX),";;",2,99)
"RTN","RORUTL03",12,0)
 Q $TR($E(S,2,$L(S)-1),ASSOCSTR,IDSTR)
"RTN","RORUTL03",13,0)
 ;
"RTN","RORUTL03",14,0)
 ;***** ENCRYPTS THE STRING
"RTN","RORUTL03",15,0)
ENCRYPT(S) ;
"RTN","RORUTL03",16,0)
 N %,ASSOCIX,ASSOCSTR,IDIX,IDSTR
"RTN","RORUTL03",17,0)
 S ASSOCIX=$R(20)+1
"RTN","RORUTL03",18,0)
 F  S IDIX=$R(20)+1  Q:ASSOCIX'=IDIX
"RTN","RORUTL03",19,0)
 S ASSOCSTR=$P($T(Z+ASSOCIX),";;",2,99)
"RTN","RORUTL03",20,0)
 S IDSTR=$P($T(Z+IDIX),";;",2,99)
"RTN","RORUTL03",21,0)
 Q $C(IDIX+31)_$TR(S,IDSTR,ASSOCSTR)_$C(ASSOCIX+31)
"RTN","RORUTL03",22,0)
 ;
"RTN","RORUTL03",23,0)
 ;***** RETURN DEFAULT SITE FOR HL7 MESSAGES
"RTN","RORUTL03",24,0)
SITE(CS) ;
"RTN","RORUTL03",25,0)
 N RORSITE,RORSTN  S:$G(CS)="" CS="^"
"RTN","RORUTL03",26,0)
 S RORSITE=$$SITE^VASITE
"RTN","RORUTL03",27,0)
 I RORSITE<0  D  Q ""
"RTN","RORUTL03",28,0)
 . D ERROR^RORERR(-56,,,,RORSITE,"$$SITE^VASITE")
"RTN","RORUTL03",29,0)
 S RORSTN=$E($P(RORSITE,"^",3),1,3)
"RTN","RORUTL03",30,0)
 Q RORSTN_CS_$P(RORSITE,"^",2)_CS_"99VA4"
"RTN","RORUTL03",31,0)
 ;
"RTN","RORUTL03",32,0)
SITE1(CS) ;
"RTN","RORUTL03",33,0)
 N RORSITE,RORSTN  S:$G(CS)="" CS="^"
"RTN","RORUTL03",34,0)
 S RORSITE=$$SITE^VASITE
"RTN","RORUTL03",35,0)
 I RORSITE<0  D  Q ""
"RTN","RORUTL03",36,0)
 . D ERROR^RORERR(-56,,,,RORSITE,"$$SITE^VASITE")
"RTN","RORUTL03",37,0)
 S RORSTN=$E($P(RORSITE,"^",3),1,3)
"RTN","RORUTL03",38,0)
 Q $P(RORSITE,"^",2)_CS_"99VA4"_CS_RORSTN
"RTN","RORUTL03",39,0)
 ;
"RTN","RORUTL03",40,0)
 ;***** XOR ENCRYPTION (from ICR v2.1)
"RTN","RORUTL03",41,0)
XOR(X) ;
"RTN","RORUTL03",42,0)
 N I,SUFFIX
"RTN","RORUTL03",43,0)
 ;--- Separate digits and letters (the suffix)
"RTN","RORUTL03",44,0)
 I X'?1N.N  D  S SUFFIX=$E(X,I,99),X=$E(X,1,I-1)
"RTN","RORUTL03",45,0)
 . F I=1:1  Q:$E(X,I)'?1N
"RTN","RORUTL03",46,0)
 ;--- Convert the numeric part to hexadecimal
"RTN","RORUTL03",47,0)
 S X=$$CNV^XLFUTL(X,16)
"RTN","RORUTL03",48,0)
 ;--- Perform XOR of each hexadecimal digit with '1101' (0xD)
"RTN","RORUTL03",49,0)
 S X=$TR(X,"0123456789ABCDEF","DCFE98BA54761032")
"RTN","RORUTL03",50,0)
 ;--- Pad with 0xD from the left so that the value will contain
"RTN","RORUTL03",51,0)
 ;    no less that 9 hexadecimal digits, convert numeric part
"RTN","RORUTL03",52,0)
 ;--- back to decimal and append the suffix (if available)
"RTN","RORUTL03",53,0)
 Q $$DEC^XLFUTL($TR($J(X,9)," ","D"),16)_$G(SUFFIX)
"RTN","RORUTL03",54,0)
 ;
"RTN","RORUTL03",55,0)
 ;***** ENCODES THE SPECIAL CHARACTERS (&, <, ', and ")
"RTN","RORUTL03",56,0)
 ;
"RTN","RORUTL03",57,0)
 ; STR           Source string
"RTN","RORUTL03",58,0)
 ;
"RTN","RORUTL03",59,0)
XMLENC(STR) ;
"RTN","RORUTL03",60,0)
 N CH,I,IC
"RTN","RORUTL03",61,0)
 F I=1:1:5  S CH=$E("&<""'>",I),IC=1  D
"RTN","RORUTL03",62,0)
 . F  S IC=$F(STR,CH,IC)  Q:IC'>0  D
"RTN","RORUTL03",63,0)
 . . S $E(STR,IC-1,IC-1)=$P("&amp;^&lt;^&quot;^&apos;^&gt;","^",I)
"RTN","RORUTL03",64,0)
 Q STR
"RTN","RORUTL03",65,0)
 ;
"RTN","RORUTL03",66,0)
 ;***** ENCRYPTION/DECRYPTION TABLE
"RTN","RORUTL03",67,0)
Z ;;
"RTN","RORUTL03",68,0)
 ;;ko-ZJtdG)49K{nX1BS$vH<:Myf*>Ae0!jQW=;#PwsO`E'%+rmb[gpqN,l6/hFC@DcUa ]zR}"ViIxu?872.(TYL5_3
"RTN","RORUTL03",69,0)
 ;;`R;M/9BqAF%tSs#Vh)dO1DZP>r *fX'u[.4KlY=-mg_ci802N7LTG<]!CWo:3?{v+,5Q}(@jaExn$pIyHwzU"k6Jeb
"RTN","RORUTL03",70,0)
 ;;ZJk"WQmCn!Y,y@1d+8s?[lNMxgHE(t=uwX:qSLjAI*}6zoF{T3#;cap)/h5%`P4$r]G'9e2if_>UDKb7V<v0- RBO.
"RTN","RORUTL03",71,0)
 ;;dpjt3g4W)qD0VNJarseB "?OYhcu[<M%Z`RIL_6:]AX-zG.#}$@vk7/5x*m;(yb2Fn+l'PwUof1K{9,EQi>H=CT8S!
"RTN","RORUTL03",72,0)
 ;;:1}K$byP;jk)7'`x90Bcq@iSsEnu,(Nl-hf.Y_?J#R]+voQXZU8mrV[!p4tgOWMez CAaGFD6H53%L/dT2<*>"{wI=
"RTN","RORUTL03",73,0)
 ;;J<oZ9phXVNn)m K`t/SI%]A5qOWe?;jTM!fz1l>[D_0xR32ic*4.P"G{r7}E8wvUgyudF+6-:B=$(sCY,LkbHa#'@Q
"RTN","RORUTL03",74,0)
 ;;X,'4Ty;[a8/{6lF_V"}qLI!@x(D7bRmUHh]W15J%N0BYPkrs9:$)Zj>uvzwQ=ieC-oGA.#?tfdcOM3gp`S+En K2*<
"RTN","RORUTL03",75,0)
 ;;W5[];4'<C$/xrZ(k{>?ghBzIFN}fAK"#`p_T!qtD*1E37XGVs@0nmdjSe+Y6Qyo-aUu%i8c=H2vJ) R:MLb.9,wlOP
"RTN","RORUTL03",76,0)
 ;;tjEM+!=xXb)7,ZV{*ci3"8@_l-HS69L>2]AUF/Q%:qD?1m(yvO0e'hT<#o$p4dnIzKP`NrkaGg.ufCRB[; sJYwW}5
"RTN","RORUTL03",77,0)
 ;;/zl-9y:Pj=(R'7QJI *CTX"p0]_3.idcuOBefVU#omwNZ`$vFs?L+1Sk<5,b)hM4A6[Y%aDrg@KqEW8t>H};n!2xG{
"RTN","RORUTL03",78,0)
 ;;0Bo@_HfnK>LR}qWXV+D6`Y28=4CmsG/7-5Ab9!a#rPF.lM$hc3ijQk;),TvzUd<[:I"u1'NZSOw]*gxtE{eJpy (?%
"RTN","RORUTL03",79,0)
 ;;D}LJyGO8`$*ZqH .j>cMh<d=fimszv[#-53F!+a;NC'6T91IV?(0@x/{B)w"]QY,UWprk4:ol%g2nE7teRKbAPuS_X
"RTN","RORUTL03",80,0)
 ;;Y#_0*H<B=Q+FML6]s;r2:e8R}[icKA 1w{)vV5d,.$u"xD/Pg?IyfthO@CzjWp%!`N4Z'3-(oJ9XUE7kTlqSb>anGm
"RTN","RORUTL03",81,0)
 ;;1']_GU<X`NgM?LS9{"jT%s$}y[nvtlefB2RKJW(/cIxDCPow4,>#zm+:5b@06O3Ap8=V*7ZFY!H-uEQk;a .q)irhd
"RTN","RORUTL03",82,0)
 ;;z7AG@QX."%3Lq>METUo{Pp_ a6<0dYVSv8:bI)W9NK`(r'4fswimkRe]C2hg=HOj$1B*/nxt,;cJ#y+![?lFuZ-5D}
"RTN","RORUTL03",83,0)
 ;;Ge6F Hx>q$mC%MTn,:"o'tX/*yP.{lZ!YkiVhuw_<KE5aR[;}W0gjsz3]@7cI2QN?f#4pvbr1OUBD9)=-L(JA+d`S8
"RTN","RORUTL03",84,0)
 ;;>ym};d)-7DZ"Fe/Y<B:xwojR,Vh]O0Sc[`$sg8GXE!I1Qrzp._W%TNKk(=J 3i*2abuHA4C'?MvPq{n#56LftUl@9+
"RTN","RORUTL03",85,0)
 ;;)9 WidFN,1KsmwQ>GJM{I4:C%}#Ep(?HB/r;t.U8ol['Lg"2hRDyZ5`nbf]qjc0!zS-TkYO<_=76a*X@$Pe3+AxVvu
"RTN","RORUTL03",86,0)
 ;;jf"5VdHc#uA,W1i+v'6@pr{n;DJ!8(btPGaQM.LT3oeg?NB/9>Z`-}02*%x<7Ylsqz4OS E$R]KI[:UwC_=h)kXmyF
"RTN","RORUTL03",87,0)
 ;;ar.{YU7mBZR@-K2 "+`M%8sq4JhPo<_XSg3WC;Tuxz,fvEiQ1p9=w}FAIj/keD0c?)LN6OHV]lG:5y'$*>nd[(tb!#
"RTN","RORUTL05")
0^77^B55183638
"RTN","RORUTL05",1,0)
RORUTL05 ;HCIOFO/SG - MISCELLANEOUS UTILITIES ; 2/2/04 3:57pm
"RTN","RORUTL05",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3,5**;May 14, 2002
"RTN","RORUTL05",3,0)
 ;
"RTN","RORUTL05",4,0)
 ; This routine uses the following IAs:
"RTN","RORUTL05",5,0)
 ;
"RTN","RORUTL05",6,0)
 ; #???          Read the .01 field of the file #771.7
"RTN","RORUTL05",7,0)
 ; #10040        Access to the HOSPITAL LOCATION file (supported)
"RTN","RORUTL05",8,0)
 ; #10061        DEM^VADPT (supported)
"RTN","RORUTL05",9,0)
 ;
"RTN","RORUTL05",10,0)
 Q
"RTN","RORUTL05",11,0)
 ;
"RTN","RORUTL05",12,0)
 ;***** CHECKS IF THE E-MAIL NOTIFICATION IS ENABLED
"RTN","RORUTL05",13,0)
 ;
"RTN","RORUTL05",14,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL05",15,0)
 ;
"RTN","RORUTL05",16,0)
 ; Return Values:
"RTN","RORUTL05",17,0)
 ;        0  Do not send e-mail notifications
"RTN","RORUTL05",18,0)
 ;        1  E-mail notifications are enabled
"RTN","RORUTL05",19,0)
 ;
"RTN","RORUTL05",20,0)
CCRNTFY(REGIEN) ;
"RTN","RORUTL05",21,0)
 N DOMAIN,RC
"RTN","RORUTL05",22,0)
 ;--- Check the domain name
"RTN","RORUTL05",23,0)
 S DOMAIN=$G(^XMB("NETNAME"))
"RTN","RORUTL05",24,0)
 Q:DOMAIN'?1.E1".VA.GOV" 0
"RTN","RORUTL05",25,0)
 Q:(DOMAIN?1"TEST.".E)!(DOMAIN?1"TST.".E) 0
"RTN","RORUTL05",26,0)
 ;--- Registry-specific checks
"RTN","RORUTL05",27,0)
 I $G(REGIEN)>0  S RC=1  D  Q:'RC 0
"RTN","RORUTL05",28,0)
 . N HL,HLECH,HLFS,HLQ,NAME,RORMSG
"RTN","RORUTL05",29,0)
 . ;--- Get the HL7 protocol name
"RTN","RORUTL05",30,0)
 . S NAME=$$GET1^DIQ(798.1,+REGIEN,13,,,"RORMSG")  Q:NAME=""
"RTN","RORUTL05",31,0)
 . ;--- Check the HL7 processing ID
"RTN","RORUTL05",32,0)
 . D INIT^HLFNC2(NAME,.HL)
"RTN","RORUTL05",33,0)
 . I $G(HL("PID"))'="",HL("PID")'="P"  S RC=0  Q
"RTN","RORUTL05",34,0)
 ;--- Notification is enabled (production account)
"RTN","RORUTL05",35,0)
 Q 1
"RTN","RORUTL05",36,0)
 ;
"RTN","RORUTL05",37,0)
 ;***** CHECK IF THE PATIENT'S RECORD IN FILE #2 IS VALID
"RTN","RORUTL05",38,0)
 ;
"RTN","RORUTL05",39,0)
 ; DFN           Patient IEN (in file #2)
"RTN","RORUTL05",40,0)
 ;
"RTN","RORUTL05",41,0)
 ; Return Values:
"RTN","RORUTL05",42,0)
 ;       <0  Error code
"RTN","RORUTL05",43,0)
 ;        0  Ok
"RTN","RORUTL05",44,0)
 ;
"RTN","RORUTL05",45,0)
CHKPTR(DFN,SILENT) ;
"RTN","RORUTL05",46,0)
 N RC,VA,VADM,VAERR
"RTN","RORUTL05",47,0)
 D VADEM(DFN)
"RTN","RORUTL05",48,0)
 I $G(VADM(1))=""  S RC=-102  D:'$G(SILENT)  Q RC
"RTN","RORUTL05",49,0)
 . D ERROR^RORERR(RC,,,,"PATIENT",DFN)
"RTN","RORUTL05",50,0)
 Q 0
"RTN","RORUTL05",51,0)
 ;
"RTN","RORUTL05",52,0)
 ;***** DELETES ALL RECORDS FROM THE (SUB)FILE
"RTN","RORUTL05",53,0)
 ;
"RTN","RORUTL05",54,0)
 ; FILE          File/Subfile number
"RTN","RORUTL05",55,0)
 ; [IENS]        IENS of the subfile
"RTN","RORUTL05",56,0)
 ;
"RTN","RORUTL05",57,0)
 ; Return Values:
"RTN","RORUTL05",58,0)
 ;       <0  Error code
"RTN","RORUTL05",59,0)
 ;        0  Ok
"RTN","RORUTL05",60,0)
 ;
"RTN","RORUTL05",61,0)
CLEAR(FILE,IENS) ;
"RTN","RORUTL05",62,0)
 Q:'$$VFILE^DILFD(FILE) 0
"RTN","RORUTL05",63,0)
 N DA,DIK,RC,ROOT,TMP
"RTN","RORUTL05",64,0)
 S IENS=$G(IENS)
"RTN","RORUTL05",65,0)
 ;--- Lock the (sub)file
"RTN","RORUTL05",66,0)
 S RC=$$LOCK^RORLOCK(FILE,IENS)
"RTN","RORUTL05",67,0)
 I RC  D  Q RC
"RTN","RORUTL05",68,0)
 . S TMP=$$GET1^DID(FILE,,,"NAME",,"RORMSG")
"RTN","RORUTL05",69,0)
 . S TMP=$S(TMP'="":"file",1:"subfile")_" #"_FILE
"RTN","RORUTL05",70,0)
 . S:IENS'="" TMP=TMP_"; IENS: '"_IENS_"'"
"RTN","RORUTL05",71,0)
 . S RC=$$ERROR^RORERR(-11,,"By "_$$TEXT^RORLOCK(RC),,TMP)
"RTN","RORUTL05",72,0)
 ;
"RTN","RORUTL05",73,0)
 ;--- Delete the records
"RTN","RORUTL05",74,0)
 S DIK=$$ROOT^DILFD(FILE,IENS)
"RTN","RORUTL05",75,0)
 S ROOT=$$CREF^DILF(DIK)
"RTN","RORUTL05",76,0)
 D DA^DILF(IENS,.DA)  S DA=0
"RTN","RORUTL05",77,0)
 F  S DA=$O(@ROOT@(DA))  Q:DA'>0  D ^DIK
"RTN","RORUTL05",78,0)
 ;
"RTN","RORUTL05",79,0)
 ;--- Unlock the (sub)file
"RTN","RORUTL05",80,0)
 D UNLOCK^RORLOCK(FILE,IENS)
"RTN","RORUTL05",81,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL05",82,0)
 ;
"RTN","RORUTL05",83,0)
 ;***** CLEARS THE FIELDS OF THE RECORDS FOUND BY NAME
"RTN","RORUTL05",84,0)
 ;
"RTN","RORUTL05",85,0)
 ; FILE          File number
"RTN","RORUTL05",86,0)
 ; [IENS]        IENS of the subfile
"RTN","RORUTL05",87,0)
 ; NAME          Name of the record (value of the .01 field)
"RTN","RORUTL05",88,0)
 ; FIELDS        List of field numbers separated by semicolons
"RTN","RORUTL05",89,0)
 ;
"RTN","RORUTL05",90,0)
 ; Return Values:
"RTN","RORUTL05",91,0)
 ;       <0  Error code
"RTN","RORUTL05",92,0)
 ;        0  Ok
"RTN","RORUTL05",93,0)
 ;
"RTN","RORUTL05",94,0)
CLRFLDS(FILE,IENS,NAME,FIELDS) ;
"RTN","RORUTL05",95,0)
 N FLD,I,IEN,IENS1,IS,RC,RORBUF,RORFDA,RORMSG
"RTN","RORUTL05",96,0)
 ;--- Find the record(s)
"RTN","RORUTL05",97,0)
 D FIND^DIC(FILE,$G(IENS),"@","X",NAME,,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL05",98,0)
 S RC=$$DBS^RORERR("RORMSG",-9,,,FILE)  Q:RC<0 RC
"RTN","RORUTL05",99,0)
 S:$G(IENS)="" IENS=","  S FIELDS=$TR(FIELDS," ")
"RTN","RORUTL05",100,0)
 ;--- Update the record(s)
"RTN","RORUTL05",101,0)
 S IS="",RC=0
"RTN","RORUTL05",102,0)
 F  S IS=$O(RORBUF("DILIST",2,IS))  Q:IS=""  D  Q:RC<0
"RTN","RORUTL05",103,0)
 . S IEN=RORBUF("DILIST",2,IS)  Q:IEN'>0
"RTN","RORUTL05",104,0)
 . S IENS1=IEN_IENS
"RTN","RORUTL05",105,0)
 . F I=1:1  S FLD=$P(FIELDS,";",I)  Q:FLD'>0  D
"RTN","RORUTL05",106,0)
 . . S RORFDA(FILE,IENS1,+FLD)="@"
"RTN","RORUTL05",107,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL05",108,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,FILE,IENS1)
"RTN","RORUTL05",109,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL05",110,0)
 ;
"RTN","RORUTL05",111,0)
 ;***** RETURNS THE END DATE FOR THE EVENT PURGE
"RTN","RORUTL05",112,0)
EPDATE() ;
"RTN","RORUTL05",113,0)
 N DATE,IR,RC,RORBUF,RORMSG,TMP
"RTN","RORUTL05",114,0)
 D LIST^DIC(798.1,,"@;1I;2I","U",,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL05",115,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.1)
"RTN","RORUTL05",116,0)
 ;--- Get the oldest date of registry updates
"RTN","RORUTL05",117,0)
 S IR="",DATE=$$DT^XLFDT
"RTN","RORUTL05",118,0)
 F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D
"RTN","RORUTL05",119,0)
 . S TMP=$G(RORBUF("DILIST","ID",IR,1)) ; REGISTRY UPDATED UNTIL
"RTN","RORUTL05",120,0)
 . I TMP>0  S:TMP<DATE DATE=TMP
"RTN","RORUTL05",121,0)
 . ;S TMP=$G(RORBUF("DILIST","ID",IR,2)) ; DATA EXTRACTED UNTIL
"RTN","RORUTL05",122,0)
 . ;I TMP>0  S:TMP<DATE DATE=TMP
"RTN","RORUTL05",123,0)
 ;--- Subtract additional 14 days (just in case)
"RTN","RORUTL05",124,0)
 S DATE=$$FMADD^XLFDT(DATE\1,-14)
"RTN","RORUTL05",125,0)
 ;--- No more than 60 days in the past
"RTN","RORUTL05",126,0)
 S TMP=$$FMADD^XLFDT($$DT^XLFDT,-60)
"RTN","RORUTL05",127,0)
 Q $S(DATE>TMP:DATE,1:TMP)
"RTN","RORUTL05",128,0)
 ;
"RTN","RORUTL05",129,0)
 ;***** RETURNS NAME OF THE HOSPITAL LOCATION
"RTN","RORUTL05",130,0)
 ;
"RTN","RORUTL05",131,0)
 ; HLIEN         IEN of the hospital location
"RTN","RORUTL05",132,0)
 ;
"RTN","RORUTL05",133,0)
HLNAME(HLIEN) ;
"RTN","RORUTL05",134,0)
 N NAME
"RTN","RORUTL05",135,0)
 S NAME=$$GET1^DIQ(44,(+HLIEN)_",",.01,,,"RORMSG")
"RTN","RORUTL05",136,0)
 D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,44,(+HLIEN)_",")
"RTN","RORUTL05",137,0)
 Q NAME
"RTN","RORUTL05",138,0)
 ;
"RTN","RORUTL05",139,0)
 ;***** FORMATS THE TEXT THAT DESCRIBES STATUS OF THE HL7 MESSAGE
"RTN","RORUTL05",140,0)
 ;
"RTN","RORUTL05",141,0)
 ; MSGID         A valid ID of the HL7 message
"RTN","RORUTL05",142,0)
 ;
"RTN","RORUTL05",143,0)
 ; .RORDST       Reference to a local array that the text
"RTN","RORUTL05",144,0)
 ;               is appended to
"RTN","RORUTL05",145,0)
 ;
"RTN","RORUTL05",146,0)
 ; [TITLE]       Title of the output
"RTN","RORUTL05",147,0)
 ;
"RTN","RORUTL05",148,0)
 ; [DLGNUM]      Number of an entry in the DIALOG file that
"RTN","RORUTL05",149,0)
 ;               contains the text template (by default,
"RTN","RORUTL05",150,0)
 ;               the 7980000.004 is used)
"RTN","RORUTL05",151,0)
 ;
"RTN","RORUTL05",152,0)
 ; [.PARAMS]     Reference to a local variable containing
"RTN","RORUTL05",153,0)
 ;               additional parameters that substitute the
"RTN","RORUTL05",154,0)
 ;               placeholders in the text template
"RTN","RORUTL05",155,0)
 ; PARAMS(
"RTN","RORUTL05",156,0)
 ;  "NOR")       Number of retries to resend the message
"RTN","RORUTL05",157,0)
 ;  "REGISTRY")  Name of the registry
"RTN","RORUTL05",158,0)
 ;
"RTN","RORUTL05",159,0)
 ; [MSGSTAT]     Status of the message (result value of the
"RTN","RORUTL05",160,0)
 ;               $$MSGSTAT^HLUTIL function). If this parameter
"RTN","RORUTL05",161,0)
 ;               is undefined or equal to an empty string, the
"RTN","RORUTL05",162,0)
 ;               current status of the message is retrieved.
"RTN","RORUTL05",163,0)
 ;
"RTN","RORUTL05",164,0)
MSG7STS(MSGID,RORDST,TITLE,DLGNUM,PARAMS,MSGSTAT) ;
"RTN","RORUTL05",165,0)
 N RORMSG,TMP
"RTN","RORUTL05",166,0)
 Q:$G(MSGID)?." "
"RTN","RORUTL05",167,0)
 S:$G(MSGSTAT)="" MSGSTAT=$$MSGSTAT^HLUTIL(MSGID)
"RTN","RORUTL05",168,0)
 ;--- Prepare the parameters
"RTN","RORUTL05",169,0)
 S PARAMS("ID")=MSGID
"RTN","RORUTL05",170,0)
 S PARAMS("STATUS")=$$MSGSTXT^RORHL7(MSGSTAT)
"RTN","RORUTL05",171,0)
 S TMP=+$P(MSGSTAT,U,2)
"RTN","RORUTL05",172,0)
 S:TMP>0 PARAMS("UPDATED")=$$FMTE^XLFDT(TMP)
"RTN","RORUTL05",173,0)
 S PARAMS("ERRMSG")=$P(MSGSTAT,U,3)
"RTN","RORUTL05",174,0)
 S TMP=+$P(MSGSTAT,U,4)
"RTN","RORUTL05",175,0)
 S:TMP>0 PARAMS("ERRTYPE")=$$GET1^DIQ(771.7,TMP_",",.01,,,"RORMSG")
"RTN","RORUTL05",176,0)
 S PARAMS($S(+MSGSTAT=1:"QPOS",1:"RETRIES"))=$P(MSGSTAT,U,5)
"RTN","RORUTL05",177,0)
 S PARAMS("OPENFAIL")=$P(MSGSTAT,U,6)
"RTN","RORUTL05",178,0)
 S PARAMS("ACK")=$P(MSGSTAT,U,7)
"RTN","RORUTL05",179,0)
 ;--- Additional parameters
"RTN","RORUTL05",180,0)
 I $G(DLGNUM)>0  D
"RTN","RORUTL05",181,0)
 . S PARAMS("STATCODE")=+MSGSTAT
"RTN","RORUTL05",182,0)
 . S TMP=+$P(MSGSTAT,U,2)
"RTN","RORUTL05",183,0)
 . S:TMP>0 PARAMS("STATUPD")=$$FMTHL7^XLFDT(TMP)
"RTN","RORUTL05",184,0)
 . S TMP=$$SITE^RORUTL03()
"RTN","RORUTL05",185,0)
 . S PARAMS("STNAME")=$P(TMP,U,2)
"RTN","RORUTL05",186,0)
 . S PARAMS("STNUM")=$P(TMP,U)
"RTN","RORUTL05",187,0)
 . S:$G(PARAMS("NOR"))'>0 PARAMS("NOR")="several"
"RTN","RORUTL05",188,0)
 . S:$G(PARAMS("REGISTRY"))="" PARAMS("REGISTRY")="<unknown>"
"RTN","RORUTL05",189,0)
 E  S DLGNUM=7980000.004
"RTN","RORUTL05",190,0)
 ;--- Build the text
"RTN","RORUTL05",191,0)
 S:$G(TITLE)'="" RORDST(1)=TITLE,RORDST(2)=" "
"RTN","RORUTL05",192,0)
 D BLD^DIALOG(DLGNUM,.PARAMS,,"RORDST","S")
"RTN","RORUTL05",193,0)
 Q
"RTN","RORUTL05",194,0)
 ;
"RTN","RORUTL05",195,0)
 ;***** CHECK IF THE VALUE STARTS FROM A NUMBER
"RTN","RORUTL05",196,0)
 ;
"RTN","RORUTL05",197,0)
 ; Return Values:
"RTN","RORUTL05",198,0)
 ;        1  Value starts from a number
"RTN","RORUTL05",199,0)
 ;        0  Otherwise
"RTN","RORUTL05",200,0)
 ;
"RTN","RORUTL05",201,0)
NUMERIC(VAL) ;
"RTN","RORUTL05",202,0)
 Q (VAL?.1(1"+",1"-")1(1.N.1".".N,.N.1"."1.N).E)
"RTN","RORUTL05",203,0)
 ;
"RTN","RORUTL05",204,0)
 ;***** MARKS THE REGISTRY RECORDS FOR RESENDING THE LOCAL DATA
"RTN","RORUTL05",205,0)
 ;
"RTN","RORUTL05",206,0)
 ; .REGLST       Reference to a local array containing registry names 
"RTN","RORUTL05",207,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUTL05",208,0)
 ; WD            Number of days to wait before marking the records
"RTN","RORUTL05",209,0)
 ;               for resending the local registry data
"RTN","RORUTL05",210,0)
 ;
"RTN","RORUTL05",211,0)
 ; Return Values:
"RTN","RORUTL05",212,0)
 ;       <0  Error code
"RTN","RORUTL05",213,0)
 ;        0  Ok
"RTN","RORUTL05",214,0)
 ;
"RTN","RORUTL05",215,0)
REMARK(REGLST,WD) ;
"RTN","RORUTL05",216,0)
 N DATE,IEN,IENS,REGIEN,REGNAME,ROOT,RORFDA,RORMSG,TMP
"RTN","RORUTL05",217,0)
 S ROOT=$$ROOT^DILFD(798,,1)
"RTN","RORUTL05",218,0)
 S DATE=$$FMADD^XLFDT($$DT^XLFDT,-WD)
"RTN","RORUTL05",219,0)
 ;--- Process the registries from the list
"RTN","RORUTL05",220,0)
 S REGNAME=""
"RTN","RORUTL05",221,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D
"RTN","RORUTL05",222,0)
 . S REGIEN=+REGLST(REGNAME)
"RTN","RORUTL05",223,0)
 . I REGIEN'>0  S REGIEN=$$REGIEN^RORUTL02(REGNAME)  Q:REGIEN'>0
"RTN","RORUTL05",224,0)
 . S IENS=REGIEN_","
"RTN","RORUTL05",225,0)
 . ;--- Get the registry parameters
"RTN","RORUTL05",226,0)
 . D GETS^DIQ(798.1,IENS,"21.04;21.05","I","RORFDA","RORMSG")
"RTN","RORUTL05",227,0)
 . I $G(DIERR)  S TMP=$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)  Q
"RTN","RORUTL05",228,0)
 . ;--- Local data has been resent already
"RTN","RORUTL05",229,0)
 . Q:$G(RORFDA(798.1,IENS,21.04,"I"))
"RTN","RORUTL05",230,0)
 . ;--- The registry has not been populated yet
"RTN","RORUTL05",231,0)
 . Q:'$G(RORFDA(798.1,IENS,21.05,"I"))
"RTN","RORUTL05",232,0)
 . ;--- It is too early for resending the local data
"RTN","RORUTL05",233,0)
 . Q:RORFDA(798.1,IENS,21.05,"I")>DATE
"RTN","RORUTL05",234,0)
 . K RORFDA,RORMSG
"RTN","RORUTL05",235,0)
 . ;--- Mark registry records as modified
"RTN","RORUTL05",236,0)
 . S (IEN,RC)=0
"RTN","RORUTL05",237,0)
 . F  S IEN=$O(@ROOT@("AC",REGIEN,IEN))  Q:'IEN  D  Q:RC<0
"RTN","RORUTL05",238,0)
 . . S IENS=IEN_","
"RTN","RORUTL05",239,0)
 . . S RORFDA(798,IENS,4)=1  ; UPDATE DEMOGRAPHICS
"RTN","RORUTL05",240,0)
 . . S RORFDA(798,IENS,5)=1  ; UPDATE LOCAL REGISTRY DATA
"RTN","RORUTL05",241,0)
 . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL05",242,0)
 . . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,798,IENS)  Q
"RTN","RORUTL05",243,0)
 . Q:RC<0
"RTN","RORUTL05",244,0)
 . ;--- Update registry parameters
"RTN","RORUTL05",245,0)
 . S IENS=REGIEN_","
"RTN","RORUTL05",246,0)
 . S RORFDA(798.1,IENS,21.04)=$$NOW^XLFDT
"RTN","RORUTL05",247,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUTL05",248,0)
 . I $G(DIERR)  S TMP=$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)  Q
"RTN","RORUTL05",249,0)
 . ;--- Record the message
"RTN","RORUTL05",250,0)
 . S TMP="Local registry and demographic data will be resent to AAC"
"RTN","RORUTL05",251,0)
 . D LOG^RORLOG(2,TMP,,"Registry Name: "_REGNAME)
"RTN","RORUTL05",252,0)
 Q 0
"RTN","RORUTL05",253,0)
 ;
"RTN","RORUTL05",254,0)
 ;***** CALLS THE DEM^VADPT
"RTN","RORUTL05",255,0)
 ;
"RTN","RORUTL05",256,0)
 ; DFN           Patient IEN (in file #2)
"RTN","RORUTL05",257,0)
 ; VALIDATE      Make sure that required fields are not empty
"RTN","RORUTL05",258,0)
 ; VAPTYP
"RTN","RORUTL05",259,0)
 ; VAHOW
"RTN","RORUTL05",260,0)
 ;
"RTN","RORUTL05",261,0)
VADEM(DFN,VALIDATE,VAPTYP,VAHOW) ;
"RTN","RORUTL05",262,0)
 N I,J,X,A,K,K1,NC,NF,NQ,T,VAROOT
"RTN","RORUTL05",263,0)
 D DEM^VADPT
"RTN","RORUTL05",264,0)
 Q:'$G(VALIDATE)
"RTN","RORUTL05",265,0)
 ;--- Make sure that required fields are not empty
"RTN","RORUTL05",266,0)
 S:$G(VADM(1))="" VADM(1)="Unknown ("_DFN_")"
"RTN","RORUTL05",267,0)
 S:$G(VA("BID"))="" VA("BID")="UNKN"
"RTN","RORUTL05",268,0)
 Q
"RTN","RORUTL06")
0^108^B61311339
"RTN","RORUTL06",1,0)
RORUTL06 ;HCIOFO/SG - DEVELOPER ENTRY POINTS ; 10/2/03 8:08am
"RTN","RORUTL06",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUTL06",3,0)
 ;
"RTN","RORUTL06",4,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,X,Y
"RTN","RORUTL06",5,0)
 W !,"CLINICAL CASE REGISTRIES DEVELOPER'S UTILITIES"
"RTN","RORUTL06",6,0)
 S X=""
"RTN","RORUTL06",7,0)
 S X=X_";M:Metadata definitions"
"RTN","RORUTL06",8,0)
 S X=X_";V:Verify registry definition"
"RTN","RORUTL06",9,0)
 S X=X_";P:Prepare for KIDS"
"RTN","RORUTL06",10,0)
 S DIR(0)="SO^"_$P(X,";",2,999)
"RTN","RORUTL06",11,0)
 D ^DIR  W !  Q:$D(DIRUT)
"RTN","RORUTL06",12,0)
 G PRTMDE:Y="M",VERIFY:Y="V",DISTPREP:Y="P"
"RTN","RORUTL06",13,0)
 Q
"RTN","RORUTL06",14,0)
 ;
"RTN","RORUTL06",15,0)
 ;***** VERIFIES REGISTRY DEFINITION
"RTN","RORUTL06",16,0)
VERIFY ;
"RTN","RORUTL06",17,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL06",18,0)
 N RORERROR      ; Error processing data
"RTN","RORUTL06",19,0)
 N RORPARM       ; Application parameters
"RTN","RORUTL06",20,0)
 ;
"RTN","RORUTL06",21,0)
 N RC,REGLST,REGNAME
"RTN","RORUTL06",22,0)
 W !,"REGISTRY DEFINITION VERIFIER",!
"RTN","RORUTL06",23,0)
 D KILL^XUSCLEAN,INIT^RORUTL01("ROR")
"RTN","RORUTL06",24,0)
 S RORPARM("DEBUG")=2
"RTN","RORUTL06",25,0)
 S RORPARM("ERR")=1
"RTN","RORUTL06",26,0)
 D CLEAR^RORERR("START^RORUTL06")
"RTN","RORUTL06",27,0)
 ;--- Select a registry
"RTN","RORUTL06",28,0)
 S RC=$$SELREG^RORHDTUT(.REGNAME)  G:RC<0 ERROR
"RTN","RORUTL06",29,0)
 Q:RC'>0  S REGLST(REGNAME)=""
"RTN","RORUTL06",30,0)
 ;--- Validate registry update defintion
"RTN","RORUTL06",31,0)
 S RC=$$UPDDEF(.REGLST)            G:RC<0 ERROR
"RTN","RORUTL06",32,0)
 ;--- Validate data extraction defintion
"RTN","RORUTL06",33,0)
 S RC=$$EXTDEF(REGNAME)            G:RC<0 ERROR
"RTN","RORUTL06",34,0)
 ;--- Cleanup
"RTN","RORUTL06",35,0)
 D INIT^RORUTL01("ROR")
"RTN","RORUTL06",36,0)
 Q
"RTN","RORUTL06",37,0)
 ;
"RTN","RORUTL06",38,0)
 ;***** PREPARES THE REGISTRY FOR KIDS DISTRIBUTION
"RTN","RORUTL06",39,0)
DISTPREP ;
"RTN","RORUTL06",40,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL06",41,0)
 N RORERROR      ; Error processing data
"RTN","RORUTL06",42,0)
 N RORPARM       ; Application parameters
"RTN","RORUTL06",43,0)
 ;
"RTN","RORUTL06",44,0)
 N IENS,FLD,RC,REGIEN,REGNAME,RORFDA,RORMSG
"RTN","RORUTL06",45,0)
 N DA,DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","RORUTL06",46,0)
 W !,"REGISTRY PREPARATION FOR KIDS DISTRIBUTION",!
"RTN","RORUTL06",47,0)
 D KILL^XUSCLEAN
"RTN","RORUTL06",48,0)
 S RORPARM("ERR")=1
"RTN","RORUTL06",49,0)
 D CLEAR^RORERR("DISTPREP^RORUTL06")
"RTN","RORUTL06",50,0)
 ;--- Select a registry
"RTN","RORUTL06",51,0)
 S RC=$$SELREG^RORHDTUT(.REGNAME)  G:RC<0 ERROR
"RTN","RORUTL06",52,0)
 Q:RC'>0  S REGIEN=RC
"RTN","RORUTL06",53,0)
 ;--- Request a confirmation
"RTN","RORUTL06",54,0)
 S DIR(0)="Y",DIR("B")="NO"
"RTN","RORUTL06",55,0)
 S DIR("A",1)="Some fields of the '"_REGNAME_"' registry parameters"
"RTN","RORUTL06",56,0)
 S DIR("A",2)="will be cleared to prepare them for KIDS distribution."
"RTN","RORUTL06",57,0)
 S DIR("A")="Do you really want to do this"
"RTN","RORUTL06",58,0)
 D ^DIR  Q:'$G(Y)
"RTN","RORUTL06",59,0)
 ;--- Clear Registry parameters (single-valued)
"RTN","RORUTL06",60,0)
 S IENS=REGIEN_","
"RTN","RORUTL06",61,0)
 F FLD=2.1,2.2,2.3,2.4,2.5,19.1,19.2,21.02,21.03,21.04,21.05  D
"RTN","RORUTL06",62,0)
 . S RORFDA(798.1,IENS,FLD)="@"
"RTN","RORUTL06",63,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL06",64,0)
 G:$$DBS^RORERR("RORMSG",-9,,,798.1,IENS) ERROR
"RTN","RORUTL06",65,0)
 ;--- Clear Registry parameters (multiples)
"RTN","RORUTL06",66,0)
 S IENS=","_REGIEN_","
"RTN","RORUTL06",67,0)
 G:$$CLEAR^RORUTL05(798.114,IENS)<0 ERROR  ; COORDINATOR (14)
"RTN","RORUTL06",68,0)
 G:$$CLEAR^RORUTL05(798.116,IENS)<0 ERROR  ; USER (16)
"RTN","RORUTL06",69,0)
 G:$$CLEAR^RORUTL05(798.128,IENS)<0 ERROR  ; LOCAL LAB TEST (28)
"RTN","RORUTL06",70,0)
 G:$$CLEAR^RORUTL05(798.129,IENS)<0 ERROR  ; LOCAL DRUG (29)
"RTN","RORUTL06",71,0)
 ;--- Registry-specific data
"RTN","RORUTL06",72,0)
 I REGNAME="VA HEPC"  G:$$HEPC(REGIEN)<0 ERROR
"RTN","RORUTL06",73,0)
 I REGNAME="VA ICR"   G:$$ICR(REGIEN)<0 ERROR
"RTN","RORUTL06",74,0)
 ;--- Success
"RTN","RORUTL06",75,0)
 W !,"Registry parameters are ready for distribution."
"RTN","RORUTL06",76,0)
 Q
"RTN","RORUTL06",77,0)
 ;
"RTN","RORUTL06",78,0)
 ;***** DISPLAYS THE ERRORS
"RTN","RORUTL06",79,0)
ERROR ;
"RTN","RORUTL06",80,0)
 D DSPSTK^RORERR()
"RTN","RORUTL06",81,0)
 Q
"RTN","RORUTL06",82,0)
 ;
"RTN","RORUTL06",83,0)
 ;***** VALIDATES DATA EXTRACTION DEFINITION
"RTN","RORUTL06",84,0)
 ;
"RTN","RORUTL06",85,0)
 ; REGNAME       Registry name
"RTN","RORUTL06",86,0)
 ;
"RTN","RORUTL06",87,0)
 ; Return Values:
"RTN","RORUTL06",88,0)
 ;       <0  Error Code
"RTN","RORUTL06",89,0)
 ;        0  Ok
"RTN","RORUTL06",90,0)
 ;
"RTN","RORUTL06",91,0)
EXTDEF(REGNAME) ;
"RTN","RORUTL06",92,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL06",93,0)
 N ROREXT        ; Data extraction descriptor
"RTN","RORUTL06",94,0)
 N RORHL         ; HL7 variables
"RTN","RORUTL06",95,0)
 N RORLRC        ; List of codes of Lab results to be extracted
"RTN","RORUTL06",96,0)
 ;
"RTN","RORUTL06",97,0)
 N RC
"RTN","RORUTL06",98,0)
 W !,"DATA EXTRACTION DEFINITION",!
"RTN","RORUTL06",99,0)
 D CLEAR^RORERR("UPDDEF^RORUTL06")
"RTN","RORUTL06",100,0)
 S RC=$$PREPARE^ROREXPR(REGNAME)
"RTN","RORUTL06",101,0)
 D:RC'<0 DEBUG1^ROREXT
"RTN","RORUTL06",102,0)
 Q RC
"RTN","RORUTL06",103,0)
 ;
"RTN","RORUTL06",104,0)
 ;***** HEPC-SPECIFIC PREPARATIONS
"RTN","RORUTL06",105,0)
HEPC(REGIEN) ;
"RTN","RORUTL06",106,0)
 N IENS,RORFDA,RORMSG
"RTN","RORUTL06",107,0)
 S IENS=(+REGIEN)_","
"RTN","RORUTL06",108,0)
 S RORFDA(798.1,IENS,1)=2900101  ; REGISTRY UPDATED UNTIL
"RTN","RORUTL06",109,0)
 S RORFDA(798.1,IENS,2)=2900101  ; DATA EXTRACTED UNTIL
"RTN","RORUTL06",110,0)
 S RORFDA(798.1,IENS,25)=1       ; ENABLE PROTOCOLS
"RTN","RORUTL06",111,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL06",112,0)
 Q $$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","RORUTL06",113,0)
 ;
"RTN","RORUTL06",114,0)
 ;***** ICR-SPECIFIC PREPARATIONS
"RTN","RORUTL06",115,0)
ICR(REGIEN) ;
"RTN","RORUTL06",116,0)
 N IENS,RORFDA,RORMSG
"RTN","RORUTL06",117,0)
 S IENS=(+REGIEN)_","
"RTN","RORUTL06",118,0)
 S RORFDA(798.1,IENS,1)=2850101  ; REGISTRY UPDATED UNTIL
"RTN","RORUTL06",119,0)
 S RORFDA(798.1,IENS,2)=2850101  ; DATA EXTRACTED UNTIL
"RTN","RORUTL06",120,0)
 S RORFDA(798.1,IENS,25)=1       ; ENABLE PROTOCOLS
"RTN","RORUTL06",121,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL06",122,0)
 Q $$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","RORUTL06",123,0)
 ;
"RTN","RORUTL06",124,0)
 ;***** PRINTS THE DATA ELEMENT METADATA
"RTN","RORUTL06",125,0)
PRTMDE ;
"RTN","RORUTL06",126,0)
 N RORCOLS       ; Lits of column descriptors
"RTN","RORUTL06",127,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL06",128,0)
 N RORERROR      ; Error processing data
"RTN","RORUTL06",129,0)
 N RORLST        ; List of files grouped by parents
"RTN","RORUTL06",130,0)
 N RORPAGE       ; Current page number
"RTN","RORUTL06",131,0)
 N RORPARM       ; Application parameters
"RTN","RORUTL06",132,0)
 N RORTTL        ; Title of the report
"RTN","RORUTL06",133,0)
 ;
"RTN","RORUTL06",134,0)
 N DIR,DIRUT,DTOUT,DUOUT,MODE,TMP,X,Y
"RTN","RORUTL06",135,0)
 D KILL^XUSCLEAN
"RTN","RORUTL06",136,0)
 S (DDBDMSG,RORTTL)="METADATA OF THE DATA ELEMENTS"
"RTN","RORUTL06",137,0)
 W !,RORTTL,!  S RORPARM("ERR")=1
"RTN","RORUTL06",138,0)
 D CLEAR^RORERR("PRTMDE^RORUTL06")
"RTN","RORUTL06",139,0)
 ;---Request report sort mode from user
"RTN","RORUTL06",140,0)
 S DIR(0)="S^H:Hierarhical;L:List of codes"
"RTN","RORUTL06",141,0)
 S DIR("A")="Sort mode",DIR("B")="List of codes"
"RTN","RORUTL06",142,0)
 D ^DIR  Q:$D(DIRUT)  S MODE=Y
"RTN","RORUTL06",143,0)
 ;--- Generate and print the report
"RTN","RORUTL06",144,0)
 I MODE="H"  S RC=0  D
"RTN","RORUTL06",145,0)
 . N %ZIS,I,FILE,PARENT,ROOT,RORMSG
"RTN","RORUTL06",146,0)
 . S ROOT=$$ROOT^DILFD(799.2,,1),RORPAGE=0
"RTN","RORUTL06",147,0)
 . ;--- Load column descriptors
"RTN","RORUTL06",148,0)
 . F I=1:1  S TMP=$P($T(PRTMDEH+I),";;",2)  Q:TMP=""  D
"RTN","RORUTL06",149,0)
 . . S RORCOLS(I)=$TR($P(TMP,U,1,3)," ")_U_$P(TMP,U,4)
"RTN","RORUTL06",150,0)
 . ;--- Load file list
"RTN","RORUTL06",151,0)
 . S FILE=0,RC=0
"RTN","RORUTL06",152,0)
 . F  S FILE=$O(@ROOT@(FILE))  Q:FILE'>0  D  Q:RC<0
"RTN","RORUTL06",153,0)
 . . S PARENT=+$$GET1^DIQ(799.2,FILE_",",1,"I",,"RORMSG")
"RTN","RORUTL06",154,0)
 . . I $G(DIERR)  D  Q
"RTN","RORUTL06",155,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,,,799.2,FILE_",")
"RTN","RORUTL06",156,0)
 . . S RORLST(PARENT,FILE)=""
"RTN","RORUTL06",157,0)
 . Q:RC<0
"RTN","RORUTL06",158,0)
 . ;--- Print the report
"RTN","RORUTL06",159,0)
 . S %ZIS("B")=""
"RTN","RORUTL06",160,0)
 . D ^%ZIS   Q:$G(POP)  U IO
"RTN","RORUTL06",161,0)
 . S RC=$$PRTMDEH()  S:RC'<0 RC=$$PRTMDE1(0,1)
"RTN","RORUTL06",162,0)
 . D ^%ZISC
"RTN","RORUTL06",163,0)
 E  S RC=$$PRTMDE2()
"RTN","RORUTL06",164,0)
 G:RC<0 ERROR
"RTN","RORUTL06",165,0)
 Q
"RTN","RORUTL06",166,0)
 ;
"RTN","RORUTL06",167,0)
 ;***** PRINTS A LEVEL OF THE "FILE-PROCESSING TREE"
"RTN","RORUTL06",168,0)
 ;
"RTN","RORUTL06",169,0)
 ; PARENT        Parent file number
"RTN","RORUTL06",170,0)
 ; LEVEL         Number of the current level in the tree
"RTN","RORUTL06",171,0)
 ;
"RTN","RORUTL06",172,0)
 ; Return Values:
"RTN","RORUTL06",173,0)
 ;       <0  Error Code
"RTN","RORUTL06",174,0)
 ;        0  Ok
"RTN","RORUTL06",175,0)
 ;
"RTN","RORUTL06",176,0)
PRTMDE1(PARENT,LEVEL) ;
"RTN","RORUTL06",177,0)
 N FIELDS,FILE,FLD,I,IENS,IR,L,RORBUF,RORMSG
"RTN","RORUTL06",178,0)
 S FIELDS="@;.01E;.02I;1I;2E;4I;4.1;4.2;6I"
"RTN","RORUTL06",179,0)
 ;---
"RTN","RORUTL06",180,0)
 S FILE="",RC=0
"RTN","RORUTL06",181,0)
 F  S FILE=$O(RORLST(PARENT,FILE))  Q:FILE=""  D  Q:RC<0
"RTN","RORUTL06",182,0)
 . ;--- Load descriptors of the data elements
"RTN","RORUTL06",183,0)
 . K RORBUF  S IENS=","_FILE_","
"RTN","RORUTL06",184,0)
 . D LIST^DIC(799.22,IENS,FIELDS,,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL06",185,0)
 . ;--- Print header (if necessary) and file number
"RTN","RORUTL06",186,0)
 . I ($Y+5)>IOSL  S RC=$$PRTMDEH()  Q:RC<0
"RTN","RORUTL06",187,0)
 . D PRTMDEL(LEVEL-1),PRTMDEL(LEVEL-1,FILE)
"RTN","RORUTL06",188,0)
 . ;--- Print data element descriptors
"RTN","RORUTL06",189,0)
 . S IR="",RC=0
"RTN","RORUTL06",190,0)
 . F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D  Q:RC<0  W !
"RTN","RORUTL06",191,0)
 . . I ($Y+5)>IOSL  S RC=$$PRTMDEH()  Q:RC<0
"RTN","RORUTL06",192,0)
 . . D:IR>1 PRTMDEL(LEVEL,"")
"RTN","RORUTL06",193,0)
 . . S I=""
"RTN","RORUTL06",194,0)
 . . F  S I=$O(RORCOLS(I))  Q:I=""  D
"RTN","RORUTL06",195,0)
 . . . S FLD=+$P(RORCOLS(I),U,2)  Q:FLD'>0
"RTN","RORUTL06",196,0)
 . . . S L=+$P(RORCOLS(I),U,3)  S:L'>0 L=999
"RTN","RORUTL06",197,0)
 . . . W ?(+RORCOLS(I)),$E($G(RORBUF("DILIST","ID",IR,FLD)),1,L)
"RTN","RORUTL06",198,0)
 . Q:RC<0
"RTN","RORUTL06",199,0)
 . S:$D(RORLST(FILE))>1 RC=$$PRTMDE1(FILE,LEVEL+1)
"RTN","RORUTL06",200,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL06",201,0)
 ;
"RTN","RORUTL06",202,0)
 ;***** PRINTS A TABLE OF DATA ELEMENTS
"RTN","RORUTL06",203,0)
PRTMDE2() ;
"RTN","RORUTL06",204,0)
 N BY,DHD,FR,L,DIC,FLDS,TO
"RTN","RORUTL06",205,0)
 S L=0,DIC=799.2,DHD=RORTTL
"RTN","RORUTL06",206,0)
 S BY="[ROR DATA ELEMENTS]",FLDS="[ROR DATA ELEMENTS]"
"RTN","RORUTL06",207,0)
 D EN1^DIP
"RTN","RORUTL06",208,0)
 Q 0
"RTN","RORUTL06",209,0)
 ;
"RTN","RORUTL06",210,0)
 ;***** PRINTS A HEADER OF THE DATA ELEMENT REPORT
"RTN","RORUTL06",211,0)
 ;  X  Field Width Title
"RTN","RORUTL06",212,0)
PRTMDEH() ;
"RTN","RORUTL06",213,0)
 ;;  0^     ^     ^File
"RTN","RORUTL06",214,0)
 ;; 22^  .01^   25^Data Name
"RTN","RORUTL06",215,0)
 ;; 49^  .02^     ^Code
"RTN","RORUTL06",216,0)
 ;; 55^ 2   ^     ^Req
"RTN","RORUTL06",217,0)
 ;; 60^ 1   ^     ^API
"RTN","RORUTL06",218,0)
 ;; 65^ 6   ^     ^Field Number
"RTN","RORUTL06",219,0)
 ;; 82^ 4   ^     ^VT
"RTN","RORUTL06",220,0)
 ;; 86^ 4.1 ^   20^External
"RTN","RORUTL06",221,0)
 ;;108^ 4.2 ^   20^Internal
"RTN","RORUTL06",222,0)
 ;
"RTN","RORUTL06",223,0)
 N DIR,DIRUT,DTOUT,DUOUT,I,X,Y
"RTN","RORUTL06",224,0)
 I RORPAGE,$E(IOST,1,2)="C-"  D  Q:'Y $S(Y="":-72,1:-71)
"RTN","RORUTL06",225,0)
 . S DIR(0)="E"  D ^DIR
"RTN","RORUTL06",226,0)
 W:RORPAGE!($E(IOST,1,2)="C-") @IOF
"RTN","RORUTL06",227,0)
 S RORPAGE=RORPAGE+1,I=""  W RORTTL,!
"RTN","RORUTL06",228,0)
 F  S I=$O(RORCOLS(I))  Q:I=""  W ?(+RORCOLS(I)),$P(RORCOLS(I),U,4)
"RTN","RORUTL06",229,0)
 S X="",$P(X,"-",IOM)=""
"RTN","RORUTL06",230,0)
 W !,X,!
"RTN","RORUTL06",231,0)
 Q 0
"RTN","RORUTL06",232,0)
 ;
"RTN","RORUTL06",233,0)
 ;***** PRINTS THE LEVEL INDICATOR
"RTN","RORUTL06",234,0)
 ;
"RTN","RORUTL06",235,0)
 ; N             Number of dots in the indicator
"RTN","RORUTL06",236,0)
 ; [FILE]        File number
"RTN","RORUTL06",237,0)
 ;
"RTN","RORUTL06",238,0)
PRTMDEL(N,FILE) ;
"RTN","RORUTL06",239,0)
 N I  W:$X>0 !  F I=1:1:N  W ". "
"RTN","RORUTL06",240,0)
 W:$D(FILE) FILE  W:'$D(FILE) !
"RTN","RORUTL06",241,0)
 Q
"RTN","RORUTL06",242,0)
 ;
"RTN","RORUTL06",243,0)
 ;***** VALIDATES REGISTRY UPDATE DEFINITION
"RTN","RORUTL06",244,0)
 ;
"RTN","RORUTL06",245,0)
 ; .REGLST       Reference to a local array containing
"RTN","RORUTL06",246,0)
 ;               registry names as subscripts
"RTN","RORUTL06",247,0)
 ;
"RTN","RORUTL06",248,0)
 ; Return Values:
"RTN","RORUTL06",249,0)
 ;       <0  Error Code
"RTN","RORUTL06",250,0)
 ;        0  Ok
"RTN","RORUTL06",251,0)
 ;
"RTN","RORUTL06",252,0)
UPDDEF(REGLST) ;
"RTN","RORUTL06",253,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL06",254,0)
 N RORLRC        ; List of Lab result codes to check
"RTN","RORUTL06",255,0)
 N RORUPD        ; Update descriptor
"RTN","RORUTL06",256,0)
 N RORUPDPI      ; Closed root of the temporary storage
"RTN","RORUTL06",257,0)
 N RORVALS       ; Calculated values
"RTN","RORUTL06",258,0)
 ;
"RTN","RORUTL06",259,0)
 N RC
"RTN","RORUTL06",260,0)
 W !,"REGISTRY UPDATE DEFINITION",!
"RTN","RORUTL06",261,0)
 D CLEAR^RORERR("UPDDEF^RORUTL06")
"RTN","RORUTL06",262,0)
 S RORUPDPI=$NA(^TMP("RORUPD",$J))
"RTN","RORUTL06",263,0)
 S RC=$$PREPARE^RORUPR(.REGLST)
"RTN","RORUTL06",264,0)
 D:RC'<0 DEBUG^RORUPDUT
"RTN","RORUTL06",265,0)
 Q RC
"RTN","RORUTL07")
0^97^B10278972
"RTN","RORUTL07",1,0)
RORUTL07 ;HCIOFO/SG - TEST ENTRY POINTS ; 7/21/03 9:59am
"RTN","RORUTL07",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUTL07",3,0)
 ;
"RTN","RORUTL07",4,0)
 Q
"RTN","RORUTL07",5,0)
 ;
"RTN","RORUTL07",6,0)
 ;***** RESETS THE 'AWAITING ACK' FLAG
"RTN","RORUTL07",7,0)
 ;
"RTN","RORUTL07",8,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL07",9,0)
 ;
"RTN","RORUTL07",10,0)
 ; Return Values:
"RTN","RORUTL07",11,0)
 ;       <0  Error Code
"RTN","RORUTL07",12,0)
 ;        0  Ok
"RTN","RORUTL07",13,0)
 ;       >0  The flag has not been reset
"RTN","RORUTL07",14,0)
 ;
"RTN","RORUTL07",15,0)
ACKFLAG(REGIEN) ;
"RTN","RORUTL07",16,0)
 N DIR,DIRUT,DTOUT,DUOUT,IENS,RORBUF,RORFDA,RORMSG,X,Y
"RTN","RORUTL07",17,0)
 S IENS=REGIEN_","
"RTN","RORUTL07",18,0)
 ;--- Load the data
"RTN","RORUTL07",19,0)
 D GETS^DIQ(798.1,IENS,"2.2;2.3","I","RORBUF","RORMSG")
"RTN","RORUTL07",20,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","RORUTL07",21,0)
 S Y=$G(RORBUF(798.1,IENS,2.2,"I"))
"RTN","RORUTL07",22,0)
 ;--- Ask confirmation to reset the flag
"RTN","RORUTL07",23,0)
 I Y  D  Q:RC RC
"RTN","RORUTL07",24,0)
 . S DIR(0)="Y",DIR("B")="YES"
"RTN","RORUTL07",25,0)
 . S DIR("A")="Reset the 'Awaiting ACK' flag"
"RTN","RORUTL07",26,0)
 . D ^DIR
"RTN","RORUTL07",27,0)
 . S RC=$S($D(DIRUT):-72,1:'$G(Y))
"RTN","RORUTL07",28,0)
 ;--- Cancel the message
"RTN","RORUTL07",29,0)
 S Y=$G(RORBUF(798.1,IENS,2.3,"I"))
"RTN","RORUTL07",30,0)
 S:Y'="" Y=$$MSGACT^HLUTIL(Y,1)
"RTN","RORUTL07",31,0)
 ;--- Clear the flag
"RTN","RORUTL07",32,0)
 S RORFDA(798.1,IENS,2.2)="@"
"RTN","RORUTL07",33,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUTL07",34,0)
 Q +$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","RORUTL07",35,0)
 ;
"RTN","RORUTL07",36,0)
 ;***** DISPLAYS THE ERRORS
"RTN","RORUTL07",37,0)
ERROR ;
"RTN","RORUTL07",38,0)
 D DSPSTK^RORERR()
"RTN","RORUTL07",39,0)
 Q
"RTN","RORUTL07",40,0)
 ;
"RTN","RORUTL07",41,0)
 ;***** DATA EXTRACTION TEST ENTRY POINT
"RTN","RORUTL07",42,0)
EXTRACT ;
"RTN","RORUTL07",43,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL07",44,0)
 N RORERROR      ; Error processing data
"RTN","RORUTL07",45,0)
 N RORPARM       ; Application parameters
"RTN","RORUTL07",46,0)
 ;
"RTN","RORUTL07",47,0)
 N RC,REGIEN,REGNAME,SDT
"RTN","RORUTL07",48,0)
 W !,"DATA EXTRACTION & TRANSMISSION IN DEBUG MODE",!
"RTN","RORUTL07",49,0)
 D KILL^XUSCLEAN
"RTN","RORUTL07",50,0)
 S RORPARM("DEBUG")=2
"RTN","RORUTL07",51,0)
 S RORPARM("ERR")=1
"RTN","RORUTL07",52,0)
 D CLEAR^RORERR("EXTRACT^RORUTL07")
"RTN","RORUTL07",53,0)
 ;--- Select a registry
"RTN","RORUTL07",54,0)
 S RC=$$SELREG^RORHDTUT(.REGNAME)        G:RC<0 ERROR
"RTN","RORUTL07",55,0)
 Q:RC'>0  S REGIEN=RC
"RTN","RORUTL07",56,0)
 ;--- Request a start date
"RTN","RORUTL07",57,0)
 S SDT=$$GETSDT()                       G:SDT<0 ERROR
"RTN","RORUTL07",58,0)
 ;--- Check/Reset the 'Awaiting Acknowledgement' flag
"RTN","RORUTL07",59,0)
 S RC=$$ACKFLAG(REGIEN)                  G:RC<0 ERROR
"RTN","RORUTL07",60,0)
 ;--- Extract the registry data
"RTN","RORUTL07",61,0)
 S RC=$$EXTRACT^ROREXT(REGNAME,$G(SDT))  G:RC<0 ERROR
"RTN","RORUTL07",62,0)
 Q
"RTN","RORUTL07",63,0)
 ;
"RTN","RORUTL07",64,0)
 ;***** REQESTS A START DATE FROM A USER
"RTN","RORUTL07",65,0)
 ;
"RTN","RORUTL07",66,0)
 ; Return Values:
"RTN","RORUTL07",67,0)
 ;       <0  Error Code
"RTN","RORUTL07",68,0)
 ;       ""  No start date (default)
"RTN","RORUTL07",69,0)
 ;       >0  Start date
"RTN","RORUTL07",70,0)
 ;
"RTN","RORUTL07",71,0)
GETSDT() ;
"RTN","RORUTL07",72,0)
 ;;If you enter an empty string then the individual start date
"RTN","RORUTL07",73,0)
 ;;(from the registry record) will be used for each patient.
"RTN","RORUTL07",74,0)
 ;
"RTN","RORUTL07",75,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,RC,X,Y
"RTN","RORUTL07",76,0)
 S DIR(0)="DO^:DT:EX"
"RTN","RORUTL07",77,0)
 S DIR("A")="Start date for data extraction"
"RTN","RORUTL07",78,0)
 F X=1:1  S Y=$P($T(GETSDT+X),";;",2)  Q:Y=""  S DIR("?",X)=Y
"RTN","RORUTL07",79,0)
 S DIR("?")="This response must be a date."
"RTN","RORUTL07",80,0)
 D ^DIR
"RTN","RORUTL07",81,0)
 S RC=$S($D(DTOUT):-72,$D(DUOUT):-71,1:0)
"RTN","RORUTL07",82,0)
 Q $S(RC<0:RC,1:$G(Y))
"RTN","RORUTL07",83,0)
 ;
"RTN","RORUTL07",84,0)
 ;***** REGISTRY UPDATE TEST ENTRY POINT
"RTN","RORUTL07",85,0)
UPDATE ;
"RTN","RORUTL07",86,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL07",87,0)
 N RORERROR      ; Error processing data
"RTN","RORUTL07",88,0)
 N RORPARM       ; Application parameters
"RTN","RORUTL07",89,0)
 ;
"RTN","RORUTL07",90,0)
 N RC,REGLST,REGNAME
"RTN","RORUTL07",91,0)
 W !,"REGISTRY UPDATE IN DEBUG MODE",!
"RTN","RORUTL07",92,0)
 D KILL^XUSCLEAN
"RTN","RORUTL07",93,0)
 S RORPARM("DEBUG")=2
"RTN","RORUTL07",94,0)
 S RORPARM("ERR")=1
"RTN","RORUTL07",95,0)
 D CLEAR^RORERR("UPDATE^RORUTL07")
"RTN","RORUTL07",96,0)
 ;--- Select a registry
"RTN","RORUTL07",97,0)
 S RC=$$SELREG^RORHDTUT(.REGNAME)  G:RC<0 ERROR
"RTN","RORUTL07",98,0)
 Q:RC'>0  S REGLST(REGNAME)=""
"RTN","RORUTL07",99,0)
 ;--- Update the registry
"RTN","RORUTL07",100,0)
 S RC=$$UPDATE^RORUPD(.REGLST)     G:RC<0 ERROR
"RTN","RORUTL07",101,0)
 Q
"RTN","RORUTL08")
0^6^B17859176
"RTN","RORUTL08",1,0)
RORUTL08 ;HCIOFO/SG - REPORT PARAMETERS UTILITIES  ; 11/3/03 12:12pm
"RTN","RORUTL08",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUTL08",3,0)
 ;
"RTN","RORUTL08",4,0)
 Q
"RTN","RORUTL08",5,0)
 ;
"RTN","RORUTL08",6,0)
 ;***** RETURNS CODE AND NAME OF THE REPORT PARAMETERS (#799.34)
"RTN","RORUTL08",7,0)
 ;
"RTN","RORUTL08",8,0)
 ; ITEMIEN       IEN of the report parameters
"RTN","RORUTL08",9,0)
 ; [.NAME]       Report name is returned via this parameter
"RTN","RORUTL08",10,0)
 ;
"RTN","RORUTL08",11,0)
 ; Return Values:
"RTN","RORUTL08",12,0)
 ;       ""  Code is not available
"RTN","RORUTL08",13,0)
 ;           Code of the report
"RTN","RORUTL08",14,0)
 ;
"RTN","RORUTL08",15,0)
RPCODE(RPIEN,NAME) ;
"RTN","RORUTL08",16,0)
 S NAME=""  Q:RPIEN'>0 ""
"RTN","RORUTL08",17,0)
 N BUF
"RTN","RORUTL08",18,0)
 S BUF=$G(^ROR(799.34,+RPIEN,0))  Q:BUF="" ""
"RTN","RORUTL08",19,0)
 S NAME=$P(BUF,U)
"RTN","RORUTL08",20,0)
 Q $P(BUF,U,4)
"RTN","RORUTL08",21,0)
 ;
"RTN","RORUTL08",22,0)
 ;***** RETURNS IEN AND NAME OF THE REPORT PARAMETERS (#799.34)
"RTN","RORUTL08",23,0)
 ;
"RTN","RORUTL08",24,0)
 ; CODE          Code of the report
"RTN","RORUTL08",25,0)
 ; [.NAME]       Report name is returned via this parameter
"RTN","RORUTL08",26,0)
 ;
"RTN","RORUTL08",27,0)
 ; Return Values:
"RTN","RORUTL08",28,0)
 ;       <0  Error code
"RTN","RORUTL08",29,0)
 ;       >0  IEN of the item
"RTN","RORUTL08",30,0)
 ;
"RTN","RORUTL08",31,0)
RPIEN(CODE,NAME) ;
"RTN","RORUTL08",32,0)
 N RC,RORBUF,RORMSG  S NAME=""
"RTN","RORUTL08",33,0)
 D FIND^DIC(799.34,,"@;.01","QX",CODE,2,"KEY",,,"RORBUF","RORMSG")
"RTN","RORUTL08",34,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,799.34)
"RTN","RORUTL08",35,0)
 S RC=+$G(RORBUF("DILIST",0))
"RTN","RORUTL08",36,0)
 S:RC=1 NAME=$G(RORBUF("DILIST","ID",1,.01))
"RTN","RORUTL08",37,0)
 Q $S(RC<1:-86,RC>1:-87,1:+RORBUF("DILIST",2,1))
"RTN","RORUTL08",38,0)
 ;
"RTN","RORUTL08",39,0)
 ;***** RETURNS REPORT PARAMETERS
"RTN","RORUTL08",40,0)
 ;
"RTN","RORUTL08",41,0)
 ; CODE          Report code
"RTN","RORUTL08",42,0)
 ;
"RTN","RORUTL08",43,0)
 ; .INFO         Reference to a local variable (output):
"RTN","RORUTL08",44,0)
 ;
"RTN","RORUTL08",45,0)
 ; INFO(
"RTN","RORUTL08",46,0)
 ;   OFFSET+1)           Report Name
"RTN","RORUTL08",47,0)
 ;   OFFSET+2)           Backgr. Processing  (0/1)
"RTN","RORUTL08",48,0)
 ;   OFFSET+3)           reserved
"RTN","RORUTL08",49,0)
 ;   OFFSET+4)           Code of the report
"RTN","RORUTL08",50,0)
 ;   OFFSET+5)           Report Parameters IEN
"RTN","RORUTL08",51,0)
 ;   OFFSET+6)           Inactivation Date   (internal)
"RTN","RORUTL08",52,0)
 ;   OFFSET+7)           National            (0/1)
"RTN","RORUTL08",53,0)
 ;   OFFSET+8)           List of parameter panels
"RTN","RORUTL08",54,0)
 ;   OFFSET+9)           Report Builder      ($$TAG^ROUTINE)
"RTN","RORUTL08",55,0)
 ;   OFFSET+10)          Default parameters (NAME=VALUE),
"RTN","RORUTL08",56,0)
 ;                       separated by "<*>"
"RTN","RORUTL08",57,0)
 ;   OFFSET+11)          Default sorting modes (TABLE=FIELD),
"RTN","RORUTL08",58,0)
 ;                       separated by "<*>"
"RTN","RORUTL08",59,0)
 ;
"RTN","RORUTL08",60,0)
 ; [FLAGS]       Characters controlling behavior of the function
"RTN","RORUTL08",61,0)
 ;               (they can be combined):
"RTN","RORUTL08",62,0)
 ;                 E  Return external values also (when applicable)
"RTN","RORUTL08",63,0)
 ;
"RTN","RORUTL08",64,0)
 ; [OFFSET]      A number that is added to all subscripts in the
"RTN","RORUTL08",65,0)
 ;               destination array (by default, it is zero).
"RTN","RORUTL08",66,0)
 ;
"RTN","RORUTL08",67,0)
 ; Return Values:
"RTN","RORUTL08",68,0)
 ;       <0  Error code
"RTN","RORUTL08",69,0)
 ;        0  Ok
"RTN","RORUTL08",70,0)
 ;
"RTN","RORUTL08",71,0)
RPINFO(CODE,INFO,FLAGS,OFFSET) ;
"RTN","RORUTL08",72,0)
 N BUF,I,IEN,IENS,RC,RORBUF,RORMSG,SEP,TMP
"RTN","RORUTL08",73,0)
 S FLAGS=$$UP^XLFSTR($G(FLAGS))
"RTN","RORUTL08",74,0)
 S OFFSET=$S($G(OFFSET)>0:+OFFSET,1:0)
"RTN","RORUTL08",75,0)
 ;--- Clear the output array
"RTN","RORUTL08",76,0)
 K:'OFFSET INFO  S TMP=$$RPN
"RTN","RORUTL08",77,0)
 F I=1:1:TMP  S INFO(OFFSET+I)=""
"RTN","RORUTL08",78,0)
 ;--- Get the record IEN
"RTN","RORUTL08",79,0)
 S IEN=$$RPIEN(CODE)  Q:IEN<0 IEN
"RTN","RORUTL08",80,0)
 ;--- Load the parameters
"RTN","RORUTL08",81,0)
 S IENS=IEN_",",I=$S(FLAGS["E":"EIN",1:"IN")
"RTN","RORUTL08",82,0)
 S TMP=".01;.02;.04;.05;.09;1;10.01;11;12"
"RTN","RORUTL08",83,0)
 D GETS^DIQ(799.34,IENS,TMP,I,"RORBUF","RORMSG")
"RTN","RORUTL08",84,0)
 I $G(DIERR)  D  Q RC
"RTN","RORUTL08",85,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,799.34,IENS)
"RTN","RORUTL08",86,0)
 ;--- Name
"RTN","RORUTL08",87,0)
 S INFO(OFFSET+1)=$G(RORBUF(799.34,IENS,.01,"I"))
"RTN","RORUTL08",88,0)
 ;--- Background Processing
"RTN","RORUTL08",89,0)
 I $G(RORBUF(799.34,IENS,.02,"I"))'=""  D
"RTN","RORUTL08",90,0)
 . S INFO(OFFSET+2)=RORBUF(799.34,IENS,.02,"I")
"RTN","RORUTL08",91,0)
 ;--- Code of the report
"RTN","RORUTL08",92,0)
 S INFO(OFFSET+4)=$G(RORBUF(799.34,IENS,.04,"I"))
"RTN","RORUTL08",93,0)
 ;--- Report Parameters IEN
"RTN","RORUTL08",94,0)
 S INFO(OFFSET+5)=IEN
"RTN","RORUTL08",95,0)
 ;--- Inactivation Date
"RTN","RORUTL08",96,0)
 I $G(RORBUF(799.34,IENS,.05,"I"))'=""  D
"RTN","RORUTL08",97,0)
 . S INFO(OFFSET+6)=RORBUF(799.34,IENS,.05,"I")
"RTN","RORUTL08",98,0)
 ;--- National
"RTN","RORUTL08",99,0)
 I $G(RORBUF(799.34,IENS,.09,"I"))'=""  D
"RTN","RORUTL08",100,0)
 . S INFO(OFFSET+7)=RORBUF(799.34,IENS,.09,"I")
"RTN","RORUTL08",101,0)
 ;--- List of parameter panels
"RTN","RORUTL08",102,0)
 S INFO(OFFSET+8)=$G(RORBUF(799.34,IENS,1,"I"))
"RTN","RORUTL08",103,0)
 ;--- Report Builder
"RTN","RORUTL08",104,0)
 S INFO(OFFSET+9)=$G(RORBUF(799.34,IENS,10.01,"I"))
"RTN","RORUTL08",105,0)
 ;--- Default parameters
"RTN","RORUTL08",106,0)
 S I=0,BUF="",SEP="<*>"
"RTN","RORUTL08",107,0)
 F  S I=$O(RORBUF(799.34,IENS,11,I))  Q:I'>0  D
"RTN","RORUTL08",108,0)
 . S TMP=$TR(RORBUF(799.34,IENS,11,I)," ")
"RTN","RORUTL08",109,0)
 . S:TMP?1(1.ANP,1.ANP1"("1.NP1")")1"="1.E BUF=BUF_SEP_TMP
"RTN","RORUTL08",110,0)
 S INFO(OFFSET+10)=$P(BUF,SEP,2,999)
"RTN","RORUTL08",111,0)
 ;--- Default sorting modes
"RTN","RORUTL08",112,0)
 S I=0,BUF="",SEP="<*>"
"RTN","RORUTL08",113,0)
 F  S I=$O(RORBUF(799.34,IENS,12,I))  Q:I'>0  D
"RTN","RORUTL08",114,0)
 . S TMP=$TR(RORBUF(799.34,IENS,12,I)," ")
"RTN","RORUTL08",115,0)
 . S:TMP?1.ANP1"="1.E BUF=BUF_SEP_TMP
"RTN","RORUTL08",116,0)
 S INFO(OFFSET+11)=$P(BUF,SEP,2,999)
"RTN","RORUTL08",117,0)
 Q 0
"RTN","RORUTL08",118,0)
 ;
"RTN","RORUTL08",119,0)
 ;***** RETURNS A LIST OF REPORTS AVAILABLE FOR THE REGISTRY
"RTN","RORUTL08",120,0)
 ;
"RTN","RORUTL08",121,0)
 ; .ROR8DST      Reference to a local variable. Report parameters are
"RTN","RORUTL08",122,0)
 ;               returned into this array in the following format:
"RTN","RORUTL08",123,0)
 ;
"RTN","RORUTL08",124,0)
 ;                 ROR8DST(ReportCode)=ReportIEN^ReportName
"RTN","RORUTL08",125,0)
 ;
"RTN","RORUTL08",126,0)
 ; [REGIEN]      Registry IEN. If $G(REGIEN)>0, both the registry
"RTN","RORUTL08",127,0)
 ;               specific (REGISTRY=REGIEN) and common (REGISTRY=0)
"RTN","RORUTL08",128,0)
 ;               reports will be returned. Otherwise, only the common
"RTN","RORUTL08",129,0)
 ;               ones will be returned.
"RTN","RORUTL08",130,0)
 ;
"RTN","RORUTL08",131,0)
 ; [CDT]         "Current" Date/Time (NOW by default)
"RTN","RORUTL08",132,0)
 ;
"RTN","RORUTL08",133,0)
 ;               If this date/time is equal or later that the
"RTN","RORUTL08",134,0)
 ;               inactivation date from the record (only if there
"RTN","RORUTL08",135,0)
 ;               is any) then the record is considered inactive
"RTN","RORUTL08",136,0)
 ;               and will be skipped.
"RTN","RORUTL08",137,0)
 ;
"RTN","RORUTL08",138,0)
 ;               To include both active and inactive reports in the
"RTN","RORUTL08",139,0)
 ;               list, pass a negative number as the value of this
"RTN","RORUTL08",140,0)
 ;               parameter.
"RTN","RORUTL08",141,0)
 ;
"RTN","RORUTL08",142,0)
 ; Return Values:
"RTN","RORUTL08",143,0)
 ;       <0  Error code
"RTN","RORUTL08",144,0)
 ;        0  Ok
"RTN","RORUTL08",145,0)
 ;
"RTN","RORUTL08",146,0)
RPLIST(ROR8DST,REGIEN,CDT) ;
"RTN","RORUTL08",147,0)
 N CODE,I,IEN,IENS,NAME,INCTVDT,RC,RORMSG,RPLST
"RTN","RORUTL08",148,0)
 K ROR8DST  S RC=0  S:'$G(CDT) CDT=$$NOW^XLFDT
"RTN","RORUTL08",149,0)
 ;--- Load the list of available reports (report codes)
"RTN","RORUTL08",150,0)
 S IENS=(+REGIEN)_","
"RTN","RORUTL08",151,0)
 S RPLST=$$GET1^DIQ(798.1,IENS,27,,,"RORMSG")
"RTN","RORUTL08",152,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","RORUTL08",153,0)
 S RPLST=$TR(RPLST," ")
"RTN","RORUTL08",154,0)
 ;--- Load the report parameters
"RTN","RORUTL08",155,0)
 F I=1:1  S CODE=$P(RPLST,",",I)  Q:CODE=""  D  Q:RC<0
"RTN","RORUTL08",156,0)
 . S IEN=$$RPIEN(CODE,.NAME)  Q:IEN'>0
"RTN","RORUTL08",157,0)
 . S IENS=IEN_","
"RTN","RORUTL08",158,0)
 . ;--- Skip inactive report parameters
"RTN","RORUTL08",159,0)
 . S INCTVDT=$$GET1^DIQ(799.34,IENS,.05,"I",,"RORMSG")
"RTN","RORUTL08",160,0)
 . I $G(DIERR)  D  Q
"RTN","RORUTL08",161,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,799.34,IENS)
"RTN","RORUTL08",162,0)
 . I INCTVDT>0  Q:CDT'<INCTVDT
"RTN","RORUTL08",163,0)
 . ;--- Create a record in the destination array
"RTN","RORUTL08",164,0)
 . S ROR8DST(CODE)=IEN_U_NAME
"RTN","RORUTL08",165,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL08",166,0)
 ;
"RTN","RORUTL08",167,0)
 ;***** RETURNS NUMBER OF NODES IN THE PARAMETERS ARRAY
"RTN","RORUTL08",168,0)
RPN() Q 11
"RTN","RORUTL09")
0^73^B6779484
"RTN","RORUTL09",1,0)
RORUTL09 ;HCIOFO/SG - LIST ITEM UTILITIES  ; 9/29/03 3:47pm
"RTN","RORUTL09",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUTL09",3,0)
 ;
"RTN","RORUTL09",4,0)
 Q
"RTN","RORUTL09",5,0)
 ;
"RTN","RORUTL09",6,0)
 ;***** RETURNS CODE AND TEXT OF THE ITEM IN THE FILE #799.1
"RTN","RORUTL09",7,0)
 ;
"RTN","RORUTL09",8,0)
 ; ITEMIEN       IEN of the item
"RTN","RORUTL09",9,0)
 ; [.TEXT]       Text of the item is returned via this parameter
"RTN","RORUTL09",10,0)
 ;
"RTN","RORUTL09",11,0)
 ; Return Values:
"RTN","RORUTL09",12,0)
 ;       <0  Error code
"RTN","RORUTL09",13,0)
 ;       ""  Code is not available
"RTN","RORUTL09",14,0)
 ;       >0  Code of the item
"RTN","RORUTL09",15,0)
 ;
"RTN","RORUTL09",16,0)
ITEMCODE(ITEMIEN,TEXT) ;
"RTN","RORUTL09",17,0)
 S TEXT=""  Q:ITEMIEN'>0 ""
"RTN","RORUTL09",18,0)
 Q:'$D(^ROR(799.1,+ITEMIEN,0)) ""
"RTN","RORUTL09",19,0)
 N IENS,RC,RORBUF,RORMSG
"RTN","RORUTL09",20,0)
 S IENS=(+ITEMIEN)_","
"RTN","RORUTL09",21,0)
 D GETS^DIQ(799.1,IENS,".01;.04",,"RORBUF","RORMSG")
"RTN","RORUTL09",22,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,799.1,IENS)
"RTN","RORUTL09",23,0)
 S TEXT=$G(RORBUF(799.1,IENS,.01))
"RTN","RORUTL09",24,0)
 Q $G(RORBUF(799.1,IENS,.04))
"RTN","RORUTL09",25,0)
 ;
"RTN","RORUTL09",26,0)
 ;***** RETURNS IEN AND TEXT OF THE ITEM IN THE FILE #799.1
"RTN","RORUTL09",27,0)
 ;
"RTN","RORUTL09",28,0)
 ; TYPE          Type of the item
"RTN","RORUTL09",29,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL09",30,0)
 ; CODE          Code of the item
"RTN","RORUTL09",31,0)
 ; [.TEXT]       Text of the item is returned via this parameter
"RTN","RORUTL09",32,0)
 ;
"RTN","RORUTL09",33,0)
 ; Return Values:
"RTN","RORUTL09",34,0)
 ;       <0  Error code
"RTN","RORUTL09",35,0)
 ;       >0  IEN of the item
"RTN","RORUTL09",36,0)
 ;
"RTN","RORUTL09",37,0)
ITEMIEN(TYPE,REGIEN,CODE,TEXT) ;
"RTN","RORUTL09",38,0)
 N RC,RORBUF,RORMSG,SRCHVAL
"RTN","RORUTL09",39,0)
 S TEXT="",SRCHVAL(1)=+TYPE,SRCHVAL(2)=+REGIEN,SRCHVAL(3)=+CODE
"RTN","RORUTL09",40,0)
 D FIND^DIC(799.1,,"@;.01","QX",.SRCHVAL,2,"KEY",,,"RORBUF","RORMSG")
"RTN","RORUTL09",41,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,799.1)
"RTN","RORUTL09",42,0)
 S RC=+$G(RORBUF("DILIST",0))
"RTN","RORUTL09",43,0)
 S:RC=1 TEXT=$G(RORBUF("DILIST","ID",1,.01))
"RTN","RORUTL09",44,0)
 Q $S(RC<1:-80,RC>1:-81,1:+RORBUF("DILIST",2,1))
"RTN","RORUTL09",45,0)
 ;
"RTN","RORUTL09",46,0)
 ;***** RETURNS A LIST OF ITEMS FROM THE FILE #799.1
"RTN","RORUTL09",47,0)
 ;
"RTN","RORUTL09",48,0)
 ; TYPE          Type of the items:
"RTN","RORUTL09",49,0)
 ;                 1  Reason for inactivation
"RTN","RORUTL09",50,0)
 ;                 2  Supporting evidence
"RTN","RORUTL09",51,0)
 ;                 3  Lab Group
"RTN","RORUTL09",52,0)
 ;                 4  Drug Group
"RTN","RORUTL09",53,0)
 ;
"RTN","RORUTL09",54,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL09",55,0)
 ;
"RTN","RORUTL09",56,0)
 ; .ROR8DST      Reference to a destination array.
"RTN","RORUTL09",57,0)
 ;               Items are returned into this array in the following
"RTN","RORUTL09",58,0)
 ;               format: ROR8DST(ItemCode)=ItemIEN^ItemText
"RTN","RORUTL09",59,0)
 ;
"RTN","RORUTL09",60,0)
 ; [CDT]         "Current" Date/Time (NOW by default)
"RTN","RORUTL09",61,0)
 ;
"RTN","RORUTL09",62,0)
 ;               If this date/time is equal or later that the
"RTN","RORUTL09",63,0)
 ;               inactivation date from the item record (only if
"RTN","RORUTL09",64,0)
 ;               there is any) then the item is considered inactive
"RTN","RORUTL09",65,0)
 ;               and will be skipped.
"RTN","RORUTL09",66,0)
 ;
"RTN","RORUTL09",67,0)
 ;               To include both active and inactive items in the
"RTN","RORUTL09",68,0)
 ;               list, pass a negative number as the value of this
"RTN","RORUTL09",69,0)
 ;               parameter.
"RTN","RORUTL09",70,0)
 ;
"RTN","RORUTL09",71,0)
 ; Return Values:
"RTN","RORUTL09",72,0)
 ;       <0  Error code
"RTN","RORUTL09",73,0)
 ;        0  Ok
"RTN","RORUTL09",74,0)
 ;
"RTN","RORUTL09",75,0)
ITEMLIST(TYPE,REGIEN,ROR8DST,CDT) ;
"RTN","RORUTL09",76,0)
 N CODE,IEN,IENS,INCTVDT,NODE,RC,RORBUF,RORMSG
"RTN","RORUTL09",77,0)
 S NODE=$NA(^ROR(799.1,"KEY",TYPE,REGIEN))  K ROR8DST
"RTN","RORUTL09",78,0)
 S:'$G(CDT) CDT=$$NOW^XLFDT
"RTN","RORUTL09",79,0)
 ;--- Load the active list items
"RTN","RORUTL09",80,0)
 S CODE="",RC=0
"RTN","RORUTL09",81,0)
 F  S CODE=$O(@NODE@(CODE))  Q:CODE=""  D  Q:RC<0
"RTN","RORUTL09",82,0)
 . S IEN=$O(@NODE@(CODE,""))  Q:'IEN
"RTN","RORUTL09",83,0)
 . S IENS=IEN_","  K RORBUF
"RTN","RORUTL09",84,0)
 . ;--- Load text and inactivation date
"RTN","RORUTL09",85,0)
 . D GETS^DIQ(799.1,IENS,".01;1","IE","RORBUF","RORMSG")
"RTN","RORUTL09",86,0)
 . I $G(DIERR)  D  Q
"RTN","RORUTL09",87,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,799.1,IENS)
"RTN","RORUTL09",88,0)
 . ;--- Skip inactive items
"RTN","RORUTL09",89,0)
 . S INCTVDT=$G(RORBUF(799.1,IENS,1,"I"))
"RTN","RORUTL09",90,0)
 . I INCTVDT>0  Q:CDT'<INCTVDT
"RTN","RORUTL09",91,0)
 . ;--- Create a record in the destination array
"RTN","RORUTL09",92,0)
 . S ROR8DST(CODE)=IEN_U_$G(RORBUF(799.1,IENS,.01,"E"))
"RTN","RORUTL09",93,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL10")
0^107^B40583539
"RTN","RORUTL10",1,0)
RORUTL10 ;HCIOFO/SG - LAB DATA SEARCH ; 2/10/04 9:00am
"RTN","RORUTL10",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUTL10",3,0)
 ;
"RTN","RORUTL10",4,0)
 ; This routine uses the following IAs:
"RTN","RORUTL10",5,0)
 ;
"RTN","RORUTL10",6,0)
 ; #91           Read access to the file #60
"RTN","RORUTL10",7,0)
 ; #554          Read access to the file #63
"RTN","RORUTL10",8,0)
 ; #998          Laboratory reference from file #2
"RTN","RORUTL10",9,0)
 ;
"RTN","RORUTL10",10,0)
 Q
"RTN","RORUTL10",11,0)
 ;
"RTN","RORUTL10",12,0)
 ;***** LOADS THE LIST OF TESTS FROM THE REGISTRY PARAMETERS
"RTN","RORUTL10",13,0)
 ;
"RTN","RORUTL10",14,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL10",15,0)
 ;
"RTN","RORUTL10",16,0)
 ; ROR8LTST      Closed root of a variable, which will contain
"RTN","RORUTL10",17,0)
 ;               a list of lab tests of interest:
"RTN","RORUTL10",18,0)
 ;
"RTN","RORUTL10",19,0)
 ;               @ROR8LTST@(ResultNode,TestIEN)
"RTN","RORUTL10",20,0)
 ;                 ^01: Test IEN (in file #60)
"RTN","RORUTL10",21,0)
 ;                 ^02: Test name
"RTN","RORUTL10",22,0)
 ;                 ^03: Code of the group
"RTN","RORUTL10",23,0)
 ;                 ^04: Group name
"RTN","RORUTL10",24,0)
 ;                 ^05: Location subscript
"RTN","RORUTL10",25,0)
 ;                 ^06: Result node
"RTN","RORUTL10",26,0)
 ;
"RTN","RORUTL10",27,0)
 ; [GROUPS]      List of codes (separated by commas) of Lab Groups
"RTN","RORUTL10",28,0)
 ;               to load (1 - CD4, 2 - CD4 %, 3 - Viral Load).
"RTN","RORUTL10",29,0)
 ;               If this parameter is undefined or empty then all
"RTN","RORUTL10",30,0)
 ;               tests will be loaded.
"RTN","RORUTL10",31,0)
 ;
"RTN","RORUTL10",32,0)
 ; Return Values:
"RTN","RORUTL10",33,0)
 ;       <0  Error code
"RTN","RORUTL10",34,0)
 ;        0  No tests are defined
"RTN","RORUTL10",35,0)
 ;       >0  Number of the tests
"RTN","RORUTL10",36,0)
 ;
"RTN","RORUTL10",37,0)
LOADTSTS(REGIEN,ROR8LTST,GROUPS) ;
"RTN","RORUTL10",38,0)
 N BUF,CNT,GRIEN,I,IEN,IENS,LTIEN,LTNODE,NAME,NODE,RC,RGIENS,RORBUF,RORMSG,TMP
"RTN","RORUTL10",39,0)
 S RC=0,RGIENS=","_(+REGIEN)_","  K @ROR8LTST
"RTN","RORUTL10",40,0)
 S NODE=$$ROOT^DILFD(798.128,RGIENS,1)
"RTN","RORUTL10",41,0)
 ;--- List of Group IEN's
"RTN","RORUTL10",42,0)
 S GROUPS=$TR($G(GROUPS)," ")
"RTN","RORUTL10",43,0)
 D:GROUPS'=""
"RTN","RORUTL10",44,0)
 . F I=1:1  S TMP=$P(GROUPS,",",I)  Q:TMP'>0  D
"RTN","RORUTL10",45,0)
 . . S TMP=$$ITEMIEN^RORUTL09(3,REGIEN,TMP)
"RTN","RORUTL10",46,0)
 . . S:TMP>0 GRIEN(TMP)=""
"RTN","RORUTL10",47,0)
 ;---
"RTN","RORUTL10",48,0)
 S (CNT,IEN)=0
"RTN","RORUTL10",49,0)
 F  S IEN=$O(@NODE@(IEN))  Q:IEN'>0  D  Q:RC<0
"RTN","RORUTL10",50,0)
 . K RORBUF  S BUF=""
"RTN","RORUTL10",51,0)
 . ;--- Load the local test reference
"RTN","RORUTL10",52,0)
 . S IENS=IEN_RGIENS
"RTN","RORUTL10",53,0)
 . D GETS^DIQ(798.128,IENS,".01;.02","I","RORBUF","RORMSG")
"RTN","RORUTL10",54,0)
 . I $G(DIERR)  D  Q
"RTN","RORUTL10",55,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,798.128,IENS)
"RTN","RORUTL10",56,0)
 . S (BUF,LTIEN)=+$G(RORBUF(798.128,IENS,.01,"I"))
"RTN","RORUTL10",57,0)
 . Q:LTIEN'>0
"RTN","RORUTL10",58,0)
 . ;--- Check the Lab Group
"RTN","RORUTL10",59,0)
 . S GRIEN=+$G(RORBUF(798.128,IENS,.02,"I"))
"RTN","RORUTL10",60,0)
 . I $D(GRIEN)>1  Q:'$D(GRIEN(GRIEN))
"RTN","RORUTL10",61,0)
 . I GRIEN>0  D  Q:RC<0
"RTN","RORUTL10",62,0)
 . . S TMP=$$ITEMCODE^RORUTL09(GRIEN,.NAME)
"RTN","RORUTL10",63,0)
 . . I TMP'>0  S:TMP<0 RC=+TMP  Q
"RTN","RORUTL10",64,0)
 . . S $P(BUF,U,3,4)=TMP_U_NAME  ; Code and name of the group
"RTN","RORUTL10",65,0)
 . ;--- Load the lab test parameters
"RTN","RORUTL10",66,0)
 . S IENS=LTIEN_","
"RTN","RORUTL10",67,0)
 . D GETS^DIQ(60,IENS,".01;5","EI","RORBUF","RORMSG")
"RTN","RORUTL10",68,0)
 . I $G(DIERR)  D  Q
"RTN","RORUTL10",69,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,60,IENS)
"RTN","RORUTL10",70,0)
 . S LTNODE=$P($G(RORBUF(60,IENS,5,"I")),";",2)
"RTN","RORUTL10",71,0)
 . Q:LTNODE=""
"RTN","RORUTL10",72,0)
 . S TMP=$G(RORBUF(60,IENS,.01,"E"))             ; Name of the test
"RTN","RORUTL10",73,0)
 . S $P(BUF,U,2)=$S(TMP'="":TMP,1:"Unknown ("_LTIEN_")")
"RTN","RORUTL10",74,0)
 . S $P(BUF,U,5)=$P(RORBUF(60,IENS,5,"I"),";",1) ; Subscript
"RTN","RORUTL10",75,0)
 . S $P(BUF,U,6)=$P(RORBUF(60,IENS,5,"I"),";",2) ; Result node
"RTN","RORUTL10",76,0)
 . ;--- Create the reference
"RTN","RORUTL10",77,0)
 . S @ROR8LTST@(LTNODE,LTIEN)=BUF,CNT=CNT+1
"RTN","RORUTL10",78,0)
 ;---
"RTN","RORUTL10",79,0)
 Q $S(RC<0:RC,1:CNT)
"RTN","RORUTL10",80,0)
 ;
"RTN","RORUTL10",81,0)
 ;***** SEARCHES THE LAB DATA FOR REGISTRY SPECIFIC RESULTS
"RTN","RORUTL10",82,0)
 ;
"RTN","RORUTL10",83,0)
 ; PATIEN        IEN of the patient (DFN)
"RTN","RORUTL10",84,0)
 ;
"RTN","RORUTL10",85,0)
 ; ROR8LTST      Closed root of a variable, which contains a list
"RTN","RORUTL10",86,0)
 ;               of lab tests of interest (in the same format as
"RTN","RORUTL10",87,0)
 ;               the list returned by the $$LOADTSTS^RORUTL10).
"RTN","RORUTL10",88,0)
 ;
"RTN","RORUTL10",89,0)
 ;               If the "*" is passed via this parameter then all
"RTN","RORUTL10",90,0)
 ;               lab tests are considered.
"RTN","RORUTL10",91,0)
 ;
"RTN","RORUTL10",92,0)
 ;               If this parameter has a pure numeric value then
"RTN","RORUTL10",93,0)
 ;               it is considered as registry IEN and the default
"RTN","RORUTL10",94,0)
 ;               list of registry specific tests is automatically
"RTN","RORUTL10",95,0)
 ;               compiled by the $$LOADTSTS^RORUTL10 function.
"RTN","RORUTL10",96,0)
 ;
"RTN","RORUTL10",97,0)
 ; [[.]ROR8DST]  Closed root of an array where the results will be
"RTN","RORUTL10",98,0)
 ;               returned (the ^TMP("RORUTL10",$J), by default).
"RTN","RORUTL10",99,0)
 ;               The results will be stored into the destination
"RTN","RORUTL10",100,0)
 ;               array in following format:
"RTN","RORUTL10",101,0)
 ;
"RTN","RORUTL10",102,0)
 ;                 @ROR8DST@(i,
"RTN","RORUTL10",103,0)
 ;                   1)  Result Descriptor
"RTN","RORUTL10",104,0)
 ;                         ^01: IEN in the file #63 (inverted date)
"RTN","RORUTL10",105,0)
 ;                         ^02: Date of the test (FileMan)
"RTN","RORUTL10",106,0)
 ;                         ^03: Result
"RTN","RORUTL10",107,0)
 ;                   2)  Test Descriptor
"RTN","RORUTL10",108,0)
 ;                         ^01: Test IEN (in the file #60)
"RTN","RORUTL10",109,0)
 ;                         ^02: Test name
"RTN","RORUTL10",110,0)
 ;                         ^03: Code of the group
"RTN","RORUTL10",111,0)
 ;                         ^04: Group name
"RTN","RORUTL10",112,0)
 ;                         ^05: Location subscript
"RTN","RORUTL10",113,0)
 ;                         ^06: Result node
"RTN","RORUTL10",114,0)
 ;
"RTN","RORUTL10",115,0)
 ;               Example:
"RTN","RORUTL10",116,0)
 ;                 S RC=$$LTSEARCH^RORUTL10(DFN,REGIEN,"RORBUF")
"RTN","RORUTL10",117,0)
 ;
"RTN","RORUTL10",118,0)
 ;               If this parameter is passed by reference, you can
"RTN","RORUTL10",119,0)
 ;               provide a full name ($$TAG^ROUTINE) of the callback
"RTN","RORUTL10",120,0)
 ;               function, which will process and store the results,
"RTN","RORUTL10",121,0)
 ;               as the value of the "RORCB" node.
"RTN","RORUTL10",122,0)
 ;
"RTN","RORUTL10",123,0)
 ;               Any additional nodes created in this variable will
"RTN","RORUTL10",124,0)
 ;               be accessible in the callback function. Two other
"RTN","RORUTL10",125,0)
 ;               nodes are created automatically:
"RTN","RORUTL10",126,0)
 ;
"RTN","RORUTL10",127,0)
 ;                 "RORDFN"      IEN of the registry patient (DFN)
"RTN","RORUTL10",128,0)
 ;
"RTN","RORUTL10",129,0)
 ;                 "ROREDT"      End date
"RTN","RORUTL10",130,0)
 ;
"RTN","RORUTL10",131,0)
 ;                 "RORFLAGS"    Value of parameter of the same name
"RTN","RORUTL10",132,0)
 ;
"RTN","RORUTL10",133,0)
 ;                 "RORSDT"      Start date
"RTN","RORUTL10",134,0)
 ;
"RTN","RORUTL10",135,0)
 ;               The callback function must accept 3 parameters:
"RTN","RORUTL10",136,0)
 ;
"RTN","RORUTL10",137,0)
 ;                 .ROR8DST      Reference to the ROR8DST parameter.
"RTN","RORUTL10",138,0)
 ;
"RTN","RORUTL10",139,0)
 ;                 INVDT         IEN of the Lab test (inverted date)
"RTN","RORUTL10",140,0)
 ;
"RTN","RORUTL10",141,0)
 ;                 .RESULT       Reference to a local variable,
"RTN","RORUTL10",142,0)
 ;                               which contains the result in the
"RTN","RORUTL10",143,0)
 ;                               same format as it is stored into
"RTN","RORUTL10",144,0)
 ;                               the destination array by default.
"RTN","RORUTL10",145,0)
 ;
"RTN","RORUTL10",146,0)
 ;               The function should return the following values:
"RTN","RORUTL10",147,0)
 ;
"RTN","RORUTL10",148,0)
 ;                 <0  Error code (the search will be aborted)
"RTN","RORUTL10",149,0)
 ;                  0  Ok
"RTN","RORUTL10",150,0)
 ;                  1  Skip this result
"RTN","RORUTL10",151,0)
 ;                  2  Skip this and all remaining results
"RTN","RORUTL10",152,0)
 ;
"RTN","RORUTL10",153,0)
 ;               Example:
"RTN","RORUTL10",154,0)
 ;                 S RORDST=$NA(^TMP("RORBUF",$J))
"RTN","RORUTL10",155,0)
 ;                 S RORDST("RORPTR")=+$O(@RORDST@(""),-1)
"RTN","RORUTL10",156,0)
 ;                 S RORDST("RORCB")="$$LTCB^RORUT999"
"RTN","RORUTL10",157,0)
 ;                 S RC=$$LTSEARCH^RORUTL10(DFN,REGIEN,.RORDST)
"RTN","RORUTL10",158,0)
 ;
"RTN","RORUTL10",159,0)
 ; [RORFLAGS]    Flags to control processing (reserved)
"RTN","RORUTL10",160,0)
 ;
"RTN","RORUTL10",161,0)
 ; [STDT]        Start date (FileMan)
"RTN","RORUTL10",162,0)
 ; [ENDT]        End date   (FileMan)
"RTN","RORUTL10",163,0)
 ;
"RTN","RORUTL10",164,0)
 ;               The search is performed exactly between provided
"RTN","RORUTL10",165,0)
 ;               boundaries (the time parts are considered).
"RTN","RORUTL10",166,0)
 ;
"RTN","RORUTL10",167,0)
 ; The ^TMP("RORUTL10",$J) and ^TMP("RORUTL10L",$J) global nodes are
"RTN","RORUTL10",168,0)
 ; used by the function.
"RTN","RORUTL10",169,0)
 ;
"RTN","RORUTL10",170,0)
 ; Return Values:
"RTN","RORUTL10",171,0)
 ;       <0  Error code
"RTN","RORUTL10",172,0)
 ;        0  No results have been found
"RTN","RORUTL10",173,0)
 ;       >0  Number of results
"RTN","RORUTL10",174,0)
 ;
"RTN","RORUTL10",175,0)
LTSEARCH(PATIEN,ROR8LTST,ROR8DST,RORFLAGS,STDT,ENDT) ;
"RTN","RORUTL10",176,0)
 N BUF,CNT,EXIT,GRC,ILDT,LTDT,LTIEN,LTLOC,LTNODE,LTRES,RC,ROR8SET,RORLR,RORMSG,TMP
"RTN","RORUTL10",177,0)
 S:$G(ROR8DST)="" ROR8DST=$NA(^TMP("RORUTL10",$J))
"RTN","RORUTL10",178,0)
 Q:$G(ROR8LTST)="" 0  ; No Lab tests to search for
"RTN","RORUTL10",179,0)
 S RORFLAGS=$G(RORFLAGS),RC=0
"RTN","RORUTL10",180,0)
 ;
"RTN","RORUTL10",181,0)
 ;--- Determine the storage method (default or callback)
"RTN","RORUTL10",182,0)
 I $G(ROR8DST("RORCB"))?2"$"1.8UN1"^"1.8UN  D  Q:RC<0 RC
"RTN","RORUTL10",183,0)
 . S ROR8SET="S RC="_ROR8DST("RORCB")_"(.ROR8DST,ILDT,.BUF)"
"RTN","RORUTL10",184,0)
 . S ROR8DST("RORDFN")=PATIEN
"RTN","RORUTL10",185,0)
 . S ROR8DST("ROREDT")=$G(ENDT)
"RTN","RORUTL10",186,0)
 . S ROR8DST("RORFLAGS")=RORFLAGS
"RTN","RORUTL10",187,0)
 . S ROR8DST("RORSDT")=$G(STDT)
"RTN","RORUTL10",188,0)
 E  S ROR8SET=""  K @ROR8DST
"RTN","RORUTL10",189,0)
 ;
"RTN","RORUTL10",190,0)
 ;--- Get the Lab reference
"RTN","RORUTL10",191,0)
 S RORLR=$P($G(^DPT(PATIEN,"LR")),U)  Q:RORLR'>0 0
"RTN","RORUTL10",192,0)
 ;
"RTN","RORUTL10",193,0)
 ;--- Prepare the list of tests of interest
"RTN","RORUTL10",194,0)
 I (+ROR8LTST)=ROR8LTST  D  Q:RC'>0 RC
"RTN","RORUTL10",195,0)
 . S TMP=ROR8LTST,ROR8LTST=$NA(^TMP("RORUTL10L",$J))
"RTN","RORUTL10",196,0)
 . S RC=$$LOADTSTS(TMP,ROR8LTST)
"RTN","RORUTL10",197,0)
 I ROR8LTST'="*"  Q:$D(@ROR8LTST)<10 0
"RTN","RORUTL10",198,0)
 ;
"RTN","RORUTL10",199,0)
 ;--- Search the Lab data
"RTN","RORUTL10",200,0)
 S STDT=$$INVDATE^RORUTL01($S($G(STDT)>0:STDT,1:0))
"RTN","RORUTL10",201,0)
 S ILDT=$S($G(ENDT)>0:$$INVDATE^RORUTL01(ENDT),1:0)
"RTN","RORUTL10",202,0)
 S (CNT,RC)=0
"RTN","RORUTL10",203,0)
 F  S ILDT=$O(^LR(RORLR,"CH",ILDT))  Q:(ILDT'>0)!(ILDT>STDT)  D  Q:RC
"RTN","RORUTL10",204,0)
 . S LTNODE=1
"RTN","RORUTL10",205,0)
 . F  S LTNODE=$O(^LR(RORLR,"CH",ILDT,LTNODE))  Q:LTNODE=""  D  Q:RC
"RTN","RORUTL10",206,0)
 . . S LTRES=$P($G(^LR(RORLR,"CH",ILDT,LTNODE)),U)
"RTN","RORUTL10",207,0)
 . . Q:LTRES=""    ; Skip empty results
"RTN","RORUTL10",208,0)
 . . S TMP=$$UP^XLFSTR(LTRES)
"RTN","RORUTL10",209,0)
 . . Q:TMP["CANC"  ; Skip cancelled tests
"RTN","RORUTL10",210,0)
 . . S LTDT=$P($G(^LR(RORLR,"CH",ILDT,0)),U)
"RTN","RORUTL10",211,0)
 . . ;--- Only selected tests
"RTN","RORUTL10",212,0)
 . . I ROR8LTST'="*"  D  Q
"RTN","RORUTL10",213,0)
 . . . S LTIEN=""
"RTN","RORUTL10",214,0)
 . . . F  S LTIEN=$O(@ROR8LTST@(LTNODE,LTIEN))  Q:LTIEN=""  D  Q:RC
"RTN","RORUTL10",215,0)
 . . . . S GRC=$P(@ROR8LTST@(LTNODE,LTIEN),U,3)  Q:GRC'>0
"RTN","RORUTL10",216,0)
 . . . . K BUF
"RTN","RORUTL10",217,0)
 . . . . S BUF(1)=ILDT_U_LTDT_U_LTRES
"RTN","RORUTL10",218,0)
 . . . . S BUF(2)=@ROR8LTST@(LTNODE,LTIEN)
"RTN","RORUTL10",219,0)
 . . . . ;--- Default output
"RTN","RORUTL10",220,0)
 . . . . I ROR8SET=""  S CNT=CNT+1  M @ROR8DST@(CNT)=BUF  Q
"RTN","RORUTL10",221,0)
 . . . . ;--- Callback function
"RTN","RORUTL10",222,0)
 . . . . X ROR8SET
"RTN","RORUTL10",223,0)
 . . . . I RC  S:RC=1 RC=0  Q
"RTN","RORUTL10",224,0)
 . . . . S CNT=CNT+1
"RTN","RORUTL10",225,0)
 . . ;--- Consider all tests
"RTN","RORUTL10",226,0)
 . . S LTLOC="CH;"_LTNODE_";1",LTIEN=""
"RTN","RORUTL10",227,0)
 . . F  S LTIEN=$O(^LAB(60,"C",LTLOC,LTIEN))  Q:LTIEN=""  D  Q:RC
"RTN","RORUTL10",228,0)
 . . . K BUF
"RTN","RORUTL10",229,0)
 . . . S BUF(1)=ILDT_U_LTDT_U_LTRES
"RTN","RORUTL10",230,0)
 . . . S TMP=$$GET1^DIQ(60,LTIEN,.01,,,"RORMSG")
"RTN","RORUTL10",231,0)
 . . . S BUF(2)=LTIEN_U_$S(TMP'="":TMP,1:"Unknown ("_LTIEN_")")
"RTN","RORUTL10",232,0)
 . . . S $P(BUF(2),U,5,6)="CH"_U_LTNODE
"RTN","RORUTL10",233,0)
 . . . ;--- Default output
"RTN","RORUTL10",234,0)
 . . . I ROR8SET=""  S CNT=CNT+1  M @ROR8DST@(CNT)=BUF  Q
"RTN","RORUTL10",235,0)
 . . . ;--- Callback function
"RTN","RORUTL10",236,0)
 . . . X ROR8SET
"RTN","RORUTL10",237,0)
 . . . I RC  S:RC=1 RC=0  Q
"RTN","RORUTL10",238,0)
 . . . S CNT=CNT+1
"RTN","RORUTL10",239,0)
 ;
"RTN","RORUTL10",240,0)
 ;--- Cleanup
"RTN","RORUTL10",241,0)
 K ^TMP("RORUTL10L",$J)
"RTN","RORUTL10",242,0)
 Q $S(RC<0:RC,1:CNT)
"RTN","RORUTL11")
0^114^B2472015
"RTN","RORUTL11",1,0)
RORUTL11 ;HCIOFO/SG - ACCESS AND SECURITY UTILITIES ; 7/21/03 10:28am
"RTN","RORUTL11",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUTL11",3,0)
 ;
"RTN","RORUTL11",4,0)
 Q
"RTN","RORUTL11",5,0)
 ;
"RTN","RORUTL11",6,0)
 ;***** REBUILDS THE "ACL" CROSS-REFERENCE (USER ACCESS)
"RTN","RORUTL11",7,0)
 ;
"RTN","RORUTL11",8,0)
 ; Return Values:
"RTN","RORUTL11",9,0)
 ;       <0  Error code
"RTN","RORUTL11",10,0)
 ;        0  Ok
"RTN","RORUTL11",11,0)
 ;
"RTN","RORUTL11",12,0)
RNDXACL() ;
"RTN","RORUTL11",13,0)
 N DA,DIK,REGIEN,ROOT
"RTN","RORUTL11",14,0)
 S ROOT=$$ROOT^DILFD(798.1,,1)  K @ROOT@("ACL")
"RTN","RORUTL11",15,0)
 S REGIEN=0
"RTN","RORUTL11",16,0)
 F  S REGIEN=$O(@ROOT@(REGIEN))  Q:'REGIEN  D
"RTN","RORUTL11",17,0)
 . S DIK=$$ROOT^DILFD(798.118,","_REGIEN_","),DIK(1)=".01^ACL"
"RTN","RORUTL11",18,0)
 . S DA(1)=REGIEN  D ENALL^DIK
"RTN","RORUTL11",19,0)
 Q 0
"RTN","RORUTL11",20,0)
 ;
"RTN","RORUTL11",21,0)
 ;***** CHECKS IF THE RPC CAN BE CALLED BY THE CURRENT USER
"RTN","RORUTL11",22,0)
 ;
"RTN","RORUTL11",23,0)
 ; RPCNAME       Name of the RPC
"RTN","RORUTL11",24,0)
 ;
"RTN","RORUTL11",25,0)
 ; [REGIEN]      Registry IEN
"RTN","RORUTL11",26,0)
 ;
"RTN","RORUTL11",27,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORUTL11",28,0)
 ;                 A  Administrator Only
"RTN","RORUTL11",29,0)
 ;                 I  IRM Only
"RTN","RORUTL11",30,0)
 ;
"RTN","RORUTL11",31,0)
 ; Return Values:
"RTN","RORUTL11",32,0)
 ;       <0  Error code
"RTN","RORUTL11",33,0)
 ;        0  Ok
"RTN","RORUTL11",34,0)
 ;       >0  Access denied
"RTN","RORUTL11",35,0)
 ;
"RTN","RORUTL11",36,0)
RPCHECK(RPCNAME,REGIEN,FLAGS) ;
"RTN","RORUTL11",37,0)
 N ACCESS,KEY,RC
"RTN","RORUTL11",38,0)
 Q:$G(DUZ)'>0 $$ERROR^RORERR(-40,,,,"DUZ")
"RTN","RORUTL11",39,0)
 S FLAGS=$G(FLAGS),REGIEN=+$G(REGIEN)
"RTN","RORUTL11",40,0)
 ;---
"RTN","RORUTL11",41,0)
 S (ACCESS,RC)=0
"RTN","RORUTL11",42,0)
 D  Q:ACCESS 0
"RTN","RORUTL11",43,0)
 . I REGIEN  Q:$D(^ROR(798.1,"ACL",DUZ,REGIEN))<10
"RTN","RORUTL11",44,0)
 . E  Q:$D(^ROR(798.1,"ACL",DUZ))<10
"RTN","RORUTL11",45,0)
 . I FLAGS["I"  Q:'$D(^XUSEC("ROR VA IRM",DUZ))
"RTN","RORUTL11",46,0)
 . I FLAGS["A"  S RC=1,KEY=""  D  Q:RC
"RTN","RORUTL11",47,0)
 . . F  S KEY=$O(^ROR(798.1,"ACL",DUZ,REGIEN,KEY))  Q:KEY=""  D  Q:'RC
"RTN","RORUTL11",48,0)
 . . . I KEY?1"ROR"1.E  S:KEY["ADMIN" RC=0
"RTN","RORUTL11",49,0)
 . S ACCESS=1
"RTN","RORUTL11",50,0)
 ;---
"RTN","RORUTL11",51,0)
 D ACVIOLTN^RORLOG(X,$G(REGIEN),RPCNAME)
"RTN","RORUTL11",52,0)
 Q 1
"RTN","RORUTL14")
0^168^B9079803
"RTN","RORUTL14",1,0)
RORUTL14 ;HCIOFO/BH,SG - PHARMACY DATA SEARCH ; 11/25/03 10:06am
"RTN","RORUTL14",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUTL14",3,0)
 ;
"RTN","RORUTL14",4,0)
 Q
"RTN","RORUTL14",5,0)
 ;
"RTN","RORUTL14",6,0)
 ;***** SEARCHES THE PHARMACY DATA
"RTN","RORUTL14",7,0)
 ;
"RTN","RORUTL14",8,0)
 ; PATIEN        IEN of the patient (DFN)
"RTN","RORUTL14",9,0)
 ;
"RTN","RORUTL14",10,0)
 ; ROR8RXS       Closed root of a variable, which contains a list
"RTN","RORUTL14",11,0)
 ;               of drugs of interest (in the same format as
"RTN","RORUTL14",12,0)
 ;               the list returned by the $$DRUGLIST^RORUTL16).
"RTN","RORUTL14",13,0)
 ;
"RTN","RORUTL14",14,0)
 ;               If the "*" is passed via this parameter then all
"RTN","RORUTL14",15,0)
 ;               pharmacy orders tests are considered.
"RTN","RORUTL14",16,0)
 ;
"RTN","RORUTL14",17,0)
 ;               If this parameter has a pure numeric value then
"RTN","RORUTL14",18,0)
 ;               it is considered as registry IEN and the default
"RTN","RORUTL14",19,0)
 ;               list of registry specific drugs is automatically
"RTN","RORUTL14",20,0)
 ;               compiled by the $$DRUGLIST^RORUTL16 function.
"RTN","RORUTL14",21,0)
 ;
"RTN","RORUTL14",22,0)
 ; [[.]ROR8DST]  Closed root of an array where the data will be
"RTN","RORUTL14",23,0)
 ;               returned (the ^TMP("RORUTL14",$J), by default).
"RTN","RORUTL14",24,0)
 ;               The data will be stored into the destination
"RTN","RORUTL14",25,0)
 ;               array in following format:
"RTN","RORUTL14",26,0)
 ;
"RTN","RORUTL14",27,0)
 ;                 @ROR8DST@(i,  Additional drug information
"RTN","RORUTL14",28,0)
 ;                                 ^01: Order number
"RTN","RORUTL14",29,0)
 ;                                 ^02: Flags describing the order:
"RTN","RORUTL14",30,0)
 ;                                        I  Inpatient dose
"RTN","RORUTL14",31,0)
 ;                                        O  Outpatient fill
"RTN","RORUTL14",32,0)
 ;                                        P  Pending
"RTN","RORUTL14",33,0)
 ;                                        V  IV
"RTN","RORUTL14",34,0)
 ;                                 ^03: Generic drug IEN (file #50.6)
"RTN","RORUTL14",35,0)
 ;                                 ^04: Generic drug name (E)
"RTN","RORUTL14",36,0)
 ;                                 ^05: Drug class IEN (file #50.605)
"RTN","RORUTL14",37,0)
 ;                                 ^06: Drug class name (E)
"RTN","RORUTL14",38,0)
 ;                   0)          Detailed information on pharmacy
"RTN","RORUTL14",39,0)
 ;                   "RXN",0)    order loaded by the OEL^PSOORRL
"RTN","RORUTL14",40,0)
 ;                   ...
"RTN","RORUTL14",41,0)
 ;
"RTN","RORUTL14",42,0)
 ;               Example:
"RTN","RORUTL14",43,0)
 ;                 S RORDST=$NA(^TMP("RORTMP",$J))
"RTN","RORUTL14",44,0)
 ;                 S RC=$$RXSEARCH^RORUTL14(DFN,REGIEN,RORDST)
"RTN","RORUTL14",45,0)
 ;
"RTN","RORUTL14",46,0)
 ;               If this parameter is passed by reference, you can
"RTN","RORUTL14",47,0)
 ;               provide a full name ($$TAG^ROUTINE) of the callback
"RTN","RORUTL14",48,0)
 ;               function, which will process and store the results,
"RTN","RORUTL14",49,0)
 ;               as the value of the "RORCB" node.
"RTN","RORUTL14",50,0)
 ;
"RTN","RORUTL14",51,0)
 ;               Any additional nodes created in this variable will
"RTN","RORUTL14",52,0)
 ;               be accessible in the callback function. The following
"RTN","RORUTL14",53,0)
 ;               nodes are created automatically:
"RTN","RORUTL14",54,0)
 ;
"RTN","RORUTL14",55,0)
 ;                 "RORDFN"      IEN of the registry patient (DFN)
"RTN","RORUTL14",56,0)
 ;
"RTN","RORUTL14",57,0)
 ;                 "ROREDT"      End date
"RTN","RORUTL14",58,0)
 ;
"RTN","RORUTL14",59,0)
 ;                 "RORFLAGS"    Value of parameter of the same name
"RTN","RORUTL14",60,0)
 ;
"RTN","RORUTL14",61,0)
 ;                 "RORSDT"      Start date
"RTN","RORUTL14",62,0)
 ;                              
"RTN","RORUTL14",63,0)
 ;                 "RORXGEN"     Generic drug
"RTN","RORUTL14",64,0)
 ;                                 ^01: Drug IEN in file #50.6
"RTN","RORUTL14",65,0)
 ;                                 ^02: Generic drug name (E)
"RTN","RORUTL14",66,0)
 ;
"RTN","RORUTL14",67,0)
 ;                 "RORXVCL"     VA Drug class
"RTN","RORUTL14",68,0)
 ;                                 ^01: Class IEN in file #50.605
"RTN","RORUTL14",69,0)
 ;                                 ^02: Class name (E)
"RTN","RORUTL14",70,0)
 ;
"RTN","RORUTL14",71,0)
 ;               The callback function must accept 5 parameters:
"RTN","RORUTL14",72,0)
 ;
"RTN","RORUTL14",73,0)
 ;                 .ROR8DST      Reference to the ROR8DST parameter
"RTN","RORUTL14",74,0)
 ;                               passed into the $$RXSEARCH function.
"RTN","RORUTL14",75,0)
 ;
"RTN","RORUTL14",76,0)
 ;                 ORDER         Order number (from condensed list)
"RTN","RORUTL14",77,0)
 ;
"RTN","RORUTL14",78,0)
 ;                 FLAGS         Flags describing the order to be
"RTN","RORUTL14",79,0)
 ;                               processed.
"RTN","RORUTL14",80,0)
 ;
"RTN","RORUTL14",81,0)
 ;                 DRUG          Dispensed drug
"RTN","RORUTL14",82,0)
 ;                                 ^01: Drug IEN in file #50
"RTN","RORUTL14",83,0)
 ;                                 ^02: Drug name
"RTN","RORUTL14",84,0)
 ;
"RTN","RORUTL14",85,0)
 ;                 DATE          Order date (issue date for outpatient
"RTN","RORUTL14",86,0)
 ;                               drugs or start date for inpatient)
"RTN","RORUTL14",87,0)
 ;
"RTN","RORUTL14",88,0)
 ;               The ^TMP("PS",$J) global node contains the data
"RTN","RORUTL14",89,0)
 ;               returned by the OEL^PSOORRL procedure (see the
"RTN","RORUTL14",90,0)
 ;               DBIA #2400 for details).
"RTN","RORUTL14",91,0)
 ;
"RTN","RORUTL14",92,0)
 ;               The function should return the following values:
"RTN","RORUTL14",93,0)
 ;
"RTN","RORUTL14",94,0)
 ;                 <0  Error code (the search will be aborted)
"RTN","RORUTL14",95,0)
 ;                  0  Ok
"RTN","RORUTL14",96,0)
 ;                  1  Skip this pharmacy order
"RTN","RORUTL14",97,0)
 ;                  2  Skip this and all remaining orders
"RTN","RORUTL14",98,0)
 ;
"RTN","RORUTL14",99,0)
 ;               Example:
"RTN","RORUTL14",100,0)
 ;                 S RORDST=$NA(^TMP("RORBUF",$J))
"RTN","RORUTL14",101,0)
 ;                 S RORDST("RORPTR")=+$O(@RORDST@(""),-1)
"RTN","RORUTL14",102,0)
 ;                 S RORDST("RORCB")="$$RXCB^RORUT999"
"RTN","RORUTL14",103,0)
 ;                 S RC=$$RXSEARCH^RORUTL14(DFN,REGIEN,.RORDST)
"RTN","RORUTL14",104,0)
 ;
"RTN","RORUTL14",105,0)
 ; [RORFLAGS]    Flags to control processing:
"RTN","RORUTL14",106,0)
 ;                 E  Load external values for additional fields
"RTN","RORUTL14",107,0)
 ;                    stored into the output array or passed to
"RTN","RORUTL14",108,0)
 ;                    the callback function. Affected fields
"RTN","RORUTL14",109,0)
 ;                    have the (E) marker.
"RTN","RORUTL14",110,0)
 ;                 I  Include inpatient doses
"RTN","RORUTL14",111,0)
 ;                 O  Include outpatient fills
"RTN","RORUTL14",112,0)
 ;                 P  Include pending orders
"RTN","RORUTL14",113,0)
 ;                 V  Include IV
"RTN","RORUTL14",114,0)
 ;
"RTN","RORUTL14",115,0)
 ;               If this parameter has no value ($G(RORFLAGS)="")
"RTN","RORUTL14",116,0)
 ;               then the default set of flags is used: "IO".
"RTN","RORUTL14",117,0)
 ;
"RTN","RORUTL14",118,0)
 ; RORSDT        Start date (FileMan)
"RTN","RORUTL14",119,0)
 ; [ROREDT]      End date   (FileMan)
"RTN","RORUTL14",120,0)
 ;
"RTN","RORUTL14",121,0)
 ;               The search is performed exactly between provided
"RTN","RORUTL14",122,0)
 ;               boundaries (the time parts are considered).
"RTN","RORUTL14",123,0)
 ;
"RTN","RORUTL14",124,0)
 ; The following global nodes are used by the function:
"RTN","RORUTL14",125,0)
 ;
"RTN","RORUTL14",126,0)
 ; ^TMP("PS",$J)         The OCL^PSOORRL and OEL^PSOORRL procedures
"RTN","RORUTL14",127,0)
 ;                       return the results into this node.
"RTN","RORUTL14",128,0)
 ;
"RTN","RORUTL14",129,0)
 ; ^TMP("RORUTL14",$J)   If the name of the destination array is
"RTN","RORUTL14",130,0)
 ;                       not provided via the ROR8DST parameter
"RTN","RORUTL14",131,0)
 ;                       then the $$RXSEARCH returns the results
"RTN","RORUTL14",132,0)
 ;                       under this node.
"RTN","RORUTL14",133,0)
 ;
"RTN","RORUTL14",134,0)
 ; ^TMP("RORUTL14L",$J)  If the ROR8RXS parameter is undefined
"RTN","RORUTL14",135,0)
 ;                       then a temporary list of registry specific
"RTN","RORUTL14",136,0)
 ;                       drugs is compiled under this node.
"RTN","RORUTL14",137,0)
 ;
"RTN","RORUTL14",138,0)
 ; ^TMP("RORUTL14P",$J)  A temporary list of pharmacy orders is
"RTN","RORUTL14",139,0)
 ;                       stored under this node (see the description
"RTN","RORUTL14",140,0)
 ;                       of $$QUERY^RORUTL15 for details).
"RTN","RORUTL14",141,0)
 ;
"RTN","RORUTL14",142,0)
 ; Return Values:
"RTN","RORUTL14",143,0)
 ;       <0  Error code
"RTN","RORUTL14",144,0)
 ;        0  No ordes have been found
"RTN","RORUTL14",145,0)
 ;       >0  Number of pharmacy orders
"RTN","RORUTL14",146,0)
 ;
"RTN","RORUTL14",147,0)
RXSEARCH(PATIEN,ROR8RXS,ROR8DST,RORFLAGS,RORSDT,ROREDT) ;
"RTN","RORUTL14",148,0)
 N RC,ROR8SET,TMP
"RTN","RORUTL14",149,0)
 S:$G(ROR8DST)="" ROR8DST=$NA(^TMP("RORUTL14",$J))
"RTN","RORUTL14",150,0)
 S RORFLAGS=$S($G(RORFLAGS)'="":RORFLAGS,1:"IO")
"RTN","RORUTL14",151,0)
 Q:$TR(RORFLAGS,"IO")=RORFLAGS 0  ; Neither Inpatient nor Outpatient
"RTN","RORUTL14",152,0)
 Q:$G(ROR8RXS)="" 0               ; No drugs to search for
"RTN","RORUTL14",153,0)
 S:$G(ROREDT)'>0 ROREDT=DT
"RTN","RORUTL14",154,0)
 S RC=0
"RTN","RORUTL14",155,0)
 ;
"RTN","RORUTL14",156,0)
 ;--- Prepare the list of drugs of interest
"RTN","RORUTL14",157,0)
 I (+ROR8RXS)=ROR8RXS  D  Q:RC'>0 RC
"RTN","RORUTL14",158,0)
 . S TMP=ROR8RXS,ROR8RXS=$NA(^TMP("RORUTL14L",$J))
"RTN","RORUTL14",159,0)
 . S RC=$$DRUGLIST^RORUTL16(ROR8RXS,TMP)
"RTN","RORUTL14",160,0)
 I ROR8RXS'="*"  Q:$D(@ROR8RXS)<10 0
"RTN","RORUTL14",161,0)
 ;
"RTN","RORUTL14",162,0)
 D
"RTN","RORUTL14",163,0)
 . ;--- Preselect pharmacy orders
"RTN","RORUTL14",164,0)
 . S RC=$$QUERY^RORUTL15(PATIEN,RORFLAGS,RORSDT,ROREDT)  Q:RC'>0
"RTN","RORUTL14",165,0)
 . ;--- Process selected orders
"RTN","RORUTL14",166,0)
 . S RC=$$PROCESS^RORUTL15(PATIEN,RORFLAGS)              Q:RC'>0
"RTN","RORUTL14",167,0)
 ;
"RTN","RORUTL14",168,0)
 ;--- Cleanup
"RTN","RORUTL14",169,0)
 K ^TMP("RORUTL14L",$J),^TMP("RORUTL14P",$J)
"RTN","RORUTL14",170,0)
 Q RC
"RTN","RORUTL15")
0^169^B30459716
"RTN","RORUTL15",1,0)
RORUTL15 ;HCIOFO/BH,SG - PHARMACY DATA SEARCH (TOOLS) ; 2/17/04 2:18pm
"RTN","RORUTL15",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUTL15",3,0)
 ;
"RTN","RORUTL15",4,0)
 ; This routine uses the following IAs:
"RTN","RORUTL15",5,0)
 ;
"RTN","RORUTL15",6,0)
 ; #2400         OCL^PSOORRL and OEL^PSOORRL (controlled)
"RTN","RORUTL15",7,0)
 ; #221-A        Read access to the file #50
"RTN","RORUTL15",8,0)
 ;               (inherit from the ICR 2.1)
"RTN","RORUTL15",9,0)
 ;
"RTN","RORUTL15",10,0)
 Q
"RTN","RORUTL15",11,0)
 ;
"RTN","RORUTL15",12,0)
 ;***** DOUBLE-CHECKS THE DATES (ORDER, REFILLS AND PARTIALS)
"RTN","RORUTL15",13,0)
 ;
"RTN","RORUTL15",14,0)
 ; Return Values:
"RTN","RORUTL15",15,0)
 ;        0  Ok
"RTN","RORUTL15",16,0)
 ;        1  Skip the order
"RTN","RORUTL15",17,0)
 ;
"RTN","RORUTL15",18,0)
DTCHECK(NREF,NPAR) ;
"RTN","RORUTL15",19,0)
 N IRP,RXDT,SKIP
"RTN","RORUTL15",20,0)
 S RXDT=+$P($G(^TMP("PS",$J,"RXN",0)),U,6)
"RTN","RORUTL15",21,0)
 S SKIP=(RXDT<RORSDT)!(RXDT'<ROREDT)
"RTN","RORUTL15",22,0)
 S (NREF,NPAR)=0
"RTN","RORUTL15",23,0)
 ;--- Refills
"RTN","RORUTL15",24,0)
 S IRP=0
"RTN","RORUTL15",25,0)
 F  S IRP=$O(^TMP("PS",$J,"REF",IRP))  Q:IRP'>0  D
"RTN","RORUTL15",26,0)
 . S RXDT=+$P($G(^TMP("PS",$J,"REF",IRP,0)),U)
"RTN","RORUTL15",27,0)
 . I RXDT'<RORSDT,RXDT<ROREDT  S SKIP=0  Q
"RTN","RORUTL15",28,0)
 . S NREF=NREF+1
"RTN","RORUTL15",29,0)
 . K ^TMP("PS",$J,"REF",IRP)
"RTN","RORUTL15",30,0)
 ;--- Partials
"RTN","RORUTL15",31,0)
 S IRP=0
"RTN","RORUTL15",32,0)
 F  S IRP=$O(^TMP("PS",$J,"PAR",IRP))  Q:IRP'>0  D
"RTN","RORUTL15",33,0)
 . S RXDT=+$P($G(^TMP("PS",$J,"PAR",IRP,0)),U)
"RTN","RORUTL15",34,0)
 . I RXDT'<RORSDT,RXDT<ROREDT  S SKIP=0  Q
"RTN","RORUTL15",35,0)
 . S NPAR=NPAR+1
"RTN","RORUTL15",36,0)
 . K ^TMP("PS",$J,"PAR",IRP)
"RTN","RORUTL15",37,0)
 ;---
"RTN","RORUTL15",38,0)
 Q SKIP
"RTN","RORUTL15",39,0)
 ;
"RTN","RORUTL15",40,0)
 ;***** PROCESSES THE LIST OF PRESELECTED PHARMACY ORDERS
"RTN","RORUTL15",41,0)
 ;
"RTN","RORUTL15",42,0)
 ; PATIEN        IEN of the patient (DFN)
"RTN","RORUTL15",43,0)
 ;
"RTN","RORUTL15",44,0)
 ; FLAGS         Flags to control processing
"RTN","RORUTL15",45,0)
 ;
"RTN","RORUTL15",46,0)
 ; Return Values:
"RTN","RORUTL15",47,0)
 ;       <0  Error code
"RTN","RORUTL15",48,0)
 ;        0  No orders have been found
"RTN","RORUTL15",49,0)
 ;       >0  Number of orders
"RTN","RORUTL15",50,0)
 ;
"RTN","RORUTL15",51,0)
PROCESS(PATIEN,RORFLAGS) ;
"RTN","RORUTL15",52,0)
 N DRUGIEN,DRUGNAME,IEN,IENS,IRP,IRX,LOADEXT,ORDDATE,ORDER,ORDFLG,RC,ROR8BUF,ROR8SET,RORMSG,RXCNT,RXSMODE,SRCHGEN,SRCHVCL,SKIP,TMP
"RTN","RORUTL15",53,0)
 S LOADEXT=(RORFLAGS["E")
"RTN","RORUTL15",54,0)
 S (RC,RORXCNT,SRCHGEN,SRCHVCL)=0
"RTN","RORUTL15",55,0)
 ;
"RTN","RORUTL15",56,0)
 ;--- Determine the storage method (default or callback)
"RTN","RORUTL15",57,0)
 I $G(ROR8DST("RORCB"))?2"$"1.8UN1"^"1.8UN  D
"RTN","RORUTL15",58,0)
 . S ROR8SET="S RC="_ROR8DST("RORCB")_"(.ROR8DST,ORDER"
"RTN","RORUTL15",59,0)
 . S ROR8SET=ROR8SET_",ORDFLG,DRUGIEN_U_DRUGNAME,ORDDATE)"
"RTN","RORUTL15",60,0)
 . ;---
"RTN","RORUTL15",61,0)
 . S ROR8DST("RORDFN")=PATIEN
"RTN","RORUTL15",62,0)
 . S ROR8DST("ROREDT")=ROREDT
"RTN","RORUTL15",63,0)
 . S ROR8DST("RORFLAGS")=RORFLAGS
"RTN","RORUTL15",64,0)
 . S ROR8DST("RORSDT")=RORSDT
"RTN","RORUTL15",65,0)
 E  S ROR8SET=""  K @ROR8DST
"RTN","RORUTL15",66,0)
 ;
"RTN","RORUTL15",67,0)
 ;--- Check if additional search for VA Drug Classes
"RTN","RORUTL15",68,0)
 ;--- and/or Generic Drugs should be performed
"RTN","RORUTL15",69,0)
 I ROR8RXS'="*"  D
"RTN","RORUTL15",70,0)
 . S:$D(@ROR8RXS@("C"))>1 SRCHVCL=1
"RTN","RORUTL15",71,0)
 . S:$D(@ROR8RXS@("G"))>1 SRCHGEN=1
"RTN","RORUTL15",72,0)
 ;
"RTN","RORUTL15",73,0)
 ;--- Process the list of preselected orders
"RTN","RORUTL15",74,0)
 S (IRX,RC)=0
"RTN","RORUTL15",75,0)
 F  S IRX=$O(^TMP("RORUTL14P",$J,IRX))  Q:'IRX  D  Q:RC
"RTN","RORUTL15",76,0)
 . S ORDFLG=$P(^TMP("RORUTL14P",$J,IRX),U)
"RTN","RORUTL15",77,0)
 . S TMP=^TMP("RORUTL14P",$J,IRX,0)
"RTN","RORUTL15",78,0)
 . S ORDER=$P(TMP,U),DRUGNAME=$P(TMP,U,2)
"RTN","RORUTL15",79,0)
 . S ORDDATE=$P(TMP,U,15)
"RTN","RORUTL15",80,0)
 . ;
"RTN","RORUTL15",81,0)
 . ;--- Get detailed information on the order
"RTN","RORUTL15",82,0)
 . K ^TMP("PS",$J)
"RTN","RORUTL15",83,0)
 . D OEL^PSOORRL(PATIEN,ORDER)
"RTN","RORUTL15",84,0)
 . Q:$D(^TMP("PS",$J))<10
"RTN","RORUTL15",85,0)
 . ;
"RTN","RORUTL15",86,0)
 . ;--- Get the drug IEN in the DRUG file (#50)
"RTN","RORUTL15",87,0)
 . S TMP=$G(^TMP("PS",$J,"DD",1,0)),DRUGIEN=+$P(TMP,U,3)
"RTN","RORUTL15",88,0)
 . I DRUGIEN'>0  S DRUGIEN=+$P(TMP,U)  Q:DRUGIEN'>0
"RTN","RORUTL15",89,0)
 . ;
"RTN","RORUTL15",90,0)
 . ;--- Load some drug data
"RTN","RORUTL15",91,0)
 . S IENS=DRUGIEN_","
"RTN","RORUTL15",92,0)
 . D GETS^DIQ(50,IENS,"20;25","I","ROR8BUF","RORMSG")
"RTN","RORUTL15",93,0)
 . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,50,IENS)
"RTN","RORUTL15",94,0)
 . S ROR8DST("RORXGEN")=+$G(ROR8BUF(50,IENS,20,"I")) ; Generic Drug
"RTN","RORUTL15",95,0)
 . S ROR8DST("RORXVCL")=+$G(ROR8BUF(50,IENS,25,"I")) ; VA Class IEN
"RTN","RORUTL15",96,0)
 . ;
"RTN","RORUTL15",97,0)
 . ;--- Check if the drug should be skipped
"RTN","RORUTL15",98,0)
 . I ROR8RXS'="*"  S SKIP=0  D  Q:SKIP
"RTN","RORUTL15",99,0)
 . . Q:$D(@ROR8RXS@(DRUGIEN))
"RTN","RORUTL15",100,0)
 . . I SRCHVCL  Q:$D(@ROR8RXS@("C",ROR8DST("RORXVCL")))
"RTN","RORUTL15",101,0)
 . . I SRCHGEN  Q:$D(@ROR8RXS@("G",ROR8DST("RORXGEN")))
"RTN","RORUTL15",102,0)
 . . S SKIP=1
"RTN","RORUTL15",103,0)
 . ;--- Double-check the dates for outpatient orders
"RTN","RORUTL15",104,0)
 . I ORDFLG["O"  Q:$$DTCHECK()
"RTN","RORUTL15",105,0)
 . ;
"RTN","RORUTL15",106,0)
 . ;--- Load additional drug data
"RTN","RORUTL15",107,0)
 . D:LOADEXT
"RTN","RORUTL15",108,0)
 . . S IENS=DRUGIEN_","
"RTN","RORUTL15",109,0)
 . . D GETS^DIQ(50,IENS,"20;25","E","ROR8BUF","RORMSG")
"RTN","RORUTL15",110,0)
 . . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,50,IENS)
"RTN","RORUTL15",111,0)
 . . S TMP=$G(ROR8BUF(50,IENS,20,"E"))
"RTN","RORUTL15",112,0)
 . . S:TMP="" TMP="Unknown ("_(+ROR8DST("RORXGEN"))_")"
"RTN","RORUTL15",113,0)
 . . S $P(ROR8DST("RORXGEN"),U,2)=TMP
"RTN","RORUTL15",114,0)
 . . S TMP=$G(ROR8BUF(50,IENS,25,"E"))
"RTN","RORUTL15",115,0)
 . . S:TMP="" TMP="Unknown ("_(+ROR8DST("RORXVCL"))_")"
"RTN","RORUTL15",116,0)
 . . S $P(ROR8DST("RORXVCL"),U,2)=TMP
"RTN","RORUTL15",117,0)
 . ;
"RTN","RORUTL15",118,0)
 . ;--- Default output
"RTN","RORUTL15",119,0)
 . I ROR8SET=""  D  Q
"RTN","RORUTL15",120,0)
 . . S RORXCNT=RORXCNT+1
"RTN","RORUTL15",121,0)
 . . M @ROR8DST@(RORXCNT)=^TMP("PS",$J)
"RTN","RORUTL15",122,0)
 . . S TMP=ORDER_U_ORDFLG_U_ROR8DST("RORXGEN")
"RTN","RORUTL15",123,0)
 . . S $P(TMP,U,5,6)=ROR8DST("RORXVCL")
"RTN","RORUTL15",124,0)
 . . S @ROR8DST@(RORXCNT)=TMP
"RTN","RORUTL15",125,0)
 . ;--- Callback function
"RTN","RORUTL15",126,0)
 . X ROR8SET
"RTN","RORUTL15",127,0)
 . I RC  S:RC=1 RC=0  Q
"RTN","RORUTL15",128,0)
 . S RORXCNT=RORXCNT+1
"RTN","RORUTL15",129,0)
 ;---
"RTN","RORUTL15",130,0)
 Q $S(RC<0:RC,1:RORXCNT)
"RTN","RORUTL15",131,0)
 ;
"RTN","RORUTL15",132,0)
 ;***** LOADS AND PRESELECTS PHARMACY ORDERS
"RTN","RORUTL15",133,0)
 ;
"RTN","RORUTL15",134,0)
 ; PATIEN        IEN of the patient (DFN)
"RTN","RORUTL15",135,0)
 ;
"RTN","RORUTL15",136,0)
 ; FLAGS         Flags to control processing
"RTN","RORUTL15",137,0)
 ;
"RTN","RORUTL15",138,0)
 ; STDT          Start date (FileMan)
"RTN","RORUTL15",139,0)
 ; ENDT          End date   (FileMan)
"RTN","RORUTL15",140,0)
 ;
"RTN","RORUTL15",141,0)
 ; The temporary list of preselected pharmacy orders is compiled
"RTN","RORUTL15",142,0)
 ; under the ^TMP("RORUTL14P",$J) global node:
"RTN","RORUTL15",143,0)
 ;
"RTN","RORUTL15",144,0)
 ; ^TMP("RORUTL14P",$J,
"RTN","RORUTL15",145,0)
 ;   Seq#,               Flags that describe the order (I,O,P, etc.)
"RTN","RORUTL15",146,0)
 ;     0)                Content of the ^TMP("PS",$J,i,0) node
"RTN","RORUTL15",147,0)
 ;                       returned by the OCL^PSOORRL (see the DBIA
"RTN","RORUTL15",148,0)
 ;                       #2400 for details).
"RTN","RORUTL15",149,0)
 ;
"RTN","RORUTL15",150,0)
 ; Return Values:
"RTN","RORUTL15",151,0)
 ;       <0  Error code
"RTN","RORUTL15",152,0)
 ;        0  No orders have been found
"RTN","RORUTL15",153,0)
 ;       >0  Number of orders
"RTN","RORUTL15",154,0)
 ;
"RTN","RORUTL15",155,0)
QUERY(PATIEN,FLAGS,STDT,ENDT) ;
"RTN","RORUTL15",156,0)
 N IEN,IRX,ORDER,RXCNT,TMP,TYPE
"RTN","RORUTL15",157,0)
 K ^TMP("PS",$J),^TMP($J,"RORUTL14P")
"RTN","RORUTL15",158,0)
 ;
"RTN","RORUTL15",159,0)
 ;--- Prepare the flags
"RTN","RORUTL15",160,0)
 I FLAGS["I"  D  S TYPE("U;I")="I"
"RTN","RORUTL15",161,0)
 . S:FLAGS["P" TYPE("P;I")="IP"
"RTN","RORUTL15",162,0)
 . S:FLAGS["V" TYPE("V;I")="IV"
"RTN","RORUTL15",163,0)
 I FLAGS["O"  D  S TYPE("R;O")="O"
"RTN","RORUTL15",164,0)
 . S:FLAGS["P" TYPE("P;O")="OP"
"RTN","RORUTL15",165,0)
 ;
"RTN","RORUTL15",166,0)
 ;--- Load the list of pharmacy orders
"RTN","RORUTL15",167,0)
 D OCL^PSOORRL(PATIEN,STDT,ENDT)
"RTN","RORUTL15",168,0)
 Q:$D(^TMP("PS",$J))<10 0
"RTN","RORUTL15",169,0)
 ;
"RTN","RORUTL15",170,0)
 ;--- Preselect the orders
"RTN","RORUTL15",171,0)
 S (IRX,RXCNT)=0
"RTN","RORUTL15",172,0)
 F  S IRX=$O(^TMP("PS",$J,IRX))  Q:'IRX  D
"RTN","RORUTL15",173,0)
 . S ORDER=$P($G(^TMP("PS",$J,IRX,0)),U)  Q:ORDER'>0
"RTN","RORUTL15",174,0)
 . ;--- Check the type of order
"RTN","RORUTL15",175,0)
 . S TMP=$L(ORDER),TYPE=$E(ORDER,TMP-2,TMP)
"RTN","RORUTL15",176,0)
 . S TYPE=$G(TYPE(TYPE))  Q:TYPE=""
"RTN","RORUTL15",177,0)
 . ;--- Double-check the dates
"RTN","RORUTL15",178,0)
 . I TYPE["I"  D  Q:(TMP<STDT)!(TMP'<ENDT)
"RTN","RORUTL15",179,0)
 . . S TMP=+$P($G(^TMP("PS",$J,IRX,0)),U,15)
"RTN","RORUTL15",180,0)
 . I TYPE["O"  D  Q:TMP<STDT
"RTN","RORUTL15",181,0)
 . . S TMP=+$P($G(^TMP("PS",$J,IRX,0)),U,10)
"RTN","RORUTL15",182,0)
 . ;--- Select the order
"RTN","RORUTL15",183,0)
 . S RXCNT=RXCNT+1,^TMP("RORUTL14P",$J,RXCNT)=TYPE
"RTN","RORUTL15",184,0)
 . S ^TMP("RORUTL14P",$J,RXCNT,0)=^TMP("PS",$J,IRX,0)
"RTN","RORUTL15",185,0)
 ;
"RTN","RORUTL15",186,0)
 ;--- Cleanup
"RTN","RORUTL15",187,0)
 K ^TMP("PS",$J)
"RTN","RORUTL15",188,0)
 Q RXCNT
"RTN","RORUTL16")
0^170^B10030242
"RTN","RORUTL16",1,0)
RORUTL16 ;HCIOFO/SG - PHARMACY DATA SEARCH (UTILITIES) ; 1/14/04 2:45pm
"RTN","RORUTL16",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUTL16",3,0)
 ;
"RTN","RORUTL16",4,0)
 ; This routine uses the following IAs:
"RTN","RORUTL16",5,0)
 ;
"RTN","RORUTL16",6,0)
 ; #221-A        "AND" and "VAC" x-refs of file #50
"RTN","RORUTL16",7,0)
 ; #221-A        Read access to file #50
"RTN","RORUTL16",8,0)
 ;               (inherit from ICR 2.1)
"RTN","RORUTL16",9,0)
 ;
"RTN","RORUTL16",10,0)
 Q
"RTN","RORUTL16",11,0)
 ;
"RTN","RORUTL16",12,0)
 ;***** LOADS THE LIST OF REGISTRY SPECIFIC DRUGS
"RTN","RORUTL16",13,0)
 ;
"RTN","RORUTL16",14,0)
 ; ROR8DST       Closed root of the destination buffer
"RTN","RORUTL16",15,0)
 ;
"RTN","RORUTL16",16,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL16",17,0)
 ;
"RTN","RORUTL16",18,0)
 ; FLAGS         Flags to control processing:
"RTN","RORUTL16",19,0)
 ;                 A  Do not kill the destination array before
"RTN","RORUTL16",20,0)
 ;                    loading the drugs (Add the drugs)
"RTN","RORUTL16",21,0)
 ;                 C  Include VA drug classes from the file #798.6
"RTN","RORUTL16",22,0)
 ;                 D  Include local (dispensed) drugs from the LOCAL
"RTN","RORUTL16",23,0)
 ;                    DRUG NAME multiple of the file #798.1
"RTN","RORUTL16",24,0)
 ;                 G  Include generic drugs from the file #799.51
"RTN","RORUTL16",25,0)
 ;                 R  Reduce everything to local (dispensed) drugs
"RTN","RORUTL16",26,0)
 ;
"RTN","RORUTL16",27,0)
 ;               If this parameter has no value ($G(FLAGS)="") then
"RTN","RORUTL16",28,0)
 ;               the default set of flags is used: "DGR".
"RTN","RORUTL16",29,0)
 ;
"RTN","RORUTL16",30,0)
 ; Return Values:
"RTN","RORUTL16",31,0)
 ;       <0  Error code
"RTN","RORUTL16",32,0)
 ;        0  Ok
"RTN","RORUTL16",33,0)
 ;
"RTN","RORUTL16",34,0)
 ; The list of drugs is returned as follow:
"RTN","RORUTL16",35,0)
 ;
"RTN","RORUTL16",36,0)
 ; @ROR8DST@(
"RTN","RORUTL16",37,0)
 ;   DrugIEN)            ""
"RTN","RORUTL16",38,0)
 ;   "C",
"RTN","RORUTL16",39,0)
 ;     VAClassIEN)       ""
"RTN","RORUTL16",40,0)
 ;   "G",
"RTN","RORUTL16",41,0)
 ;     GenericDrugIEN)   ""
"RTN","RORUTL16",42,0)
 ;
"RTN","RORUTL16",43,0)
 ; DrugIEN is an internal entry number of the local drug record
"RTN","RORUTL16",44,0)
 ; in the DRUG file (#50).
"RTN","RORUTL16",45,0)
 ;
"RTN","RORUTL16",46,0)
 ; Nodes "C" and/or "G" are created only if the R flag is not used.
"RTN","RORUTL16",47,0)
 ; Otherwise, VA drug classes and generic drugs are reduced to the
"RTN","RORUTL16",48,0)
 ; local (dispensed) drugs.
"RTN","RORUTL16",49,0)
 ;
"RTN","RORUTL16",50,0)
DRUGLIST(ROR8DST,REGIEN,FLAGS) ;
"RTN","RORUTL16",51,0)
 N DRUGIEN,IEN,NDFP,RC,REDUCE,ROOT,RORMSG,VACLIEN
"RTN","RORUTL16",52,0)
 S FLAGS=$S($G(FLAGS)'="":FLAGS,1:"DGR")
"RTN","RORUTL16",53,0)
 S REDUCE=(FLAGS["R")  K:FLAGS'["A" @ROR8DST
"RTN","RORUTL16",54,0)
 ;
"RTN","RORUTL16",55,0)
 ;--- Drug classes
"RTN","RORUTL16",56,0)
 D:FLAGS["C"
"RTN","RORUTL16",57,0)
 . S IEN=0
"RTN","RORUTL16",58,0)
 . F  S IEN=$O(^ROR(798.6,"AC",REGIEN,IEN))  Q:IEN'>0  D
"RTN","RORUTL16",59,0)
 . . D RXADDVCL(ROR8DST,+$G(^ROR(798.6,IEN,0)),REDUCE)
"RTN","RORUTL16",60,0)
 ;
"RTN","RORUTL16",61,0)
 ;--- Local drug names
"RTN","RORUTL16",62,0)
 D:FLAGS["D"
"RTN","RORUTL16",63,0)
 . S ROOT=$$ROOT^DILFD(798.129,","_REGIEN_",",1)
"RTN","RORUTL16",64,0)
 . S IEN=0
"RTN","RORUTL16",65,0)
 . F  S IEN=$O(@ROOT@(IEN))  Q:IEN'>0  D
"RTN","RORUTL16",66,0)
 . . S DRUGIEN=+$P($G(@ROOT@(IEN,0)),U)
"RTN","RORUTL16",67,0)
 . . S:DRUGIEN>0 @ROR8DST@(DRUGIEN)=""
"RTN","RORUTL16",68,0)
 ;
"RTN","RORUTL16",69,0)
 ;--- Generic drugs
"RTN","RORUTL16",70,0)
 D:FLAGS["G"
"RTN","RORUTL16",71,0)
 . N RGS  S RGS=REGIEN_"#",DRUGIEN=0
"RTN","RORUTL16",72,0)
 . F  S DRUGIEN=$O(^ROR(799.51,"ARDG",RGS,DRUGIEN))  Q:DRUGIEN'>0  D
"RTN","RORUTL16",73,0)
 . . D RXADDGEN(ROR8DST,DRUGIEN,REDUCE)
"RTN","RORUTL16",74,0)
 Q 0
"RTN","RORUTL16",75,0)
 ;
"RTN","RORUTL16",76,0)
 ;***** LOADS PHARMACY ORDER DATA
"RTN","RORUTL16",77,0)
 ;
"RTN","RORUTL16",78,0)
 ; .ROR8DST      Reference to the ROR8DST parameter
"RTN","RORUTL16",79,0)
 ;               passed into the callback function.
"RTN","RORUTL16",80,0)
 ;
"RTN","RORUTL16",81,0)
 ; ORDFLGS       Flags describing the original order
"RTN","RORUTL16",82,0)
 ;
"RTN","RORUTL16",83,0)
 ; Return Values:
"RTN","RORUTL16",84,0)
 ;       <0  Error code
"RTN","RORUTL16",85,0)
 ;        0  Ok
"RTN","RORUTL16",86,0)
 ;        1  Skip this refill
"RTN","RORUTL16",87,0)
 ;
"RTN","RORUTL16",88,0)
ORDER(ROR8DST,ORDFLGS) ;
"RTN","RORUTL16",89,0)
 N DATE,FILLTYPE
"RTN","RORUTL16",90,0)
 D:ORDFLGS["I"
"RTN","RORUTL16",91,0)
 . S DATE=$P(RORRXE(0),U,5),FILLTYPE="I"
"RTN","RORUTL16",92,0)
 D:ORDFLGS["O"
"RTN","RORUTL16",93,0)
 . S DATE=$P(RORRXE("RXN",0),U,6)
"RTN","RORUTL16",94,0)
 . S FILLTYPE=$P(RORRXE("RXN",0),U,3)
"RTN","RORUTL16",95,0)
 Q
"RTN","RORUTL16",96,0)
 ;
"RTN","RORUTL16",97,0)
 ;***** ADDS THE GENERIC DRUG TO THE LIST OF DRUGS
"RTN","RORUTL16",98,0)
 ;
"RTN","RORUTL16",99,0)
 ; ROR8DST       Closed root of the destination buffer
"RTN","RORUTL16",100,0)
 ;
"RTN","RORUTL16",101,0)
 ; VACLIEN       IEN of a VA drug class
"RTN","RORUTL16",102,0)
 ;
"RTN","RORUTL16",103,0)
 ; [REDUCE]      Reduce the class to a list of local drugs
"RTN","RORUTL16",104,0)
 ;
"RTN","RORUTL16",105,0)
 ; [GROUP]       Drug group ID
"RTN","RORUTL16",106,0)
 ;
"RTN","RORUTL16",107,0)
RXADDGEN(ROR8DST,GENIEN,REDUCE,GROUP) ;
"RTN","RORUTL16",108,0)
 Q:GENIEN'>0
"RTN","RORUTL16",109,0)
 I '$G(REDUCE)  S @ROR8DST@("G",GENIEN)=$G(GROUP)  Q
"RTN","RORUTL16",110,0)
 N DRUGIEN  S DRUGIEN=0
"RTN","RORUTL16",111,0)
 F  S DRUGIEN=$O(^PSDRUG("AND",GENIEN,DRUGIEN))  Q:DRUGIEN'>0  D
"RTN","RORUTL16",112,0)
 . S @ROR8DST@(DRUGIEN)=$G(GROUP)
"RTN","RORUTL16",113,0)
 Q
"RTN","RORUTL16",114,0)
 ;
"RTN","RORUTL16",115,0)
 ;***** ADDS THE VA DRUG CLASS TO THE LIST OF DRUGS
"RTN","RORUTL16",116,0)
 ;
"RTN","RORUTL16",117,0)
 ; ROR8DST       Closed root of the destination buffer
"RTN","RORUTL16",118,0)
 ;
"RTN","RORUTL16",119,0)
 ; VACL          Either IEN or code of a VA drug class
"RTN","RORUTL16",120,0)
 ;
"RTN","RORUTL16",121,0)
 ; [REDUCE]      Reduce the class to a list of local drugs
"RTN","RORUTL16",122,0)
 ;
"RTN","RORUTL16",123,0)
 ; [FLAGS]       Flags to control processing:
"RTN","RORUTL16",124,0)
 ;                 E  Always treat content of the VACL parameter as
"RTN","RORUTL16",125,0)
 ;                    a code of the VA Drug Class (instead of IEN)
"RTN","RORUTL16",126,0)
 ;
"RTN","RORUTL16",127,0)
RXADDVCL(ROR8DST,VACL,REDUCE,FLAGS) ;
"RTN","RORUTL16",128,0)
 N DRUGIEN,RORMSG,VACLIEN
"RTN","RORUTL16",129,0)
 S VACLIEN=+VACL
"RTN","RORUTL16",130,0)
 D:(VACLIEN'=VACL)!($G(FLAGS)["E")
"RTN","RORUTL16",131,0)
 . S VACLIEN=$$FIND1^DIC(50.605,,,VACL,"B",,"RORMSG")
"RTN","RORUTL16",132,0)
 . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,50.605)
"RTN","RORUTL16",133,0)
 Q:VACLIEN'>0
"RTN","RORUTL16",134,0)
 ;---
"RTN","RORUTL16",135,0)
 I '$G(REDUCE)  S @ROR8DST@("C",VACLIEN)=""  Q
"RTN","RORUTL16",136,0)
 S DRUGIEN=0
"RTN","RORUTL16",137,0)
 F  S DRUGIEN=$O(^PSDRUG("VAC",VACLIEN,DRUGIEN))  Q:DRUGIEN'>0  D
"RTN","RORUTL16",138,0)
 . S @ROR8DST@(DRUGIEN)=""
"RTN","RORUTL16",139,0)
 Q
"RTN","RORUTL17")
0^180^B53261399
"RTN","RORUTL17",1,0)
RORUTL17 ;HCIOFO/SG - REGISTRY INFORMATION UTILITIES ; 2/9/04 1:26pm
"RTN","RORUTL17",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORUTL17",3,0)
 ;
"RTN","RORUTL17",4,0)
 Q
"RTN","RORUTL17",5,0)
 ;
"RTN","RORUTL17",6,0)
 ;***** ADDS THE PENDING PATIENT TO THE LIST
"RTN","RORUTL17",7,0)
 ;
"RTN","RORUTL17",8,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL17",9,0)
 ; IEN           IEN of the registry record
"RTN","RORUTL17",10,0)
 ; PATIEN        Patient IEN (DFN)
"RTN","RORUTL17",11,0)
 ;
"RTN","RORUTL17",12,0)
 ; Return Values:
"RTN","RORUTL17",13,0)
 ;       <0  Error code
"RTN","RORUTL17",14,0)
 ;        0  Ok
"RTN","RORUTL17",15,0)
 ;
"RTN","RORUTL17",16,0)
ADDPP(REGIEN,IEN,PATIEN) ;
"RTN","RORUTL17",17,0)
 N BUF,I,NODE,IEN1,TMP,VA,VADM
"RTN","RORUTL17",18,0)
 D VADEM^RORUTL05(PATIEN)
"RTN","RORUTL17",19,0)
 S @ROR8DST@("PPL",PATIEN)=IEN_U_$$XOR^RORUTL03($P($G(VADM(3)),U))
"RTN","RORUTL17",20,0)
 ;--- Dates of selection rules
"RTN","RORUTL17",21,0)
 S NODE=$$ROOT^DILFD(798.01,","_IEN_",",1),BUF=""
"RTN","RORUTL17",22,0)
 S IEN1=0
"RTN","RORUTL17",23,0)
 F  S IEN1=$O(@NODE@(IEN1))  Q:IEN1'>0  D
"RTN","RORUTL17",24,0)
 . S TMP=$G(@NODE@(IEN1,0)),I=+$G(RORSRL(+TMP))
"RTN","RORUTL17",25,0)
 . S:I>0 $P(BUF,U,I)=$P(TMP,U,2)
"RTN","RORUTL17",26,0)
 S @ROR8DST@("PPL",PATIEN,1)=BUF
"RTN","RORUTL17",27,0)
 Q 0
"RTN","RORUTL17",28,0)
 ;
"RTN","RORUTL17",29,0)
 ;***** FORMATS THE DATE
"RTN","RORUTL17",30,0)
DATE(DATE) ;
"RTN","RORUTL17",31,0)
 Q $S(DATE>1:$$FMTE^XLFDT(DATE\1,"5Z"),1:"")
"RTN","RORUTL17",32,0)
 ;
"RTN","RORUTL17",33,0)
 ;***** LOADS THE LIST OF SELECTION RULES
"RTN","RORUTL17",34,0)
 ;
"RTN","RORUTL17",35,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL17",36,0)
 ; .SRLST        Reference to a local variable for the
"RTN","RORUTL17",37,0)
 ;               list of selection rules
"RTN","RORUTL17",38,0)
 ;
"RTN","RORUTL17",39,0)
 ; Return Values:
"RTN","RORUTL17",40,0)
 ;       <0  Error code
"RTN","RORUTL17",41,0)
 ;        0  Ok
"RTN","RORUTL17",42,0)
 ;
"RTN","RORUTL17",43,0)
LOADSRL(REGIEN,SRLST) ;
"RTN","RORUTL17",44,0)
 N IEN,NAME,NODE
"RTN","RORUTL17",45,0)
 S NODE=$$ROOT^DILFD(798.2,,1)
"RTN","RORUTL17",46,0)
 S IEN=0
"RTN","RORUTL17",47,0)
 F  S IEN=$O(@NODE@(IEN))  Q:IEN'>0  D
"RTN","RORUTL17",48,0)
 . S NAME=$P($G(@NODE@(IEN,0)),U)  Q:NAME=""
"RTN","RORUTL17",49,0)
 . I NAME?1"VA"1.E1"LAB".E      S SRLST(IEN)="1^LAB"      Q
"RTN","RORUTL17",50,0)
 . I NAME?1"VA"1.E1"PROBLEM".E  S SRLST(IEN)="2^PROBLEM"  Q
"RTN","RORUTL17",51,0)
 . I NAME?1"VA"1.E1"PTF".E      S SRLST(IEN)="3^PTF"      Q
"RTN","RORUTL17",52,0)
 . I NAME?1"VA"1.E1"VPOV".E     S SRLST(IEN)="4^VISIT"    Q
"RTN","RORUTL17",53,0)
 . I NAME?1"VA"1.E1"VISIT".E    S SRLST(IEN)="4^VISIT"    Q
"RTN","RORUTL17",54,0)
 Q 0
"RTN","RORUTL17",55,0)
 ;
"RTN","RORUTL17",56,0)
 ;***** COUNTS PATIENTS WITH ERRORS
"RTN","RORUTL17",57,0)
 ;
"RTN","RORUTL17",58,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL17",59,0)
 ;
"RTN","RORUTL17",60,0)
 ; Return Values:
"RTN","RORUTL17",61,0)
 ;       <0  Error code
"RTN","RORUTL17",62,0)
 ;        0  Ok
"RTN","RORUTL17",63,0)
 ;       >0  Number of patients with errors
"RTN","RORUTL17",64,0)
 ;
"RTN","RORUTL17",65,0)
PTERR(REGIEN,SPI) ;
"RTN","RORUTL17",66,0)
 N CNT,IEN,NODE,RC,TMP
"RTN","RORUTL17",67,0)
 W:SPI !,"Counting patients with errors",!
"RTN","RORUTL17",68,0)
 S NODE=$$ROOT^DILFD(798.3,,1),(CNT,RC)=0
"RTN","RORUTL17",69,0)
 S IEN=0
"RTN","RORUTL17",70,0)
 F  S IEN=$O(@NODE@(IEN))  Q:IEN'>0  D
"RTN","RORUTL17",71,0)
 . W:SPI "."
"RTN","RORUTL17",72,0)
 . S:$D(@NODE@(IEN,1,"B",REGIEN)) CNT=CNT+1
"RTN","RORUTL17",73,0)
 Q $S(RC<0:RC,1:CNT)
"RTN","RORUTL17",74,0)
 ;
"RTN","RORUTL17",75,0)
 ;***** GATHERS THE INFORMATION ABOUT THE REGISTRY
"RTN","RORUTL17",76,0)
 ;
"RTN","RORUTL17",77,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL17",78,0)
 ;
"RTN","RORUTL17",79,0)
 ; ROR8DST       Closed root of the destination array
"RTN","RORUTL17",80,0)
 ;
"RTN","RORUTL17",81,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORUTL17",82,0)
 ;                 E  Count patients with errors in the
"RTN","RORUTL17",83,0)
 ;                    ROR PENDING PATIENT file
"RTN","RORUTL17",84,0)
 ;                 P  Include list of pending patients
"RTN","RORUTL17",85,0)
 ;                 S  Show the progress indicator
"RTN","RORUTL17",86,0)
 ;
"RTN","RORUTL17",87,0)
 ; @ROR8DST@(
"RTN","RORUTL17",88,0)
 ;   "DTACKMAX")         The latest and the earliest dates by which
"RTN","RORUTL17",89,0)
 ;   "DTACKMIN")         patient data transmissions are acknowledged
"RTN","RORUTL17",90,0)
 ;
"RTN","RORUTL17",91,0)
 ;   "NPA")              Number of active patients
"RTN","RORUTL17",92,0)
 ;   "NPE")              Number of patients with errors in the
"RTN","RORUTL17",93,0)
 ;                       ROR PENDING PATIENT file
"RTN","RORUTL17",94,0)
 ;   "NPP")              Number of pending patients
"RTN","RORUTL17",95,0)
 ;   "NPT")              Total number of patients in the registry
"RTN","RORUTL17",96,0)
 ;                       (including inactive and pending)
"RTN","RORUTL17",97,0)
 ;
"RTN","RORUTL17",98,0)
 ;   "PPL",
"RTN","RORUTL17",99,0)
 ;     0,1)              Map of the corresponding data subnode
"RTN","RORUTL17",100,0)
 ;                       (field names separated by ^)
"RTN","RORUTL17",101,0)
 ;     DFN)              Pending patient
"RTN","RORUTL17",102,0)
 ;                         ^01: IEN of the registry record
"RTN","RORUTL17",103,0)
 ;                         ^02: Coded SSN
"RTN","RORUTL17",104,0)
 ;     DFN,1)
"RTN","RORUTL17",105,0)
 ;                       Dates of the selection rules
"RTN","RORUTL17",106,0)
 ;                         ^01: LAB
"RTN","RORUTL17",107,0)
 ;                         ^02: PROBLEM
"RTN","RORUTL17",108,0)
 ;                         ^03: PTF
"RTN","RORUTL17",109,0)
 ;                         ^04: VISIT
"RTN","RORUTL17",110,0)
 ;
"RTN","RORUTL17",111,0)
 ; Return Values:
"RTN","RORUTL17",112,0)
 ;       <0  Error code
"RTN","RORUTL17",113,0)
 ;        0  Ok
"RTN","RORUTL17",114,0)
 ;       >0  Number of ignored errors
"RTN","RORUTL17",115,0)
 ;
"RTN","RORUTL17",116,0)
REGINFO(REGIEN,ROR8DST,FLAGS) ;
"RTN","RORUTL17",117,0)
 N RORECNT       ; Number of errors
"RTN","RORUTL17",118,0)
 N RORSRL        ; List of selection rules
"RTN","RORUTL17",119,0)
 ;
"RTN","RORUTL17",120,0)
 N COUNTS,CPPL,DTACKMIN,DTACKMAX,IEN,IENS,NODE,PTSTAT,RC,RORBUF,RORMSG,SPI,TMP
"RTN","RORUTL17",121,0)
 S FLAGS=$G(FLAGS),SPI=(FLAGS["S"),CPPL=(FLAGS["P")
"RTN","RORUTL17",122,0)
 S DTACKMIN=999999999,DTACKMAX=0
"RTN","RORUTL17",123,0)
 K @ROR8DST  S (RC,RORECNT)=0
"RTN","RORUTL17",124,0)
 ;
"RTN","RORUTL17",125,0)
 ;--- Load the list of selection rules
"RTN","RORUTL17",126,0)
 I CPPL  S RC=$$LOADSRL(REGIEN,.RORSRL)  Q:RC<0 RC
"RTN","RORUTL17",127,0)
 ;
"RTN","RORUTL17",128,0)
 ;--- Examine registry records
"RTN","RORUTL17",129,0)
 W:SPI !,"Examining registry records",!
"RTN","RORUTL17",130,0)
 S NODE=$$ROOT^DILFD(798,,1)
"RTN","RORUTL17",131,0)
 S IEN=0
"RTN","RORUTL17",132,0)
 F  S IEN=$O(@NODE@("AC",REGIEN,IEN))  Q:IEN'>0  D
"RTN","RORUTL17",133,0)
 . W:SPI "."
"RTN","RORUTL17",134,0)
 . S COUNTS("NPT")=$G(COUNTS("NPT"))+1  ; Total number of patients
"RTN","RORUTL17",135,0)
 . ;--- Load the data
"RTN","RORUTL17",136,0)
 . S IENS=IEN_","  K RORBUF
"RTN","RORUTL17",137,0)
 . D GETS^DIQ(798,IENS,".01;3;9.1","I","RORBUF","RORMSG")
"RTN","RORUTL17",138,0)
 . I $G(DIERR)  D  S RORECNT=RORECNT+1  Q
"RTN","RORUTL17",139,0)
 . . D DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","RORUTL17",140,0)
 . S PTSTAT=+$G(RORBUF(798,IENS,3,"I"))
"RTN","RORUTL17",141,0)
 . ;--- Number of active patients
"RTN","RORUTL17",142,0)
 . D:$$ACTIVE^RORDD(IEN)
"RTN","RORUTL17",143,0)
 . . S COUNTS("NPA")=$G(COUNTS("NPA"))+1
"RTN","RORUTL17",144,0)
 . . S TMP=+$G(RORBUF(798,IENS,9.1,"I"))
"RTN","RORUTL17",145,0)
 . . I TMP>0  S:TMP<DTACKMIN DTACKMIN=TMP  S:TMP>DTACKMAX DTACKMAX=TMP
"RTN","RORUTL17",146,0)
 . ;--- Add a pending patient to the list
"RTN","RORUTL17",147,0)
 . I PTSTAT=4  D:CPPL  S COUNTS("NPP")=$G(COUNTS("NPP"))+1
"RTN","RORUTL17",148,0)
 . . S TMP=$$ADDPP(REGIEN,IEN,+RORBUF(798,IENS,.01,"I"))
"RTN","RORUTL17",149,0)
 ;
"RTN","RORUTL17",150,0)
 ;--- Count patients with errors
"RTN","RORUTL17",151,0)
 I FLAGS["E"  D  Q:RC<0 RC  S @ROR8DST@("NPE")=RC
"RTN","RORUTL17",152,0)
 . S RC=$$PTERR(REGIEN,SPI)
"RTN","RORUTL17",153,0)
 ;
"RTN","RORUTL17",154,0)
 ;--- Success
"RTN","RORUTL17",155,0)
 I DTACKMAX>0  D
"RTN","RORUTL17",156,0)
 . S @ROR8DST@("DTACKMIN")=DTACKMIN
"RTN","RORUTL17",157,0)
 . S @ROR8DST@("DTACKMAX")=DTACKMAX
"RTN","RORUTL17",158,0)
 E  F TMP="MIN","MAX"  S @ROR8DST@("DTACK"_TMP)=""
"RTN","RORUTL17",159,0)
 I CPPL  D:$G(COUNTS("NPP"))>0
"RTN","RORUTL17",160,0)
 . S RORBUF="",TMP=0
"RTN","RORUTL17",161,0)
 . F  S TMP=$O(RORSRL(TMP))  Q:TMP'>0  D
"RTN","RORUTL17",162,0)
 . . S $P(RORBUF,U,+RORSRL(TMP))=$P(RORSRL(TMP),U,2)
"RTN","RORUTL17",163,0)
 . S @ROR8DST@("PPL",0,1)=RORBUF
"RTN","RORUTL17",164,0)
 F TMP="NPA","NPP","NPT"  S @ROR8DST@(TMP)=+$G(COUNTS(TMP))
"RTN","RORUTL17",165,0)
 Q RORECNT
"RTN","RORUTL17",166,0)
 ;
"RTN","RORUTL17",167,0)
 ;***** E-MAILS THE INFORMATION ABOUT THE REGISTRY
"RTN","RORUTL17",168,0)
 ;
"RTN","RORUTL17",169,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL17",170,0)
 ;
"RTN","RORUTL17",171,0)
 ; [EMAIL]       E-mail address where the data will be sent to
"RTN","RORUTL17",172,0)
 ;
"RTN","RORUTL17",173,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORUTL17",174,0)
 ;                 E  Count patients with errors in the
"RTN","RORUTL17",175,0)
 ;                    ROR PENDING PATIENT file
"RTN","RORUTL17",176,0)
 ;                 P  Include list of pending patients
"RTN","RORUTL17",177,0)
 ;                 S  Show the progress indicator
"RTN","RORUTL17",178,0)
 ;
"RTN","RORUTL17",179,0)
 ; The ^TMP("RORSETU3I",$J) and ^TMP("RORSETU3M",$J) global nodes are 
"RTN","RORUTL17",180,0)
 ; used by this function.
"RTN","RORUTL17",181,0)
 ;
"RTN","RORUTL17",182,0)
 ; Return Values:
"RTN","RORUTL17",183,0)
 ;       <0  Error code
"RTN","RORUTL17",184,0)
 ;        0  Ok
"RTN","RORUTL17",185,0)
 ;
"RTN","RORUTL17",186,0)
SENDINFO(REGIEN,EMAIL,FLAGS) ;
"RTN","RORUTL17",187,0)
 Q:'$$CCRNTFY^RORUTL05(REGIEN) 0
"RTN","RORUTL17",188,0)
 N DATE,IENS,INFO,MSGBUF,PARAMS,RC,RORBUF,RORMSG,TMP
"RTN","RORUTL17",189,0)
 S FLAGS=$G(FLAGS)
"RTN","RORUTL17",190,0)
 S INFO=$NA(^TMP("RORSETU3I",$J)),RC=0
"RTN","RORUTL17",191,0)
 S MSGBUF=$NA(^TMP("RORSETU3M",$J))
"RTN","RORUTL17",192,0)
 S PARAMS("DATE")=$$DATE($$DT^XLFDT)
"RTN","RORUTL17",193,0)
 ;
"RTN","RORUTL17",194,0)
 ;--- Gather the information
"RTN","RORUTL17",195,0)
 S RC=$$REGINFO(REGIEN,INFO,FLAGS)
"RTN","RORUTL17",196,0)
 ;
"RTN","RORUTL17",197,0)
 D:RC'<0
"RTN","RORUTL17",198,0)
 . N I,MBI,NF,PATIEN,XMCHAN,XMDUZ,XMLOC,XMSUB,XMTEXT,XMY,XMZ
"RTN","RORUTL17",199,0)
 . S IENS=REGIEN_","  K @MSGBUF
"RTN","RORUTL17",200,0)
 . ;
"RTN","RORUTL17",201,0)
 . ;--- Load the registry parameters
"RTN","RORUTL17",202,0)
 . D GETS^DIQ(798.1,IENS,".01;1;2;2.5;13.3","I","RORBUF","RORMSG")
"RTN","RORUTL17",203,0)
 . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)  Q
"RTN","RORUTL17",204,0)
 . I $G(EMAIL)=""  S EMAIL=$G(RORBUF(798.1,IENS,13.3,"I"))  Q:EMAIL=""
"RTN","RORUTL17",205,0)
 . ;
"RTN","RORUTL17",206,0)
 . ;--- Header of the message body
"RTN","RORUTL17",207,0)
 . S TMP=$$SITE^RORUTL03()
"RTN","RORUTL17",208,0)
 . S PARAMS("STNAME")=$P(TMP,U,2)
"RTN","RORUTL17",209,0)
 . S PARAMS("STNUM")=$P(TMP,U)
"RTN","RORUTL17",210,0)
 . ;---
"RTN","RORUTL17",211,0)
 . F I="DTACKMAX","DTACKMIN"  D
"RTN","RORUTL17",212,0)
 . . S PARAMS(I)=$$DATE(+$G(@INFO@(I)))
"RTN","RORUTL17",213,0)
 . F I="NPA","NPP","NPT"  D
"RTN","RORUTL17",214,0)
 . . S PARAMS(I)=+$G(@INFO@(I))
"RTN","RORUTL17",215,0)
 . ;---
"RTN","RORUTL17",216,0)
 . S PARAMS("REGISTRY")=$G(RORBUF(798.1,IENS,.01,"I"))
"RTN","RORUTL17",217,0)
 . S PARAMS("RETRIES")=+$G(RORBUF(798.1,IENS,2.5,"I"))
"RTN","RORUTL17",218,0)
 . S PARAMS("UPDATED_UNTIL")=$$DATE($G(RORBUF(798.1,IENS,1,"I")))
"RTN","RORUTL17",219,0)
 . S PARAMS("EXTRACTED_UNTIL")=$$DATE($G(RORBUF(798.1,IENS,2,"I")))
"RTN","RORUTL17",220,0)
 . D BLD^DIALOG(7980000.021,.PARAMS,,MSGBUF,"S")
"RTN","RORUTL17",221,0)
 . S MBI=+$O(@MSGBUF@(""),-1)
"RTN","RORUTL17",222,0)
 . ;
"RTN","RORUTL17",223,0)
 . ;--- Number of patients with errors
"RTN","RORUTL17",224,0)
 . D:FLAGS["E"
"RTN","RORUTL17",225,0)
 . . S MBI=MBI+1,@MSGBUF@(MBI)="<NPE>"_$G(@INFO@("NPE"))_"</NPE>"
"RTN","RORUTL17",226,0)
 . ;
"RTN","RORUTL17",227,0)
 . ;--- List of pending patients
"RTN","RORUTL17",228,0)
 . D:FLAGS["P"
"RTN","RORUTL17",229,0)
 . . S RORBUF=$G(@INFO@("PPL",0,1))
"RTN","RORUTL17",230,0)
 . . F NF=1:1  Q:$P(RORBUF,U,NF)=""
"RTN","RORUTL17",231,0)
 . . S NF=NF-1
"RTN","RORUTL17",232,0)
 . . S MBI=MBI+1,@MSGBUF@(MBI)="<PPLIST>"
"RTN","RORUTL17",233,0)
 . . S MBI=MBI+1,@MSGBUF@(MBI)="CSSN,"_$TR(RORBUF,U,",")
"RTN","RORUTL17",234,0)
 . . S PATIEN=0
"RTN","RORUTL17",235,0)
 . . F  S PATIEN=$O(@INFO@("PPL",PATIEN))  Q:PATIEN'>0  D
"RTN","RORUTL17",236,0)
 . . . S RORBUF=$G(@INFO@("PPL",PATIEN,1))
"RTN","RORUTL17",237,0)
 . . . F I=1:1:NF  S $P(RORBUF,U,I)=$$DATE(+$P(RORBUF,U,I))
"RTN","RORUTL17",238,0)
 . . . S TMP=$P(@INFO@("PPL",PATIEN),U,2)
"RTN","RORUTL17",239,0)
 . . . S MBI=MBI+1,@MSGBUF@(MBI)=TMP_","_$TR(RORBUF,U,",")
"RTN","RORUTL17",240,0)
 . . S MBI=MBI+1,@MSGBUF@(MBI)="</PPLIST>"
"RTN","RORUTL17",241,0)
 . ;
"RTN","RORUTL17",242,0)
 . ;--- Footer of the message body
"RTN","RORUTL17",243,0)
 . D BLD^DIALOG(7980000.022,.PARAMS,,MSGBUF,"S")
"RTN","RORUTL17",244,0)
 . ;
"RTN","RORUTL17",245,0)
 . ;--- Send the message
"RTN","RORUTL17",246,0)
 . S XMDUZ=.5,XMY(EMAIL)=""
"RTN","RORUTL17",247,0)
 . S XMSUB="ROR: REGISTRY INFO"
"RTN","RORUTL17",248,0)
 . S XMTEXT=$$OREF^DILF(MSGBUF)
"RTN","RORUTL17",249,0)
 . D ^XMD
"RTN","RORUTL17",250,0)
 ;
"RTN","RORUTL17",251,0)
 ;--- Cleanup
"RTN","RORUTL17",252,0)
 K @INFO,@MSGBUF
"RTN","RORUTL17",253,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORVM001")
0^79^B2351863
"RTN","RORVM001",1,0)
RORVM001 ;HCIOFO/SG - MAINTENANCE OPTIONS ; 7/18/03 7:44am
"RTN","RORVM001",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORVM001",3,0)
 ;
"RTN","RORVM001",4,0)
 Q
"RTN","RORVM001",5,0)
 ;
"RTN","RORVM001",6,0)
 ;***** EDITS THE 'AWAITING ACK' FLAG
"RTN","RORVM001",7,0)
EDITACK ;
"RTN","RORVM001",8,0)
 N ACKVAL,DA,DIC,DINUM,DIR,DLAYGO,DIRUT,DTOUT,DUOUT,REGIENS,RORFDA,RORMSG,X,Y
"RTN","RORVM001",9,0)
 W !
"RTN","RORVM001",10,0)
 ;--- Select the registry
"RTN","RORVM001",11,0)
 S DIC=798.1,DIC(0)="AEMQ"
"RTN","RORVM001",12,0)
 D ^DIC  Q:$D(DTOUT)!$D(DUOUT)!($G(Y)'>0)
"RTN","RORVM001",13,0)
 S REGIENS=+$G(Y)_","
"RTN","RORVM001",14,0)
 ;--- Edit the flag
"RTN","RORVM001",15,0)
 S DIR(0)="798.1,2.2",DA=+REGIENS
"RTN","RORVM001",16,0)
 D ^DIR  Q:$D(DTOUT)!$D(DUOUT)  W !
"RTN","RORVM001",17,0)
 S ACKVAL=$P(Y,U)
"RTN","RORVM001",18,0)
 ;--- Cancel the message if necessary
"RTN","RORVM001",19,0)
 S MSGID=$$GET1^DIQ(798.1,REGIENS,2.3,,,"RORMSG")
"RTN","RORVM001",20,0)
 I ACKVAL="",MSGID'=""  D:$$MSGACT^HLUTIL(MSGID,1)
"RTN","RORVM001",21,0)
 . W !,"The HL7 message #"_MSGID_" has been canceled."
"RTN","RORVM001",22,0)
 ;--- Update the record
"RTN","RORVM001",23,0)
 S RORFDA(798.1,REGIENS,2.2)=ACKVAL
"RTN","RORVM001",24,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORVM001",25,0)
 W:'$G(DIERR) !,"The registry parameters have been updated."
"RTN","RORVM001",26,0)
 Q
"RTN","RORVM001",27,0)
 ;
"RTN","RORVM001",28,0)
 ;***** REBUILDS THE "ACL" CROSS-REFERENCE (USER ACCESS)
"RTN","RORVM001",29,0)
 ; OPTION: [RORMNT ACL REINDEX]
"RTN","RORVM001",30,0)
RNDXACL ;
"RTN","RORVM001",31,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,X,Y
"RTN","RORVM001",32,0)
 S DIR(0)="Y",DIR("B")="NO"
"RTN","RORVM001",33,0)
 S DIR("A")="Do you want to reindex the ACL cross-reference"
"RTN","RORVM001",34,0)
 D BLD^DIALOG(7980000.007,,,"DIR(""?"")","S")
"RTN","RORVM001",35,0)
 D ^DIR
"RTN","RORVM001",36,0)
 I $G(Y)  D  W !!,"Done."
"RTN","RORVM001",37,0)
 . S X=$$RNDXACL^RORUTL11()
"RTN","RORVM001",38,0)
 Q
"RTN","RORX000")
0^136^B4541569
"RTN","RORX000",1,0)
RORX000 ;HCIOFO/SG - DUMMY REPORT ; 9/29/03 3:51pm
"RTN","RORX000",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORX000",3,0)
 ;
"RTN","RORX000",4,0)
 Q
"RTN","RORX000",5,0)
 ;
"RTN","RORX000",6,0)
 ;*****
"RTN","RORX000",7,0)
BIGDUMMY(RORTSK) ;
"RTN","RORX000",8,0)
 N BODY,FLT,IEN,IENS,NAME,NODE,PARAMS,PATIENT,REPORT,RORBUF,RORMSG,TMP
"RTN","RORX000",9,0)
 ;---
"RTN","RORX000",10,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX000",11,0)
 ;--- Dump the report parameters
"RTN","RORX000",12,0)
 S BODY=$$ADDVAL^RORTSK11(RORTSK,"PARAMETERS",,REPORT)
"RTN","RORX000",13,0)
 S NODE=$NA(RORTSK("PARAMS")),FLT=$P(NODE,")")_","
"RTN","RORX000",14,0)
 F  S NODE=$Q(@NODE)  Q:'(NODE[FLT)  D
"RTN","RORX000",15,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"PARAMETER",NODE_" = "_@NODE,BODY)
"RTN","RORX000",16,0)
 ;--- List of patients
"RTN","RORX000",17,0)
 S BODY=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,REPORT)
"RTN","RORX000",18,0)
 S NAME=""
"RTN","RORX000",19,0)
 F  S NAME=$O(^DPT("B",NAME))  Q:NAME=""  D
"RTN","RORX000",20,0)
 . S IEN=0
"RTN","RORX000",21,0)
 . F  S IEN=$O(^DPT("B",NAME,IEN))  Q:IEN'>0  D
"RTN","RORX000",22,0)
 . . S IENS=IEN_","  K RORBUF
"RTN","RORX000",23,0)
 . . D GETS^DIQ(2,IENS,".01;.02;.03;.06;.09;","E","RORBUF","RORMSG")
"RTN","RORX000",24,0)
 . . S PATIENT=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,BODY)
"RTN","RORX000",25,0)
 . . S TMP=$G(RORBUF(2,IENS,.01,"E"))
"RTN","RORX000",26,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NAME",TMP,PATIENT)
"RTN","RORX000",27,0)
 . . S TMP=$G(RORBUF(2,IENS,.02,"E"))
"RTN","RORX000",28,0)
 . . D ADDVAL^RORTSK11(RORTSK,"SEX",TMP,PATIENT)
"RTN","RORX000",29,0)
 . . S TMP=$G(RORBUF(2,IENS,.03,"E"))
"RTN","RORX000",30,0)
 . . D ADDVAL^RORTSK11(RORTSK,"DOB",TMP,PATIENT)
"RTN","RORX000",31,0)
 . . S TMP=$G(RORBUF(2,IENS,.06,"E"))
"RTN","RORX000",32,0)
 . . D ADDVAL^RORTSK11(RORTSK,"RACE",TMP,PATIENT)
"RTN","RORX000",33,0)
 . . S TMP=$G(RORBUF(2,IENS,.09,"E"))
"RTN","RORX000",34,0)
 . . D ADDVAL^RORTSK11(RORTSK,"SSN",TMP,PATIENT)
"RTN","RORX000",35,0)
 Q 0
"RTN","RORX000",36,0)
 ;
"RTN","RORX000",37,0)
 ;*****
"RTN","RORX000",38,0)
DUMMY(RORTSK) ;
"RTN","RORX000",39,0)
 N FLT,NODE,PARAMS,REPORT,TMP
"RTN","RORX000",40,0)
 ;---
"RTN","RORX000",41,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX000",42,0)
 S PARAMS=$$ADDVAL^RORTSK11(RORTSK,"PARAMETERS",,REPORT)
"RTN","RORX000",43,0)
 ;--- Dump the report parameters
"RTN","RORX000",44,0)
 S NODE=$NA(RORTSK("PARAMS")),FLT=$P(NODE,")")_","
"RTN","RORX000",45,0)
 F  S NODE=$Q(@NODE)  Q:'(NODE[FLT)  D
"RTN","RORX000",46,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"PARAMETER",NODE_" = "_@NODE,PARAMS)
"RTN","RORX000",47,0)
 Q 0
"RTN","RORX001")
0^32^B38640459
"RTN","RORX001",1,0)
RORX001 ;HCIOFO/SG - LIST OF REGISTRY PATIENTS ; 12/3/03 9:20am
"RTN","RORX001",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORX001",3,0)
 ;
"RTN","RORX001",4,0)
 ; This routine uses the following IAs:
"RTN","RORX001",5,0)
 ;
"RTN","RORX001",6,0)
 ; #10061        DEM^VADPT (supported)
"RTN","RORX001",7,0)
 ;
"RTN","RORX001",8,0)
 Q
"RTN","RORX001",9,0)
 ;
"RTN","RORX001",10,0)
 ;***** OUTPUTS THE REPORT HEADER
"RTN","RORX001",11,0)
 ;
"RTN","RORX001",12,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX001",13,0)
 ;
"RTN","RORX001",14,0)
 ; Return Values:
"RTN","RORX001",15,0)
 ;       <0  Error code
"RTN","RORX001",16,0)
 ;        0  Ok
"RTN","RORX001",17,0)
 ;
"RTN","RORX001",18,0)
HEADER(PARTAG) ;
"RTN","RORX001",19,0)
 N COL,COLUMNS,HEADER,TMP
"RTN","RORX001",20,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX001",21,0)
 S COLUMNS=$$ADDVAL^RORTSK11(RORTSK,"TBLDEF",,HEADER)
"RTN","RORX001",22,0)
 D ADDATTR^RORTSK11(RORTSK,COLUMNS,"NAME","PATIENTS")
"RTN","RORX001",23,0)
 D ADDATTR^RORTSK11(RORTSK,COLUMNS,"HEADER","1")
"RTN","RORX001",24,0)
 D ADDATTR^RORTSK11(RORTSK,COLUMNS,"FOOTER","1")
"RTN","RORX001",25,0)
 S RORFLDS=".01"
"RTN","RORX001",26,0)
 ;--- Required columns
"RTN","RORX001",27,0)
 F COL="#","NAME"  D
"RTN","RORX001",28,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,COLUMNS)
"RTN","RORX001",29,0)
 . D ADDATTR^RORTSK11(RORTSK,TMP,"NAME",COL)
"RTN","RORX001",30,0)
 ;--- Additional columns
"RTN","RORX001",31,0)
 F COL="DOB","CSSN","LAST4","SELRULES","ENTDT","INADT","READT","INARSN"  D
"RTN","RORX001",32,0)
 . Q:'$D(RORFLDS(COL))
"RTN","RORX001",33,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,COLUMNS)
"RTN","RORX001",34,0)
 . D ADDATTR^RORTSK11(RORTSK,TMP,"NAME",COL)
"RTN","RORX001",35,0)
 ;---
"RTN","RORX001",36,0)
 S:$D(RORFLDS("ENTDT")) RORFLDS=RORFLDS_";1"
"RTN","RORX001",37,0)
 S:$D(RORFLDS("INADT")) RORFLDS=RORFLDS_";2"
"RTN","RORX001",38,0)
 S:$D(RORFLDS("INARSN")) RORFLDS=RORFLDS_";2.2"
"RTN","RORX001",39,0)
 S:$D(RORFLDS("READT")) RORFLDS=RORFLDS_";7"
"RTN","RORX001",40,0)
 Q 0
"RTN","RORX001",41,0)
 ;
"RTN","RORX001",42,0)
 ;***** ADDS THE PATIENT DATA TO THE REPORT
"RTN","RORX001",43,0)
 ;
"RTN","RORX001",44,0)
 ; IENS          IENS of the patient's record in the registry
"RTN","RORX001",45,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX001",46,0)
 ;
"RTN","RORX001",47,0)
 ; Return Values:
"RTN","RORX001",48,0)
 ;       <0  Error code
"RTN","RORX001",49,0)
 ;        0  Ok
"RTN","RORX001",50,0)
 ;
"RTN","RORX001",51,0)
PATIENT(IENS,PARTAG) ;
"RTN","RORX001",52,0)
 N DFN,IATIME,NAME,RC,RORBUF,RORMSG,TMP,VA,VADM,VAHOW,VAROOT
"RTN","RORX001",53,0)
 D GETS^DIQ(798,IENS,RORFLDS,"I","RORBUF","RORMSG")
"RTN","RORX001",54,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","RORX001",55,0)
 S DFN=$G(RORBUF(798,IENS,.01,"I"))
"RTN","RORX001",56,0)
 ;--- Load the demographic data
"RTN","RORX001",57,0)
 D DEM^VADPT
"RTN","RORX001",58,0)
 ;--- The <PATIENT> tag
"RTN","RORX001",59,0)
 S PTAG=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,PARTAG,,DFN)
"RTN","RORX001",60,0)
 ;--- Patient Name
"RTN","RORX001",61,0)
 D ADDVAL^RORTSK11(RORTSK,"NAME",VADM(1),PTAG,1)
"RTN","RORX001",62,0)
 ;--- Date of Birth
"RTN","RORX001",63,0)
 D:$D(RORFLDS("DOB"))
"RTN","RORX001",64,0)
 . S TMP=$$DATE^RORXU002(VADM(3)\1)
"RTN","RORX001",65,0)
 . D ADDVAL^RORTSK11(RORTSK,"DOB",TMP,PTAG,1)
"RTN","RORX001",66,0)
 ;--- Coded SSN
"RTN","RORX001",67,0)
 D:$D(RORFLDS("CSSN"))
"RTN","RORX001",68,0)
 . S TMP=$$XOR^RORUTL03($P(VADM(2),U))
"RTN","RORX001",69,0)
 . D ADDVAL^RORTSK11(RORTSK,"CSSN",TMP,PTAG,1)
"RTN","RORX001",70,0)
 ;--- last 4 digits of the SSN
"RTN","RORX001",71,0)
 D:$D(RORFLDS("LAST4"))
"RTN","RORX001",72,0)
 . D ADDVAL^RORTSK11(RORTSK,"LAST4",VA("BID"),PTAG,2)
"RTN","RORX001",73,0)
 ;--- Selection Rules
"RTN","RORX001",74,0)
 I $D(RORFLDS("SELRULES"))  S RC=$$SELRULES(IENS,PTAG)  Q:RC<0 RC
"RTN","RORX001",75,0)
 ;--- Date Entered into the Registry
"RTN","RORX001",76,0)
 D:$D(RORFLDS("ENTDT"))
"RTN","RORX001",77,0)
 . S TMP=$$DATE^RORXU002($G(RORBUF(798,IENS,1,"I"))\1)
"RTN","RORX001",78,0)
 . D ADDVAL^RORTSK11(RORTSK,"ENTDT",TMP,PTAG,1)
"RTN","RORX001",79,0)
 ;--- Inactivation Date
"RTN","RORX001",80,0)
 D:$D(RORFLDS("INADT"))
"RTN","RORX001",81,0)
 . S TMP=$G(RORBUF(798,IENS,2,"I"))\1
"RTN","RORX001",82,0)
 . I TMP>0  D:$G(RORBUF(798,IENS,7,"I"))\1=TMP
"RTN","RORX001",83,0)
 . . ;--- Display time parts of the dates if the patient
"RTN","RORX001",84,0)
 . . ;--- was inactivated and reactivated on the same day
"RTN","RORX001",85,0)
 . . S IATIME=1,TMP=RORBUF(798,IENS,2,"I")
"RTN","RORX001",86,0)
 . E  S TMP=""
"RTN","RORX001",87,0)
 . D ADDVAL^RORTSK11(RORTSK,"INADT",TMP,PTAG,1)
"RTN","RORX001",88,0)
 ;--- Reactivation Date
"RTN","RORX001",89,0)
 D:$D(RORFLDS("READT"))
"RTN","RORX001",90,0)
 . S TMP=$G(RORBUF(798,IENS,7,"I"))
"RTN","RORX001",91,0)
 . S TMP=$$DATE^RORXU002($S('$G(IATIME):TMP\1,1:TMP))
"RTN","RORX001",92,0)
 . D ADDVAL^RORTSK11(RORTSK,"READT",TMP,PTAG,1)
"RTN","RORX001",93,0)
 ;--- Inactivation Reason
"RTN","RORX001",94,0)
 D:$D(RORFLDS("INARSN"))
"RTN","RORX001",95,0)
 . S TMP=$G(RORBUF(798,IENS,2.2,"I"))
"RTN","RORX001",96,0)
 . I TMP>0  D
"RTN","RORX001",97,0)
 . . S TMP=$$EXTERNAL^DILFD(798,2.2,,TMP,"RORMSG")
"RTN","RORX001",98,0)
 . E  S TMP=""  D:$G(VADM(6))>0
"RTN","RORX001",99,0)
 . . S TMP="Deceased ("_$$FMTE^XLFDT(VADM(6)\1,5)_")"
"RTN","RORX001",100,0)
 . D ADDVAL^RORTSK11(RORTSK,"INARSN",TMP,PTAG,1)
"RTN","RORX001",101,0)
 ;--- Patient IEN (DFN)
"RTN","RORX001",102,0)
 ;S:$D(RORFLDS("DFN")) TMP=$$ADDVAL^RORTSK11(RORTSK,"DFN",DFN,PTAG)
"RTN","RORX001",103,0)
 ;--- Integration Control Number
"RTN","RORX001",104,0)
 ;D:$D(RORFLDS("ICN"))
"RTN","RORX001",105,0)
 ;. S TMP=$$ICN^RORUTL02(DFN)
"RTN","RORX001",106,0)
 ;. D ADDVAL^RORTSK11(RORTSK,"ICN",$P(TMP,"V"),PTAG,1)
"RTN","RORX001",107,0)
 ;--- Investigational Drugs
"RTN","RORX001",108,0)
 ;D:$E(RORFLDS,8)
"RTN","RORX001",109,0)
 ;. S TMP=$S($G(RORBUF(798,IENS,6,"I")):"YES",1:"NO")
"RTN","RORX001",110,0)
 ;. D ADDVAL^RORTSK11(RORTSK,"INV_DRUGS",TMP,PTAG,1)
"RTN","RORX001",111,0)
 Q 0
"RTN","RORX001",112,0)
 ;
"RTN","RORX001",113,0)
 ;***** COMPILES A LIST OF REGISTRY PATIENTS
"RTN","RORX001",114,0)
 ; REPORT CODE: 001
"RTN","RORX001",115,0)
 ;
"RTN","RORX001",116,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORX001",117,0)
 ;
"RTN","RORX001",118,0)
 ; Return Values:
"RTN","RORX001",119,0)
 ;       <0  Error code
"RTN","RORX001",120,0)
 ;        0  Ok
"RTN","RORX001",121,0)
 ;
"RTN","RORX001",122,0)
REGPTLST(RORTSK) ;
"RTN","RORX001",123,0)
 N ROREDT        ; End date
"RTN","RORX001",124,0)
 N RORFLDS       ; List of additional fields
"RTN","RORX001",125,0)
 N RORPTN        ; Number of patients in the registry
"RTN","RORX001",126,0)
 N RORSDT        ; Start date
"RTN","RORX001",127,0)
 N RORREG        ; Registry IEN
"RTN","RORX001",128,0)
 ;
"RTN","RORX001",129,0)
 N ACTIVE,BODY,CNT,DTE,ECNT,ENDT,IEN,IENS,MODE,RC,REPORT,SFLAGS,TMP,XREFNODE
"RTN","RORX001",130,0)
 ;--- Root node of the report
"RTN","RORX001",131,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX001",132,0)
 Q:REPORT<0 REPORT
"RTN","RORX001",133,0)
 ;
"RTN","RORX001",134,0)
 ;--- Get and prepare the report parameters
"RTN","RORX001",135,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")
"RTN","RORX001",136,0)
 S RC=$$PARAMS^RORXU002(.RORTSK,REPORT,.RORSDT,.ROREDT,.SFLAGS)
"RTN","RORX001",137,0)
 Q:RC<0 RC
"RTN","RORX001",138,0)
 S MODE=$$PARAM^RORTSK01("PATIENTS")
"RTN","RORX001",139,0)
 D LIST^RORXU002(.MODE)
"RTN","RORX001",140,0)
 S RORFLDS=$$PARAM^RORTSK01("FIELDS")
"RTN","RORX001",141,0)
 D LIST^RORXU002(.RORFLDS)
"RTN","RORX001",142,0)
 D ADDVAL^RORTSK11(RORTSK,"TYPE",SFLAGS,REPORT)
"RTN","RORX001",143,0)
 ;
"RTN","RORX001",144,0)
 ;--- Initialize constants and variables
"RTN","RORX001",145,0)
 S RORPTN=$$REGSIZE^RORUTL02(+RORREG)  S:RORPTN<0 RORPTN=0
"RTN","RORX001",146,0)
 S ECNT=0,XREFNODE=$NA(^RORDATA(798,"ARD",RORREG_"#"))
"RTN","RORX001",147,0)
 ;
"RTN","RORX001",148,0)
 ;--- The report header and list of patients
"RTN","RORX001",149,0)
 S RC=$$HEADER(REPORT)  Q:RC<0 RC
"RTN","RORX001",150,0)
 S BODY=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,REPORT)
"RTN","RORX001",151,0)
 D ADDATTR^RORTSK11(RORTSK,BODY,"TABLE","PATIENTS")
"RTN","RORX001",152,0)
 Q:BODY<0 BODY
"RTN","RORX001",153,0)
 ;
"RTN","RORX001",154,0)
 ;--- Browse through the registry records
"RTN","RORX001",155,0)
 S DTE=$S(RORSDT>0:$O(@XREFNODE@(RORSDT\1),-1),1:"")
"RTN","RORX001",156,0)
 S (CNT,RC)=0,ENDT=ROREDT\1+1
"RTN","RORX001",157,0)
 F  S DTE=$O(@XREFNODE@(DTE))  Q:'DTE!(DTE'<ENDT)  D  Q:RC<0
"RTN","RORX001",158,0)
 . S IEN=0
"RTN","RORX001",159,0)
 . F  S IEN=$O(@XREFNODE@(DTE,IEN))  Q:IEN'>0  D  Q:RC<0
"RTN","RORX001",160,0)
 . . S TMP=$S(RORPTN>0:CNT/RORPTN,1:"")
"RTN","RORX001",161,0)
 . . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX001",162,0)
 . . S IENS=IEN_",",CNT=CNT+1
"RTN","RORX001",163,0)
 . . ;--- Check if the patient should be skipped
"RTN","RORX001",164,0)
 . . S TMP=$$ACTIVE^RORDD(IEN)
"RTN","RORX001",165,0)
 . . Q:$S(TMP:SFLAGS["A",1:SFLAGS["I")
"RTN","RORX001",166,0)
 . . ;--- Process the registry record
"RTN","RORX001",167,0)
 . . I $$PATIENT(IENS,BODY)<0  S ECNT=ECNT+1  Q
"RTN","RORX001",168,0)
 ;---
"RTN","RORX001",169,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX001",170,0)
 ;
"RTN","RORX001",171,0)
 ;***** ADDS THE SELECTION RULES TO THE REPORT
"RTN","RORX001",172,0)
 ;
"RTN","RORX001",173,0)
 ; IENS          IENS of the patient's record in the registry
"RTN","RORX001",174,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX001",175,0)
 ;
"RTN","RORX001",176,0)
 ; Return Values:
"RTN","RORX001",177,0)
 ;       <0  Error code
"RTN","RORX001",178,0)
 ;        0  Ok
"RTN","RORX001",179,0)
 ;
"RTN","RORX001",180,0)
SELRULES(IENS,PARTAG) ;
"RTN","RORX001",181,0)
 N CNT,I,RORBUF,RORMSG,RT,SRLTAG,TMP
"RTN","RORX001",182,0)
 ;--- Load the list of selection rules
"RTN","RORX001",183,0)
 D LIST^DIC(798.01,","_IENS,"@;.01I;1I",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORX001",184,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.01,IENS)
"RTN","RORX001",185,0)
 ;--- The <SELRULES> ... </SELRULES> tags
"RTN","RORX001",186,0)
 S SRLTAG=$$ADDVAL^RORTSK11(RORTSK,"SELRULES",,PARTAG)
"RTN","RORX001",187,0)
 ;--- Add the selection rules to the report
"RTN","RORX001",188,0)
 S I="",CNT=0
"RTN","RORX001",189,0)
 F  S I=$O(RORBUF("DILIST","ID",I))  Q:I=""  D
"RTN","RORX001",190,0)
 . S RT=$$ADDVAL^RORTSK11(RORTSK,"RULE",,SRLTAG),CNT=CNT+1
"RTN","RORX001",191,0)
 . S TMP=$G(RORBUF("DILIST","ID",I,.01))
"RTN","RORX001",192,0)
 . S TMP=$$GET1^DIQ(798.2,TMP_",",4,,,"RORMSG")
"RTN","RORX001",193,0)
 . Q:$G(DIERR)!(TMP="")
"RTN","RORX001",194,0)
 . D ADDATTR^RORTSK11(RORTSK,RT,"DESCR",TMP)
"RTN","RORX001",195,0)
 . S TMP=$$DATE^RORXU002($G(RORBUF("DILIST","ID",I,1))\1)
"RTN","RORX001",196,0)
 . D:TMP'="" ADDATTR^RORTSK11(RORTSK,RT,"DATE",TMP)
"RTN","RORX001",197,0)
 ;--- Add the default item if no selection rules have been found
"RTN","RORX001",198,0)
 D:CNT'>0
"RTN","RORX001",199,0)
 . S RT=$$ADDVAL^RORTSK11(RORTSK,"RULE",,SRLTAG)
"RTN","RORX001",200,0)
 . D ADDATTR^RORTSK11(RORTSK,RT,"DESCR","Manual Entry")
"RTN","RORX001",201,0)
 Q 0
"RTN","RORX002")
0^33^B20256983
"RTN","RORX002",1,0)
RORX002 ;HCIOFO/SG - CURRENT INPATIENT LIST ; 12/5/03 1:38pm
"RTN","RORX002",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORX002",3,0)
 ;
"RTN","RORX002",4,0)
 ; This routine uses the following IAs:
"RTN","RORX002",5,0)
 ;
"RTN","RORX002",6,0)
 ; #325          ADM^VADPT2 (controlled)
"RTN","RORX002",7,0)
 ; #10061        51^VADPT (supported)
"RTN","RORX002",8,0)
 ;
"RTN","RORX002",9,0)
 Q
"RTN","RORX002",10,0)
 ;
"RTN","RORX002",11,0)
 ;***** OUTPUTS THE REPORT HEADER
"RTN","RORX002",12,0)
 ;
"RTN","RORX002",13,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX002",14,0)
 ;
"RTN","RORX002",15,0)
 ; Return Values:
"RTN","RORX002",16,0)
 ;       <0  Error code
"RTN","RORX002",17,0)
 ;        0  Ok
"RTN","RORX002",18,0)
 ;
"RTN","RORX002",19,0)
HEADER(PARTAG) ;
"RTN","RORX002",20,0)
 ;;PATIENTS(#,NAME,LAST4,AIDSTAT,WARD,ROOM-BED)
"RTN","RORX002",21,0)
 ;
"RTN","RORX002",22,0)
 N HEADER,RC
"RTN","RORX002",23,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX002",24,0)
 Q:HEADER<0 HEADER
"RTN","RORX002",25,0)
 S RC=$$TBLDEF^RORXU002("HEADER^RORX002",HEADER)
"RTN","RORX002",26,0)
 Q $S(RC<0:RC,1:HEADER)
"RTN","RORX002",27,0)
 ;
"RTN","RORX002",28,0)
 ;***** COMPILES THE "CURRENT INPATIENT LIST"
"RTN","RORX002",29,0)
 ; REPORT CODE: 002
"RTN","RORX002",30,0)
 ;
"RTN","RORX002",31,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORX002",32,0)
 ;
"RTN","RORX002",33,0)
 ; The ^TMP("RORX002",$J) global node is used by the function.
"RTN","RORX002",34,0)
 ;
"RTN","RORX002",35,0)
 ; Return Values:
"RTN","RORX002",36,0)
 ;       <0  Error code
"RTN","RORX002",37,0)
 ;        0  Ok
"RTN","RORX002",38,0)
 ;
"RTN","RORX002",39,0)
INPTLST(RORTSK) ;
"RTN","RORX002",40,0)
 N RORPTN        ; Number of patients in the registry
"RTN","RORX002",41,0)
 N RORREG        ; Registry IEN
"RTN","RORX002",42,0)
 ;
"RTN","RORX002",43,0)
 N BODY,ECNT,INPCNT,RC,REPORT,TMP
"RTN","RORX002",44,0)
 ;--- Root node of the report
"RTN","RORX002",45,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX002",46,0)
 Q:REPORT<0 REPORT
"RTN","RORX002",47,0)
 ;
"RTN","RORX002",48,0)
 ;--- Get and prepare the report parameters
"RTN","RORX002",49,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")
"RTN","RORX002",50,0)
 S RC=$$PARAMS^RORXU002(.RORTSK,REPORT)  Q:RC<0 RC
"RTN","RORX002",51,0)
 ;
"RTN","RORX002",52,0)
 ;--- Initialize constants and variables
"RTN","RORX002",53,0)
 K ^TMP("RORX002",$J)  S ECNT=0
"RTN","RORX002",54,0)
 S RORPTN=$$REGSIZE^RORUTL02(+RORREG)  S:RORPTN<0 RORPTN=0
"RTN","RORX002",55,0)
 ;
"RTN","RORX002",56,0)
 ;--- Report header
"RTN","RORX002",57,0)
 S RC=$$HEADER(REPORT)  Q:RC<0 RC
"RTN","RORX002",58,0)
 ;
"RTN","RORX002",59,0)
 D
"RTN","RORX002",60,0)
 . ;--- Query the registry
"RTN","RORX002",61,0)
 . D TPPSETUP^RORTSK01(50)
"RTN","RORX002",62,0)
 . S RC=$$QUERY(.INPCNT)
"RTN","RORX002",63,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX002",64,0)
 . ;--- Generate the list of patients
"RTN","RORX002",65,0)
 . D TPPSETUP^RORTSK01(50)
"RTN","RORX002",66,0)
 . S RC=$$PTLIST(REPORT,INPCNT)
"RTN","RORX002",67,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX002",68,0)
 ;
"RTN","RORX002",69,0)
 ;--- Cleanup
"RTN","RORX002",70,0)
 K ^TMP("RORX002",$J)
"RTN","RORX002",71,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX002",72,0)
 ;
"RTN","RORX002",73,0)
 ;***** ADDS THE PATIENT DATA TO THE REPORT
"RTN","RORX002",74,0)
 ;
"RTN","RORX002",75,0)
 ; NODE          Closed root of the patient's node in the buffer
"RTN","RORX002",76,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX002",77,0)
 ;
"RTN","RORX002",78,0)
 ; Return Values:
"RTN","RORX002",79,0)
 ;       <0  Error code
"RTN","RORX002",80,0)
 ;        0  Ok
"RTN","RORX002",81,0)
 ;
"RTN","RORX002",82,0)
PATIENT(NODE,PARTAG) ;
"RTN","RORX002",83,0)
 N CLINAIDS,IEN,NAME,PATIEN,PTAG,PTBUF,RC,TMP
"RTN","RORX002",84,0)
 S PTBUF=@NODE,PATIEN=$P(PTBUF,U,2)
"RTN","RORX002",85,0)
 Q:PATIEN'>0 0
"RTN","RORX002",86,0)
 ;--- Clinical AIDS status
"RTN","RORX002",87,0)
 S CLINAIDS=+$$CLINAIDS^RORICRUT(+PTBUF)
"RTN","RORX002",88,0)
 ;--- The <PATIENT> tag
"RTN","RORX002",89,0)
 S PTAG=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,PARTAG,,PATIEN)
"RTN","RORX002",90,0)
 ;--- Patient data
"RTN","RORX002",91,0)
 D ADDVAL^RORTSK11(RORTSK,"NAME",$QS(NODE,4),PTAG,1)
"RTN","RORX002",92,0)
 D ADDVAL^RORTSK11(RORTSK,"LAST4",$QS(NODE,5),PTAG,2)
"RTN","RORX002",93,0)
 D ADDVAL^RORTSK11(RORTSK,"AIDSTAT",CLINAIDS,PTAG,1)
"RTN","RORX002",94,0)
 D ADDVAL^RORTSK11(RORTSK,"WARD",$QS(NODE,3),PTAG,1)
"RTN","RORX002",95,0)
 D ADDVAL^RORTSK11(RORTSK,"ROOM-BED",$P(PTBUF,U,3),PTAG,1)
"RTN","RORX002",96,0)
 Q 0
"RTN","RORX002",97,0)
 ;
"RTN","RORX002",98,0)
 ;***** GENERATES THE LIST OF PATIENTS
"RTN","RORX002",99,0)
 ;
"RTN","RORX002",100,0)
 ; REPORT        IEN of the <REPORT> node
"RTN","RORX002",101,0)
 ; INPCNT        Number of inpatients
"RTN","RORX002",102,0)
 ;
"RTN","RORX002",103,0)
 ; Return Values:
"RTN","RORX002",104,0)
 ;       <0  Error code
"RTN","RORX002",105,0)
 ;        0  Ok
"RTN","RORX002",106,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX002",107,0)
 ;
"RTN","RORX002",108,0)
PTLIST(REPORT,INPCNT) ;
"RTN","RORX002",109,0)
 N BODY,CNT,ECNT,FLT,FLTLEN,NODE,RC,TCNT,TMP
"RTN","RORX002",110,0)
 S (CNT,ECNT,RC)=0
"RTN","RORX002",111,0)
 S BODY=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,REPORT)
"RTN","RORX002",112,0)
 Q:BODY<0 BODY
"RTN","RORX002",113,0)
 D ADDATTR^RORTSK11(RORTSK,BODY,"TABLE","PATIENTS")
"RTN","RORX002",114,0)
 D:$D(^TMP("RORX002",$J))>1
"RTN","RORX002",115,0)
 . S NODE=$NA(^TMP("RORX002",$J))
"RTN","RORX002",116,0)
 . S FLTLEN=$L(NODE)-1,FLT=$E(NODE,1,FLTLEN)
"RTN","RORX002",117,0)
 . F  S NODE=$Q(@NODE)  Q:$E(NODE,1,FLTLEN)'=FLT  D  Q:RC<0
"RTN","RORX002",118,0)
 . . S TMP=$S(INPCNT>0:CNT/INPCNT,1:"")
"RTN","RORX002",119,0)
 . . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX002",120,0)
 . . S CNT=CNT+1
"RTN","RORX002",121,0)
 . . I $$PATIENT(NODE,BODY)<0  S ECNT=ECNT+1  Q
"RTN","RORX002",122,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX002",123,0)
 ;
"RTN","RORX002",124,0)
 ;***** QUERIES THE REGISTRY
"RTN","RORX002",125,0)
 ;
"RTN","RORX002",126,0)
 ; .INPCNT       Number of inpatients is returned in this parameter
"RTN","RORX002",127,0)
 ;
"RTN","RORX002",128,0)
 ; Return Values:
"RTN","RORX002",129,0)
 ;       <0  Error code
"RTN","RORX002",130,0)
 ;        0  Ok
"RTN","RORX002",131,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX002",132,0)
 ;
"RTN","RORX002",133,0)
QUERY(INPCNT) ;
"RTN","RORX002",134,0)
 N CNT,DFN,ECNT,IEN,IENS,RC,TCNT,TMP,VA,VADM,VAHOW,VAIP,VAROOT,XREFNODE,WARD
"RTN","RORX002",135,0)
 S XREFNODE=$NA(^RORDATA(798,"AC",+RORREG))
"RTN","RORX002",136,0)
 S (CNT,ECNT,INPCNT,RC)=0
"RTN","RORX002",137,0)
 ;--- Browse through the registry records
"RTN","RORX002",138,0)
 S IEN=0
"RTN","RORX002",139,0)
 F  S IEN=$O(@XREFNODE@(IEN))  Q:IEN'>0  D  Q:RC<0
"RTN","RORX002",140,0)
 . S TMP=$S(RORPTN>0:CNT/RORPTN,1:"")
"RTN","RORX002",141,0)
 . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX002",142,0)
 . S IENS=IEN_",",CNT=CNT+1
"RTN","RORX002",143,0)
 . ;--- Skip an inactive patient
"RTN","RORX002",144,0)
 . Q:$$SKIP^RORXU005(IEN,"I")
"RTN","RORX002",145,0)
 . ;--- Process the registry record
"RTN","RORX002",146,0)
 . S DFN=$$PTIEN^RORUTL01(IEN)  Q:DFN'>0
"RTN","RORX002",147,0)
 . K VA,VADM,VAIP  D 51^VADPT
"RTN","RORX002",148,0)
 . S WARD=$P(VAIP(5),U,2)  Q:WARD=""
"RTN","RORX002",149,0)
 . S TMP=$S($G(VA("BID"))'="":VA("BID"),1:"UNKN") ; Last 4 of SSN
"RTN","RORX002",150,0)
 . S ^TMP("RORX002",$J,WARD,VADM(1),TMP)=IEN_U_DFN_U_$P(VAIP(6),U,2)
"RTN","RORX002",151,0)
 . S INPCNT=INPCNT+1
"RTN","RORX002",152,0)
 ;---
"RTN","RORX002",153,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX002",154,0)
 ;
"RTN","RORX002",155,0)
 ;***** CHECKS THE SUFFIX FOR VALIDITY
"RTN","RORX002",156,0)
 ;
"RTN","RORX002",157,0)
 ; SUFFIX        Suffix
"RTN","RORX002",158,0)
 ;
"RTN","RORX002",159,0)
 ; Return Values:
"RTN","RORX002",160,0)
 ;        0  Ok
"RTN","RORX002",161,0)
 ;        1  Invalid suffix
"RTN","RORX002",162,0)
VSUFFIX(SUFFIX) ;
"RTN","RORX002",163,0)
 Q '("9AA,9AB,9BB,A0,A4,A5,BU,BV,PA"[SUFFIX)
"RTN","RORX003")
0^60^B20228315
"RTN","RORX003",1,0)
RORX003 ;HCIOFO/SG - GENERAL UTLIZATION AND DEMOGRAPHICS ; 12/30/03 10:05am
"RTN","RORX003",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORX003",3,0)
 ;
"RTN","RORX003",4,0)
 ;--------------------------------------------------------------------
"RTN","RORX003",5,0)
 ; Registry: [VA ICR]
"RTN","RORX003",6,0)
 ;--------------------------------------------------------------------
"RTN","RORX003",7,0)
 Q
"RTN","RORX003",8,0)
 ;
"RTN","RORX003",9,0)
 ;***** OUTPUTS THE REPORT HEADER
"RTN","RORX003",10,0)
 ;
"RTN","RORX003",11,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX003",12,0)
 ;
"RTN","RORX003",13,0)
 ; Return Values:
"RTN","RORX003",14,0)
 ;       <0  Error code
"RTN","RORX003",15,0)
 ;       >0  IEN of the HEADER element
"RTN","RORX003",16,0)
 ;
"RTN","RORX003",17,0)
HEADER(PARTAG) ;
"RTN","RORX003",18,0)
 N COLUMNS,HEADER,NAME,NOTES,TMP
"RTN","RORX003",19,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX003",20,0)
 Q:HEADER<0 HEADER
"RTN","RORX003",21,0)
 S NOTES=$$ADDVAL^RORTSK11(RORTSK,"NOTES",,HEADER)
"RTN","RORX003",22,0)
 D ADDVAL^RORTSK11(RORTSK,"AGE_BASE_DATE",RORAGEDT,NOTES)
"RTN","RORX003",23,0)
 ;---
"RTN","RORX003",24,0)
 S COLUMNS=$$ADDVAL^RORTSK11(RORTSK,"TBLDEF",,HEADER)
"RTN","RORX003",25,0)
 Q:COLUMNS<0 COLUMNS
"RTN","RORX003",26,0)
 D ADDATTR^RORTSK11(RORTSK,COLUMNS,"HEADER","1")
"RTN","RORX003",27,0)
 D ADDATTR^RORTSK11(RORTSK,COLUMNS,"FOOTER","1")
"RTN","RORX003",28,0)
 D ADDATTR^RORTSK11(RORTSK,COLUMNS,"NAME","PATIENTS")
"RTN","RORX003",29,0)
 S RORFL798=".01",RORFLICR=""
"RTN","RORX003",30,0)
 ;--- Required columns
"RTN","RORX003",31,0)
 F NAME="#","NAME","LAST4"  D
"RTN","RORX003",32,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,COLUMNS)
"RTN","RORX003",33,0)
 . D ADDATTR^RORTSK11(RORTSK,TMP,"NAME",NAME)
"RTN","RORX003",34,0)
 ;--- Additional columns
"RTN","RORX003",35,0)
 F NAME="RACE","RISK","AGE","SEX","PRIMELIG","AIDSTAT","REIMBLVL","ENTDT","UTIL","ALIVE"  D
"RTN","RORX003",36,0)
 . Q:'$D(RORFLDS(NAME))
"RTN","RORX003",37,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,COLUMNS)
"RTN","RORX003",38,0)
 . D ADDATTR^RORTSK11(RORTSK,TMP,"NAME",NAME)
"RTN","RORX003",39,0)
 ;---
"RTN","RORX003",40,0)
 S:$D(RORFLDS("ENTDT")) RORFL798=RORFL798_";1"
"RTN","RORX003",41,0)
 Q HEADER
"RTN","RORX003",42,0)
 ;
"RTN","RORX003",43,0)
 ;***** COMPILES THE "GENERAL UTLIZATION AND DEMOGRAPHICS" REPORT
"RTN","RORX003",44,0)
 ; REPORT CODE: 003
"RTN","RORX003",45,0)
 ;
"RTN","RORX003",46,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORX003",47,0)
 ;
"RTN","RORX003",48,0)
 ; The ^TMP("RORX003",$J) global node is used by this function.
"RTN","RORX003",49,0)
 ;
"RTN","RORX003",50,0)
 ; Return Values:
"RTN","RORX003",51,0)
 ;       <0  Error code
"RTN","RORX003",52,0)
 ;        0  Ok
"RTN","RORX003",53,0)
 ;
"RTN","RORX003",54,0)
UTLDMG(RORTSK) ;
"RTN","RORX003",55,0)
 N RORAGEDT      ; Base date for age calculations
"RTN","RORX003",56,0)
 N RORARV        ; Closed root of the ARV drug list
"RTN","RORX003",57,0)
 N ROREDT        ; End date
"RTN","RORX003",58,0)
 N RORFL798      ; Fields to load from the file #798
"RTN","RORX003",59,0)
 N RORFLDS       ; List of additional fields
"RTN","RORX003",60,0)
 N RORFLICR      ; Fields to load from the file #799.4
"RTN","RORX003",61,0)
 N RORMODE       ; Patient selection options
"RTN","RORX003",62,0)
 N ROROPT        ; Report options
"RTN","RORX003",63,0)
 N RORREG        ; Registry IEN
"RTN","RORX003",64,0)
 N RORRISK       ; Risk factor counters
"RTN","RORX003",65,0)
 N RORSDT        ; Start date
"RTN","RORX003",66,0)
 N RORSUM        ; Summary data
"RTN","RORX003",67,0)
 N RORUTIL       ; Utilization code counters
"RTN","RORX003",68,0)
 ;
"RTN","RORX003",69,0)
 N CNT,ECNT,IEN,IENS,PATIENTS,RC,REPORT,RORPTN,SFLAGS,TMP,XREFNODE
"RTN","RORX003",70,0)
 ;--- Root node of the report
"RTN","RORX003",71,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX003",72,0)
 Q:REPORT<0 REPORT
"RTN","RORX003",73,0)
 ;
"RTN","RORX003",74,0)
 ;--- Get and prepare the report parameters
"RTN","RORX003",75,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")
"RTN","RORX003",76,0)
 S RC=$$PARAMS^RORXU002(.RORTSK,REPORT,.RORSDT,.ROREDT,.SFLAGS)
"RTN","RORX003",77,0)
 Q:RC<0 RC
"RTN","RORX003",78,0)
 S RORMODE=$$PARAM^RORTSK01("PATIENTS")
"RTN","RORX003",79,0)
 D LIST^RORXU002(.RORMODE)
"RTN","RORX003",80,0)
 S ROROPT=$$PARAM^RORTSK01("OPTIONS")
"RTN","RORX003",81,0)
 D LIST^RORXU002(.ROROPT)
"RTN","RORX003",82,0)
 I '$D(ROROPT("SUMMARY"))  S RORFLDS=$$PARAM^RORTSK01("FIELDS")
"RTN","RORX003",83,0)
 E  S RORFLDS="RACE,RISK,AGE,SEX,REIMBLVL,UTIL"
"RTN","RORX003",84,0)
 D LIST^RORXU002(.RORFLDS)
"RTN","RORX003",85,0)
 ;
"RTN","RORX003",86,0)
 ;--- Initialize constants and variables
"RTN","RORX003",87,0)
 S RORPTN=$$REGSIZE^RORUTL02(+RORREG)  S:RORPTN<0 RORPTN=0
"RTN","RORX003",88,0)
 S XREFNODE=$NA(^RORDATA(798,"AC",RORREG))
"RTN","RORX003",89,0)
 S ECNT=0,SFLAGS=SFLAGS_"DI"
"RTN","RORX003",90,0)
 S TMP=$$FMDIFF^XLFDT(ROREDT,RORSDT)
"RTN","RORX003",91,0)
 S RORAGEDT=$$FMADD^XLFDT(RORSDT,TMP\2)
"RTN","RORX003",92,0)
 ;
"RTN","RORX003",93,0)
 ;--- Prepare the ARV drug list
"RTN","RORX003",94,0)
 S RORARV=$NA(^TMP("RORX003",$J))
"RTN","RORX003",95,0)
 S RC=$$DRUGLIST^RORUTL16(RORARV,+RORREG)  Q:RC<0 RC
"RTN","RORX003",96,0)
 ;
"RTN","RORX003",97,0)
 D
"RTN","RORX003",98,0)
 . ;--- Report header
"RTN","RORX003",99,0)
 . S RC=$$HEADER(REPORT)  Q:RC<0
"RTN","RORX003",100,0)
 . ;---
"RTN","RORX003",101,0)
 . S PATIENTS=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,REPORT)
"RTN","RORX003",102,0)
 . I PATIENTS<0  S RC=+PATIENTS  Q
"RTN","RORX003",103,0)
 . D ADDATTR^RORTSK11(RORTSK,PATIENTS,"TABLE","PATIENTS")
"RTN","RORX003",104,0)
 . ;
"RTN","RORX003",105,0)
 . D TPPSETUP^RORTSK01(97)
"RTN","RORX003",106,0)
 . ;--- Browse through the registry records
"RTN","RORX003",107,0)
 . S (CNT,IEN,RC)=0
"RTN","RORX003",108,0)
 . F  S IEN=$O(@XREFNODE@(IEN))  Q:IEN'>0  D  Q:RC<0
"RTN","RORX003",109,0)
 . . S TMP=$S(RORPTN>0:CNT/RORPTN,1:"")
"RTN","RORX003",110,0)
 . . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX003",111,0)
 . . S IENS=IEN_",",CNT=CNT+1
"RTN","RORX003",112,0)
 . . ;--- Check if the patient should be skipped
"RTN","RORX003",113,0)
 . . Q:$$SKIP^RORXU005(IEN,SFLAGS,RORSDT,ROREDT)
"RTN","RORX003",114,0)
 . . ;--- Process the registry record
"RTN","RORX003",115,0)
 . . S TMP=$$PATIENT^RORX003A(IENS,PATIENTS)
"RTN","RORX003",116,0)
 . . I TMP<0  S ECNT=ECNT+1  Q
"RTN","RORX003",117,0)
 . Q:RC<0
"RTN","RORX003",118,0)
 . ;
"RTN","RORX003",119,0)
 . ;--- Report summary
"RTN","RORX003",120,0)
 . D TPPSETUP^RORTSK01(3)
"RTN","RORX003",121,0)
 . S RC=$$SUMMARY^RORX003A(REPORT,PATIENTS)  Q:RC<0
"RTN","RORX003",122,0)
 . ;
"RTN","RORX003",123,0)
 . ;--- Summary only
"RTN","RORX003",124,0)
 . D:'$D(ROROPT("COMPLETE")) UPDVAL^RORTSK11(RORTSK,PATIENTS,,,1)
"RTN","RORX003",125,0)
 ;
"RTN","RORX003",126,0)
 ;--- Cleanup
"RTN","RORX003",127,0)
 K ^TMP("RORX003",$J)
"RTN","RORX003",128,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX003A")
0^177^B34213708
"RTN","RORX003A",1,0)
RORX003A ;HCIOFO/SG - GENERAL UTLIZATION AND DEMOGRAPHICS ; 12/30/03 10:05am
"RTN","RORX003A",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORX003A",3,0)
 ;
"RTN","RORX003A",4,0)
 ; This routine uses the following IAs:
"RTN","RORX003A",5,0)
 ;
"RTN","RORX003A",6,0)
 ; #10061        2^VADPT (supported)
"RTN","RORX003A",7,0)
 ;
"RTN","RORX003A",8,0)
 Q
"RTN","RORX003A",9,0)
 ;
"RTN","RORX003A",10,0)
 ;***** INCREMENTS SUMMARY COUNTER
"RTN","RORX003A",11,0)
INCSUM(SUMMARY,VAL) ;
"RTN","RORX003A",12,0)
 S:$G(VAL)="" VAL="NO DATA"
"RTN","RORX003A",13,0)
 S RORSUM(SUMMARY,VAL)=$G(RORSUM(SUMMARY,VAL))+1
"RTN","RORX003A",14,0)
 Q
"RTN","RORX003A",15,0)
 ;
"RTN","RORX003A",16,0)
 ;***** ADDS THE PATIENT DATA TO THE REPORT
"RTN","RORX003A",17,0)
 ;
"RTN","RORX003A",18,0)
 ; IENS          IENS of the patient's record in the registry
"RTN","RORX003A",19,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX003A",20,0)
 ;
"RTN","RORX003A",21,0)
 ; Return Values:
"RTN","RORX003A",22,0)
 ;       <0  Error code
"RTN","RORX003A",23,0)
 ;        0  Ok
"RTN","RORX003A",24,0)
 ;       >0  Skip the patient
"RTN","RORX003A",25,0)
 ;
"RTN","RORX003A",26,0)
PATIENT(IENS,PARTAG) ;
"RTN","RORX003A",27,0)
 N CLINAIDS,DFN,IEN,NAME,RC,RORBUF,RORMSG,TMP,UTIL,VA,VADM,VAERR,VAHOW,VAPTYP,VAROOT
"RTN","RORX003A",28,0)
 S RC=0
"RTN","RORX003A",29,0)
 ;
"RTN","RORX003A",30,0)
 ;--- Check the clinical status
"RTN","RORX003A",31,0)
 S CLINAIDS=$$CLINAIDS^RORICRUT(+IENS,ROREDT)
"RTN","RORX003A",32,0)
 Q:'$D(RORMODE($S(CLINAIDS:"AIDS",1:"HIV"))) 1
"RTN","RORX003A",33,0)
 ;
"RTN","RORX003A",34,0)
 ;--- Get the data from the ROR LOCAL REGISTRY file
"RTN","RORX003A",35,0)
 I $G(RORFL798)'=""  D  Q:RC<0 RC
"RTN","RORX003A",36,0)
 . D GETS^DIQ(798,IENS,RORFL798,"I","RORBUF","RORMSG")
"RTN","RORX003A",37,0)
 . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,798,IENS)  Q
"RTN","RORX003A",38,0)
 S DFN=$G(RORBUF(798,IENS,.01,"I"))
"RTN","RORX003A",39,0)
 ;
"RTN","RORX003A",40,0)
 ;--- Skip a patient without utilization
"RTN","RORX003A",41,0)
 S UTIL("ALL")=1
"RTN","RORX003A",42,0)
 S UTIL=$$UTIL^RORXU003(RORSDT,ROREDT,DFN,.UTIL)
"RTN","RORX003A",43,0)
 Q:'UTIL 1
"RTN","RORX003A",44,0)
 ;
"RTN","RORX003A",45,0)
 ;--- Get the data from the ROR ICR STUDY file
"RTN","RORX003A",46,0)
 I $G(RORFLICR)'=""  D  Q:RC<0 RC
"RTN","RORX003A",47,0)
 . D GETS^DIQ(799.4,IENS,RORFLICR,"I","RORBUF","RORMSG")
"RTN","RORX003A",48,0)
 . I $G(DIERR),'$D(RORMSG("DIERR","E",601))  D  Q
"RTN","RORX003A",49,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,,799.4,IENS)
"RTN","RORX003A",50,0)
 ;--- Load the demographic data
"RTN","RORX003A",51,0)
 D 2^VADPT
"RTN","RORX003A",52,0)
 ;
"RTN","RORX003A",53,0)
 ;--- The <PATIENT> tag
"RTN","RORX003A",54,0)
 S PTAG=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,PARTAG,,DFN)
"RTN","RORX003A",55,0)
 Q:PTAG<0 PTAG  S RORSUM=$G(RORSUM)+1
"RTN","RORX003A",56,0)
 ;--- Patient Name
"RTN","RORX003A",57,0)
 D ADDVAL^RORTSK11(RORTSK,"NAME",VADM(1),PTAG,1)
"RTN","RORX003A",58,0)
 ;--- last 4 digits of the SSN
"RTN","RORX003A",59,0)
 D ADDVAL^RORTSK11(RORTSK,"LAST4",VA("BID"),PTAG,2)
"RTN","RORX003A",60,0)
 ;
"RTN","RORX003A",61,0)
 ;--- Race
"RTN","RORX003A",62,0)
 D:$D(RORFLDS("RACE"))
"RTN","RORX003A",63,0)
 . N I,RACES,SUMVAL
"RTN","RORX003A",64,0)
 . S RACES=$$ADDVAL^RORTSK11(RORTSK,"RACES",,PTAG)
"RTN","RORX003A",65,0)
 . I $G(VADM(12))>0  S I=""  D
"RTN","RORX003A",66,0)
 . . F  S I=$O(VADM(12,I))  Q:I=""  D
"RTN","RORX003A",67,0)
 . . . S SUMVAL=$P(VADM(12,I),U,2)
"RTN","RORX003A",68,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"RACE",SUMVAL,RACES)
"RTN","RORX003A",69,0)
 . . S:VADM(12)>1 SUMVAL="MULTIPLE VALUES"
"RTN","RORX003A",70,0)
 . E  D ADDVAL^RORTSK11(RORTSK,"RACE",,RACES)
"RTN","RORX003A",71,0)
 . D INCSUM("RACE",$G(SUMVAL))
"RTN","RORX003A",72,0)
 ;
"RTN","RORX003A",73,0)
 ;--- Risk factors
"RTN","RORX003A",74,0)
 D:$D(RORFLDS("RISK"))
"RTN","RORX003A",75,0)
 . N I,RISKS
"RTN","RORX003A",76,0)
 . S RISKS=$$RISKS^RORXU005(+IENS)  S:RISKS<0 RISKS=""
"RTN","RORX003A",77,0)
 . D ADDVAL^RORTSK11(RORTSK,"RISK",RISKS,PTAG)
"RTN","RORX003A",78,0)
 . S RISKS=$TR(RISKS," ")
"RTN","RORX003A",79,0)
 . F I=1:1  S TMP=$P(RISKS,",",I)  Q:TMP'>0  D
"RTN","RORX003A",80,0)
 . . S RORRISK(TMP)=$G(RORRISK(TMP))+1
"RTN","RORX003A",81,0)
 ;
"RTN","RORX003A",82,0)
 ;--- Age
"RTN","RORX003A",83,0)
 D:$D(RORFLDS("AGE"))
"RTN","RORX003A",84,0)
 . S TMP=+$G(VADM(6))  ; Date of Death
"RTN","RORX003A",85,0)
 . S TMP=$S(TMP'>0:RORAGEDT,TMP<RORAGEDT:TMP,1:RORAGEDT)
"RTN","RORX003A",86,0)
 . S TMP=$$FMDIFF^XLFDT(TMP,+VADM(3))\365
"RTN","RORX003A",87,0)
 . D ADDVAL^RORTSK11(RORTSK,"AGE",$S(TMP>0:TMP,1:""),PTAG,1)
"RTN","RORX003A",88,0)
 . Q:TMP'>0
"RTN","RORX003A",89,0)
 . S RORSUM("AGE")=$G(RORSUM("AGE"))+1
"RTN","RORX003A",90,0)
 . S RORSUM("AGE","Average")=$G(RORSUM("AGE","Average"))+TMP
"RTN","RORX003A",91,0)
 . D INCSUM("AGE",TMP-(TMP#10))
"RTN","RORX003A",92,0)
 ;
"RTN","RORX003A",93,0)
 ;--- Sex
"RTN","RORX003A",94,0)
 D:$D(RORFLDS("SEX"))
"RTN","RORX003A",95,0)
 . S TMP=$P(VADM(5),U,2)
"RTN","RORX003A",96,0)
 . D ADDVAL^RORTSK11(RORTSK,"SEX",TMP,PTAG,1)
"RTN","RORX003A",97,0)
 . D INCSUM("SEX",TMP)
"RTN","RORX003A",98,0)
 ;
"RTN","RORX003A",99,0)
 ;--- Primary eligibility
"RTN","RORX003A",100,0)
 D:$D(RORFLDS("PRIMELIG"))
"RTN","RORX003A",101,0)
 . D ADDVAL^RORTSK11(RORTSK,"PRIMELIG",$P(VAEL(1),U,2),PTAG,1)
"RTN","RORX003A",102,0)
 ;
"RTN","RORX003A",103,0)
 ;--- Clinical AIDS status
"RTN","RORX003A",104,0)
 D:$D(RORFLDS("AIDSTAT"))
"RTN","RORX003A",105,0)
 . D ADDVAL^RORTSK11(RORTSK,"AIDSTAT",+CLINAIDS,PTAG,1)
"RTN","RORX003A",106,0)
 ;
"RTN","RORX003A",107,0)
 ;--- Reimbursement level
"RTN","RORX003A",108,0)
 D:$D(RORFLDS("REIMBLVL"))
"RTN","RORX003A",109,0)
 . S TMP=$$REIMBLVL^RORXU005(+IENS,RORARV,RORSDT,ROREDT)
"RTN","RORX003A",110,0)
 . S TMP=$S(TMP=30:"AIDS+ARV",TMP=20:"AIDS",TMP=10:"ARV",'TMP:"NOARV",1:"")
"RTN","RORX003A",111,0)
 . D ADDVAL^RORTSK11(RORTSK,"REIMBLVL",TMP,PTAG,1)
"RTN","RORX003A",112,0)
 . D INCSUM("REIMBLVL",TMP)
"RTN","RORX003A",113,0)
 ;
"RTN","RORX003A",114,0)
 ;--- Date Entered into the Registry
"RTN","RORX003A",115,0)
 D:$D(RORFLDS("ENTDT"))
"RTN","RORX003A",116,0)
 . S TMP=$$DATE^RORXU002($G(RORBUF(798,IENS,1,"I"))\1)
"RTN","RORX003A",117,0)
 . D ADDVAL^RORTSK11(RORTSK,"ENTDT",TMP,PTAG,1)
"RTN","RORX003A",118,0)
 ;
"RTN","RORX003A",119,0)
 ;--- Utilization
"RTN","RORX003A",120,0)
 D:$D(RORFLDS("UTIL"))
"RTN","RORX003A",121,0)
 . S TMP=$$UTLCODES($P(UTIL,U,2,999))
"RTN","RORX003A",122,0)
 . D ADDVAL^RORTSK11(RORTSK,"UTIL",TMP,PTAG)
"RTN","RORX003A",123,0)
 ;
"RTN","RORX003A",124,0)
 ;--- Alive?
"RTN","RORX003A",125,0)
 D:$D(RORFLDS("ALIVE"))
"RTN","RORX003A",126,0)
 . S TMP=VADM(6)\1,TMP=$S(TMP>0:TMP>ROREDT,1:1)
"RTN","RORX003A",127,0)
 . S TMP=$S(TMP:"",1:VADM(6)\1)
"RTN","RORX003A",128,0)
 . D ADDVAL^RORTSK11(RORTSK,"ALIVE",TMP,PTAG,1)
"RTN","RORX003A",129,0)
 Q 0
"RTN","RORX003A",130,0)
 ;
"RTN","RORX003A",131,0)
 ;***** GENERATES THE REPORT SUMMARY
"RTN","RORX003A",132,0)
 ;
"RTN","RORX003A",133,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX003A",134,0)
 ;
"RTN","RORX003A",135,0)
 ; PATIENTS      Reference (IEN) to the PATIENTS tag
"RTN","RORX003A",136,0)
 ;
"RTN","RORX003A",137,0)
 ; Return Values:
"RTN","RORX003A",138,0)
 ;       <0  Error code
"RTN","RORX003A",139,0)
 ;        0  Ok
"RTN","RORX003A",140,0)
 ;
"RTN","RORX003A",141,0)
SUMMARY(PARTAG,PATIENTS) ;
"RTN","RORX003A",142,0)
 N AGE,I,RC,RORBUF,SI,SUMMARY,TABLE,TAG,TMP
"RTN","RORX003A",143,0)
 S SUMMARY=$$ADDVAL^RORTSK11(RORTSK,"SUMMARY",,PARTAG)
"RTN","RORX003A",144,0)
 Q:SUMMARY<0 SUMMARY
"RTN","RORX003A",145,0)
 ;
"RTN","RORX003A",146,0)
 ;--- Risk factors
"RTN","RORX003A",147,0)
 D:$D(RORRISK)>1
"RTN","RORX003A",148,0)
 . K RORBUF  D BLD^DIALOG(7980000.016,.RORRISK,,"RORBUF")
"RTN","RORX003A",149,0)
 . D ADDTEXT^RORTSK11(RORTSK,"RISK_FACTORS",.RORBUF,SUMMARY)
"RTN","RORX003A",150,0)
 ;
"RTN","RORX003A",151,0)
 ;--- Simple summaries
"RTN","RORX003A",152,0)
 F SI="RACE","SEX","REIMBLVL"  D:$D(RORSUM(SI))>1
"RTN","RORX003A",153,0)
 . S TABLE=$$ADDVAL^RORTSK11(RORTSK,SI_"_SUMMARY",,SUMMARY)
"RTN","RORX003A",154,0)
 . S I=""
"RTN","RORX003A",155,0)
 . F  S I=$O(RORSUM(SI,I))  Q:I=""  D
"RTN","RORX003A",156,0)
 . . S TAG=$$ADDVAL^RORTSK11(RORTSK,SI,I,TABLE)
"RTN","RORX003A",157,0)
 . . D ADDATTR^RORTSK11(RORTSK,TAG,"COUNT",RORSUM(SI,I))
"RTN","RORX003A",158,0)
 ;
"RTN","RORX003A",159,0)
 ;--- Utilization codes
"RTN","RORX003A",160,0)
 D:$D(RORUTIL)>1
"RTN","RORX003A",161,0)
 . K RORBUF  D BLD^DIALOG(7980000.017,.RORUTIL,,"RORBUF")
"RTN","RORX003A",162,0)
 . D ADDTEXT^RORTSK11(RORTSK,"UTIL_CODES",.RORBUF,SUMMARY)
"RTN","RORX003A",163,0)
 ;
"RTN","RORX003A",164,0)
 ;--- Age summary
"RTN","RORX003A",165,0)
 I $G(RORSUM("AGE"))>0  D
"RTN","RORX003A",166,0)
 . ;--- Average age
"RTN","RORX003A",167,0)
 . S TMP=$G(RORSUM("AGE","Average"))/RORSUM("AGE")
"RTN","RORX003A",168,0)
 . S RORSUM("AGE","Average")=$J(TMP,0,2)
"RTN","RORX003A",169,0)
 . ;--- Median age
"RTN","RORX003A",170,0)
 . S TMP=$$XREFNODE^RORTSK10(RORTSK,PATIENTS,"AGE")
"RTN","RORX003A",171,0)
 . S:TMP'="" TMP=$$XREFMDNV^RORXU004(TMP,RORSUM("AGE"))
"RTN","RORX003A",172,0)
 . S RORSUM("AGE","Median")=$S(TMP'="":$J(TMP,0,2),1:"")
"RTN","RORX003A",173,0)
 . ;--- Output the table
"RTN","RORX003A",174,0)
 . S TABLE=$$ADDVAL^RORTSK11(RORTSK,"AGE_SUMMARY",,SUMMARY)
"RTN","RORX003A",175,0)
 . S I=""
"RTN","RORX003A",176,0)
 . F  S I=$O(RORSUM("AGE",I))  Q:I=""  D
"RTN","RORX003A",177,0)
 . . S TAG=$$ADDVAL^RORTSK11(RORTSK,"AGE",$S(+I=I:I_"+",1:I),TABLE)
"RTN","RORX003A",178,0)
 . . D ADDATTR^RORTSK11(RORTSK,TAG,"COUNT",RORSUM("AGE",I))
"RTN","RORX003A",179,0)
 ;---
"RTN","RORX003A",180,0)
 Q 0
"RTN","RORX003A",181,0)
 ;
"RTN","RORX003A",182,0)
 ;***** PROCESSES UTILIZATION CODES
"RTN","RORX003A",183,0)
UTLCODES(UCSRC) ;
"RTN","RORX003A",184,0)
 N I,UCLST  S UCLST=""
"RTN","RORX003A",185,0)
 F I=1:1  S UC=$P(UCSRC,U,I)  Q:UC=""  D
"RTN","RORX003A",186,0)
 . S UCLST=UCLST_", "_UC,RORUTIL(UC)=$G(RORUTIL(UC))+1
"RTN","RORX003A",187,0)
 Q $P(UCLST,", ",2,999)
"RTN","RORX004")
0^84^B27546159
"RTN","RORX004",1,0)
RORX004 ;HOIFO/BH,SG - CLINIC FOLLOW UP ; 1/12/04 10:21am
"RTN","RORX004",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;March 14, 2003
"RTN","RORX004",3,0)
 ;
"RTN","RORX004",4,0)
 ; This routine uses the following IAs:
"RTN","RORX004",5,0)
 ;
"RTN","RORX004",6,0)
 ; #10040        Access to the HOSPITAL LOCATION file (supported)
"RTN","RORX004",7,0)
 ; #10061        2^VADPT (supported)
"RTN","RORX004",8,0)
 ;
"RTN","RORX004",9,0)
 ;--------------------------------------------------------------------
"RTN","RORX004",10,0)
 ; Registry: [VA ICR]
"RTN","RORX004",11,0)
 ;--------------------------------------------------------------------
"RTN","RORX004",12,0)
 Q
"RTN","RORX004",13,0)
 ;
"RTN","RORX004",14,0)
 ;***** COMPILES THE "CLINIC FOLLOW UP" REPORT
"RTN","RORX004",15,0)
 ; REPORT CODE: 004
"RTN","RORX004",16,0)
 ;
"RTN","RORX004",17,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORX004",18,0)
 ;
"RTN","RORX004",19,0)
 ; Return Values:
"RTN","RORX004",20,0)
 ;       <0  Error code
"RTN","RORX004",21,0)
 ;        0  Ok
"RTN","RORX004",22,0)
 ;
"RTN","RORX004",23,0)
CLNFLWUP(RORTSK) ;
"RTN","RORX004",24,0)
 N RORCLIN       ; List of clinic IEN's
"RTN","RORX004",25,0)
 N ROREDT        ; End date
"RTN","RORX004",26,0)
 N RORMODE       ; Subset of patients to be selected
"RTN","RORX004",27,0)
 N ROROPT        ; Report options
"RTN","RORX004",28,0)
 N RORREG        ; Registry IEN
"RTN","RORX004",29,0)
 N RORSDT        ; Start date
"RTN","RORX004",30,0)
 N RORSUM        ; Summary data
"RTN","RORX004",31,0)
 ;
"RTN","RORX004",32,0)
 N CNT,ECNT,IEN,IENS,PATIENTS,RC,REPORT,RORPTN,SFLAGS,TMP,XREFNODE
"RTN","RORX004",33,0)
 ;--- Root node of the report
"RTN","RORX004",34,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX004",35,0)
 Q:REPORT<0 REPORT
"RTN","RORX004",36,0)
 ;
"RTN","RORX004",37,0)
 ;--- Get and prepare the report parameters
"RTN","RORX004",38,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")
"RTN","RORX004",39,0)
 S RC=$$PARAMS(REPORT,.RORSDT,.ROREDT,.SFLAGS)
"RTN","RORX004",40,0)
 Q:RC<0 RC
"RTN","RORX004",41,0)
 S RORMODE=$$PARAM^RORTSK01("PATIENTS")
"RTN","RORX004",42,0)
 D LIST^RORXU002(.RORMODE)
"RTN","RORX004",43,0)
 S ROROPT=$$PARAM^RORTSK01("OPTIONS")
"RTN","RORX004",44,0)
 D LIST^RORXU002(.ROROPT)
"RTN","RORX004",45,0)
 ;
"RTN","RORX004",46,0)
 ;--- Initialize constants and variables
"RTN","RORX004",47,0)
 S RORPTN=$$REGSIZE^RORUTL02(+RORREG)  S:RORPTN<0 RORPTN=0
"RTN","RORX004",48,0)
 S ECNT=0,XREFNODE=$NA(^RORDATA(798,"AC",RORREG))
"RTN","RORX004",49,0)
 S SFLAGS=SFLAGS_"DI"
"RTN","RORX004",50,0)
 ;
"RTN","RORX004",51,0)
 D
"RTN","RORX004",52,0)
 . ;--- Report header
"RTN","RORX004",53,0)
 . S RC=$$HEADER(REPORT)  Q:RC<0
"RTN","RORX004",54,0)
 . S PATIENTS=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,REPORT)
"RTN","RORX004",55,0)
 . I PATIENTS<0  S RC=+PATIENTS  Q
"RTN","RORX004",56,0)
 . D ADDATTR^RORTSK11(RORTSK,PATIENTS,"TABLE","PATIENTS")
"RTN","RORX004",57,0)
 . ;
"RTN","RORX004",58,0)
 . ;--- Browse through the registry records
"RTN","RORX004",59,0)
 . D TPPSETUP^RORTSK01(99)
"RTN","RORX004",60,0)
 . S (CNT,IEN,RC)=0
"RTN","RORX004",61,0)
 . F  S IEN=$O(@XREFNODE@(IEN))  Q:IEN'>0  D  Q:RC<0
"RTN","RORX004",62,0)
 . . S TMP=$S(RORPTN>0:CNT/RORPTN,1:"")
"RTN","RORX004",63,0)
 . . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX004",64,0)
 . . S IENS=IEN_",",CNT=CNT+1
"RTN","RORX004",65,0)
 . . ;--- Check if the patient should be skipped
"RTN","RORX004",66,0)
 . . Q:$$SKIP^RORXU005(IEN,SFLAGS,RORSDT,ROREDT)
"RTN","RORX004",67,0)
 . . ;--- Process the registry record
"RTN","RORX004",68,0)
 . . S TMP=$$PATIENT(IENS,PATIENTS)
"RTN","RORX004",69,0)
 . . I TMP<0  S ECNT=ECNT+1  Q
"RTN","RORX004",70,0)
 . Q:RC<0
"RTN","RORX004",71,0)
 . ;
"RTN","RORX004",72,0)
 . ;--- Report summary
"RTN","RORX004",73,0)
 . I $D(ROROPT("SUMMARY"))  D  Q:RC<0
"RTN","RORX004",74,0)
 . . D TPPSETUP^RORTSK01(1)
"RTN","RORX004",75,0)
 . . S RC=$$SUMMARY(REPORT,PATIENTS)
"RTN","RORX004",76,0)
 ;
"RTN","RORX004",77,0)
 ;--- Cleanup
"RTN","RORX004",78,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX004",79,0)
 ;
"RTN","RORX004",80,0)
 ;***** OUTPUTS THE REPORT HEADER
"RTN","RORX004",81,0)
 ;
"RTN","RORX004",82,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX004",83,0)
 ;
"RTN","RORX004",84,0)
 ; Return Values:
"RTN","RORX004",85,0)
 ;       <0  Error code
"RTN","RORX004",86,0)
 ;        0  Ok
"RTN","RORX004",87,0)
 ;
"RTN","RORX004",88,0)
HEADER(PARTAG) ;
"RTN","RORX004",89,0)
 ;;PATIENTS(#,NAME,LAST4,AIDSTAT,SEEN,LSNDT)
"RTN","RORX004",90,0)
 ;
"RTN","RORX004",91,0)
 N HEADER,RC
"RTN","RORX004",92,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX004",93,0)
 Q:HEADER<0 HEADER
"RTN","RORX004",94,0)
 S RC=$$TBLDEF^RORXU002("HEADER^RORX004",HEADER)
"RTN","RORX004",95,0)
 Q $S(RC<0:RC,1:HEADER)
"RTN","RORX004",96,0)
 ;
"RTN","RORX004",97,0)
 ;***** INCREMENTS SUMMARY COUNTER
"RTN","RORX004",98,0)
INCSUM(SUMMARY,VAL) ;
"RTN","RORX004",99,0)
 S:$G(VAL)="" VAL="No Data"
"RTN","RORX004",100,0)
 S RORSUM(SUMMARY,VAL)=$G(RORSUM(SUMMARY,VAL))+1
"RTN","RORX004",101,0)
 Q
"RTN","RORX004",102,0)
 ;
"RTN","RORX004",103,0)
 ;***** OUTPUTS THE PARAMETERS TO THE REPORT
"RTN","RORX004",104,0)
 ;
"RTN","RORX004",105,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX004",106,0)
 ;
"RTN","RORX004",107,0)
 ; [.STDT]       Start and end dates of the report
"RTN","RORX004",108,0)
 ; [.ENDT]       are returned via these parameters
"RTN","RORX004",109,0)
 ;
"RTN","RORX004",110,0)
 ; Return Values:
"RTN","RORX004",111,0)
 ;       <0  Error code
"RTN","RORX004",112,0)
 ;       >0  IEN of the PARAMETERS element
"RTN","RORX004",113,0)
 ;
"RTN","RORX004",114,0)
PARAMS(PARTAG,STDT,ENDT,FLAGS) ;
"RTN","RORX004",115,0)
 N PARAMS,TMP
"RTN","RORX004",116,0)
 S PARAMS=$$PARAMS^RORXU002(.RORTSK,PARTAG,.STDT,.ENDT,.FLAGS)
"RTN","RORX004",117,0)
 Q:PARAMS<0 PARAMS
"RTN","RORX004",118,0)
 ;--- Process the list of clinics
"RTN","RORX004",119,0)
 S TMP=$$CLINLST^RORXU006(.RORTSK,PARAMS,"RORCLIN")
"RTN","RORX004",120,0)
 Q:TMP<0 TMP
"RTN","RORX004",121,0)
 ;---
"RTN","RORX004",122,0)
 Q PARAMS
"RTN","RORX004",123,0)
 ;
"RTN","RORX004",124,0)
 ;***** ADDS THE PATIENT DATA TO THE REPORT
"RTN","RORX004",125,0)
 ;
"RTN","RORX004",126,0)
 ; IENS          IENS of the patient's record in the registry
"RTN","RORX004",127,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX004",128,0)
 ;
"RTN","RORX004",129,0)
 ; Return Values:
"RTN","RORX004",130,0)
 ;       <0  Error code
"RTN","RORX004",131,0)
 ;        0  Ok
"RTN","RORX004",132,0)
 ;       >0  Skip the patient
"RTN","RORX004",133,0)
 ;
"RTN","RORX004",134,0)
PATIENT(IENS,PARTAG) ;
"RTN","RORX004",135,0)
 N CHK,CLINAIDS,DFN,IEN,RC,RORBUF,RORMSG,SEEN,TMP,VA,VADM,VAHOW,VAROOT
"RTN","RORX004",136,0)
 S RC=0
"RTN","RORX004",137,0)
 S DFN=$$PTIEN^RORUTL01(+IENS)
"RTN","RORX004",138,0)
 ;
"RTN","RORX004",139,0)
 ;--- Check the clinical status
"RTN","RORX004",140,0)
 S CLINAIDS=$$CLINAIDS^RORICRUT(+IENS,ROREDT)
"RTN","RORX004",141,0)
 Q:'$D(RORMODE($S(CLINAIDS:"AIDS",1:"HIV"))) 1
"RTN","RORX004",142,0)
 ; 
"RTN","RORX004",143,0)
 ;--- Only include patients that received utilization if care is true
"RTN","RORX004",144,0)
 I $D(RORMODE("CAREONLY"))  D  Q:'TMP 1
"RTN","RORX004",145,0)
 . S CHK("ALL")=""
"RTN","RORX004",146,0)
 . S TMP=$$UTIL^RORXU003(RORSDT,ROREDT,DFN,.CHK)
"RTN","RORX004",147,0)
 ;
"RTN","RORX004",148,0)
 ;--- Select Seen/NotSeen patients
"RTN","RORX004",149,0)
 S SEEN=$$SEEN^RORXU001(RORSDT,ROREDT,DFN,.RORCLIN)
"RTN","RORX004",150,0)
 Q:'$D(RORMODE($S(SEEN:"SEEN",1:"NOTSEEN"))) 1
"RTN","RORX004",151,0)
 ;
"RTN","RORX004",152,0)
 ;--- Load the demographic data
"RTN","RORX004",153,0)
 D 2^VADPT
"RTN","RORX004",154,0)
 ;
"RTN","RORX004",155,0)
 ;--- The <PATIENT> tag
"RTN","RORX004",156,0)
 S PTAG=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,PARTAG,,DFN)
"RTN","RORX004",157,0)
 Q:PTAG<0 PTAG  S RORSUM=$G(RORSUM)+1
"RTN","RORX004",158,0)
 ;
"RTN","RORX004",159,0)
 ;--- Patient Name
"RTN","RORX004",160,0)
 D ADDVAL^RORTSK11(RORTSK,"NAME",VADM(1),PTAG,1)
"RTN","RORX004",161,0)
 ;--- last 4 digits of the SSN
"RTN","RORX004",162,0)
 D ADDVAL^RORTSK11(RORTSK,"LAST4",VA("BID"),PTAG,2)
"RTN","RORX004",163,0)
 ;--- Clinical AIDS status
"RTN","RORX004",164,0)
 D ADDVAL^RORTSK11(RORTSK,"AIDSTAT",+CLINAIDS,PTAG,1)
"RTN","RORX004",165,0)
 D INCSUM("PATIENT",$S(CLINAIDS:"AIDS OI",1:"HIV+ (no AIDS OI)"))
"RTN","RORX004",166,0)
 ;--- Seen/Not Seen
"RTN","RORX004",167,0)
 D ADDVAL^RORTSK11(RORTSK,"SEEN",SEEN,PTAG,1)
"RTN","RORX004",168,0)
 D INCSUM("PATIENT",$S(SEEN:"Seen",1:"Not Seen"))
"RTN","RORX004",169,0)
 ;--- The latest date the patient was seen at any one of
"RTN","RORX004",170,0)
 ;--- the given clinics
"RTN","RORX004",171,0)
 S TMP=$$LASTVSIT^RORXU001(DFN,.RORCLIN)\1
"RTN","RORX004",172,0)
 D ADDVAL^RORTSK11(RORTSK,"LSNDT",$$DATE^RORXU002(TMP),PTAG,1)
"RTN","RORX004",173,0)
 Q 0
"RTN","RORX004",174,0)
 ;
"RTN","RORX004",175,0)
 ;***** GENERATES THE REPORT SUMMARY
"RTN","RORX004",176,0)
 ;
"RTN","RORX004",177,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX004",178,0)
 ;
"RTN","RORX004",179,0)
 ; PATIENTS      Reference (IEN) to the PATIENTS tag
"RTN","RORX004",180,0)
 ;
"RTN","RORX004",181,0)
 ; Return Values:
"RTN","RORX004",182,0)
 ;       <0  Error code
"RTN","RORX004",183,0)
 ;        0  Ok
"RTN","RORX004",184,0)
 ;
"RTN","RORX004",185,0)
SUMMARY(PARTAG,PATIENTS) ;
"RTN","RORX004",186,0)
 N I,RC,SI,SUMMARY,TABLE,TAG,TMP
"RTN","RORX004",187,0)
 S SUMMARY=$$ADDVAL^RORTSK11(RORTSK,"SUMMARY",,PARTAG)
"RTN","RORX004",188,0)
 ;
"RTN","RORX004",189,0)
 ;--- Simple summaries
"RTN","RORX004",190,0)
 F SI="PATIENT"  D:$D(RORSUM(SI))>1
"RTN","RORX004",191,0)
 . S TABLE=$$ADDVAL^RORTSK11(RORTSK,SI_"_SUMMARY",,SUMMARY)
"RTN","RORX004",192,0)
 . S I=""
"RTN","RORX004",193,0)
 . F  S I=$O(RORSUM(SI,I))  Q:I=""  D
"RTN","RORX004",194,0)
 . . S TAG=$$ADDVAL^RORTSK11(RORTSK,SI,I,TABLE)
"RTN","RORX004",195,0)
 . . D ADDATTR^RORTSK11(RORTSK,TAG,"COUNT",RORSUM(SI,I))
"RTN","RORX004",196,0)
 ;---
"RTN","RORX004",197,0)
 Q 0
"RTN","RORX005")
0^147^B15608297
"RTN","RORX005",1,0)
RORX005 ;HCIOFO/BH,SG - INPATIENT & OUTPATIENT UTILIZATION ; 12/29/03 3:43pm
"RTN","RORX005",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX005",3,0)
 ;
"RTN","RORX005",4,0)
 ;--------------------------------------------------------------------
"RTN","RORX005",5,0)
 ; Registry: [VA ICR]
"RTN","RORX005",6,0)
 ;--------------------------------------------------------------------
"RTN","RORX005",7,0)
 Q
"RTN","RORX005",8,0)
 ;
"RTN","RORX005",9,0)
 ;***** OUTPUTS THE REPORT HEADER
"RTN","RORX005",10,0)
 ;
"RTN","RORX005",11,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX005",12,0)
 ;
"RTN","RORX005",13,0)
 ; Return Values:
"RTN","RORX005",14,0)
 ;       <0  Error code
"RTN","RORX005",15,0)
 ;       >0  IEN of the HEADER element
"RTN","RORX005",16,0)
 ;
"RTN","RORX005",17,0)
HEADER(PARTAG) ;
"RTN","RORX005",18,0)
 ;;HU_DAYS(#,NAME,LAST4,NST,ND,NSS)
"RTN","RORX005",19,0)
 ;;HU_STAYS(#,NAME,LAST4,NST,ND,NSS)
"RTN","RORX005",20,0)
 ;;HU_STOPS(#,NAME,LAST4,NV,NSC,NDS)
"RTN","RORX005",21,0)
 ;;BEDSECTIONS(#,NAME,NP,NST,ND,MLOS,NSS)
"RTN","RORX005",22,0)
 ;;NOBS(#,NAME,LAST4,DATE,PTF)
"RTN","RORX005",23,0)
 ;;STAYS(NP,NST)
"RTN","RORX005",24,0)
 ;;CLINICS(#,STOP,NAME,NP,NV,NSC)
"RTN","RORX005",25,0)
 ;;STOPS(NP,NSC)
"RTN","RORX005",26,0)
 ;
"RTN","RORX005",27,0)
 N HEADER,RC
"RTN","RORX005",28,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX005",29,0)
 Q:HEADER<0 HEADER
"RTN","RORX005",30,0)
 S RC=$$TBLDEF^RORXU002("HEADER^RORX005",HEADER)
"RTN","RORX005",31,0)
 Q $S(RC<0:RC,1:HEADER)
"RTN","RORX005",32,0)
 ;
"RTN","RORX005",33,0)
 ;
"RTN","RORX005",34,0)
 ;***** COMPILES THE "INPATIENT AND OUTPATIENT UTILIZATION" REPORT
"RTN","RORX005",35,0)
 ; REPORT CODE: 005
"RTN","RORX005",36,0)
 ;
"RTN","RORX005",37,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORX005",38,0)
 ;
"RTN","RORX005",39,0)
 ; The ^TMP("RORX005",$J) global node is used by this function.
"RTN","RORX005",40,0)
 ;
"RTN","RORX005",41,0)
 ; ^TMP("RORX005",$J,
"RTN","RORX005",42,0)
 ;   CatSub,             ("HIV", "AIDS", or "ALLCATS")
"RTN","RORX005",43,0)
 ;
"RTN","RORX005",44,0)
 ;     "IP",             Number of inpatients
"RTN","RORX005",45,0)
 ;       DFN,            Last 4 digits of SSN
"RTN","RORX005",46,0)
 ;         "D")          Number of days
"RTN","RORX005",47,0)
 ;         "S")          Number of overnight stays
"RTN","RORX005",48,0)
 ;         "V")          Number of short stays
"RTN","RORX005",49,0)
 ;
"RTN","RORX005",50,0)
 ;     "IPB",
"RTN","RORX005",51,0)
 ;#      BedSectID,
"RTN","RORX005",52,0)
 ;         "D")          Number of days
"RTN","RORX005",53,0)
 ;         "P",          Number of patients
"RTN","RORX005",54,0)
 ;           DFN)
"RTN","RORX005",55,0)
 ;         "S")          Number of overnight stays
"RTN","RORX005",56,0)
 ;         "V")          Number of short stays
"RTN","RORX005",57,0)
 ;       "B",
"RTN","RORX005",58,0)
 ;         BedSectName,
"RTN","RORX005",59,0)
 ;%          BedSectID)
"RTN","RORX005",60,0)
 ;
"RTN","RORX005",61,0)
 ;     "IPD",            Total number of days
"RTN","RORX005",62,0)
 ;       NumOfDays,      Number of patients
"RTN","RORX005",63,0)
 ;         PatientName,
"RTN","RORX005",64,0)
 ;           DFN)
"RTN","RORX005",65,0)
 ;
"RTN","RORX005",66,0)
 ;     "IPMLOS",         Median Length Of Stay
"RTN","RORX005",67,0)
 ;*      BedSectID,      Median Length Of Stay
"RTN","RORX005",68,0)
 ;         NumOfDays,
"RTN","RORX005",69,0)
 ;           Seq#)
"RTN","RORX005",70,0)
 ;
"RTN","RORX005",71,0)
 ;     "IPNOBS",
"RTN","RORX005",72,0)
 ;        PatientName,
"RTN","RORX005",73,0)
 ;          Date,
"RTN","RORX005",74,0)
 ;            PTF#,
"RTN","RORX005",75,0)
 ;              DFN)
"RTN","RORX005",76,0)
 ;
"RTN","RORX005",77,0)
 ;     "IPS",            Total number of stays
"RTN","RORX005",78,0)
 ;       NumOfStays,     Number of patients
"RTN","RORX005",79,0)
 ;         PatientName,
"RTN","RORX005",80,0)
 ;           DFN)
"RTN","RORX005",81,0)
 ;
"RTN","RORX005",82,0)
 ;     "IPV")            Total number of short stays
"RTN","RORX005",83,0)
 ;
"RTN","RORX005",84,0)
 ;     "OP",             Number of outpatients
"RTN","RORX005",85,0)
 ;       DFN,            Patient's data
"RTN","RORX005",86,0)
 ;                         ^01: Number of stops
"RTN","RORX005",87,0)
 ;                         ^02: Number of different stops
"RTN","RORX005",88,0)
 ;                         ^03: Last 4 digits of SSN
"RTN","RORX005",89,0)
 ;                         ^04: Number of visits
"RTN","RORX005",90,0)
 ;                       Children of this node are KILL'ed by
"RTN","RORX005",91,0)
 ;                       the $$TOTALS^RORX005B function.
"RTN","RORX005",92,0)
 ;         Date,         Number of stops associated with the visit
"RTN","RORX005",93,0)
 ;           StopCode)   Quantity
"RTN","RORX005",94,0)
 ;
"RTN","RORX005",95,0)
 ;     "OPS",            Totals
"RTN","RORX005",96,0)
 ;                         ^01: Total number of stops
"RTN","RORX005",97,0)
 ;                         ^02: Number of different stops
"RTN","RORX005",98,0)
 ;       StopCode,       Name of the Clinic Stop Code
"RTN","RORX005",99,0)
 ;         "P")          Number of patients
"RTN","RORX005",100,0)
 ;         "S")          Quantity
"RTN","RORX005",101,0)
 ;         "V")          Number of visits
"RTN","RORX005",102,0)
 ;
"RTN","RORX005",103,0)
 ;     "OPS1",
"RTN","RORX005",104,0)
 ;       NumOfStops,     Number of patients
"RTN","RORX005",105,0)
 ;         PatientName,
"RTN","RORX005",106,0)
 ;           DFN)
"RTN","RORX005",107,0)
 ;
"RTN","RORX005",108,0)
 ;     "OPV")            Total number of visits
"RTN","RORX005",109,0)
 ;
"RTN","RORX005",110,0)
 ; Bed section IDs (BedSectID):
"RTN","RORX005",111,0)
 ;   -1  No bed section               [#%*]
"RTN","RORX005",112,0)
 ;    0  Whole patient's stays        [  *]
"RTN","RORX005",113,0)
 ;   >0  Bed section ID (IEN;File#)   [# *]
"RTN","RORX005",114,0)
 ;
"RTN","RORX005",115,0)
 ; Return Values:
"RTN","RORX005",116,0)
 ;       <0  Error code
"RTN","RORX005",117,0)
 ;        0  Ok
"RTN","RORX005",118,0)
 ;
"RTN","RORX005",119,0)
IPOPUTL(RORTSK) ;
"RTN","RORX005",120,0)
 N RORDIV        ; List of division IEN's
"RTN","RORX005",121,0)
 N ROREDT        ; End date
"RTN","RORX005",122,0)
 N RORMODE       ; Subset of patients to be selected
"RTN","RORX005",123,0)
 N ROROPT        ; Report options
"RTN","RORX005",124,0)
 N RORREG        ; Registry IEN
"RTN","RORX005",125,0)
 N RORSDT        ; Start date
"RTN","RORX005",126,0)
 ;
"RTN","RORX005",127,0)
 N ECNT,RC,REPORT,SFLAGS,TMP
"RTN","RORX005",128,0)
 ;--- Root node of the report
"RTN","RORX005",129,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX005",130,0)
 Q:REPORT<0 REPORT
"RTN","RORX005",131,0)
 ;
"RTN","RORX005",132,0)
 ;--- Get and prepare the report parameters
"RTN","RORX005",133,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")
"RTN","RORX005",134,0)
 S RC=$$PARAMS(REPORT,.RORSDT,.ROREDT,.SFLAGS)  Q:RC<0 RC
"RTN","RORX005",135,0)
 S RORMODE=$$PARAM^RORTSK01("PATIENTS")
"RTN","RORX005",136,0)
 D LIST^RORXU002(.RORMODE)
"RTN","RORX005",137,0)
 S ROROPT=$$PARAM^RORTSK01("OPTIONS")
"RTN","RORX005",138,0)
 D LIST^RORXU002(.ROROPT)
"RTN","RORX005",139,0)
 ;
"RTN","RORX005",140,0)
 ;--- Initialize constants and variables
"RTN","RORX005",141,0)
 S ECNT=0  K ^TMP("RORX005",$J)
"RTN","RORX005",142,0)
 ;
"RTN","RORX005",143,0)
 ;--- Report header
"RTN","RORX005",144,0)
 S RC=$$HEADER(REPORT)  Q:RC<0 RC
"RTN","RORX005",145,0)
 ;
"RTN","RORX005",146,0)
 D
"RTN","RORX005",147,0)
 . ;--- Query the registry
"RTN","RORX005",148,0)
 . D TPPSETUP^RORTSK01(70)
"RTN","RORX005",149,0)
 . S RC=$$QUERY^RORX005A(SFLAGS_"DI")
"RTN","RORX005",150,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX005",151,0)
 . ;--- Sort the data
"RTN","RORX005",152,0)
 . D TPPSETUP^RORTSK01(15)
"RTN","RORX005",153,0)
 . S RC=$$SORT^RORX005B()
"RTN","RORX005",154,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX005",155,0)
 . ;--- Store the results
"RTN","RORX005",156,0)
 . D TPPSETUP^RORTSK01(15)
"RTN","RORX005",157,0)
 . S RC=$$STORE^RORX005C(REPORT)
"RTN","RORX005",158,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX005",159,0)
 ;
"RTN","RORX005",160,0)
 ;--- Cleanup
"RTN","RORX005",161,0)
 K ^TMP("RORX005",$J)
"RTN","RORX005",162,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX005",163,0)
 ;
"RTN","RORX005",164,0)
 ;***** OUTPUTS THE PARAMETERS TO THE REPORT
"RTN","RORX005",165,0)
 ;
"RTN","RORX005",166,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX005",167,0)
 ;
"RTN","RORX005",168,0)
 ; [.STDT]       Start and end dates of the report
"RTN","RORX005",169,0)
 ; [.ENDT]       are returned via these parameters
"RTN","RORX005",170,0)
 ;
"RTN","RORX005",171,0)
 ; [.FLAGS]      Flags for the $$SKIP^RORXU005 are
"RTN","RORX005",172,0)
 ;               returned via this parameter
"RTN","RORX005",173,0)
 ;
"RTN","RORX005",174,0)
 ; Return Values:
"RTN","RORX005",175,0)
 ;       <0  Error code
"RTN","RORX005",176,0)
 ;       >0  IEN of the PARAMETERS element
"RTN","RORX005",177,0)
 ;
"RTN","RORX005",178,0)
PARAMS(PARTAG,STDT,ENDT,FLAGS) ;
"RTN","RORX005",179,0)
 N PARAMS,TMP
"RTN","RORX005",180,0)
 S PARAMS=$$PARAMS^RORXU002(.RORTSK,PARTAG,.STDT,.ENDT,.FLAGS)
"RTN","RORX005",181,0)
 Q:PARAMS<0 PARAMS
"RTN","RORX005",182,0)
 ;--- Process the list of divisions
"RTN","RORX005",183,0)
 S TMP=$$DIVLST^RORXU006(.RORTSK,PARAMS,"RORDIV")
"RTN","RORX005",184,0)
 Q:TMP<0 TMP
"RTN","RORX005",185,0)
 ;--- Additional parameters
"RTN","RORX005",186,0)
 F NAME="MAXUTNUM"  D
"RTN","RORX005",187,0)
 . S TMP=$$PARAM^RORTSK01(NAME)
"RTN","RORX005",188,0)
 . D:TMP'="" ADDVAL^RORTSK11(RORTSK,NAME,TMP,PARAMS)
"RTN","RORX005",189,0)
 ;---
"RTN","RORX005",190,0)
 Q PARAMS
"RTN","RORX005A")
0^149^B41714803
"RTN","RORX005A",1,0)
RORX005A ;HCIOFO/BH,SG - INP & OUT UTILIZATION (QUERY) ; 1/22/04 4:00pm
"RTN","RORX005A",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX005A",3,0)
 ;
"RTN","RORX005A",4,0)
 ; This routine uses the following IAs:
"RTN","RORX005A",5,0)
 ;
"RTN","RORX005A",6,0)
 ; #92           Read access to the file #45 (controlled)
"RTN","RORX005A",7,0)
 ; #557          Read access to the file #40.7 (controlled)
"RTN","RORX005A",8,0)
 ; #2548         ACRP Interface Toolkit (supported)
"RTN","RORX005A",9,0)
 ; #???          The .01 field and "C" x-ref of file #40.8
"RTN","RORX005A",10,0)
 ;
"RTN","RORX005A",11,0)
 Q
"RTN","RORX005A",12,0)
 ;
"RTN","RORX005A",13,0)
 ;***** ADDS THE INPATIENT STAY
"RTN","RORX005A",14,0)
 ;
"RTN","RORX005A",15,0)
 ; DFN           Patient IEN (in file #2)
"RTN","RORX005A",16,0)
 ; PTFIEN        IEN of the PTF record
"RTN","RORX005A",17,0)
 ; LOS           Length of stay
"RTN","RORX005A",18,0)
 ; BSID          Bed section ID
"RTN","RORX005A",19,0)
 ; DATE          Movement date/time (FileMan)
"RTN","RORX005A",20,0)
 ;
"RTN","RORX005A",21,0)
ADDSTAY(DFN,PTFIEN,LOS,BSID,DATE) ;
"RTN","RORX005A",22,0)
 N DST,I,TMP
"RTN","RORX005A",23,0)
 S:$G(BSID)="" BSID=0
"RTN","RORX005A",24,0)
 ;--- Number of patients for the bedsection
"RTN","RORX005A",25,0)
 I 'BSID  S DST=$NA(@RORDST@("IP",DFN))
"RTN","RORX005A",26,0)
 E  S DST=$NA(@RORDST@("IPB",BSID))  D:'$D(@DST@("P",DFN))
"RTN","RORX005A",27,0)
 . S @DST@("P")=$G(@DST@("P"))+1,@DST@("P",DFN)=""
"RTN","RORX005A",28,0)
 ;--- No bed section ID
"RTN","RORX005A",29,0)
 I BSID<0  F TMP=RORDST,RORSUM  D:TMP'=""
"RTN","RORX005A",30,0)
 . S @TMP@("IPNOBS",RORPNAME,DATE,PTFIEN,DFN)=""
"RTN","RORX005A",31,0)
 ;--- Short stays (visits)
"RTN","RORX005A",32,0)
 I LOS'>0  S @DST@("V")=$G(@DST@("V"))+1  Q
"RTN","RORX005A",33,0)
 ;--- Days and stays
"RTN","RORX005A",34,0)
 S @DST@("D")=$G(@DST@("D"))+LOS
"RTN","RORX005A",35,0)
 S @DST@("S")=$G(@DST@("S"))+1
"RTN","RORX005A",36,0)
 ;--- Lengths of stay for median value calculations
"RTN","RORX005A",37,0)
 F TMP=RORDST,RORSUM  D:TMP'=""
"RTN","RORX005A",38,0)
 . S I=$O(@TMP@("IPMLOS",BSID,LOS,""),-1)+1
"RTN","RORX005A",39,0)
 . S @TMP@("IPMLOS",BSID,LOS,I)=""
"RTN","RORX005A",40,0)
 Q
"RTN","RORX005A",41,0)
 ;
"RTN","RORX005A",42,0)
 ;***** LOADS AND PROCESSES THE INPATIENT DATA
"RTN","RORX005A",43,0)
 ;
"RTN","RORX005A",44,0)
 ; DFN           Patient IEN (in file #2)
"RTN","RORX005A",45,0)
 ; CATSUB        Category subscript in the temporary global
"RTN","RORX005A",46,0)
 ;
"RTN","RORX005A",47,0)
 ; Return Values:
"RTN","RORX005A",48,0)
 ;       <0  Error code
"RTN","RORX005A",49,0)
 ;        0  Ok
"RTN","RORX005A",50,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX005A",51,0)
 ;
"RTN","RORX005A",52,0)
IPDATA(DFN,CATSUB) ;
"RTN","RORX005A",53,0)
 N RORDST        ; Closed reference to the category node in ^TMP
"RTN","RORX005A",54,0)
 N RORSUM        ; Closed reference of the summary node in ^TMP
"RTN","RORX005A",55,0)
 ;
"RTN","RORX005A",56,0)
 N BSID,DATE,DISDT,ENDT,FACILITY,LOS,PTFIEN,RC,RORMSG,STDT,SUFFIX,TMP,VAHOW,VAIP,VAROOT
"RTN","RORX005A",57,0)
 S RORDST=$NA(^TMP("RORX005",$J,CATSUB))
"RTN","RORX005A",58,0)
 I $D(RORMODE("AIDS"))&$D(RORMODE("HIV"))  D
"RTN","RORX005A",59,0)
 . S TMP=$P($$CAT^RORICRUT(1),U)
"RTN","RORX005A",60,0)
 . S RORSUM=$NA(^TMP("RORX005",$J,TMP))
"RTN","RORX005A",61,0)
 E  S RORSUM=""
"RTN","RORX005A",62,0)
 ;---
"RTN","RORX005A",63,0)
 S DATE=RORSDT
"RTN","RORX005A",64,0)
 F  S RC=0  D  Q:RC<2  S DATE=$O(^DGPT("AAD",DFN,DATE))  Q:DATE'>0
"RTN","RORX005A",65,0)
 . I DATE'<ROREDT1  S RC=1  Q
"RTN","RORX005A",66,0)
 . K LOS,VAIP  S VAIP(16,1)=DATE
"RTN","RORX005A",67,0)
 . F  D  Q:RC
"RTN","RORX005A",68,0)
 . . S VAIP("D")=+$G(VAIP(16,1))
"RTN","RORX005A",69,0)
 . . I VAIP("D")'>0  S RC=2  Q
"RTN","RORX005A",70,0)
 . . D IN5^VADPT
"RTN","RORX005A",71,0)
 . . I $G(VAIP(1))'>0  S RC=2  Q
"RTN","RORX005A",72,0)
 . . S DATE=+VAIP(3)
"RTN","RORX005A",73,0)
 . . Q:+$G(VAIP(4))=3
"RTN","RORX005A",74,0)
 . . ;--- Check the movement date
"RTN","RORX005A",75,0)
 . . I DATE'<ROREDT1  S RC=1  Q
"RTN","RORX005A",76,0)
 . . S:DATE<RORSDT DATE=RORSDT
"RTN","RORX005A",77,0)
 . . ;--- Check the PTF record
"RTN","RORX005A",78,0)
 . . S PTFIEN=+$G(VAIP(12))  Q:PTFIEN'>0
"RTN","RORX005A",79,0)
 . . I '$D(PTFIEN(PTFIEN))  D  Q:RC
"RTN","RORX005A",80,0)
 . . . S PTFIEN(PTFIEN)=0
"RTN","RORX005A",81,0)
 . . . Q:$$PTF^RORXU001(PTFIEN,"P",,,.SUFFIX,,.FACILITY)
"RTN","RORX005A",82,0)
 . . . ;--- Check the suffix
"RTN","RORX005A",83,0)
 . . . I SUFFIX'=""  Q:$$VSUFFIX^RORX005U(SUFFIX)
"RTN","RORX005A",84,0)
 . . . ;--- Check the division
"RTN","RORX005A",85,0)
 . . . I '$D(RORDIV("ALL"))  D  Q:'$D(RORDIV(DIVIEN))
"RTN","RORX005A",86,0)
 . . . . S TMP=FACILITY_SUFFIX
"RTN","RORX005A",87,0)
 . . . . S DIVIEN=$S(TMP'="":+$O(^DG(40.8,"C",TMP,"")),1:0)
"RTN","RORX005A",88,0)
 . . . S PTFIEN(PTFIEN)=1
"RTN","RORX005A",89,0)
 . . ;--- Skip the PTF record if necessary
"RTN","RORX005A",90,0)
 . . Q:'PTFIEN(PTFIEN)
"RTN","RORX005A",91,0)
 . . ;--- Process the admission (only once)
"RTN","RORX005A",92,0)
 . . I '$D(LOS)  D  Q:RC
"RTN","RORX005A",93,0)
 . . . S LOS=$$LOS^RORX005U(+$G(VAIP(13,1)),+$G(VAIP(17,1)))
"RTN","RORX005A",94,0)
 . . . D ADDSTAY(DFN,PTFIEN,LOS)
"RTN","RORX005A",95,0)
 . . ;--- Process the movement
"RTN","RORX005A",96,0)
 . . S ENDT=$G(VAIP(16,1))\1
"RTN","RORX005A",97,0)
 . . S:(ENDT'>0)!(ENDT'<ROREDT1) ENDT=ROREDT,RC=2
"RTN","RORX005A",98,0)
 . . Q:ENDT<RORSDT
"RTN","RORX005A",99,0)
 . . S LOS=$$FMDIFF^XLFDT(ENDT,DATE\1,1)  S:LOS'>0 LOS=0
"RTN","RORX005A",100,0)
 . . ;--- Use the IEN in the SPECIALTY file (#42.4) as the Bedsection 
"RTN","RORX005A",101,0)
 . . ;    ID if it is available (it should be). Otherwise, use the
"RTN","RORX005A",102,0)
 . . ;--- IEN in the FACILITY TREATING SPECIALTY file (#45.7).
"RTN","RORX005A",103,0)
 . . I $G(VAIP(8))>0  D
"RTN","RORX005A",104,0)
 . . . S TMP=$$GET1^DIQ(45.7,+VAIP(8),1,"I",,"RORMSG")
"RTN","RORX005A",105,0)
 . . . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,DFN,45.7,+VAIP(8))
"RTN","RORX005A",106,0)
 . . . S BSID=$S(TMP>0:TMP_";42.4",1:+VAIP(8)_";45.7")
"RTN","RORX005A",107,0)
 . . E  S BSID=-1
"RTN","RORX005A",108,0)
 . . D ADDSTAY(DFN,PTFIEN,LOS,BSID,+VAIP(3))
"RTN","RORX005A",109,0)
 ;---
"RTN","RORX005A",110,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORX005A",111,0)
 ;
"RTN","RORX005A",112,0)
 ;***** LOADS AND PROCESSES THE OUTPATIENT DATA
"RTN","RORX005A",113,0)
 ;
"RTN","RORX005A",114,0)
 ; RORDFN        Patient IEN (in file #2)
"RTN","RORX005A",115,0)
 ;
"RTN","RORX005A",116,0)
 ; CATSUB        Category subscript in the temporary global
"RTN","RORX005A",117,0)
 ;
"RTN","RORX005A",118,0)
 ; Return Values:
"RTN","RORX005A",119,0)
 ;       <0  Error code
"RTN","RORX005A",120,0)
 ;        0  Ok
"RTN","RORX005A",121,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX005A",122,0)
 ;
"RTN","RORX005A",123,0)
OPDATA(RORDFN,CATSUB) ;
"RTN","RORX005A",124,0)
 N QUERY,RORDST,RORECNT
"RTN","RORX005A",125,0)
 S RORDST=$NA(^TMP("RORX005",$J,CATSUB))
"RTN","RORX005A",126,0)
 D OPEN^SDQ(.QUERY)
"RTN","RORX005A",127,0)
 D INDEX^SDQ(.QUERY,"PATIENT/DATE","SET")
"RTN","RORX005A",128,0)
 D PAT^SDQ(.QUERY,RORDFN,"SET")
"RTN","RORX005A",129,0)
 D DATE^SDQ(.QUERY,RORSDT,ROREDT1,"SET")
"RTN","RORX005A",130,0)
 D SCANCB^SDQ(.QUERY,"D SCAN^RORX005A(Y,Y0)","SET")
"RTN","RORX005A",131,0)
 D ACTIVE^SDQ(.QUERY,"TRUE","SET")
"RTN","RORX005A",132,0)
 D SCAN^SDQ(.QUERY,"FORWARD")
"RTN","RORX005A",133,0)
 D CLOSE^SDQ(.QUERY)
"RTN","RORX005A",134,0)
 Q +$G(RORECNT)
"RTN","RORX005A",135,0)
 ;
"RTN","RORX005A",136,0)
 ;***** QUERIES THE REGISTRY
"RTN","RORX005A",137,0)
 ;
"RTN","RORX005A",138,0)
 ; FLAGS         Flags for the $$SKIP^RORXU005
"RTN","RORX005A",139,0)
 ;
"RTN","RORX005A",140,0)
 ; Return Values:
"RTN","RORX005A",141,0)
 ;       <0  Error code
"RTN","RORX005A",142,0)
 ;        0  Ok
"RTN","RORX005A",143,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX005A",144,0)
 ;
"RTN","RORX005A",145,0)
QUERY(FLAGS) ;
"RTN","RORX005A",146,0)
 N ROREDT1       ; Day after the end date
"RTN","RORX005A",147,0)
 N RORLAST4      ; Last 4 digits of the current patient's SSN
"RTN","RORX005A",148,0)
 N RORPNAME      ; Name of the current patient
"RTN","RORX005A",149,0)
 N RORPTN        ; Number of patients in the registry
"RTN","RORX005A",150,0)
 ;
"RTN","RORX005A",151,0)
 N CATSUB,CNT,ECNT,IEN,IENS,PATIEN,RC,TMP,VA,VADM,XREFNODE
"RTN","RORX005A",152,0)
 S XREFNODE=$NA(^RORDATA(798,"AC",+RORREG))
"RTN","RORX005A",153,0)
 S RORPTN=$$REGSIZE^RORUTL02(+RORREG)  S:RORPTN<0 RORPTN=0
"RTN","RORX005A",154,0)
 S ROREDT1=$$FMADD^XLFDT(ROREDT,1)
"RTN","RORX005A",155,0)
 S (CNT,ECNT,RC)=0
"RTN","RORX005A",156,0)
 ;--- Browse through the registry records
"RTN","RORX005A",157,0)
 S IEN=0
"RTN","RORX005A",158,0)
 F  S IEN=$O(@XREFNODE@(IEN))  Q:IEN'>0  D  Q:RC<0
"RTN","RORX005A",159,0)
 . S TMP=$S(RORPTN>0:CNT/RORPTN,1:"")
"RTN","RORX005A",160,0)
 . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX005A",161,0)
 . S IENS=IEN_",",CNT=CNT+1
"RTN","RORX005A",162,0)
 . ;--- Check if the patient should be skipped
"RTN","RORX005A",163,0)
 . Q:$$SKIP^RORXU005(IEN,FLAGS,RORSDT,ROREDT)
"RTN","RORX005A",164,0)
 . ;
"RTN","RORX005A",165,0)
 . ;--- Get the patient IEN (DFN)
"RTN","RORX005A",166,0)
 . S PATIEN=$$PTIEN^RORUTL01(IEN)  Q:PATIEN'>0
"RTN","RORX005A",167,0)
 . ;
"RTN","RORX005A",168,0)
 . ;--- Get the category subscript
"RTN","RORX005A",169,0)
 . S TMP=$$CLINAIDS^RORICRUT(IEN,ROREDT)
"RTN","RORX005A",170,0)
 . Q:'$D(RORMODE($S(TMP:"AIDS",1:"HIV")))
"RTN","RORX005A",171,0)
 . S CATSUB=$S(TMP:"AIDS",1:"HIV")
"RTN","RORX005A",172,0)
 . ;
"RTN","RORX005A",173,0)
 . ;--- Get the patient's data
"RTN","RORX005A",174,0)
 . D VADEM^RORUTL05(PATIEN,1)
"RTN","RORX005A",175,0)
 . S RORPNAME=VADM(1),RORLAST4=VA("BID")
"RTN","RORX005A",176,0)
 . ;
"RTN","RORX005A",177,0)
 . ;--- Get the outpatient data
"RTN","RORX005A",178,0)
 . I $D(RORMODE("OUTPATIENT"))  D  I RC  S ECNT=ECNT+1  Q:RC<0
"RTN","RORX005A",179,0)
 . . S RC=$$OPDATA(PATIEN,CATSUB)
"RTN","RORX005A",180,0)
 . ;
"RTN","RORX005A",181,0)
 . ;--- Get the inpatient data
"RTN","RORX005A",182,0)
 . I $D(RORMODE("INPATIENT"))  D  I RC  S ECNT=ECNT+1  Q:RC<0
"RTN","RORX005A",183,0)
 . . S RC=$$IPDATA(PATIEN,CATSUB)
"RTN","RORX005A",184,0)
 . ;
"RTN","RORX005A",185,0)
 . ;--- Calculate intermediate totals
"RTN","RORX005A",186,0)
 . S RC=$$TOTALS^RORX005B(PATIEN,CATSUB)
"RTN","RORX005A",187,0)
 . I RC  S ECNT=ECNT+1  Q:RC<0
"RTN","RORX005A",188,0)
 ;---
"RTN","RORX005A",189,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX005A",190,0)
 ;
"RTN","RORX005A",191,0)
 ;***** CALLBACK ENTRY POINT FOR ACRP API
"RTN","RORX005A",192,0)
SCAN(Y,Y0) ;
"RTN","RORX005A",193,0)
 N DTX,STOP,TMP
"RTN","RORX005A",194,0)
 ;--- Check the division
"RTN","RORX005A",195,0)
 I '$D(RORDIV("ALL"))  S TMP=+$P(Y0,U,11)  Q:'$D(RORDIV(TMP))
"RTN","RORX005A",196,0)
 ;--- Data comes from the OUTPATIENT ENCOUNTER file (409.68)
"RTN","RORX005A",197,0)
 S STOP=$P($G(^DIC(40.7,+$P(Y0,U,3),0)),U,2),DTX=Y0\1
"RTN","RORX005A",198,0)
 S:STOP="" STOP="NSC"
"RTN","RORX005A",199,0)
 S @RORDST@("OP",RORDFN,DTX)=$G(@RORDST@("OP",RORDFN,DTX))+1
"RTN","RORX005A",200,0)
 S @RORDST@("OP",RORDFN,DTX,STOP)=$G(@RORDST@("OP",RORDFN,DTX,STOP))+1
"RTN","RORX005A",201,0)
 Q
"RTN","RORX005B")
0^153^B41086248
"RTN","RORX005B",1,0)
RORX005B ;HCIOFO/BH,SG - INPT & OUT UTILIZATION (SORT) ; 12/22/03 1:25pm
"RTN","RORX005B",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX005B",3,0)
 ;
"RTN","RORX005B",4,0)
 Q
"RTN","RORX005B",5,0)
 ;
"RTN","RORX005B",6,0)
 ;***** CALCULATES MEDIAN LENGTHS OF STAY
"RTN","RORX005B",7,0)
 ;
"RTN","RORX005B",8,0)
 ; NODE          Closed root of the category section
"RTN","RORX005B",9,0)
 ;               in the temporary global
"RTN","RORX005B",10,0)
 ;
"RTN","RORX005B",11,0)
 ; FSUM          Update the summary data (0/1)
"RTN","RORX005B",12,0)
 ;
"RTN","RORX005B",13,0)
MLOS(NODE) ;
"RTN","RORX005B",14,0)
 N BSID,TMP,XREFNODE
"RTN","RORX005B",15,0)
 ;--- Median length of the whole stays
"RTN","RORX005B",16,0)
 S XREFNODE=$NA(@NODE@("IPMLOS",0))
"RTN","RORX005B",17,0)
 S TMP=$$XREFMDNV^RORXU004(XREFNODE,+$G(@NODE@("IPS")))
"RTN","RORX005B",18,0)
 S (@NODE@("IPMLOS"),@NODE@("IPMLOS",0))=TMP
"RTN","RORX005B",19,0)
 ;--- Median lengths of the bed section stays
"RTN","RORX005B",20,0)
 S BSID=""
"RTN","RORX005B",21,0)
 F  S BSID=$O(@NODE@("IPMLOS",BSID))  Q:BSID=""  D:BSID
"RTN","RORX005B",22,0)
 . S XREFNODE=$NA(@NODE@("IPMLOS",BSID))
"RTN","RORX005B",23,0)
 . S TMP=+$G(@NODE@("IPB",BSID,"S"))
"RTN","RORX005B",24,0)
 . S @NODE@("IPMLOS",BSID)=$$XREFMDNV^RORXU004(XREFNODE,TMP)
"RTN","RORX005B",25,0)
 Q
"RTN","RORX005B",26,0)
 ;
"RTN","RORX005B",27,0)
 ;***** SORTS THE RESULTS AND COMPILES THE TOTALS
"RTN","RORX005B",28,0)
 ;
"RTN","RORX005B",29,0)
 ; Return Values:
"RTN","RORX005B",30,0)
 ;       <0  Error code
"RTN","RORX005B",31,0)
 ;        0  Ok
"RTN","RORX005B",32,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX005B",33,0)
 ;
"RTN","RORX005B",34,0)
SORT() ;
"RTN","RORX005B",35,0)
 N CATSUB,ECNT,FSUM,NODE,NSUB,RC,RORI,RORSUM,TMP
"RTN","RORX005B",36,0)
 S (ECNT,RC)=0
"RTN","RORX005B",37,0)
 S RORSUM=$NA(^TMP("RORX005",$J,$P($$CAT^RORICRUT(1),U)))
"RTN","RORX005B",38,0)
 S NSUB=$$NCAT^RORICRUT
"RTN","RORX005B",39,0)
 ;---
"RTN","RORX005B",40,0)
 F RORI=NSUB:-1:1  D  Q:RC<0
"RTN","RORX005B",41,0)
 . S RC=$$LOOP^RORTSK01((NSUB-RORI)/NSUB)  Q:RC<0
"RTN","RORX005B",42,0)
 . S CATSUB=$P($$CAT^RORICRUT(RORI),U)
"RTN","RORX005B",43,0)
 . S NODE=$NA(^TMP("RORX005",$J,CATSUB))
"RTN","RORX005B",44,0)
 . Q:$D(@NODE)<10
"RTN","RORX005B",45,0)
 . S FSUM=$D(RORMODE("AIDS"))&$D(RORMODE("HIV"))&(RORI'=1)
"RTN","RORX005B",46,0)
 . ;---
"RTN","RORX005B",47,0)
 . D SORTOP(NODE,FSUM)
"RTN","RORX005B",48,0)
 . D SORTIP(NODE,FSUM)
"RTN","RORX005B",49,0)
 ;---
"RTN","RORX005B",50,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX005B",51,0)
 ;
"RTN","RORX005B",52,0)
 ;***** SORTS THE INPATIENT DATA
"RTN","RORX005B",53,0)
 ;
"RTN","RORX005B",54,0)
 ; NODE          Closed root of the category section
"RTN","RORX005B",55,0)
 ;               in the temporary global
"RTN","RORX005B",56,0)
 ;
"RTN","RORX005B",57,0)
 ; FSUM          Update the summary data (0/1)
"RTN","RORX005B",58,0)
 ;
"RTN","RORX005B",59,0)
SORTIP(NODE,FSUM) ;
"RTN","RORX005B",60,0)
 N BSID,DFN,FILE,I,IENS,LOS,NAME,NPT,RORMSG,TMP
"RTN","RORX005B",61,0)
 ;--- Bed sections
"RTN","RORX005B",62,0)
 S BSID=""
"RTN","RORX005B",63,0)
 F  S BSID=$O(@NODE@("IPB",BSID))  Q:'BSID  D
"RTN","RORX005B",64,0)
 . D:BSID>0
"RTN","RORX005B",65,0)
 . . S IENS=(+BSID)_",",FILE=+$P(BSID,";",2)
"RTN","RORX005B",66,0)
 . . S NAME=$$GET1^DIQ(FILE,IENS,.01,,,"RORMSG")
"RTN","RORX005B",67,0)
 . . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,FILE,IENS)
"RTN","RORX005B",68,0)
 . . S:NAME?." " NAME="Unknown ("_BSID_")"
"RTN","RORX005B",69,0)
 . . S @NODE@("IPB","B",NAME,BSID)=""
"RTN","RORX005B",70,0)
 . Q:'FSUM
"RTN","RORX005B",71,0)
 . S I=""
"RTN","RORX005B",72,0)
 . F  S I=$O(@NODE@("IPB",BSID,I))  Q:I=""  D
"RTN","RORX005B",73,0)
 . . S TMP=+$G(@NODE@("IPB",BSID,I))
"RTN","RORX005B",74,0)
 . . S:TMP @RORSUM@("IPB",BSID,I)=$G(@RORSUM@("IPB",BSID,I))+TMP
"RTN","RORX005B",75,0)
 ;--- Median length of stay
"RTN","RORX005B",76,0)
 D MLOS(NODE)
"RTN","RORX005B",77,0)
 ;---
"RTN","RORX005B",78,0)
 Q:'FSUM
"RTN","RORX005B",79,0)
 ;--- Inpatients
"RTN","RORX005B",80,0)
 S DFN=0
"RTN","RORX005B",81,0)
 F  S DFN=$O(@NODE@("IP",DFN))  Q:DFN'>0  D
"RTN","RORX005B",82,0)
 . M @RORSUM@("IP",DFN)=@NODE@("IP",DFN)
"RTN","RORX005B",83,0)
 S @RORSUM@("IP")=$G(@RORSUM@("IP"))+$G(@NODE@("IP"))
"RTN","RORX005B",84,0)
 ;--- Number of days, stays, and short visits
"RTN","RORX005B",85,0)
 F NAME="IPD","IPS","IPV"  D
"RTN","RORX005B",86,0)
 . S I=""
"RTN","RORX005B",87,0)
 . F  S I=$O(@NODE@(NAME,I))  Q:I=""  D
"RTN","RORX005B",88,0)
 . . S TMP=$G(@RORSUM@(NAME,I))
"RTN","RORX005B",89,0)
 . . M @RORSUM@(NAME,I)=@NODE@(NAME,I)
"RTN","RORX005B",90,0)
 . . S @RORSUM@(NAME,I)=TMP+$G(@NODE@(NAME,I))
"RTN","RORX005B",91,0)
 . S @RORSUM@(NAME)=$G(@RORSUM@(NAME))+$G(@NODE@(NAME))
"RTN","RORX005B",92,0)
 Q
"RTN","RORX005B",93,0)
 ;
"RTN","RORX005B",94,0)
 ;***** SORTS THE OUTPATIENT DATA
"RTN","RORX005B",95,0)
 ;
"RTN","RORX005B",96,0)
 ; NODE          Closed root of the category section
"RTN","RORX005B",97,0)
 ;               in the temporary global
"RTN","RORX005B",98,0)
 ;
"RTN","RORX005B",99,0)
 ; FSUM          Update the summary data (0/1)
"RTN","RORX005B",100,0)
 ;
"RTN","RORX005B",101,0)
SORTOP(NODE,FSUM) ;
"RTN","RORX005B",102,0)
 N I,NDSC,NAME,NSC,NV,RORBUF,RORMSG,STOP,TMP
"RTN","RORX005B",103,0)
 ;--- Outpatient stop codes
"RTN","RORX005B",104,0)
 S STOP="",(NDSC,NSC)=0
"RTN","RORX005B",105,0)
 F  S STOP=$O(@NODE@("OPS",STOP))  Q:STOP=""  D
"RTN","RORX005B",106,0)
 . S NSC=NSC+$G(@NODE@("OPS",STOP,"S")),NDSC=NDSC+1
"RTN","RORX005B",107,0)
 . D FIND^DIC(40.7,,"@;.01","UX",STOP,1,"C",,,"RORBUF","RORMSG")
"RTN","RORX005B",108,0)
 . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,40.7)
"RTN","RORX005B",109,0)
 . S NAME=$G(RORBUF("DILIST","ID",1,.01))  K RORBUF
"RTN","RORX005B",110,0)
 . S @NODE@("OPS",STOP)=$S(NAME'="":NAME,1:"Unknown")
"RTN","RORX005B",111,0)
 . Q:'FSUM
"RTN","RORX005B",112,0)
 . ;---
"RTN","RORX005B",113,0)
 . S I=""
"RTN","RORX005B",114,0)
 . F  S I=$O(@NODE@("OPS",STOP,I))  Q:I=""  D
"RTN","RORX005B",115,0)
 . . S TMP=$G(@NODE@("OPS",STOP,I))
"RTN","RORX005B",116,0)
 . . S:TMP @RORSUM@("OPS",STOP,I)=$G(@RORSUM@("OPS",STOP,I))+TMP
"RTN","RORX005B",117,0)
 S @NODE@("OPS")=NSC_U_NDSC
"RTN","RORX005B",118,0)
 ;---
"RTN","RORX005B",119,0)
 Q:'FSUM
"RTN","RORX005B",120,0)
 ;--- Outpatients
"RTN","RORX005B",121,0)
 S TMP=$G(@RORSUM@("OP"))
"RTN","RORX005B",122,0)
 M @RORSUM@("OP")=@NODE@("OP")
"RTN","RORX005B",123,0)
 S @RORSUM@("OP")=TMP+$G(@NODE@("OP"))
"RTN","RORX005B",124,0)
 ;--- Outpatient visits
"RTN","RORX005B",125,0)
 S @RORSUM@("OPV")=$G(@RORSUM@("OPV"))+$G(@NODE@("OPV"))
"RTN","RORX005B",126,0)
 ;--- Outpatient stop codes
"RTN","RORX005B",127,0)
 S NSC=0
"RTN","RORX005B",128,0)
 F  S NSC=$O(@NODE@("OPS1",NSC))  Q:NSC'>0  D
"RTN","RORX005B",129,0)
 . S TMP=$G(@RORSUM@("OPS1",NSC))
"RTN","RORX005B",130,0)
 . M @RORSUM@("OPS1",NSC)=@NODE@("OPS1",NSC)
"RTN","RORX005B",131,0)
 . S @RORSUM@("OPS1",NSC)=TMP+$G(@NODE@("OPS1",NSC))
"RTN","RORX005B",132,0)
 Q
"RTN","RORX005B",133,0)
 ;
"RTN","RORX005B",134,0)
 ;***** CALCULATES THE INTERMEDIATE TOTALS
"RTN","RORX005B",135,0)
 ;
"RTN","RORX005B",136,0)
 ; PATIEN        Patient IEN (DFN)
"RTN","RORX005B",137,0)
 ; CATSUB        Category subscript in the temporary global
"RTN","RORX005B",138,0)
 ;
"RTN","RORX005B",139,0)
 ; Return Values:
"RTN","RORX005B",140,0)
 ;       <0  Error code
"RTN","RORX005B",141,0)
 ;        0  Ok
"RTN","RORX005B",142,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX005B",143,0)
 ;
"RTN","RORX005B",144,0)
TOTALS(PATIEN,CATSUB) ;
"RTN","RORX005B",145,0)
 N NODE,TMP
"RTN","RORX005B",146,0)
 S NODE=$NA(^TMP("RORX005",$J,CATSUB))
"RTN","RORX005B",147,0)
 ;
"RTN","RORX005B",148,0)
 ;=== Outpatient data
"RTN","RORX005B",149,0)
 D:$D(@NODE@("OP",PATIEN))>1
"RTN","RORX005B",150,0)
 . N DATE,NDSC,NPSC,NSC,NV,NVSC,SCLST,STOP
"RTN","RORX005B",151,0)
 . S @NODE@("OP")=$G(@NODE@("OP"))+1
"RTN","RORX005B",152,0)
 . ;---
"RTN","RORX005B",153,0)
 . S (DATE,NPSC,NV)=0
"RTN","RORX005B",154,0)
 . F  S DATE=$O(@NODE@("OP",PATIEN,DATE))  Q:DATE'>0  D
"RTN","RORX005B",155,0)
 . . S NV=NV+1                              ; Number of visits
"RTN","RORX005B",156,0)
 . . S NVSC=@NODE@("OP",PATIEN,DATE)        ; Number of visist's stops
"RTN","RORX005B",157,0)
 . . ;--- Count the patient's stops
"RTN","RORX005B",158,0)
 . . S STOP=""
"RTN","RORX005B",159,0)
 . . F  S STOP=$O(@NODE@("OP",PATIEN,DATE,STOP))  Q:STOP=""  D
"RTN","RORX005B",160,0)
 . . . S NSC=@NODE@("OP",PATIEN,DATE,STOP)  ; Number of stops
"RTN","RORX005B",161,0)
 . . . S @NODE@("OPS",STOP,"S")=$G(@NODE@("OPS",STOP,"S"))+NSC
"RTN","RORX005B",162,0)
 . . . S @NODE@("OPS",STOP,"V")=$G(@NODE@("OPS",STOP,"V"))+(NSC/NVSC)
"RTN","RORX005B",163,0)
 . . . S SCLST(STOP)=""
"RTN","RORX005B",164,0)
 . . S NPSC=NPSC+NVSC                       ; Total number of stops
"RTN","RORX005B",165,0)
 . K @NODE@("OP",PATIEN)
"RTN","RORX005B",166,0)
 . ;--- Count the different stops and patients
"RTN","RORX005B",167,0)
 . S STOP="",NDSC=0
"RTN","RORX005B",168,0)
 . F  S STOP=$O(SCLST(STOP))  Q:STOP=""  D
"RTN","RORX005B",169,0)
 . . S @NODE@("OPS",STOP,"P")=$G(@NODE@("OPS",STOP,"P"))+1
"RTN","RORX005B",170,0)
 . . S NDSC=NDSC+1                          ; Number of diff. stops
"RTN","RORX005B",171,0)
 . ;--- Count the visits
"RTN","RORX005B",172,0)
 . S:NV>0 @NODE@("OPV")=$G(@NODE@("OPV"))+NV
"RTN","RORX005B",173,0)
 . ;--- Count the stop codes
"RTN","RORX005B",174,0)
 . D:NPSC>0
"RTN","RORX005B",175,0)
 . . S @NODE@("OP",PATIEN)=NPSC_U_NDSC_U_$G(VA("BID"))_U_NV
"RTN","RORX005B",176,0)
 . . S @NODE@("OPS1",NPSC)=$G(@NODE@("OPS1",NPSC))+1
"RTN","RORX005B",177,0)
 . . S @NODE@("OPS1",NPSC,RORPNAME,PATIEN)=""
"RTN","RORX005B",178,0)
 ;
"RTN","RORX005B",179,0)
 ;=== Inpatient data
"RTN","RORX005B",180,0)
 D:$D(@NODE@("IP",PATIEN))>1
"RTN","RORX005B",181,0)
 . N DAYS,STAYS,VISITS
"RTN","RORX005B",182,0)
 . S @NODE@("IP",PATIEN)=RORLAST4
"RTN","RORX005B",183,0)
 . S @NODE@("IP")=$G(@NODE@("IP"))+1
"RTN","RORX005B",184,0)
 . S STAYS=+$G(@NODE@("IP",PATIEN,"S"))
"RTN","RORX005B",185,0)
 . S DAYS=+$G(@NODE@("IP",PATIEN,"D"))
"RTN","RORX005B",186,0)
 . S VISITS=+$G(@NODE@("IP",PATIEN,"V"))
"RTN","RORX005B",187,0)
 . ;--- Number of stays
"RTN","RORX005B",188,0)
 . D:(STAYS>0)!(VISITS>0)
"RTN","RORX005B",189,0)
 . . S @NODE@("IPS")=$G(@NODE@("IPS"))+STAYS
"RTN","RORX005B",190,0)
 . . S @NODE@("IPS",STAYS)=$G(@NODE@("IPS",STAYS))+1
"RTN","RORX005B",191,0)
 . . S @NODE@("IPS",STAYS,RORPNAME,PATIEN)=""
"RTN","RORX005B",192,0)
 . ;--- Number of days
"RTN","RORX005B",193,0)
 . D:(DAYS>0)!(VISITS>0)
"RTN","RORX005B",194,0)
 . . S @NODE@("IPD")=$G(@NODE@("IPD"))+DAYS
"RTN","RORX005B",195,0)
 . . S @NODE@("IPD",DAYS)=$G(@NODE@("IPD",DAYS))+1
"RTN","RORX005B",196,0)
 . . S @NODE@("IPD",DAYS,RORPNAME,PATIEN)=""
"RTN","RORX005B",197,0)
 . ;--- Number of short stays (visits)
"RTN","RORX005B",198,0)
 . D:VISITS>0
"RTN","RORX005B",199,0)
 . . S @NODE@("IPV")=$G(@NODE@("IPV"))+VISITS
"RTN","RORX005B",200,0)
 Q 0
"RTN","RORX005C")
0^152^B72977604
"RTN","RORX005C",1,0)
RORX005C ;HCIOFO/BH,SG - INP & OUT UTILIZATION (STORE) ; 1/9/04 11:47am
"RTN","RORX005C",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX005C",3,0)
 ;
"RTN","RORX005C",4,0)
 Q
"RTN","RORX005C",5,0)
 ;
"RTN","RORX005C",6,0)
 ;***** HIGHEST UTILIZATION
"RTN","RORX005C",7,0)
 ;
"RTN","RORX005C",8,0)
 ; CATEGORY      IEN of the CATEGORY element
"RTN","RORX005C",9,0)
 ;
"RTN","RORX005C",10,0)
 ; RORNODE       Closed root of the category section
"RTN","RORX005C",11,0)
 ;               in the temporary global
"RTN","RORX005C",12,0)
 ;
"RTN","RORX005C",13,0)
 ; Return Values:
"RTN","RORX005C",14,0)
 ;       <0  Error code
"RTN","RORX005C",15,0)
 ;        0  Ok
"RTN","RORX005C",16,0)
 ;
"RTN","RORX005C",17,0)
HIGHUTIL(CATEGORY,RORNODE) ;
"RTN","RORX005C",18,0)
 N BUF,COUNT,DFN,I,ITEM,NAME,NUM,RC,RORMAXUT,RORTCNT,SECTION,TABLE,TMP
"RTN","RORX005C",19,0)
 S RORMAXUT=$$PARAM^RORTSK01("MAXUTNUM")
"RTN","RORX005C",20,0)
 Q:RORMAXUT'>0 0
"RTN","RORX005C",21,0)
 S SECTION=$$ADDVAL^RORTSK11(RORTSK,"HIGHUTIL",,CATEGORY)
"RTN","RORX005C",22,0)
 Q:SECTION<0 SECTION
"RTN","RORX005C",23,0)
 S (RC,RORTCNT)=0
"RTN","RORX005C",24,0)
 ;--- Stops
"RTN","RORX005C",25,0)
 I $D(@RORNODE@("OPS1"))>1  D  Q:RC<0 RC
"RTN","RORX005C",26,0)
 . S TABLE=$$ADDVAL^RORTSK11(RORTSK,"HU_STOPS",,SECTION)
"RTN","RORX005C",27,0)
 . I TABLE<0  S RC=TABLE  Q
"RTN","RORX005C",28,0)
 . D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","HU_STOPS")
"RTN","RORX005C",29,0)
 . S RORTCNT=RORTCNT+1
"RTN","RORX005C",30,0)
 . ;---
"RTN","RORX005C",31,0)
 . S NUM="",(COUNT,RC)=0
"RTN","RORX005C",32,0)
 . F  S NUM=$O(@RORNODE@("OPS1",NUM),-1)  Q:NUM=""  D  Q:RC
"RTN","RORX005C",33,0)
 . . S NAME=""
"RTN","RORX005C",34,0)
 . . F  S NAME=$O(@RORNODE@("OPS1",NUM,NAME))  Q:NAME=""  D  Q:RC
"RTN","RORX005C",35,0)
 . . . S DFN=""
"RTN","RORX005C",36,0)
 . . . F  S DFN=$O(@RORNODE@("OPS1",NUM,NAME,DFN))  Q:DFN=""  D  Q:RC
"RTN","RORX005C",37,0)
 . . . . S COUNT=COUNT+1  I COUNT>RORMAXUT  S RC=1  Q
"RTN","RORX005C",38,0)
 . . . . S BUF=$G(@RORNODE@("OP",DFN))
"RTN","RORX005C",39,0)
 . . . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,TABLE)
"RTN","RORX005C",40,0)
 . . . . D ADDVAL^RORTSK11(RORTSK,"NAME",NAME,ITEM,1)
"RTN","RORX005C",41,0)
 . . . . D ADDVAL^RORTSK11(RORTSK,"LAST4",$P(BUF,U,3),ITEM,2)
"RTN","RORX005C",42,0)
 . . . . D ADDVAL^RORTSK11(RORTSK,"NV",+$P(BUF,U,4),ITEM,3)
"RTN","RORX005C",43,0)
 . . . . D ADDVAL^RORTSK11(RORTSK,"NSC",NUM,ITEM,3)
"RTN","RORX005C",44,0)
 . . . . D ADDVAL^RORTSK11(RORTSK,"NDS",+$P(BUF,U,2),ITEM,3)
"RTN","RORX005C",45,0)
 ;--- Stays
"RTN","RORX005C",46,0)
 S RC=$$HIGHUTSD(SECTION,"IPS","HU_STAYS")  Q:RC<0 RC
"RTN","RORX005C",47,0)
 ;--- Days
"RTN","RORX005C",48,0)
 S RC=$$HIGHUTSD(SECTION,"IPD","HU_DAYS")   Q:RC<0 RC
"RTN","RORX005C",49,0)
 ;--- Disable the empty section
"RTN","RORX005C",50,0)
 D:RORTCNT'>0 UPDVAL^RORTSK11(RORTSK,SECTION,"",,1)
"RTN","RORX005C",51,0)
 Q 0
"RTN","RORX005C",52,0)
 ;
"RTN","RORX005C",53,0)
 ;*****
"RTN","RORX005C",54,0)
 ;
"RTN","RORX005C",55,0)
 ; CATEGORY      IEN of the CATEGORY element
"RTN","RORX005C",56,0)
 ;
"RTN","RORX005C",57,0)
 ; SUBS          Utilization subscript in the temporary global
"RTN","RORX005C",58,0)
 ;
"RTN","RORX005C",59,0)
 ; TBLNAME       Name of the table element
"RTN","RORX005C",60,0)
 ;
"RTN","RORX005C",61,0)
 ; Return Values:
"RTN","RORX005C",62,0)
 ;       <0  Error code
"RTN","RORX005C",63,0)
 ;        0  Ok
"RTN","RORX005C",64,0)
 ;
"RTN","RORX005C",65,0)
HIGHUTSD(SECTION,SUBS,TBLNAME) ;
"RTN","RORX005C",66,0)
 Q:$D(@RORNODE@(SUBS))<10 0
"RTN","RORX005C",67,0)
 N COUNT,DFN,ITEM,NAME,NUM,RC,TABLE,TMP
"RTN","RORX005C",68,0)
 S TABLE=$$ADDVAL^RORTSK11(RORTSK,TBLNAME,,SECTION)
"RTN","RORX005C",69,0)
 Q:TABLE<0 TABLE
"RTN","RORX005C",70,0)
 D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE",TBLNAME)
"RTN","RORX005C",71,0)
 S RORTCNT=RORTCNT+1
"RTN","RORX005C",72,0)
 ;---
"RTN","RORX005C",73,0)
 S NUM="",(COUNT,RC)=0
"RTN","RORX005C",74,0)
 F  S NUM=$O(@RORNODE@(SUBS,NUM),-1)  Q:NUM=""  D  Q:RC
"RTN","RORX005C",75,0)
 . S NAME=""
"RTN","RORX005C",76,0)
 . F  S NAME=$O(@RORNODE@(SUBS,NUM,NAME))  Q:NAME=""  D  Q:RC
"RTN","RORX005C",77,0)
 . . S DFN=""
"RTN","RORX005C",78,0)
 . . F  S DFN=$O(@RORNODE@(SUBS,NUM,NAME,DFN))  Q:DFN=""  D  Q:RC
"RTN","RORX005C",79,0)
 . . . S COUNT=COUNT+1  I COUNT>RORMAXUT  S RC=1  Q
"RTN","RORX005C",80,0)
 . . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,TABLE)
"RTN","RORX005C",81,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NAME",NAME,ITEM,1)
"RTN","RORX005C",82,0)
 . . . S TMP=$G(@RORNODE@("IP",DFN))
"RTN","RORX005C",83,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"LAST4",$P(TMP,U),ITEM,2)
"RTN","RORX005C",84,0)
 . . . S TMP=+$G(@RORNODE@("IP",DFN,"S"))
"RTN","RORX005C",85,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NST",TMP,ITEM,3)
"RTN","RORX005C",86,0)
 . . . S TMP=+$G(@RORNODE@("IP",DFN,"D"))
"RTN","RORX005C",87,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"ND",TMP,ITEM,3)
"RTN","RORX005C",88,0)
 . . . S TMP=$G(@RORNODE@("IP",DFN,"V"))
"RTN","RORX005C",89,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NSS",TMP,ITEM,3)
"RTN","RORX005C",90,0)
 Q 0
"RTN","RORX005C",91,0)
 ;
"RTN","RORX005C",92,0)
 ;***** STORES THE REPORT DATA
"RTN","RORX005C",93,0)
 ;
"RTN","RORX005C",94,0)
 ; REPORT        IEN of the REPORT element
"RTN","RORX005C",95,0)
 ;
"RTN","RORX005C",96,0)
 ; Return Values:
"RTN","RORX005C",97,0)
 ;       <0  Error code
"RTN","RORX005C",98,0)
 ;        0  Ok
"RTN","RORX005C",99,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX005C",100,0)
 ;
"RTN","RORX005C",101,0)
STORE(REPORT) ;
"RTN","RORX005C",102,0)
 N RORSONLY      ; Output summary only
"RTN","RORX005C",103,0)
 ;
"RTN","RORX005C",104,0)
 N CATEGORY,CATHDR,CATSUB,ECNT,NODE,NSUB,RC,RORI,TMP
"RTN","RORX005C",105,0)
 S RORSONLY=$$SMRYONLY^RORXU006()
"RTN","RORX005C",106,0)
 S NSUB=$$NCAT^RORICRUT
"RTN","RORX005C",107,0)
 S (ECNT,RC)=0
"RTN","RORX005C",108,0)
 ;--- Tables
"RTN","RORX005C",109,0)
 F RORI=NSUB:-1:1  D  Q:RC<0
"RTN","RORX005C",110,0)
 . S RC=$$LOOP^RORTSK01((NSUB-RORI)/3)  Q:RC<0
"RTN","RORX005C",111,0)
 . S TMP=$$CAT^RORICRUT(RORI),CATSUB=$P(TMP,U),CATHDR=$P(TMP,U,2)
"RTN","RORX005C",112,0)
 . S NODE=$NA(^TMP("RORX005",$J,CATSUB))
"RTN","RORX005C",113,0)
 . Q:$D(@NODE)<10
"RTN","RORX005C",114,0)
 . ;--- Category
"RTN","RORX005C",115,0)
 . S CATEGORY=$$ADDVAL^RORTSK11(RORTSK,"CATEGORY",,REPORT)
"RTN","RORX005C",116,0)
 . D ADDVAL^RORTSK11(RORTSK,"NAME",CATHDR,CATEGORY)
"RTN","RORX005C",117,0)
 . ;---
"RTN","RORX005C",118,0)
 . S RC=$$STOREOP(CATEGORY,NODE)
"RTN","RORX005C",119,0)
 . I RC  Q:RC<0  S ECNT=ECNT+1
"RTN","RORX005C",120,0)
 . S RC=$$STOREIP(CATEGORY,NODE)
"RTN","RORX005C",121,0)
 . I RC  Q:RC<0  S ECNT=ECNT+1
"RTN","RORX005C",122,0)
 . S RC=$$HIGHUTIL(CATEGORY,NODE)
"RTN","RORX005C",123,0)
 . I RC  Q:RC<0  S ECNT=ECNT+1
"RTN","RORX005C",124,0)
 ;---
"RTN","RORX005C",125,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX005C",126,0)
 ;
"RTN","RORX005C",127,0)
 ;***** INPATIENT DATA
"RTN","RORX005C",128,0)
 ;
"RTN","RORX005C",129,0)
 ; CATEGORY      IEN of the CATEGORY element
"RTN","RORX005C",130,0)
 ;
"RTN","RORX005C",131,0)
 ; NODE          Closed root of the category section
"RTN","RORX005C",132,0)
 ;               in the temporary global
"RTN","RORX005C",133,0)
 ;
"RTN","RORX005C",134,0)
 ; Return Values:
"RTN","RORX005C",135,0)
 ;       <0  Error code
"RTN","RORX005C",136,0)
 ;        0  Ok
"RTN","RORX005C",137,0)
 ;
"RTN","RORX005C",138,0)
STOREIP(CATEGORY,NODE) ;
"RTN","RORX005C",139,0)
 Q:$D(@NODE@("IP"))<10 0
"RTN","RORX005C",140,0)
 N BSID,DATE,ITEM,NAME,NS,PATIEN,PTF,RC,SECTION,TABLE,TMP
"RTN","RORX005C",141,0)
 S SECTION=$$ADDVAL^RORTSK11(RORTSK,"INPATIENTS",,CATEGORY)
"RTN","RORX005C",142,0)
 Q:SECTION<0 SECTION
"RTN","RORX005C",143,0)
 S RC=0
"RTN","RORX005C",144,0)
 ;--- Stays
"RTN","RORX005C",145,0)
 I $D(@NODE@("IPS"))>1  D  Q:RC<0 RC
"RTN","RORX005C",146,0)
 . S TABLE=$$ADDVAL^RORTSK11(RORTSK,"STAYS",,SECTION)
"RTN","RORX005C",147,0)
 . I TABLE<0  S RC=TABLE  Q
"RTN","RORX005C",148,0)
 . D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","STAYS")
"RTN","RORX005C",149,0)
 . S NS=""
"RTN","RORX005C",150,0)
 . F  S NS=$O(@NODE@("IPS",NS))  Q:NS=""  D
"RTN","RORX005C",151,0)
 . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"ITEM",,TABLE)
"RTN","RORX005C",152,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NP",$P(@NODE@("IPS",NS),U),ITEM,3)
"RTN","RORX005C",153,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NST",NS,ITEM,3)
"RTN","RORX005C",154,0)
 ;--- Bed sections (clinics)
"RTN","RORX005C",155,0)
 I $D(@NODE@("IPB"))>1  D  Q:RC<0 RC
"RTN","RORX005C",156,0)
 . S TABLE=$$ADDVAL^RORTSK11(RORTSK,"BEDSECTIONS",,SECTION)
"RTN","RORX005C",157,0)
 . I TABLE<0  S RC=TABLE  Q
"RTN","RORX005C",158,0)
 . D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","BEDSECTIONS")
"RTN","RORX005C",159,0)
 . S NAME=""
"RTN","RORX005C",160,0)
 . F  S NAME=$O(@NODE@("IPB","B",NAME))  Q:NAME=""  D
"RTN","RORX005C",161,0)
 . . S BSID=""
"RTN","RORX005C",162,0)
 . . F  S BSID=$O(@NODE@("IPB","B",NAME,BSID))  Q:BSID=""  D:BSID>0
"RTN","RORX005C",163,0)
 . . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"BEDSECTION",,TABLE)
"RTN","RORX005C",164,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NAME",NAME,ITEM,1)
"RTN","RORX005C",165,0)
 . . . S TMP=+$G(@NODE@("IPB",BSID,"P"))
"RTN","RORX005C",166,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NP",TMP,ITEM,3)
"RTN","RORX005C",167,0)
 . . . S TMP=+$G(@NODE@("IPB",BSID,"S"))
"RTN","RORX005C",168,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NST",TMP,ITEM,3)
"RTN","RORX005C",169,0)
 . . . S TMP=+$G(@NODE@("IPB",BSID,"D"))
"RTN","RORX005C",170,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"ND",TMP,ITEM,3)
"RTN","RORX005C",171,0)
 . . . S TMP=+$G(@NODE@("IPMLOS",BSID))
"RTN","RORX005C",172,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"MLOS",$J(TMP,0,1),ITEM,3)
"RTN","RORX005C",173,0)
 . . . S TMP=$G(@NODE@("IPB",BSID,"V"))
"RTN","RORX005C",174,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NSS",TMP,ITEM,3)
"RTN","RORX005C",175,0)
 ;--- No bed section
"RTN","RORX005C",176,0)
 I 'RORSONLY,$D(@NODE@("IPNOBS"))>1  D  Q:RC<0 RC
"RTN","RORX005C",177,0)
 . S TABLE=$$ADDVAL^RORTSK11(RORTSK,"NOBS",,SECTION)
"RTN","RORX005C",178,0)
 . I TABLE<0  S RC=TABLE  Q
"RTN","RORX005C",179,0)
 . D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","NOBS")
"RTN","RORX005C",180,0)
 . S NAME=""
"RTN","RORX005C",181,0)
 . F  S NAME=$O(@NODE@("IPNOBS",NAME))  Q:NAME=""  D
"RTN","RORX005C",182,0)
 . . S DATE=""
"RTN","RORX005C",183,0)
 . . F  S DATE=$O(@NODE@("IPNOBS",NAME,DATE))  Q:DATE=""  D
"RTN","RORX005C",184,0)
 . . . S PTF=""
"RTN","RORX005C",185,0)
 . . . F  S PTF=$O(@NODE@("IPNOBS",NAME,DATE,PTF))  Q:PTF=""  D
"RTN","RORX005C",186,0)
 . . . . S DFN=""
"RTN","RORX005C",187,0)
 . . . . F  S DFN=$O(@NODE@("IPNOBS",NAME,DATE,PTF,DFN))  Q:DFN=""  D
"RTN","RORX005C",188,0)
 . . . . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,TABLE)
"RTN","RORX005C",189,0)
 . . . . . D ADDVAL^RORTSK11(RORTSK,"NAME",NAME,ITEM,1)
"RTN","RORX005C",190,0)
 . . . . . S TMP=$P($G(@NODE@("IP",DFN)),U)
"RTN","RORX005C",191,0)
 . . . . . D ADDVAL^RORTSK11(RORTSK,"LAST4",TMP,ITEM,2)
"RTN","RORX005C",192,0)
 . . . . . D ADDVAL^RORTSK11(RORTSK,"DATE",DATE,ITEM,3)
"RTN","RORX005C",193,0)
 . . . . . D ADDVAL^RORTSK11(RORTSK,"PTF",PTF,ITEM,1)
"RTN","RORX005C",194,0)
 ;--- Summary
"RTN","RORX005C",195,0)
 D ADDVAL^RORTSK11(RORTSK,"NP",+$G(@NODE@("IP")),SECTION)
"RTN","RORX005C",196,0)
 D ADDVAL^RORTSK11(RORTSK,"NST",+$G(@NODE@("IPS")),SECTION)
"RTN","RORX005C",197,0)
 D ADDVAL^RORTSK11(RORTSK,"ND",+$G(@NODE@("IPD")),SECTION)
"RTN","RORX005C",198,0)
 D ADDVAL^RORTSK11(RORTSK,"NSS",+$G(@NODE@("IPV")),SECTION)
"RTN","RORX005C",199,0)
 S TMP=$G(@NODE@("IPMLOS",0))
"RTN","RORX005C",200,0)
 D ADDVAL^RORTSK11(RORTSK,"MLOS",$J(TMP,0,1),SECTION)
"RTN","RORX005C",201,0)
 I $G(@NODE@("IPS"))>0  D
"RTN","RORX005C",202,0)
 . S TMP=$G(@NODE@("IPD"))/@NODE@("IPS")
"RTN","RORX005C",203,0)
 E  S TMP=0
"RTN","RORX005C",204,0)
 D ADDVAL^RORTSK11(RORTSK,"ALOS",$J(TMP,0,1),SECTION)
"RTN","RORX005C",205,0)
 Q 0
"RTN","RORX005C",206,0)
 ;
"RTN","RORX005C",207,0)
 ;***** OUTPATIENT DATA
"RTN","RORX005C",208,0)
 ;
"RTN","RORX005C",209,0)
 ; CATEGORY      IEN of the CATEGORY element
"RTN","RORX005C",210,0)
 ;
"RTN","RORX005C",211,0)
 ; NODE          Closed root of the category section
"RTN","RORX005C",212,0)
 ;               in the temporary global
"RTN","RORX005C",213,0)
 ;
"RTN","RORX005C",214,0)
 ; Return Values:
"RTN","RORX005C",215,0)
 ;       <0  Error code
"RTN","RORX005C",216,0)
 ;        0  Ok
"RTN","RORX005C",217,0)
 ;
"RTN","RORX005C",218,0)
STOREOP(CATEGORY,NODE) ;
"RTN","RORX005C",219,0)
 Q:$D(@NODE@("OP"))<10 0
"RTN","RORX005C",220,0)
 N ITEM,NSC,NV,RC,SECTION,STOP,TABLE,TMP
"RTN","RORX005C",221,0)
 S SECTION=$$ADDVAL^RORTSK11(RORTSK,"OUTPATIENTS",,CATEGORY)
"RTN","RORX005C",222,0)
 Q:SECTION<0 SECTION
"RTN","RORX005C",223,0)
 S RC=0
"RTN","RORX005C",224,0)
 ;--- Stop codes
"RTN","RORX005C",225,0)
 I $D(@NODE@("OPS1"))>1  D  Q:RC<0 RC
"RTN","RORX005C",226,0)
 . S TABLE=$$ADDVAL^RORTSK11(RORTSK,"STOPS",,SECTION)
"RTN","RORX005C",227,0)
 . I TABLE<0  S RC=TABLE  Q
"RTN","RORX005C",228,0)
 . D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","STOPS")
"RTN","RORX005C",229,0)
 . S NSC=""
"RTN","RORX005C",230,0)
 . F  S NSC=$O(@NODE@("OPS1",NSC),-1)  Q:NSC=""  D
"RTN","RORX005C",231,0)
 . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"ITEM",,TABLE)
"RTN","RORX005C",232,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NP",$P(@NODE@("OPS1",NSC),U),ITEM,3)
"RTN","RORX005C",233,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NSC",NSC,ITEM,3)
"RTN","RORX005C",234,0)
 ;--- Clinics
"RTN","RORX005C",235,0)
 I $D(@NODE@("OPS"))>1  D  Q:RC<0 RC
"RTN","RORX005C",236,0)
 . S TABLE=$$ADDVAL^RORTSK11(RORTSK,"CLINICS",,SECTION)
"RTN","RORX005C",237,0)
 . I TABLE<0  S RC=TABLE  Q
"RTN","RORX005C",238,0)
 . D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","CLINICS")
"RTN","RORX005C",239,0)
 . S STOP=""
"RTN","RORX005C",240,0)
 . F  S STOP=$O(@NODE@("OPS",STOP))  Q:STOP=""  D
"RTN","RORX005C",241,0)
 . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"CLINIC",,TABLE)
"RTN","RORX005C",242,0)
 . . D ADDVAL^RORTSK11(RORTSK,"STOP",STOP,ITEM,3)
"RTN","RORX005C",243,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NAME",$P(@NODE@("OPS",STOP),U),ITEM,1)
"RTN","RORX005C",244,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NP",+$G(@NODE@("OPS",STOP,"P")),ITEM,3)
"RTN","RORX005C",245,0)
 . . S TMP=+$G(@NODE@("OPS",STOP,"V"))
"RTN","RORX005C",246,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NV",$J(TMP,0,2),ITEM,3)
"RTN","RORX005C",247,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NSC",+$G(@NODE@("OPS",STOP,"S")),ITEM,3)
"RTN","RORX005C",248,0)
 ;--- Summary
"RTN","RORX005C",249,0)
 D ADDVAL^RORTSK11(RORTSK,"NP",+$G(@NODE@("OP")),SECTION)
"RTN","RORX005C",250,0)
 D ADDVAL^RORTSK11(RORTSK,"NV",+$G(@NODE@("OPV")),SECTION)
"RTN","RORX005C",251,0)
 D ADDVAL^RORTSK11(RORTSK,"NSC",+$G(@NODE@("OPS")),SECTION)
"RTN","RORX005C",252,0)
 Q 0
"RTN","RORX005U")
0^154^B533108
"RTN","RORX005U",1,0)
RORX005U ;HCIOFO/BH,SG - INP & OUT UTILIZATION (UTILITIES) ; 12/30/03 8:41am
"RTN","RORX005U",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX005U",3,0)
 ;
"RTN","RORX005U",4,0)
 ; This routine uses the following IAs:
"RTN","RORX005U",5,0)
 ;
"RTN","RORX005U",6,0)
 ; #92           Read access to the file #45 (controlled)
"RTN","RORX005U",7,0)
 ; #10035        Read access to the file #2 (supported)
"RTN","RORX005U",8,0)
 ;
"RTN","RORX005U",9,0)
 Q
"RTN","RORX005U",10,0)
 ;
"RTN","RORX005U",11,0)
 ;***** CALCULATES THE LENGTH OF STAY
"RTN","RORX005U",12,0)
LOS(STDT,ENDT) ;
"RTN","RORX005U",13,0)
 N DAYS
"RTN","RORX005U",14,0)
 S:STDT<RORSDT STDT=RORSDT
"RTN","RORX005U",15,0)
 S:(ENDT'>0)!(ENDT>ROREDT) ENDT=ROREDT
"RTN","RORX005U",16,0)
 S DAYS=$$FMDIFF^XLFDT(ENDT\1,STDT\1,1)
"RTN","RORX005U",17,0)
 Q $S(DAYS'<0:DAYS,1:0)
"RTN","RORX005U",18,0)
 ;
"RTN","RORX005U",19,0)
 ;***** CHECKS THE SUFFIX FOR VALIDITY
"RTN","RORX005U",20,0)
 ;
"RTN","RORX005U",21,0)
 ; SUFFIX        Suffix
"RTN","RORX005U",22,0)
 ;
"RTN","RORX005U",23,0)
 ; Return Values:
"RTN","RORX005U",24,0)
 ;        0  Ok
"RTN","RORX005U",25,0)
 ;        1  Invalid suffix
"RTN","RORX005U",26,0)
VSUFFIX(SUFFIX) ;
"RTN","RORX005U",27,0)
 Q '("9AA,9AB,9AC,9AD,9AE,9BB,A0,A4,A5,BU,BV,PA"[SUFFIX)
"RTN","RORX006")
0^155^B11208079
"RTN","RORX006",1,0)
RORX006 ;HCIOFO/BH,SG - LAB UTILIZATION ; 12/5/03 4:19pm
"RTN","RORX006",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX006",3,0)
 ;
"RTN","RORX006",4,0)
 ;--------------------------------------------------------------------
"RTN","RORX006",5,0)
 ; Registry: [VA ICR]
"RTN","RORX006",6,0)
 ;--------------------------------------------------------------------
"RTN","RORX006",7,0)
 Q
"RTN","RORX006",8,0)
 ;
"RTN","RORX006",9,0)
 ;***** OUTPUTS THE REPORT HEADER
"RTN","RORX006",10,0)
 ;
"RTN","RORX006",11,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX006",12,0)
 ;
"RTN","RORX006",13,0)
 ; Return Values:
"RTN","RORX006",14,0)
 ;       <0  Error code
"RTN","RORX006",15,0)
 ;       >0  IEN of the HEADER element
"RTN","RORX006",16,0)
 ;
"RTN","RORX006",17,0)
HEADER(PARTAG) ;
"RTN","RORX006",18,0)
 ;;LABTESTS(#,NAME,NP,NR,MAXNRPP,MAXNP)
"RTN","RORX006",19,0)
 ;;PATIENTS(#,NAME,LAST4,NO,NR,NDT)
"RTN","RORX006",20,0)
 ;;RESULTS(NP,NR)
"RTN","RORX006",21,0)
 ;
"RTN","RORX006",22,0)
 N HEADER,RC
"RTN","RORX006",23,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX006",24,0)
 Q:HEADER<0 HEADER
"RTN","RORX006",25,0)
 S RC=$$TBLDEF^RORXU002("HEADER^RORX006",HEADER)
"RTN","RORX006",26,0)
 Q $S(RC<0:RC,1:HEADER)
"RTN","RORX006",27,0)
 ;
"RTN","RORX006",28,0)
 ;
"RTN","RORX006",29,0)
 ;***** COMPILES THE "LAB UTILIZATION" REPORT
"RTN","RORX006",30,0)
 ; REPORT CODE: 006
"RTN","RORX006",31,0)
 ;
"RTN","RORX006",32,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORX006",33,0)
 ;
"RTN","RORX006",34,0)
 ; The ^TMP("RORX006",$J) global node is used by this function.
"RTN","RORX006",35,0)
 ;
"RTN","RORX006",36,0)
 ; ^TMP("RORX006",$J,
"RTN","RORX006",37,0)
 ;   CatSub,             ("HIV", "AIDS", or "ALLCATS")
"RTN","RORX006",38,0)
 ;
"RTN","RORX006",39,0)
 ;     "ORD",            Total number of orders
"RTN","RORX006",40,0)
 ;       NumOfOrd,       Number of patients
"RTN","RORX006",41,0)
 ;         PatientName,
"RTN","RORX006",42,0)
 ;           DFN)
"RTN","RORX006",43,0)
 ;
"RTN","RORX006",44,0)
 ;     "PAT",            Total number of patients
"RTN","RORX006",45,0)
 ;       DFN,            Last 4 digits of SSN
"RTN","RORX006",46,0)
 ;         "O")          Number of orders
"RTN","RORX006",47,0)
 ;         "R",          Results
"RTN","RORX006",48,0)
 ;                         ^01: Number of results
"RTN","RORX006",49,0)
 ;                         ^02: Number of different tests
"RTN","RORX006",50,0)
 ;           TestIEN)    Number of results
"RTN","RORX006",51,0)
 ;
"RTN","RORX006",52,0)
 ;     "RES",            Totals
"RTN","RORX006",53,0)
 ;                         ^01: Total number of results
"RTN","RORX006",54,0)
 ;                         ^02: Number of different tests
"RTN","RORX006",55,0)
 ;       TestIEN,
"RTN","RORX006",56,0)
 ;         "M")          Maximum
"RTN","RORX006",57,0)
 ;                         ^01: Maximum number of results
"RTN","RORX006",58,0)
 ;                         ^02: Number of patients
"RTN","RORX006",59,0)
 ;         "P")          Number of patients
"RTN","RORX006",60,0)
 ;         "R")          Number of results
"RTN","RORX006",61,0)
 ;       "B",
"RTN","RORX006",62,0)
 ;         NumOfRes,
"RTN","RORX006",63,0)
 ;           TestName,
"RTN","RORX006",64,0)
 ;             TestIEN)
"RTN","RORX006",65,0)
 ;
"RTN","RORX006",66,0)
 ;     "RES1",
"RTN","RORX006",67,0)
 ;       NumOfResults,   Number of patients
"RTN","RORX006",68,0)
 ;         PatientName,
"RTN","RORX006",69,0)
 ;           DFN)
"RTN","RORX006",70,0)
 ;
"RTN","RORX006",71,0)
 ; Return Values:
"RTN","RORX006",72,0)
 ;       <0  Error code
"RTN","RORX006",73,0)
 ;        0  Ok
"RTN","RORX006",74,0)
 ;
"RTN","RORX006",75,0)
LABUTL(RORTSK) ;
"RTN","RORX006",76,0)
 N ROREDT        ; End date
"RTN","RORX006",77,0)
 N ROREDT1       ; End date + 1 day
"RTN","RORX006",78,0)
 N RORLTST       ; List of lab tests
"RTN","RORX006",79,0)
 N RORMODE       ; Subset of patients to be selected
"RTN","RORX006",80,0)
 N RORREG        ; Registry IEN
"RTN","RORX006",81,0)
 N RORSDT        ; Start date
"RTN","RORX006",82,0)
 ;
"RTN","RORX006",83,0)
 N ECNT,RC,REPORT,SFLAGS,TMP
"RTN","RORX006",84,0)
 ;--- Root node of the report
"RTN","RORX006",85,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX006",86,0)
 Q:REPORT<0 REPORT
"RTN","RORX006",87,0)
 ;
"RTN","RORX006",88,0)
 ;--- Get and prepare the report parameters
"RTN","RORX006",89,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")
"RTN","RORX006",90,0)
 S RC=$$PARAMS(REPORT,.RORSDT,.ROREDT,.SFLAGS)  Q:RC<0 RC
"RTN","RORX006",91,0)
 S RORMODE=$$PARAM^RORTSK01("PATIENTS")
"RTN","RORX006",92,0)
 D LIST^RORXU002(.RORMODE)
"RTN","RORX006",93,0)
 ;
"RTN","RORX006",94,0)
 ;--- Initialize constants and variables
"RTN","RORX006",95,0)
 S ROREDT1=$$FMADD^XLFDT(ROREDT\1,1),ECNT=0
"RTN","RORX006",96,0)
 K ^TMP("RORX006",$J)
"RTN","RORX006",97,0)
 ;
"RTN","RORX006",98,0)
 ;--- Report header
"RTN","RORX006",99,0)
 S RC=$$HEADER(REPORT)  Q:RC<0 RC
"RTN","RORX006",100,0)
 ;
"RTN","RORX006",101,0)
 D
"RTN","RORX006",102,0)
 . ;--- Query the registry
"RTN","RORX006",103,0)
 . D TPPSETUP^RORTSK01(70)
"RTN","RORX006",104,0)
 . S RC=$$QUERY^RORX006A(SFLAGS_"DI")
"RTN","RORX006",105,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX006",106,0)
 . ;--- Sort the data
"RTN","RORX006",107,0)
 . D TPPSETUP^RORTSK01(15)
"RTN","RORX006",108,0)
 . S RC=$$SORT^RORX006A()
"RTN","RORX006",109,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX006",110,0)
 . ;--- Store the results
"RTN","RORX006",111,0)
 . D TPPSETUP^RORTSK01(15)
"RTN","RORX006",112,0)
 . S RC=$$STORE^RORX006C(REPORT)
"RTN","RORX006",113,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX006",114,0)
 ;
"RTN","RORX006",115,0)
 ;--- Cleanup
"RTN","RORX006",116,0)
 K ^TMP("RORX006",$J)
"RTN","RORX006",117,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX006",118,0)
 ;
"RTN","RORX006",119,0)
 ;***** OUTPUTS THE PARAMETERS TO THE REPORT
"RTN","RORX006",120,0)
 ;
"RTN","RORX006",121,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX006",122,0)
 ;
"RTN","RORX006",123,0)
 ; [.STDT]       Start and end dates of the report
"RTN","RORX006",124,0)
 ; [.ENDT]       are returned via these parameters
"RTN","RORX006",125,0)
 ;
"RTN","RORX006",126,0)
 ; [.FLAGS]      Flags for the $$SKIP^RORXU005 are
"RTN","RORX006",127,0)
 ;               returned via this parameter
"RTN","RORX006",128,0)
 ;
"RTN","RORX006",129,0)
 ; Return Values:
"RTN","RORX006",130,0)
 ;       <0  Error code
"RTN","RORX006",131,0)
 ;       >0  IEN of the PARAMETERS element
"RTN","RORX006",132,0)
 ;
"RTN","RORX006",133,0)
PARAMS(PARTAG,STDT,ENDT,FLAGS) ;
"RTN","RORX006",134,0)
 N PARAMS,TMP
"RTN","RORX006",135,0)
 S PARAMS=$$PARAMS^RORXU002(.RORTSK,PARTAG,.STDT,.ENDT,.FLAGS)
"RTN","RORX006",136,0)
 Q:PARAMS<0 PARAMS
"RTN","RORX006",137,0)
 ;--- Additional parameters
"RTN","RORX006",138,0)
 F NAME="MAXUTNUM","MINRPNUM"  D
"RTN","RORX006",139,0)
 . S TMP=$$PARAM^RORTSK01(NAME)
"RTN","RORX006",140,0)
 . D:TMP'="" ADDVAL^RORTSK11(RORTSK,NAME,TMP,PARAMS)
"RTN","RORX006",141,0)
 ;--- Process the list of Lab tests
"RTN","RORX006",142,0)
 S TMP=$$LTLST^RORXU006(.RORTSK,PARAMS,"RORLTST")  Q:TMP<0 TMP
"RTN","RORX006",143,0)
 ;---
"RTN","RORX006",144,0)
 Q PARAMS
"RTN","RORX006A")
0^157^B34713272
"RTN","RORX006A",1,0)
RORX006A ;HCIOFO/BH,SG - LAB UTILIZATION (QUERY & SORT) ; 12/5/03 4:08pm
"RTN","RORX006A",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX006A",3,0)
 ;
"RTN","RORX006A",4,0)
 Q
"RTN","RORX006A",5,0)
 ;
"RTN","RORX006A",6,0)
 ;***** LOADS AND PROCESSES THE LAB DATA
"RTN","RORX006A",7,0)
 ;
"RTN","RORX006A",8,0)
 ; DFN           Patient IEN (in file #2)
"RTN","RORX006A",9,0)
 ; CATSUB        Category subscript in the temporary global
"RTN","RORX006A",10,0)
 ;
"RTN","RORX006A",11,0)
 ; Return Values:
"RTN","RORX006A",12,0)
 ;       <0  Error code
"RTN","RORX006A",13,0)
 ;        0  Ok
"RTN","RORX006A",14,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX006A",15,0)
 ;
"RTN","RORX006A",16,0)
LABDATA(DFN,CATSUB) ;
"RTN","RORX006A",17,0)
 N DST,ENDT,NR,PTNO,PTNR,PRNT,RC,TSTIEN
"RTN","RORX006A",18,0)
 S DST=$NA(^TMP("RORX006",$J,CATSUB))
"RTN","RORX006A",19,0)
 ;
"RTN","RORX006A",20,0)
 ;--- Get the data
"RTN","RORX006A",21,0)
 S DST("RORCB")="$$LTSCB^RORX006A",DST("RORIDT")=""
"RTN","RORX006A",22,0)
 S RC=$$LTSEARCH^RORUTL10(DFN,RORLTP,.DST,,RORSDT,ROREDT1)
"RTN","RORX006A",23,0)
 Q:RC<0 RC  Q:$D(@DST@("PAT",DFN))<10 0
"RTN","RORX006A",24,0)
 ;
"RTN","RORX006A",25,0)
 ;--- Calculate intermediate totals of the tests
"RTN","RORX006A",26,0)
 S TSTIEN=0,(PTNR,PTNT)=0
"RTN","RORX006A",27,0)
 F  S TSTIEN=$O(@DST@("PAT",DFN,"R",TSTIEN))  Q:TSTIEN'>0  D
"RTN","RORX006A",28,0)
 . S NR=+$G(@DST@("PAT",DFN,"R",TSTIEN))
"RTN","RORX006A",29,0)
 . S PTNR=PTNR+NR  ; Number of patient's results
"RTN","RORX006A",30,0)
 . S PTNT=PTNT+1   ; Number of different tests
"RTN","RORX006A",31,0)
 . ;---
"RTN","RORX006A",32,0)
 . S @DST@("RES",TSTIEN,"P")=$G(@DST@("RES",TSTIEN,"P"))+1
"RTN","RORX006A",33,0)
 . S @DST@("RES",TSTIEN,"R")=$G(@DST@("RES",TSTIEN,"R"))+NR
"RTN","RORX006A",34,0)
 . ;---
"RTN","RORX006A",35,0)
 . S TMP=$G(@DST@("RES",TSTIEN,"M"))
"RTN","RORX006A",36,0)
 . D:NR'<TMP
"RTN","RORX006A",37,0)
 . . I NR>TMP  S @DST@("RES",TSTIEN,"M")=NR_U_1  Q
"RTN","RORX006A",38,0)
 . . S $P(@DST@("RES",TSTIEN,"M"),U,2)=$P(TMP,U,2)+1
"RTN","RORX006A",39,0)
 ;
"RTN","RORX006A",40,0)
 ;--- Orders
"RTN","RORX006A",41,0)
 S @DST@("ORD")=$G(@DST@("ORD"))+$G(@DST@("PAT",DFN,"O"))
"RTN","RORX006A",42,0)
 ;
"RTN","RORX006A",43,0)
 ;--- Results
"RTN","RORX006A",44,0)
 S @DST@("RES1",PTNR)=$G(@DST@("RES1",PTNR))+1
"RTN","RORX006A",45,0)
 S @DST@("RES1",PTNR,RORPNAME,DFN)=""
"RTN","RORX006A",46,0)
 ;
"RTN","RORX006A",47,0)
 ;--- Other totals
"RTN","RORX006A",48,0)
 S @DST@("PAT",DFN)=RORLAST4
"RTN","RORX006A",49,0)
 S @DST@("PAT",DFN,"R")=PTNR_U_PTNT
"RTN","RORX006A",50,0)
 S @DST@("PAT")=$G(@DST@("PAT"))+1
"RTN","RORX006A",51,0)
 S @DST@("RES")=$G(@DST@("RES"))+PTNR
"RTN","RORX006A",52,0)
 Q 0
"RTN","RORX006A",53,0)
 ;
"RTN","RORX006A",54,0)
 ;***** LAB SEARCH CALLBACK
"RTN","RORX006A",55,0)
 ;
"RTN","RORX006A",56,0)
 ; .ROR8DST      Reference to the ROR8DST parameter.
"RTN","RORX006A",57,0)
 ;
"RTN","RORX006A",58,0)
 ; INVDT         IEN of the Lab test (inverted date)
"RTN","RORX006A",59,0)
 ;
"RTN","RORX006A",60,0)
 ; .RESULT       Reference to a local variable, which contains
"RTN","RORX006A",61,0)
 ;               the result (see the $$LTSEARCH^RORUTL10).
"RTN","RORX006A",62,0)
 ;
"RTN","RORX006A",63,0)
 ; Return Values:
"RTN","RORX006A",64,0)
 ;       <0  Error code (the search will be aborted)
"RTN","RORX006A",65,0)
 ;        0  Ok
"RTN","RORX006A",66,0)
 ;        1  Skip this result
"RTN","RORX006A",67,0)
 ;        2  Skip this and all remaining results
"RTN","RORX006A",68,0)
 ;
"RTN","RORX006A",69,0)
LTSCB(ROR8DST,INVDT,RESULT) ;
"RTN","RORX006A",70,0)
 N DFN,TMP,TSTIEN
"RTN","RORX006A",71,0)
 S DFN=+ROR8DST("RORDFN"),TSTIEN=+RESULT(2)
"RTN","RORX006A",72,0)
 ;--- Number of orders
"RTN","RORX006A",73,0)
 I INVDT'=ROR8DST("RORIDT")  D  S ROR8DST("RORIDT")=INVDT
"RTN","RORX006A",74,0)
 . S @ROR8DST@("PAT",DFN,"O")=$G(@ROR8DST@("PAT",DFN,"O"))+1
"RTN","RORX006A",75,0)
 ;--- Number of results
"RTN","RORX006A",76,0)
 S TMP=$G(@ROR8DST@("PAT",DFN,"R",TSTIEN))
"RTN","RORX006A",77,0)
 S @ROR8DST@("PAT",DFN,"R",TSTIEN)=TMP+1
"RTN","RORX006A",78,0)
 Q 0
"RTN","RORX006A",79,0)
 ;
"RTN","RORX006A",80,0)
 ;***** QUERIES THE REGISTRY
"RTN","RORX006A",81,0)
 ;
"RTN","RORX006A",82,0)
 ; FLAGS         Flags for the $$SKIP^RORXU005
"RTN","RORX006A",83,0)
 ;
"RTN","RORX006A",84,0)
 ; Return Values:
"RTN","RORX006A",85,0)
 ;       <0  Error code
"RTN","RORX006A",86,0)
 ;        0  Ok
"RTN","RORX006A",87,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX006A",88,0)
 ;
"RTN","RORX006A",89,0)
QUERY(FLAGS) ;
"RTN","RORX006A",90,0)
 N RORLAST4      ; Last 4 digits of the current patient's SSN
"RTN","RORX006A",91,0)
 N RORLTP        ; Reference to the list of Lab tests
"RTN","RORX006A",92,0)
 N RORPNAME      ; Name of the current patient
"RTN","RORX006A",93,0)
 N RORPTN        ; Number of patients in the registry
"RTN","RORX006A",94,0)
 ;
"RTN","RORX006A",95,0)
 N CATSUB,CNT,ECNT,IEN,IENS,PATIEN,RC,TMP,VA,VADM,XREFNODE
"RTN","RORX006A",96,0)
 S XREFNODE=$NA(^RORDATA(798,"AC",+RORREG))
"RTN","RORX006A",97,0)
 S RORPTN=$$REGSIZE^RORUTL02(+RORREG)  S:RORPTN<0 RORPTN=0
"RTN","RORX006A",98,0)
 S RORLTP=$S($D(RORLTST("ALL")):"*",1:"RORLTST")
"RTN","RORX006A",99,0)
 S (CNT,ECNT,RC)=0
"RTN","RORX006A",100,0)
 ;
"RTN","RORX006A",101,0)
 ;--- Browse through the registry records
"RTN","RORX006A",102,0)
 S IEN=0
"RTN","RORX006A",103,0)
 F  S IEN=$O(@XREFNODE@(IEN))  Q:IEN'>0  D  Q:RC<0
"RTN","RORX006A",104,0)
 . S TMP=$S(RORPTN>0:CNT/RORPTN,1:"")
"RTN","RORX006A",105,0)
 . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX006A",106,0)
 . S IENS=IEN_",",CNT=CNT+1
"RTN","RORX006A",107,0)
 . ;--- Check if the patient should be skipped
"RTN","RORX006A",108,0)
 . Q:$$SKIP^RORXU005(IEN,FLAGS,RORSDT,ROREDT)
"RTN","RORX006A",109,0)
 . ;
"RTN","RORX006A",110,0)
 . ;--- Get the patient IEN (DFN)
"RTN","RORX006A",111,0)
 . S PATIEN=$$PTIEN^RORUTL01(IEN)  Q:PATIEN'>0
"RTN","RORX006A",112,0)
 . ;
"RTN","RORX006A",113,0)
 . ;--- Get the category subscript
"RTN","RORX006A",114,0)
 . S TMP=$$CLINAIDS^RORICRUT(IEN,ROREDT)
"RTN","RORX006A",115,0)
 . S CATSUB=$S(TMP:"AIDS",1:"HIV")
"RTN","RORX006A",116,0)
 . Q:'$D(RORMODE(CATSUB))
"RTN","RORX006A",117,0)
 . ;
"RTN","RORX006A",118,0)
 . ;--- Get the patient's data
"RTN","RORX006A",119,0)
 . D VADEM^RORUTL05(PATIEN,1)
"RTN","RORX006A",120,0)
 . S RORPNAME=VADM(1),RORLAST4=VA("BID")
"RTN","RORX006A",121,0)
 . ;
"RTN","RORX006A",122,0)
 . ;--- Get the Lab data
"RTN","RORX006A",123,0)
 . S RC=$$LABDATA(PATIEN,CATSUB)
"RTN","RORX006A",124,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX006A",125,0)
 ;---
"RTN","RORX006A",126,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX006A",127,0)
 ;
"RTN","RORX006A",128,0)
 ;***** SORTS THE RESULTS AND COMPILES THE TOTALS
"RTN","RORX006A",129,0)
 ;
"RTN","RORX006A",130,0)
 ; Return Values:
"RTN","RORX006A",131,0)
 ;       <0  Error code
"RTN","RORX006A",132,0)
 ;        0  Ok
"RTN","RORX006A",133,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX006A",134,0)
 ;
"RTN","RORX006A",135,0)
SORT() ;
"RTN","RORX006A",136,0)
 N CATSUB,ECNT,FSUM,NODE,NR,NSUB,RC,RORI,RORMSG,RORSUM,TMP
"RTN","RORX006A",137,0)
 S (ECNT,RC)=0
"RTN","RORX006A",138,0)
 S RORSUM=$NA(^TMP("RORX006",$J,$P($$CAT^RORICRUT(1),U)))
"RTN","RORX006A",139,0)
 S NSUB=$$NCAT^RORICRUT
"RTN","RORX006A",140,0)
 ;---
"RTN","RORX006A",141,0)
 F RORI=NSUB:-1:1  D  Q:RC<0
"RTN","RORX006A",142,0)
 . S RC=$$LOOP^RORTSK01((NSUB-RORI)/NSUB)  Q:RC<0
"RTN","RORX006A",143,0)
 . S CATSUB=$P($$CAT^RORICRUT(RORI),U)
"RTN","RORX006A",144,0)
 . S NODE=$NA(^TMP("RORX006",$J,CATSUB))
"RTN","RORX006A",145,0)
 . Q:$D(@NODE)<10
"RTN","RORX006A",146,0)
 . S FSUM=$D(RORMODE("AIDS"))&$D(RORMODE("HIV"))&(RORI'=1)
"RTN","RORX006A",147,0)
 . ;---
"RTN","RORX006A",148,0)
 . D SORTRES(NODE,FSUM)
"RTN","RORX006A",149,0)
 . ;---
"RTN","RORX006A",150,0)
 . Q:'FSUM
"RTN","RORX006A",151,0)
 . ;--- Patients
"RTN","RORX006A",152,0)
 . S TMP=$G(@RORSUM@("PAT"))
"RTN","RORX006A",153,0)
 . M @RORSUM@("PAT")=@NODE@("PAT")
"RTN","RORX006A",154,0)
 . S @RORSUM@("PAT")=TMP+$G(@NODE@("PAT"))
"RTN","RORX006A",155,0)
 . ;--- Orders
"RTN","RORX006A",156,0)
 . S @RORSUM@("ORD")=$G(@RORSUM@("ORD"))+$G(@NODE@("ORD"))
"RTN","RORX006A",157,0)
 . ;--- Results
"RTN","RORX006A",158,0)
 . S NR=0
"RTN","RORX006A",159,0)
 . F  S NR=$O(@NODE@("RES1",NR))  Q:NR'>0  D
"RTN","RORX006A",160,0)
 . . S TMP=$G(@RORSUM@("RES1",NR))
"RTN","RORX006A",161,0)
 . . M @RORSUM@("RES1",NR)=@NODE@("RES1",NR)
"RTN","RORX006A",162,0)
 . . S @RORSUM@("RES1",NR)=TMP+$G(@NODE@("RES1",NR))
"RTN","RORX006A",163,0)
 Q 0
"RTN","RORX006A",164,0)
 ;
"RTN","RORX006A",165,0)
 ;***** SORTS THE RESULT DATA
"RTN","RORX006A",166,0)
 ;
"RTN","RORX006A",167,0)
 ; NODE          Closed root of the category section
"RTN","RORX006A",168,0)
 ;               in the temporary global
"RTN","RORX006A",169,0)
 ;
"RTN","RORX006A",170,0)
 ; FSUM          Update the summary data (0/1)
"RTN","RORX006A",171,0)
 ;
"RTN","RORX006A",172,0)
SORTRES(NODE,FSUM) ;
"RTN","RORX006A",173,0)
 N I,IEN,NAME,NDLT,SUM,TMP
"RTN","RORX006A",174,0)
 S IEN=0,NDLT=0
"RTN","RORX006A",175,0)
 F  S IEN=$O(@NODE@("RES",IEN))  Q:IEN'>0  D
"RTN","RORX006A",176,0)
 . S NDLT=NDLT+1
"RTN","RORX006A",177,0)
 . S NAME=$$GET1^DIQ(60,IEN,.01,,,"RORMSG")
"RTN","RORX006A",178,0)
 . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,60,IEN)
"RTN","RORX006A",179,0)
 . S:NAME?." " NAME="Unknown ("_IEN_")"
"RTN","RORX006A",180,0)
 . S TMP=+$G(@NODE@("RES",IEN,"R"))
"RTN","RORX006A",181,0)
 . S @NODE@("RES","B",TMP,NAME,IEN)=""
"RTN","RORX006A",182,0)
 . Q:'FSUM
"RTN","RORX006A",183,0)
 . ;--- Numbers of patients and results
"RTN","RORX006A",184,0)
 . F I="P","R"  S TMP=$G(@NODE@("RES",IEN,I))  D:TMP>0
"RTN","RORX006A",185,0)
 . . S @RORSUM@("RES",IEN,I)=$G(@RORSUM@("RES",IEN,I))+TMP
"RTN","RORX006A",186,0)
 . ;--- Maximum number of results per patient
"RTN","RORX006A",187,0)
 . S TMP=$G(@NODE@("RES",IEN,"M"))
"RTN","RORX006A",188,0)
 . S SUM=$G(@RORSUM@("RES",IEN,"M"))
"RTN","RORX006A",189,0)
 . D:TMP'<SUM
"RTN","RORX006A",190,0)
 . . I TMP>SUM  S @RORSUM@("RES",IEN,"M")=TMP  Q
"RTN","RORX006A",191,0)
 . . S $P(@RORSUM@("RES",IEN,"M"),U,2)=$P(SUM,U,2)+$P(TMP,U,2)
"RTN","RORX006A",192,0)
 ;--- Total numbers of Lab tests
"RTN","RORX006A",193,0)
 S:FSUM @RORSUM@("RES")=$G(@RORSUM@("RES"))+$G(@NODE@("RES"))
"RTN","RORX006A",194,0)
 S $P(@NODE@("RES"),U,2)=NDLT
"RTN","RORX006A",195,0)
 Q
"RTN","RORX006C")
0^158^B22092254
"RTN","RORX006C",1,0)
RORX006C ;HCIOFO/BH,SG - LAB UTILIZATION (STORE) ; 12/9/03 10:41am
"RTN","RORX006C",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX006C",3,0)
 ;
"RTN","RORX006C",4,0)
 Q
"RTN","RORX006C",5,0)
 ;
"RTN","RORX006C",6,0)
 ;***** PATIENTS WITH HIGHEST UTILIZATION
"RTN","RORX006C",7,0)
 ;
"RTN","RORX006C",8,0)
 ; CATEGORY      IEN of the CATEGORY element
"RTN","RORX006C",9,0)
 ;
"RTN","RORX006C",10,0)
 ; NODE          Closed root of the category section
"RTN","RORX006C",11,0)
 ;               in the temporary global
"RTN","RORX006C",12,0)
 ;
"RTN","RORX006C",13,0)
 ; Return Values:
"RTN","RORX006C",14,0)
 ;       <0  Error code
"RTN","RORX006C",15,0)
 ;        0  Ok
"RTN","RORX006C",16,0)
 ;
"RTN","RORX006C",17,0)
PATIENTS(CATEGORY,NODE) ;
"RTN","RORX006C",18,0)
 Q:$D(@NODE@("PAT"))<10 0
"RTN","RORX006C",19,0)
 N BUF,COUNT,DFN,ITEM,MAXUTNUM,NAME,NUM,RC,TMP
"RTN","RORX006C",20,0)
 S MAXUTNUM=$$PARAM^RORTSK01("MAXUTNUM")
"RTN","RORX006C",21,0)
 Q:MAXUTNUM'>0 0
"RTN","RORX006C",22,0)
 S TABLE=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,CATEGORY)
"RTN","RORX006C",23,0)
 Q:TABLE<0 TABLE
"RTN","RORX006C",24,0)
 D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","PATIENTS")
"RTN","RORX006C",25,0)
 ;---
"RTN","RORX006C",26,0)
 S NUM="",(COUNT,RC)=0
"RTN","RORX006C",27,0)
 F  S NUM=$O(@NODE@("RES1",NUM),-1)  Q:NUM=""  D  Q:RC
"RTN","RORX006C",28,0)
 . S NAME=""
"RTN","RORX006C",29,0)
 . F  S NAME=$O(@NODE@("RES1",NUM,NAME))  Q:NAME=""  D  Q:RC
"RTN","RORX006C",30,0)
 . . S DFN=""
"RTN","RORX006C",31,0)
 . . F  S DFN=$O(@NODE@("RES1",NUM,NAME,DFN))  Q:DFN=""  D  Q:RC
"RTN","RORX006C",32,0)
 . . . S COUNT=COUNT+1  I COUNT>MAXUTNUM  S RC=1  Q
"RTN","RORX006C",33,0)
 . . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,TABLE)
"RTN","RORX006C",34,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NAME",NAME,ITEM,1)
"RTN","RORX006C",35,0)
 . . . S TMP=$P($G(@NODE@("PAT",DFN)),U)
"RTN","RORX006C",36,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"LAST4",TMP,ITEM,2)
"RTN","RORX006C",37,0)
 . . . S TMP=+$G(@NODE@("PAT",DFN,"O"))
"RTN","RORX006C",38,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NO",TMP,ITEM,3)
"RTN","RORX006C",39,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NR",NUM,ITEM,3)
"RTN","RORX006C",40,0)
 . . . S TMP=+$P($G(@NODE@("PAT",DFN,"R")),U,2)
"RTN","RORX006C",41,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NDT",TMP,ITEM,3)
"RTN","RORX006C",42,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORX006C",43,0)
 ;
"RTN","RORX006C",44,0)
 ;***** NUMBERS OF PATIENTS AND RESULTS
"RTN","RORX006C",45,0)
 ;
"RTN","RORX006C",46,0)
 ; CATEGORY      IEN of the CATEGORY element
"RTN","RORX006C",47,0)
 ;
"RTN","RORX006C",48,0)
 ; NODE          Closed root of the category section
"RTN","RORX006C",49,0)
 ;               in the temporary global
"RTN","RORX006C",50,0)
 ;
"RTN","RORX006C",51,0)
 ; Return Values:
"RTN","RORX006C",52,0)
 ;       <0  Error code
"RTN","RORX006C",53,0)
 ;        0  Ok
"RTN","RORX006C",54,0)
 ;
"RTN","RORX006C",55,0)
RESULTS(CATEGORY,NODE) ;
"RTN","RORX006C",56,0)
 Q:$D(@NODE@("RES1"))<10 0
"RTN","RORX006C",57,0)
 N ITEM,NUM,RC,TABLE
"RTN","RORX006C",58,0)
 S TABLE=$$ADDVAL^RORTSK11(RORTSK,"RESULTS",,CATEGORY)
"RTN","RORX006C",59,0)
 Q:TABLE<0 TABLE
"RTN","RORX006C",60,0)
 D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","RESULTS")
"RTN","RORX006C",61,0)
 S NUM="",RC=0
"RTN","RORX006C",62,0)
 F  S NUM=$O(@NODE@("RES1",NUM),-1)  Q:NUM=""  D  Q:RC
"RTN","RORX006C",63,0)
 . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"ITEM",,TABLE)
"RTN","RORX006C",64,0)
 . S TMP=+$G(@NODE@("RES1",NUM))
"RTN","RORX006C",65,0)
 . D ADDVAL^RORTSK11(RORTSK,"NP",TMP,ITEM,3)
"RTN","RORX006C",66,0)
 . D ADDVAL^RORTSK11(RORTSK,"NR",NUM,ITEM,3)
"RTN","RORX006C",67,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORX006C",68,0)
 ;
"RTN","RORX006C",69,0)
 ;***** STORES THE REPORT DATA
"RTN","RORX006C",70,0)
 ;
"RTN","RORX006C",71,0)
 ; REPORT        IEN of the REPORT element
"RTN","RORX006C",72,0)
 ;
"RTN","RORX006C",73,0)
 ; Return Values:
"RTN","RORX006C",74,0)
 ;       <0  Error code
"RTN","RORX006C",75,0)
 ;        0  Ok
"RTN","RORX006C",76,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX006C",77,0)
 ;
"RTN","RORX006C",78,0)
STORE(REPORT) ;
"RTN","RORX006C",79,0)
 N RORSONLY      ; Output summary only
"RTN","RORX006C",80,0)
 ;
"RTN","RORX006C",81,0)
 N CATEGORY,CATHDR,CATSUB,ECNT,NODE,NSUB,RC,RORI,SUBLST,TMP
"RTN","RORX006C",82,0)
 S RORSONLY=$$SMRYONLY^RORXU006()
"RTN","RORX006C",83,0)
 S NSUB=$$NCAT^RORICRUT
"RTN","RORX006C",84,0)
 S (ECNT,RC)=0
"RTN","RORX006C",85,0)
 ;---
"RTN","RORX006C",86,0)
 F RORI=NSUB:-1:1  D  Q:RC<0
"RTN","RORX006C",87,0)
 . S RC=$$LOOP^RORTSK01((NSUB-RORI)/3)  Q:RC<0
"RTN","RORX006C",88,0)
 . S TMP=$$CAT^RORICRUT(RORI),CATSUB=$P(TMP,U),CATHDR=$P(TMP,U,2)
"RTN","RORX006C",89,0)
 . S NODE=$NA(^TMP("RORX006",$J,CATSUB))
"RTN","RORX006C",90,0)
 . Q:$D(@NODE)<10
"RTN","RORX006C",91,0)
 . ;--- Category
"RTN","RORX006C",92,0)
 . S CATEGORY=$$ADDVAL^RORTSK11(RORTSK,"CATEGORY",,REPORT)
"RTN","RORX006C",93,0)
 . D ADDVAL^RORTSK11(RORTSK,"NAME",CATHDR,CATEGORY)
"RTN","RORX006C",94,0)
 . ;--- Tables
"RTN","RORX006C",95,0)
 . S RC=$$RESULTS(CATEGORY,NODE)
"RTN","RORX006C",96,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX006C",97,0)
 . S RC=$$TESTS(CATEGORY,NODE)
"RTN","RORX006C",98,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX006C",99,0)
 . S RC=$$PATIENTS(CATEGORY,NODE)
"RTN","RORX006C",100,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX006C",101,0)
 . ;--- Summary
"RTN","RORX006C",102,0)
 . D ADDVAL^RORTSK11(RORTSK,"NO",+$G(@NODE@("ORD")),CATEGORY)
"RTN","RORX006C",103,0)
 . S TMP=$G(@NODE@("RES"))
"RTN","RORX006C",104,0)
 . D ADDVAL^RORTSK11(RORTSK,"NR",+$P(TMP,U),CATEGORY)
"RTN","RORX006C",105,0)
 . D ADDVAL^RORTSK11(RORTSK,"NDT",+$P(TMP,U,2),CATEGORY)
"RTN","RORX006C",106,0)
 . D ADDVAL^RORTSK11(RORTSK,"NP",+$G(@NODE@("PAT")),CATEGORY)
"RTN","RORX006C",107,0)
 ;---
"RTN","RORX006C",108,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX006C",109,0)
 ;
"RTN","RORX006C",110,0)
 ;***** LAB TESTS
"RTN","RORX006C",111,0)
 ;
"RTN","RORX006C",112,0)
 ; CATEGORY      IEN of the CATEGORY element
"RTN","RORX006C",113,0)
 ;
"RTN","RORX006C",114,0)
 ; NODE          Closed root of the category section
"RTN","RORX006C",115,0)
 ;               in the temporary global
"RTN","RORX006C",116,0)
 ;
"RTN","RORX006C",117,0)
 ; Return Values:
"RTN","RORX006C",118,0)
 ;       <0  Error code
"RTN","RORX006C",119,0)
 ;        0  Ok
"RTN","RORX006C",120,0)
 ;
"RTN","RORX006C",121,0)
TESTS(CATEGORY,NODE) ;
"RTN","RORX006C",122,0)
 Q:$D(@NODE@("RES"))<10 0
"RTN","RORX006C",123,0)
 N IEN,ITEM,MINRPNUM,NAME,NUM,RC,TMP
"RTN","RORX006C",124,0)
 S MINRPNUM=$$PARAM^RORTSK01("MINRPNUM")
"RTN","RORX006C",125,0)
 Q:MINRPNUM'>0 0
"RTN","RORX006C",126,0)
 S TABLE=$$ADDVAL^RORTSK11(RORTSK,"LABTESTS",,CATEGORY)
"RTN","RORX006C",127,0)
 Q:TABLE<0 TABLE
"RTN","RORX006C",128,0)
 D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","LABTESTS")
"RTN","RORX006C",129,0)
 ;---
"RTN","RORX006C",130,0)
 S NUM="",RC=0
"RTN","RORX006C",131,0)
 F  S NUM=$O(@NODE@("RES","B",NUM),-1)  Q:NUM<MINRPNUM  D  Q:RC
"RTN","RORX006C",132,0)
 . S NAME=""
"RTN","RORX006C",133,0)
 . F  S NAME=$O(@NODE@("RES","B",NUM,NAME))  Q:NAME=""  D  Q:RC
"RTN","RORX006C",134,0)
 . . S IEN=""
"RTN","RORX006C",135,0)
 . . F  S IEN=$O(@NODE@("RES","B",NUM,NAME,IEN))  Q:IEN=""  D  Q:RC
"RTN","RORX006C",136,0)
 . . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"LT",,TABLE)
"RTN","RORX006C",137,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NAME",NAME,ITEM,1)
"RTN","RORX006C",138,0)
 . . . S TMP=+$G(@NODE@("RES",IEN,"P"))
"RTN","RORX006C",139,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NP",TMP,ITEM,3)
"RTN","RORX006C",140,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NR",NUM,ITEM,3)
"RTN","RORX006C",141,0)
 . . . S TMP=$G(@NODE@("RES",IEN,"M"))
"RTN","RORX006C",142,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"MAXNRPP",+$P(TMP,U),ITEM,3)
"RTN","RORX006C",143,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"MAXNP",+$P(TMP,U,2),ITEM,3)
"RTN","RORX006C",144,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORX007")
0^145^B61153947
"RTN","RORX007",1,0)
RORX007 ;HCIOFO/BH,SG - RADIOLOGY UTILIZATION ; 12/10/03 10:53am
"RTN","RORX007",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX007",3,0)
 ;
"RTN","RORX007",4,0)
 ; This routine uses the following IAs:
"RTN","RORX007",5,0)
 ;
"RTN","RORX007",6,0)
 ; #10061        DEM^VADPT (supported)
"RTN","RORX007",7,0)
 ; #2043         EN1^RAO7PC1 (supported)
"RTN","RORX007",8,0)
 ;
"RTN","RORX007",9,0)
 ;--------------------------------------------------------------------
"RTN","RORX007",10,0)
 ; Registry: [VA ICR]
"RTN","RORX007",11,0)
 ;--------------------------------------------------------------------
"RTN","RORX007",12,0)
 Q
"RTN","RORX007",13,0)
 ;
"RTN","RORX007",14,0)
 ;***** COMPILES THE "RADIOLOGY UTILIZATION" REPORT
"RTN","RORX007",15,0)
 ; REPORT CODE: 007
"RTN","RORX007",16,0)
 ;
"RTN","RORX007",17,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORX007",18,0)
 ;
"RTN","RORX007",19,0)
 ; The ^TMP("RORX007",$J) and ^TMP($J,"RAE1") global nodes are
"RTN","RORX007",20,0)
 ; used by this function.
"RTN","RORX007",21,0)
 ;
"RTN","RORX007",22,0)
 ; ^TMP("RORX007",$J,
"RTN","RORX007",23,0)
 ;   CatSub,             ("HIV", "AIDS", or "ALLCATS")
"RTN","RORX007",24,0)
 ;
"RTN","RORX007",25,0)
 ;     "PAT",
"RTN","RORX007",26,0)
 ;       DFN,
"RTN","RORX007",27,0)
 ;         ProcName)     Number of procedures
"RTN","RORX007",28,0)
 ;
"RTN","RORX007",29,0)
 ;     "PATSORT",
"RTN","RORX007",30,0)
 ;       ProcQnty,
"RTN","RORX007",31,0)
 ;         Name,
"RTN","RORX007",32,0)
 ;           Last4)      Number of different procedures
"RTN","RORX007",33,0)
 ;
"RTN","RORX007",34,0)
 ;     "PROC",
"RTN","RORX007",35,0)
 ;       ProcName,
"RTN","RORX007",36,0)
 ;         DFN)          Number of procedures
"RTN","RORX007",37,0)
 ;
"RTN","RORX007",38,0)
 ;     "PROCSORT",
"RTN","RORX007",39,0)
 ;       ProcQnty,
"RTN","RORX007",40,0)
 ;         ProcName,
"RTN","RORX007",41,0)
 ;           CPT)        Number of individual patients
"RTN","RORX007",42,0)
 ;
"RTN","RORX007",43,0)
 ;     "TOTAL")          Category Totals
"RTN","RORX007",44,0)
 ;                         ^01: Total number of procedures
"RTN","RORX007",45,0)
 ;                         ^02: Number of different procedures
"RTN","RORX007",46,0)
 ;                         ^03: Total number of patients
"RTN","RORX007",47,0)
 ;                         ^04: Number of individual patients
"RTN","RORX007",48,0)
 ;
"RTN","RORX007",49,0)
 ; Return Values:
"RTN","RORX007",50,0)
 ;       <0  Error code
"RTN","RORX007",51,0)
 ;        0  Ok
"RTN","RORX007",52,0)
 ;
"RTN","RORX007",53,0)
RADUTL(RORTSK) ;
"RTN","RORX007",54,0)
 N ROREDT        ; End date
"RTN","RORX007",55,0)
 N RORMODE       ; Subset of patients to be selected
"RTN","RORX007",56,0)
 N ROROPT        ; Report options
"RTN","RORX007",57,0)
 N RORREG        ; Registry IEN
"RTN","RORX007",58,0)
 N RORSDT        ; Start date
"RTN","RORX007",59,0)
 ;
"RTN","RORX007",60,0)
 N CNT,ECNT,RC,REPORT,RORPTN,SFLAGS,TMP
"RTN","RORX007",61,0)
 ;--- Root node of the report
"RTN","RORX007",62,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX007",63,0)
 Q:REPORT<0 REPORT
"RTN","RORX007",64,0)
 ;
"RTN","RORX007",65,0)
 ;--- Get and prepare the report parameters
"RTN","RORX007",66,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")
"RTN","RORX007",67,0)
 S RC=$$PARAMS^RORX007A(REPORT,.RORSDT,.ROREDT,.SFLAGS)
"RTN","RORX007",68,0)
 Q:RC<0 RC
"RTN","RORX007",69,0)
 S RORMODE=$$PARAM^RORTSK01("PATIENTS")
"RTN","RORX007",70,0)
 D LIST^RORXU002(.RORMODE)
"RTN","RORX007",71,0)
 S ROROPT=$$PARAM^RORTSK01("OPTIONS")
"RTN","RORX007",72,0)
 D LIST^RORXU002(.ROROPT)
"RTN","RORX007",73,0)
 ;
"RTN","RORX007",74,0)
 ;--- Initialize constants and variables
"RTN","RORX007",75,0)
 S RORPTN=$$REGSIZE^RORUTL02(+RORREG)  S:RORPTN<0 RORPTN=0
"RTN","RORX007",76,0)
 S ECNT=0  K ^TMP("RORX007",$J)
"RTN","RORX007",77,0)
 ;
"RTN","RORX007",78,0)
 ;--- Report header
"RTN","RORX007",79,0)
 S RC=$$HEADER^RORX007A(REPORT)  Q:RC<0 RC
"RTN","RORX007",80,0)
 ;
"RTN","RORX007",81,0)
 D
"RTN","RORX007",82,0)
 . ;--- Query the registry
"RTN","RORX007",83,0)
 . D TPPSETUP^RORTSK01(75)
"RTN","RORX007",84,0)
 . S RC=$$QUERY^RORX007A(SFLAGS_"DI")
"RTN","RORX007",85,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX007",86,0)
 . ;--- Sort the data
"RTN","RORX007",87,0)
 . D TPPSETUP^RORTSK01(10)
"RTN","RORX007",88,0)
 . S RC=$$SORT()
"RTN","RORX007",89,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX007",90,0)
 . ;--- Store the results
"RTN","RORX007",91,0)
 . D TPPSETUP^RORTSK01(15)
"RTN","RORX007",92,0)
 . S RC=$$STORE(REPORT)
"RTN","RORX007",93,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX007",94,0)
 ;
"RTN","RORX007",95,0)
 ;--- Cleanup
"RTN","RORX007",96,0)
 K ^TMP("RORX007",$J)
"RTN","RORX007",97,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX007",98,0)
 ;
"RTN","RORX007",99,0)
 ;***** SORTS THE RESULTS AND COMPILES THE TOTALS
"RTN","RORX007",100,0)
 ;
"RTN","RORX007",101,0)
 ; SPCNT         Number of patients selected for the report
"RTN","RORX007",102,0)
 ;
"RTN","RORX007",103,0)
 ; Return Values:
"RTN","RORX007",104,0)
 ;       <0  Error code
"RTN","RORX007",105,0)
 ;        0  Ok
"RTN","RORX007",106,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX007",107,0)
 ;
"RTN","RORX007",108,0)
SORT(SPCNT) ;
"RTN","RORX007",109,0)
 N CATSUB,DFN,DPCNT,ECNT,FSUM,NAME,NODE,NSUB,PRCNT,PQ,PRN,RC,RORI,TMP,TOTAL,VA,VADM,VAHOW,VAROOT
"RTN","RORX007",110,0)
 S FSUM=$D(RORMODE("AIDS"))&$D(RORMODE("HIV"))
"RTN","RORX007",111,0)
 S NSUB=$$NCAT^RORICRUT,(ECNT,RC)=0
"RTN","RORX007",112,0)
 ;---
"RTN","RORX007",113,0)
 F RORI=NSUB:-1:1  D  Q:RC<0
"RTN","RORX007",114,0)
 . S RC=$$LOOP^RORTSK01((NSUB-RORI)/3)  Q:RC<0
"RTN","RORX007",115,0)
 . S CATSUB=$P($$CAT^RORICRUT(RORI),U)
"RTN","RORX007",116,0)
 . S NODE=$NA(^TMP("RORX007",$J,CATSUB))
"RTN","RORX007",117,0)
 . Q:$D(@NODE)<10  K TOTAL
"RTN","RORX007",118,0)
 . ;--- Procedures
"RTN","RORX007",119,0)
 . S PRN=""
"RTN","RORX007",120,0)
 . F  S PRN=$O(@NODE@("PROC",PRN))  Q:PRN=""  D
"RTN","RORX007",121,0)
 . . S (DPCNT,PRCNT)=0
"RTN","RORX007",122,0)
 . . S DFN=""
"RTN","RORX007",123,0)
 . . F  S DFN=$O(@NODE@("PROC",PRN,DFN))  Q:DFN=""  D
"RTN","RORX007",124,0)
 . . . S PQ=$G(@NODE@("PROC",PRN,DFN))
"RTN","RORX007",125,0)
 . . . S DPCNT=DPCNT+1,PRCNT=PRCNT+PQ
"RTN","RORX007",126,0)
 . . . Q:'FSUM!(CATSUB="ALLCATS")
"RTN","RORX007",127,0)
 . . . S ^TMP("RORX007",$J,"ALLCATS","PROC",PRN,DFN)=PQ
"RTN","RORX007",128,0)
 . . ;---
"RTN","RORX007",129,0)
 . . S @NODE@("PROCSORT",PRCNT,$P(PRN,U),$P(PRN,U,2))=DPCNT
"RTN","RORX007",130,0)
 . . S TOTAL("DPR")=$G(TOTAL("DPR"))+1      ; Different procedures
"RTN","RORX007",131,0)
 . . S TOTAL("TPT")=$G(TOTAL("TPT"))+DPCNT  ; Number of patients
"RTN","RORX007",132,0)
 . K @NODE@("PROC")
"RTN","RORX007",133,0)
 . ;--- Patients
"RTN","RORX007",134,0)
 . S DFN=""
"RTN","RORX007",135,0)
 . F  S DFN=$O(@NODE@("PAT",DFN))  Q:DFN=""  D
"RTN","RORX007",136,0)
 . . S (DPCNT,PRCNT)=0
"RTN","RORX007",137,0)
 . . D DEM^VADPT
"RTN","RORX007",138,0)
 . . S NAME=$G(VADM(1))  Q:NAME=""
"RTN","RORX007",139,0)
 . . S LAST4=$G(VA("BID"))  S:LAST4="" LAST4=" "
"RTN","RORX007",140,0)
 . . S PRN=""
"RTN","RORX007",141,0)
 . . F  S PRN=$O(@NODE@("PAT",DFN,PRN))  Q:PRN=""  D
"RTN","RORX007",142,0)
 . . . S PQ=$G(@NODE@("PAT",DFN,PRN))
"RTN","RORX007",143,0)
 . . . S DPCNT=DPCNT+1,PRCNT=PRCNT+PQ
"RTN","RORX007",144,0)
 . . . Q:'FSUM!(CATSUB="ALLCATS")
"RTN","RORX007",145,0)
 . . . S ^TMP("RORX007",$J,"ALLCATS","PAT",DFN,PRN)=PQ
"RTN","RORX007",146,0)
 . . ;---
"RTN","RORX007",147,0)
 . . S @NODE@("PATSORT",PRCNT,NAME,LAST4)=DPCNT
"RTN","RORX007",148,0)
 . . S TOTAL("TPR")=$G(TOTAL("TPR"))+PRCNT  ; Number of procedures
"RTN","RORX007",149,0)
 . . S TOTAL("DPT")=$G(TOTAL("DPT"))+1      ; Different patients
"RTN","RORX007",150,0)
 . K @NODE@("PAT")
"RTN","RORX007",151,0)
 . ;--- Totals
"RTN","RORX007",152,0)
 . S TMP=$G(TOTAL("TPR"))_U_$G(TOTAL("DPR"))
"RTN","RORX007",153,0)
 . S @NODE@("TOTAL")=TMP_U_$G(TOTAL("TPT"))_U_$G(TOTAL("DPT"))
"RTN","RORX007",154,0)
 ;---
"RTN","RORX007",155,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX007",156,0)
 ;
"RTN","RORX007",157,0)
 ;***** STORES THE RESULTS
"RTN","RORX007",158,0)
 ;
"RTN","RORX007",159,0)
 ; Return Values:
"RTN","RORX007",160,0)
 ;       <0  Error code
"RTN","RORX007",161,0)
 ;        0  Ok
"RTN","RORX007",162,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX007",163,0)
 ;
"RTN","RORX007",164,0)
STORE(PARTAG) ;
"RTN","RORX007",165,0)
 N RORSONLY      ; Output summary only
"RTN","RORX007",166,0)
 ;
"RTN","RORX007",167,0)
 N CATEGORY,CATSUB,RC,RORI,TMP
"RTN","RORX007",168,0)
 S RORSONLY=$$SMRYONLY^RORXU006()
"RTN","RORX007",169,0)
 S NSUB=$$NCAT^RORICRUT,RC=0
"RTN","RORX007",170,0)
 ;--- Tables
"RTN","RORX007",171,0)
 F RORI=NSUB:-1:1  D  Q:RC<0
"RTN","RORX007",172,0)
 . S RC=$$LOOP^RORTSK01((NSUB-RORI)/3)  Q:RC<0
"RTN","RORX007",173,0)
 . S TMP=$$CAT^RORICRUT(RORI),CATSUB=$P(TMP,U)
"RTN","RORX007",174,0)
 . Q:$D(^TMP("RORX007",$J,CATSUB))<10
"RTN","RORX007",175,0)
 . ;--- Category
"RTN","RORX007",176,0)
 . S CATEGORY=$$ADDVAL^RORTSK11(RORTSK,"CATEGORY",,PARTAG)
"RTN","RORX007",177,0)
 . D ADDVAL^RORTSK11(RORTSK,"NAME",$P(TMP,U,2),CATEGORY)
"RTN","RORX007",178,0)
 . ;--- Procedures
"RTN","RORX007",179,0)
 . S RC=$$TBLPROC(CATEGORY,CATSUB)  Q:RC<0
"RTN","RORX007",180,0)
 . ;--- Patients
"RTN","RORX007",181,0)
 . S RC=$$TBLPAT(CATEGORY,CATSUB)   Q:RC<0
"RTN","RORX007",182,0)
 . ;--- Totals
"RTN","RORX007",183,0)
 . S TMP=$G(^TMP("RORX007",$J,CATSUB,"TOTAL"))
"RTN","RORX007",184,0)
 . D ADDVAL^RORTSK11(RORTSK,"NPR",$P(TMP,U,1),CATEGORY)
"RTN","RORX007",185,0)
 . D ADDVAL^RORTSK11(RORTSK,"NDP",$P(TMP,U,2),CATEGORY)
"RTN","RORX007",186,0)
 . D ADDVAL^RORTSK11(RORTSK,"NP",$P(TMP,U,4),CATEGORY)
"RTN","RORX007",187,0)
 ;---
"RTN","RORX007",188,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORX007",189,0)
 ;
"RTN","RORX007",190,0)
 ;***** STORES THE TABLE OF PATIENTS
"RTN","RORX007",191,0)
 ;
"RTN","RORX007",192,0)
 ; CATEGORY      IEN of the parent tag (<CATEGORY>)
"RTN","RORX007",193,0)
 ;
"RTN","RORX007",194,0)
 ; CATSUB        Category subscript in the temporary global
"RTN","RORX007",195,0)
 ;
"RTN","RORX007",196,0)
 ; Return Values:
"RTN","RORX007",197,0)
 ;       <0  Error code
"RTN","RORX007",198,0)
 ;        0  Ok
"RTN","RORX007",199,0)
 ;
"RTN","RORX007",200,0)
TBLPAT(CATEGORY,CATSUB) ;
"RTN","RORX007",201,0)
 N ITEM,LAST4,MAXUTNUM,NAME,NODE,PRCNT,RC,TABLE,TMP,UTNUM
"RTN","RORX007",202,0)
 S MAXUTNUM=$$PARAM^RORTSK01("MAXUTNUM")
"RTN","RORX007",203,0)
 Q:MAXUTNUM'>0 0
"RTN","RORX007",204,0)
 S TABLE=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,CATEGORY)
"RTN","RORX007",205,0)
 Q:TABLE<0 TABLE
"RTN","RORX007",206,0)
 D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","PATIENTS")
"RTN","RORX007",207,0)
 S NODE=$NA(^TMP("RORX007",$J,CATSUB,"PATSORT"))
"RTN","RORX007",208,0)
 ;--- Table
"RTN","RORX007",209,0)
 S PRCNT="",(RC,UTNUM)=0
"RTN","RORX007",210,0)
 F  S PRCNT=$O(@NODE@(PRCNT),-1)  Q:PRCNT=""  D  Q:RC
"RTN","RORX007",211,0)
 . S NAME=""
"RTN","RORX007",212,0)
 . F  S NAME=$O(@NODE@(PRCNT,NAME))  Q:NAME=""  D  Q:RC
"RTN","RORX007",213,0)
 . . S LAST4=""
"RTN","RORX007",214,0)
 . . F  S LAST4=$O(@NODE@(PRCNT,NAME,LAST4))  Q:LAST4=""  D  Q:RC
"RTN","RORX007",215,0)
 . . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,TABLE)
"RTN","RORX007",216,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NAME",NAME,ITEM,1)
"RTN","RORX007",217,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"LAST4",LAST4,ITEM,1)
"RTN","RORX007",218,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"TOTAL",PRCNT,ITEM,1)
"RTN","RORX007",219,0)
 . . . S TMP=+@NODE@(PRCNT,NAME,LAST4)
"RTN","RORX007",220,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"UNIQUE",TMP,ITEM,1)
"RTN","RORX007",221,0)
 . . . S UTNUM=UTNUM+1  S:UTNUM'<MAXUTNUM RC=1
"RTN","RORX007",222,0)
 Q:RC<0 RC
"RTN","RORX007",223,0)
 ;---
"RTN","RORX007",224,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORX007",225,0)
 ;
"RTN","RORX007",226,0)
 ;***** STORES THE TABLE OF PROCEDURES
"RTN","RORX007",227,0)
 ;
"RTN","RORX007",228,0)
 ; CATEGORY      IEN of the parent tag (<CATEGORY>)
"RTN","RORX007",229,0)
 ;
"RTN","RORX007",230,0)
 ; CATSUB        Category subscript in the temporary global
"RTN","RORX007",231,0)
 ;
"RTN","RORX007",232,0)
 ; Return Values:
"RTN","RORX007",233,0)
 ;       <0  Error code
"RTN","RORX007",234,0)
 ;        0  Ok
"RTN","RORX007",235,0)
 ;
"RTN","RORX007",236,0)
TBLPROC(CATEGORY,CATSUB) ;
"RTN","RORX007",237,0)
 N CPT,ITEM,MINRPNUM,NODE,PRCNT,PRN,TABLE,TMP
"RTN","RORX007",238,0)
 S MINRPNUM=$$PARAM^RORTSK01("MINRPNUM")
"RTN","RORX007",239,0)
 Q:MINRPNUM'>0 0
"RTN","RORX007",240,0)
 S TABLE=$$ADDVAL^RORTSK11(RORTSK,"PROCEDURES",,CATEGORY)
"RTN","RORX007",241,0)
 Q:TABLE<0 TABLE
"RTN","RORX007",242,0)
 D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","PROCEDURES")
"RTN","RORX007",243,0)
 S NODE=$NA(^TMP("RORX007",$J,CATSUB,"PROCSORT"))
"RTN","RORX007",244,0)
 ;--- Table
"RTN","RORX007",245,0)
 S PRCNT="",RC=0
"RTN","RORX007",246,0)
 F  S PRCNT=$O(@NODE@(PRCNT),-1)  Q:PRCNT<MINRPNUM  D  Q:RC
"RTN","RORX007",247,0)
 . S PRN=""
"RTN","RORX007",248,0)
 . F  S PRN=$O(@NODE@(PRCNT,PRN))  Q:PRN=""  D  Q:RC
"RTN","RORX007",249,0)
 . . S CPT=""
"RTN","RORX007",250,0)
 . . F  S CPT=$O(@NODE@(PRCNT,PRN,CPT))  Q:CPT=""  D  Q:RC
"RTN","RORX007",251,0)
 . . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"PROCEDURE",,TABLE)
"RTN","RORX007",252,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NAME",PRN,ITEM,1)
"RTN","RORX007",253,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"CPT",CPT,ITEM,2)
"RTN","RORX007",254,0)
 . . . S TMP=+@NODE@(PRCNT,PRN,CPT)
"RTN","RORX007",255,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"PATIENTS",TMP,ITEM,1)
"RTN","RORX007",256,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"TOTAL",PRCNT,ITEM,1)
"RTN","RORX007",257,0)
 Q:RC<0 RC
"RTN","RORX007",258,0)
 ;---
"RTN","RORX007",259,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORX007A")
0^102^B13263174
"RTN","RORX007A",1,0)
RORX007A ;HCIOFO/BH,SG - RADILOGY UTILIZATION (OVERFLOW) ; 12/10/03 10:53am
"RTN","RORX007A",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX007A",3,0)
 ;
"RTN","RORX007A",4,0)
 Q
"RTN","RORX007A",5,0)
 ;
"RTN","RORX007A",6,0)
 ;***** APPENDS MODIFIERS TO THE CPT CODE
"RTN","RORX007A",7,0)
 ;
"RTN","RORX007A",8,0)
 ; CPT           CPT code
"RTN","RORX007A",9,0)
 ;
"RTN","RORX007A",10,0)
 ; NODE          Closed root of the exam data node returned
"RTN","RORX007A",11,0)
 ;               by the EN1^RAO7PC1
"RTN","RORX007A",12,0)
 ;
"RTN","RORX007A",13,0)
CPTMOD(CPT,NODE) ;
"RTN","RORX007A",14,0)
 N CPM,RORIM
"RTN","RORX007A",15,0)
 S RORIM=""
"RTN","RORX007A",16,0)
 F  S RORIM=$O(@NODE@("CMOD",RORIM))  Q:RORIM=""  D
"RTN","RORX007A",17,0)
 . S CPM=$P($G(@NODE@("CMOD",RORIM)),U)
"RTN","RORX007A",18,0)
 . S:CPM'="" CPT=CPT_"-"_CPM
"RTN","RORX007A",19,0)
 Q CPT
"RTN","RORX007A",20,0)
 ;
"RTN","RORX007A",21,0)
 ;***** LOADS AND PROCESSES THE RADILOGY DATA
"RTN","RORX007A",22,0)
 ;
"RTN","RORX007A",23,0)
 ; DFN           Patient IEN (in file #2)
"RTN","RORX007A",24,0)
 ;
"RTN","RORX007A",25,0)
 ; CATSUB        Category subscript in the temporary global
"RTN","RORX007A",26,0)
 ;
"RTN","RORX007A",27,0)
 ; Return Values:
"RTN","RORX007A",28,0)
 ;       <0  Error code
"RTN","RORX007A",29,0)
 ;        0  Ok
"RTN","RORX007A",30,0)
 ;
"RTN","RORX007A",31,0)
GETDATA(DFN,CATSUB) ;
"RTN","RORX007A",32,0)
 N CPT,EXAMID,NODE,PRNAME,RORBUF
"RTN","RORX007A",33,0)
 ;--- Get the data
"RTN","RORX007A",34,0)
 D EN1^RAO7PC1(DFN,RORSDT,ROREDT,999999)
"RTN","RORX007A",35,0)
 Q:'$D(^TMP($J,"RAE1",PATIEN)) 0
"RTN","RORX007A",36,0)
 ;
"RTN","RORX007A",37,0)
 ;--- Process the data
"RTN","RORX007A",38,0)
 S EXAMID=""
"RTN","RORX007A",39,0)
 F  S EXAMID=$O(^TMP($J,"RAE1",DFN,EXAMID))  Q:EXAMID=""  D
"RTN","RORX007A",40,0)
 . S NODE=$NA(^TMP($J,"RAE1",DFN,EXAMID))
"RTN","RORX007A",41,0)
 . S RORBUF=$G(@NODE),CPT=$$CPTMOD($P(RORBUF,U,10),NODE)
"RTN","RORX007A",42,0)
 . ;--- Get Procedure Name
"RTN","RORX007A",43,0)
 . S PRNAME=$E($P(RORBUF,U),1,30)  Q:PRNAME=""
"RTN","RORX007A",44,0)
 . S PRNAME=PRNAME_U_$S(CPT'="":CPT,1:" ")
"RTN","RORX007A",45,0)
 . ;--- Increment the counters
"RTN","RORX007A",46,0)
 . S ^(DFN)=$G(^TMP("RORX007",$J,CATSUB,"PROC",PRNAME,DFN))+1
"RTN","RORX007A",47,0)
 . S ^(PRNAME)=$G(^TMP("RORX007",$J,CATSUB,"PAT",DFN,PRNAME))+1
"RTN","RORX007A",48,0)
 ;
"RTN","RORX007A",49,0)
 ;--- Cleanup
"RTN","RORX007A",50,0)
 K ^TMP($J,"RAE1")
"RTN","RORX007A",51,0)
 Q 0
"RTN","RORX007A",52,0)
 ;
"RTN","RORX007A",53,0)
 ;***** OUTPUTS THE REPORT HEADER
"RTN","RORX007A",54,0)
 ;
"RTN","RORX007A",55,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX007A",56,0)
 ;
"RTN","RORX007A",57,0)
 ; Return Values:
"RTN","RORX007A",58,0)
 ;       <0  Error code
"RTN","RORX007A",59,0)
 ;        0  Ok
"RTN","RORX007A",60,0)
 ;
"RTN","RORX007A",61,0)
HEADER(PARTAG) ;
"RTN","RORX007A",62,0)
 ;;PATIENTS(#,NAME,LAST4,TOTAL,UNIQUE)
"RTN","RORX007A",63,0)
 ;;PROCEDURES(#,NAME,CPT,PATIENTS,TOTAL)
"RTN","RORX007A",64,0)
 ;
"RTN","RORX007A",65,0)
 N HEADER,RC
"RTN","RORX007A",66,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX007A",67,0)
 Q:HEADER<0 HEADER
"RTN","RORX007A",68,0)
 S RC=$$TBLDEF^RORXU002("HEADER^RORX007A",HEADER)
"RTN","RORX007A",69,0)
 Q $S(RC<0:RC,1:HEADER)
"RTN","RORX007A",70,0)
 ;
"RTN","RORX007A",71,0)
 ;***** OUTPUTS THE PARAMETERS TO THE REPORT
"RTN","RORX007A",72,0)
 ;
"RTN","RORX007A",73,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX007A",74,0)
 ;
"RTN","RORX007A",75,0)
 ; [.STDT]       Start and end dates of the report
"RTN","RORX007A",76,0)
 ; [.ENDT]       are returned via these parameters
"RTN","RORX007A",77,0)
 ;
"RTN","RORX007A",78,0)
 ; [.FLAGS]      Flags for the $$SKIP^RORXU005 are
"RTN","RORX007A",79,0)
 ;               returned via this parameter
"RTN","RORX007A",80,0)
 ;
"RTN","RORX007A",81,0)
 ; Return Values:
"RTN","RORX007A",82,0)
 ;       <0  Error code
"RTN","RORX007A",83,0)
 ;       >0  IEN of the PARAMETERS element
"RTN","RORX007A",84,0)
 ;
"RTN","RORX007A",85,0)
PARAMS(PARTAG,STDT,ENDT,FLAGS) ;
"RTN","RORX007A",86,0)
 N NAME,PARAMS,TMP
"RTN","RORX007A",87,0)
 S PARAMS=$$PARAMS^RORXU002(.RORTSK,PARTAG,.STDT,.ENDT,.FLAGS)
"RTN","RORX007A",88,0)
 Q:PARAMS<0 PARAMS
"RTN","RORX007A",89,0)
 ;--- Additional parameters
"RTN","RORX007A",90,0)
 F NAME="MAXUTNUM","MINRPNUM"  D
"RTN","RORX007A",91,0)
 . S TMP=$$PARAM^RORTSK01(NAME)
"RTN","RORX007A",92,0)
 . D:TMP'="" ADDVAL^RORTSK11(RORTSK,NAME,TMP,PARAMS)
"RTN","RORX007A",93,0)
 ;---
"RTN","RORX007A",94,0)
 Q PARAMS
"RTN","RORX007A",95,0)
 ;
"RTN","RORX007A",96,0)
 ;***** QUERIES THE REGISTRY
"RTN","RORX007A",97,0)
 ;
"RTN","RORX007A",98,0)
 ; FLAGS         Flags for the $$SKIP^RORXU005
"RTN","RORX007A",99,0)
 ;
"RTN","RORX007A",100,0)
 ; Return Values:
"RTN","RORX007A",101,0)
 ;       <0  Error code
"RTN","RORX007A",102,0)
 ;        0  Ok
"RTN","RORX007A",103,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX007A",104,0)
 ;
"RTN","RORX007A",105,0)
QUERY(FLAGS) ;
"RTN","RORX007A",106,0)
 N CATSUB,CNT,ECNT,IEN,IENS,PATIEN,RC,RORMSG,TMP,XREFNODE
"RTN","RORX007A",107,0)
 S XREFNODE=$NA(^RORDATA(798,"AC",+RORREG))
"RTN","RORX007A",108,0)
 S (CNT,ECNT,RC)=0
"RTN","RORX007A",109,0)
 ;--- Browse through the registry records
"RTN","RORX007A",110,0)
 S IEN=0
"RTN","RORX007A",111,0)
 F  S IEN=$O(@XREFNODE@(IEN))  Q:IEN'>0  D  Q:RC<0
"RTN","RORX007A",112,0)
 . S TMP=$S(RORPTN>0:CNT/RORPTN,1:"")
"RTN","RORX007A",113,0)
 . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX007A",114,0)
 . S IENS=IEN_",",CNT=CNT+1
"RTN","RORX007A",115,0)
 . ;--- Check if the patient should be skipped
"RTN","RORX007A",116,0)
 . Q:$$SKIP^RORXU005(IEN,FLAGS,RORSDT,ROREDT)
"RTN","RORX007A",117,0)
 . ;
"RTN","RORX007A",118,0)
 . ;--- Get the patient IEN (DFN)
"RTN","RORX007A",119,0)
 . S PATIEN=$$PTIEN^RORUTL01(IEN)  Q:PATIEN'>0
"RTN","RORX007A",120,0)
 . ;
"RTN","RORX007A",121,0)
 . ;--- Get the category subscript
"RTN","RORX007A",122,0)
 . S TMP=$$CLINAIDS^RORICRUT(IEN,ROREDT)
"RTN","RORX007A",123,0)
 . Q:'$D(RORMODE($S(TMP:"AIDS",1:"HIV")))
"RTN","RORX007A",124,0)
 . S CATSUB=$S(TMP:"AIDS",1:"HIV")
"RTN","RORX007A",125,0)
 . ;
"RTN","RORX007A",126,0)
 . ;--- Get the radiology data
"RTN","RORX007A",127,0)
 . S RC=$$GETDATA(PATIEN,CATSUB)
"RTN","RORX007A",128,0)
 . I RC  S ECNT=ECNT+1  Q:RC<0
"RTN","RORX007A",129,0)
 ;---
"RTN","RORX007A",130,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX007A",131,0)
 ;
"RTN","RORX007A",132,0)
 ;***** PLURAL/SINGULAR
"RTN","RORX007A",133,0)
SRPL(QNTY,WORD,SQ) ;
"RTN","RORX007A",134,0)
 Q $S('$G(SQ):QNTY_" ",1:"")_$P(WORD,U,$S(QNTY=1:1,1:2))
"RTN","RORX008")
0^163^B9126284
"RTN","RORX008",1,0)
RORX008 ;HOIFO/BH,SG - VERA REIMBURSEMENT REPORT ; 12/10/03 12:07pm
"RTN","RORX008",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;March 14, 2003
"RTN","RORX008",3,0)
 ;
"RTN","RORX008",4,0)
 ;--------------------------------------------------------------------
"RTN","RORX008",5,0)
 ; Registry: [VA ICR]
"RTN","RORX008",6,0)
 ;--------------------------------------------------------------------
"RTN","RORX008",7,0)
 Q
"RTN","RORX008",8,0)
 ;
"RTN","RORX008",9,0)
 ;***** COMPILES THE "VERA REIMBURSEMENT" REPORT
"RTN","RORX008",10,0)
 ; REPORT CODE: 008
"RTN","RORX008",11,0)
 ;
"RTN","RORX008",12,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORX008",13,0)
 ;
"RTN","RORX008",14,0)
 ; The ^TMP("RORX008",$J) and ^TMP("RORX008D",$J) global nodes are
"RTN","RORX008",15,0)
 ; used by this function.
"RTN","RORX008",16,0)
 ;
"RTN","RORX008",17,0)
 ; ^TMP("RORX008",$J,
"RTN","RORX008",18,0)
 ;
"RTN","RORX008",19,0)
 ;   "DRG",
"RTN","RORX008",20,0)
 ;     GenDrugIEN,       Generic drug name
"RTN","RORX008",21,0)
 ;       0)              Number of HIV+ patients
"RTN","RORX008",22,0)
 ;       1)              Number of Clinical AIDS patients
"RTN","RORX008",23,0)
 ;
"RTN","RORX008",24,0)
 ;   "PAT",              Totals
"RTN","RORX008",25,0)
 ;                         ^01: Number of basic care patients
"RTN","RORX008",26,0)
 ;                         ^02: Number of complex care patients
"RTN","RORX008",27,0)
 ;                         ^03: Number of patients received ARVs
"RTN","RORX008",28,0)
 ;     DFN)              Patient Descriptor
"RTN","RORX008",29,0)
 ;                         ^01: Las 4 digits of SSN
"RTN","RORX008",30,0)
 ;                         ^02: Name
"RTN","RORX008",31,0)
 ;                         ^03: Clinical AIDS (0/1)
"RTN","RORX008",32,0)
 ;                         ^04: Received ARV drugs(0/1)
"RTN","RORX008",33,0)
 ;                         ^05: Complex care (0/1)
"RTN","RORX008",34,0)
 ;
"RTN","RORX008",35,0)
 ; Return Values:
"RTN","RORX008",36,0)
 ;       <0  Error code
"RTN","RORX008",37,0)
 ;        0  Ok
"RTN","RORX008",38,0)
 ;
"RTN","RORX008",39,0)
ARVREIMB(RORTSK) ;
"RTN","RORX008",40,0)
 N ROREDT        ; End date
"RTN","RORX008",41,0)
 N ROREDT1       ; End date + 1
"RTN","RORX008",42,0)
 N RORMODE       ; Subset of patients to be selected
"RTN","RORX008",43,0)
 N ROROPT        ; Report options
"RTN","RORX008",44,0)
 N RORREG        ; Registry IEN
"RTN","RORX008",45,0)
 N RORSDT        ; Start date
"RTN","RORX008",46,0)
 N RORXOPT       ; Drug options
"RTN","RORX008",47,0)
 ;
"RTN","RORX008",48,0)
 N ECNT,RC,REPORT,SFLAGS,TMP
"RTN","RORX008",49,0)
 ;--- Root node of the report
"RTN","RORX008",50,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX008",51,0)
 Q:REPORT<0 REPORT
"RTN","RORX008",52,0)
 ;
"RTN","RORX008",53,0)
 ;--- Get and prepare the report parameters
"RTN","RORX008",54,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")
"RTN","RORX008",55,0)
 S RC=$$PARAMS(REPORT,.RORSDT,.ROREDT,.SFLAGS)
"RTN","RORX008",56,0)
 Q:RC<0 RC
"RTN","RORX008",57,0)
 S RORMODE=$$PARAM^RORTSK01("PATIENTS")
"RTN","RORX008",58,0)
 D LIST^RORXU002(.RORMODE)
"RTN","RORX008",59,0)
 S ROROPT=$$PARAM^RORTSK01("OPTIONS")
"RTN","RORX008",60,0)
 D LIST^RORXU002(.ROROPT)
"RTN","RORX008",61,0)
 ;
"RTN","RORX008",62,0)
 ;--- Initialize constants and variables
"RTN","RORX008",63,0)
 S ROREDT1=$$FMADD^XLFDT(ROREDT\1,1),ECNT=0
"RTN","RORX008",64,0)
 K ^TMP("RORX008",$J)
"RTN","RORX008",65,0)
 ;
"RTN","RORX008",66,0)
 ;--- Report header
"RTN","RORX008",67,0)
 S RC=$$HEADER(REPORT)  Q:RC<0 RC
"RTN","RORX008",68,0)
 ;
"RTN","RORX008",69,0)
 S RC=0  D
"RTN","RORX008",70,0)
 . ;--- Query the registry
"RTN","RORX008",71,0)
 . D TPPSETUP^RORTSK01(75)
"RTN","RORX008",72,0)
 . S RC=$$QUERY^RORX008A(SFLAGS_"DI")
"RTN","RORX008",73,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX008",74,0)
 . ;--- Store the results
"RTN","RORX008",75,0)
 . D TPPSETUP^RORTSK01(25)
"RTN","RORX008",76,0)
 . S RC=$$STORE^RORX008A(REPORT)
"RTN","RORX008",77,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX008",78,0)
 ;
"RTN","RORX008",79,0)
 ;--- Cleanup
"RTN","RORX008",80,0)
 K ^TMP("RORX008",$J),^TMP("RORX008D",$J)
"RTN","RORX008",81,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX008",82,0)
 ;
"RTN","RORX008",83,0)
 ;***** OUTPUTS THE REPORT HEADER
"RTN","RORX008",84,0)
 ;
"RTN","RORX008",85,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX008",86,0)
 ;
"RTN","RORX008",87,0)
 ; Return Values:
"RTN","RORX008",88,0)
 ;       <0  Error code
"RTN","RORX008",89,0)
 ;       >0  IEN of the HEADER element
"RTN","RORX008",90,0)
 ;
"RTN","RORX008",91,0)
HEADER(PARTAG) ;
"RTN","RORX008",92,0)
 ;;DRUGS(#,NAME,NP,NPHIV,NPAIDS)             ^I $D(ROROPT("ARVSMRY"))
"RTN","RORX008",93,0)
 ;;PATIENTS(#,NAME,LAST4,AIDSTAT,ARV,COMPLEX)^I $D(ROROPT("PTLIST"))
"RTN","RORX008",94,0)
 ;
"RTN","RORX008",95,0)
 N HEADER,RC
"RTN","RORX008",96,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX008",97,0)
 Q:HEADER<0 HEADER
"RTN","RORX008",98,0)
 S RC=$$TBLDEF^RORXU002("HEADER^RORX008",HEADER)
"RTN","RORX008",99,0)
 Q $S(RC<0:RC,1:HEADER)
"RTN","RORX008",100,0)
 ;
"RTN","RORX008",101,0)
 ;***** OUTPUTS THE PARAMETERS TO THE REPORT
"RTN","RORX008",102,0)
 ;
"RTN","RORX008",103,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX008",104,0)
 ;
"RTN","RORX008",105,0)
 ; [.STDT]       Start and end dates of the report
"RTN","RORX008",106,0)
 ; [.ENDT]       are returned via these parameters
"RTN","RORX008",107,0)
 ;
"RTN","RORX008",108,0)
 ; [.FLAGS]      Flags for the $$SKIP^RORXU005 are
"RTN","RORX008",109,0)
 ;               returned via this parameter
"RTN","RORX008",110,0)
 ;
"RTN","RORX008",111,0)
 ; Return Values:
"RTN","RORX008",112,0)
 ;       <0  Error code
"RTN","RORX008",113,0)
 ;       >0  IEN of the PARAMETERS element
"RTN","RORX008",114,0)
 ;
"RTN","RORX008",115,0)
PARAMS(PARTAG,STDT,ENDT,FLAGS) ;
"RTN","RORX008",116,0)
 N PARAMS,TMP
"RTN","RORX008",117,0)
 S PARAMS=$$PARAMS^RORXU002(.RORTSK,PARTAG,.STDT,.ENDT,.FLAGS)
"RTN","RORX008",118,0)
 Q:PARAMS<0 PARAMS
"RTN","RORX008",119,0)
 ;--- Process the drug options
"RTN","RORX008",120,0)
 S TMP=$$DRUGLST^RORXU007(.RORTSK,PARAMS,,.RORXOPT)
"RTN","RORX008",121,0)
 Q:TMP<0 TMP
"RTN","RORX008",122,0)
 ;---
"RTN","RORX008",123,0)
 Q PARAMS
"RTN","RORX008A")
0^174^B26936017
"RTN","RORX008A",1,0)
RORX008A ;HOIFO/BH,SG - VERA REIMBURSEMENT REPORT ; 12/10/03 12:07pm
"RTN","RORX008A",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;March 14, 2003
"RTN","RORX008A",3,0)
 ;
"RTN","RORX008A",4,0)
 Q
"RTN","RORX008A",5,0)
 ;
"RTN","RORX008A",6,0)
 ;***** QUERIES THE REGISTRY
"RTN","RORX008A",7,0)
 ;
"RTN","RORX008A",8,0)
 ; FLAGS         Flags for the $$SKIP^RORXU005
"RTN","RORX008A",9,0)
 ;
"RTN","RORX008A",10,0)
 ; Return Values:
"RTN","RORX008A",11,0)
 ;       <0  Error code
"RTN","RORX008A",12,0)
 ;        0  Ok
"RTN","RORX008A",13,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX008A",14,0)
 ;
"RTN","RORX008A",15,0)
QUERY(FLAGS) ;
"RTN","RORX008A",16,0)
 N RORPTN        ; Number of patients in the registry
"RTN","RORX008A",17,0)
 ;
"RTN","RORX008A",18,0)
 N CLINAIDS,CMPXCARE,CNT,CNTARV,CNTBASIC,CNTCMPX,ECNT,IEN,NAME,PATIEN,RC,RORIEN,RORXDST,RORXL,TMP,UTLCHK,VA,VADM,VAERR,XREFNODE
"RTN","RORX008A",19,0)
 ;
"RTN","RORX008A",20,0)
 S XREFNODE=$NA(^RORDATA(798,"AC",+RORREG))
"RTN","RORX008A",21,0)
 S RORPTN=$$REGSIZE^RORUTL02(+RORREG)  S:RORPTN<0 RORPTN=0
"RTN","RORX008A",22,0)
 S (CNT,CNTARV,CNTBASIC,CNTCMPX,ECNT,RC)=0
"RTN","RORX008A",23,0)
 S UTLCHK("ALL")=""
"RTN","RORX008A",24,0)
 ;
"RTN","RORX008A",25,0)
 ;--- Prepare parameters for the pharmacy search API
"RTN","RORX008A",26,0)
 S RORXDST("RORCB")="$$RXSCB^RORX008A"
"RTN","RORX008A",27,0)
 S RORXDST("SINGLE")='$D(ROROPT("ARVSMRY"))!'$D(RORMODE("COMPLEX"))
"RTN","RORX008A",28,0)
 ;
"RTN","RORX008A",29,0)
 ;--- Compile the list of ARV drugs and classes
"RTN","RORX008A",30,0)
 S RORXL=$NA(^TMP("RORX008D",$J))
"RTN","RORX008A",31,0)
 S TMP="DGR"  S:$D(RORXOPT("INVESTIG")) TMP=TMP_"C"
"RTN","RORX008A",32,0)
 S RC=$$DRUGLIST^RORUTL16(RORXL,+RORREG,TMP)
"RTN","RORX008A",33,0)
 Q:RC<0 RC
"RTN","RORX008A",34,0)
 ;
"RTN","RORX008A",35,0)
 ;--- Browse through the registry records
"RTN","RORX008A",36,0)
 S RORIEN=0
"RTN","RORX008A",37,0)
 F  S RORIEN=$O(@XREFNODE@(RORIEN))  Q:RORIEN'>0  D  Q:RC<0
"RTN","RORX008A",38,0)
 . S TMP=$S(RORPTN>0:CNT/RORPTN,1:"")
"RTN","RORX008A",39,0)
 . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX008A",40,0)
 . S CNT=CNT+1
"RTN","RORX008A",41,0)
 . ;--- Check if the patient should be skipped
"RTN","RORX008A",42,0)
 . Q:$$SKIP^RORXU005(RORIEN,FLAGS,RORSDT,ROREDT)
"RTN","RORX008A",43,0)
 . ;
"RTN","RORX008A",44,0)
 . ;--- Get the patient IEN (DFN)
"RTN","RORX008A",45,0)
 . S PATIEN=$$PTIEN^RORUTL01(RORIEN)  Q:PATIEN'>0
"RTN","RORX008A",46,0)
 . ;
"RTN","RORX008A",47,0)
 . ;--- Skip Clinical AIDS if Complex Care was not requested
"RTN","RORX008A",48,0)
 . S CMPXCARE=0
"RTN","RORX008A",49,0)
 . S CLINAIDS=$S($$CLINAIDS^RORICRUT(RORIEN,ROREDT):1,1:0)
"RTN","RORX008A",50,0)
 . I CLINAIDS  Q:'$D(RORMODE("COMPLEX"))  S CMPXCARE=1
"RTN","RORX008A",51,0)
 . ;
"RTN","RORX008A",52,0)
 . ;--- Skip a patient without utlilization
"RTN","RORX008A",53,0)
 . Q:'$$UTIL^RORXU003(RORSDT,ROREDT,PATIEN,.UTLCHK)
"RTN","RORX008A",54,0)
 . ;
"RTN","RORX008A",55,0)
 . ;--- Search for pharmacy data
"RTN","RORX008A",56,0)
 . K RORXDST("ARV")
"RTN","RORX008A",57,0)
 . S TMP=$$RXSEARCH^RORUTL14(PATIEN,RORXL,.RORXDST,"EIOV",RORSDT,ROREDT1)
"RTN","RORX008A",58,0)
 . I TMP<0  S ECNT=ECNT+1  Q
"RTN","RORX008A",59,0)
 . I $D(RORXDST("ARV"))  Q:'$D(RORMODE("COMPLEX"))  D
"RTN","RORX008A",60,0)
 . . S IEN=0
"RTN","RORX008A",61,0)
 . . F  S IEN=$O(RORXDST("ARV",IEN))  Q:IEN'>0  D
"RTN","RORX008A",62,0)
 . . . D:'$D(^TMP("RORX008",$J,"DRG",IEN))
"RTN","RORX008A",63,0)
 . . . . S ^TMP("RORX008",$J,"DRG",IEN)=RORXDST("ARV",IEN)
"RTN","RORX008A",64,0)
 . . . S ^(CLINAIDS)=$G(^TMP("RORX008",$J,"DRG",IEN,CLINAIDS))+1
"RTN","RORX008A",65,0)
 . . S CMPXCARE=1,CNTARV=CNTARV+1
"RTN","RORX008A",66,0)
 . ;
"RTN","RORX008A",67,0)
 . ;--- Skip Basic Care if it was not requested
"RTN","RORX008A",68,0)
 . I CMPXCARE  S CNTCMPX=CNTCMPX+1
"RTN","RORX008A",69,0)
 . E  Q:'$D(RORMODE("BASIC"))  S CNTBASIC=CNTBASIC+1
"RTN","RORX008A",70,0)
 . ;
"RTN","RORX008A",71,0)
 . D:$D(ROROPT("PTLIST"))
"RTN","RORX008A",72,0)
 . . D VADEM^RORUTL05(PATIEN,1)
"RTN","RORX008A",73,0)
 . . S TMP=CLINAIDS_U_($D(RORXDST("ARV"))>0)_U_CMPXCARE
"RTN","RORX008A",74,0)
 . . S ^TMP("RORX008",$J,"PAT",PATIEN)=VA("BID")_U_VADM(1)_U_TMP
"RTN","RORX008A",75,0)
 ;
"RTN","RORX008A",76,0)
 ;--- Totals
"RTN","RORX008A",77,0)
 S ^TMP("RORX008",$J,"PAT")=CNTBASIC_U_CNTCMPX_U_CNTARV
"RTN","RORX008A",78,0)
 ;---
"RTN","RORX008A",79,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX008A",80,0)
 ;
"RTN","RORX008A",81,0)
 ;***** CALLBACK FUNCTION FOR THE PHARMACY SEARCH API
"RTN","RORX008A",82,0)
RXSCB(ROR8DST,ORDER,ORDFLG,DRUG,DATE) ;
"RTN","RORX008A",83,0)
 N CA,IEN,NAME
"RTN","RORX008A",84,0)
 S IEN=+ROR8DST("RORXGEN"),NAME=$P(ROR8DST("RORXGEN"),U,2)
"RTN","RORX008A",85,0)
 Q:(IEN'>0)!(NAME="") 1
"RTN","RORX008A",86,0)
 ;---
"RTN","RORX008A",87,0)
 S ROR8DST("ARV")=""  Q:ROR8DST("SINGLE") 2
"RTN","RORX008A",88,0)
 ;---
"RTN","RORX008A",89,0)
 S ROR8DST("ARV",IEN)=NAME
"RTN","RORX008A",90,0)
 Q 0
"RTN","RORX008A",91,0)
 ;
"RTN","RORX008A",92,0)
 ;***** STORES THE REPORT DATA
"RTN","RORX008A",93,0)
 ;
"RTN","RORX008A",94,0)
 ; REPORT        IEN of the REPORT element
"RTN","RORX008A",95,0)
 ;
"RTN","RORX008A",96,0)
 ; Return Values:
"RTN","RORX008A",97,0)
 ;       <0  Error code
"RTN","RORX008A",98,0)
 ;        0  Ok
"RTN","RORX008A",99,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX008A",100,0)
 ;
"RTN","RORX008A",101,0)
STORE(REPORT) ;
"RTN","RORX008A",102,0)
 N BUF,CNT,ITEM,IEN,NODE,NPAIDS,NPHIV,RC,TABLE,TMP
"RTN","RORX008A",103,0)
 S NODE=$NA(^TMP("RORX008",$J)),RC=0
"RTN","RORX008A",104,0)
 ;
"RTN","RORX008A",105,0)
 ;--- List of ARV drugs
"RTN","RORX008A",106,0)
 I $D(ROROPT("ARVSMRY")),$D(RORMODE("COMPLEX"))  D  Q:RC<0 RC
"RTN","RORX008A",107,0)
 . S TABLE=$$ADDVAL^RORTSK11(RORTSK,"DRUGS",,REPORT)
"RTN","RORX008A",108,0)
 . I TABLE<0  S RC=TABLE  Q
"RTN","RORX008A",109,0)
 . D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","DRUGS")
"RTN","RORX008A",110,0)
 . S IEN=0
"RTN","RORX008A",111,0)
 . F  S IEN=$O(@NODE@("DRG",IEN))  Q:IEN'>0  D
"RTN","RORX008A",112,0)
 . . S BUF=@NODE@("DRG",IEN)
"RTN","RORX008A",113,0)
 . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"DRUG",,TABLE)
"RTN","RORX008A",114,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NAME",$P(@NODE@("DRG",IEN),U),ITEM,1)
"RTN","RORX008A",115,0)
 . . S NPHIV=+$G(@NODE@("DRG",IEN,0))
"RTN","RORX008A",116,0)
 . . S NPAIDS=+$G(@NODE@("DRG",IEN,1))
"RTN","RORX008A",117,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NP",NPHIV+NPAIDS,ITEM,3)
"RTN","RORX008A",118,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NPHIV",NPHIV,ITEM,3)
"RTN","RORX008A",119,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NPAIDS",NPAIDS,ITEM,3)
"RTN","RORX008A",120,0)
 ;
"RTN","RORX008A",121,0)
 ;--- List of patients
"RTN","RORX008A",122,0)
 I $D(ROROPT("PTLIST"))  D  Q:RC<0 RC
"RTN","RORX008A",123,0)
 . S TABLE=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,REPORT)
"RTN","RORX008A",124,0)
 . I TABLE<0  S RC=TABLE  Q
"RTN","RORX008A",125,0)
 . D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","PATIENTS")
"RTN","RORX008A",126,0)
 . S IEN=0
"RTN","RORX008A",127,0)
 . F  S IEN=$O(@NODE@("PAT",IEN))  Q:IEN'>0  D
"RTN","RORX008A",128,0)
 . . S BUF=@NODE@("PAT",IEN)
"RTN","RORX008A",129,0)
 . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,TABLE,,IEN)
"RTN","RORX008A",130,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NAME",$P(BUF,U,2),ITEM,1)
"RTN","RORX008A",131,0)
 . . D ADDVAL^RORTSK11(RORTSK,"LAST4",$P(BUF,U),ITEM,2)
"RTN","RORX008A",132,0)
 . . D ADDVAL^RORTSK11(RORTSK,"AIDSTAT",+$P(BUF,U,3),ITEM,1)
"RTN","RORX008A",133,0)
 . . D ADDVAL^RORTSK11(RORTSK,"ARV",+$P(BUF,U,4),ITEM,1)
"RTN","RORX008A",134,0)
 . . D ADDVAL^RORTSK11(RORTSK,"COMPLEX",+$P(BUF,U,5),ITEM,1)
"RTN","RORX008A",135,0)
 ;
"RTN","RORX008A",136,0)
 ;--- Summary
"RTN","RORX008A",137,0)
 S BUF=@NODE@("PAT")
"RTN","RORX008A",138,0)
 S ITEM=$$ADDVAL^RORTSK11(RORTSK,"SUMMARY",,REPORT)
"RTN","RORX008A",139,0)
 D ADDVAL^RORTSK11(RORTSK,"NP",$P(BUF,U)+$P(BUF,U,2),ITEM)
"RTN","RORX008A",140,0)
 D ADDVAL^RORTSK11(RORTSK,"NPBASIC",+$P(BUF,U,1),ITEM)
"RTN","RORX008A",141,0)
 D ADDVAL^RORTSK11(RORTSK,"NPCOMPLEX",+$P(BUF,U,2),ITEM)
"RTN","RORX008A",142,0)
 D ADDVAL^RORTSK11(RORTSK,"NPARV",+$P(BUF,U,3),ITEM)
"RTN","RORX008A",143,0)
 Q 0
"RTN","RORX009")
0^166^B15466475
"RTN","RORX009",1,0)
RORX009 ;HCIOFO/SG - PHARMACY PRESCRIPTION UTILIZATION ; 1/12/04 3:16pm
"RTN","RORX009",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX009",3,0)
 ;
"RTN","RORX009",4,0)
 ;--------------------------------------------------------------------
"RTN","RORX009",5,0)
 ; Registry: [VA ICR]
"RTN","RORX009",6,0)
 ;--------------------------------------------------------------------
"RTN","RORX009",7,0)
 Q
"RTN","RORX009",8,0)
 ;
"RTN","RORX009",9,0)
 ;***** OUTPUTS THE REPORT HEADER
"RTN","RORX009",10,0)
 ;
"RTN","RORX009",11,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX009",12,0)
 ;
"RTN","RORX009",13,0)
 ; Return Values:
"RTN","RORX009",14,0)
 ;       <0  Error code
"RTN","RORX009",15,0)
 ;       >0  IEN of the HEADER element
"RTN","RORX009",16,0)
 ;
"RTN","RORX009",17,0)
HEADER(PARTAG) ;
"RTN","RORX009",18,0)
 ;;DOSES(NP,NRX)^I $D(RORMODE("INPATIENT"))
"RTN","RORX009",19,0)
 ;;DRUGS_DOSES(#,NAME,NP,NRX,MAXNRPP,MAXNP)
"RTN","RORX009",20,0)
 ;;DRUGS_FILLS(#,NAME,NP,NRX,MAXNRPP,MAXNP)
"RTN","RORX009",21,0)
 ;;FILLS(NP,NRX)^I $D(RORMODE("OUTPATIENT"))
"RTN","RORX009",22,0)
 ;;HU_DOSES(#,NAME,LAST4,NRX,ND)^I $D(RORMODE("INPATIENT"))
"RTN","RORX009",23,0)
 ;;HU_FILLS(#,NAME,LAST4,NRX,ND)^I $D(RORMODE("OUTPATIENT"))
"RTN","RORX009",24,0)
 ;
"RTN","RORX009",25,0)
 N HEADER,RC
"RTN","RORX009",26,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX009",27,0)
 Q:HEADER<0 HEADER
"RTN","RORX009",28,0)
 S RC=$$TBLDEF^RORXU002("HEADER^RORX009",HEADER)
"RTN","RORX009",29,0)
 Q $S(RC<0:RC,1:HEADER)
"RTN","RORX009",30,0)
 ;
"RTN","RORX009",31,0)
 ;***** OUTPUTS THE PARAMETERS TO THE REPORT
"RTN","RORX009",32,0)
 ;
"RTN","RORX009",33,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX009",34,0)
 ;
"RTN","RORX009",35,0)
 ; [.STDT]       Start and end dates of the report
"RTN","RORX009",36,0)
 ; [.ENDT]       are returned via these parameters
"RTN","RORX009",37,0)
 ;
"RTN","RORX009",38,0)
 ; [.FLAGS]      Flags for the $$SKIP^RORXU005 are
"RTN","RORX009",39,0)
 ;               returned via this parameter
"RTN","RORX009",40,0)
 ;
"RTN","RORX009",41,0)
 ; Return Values:
"RTN","RORX009",42,0)
 ;       <0  Error code
"RTN","RORX009",43,0)
 ;       >0  IEN of the PARAMETERS element
"RTN","RORX009",44,0)
 ;
"RTN","RORX009",45,0)
PARAMS(PARTAG,STDT,ENDT,FLAGS) ;
"RTN","RORX009",46,0)
 N PARAMS,TMP
"RTN","RORX009",47,0)
 S PARAMS=$$PARAMS^RORXU002(.RORTSK,PARTAG,.STDT,.ENDT,.FLAGS)
"RTN","RORX009",48,0)
 Q:PARAMS<0 PARAMS
"RTN","RORX009",49,0)
 ;--- Compile the list of drugs and process options
"RTN","RORX009",50,0)
 S TMP=$NA(^TMP("RORX009D",$J))
"RTN","RORX009",51,0)
 S RORLRX=$$COMBRXL^RORXU007(.RORTSK,PARAMS,TMP,.RORXOPT,.RORVCOPT)
"RTN","RORX009",52,0)
 Q:RORLRX<0 RORLRX
"RTN","RORX009",53,0)
 ;--- Additional parameters
"RTN","RORX009",54,0)
 F NAME="MAXUTNUM"  D
"RTN","RORX009",55,0)
 . S TMP=$$PARAM^RORTSK01(NAME)
"RTN","RORX009",56,0)
 . D:TMP'="" ADDVAL^RORTSK11(RORTSK,NAME,TMP,PARAMS)
"RTN","RORX009",57,0)
 ;---
"RTN","RORX009",58,0)
 Q PARAMS
"RTN","RORX009",59,0)
 ;
"RTN","RORX009",60,0)
 ;***** COMPILES THE "PHARMACY PRESCRIPTION UTILIZATION" REPORT
"RTN","RORX009",61,0)
 ; REPORT CODE: 009
"RTN","RORX009",62,0)
 ;
"RTN","RORX009",63,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORX009",64,0)
 ;
"RTN","RORX009",65,0)
 ; The ^TMP("RORX009",$J) global node is used by this function.
"RTN","RORX009",66,0)
 ;
"RTN","RORX009",67,0)
 ; ^TMP("RORX009",$J,
"RTN","RORX009",68,0)
 ;   CatSub,             ("HIV", "AIDS", or "ALLCATS")
"RTN","RORX009",69,0)
 ;
"RTN","RORX009",70,0)
 ;     "IP",             Number of inpatients
"RTN","RORX009",71,0)
 ;       DFN,            Patient's data
"RTN","RORX009",72,0)
 ;                         ^01: Last 4 digits of SSN
"RTN","RORX009",73,0)
 ;                         ^02: Name
"RTN","RORX009",74,0)
 ;                         ^03: Total number of doses
"RTN","RORX009",75,0)
 ;                         ^04: Number of different drugs
"RTN","RORX009",76,0)
 ;         "D",
"RTN","RORX009",77,0)
 ;           DrugIEN)    Quantity
"RTN","RORX009",78,0)
 ;
"RTN","RORX009",79,0)
 ;     "IPD",            Number of different drugs
"RTN","RORX009",80,0)
 ;       DrugIEN,        Drug Name
"RTN","RORX009",81,0)
 ;         "D")          Number of doses
"RTN","RORX009",82,0)
 ;         "M")          Maximum
"RTN","RORX009",83,0)
 ;                         ^01: Maximum number of doses
"RTN","RORX009",84,0)
 ;                         ^02: Number of patients
"RTN","RORX009",85,0)
 ;         "P")          Number of patients
"RTN","RORX009",86,0)
 ;       "B",
"RTN","RORX009",87,0)
 ;         NumOfDoses,
"RTN","RORX009",88,0)
 ;           DrugName,
"RTN","RORX009",89,0)
 ;             DrugIEN)  ""
"RTN","RORX009",90,0)
 ;
"RTN","RORX009",91,0)
 ;     "IPRX",           Total number of doses
"RTN","RORX009",92,0)
 ;       NumOfDoses,     Number of patients
"RTN","RORX009",93,0)
 ;         PatientName,
"RTN","RORX009",94,0)
 ;           DFN)        ""
"RTN","RORX009",95,0)
 ;
"RTN","RORX009",96,0)
 ;     "OP",             Number of outpatients
"RTN","RORX009",97,0)
 ;       DFN,            Patient's data
"RTN","RORX009",98,0)
 ;                         ^01: Last 4 digits of SSN
"RTN","RORX009",99,0)
 ;                         ^02: Name
"RTN","RORX009",100,0)
 ;                         ^03: Total number of fills
"RTN","RORX009",101,0)
 ;                         ^04: Number of different drugs
"RTN","RORX009",102,0)
 ;         "D",
"RTN","RORX009",103,0)
 ;           DrugIEN)    Quantity
"RTN","RORX009",104,0)
 ;
"RTN","RORX009",105,0)
 ;     "OPD",            Number of different drugs
"RTN","RORX009",106,0)
 ;       DrugIEN,        Drug Name
"RTN","RORX009",107,0)
 ;         "D")          Number of fills
"RTN","RORX009",108,0)
 ;         "M")          Maximum
"RTN","RORX009",109,0)
 ;                         ^01: Maximum number of fills
"RTN","RORX009",110,0)
 ;                         ^02: Number of patients
"RTN","RORX009",111,0)
 ;         "P")          Number of patients
"RTN","RORX009",112,0)
 ;       "B",
"RTN","RORX009",113,0)
 ;         NumOfFills,
"RTN","RORX009",114,0)
 ;           DrugName,
"RTN","RORX009",115,0)
 ;             DrugIEN)  ""
"RTN","RORX009",116,0)
 ;
"RTN","RORX009",117,0)
 ;     "OPRX",           Total number of fills
"RTN","RORX009",118,0)
 ;       NumOfFills,     Number of patients
"RTN","RORX009",119,0)
 ;         PatientName,
"RTN","RORX009",120,0)
 ;           DFN)        ""
"RTN","RORX009",121,0)
 ;
"RTN","RORX009",122,0)
 ; Return Values:
"RTN","RORX009",123,0)
 ;       <0  Error code
"RTN","RORX009",124,0)
 ;        0  Ok
"RTN","RORX009",125,0)
 ;
"RTN","RORX009",126,0)
RXUTIL(RORTSK) ;
"RTN","RORX009",127,0)
 N ROREDT        ; End date
"RTN","RORX009",128,0)
 N RORLRX        ; List of drugs for the pharmacy search API
"RTN","RORX009",129,0)
 N RORMODE       ; Subset of patients to be selected
"RTN","RORX009",130,0)
 N ROROPT        ; Report options
"RTN","RORX009",131,0)
 N RORREG        ; Registry IEN
"RTN","RORX009",132,0)
 N RORSDT        ; Start date
"RTN","RORX009",133,0)
 N RORVCOPT      ; Drug class options
"RTN","RORX009",134,0)
 N RORXOPT       ; Drug options
"RTN","RORX009",135,0)
 ;
"RTN","RORX009",136,0)
 N ECNT,RC,REPORT,SFLAGS,TMP
"RTN","RORX009",137,0)
 S (ECNT,RC)=0
"RTN","RORX009",138,0)
 K ^TMP("RORX009",$J)
"RTN","RORX009",139,0)
 ;--- Root node of the report
"RTN","RORX009",140,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX009",141,0)
 Q:REPORT<0 REPORT
"RTN","RORX009",142,0)
 ;
"RTN","RORX009",143,0)
 ;--- Get and prepare the report parameters
"RTN","RORX009",144,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")
"RTN","RORX009",145,0)
 S RC=$$PARAMS(REPORT,.RORSDT,.ROREDT,.SFLAGS)  Q:RC<0 RC
"RTN","RORX009",146,0)
 S RORMODE=$$PARAM^RORTSK01("PATIENTS")
"RTN","RORX009",147,0)
 D LIST^RORXU002(.RORMODE)
"RTN","RORX009",148,0)
 S ROROPT=$$PARAM^RORTSK01("OPTIONS")
"RTN","RORX009",149,0)
 D LIST^RORXU002(.ROROPT)
"RTN","RORX009",150,0)
 ;
"RTN","RORX009",151,0)
 ;--- Report header
"RTN","RORX009",152,0)
 S RC=$$HEADER(REPORT)  Q:RC<0 RC
"RTN","RORX009",153,0)
 ;
"RTN","RORX009",154,0)
 D
"RTN","RORX009",155,0)
 . ;--- Query the registry
"RTN","RORX009",156,0)
 . D TPPSETUP^RORTSK01(75)
"RTN","RORX009",157,0)
 . S RC=$$QUERY^RORX009A(SFLAGS_"DI")
"RTN","RORX009",158,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX009",159,0)
 . ;--- Sort the data
"RTN","RORX009",160,0)
 . D TPPSETUP^RORTSK01(10)
"RTN","RORX009",161,0)
 . S RC=$$SORT^RORX009A()
"RTN","RORX009",162,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX009",163,0)
 . ;--- Store the results
"RTN","RORX009",164,0)
 . D TPPSETUP^RORTSK01(15)
"RTN","RORX009",165,0)
 . S RC=$$STORE^RORX009C(REPORT)
"RTN","RORX009",166,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX009",167,0)
 ;
"RTN","RORX009",168,0)
 ;--- Cleanup
"RTN","RORX009",169,0)
 K ^TMP("RORX009",$J),^TMP("RORX009D",$J)
"RTN","RORX009",170,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX009A")
0^175^B38249020
"RTN","RORX009A",1,0)
RORX009A ;HCIOFO/SG - PRESCRIPTION UTILIZ. (QUERY & SORT) ; 12/9/03 1:01pm
"RTN","RORX009A",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX009A",3,0)
 ;
"RTN","RORX009A",4,0)
 Q
"RTN","RORX009A",5,0)
 ;
"RTN","RORX009A",6,0)
 ;***** QUERIES THE REGISTRY
"RTN","RORX009A",7,0)
 ;
"RTN","RORX009A",8,0)
 ; FLAGS         Flags for the $$SKIP^RORXU005
"RTN","RORX009A",9,0)
 ;
"RTN","RORX009A",10,0)
 ; Return Values:
"RTN","RORX009A",11,0)
 ;       <0  Error code
"RTN","RORX009A",12,0)
 ;        0  Ok
"RTN","RORX009A",13,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX009A",14,0)
 ;
"RTN","RORX009A",15,0)
QUERY(FLAGS) ;
"RTN","RORX009A",16,0)
 N ROREDT1       ; Day after the end date
"RTN","RORX009A",17,0)
 N RORPTN        ; Number of patients in the registry
"RTN","RORX009A",18,0)
 ;
"RTN","RORX009A",19,0)
 N CATSUB,CNT,ECNT,IEN,IENS,PATIEN,RC,RORXDST,RXFLAGS,TMP,XREFNODE
"RTN","RORX009A",20,0)
 S XREFNODE=$NA(^RORDATA(798,"AC",+RORREG))
"RTN","RORX009A",21,0)
 S RORPTN=$$REGSIZE^RORUTL02(+RORREG)  S:RORPTN<0 RORPTN=0
"RTN","RORX009A",22,0)
 S ROREDT1=$$FMADD^XLFDT(ROREDT,1)
"RTN","RORX009A",23,0)
 S (CNT,ECNT,RC)=0
"RTN","RORX009A",24,0)
 ;
"RTN","RORX009A",25,0)
 ;--- Prepare parameters for the pharmacy search API
"RTN","RORX009A",26,0)
 S RORXDST("RORCB")="$$RXSCB^RORX009A"
"RTN","RORX009A",27,0)
 S RORXDST("GENERIC")=($D(RORXOPT("GENERIC"))>0)
"RTN","RORX009A",28,0)
 S RXFLAGS="E"
"RTN","RORX009A",29,0)
 S:$D(RORMODE("INPATIENT")) RXFLAGS=RXFLAGS_"IV"
"RTN","RORX009A",30,0)
 S:$D(RORMODE("OUTPATIENT")) RXFLAGS=RXFLAGS_"O"
"RTN","RORX009A",31,0)
 Q:RXFLAGS="E" 0
"RTN","RORX009A",32,0)
 ;
"RTN","RORX009A",33,0)
 ;--- Browse through the registry records
"RTN","RORX009A",34,0)
 S IEN=0
"RTN","RORX009A",35,0)
 F  S IEN=$O(@XREFNODE@(IEN))  Q:IEN'>0  D  Q:RC<0
"RTN","RORX009A",36,0)
 . S TMP=$S(RORPTN>0:CNT/RORPTN,1:"")
"RTN","RORX009A",37,0)
 . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX009A",38,0)
 . S IENS=IEN_",",CNT=CNT+1
"RTN","RORX009A",39,0)
 . ;--- Check if the patient should be skipped
"RTN","RORX009A",40,0)
 . Q:$$SKIP^RORXU005(IEN,FLAGS,RORSDT,ROREDT)
"RTN","RORX009A",41,0)
 . ;
"RTN","RORX009A",42,0)
 . ;--- Get the patient IEN (DFN)
"RTN","RORX009A",43,0)
 . S PATIEN=$$PTIEN^RORUTL01(IEN)  Q:PATIEN'>0
"RTN","RORX009A",44,0)
 . ;
"RTN","RORX009A",45,0)
 . ;--- Get the category subscript
"RTN","RORX009A",46,0)
 . S TMP=$$CLINAIDS^RORICRUT(IEN,ROREDT)
"RTN","RORX009A",47,0)
 . Q:'$D(RORMODE($S(TMP:"AIDS",1:"HIV")))
"RTN","RORX009A",48,0)
 . S CATSUB=$S(TMP:"AIDS",1:"HIV")
"RTN","RORX009A",49,0)
 . ;
"RTN","RORX009A",50,0)
 . ;--- Search the pharmacy data
"RTN","RORX009A",51,0)
 . S RORXDST=$NA(^TMP("RORX009",$J,CATSUB))
"RTN","RORX009A",52,0)
 . S TMP=$$RXSEARCH^RORUTL14(PATIEN,RORLRX,.RORXDST,RXFLAGS,RORSDT,ROREDT1)
"RTN","RORX009A",53,0)
 . I TMP<0  S ECNT=ECNT+1  Q
"RTN","RORX009A",54,0)
 . ;--- Skip the patient if no data has been found
"RTN","RORX009A",55,0)
 . I '$D(@RORXDST@("IP",PATIEN)),'$D(@RORXDST@("OP",PATIEN))  Q
"RTN","RORX009A",56,0)
 . ;
"RTN","RORX009A",57,0)
 . ;--- Calculate intermediate totals
"RTN","RORX009A",58,0)
 . S RC=$$TOTALS(PATIEN,CATSUB)
"RTN","RORX009A",59,0)
 . I RC  S ECNT=ECNT+1  Q:RC<0
"RTN","RORX009A",60,0)
 ;---
"RTN","RORX009A",61,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX009A",62,0)
 ;
"RTN","RORX009A",63,0)
 ;***** CALLBACK FUNCTION FOR THE PHARMACY SEARCH API
"RTN","RORX009A",64,0)
RXSCB(ROR8DST,ORDER,ORDFLG,DRUG,DATE) ;
"RTN","RORX009A",65,0)
 N DRUGIEN,DRUGNAME,IRP,RPS,RXCNT,SUBS,TMP
"RTN","RORX009A",66,0)
 I ROR8DST("GENERIC")  D
"RTN","RORX009A",67,0)
 . S DRUGIEN=+ROR8DST("RORXGEN"),DRUGNAME=$P(ROR8DST("RORXGEN"),U,2)
"RTN","RORX009A",68,0)
 E  S DRUGIEN=+DRUG,DRUGNAME=$P(DRUG,U,2)
"RTN","RORX009A",69,0)
 Q:(DRUGIEN'>0)!(DRUGNAME="") 1
"RTN","RORX009A",70,0)
 S SUBS=$S(ORDFLG["I":"IP",ORDFLG["O":"OP",1:"")  Q:SUBS="" 1
"RTN","RORX009A",71,0)
 ;--- Count the original order, refills and partials
"RTN","RORX009A",72,0)
 S RXCNT=0
"RTN","RORX009A",73,0)
 S:(DATE'<ROR8DST("RORSDT"))&(DATE<ROR8DST("ROREDT")) RXCNT=RXCNT+1
"RTN","RORX009A",74,0)
 F RPS="PAR","REF"  S IRP=0  D
"RTN","RORX009A",75,0)
 . F  S IRP=$O(^TMP("PS",$J,RPS,IRP))  Q:IRP'>0  S RXCNT=RXCNT+1
"RTN","RORX009A",76,0)
 ;--- Update the counters
"RTN","RORX009A",77,0)
 D:RXCNT>0
"RTN","RORX009A",78,0)
 . S TMP=$G(@ROR8DST@(SUBS,+ROR8DST("RORDFN"),"D",DRUGIEN))
"RTN","RORX009A",79,0)
 . S @ROR8DST@(SUBS,+ROR8DST("RORDFN"),"D",DRUGIEN)=TMP+RXCNT
"RTN","RORX009A",80,0)
 . S TMP=SUBS_"D"
"RTN","RORX009A",81,0)
 . S:'$D(@ROR8DST@(TMP,DRUGIEN)) @ROR8DST@(TMP,DRUGIEN)=DRUGNAME
"RTN","RORX009A",82,0)
 Q 0
"RTN","RORX009A",83,0)
 ;
"RTN","RORX009A",84,0)
 ;***** SORTS THE RESULTS AND COMPILES THE TOTALS
"RTN","RORX009A",85,0)
 ;
"RTN","RORX009A",86,0)
 ; Return Values:
"RTN","RORX009A",87,0)
 ;       <0  Error code
"RTN","RORX009A",88,0)
 ;        0  Ok
"RTN","RORX009A",89,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX009A",90,0)
 ;
"RTN","RORX009A",91,0)
SORT() ;
"RTN","RORX009A",92,0)
 N CATSUB,ECNT,FSUM,NODE,NSUB,RC,RORI,RORSUM,TMP
"RTN","RORX009A",93,0)
 S (ECNT,RC)=0
"RTN","RORX009A",94,0)
 S RORSUM=$NA(^TMP("RORX009",$J,$P($$CAT^RORICRUT(1),U)))
"RTN","RORX009A",95,0)
 S NSUB=$$NCAT^RORICRUT
"RTN","RORX009A",96,0)
 ;---
"RTN","RORX009A",97,0)
 F RORI=NSUB:-1:1  D  Q:RC<0
"RTN","RORX009A",98,0)
 . S RC=$$LOOP^RORTSK01((NSUB-RORI)/NSUB)  Q:RC<0
"RTN","RORX009A",99,0)
 . S CATSUB=$P($$CAT^RORICRUT(RORI),U)
"RTN","RORX009A",100,0)
 . S NODE=$NA(^TMP("RORX009",$J,CATSUB))
"RTN","RORX009A",101,0)
 . Q:$D(@NODE)<10
"RTN","RORX009A",102,0)
 . S FSUM=$D(RORMODE("AIDS"))&$D(RORMODE("HIV"))&(RORI'=1)
"RTN","RORX009A",103,0)
 . ;---
"RTN","RORX009A",104,0)
 . D SORT1(NODE,"IP",FSUM)
"RTN","RORX009A",105,0)
 . S RC=$$LOOP^RORTSK01()  Q:RC<0
"RTN","RORX009A",106,0)
 . D SORT1(NODE,"OP",FSUM)
"RTN","RORX009A",107,0)
 ;---
"RTN","RORX009A",108,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX009A",109,0)
 ;
"RTN","RORX009A",110,0)
 ;***** SORTS THE DATA NAD CALCULATES THE TOTALS
"RTN","RORX009A",111,0)
 ;
"RTN","RORX009A",112,0)
 ; NODE          Closed root of the category section
"RTN","RORX009A",113,0)
 ;               in the temporary global
"RTN","RORX009A",114,0)
 ;
"RTN","RORX009A",115,0)
 ; SUBS          Base subscript ("IP" or "OP")
"RTN","RORX009A",116,0)
 ;
"RTN","RORX009A",117,0)
 ; FSUM          Update the summary data (0/1)
"RTN","RORX009A",118,0)
 ;
"RTN","RORX009A",119,0)
SORT1(NODE,SUBS,FSUM) ;
"RTN","RORX009A",120,0)
 N DFN,I,IEN,NDRUGS,RXS,TMP
"RTN","RORX009A",121,0)
 D SORTRX(NODE,SUBS_"D",FSUM)
"RTN","RORX009A",122,0)
 Q:'FSUM
"RTN","RORX009A",123,0)
 ;--- Number of patients
"RTN","RORX009A",124,0)
 S TMP=$G(@RORSUM@(SUBS))
"RTN","RORX009A",125,0)
 M @RORSUM@(SUBS)=@NODE@(SUBS)
"RTN","RORX009A",126,0)
 S @RORSUM@(SUBS)=TMP+$G(@NODE@(SUBS))
"RTN","RORX009A",127,0)
 ;--- Number of fills/doses
"RTN","RORX009A",128,0)
 S RXS=SUBS_"RX"
"RTN","RORX009A",129,0)
 S I=""
"RTN","RORX009A",130,0)
 F  S I=$O(@NODE@(RXS,I))  Q:I=""  D
"RTN","RORX009A",131,0)
 . S TMP=$G(@RORSUM@(RXS,I))
"RTN","RORX009A",132,0)
 . M @RORSUM@(RXS,I)=@NODE@(RXS,I)
"RTN","RORX009A",133,0)
 . S @RORSUM@(RXS,I)=TMP+$G(@NODE@(RXS,I))
"RTN","RORX009A",134,0)
 S @RORSUM@(RXS)=$G(@RORSUM@(RXS))+$G(@NODE@(RXS))
"RTN","RORX009A",135,0)
 Q
"RTN","RORX009A",136,0)
 ;
"RTN","RORX009A",137,0)
 ;***** SORTS THE DRUG LIST
"RTN","RORX009A",138,0)
 ;
"RTN","RORX009A",139,0)
 ; NODE          Closed root of the category section
"RTN","RORX009A",140,0)
 ;               in the temporary global
"RTN","RORX009A",141,0)
 ;
"RTN","RORX009A",142,0)
 ; SUBS          Drug list subscript ("IPD" or "OPD")
"RTN","RORX009A",143,0)
 ;
"RTN","RORX009A",144,0)
 ; FSUM          Update the summary data (0/1)
"RTN","RORX009A",145,0)
 ;
"RTN","RORX009A",146,0)
SORTRX(NODE,SUBS,FSUM) ;
"RTN","RORX009A",147,0)
 N I,IEN,NAME,NDRUGS,SUM,TMP
"RTN","RORX009A",148,0)
 S IEN=0,NDRUGS=0
"RTN","RORX009A",149,0)
 F  S IEN=$O(@NODE@(SUBS,IEN))  Q:IEN'>0  D
"RTN","RORX009A",150,0)
 . S NAME=@NODE@(SUBS,IEN),NDRUGS=NDRUGS+1
"RTN","RORX009A",151,0)
 . S TMP=+$G(@NODE@(SUBS,IEN,"D"))
"RTN","RORX009A",152,0)
 . S @NODE@(SUBS,"B",TMP,NAME,IEN)=""
"RTN","RORX009A",153,0)
 . Q:'FSUM
"RTN","RORX009A",154,0)
 . S @RORSUM@(SUBS,IEN)=NAME
"RTN","RORX009A",155,0)
 . ;--- Numbers of patients and doses/fills
"RTN","RORX009A",156,0)
 . F I="P","D"  S TMP=$G(@NODE@(SUBS,IEN,I))  D:TMP>0
"RTN","RORX009A",157,0)
 . . S @RORSUM@(SUBS,IEN,I)=$G(@RORSUM@(SUBS,IEN,I))+TMP
"RTN","RORX009A",158,0)
 . ;--- Maximum number of doses/fills per patient
"RTN","RORX009A",159,0)
 . S TMP=$G(@NODE@(SUBS,IEN,"M"))
"RTN","RORX009A",160,0)
 . S SUM=$G(@RORSUM@(SUBS,IEN,"M"))
"RTN","RORX009A",161,0)
 . D:TMP'<SUM
"RTN","RORX009A",162,0)
 . . I TMP>SUM  S @RORSUM@(SUBS,IEN,"M")=TMP  Q
"RTN","RORX009A",163,0)
 . . S $P(@RORSUM@(SUBS,IEN,"M"),U,2)=$P(SUM,U,2)+$P(TMP,U,2)
"RTN","RORX009A",164,0)
 ;--- Numbers of different drugs
"RTN","RORX009A",165,0)
 S @NODE@(SUBS)=NDRUGS
"RTN","RORX009A",166,0)
 Q
"RTN","RORX009A",167,0)
 ;
"RTN","RORX009A",168,0)
 ;***** CALCULATES THE INTERMEDIATE TOTALS
"RTN","RORX009A",169,0)
 ;
"RTN","RORX009A",170,0)
 ; PATIEN        Patient IEN (DFN)
"RTN","RORX009A",171,0)
 ; CATSUB        Category subscript in the temporary global
"RTN","RORX009A",172,0)
 ;
"RTN","RORX009A",173,0)
 ; Return Values:
"RTN","RORX009A",174,0)
 ;       <0  Error code
"RTN","RORX009A",175,0)
 ;        0  Ok
"RTN","RORX009A",176,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX009A",177,0)
 ;
"RTN","RORX009A",178,0)
TOTALS(PATIEN,CATSUB) ;
"RTN","RORX009A",179,0)
 N IEN,LAST4,NDRUGS,NODE,NRX,PTNAME,PTNRX,RXS,SUBS,TMP,VA,VADM,VAERR
"RTN","RORX009A",180,0)
 S NODE=$NA(^TMP("RORX009",$J,CATSUB))
"RTN","RORX009A",181,0)
 ;--- Get the patient's data
"RTN","RORX009A",182,0)
 D VADEM^RORUTL05(PATIEN,1)
"RTN","RORX009A",183,0)
 S PTNAME=VADM(1),LAST4=VA("BID")
"RTN","RORX009A",184,0)
 ;---
"RTN","RORX009A",185,0)
 F SUBS="IP","OP"  D:$D(@NODE@(SUBS,PATIEN))>1
"RTN","RORX009A",186,0)
 . S RXS=SUBS_"D"
"RTN","RORX009A",187,0)
 . S IEN=0,(NDRUGS,PTNRX)=0
"RTN","RORX009A",188,0)
 . F  S IEN=$O(@NODE@(SUBS,PATIEN,"D",IEN))  Q:IEN'>0  D
"RTN","RORX009A",189,0)
 . . S NRX=@NODE@(SUBS,PATIEN,"D",IEN)
"RTN","RORX009A",190,0)
 . . S NDRUGS=NDRUGS+1,PTNRX=PTNRX+NRX
"RTN","RORX009A",191,0)
 . . ;---
"RTN","RORX009A",192,0)
 . . S @NODE@(RXS,IEN,"D")=$G(@NODE@(RXS,IEN,"D"))+NRX
"RTN","RORX009A",193,0)
 . . S @NODE@(RXS,IEN,"P")=$G(@NODE@(RXS,IEN,"P"))+1
"RTN","RORX009A",194,0)
 . . ;---
"RTN","RORX009A",195,0)
 . . S TMP=$G(@NODE@(RXS,IEN,"M"))
"RTN","RORX009A",196,0)
 . . D:NRX'<TMP
"RTN","RORX009A",197,0)
 . . . I NRX>TMP  S @NODE@(RXS,IEN,"M")=NRX_U_1  Q
"RTN","RORX009A",198,0)
 . . . S $P(@NODE@(RXS,IEN,"M"),U,2)=$P(TMP,U,2)+1
"RTN","RORX009A",199,0)
 . ;---
"RTN","RORX009A",200,0)
 . S @NODE@(SUBS)=$G(@NODE@(SUBS))+1
"RTN","RORX009A",201,0)
 . S @NODE@(SUBS,PATIEN)=LAST4_U_PTNAME_U_PTNRX_U_NDRUGS
"RTN","RORX009A",202,0)
 . ;---
"RTN","RORX009A",203,0)
 . S RXS=SUBS_"RX"
"RTN","RORX009A",204,0)
 . S @NODE@(RXS)=$G(@NODE@(RXS))+PTNRX
"RTN","RORX009A",205,0)
 . S @NODE@(RXS,PTNRX)=$G(@NODE@(RXS,PTNRX))+1
"RTN","RORX009A",206,0)
 . S @NODE@(RXS,PTNRX,PTNAME,PATIEN)=""
"RTN","RORX009A",207,0)
 ;---
"RTN","RORX009A",208,0)
 Q 0
"RTN","RORX009C")
0^176^B39303150
"RTN","RORX009C",1,0)
RORX009C ;HCIOFO/SG - PRESCRIPTION UTILIZ. (STORE) ; 1/12/04 3:21pm
"RTN","RORX009C",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX009C",3,0)
 ;
"RTN","RORX009C",4,0)
 Q
"RTN","RORX009C",5,0)
 ;
"RTN","RORX009C",6,0)
 ;***** DRUGS
"RTN","RORX009C",7,0)
 ;
"RTN","RORX009C",8,0)
 ; SECTION       IEN of the parent element
"RTN","RORX009C",9,0)
 ;
"RTN","RORX009C",10,0)
 ; SUBS
"RTN","RORX009C",11,0)
 ;
"RTN","RORX009C",12,0)
 ; NODE          Closed root of the category section
"RTN","RORX009C",13,0)
 ;               in the temporary global
"RTN","RORX009C",14,0)
 ;
"RTN","RORX009C",15,0)
 ; TBLNAME
"RTN","RORX009C",16,0)
 ;
"RTN","RORX009C",17,0)
 ; Return Values:
"RTN","RORX009C",18,0)
 ;       <0  Error code
"RTN","RORX009C",19,0)
 ;        0  Ok
"RTN","RORX009C",20,0)
 ;
"RTN","RORX009C",21,0)
DRUGS(SECTION,SUBS,NODE,TBLNAME) ;
"RTN","RORX009C",22,0)
 Q:$D(@NODE@(SUBS))<10 0
"RTN","RORX009C",23,0)
 N IEN,ITEM,NAME,NUM,RC,TMP
"RTN","RORX009C",24,0)
 S TABLE=$$ADDVAL^RORTSK11(RORTSK,"DRUGS",,SECTION)
"RTN","RORX009C",25,0)
 Q:TABLE<0 TABLE
"RTN","RORX009C",26,0)
 D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE",TBLNAME)
"RTN","RORX009C",27,0)
 ;---
"RTN","RORX009C",28,0)
 S NUM="",RC=0
"RTN","RORX009C",29,0)
 F  S NUM=$O(@NODE@(SUBS,"B",NUM),-1)  Q:NUM=""  D  Q:RC
"RTN","RORX009C",30,0)
 . S NAME=""
"RTN","RORX009C",31,0)
 . F  S NAME=$O(@NODE@(SUBS,"B",NUM,NAME))  Q:NAME=""  D  Q:RC
"RTN","RORX009C",32,0)
 . . S IEN=""
"RTN","RORX009C",33,0)
 . . F  S IEN=$O(@NODE@(SUBS,"B",NUM,NAME,IEN))  Q:IEN=""  D  Q:RC
"RTN","RORX009C",34,0)
 . . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"DRUG",,TABLE)
"RTN","RORX009C",35,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NAME",NAME,ITEM,1)
"RTN","RORX009C",36,0)
 . . . S TMP=+$G(@NODE@(SUBS,IEN,"P"))
"RTN","RORX009C",37,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NP",TMP,ITEM,3)
"RTN","RORX009C",38,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NRX",NUM,ITEM,3)
"RTN","RORX009C",39,0)
 . . . S TMP=$G(@NODE@(SUBS,IEN,"M"))
"RTN","RORX009C",40,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"MAXNRPP",+$P(TMP,U),ITEM,3)
"RTN","RORX009C",41,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"MAXNP",+$P(TMP,U,2),ITEM,3)
"RTN","RORX009C",42,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORX009C",43,0)
 ;
"RTN","RORX009C",44,0)
 ;***** STORES THE REPORT DATA
"RTN","RORX009C",45,0)
 ;
"RTN","RORX009C",46,0)
 ; REPORT        IEN of the REPORT element
"RTN","RORX009C",47,0)
 ;
"RTN","RORX009C",48,0)
 ; Return Values:
"RTN","RORX009C",49,0)
 ;       <0  Error code
"RTN","RORX009C",50,0)
 ;        0  Ok
"RTN","RORX009C",51,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX009C",52,0)
 ;
"RTN","RORX009C",53,0)
STORE(REPORT) ;
"RTN","RORX009C",54,0)
 N RORSONLY      ; Output summary only
"RTN","RORX009C",55,0)
 ;
"RTN","RORX009C",56,0)
 N CATEGORY,CATHDR,CATSUB,ECNT,NODE,NSUB,RC,RORI,TMP
"RTN","RORX009C",57,0)
 S RORSONLY=$$SMRYONLY^RORXU006()
"RTN","RORX009C",58,0)
 S NSUB=$$NCAT^RORICRUT
"RTN","RORX009C",59,0)
 S (ECNT,RC)=0
"RTN","RORX009C",60,0)
 ;--- Tables
"RTN","RORX009C",61,0)
 F RORI=NSUB:-1:1  D  Q:RC<0
"RTN","RORX009C",62,0)
 . S RC=$$LOOP^RORTSK01((NSUB-RORI)/3)  Q:RC<0
"RTN","RORX009C",63,0)
 . S TMP=$$CAT^RORICRUT(RORI),CATSUB=$P(TMP,U),CATHDR=$P(TMP,U,2)
"RTN","RORX009C",64,0)
 . S NODE=$NA(^TMP("RORX009",$J,CATSUB))
"RTN","RORX009C",65,0)
 . Q:$D(@NODE)<10
"RTN","RORX009C",66,0)
 . ;--- Category
"RTN","RORX009C",67,0)
 . S CATEGORY=$$ADDVAL^RORTSK11(RORTSK,"CATEGORY",,REPORT)
"RTN","RORX009C",68,0)
 . D ADDVAL^RORTSK11(RORTSK,"NAME",CATHDR,CATEGORY)
"RTN","RORX009C",69,0)
 . ;---
"RTN","RORX009C",70,0)
 . S RC=$$STOREOP(CATEGORY,NODE)
"RTN","RORX009C",71,0)
 . I RC  Q:RC<0  S ECNT=ECNT+1
"RTN","RORX009C",72,0)
 . S RC=$$STOREIP(CATEGORY,NODE)
"RTN","RORX009C",73,0)
 . I RC  Q:RC<0  S ECNT=ECNT+1
"RTN","RORX009C",74,0)
 ;---
"RTN","RORX009C",75,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX009C",76,0)
 ;
"RTN","RORX009C",77,0)
 ;***** INPATIENT DATA
"RTN","RORX009C",78,0)
 ;
"RTN","RORX009C",79,0)
 ; CATEGORY      IEN of the CATEGORY element
"RTN","RORX009C",80,0)
 ;
"RTN","RORX009C",81,0)
 ; NODE          Closed root of the category section
"RTN","RORX009C",82,0)
 ;               in the temporary global
"RTN","RORX009C",83,0)
 ;
"RTN","RORX009C",84,0)
 ; Return Values:
"RTN","RORX009C",85,0)
 ;       <0  Error code
"RTN","RORX009C",86,0)
 ;        0  Ok
"RTN","RORX009C",87,0)
 ;
"RTN","RORX009C",88,0)
STOREIP(CATEGORY,NODE) ;
"RTN","RORX009C",89,0)
 Q:$D(@NODE@("IP"))<10 0
"RTN","RORX009C",90,0)
 N COUNT,DFN,ITEM,MAXUTNUM,NAME,NRX,RC,SECTION,TABLE,TMP
"RTN","RORX009C",91,0)
 S MAXUTNUM=$$PARAM^RORTSK01("MAXUTNUM")
"RTN","RORX009C",92,0)
 S SECTION=$$ADDVAL^RORTSK11(RORTSK,"INPATIENTS",,CATEGORY)
"RTN","RORX009C",93,0)
 Q:SECTION<0 SECTION
"RTN","RORX009C",94,0)
 S RC=0
"RTN","RORX009C",95,0)
 ;--- Number of doses
"RTN","RORX009C",96,0)
 S TABLE=$$ADDVAL^RORTSK11(RORTSK,"DOSES",,SECTION)
"RTN","RORX009C",97,0)
 Q:TABLE<0 TABLE
"RTN","RORX009C",98,0)
 D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","DOSES")
"RTN","RORX009C",99,0)
 S NRX=""
"RTN","RORX009C",100,0)
 F  S NRX=$O(@NODE@("IPRX",NRX),-1)  Q:NRX=""  D
"RTN","RORX009C",101,0)
 . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"ITEM",,TABLE)
"RTN","RORX009C",102,0)
 . D ADDVAL^RORTSK11(RORTSK,"NP",$P(@NODE@("IPRX",NRX),U),ITEM,3)
"RTN","RORX009C",103,0)
 . D ADDVAL^RORTSK11(RORTSK,"NRX",NRX,ITEM,3)
"RTN","RORX009C",104,0)
 ;--- Drugs
"RTN","RORX009C",105,0)
 S RC=$$DRUGS(SECTION,"IPD",NODE,"DRUGS_DOSES")  Q:RC<0 RC
"RTN","RORX009C",106,0)
 ;--- Patients with highest utlization
"RTN","RORX009C",107,0)
 I MAXUTNUM>0  D  Q:RC<0 RC
"RTN","RORX009C",108,0)
 . S TABLE=$$ADDVAL^RORTSK11(RORTSK,"HU_DOSES",,SECTION)
"RTN","RORX009C",109,0)
 . I TABLE<0  S RC=TABLE  Q
"RTN","RORX009C",110,0)
 . D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","HU_DOSES")
"RTN","RORX009C",111,0)
 . S NRX="",(COUNT,RC)=0
"RTN","RORX009C",112,0)
 . F  S NRX=$O(@NODE@("IPRX",NRX),-1)  Q:NRX=""  D  Q:RC
"RTN","RORX009C",113,0)
 . . S RC=$$LOOP^RORTSK01()  Q:RC<0
"RTN","RORX009C",114,0)
 . . S NAME=""
"RTN","RORX009C",115,0)
 . . F  S NAME=$O(@NODE@("IPRX",NRX,NAME))  Q:NAME=""  D  Q:RC
"RTN","RORX009C",116,0)
 . . . S DFN=""
"RTN","RORX009C",117,0)
 . . . F  S DFN=$O(@NODE@("IPRX",NRX,NAME,DFN))  Q:DFN=""  D  Q:RC
"RTN","RORX009C",118,0)
 . . . . S COUNT=COUNT+1  I COUNT>MAXUTNUM  S RC=1  Q
"RTN","RORX009C",119,0)
 . . . . S BUF=$G(@NODE@("IP",DFN))
"RTN","RORX009C",120,0)
 . . . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,TABLE)
"RTN","RORX009C",121,0)
 . . . . D ADDVAL^RORTSK11(RORTSK,"NAME",NAME,ITEM,1)
"RTN","RORX009C",122,0)
 . . . . D ADDVAL^RORTSK11(RORTSK,"LAST4",$P(BUF,U),ITEM,2)
"RTN","RORX009C",123,0)
 . . . . D ADDVAL^RORTSK11(RORTSK,"NRX",NRX,ITEM,3)
"RTN","RORX009C",124,0)
 . . . . D ADDVAL^RORTSK11(RORTSK,"ND",$P(BUF,U,4),ITEM,3)
"RTN","RORX009C",125,0)
 ;--- Summary
"RTN","RORX009C",126,0)
 D ADDVAL^RORTSK11(RORTSK,"NP",+$G(@NODE@("IP")),SECTION)
"RTN","RORX009C",127,0)
 D ADDVAL^RORTSK11(RORTSK,"NRX",+$G(@NODE@("IPRX")),SECTION)
"RTN","RORX009C",128,0)
 D ADDVAL^RORTSK11(RORTSK,"ND",+$G(@NODE@("IPD")),SECTION)
"RTN","RORX009C",129,0)
 Q 0
"RTN","RORX009C",130,0)
 ;
"RTN","RORX009C",131,0)
 ;***** OUTPATIENT DATA
"RTN","RORX009C",132,0)
 ;
"RTN","RORX009C",133,0)
 ; CATEGORY      IEN of the CATEGORY element
"RTN","RORX009C",134,0)
 ;
"RTN","RORX009C",135,0)
 ; NODE          Closed root of the category section
"RTN","RORX009C",136,0)
 ;               in the temporary global
"RTN","RORX009C",137,0)
 ;
"RTN","RORX009C",138,0)
 ; Return Values:
"RTN","RORX009C",139,0)
 ;       <0  Error code
"RTN","RORX009C",140,0)
 ;        0  Ok
"RTN","RORX009C",141,0)
 ;
"RTN","RORX009C",142,0)
STOREOP(CATEGORY,NODE) ;
"RTN","RORX009C",143,0)
 Q:$D(@NODE@("OP"))<10 0
"RTN","RORX009C",144,0)
 N COUNT,DFN,ITEM,MAXUTNUM,NAME,NRX,RC,SECTION,TABLE,TMP
"RTN","RORX009C",145,0)
 S MAXUTNUM=$$PARAM^RORTSK01("MAXUTNUM")
"RTN","RORX009C",146,0)
 S SECTION=$$ADDVAL^RORTSK11(RORTSK,"OUTPATIENTS",,CATEGORY)
"RTN","RORX009C",147,0)
 Q:SECTION<0 SECTION
"RTN","RORX009C",148,0)
 S RC=0
"RTN","RORX009C",149,0)
 ;--- Number of fills
"RTN","RORX009C",150,0)
 S TABLE=$$ADDVAL^RORTSK11(RORTSK,"FILLS",,SECTION)
"RTN","RORX009C",151,0)
 Q:TABLE<0 TABLE
"RTN","RORX009C",152,0)
 D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","FILLS")
"RTN","RORX009C",153,0)
 S NRX=""
"RTN","RORX009C",154,0)
 F  S NRX=$O(@NODE@("OPRX",NRX),-1)  Q:NRX=""  D
"RTN","RORX009C",155,0)
 . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"ITEM",,TABLE)
"RTN","RORX009C",156,0)
 . D ADDVAL^RORTSK11(RORTSK,"NP",$P(@NODE@("OPRX",NRX),U),ITEM,3)
"RTN","RORX009C",157,0)
 . D ADDVAL^RORTSK11(RORTSK,"NRX",NRX,ITEM,3)
"RTN","RORX009C",158,0)
 ;--- Drugs
"RTN","RORX009C",159,0)
 S RC=$$DRUGS(SECTION,"OPD",NODE,"DRUGS_FILLS")  Q:RC<0 RC
"RTN","RORX009C",160,0)
 ;--- Patients with highest utlization
"RTN","RORX009C",161,0)
 I MAXUTNUM>0  D  Q:RC<0 RC
"RTN","RORX009C",162,0)
 . S TABLE=$$ADDVAL^RORTSK11(RORTSK,"HU_FILLS",,SECTION)
"RTN","RORX009C",163,0)
 . I TABLE<0  S RC=TABLE  Q
"RTN","RORX009C",164,0)
 . D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","HU_FILLS")
"RTN","RORX009C",165,0)
 . S NRX="",(COUNT,RC)=0
"RTN","RORX009C",166,0)
 . F  S NRX=$O(@NODE@("OPRX",NRX),-1)  Q:NRX=""  D  Q:RC
"RTN","RORX009C",167,0)
 . . S RC=$$LOOP^RORTSK01()  Q:RC<0
"RTN","RORX009C",168,0)
 . . S NAME=""
"RTN","RORX009C",169,0)
 . . F  S NAME=$O(@NODE@("OPRX",NRX,NAME))  Q:NAME=""  D  Q:RC
"RTN","RORX009C",170,0)
 . . . S DFN=""
"RTN","RORX009C",171,0)
 . . . F  S DFN=$O(@NODE@("OPRX",NRX,NAME,DFN))  Q:DFN=""  D  Q:RC
"RTN","RORX009C",172,0)
 . . . . S COUNT=COUNT+1  I COUNT>MAXUTNUM  S RC=1  Q
"RTN","RORX009C",173,0)
 . . . . S BUF=$G(@NODE@("OP",DFN))
"RTN","RORX009C",174,0)
 . . . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,TABLE)
"RTN","RORX009C",175,0)
 . . . . D ADDVAL^RORTSK11(RORTSK,"NAME",NAME,ITEM,1)
"RTN","RORX009C",176,0)
 . . . . D ADDVAL^RORTSK11(RORTSK,"LAST4",$P(BUF,U),ITEM,2)
"RTN","RORX009C",177,0)
 . . . . D ADDVAL^RORTSK11(RORTSK,"NRX",NRX,ITEM,3)
"RTN","RORX009C",178,0)
 . . . . D ADDVAL^RORTSK11(RORTSK,"ND",$P(BUF,U,4),ITEM,3)
"RTN","RORX009C",179,0)
 ;--- Summary
"RTN","RORX009C",180,0)
 D ADDVAL^RORTSK11(RORTSK,"NP",+$G(@NODE@("OP")),SECTION)
"RTN","RORX009C",181,0)
 D ADDVAL^RORTSK11(RORTSK,"NRX",+$G(@NODE@("OPRX")),SECTION)
"RTN","RORX009C",182,0)
 D ADDVAL^RORTSK11(RORTSK,"ND",+$G(@NODE@("OPD")),SECTION)
"RTN","RORX009C",183,0)
 Q 0
"RTN","RORX010")
0^138^B36480677
"RTN","RORX010",1,0)
RORX010 ;HCIOFO/SG - VIRAL LOAD AND CD4 BY RANGE REPORT ; 12/8/03 2:12pm
"RTN","RORX010",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORX010",3,0)
 ;
"RTN","RORX010",4,0)
 ; This routine uses the following IAs:
"RTN","RORX010",5,0)
 ;
"RTN","RORX010",6,0)
 ; #10061        DEM^VADPT (supported)
"RTN","RORX010",7,0)
 ;
"RTN","RORX010",8,0)
 ;--------------------------------------------------------------------
"RTN","RORX010",9,0)
 ; Registry: [VA ICR]
"RTN","RORX010",10,0)
 ;--------------------------------------------------------------------
"RTN","RORX010",11,0)
 Q
"RTN","RORX010",12,0)
 ;
"RTN","RORX010",13,0)
 ;***** OUTPUTS THE REPORT HEADER
"RTN","RORX010",14,0)
 ;
"RTN","RORX010",15,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX010",16,0)
 ;
"RTN","RORX010",17,0)
 ; Return Values:
"RTN","RORX010",18,0)
 ;       <0  Error code
"RTN","RORX010",19,0)
 ;        0  Ok
"RTN","RORX010",20,0)
 ;
"RTN","RORX010",21,0)
HEADER(PARTAG) ;
"RTN","RORX010",22,0)
 ;;PATIENTS(#,NAME,LAST4,PTLRL(GROUP,DATE,NAME,RESULT))
"RTN","RORX010",23,0)
 ;
"RTN","RORX010",24,0)
 N COLUMNS,HEADER,LT,NAME,TMP
"RTN","RORX010",25,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX010",26,0)
 Q:HEADER<0 HEADER
"RTN","RORX010",27,0)
 S RC=$$TBLDEF^RORXU002("HEADER^RORX010",HEADER)
"RTN","RORX010",28,0)
 Q $S(RC<0:RC,1:HEADER)
"RTN","RORX010",29,0)
 ;
"RTN","RORX010",30,0)
 ;***** CALLBACK FUNCTION FOR LAB DATA SEARCH
"RTN","RORX010",31,0)
LTCB(RORDST,INVDT,RESULT) ;
"RTN","RORX010",32,0)
 N GRP,VAL
"RTN","RORX010",33,0)
 S VAL=$P($G(RESULT(1)),U,3),VAL=$TR(VAL," <>,")
"RTN","RORX010",34,0)
 S GRP=+$P($G(RESULT(2)),U,3)
"RTN","RORX010",35,0)
 ;--- Skip a non-numeric result if ranges are requested
"RTN","RORX010",36,0)
 I $D(RORDST("LH",GRP))>1  Q:'$$NUMERIC^RORUTL05(VAL) 1
"RTN","RORX010",37,0)
 ;--- Check the ranges
"RTN","RORX010",38,0)
 I $G(RORDST("LH",GRP,"L"))'=""  Q:VAL<RORDST("LH",GRP,"L") 1
"RTN","RORX010",39,0)
 I $G(RORDST("LH",GRP,"H"))'=""  Q:VAL>RORDST("LH",GRP,"H") 1
"RTN","RORX010",40,0)
 K RORDST("GRP",GRP)
"RTN","RORX010",41,0)
 ;--- Store the result
"RTN","RORX010",42,0)
 S RORDST("RORPTR")=$G(RORDST("RORPTR"))+1
"RTN","RORX010",43,0)
 M @RORDST@(RORDST("RORPTR"))=RESULT
"RTN","RORX010",44,0)
 Q 0
"RTN","RORX010",45,0)
 ;
"RTN","RORX010",46,0)
 ;***** OUTPUTS THE REPORT PARAMETERS
"RTN","RORX010",47,0)
 ;
"RTN","RORX010",48,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX010",49,0)
 ;
"RTN","RORX010",50,0)
 ; Return Values:
"RTN","RORX010",51,0)
 ;       <0  Error code
"RTN","RORX010",52,0)
 ;        0  Ok
"RTN","RORX010",53,0)
 ;
"RTN","RORX010",54,0)
PARAMS(PARTAG) ;
"RTN","RORX010",55,0)
 N ELEMENT,GRC,NAME,PARAMS,TMP
"RTN","RORX010",56,0)
 S PARAMS=$$PARAMS^RORXU002(.RORTSK,PARTAG,.RORSDT,.ROREDT)
"RTN","RORX010",57,0)
 Q:PARAMS<0 PARAMS
"RTN","RORX010",58,0)
 ;--- Viral Load (3) and CD4 (1) options
"RTN","RORX010",59,0)
 F GRC=3,1  D
"RTN","RORX010",60,0)
 . S NAME=$P("CD4OPT^^VIRAL_LOAD","^",GRC)
"RTN","RORX010",61,0)
 . S TMP=$$PARAM^RORTSK01(NAME)  Q:'TMP
"RTN","RORX010",62,0)
 . ;---
"RTN","RORX010",63,0)
 . S ELEMENT=$$ADDVAL^RORTSK11(RORTSK,NAME,$$RANGE(GRC,TMP),PARAMS)
"RTN","RORX010",64,0)
 . D:$D(RORDST("LH",1))>1 ADDATTR^RORTSK11(RORTSK,ELEMENT,"RANGE",1)
"RTN","RORX010",65,0)
 . ;---
"RTN","RORX010",66,0)
 . S TMP=$G(RORDST("LH",GRC,"L"))
"RTN","RORX010",67,0)
 . D:TMP'="" ADDATTR^RORTSK11(RORTSK,ELEMENT,"LOW",TMP)
"RTN","RORX010",68,0)
 . S TMP=$G(RORDST("LH",GRC,"H"))
"RTN","RORX010",69,0)
 . D:TMP'="" ADDATTR^RORTSK11(RORTSK,ELEMENT,"HIGH",TMP)
"RTN","RORX010",70,0)
 ;---
"RTN","RORX010",71,0)
 Q PARAMS
"RTN","RORX010",72,0)
 ;
"RTN","RORX010",73,0)
 ;***** ADDS THE PATIENT DATA TO THE REPORT
"RTN","RORX010",74,0)
 ;
"RTN","RORX010",75,0)
 ; IENS          IENS of the patient's record in the registry
"RTN","RORX010",76,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX010",77,0)
 ;
"RTN","RORX010",78,0)
 ; Return Values:
"RTN","RORX010",79,0)
 ;       <0  Error code
"RTN","RORX010",80,0)
 ;        0  Ok
"RTN","RORX010",81,0)
 ;
"RTN","RORX010",82,0)
PATIENT(IENS,PARTAG) ;
"RTN","RORX010",83,0)
 N DFN,I,LABTESTS,LT,NAME,RC,RORBUF,RORMSG,TMP,VA,VADM
"RTN","RORX010",84,0)
 ;--- Get the data from the ROR LOCAL REGISTRY file
"RTN","RORX010",85,0)
 D GETS^DIQ(798,IENS,".01","I","RORBUF","RORMSG")
"RTN","RORX010",86,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","RORX010",87,0)
 S DFN=$G(RORBUF(798,IENS,.01,"I"))
"RTN","RORX010",88,0)
 ;--- Search for the lab results
"RTN","RORX010",89,0)
 K @RORDST,RORDST("RORPTR")
"RTN","RORX010",90,0)
 M RORDST("GRP")=RORDST("LH")
"RTN","RORX010",91,0)
 S RC=$$LTSEARCH^RORUTL10(DFN,"RORLTL",.RORDST,,RORSDT,ROREDT1)
"RTN","RORX010",92,0)
 Q:RC'>0 RC
"RTN","RORX010",93,0)
 ;--- Results from all groups should be present
"RTN","RORX010",94,0)
 Q:$D(RORDST("GRP"))>1 0
"RTN","RORX010",95,0)
 ;--- Load the demographic data
"RTN","RORX010",96,0)
 D VADEM^RORUTL05(DFN,1)
"RTN","RORX010",97,0)
 ;--- The <PATIENT> tag
"RTN","RORX010",98,0)
 S PTAG=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,PARTAG,,DFN)
"RTN","RORX010",99,0)
 Q:PTAG<0 PTAG
"RTN","RORX010",100,0)
 ;--- Patient Name
"RTN","RORX010",101,0)
 D ADDVAL^RORTSK11(RORTSK,"NAME",VADM(1),PTAG,1)
"RTN","RORX010",102,0)
 ;--- last 4 digits of the SSN
"RTN","RORX010",103,0)
 D ADDVAL^RORTSK11(RORTSK,"LAST4",VA("BID"),PTAG,2)
"RTN","RORX010",104,0)
 ;--- Lab results
"RTN","RORX010",105,0)
 S LABTESTS=$$ADDVAL^RORTSK11(RORTSK,"PTLRL",,PTAG)
"RTN","RORX010",106,0)
 S I=""
"RTN","RORX010",107,0)
 F  S I=$O(@RORDST@(I))  Q:I=""  D
"RTN","RORX010",108,0)
 . S LT=$$ADDVAL^RORTSK11(RORTSK,"LT",,LABTESTS)
"RTN","RORX010",109,0)
 . D ADDVAL^RORTSK11(RORTSK,"GROUP",$P(@RORDST@(I,2),U,4),LT,1)
"RTN","RORX010",110,0)
 . D ADDVAL^RORTSK11(RORTSK,"DATE",$P(@RORDST@(I,1),U,2),LT,1)
"RTN","RORX010",111,0)
 . D ADDVAL^RORTSK11(RORTSK,"NAME",$P(@RORDST@(I,2),U,2),LT,1)
"RTN","RORX010",112,0)
 . D ADDVAL^RORTSK11(RORTSK,"RESULT",$P(@RORDST@(I,1),U,3),LT,3)
"RTN","RORX010",113,0)
 ;---
"RTN","RORX010",114,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORX010",115,0)
 ;
"RTN","RORX010",116,0)
 ;***** PROCESSES THE RESULT RANGE OPTIONS
"RTN","RORX010",117,0)
 ;
"RTN","RORX010",118,0)
 ; GRC           Code of a Lab Group (1 - CD4, 3 - Viral Load)
"RTN","RORX010",119,0)
 ;
"RTN","RORX010",120,0)
 ; OPT           String value of the option (see description of the
"RTN","RORX010",121,0)
 ;               ROR REPORT SCHEDULE remote procedure for details)
"RTN","RORX010",122,0)
 ;
"RTN","RORX010",123,0)
 ; Return Values:
"RTN","RORX010",124,0)
 ;       Description of the Lab results to be included in the report.
"RTN","RORX010",125,0)
 ;
"RTN","RORX010",126,0)
RANGE(GRC,OPT) ;
"RTN","RORX010",127,0)
 N RANGE,TMP
"RTN","RORX010",128,0)
 S RORDST("LH",GRC)=1,RANGE=""
"RTN","RORX010",129,0)
 ;--- Range
"RTN","RORX010",130,0)
 D:$P(OPT,U,2)
"RTN","RORX010",131,0)
 . ;--- Low
"RTN","RORX010",132,0)
 . D:$P(OPT,U,3)'=""
"RTN","RORX010",133,0)
 . . S (RORDST("LH",GRC,"L"),TMP)=+$P(OPT,U,3)
"RTN","RORX010",134,0)
 . . S RANGE=RANGE_" not less than "_TMP
"RTN","RORX010",135,0)
 . ;--- High
"RTN","RORX010",136,0)
 . D:$P(OPT,U,4)'=""
"RTN","RORX010",137,0)
 . . S (RORDST("LH",GRC,"H"),TMP)=+$P(OPT,U,4)
"RTN","RORX010",138,0)
 . . S RANGE=RANGE_$S(RANGE'="":" and",1:"")_" not greater than "_TMP
"RTN","RORX010",139,0)
 ;--- Description
"RTN","RORX010",140,0)
 S TMP=$S(RANGE'="":" numerical results, which are",1:" all results")
"RTN","RORX010",141,0)
 Q "Include"_TMP_RANGE
"RTN","RORX010",142,0)
 ;
"RTN","RORX010",143,0)
 ;***** COMPILES THE VIRAL LOAD AND CD4 BY RANGE REPORT
"RTN","RORX010",144,0)
 ; REPORT CODE: 010
"RTN","RORX010",145,0)
 ;
"RTN","RORX010",146,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORX010",147,0)
 ;
"RTN","RORX010",148,0)
 ; Return Values:
"RTN","RORX010",149,0)
 ;       <0  Error code
"RTN","RORX010",150,0)
 ;        0  Ok
"RTN","RORX010",151,0)
 ;
"RTN","RORX010",152,0)
VRLCD4(RORTSK) ;
"RTN","RORX010",153,0)
 N RORDST        ; Callback descriptor
"RTN","RORX010",154,0)
 N ROREDT        ; End date
"RTN","RORX010",155,0)
 N ROREDT1       ; End date + 1 day
"RTN","RORX010",156,0)
 N RORLTL        ; List of lab tests to search for
"RTN","RORX010",157,0)
 N RORREG        ; Registry IEN
"RTN","RORX010",158,0)
 N RORSDT        ; Start date
"RTN","RORX010",159,0)
 ;
"RTN","RORX010",160,0)
 N BODY,CNT,ECNT,IEN,IENS,MODE,RC,REPORT,RORPTN,TMP
"RTN","RORX010",161,0)
 ;--- Root node of the report
"RTN","RORX010",162,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX010",163,0)
 Q:REPORT<0 REPORT
"RTN","RORX010",164,0)
 ;
"RTN","RORX010",165,0)
 ;--- Get and prepare the report parameters
"RTN","RORX010",166,0)
 S RORREG=+$$PARAM^RORTSK01("REGIEN")
"RTN","RORX010",167,0)
 S RC=$$PARAMS(REPORT)  Q:RC<0 RC
"RTN","RORX010",168,0)
 S MODE=$$PARAM^RORTSK01("PATIENTS")
"RTN","RORX010",169,0)
 D LIST^RORXU002(.MODE)
"RTN","RORX010",170,0)
 ;
"RTN","RORX010",171,0)
 ;--- Initialize constants and variables
"RTN","RORX010",172,0)
 S RORPTN=$$REGSIZE^RORUTL02(+RORREG)  S:RORPTN<0 RORPTN=0
"RTN","RORX010",173,0)
 S ROREDT1=$$FMADD^XLFDT(ROREDT\1,1),ECNT=0
"RTN","RORX010",174,0)
 K ^TMP("RORX010",$J)
"RTN","RORX010",175,0)
 ;---
"RTN","RORX010",176,0)
 S RORDST=$NA(^TMP("RORX010",$J)),TMP=""
"RTN","RORX010",177,0)
 S RORDST("RORCB")="$$LTCB^RORX010"
"RTN","RORX010",178,0)
 S:$G(RORDST("LH",1)) TMP=TMP_"1,"
"RTN","RORX010",179,0)
 S:$G(RORDST("LH",3)) TMP=TMP_"3,"
"RTN","RORX010",180,0)
 S RC=$$LOADTSTS^RORUTL10(+RORREG,"RORLTL",TMP)
"RTN","RORX010",181,0)
 ;
"RTN","RORX010",182,0)
 ;--- Report header and list of patients
"RTN","RORX010",183,0)
 S RC=$$HEADER(REPORT)  Q:RC<0 RC
"RTN","RORX010",184,0)
 S BODY=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,REPORT)
"RTN","RORX010",185,0)
 Q:BODY<0 BODY
"RTN","RORX010",186,0)
 D ADDATTR^RORTSK11(RORTSK,BODY,"TABLE","PATIENTS")
"RTN","RORX010",187,0)
 ;
"RTN","RORX010",188,0)
 ;--- Browse through the registry records
"RTN","RORX010",189,0)
 S (CNT,IEN,RC)=0
"RTN","RORX010",190,0)
 F  S IEN=$O(^RORDATA(798,"AC",RORREG,IEN))  Q:IEN'>0  D  Q:RC<0
"RTN","RORX010",191,0)
 . S TMP=$S(RORPTN>0:CNT/RORPTN,1:"")
"RTN","RORX010",192,0)
 . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX010",193,0)
 . S IENS=IEN_",",CNT=CNT+1
"RTN","RORX010",194,0)
 . ;--- Check if the patient should be skipped
"RTN","RORX010",195,0)
 . Q:$$SKIP^RORXU005(IEN,"DI",RORSDT,ROREDT)
"RTN","RORX010",196,0)
 . ;--- Check the clinical status
"RTN","RORX010",197,0)
 . S TMP=$$CLINAIDS^RORICRUT(IEN,ROREDT)
"RTN","RORX010",198,0)
 . Q:'$D(MODE($S(TMP:"AIDS",1:"HIV")))
"RTN","RORX010",199,0)
 . ;--- Process the registry record
"RTN","RORX010",200,0)
 . I $$PATIENT(IENS,BODY)<0  S ECNT=ECNT+1  Q
"RTN","RORX010",201,0)
 ;
"RTN","RORX010",202,0)
 ;--- Cleanup
"RTN","RORX010",203,0)
 K ^TMP("RORX010",$J)
"RTN","RORX010",204,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX011")
0^167^B44205168
"RTN","RORX011",1,0)
RORX011 ; HCIOFO/SG - PATIENT DRUG HISTORY ; 12/9/03 8:52am
"RTN","RORX011",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX011",3,0)
 ;
"RTN","RORX011",4,0)
 ;--------------------------------------------------------------------
"RTN","RORX011",5,0)
 ; Registry: [VA ICR]
"RTN","RORX011",6,0)
 ;--------------------------------------------------------------------
"RTN","RORX011",7,0)
 Q
"RTN","RORX011",8,0)
 ;
"RTN","RORX011",9,0)
 ;***** OUTPUTS THE REPORT HEADER
"RTN","RORX011",10,0)
 ;
"RTN","RORX011",11,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX011",12,0)
 ;
"RTN","RORX011",13,0)
 ; Return Values:
"RTN","RORX011",14,0)
 ;       <0  Error code
"RTN","RORX011",15,0)
 ;       >0  IEN of the HEADER element
"RTN","RORX011",16,0)
 ;
"RTN","RORX011",17,0)
HEADER(PARTAG) ;
"RTN","RORX011",18,0)
 ;;PTRXL(DATE,ORDER,TYPE,NAME,GENERIC,DAYSPLY,FILLTYPE)
"RTN","RORX011",19,0)
 ;
"RTN","RORX011",20,0)
 N HEADER,NOTES,RC
"RTN","RORX011",21,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX011",22,0)
 Q:HEADER<0 HEADER
"RTN","RORX011",23,0)
 S NOTES=$$ADDVAL^RORTSK11(RORTSK,"NOTES",,HEADER)
"RTN","RORX011",24,0)
 D ADDVAL^RORTSK11(RORTSK,"AGE",$$DT^XLFDT,NOTES)
"RTN","RORX011",25,0)
 S RC=$$TBLDEF^RORXU002("HEADER^RORX011",HEADER)
"RTN","RORX011",26,0)
 Q $S(RC<0:RC,1:HEADER)
"RTN","RORX011",27,0)
 ;
"RTN","RORX011",28,0)
 ;***** OUTPUTS THE PARAMETERS TO THE REPORT
"RTN","RORX011",29,0)
 ;
"RTN","RORX011",30,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX011",31,0)
 ;
"RTN","RORX011",32,0)
 ; [.STDT]       Start and end dates of the report
"RTN","RORX011",33,0)
 ; [.ENDT]       are returned via these parameters
"RTN","RORX011",34,0)
 ;
"RTN","RORX011",35,0)
 ; [.FLAGS]      Flags for the $$SKIP^RORXU005 are
"RTN","RORX011",36,0)
 ;               returned via this parameter
"RTN","RORX011",37,0)
 ;
"RTN","RORX011",38,0)
 ; Return Values:
"RTN","RORX011",39,0)
 ;       <0  Error code
"RTN","RORX011",40,0)
 ;       >0  IEN of the PARAMETERS element
"RTN","RORX011",41,0)
 ;
"RTN","RORX011",42,0)
PARAMS(PARTAG,STDT,ENDT,FLAGS) ;
"RTN","RORX011",43,0)
 N PARAMS,TMP
"RTN","RORX011",44,0)
 S PARAMS=$$PARAMS^RORXU002(.RORTSK,PARTAG,.STDT,.ENDT,.FLAGS)
"RTN","RORX011",45,0)
 Q:PARAMS<0 PARAMS
"RTN","RORX011",46,0)
 ;--- Compile the list of drugs and process options
"RTN","RORX011",47,0)
 S TMP=$NA(^TMP("RORX011D",$J))
"RTN","RORX011",48,0)
 S RORLRX=$$COMBRXL^RORXU007(.RORTSK,PARAMS,TMP,.RORXOPT)
"RTN","RORX011",49,0)
 Q:RORLRX<0 RORLRX
"RTN","RORX011",50,0)
 ;---
"RTN","RORX011",51,0)
 Q PARAMS
"RTN","RORX011",52,0)
 ;
"RTN","RORX011",53,0)
 ;***** PROCESS THE PATIENT'S DATA
"RTN","RORX011",54,0)
 ;
"RTN","RORX011",55,0)
 ; PTLIST        Reference (IEN) to the parent tag
"RTN","RORX011",56,0)
 ; PATIEN        Patient IEN in the file #2 (DFN)
"RTN","RORX011",57,0)
 ;
"RTN","RORX011",58,0)
 ; Return Values:
"RTN","RORX011",59,0)
 ;       <0  Error code
"RTN","RORX011",60,0)
 ;        0  Ok
"RTN","RORX011",61,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX011",62,0)
 ;
"RTN","RORX011",63,0)
PATIENT(PTLIST,PATIEN) ;
"RTN","RORX011",64,0)
 N BUF,FLT,FLTL,FQL,ITEM,NODE,PTAG,QSB,RC,TABLE,VA,VADM,VAERR
"RTN","RORX011",65,0)
 S (ECNT,RC)=0
"RTN","RORX011",66,0)
 ;--- Patient data
"RTN","RORX011",67,0)
 S PTAG=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,PTLIST,,PATIEN)
"RTN","RORX011",68,0)
 Q:PTAG<0 PTAG
"RTN","RORX011",69,0)
 D VADEM^RORUTL05(PATIEN,1)
"RTN","RORX011",70,0)
 D ADDVAL^RORTSK11(RORTSK,"NAME",VADM(1),PTAG,1)
"RTN","RORX011",71,0)
 D ADDVAL^RORTSK11(RORTSK,"LAST4",VA("BID"),PTAG)
"RTN","RORX011",72,0)
 D ADDVAL^RORTSK11(RORTSK,"DOB",$P(VADM(3),U),PTAG)
"RTN","RORX011",73,0)
 D ADDVAL^RORTSK11(RORTSK,"AGE",VADM(4),PTAG)
"RTN","RORX011",74,0)
 ;--- List of drugs
"RTN","RORX011",75,0)
 S TABLE=$$ADDVAL^RORTSK11(RORTSK,"PTRXL",,PTAG)
"RTN","RORX011",76,0)
 Q:TABLE<0 TABLE
"RTN","RORX011",77,0)
 D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","PTRXL")
"RTN","RORX011",78,0)
 ;---
"RTN","RORX011",79,0)
 S NODE=RORXDST,FLTL=$L(NODE)-1,FLT=$E(NODE,1,FLTL)
"RTN","RORX011",80,0)
 S QSB=$QL(NODE),FQL=QSB+5
"RTN","RORX011",81,0)
 F  S NODE=$Q(@NODE)  Q:$E(NODE,1,FLTL)'=FLT  D:$QL(NODE)=FQL
"RTN","RORX011",82,0)
 . ; NODE: @RORXDST@(DATE,DRUGNAME,DRUGIEN,RXNUM,RXCNT)
"RTN","RORX011",83,0)
 . S BUF=@NODE
"RTN","RORX011",84,0)
 . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"DRUG",,TABLE)
"RTN","RORX011",85,0)
 . D ADDVAL^RORTSK11(RORTSK,"DATE",$QS(NODE,QSB+1)\1,ITEM,1)
"RTN","RORX011",86,0)
 . D ADDVAL^RORTSK11(RORTSK,"ORDER",$QS(NODE,QSB+4),ITEM,1)
"RTN","RORX011",87,0)
 . S TMP=$P(BUF,U)
"RTN","RORX011",88,0)
 . S TMP=$S(TMP="O":"ORIGINAL",TMP="P":"PARTIAL",TMP="R":"REFILL",1:"")
"RTN","RORX011",89,0)
 . D ADDVAL^RORTSK11(RORTSK,"TYPE",TMP,ITEM,1)
"RTN","RORX011",90,0)
 . D ADDVAL^RORTSK11(RORTSK,"NAME",$QS(NODE,QSB+2),ITEM,1)
"RTN","RORX011",91,0)
 . D ADDVAL^RORTSK11(RORTSK,"GENERIC",$P(BUF,U,4),ITEM,1)
"RTN","RORX011",92,0)
 . D ADDVAL^RORTSK11(RORTSK,"DAYSPLY",$P(BUF,U,5),ITEM,1)
"RTN","RORX011",93,0)
 . S TMP=$P(BUF,U,2)
"RTN","RORX011",94,0)
 . S TMP=$S(TMP="I":"INPATIENT",TMP="M":"MAIL",TMP="W":"WINDOW",1:"")
"RTN","RORX011",95,0)
 . D ADDVAL^RORTSK11(RORTSK,"FILLTYPE",TMP,ITEM,1)
"RTN","RORX011",96,0)
 ;---
"RTN","RORX011",97,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX011",98,0)
 ;
"RTN","RORX011",99,0)
 ;***** PROCESSES THE LIST OF PATIENTS
"RTN","RORX011",100,0)
 ;
"RTN","RORX011",101,0)
 ; REPORT        Reference (IEN) to the parent tag
"RTN","RORX011",102,0)
 ;
"RTN","RORX011",103,0)
 ; Return Values:
"RTN","RORX011",104,0)
 ;       <0  Error code
"RTN","RORX011",105,0)
 ;        0  Ok
"RTN","RORX011",106,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX011",107,0)
 ;
"RTN","RORX011",108,0)
PROCESS(REPORT) ;
"RTN","RORX011",109,0)
 N CNT,ECNT,PATIEN,PTLIST,RC,RORI,RORPTN,RORXDST,RXFLAGS,TMP
"RTN","RORX011",110,0)
 S (CNT,ECNT,RC)=0
"RTN","RORX011",111,0)
 ;
"RTN","RORX011",112,0)
 ;--- Count patients in the list
"RTN","RORX011",113,0)
 S (RORI,RORPTN)=0
"RTN","RORX011",114,0)
 F  D  Q:RORI'>0  S RORPTN=RORPTN+1
"RTN","RORX011",115,0)
 . S RORI=$O(RORTSK("PARAMS","PTLST",RORI))
"RTN","RORX011",116,0)
 Q:RORPTN'>0 0
"RTN","RORX011",117,0)
 S PTLIST=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,REPORT)
"RTN","RORX011",118,0)
 Q:PTLIST<0 PTLIST
"RTN","RORX011",119,0)
 ;
"RTN","RORX011",120,0)
 ;--- Prepare parameters for the pharmacy search API
"RTN","RORX011",121,0)
 S RORXDST=$NA(^TMP("RORX011",$J))
"RTN","RORX011",122,0)
 S RORXDST("RORCB")="$$RXSCB^RORX011"
"RTN","RORX011",123,0)
 S RXFLAGS="E"
"RTN","RORX011",124,0)
 S:$D(RORMODE("INPATIENT")) RXFLAGS=RXFLAGS_"IV"
"RTN","RORX011",125,0)
 S:$D(RORMODE("OUTPATIENT")) RXFLAGS=RXFLAGS_"O"
"RTN","RORX011",126,0)
 ;
"RTN","RORX011",127,0)
 ;--- Browse through the list of patients
"RTN","RORX011",128,0)
 S (CNT,RORI)=0
"RTN","RORX011",129,0)
 F  S RORI=$O(RORTSK("PARAMS","PTLST",RORI))  Q:RORI'>0  D  Q:RC<0
"RTN","RORX011",130,0)
 . S RC=$$LOOP^RORTSK01(CNT/RORPTN)  Q:RC<0
"RTN","RORX011",131,0)
 . S CNT=CNT+1
"RTN","RORX011",132,0)
 . S PATIEN=RORTSK("PARAMS","PTLST",RORI)  Q:PATIEN'>0
"RTN","RORX011",133,0)
 . ;--- Search the pharmacy data
"RTN","RORX011",134,0)
 . K @RORXDST
"RTN","RORX011",135,0)
 . S TMP=$$RXSEARCH^RORUTL14(PATIEN,RORLRX,.RORXDST,RXFLAGS,RORSDT,ROREDT1)
"RTN","RORX011",136,0)
 . I TMP<0  S ECNT=ECNT+1  Q
"RTN","RORX011",137,0)
 . ;--- Append the patient's data to the report
"RTN","RORX011",138,0)
 . S TMP=$$PATIENT(PTLIST,PATIEN)
"RTN","RORX011",139,0)
 . I TMP  S ECNT=ECNT+$S(TMP>0:TMP,1:1)  Q
"RTN","RORX011",140,0)
 ;
"RTN","RORX011",141,0)
 ;--- Cleanup
"RTN","RORX011",142,0)
 K @RORXDST
"RTN","RORX011",143,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX011",144,0)
 ;
"RTN","RORX011",145,0)
 ;***** COMPILES THE "PATIENT DRUG HISTORY" REPORT
"RTN","RORX011",146,0)
 ; REPORT CODE: 011
"RTN","RORX011",147,0)
 ;
"RTN","RORX011",148,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORX011",149,0)
 ;
"RTN","RORX011",150,0)
 ; The ^TMP("RORX011",$J) and ^TMP("RORX011D",$J) global nodes are
"RTN","RORX011",151,0)
 ; used by this function.
"RTN","RORX011",152,0)
 ;
"RTN","RORX011",153,0)
 ; Return Values:
"RTN","RORX011",154,0)
 ;       <0  Error code
"RTN","RORX011",155,0)
 ;        0  Ok
"RTN","RORX011",156,0)
 ;
"RTN","RORX011",157,0)
RXHIST(RORTSK) ;
"RTN","RORX011",158,0)
 N ROREDT        ; End date
"RTN","RORX011",159,0)
 N ROREDT1       ; End date + 1
"RTN","RORX011",160,0)
 N RORLRX        ; List of drugs
"RTN","RORX011",161,0)
 N RORMODE       ; Subset of patients to be selected
"RTN","RORX011",162,0)
 N ROROPT        ; Report options
"RTN","RORX011",163,0)
 N RORREG        ; Registry IEN
"RTN","RORX011",164,0)
 N RORSDT        ; Start date
"RTN","RORX011",165,0)
 N RORXOPT       ; Drug options
"RTN","RORX011",166,0)
 ;
"RTN","RORX011",167,0)
 N ECNT,RC,REPORT,TMP
"RTN","RORX011",168,0)
 S (ECNT,RC)=0
"RTN","RORX011",169,0)
 ;
"RTN","RORX011",170,0)
 ;--- Root node of the report
"RTN","RORX011",171,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX011",172,0)
 Q:REPORT<0 REPORT
"RTN","RORX011",173,0)
 ;
"RTN","RORX011",174,0)
 ;--- Get and prepare the report parameters
"RTN","RORX011",175,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")
"RTN","RORX011",176,0)
 S RC=$$PARAMS(REPORT,.RORSDT,.ROREDT)  Q:RC<0 RC
"RTN","RORX011",177,0)
 S RORMODE=$$PARAM^RORTSK01("PATIENTS")
"RTN","RORX011",178,0)
 D LIST^RORXU002(.RORMODE)
"RTN","RORX011",179,0)
 S ROROPT=$$PARAM^RORTSK01("OPTIONS")
"RTN","RORX011",180,0)
 D LIST^RORXU002(.ROROPT)
"RTN","RORX011",181,0)
 S ROREDT1=$$FMADD^XLFDT(ROREDT\1,1)
"RTN","RORX011",182,0)
 ;
"RTN","RORX011",183,0)
 ;--- Report header
"RTN","RORX011",184,0)
 S RC=$$HEADER(REPORT)  Q:RC<0 RC
"RTN","RORX011",185,0)
 ;
"RTN","RORX011",186,0)
 ;--- Process the data and generate the report
"RTN","RORX011",187,0)
 S RC=$$PROCESS(REPORT)  S:RC>0 ECNT=ECNT+RC
"RTN","RORX011",188,0)
 ;
"RTN","RORX011",189,0)
 ;--- Cleanup
"RTN","RORX011",190,0)
 K ^TMP("RORX011",$J),^TMP("RORX011D",$J)
"RTN","RORX011",191,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX011",192,0)
 ;
"RTN","RORX011",193,0)
 ;***** CALLBACK FUNCTION FOR THE PHARMACY SEARCH API
"RTN","RORX011",194,0)
RXSCB(ROR8DST,ORDER,ORDFLG,DRUG,DATE) ;
"RTN","RORX011",195,0)
 N DRUGIEN,DRUGNAME,FILLTYPE,IEN,IRP,RPSUB,RXBUF,RXCNT,RXNUM,TMP
"RTN","RORX011",196,0)
 S DRUGIEN=+DRUG,DRUGNAME=$P(DRUG,U,2)
"RTN","RORX011",197,0)
 Q:(DRUGIEN'>0)!(DRUGNAME="") 1
"RTN","RORX011",198,0)
 S:ROR8DST("RORXGEN")>0 $P(RXBUF,U,4)=$P(ROR8DST("RORXGEN"),U,2)
"RTN","RORX011",199,0)
 S $P(RXBUF,U,5)=$P($G(^TMP("PS",$J,0)),U,7)  ; Days Supply
"RTN","RORX011",200,0)
 S TMP=$G(^TMP("PS",$J,"RXN",0))
"RTN","RORX011",201,0)
 S FILLTYPE=$S(ORDFLG["I":"I",1:$P(TMP,U,3))
"RTN","RORX011",202,0)
 S RXNUM=$P(TMP,U)  S:RXNUM="" RXNUM=" "
"RTN","RORX011",203,0)
 ;--- Original prescription
"RTN","RORX011",204,0)
 S RXCNT=0
"RTN","RORX011",205,0)
 D:(DATE'<ROR8DST("RORSDT"))&(DATE<ROR8DST("ROREDT"))
"RTN","RORX011",206,0)
 . S $P(RXBUF,U,1,2)="O"_U_FILLTYPE,RXCNT=RXCNT+1
"RTN","RORX011",207,0)
 . S @ROR8DST@(DATE,DRUGNAME,DRUGIEN,RXNUM,RXCNT)=RXBUF
"RTN","RORX011",208,0)
 ;--- Refills and partials
"RTN","RORX011",209,0)
 F RPSUB="REF","PAR"  D
"RTN","RORX011",210,0)
 . S $P(RXBUF,U)=$E(RPSUB,1)
"RTN","RORX011",211,0)
 . S IRP=0
"RTN","RORX011",212,0)
 . F  S IRP=$O(^TMP("PS",$J,RPSUB,IRP))  Q:IRP'>0  D
"RTN","RORX011",213,0)
 . . S TMP=$G(^TMP("PS",$J,RPSUB,IRP,0))
"RTN","RORX011",214,0)
 . . S $P(RXBUF,U,2)=$S(ORDFLG["I":"I",1:$P(TMP,U,5))
"RTN","RORX011",215,0)
 . . S $P(RXBUF,U,5)=$P(TMP,U,2)  ; Days Supply
"RTN","RORX011",216,0)
 . . I TMP>0  S RXCNT=RXCNT+1  D
"RTN","RORX011",217,0)
 . . . S @ROR8DST@(+TMP,DRUGNAME,DRUGIEN,RXNUM,RXCNT)=RXBUF
"RTN","RORX011",218,0)
 Q 0
"RTN","RORX012")
0^162^B10720831
"RTN","RORX012",1,0)
RORX012 ;HOIFO/SG - COMBINED RX AND LAB REPORT ; 11/26/03 12:58pm
"RTN","RORX012",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;March 14, 2003
"RTN","RORX012",3,0)
 ;
"RTN","RORX012",4,0)
 ;--------------------------------------------------------------------
"RTN","RORX012",5,0)
 ; Registry: [VA ICR]
"RTN","RORX012",6,0)
 ;--------------------------------------------------------------------
"RTN","RORX012",7,0)
 Q
"RTN","RORX012",8,0)
 ;
"RTN","RORX012",9,0)
 ;***** OUTPUTS THE REPORT HEADER
"RTN","RORX012",10,0)
 ;
"RTN","RORX012",11,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX012",12,0)
 ;
"RTN","RORX012",13,0)
 ; Return Values:
"RTN","RORX012",14,0)
 ;       <0  Error code
"RTN","RORX012",15,0)
 ;       >0  IEN of the HEADER element
"RTN","RORX012",16,0)
 ;
"RTN","RORX012",17,0)
HEADER(PARTAG) ;
"RTN","RORX012",18,0)
 ;;LABTESTS(#,NAME,LAST4,AIDSTAT,PTLRL(DATE,NAME,RESULT))
"RTN","RORX012",19,0)
 ;;DRUGS(#,NAME,LAST4,AIDSTAT,PTRXL)
"RTN","RORX012",20,0)
 ;
"RTN","RORX012",21,0)
 N HEADER,RC
"RTN","RORX012",22,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX012",23,0)
 Q:HEADER<0 HEADER
"RTN","RORX012",24,0)
 S RC=$$TBLDEF^RORXU002("HEADER^RORX012",HEADER)
"RTN","RORX012",25,0)
 Q $S(RC<0:RC,1:HEADER)
"RTN","RORX012",26,0)
 ;
"RTN","RORX012",27,0)
 ;***** OUTPUTS THE PARAMETERS TO THE REPORT
"RTN","RORX012",28,0)
 ;
"RTN","RORX012",29,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX012",30,0)
 ;
"RTN","RORX012",31,0)
 ; [.STDT]       Start and end dates of the report
"RTN","RORX012",32,0)
 ; [.ENDT]       are returned via these parameters
"RTN","RORX012",33,0)
 ;
"RTN","RORX012",34,0)
 ; [.FLAGS]      Flags for the $$SKIP^RORXU005 are
"RTN","RORX012",35,0)
 ;               returned via this parameter
"RTN","RORX012",36,0)
 ;
"RTN","RORX012",37,0)
 ; Return Values:
"RTN","RORX012",38,0)
 ;       <0  Error code
"RTN","RORX012",39,0)
 ;       >0  IEN of the PARAMETERS element
"RTN","RORX012",40,0)
 ;
"RTN","RORX012",41,0)
PARAMS(PARTAG,STDT,ENDT,FLAGS) ;
"RTN","RORX012",42,0)
 N PARAMS,TMP
"RTN","RORX012",43,0)
 S PARAMS=$$PARAMS^RORXU002(.RORTSK,PARTAG,.STDT,.ENDT,.FLAGS)
"RTN","RORX012",44,0)
 Q:PARAMS<0 PARAMS
"RTN","RORX012",45,0)
 ;--- Options
"RTN","RORX012",46,0)
 S RORMODE=$$PARAM^RORTSK01("PATIENTS")
"RTN","RORX012",47,0)
 D LIST^RORXU002(.RORMODE)
"RTN","RORX012",48,0)
 S ROROPT=$$PARAM^RORTSK01("OPTIONS")
"RTN","RORX012",49,0)
 D LIST^RORXU002(.ROROPT)
"RTN","RORX012",50,0)
 ;--- Process the list of drugs and groups
"RTN","RORX012",51,0)
 I $D(ROROPT("PHARMACY"))  D  Q:TMP<0 TMP
"RTN","RORX012",52,0)
 . S TMP=$$DRUGLST^RORXU007(.RORTSK,PARAMS,"RORLRX",.RORXOPT,.RORXGRP)
"RTN","RORX012",53,0)
 ;--- Process the list of Lab tests
"RTN","RORX012",54,0)
 I $D(ROROPT("LAB"))  D  Q:TMP<0 TMP
"RTN","RORX012",55,0)
 . S TMP=$$LTLST^RORXU006(.RORTSK,PARAMS,"RORLTST")
"RTN","RORX012",56,0)
 ;---
"RTN","RORX012",57,0)
 Q PARAMS
"RTN","RORX012",58,0)
 ;
"RTN","RORX012",59,0)
 ;***** COMPILES THE "COMBINED PHARMACY AND LAB" REPORT
"RTN","RORX012",60,0)
 ; REPORT CODE: 012
"RTN","RORX012",61,0)
 ;
"RTN","RORX012",62,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORX012",63,0)
 ;
"RTN","RORX012",64,0)
 ; The ^TMP("RORX012",$J) global node is used by this function.
"RTN","RORX012",65,0)
 ;
"RTN","RORX012",66,0)
 ; ^TMP("RORX012",$J,
"RTN","RORX012",67,0)
 ;   "PAT",
"RTN","RORX012",68,0)
 ;     DFN,              Patient descriptor
"RTN","RORX012",69,0)
 ;                         ^01: Last 4 digits of SSN
"RTN","RORX012",70,0)
 ;                         ^02: Patient name
"RTN","RORX012",71,0)
 ;                         ^03: Clinical AIDS status
"RTN","RORX012",72,0)
 ;       "LR",
"RTN","RORX012",73,0)
 ;         Date,
"RTN","RORX012",74,0)
 ;           TestName,
"RTN","RORX012",75,0)
 ;             TestIEN)  Result
"RTN","RORX012",76,0)
 ;       "RX",
"RTN","RORX012",77,0)
 ;         DrugName,
"RTN","RORX012",78,0)
 ;           DrugIEN)    ""
"RTN","RORX012",79,0)
 ;
"RTN","RORX012",80,0)
 ; Return Values:
"RTN","RORX012",81,0)
 ;       <0  Error code
"RTN","RORX012",82,0)
 ;        0  Ok
"RTN","RORX012",83,0)
 ;
"RTN","RORX012",84,0)
RXANDLAB(RORTSK) ;
"RTN","RORX012",85,0)
 N ROREDT        ; End date
"RTN","RORX012",86,0)
 N ROREDT1       ; End date + 1
"RTN","RORX012",87,0)
 N RORLRX        ; List of selected drugs
"RTN","RORX012",88,0)
 N RORLTST       ; List of lab tests
"RTN","RORX012",89,0)
 N RORMODE       ; Subset of patients to be selected
"RTN","RORX012",90,0)
 N ROROPT        ; Report options
"RTN","RORX012",91,0)
 N RORREG        ; Registry IEN
"RTN","RORX012",92,0)
 N RORSDT        ; Start date
"RTN","RORX012",93,0)
 N RORXGRP       ; List of drug groups
"RTN","RORX012",94,0)
 N RORXOPT       ; Drug options
"RTN","RORX012",95,0)
 ;
"RTN","RORX012",96,0)
 N ECNT,NSPT,RC,REPORT,SFLAGS,TMP
"RTN","RORX012",97,0)
 ;--- Root node of the report
"RTN","RORX012",98,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX012",99,0)
 Q:REPORT<0 REPORT
"RTN","RORX012",100,0)
 ;
"RTN","RORX012",101,0)
 ;--- Get and prepare the report parameters
"RTN","RORX012",102,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")
"RTN","RORX012",103,0)
 S RC=$$PARAMS(REPORT,.RORSDT,.ROREDT,.SFLAGS)  Q:RC<0 RC
"RTN","RORX012",104,0)
 ;
"RTN","RORX012",105,0)
 ;--- Initialize constants and variables
"RTN","RORX012",106,0)
 S ROREDT1=$$FMADD^XLFDT(ROREDT\1,1),ECNT=0
"RTN","RORX012",107,0)
 K ^TMP("RORX012",$J)
"RTN","RORX012",108,0)
 ;
"RTN","RORX012",109,0)
 ;--- Report header
"RTN","RORX012",110,0)
 S RC=$$HEADER(REPORT)  Q:RC<0 RC
"RTN","RORX012",111,0)
 ;
"RTN","RORX012",112,0)
 S RC=0  D
"RTN","RORX012",113,0)
 . ;--- Query the registry
"RTN","RORX012",114,0)
 . D TPPSETUP^RORTSK01(80)
"RTN","RORX012",115,0)
 . S RC=$$QUERY^RORX012A(SFLAGS_"DI",.NSPT)
"RTN","RORX012",116,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX012",117,0)
 . ;--- Store the results
"RTN","RORX012",118,0)
 . D TPPSETUP^RORTSK01(20)
"RTN","RORX012",119,0)
 . S RC=$$STORE^RORX012A(REPORT,NSPT)
"RTN","RORX012",120,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX012",121,0)
 ;
"RTN","RORX012",122,0)
 ;--- Cleanup
"RTN","RORX012",123,0)
 K ^TMP("RORX012",$J)
"RTN","RORX012",124,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX012A")
0^171^B31881502
"RTN","RORX012A",1,0)
RORX012A ;HCIOFO/SG - COMBINED RX AND LAB (QUERY & STORE) ; 12/5/03 10:38am
"RTN","RORX012A",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX012A",3,0)
 ;
"RTN","RORX012A",4,0)
 Q
"RTN","RORX012A",5,0)
 ;
"RTN","RORX012A",6,0)
 ;***** LAB SEARCH CALLBACK
"RTN","RORX012A",7,0)
 ;
"RTN","RORX012A",8,0)
 ; .ROR8DST      Reference to the ROR8DST parameter.
"RTN","RORX012A",9,0)
 ;
"RTN","RORX012A",10,0)
 ; INVDT         IEN of the Lab test (inverted date)
"RTN","RORX012A",11,0)
 ;
"RTN","RORX012A",12,0)
 ; .RESULT       Reference to a local variable, which contains
"RTN","RORX012A",13,0)
 ;               the result (see the $$LTSEARCH^RORUTL10).
"RTN","RORX012A",14,0)
 ;
"RTN","RORX012A",15,0)
 ; Return Values:
"RTN","RORX012A",16,0)
 ;       <0  Error code (the search will be aborted)
"RTN","RORX012A",17,0)
 ;        0  Ok
"RTN","RORX012A",18,0)
 ;        1  Skip this result
"RTN","RORX012A",19,0)
 ;        2  Skip this and all remaining results
"RTN","RORX012A",20,0)
 ;
"RTN","RORX012A",21,0)
LTSCB(ROR8DST,INVDT,RESULT) ;
"RTN","RORX012A",22,0)
 N DATE,DFN,IEN,NAME,TMP
"RTN","RORX012A",23,0)
 S IEN=+RESULT(2)           Q:IEN'>0 1   ; IEN of the Lab test
"RTN","RORX012A",24,0)
 S NAME=$P(RESULT(2),U,2)   Q:NAME="" 1  ; Name of the test
"RTN","RORX012A",25,0)
 S DATE=+$P(RESULT(1),U,2)  Q:DATE'>0 1  ; Date of the test
"RTN","RORX012A",26,0)
 S DFN=+ROR8DST("RORDFN")
"RTN","RORX012A",27,0)
 S @ROR8DST@(DATE,NAME,IEN)=$P(RESULT(1),U,3)
"RTN","RORX012A",28,0)
 Q 0
"RTN","RORX012A",29,0)
 ;
"RTN","RORX012A",30,0)
 ;***** QUERIES THE REGISTRY
"RTN","RORX012A",31,0)
 ;
"RTN","RORX012A",32,0)
 ; FLAGS         Flags for the $$SKIP^RORXU005
"RTN","RORX012A",33,0)
 ; .NSPT         Number of selected patients is returned here
"RTN","RORX012A",34,0)
 ;
"RTN","RORX012A",35,0)
 ; Return Values:
"RTN","RORX012A",36,0)
 ;       <0  Error code
"RTN","RORX012A",37,0)
 ;        0  Ok
"RTN","RORX012A",38,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX012A",39,0)
 ;
"RTN","RORX012A",40,0)
QUERY(FLAGS,NSPT) ;
"RTN","RORX012A",41,0)
 N RORLDST       ; Descriptor for Lab search API
"RTN","RORX012A",42,0)
 N RORPTN        ; Number of patients in the registry
"RTN","RORX012A",43,0)
 N RORXDST       ; Descriptor for pharmacy search API
"RTN","RORX012A",44,0)
 ;
"RTN","RORX012A",45,0)
 N CNT,ECNT,IEN,IENS,LTLP,PATIEN,RC,SKIP,TMP,VA,VADM,XREFNODE
"RTN","RORX012A",46,0)
 S XREFNODE=$NA(^RORDATA(798,"AC",+RORREG))
"RTN","RORX012A",47,0)
 S RORPTN=$$REGSIZE^RORUTL02(+RORREG)  S:RORPTN<0 RORPTN=0
"RTN","RORX012A",48,0)
 S (CNT,ECNT,NSPT)=0
"RTN","RORX012A",49,0)
 ;
"RTN","RORX012A",50,0)
 ;--- Setup the descriptors for callback API's
"RTN","RORX012A",51,0)
 S RC=1
"RTN","RORX012A",52,0)
 I $D(ROROPT("LAB"))  D
"RTN","RORX012A",53,0)
 . I $D(RORLTST("ALL"))  S LTLP="*"
"RTN","RORX012A",54,0)
 . E  S LTLP="RORLTST"  Q:$D(@LTLP)<10
"RTN","RORX012A",55,0)
 . S RORLDST("RORCB")="$$LTSCB^RORX012A"
"RTN","RORX012A",56,0)
 . S RORLDST("RORIDT")=""
"RTN","RORX012A",57,0)
 . S RC=0
"RTN","RORX012A",58,0)
 I $D(ROROPT("PHARMACY"))  D:$D(RORXGRP)>1
"RTN","RORX012A",59,0)
 . S RORXDST("RORCB")="$$RXSCB^RORX012A"
"RTN","RORX012A",60,0)
 . S RORXDST("GENERIC")=($D(RORXOPT("GENERIC"))>0)
"RTN","RORX012A",61,0)
 . S RC=0
"RTN","RORX012A",62,0)
 Q:RC 0
"RTN","RORX012A",63,0)
 ;
"RTN","RORX012A",64,0)
 ;--- Browse through the registry records
"RTN","RORX012A",65,0)
 S IEN=0
"RTN","RORX012A",66,0)
 F  S IEN=$O(@XREFNODE@(IEN))  Q:IEN'>0  D  Q:RC<0
"RTN","RORX012A",67,0)
 . S TMP=$S(RORPTN>0:CNT/RORPTN,1:"")
"RTN","RORX012A",68,0)
 . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX012A",69,0)
 . S IENS=IEN_",",CNT=CNT+1
"RTN","RORX012A",70,0)
 . ;--- Check if the patient should be skipped
"RTN","RORX012A",71,0)
 . Q:$$SKIP^RORXU005(IEN,FLAGS,RORSDT,ROREDT)
"RTN","RORX012A",72,0)
 . ;
"RTN","RORX012A",73,0)
 . ;--- Get the patient IEN (DFN)
"RTN","RORX012A",74,0)
 . S PATIEN=$$PTIEN^RORUTL01(IEN)  Q:PATIEN'>0
"RTN","RORX012A",75,0)
 . ;
"RTN","RORX012A",76,0)
 . D  I RC<0  S ECNT=ECNT+1,RC=0  Q
"RTN","RORX012A",77,0)
 . . S SKIP=1  M RORXDST("RORXGRP")=RORXGRP
"RTN","RORX012A",78,0)
 . . S (RORLDST,RORXDST)=$NA(^TMP("RORX012",$J,"PAT",PATIEN))
"RTN","RORX012A",79,0)
 . . ;--- Search for pharmacy data
"RTN","RORX012A",80,0)
 . . I $D(ROROPT("PHARMACY"))  D  Q:(RC'>0)!($D(RORXDST("RORXGRP"))>1)
"RTN","RORX012A",81,0)
 . . . S RORXDST=$NA(^TMP("RORX012",$J,"PAT",PATIEN,"RX"))
"RTN","RORX012A",82,0)
 . . . S RC=$$RXSEARCH^RORUTL14(PATIEN,"RORLRX",.RORXDST,"EIOV",RORSDT,ROREDT1)
"RTN","RORX012A",83,0)
 . . ;--- Search for Lab data
"RTN","RORX012A",84,0)
 . . I $D(ROROPT("LAB"))  D  Q:RC'>0
"RTN","RORX012A",85,0)
 . . . S RORLDST=$NA(^TMP("RORX012",$J,"PAT",PATIEN,"LR"))
"RTN","RORX012A",86,0)
 . . . S RC=$$LTSEARCH^RORUTL10(PATIEN,LTLP,.RORLDST,,RORSDT,ROREDT1)
"RTN","RORX012A",87,0)
 . . ;---
"RTN","RORX012A",88,0)
 . . S SKIP=0
"RTN","RORX012A",89,0)
 . ;
"RTN","RORX012A",90,0)
 . ;--- Skip the patient if not all search criteria have been met
"RTN","RORX012A",91,0)
 . I SKIP  K ^TMP("RORX012",$J,"PAT",PATIEN)  Q
"RTN","RORX012A",92,0)
 . ;
"RTN","RORX012A",93,0)
 . ;--- Get and store the patient's data
"RTN","RORX012A",94,0)
 . D VADEM^RORUTL05(PATIEN,1)
"RTN","RORX012A",95,0)
 . S TMP=$$CLINAIDS^RORICRUT(IEN,ROREDT)
"RTN","RORX012A",96,0)
 . S ^TMP("RORX012",$J,"PAT",PATIEN)=VA("BID")_U_VADM(1)_U_TMP
"RTN","RORX012A",97,0)
 . S NSPT=NSPT+1
"RTN","RORX012A",98,0)
 ;
"RTN","RORX012A",99,0)
 ;---
"RTN","RORX012A",100,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX012A",101,0)
 ;
"RTN","RORX012A",102,0)
 ;***** CALLBACK FUNCTION FOR THE PHARMACY SEARCH API
"RTN","RORX012A",103,0)
RXSCB(RORDST,ORDER,ORDFLG,DRUG,DATE) ;
"RTN","RORX012A",104,0)
 N GRP,IEN,NAME
"RTN","RORX012A",105,0)
 ;--- Check the droug group
"RTN","RORX012A",106,0)
 S GRP=$P($G(RORLRX(+DRUG)),U)  Q:GRP="" 1
"RTN","RORX012A",107,0)
 K RORDST("RORXGRP",GRP)
"RTN","RORX012A",108,0)
 ;--- Get the drug data
"RTN","RORX012A",109,0)
 I RORDST("GENERIC")  D
"RTN","RORX012A",110,0)
 . S IEN=+RORDST("RORXGEN"),NAME=$P(RORDST("RORXGEN"),U,2)
"RTN","RORX012A",111,0)
 E  S IEN=+DRUG,NAME=$P(DRUG,U,2)
"RTN","RORX012A",112,0)
 Q:(IEN'>0)!(NAME="") 1
"RTN","RORX012A",113,0)
 ;--- Output the data
"RTN","RORX012A",114,0)
 S @RORDST@(NAME,IEN)=""
"RTN","RORX012A",115,0)
 Q 0
"RTN","RORX012A",116,0)
 ;
"RTN","RORX012A",117,0)
 ;***** STORES THE REPORT DATA
"RTN","RORX012A",118,0)
 ;
"RTN","RORX012A",119,0)
 ; REPORT        IEN of the REPORT element
"RTN","RORX012A",120,0)
 ; NSPT          Number of selected patients
"RTN","RORX012A",121,0)
 ;
"RTN","RORX012A",122,0)
 ; Return Values:
"RTN","RORX012A",123,0)
 ;       <0  Error code
"RTN","RORX012A",124,0)
 ;        0  Ok
"RTN","RORX012A",125,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX012A",126,0)
 ;
"RTN","RORX012A",127,0)
STORE(REPORT,NSPT) ;
"RTN","RORX012A",128,0)
 N CNT,DATE,DFN,ECNT,IEN,ITEM,LIST,NAME,NODE,PTAG,PTLIST,RC,TMP
"RTN","RORX012A",129,0)
 S (ECNT,RC)=0
"RTN","RORX012A",130,0)
 ;---
"RTN","RORX012A",131,0)
 S PTLIST=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,REPORT)
"RTN","RORX012A",132,0)
 Q:PTLIST<0 PTLIST
"RTN","RORX012A",133,0)
 D ADDATTR^RORTSK11(RORTSK,PTLIST,"TABLE","PATIENTS")
"RTN","RORX012A",134,0)
 ;---
"RTN","RORX012A",135,0)
 S (CNT,DFN)=0
"RTN","RORX012A",136,0)
 F  S DFN=$O(^TMP("RORX012",$J,"PAT",DFN))  Q:DFN'>0  D  Q:RC<0
"RTN","RORX012A",137,0)
 . S TMP=$S(NSPT>0:CNT/NSPT,1:"")
"RTN","RORX012A",138,0)
 . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX012A",139,0)
 . S CNT=CNT+1,NODE=$NA(^TMP("RORX012",$J,"PAT",DFN))
"RTN","RORX012A",140,0)
 . ;--- Patient's data
"RTN","RORX012A",141,0)
 . S PTAG=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,PTLIST,,DFN)
"RTN","RORX012A",142,0)
 . S TMP=$G(@NODE)
"RTN","RORX012A",143,0)
 . D ADDVAL^RORTSK11(RORTSK,"NAME",$P(TMP,U,2),PTAG,1)
"RTN","RORX012A",144,0)
 . D ADDVAL^RORTSK11(RORTSK,"LAST4",$P(TMP,U),PTAG,2)
"RTN","RORX012A",145,0)
 . D ADDVAL^RORTSK11(RORTSK,"AIDSTAT",$P(TMP,U,3),PTAG,1)
"RTN","RORX012A",146,0)
 . ;--- List of Lab tests
"RTN","RORX012A",147,0)
 . D:$D(@NODE@("LR"))>1
"RTN","RORX012A",148,0)
 . . S LIST=$$ADDVAL^RORTSK11(RORTSK,"PTLRL",,PTAG)
"RTN","RORX012A",149,0)
 . . S DATE=""
"RTN","RORX012A",150,0)
 . . F  S DATE=$O(@NODE@("LR",DATE))  Q:DATE=""  D
"RTN","RORX012A",151,0)
 . . . S NAME=""
"RTN","RORX012A",152,0)
 . . . F  S NAME=$O(@NODE@("LR",DATE,NAME))  Q:NAME=""  D
"RTN","RORX012A",153,0)
 . . . . S IEN=""
"RTN","RORX012A",154,0)
 . . . . F  S IEN=$O(@NODE@("LR",DATE,NAME,IEN))  Q:IEN=""  D
"RTN","RORX012A",155,0)
 . . . . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"LT",,LIST)
"RTN","RORX012A",156,0)
 . . . . . D ADDVAL^RORTSK11(RORTSK,"DATE",DATE\1,ITEM,1)
"RTN","RORX012A",157,0)
 . . . . . D ADDVAL^RORTSK11(RORTSK,"NAME",NAME,ITEM,1)
"RTN","RORX012A",158,0)
 . . . . . S TMP=$G(@NODE@("LR",DATE,NAME,IEN))
"RTN","RORX012A",159,0)
 . . . . . D ADDVAL^RORTSK11(RORTSK,"RESULT",TMP,ITEM,1)
"RTN","RORX012A",160,0)
 . ;--- List of drugs
"RTN","RORX012A",161,0)
 . D:$D(@NODE@("RX"))>1
"RTN","RORX012A",162,0)
 . . S LIST=$$ADDVAL^RORTSK11(RORTSK,"PTRXL",,PTAG)
"RTN","RORX012A",163,0)
 . . S NAME=""
"RTN","RORX012A",164,0)
 . . F  S NAME=$O(@NODE@("RX",NAME))  Q:NAME=""  D
"RTN","RORX012A",165,0)
 . . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"DRUG",,LIST)
"RTN","RORX012A",166,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NAME",NAME,ITEM,1)
"RTN","RORX012A",167,0)
 ;---
"RTN","RORX012A",168,0)
 Q ECNT
"RTN","RORX013")
0^159^B9020068
"RTN","RORX013",1,0)
RORX013 ;HOIFO/SG - DIAGNOSIS CODES REPORT ; 12/10/03 8:20am
"RTN","RORX013",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;March 14, 2003
"RTN","RORX013",3,0)
 ;
"RTN","RORX013",4,0)
 ;--------------------------------------------------------------------
"RTN","RORX013",5,0)
 ; Registry: [VA ICR]
"RTN","RORX013",6,0)
 ;--------------------------------------------------------------------
"RTN","RORX013",7,0)
 Q
"RTN","RORX013",8,0)
 ;
"RTN","RORX013",9,0)
 ;***** OUTPUTS THE REPORT HEADER
"RTN","RORX013",10,0)
 ;
"RTN","RORX013",11,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX013",12,0)
 ;
"RTN","RORX013",13,0)
 ; Return Values:
"RTN","RORX013",14,0)
 ;       <0  Error code
"RTN","RORX013",15,0)
 ;       >0  IEN of the HEADER element
"RTN","RORX013",16,0)
 ;
"RTN","RORX013",17,0)
HEADER(PARTAG) ;
"RTN","RORX013",18,0)
 ;;ICD9LST(#,CODE,DIAG,NP,NC)
"RTN","RORX013",19,0)
 ;;PATIENTS(#,NAME,LAST4,AIDSTAT,PTICDL(CODE,DIAG,DATE))
"RTN","RORX013",20,0)
 ;
"RTN","RORX013",21,0)
 N HEADER,RC
"RTN","RORX013",22,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX013",23,0)
 Q:HEADER<0 HEADER
"RTN","RORX013",24,0)
 S RC=$$TBLDEF^RORXU002("HEADER^RORX013",HEADER)
"RTN","RORX013",25,0)
 Q $S(RC<0:RC,1:HEADER)
"RTN","RORX013",26,0)
 ;
"RTN","RORX013",27,0)
 ;
"RTN","RORX013",28,0)
 ;***** COMPILES THE "DIAGNOSIS CODE" REPORT
"RTN","RORX013",29,0)
 ; REPORT CODE: 013
"RTN","RORX013",30,0)
 ;
"RTN","RORX013",31,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORX013",32,0)
 ;
"RTN","RORX013",33,0)
 ; The ^TMP("RORX013",$J) and ^TMP("VSIT",$J) global nodes are
"RTN","RORX013",34,0)
 ; used by this function.
"RTN","RORX013",35,0)
 ;
"RTN","RORX013",36,0)
 ; ^TMP("RORX013",$J,
"RTN","RORX013",37,0)
 ;
"RTN","RORX013",38,0)
 ;   "PAT",              Number of patients
"RTN","RORX013",39,0)
 ;     DFN,              Descriptor
"RTN","RORX013",40,0)
 ;                         ^01: Las 4 digits of SSN
"RTN","RORX013",41,0)
 ;                         ^02: Name
"RTN","RORX013",42,0)
 ;                         ^03: Clinical AIDS (0/1)
"RTN","RORX013",43,0)
 ;       ICD9IEN,        Earliest date
"RTN","RORX013",44,0)
 ;         "C")          Quantity
"RTN","RORX013",45,0)
 ;
"RTN","RORX013",46,0)
 ;   "ICD",              Totals
"RTN","RORX013",47,0)
 ;                         ^01: Number of ICD-9 codes
"RTN","RORX013",48,0)
 ;                         ^02: Number of different codes
"RTN","RORX013",49,0)
 ;     ICD9IEN,          ICD-9 Descriptor
"RTN","RORX013",50,0)
 ;                         ^01: Code
"RTN","RORX013",51,0)
 ;                         ^02: Diagnosis
"RTN","RORX013",52,0)
 ;       "C")            Quantity
"RTN","RORX013",53,0)
 ;       "P")            Number of unique patients
"RTN","RORX013",54,0)
 ;
"RTN","RORX013",55,0)
 ; Return Values:
"RTN","RORX013",56,0)
 ;       <0  Error code
"RTN","RORX013",57,0)
 ;        0  Ok
"RTN","RORX013",58,0)
 ;
"RTN","RORX013",59,0)
ICD9LST(RORTSK) ;
"RTN","RORX013",60,0)
 N ROREDT        ; End date
"RTN","RORX013",61,0)
 N RORICD9       ; List of ICD9 codes
"RTN","RORX013",62,0)
 N RORMODE       ; Subset of patients to be selected
"RTN","RORX013",63,0)
 N ROROPT        ; Report options
"RTN","RORX013",64,0)
 N RORREG        ; Registry IEN
"RTN","RORX013",65,0)
 N RORSDT        ; Start date
"RTN","RORX013",66,0)
 ;
"RTN","RORX013",67,0)
 N ECNT,RC,REPORT,SFLAGS,TMP
"RTN","RORX013",68,0)
 ;--- Root node of the report
"RTN","RORX013",69,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX013",70,0)
 Q:REPORT<0 REPORT
"RTN","RORX013",71,0)
 ;
"RTN","RORX013",72,0)
 ;--- Get and prepare the report parameters
"RTN","RORX013",73,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")
"RTN","RORX013",74,0)
 S RC=$$PARAMS(REPORT,.RORSDT,.ROREDT,.SFLAGS)  Q:RC<0 RC
"RTN","RORX013",75,0)
 S RORMODE=$$PARAM^RORTSK01("PATIENTS")
"RTN","RORX013",76,0)
 D LIST^RORXU002(.RORMODE)
"RTN","RORX013",77,0)
 S ROROPT=$$PARAM^RORTSK01("OPTIONS")
"RTN","RORX013",78,0)
 D LIST^RORXU002(.ROROPT)
"RTN","RORX013",79,0)
 ;
"RTN","RORX013",80,0)
 ;--- Initialize constants and variables
"RTN","RORX013",81,0)
 S ECNT=0  K ^TMP("RORX013",$J)
"RTN","RORX013",82,0)
 ;
"RTN","RORX013",83,0)
 ;--- Report header
"RTN","RORX013",84,0)
 S RC=$$HEADER(REPORT)  Q:RC<0 RC
"RTN","RORX013",85,0)
 ;
"RTN","RORX013",86,0)
 S RC=0  D
"RTN","RORX013",87,0)
 . ;--- Query the registry
"RTN","RORX013",88,0)
 . D TPPSETUP^RORTSK01(70)
"RTN","RORX013",89,0)
 . S RC=$$QUERY^RORX013A(SFLAGS_"DI")
"RTN","RORX013",90,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX013",91,0)
 . ;--- Sort the data
"RTN","RORX013",92,0)
 . D TPPSETUP^RORTSK01(10)
"RTN","RORX013",93,0)
 . S RC=$$SORT^RORX013A()
"RTN","RORX013",94,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX013",95,0)
 . ;--- Store the results
"RTN","RORX013",96,0)
 . D TPPSETUP^RORTSK01(20)
"RTN","RORX013",97,0)
 . S RC=$$STORE^RORX013C(REPORT)
"RTN","RORX013",98,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX013",99,0)
 ;
"RTN","RORX013",100,0)
 ;--- Cleanup
"RTN","RORX013",101,0)
 K ^TMP("RORX013",$J)
"RTN","RORX013",102,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX013",103,0)
 ;
"RTN","RORX013",104,0)
 ;***** OUTPUTS THE PARAMETERS TO THE REPORT
"RTN","RORX013",105,0)
 ;
"RTN","RORX013",106,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX013",107,0)
 ;
"RTN","RORX013",108,0)
 ; [.STDT]       Start and end dates of the report
"RTN","RORX013",109,0)
 ; [.ENDT]       are returned via these parameters
"RTN","RORX013",110,0)
 ;
"RTN","RORX013",111,0)
 ; [.FLAGS]      Flags for the $$SKIP^RORXU005 are
"RTN","RORX013",112,0)
 ;               returned via this parameter
"RTN","RORX013",113,0)
 ;
"RTN","RORX013",114,0)
 ; Return Values:
"RTN","RORX013",115,0)
 ;       <0  Error code
"RTN","RORX013",116,0)
 ;       >0  IEN of the PARAMETERS element
"RTN","RORX013",117,0)
 ;
"RTN","RORX013",118,0)
PARAMS(PARTAG,STDT,ENDT,FLAGS) ;
"RTN","RORX013",119,0)
 N PARAMS,TMP
"RTN","RORX013",120,0)
 S PARAMS=$$PARAMS^RORXU002(.RORTSK,PARTAG,.STDT,.ENDT,.FLAGS)
"RTN","RORX013",121,0)
 Q:PARAMS<0 PARAMS
"RTN","RORX013",122,0)
 ;--- Process the list of ICD9 codes
"RTN","RORX013",123,0)
 S TMP=$$ICD9LST^RORXU006(.RORTSK,PARAMS,"RORICD9")  Q:TMP<0 TMP
"RTN","RORX013",124,0)
 ;---
"RTN","RORX013",125,0)
 Q PARAMS
"RTN","RORX013A")
0^160^B50024432
"RTN","RORX013A",1,0)
RORX013A ;HCIOFO/SG - DIAGNOSIS CODES (QUERY & SORT) ; 12/10/03 12:27pm
"RTN","RORX013A",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX013A",3,0)
 ;
"RTN","RORX013A",4,0)
 ; This routine uses the following IAs:
"RTN","RORX013A",5,0)
 ;
"RTN","RORX013A",6,0)
 ; #928          ACTIVE^GMPLUTL
"RTN","RORX013A",7,0)
 ; #1554         POV^PXAPIIB (controlled)
"RTN","RORX013A",8,0)
 ; #1900-F       SELECTED^VSIT (controlled)
"RTN","RORX013A",9,0)
 ; #2977         GETFLDS^GMPLEDT3
"RTN","RORX013A",10,0)
 ; #3157         RPC^DGPTFAPI (supported)
"RTN","RORX013A",11,0)
 ; #3545         Access to the "AAD" cross-reference and the field 80
"RTN","RORX013A",12,0)
 ; #3990         ^ICDCODE
"RTN","RORX013A",13,0)
 ; #10082        Read access to the file #80 (supported)
"RTN","RORX013A",14,0)
 ;
"RTN","RORX013A",15,0)
 Q
"RTN","RORX013A",16,0)
 ;
"RTN","RORX013A",17,0)
 ;**** STORES THE ICD-9 CODE
"RTN","RORX013A",18,0)
 ;
"RTN","RORX013A",19,0)
 ; PATIEN        Patient IEN (DFN)
"RTN","RORX013A",20,0)
 ; [ICD9IEN]     IEN of the ICD-9 descriptor in file #80
"RTN","RORX013A",21,0)
 ; DATE          Date when the code was entered
"RTN","RORX013A",22,0)
 ; [ICD9]        ICD-9 code
"RTN","RORX013A",23,0)
 ;
"RTN","RORX013A",24,0)
 ; Either the ICD9IEN or the ICD9 parameter must be provided.
"RTN","RORX013A",25,0)
 ;
"RTN","RORX013A",26,0)
 ; Return Values:
"RTN","RORX013A",27,0)
 ;       <0  Error code
"RTN","RORX013A",28,0)
 ;        0  Ok
"RTN","RORX013A",29,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX013A",30,0)
 ;
"RTN","RORX013A",31,0)
ICD9SET(PATIEN,ICD9IEN,DATE,ICD9) ;
"RTN","RORX013A",32,0)
 Q:DATE'>0
"RTN","RORX013A",33,0)
 N TMP
"RTN","RORX013A",34,0)
 I $G(ICD9IEN)'>0  Q:$G(ICD9)=""  D  Q:ICD9IEN'>0
"RTN","RORX013A",35,0)
 . S ICD9IEN=+$$CODEN^ICDCODE(ICD9,80)
"RTN","RORX013A",36,0)
 I '$D(RORICD9("ALL")) Q:'$D(RORICD9(ICD9IEN))
"RTN","RORX013A",37,0)
 S TMP=+$G(^TMP("RORX013",$J,"PAT",PATIEN,ICD9IEN))
"RTN","RORX013A",38,0)
 S:'TMP!(DATE<TMP) ^TMP("RORX013",$J,"PAT",PATIEN,ICD9IEN)=DATE
"RTN","RORX013A",39,0)
 S ^("C")=$G(^TMP("RORX013",$J,"PAT",PATIEN,ICD9IEN,"C"))+1
"RTN","RORX013A",40,0)
 Q
"RTN","RORX013A",41,0)
 ;
"RTN","RORX013A",42,0)
 ;***** SEARCHES FOR INPATIENT DIAGNOSES
"RTN","RORX013A",43,0)
 ;
"RTN","RORX013A",44,0)
 ; PATIEN        Patient IEN (DFN)
"RTN","RORX013A",45,0)
 ;
"RTN","RORX013A",46,0)
 ; Return Values:
"RTN","RORX013A",47,0)
 ;       <0  Error code
"RTN","RORX013A",48,0)
 ;        0  Ok
"RTN","RORX013A",49,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX013A",50,0)
 ;
"RTN","RORX013A",51,0)
INPAT(PATIEN) ;
"RTN","RORX013A",52,0)
 N ADMDT,DISDT,I,IEN,NODE,RC,RORBUF,RORMSG,TMP
"RTN","RORX013A",53,0)
 S NODE=$NA(^DGPT("AAD",+PATIEN))
"RTN","RORX013A",54,0)
 S RC=0
"RTN","RORX013A",55,0)
 ;--- Browse through the admissions
"RTN","RORX013A",56,0)
 S ADMDT=ROREDT1
"RTN","RORX013A",57,0)
 F  S ADMDT=$O(@NODE@(ADMDT),-1)  Q:ADMDT'>0  D  Q:RC
"RTN","RORX013A",58,0)
 . S IEN=""
"RTN","RORX013A",59,0)
 . F  S IEN=$O(@NODE@(ADMDT,IEN),-1)  Q:IEN'>0  D  Q:RC
"RTN","RORX013A",60,0)
 . . Q:+$G(^DGPT(IEN,0))'=PATIEN
"RTN","RORX013A",61,0)
 . . Q:$$PTF^RORXU001(IEN,"P",,.DISDT)
"RTN","RORX013A",62,0)
 . . ;--- Skip invalid and/or incomplete admissions
"RTN","RORX013A",63,0)
 . . I DISDT'>0  D  Q:TMP!(DISDT'>0)
"RTN","RORX013A",64,0)
 . . . S TMP=$$CHKADM^RORXU001(PATIEN,ADMDT,.DISDT)
"RTN","RORX013A",65,0)
 . . ;--- Check if any appropriate admissions are left
"RTN","RORX013A",66,0)
 . . I DISDT<RORSDT  S RC=1  Q
"RTN","RORX013A",67,0)
 . . Q:DISDT'<ROREDT1
"RTN","RORX013A",68,0)
 . . ;--- Load and process the admission data
"RTN","RORX013A",69,0)
 . . K RORBUF  D RPC^DGPTFAPI(.RORBUF,IEN)
"RTN","RORX013A",70,0)
 . . I $G(RORBUF(0))<0  D  Q
"RTN","RORX013A",71,0)
 . . . D ERROR^RORERR(-57,,,,RORBUF(0),"RPC^DGPTFAPI")
"RTN","RORX013A",72,0)
 . . S TMP=$P($G(RORBUF(1)),U,3)
"RTN","RORX013A",73,0)
 . . D:TMP'="" ICD9SET(PATIEN,,DISDT,TMP)  ; ICD1
"RTN","RORX013A",74,0)
 . . D:$G(RORBUF(2))'=""                   ; ICD2 - ICD10
"RTN","RORX013A",75,0)
 . . . F I=1:1:9  S TMP=$P(RORBUF(2),U,I)  D:TMP'=""
"RTN","RORX013A",76,0)
 . . . . D ICD9SET(PATIEN,,DISDT,TMP)
"RTN","RORX013A",77,0)
 . . S TMP=$$GET1^DIQ(45,IEN,80,"I",,"RORMSG")
"RTN","RORX013A",78,0)
 . . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,45,IEN)
"RTN","RORX013A",79,0)
 . . D:TMP>0 ICD9SET(PATIEN,TMP,DISDT)     ; PRINCIPAL DIAGNOSIS
"RTN","RORX013A",80,0)
 ;---
"RTN","RORX013A",81,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORX013A",82,0)
 ;
"RTN","RORX013A",83,0)
 ;***** SEARCHES FOR OUTPATIENT DIAGNOSES
"RTN","RORX013A",84,0)
 ;
"RTN","RORX013A",85,0)
 ; PATIEN        Patient IEN (DFN)
"RTN","RORX013A",86,0)
 ;
"RTN","RORX013A",87,0)
 ; Return Values:
"RTN","RORX013A",88,0)
 ;       <0  Error code
"RTN","RORX013A",89,0)
 ;        0  Ok
"RTN","RORX013A",90,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX013A",91,0)
 ;
"RTN","RORX013A",92,0)
OUTPAT(PATIEN) ;
"RTN","RORX013A",93,0)
 N DATE,ICDIEN,RC,RORMSG,RORVPLST,TMP,VPIEN,VSIEN,VSIT
"RTN","RORX013A",94,0)
 D SELECTED^VSIT(PATIEN,RORSDT,ROREDT)
"RTN","RORX013A",95,0)
 ;--- Browse through the visits
"RTN","RORX013A",96,0)
 S (VSIEN,RC)=0
"RTN","RORX013A",97,0)
 F  S VSIEN=$O(^TMP("VSIT",$J,VSIEN))  Q:VSIEN=""  D  Q:RC<0
"RTN","RORX013A",98,0)
 . S TMP=+$O(^TMP("VSIT",$J,VSIEN,""))  Q:TMP'>0
"RTN","RORX013A",99,0)
 . S DATE=$P($G(^TMP("VSIT",$J,VSIEN,TMP)),U)  Q:DATE'>0
"RTN","RORX013A",100,0)
 . ;--- Get a list of V POV records
"RTN","RORX013A",101,0)
 . D POV^PXAPIIB(VSIEN,.RORVPLST)
"RTN","RORX013A",102,0)
 . ;--- Process the records
"RTN","RORX013A",103,0)
 . S (VPIEN,RC)=0
"RTN","RORX013A",104,0)
 . F  S VPIEN=$O(RORVPLST(VPIEN))  Q:VPIEN'>0  D  Q:RC
"RTN","RORX013A",105,0)
 . . S ICDIEN=$P(RORVPLST(VPIEN),U)
"RTN","RORX013A",106,0)
 . . D:ICDIEN>0 ICD9SET(PATIEN,ICDIEN,DATE)
"RTN","RORX013A",107,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORX013A",108,0)
 ;
"RTN","RORX013A",109,0)
 ;***** SEARCHES FOR PROBLEMS
"RTN","RORX013A",110,0)
 ;
"RTN","RORX013A",111,0)
 ; PATIEN        Patient IEN (DFN)
"RTN","RORX013A",112,0)
 ;
"RTN","RORX013A",113,0)
 ; Return Values:
"RTN","RORX013A",114,0)
 ;       <0  Error code
"RTN","RORX013A",115,0)
 ;        0  Ok
"RTN","RORX013A",116,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX013A",117,0)
 ;
"RTN","RORX013A",118,0)
PROBLEM(PATIEN) ;
"RTN","RORX013A",119,0)
 N DATE,GMPFLD,GMPORIG,GMPROV,GMVAMC,ICDIEN,IEN,RC,RORPLST,TMP
"RTN","RORX013A",120,0)
 ;--- Load a list of active problems
"RTN","RORX013A",121,0)
 D ACTIVE^GMPLUTL(PATIEN,.RORPLST)
"RTN","RORX013A",122,0)
 ;--- Browse through the problems
"RTN","RORX013A",123,0)
 S (GMPVAMC,GMPROV)=0
"RTN","RORX013A",124,0)
 S (IS,RC)=0
"RTN","RORX013A",125,0)
 F  S IS=$O(RORPLST(IS))  Q:IS=""  D  Q:RC
"RTN","RORX013A",126,0)
 . S IEN=+$G(RORPLST(IS,0))  Q:IEN'>0
"RTN","RORX013A",127,0)
 . K GMPFLD,GMPORIG  D GETFLDS^GMPLEDT3(IEN)
"RTN","RORX013A",128,0)
 . S ICDIEN=+$G(GMPFLD(.01))  Q:ICDIEN'>0
"RTN","RORX013A",129,0)
 . S DATE=$P($G(GMPFLD(.08)),U)
"RTN","RORX013A",130,0)
 . D:(DATE'<RORSDT)&(DATE<ROREDT1) ICD9SET(PATIEN,ICDIEN,DATE)
"RTN","RORX013A",131,0)
 Q 0
"RTN","RORX013A",132,0)
 ;
"RTN","RORX013A",133,0)
 ;***** QUERIES THE REGISTRY
"RTN","RORX013A",134,0)
 ;
"RTN","RORX013A",135,0)
 ; FLAGS         Flags for the $$SKIP^RORXU005
"RTN","RORX013A",136,0)
 ;
"RTN","RORX013A",137,0)
 ; Return Values:
"RTN","RORX013A",138,0)
 ;       <0  Error code
"RTN","RORX013A",139,0)
 ;        0  Ok
"RTN","RORX013A",140,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX013A",141,0)
 ;
"RTN","RORX013A",142,0)
QUERY(FLAGS) ;
"RTN","RORX013A",143,0)
 N RORCAT        ; Clinical AIDS status (0/1)
"RTN","RORX013A",144,0)
 N ROREDT1       ; Day after the end date
"RTN","RORX013A",145,0)
 N RORLAST4      ; Last 4 digits of the current patient's SSN
"RTN","RORX013A",146,0)
 N RORPNAME      ; Name of the current patient
"RTN","RORX013A",147,0)
 N RORPTN        ; Number of patients in the registry
"RTN","RORX013A",148,0)
 ;
"RTN","RORX013A",149,0)
 N CNT,ECNT,IEN,IENS,PATIEN,RC,TMP,VA,VADM,XREFNODE
"RTN","RORX013A",150,0)
 S XREFNODE=$NA(^RORDATA(798,"AC",+RORREG))
"RTN","RORX013A",151,0)
 S RORPTN=$$REGSIZE^RORUTL02(+RORREG)  S:RORPTN<0 RORPTN=0
"RTN","RORX013A",152,0)
 S ROREDT1=$$FMADD^XLFDT(ROREDT\1,1)
"RTN","RORX013A",153,0)
 S (CNT,ECNT,RC)=0
"RTN","RORX013A",154,0)
 ;
"RTN","RORX013A",155,0)
 ;--- Browse through the registry records
"RTN","RORX013A",156,0)
 S IEN=0
"RTN","RORX013A",157,0)
 F  S IEN=$O(@XREFNODE@(IEN))  Q:IEN'>0  D  Q:RC<0
"RTN","RORX013A",158,0)
 . S TMP=$S(RORPTN>0:CNT/RORPTN,1:"")
"RTN","RORX013A",159,0)
 . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX013A",160,0)
 . S IENS=IEN_",",CNT=CNT+1
"RTN","RORX013A",161,0)
 . ;--- Check if the patient should be skipped
"RTN","RORX013A",162,0)
 . Q:$$SKIP^RORXU005(IEN,FLAGS,RORSDT,ROREDT)
"RTN","RORX013A",163,0)
 . ;
"RTN","RORX013A",164,0)
 . ;--- Get the patient IEN (DFN)
"RTN","RORX013A",165,0)
 . S PATIEN=$$PTIEN^RORUTL01(IEN)  Q:PATIEN'>0
"RTN","RORX013A",166,0)
 . ;
"RTN","RORX013A",167,0)
 . ;--- Get the category
"RTN","RORX013A",168,0)
 . S RORCAT=$$CLINAIDS^RORICRUT(IEN,ROREDT)
"RTN","RORX013A",169,0)
 . S TMP=$S(RORCAT:"AIDS",1:"HIV")
"RTN","RORX013A",170,0)
 . Q:'$D(RORMODE(TMP))
"RTN","RORX013A",171,0)
 . ;
"RTN","RORX013A",172,0)
 . ;--- Inpatient codes
"RTN","RORX013A",173,0)
 . S RC=$$INPAT(PATIEN)
"RTN","RORX013A",174,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX013A",175,0)
 . ;
"RTN","RORX013A",176,0)
 . ;--- Outpatient codes
"RTN","RORX013A",177,0)
 . S RC=$$OUTPAT(PATIEN)
"RTN","RORX013A",178,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX013A",179,0)
 . ;
"RTN","RORX013A",180,0)
 . ;--- Problem list
"RTN","RORX013A",181,0)
 . S RC=$$PROBLEM(PATIEN)
"RTN","RORX013A",182,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX013A",183,0)
 . ;
"RTN","RORX013A",184,0)
 . ;--- Skip the patient if no data has been found
"RTN","RORX013A",185,0)
 . Q:$D(^TMP("RORX013",$J,"PAT",PATIEN))<10
"RTN","RORX013A",186,0)
 . ;--- Get the patient's data
"RTN","RORX013A",187,0)
 . D VADEM^RORUTL05(PATIEN,1)
"RTN","RORX013A",188,0)
 . S RORPNAME=VADM(1),RORLAST4=VA("BID")
"RTN","RORX013A",189,0)
 . ;
"RTN","RORX013A",190,0)
 . ;--- Calculate the patient's totals
"RTN","RORX013A",191,0)
 . S RC=$$TOTALS(PATIEN)
"RTN","RORX013A",192,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX013A",193,0)
 ;---
"RTN","RORX013A",194,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX013A",195,0)
 ;
"RTN","RORX013A",196,0)
 ;***** SORTS THE RESULTS AND COMPILES THE TOTALS
"RTN","RORX013A",197,0)
 ;
"RTN","RORX013A",198,0)
 ; Return Values:
"RTN","RORX013A",199,0)
 ;       <0  Error code
"RTN","RORX013A",200,0)
 ;        0  Ok
"RTN","RORX013A",201,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX013A",202,0)
 ;
"RTN","RORX013A",203,0)
SORT() ;
"RTN","RORX013A",204,0)
 N ICDIEN,TMP,TNC,TNDC
"RTN","RORX013A",205,0)
 ;---
"RTN","RORX013A",206,0)
 S ICDIEN=0,(TNC,TNDC)=0
"RTN","RORX013A",207,0)
 F  S ICDIEN=$O(^TMP("RORX013",$J,"ICD",ICDIEN))  Q:ICDIEN'>0  D
"RTN","RORX013A",208,0)
 . S TNC=TNC+$G(^TMP("RORX013",$J,"ICD",ICDIEN,"C"))
"RTN","RORX013A",209,0)
 . S TNDC=TNDC+1
"RTN","RORX013A",210,0)
 S ^TMP("RORX013",$J,"ICD")=TNC_U_TNDC
"RTN","RORX013A",211,0)
 ;---
"RTN","RORX013A",212,0)
 Q 0
"RTN","RORX013A",213,0)
 ;
"RTN","RORX013A",214,0)
 ;***** CALCULATES INTERMEDIATE TOTALS
"RTN","RORX013A",215,0)
 ;
"RTN","RORX013A",216,0)
 ; PATIEN        Patient IEN (DFN)
"RTN","RORX013A",217,0)
 ;
"RTN","RORX013A",218,0)
 ; Return Values:
"RTN","RORX013A",219,0)
 ;       <0  Error code
"RTN","RORX013A",220,0)
 ;        0  Ok
"RTN","RORX013A",221,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX013A",222,0)
 ;
"RTN","RORX013A",223,0)
TOTALS(PATIEN) ;
"RTN","RORX013A",224,0)
 N ICD9,ICDIEN,IENS,PNODE,RC,RORBUF,RORMSG,TMP
"RTN","RORX013A",225,0)
 S PNODE=$NA(^TMP("RORX013",$J,"PAT",PATIEN))
"RTN","RORX013A",226,0)
 S @PNODE=RORLAST4_U_RORPNAME_U_RORCAT
"RTN","RORX013A",227,0)
 S ^("PAT")=$G(^TMP("RORX013",$J,"PAT"))+1
"RTN","RORX013A",228,0)
 ;
"RTN","RORX013A",229,0)
 S ICDIEN=0
"RTN","RORX013A",230,0)
 F  S ICDIEN=$O(@PNODE@(ICDIEN))  Q:ICDIEN'>0  D
"RTN","RORX013A",231,0)
 . S ICD9=$P($G(^TMP("RORX013",$J,"ICD",ICDIEN)),U)
"RTN","RORX013A",232,0)
 . I ICD9=""  D  K RORBUF
"RTN","RORX013A",233,0)
 . . S IENS=ICDIEN_","
"RTN","RORX013A",234,0)
 . . D GETS^DIQ(80,IENS,".01;3",,"RORBUF","RORMSG")
"RTN","RORX013A",235,0)
 . . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,80,IENS)
"RTN","RORX013A",236,0)
 . . S ICD9=$G(RORBUF(80,IENS,.01))  S:ICD9="" ICD9="UNKN"
"RTN","RORX013A",237,0)
 . . S TMP=$G(RORBUF(80,IENS,3))  S:TMP="" TMP="Unknown ("_ICDIEN_")"
"RTN","RORX013A",238,0)
 . . S ^TMP("RORX013",$J,"ICD",ICDIEN)=ICD9_U_TMP
"RTN","RORX013A",239,0)
 . ;---
"RTN","RORX013A",240,0)
 . S TMP=$G(@PNODE@(ICDIEN,"C"))
"RTN","RORX013A",241,0)
 . S ^("C")=$G(^TMP("RORX013",$J,"ICD",ICDIEN,"C"))+TMP
"RTN","RORX013A",242,0)
 . S ^("P")=$G(^TMP("RORX013",$J,"ICD",ICDIEN,"P"))+1
"RTN","RORX013A",243,0)
 Q 0
"RTN","RORX013C")
0^161^B10582758
"RTN","RORX013C",1,0)
RORX013C ;HCIOFO/SG - DIAGNOSIS CODES (STORE) ; 12/10/03 8:06am
"RTN","RORX013C",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;Feb 09, 1998
"RTN","RORX013C",3,0)
 ;
"RTN","RORX013C",4,0)
 Q
"RTN","RORX013C",5,0)
 ;
"RTN","RORX013C",6,0)
 ;***** STORES THE ICD-9 CODE TABLE
"RTN","RORX013C",7,0)
 ;
"RTN","RORX013C",8,0)
 ; PTAG          IEN of the parent element
"RTN","RORX013C",9,0)
 ;
"RTN","RORX013C",10,0)
 ; NODE          Closed root of the node of the temporary global
"RTN","RORX013C",11,0)
 ;
"RTN","RORX013C",12,0)
 ; Return Values:
"RTN","RORX013C",13,0)
 ;       <0  Error code
"RTN","RORX013C",14,0)
 ;        0  Ok
"RTN","RORX013C",15,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX013C",16,0)
 ;
"RTN","RORX013C",17,0)
CODES(PTAG,NODE) ;
"RTN","RORX013C",18,0)
 N ICDIEN,ITEM,TABLE,TMP
"RTN","RORX013C",19,0)
 S TABLE=$$ADDVAL^RORTSK11(RORTSK,"ICD9LST",,PTAG)
"RTN","RORX013C",20,0)
 Q:TABLE<0 TABLE
"RTN","RORX013C",21,0)
 D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","ICD9LST")
"RTN","RORX013C",22,0)
 S ICDIEN=0
"RTN","RORX013C",23,0)
 F  S ICDIEN=$O(@NODE@("ICD",ICDIEN))  Q:ICDIEN'>0  D
"RTN","RORX013C",24,0)
 . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"ICD9",,TABLE)
"RTN","RORX013C",25,0)
 . S TMP=@NODE@("ICD",ICDIEN)
"RTN","RORX013C",26,0)
 . D ADDVAL^RORTSK11(RORTSK,"CODE",$P(TMP,U,1),ITEM,2)
"RTN","RORX013C",27,0)
 . D ADDVAL^RORTSK11(RORTSK,"DIAG",$P(TMP,U,2),ITEM,2)
"RTN","RORX013C",28,0)
 . S TMP=$G(@NODE@("ICD",ICDIEN,"P"))
"RTN","RORX013C",29,0)
 . D ADDVAL^RORTSK11(RORTSK,"NP",TMP,ITEM,3)
"RTN","RORX013C",30,0)
 . S TMP=$G(@NODE@("ICD",ICDIEN,"C"))
"RTN","RORX013C",31,0)
 . D ADDVAL^RORTSK11(RORTSK,"NC",TMP,ITEM,3)
"RTN","RORX013C",32,0)
 Q 0
"RTN","RORX013C",33,0)
 ;
"RTN","RORX013C",34,0)
 ;***** STORES THE PATIENT TABLE
"RTN","RORX013C",35,0)
 ;
"RTN","RORX013C",36,0)
 ; PTAG          IEN of the parent element
"RTN","RORX013C",37,0)
 ;
"RTN","RORX013C",38,0)
 ; NODE          Closed root of the node of the temporary global
"RTN","RORX013C",39,0)
 ;
"RTN","RORX013C",40,0)
 ; Return Values:
"RTN","RORX013C",41,0)
 ;       <0  Error code
"RTN","RORX013C",42,0)
 ;        0  Ok
"RTN","RORX013C",43,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX013C",44,0)
 ;
"RTN","RORX013C",45,0)
PATIENTS(PTAG,NODE) ;
"RTN","RORX013C",46,0)
 N PATIEN,ICD9,ICDIEN,ITEM,PTICDL,TABLE,TMP
"RTN","RORX013C",47,0)
 S TABLE=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,PTAG)
"RTN","RORX013C",48,0)
 Q:TABLE<0 TABLE
"RTN","RORX013C",49,0)
 D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","PATIENTS")
"RTN","RORX013C",50,0)
 S PATIEN=0
"RTN","RORX013C",51,0)
 F  S PATIEN=$O(@NODE@("PAT",PATIEN))  Q:PATIEN'>0  D
"RTN","RORX013C",52,0)
 . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,TABLE)
"RTN","RORX013C",53,0)
 . S TMP=@NODE@("PAT",PATIEN)
"RTN","RORX013C",54,0)
 . D ADDVAL^RORTSK11(RORTSK,"NAME",$P(TMP,U,2),ITEM,2)
"RTN","RORX013C",55,0)
 . D ADDVAL^RORTSK11(RORTSK,"LAST4",$P(TMP,U,1),ITEM,2)
"RTN","RORX013C",56,0)
 . D ADDVAL^RORTSK11(RORTSK,"AIDSTAT",+$P(TMP,U,3),ITEM,3)
"RTN","RORX013C",57,0)
 . S PTICDL=$$ADDVAL^RORTSK11(RORTSK,"PTICDL",,ITEM)
"RTN","RORX013C",58,0)
 . S ICDIEN=0
"RTN","RORX013C",59,0)
 . F  S ICDIEN=$O(@NODE@("PAT",PATIEN,ICDIEN))  Q:ICDIEN'>0  D
"RTN","RORX013C",60,0)
 . . S ICD9=$$ADDVAL^RORTSK11(RORTSK,"ICD9",,PTICDL)
"RTN","RORX013C",61,0)
 . . S TMP=@NODE@("ICD",ICDIEN)
"RTN","RORX013C",62,0)
 . . D ADDVAL^RORTSK11(RORTSK,"CODE",$P(TMP,U,1),ICD9,2)
"RTN","RORX013C",63,0)
 . . D ADDVAL^RORTSK11(RORTSK,"DIAG",$P(TMP,U,2),ICD9,2)
"RTN","RORX013C",64,0)
 . . S TMP=$G(@NODE@("PAT",PATIEN,ICDIEN))
"RTN","RORX013C",65,0)
 . . D ADDVAL^RORTSK11(RORTSK,"DATE",$P(TMP,U)\1,ICD9,1)
"RTN","RORX013C",66,0)
 Q 0
"RTN","RORX013C",67,0)
 ;
"RTN","RORX013C",68,0)
 ;***** STORES THE REPORT DATA
"RTN","RORX013C",69,0)
 ;
"RTN","RORX013C",70,0)
 ; REPORT        IEN of the REPORT element
"RTN","RORX013C",71,0)
 ;
"RTN","RORX013C",72,0)
 ; Return Values:
"RTN","RORX013C",73,0)
 ;       <0  Error code
"RTN","RORX013C",74,0)
 ;        0  Ok
"RTN","RORX013C",75,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX013C",76,0)
 ;
"RTN","RORX013C",77,0)
STORE(REPORT) ;
"RTN","RORX013C",78,0)
 N ECNT,ICDIEN,NODE,PATIEN,RC,SECTION,TMP
"RTN","RORX013C",79,0)
 S NODE=$NA(^TMP("RORX013",$J))
"RTN","RORX013C",80,0)
 S (ECNT,RC)=0
"RTN","RORX013C",81,0)
 ;--- Diagnosis codes
"RTN","RORX013C",82,0)
 S RC=$$CODES(REPORT,NODE)
"RTN","RORX013C",83,0)
 I RC  Q:RC<0 RC  S ECNT=ECNT+RC
"RTN","RORX013C",84,0)
 S RC=$$LOOP^RORTSK01(.4)  Q:RC<0 RC
"RTN","RORX013C",85,0)
 ;--- Patients
"RTN","RORX013C",86,0)
 I $D(ROROPT("COMPLETE"))  D  I RC  Q:RC<0 RC  S ECNT=ECNT+RC
"RTN","RORX013C",87,0)
 . S RC=$$PATIENTS(REPORT,NODE)
"RTN","RORX013C",88,0)
 S RC=$$LOOP^RORTSK01(.99)  Q:RC<0 RC
"RTN","RORX013C",89,0)
 ;--- Totals
"RTN","RORX013C",90,0)
 S SECTION=$$ADDVAL^RORTSK11(RORTSK,"SUMMARY",,REPORT)
"RTN","RORX013C",91,0)
 Q:SECTION<0 SECTION
"RTN","RORX013C",92,0)
 S TMP=$G(@NODE@("ICD"))
"RTN","RORX013C",93,0)
 D ADDVAL^RORTSK11(RORTSK,"NC",+$P(TMP,U,1),SECTION)
"RTN","RORX013C",94,0)
 D ADDVAL^RORTSK11(RORTSK,"NDC",+$P(TMP,U,2),SECTION)
"RTN","RORX013C",95,0)
 S TMP=$G(@NODE@("PAT"))
"RTN","RORX013C",96,0)
 D ADDVAL^RORTSK11(RORTSK,"NP",+TMP,SECTION)
"RTN","RORX013C",97,0)
 ;---
"RTN","RORX013C",98,0)
 Q ECNT
"RTN","RORX014")
0^164^B10017478
"RTN","RORX014",1,0)
RORX014 ;HOIFO/SG - ARV COMBINATION REPORT ; 12/5/03 8:23am
"RTN","RORX014",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;March 14, 2003
"RTN","RORX014",3,0)
 ;
"RTN","RORX014",4,0)
 ;--------------------------------------------------------------------
"RTN","RORX014",5,0)
 ; Registry: [VA ICR]
"RTN","RORX014",6,0)
 ;--------------------------------------------------------------------
"RTN","RORX014",7,0)
 Q
"RTN","RORX014",8,0)
 ;
"RTN","RORX014",9,0)
 ;***** COMPILES THE "ARV COMBINATION" REPORT
"RTN","RORX014",10,0)
 ; REPORT CODE: 014
"RTN","RORX014",11,0)
 ;
"RTN","RORX014",12,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORX014",13,0)
 ;
"RTN","RORX014",14,0)
 ; The ^TMP("RORX014",$J) and ^TMP("RORX014D",$J) global
"RTN","RORX014",15,0)
 ; nodes are used by this function.
"RTN","RORX014",16,0)
 ;
"RTN","RORX014",17,0)
 ; ^TMP("RORX014",$J,
"RTN","RORX014",18,0)
 ;   "DRG",
"RTN","RORX014",19,0)
 ;     DrugIEN)          Generic drug name
"RTN","RORX014",20,0)
 ;   "RXC",
"RTN","RORX014",21,0)
 ;     RxcIEN,
"RTN","RORX014",22,0)
 ;       1)              List of Drug IEN's separated by ","
"RTN","RORX014",23,0)
 ;       "P"             Number of patients
"RTN","RORX014",24,0)
 ;         DFN)          Patient Descriptor
"RTN","RORX014",25,0)
 ;                         ^01: Las 4 digits of SSN
"RTN","RORX014",26,0)
 ;                         ^02: Name
"RTN","RORX014",27,0)
 ;                         ^03: Clinical AIDS (0/1)
"RTN","RORX014",28,0)
 ;     "B",
"RTN","RORX014",29,0)
 ;       RxcNdx,
"RTN","RORX014",30,0)
 ;         RxcIEN)       ""
"RTN","RORX014",31,0)
 ;     "P",
"RTN","RORX014",32,0)
 ;       NumOfPat,
"RTN","RORX014",33,0)
 ;         RxcIEN)       ""
"RTN","RORX014",34,0)
 ;
"RTN","RORX014",35,0)
 ; RxcNdx is the frist 100 characters of the list of Drug IEN's.
"RTN","RORX014",36,0)
 ;
"RTN","RORX014",37,0)
 ; Return Values:
"RTN","RORX014",38,0)
 ;       <0  Error code
"RTN","RORX014",39,0)
 ;        0  Ok
"RTN","RORX014",40,0)
 ;
"RTN","RORX014",41,0)
ARVCOMB(RORTSK) ;
"RTN","RORX014",42,0)
 N ROREDT        ; End date
"RTN","RORX014",43,0)
 N ROREDT1       ; End date + 1
"RTN","RORX014",44,0)
 N RORMODE       ; Subset of patients to be selected
"RTN","RORX014",45,0)
 N ROROPT        ; Report options
"RTN","RORX014",46,0)
 N RORREG        ; Registry IEN
"RTN","RORX014",47,0)
 N RORSDT        ; Start date
"RTN","RORX014",48,0)
 N RORXOPT       ; Drug options
"RTN","RORX014",49,0)
 ;
"RTN","RORX014",50,0)
 N ECNT,NRXC,RC,REPORT,SFLAGS,TMP
"RTN","RORX014",51,0)
 ;--- Root node of the report
"RTN","RORX014",52,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX014",53,0)
 Q:REPORT<0 REPORT
"RTN","RORX014",54,0)
 ;
"RTN","RORX014",55,0)
 ;--- Get and prepare the report parameters
"RTN","RORX014",56,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")
"RTN","RORX014",57,0)
 S RC=$$PARAMS(REPORT,.RORSDT,.ROREDT,.SFLAGS)
"RTN","RORX014",58,0)
 Q:RC<0 RC
"RTN","RORX014",59,0)
 S RORMODE=$$PARAM^RORTSK01("PATIENTS")
"RTN","RORX014",60,0)
 D LIST^RORXU002(.RORMODE)
"RTN","RORX014",61,0)
 S ROROPT=$$PARAM^RORTSK01("OPTIONS")
"RTN","RORX014",62,0)
 D LIST^RORXU002(.ROROPT)
"RTN","RORX014",63,0)
 ;
"RTN","RORX014",64,0)
 ;--- Initialize constants and variables
"RTN","RORX014",65,0)
 S ROREDT1=$$FMADD^XLFDT(ROREDT\1,1),ECNT=0
"RTN","RORX014",66,0)
 K ^TMP("RORX014",$J)
"RTN","RORX014",67,0)
 ;
"RTN","RORX014",68,0)
 ;--- Report header
"RTN","RORX014",69,0)
 S RC=$$HEADER(REPORT)  Q:RC<0 RC
"RTN","RORX014",70,0)
 ;
"RTN","RORX014",71,0)
 S RC=0  D
"RTN","RORX014",72,0)
 . ;--- Query the registry
"RTN","RORX014",73,0)
 . D TPPSETUP^RORTSK01(80)
"RTN","RORX014",74,0)
 . S RC=$$QUERY^RORX014A(SFLAGS_"DI")
"RTN","RORX014",75,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX014",76,0)
 . ;--- Sort the data
"RTN","RORX014",77,0)
 . D TPPSETUP^RORTSK01(5)
"RTN","RORX014",78,0)
 . S RC=$$SORT^RORX014A(.NRXC)
"RTN","RORX014",79,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX014",80,0)
 . ;--- Store the results
"RTN","RORX014",81,0)
 . D TPPSETUP^RORTSK01(15)
"RTN","RORX014",82,0)
 . S RC=$$STORE^RORX014A(REPORT,NRXC)
"RTN","RORX014",83,0)
 . I RC  Q:RC<0  S ECNT=ECNT+RC
"RTN","RORX014",84,0)
 ;
"RTN","RORX014",85,0)
 ;--- Cleanup
"RTN","RORX014",86,0)
 K ^TMP("RORX014",$J),^TMP("RORX014D",$J)
"RTN","RORX014",87,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX014",88,0)
 ;
"RTN","RORX014",89,0)
 ;***** OUTPUTS THE REPORT HEADER
"RTN","RORX014",90,0)
 ;
"RTN","RORX014",91,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX014",92,0)
 ;
"RTN","RORX014",93,0)
 ; Return Values:
"RTN","RORX014",94,0)
 ;       <0  Error code
"RTN","RORX014",95,0)
 ;       >0  IEN of the HEADER element
"RTN","RORX014",96,0)
 ;
"RTN","RORX014",97,0)
HEADER(PARTAG) ;
"RTN","RORX014",98,0)
 ;;RXCOMBLST(NP,PATIENTS(NAME,LAST4,AIDSTAT))^I $D(ROROPT("COMPLETE"))
"RTN","RORX014",99,0)
 ;;RXCOMBLST(NP,RXCOMB)^I $D(ROROPT("SUMMARY"))
"RTN","RORX014",100,0)
 ;
"RTN","RORX014",101,0)
 N HEADER,RC
"RTN","RORX014",102,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX014",103,0)
 Q:HEADER<0 HEADER
"RTN","RORX014",104,0)
 S RC=$$TBLDEF^RORXU002("HEADER^RORX014",HEADER)
"RTN","RORX014",105,0)
 Q $S(RC<0:RC,1:HEADER)
"RTN","RORX014",106,0)
 ;
"RTN","RORX014",107,0)
 ;***** OUTPUTS THE PARAMETERS TO THE REPORT
"RTN","RORX014",108,0)
 ;
"RTN","RORX014",109,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX014",110,0)
 ;
"RTN","RORX014",111,0)
 ; [.STDT]       Start and end dates of the report
"RTN","RORX014",112,0)
 ; [.ENDT]       are returned via these parameters
"RTN","RORX014",113,0)
 ;
"RTN","RORX014",114,0)
 ; [.FLAGS]      Flags for the $$SKIP^RORXU005 are
"RTN","RORX014",115,0)
 ;               returned via this parameter
"RTN","RORX014",116,0)
 ;
"RTN","RORX014",117,0)
 ; Return Values:
"RTN","RORX014",118,0)
 ;       <0  Error code
"RTN","RORX014",119,0)
 ;       >0  IEN of the PARAMETERS element
"RTN","RORX014",120,0)
 ;
"RTN","RORX014",121,0)
PARAMS(PARTAG,STDT,ENDT,FLAGS) ;
"RTN","RORX014",122,0)
 N PARAMS,RC
"RTN","RORX014",123,0)
 S PARAMS=$$PARAMS^RORXU002(.RORTSK,PARTAG,.STDT,.ENDT,.FLAGS)
"RTN","RORX014",124,0)
 Q:PARAMS<0 PARAMS
"RTN","RORX014",125,0)
 ;--- Process the drug options
"RTN","RORX014",126,0)
 S RC=$$DRUGLST^RORXU007(.RORTSK,PARAMS,,.RORXOPT)
"RTN","RORX014",127,0)
 Q:RC<0 RC
"RTN","RORX014",128,0)
 ;---
"RTN","RORX014",129,0)
 Q PARAMS
"RTN","RORX014A")
0^172^B28744511
"RTN","RORX014A",1,0)
RORX014A ;HOIFO/BH,SG - ARV COMBINATION REPORT (QUERY & SORT) ; 1/24/04 12:16pm
"RTN","RORX014A",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORX014A",3,0)
 ;
"RTN","RORX014A",4,0)
 Q
"RTN","RORX014A",5,0)
 ;
"RTN","RORX014A",6,0)
 ;***** ADDS THE DRUG COMBINATION TO THE REPORT
"RTN","RORX014A",7,0)
 ;
"RTN","RORX014A",8,0)
 ; RXLST         List of drug IEN's separated by commas
"RTN","RORX014A",9,0)
 ; PATIEN        Patient IEN in file #2 (DFN)
"RTN","RORX014A",10,0)
 ; CLINAIDS      Clinical AIDS (0/1)
"RTN","RORX014A",11,0)
 ;
"RTN","RORX014A",12,0)
ADD(RXLST,PATIEN,CLINAIDS) ;
"RTN","RORX014A",13,0)
 N RXCIEN,RXCNDX,TMP,VA,VADM,VAERR
"RTN","RORX014A",14,0)
 S RXCNDX=$E(RXLST,1,100)
"RTN","RORX014A",15,0)
 ;--- Search for the combination
"RTN","RORX014A",16,0)
 S RXCIEN=""
"RTN","RORX014A",17,0)
 F  D  Q:RXCIEN=""  Q:^TMP("RORX014",$J,"RXC",RXCIEN,1)=RXLST
"RTN","RORX014A",18,0)
 . S RXCIEN=$O(^TMP("RORX014",$J,"RXC","B",RXCNDX,RXCIEN))
"RTN","RORX014A",19,0)
 ;--- Add new combination
"RTN","RORX014A",20,0)
 D:RXCIEN'>0
"RTN","RORX014A",21,0)
 . S RXCIEN=$O(^TMP("RORX014",$J,"RXC"," "),-1)+1
"RTN","RORX014A",22,0)
 . S ^TMP("RORX014",$J,"RXC",RXCIEN,1)=RXLST
"RTN","RORX014A",23,0)
 . S ^TMP("RORX014",$J,"RXC","B",RXCNDX,RXCIEN)=""
"RTN","RORX014A",24,0)
 ;--- Add new patient
"RTN","RORX014A",25,0)
 S ^("P")=$G(^TMP("RORX014",$J,"RXC",RXCIEN,"P"))+1
"RTN","RORX014A",26,0)
 D VADEM^RORUTL05(PATIEN,1)
"RTN","RORX014A",27,0)
 S TMP=VA("BID")_U_VADM(1)_U_CLINAIDS
"RTN","RORX014A",28,0)
 S ^TMP("RORX014",$J,"RXC",RXCIEN,"P",PATIEN)=TMP
"RTN","RORX014A",29,0)
 Q
"RTN","RORX014A",30,0)
 ;
"RTN","RORX014A",31,0)
 ;***** QUERIES THE REGISTRY
"RTN","RORX014A",32,0)
 ;
"RTN","RORX014A",33,0)
 ; FLAGS         Flags for the $$SKIP^RORXU005
"RTN","RORX014A",34,0)
 ;
"RTN","RORX014A",35,0)
 ; Return Values:
"RTN","RORX014A",36,0)
 ;       <0  Error code
"RTN","RORX014A",37,0)
 ;        0  Ok
"RTN","RORX014A",38,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX014A",39,0)
 ;
"RTN","RORX014A",40,0)
QUERY(FLAGS) ;
"RTN","RORX014A",41,0)
 N RORPTN        ; Number of patients in the registry
"RTN","RORX014A",42,0)
 N RORXDST       ; Descriptor for pharmacy search API
"RTN","RORX014A",43,0)
 ;
"RTN","RORX014A",44,0)
 N CNT,DRGIEN,ECNT,NAME,PATIEN,RC,RORIEN,RORXL,RXFLAGS,STR,TMP,XREFNODE
"RTN","RORX014A",45,0)
 ;
"RTN","RORX014A",46,0)
 S XREFNODE=$NA(^RORDATA(798,"AC",+RORREG))
"RTN","RORX014A",47,0)
 S RORPTN=$$REGSIZE^RORUTL02(+RORREG)  S:RORPTN<0 RORPTN=0
"RTN","RORX014A",48,0)
 S (CNT,ECNT,RC)=0
"RTN","RORX014A",49,0)
 ;
"RTN","RORX014A",50,0)
 ;--- Prepare parameters for the pharmacy search API
"RTN","RORX014A",51,0)
 S RORXDST=$NA(RORXDST("RORX014"))
"RTN","RORX014A",52,0)
 S RORXDST("RORCB")="$$RXSCB^RORX014A"
"RTN","RORX014A",53,0)
 S RXFLAGS="E"
"RTN","RORX014A",54,0)
 S:$D(RORMODE("INPATIENT")) RXFLAGS=RXFLAGS_"IV"
"RTN","RORX014A",55,0)
 S:$D(RORMODE("OUTPATIENT")) RXFLAGS=RXFLAGS_"O"
"RTN","RORX014A",56,0)
 Q:RXFLAGS="E" 0
"RTN","RORX014A",57,0)
 ;
"RTN","RORX014A",58,0)
 ;--- Compile the list of ARV drugs and classes
"RTN","RORX014A",59,0)
 S RORXL=$NA(^TMP("RORX014D",$J))
"RTN","RORX014A",60,0)
 S TMP="DGR"  S:$D(RORXOPT("INVESTIG")) TMP=TMP_"C"
"RTN","RORX014A",61,0)
 S RC=$$DRUGLIST^RORUTL16(RORXL,+RORREG,TMP)
"RTN","RORX014A",62,0)
 Q:RC<0 RC
"RTN","RORX014A",63,0)
 ;
"RTN","RORX014A",64,0)
 ;--- Browse through the registry records
"RTN","RORX014A",65,0)
 S RORIEN=0
"RTN","RORX014A",66,0)
 F  S RORIEN=$O(@XREFNODE@(RORIEN))  Q:RORIEN'>0  D  Q:RC<0
"RTN","RORX014A",67,0)
 . S TMP=$S(RORPTN>0:CNT/RORPTN,1:"")
"RTN","RORX014A",68,0)
 . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX014A",69,0)
 . S CNT=CNT+1
"RTN","RORX014A",70,0)
 . ;--- Check if the patient should be skipped
"RTN","RORX014A",71,0)
 . Q:$$SKIP^RORXU005(RORIEN,FLAGS,RORSDT,ROREDT)
"RTN","RORX014A",72,0)
 . ;
"RTN","RORX014A",73,0)
 . ;--- Get the patient IEN (DFN)
"RTN","RORX014A",74,0)
 . S PATIEN=$$PTIEN^RORUTL01(RORIEN)  Q:PATIEN'>0
"RTN","RORX014A",75,0)
 . ;
"RTN","RORX014A",76,0)
 . ;--- Search for pharmacy data
"RTN","RORX014A",77,0)
 . S TMP=$$RXSEARCH^RORUTL14(PATIEN,RORXL,.RORXDST,RXFLAGS,RORSDT,ROREDT1)
"RTN","RORX014A",78,0)
 . I TMP'>0  S:TMP<0 ECNT=ECNT+1  Q:$D(@RORXDST)<10
"RTN","RORX014A",79,0)
 . ;
"RTN","RORX014A",80,0)
 . S (NAME,STR)=""
"RTN","RORX014A",81,0)
 . F  S NAME=$O(@RORXDST@(NAME))  Q:NAME=""  D
"RTN","RORX014A",82,0)
 . . S DRGIEN=0
"RTN","RORX014A",83,0)
 . . F  S DRGIEN=$O(@RORXDST@(NAME,DRGIEN))  Q:DRGIEN'>0  D
"RTN","RORX014A",84,0)
 . . . S ^TMP("RORX014",$J,"DRG",DRGIEN)=NAME
"RTN","RORX014A",85,0)
 . . . S STR=STR_","_DRGIEN
"RTN","RORX014A",86,0)
 . K @RORXDST
"RTN","RORX014A",87,0)
 . ;
"RTN","RORX014A",88,0)
 . S TMP=$$CLINAIDS^RORICRUT(RORIEN,ROREDT)
"RTN","RORX014A",89,0)
 . D ADD($P(STR,",",2,999),PATIEN,TMP)
"RTN","RORX014A",90,0)
 ;
"RTN","RORX014A",91,0)
 ;---
"RTN","RORX014A",92,0)
 Q $S(RC<0:RC,1:ECNT)
"RTN","RORX014A",93,0)
 ;
"RTN","RORX014A",94,0)
 ;***** CALLBACK FUNCTION FOR THE PHARMACY SEARCH API
"RTN","RORX014A",95,0)
RXSCB(RORDST,ORDER,ORDFLG,DRUG,DATE) ;
"RTN","RORX014A",96,0)
 N IEN,NAME
"RTN","RORX014A",97,0)
 S IEN=+RORDST("RORXGEN"),NAME=$P(RORDST("RORXGEN"),U,2)
"RTN","RORX014A",98,0)
 Q:(IEN'>0)!(NAME="") 1
"RTN","RORX014A",99,0)
 S @RORDST@(NAME,IEN)=""
"RTN","RORX014A",100,0)
 Q 0
"RTN","RORX014A",101,0)
 ;
"RTN","RORX014A",102,0)
 ;***** SORTS THE RESULTS AND COMPILES THE TOTALS
"RTN","RORX014A",103,0)
 ;
"RTN","RORX014A",104,0)
 ; NRXC          Number of drug combinations
"RTN","RORX014A",105,0)
 ;
"RTN","RORX014A",106,0)
 ; Return Values:
"RTN","RORX014A",107,0)
 ;       <0  Error code
"RTN","RORX014A",108,0)
 ;        0  Ok
"RTN","RORX014A",109,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX014A",110,0)
 ;
"RTN","RORX014A",111,0)
SORT(NRXC) ;
"RTN","RORX014A",112,0)
 N IEN,TMP
"RTN","RORX014A",113,0)
 S (IEN,NRXC)=0
"RTN","RORX014A",114,0)
 F  S IEN=$O(^TMP("RORX014",$J,"RXC",IEN))  Q:IEN'>0  D
"RTN","RORX014A",115,0)
 . S TMP=^TMP("RORX014",$J,"RXC",IEN,"P")
"RTN","RORX014A",116,0)
 . S ^TMP("RORX014",$J,"RXC","P",TMP,IEN)="",NRXC=NRXC+1
"RTN","RORX014A",117,0)
 Q 0
"RTN","RORX014A",118,0)
 ;
"RTN","RORX014A",119,0)
 ;***** STORES THE REPORT DATA
"RTN","RORX014A",120,0)
 ;
"RTN","RORX014A",121,0)
 ; REPORT        IEN of the REPORT element
"RTN","RORX014A",122,0)
 ; NRXC          Number of drug combinations
"RTN","RORX014A",123,0)
 ;
"RTN","RORX014A",124,0)
 ; Return Values:
"RTN","RORX014A",125,0)
 ;       <0  Error code
"RTN","RORX014A",126,0)
 ;        0  Ok
"RTN","RORX014A",127,0)
 ;       >0  Number of non-fatal errors
"RTN","RORX014A",128,0)
 ;
"RTN","RORX014A",129,0)
STORE(REPORT,NRXC) ;
"RTN","RORX014A",130,0)
 N BUF,CNT,DRG,ITEM,NODE,PATIEN,RORI,RXCIEN,RXCNT,RXCOMB,SECTION,TABLE,VA,VADM,VAERR
"RTN","RORX014A",131,0)
 S NODE=$NA(^TMP("RORX014",$J))
"RTN","RORX014A",132,0)
 S SECTION=$$ADDVAL^RORTSK11(RORTSK,"RXCOMBLST",,REPORT)
"RTN","RORX014A",133,0)
 Q:SECTION<0 SECTION
"RTN","RORX014A",134,0)
 D ADDATTR^RORTSK11(RORTSK,SECTION,"TABLE","RXCOMBLST")
"RTN","RORX014A",135,0)
 ;---
"RTN","RORX014A",136,0)
 Q:NRXC'>0 0
"RTN","RORX014A",137,0)
 ;---
"RTN","RORX014A",138,0)
 S RXCNT="",CNT=0
"RTN","RORX014A",139,0)
 F  S RXCNT=$O(@NODE@("RXC","P",RXCNT),-1)  Q:RXCNT=""  D
"RTN","RORX014A",140,0)
 . S RC=$$LOOP^RORTSK01(CNT/NRXC),CNT=CNT+1  Q:RC<0
"RTN","RORX014A",141,0)
 . S RXCIEN=""
"RTN","RORX014A",142,0)
 . F  S RXCIEN=$O(@NODE@("RXC","P",RXCNT,RXCIEN),-1)  Q:RXCIEN=""  D
"RTN","RORX014A",143,0)
 . . S RXCOMB=$$ADDVAL^RORTSK11(RORTSK,"RXCOMB",,SECTION)
"RTN","RORX014A",144,0)
 . . ;--- List of drugs
"RTN","RORX014A",145,0)
 . . S TABLE=$$ADDVAL^RORTSK11(RORTSK,"DRUGS",,RXCOMB)
"RTN","RORX014A",146,0)
 . . S BUF=@NODE@("RXC",RXCIEN,1)
"RTN","RORX014A",147,0)
 . . F RORI=1:1  S DRG=$P(BUF,",",RORI)  Q:DRG=""  D
"RTN","RORX014A",148,0)
 . . . S DRG=$P(^TMP("RORX014",$J,"DRG",DRG),U)
"RTN","RORX014A",149,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NAME",DRG,TABLE,1)
"RTN","RORX014A",150,0)
 . . ;--- Number of unique patients
"RTN","RORX014A",151,0)
 . . D ADDVAL^RORTSK11(RORTSK,"NP",RXCNT,RXCOMB,3)
"RTN","RORX014A",152,0)
 . . ;--- List of patients
"RTN","RORX014A",153,0)
 . . Q:'$D(ROROPT("COMPLETE"))
"RTN","RORX014A",154,0)
 . . S TABLE=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,RXCOMB)
"RTN","RORX014A",155,0)
 . . D ADDATTR^RORTSK11(RORTSK,TABLE,"TABLE","PATIENTS")
"RTN","RORX014A",156,0)
 . . S PATIEN=""
"RTN","RORX014A",157,0)
 . . F  S PATIEN=$O(@NODE@("RXC",RXCIEN,"P",PATIEN))  Q:PATIEN=""  D
"RTN","RORX014A",158,0)
 . . . S BUF=@NODE@("RXC",RXCIEN,"P",PATIEN)
"RTN","RORX014A",159,0)
 . . . S ITEM=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,TABLE,,PATIEN)
"RTN","RORX014A",160,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"NAME",$P(BUF,U,2),ITEM,1)
"RTN","RORX014A",161,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"LAST4",$P(BUF,U),ITEM,2)
"RTN","RORX014A",162,0)
 . . . D ADDVAL^RORTSK11(RORTSK,"AIDSTAT",+$P(BUF,U,3),ITEM,1)
"RTN","RORX014A",163,0)
 Q 0
"RTN","RORXU001")
0^109^B12637299
"RTN","RORXU001",1,0)
RORXU001 ;HCIOFO/BH,SG - REPORT UTILITIES  ; 1/12/04 10:52am
"RTN","RORXU001",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORXU001",3,0)
 ;
"RTN","RORXU001",4,0)
 ; This routine uses the following IAs:
"RTN","RORXU001",5,0)
 ;
"RTN","RORXU001",6,0)
 ; #92           Read access to the file #45 (controlled)
"RTN","RORXU001",7,0)
 ;               fields 3 and 4.
"RTN","RORXU001",8,0)
 ; #1480         Read access to the file #405 (controlled)
"RTN","RORXU001",9,0)
 ; #1894         ENCEVENT^PXKENC (controlled)
"RTN","RORXU001",10,0)
 ;
"RTN","RORXU001",11,0)
 Q
"RTN","RORXU001",12,0)
 ;
"RTN","RORXU001",13,0)
 ;***** DOUBLE CHECKS THE ADMISSION
"RTN","RORXU001",14,0)
 ;
"RTN","RORXU001",15,0)
 ; DFN           Patient IEN
"RTN","RORXU001",16,0)
 ; VAINDT        Admission date
"RTN","RORXU001",17,0)
 ; .DISDT        Discharge date
"RTN","RORXU001",18,0)
 ;
"RTN","RORXU001",19,0)
 ; Return Values:
"RTN","RORXU001",20,0)
 ;        0  Ok
"RTN","RORXU001",21,0)
 ;        1  Invalid admission date
"RTN","RORXU001",22,0)
 ;
"RTN","RORXU001",23,0)
CHKADM(DFN,VAINDT,DISDT) ;
"RTN","RORXU001",24,0)
 N IEN,RORMSG,VADMVT,VAHOW,VAROOT
"RTN","RORXU001",25,0)
 D ADM^VADPT2  Q:'VADMVT 1
"RTN","RORXU001",26,0)
 S IEN=+$$GET1^DIQ(405,VADMVT,.17,"I",,"RORMSG")
"RTN","RORXU001",27,0)
 S:IEN>0 DISDT=$$GET1^DIQ(405,IEN_",",.01,"I",,"RORMSG")
"RTN","RORXU001",28,0)
 Q 0
"RTN","RORXU001",29,0)
 ;
"RTN","RORXU001",30,0)
 ;***** DATE OF THE MOST RECENT VISIT TO ANY OF THE SELECTED CLINICS
"RTN","RORXU001",31,0)
 ;
"RTN","RORXU001",32,0)
 ; PATIEN        Patient IEN (file #2)
"RTN","RORXU001",33,0)
 ;
"RTN","RORXU001",34,0)
 ; .RORCLIN      Reference to a local array of Clinics, the subscripts
"RTN","RORXU001",35,0)
 ;               are IEN's from file #44 or will be a single element
"RTN","RORXU001",36,0)
 ;               array with a subscript of "ALL", which will denote
"RTN","RORXU001",37,0)
 ;               all clinics (i.e. CLIN("ALL")="").
"RTN","RORXU001",38,0)
 ;
"RTN","RORXU001",39,0)
 ; Return Values:
"RTN","RORXU001",40,0)
 ;        0  The patient has never been seen at any of the given
"RTN","RORXU001",41,0)
 ;           clinics
"RTN","RORXU001",42,0)
 ;       >0  Date of the most recent visit to one of the selected
"RTN","RORXU001",43,0)
 ;           clinics
"RTN","RORXU001",44,0)
 ;
"RTN","RORXU001",45,0)
LASTVSIT(PATIEN,RORCLIN) ;
"RTN","RORXU001",46,0)
 N QUERY,RORDT,RORLAST
"RTN","RORXU001",47,0)
 S RORDT=$$FMADD^XLFDT($$DT^XLFDT,1),RORLAST=0
"RTN","RORXU001",48,0)
 ;---
"RTN","RORXU001",49,0)
 D OPEN^SDQ(.QUERY)
"RTN","RORXU001",50,0)
 D INDEX^SDQ(.QUERY,"PATIENT","SET")
"RTN","RORXU001",51,0)
 D PAT^SDQ(.QUERY,PATIEN,"SET")
"RTN","RORXU001",52,0)
 D SCANCB^SDQ(.QUERY,"D SDQSCAN2^RORXU001(Y,Y0)","SET")
"RTN","RORXU001",53,0)
 D ACTIVE^SDQ(.QUERY,"TRUE","SET")
"RTN","RORXU001",54,0)
 D SCAN^SDQ(.QUERY,"FORWARD")
"RTN","RORXU001",55,0)
 D CLOSE^SDQ(.QUERY)
"RTN","RORXU001",56,0)
 ;---
"RTN","RORXU001",57,0)
 Q RORLAST
"RTN","RORXU001",58,0)
 ;
"RTN","RORXU001",59,0)
 ;***** LOADS PTF DATA AND CHECKS IF THE RECORD SHOULD BE SKIPPED
"RTN","RORXU001",60,0)
 ;
"RTN","RORXU001",61,0)
 ; PTFIEN        IEN of the PTF record
"RTN","RORXU001",62,0)
 ;
"RTN","RORXU001",63,0)
 ; [FLAGS]       Flags to control processing
"RTN","RORXU001",64,0)
 ;                 F  Skip fee-basis records
"RTN","RORXU001",65,0)
 ;                 P  Skip non-PTF records
"RTN","RORXU001",66,0)
 ;
"RTN","RORXU001",67,0)
 ; [.ADMDT]      Admission date is returned via this parameter
"RTN","RORXU001",68,0)
 ; [.DISDT]      Discharge date is returned via this parameter
"RTN","RORXU001",69,0)
 ; [.SUFFIX]     Suffix is returned via this parameter
"RTN","RORXU001",70,0)
 ; [.STATUS]     Status is returned via this parameter
"RTN","RORXU001",71,0)
 ; [.FACILITY]   Facility number is returned via this parameter
"RTN","RORXU001",72,0)
 ;
"RTN","RORXU001",73,0)
 ; Return Values:
"RTN","RORXU001",74,0)
 ;       <0  Error code
"RTN","RORXU001",75,0)
 ;        0  Ok
"RTN","RORXU001",76,0)
 ;        1  Skip this record
"RTN","RORXU001",77,0)
 ;
"RTN","RORXU001",78,0)
PTF(PTFIEN,FLAGS,ADMDT,DISDT,SUFFIX,STATUS,FACILITY) ;
"RTN","RORXU001",79,0)
 N FLDLST,IENS,RORBUF,RORMSG
"RTN","RORXU001",80,0)
 S FLAGS=$G(FLAGS),IENS=(+PTFIEN)_","
"RTN","RORXU001",81,0)
 S FLDLST="2;3;5;6;70"
"RTN","RORXU001",82,0)
 S:FLAGS["F" FLDLST=FLDLST_";4"        ; FEE BASIS
"RTN","RORXU001",83,0)
 S:FLAGS["P" FLDLST=FLDLST_";11"       ; TYPE OF RECORD
"RTN","RORXU001",84,0)
 ;--- Load the data
"RTN","RORXU001",85,0)
 D GETS^DIQ(45,IENS,FLDLST,"I","RORBUF","RORMSG")
"RTN","RORXU001",86,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,45,IENS)
"RTN","RORXU001",87,0)
 ;---
"RTN","RORXU001",88,0)
 S ADMDT=$G(RORBUF(45,IENS,2,"I"))     ; ADMISSION DATE
"RTN","RORXU001",89,0)
 S FACILITY=$G(RORBUF(45,IENS,3,"I"))  ; FACILITY
"RTN","RORXU001",90,0)
 S SUFFIX=$G(RORBUF(45,IENS,5,"I"))    ; SUFFIX
"RTN","RORXU001",91,0)
 S STATUS=$G(RORBUF(45,IENS,6,"I"))    ; STATUS
"RTN","RORXU001",92,0)
 S DISDT=$G(RORBUF(45,IENS,70,"I"))    ; DISCHARGE DATE
"RTN","RORXU001",93,0)
 Q:ADMDT'>0 1
"RTN","RORXU001",94,0)
 ;--- Skip a non-PTF record
"RTN","RORXU001",95,0)
 I FLAGS["P"  Q:$G(RORBUF(45,IENS,11,"I"))'=1 1
"RTN","RORXU001",96,0)
 ;--- Skip a fee basis record
"RTN","RORXU001",97,0)
 I FLAGS["F"  Q:$G(RORBUF(45,IENS,4,"I")) 1
"RTN","RORXU001",98,0)
 ;--- Success
"RTN","RORXU001",99,0)
 Q 0
"RTN","RORXU001",100,0)
 ;
"RTN","RORXU001",101,0)
 ;**** CALL-BACK ENTRY POINTS FOR THE SDQ API
"RTN","RORXU001",102,0)
SDQSCAN1(Y,Y0) ;
"RTN","RORXU001",103,0)
 ;--- Check the clinic
"RTN","RORXU001",104,0)
 I '$D(RORCLIN("ALL"))  Q:'$D(RORCLIN(+$P(Y0,U,4)))
"RTN","RORXU001",105,0)
 ;--- Count the encounters
"RTN","RORXU001",106,0)
 S RORENCNT=RORENCNT+1
"RTN","RORXU001",107,0)
 Q
"RTN","RORXU001",108,0)
 ;
"RTN","RORXU001",109,0)
SDQSCAN2(Y,Y0) ;
"RTN","RORXU001",110,0)
 N DTX
"RTN","RORXU001",111,0)
 ;--- Check the clinic
"RTN","RORXU001",112,0)
 I '$D(RORCLIN("ALL"))  Q:'$D(RORCLIN(+$P(Y0,U,4)))
"RTN","RORXU001",113,0)
 ;--- Date of the visit
"RTN","RORXU001",114,0)
 S DTX=+$P(Y0,U)  S:(DTX>RORLAST)&(DTX<RORDT) RORLAST=DTX
"RTN","RORXU001",115,0)
 Q
"RTN","RORXU001",116,0)
 ;
"RTN","RORXU001",117,0)
 ;***** CHECKS IF THE PATIENT WAS SEEN AT SELECTED CLINICS
"RTN","RORXU001",118,0)
 ;
"RTN","RORXU001",119,0)
 ; RORSDT        Start Date for search (FileMan).
"RTN","RORXU001",120,0)
 ;               Time is ignored and the beginning of the day is
"RTN","RORXU001",121,0)
 ;               considered as the boundary (ST\1).
"RTN","RORXU001",122,0)
 ;
"RTN","RORXU001",123,0)
 ; ROREDT        End Date for search (FileMan).
"RTN","RORXU001",124,0)
 ;               Time is ignored and the end of the day is
"RTN","RORXU001",125,0)
 ;               considered as the boundary (ED\1+1).
"RTN","RORXU001",126,0)
 ;
"RTN","RORXU001",127,0)
 ; PATIEN        Patient IEN (file #2)
"RTN","RORXU001",128,0)
 ;
"RTN","RORXU001",129,0)
 ; .RORCLIN      Reference to a local array of Clinics, the subscripts
"RTN","RORXU001",130,0)
 ;               are IEN's from file #44 or will be a single element
"RTN","RORXU001",131,0)
 ;               array with a subscript of "ALL", which will denote
"RTN","RORXU001",132,0)
 ;               all clinics (i.e. RORCLIN("ALL")="").
"RTN","RORXU001",133,0)
 ;
"RTN","RORXU001",134,0)
 ; Return Values:
"RTN","RORXU001",135,0)
 ;        0  The patient was not seen at any of the given clinics
"RTN","RORXU001",136,0)
 ;           during the provided time frame
"RTN","RORXU001",137,0)
 ;        1  The patient was seen
"RTN","RORXU001",138,0)
 ; 
"RTN","RORXU001",139,0)
SEEN(RORSDT,ROREDT,PATIEN,RORCLIN) ;
"RTN","RORXU001",140,0)
 N QUERY,RORENCNT
"RTN","RORXU001",141,0)
 S RORENCNT=0
"RTN","RORXU001",142,0)
 ;---
"RTN","RORXU001",143,0)
 D OPEN^SDQ(.QUERY)
"RTN","RORXU001",144,0)
 D INDEX^SDQ(.QUERY,"PATIENT/DATE","SET")
"RTN","RORXU001",145,0)
 D PAT^SDQ(.QUERY,PATIEN,"SET")
"RTN","RORXU001",146,0)
 D DATE^SDQ(.QUERY,RORSDT\1,$$FMADD^XLFDT(ROREDT\1,1),"SET")
"RTN","RORXU001",147,0)
 D SCANCB^SDQ(.QUERY,"D SDQSCAN1^RORXU001(Y,Y0)","SET")
"RTN","RORXU001",148,0)
 D ACTIVE^SDQ(.QUERY,"TRUE","SET")
"RTN","RORXU001",149,0)
 D SCAN^SDQ(.QUERY,"FORWARD")
"RTN","RORXU001",150,0)
 D CLOSE^SDQ(.QUERY)
"RTN","RORXU001",151,0)
 ;---
"RTN","RORXU001",152,0)
 Q (RORENCNT>0)
"RTN","RORXU002")
0^140^B50867342
"RTN","RORXU002",1,0)
RORXU002 ;HCIOFO/SG - REPORT BUILDER UTILITIES ; 1/8/04 5:26pm
"RTN","RORXU002",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORXU002",3,0)
 ;
"RTN","RORXU002",4,0)
 Q
"RTN","RORXU002",5,0)
 ;
"RTN","RORXU002",6,0)
 ;***** SCANS THE TABLE DEFINITION (RORSRC) FOR COLUMN NAMES
"RTN","RORXU002",7,0)
 ;
"RTN","RORXU002",8,0)
 ; .TERM         Reference to a local variable where
"RTN","RORXU002",9,0)
 ;               is terminator is returned
"RTN","RORXU002",10,0)
 ;
"RTN","RORXU002",11,0)
 ; Return Values:
"RTN","RORXU002",12,0)
 ;       ""  End of definition
"RTN","RORXU002",13,0)
 ;      ...  Name of the column
"RTN","RORXU002",14,0)
 ;
"RTN","RORXU002",15,0)
COLSCAN(TERM) ;
"RTN","RORXU002",16,0)
 N CH,I,TOKEN
"RTN","RORXU002",17,0)
 F I=1:1  S TERM=$E(RORSRC,I)  Q:"(,)"[TERM
"RTN","RORXU002",18,0)
 S TOKEN=$E(RORSRC,1,I-1)
"RTN","RORXU002",19,0)
 F I=I+1:1  S CH=$E(RORSRC,I)  Q:(CH="")!("(,)"'[CH)
"RTN","RORXU002",20,0)
 S $E(RORSRC,1,I-1)=""
"RTN","RORXU002",21,0)
 Q TOKEN
"RTN","RORXU002",22,0)
 ;
"RTN","RORXU002",23,0)
 ;***** CHECKS THE FILEMAN DATE/TIME VALUE
"RTN","RORXU002",24,0)
DATE(DT) ;
"RTN","RORXU002",25,0)
 Q $S(DT>0:+DT,1:"")
"RTN","RORXU002",26,0)
 ;
"RTN","RORXU002",27,0)
 ;***** GETS THE START AND END DATES FROM THE DATE RANGE
"RTN","RORXU002",28,0)
 ;
"RTN","RORXU002",29,0)
 ; RANGE         Date range
"RTN","RORXU002",30,0)
 ;
"RTN","RORXU002",31,0)
 ; .STDT         Reference to a local variable where
"RTN","RORXU002",32,0)
 ;               the start date is returned to
"RTN","RORXU002",33,0)
 ;
"RTN","RORXU002",34,0)
 ; .ENDT         Reference to a local variable where
"RTN","RORXU002",35,0)
 ;               the end date is returned to
"RTN","RORXU002",36,0)
 ;
"RTN","RORXU002",37,0)
 ; Return Values:
"RTN","RORXU002",38,0)
 ;       <0  Error code
"RTN","RORXU002",39,0)
 ;        0  Ok
"RTN","RORXU002",40,0)
 ;
"RTN","RORXU002",41,0)
 ; NOTE: In case of an error the function does not change
"RTN","RORXU002",42,0)
 ;       values of the STDT and ENDT parameters.
"RTN","RORXU002",43,0)
 ;
"RTN","RORXU002",44,0)
DTRANGE(RANGE,STDT,ENDT) ;
"RTN","RORXU002",45,0)
 N ENDT1,FISCAL,QUARTER,RC,RORMSG,STDT1,TMP,TYPE,YEAR
"RTN","RORXU002",46,0)
 S (STDT1,ENDT1)="",TYPE=$P(RANGE,U)
"RTN","RORXU002",47,0)
 S RC=0  D  Q:RC<0 $$DBS^RORERR("RORMSG",-9,"DTRANGE^RORXDTU1")
"RTN","RORXU002",48,0)
 . ;
"RTN","RORXU002",49,0)
 . ;--- CUSTOM^StartDate^EndDate
"RTN","RORXU002",50,0)
 . I TYPE="CUSTOM"  D  Q
"RTN","RORXU002",51,0)
 . . S STDT1=$P(RANGE,U,2),ENDT1=$P(RANGE,U,3)
"RTN","RORXU002",52,0)
 . ;
"RTN","RORXU002",53,0)
 . ;--- CUTOFF^Cutoff
"RTN","RORXU002",54,0)
 . I TYPE="CUTOFF"  D  Q
"RTN","RORXU002",55,0)
 . . S ENDT1=$$DT^XLFDT,TMP=$P(RANGE,U,2)
"RTN","RORXU002",56,0)
 . . S:$E(TMP,1)="-" TMP=$E(TMP,2,999)
"RTN","RORXU002",57,0)
 . . D DT^DILF("P","TODAY-"_TMP,.STDT1,-ENDT1,"RORMSG")
"RTN","RORXU002",58,0)
 . . S:STDT1<0 RC=STDT1
"RTN","RORXU002",59,0)
 . ;
"RTN","RORXU002",60,0)
 . ;--- QUARTER^Quarter^Year^Fiscal
"RTN","RORXU002",61,0)
 . I TYPE="QUARTER"  D  Q
"RTN","RORXU002",62,0)
 . . S QUARTER=+$P(RANGE,U,2),YEAR=+$P(RANGE,U,3)
"RTN","RORXU002",63,0)
 . . S FISCAL=+$P(RANGE,U,4)  S:FISCAL QUARTER=QUARTER-1
"RTN","RORXU002",64,0)
 . . S TMP=$P("10/01^01/01^04/01^07/01^10/01","^",QUARTER+1)
"RTN","RORXU002",65,0)
 . . S TMP=TMP_"/"_$S(QUARTER:YEAR,1:YEAR-1)
"RTN","RORXU002",66,0)
 . . D DT^DILF("P",TMP,.STDT1,,"RORMSG")
"RTN","RORXU002",67,0)
 . . I STDT1<0  S RC=STDT1  Q
"RTN","RORXU002",68,0)
 . . S TMP=$P("12/31^03/31^06/30^09/30^12/31","^",QUARTER+1)
"RTN","RORXU002",69,0)
 . . S TMP=TMP_"/"_$S(QUARTER:YEAR,1:YEAR-1)
"RTN","RORXU002",70,0)
 . . D DT^DILF("P",TMP,.ENDT1,STDT1,"RORMSG")
"RTN","RORXU002",71,0)
 . . I ENDT1<0  S RC=ENDT1  Q
"RTN","RORXU002",72,0)
 . ;
"RTN","RORXU002",73,0)
 . ;--- YEAR^Year^Fiscal
"RTN","RORXU002",74,0)
 . I TYPE="YEAR"  D  Q
"RTN","RORXU002",75,0)
 . . S YEAR=+$P(RANGE,U,2),FISCAL=+$P(RANGE,U,3)
"RTN","RORXU002",76,0)
 . . S TMP=$S(FISCAL:"10/01/"_(YEAR-1),1:"01/01/"_YEAR)
"RTN","RORXU002",77,0)
 . . D DT^DILF("P",TMP,.STDT1,,"RORMSG")
"RTN","RORXU002",78,0)
 . . I STDT1<0  S RC=STDT1  Q
"RTN","RORXU002",79,0)
 . . S TMP=$S(FISCAL:"09/30/"_YEAR,1:"12/31/"_YEAR)
"RTN","RORXU002",80,0)
 . . D DT^DILF("P",TMP,.ENDT1,STDT1,"RORMSG")
"RTN","RORXU002",81,0)
 . . I ENDT1<0  S RC=ENDT1  Q
"RTN","RORXU002",82,0)
 ;
"RTN","RORXU002",83,0)
 ;--- Invalid time frame
"RTN","RORXU002",84,0)
 I (STDT1'>0)!(ENDT1'>0)!(STDT1>ENDT1)  D  Q RC
"RTN","RORXU002",85,0)
 . S RC=$$ERROR^RORERR(-88,,,,"DATA_RANGE",RANGE)
"RTN","RORXU002",86,0)
 ;
"RTN","RORXU002",87,0)
 ;--- Success
"RTN","RORXU002",88,0)
 S STDT=STDT1,ENDT=ENDT1
"RTN","RORXU002",89,0)
 Q 0
"RTN","RORXU002",90,0)
 ;
"RTN","RORXU002",91,0)
 ;***** OUTPUTS THE BASIC HEADER TO THE REPORT
"RTN","RORXU002",92,0)
 ;
"RTN","RORXU002",93,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORXU002",94,0)
 ;
"RTN","RORXU002",95,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORXU002",96,0)
 ;
"RTN","RORXU002",97,0)
 ; Return Values:
"RTN","RORXU002",98,0)
 ;       <0  Error code
"RTN","RORXU002",99,0)
 ;       >0  IEN of the HEADER element
"RTN","RORXU002",100,0)
 ;
"RTN","RORXU002",101,0)
HEADER(RORTSK,PARTAG) ;
"RTN","RORXU002",102,0)
 N HEADER,IENS,REGIEN,RORBUF,RORMSG,TMP
"RTN","RORXU002",103,0)
 S HEADER=$$ADDVAL^RORTSK11(RORTSK,"HEADER",,PARTAG)
"RTN","RORXU002",104,0)
 Q:HEADER<0 HEADER
"RTN","RORXU002",105,0)
 D ADDVAL^RORTSK11(RORTSK,"DATE",$$DATE($$NOW^XLFDT),HEADER)
"RTN","RORXU002",106,0)
 D ADDVAL^RORTSK11(RORTSK,"TASK_NUMBER",RORTSK,HEADER)
"RTN","RORXU002",107,0)
 S REGIEN=+$$PARAM^RORTSK01("REGIEN")
"RTN","RORXU002",108,0)
 ;---
"RTN","RORXU002",109,0)
 S IENS=REGIEN_","
"RTN","RORXU002",110,0)
 D GETS^DIQ(798.1,IENS,"1;2","I","RORBUF","RORMSG")
"RTN","RORXU002",111,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","RORXU002",112,0)
 S TMP=$G(RORBUF(798.1,IENS,1,"I"))
"RTN","RORXU002",113,0)
 D ADDVAL^RORTSK11(RORTSK,"UPDATED_UNTIL",$$DATE(TMP),HEADER)
"RTN","RORXU002",114,0)
 S TMP=$G(RORBUF(798.1,IENS,2,"I"))
"RTN","RORXU002",115,0)
 D ADDVAL^RORTSK11(RORTSK,"EXTRACTED_UNTIL",$$DATE(TMP),HEADER)
"RTN","RORXU002",116,0)
 Q HEADER
"RTN","RORXU002",117,0)
 ;
"RTN","RORXU002",118,0)
 ;***** PARSES THE COMMA-SEPARATED LIST
"RTN","RORXU002",119,0)
 ;
"RTN","RORXU002",120,0)
 ; .LIST         Reference to a local variable that contains a list.
"RTN","RORXU002",121,0)
 ;               Items of the list are returned as the subscripts of
"RTN","RORXU002",122,0)
 ;               this variable.
"RTN","RORXU002",123,0)
 ;
"RTN","RORXU002",124,0)
LIST(LIST) ;
"RTN","RORXU002",125,0)
 N I,TMP,VAL
"RTN","RORXU002",126,0)
 F I=1:1  S VAL=$P(LIST,",",I)  Q:VAL=""  D
"RTN","RORXU002",127,0)
 . S TMP=$$TRIM^XLFSTR(VAL)
"RTN","RORXU002",128,0)
 . S:TMP'="" LIST(TMP)=""
"RTN","RORXU002",129,0)
 Q
"RTN","RORXU002",130,0)
 ;
"RTN","RORXU002",131,0)
 ;***** COMPILES A TEXT DESCRIPTION FOR THE REPORT OPTIONS
"RTN","RORXU002",132,0)
 ;
"RTN","RORXU002",133,0)
 ; .OPTIONS      Reference to a local variable containing
"RTN","RORXU002",134,0)
 ;               the options as subscripts
"RTN","RORXU002",135,0)
 ;
"RTN","RORXU002",136,0)
 ; Return Values:
"RTN","RORXU002",137,0)
 ;      ...  Text description of the options
"RTN","RORXU002",138,0)
 ;
"RTN","RORXU002",139,0)
OPTXT(OPTIONS) ;
"RTN","RORXU002",140,0)
 N I,J,NS,RORBUF,TEXT,TMP
"RTN","RORXU002",141,0)
 D BLD^DIALOG(7980000.018,,,"RORBUF")
"RTN","RORXU002",142,0)
 S TEXT="",I=0
"RTN","RORXU002",143,0)
 F  S I=$O(RORBUF(I))  Q:I=""  D:$E(RORBUF(I),1)'=" "
"RTN","RORXU002",144,0)
 . S NS=0
"RTN","RORXU002",145,0)
 . F J=1:1  S TMP=$TR($P(RORBUF(I),",",J)," ")  Q:TMP=""  D
"RTN","RORXU002",146,0)
 . . S:$D(OPTIONS(TMP)) NS=2**(J-1)+NS
"RTN","RORXU002",147,0)
 . Q:'NS
"RTN","RORXU002",148,0)
 . S TMP=$$TRIM^XLFSTR($G(RORBUF(I+NS)))
"RTN","RORXU002",149,0)
 . S:TMP'="" TEXT=TEXT_", "_TMP
"RTN","RORXU002",150,0)
 Q $P(TEXT,", ",2,999)
"RTN","RORXU002",151,0)
 ;
"RTN","RORXU002",152,0)
 ;***** OUTPUTS THE PARAMETERS TO THE REPORT
"RTN","RORXU002",153,0)
 ;
"RTN","RORXU002",154,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORXU002",155,0)
 ;
"RTN","RORXU002",156,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORXU002",157,0)
 ;
"RTN","RORXU002",158,0)
 ; .STDT         Start and end dates of the report
"RTN","RORXU002",159,0)
 ; .ENDT         are returned via these parameters
"RTN","RORXU002",160,0)
 ;
"RTN","RORXU002",161,0)
 ; [.FLAGS]      Flags for the $$SKIP^RORXU005 are
"RTN","RORXU002",162,0)
 ;               returned via this parameter
"RTN","RORXU002",163,0)
 ;
"RTN","RORXU002",164,0)
 ; Return Values:
"RTN","RORXU002",165,0)
 ;       <0  Error code
"RTN","RORXU002",166,0)
 ;       >0  IEN of the PARAMETERS element
"RTN","RORXU002",167,0)
 ;
"RTN","RORXU002",168,0)
PARAMS(RORTSK,PARTAG,STDT,ENDT,FLAGS) ;
"RTN","RORXU002",169,0)
 N ELEMENT,IENS,MODE,NAME,PARAMS,RC,REGIEN,RORBUF,TMP
"RTN","RORXU002",170,0)
 S PARAMS=$$ADDVAL^RORTSK11(RORTSK,"PARAMETERS",,PARTAG)
"RTN","RORXU002",171,0)
 S RC=0,FLAGS=""
"RTN","RORXU002",172,0)
 ;
"RTN","RORXU002",173,0)
 ;--- Registry name
"RTN","RORXU002",174,0)
 S REGIEN=+$$PARAM^RORTSK01("REGIEN")
"RTN","RORXU002",175,0)
 I REGIEN>0  D  Q:RC<0 RC
"RTN","RORXU002",176,0)
 . S TMP=$P($$REGNAME^RORUTL01(REGIEN),U)
"RTN","RORXU002",177,0)
 . I TMP=""  S RC=-1  Q
"RTN","RORXU002",178,0)
 . S RC=$$ADDVAL^RORTSK11(RORTSK,"REGNAME",TMP,PARAMS)
"RTN","RORXU002",179,0)
 ;
"RTN","RORXU002",180,0)
 ;--- Date range
"RTN","RORXU002",181,0)
 S TMP=$$PARAM^RORTSK01("DATE_RANGE")
"RTN","RORXU002",182,0)
 I $P(TMP,U)'=""  D  Q:RC<0 RC
"RTN","RORXU002",183,0)
 . S RC=$$DTRANGE(TMP,.STDT,.ENDT)  Q:RC<0
"RTN","RORXU002",184,0)
 . S STDT=STDT\1,ENDT=ENDT\1
"RTN","RORXU002",185,0)
 . S ELEMENT=$$ADDVAL^RORTSK11(RORTSK,"DATE_RANGE",,PARAMS)
"RTN","RORXU002",186,0)
 . S RC=$$ADDATTR^RORTSK11(RORTSK,ELEMENT,"START",$$DATE(STDT))
"RTN","RORXU002",187,0)
 . S RC=$$ADDATTR^RORTSK11(RORTSK,ELEMENT,"END",$$DATE(ENDT))
"RTN","RORXU002",188,0)
 ;
"RTN","RORXU002",189,0)
 ;--- Patient selection and Options
"RTN","RORXU002",190,0)
 F NAME="PATIENTS","OPTIONS"  D  Q:RC<0
"RTN","RORXU002",191,0)
 . K RORBUF  S RORBUF=$$PARAM^RORTSK01(NAME)  Q:RORBUF=""
"RTN","RORXU002",192,0)
 . D LIST^RORXU002(.RORBUF)
"RTN","RORXU002",193,0)
 . ;--- Generate the XML tags
"RTN","RORXU002",194,0)
 . S ELEMENT=$$ADDVAL^RORTSK11(RORTSK,NAME,$$OPTXT(.RORBUF),PARAMS)
"RTN","RORXU002",195,0)
 . I ELEMENT'>0  S RC=ELEMENT  Q
"RTN","RORXU002",196,0)
 . S TMP=""
"RTN","RORXU002",197,0)
 . F  S TMP=$O(RORBUF(TMP))  Q:TMP=""  D  Q:RC<0
"RTN","RORXU002",198,0)
 . . S RC=$$ADDATTR^RORTSK11(RORTSK,ELEMENT,TMP,"1")
"RTN","RORXU002",199,0)
 . ;--- Compile the flags
"RTN","RORXU002",200,0)
 . D:NAME="PATIENTS"
"RTN","RORXU002",201,0)
 . . S TMP=""
"RTN","RORXU002",202,0)
 . . S:'$D(RORBUF("ACTIVE")) TMP=TMP_"A"
"RTN","RORXU002",203,0)
 . . S:'$D(RORBUF("INACTIVE")) TMP=TMP_"I"
"RTN","RORXU002",204,0)
 . . S:TMP'="AI" FLAGS=FLAGS_TMP
"RTN","RORXU002",205,0)
 . . S TMP=""
"RTN","RORXU002",206,0)
 . . S:'$D(RORBUF("DE_BEFORE")) TMP=TMP_"P"
"RTN","RORXU002",207,0)
 . . S:'$D(RORBUF("DE_DURING")) TMP=TMP_"N"
"RTN","RORXU002",208,0)
 . . S:'$D(RORBUF("DE_AFTER")) TMP=TMP_"F"
"RTN","RORXU002",209,0)
 . . S:TMP'="PNF" FLAGS=FLAGS_TMP
"RTN","RORXU002",210,0)
 ;---
"RTN","RORXU002",211,0)
 Q $S(RC<0:RC,1:PARAMS)
"RTN","RORXU002",212,0)
 ;
"RTN","RORXU002",213,0)
 ;***** GENERATES TABLE DEFINITION
"RTN","RORXU002",214,0)
 ;
"RTN","RORXU002",215,0)
 ; TBLREF        Reference to the definition table in the source
"RTN","RORXU002",216,0)
 ;               code (TAG^ROUTINE). See the HEADER^RORX013 for
"RTN","RORXU002",217,0)
 ;               examples of table definitions.
"RTN","RORXU002",218,0)
 ;
"RTN","RORXU002",219,0)
 ; HEADER        IEN of the HEADER element
"RTN","RORXU002",220,0)
 ;
"RTN","RORXU002",221,0)
 ; Return Values:
"RTN","RORXU002",222,0)
 ;       <0  Error code
"RTN","RORXU002",223,0)
 ;        0  Ok
"RTN","RORXU002",224,0)
 ;
"RTN","RORXU002",225,0)
TBLDEF(TBLREF,HEADER) ;
"RTN","RORXU002",226,0)
 N COND,IT,NAME,RC,RORSRC,TBLDEF,TERM,TGET
"RTN","RORXU002",227,0)
 S TGET="S RORSRC=$T("_$P(TBLREF,"^")_"+IT^"_$P(TBLREF,"^",2)_")"
"RTN","RORXU002",228,0)
 S RC=0
"RTN","RORXU002",229,0)
 F IT=1:1  X TGET  S RORSRC=$P(RORSRC,";;",2)  Q:RORSRC=""  D  Q:RC<0
"RTN","RORXU002",230,0)
 . S COND=$$TRIM^XLFSTR($P(RORSRC,U,2,999))
"RTN","RORXU002",231,0)
 . I COND'=""  X COND  E  Q
"RTN","RORXU002",232,0)
 . S RORSRC=$$TRIM^XLFSTR($P(RORSRC,U))
"RTN","RORXU002",233,0)
 . S NAME=$$COLSCAN(.TERM)  Q:(NAME="")!(TERM'="(")
"RTN","RORXU002",234,0)
 . S TBLDEF=$$ADDVAL^RORTSK11(RORTSK,"TBLDEF",,HEADER)
"RTN","RORXU002",235,0)
 . I TBLDEF<0  S RC=TBLDEF  Q
"RTN","RORXU002",236,0)
 . D ADDATTR^RORTSK11(RORTSK,TBLDEF,"NAME",NAME)
"RTN","RORXU002",237,0)
 . D ADDATTR^RORTSK11(RORTSK,TBLDEF,"HEADER","1")
"RTN","RORXU002",238,0)
 . D ADDATTR^RORTSK11(RORTSK,TBLDEF,"FOOTER","1")
"RTN","RORXU002",239,0)
 . D TBLDEF1(TBLDEF)
"RTN","RORXU002",240,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORXU002",241,0)
 ;
"RTN","RORXU002",242,0)
 ;***** GENERATES <COLUMN> ELEMENTS FROM TABLE DEFINITION (RORSRC)
"RTN","RORXU002",243,0)
 ;
"RTN","RORXU002",244,0)
 ; PTAG          IEN of the parent element
"RTN","RORXU002",245,0)
 ;
"RTN","RORXU002",246,0)
TBLDEF1(PTAG) ;
"RTN","RORXU002",247,0)
 N COLUMN,NAME,TERM
"RTN","RORXU002",248,0)
 F  S NAME=$$COLSCAN(.TERM)  Q:NAME=""  D  Q:")"[TERM
"RTN","RORXU002",249,0)
 . S COLUMN=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,PTAG)
"RTN","RORXU002",250,0)
 . D ADDATTR^RORTSK11(RORTSK,COLUMN,"NAME",NAME)
"RTN","RORXU002",251,0)
 . D:TERM="(" TBLDEF1(COLUMN)
"RTN","RORXU002",252,0)
 Q
"RTN","RORXU003")
0^142^B56989100
"RTN","RORXU003",1,0)
RORXU003 ;HCIOFO/BH - REPORT BUILDER UTILITIES ; 12/30/03 2:48pm
"RTN","RORXU003",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORXU003",3,0)
 ;
"RTN","RORXU003",4,0)
 ; This routine uses the following IAs:
"RTN","RORXU003",5,0)
 ;
"RTN","RORXU003",6,0)
 ; #1894         ENCEVENT^PXKENC (controlled)
"RTN","RORXU003",7,0)
 ;
"RTN","RORXU003",8,0)
 Q
"RTN","RORXU003",9,0)
 ;
"RTN","RORXU003",10,0)
 ; *****************************************************
"RTN","RORXU003",11,0)
 ;
"RTN","RORXU003",12,0)
 ;  Input:
"RTN","RORXU003",13,0)
 ;
"RTN","RORXU003",14,0)
 ;      ST - Start date for search - FM format
"RTN","RORXU003",15,0)
 ;      ED - End date for search - FM format
"RTN","RORXU003",16,0)
 ;  RORDFN - Patient IEN in file #2
"RTN","RORXU003",17,0)
 ;     CHK - A passed array that identifies the packages files
"RTN","RORXU003",18,0)
 ;           that need to be checked i.e. CHK("OUTPAT").  
"RTN","RORXU003",19,0)
 ;           If set to "ALL" Outpatients, Inpatients
"RTN","RORXU003",20,0)
 ;           Radiology,Allergy,Pharmacy,Microbiology, Surgical Pathology
"RTN","RORXU003",21,0)
 ;           Cytopathology and Lab will be checked.
"RTN","RORXU003",22,0)
 ;
"RTN","RORXU003",23,0)
 ; Output:
"RTN","RORXU003",24,0)
 ;
"RTN","RORXU003",25,0)
 ;  0 - If the patient has not had utilization
"RTN","RORXU003",26,0)
 ;      
"RTN","RORXU003",27,0)
 ;      If the patients has had utilization the routine will pass back
"RTN","RORXU003",28,0)
 ;      a string.  The first piece will be the number one'1', following
"RTN","RORXU003",29,0)
 ;      this will be other pieces that indicate what the utilization
"RTN","RORXU003",30,0)
 ;      areas are - I f utilization is from Outpatient the string will
"RTN","RORXU003",31,0)
 ;      contain an O, if Inpatients an I, Radiology an R, Allergy an A,
"RTN","RORXU003",32,0)
 ;      Outpatient Pharmacy OP, Inpatient Pharmacy IP, IV IV, 
"RTN","RORXU003",33,0)
 ;      Microbiology M, Surgical Pathology SP, Cytopathology C and 
"RTN","RORXU003",34,0)
 ;      Lab L.
"RTN","RORXU003",35,0)
 ;
"RTN","RORXU003",36,0)
 ;      E.g. If a patient had utilization for Inpatients, Outpatient
"RTN","RORXU003",37,0)
 ;      Pharmacy and Lab the string would look as follows;
"RTN","RORXU003",38,0)
 ;      1^I^O^OP^L 
"RTN","RORXU003",39,0)
 ;
"RTN","RORXU003",40,0)
UTIL(ST,ED,RORDFN,CHK) ;
"RTN","RORXU003",41,0)
 ;
"RTN","RORXU003",42,0)
 N VAL,LRDFN,RES,DATA,RORMSG  S VAL=0
"RTN","RORXU003",43,0)
 ;
"RTN","RORXU003",44,0)
 ; - Check Outpatient data
"RTN","RORXU003",45,0)
 I $D(CHK("ALL"))!($D(CHK("OUTPAT"))) D
"RTN","RORXU003",46,0)
 . S RES=$$OUTPAT(ST,ED,RORDFN)
"RTN","RORXU003",47,0)
 . I +RES S VAL=RES
"RTN","RORXU003",48,0)
 ;
"RTN","RORXU003",49,0)
 ; - Check Inpatient data
"RTN","RORXU003",50,0)
 I $D(CHK("ALL"))!($D(CHK("INPAT"))) D
"RTN","RORXU003",51,0)
 . S RES=$$INPAT(ST,ED,RORDFN)
"RTN","RORXU003",52,0)
 . I '+RES Q
"RTN","RORXU003",53,0)
 . S DATA=$P(VAL,U,2,99)
"RTN","RORXU003",54,0)
 . I DATA="" S VAL=RES
"RTN","RORXU003",55,0)
 . I DATA'="" S VAL=RES_"^"_DATA
"RTN","RORXU003",56,0)
 ;
"RTN","RORXU003",57,0)
 ; - Check Radiology data
"RTN","RORXU003",58,0)
 I $D(CHK("ALL"))!($D(CHK("RAD"))) D
"RTN","RORXU003",59,0)
 . S RES=$$RAD(ST,ED,RORDFN)
"RTN","RORXU003",60,0)
 . I '+RES Q
"RTN","RORXU003",61,0)
 . S DATA=$P(VAL,U,2,99)
"RTN","RORXU003",62,0)
 . I DATA="" S VAL=RES
"RTN","RORXU003",63,0)
 . I DATA'="" S VAL=RES_"^"_DATA
"RTN","RORXU003",64,0)
 ;
"RTN","RORXU003",65,0)
 ; - Check Allergy data
"RTN","RORXU003",66,0)
 I $D(CHK("ALL"))!($D(CHK("ALLERGY"))) D
"RTN","RORXU003",67,0)
 . S RES=$$ALLERGY(ST,ED,RORDFN)
"RTN","RORXU003",68,0)
 . I '+RES Q
"RTN","RORXU003",69,0)
 . S DATA=$P(VAL,U,2,99)
"RTN","RORXU003",70,0)
 . I DATA="" S VAL=RES
"RTN","RORXU003",71,0)
 . I DATA'="" S VAL=RES_"^"_DATA
"RTN","RORXU003",72,0)
 ;
"RTN","RORXU003",73,0)
 ; - Check Pharmacy data
"RTN","RORXU003",74,0)
 I $D(CHK("ALL"))!($D(CHK("PHARM"))) D
"RTN","RORXU003",75,0)
 . S RES=$$PHARM(ST,ED,RORDFN)
"RTN","RORXU003",76,0)
 . I '+RES Q
"RTN","RORXU003",77,0)
 . S DATA=$P(VAL,U,2,99)
"RTN","RORXU003",78,0)
 . I DATA="" S VAL=RES
"RTN","RORXU003",79,0)
 . I DATA'="" S VAL=RES_"^"_DATA
"RTN","RORXU003",80,0)
 ;
"RTN","RORXU003",81,0)
 S LRDFN=+$$LRDFN^LR7OR1(RORDFN)
"RTN","RORXU003",82,0)
 ;
"RTN","RORXU003",83,0)
 ; - Check Microbiology/Surgical Pathology/Cytopathology data
"RTN","RORXU003",84,0)
 I LRDFN D
"RTN","RORXU003",85,0)
 . I $D(CHK("ALL"))!($D(CHK("MICRO"))) D
"RTN","RORXU003",86,0)
 . . S RES=$$MICRO(ST,ED,LRDFN)
"RTN","RORXU003",87,0)
 . . I '+RES Q
"RTN","RORXU003",88,0)
 . . S DATA=$P(VAL,U,2,99)
"RTN","RORXU003",89,0)
 . . I DATA="" S VAL=RES
"RTN","RORXU003",90,0)
 . . I DATA'="" S VAL=RES_"^"_DATA
"RTN","RORXU003",91,0)
 . ;
"RTN","RORXU003",92,0)
 . I $D(CHK("ALL"))!($D(CHK("SURGP"))) D
"RTN","RORXU003",93,0)
 . . S RES=$$SURGP(ST,ED,LRDFN)
"RTN","RORXU003",94,0)
 . . I '+RES Q
"RTN","RORXU003",95,0)
 . . S DATA=$P(VAL,U,2,99)
"RTN","RORXU003",96,0)
 . . I DATA="" S VAL=RES
"RTN","RORXU003",97,0)
 . . I DATA'="" S VAL=RES_"^"_DATA
"RTN","RORXU003",98,0)
 . ;
"RTN","RORXU003",99,0)
 . I $D(CHK("ALL"))!($D(CHK("CYTO"))) D
"RTN","RORXU003",100,0)
 . . S RES=$$CYTO(ST,ED,LRDFN)
"RTN","RORXU003",101,0)
 . . I '+RES Q
"RTN","RORXU003",102,0)
 . . S DATA=$P(VAL,U,2,99)
"RTN","RORXU003",103,0)
 . . I DATA="" S VAL=RES
"RTN","RORXU003",104,0)
 . . I DATA'="" S VAL=RES_"^"_DATA
"RTN","RORXU003",105,0)
 ;
"RTN","RORXU003",106,0)
 ; - Check Lab data
"RTN","RORXU003",107,0)
 I $D(CHK("ALL"))!($D(CHK("LAB"))) D
"RTN","RORXU003",108,0)
 . S RES=$$LAB(ST,ED,RORDFN)
"RTN","RORXU003",109,0)
 . I '+RES Q
"RTN","RORXU003",110,0)
 . S DATA=$P(VAL,U,2,99)
"RTN","RORXU003",111,0)
 . I DATA="" S VAL=RES
"RTN","RORXU003",112,0)
 . I DATA'="" S VAL=RES_"^"_DATA
"RTN","RORXU003",113,0)
 ;
"RTN","RORXU003",114,0)
 Q VAL
"RTN","RORXU003",115,0)
 ;
"RTN","RORXU003",116,0)
 ;
"RTN","RORXU003",117,0)
 ; ***************************
"RTN","RORXU003",118,0)
 ; Checks Outpatient data for utilization for given dates ST and ED.
"RTN","RORXU003",119,0)
 ;
"RTN","RORXU003",120,0)
 ; OUTPAT(ST,ED,RORDFN)
"RTN","RORXU003",121,0)
 ; N PIEN,QUIT
"RTN","RORXU003",122,0)
 ; S QUIT=0
"RTN","RORXU003",123,0)
 ; S ST=9999999-ST
"RTN","RORXU003",124,0)
 ; S ED=9999999-ED
"RTN","RORXU003",125,0)
 ; F  S ST=$O(^AUPNVSIT("AA",RORDFN,ST),-1)  Q:'ST!(ST'>ED)!(QUIT)  D
"RTN","RORXU003",126,0)
 ; . S PIEN=""
"RTN","RORXU003",127,0)
 ; . F  S PIEN=$O(^AUPNVSIT("AA",RORDFN,ST,PIEN),-1)  Q:'PIEN  D
"RTN","RORXU003",128,0)
 ; . . K ^TMP("PXKENC",$J,PIEN)
"RTN","RORXU003",129,0)
 ; . . D ENCEVENT^PXKENC(PIEN,1)
"RTN","RORXU003",130,0)
 ; . . Q:$D(^TMP("PXKENC",$J,PIEN))<10
"RTN","RORXU003",131,0)
 ; . . S QUIT=1_"^O" Q
"RTN","RORXU003",132,0)
 ; Q QUIT
"RTN","RORXU003",133,0)
 ;
"RTN","RORXU003",134,0)
 ; ***************************
"RTN","RORXU003",135,0)
 ; Checks Outpatient data for utilization for given dates ST and ED.
"RTN","RORXU003",136,0)
 ;
"RTN","RORXU003",137,0)
OUTPAT(ST,ED,RORDFN) ;
"RTN","RORXU003",138,0)
 S ST=$P(ST,".",1),ST=ST-1,ST=ST+.9999
"RTN","RORXU003",139,0)
 S ED=$P(ED,".",1),ED=ED+1
"RTN","RORXU003",140,0)
 N QUERY,RORDST,RORECNT
"RTN","RORXU003",141,0)
 S RORECNT=0
"RTN","RORXU003",142,0)
 S RORDST=$NA(^TMP("RORXU003",$J,"OUT"))
"RTN","RORXU003",143,0)
 D OPEN^SDQ(.QUERY)
"RTN","RORXU003",144,0)
 D INDEX^SDQ(.QUERY,"PATIENT/DATE","SET")
"RTN","RORXU003",145,0)
 D PAT^SDQ(.QUERY,RORDFN,"SET")
"RTN","RORXU003",146,0)
 D DATE^SDQ(.QUERY,ST,ED,"SET")
"RTN","RORXU003",147,0)
 D SCANCB^SDQ(.QUERY,"D SCAN^RORXU003()","SET")
"RTN","RORXU003",148,0)
 D ACTIVE^SDQ(.QUERY,"TRUE","SET")
"RTN","RORXU003",149,0)
 D SCAN^SDQ(.QUERY,"FORWARD")
"RTN","RORXU003",150,0)
 D CLOSE^SDQ(.QUERY)
"RTN","RORXU003",151,0)
 I RORECNT S RORECNT=1_"^O"
"RTN","RORXU003",152,0)
 Q RORECNT
"RTN","RORXU003",153,0)
 ;
"RTN","RORXU003",154,0)
 ;
"RTN","RORXU003",155,0)
 ; ***************************
"RTN","RORXU003",156,0)
 ; Checks Inpatient data for utilization for given dates ST and ED.
"RTN","RORXU003",157,0)
 ;
"RTN","RORXU003",158,0)
INPAT(ST,ED,DFN) ;
"RTN","RORXU003",159,0)
 N ADMDT,DATE,DISDT,IEN,QUIT
"RTN","RORXU003",160,0)
 S ST=ST\1,QUIT=0
"RTN","RORXU003",161,0)
 ;--- Check for admission date inside the time frame
"RTN","RORXU003",162,0)
 S DATE=(ED\1)_".999999"
"RTN","RORXU003",163,0)
 F  S DATE=$O(^DGPT("AAD",DFN,DATE),-1)  Q:'DATE!(DATE<ST)  D  Q:QUIT
"RTN","RORXU003",164,0)
 . S IEN=""
"RTN","RORXU003",165,0)
 . F  S IEN=$O(^DGPT("AAD",DFN,DATE,IEN),-1)  Q:'IEN  D  Q:QUIT
"RTN","RORXU003",166,0)
 . . S:'$$PTF^RORXU001(IEN,"P") QUIT=1
"RTN","RORXU003",167,0)
 Q:QUIT=1 "1^I"
"RTN","RORXU003",168,0)
 ;--- Check for discharge date inside the time frame or
"RTN","RORXU003",169,0)
 ;--- an admission, which surrounds the time frame
"RTN","RORXU003",170,0)
 S DATE=ST
"RTN","RORXU003",171,0)
 F  S DATE=$O(^DGPT("AAD",DFN,DATE),-1)  Q:'DATE  D  Q:QUIT
"RTN","RORXU003",172,0)
 . S IEN=""
"RTN","RORXU003",173,0)
 . F  S IEN=$O(^DGPT("AAD",DFN,DATE,IEN),-1)  Q:'IEN  D  Q:QUIT
"RTN","RORXU003",174,0)
 . . Q:$$PTF^RORXU001(IEN,"P",.ADMDT,.DISDT)
"RTN","RORXU003",175,0)
 . . ;--- Check the discharge date
"RTN","RORXU003",176,0)
 . . I DISDT'>0  Q:$$CHKADM^RORXU001(DFN,ADMDT,.DISDT)
"RTN","RORXU003",177,0)
 . . I DISDT>0,DISDT'>ST  S QUIT=2  Q
"RTN","RORXU003",178,0)
 . . S QUIT=1
"RTN","RORXU003",179,0)
 Q $S(QUIT=1:"1^I",1:0)
"RTN","RORXU003",180,0)
 ;
"RTN","RORXU003",181,0)
 ; ***************************
"RTN","RORXU003",182,0)
 ; Checks Radiology data for utilization for given dates ST and ED.
"RTN","RORXU003",183,0)
 ;
"RTN","RORXU003",184,0)
 ;
"RTN","RORXU003",185,0)
RAD(ST,ED,RORDFN) ;
"RTN","RORXU003",186,0)
 N QUIT S QUIT=1_"^R"
"RTN","RORXU003",187,0)
 K ^TMP($J,"RAE1")
"RTN","RORXU003",188,0)
 D EN1^RAO7PC1(RORDFN,ST,ED,999999999)
"RTN","RORXU003",189,0)
 I $D(^TMP($J,"RAE1",RORDFN))<10 S QUIT=0
"RTN","RORXU003",190,0)
 K ^TMP($J,"RAE1")
"RTN","RORXU003",191,0)
 Q QUIT
"RTN","RORXU003",192,0)
 ;
"RTN","RORXU003",193,0)
 ; ***************************
"RTN","RORXU003",194,0)
 ; Checks Allergy data for utilization for given dates ST and ED.
"RTN","RORXU003",195,0)
 ;
"RTN","RORXU003",196,0)
ALLERGY(ST,ED,RORDFN) ;
"RTN","RORXU003",197,0)
 N RORDTE,QUIT,RORIEN
"RTN","RORXU003",198,0)
 S QUIT=0
"RTN","RORXU003",199,0)
 S RORDTE=$O(^GMR(120.8,"AODT",ST),-1)
"RTN","RORXU003",200,0)
 S ED=ED_".999999"
"RTN","RORXU003",201,0)
 F  S RORDTE=$O(^GMR(120.8,"AODT",RORDTE))  Q:'RORDTE!(RORDTE'<ED)!(QUIT)  D
"RTN","RORXU003",202,0)
 . S RORIEN=0
"RTN","RORXU003",203,0)
 . F  S RORIEN=$O(^GMR(120.8,"AODT",RORDTE,RORIEN))  Q:'RORIEN  D
"RTN","RORXU003",204,0)
 . . S:$D(^GMR(120.8,"B",RORDFN,RORIEN)) QUIT=1_"^A"
"RTN","RORXU003",205,0)
 Q QUIT
"RTN","RORXU003",206,0)
 ;
"RTN","RORXU003",207,0)
 ; ***************************
"RTN","RORXU003",208,0)
 ; Checks Pharmacy data for utilization for given dates ST and ED.
"RTN","RORXU003",209,0)
 ;
"RTN","RORXU003",210,0)
PHARM(ST,ED,RORDFN) ;
"RTN","RORXU003",211,0)
 N QUIT,RORII,RORORD,OP,IP,IV,EXIT,TMP1,TMPST,TMPV,TMPQ,II
"RTN","RORXU003",212,0)
 S ED=$P(ED,".",1),ED=ED+1
"RTN","RORXU003",213,0)
 S (EXIT,QUIT,OP,IP,IV)=0
"RTN","RORXU003",214,0)
 K ^TMP("PS",$J)
"RTN","RORXU003",215,0)
 S TMPST=ST
"RTN","RORXU003",216,0)
 D OCL^PSOORRL(RORDFN,ST,ED)
"RTN","RORXU003",217,0)
 Q:$D(^TMP("PS",$J))<10 QUIT
"RTN","RORXU003",218,0)
 S ST=TMPST
"RTN","RORXU003",219,0)
 ;
"RTN","RORXU003",220,0)
 ; *************************
"RTN","RORXU003",221,0)
 ;--- Check for Inpat.,Outpat. or IV prescriptions
"RTN","RORXU003",222,0)
 ;
"RTN","RORXU003",223,0)
 S RORII=0
"RTN","RORXU003",224,0)
 F  S RORII=$O(^TMP("PS",$J,RORII))  Q:'RORII!(EXIT)  D
"RTN","RORXU003",225,0)
 . I OP,IV,IP S EXIT=1 Q
"RTN","RORXU003",226,0)
 . S RORORD=$P(^TMP("PS",$J,RORII,0),U)
"RTN","RORXU003",227,0)
 . Q:RORORD'>0
"RTN","RORXU003",228,0)
 . S II=$P(RORORD,";"),II=$E(II,$L(II))
"RTN","RORXU003",229,0)
 . Q:'("RUV"[II)
"RTN","RORXU003",230,0)
 . ;
"RTN","RORXU003",231,0)
 . I II="U"!(II="V")  D  Q:(TMP1<ST)!(TMP1'<ED)
"RTN","RORXU003",232,0)
 . . S TMP1=$P($G(^TMP("PS",$J,RORII,0)),U,15)
"RTN","RORXU003",233,0)
 . I II="R"  D  Q:(TMP1<ST)!(TMP1'<ED)
"RTN","RORXU003",234,0)
 . . S TMP1=$P($G(^TMP("PS",$J,RORII,0)),U,10)
"RTN","RORXU003",235,0)
 . ;
"RTN","RORXU003",236,0)
 . S TMPV=$S(II="R":"OP",II="U":"IP",II="V":"IV",1:"")
"RTN","RORXU003",237,0)
 . I TMPV="" Q
"RTN","RORXU003",238,0)
 . I @(TMPV) Q
"RTN","RORXU003",239,0)
 . S TMPQ=$P(QUIT,U,2,9)
"RTN","RORXU003",240,0)
 . I TMPQ="" S QUIT="1^"_TMPV
"RTN","RORXU003",241,0)
 . I TMPQ'="" S QUIT="1^"_TMPQ_"^"_TMPV
"RTN","RORXU003",242,0)
 . S @(TMPV)=1
"RTN","RORXU003",243,0)
 . Q
"RTN","RORXU003",244,0)
 Q QUIT
"RTN","RORXU003",245,0)
 ;
"RTN","RORXU003",246,0)
 ; ***************************
"RTN","RORXU003",247,0)
 ; Checks Microbiology data for utilization for given dates ST and ED.
"RTN","RORXU003",248,0)
 ;
"RTN","RORXU003",249,0)
MICRO(ST,ED,LRDFN) ;
"RTN","RORXU003",250,0)
 N QUIT,RORTMP,RORRES
"RTN","RORXU003",251,0)
 S QUIT=0
"RTN","RORXU003",252,0)
 ;
"RTN","RORXU003",253,0)
 S RORTMP=$NA(^TMP("RORXU003",$J))  K @RORTMP
"RTN","RORXU003",254,0)
 S RORRES=$$GETDATA^LA7UTL1A(LRDFN,ST,ED,"CD",RORTMP)
"RTN","RORXU003",255,0)
 I RORRES<0 Q QUIT
"RTN","RORXU003",256,0)
 ;
"RTN","RORXU003",257,0)
 I $D(^TMP("RORXU003",$J,LRDFN)) S QUIT=1_"^M"
"RTN","RORXU003",258,0)
 K @RORTMP
"RTN","RORXU003",259,0)
 Q QUIT
"RTN","RORXU003",260,0)
 ;
"RTN","RORXU003",261,0)
 ; ***************************
"RTN","RORXU003",262,0)
 ; Checks Surgical Pathology data for utilization for given dates ST and ED
"RTN","RORXU003",263,0)
 ;
"RTN","RORXU003",264,0)
SURGP(ST,ED,LRDFN) ;
"RTN","RORXU003",265,0)
 N QUIT,ENDT,IDT,STDT
"RTN","RORXU003",266,0)
 S QUIT=0
"RTN","RORXU003",267,0)
 S STDT=9999999-ST
"RTN","RORXU003",268,0)
 S ENDT=9999999-ED
"RTN","RORXU003",269,0)
 ;---
"RTN","RORXU003",270,0)
 S IDT=$O(^LR(LRDFN,"SP",STDT))
"RTN","RORXU003",271,0)
 F  S IDT=$O(^LR(LRDFN,"SP",IDT),-1)  Q:'IDT!(IDT'>ENDT)!(QUIT)  D
"RTN","RORXU003",272,0)
 . S QUIT=1_"^SP"
"RTN","RORXU003",273,0)
 Q QUIT
"RTN","RORXU003",274,0)
 ;
"RTN","RORXU003",275,0)
 ; ***************************
"RTN","RORXU003",276,0)
 ; Checks Cytopathology data for utilization for given dates ST and ED
"RTN","RORXU003",277,0)
 ;
"RTN","RORXU003",278,0)
CYTO(ST,ED,LRDFN) ;
"RTN","RORXU003",279,0)
 N QUIT,ENDT,IDT,STDT
"RTN","RORXU003",280,0)
 S QUIT=0
"RTN","RORXU003",281,0)
 S STDT=9999999-ST
"RTN","RORXU003",282,0)
 S ENDT=9999999-ED
"RTN","RORXU003",283,0)
 ;---
"RTN","RORXU003",284,0)
 S IDT=$O(^LR(LRDFN,"CY",STDT))
"RTN","RORXU003",285,0)
 F  S IDT=$O(^LR(LRDFN,"CY",IDT),-1)  Q:'IDT!(IDT'>ENDT)!(QUIT)  D
"RTN","RORXU003",286,0)
 . S QUIT=1_"^C"
"RTN","RORXU003",287,0)
 Q QUIT
"RTN","RORXU003",288,0)
 ;
"RTN","RORXU003",289,0)
 ; ***************************
"RTN","RORXU003",290,0)
 ; Checks Lab data for utilization for given dates ST and ED
"RTN","RORXU003",291,0)
 ;
"RTN","RORXU003",292,0)
LAB(ST,ED,RORDFN) ;
"RTN","RORXU003",293,0)
 N DST,PTID,QUIT,RORMSG
"RTN","RORXU003",294,0)
 S ED=$P(ED,".",1),ED=ED+1
"RTN","RORXU003",295,0)
 S QUIT=0
"RTN","RORXU003",296,0)
 S DST=$NA(^TMP("RORTMP",$J))  K @DST
"RTN","RORXU003",297,0)
 S PTID=$$PTID^RORUTL02(RORDFN)  Q:PTID<0 QUIT
"RTN","RORXU003",298,0)
 S ED=ED_"^CD",ST=ST_"^CD"
"RTN","RORXU003",299,0)
 ;--- Get the Lab data
"RTN","RORXU003",300,0)
 S RC=$$GCPR^LA7QRY(PTID,ST,ED,"CH","*",.RORMSG,DST,"")
"RTN","RORXU003",301,0)
 I $D(RORMSG)>1 Q QUIT
"RTN","RORXU003",302,0)
 I $D(^TMP("RORTMP",$J)) S QUIT=1_"^L"
"RTN","RORXU003",303,0)
 K @DST
"RTN","RORXU003",304,0)
 Q QUIT
"RTN","RORXU003",305,0)
 ;
"RTN","RORXU003",306,0)
SCAN() ;
"RTN","RORXU003",307,0)
 S RORECNT=1
"RTN","RORXU003",308,0)
 Q
"RTN","RORXU003",309,0)
 ;
"RTN","RORXU004")
0^148^B860897
"RTN","RORXU004",1,0)
RORXU004 ;HCIOFO/SG - REPORT UTILITIES (STATISTICS) ; 9/23/03 10:51am
"RTN","RORXU004",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORXU004",3,0)
 ;
"RTN","RORXU004",4,0)
 Q
"RTN","RORXU004",5,0)
 ;
"RTN","RORXU004",6,0)
 ;***** CALCULATES THE MEDIAN VALUE OF THE CROSS-REFERENCE
"RTN","RORXU004",7,0)
 ;
"RTN","RORXU004",8,0)
 ; XREFNODE      Root node of the old-style cross-reference
"RTN","RORXU004",9,0)
 ; NUM           Total number of elements in the array
"RTN","RORXU004",10,0)
 ;
"RTN","RORXU004",11,0)
 ; Return Values:
"RTN","RORXU004",12,0)
 ;       ""  Error (or an empty array)
"RTN","RORXU004",13,0)
 ;     '=""  Median Value
"RTN","RORXU004",14,0)
 ;
"RTN","RORXU004",15,0)
XREFMDNV(XREFNODE,NUM) ;
"RTN","RORXU004",16,0)
 Q:NUM'>0 ""
"RTN","RORXU004",17,0)
 N FLT,FLTL,I,MV,N,PI,VPOS
"RTN","RORXU004",18,0)
 S FLTL=$L(XREFNODE)-1,FLT=$E(XREFNODE,1,FLTL)
"RTN","RORXU004",19,0)
 S N=(NUM+1)\2,VPOS=$QL(XREFNODE)+1
"RTN","RORXU004",20,0)
 ;--- Find the median value
"RTN","RORXU004",21,0)
 S PI=XREFNODE
"RTN","RORXU004",22,0)
 F I=1:1:N  S PI=$Q(@PI)  Q:$E(PI,1,FLTL)'=FLT
"RTN","RORXU004",23,0)
 Q:$E(PI,1,FLTL)'=FLT ""
"RTN","RORXU004",24,0)
 ;--- Calculate median value if NUM is even
"RTN","RORXU004",25,0)
 S MV=$QS(PI,VPOS)
"RTN","RORXU004",26,0)
 I '(NUM#2)  D  Q:I="" ""  S MV=(MV+I)/2
"RTN","RORXU004",27,0)
 . S PI=$Q(@PI),I=$S($E(PI,1,FLTL)=FLT:$QS(PI,VPOS),1:"")
"RTN","RORXU004",28,0)
 Q MV
"RTN","RORXU005")
0^143^B10608819
"RTN","RORXU005",1,0)
RORXU005 ;HCIOFO/SG - REPORT BUILDER UTILITIES ; 12/3/03 2:10pm
"RTN","RORXU005",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORXU005",3,0)
 ;
"RTN","RORXU005",4,0)
 ; This routine uses the following IAs:
"RTN","RORXU005",5,0)
 ;
"RTN","RORXU005",6,0)
 ; #10035        Direct read of the DOD field of the file #2
"RTN","RORXU005",7,0)
 ;
"RTN","RORXU005",8,0)
 Q
"RTN","RORXU005",9,0)
 ;
"RTN","RORXU005",10,0)
 ;***** CALLBACK FUNCTION FOR DRUG SEARCH API
"RTN","RORXU005",11,0)
REIMBCB(RORDST,ORDER,FLAGS,DRUG,DATE) ;
"RTN","RORXU005",12,0)
 S RORDST=1
"RTN","RORXU005",13,0)
 Q 2
"RTN","RORXU005",14,0)
 ;
"RTN","RORXU005",15,0)
 ;***** RETURNS THE REIMBURSEMENT LEVEL FOR THE PATIENT
"RTN","RORXU005",16,0)
 ;
"RTN","RORXU005",17,0)
 ; RORIEN        IEN of the patient's record in the registry
"RTN","RORXU005",18,0)
 ;
"RTN","RORXU005",19,0)
 ; ROR8DRGS      Either closed root of the ARV drug list prepared by
"RTN","RORXU005",20,0)
 ;               the $$DRUGLIST^RORUTL16 or the Registry IEN. In the
"RTN","RORXU005",21,0)
 ;               latter case, the list will be compiled automatically.
"RTN","RORXU005",22,0)
 ;
"RTN","RORXU005",23,0)
 ; STDT          Start date
"RTN","RORXU005",24,0)
 ; ENDT          End date
"RTN","RORXU005",25,0)
 ;
"RTN","RORXU005",26,0)
 ; Return Values:
"RTN","RORXU005",27,0)
 ;       <0  Error code
"RTN","RORXU005",28,0)
 ;        0  Neither Clinical AIDS nor ARV drugs
"RTN","RORXU005",29,0)
 ;       10  ARV drugs
"RTN","RORXU005",30,0)
 ;       20  Clinical AIDS
"RTN","RORXU005",31,0)
 ;       30  Both Clinical AIDS and ARV drugs
"RTN","RORXU005",32,0)
 ;
"RTN","RORXU005",33,0)
REIMBLVL(RORIEN,ROR8DRGS,STDT,ENDT) ;
"RTN","RORXU005",34,0)
 N PATIEN,RC,RLVL,RORDST
"RTN","RORXU005",35,0)
 S RLVL=0
"RTN","RORXU005",36,0)
 ;--- Clinical AIDS
"RTN","RORXU005",37,0)
 S:$$CLINAIDS^RORICRUT(+RORIEN,ENDT) RLVL=RLVL+20
"RTN","RORXU005",38,0)
 ;--- ARV Drugs
"RTN","RORXU005",39,0)
 S PATIEN=$$PTIEN^RORUTL01(RORIEN)
"RTN","RORXU005",40,0)
 S RORDST("RORCB")="$$REIMBCB^RORXU005"
"RTN","RORXU005",41,0)
 S RC=$$RXSEARCH^RORUTL14(PATIEN,ROR8DRGS,.RORDST,"IOV",STDT,ENDT)
"RTN","RORXU005",42,0)
 S:$G(RORDST)>0 RLVL=RLVL+10
"RTN","RORXU005",43,0)
 ;--- Reimbursement level
"RTN","RORXU005",44,0)
 Q $S(RC<0:RC,1:RLVL)
"RTN","RORXU005",45,0)
 ;
"RTN","RORXU005",46,0)
 ;***** RETURNS THE PATIENT'S LIST OF RISK FACTORS
"RTN","RORXU005",47,0)
 ;
"RTN","RORXU005",48,0)
 ; RORIEN        IEN of the patient's record in the registry
"RTN","RORXU005",49,0)
 ;
"RTN","RORXU005",50,0)
 ; Return Values:
"RTN","RORXU005",51,0)
 ;       <0  Error code
"RTN","RORXU005",52,0)
 ;       ""  No risk factors have been found
"RTN","RORXU005",53,0)
 ;  " ... "  A string containing the risk factor numbers
"RTN","RORXU005",54,0)
 ;           separated by commas and spaces
"RTN","RORXU005",55,0)
 ;
"RTN","RORXU005",56,0)
RISKS(RORIEN) ;
"RTN","RORXU005",57,0)
 Q:'$D(^RORDATA(799.4,+RORIEN,0)) ""
"RTN","RORXU005",58,0)
 N FLD,FLDLST,I,RISKLST,RORBUF,RORMSG
"RTN","RORXU005",59,0)
 S FLDLST="14.01;14.02;14.03;14.04;14.08;14.07;14.09;14.1;14.11;14.12;14.13;14.16;14.17"
"RTN","RORXU005",60,0)
 ;--- Load the risk fields
"RTN","RORXU005",61,0)
 S IENS=(+RORIEN)_","
"RTN","RORXU005",62,0)
 D GETS^DIQ(799.4,IENS,FLDLST,"I","RORBUF","RORMSG")
"RTN","RORXU005",63,0)
 Q:$G(DIERR) $$DBS^RORERR(799.4,-9,,,799.4,IENS)
"RTN","RORXU005",64,0)
 ;--- Process the data
"RTN","RORXU005",65,0)
 S RISKLST=""
"RTN","RORXU005",66,0)
 F I=1:1  S FLD=$P(FLDLST,";",I)  Q:FLD=""  D:FLD>0
"RTN","RORXU005",67,0)
 . S:$G(RORBUF(799.4,IENS,FLD,"I"))=1 RISKLST=RISKLST_", "_I
"RTN","RORXU005",68,0)
 Q $P(RISKLST,", ",2,999)
"RTN","RORXU005",69,0)
 ;
"RTN","RORXU005",70,0)
 ;***** DETERMINES IF THE PATIENT SHOULD NOT BE INCLUDED IN THE REPORT
"RTN","RORXU005",71,0)
 ;
"RTN","RORXU005",72,0)
 ; RORIEN        IEN of the patient's record in the registry
"RTN","RORXU005",73,0)
 ;
"RTN","RORXU005",74,0)
 ; FLAGS         Flags that control the execution (can be combined)
"RTN","RORXU005",75,0)
 ;
"RTN","RORXU005",76,0)
 ;                 A  Skip active patients
"RTN","RORXU005",77,0)
 ;                 I  Skip inactivated patients
"RTN","RORXU005",78,0)
 ;
"RTN","RORXU005",79,0)
 ;                 D  Skip deceased patients
"RTN","RORXU005",80,0)
 ;                 L  Skip alive patients
"RTN","RORXU005",81,0)
 ;
"RTN","RORXU005",82,0)
 ;                 P  Skip patients added before the report time frame
"RTN","RORXU005",83,0)
 ;                 N  Skip patients added to the registry during
"RTN","RORXU005",84,0)
 ;                    the report time frame
"RTN","RORXU005",85,0)
 ;                 F  Skip patients added after the report time frame
"RTN","RORXU005",86,0)
 ;
"RTN","RORXU005",87,0)
 ;     NOTE:     Patients inactivated due to their death (the Reason
"RTN","RORXU005",88,0)
 ;               for Inactivation field is empty or zero and the Date 
"RTN","RORXU005",89,0)
 ;               of Death field of the PATIENT file is populated) are 
"RTN","RORXU005",90,0)
 ;               considered 'active' by this function! This behavior
"RTN","RORXU005",91,0)
 ;               is different from the $$ACTIVE^RORDD function and the
"RTN","RORXU005",92,0)
 ;               ACTIVE field (#8) logic.
"RTN","RORXU005",93,0)
 ;
"RTN","RORXU005",94,0)
 ; [STDT]        Start date of the report (FileMan).
"RTN","RORXU005",95,0)
 ;               Time is ignored and the beginning of the day is
"RTN","RORXU005",96,0)
 ;               considered as the boundary (STDT\1).
"RTN","RORXU005",97,0)
 ;
"RTN","RORXU005",98,0)
 ;               If not defined or not greater than 0 then 0 is used.
"RTN","RORXU005",99,0)
 ;
"RTN","RORXU005",100,0)
 ; [ENDT]        End date of the report (FileMan).
"RTN","RORXU005",101,0)
 ;               Time is ignored and the end of the day is
"RTN","RORXU005",102,0)
 ;               considered as the boundary (ENDT\1+1).
"RTN","RORXU005",103,0)
 ;
"RTN","RORXU005",104,0)
 ;               If not defined or not greater than 0 then 9999999
"RTN","RORXU005",105,0)
 ;               is used.
"RTN","RORXU005",106,0)
 ;
"RTN","RORXU005",107,0)
 ; Return Values:
"RTN","RORXU005",108,0)
 ;        0  Include the patient's data in the report
"RTN","RORXU005",109,0)
 ;        1  Skip the patient
"RTN","RORXU005",110,0)
 ;
"RTN","RORXU005",111,0)
SKIP(RORIEN,FLAGS,STDT,ENDT) ;
"RTN","RORXU005",112,0)
 N DOD,REASON,TMP
"RTN","RORXU005",113,0)
 ;--- Always skip 'pending' patients
"RTN","RORXU005",114,0)
 Q:$P($G(^RORDATA(798,+RORIEN,0)),U,5)=4 1
"RTN","RORXU005",115,0)
 ;---Include all patients if flags are not provided
"RTN","RORXU005",116,0)
 Q:FLAGS="" 0
"RTN","RORXU005",117,0)
 ;--- Get the Date of Death if necessary
"RTN","RORXU005",118,0)
 D:$TR(FLAGS,"AILD")'=FLAGS
"RTN","RORXU005",119,0)
 . S TMP=$$PTIEN^RORUTL01(RORIEN),DOD=+$P($G(^DPT(TMP,.35)),U)
"RTN","RORXU005",120,0)
 ;
"RTN","RORXU005",121,0)
 ;--- Active/Inactive patients
"RTN","RORXU005",122,0)
 I $TR(FLAGS,"AI")'=FLAGS  D  Q:$S(TMP:FLAGS["A",1:FLAGS["I") 1
"RTN","RORXU005",123,0)
 . S TMP=$$ACTIVE^RORDD(RORIEN,,.REASON)
"RTN","RORXU005",124,0)
 . ;--- Inactivated due to the death are considered active!
"RTN","RORXU005",125,0)
 . I 'TMP,'REASON  S:DOD>0 TMP=1
"RTN","RORXU005",126,0)
 ;
"RTN","RORXU005",127,0)
 ;--- Alive/Deceased patients
"RTN","RORXU005",128,0)
 S STDT=$S($G(STDT)>0:STDT\1,1:0)
"RTN","RORXU005",129,0)
 I $TR(FLAGS,"LD")'=FLAGS  D  Q:$S(TMP:FLAGS["L",1:FLAGS["D") 1
"RTN","RORXU005",130,0)
 . S TMP=$S(DOD>0:DOD'<STDT,1:1)
"RTN","RORXU005",131,0)
 ;
"RTN","RORXU005",132,0)
 ;--- Added before/during/after the date range
"RTN","RORXU005",133,0)
 I $TR(FLAGS,"PNF")'=FLAGS  D  Q:TMP 1
"RTN","RORXU005",134,0)
 . S ENDT=$S($G(ENDT)>0:ENDT\1,1:9999999)+1
"RTN","RORXU005",135,0)
 . S TMP=+$P($G(^RORDATA(798,RORIEN,0)),U,3)  ; Date Entered
"RTN","RORXU005",136,0)
 . S TMP=$S(TMP<STDT:FLAGS["P",TMP>ENDT:FLAGS["F",1:FLAGS["N")
"RTN","RORXU005",137,0)
 ;---
"RTN","RORXU005",138,0)
 Q 0
"RTN","RORXU006")
0^156^B24074439
"RTN","RORXU006",1,0)
RORXU006 ;HCIOFO/SG - REPORT PARAMETERS ; 2/10/04 9:00am
"RTN","RORXU006",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORXU006",3,0)
 ;
"RTN","RORXU006",4,0)
 ; This routine uses the following IAs:
"RTN","RORXU006",5,0)
 ;
"RTN","RORXU006",6,0)
 ; #91           Read access to the file #60 (controlled)
"RTN","RORXU006",7,0)
 ; #2016         Get the drug name from file #50.6 (private)
"RTN","RORXU006",8,0)
 ; #10035        Direct read of DOD field of file #2 (supported)
"RTN","RORXU006",9,0)
 ; #10040        Read access to HOSPITAL LOCATION file (suppotted)
"RTN","RORXU006",10,0)
 ; #10043        Get the drug name from file #50 (supported)
"RTN","RORXU006",11,0)
 ; #10082        Read access to the file #80 (supported)
"RTN","RORXU006",12,0)
 ;
"RTN","RORXU006",13,0)
 Q
"RTN","RORXU006",14,0)
 ;
"RTN","RORXU006",15,0)
 ;***** PROCESSES THE LIST OF CLINICS
"RTN","RORXU006",16,0)
 ;
"RTN","RORXU006",17,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORXU006",18,0)
 ;
"RTN","RORXU006",19,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORXU006",20,0)
 ;
"RTN","RORXU006",21,0)
 ; [ROR8LST]     Closed root of an array where the IEN's of
"RTN","RORXU006",22,0)
 ;               clinics will be returned to (as subscripts).
"RTN","RORXU006",23,0)
 ;               If this parameter is undefined or empty, the
"RTN","RORXU006",24,0)
 ;               list will not be compiled.
"RTN","RORXU006",25,0)
 ;
"RTN","RORXU006",26,0)
 ; Return Values:
"RTN","RORXU006",27,0)
 ;       <0  Error code
"RTN","RORXU006",28,0)
 ;       >0  IEN of the CLINICS element
"RTN","RORXU006",29,0)
 ;
"RTN","RORXU006",30,0)
CLINLST(RORTSK,PARTAG,ROR8LST) ;
"RTN","RORXU006",31,0)
 N I,IEN,LTAG,RORMSG,TMP
"RTN","RORXU006",32,0)
 S ROR8LST=$G(ROR8LST)
"RTN","RORXU006",33,0)
 I $D(RORTSK("PARAMS","CLINICS"))>1  D
"RTN","RORXU006",34,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"CLINICS",,PARTAG)  Q:LTAG'>0
"RTN","RORXU006",35,0)
 . S I=""
"RTN","RORXU006",36,0)
 . F  S I=$O(RORTSK("PARAMS","CLINICS",I))  Q:I=""  D
"RTN","RORXU006",37,0)
 . . S IEN=+RORTSK("PARAMS","CLINICS",I)  Q:IEN'>0
"RTN","RORXU006",38,0)
 . . S TMP=$$GET1^DIQ(44,IEN_",",.01,,,"RORMSG")
"RTN","RORXU006",39,0)
 . . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,44,IEN_",")
"RTN","RORXU006",40,0)
 . . Q:TMP=""
"RTN","RORXU006",41,0)
 . . D ADDVAL^RORTSK11(RORTSK,"CLINIC",TMP,LTAG,,IEN)
"RTN","RORXU006",42,0)
 . . S:ROR8LST'="" @ROR8LST@(IEN)=""
"RTN","RORXU006",43,0)
 E  D:$G(RORTSK("PARAMS","CLINICS"))="ALL"
"RTN","RORXU006",44,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"CLINICS","ALL",PARTAG)
"RTN","RORXU006",45,0)
 . S:ROR8LST'="" @ROR8LST@("ALL")=""
"RTN","RORXU006",46,0)
 Q +$G(LTAG)
"RTN","RORXU006",47,0)
 ;
"RTN","RORXU006",48,0)
 ;***** PROCESSES THE LIST OF DIVISIONS
"RTN","RORXU006",49,0)
 ;
"RTN","RORXU006",50,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORXU006",51,0)
 ;
"RTN","RORXU006",52,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORXU006",53,0)
 ;
"RTN","RORXU006",54,0)
 ; [ROR8LST]     Closed root of an array where the IEN's of the
"RTN","RORXU006",55,0)
 ;               divisions will be returned to (as subscripts).
"RTN","RORXU006",56,0)
 ;               If this parameter is undefined or empty, the list
"RTN","RORXU006",57,0)
 ;               will not be compiled.
"RTN","RORXU006",58,0)
 ;
"RTN","RORXU006",59,0)
 ; Return Values:
"RTN","RORXU006",60,0)
 ;       <0  Error code
"RTN","RORXU006",61,0)
 ;       >0  IEN of the DIVISIONS element
"RTN","RORXU006",62,0)
 ;
"RTN","RORXU006",63,0)
DIVLST(RORTSK,PARTAG,ROR8LST) ;
"RTN","RORXU006",64,0)
 N I,IEN,LTAG,RORMSG,TMP
"RTN","RORXU006",65,0)
 S ROR8LST=$G(ROR8LST)
"RTN","RORXU006",66,0)
 I $D(RORTSK("PARAMS","DIVISIONS"))>1  D
"RTN","RORXU006",67,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"DIVISIONS",,PARTAG)  Q:LTAG'>0
"RTN","RORXU006",68,0)
 . S I=""
"RTN","RORXU006",69,0)
 . F  S I=$O(RORTSK("PARAMS","DIVISIONS",I))  Q:I=""  D
"RTN","RORXU006",70,0)
 . . S IEN=+RORTSK("PARAMS","DIVISIONS",I)  Q:IEN'>0
"RTN","RORXU006",71,0)
 . . S TMP=$$GET1^DIQ(40.8,IEN_",",.01,,,"RORMSG")
"RTN","RORXU006",72,0)
 . . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,40.8,IEN_",")
"RTN","RORXU006",73,0)
 . . Q:TMP=""
"RTN","RORXU006",74,0)
 . . D ADDVAL^RORTSK11(RORTSK,"DIVISION",TMP,LTAG,,IEN)
"RTN","RORXU006",75,0)
 . . S:ROR8LST'="" @ROR8LST@(IEN)=""
"RTN","RORXU006",76,0)
 E  D:$G(RORTSK("PARAMS","DIVISIONS"))="ALL"
"RTN","RORXU006",77,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"DIVISIONS","ALL",PARTAG)
"RTN","RORXU006",78,0)
 . S:ROR8LST'="" @ROR8LST@("ALL")=""
"RTN","RORXU006",79,0)
 Q +$G(LTAG)
"RTN","RORXU006",80,0)
 ;
"RTN","RORXU006",81,0)
 ;***** PROCESSES THE LIST OF ICD-9 CODES
"RTN","RORXU006",82,0)
 ;
"RTN","RORXU006",83,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORXU006",84,0)
 ;
"RTN","RORXU006",85,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORXU006",86,0)
 ;
"RTN","RORXU006",87,0)
 ; [ROR8LST]     Closed root of an array where the IEN's of
"RTN","RORXU006",88,0)
 ;               ICD-9 codes will be returned to (as subscripts).
"RTN","RORXU006",89,0)
 ;               If this parameter is undefined or empty, the
"RTN","RORXU006",90,0)
 ;               list will not be compiled.
"RTN","RORXU006",91,0)
 ;
"RTN","RORXU006",92,0)
 ; Return Values:
"RTN","RORXU006",93,0)
 ;       <0  Error code
"RTN","RORXU006",94,0)
 ;       >0  IEN of the ICD9LST element
"RTN","RORXU006",95,0)
 ;
"RTN","RORXU006",96,0)
ICD9LST(RORTSK,PARTAG,ROR8LST) ;
"RTN","RORXU006",97,0)
 N I,ICD9,IEN,LTAG,RORMSG,TMP
"RTN","RORXU006",98,0)
 S ROR8LST=$G(ROR8LST)
"RTN","RORXU006",99,0)
 I $D(RORTSK("PARAMS","ICD9LST"))>1  D
"RTN","RORXU006",100,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"ICD9LST",,PARTAG)  Q:LTAG'>0
"RTN","RORXU006",101,0)
 . S I=""
"RTN","RORXU006",102,0)
 . F  S I=$O(RORTSK("PARAMS","ICD9LST",I))  Q:I=""  D
"RTN","RORXU006",103,0)
 . . S ICD9=RORTSK("PARAMS","ICD9LST",I)  Q:ICD9=""
"RTN","RORXU006",104,0)
 . . S IEN=$$FIND1^DIC(80,,"X",ICD9_" ","BA",,"RORMSG")
"RTN","RORXU006",105,0)
 . . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,80)
"RTN","RORXU006",106,0)
 . . Q:IEN'>0
"RTN","RORXU006",107,0)
 . . D ADDVAL^RORTSK11(RORTSK,"ICD9",ICD9,LTAG,,IEN)
"RTN","RORXU006",108,0)
 . . S:ROR8LST'="" @ROR8LST@(IEN)=""
"RTN","RORXU006",109,0)
 E  D:$G(RORTSK("PARAMS","ICD9LST"))="ALL"
"RTN","RORXU006",110,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"ICD9LST","ALL",PARTAG)
"RTN","RORXU006",111,0)
 . S:ROR8LST'="" @ROR8LST@("ALL")=""
"RTN","RORXU006",112,0)
 Q +$G(LTAG)
"RTN","RORXU006",113,0)
 ;
"RTN","RORXU006",114,0)
 ;***** PROCESSES THE LIST OF LAB TESTS
"RTN","RORXU006",115,0)
 ;
"RTN","RORXU006",116,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORXU006",117,0)
 ;
"RTN","RORXU006",118,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORXU006",119,0)
 ;
"RTN","RORXU006",120,0)
 ; ROR8LTST      Closed root of a variable, which will contain
"RTN","RORXU006",121,0)
 ;               a list of lab tests. If this parameter is undefined
"RTN","RORXU006",122,0)
 ;               or empty, the list will not be compiled.
"RTN","RORXU006",123,0)
 ;
"RTN","RORXU006",124,0)
 ;               @ROR8LTST@(ResultNode,TestIEN)
"RTN","RORXU006",125,0)
 ;                 ^01: Test IEN (in file #60)
"RTN","RORXU006",126,0)
 ;                 ^02: Test name
"RTN","RORXU006",127,0)
 ;                 ^03: 99
"RTN","RORXU006",128,0)
 ;                 ^04: "Other"
"RTN","RORXU006",129,0)
 ;                 ^05: Location subscript
"RTN","RORXU006",130,0)
 ;                 ^06: Result node
"RTN","RORXU006",131,0)
 ;
"RTN","RORXU006",132,0)
 ; Return Values:
"RTN","RORXU006",133,0)
 ;       <0  Error code
"RTN","RORXU006",134,0)
 ;       >0  IEN of the LABTESTS element
"RTN","RORXU006",135,0)
 ;
"RTN","RORXU006",136,0)
LTLST(RORTSK,PARTAG,ROR8LST) ;
"RTN","RORXU006",137,0)
 N BUF,I,IENS,LTAG,LTIEN,LTNAME,RORMSG,TMP
"RTN","RORXU006",138,0)
 S ROR8LST=$G(ROR8LST)
"RTN","RORXU006",139,0)
 I $D(RORTSK("PARAMS","LABTESTS"))>1  D
"RTN","RORXU006",140,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"LABTESTS",,PARTAG)  Q:LTAG'>0
"RTN","RORXU006",141,0)
 . S I=""
"RTN","RORXU006",142,0)
 . F  S I=$O(RORTSK("PARAMS","LABTESTS",I))  Q:I=""  D
"RTN","RORXU006",143,0)
 . . S LTIEN=+RORTSK("PARAMS","LABTESTS",I)  Q:LTIEN'>0
"RTN","RORXU006",144,0)
 . . ;--- Load the lab test parameters
"RTN","RORXU006",145,0)
 . . S IENS=LTIEN_","
"RTN","RORXU006",146,0)
 . . D GETS^DIQ(60,IENS,".01;5","EI","RORBUF","RORMSG")
"RTN","RORXU006",147,0)
 . . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,60,IENS)
"RTN","RORXU006",148,0)
 . . ;--- Output the tag
"RTN","RORXU006",149,0)
 . . S LTNAME=$G(RORBUF(60,IENS,.01,"E"))  Q:LTNAME=""
"RTN","RORXU006",150,0)
 . . D ADDVAL^RORTSK11(RORTSK,"LT",LTNAME,LTAG,,LTIEN)
"RTN","RORXU006",151,0)
 . . Q:ROR8LST=""
"RTN","RORXU006",152,0)
 . . ;--- Create the reference
"RTN","RORXU006",153,0)
 . . S LTNODE=$P($G(RORBUF(60,IENS,5,"I")),";",2)  Q:LTNODE=""
"RTN","RORXU006",154,0)
 . . S BUF=LTIEN_U_LTNAME_U_"99^Other"
"RTN","RORXU006",155,0)
 . . S $P(BUF,U,5)=$P(RORBUF(60,IENS,5,"I"),";")  ; Subscript
"RTN","RORXU006",156,0)
 . . S $P(BUF,U,6)=LTNODE                         ; Result node
"RTN","RORXU006",157,0)
 . . S @ROR8LST@(LTNODE,LTIEN)=BUF
"RTN","RORXU006",158,0)
 E  D:$G(RORTSK("PARAMS","LABTESTS"))="ALL"
"RTN","RORXU006",159,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"LABTESTS","ALL",PARTAG)
"RTN","RORXU006",160,0)
 . S:ROR8LST'="" @ROR8LST@("ALL")=""
"RTN","RORXU006",161,0)
 Q +$G(LTAG)
"RTN","RORXU006",162,0)
 ;
"RTN","RORXU006",163,0)
 ;***** CHECK IF ONLY THE SUMMARY SHOULD BE GENERATED
"RTN","RORXU006",164,0)
SMRYONLY() ;
"RTN","RORXU006",165,0)
 Q:$$PARAM^RORTSK01("MAXUTNUM")'="" 0
"RTN","RORXU006",166,0)
 Q:$$PARAM^RORTSK01("MINRPNUM")'="" 0
"RTN","RORXU006",167,0)
 Q 1
"RTN","RORXU007")
0^173^B35921513
"RTN","RORXU007",1,0)
RORXU007 ;HCIOFO/SG - REPORT PARAMETERS ; 11/24/03 3:44pm
"RTN","RORXU007",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**5**;May 14, 2002
"RTN","RORXU007",3,0)
 ;
"RTN","RORXU007",4,0)
 ; This routine uses the following IAs:
"RTN","RORXU007",5,0)
 ;
"RTN","RORXU007",6,0)
 ; #91           Read access to the file #60 (controlled)
"RTN","RORXU007",7,0)
 ;
"RTN","RORXU007",8,0)
 Q
"RTN","RORXU007",9,0)
 ;
"RTN","RORXU007",10,0)
 ;***** COMPILES THE LIST OF DRUGS FROM AVAILABLE SOURCES
"RTN","RORXU007",11,0)
 ;
"RTN","RORXU007",12,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORXU007",13,0)
 ;
"RTN","RORXU007",14,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORXU007",15,0)
 ;
"RTN","RORXU007",16,0)
 ; ROR8RXL       Closed root of an array, which will contain a list
"RTN","RORXU007",17,0)
 ;               of drugs to search for in the same format as the
"RTN","RORXU007",18,0)
 ;               list returned by $$DRUGLIST^RORUTL16.
"RTN","RORXU007",19,0)
 ;               By default ($G(ROR8RXL)=""), the ^TMP("RORXU007",$J)
"RTN","RORXU007",20,0)
 ;               global node will be used.
"RTN","RORXU007",21,0)
 ;
"RTN","RORXU007",22,0)
 ; .RX8OPT       Reference to a local variable for drug options
"RTN","RORXU007",23,0)
 ; .VC8OPT       Reference to a local variable for drug class options
"RTN","RORXU007",24,0)
 ;
"RTN","RORXU007",25,0)
 ; The ^TMP("RORXU007",$J) and ^TMP("RORXU007T",$J) global nodes are
"RTN","RORXU007",26,0)
 ; used by this function.
"RTN","RORXU007",27,0)
 ;
"RTN","RORXU007",28,0)
 ; Return Values:
"RTN","RORXU007",29,0)
 ;       <0  Error code
"RTN","RORXU007",30,0)
 ;      "*"  All drugs
"RTN","RORXU007",31,0)
 ;      ...  Closed root of the drug list
"RTN","RORXU007",32,0)
 ;
"RTN","RORXU007",33,0)
COMBRXL(RORTSK,PARTAG,ROR8RXL,RX8OPT,VC8OPT) ;
"RTN","RORXU007",34,0)
 N IEN,RC,REGIEN,ROR8TMP,TMP
"RTN","RORXU007",35,0)
 S:$G(ROR8RXL)="" ROR8RXL=$NA(^TMP("RORXU007",$J))
"RTN","RORXU007",36,0)
 S REGIEN=+$$PARAM^RORTSK01("REGIEN")
"RTN","RORXU007",37,0)
 S ROR8TMP=$NA(^TMP("RORXU007T",$J))
"RTN","RORXU007",38,0)
 K @ROR8RXL  S RC=0
"RTN","RORXU007",39,0)
 ;
"RTN","RORXU007",40,0)
 D
"RTN","RORXU007",41,0)
 . ;--- Process the list of drugs and options
"RTN","RORXU007",42,0)
 . S RC=$$DRUGLST(.RORTSK,PARTAG,ROR8RXL,.RX8OPT)
"RTN","RORXU007",43,0)
 . Q:RC<0
"RTN","RORXU007",44,0)
 . ;--- Process the list of drug classes and options
"RTN","RORXU007",45,0)
 . S RC=$$VARXCLST(.RORTSK,PARTAG,$NA(@ROR8TMP@("C")),.VC8OPT)
"RTN","RORXU007",46,0)
 . Q:RC<0
"RTN","RORXU007",47,0)
 . ;--- All drugs have been requested
"RTN","RORXU007",48,0)
 . I $D(RX8OPT("ALL"))!$D(VC8OPT("ALL"))  D  Q
"RTN","RORXU007",49,0)
 . . K @ROR8RXL  S ROR8RXL="*"
"RTN","RORXU007",50,0)
 . ;
"RTN","RORXU007",51,0)
 . ;--- Add the list of registry-specific drugs
"RTN","RORXU007",52,0)
 . S TMP="AR"
"RTN","RORXU007",53,0)
 . S:$D(RX8OPT("ARV")) TMP=TMP_"DG"
"RTN","RORXU007",54,0)
 . S:$D(RX8OPT("INVESTIG")) TMP=TMP_"C"
"RTN","RORXU007",55,0)
 . I TMP'="AR"  D  Q:RC<0
"RTN","RORXU007",56,0)
 . . S RC=$$DRUGLIST^RORUTL16(ROR8RXL,REGIEN,TMP)
"RTN","RORXU007",57,0)
 . ;
"RTN","RORXU007",58,0)
 . ;--- Add VA drug classes from the report parameters
"RTN","RORXU007",59,0)
 . S IEN=0
"RTN","RORXU007",60,0)
 . F  S IEN=$O(@ROR8TMP@("C",IEN))  Q:IEN'>0  D
"RTN","RORXU007",61,0)
 . . D RXADDVCL^RORUTL16(ROR8RXL,IEN,0)
"RTN","RORXU007",62,0)
 ;
"RTN","RORXU007",63,0)
 ;--- Cleanup
"RTN","RORXU007",64,0)
 K @ROR8TMP
"RTN","RORXU007",65,0)
 Q $S(RC<0:RC,1:ROR8RXL)
"RTN","RORXU007",66,0)
 ;
"RTN","RORXU007",67,0)
 ;***** PROCESSES THE "DRUGS" REPORT PARAMETER
"RTN","RORXU007",68,0)
 ;
"RTN","RORXU007",69,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORXU007",70,0)
 ;
"RTN","RORXU007",71,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORXU007",72,0)
 ;
"RTN","RORXU007",73,0)
 ; ROR8LTST      Closed root of a variable, which will contain
"RTN","RORXU007",74,0)
 ;               the IEN's of dispensed drugs. If this parameter is
"RTN","RORXU007",75,0)
 ;               undefined or empty, the list will not be compiled.
"RTN","RORXU007",76,0)
 ;
"RTN","RORXU007",77,0)
 ;                 @ROR8LTST@(DrugIEN) = GroupID
"RTN","RORXU007",78,0)
 ;
"RTN","RORXU007",79,0)
 ; [.ROR8OPT]    Reference to a local array for drug options
"RTN","RORXU007",80,0)
 ;
"RTN","RORXU007",81,0)
 ; [.GRPLST]     Reference to a local variable, which will contain
"RTN","RORXU007",82,0)
 ;               the list of groups.
"RTN","RORXU007",83,0)
 ;
"RTN","RORXU007",84,0)
 ;                 GRPLST(GroupID)=""
"RTN","RORXU007",85,0)
 ;
"RTN","RORXU007",86,0)
 ; Return Values:
"RTN","RORXU007",87,0)
 ;       <0  Error code
"RTN","RORXU007",88,0)
 ;       >0  IEN of the DRUGS element
"RTN","RORXU007",89,0)
 ;
"RTN","RORXU007",90,0)
DRUGLST(RORTSK,PARTAG,ROR8LST,ROR8OPT,GRPLST) ;
"RTN","RORXU007",91,0)
 N GENERIC,LTAG,RC,RORI
"RTN","RORXU007",92,0)
 S ROR8LST=$G(ROR8LST),LTAG=0
"RTN","RORXU007",93,0)
 K:ROR8LST'="" @ROR8LST
"RTN","RORXU007",94,0)
 S ROR8OPT=$$PARAM^RORTSK01("DRUGS")
"RTN","RORXU007",95,0)
 D LIST^RORXU002(.ROR8OPT)
"RTN","RORXU007",96,0)
 ;
"RTN","RORXU007",97,0)
 ;--- Process the drug options (if present)
"RTN","RORXU007",98,0)
 I $D(ROR8OPT)>1  D  Q:LTAG'>0 LTAG
"RTN","RORXU007",99,0)
 . S RORI=""
"RTN","RORXU007",100,0)
 . I $D(ROR8OPT("ALL"))  D  S RORI="ALL"
"RTN","RORXU007",101,0)
 . . S:ROR8LST'="" @ROR8LST@("ALL")=""
"RTN","RORXU007",102,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"DRUGS",RORI,PARTAG)
"RTN","RORXU007",103,0)
 . Q:LTAG'>0
"RTN","RORXU007",104,0)
 . ;--- Temporary patch for 'IN150' (investigational drugs)
"RTN","RORXU007",105,0)
 . D:$D(ROR8OPT("VARXCLS"))
"RTN","RORXU007",106,0)
 . . K ROR8OPT("VARXCLS"),RORTSK("PARAMS","VADRUGCLS")
"RTN","RORXU007",107,0)
 . . S ROR8OPT("INVESTIG")=""
"RTN","RORXU007",108,0)
 . ;--- Output option attributes
"RTN","RORXU007",109,0)
 . S RORI="",RC=0
"RTN","RORXU007",110,0)
 . F  S RORI=$O(ROR8OPT(RORI))  Q:RORI=""  D  Q:RC<0
"RTN","RORXU007",111,0)
 . . S RC=$$ADDATTR^RORTSK11(RORTSK,LTAG,RORI,"1")
"RTN","RORXU007",112,0)
 . S:RC<0 LTAG=RC
"RTN","RORXU007",113,0)
 . S RORI=$$OPTXT^RORXU002(.ROR8OPT)
"RTN","RORXU007",114,0)
 . D:RORI'="" ADDATTR^RORTSK11(RORTSK,LTAG,"DESCR",RORI)
"RTN","RORXU007",115,0)
 ;
"RTN","RORXU007",116,0)
 ;--- Process the list of drugs (if present)
"RTN","RORXU007",117,0)
 I '$D(ROR8OPT("ALL"))  D:$D(RORTSK("PARAMS","DRUGS"))>1
"RTN","RORXU007",118,0)
 . N GROUP,IG,RORMSG,RXFILE
"RTN","RORXU007",119,0)
 . I LTAG'>0  D  Q:LTAG'>0
"RTN","RORXU007",120,0)
 . . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"DRUGS",,PARTAG)
"RTN","RORXU007",121,0)
 . S GENERIC=($D(ROR8OPT("GENERIC"))>0)
"RTN","RORXU007",122,0)
 . S RXFILE=$S(GENERIC:50.6,1:50)
"RTN","RORXU007",123,0)
 . ;---
"RTN","RORXU007",124,0)
 . S IG=$O(RORTSK("PARAMS","DRUGS",""))  Q:IG=""
"RTN","RORXU007",125,0)
 . I $D(RORTSK("PARAMS","DRUGS",IG))>1  D
"RTN","RORXU007",126,0)
 . . S IG=""
"RTN","RORXU007",127,0)
 . . F  S IG=$O(RORTSK("PARAMS","DRUGS",IG))  Q:IG=""  D
"RTN","RORXU007",128,0)
 . . . S GROUP=$$ADDVAL^RORTSK11(RORTSK,"GROUP",,LTAG)  Q:GROUP'>0
"RTN","RORXU007",129,0)
 . . . D ADDATTR^RORTSK11(RORTSK,GROUP,"NAME","RX"_IG)
"RTN","RORXU007",130,0)
 . . . D DRUGLST1($NA(RORTSK("PARAMS","DRUGS",IG)),GROUP,IG)
"RTN","RORXU007",131,0)
 . . . S GRPLST(IG)=""
"RTN","RORXU007",132,0)
 . E  D DRUGLST1($NA(RORTSK("PARAMS","DRUGS")),LTAG)
"RTN","RORXU007",133,0)
 ;---
"RTN","RORXU007",134,0)
 Q LTAG
"RTN","RORXU007",135,0)
 ;
"RTN","RORXU007",136,0)
DRUGLST1(NODE,PTAG,IG) ;
"RTN","RORXU007",137,0)
 N ID,IEN,NAME
"RTN","RORXU007",138,0)
 S ID=""
"RTN","RORXU007",139,0)
 F  S ID=$O(@NODE@(ID))  Q:ID=""  D
"RTN","RORXU007",140,0)
 . S IEN=+$G(@NODE@(ID))  Q:IEN'>0
"RTN","RORXU007",141,0)
 . S NAME=$$GET1^DIQ(RXFILE,IEN,.01,,,"RORMSG")
"RTN","RORXU007",142,0)
 . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,RXFILE,IEN)
"RTN","RORXU007",143,0)
 . Q:NAME=""
"RTN","RORXU007",144,0)
 . D ADDVAL^RORTSK11(RORTSK,"DRUG",NAME,PTAG,,IEN)
"RTN","RORXU007",145,0)
 . Q:ROR8LST=""
"RTN","RORXU007",146,0)
 . I GENERIC  D RXADDGEN^RORUTL16(ROR8LST,IEN,1,$G(IG))  Q
"RTN","RORXU007",147,0)
 . S @ROR8LST@(IEN)=$G(IG)
"RTN","RORXU007",148,0)
 Q
"RTN","RORXU007",149,0)
 ;
"RTN","RORXU007",150,0)
 ;***** PROCESSES THE "VA DRUG CLASSES" REPORT PARAMETER
"RTN","RORXU007",151,0)
 ;
"RTN","RORXU007",152,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORXU007",153,0)
 ;
"RTN","RORXU007",154,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORXU007",155,0)
 ;
"RTN","RORXU007",156,0)
 ; [ROR8LST]     Closed root of an array where the IEN's of
"RTN","RORXU007",157,0)
 ;               drug classes will be returned to (as subscripts).
"RTN","RORXU007",158,0)
 ;               If this parameter is undefined or empty, the
"RTN","RORXU007",159,0)
 ;               list will not be compiled.
"RTN","RORXU007",160,0)
 ;
"RTN","RORXU007",161,0)
 ; [.ROR8OPT]    Reference to a local array for drug class options
"RTN","RORXU007",162,0)
 ;
"RTN","RORXU007",163,0)
 ; Return Values:
"RTN","RORXU007",164,0)
 ;       <0  Error code
"RTN","RORXU007",165,0)
 ;        0  No drug class parameters
"RTN","RORXU007",166,0)
 ;       >0  IEN of the VARXCLS element
"RTN","RORXU007",167,0)
 ;
"RTN","RORXU007",168,0)
VARXCLST(RORTSK,PARTAG,ROR8LST,ROR8OPT) ;
"RTN","RORXU007",169,0)
 N IEN,LTAG,RORI,RORMSG,VACL
"RTN","RORXU007",170,0)
 S ROR8LST=$G(ROR8LST),LTAG=0
"RTN","RORXU007",171,0)
 K:ROR8LST'="" @ROR8LST
"RTN","RORXU007",172,0)
 S ROR8OPT=$$PARAM^RORTSK01("VADRUGCLS")
"RTN","RORXU007",173,0)
 D LIST^RORXU002(.ROR8OPT)
"RTN","RORXU007",174,0)
 ;
"RTN","RORXU007",175,0)
 ;--- Process the drug class options (if present)
"RTN","RORXU007",176,0)
 I $D(ROR8OPT)>1  D  Q:LTAG'>0 LTAG
"RTN","RORXU007",177,0)
 . S RORI=""
"RTN","RORXU007",178,0)
 . I $D(ROR8OPT("ALL"))  D  S RORI="ALL"
"RTN","RORXU007",179,0)
 . . S:ROR8LST'="" @ROR8LST@("ALL")=""
"RTN","RORXU007",180,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"VARXCLS",RORI,PARTAG)
"RTN","RORXU007",181,0)
 . Q:LTAG'>0
"RTN","RORXU007",182,0)
 . ;--- Output option attributes
"RTN","RORXU007",183,0)
 . S RORI="",RC=0
"RTN","RORXU007",184,0)
 . F  S RORI=$O(ROR8OPT(RORI))  Q:RORI=""  D  Q:RC<0
"RTN","RORXU007",185,0)
 . . S RC=$$ADDATTR^RORTSK11(RORTSK,LTAG,RORI,"1")
"RTN","RORXU007",186,0)
 . S:RC<0 LTAG=RC
"RTN","RORXU007",187,0)
 . S RORI=$$OPTXT^RORXU002(.ROR8OPT)
"RTN","RORXU007",188,0)
 . D:RORI'="" ADDATTR^RORTSK11(RORTSK,LTAG,"DESCR",RORI)
"RTN","RORXU007",189,0)
 ;
"RTN","RORXU007",190,0)
 ;--- Process the list of classes (if present)
"RTN","RORXU007",191,0)
 I '$D(ROR8OPT("ALL"))  D:$D(RORTSK("PARAMS","VADRUGCLS"))>1
"RTN","RORXU007",192,0)
 . I LTAG'>0  D  Q:LTAG'>0
"RTN","RORXU007",193,0)
 . . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"VARXCLS",,PARTAG)
"RTN","RORXU007",194,0)
 . ;---
"RTN","RORXU007",195,0)
 . S RORI=""
"RTN","RORXU007",196,0)
 . F  S RORI=$O(RORTSK("PARAMS","VADRUGCLS",RORI))  Q:RORI=""  D
"RTN","RORXU007",197,0)
 . . S VACL=RORTSK("PARAMS","VADRUGCLS",RORI)  Q:VACL=""
"RTN","RORXU007",198,0)
 . . S IEN=$$FIND1^DIC(50.605,,,VACL,"B",,"RORMSG")
"RTN","RORXU007",199,0)
 . . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,50.605)
"RTN","RORXU007",200,0)
 . . Q:IEN'>0
"RTN","RORXU007",201,0)
 . . D ADDVAL^RORTSK11(RORTSK,"VARXCL",VACL,LTAG,,IEN)
"RTN","RORXU007",202,0)
 . . S:ROR8LST'="" @ROR8LST@(IEN)=""
"RTN","RORXU007",203,0)
 ;---
"RTN","RORXU007",204,0)
 Q LTAG
"SEC","^DD",799.4,799.4,10,9)

"SEC","^DD",799.4,799.41,.01,8.5)

"SEC","^DD",799.4,799.41,.01,9)

"SEC","^DD",799.4,799.41,.02,8.5)

"SEC","^DD",799.4,799.41,.02,9)

"SEC","^DD",799.4,799.41,.03,8.5)

"SEC","^DD",799.4,799.41,.03,9)

"SEC","^DIC",798.8,798.8,0,"AUDIT")
@
"SEC","^DIC",798.8,798.8,0,"DD")
@
"SEC","^DIC",798.8,798.8,0,"DEL")
@
"SEC","^DIC",798.8,798.8,0,"LAYGO")
@
"SEC","^DIC",798.8,798.8,0,"RD")

"SEC","^DIC",798.8,798.8,0,"WR")
@
"SEC","^DIC",799.31,799.31,0,"AUDIT")
@
"SEC","^DIC",799.31,799.31,0,"DD")
@
"SEC","^DIC",799.31,799.31,0,"DEL")
@
"SEC","^DIC",799.31,799.31,0,"LAYGO")
@
"SEC","^DIC",799.31,799.31,0,"RD")

"SEC","^DIC",799.31,799.31,0,"WR")
@
"SEC","^DIC",799.33,799.33,0,"AUDIT")
@
"SEC","^DIC",799.33,799.33,0,"DD")
@
"SEC","^DIC",799.33,799.33,0,"DEL")
@
"SEC","^DIC",799.33,799.33,0,"LAYGO")
@
"SEC","^DIC",799.33,799.33,0,"RD")

"SEC","^DIC",799.33,799.33,0,"WR")
@
"SEC","^DIC",799.34,799.34,0,"AUDIT")
@
"SEC","^DIC",799.34,799.34,0,"DD")
@
"SEC","^DIC",799.34,799.34,0,"DEL")
@
"SEC","^DIC",799.34,799.34,0,"LAYGO")
@
"SEC","^DIC",799.34,799.34,0,"RD")
@
"SEC","^DIC",799.34,799.34,0,"WR")
@
"SEC","^DIC",799.4,799.4,0,"AUDIT")
@
"SEC","^DIC",799.4,799.4,0,"DD")
@
"SEC","^DIC",799.4,799.4,0,"DEL")
@
"SEC","^DIC",799.4,799.4,0,"LAYGO")
@
"SEC","^DIC",799.4,799.4,0,"RD")

"SEC","^DIC",799.4,799.4,0,"WR")
@
"SEC","^DIC",799.49,799.49,0,"AUDIT")
@
"SEC","^DIC",799.49,799.49,0,"DD")
@
"SEC","^DIC",799.49,799.49,0,"DEL")
@
"SEC","^DIC",799.49,799.49,0,"LAYGO")
@
"SEC","^DIC",799.49,799.49,0,"RD")

"SEC","^DIC",799.49,799.49,0,"WR")
@
"SEC","^DIC",799.51,799.51,0,"AUDIT")
@
"SEC","^DIC",799.51,799.51,0,"DD")
@
"SEC","^DIC",799.51,799.51,0,"DEL")
@
"SEC","^DIC",799.51,799.51,0,"LAYGO")
@
"SEC","^DIC",799.51,799.51,0,"RD")

"SEC","^DIC",799.51,799.51,0,"WR")
@
"TEMP","RORCDCDEF",1)

"TEMP","RORCDCDEF",2)
edt1_1=^^548^87^32^^49^^^^1^^^^^^Name
"TEMP","RORCDCDEF",3)
edt1_3=^^246^178^22^^49^^^^1^ADR^3^^13^^Address
"TEMP","RORCDCDEF",4)
edt1_4=^^1083^178^22^^49^^^^1^ADR^6^^13^^City
"TEMP","RORCDCDEF",5)
edt1_5=^^1512^178^22^^49^^^^1^ADR^12^^13^^County
"TEMP","RORCDCDEF",6)
edt1_6=^^2205^178^22^^49^^^^1^ADR^9^^13^^ZIP
"TEMP","RORCDCDEF",7)
cmbb1_1=^^1872^176^24^^49^^^^1^ADR^8^^13^^
"TEMP","RORCDCDEF",8)
edt1_2=^^2020^108^22^^49^^^^1^ADR^13^^13^^Phone
"TEMP","RORCDCDEF",9)
edt1_7=^^1872^178^22^^49^^^^1^ADR^^^^^State
"TEMP","RORCDCDEF",10)
dtp2_1=^^161^567^30^MMDDYY^49^117^^^1^HDR^3^^6^^Date form was Completed
"TEMP","RORCDCDEF",11)
edt2_1=^^^^32^^49^^^^1^^^^^^
"TEMP","RORCDCDEF",12)
edt2_2=^^^^32^^49^^^^1^^^^^^
"TEMP","RORCDCDEF",13)
edt2_3=^^^^32^^49^^^^1^^^^^^
"TEMP","RORCDCDEF",14)
edt2_4=^^^^32^^49^^^^1^^^^^^
"TEMP","RORCDCDEF",15)
edt2_5=^^^^32^^49^^^^1^^^^^^
"TEMP","RORCDCDEF",16)
edt2_6=^^^^32^^49^^^^1^^^^^^
"TEMP","RORCDCDEF",17)
chkb2_1=^^^^32^^49^^^^1^^^^^^
"TEMP","RORCDCDEF",18)
chkb2_2=^^^^32^^49^^^^1^^^^^^
"TEMP","RORCDCDEF",19)
edt3_3_1=^^1985^871^22^^49^^^^1^DEM^7^^8^^Territory of death
"TEMP","RORCDCDEF",20)
chkb3_3_1=^^1301^910^25^^49^^^^1^CDM^1^^14^^Current Status Alive
"TEMP","RORCDCDEF",21)
chkb3_3_2=^^1393^910^25^^49^^^^1^CDM^2^^14^^Current Status Dead
"TEMP","RORCDCDEF",22)
chkb3_3_3=^^1485^910^25^^49^^^^1^CDM^9^^14^^Current Status Unk
"TEMP","RORCDCDEF",23)
edt3_3_2=^^1607^902^30^MMDDYY^58^116^^^1^CDM^6^^14^^Date of Death
"TEMP","RORCDCDEF",24)
edt3_2_1=^^885^902^30^MMDDYY^58^115^^^1^DEM^7^^8^^Date of Birth
"TEMP","RORCDCDEF",25)
edt3_1_2=^^574^910^30^BoxedLine^54^2^^^1^CDM^4^^14^^AIDS age
"TEMP","RORCDCDEF",26)
chkb3_1_1=^^126^868^25^^49^^^^1^CDM^3^1^14^^Diagnostic status HIV
"TEMP","RORCDCDEF",27)
chkb3_1_2=^^126^923^25^^49^^^^1^CDM^3^2^14^^Diagnostic status AIDS
"TEMP","RORCDCDEF",28)
edt3_1_1=^^574^848^30^BoxedLine^54^2^^^1^CDM^4^^14^^HIV Age
"TEMP","RORCDCDEF",29)
chkb3_5_1=^^355^1040^25^^49^^^^1^ETN^3^2135-2^6^^Ethnicity Hispanic
"TEMP","RORCDCDEF",30)
chkb3_5_2=^^543^1039^25^^49^^^^1^ETN^3^2186-5^6^^Ethnicity Unk
"TEMP","RORCDCDEF",31)
chkb3_5_3=^^355^1101^25^^49^^^^1^ETN^3^9999-4^6^^Ethnicity Not Hispanic
"TEMP","RORCDCDEF",32)
chkb3_4_1=^^127^1040^25^^49^^^^1^DEM^8^M^8^^Sex Male
"TEMP","RORCDCDEF",33)
chkb3_4_2=^^126^1106^25^^49^^^^1^DEM^8^F^8^^Sex Female
"TEMP","RORCDCDEF",34)
chkb3_6_1=^^730^1039^25^^49^^^^1^RCE^3^1002-5^6^^Race American
"TEMP","RORCDCDEF",35)
chkb3_6_2=^^730^1118^25^^49^^^^1^RCE^3^2028-9^6^^Race Asian
"TEMP","RORCDCDEF",36)
chkb3_6_4=^^864^1119^25^^49^^^^1^RCE^3^2054-5^6^^Race Hawaiian
"TEMP","RORCDCDEF",37)
chkb3_6_3=^^1001^1039^25^^49^^^^1^RCE^3^2076-8^6^^Race Black Am
"TEMP","RORCDCDEF",38)
chkb3_6_6=^^1334^1115^25^^49^^^^1^RCE^3^2106-3^6^^Race Unkn.
"TEMP","RORCDCDEF",39)
chkb3_6_5=^^1189^1114^25^^49^^^^1^RCE^3^9999-4^6^^Race White
"TEMP","RORCDCDEF",40)
chkb3_7_1=^^1501^1019^25^^49^^^^1^CDM^7^1^14^^Country of Birth USA
"TEMP","RORCDCDEF",41)
chkb3_7_2=^^1643^1018^25^^49^^^^1^CDM^7^7^14^^Country of Birth US Depend
"TEMP","RORCDCDEF",42)
chkb3_7_4=^^2339^1123^25^^49^^^^1^CDM^7^9^14^^Country of Birth Unk.
"TEMP","RORCDCDEF",43)
edt3_7_1=^^1811^1065^22^^49^^^^1^CDM^8^^14^^Country of Birth USA Dep Name
"TEMP","RORCDCDEF",44)
chkb3_7_3=^^1501^1119^25^^49^^^^1^CDM^7^8^14^^Country of Birth Other
"TEMP","RORCDCDEF",45)
edt3_7_2=^^1765^1122^22^^49^^^^1^CDM^8^^14^^Country of Birth Other Name
"TEMP","RORCDCDEF",46)
edt3_8_2=^^864^1234^22^^49^^^^1^CDM^10^^14^^Residence County
"TEMP","RORCDCDEF",47)
edt3_8_1=^^214^1234^22^^49^^^^1^CDM^9^^14^^Residence City
"TEMP","RORCDCDEF",48)
edt3_8_4=^^1974^1215^30^BoxedLine^49^9^^^1^CDM^14^^14^ZIP^Residence ZIP
"TEMP","RORCDCDEF",49)
edt3_8_5=^^1383^1234^22^^49^^^^1^CDM^13^^14^^Residence Country
"TEMP","RORCDCDEF",50)
cmbb3_8_1=^^^^39^^49^^^^1^CDM^14^^14^ZIP^
"TEMP","RORCDCDEF",51)
chkb4_3_1=^^130^1806^25^^49^^^^1^FD^9^01^10^^Diagnostic Facility Type Physitcan, HMO
"TEMP","RORCDCDEF",52)
chkb4_3_2=^^484^1806^25^^49^^^^1^FD^9^31^10^^Diagnostic Facility Type Inpatient
"TEMP","RORCDCDEF",53)
chkb4_3_3=^^129^1865^25^^49^^^^1^FD^9^88^10^^Diagnostic Facility Type Other
"TEMP","RORCDCDEF",54)
edt4_3_1=^^397^1859^22^^49^^^^1^FD^10^^10^^Diagnostic Facility Type Other Name
"TEMP","RORCDCDEF",55)
chkb4_2_1=^^130^1694^25^^49^^^^1^FD^8^1^10^^Diagnostic Facility Setting Public
"TEMP","RORCDCDEF",56)
chkb4_2_2=^^339^1694^25^^49^^^^1^FD^8^2^10^^Diagnostic Facility Setting Private
"TEMP","RORCDCDEF",57)
chkb4_2_3=^^551^1694^25^^49^^^^1^FD^8^3^10^^Diagnostic Facility Setting  Federal
"TEMP","RORCDCDEF",58)
chkb4_2_4=^^772^1694^25^^49^^^^1^FD^8^9^10^^Diagnostic Facility Setting Unk
"TEMP","RORCDCDEF",59)
edt4_1_1=^^125^1402^22^^49^^^^1^FD^3^^10^^Diagnostic Facility Name
"TEMP","RORCDCDEF",60)
edt4_1_2=^^125^1474^22^^49^^^^1^FD^4^^10^^Diagnostic Facility City
"TEMP","RORCDCDEF",61)
edt4_1_4=^^125^1550^22^^49^^^^1^FD^7^^10^^Facility Country
"TEMP","RORCDCDEF",62)
cmbb4_1_1=^^125^1550^22^^49^^^^1^FD^6^^10^^Diagnostic Facility Setting  State
"TEMP","RORCDCDEF",63)
chkb5_14_1=^^2228^2209^24^^49^^^^1^PH^19^1^20^^Work in Clinical Lab Yes
"TEMP","RORCDCDEF",64)
chkb5_14_2=^^2316^2209^24^^49^^^^1^PH^19^0^20^^Work in Clinical Lab No
"TEMP","RORCDCDEF",65)
chkb5_14_3=^^2399^2209^24^^49^^^^1^PH^19^9^20^^Work in Clinical Lab Unk.
"TEMP","RORCDCDEF",66)
edt5_14_1=^^1420^2257^22^^49^^^^1^PH^20^^20^^Work in Clinical Lab Name
"TEMP","RORCDCDEF",67)
chkb5_12_1=^^2228^2163^24^^49^^^^1^PH^18^1^20^^Received Transpalnt Yes
"TEMP","RORCDCDEF",68)
chkb5_12_2=^^2316^2163^24^^49^^^^1^PH^18^0^20^^Received Transpalnt No
"TEMP","RORCDCDEF",69)
chkb5_12_3=^^2398^2163^24^^49^^^^1^PH^18^9^20^^Received Transpalnt Unk
"TEMP","RORCDCDEF",70)
chkb5_11_1=^^2228^2038^24^^49^^^^1^PH^15^1^20^^Received Transfusion Yes
"TEMP","RORCDCDEF",71)
chkb5_11_2=^^2316^2038^24^^49^^^^1^PH^15^0^20^^Received Transfusion No
"TEMP","RORCDCDEF",72)
chkb5_11_3=^^2399^2038^24^^49^^^^1^PH^15^9^20^^Received Transfusion Unk
"TEMP","RORCDCDEF",73)
edV_FirstYear=^^1357^2107^30^MMYY^50^170^^^1^PH^16^^20^MM/YY^Received Transfusion First
"TEMP","RORCDCDEF",74)
edV_LastYear=^^1766^2107^30^MMYY^50^170^^^1^PH^17^^20^MM/YY^Received Transfusion Last
"TEMP","RORCDCDEF",75)
chkb5_10_1=^^2228^1992^24^^49^^^^1^PH^14^1^20^^Hetero SR with Person with AIDS Yes
"TEMP","RORCDCDEF",76)
chkb5_10_2=^^2316^1992^24^^49^^^^1^PH^14^0^20^^Hetero SR with Person with AIDS No
"TEMP","RORCDCDEF",77)
chkb5_10_3=^^2398^1992^24^^49^^^^1^PH^14^9^20^^Hetero SR with Person with AIDS Unk.
"TEMP","RORCDCDEF",78)
chkb5_9_1=^^2228^1946^25^^49^^^^1^PH^13^1^20^^Hetero SR with Transplant recepient Yes
"TEMP","RORCDCDEF",79)
chkb5_9_2=^^2315^1946^25^^49^^^^1^PH^13^0^20^^Hetero SR with Transplant recepient No
"TEMP","RORCDCDEF",80)
chkb5_9_3=^^2398^1946^25^^49^^^^1^PH^13^9^20^^Hetero SR with Transplant recepient Unk
"TEMP","RORCDCDEF",81)
chkb5_8_1=^^2228^1901^24^^49^^^^1^PH^12^1^20^^Hetero SR with Transfusion recepient Yes
"TEMP","RORCDCDEF",82)
chkb5_8_2=^^2316^1901^24^^49^^^^1^PH^12^0^20^^Hetero SR with Transfusion recepient No
"TEMP","RORCDCDEF",83)
chkb5_8_3=^^2399^1901^24^^49^^^^1^PH^12^9^20^^Hetero SR with Transfusion recepient Unk
"TEMP","RORCDCDEF",84)
chkb5_7_1=^^2228^1855^24^^49^^^^1^PH^11^1^20^^Hetero SR with Hemofilia Yes
"TEMP","RORCDCDEF",85)
chkb5_7_2=^^2316^1855^24^^49^^^^1^PH^11^0^20^^Hetero SR with Hemofilia  No
"TEMP","RORCDCDEF",86)
chkb5_7_3=^^2398^1855^24^^49^^^^1^PH^11^9^20^^Hetero SR with Hemofilia Unk
"TEMP","RORCDCDEF",87)
chkb5_6_1=^^2228^1809^24^^49^^^^1^PH^9^1^20^^Hetero SR with Bisexual  male Yes
"TEMP","RORCDCDEF",88)
chkb5_6_2=^^2316^1809^24^^49^^^^1^PH^9^0^20^^Hetero SR with Bisexual  male No
"TEMP","RORCDCDEF",89)
chkb5_6_3=^^2398^1809^24^^49^^^^1^PH^9^9^20^^Hetero SR with Bisexual  male Unk
"TEMP","RORCDCDEF",90)
chkb5_5_1=^^2228^1763^24^^49^^^^1^PH^10^1^20^^Hetero SR with Intravenoue Yes
"TEMP","RORCDCDEF",91)
chkb5_5_2=^^2316^1763^24^^49^^^^1^PH^10^0^20^^Hetero SR with Intravenoue No
"TEMP","RORCDCDEF",92)
chkb5_5_3=^^2398^1763^24^^49^^^^1^PH^10^9^20^^Hetero SR with Intravenoue Unk
"TEMP","RORCDCDEF",93)
chkb5_4_1=^^2228^1601^24^^49^^^^1^PH^6^1^20^^Receiving Clotting Factor  Yes
"TEMP","RORCDCDEF",94)
chkb5_4_2=^^2316^1601^24^^49^^^^1^PH^6^0^20^^Receiving Clotting Factor  No
"TEMP","RORCDCDEF",95)
chkb5_4_3=^^2399^1601^24^^49^^^^1^PH^6^9^20^^Receiving Clotting Factor  Unk
"TEMP","RORCDCDEF",96)
chkb5_4_4=^^1167^1642^27^^49^^^^1^PH^7^1^20^^Receiving Clotting Factor VIII
"TEMP","RORCDCDEF",97)
chkb5_4_5=^^1429^1642^27^^49^^^^1^PH^7^2^20^^Receiving Clotting Factor IX
"TEMP","RORCDCDEF",98)
chkb5_4_6=^^1708^1642^27^^49^^^^1^PH^7^8^20^^Receiving Clotting Factor  Other
"TEMP","RORCDCDEF",99)
edt5_4_1=^^1901^1672^22^^49^^^^1^PH^8^^20^^Receiving Clotting Factor  Other Name
"TEMP","RORCDCDEF",100)
chkb5_3_1=^^2228^1555^24^^49^^^^1^PH^5^1^20^^Injected Drug Yes
"TEMP","RORCDCDEF",101)
chkb5_3_2=^^2316^1555^24^^49^^^^1^PH^5^0^20^^Injected Drug No
"TEMP","RORCDCDEF",102)
chkb5_3_3=^^2398^1555^24^^49^^^^1^PH^5^9^20^^Injected Drug Unk
"TEMP","RORCDCDEF",103)
chkb5_2_1=^^2228^1509^24^^49^^^^1^PH^4^1^20^^Sex With Female Yes
"TEMP","RORCDCDEF",104)
chkb5_2_2=^^2316^1509^24^^49^^^^1^PH^4^0^20^^Sex With Female No
"TEMP","RORCDCDEF",105)
chkb5_2_3=^^2398^1509^24^^49^^^^1^PH^4^9^20^^Sex With Female Unk
"TEMP","RORCDCDEF",106)
chkb5_1_1=^^2228^1463^24^^49^^^^1^PH^3^1^20^^Sex With Male Yes
"TEMP","RORCDCDEF",107)
chkb5_1_2=^^2316^1463^24^^49^^^^1^PH^3^0^20^^Sex With Male No
"TEMP","RORCDCDEF",108)
chkb5_1_3=^^2399^1463^24^^49^^^^1^PH^3^9^20^^Sex With Male Unk
"TEMP","RORCDCDEF",109)
chkb6_8_1=^^2228^2563^24^^49^^^^1^LD2^5^1^14^^HIV-1 Yes
"TEMP","RORCDCDEF",110)
chkb6_8_2=^^2308^2563^24^^49^^^^1^LD2^5^0^14^^HIV-1 No
"TEMP","RORCDCDEF",111)
chkb6_8_3=^^2387^2563^24^^49^^^^1^LD2^5^9^14^^HIV-1 Unk
"TEMP","RORCDCDEF",112)
edt6_8_1=^^2230^2656^30^MMYY^50^170^^^1^LD2^6^^14^MM/YY^HIV Diagnosis by Physician Date
"TEMP","RORCDCDEF",113)
edt6_7_1=^^2230^2448^30^MMYY^50^170^^^1^LD2^4^^14^MM/YY^Lst Documented negative HIV Date
"TEMP","RORCDCDEF",114)
edt6_7_2=^^1557^2469^22^^49^^^^1^LD2^3^^14^^Lst Documented negative HIV Name
"TEMP","RORCDCDEF",115)
edt6_4_1=^^1046^2664^30^MMYY^50^170^^^1^LD1^10^^18^MM/YY^VI. Other HIV Test Date
"TEMP","RORCDCDEF",116)
chkb6_4_1=^^746^2671^27^^49^^^^1^LD1^9^1^18^^VI. Other HIV Test Pos
"TEMP","RORCDCDEF",117)
chkb6_4_2=^^821^2671^27^^49^^^^1^LD1^9^0^18^^VI. Other HIV Test Neg
"TEMP","RORCDCDEF",118)
chkb6_4_3=^^895^2671^27^^49^^^^1^LD1^9^8^18^^VI. Other HIV Test Ind
"TEMP","RORCDCDEF",119)
chkb6_4_4=^^966^2671^27^^49^^^^1^LD1^9^9^18^^VI. Other HIV Not Done
"TEMP","RORCDCDEF",120)
edt6_4_2=^^315^2718^22^^49^^^^1^LD1^11^^18^^VI. Other HIV Test Name
"TEMP","RORCDCDEF",121)
edt6_3_1=^^1046^2598^30^MMYY^50^170^^^1^LD1^8^^18^MM/YY^VI. HIV-1 Western Date
"TEMP","RORCDCDEF",122)
chkb6_3_1=^^746^2605^26^^49^^^^1^LD1^7^1^18^^VI. HIV-1 Western Yes
"TEMP","RORCDCDEF",123)
chkb6_3_2=^^821^2605^26^^49^^^^1^LD1^7^0^18^^VI. HIV-1 Western No
"TEMP","RORCDCDEF",124)
chkb6_3_3=^^896^2605^26^^49^^^^1^LD1^7^8^18^^VI. HIV-1 Western Ind
"TEMP","RORCDCDEF",125)
chkb6_3_4=^^967^2605^26^^49^^^^1^LD1^7^9^18^^VI. HIV-1 Western Not Done
"TEMP","RORCDCDEF",126)
edt6_2_1=^^1046^2531^30^MMYY^50^170^^^1^LD1^6^^18^MM/YY^VI. HIV-1/2 Date
"TEMP","RORCDCDEF",127)
chkb6_2_1=^^746^2538^27^^49^^^^1^LD1^5^1^18^^VI. HIV 1/2 Pos
"TEMP","RORCDCDEF",128)
chkb6_2_2=^^820^2538^27^^49^^^^1^LD1^5^0^18^^VI. HIV 1/2 Neg
"TEMP","RORCDCDEF",129)
chkb6_2_3=^^967^2538^27^^49^^^^1^LD1^5^9^18^^VI. HIV 1/2 Not Done
"TEMP","RORCDCDEF",130)
edt6_1_1=^^1046^2465^30^MMYY^50^170^^^1^LD1^4^^18^MM/YY^VI. HIV-1 EAI Date
"TEMP","RORCDCDEF",131)
chkb6_1_1=^^746^2471^27^^49^^^^1^LD1^3^1^18^^VI. HIV-1 EAI Pos
"TEMP","RORCDCDEF",132)
chkb6_1_2=^^821^2471^27^^49^^^^1^LD1^3^0^18^^VI. HIV-1 EAI Neg
"TEMP","RORCDCDEF",133)
chkb6_1_3=^^966^2471^27^^49^^^^1^LD1^3^9^18^^VI. HIV-1 EAI  Not Done
"TEMP","RORCDCDEF",134)
edt6_5_1=^^1046^2836^30^MMYY^50^170^^^1^LD1^13^^18^MM/YY^VI. Positive HIV Detection Date
"TEMP","RORCDCDEF",135)
edt6_5_2=^^399^2908^22^^49^^^^1^LD1^14^^18^^VI. Positive HIV Detection Other Test Type
"TEMP","RORCDCDEF",136)
edt6_5_3=^^1046^2902^30^MMYY^50^170^^^1^LD1^15^^18^MM/YY^VI. Positive HIV Detection Other Date
"TEMP","RORCDCDEF",137)
chkb6_5_1=^^162^2838^27^^49^^^^1^LD1^12^1^18^^VI. Positive HIV Detection Culture
"TEMP","RORCDCDEF",138)
chkb6_5_2=^^337^2838^27^^49^^^^1^LD1^12^2^18^^VI. Positive HIV Detection Antigen
"TEMP","RORCDCDEF",139)
chkb6_5_3=^^524^2838^27^^49^^^^1^LD1^12^3^18^^VI. Positive HIV Detection PCR, DNA or RNA Probe 
"TEMP","RORCDCDEF",140)
edt6_6_2=^^1046^3074^30^MMYY^50^170^^^1^LD1^18^^18^MM/YY^VI. VIRAL LOAD TEST DATE
"TEMP","RORCDCDEF",141)
cmbb6_6_1=^^301^3073^30^BoxedLine^49^2^^^1^LD1^16^^18^^VI. VIRAL LOAD TEST TYPE 
"TEMP","RORCDCDEF",142)
edt6_6_1=^^517^3073^30^N7^50^29^125^^1^LD1^17^^18^^VI. VIRAL LOAD  COPIES/ML
"TEMP","RORCDCDEF",143)
edt6_9_2=^^2230^2877^30^MMYY^50^170^^^1^LD2^8^^14^MM/YY^VI. IMMUNOLOGY LAB CD4 Count Date
"TEMP","RORCDCDEF",144)
edt6_9_4=^^2230^2944^30^MMYY^50^170^^^1^LD2^10^^14^MM/YY^VI. IMMUNOLOGY LAB CD4 Percent Date
"TEMP","RORCDCDEF",145)
edt6_9_6=^^2230^3058^30^MMYY^50^170^^^1^LD2^12^^14^MM/YY^VI. IMMUNOLOGY LAB First <200ml CD4 Count Date
"TEMP","RORCDCDEF",146)
edt6_9_8=^^2230^3123^30^MMYY^50^170^^^1^LD2^14^^14^MM/YY^VI. IMMUNOLOGY LAB First <200ml CD4 Percent Date
"TEMP","RORCDCDEF",147)
edt6_9_3=^^1938^2944^30^BoxedLine^49^2^^^1^LD2^9^^14^^VI. IMMUNOLOGY LAB CD4 Percent
"TEMP","RORCDCDEF",148)
edt6_9_1=^^1811^2877^30^N4^49^30^^^1^LD2^7^^14^^VI. IMMUNOLOGY LAB CD4 Count
"TEMP","RORCDCDEF",149)
edt6_9_5=^^1810^3057^30^N4^49^30^^^1^LD2^11^^14^^VI. IMMUNOLOGY LAB First <200ml CD4 Count
"TEMP","RORCDCDEF",150)
edt6_9_7=^^1939^3123^30^BoxedLine^49^2^^^1^LD2^13^^14^^VI. IMMUNOLOGY LAB First <200ml CD4 Percent
"TEMP","RORCDCDEF",151)
edt7_1=^^380^111^22^^49^^^^2^^^^^^VII. Physician
"TEMP","RORCDCDEF",152)
edt7_5=^^1320^184^22^PlainLine^49^^^^2^^^^^^VII. Person, compiling form
"TEMP","RORCDCDEF",153)
edt7_3=^^1455^111^22^^49^^^^2^^^^^^VII. Physician Phone
"TEMP","RORCDCDEF",154)
edt7_6=^^2005^184^22^^49^^^^2^^^^^^VII. Person compiling phone
"TEMP","RORCDCDEF",155)
edt7_4=^^355^184^22^^49^^^^2^^^^^^VII. Hospital
"TEMP","RORCDCDEF",156)
edt7_2=^^2140^111^22^^49^^^^2^^^^^^VII. Medical Record Num
"TEMP","RORCDCDEF",157)
edt8_27_1=^^2185^1640^30^MMYY^50^158^^26^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",158)
chkb8_27_1=^^2016^1642^27^^49^^^26^2^AID^3^1^4^^
"TEMP","RORCDCDEF",159)
edt8_26_1=^^2185^1553^30^MMYY^50^158^^25^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",160)
chkb8_26_1=^^2017^1555^26^^49^^^25^2^AID^3^1^4^^
"TEMP","RORCDCDEF",161)
chkb8_26_2=^^2100^1555^26^^49^^^25^2^AID^3^2^4^^
"TEMP","RORCDCDEF",162)
edt8_25_1=^^2185^1464^30^MMYY^50^158^^24^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",163)
chkb8_25_1=^^2016^1467^27^PlainLine^49^1^^24^2^AID^3^1^4^^
"TEMP","RORCDCDEF",164)
edt8_24_1=^^2185^1378^30^MMYY^50^158^^23^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",165)
chkb8_24_1=^^2016^1380^26^^49^^^23^2^AID^3^1^26^^
"TEMP","RORCDCDEF",166)
edt8_23_1=^^2185^1290^30^MMYY^50^158^^22^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",167)
chkb8_23_1=^^2016^1292^27^^49^^^22^2^AID^3^1^4^^
"TEMP","RORCDCDEF",168)
chkb8_23_2=^^2104^1292^27^^49^^^22^2^AID^3^2^4^^
"TEMP","RORCDCDEF",169)
edt8_22_1=^^2185^1204^30^MMYY^50^158^^21^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",170)
chkb8_22_1=^^2017^1205^26^^49^^^21^2^AID^3^1^4^^
"TEMP","RORCDCDEF",171)
chkb8_22_2=^^2104^1205^26^^49^^^21^2^AID^3^2^4^^
"TEMP","RORCDCDEF",172)
edt8_21_1=^^2185^1115^30^MMYY^50^158^^20^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",173)
chkb8_21_1=^^2016^1117^27^^49^^^20^2^AID^3^1^4^^
"TEMP","RORCDCDEF",174)
chkb8_21_2=^^2104^1117^27^^49^^^20^2^AID^3^2^4^^
"TEMP","RORCDCDEF",175)
edt8_20_1=^^2185^1028^30^MMYY^50^158^^19^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",176)
chkb8_20_1=^^2017^1034^26^^49^^^19^2^AID^3^1^4^^
"TEMP","RORCDCDEF",177)
chkb8_20_2=^^2104^1034^26^^49^^^19^2^AID^3^2^4^^
"TEMP","RORCDCDEF",178)
edt8_19_1=^^2185^941^30^MMYY^50^158^^18^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",179)
chkb8_19_1=^^2016^942^27^^49^^^18^2^AID^3^1^4^^
"TEMP","RORCDCDEF",180)
chkb8_19_2=^^2104^942^27^^49^^^18^2^AID^3^2^4^^
"TEMP","RORCDCDEF",181)
edt8_18_1=^^2185^853^30^MMYY^50^158^^17^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",182)
chkb8_18_1=^^2017^855^26^^49^^^17^2^AID^3^1^4^^
"TEMP","RORCDCDEF",183)
chkb8_18_2=^^2104^855^26^PlainLine^49^^^17^2^AID^3^2^4^^
"TEMP","RORCDCDEF",184)
edt8_17_1=^^2185^765^30^MMYY^50^158^^16^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",185)
chkb8_17_1=^^2016^767^27^^49^^^16^2^AID^3^1^4^^
"TEMP","RORCDCDEF",186)
edt8_16_1=^^2185^676^30^MMYY^50^158^^15^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",187)
chkb8_16_1=^^2017^680^26^^49^^^15^2^AID^3^1^4^^
"TEMP","RORCDCDEF",188)
edt8_15_1=^^2185^590^30^MMYY^50^158^^14^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",189)
chkb8_15_1=^^2016^592^27^^49^^^14^2^AID^3^1^4^^
"TEMP","RORCDCDEF",190)
edt8_14_1=^^1019^1640^30^MMYY^50^158^^13^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",191)
chkb8_14_1=^^846^1642^27^^49^^^13^2^AID^3^1^4^^
"TEMP","RORCDCDEF",192)
chkb8_14_2=^^933^1642^27^^49^^^13^2^AID^3^2^4^^
"TEMP","RORCDCDEF",193)
edt8_13_1=^^1019^1552^30^MMYY^50^158^^12^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",194)
chkb8_13_1=^^846^1555^26^^49^^^12^2^AID^3^1^4^^
"TEMP","RORCDCDEF",195)
edt8_12_1=^^1019^1465^30^MMYY^50^158^^11^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",196)
chkb8_12_1=^^845^1467^27^^49^^^11^2^AID^3^1^4^^
"TEMP","RORCDCDEF",197)
edt8_11_1=^^1019^1376^30^MMYY^50^158^^10^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",198)
chkb8_11_1=^^846^1380^26^^49^^^10^2^AID^3^1^4^^
"TEMP","RORCDCDEF",199)
edt8_10_1=^^1019^1289^30^MMYY^50^158^^9^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",200)
chkb8_10_1=^^846^1292^27^^49^^^9^2^AID^3^1^4^^
"TEMP","RORCDCDEF",201)
edt8_9_1=^^1019^1202^30^MMYY^50^158^^8^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",202)
chkb8_9_1=^^846^1205^26^^49^^^8^2^AID^3^1^4^^
"TEMP","RORCDCDEF",203)
chkb8_9_2=^^934^1205^26^^49^^^8^2^AID^3^2^4^^
"TEMP","RORCDCDEF",204)
edt8_8_1=^^1019^1115^30^MMYY^50^158^^7^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",205)
chkb8_8_1=^^846^1117^27^^49^^^7^2^AID^3^1^4^^
"TEMP","RORCDCDEF",206)
edt8_7_1=^^1019^1029^30^MMYY^50^158^^6^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",207)
chkb8_7_1=^^846^1034^26^^49^^^6^2^AID^3^1^4^^
"TEMP","RORCDCDEF",208)
edt8_6_1=^^1019^941^30^MMYY^50^158^^5^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",209)
chkb8_6_1=^^846^946^27^^49^^^5^2^AID^3^1^4^^
"TEMP","RORCDCDEF",210)
edt8_5_1=^^1019^853^30^MMYY^50^158^^4^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",211)
chkb8_5_1=^^846^855^26^^49^^^4^2^AID^3^1^4^^
"TEMP","RORCDCDEF",212)
edt8_4_1=^^1019^765^30^MMYY^50^158^^3^2^AID^4^^4^MM/YY^
"TEMP","RORCDCDEF",213)
chkb8_4_1=^^846^767^27^^49^^^3^2^AID^3^1^4^^
"TEMP","RORCDCDEF",214)
edt8_3_1=^^1019^678^30^MMYY^50^158^^2^2^AID^4^^4^MM/YY^VIII. Candidiasis, esophagel Date
"TEMP","RORCDCDEF",215)
chkb8_3_1=^^846^684^26^^49^^^2^2^AID^3^1^4^^VIII. Candidiasis, esophagel Def
"TEMP","RORCDCDEF",216)
chkb8_3_2=^^934^684^26^^49^^^2^2^AID^3^2^4^^VIII. Candidiasis, esophagel Pres
"TEMP","RORCDCDEF",217)
edt8_2_1=^^1019^591^30^MMYY^50^158^^1^2^AID^4^^4^MM/YY^VIII. Candidiasis, Bronchi, trachea Date
"TEMP","RORCDCDEF",218)
chkb8_2_1=^^846^596^27^^49^^^1^2^AID^3^1^4^^VIII. Candidiasis, Bronchi, trachea Def
"TEMP","RORCDCDEF",219)
chkb8_1=^^471^417^27^^49^^^^2^CS^3^1^7^^VIII. Record Rewieved yes
"TEMP","RORCDCDEF",220)
chkb8_2=^^566^417^27^^49^^^^2^CS^3^0^7^^VIII. Record Rewieved No
"TEMP","RORCDCDEF",221)
edt8_1_1=^^1667^420^30^MMYY^50^155^^^2^CS^4^^7^MM/YY^VIII Asymptomatic Date
"TEMP","RORCDCDEF",222)
edt8_1_2=^^2188^419^30^MMYY^50^155^^^2^CS^5^^7^MM/YY^Symptomatic Date
"TEMP","RORCDCDEF",223)
edt8_1=^^1622^1724^30^BoxedLine^46^9^^^2^CS^6^^7^^RVCT CASE NO
"TEMP","RORCDCDEF",224)
chkb8_28_1=^^1396^1813^27^PlainLine^49^^^^2^CS^7^1^7^^VIII. Immunideficiency disqualifying from AIDS Yes
"TEMP","RORCDCDEF",225)
chkb8_28_2=^^1563^1813^27^^49^^^^2^CS^7^0^7^^VIII. Immunideficiency disqualifying from AIDS No
"TEMP","RORCDCDEF",226)
chkb8_28_3=^^1712^1813^27^^49^^^^2^CS^7^9^7^^VIII. Immunideficiency disqualifying from AIDS Unk
"TEMP","RORCDCDEF",227)
chkb9_8_1=^^1142^2255^26^^49^^^^2^TS1^10^1^11^^Clinic (HRSA)
"TEMP","RORCDCDEF",228)
chkb9_8_2=^^1142^2305^26^^49^^^^2^TS1^10^2^11^^Clinic (Other)
"TEMP","RORCDCDEF",229)
chkb9_8_4=^^1142^2355^26^^49^^^^2^TS1^10^9^11^^Clinic (None)
"TEMP","RORCDCDEF",230)
chkb9_8_3=^^1142^2405^26^^49^^^^2^TS1^10^3^11^^Clinic (Unknown)
"TEMP","RORCDCDEF",231)
chkb9_6_1=^^467^2392^27^^49^^^^2^TS1^8^1^11^^PCP prophylaxis Yes
"TEMP","RORCDCDEF",232)
chkb9_6_2=^^550^2392^27^^49^^^^2^TS1^8^0^11^^PCP prophylaxis No
"TEMP","RORCDCDEF",233)
chkb9_6_3=^^632^2392^27^^49^^^^2^TS1^8^9^11^^PCP prophylaxis Unk
"TEMP","RORCDCDEF",234)
chkb9_12_1=^^1241^2588^27^^49^^^^2^TS2^5^1^9^^IX. Live Infant delivered  Yes
"TEMP","RORCDCDEF",235)
chkb9_12_2=^^2100^2588^27^^49^^^^2^TS2^5^0^9^^IX. Live Infant delivered  No
"TEMP","RORCDCDEF",236)
chkb9_12_3=^^2250^2588^27^^49^^^^2^TS2^5^9^9^^IX. Live Infant delivered  Unk
"TEMP","RORCDCDEF",237)
edt9_12_2=^^1417^2758^30^BoxedLine^49^4^^^2^TS2^^^9^^IX. Live Infant delivered Child SOUNDEX ????
"TEMP","RORCDCDEF",238)
edt9_12_5=^^1942^2751^30^BoxedLine^50^10^^^2^TS2^9^^9^^IX. Live Infant delivered  Child State Patient # 
"TEMP","RORCDCDEF",239)
dtp9_12_1=^^164^2761^30^MMDDYY^49^106^^^2^TS2^6^^9^^IX. Live Infant delivered  Date of Birth
"TEMP","RORCDCDEF",240)
edt9_12_3=^^615^2772^22^^49^^^^2^TS2^8^^9^^IX. Live Infant delivered  City
"TEMP","RORCDCDEF",241)
edt9_12_1=^^769^2700^22^^49^^^^2^TS2^7^^9^^IX. Live Infant delivered  Hospital
"TEMP","RORCDCDEF",242)
cmbb9_12_1=^^1037^2772^22^^49^^^^2^TS2^9^^9^^IX. Live Infant delivered  State
"TEMP","RORCDCDEF",243)
chkb9_11_1=^^1934^2534^26^^49^^^^2^TS2^4^1^9^^IX. Is  patient pregnant Yes
"TEMP","RORCDCDEF",244)
chkb9_11_2=^^2101^2534^26^^49^^^^2^TS2^4^0^9^^IX. Is  patient pregnant No
"TEMP","RORCDCDEF",245)
chkb9_11_3=^^2251^2534^26^^49^^^^2^TS2^4^9^9^^IX. Is  patient pregnant Unk
"TEMP","RORCDCDEF",246)
chkb9_4_1=^^2146^2105^26^^49^^^^2^TS1^6^1^11^^Substance abuse Yes
"TEMP","RORCDCDEF",247)
chkb9_4_2=^^2229^2105^26^^49^^^^2^TS1^6^0^11^^Substance abuse No
"TEMP","RORCDCDEF",248)
chkb9_4_4=^^2392^2105^26^^49^^^^2^TS1^6^8^11^^Substance abuse Unk
"TEMP","RORCDCDEF",249)
chkb9_4_3=^^2313^2105^26^^49^^^^2^TS1^6^9^11^^Substance abuse NA
"TEMP","RORCDCDEF",250)
chkb9_3_1=^^2146^2050^27^^49^^^^2^TS1^5^1^11^^HIV med. services Yes
"TEMP","RORCDCDEF",251)
chkb9_3_2=^^2229^2050^27^^49^^^^2^TS1^5^0^11^^HIV med. services No
"TEMP","RORCDCDEF",252)
chkb9_3_3=^^2392^2050^27^^49^^^^2^TS1^5^9^11^^HIV med. services Unk
"TEMP","RORCDCDEF",253)
chkb9_2_1=^^229^2109^26^^49^^^^2^TS1^4^1^11^^Notified Health department
"TEMP","RORCDCDEF",254)
chkb9_2_3=^^625^2109^26^^49^^^^2^TS1^4^2^11^^Notified Physician/Provider
"TEMP","RORCDCDEF",255)
chkb9_2_2=^^1030^2109^26^^49^^^^2^TS1^4^3^11^^Notified Patient
"TEMP","RORCDCDEF",256)
chkb9_2_4=^^1263^2109^26^^49^^^^2^TS1^4^9^11^^Notified Unk
"TEMP","RORCDCDEF",257)
chkb9_1_1=^^996^1992^27^^49^^^^2^TS1^3^1^11^^Informed of HIV Yes
"TEMP","RORCDCDEF",258)
chkb9_1_2=^^1162^1992^27^^49^^^^2^TS1^3^0^11^^Informed of HIV No
"TEMP","RORCDCDEF",259)
chkb9_1_3=^^1312^1992^27^^49^^^^2^TS1^3^9^11^^Informed of HIV Unk
"TEMP","RORCDCDEF",260)
chkb9_5_1=^^468^2280^26^^49^^^^2^TS1^7^1^11^^ARV therapy Yes
"TEMP","RORCDCDEF",261)
chkb9_5_2=^^550^2280^26^^49^^^^2^TS1^7^0^11^^ARV therapy No
"TEMP","RORCDCDEF",262)
chkb9_5_3=^^634^2280^26^^49^^^^2^TS1^7^9^11^^ARV therapy Unk
"TEMP","RORCDCDEF",263)
chkb9_7_1=^^784^2255^26^^49^^^^2^TS1^9^1^11^^Clinical Trial NIH
"TEMP","RORCDCDEF",264)
chkb9_7_2=^^784^2305^26^^49^^^^2^TS1^9^2^11^^Clinical Trial Other
"TEMP","RORCDCDEF",265)
chkb9_7_4=^^784^2355^26^^49^^^^2^TS1^9^3^11^^Clinical Trial None
"TEMP","RORCDCDEF",266)
chkb9_7_3=^^784^2405^26^^49^^^^2^TS1^9^9^11^^Clinical Trial Unk
"TEMP","RORCDCDEF",267)
chkb9_9_1=^^1621^2255^26^^49^^^^2^TS1^11^1^11^^Reimburse Medicaid
"TEMP","RORCDCDEF",268)
chkb9_9_3=^^1621^2309^26^^49^^^^2^TS1^11^2^11^^Reimbursed No coverage
"TEMP","RORCDCDEF",269)
chkb9_9_2=^^2000^2255^26^^49^^^^2^TS1^11^3^11^^Reimbursed HMO
"TEMP","RORCDCDEF",270)
chkb9_9_4=^^2001^2309^26^^49^^^^2^TS1^11^4^11^^Reimbursed Other
"TEMP","RORCDCDEF",271)
chkb9_9_5=^^1621^2363^27^^49^^^^2^TS1^11^7^11^^Reimbursed Trial
"TEMP","RORCDCDEF",272)
chkb9_9_6=^^2000^2363^27^^49^^^^2^TS1^11^9^11^^Reimbursed Unk
"TEMP","RORCDCDEF",273)
chkb9_10_1=^^1934^2480^26^^49^^^^2^TS2^3^1^9^^Gynecol. services Yes
"TEMP","RORCDCDEF",274)
chkb9_10_2=^^2101^2480^26^^49^^^^2^TS2^3^0^9^^Gynecol. services No
"TEMP","RORCDCDEF",275)
chkb9_10_3=^^2251^2480^26^^49^^^^2^TS2^3^9^9^^Gynecol. services Unk
"TEMP","RORCDCDEF",276)
mmComments=^^420^2864^30^MEMO^65^^^^2^CMT^3^^3^^
"TEMP","RORHL7SEG",1)
PID^^5
"TEMP","RORHL7SEG",2)
ZSP^^5
"TEMP","RORHL7SEG",3)
ZRD^^5
"TEMP","RORHL7SEG",4)
OBR^^1
"TEMP","RORHL7SEG",5)
OBX^^1
"TEMP","RORHL7SEG",6)
NTE^^1
"TEMP","RORHL7SEG",7)
CSR^^5
"TEMP","RORHL7SEG",8)
CSP^^5
"TEMP","RORHL7SEG",9)
CSS^^5
"TEMP","RORHL7SEG",10)
ORC^^6
"TEMP","RORHL7SEG",11)
RXE^^6
"TEMP","RORHL7SEG",12)
OBR^^4
"TEMP","RORHL7SEG",13)
OBR^^7
"TEMP","RORHL7SEG",14)
OBR^^8
"VER")
8.0^22
"^DD",798,798,0)
FIELD^^12^23
"^DD",798,798,0,"DDA")
N
"^DD",798,798,0,"DT")
3031125
"^DD",798,798,0,"IX","AC",798,.02)

"^DD",798,798,0,"IX","AM",798,10)

"^DD",798,798,0,"IX","B",798,.01)

"^DD",798,798,0,"NM","ROR LOCAL REGISTRY")

"^DD",798,798,0,"PT",798.53,.01)

"^DD",798,798,0,"PT",799.4,.01)

"^DD",798,798,0,"SCR")
I $$ACCESS^RORDD(798,+$P($G(^(0)),U,2))
"^DD",798,798,0,"VRPK")
ROR
"^DD",798,798,.01,0)
PATIENT NAME^RP798.4^RORDATA(798.4,^0;1^Q
"^DD",798,798,.01,1,0)
^.1
"^DD",798,798,.01,1,1,0)
798^B
"^DD",798,798,.01,1,1,1)
S ^RORDATA(798,"B",$E(X,1,30),DA)=""
"^DD",798,798,.01,1,1,2)
K ^RORDATA(798,"B",$E(X,1,30),DA)
"^DD",798,798,.01,1,1,3)
Do not delete!
"^DD",798,798,.01,1,1,"%D",0)
^.101^2^2^3030428^^
"^DD",798,798,.01,1,1,"%D",1,0)
Patient records in all defined registries can be
"^DD",798,798,.01,1,1,"%D",2,0)
found using this cross-reference.
"^DD",798,798,.01,3)

"^DD",798,798,.01,8.5)
@
"^DD",798,798,.01,9)
@
"^DD",798,798,.01,20,0)
^.3LA^1^1
"^DD",798,798,.01,20,1,0)
ENTRY
"^DD",798,798,.01,21,0)
^.001^7^7^3020816^^
"^DD",798,798,.01,21,1,0)
The PATIENT NAME field identifies a patient in the
"^DD",798,798,.01,21,2,0)
registry. You can select a patient either from the
"^DD",798,798,.01,21,3,0)
local registry or the ROR PATIENT file, or you can
"^DD",798,798,.01,21,4,0)
add a new patient from the PATIENT file.
"^DD",798,798,.01,21,5,0)
 
"^DD",798,798,.01,21,6,0)
You can select records only of those registries
"^DD",798,798,.01,21,7,0)
that you have appropriate security key(s) for.
"^DD",798,798,.01,23,0)
^^12^12^3030428^
"^DD",798,798,.01,23,1,0)
An internal value of this field is the patient IEN in
"^DD",798,798,.01,23,2,0)
the PATIENT file (#2) because records in the ROR
"^DD",798,798,.01,23,3,0)
PATIENT file (#798.4) have the same internal entry
"^DD",798,798,.01,23,4,0)
numbers as corresponding records in the PATIENT file.
"^DD",798,798,.01,23,5,0)
Patient records in all registries can be found by
"^DD",798,798,.01,23,6,0)
traditional "B" cross-reference.
"^DD",798,798,.01,23,7,0)
 
"^DD",798,798,.01,23,8,0)
When value of this field is deleted (which means 
"^DD",798,798,.01,23,9,0)
deletion of the whole record), the logic of the ADELETE
"^DD",798,798,.01,23,10,0)
cross-reference tries to delete associated records from
"^DD",798,798,.01,23,11,0)
the ROR ICR STUDY (#799.4), ROR PATIENT (#798.4), and
"^DD",798,798,.01,23,12,0)
ROR PENDING PATIENT (#798.3) files.
"^DD",798,798,.01,"DT")
3030402
"^DD",798,798,.02,0)
REGISTRY^RP798.1'I^ROR(798.1,^0;2^Q
"^DD",798,798,.02,1,0)
^.1
"^DD",798,798,.02,1,1,0)
798^AC
"^DD",798,798,.02,1,1,1)
S ^RORDATA(798,"AC",$E(X,1,30),DA)=""
"^DD",798,798,.02,1,1,2)
K ^RORDATA(798,"AC",$E(X,1,30),DA)
"^DD",798,798,.02,1,1,3)
Do not delete!
"^DD",798,798,.02,1,1,"%D",0)
^^2^2^3011005^
"^DD",798,798,.02,1,1,"%D",1,0)
This cross-reference is used to link all records
"^DD",798,798,.02,1,1,"%D",2,0)
of the registry together.
"^DD",798,798,.02,1,1,"DT")
3000406
"^DD",798,798,.02,1,2,0)
^^TRIGGER^798^1
"^DD",798,798,.02,1,2,1)
X ^DD(798,.02,1,2,1.3) I X S X=DIV S Y(1)=$S($D(^RORDATA(798,D0,0)):^(0),1:"") S X=$P(Y(1),U,3),X=X S DIU=X K Y S X=DIV S %=$P($H,",",2),X=DT_(%\60#60/100+(%\3600)+(%#60/10000)/100) X ^DD(798,.02,1,2,1.4)
"^DD",798,798,.02,1,2,1.3)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(0)=X S Y(1)=$S($D(^RORDATA(798,D0,0)):^(0),1:"") S X='$P(Y(1),U,3)
"^DD",798,798,.02,1,2,1.4)
S DIH=$G(^RORDATA(798,DIV(0),0)),DIV=X S $P(^(0),U,3)=DIV,DIH=798,DIG=1 D ^DICR
"^DD",798,798,.02,1,2,2)
Q
"^DD",798,798,.02,1,2,3)
Do not delete!
"^DD",798,798,.02,1,2,"%D",0)
^^2^2^3020402^
"^DD",798,798,.02,1,2,"%D",1,0)
This trigger populates the DATE ENTERED field 
"^DD",798,798,.02,1,2,"%D",2,0)
when the patient is added to the registry.
"^DD",798,798,.02,1,2,"CREATE CONDITION")
'DATE ENTERED
"^DD",798,798,.02,1,2,"CREATE VALUE")
NOW
"^DD",798,798,.02,1,2,"DELETE VALUE")
NO EFFECT
"^DD",798,798,.02,1,2,"DT")
3011119
"^DD",798,798,.02,1,2,"FIELD")
DATE
"^DD",798,798,.02,8.5)
@
"^DD",798,798,.02,9)
@
"^DD",798,798,.02,20,0)
^.3LA^1^1
"^DD",798,798,.02,20,1,0)
ENTRY
"^DD",798,798,.02,21,0)
^.001^2^2^3020816^^
"^DD",798,798,.02,21,1,0)
The REGISTRY field identifies the registry that 
"^DD",798,798,.02,21,2,0)
the record belongs to.
"^DD",798,798,.02,23,0)
^.001^2^2^3020816^^
"^DD",798,798,.02,23,1,0)
Traditional cross-reference "AC" is used to link all 
"^DD",798,798,.02,23,2,0)
records of the registry together.
"^DD",798,798,.02,"DT")
3031027
"^DD",798,798,1,0)
DATE ENTERED^DI^^0;3^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798,1,1,0)
^.1^^0
"^DD",798,798,1,5,1,0)
798^.02^2
"^DD",798,798,1,8.5)
@
"^DD",798,798,1,9)
@
"^DD",798,798,1,20,0)
^.3LA^1^1
"^DD",798,798,1,20,1,0)
ENTRY
"^DD",798,798,1,21,0)
^.001^3^3^3020816^^
"^DD",798,798,1,21,1,0)
The DATE ENTERED field is automatically populated
"^DD",798,798,1,21,2,0)
by the trigger associated with the REGISTRY field
"^DD",798,798,1,21,3,0)
when the patient is added to the registry.
"^DD",798,798,1,"DT")
3031027
"^DD",798,798,2,0)
INACTIVATION DATE^DX^^0;4^S %DT="ESTX" K Y S:$G(DIUTIL)'="VERIFY FIELDS" Y(9.2)=$P($G(^RORDATA(798,DA,2)),U,2),Y(7)=$P($G(^(0)),U,11),Y=$S(Y(9.2)>Y(7):Y(9.2),1:Y(7)) S:$G(Y)>0 %DT(0)=Y D ^%DT S X=Y K:Y<1 X K %DT,Y
"^DD",798,798,2,1,0)
^.1^^0
"^DD",798,798,2,3)
Enter the inactivation date for the patient.
"^DD",798,798,2,4)

"^DD",798,798,2,20,0)
^.3LA^1^1
"^DD",798,798,2,20,1,0)
STATE
"^DD",798,798,2,21,0)
^.001^8^8^3020816^^
"^DD",798,798,2,21,1,0)
When present the INACTIVATION DATE field contains
"^DD",798,798,2,21,2,0)
the latest inactivation date/time of the patient
"^DD",798,798,2,21,3,0)
in the registry.
"^DD",798,798,2,21,4,0)
 
"^DD",798,798,2,21,5,0)
The new inactivation date could be in the future
"^DD",798,798,2,21,6,0)
or in the past but it should be not earlier than
"^DD",798,798,2,21,7,0)
the date of the last data extraction or the date
"^DD",798,798,2,21,8,0)
of re-activation (if present).
"^DD",798,798,2,23,0)
^.001^5^5^3020816^^
"^DD",798,798,2,23,1,0)
Patient's record is active if there is no inactivation 
"^DD",798,798,2,23,2,0)
date. Otherwise, values of both the INACTIVATION DATE
"^DD",798,798,2,23,3,0)
and REACTIVATION DATE fields should be analyzed along
"^DD",798,798,2,23,4,0)
with the current date/time. See description of the 
"^DD",798,798,2,23,5,0)
ACTIVE computed field (#798, 8) for further details.
"^DD",798,798,2,"DT")
3011120
"^DD",798,798,2.1,0)
INACTIVATED BY^P200'^VA(200,^0;10^Q
"^DD",798,798,2.1,21,0)
^^3^3^3020402^
"^DD",798,798,2.1,21,1,0)
The INACTIVATED BY field identifies a person who
"^DD",798,798,2.1,21,2,0)
has inactivated a patient record in the registry
"^DD",798,798,2.1,21,3,0)
for the last time.
"^DD",798,798,2.1,23,0)
^^4^4^3020402^
"^DD",798,798,2.1,23,1,0)
This field is automatically populated by the
"^DD",798,798,2.1,23,2,0)
inactivation remote procedure. If the patient record
"^DD",798,798,2.1,23,3,0)
has been automatically inactivated because of patient
"^DD",798,798,2.1,23,4,0)
death, this field will have no value.
"^DD",798,798,2.1,"DT")
3000504
"^DD",798,798,2.2,0)
REASON FOR INACTIVATION^*P799.1'X^ROR(799.1,^0;13^S Y=$P($G(^RORDATA(798,DA,0)),U,2),DIC("S")="S D=$G(^(0)) I $P(D,U,2)=1"_$S(Y>0:",$P(D,U,3)="_Y,1:"") D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",798,798,2.2,3)

"^DD",798,798,2.2,12)
Only reasons for inactivation can be selected.
"^DD",798,798,2.2,12.1)
S DIC("S")="I $P(^(0),U,2)=1"
"^DD",798,798,2.2,21,0)
^.001^3^3^3011120^^^^
"^DD",798,798,2.2,21,1,0)
Value of this field indicates a reason for the 
"^DD",798,798,2.2,21,2,0)
latest manual inactivation of the patient record
"^DD",798,798,2.2,21,3,0)
in the registry.
"^DD",798,798,2.2,23,0)
^.001^5^5^3011120^^^^
"^DD",798,798,2.2,23,1,0)
This field is only ever populated via the GUI manual
"^DD",798,798,2.2,23,2,0)
entry option.
"^DD",798,798,2.2,23,3,0)
 
"^DD",798,798,2.2,23,4,0)
If a patient was inactivated because of death, this 
"^DD",798,798,2.2,23,5,0)
field MUST be empty!
"^DD",798,798,2.2,"DT")
3030319
"^DD",798,798,3,0)
NEW PATIENT^S^0:NO;1:AUTO;2:MANUAL;3:REACTIVATED;4:PENDING;^0;5^Q
"^DD",798,798,3,1,0)
^.1^^0
"^DD",798,798,3,20,0)
^.3LA^1^1
"^DD",798,798,3,20,1,0)
STATE
"^DD",798,798,3,21,0)
^.001^2^2^3030218^^^
"^DD",798,798,3,21,1,0)
The NEW PATIENT field describes how the patient 
"^DD",798,798,3,21,2,0)
has been added/updated in the registry.
"^DD",798,798,3,23,0)
^.001^7^7^3030218^^^
"^DD",798,798,3,23,1,0)
Usually, this field contains 0 or no value at all. The
"^DD",798,798,3,23,2,0)
field is automatically populated by the registry
"^DD",798,798,3,23,3,0)
update, patient reactivation and GUI manual entry
"^DD",798,798,3,23,4,0)
processing.
"^DD",798,798,3,23,5,0)
 
"^DD",798,798,3,23,6,0)
After acknowledgement of the successful processing of
"^DD",798,798,3,23,7,0)
transmitted data the value of this field is deleted.
"^DD",798,798,3,"DT")
3030402
"^DD",798,798,3.1,0)
SELECTION RULE^798.01P^^1;0
"^DD",798,798,3.1,20,0)
^.3LA^1^1
"^DD",798,798,3.1,20,1,0)
ENTRY
"^DD",798,798,3.1,21,0)
^.001^3^3^3020816^^
"^DD",798,798,3.1,21,1,0)
The SELECTION RULE multiple contains a list of
"^DD",798,798,3.1,21,2,0)
selection rules that the patient passed when added
"^DD",798,798,3.1,21,3,0)
to the registry.
"^DD",798,798,3.1,23,0)
^.001^2^2^3020816^^
"^DD",798,798,3.1,23,1,0)
The list is automatically populated by the registry
"^DD",798,798,3.1,23,2,0)
update and the GUI manual patient entry processing.
"^DD",798,798,3.2,0)
SUPPORTING EVIDENCE^*P799.1'X^ROR(799.1,^0;14^S Y=$P($G(^RORDATA(798,DA,0)),U,2),DIC("S")="S D=$G(^(0)) I $P(D,U,2)=2"_$S(Y>0:",$P(D,U,3)="_Y,1:"") D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",798,798,3.2,3)

"^DD",798,798,3.2,12)
Only supporting evidences can be selected.
"^DD",798,798,3.2,12.1)
S DIC("S")="I $P(^(0),U,2)=2"
"^DD",798,798,3.2,20,0)
^.3LA^1^1
"^DD",798,798,3.2,20,1,0)
ENTRY
"^DD",798,798,3.2,21,0)
^.001^2^2^3020816^^^^
"^DD",798,798,3.2,21,1,0)
This field indicates a reason for manual addition
"^DD",798,798,3.2,21,2,0)
of the patient to the registry.
"^DD",798,798,3.2,23,0)
^^2^2^3030428^
"^DD",798,798,3.2,23,1,0)
The SUPPORTING EVIDENCE field is only ever populated
"^DD",798,798,3.2,23,2,0)
via the GUI manual entry option.
"^DD",798,798,3.2,"DT")
3011009
"^DD",798,798,4,0)
UPDATE DEMOGRAPHICS^S^0:NO;1:YES;^0;6^Q
"^DD",798,798,4,1,0)
^.1^^0
"^DD",798,798,4,20,0)
^.3LA^1^1
"^DD",798,798,4,20,1,0)
STATE
"^DD",798,798,4,21,0)
^.001^3^3^3020816^^
"^DD",798,798,4,21,1,0)
Usually, you should not edit this field. Set a 
"^DD",798,798,4,21,2,0)
value of this field to "Yes" if you want the
"^DD",798,798,4,21,3,0)
patient demographic data to be sent to AAC.
"^DD",798,798,4,23,0)
^.001^12^12^3020816^^
"^DD",798,798,4,23,1,0)
During the registry update, demographic fields of each
"^DD",798,798,4,23,2,0)
record of the ROR PATIENT file are compared with
"^DD",798,798,4,23,3,0)
corresponding fields of the PATIENT file.
"^DD",798,798,4,23,4,0)
 
"^DD",798,798,4,23,5,0)
If some of the fields have different values, an 
"^DD",798,798,4,23,6,0)
internal value of 1 is assigned to the UPDATE
"^DD",798,798,4,23,7,0)
DEMOGRAPHICS field of all active patient records in 
"^DD",798,798,4,23,8,0)
local registries. As a result, demographic data is
"^DD",798,798,4,23,9,0)
transmitted to the national registries.
"^DD",798,798,4,23,10,0)
 
"^DD",798,798,4,23,11,0)
After acknowledgement of the successful processing of
"^DD",798,798,4,23,12,0)
transmitted data the value of this field is deleted.
"^DD",798,798,4,"DT")
3040126
"^DD",798,798,4.1,0)
DEMOGRAPHICS UPDATED^D^^0;15^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798,4.1,8.5)
@
"^DD",798,798,4.1,9)
@
"^DD",798,798,4.1,20,0)
^.3LA^1^1
"^DD",798,798,4.1,20,1,0)
STATE
"^DD",798,798,4.1,21,0)
^^4^4^3030428^
"^DD",798,798,4.1,21,1,0)
The DEMOGRAPHICS UPDATED field stores the 
"^DD",798,798,4.1,21,2,0)
date/time of the last change in the patient's
"^DD",798,798,4.1,21,3,0)
demographic data that was detected by the Clinical
"^DD",798,798,4.1,21,4,0)
Case Registries software.
"^DD",798,798,4.1,23,0)
^.001^2^2^3030428^^
"^DD",798,798,4.1,23,1,0)
This field is populated by the trigger associated with
"^DD",798,798,4.1,23,2,0)
the UPDATE DEMOGRAPHICS field.
"^DD",798,798,4.1,"DT")
3030417
"^DD",798,798,5,0)
UPDATE LOCAL REGISTRY DATA^S^0:NO;1:YES;^0;7^Q
"^DD",798,798,5,20,0)
^.3LA^1^1
"^DD",798,798,5,20,1,0)
STATE
"^DD",798,798,5,21,0)
^.001^4^4^3020816^^^
"^DD",798,798,5,21,1,0)
Usually, you should not edit this field. Set a 
"^DD",798,798,5,21,2,0)
value of this field to "Yes" if you have changed
"^DD",798,798,5,21,3,0)
any local registry data of the patient and want 
"^DD",798,798,5,21,4,0)
this data to be sent to AAC.
"^DD",798,798,5,23,0)
^.001^8^8^3020816^^^
"^DD",798,798,5,23,1,0)
Any changes of local registry data result in assignment
"^DD",798,798,5,23,2,0)
of 1 as an internal value of the UPDATE LOCAL REGISTRY
"^DD",798,798,5,23,3,0)
DATA field (by registry update process or remote
"^DD",798,798,5,23,4,0)
procedures). This is an indication to transmit local
"^DD",798,798,5,23,5,0)
data to the national registry.
"^DD",798,798,5,23,6,0)
 
"^DD",798,798,5,23,7,0)
After acknowledgement of the successful processing of
"^DD",798,798,5,23,8,0)
transmitted data the value of this field is deleted.
"^DD",798,798,5,"DT")
3030418
"^DD",798,798,5.1,0)
LOCAL DATA UPDATED^D^^0;16^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798,5.1,8.5)
@
"^DD",798,798,5.1,9)
@
"^DD",798,798,5.1,20,0)
^.3LA^1^1
"^DD",798,798,5.1,20,1,0)
STATE
"^DD",798,798,5.1,21,0)
^^3^3^3030428^
"^DD",798,798,5.1,21,1,0)
The LOCAL DATA UPDATED field stores the date/time
"^DD",798,798,5.1,21,2,0)
of the last change in the patient's local registry
"^DD",798,798,5.1,21,3,0)
data.
"^DD",798,798,5.1,23,0)
^^2^2^3030428^
"^DD",798,798,5.1,23,1,0)
This field is populated by the trigger associated with
"^DD",798,798,5.1,23,2,0)
the UPDATE LOCAL REGISTRY DATA field.
"^DD",798,798,5.1,"DT")
3030417
"^DD",798,798,6,0)
INVESTIGATIONAL DRUGS^S^0:NO;1:YES;^0;8^Q
"^DD",798,798,6,20,0)
^.3LA^1^1
"^DD",798,798,6,20,1,0)
ENTRY
"^DD",798,798,6,21,0)
^.001^3^3^3030417^^
"^DD",798,798,6,21,1,0)
Set this field to "Yes" if any investigational 
"^DD",798,798,6,21,2,0)
drugs related to the registry are/were used in
"^DD",798,798,6,21,3,0)
the treatment of the patient.
"^DD",798,798,6,23,0)
^.001^6^6^3030417^^
"^DD",798,798,6,23,1,0)
The internal value of 1 in the INVESTIGATIONAL DRUGS
"^DD",798,798,6,23,2,0)
field indicates that these drugs are used in the
"^DD",798,798,6,23,3,0)
treatment of the patient.
"^DD",798,798,6,23,4,0)
 
"^DD",798,798,6,23,5,0)
Value of this field is controlled by a user (via
"^DD",798,798,6,23,6,0)
the corresponding check-box in the GUI).
"^DD",798,798,6,"DT")
3000327
"^DD",798,798,6.1,0)
MEDICATION IN PROFILE^S^0:NO;1:YES;^0;9^Q
"^DD",798,798,6.1,20,0)
^.3LA^1^1
"^DD",798,798,6.1,20,1,0)
ENTRY
"^DD",798,798,6.1,21,0)
^.001^3^3^3030417^^
"^DD",798,798,6.1,21,1,0)
Enter "Yes" if the drugs that the patient is
"^DD",798,798,6.1,21,2,0)
currently taking are in the medication profile
"^DD",798,798,6.1,21,3,0)
that exists within VistA or CPRS.
"^DD",798,798,6.1,23,0)
^.001^2^2^3030417^^^^
"^DD",798,798,6.1,23,1,0)
Value of this field is controlled by a user (via
"^DD",798,798,6.1,23,2,0)
the corresponding check-box in the GUI).
"^DD",798,798,6.1,"DT")
3000327
"^DD",798,798,7,0)
REACTIVATION DATE^DX^^0;11^S %DT="ESTX" K Y S:$G(DIUTIL)'="VERIFY FIELDS" Y(9.2)=$P($G(^RORDATA(798,DA,2)),U,2),Y(2)=$P($G(^(0)),U,4),Y=$S(Y(9.2)>Y(2):Y(9.2),1:Y(2)) S:$G(Y)>0 %DT(0)=Y D ^%DT S X=Y K:(Y<1)!(Y>$$NOW^XLFDT) X K %DT,Y
"^DD",798,798,7,3)
Enter the reactivation date for the patient.
"^DD",798,798,7,4)

"^DD",798,798,7,20,0)
^.3LA^1^1
"^DD",798,798,7,20,1,0)
STATE
"^DD",798,798,7,21,0)
^.001^7^7^3020816^^
"^DD",798,798,7,21,1,0)
The REACTIVATION DATE field contains a date/time
"^DD",798,798,7,21,2,0)
of the latest reactivation of the patient in the
"^DD",798,798,7,21,3,0)
registry.
"^DD",798,798,7,21,4,0)
 
"^DD",798,798,7,21,5,0)
The new reactivation date cannot be earlier than 
"^DD",798,798,7,21,6,0)
the date of the latest data extract or the date of
"^DD",798,798,7,21,7,0)
inactivation. You cannot enter a future date.
"^DD",798,798,7,23,0)
^.001^5^5^3020816^^
"^DD",798,798,7,23,1,0)
You must evaluate both REACTIVATION DATE and 
"^DD",798,798,7,23,2,0)
INACTIVATION DATE fields along with the current 
"^DD",798,798,7,23,3,0)
date/time to determine whether the patient record is
"^DD",798,798,7,23,4,0)
active or not. See the description of the ACTIVE
"^DD",798,798,7,23,5,0)
computed field (#798, 8) for further details.
"^DD",798,798,7,"DT")
3011011
"^DD",798,798,7.1,0)
REACTIVATED BY^P200'^VA(200,^0;12^Q
"^DD",798,798,7.1,21,0)
^^2^2^3020402^
"^DD",798,798,7.1,21,1,0)
The REACTIVATED BY field identifies a person who
"^DD",798,798,7.1,21,2,0)
last re-activated the patient.
"^DD",798,798,7.1,23,0)
^.001^2^2^3020402^^
"^DD",798,798,7.1,23,1,0)
This field is automatically populated by the 
"^DD",798,798,7.1,23,2,0)
re-activation processing within the GUI.
"^DD",798,798,7.1,"DT")
3000504
"^DD",798,798,8,0)
ACTIVE^CJ1,0^^ ; ^S X=$$ACTIVE^RORDD(D0)
"^DD",798,798,8,9)
^
"^DD",798,798,8,9.01)

"^DD",798,798,8,9.1)
S X=$$ACTIVE^RORDD(D0)
"^DD",798,798,8,20,0)
^.3LA^1^1
"^DD",798,798,8,20,1,0)
STATE
"^DD",798,798,8,21,0)
^.001^3^3^3030725^^^^
"^DD",798,798,8,21,1,0)
This is a computed field that indicates the 
"^DD",798,798,8,21,2,0)
current status of the patient in the local
"^DD",798,798,8,21,3,0)
registry.
"^DD",798,798,8,23,0)
^.001^8^8^3030725^^^^
"^DD",798,798,8,23,1,0)
Patient is active if there is no inactivation date. 
"^DD",798,798,8,23,2,0)
Otherwise, the patient is active only if:
"^DD",798,798,8,23,3,0)
 
"^DD",798,798,8,23,4,0)
 (INACTIVATION DATE > NOW) or 
"^DD",798,798,8,23,5,0)
 (INACTIVATION DATE < REACTIVATION DATE)
"^DD",798,798,8,23,6,0)
 
"^DD",798,798,8,23,7,0)
Please, remember that REACTIVATION DATE cannot be in 
"^DD",798,798,8,23,8,0)
the future.
"^DD",798,798,8,"DT")
3030725
"^DD",798,798,9.1,0)
DATA ACKNOWLEDGED UNTIL^D^^2;1^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798,9.1,20,0)
^.3LA^1^1
"^DD",798,798,9.1,20,1,0)
STATE
"^DD",798,798,9.1,21,0)
^.001^3^3^3020816^^
"^DD",798,798,9.1,21,1,0)
The DATA ACKNOWLEDGED UNTIL field contains a date
"^DD",798,798,9.1,21,2,0)
that the patient data has been extracted until,
"^DD",798,798,9.1,21,3,0)
successfully transmitted and acknowledged.
"^DD",798,798,9.1,23,0)
^.001^7^7^3020816^^
"^DD",798,798,9.1,23,1,0)
A regular data extraction for the patient in the 
"^DD",798,798,9.1,23,2,0)
registry starts from this date.
"^DD",798,798,9.1,23,3,0)
 
"^DD",798,798,9.1,23,4,0)
Acknowledgement processing copies the value of the
"^DD",798,798,9.1,23,5,0)
DATA EXTRACTED UNTIL field into this field upon
"^DD",798,798,9.1,23,6,0)
receiving and processing the HL7 acknowledgement from 
"^DD",798,798,9.1,23,7,0)
the AAC.
"^DD",798,798,9.1,"DT")
3010830
"^DD",798,798,9.2,0)
DATA EXTRACTED UNTIL^D^^2;2^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798,9.2,20,0)
^.3LA^1^1
"^DD",798,798,9.2,20,1,0)
STATE
"^DD",798,798,9.2,21,0)
^.001^3^3^3020816^^^
"^DD",798,798,9.2,21,1,0)
This field contains a date that registry data of 
"^DD",798,798,9.2,21,2,0)
the patient has been extracted until, transmitted
"^DD",798,798,9.2,21,3,0)
but not acknowledged yet.
"^DD",798,798,9.2,23,0)
^.001^8^8^3020816^^
"^DD",798,798,9.2,23,1,0)
The field is automatically populated by the regular
"^DD",798,798,9.2,23,2,0)
data extraction process if the data is extracted
"^DD",798,798,9.2,23,3,0)
successfully.
"^DD",798,798,9.2,23,4,0)
 
"^DD",798,798,9.2,23,5,0)
Acknowledgement processing routine copies value of this
"^DD",798,798,9.2,23,6,0)
field into the DATA ACKNOWLEDGED UNTIL field upon
"^DD",798,798,9.2,23,7,0)
receiving and processing HL7 acknowledgement from the
"^DD",798,798,9.2,23,8,0)
AAC.
"^DD",798,798,9.2,"DT")
3010830
"^DD",798,798,10,0)
MESSAGE ID^FX^^2;3^K:X[""""!($A(X)=45) X I $D(X) K:$L(X)>20!(X'?1.E1"-"1.N) X
"^DD",798,798,10,1,0)
^.1
"^DD",798,798,10,1,1,0)
798^AM
"^DD",798,798,10,1,1,1)
S ^RORDATA(798,"AM",$E(X,1,30),DA)=""
"^DD",798,798,10,1,1,2)
K ^RORDATA(798,"AM",$E(X,1,30),DA)
"^DD",798,798,10,1,1,3)
Do not delete!
"^DD",798,798,10,1,1,"%D",0)
^^3^3^3011005^
"^DD",798,798,10,1,1,"%D",1,0)
The cross-reference allows to find a patient 
"^DD",798,798,10,1,1,"%D",2,0)
record in the registry using an ID of an HL7
"^DD",798,798,10,1,1,"%D",3,0)
message sent to the national registry.
"^DD",798,798,10,1,1,"DT")
3010824
"^DD",798,798,10,3)
The unique ID of the latest HL7 message (1-20 characters).
"^DD",798,798,10,20,0)
^.3LA^1^1
"^DD",798,798,10,20,1,0)
HL7
"^DD",798,798,10,21,0)
^.001^8^8^3030417^^
"^DD",798,798,10,21,1,0)
The MESSAGE ID field contains an identifier of 
"^DD",798,798,10,21,2,0)
the latest individual HL7 message created for this
"^DD",798,798,10,21,3,0)
registry record.
"^DD",798,798,10,21,4,0)
 
"^DD",798,798,10,21,5,0)
Value of this field should have the following
"^DD",798,798,10,21,6,0)
format: BatchID-N, where BatchID is an ID of an
"^DD",798,798,10,21,7,0)
HL7 batch message, and N is a sequential number of
"^DD",798,798,10,21,8,0)
the message in the batch.
"^DD",798,798,10,23,0)
^.001^3^3^3030417^^^^
"^DD",798,798,10,23,1,0)
This field is automatically populated by the regular
"^DD",798,798,10,23,2,0)
data extraction process every time an HL7 message is
"^DD",798,798,10,23,3,0)
generated.
"^DD",798,798,10,"DT")
3011005
"^DD",798,798,11,0)
DON'T SEND^S^0:NO;1:YES;^2;4^Q
"^DD",798,798,11,20,0)
^.3LA^1^1
"^DD",798,798,11,20,1,0)
ENTRY
"^DD",798,798,11,21,0)
^.001^3^3^3030417^^
"^DD",798,798,11,21,1,0)
Set this field to "Yes" if you do not want any 
"^DD",798,798,11,21,2,0)
data to be sent to the national registry for this
"^DD",798,798,11,21,3,0)
record.
"^DD",798,798,11,23,0)
^.001^4^4^3030417^^
"^DD",798,798,11,23,1,0)
Usually, this field is populated only automatically by
"^DD",798,798,11,23,2,0)
the registry update processing if a patient is defined
"^DD",798,798,11,23,3,0)
in the PATIENT file as a "test patient" (internal value
"^DD",798,798,11,23,4,0)
of the TEST PATIENT INDICATOR field equals to 1).
"^DD",798,798,11,"DT")
3010919
"^DD",798,798,12,0)
CAN BE DELETED^S^0:NO;1:YES;^2;5^Q
"^DD",798,798,12,8.5)
@
"^DD",798,798,12,9)
@
"^DD",798,798,12,21,0)
^^3^3^3031126^
"^DD",798,798,12,21,1,0)
The CAN BE DELETED field indicates if the registry
"^DD",798,798,12,21,2,0)
record can be completely deleted instead of
"^DD",798,798,12,21,3,0)
inactivation. 
"^DD",798,798,12,23,0)
^^5^5^3031126^
"^DD",798,798,12,23,1,0)
When a patient is added to the registry this field is
"^DD",798,798,12,23,2,0)
automatically set to 'YES' by the $$ADD^RORUPD50
"^DD",798,798,12,23,3,0)
function. The $$PROCREC^ROREXT01 function clears the
"^DD",798,798,12,23,4,0)
field when a first HL7 message is generated for this
"^DD",798,798,12,23,5,0)
patient.
"^DD",798,798,12,"DT")
3031126
"^DD",798,798.01,0)
SELECTION RULE SUB-FIELD^^1^2
"^DD",798,798.01,0,"DT")
3011009
"^DD",798,798.01,0,"IX","AD",798.01,1)

"^DD",798,798.01,0,"IX","B",798.01,.01)

"^DD",798,798.01,0,"NM","SELECTION RULE")

"^DD",798,798.01,0,"UP")
798
"^DD",798,798.01,.01,0)
SELECTION RULE^MP798.2'^ROR(798.2,^0;1^Q
"^DD",798,798.01,.01,1,0)
^.1
"^DD",798,798.01,.01,1,1,0)
798.01^B
"^DD",798,798.01,.01,1,1,1)
S ^RORDATA(798,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",798,798.01,.01,1,1,2)
K ^RORDATA(798,DA(1),1,"B",$E(X,1,30),DA)
"^DD",798,798.01,.01,1,1,3)
Do not delete!
"^DD",798,798.01,.01,21,0)
^.001^2^2^3011009^^
"^DD",798,798.01,.01,21,1,0)
This field identifies the selection rule that has 
"^DD",798,798.01,.01,21,2,0)
caused addition of the patient to the registry.
"^DD",798,798.01,.01,"DT")
3011009
"^DD",798,798.01,1,0)
DATE^D^^0;2^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798.01,1,1,0)
^.1
"^DD",798,798.01,1,1,1,0)
798.01^AD
"^DD",798,798.01,1,1,1,1)
S ^RORDATA(798,DA(1),1,"AD",$E(X,1,30),DA)=""
"^DD",798,798.01,1,1,1,2)
K ^RORDATA(798,DA(1),1,"AD",$E(X,1,30),DA)
"^DD",798,798.01,1,1,1,3)
Do not delete!
"^DD",798,798.01,1,1,1,"DT")
3000426
"^DD",798,798.01,1,21,0)
^^2^2^3020402^
"^DD",798,798.01,1,21,1,0)
The DATE field contains the date when the patient
"^DD",798,798.01,1,21,2,0)
passed the rule for the first time.
"^DD",798,798.01,1,"DT")
3000426
"^DD",798.1,798.1,0)
FIELD^^29^43
"^DD",798.1,798.1,0,"DDA")
N
"^DD",798.1,798.1,0,"DT")
3030625
"^DD",798.1,798.1,0,"ID","WRITE")
D EN^DDIOL("  "_$P($G(^(0)),U,4),,"?30")
"^DD",798.1,798.1,0,"IX","ACL",798.118,.01)

"^DD",798.1,798.1,0,"IX","AEP",798.1,25)

"^DD",798.1,798.1,0,"IX","AM",798.1,2.3)

"^DD",798.1,798.1,0,"IX","ARULES",798.13,.01)

"^DD",798.1,798.1,0,"NM","ROR REGISTRY PARAMETERS")

"^DD",798.1,798.1,0,"PT",798,.02)

"^DD",798.1,798.1,0,"PT",798.31,.01)

"^DD",798.1,798.1,0,"PT",798.5,.02)

"^DD",798.1,798.1,0,"PT",798.6,.02)

"^DD",798.1,798.1,0,"PT",798.73,.01)

"^DD",798.1,798.1,0,"PT",798.8,.03)

"^DD",798.1,798.1,0,"PT",799.1,.03)

"^DD",798.1,798.1,0,"PT",799.51,.02)

"^DD",798.1,798.1,0,"SCR")
I $$ACCESS^RORDD(798.1,Y)
"^DD",798.1,798.1,0,"VRPK")
ROR
"^DD",798.1,798.1,.01,0)
REGISTRY NAME^RFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA))  K:$L(X)>30!($L(X)<3)!'(X?1.UNP) X
"^DD",798.1,798.1,.01,1,0)
^.1^^0
"^DD",798.1,798.1,.01,3)
Enter the unique registry name (3-30 characters).
"^DD",798.1,798.1,.01,8.5)
@
"^DD",798.1,798.1,.01,9)
@
"^DD",798.1,798.1,.01,20,0)
^.3LA^1^1
"^DD",798.1,798.1,.01,20,1,0)
DEFINITION
"^DD",798.1,798.1,.01,21,0)
^^9^9^3021101^
"^DD",798.1,798.1,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,.01,21,3,0)
 
"^DD",798.1,798.1,.01,21,4,0)
You can either select an existing registry or add 
"^DD",798.1,798.1,.01,21,5,0)
a new one. Registry names must be unique. Names of
"^DD",798.1,798.1,.01,21,6,0)
the National registries must start with "VA".
"^DD",798.1,798.1,.01,21,7,0)
 
"^DD",798.1,798.1,.01,21,8,0)
You can select records only of those registries
"^DD",798.1,798.1,.01,21,9,0)
that you have appropriate security key(s) for.
"^DD",798.1,798.1,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,.01,"DT")
3031027
"^DD",798.1,798.1,.09,0)
NATIONAL^SX^0:NO;1:YES;^0;11^Q:$$VAEDT^RORDD(798.1,,-1)
"^DD",798.1,798.1,.09,8.5)
@
"^DD",798.1,798.1,.09,9)
@
"^DD",798.1,798.1,.09,20,0)
^.3LA^1^1
"^DD",798.1,798.1,.09,20,1,0)
DEFINITION
"^DD",798.1,798.1,.09,21,0)
^.001^6^6^3020816^^^^
"^DD",798.1,798.1,.09,21,1,0)
ONLY AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN
"^DD",798.1,798.1,.09,21,2,0)
EDIT THIS FIELD!
"^DD",798.1,798.1,.09,21,3,0)
 
"^DD",798.1,798.1,.09,21,4,0)
The national registries must have this field set
"^DD",798.1,798.1,.09,21,5,0)
to "Yes". This prevents local editing of other 
"^DD",798.1,798.1,.09,21,6,0)
fields of national registry definitions.
"^DD",798.1,798.1,.09,"DEL",1,0)
I $$VADEL^RORDD(798.1,,-1)
"^DD",798.1,798.1,.09,"DT")
3011120
"^DD",798.1,798.1,1,0)
REGISTRY UPDATED UNTIL^D^^0;2^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,1,20,0)
^.3LA^1^1
"^DD",798.1,798.1,1,20,1,0)
STATE
"^DD",798.1,798.1,1,21,0)
^.001^9^9^3020816^^
"^DD",798.1,798.1,1,21,1,0)
This field indicates the date of the last 
"^DD",798.1,798.1,1,21,2,0)
successful run of the regular registry update
"^DD",798.1,798.1,1,21,3,0)
process. The search engine looks for new patients
"^DD",798.1,798.1,1,21,4,0)
starting from this date.
"^DD",798.1,798.1,1,21,5,0)
 
"^DD",798.1,798.1,1,21,6,0)
Usually, this field should not be manually edited;
"^DD",798.1,798.1,1,21,7,0)
it is updated automatically. Before initial
"^DD",798.1,798.1,1,21,8,0)
population of the registry enter the date that the
"^DD",798.1,798.1,1,21,9,0)
data search should start from.
"^DD",798.1,798.1,1,23,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,1,23,1,0)
This field is updated automatically by the registry 
"^DD",798.1,798.1,1,23,2,0)
update process after successful completion (see the 
"^DD",798.1,798.1,1,23,3,0)
$$TMSTMP^RORUPD01 function for details).
"^DD",798.1,798.1,1,"DT")
3010928
"^DD",798.1,798.1,2,0)
DATA EXTRACTED UNTIL^D^^0;3^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,2,20,0)
^.3LA^1^1
"^DD",798.1,798.1,2,20,1,0)
STATE
"^DD",798.1,798.1,2,21,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,2,21,1,0)
This field indicates the date of the last 
"^DD",798.1,798.1,2,21,2,0)
successful run of the regular data extraction
"^DD",798.1,798.1,2,21,3,0)
process. Do not edit this field.
"^DD",798.1,798.1,2,23,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,2,23,1,0)
This field is updated automatically by the regular data
"^DD",798.1,798.1,2,23,2,0)
extraction process after its successful completion (see
"^DD",798.1,798.1,2,23,3,0)
the $$TMSTMP^ROREXTUT function for details).
"^DD",798.1,798.1,2,"DT")
3010928
"^DD",798.1,798.1,2.1,0)
LAST BATCH ID^FX^^0;8^K:X[""""!($A(X)=45) X I $D(X) K:$L(X)>20!($L(X)<1) X
"^DD",798.1,798.1,2.1,3)
The unique ID of the latest batch HL7 message (1-20 characters).
"^DD",798.1,798.1,2.1,8.5)
@
"^DD",798.1,798.1,2.1,9)
@
"^DD",798.1,798.1,2.1,20,0)
^.3LA^1^1
"^DD",798.1,798.1,2.1,20,1,0)
HL7
"^DD",798.1,798.1,2.1,21,0)
^.001^7^7^3020816^^^^
"^DD",798.1,798.1,2.1,21,1,0)
This field contains an identifier of the latest
"^DD",798.1,798.1,2.1,21,2,0)
batch HL7 message created for the registry.
"^DD",798.1,798.1,2.1,21,3,0)
 
"^DD",798.1,798.1,2.1,21,4,0)
Control ID of each individual messages of the
"^DD",798.1,798.1,2.1,21,5,0)
batch is constructed from the value of this field
"^DD",798.1,798.1,2.1,21,6,0)
and a sequential number separated by the '-' 
"^DD",798.1,798.1,2.1,21,7,0)
character.
"^DD",798.1,798.1,2.1,23,0)
^.001^8^8^3020816^^^
"^DD",798.1,798.1,2.1,23,1,0)
The LAST BATCH ID field is automatically populated by
"^DD",798.1,798.1,2.1,23,2,0)
the regular data extraction process every time a batch
"^DD",798.1,798.1,2.1,23,3,0)
HL7 message is successfully generated for the registry.
"^DD",798.1,798.1,2.1,23,4,0)
 
"^DD",798.1,798.1,2.1,23,5,0)
This field is populated with the message control ID
"^DD",798.1,798.1,2.1,23,6,0)
returned by the CREATE^HLTF procedure (see the 
"^DD",798.1,798.1,2.1,23,7,0)
$$CREATE^RORHL7 and $$TMSTMP^ROREXTUT functions for 
"^DD",798.1,798.1,2.1,23,8,0)
details).
"^DD",798.1,798.1,2.1,"DT")
3031027
"^DD",798.1,798.1,2.2,0)
AWAITING ACKNOWLEDGEMENT^D^^0;9^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,2.2,1,0)
^.1^^-1
"^DD",798.1,798.1,2.2,1,1,0)
^^TRIGGER^798.1^2.3
"^DD",798.1,798.1,2.2,1,1,1)
Q
"^DD",798.1,798.1,2.2,1,1,2)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(0)=X S Y(1)=$S($D(^ROR(798.1,D0,0)):^(0),1:"") S X=$P(Y(1),U,9)="" I X S X=DIV S Y(1)=$S($D(^ROR(798.1,D0,0)):^(0),1:"") S X=$P(Y(1),U,13),X=X S DIU=X K Y S X="" X ^DD(798.1,2.2,1,1,2.4)
"^DD",798.1,798.1,2.2,1,1,2.4)
S DIH=$G(^ROR(798.1,DIV(0),0)),DIV=X S $P(^(0),U,13)=DIV,DIH=798.1,DIG=2.3 D ^DICR
"^DD",798.1,798.1,2.2,1,1,3)
Do not delete!
"^DD",798.1,798.1,2.2,1,1,"%D",0)
^^4^4^3030507^
"^DD",798.1,798.1,2.2,1,1,"%D",1,0)
This trigger clears the LAST MESSAGE ID field when
"^DD",798.1,798.1,2.2,1,1,"%D",2,0)
the AWAITING ACKNOWLEDGEMENT field is cleared.
"^DD",798.1,798.1,2.2,1,1,"%D",3,0)
This guaranties that if the expired 
"^DD",798.1,798.1,2.2,1,1,"%D",4,0)
acknowledgement arrives later, it will be ignored.
"^DD",798.1,798.1,2.2,1,1,"CREATE VALUE")
NO EFFECT
"^DD",798.1,798.1,2.2,1,1,"DELETE CONDITION")
AWAITING ACKNOWLEDGEMENT=""
"^DD",798.1,798.1,2.2,1,1,"DELETE VALUE")
""
"^DD",798.1,798.1,2.2,1,1,"FIELD")
LAST MESSAGE ID
"^DD",798.1,798.1,2.2,3)

"^DD",798.1,798.1,2.2,8.5)
@
"^DD",798.1,798.1,2.2,9)
@
"^DD",798.1,798.1,2.2,20,0)
^.3LA^2^2
"^DD",798.1,798.1,2.2,20,1,0)
HL7
"^DD",798.1,798.1,2.2,20,2,0)
STATE
"^DD",798.1,798.1,2.2,21,0)
^^7^7^3030429^
"^DD",798.1,798.1,2.2,21,1,0)
This field is set to current date/time after the
"^DD",798.1,798.1,2.2,21,2,0)
data has been successfully sent to the national
"^DD",798.1,798.1,2.2,21,3,0)
registry. Upon successful receiving and processing
"^DD",798.1,798.1,2.2,21,4,0)
of the acknowledgement the value of this field is
"^DD",798.1,798.1,2.2,21,5,0)
deleted.
"^DD",798.1,798.1,2.2,21,6,0)
 
"^DD",798.1,798.1,2.2,21,7,0)
Usually, you should not edit this field directly.
"^DD",798.1,798.1,2.2,23,0)
^^13^13^3030429^
"^DD",798.1,798.1,2.2,23,1,0)
This field is populated by the regular data extraction
"^DD",798.1,798.1,2.2,23,2,0)
process (see the $$TMSTMP^ROREXTUT function) and
"^DD",798.1,798.1,2.2,23,3,0)
cleared by the acknowledgement processing (see the
"^DD",798.1,798.1,2.2,23,4,0)
$$UPDPARMS^RORACK function) after its successful
"^DD",798.1,798.1,2.2,23,5,0)
completion.
"^DD",798.1,798.1,2.2,23,6,0)
 
"^DD",798.1,798.1,2.2,23,7,0)
Moreover, if the application acknowledgement is not 
"^DD",798.1,798.1,2.2,23,8,0)
received from AAC during the time frame defined by the
"^DD",798.1,798.1,2.2,23,9,0)
value of the DAYS TO WAIT FOR ACK field, the AWAITING 
"^DD",798.1,798.1,2.2,23,10,0)
ACKNOWLEDGEMENT field will be cleared by the regular 
"^DD",798.1,798.1,2.2,23,11,0)
registry update and data extraction task (see the 
"^DD",798.1,798.1,2.2,23,12,0)
source code of the $$CHECKACK^ROR10 function for
"^DD",798.1,798.1,2.2,23,13,0)
details).
"^DD",798.1,798.1,2.2,"DT")
3030422
"^DD",798.1,798.1,2.3,0)
LAST MESSAGE ID^F^^0;13^K:$L(X)>20!($L(X)<1) X
"^DD",798.1,798.1,2.3,1,0)
^.1^^-1
"^DD",798.1,798.1,2.3,1,1,0)
798.1^AM
"^DD",798.1,798.1,2.3,1,1,1)
S ^ROR(798.1,"AM",$E(X,1,30),DA)=""
"^DD",798.1,798.1,2.3,1,1,2)
K ^ROR(798.1,"AM",$E(X,1,30),DA)
"^DD",798.1,798.1,2.3,1,1,3)
Do not delete!
"^DD",798.1,798.1,2.3,1,1,"%D",0)
^.101^6^6^3030523^^
"^DD",798.1,798.1,2.3,1,1,"%D",1,0)
The application acknowledgement handler searches
"^DD",798.1,798.1,2.3,1,1,"%D",2,0)
this cross-reference for the reference message ID
"^DD",798.1,798.1,2.3,1,1,"%D",3,0)
(extracted from the header of the application
"^DD",798.1,798.1,2.3,1,1,"%D",4,0)
acknowledgement) to find the parameters of the
"^DD",798.1,798.1,2.3,1,1,"%D",5,0)
registry that generated the original batch HL7
"^DD",798.1,798.1,2.3,1,1,"%D",6,0)
message.
"^DD",798.1,798.1,2.3,1,1,"DT")
3020325
"^DD",798.1,798.1,2.3,3)
The unique ID of the latest batch HL7 message (1-20 characters).
"^DD",798.1,798.1,2.3,5,1,0)
798.1^2.2^1
"^DD",798.1,798.1,2.3,8.5)
@
"^DD",798.1,798.1,2.3,9)
@
"^DD",798.1,798.1,2.3,20,0)
^.3LA^1^1
"^DD",798.1,798.1,2.3,20,1,0)
HL7
"^DD",798.1,798.1,2.3,21,0)
^.001^5^5^3020816^^
"^DD",798.1,798.1,2.3,21,1,0)
This field contains a message control ID of the
"^DD",798.1,798.1,2.3,21,2,0)
latest batch HL7 message sent to AAC.
"^DD",798.1,798.1,2.3,21,3,0)
 
"^DD",798.1,798.1,2.3,21,4,0)
The application acknowledgement from the AAC will
"^DD",798.1,798.1,2.3,21,5,0)
reference this ID.
"^DD",798.1,798.1,2.3,23,0)
^^12^12^3030507^
"^DD",798.1,798.1,2.3,23,1,0)
This field is automatically populated by the regular
"^DD",798.1,798.1,2.3,23,2,0)
data extraction process every time a batch HL7 message
"^DD",798.1,798.1,2.3,23,3,0)
is sent to AAC. 
"^DD",798.1,798.1,2.3,23,4,0)
 
"^DD",798.1,798.1,2.3,23,5,0)
The control message ID returned by the GENERATE^HLMA
"^DD",798.1,798.1,2.3,23,6,0)
procedure is used to populate this field. This value
"^DD",798.1,798.1,2.3,23,7,0)
may be different from the value of the LAST BATCH ID
"^DD",798.1,798.1,2.3,23,8,0)
field.
"^DD",798.1,798.1,2.3,23,9,0)
 
"^DD",798.1,798.1,2.3,23,10,0)
The field is cleared by the application acknowledgement
"^DD",798.1,798.1,2.3,23,11,0)
handler after successful processing of received batch
"^DD",798.1,798.1,2.3,23,12,0)
acknowledgement (see the $$UPDPARMS^RORACK function).
"^DD",798.1,798.1,2.3,"DT")
3031027
"^DD",798.1,798.1,2.4,0)
LAST IEN EXTRACTED^NJ12,0^^14;1^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,2.4,3)
Enter IEN of the registry record (between 0 and 999999999999).
"^DD",798.1,798.1,2.4,8.5)
@
"^DD",798.1,798.1,2.4,9)
@
"^DD",798.1,798.1,2.4,20,0)
^.3LA^^0
"^DD",798.1,798.1,2.4,21,0)
^.001^12^12^3030418^^^^
"^DD",798.1,798.1,2.4,21,1,0)
This field stores the IEN of the last record
"^DD",798.1,798.1,2.4,21,2,0)
processed by the last registry data extraction
"^DD",798.1,798.1,2.4,21,3,0)
when the size of the HL7 message had reached its
"^DD",798.1,798.1,2.4,21,4,0)
upper limit.
"^DD",798.1,798.1,2.4,21,5,0)
 
"^DD",798.1,798.1,2.4,21,6,0)
The next registry data extraction will start from
"^DD",798.1,798.1,2.4,21,7,0)
the registry record that has an IEN greater than
"^DD",798.1,798.1,2.4,21,8,0)
value of this field.
"^DD",798.1,798.1,2.4,21,9,0)
 
"^DD",798.1,798.1,2.4,21,10,0)
Usually, you should not edit this field. It is 
"^DD",798.1,798.1,2.4,21,11,0)
updated automatically by the registry data 
"^DD",798.1,798.1,2.4,21,12,0)
extraction task.
"^DD",798.1,798.1,2.4,23,0)
^.001^20^20^3030418^^^^
"^DD",798.1,798.1,2.4,23,1,0)
Usually, all new data is sent to the AAC in a single 
"^DD",798.1,798.1,2.4,23,2,0)
message and this field is empty or 0.
"^DD",798.1,798.1,2.4,23,3,0)
 
"^DD",798.1,798.1,2.4,23,4,0)
However, when big amounts of data should be sent, the
"^DD",798.1,798.1,2.4,23,5,0)
ROR software tries to throttle the data flow and even
"^DD",798.1,798.1,2.4,23,6,0)
the spike over the following days.
"^DD",798.1,798.1,2.4,23,7,0)
 
"^DD",798.1,798.1,2.4,23,8,0)
In this case, each data extraction starts from the
"^DD",798.1,798.1,2.4,23,9,0)
registry record that follows the last one processed by
"^DD",798.1,798.1,2.4,23,10,0)
the previous extraction (this field) and continues
"^DD",798.1,798.1,2.4,23,11,0)
until size of the messages reaches its maximum value
"^DD",798.1,798.1,2.4,23,12,0)
(the MAXIMUM MESSAGE SIZE field).
"^DD",798.1,798.1,2.4,23,13,0)
 
"^DD",798.1,798.1,2.4,23,14,0)
The field has the NUMERIC type instead of the POINTER
"^DD",798.1,798.1,2.4,23,15,0)
(to the ROR LOCAL REGISTRY file) to prevent possible
"^DD",798.1,798.1,2.4,23,16,0)
FileMan errors caused by records deleted from the
"^DD",798.1,798.1,2.4,23,17,0)
registry.
"^DD",798.1,798.1,2.4,23,18,0)
 
"^DD",798.1,798.1,2.4,23,19,0)
The field is used and updated by the PROCESS^ROREXT01
"^DD",798.1,798.1,2.4,23,20,0)
function.
"^DD",798.1,798.1,2.4,"DT")
3020801
"^DD",798.1,798.1,2.5,0)
NUMBER OF RETRIES^NJ3,0^^14;2^K:+X'=X!(X>999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,2.5,3)
Type a Number between 0 and 999, 0 Decimal Digits
"^DD",798.1,798.1,2.5,8.5)
@
"^DD",798.1,798.1,2.5,9)
@
"^DD",798.1,798.1,2.5,20,0)
^.3LA^1^1
"^DD",798.1,798.1,2.5,20,1,0)
HL7
"^DD",798.1,798.1,2.5,21,0)
^.001^8^8^3030507^^^
"^DD",798.1,798.1,2.5,21,1,0)
The NUMBER OF RETRIES field is incremented each
"^DD",798.1,798.1,2.5,21,2,0)
time the nightly task (the [ROR TASK] option)
"^DD",798.1,798.1,2.5,21,3,0)
tries to (re)send the HL7 message to the AAC.
"^DD",798.1,798.1,2.5,21,4,0)
 
"^DD",798.1,798.1,2.5,21,5,0)
The field is cleared when a valid application
"^DD",798.1,798.1,2.5,21,6,0)
acknowledgement is received and processed.
"^DD",798.1,798.1,2.5,21,7,0)
 
"^DD",798.1,798.1,2.5,21,8,0)
Usually, you should not edit this field.
"^DD",798.1,798.1,2.5,23,0)
^^11^11^3030507^
"^DD",798.1,798.1,2.5,23,1,0)
When a new HL7 message is generated, the value of this
"^DD",798.1,798.1,2.5,23,2,0)
field is incremented by the $$TMSTMP^ROREXTUT function.
"^DD",798.1,798.1,2.5,23,3,0)
 
"^DD",798.1,798.1,2.5,23,4,0)
The $$CHECKACK^ROR10 function increments the field 
"^DD",798.1,798.1,2.5,23,5,0)
value each time the HL7 message is re-queued.
"^DD",798.1,798.1,2.5,23,6,0)
 
"^DD",798.1,798.1,2.5,23,7,0)
The field is cleared by the $$UPDPARMS^RORACK function 
"^DD",798.1,798.1,2.5,23,8,0)
after successful processing the application
"^DD",798.1,798.1,2.5,23,9,0)
acknowledgement received from the AAC. It is also 
"^DD",798.1,798.1,2.5,23,10,0)
cleared by the Edit 'Awaiting ACK' flag [RORMNT 
"^DD",798.1,798.1,2.5,23,11,0)
AWAITING ACK] menu option.
"^DD",798.1,798.1,2.5,"DT")
3030422
"^DD",798.1,798.1,3,0)
SELECTION RULE^798.13^^1;0
"^DD",798.1,798.1,3,9)
@
"^DD",798.1,798.1,3,20,0)
^.3LA^1^1
"^DD",798.1,798.1,3,20,1,0)
DEFINITION
"^DD",798.1,798.1,3,21,0)
^.001^8^8^3020816^^
"^DD",798.1,798.1,3,21,1,0)
The SELECTION RULE field contains a list of the 
"^DD",798.1,798.1,3,21,2,0)
top-level selection rules that are used to screen
"^DD",798.1,798.1,3,21,3,0)
the patients to be added to the registry.
"^DD",798.1,798.1,3,21,4,0)
 
"^DD",798.1,798.1,3,21,5,0)
The records of the multiple are uniquely 
"^DD",798.1,798.1,3,21,6,0)
identified by the selection rule names. The "A"
"^DD",798.1,798.1,3,21,7,0)
primary key and the uniqueness index "B" are used
"^DD",798.1,798.1,3,21,8,0)
for this purpose.
"^DD",798.1,798.1,4,0)
SHORT DESCRIPTION^RFX^^0;4^Q:$$VAEDT^RORDD(798.1,$G(DA))  K:$L(X)>40!($L(X)<3) X
"^DD",798.1,798.1,4,3)
Enter a short description of the registry (3-40 characters).
"^DD",798.1,798.1,4,8.5)
@
"^DD",798.1,798.1,4,9)
@
"^DD",798.1,798.1,4,21,0)
^.001^2^2^3020403^^
"^DD",798.1,798.1,4,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,4,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,4,"DT")
3011109
"^DD",798.1,798.1,5,0)
DESCRIPTION^798.15^^2;0
"^DD",798.1,798.1,5,21,0)
^.001^2^2^3011009^^^
"^DD",798.1,798.1,5,21,1,0)
Any additional reference information related to
"^DD",798.1,798.1,5,21,2,0)
the registry may be stored in this field.
"^DD",798.1,798.1,5,23,0)
^.001^1^1^3011009^^
"^DD",798.1,798.1,5,23,1,0)
Content of this field is not used by the application.
"^DD",798.1,798.1,6.1,0)
BEFORE UPDATE^FX^^4;E1,245^Q:$$VAEDT^RORDD(798.1,$G(DA))  Q:$$EP^RORDD(3)
"^DD",798.1,798.1,6.1,3)
Answer must be $$TAG^ROUTINE (5-19 characters in length).
"^DD",798.1,798.1,6.1,8.5)
@
"^DD",798.1,798.1,6.1,9)
@
"^DD",798.1,798.1,6.1,20,0)
^.3LA^1^1
"^DD",798.1,798.1,6.1,20,1,0)
DEFINITION
"^DD",798.1,798.1,6.1,21,0)
^.001^7^7^3020816^^^
"^DD",798.1,798.1,6.1,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,6.1,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,6.1,21,3,0)
 
"^DD",798.1,798.1,6.1,21,4,0)
Enter a full name ($$TAG^ROUTINE) of the external
"^DD",798.1,798.1,6.1,21,5,0)
MUMPS function that will be called before adding a
"^DD",798.1,798.1,6.1,21,6,0)
new record to the registry. This entry point can
"^DD",798.1,798.1,6.1,21,7,0)
be used to prepare any additional data.
"^DD",798.1,798.1,6.1,23,0)
^.001^20^20^3020816^^^
"^DD",798.1,798.1,6.1,23,1,0)
The call-back entry point must accept three parameters:
"^DD",798.1,798.1,6.1,23,2,0)
 
"^DD",798.1,798.1,6.1,23,3,0)
FDA - A reference to a local array that contains 
"^DD",798.1,798.1,6.1,23,4,0)
prepared data (for the UPDATE^DIE FileMan DSB call)
"^DD",798.1,798.1,6.1,23,5,0)
that should be stored as a new record in the ROR LOCAL
"^DD",798.1,798.1,6.1,23,6,0)
REGISTRY (#798) file.
"^DD",798.1,798.1,6.1,23,7,0)
 
"^DD",798.1,798.1,6.1,23,8,0)
The main record uses "+1," placeholder and records of
"^DD",798.1,798.1,6.1,23,9,0)
the SELECTION RULE multiple use placeholders with
"^DD",798.1,798.1,6.1,23,10,0)
numbers starting from 1001.
"^DD",798.1,798.1,6.1,23,11,0)
 
"^DD",798.1,798.1,6.1,23,12,0)
See the source code of the $$ADD^RORUPD50 function and
"^DD",798.1,798.1,6.1,23,13,0)
the FileMan Programmer Manual for further details.
"^DD",798.1,798.1,6.1,23,14,0)
 
"^DD",798.1,798.1,6.1,23,15,0)
PATIEN - Patient IEN (in the file #2)
"^DD",798.1,798.1,6.1,23,16,0)
 
"^DD",798.1,798.1,6.1,23,17,0)
REGIEN - Registry IEN (in the file #798.1)
"^DD",798.1,798.1,6.1,23,18,0)
 
"^DD",798.1,798.1,6.1,23,19,0)
The function should return a negative number in case of
"^DD",798.1,798.1,6.1,23,20,0)
errors. Otherwise, zero should be returned.
"^DD",798.1,798.1,6.1,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,6.1,"DT")
3011120
"^DD",798.1,798.1,6.2,0)
AFTER UPDATE^FX^^5;E1,245^Q:$$VAEDT^RORDD(798.1,$G(DA))  Q:$$EP^RORDD(3)
"^DD",798.1,798.1,6.2,3)
Answer must be $$TAG^ROUTINE (5-19 characters in length).
"^DD",798.1,798.1,6.2,8.5)
@
"^DD",798.1,798.1,6.2,9)
@
"^DD",798.1,798.1,6.2,20,0)
^.3LA^1^1
"^DD",798.1,798.1,6.2,20,1,0)
DEFINITION
"^DD",798.1,798.1,6.2,21,0)
^.001^8^8^3020816^^
"^DD",798.1,798.1,6.2,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,6.2,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,6.2,21,3,0)
 
"^DD",798.1,798.1,6.2,21,4,0)
Enter a full name ($$TAG^ROUTINE) of the external
"^DD",798.1,798.1,6.2,21,5,0)
MUMPS function that will be called after adding a
"^DD",798.1,798.1,6.2,21,6,0)
new record to the registry. This entry point can
"^DD",798.1,798.1,6.2,21,7,0)
be used to create record(s) in additional linked
"^DD",798.1,798.1,6.2,21,8,0)
file(s) of the local registry.
"^DD",798.1,798.1,6.2,23,0)
^.001^11^11^3020816^^
"^DD",798.1,798.1,6.2,23,1,0)
The call-back function must accept three parameters:
"^DD",798.1,798.1,6.2,23,2,0)
 
"^DD",798.1,798.1,6.2,23,3,0)
IEN - An IEN of the newly added record of the ROR LOCAL
"^DD",798.1,798.1,6.2,23,4,0)
REGISTRY file
"^DD",798.1,798.1,6.2,23,5,0)
 
"^DD",798.1,798.1,6.2,23,6,0)
PATIEN - Patient IEN (in file #2)
"^DD",798.1,798.1,6.2,23,7,0)
 
"^DD",798.1,798.1,6.2,23,8,0)
REGIEN - Registry IEN (in file #798.1)
"^DD",798.1,798.1,6.2,23,9,0)
 
"^DD",798.1,798.1,6.2,23,10,0)
The function should return a negative number in case of
"^DD",798.1,798.1,6.2,23,11,0)
errors. Otherwise, zero should be returned.
"^DD",798.1,798.1,6.2,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,6.2,"DT")
3011120
"^DD",798.1,798.1,7,0)
EXTRACT PERIOD FOR NEW PATIENT^NJ5,0X^^0;5^Q:$$VAEDT^RORDD(798.1,$G(DA))  K:+X'=X!(X>15000)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,7,3)
Enter number of days between 1 and 15000.
"^DD",798.1,798.1,7,8.5)
@
"^DD",798.1,798.1,7,9)
@
"^DD",798.1,798.1,7,20,0)
^.3LA^1^1
"^DD",798.1,798.1,7,20,1,0)
DEFINITION
"^DD",798.1,798.1,7,21,0)
^.001^11^11^3030717^^^
"^DD",798.1,798.1,7,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,7,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,7,21,3,0)
 
"^DD",798.1,798.1,7,21,4,0)
Enter the number of days that should be subtracted
"^DD",798.1,798.1,7,21,5,0)
from the earliest date when the patient passed one
"^DD",798.1,798.1,7,21,6,0)
of the selection rules. The result will be used as
"^DD",798.1,798.1,7,21,7,0)
the start date of the data extraction for this new
"^DD",798.1,798.1,7,21,8,0)
patient.
"^DD",798.1,798.1,7,21,9,0)
 
"^DD",798.1,798.1,7,21,10,0)
If this field is empty, the default value of 3650
"^DD",798.1,798.1,7,21,11,0)
is used.
"^DD",798.1,798.1,7,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,7,"DT")
3011109
"^DD",798.1,798.1,7,"V",0)
^.12P
"^DD",798.1,798.1,8,0)
ENABLE LOG^S^0:NO;1:YES;^0;6^Q
"^DD",798.1,798.1,8,20,0)
^.3LA^1^1
"^DD",798.1,798.1,8,20,1,0)
PARAMETERS
"^DD",798.1,798.1,8,21,0)
^.001^3^3^3020816^^^^
"^DD",798.1,798.1,8,21,1,0)
Select "Yes" to enable recording of different 
"^DD",798.1,798.1,8,21,2,0)
kinds of events (debug messages, errors, etc.)
"^DD",798.1,798.1,8,21,3,0)
generated by registry processes.
"^DD",798.1,798.1,8,23,0)
^.001^10^10^3020816^^^^
"^DD",798.1,798.1,8,23,1,0)
The ENABLE LOG field controls recording of the errors
"^DD",798.1,798.1,8,23,2,0)
and other events in the log file.
"^DD",798.1,798.1,8,23,3,0)
 
"^DD",798.1,798.1,8,23,4,0)
If internal value of the field is 0 or the field is 
"^DD",798.1,798.1,8,23,5,0)
empty, the recording of all events associated with the
"^DD",798.1,798.1,8,23,6,0)
registry is disabled.
"^DD",798.1,798.1,8,23,7,0)
 
"^DD",798.1,798.1,8,23,8,0)
If internal value of the field is 1, content of the
"^DD",798.1,798.1,8,23,9,0)
LOG EVENTS multiple is analyzed to determine which
"^DD",798.1,798.1,8,23,10,0)
events (errors, warnings, etc.) should be recorded.
"^DD",798.1,798.1,8,"DT")
3000503
"^DD",798.1,798.1,8.1,0)
LOG EVENTS^798.11S^^3;0
"^DD",798.1,798.1,8.1,20,0)
^.3LA^^0
"^DD",798.1,798.1,8.1,21,0)
^.001^8^8^3020816^^^^
"^DD",798.1,798.1,8.1,21,1,0)
The LOG EVENTS multiple contain a list of event 
"^DD",798.1,798.1,8.1,21,2,0)
types that are enabled to record. 
"^DD",798.1,798.1,8.1,21,3,0)
 
"^DD",798.1,798.1,8.1,21,4,0)
If the list is empty and recording is enabled, 
"^DD",798.1,798.1,8.1,21,5,0)
all events except debug messages will be recorded.
"^DD",798.1,798.1,8.1,21,6,0)
 
"^DD",798.1,798.1,8.1,21,7,0)
Otherwise, only recording of the events from the
"^DD",798.1,798.1,8.1,21,8,0)
list and error messages will be enabled.
"^DD",798.1,798.1,9,0)
HL7 SEGMENT^798.19I^^6;0
"^DD",798.1,798.1,9,20,0)
^.3LA^2^2
"^DD",798.1,798.1,9,20,1,0)
HL7
"^DD",798.1,798.1,9,20,2,0)
DEFINITION
"^DD",798.1,798.1,9,21,0)
^.001^16^16^3030603^^^^
"^DD",798.1,798.1,9,21,1,0)
This multiple contains a list of segments that the
"^DD",798.1,798.1,9,21,2,0)
registry HL7 message is composed from. 
"^DD",798.1,798.1,9,21,3,0)
 
"^DD",798.1,798.1,9,21,4,0)
Records of the multiple are uniquely identified by
"^DD",798.1,798.1,9,21,5,0)
the data area code and segment name. The "A" 
"^DD",798.1,798.1,9,21,6,0)
primary key and uniqueness index "KEY" are used
"^DD",798.1,798.1,9,21,7,0)
for this purpose.
"^DD",798.1,798.1,9,21,8,0)
 
"^DD",798.1,798.1,9,21,9,0)
The general structure of the message is hard-coded
"^DD",798.1,798.1,9,21,10,0)
in the message builder (either default or defined
"^DD",798.1,798.1,9,21,11,0)
by the MESSAGE BUILDER field) but you can exclude
"^DD",798.1,798.1,9,21,12,0)
some segments (or fields) from the message by
"^DD",798.1,798.1,9,21,13,0)
deleting them from this list.
"^DD",798.1,798.1,9,21,14,0)
 
"^DD",798.1,798.1,9,21,15,0)
See the source code of the $$MESSAGE^ROREXT02
"^DD",798.1,798.1,9,21,16,0)
function for the further details.
"^DD",798.1,798.1,10,0)
MESSAGE BUILDER^FX^^7;E1,245^Q:$$VAEDT^RORDD(798.1,$G(DA))  Q:$$EP^RORDD(4)
"^DD",798.1,798.1,10,3)
Answer must be $$TAG^ROUTINE (5-19 characters in length).
"^DD",798.1,798.1,10,8.5)
@
"^DD",798.1,798.1,10,9)
@
"^DD",798.1,798.1,10,20,0)
^.3LA^1^1
"^DD",798.1,798.1,10,20,1,0)
DEFINITION
"^DD",798.1,798.1,10,21,0)
^.001^9^9^3030513^^^^
"^DD",798.1,798.1,10,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,10,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,10,21,3,0)
 
"^DD",798.1,798.1,10,21,4,0)
Enter a full name ($$TAG^ROUTINE) of the external 
"^DD",798.1,798.1,10,21,5,0)
MUMPS function that will be called to generate the
"^DD",798.1,798.1,10,21,6,0)
HL7 message for each record of the registry.
"^DD",798.1,798.1,10,21,7,0)
 
"^DD",798.1,798.1,10,21,8,0)
If this field has no value, the default entry 
"^DD",798.1,798.1,10,21,9,0)
point ($$MESSAGE^ROREXT02) will be used.
"^DD",798.1,798.1,10,23,0)
^^30^30^3030513^
"^DD",798.1,798.1,10,23,1,0)
The call-back function must accept four parameters:
"^DD",798.1,798.1,10,23,2,0)
 
"^DD",798.1,798.1,10,23,3,0)
IEN - IEN of the registry record
"^DD",798.1,798.1,10,23,4,0)
 
"^DD",798.1,798.1,10,23,5,0)
PATIEN - Patient IEN (in the file #2)
"^DD",798.1,798.1,10,23,6,0)
 
"^DD",798.1,798.1,10,23,7,0)
[.]DXDTS - Either a single time frame in 
"^DD",798.1,798.1,10,23,8,0)
StartDate^EndDate format or a reference to a local 
"^DD",798.1,798.1,10,23,9,0)
variable containing the list of data extraction time 
"^DD",798.1,798.1,10,23,10,0)
frames. The main time frame should be stored in the
"^DD",798.1,798.1,10,23,11,0)
root node (see the $$DXPERIOD^ROREXTUT function for 
"^DD",798.1,798.1,10,23,12,0)
details):
"^DD",798.1,798.1,10,23,13,0)
 
"^DD",798.1,798.1,10,23,14,0)
  DXDTS(         StartDate^EndDate  (FileMan)
"^DD",798.1,798.1,10,23,15,0)
    DataArea,
"^DD",798.1,798.1,10,23,16,0)
      i)         StartDate^EndDate  (FileMan)
"^DD",798.1,798.1,10,23,17,0)
 
"^DD",798.1,798.1,10,23,18,0)
The function should add the text of the HL7 message 
"^DD",798.1,798.1,10,23,19,0)
after already existing nodes in the standard location:
"^DD",798.1,798.1,10,23,20,0)
^TMP("HLS",$J). DO NOT KILL THIS NODE! It contains the
"^DD",798.1,798.1,10,23,21,0)
previous messages of the batch.
"^DD",798.1,798.1,10,23,22,0)
 
"^DD",798.1,798.1,10,23,23,0)
If the message was generated successfully, the function
"^DD",798.1,798.1,10,23,24,0)
should return zero. Otherwise, either a negative error
"^DD",798.1,798.1,10,23,25,0)
code (in case of an error) or a positive value (if the
"^DD",798.1,798.1,10,23,26,0)
message should be discarded for some reason) must be
"^DD",798.1,798.1,10,23,27,0)
returned. 
"^DD",798.1,798.1,10,23,28,0)
                                                                    
"^DD",798.1,798.1,10,23,29,0)
See the source code of the $$MESSAGE^ROREXT02 function 
"^DD",798.1,798.1,10,23,30,0)
for further details.
"^DD",798.1,798.1,10,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,10,"DT")
3011120
"^DD",798.1,798.1,11,0)
REGISTRY STATUS^S^0:ACTIVE;1:INACTIVE;^0;7^Q
"^DD",798.1,798.1,11,1,0)
^.1^^0
"^DD",798.1,798.1,11,20,0)
^.3LA^1^1
"^DD",798.1,798.1,11,20,1,0)
PARAMETERS
"^DD",798.1,798.1,11,21,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,11,21,1,0)
Select the "INACTIVE" code if you want to exclude
"^DD",798.1,798.1,11,21,2,0)
the registry from the regular registry updates and
"^DD",798.1,798.1,11,21,3,0)
data transmissions.
"^DD",798.1,798.1,11,"DT")
3020424
"^DD",798.1,798.1,12,0)
EXTRACTED RESULT^798.112I^^8;0
"^DD",798.1,798.1,12,9)
@
"^DD",798.1,798.1,12,20,0)
^.3LA^1^1
"^DD",798.1,798.1,12,20,1,0)
DEFINITION
"^DD",798.1,798.1,12,21,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,12,21,1,0)
This multiple contains a list of Lab result codes.
"^DD",798.1,798.1,12,21,2,0)
These results will be extracted and transmitted to
"^DD",798.1,798.1,12,21,3,0)
AAC.
"^DD",798.1,798.1,12,"DT")
3010629
"^DD",798.1,798.1,13,0)
PROTOCOL^*P101'X^ORD(101,^9;1^Q:$$VAEDT^RORDD(798.1,$G(DA))  S DIC("S")="S D=$G(^(0)) I $E($P(D,U),1,3)=""ROR"",$P(D,U,4)=""E""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",798.1,798.1,13,3)

"^DD",798.1,798.1,13,8.5)
@
"^DD",798.1,798.1,13,9)
@
"^DD",798.1,798.1,13,12)
Only Event Drivers from the "ROR" namespace can be selected!
"^DD",798.1,798.1,13,12.1)
S DIC("S")="S D=$G(^(0)) I $E($P(D,U),1,3)=""ROR"",$P(D,U,4)=""E"""
"^DD",798.1,798.1,13,20,0)
^.3LA^2^2
"^DD",798.1,798.1,13,20,1,0)
HL7
"^DD",798.1,798.1,13,20,2,0)
DEFINITION
"^DD",798.1,798.1,13,21,0)
^.001^6^6^3020816^^^
"^DD",798.1,798.1,13,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.1,798.1,13,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,13,21,3,0)
 
"^DD",798.1,798.1,13,21,4,0)
This field contains a pointer to the protocol in 
"^DD",798.1,798.1,13,21,5,0)
the PROTOCOL file that is used as the event driver
"^DD",798.1,798.1,13,21,6,0)
for sending HL7 messages.
"^DD",798.1,798.1,13,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,13,"DT")
3011112
"^DD",798.1,798.1,13.1,0)
MAXIMUM MESSAGE SIZE^NJ4,1^^9;2^K:+X'=X!(X>99)!(X<0)!(X?.E1"."2N.N) X
"^DD",798.1,798.1,13.1,3)
Enter maximum size (in megabytes) between 0 and 99, 1 decimal digit.
"^DD",798.1,798.1,13.1,8.5)
@
"^DD",798.1,798.1,13.1,9)
@
"^DD",798.1,798.1,13.1,20,0)
^.3LA^2^2
"^DD",798.1,798.1,13.1,20,1,0)
HL7
"^DD",798.1,798.1,13.1,20,2,0)
PARAMETERS
"^DD",798.1,798.1,13.1,21,0)
^.001^8^8^3020816^^^
"^DD",798.1,798.1,13.1,21,1,0)
This field stores the maximum size (in megabytes)
"^DD",798.1,798.1,13.1,21,2,0)
of a batch HL7 message that can be sent to Austin
"^DD",798.1,798.1,13.1,21,3,0)
Automation Center (AAC). If this field is empty or
"^DD",798.1,798.1,13.1,21,4,0)
contains 0, the size is not limited.
"^DD",798.1,798.1,13.1,21,5,0)
 
"^DD",798.1,798.1,13.1,21,6,0)
You must co-ordinate your intentions with AAC
"^DD",798.1,798.1,13.1,21,7,0)
support personnel if you are going to edit this
"^DD",798.1,798.1,13.1,21,8,0)
field.
"^DD",798.1,798.1,13.1,23,0)
^.001^8^8^3020816^^^
"^DD",798.1,798.1,13.1,23,1,0)
Actual size of an HL7 batch can be greater than the
"^DD",798.1,798.1,13.1,23,2,0)
value of this field because the software does not break
"^DD",798.1,798.1,13.1,23,3,0)
in the middle of an individual HL7 message.
"^DD",798.1,798.1,13.1,23,4,0)
 
"^DD",798.1,798.1,13.1,23,5,0)
For example, if the maximum size is 10Mb, the current
"^DD",798.1,798.1,13.1,23,6,0)
size is 9Mb and 3Mb should be sent for the patient
"^DD",798.1,798.1,13.1,23,7,0)
being processed then the actual size of the batch will
"^DD",798.1,798.1,13.1,23,8,0)
be 12Mb.
"^DD",798.1,798.1,13.1,"DT")
3020730
"^DD",798.1,798.1,13.2,0)
NUMBER OF RETRIES FOR ALERT^NJ2,0^^9;3^K:+X'=X!(X>10)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,13.2,3)
Type a Number between 1 and 10, 0 Decimal Digits
"^DD",798.1,798.1,13.2,8.5)
@
"^DD",798.1,798.1,13.2,9)
@
"^DD",798.1,798.1,13.2,11,0)
^.2LAP^^0
"^DD",798.1,798.1,13.2,20,0)
^.3LA^2^2
"^DD",798.1,798.1,13.2,20,1,0)
HL7
"^DD",798.1,798.1,13.2,20,2,0)
PARAMETERS
"^DD",798.1,798.1,13.2,21,0)
^^16^16^3030929^
"^DD",798.1,798.1,13.2,21,1,0)
Value of the NUMBER OF RETRIES FOR ALERT field 
"^DD",798.1,798.1,13.2,21,2,0)
determines how often the e-mail notifications and
"^DD",798.1,798.1,13.2,21,3,0)
VistA alerts will be sent to the AAC and local
"^DD",798.1,798.1,13.2,21,4,0)
registry coordinators in case of any problems with
"^DD",798.1,798.1,13.2,21,5,0)
the HL7 data transmissions.
"^DD",798.1,798.1,13.2,21,6,0)
 
"^DD",798.1,798.1,13.2,21,7,0)
If this field is empty, the notifications will not
"^DD",798.1,798.1,13.2,21,8,0)
be sent.
"^DD",798.1,798.1,13.2,21,9,0)
 
"^DD",798.1,798.1,13.2,21,10,0)
Otherwise, before an HL7 message is (re)sent to
"^DD",798.1,798.1,13.2,21,11,0)
the AAC, the software will check the remainder
"^DD",798.1,798.1,13.2,21,12,0)
from division of the number of retries by the
"^DD",798.1,798.1,13.2,21,13,0)
value of this field. If the reminder is equal to
"^DD",798.1,798.1,13.2,21,14,0)
0, the e-mail notification will be sent to the AAC
"^DD",798.1,798.1,13.2,21,15,0)
and the VistA alert will be sent to the local
"^DD",798.1,798.1,13.2,21,16,0)
coordinators.
"^DD",798.1,798.1,13.2,23,0)
^.001^3^3^3030929^^^^
"^DD",798.1,798.1,13.2,23,1,0)
See descriptions of the NUMBER OF RETRIES and DAYS TO 
"^DD",798.1,798.1,13.2,23,2,0)
WAIT FOR ACK fields, and the source code of the 
"^DD",798.1,798.1,13.2,23,3,0)
$$CHECKACK^ROR10 function for more details.
"^DD",798.1,798.1,13.2,"DT")
3030422
"^DD",798.1,798.1,13.3,0)
NATIONAL NOTIFICATION E-MAIL^FX^^9;4^Q:$$VAEDT^RORDD(798.1,$G(DA))  K:$L(X)>50!($L(X)<3)!(X'?1.ANP1"@"1.ANP) X
"^DD",798.1,798.1,13.3,3)
Answer must be a valid e-mail address (3-50 characters in length)
"^DD",798.1,798.1,13.3,8.5)
@
"^DD",798.1,798.1,13.3,9)
@
"^DD",798.1,798.1,13.3,20,0)
^.3LA^1^1
"^DD",798.1,798.1,13.3,20,1,0)
DEFINITION
"^DD",798.1,798.1,13.3,21,0)
^.001^10^10^3030429^^
"^DD",798.1,798.1,13.3,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.1,798.1,13.3,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,13.3,21,3,0)
 
"^DD",798.1,798.1,13.3,21,4,0)
The NATIONAL NOTIFICATION E-MAIL field holds an 
"^DD",798.1,798.1,13.3,21,5,0)
e-mail address where the notifications about the
"^DD",798.1,798.1,13.3,21,6,0)
registry problems (mostly, the data transmission
"^DD",798.1,798.1,13.3,21,7,0)
problems) are sent to.
"^DD",798.1,798.1,13.3,21,8,0)
 
"^DD",798.1,798.1,13.3,21,9,0)
If the field is empty, the e-mail notifications
"^DD",798.1,798.1,13.3,21,10,0)
will not be sent.
"^DD",798.1,798.1,13.3,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,13.3,"DT")
3030429
"^DD",798.1,798.1,14,0)
COORDINATOR^798.114P^^10;0
"^DD",798.1,798.1,14,21,0)
^^2^2^3011012^
"^DD",798.1,798.1,14,21,1,0)
This multiple contains a list of the registry 
"^DD",798.1,798.1,14,21,2,0)
coordinators.
"^DD",798.1,798.1,15.1,0)
LAG DAYS^NJ1,0^^11;1^K:+X'=X!(X>7)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,15.1,3)
Enter number of days between 1 and 7.
"^DD",798.1,798.1,15.1,20,0)
^.3LA^1^1
"^DD",798.1,798.1,15.1,20,1,0)
PARAMETERS
"^DD",798.1,798.1,15.1,21,0)
^.001^12^12^3020816^^^
"^DD",798.1,798.1,15.1,21,1,0)
Number of days that defines an overlap of the data
"^DD",798.1,798.1,15.1,21,2,0)
searches during the registry updates and a data
"^DD",798.1,798.1,15.1,21,3,0)
extraction delay during the regular data
"^DD",798.1,798.1,15.1,21,4,0)
extractions.
"^DD",798.1,798.1,15.1,21,5,0)
 
"^DD",798.1,798.1,15.1,21,6,0)
If this field is empty, the default value of 1 is 
"^DD",798.1,798.1,15.1,21,7,0)
used by the registry update and data extraction
"^DD",798.1,798.1,15.1,21,8,0)
processes.
"^DD",798.1,798.1,15.1,21,9,0)
 
"^DD",798.1,798.1,15.1,21,10,0)
See the package documentation or Technical
"^DD",798.1,798.1,15.1,21,11,0)
Description of the field in the data dictionary
"^DD",798.1,798.1,15.1,21,12,0)
for more information.
"^DD",798.1,798.1,15.1,23,0)
^.001^37^37^3020816^^^
"^DD",798.1,798.1,15.1,23,1,0)
Clinical data may be entered to the VistA system later
"^DD",798.1,798.1,15.1,23,2,0)
than they are available. For example, an encounter that
"^DD",798.1,798.1,15.1,23,3,0)
occurred today may not get entered into the system
"^DD",798.1,798.1,15.1,23,4,0)
until tomorrow.
"^DD",798.1,798.1,15.1,23,5,0)
 
"^DD",798.1,798.1,15.1,23,6,0)
Because of this data may be missed by the registry
"^DD",798.1,798.1,15.1,23,7,0)
update and data extraction processes if they look for
"^DD",798.1,798.1,15.1,23,8,0)
the data until the current date and then continue from
"^DD",798.1,798.1,15.1,23,9,0)
that point next time.
"^DD",798.1,798.1,15.1,23,10,0)
 
"^DD",798.1,798.1,15.1,23,11,0)
To avoid this problem data search intervals are 
"^DD",798.1,798.1,15.1,23,12,0)
overlapped by the number of days indicated by this 
"^DD",798.1,798.1,15.1,23,13,0)
field. The registry update process looks for new data 
"^DD",798.1,798.1,15.1,23,14,0)
not from the end date of its previous run but from the 
"^DD",798.1,798.1,15.1,23,15,0)
date that is earlier by the number of days from this 
"^DD",798.1,798.1,15.1,23,16,0)
field. This overlap increases chances of the data
"^DD",798.1,798.1,15.1,23,17,0)
entered retrospectively to be found by the next run of
"^DD",798.1,798.1,15.1,23,18,0)
the registry update process.
"^DD",798.1,798.1,15.1,23,19,0)
 
"^DD",798.1,798.1,15.1,23,20,0)
Moreover, the regular data extraction process extracts
"^DD",798.1,798.1,15.1,23,21,0)
data not until the date when the process is run but
"^DD",798.1,798.1,15.1,23,22,0)
until the date that is earlier by the number of days
"^DD",798.1,798.1,15.1,23,23,0)
from this field. So, this is a delay that increases
"^DD",798.1,798.1,15.1,23,24,0)
chances of the data to be entered retrospectively
"^DD",798.1,798.1,15.1,23,25,0)
before the next data extraction.
"^DD",798.1,798.1,15.1,23,26,0)
 
"^DD",798.1,798.1,15.1,23,27,0)
If the value of this field is too small, you may miss 
"^DD",798.1,798.1,15.1,23,28,0)
some data entered retrospectively. If it is too big,
"^DD",798.1,798.1,15.1,23,29,0)
the national registry will not contain the up to date
"^DD",798.1,798.1,15.1,23,30,0)
information (data will be delayed by the number of days
"^DD",798.1,798.1,15.1,23,31,0)
indicated by this field) and the registry update
"^DD",798.1,798.1,15.1,23,32,0)
process will take more time to complete (this time will
"^DD",798.1,798.1,15.1,23,33,0)
be spent processing the data from the overlap
"^DD",798.1,798.1,15.1,23,34,0)
interval).
"^DD",798.1,798.1,15.1,23,35,0)
 
"^DD",798.1,798.1,15.1,23,36,0)
When several registries are processed at the same time,
"^DD",798.1,798.1,15.1,23,37,0)
the maximum value of the LAG DAYS field is used.
"^DD",798.1,798.1,15.1,"DT")
3020426
"^DD",798.1,798.1,15.9,0)
DAYS TO WAIT FOR ACK^NJ1,0^^11;2^K:+X'=X!(X>7)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,15.9,3)
Type a number of days between 0 and 7.
"^DD",798.1,798.1,15.9,20,0)
^.3LA^2^2
"^DD",798.1,798.1,15.9,20,1,0)
HL7
"^DD",798.1,798.1,15.9,20,2,0)
PARAMETERS
"^DD",798.1,798.1,15.9,21,0)
^^11^11^3030429^
"^DD",798.1,798.1,15.9,21,1,0)
The value of this field determines how many days 
"^DD",798.1,798.1,15.9,21,2,0)
the package waits for an application
"^DD",798.1,798.1,15.9,21,3,0)
acknowledgement from the AAC.
"^DD",798.1,798.1,15.9,21,4,0)
 
"^DD",798.1,798.1,15.9,21,5,0)
If the value of this field is equal to 0 then the 
"^DD",798.1,798.1,15.9,21,6,0)
nightly task (the [ROR TASK] option) will not wait
"^DD",798.1,798.1,15.9,21,7,0)
for the application acknowledgement. It will try
"^DD",798.1,798.1,15.9,21,8,0)
to resend the last message straight away.
"^DD",798.1,798.1,15.9,21,9,0)
 
"^DD",798.1,798.1,15.9,21,10,0)
By default (if the field is empty), the waiting
"^DD",798.1,798.1,15.9,21,11,0)
time is 1 day.
"^DD",798.1,798.1,15.9,23,0)
^^15^15^3030507^
"^DD",798.1,798.1,15.9,23,1,0)
If the application acknowledgement is not received in
"^DD",798.1,798.1,15.9,23,2,0)
the time frame defined by the value of this field, the
"^DD",798.1,798.1,15.9,23,3,0)
nightly task will try to re-queue the last HL7 message.
"^DD",798.1,798.1,15.9,23,4,0)
 
"^DD",798.1,798.1,15.9,23,5,0)
If this attempt fails by any reason, the fields related
"^DD",798.1,798.1,15.9,23,6,0)
to the most recent data transmission (AWAITING
"^DD",798.1,798.1,15.9,23,7,0)
ACKNOWLEDGEMENT, LAST MESSAGE ID, etc) will be cleared
"^DD",798.1,798.1,15.9,23,8,0)
automatically. The last HL7 message will be cancelled
"^DD",798.1,798.1,15.9,23,9,0)
and a new one will be generated.
"^DD",798.1,798.1,15.9,23,10,0)
 
"^DD",798.1,798.1,15.9,23,11,0)
The AAC and local registry coordinators will be 
"^DD",798.1,798.1,15.9,23,12,0)
notified if necessary. See descriptions of the NUMBER
"^DD",798.1,798.1,15.9,23,13,0)
OF RETRIES and NUMBER OF RETRIES FOR ALERT fields, and
"^DD",798.1,798.1,15.9,23,14,0)
the source code of the $$CHECKACK^ROR10 function for
"^DD",798.1,798.1,15.9,23,15,0)
more details.
"^DD",798.1,798.1,15.9,"DT")
3020425
"^DD",798.1,798.1,16,0)
USER^798.116A^^13;0
"^DD",798.1,798.1,16,20,0)
^.3LA^^0
"^DD",798.1,798.1,17,0)
DRUG THERAPY LIST^798.117^^12;0
"^DD",798.1,798.1,17,9)
@
"^DD",798.1,798.1,17,20,0)
^.3LA^1^1
"^DD",798.1,798.1,17,20,1,0)
DEFINITION
"^DD",798.1,798.1,17,21,0)
^.001^3^3^3020816^^^^
"^DD",798.1,798.1,17,21,1,0)
A list of National Drug Codes to use in the Drug 
"^DD",798.1,798.1,17,21,2,0)
Therapy report. Use of the drugs listed here will
"^DD",798.1,798.1,17,21,3,0)
be reported in the Drug Therapy report.
"^DD",798.1,798.1,18,0)
SECURITY KEY^798.118^^18;0
"^DD",798.1,798.1,18,9)
@
"^DD",798.1,798.1,18,20,0)
^.3LA^1^1
"^DD",798.1,798.1,18,20,1,0)
DEFINITION
"^DD",798.1,798.1,18,21,0)
^.001^2^2^3020816^^^^
"^DD",798.1,798.1,18,21,1,0)
This multiple stores a list of security keys 
"^DD",798.1,798.1,18,21,2,0)
associated with the registry.
"^DD",798.1,798.1,19.1,0)
NUMBER OF PATIENTS^NJ9,0^^19;1^K:+X'=X!(X>999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,19.1,3)
Type a Number between 0 and 999999999, 0 Decimal Digits
"^DD",798.1,798.1,19.1,8.5)
@
"^DD",798.1,798.1,19.1,9)
@
"^DD",798.1,798.1,19.1,20,0)
^.3LA^1^1
"^DD",798.1,798.1,19.1,20,1,0)
STATE
"^DD",798.1,798.1,19.1,21,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,19.1,21,1,0)
The NUMBER OF PATIENTS field contains total number
"^DD",798.1,798.1,19.1,21,2,0)
of patients in the registry right after the last
"^DD",798.1,798.1,19.1,21,3,0)
registry update.
"^DD",798.1,798.1,19.1,23,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,19.1,23,1,0)
The field cannot be edited. It is updated automatically
"^DD",798.1,798.1,19.1,23,2,0)
by the $$UPDDEM^RORUPD51 function during the registry
"^DD",798.1,798.1,19.1,23,3,0)
update.
"^DD",798.1,798.1,19.1,"DT")
3031027
"^DD",798.1,798.1,19.2,0)
NUMBER OF ACTIVE PATIENTS^NJ9,0^^19;2^K:+X'=X!(X>999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,19.2,3)
Type a Number between 0 and 999999999, 0 Decimal Digits
"^DD",798.1,798.1,19.2,8.5)
@
"^DD",798.1,798.1,19.2,9)
@
"^DD",798.1,798.1,19.2,20,0)
^.3LA^1^1
"^DD",798.1,798.1,19.2,20,1,0)
STATE
"^DD",798.1,798.1,19.2,21,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,19.2,21,1,0)
The NUMBER OF ACTIVE PATIENTS field contains 
"^DD",798.1,798.1,19.2,21,2,0)
number of active patients in the registry right
"^DD",798.1,798.1,19.2,21,3,0)
after the last registry update.
"^DD",798.1,798.1,19.2,23,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,19.2,23,1,0)
The field cannot be edited. It is updated automatically
"^DD",798.1,798.1,19.2,23,2,0)
by the $$UPDDEM^RORUPD51 function during the registry
"^DD",798.1,798.1,19.2,23,3,0)
update.
"^DD",798.1,798.1,19.2,"DT")
3031027
"^DD",798.1,798.1,21.01,0)
HDT START DATE^RD^^21;1^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,21.01,21,0)
^.001^6^6^3011109^^
"^DD",798.1,798.1,21.01,21,1,0)
This field indicates the start date for the 
"^DD",798.1,798.1,21.01,21,2,0)
historical data extraction.  
"^DD",798.1,798.1,21.01,21,3,0)
                                 
"^DD",798.1,798.1,21.01,21,4,0)
Usually, this field should not be edited. Its
"^DD",798.1,798.1,21.01,21,5,0)
predefined value is distributed within the package
"^DD",798.1,798.1,21.01,21,6,0)
KIDS build.
"^DD",798.1,798.1,21.01,"DT")
3011109
"^DD",798.1,798.1,21.02,0)
HDT END DATE^D^^21;2^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,21.02,21,0)
^^6^6^3020508^
"^DD",798.1,798.1,21.02,21,1,0)
This field indicates the end date for the 
"^DD",798.1,798.1,21.02,21,2,0)
historical data extraction.
"^DD",798.1,798.1,21.02,21,3,0)
 
"^DD",798.1,798.1,21.02,21,4,0)
Usually, this field should not be edited. It is 
"^DD",798.1,798.1,21.02,21,5,0)
populated automatically by the registry setup 
"^DD",798.1,798.1,21.02,21,6,0)
task.
"^DD",798.1,798.1,21.02,23,0)
^^1^1^3020508^
"^DD",798.1,798.1,21.02,23,1,0)
See the $$UPDHDTRP^RORSETU2 function for details.
"^DD",798.1,798.1,21.02,"DT")
3011107
"^DD",798.1,798.1,21.03,0)
HDT OUTPUT DIRECTORY^F^^21.03;E1,245^K:$L(X)>245!($L(X)<1) X
"^DD",798.1,798.1,21.03,3)
Enter a valid name of the output directory (1-245 characters).
"^DD",798.1,798.1,21.03,21,0)
^^19^19^3011107^
"^DD",798.1,798.1,21.03,21,1,0)
A directory must be created within the file system
"^DD",798.1,798.1,21.03,21,2,0)
of the host operating system (VMS, Windows,
"^DD",798.1,798.1,21.03,21,3,0)
etc).  Text files containing historical data in
"^DD",798.1,798.1,21.03,21,4,0)
the HL7 format will be created in this directory
"^DD",798.1,798.1,21.03,21,5,0)
by the data extraction tasks.
"^DD",798.1,798.1,21.03,21,6,0)
                                 
"^DD",798.1,798.1,21.03,21,7,0)
The full name of the directory must be entered as
"^DD",798.1,798.1,21.03,21,8,0)
a value of this field. For example, the value can
"^DD",798.1,798.1,21.03,21,9,0)
look something like this: 
"^DD",798.1,798.1,21.03,21,10,0)
                                 
"^DD",798.1,798.1,21.03,21,11,0)
 VA2$:[OUTPUT] - VAX VMS 
"^DD",798.1,798.1,21.03,21,12,0)
 D:\Output\    - Windows, MS-DOS 
"^DD",798.1,798.1,21.03,21,13,0)
                                 
"^DD",798.1,798.1,21.03,21,14,0)
Because a file name will be concatenated to the
"^DD",798.1,798.1,21.03,21,15,0)
directory name, the trailing slash in the Windows
"^DD",798.1,798.1,21.03,21,16,0)
directory name is required.  
"^DD",798.1,798.1,21.03,21,17,0)
                                 
"^DD",798.1,798.1,21.03,21,18,0)
Do not forget to enable read/write access to this
"^DD",798.1,798.1,21.03,21,19,0)
directory for M processes!
"^DD",798.1,798.1,21.03,"DT")
3011108
"^DD",798.1,798.1,21.04,0)
LOCAL DATA RESENT^D^^21;3^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,21.04,8.5)
@
"^DD",798.1,798.1,21.04,9)
@
"^DD",798.1,798.1,21.04,20,0)
^.3LA^1^1
"^DD",798.1,798.1,21.04,20,1,0)
STATE
"^DD",798.1,798.1,21.04,21,0)
^.001^10^10^3020816^^^^
"^DD",798.1,798.1,21.04,21,1,0)
This field holds the date when all local registry 
"^DD",798.1,798.1,21.04,21,2,0)
data was resent to AAC after the installation (to 
"^DD",798.1,798.1,21.04,21,3,0)
fix the data incorrectly overwritten with the 
"^DD",798.1,798.1,21.04,21,4,0)
historical data).
"^DD",798.1,798.1,21.04,21,5,0)
 
"^DD",798.1,798.1,21.04,21,6,0)
Usually, you should not modify this field. If, by
"^DD",798.1,798.1,21.04,21,7,0)
some reason, you need to resend all local registry
"^DD",798.1,798.1,21.04,21,8,0)
and demographic data to AAC, you should clear this
"^DD",798.1,798.1,21.04,21,9,0)
field. The data will be resent automatically 
"^DD",798.1,798.1,21.04,21,10,0)
during the next nightly transmission.
"^DD",798.1,798.1,21.04,23,0)
^.001^4^4^3020816^^^^
"^DD",798.1,798.1,21.04,23,1,0)
The value of this field is analyzed and modified by the
"^DD",798.1,798.1,21.04,23,2,0)
$$REMARK^RORUTL05 function. The function is called by
"^DD",798.1,798.1,21.04,23,3,0)
the nightly registry update and data transmission task
"^DD",798.1,798.1,21.04,23,4,0)
(TASK^ROR).
"^DD",798.1,798.1,21.04,"DT")
3020508
"^DD",798.1,798.1,21.05,0)
HDT DATE/TIME^D^^21;4^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,21.05,8.5)
@
"^DD",798.1,798.1,21.05,9)
@
"^DD",798.1,798.1,21.05,21,0)
^^4^4^3020508^
"^DD",798.1,798.1,21.05,21,1,0)
This field is initialized with the current 
"^DD",798.1,798.1,21.05,21,2,0)
date/time by the registry setup task upon
"^DD",798.1,798.1,21.05,21,3,0)
successful completion of the initial registry
"^DD",798.1,798.1,21.05,21,4,0)
population.
"^DD",798.1,798.1,21.05,23,0)
^^10^10^3020508^
"^DD",798.1,798.1,21.05,23,1,0)
The field is populated by the $$UPDHDTRP^RORSETU2 
"^DD",798.1,798.1,21.05,23,2,0)
function during the registry setup.
"^DD",798.1,798.1,21.05,23,3,0)
 
"^DD",798.1,798.1,21.05,23,4,0)
The historical data extraction tasks do not process the
"^DD",798.1,798.1,21.05,23,5,0)
registry records that were added after this date. This
"^DD",798.1,798.1,21.05,23,6,0)
prevents sending the same data twice (by the regular
"^DD",798.1,798.1,21.05,23,7,0)
data extraction process and the historical data
"^DD",798.1,798.1,21.05,23,8,0)
extraction task).
"^DD",798.1,798.1,21.05,23,9,0)
 
"^DD",798.1,798.1,21.05,23,10,0)
Do not delete value of this field!
"^DD",798.1,798.1,21.05,"DT")
3031027
"^DD",798.1,798.1,25,0)
ENABLE PROTOCOLS^S^0:NO;1:YES;^0;14^Q
"^DD",798.1,798.1,25,1,0)
^.1
"^DD",798.1,798.1,25,1,1,0)
798.1^AEP^MUMPS
"^DD",798.1,798.1,25,1,1,1)
S:X ^ROR(798.1,"AEP",DA)=""
"^DD",798.1,798.1,25,1,1,2)
K ^ROR(798.1,"AEP",DA)
"^DD",798.1,798.1,25,1,1,3)
Do not delete!
"^DD",798.1,798.1,25,1,1,"%D",0)
^^10^10^3020418^
"^DD",798.1,798.1,25,1,1,"%D",1,0)
This cross-reference controls the package event 
"^DD",798.1,798.1,25,1,1,"%D",2,0)
protocols.
"^DD",798.1,798.1,25,1,1,"%D",3,0)
 
"^DD",798.1,798.1,25,1,1,"%D",4,0)
If at least one registry has the ENABLE PROTOCOLS
"^DD",798.1,798.1,25,1,1,"%D",5,0)
field set to "YES", the ^ROR(798.1,"AEP") node
"^DD",798.1,798.1,25,1,1,"%D",6,0)
will be defined and the protocols will call the
"^DD",798.1,798.1,25,1,1,"%D",7,0)
processing routines.
"^DD",798.1,798.1,25,1,1,"%D",8,0)
 
"^DD",798.1,798.1,25,1,1,"%D",9,0)
Otherwise, they will run idle (unless they are 
"^DD",798.1,798.1,25,1,1,"%D",10,0)
disabled or unsubscribed manually).
"^DD",798.1,798.1,25,1,1,"DT")
3020418
"^DD",798.1,798.1,25,20,0)
^.3LA^1^1
"^DD",798.1,798.1,25,20,1,0)
PARAMETERS
"^DD",798.1,798.1,25,21,0)
^.001^13^13^3020816^^
"^DD",798.1,798.1,25,21,1,0)
If this field is set to "Yes", event protocols
"^DD",798.1,798.1,25,21,2,0)
will be used by the package to speed up the 
"^DD",798.1,798.1,25,21,3,0)
registry processing.
"^DD",798.1,798.1,25,21,4,0)
 
"^DD",798.1,798.1,25,21,5,0)
The protocols create references to patient events
"^DD",798.1,798.1,25,21,6,0)
in the ROR PENDING PATIENT file. Only those 
"^DD",798.1,798.1,25,21,7,0)
patients that have new references will be 
"^DD",798.1,798.1,25,21,8,0)
processed by the next registry update.
"^DD",798.1,798.1,25,21,9,0)
 
"^DD",798.1,798.1,25,21,10,0)
If several registries are updated at the same 
"^DD",798.1,798.1,25,21,11,0)
time and at least one of them has this field set 
"^DD",798.1,798.1,25,21,12,0)
to "Yes", all these registries will be processed 
"^DD",798.1,798.1,25,21,13,0)
using event references.
"^DD",798.1,798.1,25,23,0)
^.001^11^11^3020816^^
"^DD",798.1,798.1,25,23,1,0)
This field controls both the registry update engine 
"^DD",798.1,798.1,25,23,2,0)
and the event protocols.
"^DD",798.1,798.1,25,23,3,0)
 
"^DD",798.1,798.1,25,23,4,0)
If at least one of the defined registries enables the
"^DD",798.1,798.1,25,23,5,0)
protocols, they will process the events and create
"^DD",798.1,798.1,25,23,6,0)
references in the ROR PENDING PATIENT file (#798.3).
"^DD",798.1,798.1,25,23,7,0)
 
"^DD",798.1,798.1,25,23,8,0)
Otherwise, the protocols will be executed (if they are
"^DD",798.1,798.1,25,23,9,0)
not disabled or unsubscribed manually) but will not
"^DD",798.1,798.1,25,23,10,0)
call processing routines and will not create references
"^DD",798.1,798.1,25,23,11,0)
in the file #798.3.
"^DD",798.1,798.1,25,"DT")
3020418
"^DD",798.1,798.1,26,0)
EXCLUDE EMPLOYEES^SX^0:NO;1:YES;^0;10^Q:$$VAEDT^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,26,8.5)
@
"^DD",798.1,798.1,26,9)
@
"^DD",798.1,798.1,26,20,0)
^.3LA^1^1
"^DD",798.1,798.1,26,20,1,0)
DEFINITION
"^DD",798.1,798.1,26,21,0)
^.001^6^6^3020816^^^^
"^DD",798.1,798.1,26,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,26,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,26,21,3,0)
 
"^DD",798.1,798.1,26,21,4,0)
If this field is set to "Yes", patients who are
"^DD",798.1,798.1,26,21,5,0)
employees will not get processed by the registry
"^DD",798.1,798.1,26,21,6,0)
update or data extraction functions.
"^DD",798.1,798.1,26,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,26,"DT")
3020802
"^DD",798.1,798.1,27,0)
AVAILABLE REPORTS^FX^^27;E1,250^Q:$$VAEDT^RORDD(798.1,$G(DA))  K:$L(X)>250!($L(X)<1) X
"^DD",798.1,798.1,27,3)
Answer must be 1-250 characters in length.
"^DD",798.1,798.1,27,8.5)
@
"^DD",798.1,798.1,27,9)
@
"^DD",798.1,798.1,27,20,0)
^.3LA^1^1
"^DD",798.1,798.1,27,20,1,0)
DEFINITION
"^DD",798.1,798.1,27,21,0)
^^7^7^3030429^
"^DD",798.1,798.1,27,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.1,798.1,27,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,27,21,3,0)
 
"^DD",798.1,798.1,27,21,4,0)
The AVAILABLE REPORTS field stores a list of 
"^DD",798.1,798.1,27,21,5,0)
report codes (not the IEN's!) separated by commas.
"^DD",798.1,798.1,27,21,6,0)
These reports will be available for this registry
"^DD",798.1,798.1,27,21,7,0)
in the GUI.
"^DD",798.1,798.1,27,23,0)
^.001^5^5^3030429^^^
"^DD",798.1,798.1,27,23,1,0)
The GUI loads the value of this field using the ROR 
"^DD",798.1,798.1,27,23,2,0)
REPORTS AVAILABLE remote procedure.
"^DD",798.1,798.1,27,23,3,0)
 
"^DD",798.1,798.1,27,23,4,0)
See the data dictionary of the ROR REPORT PARAMETERS 
"^DD",798.1,798.1,27,23,5,0)
file (#799.12) for more details.
"^DD",798.1,798.1,27,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,27,"DT")
3030417
"^DD",798.1,798.1,28,0)
LOCAL TEST NAME^798.128PI^^28;0
"^DD",798.1,798.1,28,"DT")
3030402
"^DD",798.1,798.1,29,0)
LOCAL DRUG NAME^798.129P^^29;0
"^DD",798.1,798.1,29,20,0)
^.3LA^1^1
"^DD",798.1,798.1,29,20,1,0)
PARAMETERS
"^DD",798.1,798.11,0)
LOG EVENTS SUB-FIELD^^.01^1
"^DD",798.1,798.11,0,"DT")
3010712
"^DD",798.1,798.11,0,"IX","B",798.11,.01)

"^DD",798.1,798.11,0,"NM","LOG EVENTS")

"^DD",798.1,798.11,0,"UP")
798.1
"^DD",798.1,798.11,.01,0)
LOG EVENT TYPE^MS^1:Debug;2:Information;3:Data Quality;4:Warning;5:Database Error;6:Error;^0;1^Q
"^DD",798.1,798.11,.01,1,0)
^.1
"^DD",798.1,798.11,.01,1,1,0)
798.11^B
"^DD",798.1,798.11,.01,1,1,1)
S ^ROR(798.1,DA(1),3,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.11,.01,1,1,2)
K ^ROR(798.1,DA(1),3,"B",$E(X,1,30),DA)
"^DD",798.1,798.11,.01,1,1,3)
Do not delete!
"^DD",798.1,798.11,.01,21,0)
^^10^10^3020403^
"^DD",798.1,798.11,.01,21,1,0)
Select the type of the event if you want to enable
"^DD",798.1,798.11,.01,21,2,0)
recording of these events. If the list is empty,
"^DD",798.1,798.11,.01,21,3,0)
recording of all events is enabled. Otherwise,
"^DD",798.1,798.11,.01,21,4,0)
only events from the list and error messages will 
"^DD",798.1,798.11,.01,21,5,0)
be recorded.
"^DD",798.1,798.11,.01,21,6,0)
 
"^DD",798.1,798.11,.01,21,7,0)
Debug messages are exclusions from this rule (they
"^DD",798.1,798.11,.01,21,8,0)
are not logged if the ENABLE LOG field is set to
"^DD",798.1,798.11,.01,21,9,0)
"Yes" and this multiple is empty). Their recording
"^DD",798.1,798.11,.01,21,10,0)
can be enabled only explicitly.
"^DD",798.1,798.11,.01,23,0)
^^9^9^3020403^
"^DD",798.1,798.11,.01,23,1,0)
If several registries are processed at the same time,
"^DD",798.1,798.11,.01,23,2,0)
the recording parameters are combined.
"^DD",798.1,798.11,.01,23,3,0)
 
"^DD",798.1,798.11,.01,23,4,0)
If one of the registries requests recording of all 
"^DD",798.1,798.11,.01,23,5,0)
events, all events except the debug messages (type 1)
"^DD",798.1,798.11,.01,23,6,0)
will be recorded for all registries.
"^DD",798.1,798.11,.01,23,7,0)
 
"^DD",798.1,798.11,.01,23,8,0)
Otherwise, merged content of the LOG EVENT TYPE
"^DD",798.1,798.11,.01,23,9,0)
multiples will determine the events to be recorded.
"^DD",798.1,798.11,.01,"DT")
3010712
"^DD",798.1,798.112,0)
EXTRACTED RESULT SUB-FIELD^^.03^3
"^DD",798.1,798.112,0,"DT")
3030318
"^DD",798.1,798.112,0,"ID","WRITE")
D EN^DDIOL($P(^(0),U,2),"","?20")
"^DD",798.1,798.112,0,"IX","B",798.112,.01)

"^DD",798.1,798.112,0,"IX","C",798.112,.02)

"^DD",798.1,798.112,0,"NM","EXTRACTED RESULT")

"^DD",798.1,798.112,0,"UP")
798.1
"^DD",798.1,798.112,.01,0)
LOINC CODE^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:X'?1(1.7N,1"*") X
"^DD",798.1,798.112,.01,1,0)
^.1
"^DD",798.1,798.112,.01,1,1,0)
798.112^B
"^DD",798.1,798.112,.01,1,1,1)
S ^ROR(798.1,DA(1),8,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.112,.01,1,1,2)
K ^ROR(798.1,DA(1),8,"B",$E(X,1,30),DA)
"^DD",798.1,798.112,.01,1,1,3)
Do not delete!
"^DD",798.1,798.112,.01,1,1,"DT")
3010716
"^DD",798.1,798.112,.01,3)
Answer must be 1-7 characters in length.
"^DD",798.1,798.112,.01,8.5)
@
"^DD",798.1,798.112,.01,9)
@
"^DD",798.1,798.112,.01,21,0)
^^11^11^3011015^
"^DD",798.1,798.112,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.112,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.112,.01,21,3,0)
 
"^DD",798.1,798.112,.01,21,4,0)
Enter the unique numeric LOINC code (without the
"^DD",798.1,798.112,.01,21,5,0)
check digit) of the Lab result to be extracted. If
"^DD",798.1,798.112,.01,21,6,0)
you want to use only NLT code, enter zero as the
"^DD",798.1,798.112,.01,21,7,0)
value of this field.
"^DD",798.1,798.112,.01,21,8,0)
 
"^DD",798.1,798.112,.01,21,9,0)
If you want to extract all results, create a
"^DD",798.1,798.112,.01,21,10,0)
record in this multiple containing the "*" 
"^DD",798.1,798.112,.01,21,11,0)
character in this field.
"^DD",798.1,798.112,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.112,.01,"DT")
3010716
"^DD",798.1,798.112,.02,0)
NLT CODE^FX^^0;2^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:'(X?5N1"."4.5N) X
"^DD",798.1,798.112,.02,1,0)
^.1
"^DD",798.1,798.112,.02,1,1,0)
798.112^C
"^DD",798.1,798.112,.02,1,1,1)
S ^ROR(798.1,DA(1),8,"C",$E(X,1,30),DA)=""
"^DD",798.1,798.112,.02,1,1,2)
K ^ROR(798.1,DA(1),8,"C",$E(X,1,30),DA)
"^DD",798.1,798.112,.02,1,1,3)
Do not delete!
"^DD",798.1,798.112,.02,1,1,"DT")
3010716
"^DD",798.1,798.112,.02,3)
Answer must be 10-11 characters in length.
"^DD",798.1,798.112,.02,8.5)
@
"^DD",798.1,798.112,.02,9)
@
"^DD",798.1,798.112,.02,21,0)
^^8^8^3011015^
"^DD",798.1,798.112,.02,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.112,.02,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.112,.02,21,3,0)
 
"^DD",798.1,798.112,.02,21,4,0)
Enter the unique NLT code of the Lab result to be
"^DD",798.1,798.112,.02,21,5,0)
extracted. Both LOINC and NLT codes (if available)
"^DD",798.1,798.112,.02,21,6,0)
are used for searching the Lab results. If you 
"^DD",798.1,798.112,.02,21,7,0)
want to use only the LOINC code, leave this field 
"^DD",798.1,798.112,.02,21,8,0)
empty.
"^DD",798.1,798.112,.02,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.112,.02,"DT")
3010716
"^DD",798.1,798.112,.03,0)
SUBSCRIPTS^FX^^0;3^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:$L(X)>30!($L(X)<2) X
"^DD",798.1,798.112,.03,3)
Answer must be 2-30 characters in length.
"^DD",798.1,798.112,.03,8.5)
@
"^DD",798.1,798.112,.03,9)
@
"^DD",798.1,798.112,.03,21,0)
^^14^14^3030318^
"^DD",798.1,798.112,.03,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.112,.03,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.112,.03,21,3,0)
 
"^DD",798.1,798.112,.03,21,4,0)
Enter a list of the subscripts separated by commas
"^DD",798.1,798.112,.03,21,5,0)
(CH, MI, etc.) from where the results should be
"^DD",798.1,798.112,.03,21,6,0)
loaded by the $$GCPR^LA7QRY function. Only these
"^DD",798.1,798.112,.03,21,7,0)
subscripts will be searched for new data.
"^DD",798.1,798.112,.03,21,8,0)
 
"^DD",798.1,798.112,.03,21,9,0)
NOTE: The value of the field affects the data
"^DD",798.1,798.112,.03,21,10,0)
extraction only if the LOINC CODE field is equal
"^DD",798.1,798.112,.03,21,11,0)
to "*".
"^DD",798.1,798.112,.03,21,12,0)
 
"^DD",798.1,798.112,.03,21,13,0)
If this field is empty (by default), the API 
"^DD",798.1,798.112,.03,21,14,0)
searches through all supported subscripts.
"^DD",798.1,798.112,.03,"DT")
3030318
"^DD",798.1,798.114,0)
COORDINATOR SUB-FIELD^^.01^1
"^DD",798.1,798.114,0,"DT")
3010907
"^DD",798.1,798.114,0,"IX","B",798.114,.01)

"^DD",798.1,798.114,0,"NM","COORDINATOR")

"^DD",798.1,798.114,0,"UP")
798.1
"^DD",798.1,798.114,.01,0)
COORDINATOR^MP200'X^VA(200,^0;1^S:$D(X) DINUM=X
"^DD",798.1,798.114,.01,1,0)
^.1
"^DD",798.1,798.114,.01,1,1,0)
798.114^B
"^DD",798.1,798.114,.01,1,1,1)
S ^ROR(798.1,DA(1),10,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.114,.01,1,1,2)
K ^ROR(798.1,DA(1),10,"B",$E(X,1,30),DA)
"^DD",798.1,798.114,.01,1,1,3)
Do not delete!
"^DD",798.1,798.114,.01,21,0)
^^4^4^3020403^
"^DD",798.1,798.114,.01,21,1,0)
Select the registry coordinator or add a new one
"^DD",798.1,798.114,.01,21,2,0)
from the NEW PERSON file. People defined as 
"^DD",798.1,798.114,.01,21,3,0)
registry coordinators will be receiving alerts 
"^DD",798.1,798.114,.01,21,4,0)
regarding problems with the registry processes.
"^DD",798.1,798.114,.01,"DT")
3010907
"^DD",798.1,798.116,0)
USER SUB-FIELD^^2^3
"^DD",798.1,798.116,0,"DT")
3020426
"^DD",798.1,798.116,0,"IX","B",798.116,.01)

"^DD",798.1,798.116,0,"NM","USER")

"^DD",798.1,798.116,0,"UP")
798.1
"^DD",798.1,798.116,.01,0)
USER^NJ10,0X^^0;1^S X=X
"^DD",798.1,798.116,.01,1,0)
^.1
"^DD",798.1,798.116,.01,1,1,0)
798.116^B
"^DD",798.1,798.116,.01,1,1,1)
S ^ROR(798.1,DA(1),13,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.116,.01,1,1,2)
K ^ROR(798.1,DA(1),13,"B",$E(X,1,30),DA)
"^DD",798.1,798.116,.01,3)
Type a Number between 1 and 9999999999, 0 Decimal Digits
"^DD",798.1,798.116,.01,"DT")
3020426
"^DD",798.1,798.116,1,0)
RPC HANDLE^F^^0;2^K:$L(X)>30!($L(X)<1) X
"^DD",798.1,798.116,1,3)
Answer must be 1-30 characters in length.
"^DD",798.1,798.116,1,21,0)
^.001^2^2^3020426^^^
"^DD",798.1,798.116,1,21,1,0)
This field holds a reference to the last deferred remote procedure that
"^DD",798.1,798.116,1,21,2,0)
created a drug report.
"^DD",798.1,798.116,1,23,0)
^.001^4^4^3020426^^
"^DD",798.1,798.116,1,23,1,0)
This field should not be set manually. It holds a free-text handle to
"^DD",798.1,798.116,1,23,2,0)
identify the last deferred remote procedure that was scheduled.  It is 
"^DD",798.1,798.116,1,23,3,0)
used by the GUI to fetch the drug report created by the deferred remote 
"^DD",798.1,798.116,1,23,4,0)
procedure.  See the EN2^RORRP9 procedure for details.
"^DD",798.1,798.116,1,"DT")
3020426
"^DD",798.1,798.116,2,0)
RPC HANDLE 2^F^^0;3^K:$L(X)>30!($L(X)<1) X
"^DD",798.1,798.116,2,3)
Answer must be 1-30 characters in length.
"^DD",798.1,798.116,2,21,0)
^^2^2^3020426^
"^DD",798.1,798.116,2,21,1,0)
This field holds a reference to the last deferred remote procedure that
"^DD",798.1,798.116,2,21,2,0)
created a Hepatitis C Local Registry report.
"^DD",798.1,798.116,2,23,0)
^^1^1^3020426^
"^DD",798.1,798.116,2,23,1,0)
See the EN2^RORRP9 procedure for details.
"^DD",798.1,798.116,2,"DT")
3020426
"^DD",798.1,798.117,0)
DRUG THERAPY LIST SUB-FIELD^^.01^1
"^DD",798.1,798.117,0,"DT")
3011112
"^DD",798.1,798.117,0,"IX","B",798.117,.01)

"^DD",798.1,798.117,0,"NM","DRUG THERAPY LIST")

"^DD",798.1,798.117,0,"UP")
798.1
"^DD",798.1,798.117,.01,0)
NDC^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:'(X?12N) X
"^DD",798.1,798.117,.01,1,0)
^.1
"^DD",798.1,798.117,.01,1,1,0)
798.117^B
"^DD",798.1,798.117,.01,1,1,1)
S ^ROR(798.1,DA(1),12,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.117,.01,1,1,2)
K ^ROR(798.1,DA(1),12,"B",$E(X,1,30),DA)
"^DD",798.1,798.117,.01,1,1,3)
Do not delete!
"^DD",798.1,798.117,.01,3)
Answer must be 12 characters in length.
"^DD",798.1,798.117,.01,21,0)
^.001^2^2^3020122^^^
"^DD",798.1,798.117,.01,21,1,0)
National Drug Code to include in Drug Therapy 
"^DD",798.1,798.117,.01,21,2,0)
Report.
"^DD",798.1,798.117,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.117,.01,"DT")
3011112
"^DD",798.1,798.118,0)
SECURITY KEY SUB-FIELD^^.01^1
"^DD",798.1,798.118,0,"DT")
3020801
"^DD",798.1,798.118,0,"IX","B",798.118,.01)

"^DD",798.1,798.118,0,"NM","SECURITY KEY")

"^DD",798.1,798.118,0,"UP")
798.1
"^DD",798.1,798.118,.01,0)
SECURITY KEY^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:$L(X)>27!($L(X)<3) X
"^DD",798.1,798.118,.01,1,0)
^.1
"^DD",798.1,798.118,.01,1,1,0)
798.118^B
"^DD",798.1,798.118,.01,1,1,1)
S ^ROR(798.1,DA(1),18,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.118,.01,1,1,2)
K ^ROR(798.1,DA(1),18,"B",$E(X,1,30),DA)
"^DD",798.1,798.118,.01,1,1,3)
Do not delete!
"^DD",798.1,798.118,.01,1,2,0)
798.1^ACL^MUMPS
"^DD",798.1,798.118,.01,1,2,1)
D ACLSET^RORDD
"^DD",798.1,798.118,.01,1,2,2)
D ACLKILL^RORDD
"^DD",798.1,798.118,.01,1,2,3)
Do not delete!
"^DD",798.1,798.118,.01,1,2,"%D",0)
^^25^25^3030718^
"^DD",798.1,798.118,.01,1,2,"%D",1,0)
This cross-reference is used by the screening 
"^DD",798.1,798.118,.01,1,2,"%D",2,0)
logic (the "SCR" node) of some Clinical Case 
"^DD",798.1,798.118,.01,1,2,"%D",3,0)
Registries files to check whether a user is
"^DD",798.1,798.118,.01,1,2,"%D",4,0)
allowed to access the records or no.
"^DD",798.1,798.118,.01,1,2,"%D",5,0)
 
"^DD",798.1,798.118,.01,1,2,"%D",6,0)
The cross-reference contains two kinds of items:
"^DD",798.1,798.118,.01,1,2,"%D",7,0)
 
"^DD",798.1,798.118,.01,1,2,"%D",8,0)
  ^ROR(798.1,"ACL",RORDUZ,RegIEN,KEY,IEN) = ""
"^DD",798.1,798.118,.01,1,2,"%D",9,0)
  ^ROR(798.1,"ACL",RORDUZ,RegName,KEY,IEN) = ""
"^DD",798.1,798.118,.01,1,2,"%D",10,0)
 
"^DD",798.1,798.118,.01,1,2,"%D",11,0)
where RORDUZ is the value of the DUZ variable for
"^DD",798.1,798.118,.01,1,2,"%D",12,0)
the user who has access to one or more registries
"^DD",798.1,798.118,.01,1,2,"%D",13,0)
(according to the allocated security keys). RegIEN
"^DD",798.1,798.118,.01,1,2,"%D",14,0)
and RegName are the registry IEN and name. KEY is
"^DD",798.1,798.118,.01,1,2,"%D",15,0)
the name of security key and IEN is the internal
"^DD",798.1,798.118,.01,1,2,"%D",16,0)
entry number of the corresponding record of the
"^DD",798.1,798.118,.01,1,2,"%D",17,0)
SECURITY KEY multiple.
"^DD",798.1,798.118,.01,1,2,"%D",18,0)
 
"^DD",798.1,798.118,.01,1,2,"%D",19,0)
The cross-reference should be rebuilt after
"^DD",798.1,798.118,.01,1,2,"%D",20,0)
changes in the allocation of the security keys
"^DD",798.1,798.118,.01,1,2,"%D",21,0)
associated with any registry. Usually, this is
"^DD",798.1,798.118,.01,1,2,"%D",22,0)
done by the nightly task (the [ROR TASK] option).
"^DD",798.1,798.118,.01,1,2,"%D",23,0)
However, if you want the changes to be in effect
"^DD",798.1,798.118,.01,1,2,"%D",24,0)
immediately, you should rebuild this
"^DD",798.1,798.118,.01,1,2,"%D",25,0)
cross-reference manually.
"^DD",798.1,798.118,.01,1,2,"DT")
3020805
"^DD",798.1,798.118,.01,3)
Enter a name of security key (3-27 characters in length).
"^DD",798.1,798.118,.01,8.5)
@
"^DD",798.1,798.118,.01,9)
@
"^DD",798.1,798.118,.01,20,0)
^.3LA^^0
"^DD",798.1,798.118,.01,21,0)
^.001^5^5^3020816^^^
"^DD",798.1,798.118,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.118,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.118,.01,21,3,0)
 
"^DD",798.1,798.118,.01,21,4,0)
The SECURITY KEY field contains the name of the 
"^DD",798.1,798.118,.01,21,5,0)
security key associated with the registry.
"^DD",798.1,798.118,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.118,.01,"DT")
3020805
"^DD",798.1,798.128,0)
LOCAL TEST NAME SUB-FIELD^^.02^2
"^DD",798.1,798.128,0,"DT")
3030402
"^DD",798.1,798.128,0,"ID","WRITE")
S %I=Y,Y=+$P($G(^(0)),U,2),Y=$S(Y>0:$P($G(^ROR(799.1,Y,0)),U),1:"") D EN^DDIOL("   "_Y,,"?40") S Y=%I K %I
"^DD",798.1,798.128,0,"IX","B",798.128,.01)

"^DD",798.1,798.128,0,"NM","LOCAL TEST NAME")

"^DD",798.1,798.128,0,"UP")
798.1
"^DD",798.1,798.128,.01,0)
LOCAL TEST NAME^MP60'^LAB(60,^0;1^Q
"^DD",798.1,798.128,.01,1,0)
^.1
"^DD",798.1,798.128,.01,1,1,0)
798.128^B
"^DD",798.1,798.128,.01,1,1,1)
S ^ROR(798.1,DA(1),28,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.128,.01,1,1,2)
K ^ROR(798.1,DA(1),28,"B",$E(X,1,30),DA)
"^DD",798.1,798.128,.01,"DT")
3030706
"^DD",798.1,798.128,.02,0)
LAB GROUP^R*P799.1'X^ROR(799.1,^0;2^S DIC("S")="S D=$G(^(0)) I $P(D,U,2)=3,$P(D,U,3)="_DA(1) D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",798.1,798.128,.02,1,0)
^.1^^0
"^DD",798.1,798.128,.02,12)
Only Lab Groups can be selected.
"^DD",798.1,798.128,.02,12.1)
S DIC("S")="I $P(^(0),U,2)=3"
"^DD",798.1,798.128,.02,"DT")
3030706
"^DD",798.1,798.129,0)
LOCAL DRUG NAME SUB-FIELD^^.02^2
"^DD",798.1,798.129,0,"DT")
3030625
"^DD",798.1,798.129,0,"IX","B",798.129,.01)

"^DD",798.1,798.129,0,"NM","LOCAL DRUG NAME")

"^DD",798.1,798.129,0,"UP")
798.1
"^DD",798.1,798.129,.01,0)
LOCAL DRUG NAME^MP50'^PSDRUG(^0;1^Q
"^DD",798.1,798.129,.01,1,0)
^.1
"^DD",798.1,798.129,.01,1,1,0)
798.129^B
"^DD",798.1,798.129,.01,1,1,1)
S ^ROR(798.1,DA(1),29,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.129,.01,1,1,2)
K ^ROR(798.1,DA(1),29,"B",$E(X,1,30),DA)
"^DD",798.1,798.129,.01,20,0)
^.3LA^^0
"^DD",798.1,798.129,.01,"DT")
3030706
"^DD",798.1,798.129,.02,0)
DRUG GROUP^R*P799.1'X^ROR(799.1,^0;2^S DIC("S")="S D=$G(^(0)) I $P(D,U,2)=4,$P(D,U,3)="_DA(1) D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",798.1,798.129,.02,12)
Only Drug Groups can be selected.
"^DD",798.1,798.129,.02,12.1)
S DIC("S")="I $P(^(0),U,2)=4"
"^DD",798.1,798.129,.02,20,0)
^.3LA^^0
"^DD",798.1,798.129,.02,"DT")
3030706
"^DD",798.1,798.13,0)
SELECTION RULE SUB-FIELD^^.01^1
"^DD",798.1,798.13,0,"DT")
3000410
"^DD",798.1,798.13,0,"NM","SELECTION RULE")

"^DD",798.1,798.13,0,"UP")
798.1
"^DD",798.1,798.13,.01,0)
SELECTION RULE^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:$L(X)>30!($L(X)<3)!'(X?3.UNP) X I $D(X) K:'$D(^ROR(798.2,"B",$E(X,1,30))) X
"^DD",798.1,798.13,.01,1,0)
^.1^^-1
"^DD",798.1,798.13,.01,1,2,0)
798.1^ARULES
"^DD",798.1,798.13,.01,1,2,1)
S ^ROR(798.1,"ARULES",$E(X,1,30),DA(1),DA)=""
"^DD",798.1,798.13,.01,1,2,2)
K ^ROR(798.1,"ARULES",$E(X,1,30),DA(1),DA)
"^DD",798.1,798.13,.01,1,2,3)
Do not delete!
"^DD",798.1,798.13,.01,1,2,"%D",0)
^^2^2^3011015^
"^DD",798.1,798.13,.01,1,2,"%D",1,0)
This cross-reference can be used to find all 
"^DD",798.1,798.13,.01,1,2,"%D",2,0)
registries that use the selection rule.
"^DD",798.1,798.13,.01,1,2,"DT")
3000406
"^DD",798.1,798.13,.01,3)
Enter a name of the selection rule (3-30 characters).
"^DD",798.1,798.13,.01,4)
I $G(X)="?" N D,DIC,DZ S DIC="^ROR(798.2,",DIC(0)="",D="B",DZ="??" D DQ^DICQ,EN^DDIOL("",,"!")
"^DD",798.1,798.13,.01,8.5)
@
"^DD",798.1,798.13,.01,9)
@
"^DD",798.1,798.13,.01,21,0)
^.001^8^8^3020403^^^
"^DD",798.1,798.13,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.13,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.13,.01,21,3,0)
 
"^DD",798.1,798.13,.01,21,4,0)
Enter a name of the selection rule that will be 
"^DD",798.1,798.13,.01,21,5,0)
used to select patients for addition to the
"^DD",798.1,798.13,.01,21,6,0)
registry. The name should be entered exactly as it
"^DD",798.1,798.13,.01,21,7,0)
appears in the list of selection rules (file 
"^DD",798.1,798.13,.01,21,8,0)
#798.2).
"^DD",798.1,798.13,.01,23,0)
^.001^3^3^3020403^^^
"^DD",798.1,798.13,.01,23,1,0)
Names of the selection rules are used here instead of 
"^DD",798.1,798.13,.01,23,2,0)
pointers because the KIDS pointer resolving feature 
"^DD",798.1,798.13,.01,23,3,0)
does not work for .01 fields.
"^DD",798.1,798.13,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.13,.01,"DT")
3011109
"^DD",798.1,798.15,0)
DESCRIPTION SUB-FIELD^^.01^1
"^DD",798.1,798.15,0,"NM","DESCRIPTION")

"^DD",798.1,798.15,0,"UP")
798.1
"^DD",798.1,798.15,.01,0)
DESCRIPTION^W^^0;1^Q
"^DD",798.1,798.15,.01,"DT")
3000313
"^DD",798.1,798.19,0)
HL7 SEGMENT SUB-FIELD^^1^3
"^DD",798.1,798.19,0,"DT")
3030606
"^DD",798.1,798.19,0,"IX","B",798.19,.01)

"^DD",798.1,798.19,0,"NM","HL7 SEGMENT")

"^DD",798.1,798.19,0,"UP")
798.1
"^DD",798.1,798.19,.01,0)
HL7 SEGMENT^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:'(X?3UN) X
"^DD",798.1,798.19,.01,1,0)
^.1
"^DD",798.1,798.19,.01,1,1,0)
798.19^B
"^DD",798.1,798.19,.01,1,1,1)
S ^ROR(798.1,DA(1),6,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.19,.01,1,1,2)
K ^ROR(798.1,DA(1),6,"B",$E(X,1,30),DA)
"^DD",798.1,798.19,.01,1,1,3)
Do not delete!
"^DD",798.1,798.19,.01,3)
Enter a name of the HL7 segment (3 characters).
"^DD",798.1,798.19,.01,21,0)
^.001^9^9^3021113^^^^
"^DD",798.1,798.19,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.19,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.19,.01,21,3,0)
 
"^DD",798.1,798.19,.01,21,4,0)
Enter a name of the HL7 segment that should be 
"^DD",798.1,798.19,.01,21,5,0)
included in the message sent to AAC. The general 
"^DD",798.1,798.19,.01,21,6,0)
structure of the registry HL7 message is hard 
"^DD",798.1,798.19,.01,21,7,0)
coded in the message builder routine. Therefore, 
"^DD",798.1,798.19,.01,21,8,0)
the segments that are not generated by the builder
"^DD",798.1,798.19,.01,21,9,0)
will be ignored if added to this multiple.
"^DD",798.1,798.19,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.19,.01,"DT")
3011015
"^DD",798.1,798.19,.02,0)
DATA AREA^RP799.33'X^ROR(799.33,^0;3^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.19,.02,3)

"^DD",798.1,798.19,.02,8.5)
@
"^DD",798.1,798.19,.02,9)
@
"^DD",798.1,798.19,.02,21,0)
^.001^6^6^3030606^^^^
"^DD",798.1,798.19,.02,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.19,.02,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.19,.02,21,3,0)
 
"^DD",798.1,798.19,.02,21,4,0)
The same HL7 segments can be used in different 
"^DD",798.1,798.19,.02,21,5,0)
contexts to store different data. The data area
"^DD",798.1,798.19,.02,21,6,0)
code is used to distinguish between them.
"^DD",798.1,798.19,.02,"DT")
3030606
"^DD",798.1,798.19,1,0)
FIELDS^FX^^1;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:$L(X)>200!($L(X)<1) X
"^DD",798.1,798.19,1,3)
Enter a list of HL7 field numbers separated by commas (1-200 characters).
"^DD",798.1,798.19,1,8.5)
@
"^DD",798.1,798.19,1,9)
@
"^DD",798.1,798.19,1,21,0)
^.001^11^11^3011121^^^
"^DD",798.1,798.19,1,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.19,1,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.19,1,21,3,0)
 
"^DD",798.1,798.19,1,21,4,0)
The values of the segment fields listed here 
"^DD",798.1,798.19,1,21,5,0)
(field numbers should be separated by commas) will
"^DD",798.1,798.19,1,21,6,0)
be extracted and sent to AAC. If this field is 
"^DD",798.1,798.19,1,21,7,0)
empty, the values of all fields will be sent.
"^DD",798.1,798.19,1,21,8,0)
 
"^DD",798.1,798.19,1,21,9,0)
Some existing VistA APIs do not support this 
"^DD",798.1,798.19,1,21,10,0)
feature. So, sometimes the value of this field may
"^DD",798.1,798.19,1,21,11,0)
be ignored and all values will be sent instead.
"^DD",798.1,798.19,1,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.19,1,"DT")
3010622
"^DD",798.2,798.2,0)
FIELD^^6^7
"^DD",798.2,798.2,0,"DDA")
N
"^DD",798.2,798.2,0,"DT")
3020326
"^DD",798.2,798.2,0,"ID","WRITE")
D EN^DDIOL("  "_$P($G(^(0)),U,3),,"?30")
"^DD",798.2,798.2,0,"NM","ROR SELECTION RULE")

"^DD",798.2,798.2,0,"PT",798.01,.01)

"^DD",798.2,798.2,0,"VRPK")
ROR
"^DD",798.2,798.2,.01,0)
RULE NAME^FX^^0;1^Q:$$VAEDT^RORDD(798.2,$G(DA))  K:$L(X)>30!($L(X)<3)!'(X?1.UNP) X
"^DD",798.2,798.2,.01,1,0)
^.1^^0
"^DD",798.2,798.2,.01,3)
Enter a unique namespaced rule name (3-30 characters).
"^DD",798.2,798.2,.01,8.5)
@
"^DD",798.2,798.2,.01,9)
@
"^DD",798.2,798.2,.01,21,0)
^.001^6^6^3011010^^
"^DD",798.2,798.2,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.2,798.2,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.2,798.2,.01,21,3,0)
 
"^DD",798.2,798.2,.01,21,4,0)
Selection rule name must be unique and name 
"^DD",798.2,798.2,.01,21,5,0)
spaced. Names of the rules that are used for
"^DD",798.2,798.2,.01,21,6,0)
National Registries must start with "VA".
"^DD",798.2,798.2,.01,"DEL",1,0)
I $$VADEL^RORDD(798.2,$G(DA))
"^DD",798.2,798.2,.01,"DT")
3020314
"^DD",798.2,798.2,.09,0)
NATIONAL^SX^0:NO;1:YES;^0;4^Q:$$VAEDT^RORDD(798.2,,-1)
"^DD",798.2,798.2,.09,1,0)
^.1^^0
"^DD",798.2,798.2,.09,8.5)
@
"^DD",798.2,798.2,.09,9)
@
"^DD",798.2,798.2,.09,21,0)
^.001^6^6^3020403^^
"^DD",798.2,798.2,.09,21,1,0)
ONLY AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN
"^DD",798.2,798.2,.09,21,2,0)
EDIT THIS FIELD!
"^DD",798.2,798.2,.09,21,3,0)
 
"^DD",798.2,798.2,.09,21,4,0)
Selection rules of the national registries must
"^DD",798.2,798.2,.09,21,5,0)
have this field set to "Yes". This prevents local
"^DD",798.2,798.2,.09,21,6,0)
editing of other fields of rule definitions.
"^DD",798.2,798.2,.09,"DEL",1,0)
I $$VADEL^RORDD(798.2,,,-1)
"^DD",798.2,798.2,.09,"DT")
3011121
"^DD",798.2,798.2,1,0)
EXPRESSION^RFX^^1;E1,245^Q:$$VAEDT^RORDD(798.2,$G(DA))  K:$L(X)>250!($L(X)<1) X I $D(X) Q:$$EXPR^RORDD($P($G(^ROR(798.2,DA,0)),U,2))
"^DD",798.2,798.2,1,3)
Enter M expression that implements the selection rule (1-250 characters).
"^DD",798.2,798.2,1,8.5)
@
"^DD",798.2,798.2,1,9)
@
"^DD",798.2,798.2,1,21,0)
^^5^5^3011010^
"^DD",798.2,798.2,1,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.2,798.2,1,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.2,798.2,1,21,3,0)
 
"^DD",798.2,798.2,1,21,4,0)
Enter a MUMPS expression (it may contain special
"^DD",798.2,798.2,1,21,5,0)
macros) that implements the selection rule.
"^DD",798.2,798.2,1,23,0)
^^62^62^3020403^
"^DD",798.2,798.2,1,23,1,0)
MUMPS expression that implements the selection rule can
"^DD",798.2,798.2,1,23,2,0)
contain special macros:
"^DD",798.2,798.2,1,23,3,0)
 
"^DD",798.2,798.2,1,23,4,0)
 {E: Field Name} - External value of the field
"^DD",798.2,798.2,1,23,5,0)
 {E: Field Number}
"^DD",798.2,798.2,1,23,6,0)
 
"^DD",798.2,798.2,1,23,7,0)
 {I: Field Name} - Internal value of the field
"^DD",798.2,798.2,1,23,8,0)
 {I: Field Number}
"^DD",798.2,798.2,1,23,9,0)
 
"^DD",798.2,798.2,1,23,10,0)
 {Rule Name} - Result value of the lower level
"^DD",798.2,798.2,1,23,11,0)
selection rule
"^DD",798.2,798.2,1,23,12,0)
 
"^DD",798.2,798.2,1,23,13,0)
 {AVG: Rule Name} - Average value of the rule
"^DD",798.2,798.2,1,23,14,0)
 
"^DD",798.2,798.2,1,23,15,0)
 {CNT: Rule Name} - Number of calculations of the rule
"^DD",798.2,798.2,1,23,16,0)
 
"^DD",798.2,798.2,1,23,17,0)
 {MAX: Rule Name} - Maximum value of the rule
"^DD",798.2,798.2,1,23,18,0)
 
"^DD",798.2,798.2,1,23,19,0)
 {MIN: Rule Name} - Minimum value of the rule
"^DD",798.2,798.2,1,23,20,0)
 
"^DD",798.2,798.2,1,23,21,0)
 {SUM: Rule Name} - Total of the selection rule values
"^DD",798.2,798.2,1,23,22,0)
 
"^DD",798.2,798.2,1,23,23,0)
 {LS: Lab Search Name} - This macro can be used only in
"^DD",798.2,798.2,1,23,24,0)
the selection rules associated with the LAB DATA file
"^DD",798.2,798.2,1,23,25,0)
(#63). It is evaluated as 1 if some of the patient
"^DD",798.2,798.2,1,23,26,0)
lab results pass the Lab search criteria (from the file
"^DD",798.2,798.2,1,23,27,0)
#798.9). Otherwise, it is evaluated as zero.
"^DD",798.2,798.2,1,23,28,0)
 
"^DD",798.2,798.2,1,23,29,0)
Return values of the top-level rules:
"^DD",798.2,798.2,1,23,30,0)
 
"^DD",798.2,798.2,1,23,31,0)
 0        - Skip the patient
"^DD",798.2,798.2,1,23,32,0)
 Non-zero - Add the patient to the registry
"^DD",798.2,798.2,1,23,33,0)
 
"^DD",798.2,798.2,1,23,34,0)
Return values of the lower level rules:
"^DD",798.2,798.2,1,23,35,0)
 
"^DD",798.2,798.2,1,23,36,0)
Return values can be used in the expressions of the
"^DD",798.2,798.2,1,23,37,0)
other rules. Some additional values are calculated
"^DD",798.2,798.2,1,23,38,0)
automatically (minimum, maximum, average, etc) for each
"^DD",798.2,798.2,1,23,39,0)
rule.
"^DD",798.2,798.2,1,23,40,0)
 
"^DD",798.2,798.2,1,23,41,0)
Avoid circular references in the expressions. If a 
"^DD",798.2,798.2,1,23,42,0)
rule directly or indirectly depends on itself, it
"^DD",798.2,798.2,1,23,43,0)
cannot be evaluated. An example of the circular
"^DD",798.2,798.2,1,23,44,0)
reference:
"^DD",798.2,798.2,1,23,45,0)
 
"^DD",798.2,798.2,1,23,46,0)
 Rule A: {MAX:B}<10
"^DD",798.2,798.2,1,23,47,0)
 Rule B: {I:23}+{C}
"^DD",798.2,798.2,1,23,48,0)
 Rule C: {CNT:A}
"^DD",798.2,798.2,1,23,49,0)
 
"^DD",798.2,798.2,1,23,50,0)
The rule A cannot be evaluated because it depends on 
"^DD",798.2,798.2,1,23,51,0)
the rule B, which depends on rule C, and C depends on
"^DD",798.2,798.2,1,23,52,0)
A.
"^DD",798.2,798.2,1,23,53,0)
 
"^DD",798.2,798.2,1,23,54,0)
Complex selection rules could be implemented by 
"^DD",798.2,798.2,1,23,55,0)
external MUMPS functions. In that case the expression
"^DD",798.2,798.2,1,23,56,0)
should contains a full reference to the function
"^DD",798.2,798.2,1,23,57,0)
($$TAG^ROUTINE). Values of the necessary data elements
"^DD",798.2,798.2,1,23,58,0)
can be loaded automatically (see descriptiion of the
"^DD",798.2,798.2,1,23,59,0)
DATA ELEMENT multiple).
"^DD",798.2,798.2,1,23,60,0)
 
"^DD",798.2,798.2,1,23,61,0)
See the Programmer's reference manual for more details 
"^DD",798.2,798.2,1,23,62,0)
regarding the selection rule expressions.
"^DD",798.2,798.2,1,"DEL",1,0)
I $$VADEL^RORDD(798.2,$G(DA))
"^DD",798.2,798.2,1,"DT")
3011109
"^DD",798.2,798.2,2,0)
FILE^RNJ22,9X^^0;2^Q:$$VAEDT^RORDD(798.2,$G(DA))  K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."10N.N) X I $D(X) K:'$$VFILE^DILFD(X) X
"^DD",798.2,798.2,2,3)
Enter (sub)file number between 1 and 999999999999, 9 Decimal Digits.
"^DD",798.2,798.2,2,8.5)
@
"^DD",798.2,798.2,2,9)
@
"^DD",798.2,798.2,2,21,0)
^.001^6^6^3020403^^
"^DD",798.2,798.2,2,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.2,798.2,2,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.2,798.2,2,21,3,0)
 
"^DD",798.2,798.2,2,21,4,0)
Enter a file/sub-file number that the selection 
"^DD",798.2,798.2,2,21,5,0)
rule is associated with. Each selection rule can
"^DD",798.2,798.2,2,21,6,0)
be associated with only one file.
"^DD",798.2,798.2,2,"DEL",1,0)
I $$VADEL^RORDD(798.2,$G(DA))
"^DD",798.2,798.2,2,"DT")
3011109
"^DD",798.2,798.2,4,0)
SHORT DESCRIPTION^FX^^0;3^Q:$$VAEDT^RORDD(798.2,$G(DA))  K:$L(X)>30!($L(X)<3) X
"^DD",798.2,798.2,4,3)
Enter a short description of the selection rule (3-30 characters).
"^DD",798.2,798.2,4,8.5)
@
"^DD",798.2,798.2,4,9)
@
"^DD",798.2,798.2,4,21,0)
^^5^5^3020403^
"^DD",798.2,798.2,4,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.2,798.2,4,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.2,798.2,4,21,3,0)
 
"^DD",798.2,798.2,4,21,4,0)
The short description of the selection rule is 
"^DD",798.2,798.2,4,21,5,0)
used in the reports and GUI dialogs.
"^DD",798.2,798.2,4,"DEL",1,0)
I $$VADEL^RORDD(798.2,$G(DA))
"^DD",798.2,798.2,4,"DT")
3011109
"^DD",798.2,798.2,5,0)
DESCRIPTION^798.25^^3;0
"^DD",798.2,798.2,5,21,0)
^^3^3^3020403^
"^DD",798.2,798.2,5,21,1,0)
You can enter any additional reference information
"^DD",798.2,798.2,5,21,2,0)
related to the selection rule. The content of this
"^DD",798.2,798.2,5,21,3,0)
field is not used by the application.
"^DD",798.2,798.2,6,0)
DATA ELEMENT^798.26^^4;0
"^DD",798.2,798.2,6,9)
@
"^DD",798.2,798.2,6,21,0)
^^12^12^3020328^
"^DD",798.2,798.2,6,21,1,0)
The DATA ELEMENT multiple contains a list of 
"^DD",798.2,798.2,6,21,2,0)
additional data elements to load. 
"^DD",798.2,798.2,6,21,3,0)
 
"^DD",798.2,798.2,6,21,4,0)
Values of all the data elements referenced in the
"^DD",798.2,798.2,6,21,5,0)
selection rule expression are loaded
"^DD",798.2,798.2,6,21,6,0)
automatically.
"^DD",798.2,798.2,6,21,7,0)
 
"^DD",798.2,798.2,6,21,8,0)
However, if the rule is implemented by an external
"^DD",798.2,798.2,6,21,9,0)
function, you can enter codes of all necessary
"^DD",798.2,798.2,6,21,10,0)
data elements into this multiple. Their values
"^DD",798.2,798.2,6,21,11,0)
will be loaded automatically and will be
"^DD",798.2,798.2,6,21,12,0)
accessible in the function.
"^DD",798.2,798.2,6,"DT")
3020326
"^DD",798.2,798.25,0)
DESCRIPTION SUB-FIELD^^.01^1
"^DD",798.2,798.25,0,"NM","DESCRIPTION")

"^DD",798.2,798.25,0,"UP")
798.2
"^DD",798.2,798.25,.01,0)
DESCRIPTION^W^^0;1^Q
"^DD",798.2,798.25,.01,"DT")
3000313
"^DD",798.2,798.26,0)
DATA ELEMENT SUB-FIELD^^1^2
"^DD",798.2,798.26,0,"DT")
3020326
"^DD",798.2,798.26,0,"NM","DATA ELEMENT")

"^DD",798.2,798.26,0,"UP")
798.2
"^DD",798.2,798.26,.01,0)
ELEMENT CODE^MNJ9,0X^^0;1^Q:$$VAEDT^RORDD(798.2,$G(DA(1)))  K:+X'=X!(X>999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.2,798.26,.01,1,0)
^.1^^0
"^DD",798.2,798.26,.01,3)
Type a Number between 1 and 999999999, 0 Decimal Digits.
"^DD",798.2,798.26,.01,8.5)
@
"^DD",798.2,798.26,.01,9)
@
"^DD",798.2,798.26,.01,21,0)
^^8^8^3020328^
"^DD",798.2,798.26,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.2,798.26,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.2,798.26,.01,21,3,0)
 
"^DD",798.2,798.26,.01,21,4,0)
Enter the code of the data element that should be 
"^DD",798.2,798.26,.01,21,5,0)
loaded before evaluation of the expression. Values
"^DD",798.2,798.26,.01,21,6,0)
of all data elements referenced in the selection
"^DD",798.2,798.26,.01,21,7,0)
rule expression are loaded automatically (you do
"^DD",798.2,798.26,.01,21,8,0)
not need to enter them here).
"^DD",798.2,798.26,.01,"DEL",1,0)
I $$VADEL^RORDD(798.2,$G(DA(1)))
"^DD",798.2,798.26,.01,"DT")
3020326
"^DD",798.2,798.26,1,0)
VALUE TYPE^RSX^E:External;I:Internal;EI:Both;^0;2^Q:$$VAEDT^RORDD(798.2,$G(DA(1)))
"^DD",798.2,798.26,1,8.5)
@
"^DD",798.2,798.26,1,9)
@
"^DD",798.2,798.26,1,21,0)
^^3^3^3020328^
"^DD",798.2,798.26,1,21,1,0)
This field holds required value type(s) of the
"^DD",798.2,798.26,1,21,2,0)
data element. The type(s) must be supported by the
"^DD",798.2,798.26,1,21,3,0)
search engine.
"^DD",798.2,798.26,1,"DT")
3020311
"^DD",798.3,798.3,0)
FIELD^^2^3
"^DD",798.3,798.3,0,"DDA")
N
"^DD",798.3,798.3,0,"DT")
3030606
"^DD",798.3,798.3,0,"IX","AT",798.32,.01)

"^DD",798.3,798.3,0,"IX","B",798.3,.01)

"^DD",798.3,798.3,0,"NM","ROR PENDING PATIENT")

"^DD",798.3,798.3,0,"VRPK")
ROR
"^DD",798.3,798.3,.01,0)
PATIENT NAME^RP2'X^DPT(^0;1^S:$D(X) DINUM=X
"^DD",798.3,798.3,.01,1,0)
^.1
"^DD",798.3,798.3,.01,1,1,0)
798.3^B
"^DD",798.3,798.3,.01,1,1,1)
S ^RORDATA(798.3,"B",$E(X,1,30),DA)=""
"^DD",798.3,798.3,.01,1,1,2)
K ^RORDATA(798.3,"B",$E(X,1,30),DA)
"^DD",798.3,798.3,.01,1,1,3)
Do not delete!
"^DD",798.3,798.3,.01,3)

"^DD",798.3,798.3,.01,8.5)
@
"^DD",798.3,798.3,.01,9)
@
"^DD",798.3,798.3,.01,21,0)
^^2^2^3020424^
"^DD",798.3,798.3,.01,21,1,0)
The PATIENT NAME field identifies the patient. You
"^DD",798.3,798.3,.01,21,2,0)
can add a patient from the PATIENT file.
"^DD",798.3,798.3,.01,"DT")
3020415
"^DD",798.3,798.3,1,0)
ERROR^798.31P^^1;0
"^DD",798.3,798.3,1,9)
@
"^DD",798.3,798.3,1,21,0)
^^44^44^3020424^
"^DD",798.3,798.3,1,21,1,0)
This multiple stores references to those
"^DD",798.3,798.3,1,21,2,0)
registries that have the patient processed with
"^DD",798.3,798.3,1,21,3,0)
errors and has not been added to the registry.
"^DD",798.3,798.3,1,21,4,0)
     
"^DD",798.3,798.3,1,21,5,0)
When the problems are fixed, the data search must 
"^DD",798.3,798.3,1,21,6,0)
start not from the date of the previous run of the
"^DD",798.3,798.3,1,21,7,0)
registry update process but from the date that 
"^DD",798.3,798.3,1,21,8,0)
was used when the problem arose. Otherwise, the
"^DD",798.3,798.3,1,21,9,0)
data in the interval between those dates will not
"^DD",798.3,798.3,1,21,10,0)
be checked and some important information may be
"^DD",798.3,798.3,1,21,11,0)
missed.
"^DD",798.3,798.3,1,21,12,0)
     
"^DD",798.3,798.3,1,21,13,0)
This date cannot be stored in the registry file 
"^DD",798.3,798.3,1,21,14,0)
(#798) because the patient has not been added to
"^DD",798.3,798.3,1,21,15,0)
the registry yet. So, the date is stored in this
"^DD",798.3,798.3,1,21,16,0)
multiple.  
"^DD",798.3,798.3,1,21,17,0)
     
"^DD",798.3,798.3,1,21,18,0)
Before the registry update process begins 
"^DD",798.3,798.3,1,21,19,0)
searching the data of the patient, it tries to
"^DD",798.3,798.3,1,21,20,0)
find a record for that patient in this multiple.
"^DD",798.3,798.3,1,21,21,0)
If it exists, the date from the record is used in
"^DD",798.3,798.3,1,21,22,0)
the search instead of regular date (from the
"^DD",798.3,798.3,1,21,23,0)
REGISTRY UPDATED UNTIL field of the REGISTRY
"^DD",798.3,798.3,1,21,24,0)
PARAMETERS file.
"^DD",798.3,798.3,1,21,25,0)
     
"^DD",798.3,798.3,1,21,26,0)
After successfully processing the patient data 
"^DD",798.3,798.3,1,21,27,0)
the corresponding record is deleted from this
"^DD",798.3,798.3,1,21,28,0)
multiple.  
"^DD",798.3,798.3,1,21,29,0)
     
"^DD",798.3,798.3,1,21,30,0)
Records of the multiple are uniquely identified by
"^DD",798.3,798.3,1,21,31,0)
the registry IEN. The "A" primary key and the "B"
"^DD",798.3,798.3,1,21,32,0)
uniqueness index are used for this purpose.
"^DD",798.3,798.3,1,21,33,0)
 
"^DD",798.3,798.3,1,21,34,0)
Usually, records within this multiple should not
"^DD",798.3,798.3,1,21,35,0)
be edited. Its content is handled automatically by
"^DD",798.3,798.3,1,21,36,0)
entry points from the routine RORUPP01 during the
"^DD",798.3,798.3,1,21,37,0)
registry update.  
"^DD",798.3,798.3,1,21,38,0)
     
"^DD",798.3,798.3,1,21,39,0)
However, if the errors are not corrected in the 
"^DD",798.3,798.3,1,21,40,0)
predefined time frame (2 weeks at the moment),
"^DD",798.3,798.3,1,21,41,0)
patient data will not be analized by the 
"^DD",798.3,798.3,1,21,42,0)
subsequent registry updates until someone fixes 
"^DD",798.3,798.3,1,21,43,0)
the errors and resets the the COUNTER field of the
"^DD",798.3,798.3,1,21,44,0)
patient records in this multiple.  
"^DD",798.3,798.3,2,0)
EVENT^798.32D^^2;0
"^DD",798.3,798.3,2,9)
@
"^DD",798.3,798.3,2,21,0)
^^9^9^3020424^
"^DD",798.3,798.3,2,21,1,0)
This multiple stores event references created by
"^DD",798.3,798.3,2,21,2,0)
the event protocols. The registry update uses
"^DD",798.3,798.3,2,21,3,0)
these references to speed up the processing.
"^DD",798.3,798.3,2,21,4,0)
 
"^DD",798.3,798.3,2,21,5,0)
The event references are grouped by the data areas
"^DD",798.3,798.3,2,21,6,0)
(protocols) and only one reference per associated 
"^DD",798.3,798.3,2,21,7,0)
date (the DATE field) for each data area is stored
"^DD",798.3,798.3,2,21,8,0)
at the moment. The "AD" cross-reference is used by
"^DD",798.3,798.3,2,21,9,0)
the $$ADD^RORUPP02 function for this purpose.
"^DD",798.3,798.3,2,"DT")
3020415
"^DD",798.3,798.31,0)
ERROR SUB-FIELD^^2^3
"^DD",798.3,798.31,0,"DT")
3020415
"^DD",798.3,798.31,0,"IX","AD",798.31,1)

"^DD",798.3,798.31,0,"NM","ERROR")

"^DD",798.3,798.31,0,"UP")
798.3
"^DD",798.3,798.31,.01,0)
REGISTRY^MP798.1'IX^ROR(798.1,^0;1^Q
"^DD",798.3,798.31,.01,1,0)
^.1^^0
"^DD",798.3,798.31,.01,8.5)
@
"^DD",798.3,798.31,.01,9)
@
"^DD",798.3,798.31,.01,21,0)
^.001^2^2^3020415^^
"^DD",798.3,798.31,.01,21,1,0)
The REGISTRY field identifies the registry that 
"^DD",798.3,798.31,.01,21,2,0)
the record is associated with.
"^DD",798.3,798.31,.01,"DT")
3020415
"^DD",798.3,798.31,1,0)
DATE^RD^^0;2^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798.3,798.31,1,1,0)
^.1
"^DD",798.3,798.31,1,1,1,0)
798.31^AD
"^DD",798.3,798.31,1,1,1,1)
S ^RORDATA(798.3,DA(1),1,"AD",$E(X,1,30),DA)=""
"^DD",798.3,798.31,1,1,1,2)
K ^RORDATA(798.3,DA(1),1,"AD",$E(X,1,30),DA)
"^DD",798.3,798.31,1,1,1,3)
Do not delete!
"^DD",798.3,798.31,1,1,1,"DT")
3020415
"^DD",798.3,798.31,1,8.5)
@
"^DD",798.3,798.31,1,9)
@
"^DD",798.3,798.31,1,21,0)
^^5^5^3020424^
"^DD",798.3,798.31,1,21,1,0)
The field holds the date that was used as the 
"^DD",798.3,798.31,1,21,2,0)
start date of the data search when problems arose
"^DD",798.3,798.31,1,21,3,0)
during the processing of patient data. After the
"^DD",798.3,798.31,1,21,4,0)
problems are fixed, the next data search will
"^DD",798.3,798.31,1,21,5,0)
start from this date (minus lag days).
"^DD",798.3,798.31,1,23,0)
^.001^4^4^3020424^^^
"^DD",798.3,798.31,1,23,1,0)
The value of this field is used instead of the regular
"^DD",798.3,798.31,1,23,2,0)
start date from the REGISTRY UPDATED UNTIL field of the
"^DD",798.3,798.31,1,23,3,0)
REGISTRY PARAMETERS file during the search for patient
"^DD",798.3,798.31,1,23,4,0)
data.
"^DD",798.3,798.31,1,"DT")
3020415
"^DD",798.3,798.31,2,0)
COUNTER^NJ2,0^^0;3^K:+X'=X!(X>99)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.3,798.31,2,3)
Type a Number between 1 and 99, 0 Decimal Digits
"^DD",798.3,798.31,2,21,0)
^^10^10^3020424^
"^DD",798.3,798.31,2,21,1,0)
When a patient is added to the ROR PENDING PATIENT
"^DD",798.3,798.31,2,21,2,0)
file (due to errors during the registry update),
"^DD",798.3,798.31,2,21,3,0)
this field is populated with 1.
"^DD",798.3,798.31,2,21,4,0)
 
"^DD",798.3,798.31,2,21,5,0)
Until someone fixes the error(s), every subsequent
"^DD",798.3,798.31,2,21,6,0)
registry update will increment a value of this 
"^DD",798.3,798.31,2,21,7,0)
field by 1. When it reaches a predefined threshold
"^DD",798.3,798.31,2,21,8,0)
value, the registry updates will skip this patient
"^DD",798.3,798.31,2,21,9,0)
until someone fixes the error(s) and resets this
"^DD",798.3,798.31,2,21,10,0)
field to 1.
"^DD",798.3,798.31,2,23,0)
^^10^10^3020424^
"^DD",798.3,798.31,2,23,1,0)
The $$ADD^RORUPP01 function initializes this field with
"^DD",798.3,798.31,2,23,2,0)
1 when the record is created. Then it increments its
"^DD",798.3,798.31,2,23,3,0)
value each time when the record is updated until the
"^DD",798.3,798.31,2,23,4,0)
field value become not less than a value of the local
"^DD",798.3,798.31,2,23,5,0)
RORUPD(MAXPPCNT") node (or 14 by default).
"^DD",798.3,798.31,2,23,6,0)
 
"^DD",798.3,798.31,2,23,7,0)
The function $$SDSDATE^RORUPP01 analizes the value of
"^DD",798.3,798.31,2,23,8,0)
the field and returns an error if the counters
"^DD",798.3,798.31,2,23,9,0)
associated with all processed registries have reached
"^DD",798.3,798.31,2,23,10,0)
the threshold.
"^DD",798.3,798.31,2,"DT")
3020415
"^DD",798.3,798.32,0)
EVENT SUB-FIELD^^2^3
"^DD",798.3,798.32,0,"DT")
3030606
"^DD",798.3,798.32,0,"IX","B",798.32,.01)

"^DD",798.3,798.32,0,"NM","EVENT")

"^DD",798.3,798.32,0,"UP")
798.3
"^DD",798.3,798.32,.01,0)
TIMESTAMP^MD^^0;1^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798.3,798.32,.01,1,0)
^.1
"^DD",798.3,798.32,.01,1,1,0)
798.32^B
"^DD",798.3,798.32,.01,1,1,1)
S ^RORDATA(798.3,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",798.3,798.32,.01,1,1,2)
K ^RORDATA(798.3,DA(1),2,"B",$E(X,1,30),DA)
"^DD",798.3,798.32,.01,1,1,3)
Do not delete!
"^DD",798.3,798.32,.01,1,2,0)
798.3^AT
"^DD",798.3,798.32,.01,1,2,1)
S ^RORDATA(798.3,"AT",$E(X,1,30),DA(1),DA)=""
"^DD",798.3,798.32,.01,1,2,2)
K ^RORDATA(798.3,"AT",$E(X,1,30),DA(1),DA)
"^DD",798.3,798.32,.01,1,2,3)
Do not delete!
"^DD",798.3,798.32,.01,1,2,"%D",0)
^^3^3^3020424^
"^DD",798.3,798.32,.01,1,2,"%D",1,0)
This cross-reference is used by the 
"^DD",798.3,798.32,.01,1,2,"%D",2,0)
$$PURGE^RORUPP02 function to purge the old event 
"^DD",798.3,798.32,.01,1,2,"%D",3,0)
references.
"^DD",798.3,798.32,.01,1,2,"DT")
3020419
"^DD",798.3,798.32,.01,8.5)
@
"^DD",798.3,798.32,.01,9)
@
"^DD",798.3,798.32,.01,21,0)
^.001^3^3^3020502^^
"^DD",798.3,798.32,.01,21,1,0)
This field stores the timestamp of the event
"^DD",798.3,798.32,.01,21,2,0)
reference (the current date and time when the
"^DD",798.3,798.32,.01,21,3,0)
reference was created).
"^DD",798.3,798.32,.01,"DT")
3020502
"^DD",798.3,798.32,1,0)
DATA AREA^RP799.33'^ROR(799.33,^0;2^Q
"^DD",798.3,798.32,1,3)

"^DD",798.3,798.32,1,8.5)
@
"^DD",798.3,798.32,1,9)
@
"^DD",798.3,798.32,1,21,0)
^.001^3^3^3030606^^^
"^DD",798.3,798.32,1,21,1,0)
Internal value of this field is the code defining
"^DD",798.3,798.32,1,21,2,0)
the data area (protocol) that this event reference
"^DD",798.3,798.32,1,21,3,0)
associated with.
"^DD",798.3,798.32,1,23,0)
^.001^6^6^3030606^^
"^DD",798.3,798.32,1,23,1,0)
The codes are associated with the event protocols as
"^DD",798.3,798.32,1,23,2,0)
follow:
"^DD",798.3,798.32,1,23,3,0)
 
"^DD",798.3,798.32,1,23,4,0)
 1 - ROR EVENT LAB (LR7O ALL EVSEND RESULTS)
"^DD",798.3,798.32,1,23,5,0)
 2 - ROR EVENT VISIT (PXK VISIT DATA EVENT)
"^DD",798.3,798.32,1,23,6,0)
 3 - ROR EVENT PTF (DGPM MOVEMENT EVENTS)
"^DD",798.3,798.32,1,"DT")
3030606
"^DD",798.3,798.32,2,0)
DATE^D^^0;3^S %DT="EST" D ^%DT S X=Y K:Y<1 X
"^DD",798.3,798.32,2,1,0)
^.1^^0
"^DD",798.3,798.32,2,8.5)
@
"^DD",798.3,798.32,2,9)
@
"^DD",798.3,798.32,2,21,0)
^.001^3^3^3020424^^
"^DD",798.3,798.32,2,21,1,0)
This field stores the date and time associated
"^DD",798.3,798.32,2,21,2,0)
with the event. For example, collection date/time
"^DD",798.3,798.32,2,21,3,0)
of the specimen is stored here for the Lab event.
"^DD",798.3,798.32,2,"DT")
3020419
"^DD",798.4,798.4,0)
FIELD^^991^14
"^DD",798.4,798.4,0,"DDA")
N
"^DD",798.4,798.4,0,"DT")
3021101
"^DD",798.4,798.4,0,"IX","B",798.4,.01)

"^DD",798.4,798.4,0,"IX","BS",798.4,.09)

"^DD",798.4,798.4,0,"IX","BS5",798.4,.09)

"^DD",798.4,798.4,0,"IX","SSN",798.4,.09)

"^DD",798.4,798.4,0,"NM","ROR PATIENT")

"^DD",798.4,798.4,0,"PT",798,.01)

"^DD",798.4,798.4,0,"SCR")
I $$ACCESS^RORDD(798.4)
"^DD",798.4,798.4,0,"VRPK")
ROR
"^DD",798.4,798.4,.01,0)
PATIENT NAME^RP2'X^DPT(^0;1^S:$D(X) DINUM=X
"^DD",798.4,798.4,.01,1,0)
^.1
"^DD",798.4,798.4,.01,1,1,0)
798.4^B
"^DD",798.4,798.4,.01,1,1,1)
S ^RORDATA(798.4,"B",$E(X,1,30),DA)=""
"^DD",798.4,798.4,.01,1,1,2)
K ^RORDATA(798.4,"B",$E(X,1,30),DA)
"^DD",798.4,798.4,.01,1,1,3)
Do not delete!
"^DD",798.4,798.4,.01,1,1,"DT")
3000523
"^DD",798.4,798.4,.01,3)

"^DD",798.4,798.4,.01,8.5)
@
"^DD",798.4,798.4,.01,9)
@
"^DD",798.4,798.4,.01,21,0)
^^5^5^3020802^
"^DD",798.4,798.4,.01,21,1,0)
You can select an existing patient or add a new 
"^DD",798.4,798.4,.01,21,2,0)
one from the PATIENT file (#2).
"^DD",798.4,798.4,.01,21,3,0)
 
"^DD",798.4,798.4,.01,21,4,0)
You can access records of this file only if you
"^DD",798.4,798.4,.01,21,5,0)
have appropriate security key(s) for any registry.
"^DD",798.4,798.4,.01,23,0)
^.001^4^4^3020802^^^
"^DD",798.4,798.4,.01,23,1,0)
The PATIENT NAME field points to the patient record in 
"^DD",798.4,798.4,.01,23,2,0)
the PATIENT file (#2). Internal value of this field is
"^DD",798.4,798.4,.01,23,3,0)
used as internal entry number of the record ("DINUM"
"^DD",798.4,798.4,.01,23,4,0)
feature).
"^DD",798.4,798.4,.01,"DEL",1,0)
I $D(^RORDATA(798,"B",+$G(DA)))
"^DD",798.4,798.4,.01,"DT")
3000523
"^DD",798.4,798.4,.02,0)
SEX^SI^M:MALE;F:FEMALE;^1;3^Q
"^DD",798.4,798.4,.02,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.02,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.02,21,0)
^.001^1^1^3021106^^^^
"^DD",798.4,798.4,.02,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.02,23,0)
^.001^1^1^3021106^^^
"^DD",798.4,798.4,.02,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.02,"DT")
3011120
"^DD",798.4,798.4,.03,0)
DATE OF BIRTH^RDOI^^1;2^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.4,798.4,.03,2)
S Y(0)=Y S Y(0)=Y S X=Y(0) S:X X=$E(X,4,5)_"/"_$E(X,6,7)_"/"_(1700+$E(X,1,3)) S Y=X
"^DD",798.4,798.4,.03,2.1)
S Y(0)=Y S X=Y(0) S:X X=$E(X,4,5)_"/"_$E(X,6,7)_"/"_(1700+$E(X,1,3)) S Y=X
"^DD",798.4,798.4,.03,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.03,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.03,21,0)
^.001^1^1^3021106^^^^
"^DD",798.4,798.4,.03,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.03,23,0)
^.001^1^1^3021106^^^^
"^DD",798.4,798.4,.03,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.03,"DT")
3011120
"^DD",798.4,798.4,.09,0)
SOCIAL SECURITY NUMBER^RFOI^^1;1^K:$L(X)>11!($L(X)<9) X
"^DD",798.4,798.4,.09,1,0)
^.1
"^DD",798.4,798.4,.09,1,1,0)
798.4^BS^MUMPS
"^DD",798.4,798.4,.09,1,1,1)
S ^RORDATA(798.4,"BS",$E(X,6,9),DA)=""
"^DD",798.4,798.4,.09,1,1,2)
K ^RORDATA(798.4,"BS",$E(X,6,9),DA)
"^DD",798.4,798.4,.09,1,1,3)
Do not delete!
"^DD",798.4,798.4,.09,1,1,"%D",0)
^.101^1^1^3011220^^
"^DD",798.4,798.4,.09,1,1,"%D",1,0)
The cross-reference on the last four digits of the SSN.
"^DD",798.4,798.4,.09,1,1,"DT")
3000426
"^DD",798.4,798.4,.09,1,2,0)
798.4^BS5^MUMPS
"^DD",798.4,798.4,.09,1,2,1)
S ^RORDATA(798.4,"BS5",$E(^DPT(DA,0),1)_$E(X,6,9),DA)=""
"^DD",798.4,798.4,.09,1,2,2)
K ^RORDATA(798.4,"BS5",$E(^DPT(DA,0),1)_$E(X,6,9),DA)
"^DD",798.4,798.4,.09,1,2,3)
Do not delete!
"^DD",798.4,798.4,.09,1,2,"%D",0)
^^3^3^3020403^
"^DD",798.4,798.4,.09,1,2,"%D",1,0)
This cross-reference contains values combined from
"^DD",798.4,798.4,.09,1,2,"%D",2,0)
the first letter of the last name and last four
"^DD",798.4,798.4,.09,1,2,"%D",3,0)
digits of the SSN.
"^DD",798.4,798.4,.09,1,2,"DT")
3011220
"^DD",798.4,798.4,.09,1,3,0)
798.4^SSN
"^DD",798.4,798.4,.09,1,3,1)
S ^RORDATA(798.4,"SSN",$E(X,1,30),DA)=""
"^DD",798.4,798.4,.09,1,3,2)
K ^RORDATA(798.4,"SSN",$E(X,1,30),DA)
"^DD",798.4,798.4,.09,1,3,3)
Do not delete!
"^DD",798.4,798.4,.09,1,3,"DT")
3011221
"^DD",798.4,798.4,.09,2)
S Y(0)=Y S:$L(Y)=11 Y=$E(Y,10,11)_$E(Y,1,9)
"^DD",798.4,798.4,.09,2.1)
S:$L(Y)=11 Y=$E(Y,10,11)_$E(Y,1,9)
"^DD",798.4,798.4,.09,3)
Answer must be 9-11 characters in length.
"^DD",798.4,798.4,.09,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.09,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.09,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.09,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.09,23,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.09,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.09,"DT")
3020403
"^DD",798.4,798.4,.1112,0)
ZIP+4^FI^^1;8^K:$L(X)>9!($L(X)<5) X
"^DD",798.4,798.4,.1112,3)
Answer must be 5-9 characters in length.
"^DD",798.4,798.4,.1112,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.1112,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.1112,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.1112,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.1112,23,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.1112,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.1112,"DT")
3011120
"^DD",798.4,798.4,.301,0)
SERVICE CONNECTED?^RSI^Y:YES;N:NO;^1;6^Q
"^DD",798.4,798.4,.301,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.301,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.301,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.301,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.301,23,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.301,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.301,"DT")
3011120
"^DD",798.4,798.4,.302,0)
SERVICE CONNECTED PERCENTAGE^NJ3,0I^^1;7^K:+X'=X!(X>100)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.4,798.4,.302,3)
Type a Number between 0 and 100, 0 Decimal Digits
"^DD",798.4,798.4,.302,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.302,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.302,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.302,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.302,23,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.302,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.302,"DT")
3011120
"^DD",798.4,798.4,.323,0)
PERIOD OF SERVICE^P21'I^DIC(21,^1;5^Q
"^DD",798.4,798.4,.323,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.323,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.323,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.323,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.323,23,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.323,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.323,"DT")
3011120
"^DD",798.4,798.4,.351,0)
DATE OF DEATH^DI^^1;4^S %DT="ET" D ^%DT S X=Y K:Y<1 X
"^DD",798.4,798.4,.351,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.351,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.351,21,0)
^.001^1^1^3021106^^^^
"^DD",798.4,798.4,.351,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.351,23,0)
^.001^1^1^3021106^^^^
"^DD",798.4,798.4,.351,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.351,"DT")
3020502
"^DD",798.4,798.4,.3721,0)
RATED DISABILITIES DATA^FI^^3;E1,245^K:$L(X)>245!($L(X)<1) X
"^DD",798.4,798.4,.3721,3)
Answer must be 1-245 characters in length.
"^DD",798.4,798.4,.3721,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.3721,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.3721,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.3721,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.3721,23,0)
^.001^5^5^3021106^^
"^DD",798.4,798.4,.3721,23,1,0)
This field stores the combined data from the RATED
"^DD",798.4,798.4,.3721,23,2,0)
DISABILITIES (VA) multiple (.3721) of the PATIENT file
"^DD",798.4,798.4,.3721,23,3,0)
(#2). This data can be used only for comparison (by the
"^DD",798.4,798.4,.3721,23,4,0)
RORUPD52 routine) to the data in the PATIENT file (do
"^DD",798.4,798.4,.3721,23,5,0)
not try to parse values of this field in any way)!
"^DD",798.4,798.4,.3721,"DT")
3021106
"^DD",798.4,798.4,2,0)
RACE AND ETHNICITY DATA^FI^^2;E1,245^K:$L(X)>245!($L(X)<1) X
"^DD",798.4,798.4,2,3)
Answer must be 1-245 characters in length.
"^DD",798.4,798.4,2,20,0)
^.3LA^1^1
"^DD",798.4,798.4,2,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,2,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,2,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,2,23,0)
^.001^6^6^3021106^^
"^DD",798.4,798.4,2,23,1,0)
This field stores the combined data from the RACE
"^DD",798.4,798.4,2,23,2,0)
INFORMATION (2) and ETHNICITY INFORMATION (6) multiples
"^DD",798.4,798.4,2,23,3,0)
of the PATIENT file (#2). This data can be used only
"^DD",798.4,798.4,2,23,4,0)
for comparison (by the RORUPD52 routine) to the data in
"^DD",798.4,798.4,2,23,5,0)
the PATIENT file (do not try to parse values of this
"^DD",798.4,798.4,2,23,6,0)
field in any way)!
"^DD",798.4,798.4,2,"DT")
3021106
"^DD",798.4,798.4,10.1,0)
OLD SSN^FI^^10;1^K:$L(X)>11!($L(X)<9) X
"^DD",798.4,798.4,10.1,3)
Answer must be 9-11 characters in length.
"^DD",798.4,798.4,10.1,20,0)
^.3LA^1^1
"^DD",798.4,798.4,10.1,20,1,0)
OLD DEMOGRAPHICS
"^DD",798.4,798.4,10.1,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,10.1,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,10.1,23,0)
^.001^3^3^3021106^^
"^DD",798.4,798.4,10.1,23,1,0)
This field contains the previous value of the patient 
"^DD",798.4,798.4,10.1,23,2,0)
SSN. The registry extraction process transmits both new
"^DD",798.4,798.4,10.1,23,3,0)
and old values of the SSN to the national registries.
"^DD",798.4,798.4,10.1,"DT")
3011120
"^DD",798.4,798.4,10.2,0)
OLD ICN^FI^^10;2^K:$L(X)>19!($L(X)<1) X
"^DD",798.4,798.4,10.2,3)
Answer must be 1-19 characters in length.
"^DD",798.4,798.4,10.2,20,0)
^.3LA^1^1
"^DD",798.4,798.4,10.2,20,1,0)
OLD DEMOGRAPHICS
"^DD",798.4,798.4,10.2,21,0)
^.001^1^1^3021106^^^
"^DD",798.4,798.4,10.2,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,10.2,23,0)
^.001^4^4^3021106^^
"^DD",798.4,798.4,10.2,23,1,0)
This field contains the previous value of the patient 
"^DD",798.4,798.4,10.2,23,2,0)
ICN (with the checksum). The registry extraction
"^DD",798.4,798.4,10.2,23,3,0)
process transmits both new and old values of the ICN to
"^DD",798.4,798.4,10.2,23,4,0)
the national registries.
"^DD",798.4,798.4,10.2,"DT")
3021101
"^DD",798.4,798.4,991,0)
INTEGRATION CONTROL NUMBER^FI^^1;9^K:$L(X)>19!($L(X)<1) X
"^DD",798.4,798.4,991,3)
Answer must be 1-19 characters in length.
"^DD",798.4,798.4,991,20,0)
^.3LA^1^1
"^DD",798.4,798.4,991,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,991,21,0)
^.001^1^1^3021106^^^
"^DD",798.4,798.4,991,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,991,23,0)
^.001^4^4^3021106^^
"^DD",798.4,798.4,991,23,1,0)
This field stores the patient's full Integration
"^DD",798.4,798.4,991,23,2,0)
Control Number (the ICN and checksum separated by the
"^DD",798.4,798.4,991,23,3,0)
"V"). See the fields 991.01 and 991.02 of the PATIENT
"^DD",798.4,798.4,991,23,4,0)
file (#2).
"^DD",798.4,798.4,991,"DT")
3021101
"^DD",798.5,798.5,0)
FIELD^^4^9
"^DD",798.5,798.5,0,"DDA")
N
"^DD",798.5,798.5,0,"DT")
3011114
"^DD",798.5,798.5,0,"IX","ALOG",798.5,2.04)

"^DD",798.5,798.5,0,"IX","AR",798.5,.02)

"^DD",798.5,798.5,0,"IX","B",798.5,.01)

"^DD",798.5,798.5,0,"IX","T",798.5,2.01)

"^DD",798.5,798.5,0,"NM","ROR HDT TASK")

"^DD",798.5,798.5,0,"VRPK")
ROR
"^DD",798.5,798.5,.01,0)
START RECORD IEN^RNJ12,0^^0;1^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.5,798.5,.01,1,0)
^.1
"^DD",798.5,798.5,.01,1,1,0)
798.5^B
"^DD",798.5,798.5,.01,1,1,1)
S ^RORDATA(798.5,"B",$E(X,1,30),DA)=""
"^DD",798.5,798.5,.01,1,1,2)
K ^RORDATA(798.5,"B",$E(X,1,30),DA)
"^DD",798.5,798.5,.01,1,1,3)
Do not delete!
"^DD",798.5,798.5,.01,3)
Enter an IEN of the registry record (1-999999999999, 0 Decimal Digits).
"^DD",798.5,798.5,.01,8.5)
@
"^DD",798.5,798.5,.01,9)
@
"^DD",798.5,798.5,.01,21,0)
^^16^16^3011108^
"^DD",798.5,798.5,.01,21,1,0)
All patients in the registry are distributed 
"^DD",798.5,798.5,.01,21,2,0)
between the data extraction tasks. Each task
"^DD",798.5,798.5,.01,21,3,0)
extracts the data of the patients whose registry
"^DD",798.5,798.5,.01,21,4,0)
records have IENs that are not less than the value
"^DD",798.5,798.5,.01,21,5,0)
of this field in the task record and are less than
"^DD",798.5,798.5,.01,21,6,0)
the value of the field in the next task record.
"^DD",798.5,798.5,.01,21,7,0)
                                 
"^DD",798.5,798.5,.01,21,8,0)
The first task always has 1 as a value of this
"^DD",798.5,798.5,.01,21,9,0)
field (just in case).  
"^DD",798.5,798.5,.01,21,10,0)
                                 
"^DD",798.5,798.5,.01,21,11,0)
The last task extracts the data of all patients
"^DD",798.5,798.5,.01,21,12,0)
whose registry records have IENs not less than the
"^DD",798.5,798.5,.01,21,13,0)
value of this field.  
"^DD",798.5,798.5,.01,21,14,0)
                                 
"^DD",798.5,798.5,.01,21,15,0)
Usually, this field should not be edited. It is
"^DD",798.5,798.5,.01,21,16,0)
populated automatically when the task is created.
"^DD",798.5,798.5,.01,23,0)
^^7^7^3020403^
"^DD",798.5,798.5,.01,23,1,0)
The value of this field is not a real pointer to the 
"^DD",798.5,798.5,.01,23,2,0)
ROR LOCAL REGISTRY file. There can be no record in the
"^DD",798.5,798.5,.01,23,3,0)
local registry with an IEN stored in this field.
"^DD",798.5,798.5,.01,23,4,0)
 
"^DD",798.5,798.5,.01,23,5,0)
The historical data extraction task will start 
"^DD",798.5,798.5,.01,23,6,0)
processing from the registry record with IEN that is
"^DD",798.5,798.5,.01,23,7,0)
not less than the value of this field.
"^DD",798.5,798.5,.01,"DT")
3011108
"^DD",798.5,798.5,.02,0)
REGISTRY^P798.1'I^ROR(798.1,^0;2^Q
"^DD",798.5,798.5,.02,1,0)
^.1
"^DD",798.5,798.5,.02,1,1,0)
798.5^AR
"^DD",798.5,798.5,.02,1,1,1)
S ^RORDATA(798.5,"AR",$E(X,1,30),DA)=""
"^DD",798.5,798.5,.02,1,1,2)
K ^RORDATA(798.5,"AR",$E(X,1,30),DA)
"^DD",798.5,798.5,.02,1,1,3)
Do not delete!
"^DD",798.5,798.5,.02,1,1,"DT")
3011108
"^DD",798.5,798.5,.02,8.5)
@
"^DD",798.5,798.5,.02,9)
@
"^DD",798.5,798.5,.02,21,0)
^^2^2^3011108^
"^DD",798.5,798.5,.02,21,1,0)
This field identifies the registry that the task
"^DD",798.5,798.5,.02,21,2,0)
is associated with.
"^DD",798.5,798.5,.02,"DT")
3011116
"^DD",798.5,798.5,1.01,0)
FILE NAME^FX^^0;3^K:$L(X)>30!($L(X)<3)!($L($TR(X,"*?/\[]|"":<>"))<$L(X)) X
"^DD",798.5,798.5,1.01,3)
Answer must be 3-30 characters in length.
"^DD",798.5,798.5,1.01,8.5)
@
"^DD",798.5,798.5,1.01,9)
@
"^DD",798.5,798.5,1.01,21,0)
^.001^18^18^3011114^^^
"^DD",798.5,798.5,1.01,21,1,0)
The output file name is stored in this field. This
"^DD",798.5,798.5,1.01,21,2,0)
name is generated automatically when the task is
"^DD",798.5,798.5,1.01,21,3,0)
created. The name has the following structure:
"^DD",798.5,798.5,1.01,21,4,0)
                                 
"^DD",798.5,798.5,1.01,21,5,0)
 SsssTtt.HDT 
"^DD",798.5,798.5,1.01,21,6,0)
                                 
"^DD",798.5,798.5,1.01,21,7,0)
where 'sss' is the site number and 'tt' is the
"^DD",798.5,798.5,1.01,21,8,0)
sequential number of the task.  
"^DD",798.5,798.5,1.01,21,9,0)
                                 
"^DD",798.5,798.5,1.01,21,10,0)
If the task is restarted, the optional numeric
"^DD",798.5,798.5,1.01,21,11,0)
modifier 'nn' can be added to the name so that the
"^DD",798.5,798.5,1.01,21,12,0)
already extracted data will not be overwritten:
"^DD",798.5,798.5,1.01,21,13,0)
                                 
"^DD",798.5,798.5,1.01,21,14,0)
 SsssTtt-nn.HDT 
"^DD",798.5,798.5,1.01,21,15,0)
                                 
"^DD",798.5,798.5,1.01,21,16,0)
Usually, this field should not be edited. It is
"^DD",798.5,798.5,1.01,21,17,0)
populated automatically when the task is created
"^DD",798.5,798.5,1.01,21,18,0)
or restarted.  
"^DD",798.5,798.5,1.01,23,0)
^^3^3^3020403^
"^DD",798.5,798.5,1.01,23,1,0)
Uniqueness of the output file names (for the same 
"^DD",798.5,798.5,1.01,23,2,0)
registry) is guaranteed by the "B" secondary key and
"^DD",798.5,798.5,1.01,23,3,0)
the "DF" index.
"^DD",798.5,798.5,1.01,"DT")
3011114
"^DD",798.5,798.5,2.01,0)
TASK NUMBER^NJ10,0I^^0;4^K:+X'=X!(X>9899999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.5,798.5,2.01,1,0)
^.1
"^DD",798.5,798.5,2.01,1,1,0)
798.5^T
"^DD",798.5,798.5,2.01,1,1,1)
S ^RORDATA(798.5,"T",$E(X,1,30),DA)=""
"^DD",798.5,798.5,2.01,1,1,2)
K ^RORDATA(798.5,"T",$E(X,1,30),DA)
"^DD",798.5,798.5,2.01,1,1,3)
Do not delete!
"^DD",798.5,798.5,2.01,1,1,"%D",0)
^^3^3^3011108^
"^DD",798.5,798.5,2.01,1,1,"%D",1,0)
This cross-reference can be used to find a 
"^DD",798.5,798.5,2.01,1,1,"%D",2,0)
historical data extraction task using the task
"^DD",798.5,798.5,2.01,1,1,"%D",3,0)
number assigned by TaskMan.
"^DD",798.5,798.5,2.01,1,1,"DT")
3011108
"^DD",798.5,798.5,2.01,3)
Type a Number between 1 and 9899999999, 0 Decimal Digits.
"^DD",798.5,798.5,2.01,8.5)
@
"^DD",798.5,798.5,2.01,9)
@
"^DD",798.5,798.5,2.01,21,0)
^^6^6^3011108^
"^DD",798.5,798.5,2.01,21,1,0)
This field contains the number of the Taskman task
"^DD",798.5,798.5,2.01,21,2,0)
(scheduled or running) that does the data
"^DD",798.5,798.5,2.01,21,3,0)
extraction.  
"^DD",798.5,798.5,2.01,21,4,0)
                                 
"^DD",798.5,798.5,2.01,21,5,0)
This field cannot be edited. It is updated
"^DD",798.5,798.5,2.01,21,6,0)
automatically by the data extraction task.
"^DD",798.5,798.5,2.01,"DT")
3011116
"^DD",798.5,798.5,2.02,0)
JOB NUMBER^NJ12,0I^^0;5^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.5,798.5,2.02,3)
Type a Number between 1 and 999999999999, 0 Decimal Digits.
"^DD",798.5,798.5,2.02,8.5)
@
"^DD",798.5,798.5,2.02,9)
@
"^DD",798.5,798.5,2.02,21,0)
^^5^5^3011108^
"^DD",798.5,798.5,2.02,21,1,0)
This field contains the job number of the M 
"^DD",798.5,798.5,2.02,21,2,0)
process that does/did the data extraction.
"^DD",798.5,798.5,2.02,21,3,0)
                                 
"^DD",798.5,798.5,2.02,21,4,0)
This field cannot be edited. It is updated
"^DD",798.5,798.5,2.02,21,5,0)
automatically by the data extraction task.
"^DD",798.5,798.5,2.02,23,0)
^.001^2^2^3020403^^
"^DD",798.5,798.5,2.02,23,1,0)
The task has crashed or has been forced to exit if it
"^DD",798.5,798.5,2.02,23,2,0)
is not running and this field has a value.
"^DD",798.5,798.5,2.02,"DT")
3011116
"^DD",798.5,798.5,2.03,0)
COMPLETED^SI^0:NO;1:YES;^0;6^Q
"^DD",798.5,798.5,2.03,8.5)
@
"^DD",798.5,798.5,2.03,9)
@
"^DD",798.5,798.5,2.03,21,0)
^^5^5^3020403^
"^DD",798.5,798.5,2.03,21,1,0)
This field is set to "Yes" if the data extraction
"^DD",798.5,798.5,2.03,21,2,0)
task has been completed without any errors.
"^DD",798.5,798.5,2.03,21,3,0)
                                 
"^DD",798.5,798.5,2.03,21,4,0)
This field cannot be edited. It is updated
"^DD",798.5,798.5,2.03,21,5,0)
automatically by the data extraction task.
"^DD",798.5,798.5,2.03,"DT")
3011119
"^DD",798.5,798.5,2.04,0)
LOG^P798.7'I^RORDATA(798.7,^0;7^Q
"^DD",798.5,798.5,2.04,1,0)
^.1
"^DD",798.5,798.5,2.04,1,1,0)
798.5^ALOG^MUMPS
"^DD",798.5,798.5,2.04,1,1,1)
S ^RORDATA(798.7,"AREF",X,798.5,DA_",",2.04)=""
"^DD",798.5,798.5,2.04,1,1,2)
K ^RORDATA(798.7,"AREF",X,798.5,DA_",",2.04)
"^DD",798.5,798.5,2.04,1,1,3)
Do not delete!
"^DD",798.5,798.5,2.04,1,1,"%D",0)
^^24^24^3030507^
"^DD",798.5,798.5,2.04,1,1,"%D",1,0)
The logic of the ALOG cross-reference maintains a
"^DD",798.5,798.5,2.04,1,1,"%D",2,0)
list of references from the ROR HDT TASK file to
"^DD",798.5,798.5,2.04,1,1,"%D",3,0)
the ROR LOG file. This list allows the function
"^DD",798.5,798.5,2.04,1,1,"%D",4,0)
that purges the old logs ($$PURGE^RORLOG01) either
"^DD",798.5,798.5,2.04,1,1,"%D",5,0)
to keep those logs that are referenced from other
"^DD",798.5,798.5,2.04,1,1,"%D",6,0)
files or to remove the references.
"^DD",798.5,798.5,2.04,1,1,"%D",7,0)
 
"^DD",798.5,798.5,2.04,1,1,"%D",8,0)
The list is stored under the "AREF" subscript in
"^DD",798.5,798.5,2.04,1,1,"%D",9,0)
the ROR LOG file (#798.7) and has the following
"^DD",798.5,798.5,2.04,1,1,"%D",10,0)
structure:
"^DD",798.5,798.5,2.04,1,1,"%D",11,0)
 
"^DD",798.5,798.5,2.04,1,1,"%D",12,0)
 ^RORDATA(798.7,"AREF",<Log>,798.5,<IENS>,2.04)
"^DD",798.5,798.5,2.04,1,1,"%D",13,0)
 
"^DD",798.5,798.5,2.04,1,1,"%D",14,0)
<Log> is the IEN of the log that is associated
"^DD",798.5,798.5,2.04,1,1,"%D",15,0)
with the task (internal value of the LOG field). 
"^DD",798.5,798.5,2.04,1,1,"%D",16,0)
 
"^DD",798.5,798.5,2.04,1,1,"%D",17,0)
'798.5' is the number of the file from where the
"^DD",798.5,798.5,2.04,1,1,"%D",18,0)
log is referenced (ROR HDT TASK).
"^DD",798.5,798.5,2.04,1,1,"%D",19,0)
 
"^DD",798.5,798.5,2.04,1,1,"%D",20,0)
<IENS> is the IENS of the record that references
"^DD",798.5,798.5,2.04,1,1,"%D",21,0)
the log.
"^DD",798.5,798.5,2.04,1,1,"%D",22,0)
 
"^DD",798.5,798.5,2.04,1,1,"%D",23,0)
'2.04' is the number of the field that points to
"^DD",798.5,798.5,2.04,1,1,"%D",24,0)
the log (the LOG field).
"^DD",798.5,798.5,2.04,1,1,"DT")
3030314
"^DD",798.5,798.5,2.04,8.5)
@
"^DD",798.5,798.5,2.04,9)
@
"^DD",798.5,798.5,2.04,21,0)
^^6^6^3011108^
"^DD",798.5,798.5,2.04,21,1,0)
This fields contains a pointer to the log file 
"^DD",798.5,798.5,2.04,21,2,0)
that was created during the last run of the data
"^DD",798.5,798.5,2.04,21,3,0)
extraction task.  
"^DD",798.5,798.5,2.04,21,4,0)
                                 
"^DD",798.5,798.5,2.04,21,5,0)
This field cannot be edited. It is updated
"^DD",798.5,798.5,2.04,21,6,0)
automatically by the data extraction task.
"^DD",798.5,798.5,2.04,"DT")
3030314
"^DD",798.5,798.5,3,0)
ERROR^798.53P^^3;0
"^DD",798.5,798.5,3,9)
@
"^DD",798.5,798.5,3,21,0)
^^11^11^3020403^
"^DD",798.5,798.5,3,21,1,0)
This multiple contains a list of registry records
"^DD",798.5,798.5,3,21,2,0)
that were processed with errors.  
"^DD",798.5,798.5,3,21,3,0)
 
"^DD",798.5,798.5,3,21,4,0)
When the data extraction task is restarted, it
"^DD",798.5,798.5,3,21,5,0)
tries to re-extract the data for these patients.  
"^DD",798.5,798.5,3,21,6,0)
If it succeeds, it deletes the corresponding
"^DD",798.5,798.5,3,21,7,0)
records from the list.  
"^DD",798.5,798.5,3,21,8,0)
 
"^DD",798.5,798.5,3,21,9,0)
The records of the multiple have the same IENs as
"^DD",798.5,798.5,3,21,10,0)
the corresponding registry records in the ROR
"^DD",798.5,798.5,3,21,11,0)
LOCAL REGISTRY file.
"^DD",798.5,798.5,4,0)
NEXT RECORD IEN^NJ12,0^^0;8^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.5,798.5,4,3)
Enter an IEN of the registry record (1-999999999999, 0 Decimal Digits).
"^DD",798.5,798.5,4,8.5)
@
"^DD",798.5,798.5,4,9)
@
"^DD",798.5,798.5,4,21,0)
^^10^10^3030507^
"^DD",798.5,798.5,4,21,1,0)
If the data extraction task is stopped, it finishes
"^DD",798.5,798.5,4,21,2,0)
processing the current registry record and stores
"^DD",798.5,798.5,4,21,3,0)
an IEN of the record that should be processed next
"^DD",798.5,798.5,4,21,4,0)
as a value of this field.  
"^DD",798.5,798.5,4,21,5,0)
                                 
"^DD",798.5,798.5,4,21,6,0)
When the task is restarted, it starts from the
"^DD",798.5,798.5,4,21,7,0)
registry record IEN stored in this field.
"^DD",798.5,798.5,4,21,8,0)
                                 
"^DD",798.5,798.5,4,21,9,0)
Usually, this field should not be edited. It is
"^DD",798.5,798.5,4,21,10,0)
updated automatically by the data extraction task.
"^DD",798.5,798.5,4,23,0)
^.001^7^7^3030507^^
"^DD",798.5,798.5,4,23,1,0)
The value of this field is not a real pointer to the 
"^DD",798.5,798.5,4,23,2,0)
ROR LOCAL REGISTRY file. There can be no record in the
"^DD",798.5,798.5,4,23,3,0)
local registry with an IEN stored in this field.
"^DD",798.5,798.5,4,23,4,0)
 
"^DD",798.5,798.5,4,23,5,0)
The restarted historical data extraction task will 
"^DD",798.5,798.5,4,23,6,0)
continue processing from the registry record with IEN
"^DD",798.5,798.5,4,23,7,0)
that is not less than the value of this field.
"^DD",798.5,798.5,4,"DT")
3011109
"^DD",798.5,798.53,0)
ERROR SUB-FIELD^^.01^1
"^DD",798.5,798.53,0,"DT")
3011108
"^DD",798.5,798.53,0,"IX","B",798.53,.01)

"^DD",798.5,798.53,0,"NM","ERROR")

"^DD",798.5,798.53,0,"UP")
798.5
"^DD",798.5,798.53,.01,0)
RECORD^MP798'X^RORDATA(798,^0;1^S:$D(X) DINUM=X
"^DD",798.5,798.53,.01,1,0)
^.1
"^DD",798.5,798.53,.01,1,1,0)
798.53^B
"^DD",798.5,798.53,.01,1,1,1)
S ^RORDATA(798.5,DA(1),3,"B",$E(X,1,30),DA)=""
"^DD",798.5,798.53,.01,1,1,2)
K ^RORDATA(798.5,DA(1),3,"B",$E(X,1,30),DA)
"^DD",798.5,798.53,.01,1,1,3)
Do not delete!
"^DD",798.5,798.53,.01,8.5)
@
"^DD",798.5,798.53,.01,9)
@
"^DD",798.5,798.53,.01,21,0)
^^6^6^3011108^
"^DD",798.5,798.53,.01,21,1,0)
This field holds a pointer to the registry record
"^DD",798.5,798.53,.01,21,2,0)
that was processed with errors. If the task is
"^DD",798.5,798.53,.01,21,3,0)
restarted, it tries to re-extract this data.
"^DD",798.5,798.53,.01,21,4,0)
                                   
"^DD",798.5,798.53,.01,21,5,0)
Usually, this field should not be edited. It is
"^DD",798.5,798.53,.01,21,6,0)
updated automatically by the data extraction task.
"^DD",798.5,798.53,.01,"DT")
3011108
"^DD",798.7,798.7,0)
FIELD^^7^10
"^DD",798.7,798.7,0,"DDA")
N
"^DD",798.7,798.7,0,"DT")
3030130
"^DD",798.7,798.7,0,"IX","B",798.7,.01)

"^DD",798.7,798.7,0,"IX","C",798.7,2)

"^DD",798.7,798.7,0,"NM","ROR LOG")

"^DD",798.7,798.7,0,"PT",798.5,2.04)

"^DD",798.7,798.7,0,"PT",798.8,2.03)

"^DD",798.7,798.7,0,"SCR")
I $$ACCESS^RORDD(798.7)
"^DD",798.7,798.7,0,"VRPK")
ROR
"^DD",798.7,798.7,.01,0)
START DATE/TIME^RDI^^0;1^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798.7,798.7,.01,1,0)
^.1
"^DD",798.7,798.7,.01,1,1,0)
798.7^B
"^DD",798.7,798.7,.01,1,1,1)
S ^RORDATA(798.7,"B",$E(X,1,30),DA)=""
"^DD",798.7,798.7,.01,1,1,2)
K ^RORDATA(798.7,"B",$E(X,1,30),DA)
"^DD",798.7,798.7,.01,1,1,3)
Do not delete!
"^DD",798.7,798.7,.01,3)

"^DD",798.7,798.7,.01,21,0)
^^5^5^3021101^
"^DD",798.7,798.7,.01,21,1,0)
This field contains the date/time when this log 
"^DD",798.7,798.7,.01,21,2,0)
was created.
"^DD",798.7,798.7,.01,21,3,0)
 
"^DD",798.7,798.7,.01,21,4,0)
You can access records of this file only if you
"^DD",798.7,798.7,.01,21,5,0)
have appropriate security key(s) for any registry.
"^DD",798.7,798.7,.01,23,0)
^.001^2^2^3021101^^
"^DD",798.7,798.7,.01,23,1,0)
The $$OPEN^RORLOG function populates this field
"^DD",798.7,798.7,.01,23,2,0)
automatically when a new log is created.
"^DD",798.7,798.7,.01,"DEL",1,0)
I $D(^RORDATA(798.7,"AREF",+$G(DA)))
"^DD",798.7,798.7,.01,"DT")
3010807
"^DD",798.7,798.7,1,0)
ACTIVITY^S^0:Other;1:Registry Update;2:Data Extraction;3:Acknowledgement;4:Hist. Extraction;5:Report;6:Access Violation;^0;3^Q
"^DD",798.7,798.7,1,21,0)
^.001^2^2^3030121^^
"^DD",798.7,798.7,1,21,1,0)
The value of this field indicates the activity
"^DD",798.7,798.7,1,21,2,0)
performed by the process that created the log.
"^DD",798.7,798.7,1,23,0)
^.001^2^2^3030121^^
"^DD",798.7,798.7,1,23,1,0)
This field is populated by the $$OPEN^RORLOG function 
"^DD",798.7,798.7,1,23,2,0)
with the value passed as one of the parameters.
"^DD",798.7,798.7,1,"DT")
3030121
"^DD",798.7,798.7,2,0)
JOB NUMBER^NJ12,0^^0;4^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.7,798.7,2,1,0)
^.1
"^DD",798.7,798.7,2,1,1,0)
798.7^C
"^DD",798.7,798.7,2,1,1,1)
S ^RORDATA(798.7,"C",$E(X,1,30),DA)=""
"^DD",798.7,798.7,2,1,1,2)
K ^RORDATA(798.7,"C",$E(X,1,30),DA)
"^DD",798.7,798.7,2,1,1,3)
Do not delete!
"^DD",798.7,798.7,2,1,1,"%D",0)
^^3^3^3011011^
"^DD",798.7,798.7,2,1,1,"%D",1,0)
This cross-reference can be used in the 
"^DD",798.7,798.7,2,1,1,"%D",2,0)
troubleshooting process to find the log by the job
"^DD",798.7,798.7,2,1,1,"%D",3,0)
number.
"^DD",798.7,798.7,2,1,1,"DT")
3010813
"^DD",798.7,798.7,2,3)
Enter a job number between 1 and 999999999999, 0 Decimal Digits.
"^DD",798.7,798.7,2,21,0)
^^2^2^3020403^
"^DD",798.7,798.7,2,21,1,0)
Value of the JOB NUMBER field is the job number 
"^DD",798.7,798.7,2,21,2,0)
($JOB) of the process that has created this log.
"^DD",798.7,798.7,2,23,0)
^^2^2^3020403^
"^DD",798.7,798.7,2,23,1,0)
This field is populated automatically by the 
"^DD",798.7,798.7,2,23,2,0)
$$OPEN^RORLOG function.
"^DD",798.7,798.7,2,"DT")
3010813
"^DD",798.7,798.7,3,0)
REGISTRY^798.73P^^1;0
"^DD",798.7,798.7,3,21,0)
^^8^8^3020403^
"^DD",798.7,798.7,3,21,1,0)
This multiple contains a list of the registries 
"^DD",798.7,798.7,3,21,2,0)
that were processed. Events recorded in the log
"^DD",798.7,798.7,3,21,3,0)
are associated with these registries.
"^DD",798.7,798.7,3,21,4,0)
 
"^DD",798.7,798.7,3,21,5,0)
Records of this multiple are indexed by the "ARD"
"^DD",798.7,798.7,3,21,6,0)
index (whole file). So, it is possible to get a
"^DD",798.7,798.7,3,21,7,0)
list of log files associated with the particular
"^DD",798.7,798.7,3,21,8,0)
registry.
"^DD",798.7,798.7,4,0)
MESSAGE^798.74D^^2;0
"^DD",798.7,798.7,4,21,0)
^^2^2^3020403^
"^DD",798.7,798.7,4,21,1,0)
This multiple contains all messages recorded in 
"^DD",798.7,798.7,4,21,2,0)
the log.
"^DD",798.7,798.7,4,23,0)
^^4^4^3020403^
"^DD",798.7,798.7,4,23,1,0)
Every call of the LOG^RORLOG procedure adds a new 
"^DD",798.7,798.7,4,23,2,0)
record to this multiple. The $$OPEN^RORLOG and 
"^DD",798.7,798.7,4,23,3,0)
CLOSE^RORLOG entry points can also call the LOG^RORLOG
"^DD",798.7,798.7,4,23,4,0)
automatically to add header and footer to the log.
"^DD",798.7,798.7,5,0)
END DATE/TIME^D^^0;2^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798.7,798.7,5,21,0)
^^2^2^3020403^
"^DD",798.7,798.7,5,21,1,0)
This field contains the date/time when the 
"^DD",798.7,798.7,5,21,2,0)
log was closed.
"^DD",798.7,798.7,5,23,0)
^^2^2^3020403^
"^DD",798.7,798.7,5,23,1,0)
The CLOSE^RORLOG procedure populates this field
"^DD",798.7,798.7,5,23,2,0)
automatically when the log is closed.
"^DD",798.7,798.7,5,"DT")
3010807
"^DD",798.7,798.7,6.01,0)
PROCESSED PATIENTS^NJ12,0^^0;5^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.7,798.7,6.01,3)
Type a Number between 0 and 999999999999, 0 Decimal Digits.
"^DD",798.7,798.7,6.01,21,0)
^.001^2^2^3011011^^
"^DD",798.7,798.7,6.01,21,1,0)
The value of this field indicates the number of 
"^DD",798.7,798.7,6.01,21,2,0)
processed patients.
"^DD",798.7,798.7,6.01,23,0)
^.001^2^2^3020403^^
"^DD",798.7,798.7,6.01,23,1,0)
The value of this field is also duplicated in the last
"^DD",798.7,798.7,6.01,23,2,0)
message of the log (footer).
"^DD",798.7,798.7,6.01,"DT")
3010807
"^DD",798.7,798.7,6.02,0)
PATIENTS WITH ERRORS^NJ12,0^^0;6^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.7,798.7,6.02,3)
Type a Number between 0 and 999999999999, 0 Decimal Digits.
"^DD",798.7,798.7,6.02,21,0)
^^2^2^3011011^
"^DD",798.7,798.7,6.02,21,1,0)
The value of this field indicates the number of 
"^DD",798.7,798.7,6.02,21,2,0)
patients processed with errors.
"^DD",798.7,798.7,6.02,23,0)
^.001^2^2^3020403^^
"^DD",798.7,798.7,6.02,23,1,0)
The value of this field is also duplicated in the last
"^DD",798.7,798.7,6.02,23,2,0)
message of the log (footer).
"^DD",798.7,798.7,6.02,"DT")
3010807
"^DD",798.7,798.7,6.03,0)
RATE^NJ16,3^^0;7^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."4N.N) X
"^DD",798.7,798.7,6.03,3)
Type a Number between 0 and 999999999999, 3 Decimal Digits.
"^DD",798.7,798.7,6.03,21,0)
^^2^2^3011011^
"^DD",798.7,798.7,6.03,21,1,0)
The value of this field indicates the rate of 
"^DD",798.7,798.7,6.03,21,2,0)
patient processing (patients per second).
"^DD",798.7,798.7,6.03,23,0)
^.001^2^2^3020403^^
"^DD",798.7,798.7,6.03,23,1,0)
The value of this field is also duplicated in the last
"^DD",798.7,798.7,6.03,23,2,0)
message of the log (footer).
"^DD",798.7,798.7,6.03,"DT")
3010807
"^DD",798.7,798.7,7,0)
USER^P200'I^VA(200,^0;8^Q
"^DD",798.7,798.7,7,8.5)
@
"^DD",798.7,798.7,7,9)
@
"^DD",798.7,798.7,7,10)
The user's DUZ
"^DD",798.7,798.7,7,21,0)
^^3^3^3030219^
"^DD",798.7,798.7,7,21,1,0)
The USER field points to the VistA user associated
"^DD",798.7,798.7,7,21,2,0)
with the log (its internal value is the DUZ at the
"^DD",798.7,798.7,7,21,3,0)
moment when the log was created).
"^DD",798.7,798.7,7,"DT")
3030203
"^DD",798.7,798.73,0)
REGISTRY SUB-FIELD^^.01^1
"^DD",798.7,798.73,0,"DT")
3010807
"^DD",798.7,798.73,0,"IX","B",798.73,.01)

"^DD",798.7,798.73,0,"NM","REGISTRY")

"^DD",798.7,798.73,0,"UP")
798.7
"^DD",798.7,798.73,.01,0)
REGISTRY^MP798.1'X^ROR(798.1,^0;1^S:$D(X) DINUM=X
"^DD",798.7,798.73,.01,1,0)
^.1^^-1
"^DD",798.7,798.73,.01,1,1,0)
798.73^B
"^DD",798.7,798.73,.01,1,1,1)
S ^RORDATA(798.7,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",798.7,798.73,.01,1,1,2)
K ^RORDATA(798.7,DA(1),1,"B",$E(X,1,30),DA)
"^DD",798.7,798.73,.01,1,1,3)
Do not delete!
"^DD",798.7,798.73,.01,21,0)
^^4^4^3020403^
"^DD",798.7,798.73,.01,21,1,0)
The value of this field is a pointer to a record 
"^DD",798.7,798.73,.01,21,2,0)
of the ROR REGISTRY PARAMETERS file. The registry
"^DD",798.7,798.73,.01,21,3,0)
represented by that record was processed by the
"^DD",798.7,798.73,.01,21,4,0)
job that created this log.
"^DD",798.7,798.73,.01,"DT")
3010906
"^DD",798.7,798.74,0)
MESSAGE SUB-FIELD^^4^5
"^DD",798.7,798.74,0,"DT")
3011109
"^DD",798.7,798.74,0,"IX","B",798.74,.01)

"^DD",798.7,798.74,0,"NM","MESSAGE")

"^DD",798.7,798.74,0,"UP")
798.7
"^DD",798.7,798.74,.01,0)
DATE/TIME^MD^^0;1^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798.7,798.74,.01,1,0)
^.1
"^DD",798.7,798.74,.01,1,1,0)
798.74^B
"^DD",798.7,798.74,.01,1,1,1)
S ^RORDATA(798.7,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",798.7,798.74,.01,1,1,2)
K ^RORDATA(798.7,DA(1),2,"B",$E(X,1,30),DA)
"^DD",798.7,798.74,.01,1,1,3)
Do not delete!
"^DD",798.7,798.74,.01,21,0)
^^2^2^3011011^
"^DD",798.7,798.74,.01,21,1,0)
This field contains the date/time of the recorded
"^DD",798.7,798.74,.01,21,2,0)
event.
"^DD",798.7,798.74,.01,23,0)
^^2^2^3020403^
"^DD",798.7,798.74,.01,23,1,0)
The field is populated automatically by the LOG^RORLOG 
"^DD",798.7,798.74,.01,23,2,0)
procedure with the current date and time.
"^DD",798.7,798.74,.01,"DT")
3010807
"^DD",798.7,798.74,1,0)
TYPE^RS^1:Debug;2:Information;3:Data Quality;4:Warning;5:Database Error;6:Error;^0;2^Q
"^DD",798.7,798.74,1,21,0)
^^6^6^3020403^
"^DD",798.7,798.74,1,21,1,0)
The value of this field indicates the type of the
"^DD",798.7,798.74,1,21,2,0)
recorded event.
"^DD",798.7,798.74,1,21,3,0)
 
"^DD",798.7,798.74,1,21,4,0)
You can control which events are recorded and 
"^DD",798.7,798.74,1,21,5,0)
which are not via the LOG EVENTS multiple of the
"^DD",798.7,798.74,1,21,6,0)
ROR REGISTRY PARAMETERS file.
"^DD",798.7,798.74,1,"DT")
3010807
"^DD",798.7,798.74,2,0)
MESSAGE^RF^^2;E1,245^K:$L(X)>70!($L(X)<1) X
"^DD",798.7,798.74,2,3)
Answer must be 1-70 characters in length.
"^DD",798.7,798.74,2,21,0)
^^2^2^3011109^
"^DD",798.7,798.74,2,21,1,0)
This field contains a text message describing the 
"^DD",798.7,798.74,2,21,2,0)
recorded event.
"^DD",798.7,798.74,2,"DT")
3011109
"^DD",798.7,798.74,3,0)
PATIENT^P2'^DPT(^0;4^Q
"^DD",798.7,798.74,3,21,0)
^^3^3^3020403^
"^DD",798.7,798.74,3,21,1,0)
If the recorded event can be associated with a 
"^DD",798.7,798.74,3,21,2,0)
particular patient, this field contains a pointer 
"^DD",798.7,798.74,3,21,3,0)
to the patient record in the PATIENT file (DFN).
"^DD",798.7,798.74,3,"DT")
3010807
"^DD",798.7,798.74,4,0)
ADDITIONAL INFO^798.744^^1;0
"^DD",798.7,798.74,4,21,0)
^.001^2^2^3011011^^^
"^DD",798.7,798.74,4,21,1,0)
This field contains any additional information 
"^DD",798.7,798.74,4,21,2,0)
describing the event.
"^DD",798.7,798.744,0)
ADDITIONAL INFO SUB-FIELD^^.01^1
"^DD",798.7,798.744,0,"DT")
3010807
"^DD",798.7,798.744,0,"NM","ADDITIONAL INFO")

"^DD",798.7,798.744,0,"UP")
798.74
"^DD",798.7,798.744,.01,0)
ADDITIONAL INFO^WL^^0;1^Q
"^DD",798.7,798.744,.01,21,0)
^^2^2^3011011^
"^DD",798.7,798.744,.01,21,1,0)
This field contains any additional information 
"^DD",798.7,798.744,.01,21,2,0)
describing the event.
"^DD",798.7,798.744,.01,"DT")
3010807
"^DD",798.8,798.8,0)
FIELD^^7^15
"^DD",798.8,798.8,0,"DDA")
N
"^DD",798.8,798.8,0,"DT")
3040121
"^DD",798.8,798.8,0,"IX","ACDT",798.8,.07)

"^DD",798.8,798.8,0,"IX","ADUMMY",798.8,.03)

"^DD",798.8,798.8,0,"IX","ALOG",798.8,2.03)

"^DD",798.8,798.8,0,"IX","B",798.8,.01)

"^DD",798.8,798.8,0,"IX","U",798.8,.08)

"^DD",798.8,798.8,0,"NM","ROR TASK")

"^DD",798.8,798.8,0,"SCR")
I $$ACCESS^RORDD(798.8)
"^DD",798.8,798.8,0,"VRPK")
ROR
"^DD",798.8,798.8,.01,0)
TASK NUMBER^RNJ10,0XI^^0;1^K:+X'=X!(X>9899999999)!(X<1)!(X?.E1"."1N.N) X S:$D(X) DINUM=X
"^DD",798.8,798.8,.01,1,0)
^.1
"^DD",798.8,798.8,.01,1,1,0)
798.8^B
"^DD",798.8,798.8,.01,1,1,1)
S ^RORDATA(798.8,"B",$E(X,1,30),DA)=""
"^DD",798.8,798.8,.01,1,1,2)
K ^RORDATA(798.8,"B",$E(X,1,30),DA)
"^DD",798.8,798.8,.01,1,1,3)
Do not delete!
"^DD",798.8,798.8,.01,1,2,0)
^^TRIGGER^798.8^.07
"^DD",798.8,798.8,.01,1,2,1)
X ^DD(798.8,.01,1,2,1.3) I X S X=DIV S Y(1)=$S($D(^RORDATA(798.8,D0,0)):^(0),1:"") S X=$P(Y(1),U,7),X=X S DIU=X K Y S X=DIV S %=$P($H,",",2),X=DT_(%\60#60/100+(%\3600)+(%#60/10000)/100) X ^DD(798.8,.01,1,2,1.4)
"^DD",798.8,798.8,.01,1,2,1.3)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(0)=X S Y(1)=$S($D(^RORDATA(798.8,D0,0)):^(0),1:"") S X=$P(Y(1),U,7)=""
"^DD",798.8,798.8,.01,1,2,1.4)
S DIH=$G(^RORDATA(798.8,DIV(0),0)),DIV=X S $P(^(0),U,7)=DIV,DIH=798.8,DIG=.07 D ^DICR
"^DD",798.8,798.8,.01,1,2,2)
Q
"^DD",798.8,798.8,.01,1,2,3)
Do not delete!
"^DD",798.8,798.8,.01,1,2,"%D",0)
^^3^3^3030502^
"^DD",798.8,798.8,.01,1,2,"%D",1,0)
This trigger populates the CREATION TIME field 
"^DD",798.8,798.8,.01,1,2,"%D",2,0)
with the current date and time when the task is
"^DD",798.8,798.8,.01,1,2,"%D",3,0)
created.
"^DD",798.8,798.8,.01,1,2,"CREATE CONDITION")
CREATION TIME=""
"^DD",798.8,798.8,.01,1,2,"CREATE VALUE")
NOW
"^DD",798.8,798.8,.01,1,2,"DELETE VALUE")
NO EFFECT
"^DD",798.8,798.8,.01,1,2,"DT")
3021109
"^DD",798.8,798.8,.01,1,2,"FIELD")
CREATION TIME
"^DD",798.8,798.8,.01,1,3,0)
^^TRIGGER^798.8^.08
"^DD",798.8,798.8,.01,1,3,1)
X ^DD(798.8,.01,1,3,1.3) I X S X=DIV S Y(1)=$S($D(^RORDATA(798.8,D0,0)):^(0),1:"") S X=$P(Y(1),U,8),X=X S DIU=X K Y X ^DD(798.8,.01,1,3,1.1) S DIH=$G(^RORDATA(798.8,DIV(0),0)),DIV=X S $P(^(0),U,8)=DIV,DIH=798.8,DIG=.08 D ^DICR
"^DD",798.8,798.8,.01,1,3,1.1)
S X=DIV X ^DD(798.8,.01,1,3,49.2) S %=$S($D(^VA(200,+DUZ,0)):^(0),1:""),X=$S('DUZ:"??",X="#":DUZ,X="N":$P(%,U,1),X="I":$P(%,U,2),X="T":$S($D(^DIC(3.1,+$P(%,U,9),0)):$P(^(0),U,1),1:""),X="NN":$S($D(^VA(200,+DUZ,.1)):$P(^(.1),U,4),1:""),1:"??") K %
"^DD",798.8,798.8,.01,1,3,1.3)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(0)=X S Y(1)=$S($D(^RORDATA(798.8,D0,0)):^(0),1:"") S X=$S('$D(^VA(200,+$P(Y(1),U,8),0)):"",1:$P(^(0),U,1))=""
"^DD",798.8,798.8,.01,1,3,2)
Q
"^DD",798.8,798.8,.01,1,3,3)
Do not delete!
"^DD",798.8,798.8,.01,1,3,49.2)
S X="#"
"^DD",798.8,798.8,.01,1,3,"%D",0)
^^2^2^3030502^
"^DD",798.8,798.8,.01,1,3,"%D",1,0)
This trigger populates the USER field with the DUZ
"^DD",798.8,798.8,.01,1,3,"%D",2,0)
of the user who created the task.
"^DD",798.8,798.8,.01,1,3,"CREATE CONDITION")
USER=""
"^DD",798.8,798.8,.01,1,3,"CREATE VALUE")
USER("#")
"^DD",798.8,798.8,.01,1,3,"DELETE VALUE")
NO EFFECT
"^DD",798.8,798.8,.01,1,3,"DT")
3021109
"^DD",798.8,798.8,.01,1,3,"FIELD")
USER
"^DD",798.8,798.8,.01,3)
Type a Number between 1 and 9899999999, 0 Decimal Digits
"^DD",798.8,798.8,.01,8.5)
@
"^DD",798.8,798.8,.01,9)
@
"^DD",798.8,798.8,.01,21,0)
^^2^2^3030507^
"^DD",798.8,798.8,.01,21,1,0)
The TASK NUMBER field references the task created
"^DD",798.8,798.8,.01,21,2,0)
by Taskman.
"^DD",798.8,798.8,.01,23,0)
^.001^2^2^3030507^^
"^DD",798.8,798.8,.01,23,1,0)
Internal value of this field is used as the internal
"^DD",798.8,798.8,.01,23,2,0)
entry number of record ("DINUM" feature).
"^DD",798.8,798.8,.01,"DT")
3031027
"^DD",798.8,798.8,.02,0)
TYPE^RSI^1:Generic;2:Report;^0;2^Q
"^DD",798.8,798.8,.02,8.5)
@
"^DD",798.8,798.8,.02,9)
@
"^DD",798.8,798.8,.02,21,0)
^.001^1^1^3030507^^
"^DD",798.8,798.8,.02,21,1,0)
The TYPE field indicates the type of task.
"^DD",798.8,798.8,.02,23,0)
^^1^1^3030507^
"^DD",798.8,798.8,.02,23,1,0)
Currently only the 'Report' tasks are used.
"^DD",798.8,798.8,.02,"DT")
3031028
"^DD",798.8,798.8,.03,0)
REGISTRY^P798.1'I^ROR(798.1,^0;3^Q
"^DD",798.8,798.8,.03,1,0)
^.1
"^DD",798.8,798.8,.03,1,1,0)
798.8^ADUMMY^MUMPS
"^DD",798.8,798.8,.03,1,1,1)
Q
"^DD",798.8,798.8,.03,1,1,2)
Q
"^DD",798.8,798.8,.03,1,1,3)
Do not delete!
"^DD",798.8,798.8,.03,1,1,"%D",0)
^^4^4^3030507^
"^DD",798.8,798.8,.03,1,1,"%D",1,0)
This dummy cross-reference forces FileMan to flush
"^DD",798.8,798.8,.03,1,1,"%D",2,0)
data during editing a record.  This is required
"^DD",798.8,798.8,.03,1,1,"%D",3,0)
for the proper functioning of the REPORT field's
"^DD",798.8,798.8,.03,1,1,"%D",4,0)
screening logic.
"^DD",798.8,798.8,.03,1,1,"DT")
3021127
"^DD",798.8,798.8,.03,3)

"^DD",798.8,798.8,.03,8.5)
@
"^DD",798.8,798.8,.03,9)
@
"^DD",798.8,798.8,.03,21,0)
^^6^6^3030501^
"^DD",798.8,798.8,.03,21,1,0)
The REGISTRY field references the registry that 
"^DD",798.8,798.8,.03,21,2,0)
the task is associated with. 
"^DD",798.8,798.8,.03,21,3,0)
 
"^DD",798.8,798.8,.03,21,4,0)
If this field has no value then the task either
"^DD",798.8,798.8,.03,21,5,0)
works on several registries or does not affect any
"^DD",798.8,798.8,.03,21,6,0)
of them directly.
"^DD",798.8,798.8,.03,"DT")
3031028
"^DD",798.8,798.8,.04,0)
REPORT^P799.34'I^ROR(799.34,^0;4^Q
"^DD",798.8,798.8,.04,8.5)
@
"^DD",798.8,798.8,.04,9)
@
"^DD",798.8,798.8,.04,21,0)
^^3^3^3040121^
"^DD",798.8,798.8,.04,21,1,0)
The REPORT field indicates the report generated by
"^DD",798.8,798.8,.04,21,2,0)
the task.  This field has a value only if the type
"^DD",798.8,798.8,.04,21,3,0)
of task is 'Report' (see the TYPE field).
"^DD",798.8,798.8,.04,"DT")
3040121
"^DD",798.8,798.8,.05,0)
DESCRIPTION^F^^0;5^K:$L(X)>60!($L(X)<1) X
"^DD",798.8,798.8,.05,3)
Answer must be 1-60 characters in length.
"^DD",798.8,798.8,.05,8.5)
@
"^DD",798.8,798.8,.05,9)
@
"^DD",798.8,798.8,.05,21,0)
^^2^2^3030502^
"^DD",798.8,798.8,.05,21,1,0)
This field stores the description of task.  For
"^DD",798.8,798.8,.05,21,2,0)
the reports, it usually holds the report name.
"^DD",798.8,798.8,.05,"DT")
3021107
"^DD",798.8,798.8,.07,0)
CREATION TIME^RDI^^0;7^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",798.8,798.8,.07,1,0)
^.1
"^DD",798.8,798.8,.07,1,1,0)
798.8^ACDT
"^DD",798.8,798.8,.07,1,1,1)
S ^RORDATA(798.8,"ACDT",$E(X,1,30),DA)=""
"^DD",798.8,798.8,.07,1,1,2)
K ^RORDATA(798.8,"ACDT",$E(X,1,30),DA)
"^DD",798.8,798.8,.07,1,1,3)
Do not delete!
"^DD",798.8,798.8,.07,1,1,"%D",0)
^^2^2^3030502^
"^DD",798.8,798.8,.07,1,1,"%D",1,0)
The $$PURGE^RORTSK02 function uses the ACDT
"^DD",798.8,798.8,.07,1,1,"%D",2,0)
cross-reference to find and purge the old tasks.
"^DD",798.8,798.8,.07,1,1,"DT")
3030317
"^DD",798.8,798.8,.07,5,1,0)
798.8^.01^2
"^DD",798.8,798.8,.07,8.5)
@
"^DD",798.8,798.8,.07,9)
@
"^DD",798.8,798.8,.07,21,0)
^^4^4^3030502^
"^DD",798.8,798.8,.07,21,1,0)
The CREATION TIME field stores the date and time 
"^DD",798.8,798.8,.07,21,2,0)
when the task was created.  This field is
"^DD",798.8,798.8,.07,21,3,0)
populated by the trigger associated with the TASK
"^DD",798.8,798.8,.07,21,4,0)
NUMBER field.
"^DD",798.8,798.8,.07,"DT")
3030317
"^DD",798.8,798.8,.08,0)
USER^RP200'I^VA(200,^0;8^Q
"^DD",798.8,798.8,.08,1,0)
^.1
"^DD",798.8,798.8,.08,1,1,0)
798.8^U
"^DD",798.8,798.8,.08,1,1,1)
S ^RORDATA(798.8,"U",$E(X,1,30),DA)=""
"^DD",798.8,798.8,.08,1,1,2)
K ^RORDATA(798.8,"U",$E(X,1,30),DA)
"^DD",798.8,798.8,.08,1,1,3)
Do not delete!
"^DD",798.8,798.8,.08,1,1,"%D",0)
^^2^2^3031210^
"^DD",798.8,798.8,.08,1,1,"%D",1,0)
This cross-reference is used to select only the
"^DD",798.8,798.8,.08,1,1,"%D",2,0)
tasks created by a particular user.
"^DD",798.8,798.8,.08,1,1,"DT")
3021109
"^DD",798.8,798.8,.08,5,1,0)
798.8^.01^3
"^DD",798.8,798.8,.08,8.5)
@
"^DD",798.8,798.8,.08,9)
@
"^DD",798.8,798.8,.08,21,0)
^^3^3^3030502^
"^DD",798.8,798.8,.08,21,1,0)
The USER field references the VistA user who
"^DD",798.8,798.8,.08,21,2,0)
created the task.  This field is populated by the
"^DD",798.8,798.8,.08,21,3,0)
trigger associated with the TASK NUMBER field.
"^DD",798.8,798.8,.08,"DT")
3021109
"^DD",798.8,798.8,2.01,0)
STATUS^S^3:Inactive> Finished;5:Inactive> Interrupted;100:Inactive> Crashed;101:Inactive> Errors;102:Active> Suspended;103:Active> Stopping;^2;1^Q
"^DD",798.8,798.8,2.01,3)

"^DD",798.8,798.8,2.01,8.5)
@
"^DD",798.8,798.8,2.01,9)
@
"^DD",798.8,798.8,2.01,21,0)
^^3^3^3030502^
"^DD",798.8,798.8,2.01,21,1,0)
The STATUS field stores the current status of the
"^DD",798.8,798.8,2.01,21,2,0)
task.  The values of this field are used along
"^DD",798.8,798.8,2.01,21,3,0)
with those returned by the STAT^%ZTLOAD procedure.
"^DD",798.8,798.8,2.01,23,0)
^^6^6^3030507^
"^DD",798.8,798.8,2.01,23,1,0)
The codes 3 and 5 are duplicated here so that the most
"^DD",798.8,798.8,2.01,23,2,0)
recent status of task will be known even if the task is
"^DD",798.8,798.8,2.01,23,3,0)
deleted by Taskman.
"^DD",798.8,798.8,2.01,23,4,0)
 
"^DD",798.8,798.8,2.01,23,5,0)
Please do not try to analyze this field yourself, use 
"^DD",798.8,798.8,2.01,23,6,0)
the $$STATUS^RORTSK function instead.
"^DD",798.8,798.8,2.01,"DT")
3031201
"^DD",798.8,798.8,2.02,0)
COMPLETION TIME^D^^2;2^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",798.8,798.8,2.02,3)

"^DD",798.8,798.8,2.02,8.5)
@
"^DD",798.8,798.8,2.02,9)
@
"^DD",798.8,798.8,2.02,21,0)
^^3^3^3030501^
"^DD",798.8,798.8,2.02,21,1,0)
The task populates the COMPLETION TIME field with
"^DD",798.8,798.8,2.02,21,2,0)
the current date and time right before the task is
"^DD",798.8,798.8,2.02,21,3,0)
completed.
"^DD",798.8,798.8,2.02,23,0)
^^7^7^3030507^
"^DD",798.8,798.8,2.02,23,1,0)
This field has no value in the following cases:
"^DD",798.8,798.8,2.02,23,2,0)
 
"^DD",798.8,798.8,2.02,23,3,0)
 * the task has not started yet;
"^DD",798.8,798.8,2.02,23,4,0)
 * the task is still running;
"^DD",798.8,798.8,2.02,23,5,0)
 * the task has crashed;
"^DD",798.8,798.8,2.02,23,6,0)
 * the task has not populated the field
"^DD",798.8,798.8,2.02,23,7,0)
   due to poor design.
"^DD",798.8,798.8,2.02,"DT")
3030317
"^DD",798.8,798.8,2.03,0)
LOG^P798.7'^RORDATA(798.7,^2;3^Q
"^DD",798.8,798.8,2.03,1,0)
^.1
"^DD",798.8,798.8,2.03,1,1,0)
798.8^ALOG^MUMPS
"^DD",798.8,798.8,2.03,1,1,1)
S ^RORDATA(798.7,"AREF",X,798.8,DA_",",2.03)=""
"^DD",798.8,798.8,2.03,1,1,2)
K ^RORDATA(798.7,"AREF",X,798.8,DA_",",2.03)
"^DD",798.8,798.8,2.03,1,1,3)
Do not delete!
"^DD",798.8,798.8,2.03,1,1,"%D",0)
^^24^24^3030502^
"^DD",798.8,798.8,2.03,1,1,"%D",1,0)
The logic of the ALOG cross-reference maintains a
"^DD",798.8,798.8,2.03,1,1,"%D",2,0)
list of references from the ROR TASK file to the
"^DD",798.8,798.8,2.03,1,1,"%D",3,0)
ROR LOG file.  This list allows the function that
"^DD",798.8,798.8,2.03,1,1,"%D",4,0)
purges the old logs ($$PURGE^RORLOG01) either to 
"^DD",798.8,798.8,2.03,1,1,"%D",5,0)
keep those logs that are referenced from other
"^DD",798.8,798.8,2.03,1,1,"%D",6,0)
files or to remove the references.
"^DD",798.8,798.8,2.03,1,1,"%D",7,0)
                     
"^DD",798.8,798.8,2.03,1,1,"%D",8,0)
The list is stored under the "AREF" subscript in
"^DD",798.8,798.8,2.03,1,1,"%D",9,0)
the ROR LOG file (#798.7) and has the following 
"^DD",798.8,798.8,2.03,1,1,"%D",10,0)
structure:
"^DD",798.8,798.8,2.03,1,1,"%D",11,0)
                     
"^DD",798.8,798.8,2.03,1,1,"%D",12,0)
 ^RORDATA(798.7,"AREF",<Log>,798.8,<IENS>,2.03)
"^DD",798.8,798.8,2.03,1,1,"%D",13,0)
                     
"^DD",798.8,798.8,2.03,1,1,"%D",14,0)
The <Log> is the IEN of the log that is associated
"^DD",798.8,798.8,2.03,1,1,"%D",15,0)
with the task (internal value of the LOG field).
"^DD",798.8,798.8,2.03,1,1,"%D",16,0)
                     
"^DD",798.8,798.8,2.03,1,1,"%D",17,0)
The 798.8 is the number of the file from where the
"^DD",798.8,798.8,2.03,1,1,"%D",18,0)
log is referenced (ROR TASK).
"^DD",798.8,798.8,2.03,1,1,"%D",19,0)
                     
"^DD",798.8,798.8,2.03,1,1,"%D",20,0)
The <IENS> is the IENS of the record that
"^DD",798.8,798.8,2.03,1,1,"%D",21,0)
references the log.
"^DD",798.8,798.8,2.03,1,1,"%D",22,0)
                     
"^DD",798.8,798.8,2.03,1,1,"%D",23,0)
The 2.03 is the number of the field that points to
"^DD",798.8,798.8,2.03,1,1,"%D",24,0)
the log (the LOG field).
"^DD",798.8,798.8,2.03,1,1,"DT")
3030318
"^DD",798.8,798.8,2.03,8.5)
@
"^DD",798.8,798.8,2.03,9)
@
"^DD",798.8,798.8,2.03,21,0)
^^2^2^3030501^
"^DD",798.8,798.8,2.03,21,1,0)
The LOG field references the log created by the 
"^DD",798.8,798.8,2.03,21,2,0)
task.
"^DD",798.8,798.8,2.03,23,0)
^^2^2^3030501^
"^DD",798.8,798.8,2.03,23,1,0)
The proxy task used by the reports (TASK^RORTSK01)
"^DD",798.8,798.8,2.03,23,2,0)
always creates a log and populates this field.
"^DD",798.8,798.8,2.03,"DT")
3030318
"^DD",798.8,798.8,2.04,0)
JOB NUMBER^NJ12,0^^2;4^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.8,798.8,2.04,3)
Type a Number between 1 and 999999999999, 0 Decimal Digits
"^DD",798.8,798.8,2.04,8.5)
@
"^DD",798.8,798.8,2.04,9)
@
"^DD",798.8,798.8,2.04,21,0)
^^3^3^3030501^
"^DD",798.8,798.8,2.04,21,1,0)
When the task is running, the JOB NUMBER field
"^DD",798.8,798.8,2.04,21,2,0)
holds the job number that is assigned to the task
"^DD",798.8,798.8,2.04,21,3,0)
by the M system.
"^DD",798.8,798.8,2.04,23,0)
^^3^3^3030501^
"^DD",798.8,798.8,2.04,23,1,0)
If the task crashes, this field retains its value. 
"^DD",798.8,798.8,2.04,23,2,0)
Otherwise, it is cleared right before the task finishes
"^DD",798.8,798.8,2.04,23,3,0)
(see the $$EXIT^RORTSK01 function).
"^DD",798.8,798.8,2.04,"DT")
3021109
"^DD",798.8,798.8,3,0)
SUBTASK^798.83^^T;0
"^DD",798.8,798.8,3,9)
@
"^DD",798.8,798.8,3,21,0)
^.001^2^2^3030507^^
"^DD",798.8,798.8,3,21,1,0)
The SUBTASK multiple contains a list of subtasks 
"^DD",798.8,798.8,3,21,2,0)
started by the main task.
"^DD",798.8,798.8,3,23,0)
^^2^2^3030507^
"^DD",798.8,798.8,3,23,1,0)
The subtask functionality has not been implemented yet.
"^DD",798.8,798.8,3,23,2,0)
This multiple is reserved for future use.
"^DD",798.8,798.8,4,0)
PROGRESS^NJ7,3^^P;E1,255^K:+X'=X!(X>100)!(X<0)!(X?.E1"."4N.N) X
"^DD",798.8,798.8,4,3)
Type a Number between 0 and 100, 3 Decimal Digits
"^DD",798.8,798.8,4,8.5)
@
"^DD",798.8,798.8,4,9)
@
"^DD",798.8,798.8,4,21,0)
^^4^4^3030502^
"^DD",798.8,798.8,4,21,1,0)
The PROGRES field stores the percentage of 
"^DD",798.8,798.8,4,21,2,0)
completion of the task.  If the task does not 
"^DD",798.8,798.8,4,21,3,0)
explicitly support this feature, the field is 
"^DD",798.8,798.8,4,21,4,0)
always empty.
"^DD",798.8,798.8,4,23,0)
^.001^3^3^3030502^^^
"^DD",798.8,798.8,4,23,1,0)
The task can update the value of this field using the 
"^DD",798.8,798.8,4,23,2,0)
parameter of the $$LOOP^RORTSK01 function that should 
"^DD",798.8,798.8,4,23,3,0)
be called in the main loop of the task.
"^DD",798.8,798.8,4,"DT")
3021114
"^DD",798.8,798.8,5,0)
ACTION^S^1:Suspend;2:Stop;^A;E1,255^Q
"^DD",798.8,798.8,5,8.5)
@
"^DD",798.8,798.8,5,9)
@
"^DD",798.8,798.8,5,21,0)
^^3^3^3030502^
"^DD",798.8,798.8,5,21,1,0)
Values of the ACTION field control the task
"^DD",798.8,798.8,5,21,2,0)
behavior.  You can either suspend/resume or stop
"^DD",798.8,798.8,5,21,3,0)
the task
"^DD",798.8,798.8,5,23,0)
^^7^7^3030502^
"^DD",798.8,798.8,5,23,1,0)
Please do not modify this field directly.  Use the 
"^DD",798.8,798.8,5,23,2,0)
$$DEQUEUE^RORTSK function to stop the task, and the
"^DD",798.8,798.8,5,23,3,0)
$$SUSPEND^RORTSK02 and $$RESUME^RORTSK02 functions to
"^DD",798.8,798.8,5,23,4,0)
suspend/resume it.
"^DD",798.8,798.8,5,23,5,0)
 
"^DD",798.8,798.8,5,23,6,0)
The task can also be stopped using the Stop task option
"^DD",798.8,798.8,5,23,7,0)
of the Taskman User menu (see the User's Toolbox menu).
"^DD",798.8,798.8,5,"DT")
3021114
"^DD",798.8,798.8,7,0)
REPORT ELEMENT^798.87P^^RI;0
"^DD",798.8,798.8,7,9)
@
"^DD",798.8,798.8,7,21,0)
^.001^18^18^3030501^^^
"^DD",798.8,798.8,7,21,1,0)
The REPORT ELEMENT multiple stores the output of 
"^DD",798.8,798.8,7,21,2,0)
the 'Report' task (see the TYPE field).
"^DD",798.8,798.8,7,21,3,0)
 
"^DD",798.8,798.8,7,21,4,0)
A report is stored as a tree of XML elements. Each
"^DD",798.8,798.8,7,21,5,0)
element can contain some text, a single-line value
"^DD",798.8,798.8,7,21,6,0)
or no value at all. Several attributes can be 
"^DD",798.8,798.8,7,21,7,0)
associated with the element. Valid element and
"^DD",798.8,798.8,7,21,8,0)
attribute names are stored in the ROR XML ELEMENT 
"^DD",798.8,798.8,7,21,9,0)
and ROR XML ATTRIBUTE files.
"^DD",798.8,798.8,7,21,10,0)
 
"^DD",798.8,798.8,7,21,11,0)
Storing the XML document in this sparse format
"^DD",798.8,798.8,7,21,12,0)
allows to perform sorting on predefined fields
"^DD",798.8,798.8,7,21,13,0)
(on the server) when the report is created.
"^DD",798.8,798.8,7,21,14,0)
 
"^DD",798.8,798.8,7,21,15,0)
If you do not need this functionality, you can 
"^DD",798.8,798.8,7,21,16,0)
generate a report as a single element (in terms 
"^DD",798.8,798.8,7,21,17,0)
of this multiple) that contains the whole XML 
"^DD",798.8,798.8,7,21,18,0)
document.
"^DD",798.8,798.8,7,23,0)
^.001^2^2^3030501^^
"^DD",798.8,798.8,7,23,1,0)
Please do not edit this multiple directly. Use the API 
"^DD",798.8,798.8,7,23,2,0)
defined in the RORTSK1 routine instead.
"^DD",798.8,798.8,7,"DT")
3021129
"^DD",798.8,798.83,0)
SUBTASK SUB-FIELD^^.01^2
"^DD",798.8,798.83,0,"DT")
3021113
"^DD",798.8,798.83,0,"NM","SUBTASK")

"^DD",798.8,798.83,0,"UP")
798.8
"^DD",798.8,798.83,.001,0)
NUMBER^NJ10,0^^ ^K:+X'=X!(X>9899999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.8,798.83,.001,3)
Type a Number between 1 and 9899999999, 0 Decimal Digits
"^DD",798.8,798.83,.001,8.5)
@
"^DD",798.8,798.83,.001,9)
@
"^DD",798.8,798.83,.001,21,0)
^^2^2^3030501^
"^DD",798.8,798.83,.001,21,1,0)
This is the record IEN that should be equal to the
"^DD",798.8,798.83,.001,21,2,0)
subtask number.
"^DD",798.8,798.83,.001,"DT")
3021113
"^DD",798.8,798.83,.01,0)
STATUS^MF^^0;1^K:$L(X)>10!($L(X)<1) X
"^DD",798.8,798.83,.01,1,0)
^.1^^0
"^DD",798.8,798.83,.01,3)
Answer must be 1-10 characters in length.
"^DD",798.8,798.83,.01,8.5)
@
"^DD",798.8,798.83,.01,9)
@
"^DD",798.8,798.83,.01,21,0)
^^2^2^3030501^
"^DD",798.8,798.83,.01,21,1,0)
The current status of the subtask is stored in 
"^DD",798.8,798.83,.01,21,2,0)
this field.
"^DD",798.8,798.83,.01,"DT")
3021113
"^DD",798.8,798.87,0)
REPORT ELEMENT SUB-FIELD^^.04^7
"^DD",798.8,798.87,0,"DT")
3031020
"^DD",798.8,798.87,0,"IX","B",798.87,.01)

"^DD",798.8,798.87,0,"NM","REPORT ELEMENT")

"^DD",798.8,798.87,0,"UP")
798.8
"^DD",798.8,798.87,.01,0)
REPORT ELEMENT^MP799.31'^ROR(799.31,^0;1^Q
"^DD",798.8,798.87,.01,1,0)
^.1
"^DD",798.8,798.87,.01,1,1,0)
798.87^B
"^DD",798.8,798.87,.01,1,1,1)
S ^RORDATA(798.8,DA(1),"RI","B",$E(X,1,30),DA)=""
"^DD",798.8,798.87,.01,1,1,2)
K ^RORDATA(798.8,DA(1),"RI","B",$E(X,1,30),DA)
"^DD",798.8,798.87,.01,1,1,3)
Do not delete!
"^DD",798.8,798.87,.01,1,1,"DT")
3021129
"^DD",798.8,798.87,.01,3)

"^DD",798.8,798.87,.01,8.5)
@
"^DD",798.8,798.87,.01,9)
@
"^DD",798.8,798.87,.01,21,0)
^^2^2^3030501^
"^DD",798.8,798.87,.01,21,1,0)
The REPORT ELEMENT field references the XML 
"^DD",798.8,798.87,.01,21,2,0)
element (tag) that is a part of the report.
"^DD",798.8,798.87,.01,"DT")
3030819
"^DD",798.8,798.87,.02,0)
PARENT^NJ12,0^^0;2^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.8,798.87,.02,3)
Type a Number between 1 and 999999999999, 0 Decimal Digits
"^DD",798.8,798.87,.02,8.5)
@
"^DD",798.8,798.87,.02,9)
@
"^DD",798.8,798.87,.02,21,0)
^^3^3^3030501^
"^DD",798.8,798.87,.02,21,1,0)
The PARENT field stores the IEN of the record of 
"^DD",798.8,798.87,.02,21,2,0)
the REPORT ELEMENT multiple that represents the
"^DD",798.8,798.87,.02,21,3,0)
parent element for this one.
"^DD",798.8,798.87,.02,"DT")
3030819
"^DD",798.8,798.87,.03,0)
SORT BY^S^0:NO;1:AS-IS;2:STRING;3:NUMBER;^0;3^Q
"^DD",798.8,798.87,.03,8.5)
@
"^DD",798.8,798.87,.03,9)
@
"^DD",798.8,798.87,.03,21,0)
^.001^6^6^3030723^^
"^DD",798.8,798.87,.03,21,1,0)
If the SORT field is set to YES then a special
"^DD",798.8,798.87,.03,21,2,0)
cross-reference is built using the value of this 
"^DD",798.8,798.87,.03,21,3,0)
element and the IEN of its parent element.
"^DD",798.8,798.87,.03,21,4,0)
 
"^DD",798.8,798.87,.03,21,5,0)
Only those elements that have single-line values 
"^DD",798.8,798.87,.03,21,6,0)
can be sorted.
"^DD",798.8,798.87,.03,23,0)
^.001^26^26^3030723^^^
"^DD",798.8,798.87,.03,23,1,0)
For example, let us assume the report has the following
"^DD",798.8,798.87,.03,23,2,0)
structure:
"^DD",798.8,798.87,.03,23,3,0)
 
"^DD",798.8,798.87,.03,23,4,0)
  <REPORT>
"^DD",798.8,798.87,.03,23,5,0)
   <HEADER>
"^DD",798.8,798.87,.03,23,6,0)
   ...
"^DD",798.8,798.87,.03,23,7,0)
   </HEADER>
"^DD",798.8,798.87,.03,23,8,0)
   <PATIENTS>
"^DD",798.8,798.87,.03,23,9,0)
    <PATIENT>
"^DD",798.8,798.87,.03,23,10,0)
     <NAME> ... </NAME>
"^DD",798.8,798.87,.03,23,11,0)
     <DOB> ... </DOB>
"^DD",798.8,798.87,.03,23,12,0)
     <SELRULES>
"^DD",798.8,798.87,.03,23,13,0)
      <RULE>
"^DD",798.8,798.87,.03,23,14,0)
       <NAME> ... </NAME>
"^DD",798.8,798.87,.03,23,15,0)
       <DATE> ... </DATE>
"^DD",798.8,798.87,.03,23,16,0)
      </RULE>
"^DD",798.8,798.87,.03,23,17,0)
      ...
"^DD",798.8,798.87,.03,23,18,0)
     </SELRULES>
"^DD",798.8,798.87,.03,23,19,0)
    </PATIENT>
"^DD",798.8,798.87,.03,23,20,0)
    ...
"^DD",798.8,798.87,.03,23,21,0)
   </PATIENTS>
"^DD",798.8,798.87,.03,23,22,0)
  </REPORT>
"^DD",798.8,798.87,.03,23,23,0)
 
"^DD",798.8,798.87,.03,23,24,0)
If the SORT BY field is set to YES for the NAME child
"^DD",798.8,798.87,.03,23,25,0)
element of each PATIENT element then the patients will
"^DD",798.8,798.87,.03,23,26,0)
be sorted by their names.
"^DD",798.8,798.87,.03,"DT")
3030819
"^DD",798.8,798.87,.04,0)
IGNORE^S^0:NO;1:YES;^0;4^Q
"^DD",798.8,798.87,.04,21,0)
^^3^3^3030924^
"^DD",798.8,798.87,.04,21,1,0)
If the IGNORE field is set to 'YES' then the 
"^DD",798.8,798.87,.04,21,2,0)
report element and all its descendands will not be
"^DD",798.8,798.87,.04,21,3,0)
rendered into the resulting XML document.
"^DD",798.8,798.87,.04,"DT")
3030924
"^DD",798.8,798.87,1,0)
VALUE^F^^1;E1,245^K:$L(X)>245!($L(X)<1) X
"^DD",798.8,798.87,1,3)
Answer must be 1-245 characters in length.
"^DD",798.8,798.87,1,8.5)
@
"^DD",798.8,798.87,1,9)
@
"^DD",798.8,798.87,1,21,0)
^^5^5^3030502^
"^DD",798.8,798.87,1,21,1,0)
The VALUE field stores the single-line value of 
"^DD",798.8,798.87,1,21,2,0)
the element.  For example, if the "SMITH, JOHN" is
"^DD",798.8,798.87,1,21,3,0)
stored as the value of the NAME element then the
"^DD",798.8,798.87,1,21,4,0)
corresponding fragment of the XML document will
"^DD",798.8,798.87,1,21,5,0)
look as follow: <NAME>SMITH, JOHN</NAME>.
"^DD",798.8,798.87,1,"DT")
3030819
"^DD",798.8,798.87,2,0)
ATTRIBUTE^798.872P^^2;0
"^DD",798.8,798.87,2,9)
@
"^DD",798.8,798.87,2,21,0)
^.001^3^3^3030502^^
"^DD",798.8,798.87,2,21,1,0)
The ATTRIBUTE multiple contains a list of XML
"^DD",798.8,798.87,2,21,2,0)
attributes (and their values) associated with the 
"^DD",798.8,798.87,2,21,3,0)
element.
"^DD",798.8,798.87,3,0)
TEXT^798.873^^3;0
"^DD",798.8,798.87,3,9)
@
"^DD",798.8,798.87,3,21,0)
^^8^8^3030502^
"^DD",798.8,798.87,3,21,1,0)
The TEXT field stores the text (multi-line) value
"^DD",798.8,798.87,3,21,2,0)
of the element.  Let us take the DESCRIPTION
"^DD",798.8,798.87,3,21,3,0)
element as an example.  The corresponding fragment
"^DD",798.8,798.87,3,21,4,0)
of the XML document for the will look as follow:
"^DD",798.8,798.87,3,21,5,0)
 
"^DD",798.8,798.87,3,21,6,0)
  <DESCRIPTION>
"^DD",798.8,798.87,3,21,7,0)
  ... Text from this field ...
"^DD",798.8,798.87,3,21,8,0)
  </DESCRIPTION>
"^DD",798.8,798.872,0)
ATTRIBUTE SUB-FIELD^^1^2
"^DD",798.8,798.872,0,"DT")
3031020
"^DD",798.8,798.872,0,"IX","B",798.872,.01)

"^DD",798.8,798.872,0,"NM","ATTRIBUTE")

"^DD",798.8,798.872,0,"UP")
798.87
"^DD",798.8,798.872,.01,0)
ATTRIBUTE^MP799.31'X^ROR(799.31,^0;1^S:$D(X) DINUM=X
"^DD",798.8,798.872,.01,1,0)
^.1
"^DD",798.8,798.872,.01,1,1,0)
798.872^B
"^DD",798.8,798.872,.01,1,1,1)
S ^RORDATA(798.8,DA(2),"RI",DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",798.8,798.872,.01,1,1,2)
K ^RORDATA(798.8,DA(2),"RI",DA(1),2,"B",$E(X,1,30),DA)
"^DD",798.8,798.872,.01,1,1,3)
Do not delete!
"^DD",798.8,798.872,.01,1,1,"DT")
3030502
"^DD",798.8,798.872,.01,8.5)
@
"^DD",798.8,798.872,.01,9)
@
"^DD",798.8,798.872,.01,21,0)
^.001^2^2^3031020^^^^
"^DD",798.8,798.872,.01,21,1,0)
The ATTRIBUTE field references an XML attribute
"^DD",798.8,798.872,.01,21,2,0)
associated with the report element (tag).
"^DD",798.8,798.872,.01,"DT")
3031020
"^DD",798.8,798.872,1,0)
VALUE^F^^1;E1,245^K:$L(X)>245!($L(X)<1) X
"^DD",798.8,798.872,1,3)
Answer must be 1-245 characters in length.
"^DD",798.8,798.872,1,8.5)
@
"^DD",798.8,798.872,1,9)
@
"^DD",798.8,798.872,1,21,0)
^^5^5^3030502^
"^DD",798.8,798.872,1,21,1,0)
The VALUE field stores the attribute value.  For
"^DD",798.8,798.872,1,21,2,0)
example, if 193 is stored as the value of the ID
"^DD",798.8,798.872,1,21,3,0)
attribute of the PATIENT report element then the
"^DD",798.8,798.872,1,21,4,0)
corresponding fragment of the XML document will
"^DD",798.8,798.872,1,21,5,0)
look like as follow: <PATIENT ID="193">.
"^DD",798.8,798.872,1,"DT")
3021130
"^DD",798.8,798.873,0)
TEXT SUB-FIELD^^.01^1
"^DD",798.8,798.873,0,"DT")
3021130
"^DD",798.8,798.873,0,"NM","TEXT")

"^DD",798.8,798.873,0,"UP")
798.87
"^DD",798.8,798.873,.01,0)
TEXT^WL^^0;1^Q
"^DD",798.8,798.873,.01,8.5)
@
"^DD",798.8,798.873,.01,9)
@
"^DD",798.8,798.873,.01,21,0)
^^2^2^3030502^
"^DD",798.8,798.873,.01,21,1,0)
This is a line of the text value of the report 
"^DD",798.8,798.873,.01,21,2,0)
element.
"^DD",798.8,798.873,.01,"DT")
3021130
"^DD",798.9,798.9,0)
FIELD^^2^4
"^DD",798.9,798.9,0,"DDA")
N
"^DD",798.9,798.9,0,"DT")
3031006
"^DD",798.9,798.9,0,"IX","ALN",798.92,.01)

"^DD",798.9,798.9,0,"IX","ANLT",798.92,.02)

"^DD",798.9,798.9,0,"NM","ROR LAB SEARCH")

"^DD",798.9,798.9,0,"VRPK")
ROR
"^DD",798.9,798.9,.01,0)
NAME^RFX^^0;1^Q:$$VAEDT^RORDD(798.9,$G(DA))  K:$L(X)>30!($L(X)<3) X
"^DD",798.9,798.9,.01,1,0)
^.1^^0
"^DD",798.9,798.9,.01,3)
Enter a unique name spaced criterion name (3-30 characters).
"^DD",798.9,798.9,.01,8.5)
@
"^DD",798.9,798.9,.01,9)
@
"^DD",798.9,798.9,.01,21,0)
^^6^6^3011016^
"^DD",798.9,798.9,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.9,798.9,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.9,798.9,.01,21,3,0)
 
"^DD",798.9,798.9,.01,21,4,0)
The criterion name must be unique and name spaced.
"^DD",798.9,798.9,.01,21,5,0)
The names that are used for National Registries
"^DD",798.9,798.9,.01,21,6,0)
must start with "VA".
"^DD",798.9,798.9,.01,"DEL",1,0)
I $$VADEL^RORDD(798.9,$G(DA))
"^DD",798.9,798.9,.01,"DT")
3010720
"^DD",798.9,798.9,.09,0)
NATIONAL^SX^0:NO;1:YES;^0;3^Q:$$VAEDT^RORDD(798.9,,-1)
"^DD",798.9,798.9,.09,8.5)
@
"^DD",798.9,798.9,.09,9)
@
"^DD",798.9,798.9,.09,21,0)
^^6^6^3020403^
"^DD",798.9,798.9,.09,21,1,0)
ONLY AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN
"^DD",798.9,798.9,.09,21,2,0)
EDIT THIS FIELD!
"^DD",798.9,798.9,.09,21,3,0)
 
"^DD",798.9,798.9,.09,21,4,0)
The national registries must have this field set
"^DD",798.9,798.9,.09,21,5,0)
to "Yes". This prevents local editing of other
"^DD",798.9,798.9,.09,21,6,0)
fields of national registry definitions.
"^DD",798.9,798.9,.09,"DEL",1,0)
I $$VADEL^RORDD(798.9,,-1)
"^DD",798.9,798.9,.09,"DT")
3011119
"^DD",798.9,798.9,1,0)
STATUS^S^0:ACTIVE;1:INACTIVE;^0;2^Q
"^DD",798.9,798.9,1,21,0)
^^2^2^3020403^
"^DD",798.9,798.9,1,21,1,0)
Select the "INACTIVE" code if you want to disable
"^DD",798.9,798.9,1,21,2,0)
the criterion temporarily.
"^DD",798.9,798.9,1,"DT")
3011016
"^DD",798.9,798.9,2,0)
LAB TEST^798.92^^1;0
"^DD",798.9,798.9,2,9)
@
"^DD",798.9,798.9,2,21,0)
^^9^9^3011119^
"^DD",798.9,798.9,2,21,1,0)
This multiple contains a list of the Lab search 
"^DD",798.9,798.9,2,21,2,0)
indicators used by the registry update process.
"^DD",798.9,798.9,2,21,3,0)
 
"^DD",798.9,798.9,2,21,4,0)
If at least one of the indicators is evaluated as 
"^DD",798.9,798.9,2,21,5,0)
True, the macro referencing the search criterion
"^DD",798.9,798.9,2,21,6,0)
will be evaluated as True as well.
"^DD",798.9,798.9,2,21,7,0)
 
"^DD",798.9,798.9,2,21,8,0)
This multiple can contain several records for the
"^DD",798.9,798.9,2,21,9,0)
same Lab test.
"^DD",798.9,798.92,0)
LAB TEST SUB-FIELD^^2^4
"^DD",798.9,798.92,0,"DT")
3031006
"^DD",798.9,798.92,0,"IX","B",798.92,.01)

"^DD",798.9,798.92,0,"NM","LAB TEST")

"^DD",798.9,798.92,0,"UP")
798.9
"^DD",798.9,798.92,.01,0)
LOINC CODE^MNJ7,0^^0;1^K:+X'=X!(X>9999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.9,798.92,.01,1,0)
^.1
"^DD",798.9,798.92,.01,1,1,0)
798.92^B
"^DD",798.9,798.92,.01,1,1,1)
S ^ROR(798.9,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",798.9,798.92,.01,1,1,2)
K ^ROR(798.9,DA(1),1,"B",$E(X,1,30),DA)
"^DD",798.9,798.92,.01,1,1,3)
Do not delete!
"^DD",798.9,798.92,.01,1,2,0)
798.9^ALN
"^DD",798.9,798.92,.01,1,2,1)
S ^ROR(798.9,"ALN",$E(X,1,30),DA(1),DA)=""
"^DD",798.9,798.92,.01,1,2,2)
K ^ROR(798.9,"ALN",$E(X,1,30),DA(1),DA)
"^DD",798.9,798.92,.01,1,2,3)
Do not delete!
"^DD",798.9,798.92,.01,1,2,"%D",0)
^^3^3^3011016^
"^DD",798.9,798.92,.01,1,2,"%D",1,0)
This cross-reference can be used to find all 
"^DD",798.9,798.92,.01,1,2,"%D",2,0)
criteria that look for the Lab results with the
"^DD",798.9,798.92,.01,1,2,"%D",3,0)
particular LOINC code.
"^DD",798.9,798.92,.01,1,2,"DT")
3010621
"^DD",798.9,798.92,.01,3)
Enter the LOINC code without a control digit.
"^DD",798.9,798.92,.01,8.5)
@
"^DD",798.9,798.92,.01,9)
@
"^DD",798.9,798.92,.01,21,0)
^.001^4^4^3011119^^
"^DD",798.9,798.92,.01,21,1,0)
Enter the numeric LOINC code (without the check
"^DD",798.9,798.92,.01,21,2,0)
digit) of the Lab result to be searched for. If
"^DD",798.9,798.92,.01,21,3,0)
you want to use only NLT code, enter zero as the
"^DD",798.9,798.92,.01,21,4,0)
value of this field.
"^DD",798.9,798.92,.01,"DT")
3011119
"^DD",798.9,798.92,.02,0)
NLT CODE^F^^0;2^K:'(X?5N1"."4.5N) X
"^DD",798.9,798.92,.02,1,0)
^.1
"^DD",798.9,798.92,.02,1,1,0)
798.9^ANLT
"^DD",798.9,798.92,.02,1,1,1)
S ^ROR(798.9,"ANLT",$E(X,1,30),DA(1),DA)=""
"^DD",798.9,798.92,.02,1,1,2)
K ^ROR(798.9,"ANLT",$E(X,1,30),DA(1),DA)
"^DD",798.9,798.92,.02,1,1,3)
Do not delete!
"^DD",798.9,798.92,.02,1,1,"%D",0)
^^3^3^3011016^
"^DD",798.9,798.92,.02,1,1,"%D",1,0)
This cross-reference can be used to find all 
"^DD",798.9,798.92,.02,1,1,"%D",2,0)
criteria that look for the Lab results with the
"^DD",798.9,798.92,.02,1,1,"%D",3,0)
particular NLT code.
"^DD",798.9,798.92,.02,1,1,"DT")
3010621
"^DD",798.9,798.92,.02,3)
Enter the NLT code (NNNNN.MMMM[M]).
"^DD",798.9,798.92,.02,8.5)
@
"^DD",798.9,798.92,.02,9)
@
"^DD",798.9,798.92,.02,21,0)
^.001^5^5^3011119^^^
"^DD",798.9,798.92,.02,21,1,0)
Enter the NLT code of the Lab result to be 
"^DD",798.9,798.92,.02,21,2,0)
searched for. Both LOINC and NLT codes (if
"^DD",798.9,798.92,.02,21,3,0)
available) are used for searching the Lab results.
"^DD",798.9,798.92,.02,21,4,0)
If you want to use only the LOINC code, leave this
"^DD",798.9,798.92,.02,21,5,0)
field empty.
"^DD",798.9,798.92,.02,"DT")
3011119
"^DD",798.9,798.92,1,0)
INDICATOR^RS^0:Ignore;1:Use Reference Range;2:Contains;3:Greater Than;4:Less Than;5:Equal To;6:Positive Result;^0;3^Q
"^DD",798.9,798.92,1,8.5)
@
"^DD",798.9,798.92,1,9)
@
"^DD",798.9,798.92,1,21,0)
^^35^35^3031006^
"^DD",798.9,798.92,1,21,1,0)
The value of this field indicates the comparison
"^DD",798.9,798.92,1,21,2,0)
operation applied to the Lab result. The Lab
"^DD",798.9,798.92,1,21,3,0)
result is compared to the value of the INDICATED 
"^DD",798.9,798.92,1,21,4,0)
VALUE field. 
"^DD",798.9,798.92,1,21,5,0)
 
"^DD",798.9,798.92,1,21,6,0)
NOTE: All string comparisons are case-insensitive.
"^DD",798.9,798.92,1,21,7,0)
 
"^DD",798.9,798.92,1,21,8,0)
For example, if the internal value of this field 
"^DD",798.9,798.92,1,21,9,0)
is equal to 3 ("Greater Than") and the value of
"^DD",798.9,798.92,1,21,10,0)
the INDICATED VALUE field is 5 then this indicator
"^DD",798.9,798.92,1,21,11,0)
will be evaluated as True for all numeric Lab 
"^DD",798.9,798.92,1,21,12,0)
results values greater than 5.
"^DD",798.9,798.92,1,21,13,0)
 
"^DD",798.9,798.92,1,21,14,0)
The "Contains" indicator checks if the indicated
"^DD",798.9,798.92,1,21,15,0)
value is contained in the Lab result value.
"^DD",798.9,798.92,1,21,16,0)
 
"^DD",798.9,798.92,1,21,17,0)
The only exceptions are the "Use Reference Range"
"^DD",798.9,798.92,1,21,18,0)
indicator, which checks if the result value is
"^DD",798.9,798.92,1,21,19,0)
outside of the reference range defined for the 
"^DD",798.9,798.92,1,21,20,0)
Lab test, and the "Positive Result".
"^DD",798.9,798.92,1,21,21,0)
 
"^DD",798.9,798.92,1,21,22,0)
The "Positive Result" indicator selects a test 
"^DD",798.9,798.92,1,21,23,0)
result if the value
"^DD",798.9,798.92,1,21,24,0)
 
"^DD",798.9,798.92,1,21,25,0)
  * is equal to "P"
"^DD",798.9,798.92,1,21,26,0)
 
"^DD",798.9,798.92,1,21,27,0)
    or
"^DD",798.9,798.92,1,21,28,0)
 
"^DD",798.9,798.92,1,21,29,0)
  * contains "POS", "DETEC" or "REA" and
"^DD",798.9,798.92,1,21,30,0)
    does not contain "NEG", "NON" or "IND".
"^DD",798.9,798.92,1,21,31,0)
 
"^DD",798.9,798.92,1,21,32,0)
For example, the "POSITIVE", "POS", "REACT", and 
"^DD",798.9,798.92,1,21,33,0)
"DETECTABLE" values will be picked up. At the same
"^DD",798.9,798.92,1,21,34,0)
time, the "NON-REACT", "INDETERMINATE", and "NEG"
"^DD",798.9,798.92,1,21,35,0)
values will be skipped.
"^DD",798.9,798.92,1,"DT")
3031006
"^DD",798.9,798.92,2,0)
INDICATED VALUE^F^^0;4^K:$L(X)>30!($L(X)<1) X
"^DD",798.9,798.92,2,3)
Answer must be 1-30 characters in length.
"^DD",798.9,798.92,2,8.5)
@
"^DD",798.9,798.92,2,9)
@
"^DD",798.9,798.92,2,21,0)
^^3^3^3020403^
"^DD",798.9,798.92,2,21,1,0)
This field holds the value that the Lab results
"^DD",798.9,798.92,2,21,2,0)
are compared to (except the "Use Reference Range"
"^DD",798.9,798.92,2,21,3,0)
indicator).
"^DD",798.9,798.92,2,"DT")
3010621
"^DD",799.1,799.1,0)
FIELD^^1^5
"^DD",799.1,799.1,0,"DDA")
N
"^DD",799.1,799.1,0,"DT")
3021126
"^DD",799.1,799.1,0,"IX","B",799.1,.01)

"^DD",799.1,799.1,0,"NM","ROR LIST ITEM")

"^DD",799.1,799.1,0,"PT",798,2.2)

"^DD",799.1,799.1,0,"PT",798,3.2)

"^DD",799.1,799.1,0,"PT",798.128,.02)

"^DD",799.1,799.1,0,"PT",798.129,.02)

"^DD",799.1,799.1,0,"PT",799.51,.03)

"^DD",799.1,799.1,0,"VRPK")
ROR
"^DD",799.1,799.1,.01,0)
TEXT^RFX^^0;1^Q:$$VAEDT^RORDD(799.1,,-1)  K:$L(X)>60!($L(X)<1) X
"^DD",799.1,799.1,.01,1,0)
^.1
"^DD",799.1,799.1,.01,1,1,0)
799.1^B
"^DD",799.1,799.1,.01,1,1,1)
S ^ROR(799.1,"B",$E(X,1,30),DA)=""
"^DD",799.1,799.1,.01,1,1,2)
K ^ROR(799.1,"B",$E(X,1,30),DA)
"^DD",799.1,799.1,.01,1,1,3)
Do not delete!
"^DD",799.1,799.1,.01,3)
Enter text of the item (1-60 characters).
"^DD",799.1,799.1,.01,8.5)
@
"^DD",799.1,799.1,.01,9)
@
"^DD",799.1,799.1,.01,21,0)
^^6^6^3020403^
"^DD",799.1,799.1,.01,21,1,0)
This field contains a text representation of the
"^DD",799.1,799.1,.01,21,2,0)
item (external value). The text is displayed by 
"^DD",799.1,799.1,.01,21,3,0)
the GUI in the list of possible values of the
"^DD",799.1,799.1,.01,21,4,0)
registry field (for example, the REASON FOR 
"^DD",799.1,799.1,.01,21,5,0)
INACTIVATION field of the ROR LOCAL REGISTRY file)
"^DD",799.1,799.1,.01,21,6,0)
that this item is associated with.
"^DD",799.1,799.1,.01,"DEL",1,0)
I $$VADEL^RORDD(799.1,,-1)
"^DD",799.1,799.1,.01,"DT")
3011112
"^DD",799.1,799.1,.02,0)
TYPE^RSX^1:Reason for inactivation;2:Supporting evidence;3:Lab Group;4:Drug Group;^0;2^Q:$$VAEDT^RORDD(799.1,,-1)
"^DD",799.1,799.1,.02,8.5)
@
"^DD",799.1,799.1,.02,9)
@
"^DD",799.1,799.1,.02,21,0)
^.001^3^3^3030625^^^^
"^DD",799.1,799.1,.02,21,1,0)
An internal value of this field links the item to
"^DD",799.1,799.1,.02,21,2,0)
the registry field. The items with the same type
"^DD",799.1,799.1,.02,21,3,0)
define the possible values of the registry field.
"^DD",799.1,799.1,.02,23,0)
^.001^3^3^3030625^^^^
"^DD",799.1,799.1,.02,23,1,0)
When a new registry field needs to be added, add
"^DD",799.1,799.1,.02,23,2,0)
another code to the definition of this field and create
"^DD",799.1,799.1,.02,23,3,0)
the corresponding item records.
"^DD",799.1,799.1,.02,"DT")
3011112
"^DD",799.1,799.1,.03,0)
REGISTRY^RP798.1'X^ROR(798.1,^0;3^Q:$$VAEDT^RORDD(799.1,,-1)
"^DD",799.1,799.1,.03,8.5)
@
"^DD",799.1,799.1,.03,9)
@
"^DD",799.1,799.1,.03,21,0)
^.001^2^2^3011112^^
"^DD",799.1,799.1,.03,21,1,0)
This field identifies the registry that the item
"^DD",799.1,799.1,.03,21,2,0)
is associated with.
"^DD",799.1,799.1,.03,"DT")
3011112
"^DD",799.1,799.1,.04,0)
CODE^RNJ2,0X^^0;4^Q:$$VAEDT^RORDD(799.1,,-1)  K:+X'=X!(X>99)!(X<1)!(X?.E1"."1N.N) X
"^DD",799.1,799.1,.04,3)
Type a Number between 1 and 99, 0 Decimal Digits.
"^DD",799.1,799.1,.04,8.5)
@
"^DD",799.1,799.1,.04,9)
@
"^DD",799.1,799.1,.04,21,0)
^.001^3^3^3030625^^^
"^DD",799.1,799.1,.04,21,1,0)
This field contains a code (internal value) of the
"^DD",799.1,799.1,.04,21,2,0)
item. The codes are unique only among the items of
"^DD",799.1,799.1,.04,21,3,0)
the same type associated with the same registry.
"^DD",799.1,799.1,.04,"DT")
3011112
"^DD",799.1,799.1,1,0)
DATE OF INACTIVATION^D^^0;5^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",799.1,799.1,1,21,0)
^.001^4^4^3021126^^^
"^DD",799.1,799.1,1,21,1,0)
If this field has a value, the item will be
"^DD",799.1,799.1,1,21,2,0)
considered inactive after this date. Use this 
"^DD",799.1,799.1,1,21,3,0)
field to disable unnecessary items instead of
"^DD",799.1,799.1,1,21,4,0)
deleting them.
"^DD",799.1,799.1,1,23,0)
^.001^3^3^3021126^^^
"^DD",799.1,799.1,1,23,1,0)
The $$ITEMLIST^RORUTL01 function analyzes this field 
"^DD",799.1,799.1,1,23,2,0)
when it loads the requested list of items and skips the
"^DD",799.1,799.1,1,23,3,0)
inactive items.
"^DD",799.1,799.1,1,"DT")
3021126
"^DD",799.31,799.31,0)
FIELD^^.01^1
"^DD",799.31,799.31,0,"DDA")
N
"^DD",799.31,799.31,0,"DT")
3021130
"^DD",799.31,799.31,0,"IX","B",799.31,.01)

"^DD",799.31,799.31,0,"NM","ROR XML ITEM")

"^DD",799.31,799.31,0,"PT",798.87,.01)

"^DD",799.31,799.31,0,"PT",798.872,.01)

"^DD",799.31,799.31,0,"VRPK")
ROR
"^DD",799.31,799.31,.01,0)
NAME^RFX^^0;1^Q:$$VAEDT^RORDD(799.31,,-1)  K:$L(X)>30!($L(X)<2)!'(X'?1P.E) X
"^DD",799.31,799.31,.01,1,0)
^.1
"^DD",799.31,799.31,.01,1,1,0)
799.31^B
"^DD",799.31,799.31,.01,1,1,1)
S ^ROR(799.31,"B",$E(X,1,30),DA)=""
"^DD",799.31,799.31,.01,1,1,2)
K ^ROR(799.31,"B",$E(X,1,30),DA)
"^DD",799.31,799.31,.01,1,1,3)
Do not delete!
"^DD",799.31,799.31,.01,3)
Enter the tag name (2-30 characters).
"^DD",799.31,799.31,.01,8.5)
@
"^DD",799.31,799.31,.01,9)
@
"^DD",799.31,799.31,.01,21,0)
^.001^4^4^3030506^^
"^DD",799.31,799.31,.01,21,1,0)
This field stores the tag name. The name should 
"^DD",799.31,799.31,.01,21,2,0)
not contain spaces and any punctuation marks 
"^DD",799.31,799.31,.01,21,3,0)
except underscore. See an XML reference guide for
"^DD",799.31,799.31,.01,21,4,0)
more details.
"^DD",799.31,799.31,.01,23,0)
^.001^4^4^3030506^^
"^DD",799.31,799.31,.01,23,1,0)
Please try to use shorter names for the tags that will
"^DD",799.31,799.31,.01,23,2,0)
be used more often and/or will be repeated many times 
"^DD",799.31,799.31,.01,23,3,0)
in the report. Thus you will decrease amount of the
"^DD",799.31,799.31,.01,23,4,0)
overhead data transmitted from the server to the GUI.
"^DD",799.31,799.31,.01,"DEL",1,0)
I $$VADEL^RORDD(799.31,,-1)
"^DD",799.31,799.31,.01,"DT")
3030506
"^DD",799.33,799.33,0)
FIELD^^.01^2
"^DD",799.33,799.33,0,"DDA")
N
"^DD",799.33,799.33,0,"DT")
3030606
"^DD",799.33,799.33,0,"IX","B",799.33,.01)

"^DD",799.33,799.33,0,"NM","ROR DATA AREA")

"^DD",799.33,799.33,0,"PT",798.19,.02)

"^DD",799.33,799.33,0,"PT",798.32,1)

"^DD",799.33,799.33,0,"VRPK")
ROR
"^DD",799.33,799.33,.001,0)
NUMBER^NJ2,0^^ ^K:+X'=X!(X>99)!(X<1)!(X?.E1"."1N.N) X
"^DD",799.33,799.33,.001,3)
Type a Number between 1 and 99, 0 Decimal Digits
"^DD",799.33,799.33,.001,8.5)
@
"^DD",799.33,799.33,.001,9)
@
"^DD",799.33,799.33,.001,"DT")
3030606
"^DD",799.33,799.33,.01,0)
NAME^RFX^^0;1^Q:$$VAEDT^RORDD(799.33,,-1)  K:$L(X)>30!($L(X)<2)!'(X'?1P.E) X
"^DD",799.33,799.33,.01,1,0)
^.1
"^DD",799.33,799.33,.01,1,1,0)
799.33^B
"^DD",799.33,799.33,.01,1,1,1)
S ^ROR(799.33,"B",$E(X,1,30),DA)=""
"^DD",799.33,799.33,.01,1,1,2)
K ^ROR(799.33,"B",$E(X,1,30),DA)
"^DD",799.33,799.33,.01,1,1,3)
Do not delete!
"^DD",799.33,799.33,.01,3)
Enter name of the data area (2-30 characters).
"^DD",799.33,799.33,.01,8.5)
@
"^DD",799.33,799.33,.01,9)
@
"^DD",799.33,799.33,.01,21,0)
^^4^4^3030606^
"^DD",799.33,799.33,.01,21,1,0)
This field stores the name of the data area 
"^DD",799.33,799.33,.01,21,2,0)
referenced by the DATA AREA fields of the HL7
"^DD",799.33,799.33,.01,21,3,0)
SEGMENT (the ROR REGISTRY PARAMETERS file) and
"^DD",799.33,799.33,.01,21,4,0)
EVENT (the ROR PENDING PATIENT file) multiples.
"^DD",799.33,799.33,.01,"DEL",1,0)
I $$VADEL^RORDD(799.33,,-1)
"^DD",799.33,799.33,.01,"DT")
3030606
"^DD",799.34,799.34,0)
FIELD^^12^9
"^DD",799.34,799.34,0,"DDA")
N
"^DD",799.34,799.34,0,"DT")
3031103
"^DD",799.34,799.34,0,"IX","B",799.34,.01)

"^DD",799.34,799.34,0,"NM","ROR REPORT PARAMETERS")

"^DD",799.34,799.34,0,"PT",798.8,.04)

"^DD",799.34,799.34,.01,0)
NAME^RFX^^0;1^Q:$$VAEDT^RORDD(799.34,$G(DA))  K:$L(X)>60!($L(X)<3)!'(X'?1P.E) X
"^DD",799.34,799.34,.01,1,0)
^.1
"^DD",799.34,799.34,.01,1,1,0)
799.34^B
"^DD",799.34,799.34,.01,1,1,1)
S ^ROR(799.34,"B",$E(X,1,30),DA)=""
"^DD",799.34,799.34,.01,1,1,2)
K ^ROR(799.34,"B",$E(X,1,30),DA)
"^DD",799.34,799.34,.01,1,1,3)
Do not delete!
"^DD",799.34,799.34,.01,3)
Enter the report name (3-60 characters).
"^DD",799.34,799.34,.01,8.5)
@
"^DD",799.34,799.34,.01,9)
@
"^DD",799.34,799.34,.01,21,0)
^^5^5^3030505^
"^DD",799.34,799.34,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",799.34,799.34,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",799.34,799.34,.01,21,3,0)
 
"^DD",799.34,799.34,.01,21,4,0)
The name of the report stored in the NAME field is
"^DD",799.34,799.34,.01,21,5,0)
displayed in the Reports sub-menu of the GUI.
"^DD",799.34,799.34,.01,"DEL",1,0)
I $$VADEL^RORDD(799.34,$G(DA))
"^DD",799.34,799.34,.01,"DT")
3021126
"^DD",799.34,799.34,.02,0)
BACKGROUND PROCESSING?^SX^0:NO;1:YES;^0;2^Q:$$VAEDT^RORDD(799.34,$G(DA))
"^DD",799.34,799.34,.02,8.5)
@
"^DD",799.34,799.34,.02,9)
@
"^DD",799.34,799.34,.02,21,0)
^^6^6^3030506^
"^DD",799.34,799.34,.02,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",799.34,799.34,.02,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",799.34,799.34,.02,21,3,0)
 
"^DD",799.34,799.34,.02,21,4,0)
If the BACKGROUND PROCESSING? field is set to
"^DD",799.34,799.34,.02,21,5,0)
'YES' then the report will be scheduled to run as
"^DD",799.34,799.34,.02,21,6,0)
a background task.
"^DD",799.34,799.34,.02,23,0)
^^1^1^3030506^
"^DD",799.34,799.34,.02,23,1,0)
Only background processing is currently implemented.
"^DD",799.34,799.34,.02,"DEL",1,0)
I $$VADEL^RORDD(799.34,$G(DA))
"^DD",799.34,799.34,.02,"DT")
3021127
"^DD",799.34,799.34,.04,0)
CODE^RNJ3,0X^^0;4^Q:$$VAEDT^RORDD(799.34,$G(DA))  K:+X'=X!(X>999)!(X<1)!(X?.E1"."1N.N) X
"^DD",799.34,799.34,.04,3)
Enter the unique report code (between 1 and 999, 0 Decimal Digits).
"^DD",799.34,799.34,.04,8.5)
@
"^DD",799.34,799.34,.04,9)
@
"^DD",799.34,799.34,.04,21,0)
^^5^5^3030505^
"^DD",799.34,799.34,.04,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",799.34,799.34,.04,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",799.34,799.34,.04,21,3,0)
 
"^DD",799.34,799.34,.04,21,4,0)
The CODE field stores the unique code of the
"^DD",799.34,799.34,.04,21,5,0)
report.
"^DD",799.34,799.34,.04,23,0)
^^19^19^3030507^
"^DD",799.34,799.34,.04,23,1,0)
The corresponding XSL templates for the report are 
"^DD",799.34,799.34,.04,23,2,0)
stored in the DIALOG file (#.84). The dialog number 
"^DD",799.34,799.34,.04,23,3,0)
of the template has the following structure:
"^DD",799.34,799.34,.04,23,4,0)
 
"^DD",799.34,799.34,.04,23,5,0)
 7981CCC.TTT
"^DD",799.34,799.34,.04,23,6,0)
 
"^DD",799.34,799.34,.04,23,7,0)
 'CCC' is the code of the report.
"^DD",799.34,799.34,.04,23,8,0)
 
"^DD",799.34,799.34,.04,23,9,0)
 'TTT' is the type of the template:
"^DD",799.34,799.34,.04,23,10,0)
        001 - HTML Preview,
"^DD",799.34,799.34,.04,23,11,0)
        002 - Delimited Format (CSV),
"^DD",799.34,799.34,.04,23,12,0)
        003 - Printer Output.
"^DD",799.34,799.34,.04,23,13,0)
 
"^DD",799.34,799.34,.04,23,14,0)
For example, the dialog 7981001.001 contains the HTML
"^DD",799.34,799.34,.04,23,15,0)
preview template for the List of Registry Patients
"^DD",799.34,799.34,.04,23,16,0)
(report code: 1).
"^DD",799.34,799.34,.04,23,17,0)
 
"^DD",799.34,799.34,.04,23,18,0)
If no template is defined for the report then the
"^DD",799.34,799.34,.04,23,19,0)
default template from dialog 7981000 is used.
"^DD",799.34,799.34,.04,"DT")
3030401
"^DD",799.34,799.34,.05,0)
DATE OF INACTIVATION^D^^0;5^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",799.34,799.34,.05,21,0)
^^5^5^3030505^
"^DD",799.34,799.34,.05,21,1,0)
If this field has a value, the report will be
"^DD",799.34,799.34,.05,21,2,0)
considered inactive after this date. Use this
"^DD",799.34,799.34,.05,21,3,0)
field to disable unnecessary reports (and hide
"^DD",799.34,799.34,.05,21,4,0)
them from the Report sub-menu of the GUI) instead
"^DD",799.34,799.34,.05,21,5,0)
of deleting them.
"^DD",799.34,799.34,.05,23,0)
^^3^3^3030505^
"^DD",799.34,799.34,.05,23,1,0)
The ROR REPORTS AVAILABLE remote procedure analyzes
"^DD",799.34,799.34,.05,23,2,0)
this field when it loads the list of available reports
"^DD",799.34,799.34,.05,23,3,0)
and skips the inactive ones.
"^DD",799.34,799.34,.05,"DT")
3021126
"^DD",799.34,799.34,.09,0)
NATIONAL^SX^0:NO;1:YES;^0;9^Q:$$VAEDT^RORDD(799.34,,-1)
"^DD",799.34,799.34,.09,8.5)
@
"^DD",799.34,799.34,.09,9)
@
"^DD",799.34,799.34,.09,21,0)
^^7^7^3030506^
"^DD",799.34,799.34,.09,21,1,0)
ONLY AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN
"^DD",799.34,799.34,.09,21,2,0)
EDIT THIS FIELD!
"^DD",799.34,799.34,.09,21,3,0)
 
"^DD",799.34,799.34,.09,21,4,0)
Reports distributed with the national registries
"^DD",799.34,799.34,.09,21,5,0)
must have this field set to "YES". This prevents
"^DD",799.34,799.34,.09,21,6,0)
local editing of other fields of report
"^DD",799.34,799.34,.09,21,7,0)
definitions.
"^DD",799.34,799.34,.09,"DEL",1,0)
I $$VADEL^RORDD(799.34,,,-1)
"^DD",799.34,799.34,.09,"DT")
3021126
"^DD",799.34,799.34,1,0)
PARAMETER PANELS^FX^^1;E1,250^Q:$$VAEDT^RORDD(799.34,$G(DA))  K:$L(X)>250!($L(X)<1) X
"^DD",799.34,799.34,1,3)
Enter codes of dialog panels separated by commas (1-250 characters).
"^DD",799.34,799.34,1,8.5)
@
"^DD",799.34,799.34,1,9)
@
"^DD",799.34,799.34,1,21,0)
^^7^7^3030507^
"^DD",799.34,799.34,1,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",799.34,799.34,1,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",799.34,799.34,1,21,3,0)
 
"^DD",799.34,799.34,1,21,4,0)
The PARAMETER PANELS field stores the list of 
"^DD",799.34,799.34,1,21,5,0)
panel codes separated by commas. The panels are 
"^DD",799.34,799.34,1,21,6,0)
combined by the GUI into the dialog form that is
"^DD",799.34,799.34,1,21,7,0)
used to request values of the report parameters.
"^DD",799.34,799.34,1,"DEL",1,0)
I $$VADEL^RORDD(799.34,$G(DA))
"^DD",799.34,799.34,1,"DT")
3030304
"^DD",799.34,799.34,10.01,0)
REPORT BUILDER^RFX^^10.01;E1,245^Q:$$VAEDT^RORDD(799.34,$G(DA))  Q:$$EP^RORDD(1)
"^DD",799.34,799.34,10.01,3)
Answer must be $$TAG^ROUTINE (5-19 characters in length).
"^DD",799.34,799.34,10.01,8.5)
@
"^DD",799.34,799.34,10.01,9)
@
"^DD",799.34,799.34,10.01,21,0)
^^6^6^3030506^
"^DD",799.34,799.34,10.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",799.34,799.34,10.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",799.34,799.34,10.01,21,3,0)
 
"^DD",799.34,799.34,10.01,21,4,0)
The REPORT BUILDER field stores a reference to the
"^DD",799.34,799.34,10.01,21,5,0)
function that is used to build the report (the
"^DD",799.34,799.34,10.01,21,6,0)
report builder).
"^DD",799.34,799.34,10.01,23,0)
^^70^70^3030507^
"^DD",799.34,799.34,10.01,23,1,0)
The call-back entry point is called with a single
"^DD",799.34,799.34,10.01,23,2,0)
parameter. The parameter is a reference to a local
"^DD",799.34,799.34,10.01,23,3,0)
variable that contains values of the report parameters.
"^DD",799.34,799.34,10.01,23,4,0)
 
"^DD",799.34,799.34,10.01,23,5,0)
 RORTSK(            Task Number
"^DD",799.34,799.34,10.01,23,6,0)
 
"^DD",799.34,799.34,10.01,23,7,0)
   "EP")            Entry Point ($$TAG^ROUTINE)
"^DD",799.34,799.34,10.01,23,8,0)
 
"^DD",799.34,799.34,10.01,23,9,0)
   "PARAMS",
"^DD",799.34,799.34,10.01,23,10,0)
 
"^DD",799.34,799.34,10.01,23,11,0)
     "CD4OPT")      CD4 Options
"^DD",799.34,799.34,10.01,23,12,0)
 
"^DD",799.34,799.34,10.01,23,13,0)
     "CLINICS",     "ALL"
"^DD",799.34,799.34,10.01,23,14,0)
      i)            Clinic IEN
"^DD",799.34,799.34,10.01,23,15,0)
 
"^DD",799.34,799.34,10.01,23,16,0)
     "DATE_RANGE")  Date Range
"^DD",799.34,799.34,10.01,23,17,0)
 
"^DD",799.34,799.34,10.01,23,18,0)
     "DIVISIONS",   "ALL"
"^DD",799.34,799.34,10.01,23,19,0)
       i)           Division IEN
"^DD",799.34,799.34,10.01,23,20,0)
 
"^DD",799.34,799.34,10.01,23,21,0)
     "DRUGS",       "AGRDISP", "AGRGEN", "ALL", 
"^DD",799.34,799.34,10.01,23,22,0)
                    "ARV", "VACLS"
"^DD",799.34,799.34,10.01,23,23,0)
       i)           Drug IEN
"^DD",799.34,799.34,10.01,23,24,0)
 
"^DD",799.34,799.34,10.01,23,25,0)
     "DRUGS",       "AGRDISP", "AGRGEN", "ALL", 
"^DD",799.34,799.34,10.01,23,26,0)
                    "ARV", "VACLS"
"^DD",799.34,799.34,10.01,23,27,0)
       i,j)         Drug IEN (grouped list of
"^DD",799.34,799.34,10.01,23,28,0)
                    drugs)
"^DD",799.34,799.34,10.01,23,29,0)
 
"^DD",799.34,799.34,10.01,23,30,0)
     "FIELDS")      List of additional fields
"^DD",799.34,799.34,10.01,23,31,0)
 
"^DD",799.34,799.34,10.01,23,32,0)
     "ICD9LST",     "ALL"
"^DD",799.34,799.34,10.01,23,33,0)
       i)           ICD-9 Code
"^DD",799.34,799.34,10.01,23,34,0)
 
"^DD",799.34,799.34,10.01,23,35,0)
     "LABTESTS",    "ALL"
"^DD",799.34,799.34,10.01,23,36,0)
       i)           Test IEN ???
"^DD",799.34,799.34,10.01,23,37,0)
 
"^DD",799.34,799.34,10.01,23,38,0)
     "MAXUTNUM")    Number of patients with
"^DD",799.34,799.34,10.01,23,39,0)
                    highest utilization
"^DD",799.34,799.34,10.01,23,40,0)
 
"^DD",799.34,799.34,10.01,23,41,0)
     "MINLRNUM")    Minimum number of lab
"^DD",799.34,799.34,10.01,23,42,0)
                    results
"^DD",799.34,799.34,10.01,23,43,0)
 
"^DD",799.34,799.34,10.01,23,44,0)
     "MINRPNUM")    Minimum number of radiology
"^DD",799.34,799.34,10.01,23,45,0)
                    procedures
"^DD",799.34,799.34,10.01,23,46,0)
 
"^DD",799.34,799.34,10.01,23,47,0)
     "OPTIONS")     Report Options
"^DD",799.34,799.34,10.01,23,48,0)
 
"^DD",799.34,799.34,10.01,23,49,0)
     "PATIENTS")    Patients Options
"^DD",799.34,799.34,10.01,23,50,0)
 
"^DD",799.34,799.34,10.01,23,51,0)
     "TASK_DESCR")  Task Description
"^DD",799.34,799.34,10.01,23,52,0)
 
"^DD",799.34,799.34,10.01,23,53,0)
     "VADRUGLCS",
"^DD",799.34,799.34,10.01,23,54,0)
       i)           VA Drug Class
"^DD",799.34,799.34,10.01,23,55,0)
 
"^DD",799.34,799.34,10.01,23,56,0)
     "VIRAL_LOAD")  Viral Load Options
"^DD",799.34,799.34,10.01,23,57,0)
 
"^DD",799.34,799.34,10.01,23,58,0)
   "REGIEN")        Registry IEN
"^DD",799.34,799.34,10.01,23,59,0)
 
"^DD",799.34,799.34,10.01,23,60,0)
   "TYPE")          Type of the Task
"^DD",799.34,799.34,10.01,23,61,0)
   "REPORT")        Code of the Report
"^DD",799.34,799.34,10.01,23,62,0)
   "SCHCODE")       Rescheduling Code
"^DD",799.34,799.34,10.01,23,63,0)
 
"^DD",799.34,799.34,10.01,23,64,0)
The function must return 0 in the case of successful
"^DD",799.34,799.34,10.01,23,65,0)
completion. Otherwise, a negative error code must be 
"^DD",799.34,799.34,10.01,23,66,0)
returned.
"^DD",799.34,799.34,10.01,23,67,0)
 
"^DD",799.34,799.34,10.01,23,68,0)
See description of the ROR REPORT SCHEDULE remote
"^DD",799.34,799.34,10.01,23,69,0)
procedure and source code of the RORTSK01 routine for
"^DD",799.34,799.34,10.01,23,70,0)
more details.
"^DD",799.34,799.34,10.01,"DT")
3021126
"^DD",799.34,799.34,11,0)
DEFAULT PARAMETERS^799.3411^^11;0
"^DD",799.34,799.34,11,9)
@
"^DD",799.34,799.34,11,21,0)
^.001^2^2^3040124^^
"^DD",799.34,799.34,11,21,1,0)
This field stores the default values for the 
"^DD",799.34,799.34,11,21,2,0)
report parameters (in the NAME=VALUE format).
"^DD",799.34,799.34,12,0)
DEFAULT SORTING^799.3412^^12;0
"^DD",799.34,799.34,12,9)
@
"^DD",799.34,799.34,12,21,0)
^^2^2^3040121^
"^DD",799.34,799.34,12,21,1,0)
This field stores the default sorting modes for
"^DD",799.34,799.34,12,21,2,0)
the report (in the TABLE=FIELD format).
"^DD",799.34,799.3411,0)
DEFAULT PARAMETERS SUB-FIELD^^.01^1
"^DD",799.34,799.3411,0,"DT")
3030918
"^DD",799.34,799.3411,0,"NM","DEFAULT PARAMETERS")

"^DD",799.34,799.3411,0,"UP")
799.34
"^DD",799.34,799.3411,.01,0)
DEFAULT PARAMETERS^WL^^0;1^Q
"^DD",799.34,799.3411,.01,8.5)
@
"^DD",799.34,799.3411,.01,9)
@
"^DD",799.34,799.3411,.01,"DT")
3030918
"^DD",799.34,799.3412,0)
DEFAULT SORTING SUB-FIELD^^.01^1
"^DD",799.34,799.3412,0,"DT")
3031103
"^DD",799.34,799.3412,0,"NM","DEFAULT SORTING")

"^DD",799.34,799.3412,0,"UP")
799.34
"^DD",799.34,799.3412,.01,0)
DEFAULT SORTING^WL^^0;1^Q
"^DD",799.34,799.3412,.01,8.5)
@
"^DD",799.34,799.3412,.01,9)
@
"^DD",799.34,799.3412,.01,"DT")
3031103
"^DD",799.4,799.4,0)
FIELD^^25^100
"^DD",799.4,799.4,0,"DDA")
N
"^DD",799.4,799.4,0,"DT")
3030417
"^DD",799.4,799.4,0,"IX","B",799.4,.01)

"^DD",799.4,799.4,0,"NM","ROR ICR STUDY")

"^DD",799.4,799.4,0,"SCR")
I $$ACCESS^RORDD(799.4,"VA ICR",1)
"^DD",799.4,799.4,0,"VRPK")
ROR
"^DD",799.4,799.4,.01,0)
REGISTRY RECORD^RP798'XI^RORDATA(798,^0;1^S:$D(X) DINUM=X
"^DD",799.4,799.4,.01,1,0)
^.1
"^DD",799.4,799.4,.01,1,1,0)
799.4^B
"^DD",799.4,799.4,.01,1,1,1)
S ^RORDATA(799.4,"B",$E(X,1,30),DA)=""
"^DD",799.4,799.4,.01,1,1,2)
K ^RORDATA(799.4,"B",$E(X,1,30),DA)
"^DD",799.4,799.4,.01,1,1,3)
Do not delete!
"^DD",799.4,799.4,.01,3)

"^DD",799.4,799.4,.01,8.5)
@
"^DD",799.4,799.4,.01,9)
@
"^DD",799.4,799.4,.01,21,0)
^^7^7^3030506^
"^DD",799.4,799.4,.01,21,1,0)
The REGISTRY RECORD field links a record of the 
"^DD",799.4,799.4,.01,21,2,0)
ROR ICR STUDY file to the main registry record in
"^DD",799.4,799.4,.01,21,3,0)
the ROR LOCAL REGISTRY file.
"^DD",799.4,799.4,.01,21,4,0)
 
"^DD",799.4,799.4,.01,21,5,0)
You can access records of this file only if you 
"^DD",799.4,799.4,.01,21,6,0)
have appropriate security key(s) for the
"^DD",799.4,799.4,.01,21,7,0)
Immunology Case Registry.
"^DD",799.4,799.4,.01,23,0)
^^5^5^3030507^
"^DD",799.4,799.4,.01,23,1,0)
Internal value of this field is used as the internal
"^DD",799.4,799.4,.01,23,2,0)
entry number of the record (the 'DINUM' feature).
"^DD",799.4,799.4,.01,23,3,0)
Therefore, the corresponding records of this file and
"^DD",799.4,799.4,.01,23,4,0)
the ROR LOCAL REGISTRY file have the same internal
"^DD",799.4,799.4,.01,23,5,0)
entry numbers.
"^DD",799.4,799.4,.01,"DT")
3031028
"^DD",799.4,799.4,.02,0)
CLINICAL AIDS^S^0:NO;1:YES;^0;2^Q
"^DD",799.4,799.4,.02,21,0)
^^3^3^3030507^
"^DD",799.4,799.4,.02,21,1,0)
The CLINICAL AIDS fields indicates if the 
"^DD",799.4,799.4,.02,21,2,0)
clinical AIDS (the category 4) was diagnosed for 
"^DD",799.4,799.4,.02,21,3,0)
the patient.
"^DD",799.4,799.4,.02,"DT")
3030407
"^DD",799.4,799.4,.03,0)
CLINICAL AIDS DATE^D^^0;3^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,.03,21,0)
^^3^3^3030507^
"^DD",799.4,799.4,.03,21,1,0)
The CLINICAL AIDS DATE field stores the date of 
"^DD",799.4,799.4,.03,21,2,0)
the clinical AIDS diagnosis indicated by the 
"^DD",799.4,799.4,.03,21,3,0)
CLINICAL AIDS field.
"^DD",799.4,799.4,.03,"DT")
3030407
"^DD",799.4,799.4,.04,0)
STATION^P4'^DIC(4,^0;4^Q
"^DD",799.4,799.4,.04,.1)
Institution
"^DD",799.4,799.4,.04,3)
Enter the name of the institution completing the form.
"^DD",799.4,799.4,.04,21,0)
^^4^4^3030506^
"^DD",799.4,799.4,.04,21,1,0)
This field is a pointer to the Institution file 
"^DD",799.4,799.4,.04,21,2,0)
(#4) and identifies the name of the station
"^DD",799.4,799.4,.04,21,3,0)
completing the Center for Disease Control (CDC) 
"^DD",799.4,799.4,.04,21,4,0)
form.
"^DD",799.4,799.4,.04,"DT")
2871217
"^DD",799.4,799.4,9.01,0)
DATE CDC FORM COMPLETED^D^^9;1^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,9.01,.1)
CDC Form Date
"^DD",799.4,799.4,9.01,3)
Enter date CDC Form is being completed.
"^DD",799.4,799.4,9.01,20,0)
^.3LA^1^1
"^DD",799.4,799.4,9.01,20,1,0)
CDC HEADER
"^DD",799.4,799.4,9.01,21,0)
^.001^2^2^3030506^^^^
"^DD",799.4,799.4,9.01,21,1,0)
This field is used to track the date on which the 
"^DD",799.4,799.4,9.01,21,2,0)
CDC form was completed.
"^DD",799.4,799.4,9.01,"DT")
3030411
"^DD",799.4,799.4,9.02,0)
STATUS AT REPORT^S^1:HIV (NOT AIDS);2:AIDS;^9;2^Q
"^DD",799.4,799.4,9.02,3)
This is the status indicator at the time of generating the HIV/AIDS report form.
"^DD",799.4,799.4,9.02,20,0)
^.3LA^1^1
"^DD",799.4,799.4,9.02,20,1,0)
CDC FORM (III)
"^DD",799.4,799.4,9.02,21,0)
^^3^3^3030507^
"^DD",799.4,799.4,9.02,21,1,0)
This field is used to indicate the status of the 
"^DD",799.4,799.4,9.02,21,2,0)
patient at the time a CDC HIV/AIDS form is
"^DD",799.4,799.4,9.02,21,3,0)
generated.
"^DD",799.4,799.4,9.02,"DT")
2940628
"^DD",799.4,799.4,9.03,0)
AGE AT HIV DIAGNOSIS^NJ2,0^^9;3^K:+X'=X!(X>99)!(X<0)!(X?.E1"."1N.N) X
"^DD",799.4,799.4,9.03,3)
This is the age at which HIV was diagnosed in this patient. Type a Number between 0 and 99, 0 Decimal Digits
"^DD",799.4,799.4,9.03,20,0)
^.3LA^1^1
"^DD",799.4,799.4,9.03,20,1,0)
CDC FORM (III)
"^DD",799.4,799.4,9.03,21,0)
^.001^3^3^3030506^^
"^DD",799.4,799.4,9.03,21,1,0)
This field contains the age at which HIV was 
"^DD",799.4,799.4,9.03,21,2,0)
diagnosed in this patient. The value is used for a
"^DD",799.4,799.4,9.03,21,3,0)
field on the CDC HIV/AIDS form.
"^DD",799.4,799.4,9.03,"DT")
2940628
"^DD",799.4,799.4,9.04,0)
AGE AT AIDS DIAGNOSIS^NJ3,0^^9;4^K:+X'=X!(X>100)!(X<0)!(X?.E1"."1N.N) X
"^DD",799.4,799.4,9.04,.1)
Age at AIDS Diagnosis
"^DD",799.4,799.4,9.04,3)
Enter patient's age at diagnosis of AIDS. Type a number between 0-100, 0 decimal digits.
"^DD",799.4,799.4,9.04,20,0)
^.3LA^1^1
"^DD",799.4,799.4,9.04,20,1,0)
CDC FORM (III)
"^DD",799.4,799.4,9.04,21,0)
^.001^4^4^3030506^^
"^DD",799.4,799.4,9.04,21,1,0)
This field is used to indicate the patient's age 
"^DD",799.4,799.4,9.04,21,2,0)
at the time that the diagnosis of AIDS was made.
"^DD",799.4,799.4,9.04,21,3,0)
The field is used to print part III of the the CDC
"^DD",799.4,799.4,9.04,21,4,0)
form.
"^DD",799.4,799.4,9.04,"DT")
2880114
"^DD",799.4,799.4,9.05,0)
CDC FORM COMPLETED BY^P200'^VA(200,^9;5^Q
"^DD",799.4,799.4,9.05,3)

"^DD",799.4,799.4,9.05,8.5)
@
"^DD",799.4,799.4,9.05,9)
@
"^DD",799.4,799.4,9.05,20,0)
^.3LA^1^1
"^DD",799.4,799.4,9.05,20,1,0)
CDC HEADER
"^DD",799.4,799.4,9.05,"DT")
3030417
"^DD",799.4,799.4,9.06,0)
STATE/TERRITORY OF DEATH^F^^9;6^K:$L(X)>24!($L(X)<2) X
"^DD",799.4,799.4,9.06,3)
Enter the State or Territory in which the patient's death occurred. Answer must be 2-24 characters in length.
"^DD",799.4,799.4,9.06,20,0)
^.3LA^1^1
"^DD",799.4,799.4,9.06,20,1,0)
CDC FORM (III)
"^DD",799.4,799.4,9.06,21,0)
^.001^4^4^3030506^^
"^DD",799.4,799.4,9.06,21,1,0)
This field is used to hold the name of the state 
"^DD",799.4,799.4,9.06,21,2,0)
or territory in which the patient died. This
"^DD",799.4,799.4,9.06,21,3,0)
information is used to generate the CDC HIV/AIDS
"^DD",799.4,799.4,9.06,21,4,0)
form.
"^DD",799.4,799.4,9.06,"DT")
2950313
"^DD",799.4,799.4,9.07,0)
COUNTRY OF BIRTH^S^1:U.S.;7:U.S. DEPENDENCIES AND POSSESSIONS (INCLUDING PUERTO RICO);8:OTHER;9:UNKNOWN;^9;7^Q
"^DD",799.4,799.4,9.07,3)
Enter the number (or name) indicating the country of birth. NOTE that U.S. Dependencies and possessions includes Puerto Rico.
"^DD",799.4,799.4,9.07,20,0)
^.3LA^1^1
"^DD",799.4,799.4,9.07,20,1,0)
CDC FORM (III)
"^DD",799.4,799.4,9.07,21,0)
^.001^8^8^3030506^^
"^DD",799.4,799.4,9.07,21,1,0)
This is the country of birth information for this 
"^DD",799.4,799.4,9.07,21,2,0)
patient for use on the revised CDC form. The
"^DD",799.4,799.4,9.07,21,3,0)
options for this information on the new form 
"^DD",799.4,799.4,9.07,21,4,0)
differ from those available on the earlier CDC
"^DD",799.4,799.4,9.07,21,5,0)
form.
"^DD",799.4,799.4,9.07,21,6,0)
 
"^DD",799.4,799.4,9.07,21,7,0)
The name for either 7 or 8 should be entered in 
"^DD",799.4,799.4,9.07,21,8,0)
the appropriate place.
"^DD",799.4,799.4,9.07,"DT")
3030506
"^DD",799.4,799.4,9.08,0)
DEPENDENCY OR POSSESSION NAME^F^^9;8^K:$L(X)>15!($L(X)<2) X
"^DD",799.4,799.4,9.08,3)
Enter the name of the U.S. Dependency or Possession in which the patient was born (2-15 characters).
"^DD",799.4,799.4,9.08,20,0)
^.3LA^1^1
"^DD",799.4,799.4,9.08,20,1,0)
CDC FORM (III)
"^DD",799.4,799.4,9.08,21,0)
^.001^4^4^3030507^^^
"^DD",799.4,799.4,9.08,21,1,0)
This field is used to enter the name of the 
"^DD",799.4,799.4,9.08,21,2,0)
country of birth when the country of birth is
"^DD",799.4,799.4,9.08,21,3,0)
indicated as a U.S. dependency or possession for 
"^DD",799.4,799.4,9.08,21,4,0)
the revised CDC form.
"^DD",799.4,799.4,9.08,"DT")
2930331
"^DD",799.4,799.4,9.09,0)
OTHER COUNTRY DESCRIPTION^F^^9;9^K:$L(X)>15!($L(X)<3) X
"^DD",799.4,799.4,9.09,.1)
Other Country Name
"^DD",799.4,799.4,9.09,3)
If patient's country of birth is 'Other', enter name (3-15 characters).
"^DD",799.4,799.4,9.09,20,0)
^.3LA^1^1
"^DD",799.4,799.4,9.09,20,1,0)
CDC FORM (III)
"^DD",799.4,799.4,9.09,21,0)
^.001^5^5^3030507^^
"^DD",799.4,799.4,9.09,21,1,0)
This field is used to enter the name of the 
"^DD",799.4,799.4,9.09,21,2,0)
country of birth if OTHER was selected as a value 
"^DD",799.4,799.4,9.09,21,3,0)
of the COUNTRY OF BIRTH field. If the field is not
"^DD",799.4,799.4,9.09,21,4,0)
blank, then it is printed in the part III of the
"^DD",799.4,799.4,9.09,21,5,0)
CDC form.
"^DD",799.4,799.4,9.09,"DT")
2871217
"^DD",799.4,799.4,9.1,0)
ONSET OF ILLNESS/AIDS- CITY^F^^9;10^K:$L(X)>15!($L(X)<3) X
"^DD",799.4,799.4,9.1,.1)
City at Onset of Illness Suggestive of AIDS
"^DD",799.4,799.4,9.1,3)
Enter city of residence at onset of illness suggestive of AIDS diagnosis. Answer must be 3-15 characters in length.
"^DD",799.4,799.4,9.1,20,0)
^.3LA^1^1
"^DD",799.4,799.4,9.1,20,1,0)
CDC FORM (III)
"^DD",799.4,799.4,9.1,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,9.1,21,1,0)
This is the city in which the patient was residing
"^DD",799.4,799.4,9.1,21,2,0)
at the onset of an illness suggestive of AIDS.
"^DD",799.4,799.4,9.1,21,3,0)
This field is used in printing Part III of the CDC
"^DD",799.4,799.4,9.1,21,4,0)
form.
"^DD",799.4,799.4,9.1,"DT")
3030211
"^DD",799.4,799.4,9.11,0)
ONSET OF ILLNESS/AIDS- COUNTY^F^^9;11^K:$L(X)>15!($L(X)<3) X
"^DD",799.4,799.4,9.11,.1)
County at Onset of Illness Suggestive of AIDS
"^DD",799.4,799.4,9.11,3)
Enter county of residence at onset of illness suggestive of AIDS diagnosis. Answer must be 3-15 characters in length.
"^DD",799.4,799.4,9.11,20,0)
^.3LA^1^1
"^DD",799.4,799.4,9.11,20,1,0)
CDC FORM (III)
"^DD",799.4,799.4,9.11,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,9.11,21,1,0)
This field is used to indicate the COUNTY in which
"^DD",799.4,799.4,9.11,21,2,0)
the patient was residing at the onset of an
"^DD",799.4,799.4,9.11,21,3,0)
illness suggestive of AIDS. This field is used in
"^DD",799.4,799.4,9.11,21,4,0)
printing part III of the CDC form.
"^DD",799.4,799.4,9.11,"DT")
3030211
"^DD",799.4,799.4,9.12,0)
ONSET OF ILLNESS/AIDS- STATE^P5'^DIC(5,^9;12^Q
"^DD",799.4,799.4,9.12,.1)
State at Onset of Illness Suggestive of AIDS
"^DD",799.4,799.4,9.12,3)
Enter patient's state of residence at onset of illness sugesstive of AIDS.
"^DD",799.4,799.4,9.12,20,0)
^.3LA^1^1
"^DD",799.4,799.4,9.12,20,1,0)
CDC FORM (III)
"^DD",799.4,799.4,9.12,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,9.12,21,1,0)
This field is used to indicate the STATE in which 
"^DD",799.4,799.4,9.12,21,2,0)
the patient was residing at the time of onset of
"^DD",799.4,799.4,9.12,21,3,0)
an illness suggestive of AIDS. This field is used
"^DD",799.4,799.4,9.12,21,4,0)
in printing part III of the CDC form.
"^DD",799.4,799.4,9.12,"DT")
3030211
"^DD",799.4,799.4,9.13,0)
ONSET OF ILLNESS/AIDS- COUNTRY^F^^9;13^K:$L(X)>15!($L(X)<3) X
"^DD",799.4,799.4,9.13,.1)
Country at Onset of Illness Suggestive of AIDS
"^DD",799.4,799.4,9.13,3)
Enter patient's country of residence at onset of illness suggestive of AIDS. Answer must be 3-15 characters in length.
"^DD",799.4,799.4,9.13,20,0)
^.3LA^1^1
"^DD",799.4,799.4,9.13,20,1,0)
CDC FORM (III)
"^DD",799.4,799.4,9.13,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,9.13,21,1,0)
This field is used to indicate the COUNTRY in 
"^DD",799.4,799.4,9.13,21,2,0)
which the patient was residing at the time of
"^DD",799.4,799.4,9.13,21,3,0)
onset of an illness suggestive of AIDS. This field
"^DD",799.4,799.4,9.13,21,4,0)
is used in printing part III of the CDC form.
"^DD",799.4,799.4,9.13,"DT")
3030211
"^DD",799.4,799.4,9.14,0)
ONSET OF ILLNESS/AIDS- ZIP^F^^9;14^K:$L(X)>9!($L(X)<5) X
"^DD",799.4,799.4,9.14,.1)
Zip Code at Onset of Illness Suggestive of AIDS
"^DD",799.4,799.4,9.14,3)
Enter patient's zip code of residence at onset of illness suggestive of AIDS. Answer must be 5-9 characters in length.
"^DD",799.4,799.4,9.14,20,0)
^.3LA^1^1
"^DD",799.4,799.4,9.14,20,1,0)
CDC FORM (III)
"^DD",799.4,799.4,9.14,21,0)
^^5^5^3030211^
"^DD",799.4,799.4,9.14,21,1,0)
This field is used to indicate the zip code which 
"^DD",799.4,799.4,9.14,21,2,0)
was associated with the residence of the patient
"^DD",799.4,799.4,9.14,21,3,0)
at the onset of an illness suggestive of AIDS.
"^DD",799.4,799.4,9.14,21,4,0)
This field is used in printing part III of the CDC
"^DD",799.4,799.4,9.14,21,5,0)
form.
"^DD",799.4,799.4,9.14,"DT")
3030211
"^DD",799.4,799.4,9.9,0)
PATIENT STATUS^CJ1,0^^ ; ^S X=$S('$D(D0):"",D0<0:"",1:D0),X=$S(X>0:+$P($G(^RORDATA(798,+X,0)),U),1:0),X=$S(X'>0:9,$P($G(^RORDATA(798.4,X,1)),U,4)>0:2,1:1)
"^DD",799.4,799.4,9.9,9)
^
"^DD",799.4,799.4,9.9,9.01)

"^DD",799.4,799.4,9.9,9.1)
RORPTSTATUS(NUMBER)
"^DD",799.4,799.4,9.9,21,0)
^^4^4^3030219^
"^DD",799.4,799.4,9.9,21,1,0)
The PATIENT STATUS field indicates whether the
"^DD",799.4,799.4,9.9,21,2,0)
patient is alive (1) or dead (2), or if the status
"^DD",799.4,799.4,9.9,21,3,0)
is unknown (9). It is also used in printing the
"^DD",799.4,799.4,9.9,21,4,0)
CDC form.
"^DD",799.4,799.4,9.9,"DT")
3030219
"^DD",799.4,799.4,10,0)
AIDS INDICATOR DISEASE^799.41P^^10;0
"^DD",799.4,799.4,10,20,0)
^.3LA^1^1
"^DD",799.4,799.4,10,20,1,0)
CDC FORM (VIII)
"^DD",799.4,799.4,10,21,0)
^^2^2^3030507^
"^DD",799.4,799.4,10,21,1,0)
The AIDS INDICATOR DISEASE multiple contains a 
"^DD",799.4,799.4,10,21,2,0)
list of disease diagnoses that indicate the AIDS.
"^DD",799.4,799.4,10,23,0)
^^3^3^3030507^
"^DD",799.4,799.4,10,23,1,0)
The records of the multiple have the same internal
"^DD",799.4,799.4,10,23,2,0)
entry numbers as the corresponding diseases from
"^DD",799.4,799.4,10,23,3,0)
the ROR AIDS INDICATOR DISEASE file (#799.49).
"^DD",799.4,799.4,11.01,0)
RECORD REVIEWED^S^1:YES;0:NO;^11;1^Q
"^DD",799.4,799.4,11.01,3)
Indicate whether the patient's medical record was reviewed prior to submitting the CDC HIV/AIDS form or no.
"^DD",799.4,799.4,11.01,20,0)
^.3LA^1^1
"^DD",799.4,799.4,11.01,20,1,0)
CDC FORM (VIII)
"^DD",799.4,799.4,11.01,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,11.01,21,1,0)
This field is used to indicate whether the 
"^DD",799.4,799.4,11.01,21,2,0)
patient's medical record was reviewed prior to
"^DD",799.4,799.4,11.01,21,3,0)
submitting the CDC HIV/AIDS form. The entry is
"^DD",799.4,799.4,11.01,21,4,0)
used in the CDC HIV/AIDS form.
"^DD",799.4,799.4,11.01,"DT")
2940628
"^DD",799.4,799.4,11.02,0)
DATE ASYMPTOMATIC^DX^^11;2^S %DT="E",%DT(0)=-DT D ^%DT S X=Y K:Y<1 X K %DT(0)
"^DD",799.4,799.4,11.02,3)
This is the date the patient was diagnosed as ASYMPTOMATIC (including acute retroviral syndrome and persistant generalized lymphadenopathy).
"^DD",799.4,799.4,11.02,20,0)
^.3LA^1^1
"^DD",799.4,799.4,11.02,20,1,0)
CDC FORM (VIII)
"^DD",799.4,799.4,11.02,21,0)
^^5^5^3030211^
"^DD",799.4,799.4,11.02,21,1,0)
This field is used for a date requested in the 
"^DD",799.4,799.4,11.02,21,2,0)
CLINICAL STATUS portion of the CDC form. The form
"^DD",799.4,799.4,11.02,21,3,0)
requests the date the patient was diagnosed as
"^DD",799.4,799.4,11.02,21,4,0)
ASYMTPTOMATIC (including acute retroviral syndrome
"^DD",799.4,799.4,11.02,21,5,0)
and persistant generalized lymphadenopathy).
"^DD",799.4,799.4,11.02,"DT")
2970715
"^DD",799.4,799.4,11.03,0)
DATE SYMPTOMATIC^DX^^11;3^S %DT="E",%DT(0)=-DT D ^%DT S X=Y K:Y<1 X K %DT(0)
"^DD",799.4,799.4,11.03,3)
Enter the date when the patient was diagnosed as SYMPTOMATIC (not AIDS).
"^DD",799.4,799.4,11.03,20,0)
^.3LA^1^1
"^DD",799.4,799.4,11.03,20,1,0)
CDC FORM (VIII)
"^DD",799.4,799.4,11.03,21,0)
^^3^3^3030211^
"^DD",799.4,799.4,11.03,21,1,0)
This field is used for the date requested as 
"^DD",799.4,799.4,11.03,21,2,0)
SYMPTOMATIC in the CLINICAL STATUS portion of the
"^DD",799.4,799.4,11.03,21,3,0)
CDC HIV/AIDS reporting form.
"^DD",799.4,799.4,11.03,"DT")
2970715
"^DD",799.4,799.4,11.04,0)
IMMUNODEF THAT DISQUALIFIES^S^1:YES;0:NO;9:UNKNOWN;^11;4^Q
"^DD",799.4,799.4,11.04,.1)
Immunodeficiency that would disqualify AIDS diagnosis
"^DD",799.4,799.4,11.04,3)
This field indicates whether the patient has an immunodeficiency which would disqualify the patient from an AIDS diagnosis.
"^DD",799.4,799.4,11.04,20,0)
^.3LA^1^1
"^DD",799.4,799.4,11.04,20,1,0)
CDC FORM (VIII)
"^DD",799.4,799.4,11.04,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,11.04,21,1,0)
This field indicates whether the patient has an 
"^DD",799.4,799.4,11.04,21,2,0)
immunodeficiency which would disqualify the
"^DD",799.4,799.4,11.04,21,3,0)
patient from an AIDS diagnosis. This field is used
"^DD",799.4,799.4,11.04,21,4,0)
in the CDC HIV/AIDS form.
"^DD",799.4,799.4,11.04,"DT")
2940628
"^DD",799.4,799.4,11.05,0)
RVCT CASE NO.^NJ9,0^^11;5^K:+X'=X!(X>999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",799.4,799.4,11.05,3)
If the presence of Tuberculosis is indicated, this entry should contain the RVCT CASE Number for the patient.
"^DD",799.4,799.4,11.05,20,0)
^.3LA^1^1
"^DD",799.4,799.4,11.05,20,1,0)
CDC FORM (VIII)
"^DD",799.4,799.4,11.05,21,0)
^^3^3^3030211^
"^DD",799.4,799.4,11.05,21,1,0)
This field is used to enter the RVCT Case number 
"^DD",799.4,799.4,11.05,21,2,0)
if a diagnosis of Tuberculosis had been indicated
"^DD",799.4,799.4,11.05,21,3,0)
in Part VIII of the CDC form.
"^DD",799.4,799.4,11.05,"DT")
2930331
"^DD",799.4,799.4,12.01,0)
AIDS DX - HOSPITAL^F^^12;1^K:$L(X)>30!($L(X)<3) X
"^DD",799.4,799.4,12.01,.1)
Hospital Where AIDS Diagnosed
"^DD",799.4,799.4,12.01,3)
Enter the name of hospital where AIDS diagnosed.  Answer must be 3-30 characters in length.
"^DD",799.4,799.4,12.01,20,0)
^.3LA^1^1
"^DD",799.4,799.4,12.01,20,1,0)
CDC FORM (IV)
"^DD",799.4,799.4,12.01,21,0)
^^3^3^3030210^
"^DD",799.4,799.4,12.01,21,1,0)
This field contains the name of the hospital where
"^DD",799.4,799.4,12.01,21,2,0)
the diagnosis of AIDS was first made.  This field
"^DD",799.4,799.4,12.01,21,3,0)
is used in printing part IV of the CDC form.
"^DD",799.4,799.4,12.01,"DT")
3030210
"^DD",799.4,799.4,12.02,0)
AIDS DX - CITY^F^^12;2^K:$L(X)>15!($L(X)<3) X
"^DD",799.4,799.4,12.02,.1)
City of Hospital Where AIDS Dx.
"^DD",799.4,799.4,12.02,3)
Enter name of city of hospital where HIV diagnosed.  Answer must be 3-15 characters in length.
"^DD",799.4,799.4,12.02,20,0)
^.3LA^1^1
"^DD",799.4,799.4,12.02,20,1,0)
CDC FORM (IV)
"^DD",799.4,799.4,12.02,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,12.02,21,1,0)
This field contains the city in which the 
"^DD",799.4,799.4,12.02,21,2,0)
hospital where the diagnosis of AIDS was first
"^DD",799.4,799.4,12.02,21,3,0)
made is located.  This field is used in printing
"^DD",799.4,799.4,12.02,21,4,0)
part IV of the CDC form.
"^DD",799.4,799.4,12.02,"DT")
3030210
"^DD",799.4,799.4,12.03,0)
AIDS DX - STATE^P5'^DIC(5,^12;3^Q
"^DD",799.4,799.4,12.03,.1)
State of Hospital Where AIDS Dx.
"^DD",799.4,799.4,12.03,3)
Enter the name of the state where AIDS diagnosed.
"^DD",799.4,799.4,12.03,20,0)
^.3LA^1^1
"^DD",799.4,799.4,12.03,20,1,0)
CDC FORM (IV)
"^DD",799.4,799.4,12.03,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,12.03,21,1,0)
This field contains the name of the STATE in 
"^DD",799.4,799.4,12.03,21,2,0)
which the hospital is located where the diagnosis
"^DD",799.4,799.4,12.03,21,3,0)
of AIDS was first made.  This field is used in
"^DD",799.4,799.4,12.03,21,4,0)
printing part IV of the CDC form.
"^DD",799.4,799.4,12.03,"DT")
3030210
"^DD",799.4,799.4,12.04,0)
AIDS DX - COUNTRY^F^^12;4^K:$L(X)>15!($L(X)<3) X
"^DD",799.4,799.4,12.04,.1)
Country of Hospital Where AIDS Dx.
"^DD",799.4,799.4,12.04,3)
Enter name of country where AIDS Dx made.  Answer must be 3-15 characters in length.
"^DD",799.4,799.4,12.04,20,0)
^.3LA^1^1
"^DD",799.4,799.4,12.04,20,1,0)
CDC FORM (IV)
"^DD",799.4,799.4,12.04,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,12.04,21,1,0)
This field is used to record the country in  which
"^DD",799.4,799.4,12.04,21,2,0)
the hospital at which the patient was diagnosed as
"^DD",799.4,799.4,12.04,21,3,0)
having AIDS is located. This field is used in
"^DD",799.4,799.4,12.04,21,4,0)
printing part IV of the CDC form.
"^DD",799.4,799.4,12.04,"DT")
3030210
"^DD",799.4,799.4,12.05,0)
AIDS DX - FACILITY SETTING^S^1:PUBLIC;2:PRIVATE;3:FEDERAL;9:UNKNOWN;^12;5^Q
"^DD",799.4,799.4,12.05,3)
This entry is used to indicate the type of facility on the revised HIV/CDC form.
"^DD",799.4,799.4,12.05,20,0)
^.3LA^1^1
"^DD",799.4,799.4,12.05,20,1,0)
CDC FORM (IV)
"^DD",799.4,799.4,12.05,21,0)
^.001^5^5^3030210^^
"^DD",799.4,799.4,12.05,21,1,0)
This field is used to contain data related to the 
"^DD",799.4,799.4,12.05,21,2,0)
facilty setting where the diagnosis was first
"^DD",799.4,799.4,12.05,21,3,0)
made.  The facility setting is public, federal,
"^DD",799.4,799.4,12.05,21,4,0)
etc. This field is used on the CDC HIV/AIDS 
"^DD",799.4,799.4,12.05,21,5,0)
reporting form.
"^DD",799.4,799.4,12.05,"DT")
3030210
"^DD",799.4,799.4,12.06,0)
AIDS DX - FACILITY TYPE^S^01:PHYSICIAN,HMO;31:HOSPITAL,INPATIENT;88:OTHER;^12;6^Q
"^DD",799.4,799.4,12.06,3)
Select the appropriate code to indicate the type of facility at which the AIDS diagnosis was made.
"^DD",799.4,799.4,12.06,20,0)
^.3LA^1^1
"^DD",799.4,799.4,12.06,20,1,0)
CDC FORM (IV)
"^DD",799.4,799.4,12.06,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,12.06,21,1,0)
This field holds information on the type of 
"^DD",799.4,799.4,12.06,21,2,0)
facility in which the diagnosis was originally
"^DD",799.4,799.4,12.06,21,3,0)
made for this patient.  This information is used
"^DD",799.4,799.4,12.06,21,4,0)
to generate the CDC HIV/AIDS form.
"^DD",799.4,799.4,12.06,"DT")
3030210
"^DD",799.4,799.4,12.07,0)
AIDS DX - OTHER FACILITY TYPE^F^^12;7^K:$L(X)>25!($L(X)<2) X
"^DD",799.4,799.4,12.07,3)
This field is used to specify the 'OTHER' type of facility at which the AIDS diagnosis was made. Answer must be 2-25 characters in length.
"^DD",799.4,799.4,12.07,20,0)
^.3LA^1^1
"^DD",799.4,799.4,12.07,20,1,0)
CDC FORM (IV)
"^DD",799.4,799.4,12.07,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,12.07,21,1,0)
If the facility type selected for the 'AIDS DX - 
"^DD",799.4,799.4,12.07,21,2,0)
FACILITY TYPE' field (12.06) is 'OTHER', then this
"^DD",799.4,799.4,12.07,21,3,0)
field is used to provide a text description of the
"^DD",799.4,799.4,12.07,21,4,0)
'OTHER' type.
"^DD",799.4,799.4,12.07,"DT")
3030210
"^DD",799.4,799.4,14.01,0)
SEX RELATIONS W/MALE PARTNER^S^1:YES;0:NO;9:UNKNOWN;^14;1^Q
"^DD",799.4,799.4,14.01,.1)
Sex With Male Partner
"^DD",799.4,799.4,14.01,3)
Indicate whether patient had sex with a male partner.
"^DD",799.4,799.4,14.01,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.01,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.01,21,0)
^^5^5^3030210^
"^DD",799.4,799.4,14.01,21,1,0)
This field contains the answer to the question 
"^DD",799.4,799.4,14.01,21,2,0)
'Did this patient after 1977 and preceding the
"^DD",799.4,799.4,14.01,21,3,0)
diagnosis of AIDS, have sexual relations with a
"^DD",799.4,799.4,14.01,21,4,0)
male partner?'  The field is used in printing 
"^DD",799.4,799.4,14.01,21,5,0)
part V of the CDC form.
"^DD",799.4,799.4,14.01,"DT")
2930401
"^DD",799.4,799.4,14.02,0)
SEX RELATIONS W/FEMALE PARTNER^S^1:YES;0:NO;9:UNKNOWN;^14;2^Q
"^DD",799.4,799.4,14.02,.1)
Sex With Female Partner
"^DD",799.4,799.4,14.02,3)
Indicate whether patient had sex with a female partner.
"^DD",799.4,799.4,14.02,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.02,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.02,21,0)
^^5^5^3030210^
"^DD",799.4,799.4,14.02,21,1,0)
This field contains the answer to the question 
"^DD",799.4,799.4,14.02,21,2,0)
'Did this patient, after 1977 and preceding the
"^DD",799.4,799.4,14.02,21,3,0)
diagnosis of AIDS, have sexual relations with a
"^DD",799.4,799.4,14.02,21,4,0)
female partner?'  The field is used in printing 
"^DD",799.4,799.4,14.02,21,5,0)
part V of the CDC form.
"^DD",799.4,799.4,14.02,"DT")
2930401
"^DD",799.4,799.4,14.03,0)
IV DRUGS AFTER 77 AND PRE HIV^S^0:NO;1:YES;9:UNKNOWN;^14;3^Q
"^DD",799.4,799.4,14.03,.1)
IV Drugs After 1977/Pre HIV
"^DD",799.4,799.4,14.03,3)
Indicate whether patient used IV drugs after 1977 and preceding HIV diagnosis.
"^DD",799.4,799.4,14.03,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.03,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.03,21,0)
^^7^7^3030210^
"^DD",799.4,799.4,14.03,21,1,0)
This field is used to indicate whether the 
"^DD",799.4,799.4,14.03,21,2,0)
patient used needles for self-injection of drugs
"^DD",799.4,799.4,14.03,21,3,0)
not prescribed by a physician during the period
"^DD",799.4,799.4,14.03,21,4,0)
after 1977 and before the diagnosis of AIDS.
"^DD",799.4,799.4,14.03,21,5,0)
 
"^DD",799.4,799.4,14.03,21,6,0)
This field is used in printing part V of the CDC 
"^DD",799.4,799.4,14.03,21,7,0)
form.
"^DD",799.4,799.4,14.03,"DT")
2930401
"^DD",799.4,799.4,14.04,0)
REC'D CLOTTING FACTORS^S^0:NO;1:YES;9:UNKNOWN;^14;4^Q
"^DD",799.4,799.4,14.04,.1)
BP1.  Received Clotting Factor
"^DD",799.4,799.4,14.04,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.04,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.04,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,14.04,21,1,0)
This field is used in part V of the CDC form to 
"^DD",799.4,799.4,14.04,21,2,0)
indicate whether the patient had received clotting
"^DD",799.4,799.4,14.04,21,3,0)
factors in the period between 1977 and the
"^DD",799.4,799.4,14.04,21,4,0)
diagnosis of AIDS.
"^DD",799.4,799.4,14.04,"DT")
2930401
"^DD",799.4,799.4,14.05,0)
TYPE OF HEMOPHILIA^S^1:HEMOPHILIA A (FACTOR VIII);2:HEMOPHILIA B (FACTOR IX);8:OTHER;^14;5^Q
"^DD",799.4,799.4,14.05,.1)
BP1.  Type of Hemophilia
"^DD",799.4,799.4,14.05,3)
Enter the type of hemophilia.
"^DD",799.4,799.4,14.05,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.05,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.05,21,0)
^.001^4^4^3030210^^^^
"^DD",799.4,799.4,14.05,21,1,0)
This field is used to indicate, for those patients who had received
"^DD",799.4,799.4,14.05,21,2,0)
clotting factors as indicated in field 15.9, the type of hemophilia 
"^DD",799.4,799.4,14.05,21,3,0)
for which clotting factors were given.   This field is used in
"^DD",799.4,799.4,14.05,21,4,0)
printing Part 2 of the CDC form.
"^DD",799.4,799.4,14.05,"DT")
3030210
"^DD",799.4,799.4,14.06,0)
OTHER HEMOPHILIA DESCRIPTION^F^^14;6^K:$L(X)>15!($L(X)<3) X
"^DD",799.4,799.4,14.06,.1)
BP1.  Other Hemophilia Desc.
"^DD",799.4,799.4,14.06,3)
If hemophilia is 'Other', indicate type.  Answer must be 3-15 characters in length.
"^DD",799.4,799.4,14.06,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.06,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.06,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,14.06,21,1,0)
This field is used to indicate the type of 
"^DD",799.4,799.4,14.06,21,2,0)
hemophilia, if OTHER is selected in field 14.05.
"^DD",799.4,799.4,14.06,21,3,0)
This field is used in printing Part V of the CDC
"^DD",799.4,799.4,14.06,21,4,0)
form.
"^DD",799.4,799.4,14.06,"DT")
2871217
"^DD",799.4,799.4,14.07,0)
SR WITH IV DRUG USER^S^0:NO;1:YES;9:UNKNOWN;^14;7^Q
"^DD",799.4,799.4,14.07,.1)
Sex With IV Drug Abuser
"^DD",799.4,799.4,14.07,3)
Indicate whether patient had sex with IV drug abuser.
"^DD",799.4,799.4,14.07,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.07,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.07,21,0)
^^5^5^3030210^
"^DD",799.4,799.4,14.07,21,1,0)
This field is used to store the answer to the 
"^DD",799.4,799.4,14.07,21,2,0)
question 'Did this patient have heterosexual
"^DD",799.4,799.4,14.07,21,3,0)
relations with any of the following: IV drug
"^DD",799.4,799.4,14.07,21,4,0)
user'  The response is used in printing part V of 
"^DD",799.4,799.4,14.07,21,5,0)
the CDC form.
"^DD",799.4,799.4,14.07,"DT")
2930401
"^DD",799.4,799.4,14.08,0)
SR WITH BISEXUAL MAN^S^0:NO;1:YES;9:UNKNOWN;^14;8^Q
"^DD",799.4,799.4,14.08,.1)
Sex With Bisexual Male
"^DD",799.4,799.4,14.08,3)
Indicate whether patient had sex with bisexual male.
"^DD",799.4,799.4,14.08,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.08,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.08,21,0)
^^8^8^3030210^
"^DD",799.4,799.4,14.08,21,1,0)
This field is used to store the answer to the 
"^DD",799.4,799.4,14.08,21,2,0)
question 'Did this patient have heterosexual
"^DD",799.4,799.4,14.08,21,3,0)
relations with any of the following: Bisexual
"^DD",799.4,799.4,14.08,21,4,0)
Man'.  
"^DD",799.4,799.4,14.08,21,5,0)
 
"^DD",799.4,799.4,14.08,21,6,0)
Note that this question should be ignored for Male
"^DD",799.4,799.4,14.08,21,7,0)
patients. The response is used in printing part V
"^DD",799.4,799.4,14.08,21,8,0)
of the CDC form.
"^DD",799.4,799.4,14.08,"DT")
2930401
"^DD",799.4,799.4,14.09,0)
SR W HEMOPHILIA/COAG DISORDER^S^0:NO;1:YES;9:UNKNOWN;^14;9^Q
"^DD",799.4,799.4,14.09,.1)
Sex With Hemophiliac/Coagulation Disorder
"^DD",799.4,799.4,14.09,3)
Indicate whether patient had sex with person with hemophilia/coagulation disorder.
"^DD",799.4,799.4,14.09,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.09,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.09,21,0)
^^5^5^3030210^
"^DD",799.4,799.4,14.09,21,1,0)
This field is used to store the answer to the 
"^DD",799.4,799.4,14.09,21,2,0)
question 'Did this patient have heterosexual
"^DD",799.4,799.4,14.09,21,3,0)
relations with any of the following: Person with
"^DD",799.4,799.4,14.09,21,4,0)
hemophilia/coagulation disorder.'  The response 
"^DD",799.4,799.4,14.09,21,5,0)
is used in printing part V of the CDC form.
"^DD",799.4,799.4,14.09,"DT")
2930401
"^DD",799.4,799.4,14.1,0)
SR W TRANS RECIPIENT WITH AIDS^S^0:NO;1:YES;9:UNKNOWN;^14;10^Q
"^DD",799.4,799.4,14.1,.1)
Sex With Transfusion Recipient with AIDS
"^DD",799.4,799.4,14.1,3)
Indicate whether patient had sex with transfusion recipient with AIDS or documented HIV infection.
"^DD",799.4,799.4,14.1,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.1,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.1,21,0)
^^6^6^3030210^
"^DD",799.4,799.4,14.1,21,1,0)
This field is used to store the answer to the 
"^DD",799.4,799.4,14.1,21,2,0)
question 'Did this patient have heterosexual
"^DD",799.4,799.4,14.1,21,3,0)
relations with any of the following: Blood
"^DD",799.4,799.4,14.1,21,4,0)
transfusion recipient with AIDS or documented HIV 
"^DD",799.4,799.4,14.1,21,5,0)
infection.'  This field is used in printing part V
"^DD",799.4,799.4,14.1,21,6,0)
of the CDC form.
"^DD",799.4,799.4,14.1,"DT")
2930401
"^DD",799.4,799.4,14.11,0)
TRANSPLANT RECIP-DOCUMNTD HIV^S^1:YES;0:NO;9:UNKNOWN;^14;11^Q
"^DD",799.4,799.4,14.11,3)
This entry should reflect whether the patient is a transplant recipient with documented HIV infection.  The entry is used on the CDC HIV/AIDS report form.
"^DD",799.4,799.4,14.11,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.11,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.11,21,0)
^.001^4^4^3030210^^
"^DD",799.4,799.4,14.11,21,1,0)
This field should reflect whether the patient is 
"^DD",799.4,799.4,14.11,21,2,0)
a transplant recipient with documented HIV
"^DD",799.4,799.4,14.11,21,3,0)
infection.  The field is used on the CDC HIV/AIDS
"^DD",799.4,799.4,14.11,21,4,0)
report form.
"^DD",799.4,799.4,14.11,"DT")
2940628
"^DD",799.4,799.4,14.12,0)
SR W AIDS/HIV INFECTION^S^0:NO;1:YES;9:UNKNOWN;^14;12^Q
"^DD",799.4,799.4,14.12,.1)
Sex With AIDS/HIV Infected Person
"^DD",799.4,799.4,14.12,3)
Indicate whether patient had sex with person with AIDS or documented HIV infection.
"^DD",799.4,799.4,14.12,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.12,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.12,21,0)
^^5^5^3030210^
"^DD",799.4,799.4,14.12,21,1,0)
This field is used to store the answer to the 
"^DD",799.4,799.4,14.12,21,2,0)
question 'Did this patient have heterosexual
"^DD",799.4,799.4,14.12,21,3,0)
relations with any of the following: Person with
"^DD",799.4,799.4,14.12,21,4,0)
AIDS or documented HIV infection.'  This field is 
"^DD",799.4,799.4,14.12,21,5,0)
used in printing part V of the CDC form.
"^DD",799.4,799.4,14.12,"DT")
2930401
"^DD",799.4,799.4,14.13,0)
TRANS AFTER 77 AND BEFORE HIV^S^0:NO;1:YES;9:UNKNOWN;^14;13^Q
"^DD",799.4,799.4,14.13,.1)
Trans After 1977/Pre HIV
"^DD",799.4,799.4,14.13,3)
Indicate whether patient had transfusion(s) after 1977 and prior to HIV Dx.
"^DD",799.4,799.4,14.13,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.13,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.13,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,14.13,21,1,0)
This field is used to indicate if the patient had 
"^DD",799.4,799.4,14.13,21,2,0)
a transfusion after 1977 and before diagnosis of
"^DD",799.4,799.4,14.13,21,3,0)
AIDS.  This field is used in printing Part V of
"^DD",799.4,799.4,14.13,21,4,0)
the CDC form.
"^DD",799.4,799.4,14.13,"DT")
2930401
"^DD",799.4,799.4,14.14,0)
DATE OF FIRST TRANSFUSION^D^^14;14^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,14.14,.1)
Date of First Transfusion
"^DD",799.4,799.4,14.14,3)
Enter date of patient's first transfusion.
"^DD",799.4,799.4,14.14,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.14,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.14,21,0)
^^6^6^3030210^
"^DD",799.4,799.4,14.14,21,1,0)
This is the date of the first transfusion after 
"^DD",799.4,799.4,14.14,21,2,0)
1977. This field is only required if the patient
"^DD",799.4,799.4,14.14,21,3,0)
did have a transfusion after 1977 and before the
"^DD",799.4,799.4,14.14,21,4,0)
diagnosis of AIDS, AND this is the only risk 
"^DD",799.4,799.4,14.14,21,5,0)
factor for the patient. This field is used in
"^DD",799.4,799.4,14.14,21,6,0)
printing Part V of the CDC form.
"^DD",799.4,799.4,14.14,"DT")
2871217
"^DD",799.4,799.4,14.15,0)
DATE OF LAST TRANSFUSION^D^^14;15^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,14.15,.1)
Date of Last Transfusion
"^DD",799.4,799.4,14.15,3)
Enter date of patient's last transfusion.
"^DD",799.4,799.4,14.15,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.15,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.15,21,0)
^^6^6^3030210^
"^DD",799.4,799.4,14.15,21,1,0)
This is the date of the last transfusion after 
"^DD",799.4,799.4,14.15,21,2,0)
1977. This field is only required if the patient
"^DD",799.4,799.4,14.15,21,3,0)
did have a transfusion after 1977 and before the
"^DD",799.4,799.4,14.15,21,4,0)
diagnosis of AIDS (YES to field #14.13), AND this
"^DD",799.4,799.4,14.15,21,5,0)
is the only risk factor for the patient.  This 
"^DD",799.4,799.4,14.15,21,6,0)
field is used in printing Part V of the CDC form.
"^DD",799.4,799.4,14.15,"DT")
2871217
"^DD",799.4,799.4,14.16,0)
TRANSPLANT OR ARTIF INSEMIN^S^1:YES;0:NO;9:UNKNOWN;^14;16^Q
"^DD",799.4,799.4,14.16,3)
Indicate whether the patient received a transplant of tissue/organs or artificial insemination.
"^DD",799.4,799.4,14.16,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.16,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.16,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,14.16,21,1,0)
This field is used to indicate whether the 
"^DD",799.4,799.4,14.16,21,2,0)
patient was the recipient of a transplant or
"^DD",799.4,799.4,14.16,21,3,0)
artificial insemination following 1977 and prior 
"^DD",799.4,799.4,14.16,21,4,0)
to being diagnosed as HIV positive.
"^DD",799.4,799.4,14.16,"DT")
2930401
"^DD",799.4,799.4,14.17,0)
WORK IN HEALTH CARE OR LAB^S^0:NO;1:YES;9:UNKNOWN;^14;17^Q
"^DD",799.4,799.4,14.17,.1)
Health Care/Lab Worker
"^DD",799.4,799.4,14.17,3)
Indicate whether patient has worked as health care or lab worker.
"^DD",799.4,799.4,14.17,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.17,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.17,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,14.17,21,1,0)
After 1977 and preceding the diagnosis of AIDS 
"^DD",799.4,799.4,14.17,21,2,0)
did the patient work in a health care or clinical
"^DD",799.4,799.4,14.17,21,3,0)
laboratory setting?  This field is used in
"^DD",799.4,799.4,14.17,21,4,0)
printing Part V of the CDC form.
"^DD",799.4,799.4,14.17,"DT")
2930401
"^DD",799.4,799.4,14.18,0)
OCCUPATION^F^^14;18^K:$L(X)>30!($L(X)<3) X
"^DD",799.4,799.4,14.18,.1)
Occupation
"^DD",799.4,799.4,14.18,3)
If patient has worked as health care or lab worker, indicate occupation.  Answer must be 3-30 characters in length.
"^DD",799.4,799.4,14.18,20,0)
^.3LA^1^1
"^DD",799.4,799.4,14.18,20,1,0)
CDC FORM (V)
"^DD",799.4,799.4,14.18,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,14.18,21,1,0)
If the patient did work in a health care or 
"^DD",799.4,799.4,14.18,21,2,0)
clinical lab after 1977 and prior to the diagnosis
"^DD",799.4,799.4,14.18,21,3,0)
of AIDS (YES to field #14.17), this field is used
"^DD",799.4,799.4,14.18,21,4,0)
to specify the occupation.
"^DD",799.4,799.4,14.18,"DT")
2900905
"^DD",799.4,799.4,16.01,0)
HIV-1 EIA^S^1:POSITIVE;0:NEGATIVE;9:NOT DONE;^16;1^Q
"^DD",799.4,799.4,16.01,3)
Enter the result of the ELISA antibody test.
"^DD",799.4,799.4,16.01,20,0)
^.3LA^1^1
"^DD",799.4,799.4,16.01,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,16.01,21,0)
^^3^3^3030210^
"^DD",799.4,799.4,16.01,21,1,0)
This field is used in filling out part VI of the 
"^DD",799.4,799.4,16.01,21,2,0)
CDC form, and indicates whether an ELISA test for
"^DD",799.4,799.4,16.01,21,3,0)
HIV was performed, and if so what the result was.
"^DD",799.4,799.4,16.01,"DT")
3030210
"^DD",799.4,799.4,16.02,0)
HIV-1 EIA DATE^D^^16;2^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,16.02,3)
Enter the date (Month and Year) for the FIRST POSITIVE TEST, or the test date
"^DD",799.4,799.4,16.02,20,0)
^.3LA^1^1
"^DD",799.4,799.4,16.02,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,16.02,21,0)
^^3^3^3030210^
"^DD",799.4,799.4,16.02,21,1,0)
This field is used to contain the date (month and 
"^DD",799.4,799.4,16.02,21,2,0)
year) when the indicated result in part VI of the
"^DD",799.4,799.4,16.02,21,3,0)
revised CDC form was originally determined.
"^DD",799.4,799.4,16.02,"DT")
3030210
"^DD",799.4,799.4,16.03,0)
HIV-1/HIV-2 EIA^S^1:POSITIVE;0:NEGATIVE;9:NOT DONE;^16;3^Q
"^DD",799.4,799.4,16.03,3)
Enter the result of the HIV-1/HIV-2 combination EIA test.
"^DD",799.4,799.4,16.03,20,0)
^.3LA^1^1
"^DD",799.4,799.4,16.03,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,16.03,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,16.03,21,1,0)
This field is used to hold information on whether 
"^DD",799.4,799.4,16.03,21,2,0)
an HIV-1/HIV-2 EIA was performed on the patient
"^DD",799.4,799.4,16.03,21,3,0)
and, if so, the result.  This information is used
"^DD",799.4,799.4,16.03,21,4,0)
to generate the CDC HIV/AIDS form.
"^DD",799.4,799.4,16.03,"DT")
3030210
"^DD",799.4,799.4,16.04,0)
HIV-1/HIV-2 EIA DATE^D^^16;4^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,16.04,3)
Enter the date of the MOST RECENT HIV-1/HIV-2 combination EIA test.
"^DD",799.4,799.4,16.04,20,0)
^.3LA^1^1
"^DD",799.4,799.4,16.04,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,16.04,21,0)
^^3^3^3030210^
"^DD",799.4,799.4,16.04,21,1,0)
This field is used to indicate the date on which 
"^DD",799.4,799.4,16.04,21,2,0)
an HIV-1/HIV-2 EIA test was performed.  It is used
"^DD",799.4,799.4,16.04,21,3,0)
to generate the CDC HIV/AIDS form.
"^DD",799.4,799.4,16.04,"DT")
2940803
"^DD",799.4,799.4,16.05,0)
HIV-1 WESTERN BLOT/IFA^S^1:POSITIVE;0:NEGATIVE;8:INDETERMINATE;9:NOT DONE;^16;5^Q
"^DD",799.4,799.4,16.05,.1)
WESTERN BLOT
"^DD",799.4,799.4,16.05,3)
Enter the result of the Western blot antibody test.
"^DD",799.4,799.4,16.05,20,0)
^.3LA^1^1
"^DD",799.4,799.4,16.05,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,16.05,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,16.05,21,1,0)
This field is used in filling out part VI of the 
"^DD",799.4,799.4,16.05,21,2,0)
CDC form, and indicates whether a WESTERN BLOT
"^DD",799.4,799.4,16.05,21,3,0)
test was performed for HIV, and if so what the
"^DD",799.4,799.4,16.05,21,4,0)
result was.
"^DD",799.4,799.4,16.05,"DT")
3030210
"^DD",799.4,799.4,16.06,0)
HIV-1 WESTERN BLOT/IFA DATE^D^^16;6^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,16.06,3)
Enter the date (Month and Year) for the FIRST POSITIVE TEST, or the test date
"^DD",799.4,799.4,16.06,20,0)
^.3LA^1^1
"^DD",799.4,799.4,16.06,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,16.06,21,0)
^^3^3^3030210^
"^DD",799.4,799.4,16.06,21,1,0)
This field is used to contain the date (month and 
"^DD",799.4,799.4,16.06,21,2,0)
year) when the indicated result in part VI of the
"^DD",799.4,799.4,16.06,21,3,0)
revised CDC form was originally determined.
"^DD",799.4,799.4,16.06,"DT")
3030210
"^DD",799.4,799.4,16.07,0)
OTHER HIV ANTIBODY TEST^S^1:POSITIVE;0:NEGATIVE;8:INDETERMINATE;9:NOT DONE;^16;7^Q
"^DD",799.4,799.4,16.07,.1)
Other Antibody Test
"^DD",799.4,799.4,16.07,3)
Enter the result of "Other" antibody test.
"^DD",799.4,799.4,16.07,20,0)
^.3LA^1^1
"^DD",799.4,799.4,16.07,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,16.07,21,0)
^^5^5^3030210^
"^DD",799.4,799.4,16.07,21,1,0)
This field is used in filling out part VI of the 
"^DD",799.4,799.4,16.07,21,2,0)
CDC form, and is used to indicate whether an
"^DD",799.4,799.4,16.07,21,3,0)
antibody test for HIV was performed other than the
"^DD",799.4,799.4,16.07,21,4,0)
ELISA or WESTERN BLOT, and the result of this 
"^DD",799.4,799.4,16.07,21,5,0)
test.
"^DD",799.4,799.4,16.07,"DT")
3030210
"^DD",799.4,799.4,16.08,0)
OTHER HIV ANTIBODY TEST DATE^D^^16;8^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,16.08,3)
Enter the date (Month and Year) for the FIRST POSITIVE TEST, or the test date
"^DD",799.4,799.4,16.08,20,0)
^.3LA^1^1
"^DD",799.4,799.4,16.08,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,16.08,21,0)
^^3^3^3030210^
"^DD",799.4,799.4,16.08,21,1,0)
This field is used to contain the date (month and 
"^DD",799.4,799.4,16.08,21,2,0)
year) when the indicated result in part VI of the
"^DD",799.4,799.4,16.08,21,3,0)
revised CDC form was originally determined.
"^DD",799.4,799.4,16.08,"DT")
3030210
"^DD",799.4,799.4,16.09,0)
OTHER HIV ANTIBODY TEST DESC^F^^16;9^K:$L(X)>15!($L(X)<1) X
"^DD",799.4,799.4,16.09,3)
Describe the type of "Other" antibody test.  Answer must be 1-15 characters in length.
"^DD",799.4,799.4,16.09,20,0)
^.3LA^1^1
"^DD",799.4,799.4,16.09,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,16.09,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,16.09,21,1,0)
This field is used to name or describe the OTHER 
"^DD",799.4,799.4,16.09,21,2,0)
ANTIBODY test used, if field 16.07 indicates that
"^DD",799.4,799.4,16.09,21,3,0)
an OTHER ANTIBODY test was used.  This field is
"^DD",799.4,799.4,16.09,21,4,0)
used in filling out part VI of the CDC form.
"^DD",799.4,799.4,16.09,"DT")
3030210
"^DD",799.4,799.4,16.11,0)
* HIV-2 SERUM EIA^S^1:POSITIVE;0:NEGATIVE;9:NOT DONE;^16;11^Q
"^DD",799.4,799.4,16.11,3)
Indicate the type of results (or NOT DONE) for HIV-2 serum antibody EIA tests.
"^DD",799.4,799.4,16.11,20,0)
^.3LA^1^1
"^DD",799.4,799.4,16.11,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,16.11,21,0)
^^2^2^3030210^
"^DD",799.4,799.4,16.11,21,1,0)
This field is used to enter the results of a test 
"^DD",799.4,799.4,16.11,21,2,0)
for the HIV-2 virus by serum EIA.
"^DD",799.4,799.4,16.11,"DT")
3030410
"^DD",799.4,799.4,16.12,0)
* HIV-2 SERUM EIA DATE^D^^16;12^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,16.12,3)
Enter the date (Month and Year) for the FIRST POSITIVE TEST, or the test date
"^DD",799.4,799.4,16.12,20,0)
^.3LA^1^1
"^DD",799.4,799.4,16.12,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,16.12,21,0)
^^3^3^3030210^
"^DD",799.4,799.4,16.12,21,1,0)
This field is used to contain the date (month and 
"^DD",799.4,799.4,16.12,21,2,0)
year) when the indicated result in part VI of the
"^DD",799.4,799.4,16.12,21,3,0)
revised CDC form was originally determined.
"^DD",799.4,799.4,16.12,"DT")
3030410
"^DD",799.4,799.4,16.13,0)
* HIV-2 WESTERN BLOT^S^1:POSITIVE;0:NEGATIVE;8:INDETERMINATE;9:NOT DONE;^16;13^Q
"^DD",799.4,799.4,16.13,3)
Enter the result for the Western Blot test for HIV-2
"^DD",799.4,799.4,16.13,20,0)
^.3LA^1^1
"^DD",799.4,799.4,16.13,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,16.13,21,0)
^^5^5^3030210^
"^DD",799.4,799.4,16.13,21,1,0)
This field is used to hold information on whether 
"^DD",799.4,799.4,16.13,21,2,0)
an HIV-2 Wester Blot test was performed on the
"^DD",799.4,799.4,16.13,21,3,0)
patient and, if so, the result of the test. This
"^DD",799.4,799.4,16.13,21,4,0)
information is used to generate the CDC HIV/AIDS 
"^DD",799.4,799.4,16.13,21,5,0)
form.
"^DD",799.4,799.4,16.13,"DT")
3030410
"^DD",799.4,799.4,16.14,0)
* HIV-2 WESTERN BLOT DATE^D^^16;14^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,16.14,3)
Enter the date of the MOST RECENT Western Blot test for the HIV-2 virus
"^DD",799.4,799.4,16.14,20,0)
^.3LA^1^1
"^DD",799.4,799.4,16.14,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,16.14,21,0)
^^4^4^3030210^
"^DD",799.4,799.4,16.14,21,1,0)
This field is used to hold the date on which an 
"^DD",799.4,799.4,16.14,21,2,0)
HIV-2 Western Blot test was performed on the
"^DD",799.4,799.4,16.14,21,3,0)
patient.  This information is used to generate the
"^DD",799.4,799.4,16.14,21,4,0)
CDC HIV/AIDS form.
"^DD",799.4,799.4,16.14,"DT")
3030410
"^DD",799.4,799.4,18.01,0)
HIV CULTURE DETECTION TEST^D^^18;1^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,18.01,3)
Enter the DATE of the FIRST POSITIVE HIV culture detection test.
"^DD",799.4,799.4,18.01,20,0)
^.3LA^1^1
"^DD",799.4,799.4,18.01,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,18.01,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,18.01,21,1,0)
This field is used to hold the date on which an 
"^DD",799.4,799.4,18.01,21,2,0)
HIV culture test first produced a positive
"^DD",799.4,799.4,18.01,21,3,0)
result.  This information is used to generate the
"^DD",799.4,799.4,18.01,21,4,0)
CDC HIV/AIDS form.
"^DD",799.4,799.4,18.01,"DT")
2941026
"^DD",799.4,799.4,18.02,0)
HIV ANTIGEN DETECTION TEST^D^^18;2^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,18.02,3)
Enter the DATE of the FIRST POSITIVE HIV ANTIGEN detection test.
"^DD",799.4,799.4,18.02,20,0)
^.3LA^1^1
"^DD",799.4,799.4,18.02,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,18.02,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,18.02,21,1,0)
This field is used for the date of the first 
"^DD",799.4,799.4,18.02,21,2,0)
positive HIV antigen detection test which was run.
"^DD",799.4,799.4,18.02,21,3,0)
The data is used in generating the CDC HIV/AIDS
"^DD",799.4,799.4,18.02,21,4,0)
form.
"^DD",799.4,799.4,18.02,"DT")
2941026
"^DD",799.4,799.4,18.03,0)
HIV PCR, DNA, OR RNA PROBE^D^^18;3^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,18.03,3)
Enter the DATE of the FIRST POSITIVE PCR, DNA, or RNA detection test for HIV.
"^DD",799.4,799.4,18.03,20,0)
^.3LA^1^1
"^DD",799.4,799.4,18.03,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,18.03,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,18.03,21,1,0)
This field is used to hold the date on which an 
"^DD",799.4,799.4,18.03,21,2,0)
HIV test involving PCR, DNA or RNA probes first
"^DD",799.4,799.4,18.03,21,3,0)
produced a positive result.  This information is
"^DD",799.4,799.4,18.03,21,4,0)
used to generate the CDC HIV/AIDS form.
"^DD",799.4,799.4,18.03,"DT")
2941026
"^DD",799.4,799.4,18.04,0)
TYPE OF OTHER POSITIVE TEST^F^^18;4^K:$L(X)>30!($L(X)<3) X
"^DD",799.4,799.4,18.04,3)
Enter the TYPE of OTHER HIV detection test which was POSITIVE
"^DD",799.4,799.4,18.04,20,0)
^.3LA^1^1
"^DD",799.4,799.4,18.04,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,18.04,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,18.04,21,1,0)
This field is used to indicate the type of other 
"^DD",799.4,799.4,18.04,21,2,0)
HIV detection test which yielded a positive
"^DD",799.4,799.4,18.04,21,3,0)
result. This information is used to generate the
"^DD",799.4,799.4,18.04,21,4,0)
CDC HIV/AIDS form.
"^DD",799.4,799.4,18.04,"DT")
2950519
"^DD",799.4,799.4,18.05,0)
DATE OTHER POS DETECTION TEST^D^^18;5^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,18.05,3)
Enter the DATE for the OTHER positive HIV test.
"^DD",799.4,799.4,18.05,20,0)
^.3LA^1^1
"^DD",799.4,799.4,18.05,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,18.05,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,18.05,21,1,0)
This field is used to hold the date on which a 
"^DD",799.4,799.4,18.05,21,2,0)
positive HIV detection test was obtained with an
"^DD",799.4,799.4,18.05,21,3,0)
"other" type of test. This information is used to
"^DD",799.4,799.4,18.05,21,4,0)
generate the CDC HIV/AIDS form.
"^DD",799.4,799.4,18.05,"DT")
2941026
"^DD",799.4,799.4,18.06,0)
LAST DOCUMNTD NEG HIV TEST^D^^18;6^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,18.06,3)
Enter the date on which the last DOCUMENTED negative HIV test was obtained for this patient
"^DD",799.4,799.4,18.06,20,0)
^.3LA^1^1
"^DD",799.4,799.4,18.06,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,18.06,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,18.06,21,1,0)
This field is used to hold the date on which the 
"^DD",799.4,799.4,18.06,21,2,0)
patient last had a documented negative HIV test.
"^DD",799.4,799.4,18.06,21,3,0)
This information is used to generate the CDC
"^DD",799.4,799.4,18.06,21,4,0)
HIV/AIDS form.
"^DD",799.4,799.4,18.06,"DT")
2940803
"^DD",799.4,799.4,18.07,0)
TYPE FOR LAST NEG TEST^F^^18;7^K:$L(X)>30!($L(X)<3) X
"^DD",799.4,799.4,18.07,3)
Enter the TYPE of HIV test which was the last documented NEGATIVE HIV test for this patient.  Enter 3-30 characters.
"^DD",799.4,799.4,18.07,20,0)
^.3LA^1^1
"^DD",799.4,799.4,18.07,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,18.07,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,18.07,21,1,0)
This field is used to hold information on the type
"^DD",799.4,799.4,18.07,21,2,0)
of test which resulted in the last documented
"^DD",799.4,799.4,18.07,21,3,0)
negative HIV test (field 18.06). This information
"^DD",799.4,799.4,18.07,21,4,0)
is used to generate the CDC HIV/AIDS form.
"^DD",799.4,799.4,18.07,"DT")
2940803
"^DD",799.4,799.4,18.08,0)
PHYS DOCUMNTD DIAGNOSIS?^S^1:YES;0:NO;9:UNKNONW;^18;8^Q
"^DD",799.4,799.4,18.08,3)
Indicate whether, if HIV laboratory tests were not documented, the HIV diagnosis was documented by a physician.
"^DD",799.4,799.4,18.08,20,0)
^.3LA^1^1
"^DD",799.4,799.4,18.08,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,18.08,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,18.08,21,1,0)
This field is used to indicate whether a physician
"^DD",799.4,799.4,18.08,21,2,0)
has documented the diagnosis of HIV or AIDS in
"^DD",799.4,799.4,18.08,21,3,0)
this patient. The information is used to generate
"^DD",799.4,799.4,18.08,21,4,0)
the CDC HIV/AIDS form.
"^DD",799.4,799.4,18.08,"DT")
2940803
"^DD",799.4,799.4,18.09,0)
DATE PHYS DOCUMNTD DIAG^D^^18;9^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,18.09,3)
If HIV laboratory tests were not documented, enter the DATE that the HIV diagnosis was documented by a physician.
"^DD",799.4,799.4,18.09,20,0)
^.3LA^1^1
"^DD",799.4,799.4,18.09,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,18.09,21,0)
^^5^5^3030211^
"^DD",799.4,799.4,18.09,21,1,0)
This field is used for the date on which the 
"^DD",799.4,799.4,18.09,21,2,0)
physician documented the diagnosis on this patient
"^DD",799.4,799.4,18.09,21,3,0)
if this is the case as indicated by field 18.08.
"^DD",799.4,799.4,18.09,21,4,0)
The information is used to generate the CDC 
"^DD",799.4,799.4,18.09,21,5,0)
HIV/AIDS form.
"^DD",799.4,799.4,18.09,"DT")
2940803
"^DD",799.4,799.4,18.1,0)
DETECTABLE VIRAL LOAD TEST^S^11:NASBA (Organon);12:RT-PCR (Roche);13:bDNA (Chiron);18:Other;^18;10^Q
"^DD",799.4,799.4,18.1,20,0)
^.3LA^1^1
"^DD",799.4,799.4,18.1,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,18.1,"DT")
3030410
"^DD",799.4,799.4,18.11,0)
DETECTABLE VIRAL LOAD RESULT^NJ7,0^^18;11^K:+X'=X!(X>9999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",799.4,799.4,18.11,3)
Type a Number between 0 and 9999999, 0 Decimal Digits
"^DD",799.4,799.4,18.11,20,0)
^.3LA^1^1
"^DD",799.4,799.4,18.11,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,18.11,"DT")
3030410
"^DD",799.4,799.4,18.12,0)
DETECTABLE VIRAL LOAD DATE^D^^18;12^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,18.12,20,0)
^.3LA^1^1
"^DD",799.4,799.4,18.12,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,18.12,"DT")
3030410
"^DD",799.4,799.4,18.13,0)
POSITIVE HIV DETECTION TEST^S^1:CULTURE;2:ANTIGEN;3:PCR, DNA OR RNA PROBE;^18;13^Q
"^DD",799.4,799.4,18.13,20,0)
^.3LA^1^1
"^DD",799.4,799.4,18.13,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,18.13,"DT")
3030416
"^DD",799.4,799.4,20.01,0)
CD4+ COUNT FOR CDC^NJ5,0^^20;1^K:+X'=X!(X>99999)!(X<0)!(X?.E1"."1N.N) X
"^DD",799.4,799.4,20.01,3)
Enter the actual count, expressed as number of cells per microliter, of T-helper (CD4+) lymphocytes.
"^DD",799.4,799.4,20.01,20,0)
^.3LA^1^1
"^DD",799.4,799.4,20.01,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,20.01,21,0)
^^2^2^3030211^
"^DD",799.4,799.4,20.01,21,1,0)
This field is used to contain the CD4+ count 
"^DD",799.4,799.4,20.01,21,2,0)
entered for part VI of the revised CDC form.
"^DD",799.4,799.4,20.01,"DT")
3030211
"^DD",799.4,799.4,20.02,0)
CD4+ COUNT FOR CDC DATE^D^^20;2^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,20.02,3)
Enter the date (Month and Year) for the FIRST POSITIVE TEST, or the test date
"^DD",799.4,799.4,20.02,20,0)
^.3LA^1^1
"^DD",799.4,799.4,20.02,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,20.02,21,0)
^^3^3^3030211^
"^DD",799.4,799.4,20.02,21,1,0)
This field is used to contain the date (month and 
"^DD",799.4,799.4,20.02,21,2,0)
year) when the indicated result in part VI of the
"^DD",799.4,799.4,20.02,21,3,0)
revised CDC form was originally determined.
"^DD",799.4,799.4,20.02,"DT")
3030211
"^DD",799.4,799.4,20.03,0)
CD4+ PERCENT FOR CDC^NJ2,0^^20;3^K:+X'=X!(X>99)!(X<0)!(X?.E1"."1N.N) X
"^DD",799.4,799.4,20.03,3)
Type a Number between 0 and 99, 0 Decimal Digits to indicate the percent of the lymphocyte population which was CD4+ lymphocytes.
"^DD",799.4,799.4,20.03,20,0)
^.3LA^1^1
"^DD",799.4,799.4,20.03,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,20.03,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,20.03,21,1,0)
This field is used to enter the percentage of 
"^DD",799.4,799.4,20.03,21,2,0)
CD4+ leukocytes present in the leukocyte
"^DD",799.4,799.4,20.03,21,3,0)
population.  The value is used for part VI of the 
"^DD",799.4,799.4,20.03,21,4,0)
revised CDC form.
"^DD",799.4,799.4,20.03,"DT")
3030211
"^DD",799.4,799.4,20.04,0)
CD4+ PERCENT FOR CDC DATE^D^^20;4^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,20.04,3)
Enter the DATE for the CD4 PERCENTAGE at or near the current diagnostic status.
"^DD",799.4,799.4,20.04,20,0)
^.3LA^1^1
"^DD",799.4,799.4,20.04,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,20.04,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,20.04,21,1,0)
This field is used to store the date on which the 
"^DD",799.4,799.4,20.04,21,2,0)
percentage CD4 value was determined at or closest
"^DD",799.4,799.4,20.04,21,3,0)
to the current diagnosis.  This information is
"^DD",799.4,799.4,20.04,21,4,0)
used to generate the CDC HIV/AIDS form.
"^DD",799.4,799.4,20.04,"DT")
3030211
"^DD",799.4,799.4,20.05,0)
CD4 COUNT FIRST <200^NJ3,0^^20;5^K:+X'=X!(X>200)!(X<0)!(X?.E1"."1N.N) X
"^DD",799.4,799.4,20.05,3)
Enter the first CD4 COUNT which was below 200.  This should be a number between 0 and 199
"^DD",799.4,799.4,20.05,20,0)
^.3LA^1^1
"^DD",799.4,799.4,20.05,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,20.05,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,20.05,21,1,0)
This field is used to contain the number count 
"^DD",799.4,799.4,20.05,21,2,0)
for the CD4 count which first was below the value
"^DD",799.4,799.4,20.05,21,3,0)
of 200. This information is used to generate the
"^DD",799.4,799.4,20.05,21,4,0)
CDC HIV/AIDS form.
"^DD",799.4,799.4,20.05,"DT")
2941026
"^DD",799.4,799.4,20.06,0)
CD4 COUNT FIRST <200 DATE^D^^20;6^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,20.06,3)
Enter the date for the CD4 count which first gave a value of less than 200.
"^DD",799.4,799.4,20.06,20,0)
^.3LA^1^1
"^DD",799.4,799.4,20.06,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,20.06,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,20.06,21,1,0)
This field is used to hold the date on which the 
"^DD",799.4,799.4,20.06,21,2,0)
CD4 count was first below the value of 200. This
"^DD",799.4,799.4,20.06,21,3,0)
information is used to generate the CDC HIV/AIDS
"^DD",799.4,799.4,20.06,21,4,0)
form.
"^DD",799.4,799.4,20.06,"DT")
2941026
"^DD",799.4,799.4,20.07,0)
CD4 PERCENT FIRST <14%^NJ4,1^^20;7^K:+X'=X!(X>13)!(X<0)!(X?.E1"."2N.N) X
"^DD",799.4,799.4,20.07,3)
Enter the CD4 PERCENTAGE which first gave a value of less than 14 %.
"^DD",799.4,799.4,20.07,20,0)
^.3LA^1^1
"^DD",799.4,799.4,20.07,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,20.07,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,20.07,21,1,0)
This field is used to hold the CD4 percentage 
"^DD",799.4,799.4,20.07,21,2,0)
value which was obtained when the percentage was
"^DD",799.4,799.4,20.07,21,3,0)
first below 14%. This information is used to
"^DD",799.4,799.4,20.07,21,4,0)
generate the CDC HIV/AIDS form.
"^DD",799.4,799.4,20.07,"DT")
2941026
"^DD",799.4,799.4,20.08,0)
CD4 PERCENT FIRST <14% DATE^D^^20;8^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,20.08,.1)
Date of First CD4 Percentage value of less than 14%
"^DD",799.4,799.4,20.08,3)
Enter the date of the first CD4 PERCENTAGE which resulted in a value of less than 14%.
"^DD",799.4,799.4,20.08,20,0)
^.3LA^1^1
"^DD",799.4,799.4,20.08,20,1,0)
CDC FORM (VI)
"^DD",799.4,799.4,20.08,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,20.08,21,1,0)
This field is used to hold the date on which the 
"^DD",799.4,799.4,20.08,21,2,0)
percentage CD4 value was first observed to be
"^DD",799.4,799.4,20.08,21,3,0)
below 14%. This information is used to generate
"^DD",799.4,799.4,20.08,21,4,0)
the CDC HIV/AIDS form.
"^DD",799.4,799.4,20.08,"DT")
2941026
"^DD",799.4,799.4,22.01,0)
PATIENT BEEN INFORMED OF HIV^S^1:YES;0:NO;9:UNKNOWN;^22;1^Q
"^DD",799.4,799.4,22.01,.1)
Has the Patient been informed of HIV Infection?
"^DD",799.4,799.4,22.01,3)
This field is used to indicate whether the patient has been informed of the diagnosis of HIV infection.
"^DD",799.4,799.4,22.01,20,0)
^.3LA^1^1
"^DD",799.4,799.4,22.01,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,22.01,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,22.01,21,1,0)
This field is used to indicate whether the patient
"^DD",799.4,799.4,22.01,21,2,0)
has been informed of the diagnosis of HIV
"^DD",799.4,799.4,22.01,21,3,0)
infection. The field is used to supply data for
"^DD",799.4,799.4,22.01,21,4,0)
the CDC HIV/AIDS form.
"^DD",799.4,799.4,22.01,"DT")
2940628
"^DD",799.4,799.4,22.02,0)
PARTNERS NOTIFIED BY^S^1:Health Dept.;2:Physician/Provider;3:Patient;9:Unknown;^22;2^Q
"^DD",799.4,799.4,22.02,.1)
Patient's sexual Partners will be notified by
"^DD",799.4,799.4,22.02,3)
This field is used to indicate the entity with responsiblity for informing the patient's sexual partners of the patient's HIV infection.
"^DD",799.4,799.4,22.02,20,0)
^.3LA^1^1
"^DD",799.4,799.4,22.02,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,22.02,21,0)
^^5^5^3030211^
"^DD",799.4,799.4,22.02,21,1,0)
This field is used to indicate the entity with 
"^DD",799.4,799.4,22.02,21,2,0)
responsiblity for informing the patient's sexual
"^DD",799.4,799.4,22.02,21,3,0)
partners of the patient's HIV infection. The data
"^DD",799.4,799.4,22.02,21,4,0)
in this field will be used in the CDC HIV/AIDS 
"^DD",799.4,799.4,22.02,21,5,0)
form.
"^DD",799.4,799.4,22.02,"DT")
2940628
"^DD",799.4,799.4,22.03,0)
HIV RELATED MED SERVICES^S^1:YES;0:NO;9:UNKNOWN;^22;3^Q
"^DD",799.4,799.4,22.03,3)
Indicate if this patient is receiving or has been referred for HIV related medical services.
"^DD",799.4,799.4,22.03,20,0)
^.3LA^1^1
"^DD",799.4,799.4,22.03,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,22.03,21,0)
^^5^5^3030211^
"^DD",799.4,799.4,22.03,21,1,0)
This field is used to hold the response related 
"^DD",799.4,799.4,22.03,21,2,0)
to whether the patient is receiving or has been
"^DD",799.4,799.4,22.03,21,3,0)
referred to recieve HIV related medical services.
"^DD",799.4,799.4,22.03,21,4,0)
This information is used in preparing the CDC 
"^DD",799.4,799.4,22.03,21,5,0)
HIV/AIDS form.
"^DD",799.4,799.4,22.03,"DT")
2950710
"^DD",799.4,799.4,22.04,0)
RCVD ANTI-RETROVIRAL THERAPY^S^1:YES;0:NO;9:UNKNOWN;^22;4^Q
"^DD",799.4,799.4,22.04,.1)
RECIEVING OR RECIEVED ANTI-RETROVIRAL THERAPY
"^DD",799.4,799.4,22.04,3)
The response should indicate whether the patient has received or is receiving anti-retroviral therapy.
"^DD",799.4,799.4,22.04,20,0)
^.3LA^1^1
"^DD",799.4,799.4,22.04,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,22.04,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,22.04,21,1,0)
The response should indicate whether the patient 
"^DD",799.4,799.4,22.04,21,2,0)
has received or is receiving anti-retroviral
"^DD",799.4,799.4,22.04,21,3,0)
therapy. The data is used in generating the CDC
"^DD",799.4,799.4,22.04,21,4,0)
HIV/AIDS form.
"^DD",799.4,799.4,22.04,"DT")
2940628
"^DD",799.4,799.4,22.05,0)
RECEIVED PCP PROPHYLAXIS^S^1:YES;0:NO;9:UNKNOWN;^22;5^Q
"^DD",799.4,799.4,22.05,.1)
Received or receiving PCP Prophylaxis
"^DD",799.4,799.4,22.05,3)
The response should indicate whether the patient has received or is receiving PCP prophylaxis.
"^DD",799.4,799.4,22.05,20,0)
^.3LA^1^1
"^DD",799.4,799.4,22.05,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,22.05,21,0)
^^3^3^3030211^
"^DD",799.4,799.4,22.05,21,1,0)
The response should indicate whether the patient 
"^DD",799.4,799.4,22.05,21,2,0)
has received or is receiving PCP prophylaxis. The
"^DD",799.4,799.4,22.05,21,3,0)
data is used in generating the CDC HIV/AIDS form.
"^DD",799.4,799.4,22.05,"DT")
2940628
"^DD",799.4,799.4,22.06,0)
ENROLLED AT CLINCAL TRIAL^S^1:NIH SPONSORED;2:OTHER;3:NONE;9:UNKNOWN;^22;6^Q
"^DD",799.4,799.4,22.06,3)
This field is used to indicate whether the patient is enrolled in a clincal trial, and which category of clinical trial.
"^DD",799.4,799.4,22.06,20,0)
^.3LA^1^1
"^DD",799.4,799.4,22.06,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,22.06,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,22.06,21,1,0)
This field is used to indicate whether the patient
"^DD",799.4,799.4,22.06,21,2,0)
is enrolled in a clincal trial, and which category
"^DD",799.4,799.4,22.06,21,3,0)
of clinical trial. The data in this field is used
"^DD",799.4,799.4,22.06,21,4,0)
in generating the CDC HIV/AIDS form.
"^DD",799.4,799.4,22.06,"DT")
2940628
"^DD",799.4,799.4,22.07,0)
ENROLLED AT CLINIC^S^1:HRSA SPONSORED;2:OTHER;3:NONE;9:UNKNOWN;^22;7^Q
"^DD",799.4,799.4,22.07,3)
This field is used to indicate whether the patient is enrolled in a clinc, and which category of clinic.
"^DD",799.4,799.4,22.07,20,0)
^.3LA^1^1
"^DD",799.4,799.4,22.07,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,22.07,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,22.07,21,1,0)
This field is used to indicate whether the patient
"^DD",799.4,799.4,22.07,21,2,0)
is enrolled in a clinc, and which category of
"^DD",799.4,799.4,22.07,21,3,0)
clinic. The data in this field is used in
"^DD",799.4,799.4,22.07,21,4,0)
generating the CDC HIV/AIDS form.
"^DD",799.4,799.4,22.07,"DT")
2940628
"^DD",799.4,799.4,22.08,0)
PRIMARY REIMBURSER FOR MED RX^S^1:MEDICAID;2:PRIMARY INS/HMO;3:NO COVERAGE;4:OTHER PUBLIC FUNDS;7:CLINICAL TRIAL/GOVMNT PROGRAM;9:UNKNOWN;^22;8^Q
"^DD",799.4,799.4,22.08,.1)
Medical treatment PRIMARILY reimbursed by
"^DD",799.4,799.4,22.08,3)
This field is used to indicate who was the PRIMARY reimburser for this patient's medical treatment.
"^DD",799.4,799.4,22.08,20,0)
^.3LA^1^1
"^DD",799.4,799.4,22.08,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,22.08,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,22.08,21,1,0)
This field is used to indicate who was the PRIMARY
"^DD",799.4,799.4,22.08,21,2,0)
reimburser for this patient's medical treatment.
"^DD",799.4,799.4,22.08,21,3,0)
The entry is used in the generation of the CDC
"^DD",799.4,799.4,22.08,21,4,0)
HIV/AIDS form.
"^DD",799.4,799.4,22.08,"DT")
2940628
"^DD",799.4,799.4,23.01,0)
GYNECOLOGY OR OBSTETRIC CARE^S^1:YES;0:NO;9:UNKNOWN;^23;1^Q
"^DD",799.4,799.4,23.01,.1)
Patient receiving obstetric or gynecological care
"^DD",799.4,799.4,23.01,3)
For FEMALE patients only - Is the patient receiving obstetric or gynecological care?
"^DD",799.4,799.4,23.01,20,0)
^.3LA^1^1
"^DD",799.4,799.4,23.01,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,23.01,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,23.01,21,1,0)
This field is applicable to female patients only.
"^DD",799.4,799.4,23.01,21,2,0)
Is the patient receiving obstetric or
"^DD",799.4,799.4,23.01,21,3,0)
gynecological care? The response is used in 
"^DD",799.4,799.4,23.01,21,4,0)
generating the CDC HIV/AIDS form.
"^DD",799.4,799.4,23.01,"DT")
3030211
"^DD",799.4,799.4,23.02,0)
CURRENTLY PREGNANT^S^1:YES;0:NO;9:UNKNOWN;^23;2^Q
"^DD",799.4,799.4,23.02,3)
For FEMALE patients only - Is the patient currently pregnant?
"^DD",799.4,799.4,23.02,20,0)
^.3LA^1^1
"^DD",799.4,799.4,23.02,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,23.02,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,23.02,21,1,0)
This field is applicable to female patients only. 
"^DD",799.4,799.4,23.02,21,2,0)
The field is used to indicate whether the female
"^DD",799.4,799.4,23.02,21,3,0)
patient is pregnant at the time the CDC HIV/AIDS
"^DD",799.4,799.4,23.02,21,4,0)
form is generated.
"^DD",799.4,799.4,23.02,"DT")
3030211
"^DD",799.4,799.4,23.03,0)
DELIVERED LIVE BORN INFANT^S^1:YES;0:NO;3:UNKNOWN;^23;3^Q
"^DD",799.4,799.4,23.03,3)
For FEMALE patients only - Has the female patient ever delivered a live born infant?
"^DD",799.4,799.4,23.03,20,0)
^.3LA^1^1
"^DD",799.4,799.4,23.03,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,23.03,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,23.03,21,1,0)
This field is applicable to FEMALES ONLY. Has the 
"^DD",799.4,799.4,23.03,21,2,0)
female patient ever delivered a live born infant?
"^DD",799.4,799.4,23.03,21,3,0)
The response is used to generate the CDC HIV/AIDS
"^DD",799.4,799.4,23.03,21,4,0)
form.
"^DD",799.4,799.4,23.03,"DT")
3030211
"^DD",799.4,799.4,23.04,0)
CHILD'S DATE OF BIRTH^D^^23;4^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.4,23.04,3)
Enter the date of birth of the last child born to a woman patient if the birthdate is past 1977.
"^DD",799.4,799.4,23.04,20,0)
^.3LA^1^1
"^DD",799.4,799.4,23.04,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,23.04,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,23.04,21,1,0)
This field is used to indicate the date of birth 
"^DD",799.4,799.4,23.04,21,2,0)
of a child to a woman who has been diagnosed with
"^DD",799.4,799.4,23.04,21,3,0)
HIV or AIDS. This information is used to generate
"^DD",799.4,799.4,23.04,21,4,0)
the CDC HIV/AIDS form.
"^DD",799.4,799.4,23.04,"DT")
2941026
"^DD",799.4,799.4,23.05,0)
CHILD'S HOSPITAL OF BIRTH^F^^23;5^K:$L(X)>23!($L(X)<2) X
"^DD",799.4,799.4,23.05,3)
Enter the name of the hospital (2 to 23 characters) in which the last child born, if this patient is a woman, and the date of birth is past 1977.
"^DD",799.4,799.4,23.05,20,0)
^.3LA^1^1
"^DD",799.4,799.4,23.05,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,23.05,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,23.05,21,1,0)
This field is used to indicate the birth hospital 
"^DD",799.4,799.4,23.05,21,2,0)
for the most recent child of a woman who has been
"^DD",799.4,799.4,23.05,21,3,0)
diagnosed with HIV or AIDS. This information is
"^DD",799.4,799.4,23.05,21,4,0)
used to generate the CDC HIV/AIDS form.
"^DD",799.4,799.4,23.05,"DT")
2941026
"^DD",799.4,799.4,23.06,0)
CHILD'S HOSPITAL - CITY^F^^23;6^K:$L(X)>23!($L(X)<2) X
"^DD",799.4,799.4,23.06,3)
Enter the name of the city (2-23 characters) in which the CHILD'S HOSPITAL of birth is located.
"^DD",799.4,799.4,23.06,20,0)
^.3LA^1^1
"^DD",799.4,799.4,23.06,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,23.06,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,23.06,21,1,0)
This field is used to hold the city of the birth 
"^DD",799.4,799.4,23.06,21,2,0)
hospital of the most recent child of a woman
"^DD",799.4,799.4,23.06,21,3,0)
diagnosed with HIV or AIDS. This information is
"^DD",799.4,799.4,23.06,21,4,0)
used to generate the CDC HIV/AIDS form.
"^DD",799.4,799.4,23.06,"DT")
2941026
"^DD",799.4,799.4,23.07,0)
CHILD'S HOSPITAL - STATE^F^^23;7^K:$L(X)>2!($L(X)<2)!'(X?2U) X
"^DD",799.4,799.4,23.07,3)
Enter the 2 letter abbreviation for the state in which the CHILD'S HOSPITAL OF BIRTH is located.
"^DD",799.4,799.4,23.07,20,0)
^.3LA^1^1
"^DD",799.4,799.4,23.07,20,1,0)
CDC FORM (IX)
"^DD",799.4,799.4,23.07,21,0)
^^4^4^3030211^
"^DD",799.4,799.4,23.07,21,1,0)
This field is used to hold the state of the birth 
"^DD",799.4,799.4,23.07,21,2,0)
hospital of the most recent child of a woman
"^DD",799.4,799.4,23.07,21,3,0)
diagnosed with HIV or AIDS. This information is
"^DD",799.4,799.4,23.07,21,4,0)
used to generate the CDC HIV/AIDS form.
"^DD",799.4,799.4,23.07,"DT")
2941026
"^DD",799.4,799.4,25,0)
CDC COMMENTS^799.425^^25;0
"^DD",799.4,799.4,25,20,0)
^.3LA^1^1
"^DD",799.4,799.4,25,20,1,0)
CDC FORM (X)
"^DD",799.4,799.41,0)
AIDS INDICATOR DISEASE SUB-FIELD^^.03^3
"^DD",799.4,799.41,0,"DT")
3030207
"^DD",799.4,799.41,0,"IX","B",799.41,.01)

"^DD",799.4,799.41,0,"NM","AIDS INDICATOR DISEASE")

"^DD",799.4,799.41,0,"UP")
799.4
"^DD",799.4,799.41,.01,0)
AIDS INDICATOR DISEASE^M*P799.49'X^ROR(799.49,^0;1^S DIC("S")="I $P($G(^(0)),U,3)" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X S:$D(X) DINUM=X
"^DD",799.4,799.41,.01,1,0)
^.1
"^DD",799.4,799.41,.01,1,1,0)
799.41^B
"^DD",799.4,799.41,.01,1,1,1)
S ^RORDATA(799.4,DA(1),10,"B",$E(X,1,30),DA)=""
"^DD",799.4,799.41,.01,1,1,2)
K ^RORDATA(799.4,DA(1),10,"B",$E(X,1,30),DA)
"^DD",799.4,799.41,.01,12)
Only active indicator diseases can be selected.
"^DD",799.4,799.41,.01,12.1)
S DIC("S")="I $P($G(^(0)),U,3)"
"^DD",799.4,799.41,.01,20,0)
^.3LA^1^1
"^DD",799.4,799.41,.01,20,1,0)
CDC FORM (VIII)
"^DD",799.4,799.41,.01,21,0)
^.001^2^2^3030507^^^
"^DD",799.4,799.41,.01,21,1,0)
The AIDS INDICATOR DISEASE field references the 
"^DD",799.4,799.41,.01,21,2,0)
AIDS indicator disease.
"^DD",799.4,799.41,.01,23,0)
^^6^6^3030507^
"^DD",799.4,799.41,.01,23,1,0)
Only diseases that have values in the SEQUENTIAL NUMBER
"^DD",799.4,799.41,.01,23,2,0)
field can be selected from the ROR AIDS INDICATOR
"^DD",799.4,799.41,.01,23,3,0)
DISEASE file.
"^DD",799.4,799.41,.01,23,4,0)
 
"^DD",799.4,799.41,.01,23,5,0)
Internal value of this field is used as the internal 
"^DD",799.4,799.41,.01,23,6,0)
entry number of the record (the 'DINUM' feature).
"^DD",799.4,799.41,.01,"DT")
3030207
"^DD",799.4,799.41,.02,0)
INITIAL DIAGNOSIS^*S^1:Definitive;2:Presumptive;^0;2^Q
"^DD",799.4,799.41,.02,3)

"^DD",799.4,799.41,.02,12)
Each indicator disease have its own set of initial diagnoses.
"^DD",799.4,799.41,.02,12.1)
S DIC("S")="N RORV S RORV=+$G(^RORDATA(799.4,DA(1),10,DA,0)) I RORV>0 S RORV=$P($G(^ROR(799.49,RORV,0)),U,2) I ("";""_RORV)[("";""_Y_"":"")"
"^DD",799.4,799.41,.02,20,0)
^.3LA^1^1
"^DD",799.4,799.41,.02,20,1,0)
CDC FORM (VIII)
"^DD",799.4,799.41,.02,21,0)
^^2^2^3030507^
"^DD",799.4,799.41,.02,21,1,0)
The INITIAL DIAGNOSIS field stores a diagnosis for
"^DD",799.4,799.41,.02,21,2,0)
the disease. 
"^DD",799.4,799.41,.02,23,0)
^^5^5^3030507^
"^DD",799.4,799.41,.02,23,1,0)
The set of codes is screened according to the value of
"^DD",799.4,799.41,.02,23,2,0)
the INITIAL DIAGNOSIS VALUES field (.02) from the
"^DD",799.4,799.41,.02,23,3,0)
record of the ROR AIDS INDICATOR DISEASE file
"^DD",799.4,799.41,.02,23,4,0)
(#799.49) that is referenced by the AIDS INDICATOR 
"^DD",799.4,799.41,.02,23,5,0)
DISEASE field (.01) of this multiple.
"^DD",799.4,799.41,.02,"DT")
3030206
"^DD",799.4,799.41,.03,0)
DATE^D^^0;3^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",799.4,799.41,.03,20,0)
^.3LA^1^1
"^DD",799.4,799.41,.03,20,1,0)
CDC FORM (VIII)
"^DD",799.4,799.41,.03,21,0)
^^2^2^3030507^
"^DD",799.4,799.41,.03,21,1,0)
The DATE field stores the date when the disease 
"^DD",799.4,799.41,.03,21,2,0)
was diagnosed.
"^DD",799.4,799.41,.03,"DT")
3030206
"^DD",799.4,799.425,0)
CDC COMMENTS SUB-FIELD^^.01^1
"^DD",799.4,799.425,0,"DT")
3030211
"^DD",799.4,799.425,0,"NM","CDC COMMENTS")

"^DD",799.4,799.425,0,"UP")
799.4
"^DD",799.4,799.425,.01,0)
CDC COMMENTS^WL^^0;1^Q
"^DD",799.4,799.425,.01,21,0)
^^2^2^3030507^
"^DD",799.4,799.425,.01,21,1,0)
The CDC COMMENTS field stores 3 lines of text that
"^DD",799.4,799.425,.01,21,2,0)
is printed in the section X of the CDC form.
"^DD",799.4,799.425,.01,"DT")
3030211
"^DD",799.49,799.49,0)
FIELD^^2^5
"^DD",799.49,799.49,0,"DDA")
N
"^DD",799.49,799.49,0,"DT")
3030507
"^DD",799.49,799.49,0,"ID","WRITE")
D EN^DDIOL($J(Y,3),"","?40")
"^DD",799.49,799.49,0,"IX","AS",799.49,.03)

"^DD",799.49,799.49,0,"IX","B",799.49,.01)

"^DD",799.49,799.49,0,"NM","ROR AIDS INDICATOR DISEASE")

"^DD",799.49,799.49,0,"PT",799.41,.01)

"^DD",799.49,799.49,0,"VRPK")
ROR
"^DD",799.49,799.49,.01,0)
DISEASE NAME^RFX^^0;1^Q:$$VAEDT^RORDD(799.49,,-1)  K:$L(X)>30!($L(X)<3)!'(X'?1P.E) X
"^DD",799.49,799.49,.01,1,0)
^.1
"^DD",799.49,799.49,.01,1,1,0)
799.49^B
"^DD",799.49,799.49,.01,1,1,1)
S ^ROR(799.49,"B",$E(X,1,30),DA)=""
"^DD",799.49,799.49,.01,1,1,2)
K ^ROR(799.49,"B",$E(X,1,30),DA)
"^DD",799.49,799.49,.01,1,1,3)
Do not delete!
"^DD",799.49,799.49,.01,3)
Answer must be 3-30 characters in length.
"^DD",799.49,799.49,.01,8.5)
@
"^DD",799.49,799.49,.01,9)
@
"^DD",799.49,799.49,.01,21,0)
^^2^2^3030506^
"^DD",799.49,799.49,.01,21,1,0)
The DISEASE NAME field stores a short name of the
"^DD",799.49,799.49,.01,21,2,0)
disease. 
"^DD",799.49,799.49,.01,23,0)
^^4^4^3030506^
"^DD",799.49,799.49,.01,23,1,0)
Usually, the name is the same as that of the
"^DD",799.49,799.49,.01,23,2,0)
corresponding field of the IMMUNOLOGY CASE STUDY file
"^DD",799.49,799.49,.01,23,3,0)
(#158) that was used by the Immunology Case Registry
"^DD",799.49,799.49,.01,23,4,0)
v2.1 software.
"^DD",799.49,799.49,.01,"DEL",1,0)
I $$VADEL^RORDD(799.49,,-1)
"^DD",799.49,799.49,.01,"DT")
3030206
"^DD",799.49,799.49,.02,0)
INITIAL DIAGNOSIS VALUES^RFX^^0;2^Q:$$VAEDT^RORDD(799.49,,-1)  K:$L(X)>30!($L(X)<1) X
"^DD",799.49,799.49,.02,3)
Answer must be 1-30 characters in length.
"^DD",799.49,799.49,.02,8.5)
@
"^DD",799.49,799.49,.02,9)
@
"^DD",799.49,799.49,.02,21,0)
^^13^13^3030507^
"^DD",799.49,799.49,.02,21,1,0)
The INITIAL DIAGNOSIS VALUES field contains a list
"^DD",799.49,799.49,.02,21,2,0)
of valid diagnoses for this particular disease (as
"^DD",799.49,799.49,.02,21,3,0)
they are defined in the CDC form) separated by
"^DD",799.49,799.49,.02,21,4,0)
semicolons. Each initial diagnosis should consist
"^DD",799.49,799.49,.02,21,5,0)
of internal and external values separated by
"^DD",799.49,799.49,.02,21,6,0)
colon.
"^DD",799.49,799.49,.02,21,7,0)
 
"^DD",799.49,799.49,.02,21,8,0)
For example: '1:Definitive;2:Presumptive'.
"^DD",799.49,799.49,.02,21,9,0)
 
"^DD",799.49,799.49,.02,21,10,0)
The full set of possible diagnoses should be also
"^DD",799.49,799.49,.02,21,11,0)
defined for the INITIAL DIAGNOSIS field of the
"^DD",799.49,799.49,.02,21,12,0)
AIDS INDICATOR DISEASE multiple of the ROR ICR
"^DD",799.49,799.49,.02,21,13,0)
STUDY file.
"^DD",799.49,799.49,.02,23,0)
^.001^4^4^3030507^^^
"^DD",799.49,799.49,.02,23,1,0)
The value of this field is used by the input transform 
"^DD",799.49,799.49,.02,23,2,0)
of the INITIAL DIAGNOSIS field (.02) of the AIDS 
"^DD",799.49,799.49,.02,23,3,0)
INDICATOR DISEASE multiple (10) of the ROR ICR STUDY 
"^DD",799.49,799.49,.02,23,4,0)
file (#799.4).
"^DD",799.49,799.49,.02,"DT")
3030206
"^DD",799.49,799.49,.03,0)
SEQUENTIAL NUMBER^NJ2,0X^^0;3^Q:$$VAEDT^RORDD(799.49,,-1)  K:+X'=X!(X>99)!(X<1)!(X?.E1"."1N.N) X
"^DD",799.49,799.49,.03,1,0)
^.1
"^DD",799.49,799.49,.03,1,1,0)
799.49^AS
"^DD",799.49,799.49,.03,1,1,1)
S ^ROR(799.49,"AS",$E(X,1,30),DA)=""
"^DD",799.49,799.49,.03,1,1,2)
K ^ROR(799.49,"AS",$E(X,1,30),DA)
"^DD",799.49,799.49,.03,1,1,3)
Do not delete!
"^DD",799.49,799.49,.03,1,1,"DT")
3030207
"^DD",799.49,799.49,.03,3)
Type a Number between 1 and 99, 0 Decimal Digits
"^DD",799.49,799.49,.03,8.5)
@
"^DD",799.49,799.49,.03,9)
@
"^DD",799.49,799.49,.03,21,0)
^.001^8^8^3030506^^
"^DD",799.49,799.49,.03,21,1,0)
The SEQUENTIAL NUMBER field stores a sequential 
"^DD",799.49,799.49,.03,21,2,0)
number of the indicator disease in the section 
"^DD",799.49,799.49,.03,21,3,0)
VIII of the CDC form (the first column from top to
"^DD",799.49,799.49,.03,21,4,0)
bottom and then the second column in the same 
"^DD",799.49,799.49,.03,21,5,0)
way).
"^DD",799.49,799.49,.03,21,6,0)
 
"^DD",799.49,799.49,.03,21,7,0)
If this field has no value then the record is 
"^DD",799.49,799.49,.03,21,8,0)
considered inactive.
"^DD",799.49,799.49,.03,"DEL",1,0)
I $$VADEL^RORDD(799.49,,-1)
"^DD",799.49,799.49,.03,"DT")
3030207
"^DD",799.49,799.49,1.01,0)
DESCRIPTION^RFX^^1;1^Q:$$VAEDT^RORDD(799.49,,-1)  K:$L(X)>100!($L(X)<1) X
"^DD",799.49,799.49,1.01,3)
Answer must be 1-100 characters in length.
"^DD",799.49,799.49,1.01,8.5)
@
"^DD",799.49,799.49,1.01,9)
@
"^DD",799.49,799.49,1.01,21,0)
^^3^3^3030507^
"^DD",799.49,799.49,1.01,21,1,0)
The DESCRIPTION field stores the text associated
"^DD",799.49,799.49,1.01,21,2,0)
with the AIDS indicator disease in the section
"^DD",799.49,799.49,1.01,21,3,0)
VIII of the CDC form.
"^DD",799.49,799.49,1.01,23,0)
^.001^1^1^3030507^^^^
"^DD",799.49,799.49,1.01,23,1,0)
This field is not currently used by the software.
"^DD",799.49,799.49,1.01,"DT")
3030507
"^DD",799.49,799.49,2,0)
METHOD DESCRIPTION^799.492^^2;0
"^DD",799.49,799.49,2,"DT")
3030507
"^DD",799.49,799.492,0)
METHOD DESCRIPTION SUB-FIELD^^.01^1
"^DD",799.49,799.492,0,"DT")
3030507
"^DD",799.49,799.492,0,"NM","METHOD DESCRIPTION")

"^DD",799.49,799.492,0,"UP")
799.49
"^DD",799.49,799.492,.01,0)
METHOD DESCRIPTION^WL^^0;1^Q
"^DD",799.49,799.492,.01,21,0)
^^3^3^3030507^
"^DD",799.49,799.492,.01,21,1,0)
The METHOD DESCRIPTION field stores descriptions
"^DD",799.49,799.492,.01,21,2,0)
of the methods that should be used to diagnose the
"^DD",799.49,799.492,.01,21,3,0)
disease.
"^DD",799.49,799.492,.01,"DT")
3030507
"^DD",799.51,799.51,0)
FIELD^^.09^5
"^DD",799.51,799.51,0,"DDA")
N
"^DD",799.51,799.51,0,"DT")
3040114
"^DD",799.51,799.51,0,"IX","AR",799.51,.02)

"^DD",799.51,799.51,0,"IX","B",799.51,.01)

"^DD",799.51,799.51,0,"NM","ROR GENERIC DRUG")

"^DD",799.51,799.51,.01,0)
NAME^RFX^^0;1^Q:$$VAEDT^RORDD(799.51,$G(DA))  K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E) X
"^DD",799.51,799.51,.01,1,0)
^.1
"^DD",799.51,799.51,.01,1,1,0)
799.51^B
"^DD",799.51,799.51,.01,1,1,1)
S ^ROR(799.51,"B",$E(X,1,30),DA)=""
"^DD",799.51,799.51,.01,1,1,2)
K ^ROR(799.51,"B",$E(X,1,30),DA)
"^DD",799.51,799.51,.01,1,1,3)
Do not delete!
"^DD",799.51,799.51,.01,3)
Name must be 3-30 characters, not numeric or starting with punctuation.
"^DD",799.51,799.51,.01,8.5)
@
"^DD",799.51,799.51,.01,9)
@
"^DD",799.51,799.51,.01,21,0)
^.001^4^4^3040124^^^
"^DD",799.51,799.51,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF 
"^DD",799.51,799.51,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",799.51,799.51,.01,21,3,0)
 
"^DD",799.51,799.51,.01,21,4,0)
The NAME field stores a short name of the drug.
"^DD",799.51,799.51,.01,"DEL",1,0)
I $$VADEL^RORDD(799.51,$G(DA))
"^DD",799.51,799.51,.02,0)
REGISTRY^RP798.1'X^ROR(798.1,^0;2^Q:$$VAEDT^RORDD(799.51,$G(DA))
"^DD",799.51,799.51,.02,1,0)
^.1
"^DD",799.51,799.51,.02,1,1,0)
799.51^AR
"^DD",799.51,799.51,.02,1,1,1)
S ^ROR(799.51,"AR",$E(X,1,30),DA)=""
"^DD",799.51,799.51,.02,1,1,2)
K ^ROR(799.51,"AR",$E(X,1,30),DA)
"^DD",799.51,799.51,.02,1,1,3)
Do not delete!
"^DD",799.51,799.51,.02,1,1,"%D",0)
^^2^2^3040124^
"^DD",799.51,799.51,.02,1,1,"%D",1,0)
This cross-reference groups all drugs associated
"^DD",799.51,799.51,.02,1,1,"%D",2,0)
with a particular registry together.
"^DD",799.51,799.51,.02,1,1,"DT")
3030818
"^DD",799.51,799.51,.02,8.5)
@
"^DD",799.51,799.51,.02,9)
@
"^DD",799.51,799.51,.02,21,0)
^^5^5^3040124^
"^DD",799.51,799.51,.02,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF 
"^DD",799.51,799.51,.02,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",799.51,799.51,.02,21,3,0)
 
"^DD",799.51,799.51,.02,21,4,0)
This field identifies the registry that the drug 
"^DD",799.51,799.51,.02,21,5,0)
is associated with.
"^DD",799.51,799.51,.02,"DT")
3040114
"^DD",799.51,799.51,.03,0)
DRUG GROUP^R*P799.1'X^ROR(799.1,^0;3^Q:$$VAEDT^RORDD(799.51,$G(DA))  S Y=$P($G(^ROR(799.51,DA,0)),U,2),DIC("S")="S D=$G(^(0)) I $P(D,U,2)=4"_$S(Y>0:",$P(D,U,3)="_Y,1:"") D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",799.51,799.51,.03,3)

"^DD",799.51,799.51,.03,8.5)
@
"^DD",799.51,799.51,.03,9)
@
"^DD",799.51,799.51,.03,12)
Only Drug Groups can be selected.
"^DD",799.51,799.51,.03,12.1)
S DIC("S")="S D=$G(^(0)) I $P(D,U,2)=4"_$S(Y>0:",$P(D,U,3)="_Y,1:"")
"^DD",799.51,799.51,.03,21,0)
^^2^2^3040124^
"^DD",799.51,799.51,.03,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF 
"^DD",799.51,799.51,.03,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",799.51,799.51,.03,23,0)
^^2^2^3040124^
"^DD",799.51,799.51,.03,23,1,0)
This field is not used currently. It is reserved for 
"^DD",799.51,799.51,.03,23,2,0)
future use.
"^DD",799.51,799.51,.03,"DT")
3040124
"^DD",799.51,799.51,.04,0)
VA GENERIC^RP50.6'X^PSNDF(50.6,^0;4^Q:$$VAEDT^RORDD(799.51,$G(DA))
"^DD",799.51,799.51,.04,8.5)
@
"^DD",799.51,799.51,.04,9)
@
"^DD",799.51,799.51,.04,21,0)
^^2^2^3040124^
"^DD",799.51,799.51,.04,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF 
"^DD",799.51,799.51,.04,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",799.51,799.51,.04,"DT")
3040114
"^DD",799.51,799.51,.09,0)
NATIONAL^SX^0:NO;1:YES;^0;9^Q:$$VAEDT^RORDD(799.51,,-1)
"^DD",799.51,799.51,.09,8.5)
@
"^DD",799.51,799.51,.09,9)
@
"^DD",799.51,799.51,.09,21,0)
^^6^6^3040124^
"^DD",799.51,799.51,.09,21,1,0)
ONLY AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN
"^DD",799.51,799.51,.09,21,2,0)
EDIT THIS FIELD!
"^DD",799.51,799.51,.09,21,3,0)
 
"^DD",799.51,799.51,.09,21,4,0)
Drugs associated with the national registries must
"^DD",799.51,799.51,.09,21,5,0)
have this field set to "Yes". This prevents local
"^DD",799.51,799.51,.09,21,6,0)
editing of other fields of the record.
"^DD",799.51,799.51,.09,"DEL",1,0)
I $$VADEL^RORDD(799.51,,-1)
"^DD",799.51,799.51,.09,"DT")
3030818
"^DIC",798,798,0)
ROR LOCAL REGISTRY^798
"^DIC",798,798,0,"GL")
^RORDATA(798,
"^DIC",798,798,"%",0)
^1.005^^0
"^DIC",798,798,"%D",0)
^^32^32^3030428^
"^DIC",798,798,"%D",1,0)
The ROR LOCAL REGISTRY file contains records of
"^DIC",798,798,"%D",2,0)
local registries. Each record associates a patient
"^DIC",798,798,"%D",3,0)
with a registry and contains registry specific and
"^DIC",798,798,"%D",4,0)
additional service information (when the patient 
"^DIC",798,798,"%D",5,0)
has been added to the registry, if the patient
"^DIC",798,798,"%D",6,0)
record is active or not, etc).
"^DIC",798,798,"%D",7,0)
 
"^DIC",798,798,"%D",8,0)
Records of the file are uniquely identified by 
"^DIC",798,798,"%D",9,0)
the patient and the registry (the "A" primary key
"^DIC",798,798,"%D",10,0)
and the uniqueness index "KEY" are used for that
"^DIC",798,798,"%D",11,0)
purpose).
"^DIC",798,798,"%D",12,0)
 
"^DIC",798,798,"%D",13,0)
When the record of this file is deleted, the logic
"^DIC",798,798,"%D",14,0)
of the ADELETE cross-reference tries to delete the
"^DIC",798,798,"%D",15,0)
associated records from the ROR ICR STUDY
"^DIC",798,798,"%D",16,0)
(#799.4), ROR PATIENT (#798.4), and ROR PENDING 
"^DIC",798,798,"%D",17,0)
PATIENT (#798.3) files.
"^DIC",798,798,"%D",18,0)
 
"^DIC",798,798,"%D",19,0)
A permanent screen (the ^DD(798,0,"SCR") node) 
"^DIC",798,798,"%D",20,0)
restricts access to records of this file. Users
"^DIC",798,798,"%D",21,0)
can access records of only those registries that
"^DIC",798,798,"%D",22,0)
they have the security key(s) for. Users with the
"^DIC",798,798,"%D",23,0)
ROR VA IRM security key can access all records of
"^DIC",798,798,"%D",24,0)
the file.
"^DIC",798,798,"%D",25,0)
 
"^DIC",798,798,"%D",26,0)
If you want the changes in the security keys
"^DIC",798,798,"%D",27,0)
allocation to have an effect immediately, you 
"^DIC",798,798,"%D",28,0)
should rebuild the "ACL" cross-reference of the
"^DIC",798,798,"%D",29,0)
.01 field of the SECURITY KEY multiple of the ROR
"^DIC",798,798,"%D",30,0)
REGISTRY PARAMETERS file (#798.1). See the
"^DIC",798,798,"%D",31,0)
description of the cross-reference for more
"^DIC",798,798,"%D",32,0)
details.
"^DIC",798,"B","ROR LOCAL REGISTRY",798)

"^DIC",798.1,798.1,0)
ROR REGISTRY PARAMETERS^798.1
"^DIC",798.1,798.1,0,"GL")
^ROR(798.1,
"^DIC",798.1,798.1,"%",0)
^1.005^^0
"^DIC",798.1,798.1,"%D",0)
^^22^22^3021223^
"^DIC",798.1,798.1,"%D",1,0)
Records of the ROR REGISTRY PARAMETERS file 
"^DIC",798.1,798.1,"%D",2,0)
contain various registry parameters and the data
"^DIC",798.1,798.1,"%D",3,0)
that indicates current registry state. Every 
"^DIC",798.1,798.1,"%D",4,0)
registry must have a record in this file.
"^DIC",798.1,798.1,"%D",5,0)
 
"^DIC",798.1,798.1,"%D",6,0)
Records of the file are uniquely identified by the
"^DIC",798.1,798.1,"%D",7,0)
registry name (the "A" primary key and the
"^DIC",798.1,798.1,"%D",8,0)
uniqueness index "B" are used for that purpose).
"^DIC",798.1,798.1,"%D",9,0)
 
"^DIC",798.1,798.1,"%D",10,0)
A permanent screen (the ^DD(798.1,0,"SCR") node) 
"^DIC",798.1,798.1,"%D",11,0)
restricts access to records of this file. Users
"^DIC",798.1,798.1,"%D",12,0)
can access records of only those registries that
"^DIC",798.1,798.1,"%D",13,0)
they have the security key(s) for. Users with the
"^DIC",798.1,798.1,"%D",14,0)
ROR VA IRM security key can access all records of
"^DIC",798.1,798.1,"%D",15,0)
the file.
"^DIC",798.1,798.1,"%D",16,0)
 
"^DIC",798.1,798.1,"%D",17,0)
If you want the changes in the security keys 
"^DIC",798.1,798.1,"%D",18,0)
allocation to have an effect immediately, you
"^DIC",798.1,798.1,"%D",19,0)
should rebuild the "ACL" cross-reference of the
"^DIC",798.1,798.1,"%D",20,0)
.01 field of the SECURITY KEY multiple of this
"^DIC",798.1,798.1,"%D",21,0)
file. See the description of the cross-reference
"^DIC",798.1,798.1,"%D",22,0)
for more details.
"^DIC",798.1,"B","ROR REGISTRY PARAMETERS",798.1)

"^DIC",798.2,798.2,0)
ROR SELECTION RULE^798.2
"^DIC",798.2,798.2,0,"GL")
^ROR(798.2,
"^DIC",798.2,798.2,"%",0)
^1.005^^0
"^DIC",798.2,798.2,"%D",0)
^^30^30^3020403^
"^DIC",798.2,798.2,"%D",1,0)
The ROR SELECTION RULES file contains definitions
"^DIC",798.2,798.2,"%D",2,0)
of the selection rules that are used to screen
"^DIC",798.2,798.2,"%D",3,0)
patients for addition to the registries. There are
"^DIC",798.2,798.2,"%D",4,0)
two kinds of rules: top-level and lower level.
"^DIC",798.2,798.2,"%D",5,0)
 
"^DIC",798.2,798.2,"%D",6,0)
If a rule is referenced by the ROR REGISTRY 
"^DIC",798.2,798.2,"%D",7,0)
PARAMETERS file, it is the top-level rule.
"^DIC",798.2,798.2,"%D",8,0)
Non-zero value of any top-level rule expression 
"^DIC",798.2,798.2,"%D",9,0)
directly determines that the patient should be
"^DIC",798.2,798.2,"%D",10,0)
added to the corresponding registry.
"^DIC",798.2,798.2,"%D",11,0)
 
"^DIC",798.2,798.2,"%D",12,0)
Lower level rules are referenced only by other 
"^DIC",798.2,798.2,"%D",13,0)
rules (by rule macros in the expressions). Their
"^DIC",798.2,798.2,"%D",14,0)
expressions are evaluated in the proper order, and
"^DIC",798.2,798.2,"%D",15,0)
the result values are used in the expressions of 
"^DIC",798.2,798.2,"%D",16,0)
other rules. Lower level rules have an indirect
"^DIC",798.2,798.2,"%D",17,0)
impact on the final result and can be used for
"^DIC",798.2,798.2,"%D",18,0)
complex processing of linked files and multiples.
"^DIC",798.2,798.2,"%D",19,0)
 
"^DIC",798.2,798.2,"%D",20,0)
For example, a lower level rule can calculate 
"^DIC",798.2,798.2,"%D",21,0)
maximum and minimum values of a parameter in the
"^DIC",798.2,798.2,"%D",22,0)
sub-file, and a top-level rule will analyze these
"^DIC",798.2,798.2,"%D",23,0)
values and decide if the patient should be added 
"^DIC",798.2,798.2,"%D",24,0)
to the registry. Moreover, they could be used to
"^DIC",798.2,798.2,"%D",25,0)
split a very complex rule into several simpler
"^DIC",798.2,798.2,"%D",26,0)
rules.
"^DIC",798.2,798.2,"%D",27,0)
 
"^DIC",798.2,798.2,"%D",28,0)
Records of the file are uniquely identified by the
"^DIC",798.2,798.2,"%D",29,0)
rule name (the "A" primary key and the uniqueness
"^DIC",798.2,798.2,"%D",30,0)
index "B" are used for this purpose).
"^DIC",798.2,"B","ROR SELECTION RULE",798.2)

"^DIC",798.3,798.3,0)
ROR PENDING PATIENT^798.3
"^DIC",798.3,798.3,0,"GL")
^RORDATA(798.3,
"^DIC",798.3,798.3,"%",0)
^1.005^^0
"^DIC",798.3,798.3,"%D",0)
^1.001^13^13^3020801^^^^
"^DIC",798.3,798.3,"%D",1,0)
The ROR PENDING PATIENT file is used to store 
"^DIC",798.3,798.3,"%D",2,0)
references to those patients that were processed 
"^DIC",798.3,798.3,"%D",3,0)
with errors and were not added to the registry 
"^DIC",798.3,798.3,"%D",4,0)
(see the ERROR multiple).
"^DIC",798.3,798.3,"%D",5,0)
 
"^DIC",798.3,798.3,"%D",6,0)
Moreover, the data references generated by the 
"^DIC",798.3,798.3,"%D",7,0)
event protocols are stored in this file (see the 
"^DIC",798.3,798.3,"%D",8,0)
EVENT multiple). These references are used to 
"^DIC",798.3,798.3,"%D",9,0)
speed up the regular registry updates.
"^DIC",798.3,798.3,"%D",10,0)
 
"^DIC",798.3,798.3,"%D",11,0)
Records of the file have the same internal entry 
"^DIC",798.3,798.3,"%D",12,0)
numbers as the internal values of the PATIENT NAME
"^DIC",798.3,798.3,"%D",13,0)
field ('DINUM' feature).
"^DIC",798.3,"B","ROR PENDING PATIENT",798.3)

"^DIC",798.4,798.4,0)
ROR PATIENT^798.4
"^DIC",798.4,798.4,0,"GL")
^RORDATA(798.4,
"^DIC",798.4,798.4,"%",0)
^1.005^^0
"^DIC",798.4,798.4,"%D",0)
^^34^34^3021223^
"^DIC",798.4,798.4,"%D",1,0)
The ROR PATIENT file contains patient information
"^DIC",798.4,798.4,"%D",2,0)
that is common for all local registries (mostly,
"^DIC",798.4,798.4,"%D",3,0)
demographic information).
"^DIC",798.4,798.4,"%D",4,0)
 
"^DIC",798.4,798.4,"%D",5,0)
Most of the fields in the file have the same 
"^DIC",798.4,798.4,"%D",6,0)
numbers and names as the corresponding fields in
"^DIC",798.4,798.4,"%D",7,0)
the PATIENT file.
"^DIC",798.4,798.4,"%D",8,0)
 
"^DIC",798.4,798.4,"%D",9,0)
Demographic data from this file is compared to
"^DIC",798.4,798.4,"%D",10,0)
that from the PATIENT file (#2) to determine if it
"^DIC",798.4,798.4,"%D",11,0)
has been changed since the last registry data
"^DIC",798.4,798.4,"%D",12,0)
extraction. These fields are updated with the
"^DIC",798.4,798.4,"%D",13,0)
values from the PATIENT file and the UPDATE
"^DIC",798.4,798.4,"%D",14,0)
DEMOGRAPHICS flag is set to "Yes" in all active
"^DIC",798.4,798.4,"%D",15,0)
registry records of the patient.
"^DIC",798.4,798.4,"%D",16,0)
 
"^DIC",798.4,798.4,"%D",17,0)
Records in the file have the same internal entry 
"^DIC",798.4,798.4,"%D",18,0)
numbers as the patients' records in the PATIENT
"^DIC",798.4,798.4,"%D",19,0)
file. The records are uniquely identified by
"^DIC",798.4,798.4,"%D",20,0)
internal value of the PATIENT NAME field.
"^DIC",798.4,798.4,"%D",21,0)
 
"^DIC",798.4,798.4,"%D",22,0)
A permanent screen (the ^DD(798.4,0,"SCR") node) 
"^DIC",798.4,798.4,"%D",23,0)
restricts access to the records of this file. Only
"^DIC",798.4,798.4,"%D",24,0)
users with the security key(s) for any defined
"^DIC",798.4,798.4,"%D",25,0)
registry (or those with the ROR VA IRM security
"^DIC",798.4,798.4,"%D",26,0)
key) can access records of the file.
"^DIC",798.4,798.4,"%D",27,0)
 
"^DIC",798.4,798.4,"%D",28,0)
If you want the changes in the security keys
"^DIC",798.4,798.4,"%D",29,0)
allocation to have an effect immediately, you 
"^DIC",798.4,798.4,"%D",30,0)
should rebuild the "ACL" cross-reference of the
"^DIC",798.4,798.4,"%D",31,0)
.01 field of the SECURITY KEY multiple of the ROR
"^DIC",798.4,798.4,"%D",32,0)
REGISTRY PARAMETERS file (#798.1). See the
"^DIC",798.4,798.4,"%D",33,0)
description of the cross-reference for more
"^DIC",798.4,798.4,"%D",34,0)
details.
"^DIC",798.4,"B","ROR PATIENT",798.4)

"^DIC",798.5,798.5,0)
ROR HDT TASK^798.5
"^DIC",798.5,798.5,0,"GL")
^RORDATA(798.5,
"^DIC",798.5,798.5,"%",0)
^1.005^^0
"^DIC",798.5,798.5,"%D",0)
^^14^14^3020508^
"^DIC",798.5,798.5,"%D",1,0)
Several data extraction tasks can be defined to 
"^DIC",798.5,798.5,"%D",2,0)
speed up the historical data extraction process.  
"^DIC",798.5,798.5,"%D",3,0)
Records of this file contain task parameters and
"^DIC",798.5,798.5,"%D",4,0)
data indicating the current state of the tasks.
"^DIC",798.5,798.5,"%D",5,0)
                                 
"^DIC",798.5,798.5,"%D",6,0)
By default, the single task is defined for the 
"^DIC",798.5,798.5,"%D",7,0)
registry by the setup task.
"^DIC",798.5,798.5,"%D",8,0)
 
"^DIC",798.5,798.5,"%D",9,0)
Records of the file are uniquely identified by the
"^DIC",798.5,798.5,"%D",10,0)
registry (the REGISTRY field) and IEN of the local
"^DIC",798.5,798.5,"%D",11,0)
registry record that the historical data
"^DIC",798.5,798.5,"%D",12,0)
extraction starts from (the START RECORD IEN
"^DIC",798.5,798.5,"%D",13,0)
field). The "A" primary key and the "C" uniqueness
"^DIC",798.5,798.5,"%D",14,0)
index are used for this purpose.
"^DIC",798.5,"B","ROR HDT TASK",798.5)

"^DIC",798.7,798.7,0)
ROR LOG^798.7
"^DIC",798.7,798.7,0,"GL")
^RORDATA(798.7,
"^DIC",798.7,798.7,"%",0)
^1.005^^0
"^DIC",798.7,798.7,"%D",0)
^^22^22^3021223^
"^DIC",798.7,798.7,"%D",1,0)
The ROR LOG file is used for recording different
"^DIC",798.7,798.7,"%D",2,0)
kinds of events (errors, debug messages, etc.)
"^DIC",798.7,798.7,"%D",3,0)
that are generated by registry processes.
"^DIC",798.7,798.7,"%D",4,0)
 
"^DIC",798.7,798.7,"%D",5,0)
You may control event recording via parameters in
"^DIC",798.7,798.7,"%D",6,0)
the ROR REGISTRY PARAMETERS file. Look for
"^DIC",798.7,798.7,"%D",7,0)
additional information in the RORLOG and RORERR
"^DIC",798.7,798.7,"%D",8,0)
routines.
"^DIC",798.7,798.7,"%D",9,0)
 
"^DIC",798.7,798.7,"%D",10,0)
A permanent screen (the ^DD(798.7,0,"SCR") node) 
"^DIC",798.7,798.7,"%D",11,0)
restricts access to records of this file. Only
"^DIC",798.7,798.7,"%D",12,0)
users with the security key(s) for any defined 
"^DIC",798.7,798.7,"%D",13,0)
registry (or those with the ROR VA IRM security
"^DIC",798.7,798.7,"%D",14,0)
key) can access records of the file.
"^DIC",798.7,798.7,"%D",15,0)
 
"^DIC",798.7,798.7,"%D",16,0)
If you want the changes in the security keys 
"^DIC",798.7,798.7,"%D",17,0)
allocation to have an effect immediately, you
"^DIC",798.7,798.7,"%D",18,0)
should rebuild the "ACL" cross-reference of the
"^DIC",798.7,798.7,"%D",19,0)
.01 field of the SECURITY KEY multiple of the ROR
"^DIC",798.7,798.7,"%D",20,0)
REGISTRY PARAMETERS file (#798.1). See the 
"^DIC",798.7,798.7,"%D",21,0)
description of the cross-reference for more
"^DIC",798.7,798.7,"%D",22,0)
details.
"^DIC",798.7,"B","ROR LOG",798.7)

"^DIC",798.8,798.8,0)
ROR TASK^798.8
"^DIC",798.8,798.8,0,"GL")
^RORDATA(798.8,
"^DIC",798.8,798.8,"%",0)
^1.005^^0
"^DIC",798.8,798.8,"%D",0)
^^27^27^3030507^
"^DIC",798.8,798.8,"%D",1,0)
The ROR TASK file enhances the functionality of 
"^DIC",798.8,798.8,"%D",2,0)
Taskman and supports the package API's used by the
"^DIC",798.8,798.8,"%D",3,0)
GUI to schedule and control the tasks, and view
"^DIC",798.8,798.8,"%D",4,0)
and print the reports.
"^DIC",798.8,798.8,"%D",5,0)
 
"^DIC",798.8,798.8,"%D",6,0)
Records in the file have the same internal entry 
"^DIC",798.8,798.8,"%D",7,0)
numbers as the corresponding tasks in Taskman. The
"^DIC",798.8,798.8,"%D",8,0)
records are uniquely identified by the internal 
"^DIC",798.8,798.8,"%D",9,0)
value of the TASK NUMBER field.
"^DIC",798.8,798.8,"%D",10,0)
 
"^DIC",798.8,798.8,"%D",11,0)
Usually, you should not edit records of this file 
"^DIC",798.8,798.8,"%D",12,0)
directly. The file is maintained by the API's 
"^DIC",798.8,798.8,"%D",13,0)
located in the RORTSK* routines.
"^DIC",798.8,798.8,"%D",14,0)
 
"^DIC",798.8,798.8,"%D",15,0)
A permanent screen (the ^DD(798.8,0,"SCR") node) 
"^DIC",798.8,798.8,"%D",16,0)
restricts access to the records of this file. Only
"^DIC",798.8,798.8,"%D",17,0)
users with the security key(s) for any defined
"^DIC",798.8,798.8,"%D",18,0)
registry (or those with the ROR VA IRM security
"^DIC",798.8,798.8,"%D",19,0)
key) can access records of the file.
"^DIC",798.8,798.8,"%D",20,0)
     
"^DIC",798.8,798.8,"%D",21,0)
If you want the changes in the security keys 
"^DIC",798.8,798.8,"%D",22,0)
allocation to have an effect immediately, you
"^DIC",798.8,798.8,"%D",23,0)
should rebuild the "ACL" cross-reference of the
"^DIC",798.8,798.8,"%D",24,0)
.01 field of the SECURITY KEY multiple of the ROR
"^DIC",798.8,798.8,"%D",25,0)
REGISTRY PARAMETERS file (#798.1). See the
"^DIC",798.8,798.8,"%D",26,0)
description of the cross-reference for more
"^DIC",798.8,798.8,"%D",27,0)
details.
"^DIC",798.8,"B","ROR TASK",798.8)

"^DIC",798.9,798.9,0)
ROR LAB SEARCH^798.9
"^DIC",798.9,798.9,0,"GL")
^ROR(798.9,
"^DIC",798.9,798.9,"%",0)
^1.005^^0
"^DIC",798.9,798.9,"%D",0)
^^10^10^3020403^
"^DIC",798.9,798.9,"%D",1,0)
Lab search criteria are stored in this file. These
"^DIC",798.9,798.9,"%D",2,0)
criteria are referenced by the selection rules and
"^DIC",798.9,798.9,"%D",3,0)
used in the search for Lab results.
"^DIC",798.9,798.9,"%D",4,0)
 
"^DIC",798.9,798.9,"%D",5,0)
It is possible but not recommended to use the same
"^DIC",798.9,798.9,"%D",6,0)
criterion for several different registries.
"^DIC",798.9,798.9,"%D",7,0)
 
"^DIC",798.9,798.9,"%D",8,0)
Records of the file are uniquely identified by the
"^DIC",798.9,798.9,"%D",9,0)
criterion name. The "A" primary key and the "B"
"^DIC",798.9,798.9,"%D",10,0)
uniqueness index are used for this purpose.
"^DIC",798.9,"B","ROR LAB SEARCH",798.9)

"^DIC",799.1,799.1,0)
ROR LIST ITEM^799.1
"^DIC",799.1,799.1,0,"GL")
^ROR(799.1,
"^DIC",799.1,799.1,"%",0)
^1.005^^0
"^DIC",799.1,799.1,"%D",0)
^^22^22^3020403^
"^DIC",799.1,799.1,"%D",1,0)
THIS FILE MUST NOT BE MODIFIED LOCALLY! ONLY 
"^DIC",799.1,799.1,"%D",2,0)
AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN EDIT
"^DIC",799.1,799.1,"%D",3,0)
THIS FILE!
"^DIC",799.1,799.1,"%D",4,0)
 
"^DIC",799.1,799.1,"%D",5,0)
This file contains code sets used within different
"^DIC",799.1,799.1,"%D",6,0)
registries.
"^DIC",799.1,799.1,"%D",7,0)
 
"^DIC",799.1,799.1,"%D",8,0)
For example, the REASON FOR INACTIVATION field of
"^DIC",799.1,799.1,"%D",9,0)
the ROR LOCAL REGISTRY file may have different
"^DIC",799.1,799.1,"%D",10,0)
sets of possible values for different registries.
"^DIC",799.1,799.1,"%D",11,0)
All these values (for all registries) are stored
"^DIC",799.1,799.1,"%D",12,0)
in this file. The same is true for the SUPPORTING
"^DIC",799.1,799.1,"%D",13,0)
EVIDENCE field of the same file.
"^DIC",799.1,799.1,"%D",14,0)
 
"^DIC",799.1,799.1,"%D",15,0)
Records of the file are uniquely identified by the
"^DIC",799.1,799.1,"%D",16,0)
type (it associates the set of values with the 
"^DIC",799.1,799.1,"%D",17,0)
registry field), registry and item code. The "A"
"^DIC",799.1,799.1,"%D",18,0)
primary key and the "KEY" uniqueness index are
"^DIC",799.1,799.1,"%D",19,0)
used for this purpose.
"^DIC",799.1,799.1,"%D",20,0)
 
"^DIC",799.1,799.1,"%D",21,0)
DO NOT DELETE RECORDS FROM THIS FILE IF THEY HAVE 
"^DIC",799.1,799.1,"%D",22,0)
BEEN DISTRIBUTED TO THE SITES ALREADY!
"^DIC",799.1,"B","ROR LIST ITEM",799.1)

"^DIC",799.31,799.31,0)
ROR XML ITEM^799.31
"^DIC",799.31,799.31,0,"GL")
^ROR(799.31,
"^DIC",799.31,799.31,"%",0)
^1.005^^0
"^DIC",799.31,799.31,"%D",0)
^^7^7^3040124^
"^DIC",799.31,799.31,"%D",1,0)
THIS FILE MUST NOT BE MODIFIED LOCALLY! ONLY 
"^DIC",799.31,799.31,"%D",2,0)
AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN EDIT
"^DIC",799.31,799.31,"%D",3,0)
THIS FILE!
"^DIC",799.31,799.31,"%D",4,0)
 
"^DIC",799.31,799.31,"%D",5,0)
The ROR XML ELEMENT file contains a list of XML 
"^DIC",799.31,799.31,"%D",6,0)
tags and attributes that can be used in the 
"^DIC",799.31,799.31,"%D",7,0)
reports.
"^DIC",799.31,"B","ROR XML ITEM",799.31)

"^DIC",799.33,799.33,0)
ROR DATA AREA^799.33
"^DIC",799.33,799.33,0,"GL")
^ROR(799.33,
"^DIC",799.33,799.33,"%",0)
^1.005^^0
"^DIC",799.33,799.33,"%D",0)
^^11^11^3030606^
"^DIC",799.33,799.33,"%D",1,0)
THIS FILE MUST NOT BE MODIFIED LOCALLY! ONLY 
"^DIC",799.33,799.33,"%D",2,0)
AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN EDIT
"^DIC",799.33,799.33,"%D",3,0)
THIS FILE!
"^DIC",799.33,799.33,"%D",4,0)
 
"^DIC",799.33,799.33,"%D",5,0)
The ROR DATA AREA stores codes and names of the
"^DIC",799.33,799.33,"%D",6,0)
data areas referenced by the HL7 SEGMENT (the ROR
"^DIC",799.33,799.33,"%D",7,0)
REGISTRY PARAMETERS file) and the EVENT (the ROR
"^DIC",799.33,799.33,"%D",8,0)
PENDING PATIENT file) multiples.
"^DIC",799.33,799.33,"%D",9,0)
 
"^DIC",799.33,799.33,"%D",10,0)
DO NOT EDIT OR DELETE RECORDS FROM THIS FILE IF
"^DIC",799.33,799.33,"%D",11,0)
THEY HAVE BEEN DISTRIBUTED TO THE SITES ALREADY!
"^DIC",799.33,"B","ROR DATA AREA",799.33)

"^DIC",799.34,799.34,0)
ROR REPORT PARAMETERS^799.34
"^DIC",799.34,799.34,0,"GL")
^ROR(799.34,
"^DIC",799.34,799.34,"%",0)
^1.005^^
"^DIC",799.34,799.34,"%D",0)
^^7^7^3030814^^
"^DIC",799.34,799.34,"%D",1,0)
The ROR REPORT PARAMETERS file stores the report
"^DIC",799.34,799.34,"%D",2,0)
definitions that are used by the ROR REPORT 
"^DIC",799.34,799.34,"%D",3,0)
SCHEDULE remote procedure to schedule the reports.
"^DIC",799.34,799.34,"%D",4,0)
 
"^DIC",799.34,799.34,"%D",5,0)
Records of the file are uniquely identified by the
"^DIC",799.34,799.34,"%D",6,0)
report code (the "A" primary key and the
"^DIC",799.34,799.34,"%D",7,0)
uniqueness index "KEY" are used for that purpose).
"^DIC",799.34,"B","ROR REPORT PARAMETERS",799.34)

"^DIC",799.4,799.4,0)
ROR ICR STUDY^799.4
"^DIC",799.4,799.4,0,"GL")
^RORDATA(799.4,
"^DIC",799.4,799.4,"%",0)
^1.005^^0
"^DIC",799.4,799.4,"%D",0)
^^15^15^3030507^
"^DIC",799.4,799.4,"%D",1,0)
The ROR ICR STUDY file stores the patients' data
"^DIC",799.4,799.4,"%D",2,0)
specific to the Immunology Case Registry (ICR).
"^DIC",799.4,799.4,"%D",3,0)
 
"^DIC",799.4,799.4,"%D",4,0)
Records of this file have the same internal entry
"^DIC",799.4,799.4,"%D",5,0)
numbers as the corresponding records of the ROR 
"^DIC",799.4,799.4,"%D",6,0)
LOCAL REGISTRY file (#798).
"^DIC",799.4,799.4,"%D",7,0)
 
"^DIC",799.4,799.4,"%D",8,0)
When an ICR record is deleted from the ROR LOCAL 
"^DIC",799.4,799.4,"%D",9,0)
REGISTRY file, the corresponding record of this
"^DIC",799.4,799.4,"%D",10,0)
file is deleted automatically.
"^DIC",799.4,799.4,"%D",11,0)
 
"^DIC",799.4,799.4,"%D",12,0)
A permanent screen (the ^DD(799.4,0,"SCR") node) 
"^DIC",799.4,799.4,"%D",13,0)
restricts access to this file. Only the users who
"^DIC",799.4,799.4,"%D",14,0)
have the ICR security key(s) and those with the
"^DIC",799.4,799.4,"%D",15,0)
ROR VA IRM key can access the records of the file.
"^DIC",799.4,"B","ROR ICR STUDY",799.4)

"^DIC",799.49,799.49,0)
ROR AIDS INDICATOR DISEASE^799.49
"^DIC",799.49,799.49,0,"GL")
^ROR(799.49,
"^DIC",799.49,799.49,"%",0)
^1.005^^0
"^DIC",799.49,799.49,"%D",0)
^^10^10^3030507^
"^DIC",799.49,799.49,"%D",1,0)
THIS FILE MUST NOT BE MODIFIED LOCALLY! ONLY 
"^DIC",799.49,799.49,"%D",2,0)
AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN EDIT
"^DIC",799.49,799.49,"%D",3,0)
THIS FILE!
"^DIC",799.49,799.49,"%D",4,0)
 
"^DIC",799.49,799.49,"%D",5,0)
The ROR AIDS INDICATOR DISEASE file contains 
"^DIC",799.49,799.49,"%D",6,0)
definitions of the AIDS indicator diseases 
"^DIC",799.49,799.49,"%D",7,0)
referenced by the Part VIII of the HIV CDC form.
"^DIC",799.49,799.49,"%D",8,0)
 
"^DIC",799.49,799.49,"%D",9,0)
Also see the AIDS INDICATOR DISEASE multiple (10)
"^DIC",799.49,799.49,"%D",10,0)
of the ROR ICR STUDY file (#799.4).
"^DIC",799.49,"B","ROR AIDS INDICATOR DISEASE",799.49)

"^DIC",799.51,799.51,0)
ROR GENERIC DRUG^799.51
"^DIC",799.51,799.51,0,"GL")
^ROR(799.51,
"^DIC",799.51,799.51,"%",0)
^1.005^^
"^DIC",799.51,799.51,"%D",0)
^^4^4^3040124^
"^DIC",799.51,799.51,"%D",1,0)
This file contains a list of registry specific
"^DIC",799.51,799.51,"%D",2,0)
generic drugs. For example, the ARV 
"^DIC",799.51,799.51,"%D",3,0)
(anti-retroviral) drugs associated with the
"^DIC",799.51,799.51,"%D",4,0)
Immunology Case Registry are stored here.
"^DIC",799.51,"B","ROR GENERIC DRUG",799.51)

**END**
**END**
