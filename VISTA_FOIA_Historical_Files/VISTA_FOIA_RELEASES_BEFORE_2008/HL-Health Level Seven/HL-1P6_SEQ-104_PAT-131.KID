Released HL*1.6*131 SEQ #104
Extracted from mail message
**KIDS**:HL*1.6*131^

**INSTALL NAME**
HL*1.6*131
"BLD",925,0)
HL*1.6*131^HEALTH LEVEL SEVEN^0^3060419^y
"BLD",925,1,0)
^^3^3^3060404^^
"BLD",925,1,1,0)

"BLD",925,1,2,0)

"BLD",925,1,3,0)

"BLD",925,4,0)
^9.64PA^^0
"BLD",925,6.3)
10
"BLD",925,"ABPKG")
n
"BLD",925,"INID")
^
"BLD",925,"INIT")

"BLD",925,"KRN",0)
^9.67PA^8989.52^19
"BLD",925,"KRN",.4,0)
.4
"BLD",925,"KRN",.401,0)
.401
"BLD",925,"KRN",.402,0)
.402
"BLD",925,"KRN",.403,0)
.403
"BLD",925,"KRN",.5,0)
.5
"BLD",925,"KRN",.84,0)
.84
"BLD",925,"KRN",3.6,0)
3.6
"BLD",925,"KRN",3.8,0)
3.8
"BLD",925,"KRN",9.2,0)
9.2
"BLD",925,"KRN",9.8,0)
9.8
"BLD",925,"KRN",9.8,"NM",0)
^9.68A^15^15
"BLD",925,"KRN",9.8,"NM",1,0)
HLOCLNT^^0^B57442573
"BLD",925,"KRN",9.8,"NM",2,0)
HLOCLNT1^^0^B28062817
"BLD",925,"KRN",9.8,"NM",3,0)
HLOCLNT2^^0^B30513205
"BLD",925,"KRN",9.8,"NM",4,0)
HLOSRVR^^0^B62293420
"BLD",925,"KRN",9.8,"NM",5,0)
HLOSRVR1^^0^B63396021
"BLD",925,"KRN",9.8,"NM",6,0)
HLOTCP^^0^B45043587
"BLD",925,"KRN",9.8,"NM",7,0)
HLOT^^0^B2729395
"BLD",925,"KRN",9.8,"NM",8,0)
HLOPRS2^^0^B25178316
"BLD",925,"KRN",9.8,"NM",9,0)
HLOAPI4^^0^B22068040
"BLD",925,"KRN",9.8,"NM",10,0)
HLOAPI2^^0^B36169512
"BLD",925,"KRN",9.8,"NM",11,0)
HLOTLNK^^0^B23891993
"BLD",925,"KRN",9.8,"NM",12,0)
HLOSTAT^^0^B55442954
"BLD",925,"KRN",9.8,"NM",13,0)
HLOSRVR2^^0^B13997562
"BLD",925,"KRN",9.8,"NM",14,0)
HLOPRS1^^0^B19358044
"BLD",925,"KRN",9.8,"NM",15,0)
HLOFILER^^0^B25709739
"BLD",925,"KRN",9.8,"NM","B","HLOAPI2",10)

"BLD",925,"KRN",9.8,"NM","B","HLOAPI4",9)

"BLD",925,"KRN",9.8,"NM","B","HLOCLNT",1)

"BLD",925,"KRN",9.8,"NM","B","HLOCLNT1",2)

"BLD",925,"KRN",9.8,"NM","B","HLOCLNT2",3)

"BLD",925,"KRN",9.8,"NM","B","HLOFILER",15)

"BLD",925,"KRN",9.8,"NM","B","HLOPRS1",14)

"BLD",925,"KRN",9.8,"NM","B","HLOPRS2",8)

"BLD",925,"KRN",9.8,"NM","B","HLOSRVR",4)

"BLD",925,"KRN",9.8,"NM","B","HLOSRVR1",5)

"BLD",925,"KRN",9.8,"NM","B","HLOSRVR2",13)

"BLD",925,"KRN",9.8,"NM","B","HLOSTAT",12)

"BLD",925,"KRN",9.8,"NM","B","HLOT",7)

"BLD",925,"KRN",9.8,"NM","B","HLOTCP",6)

"BLD",925,"KRN",9.8,"NM","B","HLOTLNK",11)

"BLD",925,"KRN",19,0)
19
"BLD",925,"KRN",19,"NM",0)
^9.68A^^
"BLD",925,"KRN",19.1,0)
19.1
"BLD",925,"KRN",101,0)
101
"BLD",925,"KRN",409.61,0)
409.61
"BLD",925,"KRN",771,0)
771
"BLD",925,"KRN",870,0)
870
"BLD",925,"KRN",8989.51,0)
8989.51
"BLD",925,"KRN",8989.52,0)
8989.52
"BLD",925,"KRN",8994,0)
8994
"BLD",925,"KRN","B",.4,.4)

"BLD",925,"KRN","B",.401,.401)

"BLD",925,"KRN","B",.402,.402)

"BLD",925,"KRN","B",.403,.403)

"BLD",925,"KRN","B",.5,.5)

"BLD",925,"KRN","B",.84,.84)

"BLD",925,"KRN","B",3.6,3.6)

"BLD",925,"KRN","B",3.8,3.8)

"BLD",925,"KRN","B",9.2,9.2)

"BLD",925,"KRN","B",9.8,9.8)

"BLD",925,"KRN","B",19,19)

"BLD",925,"KRN","B",19.1,19.1)

"BLD",925,"KRN","B",101,101)

"BLD",925,"KRN","B",409.61,409.61)

"BLD",925,"KRN","B",771,771)

"BLD",925,"KRN","B",870,870)

"BLD",925,"KRN","B",8989.51,8989.51)

"BLD",925,"KRN","B",8989.52,8989.52)

"BLD",925,"KRN","B",8994,8994)

"BLD",925,"QUES",0)
^9.62^^
"BLD",925,"REQB",0)
^9.611^1^1
"BLD",925,"REQB",1,0)
HL*1.6*130^2
"BLD",925,"REQB","B","HL*1.6*130",1)

"MBREQ")
0
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
131^3060419^16
"PKG",9,22,1,"PAH",1,1,0)
^^3^3^3060419
"PKG",9,22,1,"PAH",1,1,1,0)

"PKG",9,22,1,"PAH",1,1,2,0)

"PKG",9,22,1,"PAH",1,1,3,0)

"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
15
"RTN","HLOAPI2")
0^10^B36169512^B27708015
"RTN","HLOAPI2",1,0)
HLOAPI2 ;ALB/CJM-HL7 - Developer API's for sending application acks ;02/04/2004
"RTN","HLOAPI2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131**;Oct 13, 1995;Build 10
"RTN","HLOAPI2",3,0)
 ;
"RTN","HLOAPI2",4,0)
ACK(HLMSTATE,PARMS,ACK,ERROR) ;Default behavior is to return a general
"RTN","HLOAPI2",5,0)
 ;application ack. The application may optionally specify the message
"RTN","HLOAPI2",6,0)
 ;type and event or call $$ADDSEG^HLOAPI to add segments.
"RTN","HLOAPI2",7,0)
 ;A generic MSA segment (components 1-3) is added automatically IF the
"RTN","HLOAPI2",8,0)
 ;application doesn't call $$ADDSEG^HLOAPI to add an MSA segment as the
"RTN","HLOAPI2",9,0)
 ;FIRST segment following the header.
"RTN","HLOAPI2",10,0)
 ;$$SENDACK must be called when the ack is completed. The return
"RTN","HLOAPI2",11,0)
 ;destination is determined automatically from the original message
"RTN","HLOAPI2",12,0)
 ;
"RTN","HLOAPI2",13,0)
 ;This API should NOT be called for batch messages, use $$BATCHACK instead.
"RTN","HLOAPI2",14,0)
 ;Input:
"RTN","HLOAPI2",15,0)
 ;  HLMSTATE (pass by reference, required) the array obtained by calling $$STARTMSG^HLOPRS when parsing the original message 
"RTN","HLOAPI2",16,0)
 ;  PARMS (pass by reference) These subscripts may be defined:
"RTN","HLOAPI2",17,0)
 ;    "ACK CODE" (required) MSA1[ {AA,AE,AR}
"RTN","HLOAPI2",18,0)
 ;    "ERROR MESSAGE" - MSA3, should be used only if AE or AR
"RTN","HLOAPI2",19,0)
 ;    "ACCEPT ACK RESPONSE" - the <tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI2",20,0)
 ;    "ACCEPT ACK TYPE" - {AL,NE} (optional, defaults to AL)
"RTN","HLOAPI2",21,0)
 ;    "CONTINUATION POINTER" (optional)indicates a fragmented message
"RTN","HLOAPI2",22,0)
 ;    "COUNTRY" - the 3 character country code (optional)
"RTN","HLOAPI2",23,0)
 ;    "EVENT" - the 3 character event type (optional, defaults to the event code of the original message)
"RTN","HLOAPI2",24,0)
 ;     "ENCODING CHARACTERS" - the four HL7 encoding characters (optional,defaults to "^~\&"
"RTN","HLOAPI2",25,0)
 ;    "FAILURE RESPONSE" (optional) the <tag>^<routine> that the sending application routine should execute if the transmission of the message fails, i.e., the message can not be sent or a requested commit ack is not received.
"RTN","HLOAPI2",26,0)
 ;    "FIELD SEPARATOR" - field separator (optional, defaults to "|")
"RTN","HLOAPI2",27,0)
 ;    "MESSAGE TYPE" - if not defined, ACK is used
"RTN","HLOAPI2",28,0)
 ;    "MESSAGE STRUCTURE" (optional)
"RTN","HLOAPI2",29,0)
 ;    "QUEUE" - (optional) An application can name its own private queue (a string under 20 characters,namespaced). The default is the name of the queue of the original message
"RTN","HLOAPI2",30,0)
 ;    "SECURITY" (optional) security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI2",31,0)
 ;    "VERSION" - the HL7 Version ID (optional, defaults to 2.4)
"RTN","HLOAPI2",32,0)
 ;Output:
"RTN","HLOAPI2",33,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI2",34,0)
 ;  PARMS - left undefined when the function returns
"RTN","HLOAPI2",35,0)
 ;  ACK (pass by reference, required) the acknowledgment message being built.
"RTN","HLOAPI2",36,0)
 ;  ERROR (pass by reference) error msg
"RTN","HLOAPI2",37,0)
 N I,SEG,TOLINK,SUCCESS
"RTN","HLOAPI2",38,0)
 S SUCCESS=0,ERROR=""
"RTN","HLOAPI2",39,0)
 ;
"RTN","HLOAPI2",40,0)
 D
"RTN","HLOAPI2",41,0)
 .N PORT
"RTN","HLOAPI2",42,0)
 .I $G(PARMS("ACK CODE"))'="AA",$G(PARMS("ACK CODE"))'="AE",$G(PARMS("ACK CODE"))'="AR" S ERROR="INVALID ACK CODE" Q
"RTN","HLOAPI2",43,0)
 .;
"RTN","HLOAPI2",44,0)
 .I '$G(HLMSTATE("IEN")) S ERROR="ORIGINAL MESSAGE TO ACKNOWLEDGE IS NOT IDENTIFIED" Q
"RTN","HLOAPI2",45,0)
 .I $G(HLMSTATE("BATCH")) S ERROR="BATCH ACKNOWLEDGMENTS MUST USE $$BATCHACK^HLOAPI3" Q
"RTN","HLOAPI2",46,0)
 .;
"RTN","HLOAPI2",47,0)
 .I $G(HLMSTATE("HDR","MESSAGE CONTROL ID"))="" S ERROR="MESSAGE CONTROL ID MUST EXIST TO RETURN AN APPLICATION ACK" Q
"RTN","HLOAPI2",48,0)
 .S PARMS("MESSAGE TYPE")=$G(PARMS("MESSAGE TYPE"),"ACK")
"RTN","HLOAPI2",49,0)
 .S:PARMS("MESSAGE TYPE")="ACK" PARMS("MESSAGE STRUCTURE")="ACK"
"RTN","HLOAPI2",50,0)
 .S PARMS("EVENT")=$G(PARMS("EVENT"),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOAPI2",51,0)
 .I $$NEWMSG^HLOAPI(.PARMS,.ACK)  ;can't fail!
"RTN","HLOAPI2",52,0)
 .;
"RTN","HLOAPI2",53,0)
 .;if the return link can not be determined, the HL Logical Link file has a problem that must be fixed at the site
"RTN","HLOAPI2",54,0)
 .S PORT=$P(HLMSTATE("HDR","SENDING FACILITY",2),":",2)
"RTN","HLOAPI2",55,0)
 .S TOLINK=$$ACKLINK(.HLMSTATE)
"RTN","HLOAPI2",56,0)
 .I TOLINK="" S ERROR="TRANSMISSION LINK FOR APPLICATION ACK CANNOT BE DETERMINED" Q
"RTN","HLOAPI2",57,0)
 .I 'PORT S PORT=$$PORT2^HLOTLNK(TOLINK)
"RTN","HLOAPI2",58,0)
 .;
"RTN","HLOAPI2",59,0)
 .S ACK("HDR","APP ACK TYPE")="NE"
"RTN","HLOAPI2",60,0)
 .S ACK("HDR","ACCEPT ACK TYPE")=$G(PARMS("ACCEPT ACK TYPE"),"AL")
"RTN","HLOAPI2",61,0)
 .S ACK("STATUS","QUEUE")=$G(PARMS("QUEUE"),$G(HLMSTATE("STATUS","QUEUE")))
"RTN","HLOAPI2",62,0)
 .S ACK("STATUS","PORT")=PORT
"RTN","HLOAPI2",63,0)
 .S ACK("HDR","SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI2",64,0)
 .S ACK("HDR","SENDING APPLICATION")=$G(HLMSTATE("HDR","RECEIVING APPLICATION"))
"RTN","HLOAPI2",65,0)
 .S ACK("HDR","RECEIVING APPLICATION")=$G(HLMSTATE("HDR","SENDING APPLICATION"))
"RTN","HLOAPI2",66,0)
 .F I=1:1:3 S ACK("HDR","RECEIVING FACILITY",I)=$G(HLMSTATE("HDR","SENDING FACILITY",I))
"RTN","HLOAPI2",67,0)
 .S ACK("ACK TO","STATUS")=$S(PARMS("ACK CODE")="AA":"SU",1:"AE")
"RTN","HLOAPI2",68,0)
 .S ACK("ACK TO")=$G(HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOAPI2",69,0)
 .S ACK("ACK TO","IEN")=HLMSTATE("IEN")
"RTN","HLOAPI2",70,0)
 .S ACK("STATUS","LINK NAME")=TOLINK
"RTN","HLOAPI2",71,0)
 .S ACK("LINE COUNT")=0
"RTN","HLOAPI2",72,0)
 .S ACK("MSA")="MSA|"_PARMS("ACK CODE")_"|"_$G(HLMSTATE("HDR","MESSAGE CONTROL ID"))_"|"_$G(PARMS("ERROR MESSAGE"))
"RTN","HLOAPI2",73,0)
 .S SUCCESS=1
"RTN","HLOAPI2",74,0)
 K PARMS
"RTN","HLOAPI2",75,0)
 K:'SUCCESS ACK
"RTN","HLOAPI2",76,0)
 Q SUCCESS
"RTN","HLOAPI2",77,0)
 ;
"RTN","HLOAPI2",78,0)
SENDACK(ACK,ERROR) ;This is used to signal that an application acknowledgment is complete.
"RTN","HLOAPI2",79,0)
 ;Input:
"RTN","HLOAPI2",80,0)
 ;  ACK (pass by reference,required) An array that contains the acknowledgment msg
"RTN","HLOAPI2",81,0)
 ;Output:
"RTN","HLOAPI2",82,0)
 ; Function returns 1 on success, 0 on failure
"RTN","HLOAPI2",83,0)
 ; ERROR (pass by reference) error msg
"RTN","HLOAPI2",84,0)
 ;
"RTN","HLOAPI2",85,0)
 N SEG
"RTN","HLOAPI2",86,0)
 ;if the application added its own MSA, then the ACK("MSA") node was killed
"RTN","HLOAPI2",87,0)
 I $D(ACK("MSA")) S SEG(1)=ACK("MSA") D ADDSEG^HLOMSG(.ACK,.SEG)
"RTN","HLOAPI2",88,0)
 ;
"RTN","HLOAPI2",89,0)
 I $$SEND^HLOAPI1(.ACK,.ERROR) Q 1
"RTN","HLOAPI2",90,0)
 Q 0
"RTN","HLOAPI2",91,0)
 ;
"RTN","HLOAPI2",92,0)
ACKLINK(HLMSTATE) ;
"RTN","HLOAPI2",93,0)
 ;Finds the link to return the application ack to.
"RTN","HLOAPI2",94,0)
 N LINK
"RTN","HLOAPI2",95,0)
 S LINK=$$RTRNLNK^HLOAPP($G(HLMSTATE("HDR","RECEIVING APPLICATION")))
"RTN","HLOAPI2",96,0)
 Q:LINK]"" LINK
"RTN","HLOAPI2",97,0)
 S LINK=$$RTRNLNK^HLOTLNK($G(HLMSTATE("HDR","SENDING FACILITY",1)),$G(HLMSTATE("HDR","SENDING FACILITY",2)),$G(HLMSTATE("HDR","SENDING FACILITY",3)))
"RTN","HLOAPI2",98,0)
 Q LINK
"RTN","HLOAPI2",99,0)
 ;
"RTN","HLOAPI2",100,0)
CHKPARMS(HLMSTATE,PARMS,ERROR) ;
"RTN","HLOAPI2",101,0)
 N LEN,SARY,HARY
"RTN","HLOAPI2",102,0)
 ;
"RTN","HLOAPI2",103,0)
 ;shortcut to reference the header sub-array
"RTN","HLOAPI2",104,0)
 S HARY="HLMSTATE(""HDR"")"
"RTN","HLOAPI2",105,0)
 ;
"RTN","HLOAPI2",106,0)
 ;shortcut to reference the status sub-array
"RTN","HLOAPI2",107,0)
 S SARY="HLMSTATE(""STATUS"")"
"RTN","HLOAPI2",108,0)
 ;
"RTN","HLOAPI2",109,0)
 S ERROR=""
"RTN","HLOAPI2",110,0)
 I $G(PARMS("ACCEPT ACK TYPE"))="" S PARMS("ACCEPT ACK TYPE")="AL"
"RTN","HLOAPI2",111,0)
 I $G(PARMS("APP ACK TYPE"))="" S PARMS("APP ACK TYPE")="NE"
"RTN","HLOAPI2",112,0)
 I PARMS("ACCEPT ACK TYPE")'="NE",PARMS("ACCEPT ACK TYPE")'="AL" S ERROR="INVALID ACCEPT ACKNOWLEDGMENT TYPE"
"RTN","HLOAPI2",113,0)
 I PARMS("APP ACK TYPE")'="NE",PARMS("APP ACK TYPE")'="AL" S ERROR="INVALID APPLICATION ACKNOWLEDGMENT TYPE"
"RTN","HLOAPI2",114,0)
 S LEN=$L($G(PARMS("QUEUE")))
"RTN","HLOAPI2",115,0)
 I $G(PARMS("QUEUE"))["^" S ERROR="QUEUE NAME MAY NOT CONTAIN '^'"
"RTN","HLOAPI2",116,0)
 I LEN>20 S ERROR="QUEUE PARAMETER IS MAX 20 LENGTH",PARMS("QUEUE")=$E(PARMS("QUEUE"),1,20)
"RTN","HLOAPI2",117,0)
 I 'LEN S PARMS("QUEUE")="DEFAULT"
"RTN","HLOAPI2",118,0)
 I $G(PARMS("SENDING APPLICATION"))="" D
"RTN","HLOAPI2",119,0)
 .S ERROR="SENDING APPLICATION IS REQUIRED"
"RTN","HLOAPI2",120,0)
 .S PARMS("SENDING APPLICATION")=""
"RTN","HLOAPI2",121,0)
 E  D
"RTN","HLOAPI2",122,0)
 .I '$D(^HLD(779.2,"C",PARMS("SENDING APPLICATION"))) S ERROR="SENDING APPLICATION NOT FOUND IN THE HLO APPLICATION REGISTRY"
"RTN","HLOAPI2",123,0)
 ;
"RTN","HLOAPI2",124,0)
 ;move parameters into HLMSTATE
"RTN","HLOAPI2",125,0)
 S @HARY@("ACCEPT ACK TYPE")=PARMS("ACCEPT ACK TYPE")
"RTN","HLOAPI2",126,0)
 S @HARY@("APP ACK TYPE")=PARMS("APP ACK TYPE")
"RTN","HLOAPI2",127,0)
 S @HARY@("SENDING APPLICATION")=$E(PARMS("SENDING APPLICATION"),1,60)
"RTN","HLOAPI2",128,0)
 S @HARY@("SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI2",129,0)
 S @SARY@("APP ACK RESPONSE")=$G(PARMS("APP ACK RESPONSE"))
"RTN","HLOAPI2",130,0)
 S @SARY@("ACCEPT ACK RESPONSE")=$G(PARMS("ACCEPT ACK RESPONSE"))
"RTN","HLOAPI2",131,0)
 S @SARY@("FAILURE RESPONSE")=$G(PARMS("FAILURE RESPONSE"))
"RTN","HLOAPI2",132,0)
 S @SARY@("QUEUE")=PARMS("QUEUE")
"RTN","HLOAPI2",133,0)
 Q:$L(ERROR) 0
"RTN","HLOAPI2",134,0)
 Q 1
"RTN","HLOAPI2",135,0)
 ;
"RTN","HLOAPI2",136,0)
SETCODE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI2",137,0)
 ;Implements SETCNE and SETCWE
"RTN","HLOAPI2",138,0)
 ;
"RTN","HLOAPI2",139,0)
 N SUB,VAR
"RTN","HLOAPI2",140,0)
 Q:'$G(FIELD)
"RTN","HLOAPI2",141,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI2",142,0)
 I '$G(COMP) D
"RTN","HLOAPI2",143,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI2",144,0)
 E  D
"RTN","HLOAPI2",145,0)
 .S VAR="SUB"
"RTN","HLOAPI2",146,0)
 S @VAR=1,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ID"))
"RTN","HLOAPI2",147,0)
 S @VAR=2,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("TEXT"))
"RTN","HLOAPI2",148,0)
 S @VAR=3,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("SYSTEM"))
"RTN","HLOAPI2",149,0)
 S @VAR=4,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ALTERNATE ID"))
"RTN","HLOAPI2",150,0)
 S @VAR=5,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ALTERNATE TEXT"))
"RTN","HLOAPI2",151,0)
 S @VAR=6,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ALTERNATE SYSTEM"))
"RTN","HLOAPI2",152,0)
 S @VAR=7,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("SYSTEM VERSION"))
"RTN","HLOAPI2",153,0)
 S @VAR=8,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ALTERNATE SYSTEM VERSION"))
"RTN","HLOAPI2",154,0)
 S @VAR=9,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ORIGINAL TEXT"))
"RTN","HLOAPI2",155,0)
 Q
"RTN","HLOAPI4")
0^9^B22068040
"RTN","HLOAPI4",1,0)
HLOAPI4 ;ALB/CJM-HL7 - Developer API's for sending & receiving messages(continued) ;02/04/2004
"RTN","HLOAPI4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**131**;Oct 13, 1995;Build 10
"RTN","HLOAPI4",3,0)
 ;
"RTN","HLOAPI4",4,0)
SETTS(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",5,0)
 ;Sets a value that is a timestamp in FM format into the segment in HL7
"RTN","HLOAPI4",6,0)
 ;format. The degree of precision may be optionally specified. The
"RTN","HLOAPI4",7,0)
 ;inserted value will include the timezone if the input included the time.
"RTN","HLOAPI4",8,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",9,0)
 ;
"RTN","HLOAPI4",10,0)
 ;Input:
"RTN","HLOAPI4",11,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",12,0)
 ;  VALUE  (required)to be set into the segment
"RTN","HLOAPI4",13,0)
 ;  VALUE("PRECISION") (optional) If included, VALUE must be passed by
"RTN","HLOAPI4",14,0)
 ;       reference.  Allowed values are:
"RTN","HLOAPI4",15,0)
 ;           "S" - seconds (default value)
"RTN","HLOAPI4",16,0)
 ;           "M" - minutes
"RTN","HLOAPI4",17,0)
 ;           "H" - hours
"RTN","HLOAPI4",18,0)
 ;           "D" - days
"RTN","HLOAPI4",19,0)
 ;  FIELD - the sequence # of the field
"RTN","HLOAPI4",20,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",21,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating.
"RTN","HLOAPI4",22,0)
 ;Output: 
"RTN","HLOAPI4",23,0)
 ;   SEG array
"RTN","HLOAPI4",24,0)
 ;
"RTN","HLOAPI4",25,0)
 ;Example:
"RTN","HLOAPI4",26,0)
 ;    D SETTS^HLOAPI4(.SEG,$$NOW^XLFDT,1) will place the current date/time into the segment in the 1st field,1st occurence.  The timezone is included.
"RTN","HLOAPI4",27,0)
 ;
"RTN","HLOAPI4",28,0)
 ;
"RTN","HLOAPI4",29,0)
 N TIME
"RTN","HLOAPI4",30,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",31,0)
 Q:'$G(VALUE)
"RTN","HLOAPI4",32,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",33,0)
 S:'$G(COMP) COMP=1
"RTN","HLOAPI4",34,0)
 S TIME=$$FMTHL7^XLFDT(VALUE)
"RTN","HLOAPI4",35,0)
 I $D(VALUE("PRECISION")) D
"RTN","HLOAPI4",36,0)
 .N TZ
"RTN","HLOAPI4",37,0)
 .S TZ=""
"RTN","HLOAPI4",38,0)
 .I TIME["+" S TZ="+"_$P(TIME,"+",2)
"RTN","HLOAPI4",39,0)
 .E  I TIME["-" S TZ="-"_$P(TIME,"-",2)
"RTN","HLOAPI4",40,0)
 .I VALUE("PRECISION")="D" D
"RTN","HLOAPI4",41,0)
 ..S TIME=$E(TIME,1,8)_TZ
"RTN","HLOAPI4",42,0)
 .E  I VALUE("PRECISION")="H" D
"RTN","HLOAPI4",43,0)
 ..S TIME=$E($$LJ^XLFSTR(+TIME,10,0),1,10)_TZ
"RTN","HLOAPI4",44,0)
 .E  I VALUE("PRECISION")="M" D
"RTN","HLOAPI4",45,0)
 ..S TIME=$E($$LJ^XLFSTR(+TIME,12,0),1,12)_TZ
"RTN","HLOAPI4",46,0)
 .E  I VALUE("PRECISION")="S" D
"RTN","HLOAPI4",47,0)
 ..S TIME=$E($$LJ^XLFSTR(+TIME,14,0),1,14)_TZ
"RTN","HLOAPI4",48,0)
 S SEG(FIELD+1,REP,COMP,1)=TIME
"RTN","HLOAPI4",49,0)
 Q
"RTN","HLOAPI4",50,0)
 ;
"RTN","HLOAPI4",51,0)
SETDT(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",52,0)
 ;Sets a value that is a date in FM format into the segment in HL7 format.  The degree of precision may be optionally specified.
"RTN","HLOAPI4",53,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",54,0)
 ;
"RTN","HLOAPI4",55,0)
 ;Input:
"RTN","HLOAPI4",56,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",57,0)
 ;  VALUE  (required)the date to be set into the segment
"RTN","HLOAPI4",58,0)
 ;  VALUE("PRECISION") (optional) If included, VALUE must be passed by
"RTN","HLOAPI4",59,0)
 ;       reference.  Allowed values are:
"RTN","HLOAPI4",60,0)
 ;           "D" - day (default value)
"RTN","HLOAPI4",61,0)
 ;           "L" - month
"RTN","HLOAPI4",62,0)
 ;           "Y" - year
"RTN","HLOAPI4",63,0)
 ;  FIELD - the sequence # of the field
"RTN","HLOAPI4",64,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",65,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating.
"RTN","HLOAPI4",66,0)
 ;Output:
"RTN","HLOAPI4",67,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",68,0)
 ;
"RTN","HLOAPI4",69,0)
 ;Example:
"RTN","HLOAPI4",70,0)
 ;    D SETDT^HLOAPI4(.SEG,$$TODAY^XLFDT,1) will place the current date into segment in the 1st field,1st occurence.
"RTN","HLOAPI4",71,0)
 ;
"RTN","HLOAPI4",72,0)
 ;
"RTN","HLOAPI4",73,0)
 N TIME
"RTN","HLOAPI4",74,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",75,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",76,0)
 S:'$G(COMP) COMP=1
"RTN","HLOAPI4",77,0)
 S TIME=$$FMTHL7^XLFDT(VALUE)
"RTN","HLOAPI4",78,0)
 I $D(VALUE("PRECISION")) D
"RTN","HLOAPI4",79,0)
 .I VALUE("PRECISION")="Y" D
"RTN","HLOAPI4",80,0)
 ..S TIME=$E(TIME,1,4)
"RTN","HLOAPI4",81,0)
 .E  I VALUE("PRECISION")="L" D
"RTN","HLOAPI4",82,0)
 ..S TIME=$E(TIME,1,6)
"RTN","HLOAPI4",83,0)
 .E  I VALUE("PRECISION")="D" D
"RTN","HLOAPI4",84,0)
 ..S TIME=$E(TIME,1,8)
"RTN","HLOAPI4",85,0)
 S SEG(FIELD+1,REP,COMP,1)=TIME
"RTN","HLOAPI4",86,0)
 Q
"RTN","HLOAPI4",87,0)
 ;
"RTN","HLOAPI4",88,0)
SETCE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",89,0)
 ;Sets a value that is an HL7 Coded Element data type (HL7 Section Reference 2.9.3) into the segment in the specified field.
"RTN","HLOAPI4",90,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",91,0)
 ;
"RTN","HLOAPI4",92,0)
 ;Input:
"RTN","HLOAPI4",93,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",94,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",95,0)
 ;    "ID" - the identifier
"RTN","HLOAPI4",96,0)
 ;    "TEXT" - 
"RTN","HLOAPI4",97,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOAPI4",98,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOAPI4",99,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOAPI4",100,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOAPI4",101,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",102,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",103,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",104,0)
 ;Output: 
"RTN","HLOAPI4",105,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",106,0)
 ;
"RTN","HLOAPI4",107,0)
 N SUB,VAR
"RTN","HLOAPI4",108,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",109,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",110,0)
 I '$G(COMP) D
"RTN","HLOAPI4",111,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI4",112,0)
 E  D
"RTN","HLOAPI4",113,0)
 .S VAR="SUB"
"RTN","HLOAPI4",114,0)
 S @VAR=1,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ID"))
"RTN","HLOAPI4",115,0)
 S @VAR=2,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("TEXT"))
"RTN","HLOAPI4",116,0)
 S @VAR=3,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("SYSTEM"))
"RTN","HLOAPI4",117,0)
 S @VAR=4,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ALTERNATE ID"))
"RTN","HLOAPI4",118,0)
 S @VAR=5,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ALTERNATE TEXT"))
"RTN","HLOAPI4",119,0)
 S @VAR=6,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ALTERNATE SYSTEM"))
"RTN","HLOAPI4",120,0)
 Q
"RTN","HLOAPI4",121,0)
 ;
"RTN","HLOAPI4",122,0)
SETHD(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",123,0)
 ;Sets a value that is an HL7 Hierarchic Designator data type (HL7 Section Reference 2.9.21) into the segment in the specified field.
"RTN","HLOAPI4",124,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",125,0)
 ;
"RTN","HLOAPI4",126,0)
 ;Input:
"RTN","HLOAPI4",127,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",128,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",129,0)
 ;    "NAMESPACE ID"
"RTN","HLOAPI4",130,0)
 ;    "UNIVERSAL ID"
"RTN","HLOAPI4",131,0)
 ;    "UNIVERSAL ID TYPE"
"RTN","HLOAPI4",132,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",133,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",134,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",135,0)
 ;Output: 
"RTN","HLOAPI4",136,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",137,0)
 ;
"RTN","HLOAPI4",138,0)
 N SUB,VAR
"RTN","HLOAPI4",139,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",140,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",141,0)
 I '$G(COMP) D
"RTN","HLOAPI4",142,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI4",143,0)
 E  D
"RTN","HLOAPI4",144,0)
 .S VAR="SUB"
"RTN","HLOAPI4",145,0)
 S @VAR=1,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("NAMESPACE ID"))
"RTN","HLOAPI4",146,0)
 S @VAR=2,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("UNIVERSAL ID"))
"RTN","HLOAPI4",147,0)
 S @VAR=3,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("UNIVERSAL ID TYPE"))
"RTN","HLOAPI4",148,0)
 Q
"RTN","HLOAPI4",149,0)
 ;
"RTN","HLOAPI4",150,0)
SETCNE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",151,0)
 ;Sets a value that is an HL7 Coded With No Exceptions  data type (HL7 Section Reference 2.9.8) into the segment in the specified field.
"RTN","HLOAPI4",152,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",153,0)
 ;
"RTN","HLOAPI4",154,0)
 ;Input:
"RTN","HLOAPI4",155,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",156,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",157,0)
 ;    "ID" - the identifier
"RTN","HLOAPI4",158,0)
 ;    "TEXT" - 
"RTN","HLOAPI4",159,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOAPI4",160,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOAPI4",161,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOAPI4",162,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOAPI4",163,0)
 ;    "SYSTEM VERSION" - version ID of the coding system
"RTN","HLOAPI4",164,0)
 ;    "ALTERNATE SYSTEM VERSION" - version ID of the alternate coding system
"RTN","HLOAPI4",165,0)
 ;    "ORIGINAL TEXT"
"RTN","HLOAPI4",166,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",167,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",168,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",169,0)
 ;Output: 
"RTN","HLOAPI4",170,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",171,0)
 D SETCODE^HLOAPI2(.SEG,.VALUE,.FIELD,.COMP,.REP)
"RTN","HLOAPI4",172,0)
 Q
"RTN","HLOAPI4",173,0)
 ;
"RTN","HLOAPI4",174,0)
SETCWE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",175,0)
 ;Sets a value that is an HL7 Coded With Exceptions  data type (HL7 Section Reference 2.9.11) into the segment in the specified field.
"RTN","HLOAPI4",176,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",177,0)
 ;
"RTN","HLOAPI4",178,0)
 ;Input:
"RTN","HLOAPI4",179,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",180,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",181,0)
 ;    "ID" - the identifier
"RTN","HLOAPI4",182,0)
 ;    "TEXT" - 
"RTN","HLOAPI4",183,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOAPI4",184,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOAPI4",185,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOAPI4",186,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOAPI4",187,0)
 ;    "SYSTEM VERSION" - version ID of the coding system
"RTN","HLOAPI4",188,0)
 ;    "ALTERNATE SYSTEM VERSION" - version ID of the alternate coding system
"RTN","HLOAPI4",189,0)
 ;    "ORIGINAL TEXT"
"RTN","HLOAPI4",190,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",191,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",192,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",193,0)
 ;Output: 
"RTN","HLOAPI4",194,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",195,0)
 D SETCODE^HLOAPI2(.SEG,.VALUE,.FIELD,.COMP,.REP)
"RTN","HLOAPI4",196,0)
 Q
"RTN","HLOAPI4",197,0)
 ;
"RTN","HLOAPI4",198,0)
SETAD(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",199,0)
 ;Sets an AD data type (Address, HL7 Section Reference 2.9.1) into the segment in the specified field. It can also be used to set the 1st 8 components of the XAD (Extended Address) data type.
"RTN","HLOAPI4",200,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",201,0)
 ;
"RTN","HLOAPI4",202,0)
 ;Input:
"RTN","HLOAPI4",203,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",204,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",205,0)
 ;    "STREET1" -street address
"RTN","HLOAPI4",206,0)
 ;    "STREET2" - other designation
"RTN","HLOAPI4",207,0)
 ;    "CITY"
"RTN","HLOAPI4",208,0)
 ;    "STATE" - state or province
"RTN","HLOAPI4",209,0)
 ;    "ZIP" - zip or postal code
"RTN","HLOAPI4",210,0)
 ;    "COUNTRY"
"RTN","HLOAPI4",211,0)
 ;    "TYPE"  - address type
"RTN","HLOAPI4",212,0)
 ;    "OTHER" - other geographic designation
"RTN","HLOAPI4",213,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",214,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",215,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",216,0)
 ;Output: 
"RTN","HLOAPI4",217,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",218,0)
 ;
"RTN","HLOAPI4",219,0)
 N SUB,VAR
"RTN","HLOAPI4",220,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",221,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",222,0)
 I '$G(COMP) D
"RTN","HLOAPI4",223,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI4",224,0)
 E  D
"RTN","HLOAPI4",225,0)
 .S VAR="SUB"
"RTN","HLOAPI4",226,0)
 S @VAR=1,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("STREET1"))
"RTN","HLOAPI4",227,0)
 S @VAR=2,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("STREET2"))
"RTN","HLOAPI4",228,0)
 S @VAR=3,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("CITY"))
"RTN","HLOAPI4",229,0)
 S @VAR=4,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("STATE"))
"RTN","HLOAPI4",230,0)
 S @VAR=5,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("ZIP"))
"RTN","HLOAPI4",231,0)
 S @VAR=6,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("COUNTRY"))
"RTN","HLOAPI4",232,0)
 S @VAR=7,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("TYPE"))
"RTN","HLOAPI4",233,0)
 S @VAR=8,SEG(FIELD+1,REP,COMP,SUB)=$G(VALUE("OTHER"))
"RTN","HLOAPI4",234,0)
 Q
"RTN","HLOCLNT")
0^1^B57442573^B55768085
"RTN","HLOCLNT",1,0)
HLOCLNT ;ALB/CJM- Client for sending messages - 10/4/94 1pm
"RTN","HLOCLNT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131**;Oct 13, 1995;Build 10
"RTN","HLOCLNT",3,0)
 ;
"RTN","HLOCLNT",4,0)
 ;GET WORK function for the process running under the Process Manager
"RTN","HLOCLNT",5,0)
GETWORK(QUE) ;
"RTN","HLOCLNT",6,0)
 ;Input:
"RTN","HLOCLNT",7,0)
 ;  QUE - (pass by reference) These subscripts are used:
"RTN","HLOCLNT",8,0)
 ;    ("LINK")  - <link name>_":"_<port> last obtained
"RTN","HLOCLNT",9,0)
 ;    ("QUEUE") - name of the queue last obtained
"RTN","HLOCLNT",10,0)
 ;Output:
"RTN","HLOCLNT",11,0)
 ;  Function returns 1 if success, 0 if no more work
"RTN","HLOCLNT",12,0)
 ;  QUE -  updated to identify next queue of messages to process.
"RTN","HLOCLNT",13,0)
 ;    ("LINK") - <link name>_":"_<port>
"RTN","HLOCLNT",14,0)
 ;    ("QUEUE") - the named queue on the link
"RTN","HLOCLNT",15,0)
 ;    ("DOWN") - =1 means that the last OPEN attempt failed
"RTN","HLOCLNT",16,0)
 ;
"RTN","HLOCLNT",17,0)
 N LINK,QUEUE
"RTN","HLOCLNT",18,0)
 S LINK=$G(QUE("LINK")),QUEUE=$G(QUE("QUEUE"))
"RTN","HLOCLNT",19,0)
 I (LINK]""),(QUEUE]"") D
"RTN","HLOCLNT",20,0)
 .L -^HLB("QUEUE","OUT",LINK,QUEUE)
"RTN","HLOCLNT",21,0)
 .I '$$CNNCTD(LINK),$$FAILING(.LINK) S QUEUE="" Q
"RTN","HLOCLNT",22,0)
 .F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0  Q:$T
"RTN","HLOCLNT",23,0)
 I (LINK]""),(QUEUE="") D
"RTN","HLOCLNT",24,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",25,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",26,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",27,0)
 I LINK="" D
"RTN","HLOCLNT",28,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",29,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",30,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",31,0)
 S QUE("LINK")=LINK,QUE("QUEUE")=QUEUE,QUE("DOWN")=$G(LINK("DOWN"))
"RTN","HLOCLNT",32,0)
 Q:$L(QUEUE) 1
"RTN","HLOCLNT",33,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",34,0)
 Q 0
"RTN","HLOCLNT",35,0)
 ;
"RTN","HLOCLNT",36,0)
FAILING(LINK) ;
"RTN","HLOCLNT",37,0)
 ;Returns 1 if the link has failed in the last 30 seconds, 0 otherwise
"RTN","HLOCLNT",38,0)
 ;Also returns LINK("DOWN")=1 if the link was failing > 30 seconds ago, not yet known if its up
"RTN","HLOCLNT",39,0)
 ;
"RTN","HLOCLNT",40,0)
 N LASTTIME,SET
"RTN","HLOCLNT",41,0)
 S LINK("DOWN")=0
"RTN","HLOCLNT",42,0)
 S LASTTIME=$G(^HLB("QUEUE","OUT",LINK))
"RTN","HLOCLNT",43,0)
 S SET=$S(LASTTIME]"":1,1:0)
"RTN","HLOCLNT",44,0)
 I SET D
"RTN","HLOCLNT",45,0)
 .I $$HDIFF^XLFDT($H,LASTTIME,2)>30 S ^HLB("QUEUE","OUT",LINK)="",SET=0,LINK("DOWN")=1
"RTN","HLOCLNT",46,0)
 I $D(^HLTMP("FAILING LINKS",LINK)) S LINK("DOWN")=1
"RTN","HLOCLNT",47,0)
 Q SET
"RTN","HLOCLNT",48,0)
 ;
"RTN","HLOCLNT",49,0)
LINKDOWN(HLCSTATE) ;
"RTN","HLOCLNT",50,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",51,0)
 I $D(HLCSTATE("LINK","NAME")),$D(HLCSTATE("LINK","PORT")) D
"RTN","HLOCLNT",52,0)
 .S TO=HLCSTATE("LINK","NAME")_":"_HLCSTATE("LINK","PORT")
"RTN","HLOCLNT",53,0)
 .S ^HLB("QUEUE","OUT",TO)=$H
"RTN","HLOCLNT",54,0)
 .S:'$D(^HLTMP("FAILING LINKS",TO)) ^HLTMP("FAILING LINKS",TO)=$H
"RTN","HLOCLNT",55,0)
 Q
"RTN","HLOCLNT",56,0)
 ;
"RTN","HLOCLNT",57,0)
ERROR ;error trap
"RTN","HLOCLNT",58,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOCLNT",59,0)
 D END
"RTN","HLOCLNT",60,0)
 D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",61,0)
 ;
"RTN","HLOCLNT",62,0)
 ;while debugging quit on all errors - this will return the process to the Process Manager error trap
"RTN","HLOCLNT",63,0)
 I $G(^HLTMP("LOG ALL ERRORS")) QUIT
"RTN","HLOCLNT",64,0)
 ;
"RTN","HLOCLNT",65,0)
 ;don't log some common errors
"RTN","HLOCLNT",66,0)
 I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D
"RTN","HLOCLNT",67,0)
 .;
"RTN","HLOCLNT",68,0)
 E  D
"RTN","HLOCLNT",69,0)
 .D ^%ZTER
"RTN","HLOCLNT",70,0)
 ;
"RTN","HLOCLNT",71,0)
 ;a lot of errors of the same type may indicate an endless loop, so keep a count
"RTN","HLOCLNT",72,0)
 S ^TMP("HL7 ERRORS",$J,$ECODE)=$G(^TMP("HL7 ERRORS",$J,$ECODE))+1
"RTN","HLOCLNT",73,0)
 ;
"RTN","HLOCLNT",74,0)
 QUIT:($G(^TMP("HL7 ERRORS",$J,$ECODE))>100)  ;return to the Process Manager error trap
"RTN","HLOCLNT",75,0)
 D UNWIND^%ZTER
"RTN","HLOCLNT",76,0)
 Q
"RTN","HLOCLNT",77,0)
 ;
"RTN","HLOCLNT",78,0)
DOWORK(QUEUE) ;sends the messages on the queue
"RTN","HLOCLNT",79,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOCLNT"
"RTN","HLOCLNT",80,0)
 N MSGIEN,DEQUE,SUCCESS,MSGCOUNT
"RTN","HLOCLNT",81,0)
 S DEQUE=0
"RTN","HLOCLNT",82,0)
 S SUCCESS=1
"RTN","HLOCLNT",83,0)
 I '$$CNNCTD(QUEUE("LINK")),'$$CONNECT^HLOCLNT1($P(QUEUE("LINK"),":"),$P(QUEUE("LINK"),":",2),30,.HLCSTATE) Q
"RTN","HLOCLNT",84,0)
 ;
"RTN","HLOCLNT",85,0)
 S (MSGCOUNT,MSGIEN)=0
"RTN","HLOCLNT",86,0)
 F  S MSGIEN=$O(^HLB("QUEUE","OUT",QUEUE("LINK"),QUEUE("QUEUE"),MSGIEN)) Q:'MSGIEN  D  Q:'SUCCESS  Q:MSGCOUNT>1000
"RTN","HLOCLNT",87,0)
 .N UPDATE
"RTN","HLOCLNT",88,0)
 .I $$INC^HLOSITE($NA(^HLB(MSGIEN,"TRIES"))) S SUCCESS=0
"RTN","HLOCLNT",89,0)
 .S:$$TRANSMIT(.HLCSTATE,MSGIEN,.UPDATE) SUCCESS=1
"RTN","HLOCLNT",90,0)
 .Q:('SUCCESS)!('$D(UPDATE))  ;'$D(UPDATE) with SUCCESS=1 means that the message is to be removed from the queue without actually being transmitted
"RTN","HLOCLNT",91,0)
 .D DEQUE(.UPDATE)
"RTN","HLOCLNT",92,0)
 .S MSGCOUNT=MSGCOUNT+1
"RTN","HLOCLNT",93,0)
 .D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOCLNT",94,0)
 .;
"RTN","HLOCLNT",95,0)
 .;if the queue was on the down list, and not since shutdown, mark it as up, since a message has been successfully transmitted across it
"RTN","HLOCLNT",96,0)
 .I $G(QUEUE("DOWN"))!$$FAILING(QUEUE("LINK")),'$$IFSHUT^HLOTLNK(QUEUE("LINK")) S QUEUE("DOWN")=0,^HLB("QUEUE","OUT",QUEUE("LINK"))="" K ^HLTMP("FAILING LINKS",QUEUE("LINK"))
"RTN","HLOCLNT",97,0)
 ;
"RTN","HLOCLNT",98,0)
END D DEQUE()
"RTN","HLOCLNT",99,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOCLNT",100,0)
 Q
"RTN","HLOCLNT",101,0)
CNNCTD(LINK) ;
"RTN","HLOCLNT",102,0)
 ;Connected to LINK?  HLCSTATE must be defined, LINK=<link name>:<port>
"RTN","HLOCLNT",103,0)
 ;
"RTN","HLOCLNT",104,0)
 I ($G(HLCSTATE("LINK","NAME"))=$P(LINK,":")),($G(HLCSTATE("LINK","PORT"))=$P(LINK,":",2)),$G(HLCSTATE("CONNECTED")) Q 1
"RTN","HLOCLNT",105,0)
 Q 0
"RTN","HLOCLNT",106,0)
 ;
"RTN","HLOCLNT",107,0)
DEQUE(UPDATE) ;
"RTN","HLOCLNT",108,0)
 I $D(UPDATE) S DEQUE=DEQUE+1,DEQUE(+UPDATE)=$P(UPDATE,"^",2,99) S:$G(UPDATE("MSA"))]"" DEQUE(+UPDATE,"MSA")=UPDATE("MSA") S:$G(UPDATE("ACTION"))]"" DEQUE(+UPDATE,"ACTION")=UPDATE("ACTION")
"RTN","HLOCLNT",109,0)
 I '$D(UPDATE)!(DEQUE>15) D
"RTN","HLOCLNT",110,0)
 .N MSGIEN S MSGIEN=0
"RTN","HLOCLNT",111,0)
 .F  S MSGIEN=$O(DEQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOCLNT",112,0)
 ..N NODE,TIME
"RTN","HLOCLNT",113,0)
 ..D DEQUE^HLOQUE(QUEUE("LINK"),QUEUE("QUEUE"),"OUT",MSGIEN)
"RTN","HLOCLNT",114,0)
 ..S TIME=$P(DEQUE(MSGIEN),"^")
"RTN","HLOCLNT",115,0)
 ..S NODE=QUEUE("LINK")_"^"_QUEUE("QUEUE")_"^"_$P(DEQUE(MSGIEN),"^",2,99)
"RTN","HLOCLNT",116,0)
 ..S ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN)=NODE
"RTN","HLOCLNT",117,0)
 ..S:$G(DEQUE(MSGIEN,"MSA"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"MSA")=DEQUE(MSGIEN,"MSA")
"RTN","HLOCLNT",118,0)
 ..S:$G(DEQUE(MSGIEN,"ACTION"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"ACTION")=DEQUE(MSGIEN,"ACTION")
"RTN","HLOCLNT",119,0)
 .K DEQUE S DEQUE=0
"RTN","HLOCLNT",120,0)
 Q
"RTN","HLOCLNT",121,0)
 ;
"RTN","HLOCLNT",122,0)
TRANSMIT(HLCSTATE,MSGIEN,UPDATE) ;
"RTN","HLOCLNT",123,0)
 ;Transmits a single message and if a commit ack was requested reads it.  Updates file 778 with the result.  Queues for the infiler the application accept action if one was requested.
"RTN","HLOCLNT",124,0)
 ;Input:
"RTN","HLOCLNT",125,0)
 ;   HLCSTATE (pass by reference)
"RTN","HLOCLNT",126,0)
 ;   MSGIEN - ien, file 778, of message to be transmitted
"RTN","HLOCLNT",127,0)
 ;Output:
"RTN","HLOCLNT",128,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT",129,0)
 ;  UPDATE - (pass by reference) to contain updates needed for message
"RTN","HLOCLNT",130,0)
 ;
"RTN","HLOCLNT",131,0)
 N HLMSTATE,MSA,HDR,SUCCESS
"RTN","HLOCLNT",132,0)
 ;
"RTN","HLOCLNT",133,0)
 S SUCCESS=0
"RTN","HLOCLNT",134,0)
 S HLCSTATE("ATTEMPT")=0
"RTN","HLOCLNT",135,0)
 ;
"RTN","HLOCLNT",136,0)
 Q:'$$GETMSG^HLOCLNT2(MSGIEN,.HLMSTATE) 1  ;returns 1 so the message will be removed from the queue
"RTN","HLOCLNT",137,0)
 I HLMSTATE("DT/TM"),HLMSTATE("STATUS","ACCEPTED")!(HLMSTATE("HDR","ACCEPT ACK TYPE")="NE") Q 1  ;the message was already transmitted
"RTN","HLOCLNT",138,0)
 ;
"RTN","HLOCLNT",139,0)
 ;start saving updates needed after the message is transmitted
"RTN","HLOCLNT",140,0)
 S UPDATE=MSGIEN_"^"_$$NOW^XLFDT
"RTN","HLOCLNT",141,0)
RETRY D
"RTN","HLOCLNT",142,0)
 .S HLCSTATE("ATTEMPT")=HLCSTATE("ATTEMPT")+1
"RTN","HLOCLNT",143,0)
 .I 'HLCSTATE("CONNECTED") D OPEN^HLOT(.HLCSTATE)
"RTN","HLOCLNT",144,0)
 .;
"RTN","HLOCLNT",145,0)
 .;try to send the message
"RTN","HLOCLNT",146,0)
 .Q:'$$WRITEMSG^HLOCLNT1(.HLCSTATE,.HLMSTATE)
"RTN","HLOCLNT",147,0)
 .;does the message need an accept ack?
"RTN","HLOCLNT",148,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" D
"RTN","HLOCLNT",149,0)
 ..N FS
"RTN","HLOCLNT",150,0)
 ..Q:'$$READACK^HLOCLNT1(.HLCSTATE,.HDR,.MSA)
"RTN","HLOCLNT",151,0)
 ..;does the MSA refer to the correct control id?
"RTN","HLOCLNT",152,0)
 ..S FS=$E(HDR(1),4)
"RTN","HLOCLNT",153,0)
 ..Q:$P(MSA,FS,3)'=HLMSTATE("ID")
"RTN","HLOCLNT",154,0)
 ..N ACKID,ACKCODE
"RTN","HLOCLNT",155,0)
 ..S ACKCODE=$P(MSA,FS,2)
"RTN","HLOCLNT",156,0)
 ..S ACKID=$S($E(HDR(1),1,3)="MSH":$P(HDR(2),FS,5),1:$P(HDR(2),FS,6))
"RTN","HLOCLNT",157,0)
 ..S $P(UPDATE,"^",5)=1
"RTN","HLOCLNT",158,0)
 ..S UPDATE("MSA")=ACKID_"^"_MSA
"RTN","HLOCLNT",159,0)
 ..I '(ACKCODE="CA") S $P(UPDATE,"^",3)="SE",$P(UPDATE,"^",4)=2
"RTN","HLOCLNT",160,0)
 ..I ACKCODE="CA",HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=$S(HLMSTATE("BATCH"):"2",1:1)
"RTN","HLOCLNT",161,0)
 ..I ($P(UPDATE,"^",3)="SE") S $P(UPDATE,"^",6)=$P(HLMSTATE("HDR",1),FS,5) ;errors need the application for xref
"RTN","HLOCLNT",162,0)
 ..;
"RTN","HLOCLNT",163,0)
 ..;did the app request notification of accept ack?
"RTN","HLOCLNT",164,0)
 ..S UPDATE("ACTION")=HLMSTATE("ACCEPT ACK RESPONSE")
"RTN","HLOCLNT",165,0)
 ..S SUCCESS=1
"RTN","HLOCLNT",166,0)
 .E  D  ;accept ack wasn't requested
"RTN","HLOCLNT",167,0)
 ..S SUCCESS=1
"RTN","HLOCLNT",168,0)
 ..I HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=$S(HLMSTATE("BATCH"):2,1:1)
"RTN","HLOCLNT",169,0)
 ;
"RTN","HLOCLNT",170,0)
 I 'SUCCESS,'HLCSTATE("CONNECTED"),(HLCSTATE("ATTEMPT")<2) G RETRY
"RTN","HLOCLNT",171,0)
 I SUCCESS D
"RTN","HLOCLNT",172,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOCLNT",173,0)
 .;if this is an ack to a message need to purge the original message, so store its ien with the purge date
"RTN","HLOCLNT",174,0)
 .S:$G(HLMSTATE("ACK TO IEN")) $P(UPDATE,"^",4)=$P(UPDATE,"^",4)_"-"_HLMSTATE("ACK TO IEN")
"RTN","HLOCLNT",175,0)
 I ('HLCSTATE("CONNECTED"))!('SUCCESS) D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",176,0)
 Q SUCCESS
"RTN","HLOCLNT1")
0^2^B28062817^B27548481
"RTN","HLOCLNT1",1,0)
HLOCLNT1 ;IRMFO-ALB/CJM - Writing messages, reading acks;03/24/2004  14:43
"RTN","HLOCLNT1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131**;Oct 13, 1995;Build 10
"RTN","HLOCLNT1",3,0)
 ;
"RTN","HLOCLNT1",4,0)
 ;
"RTN","HLOCLNT1",5,0)
WRITEMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOCLNT1",6,0)
 ;Description:  This function uses the services offered by the transport layer to send a message over an open communication channel.
"RTN","HLOCLNT1",7,0)
 ;
"RTN","HLOCLNT1",8,0)
 ;Input:
"RTN","HLOCLNT1",9,0)
 ;  HLCSTATE (pass by reference, required) Defines the LLP & its state
"RTN","HLOCLNT1",10,0)
 ;  HLMSTATE (pass by reference, required) The message
"RTN","HLOCLNT1",11,0)
 ;Output:
"RTN","HLOCLNT1",12,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT1",13,0)
 ;
"RTN","HLOCLNT1",14,0)
 N SEG,QUIT,HDR
"RTN","HLOCLNT1",15,0)
 S QUIT=0
"RTN","HLOCLNT1",16,0)
 Q:'$G(HLMSTATE("IEN")) 0
"RTN","HLOCLNT1",17,0)
 S HDR(1)=HLMSTATE("HDR",1),HDR(2)=HLMSTATE("HDR",2)
"RTN","HLOCLNT1",18,0)
 Q:'$$WRITEHDR^HLOT(.HLCSTATE,.HDR) 0
"RTN","HLOCLNT1",19,0)
 I HLMSTATE("BATCH") D
"RTN","HLOCLNT1",20,0)
 .N LAST S LAST=0
"RTN","HLOCLNT1",21,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0
"RTN","HLOCLNT1",22,0)
 .F  Q:'$$NEXTMSG^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",23,0)
 ..S LAST=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOCLNT1",24,0)
 ..I '$$WRITESEG^HLOT(.HLCSTATE,.SEG) S QUIT=1 Q
"RTN","HLOCLNT1",25,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",26,0)
 ...I '$$WRITESEG^HLOT(.HLCSTATE,.SEG) S QUIT=1 Q
"RTN","HLOCLNT1",27,0)
 .K SEG S SEG(1)="BTS"_HLMSTATE("HDR","FIELD SEPARATOR")_LAST
"RTN","HLOCLNT1",28,0)
 .S:'$$WRITESEG^HLOT(.HLCSTATE,.SEG) QUIT=1
"RTN","HLOCLNT1",29,0)
 E  D
"RTN","HLOCLNT1",30,0)
 .F  Q:'$$HLNEXT^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",31,0)
 ..S:'$$WRITESEG^HLOT(.HLCSTATE,.SEG) QUIT=1
"RTN","HLOCLNT1",32,0)
 S:'$$ENDMSG^HLOT(.HLCSTATE) QUIT=1
"RTN","HLOCLNT1",33,0)
 Q 'QUIT
"RTN","HLOCLNT1",34,0)
 ;
"RTN","HLOCLNT1",35,0)
READACK(HLCSTATE,HDR,MSA) ;
"RTN","HLOCLNT1",36,0)
 ;Description:  This function uses the services offered by the transport layer to read an accept ack.
"RTN","HLOCLNT1",37,0)
 ;
"RTN","HLOCLNT1",38,0)
 ;Input:
"RTN","HLOCLNT1",39,0)
 ;  HLCSTATE (pass by reference, required) Defines the communication channel and its state.
"RTN","HLOCLNT1",40,0)
 ;Output:
"RTN","HLOCLNT1",41,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT1",42,0)
 ;  HDR (pass by reference) the message header:
"RTN","HLOCLNT1",43,0)
 ;   HDR(1) is components 1-6
"RTN","HLOCLNT1",44,0)
 ;   HDR(2) is components 7-end
"RTN","HLOCLNT1",45,0)
 ;  MSA (pass by reference) the MSA segment as an unsubscripted variable
"RTN","HLOCLNT1",46,0)
 ;
"RTN","HLOCLNT1",47,0)
 N SEG
"RTN","HLOCLNT1",48,0)
 K HDR,MSA,MAX,I
"RTN","HLOCLNT1",49,0)
 S MAX=HLCSTATE("SYSTEM","MAXSTRING")-40 ;MAX is the maximum that can be safely stored on a node, leaving room for the other fields stored with MSA seg
"RTN","HLOCLNT1",50,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.HDR) 0
"RTN","HLOCLNT1",51,0)
 F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOCLNT1",52,0)
 .I $E($E(SEG(1),1,3)_$E($G(SEG(2)),1,3),1,3)="MSA" D
"RTN","HLOCLNT1",53,0)
 ..S MSA=""
"RTN","HLOCLNT1",54,0)
 ..F I=1:1 Q:'$D(SEG(I))  S MSA=MSA_$S((MAX-$L(MSA))<1:"",1:$E(SEG(I),1,MAX))
"RTN","HLOCLNT1",55,0)
 I $D(MSA),HLCSTATE("MESSAGE ENDED") D  Q 1
"RTN","HLOCLNT1",56,0)
 .D SPLITHDR^HLOSRVR1(.HDR)
"RTN","HLOCLNT1",57,0)
 .S HLCSTATE("COUNTS","ACKS")=$G(HLCSTATE("COUNTS","ACKS"))+1
"RTN","HLOCLNT1",58,0)
 Q 0
"RTN","HLOCLNT1",59,0)
 ;
"RTN","HLOCLNT1",60,0)
CONNECT(LINK,PORT,TIMEOUT,HLCSTATE) ;
"RTN","HLOCLNT1",61,0)
 ;sets up HLCSTATE() and opens a client connection
"RTN","HLOCLNT1",62,0)
 ;Input:
"RTN","HLOCLNT1",63,0)
 ;  LINK - name of the link to connect to
"RTN","HLOCLNT1",64,0)
 ;  PORT (optional) port # to connect to, defaults to that specified by the link
"RTN","HLOCLNT1",65,0)
 ;  TIMEOUT (optional) specifies the open timeout in seconds, defaults to 30
"RTN","HLOCLNT1",66,0)
 ;Output:
"RTN","HLOCLNT1",67,0)
 ;   HLCSTATE - array to hold the connection state
"RTN","HLOCLNT1",68,0)
 ;
"RTN","HLOCLNT1",69,0)
 I $G(HLCSTATE("CONNECTED")) D  Q:HLCSTATE("CONNECTED")
"RTN","HLOCLNT1",70,0)
 .I $G(HLCSTATE("LINK","NAME"))]"",($G(HLCSTATE("LINK","NAME"))'=LINK) D CLOSE^HLOT(.HLCSTATE) Q
"RTN","HLOCLNT1",71,0)
 .I $G(HLCSTATE("LINK","NAME"))]"",$G(PORT),($G(HLCSTATE("LINK","PORT"))'=PORT) D CLOSE^HLOT(.HLCSTATE) Q
"RTN","HLOCLNT1",72,0)
 .I (HLCSTATE("SYSTEM","OS")="CACHE") D  Q
"RTN","HLOCLNT1",73,0)
 ..U HLCSTATE("DEVICE") S HLCSTATE("CONNECTED")=($ZA\8192#2)
"RTN","HLOCLNT1",74,0)
 ..I 'HLCSTATE("CONNECTED") D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",75,0)
 .;D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",76,0)
 K HLCSTATE
"RTN","HLOCLNT1",77,0)
 N ARY,NODE
"RTN","HLOCLNT1",78,0)
 I '$$GETLINK^HLOTLNK(LINK,.ARY) S HLCSTATE("LINK","NAME")=LINK,HLCSTATE("LINK","PORT")=$G(PORT) D LINKDOWN^HLOCLNT(.HLCSTATE) Q 0
"RTN","HLOCLNT1",79,0)
 M HLCSTATE("LINK")=ARY
"RTN","HLOCLNT1",80,0)
 I HLCSTATE("LINK","SHUTDOWN") S HLCSTATE("CONNECTED")=0 D LINKDOWN^HLOCLNT(.HLCSTATE) Q 0
"RTN","HLOCLNT1",81,0)
 ;overlay the port if supplied from the queue
"RTN","HLOCLNT1",82,0)
 S:$G(PORT) HLCSTATE("LINK","PORT")=PORT
"RTN","HLOCLNT1",83,0)
 S HLCSTATE("READ TIMEOUT")=20
"RTN","HLOCLNT1",84,0)
 S HLCSTATE("OPEN TIMEOUT")=$S($G(TIMEOUT):TIMEOUT,1:30)
"RTN","HLOCLNT1",85,0)
 S HLCSTATE("COUNTS")=0
"RTN","HLOCLNT1",86,0)
 S HLCSTATE("READ")="" ;where the reads are stored
"RTN","HLOCLNT1",87,0)
 ;
"RTN","HLOCLNT1",88,0)
 ;HLCSTATE("BUFFER",<seg>,<line>) serves as a write buffer so that a lot can be written all at once
"RTN","HLOCLNT1",89,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of BYTES in buffer
"RTN","HLOCLNT1",90,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOCLNT1",91,0)
 ;
"RTN","HLOCLNT1",92,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOCLNT1",93,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOCLNT1",94,0)
 S HLCSTATE("SERVER")=0
"RTN","HLOCLNT1",95,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOCLNT1",96,0)
 I HLCSTATE("SYSTEM","OS")="" D LINKDOWN^HLOCLNT(.HLCSTATE) Q 0
"RTN","HLOCLNT1",97,0)
 D
"RTN","HLOCLNT1",98,0)
 .N SYS
"RTN","HLOCLNT1",99,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOCLNT1",100,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOCLNT1",101,0)
 .S HLCSTATE("SYSTEM","MAXSTRING")=SYS("MAXSTRING")
"RTN","HLOCLNT1",102,0)
 .S HLCSTATE("SYSTEM","NORMAL PURGE")=SYS("NORMAL PURGE")
"RTN","HLOCLNT1",103,0)
 .S HLCSTATE("SYSTEM","ERROR PURGE")=SYS("ERROR PURGE")
"RTN","HLOCLNT1",104,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOCLNT1",105,0)
 .S HLCSTATE("OPEN")="OPEN^HLOTCP"
"RTN","HLOCLNT1",106,0)
 E  ;no other LLP implemented
"RTN","HLOCLNT1",107,0)
 D OPEN^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",108,0)
 ;
"RTN","HLOCLNT1",109,0)
 ;mark the failure time for the link so other processes know not to try for a while
"RTN","HLOCLNT1",110,0)
 I 'HLCSTATE("CONNECTED") D LINKDOWN^HLOCLNT(.HLCSTATE)
"RTN","HLOCLNT1",111,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOCLNT1",112,0)
 ;
"RTN","HLOCLNT1",113,0)
BADMSGS(WORK) ;
"RTN","HLOCLNT1",114,0)
 ;finds messages that won't transmit and takes them off the outgoing queue
"RTN","HLOCLNT1",115,0)
 N LINK
"RTN","HLOCLNT1",116,0)
 S LINK=""
"RTN","HLOCLNT1",117,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D
"RTN","HLOCLNT1",118,0)
 .N TIME,QUE,COUNT
"RTN","HLOCLNT1",119,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOCLNT1",120,0)
 .Q:$$HDIFF^XLFDT($H,TIME,2)<7200
"RTN","HLOCLNT1",121,0)
 .Q:'$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOCLNT1",122,0)
 .L +^HLB("QUEUE","OUT",LINK):0
"RTN","HLOCLNT1",123,0)
 .S QUE=""
"RTN","HLOCLNT1",124,0)
 .F  S QUE=$O(^HLB("QUEUE","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOCLNT1",125,0)
 ..N MSG S MSG=0
"RTN","HLOCLNT1",126,0)
 ..S MSG=$O(^HLB("QUEUE","OUT",LINK,QUE,MSG))
"RTN","HLOCLNT1",127,0)
 ..Q:'MSG
"RTN","HLOCLNT1",128,0)
 ..S COUNT=$G(^HLB(MSG,"TRIES"))
"RTN","HLOCLNT1",129,0)
 ..I COUNT>20 D
"RTN","HLOCLNT1",130,0)
 ...N NODE,TIME,APP,FS,ACTION
"RTN","HLOCLNT1",131,0)
 ...S NODE=$G(^HLB(MSG,0))
"RTN","HLOCLNT1",132,0)
 ...Q:'$P(NODE,"^",2)
"RTN","HLOCLNT1",133,0)
 ...S TIME=+$G(^HLA($P(NODE,"^",2),0))
"RTN","HLOCLNT1",134,0)
 ...S NODE=$G(^HLB(MSG,1))
"RTN","HLOCLNT1",135,0)
 ...S FS=$E(NODE,4)
"RTN","HLOCLNT1",136,0)
 ...Q:FS=""
"RTN","HLOCLNT1",137,0)
 ...S APP=$P(NODE,FS,3)
"RTN","HLOCLNT1",138,0)
 ...Q:APP=""
"RTN","HLOCLNT1",139,0)
 ...S $P(^HLB(MSG,0),"^",21)=COUNT_" FAILED TRANSMISSIONS"
"RTN","HLOCLNT1",140,0)
 ...S $P(^HLB(MSG,0),"^",20)="TF"
"RTN","HLOCLNT1",141,0)
 ...S ^HLB("ERRORS","TF",APP,TIME,MSG)=""
"RTN","HLOCLNT1",142,0)
 ...S ACTION=$P(NODE,"^",14,15)
"RTN","HLOCLNT1",143,0)
 ...I ACTION'="^",ACTION]"" D INQUE^HLOQUE(LINK,QUE,MSG,ACTION,1)
"RTN","HLOCLNT1",144,0)
 ...D DEQUE^HLOQUE(LINK,QUE,"OUT",MSG)
"RTN","HLOCLNT1",145,0)
 .L -^HLB("QUEUE","OUT",LINK)
"RTN","HLOCLNT1",146,0)
 Q
"RTN","HLOCLNT2")
0^3^B30513205^B23345410
"RTN","HLOCLNT2",1,0)
HLOCLNT2 ;ALB/CJM- Performs message updates for the client - 10/4/94 1pm
"RTN","HLOCLNT2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131**;Oct 13, 1995;Build 10
"RTN","HLOCLNT2",3,0)
 ;
"RTN","HLOCLNT2",4,0)
GETWORK(WORK) ;
"RTN","HLOCLNT2",5,0)
 ;
"RTN","HLOCLNT2",6,0)
 N OLD,DOLLARJ,SUCCESS,NOW
"RTN","HLOCLNT2",7,0)
 S SUCCESS=0
"RTN","HLOCLNT2",8,0)
 S NOW=$$NOW^XLFDT
"RTN","HLOCLNT2",9,0)
 S (OLD,DOLLARJ)=$G(WORK("DOLLARJ"))
"RTN","HLOCLNT2",10,0)
 F  S DOLLARJ=$O(^HLTMP("CLIENT UPDATES",DOLLARJ)) Q:DOLLARJ=""  D  Q:SUCCESS
"RTN","HLOCLNT2",11,0)
 .L +^HLTMP("CLIENT UPDATES",DOLLARJ):0
"RTN","HLOCLNT2",12,0)
 .Q:'$T
"RTN","HLOCLNT2",13,0)
 .N TIME S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,""))
"RTN","HLOCLNT2",14,0)
 .I $$FMDIFF^XLFDT(NOW,TIME,2)<2 L -^HLTMP("CLIENT UPDATES",DOLLARJ) Q
"RTN","HLOCLNT2",15,0)
 .S SUCCESS=1
"RTN","HLOCLNT2",16,0)
 ;
"RTN","HLOCLNT2",17,0)
 I OLD'="",'SUCCESS F  S DOLLARJ=$O(^HLTMP("CLIENT UPDATES",DOLLARJ)) Q:DOLLARJ=""  Q:DOLLARJ>OLD  D  Q:SUCCESS
"RTN","HLOCLNT2",18,0)
 .L +^HLTMP("CLIENT UPDATES",DOLLARJ):0
"RTN","HLOCLNT2",19,0)
 .Q:'$T
"RTN","HLOCLNT2",20,0)
 .N TIME S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,""))
"RTN","HLOCLNT2",21,0)
 .I $$FMDIFF^XLFDT(NOW,TIME,2)<2 L -^HLTMP("CLIENT UPDATES",DOLLARJ) Q
"RTN","HLOCLNT2",22,0)
 .S SUCCESS=1
"RTN","HLOCLNT2",23,0)
 S WORK("DOLLARJ")=DOLLARJ,WORK("NOW")=NOW
"RTN","HLOCLNT2",24,0)
 Q $S($L(WORK("DOLLARJ")):1,1:0)
"RTN","HLOCLNT2",25,0)
 ;
"RTN","HLOCLNT2",26,0)
DOWORK(WORK) ;
"RTN","HLOCLNT2",27,0)
 ;
"RTN","HLOCLNT2",28,0)
 N DOLLARJ,TIME,IEN,PARMS,SYSTEM
"RTN","HLOCLNT2",29,0)
 S TIME=""
"RTN","HLOCLNT2",30,0)
 S DOLLARJ=WORK("DOLLARJ")
"RTN","HLOCLNT2",31,0)
 D SYSPARMS^HLOSITE(.SYSTEM)
"RTN","HLOCLNT2",32,0)
 F  S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME)) Q:TIME=""  Q:$$FMDIFF^XLFDT(WORK("NOW"),TIME,2)<2  D
"RTN","HLOCLNT2",33,0)
 .S IEN=0
"RTN","HLOCLNT2",34,0)
 .F  S IEN=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN)) Q:'IEN  D
"RTN","HLOCLNT2",35,0)
 ..N NODE
"RTN","HLOCLNT2",36,0)
 ..S NODE=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN))
"RTN","HLOCLNT2",37,0)
 ..S PARMS("LINK")=$P(NODE,"^")
"RTN","HLOCLNT2",38,0)
 ..S PARMS("QUEUE")=$P(NODE,"^",2)
"RTN","HLOCLNT2",39,0)
 ..S PARMS("STATUS")=$P(NODE,"^",3)
"RTN","HLOCLNT2",40,0)
 ..S PARMS("PURGE TYPE")=$P(NODE,"^",4)
"RTN","HLOCLNT2",41,0)
 ..S PARMS("ACK TO IEN")=+$P($P(NODE,"^",4),"-",2)
"RTN","HLOCLNT2",42,0)
 ..S PARMS("ACCEPT ACK")=$P(NODE,"^",5)
"RTN","HLOCLNT2",43,0)
 ..S PARMS("RECEIVING APP")=$P(NODE,"^",6)
"RTN","HLOCLNT2",44,0)
 ..S:PARMS("RECEIVING APP")="" PARMS("RECEIVING APP")="UNKNOWN RECEIVING APPLICATION"
"RTN","HLOCLNT2",45,0)
 ..S PARMS("MSA")=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN,"MSA"))
"RTN","HLOCLNT2",46,0)
 ..S PARMS("ACTION")=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN,"ACTION"))
"RTN","HLOCLNT2",47,0)
 ..D UPDATE(IEN,TIME,.PARMS)
"RTN","HLOCLNT2",48,0)
 ..K ^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN)
"RTN","HLOCLNT2",49,0)
 L -^HLTMP("CLIENT UPDATES",DOLLARJ)
"RTN","HLOCLNT2",50,0)
 Q
"RTN","HLOCLNT2",51,0)
 ;
"RTN","HLOCLNT2",52,0)
UPDATE(MSGIEN,TIME,PARMS) ;
"RTN","HLOCLNT2",53,0)
 S:PARMS("STATUS")]"" $P(^HLB(MSGIEN,0),"^",20)=PARMS("STATUS")
"RTN","HLOCLNT2",54,0)
 S:PARMS("STATUS")="SE" ^HLB("ERRORS","SE",PARMS("RECEIVING APP"),TIME,MSGIEN)=""
"RTN","HLOCLNT2",55,0)
 S:PARMS("STATUS")="AE" ^HLB("ERRORS","AE",PARMS("RECEIVING APP"),TIME,MSGIEN_"^")=""
"RTN","HLOCLNT2",56,0)
 S:PARMS("ACCEPT ACK") $P(^HLB(MSGIEN,0),"^",17)=PARMS("ACCEPT ACK")
"RTN","HLOCLNT2",57,0)
 S $P(^HLB(MSGIEN,0),"^",16)=TIME
"RTN","HLOCLNT2",58,0)
 S:PARMS("MSA")]"" ^HLB(MSGIEN,4)=TIME_"^"_PARMS("MSA")
"RTN","HLOCLNT2",59,0)
 I PARMS("PURGE TYPE"),PARMS("ACTION")="" D
"RTN","HLOCLNT2",60,0)
 .;don't set purge if going on the infiler - let infiler do it
"RTN","HLOCLNT2",61,0)
 .N PTIME
"RTN","HLOCLNT2",62,0)
 .S:(PARMS("PURGE TYPE")=2) PTIME=$$FMADD^XLFDT(TIME,SYSTEM("ERROR PURGE")) ;error purge is in days
"RTN","HLOCLNT2",63,0)
 .S:(PARMS("PURGE TYPE")'=2) PTIME=$$FMADD^XLFDT(TIME,,SYSTEM("NORMAL PURGE")) ;normal purge is in hours
"RTN","HLOCLNT2",64,0)
 .S $P(^HLB(MSGIEN,0),"^",9)=PTIME,^HLB("AD","OUT",PTIME,MSGIEN)=""
"RTN","HLOCLNT2",65,0)
 .I PARMS("ACK TO IEN"),$D(^HLB(PARMS("ACK TO IEN"),0)) S $P(^HLB(PARMS("ACK TO IEN"),0),"^",9)=PTIME,^HLB("AD","OUT",PTIME,PARMS("ACK TO IEN"))=""
"RTN","HLOCLNT2",66,0)
 D:PARMS("ACTION")]""
"RTN","HLOCLNT2",67,0)
 .N PURGE
"RTN","HLOCLNT2",68,0)
 .S PURGE=$S(PARMS("PURGE TYPE"):1,1:0)
"RTN","HLOCLNT2",69,0)
 .S:PARMS("ACK TO IEN") PURGE("ACKTOIEN")=PARMS("ACK TO IEN")
"RTN","HLOCLNT2",70,0)
 .D INQUE^HLOQUE(PARMS("LINK"),PARMS("QUEUE"),MSGIEN,PARMS("ACTION"),.PURGE)
"RTN","HLOCLNT2",71,0)
 Q
"RTN","HLOCLNT2",72,0)
 ;
"RTN","HLOCLNT2",73,0)
GETMSG(IEN,MSG) ;
"RTN","HLOCLNT2",74,0)
 ;
"RTN","HLOCLNT2",75,0)
 ;Description: given the message ien=MSGIEN (required), it returns the MSG array containing information about the message, defined below.
"RTN","HLOCLNT2",76,0)
 ;Input:
"RTN","HLOCLNT2",77,0)
 ;  IEN - the ien of the message in file 778
"RTN","HLOCLNT2",78,0)
 ;Output:
"RTN","HLOCLNT2",79,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT2",80,0)
 ;  MSG (pass by reference, required) These are the subscripts returned:
"RTN","HLOCLNT2",81,0)
 ;    "ACCEPT ACK RESPONSE" - if the sending app requested notification of the accept ack, this is the routine to perform
"RTN","HLOCLNT2",82,0)
 ;    "ACKTOIEN" - if this is an app ack to a message not in a batch, this is the ien of the original message
"RTN","HLOCLNT2",83,0)
 ;    "BATCH"  = 1 if this is a batch message, 0  if not
"RTN","HLOCLNT2",84,0)
 ;    "CURRENT MESSAGE" - defined only for batch messages -  a counterused during building and parsing messages to indicate the current message.  It will be set to 0 initially.
"RTN","HLOCLNT2",85,0)
 ;    "BODY" - ptr to file 778 which contains the body of the message.
"RTN","HLOCLNT2",86,0)
 ;    "LINE COUNT" -  a counter used during writing of the
"RTN","HLOCLNT2",87,0)
 ;     messages to indicate the current line. For
"RTN","HLOCLNT2",88,0)
 ;     batch messages where each message within the batch is stored
"RTN","HLOCLNT2",89,0)
 ;     separately, this field indicates the position within the current
"RTN","HLOCLNT2",90,0)
 ;     individual message
"RTN","HLOCLNT2",91,0)
 ;    "HDR" at these lower subscripts:
"RTN","HLOCLNT2",92,0)
 ;       1    - components 1-6
"RTN","HLOCLNT2",93,0)
 ;       2    - components 7-end
"RTN","HLOCLNT2",94,0)
 ;       "ACCEPT ACK TYPE" = "AL" or "NE"
"RTN","HLOCLNT2",95,0)
 ;       "APP ACK TYPE" = "AL" or "NE"
"RTN","HLOCLNT2",96,0)
 ;       "MESSAGE CONTROL ID" - defined if NOT batch
"RTN","HLOCLNT2",97,0)
 ;       "BATCH CONTROL ID" - defined if batch
"RTN","HLOCLNT2",98,0)
 ;
"RTN","HLOCLNT2",99,0)
 ;    "ID" - message id from the header
"RTN","HLOCLNT2",100,0)
 ;    "IEN" - ien, file 778
"RTN","HLOCLNT2",101,0)
 ;
"RTN","HLOCLNT2",102,0)
 K MSG
"RTN","HLOCLNT2",103,0)
 Q:'$G(IEN) 0
"RTN","HLOCLNT2",104,0)
 N NODE,FS,CS,REP,SUBCOMP,ESCAPE
"RTN","HLOCLNT2",105,0)
 S MSG("IEN")=IEN
"RTN","HLOCLNT2",106,0)
 S NODE=$G(^HLB(IEN,0))
"RTN","HLOCLNT2",107,0)
 S MSG("BODY")=$P(NODE,"^",2)
"RTN","HLOCLNT2",108,0)
 Q:'MSG("BODY") 0
"RTN","HLOCLNT2",109,0)
 S MSG("STATUS","ACCEPTED")=$P(NODE,"^",17)
"RTN","HLOCLNT2",110,0)
 S MSG("DT/TM")=$P(NODE,"^",16)
"RTN","HLOCLNT2",111,0)
 S MSG("STATUS","QUEUE")=$P(NODE,"^",6)
"RTN","HLOCLNT2",112,0)
 I MSG("STATUS","QUEUE")="" S MSG("STATUS","QUEUE")="DEFAULT"
"RTN","HLOCLNT2",113,0)
 S MSG("ACCEPT ACK RESPONSE")=$P(NODE,"^",12,13)
"RTN","HLOCLNT2",114,0)
 I MSG("ACCEPT ACK RESPONSE")="^" S MSG("ACCEPT ACK RESPONSE")=""
"RTN","HLOCLNT2",115,0)
 ;
"RTN","HLOCLNT2",116,0)
 S MSG("BATCH")=+$P($G(^HLA(MSG("BODY"),0)),"^",2)
"RTN","HLOCLNT2",117,0)
 I MSG("BATCH") D
"RTN","HLOCLNT2",118,0)
 .S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOCLNT2",119,0)
 E  D
"RTN","HLOCLNT2",120,0)
 .N ACKTO
"RTN","HLOCLNT2",121,0)
 .S ACKTO=$P(NODE,"^",3)
"RTN","HLOCLNT2",122,0)
 .I ACKTO]"" S ACKTO=$$ACKTOIEN^HLOMSG1(MSG("ID"),ACKTO)
"RTN","HLOCLNT2",123,0)
 .I ACKTO,+ACKTO=ACKTO S MSG("ACK TO IEN")=ACKTO
"RTN","HLOCLNT2",124,0)
 S MSG("LINE COUNT")=0
"RTN","HLOCLNT2",125,0)
 S MSG("HDR",1)=$G(^HLB(IEN,1))
"RTN","HLOCLNT2",126,0)
 S MSG("HDR",2)=$G(^HLB(IEN,2))
"RTN","HLOCLNT2",127,0)
 S FS=$E(MSG("HDR",1),4)
"RTN","HLOCLNT2",128,0)
 S CS=$E(MSG("HDR",1),5)
"RTN","HLOCLNT2",129,0)
 S REP=$E(MSG("HDR",1),6)
"RTN","HLOCLNT2",130,0)
 S ESCAPE=$E(MSG("HDR",1),7)
"RTN","HLOCLNT2",131,0)
 S SUBCOMP=$E(MSG("HDR",1),8)
"RTN","HLOCLNT2",132,0)
 S MSG("HDR","FIELD SEPARATOR")=FS
"RTN","HLOCLNT2",133,0)
 S MSG("HDR","SENDING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(MSG("HDR",1),FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOCLNT2",134,0)
 S MSG("HDR","RECEIVING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(MSG("HDR",1),FS,5),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOCLNT2",135,0)
 I 'MSG("BATCH") D
"RTN","HLOCLNT2",136,0)
 .S MSG("HDR","MESSAGE TYPE")=$P($P(MSG("HDR",2),FS,4),CS)
"RTN","HLOCLNT2",137,0)
 .S MSG("HDR","EVENT")=$P($P(MSG("HDR",2),FS,4),CS,2)
"RTN","HLOCLNT2",138,0)
 .S MSG("HDR","ACCEPT ACK TYPE")=$E($P(MSG("HDR",2),FS,10),1,2)
"RTN","HLOCLNT2",139,0)
 .S MSG("HDR","APP ACK TYPE")=$E($P(MSG("HDR",2),FS,11),1,2)
"RTN","HLOCLNT2",140,0)
 .S MSG("HDR","MESSAGE CONTROL ID")=$P(MSG("HDR",2),FS,5)
"RTN","HLOCLNT2",141,0)
 .S MSG("ID")=MSG("HDR","MESSAGE CONTROL ID")
"RTN","HLOCLNT2",142,0)
 E  D
"RTN","HLOCLNT2",143,0)
 .S MSG("HDR","BATCH CONTROL ID")=$P(MSG("HDR",2),FS,6)
"RTN","HLOCLNT2",144,0)
 .S MSG("ID")=MSG("HDR","BATCH CONTROL ID")
"RTN","HLOCLNT2",145,0)
 .S MSG("HDR","ACCEPT ACK TYPE")=$E($P($P(MSG("HDR",2),FS,4),"ACCEPT ACK TYPE=",2),1,2)
"RTN","HLOCLNT2",146,0)
 .S MSG("HDR","APP ACK TYPE")=$E($P($P(MSG("HDR",2),FS,4),"APP ACK TYPE=",2),1,2)
"RTN","HLOCLNT2",147,0)
 Q 1
"RTN","HLOFILER")
0^15^B25709739^B18562276
"RTN","HLOFILER",1,0)
HLOFILER ;ALB/CJM- Passes messages on the incoming queue to the applications - 10/4/94 1pm
"RTN","HLOFILER",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131**;Oct 13, 1995;Build 10
"RTN","HLOFILER",3,0)
 ;
"RTN","HLOFILER",4,0)
 ;GET WORK function for the process running under the Process Manager
"RTN","HLOFILER",5,0)
GETWORK(QUE) ;
"RTN","HLOFILER",6,0)
 ;Input:
"RTN","HLOFILER",7,0)
 ;  QUE - (pass by reference) These subscripts are used:
"RTN","HLOFILER",8,0)
 ;    ("FROM") - sending facility last obtained
"RTN","HLOFILER",9,0)
 ;    ("QUEUE") - name of the queue last obtained
"RTN","HLOFILER",10,0)
 ;Output:
"RTN","HLOFILER",11,0)
 ;  Function returns 1 if success, 0 if no more work
"RTN","HLOFILER",12,0)
 ;  QUE-  updated to identify next queu of messages to process.
"RTN","HLOFILER",13,0)
 ;
"RTN","HLOFILER",14,0)
 N FROM,QUEUE
"RTN","HLOFILER",15,0)
 I '$D(QUE("SYSTEM")) D
"RTN","HLOFILER",16,0)
 .N SYS
"RTN","HLOFILER",17,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOFILER",18,0)
 .S QUE("SYSTEM","NORMAL PURGE")=SYS("NORMAL PURGE")
"RTN","HLOFILER",19,0)
 .S QUE("SYSTEM","ERROR PURGE")=SYS("ERROR PURGE")
"RTN","HLOFILER",20,0)
 S FROM=$G(QUE("FROM")),QUEUE=$G(QUE("QUEUE"))
"RTN","HLOFILER",21,0)
 I ($G(FROM)]""),($G(QUEUE)]"") D
"RTN","HLOFILER",22,0)
 .L -^HLB("QUEUE","IN",FROM,QUEUE)
"RTN","HLOFILER",23,0)
 .F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0  Q:$T
"RTN","HLOFILER",24,0)
 I ($G(FROM)]""),($G(QUEUE)="") D
"RTN","HLOFILER",25,0)
 .F  S FROM=$O(^HLB("QUEUE","IN",FROM)) Q:FROM=""  D  Q:($G(QUEUE)]"")
"RTN","HLOFILER",26,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0 Q:$T
"RTN","HLOFILER",27,0)
 I FROM="" D
"RTN","HLOFILER",28,0)
 .F  S FROM=$O(^HLB("QUEUE","IN",FROM)) Q:FROM=""  D  Q:($G(QUEUE)]"")
"RTN","HLOFILER",29,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0 Q:$T
"RTN","HLOFILER",30,0)
 S QUE("FROM")=FROM,QUE("QUEUE")=QUEUE
"RTN","HLOFILER",31,0)
 Q:(QUEUE]"") 1
"RTN","HLOFILER",32,0)
 Q 0
"RTN","HLOFILER",33,0)
 ;
"RTN","HLOFILER",34,0)
DOWORK(QUEUE) ;sends the messages on the queue
"RTN","HLOFILER",35,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOFILER"
"RTN","HLOFILER",36,0)
 ;
"RTN","HLOFILER",37,0)
 N MSGIEN,DEQUE,QUE
"RTN","HLOFILER",38,0)
 M QUE=QUEUE
"RTN","HLOFILER",39,0)
 S DEQUE=0
"RTN","HLOFILER",40,0)
 S MSGIEN=0
"RTN","HLOFILER",41,0)
 ;
"RTN","HLOFILER",42,0)
 F  S MSGIEN=$O(^HLB("QUEUE","IN",QUEUE("FROM"),QUEUE("QUEUE"),MSGIEN)) Q:'MSGIEN  D  M QUEUE=QUE
"RTN","HLOFILER",43,0)
 .N MCODE,ACTION,QUE,PURGE,ACKTOIEN,NODE
"RTN","HLOFILER",44,0)
 .N $ETRAP,$ESTACK S $ETRAP="G ERROR2^HLOFILER"
"RTN","HLOFILER",45,0)
 .S NODE=$G(^HLB("QUEUE","IN",QUEUE("FROM"),QUEUE("QUEUE"),MSGIEN))
"RTN","HLOFILER",46,0)
 .S ACTION=$P(NODE,"^",1,2)
"RTN","HLOFILER",47,0)
 .S PURGE=$P(NODE,"^",3)
"RTN","HLOFILER",48,0)
 .S ACKTOIEN=$P(NODE,"^",4)
"RTN","HLOFILER",49,0)
 .D DEQUE(MSGIEN,PURGE,ACKTOIEN)
"RTN","HLOFILER",50,0)
 .I ACTION]"" D
"RTN","HLOFILER",51,0)
 ..N HLMSGIEN,MCODE,DEQUE,DUZ
"RTN","HLOFILER",52,0)
 ..N $ETRAP,$ESTACK S $ETRAP="G ERROR3^HLOFILER"
"RTN","HLOFILER",53,0)
 ..S HLMSGIEN=MSGIEN
"RTN","HLOFILER",54,0)
 ..S MCODE="D "_ACTION
"RTN","HLOFILER",55,0)
 ..N MSGIEN,X
"RTN","HLOFILER",56,0)
 ..D DUZ^XUP(.5)
"RTN","HLOFILER",57,0)
 ..X MCODE
"RTN","HLOFILER",58,0)
 ..;kill the apps variables
"RTN","HLOFILER",59,0)
 ..D
"RTN","HLOFILER",60,0)
 ...N ZTSK
"RTN","HLOFILER",61,0)
 ...D KILL^XUSCLEAN
"RTN","HLOFILER",62,0)
 ;
"RTN","HLOFILER",63,0)
ENDWORK ;where the execution resumes upon an error
"RTN","HLOFILER",64,0)
 D DEQUE()
"RTN","HLOFILER",65,0)
 Q
"RTN","HLOFILER",66,0)
 ;
"RTN","HLOFILER",67,0)
DEQUE(MSGIEN,PURGE,ACKTOIEN) ;
"RTN","HLOFILER",68,0)
 ;Dequeues the message.  Also sets up the purge dt/tm and the completion status.
"RTN","HLOFILER",69,0)
 S:$G(MSGIEN) DEQUE=$G(DEQUE)+1,DEQUE(MSGIEN)=PURGE_"^"_ACKTOIEN
"RTN","HLOFILER",70,0)
 I '$G(MSGIEN)!(DEQUE>25) S MSGIEN=0 D
"RTN","HLOFILER",71,0)
 .F  S MSGIEN=$O(DEQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOFILER",72,0)
 ..N NODE,PURGE,ACKTOIEN
"RTN","HLOFILER",73,0)
 ..S NODE=DEQUE(MSGIEN)
"RTN","HLOFILER",74,0)
 ..S PURGE=$P(NODE,"^"),ACKTOIEN=$P(NODE,"^",2)
"RTN","HLOFILER",75,0)
 ..D DEQUE^HLOQUE(QUEUE("FROM"),QUEUE("QUEUE"),"IN",MSGIEN)
"RTN","HLOFILER",76,0)
 ..S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOFILER",77,0)
 ..Q:NODE=""
"RTN","HLOFILER",78,0)
 ..S $P(NODE,"^",19)=1 ;sets the flag to show that the app handoff was done
"RTN","HLOFILER",79,0)
 ..D:PURGE
"RTN","HLOFILER",80,0)
 ...N STATUS
"RTN","HLOFILER",81,0)
 ...S STATUS=$P(NODE,"^",20)
"RTN","HLOFILER",82,0)
 ...S:STATUS="" $P(NODE,"^",20)="SU",STATUS="SU"
"RTN","HLOFILER",83,0)
 ...S $P(NODE,"^",9)=$$FMADD^XLFDT($$NOW^XLFDT,,$S(STATUS'="SU":24*QUEUE("SYSTEM","ERROR PURGE"),$D(^HLB(MSGIEN,3,1,0)):24*QUEUE("SYSTEM","ERROR PURGE"),1:QUEUE("SYSTEM","NORMAL PURGE")))
"RTN","HLOFILER",84,0)
 ...S ^HLB("AD",$S($E($P(NODE,"^",4))="I":"IN",1:"OUT"),$P(NODE,"^",9),MSGIEN)=""
"RTN","HLOFILER",85,0)
 ...I ACKTOIEN,$D(^HLB(ACKTOIEN,0)) S $P(^HLB(ACKTOIEN,0),"^",9)=$P(NODE,"^",9),^HLB("AD",$S($E($P(NODE,"^",4))="I":"OUT",1:"IN"),$P(NODE,"^",9),ACKTOIEN)=""
"RTN","HLOFILER",86,0)
 ..S ^HLB(MSGIEN,0)=NODE
"RTN","HLOFILER",87,0)
 .K DEQUE S DEQUE=0
"RTN","HLOFILER",88,0)
 Q
"RTN","HLOFILER",89,0)
 ;
"RTN","HLOFILER",90,0)
ERROR ;error trap
"RTN","HLOFILER",91,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOFILER",92,0)
 ;
"RTN","HLOFILER",93,0)
 D DEQUE()
"RTN","HLOFILER",94,0)
 ;
"RTN","HLOFILER",95,0)
 ;a lot of errors of the same type may indicate an endless loop, so keep  a count
"RTN","HLOFILER",96,0)
 S ^TMP("HL7 ERRORS",$J,$ECODE)=$G(^TMP("HL7 ERRORS",$J,$ECODE))+1
"RTN","HLOFILER",97,0)
 Q:($G(^TMP("HL7 ERRORS",$J,$ECODE))>100)  ;return to the Process Manager error trap
"RTN","HLOFILER",98,0)
 ;
"RTN","HLOFILER",99,0)
 ;while debugging quit on all errors - returns to the Process Manager error trap
"RTN","HLOFILER",100,0)
 I $G(^HLTMP("LOG ALL ERRORS")) QUIT
"RTN","HLOFILER",101,0)
 ;
"RTN","HLOFILER",102,0)
 D ^%ZTER
"RTN","HLOFILER",103,0)
 D UNWIND^%ZTER
"RTN","HLOFILER",104,0)
 Q
"RTN","HLOFILER",105,0)
 ;
"RTN","HLOFILER",106,0)
ERROR2 ;
"RTN","HLOFILER",107,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOFILER",108,0)
 ;
"RTN","HLOFILER",109,0)
 D DEQUE()
"RTN","HLOFILER",110,0)
 ;
"RTN","HLOFILER",111,0)
 ;may need to change the status to Application Error
"RTN","HLOFILER",112,0)
 D
"RTN","HLOFILER",113,0)
 .N NODE,RAPP,FS,CS,HDR,TIME
"RTN","HLOFILER",114,0)
 .S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOFILER",115,0)
 .Q:NODE=""
"RTN","HLOFILER",116,0)
 .Q:$P(NODE,"^",20)="AE"
"RTN","HLOFILER",117,0)
 .S $P(NODE,"^",20)="AE",$P(NODE,"^",21)="APPLICATION ROUTINE ERROR"
"RTN","HLOFILER",118,0)
 .I $P(NODE,"^",9) K ^HLB("AD",$S($E($P(NODE,"^",4))="I":"IN",1:"OUT"),$P(NODE,"^",9),MSGIEN)
"RTN","HLOFILER",119,0)
 .S $P(NODE,"^",9)=$$FMADD^XLFDT($$NOW^XLFDT,,24*QUEUE("SYSTEM","ERROR PURGE"))
"RTN","HLOFILER",120,0)
 .S ^HLB(MSGIEN,0)=NODE
"RTN","HLOFILER",121,0)
 .S ^HLB("AD",$S($E($P(NODE,"^",4))="I":"IN",1:"OUT"),$P(NODE,"^",9),MSGIEN)=""
"RTN","HLOFILER",122,0)
 .I $P(NODE,"^",2) S TIME=+$G(^HLA($P(NODE,"^",2),0))
"RTN","HLOFILER",123,0)
 .Q:'$G(TIME)
"RTN","HLOFILER",124,0)
 .S HDR=$G(^HLB(MSGIEN,1))
"RTN","HLOFILER",125,0)
 .S FS=$E(HDR,4)
"RTN","HLOFILER",126,0)
 .Q:FS=""
"RTN","HLOFILER",127,0)
 .S CS=$E(HDR,5)
"RTN","HLOFILER",128,0)
 .S RAPP=$P($P(HDR,FS,5),CS)
"RTN","HLOFILER",129,0)
 .I RAPP="" S RAPP="UNKNOWN"
"RTN","HLOFILER",130,0)
 .S ^HLB("ERRORS","AE",RAPP,TIME,MSGIEN)=""
"RTN","HLOFILER",131,0)
 ;
"RTN","HLOFILER",132,0)
 ;kill the apps variables
"RTN","HLOFILER",133,0)
 D
"RTN","HLOFILER",134,0)
 .N ZTSK,MSGIEN,QUEUE
"RTN","HLOFILER",135,0)
 .D KILL^XUSCLEAN
"RTN","HLOFILER",136,0)
 ;
"RTN","HLOFILER",137,0)
 ;release all the locks the app may have set, except Taskman lock
"RTN","HLOFILER",138,0)
 L:$D(ZTSK) ^%ZTSCH("TASK",ZTSK):1
"RTN","HLOFILER",139,0)
 L:'$D(ZTSK)
"RTN","HLOFILER",140,0)
 ;reset HLO's lock
"RTN","HLOFILER",141,0)
 L +^HLTMP("HL7 RUNNING PROCESSES",$J):0
"RTN","HLOFILER",142,0)
 ;return to processing the next message on the queue
"RTN","HLOFILER",143,0)
 S $ECODE=""
"RTN","HLOFILER",144,0)
 ;
"RTN","HLOFILER",145,0)
 Q
"RTN","HLOFILER",146,0)
ERROR3 ;error trap for application context
"RTN","HLOFILER",147,0)
 S $ETRAP="Q $ESTACK"
"RTN","HLOFILER",148,0)
 D ^%ZTER
"RTN","HLOFILER",149,0)
 S $ECODE=",UAPPLICATION ERROR,"
"RTN","HLOFILER",150,0)
 ;
"RTN","HLOFILER",151,0)
 ;drop to the ERROR2 error handler
"RTN","HLOFILER",152,0)
 Q
"RTN","HLOPRS1")
0^14^B19358044^B13347617
"RTN","HLOPRS1",1,0)
HLOPRS1 ;IRMFO-ALB/CJM -RTNs for parsing messages (continued);03/24/2004  14:43
"RTN","HLOPRS1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**118,131**;Oct 13, 1995;Build 10
"RTN","HLOPRS1",3,0)
 ;
"RTN","HLOPRS1",4,0)
PARSE(FIELD,REP,COMP,SUBCOMP,ESCAPE,SEG,TO) ;
"RTN","HLOPRS1",5,0)
 ;Parses the segment stored in SEG(1),SEG(2),... into TO()
"RTN","HLOPRS1",6,0)
 ;Input:
"RTN","HLOPRS1",7,0)
 ;  FIELD - field separator
"RTN","HLOPRS1",8,0)
 ;  REP - field repetition separator
"RTN","HLOPRS1",9,0)
 ;  COMP - component separator
"RTN","HLOPRS1",10,0)
 ;  SUBCOMP - subcomponent separator
"RTN","HLOPRS1",11,0)
 ;  ESCAPE - escape character
"RTN","HLOPRS1",12,0)
 ;  SEG - (pass by reference) the array holding the unparsed segment.
"RTN","HLOPRS1",13,0)
 ;Output:
"RTN","HLOPRS1",14,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOPRS1",15,0)
 ;  TO - (pass by reference) - the parsed values
"RTN","HLOPRS1",16,0)
 ;  SEG- This input variable is deleted during the processing.  If it is needs to be retained, pass in a copy!
"RTN","HLOPRS1",17,0)
 ;
"RTN","HLOPRS1",18,0)
 N VALUE,CHAR,COUNTS
"RTN","HLOPRS1",19,0)
 K TO
"RTN","HLOPRS1",20,0)
 Q:$L($G(FIELD))'=1 0
"RTN","HLOPRS1",21,0)
 Q:$L($G(REP))'=1 0
"RTN","HLOPRS1",22,0)
 Q:$L($G(COMP))'=1 0
"RTN","HLOPRS1",23,0)
 Q:$L($G(SUBCOMP))'=1 0
"RTN","HLOPRS1",24,0)
 Q:'$D(SEG) 0
"RTN","HLOPRS1",25,0)
 S COUNTS("FIELD")=1
"RTN","HLOPRS1",26,0)
 S COUNTS("REP")=1
"RTN","HLOPRS1",27,0)
 S COUNTS("COMP")=1
"RTN","HLOPRS1",28,0)
 S COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",29,0)
 S VALUE=""
"RTN","HLOPRS1",30,0)
 S SEG("LINE")=$O(SEG(0)),SEG("CHAR")=0
"RTN","HLOPRS1",31,0)
 F  S CHAR=$$NEXTCHAR(.SEG) D  Q:'$L(CHAR)
"RTN","HLOPRS1",32,0)
 .I '$L(CHAR) D  Q
"RTN","HLOPRS1",33,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=VALUE
"RTN","HLOPRS1",34,0)
 .E  I CHAR=FIELD D  Q
"RTN","HLOPRS1",35,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",36,0)
 ..S COUNTS("FIELD")=COUNTS("FIELD")+1,COUNTS("REP")=1,COUNTS("COMP")=1,COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",37,0)
 .E  I CHAR=REP D  Q
"RTN","HLOPRS1",38,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",39,0)
 ..S COUNTS("REP")=COUNTS("REP")+1,COUNTS("COMP")=1,COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",40,0)
 .E  I CHAR=COMP D  Q
"RTN","HLOPRS1",41,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",42,0)
 ..S COUNTS("COMP")=COUNTS("COMP")+1,COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",43,0)
 .E  I CHAR=SUBCOMP D  Q
"RTN","HLOPRS1",44,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",45,0)
 ..S COUNTS("SUBCOMP")=COUNTS("SUBCOMP")+1
"RTN","HLOPRS1",46,0)
 .E  S VALUE=VALUE_CHAR
"RTN","HLOPRS1",47,0)
 S TO("SEGMENT TYPE")=$G(TO(1,1,1,1))
"RTN","HLOPRS1",48,0)
 I (TO("SEGMENT TYPE")="BHS")!(TO("SEGMENT TYPE")="MSH") S TO("FIELD SEPARATOR")=FIELD
"RTN","HLOPRS1",49,0)
 Q 1
"RTN","HLOPRS1",50,0)
 ;
"RTN","HLOPRS1",51,0)
NEXTCHAR(SEG) ;
"RTN","HLOPRS1",52,0)
 ;returns the next character in the segment array
"RTN","HLOPRS1",53,0)
 ;
"RTN","HLOPRS1",54,0)
 Q:'SEG("LINE") ""
"RTN","HLOPRS1",55,0)
 N RET
"RTN","HLOPRS1",56,0)
 S SEG("CHAR")=SEG("CHAR")+1
"RTN","HLOPRS1",57,0)
 S RET=$E(SEG(SEG("LINE")),SEG("CHAR"))
"RTN","HLOPRS1",58,0)
 Q:RET]"" RET
"RTN","HLOPRS1",59,0)
 S SEG("LINE")=$O(SEG(SEG("LINE")))
"RTN","HLOPRS1",60,0)
 I SEG("LINE") S SEG("CHAR")=1 Q $E(SEG(SEG("LINE")))
"RTN","HLOPRS1",61,0)
 Q ""
"RTN","HLOPRS1",62,0)
 ;
"RTN","HLOPRS1",63,0)
DESCAPE(VALUE,FIELD,COMP,SUBCOMP,REP,ESCAPE) ;
"RTN","HLOPRS1",64,0)
 ;Replaces the escape sequences with the corresponding encoding character and returns the result as the function value
"RTN","HLOPRS1",65,0)
 ;
"RTN","HLOPRS1",66,0)
 N NEWSTRNG,SUBSTRNG,SET,LEN,I,SUBLEN,CHAR
"RTN","HLOPRS1",67,0)
 S (NEWSTRNG,SUBSTRNG,SUBLEN)=""
"RTN","HLOPRS1",68,0)
 S SET="FSTRE"
"RTN","HLOPRS1",69,0)
 S LEN=$L(VALUE)
"RTN","HLOPRS1",70,0)
 F I=1:1:LEN S SUBSTRNG=SUBSTRNG_$E(VALUE,I),SUBLEN=SUBLEN+1 D:SUBLEN=3
"RTN","HLOPRS1",71,0)
 .S CHAR=$E(SUBSTRNG,2)
"RTN","HLOPRS1",72,0)
 .I $E(SUBSTRNG,1)=ESCAPE,$E(SUBSTRNG,3)=ESCAPE,SET[CHAR D
"RTN","HLOPRS1",73,0)
 ..I CHAR="F" S NEWSTRNG=NEWSTRNG_FIELD,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",74,0)
 ..I CHAR="S" S NEWSTRNG=NEWSTRNG_COMP,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",75,0)
 ..I CHAR="T" S NEWSTRNG=NEWSTRNG_SUBCOMP,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",76,0)
 ..I CHAR="R" S NEWSTRNG=NEWSTRNG_REP,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",77,0)
 ..I CHAR="E" S NEWSTRNG=NEWSTRNG_ESCAPE,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",78,0)
 .E  S NEWSTRNG=NEWSTRNG_$E(SUBSTRNG),SUBSTRNG=$E(SUBSTRNG,2,3),SUBLEN=2
"RTN","HLOPRS1",79,0)
 Q NEWSTRNG_SUBSTRNG
"RTN","HLOPRS1",80,0)
 ;
"RTN","HLOPRS1",81,0)
GETCODE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS1",82,0)
 ;Implements GETCNE and GETCWE
"RTN","HLOPRS1",83,0)
 ;
"RTN","HLOPRS1",84,0)
 N SUB,VAR
"RTN","HLOPRS1",85,0)
 Q:'$G(FIELD)
"RTN","HLOPRS1",86,0)
 I '$G(COMP) D
"RTN","HLOPRS1",87,0)
 .S VAR="COMP",SUB=1
"RTN","HLOPRS1",88,0)
 E  D
"RTN","HLOPRS1",89,0)
 .S VAR="SUB"
"RTN","HLOPRS1",90,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS1",91,0)
 S @VAR=1,VALUE("ID")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",92,0)
 S @VAR=2,VALUE("TEXT")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",93,0)
 S @VAR=3,VALUE("SYSTEM")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",94,0)
 S @VAR=4,VALUE("ALTERNATE ID")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",95,0)
 S @VAR=5,VALUE("ALTERNATE TEXT")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",96,0)
 S @VAR=6,VALUE("ALTERNATE SYSTEM")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,RE)
"RTN","HLOPRS1",97,0)
 S @VAR=7,VALUE("SYSTEM VERSION")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",98,0)
 S @VAR=8,VALUE("ALTERNATE SYSTEM VERSION")=$$GET^HLOPRS(.SEG,FIELD,COM)
"RTN","HLOPRS1",99,0)
 S @VAR=9,VALUE("ORIGINAL TEXT")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",100,0)
 Q
"RTN","HLOPRS2")
0^8^B25178316
"RTN","HLOPRS2",1,0)
HLOPRS2 ;ALB/CJM-HL7 - Developer API's for parsing messages(continued) ;02/04/2004
"RTN","HLOPRS2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**131**;Oct 13, 1995;Build 10
"RTN","HLOPRS2",3,0)
 ;
"RTN","HLOPRS2",4,0)
GETTS(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",5,0)
 ;Gets a segment value that is a timestamp in HL7 format and converts it 
"RTN","HLOPRS2",6,0)
 ;to FileMan format. IF the segment value included the timezone, it is
"RTN","HLOPRS2",7,0)
 ;the timestamp is converted to local time. The degree of precision
"RTN","HLOPRS2",8,0)
 ;is optionally returned.
"RTN","HLOPRS2",9,0)
 ;
"RTN","HLOPRS2",10,0)
 ;IF the component is specified, then the component is parsed for data type rather than at the higher field level.
"RTN","HLOPRS2",11,0)
 ;
"RTN","HLOPRS2",12,0)
 ;
"RTN","HLOPRS2",13,0)
 ;Input:
"RTN","HLOPRS2",14,0)
 ;  SEG - (required, pass by reference) The array returned by a  call to $$NEXTSEG^HLOPRS.
"RTN","HLOPRS2",15,0)
 ;  FIELD - The sequence # of the field.
"RTN","HLOPRS2",16,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",17,0)
 ;  REP - The occurrence # (optional, defaults to 1).  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",18,0)
 ;Output:
"RTN","HLOPRS2",19,0)
 ;  VALUE  (required) The date/time in FileMan format.
"RTN","HLOPRS2",20,0)
 ;  VALUE("PRECISION") (optional) If needed, VALUE must be passed by
"RTN","HLOPRS2",21,0)
 ;       reference.  Expected values are:
"RTN","HLOPRS2",22,0)
 ;           "S" - second
"RTN","HLOPRS2",23,0)
 ;           "M" - minute
"RTN","HLOPRS2",24,0)
 ;           "H" - hour
"RTN","HLOPRS2",25,0)
 ;           "D" - day
"RTN","HLOPRS2",26,0)
 ;           "L" - month
"RTN","HLOPRS2",27,0)
 ;           "Y" - year
"RTN","HLOPRS2",28,0)
 ;           "" - precision not specified
"RTN","HLOPRS2",29,0)
 ;   Note:  FM does not allow greater precision than seconds, so this API will round off to the second.
"RTN","HLOPRS2",30,0)
 ;
"RTN","HLOPRS2",31,0)
 N TIME,PREC,VAR
"RTN","HLOPRS2",32,0)
 Q:'$G(FIELD)
"RTN","HLOPRS2",33,0)
 I '$G(COMP) D
"RTN","HLOPRS2",34,0)
 .S VAR="COMP",SUB=1
"RTN","HLOPRS2",35,0)
 E  D
"RTN","HLOPRS2",36,0)
 .S VAR="SUB"
"RTN","HLOPRS2",37,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS2",38,0)
 S @VAR=1,TIME=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",39,0)
 S @VAR=2,PREC=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",40,0)
 S VALUE=$$HL7TFM^XLFDT(TIME)
"RTN","HLOPRS2",41,0)
 I '$L(PREC) D
"RTN","HLOPRS2",42,0)
 .I $L(+TIME)>12 S PREC="S" Q
"RTN","HLOPRS2",43,0)
 .I $L(+TIME)>10 S PREC="M" Q
"RTN","HLOPRS2",44,0)
 .I $L(+TIME)>8 S PREC="H" Q
"RTN","HLOPRS2",45,0)
 .I $L(+TIME)>6 S PREC="D" Q
"RTN","HLOPRS2",46,0)
 .I $L(+TIME)>4 S PREC="L" Q
"RTN","HLOPRS2",47,0)
 .I $L(+TIME)=4 S PREC="Y" Q
"RTN","HLOPRS2",48,0)
 S VALUE("PRECISION")=PREC
"RTN","HLOPRS2",49,0)
 Q
"RTN","HLOPRS2",50,0)
 ;
"RTN","HLOPRS2",51,0)
GETDT(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",52,0)
 ;Gets a segment value that is a date in HL7 format and converts it to FileMan format. The degree of precision is optionally returned.
"RTN","HLOPRS2",53,0)
 ;IF the component is specified, then the component is parsed for data type rather than at the higher field level.
"RTN","HLOPRS2",54,0)
 ;
"RTN","HLOPRS2",55,0)
 ;Input:
"RTN","HLOPRS2",56,0)
 ;  SEG - (required, pass by reference) The array returned by a  call to $$NEXTSEG^HLOPRS.
"RTN","HLOPRS2",57,0)
 ;  FIELD - The sequence # of the field.
"RTN","HLOPRS2",58,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",59,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",60,0)
 ;Output:
"RTN","HLOPRS2",61,0)
 ;  VALUE  (required) The date/time in FileMan format.
"RTN","HLOPRS2",62,0)
 ;  VALUE("PRECISION") (optional) If needed, VALUE must be passed by
"RTN","HLOPRS2",63,0)
 ;       reference.  Expected values are:
"RTN","HLOPRS2",64,0)
 ;           "S" - second (not valid for DT)
"RTN","HLOPRS2",65,0)
 ;           "M" - minute (not valid for DT)
"RTN","HLOPRS2",66,0)
 ;           "H" - hour (not valid for DT)
"RTN","HLOPRS2",67,0)
 ;           "D" - day
"RTN","HLOPRS2",68,0)
 ;           "L" - month
"RTN","HLOPRS2",69,0)
 ;           "Y" - year
"RTN","HLOPRS2",70,0)
 ;           "" - not specified
"RTN","HLOPRS2",71,0)
 ;
"RTN","HLOPRS2",72,0)
 N TIME,PREC,VAR
"RTN","HLOPRS2",73,0)
 Q:'$G(FIELD)
"RTN","HLOPRS2",74,0)
 I '$G(COMP) D
"RTN","HLOPRS2",75,0)
 .S VAR="COMP",SUB=1
"RTN","HLOPRS2",76,0)
 E  D
"RTN","HLOPRS2",77,0)
 .S VAR="SUB"
"RTN","HLOPRS2",78,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS2",79,0)
 S @VAR=1,TIME=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",80,0)
 S VALUE=$$HL7TFM^XLFDT(TIME)
"RTN","HLOPRS2",81,0)
 S PREC=""
"RTN","HLOPRS2",82,0)
 D
"RTN","HLOPRS2",83,0)
 .I $L(+TIME)>12 S PREC="S" Q
"RTN","HLOPRS2",84,0)
 .I $L(+TIME)>10 S PREC="M" Q
"RTN","HLOPRS2",85,0)
 .I $L(+TIME)>8 S PREC="H" Q
"RTN","HLOPRS2",86,0)
 .I $L(+TIME)>6 S PREC="D" Q
"RTN","HLOPRS2",87,0)
 .I $L(+TIME)>4 S PREC="L" Q
"RTN","HLOPRS2",88,0)
 .I $L(+TIME)=4 S PREC="Y" Q
"RTN","HLOPRS2",89,0)
 S VALUE("PRECISION")=PREC
"RTN","HLOPRS2",90,0)
 Q
"RTN","HLOPRS2",91,0)
 ;
"RTN","HLOPRS2",92,0)
GETCE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",93,0)
 ;Gets an CE data type(Coded Element, HL7 Section Reference 2.9.8) from the specified field.
"RTN","HLOPRS2",94,0)
 ;IF the component is specified, then the component is parsed for data type rather than at the higher field level.
"RTN","HLOPRS2",95,0)
 ;
"RTN","HLOPRS2",96,0)
 ;Input:
"RTN","HLOPRS2",97,0)
 ;  SEG - (required, pass by reference) The array returned by a call to NEXTSEG^HLOPRS.
"RTN","HLOPRS2",98,0)
 ;  FIELD (required) The sequence # of the field.
"RTN","HLOPRS2",99,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",100,0)
 ;  REP - The occurrence # (optional, defaults to 1).  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",101,0)
 ;Output:
"RTN","HLOPRS2",102,0)
 ;  VALUE  (required, pass-by-reference) These subscripts are returned:
"RTN","HLOPRS2",103,0)
 ;    "ID" - the identifier
"RTN","HLOPRS2",104,0)
 ;    "TEXT" - 
"RTN","HLOPRS2",105,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOPRS2",106,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOPRS2",107,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOPRS2",108,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOPRS2",109,0)
 ;
"RTN","HLOPRS2",110,0)
 N SUB,VAR
"RTN","HLOPRS2",111,0)
 Q:'$G(FIELD)
"RTN","HLOPRS2",112,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS2",113,0)
 I '$G(COMP) D
"RTN","HLOPRS2",114,0)
 .S VAR="COMP",SUB=1
"RTN","HLOPRS2",115,0)
 E  D
"RTN","HLOPRS2",116,0)
 .S VAR="SUB"
"RTN","HLOPRS2",117,0)
 S @VAR=1,VALUE("ID")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",118,0)
 S @VAR=2,VALUE("TEXT")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",119,0)
 S @VAR=3,VALUE("SYSTEM")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",120,0)
 S @VAR=4,VALUE("ALTERNATE ID")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",121,0)
 S @VAR=5,VALUE("ALTERNATE TEXT")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",122,0)
 S @VAR=6,VALUE("ALTERNATE SYSTEM")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",123,0)
 Q
"RTN","HLOPRS2",124,0)
 ;
"RTN","HLOPRS2",125,0)
GETHD(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",126,0)
 ;Gets an HD data type (Hierarchic Designator, HL7 Section Reference 2.9.21) from the specified field.
"RTN","HLOPRS2",127,0)
 ;IF the component is specified, then the component is parsed for data type rather than at the higher field level.
"RTN","HLOPRS2",128,0)
 ;
"RTN","HLOPRS2",129,0)
 ;Input:
"RTN","HLOPRS2",130,0)
 ;  SEG - (required, pass by reference) The array returned by a call to NEXTSEG^HLOPRS.
"RTN","HLOPRS2",131,0)
 ;  FIELD (required) The sequence # of the field.
"RTN","HLOPRS2",132,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",133,0)
 ;  REP - The occurrence # (optional, defaults to 1).  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",134,0)
 ;Output:
"RTN","HLOPRS2",135,0)
 ;  VALUE  (required, pass-by-reference) These subscripts are returned:
"RTN","HLOPRS2",136,0)
 ;    "NAMESPACE ID"
"RTN","HLOPRS2",137,0)
 ;    "UNIVERSAL ID"
"RTN","HLOPRS2",138,0)
 ;    "UNIVERSAL ID TYPE"
"RTN","HLOPRS2",139,0)
 ;
"RTN","HLOPRS2",140,0)
 N SUB,VAR
"RTN","HLOPRS2",141,0)
 Q:'$G(FIELD)
"RTN","HLOPRS2",142,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS2",143,0)
 I '$G(COMP) D
"RTN","HLOPRS2",144,0)
 .S VAR="COMP",SUB=1
"RTN","HLOPRS2",145,0)
 E  D
"RTN","HLOPRS2",146,0)
 .S VAR="SUB"
"RTN","HLOPRS2",147,0)
 S @VAR=1,VALUE("NAMESPACE ID")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",148,0)
 S @VAR=2,VALUE("UNIVERSAL ID")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",149,0)
 S @VAR=3,VALUE("UNIVERSAL ID TYPE")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",150,0)
 Q
"RTN","HLOPRS2",151,0)
 ;
"RTN","HLOPRS2",152,0)
GETCNE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",153,0)
 ;Gets an CNE data type (Coded With No Exceptions, HL7 Section Reference 2.9.8) from the specified field.
"RTN","HLOPRS2",154,0)
 ;IF the component is specified, then the component is parsed for data type rather than at the higher field level.
"RTN","HLOPRS2",155,0)
 ;
"RTN","HLOPRS2",156,0)
 ;Input:
"RTN","HLOPRS2",157,0)
 ;  SEG - (required, pass by reference) The array returned by a call to NEXTSEG^HLOPRS.
"RTN","HLOPRS2",158,0)
 ;  FIELD (required) The sequence # of the field.
"RTN","HLOPRS2",159,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",160,0)
 ;  REP - The occurrence # (optional, defaults to 1).  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",161,0)
 ;Output:
"RTN","HLOPRS2",162,0)
 ;  VALUE  (required, pass-by-reference) These subscripts are returned:
"RTN","HLOPRS2",163,0)
 ;    "ID" - the identifier
"RTN","HLOPRS2",164,0)
 ;    "TEXT" - 
"RTN","HLOPRS2",165,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOPRS2",166,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOPRS2",167,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOPRS2",168,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOPRS2",169,0)
 ;    "SYSTEM VERSION" - version ID of the coding system
"RTN","HLOPRS2",170,0)
 ;    "ALTERNATE SYSTEM VERSION" - version ID of the alternate coding system
"RTN","HLOPRS2",171,0)
 ;    "ORIGINAL TEXT"
"RTN","HLOPRS2",172,0)
 ;
"RTN","HLOPRS2",173,0)
 D GETCODE^HLOPRS1(.SEG,.VALUE,.FIELD,.COMP,.REP)
"RTN","HLOPRS2",174,0)
 Q
"RTN","HLOPRS2",175,0)
 ;
"RTN","HLOPRS2",176,0)
GETCWE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",177,0)
 ;Gets an CWE data type (Coded With Exceptions, HL7 Section Reference 2.9.11) from the specified field.
"RTN","HLOPRS2",178,0)
 ;IF the component is specified, then the component is parsed for the data type rather than at the higher field level.
"RTN","HLOPRS2",179,0)
 ;
"RTN","HLOPRS2",180,0)
 ;Input:
"RTN","HLOPRS2",181,0)
 ;  SEG - (required, pass by reference) The array returned by a call to NEXTSEG^HLOPRS.
"RTN","HLOPRS2",182,0)
 ;  FIELD (required) The sequence # of the field.
"RTN","HLOPRS2",183,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",184,0)
 ;  REP - The occurrence # (optional, defaults to 1).  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",185,0)
 ;Output:
"RTN","HLOPRS2",186,0)
 ;  VALUE  (required, pass-by-reference) These subscripts are returned:
"RTN","HLOPRS2",187,0)
 ;    "ID" - the identifier
"RTN","HLOPRS2",188,0)
 ;    "TEXT" - 
"RTN","HLOPRS2",189,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOPRS2",190,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOPRS2",191,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOPRS2",192,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOPRS2",193,0)
 ;    "SYSTEM VERSION" - version ID of the coding system
"RTN","HLOPRS2",194,0)
 ;    "ALTERNATE SYSTEM VERSION" - version ID of the alternate coding system
"RTN","HLOPRS2",195,0)
 ;    "ORIGINAL TEXT"
"RTN","HLOPRS2",196,0)
 D GETCODE^HLOPRS1(.SEG,.VALUE,.FIELD,.COMP,.REP)
"RTN","HLOPRS2",197,0)
 Q
"RTN","HLOPRS2",198,0)
 ;
"RTN","HLOPRS2",199,0)
GETAD(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS2",200,0)
 ;Gets an AD data type (Address, HL7 Section Reference 2.9.1) from the specified field. It can also be used to get the 1st 8 components of the XAD (Extended Address) data type.
"RTN","HLOPRS2",201,0)
 ;IF the component is specified, then the component is parsed for the address rather than at the higher field level.
"RTN","HLOPRS2",202,0)
 ;
"RTN","HLOPRS2",203,0)
 ;Input:
"RTN","HLOPRS2",204,0)
 ;  SEG - (required, pass by reference) The array returned by a call to NEXTSEG^HLOPRS.
"RTN","HLOPRS2",205,0)
 ;  FIELD (required) The sequence # of the field.
"RTN","HLOPRS2",206,0)
 ;  COMP (optional) If specified, the data type is parsed as a component  value.
"RTN","HLOPRS2",207,0)
 ;  REP - The occurrence # (optional, defaults to 1).  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOPRS2",208,0)
 ;Output:
"RTN","HLOPRS2",209,0)
 ;  VALUE  (required, pass-by-reference) These subscripts are returned:
"RTN","HLOPRS2",210,0)
 ;    "STREET1" -street address
"RTN","HLOPRS2",211,0)
 ;    "STREET2" - other designation
"RTN","HLOPRS2",212,0)
 ;    "CITY"
"RTN","HLOPRS2",213,0)
 ;    "STATE" - state or province
"RTN","HLOPRS2",214,0)
 ;    "ZIP" - zip or postal code
"RTN","HLOPRS2",215,0)
 ;    "COUNTRY"
"RTN","HLOPRS2",216,0)
 ;    "TYPE"  - address type
"RTN","HLOPRS2",217,0)
 ;    "OTHER" - other geographic designation
"RTN","HLOPRS2",218,0)
 ;
"RTN","HLOPRS2",219,0)
 N SUB,VAR
"RTN","HLOPRS2",220,0)
 Q:'$G(FIELD)
"RTN","HLOPRS2",221,0)
 I '$G(COMP) D
"RTN","HLOPRS2",222,0)
 .S VAR="COMP",SUB=1
"RTN","HLOPRS2",223,0)
 E  D
"RTN","HLOPRS2",224,0)
 .S VAR="SUB"
"RTN","HLOPRS2",225,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS2",226,0)
 S @VAR=1,VALUE("STREET1")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",227,0)
 S @VAR=2,VALUE("STREET2")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",228,0)
 S @VAR=3,VALUE("CITY")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",229,0)
 S @VAR=4,VALUE("STATE")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",230,0)
 S @VAR=5,VALUE("ZIP")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",231,0)
 S @VAR=6,VALUE("COUNTRY")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",232,0)
 S @VAR=7,VALUE("TYPE")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",233,0)
 S @VAR=8,VALUE("OTHER")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS2",234,0)
 Q
"RTN","HLOSRVR")
0^4^B62293420^B70554107
"RTN","HLOSRVR",1,0)
HLOSRVR ;ALB/CJM- Server for receiving messages - 10/4/94 1pm
"RTN","HLOSRVR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131**;Oct 13, 1995;Build 10
"RTN","HLOSRVR",3,0)
 ;
"RTN","HLOSRVR",4,0)
GETWORK(WORK) ;
"RTN","HLOSRVR",5,0)
 ;GET WORK function for a single server OR Taskman multi-server
"RTN","HLOSRVR",6,0)
 N LINK
"RTN","HLOSRVR",7,0)
 I '$$CHKSTOP^HLOPROC,$G(WORK("LINK"))]"",$$GETLINK^HLOTLNK(WORK("LINK"),.LINK),+LINK("SERVER") S WORK("PORT")=LINK("PORT") Q 1
"RTN","HLOSRVR",8,0)
 Q 0
"RTN","HLOSRVR",9,0)
 ;
"RTN","HLOSRVR",10,0)
DOWORKS(WORK) ;
"RTN","HLOSRVR",11,0)
 ;DO WORK rtn for a single server (non-concurrent)
"RTN","HLOSRVR",12,0)
 D SERVER(WORK("LINK"))
"RTN","HLOSRVR",13,0)
 Q
"RTN","HLOSRVR",14,0)
DOWORKM(WORK) ;
"RTN","HLOSRVR",15,0)
 ;DO WORK rtn for a Taskman multi-server (Cache systems only)
"RTN","HLOSRVR",16,0)
 D LISTEN^%ZISTCPS(WORK("PORT"),"SERVER^HLOSRVR("""_WORK("LINK")_""")")
"RTN","HLOSRVR",17,0)
 Q
"RTN","HLOSRVR",18,0)
 ;
"RTN","HLOSRVR",19,0)
VMS2(LINKNAME) ;called from a VMS TCP Service once a connection request has been received.  This entry point should be used only if an additional VMS TCPIP Services are being created for HLO.
"RTN","HLOSRVR",20,0)
 ;Input:
"RTN","HLOSRVR",21,0)
 ;   LINKNAME - only pass it in if an additional service is being created on a different port
"RTN","HLOSRVR",22,0)
 Q:'$L(LINKNAME)
"RTN","HLOSRVR",23,0)
 D VMS
"RTN","HLOSRVR",24,0)
 Q
"RTN","HLOSRVR",25,0)
 ;
"RTN","HLOSRVR",26,0)
VMS ;Called from VMS TCP Service once a connection request has been received. This entry point should be used only by the standard HLO service that runs on the standard HLO port.
"RTN","HLOSRVR",27,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",28,0)
 D
"RTN","HLOSRVR",29,0)
 .Q:$L($G(LINKNAME))
"RTN","HLOSRVR",30,0)
 .;
"RTN","HLOSRVR",31,0)
 .N PROC,NODE
"RTN","HLOSRVR",32,0)
 .S PROC=$O(^HLD(779.3,"B","VMS TCP LISTENER",0))
"RTN","HLOSRVR",33,0)
 .I PROC S LINKNAME=$P($G(^HLD(779.3,PROC,0)),"^",14) Q:$L(LINKNAME)
"RTN","HLOSRVR",34,0)
 .S NODE=$G(^HLD(779.1,1,0)) I $P(NODE,"^",10) S LINKNAME=$P($G(^HLCS(870,$P(NODE,"^",10),0)),"^") Q:$L(LINKNAME) 
"RTN","HLOSRVR",35,0)
 .S LINKNAME="HLO DEFAULT LISTENER"
"RTN","HLOSRVR",36,0)
 ;
"RTN","HLOSRVR",37,0)
 D SERVER(LINKNAME,"SYS$NET")
"RTN","HLOSRVR",38,0)
 Q
"RTN","HLOSRVR",39,0)
 ;
"RTN","HLOSRVR",40,0)
SERVER(LINKNAME,LOGICAL) ; LINKNAME identifies the logical link, which describes the communication channel to be used
"RTN","HLOSRVR",41,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOSRVR1"
"RTN","HLOSRVR",42,0)
 N HLCSTATE,INQUE
"RTN","HLOSRVR",43,0)
 S INQUE=0
"RTN","HLOSRVR",44,0)
 Q:'$$CONNECT(.HLCSTATE,LINKNAME,.LOGICAL)
"RTN","HLOSRVR",45,0)
 K LINKNAME
"RTN","HLOSRVR",46,0)
 F  Q:'HLCSTATE("CONNECTED")  D  Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",47,0)
 .N HLMSTATE,SENT
"RTN","HLOSRVR",48,0)
 .;
"RTN","HLOSRVR",49,0)
 .;read msg and parse the hdr
"RTN","HLOSRVR",50,0)
 .;HLMSTATE("MSA",1) is set with type of ack to return
"RTN","HLOSRVR",51,0)
 .I $$READMSG^HLOSRVR1(.HLCSTATE,.HLMSTATE) D
"RTN","HLOSRVR",52,0)
 ..;
"RTN","HLOSRVR",53,0)
 ..;send an ack if required and save the MSA segment
"RTN","HLOSRVR",54,0)
 ..I (HLMSTATE("MSA",1)]"") S SENT=$$WRITEACK(.HLCSTATE,.HLMSTATE) D:HLMSTATE("IEN") SAVEACK(.HLMSTATE,SENT)
"RTN","HLOSRVR",55,0)
 ..D:HLMSTATE("IEN") UPDATE(.HLMSTATE,.HLCSTATE)
"RTN","HLOSRVR",56,0)
 ..D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",57,0)
 .E  D INQUE() H:HLCSTATE("CONNECTED") 1
"RTN","HLOSRVR",58,0)
 ;
"RTN","HLOSRVR",59,0)
END D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR",60,0)
 D INQUE()
"RTN","HLOSRVR",61,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",62,0)
 Q
"RTN","HLOSRVR",63,0)
 ;
"RTN","HLOSRVR",64,0)
CONNECT(HLCSTATE,LINKNAME,LOGICAL) ;
"RTN","HLOSRVR",65,0)
 ;sets up HLCSTATE() and opens a server connection
"RTN","HLOSRVR",66,0)
 ;
"RTN","HLOSRVR",67,0)
 N LINK,NODE
"RTN","HLOSRVR",68,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOSRVR",69,0)
 Q:'$$GETLINK^HLOTLNK(LINKNAME,.LINK) 0
"RTN","HLOSRVR",70,0)
 Q:+LINK("SERVER")'=1 0
"RTN","HLOSRVR",71,0)
 S HLCSTATE("SERVER")=LINK("SERVER")
"RTN","HLOSRVR",72,0)
 M HLCSTATE("LINK")=LINK
"RTN","HLOSRVR",73,0)
 S HLCSTATE("READ TIMEOUT")=20
"RTN","HLOSRVR",74,0)
 S HLCSTATE("OPEN TIMEOUT")=30
"RTN","HLOSRVR",75,0)
 S HLCSTATE("READ")="" ;buffer for reads
"RTN","HLOSRVR",76,0)
 ;
"RTN","HLOSRVR",77,0)
 ;HLCSTATE("BUFFER",<seg>,<line>)  write buffer
"RTN","HLOSRVR",78,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of bytes in buffer
"RTN","HLOSRVR",79,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOSRVR",80,0)
 ;
"RTN","HLOSRVR",81,0)
 S HLCSTATE("COUNTS")=0
"RTN","HLOSRVR",82,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOSRVR",83,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOSRVR",84,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOSRVR",85,0)
 Q:HLCSTATE("SYSTEM","OS")="" 0
"RTN","HLOSRVR",86,0)
 D  ;get necessary system parameters
"RTN","HLOSRVR",87,0)
 .N SYS,SUB
"RTN","HLOSRVR",88,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOSRVR",89,0)
 .F SUB="MAXSTRING","DOMAIN","STATION","PROCESSING ID","NORMAL PURGE","ERROR PURGE" S HLCSTATE("SYSTEM",SUB)=SYS(SUB)
"RTN","HLOSRVR",90,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOSRVR",91,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOSRVR",92,0)
 .D OPEN^HLOTCP(.HLCSTATE,.LOGICAL)
"RTN","HLOSRVR",93,0)
 E  ;no other LLP implemented
"RTN","HLOSRVR",94,0)
 ;
"RTN","HLOSRVR",95,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOSRVR",96,0)
 ;
"RTN","HLOSRVR",97,0)
INQUE(MSGIEN,PARMS) ;
"RTN","HLOSRVR",98,0)
 ;puts received messages on the incoming queue and sets the B x-refs
"RTN","HLOSRVR",99,0)
 I $G(MSGIEN) S INQUE=INQUE+1 M INQUE(MSGIEN)=PARMS
"RTN","HLOSRVR",100,0)
 I ('$G(MSGIEN))!(INQUE>20) S MSGIEN=0 D
"RTN","HLOSRVR",101,0)
 .F  S MSGIEN=$O(INQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOSRVR",102,0)
 ..S ^HLB("B",INQUE(MSGIEN,"MSGID"),MSGIEN)=""
"RTN","HLOSRVR",103,0)
 ..S ^HLA("B",INQUE(MSGIEN,"DT/TM"),INQUE(MSGIEN,"BODY"))=""
"RTN","HLOSRVR",104,0)
 ..D:INQUE(MSGIEN,"PASS")
"RTN","HLOSRVR",105,0)
 ...N PURGE
"RTN","HLOSRVR",106,0)
 ...S PURGE=+$G(INQUE(MSGIEN,"PURGE"))
"RTN","HLOSRVR",107,0)
 ...S PURGE("ACKTOIEN")=$G(INQUE(MSGIEN,"ACKTOIEN"))
"RTN","HLOSRVR",108,0)
 ...D INQUE^HLOQUE(INQUE(MSGIEN,"FROM"),INQUE(MSGIEN,"QUEUE"),MSGIEN,INQUE(MSGIEN,"ACTION"),.PURGE)
"RTN","HLOSRVR",109,0)
 .K INQUE S INQUE=0
"RTN","HLOSRVR",110,0)
 Q
"RTN","HLOSRVR",111,0)
 ;
"RTN","HLOSRVR",112,0)
SAVEACK(HLMSTATE,SENT) ;
"RTN","HLOSRVR",113,0)
 ;Input:
"RTN","HLOSRVR",114,0)
 ;  SENT - flag = 1 if transmission of ack succeeded, 0 otherwise
"RTN","HLOSRVR",115,0)
 ;
"RTN","HLOSRVR",116,0)
 N NODE,I
"RTN","HLOSRVR",117,0)
 S $P(NODE,"^")=HLMSTATE("MSA","DT/TM OF MESSAGE")
"RTN","HLOSRVR",118,0)
 S $P(NODE,"^",2)=HLMSTATE("MSA","MESSAGE CONTROL ID")
"RTN","HLOSRVR",119,0)
 S $P(NODE,"^",3)="MSA"
"RTN","HLOSRVR",120,0)
 F I=1:1:3 S NODE=NODE_"|"_$G(HLMSTATE("MSA",I))
"RTN","HLOSRVR",121,0)
 S ^HLB(HLMSTATE("IEN"),4)=NODE
"RTN","HLOSRVR",122,0)
 S:SENT $P(^HLB(HLMSTATE("IEN"),0),"^",$S($E(HLMSTATE("MSA",1))="A":18,1:17))=1
"RTN","HLOSRVR",123,0)
 Q
"RTN","HLOSRVR",124,0)
 ;
"RTN","HLOSRVR",125,0)
UPDATE(HLMSTATE,HLCSTATE) ;
"RTN","HLOSRVR",126,0)
 ;Updates status and purge date when appropriate
"RTN","HLOSRVR",127,0)
 ;Also, sets the "B" xrefs, files 777,778, and places message on the incoming queue
"RTN","HLOSRVR",128,0)
 ;
"RTN","HLOSRVR",129,0)
 N PARMS,PURGE,WAIT
"RTN","HLOSRVR",130,0)
 S PARMS("PASS")=0
"RTN","HLOSRVR",131,0)
 I HLMSTATE("STATUS","ACTION")]"",HLMSTATE("STATUS")'="SE" S PARMS("PASS")=1,$P(^HLB(HLMSTATE("IEN"),0),"^",6)=HLMSTATE("STATUS","QUEUE")
"RTN","HLOSRVR",132,0)
 D:'PARMS("PASS")  ;if not passing to the app, set the purge date
"RTN","HLOSRVR",133,0)
 .I HLMSTATE("STATUS")="" S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",134,0)
 .S:HLMSTATE("BATCH") WAIT=HLCSTATE("SYSTEM","ERROR PURGE")
"RTN","HLOSRVR",135,0)
 .S:'HLMSTATE("BATCH") WAIT=$S(HLMSTATE("STATUS")="SE":24*HLCSTATE("SYSTEM","ERROR PURGE"),1:HLCSTATE("SYSTEM","NORMAL PURGE"))
"RTN","HLOSRVR",136,0)
 .S PURGE=$$FMADD^XLFDT($$NOW^XLFDT,,WAIT)
"RTN","HLOSRVR",137,0)
 .S $P(^HLB(HLMSTATE("IEN"),0),"^",9)=PURGE
"RTN","HLOSRVR",138,0)
 .S ^HLB("AD","IN",PURGE,HLMSTATE("IEN"))=""
"RTN","HLOSRVR",139,0)
 .;if this is an app ack, purge the original message at the same time
"RTN","HLOSRVR",140,0)
 .I $G(HLMSTATE("ACK TO","IEN")),'HLMSTATE("BATCH") D
"RTN","HLOSRVR",141,0)
 ..S $P(^HLB(+HLMSTATE("ACK TO","IEN"),0),"^",9)=PURGE
"RTN","HLOSRVR",142,0)
 ..S ^HLB("AD","IN",PURGE,+HLMSTATE("ACK TO","IEN"))=""
"RTN","HLOSRVR",143,0)
 ;
"RTN","HLOSRVR",144,0)
 ;if not waiting for an application ack, set the status now even if passing to the app - but don't set the purge until the infiler passes the message
"RTN","HLOSRVR",145,0)
 I HLMSTATE("STATUS")="",HLMSTATE("HDR","APP ACK TYPE")'="AL" S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",146,0)
 I HLMSTATE("STATUS")'="" S $P(^HLB(HLMSTATE("IEN"),0),"^",20)=HLMSTATE("STATUS") S:$G(HLMSTATE("MSA",3))]"" $P(^HLB(HLMSTATE("IEN"),0),"^",21)=HLMSTATE("MSA",3) D:HLMSTATE("STATUS")="SE"
"RTN","HLOSRVR",147,0)
 .N APP
"RTN","HLOSRVR",148,0)
 .S APP=HLMSTATE("HDR","RECEIVING APPLICATION") S:APP="" APP="UNKNOWN" S ^HLB("ERRORS","SE",APP,HLMSTATE("DT/TM"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR",149,0)
 ;
"RTN","HLOSRVR",150,0)
 ;set the necessary parms for passing the msg to the app via the infiler
"RTN","HLOSRVR",151,0)
 D:PARMS("PASS")
"RTN","HLOSRVR",152,0)
 .N I,FROM
"RTN","HLOSRVR",153,0)
 .S FROM=HLMSTATE("HDR","SENDING FACILITY",1)
"RTN","HLOSRVR",154,0)
 .I HLMSTATE("HDR","SENDING FACILITY",2)]"" S FROM=FROM_"~"_HLMSTATE("HDR","SENDING FACILITY",2)_"~"_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",155,0)
 .I FROM="" S FROM="UNKNOWN SENDING FACILITY"
"RTN","HLOSRVR",156,0)
 .S PARMS("FROM")=FROM,PARMS("QUEUE")=HLMSTATE("STATUS","QUEUE"),PARMS("ACTION")=HLMSTATE("STATUS","ACTION")
"RTN","HLOSRVR",157,0)
 .I HLMSTATE("STATUS")'="" S PARMS("PURGE")=1
"RTN","HLOSRVR",158,0)
 .S:$G(HLMSTATE("ACK TO","IEN")) PARMS("ACKTOIEN")=HLMSTATE("ACK TO","IEN") ;to insure that the infiler will know to set the purge date at the same time as the initial message
"RTN","HLOSRVR",159,0)
 ;
"RTN","HLOSRVR",160,0)
 S PARMS("BODY")=HLMSTATE("BODY")
"RTN","HLOSRVR",161,0)
 S PARMS("DT/TM")=HLMSTATE("DT/TM")
"RTN","HLOSRVR",162,0)
 S PARMS("MSGID")=HLMSTATE("ID")
"RTN","HLOSRVR",163,0)
 D INQUE(HLMSTATE("IEN"),.PARMS)
"RTN","HLOSRVR",164,0)
 Q
"RTN","HLOSRVR",165,0)
 ;
"RTN","HLOSRVR",166,0)
WRITEACK(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR",167,0)
 ;Sends an accept ack
"RTN","HLOSRVR",168,0)
 ;
"RTN","HLOSRVR",169,0)
 ;Input:
"RTN","HLOSRVR",170,0)
 ;  HLCSTATE (pass by reference) defines the communication channel
"RTN","HLOSRVR",171,0)
 ;  HLMSTATE (pass by reference) the message being acked
"RTN","HLOSRVR",172,0)
 ;     ("MSA",1) - value for MSA-1
"RTN","HLOSRVR",173,0)
 ;     ("MSA",2) - value for MSA-2
"RTN","HLOSRVR",174,0)
 ;     ("MSA",3) - value for MSA-3
"RTN","HLOSRVR",175,0)
 ;     ("HDR") - parsed values for the message being ack'd
"RTN","HLOSRVR",176,0)
 ;Output:
"RTN","HLOSRVR",177,0)
 ;  Function returns 1 if successful, 0 otherwise
"RTN","HLOSRVR",178,0)
 ;  HLMSTATE("MSA","MESSAGE CONTROL ID") - the msg id of the ack
"RTN","HLOSRVR",179,0)
 ;  HLMSTATE(,"MSA","DT/TM OF MESSAGE") - from the ack header
"RTN","HLOSRVR",180,0)
 ;
"RTN","HLOSRVR",181,0)
 N HDR,SUB,FS,CS,MSA,ACKID,TIME
"RTN","HLOSRVR",182,0)
 ;Hard-code the delimiters, the standard requires that the receiving system accept the delimiters listed in the header
"RTN","HLOSRVR",183,0)
 S FS="|"
"RTN","HLOSRVR",184,0)
 S CS="^"
"RTN","HLOSRVR",185,0)
 S TIME=$$NOW^XLFDT
"RTN","HLOSRVR",186,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=TIME
"RTN","HLOSRVR",187,0)
 S ACKID=HLCSTATE("SYSTEM","STATION")_" "_$$NEWIEN^HLOF778A("OUT")
"RTN","HLOSRVR",188,0)
 S HLMSTATE("MSA","MESSAGE CONTROL ID")=ACKID
"RTN","HLOSRVR",189,0)
 ;
"RTN","HLOSRVR",190,0)
 S HDR(1)="MSH"_FS_"^~\&"_FS_HLMSTATE("HDR","RECEIVING APPLICATION")_FS_HLCSTATE("SYSTEM","STATION")_CS_HLCSTATE("SYSTEM","DOMAIN")_CS_"DNS"_FS
"RTN","HLOSRVR",191,0)
 S HDR(1)=HDR(1)_HLMSTATE("HDR","SENDING APPLICATION")_FS_HLMSTATE("HDR","SENDING FACILITY",1)_CS_HLMSTATE("HDR","SENDING FACILITY",2)_CS_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",192,0)
 ;
"RTN","HLOSRVR",193,0)
 S HDR(2)=FS_$$HLDATE^HLFNC(TIME,"TS")_FS_FS_"ACK"_FS_ACKID_FS_HLMSTATE("HDR","PROCESSING ID")_FS_"2.4"_FS_FS_FS_"NE"_FS_"NE"
"RTN","HLOSRVR",194,0)
 ;
"RTN","HLOSRVR",195,0)
 S MSA(1)="MSA"_FS
"RTN","HLOSRVR",196,0)
 F SUB=1:1:3 S MSA(1)=MSA(1)_HLMSTATE("MSA",SUB)_FS
"RTN","HLOSRVR",197,0)
 I $$WRITEHDR^HLOT(.HLCSTATE,.HDR),$$WRITESEG^HLOT(.HLCSTATE,.MSA),$$ENDMSG^HLOT(.HLCSTATE) S HLCSTATE("COUNTS","ACKS")=$G(HLCSTATE("COUNTS","ACKS"))+1 Q 1
"RTN","HLOSRVR",198,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=""
"RTN","HLOSRVR",199,0)
 Q 0
"RTN","HLOSRVR1")
0^5^B63396021^B65124218
"RTN","HLOSRVR1",1,0)
HLOSRVR1 ;IRMFO-ALB/CJM - Reading messages, sending acks;03/24/2004  14:43
"RTN","HLOSRVR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131**;Oct 13, 1995;Build 10
"RTN","HLOSRVR1",3,0)
 ;
"RTN","HLOSRVR1",4,0)
READMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR1",5,0)
 ;This function uses the services provided by the transport layer to receive a message.  The header is parsed. Does these checks:
"RTN","HLOSRVR1",6,0)
 ; 1) Duplicate?
"RTN","HLOSRVR1",7,0)
 ; 2) Wrong Receiving Facility?
"RTN","HLOSRVR1",8,0)
 ; 3) Can the Receiving App accept this message, based message type & event?
"RTN","HLOSRVR1",9,0)
 ; 4) Processing ID must match the receiving system
"RTN","HLOSRVR1",10,0)
 ; 5) Must have an ID
"RTN","HLOSRVR1",11,0)
 ; 6) Header must be BHS or MSH
"RTN","HLOSRVR1",12,0)
 ;
"RTN","HLOSRVR1",13,0)
 ;Output:
"RTN","HLOSRVR1",14,0)
 ;  Function returns 1 if the message was read fully, 0 otherwise
"RTN","HLOSRVR1",15,0)
 ;  HLMSTATE (pass by reference) the message.  It will include the fields for the return ack in HLMSTATE("MSA")
"RTN","HLOSRVR1",16,0)
 ;
"RTN","HLOSRVR1",17,0)
 N ACK,SEG,STORE,I
"RTN","HLOSRVR1",18,0)
 ;
"RTN","HLOSRVR1",19,0)
 S STORE=1
"RTN","HLOSRVR1",20,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.SEG) 0
"RTN","HLOSRVR1",21,0)
 D SPLITHDR(.SEG)
"RTN","HLOSRVR1",22,0)
 ;
"RTN","HLOSRVR1",23,0)
 ;parse the header, stop if unsuccessful because the server cannot know what to do next
"RTN","HLOSRVR1",24,0)
 I '$$PARSEHDR^HLOPRS(.SEG) D  Q 0
"RTN","HLOSRVR1",25,0)
 .S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOSRVR1",26,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",27,0)
 D NEWMSG^HLOSRVR2(.HLCSTATE,.HLMSTATE,.SEG)
"RTN","HLOSRVR1",28,0)
 I HLMSTATE("ID")="" D
"RTN","HLOSRVR1",29,0)
 .S STORE=0
"RTN","HLOSRVR1",30,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" S HLMSTATE("MSA",1)="CE",HLMSTATE("MSA",3)="CONTROL ID MISSING"
"RTN","HLOSRVR1",31,0)
 I STORE,$$DUP(.HLMSTATE) S STORE=0
"RTN","HLOSRVR1",32,0)
 ;
"RTN","HLOSRVR1",33,0)
 ;if the message is not to be stored, just read it and discard the segments
"RTN","HLOSRVR1",34,0)
 I 'STORE D
"RTN","HLOSRVR1",35,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)
"RTN","HLOSRVR1",36,0)
 ;
"RTN","HLOSRVR1",37,0)
 ;else the message is to be stored
"RTN","HLOSRVR1",38,0)
 E  D
"RTN","HLOSRVR1",39,0)
 .N FS
"RTN","HLOSRVR1",40,0)
 .S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOSRVR1",41,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOSRVR1",42,0)
 ..N MSA,SEGTYPE,OLDMSGID,CODE,IEN,NEWMSGID
"RTN","HLOSRVR1",43,0)
 ..S SEGTYPE=$E($E(SEG(1),1,3)_$E($G(SEG(2)),1,2),1,3)
"RTN","HLOSRVR1",44,0)
 ..I SEGTYPE="MSA" D
"RTN","HLOSRVR1",45,0)
 ...S MSA=SEG(1)_$G(SEG(2))_$G(SEG(3))
"RTN","HLOSRVR1",46,0)
 ...S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2)
"RTN","HLOSRVR1",47,0)
 ...I $E(CODE,1)'="A" S SEGTYPE="" Q
"RTN","HLOSRVR1",48,0)
 ...S:$P(OLDMSGID,"-")]"" IEN=$O(^HLB("B",$P(OLDMSGID,"-"),0))
"RTN","HLOSRVR1",49,0)
 ...S:$G(IEN) IEN=IEN_"^"_$P(OLDMSGID,"-",2)
"RTN","HLOSRVR1",50,0)
 ..I 'HLMSTATE("BATCH") D
"RTN","HLOSRVR1",51,0)
 ...D:SEGTYPE="MSA"
"RTN","HLOSRVR1",52,0)
 ....S HLMSTATE("ACK TO")=OLDMSGID
"RTN","HLOSRVR1",53,0)
 ....S HLMSTATE("ACK TO","ACK BY")=HLMSTATE("ID")
"RTN","HLOSRVR1",54,0)
 ....S HLMSTATE("ACK TO","STATUS")=$S(CODE="AA":"SU",1:"AE")
"RTN","HLOSRVR1",55,0)
 ....S:$D(IEN) HLMSTATE("ACK TO","IEN")=IEN
"RTN","HLOSRVR1",56,0)
 ...D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",57,0)
 ..E  D  ;batch
"RTN","HLOSRVR1",58,0)
 ...I SEGTYPE="MSH" D
"RTN","HLOSRVR1",59,0)
 ....D SPLITHDR(.SEG)
"RTN","HLOSRVR1",60,0)
 ....S NEWMSGID=$P(SEG(2),FS,5)
"RTN","HLOSRVR1",61,0)
 ....D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",62,0)
 ...E  D  ;not MSH
"RTN","HLOSRVR1",63,0)
 ....D:SEGTYPE="MSA"
"RTN","HLOSRVR1",64,0)
 .....N SUBIEN S SUBIEN=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOSRVR1",65,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN)=OLDMSGID
"RTN","HLOSRVR1",66,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"ACK BY")=NEWMSGID
"RTN","HLOSRVR1",67,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"STATUS")=$S(CODE="AA":"SU",1:"AE")
"RTN","HLOSRVR1",68,0)
 .....S:$D(IEN) HLMSTATE("BATCH","ACK TO",SUBIEN,"IEN")=IEN
"RTN","HLOSRVR1",69,0)
 ....D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",70,0)
 .I HLMSTATE("UNSTORED LINES"),HLCSTATE("MESSAGE ENDED"),$$SAVEMSG^HLOF778(.HLMSTATE)
"RTN","HLOSRVR1",71,0)
 ;
"RTN","HLOSRVR1",72,0)
 I STORE,'HLCSTATE("MESSAGE ENDED") D
"RTN","HLOSRVR1",73,0)
 .;reading failed before the end, there is no need to keep anything
"RTN","HLOSRVR1",74,0)
 .D:HLMSTATE("IEN") DEL778(HLMSTATE("IEN")) D:HLMSTATE("BODY") DEL777(HLMSTATE("BODY"))
"RTN","HLOSRVR1",75,0)
 .S HLMSTATE("IEN")="",HLMSTATE("BODY")=""
"RTN","HLOSRVR1",76,0)
 E  D:STORE
"RTN","HLOSRVR1",77,0)
 .D CHECKMSG(.HLMSTATE)
"RTN","HLOSRVR1",78,0)
 .D ADDAC(.HLMSTATE) ;so that future duplicates can be detected
"RTN","HLOSRVR1",79,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR1",80,0)
 ;
"RTN","HLOSRVR1",81,0)
 D:'HLCSTATE("MESSAGE ENDED") CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",82,0)
 Q HLCSTATE("MESSAGE ENDED")
"RTN","HLOSRVR1",83,0)
 ;
"RTN","HLOSRVR1",84,0)
ADDAC(HLMSTATE) ;adds the AC xref for the message that was just received
"RTN","HLOSRVR1",85,0)
 ;The AC xref allows duplicates to be detected.
"RTN","HLOSRVR1",86,0)
 ;
"RTN","HLOSRVR1",87,0)
 N FROM
"RTN","HLOSRVR1",88,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",89,0)
 S ^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR1",90,0)
 Q
"RTN","HLOSRVR1",91,0)
 ;
"RTN","HLOSRVR1",92,0)
DUP(HLMSTATE) ;
"RTN","HLOSRVR1",93,0)
 ;Function returns 1 if the message is a duplicate and its ack (if requested) is found, 0 otherwise
"RTN","HLOSRVR1",94,0)
 ;Input:
"RTN","HLOSRVR1",95,0)
 ; HLMSTATE (pass by reference) the message being read
"RTN","HLOSRVR1",96,0)
 ;Output:
"RTN","HLOSRVR1",97,0)
 ;  Function returns 1 if the message is a duplicate, 0 otherwise
"RTN","HLOSRVR1",98,0)
 ;  HLMSTATE (pass by reference) IF the message is a duplicate:
"RTN","HLOSRVR1",99,0)
 ;     returns the prior MSA segment in HLMSTATE("MSA")
"RTN","HLOSRVR1",100,0)
 ;!!!! put back if original mode implemented
"RTN","HLOSRVR1",101,0)
 ;     If original mode returns the ien of the app ack in HLMSTATE("ACK BY IEN")
"RTN","HLOSRVR1",102,0)
 ;
"RTN","HLOSRVR1",103,0)
 N IEN,FROM,DUP
"RTN","HLOSRVR1",104,0)
 S (IEN,DUP)=0
"RTN","HLOSRVR1",105,0)
 ;
"RTN","HLOSRVR1",106,0)
 ;no way to determine!  Bad header will be rejected
"RTN","HLOSRVR1",107,0)
 Q:(HLMSTATE("ID")="") 0
"RTN","HLOSRVR1",108,0)
 ;
"RTN","HLOSRVR1",109,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",110,0)
 F  S IEN=$O(^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),IEN)) Q:'IEN  D  Q:DUP
"RTN","HLOSRVR1",111,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="NE" S DUP=1 Q
"RTN","HLOSRVR1",112,0)
 .;need the MSA to return
"RTN","HLOSRVR1",113,0)
 .D  Q
"RTN","HLOSRVR1",114,0)
 ..N NODE
"RTN","HLOSRVR1",115,0)
 ..S NODE=$P($G(^HLB(IEN,4)),"^",3,10)
"RTN","HLOSRVR1",116,0)
 ..S HLMSTATE("MSA",1)=$P(NODE,"|",2)
"RTN","HLOSRVR1",117,0)
 ..Q:$L(HLMSTATE("MSA",1))'=2
"RTN","HLOSRVR1",118,0)
 ..S HLMSTATE("MSA",2)=$P(NODE,"|",3)
"RTN","HLOSRVR1",119,0)
 ..S HLMSTATE("MSA",3)=$P(NODE,"|",4,10)
"RTN","HLOSRVR1",120,0)
 ..S DUP=1
"RTN","HLOSRVR1",121,0)
 ;
"RTN","HLOSRVR1",122,0)
 Q DUP
"RTN","HLOSRVR1",123,0)
 ;
"RTN","HLOSRVR1",124,0)
CHECKMSG(HLMSTATE) ;
"RTN","HLOSRVR1",125,0)
 ;Checks the header & MSA segment, sets HLMSTATE("STATUS","ACTION") if the message needs to be passed, determines if completion status should be set
"RTN","HLOSRVR1",126,0)
 ;Input:
"RTN","HLOSRVR1",127,0)
 ;  HLMSTATE("HDR") - the parsed header segment
"RTN","HLOSRVR1",128,0)
 ;Output:
"RTN","HLOSRVR1",129,0)
 ;  HLMSTATE("STATUS")="SE" if an error is detected
"RTN","HLOSRVR1",130,0)
 ;  HLMSTATE("STATUS","QUEUE") queue to put the message on
"RTN","HLOSRVR1",131,0)
 ;  HLMSTATE("STATUS","ACTION")  <tag^rtn> that is the processing routine for the receiving application
"RTN","HLOSRVR1",132,0)
 ;  HLMSTATE("MSA") - MSA(1)=accept code to be returned, MSA(3)= error txt
"RTN","HLOSRVR1",133,0)
 ;
"RTN","HLOSRVR1",134,0)
 N WANTACK,PASS,ACTION,QUEUE
"RTN","HLOSRVR1",135,0)
 M HDR=HLMSTATE("HDR")
"RTN","HLOSRVR1",136,0)
 I HDR("ACCEPT ACK TYPE")="NE",'HLMSTATE("ORIGINAL MODE") D
"RTN","HLOSRVR1",137,0)
 .S WANTACK=0
"RTN","HLOSRVR1",138,0)
 E  D
"RTN","HLOSRVR1",139,0)
 .S WANTACK=1
"RTN","HLOSRVR1",140,0)
 I HLMSTATE("ORIGINAL MODE") S HLMSTATE("MSA",1)="AE",HLMSTATE("MSA",3)="THIS INTERFACE DOES NOT IMPLEMENT ORIGINAL MODE APPLICATION ACKOWLEDGMENTS",HLMSTATE("STATUS")="SE" Q
"RTN","HLOSRVR1",141,0)
 I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE),$G(HLMSTATE("ACK TO"))="" S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="SE" Q
"RTN","HLOSRVR1",142,0)
 S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",143,0)
 ;
"RTN","HLOSRVR1",144,0)
 ;If this is an application ack, does the original message exist?
"RTN","HLOSRVR1",145,0)
 I $G(HLMSTATE("ACK TO"))]"" D  Q:HLMSTATE("STATUS")="SE"
"RTN","HLOSRVR1",146,0)
 .N NODE
"RTN","HLOSRVR1",147,0)
 .S:+$G(HLMSTATE("ACK TO","IEN")) NODE=$G(^HLB(+HLMSTATE("ACK TO","IEN"),0))
"RTN","HLOSRVR1",148,0)
 .I $G(NODE)="" S HLMSTATE("STATUS")="SE",HLMSTATE("ACK TO","IEN")=""  S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE TO APPLICATION ACKNOWLEDGMENT NOT FOUND" Q
"RTN","HLOSRVR1",149,0)
 .I ($P(NODE,"^",11)]"") S HLMSTATE("STATUS","ACTION")=$P(NODE,"^",10,11),HLMSTATE("STATUS","QUEUE")=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")
"RTN","HLOSRVR1",150,0)
 ;
"RTN","HLOSRVR1",151,0)
 I HDR("PROCESSING ID")'=HLCSTATE("SYSTEM","PROCESSING ID") S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("STATUS")="SE",HLMSTATE("MSA",3)="SYSTEM PROCESSING ID="_HLCSTATE("SYSTEM","PROCESSING ID") Q
"RTN","HLOSRVR1",152,0)
 ;
"RTN","HLOSRVR1",153,0)
 ;
"RTN","HLOSRVR1",154,0)
 ;wrong receiving facility?  This is hard to check if the sender is not VistA, because the HL7 standard permits different coding systems to be used. This check is only for DNS or station number.
"RTN","HLOSRVR1",155,0)
 S PASS=0
"RTN","HLOSRVR1",156,0)
 D
"RTN","HLOSRVR1",157,0)
 .;if its an ack to an existing message, don't check the receiving facility
"RTN","HLOSRVR1",158,0)
 .I $G(HLMSTATE("ACK TO"))]"" S PASS=1 Q
"RTN","HLOSRVR1",159,0)
 .I HDR("RECEIVING FACILITY",1)=HLCSTATE("SYSTEM","STATION") S PASS=1 Q
"RTN","HLOSRVR1",160,0)
 .I HDR("RECEIVING FACILITY",3)'="DNS" S PASS=1 Q
"RTN","HLOSRVR1",161,0)
 .I HDR("RECEIVING FACILITY",2)="" S PASS=1 Q
"RTN","HLOSRVR1",162,0)
 .I $P(HDR("RECEIVING FACILITY",2),":")[HLCSTATE("SYSTEM","DOMAIN") S PASS=1 Q
"RTN","HLOSRVR1",163,0)
 .I HLCSTATE("SYSTEM","DOMAIN")[$P(HDR("RECEIVING FACILITY",2),":") S PASS=1 Q
"RTN","HLOSRVR1",164,0)
 I 'PASS S HLMSTATE("STATUS")="SE",HLMSTATE("MSA",3)="RECEIVING FACILITY IS "_HLCSTATE("SYSTEM","DOMAIN") S:WANTACK HLMSTATE("MSA",1)="CE"
"RTN","HLOSRVR1",165,0)
 I PASS,WANTACK S HLMSTATE("MSA",1)="CA"
"RTN","HLOSRVR1",166,0)
 Q
"RTN","HLOSRVR1",167,0)
 ;
"RTN","HLOSRVR1",168,0)
DEL777(IEN777) ;delete a record from file 777 where the read did not complete
"RTN","HLOSRVR1",169,0)
 ;
"RTN","HLOSRVR1",170,0)
 K ^HLA(IEN777,0)
"RTN","HLOSRVR1",171,0)
 Q
"RTN","HLOSRVR1",172,0)
DEL778(IEN778) ;delete a record from file 778 where the read did not complete
"RTN","HLOSRVR1",173,0)
 ;
"RTN","HLOSRVR1",174,0)
 K ^HLB(IEN778,0)
"RTN","HLOSRVR1",175,0)
 Q
"RTN","HLOSRVR1",176,0)
 ;
"RTN","HLOSRVR1",177,0)
SPLITHDR(HDR) ;
"RTN","HLOSRVR1",178,0)
 ;splits hdr segment into two lines, first being just components 1-6
"RTN","HLOSRVR1",179,0)
 ;
"RTN","HLOSRVR1",180,0)
 N TEMP,FS
"RTN","HLOSRVR1",181,0)
 D SQUISH(.HDR)
"RTN","HLOSRVR1",182,0)
 S FS=$E(HDR(1),4)
"RTN","HLOSRVR1",183,0)
 S TEMP(1)=$P(HDR(1),FS,1,6)
"RTN","HLOSRVR1",184,0)
 S TEMP(2)=""
"RTN","HLOSRVR1",185,0)
 I $L(TEMP(1))<$L(HDR(1)) S TEMP(2)=FS_$P(HDR(1),FS,7,20)
"RTN","HLOSRVR1",186,0)
 S HDR(2)=TEMP(2)_$G(HDR(2))
"RTN","HLOSRVR1",187,0)
 S HDR(1)=TEMP(1)
"RTN","HLOSRVR1",188,0)
 Q
"RTN","HLOSRVR1",189,0)
 ;
"RTN","HLOSRVR1",190,0)
SQUISH(SEG) ;
"RTN","HLOSRVR1",191,0)
 ;squish the header segment =SEG(i) into at most 2 lines
"RTN","HLOSRVR1",192,0)
 ;
"RTN","HLOSRVR1",193,0)
 Q:'$O(SEG(1))
"RTN","HLOSRVR1",194,0)
 I '$O(SEG(2)) D  Q
"RTN","HLOSRVR1",195,0)
 .N LEN
"RTN","HLOSRVR1",196,0)
 .S LEN=$L(SEG(1))
"RTN","HLOSRVR1",197,0)
 .Q:LEN>255
"RTN","HLOSRVR1",198,0)
 .S SEG(1)=SEG(1)_$E(SEG(2),1,256-LEN)
"RTN","HLOSRVR1",199,0)
 .S SEG(2)=$E(SEG(2),257-LEN,99999)
"RTN","HLOSRVR1",200,0)
 ;
"RTN","HLOSRVR1",201,0)
 N A,DONE,I
"RTN","HLOSRVR1",202,0)
 S (I,DONE)=0
"RTN","HLOSRVR1",203,0)
 S A(1)=SEG(1) K SEG(1)
"RTN","HLOSRVR1",204,0)
 F  S I=$O(SEG(I)) Q:'I  D  Q:DONE
"RTN","HLOSRVR1",205,0)
 .N LEN
"RTN","HLOSRVR1",206,0)
 .S LEN=$L(A(1))
"RTN","HLOSRVR1",207,0)
 .I (LEN+$L(SEG(I)))>256 D
"RTN","HLOSRVR1",208,0)
 ..S A(1)=A(1)_$E(SEG(I),1,256-LEN)
"RTN","HLOSRVR1",209,0)
 ..S A(2)=$E(SEG(I),257-LEN,99999)
"RTN","HLOSRVR1",210,0)
 ..S DONE=1
"RTN","HLOSRVR1",211,0)
 .E  D
"RTN","HLOSRVR1",212,0)
 ..S A(1)=A(1)_SEG(I)
"RTN","HLOSRVR1",213,0)
 .K SEG(I)
"RTN","HLOSRVR1",214,0)
 ;
"RTN","HLOSRVR1",215,0)
 ;if there are any lines left in SEG(), put them in A(2)
"RTN","HLOSRVR1",216,0)
 F  S I=$O(SEG(I)) Q:'I  D  Q:DONE
"RTN","HLOSRVR1",217,0)
 .N LEN
"RTN","HLOSRVR1",218,0)
 .S LEN=$L($G(A(2)))
"RTN","HLOSRVR1",219,0)
 .I (LEN+$L(SEG(I)))>256 D
"RTN","HLOSRVR1",220,0)
 ..S A(2)=A(2)_$E(SEG(I),1,256-LEN)
"RTN","HLOSRVR1",221,0)
 ..S DONE=1
"RTN","HLOSRVR1",222,0)
 .E  D
"RTN","HLOSRVR1",223,0)
 ..S A(2)=$G(A(2))_SEG(I)
"RTN","HLOSRVR1",224,0)
 .K SEG(I)
"RTN","HLOSRVR1",225,0)
 K SEG
"RTN","HLOSRVR1",226,0)
 M SEG=A
"RTN","HLOSRVR1",227,0)
 Q
"RTN","HLOSRVR1",228,0)
 ;
"RTN","HLOSRVR1",229,0)
ERROR ;error trap
"RTN","HLOSRVR1",230,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOSRVR1",231,0)
 D END^HLOSRVR
"RTN","HLOSRVR1",232,0)
 ;
"RTN","HLOSRVR1",233,0)
 ;while debugging quit on all errors
"RTN","HLOSRVR1",234,0)
 I $G(^HLTMP("LOG ALL ERRORS")) D ^%ZTER QUIT
"RTN","HLOSRVR1",235,0)
 ;
"RTN","HLOSRVR1",236,0)
 ;don't log these common errors
"RTN","HLOSRVR1",237,0)
 I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D
"RTN","HLOSRVR1",238,0)
 .;
"RTN","HLOSRVR1",239,0)
 E  D
"RTN","HLOSRVR1",240,0)
 .D ^%ZTER
"RTN","HLOSRVR1",241,0)
 ;
"RTN","HLOSRVR1",242,0)
 ;concurrent server connections (multi-listener) should stop execution, only a single server may continue
"RTN","HLOSRVR1",243,0)
 Q:$P($G(HLCSTATE("LINK","SERVER")),"^",2)'="S"
"RTN","HLOSRVR1",244,0)
 ;
"RTN","HLOSRVR1",245,0)
 ;a lot of errors of the same time may indicate an endless loop, so keep a count
"RTN","HLOSRVR1",246,0)
 S ^TMP("HL7 ERRORS",$J,$ECODE)=$G(^TMP("HL7 ERRORS",$J,$ECODE))+1
"RTN","HLOSRVR1",247,0)
 ;
"RTN","HLOSRVR1",248,0)
 I ($G(^TMP("HL7 ERRORS",$J,$ECODE))>100) K ^TMP("HL7 ERRORS",$J) QUIT
"RTN","HLOSRVR1",249,0)
 ;
"RTN","HLOSRVR1",250,0)
 ;resume execution for the single listener
"RTN","HLOSRVR1",251,0)
 D UNWIND^%ZTER
"RTN","HLOSRVR1",252,0)
 Q
"RTN","HLOSRVR2")
0^13^B13997562
"RTN","HLOSRVR2",1,0)
HLOSRVR2 ;ALB/CJM-HL7 - Sends an application ack over an open connection, for original mode ;02/04/2004
"RTN","HLOSRVR2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**131**;Oct 13, 1995;Build 10
"RTN","HLOSRVR2",3,0)
 ;
"RTN","HLOSRVR2",4,0)
NEWMSG(HLCSTATE,HLMSTATE,HDR) ;
"RTN","HLOSRVR2",5,0)
 ;initialize the HLMSTATE array after reading the header
"RTN","HLOSRVR2",6,0)
 ;Inputs:
"RTN","HLOSRVR2",7,0)
 ;  HLCSTATE (pass by reference)
"RTN","HLOSRVR2",8,0)
 ;  HDR (pass by reference) parsed header
"RTN","HLOSRVR2",9,0)
 ;Output:
"RTN","HLOSRVR2",10,0)
 ;  HLMSTATE (pass by reference)
"RTN","HLOSRVR2",11,0)
 ;
"RTN","HLOSRVR2",12,0)
 K HLMSTATE
"RTN","HLOSRVR2",13,0)
 S HLMSTATE("IEN")=""
"RTN","HLOSRVR2",14,0)
 S HLMSTATE("BODY")=""
"RTN","HLOSRVR2",15,0)
 S HLMSTATE("DIRECTION")="IN"
"RTN","HLOSRVR2",16,0)
 S HLMSTATE("CURRENT SEGMENT")=0 ;no segments in cache
"RTN","HLOSRVR2",17,0)
 S HLMSTATE("UNSTORED LINES")=1 ;just the header in cache so far
"RTN","HLOSRVR2",18,0)
 S HLMSTATE("LINE COUNT")=0 ;no lines within message stored to disk
"RTN","HLOSRVR2",19,0)
 I HDR("SEGMENT TYPE")="BHS" D
"RTN","HLOSRVR2",20,0)
 .S HLMSTATE("BATCH")=1
"RTN","HLOSRVR2",21,0)
 .S HLMSTATE("ID")=HDR("BATCH CONTROL ID")
"RTN","HLOSRVR2",22,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0 ;no messages in batch
"RTN","HLOSRVR2",23,0)
 .S HLMSTATE("UNSTORED MSH")=0
"RTN","HLOSRVR2",24,0)
 E  D
"RTN","HLOSRVR2",25,0)
 .S HLMSTATE("BATCH")=0
"RTN","HLOSRVR2",26,0)
 .S HLMSTATE("ID")=HDR("MESSAGE CONTROL ID")
"RTN","HLOSRVR2",27,0)
 M HLMSTATE("HDR")=HDR
"RTN","HLOSRVR2",28,0)
 M HLMSTATE("SYSTEM")=HLCSTATE("SYSTEM")
"RTN","HLOSRVR2",29,0)
 S HLMSTATE("STATUS")=""
"RTN","HLOSRVR2",30,0)
 S HLMSTATE("STATUS","QUEUE")=""
"RTN","HLOSRVR2",31,0)
 S HLMSTATE("STATUS","ACTION")=""
"RTN","HLOSRVR2",32,0)
 S HLMSTATE("STATUS","LINK NAME")=HLCSTATE("LINK","NAME")
"RTN","HLOSRVR2",33,0)
 S HLMSTATE("STATUS","PORT")=$P(HDR("SENDING FACILITY",2),":",2)
"RTN","HLOSRVR2",34,0)
 ;
"RTN","HLOSRVR2",35,0)
 ;if this is a batch, and it references another batch, assume it is a b.
"RTN","HLOSRVR2",36,0)
 I HLMSTATE("BATCH"),HLMSTATE("ID")]"" D
"RTN","HLOSRVR2",37,0)
 .N IEN
"RTN","HLOSRVR2",38,0)
 .S HLMSTATE("ACK TO")=HLMSTATE("ID")
"RTN","HLOSRVR2",39,0)
 .S HLMSTATE("ACK TO","STATUS")="SU"
"RTN","HLOSRVR2",40,0)
 .S IEN=$O(^HLB("B",HLMSTATE("ID"),0))
"RTN","HLOSRVR2",41,0)
 .I IEN S HLMSTATE("ACK TO","IEN")=IEN_"^"
"RTN","HLOSRVR2",42,0)
 E  S HLMSTATE("ACK TO")=""
"RTN","HLOSRVR2",43,0)
 I 'HLMSTATE("BATCH"),HDR("ACCEPT ACK TYPE")="",HDR("APP ACK TYPE")="" D
"RTN","HLOSRVR2",44,0)
 .S HLMSTATE("ORIGINAL MODE")=1
"RTN","HLOSRVR2",45,0)
 E  D
"RTN","HLOSRVR2",46,0)
 .S HLMSTATE("ORIGINAL MODE")=0
"RTN","HLOSRVR2",47,0)
 N I F I=1,3 S HLMSTATE("MSA",I)=""
"RTN","HLOSRVR2",48,0)
 S HLMSTATE("MSA",2)=HLMSTATE("ID")
"RTN","HLOSRVR2",49,0)
 Q
"RTN","HLOSRVR2",50,0)
 ;
"RTN","HLOSRVR2",51,0)
ACKNOW(MSG,ERROR) ;
"RTN","HLOSRVR2",52,0)
 ;Sends the messge immediately if there is an open connection, otherwise
"RTN","HLOSRVR2",53,0)
 ;will return an error.
"RTN","HLOSRVR2",54,0)
 ;
"RTN","HLOSRVR2",55,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOSRVR2"
"RTN","HLOSRVR2",56,0)
 N SENT
"RTN","HLOSRVR2",57,0)
 S SENT=0,ERROR=""
"RTN","HLOSRVR2",58,0)
 I '$G(HLCSTATE("CONNECTED")) D
"RTN","HLOSRVR2",59,0)
 .S ERROR="NOT CONNECTED"
"RTN","HLOSRVR2",60,0)
 .S MSG("STATUS")="TF"
"RTN","HLOSRVR2",61,0)
 E  S MSG("STATUS")="SU"
"RTN","HLOSRVR2",62,0)
 S:'$G(MSG("DT/TM CREATED")) MSG("DT/TM CREATED")=$$NOW^XLFDT
"RTN","HLOSRVR2",63,0)
 S MSG("STATUS","PURGE")=$$FMADD^XLFDT(MSG("DT/TM CREATED"),$S($G(HLCSTATE("ERROR PURGE")):HLCSTATE("ERROR PURGE"),1:7))
"RTN","HLOSRVR2",64,0)
 D
"RTN","HLOSRVR2",65,0)
 .I $G(MSG("UNSTORED LINES")),'$$SAVEMSG^HLOF777(.MSG) S ERROR="$$SAVE^HLOF777 FAILED!" Q
"RTN","HLOSRVR2",66,0)
 .I '$$SAVEMSG^HLOF778(.MSG) S ERROR="$$SAVE^HLOF778 FAILED!" Q
"RTN","HLOSRVR2",67,0)
 .Q:MSG("STATUS")'="SU"
"RTN","HLOSRVR2",68,0)
 .I '$$WRITEMSG^HLOCLNT1(.HLCSTATE,.MSG) S ERROR="TRANSMISSION FAILURE" Q
"RTN","HLOSRVR2",69,0)
 .S SENT=1
"RTN","HLOSRVR2",70,0)
 .D COUNT^HLOSTAT(.HLCSTATE,ACK("HDR","RECEIVING APPLICATION"),ACK("HDR","SENDING APPLICATION"),ACK("HDR","MESSAGE TYPE")_"~"_ACK("HDR","EVENT"))
"RTN","HLOSRVR2",71,0)
 ;
"RTN","HLOSRVR2",72,0)
END ;
"RTN","HLOSRVR2",73,0)
 I 'SENT,MSG("STATUS")="SU",$G(MSG("IEN")) D
"RTN","HLOSRVR2",74,0)
 .Q:'$D(^HLB(MSG("IEN"),0))
"RTN","HLOSRVR2",75,0)
 .S MSG("STATUS")="TF"
"RTN","HLOSRVR2",76,0)
 .S MSG("STATUS","ERROR TEXT")=ERROR
"RTN","HLOSRVR2",77,0)
 .S $P(^HLB(MSG("IEN"),0),"^",20)=MSG("STATUS")
"RTN","HLOSRVR2",78,0)
 .S $P(^HLB(MSG("IEN"),0),"^",21)=MSG("STATUS","ERROR TEXT")
"RTN","HLOSRVR2",79,0)
 .S ^HLB("ERRORS","TF",$S($L($G(MSG("HDR","RECEIVING APPLICATION"))):MSG("HDR","RECEIVING APPLICATION"),1:"UNKNOWN"),MSG("DT/TM CREATED"),IEN)=""
"RTN","HLOSRVR2",80,0)
 ;
"RTN","HLOSRVR2",81,0)
 Q SENT
"RTN","HLOSRVR2",82,0)
 ;
"RTN","HLOSRVR2",83,0)
ERROR ;error trap for ACKNOW
"RTN","HLOSRVR2",84,0)
 S SENT=0,ERROR="TRANSMISSION FAILURE:"_$P($ECODE,",",1,2)
"RTN","HLOSRVR2",85,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOSRVR2",86,0)
 ;
"RTN","HLOSRVR2",87,0)
 ;don't log some common errors
"RTN","HLOSRVR2",88,0)
 I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D
"RTN","HLOSRVR2",89,0)
 .;nothing!
"RTN","HLOSRVR2",90,0)
 E  D
"RTN","HLOSRVR2",91,0)
 .D ^%ZTER
"RTN","HLOSRVR2",92,0)
 G END^HLOSRVR2
"RTN","HLOSRVR2",93,0)
 Q
"RTN","HLOSTAT")
0^12^B55442954^B55434883
"RTN","HLOSTAT",1,0)
HLOSTAT ;ALB/CJM- HLO STATISTICS- 10/4/94 1pm
"RTN","HLOSTAT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**130,131**;Oct 13, 1995;Build 10
"RTN","HLOSTAT",3,0)
 ;
"RTN","HLOSTAT",4,0)
 ;
"RTN","HLOSTAT",5,0)
COUNT(HLCSTATE,RAP,SAP,TYPE) ;
"RTN","HLOSTAT",6,0)
 S:RAP="" RAP="UNKNOWN"
"RTN","HLOSTAT",7,0)
 S:SAP="" SAP="UNKNOWN"
"RTN","HLOSTAT",8,0)
 S:$L(TYPE)<2 TYPE="UNKNOWN"
"RTN","HLOSTAT",9,0)
 S HLCSTATE("COUNTS")=$G(HLCSTATE("COUNTS"))+1,HLCSTATE("COUNTS",SAP,RAP,TYPE)=1+$G(HLCSTATE("COUNTS",SAP,RAP,TYPE))
"RTN","HLOSTAT",10,0)
 Q
"RTN","HLOSTAT",11,0)
SAVECNTS(HLCSTATE) ;
"RTN","HLOSTAT",12,0)
 N TIME,DIR,RAP,SAP,TYPE,COUNT
"RTN","HLOSTAT",13,0)
 Q:'$G(HLCSTATE("COUNTS"))
"RTN","HLOSTAT",14,0)
 S TIME=$E($$NOW^XLFDT,1,10)
"RTN","HLOSTAT",15,0)
 S DIR=$S(+$G(HLCSTATE("SERVER")):"IN",1:"OUT")
"RTN","HLOSTAT",16,0)
 I $G(HLCSTATE("COUNTS","ACKS")) D
"RTN","HLOSTAT",17,0)
 .I $$INC^HLOSITE($NA(^HLSTATS($S(DIR="IN":"OUT",1:"IN"),"HOURLY",+TIME,"ACCEPT ACK")),HLCSTATE("COUNTS","ACKS"))
"RTN","HLOSTAT",18,0)
 S SAP=""
"RTN","HLOSTAT",19,0)
 F  S SAP=$O(HLCSTATE("COUNTS",SAP)) Q:SAP=""  D
"RTN","HLOSTAT",20,0)
 .S RAP=""
"RTN","HLOSTAT",21,0)
 .F  S RAP=$O(HLCSTATE("COUNTS",SAP,RAP)) Q:RAP=""  D
"RTN","HLOSTAT",22,0)
 ..S TYPE=""
"RTN","HLOSTAT",23,0)
 ..F  S TYPE=$O(HLCSTATE("COUNTS",SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOSTAT",24,0)
 ...S COUNT=HLCSTATE("COUNTS",SAP,RAP,TYPE)
"RTN","HLOSTAT",25,0)
 ...I $$INC^HLOSITE($NA(^HLSTATS(DIR,"HOURLY",+TIME,SAP,RAP,TYPE)),COUNT)
"RTN","HLOSTAT",26,0)
 K HLCSTATE("COUNTS") S HLCSTATE("COUNTS")=0
"RTN","HLOSTAT",27,0)
 Q
"RTN","HLOSTAT",28,0)
 ;
"RTN","HLOSTAT",29,0)
TOTAL(WORK) ;totals hours into days and days into months
"RTN","HLOSTAT",30,0)
 ;
"RTN","HLOSTAT",31,0)
 N RAP,SAP,TIME,LIMIT,DIR,COUNT,MONTH,START,END
"RTN","HLOSTAT",32,0)
 ;
"RTN","HLOSTAT",33,0)
 ;start totaling the next day after last date totaled
"RTN","HLOSTAT",34,0)
 S START=$G(^HLSTATS("END DATE"))
"RTN","HLOSTAT",35,0)
 S:START START=$$FMADD^XLFDT(START,1)
"RTN","HLOSTAT",36,0)
 ;
"RTN","HLOSTAT",37,0)
 ;end totaling in the last hour of yesterday and save it so that the next run knows where to start
"RTN","HLOSTAT",38,0)
 S END=$$FMADD^XLFDT($$DT^XLFDT,-1)
"RTN","HLOSTAT",39,0)
 S ^HLSTATS("END DATE")=END
"RTN","HLOSTAT",40,0)
 S END=END+.24
"RTN","HLOSTAT",41,0)
 ;
"RTN","HLOSTAT",42,0)
 ;total hours into days
"RTN","HLOSTAT",43,0)
 S LIMIT=$$FMADD^XLFDT($$DT^XLFDT,,-48) ;save ~48 hours of hourly data
"RTN","HLOSTAT",44,0)
 F DIR="IN","OUT" D
"RTN","HLOSTAT",45,0)
 .S TIME=0
"RTN","HLOSTAT",46,0)
 .F  S TIME=$O(^HLSTATS(DIR,"HOURLY",TIME)) Q:'TIME  Q:(TIME>END)  D
"RTN","HLOSTAT",47,0)
 ..D:'(TIME<START)
"RTN","HLOSTAT",48,0)
 ...S ^HLSTATS(DIR,"DAILY",$P(TIME,"."),"ACCEPT ACK")=$G(^HLSTATS(DIR,"DAILY",$P(TIME,"."),"ACCEPT ACK"))+$G(^HLSTATS(DIR,"HOURLY",TIME,"ACCEPT ACK"))
"RTN","HLOSTAT",49,0)
 ...S SAP=""
"RTN","HLOSTAT",50,0)
 ...F  S SAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP)) Q:SAP=""  D
"RTN","HLOSTAT",51,0)
 ....S RAP=""
"RTN","HLOSTAT",52,0)
 ....F  S RAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP)) Q:RAP=""  D
"RTN","HLOSTAT",53,0)
 .....S TYPE=""
"RTN","HLOSTAT",54,0)
 .....F  S TYPE=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOSTAT",55,0)
 ......S COUNT=$G(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE))
"RTN","HLOSTAT",56,0)
 ......S ^HLSTATS(DIR,"DAILY",$P(TIME,"."),SAP,RAP,TYPE)=$G(^HLSTATS(DIR,"DAILY",$P(TIME,"."),SAP,RAP,TYPE))+COUNT
"RTN","HLOSTAT",57,0)
 ..;get rid of old hourly stats
"RTN","HLOSTAT",58,0)
 ..K:(TIME<LIMIT) ^HLSTATS(DIR,"HOURLY",TIME)
"RTN","HLOSTAT",59,0)
 ;
"RTN","HLOSTAT",60,0)
 ;total days into months
"RTN","HLOSTAT",61,0)
 S LIMIT=$$FMADD^XLFDT($$DT^XLFDT,-30) ;save ~30 days of daily data
"RTN","HLOSTAT",62,0)
 F DIR="IN","OUT" D
"RTN","HLOSTAT",63,0)
 .S TIME=0
"RTN","HLOSTAT",64,0)
 .F  S TIME=$O(^HLSTATS(DIR,"DAILY",TIME)) Q:'TIME  Q:(TIME>END)  D
"RTN","HLOSTAT",65,0)
 ..D:'(TIME<START)
"RTN","HLOSTAT",66,0)
 ...S MONTH=$E(TIME,1,5)
"RTN","HLOSTAT",67,0)
 ...S ^HLSTATS(DIR,"MONTHLY",MONTH,"ACCEPT ACK")=$G(^HLSTATS(DIR,"MONTHLY",MONTH,"ACCEPT ACK"))+$G(^HLSTATS(DIR,"DAILY",TIME,"ACCEPT ACK"))
"RTN","HLOSTAT",68,0)
 ...S SAP=""
"RTN","HLOSTAT",69,0)
 ...F  S SAP=$O(^HLSTATS(DIR,"DAILY",TIME,SAP)) Q:SAP=""  D
"RTN","HLOSTAT",70,0)
 ....S RAP=""
"RTN","HLOSTAT",71,0)
 ....F  S RAP=$O(^HLSTATS(DIR,"DAILY",TIME,SAP,RAP)) Q:RAP=""  D
"RTN","HLOSTAT",72,0)
 .....S TYPE=""
"RTN","HLOSTAT",73,0)
 .....F  S TYPE=$O(^HLSTATS(DIR,"DAILY",TIME,SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOSTAT",74,0)
 ......S COUNT=$G(^HLSTATS(DIR,"DAILY",TIME,SAP,RAP,TYPE))
"RTN","HLOSTAT",75,0)
 ......S ^HLSTATS(DIR,"MONTHLY",MONTH,SAP,RAP,TYPE)=$G(^HLSTATS(DIR,"MONTHLY",MONTH,SAP,RAP,TYPE))+COUNT
"RTN","HLOSTAT",76,0)
 ..K:(TIME<LIMIT) ^HLSTATS(DIR,"DAILY",TIME)
"RTN","HLOSTAT",77,0)
 Q
"RTN","HLOSTAT",78,0)
REPORT ;Interactive option for printing the message statistics report
"RTN","HLOSTAT",79,0)
 N DIR,TYPE,START,END
"RTN","HLOSTAT",80,0)
 W !,"Hourly, daily, and monthly statistics are maintained."
"RTN","HLOSTAT",81,0)
 W !,"Hourly statistics are available for approximately the last 24 hours."
"RTN","HLOSTAT",82,0)
 W !,"Daily statistics are available for approximately the last 30 days."
"RTN","HLOSTAT",83,0)
 W !,"Monthly statistics are kept indefinitely"
"RTN","HLOSTAT",84,0)
 S DIR(0)="S^h:HOURLY;d:DAILY;m:MONTHLY"
"RTN","HLOSTAT",85,0)
 S DIR("A")="Which type of statistics should be reported"
"RTN","HLOSTAT",86,0)
 S DIR("B")="MONTHLY"
"RTN","HLOSTAT",87,0)
 D ^DIR
"RTN","HLOSTAT",88,0)
 Q:$D(DIRUT)
"RTN","HLOSTAT",89,0)
 I Y'="h",Y'="d",Y'="m" Q
"RTN","HLOSTAT",90,0)
 S TYPE=$S(Y="h":"HOURLY",Y="d":"DAILY",1:"MONTHLY")
"RTN","HLOSTAT",91,0)
 S START=$S(TYPE="HOURLY":$E($$FMADD^XLFDT($$NOW^XLFDT,,-24),1,10),TYPE="DAILY":$$FMADD^XLFDT(DT,-7),1:$E($$FMADD^XLFDT(DT,-30),1,5)_"01")
"RTN","HLOSTAT",92,0)
 S START=$$ASKBEGIN^HLOUSR2(START)
"RTN","HLOSTAT",93,0)
 Q:'START
"RTN","HLOSTAT",94,0)
 S END=$$ASKEND^HLOUSR2(START)
"RTN","HLOSTAT",95,0)
 Q:'END
"RTN","HLOSTAT",96,0)
 S:TYPE="MONTHLY" START=$E(START,1,5)_"00"
"RTN","HLOSTAT",97,0)
 S:TYPE="DAILY" START=$E(START,1,7)
"RTN","HLOSTAT",98,0)
 S:TYPE="HOURLY" START=$E(START,1,10)
"RTN","HLOSTAT",99,0)
 D:$$DEVICE() PRINT(TYPE,START,END)
"RTN","HLOSTAT",100,0)
 Q
"RTN","HLOSTAT",101,0)
 ;
"RTN","HLOSTAT",102,0)
QUE ;entry point for queuing the message statistics report
"RTN","HLOSTAT",103,0)
 ;
"RTN","HLOSTAT",104,0)
 D PRINT($G(HLOPARMS("STATISTICS TYPE")),$G(HLOPARMS("START DT/TM")),$G(HLOPARMS("END DT/TM")))
"RTN","HLOSTAT",105,0)
 Q
"RTN","HLOSTAT",106,0)
 ;
"RTN","HLOSTAT",107,0)
PRINT(STATTYPE,START,END) ;
"RTN","HLOSTAT",108,0)
 ;
"RTN","HLOSTAT",109,0)
 N RAP,SAP,TIME,DIR,COUNT,PAGE,CRT,QUIT
"RTN","HLOSTAT",110,0)
 S QUIT=0
"RTN","HLOSTAT",111,0)
 S CRT=$S($E(IOST,1,2)="C-":1,1:0)
"RTN","HLOSTAT",112,0)
 ;
"RTN","HLOSTAT",113,0)
 U IO
"RTN","HLOSTAT",114,0)
 W:CRT @IOF
"RTN","HLOSTAT",115,0)
 W "HLO MESSAGING STATISTICS REPORT ",$$FMTE^XLFDT($$NOW^XLFDT),?70,"Page 1"
"RTN","HLOSTAT",116,0)
 D LINE($$LJ("Type:",15)_STATTYPE)
"RTN","HLOSTAT",117,0)
 D LINE($$LJ("Beginning:",15)_$S(STATTYPE="MONTHLY":$$FMTE^XLFDT(START),1:$$FMTE^XLFDT(START)))
"RTN","HLOSTAT",118,0)
 D LINE($$LJ("Ending:",15)_$$FMTE^XLFDT(END))
"RTN","HLOSTAT",119,0)
 S PAGE=1
"RTN","HLOSTAT",120,0)
 ;
"RTN","HLOSTAT",121,0)
 ;
"RTN","HLOSTAT",122,0)
 F DIR="IN","OUT" D  Q:QUIT
"RTN","HLOSTAT",123,0)
 .N TOTAL
"RTN","HLOSTAT",124,0)
 .S TOTAL=0
"RTN","HLOSTAT",125,0)
 .D LINE(" ")
"RTN","HLOSTAT",126,0)
 .S TIME=START
"RTN","HLOSTAT",127,0)
 .S:STATTYPE="MONTHLY" TIME=$E(TIME,1,5)
"RTN","HLOSTAT",128,0)
 .S TIME=TIME-.0001
"RTN","HLOSTAT",129,0)
 .D LINE($S(DIR="IN":"Incoming Messages:",1:"Outgoing Messages:"))
"RTN","HLOSTAT",130,0)
 .Q:QUIT
"RTN","HLOSTAT",131,0)
 .F  S TIME=$O(^HLSTATS(DIR,STATTYPE,TIME)) Q:((TIME>$G(END))&$G(END))  Q:'TIME  D  Q:QUIT
"RTN","HLOSTAT",132,0)
 ..N SUBTOTAL
"RTN","HLOSTAT",133,0)
 ..S SUBTOTAL=0
"RTN","HLOSTAT",134,0)
 ..D LINE(" ")
"RTN","HLOSTAT",135,0)
 ..Q:QUIT
"RTN","HLOSTAT",136,0)
 ..D LINE("     Time Period: "_$S(STATTYPE="MONTHLY":$$FMTE^XLFDT(TIME_"00"),1:$$FMTE^XLFDT(TIME)))
"RTN","HLOSTAT",137,0)
 ..Q:QUIT
"RTN","HLOSTAT",138,0)
 ..S COUNT=$G(^HLSTATS(DIR,STATTYPE,TIME,"ACCEPT ACK"))
"RTN","HLOSTAT",139,0)
 ..I COUNT D  Q:QUIT
"RTN","HLOSTAT",140,0)
 ...D LINE(" ")
"RTN","HLOSTAT",141,0)
 ...Q:QUIT
"RTN","HLOSTAT",142,0)
 ...D LINE("          Accept Acknowledgments by All Applications          Count:"_$$RJ(COUNT,10))
"RTN","HLOSTAT",143,0)
 ...Q:QUIT
"RTN","HLOSTAT",144,0)
 ...D LINE(" ")
"RTN","HLOSTAT",145,0)
 ..S SAP=""
"RTN","HLOSTAT",146,0)
 ..F  S SAP=$O(^HLSTATS(DIR,STATTYPE,TIME,SAP)) Q:SAP=""  D  Q:QUIT
"RTN","HLOSTAT",147,0)
 ...Q:SAP="ACCEPT ACK"
"RTN","HLOSTAT",148,0)
 ...D LINE("          Sending Application: "_SAP)
"RTN","HLOSTAT",149,0)
 ...Q:QUIT
"RTN","HLOSTAT",150,0)
 ...S RAP=""
"RTN","HLOSTAT",151,0)
 ...F  S RAP=$O(^HLSTATS(DIR,STATTYPE,TIME,SAP,RAP)) Q:RAP=""  D  Q:QUIT
"RTN","HLOSTAT",152,0)
 ....D LINE("               Receiving Application: "_RAP)
"RTN","HLOSTAT",153,0)
 ....Q:QUIT
"RTN","HLOSTAT",154,0)
 ....S TYPE=""
"RTN","HLOSTAT",155,0)
 ....F  S TYPE=$O(^HLSTATS(DIR,STATTYPE,TIME,SAP,RAP,TYPE)) Q:TYPE=""  D  Q:QUIT
"RTN","HLOSTAT",156,0)
 .....S COUNT=$G(^HLSTATS(DIR,STATTYPE,TIME,SAP,RAP,TYPE))
"RTN","HLOSTAT",157,0)
 .....S SUBTOTAL=SUBTOTAL+COUNT
"RTN","HLOSTAT",158,0)
 .....D LINE("                    Message Type: "_$$LJ(TYPE,25)_"   Count:"_$$RJ(COUNT,10))
"RTN","HLOSTAT",159,0)
 .....Q:QUIT
"RTN","HLOSTAT",160,0)
 ..I 'QUIT D
"RTN","HLOSTAT",161,0)
 ...S TOTAL=TOTAL+SUBTOTAL
"RTN","HLOSTAT",162,0)
 ...D LINE(" "),LINE($$RJ("**"_STATTYPE_" SUBTOTAL ** (excluding commit acks):",68)_$$RJ(SUBTOTAL,10))
"RTN","HLOSTAT",163,0)
 .D:'QUIT LINE(" "),LINE($$RJ("** TOTAL "_$S(DIR="IN":"INCOMING",1:"OUTGOING")_" MESSAGES ** (excluding commit acks):",68)_$$RJ(TOTAL,10))
"RTN","HLOSTAT",164,0)
 I CRT,'QUIT D PAUSE2
"RTN","HLOSTAT",165,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLOSTAT",166,0)
 D ^%ZISC
"RTN","HLOSTAT",167,0)
 Q
"RTN","HLOSTAT",168,0)
 ;
"RTN","HLOSTAT",169,0)
DEVICE() ;
"RTN","HLOSTAT",170,0)
 ;Description: allows the user to select a device.
"RTN","HLOSTAT",171,0)
 ;Input: none
"RTN","HLOSTAT",172,0)
 ;
"RTN","HLOSTAT",173,0)
 ;Output:
"RTN","HLOSTAT",174,0)
 ;  Function Value - Returns 0 if the user decides not to print or to
"RTN","HLOSTAT",175,0)
 ;    queue the report, 1 otherwise.
"RTN","HLOSTAT",176,0)
 ;
"RTN","HLOSTAT",177,0)
 N OK,HLOPARMS
"RTN","HLOSTAT",178,0)
 S OK=1
"RTN","HLOSTAT",179,0)
 S %ZIS="MQ"
"RTN","HLOSTAT",180,0)
 D ^%ZIS
"RTN","HLOSTAT",181,0)
 S:POP OK=0
"RTN","HLOSTAT",182,0)
 D:OK&$D(IO("Q"))
"RTN","HLOSTAT",183,0)
 .S HLOPARMS("STATISTICS TYPE")=TYPE,HLOPARMS("START DT/TM")=START,HLOPARMS("END DT/TM")=END
"RTN","HLOSTAT",184,0)
 .S ZTRTN="QUE^HLOSTAT",ZTDESC="HLO MESSAGE STATISTICS REPORT",ZTSAVE("HLOPARMS(")=""
"RTN","HLOSTAT",185,0)
 .D ^%ZTLOAD
"RTN","HLOSTAT",186,0)
 .W !,$S($D(ZTSK):"REQUEST QUEUED TASK="_ZTSK,1:"REQUEST CANCELLED")
"RTN","HLOSTAT",187,0)
 .D HOME^%ZIS
"RTN","HLOSTAT",188,0)
 .S OK=0
"RTN","HLOSTAT",189,0)
 Q OK
"RTN","HLOSTAT",190,0)
 ;
"RTN","HLOSTAT",191,0)
PAUSE ;
"RTN","HLOSTAT",192,0)
 ;First scrolls to the bottome of the page, then does a screen pause.  Sets QUIT=1 if user decides to quit.
"RTN","HLOSTAT",193,0)
 ;
"RTN","HLOSTAT",194,0)
 N DIR,X,Y
"RTN","HLOSTAT",195,0)
 F  Q:$Y>(IOSL-3)  W !
"RTN","HLOSTAT",196,0)
 S DIR(0)="E"
"RTN","HLOSTAT",197,0)
 D ^DIR
"RTN","HLOSTAT",198,0)
 I ('(+Y))!$D(DIRUT) S QUIT=1
"RTN","HLOSTAT",199,0)
 Q
"RTN","HLOSTAT",200,0)
PAUSE2 ;
"RTN","HLOSTAT",201,0)
 ;Screen pause without scrolling.  Sets QUIT=1 if user decides to quit.
"RTN","HLOSTAT",202,0)
 ;
"RTN","HLOSTAT",203,0)
 N DIR,X,Y
"RTN","HLOSTAT",204,0)
 S DIR(0)="E"
"RTN","HLOSTAT",205,0)
 D ^DIR
"RTN","HLOSTAT",206,0)
 I ('(+Y))!$D(DIRUT) S QUIT=1
"RTN","HLOSTAT",207,0)
 Q
"RTN","HLOSTAT",208,0)
 ;
"RTN","HLOSTAT",209,0)
LINE(LINE) ;Prints a line.
"RTN","HLOSTAT",210,0)
 ;
"RTN","HLOSTAT",211,0)
 I CRT,($Y>(IOSL-4)) D
"RTN","HLOSTAT",212,0)
 .D PAUSE
"RTN","HLOSTAT",213,0)
 .Q:QUIT
"RTN","HLOSTAT",214,0)
 .W @IOF
"RTN","HLOSTAT",215,0)
 .W LINE
"RTN","HLOSTAT",216,0)
 ;
"RTN","HLOSTAT",217,0)
 E  I ('CRT),($Y>(IOSL-2)) D
"RTN","HLOSTAT",218,0)
 .W @IOF
"RTN","HLOSTAT",219,0)
 .W ?70,"Page: ",PAGE
"RTN","HLOSTAT",220,0)
 .S PAGE=PAGE+1
"RTN","HLOSTAT",221,0)
 .W LINE
"RTN","HLOSTAT",222,0)
 ;
"RTN","HLOSTAT",223,0)
 E  W !,LINE
"RTN","HLOSTAT",224,0)
 Q
"RTN","HLOSTAT",225,0)
 ;
"RTN","HLOSTAT",226,0)
LJ(STRING,LEN) ;
"RTN","HLOSTAT",227,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOSTAT",228,0)
RJ(STRING,LEN) ;
"RTN","HLOSTAT",229,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOT")
0^7^B2729395^B2539193
"RTN","HLOT",1,0)
HLOT ;IRMFO-ALB/CJM - Services provided by the transport layer;03/24/2004  14:43
"RTN","HLOT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131**;Oct 13, 1995;Build 10
"RTN","HLOT",3,0)
 ;
"RTN","HLOT",4,0)
 ;
"RTN","HLOT",5,0)
READHDR(HLCSTATE,HDR) ;
"RTN","HLOT",6,0)
 N SUCCESS,SEG
"RTN","HLOT",7,0)
 N MCODE
"RTN","HLOT",8,0)
 S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOT",9,0)
 S MCODE="S SUCCESS=$$"_HLCSTATE("READ HEADER")_"(.HLCSTATE,.HDR)"
"RTN","HLOT",10,0)
 X MCODE
"RTN","HLOT",11,0)
 Q SUCCESS
"RTN","HLOT",12,0)
 ;
"RTN","HLOT",13,0)
READSEG(HLCSTATE,SEG) ;
"RTN","HLOT",14,0)
 N RETURN
"RTN","HLOT",15,0)
 N MCODE
"RTN","HLOT",16,0)
 S MCODE="S RETURN=$$"_HLCSTATE("READ SEGMENT")_"(.HLCSTATE,.SEG)"
"RTN","HLOT",17,0)
 X MCODE
"RTN","HLOT",18,0)
 Q RETURN
"RTN","HLOT",19,0)
 ;
"RTN","HLOT",20,0)
OPEN(HLCSTATE) ;
"RTN","HLOT",21,0)
 N MCODE
"RTN","HLOT",22,0)
 I '$L(HLCSTATE("OPEN")) S HLCSTATE("CONNECTED")=0 Q
"RTN","HLOT",23,0)
 S MCODE="D "_HLCSTATE("OPEN")_"(.HLCSTATE)"
"RTN","HLOT",24,0)
 X MCODE
"RTN","HLOT",25,0)
 Q
"RTN","HLOT",26,0)
 ;
"RTN","HLOT",27,0)
CLOSE(HLCSTATE) ;
"RTN","HLOT",28,0)
 N MCODE
"RTN","HLOT",29,0)
 S MCODE="D "_HLCSTATE("CLOSE")_"(.HLCSTATE)"
"RTN","HLOT",30,0)
 X MCODE
"RTN","HLOT",31,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOT",32,0)
 Q
"RTN","HLOT",33,0)
 ;
"RTN","HLOT",34,0)
WRITESEG(HLCSTATE,SEG) ;
"RTN","HLOT",35,0)
 N RETURN
"RTN","HLOT",36,0)
 N MCODE
"RTN","HLOT",37,0)
 S MCODE="S RETURN=$$"_HLCSTATE("WRITE SEGMENT")_"(.HLCSTATE,.SEG)"
"RTN","HLOT",38,0)
 X MCODE
"RTN","HLOT",39,0)
 Q RETURN
"RTN","HLOT",40,0)
 ;
"RTN","HLOT",41,0)
WRITEHDR(HLCSTATE,HDR) ;
"RTN","HLOT",42,0)
 N SUCCESS
"RTN","HLOT",43,0)
 N MCODE
"RTN","HLOT",44,0)
 S MCODE="S SUCCESS=$$"_HLCSTATE("WRITE HEADER")_"(.HLCSTATE,.HDR)"
"RTN","HLOT",45,0)
 X MCODE
"RTN","HLOT",46,0)
 Q SUCCESS
"RTN","HLOT",47,0)
 ;
"RTN","HLOT",48,0)
ENDMSG(HLCSTATE) ;
"RTN","HLOT",49,0)
 N RETURN
"RTN","HLOT",50,0)
 N MCODE
"RTN","HLOT",51,0)
 S MCODE="S RETURN=$$"_HLCSTATE("END MESSAGE")_"(.HLCSTATE)"
"RTN","HLOT",52,0)
 X MCODE
"RTN","HLOT",53,0)
 Q RETURN
"RTN","HLOTCP")
0^6^B45043587^B43009690
"RTN","HLOTCP",1,0)
HLOTCP ;ALB/CJM- TCP/IP I/O - 10/4/94 1pm
"RTN","HLOTCP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131**;Oct 13, 1995;Build 10
"RTN","HLOTCP",3,0)
 ;
"RTN","HLOTCP",4,0)
OPEN(HLCSTATE,LOGICAL) ;
"RTN","HLOTCP",5,0)
 ;This may be called either in the context of a client or a server.
"RTN","HLOTCP",6,0)
 ;For the server, there are 3 situations:
"RTN","HLOTCP",7,0)
 ; 1) The server is not concurrent.  In this case the TCP device should be opened.
"RTN","HLOTCP",8,0)
 ; 2) The server is concurrent, but this process was spawned by the OS
"RTN","HLOTCP",9,0)
 ;    (via a VMS TCP Service)  In this case, the device should be opened
"RTN","HLOTCP",10,0)
 ;    via the LOGICAL that was passed in.
"RTN","HLOTCP",11,0)
 ;  3) The server is concurrent, but this process was spawned by the
"RTN","HLOTCP",12,0)
 ;     TaskMan multi-listener.  In this case TaskMan already opened the
"RTN","HLOTCP",13,0)
 ;     device.  This case can be determined by the absence of the LOGICAL
"RTN","HLOTCP",14,0)
 ;     input parameter.
"RTN","HLOTCP",15,0)
 ;
"RTN","HLOTCP",16,0)
 N IP,PORT,DNSFLAG
"RTN","HLOTCP",17,0)
 ;
"RTN","HLOTCP",18,0)
 S DNSFLAG=0 ;DNS has not been contacted for IP
"RTN","HLOTCP",19,0)
 ;
"RTN","HLOTCP",20,0)
 S:'$G(HLCSTATE("SERVER")) IP=HLCSTATE("LINK","IP")
"RTN","HLOTCP",21,0)
 S PORT=HLCSTATE("LINK","PORT")
"RTN","HLOTCP",22,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOTCP",23,0)
 S HLCSTATE("READ HEADER")="READHDR^HLOTCP"
"RTN","HLOTCP",24,0)
 S HLCSTATE("WRITE HEADER")="WRITEHDR^HLOTCP"
"RTN","HLOTCP",25,0)
 S HLCSTATE("READ SEGMENT")="READSEG^HLOTCP"
"RTN","HLOTCP",26,0)
 S HLCSTATE("WRITE SEGMENT")="WRITESEG^HLOTCP"
"RTN","HLOTCP",27,0)
 S HLCSTATE("END MESSAGE")="ENDMSG^HLOTCP"
"RTN","HLOTCP",28,0)
 S HLCSTATE("CLOSE")="CLOSE^HLOTCP"
"RTN","HLOTCP",29,0)
 ;
"RTN","HLOTCP",30,0)
 ;spawned by TaskMan multi-listener? If so, the device has already been opened
"RTN","HLOTCP",31,0)
 I $G(HLCSTATE("SERVER")),$G(HLCSTATE("LINK","SERVER"))="1^M",$G(LOGICAL)="" D  Q
"RTN","HLOTCP",32,0)
 .S HLCSTATE("DEVICE")=IO(0),HLCSTATE("FLUSH")="!",HLCSTATE("TCP BUFFER SIZE")=510
"RTN","HLOTCP",33,0)
 .S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",34,0)
 ;
"RTN","HLOTCP",35,0)
 ;if no IP, not a server, give DNS a shot
"RTN","HLOTCP",36,0)
 I '$G(HLCSTATE("SERVER")),IP="" S DNSFLAG=1,IP=$$DNS(HLCSTATE("LINK","DOMAIN")),HLCSTATE("LINK","IP")=IP Q:IP=""
"RTN","HLOTCP",37,0)
 ;
"RTN","HLOTCP",38,0)
RETRY I HLCSTATE("SYSTEM","OS")="DSM" D
"RTN","HLOTCP",39,0)
 .S HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",40,0)
 .I $G(LOGICAL)]"" S HLCSTATE("DEVICE")=LOGICAL
"RTN","HLOTCP",41,0)
 .E  S HLCSTATE("DEVICE")=PORT
"RTN","HLOTCP",42,0)
 .S HLCSTATE("FLUSH")="!"
"RTN","HLOTCP",43,0)
 .I $G(HLCSTATE("SERVER")) D
"RTN","HLOTCP",44,0)
 ..O:$G(LOGICAL)]"" HLCSTATE("DEVICE"):(TCPDEV,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",45,0)
 ..O:$G(LOGICAL)="" HLCSTATE("DEVICE"):(TCPCHAN,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",46,0)
 ..I $T D
"RTN","HLOTCP",47,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",48,0)
 ...U HLCSTATE("DEVICE"):NOECHO
"RTN","HLOTCP",49,0)
 .E  D  ;client
"RTN","HLOTCP",50,0)
 ..O HLCSTATE("DEVICE"):(TCPCHAN,ADDRESS=IP,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",51,0)
 ..I $T D
"RTN","HLOTCP",52,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",53,0)
 ...U HLCSTATE("DEVICE"):NOECHO
"RTN","HLOTCP",54,0)
 E  I HLCSTATE("SYSTEM","OS")="CACHE" D
"RTN","HLOTCP",55,0)
 .S HLCSTATE("FLUSH")="!"
"RTN","HLOTCP",56,0)
 .I $G(LOGICAL)]"" S HLCSTATE("DEVICE")=LOGICAL
"RTN","HLOTCP",57,0)
 .E  S HLCSTATE("DEVICE")="|TCP|"_PORT
"RTN","HLOTCP",58,0)
 .S HLCSTATE("TCP BUFFER SIZE")=510
"RTN","HLOTCP",59,0)
 .I $G(HLCSTATE("SERVER")) D
"RTN","HLOTCP",60,0)
 ..I HLCSTATE("SERVER")="1^S" D  Q
"RTN","HLOTCP",61,0)
 ...;single server (no concurrent connections)
"RTN","HLOTCP",62,0)
 ...O HLCSTATE("DEVICE"):(:PORT:"+A-S":::):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",63,0)
 ...I $T D
"RTN","HLOTCP",64,0)
 ....N A
"RTN","HLOTCP",65,0)
 ....S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",66,0)
 ....U HLCSTATE("DEVICE")
"RTN","HLOTCP",67,0)
 ....F  R *A:HLCSTATE("READ TIMEOUT") Q:$T  I $$CHKSTOP^HLOPROC S HLCSTATE("CONNECTED")=0 Q
"RTN","HLOTCP",68,0)
 ..;
"RTN","HLOTCP",69,0)
 ..;multi-server spawned by OS - VMS TCP Services
"RTN","HLOTCP",70,0)
 ..O HLCSTATE("DEVICE")::HLCSTATE("OPEN TIMEOUT") I '$T S HLCSTATE("CONNECTED")=0 Q
"RTN","HLOTCP",71,0)
 ..S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",72,0)
 ..U HLCSTATE("DEVICE"):(::"-S")
"RTN","HLOTCP",73,0)
 ..;
"RTN","HLOTCP",74,0)
 .E  D  ;client
"RTN","HLOTCP",75,0)
 ..S HLCSTATE("TCP BUFFER SIZE")=510
"RTN","HLOTCP",76,0)
 ..O HLCSTATE("DEVICE"):(IP:PORT:"-S":::):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",77,0)
 ..I $T D
"RTN","HLOTCP",78,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",79,0)
 E  D  ;any other system but Cache or DSM
"RTN","HLOTCP",80,0)
 .S HLCSTATE("TCP BUFFER SIZE")=256
"RTN","HLOTCP",81,0)
 .D CALL^%ZISTCP(IP,PORT,HLCSTATE("OPEN TIMEOUT"))
"RTN","HLOTCP",82,0)
 .S HLCSTATE("CONNECTED")='POP
"RTN","HLOTCP",83,0)
 .I HLCSTATE("CONNECTED") S HLCSTATE("DEVICE")=IO
"RTN","HLOTCP",84,0)
 ;
"RTN","HLOTCP",85,0)
 ;if not connected, not the server, give DNS a shot if not tried already
"RTN","HLOTCP",86,0)
 I '$G(HLCSTATE("SERVER")),'HLCSTATE("CONNECTED"),'DNSFLAG S DNSFLAG=1,IP=$$DNS(HLCSTATE("LINK","DOMAIN")) I IP]"",IP'=HLCSTATE("LINK","IP") S HLCSTATE("LINK","IP")=IP G RETRY
"RTN","HLOTCP",87,0)
 I HLCSTATE("CONNECTED"),DNSFLAG S $P(^HLCS(870,HLCSTATE("LINK","IEN"),400),"^")=IP
"RTN","HLOTCP",88,0)
 Q
"RTN","HLOTCP",89,0)
 ;
"RTN","HLOTCP",90,0)
DNS(DOMAIN) ;
"RTN","HLOTCP",91,0)
 Q $P($$ADDRESS^XLFNSLK(DOMAIN),",")
"RTN","HLOTCP",92,0)
 ;
"RTN","HLOTCP",93,0)
WRITEHDR(HLCSTATE,HDR) ;
"RTN","HLOTCP",94,0)
 ;
"RTN","HLOTCP",95,0)
 ;insure that package buffer is empty
"RTN","HLOTCP",96,0)
 K HLCSTATE("BUFFER")
"RTN","HLOTCP",97,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0
"RTN","HLOTCP",98,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0
"RTN","HLOTCP",99,0)
 S HLCSTATE("FIRST WRITE")=1 ;so that FLUSH knows $X should be 0
"RTN","HLOTCP",100,0)
 ;
"RTN","HLOTCP",101,0)
 ;Start the message with <SB>, then write the header
"RTN","HLOTCP",102,0)
 N SEG
"RTN","HLOTCP",103,0)
 S SEG(1)=$C(11)_HDR(1)
"RTN","HLOTCP",104,0)
 S SEG(2)=HDR(2)
"RTN","HLOTCP",105,0)
 Q $$WRITESEG(.HLCSTATE,.SEG)
"RTN","HLOTCP",106,0)
 ;
"RTN","HLOTCP",107,0)
WRITESEG(HLCSTATE,SEG) ;
"RTN","HLOTCP",108,0)
 N I,LAST
"RTN","HLOTCP",109,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=HLCSTATE("BUFFER","SEGMENT COUNT")+1
"RTN","HLOTCP",110,0)
 S I=0,LAST=$O(SEG(99999),-1)
"RTN","HLOTCP",111,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOTCP",112,0)
 .I HLCSTATE("BUFFER","BYTE COUNT")>HLCSTATE("SYSTEM","BUFFER") D FLUSH
"RTN","HLOTCP",113,0)
 .I I=LAST S SEG(I)=SEG(I)_$C(13)
"RTN","HLOTCP",114,0)
 .S HLCSTATE("BUFFER",HLCSTATE("BUFFER","SEGMENT COUNT"),I)=SEG(I),HLCSTATE("BUFFER","BYTE COUNT")=HLCSTATE("BUFFER","BYTE COUNT")+$L(SEG(I))+20
"RTN","HLOTCP",115,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOTCP",116,0)
 ;
"RTN","HLOTCP",117,0)
FLUSH ;flushes the HL7 package buffer, and the system TCP buffer when full
"RTN","HLOTCP",118,0)
 N SEGMENT,MAX
"RTN","HLOTCP",119,0)
 S SEGMENT=0
"RTN","HLOTCP",120,0)
 S MAX=HLCSTATE("TCP BUFFER SIZE")
"RTN","HLOTCP",121,0)
 U HLCSTATE("DEVICE") I (HLCSTATE("SYSTEM","OS")="CACHE") S HLCSTATE("CONNECTED")=($ZA\8192#2) I 'HLCSTATE("CONNECTED") D CLOSE(.HLCSTATE)
"RTN","HLOTCP",122,0)
 F  S SEGMENT=$O(HLCSTATE("BUFFER",SEGMENT)) Q:'SEGMENT  D
"RTN","HLOTCP",123,0)
 .N I S I=0
"RTN","HLOTCP",124,0)
 .F  S I=$O(HLCSTATE("BUFFER",SEGMENT,I)) Q:'I  D
"RTN","HLOTCP",125,0)
 ..N LINE,J
"RTN","HLOTCP",126,0)
 ..S J=$S(HLCSTATE("FIRST WRITE"):0,1:$X)
"RTN","HLOTCP",127,0)
 ..S HLCSTATE("FIRST WRITE")=0
"RTN","HLOTCP",128,0)
 ..S LINE=HLCSTATE("BUFFER",SEGMENT,I)
"RTN","HLOTCP",129,0)
 ..F  Q:'(J+$L(LINE)>MAX)  D
"RTN","HLOTCP",130,0)
 ...W $E(LINE,1,MAX-J),@HLCSTATE("FLUSH")
"RTN","HLOTCP",131,0)
 ...S LINE=$E(LINE,(MAX-J)+1,99999)
"RTN","HLOTCP",132,0)
 ...S J=0
"RTN","HLOTCP",133,0)
 ..W:(LINE]"") LINE
"RTN","HLOTCP",134,0)
 K HLCSTATE("BUFFER")
"RTN","HLOTCP",135,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=1
"RTN","HLOTCP",136,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0
"RTN","HLOTCP",137,0)
 S HLCSTATE("FIRST WRITE")=0
"RTN","HLOTCP",138,0)
 Q
"RTN","HLOTCP",139,0)
 ;
"RTN","HLOTCP",140,0)
READSEG(HLCSTATE,SEG) ;
"RTN","HLOTCP",141,0)
 ;
"RTN","HLOTCP",142,0)
 ;Output:
"RTN","HLOTCP",143,0)
 ;  SEG - returns the segment (pass by reference)
"RTN","HLOTCP",144,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOTCP",145,0)
 ;
"RTN","HLOTCP",146,0)
 N SUCCESS,COUNT,BUF
"RTN","HLOTCP",147,0)
 S (COUNT,SUCCESS)=0
"RTN","HLOTCP",148,0)
 K SEG
"RTN","HLOTCP",149,0)
 ;
"RTN","HLOTCP",150,0)
 ;anything left from last read?
"RTN","HLOTCP",151,0)
 S BUF=HLCSTATE("READ")
"RTN","HLOTCP",152,0)
 S HLCSTATE("READ")=""
"RTN","HLOTCP",153,0)
 I BUF]"" D  ;something was left!
"RTN","HLOTCP",154,0)
 .S COUNT=1
"RTN","HLOTCP",155,0)
 .I BUF[$C(13) D  Q
"RTN","HLOTCP",156,0)
 ..S SEG(1)=$P(BUF,$C(13)),BUF=$P(BUF,$C(13),2,9999)
"RTN","HLOTCP",157,0)
 ..S SUCCESS=1
"RTN","HLOTCP",158,0)
 .S SEG(1)=BUF,BUF=""
"RTN","HLOTCP",159,0)
 I 'SUCCESS U HLCSTATE("DEVICE") F  R BUF:HLCSTATE("READ TIMEOUT") Q:'$T  D  Q:SUCCESS
"RTN","HLOTCP",160,0)
 .I BUF[$C(13) S SUCCESS=1,COUNT=COUNT+1,SEG(COUNT)=$P(BUF,$C(13)),BUF=$P(BUF,$C(13),2,9999) Q
"RTN","HLOTCP",161,0)
 .S COUNT=COUNT+1,SEG(COUNT)=BUF
"RTN","HLOTCP",162,0)
 ;
"RTN","HLOTCP",163,0)
 I SUCCESS D
"RTN","HLOTCP",164,0)
 .S HLCSTATE("READ")=BUF ;save the leftover
"RTN","HLOTCP",165,0)
 .I COUNT>1,SEG(COUNT)="" K SEG(COUNT) S COUNT=COUNT-1
"RTN","HLOTCP",166,0)
 ;Cache can return the connection status
"RTN","HLOTCP",167,0)
 E  I (HLCSTATE("SYSTEM","OS")="CACHE") S HLCSTATE("CONNECTED")=($ZA\8192#2) I 'HLCSTATE("CONNECTED") D CLOSE(.HLCSTATE)
"RTN","HLOTCP",168,0)
 ;
"RTN","HLOTCP",169,0)
 ;if the <EB> character was encountered, then there are no more segments in the message, set the end of message flag
"RTN","HLOTCP",170,0)
 I SUCCESS,SEG(COUNT)[$C(28) D
"RTN","HLOTCP",171,0)
 .K SEG
"RTN","HLOTCP",172,0)
 .S SUCCESS=0
"RTN","HLOTCP",173,0)
 .S HLCSTATE("MESSAGE ENDED")=1
"RTN","HLOTCP",174,0)
 Q SUCCESS
"RTN","HLOTCP",175,0)
 ;
"RTN","HLOTCP",176,0)
READHDR(HLCSTATE,HDR) ;
"RTN","HLOTCP",177,0)
 ;reads the next header segment in the message stream, discarding everything that comes before it
"RTN","HLOTCP",178,0)
 ;
"RTN","HLOTCP",179,0)
 N SEG,SUCCESS,J,I
"RTN","HLOTCP",180,0)
 S SUCCESS=0
"RTN","HLOTCP",181,0)
 K HDR
"RTN","HLOTCP",182,0)
 F  Q:'$$READSEG(.HLCSTATE,.SEG)  D  Q:SUCCESS
"RTN","HLOTCP",183,0)
 .S I=0
"RTN","HLOTCP",184,0)
 .;look for the <SB>
"RTN","HLOTCP",185,0)
 .;perhaps the <SB> isn't in the first line
"RTN","HLOTCP",186,0)
 .F  S I=$O(SEG(I)) Q:'I  D  Q:SUCCESS
"RTN","HLOTCP",187,0)
 ..I (SEG(I)'[$C(11)) K SEG(I) Q
"RTN","HLOTCP",188,0)
 ..S SEG(I)=$P(SEG(I),$C(11),2)
"RTN","HLOTCP",189,0)
 ..S SUCCESS=1
"RTN","HLOTCP",190,0)
 ..K:SEG(I)="" SEG(I)
"RTN","HLOTCP",191,0)
 I SUCCESS S (I,J)=0 F  S J=$O(SEG(J)) Q:'J  S I=I+1,HDR(I)=SEG(J)
"RTN","HLOTCP",192,0)
 Q SUCCESS
"RTN","HLOTCP",193,0)
 ;
"RTN","HLOTCP",194,0)
CLOSE(HLCSTATE) ;
"RTN","HLOTCP",195,0)
 CLOSE HLCSTATE("DEVICE")
"RTN","HLOTCP",196,0)
 Q
"RTN","HLOTCP",197,0)
 ;
"RTN","HLOTCP",198,0)
ENDMSG(HLCSTATE)        ;
"RTN","HLOTCP",199,0)
 N SEG
"RTN","HLOTCP",200,0)
 S SEG(1)=$C(28)
"RTN","HLOTCP",201,0)
 I $$WRITESEG(.HLCSTATE,.SEG) D  Q 1
"RTN","HLOTCP",202,0)
 .D FLUSH
"RTN","HLOTCP",203,0)
 .U HLCSTATE("DEVICE")
"RTN","HLOTCP",204,0)
 .W:$X @HLCSTATE("FLUSH")
"RTN","HLOTCP",205,0)
 Q 0
"RTN","HLOTLNK")
0^11^B23891993^B20724359
"RTN","HLOTLNK",1,0)
HLOTLNK ;IRMFO-ALB/CJM - APIs for the HL Logical Link file;03/24/2004  14:43
"RTN","HLOTLNK",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131**;Oct 13, 1995;Build 10
"RTN","HLOTLNK",3,0)
 ;
"RTN","HLOTLNK",4,0)
SETSHUT(LINKIEN) ;
"RTN","HLOTLNK",5,0)
 ;sets the shutdown flag (can not fail - if the link doesn't exist, by definition its shutdown)
"RTN","HLOTLNK",6,0)
 Q:'$G(LINKIEN) 1
"RTN","HLOTLNK",7,0)
 Q:'$D(^HLCS(870,LINKIEN,0)) 1
"RTN","HLOTLNK",8,0)
 S $P(^HLCS(870,LINKIEN,0),"^",16)=1
"RTN","HLOTLNK",9,0)
 Q 1
"RTN","HLOTLNK",10,0)
SETOPEN(LINKIEN) ;
"RTN","HLOTLNK",11,0)
 ;clears the shutdown flag, returns 1 on success, 0 on failure
"RTN","HLOTLNK",12,0)
 Q:'$G(LINKIEN) 0
"RTN","HLOTLNK",13,0)
 Q:'$D(^HLCS(870,LINKIEN,0)) 0
"RTN","HLOTLNK",14,0)
 S $P(^HLCS(870,LINKIEN,0),"^",16)=""
"RTN","HLOTLNK",15,0)
 Q 1
"RTN","HLOTLNK",16,0)
 ;
"RTN","HLOTLNK",17,0)
IFSHUT(LINKNAME) ;
"RTN","HLOTLNK",18,0)
 ;returns 1 if the link was shut down to HLO
"RTN","HLOTLNK",19,0)
 N IEN,LINK
"RTN","HLOTLNK",20,0)
 S LINK=$P($G(LINKNAME),":")
"RTN","HLOTLNK",21,0)
 Q:LINK=""
"RTN","HLOTLNK",22,0)
 S IEN=$O(^HLCS(870,"B",LINK,0))
"RTN","HLOTLNK",23,0)
 Q:'IEN 1
"RTN","HLOTLNK",24,0)
 Q:$P($G(^HLCS(870,IEN,0)),"^",16) 1
"RTN","HLOTLNK",25,0)
 Q 0
"RTN","HLOTLNK",26,0)
 ;
"RTN","HLOTLNK",27,0)
DOMAIN(LINKIEN) ;
"RTN","HLOTLNK",28,0)
 ;Returns the domain associated with this link
"RTN","HLOTLNK",29,0)
 ;
"RTN","HLOTLNK",30,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",31,0)
 N NODE,DOMAIN
"RTN","HLOTLNK",32,0)
 S DOMAIN=""
"RTN","HLOTLNK",33,0)
 S NODE=$G(^HLCS(870,LINKIEN,0))
"RTN","HLOTLNK",34,0)
 I $P(NODE,"^",7) D
"RTN","HLOTLNK",35,0)
 .S DOMAIN=$P($G(^DIC(4.2,$P(NODE,"^",7),0)),"^")
"RTN","HLOTLNK",36,0)
 .S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",37,0)
 I '$L(DOMAIN) S DOMAIN=$P(NODE,"^",8)
"RTN","HLOTLNK",38,0)
 Q DOMAIN
"RTN","HLOTLNK",39,0)
PORT(LINKIEN) ;
"RTN","HLOTLNK",40,0)
 ;Returns the HLO port associated with this link
"RTN","HLOTLNK",41,0)
 ;
"RTN","HLOTLNK",42,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",43,0)
 N NODE,PORT
"RTN","HLOTLNK",44,0)
 S NODE=$G(^HLCS(870,LINKIEN,400))
"RTN","HLOTLNK",45,0)
 S PORT=$P(NODE,"^",8)
"RTN","HLOTLNK",46,0)
 S:'PORT PORT=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":5001,1:5026)
"RTN","HLOTLNK",47,0)
 Q PORT
"RTN","HLOTLNK",48,0)
 ;
"RTN","HLOTLNK",49,0)
PORT2(LINKNAME) ;given the name of the link, returns its HLO port
"RTN","HLOTLNK",50,0)
 Q $$PORT($O(^HLCS(870,"B",LINKNAME,0)))
"RTN","HLOTLNK",51,0)
 ;
"RTN","HLOTLNK",52,0)
STATNUM(LINKIEN) ;
"RTN","HLOTLNK",53,0)
 ;Given the ien of the link, this function returns the station #.
"RTN","HLOTLNK",54,0)
 ;
"RTN","HLOTLNK",55,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",56,0)
 N INST
"RTN","HLOTLNK",57,0)
 S INST=$P($G(^HLCS(870,LINKIEN,0)),"^",2)
"RTN","HLOTLNK",58,0)
 Q:'INST ""
"RTN","HLOTLNK",59,0)
 Q $P($G(^DIC(4,INST,99)),"^")
"RTN","HLOTLNK",60,0)
 ;
"RTN","HLOTLNK",61,0)
FINDLINK(STATN) ;
"RTN","HLOTLNK",62,0)
 ;Returns the link ien based on the station # =STATN
"RTN","HLOTLNK",63,0)
 ;The link found must have a name starting with "VA", as these are
"RTN","HLOTLNK",64,0)
 ;reserved for officially released links associated with VHA institutions
"RTN","HLOTLNK",65,0)
 ;** EXCEPTION** MPIVA is an official link associated with 200M
"RTN","HLOTLNK",66,0)
 ;
"RTN","HLOTLNK",67,0)
 Q:'$L($G(STATN)) 0
"RTN","HLOTLNK",68,0)
 ;
"RTN","HLOTLNK",69,0)
 N NAME,IEN
"RTN","HLOTLNK",70,0)
 S (NAME,IEN)=""
"RTN","HLOTLNK",71,0)
 F  S NAME=$O(^HLCS(870,"AC",STATN,NAME)) Q:NAME=""  I (NAME'="VA-VIE"),($E(NAME,1,2)="VA")!(NAME="MPIVA") S IEN=$O(^HLCS(870,"AC",STATN,NAME,0)) Q
"RTN","HLOTLNK",72,0)
 Q IEN
"RTN","HLOTLNK",73,0)
 ;
"RTN","HLOTLNK",74,0)
GETLINK(LINKNAME,LINK) ;
"RTN","HLOTLNK",75,0)
 N IEN
"RTN","HLOTLNK",76,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",77,0)
 I IEN Q $$GET(IEN,.LINK)
"RTN","HLOTLNK",78,0)
 I LINKNAME="HLO DEFAULT LISTENER" D  Q 1
"RTN","HLOTLNK",79,0)
 .N NODE
"RTN","HLOTLNK",80,0)
 .S LINK("NAME")=LINKNAME
"RTN","HLOTLNK",81,0)
 .S LINK("IEN")=0
"RTN","HLOTLNK",82,0)
 .S LINK("SHUTDOWN")=""
"RTN","HLOTLNK",83,0)
 .S LINK("LLP")="TCP"
"RTN","HLOTLNK",84,0)
 .S LINK("SERVER")="1^"_"M"
"RTN","HLOTLNK",85,0)
 .S NODE=$G(^HLD(779.1,1,0))
"RTN","HLOTLNK",86,0)
 .S LINK("DOMAIN")=$P(NODE,"^",1)
"RTN","HLOTLNK",87,0)
 .S LINK("PORT")=$S($P(NODE,"^",3)="P":5001,$P(NODE,"^",3)="T":5026,1:"")
"RTN","HLOTLNK",88,0)
 .S LINK("IP")=""
"RTN","HLOTLNK",89,0)
 Q 0
"RTN","HLOTLNK",90,0)
GET(IEN,LINK) ;
"RTN","HLOTLNK",91,0)
 N NODE,PTR
"RTN","HLOTLNK",92,0)
 K LINK
"RTN","HLOTLNK",93,0)
 S NODE=$G(^HLCS(870,IEN,0))
"RTN","HLOTLNK",94,0)
 Q:NODE="" 0
"RTN","HLOTLNK",95,0)
 S LINK("NAME")=$P(NODE,"^")
"RTN","HLOTLNK",96,0)
 S LINK("IEN")=IEN
"RTN","HLOTLNK",97,0)
 S LINK("SHUTDOWN")=+$P(NODE,"^",16)
"RTN","HLOTLNK",98,0)
 I $P(NODE,"^",7) D
"RTN","HLOTLNK",99,0)
 .S LINK("DOMAIN")=$P(^DIC(4.2,$P(NODE,"^",7),0),"^")
"RTN","HLOTLNK",100,0)
 .S LINK("DOMAIN")=$S($L(LINK("DOMAIN")):"HL7."_LINK("DOMAIN"),1:"")
"RTN","HLOTLNK",101,0)
 I $G(LINK("DOMAIN"))="" S LINK("DOMAIN")=$P(NODE,"^",8)
"RTN","HLOTLNK",102,0)
 S PTR=$P(NODE,"^",3)
"RTN","HLOTLNK",103,0)
 S LINK("LLP")=$S('PTR:"",1:$P($G(^HLCS(869.1,PTR,0)),"^"))
"RTN","HLOTLNK",104,0)
 S LINK("SERVER")=""
"RTN","HLOTLNK",105,0)
 I LINK("LLP")="TCP" D
"RTN","HLOTLNK",106,0)
 .S LINK("SERVER")=1
"RTN","HLOTLNK",107,0)
 .S NODE=$G(^HLCS(870,IEN,400))
"RTN","HLOTLNK",108,0)
 .S LINK("IP")=$P(NODE,"^")
"RTN","HLOTLNK",109,0)
 .S LINK("PORT")=$P(NODE,"^",8)
"RTN","HLOTLNK",110,0)
 .S:'LINK("PORT") LINK("PORT")=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":5001,1:5026)
"RTN","HLOTLNK",111,0)
 .S:$P(NODE,"^",3)="C" LINK("SERVER")=0
"RTN","HLOTLNK",112,0)
 .I LINK("SERVER") S LINK("SERVER")=LINK("SERVER")_"^"_$P(NODE,"^",3)
"RTN","HLOTLNK",113,0)
 Q 1
"RTN","HLOTLNK",114,0)
 ;
"RTN","HLOTLNK",115,0)
SET1(LINK,MDOMAIN) ;
"RTN","HLOTLNK",116,0)
 N DOMAIN
"RTN","HLOTLNK",117,0)
 Q:'$L(MDOMAIN)
"RTN","HLOTLNK",118,0)
 S DOMAIN=$P($G(^DIC(4.2,MDOMAIN,0)),"^")
"RTN","HLOTLNK",119,0)
 S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",120,0)
 I DOMAIN'="" S ^HLCS(870,"AD","TCP",DOMAIN,LINK)=""
"RTN","HLOTLNK",121,0)
 Q
"RTN","HLOTLNK",122,0)
KILL1(LINK,MDOMAIN) ;
"RTN","HLOTLNK",123,0)
 N DOMAIN
"RTN","HLOTLNK",124,0)
 Q:'$L(MDOMAIN)
"RTN","HLOTLNK",125,0)
 S DOMAIN=$P($G(^DIC(4.2,MDOMAIN,0)),"^")
"RTN","HLOTLNK",126,0)
 S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",127,0)
 I DOMAIN'="" K ^HLCS(870,"AD","TCP",DOMAIN,LINK)
"RTN","HLOTLNK",128,0)
 Q
"RTN","HLOTLNK",129,0)
SET2(LINK,DOMAIN) ;
"RTN","HLOTLNK",130,0)
 I DOMAIN'="" S ^HLCS(870,"AD","TCP",DOMAIN,LINK)=""
"RTN","HLOTLNK",131,0)
 Q
"RTN","HLOTLNK",132,0)
KILL2(LINK,DOMAIN) ;
"RTN","HLOTLNK",133,0)
 I DOMAIN'="" K ^HLCS(870,"AD","TCP",DOMAIN,LINK)
"RTN","HLOTLNK",134,0)
 Q
"RTN","HLOTLNK",135,0)
SET3(LINK,DEVICE) ;
"RTN","HLOTLNK",136,0)
 Q:'DEVICE
"RTN","HLOTLNK",137,0)
 S ^HLCS(870,"AD","HLLP",DEVICE,LINK)=""
"RTN","HLOTLNK",138,0)
 Q
"RTN","HLOTLNK",139,0)
KILL3(LINK,DEVICE) ;
"RTN","HLOTLNK",140,0)
 Q:'DEVICE
"RTN","HLOTLNK",141,0)
 S ^HLCS(870,"AD","HLLP",DEVICE,LINK)=""
"RTN","HLOTLNK",142,0)
 Q
"RTN","HLOTLNK",143,0)
LLP(LINKNAME) ;
"RTN","HLOTLNK",144,0)
 ;finds the type of LLP for a named link
"RTN","HLOTLNK",145,0)
 N IEN,LLP
"RTN","HLOTLNK",146,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",147,0)
 Q:'IEN ""
"RTN","HLOTLNK",148,0)
 S LLP=$P($G(^HLCS(870,IEN,0)),"^",3)
"RTN","HLOTLNK",149,0)
 Q:'LLP ""
"RTN","HLOTLNK",150,0)
 Q $P($G(^HLCS(869.1,LLP,0)),"^")
"RTN","HLOTLNK",151,0)
 ;
"RTN","HLOTLNK",152,0)
DEVICE(LINKNAME) ;
"RTN","HLOTLNK",153,0)
 N IEN
"RTN","HLOTLNK",154,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",155,0)
 Q:'IEN ""
"RTN","HLOTLNK",156,0)
 Q $P($G(^HLCS(870,IEN,200)),"^")
"RTN","HLOTLNK",157,0)
 ;
"RTN","HLOTLNK",158,0)
RTRNLNK(COMP1,COMP2,COMP3) ;
"RTN","HLOTLNK",159,0)
 ;based on the sending facility from the original header, this function finds the return link, or "" if not successful
"RTN","HLOTLNK",160,0)
 ;Inputs:
"RTN","HLOTLNK",161,0)
 ;  COMP1,COMP2,COMP3 - 3 components of the sending facility from the original message
"RTN","HLOTLNK",162,0)
 ;
"RTN","HLOTLNK",163,0)
 N LINK,IEN
"RTN","HLOTLNK",164,0)
 S LINK=""
"RTN","HLOTLNK",165,0)
 I $G(COMP3)="DNS",$P($G(COMP2),":")]"" S LINK=$O(^HLCS(870,"AD","TCP",$P(COMP2,":"),""))
"RTN","HLOTLNK",166,0)
 I LINK="",$L($G(COMP1)) S IEN=$$FINDLINK(COMP1) S:IEN LINK=$P($G(^HLCS(870,IEN,0)),"^")
"RTN","HLOTLNK",167,0)
 Q LINK
"RTN","HLOTLNK",168,0)
 ;
"RTN","HLOTLNK",169,0)
 ;HLLP is not implemented in HLO
"RTN","HLOTLNK",170,0)
 ;I LLP="HLLP" N DEVICE S DEVICE=$$DEVICE(FROMLINK) I DEVICE Q $O(^HLCS(870,"AD","TCP",DEVICE,""))
"RTN","HLOTLNK",171,0)
 ;Q ""
"RTN","HLOTLNK",172,0)
 ;
"RTN","HLOTLNK",173,0)
CHKLINK(LINK) ;
"RTN","HLOTLNK",174,0)
 Q:'$L(LINK) 0
"RTN","HLOTLNK",175,0)
 Q:'$O(^HLCS(870,"B",LINK,0)) 0
"RTN","HLOTLNK",176,0)
 Q 1
"VER")
8.0^22.0
"BLD",925,6)
^104
**END**
**END**
