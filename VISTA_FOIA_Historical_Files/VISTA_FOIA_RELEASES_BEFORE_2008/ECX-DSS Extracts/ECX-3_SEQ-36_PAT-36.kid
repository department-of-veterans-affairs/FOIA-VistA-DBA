Released ECX*3*36 SEQ #36
Extracted from mail message
**KIDS**:ECX*3.0*36^

**INSTALL NAME**
ECX*3.0*36
"BLD",3520,0)
ECX*3.0*36^DSS EXTRACTS^0^3010416^y
"BLD",3520,1,0)
^^2^2^3010416^
"BLD",3520,1,1,0)
Patch:  ECX*3.0*36   CORRECTIONS TO PROSTHETICS REPORTS
"BLD",3520,1,2,0)
Please see the description in the NPM for complete information.
"BLD",3520,4,0)
^9.64PA^^
"BLD",3520,"ABPKG")
n
"BLD",3520,"KRN",0)
^9.67PA^19^17
"BLD",3520,"KRN",.4,0)
.4
"BLD",3520,"KRN",.401,0)
.401
"BLD",3520,"KRN",.402,0)
.402
"BLD",3520,"KRN",.403,0)
.403
"BLD",3520,"KRN",.5,0)
.5
"BLD",3520,"KRN",.84,0)
.84
"BLD",3520,"KRN",3.6,0)
3.6
"BLD",3520,"KRN",3.8,0)
3.8
"BLD",3520,"KRN",9.2,0)
9.2
"BLD",3520,"KRN",9.8,0)
9.8
"BLD",3520,"KRN",9.8,"NM",0)
^9.68A^2^2
"BLD",3520,"KRN",9.8,"NM",1,0)
ECXLPRO^^0^B25268332
"BLD",3520,"KRN",9.8,"NM",2,0)
ECXAPRO^^0^B45129674
"BLD",3520,"KRN",9.8,"NM","B","ECXAPRO",2)

"BLD",3520,"KRN",9.8,"NM","B","ECXLPRO",1)

"BLD",3520,"KRN",19,0)
19
"BLD",3520,"KRN",19.1,0)
19.1
"BLD",3520,"KRN",101,0)
101
"BLD",3520,"KRN",409.61,0)
409.61
"BLD",3520,"KRN",771,0)
771
"BLD",3520,"KRN",870,0)
870
"BLD",3520,"KRN",8994,0)
8994
"BLD",3520,"KRN","B",.4,.4)

"BLD",3520,"KRN","B",.401,.401)

"BLD",3520,"KRN","B",.402,.402)

"BLD",3520,"KRN","B",.403,.403)

"BLD",3520,"KRN","B",.5,.5)

"BLD",3520,"KRN","B",.84,.84)

"BLD",3520,"KRN","B",3.6,3.6)

"BLD",3520,"KRN","B",3.8,3.8)

"BLD",3520,"KRN","B",9.2,9.2)

"BLD",3520,"KRN","B",9.8,9.8)

"BLD",3520,"KRN","B",19,19)

"BLD",3520,"KRN","B",19.1,19.1)

"BLD",3520,"KRN","B",101,101)

"BLD",3520,"KRN","B",409.61,409.61)

"BLD",3520,"KRN","B",771,771)

"BLD",3520,"KRN","B",870,870)

"BLD",3520,"KRN","B",8994,8994)

"BLD",3520,"QUES",0)
^9.62^^
"BLD",3520,"REQB",0)
^9.611^1^1
"BLD",3520,"REQB",1,0)
ECX*3.0*33^2
"BLD",3520,"REQB","B","ECX*3.0*33",1)

"MBREQ")
0
"PKG",513,-1)
1^1
"PKG",513,0)
DSS EXTRACTS^ECX^Decision Support System. (DSS)
"PKG",513,20,0)
^9.402P^^
"PKG",513,22,0)
^9.49I^1^1
"PKG",513,22,1,0)
3.0^3010108^2980112^11714
"PKG",513,22,1,"PAH",1,0)
36^3010416
"PKG",513,22,1,"PAH",1,1,0)
^^2^2^3010416
"PKG",513,22,1,"PAH",1,1,1,0)
Patch:  ECX*3.0*36   CORRECTIONS TO PROSTHETICS REPORTS
"PKG",513,22,1,"PAH",1,1,2,0)
Please see the description in the NPM for complete information.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
2
"RTN","ECXAPRO")
0^2^B45129674
"RTN","ECXAPRO",1,0)
ECXAPRO ;ALB/JAP - PRO Extract Audit Report ; Nov 16, 1998
"RTN","ECXAPRO",2,0)
 ;;3.0;DSS EXTRACTS;**9,21,33,36**;Dec 22, 1997
"RTN","ECXAPRO",3,0)
 ;
"RTN","ECXAPRO",4,0)
EN ;entry point for PRO extract audit report
"RTN","ECXAPRO",5,0)
 N %X,%Y,DIV,X,Y,DIC,DA,DR,DIQ,DIR,DIRUT,DTOUT,DUOUT
"RTN","ECXAPRO",6,0)
 S ECXERR=0
"RTN","ECXAPRO",7,0)
 ;ecxaud=0 for 'extract' audit
"RTN","ECXAPRO",8,0)
 S ECXHEAD="PRO",ECXAUD=0
"RTN","ECXAPRO",9,0)
 W !!,"Setup for ",ECXHEAD," Extract Audit Report --",!!
"RTN","ECXAPRO",10,0)
 ;determine primary division
"RTN","ECXAPRO",11,0)
 S ECXPRIME=$$PDIV^ECXPUTL
"RTN","ECXAPRO",12,0)
 I ECXPRIME=0 D ^ECXKILL Q
"RTN","ECXAPRO",13,0)
 S DA=ECXPRIME,DIC="^DIC(4,",DIQ(0)="I",DIQ="ECXDIC",DR=".01;99" D EN^DIQ1
"RTN","ECXAPRO",14,0)
 S ECXPRIME=ECXPRIME_U_$G(ECXDIC(4,DA,99,"I"))_U_$G(ECXDIC(4,DA,.01,"I"))
"RTN","ECXAPRO",15,0)
 ;select 1 or more prosthetics divisions for report
"RTN","ECXAPRO",16,0)
 D PRO^ECXDVSN2(DUZ,ECXPRIME,.ECXDIV,.ECXALL,.ECXERR)
"RTN","ECXAPRO",17,0)
 I ECXERR D  Q
"RTN","ECXAPRO",18,0)
 .D ^ECXKILL W !!,?5,"Try again later... exiting.",!
"RTN","ECXAPRO",19,0)
 ;select extract
"RTN","ECXAPRO",20,0)
 D AUDIT^ECXUTLA(ECXHEAD,.ECXERR,.ECXARRAY,ECXAUD)
"RTN","ECXAPRO",21,0)
 I ECXERR=1 D  Q
"RTN","ECXAPRO",22,0)
 .W !!,?5,"Try again later... exiting.",!
"RTN","ECXAPRO",23,0)
 .D AUDIT^ECXKILL
"RTN","ECXAPRO",24,0)
 ;if user's selected division doesn't match extract's division, then quit
"RTN","ECXAPRO",25,0)
 I +ECXPRIME'=ECXARRAY("DIV") D  Q
"RTN","ECXAPRO",26,0)
 .S DIV=+ECXARRAY("DIV") S:$D(^DIC(4,DIV,0)) DIV=$P(^(0),U,1)
"RTN","ECXAPRO",27,0)
 .W !!,?5,"Your primary division ("_$P(ECXPRIME,U,3)_") does not match the"
"RTN","ECXAPRO",28,0)
 .W !,?5,"division ("_DIV_") associated with Extract #"_ECXARRAY("EXTRACT")_"."
"RTN","ECXAPRO",29,0)
 .W !!,?5,"Try again... exiting.",!
"RTN","ECXAPRO",30,0)
 .I $E(IOST)="C" D
"RTN","ECXAPRO",31,0)
 ..S SS=20-$Y F JJ=1:1:SS W !
"RTN","ECXAPRO",32,0)
 ..S DIR(0)="E" W ! D ^DIR K DIR
"RTN","ECXAPRO",33,0)
 ..W @IOF
"RTN","ECXAPRO",34,0)
 ;select summary or detail
"RTN","ECXAPRO",35,0)
 K DIR S DIR(0)="S^D:DETAIL;S:SUMMARY",DIR("A")="Type of Report",DIR("B")="SUMMARY"
"RTN","ECXAPRO",36,0)
 D ^DIR K DIR
"RTN","ECXAPRO",37,0)
 I $D(DIRUT)!($D(DTOUT)) D  Q
"RTN","ECXAPRO",38,0)
 .W !!,?5,"Try again later... exiting.",!
"RTN","ECXAPRO",39,0)
 .D AUDIT^ECXKILL
"RTN","ECXAPRO",40,0)
 S ECXREPT=Y
"RTN","ECXAPRO",41,0)
 ;continue with detail report
"RTN","ECXAPRO",42,0)
 I ECXREPT="D" D
"RTN","ECXAPRO",43,0)
 .F  D ASK2^ECXAPRO2 Q:$D(DIRUT)!($D(DTOUT))
"RTN","ECXAPRO",44,0)
 ;continue with summary report
"RTN","ECXAPRO",45,0)
 I ECXREPT="S" D
"RTN","ECXAPRO",46,0)
 .S ECXPGM="TASK^ECXAPRO",ECXDESC="PRO Extract Audit Report"
"RTN","ECXAPRO",47,0)
 .S ECXSAVE("ECXHEAD")="",ECXSAVE("ECXDIV(")="",ECXSAVE("ECXARRAY(")="",ECXSAVE("ECXREPT")="",ECXSAVE("ECXPRIME")="",ECXSAVE("ECXALL")=""
"RTN","ECXAPRO",48,0)
 .W !
"RTN","ECXAPRO",49,0)
 .;determine output device and queue if requested
"RTN","ECXAPRO",50,0)
 .D DEVICE^ECXUTLA(ECXPGM,ECXDESC,.ECXSAVE) I ECXSAVE("POP")=1 D  Q
"RTN","ECXAPRO",51,0)
 ..W !!,?5,"Try again later... exiting.",!
"RTN","ECXAPRO",52,0)
 ..D AUDIT^ECXKILL
"RTN","ECXAPRO",53,0)
 .I ECXSAVE("ZTSK")=0 D
"RTN","ECXAPRO",54,0)
 ..K ECXSAVE,ECXPGM,ECXDESC
"RTN","ECXAPRO",55,0)
 ..D PROCESS,DISP^ECXAPRO1
"RTN","ECXAPRO",56,0)
 ..;allow user to get details
"RTN","ECXAPRO",57,0)
 ..D ASK^ECXAPRO2
"RTN","ECXAPRO",58,0)
 ;clean-up and close
"RTN","ECXAPRO",59,0)
 I IO'=IO(0) D ^%ZISC
"RTN","ECXAPRO",60,0)
 D HOME^%ZIS
"RTN","ECXAPRO",61,0)
 D AUDIT^ECXKILL
"RTN","ECXAPRO",62,0)
 Q
"RTN","ECXAPRO",63,0)
 ;
"RTN","ECXAPRO",64,0)
TASK ;entry point from taskmanager
"RTN","ECXAPRO",65,0)
 D PROCESS
"RTN","ECXAPRO",66,0)
 I ECXREPT="S" D DISP^ECXAPRO1
"RTN","ECXAPRO",67,0)
 I ECXREPT="D" D DISP^ECXAPRO2
"RTN","ECXAPRO",68,0)
 D AUDIT^ECXKILL
"RTN","ECXAPRO",69,0)
 Q
"RTN","ECXAPRO",70,0)
 ;
"RTN","ECXAPRO",71,0)
PROCESS ;process the data in file #727.826
"RTN","ECXAPRO",72,0)
 N J,CNT,CODE,COST,CPTNM,DATE,DESC,FLG,GN,IEN,KEY,LOC,LABLC,LABMC,NODE,PTNAM,PSASNM,QTY,QFLG,QQFLG,RD,SSN,STN,SRCE,TYPE
"RTN","ECXAPRO",73,0)
 K ^TMP($J)
"RTN","ECXAPRO",74,0)
 S (CNT,QQFLG)=0
"RTN","ECXAPRO",75,0)
 S ECXEXT=ECXARRAY("EXTRACT"),ECXDEF=ECXARRAY("DEF")
"RTN","ECXAPRO",76,0)
 S X=ECXARRAY("START") D ^%DT S ECXSTART=Y S X=ECXARRAY("END") D ^%DT S ECXEND=Y
"RTN","ECXAPRO",77,0)
 D NOW^%DTC S Y=$E(%,1,12) D DD^%DT S ECXRUN=Y
"RTN","ECXAPRO",78,0)
 I ECXALL=0 S J=$O(ECXDIV(99),-1),ECXDIV=ECXDIV(J)
"RTN","ECXAPRO",79,0)
 I ECXALL=1 S ECXDIV=ECXPRIME
"RTN","ECXAPRO",80,0)
 S STN=$P(ECXDIV,U,2)
"RTN","ECXAPRO",81,0)
 ;initialize the prosthetics tmp global for cumulative data
"RTN","ECXAPRO",82,0)
 D CODE^ECXAPRO1
"RTN","ECXAPRO",83,0)
 ;gather extract data and sort by grouper number, calc flag, and nppd code
"RTN","ECXAPRO",84,0)
 S IEN="" F  S IEN=$O(^ECX(727.826,"AC",ECXEXT,IEN)) Q:IEN=""  D  Q:QQFLG
"RTN","ECXAPRO",85,0)
 .S ECXPRO=^ECX(727.826,IEN,0)
"RTN","ECXAPRO",86,0)
 .;
"RTN","ECXAPRO",87,0)
 .;- Remove trailing "^" from ECXPRO if there
"RTN","ECXAPRO",88,0)
 .I $E(ECXPRO,$L(ECXPRO))="^" S ECXPRO=$E(ECXPRO,1,$L(ECXPRO)-1)
"RTN","ECXAPRO",89,0)
 .S ECXPRO=ECXPRO_U_$P(^ECX(727.826,IEN,1),U,4)
"RTN","ECXAPRO",90,0)
 .S DATE=$P(ECXPRO,U,9)
"RTN","ECXAPRO",91,0)
 .S $E(DATE,1,2)=$E(DATE,1,2)-17
"RTN","ECXAPRO",92,0)
 .Q:$L(DATE)<7  Q:(DATE<ECXSTART)  Q:(DATE>ECXEND)
"RTN","ECXAPRO",93,0)
 .S DATE=$E(DATE,4,5)_"/"_$E(DATE,6,7)
"RTN","ECXAPRO",94,0)
 .S PTNAM=$P(ECXPRO,U,7),SSN=$E($P(ECXPRO,U,6),6,9)
"RTN","ECXAPRO",95,0)
 .S LOC=$P(ECXPRO,U,10),KEY=$P(ECXPRO,U,11),QTY=$P(ECXPRO,U,12)
"RTN","ECXAPRO",96,0)
 .S COST=$P(ECXPRO,U,25),LABLC=$P(ECXPRO,U,26),LABMC=$P(ECXPRO,U,27)
"RTN","ECXAPRO",97,0)
 .S GN=$P(ECXPRO,U,34),GN=$S(GN="":" ",1:GN)
"RTN","ECXAPRO",98,0)
 .;don't double count lab items
"RTN","ECXAPRO",99,0)
 .Q:LOC["LAB"
"RTN","ECXAPRO",100,0)
 .;duplicate the logic in sort^rmprn6 that sets cost=0 if form=4
"RTN","ECXAPRO",101,0)
 .I LOC["ORD" S COST=0
"RTN","ECXAPRO",102,0)
 .S LOC=$S(LOC["ORD":$P(LOC,"ORD",1),1:$P(LOC,"NONL",1))
"RTN","ECXAPRO",103,0)
 .;quit if feeder location isn't for division selected for report
"RTN","ECXAPRO",104,0)
 .I ECXALL=1,LOC'[STN Q
"RTN","ECXAPRO",105,0)
 .I ECXALL=0,LOC'=STN Q
"RTN","ECXAPRO",106,0)
 .S TYPE=$E(KEY,6),SRCE=$E(KEY,7)
"RTN","ECXAPRO",107,0)
 .S CPTNM=$P(ECXPRO,U,15),PSASNM=$P(ECXPRO,U,33)
"RTN","ECXAPRO",108,0)
 .D GETCODE(PSASNM,.NODE)
"RTN","ECXAPRO",109,0)
 .Q:NODE=""
"RTN","ECXAPRO",110,0)
 .S CODE=$S(TYPE="X":$P(NODE,U,3),1:$P(NODE,U,4))
"RTN","ECXAPRO",111,0)
 .S FLG=$P(NODE,U,2),DESC=$P(NODE,U,5)
"RTN","ECXAPRO",112,0)
 .S ^TMP($J,"RMPRGN",STN,GN,FLG,CODE,IEN)=TYPE_U_SRCE_U_QTY_U_COST_U_LABLC_U_LABMC_U_PSASNM_U_DESC_U_PTNAM_U_SSN_U_DATE_U_LOC
"RTN","ECXAPRO",113,0)
 ;accumulate summary & detail data
"RTN","ECXAPRO",114,0)
 S GN=""
"RTN","ECXAPRO",115,0)
 F  S GN=$O(^TMP($J,"RMPRGN",STN,GN)) Q:GN=""  D
"RTN","ECXAPRO",116,0)
 .S FLG=0
"RTN","ECXAPRO",117,0)
 .F  S FLG=$O(^TMP($J,"RMPRGN",STN,GN,FLG)) Q:FLG'>0  D
"RTN","ECXAPRO",118,0)
 ..I FLG=1 D GROUP S FLG=2 Q
"RTN","ECXAPRO",119,0)
 ..S CODE=0
"RTN","ECXAPRO",120,0)
 ..F  S CODE=$O(^TMP($J,"RMPRGN",STN,GN,FLG,CODE)) Q:CODE=""  D
"RTN","ECXAPRO",121,0)
 ...S RD=0
"RTN","ECXAPRO",122,0)
 ...F  S RD=$O(^TMP($J,"RMPRGN",STN,GN,FLG,CODE,RD)) Q:RD'>0  D
"RTN","ECXAPRO",123,0)
 ....S TYPE=$P(^TMP($J,"RMPRGN",STN,GN,FLG,CODE,RD),U,1),SRCE=$P(^(RD),U,2),QTY=$P(^(RD),U,3),COST=$P(^(RD),U,4)
"RTN","ECXAPRO",124,0)
 ....S ^TMP($J,CODE,RD)=^TMP($J,"RMPRGN",STN,GN,FLG,CODE,RD)
"RTN","ECXAPRO",125,0)
 ....I TYPE="X" D REP(CODE)
"RTN","ECXAPRO",126,0)
 ....I TYPE="N" D NEW(CODE)
"RTN","ECXAPRO",127,0)
 Q
"RTN","ECXAPRO",128,0)
 ;
"RTN","ECXAPRO",129,0)
GETCODE(PSAS,NODE) ;find the appropriate nppd code using psas hcpcs
"RTN","ECXAPRO",130,0)
 N DIC,X,Y,DESC,FLG,NU,REP
"RTN","ECXAPRO",131,0)
 S NODE=""
"RTN","ECXAPRO",132,0)
 S DIC="^RMPR(661.1,",DIC(0)="XZ",X=PSAS D ^DIC
"RTN","ECXAPRO",133,0)
 I Y=-1 S NODE=U_"2"_U_"R99 Z"_U_"999 Z"_U_"NO HCPCS" Q
"RTN","ECXAPRO",134,0)
 S DESC=$E($P(Y(0),U,2),1,20)
"RTN","ECXAPRO",135,0)
 S FLG=$P(Y(0),U,8) S:FLG="" FLG=2
"RTN","ECXAPRO",136,0)
 ;make sure each code at least 4 characters; group codes are 3 characters in tmp($j,rmprcode)
"RTN","ECXAPRO",137,0)
 S REP=$P(Y(0),U,6) S:$L(REP)=3 REP=REP_" " S:REP="" REP="R99 X"
"RTN","ECXAPRO",138,0)
 S NU=$P(Y(0),U,7) S:$L(NU)=3 NU=NU_" " S:NU="" NU="999 X"
"RTN","ECXAPRO",139,0)
 S NODE=U_FLG_U_REP_U_NU_U_DESC
"RTN","ECXAPRO",140,0)
 Q
"RTN","ECXAPRO",141,0)
 ;
"RTN","ECXAPRO",142,0)
GROUP ;total grouper to main key
"RTN","ECXAPRO",143,0)
 N BF,BL,BR,BCOST,BTCOST,COST,QTY,TYPE,SRCE
"RTN","ECXAPRO",144,0)
 S BF=0,BTCOST=0
"RTN","ECXAPRO",145,0)
 F  S BF=$O(^TMP($J,"RMPRGN",STN,GN,BF)) Q:BF'>0  D
"RTN","ECXAPRO",146,0)
 .S BL=0
"RTN","ECXAPRO",147,0)
 .F  S BL=$O(^TMP($J,"RMPRGN",STN,GN,BF,BL)) Q:BL=""  D
"RTN","ECXAPRO",148,0)
 ..S BR=0
"RTN","ECXAPRO",149,0)
 ..F  S BR=$O(^TMP($J,"RMPRGN",STN,GN,BF,BL,BR)) Q:BR'>0  D
"RTN","ECXAPRO",150,0)
 ...S BCOST=$P(^TMP($J,"RMPRGN",STN,GN,BF,BL,BR),U,4)
"RTN","ECXAPRO",151,0)
 ...S BTCOST=BTCOST+BCOST
"RTN","ECXAPRO",152,0)
 S BL=$O(^TMP($J,"RMPRGN",STN,GN,1,"")),BR=$O(^TMP($J,"RMPRGN",STN,GN,1,BL,""))
"RTN","ECXAPRO",153,0)
 ;calculate based on primary
"RTN","ECXAPRO",154,0)
 S TYPE=$P(^TMP($J,"RMPRGN",STN,GN,1,BL,BR),U,1),SRCE=$P(^(BR),U,2),QTY=$P(^(BR),U,3)
"RTN","ECXAPRO",155,0)
 S COST=BTCOST
"RTN","ECXAPRO",156,0)
 S ^TMP($J,BL,BR)=^TMP($J,"RMPRGN",STN,GN,1,BL,BR),$P(^TMP($J,BL,BR),U,4)=COST
"RTN","ECXAPRO",157,0)
 I TYPE="X" D REP(BL)
"RTN","ECXAPRO",158,0)
 I TYPE="N" D NEW(BL)
"RTN","ECXAPRO",159,0)
 Q
"RTN","ECXAPRO",160,0)
 ;
"RTN","ECXAPRO",161,0)
REP(C) ;calculate repair cost
"RTN","ECXAPRO",162,0)
 N LINE
"RTN","ECXAPRO",163,0)
 S LINE=C
"RTN","ECXAPRO",164,0)
 I LINE="R90 A" S SRCE="C",QTY=1
"RTN","ECXAPRO",165,0)
 I $G(^TMP($J,"R",STN,LINE))="" S ^TMP($J,"R",STN,LINE)=""
"RTN","ECXAPRO",166,0)
 I SRCE["V" S $P(^TMP($J,"R",STN,LINE),U,1)=$P(^TMP($J,"R",STN,LINE),U,1)+QTY
"RTN","ECXAPRO",167,0)
 I SRCE["C" S $P(^TMP($J,"R",STN,LINE),U,2)=$P(^TMP($J,"R",STN,LINE),U,2)+QTY
"RTN","ECXAPRO",168,0)
 S $P(^TMP($J,"R",STN,LINE),U,3)=$P(^TMP($J,"R",STN,LINE),U,3)+COST
"RTN","ECXAPRO",169,0)
 Q
"RTN","ECXAPRO",170,0)
 ;
"RTN","ECXAPRO",171,0)
NEW(C) ;calculate new costs
"RTN","ECXAPRO",172,0)
 N LINE
"RTN","ECXAPRO",173,0)
 S LINE=C
"RTN","ECXAPRO",174,0)
 I $G(^TMP($J,"N",STN,LINE))="" S ^TMP($J,"N",STN,LINE)=""
"RTN","ECXAPRO",175,0)
 I SRCE["V" S $P(^TMP($J,"N",STN,LINE),U,1)=$P(^TMP($J,"N",STN,LINE),U,1)+QTY
"RTN","ECXAPRO",176,0)
 I SRCE["C" S $P(^TMP($J,"N",STN,LINE),U,2)=$P(^TMP($J,"N",STN,LINE),U,2)+QTY
"RTN","ECXAPRO",177,0)
 S $P(^TMP($J,"N",STN,LINE),U,3)=$P(^TMP($J,"N",STN,LINE),U,3)+COST
"RTN","ECXAPRO",178,0)
 Q
"RTN","ECXLPRO")
0^1^B25268332
"RTN","ECXLPRO",1,0)
ECXLPRO ;ALB/JAP - PRO Extract YTD Lab Report ; Feb 17, 1999
"RTN","ECXLPRO",2,0)
 ;;3.0;DSS EXTRACTS;**21,24,36**;Dec 22, 1997
"RTN","ECXLPRO",3,0)
 ;for data associated with prosthetic items produced by facility laboratory
"RTN","ECXLPRO",4,0)
 ;accumulates extract data by hcpcs code for all extracts in fiscal year date range
"RTN","ECXLPRO",5,0)
 ;if an extract has been purged, then totals will be falsely low
"RTN","ECXLPRO",6,0)
 ;if more than 1 extract exists for a particular month, then totals will be falsely high
"RTN","ECXLPRO",7,0)
 ;if site is multidivisional, then user can generate report for
"RTN","ECXLPRO",8,0)
 ;  any one division - data stored under divisional station# (e.g., 326 or 326AB)
"RTN","ECXLPRO",9,0)
 ;  or for entire facility - data stored under primary station# (e.g., 326) but includes data from all subdivisions
"RTN","ECXLPRO",10,0)
 ;if site is non-divisional, then data stored under facility station#
"RTN","ECXLPRO",11,0)
 ;
"RTN","ECXLPRO",12,0)
EN ;setup & queue
"RTN","ECXLPRO",13,0)
 N DIC,DA,DR,DIQ,DIR,DIRUT,DTOUT,DUOUT,DIV,LAST,OUT
"RTN","ECXLPRO",14,0)
 S ECXERR=0
"RTN","ECXLPRO",15,0)
 S ECXHEAD="PRO"
"RTN","ECXLPRO",16,0)
 W !!,"Setup for PRO Extract YTD Laboratory Report --",!
"RTN","ECXLPRO",17,0)
 ;determine primary division
"RTN","ECXLPRO",18,0)
 W !,"If you belong to more than one Primary Division, you must"
"RTN","ECXLPRO",19,0)
 W !,"select a Primary Division for the report.",!
"RTN","ECXLPRO",20,0)
 S ECXPRIME=$$PDIV^ECXPUTL
"RTN","ECXLPRO",21,0)
 I ECXPRIME=0 D ^ECXKILL Q
"RTN","ECXLPRO",22,0)
 S DA=ECXPRIME,DIC="^DIC(4,",DIQ(0)="I",DIQ="ECXDIC",DR=".01;99" D EN^DIQ1
"RTN","ECXLPRO",23,0)
 S ECXPRIME=ECXPRIME_U_$G(ECXDIC(4,DA,99,"I"))_U_$G(ECXDIC(4,DA,.01,"I"))
"RTN","ECXLPRO",24,0)
 ;get all prosthetics divisions for report
"RTN","ECXLPRO",25,0)
 S ECXALL=1
"RTN","ECXLPRO",26,0)
 D PDIV3^ECXPUTL(DUZ,ECXPRIME,.ECXDIV)
"RTN","ECXLPRO",27,0)
 I ECXERR D  Q
"RTN","ECXLPRO",28,0)
 .D ^ECXKILL W !!,?5,"Try again later... exiting.",!
"RTN","ECXLPRO",29,0)
 ;determine fiscal year of report
"RTN","ECXLPRO",30,0)
 S DIR(0)="SMBA^C:CURRENT;P:PREVIOUS",DIR("A")="Select C(urrent) or P(revious) Fiscal Year: ",DIR("B")="CURRENT"
"RTN","ECXLPRO",31,0)
 W ! K X,Y D ^DIR K DIR
"RTN","ECXLPRO",32,0)
 I $D(DUOUT)!($D(DTOUT)) D  Q
"RTN","ECXLPRO",33,0)
 .D ^ECXKILL W !!,?5,"Try again later... exiting.",!
"RTN","ECXLPRO",34,0)
 I Y="C" D
"RTN","ECXLPRO",35,0)
 .S X=$$CYFY^ECXUTL1(DT),ECXARRAY("START")=$P(X,U,3),ECXARRAY("END")=$P(X,U,4)
"RTN","ECXLPRO",36,0)
 I Y="P" D
"RTN","ECXLPRO",37,0)
 .S YR=$E(DT,1,3),MON=$E(DT,4,5) S:+MON<10 YR=YR-1 S X1=YR_"0930"
"RTN","ECXLPRO",38,0)
 .S X=$$CYFY^ECXUTL1(X1),ECXARRAY("START")=$P(X,U,3),ECXARRAY("END")=$P(X,U,4)
"RTN","ECXLPRO",39,0)
 .K C,MON,YR,X1
"RTN","ECXLPRO",40,0)
 ;setup variables for taskmanager
"RTN","ECXLPRO",41,0)
 S ECXPGM="PROCESS^ECXLPRO",ECXDESC="PRO Extract YTD HCPCS Report"
"RTN","ECXLPRO",42,0)
 S ECXSAVE("ECXHEAD")="",ECXSAVE("ECXDIV(")="",ECXSAVE("ECXARRAY(")="",ECXSAVE("ECXPRIME")="",ECXSAVE("ECXALL")=""
"RTN","ECXLPRO",43,0)
 ;determine output device and queue if requested
"RTN","ECXLPRO",44,0)
 W !!,"Please note: The PRO Extract YTD Laboratory Report requires 132 columns."
"RTN","ECXLPRO",45,0)
 W !,"             Select an appropriate device for output."
"RTN","ECXLPRO",46,0)
 W ! D DEVICE^ECXUTLA(ECXPGM,ECXDESC,.ECXSAVE)
"RTN","ECXLPRO",47,0)
 I ECXSAVE("POP")=1 W ! D ^ECXKILL Q
"RTN","ECXLPRO",48,0)
 I ECXSAVE("ZTSK")=0 D
"RTN","ECXLPRO",49,0)
 .K ECXSAVE,ECXPGM,ECXDESC
"RTN","ECXLPRO",50,0)
 .D PROCESS
"RTN","ECXLPRO",51,0)
 ;clean-up and close
"RTN","ECXLPRO",52,0)
 I IO'=IO(0) D ^%ZISC
"RTN","ECXLPRO",53,0)
 D HOME^%ZIS
"RTN","ECXLPRO",54,0)
 Q
"RTN","ECXLPRO",55,0)
 ;
"RTN","ECXLPRO",56,0)
PROCESS ;begin processing
"RTN","ECXLPRO",57,0)
 N DIVISION,E,EXTRACT,REC,NODE0,NODE1,LASTDAY
"RTN","ECXLPRO",58,0)
 K ^TMP($J,"ECXP") S LASTDAY=""
"RTN","ECXLPRO",59,0)
 ;determine which extracts contain data for report
"RTN","ECXLPRO",60,0)
 S (EXTRACT,E)=0
"RTN","ECXLPRO",61,0)
 F  S E=$O(^ECX(727,"E",ECXHEAD,E)) Q:'E  D
"RTN","ECXLPRO",62,0)
 .Q:'$D(^ECX(727,E,0))
"RTN","ECXLPRO",63,0)
 .Q:$P($G(^ECX(727,E,0)),U,4)<ECXARRAY("START")
"RTN","ECXLPRO",64,0)
 .Q:$P($G(^ECX(727,E,0)),U,4)>ECXARRAY("END")
"RTN","ECXLPRO",65,0)
 .Q:$G(^ECX(727,E,"DIV"))'=+ECXPRIME
"RTN","ECXLPRO",66,0)
 .S EXTRACT(E)=^ECX(727,E,0)
"RTN","ECXLPRO",67,0)
 .I $P(EXTRACT(E),U,5)>LASTDAY S LASTDAY=$P(EXTRACT(E),U,5)
"RTN","ECXLPRO",68,0)
 ;setup array of station numbers included in report
"RTN","ECXLPRO",69,0)
 F DIV=0:0 S DIV=$O(ECXDIV(DIV)) Q:'DIV  S ECXSTAT=$P(ECXDIV(DIV),U,2),DIVISION(ECXSTAT)=ECXDIV(DIV)
"RTN","ECXLPRO",70,0)
 ;get the extract data
"RTN","ECXLPRO",71,0)
 S E=0 F  S E=$O(EXTRACT(E)) Q:'E  S REC=0 I $D(^ECX(727.826,"AC",E)) F  S REC=$O(^ECX(727.826,"AC",E,REC)) Q:'REC  D
"RTN","ECXLPRO",72,0)
 .S NODE0=$G(^ECX(727.826,REC,0)),NODE1=$G(^ECX(727.826,REC,1)) Q:NODE0=""
"RTN","ECXLPRO",73,0)
 .S (ECXCTAMT,ECXLLC,ECXLMC)=0
"RTN","ECXLPRO",74,0)
 .S ECXFELOC=$P(NODE0,U,10),ECXFEKEY=$P(NODE0,U,11)
"RTN","ECXLPRO",75,0)
 .;ignore any record which isn't for lab receiving station
"RTN","ECXLPRO",76,0)
 .Q:ECXFELOC'["LAB"
"RTN","ECXLPRO",77,0)
 .S ECXHCPC=$E(ECXFEKEY,1,5),ECXTYPE=$E(ECXFEKEY,6),ECXREQ=$P($E(ECXFEKEY,8,99),"REQ",1)
"RTN","ECXLPRO",78,0)
 .S ECXQTY=$P(NODE0,U,12),ECXCTAMT=$P(NODE0,U,25),ECXGRPR=$P(NODE1,U,4)
"RTN","ECXLPRO",79,0)
 .S ECXSTAT=$P(ECXFELOC,"LAB",1),ECXFORM="LAB"
"RTN","ECXLPRO",80,0)
 .S ECXLLC=$P(NODE0,U,26),ECXLMC=$P(NODE0,U,27)
"RTN","ECXLPRO",81,0)
 .;ignore record if division not included in this report
"RTN","ECXLPRO",82,0)
 .Q:ECXSTAT=""  Q:'$D(DIVISION(ECXSTAT))
"RTN","ECXLPRO",83,0)
 .;set in ^tmp using primary station#; determine if requesting station is same as or part of this station
"RTN","ECXLPRO",84,0)
 .S ECXLAB="",ECXSTAT=+ECXSTAT,ECXLAB=$S(ECXREQ'[ECXSTAT:"OTHER",1:"SAME")
"RTN","ECXLPRO",85,0)
 .;be sure there's no padding on cost variables
"RTN","ECXLPRO",86,0)
 .S ECXCTAMT=+$TR(ECXCTAMT," ",0),ECXLLC=+$TR(ECXLLC," ",0),ECXLMC=+$TR(ECXLMC," ",0)
"RTN","ECXLPRO",87,0)
 .;tmp global holds - lab qty^lab labor cost^lab matrl cost
"RTN","ECXLPRO",88,0)
 .I '$D(^TMP($J,"ECXP",ECXTYPE,ECXHCPC)) S ^TMP($J,"ECXP",ECXTYPE,ECXHCPC,"SAME")="0^0^0",^TMP($J,"ECXP",ECXTYPE,ECXHCPC,"OTHER")="0^0^0"
"RTN","ECXLPRO",89,0)
 .S $P(^TMP($J,"ECXP",ECXTYPE,ECXHCPC,ECXLAB),U,1)=$P(^TMP($J,"ECXP",ECXTYPE,ECXHCPC,ECXLAB),U,1)+ECXQTY
"RTN","ECXLPRO",90,0)
 .S $P(^TMP($J,"ECXP",ECXTYPE,ECXHCPC,ECXLAB),U,2)=$P(^TMP($J,"ECXP",ECXTYPE,ECXHCPC,ECXLAB),U,2)+ECXLLC
"RTN","ECXLPRO",91,0)
 .S $P(^TMP($J,"ECXP",ECXTYPE,ECXHCPC,ECXLAB),U,3)=$P(^TMP($J,"ECXP",ECXTYPE,ECXHCPC,ECXLAB),U,3)+ECXLMC
"RTN","ECXLPRO",92,0)
 ;setup hcpcs descriptions
"RTN","ECXLPRO",93,0)
 D HCPCS
"RTN","ECXLPRO",94,0)
 ;print report
"RTN","ECXLPRO",95,0)
 D PRINT^ECXLPRO1
"RTN","ECXLPRO",96,0)
 ;cleanup
"RTN","ECXLPRO",97,0)
 D AUDIT^ECXKILL
"RTN","ECXLPRO",98,0)
 Q
"RTN","ECXLPRO",99,0)
 ;
"RTN","ECXLPRO",100,0)
HCPCS ;setup hcpcs cross-reference
"RTN","ECXLPRO",101,0)
 N H,CPT,CPTNM,DESC
"RTN","ECXLPRO",102,0)
 S H=0
"RTN","ECXLPRO",103,0)
 F  S H=$O(^RMPR(661.1,H)) Q:+H<1  D
"RTN","ECXLPRO",104,0)
 .;don't skip inactive hcpcs in case doing previous fy
"RTN","ECXLPRO",105,0)
 .S CPTNM="",CPT=$P(^RMPR(661.1,H,0),U,4)
"RTN","ECXLPRO",106,0)
 .I +CPT>0 S CPTNM=$P(^ICPT(CPT,0),U,1),DESC=$E($P(^ICPT(CPT,0),U,2),1,26)
"RTN","ECXLPRO",107,0)
 .Q:CPTNM=""
"RTN","ECXLPRO",108,0)
 .S ^TMP($J,"HCPCS",CPTNM)=DESC
"RTN","ECXLPRO",109,0)
 Q
"VER")
8.0^22.0
**END**
**END**
