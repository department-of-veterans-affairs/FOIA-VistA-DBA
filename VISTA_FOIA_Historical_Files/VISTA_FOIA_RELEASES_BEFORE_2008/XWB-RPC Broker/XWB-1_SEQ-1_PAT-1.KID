Released XWB*1*1 SEQ #1
Extracted from mail message
**KIDS**:XWB*1.0*1^

**INSTALL NAME**
XWB*1.0*1
"BLD",62,0)
XWB*1.0*1^^0^2961030^n
"BLD",62,1,0)
^^109^109^2961030^^^^
"BLD",62,1,1,0)
RPC Broker 1.0 patch 1 contains the following features:
"BLD",62,1,2,0)
 
"BLD",62,1,3,0)
1. The removal of extraneous error trap resetting code from the 
"BLD",62,1,4,0)
   XWBBRK2 routine.  Specifically, lines CAPI+7 - CAPI+8 have
"BLD",62,1,5,0)
   been removed.
"BLD",62,1,6,0)
 
"BLD",62,1,7,0)
2. An enhancement that allows a closed root return value from an
"BLD",62,1,8,0)
   RPC which has a return type of ARRAY.
"BLD",62,1,9,0)
 
"BLD",62,1,10,0)
3. The $GET function is no longer used when resolving REFERENCE type
"BLD",62,1,11,0)
   parameters.  Therefore, if the parameter reference is undefined,
"BLD",62,1,12,0)
   an M error will be generated and trapped on the server.
"BLD",62,1,13,0)
 
"BLD",62,1,14,0)
4. An MSM null device will be used to catch all inadvertent WRITEs in
"BLD",62,1,15,0)
   RPCs, specifically, those in "ID" nodes of files.  This requires
"BLD",62,1,16,0)
   that MSM sites set up the following entry in the DEVICE file:
"BLD",62,1,17,0)
 
"BLD",62,1,18,0)
   NAME: NULL                           $I: (version specific)
"BLD",62,1,19,0)
     ASK DEVICE: YES                    ASK PARAMETERS: NO
"BLD",62,1,20,0)
     SIGN-ON/SYSTEM DEVICE: NO          LOCATION OF TERMINAL: NT SYSTEM
"BLD",62,1,21,0)
     SUBTYPE: C-VT100                   TYPE: TERMINAL
"BLD",62,1,22,0)

"BLD",62,1,23,0)
     $I Value            MSM Version
"BLD",62,1,24,0)
     --------            ----------------------------------------
"BLD",62,1,25,0)
         46              MSM for Windows NT, Version 4.3.0 Beta-B
"BLD",62,1,26,0)
        199              MSM for Windows NT, Version 4.2.4
"BLD",62,1,27,0)
 
"BLD",62,1,28,0)
5. The addition of an internal version stamp of Broker packets.  This
"BLD",62,1,29,0)
   allows future incremental updates of the RPC Broker without an
"BLD",62,1,30,0)
   adverse impact on packages using it.
"BLD",62,1,31,0)
 
"BLD",62,1,32,0)
6. An enhancement that provides support for MULTIPLE Listeners.
"BLD",62,1,33,0)
   With this patch, a site can now start MULTIPLE Broker Listener
"BLD",62,1,34,0)
   processes in ONE account.  However, no two listeners, regardless
"BLD",62,1,35,0)
   of the UCIs in which they are running, can share the same port
"BLD",62,1,36,0)
   on one server.  Additionally, if two or more Listeners are running
"BLD",62,1,37,0)
   out of the same UCI-volume set, they cannot listen on the same port,
"BLD",62,1,38,0)
   even if the Listener processes are on differen CPUs.
"BLD",62,1,39,0)
   See NOIS SDC-0796-61985.
"BLD",62,1,40,0)

"BLD",62,1,41,0)
7. A correction of a bug which caused an innocuous error at
"BLD",62,1,42,0)
   RESTART+16^XWBTCPL:1 when stopping the Broker listener.
"BLD",62,1,43,0)
   See NOIS DAY-0796-40990.
"BLD",62,1,44,0)

"BLD",62,1,45,0)
8. A correction that fixes a bug in the pattern match on line 
"BLD",62,1,46,0)
   CREF+7^XWBBRK2.  Previously, this routine would misinterpret
"BLD",62,1,47,0)
   the "E^33310.5" parameter literal as an array.
"BLD",62,1,48,0)

"BLD",62,1,49,0)
9. An enhancement that improves the detection of problems during the
"BLD",62,1,50,0)
   startup of the Listener.  If a Listener cannot start listening
"BLD",62,1,51,0)
   on a given port (e.g., port may be busy), it will generate an 
"BLD",62,1,52,0)
   error on the server and retry up to FIVE times while continuously 
"BLD",62,1,53,0)
   informing the user of its status.
"BLD",62,1,54,0)

"BLD",62,1,55,0)
======================================================================
"BLD",62,1,56,0)
This patch should be installed during off-peak hours. Users can be on
"BLD",62,1,57,0)
the system, however, no user should be using any RPC Broker-based
"BLD",62,1,58,0)
applications during the installation of this patch.
"BLD",62,1,59,0)
======================================================================
"BLD",62,1,60,0)

"BLD",62,1,61,0)
Associated patches: (v)XU*8*24   <<= must be installed BEFORE `XWB*1*1'
"BLD",62,1,62,0)
  
"BLD",62,1,63,0)

"BLD",62,1,64,0)
INSTALLATION:
"BLD",62,1,65,0)

"BLD",62,1,66,0)
  1.  Check the system status (e.g., %SY or %SS) to see if the XWBTCPL
"BLD",62,1,67,0)
      routine is running (i.e., the Listener process). If it's running,
"BLD",62,1,68,0)
      stop the Listener process by typing D STOP^XWBTCP(nnnn) on the
"BLD",62,1,69,0)
      same CPU where the Listener was started. (NOTE: nnnn is the 
"BLD",62,1,70,0)
      same port which was used to start the Listener).
"BLD",62,1,71,0)
  
"BLD",62,1,72,0)
  2.  Disable mapping for the affected routines (see routine list 
"BLD",62,1,73,0)
      below). These patch routines are usually mapped on systems that
"BLD",62,1,74,0)
      allow mapping.
"BLD",62,1,75,0)
  
"BLD",62,1,76,0)
  3.  Load the KIDS package onto your system. Use the INSTALL/CHECK
"BLD",62,1,77,0)
      MESSAGE option on the PackMan menu. The patch will be loaded
"BLD",62,1,78,0)
      into a Transport global on your system.
"BLD",62,1,79,0)
  
"BLD",62,1,80,0)
  4.  Install the Transport global using KIDS.  
"BLD",62,1,81,0)
  
"BLD",62,1,82,0)
  5.  Use the following options under the Installation menu of the
"BLD",62,1,83,0)
      KIDS menu to complete the installation:
"BLD",62,1,84,0)
         a.  Print Transport Global
"BLD",62,1,85,0)
         b.  Compare Transport Global to Current System
"BLD",62,1,86,0)
         c.  Verify Checksums in Transport Global
"BLD",62,1,87,0)
         d.  Backup a Transport Global
"BLD",62,1,88,0)
         e.  Install Package(s)
"BLD",62,1,89,0)
  
"BLD",62,1,90,0)
  6.  MSM Sites - Answer YES to the question "Want to MOVE routines to
"BLD",62,1,91,0)
      other CPUs?". Enter the names of the Compute and Print server(s).
"BLD",62,1,92,0)
  
"BLD",62,1,93,0)
  7.  AXP Sites - After the patch has been installed, rebuild your
"BLD",62,1,94,0)
      map set.
"BLD",62,1,95,0)
  
"BLD",62,1,96,0)
 =====================================================================
"BLD",62,1,97,0)
  
"BLD",62,1,98,0)
 ROUTINES:
"BLD",62,1,99,0)
   The second line of the routine now looks like the following:
"BLD",62,1,100,0)
       ;;1.0;RPC BROKER;**1**;May 24, 1996
"BLD",62,1,101,0)
 
"BLD",62,1,102,0)
 Name           Checksum        Patch List
"BLD",62,1,103,0)
 -----------------------------------------
"BLD",62,1,104,0)
 XWBBRK         3915012         1
"BLD",62,1,105,0)
 XWBBRK2        2906456         1
"BLD",62,1,106,0)
 XWBTCP         3655053         1
"BLD",62,1,107,0)
 XWBTCPC        6796695         1
"BLD",62,1,108,0)
 XWBTCPL        5976073         1
"BLD",62,1,109,0)
 =====================================================================
"BLD",62,4,0)
^9.64PA^^
"BLD",62,"KRN",0)
^9.67PA^19^18
"BLD",62,"KRN",.4,0)
.4
"BLD",62,"KRN",.401,0)
.401
"BLD",62,"KRN",.402,0)
.402
"BLD",62,"KRN",.403,0)
.403
"BLD",62,"KRN",.5,0)
.5
"BLD",62,"KRN",.84,0)
.84
"BLD",62,"KRN",3.6,0)
3.6
"BLD",62,"KRN",3.8,0)
3.8
"BLD",62,"KRN",9.2,0)
9.2
"BLD",62,"KRN",9.8,0)
9.8
"BLD",62,"KRN",9.8,"NM",0)
^9.68A^5^5
"BLD",62,"KRN",9.8,"NM",1,0)
XWBBRK^^0^B28827837
"BLD",62,"KRN",9.8,"NM",2,0)
XWBBRK2^^0^B17592735
"BLD",62,"KRN",9.8,"NM",3,0)
XWBTCP^^0^B9311723
"BLD",62,"KRN",9.8,"NM",4,0)
XWBTCPC^^0^B31673061
"BLD",62,"KRN",9.8,"NM",5,0)
XWBTCPL^^0^B17962615
"BLD",62,"KRN",9.8,"NM","B","XWBBRK",1)

"BLD",62,"KRN",9.8,"NM","B","XWBBRK2",2)

"BLD",62,"KRN",9.8,"NM","B","XWBTCP",3)

"BLD",62,"KRN",9.8,"NM","B","XWBTCPC",4)

"BLD",62,"KRN",9.8,"NM","B","XWBTCPL",5)

"BLD",62,"KRN",19,0)
19
"BLD",62,"KRN",19.1,0)
19.1
"BLD",62,"KRN",101,0)
101
"BLD",62,"KRN",409.61,0)
409.61
"BLD",62,"KRN",771,0)
771
"BLD",62,"KRN",869.2,0)
869.2
"BLD",62,"KRN",870,0)
870
"BLD",62,"KRN",8994,0)
8994
"BLD",62,"KRN","B",.4,.4)

"BLD",62,"KRN","B",.401,.401)

"BLD",62,"KRN","B",.402,.402)

"BLD",62,"KRN","B",.403,.403)

"BLD",62,"KRN","B",.5,.5)

"BLD",62,"KRN","B",.84,.84)

"BLD",62,"KRN","B",3.6,3.6)

"BLD",62,"KRN","B",3.8,3.8)

"BLD",62,"KRN","B",9.2,9.2)

"BLD",62,"KRN","B",9.8,9.8)

"BLD",62,"KRN","B",19,19)

"BLD",62,"KRN","B",19.1,19.1)

"BLD",62,"KRN","B",101,101)

"BLD",62,"KRN","B",409.61,409.61)

"BLD",62,"KRN","B",771,771)

"BLD",62,"KRN","B",869.2,869.2)

"BLD",62,"KRN","B",870,870)

"BLD",62,"KRN","B",8994,8994)

"BLD",62,"QUES",0)
^9.62^^
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
5
"RTN","XWBBRK")
0^1^B28827837
"RTN","XWBBRK",1,0)
XWBBRK ;ISC-SF/EG - DHCP BROKER PROTOYPE ;08/20/96  14:29
"RTN","XWBBRK",2,0)
 ;;1.0;RPC BROKER;**1**;May 24, 1996
"RTN","XWBBRK",3,0)
 ;
"RTN","XWBBRK",4,0)
PRSP(P) ;Parse Protocol
"RTN","XWBBRK",5,0)
 ;M Extrinsic Function
"RTN","XWBBRK",6,0)
 ;
"RTN","XWBBRK",7,0)
 ;Inputs
"RTN","XWBBRK",8,0)
 ;P        Protocol string with the form
"RTN","XWBBRK",9,0)
 ;         Protocol := Protocol Header^Message where
"RTN","XWBBRK",10,0)
 ;         Protocol Header := LLLWKID;WINH;PRCH;WISH;MESG
"RTN","XWBBRK",11,0)
 ;           LLL  := length of protocol header (3 numeric)
"RTN","XWBBRK",12,0)
 ;           WKID := Workstation ID (ALPHA)
"RTN","XWBBRK",13,0)
 ;           WINH := Window handle (ALPHA)
"RTN","XWBBRK",14,0)
 ;           PRCH := Process handle (ALPHA)
"RTN","XWBBRK",15,0)
 ;           WISH := Window server handle (ALPHA)
"RTN","XWBBRK",16,0)
 ;           MESG := Unparsed message
"RTN","XWBBRK",17,0)
 ;Outputs
"RTN","XWBBRK",18,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",19,0)
 ;
"RTN","XWBBRK",20,0)
 N ERR,C,M,R,X,U
"RTN","XWBBRK",21,0)
 S U="U",R=0,C=";"
"RTN","XWBBRK",22,0)
 S M=512 ;Maximum buffer input
"RTN","XWBBRK",23,0)
 S ERR=0
"RTN","XWBBRK",24,0)
 IF $E(P,1,5)="{XWB}" S P=$E(P,6,$L(P)) ;drop out prefix
"RTN","XWBBRK",25,0)
 IF '+$G(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",26,0)
 IF +ERR=0 D
"RTN","XWBBRK",27,0)
 . S XWB(R,"LENG")=+$E(P,1,3)
"RTN","XWBBRK",28,0)
 . S X=$E(P,4,XWB(R,"LENG")+3)
"RTN","XWBBRK",29,0)
 . S XWB(R,"MESG")=$E(P,XWB(R,"LENG")+4,M)
"RTN","XWBBRK",30,0)
 . S XWB(R,"WKID")=$P(X,C)
"RTN","XWBBRK",31,0)
 . S XWB(R,"WINH")=$P(X,C,2)
"RTN","XWBBRK",32,0)
 . S XWB(R,"PRCH")=$P(X,C,3)
"RTN","XWBBRK",33,0)
 . S XWB(R,"WISH")=$P(X,C,4)
"RTN","XWBBRK",34,0)
 Q ERR
"RTN","XWBBRK",35,0)
 ;
"RTN","XWBBRK",36,0)
PRSM(P) ;Parse message
"RTN","XWBBRK",37,0)
 ;M Extrinsic Function
"RTN","XWBBRK",38,0)
 ;
"RTN","XWBBRK",39,0)
 ;Inputs
"RTN","XWBBRK",40,0)
 ;P        Message string with the form
"RTN","XWBBRK",41,0)
 ;         Message := Header^Content
"RTN","XWBBRK",42,0)
 ;           Header  := LLL;FLAG
"RTN","XWBBRK",43,0)
 ;             LLL     := length of entire message (3 numeric)
"RTN","XWBBRK",44,0)
 ;             FLAG    := 1 indicates variables follow
"RTN","XWBBRK",45,0)
 ;           Content := Contains API call information
"RTN","XWBBRK",46,0)
 ;Outputs
"RTN","XWBBRK",47,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",48,0)
 N C,ERR,M,R,X,U
"RTN","XWBBRK",49,0)
 S U="^",R=1,C=";"
"RTN","XWBBRK",50,0)
 S M=512 ;Max buffer
"RTN","XWBBRK",51,0)
 S ERR=0
"RTN","XWBBRK",52,0)
 IF '+$G(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",53,0)
 IF +ERR=0 D
"RTN","XWBBRK",54,0)
 . S XWB(R,"LENG")=+$E(P,1,5)
"RTN","XWBBRK",55,0)
 . S XWB(R,"FLAG")=$E(P,6,6)
"RTN","XWBBRK",56,0)
 . S XWB(R,"TEXT")=$E(P,7,M)
"RTN","XWBBRK",57,0)
 Q ERR
"RTN","XWBBRK",58,0)
 ;
"RTN","XWBBRK",59,0)
PRSA(P) ;Parse API information, get calling info
"RTN","XWBBRK",60,0)
 ;M Extrinsic Function
"RTN","XWBBRK",61,0)
 ;Inputs
"RTN","XWBBRK",62,0)
 ;P        Content := API Name^Param string
"RTN","XWBBRK",63,0)
 ;           API     := .01 field of API file
"RTN","XWBBRK",64,0)
 ;           Param   := Parameter information
"RTN","XWBBRK",65,0)
 ;Outputs
"RTN","XWBBRK",66,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",67,0)
 ;
"RTN","XWBBRK",68,0)
 N C,DR,ERR,M,R,T,X,U
"RTN","XWBBRK",69,0)
 S U="^",R=2,C=";"
"RTN","XWBBRK",70,0)
 S M=512 ;Max buffer
"RTN","XWBBRK",71,0)
 S ERR=0
"RTN","XWBBRK",72,0)
 IF '+$L(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",73,0)
 IF +ERR=0 D
"RTN","XWBBRK",74,0)
 . S XWB(R,"CAPI")=$P(P,U)
"RTN","XWBBRK",75,0)
 . S XWB(R,"PARM")=$E(P,$F(P,U),M)
"RTN","XWBBRK",76,0)
 . S T=$O(^XWB(8994,"B",XWB(R,"CAPI"),0))
"RTN","XWBBRK",77,0)
 . S T(0)=$G(^XWB(8994,T,0))
"RTN","XWBBRK",78,0)
 . S XWB(R,"NAME")=$P(T(0),"^")
"RTN","XWBBRK",79,0)
 . S XWB(R,"RTAG")=$P(T(0),"^",2)
"RTN","XWBBRK",80,0)
 . S XWB(R,"RNAM")=$P(T(0),"^",3)
"RTN","XWBBRK",81,0)
 . S XWBPTYPE=$P(T(0),"^",4)
"RTN","XWBBRK",82,0)
 . S XWBWRAP=+$P(T(0),"^",8)
"RTN","XWBBRK",83,0)
 Q ERR
"RTN","XWBBRK",84,0)
 ;
"RTN","XWBBRK",85,0)
PRSB(P) ;Parse Parameter information
"RTN","XWBBRK",86,0)
 ;M Extrinsic Function
"RTN","XWBBRK",87,0)
 ;Inputs
"RTN","XWBBRK",88,0)
 ;P        Param   := M parameter list
"RTN","XWBBRK",89,0)
 ;           Param   := LLL,Name,Value
"RTN","XWBBRK",90,0)
 ;             LLL     := length of variable name and value
"RTN","XWBBRK",91,0)
 ;             Name    := name of M variable
"RTN","XWBBRK",92,0)
 ;             Value   := a string
"RTN","XWBBRK",93,0)
 ;Outputs
"RTN","XWBBRK",94,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",95,0)
 ;
"RTN","XWBBRK",96,0)
 N A,ERR,F,FL,I,K,L,M,P1,P2,P3,P4,P5,MAXP,R
"RTN","XWBBRK",97,0)
 S R=3
"RTN","XWBBRK",98,0)
 S MAXP=+$E(P,1,5)
"RTN","XWBBRK",99,0)
 S P1=$E(P,6,MAXP+5) ;only param string
"RTN","XWBBRK",100,0)
 S ERR=0
"RTN","XWBBRK",101,0)
 S F=3,M=512
"RTN","XWBBRK",102,0)
 IF '+$D(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",103,0)
 S FL=+$G(XWB(1,"FLAG"))
"RTN","XWBBRK",104,0)
 S I=0
"RTN","XWBBRK",105,0)
 IF '+ERR D
"RTN","XWBBRK",106,0)
 . ;IF 'FL S P1=$E(P,F+1,MAXP) Q
"RTN","XWBBRK",107,0)
 . IF 'FL,+MAXP=0 S P1="",ERR=1 Q
"RTN","XWBBRK",108,0)
 . F  D  Q:P1=""
"RTN","XWBBRK",109,0)
 . . Q:P1=""
"RTN","XWBBRK",110,0)
 . . S L=+$E(P1,1,3)-1
"RTN","XWBBRK",111,0)
 . . S P3=+$E(P1,4,4)
"RTN","XWBBRK",112,0)
 . . S P1=$E(P1,5,MAXP)
"RTN","XWBBRK",113,0)
 . . S XWB(R,"P",I)=$S(P3'=1:$E(P1,1,L),1:$$GETV($E(P1,1,L)))
"RTN","XWBBRK",114,0)
 . . IF FL=1 D
"RTN","XWBBRK",115,0)
 . . . S A=$$OARY^XWBBRK2,XWBARY=A
"RTN","XWBBRK",116,0)
 . . . S XWB(R,"P",I)=$$CREF^XWBBRK2(A,XWB(R,"P",I))
"RTN","XWBBRK",117,0)
 . . S P1=$E(P1,L+1,MAXP)
"RTN","XWBBRK",118,0)
 . . S K=I,I=I+1
"RTN","XWBBRK",119,0)
 . IF 'FL Q
"RTN","XWBBRK",120,0)
 . S P3=P
"RTN","XWBBRK",121,0)
 . S L=+$E(P3,1,5)
"RTN","XWBBRK",122,0)
 . S P1=$E(P3,F+3,L+F)
"RTN","XWBBRK",123,0)
 . ;IF FL=1 S P1=$$CREF^XWBBRK2(A,P1) ;convert array ref to namespace ref
"RTN","XWBBRK",124,0)
 . S P2=$E(P3,L+F+3,M)
"RTN","XWBBRK",125,0)
 . ;instantiate array
"RTN","XWBBRK",126,0)
 . S DUMMY=0
"RTN","XWBBRK",127,0)
 . F  D  Q:+L=0
"RTN","XWBBRK",128,0)
 . . S L=$$BREAD(3) Q:+L=0  S P3=$$BREAD(L)
"RTN","XWBBRK",129,0)
 . . S L=$$BREAD(3) IF +L'=0 S P4=$$BREAD(L)
"RTN","XWBBRK",130,0)
 . . IF +L=0 Q
"RTN","XWBBRK",131,0)
 . . ;E  S L=3,P4=$$BREAD(L) IF P4=0 S P4=""
"RTN","XWBBRK",132,0)
 . . IF P3=0,P4=0 S L=0 Q
"RTN","XWBBRK",133,0)
 . . IF FL=1 D LINST(A,P3,P4)
"RTN","XWBBRK",134,0)
 . . IF FL=2 D GINST
"RTN","XWBBRK",135,0)
 . . S DUMMY=DUMMY+1
"RTN","XWBBRK",136,0)
 IF ERR Q P1
"RTN","XWBBRK",137,0)
 S P1=""
"RTN","XWBBRK",138,0)
 D  Q P1
"RTN","XWBBRK",139,0)
 . F I=0:1:K D
"RTN","XWBBRK",140,0)
 . . IF FL,$E(XWB(R,"P",I),1,1)="." D  Q
"RTN","XWBBRK",141,0)
 . . . S P1=P1_"."_$E(XWB(R,"P",I),2,$L(XWB(R,"P",I)))
"RTN","XWBBRK",142,0)
 . . . IF I'=K S P1=P1_","
"RTN","XWBBRK",143,0)
 . . S P1=P1_"XWB("_R_",""P"","_I_")"
"RTN","XWBBRK",144,0)
 . . IF I'=K S P1=P1_","
"RTN","XWBBRK",145,0)
 IF '+ERR Q P1
"RTN","XWBBRK",146,0)
 Q ERR
"RTN","XWBBRK",147,0)
 ;
"RTN","XWBBRK",148,0)
BREAD(L) ;read tcp buffer, L is length
"RTN","XWBBRK",149,0)
 N E,X,DONE
"RTN","XWBBRK",150,0)
 S (E,DONE)=0
"RTN","XWBBRK",151,0)
 R X#L:XWBTIME
"RTN","XWBBRK",152,0)
 S E=X
"RTN","XWBBRK",153,0)
 IF $L(E)<L F  D  Q:'DONE
"RTN","XWBBRK",154,0)
 . IF $L(E)=L S DONE=1 Q
"RTN","XWBBRK",155,0)
 . R X#(L-$L(E)):XWBTIME
"RTN","XWBBRK",156,0)
 . S E=E_X
"RTN","XWBBRK",157,0)
 Q E
"RTN","XWBBRK",158,0)
 ;
"RTN","XWBBRK",159,0)
CALLP(XWBP,P,DEBUG) ;make API call using Protocol string
"RTN","XWBBRK",160,0)
 N ERR,S
"RTN","XWBBRK",161,0)
 S ERR=0
"RTN","XWBBRK",162,0)
 IF '$D(DEBUG) S DEBUG=0
"RTN","XWBBRK",163,0)
 IF 'DEBUG D:$D(XRTL) T0^%ZOSV ;start RTL
"RTN","XWBBRK",164,0)
 S ERR=$$PRSP^XWBBRK(P)
"RTN","XWBBRK",165,0)
 IF '+ERR S ERR=$$PRSM^XWBBRK(XWB(0,"MESG"))
"RTN","XWBBRK",166,0)
 IF '+ERR S ERR=$$PRSA^XWBBRK(XWB(1,"TEXT"))
"RTN","XWBBRK",167,0)
 IF '+ERR S S=$$PRSB^XWBBRK(XWB(2,"PARM"))
"RTN","XWBBRK",168,0)
 ;IF (+S=0)!(+S>0) D
"RTN","XWBBRK",169,0)
 D CHKPRMIT^XWBSEC(XWB(2,"CAPI")) ;checks if RPC allowed to run
"RTN","XWBBRK",170,0)
 S:$L(XWBSEC) ERR="-1^"_XWBSEC
"RTN","XWBBRK",171,0)
 IF 'DEBUG S:$D(XRT0) XRTN="RPC BROKER READ/PARSE" D:$D(XRT0) T1^%ZOSV ;stop RTL
"RTN","XWBBRK",172,0)
 IF '+ERR,(+S=0)!(+S>0) D
"RTN","XWBBRK",173,0)
 . D CAPI^XWBBRK2(.XWBP,XWB(2,"RTAG"),XWB(2,"RNAM"),S)
"RTN","XWBBRK",174,0)
 IF 'DEBUG K XWB
"RTN","XWBBRK",175,0)
 IF $D(XWBARY) K @XWBARY,XWBARY
"RTN","XWBBRK",176,0)
 Q
"RTN","XWBBRK",177,0)
 ;
"RTN","XWBBRK",178,0)
LINST(A,X,XWBY) ;instantiate local array
"RTN","XWBBRK",179,0)
 IF XWBY=$C(1) S XWBY=""
"RTN","XWBBRK",180,0)
 S X=A_"("_X_")"
"RTN","XWBBRK",181,0)
 S @X=XWBY
"RTN","XWBBRK",182,0)
 Q
"RTN","XWBBRK",183,0)
GINST ;instantiate global
"RTN","XWBBRK",184,0)
 N DONE,N,T,T1
"RTN","XWBBRK",185,0)
 S (DONE,I)=0
"RTN","XWBBRK",186,0)
 ;find piece with global ref - recover $C(44)
"RTN","XWBBRK",187,0)
 S REF=$TR(REF,$C(23),$C(44))
"RTN","XWBBRK",188,0)
 F  D  Q:DONE
"RTN","XWBBRK",189,0)
 . S N=$NA(^TMP("XWB",$J,$P($H,",",2)))
"RTN","XWBBRK",190,0)
 . S XWB("FRM")=REF
"RTN","XWBBRK",191,0)
 . S XWB("TO")=N
"RTN","XWBBRK",192,0)
 . IF '$D(@N) S DONE=1 Q
"RTN","XWBBRK",193,0)
 ;loop through all and instantiate
"RTN","XWBBRK",194,0)
 S DONE=0
"RTN","XWBBRK",195,0)
 F  D  Q:DONE
"RTN","XWBBRK",196,0)
 . S T=$E(@REF@(I),4,M)
"RTN","XWBBRK",197,0)
 . IF T="" S DONE=1 Q
"RTN","XWBBRK",198,0)
 . S @N@("XWB")="" ;set naked indicator
"RTN","XWBBRK",199,0)
 . S @T
"RTN","XWBBRK",200,0)
 . S I=I+1
"RTN","XWBBRK",201,0)
 K @N@("XWB")
"RTN","XWBBRK",202,0)
 Q
"RTN","XWBBRK",203,0)
 ;
"RTN","XWBBRK",204,0)
GETV(V) ;get value of V - reference parameter
"RTN","XWBBRK",205,0)
 N X
"RTN","XWBBRK",206,0)
 S X=V
"RTN","XWBBRK",207,0)
 IF $E(X,1,2)="$$" Q ""
"RTN","XWBBRK",208,0)
 IF $C(34,36)[$E(V) X "S V="_V
"RTN","XWBBRK",209,0)
 E  S V=@V
"RTN","XWBBRK",210,0)
 Q V
"RTN","XWBBRK2")
0^2^B17592735
"RTN","XWBBRK2",1,0)
XWBBRK2 ;ISC-SF/EG - DHCP BROKER PROTOYPE ;08/23/96  13:31
"RTN","XWBBRK2",2,0)
 ;;1.0;RPC BROKER;**1**;May 24, 1996
"RTN","XWBBRK2",3,0)
CAPI(XWBY,TAG,NAM,PAR) ;make API call
"RTN","XWBBRK2",4,0)
 N R,T,DX,DY
"RTN","XWBBRK2",5,0)
 IF XWB(1,"FLAG")=2 D
"RTN","XWBBRK2",6,0)
 . S PAR=$P(PAR,XWB("FRM"))_XWB("TO")_$P(PAR,XWB("FRM"),2)
"RTN","XWBBRK2",7,0)
 S R=$S(PAR'=+PAR&(PAR=""):TAG_"^"_NAM_"(.XWBY)",1:TAG_"^"_NAM_"(.XWBY,"_PAR_")")
"RTN","XWBBRK2",8,0)
 D:$D(XRTL) T0^%ZOSV ;start RTL
"RTN","XWBBRK2",9,0)
 U XWBNULL
"RTN","XWBBRK2",10,0)
 D @R
"RTN","XWBBRK2",11,0)
 S:$D(XRT0) XRTN=XWB(2,"NAME") D:$D(XRT0) T1^%ZOSV ;stop RTL
"RTN","XWBBRK2",12,0)
 ;once call is completed, write buffer should be empty, make it so!
"RTN","XWBBRK2",13,0)
 S DX=0,DY=0 X ^%ZOSF("XY")
"RTN","XWBBRK2",14,0)
 U XWBTDEV
"RTN","XWBBRK2",15,0)
 Q
"RTN","XWBBRK2",16,0)
 ;
"RTN","XWBBRK2",17,0)
BHDR(WKID,WINH,PRCH,WISH) ;Build a protocol header
"RTN","XWBBRK2",18,0)
 N S,L
"RTN","XWBBRK2",19,0)
 S S=""
"RTN","XWBBRK2",20,0)
 S S=WKID_";"_WINH_";"_PRCH_";"_WISH_";"
"RTN","XWBBRK2",21,0)
 S L=$L(S)
"RTN","XWBBRK2",22,0)
 S S=$E("000"_L,$L(L)+1,$L(L)+3)_S
"RTN","XWBBRK2",23,0)
 Q S
"RTN","XWBBRK2",24,0)
 ;
"RTN","XWBBRK2",25,0)
BARY(A,R,V) ;add array elements+values to storage array
"RTN","XWBBRK2",26,0)
 IF A'["XWBS" Q "-1^ARRAY NAME MUST BE XWBS"
"RTN","XWBBRK2",27,0)
 S @A@(R)=V
"RTN","XWBBRK2",28,0)
 Q 0
"RTN","XWBBRK2",29,0)
 ;
"RTN","XWBBRK2",30,0)
BLDB(P) ;Build formatted string
"RTN","XWBBRK2",31,0)
 N L
"RTN","XWBBRK2",32,0)
 S L=$L(P)
"RTN","XWBBRK2",33,0)
 Q $E("000"_L,$L(L)+1,$L(L)+3)_P
"RTN","XWBBRK2",34,0)
 ;
"RTN","XWBBRK2",35,0)
BLDA(N,P) ;Build API string
"RTN","XWBBRK2",36,0)
 ;M Extrinsic Function
"RTN","XWBBRK2",37,0)
 ;Inputs
"RTN","XWBBRK2",38,0)
 ;N        API name
"RTN","XWBBRK2",39,0)
 ;P        Comma delimited parameter string
"RTN","XWBBRK2",40,0)
 ;Outputs
"RTN","XWBBRK2",41,0)
 ;String   API string if successful, "-1^Text" if error
"RTN","XWBBRK2",42,0)
 ;
"RTN","XWBBRK2",43,0)
 N I,F,L,T,U,T1,T2
"RTN","XWBBRK2",44,0)
 IF '+$D(N) Q "-1^Required input reference is NULL"
"RTN","XWBBRK2",45,0)
 S U="^"
"RTN","XWBBRK2",46,0)
 S (F,T,Y)=0
"RTN","XWBBRK2",47,0)
 IF '$D(P) S P=""
"RTN","XWBBRK2",48,0)
 IF P'="" D
"RTN","XWBBRK2",49,0)
 . S L=$L(P)-$L($TR(P,$C(44)))+1
"RTN","XWBBRK2",50,0)
 . IF L=0 S L=1
"RTN","XWBBRK2",51,0)
 . F I=1:1:L D  Q:T
"RTN","XWBBRK2",52,0)
 . . S T1=$P(P,",",I)
"RTN","XWBBRK2",53,0)
 . . S T2=$E(T1,1,1)="."
"RTN","XWBBRK2",54,0)
 . . IF T1=+T1 Q
"RTN","XWBBRK2",55,0)
 . . IF $E(T1,1,1)="^" S F=2,T=1 Q
"RTN","XWBBRK2",56,0)
 . . ;IF $E(T1,1,5)="$NA(^" S F=2,T=1 Q
"RTN","XWBBRK2",57,0)
 . . IF T2&($E(T1,2,$L(T1))?.ANP) S F=1,T=1 Q
"RTN","XWBBRK2",58,0)
 ;IF P?.ANP1"."1A.ANP S F=1
"RTN","XWBBRK2",59,0)
 S P=$$BLDB(P)
"RTN","XWBBRK2",60,0)
 S L=$L(P)+$L(P)-3
"RTN","XWBBRK2",61,0)
 S P=F_N_U_P
"RTN","XWBBRK2",62,0)
 S L=$L(P)
"RTN","XWBBRK2",63,0)
 Q $E("000"_L,$L(L)+1,$L(L)+3)_P
"RTN","XWBBRK2",64,0)
 ;
"RTN","XWBBRK2",65,0)
BLDS(R) ;Build a parameter string from an array
"RTN","XWBBRK2",66,0)
 N L,T,Y
"RTN","XWBBRK2",67,0)
 S Y=""
"RTN","XWBBRK2",68,0)
 F  D  Q:R=""
"RTN","XWBBRK2",69,0)
 . S R=$Q(@R)
"RTN","XWBBRK2",70,0)
 . IF R="" Q
"RTN","XWBBRK2",71,0)
 . S L=$L(R)+$L(@R)+1
"RTN","XWBBRK2",72,0)
 . S T=@R
"RTN","XWBBRK2",73,0)
 . S T=$TR(T,$C(44),$C(23))
"RTN","XWBBRK2",74,0)
 . S Y=Y_$E("000"_L,$L(L)+1,$L(L)+3)_R_"="_T
"RTN","XWBBRK2",75,0)
 Q Y_"000"
"RTN","XWBBRK2",76,0)
 ;
"RTN","XWBBRK2",77,0)
BLDU(R) ;Build a parameter string from a scalar
"RTN","XWBBRK2",78,0)
 N DONE,L,N,N1,P1
"RTN","XWBBRK2",79,0)
 IF R=+R Q R
"RTN","XWBBRK2",80,0)
 S N=$F(R,$C(34))
"RTN","XWBBRK2",81,0)
 IF N=0 Q $C(34)_R_$C(34)
"RTN","XWBBRK2",82,0)
 S P1=$E(R,1,N-2)
"RTN","XWBBRK2",83,0)
 S (L,DONE)=0
"RTN","XWBBRK2",84,0)
 F  D  Q:DONE
"RTN","XWBBRK2",85,0)
 . S N1=$F(R,$C(34),N)
"RTN","XWBBRK2",86,0)
 . IF N1=0 S L=$L(R)+2,N1=L
"RTN","XWBBRK2",87,0)
 . S P1=P1_$C(34,34)_$E(R,N,N1-2)
"RTN","XWBBRK2",88,0)
 . IF N1=L S DONE=1,P1=$C(34)_P1_$C(34) Q
"RTN","XWBBRK2",89,0)
 . S N=N1
"RTN","XWBBRK2",90,0)
 Q $TR(P1,$C(44),$C(23))
"RTN","XWBBRK2",91,0)
 ;
"RTN","XWBBRK2",92,0)
BLDG(R) ;build a parameter string from a global reference
"RTN","XWBBRK2",93,0)
 N I,L,L1,M,T,T1,T2,Y
"RTN","XWBBRK2",94,0)
 K ^TMP("XWB",$J)
"RTN","XWBBRK2",95,0)
 IF '$D(R) Q "-1^Reference does not exist"
"RTN","XWBBRK2",96,0)
 S Y=$NA(^TMP("XWB",$J,$P($H,",",2)))
"RTN","XWBBRK2",97,0)
 S I=0
"RTN","XWBBRK2",98,0)
 S M=512
"RTN","XWBBRK2",99,0)
 S T1=$P(R,")")
"RTN","XWBBRK2",100,0)
 S L1=$L($P(R,"("))
"RTN","XWBBRK2",101,0)
 F  D  Q:R=""
"RTN","XWBBRK2",102,0)
 . S R=$Q(@R)
"RTN","XWBBRK2",103,0)
 . S T2=$F(R,"(")
"RTN","XWBBRK2",104,0)
 . IF R=""!(R'[T1) Q
"RTN","XWBBRK2",105,0)
 . S L=$L(R)+$L(@R)-L1
"RTN","XWBBRK2",106,0)
 . S T=@R
"RTN","XWBBRK2",107,0)
 . S T=$TR(T,$C(44),$C(23))
"RTN","XWBBRK2",108,0)
 . S @Y@(I)=$E("000"_L,$L(L)+1,$L(L)+3)_"^("_$E(R,T2,M)_"="_$$BLDU(T)
"RTN","XWBBRK2",109,0)
 . S I=I+1
"RTN","XWBBRK2",110,0)
 S @Y@(I)="000"
"RTN","XWBBRK2",111,0)
 S Y=$TR(Y,$C(44),$C(23))
"RTN","XWBBRK2",112,0)
 Q Y
"RTN","XWBBRK2",113,0)
 ;
"RTN","XWBBRK2",114,0)
OARY() ;create storage array
"RTN","XWBBRK2",115,0)
 N A,DONE,I
"RTN","XWBBRK2",116,0)
 S (DONE,I)=0
"RTN","XWBBRK2",117,0)
 F I=1:1 D  Q:DONE
"RTN","XWBBRK2",118,0)
 . S A="XWBS"_I
"RTN","XWBBRK2",119,0)
 . IF '$D(@A) S DONE=1
"RTN","XWBBRK2",120,0)
 ;S Y("XWBS")=A
"RTN","XWBBRK2",121,0)
 S @A="" ;set naked
"RTN","XWBBRK2",122,0)
 Q A
"RTN","XWBBRK2",123,0)
 ;
"RTN","XWBBRK2",124,0)
CREF(R,P) ;Convert array contained in P to reference A
"RTN","XWBBRK2",125,0)
 N I,X,DONE,F1,S
"RTN","XWBBRK2",126,0)
 S DONE=0
"RTN","XWBBRK2",127,0)
 S S=""
"RTN","XWBBRK2",128,0)
 F I=1:1  D  Q:DONE
"RTN","XWBBRK2",129,0)
 . IF $P(P,",",I)="" S DONE=1 Q
"RTN","XWBBRK2",130,0)
 . S X(I)=$P(P,",",I)
"RTN","XWBBRK2",131,0)
 . IF X(I)?1"."1A.E D
"RTN","XWBBRK2",132,0)
 . . S F1=$F(X(I),".")
"RTN","XWBBRK2",133,0)
 . . S X(I)="."_R
"RTN","XWBBRK2",134,0)
 . S S=S_X(I)_","
"RTN","XWBBRK2",135,0)
 Q $E(S,1,$L(S)-1)
"RTN","XWBBRK2",136,0)
 ;
"RTN","XWBBRK2",137,0)
GETP(P) ;returns various parameters out of the Protocol string
"RTN","XWBBRK2",138,0)
 N M,T,XWB
"RTN","XWBBRK2",139,0)
 S M=512
"RTN","XWBBRK2",140,0)
 S T=$$PRSP^XWBBRK(P)
"RTN","XWBBRK2",141,0)
 IF '+T D
"RTN","XWBBRK2",142,0)
 . S T=$$PRSM^XWBBRK(XWB(0,"MESG"))
"RTN","XWBBRK2",143,0)
 . IF '+T S T=XWB(0,"WKID")_";"_XWB(0,"WINH")_";"_XWB(0,"PRCH")_";"_XWB(0,"WISH")_";"_$P(XWB(1,"TEXT"),"^")
"RTN","XWBBRK2",144,0)
 Q T
"RTN","XWBBRK2",145,0)
 ;
"RTN","XWBBRK2",146,0)
CALLM(X,P,DEBUG) ;make call using Message string
"RTN","XWBBRK2",147,0)
 N ERR,S
"RTN","XWBBRK2",148,0)
 S X="",ERR=0
"RTN","XWBBRK2",149,0)
 S ERR=$$PRSM^XWBBRK(P)
"RTN","XWBBRK2",150,0)
 IF '+ERR S ERR=$$PRSA^XWBBRK(XWB(1,"TEXT"))
"RTN","XWBBRK2",151,0)
 IF '+ERR S S=$$PRSB^XWBBRK(XWB(2,"PARM"))
"RTN","XWBBRK2",152,0)
 IF (+S=0)!(+S>0) D
"RTN","XWBBRK2",153,0)
 . D CAPI(.X,XWB(2,"RTAG"),XWB(2,"RNAM"),S)
"RTN","XWBBRK2",154,0)
 IF 'DEBUG K XWB
"RTN","XWBBRK2",155,0)
 K @(X("XWBS")),X("XWBS")
"RTN","XWBBRK2",156,0)
 Q
"RTN","XWBBRK2",157,0)
 ;
"RTN","XWBBRK2",158,0)
CALLA(X,P,DEBUG) ;make call using API string
"RTN","XWBBRK2",159,0)
 N ERR,S
"RTN","XWBBRK2",160,0)
 S X="",ERR=0
"RTN","XWBBRK2",161,0)
 S ERR=$$PRSA^XWBBRK(P)
"RTN","XWBBRK2",162,0)
 IF '+ERR S S=$$PRSB^XWBBRK(XWB(2,"PARM"))
"RTN","XWBBRK2",163,0)
 IF (+S=0)!(+S>0) D
"RTN","XWBBRK2",164,0)
 . D CAPI(.X,XWB(2,"RTAG"),XWB(2,"RNAM"),S)
"RTN","XWBBRK2",165,0)
 IF 'DEBUG K XWB
"RTN","XWBBRK2",166,0)
 K @(X("XWBS")),X("XWBS")
"RTN","XWBBRK2",167,0)
 Q
"RTN","XWBBRK2",168,0)
 ;
"RTN","XWBBRK2",169,0)
TRANSPRT() ;Determine the Transport Method
"RTN","XWBBRK2",170,0)
 ;DDP is local :=0
"RTN","XWBBRK2",171,0)
 ;TCP/IP is remote :=1
"RTN","XWBBRK2",172,0)
 ;Serial/RS-232 is remote :=2
"RTN","XWBBRK2",173,0)
 Q 1
"RTN","XWBBRK2",174,0)
 ;Q 0 ;Do DDP for Now
"RTN","XWBTCP")
0^3^B9311723
"RTN","XWBTCP",1,0)
XWBTCP ;ISC-SF/EG - Control TCP listener ;08/23/96  13:30
"RTN","XWBTCP",2,0)
 ;;1.0;RPC BROKER;**1**;May 24, 1996
"RTN","XWBTCP",3,0)
 ;
"RTN","XWBTCP",4,0)
EN ; -- entry point for interactive use
"RTN","XWBTCP",5,0)
 N X1,X2,XWBTDBG,XWBIP
"RTN","XWBTCP",6,0)
 S XWBIP=""
"RTN","XWBTCP",7,0)
 IF ^%ZOSF("OS")["DSM" S XWBIP=$P($ZIO," ",2)
"RTN","XWBTCP",8,0)
 W !,"Enter client address: "_XWBIP_"//" R X1:300 Q:'$T  Q:X1="^"
"RTN","XWBTCP",9,0)
 W !,"   Enter client port: " R X2:300 Q:'$T  Q:X2="^"
"RTN","XWBTCP",10,0)
 W ! S XWBTDBG=""
"RTN","XWBTCP",11,0)
 IF X1="" S X1=XWBIP
"RTN","XWBTCP",12,0)
 IF X1'="" D EN^XWBTCPC(X1,X2,"")
"RTN","XWBTCP",13,0)
 Q
"RTN","XWBTCP",14,0)
 ;
"RTN","XWBTCP",15,0)
STRT(XWBTSKT) W "Start TCP Listener...",!
"RTN","XWBTCP",16,0)
 ;
"RTN","XWBTCP",17,0)
 N IP,REF,Y,%
"RTN","XWBTCP",18,0)
 X ^%ZOSF("UCI") S REF=Y
"RTN","XWBTCP",19,0)
 S IP="0.0.0.0" ;get server IP at some point
"RTN","XWBTCP",20,0)
 IF $G(XWBTSKT)="" S XWBTSKT=9000 ;default service port is 9000
"RTN","XWBTCP",21,0)
 ;
"RTN","XWBTCP",22,0)
 ; -- see if 'running flag' for listener is set
"RTN","XWBTCP",23,0)
 L +^XWB(IP,REF,XWBTSKT,"RUNNING"):1
"RTN","XWBTCP",24,0)
 I '$T W "TCP Listener on port "_XWBTSKT_" appears to be running already." Q
"RTN","XWBTCP",25,0)
 L -^XWB(IP,REF,XWBTSKT,"RUNNING")
"RTN","XWBTCP",26,0)
 ;
"RTN","XWBTCP",27,0)
 ; -- set stop flag to false and start the listener
"RTN","XWBTCP",28,0)
 S ^XWB(IP,REF,XWBTSKT,"STOP")=""
"RTN","XWBTCP",29,0)
 S ^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")=""  ;record problem marker
"RTN","XWBTCP",30,0)
 J EN^XWBTCPL(XWBTSKT)::5
"RTN","XWBTCP",31,0)
 I '$T W "Unable to run TCP Listener in background.",! Q
"RTN","XWBTCP",32,0)
 F %=1:1:5 D  Q:%=0
"RTN","XWBTCP",33,0)
 . W "Checking if TCP Listener has started...",!
"RTN","XWBTCP",34,0)
 . H 3
"RTN","XWBTCP",35,0)
 . L +^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")
"RTN","XWBTCP",36,0)
 . S:'$D(^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")) %=0
"RTN","XWBTCP",37,0)
 . L -^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")
"RTN","XWBTCP",38,0)
 I $D(^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")) D
"RTN","XWBTCP",39,0)
 . W !,"TCP Listener could not be started!",!
"RTN","XWBTCP",40,0)
 . W "Check if port "_XWBTSKT_" is busy on this CPU.",!
"RTN","XWBTCP",41,0)
 . K ^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")   ;clear marker
"RTN","XWBTCP",42,0)
 E  W "TCP Listener started successfully."
"RTN","XWBTCP",43,0)
 Q
"RTN","XWBTCP",44,0)
 ;
"RTN","XWBTCP",45,0)
STOP(XWBTSKT) W "Stop TCP Listener...",!
"RTN","XWBTCP",46,0)
 N IP,REF,X,DEV,XWBOS  ;**1**
"RTN","XWBTCP",47,0)
 X ^%ZOSF("UCI") S REF=Y
"RTN","XWBTCP",48,0)
 S IP="0.0.0.0" ;get server IP
"RTN","XWBTCP",49,0)
 IF $G(XWBTSKT)="" S XWBTSKT=9000 ;default service port is 9000
"RTN","XWBTCP",50,0)
 ;
"RTN","XWBTCP",51,0)
 S XWBOS=$S(^%ZOSF("OS")["DSM":"DSM",^("OS")["MSM":"MSM",1:"")
"RTN","XWBTCP",52,0)
 ;
"RTN","XWBTCP",53,0)
 ; -- make sure the listener is running
"RTN","XWBTCP",54,0)
 L +^XWB(IP,REF,XWBTSKT,"RUNNING"):1
"RTN","XWBTCP",55,0)
 I $T D  Q
"RTN","XWBTCP",56,0)
 . L -^XWB(IP,REF,XWBTSKT,"RUNNING")
"RTN","XWBTCP",57,0)
 . W "TCP Listener does not appear to be running.",!
"RTN","XWBTCP",58,0)
 ;
"RTN","XWBTCP",59,0)
 ; -- set the stop flag
"RTN","XWBTCP",60,0)
 S ^XWB(IP,REF,XWBTSKT,"STOP")=1
"RTN","XWBTCP",61,0)
 ;
"RTN","XWBTCP",62,0)
 ; -- send the shutdown message to the TCP Listener process
"RTN","XWBTCP",63,0)
 ;    using loopback address
"RTN","XWBTCP",64,0)
 ; -- connect to 127.0.0.1 for DSM
"RTN","XWBTCP",65,0)
 I XWBOS="DSM" O XWBTSKT:(TCPCHAN:ADDRESS="127.0.0.1") U XWBTSKT S DEV=XWBTSKT
"RTN","XWBTCP",66,0)
 ; -- connect to 127.0.0.1 for MSM
"RTN","XWBTCP",67,0)
 I XWBOS="MSM" O 56 U 56::"TCP" W /SOCKET("localhost",XWBTSKT) S DEV=56
"RTN","XWBTCP",68,0)
 ;
"RTN","XWBTCP",69,0)
 S X=$C($L("XWB_1.1"))_"XWB_1.1"
"RTN","XWBTCP",70,0)
 W "{XWB}|"_X_"00011TCPshutdown",!  ;**1**
"RTN","XWBTCP",71,0)
 ;W "{XWB}00011TCPshutdown",!
"RTN","XWBTCP",72,0)
 R X#3:5
"RTN","XWBTCP",73,0)
 C DEV
"RTN","XWBTCP",74,0)
 W "TCP Listener Response to Shutdown Request: ",X,!  ;**1**
"RTN","XWBTCP",75,0)
 IF X="ack" W "TCP Listener has been shutdown.",!  ;**1**
"RTN","XWBTCP",76,0)
 ELSE  W "Shutdown Failed!",!  ;**1**
"RTN","XWBTCP",77,0)
 Q
"RTN","XWBTCPC")
0^4^B31673061
"RTN","XWBTCPC",1,0)
XWBTCPC ;ISC-SF/EG - TCP/IP PROCESS HANDLER ;08/23/96  15:02
"RTN","XWBTCPC",2,0)
 ;;1.0;RPC BROKER;**1**;May 24, 1996
"RTN","XWBTCPC",3,0)
 ;Based on:
"RTN","XWBTCPC",4,0)
 ;XQORTCPH ;SLC/KCM - Service TCP Messages [ 12/04/94  9:06 PM ]
"RTN","XWBTCPC",5,0)
 ;Modified by ISC-SF/EG
"RTN","XWBTCPC",6,0)
 ; 0. No longer supports old style OERR messages
"RTN","XWBTCPC",7,0)
 ; 1. Makes call to RPC  broker
"RTN","XWBTCPC",8,0)
 ; 2. Handles MSM Server under Windows NT
"RTN","XWBTCPC",9,0)
 ; 3. Handles MSM under Unix - same as DSM
"RTN","XWBTCPC",10,0)
 ; 4. Result of an rpc call can be a closed form of global
"RTN","XWBTCPC",11,0)
 ; 5. Can receive a large local array, within limits of job
"RTN","XWBTCPC",12,0)
 ;    partition size.
"RTN","XWBTCPC",13,0)
 ; 6. Sets default device to NULL device prior to call, restores
"RTN","XWBTCPC",14,0)
 ;    at termination.  Prevents garbage from 'talking' calls.
"RTN","XWBTCPC",15,0)
 ; 7. All reads have a timeout.
"RTN","XWBTCPC",16,0)
 ; 8. Intro message is sent when first connected.
"RTN","XWBTCPC",17,0)
 ; 9. Uses callback model to connect to client
"RTN","XWBTCPC",18,0)
 ;
"RTN","XWBTCPC",19,0)
EN(XWBTIP,XWBTSKT,DUZ,XWBVER) ; -- Main entry point
"RTN","XWBTCPC",20,0)
 N TYPE,XWBTBUF,XWBTBUF1,XWBTDEV,XWBTLEN,XWBTOS,XWBTRTN,XWBWRAP
"RTN","XWBTCPC",21,0)
 N X,XWBL,XWB1,XWB2,Y,XWBTIME,XWBPTYPE,XWBPLEN,XWBNULL,XWBODEV
"RTN","XWBTCPC",22,0)
 N XWBERROR,XWBSEC ;new error variable available to rpc calls
"RTN","XWBTCPC",23,0)
 N XRTL,IO,IOP
"RTN","XWBTCPC",24,0)
 ;
"RTN","XWBTCPC",25,0)
 S XWBOS=$S(^%ZOSF("OS")["DSM":"DSM",^("OS")["UNIX":"UNIX",1:"MSM")
"RTN","XWBTCPC",26,0)
 IF '$D(XWBVER) S XWBVER=1
"RTN","XWBTCPC",27,0)
 IF $$NEWERR^%ZTER S $ETRAP="S %ZTER11S=$STACK D ^%ZTER H"
"RTN","XWBTCPC",28,0)
 E  S X="^%ZTER",@^%ZOSF("TRAP")
"RTN","XWBTCPC",29,0)
 K XRTL IF XWBOS="DSM" S XRTL=1 ;log response time data for DSM
"RTN","XWBTCPC",30,0)
 S XWBTIME=1
"RTN","XWBTCPC",31,0)
 IF XWBOS="DSM" D
"RTN","XWBTCPC",32,0)
 . ;IF '$D(%)#2 S %=$P($ZIO,":")_":" ; Call with dsm$xecute()
"RTN","XWBTCPC",33,0)
 . ;S %=+$P($ZIO,"Port: ",2)_":"
"RTN","XWBTCPC",34,0)
 . ;S (XWBTDEV,IO,IO(0))=%,X=$E(%_"WKSTA",1,15)
"RTN","XWBTCPC",35,0)
 . ;;D SETENV^%ZOSV
"RTN","XWBTCPC",36,0)
 . O XWBTSKT:(TCPCHAN:ADDRESS=XWBTIP:SHARE)
"RTN","XWBTCPC",37,0)
 . U XWBTSKT X ^%ZOSF("TRMOFF")
"RTN","XWBTCPC",38,0)
 . S XWBTDEV=XWBTSKT
"RTN","XWBTCPC",39,0)
 ;
"RTN","XWBTCPC",40,0)
 IF XWBOS="MSM"!(XWBOS="UNIX") D
"RTN","XWBTCPC",41,0)
 . O 56 U 56::"TCP"
"RTN","XWBTCPC",42,0)
 . W /SOCKET(XWBTIP,XWBTSKT)
"RTN","XWBTCPC",43,0)
 . ;S (XWBTDEV,IO,IO(0))=56
"RTN","XWBTCPC",44,0)
 . S XWBTDEV=56
"RTN","XWBTCPC",45,0)
 ;
"RTN","XWBTCPC",46,0)
 ;setup null device "NULL"
"RTN","XWBTCPC",47,0)
 S XWBNULL=$S(XWBOS="DSM":"NLA0:",1:"")
"RTN","XWBTCPC",48,0)
 IF XWBOS="DSM" O XWBNULL
"RTN","XWBTCPC",49,0)
 ELSE  D
"RTN","XWBTCPC",50,0)
 . S (IO,IO(0))=XWBTDEV
"RTN","XWBTCPC",51,0)
 . S IOP="NULL" D ^%ZIS S XWBNULL=IO
"RTN","XWBTCPC",52,0)
 ;
"RTN","XWBTCPC",53,0)
 ;change process name
"RTN","XWBTCPC",54,0)
 D CHPRN("ip"_$P(XWBTIP,".",3,4)_":"_XWBTSKT)
"RTN","XWBTCPC",55,0)
RESTART IF $$NEWERR^%ZTER N $ESTACK S $ETRAP="S %ZTER11S=$STACK D ETRAP^XWBTCPC"
"RTN","XWBTCPC",56,0)
 E  S X="ETRAP^XWBTCPC",@^%ZOSF("TRAP")
"RTN","XWBTCPC",57,0)
 S DIQUIET=1,U="^" D DT^DICRW
"RTN","XWBTCPC",58,0)
 U XWBTDEV D MAIN
"RTN","XWBTCPC",59,0)
 IF $$NEWERR^%ZTER S $ETRAP=""
"RTN","XWBTCPC",60,0)
 E  S X="",@^%ZOSF("TRAP")
"RTN","XWBTCPC",61,0)
 I $G(DUZ) D LOGOUT^XUSRB
"RTN","XWBTCPC",62,0)
 K XWBR,XWBARY
"RTN","XWBTCPC",63,0)
 C XWBTDEV
"RTN","XWBTCPC",64,0)
 IF XWBOS="DSM" C XWBNULL
"RTN","XWBTCPC",65,0)
 ELSE  D ^%ZISC
"RTN","XWBTCPC",66,0)
 Q
"RTN","XWBTCPC",67,0)
 ;
"RTN","XWBTCPC",68,0)
MAIN ; -- main message processing loop
"RTN","XWBTCPC",69,0)
 F  D  Q:XWBTBUF="#BYE#"
"RTN","XWBTCPC",70,0)
 . ; -- read client request
"RTN","XWBTCPC",71,0)
 . R XWBTBUF#15:36000 IF '$T S XWBTBUF="#BYE#" D SNDERR W XWBTBUF,$C(4),! Q
"RTN","XWBTCPC",72,0)
 . S TYPE=$S($E(XWBTBUF,1,5)="{XWB}":1,1:0)
"RTN","XWBTCPC",73,0)
 . I 'TYPE S XWBTBUF="#BYE#" Q
"RTN","XWBTCPC",74,0)
 . S XWBTLEN=$E(XWBTBUF,6,10)
"RTN","XWBTCPC",75,0)
 . S XWBPLEN=$E(XWBTBUF,11,15)
"RTN","XWBTCPC",76,0)
 . R XWBTBUF#XWBPLEN:XWBTIME
"RTN","XWBTCPC",77,0)
 . I $P(XWBTBUF,U)="TCPconnect" D  Q
"RTN","XWBTCPC",78,0)
 . . D SNDERR W "accept",$C(4),!  ;Ack
"RTN","XWBTCPC",79,0)
 . IF TYPE D
"RTN","XWBTCPC",80,0)
 . . K XWBR,XWBARY
"RTN","XWBTCPC",81,0)
 . . IF XWBTBUF="#BYE#" D SNDERR W "#BYE#",$C(4),! Q  ; -- clean disconnect
"RTN","XWBTCPC",82,0)
 . . S XWBTLEN=XWBTLEN-15
"RTN","XWBTCPC",83,0)
 . . D CALLP^XWBBRK(.XWBR,XWBTBUF)
"RTN","XWBTCPC",84,0)
 . . S XWBPTYPE=$S('$D(XWBPTYPE):1,XWBPTYPE<1:1,XWBPTYPE>6:1,1:XWBPTYPE)
"RTN","XWBTCPC",85,0)
 . IF XWBTBUF="#BYE#" Q
"RTN","XWBTCPC",86,0)
 . U XWBTDEV
"RTN","XWBTCPC",87,0)
 . D SNDERR
"RTN","XWBTCPC",88,0)
 . D:$D(XRTL) T0^%ZOSV ;start RTL
"RTN","XWBTCPC",89,0)
 . IF XWBOS="DSM"!(XWBOS="UNIX") D SNDDSM
"RTN","XWBTCPC",90,0)
 . IF XWBOS="MSM" D SND
"RTN","XWBTCPC",91,0)
 . S XWBSEC=""
"RTN","XWBTCPC",92,0)
 . W $C(4),! ;send eot and flush buffer
"RTN","XWBTCPC",93,0)
 . S:$D(XRT0) XRTN="RPC BROKER WRITE" D:$D(XRT0) T1^%ZOSV ;stop RTL
"RTN","XWBTCPC",94,0)
 Q  ;End Of Main
"RTN","XWBTCPC",95,0)
 ;
"RTN","XWBTCPC",96,0)
SNDERR ;send error information
"RTN","XWBTCPC",97,0)
 ;XWBSEC is the security packet, XWBERROR is application packet
"RTN","XWBTCPC",98,0)
 N X
"RTN","XWBTCPC",99,0)
 S X=$G(XWBSEC)
"RTN","XWBTCPC",100,0)
 W $C($L(X))_X W:($X+$L(X)+1)>512 !
"RTN","XWBTCPC",101,0)
 S X=$G(XWBERROR)
"RTN","XWBTCPC",102,0)
 W $C($L(X))_X W:($X+$L(X)+1)>512 !
"RTN","XWBTCPC",103,0)
 S XWBERROR="" ;clears parameters
"RTN","XWBTCPC",104,0)
 Q
"RTN","XWBTCPC",105,0)
 ;
"RTN","XWBTCPC",106,0)
SND ; -- Send data (all except DSM)
"RTN","XWBTCPC",107,0)
 N I,T
"RTN","XWBTCPC",108,0)
 ;
"RTN","XWBTCPC",109,0)
 ; -- error or abort occurred, send null
"RTN","XWBTCPC",110,0)
 IF $L(XWBSEC)>0 W "" Q
"RTN","XWBTCPC",111,0)
 ; -- RPC returned closed root of array, process it as global array
"RTN","XWBTCPC",112,0)
 IF XWBPTYPE=2,$D(XWBR)#2,$D(@XWBR)>1 S XWBPTYPE=4,XWBWRAP=1
"RTN","XWBTCPC",113,0)
 ; -- single value
"RTN","XWBTCPC",114,0)
 IF XWBPTYPE=1 S XWBR=$G(XWBR) W XWBR Q
"RTN","XWBTCPC",115,0)
 ; -- table delimited by CR+LF
"RTN","XWBTCPC",116,0)
 IF XWBPTYPE=2 D  Q
"RTN","XWBTCPC",117,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  W XWBR(I),$C(13,10)
"RTN","XWBTCPC",118,0)
 ; -- word processing
"RTN","XWBTCPC",119,0)
 IF XWBPTYPE=3 D  Q
"RTN","XWBTCPC",120,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  W XWBR(I) W:XWBWRAP $C(13,10)
"RTN","XWBTCPC",121,0)
 ; -- global array
"RTN","XWBTCPC",122,0)
 IF XWBPTYPE=4 D  Q
"RTN","XWBTCPC",123,0)
 . S I=XWBR,T=$E(I,1,$L(I)-1) W:$D(@I)>10 @I F  S I=$Q(@I) Q:I=""!(I'[T)  W @I W:XWBWRAP $C(13,10)
"RTN","XWBTCPC",124,0)
 ; -- global instance
"RTN","XWBTCPC",125,0)
 IF XWBPTYPE=5 S XWBR=$G(@XWBR) W XWBR Q
"RTN","XWBTCPC",126,0)
 ; -- variable length records
"RTN","XWBTCPC",127,0)
 IF XWBPTYPE=6 S I="" F  S I=$O(XWBR(I)) Q:I=""  W $C($L(XWBR(I))),XWBR(I)
"RTN","XWBTCPC",128,0)
 Q
"RTN","XWBTCPC",129,0)
SNDDSM ; -- send data for DSM (requires buffer flush (!) every 509 chars)
"RTN","XWBTCPC",130,0)
 N I,T
"RTN","XWBTCPC",131,0)
 ;
"RTN","XWBTCPC",132,0)
 ; -- error or abort occurred, send null
"RTN","XWBTCPC",133,0)
 IF $L(XWBSEC)>0 W "" Q
"RTN","XWBTCPC",134,0)
 ; -- RPC returned closed root of array, process it as global array
"RTN","XWBTCPC",135,0)
 IF XWBPTYPE=2,$D(XWBR)#2,$D(@XWBR)>1 S XWBPTYPE=4,XWBWRAP=1
"RTN","XWBTCPC",136,0)
 ; -- single value
"RTN","XWBTCPC",137,0)
 IF XWBPTYPE=1 S XWBR=$G(XWBR) W XWBR Q
"RTN","XWBTCPC",138,0)
 ; -- table delimited by CR+LF
"RTN","XWBTCPC",139,0)
 I XWBPTYPE=2 D  Q
"RTN","XWBTCPC",140,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  W:($X+$L(XWBR(I)))>509 ! W XWBR(I),$C(13,10)
"RTN","XWBTCPC",141,0)
 ; -- word processing
"RTN","XWBTCPC",142,0)
 IF XWBPTYPE=3 D  Q
"RTN","XWBTCPC",143,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  W:($X+$L(XWBR(I)))>509 ! W XWBR(I) W:XWBWRAP $C(13,10)
"RTN","XWBTCPC",144,0)
 ; -- global array
"RTN","XWBTCPC",145,0)
 IF XWBPTYPE=4 D  Q
"RTN","XWBTCPC",146,0)
 . S I=XWBR,T=$E(I,1,$L(I)-1) W:$D(@I)>10 @I F  S I=$Q(@I) Q:I=""!(I'[T)  W:($X+$L(@I))>509 ! W @I W:XWBWRAP&(@I'=$C(13,10)) $C(13,10)
"RTN","XWBTCPC",147,0)
 ; -- global instance
"RTN","XWBTCPC",148,0)
 IF XWBPTYPE=5 S XWBR=$G(@XWBR) W XWBR Q
"RTN","XWBTCPC",149,0)
 ; -- variable length records
"RTN","XWBTCPC",150,0)
 IF XWBPTYPE=6 S I="" F  S I=$O(XWBR(I)) Q:I=""  W:($X+$L(XWBR(I)))>509 ! W $C($L(XWBR(I))),XWBR(I)
"RTN","XWBTCPC",151,0)
 Q
"RTN","XWBTCPC",152,0)
 ;
"RTN","XWBTCPC",153,0)
ETRAP ; -- on trapped error, send error info to client
"RTN","XWBTCPC",154,0)
 N XWBERR
"RTN","XWBTCPC",155,0)
 S XWBERR=$C(24)_"M  ERROR="_$ZERROR_$C(13,10)_"LAST REF="_$ZR_$C(4)
"RTN","XWBTCPC",156,0)
 ;Turn off error trapping during trap
"RTN","XWBTCPC",157,0)
 IF $$NEWERR^%ZTER S $ETRAP=""
"RTN","XWBTCPC",158,0)
 E  S X="",@^%ZOSF("TRAP")
"RTN","XWBTCPC",159,0)
 U XWBTDEV
"RTN","XWBTCPC",160,0)
 D ^%ZTER ;Record the error
"RTN","XWBTCPC",161,0)
 IF XWBOS="DSM" D
"RTN","XWBTCPC",162,0)
 . I $D(XWBTLEN),XWBTLEN,$ZE'["SYSTEM-F" D SNDERR W XWBERR,!
"RTN","XWBTCPC",163,0)
 IF XWBOS="MSM" D
"RTN","XWBTCPC",164,0)
 . D SNDERR W XWBERR,!
"RTN","XWBTCPC",165,0)
 I ($ZE["READERR")!($ZE["DISCON")!($ZE["SYSTEM-F") HALT
"RTN","XWBTCPC",166,0)
 I '$$NEWERR^%ZTER G RESTART
"RTN","XWBTCPC",167,0)
 S $ETRAP="Q:($ESTACK&'$QUIT)  Q:$ESTACK 0 S $ECODE="""" G RESTART",$ECODE=",U99,"
"RTN","XWBTCPC",168,0)
 Q
"RTN","XWBTCPC",169,0)
 ;
"RTN","XWBTCPC",170,0)
BREAD(L) ;read tcp buffer, L is length
"RTN","XWBTCPC",171,0)
 N E,X,DONE
"RTN","XWBTCPC",172,0)
 S (E,DONE)=0
"RTN","XWBTCPC",173,0)
 R X#L:XWBTIME
"RTN","XWBTCPC",174,0)
 S E=X
"RTN","XWBTCPC",175,0)
 IF $L(E)<L F  D  Q:'DONE
"RTN","XWBTCPC",176,0)
 . IF $L(E)=L S DONE=1 Q
"RTN","XWBTCPC",177,0)
 . R X#(L-$L(E)):XWBTIME
"RTN","XWBTCPC",178,0)
 . S E=E_X
"RTN","XWBTCPC",179,0)
 Q E
"RTN","XWBTCPC",180,0)
 ;
"RTN","XWBTCPC",181,0)
CHPRN(N) ;change process name
"RTN","XWBTCPC",182,0)
 ;under DSM, change process name to N
"RTN","XWBTCPC",183,0)
 N X
"RTN","XWBTCPC",184,0)
 Q:XWBOS'="DSM"
"RTN","XWBTCPC",185,0)
 S X=$ZC(%SETPRN,N)
"RTN","XWBTCPC",186,0)
 Q
"RTN","XWBTCPC",187,0)
 ;
"RTN","XWBTCPL")
0^5^B17962615
"RTN","XWBTCPL",1,0)
XWBTCPL ;SLC/KCM - Listener for TCP connects ;08/23/96  14:55
"RTN","XWBTCPL",2,0)
 ;;1.0;RPC BROKER;**1**;May 24, 1996
"RTN","XWBTCPL",3,0)
 ;ISC-SF/EG - DHCP Broker
"RTN","XWBTCPL",4,0)
 ;
"RTN","XWBTCPL",5,0)
 ; This routine is the background process that listens for client
"RTN","XWBTCPL",6,0)
 ; requests to connect to M.  When a request is received, This
"RTN","XWBTCPL",7,0)
 ; procedure will job a s small routine to listen for new requests
"RTN","XWBTCPL",8,0)
 ; on the known service port.
"RTN","XWBTCPL",9,0)
 ;
"RTN","XWBTCPL",10,0)
 ; This job may be started in the background with:  D STRT^XWBTCP(PORT)
"RTN","XWBTCPL",11,0)
 ;
"RTN","XWBTCPL",12,0)
 ; When running, this job may be stopped with:      D STOP^XWBTCP(PORT)
"RTN","XWBTCPL",13,0)
 ;
"RTN","XWBTCPL",14,0)
 ; Where port is the known service port to listen for connections
"RTN","XWBTCPL",15,0)
 ;
"RTN","XWBTCPL",16,0)
EN(XWBTSKT) ; -- accept clients and start the individual message handler
"RTN","XWBTCPL",17,0)
 N IP,REF,RETRY
"RTN","XWBTCPL",18,0)
 X ^%ZOSF("UCI") S REF=Y
"RTN","XWBTCPL",19,0)
 S IP="0.0.0.0" ;get server IP
"RTN","XWBTCPL",20,0)
 IF $G(XWBTSKT)="" S XWBTSKT=9000 ; default service port
"RTN","XWBTCPL",21,0)
 S XWBTDEV=XWBTSKT
"RTN","XWBTCPL",22,0)
 ;
"RTN","XWBTCPL",23,0)
 D SETNM^%ZOSV($E("RPCB_Port:"_XWBTSKT,1,15)) ;change process name
"RTN","XWBTCPL",24,0)
 N LEN,MSG,XWBOS,DONE,DSMTCP,X,XWBVER,RETRY  ;**1**
"RTN","XWBTCPL",25,0)
 S RETRY=0
"RTN","XWBTCPL",26,0)
RESTART S DONE=0
"RTN","XWBTCPL",27,0)
 S XWBOS=$S(^%ZOSF("OS")["DSM":"DSM",^("OS")["MSM":"MSM",1:"")
"RTN","XWBTCPL",28,0)
 IF $$NEWERR^%ZTER N $ESTACK S $ETRAP="S %ZTER11S=$STACK D ETRAP^XWBTCPL"
"RTN","XWBTCPL",29,0)
 E  S X="ETRAP^XWBTCPL",@^%ZOSF("TRAP")
"RTN","XWBTCPL",30,0)
 ;
"RTN","XWBTCPL",31,0)
 ; -- check the TCP stop parameter
"RTN","XWBTCPL",32,0)
 IF $G(^XWB(IP,REF,XWBTSKT,"STOP")) K ^XWB(IP,REF,XWBTSKT) Q   ; -- change to param file later ***
"RTN","XWBTCPL",33,0)
 L +^XWB(IP,REF,XWBTSKT,"RUNNING"):1 Q:'$T  ; -- quit if job is already running
"RTN","XWBTCPL",34,0)
 ;
"RTN","XWBTCPL",35,0)
 I XWBOS="DSM" O XWBTSKT:TCPCHAN ;S DSMTCP=XWBTSKT_":TCPCHAN"
"RTN","XWBTCPL",36,0)
 ; -- loop until TCP stop parameter is set
"RTN","XWBTCPL",37,0)
 S XWBVER=1  ;**1**
"RTN","XWBTCPL",38,0)
 F  D  Q:$G(^XWB(IP,REF,XWBTSKT,"STOP"))
"RTN","XWBTCPL",39,0)
 . L +^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")
"RTN","XWBTCPL",40,0)
 . K ^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")   ;clear problem marker
"RTN","XWBTCPL",41,0)
 . L -^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")
"RTN","XWBTCPL",42,0)
 . ;
"RTN","XWBTCPL",43,0)
 . ; -- listen for connect & get the initial command from the client
"RTN","XWBTCPL",44,0)
 . I XWBOS="DSM" U XWBTSKT
"RTN","XWBTCPL",45,0)
 . I XWBOS="MSM" S XWBTDEV=56 O 56 U 56::"TCP" W /SOCKET("",XWBTSKT)
"RTN","XWBTCPL",46,0)
 . R LEN#6 IF $E(LEN,1,5)'="{XWB}" D  Q  ;bad client, abort
"RTN","XWBTCPL",47,0)
 . . W "RPC broker disconnect!",!
"RTN","XWBTCPL",48,0)
 . . IF XWBOS="DSM" U XWBTSKT:DISCONNECT
"RTN","XWBTCPL",49,0)
 . . IF XWBOS="MSM" C 56
"RTN","XWBTCPL",50,0)
 . . Q
"RTN","XWBTCPL",51,0)
 . IF $E(LEN,6,6)="|" D  
"RTN","XWBTCPL",52,0)
 . . R X#1
"RTN","XWBTCPL",53,0)
 . . R XWBVER#$A(X)  ;get version of packet
"RTN","XWBTCPL",54,0)
 . . R LEN#5
"RTN","XWBTCPL",55,0)
 . . Q
"RTN","XWBTCPL",56,0)
 . ELSE  S X=$E(LEN,6,6) R LEN#4 S LEN=X_LEN
"RTN","XWBTCPL",57,0)
 . R MSG#LEN
"RTN","XWBTCPL",58,0)
 . ; -- msg should be:  action^client IP^client port^token
"RTN","XWBTCPL",59,0)
 . ;
"RTN","XWBTCPL",60,0)
 . ; -- if the action is TCPconnect (usual case)
"RTN","XWBTCPL",61,0)
 . I $P(MSG,"^")="TCPconnect" D
"RTN","XWBTCPL",62,0)
 . . ;-- decrypt token
"RTN","XWBTCPL",63,0)
 . . S X=""
"RTN","XWBTCPL",64,0)
 . . IF XWBOS="DSM" J EN^XWBTCPC($P(MSG,"^",2),$P(MSG,"^",3),$P(X,"^"),XWBVER):OPTION="/SYMBOL=100000":5
"RTN","XWBTCPL",65,0)
 . . ELSE  J EN^XWBTCPC($P(MSG,"^",2),$P(MSG,"^",3),$P(X,"^"),XWBVER):100000:5
"RTN","XWBTCPL",66,0)
 . . I $T D SNDERR W "accept",$C(4),!
"RTN","XWBTCPL",67,0)
 . . E  D SNDERR W "reject",$C(4),! S ^TMP("TCP",$P($H,",",2))="REJECT"
"RTN","XWBTCPL",68,0)
 . ;
"RTN","XWBTCPL",69,0)
 . ; -- if the action is TCPdebug (when msg handler run interactively)
"RTN","XWBTCPL",70,0)
 . I $P(MSG,"^")="TCPdebug" D SNDERR W "accept",$C(4),!
"RTN","XWBTCPL",71,0)
 . ;
"RTN","XWBTCPL",72,0)
 . ; -- if the action is TCPshutdown, this listener will quit if the
"RTN","XWBTCPL",73,0)
 . ;    stop flag has been set.  This request comes from an M process.
"RTN","XWBTCPL",74,0)
 . I $P(MSG,"^")="TCPshutdown" W "ack",!
"RTN","XWBTCPL",75,0)
 . I XWBOS="DSM" U XWBTSKT:DISCONNECT ; release this socket
"RTN","XWBTCPL",76,0)
 . I XWBOS="MSM" C 56
"RTN","XWBTCPL",77,0)
 ; -- loop end
"RTN","XWBTCPL",78,0)
 ;
"RTN","XWBTCPL",79,0)
 IF XWBOS="DSM" C XWBTSKT
"RTN","XWBTCPL",80,0)
 IF DONE L -^XWB(IP,REF,XWBTSKT,"RUNNING")    ; destroy 'running flag'
"RTN","XWBTCPL",81,0)
 K ^XWB(IP,REF,XWBTSKT,"STOP")
"RTN","XWBTCPL",82,0)
 Q
"RTN","XWBTCPL",83,0)
 ;
"RTN","XWBTCPL",84,0)
ETRAP   ; -- on trapped error, send error info to client
"RTN","XWBTCPL",85,0)
 N XWBERR
"RTN","XWBTCPL",86,0)
 S XWBERR=$C(24)_"M  ERROR="_$ZERROR_$C(13,10)_"LAST REF="_$ZR_$C(4)
"RTN","XWBTCPL",87,0)
 D ^%ZTER ;Record it
"RTN","XWBTCPL",88,0)
 S RETRY=RETRY+1
"RTN","XWBTCPL",89,0)
 IF RETRY=5 H  ;server error, give up
"RTN","XWBTCPL",90,0)
 IF XWBOS="DSM" D
"RTN","XWBTCPL",91,0)
 . I $D(XWBTLEN),XWBTLEN,$ZE'["SYSTEM-F" D SNDERR W XWBERR
"RTN","XWBTCPL",92,0)
 IF XWBOS="MSM" D
"RTN","XWBTCPL",93,0)
 . D SNDERR W XWBERR
"RTN","XWBTCPL",94,0)
 I XWBOS="MSM" G RESTART
"RTN","XWBTCPL",95,0)
 S $ETRAP="Q:($ESTACK&'$QUIT)  Q:$ESTACK 0 S $ECODE="""" G RESTART^XWBTCPL",$ECODE=",U99,"
"RTN","XWBTCPL",96,0)
 ;
"RTN","XWBTCPL",97,0)
CHPRN(N) ;change process name
"RTN","XWBTCPL",98,0)
 ;under DSM, change process name to N
"RTN","XWBTCPL",99,0)
 N X
"RTN","XWBTCPL",100,0)
 Q:XWBOS'="DSM"
"RTN","XWBTCPL",101,0)
 S X=$ZC(%SETPRN,N)
"RTN","XWBTCPL",102,0)
 Q
"RTN","XWBTCPL",103,0)
 ;
"RTN","XWBTCPL",104,0)
SNDERR ;send error information
"RTN","XWBTCPL",105,0)
 ;XWBSEC is the security packet, XWBERROR is application packet
"RTN","XWBTCPL",106,0)
 N X
"RTN","XWBTCPL",107,0)
 S X=$G(XWBSEC)
"RTN","XWBTCPL",108,0)
 W $C($L(X))_X
"RTN","XWBTCPL",109,0)
 S X=$G(XWBERROR)
"RTN","XWBTCPL",110,0)
 W $C($L(X))_X W !
"RTN","XWBTCPL",111,0)
 S XWBERROR="" ;clears parameters
"RTN","XWBTCPL",112,0)
 Q
"VER")
8.0^21.0
**END**
**END**
