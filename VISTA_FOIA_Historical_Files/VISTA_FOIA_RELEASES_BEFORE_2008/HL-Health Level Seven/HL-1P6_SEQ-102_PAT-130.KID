Released HL*1.6*130 SEQ #102
Extracted from mail message
**KIDS**:HL*1.6*130^

**INSTALL NAME**
HL*1.6*130
"BLD",908,0)
HL*1.6*130^HEALTH LEVEL SEVEN^0^3051205^y
"BLD",908,1,0)
^^2^2^3051019^
"BLD",908,1,1,0)
Please see the NPM on Forum for a complete description.
"BLD",908,1,2,0)

"BLD",908,4,0)
^9.64PA^870^2
"BLD",908,4,779.3,0)
779.3
"BLD",908,4,779.3,222)
n^n^f^^n^^y^o^n
"BLD",908,4,779.3,224)
I $P($G(^HLD(779.3,+Y,0)),"^")="TOTAL MESSAGE COUNTS"
"BLD",908,4,870,0)
870
"BLD",908,4,870,2,0)
^9.641^870^1
"BLD",908,4,870,2,870,0)
HL LOGICAL LINK  (File-top level)
"BLD",908,4,870,2,870,1,0)
^9.6411^16^1
"BLD",908,4,870,2,870,1,16,0)
SHUTDOWN OUTGOING HLO MESSAGES
"BLD",908,4,870,222)
y^n^p^^^^n^^n
"BLD",908,4,870,224)

"BLD",908,4,"APDD",870,870)

"BLD",908,4,"APDD",870,870,16)

"BLD",908,4,"B",779.3,779.3)

"BLD",908,4,"B",870,870)

"BLD",908,6.3)
10
"BLD",908,"ABPKG")
n
"BLD",908,"KRN",0)
^9.67PA^8989.52^19
"BLD",908,"KRN",.4,0)
.4
"BLD",908,"KRN",.401,0)
.401
"BLD",908,"KRN",.402,0)
.402
"BLD",908,"KRN",.403,0)
.403
"BLD",908,"KRN",.5,0)
.5
"BLD",908,"KRN",.84,0)
.84
"BLD",908,"KRN",3.6,0)
3.6
"BLD",908,"KRN",3.8,0)
3.8
"BLD",908,"KRN",9.2,0)
9.2
"BLD",908,"KRN",9.8,0)
9.8
"BLD",908,"KRN",9.8,"NM",0)
^9.68A^9^9
"BLD",908,"KRN",9.8,"NM",1,0)
HLOCLNT^^0^55768085
"BLD",908,"KRN",9.8,"NM",2,0)
HLOCLNT1^^0^27548481
"BLD",908,"KRN",9.8,"NM",3,0)
HLOCLNT2^^0^23345410
"BLD",908,"KRN",9.8,"NM",4,0)
HLOSRVR^^0^70554107
"BLD",908,"KRN",9.8,"NM",5,0)
HLOSRVR1^^0^65124218
"BLD",908,"KRN",9.8,"NM",6,0)
HLOSTAT^^0^55434883
"BLD",908,"KRN",9.8,"NM",7,0)
HLOTLNK^^0^20724359
"BLD",908,"KRN",9.8,"NM",8,0)
HLOUSR^^0^88410850
"BLD",908,"KRN",9.8,"NM",9,0)
HLOUSRA^^0^10710992
"BLD",908,"KRN",9.8,"NM","B","HLOCLNT",1)

"BLD",908,"KRN",9.8,"NM","B","HLOCLNT1",2)

"BLD",908,"KRN",9.8,"NM","B","HLOCLNT2",3)

"BLD",908,"KRN",9.8,"NM","B","HLOSRVR",4)

"BLD",908,"KRN",9.8,"NM","B","HLOSRVR1",5)

"BLD",908,"KRN",9.8,"NM","B","HLOSTAT",6)

"BLD",908,"KRN",9.8,"NM","B","HLOTLNK",7)

"BLD",908,"KRN",9.8,"NM","B","HLOUSR",8)

"BLD",908,"KRN",9.8,"NM","B","HLOUSRA",9)

"BLD",908,"KRN",19,0)
19
"BLD",908,"KRN",19,"NM",0)
^9.68A^2^2
"BLD",908,"KRN",19,"NM",1,0)
HLO MAIN MENU^^2
"BLD",908,"KRN",19,"NM",2,0)
HLO MESSAGE STATISTICS^^0
"BLD",908,"KRN",19,"NM","B","HLO MAIN MENU",1)

"BLD",908,"KRN",19,"NM","B","HLO MESSAGE STATISTICS",2)

"BLD",908,"KRN",19.1,0)
19.1
"BLD",908,"KRN",101,0)
101
"BLD",908,"KRN",101,"NM",0)
^9.68A^4^4
"BLD",908,"KRN",101,"NM",1,0)
HLO DOWN LINKS^^0
"BLD",908,"KRN",101,"NM",2,0)
HLO DOWN LINKS MENU^^0
"BLD",908,"KRN",101,"NM",3,0)
HLO SHUTDOWN LINK^^0
"BLD",908,"KRN",101,"NM",4,0)
HLO RESTART LINK^^0
"BLD",908,"KRN",101,"NM","B","HLO DOWN LINKS",1)

"BLD",908,"KRN",101,"NM","B","HLO DOWN LINKS MENU",2)

"BLD",908,"KRN",101,"NM","B","HLO RESTART LINK",4)

"BLD",908,"KRN",101,"NM","B","HLO SHUTDOWN LINK",3)

"BLD",908,"KRN",409.61,0)
409.61
"BLD",908,"KRN",409.61,"NM",0)
^9.68A^1^1
"BLD",908,"KRN",409.61,"NM",1,0)
HLO DOWN LINKS^^0
"BLD",908,"KRN",409.61,"NM","B","HLO DOWN LINKS",1)

"BLD",908,"KRN",771,0)
771
"BLD",908,"KRN",870,0)
870
"BLD",908,"KRN",8989.51,0)
8989.51
"BLD",908,"KRN",8989.52,0)
8989.52
"BLD",908,"KRN",8994,0)
8994
"BLD",908,"KRN","B",.4,.4)

"BLD",908,"KRN","B",.401,.401)

"BLD",908,"KRN","B",.402,.402)

"BLD",908,"KRN","B",.403,.403)

"BLD",908,"KRN","B",.5,.5)

"BLD",908,"KRN","B",.84,.84)

"BLD",908,"KRN","B",3.6,3.6)

"BLD",908,"KRN","B",3.8,3.8)

"BLD",908,"KRN","B",9.2,9.2)

"BLD",908,"KRN","B",9.8,9.8)

"BLD",908,"KRN","B",19,19)

"BLD",908,"KRN","B",19.1,19.1)

"BLD",908,"KRN","B",101,101)

"BLD",908,"KRN","B",409.61,409.61)

"BLD",908,"KRN","B",771,771)

"BLD",908,"KRN","B",870,870)

"BLD",908,"KRN","B",8989.51,8989.51)

"BLD",908,"KRN","B",8989.52,8989.52)

"BLD",908,"KRN","B",8994,8994)

"BLD",908,"QUES",0)
^9.62^^
"BLD",908,"REQB",0)
^9.611^1^1
"BLD",908,"REQB",1,0)
HL*1.6*126^2
"BLD",908,"REQB","B","HL*1.6*126",1)

"DATA",779.3,13,0)
TOTAL MESSAGE COUNTS^1^0^1^360^3051122.181458^0^QUIT1^HLOPROC1^TOTAL^HLOSTAT^1^0
"FIA",779.3)
HLO PROCESS REGISTRY
"FIA",779.3,0)
^HLD(779.3,
"FIA",779.3,0,0)
779.3
"FIA",779.3,0,1)
n^n^f^^n^^y^o^n
"FIA",779.3,0,10)

"FIA",779.3,0,11)
I $P($G(^HLD(779.3,+Y,0)),"^")="TOTAL MESSAGE COUNTS"
"FIA",779.3,0,"RLRO")

"FIA",779.3,0,"VR")
1.6^HL
"FIA",779.3,779.3)
0
"FIA",870)
HL LOGICAL LINK
"FIA",870,0)
^HLCS(870,
"FIA",870,0,0)
870
"FIA",870,0,1)
y^n^p^^^^n^^n
"FIA",870,0,10)

"FIA",870,0,11)

"FIA",870,0,"RLRO")

"FIA",870,0,"VR")
1.6^HL
"FIA",870,870)
1
"FIA",870,870,16)

"IX",779.3,779.3,"C",0)
779.3^C^Used to find active entries in the process registry.^R^^F^IR^I^779.3^^^^^LS
"IX",779.3,779.3,"C",1)
S ^HLD(779.3,"C",X,DA)=""
"IX",779.3,779.3,"C",1.4)
S X=$S('X(1):0,1:1)
"IX",779.3,779.3,"C",2)
K ^HLD(779.3,"C",X,DA)
"IX",779.3,779.3,"C",2.5)
K ^HLD(779.3,"C")
"IX",779.3,779.3,"C",11.1,0)
^.114IA^1^1
"IX",779.3,779.3,"C",11.1,1,0)
1^F^779.3^.02^^1^F
"IX",779.3,779.3,"D",0)
779.3^D^Uniqueness Index for Key 'A' of File #779.3^R^^F^IR^I^779.3^^^^^LS
"IX",779.3,779.3,"D",1)
S ^HLD(779.3,"D",X,DA)=""
"IX",779.3,779.3,"D",2)
K ^HLD(779.3,"D",X,DA)
"IX",779.3,779.3,"D",2.5)
K ^HLD(779.3,"D")
"IX",779.3,779.3,"D",11.1,0)
^.114IA^1^1
"IX",779.3,779.3,"D",11.1,1,0)
1^F^779.3^.01^^1
"KEY",779.3,779.3,"A",0)
779.3^A^P^83
"KEY",779.3,779.3,"A",2,0)
^.312IA^1^1
"KEY",779.3,779.3,"A",2,1,0)
.01^779.3^1
"KEYPTR",779.3,779.3,"A")
779.3^D
"KRN",19,1047,-1)
2^1
"KRN",19,1047,0)
HLO MAIN MENU^HL7 (Optimized) MAIN MENU^^M^1000061^^^^^^y^9
"KRN",19,1047,10,0)
^19.01IP^4^4
"KRN",19,1047,10,4,0)
1151^STAT^4
"KRN",19,1047,10,4,"^")
HLO MESSAGE STATISTICS
"KRN",19,1047,"U")
HL7 (OPTIMIZED) MAIN MENU
"KRN",19,1151,-1)
0^2
"KRN",19,1151,0)
HLO MESSAGE STATISTICS^HLO MESSAGE STATISTICS^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,1151,1,0)
^^4^4^3051026^
"KRN",19,1151,1,1,0)
This option is a report that displays by period the counts of messgages sent
"KRN",19,1151,1,2,0)
and received via HLO.  The counts are sub-categorized by application and
"KRN",19,1151,1,3,0)
message type.
"KRN",19,1151,1,4,0)

"KRN",19,1151,10.1)
HLO MESSAGE STATISTICS REPORT
"KRN",19,1151,20)
D REPORT^HLOSTAT
"KRN",19,1151,"U")
HLO MESSAGE STATISTICS
"KRN",101,414,-1)
0^1
"KRN",101,414,0)
HLO DOWN LINKS^DOWN LINKS^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,414,1,0)
^101.06^1^1^3050208^^^^
"KRN",101,414,1,1,0)
This action lists the links that have been down for more than 5 minutes.
"KRN",101,414,2,0)
^101.02A^1^1
"KRN",101,414,2,1,0)
DL
"KRN",101,414,2,"B","DL",1)

"KRN",101,414,20)
D DOWNLINK^HLOUSRA
"KRN",101,414,99)
60185,48281
"KRN",101,453,-1)
0^2
"KRN",101,453,0)
HLO DOWN LINKS MENU^HLO DOWN LINKS MENU^^M^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,453,1,0)
^101.06^2^2^3050914^^^^
"KRN",101,453,1,1,0)
This is the action menu for the List Template 'HLO DOWN LINKS'.
"KRN",101,453,1,2,0)

"KRN",101,453,4)
26^4
"KRN",101,453,10,0)
^101.01PA^2^2
"KRN",101,453,10,1,0)
454^SL^1^^^SHUTDOWN LINK
"KRN",101,453,10,1,"^")
HLO SHUTDOWN LINK
"KRN",101,453,10,2,0)
455^RL^^^^RESTART LINK
"KRN",101,453,10,2,"^")
HLO RESTART LINK
"KRN",101,453,26)
D SHOW^VALM
"KRN",101,453,28)
Select Action:
"KRN",101,453,99)
60185,48281
"KRN",101,454,-1)
0^3
"KRN",101,454,0)
HLO SHUTDOWN LINK^SHUTDOWN LINK^^A^^^^^^^^HL7 PERFORMANCE ENHANCMENTS
"KRN",101,454,1,0)
^101.06^3^3^3050915^^
"KRN",101,454,1,1,0)
This action is used to stop HLO messages from being transmitted to a particular
"KRN",101,454,1,2,0)
the domain identified by an HL LOGICAL LINK file entry.
"KRN",101,454,1,3,0)

"KRN",101,454,20)
D STOPLINK^HLOUSRA
"KRN",101,454,99)
60185,48281
"KRN",101,455,-1)
0^4
"KRN",101,455,0)
HLO RESTART LINK^HLO RESTART LINK^^A^^^^^^^^HL7 PERFORMANCE ENHANCMENTS
"KRN",101,455,1,0)
^^3^3^3050915^
"KRN",101,455,1,1,0)
This action protocol allows the user to select an entry from the HL Logical Link
"KRN",101,455,1,2,0)
file and will restart HLO messages going to the IP identfied by the link
"KRN",101,455,1,3,0)

"KRN",101,455,20)
D RESTART^HLOUSRA
"KRN",101,455,99)
60185,48281
"KRN",409.61,244,-1)
0^1
"KRN",409.61,244,0)
HLO DOWN LINKS^1^1^80^3^20^1^1^DOWN LINKS^HLO DOWN LINKS MENU^Down HLO Links^1
"KRN",409.61,244,1)
^VALM HIDDEN ACTIONS
"KRN",409.61,244,"ARRAY")
 ^TMP($J,"HLO DOWN LINKS")
"KRN",409.61,244,"FNL")
D EXIT^HLOUSRA
"KRN",409.61,244,"HDR")
D HEADER^HLOUSRA
"KRN",409.61,244,"HLP")
D HELP^HLOUSRA
"KRN",409.61,244,"INIT")
D LISTDOWN^HLOUSRA
"MBREQ")
0
"ORD",15,101)
101;15;;;PRO^XPDTA;PROF1^XPDIA;PROE1^XPDIA;PROF2^XPDIA;;PRODEL^XPDIA
"ORD",15,101,0)
PROTOCOL
"ORD",17,409.61)
409.61;17;1;;;;;;;LMDEL^XPDIA1
"ORD",17,409.61,0)
LIST TEMPLATE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
130^3051205
"PKG",9,22,1,"PAH",1,1,0)
^^2^2^3051205
"PKG",9,22,1,"PAH",1,1,1,0)
Please see the NPM on Forum for a complete description.
"PKG",9,22,1,"PAH",1,1,2,0)

"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
9
"RTN","HLOCLNT")
0^1^B55768085
"RTN","HLOCLNT",1,0)
HLOCLNT ;ALB/CJM- Client for sending messages - 10/4/94 1pm
"RTN","HLOCLNT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130**;Oct 13, 1995;Build 10
"RTN","HLOCLNT",3,0)
 ;
"RTN","HLOCLNT",4,0)
 ;GET WORK function for the process running under the Process Manager
"RTN","HLOCLNT",5,0)
GETWORK(QUE) ;
"RTN","HLOCLNT",6,0)
 ;Input:
"RTN","HLOCLNT",7,0)
 ;  QUE - (pass by reference) These subscripts are used:
"RTN","HLOCLNT",8,0)
 ;    ("LINK")  - <link name>_":"_<port> last obtained
"RTN","HLOCLNT",9,0)
 ;    ("QUEUE") - name of the queue last obtained
"RTN","HLOCLNT",10,0)
 ;Output:
"RTN","HLOCLNT",11,0)
 ;  Function returns 1 if success, 0 if no more work
"RTN","HLOCLNT",12,0)
 ;  QUE -  updated to identify next queue of messages to process.
"RTN","HLOCLNT",13,0)
 ;    ("LINK") - <link name>_":"_<port>
"RTN","HLOCLNT",14,0)
 ;    ("QUEUE") - the named queue on the link
"RTN","HLOCLNT",15,0)
 ;    ("DOWN") - =1 means that the last OPEN attempt failed
"RTN","HLOCLNT",16,0)
 ;
"RTN","HLOCLNT",17,0)
 N LINK,QUEUE
"RTN","HLOCLNT",18,0)
 S LINK=$G(QUE("LINK")),QUEUE=$G(QUE("QUEUE"))
"RTN","HLOCLNT",19,0)
 I (LINK]""),(QUEUE]"") D
"RTN","HLOCLNT",20,0)
 .L -^HLB("QUEUE","OUT",LINK,QUEUE)
"RTN","HLOCLNT",21,0)
 .I '$$CNNCTD(LINK),$$FAILING(.LINK) S QUEUE="" Q
"RTN","HLOCLNT",22,0)
 .F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0  Q:$T
"RTN","HLOCLNT",23,0)
 I (LINK]""),(QUEUE="") D
"RTN","HLOCLNT",24,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",25,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",26,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",27,0)
 I LINK="" D
"RTN","HLOCLNT",28,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",29,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",30,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",31,0)
 S QUE("LINK")=LINK,QUE("QUEUE")=QUEUE,QUE("DOWN")=$G(LINK("DOWN"))
"RTN","HLOCLNT",32,0)
 Q:$L(QUEUE) 1
"RTN","HLOCLNT",33,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",34,0)
 Q 0
"RTN","HLOCLNT",35,0)
 ;
"RTN","HLOCLNT",36,0)
FAILING(LINK) ;
"RTN","HLOCLNT",37,0)
 ;Returns 1 if the link has failed in the last 30 seconds, 0 otherwise
"RTN","HLOCLNT",38,0)
 ;Also returns LINK("DOWN")=1 if the link was failing > 30 seconds ago, not yet known if its up
"RTN","HLOCLNT",39,0)
 ;
"RTN","HLOCLNT",40,0)
 N LASTTIME,SET
"RTN","HLOCLNT",41,0)
 S LINK("DOWN")=0
"RTN","HLOCLNT",42,0)
 S LASTTIME=$G(^HLB("QUEUE","OUT",LINK))
"RTN","HLOCLNT",43,0)
 S SET=$S(LASTTIME]"":1,1:0)
"RTN","HLOCLNT",44,0)
 I SET D
"RTN","HLOCLNT",45,0)
 .I $$HDIFF^XLFDT($H,LASTTIME,2)>30 S ^HLB("QUEUE","OUT",LINK)="",SET=0,LINK("DOWN")=1
"RTN","HLOCLNT",46,0)
 I $D(^HLTMP("FAILING LINKS",LINK)) S LINK("DOWN")=1
"RTN","HLOCLNT",47,0)
 Q SET
"RTN","HLOCLNT",48,0)
 ;
"RTN","HLOCLNT",49,0)
LINKDOWN(HLCSTATE) ;
"RTN","HLOCLNT",50,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",51,0)
 I $D(HLCSTATE("LINK","NAME")),$D(HLCSTATE("LINK","PORT")) D
"RTN","HLOCLNT",52,0)
 .S TO=HLCSTATE("LINK","NAME")_":"_HLCSTATE("LINK","PORT")
"RTN","HLOCLNT",53,0)
 .S ^HLB("QUEUE","OUT",TO)=$H
"RTN","HLOCLNT",54,0)
 .S:'$D(^HLTMP("FAILING LINKS",TO)) ^HLTMP("FAILING LINKS",TO)=$H
"RTN","HLOCLNT",55,0)
 Q
"RTN","HLOCLNT",56,0)
 ;
"RTN","HLOCLNT",57,0)
ERROR ;error trap
"RTN","HLOCLNT",58,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOCLNT",59,0)
 D END
"RTN","HLOCLNT",60,0)
 D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",61,0)
 ;
"RTN","HLOCLNT",62,0)
 ;while debugging quit on all errors - this will return the process to the Process Manager error trap
"RTN","HLOCLNT",63,0)
 I $G(^HLTMP("LOG ALL ERRORS")) QUIT
"RTN","HLOCLNT",64,0)
 ;
"RTN","HLOCLNT",65,0)
 ;don't log some common errors
"RTN","HLOCLNT",66,0)
 I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D
"RTN","HLOCLNT",67,0)
 .;
"RTN","HLOCLNT",68,0)
 E  D
"RTN","HLOCLNT",69,0)
 .D ^%ZTER
"RTN","HLOCLNT",70,0)
 ;
"RTN","HLOCLNT",71,0)
 ;a lot of errors of the same type may indicate an endless loop, so keep a count
"RTN","HLOCLNT",72,0)
 S ^TMP("HL7 ERRORS",$J,$ECODE)=$G(^TMP("HL7 ERRORS",$J,$ECODE))+1
"RTN","HLOCLNT",73,0)
 ;
"RTN","HLOCLNT",74,0)
 QUIT:($G(^TMP("HL7 ERRORS",$J,$ECODE))>100)  ;return to the Process Manager error trap
"RTN","HLOCLNT",75,0)
 D UNWIND^%ZTER
"RTN","HLOCLNT",76,0)
 Q
"RTN","HLOCLNT",77,0)
 ;
"RTN","HLOCLNT",78,0)
DOWORK(QUEUE) ;sends the messages on the queue
"RTN","HLOCLNT",79,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOCLNT"
"RTN","HLOCLNT",80,0)
 N MSGIEN,DEQUE,SUCCESS,MSGCOUNT
"RTN","HLOCLNT",81,0)
 S DEQUE=0
"RTN","HLOCLNT",82,0)
 S SUCCESS=1
"RTN","HLOCLNT",83,0)
 I '$$CNNCTD(QUEUE("LINK")),'$$CONNECT^HLOCLNT1($P(QUEUE("LINK"),":"),$P(QUEUE("LINK"),":",2),.HLCSTATE) Q
"RTN","HLOCLNT",84,0)
 ;
"RTN","HLOCLNT",85,0)
 S (MSGCOUNT,MSGIEN)=0
"RTN","HLOCLNT",86,0)
 F  S MSGIEN=$O(^HLB("QUEUE","OUT",QUEUE("LINK"),QUEUE("QUEUE"),MSGIEN)) Q:'MSGIEN  D  Q:'SUCCESS  Q:MSGCOUNT>1000
"RTN","HLOCLNT",87,0)
 .N UPDATE
"RTN","HLOCLNT",88,0)
 .I $$INC^HLOSITE($NA(^HLB(MSGIEN,"TRIES"))) S SUCCESS=0
"RTN","HLOCLNT",89,0)
 .S:$$TRANSMIT(.HLCSTATE,MSGIEN,.UPDATE) SUCCESS=1
"RTN","HLOCLNT",90,0)
 .Q:'SUCCESS
"RTN","HLOCLNT",91,0)
 .D DEQUE(.UPDATE)
"RTN","HLOCLNT",92,0)
 .S MSGCOUNT=MSGCOUNT+1
"RTN","HLOCLNT",93,0)
 .D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOCLNT",94,0)
 .;
"RTN","HLOCLNT",95,0)
 .;if the queue was on the down list, and not since shutdown, mark it as up, since a message has been successfully transmitted across it
"RTN","HLOCLNT",96,0)
 .I $G(QUEUE("DOWN"))!$$FAILING(QUEUE("LINK")),'$$IFSHUT^HLOTLNK(QUEUE("LINK")) S QUEUE("DOWN")=0,^HLB("QUEUE","OUT",QUEUE("LINK"))="" K ^HLTMP("FAILING LINKS",QUEUE("LINK"))
"RTN","HLOCLNT",97,0)
 ;
"RTN","HLOCLNT",98,0)
END D DEQUE()
"RTN","HLOCLNT",99,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOCLNT",100,0)
 Q
"RTN","HLOCLNT",101,0)
CNNCTD(LINK) ;
"RTN","HLOCLNT",102,0)
 ;Connected to LINK?  HLCSTATE must be defined, LINK=<link name>:<port>
"RTN","HLOCLNT",103,0)
 ;
"RTN","HLOCLNT",104,0)
 I ($G(HLCSTATE("LINK","NAME"))=$P(LINK,":")),($G(HLCSTATE("LINK","PORT"))=$P(LINK,":",2)),$G(HLCSTATE("CONNECTED")) Q 1
"RTN","HLOCLNT",105,0)
 Q 0
"RTN","HLOCLNT",106,0)
 ;
"RTN","HLOCLNT",107,0)
DEQUE(UPDATE) ;
"RTN","HLOCLNT",108,0)
 I $D(UPDATE) S DEQUE=DEQUE+1,DEQUE(+UPDATE)=$P(UPDATE,"^",2,99) S:$G(UPDATE("MSA"))]"" DEQUE(+UPDATE,"MSA")=UPDATE("MSA") S:$G(UPDATE("ACTION"))]"" DEQUE(+UPDATE,"ACTION")=UPDATE("ACTION")
"RTN","HLOCLNT",109,0)
 I '$D(UPDATE)!(DEQUE>15) D
"RTN","HLOCLNT",110,0)
 .N MSGIEN S MSGIEN=0
"RTN","HLOCLNT",111,0)
 .F  S MSGIEN=$O(DEQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOCLNT",112,0)
 ..N NODE,TIME
"RTN","HLOCLNT",113,0)
 ..D DEQUE^HLOQUE(QUEUE("LINK"),QUEUE("QUEUE"),"OUT",MSGIEN)
"RTN","HLOCLNT",114,0)
 ..S TIME=$P(DEQUE(MSGIEN),"^")
"RTN","HLOCLNT",115,0)
 ..S NODE=QUEUE("LINK")_"^"_QUEUE("QUEUE")_"^"_$P(DEQUE(MSGIEN),"^",2,99)
"RTN","HLOCLNT",116,0)
 ..S ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN)=NODE
"RTN","HLOCLNT",117,0)
 ..S:$G(DEQUE(MSGIEN,"MSA"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"MSA")=DEQUE(MSGIEN,"MSA")
"RTN","HLOCLNT",118,0)
 ..S:$G(DEQUE(MSGIEN,"ACTION"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"ACTION")=DEQUE(MSGIEN,"ACTION")
"RTN","HLOCLNT",119,0)
 .K DEQUE S DEQUE=0
"RTN","HLOCLNT",120,0)
 Q
"RTN","HLOCLNT",121,0)
 ;
"RTN","HLOCLNT",122,0)
TRANSMIT(HLCSTATE,MSGIEN,UPDATE) ;
"RTN","HLOCLNT",123,0)
 ;Transmits a single message and if a commit ack was requested reads it.  Updates file 778 with the result.  Queues for the infiler the application accept action if one was requested.
"RTN","HLOCLNT",124,0)
 ;Input:
"RTN","HLOCLNT",125,0)
 ;   HLCSTATE (pass by reference)
"RTN","HLOCLNT",126,0)
 ;   MSGIEN - ien, file 778, of message to be transmitted
"RTN","HLOCLNT",127,0)
 ;Output:
"RTN","HLOCLNT",128,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT",129,0)
 ;  UPDATE - (pass by reference) to contain updates needed for message
"RTN","HLOCLNT",130,0)
 ;
"RTN","HLOCLNT",131,0)
 N HLMSTATE,MSA,HDR,SUCCESS
"RTN","HLOCLNT",132,0)
 ;get the message that is to be sent
"RTN","HLOCLNT",133,0)
 S UPDATE=MSGIEN_"^"_$$NOW^XLFDT
"RTN","HLOCLNT",134,0)
 ;
"RTN","HLOCLNT",135,0)
 S SUCCESS=0
"RTN","HLOCLNT",136,0)
 S HLCSTATE("ATTEMPT")=0
"RTN","HLOCLNT",137,0)
RETRY ;
"RTN","HLOCLNT",138,0)
 S HLCSTATE("ATTEMPT")=HLCSTATE("ATTEMPT")+1
"RTN","HLOCLNT",139,0)
 I ('HLCSTATE("CONNECTED"))!(HLCSTATE("ATTEMPT")>1) G GIVEUP
"RTN","HLOCLNT",140,0)
 ;
"RTN","HLOCLNT",141,0)
 Q:'$$GETMSG^HLOCLNT2(MSGIEN,.HLMSTATE) 1  ;returns 1 so the message will be removed from the queue
"RTN","HLOCLNT",142,0)
 I HLMSTATE("DT/TM"),HLMSTATE("STATUS","ACCEPTED")!(HLMSTATE("HDR","ACCEPT ACK TYPE")="NE") Q 1
"RTN","HLOCLNT",143,0)
 ;
"RTN","HLOCLNT",144,0)
 ;try to send the message
"RTN","HLOCLNT",145,0)
 Q:'$$WRITEMSG^HLOCLNT1(.HLCSTATE,.HLMSTATE) 0
"RTN","HLOCLNT",146,0)
 ;does the message need an accept ack?
"RTN","HLOCLNT",147,0)
 I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" D  G:'SUCCESS RETRY
"RTN","HLOCLNT",148,0)
 .N FS
"RTN","HLOCLNT",149,0)
READACK .;GOTO within a inside dotted DO is on purpose - if the read of ack fails, it will try again, discarding whatever was received.  The remote server must follow the protocol. 
"RTN","HLOCLNT",150,0)
 .Q:'$$READACK^HLOCLNT1(.HLCSTATE,.HDR,.MSA)
"RTN","HLOCLNT",151,0)
 .;does the MSA refer to the correct control id?
"RTN","HLOCLNT",152,0)
 .S FS=$E(HDR(1),4)
"RTN","HLOCLNT",153,0)
 .I $P(MSA,FS,3)'=$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID")) G READACK
"RTN","HLOCLNT",154,0)
 .N ACKID,ACKCODE
"RTN","HLOCLNT",155,0)
 .S ACKCODE=$P(MSA,FS,2)
"RTN","HLOCLNT",156,0)
 .S ACKID=$S($E(HDR(1),1,3)="MSH":$P(HDR(2),FS,5),1:$P(HDR(2),FS,6))
"RTN","HLOCLNT",157,0)
 .S $P(UPDATE,"^",5)=1
"RTN","HLOCLNT",158,0)
 .S UPDATE("MSA")=ACKID_"^"_MSA
"RTN","HLOCLNT",159,0)
 .I '(ACKCODE="CA") S $P(UPDATE,"^",3)="SE",$P(UPDATE,"^",4)=2
"RTN","HLOCLNT",160,0)
 .I ACKCODE="CA",HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=$S(HLMSTATE("BATCH"):"2",1:1)
"RTN","HLOCLNT",161,0)
 .I ($P(UPDATE,"^",3)="SE") S $P(UPDATE,"^",6)=$P(HLMSTATE("HDR",1),FS,5) ;errors need the application for xref
"RTN","HLOCLNT",162,0)
 .;
"RTN","HLOCLNT",163,0)
 .;did the app request notification of accept ack?
"RTN","HLOCLNT",164,0)
 .S UPDATE("ACTION")=HLMSTATE("ACCEPT ACK RESPONSE")
"RTN","HLOCLNT",165,0)
 .S SUCCESS=1
"RTN","HLOCLNT",166,0)
 E  D  ;accept ack wasn't requested
"RTN","HLOCLNT",167,0)
 .S SUCCESS=1
"RTN","HLOCLNT",168,0)
 .I HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=$S(HLMSTATE("BATCH"):2,1:1)
"RTN","HLOCLNT",169,0)
 ;
"RTN","HLOCLNT",170,0)
 G:'SUCCESS RETRY ;only executes if reading the ack failed
"RTN","HLOCLNT",171,0)
 D:SUCCESS COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOCLNT",172,0)
 ;
"RTN","HLOCLNT",173,0)
GIVEUP ;
"RTN","HLOCLNT",174,0)
 I ('HLCSTATE("CONNECTED"))!('SUCCESS) D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",175,0)
 Q SUCCESS
"RTN","HLOCLNT1")
0^2^B27548481
"RTN","HLOCLNT1",1,0)
HLOCLNT1 ;IRMFO-ALB/CJM - Writing messages, reading acks;03/24/2004  14:43
"RTN","HLOCLNT1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130**;Oct 13, 1995;Build 10
"RTN","HLOCLNT1",3,0)
 ;
"RTN","HLOCLNT1",4,0)
 ;
"RTN","HLOCLNT1",5,0)
WRITEMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOCLNT1",6,0)
 ;Description:  This function uses the services offered by the transport layer to send a message over an open communication channel.
"RTN","HLOCLNT1",7,0)
 ;
"RTN","HLOCLNT1",8,0)
 ;Input:
"RTN","HLOCLNT1",9,0)
 ;  HLCSTATE (pass by reference, required) Defines the communication channel and its state.
"RTN","HLOCLNT1",10,0)
 ;  HLMSTATE (pass by reference, required) Defines the message and its state.
"RTN","HLOCLNT1",11,0)
 ;Output:
"RTN","HLOCLNT1",12,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT1",13,0)
 ;
"RTN","HLOCLNT1",14,0)
 N SEG,QUIT,HDR
"RTN","HLOCLNT1",15,0)
 S QUIT=0
"RTN","HLOCLNT1",16,0)
 Q:'$G(HLMSTATE("IEN")) 0
"RTN","HLOCLNT1",17,0)
 S HDR(1)=HLMSTATE("HDR",1),HDR(2)=HLMSTATE("HDR",2)
"RTN","HLOCLNT1",18,0)
 Q:'$$WRITEHDR^HLOT(.HLCSTATE,.HDR) 0
"RTN","HLOCLNT1",19,0)
 I HLMSTATE("BATCH") D
"RTN","HLOCLNT1",20,0)
 .N LAST S LAST=0
"RTN","HLOCLNT1",21,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0
"RTN","HLOCLNT1",22,0)
 .F  Q:'$$NEXTMSG^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",23,0)
 ..S LAST=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOCLNT1",24,0)
 ..I '$$WRITESEG^HLOT(.HLCSTATE,.SEG) S QUIT=1 Q
"RTN","HLOCLNT1",25,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",26,0)
 ...I '$$WRITESEG^HLOT(.HLCSTATE,.SEG) S QUIT=1 Q
"RTN","HLOCLNT1",27,0)
 .K SEG S SEG(1)="BTS"_HLMSTATE("HDR","FIELD SEPARATOR")_LAST
"RTN","HLOCLNT1",28,0)
 .S:'$$WRITESEG^HLOT(.HLCSTATE,.SEG) QUIT=1
"RTN","HLOCLNT1",29,0)
 E  D
"RTN","HLOCLNT1",30,0)
 .F  Q:'$$HLNEXT^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",31,0)
 ..S:'$$WRITESEG^HLOT(.HLCSTATE,.SEG) QUIT=1
"RTN","HLOCLNT1",32,0)
 S:'$$ENDMSG^HLOT(.HLCSTATE) QUIT=1
"RTN","HLOCLNT1",33,0)
 Q 'QUIT
"RTN","HLOCLNT1",34,0)
 ;
"RTN","HLOCLNT1",35,0)
READACK(HLCSTATE,HDR,MSA) ;
"RTN","HLOCLNT1",36,0)
 ;Description:  This function uses the services offered by the transport layer to read an accept ack.
"RTN","HLOCLNT1",37,0)
 ;
"RTN","HLOCLNT1",38,0)
 ;Input:
"RTN","HLOCLNT1",39,0)
 ;  HLCSTATE (pass by reference, required) Defines the communication channel and its state.
"RTN","HLOCLNT1",40,0)
 ;Output:
"RTN","HLOCLNT1",41,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT1",42,0)
 ;  HDR (pass by reference) the message header:
"RTN","HLOCLNT1",43,0)
 ;   HDR(1) is components 1-6
"RTN","HLOCLNT1",44,0)
 ;   HDR(2) is components 7-end
"RTN","HLOCLNT1",45,0)
 ;  MSA (pass by reference) the MSA segment as an unsubscripted variable
"RTN","HLOCLNT1",46,0)
 ;
"RTN","HLOCLNT1",47,0)
 N SEG
"RTN","HLOCLNT1",48,0)
 K HDR,MSA,MAX,I
"RTN","HLOCLNT1",49,0)
 S MAX=HLCSTATE("SYSTEM","MAXSTRING")-40 ;MAX is the maximum that can be safely stored on a node, leaving room for the other fields stored with MSA seg
"RTN","HLOCLNT1",50,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.HDR) 0
"RTN","HLOCLNT1",51,0)
 F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOCLNT1",52,0)
 .I $E($E(SEG(1),1,3)_$E($G(SEG(2)),1,3),1,3)="MSA" D
"RTN","HLOCLNT1",53,0)
 ..S MSA=""
"RTN","HLOCLNT1",54,0)
 ..F I=1:1 Q:'$D(SEG(I))  S MSA=MSA_$S((MAX-$L(MSA))<1:"",1:$E(SEG(I),1,MAX))
"RTN","HLOCLNT1",55,0)
 I $D(MSA),HLCSTATE("MESSAGE ENDED") D  Q 1
"RTN","HLOCLNT1",56,0)
 .D SPLITHDR^HLOSRVR1(.HDR)
"RTN","HLOCLNT1",57,0)
 .S HLCSTATE("COUNTS","ACKS")=$G(HLCSTATE("COUNTS","ACKS"))+1
"RTN","HLOCLNT1",58,0)
 Q 0
"RTN","HLOCLNT1",59,0)
 ;
"RTN","HLOCLNT1",60,0)
CONNECT(LINK,PORT,HLCSTATE) ;
"RTN","HLOCLNT1",61,0)
 ;sets up HLCSTATE() and opens a client connection
"RTN","HLOCLNT1",62,0)
 ;Input:
"RTN","HLOCLNT1",63,0)
 ;  LINK - name of the link to connect to
"RTN","HLOCLNT1",64,0)
 ;  PORT - port # to connect to (optional)
"RTN","HLOCLNT1",65,0)
 ;Output:
"RTN","HLOCLNT1",66,0)
 ;   HLCSTATE - array to hold the connection state
"RTN","HLOCLNT1",67,0)
 ;
"RTN","HLOCLNT1",68,0)
 I $G(HLCSTATE("CONNECTED")) D  Q:$G(HLCSTATE("CONNECTED"))
"RTN","HLOCLNT1",69,0)
 .I $G(HLCSTATE("LINK","NAME"))]"",($G(HLCSTATE("LINK","NAME"))'=LINK) D CLOSE^HLOT(.HLCSTATE) Q
"RTN","HLOCLNT1",70,0)
 .I $G(HLCSTATE("LINK","NAME"))]"",$G(PORT),($G(HLCSTATE("LINK","PORT"))'=PORT) D CLOSE^HLOT(.HLCSTATE) Q
"RTN","HLOCLNT1",71,0)
 .I (HLCSTATE("SYSTEM","OS")="CACHE") D  Q
"RTN","HLOCLNT1",72,0)
 ..S HLCSTATE("CONNECTED")=($ZA\8192#2)
"RTN","HLOCLNT1",73,0)
 ..I 'HLCSTATE("CONNECTED") D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",74,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",75,0)
 K HLCSTATE
"RTN","HLOCLNT1",76,0)
 N ARY,NODE
"RTN","HLOCLNT1",77,0)
 I '$$GETLINK^HLOTLNK(LINK,.ARY) S HLCSTATE("LINK","NAME")=LINK,HLCSTATE("LINK","PORT")=$G(PORT) D LINKDOWN^HLOCLNT(.HLCSTATE) Q 0
"RTN","HLOCLNT1",78,0)
 M HLCSTATE("LINK")=ARY
"RTN","HLOCLNT1",79,0)
 I HLCSTATE("LINK","SHUTDOWN") S HLCSTATE("CONNECTED")=0 D LINKDOWN^HLOCLNT(.HLCSTATE) Q 0
"RTN","HLOCLNT1",80,0)
 ;overlay the port if supplied from the queue
"RTN","HLOCLNT1",81,0)
 S:$G(PORT) HLCSTATE("LINK","PORT")=PORT
"RTN","HLOCLNT1",82,0)
 S HLCSTATE("ATTEMPT")=0
"RTN","HLOCLNT1",83,0)
 S HLCSTATE("COUNTS")=0
"RTN","HLOCLNT1",84,0)
 S HLCSTATE("READ")="" ;where the reads are stored
"RTN","HLOCLNT1",85,0)
 ;
"RTN","HLOCLNT1",86,0)
 ;HLCSTATE("BUFFER",<seg>,<line>) serves as a write buffer so that a lot can be written all at once
"RTN","HLOCLNT1",87,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of BYTES in buffer
"RTN","HLOCLNT1",88,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOCLNT1",89,0)
 ;
"RTN","HLOCLNT1",90,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOCLNT1",91,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOCLNT1",92,0)
 S HLCSTATE("SERVER")=0
"RTN","HLOCLNT1",93,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOCLNT1",94,0)
 I HLCSTATE("SYSTEM","OS")="" D LINKDOWN^HLOCLNT(.HLCSTATE) Q 0
"RTN","HLOCLNT1",95,0)
 D
"RTN","HLOCLNT1",96,0)
 .N SYS
"RTN","HLOCLNT1",97,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOCLNT1",98,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOCLNT1",99,0)
 .S HLCSTATE("SYSTEM","MAXSTRING")=SYS("MAXSTRING")
"RTN","HLOCLNT1",100,0)
 .S HLCSTATE("SYSTEM","NORMAL PURGE")=SYS("NORMAL PURGE")
"RTN","HLOCLNT1",101,0)
 .S HLCSTATE("SYSTEM","ERROR PURGE")=SYS("ERROR PURGE")
"RTN","HLOCLNT1",102,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOCLNT1",103,0)
 .D OPEN^HLOTCP(.HLCSTATE)
"RTN","HLOCLNT1",104,0)
 E  I HLCSTATE("LINK","LLP")="HLLP" D  ;serial
"RTN","HLOCLNT1",105,0)
 .;implementation of serial LLP has been deferred
"RTN","HLOCLNT1",106,0)
 ;
"RTN","HLOCLNT1",107,0)
 ;mark the failure time for the link so other processes know not to try for a while
"RTN","HLOCLNT1",108,0)
 I 'HLCSTATE("CONNECTED") D LINKDOWN^HLOCLNT(.HLCSTATE)
"RTN","HLOCLNT1",109,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOCLNT1",110,0)
 ;
"RTN","HLOCLNT1",111,0)
BADMSGS(WORK) ;
"RTN","HLOCLNT1",112,0)
 ;finds messages that won't transmit and takes them off the outgoing queue
"RTN","HLOCLNT1",113,0)
 N LINK
"RTN","HLOCLNT1",114,0)
 S LINK=""
"RTN","HLOCLNT1",115,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D
"RTN","HLOCLNT1",116,0)
 .N TIME,QUE,COUNT
"RTN","HLOCLNT1",117,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOCLNT1",118,0)
 .Q:$$HDIFF^XLFDT($H,TIME,2)<7200
"RTN","HLOCLNT1",119,0)
 .Q:'$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOCLNT1",120,0)
 .L +^HLB("QUEUE","OUT",LINK):0
"RTN","HLOCLNT1",121,0)
 .S QUE=""
"RTN","HLOCLNT1",122,0)
 .F  S QUE=$O(^HLB("QUEUE","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOCLNT1",123,0)
 ..N MSG S MSG=0
"RTN","HLOCLNT1",124,0)
 ..S MSG=$O(^HLB("QUEUE","OUT",LINK,QUE,MSG))
"RTN","HLOCLNT1",125,0)
 ..Q:'MSG
"RTN","HLOCLNT1",126,0)
 ..S COUNT=$G(^HLB(MSG,"TRIES"))
"RTN","HLOCLNT1",127,0)
 ..I COUNT>20 D
"RTN","HLOCLNT1",128,0)
 ...N NODE,TIME,APP,FS,ACTION
"RTN","HLOCLNT1",129,0)
 ...S NODE=$G(^HLB(MSG,0))
"RTN","HLOCLNT1",130,0)
 ...Q:'$P(NODE,"^",2)
"RTN","HLOCLNT1",131,0)
 ...S TIME=+$G(^HLA($P(NODE,"^",2),0))
"RTN","HLOCLNT1",132,0)
 ...S NODE=$G(^HLB(MSG,1))
"RTN","HLOCLNT1",133,0)
 ...S FS=$E(NODE,4)
"RTN","HLOCLNT1",134,0)
 ...Q:FS=""
"RTN","HLOCLNT1",135,0)
 ...S APP=$P(NODE,FS,3)
"RTN","HLOCLNT1",136,0)
 ...Q:APP=""
"RTN","HLOCLNT1",137,0)
 ...S $P(^HLB(MSG,0),"^",21)=COUNT_" FAILED TRANSMISSIONS"
"RTN","HLOCLNT1",138,0)
 ...S $P(^HLB(MSG,0),"^",20)="TF"
"RTN","HLOCLNT1",139,0)
 ...S ^HLB("ERRORS","TF",APP,TIME,MSG)=""
"RTN","HLOCLNT1",140,0)
 ...S ACTION=$P(NODE,"^",14,15)
"RTN","HLOCLNT1",141,0)
 ...I ACTION'="^",ACTION]"" D INQUE^HLOQUE(LINK,QUE,MSG,ACTION,1)
"RTN","HLOCLNT1",142,0)
 ...D DEQUE^HLOQUE(LINK,QUE,"OUT",MSG)
"RTN","HLOCLNT1",143,0)
 .L -^HLB("QUEUE","OUT",LINK)
"RTN","HLOCLNT1",144,0)
 Q
"RTN","HLOCLNT2")
0^3^B23345410
"RTN","HLOCLNT2",1,0)
HLOCLNT2 ;ALB/CJM- Performs message updates for the client - 10/4/94 1pm
"RTN","HLOCLNT2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130**;Oct 13, 1995;Build 10
"RTN","HLOCLNT2",3,0)
 ;
"RTN","HLOCLNT2",4,0)
GETWORK(WORK) ;
"RTN","HLOCLNT2",5,0)
 ;
"RTN","HLOCLNT2",6,0)
 N OLD,DOLLARJ,SUCCESS,NOW
"RTN","HLOCLNT2",7,0)
 S SUCCESS=0
"RTN","HLOCLNT2",8,0)
 S NOW=$$NOW^XLFDT
"RTN","HLOCLNT2",9,0)
 S (OLD,DOLLARJ)=$G(WORK("DOLLARJ"))
"RTN","HLOCLNT2",10,0)
 F  S DOLLARJ=$O(^HLTMP("CLIENT UPDATES",DOLLARJ)) Q:DOLLARJ=""  D  Q:SUCCESS
"RTN","HLOCLNT2",11,0)
 .L +^HLTMP("CLIENT UPDATES",DOLLARJ):0
"RTN","HLOCLNT2",12,0)
 .Q:'$T
"RTN","HLOCLNT2",13,0)
 .N TIME S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,""))
"RTN","HLOCLNT2",14,0)
 .I $$FMDIFF^XLFDT(NOW,TIME,2)<2 L -^HLTMP("CLIENT UPDATES",DOLLARJ) Q
"RTN","HLOCLNT2",15,0)
 .S SUCCESS=1
"RTN","HLOCLNT2",16,0)
 ;
"RTN","HLOCLNT2",17,0)
 I OLD'="",'SUCCESS F  S DOLLARJ=$O(^HLTMP("CLIENT UPDATES",DOLLARJ)) Q:DOLLARJ=""  Q:DOLLARJ>OLD  D  Q:SUCCESS
"RTN","HLOCLNT2",18,0)
 .L +^HLTMP("CLIENT UPDATES",DOLLARJ):0
"RTN","HLOCLNT2",19,0)
 .Q:'$T
"RTN","HLOCLNT2",20,0)
 .N TIME S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,""))
"RTN","HLOCLNT2",21,0)
 .I $$FMDIFF^XLFDT(NOW,TIME,2)<2 L -^HLTMP("CLIENT UPDATES",DOLLARJ) Q
"RTN","HLOCLNT2",22,0)
 .S SUCCESS=1
"RTN","HLOCLNT2",23,0)
 S WORK("DOLLARJ")=DOLLARJ,WORK("NOW")=NOW
"RTN","HLOCLNT2",24,0)
 Q $S($L(WORK("DOLLARJ")):1,1:0)
"RTN","HLOCLNT2",25,0)
 ;
"RTN","HLOCLNT2",26,0)
DOWORK(WORK) ;
"RTN","HLOCLNT2",27,0)
 ;
"RTN","HLOCLNT2",28,0)
 N DOLLARJ,TIME,IEN,PARMS,SYSTEM
"RTN","HLOCLNT2",29,0)
 S TIME=""
"RTN","HLOCLNT2",30,0)
 S DOLLARJ=WORK("DOLLARJ")
"RTN","HLOCLNT2",31,0)
 D SYSPARMS^HLOSITE(.SYSTEM)
"RTN","HLOCLNT2",32,0)
 F  S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME)) Q:TIME=""  Q:$$FMDIFF^XLFDT(WORK("NOW"),TIME,2)<2  D
"RTN","HLOCLNT2",33,0)
 .S IEN=0
"RTN","HLOCLNT2",34,0)
 .F  S IEN=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN)) Q:'IEN  D
"RTN","HLOCLNT2",35,0)
 ..N NODE
"RTN","HLOCLNT2",36,0)
 ..S NODE=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN))
"RTN","HLOCLNT2",37,0)
 ..S PARMS("LINK")=$P(NODE,"^")
"RTN","HLOCLNT2",38,0)
 ..S PARMS("QUEUE")=$P(NODE,"^",2)
"RTN","HLOCLNT2",39,0)
 ..S PARMS("STATUS")=$P(NODE,"^",3)
"RTN","HLOCLNT2",40,0)
 ..S PARMS("PURGE TYPE")=$P(NODE,"^",4)
"RTN","HLOCLNT2",41,0)
 ..S PARMS("ACCEPT ACK")=$P(NODE,"^",5)
"RTN","HLOCLNT2",42,0)
 ..S PARMS("RECEIVING APP")=$P(NODE,"^",6)
"RTN","HLOCLNT2",43,0)
 ..S:PARMS("RECEIVING APP")="" PARMS("RECEIVING APP")="UNKNOWN RECEIVING APPLICATION"
"RTN","HLOCLNT2",44,0)
 ..S PARMS("MSA")=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN,"MSA"))
"RTN","HLOCLNT2",45,0)
 ..S PARMS("ACTION")=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN,"ACTION"))
"RTN","HLOCLNT2",46,0)
 ..D UPDATE(IEN,TIME,.PARMS)
"RTN","HLOCLNT2",47,0)
 ..K ^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN)
"RTN","HLOCLNT2",48,0)
 L -^HLTMP("CLIENT UPDATES",DOLLARJ)
"RTN","HLOCLNT2",49,0)
 Q
"RTN","HLOCLNT2",50,0)
 ;
"RTN","HLOCLNT2",51,0)
UPDATE(MSGIEN,TIME,PARMS) ;
"RTN","HLOCLNT2",52,0)
 S:PARMS("STATUS")]"" $P(^HLB(MSGIEN,0),"^",20)=PARMS("STATUS")
"RTN","HLOCLNT2",53,0)
 S:PARMS("STATUS")="SE" ^HLB("ERRORS","SE",PARMS("RECEIVING APP"),TIME,MSGIEN)=""
"RTN","HLOCLNT2",54,0)
 S:PARMS("STATUS")="AE" ^HLB("ERRORS","AE",PARMS("RECEIVING APP"),TIME,MSGIEN_"^")=""
"RTN","HLOCLNT2",55,0)
 S:PARMS("ACCEPT ACK") $P(^HLB(MSGIEN,0),"^",17)=PARMS("ACCEPT ACK")
"RTN","HLOCLNT2",56,0)
 S $P(^HLB(MSGIEN,0),"^",16)=TIME
"RTN","HLOCLNT2",57,0)
 S:PARMS("MSA")]"" ^HLB(MSGIEN,4)=TIME_"^"_PARMS("MSA")
"RTN","HLOCLNT2",58,0)
 I PARMS("PURGE TYPE"),PARMS("ACTION")="" D
"RTN","HLOCLNT2",59,0)
 .;don't set purge if going on the infiler - let infiler do it
"RTN","HLOCLNT2",60,0)
 .N PTIME
"RTN","HLOCLNT2",61,0)
 .S:(PARMS("PURGE TYPE")=2) PTIME=$$FMADD^XLFDT(TIME,SYSTEM("ERROR PURGE")) ;error purge is in days
"RTN","HLOCLNT2",62,0)
 .S:(PARMS("PURGE TYPE")'=2) PTIME=$$FMADD^XLFDT(TIME,,SYSTEM("NORMAL PURGE")) ;normal purge is in hours
"RTN","HLOCLNT2",63,0)
 .S $P(^HLB(MSGIEN,0),"^",9)=PTIME,^HLB("AD","OUT",PTIME,MSGIEN)=""
"RTN","HLOCLNT2",64,0)
 D:PARMS("ACTION")]"" INQUE^HLOQUE(PARMS("LINK"),PARMS("QUEUE"),MSGIEN,PARMS("ACTION"),$S(PARMS("PURGE TYPE"):1,1:0))
"RTN","HLOCLNT2",65,0)
 Q
"RTN","HLOCLNT2",66,0)
 ;
"RTN","HLOCLNT2",67,0)
GETMSG(IEN,MSG) ;
"RTN","HLOCLNT2",68,0)
 ;
"RTN","HLOCLNT2",69,0)
 ;Description: given the message ien=MSGIEN (required), it returns the MSG array containing information about the message, defined below.
"RTN","HLOCLNT2",70,0)
 ;Input:
"RTN","HLOCLNT2",71,0)
 ;  IEN - the ien of the message in file 778
"RTN","HLOCLNT2",72,0)
 ;Output:
"RTN","HLOCLNT2",73,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT2",74,0)
 ;  MSG (pass by reference, required) These are the subscripts returned:
"RTN","HLOCLNT2",75,0)
 ;    "BATCH"  = 1 if this is a batch message, 0  if not
"RTN","HLOCLNT2",76,0)
 ; "CURRENT MESSAGE" - defined only for batch messages -  a counterused during building and parsing messages to indicate the current message.  It will be set to 0 initially.
"RTN","HLOCLNT2",77,0)
 ;   "BODY" - ptr to file 778 which contains the body of the message.
"RTN","HLOCLNT2",78,0)
 ;   "ACCEPT ACK RESPONSE" - if the sending app requested notification of the accept ack, this is the routine to perform
"RTN","HLOCLNT2",79,0)
 ;   "LINE COUNT" -  a counter used during writing of the
"RTN","HLOCLNT2",80,0)
 ;     messages to indicate the current line. For
"RTN","HLOCLNT2",81,0)
 ;     batch messages where each message within the batch is stored
"RTN","HLOCLNT2",82,0)
 ;     separately, this field indicates the position within the current
"RTN","HLOCLNT2",83,0)
 ;     individual message
"RTN","HLOCLNT2",84,0)
 ;   "HDR" at these lower subscripts:
"RTN","HLOCLNT2",85,0)
 ; 1    - components 1-6
"RTN","HLOCLNT2",86,0)
 ; 2    - components 7-end
"RTN","HLOCLNT2",87,0)
 ; "ACCEPT ACK TYPE" = "AL" or "NE"
"RTN","HLOCLNT2",88,0)
 ; "APP ACK TYPE" = "AL" or "NE"
"RTN","HLOCLNT2",89,0)
 ; "MESSAGE CONTROL ID" - defined if NOT batch
"RTN","HLOCLNT2",90,0)
 ; "BATCH CONTROL ID" - defined if batch
"RTN","HLOCLNT2",91,0)
 ;
"RTN","HLOCLNT2",92,0)
 ;
"RTN","HLOCLNT2",93,0)
 ;   "IEN" - ien, file 778
"RTN","HLOCLNT2",94,0)
 ;
"RTN","HLOCLNT2",95,0)
 K MSG
"RTN","HLOCLNT2",96,0)
 Q:'$G(IEN) 0
"RTN","HLOCLNT2",97,0)
 N NODE,FS,CS
"RTN","HLOCLNT2",98,0)
 S MSG("IEN")=IEN
"RTN","HLOCLNT2",99,0)
 S NODE=$G(^HLB(IEN,0))
"RTN","HLOCLNT2",100,0)
 S MSG("BODY")=$P(NODE,"^",2)
"RTN","HLOCLNT2",101,0)
 Q:'MSG("BODY") 0
"RTN","HLOCLNT2",102,0)
 S MSG("STATUS","ACCEPTED")=$P(NODE,"^",17)
"RTN","HLOCLNT2",103,0)
 S MSG("DT/TM")=$P(NODE,"^",16)
"RTN","HLOCLNT2",104,0)
 S MSG("STATUS","QUEUE")=$P(NODE,"^",6)
"RTN","HLOCLNT2",105,0)
 I MSG("STATUS","QUEUE")="" S MSG("STATUS","QUEUE")="DEFAULT"
"RTN","HLOCLNT2",106,0)
 S MSG("ACCEPT ACK RESPONSE")=$P(NODE,"^",12,13)
"RTN","HLOCLNT2",107,0)
 I MSG("ACCEPT ACK RESPONSE")="^" S MSG("ACCEPT ACK RESPONSE")=""
"RTN","HLOCLNT2",108,0)
 ;
"RTN","HLOCLNT2",109,0)
 S MSG("BATCH")=+$P($G(^HLA(MSG("BODY"),0)),"^",2)
"RTN","HLOCLNT2",110,0)
 I MSG("BATCH") S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOCLNT2",111,0)
 S MSG("LINE COUNT")=0
"RTN","HLOCLNT2",112,0)
 S MSG("HDR",1)=$G(^HLB(IEN,1))
"RTN","HLOCLNT2",113,0)
 S MSG("HDR",2)=$G(^HLB(IEN,2))
"RTN","HLOCLNT2",114,0)
 S FS=$E(MSG("HDR",1),4)
"RTN","HLOCLNT2",115,0)
 S CS=$E(MSG("HDR",1),5)
"RTN","HLOCLNT2",116,0)
 S MSG("HDR","FIELD SEPARATOR")=FS
"RTN","HLOCLNT2",117,0)
 S MSG("HDR","SENDING APPLICATION")=$P($P(MSG("HDR",1),FS,3),CS)
"RTN","HLOCLNT2",118,0)
 S MSG("HDR","RECEIVING APPLICATION")=$P($P(MSG("HDR",1),FS,5),CS)
"RTN","HLOCLNT2",119,0)
 I 'MSG("BATCH") D
"RTN","HLOCLNT2",120,0)
 .S MSG("HDR","MESSAGE TYPE")=$P($P(MSG("HDR",2),FS,4),CS)
"RTN","HLOCLNT2",121,0)
 .S MSG("HDR","EVENT")=$P($P(MSG("HDR",2),FS,4),CS,2)
"RTN","HLOCLNT2",122,0)
 .S MSG("HDR","ACCEPT ACK TYPE")=$E($P(MSG("HDR",2),FS,10),1,2)
"RTN","HLOCLNT2",123,0)
 .S MSG("HDR","APP ACK TYPE")=$E($P(MSG("HDR",2),FS,11),1,2)
"RTN","HLOCLNT2",124,0)
 .S MSG("HDR","MESSAGE CONTROL ID")=$P(MSG("HDR",2),FS,5)
"RTN","HLOCLNT2",125,0)
 E  D
"RTN","HLOCLNT2",126,0)
 .S MSG("HDR","BATCH CONTROL ID")=$P(MSG("HDR",2),FS,6)
"RTN","HLOCLNT2",127,0)
 .S MSG("HDR","ACCEPT ACK TYPE")=$E($P($P(MSG("HDR",2),FS,4),"ACCEPT ACK TYPE=",2),1,2)
"RTN","HLOCLNT2",128,0)
 .S MSG("HDR","APP ACK TYPE")=$E($P($P(MSG("HDR",2),FS,4),"APP ACK TYPE=",2),1,2)
"RTN","HLOCLNT2",129,0)
 Q 1
"RTN","HLOSRVR")
0^4^B70554107
"RTN","HLOSRVR",1,0)
HLOSRVR ;ALB/CJM- Server for receiving messages - 10/4/94 1pm
"RTN","HLOSRVR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130**;Oct 13, 1995;Build 10
"RTN","HLOSRVR",3,0)
 ;
"RTN","HLOSRVR",4,0)
GETWORK(WORK) ;
"RTN","HLOSRVR",5,0)
 ;GET WORK function for a single server OR Taskman multi-server
"RTN","HLOSRVR",6,0)
 N LINK
"RTN","HLOSRVR",7,0)
 I '$$CHKSTOP^HLOPROC,$G(WORK("LINK"))]"",$$GETLINK^HLOTLNK(WORK("LINK"),.LINK),+LINK("SERVER") S WORK("PORT")=LINK("PORT") Q 1
"RTN","HLOSRVR",8,0)
 Q 0
"RTN","HLOSRVR",9,0)
 ;
"RTN","HLOSRVR",10,0)
DOWORKS(WORK) ;
"RTN","HLOSRVR",11,0)
 ;DO WORK rtn for a single server (non-concurrent)
"RTN","HLOSRVR",12,0)
 D SERVER(WORK("LINK"))
"RTN","HLOSRVR",13,0)
 Q
"RTN","HLOSRVR",14,0)
DOWORKM(WORK) ;
"RTN","HLOSRVR",15,0)
 ;DO WORK rtn for a Taskman multi-server (Cache systems only)
"RTN","HLOSRVR",16,0)
 D LISTEN^%ZISTCPS(WORK("PORT"),"SERVER^HLOSRVR("""_WORK("LINK")_""")")
"RTN","HLOSRVR",17,0)
 Q
"RTN","HLOSRVR",18,0)
 ;
"RTN","HLOSRVR",19,0)
VMS ;called from VMS TCP Service once a connection request has been received
"RTN","HLOSRVR",20,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",21,0)
 N LINKNAME,PROC
"RTN","HLOSRVR",22,0)
 S PROC=$O(^HLD(779.3,"B","VMS TCP LISTENER",0))
"RTN","HLOSRVR",23,0)
 I 'PROC D ^%ZTER Q
"RTN","HLOSRVR",24,0)
 S LINKNAME=$P($G(^HLD(779.3,PROC,0)),"^",14)
"RTN","HLOSRVR",25,0)
 I $G(LINKNAME)="" D ^%ZTER Q
"RTN","HLOSRVR",26,0)
 D SERVER(LINKNAME,"SYS$NET")
"RTN","HLOSRVR",27,0)
 Q
"RTN","HLOSRVR",28,0)
 ;
"RTN","HLOSRVR",29,0)
SERVER(LINKNAME,LOGICAL) ; LINKNAME identifies the logical link, which describes the communication channel to be used
"RTN","HLOSRVR",30,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOSRVR1"
"RTN","HLOSRVR",31,0)
 N HLCSTATE,INQUE
"RTN","HLOSRVR",32,0)
 S INQUE=0
"RTN","HLOSRVR",33,0)
 Q:'$$CONNECT(.HLCSTATE,LINKNAME,.LOGICAL)
"RTN","HLOSRVR",34,0)
 K LINKNAME
"RTN","HLOSRVR",35,0)
 F  Q:'HLCSTATE("CONNECTED")  D  Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",36,0)
 .N HLMSTATE,SENT
"RTN","HLOSRVR",37,0)
 .I $$READMSG^HLOSRVR1(.HLCSTATE,.HLMSTATE) D
"RTN","HLOSRVR",38,0)
 ..;$$READMSG also parses the hdr and determines what to do - HLMSTATE("MSA",1) is the ack to return= <"","CA","CE","CR","AE">
"RTN","HLOSRVR",39,0)
 ..;send an ack if required and save the MSA segment
"RTN","HLOSRVR",40,0)
 ..I (HLMSTATE("MSA",1)]"") S SENT=$$WRITEACK(.HLCSTATE,.HLMSTATE) D:HLMSTATE("IEN") SAVEACK(.HLMSTATE,SENT)
"RTN","HLOSRVR",41,0)
 ..D:HLMSTATE("IEN") UPDATE(.HLMSTATE,.HLCSTATE)
"RTN","HLOSRVR",42,0)
 ..D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",43,0)
 .E  D INQUE() H 1
"RTN","HLOSRVR",44,0)
 ;
"RTN","HLOSRVR",45,0)
END D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR",46,0)
 D INQUE()
"RTN","HLOSRVR",47,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",48,0)
 Q
"RTN","HLOSRVR",49,0)
 ;
"RTN","HLOSRVR",50,0)
CONNECT(HLCSTATE,LINKNAME,LOGICAL) ;
"RTN","HLOSRVR",51,0)
 ;sets up HLCSTATE() and opens a server connection
"RTN","HLOSRVR",52,0)
 ;
"RTN","HLOSRVR",53,0)
 N LINK,NODE
"RTN","HLOSRVR",54,0)
 Q:'$$GETLINK^HLOTLNK(LINKNAME,.LINK) 0
"RTN","HLOSRVR",55,0)
 Q:+LINK("SERVER")'=1 0
"RTN","HLOSRVR",56,0)
 S HLCSTATE("SERVER")=LINK("SERVER")
"RTN","HLOSRVR",57,0)
 M HLCSTATE("LINK")=LINK
"RTN","HLOSRVR",58,0)
 S HLCSTATE("ATTEMPT")=1 ;count of #of read attempts, incremented if a message hdr is read but the read fails before the end
"RTN","HLOSRVR",59,0)
 S HLCSTATE("READ")="" ;where the reads are stored
"RTN","HLOSRVR",60,0)
 ;
"RTN","HLOSRVR",61,0)
 ;HLCSTATE("BUFFER",<seg>,<line>) serves as a write buffer so that a lot can be written all at once
"RTN","HLOSRVR",62,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of BYTES in buffer
"RTN","HLOSRVR",63,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOSRVR",64,0)
 ;
"RTN","HLOSRVR",65,0)
 S HLCSTATE("COUNTS")=0
"RTN","HLOSRVR",66,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOSRVR",67,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOSRVR",68,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOSRVR",69,0)
 Q:HLCSTATE("SYSTEM","OS")="" 0
"RTN","HLOSRVR",70,0)
 D  ;get necessary system parameters
"RTN","HLOSRVR",71,0)
 .N SYS,SUB
"RTN","HLOSRVR",72,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOSRVR",73,0)
 .F SUB="MAXSTRING","DOMAIN","STATION","PROCESSING ID","NORMAL PURGE","ERROR PURGE" S HLCSTATE("SYSTEM",SUB)=SYS(SUB)
"RTN","HLOSRVR",74,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOSRVR",75,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOSRVR",76,0)
 .D OPEN^HLOTCP(.HLCSTATE,.LOGICAL)
"RTN","HLOSRVR",77,0)
 ;E  I HLCSTATE("LINK","LLP")="HLLP" D  ;serial
"RTN","HLOSRVR",78,0)
 ;.;serial connections are deferred for later development
"RTN","HLOSRVR",79,0)
 ;
"RTN","HLOSRVR",80,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOSRVR",81,0)
 ;
"RTN","HLOSRVR",82,0)
INQUE(MSGIEN,PARMS) ;
"RTN","HLOSRVR",83,0)
 ;puts received messages on the incoming queue and sets the B x-refs
"RTN","HLOSRVR",84,0)
 I $G(MSGIEN) S INQUE=INQUE+1 M INQUE(MSGIEN)=PARMS
"RTN","HLOSRVR",85,0)
 I ('$G(MSGIEN))!(INQUE>20) S MSGIEN=0 D
"RTN","HLOSRVR",86,0)
 .F  S MSGIEN=$O(INQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOSRVR",87,0)
 ..S ^HLB("B",INQUE(MSGIEN,"MSGID"),MSGIEN)=""
"RTN","HLOSRVR",88,0)
 ..S ^HLA("B",INQUE(MSGIEN,"DT/TM"),INQUE(MSGIEN,"BODY"))=""
"RTN","HLOSRVR",89,0)
 ..D:INQUE(MSGIEN,"PASS")
"RTN","HLOSRVR",90,0)
 ...N PURGE
"RTN","HLOSRVR",91,0)
 ...S PURGE=+$G(INQUE(MSGIEN,"PURGE"))
"RTN","HLOSRVR",92,0)
 ...S PURGE("ACKTOIEN")=$G(INQUE(MSGIEN,"ACKTOIEN"))
"RTN","HLOSRVR",93,0)
 ...D INQUE^HLOQUE(INQUE(MSGIEN,"FROM"),INQUE(MSGIEN,"QUEUE"),MSGIEN,INQUE(MSGIEN,"ACTION"),.PURGE)
"RTN","HLOSRVR",94,0)
 .K INQUE S INQUE=0
"RTN","HLOSRVR",95,0)
 Q
"RTN","HLOSRVR",96,0)
 ;
"RTN","HLOSRVR",97,0)
SAVEACK(HLMSTATE,SENT) ;
"RTN","HLOSRVR",98,0)
 ;Input:
"RTN","HLOSRVR",99,0)
 ;  SENT - flag = 1 if transmission of ack succeeded, 0 otherwise
"RTN","HLOSRVR",100,0)
 ;
"RTN","HLOSRVR",101,0)
 N NODE,I
"RTN","HLOSRVR",102,0)
 S $P(NODE,"^")=HLMSTATE("MSA","DT/TM OF MESSAGE")
"RTN","HLOSRVR",103,0)
 S $P(NODE,"^",2)=HLMSTATE("MSA","MESSAGE CONTROL ID")
"RTN","HLOSRVR",104,0)
 S $P(NODE,"^",3)="MSA"
"RTN","HLOSRVR",105,0)
 F I=1:1:3 S NODE=NODE_"|"_$G(HLMSTATE("MSA",I))
"RTN","HLOSRVR",106,0)
 S ^HLB(HLMSTATE("IEN"),4)=NODE
"RTN","HLOSRVR",107,0)
 S:SENT $P(^HLB(HLMSTATE("IEN"),0),"^",$S($E(HLMSTATE("MSA",1))="A":18,1:17))=1
"RTN","HLOSRVR",108,0)
 Q
"RTN","HLOSRVR",109,0)
 ;
"RTN","HLOSRVR",110,0)
UPDATE(HLMSTATE,HLCSTATE) ;
"RTN","HLOSRVR",111,0)
 ;Updates status and purge date when appropriate
"RTN","HLOSRVR",112,0)
 ;Also, sets the "B" xrefs, files 777,778, and places message on the incoming queue
"RTN","HLOSRVR",113,0)
 ;
"RTN","HLOSRVR",114,0)
 N PARMS,PURGE,WAIT
"RTN","HLOSRVR",115,0)
 S PARMS("PASS")=0
"RTN","HLOSRVR",116,0)
 I HLMSTATE("STATUS","ACTION")]"",HLMSTATE("STATUS")'="SE" S PARMS("PASS")=1,$P(^HLB(HLMSTATE("IEN"),0),"^",6)=HLMSTATE("STATUS","QUEUE")
"RTN","HLOSRVR",117,0)
 D:'PARMS("PASS")  ;if not passing to the app, set the purge date
"RTN","HLOSRVR",118,0)
 .I HLMSTATE("STATUS")="" S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",119,0)
 .S:HLMSTATE("BATCH") WAIT=HLCSTATE("SYSTEM","ERROR PURGE")
"RTN","HLOSRVR",120,0)
 .S:'HLMSTATE("BATCH") WAIT=$S(HLMSTATE("STATUS")="SE":24*HLCSTATE("SYSTEM","ERROR PURGE"),1:HLCSTATE("SYSTEM","NORMAL PURGE"))
"RTN","HLOSRVR",121,0)
 .S PURGE=$$FMADD^XLFDT($$NOW^XLFDT,,WAIT)
"RTN","HLOSRVR",122,0)
 .S $P(^HLB(HLMSTATE("IEN"),0),"^",9)=PURGE
"RTN","HLOSRVR",123,0)
 .S ^HLB("AD","IN",PURGE,HLMSTATE("IEN"))=""
"RTN","HLOSRVR",124,0)
 ;
"RTN","HLOSRVR",125,0)
 ;if not waiting for an application ack, set the status now even if passing to the app - but don't set the purge until the infiler passes the message
"RTN","HLOSRVR",126,0)
 I HLMSTATE("STATUS")="",HLMSTATE("HDR","APP ACK TYPE")'="AL" S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",127,0)
 I HLMSTATE("STATUS")'="" S $P(^HLB(HLMSTATE("IEN"),0),"^",20)=HLMSTATE("STATUS") S:$G(HLMSTATE("MSA",3))]"" $P(^HLB(HLMSTATE("IEN"),0),"^",21)=HLMSTATE("MSA",3) D:HLMSTATE("STATUS")="SE"
"RTN","HLOSRVR",128,0)
 .N APP
"RTN","HLOSRVR",129,0)
 .S APP=HLMSTATE("HDR","RECEIVING APPLICATION") S:APP="" APP="UNKNOWN" S ^HLB("ERRORS","SE",APP,HLMSTATE("DT/TM"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR",130,0)
 ;
"RTN","HLOSRVR",131,0)
 ;set the necessary parms for passing the msg to the app via the infiler
"RTN","HLOSRVR",132,0)
 D:PARMS("PASS")
"RTN","HLOSRVR",133,0)
 .N I,FROM
"RTN","HLOSRVR",134,0)
 .S FROM=HLMSTATE("HDR","SENDING FACILITY",1)
"RTN","HLOSRVR",135,0)
 .I HLMSTATE("HDR","SENDING FACILITY",2)]"" S FROM=FROM_"~"_HLMSTATE("HDR","SENDING FACILITY",2)_"~"_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",136,0)
 .I FROM="" S FROM="UNKNOWN SENDING FACILITY"
"RTN","HLOSRVR",137,0)
 .S PARMS("FROM")=FROM,PARMS("QUEUE")=HLMSTATE("STATUS","QUEUE"),PARMS("ACTION")=HLMSTATE("STATUS","ACTION")
"RTN","HLOSRVR",138,0)
 .I HLMSTATE("STATUS")'="" S PARMS("PURGE")=1
"RTN","HLOSRVR",139,0)
 .S:$G(HLMSTATE("ACK TO","IEN")) PARMS("ACKTOIEN")=HLMSTATE("ACK TO","IEN") ;to insure that the infiler will know to set the purge date at the same time as the initial message
"RTN","HLOSRVR",140,0)
 ;
"RTN","HLOSRVR",141,0)
 S PARMS("BODY")=HLMSTATE("BODY")
"RTN","HLOSRVR",142,0)
 S PARMS("DT/TM")=HLMSTATE("DT/TM")
"RTN","HLOSRVR",143,0)
 S PARMS("MSGID")=$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOSRVR",144,0)
 D INQUE(HLMSTATE("IEN"),.PARMS)
"RTN","HLOSRVR",145,0)
 Q
"RTN","HLOSRVR",146,0)
 ;
"RTN","HLOSRVR",147,0)
WRITEACK(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR",148,0)
 ;Sends an accept ack
"RTN","HLOSRVR",149,0)
 ;
"RTN","HLOSRVR",150,0)
 ;Input:
"RTN","HLOSRVR",151,0)
 ;  HLCSTATE (pass by reference) defines the communication channel
"RTN","HLOSRVR",152,0)
 ;  HLMSTATE (pass by reference) the message being acked
"RTN","HLOSRVR",153,0)
 ;     ("MSA",1) - value to put in MSA-1
"RTN","HLOSRVR",154,0)
 ;     ("MSA",2) - value to put in MSA-2
"RTN","HLOSRVR",155,0)
 ;     ("MSA",3) - value to put in MSA-3
"RTN","HLOSRVR",156,0)
 ;     ("HDR") - parsed values for the message being ack'd
"RTN","HLOSRVR",157,0)
 ;Output:
"RTN","HLOSRVR",158,0)
 ;  Function returns 1 if successful, 0 otherwise
"RTN","HLOSRVR",159,0)
 ;  HLMSTATE("MSA","MESSAGE CONTROL ID") - the msg id of the ack
"RTN","HLOSRVR",160,0)
 ;  HLMSTATE(,"MSA","DT/TM OF MESSAGE") - from the ack header
"RTN","HLOSRVR",161,0)
 ;
"RTN","HLOSRVR",162,0)
 N HDR,SUB,FS,CS,MSA,ACKID,TIME
"RTN","HLOSRVR",163,0)
 ;for simplicity, hard-code the delimiters, the standard requires that the receiving system accept the delimiters listed in the header
"RTN","HLOSRVR",164,0)
 S FS="|"
"RTN","HLOSRVR",165,0)
 S CS="^"
"RTN","HLOSRVR",166,0)
 S TIME=$$NOW^XLFDT
"RTN","HLOSRVR",167,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=TIME
"RTN","HLOSRVR",168,0)
 S ACKID=HLCSTATE("SYSTEM","STATION")_" "_$$NEWIEN^HLOF778A("OUT")
"RTN","HLOSRVR",169,0)
 S HLMSTATE("MSA","MESSAGE CONTROL ID")=ACKID
"RTN","HLOSRVR",170,0)
 ;
"RTN","HLOSRVR",171,0)
 S HDR(1)="MSH"_FS_"^~\&"_FS_HLMSTATE("HDR","RECEIVING APPLICATION")_FS_HLCSTATE("SYSTEM","STATION")_CS_HLCSTATE("SYSTEM","DOMAIN")_CS_"DNS"_FS
"RTN","HLOSRVR",172,0)
 S HDR(1)=HDR(1)_HLMSTATE("HDR","SENDING APPLICATION")_FS_HLMSTATE("HDR","SENDING FACILITY",1)_CS_HLMSTATE("HDR","SENDING FACILITY",2)_CS_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",173,0)
 ;
"RTN","HLOSRVR",174,0)
 S HDR(2)=FS_$$HLDATE^HLFNC(TIME,"TS")_FS_FS_"ACK"_FS_ACKID_FS_HLMSTATE("HDR","PROCESSING ID")_FS_"2.4"_FS_FS_FS_"NE"_FS_"NE"
"RTN","HLOSRVR",175,0)
 ;
"RTN","HLOSRVR",176,0)
 S MSA(1)="MSA"_FS
"RTN","HLOSRVR",177,0)
 F SUB=1:1:3 S MSA(1)=MSA(1)_HLMSTATE("MSA",SUB)_FS
"RTN","HLOSRVR",178,0)
 I $$WRITEHDR^HLOT(.HLCSTATE,.HDR),$$WRITESEG^HLOT(.HLCSTATE,.MSA),$$ENDMSG^HLOT(.HLCSTATE) S HLCSTATE("COUNTS","ACKS")=$G(HLCSTATE("COUNTS","ACKS"))+1 Q 1
"RTN","HLOSRVR",179,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=""
"RTN","HLOSRVR",180,0)
 Q 0
"RTN","HLOSRVR",181,0)
 ;
"RTN","HLOSRVR",182,0)
NEWSTATE(HLCSTATE,HLMSTATE,HDR,MSA) ;
"RTN","HLOSRVR",183,0)
 ;Inputs:
"RTN","HLOSRVR",184,0)
 ;  HLCSTATE (pass by reference)
"RTN","HLOSRVR",185,0)
 ;  HDR (pass by reference) parsed header
"RTN","HLOSRVR",186,0)
 ;  MSA - (pass by reference) the values to return in the accept ack
"RTN","HLOSRVR",187,0)
 ;Output:
"RTN","HLOSRVR",188,0)
 ;  HLMSTATE (pass by reference)
"RTN","HLOSRVR",189,0)
 ;
"RTN","HLOSRVR",190,0)
 ;initialize the HLMSTATE array with the header, in preparation for reading the rest of the message
"RTN","HLOSRVR",191,0)
 S HLMSTATE("IEN")=""
"RTN","HLOSRVR",192,0)
 S HLMSTATE("BODY")=""
"RTN","HLOSRVR",193,0)
 S HLMSTATE("DIRECTION")="IN"
"RTN","HLOSRVR",194,0)
 S HLMSTATE("CURRENT SEGMENT")=0 ;no segments in cache
"RTN","HLOSRVR",195,0)
 S HLMSTATE("UNSTORED LINES")=1 ;just the header in cache so far
"RTN","HLOSRVR",196,0)
 S HLMSTATE("LINE COUNT")=0 ;no lines within message stored to disk
"RTN","HLOSRVR",197,0)
 I HDR("SEGMENT TYPE")="BHS" D
"RTN","HLOSRVR",198,0)
 .S HLMSTATE("BATCH")=1
"RTN","HLOSRVR",199,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0 ;no messages in batch
"RTN","HLOSRVR",200,0)
 .S HLMSTATE("UNSTORED MSH")=0
"RTN","HLOSRVR",201,0)
 E  S HLMSTATE("BATCH")=0
"RTN","HLOSRVR",202,0)
 M HLMSTATE("HDR")=HDR
"RTN","HLOSRVR",203,0)
 M HLMSTATE("MSA")=MSA
"RTN","HLOSRVR",204,0)
 S HLMSTATE("STATUS")=""
"RTN","HLOSRVR",205,0)
 M HLMSTATE("SYSTEM")=HLCSTATE("SYSTEM")
"RTN","HLOSRVR",206,0)
 S HLMSTATE("STATUS","LINK NAME")=HLCSTATE("LINK","NAME")
"RTN","HLOSRVR",207,0)
 S HLMSTATE("STATUS","PORT")=$P(HDR("SENDING FACILITY",2),":",2)
"RTN","HLOSRVR",208,0)
 ;
"RTN","HLOSRVR",209,0)
 ;if this is a batch, and it references another batch, assume it is a batch of application acks.  That is the only time HLO uses that field.
"RTN","HLOSRVR",210,0)
 I HLMSTATE("BATCH"),HLMSTATE("HDR","REFERENCE BATCH CONTROL ID")]"" D
"RTN","HLOSRVR",211,0)
 .N IEN
"RTN","HLOSRVR",212,0)
 .S HLMSTATE("ACK TO")=HLMSTATE("HDR","REFERENCE BATCH CONTROL ID")
"RTN","HLOSRVR",213,0)
 .S HLMSTATE("ACK TO","STATUS")="SU"
"RTN","HLOSRVR",214,0)
 .S IEN=$O(^HLB("B",HLMSTATE("HDR","REFERENCE BATCH CONTROL ID"),0))
"RTN","HLOSRVR",215,0)
 .I IEN S HLMSTATE("ACK TO","IEN")=IEN_"^"
"RTN","HLOSRVR",216,0)
 E  S HLMSTATE("ACK TO")=""
"RTN","HLOSRVR",217,0)
 Q
"RTN","HLOSRVR1")
0^5^B65124218
"RTN","HLOSRVR1",1,0)
HLOSRVR1 ;IRMFO-ALB/CJM - Reading messages, sending acks;03/24/2004  14:43
"RTN","HLOSRVR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130**;Oct 13, 1995;Build 10
"RTN","HLOSRVR1",3,0)
 ;
"RTN","HLOSRVR1",4,0)
READMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR1",5,0)
 ;This function uses the services provided by the transport layer to receive a message.  The header is parsed. Does these checks:
"RTN","HLOSRVR1",6,0)
 ; 1) Duplicate?
"RTN","HLOSRVR1",7,0)
 ; 2) Wrong Receiving Facility?
"RTN","HLOSRVR1",8,0)
 ; 3) Can the Receiving App accept this message, based on type of message & event?
"RTN","HLOSRVR1",9,0)
 ; 4) Processing ID must match the receiving system
"RTN","HLOSRVR1",10,0)
 ; 5) Must have a control ID
"RTN","HLOSRVR1",11,0)
 ; 6) Header must be BHS or MSH
"RTN","HLOSRVR1",12,0)
 ;
"RTN","HLOSRVR1",13,0)
 ;Output:
"RTN","HLOSRVR1",14,0)
 ;  Function returns 1 if the message was read fully, 0 otherwise
"RTN","HLOSRVR1",15,0)
 ;  HLMSTATE (pass by reference) the message.  It will include the fields for the return ack in HLMSTATE("MSA")
"RTN","HLOSRVR1",16,0)
 ;
"RTN","HLOSRVR1",17,0)
 N ACK,SEG,STORE,MSA,I
"RTN","HLOSRVR1",18,0)
 F I=1:1:3 S MSA(I)=""
"RTN","HLOSRVR1",19,0)
 ;
"RTN","HLOSRVR1",20,0)
 S STORE=1
"RTN","HLOSRVR1",21,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.SEG) 0
"RTN","HLOSRVR1",22,0)
 D SPLITHDR(.SEG)
"RTN","HLOSRVR1",23,0)
 S:'$$PARSEHDR^HLOPRS(.SEG) STORE=0
"RTN","HLOSRVR1",24,0)
 I STORE S MSA(2)=$S(SEG("SEGMENT TYPE")="BHS":SEG("BATCH CONTROL ID"),1:SEG("MESSAGE CONTROL ID")) I MSA(2)="" S STORE=0 I SEG("ACCEPT ACK TYPE")="AL" S MSA(1)="CE",MSA("3")="CONTROL ID MISSING"
"RTN","HLOSRVR1",25,0)
 I STORE,$$DUP(.SEG,.MSA) S STORE=0 ;$$DUP returns the prior MSA segment if this message is a duplicate
"RTN","HLOSRVR1",26,0)
 D NEWSTATE^HLOSRVR(.HLCSTATE,.HLMSTATE,.SEG,.MSA)
"RTN","HLOSRVR1",27,0)
 ;
"RTN","HLOSRVR1",28,0)
 ;if the message is not to be stored, just read it and discard the segments
"RTN","HLOSRVR1",29,0)
 I 'STORE D
"RTN","HLOSRVR1",30,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)
"RTN","HLOSRVR1",31,0)
 ;
"RTN","HLOSRVR1",32,0)
 ;else the message is to be stored
"RTN","HLOSRVR1",33,0)
 E  D
"RTN","HLOSRVR1",34,0)
 .N FS
"RTN","HLOSRVR1",35,0)
 .S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOSRVR1",36,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOSRVR1",37,0)
 ..N MSA,SEGTYPE,OLDMSGID,CODE,IEN,NEWMSGID
"RTN","HLOSRVR1",38,0)
 ..S SEGTYPE=$E($E(SEG(1),1,3)_$E($G(SEG(2)),1,2),1,3)
"RTN","HLOSRVR1",39,0)
 ..I SEGTYPE="MSA" D
"RTN","HLOSRVR1",40,0)
 ...S MSA=SEG(1)_$G(SEG(2))_$G(SEG(3))
"RTN","HLOSRVR1",41,0)
 ...S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2)
"RTN","HLOSRVR1",42,0)
 ...I $E(CODE,1)'="A" S SEGTYPE="" Q
"RTN","HLOSRVR1",43,0)
 ...S:$P(OLDMSGID,"-")]"" IEN=$O(^HLB("B",$P(OLDMSGID,"-"),0))
"RTN","HLOSRVR1",44,0)
 ...S:$G(IEN) IEN=IEN_"^"_$P(OLDMSGID,"-",2)
"RTN","HLOSRVR1",45,0)
 ..I 'HLMSTATE("BATCH") D
"RTN","HLOSRVR1",46,0)
 ...D:SEGTYPE="MSA"
"RTN","HLOSRVR1",47,0)
 ....S HLMSTATE("ACK TO")=OLDMSGID
"RTN","HLOSRVR1",48,0)
 ....S HLMSTATE("ACK TO","ACK BY")=HLMSTATE("HDR","MESSAGE CONTROL ID")
"RTN","HLOSRVR1",49,0)
 ....S HLMSTATE("ACK TO","STATUS")=$S(CODE="AA":"SU",1:"AE")
"RTN","HLOSRVR1",50,0)
 ....S:$D(IEN) HLMSTATE("ACK TO","IEN")=IEN
"RTN","HLOSRVR1",51,0)
 ...D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",52,0)
 ..E  D  ;batch
"RTN","HLOSRVR1",53,0)
 ...I SEGTYPE="MSH" D
"RTN","HLOSRVR1",54,0)
 ....D SPLITHDR(.SEG)
"RTN","HLOSRVR1",55,0)
 ....S NEWMSGID=$P(SEG(2),FS,5)
"RTN","HLOSRVR1",56,0)
 ....D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",57,0)
 ...E  D  ;not MSH
"RTN","HLOSRVR1",58,0)
 ....D:SEGTYPE="MSA"
"RTN","HLOSRVR1",59,0)
 .....N SUBIEN S SUBIEN=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOSRVR1",60,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN)=OLDMSGID
"RTN","HLOSRVR1",61,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"ACK BY")=NEWMSGID
"RTN","HLOSRVR1",62,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"STATUS")=$S(CODE="AA":"SU",1:"AE")
"RTN","HLOSRVR1",63,0)
 .....S:$D(IEN) HLMSTATE("BATCH","ACK TO",SUBIEN,"IEN")=IEN
"RTN","HLOSRVR1",64,0)
 ....D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",65,0)
 .I HLMSTATE("UNSTORED LINES"),HLCSTATE("MESSAGE ENDED"),$$SAVEMSG^HLOF778(.HLMSTATE)
"RTN","HLOSRVR1",66,0)
 ;
"RTN","HLOSRVR1",67,0)
 I STORE,'HLCSTATE("MESSAGE ENDED") D
"RTN","HLOSRVR1",68,0)
 .;reading failed before the end, there is no need to keep anything
"RTN","HLOSRVR1",69,0)
 .D:HLMSTATE("IEN") DEL778(HLMSTATE("IEN")) D:HLMSTATE("BODY") DEL777(HLMSTATE("BODY"))
"RTN","HLOSRVR1",70,0)
 .S HLMSTATE("IEN")="",HLMSTATE("BODY")=""
"RTN","HLOSRVR1",71,0)
 E  D:STORE
"RTN","HLOSRVR1",72,0)
 .D CHECKMSG(.HLMSTATE)
"RTN","HLOSRVR1",73,0)
 .D ADDAC(.HLMSTATE) ;so that future duplicates can be detected
"RTN","HLOSRVR1",74,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR1",75,0)
 ;
"RTN","HLOSRVR1",76,0)
 I 'HLCSTATE("MESSAGE ENDED") D
"RTN","HLOSRVR1",77,0)
 .S HLCSTATE("ATTEMPT")=HLCSTATE("ATTEMPT")+1
"RTN","HLOSRVR1",78,0)
 .;read keeps failing, give up
"RTN","HLOSRVR1",79,0)
 .I HLCSTATE("ATTEMPT")>4 D CLOSE^HLOT(.HLCSTATE) QUIT
"RTN","HLOSRVR1",80,0)
 E  S HLCSTATE("ATTEMPT")=1
"RTN","HLOSRVR1",81,0)
 Q HLCSTATE("MESSAGE ENDED")
"RTN","HLOSRVR1",82,0)
 ;
"RTN","HLOSRVR1",83,0)
ADDAC(HLMSTATE) ;adds the AC xref for the message that was just received
"RTN","HLOSRVR1",84,0)
 ;The AC xref allows duplicates to be detected.
"RTN","HLOSRVR1",85,0)
 ;
"RTN","HLOSRVR1",86,0)
 N FROM
"RTN","HLOSRVR1",87,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",88,0)
 S ^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID")),HLMSTATE("IEN"))=""
"RTN","HLOSRVR1",89,0)
 Q
"RTN","HLOSRVR1",90,0)
 ;
"RTN","HLOSRVR1",91,0)
DUP(HDR,MSA) ;
"RTN","HLOSRVR1",92,0)
 ;Function returns 1 if the message is a duplicate, 0 otherwise
"RTN","HLOSRVR1",93,0)
 ;Input:
"RTN","HLOSRVR1",94,0)
 ; HDR (pass by reference) the parsed header segment
"RTN","HLOSRVR1",95,0)
 ;Output:
"RTN","HLOSRVR1",96,0)
 ;  Function returns 1 if the message is a duplicate, 0 otherwise
"RTN","HLOSRVR1",97,0)
 ;  MSA (pass by reference) IF the message is a duplicate, returns the prior MSA segment
"RTN","HLOSRVR1",98,0)
 N MSGID,IEN,FROM,DUP
"RTN","HLOSRVR1",99,0)
 S (IEN,DUP)=0
"RTN","HLOSRVR1",100,0)
 S MSGID=$S(HDR("SEGMENT TYPE")="BHS":HDR("BATCH CONTROL ID"),HDR("SEGMENT TYPE")="MSH":HDR("MESSAGE CONTROL ID"),1:"")
"RTN","HLOSRVR1",101,0)
 Q:MSGID="" 0  ;no way to determine!  Bad header will be rejected
"RTN","HLOSRVR1",102,0)
 S FROM=$S(HDR("SENDING FACILITY",2)]"":HDR("SENDING FACILITY",2),1:HDR("SENDING FACILITY",1))
"RTN","HLOSRVR1",103,0)
 F  S IEN=$O(^HLB("AC",FROM_HDR("SENDING APPLICATION")_MSGID,IEN)) Q:'IEN  D  Q:DUP
"RTN","HLOSRVR1",104,0)
 .I HDR("ACCEPT ACK TYPE")="NE" S DUP=1 Q
"RTN","HLOSRVR1",105,0)
 .N NODE,I
"RTN","HLOSRVR1",106,0)
 .S NODE=$P($G(^HLB(IEN,4)),"^",3,10)
"RTN","HLOSRVR1",107,0)
 .S MSA(1)=$P(NODE,"|",2)
"RTN","HLOSRVR1",108,0)
 .Q:$E(MSA(1))'="C"
"RTN","HLOSRVR1",109,0)
 .S MSA(2)=$P(NODE,"|",3)
"RTN","HLOSRVR1",110,0)
 .S MSA(3)=$P(NODE,"|",4,10)
"RTN","HLOSRVR1",111,0)
 .S DUP=1
"RTN","HLOSRVR1",112,0)
 Q DUP
"RTN","HLOSRVR1",113,0)
 ;
"RTN","HLOSRVR1",114,0)
CHECKMSG(HLMSTATE) ;
"RTN","HLOSRVR1",115,0)
 ;Checks the header & MSA segment, sets HLMSTATE("STATUS","ACTION") if the message needs to be passed, determines if completion status should be set
"RTN","HLOSRVR1",116,0)
 ;Input:
"RTN","HLOSRVR1",117,0)
 ;  HLMSTATE("HDR") - the parsed header segment
"RTN","HLOSRVR1",118,0)
 ;Output:
"RTN","HLOSRVR1",119,0)
 ;  HLMSTATE("STATUS")="SE" if an error is detected
"RTN","HLOSRVR1",120,0)
 ;  HLMSTATE("STATUS","QUEUE") queue to put the message on
"RTN","HLOSRVR1",121,0)
 ;  HLMSTATE("STATUS","ACTION")  <tag^rtn> that is the processing routine for the receiving application
"RTN","HLOSRVR1",122,0)
 ;  HLMSTATE("MSA") - MSA(1)=accept code to be returned, MSA(3)= error txt
"RTN","HLOSRVR1",123,0)
 ;
"RTN","HLOSRVR1",124,0)
 N WANTACK,PASS,ACTION,QUEUE
"RTN","HLOSRVR1",125,0)
 M HDR=HLMSTATE("HDR")
"RTN","HLOSRVR1",126,0)
 S WANTACK=$S(HDR("ACCEPT ACK TYPE")="AL":1,1:0)
"RTN","HLOSRVR1",127,0)
 S HLMSTATE("MSA",1)="",HLMSTATE("STATUS")="",HLMSTATE("STATUS","QUEUE")="",HLMSTATE("STATUS","ACTION")=""
"RTN","HLOSRVR1",128,0)
 ;
"RTN","HLOSRVR1",129,0)
 I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE),$G(HLMSTATE("ACK TO"))="" S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="SE" Q
"RTN","HLOSRVR1",130,0)
 S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",131,0)
 ;
"RTN","HLOSRVR1",132,0)
 I (HDR("ACCEPT ACK TYPE")=""),(HDR("APP ACK TYPE")="") S HLMSTATE("MSA",1)="AE",HLMSTATE("MSA",3)="THIS INTERFACE DOES NOT IMPLEMENT ORIGINAL MODE APPLICATION ACKOWLEDGMENTS",HLMSTATE("STATUS")="SE" Q
"RTN","HLOSRVR1",133,0)
 ;
"RTN","HLOSRVR1",134,0)
 ;If this is an application ack, does the original message exist?
"RTN","HLOSRVR1",135,0)
 I $G(HLMSTATE("ACK TO"))]"" D  Q:HLMSTATE("STATUS")="SE"
"RTN","HLOSRVR1",136,0)
 .N NODE
"RTN","HLOSRVR1",137,0)
 .S:+$G(HLMSTATE("ACK TO","IEN")) NODE=$G(^HLB(+HLMSTATE("ACK TO","IEN"),0))
"RTN","HLOSRVR1",138,0)
 .I $G(NODE)="" S HLMSTATE("STATUS")="SE" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE TO APPLICATION ACKNOWLEDGMENT NOT FOUND" Q
"RTN","HLOSRVR1",139,0)
 .I ($P(NODE,"^",11)]"") S HLMSTATE("STATUS","ACTION")=$P(NODE,"^",10,11),HLMSTATE("STATUS","QUEUE")=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")
"RTN","HLOSRVR1",140,0)
 ;
"RTN","HLOSRVR1",141,0)
 I HDR("PROCESSING ID")'=HLCSTATE("SYSTEM","PROCESSING ID") S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("STATUS")="SE",HLMSTATE("MSA",3)="SYSTEM PROCESSING ID="_HLCSTATE("SYSTEM","PROCESSING ID") Q
"RTN","HLOSRVR1",142,0)
 ;
"RTN","HLOSRVR1",143,0)
 ;
"RTN","HLOSRVR1",144,0)
 ;wrong receiving facility?  This is hard to check if the sender is not VistA, because the HL7 standard permits different coding systems to be used. This check is only for DNS or station number.
"RTN","HLOSRVR1",145,0)
 S PASS=0
"RTN","HLOSRVR1",146,0)
 D
"RTN","HLOSRVR1",147,0)
 .;if its an ack to an existing message, don't check the receiving facility
"RTN","HLOSRVR1",148,0)
 .I $G(HLMSTATE("ACK TO"))]"" S PASS=1 Q
"RTN","HLOSRVR1",149,0)
 .I HDR("RECEIVING FACILITY",1)=HLCSTATE("SYSTEM","STATION") S PASS=1 Q
"RTN","HLOSRVR1",150,0)
 .I HDR("RECEIVING FACILITY",3)'="DNS" S PASS=1 Q
"RTN","HLOSRVR1",151,0)
 .I HDR("RECEIVING FACILITY",2)="" S PASS=1 Q
"RTN","HLOSRVR1",152,0)
 .I $P(HDR("RECEIVING FACILITY",2),":")[HLCSTATE("SYSTEM","DOMAIN") S PASS=1 Q
"RTN","HLOSRVR1",153,0)
 .I HLCSTATE("SYSTEM","DOMAIN")[$P(HDR("RECEIVING FACILITY",2),":") S PASS=1 Q
"RTN","HLOSRVR1",154,0)
 I 'PASS S HLMSTATE("STATUS")="SE",HLMSTATE("MSA",3)="RECEIVING FACILITY IS "_HLCSTATE("SYSTEM","DOMAIN") S:WANTACK HLMSTATE("MSA",1)="CE"
"RTN","HLOSRVR1",155,0)
 I PASS,WANTACK S HLMSTATE("MSA",1)="CA"
"RTN","HLOSRVR1",156,0)
 Q
"RTN","HLOSRVR1",157,0)
 ;
"RTN","HLOSRVR1",158,0)
DEL777(IEN777) ;delete a record from file 777 where the read did not complete
"RTN","HLOSRVR1",159,0)
 ;
"RTN","HLOSRVR1",160,0)
 K ^HLA(IEN777,0)
"RTN","HLOSRVR1",161,0)
 Q
"RTN","HLOSRVR1",162,0)
DEL778(IEN778) ;delete a record from file 778 where the read did not complete
"RTN","HLOSRVR1",163,0)
 ;
"RTN","HLOSRVR1",164,0)
 K ^HLB(IEN778,0)
"RTN","HLOSRVR1",165,0)
 Q
"RTN","HLOSRVR1",166,0)
 ;
"RTN","HLOSRVR1",167,0)
SPLITHDR(HDR) ;
"RTN","HLOSRVR1",168,0)
 ;splits hdr segment into two lines, first being just components 1-6
"RTN","HLOSRVR1",169,0)
 ;
"RTN","HLOSRVR1",170,0)
 N TEMP,FS
"RTN","HLOSRVR1",171,0)
 D SQUISH(.HDR)
"RTN","HLOSRVR1",172,0)
 S FS=$E(HDR(1),4)
"RTN","HLOSRVR1",173,0)
 S TEMP(1)=$P(HDR(1),FS,1,6)
"RTN","HLOSRVR1",174,0)
 S TEMP(2)=""
"RTN","HLOSRVR1",175,0)
 I $L(TEMP(1))<$L(HDR(1)) S TEMP(2)=FS_$P(HDR(1),FS,7,20)
"RTN","HLOSRVR1",176,0)
 S HDR(2)=TEMP(2)_$G(HDR(2))
"RTN","HLOSRVR1",177,0)
 S HDR(1)=TEMP(1)
"RTN","HLOSRVR1",178,0)
 Q
"RTN","HLOSRVR1",179,0)
 ;
"RTN","HLOSRVR1",180,0)
SQUISH(SEG) ;
"RTN","HLOSRVR1",181,0)
 ;squish the header segment =SEG(i) into at most 2 lines
"RTN","HLOSRVR1",182,0)
 ;
"RTN","HLOSRVR1",183,0)
 Q:'$O(SEG(1))
"RTN","HLOSRVR1",184,0)
 I '$O(SEG(2)) D  Q
"RTN","HLOSRVR1",185,0)
 .N LEN
"RTN","HLOSRVR1",186,0)
 .S LEN=$L(SEG(1))
"RTN","HLOSRVR1",187,0)
 .Q:LEN>255
"RTN","HLOSRVR1",188,0)
 .S SEG(1)=SEG(1)_$E(SEG(2),1,256-LEN)
"RTN","HLOSRVR1",189,0)
 .S SEG(2)=$E(SEG(2),257-LEN,99999)
"RTN","HLOSRVR1",190,0)
 ;
"RTN","HLOSRVR1",191,0)
 N A,DONE,I
"RTN","HLOSRVR1",192,0)
 S (I,DONE)=0
"RTN","HLOSRVR1",193,0)
 S A(1)=SEG(1) K SEG(1)
"RTN","HLOSRVR1",194,0)
 F  S I=$O(SEG(I)) Q:'I  D  Q:DONE
"RTN","HLOSRVR1",195,0)
 .N LEN
"RTN","HLOSRVR1",196,0)
 .S LEN=$L(A(1))
"RTN","HLOSRVR1",197,0)
 .I (LEN+$L(SEG(I)))>256 D
"RTN","HLOSRVR1",198,0)
 ..S A(1)=A(1)_$E(SEG(I),1,256-LEN)
"RTN","HLOSRVR1",199,0)
 ..S A(2)=$E(SEG(I),257-LEN,99999)
"RTN","HLOSRVR1",200,0)
 ..S DONE=1
"RTN","HLOSRVR1",201,0)
 .E  D
"RTN","HLOSRVR1",202,0)
 ..S A(1)=A(1)_SEG(I)
"RTN","HLOSRVR1",203,0)
 .K SEG(I)
"RTN","HLOSRVR1",204,0)
 ;
"RTN","HLOSRVR1",205,0)
 ;if there are any lines left in SEG(), put them in A(2)
"RTN","HLOSRVR1",206,0)
 F  S I=$O(SEG(I)) Q:'I  D  Q:DONE
"RTN","HLOSRVR1",207,0)
 .N LEN
"RTN","HLOSRVR1",208,0)
 .S LEN=$L($G(A(2)))
"RTN","HLOSRVR1",209,0)
 .I (LEN+$L(SEG(I)))>256 D
"RTN","HLOSRVR1",210,0)
 ..S A(2)=A(2)_$E(SEG(I),1,256-LEN)
"RTN","HLOSRVR1",211,0)
 ..S DONE=1
"RTN","HLOSRVR1",212,0)
 .E  D
"RTN","HLOSRVR1",213,0)
 ..S A(2)=$G(A(2))_SEG(I)
"RTN","HLOSRVR1",214,0)
 .K SEG(I)
"RTN","HLOSRVR1",215,0)
 K SEG
"RTN","HLOSRVR1",216,0)
 M SEG=A
"RTN","HLOSRVR1",217,0)
 Q
"RTN","HLOSRVR1",218,0)
 ;
"RTN","HLOSRVR1",219,0)
ERROR ;error trap
"RTN","HLOSRVR1",220,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOSRVR1",221,0)
 D END^HLOSRVR
"RTN","HLOSRVR1",222,0)
 ;
"RTN","HLOSRVR1",223,0)
 ;while debugging quit on all errors
"RTN","HLOSRVR1",224,0)
 I $G(^HLTMP("LOG ALL ERRORS")) D ^%ZTER QUIT
"RTN","HLOSRVR1",225,0)
 ;
"RTN","HLOSRVR1",226,0)
 ;don't log these common errors
"RTN","HLOSRVR1",227,0)
 I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D
"RTN","HLOSRVR1",228,0)
 .;
"RTN","HLOSRVR1",229,0)
 E  D
"RTN","HLOSRVR1",230,0)
 .D ^%ZTER
"RTN","HLOSRVR1",231,0)
 ;
"RTN","HLOSRVR1",232,0)
 ;concurrent server connections (multi-listener) should stop execution, only a single server may continue
"RTN","HLOSRVR1",233,0)
 Q:$P($G(HLCSTATE("LINK","SERVER")),"^",2)'="S"
"RTN","HLOSRVR1",234,0)
 ;
"RTN","HLOSRVR1",235,0)
 ;a lot of errors of the same time may indicate an endless loop, so keep a count
"RTN","HLOSRVR1",236,0)
 S ^TMP("HL7 ERRORS",$J,$ECODE)=$G(^TMP("HL7 ERRORS",$J,$ECODE))+1
"RTN","HLOSRVR1",237,0)
 ;
"RTN","HLOSRVR1",238,0)
 I ($G(^TMP("HL7 ERRORS",$J,$ECODE))>100) K ^TMP("HL7 ERRORS",$J) QUIT
"RTN","HLOSRVR1",239,0)
 ;
"RTN","HLOSRVR1",240,0)
 ;resume execution for the single listener
"RTN","HLOSRVR1",241,0)
 D UNWIND^%ZTER
"RTN","HLOSRVR1",242,0)
 Q
"RTN","HLOSTAT")
0^6^B55434883
"RTN","HLOSTAT",1,0)
HLOSTAT ;ALB/CJM- HLO STATISTICS- 10/4/94 1pm
"RTN","HLOSTAT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**130**;Oct 13, 1995;Build 10
"RTN","HLOSTAT",3,0)
 ;
"RTN","HLOSTAT",4,0)
 ;
"RTN","HLOSTAT",5,0)
COUNT(HLCSTATE,RAP,SAP,TYPE) ;
"RTN","HLOSTAT",6,0)
 S:RAP="" RAP="UNKNOWN"
"RTN","HLOSTAT",7,0)
 S:SAP="" SAP="UNKNOWN"
"RTN","HLOSTAT",8,0)
 S:$L(TYPE)<2 TYPE="UNKNOWN"
"RTN","HLOSTAT",9,0)
 S HLCSTATE("COUNTS")=$G(HLCSTATE("COUNTS"))+1,HLCSTATE("COUNTS",SAP,RAP,TYPE)=1+$G(HLCSTATE("COUNTS",SAP,RAP,TYPE))
"RTN","HLOSTAT",10,0)
 Q
"RTN","HLOSTAT",11,0)
SAVECNTS(HLCSTATE) ;
"RTN","HLOSTAT",12,0)
 N TIME,DIR,RAP,SAP,TYPE,COUNT
"RTN","HLOSTAT",13,0)
 Q:'HLCSTATE("COUNTS")
"RTN","HLOSTAT",14,0)
 S TIME=$E($$NOW^XLFDT,1,10)
"RTN","HLOSTAT",15,0)
 S DIR=$S(+$G(HLCSTATE("SERVER")):"IN",1:"OUT")
"RTN","HLOSTAT",16,0)
 I $G(HLCSTATE("COUNTS","ACKS")) D
"RTN","HLOSTAT",17,0)
 .I $$INC^HLOSITE($NA(^HLSTATS($S(DIR="IN":"OUT",1:"IN"),"HOURLY",+TIME,"ACCEPT ACK")),HLCSTATE("COUNTS","ACKS"))
"RTN","HLOSTAT",18,0)
 S SAP=""
"RTN","HLOSTAT",19,0)
 F  S SAP=$O(HLCSTATE("COUNTS",SAP)) Q:SAP=""  D
"RTN","HLOSTAT",20,0)
 .S RAP=""
"RTN","HLOSTAT",21,0)
 .F  S RAP=$O(HLCSTATE("COUNTS",SAP,RAP)) Q:RAP=""  D
"RTN","HLOSTAT",22,0)
 ..S TYPE=""
"RTN","HLOSTAT",23,0)
 ..F  S TYPE=$O(HLCSTATE("COUNTS",SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOSTAT",24,0)
 ...S COUNT=HLCSTATE("COUNTS",SAP,RAP,TYPE)
"RTN","HLOSTAT",25,0)
 ...I $$INC^HLOSITE($NA(^HLSTATS(DIR,"HOURLY",+TIME,SAP,RAP,TYPE)),COUNT)
"RTN","HLOSTAT",26,0)
 K HLCSTATE("COUNTS") S HLCSTATE("COUNTS")=0
"RTN","HLOSTAT",27,0)
 Q
"RTN","HLOSTAT",28,0)
 ;
"RTN","HLOSTAT",29,0)
TOTAL(WORK) ;totals hours into days and days into months
"RTN","HLOSTAT",30,0)
 ;
"RTN","HLOSTAT",31,0)
 N RAP,SAP,TIME,LIMIT,DIR,COUNT,MONTH,START,END
"RTN","HLOSTAT",32,0)
 ;
"RTN","HLOSTAT",33,0)
 ;start totaling the next day after last date totaled
"RTN","HLOSTAT",34,0)
 S START=$G(^HLSTATS("END DATE"))
"RTN","HLOSTAT",35,0)
 S:START START=$$FMADD^XLFDT(START,1)
"RTN","HLOSTAT",36,0)
 ;
"RTN","HLOSTAT",37,0)
 ;end totaling in the last hour of yesterday and save it so that the next run knows where to start
"RTN","HLOSTAT",38,0)
 S END=$$FMADD^XLFDT($$DT^XLFDT,-1)
"RTN","HLOSTAT",39,0)
 S ^HLSTATS("END DATE")=END
"RTN","HLOSTAT",40,0)
 S END=END+.24
"RTN","HLOSTAT",41,0)
 ;
"RTN","HLOSTAT",42,0)
 ;total hours into days
"RTN","HLOSTAT",43,0)
 S LIMIT=$$FMADD^XLFDT($$DT^XLFDT,,-48) ;save ~48 hours of hourly data
"RTN","HLOSTAT",44,0)
 F DIR="IN","OUT" D
"RTN","HLOSTAT",45,0)
 .S TIME=0
"RTN","HLOSTAT",46,0)
 .F  S TIME=$O(^HLSTATS(DIR,"HOURLY",TIME)) Q:'TIME  Q:(TIME>END)  D
"RTN","HLOSTAT",47,0)
 ..D:'(TIME<START)
"RTN","HLOSTAT",48,0)
 ...S ^HLSTATS(DIR,"DAILY",$P(TIME,"."),"ACCEPT ACK")=$G(^HLSTATS(DIR,"DAILY",$P(TIME,"."),"ACCEPT ACK"))+$G(^HLSTATS(DIR,"HOURLY",TIME,"ACCEPT ACK"))
"RTN","HLOSTAT",49,0)
 ...S SAP=""
"RTN","HLOSTAT",50,0)
 ...F  S SAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP)) Q:SAP=""  D
"RTN","HLOSTAT",51,0)
 ....S RAP=""
"RTN","HLOSTAT",52,0)
 ....F  S RAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP)) Q:RAP=""  D
"RTN","HLOSTAT",53,0)
 .....S TYPE=""
"RTN","HLOSTAT",54,0)
 .....F  S TYPE=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOSTAT",55,0)
 ......S COUNT=$G(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE))
"RTN","HLOSTAT",56,0)
 ......S ^HLSTATS(DIR,"DAILY",$P(TIME,"."),SAP,RAP,TYPE)=$G(^HLSTATS(DIR,"DAILY",$P(TIME,"."),SAP,RAP,TYPE))+COUNT
"RTN","HLOSTAT",57,0)
 ..;get rid of old hourly stats
"RTN","HLOSTAT",58,0)
 ..K:(TIME<LIMIT) ^HLSTATS(DIR,"HOURLY",TIME)
"RTN","HLOSTAT",59,0)
 ;
"RTN","HLOSTAT",60,0)
 ;total days into months
"RTN","HLOSTAT",61,0)
 S LIMIT=$$FMADD^XLFDT($$DT^XLFDT,-30) ;save ~30 days of daily data
"RTN","HLOSTAT",62,0)
 F DIR="IN","OUT" D
"RTN","HLOSTAT",63,0)
 .S TIME=0
"RTN","HLOSTAT",64,0)
 .F  S TIME=$O(^HLSTATS(DIR,"DAILY",TIME)) Q:'TIME  Q:(TIME>END)  D
"RTN","HLOSTAT",65,0)
 ..D:'(TIME<START)
"RTN","HLOSTAT",66,0)
 ...S MONTH=$E(TIME,1,5)
"RTN","HLOSTAT",67,0)
 ...S ^HLSTATS(DIR,"MONTHLY",MONTH,"ACCEPT ACK")=$G(^HLSTATS(DIR,"MONTHLY",MONTH,"ACCEPT ACK"))+$G(^HLSTATS(DIR,"DAILY",TIME,"ACCEPT ACK"))
"RTN","HLOSTAT",68,0)
 ...S SAP=""
"RTN","HLOSTAT",69,0)
 ...F  S SAP=$O(^HLSTATS(DIR,"DAILY",TIME,SAP)) Q:SAP=""  D
"RTN","HLOSTAT",70,0)
 ....S RAP=""
"RTN","HLOSTAT",71,0)
 ....F  S RAP=$O(^HLSTATS(DIR,"DAILY",TIME,SAP,RAP)) Q:RAP=""  D
"RTN","HLOSTAT",72,0)
 .....S TYPE=""
"RTN","HLOSTAT",73,0)
 .....F  S TYPE=$O(^HLSTATS(DIR,"DAILY",TIME,SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOSTAT",74,0)
 ......S COUNT=$G(^HLSTATS(DIR,"DAILY",TIME,SAP,RAP,TYPE))
"RTN","HLOSTAT",75,0)
 ......S ^HLSTATS(DIR,"MONTHLY",MONTH,SAP,RAP,TYPE)=$G(^HLSTATS(DIR,"MONTHLY",MONTH,SAP,RAP,TYPE))+COUNT
"RTN","HLOSTAT",76,0)
 ..K:(TIME<LIMIT) ^HLSTATS(DIR,"DAILY",TIME)
"RTN","HLOSTAT",77,0)
 Q
"RTN","HLOSTAT",78,0)
REPORT ;Interactive option for printing the message statistics report
"RTN","HLOSTAT",79,0)
 N DIR,TYPE,START,END
"RTN","HLOSTAT",80,0)
 W !,"Hourly, daily, and monthly statistics are maintained."
"RTN","HLOSTAT",81,0)
 W !,"Hourly statistics are available for approximately the last 24 hours."
"RTN","HLOSTAT",82,0)
 W !,"Daily statistics are available for approximately the last 30 days."
"RTN","HLOSTAT",83,0)
 W !,"Monthly statistics are kept indefinitely"
"RTN","HLOSTAT",84,0)
 S DIR(0)="S^h:HOURLY;d:DAILY;m:MONTHLY"
"RTN","HLOSTAT",85,0)
 S DIR("A")="Which type of statistics should be reported"
"RTN","HLOSTAT",86,0)
 S DIR("B")="MONTHLY"
"RTN","HLOSTAT",87,0)
 D ^DIR
"RTN","HLOSTAT",88,0)
 Q:$D(DIRUT)
"RTN","HLOSTAT",89,0)
 I Y'="h",Y'="d",Y'="m" Q
"RTN","HLOSTAT",90,0)
 S TYPE=$S(Y="h":"HOURLY",Y="d":"DAILY",1:"MONTHLY")
"RTN","HLOSTAT",91,0)
 S START=$S(TYPE="HOURLY":$E($$FMADD^XLFDT($$NOW^XLFDT,,-24),1,10),TYPE="DAILY":$$FMADD^XLFDT(DT,-7),1:$E($$FMADD^XLFDT(DT,-30),1,5)_"01")
"RTN","HLOSTAT",92,0)
 S START=$$ASKBEGIN^HLOUSR2(START)
"RTN","HLOSTAT",93,0)
 Q:'START
"RTN","HLOSTAT",94,0)
 S END=$$ASKEND^HLOUSR2(START)
"RTN","HLOSTAT",95,0)
 Q:'END
"RTN","HLOSTAT",96,0)
 S:TYPE="MONTHLY" START=$E(START,1,5)_"00"
"RTN","HLOSTAT",97,0)
 S:TYPE="DAILY" START=$E(START,1,7)
"RTN","HLOSTAT",98,0)
 S:TYPE="HOURLY" START=$E(START,1,10)
"RTN","HLOSTAT",99,0)
 D:$$DEVICE() PRINT(TYPE,START,END)
"RTN","HLOSTAT",100,0)
 Q
"RTN","HLOSTAT",101,0)
 ;
"RTN","HLOSTAT",102,0)
QUE ;entry point for queuing the message statistics report
"RTN","HLOSTAT",103,0)
 ;
"RTN","HLOSTAT",104,0)
 D PRINT($G(HLOPARMS("STATISTICS TYPE")),$G(HLOPARMS("START DT/TM")),$G(HLOPARMS("END DT/TM")))
"RTN","HLOSTAT",105,0)
 Q
"RTN","HLOSTAT",106,0)
 ;
"RTN","HLOSTAT",107,0)
PRINT(STATTYPE,START,END) ;
"RTN","HLOSTAT",108,0)
 ;
"RTN","HLOSTAT",109,0)
 N RAP,SAP,TIME,DIR,COUNT,PAGE,CRT,QUIT
"RTN","HLOSTAT",110,0)
 S QUIT=0
"RTN","HLOSTAT",111,0)
 S CRT=$S($E(IOST,1,2)="C-":1,1:0)
"RTN","HLOSTAT",112,0)
 ;
"RTN","HLOSTAT",113,0)
 U IO
"RTN","HLOSTAT",114,0)
 W:CRT @IOF
"RTN","HLOSTAT",115,0)
 W "HLO MESSAGING STATISTICS REPORT ",$$FMTE^XLFDT($$NOW^XLFDT),?70,"Page 1"
"RTN","HLOSTAT",116,0)
 D LINE($$LJ("Type:",15)_STATTYPE)
"RTN","HLOSTAT",117,0)
 D LINE($$LJ("Beginning:",15)_$S(STATTYPE="MONTHLY":$$FMTE^XLFDT(START),1:$$FMTE^XLFDT(START)))
"RTN","HLOSTAT",118,0)
 D LINE($$LJ("Ending:",15)_$$FMTE^XLFDT(END))
"RTN","HLOSTAT",119,0)
 S PAGE=1
"RTN","HLOSTAT",120,0)
 ;
"RTN","HLOSTAT",121,0)
 ;
"RTN","HLOSTAT",122,0)
 F DIR="IN","OUT" D  Q:QUIT
"RTN","HLOSTAT",123,0)
 .N TOTAL
"RTN","HLOSTAT",124,0)
 .S TOTAL=0
"RTN","HLOSTAT",125,0)
 .D LINE(" ")
"RTN","HLOSTAT",126,0)
 .S TIME=START
"RTN","HLOSTAT",127,0)
 .S:STATTYPE="MONTHLY" TIME=$E(TIME,1,5)
"RTN","HLOSTAT",128,0)
 .S TIME=TIME-.0001
"RTN","HLOSTAT",129,0)
 .D LINE($S(DIR="IN":"Incoming Messages:",1:"Outgoing Messages:"))
"RTN","HLOSTAT",130,0)
 .Q:QUIT
"RTN","HLOSTAT",131,0)
 .F  S TIME=$O(^HLSTATS(DIR,STATTYPE,TIME)) Q:((TIME>$G(END))&$G(END))  Q:'TIME  D  Q:QUIT
"RTN","HLOSTAT",132,0)
 ..N SUBTOTAL
"RTN","HLOSTAT",133,0)
 ..S SUBTOTAL=0
"RTN","HLOSTAT",134,0)
 ..D LINE(" ")
"RTN","HLOSTAT",135,0)
 ..Q:QUIT
"RTN","HLOSTAT",136,0)
 ..D LINE("     Time Period: "_$S(STATTYPE="MONTHLY":$$FMTE^XLFDT(TIME_"00"),1:$$FMTE^XLFDT(TIME)))
"RTN","HLOSTAT",137,0)
 ..Q:QUIT
"RTN","HLOSTAT",138,0)
 ..S COUNT=$G(^HLSTATS(DIR,STATTYPE,TIME,"ACCEPT ACK"))
"RTN","HLOSTAT",139,0)
 ..I COUNT D  Q:QUIT
"RTN","HLOSTAT",140,0)
 ...D LINE(" ")
"RTN","HLOSTAT",141,0)
 ...Q:QUIT
"RTN","HLOSTAT",142,0)
 ...D LINE("          Accept Acknowledgments by All Applications          Count:"_$$RJ(COUNT,10))
"RTN","HLOSTAT",143,0)
 ...Q:QUIT
"RTN","HLOSTAT",144,0)
 ...D LINE(" ")
"RTN","HLOSTAT",145,0)
 ..S SAP=""
"RTN","HLOSTAT",146,0)
 ..F  S SAP=$O(^HLSTATS(DIR,STATTYPE,TIME,SAP)) Q:SAP=""  D  Q:QUIT
"RTN","HLOSTAT",147,0)
 ...Q:SAP="ACCEPT ACK"
"RTN","HLOSTAT",148,0)
 ...D LINE("          Sending Application: "_SAP)
"RTN","HLOSTAT",149,0)
 ...Q:QUIT
"RTN","HLOSTAT",150,0)
 ...S RAP=""
"RTN","HLOSTAT",151,0)
 ...F  S RAP=$O(^HLSTATS(DIR,STATTYPE,TIME,SAP,RAP)) Q:RAP=""  D  Q:QUIT
"RTN","HLOSTAT",152,0)
 ....D LINE("               Receiving Application: "_RAP)
"RTN","HLOSTAT",153,0)
 ....Q:QUIT
"RTN","HLOSTAT",154,0)
 ....S TYPE=""
"RTN","HLOSTAT",155,0)
 ....F  S TYPE=$O(^HLSTATS(DIR,STATTYPE,TIME,SAP,RAP,TYPE)) Q:TYPE=""  D  Q:QUIT
"RTN","HLOSTAT",156,0)
 .....S COUNT=$G(^HLSTATS(DIR,STATTYPE,TIME,SAP,RAP,TYPE))
"RTN","HLOSTAT",157,0)
 .....S SUBTOTAL=SUBTOTAL+COUNT
"RTN","HLOSTAT",158,0)
 .....D LINE("                    Message Type: "_$$LJ(TYPE,25)_"   Count:"_$$RJ(COUNT,10))
"RTN","HLOSTAT",159,0)
 .....Q:QUIT
"RTN","HLOSTAT",160,0)
 ..I 'QUIT D
"RTN","HLOSTAT",161,0)
 ...S TOTAL=TOTAL+SUBTOTAL
"RTN","HLOSTAT",162,0)
 ...D LINE(" "),LINE($$RJ("**"_STATTYPE_" SUBTOTAL ** (excluding commit acks):",68)_$$RJ(SUBTOTAL,10))
"RTN","HLOSTAT",163,0)
 .D:'QUIT LINE(" "),LINE($$RJ("** TOTAL "_$S(DIR="IN":"INCOMING",1:"OUTGOING")_" MESSAGES ** (excluding commit acks):",68)_$$RJ(TOTAL,10))
"RTN","HLOSTAT",164,0)
 I CRT,'QUIT D PAUSE2
"RTN","HLOSTAT",165,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLOSTAT",166,0)
 D ^%ZISC
"RTN","HLOSTAT",167,0)
 Q
"RTN","HLOSTAT",168,0)
 ;
"RTN","HLOSTAT",169,0)
DEVICE() ;
"RTN","HLOSTAT",170,0)
 ;Description: allows the user to select a device.
"RTN","HLOSTAT",171,0)
 ;Input: none
"RTN","HLOSTAT",172,0)
 ;
"RTN","HLOSTAT",173,0)
 ;Output:
"RTN","HLOSTAT",174,0)
 ;  Function Value - Returns 0 if the user decides not to print or to
"RTN","HLOSTAT",175,0)
 ;    queue the report, 1 otherwise.
"RTN","HLOSTAT",176,0)
 ;
"RTN","HLOSTAT",177,0)
 N OK,HLOPARMS
"RTN","HLOSTAT",178,0)
 S OK=1
"RTN","HLOSTAT",179,0)
 S %ZIS="MQ"
"RTN","HLOSTAT",180,0)
 D ^%ZIS
"RTN","HLOSTAT",181,0)
 S:POP OK=0
"RTN","HLOSTAT",182,0)
 D:OK&$D(IO("Q"))
"RTN","HLOSTAT",183,0)
 .S HLOPARMS("STATISTICS TYPE")=TYPE,HLOPARMS("START DT/TM")=START,HLOPARMS("END DT/TM")=END
"RTN","HLOSTAT",184,0)
 .S ZTRTN="QUE^HLOSTAT",ZTDESC="HLO MESSAGE STATISTICS REPORT",ZTSAVE("HLOPARMS(")=""
"RTN","HLOSTAT",185,0)
 .D ^%ZTLOAD
"RTN","HLOSTAT",186,0)
 .W !,$S($D(ZTSK):"REQUEST QUEUED TASK="_ZTSK,1:"REQUEST CANCELLED")
"RTN","HLOSTAT",187,0)
 .D HOME^%ZIS
"RTN","HLOSTAT",188,0)
 .S OK=0
"RTN","HLOSTAT",189,0)
 Q OK
"RTN","HLOSTAT",190,0)
 ;
"RTN","HLOSTAT",191,0)
PAUSE ;
"RTN","HLOSTAT",192,0)
 ;First scrolls to the bottome of the page, then does a screen pause.  Sets QUIT=1 if user decides to quit.
"RTN","HLOSTAT",193,0)
 ;
"RTN","HLOSTAT",194,0)
 N DIR,X,Y
"RTN","HLOSTAT",195,0)
 F  Q:$Y>(IOSL-3)  W !
"RTN","HLOSTAT",196,0)
 S DIR(0)="E"
"RTN","HLOSTAT",197,0)
 D ^DIR
"RTN","HLOSTAT",198,0)
 I ('(+Y))!$D(DIRUT) S QUIT=1
"RTN","HLOSTAT",199,0)
 Q
"RTN","HLOSTAT",200,0)
PAUSE2 ;
"RTN","HLOSTAT",201,0)
 ;Screen pause without scrolling.  Sets QUIT=1 if user decides to quit.
"RTN","HLOSTAT",202,0)
 ;
"RTN","HLOSTAT",203,0)
 N DIR,X,Y
"RTN","HLOSTAT",204,0)
 S DIR(0)="E"
"RTN","HLOSTAT",205,0)
 D ^DIR
"RTN","HLOSTAT",206,0)
 I ('(+Y))!$D(DIRUT) S QUIT=1
"RTN","HLOSTAT",207,0)
 Q
"RTN","HLOSTAT",208,0)
 ;
"RTN","HLOSTAT",209,0)
LINE(LINE) ;Prints a line.
"RTN","HLOSTAT",210,0)
 ;
"RTN","HLOSTAT",211,0)
 I CRT,($Y>(IOSL-4)) D
"RTN","HLOSTAT",212,0)
 .D PAUSE
"RTN","HLOSTAT",213,0)
 .Q:QUIT
"RTN","HLOSTAT",214,0)
 .W @IOF
"RTN","HLOSTAT",215,0)
 .W LINE
"RTN","HLOSTAT",216,0)
 ;
"RTN","HLOSTAT",217,0)
 E  I ('CRT),($Y>(IOSL-2)) D
"RTN","HLOSTAT",218,0)
 .W @IOF
"RTN","HLOSTAT",219,0)
 .W ?70,"Page: ",PAGE
"RTN","HLOSTAT",220,0)
 .S PAGE=PAGE+1
"RTN","HLOSTAT",221,0)
 .W LINE
"RTN","HLOSTAT",222,0)
 ;
"RTN","HLOSTAT",223,0)
 E  W !,LINE
"RTN","HLOSTAT",224,0)
 Q
"RTN","HLOSTAT",225,0)
 ;
"RTN","HLOSTAT",226,0)
LJ(STRING,LEN) ;
"RTN","HLOSTAT",227,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOSTAT",228,0)
RJ(STRING,LEN) ;
"RTN","HLOSTAT",229,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOTLNK")
0^7^B20724359
"RTN","HLOTLNK",1,0)
HLOTLNK ;IRMFO-ALB/CJM - APIs for the HL Logical Link file;03/24/2004  14:43
"RTN","HLOTLNK",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130**;Oct 13, 1995;Build 10
"RTN","HLOTLNK",3,0)
 ;
"RTN","HLOTLNK",4,0)
SETSHUT(LINKIEN) ;
"RTN","HLOTLNK",5,0)
 ;sets the shutdown flag (can not fail - if the link doesn't exist, by definition its shutdown)
"RTN","HLOTLNK",6,0)
 Q:'$G(LINKIEN) 1
"RTN","HLOTLNK",7,0)
 Q:'$D(^HLCS(870,LINKIEN,0)) 1
"RTN","HLOTLNK",8,0)
 S $P(^HLCS(870,LINKIEN,0),"^",16)=1
"RTN","HLOTLNK",9,0)
 Q 1
"RTN","HLOTLNK",10,0)
SETOPEN(LINKIEN) ;
"RTN","HLOTLNK",11,0)
 ;clears the shutdown flag, returns 1 on success, 0 on failure
"RTN","HLOTLNK",12,0)
 Q:'$G(LINKIEN) 0
"RTN","HLOTLNK",13,0)
 Q:'$D(^HLCS(870,LINKIEN,0)) 0
"RTN","HLOTLNK",14,0)
 S $P(^HLCS(870,LINKIEN,0),"^",16)=""
"RTN","HLOTLNK",15,0)
 Q 1
"RTN","HLOTLNK",16,0)
 ;
"RTN","HLOTLNK",17,0)
IFSHUT(LINKNAME) ;
"RTN","HLOTLNK",18,0)
 ;returns 1 if the link was shut down to HLO
"RTN","HLOTLNK",19,0)
 N IEN,LINK
"RTN","HLOTLNK",20,0)
 S LINK=$P($G(LINKNAME),":")
"RTN","HLOTLNK",21,0)
 Q:LINK=""
"RTN","HLOTLNK",22,0)
 S IEN=$O(^HLCS(870,"B",LINK,0))
"RTN","HLOTLNK",23,0)
 Q:'IEN 1
"RTN","HLOTLNK",24,0)
 Q:$P($G(^HLCS(870,IEN,0)),"^",16) 1
"RTN","HLOTLNK",25,0)
 Q 0
"RTN","HLOTLNK",26,0)
 ;
"RTN","HLOTLNK",27,0)
DOMAIN(LINKIEN) ;
"RTN","HLOTLNK",28,0)
 ;Returns the domain associated with this link
"RTN","HLOTLNK",29,0)
 ;
"RTN","HLOTLNK",30,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",31,0)
 N NODE,DOMAIN
"RTN","HLOTLNK",32,0)
 S DOMAIN=""
"RTN","HLOTLNK",33,0)
 S NODE=$G(^HLCS(870,LINKIEN,0))
"RTN","HLOTLNK",34,0)
 I $P(NODE,"^",7) D
"RTN","HLOTLNK",35,0)
 .S DOMAIN=$P($G(^DIC(4.2,$P(NODE,"^",7),0)),"^")
"RTN","HLOTLNK",36,0)
 .S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",37,0)
 I '$L(DOMAIN) S DOMAIN=$P(NODE,"^",8)
"RTN","HLOTLNK",38,0)
 Q DOMAIN
"RTN","HLOTLNK",39,0)
PORT(LINKIEN) ;
"RTN","HLOTLNK",40,0)
 ;Returns the HLO port associated with this link
"RTN","HLOTLNK",41,0)
 ;
"RTN","HLOTLNK",42,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",43,0)
 N NODE,PORT
"RTN","HLOTLNK",44,0)
 S NODE=$G(^HLCS(870,LINKIEN,400))
"RTN","HLOTLNK",45,0)
 S PORT=$P(NODE,"^",8)
"RTN","HLOTLNK",46,0)
 S:'PORT PORT=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":5001,1:5026)
"RTN","HLOTLNK",47,0)
 Q PORT
"RTN","HLOTLNK",48,0)
 ;
"RTN","HLOTLNK",49,0)
PORT2(LINKNAME) ;given the name of the link, returns its HLO port
"RTN","HLOTLNK",50,0)
 Q $$PORT($O(^HLCS(870,"B",LINKNAME,0)))
"RTN","HLOTLNK",51,0)
 ;
"RTN","HLOTLNK",52,0)
STATNUM(LINKIEN) ;
"RTN","HLOTLNK",53,0)
 ;Given the ien of the link, this function returns the station #.
"RTN","HLOTLNK",54,0)
 ;
"RTN","HLOTLNK",55,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",56,0)
 N INST
"RTN","HLOTLNK",57,0)
 S INST=$P($G(^HLCS(870,LINKIEN,0)),"^",2)
"RTN","HLOTLNK",58,0)
 Q:'INST ""
"RTN","HLOTLNK",59,0)
 Q $P($G(^DIC(4,INST,99)),"^")
"RTN","HLOTLNK",60,0)
 ;
"RTN","HLOTLNK",61,0)
FINDLINK(STATN) ;
"RTN","HLOTLNK",62,0)
 ;Returns the link ien based on the station # =STATN
"RTN","HLOTLNK",63,0)
 ;The link found must have a name starting with "VA", as these are
"RTN","HLOTLNK",64,0)
 ;reserved for officially released links associated with VHA institutions
"RTN","HLOTLNK",65,0)
 ;** EXCEPTION** MPIVA is an official link associated with 200M
"RTN","HLOTLNK",66,0)
 ;
"RTN","HLOTLNK",67,0)
 Q:'$L($G(STATN)) 0
"RTN","HLOTLNK",68,0)
 ;
"RTN","HLOTLNK",69,0)
 N NAME,IEN
"RTN","HLOTLNK",70,0)
 S (NAME,IEN)=""
"RTN","HLOTLNK",71,0)
 F  S NAME=$O(^HLCS(870,"AC",STATN,NAME)) Q:NAME=""  I (NAME'="VA-VIE"),($E(NAME,1,2)="VA")!(NAME="MPIVA") S IEN=$O(^HLCS(870,"AC",STATN,NAME,0)) Q
"RTN","HLOTLNK",72,0)
 Q IEN
"RTN","HLOTLNK",73,0)
 ;
"RTN","HLOTLNK",74,0)
GETLINK(LINKNAME,LINK) ;
"RTN","HLOTLNK",75,0)
 N IEN
"RTN","HLOTLNK",76,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",77,0)
 Q:'IEN 0
"RTN","HLOTLNK",78,0)
 Q $$GET(IEN,.LINK)
"RTN","HLOTLNK",79,0)
GET(IEN,LINK) ;
"RTN","HLOTLNK",80,0)
 N NODE,PTR
"RTN","HLOTLNK",81,0)
 K LINK
"RTN","HLOTLNK",82,0)
 S NODE=$G(^HLCS(870,IEN,0))
"RTN","HLOTLNK",83,0)
 Q:NODE="" 0
"RTN","HLOTLNK",84,0)
 S LINK("NAME")=$P(NODE,"^")
"RTN","HLOTLNK",85,0)
 S LINK("IEN")=IEN
"RTN","HLOTLNK",86,0)
 S LINK("SHUTDOWN")=+$P(NODE,"^",16)
"RTN","HLOTLNK",87,0)
 I $P(NODE,"^",7) D
"RTN","HLOTLNK",88,0)
 .S LINK("DOMAIN")=$P(^DIC(4.2,$P(NODE,"^",7),0),"^")
"RTN","HLOTLNK",89,0)
 .S LINK("DOMAIN")=$S($L(LINK("DOMAIN")):"HL7."_LINK("DOMAIN"),1:"")
"RTN","HLOTLNK",90,0)
 I $G(LINK("DOMAIN"))="" S LINK("DOMAIN")=$P(NODE,"^",8)
"RTN","HLOTLNK",91,0)
 S PTR=$P(NODE,"^",3)
"RTN","HLOTLNK",92,0)
 S LINK("LLP")=$S('PTR:"",1:$P($G(^HLCS(869.1,PTR,0)),"^"))
"RTN","HLOTLNK",93,0)
 S LINK("SERVER")=""
"RTN","HLOTLNK",94,0)
 I LINK("LLP")="TCP" D
"RTN","HLOTLNK",95,0)
 .S LINK("SERVER")=1
"RTN","HLOTLNK",96,0)
 .S NODE=$G(^HLCS(870,IEN,400))
"RTN","HLOTLNK",97,0)
 .S LINK("IP")=$P(NODE,"^")
"RTN","HLOTLNK",98,0)
 .S LINK("PORT")=$P(NODE,"^",8)
"RTN","HLOTLNK",99,0)
 .S:'LINK("PORT") LINK("PORT")=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":5001,1:5026)
"RTN","HLOTLNK",100,0)
 .S:$P(NODE,"^",3)="C" LINK("SERVER")=0
"RTN","HLOTLNK",101,0)
 .I LINK("SERVER") S LINK("SERVER")=LINK("SERVER")_"^"_$P(NODE,"^",3)
"RTN","HLOTLNK",102,0)
 Q 1
"RTN","HLOTLNK",103,0)
 ;
"RTN","HLOTLNK",104,0)
SET1(LINK,MDOMAIN) ;
"RTN","HLOTLNK",105,0)
 N DOMAIN
"RTN","HLOTLNK",106,0)
 Q:'$L(MDOMAIN)
"RTN","HLOTLNK",107,0)
 S DOMAIN=$P($G(^DIC(4.2,MDOMAIN,0)),"^")
"RTN","HLOTLNK",108,0)
 S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",109,0)
 I DOMAIN'="" S ^HLCS(870,"AD","TCP",DOMAIN,LINK)=""
"RTN","HLOTLNK",110,0)
 Q
"RTN","HLOTLNK",111,0)
KILL1(LINK,MDOMAIN) ;
"RTN","HLOTLNK",112,0)
 N DOMAIN
"RTN","HLOTLNK",113,0)
 Q:'$L(MDOMAIN)
"RTN","HLOTLNK",114,0)
 S DOMAIN=$P($G(^DIC(4.2,MDOMAIN,0)),"^")
"RTN","HLOTLNK",115,0)
 S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",116,0)
 I DOMAIN'="" K ^HLCS(870,"AD","TCP",DOMAIN,LINK)
"RTN","HLOTLNK",117,0)
 Q
"RTN","HLOTLNK",118,0)
SET2(LINK,DOMAIN) ;
"RTN","HLOTLNK",119,0)
 I DOMAIN'="" S ^HLCS(870,"AD","TCP",DOMAIN,LINK)=""
"RTN","HLOTLNK",120,0)
 Q
"RTN","HLOTLNK",121,0)
KILL2(LINK,DOMAIN) ;
"RTN","HLOTLNK",122,0)
 I DOMAIN'="" K ^HLCS(870,"AD","TCP",DOMAIN,LINK)
"RTN","HLOTLNK",123,0)
 Q
"RTN","HLOTLNK",124,0)
SET3(LINK,DEVICE) ;
"RTN","HLOTLNK",125,0)
 Q:'DEVICE
"RTN","HLOTLNK",126,0)
 S ^HLCS(870,"AD","HLLP",DEVICE,LINK)=""
"RTN","HLOTLNK",127,0)
 Q
"RTN","HLOTLNK",128,0)
KILL3(LINK,DEVICE) ;
"RTN","HLOTLNK",129,0)
 Q:'DEVICE
"RTN","HLOTLNK",130,0)
 S ^HLCS(870,"AD","HLLP",DEVICE,LINK)=""
"RTN","HLOTLNK",131,0)
 Q
"RTN","HLOTLNK",132,0)
LLP(LINKNAME) ;
"RTN","HLOTLNK",133,0)
 ;finds the type of LLP for a named link
"RTN","HLOTLNK",134,0)
 N IEN,LLP
"RTN","HLOTLNK",135,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",136,0)
 Q:'IEN ""
"RTN","HLOTLNK",137,0)
 S LLP=$P($G(^HLCS(870,IEN,0)),"^",3)
"RTN","HLOTLNK",138,0)
 Q:'LLP ""
"RTN","HLOTLNK",139,0)
 Q $P($G(^HLCS(869.1,LLP,0)),"^")
"RTN","HLOTLNK",140,0)
 ;
"RTN","HLOTLNK",141,0)
DEVICE(LINKNAME) ;
"RTN","HLOTLNK",142,0)
 N IEN
"RTN","HLOTLNK",143,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",144,0)
 Q:'IEN ""
"RTN","HLOTLNK",145,0)
 Q $P($G(^HLCS(870,IEN,200)),"^")
"RTN","HLOTLNK",146,0)
 ;
"RTN","HLOTLNK",147,0)
RTRNLNK(COMP1,COMP2,COMP3) ;
"RTN","HLOTLNK",148,0)
 ;based on the sending facility from the original header, this function finds the return link, or "" if not successful
"RTN","HLOTLNK",149,0)
 ;Inputs:
"RTN","HLOTLNK",150,0)
 ;  COMP1,COMP2,COMP3 - 3 components of the sending facility from the original message
"RTN","HLOTLNK",151,0)
 ;
"RTN","HLOTLNK",152,0)
 N LINK,IEN
"RTN","HLOTLNK",153,0)
 S LINK=""
"RTN","HLOTLNK",154,0)
 I $G(COMP3)="DNS",$P($G(COMP2),":")]"" S LINK=$O(^HLCS(870,"AD","TCP",$P(COMP2,":"),""))
"RTN","HLOTLNK",155,0)
 I LINK="",$L($G(COMP1)) S IEN=$$FINDLINK(COMP1) S:IEN LINK=$P($G(^HLCS(870,IEN,0)),"^")
"RTN","HLOTLNK",156,0)
 Q LINK
"RTN","HLOTLNK",157,0)
 ;
"RTN","HLOTLNK",158,0)
 ;HLLP is not implemented in HLO
"RTN","HLOTLNK",159,0)
 ;I LLP="HLLP" N DEVICE S DEVICE=$$DEVICE(FROMLINK) I DEVICE Q $O(^HLCS(870,"AD","TCP",DEVICE,""))
"RTN","HLOTLNK",160,0)
 ;Q ""
"RTN","HLOTLNK",161,0)
 ;
"RTN","HLOTLNK",162,0)
CHKLINK(LINK) ;
"RTN","HLOTLNK",163,0)
 Q:'$L(LINK) 0
"RTN","HLOTLNK",164,0)
 Q:'$O(^HLCS(870,"B",LINK,0)) 0
"RTN","HLOTLNK",165,0)
 Q 1
"RTN","HLOUSR")
0^8^B88410850
"RTN","HLOUSR",1,0)
HLOUSR ;ALB/CJM -ListManager Screen for viewing system status;12 JUN 1997 10:00 am
"RTN","HLOUSR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130**;Oct 13, 1995;Build 10
"RTN","HLOUSR",3,0)
 ;
"RTN","HLOUSR",4,0)
EN ;
"RTN","HLOUSR",5,0)
 ;
"RTN","HLOUSR",6,0)
 N HLSCREEN,TESTOPEN,HLRFRSH
"RTN","HLOUSR",7,0)
 D WAIT^DICD
"RTN","HLOUSR",8,0)
 D EN^VALM("HLO SYSTEM MONITOR")
"RTN","HLOUSR",9,0)
 Q
"RTN","HLOUSR",10,0)
 ;
"RTN","HLOUSR",11,0)
BRIEF ;Init variables and list array
"RTN","HLOUSR",12,0)
 N COUNT,LINK,QUE,FROM,TIME,STATUS,TEMP,DIR,TODAY,LIST
"RTN","HLOUSR",13,0)
 S HLRFRSH="BRIEF^HLOUSR"
"RTN","HLOUSR",14,0)
 S (HLSCREEN,VALMSG)="Brief System Status"
"RTN","HLOUSR",15,0)
 S VALMCNT=8
"RTN","HLOUSR",16,0)
 ;K @VALMAR
"RTN","HLOUSR",17,0)
 D CLEAN^VALM10
"RTN","HLOUSR",18,0)
 S VALMBG=1
"RTN","HLOUSR",19,0)
 S VALMBCK="R"
"RTN","HLOUSR",20,0)
 K VALMDDF("COL 2"),VALMDDF("COL 3"),VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",21,0)
 D CHGCAP^VALM("COL 1","Brief Operational Overview")
"RTN","HLOUSR",22,0)
 S @VALMAR@(1,0)="SYSTEM STATUS:             "_$S($$CHKSTOP^HLOPROC:"STOPPED",1:"RUNNING")
"RTN","HLOUSR",23,0)
 S @VALMAR@(2,0)="PROCESS MANAGER:           "_$S($$RUNNING:"RUNNING",1:"STOPPED")
"RTN","HLOUSR",24,0)
 ;
"RTN","HLOUSR",25,0)
 S TIME=$P($G(TESTOPEN("LISTENER")),"^",2)
"RTN","HLOUSR",26,0)
 I TIME,$$FMDIFF^XLFDT($$NOW^XLFDT,TIME,2)<300 D
"RTN","HLOUSR",27,0)
 .S STATUS=+TESTOPEN("LISTENER")
"RTN","HLOUSR",28,0)
 E  D
"RTN","HLOUSR",29,0)
 .S STATUS=0
"RTN","HLOUSR",30,0)
 .S LINK=$P($G(^HLD(779.1,1,0)),"^",10)
"RTN","HLOUSR",31,0)
 .I LINK S LINK=$P($G(^HLCS(870,LINK,0)),"^") Q:'$L(LINK)  S STATUS=$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOUSR",32,0)
 .S TESTOPEN("LISTENER")=STATUS_"^"_$$NOW^XLFDT
"RTN","HLOUSR",33,0)
 ;
"RTN","HLOUSR",34,0)
 S @VALMAR@(3,0)="STANDARD LISTENER:         "_$S(STATUS:"OPERATIONAL",1:"NOT OPERATIONAL")
"RTN","HLOUSR",35,0)
 ;
"RTN","HLOUSR",36,0)
 S TIME=$P($G(TESTOPEN("IE")),"^",2)
"RTN","HLOUSR",37,0)
 I TIME,$$FMDIFF^XLFDT($$NOW^XLFDT,TIME,2)<300 D
"RTN","HLOUSR",38,0)
 .S STATUS=+TESTOPEN("IE")
"RTN","HLOUSR",39,0)
 E  D
"RTN","HLOUSR",40,0)
 .S STATUS=$$IFOPEN^HLOUSR1("VA-VIE")
"RTN","HLOUSR",41,0)
 .S TESTOPEN("IE")=STATUS_"^"_$$NOW^XLFDT
"RTN","HLOUSR",42,0)
 S @VALMAR@(4,0)="INTERFACE ENGINE:          "_$S(STATUS:"OPERATIONAL",1:"NOT OPERATIONAL")
"RTN","HLOUSR",43,0)
 S @VALMAR@(5,0)="TASKMAN:                   "_$S($$TM^%ZTLOAD:"RUNNING",1:"NOT RUNNING")
"RTN","HLOUSR",44,0)
 ;
"RTN","HLOUSR",45,0)
 S (LIST,LINK)=""
"RTN","HLOUSR",46,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D  I $L(LIST)>60 S LIST=LIST_",..." Q
"RTN","HLOUSR",47,0)
 .N TIME,QUE,LINKARY
"RTN","HLOUSR",48,0)
 .I $$GETLINK^HLOTLNK($P(LINK,":"),.LINKARY)
"RTN","HLOUSR",49,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOUSR",50,0)
 .I '$G(LINKARY("SHUTDOWN")),TIME="" Q
"RTN","HLOUSR",51,0)
 .I '$G(LINKARY("SHUTDOWN")),($$HDIFF^XLFDT($H,TIME,2)<300) Q
"RTN","HLOUSR",52,0)
 .S LIST=LIST_$S($L(LIST):", ",1:"")_$P(LINK,":")
"RTN","HLOUSR",53,0)
 S @VALMAR@(6,0)="DOWN LINKS: "_LIST
"RTN","HLOUSR",54,0)
 S @VALMAR@(7,0)="CLIENT LINK PROCESSES:     "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","OUTGOING CLIENT LINK"))
"RTN","HLOUSR",55,0)
 S @VALMAR@(8,0)="IN-FILER PROCESSES:        "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","INCOMING QUEUES"))
"RTN","HLOUSR",56,0)
 S COUNT=0,LINK=""
"RTN","HLOUSR",57,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  S QUE=""  F  S QUE=$O(^(LINK,QUE)) Q:QUE=""  S COUNT=COUNT+$G(^(QUE))
"RTN","HLOUSR",58,0)
 S @VALMAR@(9,0)="MESSAGES PENDING TRANSMISSION:      "_+COUNT
"RTN","HLOUSR",59,0)
 S TEMP="STOPPED OUTGOING QUEUES: "
"RTN","HLOUSR",60,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",61,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","OUT",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",62,0)
 S @VALMAR@(10,0)=TEMP
"RTN","HLOUSR",63,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",64,0)
 F  S QUE=$O(^HLC("QUEUECOUNT","IN",QUE)) Q:QUE=""  S FROM=""  F  S FROM=$O(^(QUE,FROM)) Q:FROM=""  S COUNT=COUNT+$G(^(FROM))
"RTN","HLOUSR",65,0)
 S @VALMAR@(11,0)="MESSAGES PENDING ON APPLICATIONS:   "_+COUNT
"RTN","HLOUSR",66,0)
 S TEMP="STOPPED INCOMING QUEUES: "
"RTN","HLOUSR",67,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",68,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","IN",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",69,0)
 S @VALMAR@(12,0)=TEMP
"RTN","HLOUSR",70,0)
 S @VALMAR@(13,0)="FILE 777 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^",2))
"RTN","HLOUSR",71,0)
 S @VALMAR@(14,0)="FILE 778 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^",2))
"RTN","HLOUSR",72,0)
 S TODAY=$$DT^XLFDT
"RTN","HLOUSR",73,0)
 F DIR="IN","OUT" D
"RTN","HLOUSR",74,0)
 .N RAP,SAP,TIME,TOTAL
"RTN","HLOUSR",75,0)
 .S TOTAL=0
"RTN","HLOUSR",76,0)
 .S TIME=TODAY-.0001
"RTN","HLOUSR",77,0)
 .F  S TIME=$O(^HLSTATS(DIR,"HOURLY",TIME)) Q:'TIME  Q:((TIME\1)>TODAY)  D
"RTN","HLOUSR",78,0)
 ..S SAP=""
"RTN","HLOUSR",79,0)
 ..F  S SAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP)) Q:SAP=""  D
"RTN","HLOUSR",80,0)
 ...Q:SAP="ACCEPT ACK"
"RTN","HLOUSR",81,0)
 ...S RAP=""
"RTN","HLOUSR",82,0)
 ...F  S RAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP)) Q:RAP=""  D
"RTN","HLOUSR",83,0)
 ....S TYPE=""
"RTN","HLOUSR",84,0)
 ....F  S TYPE=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOUSR",85,0)
 .....S TOTAL=TOTAL+$G(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE))
"RTN","HLOUSR",86,0)
 .S:DIR="OUT" @VALMAR@(15,0)="MESSAGES SENT TODAY:           "_$$RJ(TOTAL,10)
"RTN","HLOUSR",87,0)
 .S:DIR'="OUT" @VALMAR@(16,0)="MESSAGES RECEIVED TODAY:       "_$$RJ(TOTAL,10)
"RTN","HLOUSR",88,0)
 Q
"RTN","HLOUSR",89,0)
 ;
"RTN","HLOUSR",90,0)
HELP ;Help code
"RTN","HLOUSR",91,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLOUSR",92,0)
 Q
"RTN","HLOUSR",93,0)
 ;
"RTN","HLOUSR",94,0)
EXIT ;Exit code
"RTN","HLOUSR",95,0)
 D CLEAN^VALM10
"RTN","HLOUSR",96,0)
 D CLEAR^VALM1
"RTN","HLOUSR",97,0)
 ;
"RTN","HLOUSR",98,0)
 Q
"RTN","HLOUSR",99,0)
 ;
"RTN","HLOUSR",100,0)
EXPND ;Expand code
"RTN","HLOUSR",101,0)
 Q
"RTN","HLOUSR",102,0)
 ;
"RTN","HLOUSR",103,0)
PROCS ;
"RTN","HLOUSR",104,0)
 S HLRFRSH="PROCS^HLOUSR"
"RTN","HLOUSR",105,0)
 ;K @VALMAR
"RTN","HLOUSR",106,0)
 D CLEAN^VALM10
"RTN","HLOUSR",107,0)
 S VALMCNT=0
"RTN","HLOUSR",108,0)
 S VALMBCK="R"
"RTN","HLOUSR",109,0)
 S VALMDDF("COL 2")="COL 2^35^10^MIN^H"
"RTN","HLOUSR",110,0)
 S VALMDDF("COL 3")="COL 3^47^10^MAX^H"
"RTN","HLOUSR",111,0)
 S VALMDDF("COL 4")="COL 4^59^10^#RUNNING^H"
"RTN","HLOUSR",112,0)
 S VALMDDF("COL 5")="COL 5^71^10^#QUEUED^IOBON"
"RTN","HLOUSR",113,0)
 D CHGCAP^VALM("COL 1","Process Type")
"RTN","HLOUSR",114,0)
 N IEN
"RTN","HLOUSR",115,0)
 S IEN=0
"RTN","HLOUSR",116,0)
 F  S IEN=$O(^HLD(779.3,"C",1,IEN)) Q:'IEN  D
"RTN","HLOUSR",117,0)
 .N PROC
"RTN","HLOUSR",118,0)
 .Q:'$$GETPROC^HLOPROC1(IEN,.PROC)
"RTN","HLOUSR",119,0)
 .Q:PROC("NAME")="VMS TCP LISTENER"
"RTN","HLOUSR",120,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",121,0)
 .S @VALMAR@(VALMCNT,0)=$$LJ(PROC("NAME"),30)_$$RJ(PROC("MINIMUM"),6)_$$RJ(PROC("MAXIMUM"),12)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC("NAME"))),14)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC("NAME"))),12)
"RTN","HLOUSR",122,0)
 S VALMCNT=VALMCNT+1,@VALMAR@(VALMCNT,0)=""
"RTN","HLOUSR",123,0)
 S IEN=""
"RTN","HLOUSR",124,0)
 F  S IEN=$O(^HLTMP("HL7 RUNNING PROCESSES",IEN)) Q:IEN=""  D
"RTN","HLOUSR",125,0)
 .N NODE
"RTN","HLOUSR",126,0)
 .S NODE=$G(^HLTMP("HL7 RUNNING PROCESSES",IEN))
"RTN","HLOUSR",127,0)
 .Q:NODE=""
"RTN","HLOUSR",128,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",129,0)
 .S @VALMAR@(VALMCNT,0)="$J: "_$$LJ(IEN,9)_" ->"_$$CJ($P(NODE,"^",3),28)_"<- started at "_$$HTE^XLFDT($P(NODE,"^"))
"RTN","HLOUSR",130,0)
 Q
"RTN","HLOUSR",131,0)
 ;
"RTN","HLOUSR",132,0)
OUTQUEUE ;
"RTN","HLOUSR",133,0)
 N LINK
"RTN","HLOUSR",134,0)
 D CLEAN^VALM10
"RTN","HLOUSR",135,0)
 ;K @VALMAR
"RTN","HLOUSR",136,0)
 S HLRFRSH="OUTQUEUE^HLOUSR"
"RTN","HLOUSR",137,0)
 S (HLSCREEN,VALMSG)="Outgoing Queues *down links !stopped queues"
"RTN","HLOUSR",138,0)
 S VALMCNT=0
"RTN","HLOUSR",139,0)
 S VALMBCK="R"
"RTN","HLOUSR",140,0)
 S VALMDDF("COL 1")="COL 1^2^20^ Link^H"
"RTN","HLOUSR",141,0)
 S VALMDDF("COL 2")="COL 2^28^20^Queue^H"
"RTN","HLOUSR",142,0)
 S VALMDDF("COL 3")="COL 3^50^20^Count^H"
"RTN","HLOUSR",143,0)
 K VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",144,0)
 D CHGCAP^VALM("COL 1"," Link")
"RTN","HLOUSR",145,0)
 S LINK=""
"RTN","HLOUSR",146,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOUSR",147,0)
 .N COUNT,QUE,SHOW
"RTN","HLOUSR",148,0)
 .S SHOW=LINK
"RTN","HLOUSR",149,0)
 .I $D(^HLTMP("FAILING LINKS",SHOW)) S SHOW="*"_SHOW
"RTN","HLOUSR",150,0)
 .S QUE=""
"RTN","HLOUSR",151,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOUSR",152,0)
 ..S COUNT=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE))
"RTN","HLOUSR",153,0)
 ..Q:'COUNT
"RTN","HLOUSR",154,0)
 ..S VALMCNT=VALMCNT+1
"RTN","HLOUSR",155,0)
 ..I $E(SHOW)="*" D
"RTN","HLOUSR",156,0)
 ...S @VALMAR@(VALMCNT,0)=$$LJ(SHOW,20)_$$CJ($S($$STOPPED^HLOQUE("OUT",QUE):"!",1:"")_QUE,21)_"   "_$$RJ(COUNT,10),SHOW=""
"RTN","HLOUSR",157,0)
 ...D CNTRL^VALM10(VALMCNT,1,1,IOBON,IOBOFF)
"RTN","HLOUSR",158,0)
 ..E  S @VALMAR@(VALMCNT,0)=$$LJ(SHOW,20)_$$CJ($S($$STOPPED^HLOQUE("OUT",QUE):"!",1:"")_QUE,21)_"   "_$$RJ(COUNT,10),SHOW=""
"RTN","HLOUSR",159,0)
 Q
"RTN","HLOUSR",160,0)
 ;
"RTN","HLOUSR",161,0)
INQUEUE ;
"RTN","HLOUSR",162,0)
 N FROM
"RTN","HLOUSR",163,0)
 D CLEAN^VALM10
"RTN","HLOUSR",164,0)
 ;K @VALMAR
"RTN","HLOUSR",165,0)
 S HLRFRSH="INQUEUE^HLOUSR"
"RTN","HLOUSR",166,0)
 S (HLSCREEN,VALMSG)="Incoming Queues ('!' = stopped queues)"
"RTN","HLOUSR",167,0)
 S VALMCNT=0
"RTN","HLOUSR",168,0)
 S VALMBCK="R"
"RTN","HLOUSR",169,0)
 S VALMDDF("COL 1")="COL 1^1^40^ From^H"
"RTN","HLOUSR",170,0)
 S VALMDDF("COL 2")="COL 2^45^20^Queue^H"
"RTN","HLOUSR",171,0)
 S VALMDDF("COL 3")="COL 3^70^10^Count^H"
"RTN","HLOUSR",172,0)
 K VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",173,0)
 D CHGCAP^VALM("COL 1"," From")
"RTN","HLOUSR",174,0)
 S FROM=""
"RTN","HLOUSR",175,0)
 F  S FROM=$O(^HLC("QUEUECOUNT","IN",FROM)) Q:FROM=""  D
"RTN","HLOUSR",176,0)
 .N COUNT,QUE,SHOW
"RTN","HLOUSR",177,0)
 .S SHOW=$$LJ(FROM,40)_"  "
"RTN","HLOUSR",178,0)
 .S QUE=""
"RTN","HLOUSR",179,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","IN",FROM,QUE)) Q:QUE=""  D
"RTN","HLOUSR",180,0)
 ..S COUNT=$G(^HLC("QUEUECOUNT","IN",FROM,QUE))
"RTN","HLOUSR",181,0)
 ..Q:'COUNT
"RTN","HLOUSR",182,0)
 ..S VALMCNT=VALMCNT+1
"RTN","HLOUSR",183,0)
 ..S @VALMAR@(VALMCNT,0)=SHOW_$$LJ($S($$STOPPED^HLOQUE("IN",QUE):"!",1:"")_QUE,21)_" "_$$RJ(COUNT,10)
"RTN","HLOUSR",184,0)
 ..S SHOW=$$LJ("",40)_"  "
"RTN","HLOUSR",185,0)
 Q
"RTN","HLOUSR",186,0)
VIEWLINK ;
"RTN","HLOUSR",187,0)
 N C,QUIT,LINK,LINKARY
"RTN","HLOUSR",188,0)
 S (QUIT,C,LINK)=""
"RTN","HLOUSR",189,0)
 S VALMBCK="R"
"RTN","HLOUSR",190,0)
 ;
"RTN","HLOUSR",191,0)
 ;currently HL7 (Optimized) only does TCP, when serial added a change is needed here
"RTN","HLOUSR",192,0)
 S LINK=$$ASKLINK
"RTN","HLOUSR",193,0)
 Q:LINK=""
"RTN","HLOUSR",194,0)
 Q:'$$GETLINK^HLOTLNK(LINK,.LINKARY)
"RTN","HLOUSR",195,0)
 S LINK=LINK_":"_LINKARY("PORT")
"RTN","HLOUSR",196,0)
 W !,"Hit any key to stop...",!
"RTN","HLOUSR",197,0)
 F  D  Q:QUIT
"RTN","HLOUSR",198,0)
 .N COUNT,QUE
"RTN","HLOUSR",199,0)
 .S (COUNT,QUE)=""
"RTN","HLOUSR",200,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  S COUNT=COUNT+$G(^(QUE))
"RTN","HLOUSR",201,0)
 .W $C(13),"                             ",$C(13),"MESSAGES PENDING TRANSMISSION: ",IOBON,$$RJ(+COUNT,10),IOBOFF
"RTN","HLOUSR",202,0)
 .R *C:1 I $T S QUIT=1
"RTN","HLOUSR",203,0)
 Q
"RTN","HLOUSR",204,0)
 ;
"RTN","HLOUSR",205,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR",206,0)
 Q $$CJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",207,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR",208,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",209,0)
RJ(STRING,LEN) ;
"RTN","HLOUSR",210,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",211,0)
 ;
"RTN","HLOUSR",212,0)
RUNNING() ;Is the Process Manager running?
"RTN","HLOUSR",213,0)
 N RUNNING
"RTN","HLOUSR",214,0)
 L +^HLTMP("PROCESS MANAGER"):0
"RTN","HLOUSR",215,0)
 S RUNNING='$T
"RTN","HLOUSR",216,0)
 I 'RUNNING L -^HLTMP("PROCESS MANAGER")
"RTN","HLOUSR",217,0)
 Q RUNNING
"RTN","HLOUSR",218,0)
 ;
"RTN","HLOUSR",219,0)
TESTLINK ;
"RTN","HLOUSR",220,0)
 N LINK,LINKNAME,OK
"RTN","HLOUSR",221,0)
 S VALMBCK="R"
"RTN","HLOUSR",222,0)
 S LINKNAME=$$ASKLINK
"RTN","HLOUSR",223,0)
 Q:LINKNAME=""
"RTN","HLOUSR",224,0)
 S OK=$$IFOPEN^HLOUSR1(LINKNAME)
"RTN","HLOUSR",225,0)
 I OK W !,LINKNAME_" IS operational..."
"RTN","HLOUSR",226,0)
 E  W !,LINKNAME_" is NOT operational..."
"RTN","HLOUSR",227,0)
 W !,"Hit any key to continue..."
"RTN","HLOUSR",228,0)
 R *C:DTIME
"RTN","HLOUSR",229,0)
 Q
"RTN","HLOUSR",230,0)
 ;
"RTN","HLOUSR",231,0)
ASKLINK() ;
"RTN","HLOUSR",232,0)
 N DIC,TCP,X,Y,DTOUT,DUOUT
"RTN","HLOUSR",233,0)
 S DIC=870
"RTN","HLOUSR",234,0)
 S DIC(0)="AENQ"
"RTN","HLOUSR",235,0)
 S TCP=$O(^HLCS(869.1,"B","TCP",0))
"RTN","HLOUSR",236,0)
 S DIC("A")="Select a TCP link:"
"RTN","HLOUSR",237,0)
 S DIC("S")="I $P(^(0),U,3)=TCP"
"RTN","HLOUSR",238,0)
 D FULL^VALM1
"RTN","HLOUSR",239,0)
 D ^DIC
"RTN","HLOUSR",240,0)
 I +Y'=-1,'$D(DTOUT),'$D(DUOUT) Q $P(Y,"^",2)
"RTN","HLOUSR",241,0)
 Q ""
"RTN","HLOUSR",242,0)
 ;
"RTN","HLOUSR",243,0)
STOP ;
"RTN","HLOUSR",244,0)
 I '$$ASKYESNO^HLOUSR2("Are you SURE that you want to stop sending and receiving messages","NO") S VALMBCK="" Q
"RTN","HLOUSR",245,0)
 ;
"RTN","HLOUSR",246,0)
 D STOPHL7^HLOPROC1
"RTN","HLOUSR",247,0)
 S VALMBCK="R",VALMSG="HL7 (Optimized) has been stopped...."
"RTN","HLOUSR",248,0)
 H 5
"RTN","HLOUSR",249,0)
 D:HLSCREEN="Brief System Status" BRIEF^HLOUSR
"RTN","HLOUSR",250,0)
 D:HLSCREEN="Running Processes" PROCS^HLOUSR
"RTN","HLOUSR",251,0)
 Q
"RTN","HLOUSR",252,0)
 ;
"RTN","HLOUSR",253,0)
UPDMODE ;update mode
"RTN","HLOUSR",254,0)
 Q:'$L(HLRFRSH)
"RTN","HLOUSR",255,0)
 N QUIT,NEW,TOP,BOTTOM,DX,DY,IOTM,IOBM,I
"RTN","HLOUSR",256,0)
 W !!,IOINHI,"Hit any key to escape realtime display mode...",IOINORM
"RTN","HLOUSR",257,0)
 S IOTM=3,IOBM=23
"RTN","HLOUSR",258,0)
 W @IOSTBM
"RTN","HLOUSR",259,0)
 S DX=1,DY=$S(VALMCNT<17:VALMCNT+1,1:17) X IOXY
"RTN","HLOUSR",260,0)
 I VALMCNT>16 F I=17:1:$S(VALMCNT<22:VALMCNT,1:21) W !,@VALMAR@(I,0)
"RTN","HLOUSR",261,0)
 S QUIT=0
"RTN","HLOUSR",262,0)
 S TOP=VALMBG
"RTN","HLOUSR",263,0)
 S BOTTOM=TOP+23
"RTN","HLOUSR",264,0)
 S OLD=VALMAR
"RTN","HLOUSR",265,0)
 S VALMAR="NEW"
"RTN","HLOUSR",266,0)
 S VALMCNT=0
"RTN","HLOUSR",267,0)
 F  D  Q:QUIT
"RTN","HLOUSR",268,0)
 .N LINE
"RTN","HLOUSR",269,0)
 .R *C:3 I $T S QUIT=1
"RTN","HLOUSR",270,0)
 .S (VALMCNT,I)=0
"RTN","HLOUSR",271,0)
 .D @HLRFRSH
"RTN","HLOUSR",272,0)
 .F LINE=TOP:1:BOTTOM IF $G(@OLD@(LINE,0))'=$G(@VALMAR@(LINE,0)) D WRITE^VALM10(LINE)
"RTN","HLOUSR",273,0)
 K @OLD M @OLD=@VALMAR S VALMAR=OLD
"RTN","HLOUSR",274,0)
 S VALMBCK="R"
"RTN","HLOUSR",275,0)
 Q
"RTN","HLOUSRA")
0^9^B10710992
"RTN","HLOUSRA",1,0)
HLOUSRA ;ALB/CJM -ListManager Screen for viewing downed links;12 JUN 1997 10:00 am
"RTN","HLOUSRA",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**130**;Oct 13, 1995;Build 10
"RTN","HLOUSRA",3,0)
 ;
"RTN","HLOUSRA",4,0)
HEADER ;
"RTN","HLOUSRA",5,0)
 S VALMSG="Down Client Links"
"RTN","HLOUSRA",6,0)
 S VALMDDF("COL 2")="COL 2^20^20^Pending Messages^H"
"RTN","HLOUSRA",7,0)
 S VALMDDF("COL 3")="COL 3^47^20^Date/Time Down^H"
"RTN","HLOUSRA",8,0)
 K VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSRA",9,0)
 D CHGCAP^VALM("COL 1","Client Link")
"RTN","HLOUSRA",10,0)
 Q
"RTN","HLOUSRA",11,0)
 ;
"RTN","HLOUSRA",12,0)
HELP ;Help code
"RTN","HLOUSRA",13,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLOUSRA",14,0)
 Q
"RTN","HLOUSRA",15,0)
 ;
"RTN","HLOUSRA",16,0)
EXIT ;Exit code
"RTN","HLOUSRA",17,0)
 D CLEAN^VALM10
"RTN","HLOUSRA",18,0)
 D CLEAR^VALM1
"RTN","HLOUSRA",19,0)
 S VALMBCK="R"
"RTN","HLOUSRA",20,0)
 ;
"RTN","HLOUSRA",21,0)
 Q
"RTN","HLOUSRA",22,0)
 ;
"RTN","HLOUSRA",23,0)
DOWNLINK ;
"RTN","HLOUSRA",24,0)
 D EN^VALM("HLO DOWN LINKS")
"RTN","HLOUSRA",25,0)
 D:$L($G(HLRFRSH)) @HLRFRSH
"RTN","HLOUSRA",26,0)
 Q
"RTN","HLOUSRA",27,0)
 ;
"RTN","HLOUSRA",28,0)
RESTART ;
"RTN","HLOUSRA",29,0)
 ;Allows the user to select a link and restarts HLO messages flowing to that domain.
"RTN","HLOUSRA",30,0)
 N LINKARY
"RTN","HLOUSRA",31,0)
 S VALMBCK="R"
"RTN","HLOUSRA",32,0)
 ;
"RTN","HLOUSRA",33,0)
 S LINK=$$ASKLINK
"RTN","HLOUSRA",34,0)
 Q:LINK=""
"RTN","HLOUSRA",35,0)
 I $$GETLINK^HLOTLNK(LINK,.LINKARY) D
"RTN","HLOUSRA",36,0)
 .I $$SETOPEN^HLOTLNK(LINKARY("IEN")) K ^HLTMP("FAILING LINKS",LINK_":"_LINKARY("PORT")) S VALMSG="HLO messages across "_LINKARY("NAME")_" have been started..."
"RTN","HLOUSRA",37,0)
 .D LISTDOWN
"RTN","HLOUSRA",38,0)
 Q
"RTN","HLOUSRA",39,0)
 ;
"RTN","HLOUSRA",40,0)
LISTDOWN ;
"RTN","HLOUSRA",41,0)
 N LINK
"RTN","HLOUSRA",42,0)
 D CLEAN^VALM10
"RTN","HLOUSRA",43,0)
 S VALMCNT=0
"RTN","HLOUSRA",44,0)
 S LINK=""
"RTN","HLOUSRA",45,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D
"RTN","HLOUSRA",46,0)
 .N TIME,COUNT,QUE,LINKARY
"RTN","HLOUSRA",47,0)
 .I $$GETLINK^HLOTLNK($P(LINK,":"),.LINKARY)
"RTN","HLOUSRA",48,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK))
"RTN","HLOUSRA",49,0)
 .I '$G(LINKARY("SHUTDOWN")),TIME="" Q
"RTN","HLOUSRA",50,0)
 .I '$G(LINKARY("SHUTDOWN")),($$HDIFF^XLFDT($H,TIME,2)<300) Q
"RTN","HLOUSRA",51,0)
 .S TIME=$$HTE^XLFDT(TIME)
"RTN","HLOUSRA",52,0)
 .S COUNT=0
"RTN","HLOUSRA",53,0)
 .S QUE=""
"RTN","HLOUSRA",54,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  S COUNT=COUNT+$G(^HLC("QUEUECOUNT","OUT",LINK,QUE))
"RTN","HLOUSRA",55,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSRA",56,0)
 .S @VALMAR@(VALMCNT,0)=$$LJ(LINK,15)_$$RJ(COUNT,15)_"    "_$$RJ(TIME,30)_"  "_$S($G(LINKARY("SHUTDOWN")):"SHUTDOWN",1:"")
"RTN","HLOUSRA",57,0)
 Q
"RTN","HLOUSRA",58,0)
 ;
"RTN","HLOUSRA",59,0)
STOPLINK ;
"RTN","HLOUSRA",60,0)
 N LINK,LINKARY
"RTN","HLOUSRA",61,0)
 S VALMBCK="R"
"RTN","HLOUSRA",62,0)
 ;
"RTN","HLOUSRA",63,0)
 S LINK=$$ASKLINK
"RTN","HLOUSRA",64,0)
 Q:LINK=""
"RTN","HLOUSRA",65,0)
 I $$GETLINK^HLOTLNK(LINK,.LINKARY) D
"RTN","HLOUSRA",66,0)
 .S LINK=LINK_":"_LINKARY("PORT")
"RTN","HLOUSRA",67,0)
 .I $$SETSHUT^HLOTLNK(LINKARY("IEN")) S VALMSG="HLO messages across "_LINKARY("NAME")_" have been stopped..."
"RTN","HLOUSRA",68,0)
 .S ^HLTMP("FAILING LINKS",LINK)=$G(^HLTMP("FAILING LINKS",LINK),$H)
"RTN","HLOUSRA",69,0)
 .S ^HLB("QUEUE","OUT",LINK)=$H
"RTN","HLOUSRA",70,0)
 .D LISTDOWN
"RTN","HLOUSRA",71,0)
 Q
"RTN","HLOUSRA",72,0)
 ;
"RTN","HLOUSRA",73,0)
CJ(STRING,LEN) ;
"RTN","HLOUSRA",74,0)
 Q $$CJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSRA",75,0)
LJ(STRING,LEN) ;
"RTN","HLOUSRA",76,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSRA",77,0)
RJ(STRING,LEN) ;
"RTN","HLOUSRA",78,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSRA",79,0)
 ;
"RTN","HLOUSRA",80,0)
ASKLINK() ;
"RTN","HLOUSRA",81,0)
 ;returns the name
"RTN","HLOUSRA",82,0)
 N DIC,TCP,X,Y,DTOUT,DUOUT
"RTN","HLOUSRA",83,0)
 S DIC=870
"RTN","HLOUSRA",84,0)
 S DIC(0)="AENQ"
"RTN","HLOUSRA",85,0)
 S TCP=$O(^HLCS(869.1,"B","TCP",0))
"RTN","HLOUSRA",86,0)
 S DIC("A")="Select a TCP Client Link (Outgoing):"
"RTN","HLOUSRA",87,0)
 S DIC("S")="I $P(^(0),U,3)=TCP,$P(^(400),U,3)=""C"""
"RTN","HLOUSRA",88,0)
 D FULL^VALM1
"RTN","HLOUSRA",89,0)
 D ^DIC
"RTN","HLOUSRA",90,0)
 I +Y'=-1,'$D(DTOUT),'$D(DUOUT) Q $P(Y,"^",2)
"RTN","HLOUSRA",91,0)
 Q ""
"VER")
8.0^22.0
"^DD",779.3,779.3,0)
FIELD^^.15^15
"^DD",779.3,779.3,0,"DDA")
N
"^DD",779.3,779.3,0,"DT")
3041221
"^DD",779.3,779.3,0,"IX","B",779.3,.01)

"^DD",779.3,779.3,0,"NM","HLO PROCESS REGISTRY")

"^DD",779.3,779.3,0,"VRPK")
HL
"^DD",779.3,779.3,.01,0)
PROCESS NAME^RF^^0;1^K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E) X
"^DD",779.3,779.3,.01,1,0)
^.1
"^DD",779.3,779.3,.01,1,1,0)
779.3^B
"^DD",779.3,779.3,.01,1,1,1)
S ^HLD(779.3,"B",$E(X,1,30),DA)=""
"^DD",779.3,779.3,.01,1,1,2)
K ^HLD(779.3,"B",$E(X,1,30),DA)
"^DD",779.3,779.3,.01,3)
Give the type of process a unique name, 3-30 characters.
"^DD",779.3,779.3,.01,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.01,21,1,0)
A unique name for the type of process.
"^DD",779.3,779.3,.01,"DT")
3041115
"^DD",779.3,779.3,.02,0)
ACTIVE^S^0:NO;1:YES;^0;2^Q
"^DD",779.3,779.3,.02,3)
Enter 1 to activate these processes, 0 to inactivate.
"^DD",779.3,779.3,.02,21,0)
^^4^4^3050805^^^^
"^DD",779.3,779.3,.02,21,1,0)
A flag that indicates whether or not this type of process is active under 
"^DD",779.3,779.3,.02,21,2,0)
the HLO Process Manager. Some processes may not apply to some 
"^DD",779.3,779.3,.02,21,3,0)
systems, for example, a particular site may not use the Taskman 
"^DD",779.3,779.3,.02,21,4,0)
multi-listener. 
"^DD",779.3,779.3,.02,"DT")
3050805
"^DD",779.3,779.3,.03,0)
MINIMUM ACTIVE PROCESSES^NJ2,0^^0;3^K:+X'=X!(X>99)!(X<0)!(X?.E1"."1.N) X
"^DD",779.3,779.3,.03,3)
How many of these processes should be running at a minimum when HL7 messaging is on?
"^DD",779.3,779.3,.03,21,0)
^^3^3^3050805^^^
"^DD",779.3,779.3,.03,21,1,0)
This field indicates the minimum number of concurrent processes of this 
"^DD",779.3,779.3,.03,21,2,0)
type.  The exact number changes as the HLO Process Manager starts and 
"^DD",779.3,779.3,.03,21,3,0)
stops processes in response to changes in workload.
"^DD",779.3,779.3,.03,"DT")
3050805
"^DD",779.3,779.3,.04,0)
MAXIMUM ACTIVE PROCESSES^NJ3,0^^0;4^K:+X'=X!(X>999)!(X<1)!(X?.E1"."1.N) X
"^DD",779.3,779.3,.04,3)
How many of these processes should be running at a maximum when the HL7 messaging system is on?
"^DD",779.3,779.3,.04,"DT")
3040907
"^DD",779.3,779.3,.05,0)
SCHEDULING FREQUENCY (minutes)^NJ4,0^^0;5^K:+X'=X!(X>9999)!(X<0)!(X?.E1"."1N.N) X
"^DD",779.3,779.3,.05,3)
This is how long the Process Manager should wait between checks to see if another process of this type should be started.  Enter 0 to 9999.
"^DD",779.3,779.3,.05,21,0)
^.001^2^2^3041221^^
"^DD",779.3,779.3,.05,21,1,0)
This is how long the Process Manager should wait between checks to see if 
"^DD",779.3,779.3,.05,21,2,0)
another process of this type should be started.
"^DD",779.3,779.3,.05,"DT")
3050919
"^DD",779.3,779.3,.06,0)
DT/TM LAST STARTED OR STOPPED^D^^0;6^S %DT="ESTR" D ^%DT S X=Y K:Y<1 X
"^DD",779.3,779.3,.06,3)
DT/TM the process manager last started or stopped one of these.
"^DD",779.3,779.3,.06,21,0)
^^2^2^3041115^
"^DD",779.3,779.3,.06,21,1,0)
The date and time when a process of this type was last started or 
"^DD",779.3,779.3,.06,21,2,0)
stopped.
"^DD",779.3,779.3,.06,"DT")
3041115
"^DD",779.3,779.3,.07,0)
HANG TIME (seconds)^NJ3,0^^0;7^K:+X'=X!(X>999)!(X<0)!(X?.E1"."1.N) X
"^DD",779.3,779.3,.07,3)
If the process cannot find work, how many seconds should it hang before looking again?
"^DD",779.3,779.3,.07,21,0)
^^2^2^3041115^
"^DD",779.3,779.3,.07,21,1,0)
This is how long a process should wait between attempts to find work to 
"^DD",779.3,779.3,.07,21,2,0)
do.
"^DD",779.3,779.3,.07,"DT")
3041115
"^DD",779.3,779.3,.08,0)
GET WORK FUNCTION (TAG)^RF^^0;8^K:$L(X)>8!($L(X)<1) X
"^DD",779.3,779.3,.08,3)
What function will this process call to find work (optional routine entry point)
"^DD",779.3,779.3,.08,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.08,21,1,0)
The M entry point to the GET WORK function for this process type.
"^DD",779.3,779.3,.08,"DT")
3041115
"^DD",779.3,779.3,.09,0)
GET WORK FUNCTION (ROUTINE)^RF^^0;9^K:$L(X)>8!($L(X)<1) X
"^DD",779.3,779.3,.09,3)
What function should this process call to find work? (routine name only)
"^DD",779.3,779.3,.09,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.09,21,1,0)
The routine in which this process type has located its GET WORK function.
"^DD",779.3,779.3,.09,"DT")
3041115
"^DD",779.3,779.3,.1,0)
DO WORK FUNCTION (TAG)^F^^0;10^K:$L(X)>8!($L(X)<1) X
"^DD",779.3,779.3,.1,3)
What function should this process call to do its work? Enter the optional entry point only in this field.
"^DD",779.3,779.3,.1,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.1,21,1,0)
The M entry point for the process's DO WORK function.
"^DD",779.3,779.3,.1,"DT")
3041115
"^DD",779.3,779.3,.11,0)
DO WORK FUNCTION (ROUTINE)^F^^0;11^K:$L(X)>8!($L(X)<1) X
"^DD",779.3,779.3,.11,3)
What function should this process call to do its work?  Enter the routine name only in this field.
"^DD",779.3,779.3,.11,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.11,21,1,0)
The routine in which the process's DO WORK function is located.
"^DD",779.3,779.3,.11,"DT")
3041115
"^DD",779.3,779.3,.12,0)
MAX TRIES FINDING WORK^NJ4,0^^0;12^K:+X'=X!(X>9999)!(X<0)!(X?.E1"."1.N) X
"^DD",779.3,779.3,.12,3)
How many times should the process look for work before giving up?
"^DD",779.3,779.3,.12,21,0)
^^3^3^3041115^
"^DD",779.3,779.3,.12,21,1,0)
How many times should the process look for work and then quit if it 
"^DD",779.3,779.3,.12,21,2,0)
cannot find anything to do?  It'll hang between attempts the specified 
"^DD",779.3,779.3,.12,21,3,0)
length of time.
"^DD",779.3,779.3,.12,"DT")
3041115
"^DD",779.3,779.3,.13,0)
PERSISTENT^S^0:NO;1:YES;^0;13^Q
"^DD",779.3,779.3,.13,3)
Should processes of this type be restarted automatically if they die?
"^DD",779.3,779.3,.13,21,0)
^^2^2^3041115^
"^DD",779.3,779.3,.13,21,1,0)
Setting this field to YES results in the process being made persistent 
"^DD",779.3,779.3,.13,21,2,0)
via the Taskman persistent parameter.
"^DD",779.3,779.3,.13,"DT")
3041115
"^DD",779.3,779.3,.14,0)
DEDICATED LINK^FX^^0;14^K:$L(X)>10!($L(X)<3) X
"^DD",779.3,779.3,.14,3)
If this process is a listener, you must enter the name of an HL LOGICAL LINK that is a listener and whose TCP/IP PORT (OPTIMIZED) field contains the correct port number.
"^DD",779.3,779.3,.14,4)

"^DD",779.3,779.3,.14,21,0)
^^4^4^3041115^
"^DD",779.3,779.3,.14,21,1,0)
The primary use of this field is for TCP/IP listener processes, and 
"^DD",779.3,779.3,.14,21,2,0)
indicates which port (via the HL Logical Link) that the process should be 
"^DD",779.3,779.3,.14,21,3,0)
listening on.  However, it could be used to dedicate a client link 
"^DD",779.3,779.3,.14,21,4,0)
process to a particular link.
"^DD",779.3,779.3,.14,"DT")
3050706
"^DD",779.3,779.3,.15,0)
VMS TCP SERVICE^S^1:YES;0:NO;^0;15^Q
"^DD",779.3,779.3,.15,3)
If this process is a listener, enter YES if it is a VMS TCP service rather than a Taskman process.
"^DD",779.3,779.3,.15,21,0)
^^5^5^3040923^
"^DD",779.3,779.3,.15,21,1,0)
VMS services are not started or stopped via the HL7 Process Manager.  
"^DD",779.3,779.3,.15,21,2,0)
However, on a VMS system, these services are an important part of the HL7
"^DD",779.3,779.3,.15,21,3,0)
system, and so an entry in the HL7 Process Registry should be created for 
"^DD",779.3,779.3,.15,21,4,0)
them.  The Process Manager will use the PING functionality to verify that 
"^DD",779.3,779.3,.15,21,5,0)
the listener is running.
"^DD",779.3,779.3,.15,"DT")
3040923
"^DD",870,870,16,0)
SHUTDOWN OUTGOING HLO MESSAGES^S^0:NO;1:YES;^0;16^Q
"^DD",870,870,16,3)
Enter YES to stop HLO messages from being transmitted to this destinations.
"^DD",870,870,16,21,0)
^^2^2^3050914^
"^DD",870,870,16,21,1,0)
This field affects only HLO messages.
"^DD",870,870,16,21,2,0)

"^DD",870,870,16,"DT")
3050914
"^DIC",779.3,779.3,0)
HLO PROCESS REGISTRY^779.3
"^DIC",779.3,779.3,0,"GL")
^HLD(779.3,
"^DIC",779.3,779.3,"%",0)
^1.005^^0
"^DIC",779.3,779.3,"%D",0)
^^2^2^3050801^^^
"^DIC",779.3,779.3,"%D",1,0)
The process registry is used by the HLO process manager to start, stop, and
"^DIC",779.3,779.3,"%D",2,0)
manage all of the processes used by the HLO system.
"^DIC",779.3,"B","HLO PROCESS REGISTRY",779.3)

"BLD",908,6)
^102
**END**
**END**
