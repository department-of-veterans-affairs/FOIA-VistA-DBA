Verified XU*8*2 SEQ #3
Extracted from mail message
**KIDS**:XU*8.0*2^

**INSTALL NAME**
XU*8.0*2
"BLD",59,0)
XU*8.0*2^KERNEL^0^2950926^y
"BLD",59,1,0)
^^128^128^2950926^
"BLD",59,1,1,0)
This is Patch 2 to Kernel version 8.0.  It is in KIDS format and you must
"BLD",59,1,2,0)
use the KIDS options to install it. This patch contains Taskman routines.
"BLD",59,1,3,0)
You should put Taskman in a wait state and stop the submanager before moving
"BLD",59,1,4,0)
the Taskman routines to your Manager account.
"BLD",59,1,5,0)
========================================================================= 
"BLD",59,1,6,0)
INSTALLATION:
"BLD",59,1,7,0)
 
"BLD",59,1,8,0)
 1. Use the 'INSTALL/CHECK MESSAGE' option on the PackMan menu. This
"BLD",59,1,9,0)
    option will load the KIDS package in this message onto your system.
"BLD",59,1,10,0)
 2. Answer NO to the question:
"BLD",59,1,11,0)
    'Shall I preserve what is on disk in a separate back-up message ?'
"BLD",59,1,12,0)
 3. The patch has now been loaded into a Transport global on your system.
"BLD",59,1,13,0)
    You now need to use KIDS to install the Transport global.
"BLD",59,1,14,0)
 4. On the KIDS menu, under the 'Installation' menu, use the option
"BLD",59,1,15,0)
    'Install Package(s)'.
"BLD",59,1,16,0)
    Select the package 'XU*8.0*2' and proceed with install.
"BLD",59,1,17,0)
 5. After installing this patch, you need to move the following 2 routines
"BLD",59,1,18,0)
    from your productions account to the manager account:
"BLD",59,1,19,0)
    ZTMS
"BLD",59,1,20,0)
    ZTMS2
"BLD",59,1,21,0)
 6. In the manager account rename the 2 routines;  i.e.  ZL ZTMS ZS %ZTMS
"BLD",59,1,22,0)
    ZTMS     to  %ZTMS
"BLD",59,1,23,0)
    ZTMS2    to  %ZTMS2
"BLD",59,1,24,0)
 7. If you are a 486 Site, you should now move the 2 routines; %ZTMS &
"BLD",59,1,25,0)
    %ZTMS2 to the Manager account on you other CPU's. You also should
"BLD",59,1,26,0)
    move the routine XPDIJ from your production account to the production
"BLD",59,1,27,0)
    account on the other CPU's.
"BLD",59,1,28,0)
 8. Remove Taskman from wait state
"BLD",59,1,29,0)
========================================================================= 
"BLD",59,1,30,0)
 
"BLD",59,1,31,0)
The Routine XUTMOPT has new entry points to allow other packages to
"BLD",59,1,32,0)
edit
"BLD",59,1,33,0)
the OPTION SCHEDULING file (#19.2).
"BLD",59,1,34,0)
 
"BLD",59,1,35,0)
These new entry points include the following:
"BLD",59,1,36,0)
 
"BLD",59,1,37,0)
 
"BLD",59,1,38,0)
* EDIT^XUTMOPT: Edit an Option
"BLD",59,1,39,0)
 
"BLD",59,1,40,0)
Usage  D EDIT^XUTMOPT(option_name)
"BLD",59,1,41,0)
 
"BLD",59,1,42,0)
Input  option_name:    Name of the option to be edited.
"BLD",59,1,43,0)
 
"BLD",59,1,44,0)
Output none
"BLD",59,1,45,0)
 
"BLD",59,1,46,0)
Description
"BLD",59,1,47,0)
 
"BLD",59,1,48,0)
This entry point allows users to edit an option's scheduling in the
"BLD",59,1,49,0)
OPTION
"BLD",59,1,50,0)
SCHEDULING file (#19.2).
"BLD",59,1,51,0)
 
"BLD",59,1,52,0)
 
"BLD",59,1,53,0)
* DISP^XUTMOPT: Display an Option
"BLD",59,1,54,0)
 
"BLD",59,1,55,0)
Usage  D DISP^XUTMOPT(option_name)
"BLD",59,1,56,0)
 
"BLD",59,1,57,0)
Input  option_name:    Name of the option to be displayed.
"BLD",59,1,58,0)
 
"BLD",59,1,59,0)
Output none
"BLD",59,1,60,0)
 
"BLD",59,1,61,0)
Description
"BLD",59,1,62,0)
 
"BLD",59,1,63,0)
This entry point is used to display the schedule for an option.
"BLD",59,1,64,0)
 
"BLD",59,1,65,0)
 
"BLD",59,1,66,0)
* RESCH^XUTMOPT: Reschedule an Option
"BLD",59,1,67,0)
 
"BLD",59,1,68,0)
Usage  D RESCH^XUTMOPT(option_name,when_to_run,device_to_use,
"BLD",59,1,69,0)
re-schedule_freq,flags,error_array)
"BLD",59,1,70,0)
 
"BLD",59,1,71,0)
Input option_name:    Name of the option to be rescheduled.
"BLD",59,1,72,0)
 
"BLD",59,1,73,0)
      when_to_run:    (optional)
"BLD",59,1,74,0)
                      The new scheduled time for the option to run.
"BLD",59,1,75,0)
 
"BLD",59,1,76,0)
      device_to_use:  (optional)
"BLD",59,1,77,0)
                      The device to use for the rescheduled option.
"BLD",59,1,78,0)
 
"BLD",59,1,79,0)
   re-schedule_freq:  (optional)
"BLD",59,1,80,0)
                      The frequency to run the rescheduled option.
"BLD",59,1,81,0)
 
"BLD",59,1,82,0)
      flags:          (optional) If the flag is set to an 'L' LAYGO
"BLD",59,1,83,0)
                      a new entry if needed.
"BLD",59,1,84,0)
 
"BLD",59,1,85,0)
     error_array:     (optional) Pass by reference. Will be set to -1
"BLD",59,1,86,0)
                      if the option was not found.
"BLD",59,1,87,0)
 
"BLD",59,1,88,0)
Output none
"BLD",59,1,89,0)
 
"BLD",59,1,90,0)
Description
"BLD",59,1,91,0)
 
"BLD",59,1,92,0)
This entry point allows an application to set-up the schedule for an
"BLD",59,1,93,0)
option.
"BLD",59,1,94,0)
 
"BLD",59,1,95,0)
XUTMR had a bug in the Taskman Requeue code.
"BLD",59,1,96,0)
When the question 'Do you wish to change the Device the task goes to:' was
"BLD",59,1,97,0)
answered NO. Then it would delete the output device.
"BLD",59,1,98,0)
 
"BLD",59,1,99,0)
XUTMRP and XUTMRP1 are new routines that allow a site to redirect tasks
"BLD",59,1,100,0)
that are waiting for a particular device to be rescheduled to a new
"BLD",59,1,101,0)
device. The options to invoke these routines can be found on the Taskman
"BLD",59,1,102,0)
Management Utilities menu.
"BLD",59,1,103,0)
 
"BLD",59,1,104,0)
There are updates to the DD for the following two fields of the NEW PERSON
"BLD",59,1,105,0)
file (#200): VOICE PAGER (#.137) and DIGITAL PAGER (#.138). These fields
"BLD",59,1,106,0)
now allow three digit pager numbers.
"BLD",59,1,107,0)
 
"BLD",59,1,108,0)
XUVERIFY had a bug that prevented the use of a '?' in the access/verify
"BLD",59,1,109,0)
code pair. This has been fix.
"BLD",59,1,110,0)
 
"BLD",59,1,111,0)
ZTMS and ZTMS2 have fixes to problems found after K8 release.  That relate
"BLD",59,1,112,0)
to leaving IO("C") around, also fixed in Kernel 7.1.  %ZTMS2 also does a
"BLD",59,1,113,0)
check to see that %ZTIO and IO are the same. If not record in the TM error
"BLD",59,1,114,0)
log and CLOSE %ZTIO and set to IO.  This may be why 2 devices get opened
"BLD",59,1,115,0)
at once.
"BLD",59,1,116,0)
 
"BLD",59,1,117,0)
XPDE, XPDIA1 have been updated so that KIDS now supports List Manager
"BLD",59,1,118,0)
templates and Remote Procedures for the Kernel RPC Broker.
"BLD",59,1,119,0)
 
"BLD",59,1,120,0)
XPDT returns error message if HFS filename is rejected by Device Handler.
"BLD",59,1,121,0)
 
"BLD",59,1,122,0)
XPDR has been enhanced to allow purging of Build and Install files at the
"BLD",59,1,123,0)
same time.
"BLD",59,1,124,0)
 
"BLD",59,1,125,0)
XPDDCS will now check that routines in the transport global have header nodes.
"BLD",59,1,126,0)
 
"BLD",59,1,127,0)
XPDIJ doesn't display the message, 'Data already Installed', if there was no
"BLD",59,1,128,0)
data sent.
"BLD",59,4,0)
^9.64PA^200^1
"BLD",59,4,200,0)
200
"BLD",59,4,200,2,0)
^9.641^200^1
"BLD",59,4,200,2,200,0)
NEW PERSON  (File-top level)
"BLD",59,4,200,2,200,1,0)
^9.6411^.138^2
"BLD",59,4,200,2,200,1,.137,0)
VOICE PAGER
"BLD",59,4,200,2,200,1,.138,0)
DIGITAL PAGER
"BLD",59,4,200,222)
y^y^p^^^^n
"BLD",59,4,"APDD",200,200)

"BLD",59,4,"APDD",200,200,.137)

"BLD",59,4,"APDD",200,200,.138)

"BLD",59,4,"B",200,200)

"BLD",59,"KRN",0)
^9.67PA^.84^14
"BLD",59,"KRN",.4,0)
.4
"BLD",59,"KRN",.401,0)
.401
"BLD",59,"KRN",.402,0)
.402
"BLD",59,"KRN",.403,0)
.403
"BLD",59,"KRN",.5,0)
.5
"BLD",59,"KRN",.84,0)
.84
"BLD",59,"KRN",3.6,0)
3.6
"BLD",59,"KRN",9.2,0)
9.2
"BLD",59,"KRN",9.2,"NM",0)
^9.68A^2^2
"BLD",59,"KRN",9.2,"NM",1,0)
XUTM DELETE TASK^^0
"BLD",59,"KRN",9.2,"NM",2,0)
XUTM OPTION QUES^^0
"BLD",59,"KRN",9.2,"NM","B","XUTM DELETE TASK",1)

"BLD",59,"KRN",9.2,"NM","B","XUTM OPTION QUES",2)

"BLD",59,"KRN",9.8,0)
9.8
"BLD",59,"KRN",9.8,"NM",0)
^9.68A^14^13
"BLD",59,"KRN",9.8,"NM",1,0)
XUTMOPT^^0^B4988561
"BLD",59,"KRN",9.8,"NM",2,0)
XUTMRP^^0^B29524049
"BLD",59,"KRN",9.8,"NM",3,0)
XUTMRP1^^0^B12591026
"BLD",59,"KRN",9.8,"NM",4,0)
XUVERIFY^^0^B5113084
"BLD",59,"KRN",9.8,"NM",5,0)
ZTMS^^0^B14347508
"BLD",59,"KRN",9.8,"NM",6,0)
ZTMS2^^0^B17988369
"BLD",59,"KRN",9.8,"NM",9,0)
XPDE^^0^B30440657
"BLD",59,"KRN",9.8,"NM",10,0)
XPDIA1^^0^B13227203
"BLD",59,"KRN",9.8,"NM",11,0)
XPDT^^0^B29809851
"BLD",59,"KRN",9.8,"NM",12,0)
XPDR^^0^B35753744
"BLD",59,"KRN",9.8,"NM",13,0)
XPDDCS^^0^B7639567
"BLD",59,"KRN",9.8,"NM",14,0)
XPDIJ^^0^B40021653
"BLD",59,"KRN",9.8,"NM",15,0)
XUTMR^^0^B13199147
"BLD",59,"KRN",9.8,"NM","B","XPDDCS",13)

"BLD",59,"KRN",9.8,"NM","B","XPDE",9)

"BLD",59,"KRN",9.8,"NM","B","XPDIA1",10)

"BLD",59,"KRN",9.8,"NM","B","XPDIJ",14)

"BLD",59,"KRN",9.8,"NM","B","XPDR",12)

"BLD",59,"KRN",9.8,"NM","B","XPDT",11)

"BLD",59,"KRN",9.8,"NM","B","XUTMOPT",1)

"BLD",59,"KRN",9.8,"NM","B","XUTMR",15)

"BLD",59,"KRN",9.8,"NM","B","XUTMRP",2)

"BLD",59,"KRN",9.8,"NM","B","XUTMRP1",3)

"BLD",59,"KRN",9.8,"NM","B","XUVERIFY",4)

"BLD",59,"KRN",9.8,"NM","B","ZTMS",5)

"BLD",59,"KRN",9.8,"NM","B","ZTMS2",6)

"BLD",59,"KRN",19,0)
19
"BLD",59,"KRN",19,"NM",0)
^9.68A^3^3
"BLD",59,"KRN",19,"NM",1,0)
XUTM RP^^0
"BLD",59,"KRN",19,"NM",2,0)
XUTM REPNT^^0
"BLD",59,"KRN",19,"NM",3,0)
XUTM UTIL^^2
"BLD",59,"KRN",19,"NM","B","XUTM REPNT",2)

"BLD",59,"KRN",19,"NM","B","XUTM RP",1)

"BLD",59,"KRN",19,"NM","B","XUTM UTIL",3)

"BLD",59,"KRN",19.1,0)
19.1
"BLD",59,"KRN",101,0)
101
"BLD",59,"KRN",409.61,0)
409.61
"BLD",59,"KRN",8995,0)
8995
"BLD",59,"KRN","B",.4,.4)

"BLD",59,"KRN","B",.401,.401)

"BLD",59,"KRN","B",.402,.402)

"BLD",59,"KRN","B",.403,.403)

"BLD",59,"KRN","B",.5,.5)

"BLD",59,"KRN","B",.84,.84)

"BLD",59,"KRN","B",3.6,3.6)

"BLD",59,"KRN","B",9.2,9.2)

"BLD",59,"KRN","B",9.8,9.8)

"BLD",59,"KRN","B",19,19)

"BLD",59,"KRN","B",19.1,19.1)

"BLD",59,"KRN","B",101,101)

"BLD",59,"KRN","B",409.61,409.61)

"BLD",59,"KRN","B",8995,8995)

"BLD",59,"QUES",0)
^9.62^^
"FIA",200)
NEW PERSON
"FIA",200,0)
^VA(200,
"FIA",200,0,0)
200I
"FIA",200,0,1)
y^y^p^^^^n
"FIA",200,0,10)

"FIA",200,0,11)

"FIA",200,0,"RLRO")

"FIA",200,0,"VR")
8.0^XU
"FIA",200,200)
1
"FIA",200,200,.137)

"FIA",200,200,.138)

"KRN",9.2,778,-1)
0^1
"KRN",9.2,778,0)
XUTM DELETE TASK^DELETE TASKS^2950321.15223^^
"KRN",9.2,778,1,0)
^^7^7^2950321^
"KRN",9.2,778,1,1,0)
 If [NO] you will be given another oppportunity to re-direct the task to a
"KRN",9.2,778,1,2,0)
device.
"KRN",9.2,778,1,3,0)
 If you still do not choose a device then you will have to manually
"KRN",9.2,778,1,4,0)
requeue this task using the requeue a task option in your taskman menu.
"KRN",9.2,778,1,5,0)
  
"KRN",9.2,778,1,6,0)
 If [YES] the task will be deleted from taskman.  If [YES] the task will
"KRN",9.2,778,1,7,0)
be deleted from taskman.
"KRN",9.2,779,-1)
0^2
"KRN",9.2,779,0)
XUTM OPTION QUES^CHANGE DEVICE IN OPTION FILE^2950321.152827^^
"KRN",9.2,779,1,0)
^^7^7^2950321^
"KRN",9.2,779,1,1,0)
                       You must answer [YES] or [NO] 
"KRN",9.2,779,1,2,0)
  
"KRN",9.2,779,1,3,0)
 [YES] If the task is automatically re-schedule by TaskMan, it will be
"KRN",9.2,779,1,4,0)
tasked to the new printer.
"KRN",9.2,779,1,5,0)
  
"KRN",9.2,779,1,6,0)
  
"KRN",9.2,779,1,7,0)
 [NO] Automatic re-scheduling by TaskMan will be to original printer.  
"KRN",19,464,-1)
2^3
"KRN",19,464,0)
XUTM UTIL^Taskman Management Utilities^^M^^^^^^^^TASK MANAGER^^
"KRN",19,464,1,0)
^^1^1^2910225^^^^
"KRN",19,464,1,1,0)
This menu contains options to assist in managing Taskman.
"KRN",19,464,10,0)
^19.01IP^15^12
"KRN",19,464,10,14,0)
1353
"KRN",19,464,10,14,"^")
XUTM RP
"KRN",19,464,10,15,0)
1352
"KRN",19,464,10,15,"^")
XUTM REPNT
"KRN",19,464,99)
56496,41509
"KRN",19,464,"U")
TASKMAN MANAGEMENT UTILITIES
"KRN",19,1352,-1)
0^2
"KRN",19,1352,0)
XUTM REPNT^Repoint waiting tasks to a new port/device^^R^^^^^^^^KERNEL
"KRN",19,1352,1,0)
^^4^4^2950905^^
"KRN",19,1352,1,1,0)
This option will allow the site staff to take all tasks waiting for a
"KRN",19,1352,1,2,0)
given port/LTA device and reschedule them to some new device and/or to a
"KRN",19,1352,1,3,0)
new time.  This is useful when a port stops working and the tasks backed
"KRN",19,1352,1,4,0)
up waiting for it can be sent to another device untill it is fixed.
"KRN",19,1352,25)
REPNT^XUTMRP
"KRN",19,1352,"U")
REPOINT WAITING TASKS TO A NEW
"KRN",19,1353,-1)
0^1
"KRN",19,1353,0)
XUTM RP^Change tasks device^^R^^^^^^^^KERNEL
"KRN",19,1353,1,0)
^^5^5^2950821^
"KRN",19,1353,1,1,0)
This option will allow site staff to indicate a replacement device and to
"KRN",19,1353,1,2,0)
then repoint and waiting and future tasks to the new device.
"KRN",19,1353,1,3,0)
This is useful when a site renames devices or device becomes deadicated to
"KRN",19,1353,1,4,0)
a special task. The option can also go thru the OPTION SCVHEDULING file to
"KRN",19,1353,1,5,0)
repoint devices in this file.
"KRN",19,1353,25)
XUTMRP
"KRN",19,1353,"U")
CHANGE TASKS DEVICE
"ORD",1,9.2)
9.2;1;;;HELP^XPDTA1;HLPF1^XPDIA1;HLPE1^XPDIA1;HLPF2^XPDIA1;;HLPDEL^XPDIA1
"ORD",1,9.2,0)
HELP FRAME
"ORD",12,19)
19;12;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",12,19,0)
OPTION
"PKG",283,-1)
21^2
"PKG",283,0)
KERNEL^XU^SIGN-ON, SECURITY, MENU DRIVER, DEVICES, TASKMAN^
"PKG",283,1,0)
^^1^1^2950921^
"PKG",283,1,1,0)
This is the basic package containing the KERNEL.
"PKG",283,2,0)
^9.42A^^0
"PKG",283,3,0)
^9.43^^0
"PKG",283,4,0)
^9.44AP^^0
"PKG",283,5)
SAN FRANCISCO
"PKG",283,7)
^^I
"PKG",283,8,0)
^9.404ID^^0
"PKG",283,11)
^
"PKG",283,20,0)
^9.402P^^0
"PKG",283,22,0)
^9.49I^21^5
"PKG",283,22,6,0)
6^2890609^2880718
"PKG",283,22,6.5,0)
6.5^2890807
"PKG",283,22,7,0)
7^2920831
"PKG",283,22,8,0)
7.1^2930507^2930125
"PKG",283,22,21,0)
8.0^2950729^2950729^6
"PKG",283,22,21,"PAH",0)
^9.4901^3^3
"PKG",283,22,21,"PAH",1,0)
1^2950728
"PKG",283,22,21,"PAH",1,1,0)
^^43^43^2950901^
"PKG",283,22,21,"PAH",1,1,1,0)
This is patch 1 of Kernel 8.0. All of the changes in this patch were
"PKG",283,22,21,"PAH",1,1,2,0)
made after verification. This patch was sent as a seperate file with
"PKG",283,22,21,"PAH",1,1,3,0)
the Kernel 8.0 distribution.
"PKG",283,22,21,"PAH",1,1,4,0)

"PKG",283,22,21,"PAH",1,1,5,0)
Routines:
"PKG",283,22,21,"PAH",1,1,6,0)
ORF2     - Corrects error when deleting OERR Alerts.
"PKG",283,22,21,"PAH",1,1,7,0)
XPDR     - Purge Build/Install file option will now find patches.
"PKG",283,22,21,"PAH",1,1,8,0)
XQ1      - Corrects undefined error if the variable ZTMQUEUED is killed in
"PKG",283,22,21,"PAH",1,1,9,0)
           an queued task.
"PKG",283,22,21,"PAH",1,1,10,0)
XQALDOIT - New API call, DOOPT.
"PKG",283,22,21,"PAH",1,1,11,0)
XQALERT  - New API call, GETACT.
"PKG",283,22,21,"PAH",1,1,12,0)
XQALSET  - Corrects undefined error when two people process Alerts at
"PKG",283,22,21,"PAH",1,1,13,0)
           the same time.
"PKG",283,22,21,"PAH",1,1,14,0)
XUFILE   - Grant File Access option will now accept file numbers with
"PKG",283,22,21,"PAH",1,1,15,0)
           up to 5 decimal places.
"PKG",283,22,21,"PAH",1,1,16,0)
XUTMTDL  - Correct undefine error when deleting list of Taskman tasks.
"PKG",283,22,21,"PAH",1,1,17,0)
ZTLOAD2  - Restricted Queue on an option will now default to the correct
"PKG",283,22,21,"PAH",1,1,18,0)
           date/time.
"PKG",283,22,21,"PAH",1,1,19,0)
ZTMS3    - Corrects no-open error in Taskman, caused when IO("C") is left
"PKG",283,22,21,"PAH",1,1,20,0)
           defined by task.
"PKG",283,22,21,"PAH",1,1,21,0)

"PKG",283,22,21,"PAH",1,1,22,0)
ZTM4,    - Corrects the hanging of Taskman Submanagers on ^ZTSCH("IO") when
"PKG",283,22,21,"PAH",1,1,23,0)
ZTMS7      printer is off-line.
"PKG",283,22,21,"PAH",1,1,24,0)

"PKG",283,22,21,"PAH",1,1,25,0)
Option:
"PKG",283,22,21,"PAH",1,1,26,0)
XU OPTION START - Entry action will now be executed on queued options.
"PKG",283,22,21,"PAH",1,1,27,0)

"PKG",283,22,21,"PAH",1,1,28,0)
Installation:
"PKG",283,22,21,"PAH",1,1,29,0)
 1. Before installing this patch, you should inhibit users from login,
"PKG",283,22,21,"PAH",1,1,30,0)
    shutdown Taskman and remove users from system.
"PKG",283,22,21,"PAH",1,1,31,0)
 2. After installing this patch, you need to move the following 4 routines
"PKG",283,22,21,"PAH",1,1,32,0)
    from your productions account to the manager account:
"PKG",283,22,21,"PAH",1,1,33,0)
    ZTLOAD2
"PKG",283,22,21,"PAH",1,1,34,0)
    ZTM4
"PKG",283,22,21,"PAH",1,1,35,0)
    ZTMS3
"PKG",283,22,21,"PAH",1,1,36,0)
    ZTMS7
"PKG",283,22,21,"PAH",1,1,37,0)
 3. Rename the routines as follows:
"PKG",283,22,21,"PAH",1,1,38,0)
    ZL ZTLOAD2 ZS %ZTLOAD2
"PKG",283,22,21,"PAH",1,1,39,0)
    ZL ZTM4 ZS %ZTM4
"PKG",283,22,21,"PAH",1,1,40,0)
    ZL ZTMS3 ZS %ZTMS3
"PKG",283,22,21,"PAH",1,1,41,0)
    ZL ZTMS7 ZS %ZTMS7
"PKG",283,22,21,"PAH",1,1,42,0)
 4. Un-inhibit users from login and restart Taskman.
"PKG",283,22,21,"PAH",1,1,43,0)

"PKG",283,22,21,"PAH",2,0)
2^2950926
"PKG",283,22,21,"PAH",2,1,0)
^^128^128^2950926
"PKG",283,22,21,"PAH",2,1,1,0)
This is Patch 2 to Kernel version 8.0.  It is in KIDS format and you must
"PKG",283,22,21,"PAH",2,1,2,0)
use the KIDS options to install it. This patch contains Taskman routines.
"PKG",283,22,21,"PAH",2,1,3,0)
You should put Taskman in a wait state and stop the submanager before moving
"PKG",283,22,21,"PAH",2,1,4,0)
the Taskman routines to your Manager account.
"PKG",283,22,21,"PAH",2,1,5,0)
========================================================================= 
"PKG",283,22,21,"PAH",2,1,6,0)
INSTALLATION:
"PKG",283,22,21,"PAH",2,1,7,0)
 
"PKG",283,22,21,"PAH",2,1,8,0)
 1. Use the 'INSTALL/CHECK MESSAGE' option on the PackMan menu. This
"PKG",283,22,21,"PAH",2,1,9,0)
    option will load the KIDS package in this message onto your system.
"PKG",283,22,21,"PAH",2,1,10,0)
 2. Answer NO to the question:
"PKG",283,22,21,"PAH",2,1,11,0)
    'Shall I preserve what is on disk in a separate back-up message ?'
"PKG",283,22,21,"PAH",2,1,12,0)
 3. The patch has now been loaded into a Transport global on your system.
"PKG",283,22,21,"PAH",2,1,13,0)
    You now need to use KIDS to install the Transport global.
"PKG",283,22,21,"PAH",2,1,14,0)
 4. On the KIDS menu, under the 'Installation' menu, use the option
"PKG",283,22,21,"PAH",2,1,15,0)
    'Install Package(s)'.
"PKG",283,22,21,"PAH",2,1,16,0)
    Select the package 'XU*8.0*2' and proceed with install.
"PKG",283,22,21,"PAH",2,1,17,0)
 5. After installing this patch, you need to move the following 2 routines
"PKG",283,22,21,"PAH",2,1,18,0)
    from your productions account to the manager account:
"PKG",283,22,21,"PAH",2,1,19,0)
    ZTMS
"PKG",283,22,21,"PAH",2,1,20,0)
    ZTMS2
"PKG",283,22,21,"PAH",2,1,21,0)
 6. In the manager account rename the 2 routines;  i.e.  ZL ZTMS ZS %ZTMS
"PKG",283,22,21,"PAH",2,1,22,0)
    ZTMS     to  %ZTMS
"PKG",283,22,21,"PAH",2,1,23,0)
    ZTMS2    to  %ZTMS2
"PKG",283,22,21,"PAH",2,1,24,0)
 7. If you are a 486 Site, you should now move the 2 routines; %ZTMS &
"PKG",283,22,21,"PAH",2,1,25,0)
    %ZTMS2 to the Manager account on you other CPU's. You also should
"PKG",283,22,21,"PAH",2,1,26,0)
    move the routine XPDIJ from your production account to the production
"PKG",283,22,21,"PAH",2,1,27,0)
    account on the other CPU's.
"PKG",283,22,21,"PAH",2,1,28,0)
 8. Remove Taskman from wait state
"PKG",283,22,21,"PAH",2,1,29,0)
========================================================================= 
"PKG",283,22,21,"PAH",2,1,30,0)
 
"PKG",283,22,21,"PAH",2,1,31,0)
The Routine XUTMOPT has new entry points to allow other packages to
"PKG",283,22,21,"PAH",2,1,32,0)
edit
"PKG",283,22,21,"PAH",2,1,33,0)
the OPTION SCHEDULING file (#19.2).
"PKG",283,22,21,"PAH",2,1,34,0)
 
"PKG",283,22,21,"PAH",2,1,35,0)
These new entry points include the following:
"PKG",283,22,21,"PAH",2,1,36,0)
 
"PKG",283,22,21,"PAH",2,1,37,0)
 
"PKG",283,22,21,"PAH",2,1,38,0)
* EDIT^XUTMOPT: Edit an Option
"PKG",283,22,21,"PAH",2,1,39,0)
 
"PKG",283,22,21,"PAH",2,1,40,0)
Usage  D EDIT^XUTMOPT(option_name)
"PKG",283,22,21,"PAH",2,1,41,0)
 
"PKG",283,22,21,"PAH",2,1,42,0)
Input  option_name:    Name of the option to be edited.
"PKG",283,22,21,"PAH",2,1,43,0)
 
"PKG",283,22,21,"PAH",2,1,44,0)
Output none
"PKG",283,22,21,"PAH",2,1,45,0)
 
"PKG",283,22,21,"PAH",2,1,46,0)
Description
"PKG",283,22,21,"PAH",2,1,47,0)
 
"PKG",283,22,21,"PAH",2,1,48,0)
This entry point allows users to edit an option's scheduling in the
"PKG",283,22,21,"PAH",2,1,49,0)
OPTION
"PKG",283,22,21,"PAH",2,1,50,0)
SCHEDULING file (#19.2).
"PKG",283,22,21,"PAH",2,1,51,0)
 
"PKG",283,22,21,"PAH",2,1,52,0)
 
"PKG",283,22,21,"PAH",2,1,53,0)
* DISP^XUTMOPT: Display an Option
"PKG",283,22,21,"PAH",2,1,54,0)
 
"PKG",283,22,21,"PAH",2,1,55,0)
Usage  D DISP^XUTMOPT(option_name)
"PKG",283,22,21,"PAH",2,1,56,0)
 
"PKG",283,22,21,"PAH",2,1,57,0)
Input  option_name:    Name of the option to be displayed.
"PKG",283,22,21,"PAH",2,1,58,0)
 
"PKG",283,22,21,"PAH",2,1,59,0)
Output none
"PKG",283,22,21,"PAH",2,1,60,0)
 
"PKG",283,22,21,"PAH",2,1,61,0)
Description
"PKG",283,22,21,"PAH",2,1,62,0)
 
"PKG",283,22,21,"PAH",2,1,63,0)
This entry point is used to display the schedule for an option.
"PKG",283,22,21,"PAH",2,1,64,0)
 
"PKG",283,22,21,"PAH",2,1,65,0)
 
"PKG",283,22,21,"PAH",2,1,66,0)
* RESCH^XUTMOPT: Reschedule an Option
"PKG",283,22,21,"PAH",2,1,67,0)
 
"PKG",283,22,21,"PAH",2,1,68,0)
Usage  D RESCH^XUTMOPT(option_name,when_to_run,device_to_use,
"PKG",283,22,21,"PAH",2,1,69,0)
re-schedule_freq,flags,error_array)
"PKG",283,22,21,"PAH",2,1,70,0)
 
"PKG",283,22,21,"PAH",2,1,71,0)
Input option_name:    Name of the option to be rescheduled.
"PKG",283,22,21,"PAH",2,1,72,0)
 
"PKG",283,22,21,"PAH",2,1,73,0)
      when_to_run:    (optional)
"PKG",283,22,21,"PAH",2,1,74,0)
                      The new scheduled time for the option to run.
"PKG",283,22,21,"PAH",2,1,75,0)
 
"PKG",283,22,21,"PAH",2,1,76,0)
      device_to_use:  (optional)
"PKG",283,22,21,"PAH",2,1,77,0)
                      The device to use for the rescheduled option.
"PKG",283,22,21,"PAH",2,1,78,0)
 
"PKG",283,22,21,"PAH",2,1,79,0)
   re-schedule_freq:  (optional)
"PKG",283,22,21,"PAH",2,1,80,0)
                      The frequency to run the rescheduled option.
"PKG",283,22,21,"PAH",2,1,81,0)
 
"PKG",283,22,21,"PAH",2,1,82,0)
      flags:          (optional) If the flag is set to an 'L' LAYGO
"PKG",283,22,21,"PAH",2,1,83,0)
                      a new entry if needed.
"PKG",283,22,21,"PAH",2,1,84,0)
 
"PKG",283,22,21,"PAH",2,1,85,0)
     error_array:     (optional) Pass by reference. Will be set to -1
"PKG",283,22,21,"PAH",2,1,86,0)
                      if the option was not found.
"PKG",283,22,21,"PAH",2,1,87,0)
 
"PKG",283,22,21,"PAH",2,1,88,0)
Output none
"PKG",283,22,21,"PAH",2,1,89,0)
 
"PKG",283,22,21,"PAH",2,1,90,0)
Description
"PKG",283,22,21,"PAH",2,1,91,0)
 
"PKG",283,22,21,"PAH",2,1,92,0)
This entry point allows an application to set-up the schedule for an
"PKG",283,22,21,"PAH",2,1,93,0)
option.
"PKG",283,22,21,"PAH",2,1,94,0)
 
"PKG",283,22,21,"PAH",2,1,95,0)
XUTMR had a bug in the Taskman Requeue code.
"PKG",283,22,21,"PAH",2,1,96,0)
When the question 'Do you wish to change the Device the task goes to:' was
"PKG",283,22,21,"PAH",2,1,97,0)
answered NO. Then it would delete the output device.
"PKG",283,22,21,"PAH",2,1,98,0)
 
"PKG",283,22,21,"PAH",2,1,99,0)
XUTMRP and XUTMRP1 are new routines that allow a site to redirect tasks
"PKG",283,22,21,"PAH",2,1,100,0)
that are waiting for a particular device to be rescheduled to a new
"PKG",283,22,21,"PAH",2,1,101,0)
device. The options to invoke these routines can be found on the Taskman
"PKG",283,22,21,"PAH",2,1,102,0)
Management Utilities menu.
"PKG",283,22,21,"PAH",2,1,103,0)
 
"PKG",283,22,21,"PAH",2,1,104,0)
There are updates to the DD for the following two fields of the NEW PERSON
"PKG",283,22,21,"PAH",2,1,105,0)
file (#200): VOICE PAGER (#.137) and DIGITAL PAGER (#.138). These fields
"PKG",283,22,21,"PAH",2,1,106,0)
now allow three digit pager numbers.
"PKG",283,22,21,"PAH",2,1,107,0)
 
"PKG",283,22,21,"PAH",2,1,108,0)
XUVERIFY had a bug that prevented the use of a '?' in the access/verify
"PKG",283,22,21,"PAH",2,1,109,0)
code pair. This has been fix.
"PKG",283,22,21,"PAH",2,1,110,0)
 
"PKG",283,22,21,"PAH",2,1,111,0)
ZTMS and ZTMS2 have fixes to problems found after K8 release.  That relate
"PKG",283,22,21,"PAH",2,1,112,0)
to leaving IO("C") around, also fixed in Kernel 7.1.  %ZTMS2 also does a
"PKG",283,22,21,"PAH",2,1,113,0)
check to see that %ZTIO and IO are the same. If not record in the TM error
"PKG",283,22,21,"PAH",2,1,114,0)
log and CLOSE %ZTIO and set to IO.  This may be why 2 devices get opened
"PKG",283,22,21,"PAH",2,1,115,0)
at once.
"PKG",283,22,21,"PAH",2,1,116,0)
 
"PKG",283,22,21,"PAH",2,1,117,0)
XPDE, XPDIA1 have been updated so that KIDS now supports List Manager
"PKG",283,22,21,"PAH",2,1,118,0)
templates and Remote Procedures for the Kernel RPC Broker.
"PKG",283,22,21,"PAH",2,1,119,0)
 
"PKG",283,22,21,"PAH",2,1,120,0)
XPDT returns error message if HFS filename is rejected by Device Handler.
"PKG",283,22,21,"PAH",2,1,121,0)
 
"PKG",283,22,21,"PAH",2,1,122,0)
XPDR has been enhanced to allow purging of Build and Install files at the
"PKG",283,22,21,"PAH",2,1,123,0)
same time.
"PKG",283,22,21,"PAH",2,1,124,0)
 
"PKG",283,22,21,"PAH",2,1,125,0)
XPDDCS will now check that routines in the transport global have header nodes.
"PKG",283,22,21,"PAH",2,1,126,0)
 
"PKG",283,22,21,"PAH",2,1,127,0)
XPDIJ doesn't display the message, 'Data already Installed', if there was no
"PKG",283,22,21,"PAH",2,1,128,0)
data sent.
"PKG",283,22,21,"PAH",3,0)
5^2950921
"PKG",283,22,21,"PAH",3,1,0)
^^36^36^2950921^
"PKG",283,22,21,"PAH",3,1,1,0)
XU*8*5
"PKG",283,22,21,"PAH",3,1,2,0)
This is a patch to XPDKEY to provide a supported call to do a lookup
"PKG",283,22,21,"PAH",3,1,3,0)
on the Security Key file.
"PKG",283,22,21,"PAH",3,1,4,0)
 
"PKG",283,22,21,"PAH",3,1,5,0)
========================================================================= 
"PKG",283,22,21,"PAH",3,1,6,0)
INSTALLATION: 
"PKG",283,22,21,"PAH",3,1,7,0)
 
"PKG",283,22,21,"PAH",3,1,8,0)
 1. Use the 'INSTALL/CHECK MESSAGE' option on the PackMan menu. This 
"PKG",283,22,21,"PAH",3,1,9,0)
    option will load the KIDS package in this message onto your system.  
"PKG",283,22,21,"PAH",3,1,10,0)
 2. Answer NO to the question: 
"PKG",283,22,21,"PAH",3,1,11,0)
    'Shall I preserve what is on disk in a separate back-up message ?' 
"PKG",283,22,21,"PAH",3,1,12,0)
 3. The patch has now been loaded into a Transport global on your system.
"PKG",283,22,21,"PAH",3,1,13,0)
 
"PKG",283,22,21,"PAH",3,1,14,0)
    You now need to use KIDS to install the Transport global.  
"PKG",283,22,21,"PAH",3,1,15,0)
 4. On the KIDS menu, under the 'Installation' menu, use the option 
"PKG",283,22,21,"PAH",3,1,16,0)
    'Install Package(s)'.  
"PKG",283,22,21,"PAH",3,1,17,0)
    Select the package 'XU*8.0*5' and proceed with install.  
"PKG",283,22,21,"PAH",3,1,18,0)
 
"PKG",283,22,21,"PAH",3,1,19,0)
    This routine is used by KIDS, so there will not be any user accessing
"PKG",283,22,21,"PAH",3,1,20,0)
    it.  This patch can be installed at any time.
"PKG",283,22,21,"PAH",3,1,21,0)
 
"PKG",283,22,21,"PAH",3,1,22,0)
========================================================================= 
"PKG",283,22,21,"PAH",3,1,23,0)
 
"PKG",283,22,21,"PAH",3,1,24,0)
*  LKUP^XPDKEY(key_lookup)
"PKG",283,22,21,"PAH",3,1,25,0)
Usage  S Y=27,X=LKUP^XPDKEY(Y) 
"PKG",283,22,21,"PAH",3,1,26,0)
 
"PKG",283,22,21,"PAH",3,1,27,0)
Input  key_lookup: Name or number of a key.
"PKG",283,22,21,"PAH",3,1,28,0)
 
"PKG",283,22,21,"PAH",3,1,29,0)
Output If called with a number it returns the name of the option.
"PKG",283,22,21,"PAH",3,1,30,0)
       If called with a name it returns the number of the option.
"PKG",283,22,21,"PAH",3,1,31,0)
 
"PKG",283,22,21,"PAH",3,1,32,0)
Description
"PKG",283,22,21,"PAH",3,1,33,0)
 
"PKG",283,22,21,"PAH",3,1,34,0)
This is an extrinsic function to do lookups on the Security Key file and
"PKG",283,22,21,"PAH",3,1,35,0)
return the name if called with a number, or return a number if called with
"PKG",283,22,21,"PAH",3,1,36,0)
a name.  If the name or number is not found it returns the empty string.
"PKG",283,22,21,"PAH","B",1,1)

"PKG",283,22,21,"PAH","B",2,2)

"PKG",283,22,21,"PAH","B",5,3)

"PKG",283,22,"B",6,6)

"PKG",283,22,"B",6.5,6.5)

"PKG",283,22,"B",7,7)

"PKG",283,22,"B",7.1,8)

"PKG",283,22,"B","8.0",21)

"PKG",283,1933,0)
^9.455^^0
"PKG",283,"DEV")
SF:HVB,RWF,AC,XAK,VYD,JIC SEA:MJM,JLI
"PKG",283,"DIBT",0)
^9.48^^0
"PKG",283,"DIE",0)
^9.47^^0
"PKG",283,"DIPT",0)
^9.46^^0
"PKG",283,"EX",0)
^9.432^^0
"PKG",283,"INI")
^
"PKG",283,"INIT")
^
"PKG",283,"M",0)
^9.495^^0
"PKG",283,"PRE")
^
"PKG",283,"ST",0)
^9.444D^2830000^1
"PKG",283,"ST",2830000,0)
2830000^A
"PKG",283,"VERSION")
8.0
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Options and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
13
"RTN","XPDDCS")
0^13^B7639567
"RTN","XPDDCS",1,0)
XPDDCS ;SFISC/RSD - Display Checksum for a package ; 10 Aug 95 08:16
"RTN","XPDDCS",2,0)
 ;;8.0;KERNEL;**2**;Jul 10, 1995
"RTN","XPDDCS",3,0)
EN1 ;print from Transport Global
"RTN","XPDDCS",4,0)
 N D0,DIC,X,XPD,Y,Z
"RTN","XPDDCS",5,0)
 S DIC="^XPD(9.7,",DIC(0)="AEQMZ",DIC("S")="I $D(^XTMP(""XPDI"",Y))"
"RTN","XPDDCS",6,0)
 D ^DIC Q:Y<0
"RTN","XPDDCS",7,0)
 S D0=+Y,XPD("D0")="",X="XUTMDEVQ"
"RTN","XPDDCS",8,0)
 X ^%ZOSF("TEST") E  D  Q
"RTN","XPDDCS",9,0)
 .S IOSL=99999,IOM=80,IOF="#",IOST="",$Y=0 D PNT(9.7)
"RTN","XPDDCS",10,0)
 S Y="PNT^XPDDCS(9.7)",Z="Checksum Print"
"RTN","XPDDCS",11,0)
 D EN^XUTMDEVQ(Y,Z,.XPD)
"RTN","XPDDCS",12,0)
 Q
"RTN","XPDDCS",13,0)
EN2 ;print from system
"RTN","XPDDCS",14,0)
 N D0,DIC,XPD,Y,Z
"RTN","XPDDCS",15,0)
 S DIC="^XPD(9.6,",DIC(0)="AEQMZ"
"RTN","XPDDCS",16,0)
 D ^DIC Q:Y<0
"RTN","XPDDCS",17,0)
 S D0=+Y,XPD("D0")="",Y="PNT^XPDDCS(9.6)",Z="Checksum Print"
"RTN","XPDDCS",18,0)
 D EN^XUTMDEVQ(Y,Z,.XPD)
"RTN","XPDDCS",19,0)
 Q
"RTN","XPDDCS",20,0)
 ;
"RTN","XPDDCS",21,0)
PNT(XPDFIL) ;print
"RTN","XPDDCS",22,0)
 N XPD0,XPDC,XPDDT,XPDE,XPDI,XPDJ,XPDPG,XPDQ,XPDUL,X
"RTN","XPDDCS",23,0)
 Q:'$D(^XPD(XPDFIL,D0,0))  S XPD0=^(0),XPDPG=1,$P(XPDUL,"-",IOM)="",XPDDT=$$HTE^XLFDT($H,"1PM")
"RTN","XPDDCS",24,0)
 W:$E(IOST,1,2)="C-" @IOF D HDR
"RTN","XPDDCS",25,0)
 W !
"RTN","XPDDCS",26,0)
 S XPDI="",(XPDQ,XPDE)=0
"RTN","XPDDCS",27,0)
 I XPDFIL=9.7 D
"RTN","XPDDCS",28,0)
 .I '$D(^XTMP("XPDI",D0)) W !!," ** Transport Global doesn't exist **" S XPDQ=1 Q
"RTN","XPDDCS",29,0)
 .I '$D(^XTMP("XPDI",D0,"BLD"))="" W !!," **Transport Global corrupted, please reload **" S XPDQ=1 Q
"RTN","XPDDCS",30,0)
 .F XPDC=0:1 S XPDI=$O(^XTMP("XPDI",D0,"RTN",XPDI)) Q:XPDI=""  S XPDJ=$G(^(XPDI)) D  Q:XPDQ
"RTN","XPDDCS",31,0)
 ..I XPDJ="" W !," **Transport Global corrupted, please reload **" S XPDQ=1 Q
"RTN","XPDDCS",32,0)
 ..I +XPDJ=1 S XPDC=XPDC-1 Q
"RTN","XPDDCS",33,0)
 ..D SUM(XPDI,$NA(^XTMP("XPDI",D0,"RTN",XPDI)),$P(XPDJ,U,3))
"RTN","XPDDCS",34,0)
 ..S XPDQ=$$CHK(4)
"RTN","XPDDCS",35,0)
 E  D
"RTN","XPDDCS",36,0)
 .F XPDC=0:1 S XPDI=$O(^XPD(9.6,D0,"KRN",9.8,"NM","B",XPDI)) Q:XPDI=""  S XPDJ=$O(^(XPDI,0)) D  Q:XPDQ
"RTN","XPDDCS",37,0)
 ..Q:'$D(^XPD(9.6,D0,"KRN",9.8,"NM",+XPDJ,0))  S XPDJ=$P(^(0),U,4)
"RTN","XPDDCS",38,0)
 ..I XPDJ="" S XPDC=XPDC-1 Q
"RTN","XPDDCS",39,0)
 ..N DIF,XCNP,%N
"RTN","XPDDCS",40,0)
 ..S X=XPDI,DIF="^TMP($J,""RTN"",XPDI,",XCNP=0
"RTN","XPDDCS",41,0)
 ..X ^%ZOSF("LOAD")
"RTN","XPDDCS",42,0)
 ..D SUM(XPDI,$NA(^TMP($J,"RTN",XPDI)),XPDJ)
"RTN","XPDDCS",43,0)
 ..S XPDQ=$$CHK(4)
"RTN","XPDDCS",44,0)
 Q:XPDQ
"RTN","XPDDCS",45,0)
 W !!?3,XPDC," Routine checked, ",XPDE," failed.",!
"RTN","XPDDCS",46,0)
 Q
"RTN","XPDDCS",47,0)
 ;
"RTN","XPDDCS",48,0)
SUM(XPDR,Z,XPD) ;check checksum
"RTN","XPDDCS",49,0)
 N Y
"RTN","XPDDCS",50,0)
 I XPD'?1U1.N W !,XPDR,?10,"ERROR in Checksum" S XPDE=XPDE+1 Q
"RTN","XPDDCS",51,0)
 S @("Y=$$SUM"_$E(XPD)_"^XPDRSUM(Z)"),XPD=$E(XPD,2,255)
"RTN","XPDDCS",52,0)
 I Y'=XPD W !,XPDR,?10,"Calculated "_$C(7)_Y_", should be "_XPD S XPDE=XPDE+1
"RTN","XPDDCS",53,0)
 Q
"RTN","XPDDCS",54,0)
 ;
"RTN","XPDDCS",55,0)
CHK(Y) ;Y=excess lines, return 1 to exit
"RTN","XPDDCS",56,0)
 Q:$Y<(IOSL-Y) 0
"RTN","XPDDCS",57,0)
 I $E(IOST,1,2)="C-" D  Q:'Y 1
"RTN","XPDDCS",58,0)
 .N DIR,I,J,K,X
"RTN","XPDDCS",59,0)
 .S DIR(0)="E" D ^DIR
"RTN","XPDDCS",60,0)
 S XPDPG=XPDPG+1
"RTN","XPDDCS",61,0)
 W @IOF D HDR
"RTN","XPDDCS",62,0)
 Q 0
"RTN","XPDDCS",63,0)
 ;
"RTN","XPDDCS",64,0)
HDR W !,"PACKAGE: ",$P(XPD0,U),"     ",XPDDT,?70,"PAGE ",XPDPG,!,XPDUL,!
"RTN","XPDDCS",65,0)
 Q
"RTN","XPDE")
0^9^B30440657
"RTN","XPDE",1,0)
XPDE ;SFISC/RSD - Package Edit ; 23 Aug 95 15:34
"RTN","XPDE",2,0)
 ;;8.0;KERNEL;**2**;Jul 10, 1995
"RTN","XPDE",3,0)
 Q
"RTN","XPDE",4,0)
EDIT ;edit Build file package
"RTN","XPDE",5,0)
 N DA,DIR,DDSFILE,DR,Y,Z
"RTN","XPDE",6,0)
 Q:'$$DIC("AEMQLZ","",1)  S DA=+Y
"RTN","XPDE",7,0)
 I $P(Y,U,3) D NEW(DA)
"RTN","XPDE",8,0)
 ;need code to start editing
"RTN","XPDE",9,0)
 S DR="[XPD EDIT BUILD]",DDSFILE="^XPD(9.6,"
"RTN","XPDE",10,0)
 D ^DDS Q:'$G(DA)
"RTN","XPDE",11,0)
 S Y=0 F  S Y=$O(^XPD(9.6,DA,4,Y)) Q:'Y  S Z=$G(^(Y,222)) D
"RTN","XPDE",12,0)
 .K:$P(Z,U,3)="f" ^XPD(9.6,DA,4,Y,2),^XPD(9.6,DA,4,"APDD",Y)
"RTN","XPDE",13,0)
 D QUIT(DA)
"RTN","XPDE",14,0)
 Q
"RTN","XPDE",15,0)
COPY ;copy a Build file package
"RTN","XPDE",16,0)
 N DA,DIK,DIR,FR,FR0,TO,TO0,X,Y,Z W !
"RTN","XPDE",17,0)
 Q:'$$DIC("QEAMZ","Copy FROM what Package: ")
"RTN","XPDE",18,0)
 S FR=+Y,FR0=Y(0),Z="QEAMZL",Z("S")="I Y'="_FR
"RTN","XPDE",19,0)
 I '$$DIC(.Z,"Copy TO what Package: ") D QUIT(FR) Q
"RTN","XPDE",20,0)
 S TO=Y,TO0=Y(0)
"RTN","XPDE",21,0)
 I '$P(Y,U,3) W !,$P(TO0,U)," package will be PURGED before the copy."
"RTN","XPDE",22,0)
 W ! S DIR(0)="Y",DIR("A")="OK to continue",DIR("B")="YES" D ^DIR
"RTN","XPDE",23,0)
 S DIK="^XPD(9.6,",DA=+TO
"RTN","XPDE",24,0)
 I 'Y!$D(DIRUT) D  W ! Q
"RTN","XPDE",25,0)
 .I $P(TO,U,3) D ^DIK W $P(TO0,U)," being deleted!"
"RTN","XPDE",26,0)
 .D QUIT(FR),QUIT(TO)
"RTN","XPDE",27,0)
 D WAIT^DICD
"RTN","XPDE",28,0)
 K ^XPD(9.6,DA) M ^(DA)=^(FR) S $P(^(DA,0),U)=$P(TO0,U)
"RTN","XPDE",29,0)
 I $P(TO0,U,2)]"",$P(FR0,U,2)'=$P(TO0,U,2) K ^XPD(9.6,"C",$E($P(TO0,U,2),1,30),DA) S DIK(1)=1 D EN1^DIK
"RTN","XPDE",30,0)
 D QUIT(FR),QUIT(TO)
"RTN","XPDE",31,0)
 W "    ...Done.",! Q
"RTN","XPDE",32,0)
BUILD ;build package from a namespace
"RTN","XPDE",33,0)
 N DA,D0,D1,DIR,XPDA,XPDI,XPDIC,XPDF,XPDN,X,X1,Y,Y1 W !
"RTN","XPDE",34,0)
 Q:'$$DIC("QEAML")
"RTN","XPDE",35,0)
 S XPDA=+Y W !
"RTN","XPDE",36,0)
 I '$P(Y,U,3) D  I $D(DIRUT) D QUIT(XPDA) Q
"RTN","XPDE",37,0)
 .S DIR(0)="Y",DIR("A")="Package already exists, Want to PURGE the existing data",DIR("B")="NO",DIR("?")="YES will delete all the KERNEL FILE information for this package in the BUILD file."
"RTN","XPDE",38,0)
 .D ^DIR K DIR Q:'Y
"RTN","XPDE",39,0)
 .S Y=0 F  S Y=$O(^XPD(9.6,XPDA,"KRN",Y)) Q:'Y  K ^(Y,"NM")
"RTN","XPDE",40,0)
 E  D NEW(XPDA)
"RTN","XPDE",41,0)
 W ! S DIR(0)="FO^1:15^K:X'?.1""-""1U.15UNP X",DIR("A")="Namespace",DIR("?")="Enter 1 to 15 characters, preceed with ""-"" to exclude namespace"
"RTN","XPDE",42,0)
 F  D ^DIR Q:$D(DIRUT)  S X=$E(Y,$L(Y))="*",%=$E(Y)="-",XPDN('%,$E(Y,%+1,$L(Y)-X))=""
"RTN","XPDE",43,0)
 I '$D(XPDN)!$D(DTOUT)!$D(DUOUT) D QUIT(XPDA) Q
"RTN","XPDE",44,0)
 W !!,"NAMESPACE  INCLUDE",?35,"EXCLUDE",!,?11,"-------",?35,"-------"
"RTN","XPDE",45,0)
 S (X,Y)="",(X1,Y1)=1
"RTN","XPDE",46,0)
 F  D  W !?11,X,?35,Y Q:'X1&'Y1
"RTN","XPDE",47,0)
 .S:X1 X=$O(XPDN(1,X)),X1=X]"" S:Y1 Y=$O(XPDN(0,Y)),Y1=Y]""
"RTN","XPDE",48,0)
 S DIR(0)="Y",DIR("A")="OK to continue",DIR("B")="YES" D ^DIR
"RTN","XPDE",49,0)
 I 'Y!$D(DIRUT) D QUIT(XPDA) Q
"RTN","XPDE",50,0)
 D WAIT^DICD S (DA(2),D0)=XPDA,Y=""
"RTN","XPDE",51,0)
 F  S Y=$O(XPDN(1,Y)),D1=0 Q:Y=""  D
"RTN","XPDE",52,0)
 .F  S D1=$O(^XPD(9.6,D0,"KRN",D1)) Q:'D1  D
"RTN","XPDE",53,0)
 ..S (XPDF,DA(1))=D1,X=Y,XPDIC="^XPD(9.6,"_D0_",""KRN"","_D1_",""NM"",",XPDI("IEN")=0
"RTN","XPDE",54,0)
 ..N %,DD,DO,Y,XPD
"RTN","XPDE",55,0)
 ..D LIST^DIC(D1,"","","","*",.XPDI,X,"","I $$SCR1^XPDET(Y)")
"RTN","XPDE",56,0)
 ..F XPDI=1:1 S X=$G(^TMP("DILIST",$J,1,XPDI)) Q:X=""  D
"RTN","XPDE",57,0)
 ...S:D1<.404 %=^TMP("DILIST",$J,2,XPDI)_",",X=$$TX^XPDET(X,$$GET1^DIQ(D1,%,$$TF^XPDET(D1),"I"))
"RTN","XPDE",58,0)
 ...S Y="+1,"_D1_","_D0_",",XPD(9.68,Y,.01)=X,XPD(9.68,Y,.03)=0
"RTN","XPDE",59,0)
 ...S:'$D(^XPD(9.6,D0,"KRN",D1,"NM",0)) ^XPD(9.6,D0,"KRN",D1,"NM",0)=U_$P(^DD(9.67,10,0),U,2)
"RTN","XPDE",60,0)
 ...D UPDATE^DIE("","XPD")
"RTN","XPDE",61,0)
 D QUIT(XPDA)
"RTN","XPDE",62,0)
 W "    ...Done.",! Q
"RTN","XPDE",63,0)
VER ;verify a Build file package
"RTN","XPDE",64,0)
 N XPDA,Y
"RTN","XPDE",65,0)
 Q:'$$DIC("AEMQLZ")  S XPDA=+Y
"RTN","XPDE",66,0)
 D EN^XPDV Q
"RTN","XPDE",67,0)
DIC(DIC,A,XPDL) ;DIC lookup to Build file, 9.6
"RTN","XPDE",68,0)
 N DLAYGO
"RTN","XPDE",69,0)
 S DIC(0)=$G(DIC),DIC="^XPD(9.6," S:$G(A)]"" DIC("A")=A
"RTN","XPDE",70,0)
 S:DIC(0)["L" DLAYGO=9.6
"RTN","XPDE",71,0)
 D ^DIC Q:Y<0 0
"RTN","XPDE",72,0)
 I '$G(XPDL) L +^XPD(9.6,+Y):0 E  W !,"Being accessed by another user" Q 0
"RTN","XPDE",73,0)
 Q +Y
"RTN","XPDE",74,0)
 ;
"RTN","XPDE",75,0)
NEW(DA) ;create Kernel Files multiple for package DA
"RTN","XPDE",76,0)
 N I,J,X,XPDNEWF,XPD,XPDI
"RTN","XPDE",77,0)
 S:'$D(^XPD(9.6,DA,"KRN",0)) ^XPD(9.6,DA,"KRN",0)=U_$P(^DD(9.6,7,0),U,2)
"RTN","XPDE",78,0)
 S I=0
"RTN","XPDE",79,0)
 F J=1:1 S X=+$P($T(FILES+J),";;",2) Q:'X  S:$D(^DD(X)) I=I+1,(XPDI(I),XPD(9.67,"+"_I_","_DA_",",.01))=X
"RTN","XPDE",80,0)
 S XPD(9.6,DA_",",2)=0,XPDNEWF=1
"RTN","XPDE",81,0)
 D UPDATE^DIE("","XPD","XPDI")
"RTN","XPDE",82,0)
 Q
"RTN","XPDE",83,0)
QUIT(Y) ;unlock Y
"RTN","XPDE",84,0)
 L -^XPD(9.6,Y)
"RTN","XPDE",85,0)
 Q
"RTN","XPDE",86,0)
 ;
"RTN","XPDE",87,0)
FILES ;kernel files for field 7 in file 9.6
"RTN","XPDE",88,0)
 ;;101;11;;;PRO^XPDTA;PROF1^XPDIA;PROE1^XPDIA;PROF2^XPDIA;;PRODEL^XPDIA
"RTN","XPDE",89,0)
 ;;8995;10;;GUIF^XPDTA1;GUIE^XPDTA1;GUIF1^XPDIA1;GUIE1^XPDIA1;GUIF2^XPDIA1;;EN^XPDGCDEL(%)
"RTN","XPDE",90,0)
 ;;19;12;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"RTN","XPDE",91,0)
 ;;409.61;13;1;;;;;;;LMDEL^XPDIA1
"RTN","XPDE",92,0)
 ;;19.1;3;1;;KEY^XPDTA1;;;;;KEYDEL^XPDIA1
"RTN","XPDE",93,0)
 ;;9.8;;1;RTNF^XPDTA;RTNE^XPDTA
"RTN","XPDE",94,0)
 ;;9.2;1;;;HELP^XPDTA1;HLPF1^XPDIA1;HLPE1^XPDIA1;HLPF2^XPDIA1;;HLPDEL^XPDIA1
"RTN","XPDE",95,0)
 ;;3.6;2;1;;BUL^XPDTA1;;BULE1^XPDIA1;;;BULDEL^XPDIA1
"RTN","XPDE",96,0)
 ;;.5;4;;;EDEOUT^DIFROMSO(.5,DA,"",XPDA);FPRE^DIFROMSI(.5,"",XPDA);EPRE^DIFROMSI(.5,DA,"",XPDA,"",OLDA);;EPOST^DIFROMSI(.5,DA,"",XPDA)
"RTN","XPDE",97,0)
 ;;.4;5;;;EDEOUT^DIFROMSO(.4,DA,"",XPDA);FPRE^DIFROMSI(.4,"",XPDA);EPRE^DIFROMSI(.4,DA,"",XPDA,"",OLDA);;EPOST^DIFROMSI(.4,DA,"",XPDA);DEL^DIFROMSK(.4,"",%)
"RTN","XPDE",98,0)
 ;;.401;6;;;EDEOUT^DIFROMSO(.401,DA,"",XPDA);FPRE^DIFROMSI(.401,"",XPDA);EPRE^DIFROMSI(.401,DA,"",XPDA,"",OLDA);;EPOST^DIFROMSI(.401,DA,"",XPDA);DEL^DIFROMSK(.401,"",%)
"RTN","XPDE",99,0)
 ;;.402;7;;;EDEOUT^DIFROMSO(.402,DA,"",XPDA);FPRE^DIFROMSI(.402,"",XPDA);EPRE^DIFROMSI(.402,DA,"",XPDA,"",OLDA);;EPOST^DIFROMSI(.402,DA,"",XPDA);DEL^DIFROMSK(.402,"",%)
"RTN","XPDE",100,0)
 ;;.403;8;;;EDEOUT^DIFROMSO(.403,DA,"",XPDA);FPRE^DIFROMSI(.403,"",XPDA);EPRE^DIFROMSI(.403,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.403,DA,"",XPDA);DEL^DIFROMSK(.403,"",%)
"RTN","XPDE",101,0)
 ;;.84;9;;;EDEOUT^DIFROMSO(.84,DA,"",XPDA);FPRE^DIFROMSI(.84,"",XPDA);EPRE^DIFROMSI(.84,DA,"",XPDA,"",OLDA);;EPOST^DIFROMSI(.84,DA,"",XPDA);DEL^DIFROMSK(.84,"",%)
"RTN","XPDE",102,0)
 ;;8994;14;1;;;;;;;RPCDEL^XPDIA1
"RTN","XPDIA1")
0^10^B13227203
"RTN","XPDIA1",1,0)
XPDIA1 ;SFISC/RSD - Install Pre/Post Actions for Kernel files cont. ; 23 Aug 95 15:34
"RTN","XPDIA1",2,0)
 ;;8.0;KERNEL;**2**;Jul 10, 1995
"RTN","XPDIA1",3,0)
 Q
"RTN","XPDIA1",4,0)
GUIF1 ;window objects file pre
"RTN","XPDIA1",5,0)
 N DA,I,XPD,X,Y
"RTN","XPDIA1",6,0)
 S I=0
"RTN","XPDIA1",7,0)
 F  S I=$O(^XTMP("XPDI",XPDA,"KRN",8995.8,I)) Q:'I  S XPD=^(I,0) D
"RTN","XPDIA1",8,0)
 .S X=$P(XPD,U),Y=$$DIC^XPDIK(8995.8,X) Q:'Y  S DA=+Y
"RTN","XPDIA1",9,0)
 .K ^XTV(8995.8,DA) M ^XTV(8995.8,DA)=^XTMP("XPDI",XPDA,"KRN",8995.8,I)
"RTN","XPDIA1",10,0)
 K ^TMP($J,"XPD")
"RTN","XPDIA1",11,0)
 Q
"RTN","XPDIA1",12,0)
GUIE1 ;entry pre
"RTN","XPDIA1",13,0)
 N %
"RTN","XPDIA1",14,0)
 S ^TMP($J,"XPD",DA)="",%=$P(^XTV(8995,DA,0),U,2)
"RTN","XPDIA1",15,0)
 K ^XTV(8995,DA) K:% ^("AD",%,DA)
"RTN","XPDIA1",16,0)
 Q
"RTN","XPDIA1",17,0)
GUIF2 ;file post
"RTN","XPDIA1",18,0)
 N DA,DIK,I,X,Y,Y0
"RTN","XPDIA1",19,0)
 S DA=0,DIK=DIC F  S DA=$O(^TMP($J,"XPD",DA)) Q:'DA  D
"RTN","XPDIA1",20,0)
 .S Y0=^XTV(8995,DA,0),$P(Y0,U,2)=$$LK^XPDIA("^XTV(8995)",$P(Y0,U,2)),$P(Y0,U,3)=$$LK^XPDIA("^XTV(8995.6)",$P(Y0,U,3)),$P(Y0,U,5)=$$LK^XPDIA("^DIC(9.2)",$P(Y0,U,5))
"RTN","XPDIA1",21,0)
 .S ^XTV(8995,DA,0)=Y0,Y0=$G(^(100))
"RTN","XPDIA1",22,0)
 .I $L($P(Y0,U,3)) S $P(Y0,U,3)=$$LK^XPDIA("^XTV(8995)",$P(Y0,U,3)),^XTV(8995,DA,100)=Y0
"RTN","XPDIA1",23,0)
 .D GUIEV($NA(^XTV(8995,DA,1)))
"RTN","XPDIA1",24,0)
 .S I=0 F  S I=$O(^XTV(8995,DA,2,I)) Q:'I  S Y0=$G(^(I,0)) D
"RTN","XPDIA1",25,0)
 ..S $P(Y0,U,2)=$$LK^XPDIA("^XTV(8995)",$P(Y0,U,2)),^XTV(8995,DA,2,I,0)=Y0
"RTN","XPDIA1",26,0)
 ..D GUIEV($NA(^XTV(8995,DA,2,I,1)))
"RTN","XPDIA1",27,0)
 ..D GUIDR($NA(^XTV(8995,DA,2,I,3)))
"RTN","XPDIA1",28,0)
 .S I=0 F  S I=$O(^XTV(8995,DA,3,I)) Q:'I  S Y0=$G(^(I,0)) D
"RTN","XPDIA1",29,0)
 ..S $P(Y0,U,3)=$$LK^XPDIA("^XTV(8995)",$P(Y0,U,3))
"RTN","XPDIA1",30,0)
 ..I $L($P(Y0,U,4)) S $P(Y0,U,4)=$$LK^XPDIA("^XTV(8995.8)",$P(Y0,U,4))
"RTN","XPDIA1",31,0)
 ..S ^XTV(8995,DA,3,I,0)=Y0
"RTN","XPDIA1",32,0)
 .D GUIDR($NA(^XTV(8995,DA,6))),IX1^DIK
"RTN","XPDIA1",33,0)
 Q
"RTN","XPDIA1",34,0)
GUIEV(X) ;repoint events & call backs, X=Global root
"RTN","XPDIA1",35,0)
 N %,%1,%2
"RTN","XPDIA1",36,0)
 S %=0 F  S %=$O(@X@(%)) Q:'%  S %1=$G(^(%,0)) D
"RTN","XPDIA1",37,0)
 .S $P(%1,U)=$$LK^XPDIA("^XTV(8995.5)",$P(%1,U))
"RTN","XPDIA1",38,0)
 .I $L($P(%1,U,2)) S $P(%1,U,2)=$$LK^XPDIA("^XTV(8995.8)",$P(%1,U,2))
"RTN","XPDIA1",39,0)
 .S @X@(%,0)=%1
"RTN","XPDIA1",40,0)
 Q
"RTN","XPDIA1",41,0)
GUIDR(X) ;repoint draw command, X=Global root
"RTN","XPDIA1",42,0)
 N %,%1
"RTN","XPDIA1",43,0)
 S %=0 F  S %=$O(@X@(%)) Q:'%  S %1=$G(^(%,0)) D
"RTN","XPDIA1",44,0)
 .S $P(%1,U,2)=$$LK^XPDIA("^XTV(8995.4)",$P(%1,U,2)),@X@(%,0)=%1
"RTN","XPDIA1",45,0)
 Q
"RTN","XPDIA1",46,0)
HLPF1 ;help frames file pre
"RTN","XPDIA1",47,0)
 K ^TMP($J,"XPD")
"RTN","XPDIA1",48,0)
 Q
"RTN","XPDIA1",49,0)
HLPE1 ;entry pre
"RTN","XPDIA1",50,0)
 S ^TMP($J,"XPD",DA)="" K ^DIC(9.2,DA,1),^(2),^(3),^(10)
"RTN","XPDIA1",51,0)
 Q
"RTN","XPDIA1",52,0)
HLPF2 ;file post
"RTN","XPDIA1",53,0)
 N DA,DIK,I,X,Y,Y0
"RTN","XPDIA1",54,0)
 S DA=0,DIK=DIC F  S DA=$O(^TMP($J,"XPD",DA)) Q:'DA  D
"RTN","XPDIA1",55,0)
 .S I=0 F  S I=$O(^DIC(9.2,DA,2,I)) Q:'I  S Y0=$G(^(I,0)),Y=$$LK^XPDIA("^DIC(9.2)",$P(Y0,U,2)),$P(^DIC(9.2,DA,2,I,0),U,2)=Y
"RTN","XPDIA1",56,0)
 .S (I,X)=0 F  S I=$O(^DIC(9.2,DA,10,I)) Q:'I  S Y0=$G(^(I,0)) D
"RTN","XPDIA1",57,0)
 ..S Y=$$LK^XPDIA("^MAG",$P(Y0,U)) S:Y $P(^DIC(9.2,DA,10,I,0),U)=Y,X=X+1_U_I
"RTN","XPDIA1",58,0)
 ..K:'Y ^DIC(9.2,DA,10,I)
"RTN","XPDIA1",59,0)
 .I X S $P(^DIC(9.2,DA,10,0),U,3,4)=$P(X,U,2)_U_+X
"RTN","XPDIA1",60,0)
 .D IX1^DIK
"RTN","XPDIA1",61,0)
 K ^TMP($J,"XPD")
"RTN","XPDIA1",62,0)
 Q
"RTN","XPDIA1",63,0)
HLPDEL ;help frame delete
"RTN","XPDIA1",64,0)
 N DA,DIK,XPDI,XPDJ
"RTN","XPDIA1",65,0)
 S XPDI=0
"RTN","XPDIA1",66,0)
 F  S XPDI=$O(^TMP($J,"XPDEL",XPDI)),XPDJ=0 Q:'XPDI  D
"RTN","XPDIA1",67,0)
 .S DIK="^DIC(9.2,XPDJ,2,"
"RTN","XPDIA1",68,0)
 .F  S XPDJ=$O(^DIC(9.2,"AE",XPDI,XPDJ)) Q:'XPDJ  S Z=$O(^(XPDJ,0)) D:Z
"RTN","XPDIA1",69,0)
 ..K DA S DA=Z,DA(1)=XPDJ D ^DIK
"RTN","XPDIA1",70,0)
 .K DA S DA=XPDI,DIK="^DIC(9.2," D ^DIK
"RTN","XPDIA1",71,0)
 Q
"RTN","XPDIA1",72,0)
BULE1 ;bulletin entry pre
"RTN","XPDIA1",73,0)
 N X,I S I=0
"RTN","XPDIA1",74,0)
 I $G(^XMB(3.6,DA,2,0))]"" S X(0)=^(0) F  S I=$O(^XMB(3.6,DA,2,I)) Q:'I  S X(I)=$G(^(I,0))
"RTN","XPDIA1",75,0)
 K ^XMB(3.6,DA)
"RTN","XPDIA1",76,0)
 I $D(X) S ^XMB(3.6,DA,2,0)=X(0),I=0 F  S I=$O(X(I)) Q:'I  S ^XMB(3.6,DA,2,I,0)=X(I)
"RTN","XPDIA1",77,0)
 Q
"RTN","XPDIA1",78,0)
BULDEL ;del bulletins
"RTN","XPDIA1",79,0)
 N DA,DIK,XPDI
"RTN","XPDIA1",80,0)
 S XPDI=0,DIK="^XMB(3.6,"
"RTN","XPDIA1",81,0)
 F  S XPDI=$O(^TMP($J,"XPDEL",XPDI)) Q:'XPDI  S DA=XPDI D ^DIK
"RTN","XPDIA1",82,0)
 Q
"RTN","XPDIA1",83,0)
KEYDEL ;del security keys
"RTN","XPDIA1",84,0)
 N XPDI S XPDI=0
"RTN","XPDIA1",85,0)
 F  S XPDI=$O(^TMP($J,"XPDEL",XPDI)) Q:'XPDI  D DEL^XPDKEY(XPDI)
"RTN","XPDIA1",86,0)
 Q
"RTN","XPDIA1",87,0)
LMDEL ;del list manager templates
"RTN","XPDIA1",88,0)
 N DA,DIK,XPDI
"RTN","XPDIA1",89,0)
 S XPDI=0,DIK="^SD(409.61,"
"RTN","XPDIA1",90,0)
 F  S XPDI=$O(^TMP($J,"XPDEL",XPDI)) Q:'XPDI  S DA=XPDI D ^DIK
"RTN","XPDIA1",91,0)
 Q
"RTN","XPDIA1",92,0)
RPCDEL ;del Kernel RPCs
"RTN","XPDIA1",93,0)
 N DA,DIK,XPDI
"RTN","XPDIA1",94,0)
 S XPDI=0,DIK="^XWB(8994,"
"RTN","XPDIA1",95,0)
 F  S XPDI=$O(^TMP($J,"XPDEL",XPDI)) Q:'XPDI  S DA=XPDI D ^DIK
"RTN","XPDIA1",96,0)
 Q
"RTN","XPDIJ")
0^14^B40021653
"RTN","XPDIJ",1,0)
XPDIJ ;SFISC/RSD - Install Job; 3 Aug 95 09:19
"RTN","XPDIJ",2,0)
 ;;8.0;KERNEL;**2**;Jul 10, 1995
"RTN","XPDIJ",3,0)
EN ;install all packages
"RTN","XPDIJ",4,0)
 N XPD0,XPDSET,XPDQUIT,X,Y,ZTRTN,ZTDTH,ZTIO,ZTDESC,ZTSK
"RTN","XPDIJ",5,0)
 S X="ERR^XPDIJ",@^%ZOSF("TRAP")
"RTN","XPDIJ",6,0)
 Q:'$D(^XPD(9.7,+$G(XPDA),0))  S XPD0=^(0)
"RTN","XPDIJ",7,0)
 D INIT^XPDID S Y=$P(XPD0,U,8)
"RTN","XPDIJ",8,0)
 I Y]"" S XPDSET=Y_U_$P($G(^XTMP("XQOO",Y,0)),U) D OFF^XQOO1($P(XPDSET,U)) I $P(XPD0,U,10) H ($P(XPD0,U,10)*60)
"RTN","XPDIJ",9,0)
 S Y=0
"RTN","XPDIJ",10,0)
 F  S Y=$O(^XPD(9.7,"ASP",XPDA,Y)) Q:'Y  S %=$O(^(Y,0)) D:%  Q:$D(XPDABORT)
"RTN","XPDIJ",11,0)
 .N XPD,XPDA,XPDNM,XPDV,XPDV0,XPDX,XPDY,Y
"RTN","XPDIJ",12,0)
 .S XPDA=%,XPDNM=$P($G(^XPD(9.7,XPDA,0)),U) D IN
"RTN","XPDIJ",13,0)
 .X ^%ZOSF("UCI") S XPDY=$P(Y,",",2),XPDV=0
"RTN","XPDIJ",14,0)
 .F  S XPDV=$O(^XPD(9.7,XPDA,"VOL",XPDV)) Q:'XPDV  S XPDV0=^(XPDV,0) D:$P(XPDV0,U)'=XPDY&'$P(XPDV0,U,2)
"RTN","XPDIJ",15,0)
 ..I '$P(XPDV0,U,3) D  I '$P(XPDV0,U,3)  D BMES^XPDUTL(" ** Job on VOLUME SET "_$P(XPDV0,U)_" never started **"),MES^XPDUTL(" ** "_$P(XPDV0,U)_" has NOT been updated! **") Q
"RTN","XPDIJ",16,0)
 ...D BMES^XPDUTL(" Waiting for job on VOLUME SET "_$P(XPDV0,U)_" to start.")
"RTN","XPDIJ",17,0)
 ...F %=1:1:5 H 60 S XPDV0=^XPD(9.7,XPDA,"VOL",XPDV,0) Q:$P(XPDV0,U,3)
"RTN","XPDIJ",18,0)
 ..D BMES^XPDUTL(" Waiting for job on VOLUME SET "_$P(XPDV0,U)_" to complete.")
"RTN","XPDIJ",19,0)
 ..S XPD=0,XPDX=$G(^XPD(9.7,XPDA,"VOL",XPDV,1))
"RTN","XPDIJ",20,0)
 ..F  S Y=$P(^XPD(9.7,XPDA,"VOL",XPDV,0),U,2),X=$G(^(1)),XPD=XPD+1 Q:XPD>20!Y  S:X'=XPDX XPD=0,XPDX=X H 180
"RTN","XPDIJ",21,0)
 ..I Y D BMES^XPDUTL(" Job on VOLUME SET "_$P(XPDV0,U)_" Completed.") Q
"RTN","XPDIJ",22,0)
 ..D BMES^XPDUTL(" Job on VOLUME SET "_$P(XPDV0,U)_" has been idle for an hour."),MES^XPDUTL(" ** "_$P(XPDV0,U)_" has NOT been updated! **")
"RTN","XPDIJ",23,0)
 S Y=0
"RTN","XPDIJ",24,0)
 F  S Y=$O(^XPD(9.7,"ASP",XPDA,Y)) Q:'Y  S %=$O(^(Y,0)) D:%
"RTN","XPDIJ",25,0)
 .N Y,XPD
"RTN","XPDIJ",26,0)
 .S XPD(9.7,%_",",.02)=3
"RTN","XPDIJ",27,0)
 .D FILE^DIE("","XPD")
"RTN","XPDIJ",28,0)
 .K ^XTMP("XPDI",XPDA)
"RTN","XPDIJ",29,0)
 I $G(ZTSK) S ZTREQ="@" D
"RTN","XPDIJ",30,0)
 .N XPD S XPD(9.7,XPDA_",",5)="@"
"RTN","XPDIJ",31,0)
 .D FILE^DIE("","XPD")
"RTN","XPDIJ",32,0)
 D EXIT^XPDID("Install Completed"),^%ZISC
"RTN","XPDIJ",33,0)
 Q:$D(XPDABORT)
"RTN","XPDIJ",34,0)
 I $D(XPDSET) D ON^XQOO1($P(XPDSET,U)) K ^XTMP("XQOO",$P(XPDSET,U))
"RTN","XPDIJ",35,0)
 ;S ZTRTN="QUE^XQ81",ZTDTH=$H,ZTIO="",ZTDESC="Install Menu Rebuild" D ^%ZTLOAD
"RTN","XPDIJ",36,0)
 D CHEK^XQ83
"RTN","XPDIJ",37,0)
 D:$O(^XPD(9.7,XPDA,"VOL",0))
"RTN","XPDIJ",38,0)
 .N XPDU,XPDY,XPDV,XPDV0,ZTUCI,ZTCPU
"RTN","XPDIJ",39,0)
 .X ^%ZOSF("UCI") S XPDU=$P(Y,","),XPDY=$P(Y,",",2),XPDV=0
"RTN","XPDIJ",40,0)
 .F  S XPDV=$O(^XPD(9.7,XPDA,"VOL",XPDV)) Q:'XPDV  S XPDV0=$P(^(XPDV,0),U) D:XPDV0'=XPDY
"RTN","XPDIJ",41,0)
 ..S ZTUCI=XPDU,ZTDTH=$H,ZTIO="",ZTDESC="Install Menu Rebuild",ZTCPU=XPDV0,ZTRTN="CHEK^XQ83" D ^%ZTLOAD
"RTN","XPDIJ",42,0)
 Q
"RTN","XPDIJ",43,0)
IN ;install XPDA
"RTN","XPDIJ",44,0)
 Q:'$D(^XTMP("XPDI",XPDA))!'$D(^XPD(9.7,XPDA,0))
"RTN","XPDIJ",45,0)
 Q:$P($G(^XPD(9.7,XPDA,1)),U,3)
"RTN","XPDIJ",46,0)
 N DIFROM,XPD,XPDBLD,XPDCHECK,XPDCP,XPDI,XPDRTN,XPDIST,XPDIDTOT,XPDIDCNT,XPDIDMOD
"RTN","XPDIJ",47,0)
 S DIFROM=$$VER^XPDUTL(XPDNM),XPDBLD=$O(^XTMP("XPDI",XPDA,"BLD",0))
"RTN","XPDIJ",48,0)
 D TITLE^XPDID(XPDNM)
"RTN","XPDIJ",49,0)
 I '$$CHK(11) D
"RTN","XPDIJ",50,0)
 .D BMES^XPDUTL(" Install Started for "_XPDNM_" : "),STMP(11)
"RTN","XPDIJ",51,0)
 .S XPD(9.7,XPDA_",",.02)=2,XPD(9.7,%_",",9)=DUZ
"RTN","XPDIJ",52,0)
 .D FILE^DIE("","XPD")
"RTN","XPDIJ",53,0)
 E  D BMES^XPDUTL(" Install Restarted for "_XPDNM_" at "_$$HTE^XLFDT($H))
"RTN","XPDIJ",54,0)
 I '$$CHK(12) D:$D(^XTMP("XPDI",XPDA,"RTN"))
"RTN","XPDIJ",55,0)
 .D:$O(^XPD(9.7,XPDA,"VOL",0))&$$TM^%ZTLOAD
"RTN","XPDIJ",56,0)
 ..N XPDU,XPDY,XPDV,XPDV0,ZTUCI,ZTCPU,ZTDESC,ZTRTN,ZTDTH,ZTIO,ZTSK
"RTN","XPDIJ",57,0)
 ..X ^%ZOSF("UCI") S XPDU=$P(Y,","),XPDY=$P(Y,",",2),XPDV=0
"RTN","XPDIJ",58,0)
 ..F  S XPDV=$O(^XPD(9.7,XPDA,"VOL",XPDV)) Q:'XPDV  S XPDV0=$P(^(XPDV,0),U) D:XPDV0'=XPDY
"RTN","XPDIJ",59,0)
 ...S ZTUCI=XPDU,ZTDTH=$H,ZTIO="",ZTDESC="KIDS update CPUs",ZTCPU=XPDV0,ZTRTN="EN^XPDCPU("_XPDA_","_XPDV_")"
"RTN","XPDIJ",60,0)
 ...D ^%ZTLOAD
"RTN","XPDIJ",61,0)
 ...Q:'$G(ZTSK)  K XPD
"RTN","XPDIJ",62,0)
 ...S XPD(9.703,XPDV_","_XPDA_",",3)=ZTSK D FILE^DIE("","XPD")
"RTN","XPDIJ",63,0)
 .D BMES^XPDUTL(" Installing Routines:"),SETTOT^XPDID(9.8),RTN(XPDA),STMP(12)
"RTN","XPDIJ",64,0)
 E  D BMES^XPDUTL(" Routines already installed.")
"RTN","XPDIJ",65,0)
 S XPDCP="INI"
"RTN","XPDIJ",66,0)
 I '$$VERCP^XPDUTL("XPD PREINSTALL COMPLETED") D  Q:$D(XPDABORT)
"RTN","XPDIJ",67,0)
 .D QUES^XPDIQ("PRE")
"RTN","XPDIJ",68,0)
 .S XPDCHECK=1
"RTN","XPDIJ",69,0)
 .F  S XPDCHECK=$O(^XPD(9.7,XPDA,"INI",XPDCHECK)) Q:'XPDCHECK  S XPD=^(XPDCHECK,0) D  Q:$D(XPDABORT)
"RTN","XPDIJ",70,0)
 ..Q:$G(^XPD(9.7,XPDA,"INI",XPDCHECK,1))=""  S XPDRTN=^(1)
"RTN","XPDIJ",71,0)
 ..Q:$P(XPD,U,2)
"RTN","XPDIJ",72,0)
 ..I XPDCHECK=2 D BMES^XPDUTL(" Running Pre-Install Routine: "_XPDRTN)
"RTN","XPDIJ",73,0)
 ..I $D(XPDIDVT) S XPDIDTOT=0 D UPDATE^XPDID(0)
"RTN","XPDIJ",74,0)
 ..D @XPDRTN
"RTN","XPDIJ",75,0)
 ..I $D(XPDABORT) D BMES^XPDUTL("Install ** ABORTED ** in Pre-Install program") Q
"RTN","XPDIJ",76,0)
 ..S %=$$COMCP^XPDUTL(XPDCHECK)
"RTN","XPDIJ",77,0)
 .S %=$$COMCP^XPDUTL("XPD PREINSTALL COMPLETED")
"RTN","XPDIJ",78,0)
 E  D BMES^XPDUTL(" Pre-Install already finished.")
"RTN","XPDIJ",79,0)
 D QUES^XPDIQ("XPF")
"RTN","XPDIJ",80,0)
 S XPD=$G(^(+$O(^XPD(9.7,XPDA,4,"A"),-1),0))
"RTN","XPDIJ",81,0)
 I '$P(XPD,U,2) D:$D(^XTMP("XPDI",XPDA,"FIA"))
"RTN","XPDIJ",82,0)
 .D BMES^XPDUTL(" Installing Data Dictionaries: "),SETTOT^XPDID(4),FIA^XPDIK,MES^XPDUTL("               "_$$HTE^XLFDT($H))
"RTN","XPDIJ",83,0)
 E  D BMES^XPDUTL(" Data Dictionaries already installed.")
"RTN","XPDIJ",84,0)
 S %=+$O(^XTMP("XPDI",XPDA,"DATA",""),-1),XPD=$G(^XPD(9.7,XPDA,4,%,0))
"RTN","XPDIJ",85,0)
 I '$P(XPD,U,3) D:%
"RTN","XPDIJ",86,0)
 .D BMES^XPDUTL(" Installing Data: "),DAT^XPDIK,MES^XPDUTL("               "_$$HTE^XLFDT($H))
"RTN","XPDIJ",87,0)
 E  D BMES^XPDUTL(" Data already installed.")
"RTN","XPDIJ",88,0)
 S (%,XPD)=""
"RTN","XPDIJ",89,0)
 F  S %=+$O(^XPD(9.7,XPDA,"KRN",%)) Q:'%  S XPD=$G(^(%,0)) Q:'$P(XPD,U,2)
"RTN","XPDIJ",90,0)
 I '$P(XPD,U,2) D:$D(^XTMP("XPDI",XPDA,"KRN"))
"RTN","XPDIJ",91,0)
 .D BMES^XPDUTL(" Installing PACKAGE COMPONENTS: "),KRN^XPDIK,MES^XPDUTL("               "_$$HTE^XLFDT($H))
"RTN","XPDIJ",92,0)
 E  D BMES^XPDUTL(" PACKAGE COMPONENTS already installed.")
"RTN","XPDIJ",93,0)
 S XPDCP="INIT"
"RTN","XPDIJ",94,0)
 I '$$VERCP^XPDUTL("XPD POSTINSTALL COMPLETED") D
"RTN","XPDIJ",95,0)
 .D QUES^XPDIQ("POS")
"RTN","XPDIJ",96,0)
 .S XPDCHECK=1
"RTN","XPDIJ",97,0)
 .F  S XPDCHECK=$O(^XPD(9.7,XPDA,"INIT",XPDCHECK)) Q:'XPDCHECK  S XPD=^(XPDCHECK,0) D
"RTN","XPDIJ",98,0)
 ..Q:$G(^XPD(9.7,XPDA,"INIT",XPDCHECK,1))=""  S XPDRTN=^(1)
"RTN","XPDIJ",99,0)
 ..Q:$P(XPD,U,2)
"RTN","XPDIJ",100,0)
 ..I XPDCHECK=2 D BMES^XPDUTL(" Running Post-Install Routine: "_XPDRTN)
"RTN","XPDIJ",101,0)
 ..I $D(XPDIDVT) S XPDIDTOT=0 D UPDATE^XPDID(0)
"RTN","XPDIJ",102,0)
 ..D @XPDRTN
"RTN","XPDIJ",103,0)
 ..S %=$$COMCP^XPDUTL(XPDCHECK)
"RTN","XPDIJ",104,0)
 .S %=$$COMCP^XPDUTL("XPD POSTINSTALL COMPLETED")
"RTN","XPDIJ",105,0)
 E  D BMES^XPDUTL(" Post-Install already finished.")
"RTN","XPDIJ",106,0)
 D BMES^XPDUTL(" Updating Routine file..."),SETTOT^XPDID(9.8),RTN^XPDIP
"RTN","XPDIJ",107,0)
 S XPDIST="" D BMES^XPDUTL(" Updating KIDS files..."),PKG^XPDIP
"RTN","XPDIJ",108,0)
 D BMES^XPDUTL(" "_XPDNM_" Installed. "),STMP(17)
"RTN","XPDIJ",109,0)
 I $L(XPDIST) S %=$$EN^XPDIST(XPDA,XPDIST) D BMES^XPDUTL(" "_$P("NO ",U,'$P(%,"#",2))_"Install Message sent "_%)
"RTN","XPDIJ",110,0)
 Q
"RTN","XPDIJ",111,0)
 ;
"RTN","XPDIJ",112,0)
STMP(X) ;timestamp checkpoints in file 9.7, X=field #
"RTN","XPDIJ",113,0)
 N XPD,%
"RTN","XPDIJ",114,0)
 S %=$$NOW^XLFDT,XPD(9.7,XPDA_",",X)=%
"RTN","XPDIJ",115,0)
 D MES^XPDUTL("               "_$$FMTE^XLFDT(%)),FILE^DIE("","XPD")
"RTN","XPDIJ",116,0)
 Q
"RTN","XPDIJ",117,0)
CHK(X) ;check checkpoints in file 9.7, X=field #, returns 1=completed, 0=not completed
"RTN","XPDIJ",118,0)
 Q $$GET1^DIQ(9.7,XPDA_",",X,"I")]""
"RTN","XPDIJ",119,0)
 ;
"RTN","XPDIJ",120,0)
SAVE(X) ;restore routine X
"RTN","XPDIJ",121,0)
 N %,DIE,XCM,XCN,XCS
"RTN","XPDIJ",122,0)
 S DIE="^XTMP(""XPDI"",XPDA,""RTN"",X,",XCN=0
"RTN","XPDIJ",123,0)
 X ^%ZOSF("SAVE")
"RTN","XPDIJ",124,0)
 Q
"RTN","XPDIJ",125,0)
RTN(XPDA) ;restore all routines for package XPDA
"RTN","XPDIJ",126,0)
 Q:$G(XPDA)=""
"RTN","XPDIJ",127,0)
 N X,XPDI,XPDJ S XPDI=""
"RTN","XPDIJ",128,0)
 F  S XPDI=$O(^XTMP("XPDI",XPDA,"RTN",XPDI)) Q:XPDI=""  S XPDJ=^(XPDI) D
"RTN","XPDIJ",129,0)
 .I $D(XPDIDVT) S XPDIDCNT=XPDIDCNT+1 D:'(XPDIDCNT#XPDIDMOD) UPDATE^XPDID(XPDIDCNT)
"RTN","XPDIJ",130,0)
 .I 'XPDJ D SAVE(XPDI) Q
"RTN","XPDIJ",131,0)
 .I $P(XPDJ,U,2) S $P(^XTMP("XPDI",XPDA,"BLD",XPDBLD,"KRN",9.8,"NM",$P(XPDJ,U,2),0),U,4)=""
"RTN","XPDIJ",132,0)
 .I $P(XPDJ,U)=1 S X=XPDI X ^%ZOSF("DEL")
"RTN","XPDIJ",133,0)
 I $D(XPDIDVT) D UPDATE^XPDID(XPDIDCNT)
"RTN","XPDIJ",134,0)
 Q
"RTN","XPDIJ",135,0)
ERR D BMES^XPDUTL($$EC^%ZOSV),EXIT^XPDID()
"RTN","XPDIJ",136,0)
 G ERR^ZU
"RTN","XPDR")
0^12^B35753744
"RTN","XPDR",1,0)
XPDR ;SFISC/RSD - Routine File Edit ; 7 Sep 95 07:51
"RTN","XPDR",2,0)
 ;;8.0;KERNEL;**1,2**;Jul 10, 1995
"RTN","XPDR",3,0)
 Q
"RTN","XPDR",4,0)
UPDT ;update routine file
"RTN","XPDR",5,0)
 N DIR,DIRUT,XPD,XPDI,XPDJ,XPDN,X,X1,Y,Y1,% W !
"RTN","XPDR",6,0)
 W ! S DIR(0)="FO^1:9^K:X'?.1""-""1U.7UNP X",DIR("A")="Routine Namespace",DIR("?")="Enter 1 to 8 characters, preceed with ""-"" to exclude namespace"
"RTN","XPDR",7,0)
 F  D ^DIR Q:$D(DIRUT)  S X=$E(Y,$L(Y))="*",%=$E(Y)="-",XPDN('%,$E(Y,%+1,$L(Y)-X))=""
"RTN","XPDR",8,0)
 Q:'$D(XPDN)!$D(DTOUT)!$D(DUOUT)
"RTN","XPDR",9,0)
 W !!,"NAMESPACE  INCLUDE",?35,"EXCLUDE",!,?11,"-------",?35,"-------"
"RTN","XPDR",10,0)
 S (X,Y)="",(X1,Y1)=1
"RTN","XPDR",11,0)
 F  D  W !?11,X,?35,Y Q:'X1&'Y1
"RTN","XPDR",12,0)
 .S:X1 X=$O(XPDN(1,X)),X1=X]"" S:Y1 Y=$O(XPDN(0,Y)),Y1=Y]""
"RTN","XPDR",13,0)
 K DIR S DIR(0)="Y",DIR("A")="OK to continue",DIR("B")="YES" D ^DIR
"RTN","XPDR",14,0)
 Q:'Y!$D(DIRUT)  W !
"RTN","XPDR",15,0)
 S DIR(0)="Y",DIR("A")="Want me to clean up the Routine File before updating",DIR("?")="YES means you want to go throught the Routine file and delete any routine name that no longer exists on the system."
"RTN","XPDR",16,0)
 D ^DIR
"RTN","XPDR",17,0)
 Q:$D(DIRUT)  D WAIT^DICD,DELRTN:Y
"RTN","XPDR",18,0)
 S XPDI="" F  S XPDI=$O(XPDN(1,XPDI)) Q:XPDI=""  D
"RTN","XPDR",19,0)
 .S XPDJ=XPDI D:$D(^$R(XPDJ))  F  S XPDJ=$O(^$R(XPDJ)) Q:XPDJ=""!($P(XPDJ,XPDI)]"")  D
"RTN","XPDR",20,0)
 ..Q:$D(XPDN(0,XPDJ))!$O(^DIC(9.8,"B",XPDJ,0))
"RTN","XPDR",21,0)
 ..S %=$O(XPDN(0,XPDJ),-1) I $L(%),$P(XPDJ,%)="" Q
"RTN","XPDR",22,0)
 ..N XPD S XPD(9.8,"+1,",.01)=XPDJ,XPD(9.8,"+1,",1)="R"
"RTN","XPDR",23,0)
 ..D ADD^DICA("","XPD")
"RTN","XPDR",24,0)
 W "    ...Done.",!
"RTN","XPDR",25,0)
 Q
"RTN","XPDR",26,0)
VER ;verify Routine file
"RTN","XPDR",27,0)
 N DIR,DIRUT,X,Y
"RTN","XPDR",28,0)
 W !,"I will delete all entries in the Routine File in which",!,"the Routine no longer exist on this system!",!
"RTN","XPDR",29,0)
 S DIR(0)="Y",DIR("A")="OK to continue",DIR("B")="YES" D ^DIR
"RTN","XPDR",30,0)
 Q:'Y!$D(DIRUT)  D DELRTN
"RTN","XPDR",31,0)
 W "    ...Done.",!
"RTN","XPDR",32,0)
 Q
"RTN","XPDR",33,0)
DELRTN ;delete routine file entries
"RTN","XPDR",34,0)
 N DA,DIK,Y
"RTN","XPDR",35,0)
 S DIK="^DIC(9.8,",DA=0
"RTN","XPDR",36,0)
 F  S DA=$O(^DIC(9.8,DA)) Q:'DA  S Y=$G(^(DA,0)) I $P(Y,U,2)="R",$T(^@$P(Y,U))="" D ^DIK
"RTN","XPDR",37,0)
 Q
"RTN","XPDR",38,0)
PURGE ;purge file
"RTN","XPDR",39,0)
 N DA,DIK,DIR,DIRUT,X,XPD,XPDF,XPDL,XPDN,XPDPG,XPDS,XPDUL,Y
"RTN","XPDR",40,0)
 S DIR("?")="Enter the file you want to purge the data from.",DIR(0)="SM^B:Build;I:Install;ALL:Build & Install",DIR("A")="Purge from what file(s)"
"RTN","XPDR",41,0)
 D ^DIR Q:$D(DIRUT)
"RTN","XPDR",42,0)
 S XPDF=$S(Y="I":9.7,1:9.6) S:Y="ALL" XPDF(1)=9.7
"RTN","XPDR",43,0)
 K DIR S DIR("?")="Enter the number of Versions to keep in the file, for each package",DIR(0)="N^0:100:0",DIR("A")="Versions to Retain",DIR("B")=1
"RTN","XPDR",44,0)
 D ^DIR Q:$D(DIRUT)  S XPDN=Y
"RTN","XPDR",45,0)
 K DIR
"RTN","XPDR",46,0)
 S DIR(0)="FO^3:30",DIR("?")="^D PURGEH^XPDR",DIR("A")="Package Name",DIR("B")="ALL"
"RTN","XPDR",47,0)
 F  D ^DIR Q:$D(DIRUT)  S XPD(X)="" Q:X="ALL"  K DIR("B") S DIR("A")="Another Package Name"
"RTN","XPDR",48,0)
 Q:'$D(XPD)
"RTN","XPDR",49,0)
 I $D(XPD("ALL")) K XPD S XPD("ALL")=""
"RTN","XPDR",50,0)
 K ^TMP($J) D PURGE1(XPDF),PURGE1($G(XPDF(1))):$D(XPDF(1))
"RTN","XPDR",51,0)
 I '$D(^TMP($J)) W !!,"No match found" Q
"RTN","XPDR",52,0)
 K XPD,DIR
"RTN","XPDR",53,0)
 S DIR(0)="E",$P(XPDUL,"-",IOM)=""
"RTN","XPDR",54,0)
 D  I $D(XPDF(1)) D ^DIR I Y S XPDF=XPDF(1) D  S XPDF=9.6
"RTN","XPDR",55,0)
 .S XPD="^TMP("_$J_","_XPDF,XPDS=XPD_",",XPD=XPD_")",XPDL=$L(XPDS),XPDPG=1,Y=1
"RTN","XPDR",56,0)
 .W @IOF D HDR
"RTN","XPDR",57,0)
 .F  S XPD=$Q(@XPD) Q:XPD=""!($E(XPD,1,XPDL)'=XPDS)  D  Q:'Y
"RTN","XPDR",58,0)
 ..W $P(@XPD,"^",2),! Q:$Y<(IOSL-4)
"RTN","XPDR",59,0)
 ..D ^DIR Q:'Y
"RTN","XPDR",60,0)
 ..S XPDPG=XPDPG+1 W @IOF D HDR
"RTN","XPDR",61,0)
 S DIR(0)="Y",DIR("A")="OK to DELETE these entries",DIR("B")="NO"
"RTN","XPDR",62,0)
 W !! D ^DIR
"RTN","XPDR",63,0)
 I $D(DIRUT)!'Y W !!,"Nothing Purged" Q
"RTN","XPDR",64,0)
 D  I $D(XPDF(1)) S XPDF=XPDF(1) D
"RTN","XPDR",65,0)
 .S DIK="^XPD("_XPDF_",",XPD="^TMP("_$J_","_XPDF,XPDS=XPD_",",XPD=XPD_")",XPDL=$L(XPDS)
"RTN","XPDR",66,0)
 .F  S XPD=$Q(@XPD) Q:XPD=""!($E(XPD,1,XPDL)'=XPDS)  S DA=+@XPD D:DA ^DIK
"RTN","XPDR",67,0)
 Q
"RTN","XPDR",68,0)
 ;
"RTN","XPDR",69,0)
PURGE1(XPDF) ;XPDF=file #
"RTN","XPDR",70,0)
 N XPDFL,XPDI,XPDJ,XPDP,XPDV,Y,Z
"RTN","XPDR",71,0)
 W "."
"RTN","XPDR",72,0)
 I $D(XPD("ALL")) D
"RTN","XPDR",73,0)
 .S XPDI=""
"RTN","XPDR",74,0)
 .F  S XPDI=$O(^XPD(XPDF,"B",XPDI)) Q:XPDI=""  D
"RTN","XPDR",75,0)
 ..S X=$$PKG^XPDUTL(XPDI) D PURGE2(X)
"RTN","XPDR",76,0)
 ..W "."
"RTN","XPDR",77,0)
 E  S XPDI="" F  S XPDI=$O(XPD(XPDI)) Q:XPDI=""  D
"RTN","XPDR",78,0)
 .D PURGE2(XPDI)
"RTN","XPDR",79,0)
 .W "."
"RTN","XPDR",80,0)
 S XPDP="" F  S XPDP=$O(^TMP($J,XPDF,XPDP)) Q:XPDP=""  D
"RTN","XPDR",81,0)
 .S XPDV="",XPDL=XPDN
"RTN","XPDR",82,0)
 .F  S XPDV=$O(^TMP($J,XPDF,XPDP,XPDV),-1),XPDS="" Q:'XPDV!'XPDL  F  S XPDS=$O(^TMP($J,XPDF,XPDP,XPDV,XPDS),-1) Q:XPDS=""!'XPDL  D
"RTN","XPDR",83,0)
 ..S Y="" F  S Y=$O(^TMP($J,XPDF,XPDP,XPDV,XPDS,Y),-1) Q:Y=""!'XPDL  D
"RTN","XPDR",84,0)
 ...I $D(^TMP($J,XPDF,XPDP,XPDV,XPDS,Y))#2 K ^(Y) S XPDL=XPDL-1 Q
"RTN","XPDR",85,0)
 ...S Z="" F  S Z=$O(^TMP($J,XPDF,XPDP,XPDV,XPDS,Y,Z),-1) Q:Z=""!'XPDL  K ^(Z) S XPDL=XPDL-1
"RTN","XPDR",86,0)
 Q
"RTN","XPDR",87,0)
 ;
"RTN","XPDR",88,0)
PURGE2(XPDX) ;XPDX=package name
"RTN","XPDR",89,0)
 S XPDS=XPDX,XPDL=$L(XPDX),XPDFL=XPDX'["*"
"RTN","XPDR",90,0)
 D  F  S XPDS=$O(^XPD(XPDF,"B",XPDS)) Q:XPDS=""!($E(XPDS,1,XPDL)'=XPDX)!($S(XPDFL:XPDS["*",1:0))  D
"RTN","XPDR",91,0)
 .S Y=$O(^XPD(XPDF,"B",XPDS,0)) Q:'Y
"RTN","XPDR",92,0)
 .Q:'$D(^XPD(XPDF,Y,0))  S Z=^(0),Y=Y_"^"_XPDS
"RTN","XPDR",93,0)
 .I XPDF=9.7 Q:$P(Z,U,9)<3
"RTN","XPDR",94,0)
 .S XPDV=$$VER^XPDUTL(XPDS)
"RTN","XPDR",95,0)
 .I XPDS["*" D  Q
"RTN","XPDR",96,0)
 ..I XPDV?1.2N1"."1.2N S ^TMP($J,XPDF,$$PKG^XPDUTL(XPDS),+XPDV,"*Z",0,+$P(XPDS,"*",3))=Y Q
"RTN","XPDR",97,0)
 ..I XPDV["T" S ^TMP($J,XPDF,$$PKG^XPDUTL(XPDS),+XPDV,"*T",+$P(XPDV,"T",2),+$P(XPDS,"*",3))=Y Q
"RTN","XPDR",98,0)
 ..I XPDV["V" S ^TMP($J,XPDF,$$PKG^XPDUTL(XPDS),+XPDV,"*V",+$P(XPDV,"V",2),+$P(XPDS,"*",3))=Y Q
"RTN","XPDR",99,0)
 ..S ^TMP($J,XPDF,$$PKG^XPDUTL(XPDS),+XPDV,"*",+$P(XPDS,"*",3))=Y
"RTN","XPDR",100,0)
 .I XPDV?1.2N1"."1.2N S ^TMP($J,XPDF,$$PKG^XPDUTL(XPDS),+XPDV,"Z",0)=Y Q
"RTN","XPDR",101,0)
 .I XPDV["T" S ^TMP($J,XPDF,$$PKG^XPDUTL(XPDS),+XPDV,"T",+$P(XPDV,"T",2))=Y Q
"RTN","XPDR",102,0)
 .I XPDV["V" S ^TMP($J,XPDF,$$PKG^XPDUTL(XPDS),+XPDV,"V",+$P(XPDV,"V",2))=Y Q
"RTN","XPDR",103,0)
 Q
"RTN","XPDR",104,0)
PURGEH ;executable help from DIR call at PURGE+8
"RTN","XPDR",105,0)
 W:$E(DIR("A"),1)="P" !,"Enter 'ALL' to purge all packages, or"
"RTN","XPDR",106,0)
 W !,"Enter the name of the Package you want to Purge.",!," i.e. KERNEL 8.0  will purge version 8.0Tx and 8.0Vx",!,"      XU*8.0 will purge all patches for 8.0",!
"RTN","XPDR",107,0)
 N DIR,X,Y
"RTN","XPDR",108,0)
 S DIR(0)="Y",DIR("A")="Want to see the "_$S(XPDF=9.7:"Install File",$D(XPDF(1)):"Build & Install Files",1:"Build File")_" List",DIR("B")="Y"
"RTN","XPDR",109,0)
 D ^DIR Q:'Y!$D(DIRUT)
"RTN","XPDR",110,0)
 D PURGEH1("^XPD(9.6,"):XPDF=9.6,PURGEH1("^XPD(9.7,"):XPDF=9.7!$D(XPDF(1))
"RTN","XPDR",111,0)
 Q
"RTN","XPDR",112,0)
PURGEH1(DIC) ;
"RTN","XPDR",113,0)
 W !!,$S(DIC[9.6:"BUILD ",1:"INSTALL ")_"File"
"RTN","XPDR",114,0)
 S DIC(0)="QE",X="??" D ^DIC
"RTN","XPDR",115,0)
 Q
"RTN","XPDR",116,0)
 ;
"RTN","XPDR",117,0)
HDR W !,"Package(s) in ",$S(XPDF=9.7:"INSTALL",1:"BUILD")," File, "
"RTN","XPDR",118,0)
 I XPDN W "Retain last ",$S(XPDN=1:"version",1:XPDN_" versions")
"RTN","XPDR",119,0)
 E  W "Don't retain any versions"
"RTN","XPDR",120,0)
 W ?70,"PAGE ",XPDPG,!,XPDUL,!
"RTN","XPDR",121,0)
 Q
"RTN","XPDT")
0^11^B29809851
"RTN","XPDT",1,0)
XPDT ;SFISC/RSD - Transport a package; 3 Aug 95 09:03
"RTN","XPDT",2,0)
 ;;8.0;KERNEL;**2**;Jul 10, 1995
"RTN","XPDT",3,0)
EN ;build XTMP("XPDT",ien, XPDA=ien,XPDNM=name
"RTN","XPDT",4,0)
 N DIR,DIRUT,I,POP,XPD,XPDA,XPDERR,XPDGP,XPDH,XPDHD,XPDI,XPDNM,XPDSEQ,XPDSIZ,XPDSIZA,XPDT,XPDTP,XPDVER,X,Y,Z
"RTN","XPDT",5,0)
 K ^TMP($J,"XPD")
"RTN","XPDT",6,0)
 S XPD="First Package Name: ",XPDT=0,DIR(0)="Y",DIR("A")="   Use this Transport Global",DIR("?")="Yes, will use the current Transport Global on your system. No, will create a new one."
"RTN","XPDT",7,0)
 W !!,"Enter the Package Names to be transported. The order in which",!,"they are entered will be the order in which they are installed.",!!
"RTN","XPDT",8,0)
 F  S XPDA=$$DIC^XPDE("AEMQZ",XPD) Q:'XPDA  D  Q:$D(DIRUT)!$D(XPDERR)
"RTN","XPDT",9,0)
 .S:'XPDT XPD="Another Package Name: "
"RTN","XPDT",10,0)
 .S XPDI=$P(Y(0),U)_"^"
"RTN","XPDT",11,0)
 .I $D(XPDT("DA",XPDA)) W "   ",$P(Y(0),U)," already listed",! Q
"RTN","XPDT",12,0)
 .I $P(Y(0),U,3)=2 W "   GLOBAL PACKAGE" D  Q:$D(DIRUT)
"RTN","XPDT",13,0)
 ..I XPDT S DIRUT=1 W !,"A GLOBAL PACKAGE cannot be sent with any other packages" Q
"RTN","XPDT",14,0)
 ..W !?10,"will transport the following globals:",! S X=0,XPDGP=""
"RTN","XPDT",15,0)
 ..F  S X=$O(^XPD(9.6,XPDA,"GLO",X)) Q:'X  S Z=$G(^(X,0)) I $P(Z,U)]"" S XPDGP=XPDGP_($P(Z,U,2)="y")_";"_$P(Z,U)_"^" W ?12,$P(Z,U),!
"RTN","XPDT",16,0)
 ..S XPDERR=1
"RTN","XPDT",17,0)
 .S XPDT=XPDT+1,XPDT(XPDT)=XPDA_U_XPDI,XPDT("DA",XPDA)=XPDT
"RTN","XPDT",18,0)
 .I $D(^XTMP("XPDT",XPDA)) W "     **Transport Global exists**" D ^DIR S $P(XPDT(XPDT),U,3)=Y
"RTN","XPDT",19,0)
 G:'XPDT!$D(DIRUT) QUIT K XPDERR
"RTN","XPDT",20,0)
 W !!,"ORDER   PACKAGE",!
"RTN","XPDT",21,0)
 F XPDT=1:1:XPDT S Y=$P(XPDT(XPDT),U,2) W ?2,XPDT,?7,Y D  W !
"RTN","XPDT",22,0)
 .W:$P(XPDT(XPDT),U,3) "     **will use current Transport Global**"
"RTN","XPDT",23,0)
 S DIR(0)="Y",DIR("A")="OK to continue",DIR("B")="NO",XPDH=""
"RTN","XPDT",24,0)
 W !! D ^DIR G:$D(DIRUT)!'Y QUIT
"RTN","XPDT",25,0)
 D DEV G:POP QUIT
"RTN","XPDT",26,0)
 U IO(0)
"RTN","XPDT",27,0)
 I XPDH="" D  G:$D(DIRUT) QUIT
"RTN","XPDT",28,0)
 .S DIR(0)="Y",DIR("A")="Would you like this sent via the network",DIR("??")="^D MSG^XPDH"
"RTN","XPDT",29,0)
 .D ^DIR Q:$D(DIRUT)
"RTN","XPDT",30,0)
 .I 'Y W !,"No File selected, will only write Transport Global to ^XTMP." Q
"RTN","XPDT",31,0)
 .I XPDT>1 W !!,"You cannot send multiple Builds over the network." S DIRUT=1 Q
"RTN","XPDT",32,0)
 .S XPDTP=1
"RTN","XPDT",33,0)
 W !!
"RTN","XPDT",34,0)
 F XPDT=1:1:XPDT S XPDA=XPDT(XPDT),XPDNM=$P(XPDA,U,2) D  G:$D(XPDERR) ABORT
"RTN","XPDT",35,0)
 .W !?5,XPDNM,"..." Q:$P(XPDA,U,3)
"RTN","XPDT",36,0)
 .S XPDA=+XPDA,XPDVER=$S($P(^XPD(9.6,XPDA,0),U,2):$$VER^XPDUTL(XPDNM)_U_$$PKG^XPDUTL(XPDNM),1:"")
"RTN","XPDT",37,0)
 .K ^XTMP("XPDT",XPDA)
"RTN","XPDT",38,0)
 .I $D(XPDGP) D  S XPDT=1 Q
"RTN","XPDT",39,0)
 ..I $G(XPDTP) S XPDERR=1 Q
"RTN","XPDT",40,0)
 ..I '$$GLOPKG^XPDV(XPDA) S XPDERR=1 Q
"RTN","XPDT",41,0)
 ..F Y="PRE","INIT" I $G(^XPD(9.6,XPDA,Y))]"" S X=^(Y) D
"RTN","XPDT",42,0)
 ...S ^XTMP("XPDT",XPDA,Y)=X,X=$P(X,U,$L(X,U)),%=$$LOAD^XPDTA(X,"0^")
"RTN","XPDT",43,0)
 ..D BLD^XPDTC
"RTN","XPDT",44,0)
 .F X="DD^XPDTC","KRN^XPDTC","QUES^XPDTC","INT^XPDTC","BLD^XPDTC" D @X Q:$D(XPDERR)
"RTN","XPDT",45,0)
 I $G(XPDTP) S XPDA=+XPDT(XPDT) D ^XPDTP G QUIT
"RTN","XPDT",46,0)
 I $L(XPDH) D GO G QUIT
"RTN","XPDT",47,0)
 W !! F XPDT=1:1:XPDT W "Transport Global ^XTMP(""XPDT"","_+XPDT(XPDT)_") created for ",$P(XPDT(XPDT),U,2),!
"RTN","XPDT",48,0)
 Q
"RTN","XPDT",49,0)
DEV N FIL,DIR,IOP,X,Y,%ZIS W !
"RTN","XPDT",50,0)
 D HOME^%ZIS
"RTN","XPDT",51,0)
 S DIR(0)="FO^3:45",DIR("A")="Enter a Host File",DIR("?")="Enter a filename and/or path to output packages.",POP=0
"RTN","XPDT",52,0)
 D ^DIR I $D(DTOUT)!$D(DUOUT) S POP=1 Q
"RTN","XPDT",53,0)
 Q:Y=""  S FIL=Y
"RTN","XPDT",54,0)
 S DIR(0)="F^3:80",DIR("A")="Header Comment"
"RTN","XPDT",55,0)
 D ^DIR I $D(DIRUT) S POP=1 Q
"RTN","XPDT",56,0)
 S XPDH=Y,%ZIS="",%ZIS("HFSNAME")=FIL,%ZIS("HFSMODE")="W",IOP="HFS",(XPDSIZ,XPDSIZA)=0,XPDSEQ=1
"RTN","XPDT",57,0)
 I ^%ZOSF("OS")["MSM",FIL?1(1"A",1"B")1":"1.E D  Q:POP
"RTN","XPDT",58,0)
 .S DIR(0)="N^0:5000",DIR("A")="Size of Diskette (1K blocks)",DIR("B")=1400,DIR("?")="Enter the number of 1K blocks which each diskette will hold, 0 means unlimited space"
"RTN","XPDT",59,0)
 .D ^DIR I $D(DIRUT) S POP=1 Q
"RTN","XPDT",60,0)
 .S XPDSIZ=$S(Y:Y*1024,1:0)
"RTN","XPDT",61,0)
 D ^%ZIS I POP W !!,"**Incorrect Host File name**",!,$C(7) Q
"RTN","XPDT",62,0)
 S XPDHD="KIDS Distribution saved on "_$$HTE^XLFDT($H)
"RTN","XPDT",63,0)
 U IO W $$SUM(XPDHD),!,$$SUM(XPDH),!
"RTN","XPDT",64,0)
 Q
"RTN","XPDT",65,0)
GO S I=1,Y="" U IO
"RTN","XPDT",66,0)
 I $D(XPDGP) W $$SUM("**KIDS**GLOBALS:"_$P(XPDT(1),U,2)_U_XPDGP),! G GO1
"RTN","XPDT",67,0)
 E  F  D  W $$SUM("**KIDS**:"_Y),! Q:I=XPDT  S Y="",I=I+1
"RTN","XPDT",68,0)
 .F I=I:1 S Y=Y_$P(XPDT(I),U,2)_"^" Q:$L(Y)>200!(I=XPDT)
"RTN","XPDT",69,0)
GO1 W ! S XPDSIZA=XPDSIZA+2
"RTN","XPDT",70,0)
 F XPDT=1:1:XPDT S XPDA=+XPDT(XPDT),XPDNM=$P(XPDT(XPDT),U,2) D GW K ^XTMP("XPDT",XPDA)
"RTN","XPDT",71,0)
 W "**END**",!
"RTN","XPDT",72,0)
 I $D(XPDGP) D GPW W "**END**",!
"RTN","XPDT",73,0)
 W "**END**",! D ^%ZISC
"RTN","XPDT",74,0)
 W !!,"Package Transported Successfully",!
"RTN","XPDT",75,0)
 Q
"RTN","XPDT",76,0)
GW ;global write
"RTN","XPDT",77,0)
 N GR,GCK,GL
"RTN","XPDT",78,0)
 S GCK="^XTMP(""XPDT"","_XPDA,GR=GCK_")",GCK=GCK_",",GL=$L(GCK)
"RTN","XPDT",79,0)
 W $$SUM("**INSTALL NAME**",1),!,$$SUM(XPDNM),!
"RTN","XPDT",80,0)
 F  Q:$D(DIRUT)  S GR=$Q(@GR) Q:GR=""!($E(GR,1,GL)'=GCK)  W $$SUM($P(GR,GCK,2),1),!,$$SUM(@GR),!
"RTN","XPDT",81,0)
 Q
"RTN","XPDT",82,0)
GPW ;global package write
"RTN","XPDT",83,0)
 N I,G,GR,GCK,GL
"RTN","XPDT",84,0)
 W !
"RTN","XPDT",85,0)
 F I=1:1 S G=$P(XPDGP,U,I) Q:G=""  D
"RTN","XPDT",86,0)
 .S GR="^"_$P(G,";",2),GCK=$S(GR[")":$E(GR,1,$L(GR)-1)_",",1:GR_"("),GL=$L(GCK)
"RTN","XPDT",87,0)
 .W $$SUM("**GLOBAL**",1),!,$$SUM(GR),!
"RTN","XPDT",88,0)
 .F  Q:$D(DIRUT)  S GR=$Q(@GR) Q:GR=""!($E(GR,1,GL)'=GCK)  W $$SUM($P(GR,GCK,2),1),!,$$SUM(@GR),!
"RTN","XPDT",89,0)
 Q
"RTN","XPDT",90,0)
QUIT F XPDT=1:1:XPDT L -^XPD(9.6,+XPDT(XPDT))
"RTN","XPDT",91,0)
 Q
"RTN","XPDT",92,0)
ABORT W !!,"**TRANSPORT ABORTED**",*7
"RTN","XPDT",93,0)
 D QUIT
"RTN","XPDT",94,0)
 F XPDT=1:1:XPDT K ^XTMP("XPDT",+XPDT(XPDT))
"RTN","XPDT",95,0)
 D ^%ZISC
"RTN","XPDT",96,0)
 Q
"RTN","XPDT",97,0)
SUM(X,Z) ;X=string to write, Z 0=don't check size
"RTN","XPDT",98,0)
 S XPDSIZA=XPDSIZA+$L(X)+2
"RTN","XPDT",99,0)
 ;this code is for MSM system only
"RTN","XPDT",100,0)
 I $G(Z),XPDSIZ,XPDSIZ-XPDSIZA<1024 D
"RTN","XPDT",101,0)
 .W "**CONTINUE**",!,"**END**",!
"RTN","XPDT",102,0)
 .C IO U IO(0)
"RTN","XPDT",103,0)
 .N DIR,G,GR,GCK,GL,I,X,Y
"RTN","XPDT",104,0)
 .W !!,"Diskette #",XPDSEQ," is full."
"RTN","XPDT",105,0)
 .S DIR(0)="E",DIR("A")="Insert the next diskette and Press the return key",DIR("?")="The current diskette is full, insert a new diskette to continue."
"RTN","XPDT",106,0)
 .D ^DIR I $D(DIRUT) D ABORT Q
"RTN","XPDT",107,0)
 .W ! S XPDSEQ=XPDSEQ+1,XPDSIZA=0
"RTN","XPDT",108,0)
 .O @(""""_IO_""":"_IOPAR) U IO
"RTN","XPDT",109,0)
 .W $$SUM("Continuation #"_XPDSEQ_" of "_XPDHD),!,$$SUM(XPDH),!,$$SUM("**SEQ**:"_XPDSEQ),!!
"RTN","XPDT",110,0)
 .S XPDSIZA=XPDSIZA+2
"RTN","XPDT",111,0)
 Q X
"RTN","XUTMOPT")
0^1^B4988561
"RTN","XUTMOPT",1,0)
XUTMOPT ;SFISC/RWF - One time queue code. ;09/26/95  09:28
"RTN","XUTMOPT",2,0)
 ;;8.0;KERNEL;**2**;Jul 10, 1995
"RTN","XUTMOPT",3,0)
ONE ;One time queue setup
"RTN","XUTMOPT",4,0)
 W !!,"You can only select OPTION's that have the SCHEDULING RECOMMENDED",!,"field set to YES or STARTUP."
"RTN","XUTMOPT",5,0)
 N XUXQM,DIC,DIR,Y,ZTSK S DIC=19,DIC(0)="AEMQZ",DIC("S")="I $TR($P($G(^DIC(19,Y,200.9)),U,1),""nsy"",""011"")" D ^DIC G:Y'>0 EXIT
"RTN","XUTMOPT",6,0)
 S XUXQM=+Y,XUXQM(0)=Y(0)
"RTN","XUTMOPT",7,0)
 S DIR(0)="Y",DIR("A")="Does this option need a DEVICE",DIR("B")="NO" D ^DIR G:$D(DIRUT) EXIT
"RTN","XUTMOPT",8,0)
 S ZTIO="" I Y=1 S %ZIS="NQM",%ZIS("A")="Queue to Device:" D ^%ZIS G EXIT:POP K ZTIO
"RTN","XUTMOPT",9,0)
 S ZTSAVE("XQY")=$O(^DIC(19,"B","XU OPTION START",0)),ZTSAVE("XUXQM*")="",ZTRTN="ZTSK^XQ1" D ^%ZTLOAD
"RTN","XUTMOPT",10,0)
EXIT D HOME^%ZIS
"RTN","XUTMOPT",11,0)
 Q
"RTN","XUTMOPT",12,0)
EDIT(OPTION) ;User edit
"RTN","XUTMOPT",13,0)
 N DR,DIE,DA,DIC,DDSFILE
"RTN","XUTMOPT",14,0)
 I OPTION?1A.ANP S OPTION=$$FIND(OPTION) Q:OPTION'>0
"RTN","XUTMOPT",15,0)
 I '$D(^DIC(19.2,OPTION,0)) Q
"RTN","XUTMOPT",16,0)
 S DA=OPTION,DR="[XU OPTION SCHEDULE]",DIE="^DIC(19.2," D XUDIE^XUS5
"RTN","XUTMOPT",17,0)
 Q
"RTN","XUTMOPT",18,0)
DISP(OPTION) ;Display an option schedule (public entry-point)
"RTN","XUTMOPT",19,0)
 N DR,DIC,DA
"RTN","XUTMOPT",20,0)
 I OPTION?1A.ANP S OPTION=$$FIND(OPTION) Q:OPTION'>0
"RTN","XUTMOPT",21,0)
 S L=0,DIC="^DIC(19.2,",FLDS="[XQ-BACKGROUND SCHEDULE]",BY="NUMBER",(FR,TO)=OPTION,IOP=$G(IOP,0),DHD="Scheduled Option Display"
"RTN","XUTMOPT",22,0)
 D EN1^DIP
"RTN","XUTMOPT",23,0)
 Q
"RTN","XUTMOPT",24,0)
RESCH(OPTION,WHEN,DEVICE,BY,FLAG,ERR) ;EF. App reschedule entry point
"RTN","XUTMOPT",25,0)
 N DIE,DR,DIC,DA
"RTN","XUTMOPT",26,0)
 I OPTION?1A.ANP S OPTION=$$FIND(OPTION,$S($G(FLAG)["L":"L",1:""))
"RTN","XUTMOPT",27,0)
 I OPTION'>0 S ERR=-1
"RTN","XUTMOPT",28,0)
 S DIE="^DIC(19.2,",DA=OPTION,DR="" S:$D(WHEN) DR="2///"_WHEN_";" S:$D(DEVICE) DR=DR_"3///"_DEVICE_";" S:$D(BY) DR=DR_"6///"_BY
"RTN","XUTMOPT",29,0)
 D ^DIE
"RTN","XUTMOPT",30,0)
 Q
"RTN","XUTMOPT",31,0)
FIND(X,F) ;Find and option
"RTN","XUTMOPT",32,0)
 N DIC,Y,DLAYGO S DLAYGO=19
"RTN","XUTMOPT",33,0)
 ;S X=$O(^DIC(19,"B",X,0)) I X'>0 Q -1
"RTN","XUTMOPT",34,0)
 ;S X=$O(^DIC(19.2,"B",X,0)) I X'>0 Q -1
"RTN","XUTMOPT",35,0)
 S DIC="^DIC(19.2,",DIC(0)="M"_$G(F) D ^DIC S X=+Y
"RTN","XUTMOPT",36,0)
 Q X
"RTN","XUTMR")
0^15^B13199147
"RTN","XUTMR",1,0)
XUTMR ;SEA/RDS - Taskman: Requeue Interface, Part One ;9/8/95  15:49
"RTN","XUTMR",2,0)
 ;;8.0;KERNEL;**2**;Jul 10, 1995
"RTN","XUTMR",3,0)
 ;
"RTN","XUTMR",4,0)
INIT ;Setup
"RTN","XUTMR",5,0)
 D ENV^XUTMUTL
"RTN","XUTMR",6,0)
 W @IOF
"RTN","XUTMR",7,0)
LKUP ;Lookup Task
"RTN","XUTMR",8,0)
 F %ZTI=0:0 R !!,"Task Number: ",ZTSK:DTIME G Q^XUTMR1:"^"[ZTSK Q:$D(^%ZTSK(ZTSK,0))#2!(ZTSK="??")  W:ZTSK'="?" !?10,"This task is not listed in the Task Log." W !,"Please enter the number of an entry in the Task Log that you wish to requeue."
"RTN","XUTMR",9,0)
 I ZTSK="??" D ^XUTMQ G INIT
"RTN","XUTMR",10,0)
 L +^%ZTSK(ZTSK):5 E  W !!?10,"That file is not currently available.  Please try again later." G LKUP
"RTN","XUTMR",11,0)
 S ZTREC=^%ZTSK(ZTSK,0),ZTREC2=$S($D(^%ZTSK(ZTSK,.2))#2:^(.2),1:"")
"RTN","XUTMR",12,0)
 I 'ZTKEY,$S($P(ZTREC,U,11)_","_$P(ZTREC,U,12)=XUTMUCI:DUZ'=$P(ZTREC,U,3),1:ZTNAME'=$P(ZTREC,U,10)) W !!?10,"You may only requeue tasks that you originally queued." G LKUP
"RTN","XUTMR",13,0)
 I $P(ZTREC,U,1,2)="ZTSK^XQ1",$D(^%ZTSK(ZTSK,.3,"XQSCH")) W !!,"This is a scheduled option, Please use the SCHEDULE/UNSCHDULE option." G LKUP
"RTN","XUTMR",14,0)
 S %ZTDTH=$P(ZTREC,U,6),%ZTDTH(3)=$$H3^%ZTM(%ZTDTH)
"RTN","XUTMR",15,0)
 ;S %ZTIO=""
"RTN","XUTMR",16,0)
 ;F %ZTI=0:0 S %ZTIO=$O(^%ZTSCH("IO",%ZTIO)),%ZTU="" Q:%ZTIO=""  F %ZTI=0:0 S %ZTU=$O(^%ZTSCH("IO",%ZTIO,%ZTU)) Q:%ZTU=""  I $D(^%ZTSCH("IO",%ZTIO,%ZTU,ZTSK))#2 S %ZTIO(ZTSK)=%ZTIO G TIME
"RTN","XUTMR",17,0)
 ;
"RTN","XUTMR",18,0)
TIME ;Ask Requeue Time
"RTN","XUTMR",19,0)
 W ! D EN^XUTMTP(ZTSK) W !
"RTN","XUTMR",20,0)
 S %DT="AERSX",%DT("A")="Requeue for what time: ",%DT("B")="NOW"
"RTN","XUTMR",21,0)
 I $$HDIFF^XLFDT(%ZTDTH,$H,2)>0 S %DT("B")=$$HTE^XLFDT(%ZTDTH)
"RTN","XUTMR",22,0)
 D ^%DT G NEXT^XUTMR1:Y=-1 S ZTDTH=$$FMTH^XLFDT(Y)
"RTN","XUTMR",23,0)
 ;
"RTN","XUTMR",24,0)
DEV ;Ask Requeue Device And Calculate UCI And CPU Destination
"RTN","XUTMR",25,0)
 S %ZTYND="YES" S:$P(ZTREC2,U)="" %ZTYND="NO"
"RTN","XUTMR",26,0)
 S DIR("A")="Do you wish to change the Device the task goes to:",DIR("B")="No",DIR(0)="Y"
"RTN","XUTMR",27,0)
 S DIR("?")="Please enter whether you wish to change output device for this task." D ^DIR
"RTN","XUTMR",28,0)
 G NEXT^XUTMR1:$D(DIRUT) K ZTIO S ZTCPU=""
"RTN","XUTMR",29,0)
 I Y'=1 S ZTIO=$P(ZTREC2,U),%=$P(ZTREC2,U,6) S:$L(%) ZTIO("H")=% S:$D(^%ZTSK(ZTSK,.25))#2 ZTIO("P")=^(.25) G CONT
"RTN","XUTMR",30,0)
 ;
"RTN","XUTMR",31,0)
D0 S %ZIS("B")=$S($P(ZTREC2,U)]"":$P(ZTREC2,U),1:""),%ZIS="NQZ",%ZIS("A")="Requeue to what device: " D ^%ZIS S ZTIO=$S($D(IOS)[0:"",POP:"",$D(ION)[0:"",ION]"":ION,IOS="":"",$D(^%ZIS(1,IOS,0))[0:"",1:$P(^(0),U))
"RTN","XUTMR",32,0)
 I ZTIO="" W !!,"No device selected.  Task unchanged." G NEXT^XUTMR1
"RTN","XUTMR",33,0)
 I IOT="VTRM" D HOME^%ZIS W !,"Tasks can not open virtual terminals.  Please select another device.",$C(7),! G D0
"RTN","XUTMR",34,0)
 S ZTIO=ZTIO_$S($D(IOST)[0:"",1:";"_IOST)_$S($D(IO("DOC"))[0:$S($D(IOM)[0:"",1:";"_IOM_$S($D(IOSL)[0:"",1:";"_IOSL)),1:";"_IO("DOC"))_$S($D(IO("P"))[0:"",IO("P")="":"",1:";/"_IO("P")) S:$D(IOCPU)#2 ZTCPU=IOCPU
"RTN","XUTMR",35,0)
 I $D(IO("HFSIO"))#2,$D(IOPAR)#2,IOT="HFS" S ZTIO("H")=IO("HFSIO"),ZTIO("P")=IOPAR
"RTN","XUTMR",36,0)
 ;
"RTN","XUTMR",37,0)
CONT ;Taskman Requeue Interface Is Continued In XUTMR1
"RTN","XUTMR",38,0)
 G ^XUTMR1
"RTN","XUTMR",39,0)
 ;
"RTN","XUTMRP")
0^2^B29524049
"RTN","XUTMRP",1,0)
XUTMRP ;SFISC/RWF,BOSTON/MEF - REQUEUE ALL TASKS FOR A DEVICE -PART ONE ;9/8/95  11:10
"RTN","XUTMRP",2,0)
 ;;8.0;KERNEL;**2**;Jul 10, 1995
"RTN","XUTMRP",3,0)
 ;REPNT=1 if your using the ZZWFRep option because the device's lta#
"RTN","XUTMRP",4,0)
 ; was changed 
"RTN","XUTMRP",5,0)
INIT ;Setup
"RTN","XUTMRP",6,0)
 Q:$D(DUZ)[0  Q:DUZ=""!(DUZ=0)  D ENV^XUTMUTL S XUCPU=$P(XUTMUCI,",",2)
"RTN","XUTMRP",7,0)
 ;
"RTN","XUTMRP",8,0)
 N WAIT,FUT,MEFEND K ^TMP($J)
"RTN","XUTMRP",9,0)
 D WAIT ;Get what list to work on.
"RTN","XUTMRP",10,0)
 G:('FUT&'WAIT) EXIT G:($G(MEFEND)&'WAIT) EXIT
"RTN","XUTMRP",11,0)
OPT W ! S DIR(0)="Y",DIR("A")="Change the device field in the option file (Enter '?' for more info)",DIR("B")="NO",DIR("?")="^S XQH=""XUTM OPTION QUES"" D ^XQH" D ^DIR K DIR Q:$D(DIRUT)!($D(DUOUT))  S OPT=Y
"RTN","XUTMRP",12,0)
 W !
"RTN","XUTMRP",13,0)
 ;
"RTN","XUTMRP",14,0)
DEV S DIC("A")="Requeue tasks for device: " D ASKD K DIC G:Y'>0 EXIT S OLDLTA=LTA,CONFDEV=DEV D DVARRY("OLDDEV",OLDLTA)
"RTN","XUTMRP",15,0)
 S DIC("A")="Requeue to device: " D ASKD K DIC G:Y'>0 EXIT D
"RTN","XUTMRP",16,0)
 .S IOP=DEV D D0
"RTN","XUTMRP",17,0)
 .Q:$P(OLDDEV(CONFDEV),";",3,4)=$P(ZTIO,";",3,4)
"RTN","XUTMRP",18,0)
 .S SRCE=OLDDEV(CONFDEV) W !,$C(7),$P(SRCE,";")," margin ",$P(SRCE,";",3)," page length ",$P(SRCE,";",4),$C(7)
"RTN","XUTMRP",19,0)
 .W !,"doesn't match ",$P(ZTIO,";")," margin ",$P(ZTIO,";",3)," page length ",$P(ZTIO,";",4)
"RTN","XUTMRP",20,0)
 .W !,"Please confirm target device.",!,"If I can find a matching margin/page length",!,"I'll use it for the default.",!!,$C(7)
"RTN","XUTMRP",21,0)
 .D DVARRY("DEVNAM",LTA)
"RTN","XUTMRP",22,0)
 .S DEVNAM="" F  S DEVNAM=$O(DEVNAM(DEVNAM))  Q:DEVNAM=""  Q:$P(DEVNAM(DEVNAM),";",3,4)=$P(OLDDEV(CONFDEV),";",3,4)
"RTN","XUTMRP",23,0)
 .S DIC("A")="Requeue to device: " I DEVNAM]"" S DEFDEV=DEVNAM,DIC("B")=DEFDEV
"RTN","XUTMRP",24,0)
 .K DEVNAM D ASKD K DIC,DEFDEV Q:Y'>0
"RTN","XUTMRP",25,0)
 .S IOP=DEV D D0
"RTN","XUTMRP",26,0)
 I Y'>0 D EXIT Q  ;no target device
"RTN","XUTMRP",27,0)
 S CONFDEV(CONFDEV)=DEV D DVARRY("NEWDEV",LTA)
"RTN","XUTMRP",28,0)
CONF S DEVNAM="" F  S DEVNAM=$O(OLDDEV(DEVNAM)) Q:DEVNAM=""  I '$D(CONFDEV(DEVNAM)) S DEV="" F  S DEV=$O(CONFDEV(DEV)) Q:DEV=""  I $P(OLDDEV(DEVNAM),";",3,4)=$P(NEWDEV(CONFDEV(DEV)),";",3,4) S CONFDEV(DEVNAM)=CONFDEV(DEV) Q
"RTN","XUTMRP",29,0)
 D ^XUTMRP1
"RTN","XUTMRP",30,0)
 ;
"RTN","XUTMRP",31,0)
EXIT K CONFDEV,DEL,DEV,DEVNAM,DIC,DIRUT,DUOUT,EDATE,EDT,FUT,I,II,LTA,MEFEND
"RTN","XUTMRP",32,0)
 K NEWDEV,OLDDEV,OLDLTA,POP,SDATE,SDT,SN,SRCE,WAIT,XQH,Y,XUCPU,ZTDH,ZTIO
"RTN","XUTMRP",33,0)
 K OPT,ZTKEY,ZTMD,ZTNAME,ZTUCI,ZTSK,ZTC,ZTOPT,^TMP($J)
"RTN","XUTMRP",34,0)
 Q
"RTN","XUTMRP",35,0)
 ;
"RTN","XUTMRP",36,0)
DEVNAM(ARRAY) S DEVNAM="" F  S DEVNAM=$O(DEVNAM(DEVNAM)) Q:DEVNAM=""  S IOP=DEVNAM D D0 S NODE=ARRAY_"("""_DEVNAM_""")",@NODE=ZTIO K DEVNAM(DEVNAM)
"RTN","XUTMRP",37,0)
 Q
"RTN","XUTMRP",38,0)
 ;Slave printers and Spool Documents not allowed
"RTN","XUTMRP",39,0)
ASKD S DIC("S")="I $S($L($P(^(0),U,9)):($P(^(0),U,9)=XUCPU),$P(^(0),U,2)=0:0,""^SPL^VTRM^MT^OTH""[(U_$P(^(""TYPE""),U)):0,+$G(^(90)):$S(^(90)'>DT:0,1:1),1:1)",DIC="^%ZIS(1,",DIC(0)="AEMQZ"
"RTN","XUTMRP",40,0)
 D ^DIC Q:Y'>0
"RTN","XUTMRP",41,0)
 S DEV=Y(0,0),LTA=$P(Y(0),U,2)
"RTN","XUTMRP",42,0)
 Q
"RTN","XUTMRP",43,0)
 ;
"RTN","XUTMRP",44,0)
DVARRY(II,LTA) ;Build list of devices for a LTA.
"RTN","XUTMRP",45,0)
 F SN=0:0 S SN=$O(^%ZIS(1,"C",LTA,SN)) Q:SN'>0  S (ZTMD,IOP)=$P(^%ZIS(1,+SN,0),U) D
"RTN","XUTMRP",46,0)
 . I $S($L($P(^(0),U,9)):($P(^(0),U,9)=XUCPU),$P(^(0),U,2)=0:0,"^SPL^VTRM^MT^OTH"[(U_$P(^("TYPE"),U)):0,+$G(^(90)):$S(^(90)'>DT:0,1:1),1:1) D D0 S DEVNAM=II_"("""_ZTMD_""")",@DEVNAM=ZTIO
"RTN","XUTMRP",47,0)
 Q
"RTN","XUTMRP",48,0)
 ;
"RTN","XUTMRP",49,0)
WAIT S DIR(0)="Y",DIR("A")="Do you want to re-direct waiting tasks",DIR("B")="Yes" D ^DIR K DIR Q:$D(DIRUT)!($D(DUOUT))  S WAIT=Y
"RTN","XUTMRP",50,0)
 ;
"RTN","XUTMRP",51,0)
FUT W ! S DIR(0)="Y",DIR("A")="Do you want to re-direct future tasks",DIR("B")="NO" D ^DIR K DIR Q:$D(DIRUT)!($D(DUOUT))  S FUT=Y
"RTN","XUTMRP",52,0)
 I FUT D
"RTN","XUTMRP",53,0)
 .S SDT=$$DT("STARTING DATE/TIME","NOW") Q:SDT'>0
"RTN","XUTMRP",54,0)
 .S EDT=$$DT("ENDING DATE/TIME","T@24:00") Q:EDT'>0
"RTN","XUTMRP",55,0)
 .I SDT>EDT S ZDT=SDT,SDT=EDT,EDT=ZDT
"RTN","XUTMRP",56,0)
 .S SDATE=$$FMTE^XLFDT(SDT),EDATE=$$FMTE^XLFDT(EDT)
"RTN","XUTMRP",57,0)
 Q
"RTN","XUTMRP",58,0)
 ;
"RTN","XUTMRP",59,0)
REPNT ;Re-queues tasks to new lta# when dsv/ports are changed
"RTN","XUTMRP",60,0)
 Q:$D(DUZ)[0  Q:DUZ=""!(DUZ=0)  D ENV^XUTMUTL S XUCPU=$P(XUTMUCI,",",2)
"RTN","XUTMRP",61,0)
 K ^TMP($J),EXIT S REPNT=1
"RTN","XUTMRP",62,0)
 D REP2 
"RTN","XUTMRP",63,0)
 G:$G(EXIT) EXIT D ^XUTMRP1,EXIT
"RTN","XUTMRP",64,0)
 Q
"RTN","XUTMRP",65,0)
REP2 ;
"RTN","XUTMRP",66,0)
 D WAIT I $D(DIRUT)!($D(DUOUT)) S EXIT=1 Q
"RTN","XUTMRP",67,0)
 W ! S DIR("A")="Enter old $I (i.e. _LTA111: or 367) ",DIR(0)="F^1:9",DIR("?")="^D LISTIO^XUTMRP" D ^DIR
"RTN","XUTMRP",68,0)
 I $D(DIRUT)!($D(DUOUT)) S EXIT=1
"RTN","XUTMRP",69,0)
 I '$D(^%ZTSCH("IO",Y)) S EXIT=1 W !,"The 'IO' waiting list is empty.",!
"RTN","XUTMRP",70,0)
 S OLDLTA=Y Q:$G(EXIT)
"RTN","XUTMRP",71,0)
 W ! S DIC("A")="Requeue tasks to device: " D ASKD
"RTN","XUTMRP",72,0)
 K DIC I Y'>0 D  Q:$G(EXIT)
"RTN","XUTMRP",73,0)
 . K DIR S DIR(0)="Y",DIR("A")="Want to just move the Tasks back to the schedul list with a new run time:"
"RTN","XUTMRP",74,0)
 . D ^DIR I 'Y S EXIT=1 Q
"RTN","XUTMRP",75,0)
 . S LTA=OLDLTA
"RTN","XUTMRP",76,0)
 . Q
"RTN","XUTMRP",77,0)
 S NEWLTA=LTA
"RTN","XUTMRP",78,0)
 D DVARRY("NEWDEV",NEWLTA),DVARRY("OLDDEV",OLDLTA)
"RTN","XUTMRP",79,0)
 S II=""
"RTN","XUTMRP",80,0)
 F  S II=$O(NEWDEV(II)) Q:II=""  S CONFDEV(II)=II
"RTN","XUTMRP",81,0)
 S XUTMDTH=$$DT("When to have the tasks restart:","NOW")
"RTN","XUTMRP",82,0)
 Q
"RTN","XUTMRP",83,0)
 ;
"RTN","XUTMRP",84,0)
D0 ;
"RTN","XUTMRP",85,0)
 S %ZIS="NQZ" D ^%ZIS S ZTIO=$S($D(IOS)[0:"",POP:"",$D(ION)[0:"",ION]"":ION,IOS="":"",$D(^%ZIS(1,IOS,0))[0:"",1:$P(^(0),U))
"RTN","XUTMRP",86,0)
 S ZTIO=ZTIO_$S($D(IOST)[0:"",1:";"_IOST)_$S($D(IO("DOC"))[0:$S($D(IOM)[0:"",1:";"_IOM_$S($D(IOSL)[0:"",1:";"_IOSL)),1:";"_IO("DOC"))_$S($D(IO("P"))[0:"",IO("P")="":"",1:";/"_IO("P")) S:$D(IOCPU)#2 XUCPU=IOCPU
"RTN","XUTMRP",87,0)
 I $D(IO("HFSIO"))#2,$D(IOPAR)#2,IOT="HFS" S ZTIO("H")=IO("HFSIO"),ZTIO("P")=IOPAR
"RTN","XUTMRP",88,0)
 Q
"RTN","XUTMRP",89,0)
 ;
"RTN","XUTMRP",90,0)
DT(MES,DEF) S DIR("A")=MES,DIR("B")=DEF
"RTN","XUTMRP",91,0)
 S DIR(0)="D^DT::AEFT",DIR("?")="This response must be a date/time"
"RTN","XUTMRP",92,0)
 D ^DIR K DIR
"RTN","XUTMRP",93,0)
 Q Y
"RTN","XUTMRP",94,0)
LISTIO ;List the entries in the IO queue.
"RTN","XUTMRP",95,0)
 N DEV,I,Y
"RTN","XUTMRP",96,0)
 S DEV="" W @IOF
"RTN","XUTMRP",97,0)
 W !,"  $IO       Device names",!,"_______     ____________"
"RTN","XUTMRP",98,0)
 F  S DEV=$O(^%ZTSCH("IO",DEV)) Q:DEV=""  D
"RTN","XUTMRP",99,0)
 . W !,DEV,"=>",?12
"RTN","XUTMRP",100,0)
 . F I=0:0 S I=$O(^%ZIS(1,"C",DEV,I)) Q:I'>0  S Y=$P($G(^%ZIS(1,I,0)),U) W:$X+$L(Y)+2>79 !,?12 W Y,", "
"RTN","XUTMRP",101,0)
 . I $Y>17 N DIR S DIR(0)="E" D ^DIR
"RTN","XUTMRP",102,0)
 . Q
"RTN","XUTMRP1")
0^3^B12591026
"RTN","XUTMRP1",1,0)
XUTMRP1 ;SFISC/RWF,BOSTON/MEF - REQUEUE ALL TASKS FOR A DEVICE PART TWO ;9/8/95  11:09
"RTN","XUTMRP1",2,0)
 ;;8.0;KERNEL;**2**;Jul 10, 1995
"RTN","XUTMRP1",3,0)
 ;called by XUTMRP
"RTN","XUTMRP1",4,0)
 W !
"RTN","XUTMRP1",5,0)
WTSK I WAIT S ZTDH="" F  S ZTDH=$O(^%ZTSCH("IO",OLDLTA,ZTDH)) Q:ZTDH=""  S ZTSK="" F  S ZTSK=$O(^%ZTSCH("IO",OLDLTA,ZTDH,ZTSK)) Q:ZTSK=""  D
"RTN","XUTMRP1",6,0)
 . L +^%ZTSK(ZTSK) S DEVNAM=$P($P(^%ZTSK(ZTSK,.2),";"),U)
"RTN","XUTMRP1",7,0)
 . D CONF:'$D(CONFDEV(DEVNAM)),REQ S:$G(REPNT) ^TMP($J,ZTSK)=""
"RTN","XUTMRP1",8,0)
 . Q
"RTN","XUTMRP1",9,0)
 S WAIT=0
"RTN","XUTMRP1",10,0)
 ;
"RTN","XUTMRP1",11,0)
FTSK I FUT S TT="" F  S TT=$O(^%ZTSCH(TT)) Q:TT=""!($E(TT)'?1N)  F ZTSK=0:0 S ZTSK=$O(^%ZTSCH(TT,ZTSK)) Q:'ZTSK  L +^%ZTSK(ZTSK) D  L -^%ZTSK(ZTSK)
"RTN","XUTMRP1",12,0)
 . D WT
"RTN","XUTMRP1",13,0)
 . I $D(^%ZTSK(ZTSK,0))#2 S DEVNAM=$P($P($G(^(.2)),";"),U) I DEVNAM]"",$D(OLDDEV(DEVNAM)) I $$DATCK D
"RTN","XUTMRP1",14,0)
 .. S ZTDTH=$P(^(0),U,6)
"RTN","XUTMRP1",15,0)
 .. D CONF:'$D(CONFDEV(DEVNAM))
"RTN","XUTMRP1",16,0)
 .. I $G(REPNT) Q:$D(^TMP($J,ZTSK))  ;Already requeued
"RTN","XUTMRP1",17,0)
 .. D REQ
"RTN","XUTMRP1",18,0)
 .. Q
"RTN","XUTMRP1",19,0)
 . Q
"RTN","XUTMRP1",20,0)
 ;
"RTN","XUTMRP1",21,0)
OPT I $G(OPT) S TT="" F  S TT=$O(^DIC(19.2,TT)) Q:TT'>0  D
"RTN","XUTMRP1",22,0)
 . S T1=$G(^DIC(19.2,TT,0)),DEVNAM=$P($P(T1,U,3),";")
"RTN","XUTMRP1",23,0)
 . Q:DEVNAM=""  Q:'$D(OLDDEV(DEVNAM))  L +^DIC(19.2,TT,0)
"RTN","XUTMRP1",24,0)
 . S X=NEWDEV(DEVNAME)_";"_$P($P(T1,U,3),";",2,99)
"RTN","XUTMRP1",25,0)
 . S $P(^DIC(19.2,TT,0),U,3)=X
"RTN","XUTMRP1",26,0)
 . L -^DIC(19.2,TT,0)
"RTN","XUTMRP1",27,0)
 . Q
"RTN","XUTMRP1",28,0)
 ;
"RTN","XUTMRP1",29,0)
END Q  ;return to XUTMRP 
"RTN","XUTMRP1",30,0)
 ;
"RTN","XUTMRP1",31,0)
WT S FLAG=1+$G(FLAG)#10 W:'FLAG "."
"RTN","XUTMRP1",32,0)
 Q
"RTN","XUTMRP1",33,0)
 ;
"RTN","XUTMRP1",34,0)
REQ Q:'$D(CONFDEV(DEVNAM))
"RTN","XUTMRP1",35,0)
 I $G(XUTMDTH) S ZTDTH=XUTMDTH
"RTN","XUTMRP1",36,0)
 S ZTIO=NEWDEV(CONFDEV(DEVNAM)) D REQ^%ZTLOAD K ZTDTH
"RTN","XUTMRP1",37,0)
 Q:'ZTSK(0)
"RTN","XUTMRP1",38,0)
 W !!,"Requeued ",$S(WAIT:"waiting ",1:""),"task #",ZTSK," to device ",CONFDEV(DEVNAM),!
"RTN","XUTMRP1",39,0)
 Q
"RTN","XUTMRP1",40,0)
 ;
"RTN","XUTMRP1",41,0)
CONF S DEV="" F  S DEV=$O(NEWDEV(DEV)) Q:DEV=""  S:$P(OLDDEV(DEVNAM),";",3,4)=$P(NEWDEV(DEV),";",3,4) CONFDEV(DEVNAM)=DEV
"RTN","XUTMRP1",42,0)
 I '$D(CONFDEV(DEVNAM)) D ASKD Q:Y'>0  S CONFDEV(DEVNAM)=DEV,IOP=DEV D D0^XUTMRP S NEWDEV(DEV)=ZTIO,II="" F  D  Q:II=""
"RTN","XUTMRP1",43,0)
 . S II=$O(OLDDEV(II))
"RTN","XUTMRP1",44,0)
 . Q:II=""
"RTN","XUTMRP1",45,0)
 . I $P(OLDDEV(DEVNAM),";",3,4)=$P(OLDDEV(II),";",3,4),$D(CONFDEV(DEVNAM)) S CONFDEV(II)=CONFDEV(DEVNAM)
"RTN","XUTMRP1",46,0)
 ;
"RTN","XUTMRP1",47,0)
 Q
"RTN","XUTMRP1",48,0)
ASKD W !!,"I can't find a printer for task #",ZTSK," with the correct",!,"parameters (MARGIN= ",$P(OLDDEV(DEVNAM),";",3),"/ PAGE LENGTH= ",$P(OLDDEV(DEVNAM),";",4)," ). Where should I print it?",! D ASKD^XUTMRP,DTSK:Y'>0
"RTN","XUTMRP1",49,0)
 Q
"RTN","XUTMRP1",50,0)
DTSK D LIST Q:'$G(ZTC)
"RTN","XUTMRP1",51,0)
ASK W !!,"You didn't select a device. Do you want to delete the task"
"RTN","XUTMRP1",52,0)
 S %=2 D YN^DICN I %'>0 S XQH="XUTM DELETE TASK" D ^XQH G ASK
"RTN","XUTMRP1",53,0)
 S DEL=(%=1) I 'DEL D
"RTN","XUTMRP1",54,0)
 . S DIR(0)="Y",DIR("A")="Do you want another chance to select a device"
"RTN","XUTMRP1",55,0)
 . S DIR("B")="Yes" D ^DIR K DIR
"RTN","XUTMRP1",56,0)
 . Q:$D(DIRUT)  Q:'Y
"RTN","XUTMRP1",57,0)
 . D ASKD^XUTMRP
"RTN","XUTMRP1",58,0)
 Q:'DEL
"RTN","XUTMRP1",59,0)
 D DQ^%ZTLOAD
"RTN","XUTMRP1",60,0)
 I ZTSK(0) W !,"Task #",ZTSK," deleted."
"RTN","XUTMRP1",61,0)
 Q
"RTN","XUTMRP1",62,0)
DATCK() N X S X=$$HTFM^XLFDT($P(^%ZTSK(ZTSK,0),U,6))
"RTN","XUTMRP1",63,0)
 Q X'<SDT&(X'>EDT)
"RTN","XUTMRP1",64,0)
 ;
"RTN","XUTMRP1",65,0)
LIST ;List a task.
"RTN","XUTMRP1",66,0)
 N DIR,DIRUT,DTOUT,DUOUT
"RTN","XUTMRP1",67,0)
 S ZTC=0 I $D(^%ZTSK(ZTSK)) D EN^XUTMTP(ZTSK) S ZTC=1
"RTN","XUTMRP1",68,0)
 I 'ZTC W !!?5,"That task is not defined in this volume set's Task File."
"RTN","XUTMRP1",69,0)
 Q
"RTN","XUVERIFY")
0^4^B5113084
"RTN","XUVERIFY",1,0)
XUVERIFY ;SF/MUS - CHECKS YOUR ACCESS AND VERIFY CODES ;08/14/95  11:35
"RTN","XUVERIFY",2,0)
 ;;8.0;KERNEL;**2**;Jul 10, 1995
"RTN","XUVERIFY",3,0)
 ; The variables % and %DUZ must be set before running this
"RTN","XUVERIFY",4,0)
 ; program   % - may equal "A","V" OR both "AV"
"RTN","XUVERIFY",5,0)
 ;        %DUZ - must equal the users DUZ
"RTN","XUVERIFY",6,0)
 ;
"RTN","XUVERIFY",7,0)
 ; After the program is run % will return -1,0,1,2
"RTN","XUVERIFY",8,0)
 ; if %=-1 an "^" was entered  if %=0 an "?" was entered
"RTN","XUVERIFY",9,0)
 ; if %=1 the Code typed was correct
"RTN","XUVERIFY",10,0)
 ; if %=2 the Code was typed incorrectly
"RTN","XUVERIFY",11,0)
 ;
"RTN","XUVERIFY",12,0)
 I '$D(%)!'$D(%DUZ) S %=2 G KIL
"RTN","XUVERIFY",13,0)
 I '$D(^VA(200,%DUZ,0)) S %=2 G KIL
"RTN","XUVERIFY",14,0)
 G:%["A"!(%["V") CHECK S %=2 G KIL
"RTN","XUVERIFY",15,0)
CHECK S %R=$S(%="V":"VER",1:"ACC") D @%R
"RTN","XUVERIFY",16,0)
 I X["^" S %=-1
"RTN","XUVERIFY",17,0)
 I X?1.4"?" S %=0
"RTN","XUVERIFY",18,0)
KIL X ^%ZOSF("EON") K X,Y,Z,%AC,%VC,%R,I
"RTN","XUVERIFY",19,0)
 Q
"RTN","XUVERIFY",20,0)
ACC X ^%ZOSF("EOFF") R !,"ACCESS CODE: ",X:60 Q:X["^"!(X?1.4"?")  D LC^XUS:X?.E1L.E,^XUSHSH S %AC=X I %AC'=$P(^VA(200,%DUZ,0),"^",3) S %AC=2 D:%["V" VER S %=%AC Q
"RTN","XUVERIFY",21,0)
 S %AC=1 D:%["V" VER S:%'=2 %=%AC Q
"RTN","XUVERIFY",22,0)
VER X ^%ZOSF("EOFF") R !,"VERIFY CODE: ",X:60 Q:X["^"!(X?1.4"?")  D LC^XUS:X?.E1L.E,^XUSHSH S %VC=X I %VC'=$P(^VA(200,%DUZ,.1),"^",2) S %=2 Q
"RTN","XUVERIFY",23,0)
 S %=1
"RTN","XUVERIFY",24,0)
 Q
"RTN","XUVERIFY",25,0)
XUS2 ;MOVED FROM XUS2, TO CHECK OR RETURN USER ATTRIBUTES
"RTN","XUVERIFY",26,0)
 S:$D(XUS)[0 XUS="" D USER:XUS["A",USER:$D(DUZ)[0,EDIT:XUS["E"
"RTN","XUVERIFY",27,0)
 K XUS Q
"RTN","XUVERIFY",28,0)
USER ;ASK FOR USER ID
"RTN","XUVERIFY",29,0)
 S DUZ=0,DUZ(0)="",DUZ(1)="",XUC="",XUV="" X ^%ZOSF("EOFF") R !,"ACCESS CODE: ",X:60 I X?.ANP&(X<11) D LC^XUS S XUC=X
"RTN","XUVERIFY",30,0)
 R !,"VERIFY CODE: ",X:60 I X?.ANP D LC^XUS S XUV=X
"RTN","XUVERIFY",31,0)
 X ^%ZOSF("EON") G USX:XUC="" S U="^"
"RTN","XUVERIFY",32,0)
 S Z=$O(^VA(200,"A",XUC,0)) G USX:Z<1 S Z0=$G(^VA(200,Z,0))
"RTN","XUVERIFY",33,0)
 G USX:'$D(^(.1)) IF $D(XUV) G USX:XUV'=$P(^(.1),U,2) ;Naked set previous line
"RTN","XUVERIFY",34,0)
 S DUZ=Z,DUZ(0)=$P(Z0,U,4)
"RTN","XUVERIFY",35,0)
USX K Z,Z0,X,XUC,XUV
"RTN","XUVERIFY",36,0)
 D CHK^XM:DUZ
"RTN","XUVERIFY",37,0)
 Q
"RTN","XUVERIFY",38,0)
 ;
"RTN","XUVERIFY",39,0)
EDIT ;
"RTN","XUVERIFY",40,0)
 S XUC="",DIE="^VA(200,",DA=$S($D(DUZX):DUZX,1:DUZ) D AUTO^XUS2:XUS["G"
"RTN","XUVERIFY",41,0)
 S DR=".01;2"_$S(XUS["M"&$L(XUC):"///"_XUC,1:"")_";11"_$S(XUS["M":";1;3:9;12:20;200:201",1:";1;13")
"RTN","XUVERIFY",42,0)
 D ^DIE K DUZX,DR,DIE Q
"RTN","XUVERIFY",43,0)
 ;
"RTN","ZTMS")
0^5^B14347508
"RTN","ZTMS",1,0)
%ZTMS ;SEA/RDS-TaskMan: Submanager, (Entry & Trap) ;8/16/95  16:05
"RTN","ZTMS",2,0)
 ;;8.0;KERNEL;**2**;Jul 10, 1995
"RTN","ZTMS",3,0)
 ;
"RTN","ZTMS",4,0)
START ;Bottom level of submanager
"RTN","ZTMS",5,0)
 I $G(^%ZOSF("OS"))["VAX DSM" S $ETRAP="S %ZTER11S=$STACK D ERROR^%ZTMS HALT"
"RTN","ZTMS",6,0)
 E  S X="ERROR^%ZTMS",@^%ZOSF("TRAP")
"RTN","ZTMS",7,0)
 I $D(^%ZTSCH("STOP")) Q
"RTN","ZTMS",8,0)
 S ZTQUEUED=0,U="^",^%ZTSCH("SUB",0)=0
"RTN","ZTMS",9,0)
 I $D(^%ZTSCH("LOGRSRC")) D LOGRSRC^%ZOSV("ZTMS START")
"RTN","ZTMS",10,0)
 S X="Sub "_$J D SETENV^%ZOSV
"RTN","ZTMS",11,0)
 D PARAMS
"RTN","ZTMS",12,0)
 I '$D(ZTOUT) G SUBMGR^%ZTMS1
"RTN","ZTMS",13,0)
QUIT I $D(^%ZTSCH("LOGRSRC")) D LOGRSRC^%ZOSV("ZTMS STOP")
"RTN","ZTMS",14,0)
 Q
"RTN","ZTMS",15,0)
PARAMS ;
"RTN","ZTMS",16,0)
 ;START--lookup parameters
"RTN","ZTMS",17,0)
 X ^%ZOSF("PRIINQ") S %ZTMS("PRIO")=Y ;Get starting priority
"RTN","ZTMS",18,0)
 D GETENV^%ZOSV
"RTN","ZTMS",19,0)
 S ZTCPU=$P(Y,U,2),ZTNODE=$P(Y,U,3),ZTPAIR=$P(Y,U,4),ZTUCI=$P(Y,U)_$S(ZTCPU]"":","_ZTCPU,1:"")
"RTN","ZTMS",20,0)
 S X=$O(^%ZIS(14.7,"B",ZTPAIR,"")),ZTPRE=0,ZTYPE=""
"RTN","ZTMS",21,0)
 I X]"" S %=$G(^%ZIS(14.7,X,0)),ZTPRE=+$P(%,U,6),ZTYPE=$P(%,U,9)
"RTN","ZTMS",22,0)
 I 'X S ZTOUT=1 Q
"RTN","ZTMS",23,0)
 I "FO"[ZTYPE S ZTOUT=1 Q  ;SM only run on C,P,G types
"RTN","ZTMS",24,0)
 Q
"RTN","ZTMS",25,0)
ERROR ;START--trap
"RTN","ZTMS",26,0)
 ;
"RTN","ZTMS",27,0)
PREPARE ;prepare to handle error--save key data, set backup trap
"RTN","ZTMS",28,0)
 S %ZTERLGR=$$LGR^%ZOSV
"RTN","ZTMS",29,0)
 S ZTERROR=$$EC^%ZOSV
"RTN","ZTMS",30,0)
 S ZTERRO="" I $D(ZT)#2 S ZTERRO=ZT
"RTN","ZTMS",31,0)
 S ZTERRO2="" I $D(ZT2)#2 S ZTERRO2=ZT2
"RTN","ZTMS",32,0)
 S ZTERROXD=$D(X) I $D(X)#2 S ZTERROX=X
"RTN","ZTMS",33,0)
 S ZTERROYD=$D(Y) I $D(Y)#2 S ZTERROY=Y
"RTN","ZTMS",34,0)
 I $G(^%ZOSF("OS"))["VAX DSM" S $ETRAP="D ERROR2^%ZTMS0 HALT"
"RTN","ZTMS",35,0)
 E  S X="ERROR2^%ZTMS0",@^%ZOSF("TRAP")
"RTN","ZTMS",36,0)
 S ZTERROZT=$S($D(%ZTTV)#2:$P(%ZTTV,"^",4),$G(ZTSK)>0:ZTSK,1:0)
"RTN","ZTMS",37,0)
 I ZTERROZT L ^%ZTSK(ZTERROZT) ;Unlock all other locks
"RTN","ZTMS",38,0)
 I $D(ZTDEVOK) S $P(^%ZTSCH("IO"),U,2)=ZTDEVOK ;Have others skip dev.
"RTN","ZTMS",39,0)
 ;log error and context in TaskMan Error file
"RTN","ZTMS",40,0)
 L +^%ZTSCH("ER") H 1 S ZTERROH=$H
"RTN","ZTMS",41,0)
 S ^%ZTSCH("ER",+ZTERROH,$P(ZTERROH,",",2))=ZTERROR
"RTN","ZTMS",42,0)
 D XREF^%ZTMS0
"RTN","ZTMS",43,0)
 S ^%ZTSCH("ER",+ZTERROH,$P(ZTERROH,",",2),1)=ZTERROX1
"RTN","ZTMS",44,0)
 L -^%ZTSCH("ER")
"RTN","ZTMS",45,0)
 ;Update Task file entry
"RTN","ZTMS",46,0)
 I $G(ZTQUEUED),ZTERROZT,$D(^%ZTSK(ZTERROZT)) D STATUS^%ZTMS0
"RTN","ZTMS",47,0)
 ;
"RTN","ZTMS",48,0)
 I $D(^%ZTSCH("LOGRSRC")) D LOGRSRC^%ZOSV("ZTMS ERROR TRAP")
"RTN","ZTMS",49,0)
 I ZTQUEUED>.9,ZTERROZT>0,$G(DUZ)>.9,$D(^DD(8992,.01,0)) D
"RTN","ZTMS",50,0)
 . S XQA(DUZ)="",XQAMSG="Your task #"_ZTERROZT_" stopped because of an error",XQADATA=ZTERROZT,XQAROU="XQA^XUTMUTL"
"RTN","ZTMS",51,0)
 . D SETUP^XQALERT Q
"RTN","ZTMS",52,0)
 ;
"RTN","ZTMS",53,0)
CLEAN ;clean up global data related to this process
"RTN","ZTMS",54,0)
 I $G(ZTQUEUED)>.9 K ^%ZTSCH("TASK",ZTQUEUED)
"RTN","ZTMS",55,0)
 K ^TMP($J),^UTILITY($J),^XUTL("XQ",$J)
"RTN","ZTMS",56,0)
 I $D(ZTFREE)#2,$D(ZTUCI)#2,ZTUCI]"" D SUB^%ZTMS1(-1)
"RTN","ZTMS",57,0)
 I $D(ZTDEVN)#2,$D(%ZTIO)#2,%ZTIO]"" D DEVLK^%ZTMS1(-1,%ZTIO)
"RTN","ZTMS",58,0)
 I $D(ZTDEVOK)#2 D DEVBAD^%ZTMS0
"RTN","ZTMS",59,0)
 I $G(ZTSYNCFL)]"" S X=$$SYNCFLG^%ZTMS2("S",ZTSYNCFL,"","Stopped because of an error")
"RTN","ZTMS",60,0)
 ;
"RTN","ZTMS",61,0)
CHECK ;identify and screen out certain errors
"RTN","ZTMS",62,0)
 S ZT2="" F  S ZT2=$O(^%ZTSCH("ES",ZT2)) Q:ZT2=""  Q:ZTERROR[ZT2
"RTN","ZTMS",63,0)
 I ZT2]"" D  G CLOSE ;Skip the recording in Kernel
"RTN","ZTMS",64,0)
 . I $D(^%ZTSCH("ES",ZT2,1)) L +^%ZTSCH("ES") S ^(1)=$G(^%ZTSCH("ES",ZT2,1))+1 L -^%ZTSCH("ES")
"RTN","ZTMS",65,0)
 . K ^%ZTSCH("ER",+ZTERROH,$P(ZTERROH,",",2))
"RTN","ZTMS",66,0)
 . Q
"RTN","ZTMS",67,0)
 ;record error in Kernel error file
"RTN","ZTMS",68,0)
 S ZT=ZTERRO
"RTN","ZTMS",69,0)
 S ZT2=ZTERRO2
"RTN","ZTMS",70,0)
 S:ZTERROXD#2 X=ZTERROX S:ZTERROXD=10 X="X was undefined when the error occurred." I ZTERROXD=0 K X
"RTN","ZTMS",71,0)
 S:ZTERROYD#2 Y=ZTERROY S:ZTERROYD=10 Y="Y was undefined when the error occurred." I ZTERROYD=0 K Y
"RTN","ZTMS",72,0)
 D ^%ZTER
"RTN","ZTMS",73,0)
 ;
"RTN","ZTMS",74,0)
CLOSE ;close i/o device after error
"RTN","ZTMS",75,0)
 D ERCLOZ^%ZTMS0
"RTN","ZTMS",76,0)
 ;
"RTN","ZTMS",77,0)
 I $D(^%ZTSCH("LOGRSRC")) D LOGRSRC^%ZOSV("ZTMS ERROR STOP")
"RTN","ZTMS",78,0)
 I ZTQUEUED=.5,ZTERROZT>0,$P($G(^%ZTSK(ZTERROZT,.12)),"^")<5 D  ;Only try 5 times
"RTN","ZTMS",79,0)
 . S $P(^(.12),"^")=^%ZTSK(ZTERROZT,.12)+1
"RTN","ZTMS",80,0)
 . S ^%ZTSCH($$NEWH^%ZTMS2($H,600),ZTERROZT)=""
"RTN","ZTMS",81,0)
 HALT  ;Start a new process to continue
"RTN","ZTMS2")
0^6^B17988369
"RTN","ZTMS2",1,0)
%ZTMS2 ;SEA/RDS-TaskMan: Submanager, Part 4 (Unload, Get Device) ;8/16/95  14:33
"RTN","ZTMS2",2,0)
 ;;8.0;KERNEL;**2**;Jul 10, 1995
"RTN","ZTMS2",3,0)
 ;^%ZTSK(ZTSK) is locked on entry or return from GETNEXT
"RTN","ZTMS2",4,0)
PROCESS ;SUBMGR--process task and all others waiting for same device
"RTN","ZTMS2",5,0)
 D LOOKUP I $D(ZTREJECT) Q
"RTN","ZTMS2",6,0)
 D DEVICE
"RTN","ZTMS2",7,0)
 Q:POP
"RTN","ZTMS2",8,0)
 I ZTSYNCFL]"",'$$SYNCFLG("A",ZTSYNCFL,%ZTIO) D SYNCQ(ZTSYNCFL,%ZTIO,ZTDTH,ZTSK),^%ZISC Q
"RTN","ZTMS2",9,0)
 D TASK^%ZTMS3 I ZTYPE="C"!$D(ZTNONEXT) Q
"RTN","ZTMS2",10,0)
 D GETNEXT^%ZTMS7 I $D(ZTNONEXT)!$D(ZTQUIT) Q
"RTN","ZTMS2",11,0)
 G PROCESS
"RTN","ZTMS2",12,0)
 ;
"RTN","ZTMS2",13,0)
LOOKUP ;PROCESS--unload task, switch ucis, and test entry routine
"RTN","ZTMS2",14,0)
 K (%ZTIO,IO,U,ZTCPU,ZTDEVN,ZTDTH,ZTNODE,ZTPAIR,ZTPRE,ZTQUEUED,ZTSK,ZTUCI,ZTYPE)
"RTN","ZTMS2",15,0)
 S $P(^%ZTSK(ZTSK,.1),U,1,3)=4_U_$H_U
"RTN","ZTMS2",16,0)
 S ZTREC=^%ZTSK(ZTSK,0),ZTREC02=^(.02)
"RTN","ZTMS2",17,0)
 S ZTREC2=^%ZTSK(ZTSK,.2),ZTREC21=^(.21),ZTREC25=^(.25)
"RTN","ZTMS2",18,0)
 S ZTSYNCFL=$P(ZTREC2,"^",7),DUZ=+$P(ZTREC,U,3),DUZ(0)="@"
"RTN","ZTMS2",19,0)
 S X=$P(ZTREC02,U)_","_$P(ZTREC02,U,2)
"RTN","ZTMS2",20,0)
 I $P(ZTREC02,U,4) S $P(X,",",2)=ZTCPU
"RTN","ZTMS2",21,0)
 ;should do a check to see if X is OK, Should check UCI mapping.
"RTN","ZTMS2",22,0)
 I X'=ZTUCI S ZTUCI=X D SWAP^%XUCI
"RTN","ZTMS2",23,0)
 S X=$P($P(ZTREC,U,2),"("),ZTRTN=$P(ZTREC,U,1,2)
"RTN","ZTMS2",24,0)
 I $E(X)'="%" X ^%ZOSF("TEST"):X]"" I X=""!'$T D REJECT S ZTREJECT=""
"RTN","ZTMS2",25,0)
 Q
"RTN","ZTMS2",26,0)
 ;
"RTN","ZTMS2",27,0)
REJECT ;LOOKUP--entry routine isn't here; reject task
"RTN","ZTMS2",28,0)
 N Y X ^%ZOSF("UCI")
"RTN","ZTMS2",29,0)
 I $D(^%ZTSK(ZTSK)) S $P(^(ZTSK,.1),U,1,3)=$S($D(^(0))#2:"B^"_$H_"^No routine at destination "_Y_".",1:"I^"_$H_U_4)
"RTN","ZTMS2",30,0)
 I $D(ZTDEVN) D DEVLK^%ZTMS1(-1,%ZTIO) K ZTDEVN
"RTN","ZTMS2",31,0)
 L  Q  ;Clear all locks
"RTN","ZTMS2",32,0)
 ;
"RTN","ZTMS2",33,0)
DEVICE ;PROCESS--prepare requested device; if can't, make task wait
"RTN","ZTMS2",34,0)
 ;shortcut & screen
"RTN","ZTMS2",35,0)
 S ZTIO=$P(ZTREC2,U),ZTIOT=$P(ZTREC2,U,3)
"RTN","ZTMS2",36,0)
 I ZTIO="" S (IO,IO(0),IOF,ION,IOS,IOST,IOT)="",POP=0 Q
"RTN","ZTMS2",37,0)
 ;
"RTN","ZTMS2",38,0)
 ;setup call
"RTN","ZTMS2",39,0)
 S %ZIS="LRS0"_$S($P(ZTREC2,U,5)="DIRECT":"D",1:"")
"RTN","ZTMS2",40,0)
 S:ZTIOT="HFS" %ZIS("HFSIO")=$P(ZTREC2,U,6),%ZIS("IOPAR")=ZTREC25
"RTN","ZTMS2",41,0)
 S:ZTIOT="MT" %ZIS("IOPAR")=ZTREC25
"RTN","ZTMS2",42,0)
 S (IO,IO(0))=%ZTIO,IOP=ZTIO
"RTN","ZTMS2",43,0)
 K ^XUTL("XQ",$J)
"RTN","ZTMS2",44,0)
 ;
"RTN","ZTMS2",45,0)
 S:$P(ZTREC2,U,4)["MINIOUT" %ZISLOCK="^%ZTSCH(""NETMAIL"",IO)" ;The hang is on the close
"RTN","ZTMS2",46,0)
 ;call
"RTN","ZTMS2",47,0)
 S %ZISTO=3 D ^%ZIS K %ZISTO,%ZISLOCK ;See that we use a timeout.
"RTN","ZTMS2",48,0)
 I %ZTIO]"" D DEVLK^%ZTMS1(-1,%ZTIO) K ZTDEVN
"RTN","ZTMS2",49,0)
 I 'POP,%ZTIO]"",IO'=%ZTIO D IOMM
"RTN","ZTMS2",50,0)
 ;
"RTN","ZTMS2",51,0)
 ;results
"RTN","ZTMS2",52,0)
 I POP,(ZTYPE'="C"),(ZTIOT="TRM")!(ZTIOT="RES")!(ZTIOT="HG") D IONQ Q  ;only add to IO queue if not type C.
"RTN","ZTMS2",53,0)
 I POP D SCHNQ Q
"RTN","ZTMS2",54,0)
 I IOT'="RES",IOT'="HG" U IO
"RTN","ZTMS2",55,0)
 S IO(0)=IO
"RTN","ZTMS2",56,0)
 I $P(^%ZIS(1,+IOS,0),U,7)="y" D ^%ZTMSH
"RTN","ZTMS2",57,0)
 Q
"RTN","ZTMS2",58,0)
 ;
"RTN","ZTMS2",59,0)
IONQ ;DEVICE--put task on Device Waiting List
"RTN","ZTMS2",60,0)
 L +^%ZTSCH("IO")
"RTN","ZTMS2",61,0)
 I $D(^%ZTSK(ZTSK,0))[0 S:$D(^%ZTSK(ZTSK)) $P(^(ZTSK,.1),U,1,3)="I^"_$H_U_4 G IOQX
"RTN","ZTMS2",62,0)
 S $P(^%ZTSK(ZTSK,.1),U,1,3)="A^"_$H_U
"RTN","ZTMS2",63,0)
 S ZTIO(1)=$P(ZTREC2,U,5),ZTIOS=ZTREC21
"RTN","ZTMS2",64,0)
 D NQ^%ZTM4
"RTN","ZTMS2",65,0)
IOQX L  Q  ;Clear all Locks
"RTN","ZTMS2",66,0)
 ;
"RTN","ZTMS2",67,0)
SCHNQ ;DEVICE--if HFS or SPL or TYPE'=C, reschedule task 10 min in future (try later)
"RTN","ZTMS2",68,0)
 S ZTH=$$NEWH($H,300)
"RTN","ZTMS2",69,0)
 L +^%ZTSCH(ZTH,ZTSK)
"RTN","ZTMS2",70,0)
 S $P(^%ZTSK(ZTSK,.1),U,1,3)="1^"_$H_"^rescheduled for busy device"
"RTN","ZTMS2",71,0)
 S ^%ZTSCH(ZTH,ZTSK)=""
"RTN","ZTMS2",72,0)
 L  Q  ;Clear all locks
"RTN","ZTMS2",73,0)
 ;
"RTN","ZTMS2",74,0)
NEWH(%H,%Y) ;Build a new schedule time
"RTN","ZTMS2",75,0)
 N % S %=$P(%H,",",2)+%Y Q (%H+(%>86400))_","_(%#86400)
"RTN","ZTMS2",76,0)
 ;
"RTN","ZTMS2",77,0)
IOMM ;IO Miss Match with %ZTIO
"RTN","ZTMS2",78,0)
 N ERT L +^%ZTSCH("ER") H 1 S ERT=$H
"RTN","ZTMS2",79,0)
 S ^%ZTSCH("ER",+ERT,$P(ERT,",",2))="IO/%ZTIO MM^"_IO_"^"_%ZTIO_"^"_ZTIO
"RTN","ZTMS2",80,0)
 L -^%ZTSCH("ER")
"RTN","ZTMS2",81,0)
 C %ZTIO K IO(1,%ZTIO) S %ZTIO=IO
"RTN","ZTMS2",82,0)
 Q
"RTN","ZTMS2",83,0)
SYNCFLG(ACT,FLAG,ZIO,STAT) ;Allocate/deallocate sync flag
"RTN","ZTMS2",84,0)
 N X,DA,SYNC
"RTN","ZTMS2",85,0)
 L +^%ZISL(14.8):30 E  Q 0
"RTN","ZTMS2",86,0)
 S X=0,SYNC=ZIO_"~"_FLAG,DA=$O(^%ZISL(14.8,"B",SYNC,0))
"RTN","ZTMS2",87,0)
 I ACT["A" D
"RTN","ZTMS2",88,0)
 . I DA S X=0 Q
"RTN","ZTMS2",89,0)
 . ;I $D(^%ZTSCH("SYNC",ZIO,FLAG)) S X=0 Q
"RTN","ZTMS2",90,0)
 . S X=$P(^%ZISL(14.8,0),"^",3)+1 F  Q:'$D(^%ZISL(14.8,X))  S X=X+1
"RTN","ZTMS2",91,0)
 . S $P(^(0),"^",3,4)=X_"^"_($P(^%ZISL(14.8,0),"^",4)+1),^%ZISL(14.8,X,0)=SYNC,^%ZISL(14.8,"B",SYNC,X)=""
"RTN","ZTMS2",92,0)
 . S X=1 Q
"RTN","ZTMS2",93,0)
 I ACT["D" D  S X=1
"RTN","ZTMS2",94,0)
 . Q:DA'>0
"RTN","ZTMS2",95,0)
 . K ^%ZISL(14.8,DA),^%ZISL(14.8,"B",SYNC,DA)
"RTN","ZTMS2",96,0)
 . S $P(^(0),"^",3,4)=(DA-1)_"^"_($P(^%ZISL(14.8,0),"^",4)-1)
"RTN","ZTMS2",97,0)
 . Q
"RTN","ZTMS2",98,0)
 I ACT["S" D  S X=1
"RTN","ZTMS2",99,0)
 . Q:DA'>0
"RTN","ZTMS2",100,0)
 . S ^%ZISL(14.8,DA,1)=$G(STAT)
"RTN","ZTMS2",101,0)
 . Q
"RTN","ZTMS2",102,0)
 I ACT["?" S X=(DA)!($D(^%ZTSCH("SYNC",ZIO,FLAG)))
"RTN","ZTMS2",103,0)
 L -^%ZISL(14.8)
"RTN","ZTMS2",104,0)
 Q X
"RTN","ZTMS2",105,0)
 ;
"RTN","ZTMS2",106,0)
SYNCQ(FLAG,ZIO,ZTH,ZTSK) ;Put task on sync flag waiting list
"RTN","ZTMS2",107,0)
 L +^%ZTSCH("SYNC")
"RTN","ZTMS2",108,0)
 S ^%ZTSCH("SYNC",ZIO,FLAG,ZTSK)=ZTH
"RTN","ZTMS2",109,0)
 L -^%ZTSCH("SYNC")
"RTN","ZTMS2",110,0)
 Q
"RTN","ZTMS2",111,0)
SCHSYNC(FLAG,ZIO) ;put a waiting task in IO queue
"RTN","ZTMS2",112,0)
 L +^%ZTSCH("SYNC") I $D(^%ZTSCH("SYNC",ZIO,FLAG)) N ZTH,ZTSK D
"RTN","ZTMS2",113,0)
 . S ZTSK=$O(^(FLAG,0)),ZTH=$G(^(+ZTSK)) Q:ZTSK=""  S:$D(^%ZTSCH("IO",ZIO))[0 ^(ZIO)=IOT
"RTN","ZTMS2",114,0)
 . S ^%ZTSCH("IO",ZIO,ZTH,ZTSK)=""
"RTN","ZTMS2",115,0)
 . K ^%ZTSCH("SYNC",ZIO,FLAG,ZTSK)
"RTN","ZTMS2",116,0)
 . Q
"RTN","ZTMS2",117,0)
 L -^%ZTSCH("SYNC")
"RTN","ZTMS2",118,0)
 Q
"VER")
8.0^21.0
"^DD",200,200,.137,0)
VOICE PAGER^F^^.13;7^K:$L(X)>20!($L(X)<3)!'(X?3.20NP) X
"^DD",200,200,.137,3)
Answer must be 3-20 characters in length.
"^DD",200,200,.137,21,0)
^^4^4^2941024^
"^DD",200,200,.137,21,1,0)
This field holds a phone number for an ANALOG PAGER that this person
"^DD",200,200,.137,21,2,0)
carries with them.
"^DD",200,200,.137,21,3,0)
It needs to be a format that can be understood by a sending 
"^DD",200,200,.137,21,4,0)
MODEM.
"^DD",200,200,.137,"DT")
2950801
"^DD",200,200,.138,0)
DIGITAL PAGER^F^^.13;8^K:$L(X)>20!($L(X)<3)!'(X?3.20NP) X
"^DD",200,200,.138,3)
Answer must be 3-20 characters in length.
"^DD",200,200,.138,21,0)
^^4^4^2941024^
"^DD",200,200,.138,21,1,0)
This field holds a phone number for a DIGITAL PAGER that this person
"^DD",200,200,.138,21,2,0)
carries with them.
"^DD",200,200,.138,21,3,0)
It needs to be a format that can be understood by a sending 
"^DD",200,200,.138,21,4,0)
MODEM.
"^DD",200,200,.138,"DT")
2950801
**END**
**END**
