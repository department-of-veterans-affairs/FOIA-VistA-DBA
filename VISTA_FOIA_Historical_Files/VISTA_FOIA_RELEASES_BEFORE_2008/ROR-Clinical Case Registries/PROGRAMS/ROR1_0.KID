KIDS Distribution saved on May 15, 2002@08:28:22
Clinical Case Registries v1.0
**KIDS**:ROR 1.0^

**INSTALL NAME**
ROR 1.0
"BLD",3818,0)
ROR 1.0^CLINICAL CASE REGISTRIES^0^3020515^y
"BLD",3818,1,0)
^^12^12^3020508^^^
"BLD",3818,1,1,0)
The Clinical Case Registry package automatically collects and creates
"BLD",3818,1,2,0)
local registries of patients using the predefined search criteria.
"BLD",3818,1,3,0)
 
"BLD",3818,1,4,0)
This release contains the infrastructure and definitions of the Hepatitis
"BLD",3818,1,5,0)
C registry. The software will search for patients that pass the
"BLD",3818,1,6,0)
pre-defined selection rules that identify a patient with Hepatitis C
"BLD",3818,1,7,0)
(e.g., ICD-9 code relating to Hepatitis C, positive laboratory serology
"BLD",3818,1,8,0)
test results for Hepatitis C testing).
"BLD",3818,1,9,0)
 
"BLD",3818,1,10,0)
Local sites have the ability to review the local registry list before
"BLD",3818,1,11,0)
automated data extraction and transmission. Data extraction and
"BLD",3818,1,12,0)
transmission will be timed daily and will not require manual intervention.
"BLD",3818,4,0)
^9.64PA^799.2^11
"BLD",3818,4,798,0)
798
"BLD",3818,4,798,222)
y^y^f^^^^n
"BLD",3818,4,798.1,0)
798.1
"BLD",3818,4,798.1,222)
y^y^f^^n^^y^m^n
"BLD",3818,4,798.1,224)
I $E($P($G(^ROR(798.1,Y,0)),U),1,7)="VA HEPC"
"BLD",3818,4,798.2,0)
798.2
"BLD",3818,4,798.2,222)
y^y^f^^y^^y^o^n
"BLD",3818,4,798.2,224)
I $E($P($G(^ROR(798.2,Y,0)),U),1,7)="VA HEPC"
"BLD",3818,4,798.3,0)
798.3
"BLD",3818,4,798.3,222)
y^y^f^^y^^n^o^n
"BLD",3818,4,798.4,0)
798.4
"BLD",3818,4,798.4,222)
y^y^f^^^^n
"BLD",3818,4,798.5,0)
798.5
"BLD",3818,4,798.5,222)
y^y^f^^^^n
"BLD",3818,4,798.6,0)
798.6
"BLD",3818,4,798.6,222)
y^y^f^^^^n
"BLD",3818,4,798.7,0)
798.7
"BLD",3818,4,798.7,222)
y^y^f^^^^n
"BLD",3818,4,798.9,0)
798.9
"BLD",3818,4,798.9,222)
y^y^f^^n^^y^m^n
"BLD",3818,4,798.9,224)
I $E($P($G(^ROR(798.9,Y,0)),U),1,7)="VA HEPC"
"BLD",3818,4,799.1,0)
799.1
"BLD",3818,4,799.1,222)
y^y^f^^y^^y^o^n
"BLD",3818,4,799.2,0)
799.2
"BLD",3818,4,799.2,222)
y^y^f^^n^^y^o^n
"BLD",3818,4,"B",798,798)

"BLD",3818,4,"B",798.1,798.1)

"BLD",3818,4,"B",798.2,798.2)

"BLD",3818,4,"B",798.3,798.3)

"BLD",3818,4,"B",798.4,798.4)

"BLD",3818,4,"B",798.5,798.5)

"BLD",3818,4,"B",798.6,798.6)

"BLD",3818,4,"B",798.7,798.7)

"BLD",3818,4,"B",798.9,798.9)

"BLD",3818,4,"B",799.1,799.1)

"BLD",3818,4,"B",799.2,799.2)

"BLD",3818,"ABPKG")
n
"BLD",3818,"INI")
START^RORPRE01
"BLD",3818,"INID")
^
"BLD",3818,"INIT")
START^RORPOS01
"BLD",3818,"KRN",0)
^9.67PA^8989.52^19
"BLD",3818,"KRN",.4,0)
.4
"BLD",3818,"KRN",.4,"NM",0)
^9.68A^2^2
"BLD",3818,"KRN",.4,"NM",1,0)
ROR DATA ELEMENTS    FILE #799.2^799.2^0
"BLD",3818,"KRN",.4,"NM",2,0)
ROR LOG    FILE #798.7^798.7^0
"BLD",3818,"KRN",.4,"NM","B","ROR DATA ELEMENTS    FILE #799.2",1)

"BLD",3818,"KRN",.4,"NM","B","ROR LOG    FILE #798.7",2)

"BLD",3818,"KRN",.401,0)
.401
"BLD",3818,"KRN",.401,"NM",0)
^9.68A^2^2
"BLD",3818,"KRN",.401,"NM",1,0)
ROR DATA ELEMENTS    FILE #799.2^799.2^0
"BLD",3818,"KRN",.401,"NM",2,0)
ROR LOG    FILE #798.7^798.7^0
"BLD",3818,"KRN",.401,"NM","B","ROR DATA ELEMENTS    FILE #799.2",1)

"BLD",3818,"KRN",.401,"NM","B","ROR LOG    FILE #798.7",2)

"BLD",3818,"KRN",.402,0)
.402
"BLD",3818,"KRN",.402,"NM",0)
^9.68A^5^5
"BLD",3818,"KRN",.402,"NM",1,0)
RORHDT EDIT PARAMS    FILE #798.1^798.1^0
"BLD",3818,"KRN",.402,"NM",2,0)
RORHDT EDIT TASK    FILE #798.5^798.5^0
"BLD",3818,"KRN",.402,"NM",3,0)
RORMNT AWAITING ACK    FILE #798.1^798.1^0
"BLD",3818,"KRN",.402,"NM",4,0)
RORMNT EDIT LAB SEARCH    FILE #798.9^798.9^0
"BLD",3818,"KRN",.402,"NM",5,0)
RORMNT EDIT REG PARAMS    FILE #798.1^798.1^0
"BLD",3818,"KRN",.402,"NM","B","RORHDT EDIT PARAMS    FILE #798.1",1)

"BLD",3818,"KRN",.402,"NM","B","RORHDT EDIT TASK    FILE #798.5",2)

"BLD",3818,"KRN",.402,"NM","B","RORMNT AWAITING ACK    FILE #798.1",3)

"BLD",3818,"KRN",.402,"NM","B","RORMNT EDIT LAB SEARCH    FILE #798.9",4)

"BLD",3818,"KRN",.402,"NM","B","RORMNT EDIT REG PARAMS    FILE #798.1",5)

"BLD",3818,"KRN",.403,0)
.403
"BLD",3818,"KRN",.5,0)
.5
"BLD",3818,"KRN",.84,0)
.84
"BLD",3818,"KRN",3.6,0)
3.6
"BLD",3818,"KRN",3.8,0)
3.8
"BLD",3818,"KRN",9.2,0)
9.2
"BLD",3818,"KRN",9.8,0)
9.8
"BLD",3818,"KRN",9.8,"NM",0)
^9.68A^82^82
"BLD",3818,"KRN",9.8,"NM",1,0)
ROR^^0^B20578803
"BLD",3818,"KRN",9.8,"NM",2,0)
ROR01^^0^B15130
"BLD",3818,"KRN",9.8,"NM",3,0)
RORACK^^0^B12656056
"BLD",3818,"KRN",9.8,"NM",4,0)
RORACK01^^0^B35934745
"BLD",3818,"KRN",9.8,"NM",5,0)
RORAPI01^^0^B10528729
"BLD",3818,"KRN",9.8,"NM",6,0)
RORDD^^0^B15127310
"BLD",3818,"KRN",9.8,"NM",7,0)
RORENV01^^0^B3204733
"BLD",3818,"KRN",9.8,"NM",8,0)
RORERR^^0^B12068753
"BLD",3818,"KRN",9.8,"NM",9,0)
RORERR10^^0^B63310887
"BLD",3818,"KRN",9.8,"NM",10,0)
RORERR20^^0^B35894669
"BLD",3818,"KRN",9.8,"NM",11,0)
ROREXPR^^0^B8210396
"BLD",3818,"KRN",9.8,"NM",12,0)
ROREXT^^0^B17997555
"BLD",3818,"KRN",9.8,"NM",13,0)
ROREXT01^^0^B9006451
"BLD",3818,"KRN",9.8,"NM",14,0)
ROREXT02^^0^B21368107
"BLD",3818,"KRN",9.8,"NM",15,0)
ROREXTUT^^0^B16857910
"BLD",3818,"KRN",9.8,"NM",16,0)
RORHDT^^0^B14169030
"BLD",3818,"KRN",9.8,"NM",17,0)
RORHDT01^^0^B8808254
"BLD",3818,"KRN",9.8,"NM",18,0)
RORHDT02^^0^B3532335
"BLD",3818,"KRN",9.8,"NM",19,0)
RORHDT03^^0^B23638721
"BLD",3818,"KRN",9.8,"NM",20,0)
RORHDT04^^0^B30783840
"BLD",3818,"KRN",9.8,"NM",21,0)
RORHDT05^^0^B16124761
"BLD",3818,"KRN",9.8,"NM",22,0)
RORHDTAC^^0^B12776687
"BLD",3818,"KRN",9.8,"NM",23,0)
RORHDTUT^^0^B28999251
"BLD",3818,"KRN",9.8,"NM",24,0)
RORHL01^^0^B11470148
"BLD",3818,"KRN",9.8,"NM",25,0)
RORHL02^^0^B44292323
"BLD",3818,"KRN",9.8,"NM",26,0)
RORHL03^^0^B64738074
"BLD",3818,"KRN",9.8,"NM",27,0)
RORHL04^^0^B14087804
"BLD",3818,"KRN",9.8,"NM",28,0)
RORHL05^^0^B9259613
"BLD",3818,"KRN",9.8,"NM",29,0)
RORHL06^^0^B27080892
"BLD",3818,"KRN",9.8,"NM",30,0)
RORHL07^^0^B16116026
"BLD",3818,"KRN",9.8,"NM",31,0)
RORHL7^^0^B17035317
"BLD",3818,"KRN",9.8,"NM",32,0)
RORKIDS^^0^B14852443
"BLD",3818,"KRN",9.8,"NM",33,0)
RORLOG^^0^B38793443
"BLD",3818,"KRN",9.8,"NM",34,0)
RORLOG01^^0^B3453989
"BLD",3818,"KRN",9.8,"NM",35,0)
RORPOS01^^0^B20385618
"BLD",3818,"KRN",9.8,"NM",36,0)
RORPOSU1^^0^B1428774
"BLD",3818,"KRN",9.8,"NM",37,0)
RORPRE01^^0^B4743801
"BLD",3818,"KRN",9.8,"NM",38,0)
RORRP1^^0^B9768883
"BLD",3818,"KRN",9.8,"NM",39,0)
RORRP10^^0^B743662
"BLD",3818,"KRN",9.8,"NM",40,0)
RORRP2^^0^B21485444
"BLD",3818,"KRN",9.8,"NM",41,0)
RORRP3^^0^B9592243
"BLD",3818,"KRN",9.8,"NM",42,0)
RORRP4^^0^B20577791
"BLD",3818,"KRN",9.8,"NM",43,0)
RORRP5^^0^B3269199
"BLD",3818,"KRN",9.8,"NM",44,0)
RORRP6^^0^B16009386
"BLD",3818,"KRN",9.8,"NM",45,0)
RORRP7^^0^B17450253
"BLD",3818,"KRN",9.8,"NM",46,0)
RORRP8^^0^B14331338
"BLD",3818,"KRN",9.8,"NM",47,0)
RORRP9^^0^B45009195
"BLD",3818,"KRN",9.8,"NM",48,0)
RORSET01^^0^B13765779
"BLD",3818,"KRN",9.8,"NM",49,0)
RORSETU1^^0^B18226974
"BLD",3818,"KRN",9.8,"NM",50,0)
RORSETU2^^0^B12631212
"BLD",3818,"KRN",9.8,"NM",51,0)
RORUPD^^0^B29619781
"BLD",3818,"KRN",9.8,"NM",52,0)
RORUPD01^^0^B59537811
"BLD",3818,"KRN",9.8,"NM",53,0)
RORUPD04^^0^B30947880
"BLD",3818,"KRN",9.8,"NM",54,0)
RORUPD05^^0^B43865246
"BLD",3818,"KRN",9.8,"NM",55,0)
RORUPD06^^0^B10084571
"BLD",3818,"KRN",9.8,"NM",56,0)
RORUPD07^^0^B6845655
"BLD",3818,"KRN",9.8,"NM",57,0)
RORUPD08^^0^B18764845
"BLD",3818,"KRN",9.8,"NM",58,0)
RORUPD09^^0^B8526659
"BLD",3818,"KRN",9.8,"NM",59,0)
RORUPD50^^0^B13391732
"BLD",3818,"KRN",9.8,"NM",60,0)
RORUPD51^^0^B53647533
"BLD",3818,"KRN",9.8,"NM",61,0)
RORUPD52^^0^B8252177
"BLD",3818,"KRN",9.8,"NM",62,0)
RORUPDPP^^1^
"BLD",3818,"KRN",9.8,"NM",63,0)
RORUPDUT^^0^B47472833
"BLD",3818,"KRN",9.8,"NM",64,0)
RORUPEX^^0^B14495956
"BLD",3818,"KRN",9.8,"NM",65,0)
RORUPR^^0^B28519730
"BLD",3818,"KRN",9.8,"NM",66,0)
RORUPR1^^0^B72168761
"BLD",3818,"KRN",9.8,"NM",67,0)
RORUTL01^^0^B34602700
"BLD",3818,"KRN",9.8,"NM",68,0)
RORUTL02^^0^B33272685
"BLD",3818,"KRN",9.8,"NM",69,0)
RORUTL03^^0^B16590829
"BLD",3818,"KRN",9.8,"NM",70,0)
RORUTL04^^0^B5896522
"BLD",3818,"KRN",9.8,"NM",71,0)
RORUTL05^^0^B32076010
"BLD",3818,"KRN",9.8,"NM",72,0)
RORUTL06^^0^B45063527
"BLD",3818,"KRN",9.8,"NM",73,0)
RORUTL07^^0^B9724841
"BLD",3818,"KRN",9.8,"NM",74,0)
RORUPP02^^0^B8476762
"BLD",3818,"KRN",9.8,"NM",75,0)
RORUPP01^^0^B15079582
"BLD",3818,"KRN",9.8,"NM",76,0)
RORPOSUT^^1^
"BLD",3818,"KRN",9.8,"NM",77,0)
RORUPD02^^1^
"BLD",3818,"KRN",9.8,"NM",78,0)
RORUPD03^^1^
"BLD",3818,"KRN",9.8,"NM",79,0)
RORFIX^^1^
"BLD",3818,"KRN",9.8,"NM",80,0)
ROREVT01^^0^B4150665
"BLD",3818,"KRN",9.8,"NM",81,0)
RORTSITE^^0^B13329926
"BLD",3818,"KRN",9.8,"NM",82,0)
RORNTEG^^0^B7742531
"BLD",3818,"KRN",9.8,"NM","B","ROR",1)

"BLD",3818,"KRN",9.8,"NM","B","ROR01",2)

"BLD",3818,"KRN",9.8,"NM","B","RORACK",3)

"BLD",3818,"KRN",9.8,"NM","B","RORACK01",4)

"BLD",3818,"KRN",9.8,"NM","B","RORAPI01",5)

"BLD",3818,"KRN",9.8,"NM","B","RORDD",6)

"BLD",3818,"KRN",9.8,"NM","B","RORENV01",7)

"BLD",3818,"KRN",9.8,"NM","B","RORERR",8)

"BLD",3818,"KRN",9.8,"NM","B","RORERR10",9)

"BLD",3818,"KRN",9.8,"NM","B","RORERR20",10)

"BLD",3818,"KRN",9.8,"NM","B","ROREVT01",80)

"BLD",3818,"KRN",9.8,"NM","B","ROREXPR",11)

"BLD",3818,"KRN",9.8,"NM","B","ROREXT",12)

"BLD",3818,"KRN",9.8,"NM","B","ROREXT01",13)

"BLD",3818,"KRN",9.8,"NM","B","ROREXT02",14)

"BLD",3818,"KRN",9.8,"NM","B","ROREXTUT",15)

"BLD",3818,"KRN",9.8,"NM","B","RORFIX",79)

"BLD",3818,"KRN",9.8,"NM","B","RORHDT",16)

"BLD",3818,"KRN",9.8,"NM","B","RORHDT01",17)

"BLD",3818,"KRN",9.8,"NM","B","RORHDT02",18)

"BLD",3818,"KRN",9.8,"NM","B","RORHDT03",19)

"BLD",3818,"KRN",9.8,"NM","B","RORHDT04",20)

"BLD",3818,"KRN",9.8,"NM","B","RORHDT05",21)

"BLD",3818,"KRN",9.8,"NM","B","RORHDTAC",22)

"BLD",3818,"KRN",9.8,"NM","B","RORHDTUT",23)

"BLD",3818,"KRN",9.8,"NM","B","RORHL01",24)

"BLD",3818,"KRN",9.8,"NM","B","RORHL02",25)

"BLD",3818,"KRN",9.8,"NM","B","RORHL03",26)

"BLD",3818,"KRN",9.8,"NM","B","RORHL04",27)

"BLD",3818,"KRN",9.8,"NM","B","RORHL05",28)

"BLD",3818,"KRN",9.8,"NM","B","RORHL06",29)

"BLD",3818,"KRN",9.8,"NM","B","RORHL07",30)

"BLD",3818,"KRN",9.8,"NM","B","RORHL7",31)

"BLD",3818,"KRN",9.8,"NM","B","RORKIDS",32)

"BLD",3818,"KRN",9.8,"NM","B","RORLOG",33)

"BLD",3818,"KRN",9.8,"NM","B","RORLOG01",34)

"BLD",3818,"KRN",9.8,"NM","B","RORNTEG",82)

"BLD",3818,"KRN",9.8,"NM","B","RORPOS01",35)

"BLD",3818,"KRN",9.8,"NM","B","RORPOSU1",36)

"BLD",3818,"KRN",9.8,"NM","B","RORPOSUT",76)

"BLD",3818,"KRN",9.8,"NM","B","RORPRE01",37)

"BLD",3818,"KRN",9.8,"NM","B","RORRP1",38)

"BLD",3818,"KRN",9.8,"NM","B","RORRP10",39)

"BLD",3818,"KRN",9.8,"NM","B","RORRP2",40)

"BLD",3818,"KRN",9.8,"NM","B","RORRP3",41)

"BLD",3818,"KRN",9.8,"NM","B","RORRP4",42)

"BLD",3818,"KRN",9.8,"NM","B","RORRP5",43)

"BLD",3818,"KRN",9.8,"NM","B","RORRP6",44)

"BLD",3818,"KRN",9.8,"NM","B","RORRP7",45)

"BLD",3818,"KRN",9.8,"NM","B","RORRP8",46)

"BLD",3818,"KRN",9.8,"NM","B","RORRP9",47)

"BLD",3818,"KRN",9.8,"NM","B","RORSET01",48)

"BLD",3818,"KRN",9.8,"NM","B","RORSETU1",49)

"BLD",3818,"KRN",9.8,"NM","B","RORSETU2",50)

"BLD",3818,"KRN",9.8,"NM","B","RORTSITE",81)

"BLD",3818,"KRN",9.8,"NM","B","RORUPD",51)

"BLD",3818,"KRN",9.8,"NM","B","RORUPD01",52)

"BLD",3818,"KRN",9.8,"NM","B","RORUPD02",77)

"BLD",3818,"KRN",9.8,"NM","B","RORUPD03",78)

"BLD",3818,"KRN",9.8,"NM","B","RORUPD04",53)

"BLD",3818,"KRN",9.8,"NM","B","RORUPD05",54)

"BLD",3818,"KRN",9.8,"NM","B","RORUPD06",55)

"BLD",3818,"KRN",9.8,"NM","B","RORUPD07",56)

"BLD",3818,"KRN",9.8,"NM","B","RORUPD08",57)

"BLD",3818,"KRN",9.8,"NM","B","RORUPD09",58)

"BLD",3818,"KRN",9.8,"NM","B","RORUPD50",59)

"BLD",3818,"KRN",9.8,"NM","B","RORUPD51",60)

"BLD",3818,"KRN",9.8,"NM","B","RORUPD52",61)

"BLD",3818,"KRN",9.8,"NM","B","RORUPDPP",62)

"BLD",3818,"KRN",9.8,"NM","B","RORUPDUT",63)

"BLD",3818,"KRN",9.8,"NM","B","RORUPEX",64)

"BLD",3818,"KRN",9.8,"NM","B","RORUPP01",75)

"BLD",3818,"KRN",9.8,"NM","B","RORUPP02",74)

"BLD",3818,"KRN",9.8,"NM","B","RORUPR",65)

"BLD",3818,"KRN",9.8,"NM","B","RORUPR1",66)

"BLD",3818,"KRN",9.8,"NM","B","RORUTL01",67)

"BLD",3818,"KRN",9.8,"NM","B","RORUTL02",68)

"BLD",3818,"KRN",9.8,"NM","B","RORUTL03",69)

"BLD",3818,"KRN",9.8,"NM","B","RORUTL04",70)

"BLD",3818,"KRN",9.8,"NM","B","RORUTL05",71)

"BLD",3818,"KRN",9.8,"NM","B","RORUTL06",72)

"BLD",3818,"KRN",9.8,"NM","B","RORUTL07",73)

"BLD",3818,"KRN",19,0)
19
"BLD",3818,"KRN",19,"NM",0)
^9.68A^17^17
"BLD",3818,"KRN",19,"NM",1,0)
ROR GUI MENU^^0
"BLD",3818,"KRN",19,"NM",2,0)
ROR SETUP HEPC^^0
"BLD",3818,"KRN",19,"NM",3,0)
ROR TASK^^0
"BLD",3818,"KRN",19,"NM",4,0)
RORHDT CREATE^^0
"BLD",3818,"KRN",19,"NM",5,0)
RORHDT EDIT^^0
"BLD",3818,"KRN",19,"NM",6,0)
RORHDT EDIT REGISTRY^^0
"BLD",3818,"KRN",19,"NM",7,0)
RORHDT EDIT TASK^^0
"BLD",3818,"KRN",19,"NM",8,0)
RORHDT LOG^^0
"BLD",3818,"KRN",19,"NM",9,0)
RORHDT MAIN^^0
"BLD",3818,"KRN",19,"NM",10,0)
RORHDT START^^0
"BLD",3818,"KRN",19,"NM",11,0)
RORHDT STATUS^^0
"BLD",3818,"KRN",19,"NM",12,0)
RORHDT STOP^^0
"BLD",3818,"KRN",19,"NM",13,0)
RORMNT AWAITING ACK^^0
"BLD",3818,"KRN",19,"NM",14,0)
RORMNT EDIT LAB SEARCH^^0
"BLD",3818,"KRN",19,"NM",15,0)
RORMNT EDIT REG PARAMS^^0
"BLD",3818,"KRN",19,"NM",16,0)
RORMNT MAIN^^0
"BLD",3818,"KRN",19,"NM",17,0)
RORMNT PRINT LOGS^^0
"BLD",3818,"KRN",19,"NM","B","ROR GUI MENU",1)

"BLD",3818,"KRN",19,"NM","B","ROR SETUP HEPC",2)

"BLD",3818,"KRN",19,"NM","B","ROR TASK",3)

"BLD",3818,"KRN",19,"NM","B","RORHDT CREATE",4)

"BLD",3818,"KRN",19,"NM","B","RORHDT EDIT",5)

"BLD",3818,"KRN",19,"NM","B","RORHDT EDIT REGISTRY",6)

"BLD",3818,"KRN",19,"NM","B","RORHDT EDIT TASK",7)

"BLD",3818,"KRN",19,"NM","B","RORHDT LOG",8)

"BLD",3818,"KRN",19,"NM","B","RORHDT MAIN",9)

"BLD",3818,"KRN",19,"NM","B","RORHDT START",10)

"BLD",3818,"KRN",19,"NM","B","RORHDT STATUS",11)

"BLD",3818,"KRN",19,"NM","B","RORHDT STOP",12)

"BLD",3818,"KRN",19,"NM","B","RORMNT AWAITING ACK",13)

"BLD",3818,"KRN",19,"NM","B","RORMNT EDIT LAB SEARCH",14)

"BLD",3818,"KRN",19,"NM","B","RORMNT EDIT REG PARAMS",15)

"BLD",3818,"KRN",19,"NM","B","RORMNT MAIN",16)

"BLD",3818,"KRN",19,"NM","B","RORMNT PRINT LOGS",17)

"BLD",3818,"KRN",19.1,0)
19.1
"BLD",3818,"KRN",19.1,"NM",0)
^9.68A^2^2
"BLD",3818,"KRN",19.1,"NM",1,0)
ROR VA HEPC ADMIN^^0
"BLD",3818,"KRN",19.1,"NM",2,0)
ROR VA HEPC USER^^0
"BLD",3818,"KRN",19.1,"NM","B","ROR VA HEPC ADMIN",1)

"BLD",3818,"KRN",19.1,"NM","B","ROR VA HEPC USER",2)

"BLD",3818,"KRN",101,0)
101
"BLD",3818,"KRN",101,"NM",0)
^9.68A^8^8
"BLD",3818,"KRN",101,"NM",1,0)
ROR-SITE-DRIVER^^0
"BLD",3818,"KRN",101,"NM",2,0)
ROR-SITE-SUBSCRIBER^^0
"BLD",3818,"KRN",101,"NM",3,0)
LR7O ALL EVSEND RESULTS^^2
"BLD",3818,"KRN",101,"NM",4,0)
ROR EVENT LAB^^0
"BLD",3818,"KRN",101,"NM",5,0)
PXK VISIT DATA EVENT^^2
"BLD",3818,"KRN",101,"NM",6,0)
ROR EVENT VISIT^^0
"BLD",3818,"KRN",101,"NM",7,0)
ROR EVENT PTF^^0
"BLD",3818,"KRN",101,"NM",8,0)
DGPM MOVEMENT EVENTS^^2
"BLD",3818,"KRN",101,"NM","B","DGPM MOVEMENT EVENTS",8)

"BLD",3818,"KRN",101,"NM","B","LR7O ALL EVSEND RESULTS",3)

"BLD",3818,"KRN",101,"NM","B","PXK VISIT DATA EVENT",5)

"BLD",3818,"KRN",101,"NM","B","ROR EVENT LAB",4)

"BLD",3818,"KRN",101,"NM","B","ROR EVENT PTF",7)

"BLD",3818,"KRN",101,"NM","B","ROR EVENT VISIT",6)

"BLD",3818,"KRN",101,"NM","B","ROR-SITE-DRIVER",1)

"BLD",3818,"KRN",101,"NM","B","ROR-SITE-SUBSCRIBER",2)

"BLD",3818,"KRN",409.61,0)
409.61
"BLD",3818,"KRN",771,0)
771
"BLD",3818,"KRN",771,"NM",0)
^9.68A^2^2
"BLD",3818,"KRN",771,"NM",1,0)
ROR AAC^^0
"BLD",3818,"KRN",771,"NM",2,0)
ROR SITE^^0
"BLD",3818,"KRN",771,"NM","B","ROR AAC",1)

"BLD",3818,"KRN",771,"NM","B","ROR SITE",2)

"BLD",3818,"KRN",870,0)
870
"BLD",3818,"KRN",870,"NM",0)
^9.68A^3^2
"BLD",3818,"KRN",870,"NM",2,0)
ROR SEND^^0
"BLD",3818,"KRN",870,"NM",3,0)
ROR RECV^^1^
"BLD",3818,"KRN",870,"NM","B","ROR RECV",3)

"BLD",3818,"KRN",870,"NM","B","ROR SEND",2)

"BLD",3818,"KRN",8989.51,0)
8989.51
"BLD",3818,"KRN",8989.51,"NM",0)
^9.68A^1^1
"BLD",3818,"KRN",8989.51,"NM",1,0)
ROR VA HEPC GUI SETTINGS^^0
"BLD",3818,"KRN",8989.51,"NM","B","ROR VA HEPC GUI SETTINGS",1)

"BLD",3818,"KRN",8989.52,0)
8989.52
"BLD",3818,"KRN",8994,0)
8994
"BLD",3818,"KRN",8994,"NM",0)
^9.68A^21^21
"BLD",3818,"KRN",8994,"NM",1,0)
ROR ACTIVATE INACTIVATE^^0
"BLD",3818,"KRN",8994,"NM",2,0)
ROR ACTIVATE PATIENT GET^^0
"BLD",3818,"KRN",8994,"NM",3,0)
ROR ACTIVITY DETAILS^^0
"BLD",3818,"KRN",8994,"NM",4,0)
ROR ACTIVITY LOG^^0
"BLD",3818,"KRN",8994,"NM",5,0)
ROR CLEAR RPC HANDLE^^0
"BLD",3818,"KRN",8994,"NM",6,0)
ROR DRUG REPORT^^0
"BLD",3818,"KRN",8994,"NM",7,0)
ROR EDIT PATIENT GET^^0
"BLD",3818,"KRN",8994,"NM",8,0)
ROR ENTER EDIT PATIENT^^0
"BLD",3818,"KRN",8994,"NM",9,0)
ROR GET CODE LIST^^0
"BLD",3818,"KRN",8994,"NM",10,0)
ROR GET GUI PARAMS^^0
"BLD",3818,"KRN",8994,"NM",11,0)
ROR GET RPC HANDLE^^0
"BLD",3818,"KRN",8994,"NM",12,0)
ROR GET USER NAME^^0
"BLD",3818,"KRN",8994,"NM",13,0)
ROR IDRUGS PATIENT SET^^0
"BLD",3818,"KRN",8994,"NM",14,0)
ROR INV DRUGS^^0
"BLD",3818,"KRN",8994,"NM",15,0)
ROR LOG MESSAGE DETAILS^^0
"BLD",3818,"KRN",8994,"NM",16,0)
ROR PATIENT CHECKS^^0
"BLD",3818,"KRN",8994,"NM",17,0)
ROR PATIENT SEARCH^^0
"BLD",3818,"KRN",8994,"NM",18,0)
ROR REG PARAMS GET^^0
"BLD",3818,"KRN",8994,"NM",19,0)
ROR REPORT^^0
"BLD",3818,"KRN",8994,"NM",20,0)
ROR SET GUI PARAMS^^0
"BLD",3818,"KRN",8994,"NM",21,0)
ROR STORE RPC HANDLE^^0
"BLD",3818,"KRN",8994,"NM","B","ROR ACTIVATE INACTIVATE",1)

"BLD",3818,"KRN",8994,"NM","B","ROR ACTIVATE PATIENT GET",2)

"BLD",3818,"KRN",8994,"NM","B","ROR ACTIVITY DETAILS",3)

"BLD",3818,"KRN",8994,"NM","B","ROR ACTIVITY LOG",4)

"BLD",3818,"KRN",8994,"NM","B","ROR CLEAR RPC HANDLE",5)

"BLD",3818,"KRN",8994,"NM","B","ROR DRUG REPORT",6)

"BLD",3818,"KRN",8994,"NM","B","ROR EDIT PATIENT GET",7)

"BLD",3818,"KRN",8994,"NM","B","ROR ENTER EDIT PATIENT",8)

"BLD",3818,"KRN",8994,"NM","B","ROR GET CODE LIST",9)

"BLD",3818,"KRN",8994,"NM","B","ROR GET GUI PARAMS",10)

"BLD",3818,"KRN",8994,"NM","B","ROR GET RPC HANDLE",11)

"BLD",3818,"KRN",8994,"NM","B","ROR GET USER NAME",12)

"BLD",3818,"KRN",8994,"NM","B","ROR IDRUGS PATIENT SET",13)

"BLD",3818,"KRN",8994,"NM","B","ROR INV DRUGS",14)

"BLD",3818,"KRN",8994,"NM","B","ROR LOG MESSAGE DETAILS",15)

"BLD",3818,"KRN",8994,"NM","B","ROR PATIENT CHECKS",16)

"BLD",3818,"KRN",8994,"NM","B","ROR PATIENT SEARCH",17)

"BLD",3818,"KRN",8994,"NM","B","ROR REG PARAMS GET",18)

"BLD",3818,"KRN",8994,"NM","B","ROR REPORT",19)

"BLD",3818,"KRN",8994,"NM","B","ROR SET GUI PARAMS",20)

"BLD",3818,"KRN",8994,"NM","B","ROR STORE RPC HANDLE",21)

"BLD",3818,"KRN","B",.4,.4)

"BLD",3818,"KRN","B",.401,.401)

"BLD",3818,"KRN","B",.402,.402)

"BLD",3818,"KRN","B",.403,.403)

"BLD",3818,"KRN","B",.5,.5)

"BLD",3818,"KRN","B",.84,.84)

"BLD",3818,"KRN","B",3.6,3.6)

"BLD",3818,"KRN","B",3.8,3.8)

"BLD",3818,"KRN","B",9.2,9.2)

"BLD",3818,"KRN","B",9.8,9.8)

"BLD",3818,"KRN","B",19,19)

"BLD",3818,"KRN","B",19.1,19.1)

"BLD",3818,"KRN","B",101,101)

"BLD",3818,"KRN","B",409.61,409.61)

"BLD",3818,"KRN","B",771,771)

"BLD",3818,"KRN","B",870,870)

"BLD",3818,"KRN","B",8989.51,8989.51)

"BLD",3818,"KRN","B",8989.52,8989.52)

"BLD",3818,"KRN","B",8994,8994)

"BLD",3818,"PRE")
RORENV01
"BLD",3818,"QUES",0)
^9.62^^0
"BLD",3818,"REQB",0)
^9.611^7^7
"BLD",3818,"REQB",1,0)
LR*5.2*232^2
"BLD",3818,"REQB",2,0)
LA*5.2*46^2
"BLD",3818,"REQB",3,0)
LR*5.2*222^2
"BLD",3818,"REQB",5,0)
HL*1.6*57^2
"BLD",3818,"REQB",6,0)
LR*5.2*215^2
"BLD",3818,"REQB",7,0)
PSN*4.0*53^2
"BLD",3818,"REQB","B","HL*1.6*57",5)

"BLD",3818,"REQB","B","LA*5.2*46",2)

"BLD",3818,"REQB","B","LR*5.2*215",6)

"BLD",3818,"REQB","B","LR*5.2*222",3)

"BLD",3818,"REQB","B","LR*5.2*232",1)

"BLD",3818,"REQB","B","PSN*4.0*53",7)

"DATA",798.1,1,0)
VA HEPC^2960101^2960101^Local HepC Registry^365^1^^^^^1^^^1
"DATA",798.1,1,1,0)
^798.13^7^4
"DATA",798.1,1,1,3,0)
VA HEPC PROBLEM
"DATA",798.1,1,1,5,0)
VA HEPC LAB
"DATA",798.1,1,1,6,0)
VA HEPC PTF
"DATA",798.1,1,1,7,0)
VA HEPC VPOV
"DATA",798.1,1,6,0)
^798.19I^14^14
"DATA",798.1,1,6,1,0)
PID^^1
"DATA",798.1,1,6,1,1)

"DATA",798.1,1,6,2,0)
ZSP^^1
"DATA",798.1,1,6,2,1)

"DATA",798.1,1,6,3,0)
ZRD^^1
"DATA",798.1,1,6,3,1)

"DATA",798.1,1,6,4,0)
OBR^^2
"DATA",798.1,1,6,5,0)
OBX^^2
"DATA",798.1,1,6,6,0)
NTE^^2
"DATA",798.1,1,6,7,0)
CSR^^1
"DATA",798.1,1,6,7,1)

"DATA",798.1,1,6,8,0)
CSP^^1
"DATA",798.1,1,6,8,1)

"DATA",798.1,1,6,9,0)
CSS^^1
"DATA",798.1,1,6,9,1)

"DATA",798.1,1,6,10,0)
ORC^^3
"DATA",798.1,1,6,11,0)
RXE^^3
"DATA",798.1,1,6,12,0)
OBR^^4
"DATA",798.1,1,6,13,0)
OBR^^7
"DATA",798.1,1,6,14,0)
OBR^^8
"DATA",798.1,1,7)

"DATA",798.1,1,8,0)
^798.112I^130^90
"DATA",798.1,1,8,10,0)
10676^
"DATA",798.1,1,8,13,0)
6768^
"DATA",798.1,1,8,14,0)
1920^
"DATA",798.1,1,8,15,0)
1742^
"DATA",798.1,1,8,16,0)
1751^
"DATA",798.1,1,8,17,0)
1968^
"DATA",798.1,1,8,20,0)
6301^
"DATA",798.1,1,8,22,0)
2160^
"DATA",798.1,1,8,23,0)
718^
"DATA",798.1,1,8,29,0)
6777^
"DATA",798.1,1,8,30,0)
5195^
"DATA",798.1,1,8,36,0)
17009^
"DATA",798.1,1,8,37,0)
5192^
"DATA",798.1,1,8,43,0)
13950^
"DATA",798.1,1,8,44,0)
1975^
"DATA",798.1,1,8,45,0)
8061^
"DATA",798.1,1,8,46,0)
2276^
"DATA",798.1,1,8,47,0)
7917^
"DATA",798.1,1,8,48,0)
5198
"DATA",798.1,1,8,52,0)
5902
"DATA",798.1,1,8,53,0)
3015
"DATA",798.1,1,8,54,0)
3016
"DATA",798.1,1,8,55,0)
5186
"DATA",798.1,1,8,56,0)
1834
"DATA",798.1,1,8,57,0)
5010
"DATA",798.1,1,8,58,0)
5199
"DATA",798.1,1,8,59,0)
13955
"DATA",798.1,1,8,60,0)
15152
"DATA",798.1,1,8,61,0)
22314
"DATA",798.1,1,8,62,0)
22318
"DATA",798.1,1,8,63,0)
22322
"DATA",798.1,1,8,64,0)
26464
"DATA",798.1,1,8,65,0)
26499
"DATA",798.1,1,8,66,0)
26508
"DATA",798.1,1,8,67,0)
26511
"DATA",798.1,1,8,68,0)
26515
"DATA",798.1,1,8,69,0)
11259
"DATA",798.1,1,8,71,0)
11011
"DATA",798.1,1,8,73,0)
12190
"DATA",798.1,1,8,75,0)
6690
"DATA",798.1,1,8,76,0)
770
"DATA",798.1,1,8,78,0)
764
"DATA",798.1,1,8,79,0)
777
"DATA",798.1,1,8,80,0)
2345
"DATA",798.1,1,8,84,0)
2349
"DATA",798.1,1,8,85,0)
10832
"DATA",798.1,1,8,86,0)
5196
"DATA",798.1,1,8,87,0)
10900
"DATA",798.1,1,8,88,0)
16935
"DATA",798.1,1,8,89,0)
13952
"DATA",798.1,1,8,90,0)
24113
"DATA",798.1,1,8,91,0)
13954
"DATA",798.1,1,8,92,0)
13951
"DATA",798.1,1,8,93,0)
5048
"DATA",798.1,1,8,94,0)
7918
"DATA",798.1,1,8,95,0)
2324
"DATA",798.1,1,8,96,0)
22327
"DATA",798.1,1,8,98,0)
29615
"DATA",798.1,1,8,99,0)
6422
"DATA",798.1,1,8,100,0)
12805
"DATA",798.1,1,8,101,0)
1970
"DATA",798.1,1,8,102,0)
804
"DATA",798.1,1,8,103,0)
28942
"DATA",798.1,1,8,104,0)
769
"DATA",798.1,1,8,105,0)
26505
"DATA",798.1,1,8,106,0)
23761
"DATA",798.1,1,8,107,0)
751
"DATA",798.1,1,8,108,0)
778
"DATA",798.1,1,8,109,0)
9317
"DATA",798.1,1,8,110,0)
11580
"DATA",798.1,1,8,111,0)
11579
"DATA",798.1,1,8,112,0)
12651
"DATA",798.1,1,8,113,0)
2339
"DATA",798.1,1,8,114,0)
7905
"DATA",798.1,1,8,115,0)
5193
"DATA",798.1,1,8,116,0)
16933
"DATA",798.1,1,8,117,0)
5191
"DATA",798.1,1,8,118,0)
22297
"DATA",798.1,1,8,119,0)
13068
"DATA",798.1,1,8,120,0)
5220
"DATA",798.1,1,8,121,0)
14092
"DATA",798.1,1,8,122,0)
21009
"DATA",798.1,1,8,123,0)
26010
"DATA",798.1,1,8,124,0)
16128
"DATA",798.1,1,8,125,0)
24011
"DATA",798.1,1,8,126,0)
29609
"DATA",798.1,1,8,127,0)
1743
"DATA",798.1,1,8,128,0)
16936
"DATA",798.1,1,8,129,0)
20416
"DATA",798.1,1,8,130,0)
20571
"DATA",798.1,1,9)
5274
"DATA",798.1,1,10,0)
^798.114P^^0
"DATA",798.1,1,11)
2^1
"DATA",798.1,1,12,0)
^798.117^47^47
"DATA",798.1,1,12,1,0)
000085057106
"DATA",798.1,1,12,2,0)
000085012003
"DATA",798.1,1,12,3,0)
000085012004
"DATA",798.1,1,12,4,0)
000004198701
"DATA",798.1,1,12,5,0)
000004198709
"DATA",798.1,1,12,6,0)
000004200909
"DATA",798.1,1,12,7,0)
000085111001
"DATA",798.1,1,12,8,0)
000004199309
"DATA",798.1,1,12,9,0)
000004200509
"DATA",798.1,1,12,10,0)
000004201209
"DATA",798.1,1,12,11,0)
000004198809
"DATA",798.1,1,12,12,0)
000004690033
"DATA",798.1,1,12,13,0)
000004201109
"DATA",798.1,1,12,14,0)
000004200709
"DATA",798.1,1,12,15,0)
000085068901
"DATA",798.1,1,12,16,0)
000085095301
"DATA",798.1,1,12,17,0)
000085116801
"DATA",798.1,1,12,18,0)
000085064703
"DATA",798.1,1,12,19,0)
000085064704
"DATA",798.1,1,12,20,0)
000085064705
"DATA",798.1,1,12,21,0)
000085118401
"DATA",798.1,1,12,22,0)
000085012002
"DATA",798.1,1,12,23,0)
000085119101
"DATA",798.1,1,12,24,0)
000085119102
"DATA",798.1,1,12,25,0)
000085057102
"DATA",798.1,1,12,26,0)
000085092301
"DATA",798.1,1,12,27,0)
000085117901
"DATA",798.1,1,12,28,0)
000085117902
"DATA",798.1,1,12,29,0)
000085028502
"DATA",798.1,1,12,30,0)
000085076901
"DATA",798.1,1,12,31,0)
000085113301
"DATA",798.1,1,12,32,0)
055513055406
"DATA",798.1,1,12,33,0)
055513055401
"DATA",798.1,1,12,34,0)
055513056206
"DATA",798.1,1,12,35,0)
055513056201
"DATA",798.1,1,12,36,0)
000004201009
"DATA",798.1,1,12,37,0)
000085053901
"DATA",798.1,1,12,38,0)
000085124102
"DATA",798.1,1,12,39,0)
000085123602
"DATA",798.1,1,12,40,0)
000085125802
"DATA",798.1,1,12,41,0)
000085124101
"DATA",798.1,1,12,42,0)
000085123601
"DATA",798.1,1,12,43,0)
000085125801
"DATA",798.1,1,12,44,0)
000085124103
"DATA",798.1,1,12,45,0)
000085123603
"DATA",798.1,1,12,46,0)
000085125803
"DATA",798.1,1,12,47,0)
999999777701
"DATA",798.1,1,13,0)
^798.116A^^0
"DATA",798.1,1,19)
^
"DATA",798.1,1,21)
2960101^^^
"DATA",798.1,1,21.03)

"DATA",798.2,4,0)
VA HEPC VPOV^9000010.07^HepC ICD-9 code in V POV file^1
"DATA",798.2,4,1)
",V02.62,070.41,070.44,070.51,070.54,"[(","_{E:POV}_",")
"DATA",798.2,4,3,0)
^798.25^1^1^3020124^^^^
"DATA",798.2,4,3,1,0)
 
"DATA",798.2,6,0)
VA HEPC PTF^45^ICD-9 code in PTF file^1
"DATA",798.2,6,1)
$$PTFRULE^RORUPD09(",V02.62,070.41,070.44,070.51,070.54,")
"DATA",798.2,6,4,0)
^798.26^11^11
"DATA",798.2,6,4,1,0)
101^E
"DATA",798.2,6,4,2,0)
102^E
"DATA",798.2,6,4,3,0)
103^E
"DATA",798.2,6,4,4,0)
104^E
"DATA",798.2,6,4,5,0)
105^E
"DATA",798.2,6,4,6,0)
106^E
"DATA",798.2,6,4,7,0)
107^E
"DATA",798.2,6,4,8,0)
108^E
"DATA",798.2,6,4,9,0)
109^E
"DATA",798.2,6,4,10,0)
110^E
"DATA",798.2,6,4,11,0)
111^E
"DATA",798.2,7,0)
VA HEPC PROBLEM^9000011^HepC ICD-9 in the Problem List^1
"DATA",798.2,7,1)
",V02.62,070.41,070.44,070.51,070.54,"[(","_{E:DIAGNOSIS}_",")
"DATA",798.2,8,0)
VA HEPC LAB^63^HEPC Lab Results^1
"DATA",798.2,8,1)
{LS:VA HEPC}
"DATA",798.2,11,0)
VA HEPC PTF HIST^45^2 or more ICD-9 in PTF^1
"DATA",798.2,11,1)
{SUM:VA HEPC PTF}>1
"DATA",798.2,12,0)
VA HEPC VISIT^9000010^ICD-9 in the V POV file^1
"DATA",798.2,12,1)
{SUM:VA HEPC VPOV}>0
"DATA",798.2,13,0)
VA HEPC VISIT HIST^9000010^2 or more visits with ICD-9^1
"DATA",798.2,13,1)
{SUM:VA HEPC VISIT}>1
"DATA",798.9,3,0)
VA HEPC^^1
"DATA",798.9,3,1,0)
^798.92^3^3
"DATA",798.9,3,1,1,0)
5198^^0^
"DATA",798.9,3,1,2,0)
13955^^0^
"DATA",798.9,3,1,3,0)
22327^^0^
"DATA",799.1,1,0)
Manually entered in error^1^1^1^
"DATA",799.1,2,0)
Miscoded ICD-9^1^1^2
"DATA",799.1,3,0)
False Positive Hep C Ab Screening Test^1^1^3
"DATA",799.1,4,0)
Care elsewhere^1^1^4
"DATA",799.1,5,0)
HepC antibody result from another VA (untreated)^2^1^1
"DATA",799.1,6,0)
HepC antibody result from outside VA (untreated)^2^1^2
"DATA",799.1,7,0)
Previously diagnosed and treated for HepC (within VA)^2^1^3
"DATA",799.1,8,0)
Previously diagnosed and treated for HepC (outside VA)^2^1^4
"DATA",799.1,9,0)
Other^2^1^5
"DATA",799.2,2,0)
2
"DATA",799.2,45,0)
45^2
"DATA",799.2,45,2,0)
^799.22I^11^11
"DATA",799.2,45,2,1,0)
DXLS^101^^E^2^79
"DATA",799.2,45,2,1,4.1)
3^1
"DATA",799.2,45,2,2,0)
ICD02^102^^E^2^79.16
"DATA",799.2,45,2,2,4.1)
1^2
"DATA",799.2,45,2,3,0)
ICD03^103^^E^2^79.17
"DATA",799.2,45,2,3,4.1)
2^2
"DATA",799.2,45,2,4,0)
ICD04^104^^E^2^79.18
"DATA",799.2,45,2,4,4.1)
3^2
"DATA",799.2,45,2,5,0)
ICD05^105^^E^2^79.19
"DATA",799.2,45,2,5,4.1)
4^2
"DATA",799.2,45,2,6,0)
ICD06^106^^E^2^79.201
"DATA",799.2,45,2,6,4.1)
5^2
"DATA",799.2,45,2,7,0)
ICD07^107^^E^2^79.21
"DATA",799.2,45,2,7,4.1)
6^2
"DATA",799.2,45,2,8,0)
ICD08^108^^E^2^79.22
"DATA",799.2,45,2,8,4.1)
7^2
"DATA",799.2,45,2,9,0)
ICD09^109^^E^2^79.23
"DATA",799.2,45,2,9,4.1)
8^2
"DATA",799.2,45,2,10,0)
ICD10^110^^E^2^79.24
"DATA",799.2,45,2,10,4.1)
9^2
"DATA",799.2,45,2,11,0)
PRINCIPAL DIAGNOSIS^111^^E^1^80
"DATA",799.2,45,3,0)
^799.23I^2^1
"DATA",799.2,45,3,2,0)
2^DGPTFAPI^RPC^3157
"DATA",799.2,63,0)
63^2
"DATA",799.2,9000010,0)
9000010^2
"DATA",799.2,9000010,3,0)
^799.23I^2^1
"DATA",799.2,9000010,3,2,0)
2^VSIT^LOOKUP^1906
"DATA",799.2,9000010.07,0)
9000010.07^9000010
"DATA",799.2,9000010.07,2,0)
^799.22I^4^4
"DATA",799.2,9000010.07,2,1,0)
POV^112^^E^2^.01
"DATA",799.2,9000010.07,2,2,0)
MODIFIER^113^^I^2^.06
"DATA",799.2,9000010.07,2,2,4.2)
6
"DATA",799.2,9000010.07,2,3,0)
PRIMARY/SECONDARY^114^^I^2^.12
"DATA",799.2,9000010.07,2,3,4.2)
12
"DATA",799.2,9000010.07,2,4,0)
DATE OF INJURY^115^^I^2^.13
"DATA",799.2,9000010.07,2,4,4.2)
13
"DATA",799.2,9000010.07,3,0)
^799.23I^2^1
"DATA",799.2,9000010.07,3,2,0)
2^PXAPIIB^POV^1554
"DATA",799.2,9000011,0)
9000011^2
"DATA",799.2,9000011,2,0)
^799.22I^13^13
"DATA",799.2,9000011,2,1,0)
DIAGNOSIS^116^^E^2^.01
"DATA",799.2,9000011,2,1,4.1)
2^.01
"DATA",799.2,9000011,2,2,0)
DATE LAST MODIFIED^128^^EI^2^.03
"DATA",799.2,9000011,2,2,4.1)
2^.03
"DATA",799.2,9000011,2,2,4.2)
1^.03
"DATA",799.2,9000011,2,3,0)
PROVIDER NARRATIVE^117^^EI^2^.05
"DATA",799.2,9000011,2,3,4.1)
2^.05
"DATA",799.2,9000011,2,3,4.2)
1^.05
"DATA",799.2,9000011,2,4,0)
DATE ENTERED^118^1^EI^2^.08
"DATA",799.2,9000011,2,4,4.1)
2^.08
"DATA",799.2,9000011,2,4,4.2)
1^.08
"DATA",799.2,9000011,2,5,0)
DATE OF ONSET^119^^EI^2^.13
"DATA",799.2,9000011,2,5,4.1)
2^.13
"DATA",799.2,9000011,2,5,4.2)
1^.13
"DATA",799.2,9000011,2,6,0)
PROBLEM^120^^EI^2^1.01
"DATA",799.2,9000011,2,6,4.1)
2^1.01
"DATA",799.2,9000011,2,6,4.2)
1^1.01
"DATA",799.2,9000011,2,7,0)
CONDITION^121^1^I^2^1.02
"DATA",799.2,9000011,2,7,4.2)
1^1.02
"DATA",799.2,9000011,2,8,0)
DATE RESOLVED^122^^EI^2^1.07
"DATA",799.2,9000011,2,8,4.1)
2^1.07
"DATA",799.2,9000011,2,8,4.2)
1^1.07
"DATA",799.2,9000011,2,9,0)
DATE RECORDED^123^^EI^2^1.09
"DATA",799.2,9000011,2,9,4.1)
2^1.09
"DATA",799.2,9000011,2,9,4.2)
1^1.09
"DATA",799.2,9000011,2,10,0)
SERVICE CONNECTED^124^^I^2^1.1
"DATA",799.2,9000011,2,10,4.2)
1^1.1
"DATA",799.2,9000011,2,11,0)
AGENT ORANGE EXPOSURE^125^^I^2^1.11
"DATA",799.2,9000011,2,11,4.2)
1^1.11
"DATA",799.2,9000011,2,12,0)
IONIZING RADIATION EXPOSURE^126^^I^2^1.12
"DATA",799.2,9000011,2,12,4.2)
1^1.12
"DATA",799.2,9000011,2,13,0)
PERSIAN GULF EXPOSURE^127^^I^2^1.13
"DATA",799.2,9000011,2,13,4.2)
1^1.13
"DATA",799.2,9000011,3,0)
^799.23I^2^1
"DATA",799.2,9000011,3,2,0)
2^GMPLEDT3^GETFLDS^2977
"FIA",798)
ROR LOCAL REGISTRY
"FIA",798,0)
^RORDATA(798,
"FIA",798,0,0)
798PA
"FIA",798,0,1)
y^y^f^^^^n
"FIA",798,0,10)

"FIA",798,0,11)

"FIA",798,0,"RLRO")

"FIA",798,0,"VR")
1.0^ROR
"FIA",798,798)
0
"FIA",798,798.01)
0
"FIA",798.1)
ROR REGISTRY PARAMETERS
"FIA",798.1,0)
^ROR(798.1,
"FIA",798.1,0,0)
798.1I
"FIA",798.1,0,1)
y^y^f^^n^^y^m^n
"FIA",798.1,0,10)

"FIA",798.1,0,11)
I $E($P($G(^ROR(798.1,Y,0)),U),1,7)="VA HEPC"
"FIA",798.1,0,"RLRO")

"FIA",798.1,0,"VR")
1.0^ROR
"FIA",798.1,798.1)
0
"FIA",798.1,798.11)
0
"FIA",798.1,798.112)
0
"FIA",798.1,798.114)
0
"FIA",798.1,798.116)
0
"FIA",798.1,798.117)
0
"FIA",798.1,798.13)
0
"FIA",798.1,798.15)
0
"FIA",798.1,798.19)
0
"FIA",798.2)
ROR SELECTION RULE
"FIA",798.2,0)
^ROR(798.2,
"FIA",798.2,0,0)
798.2I
"FIA",798.2,0,1)
y^y^f^^y^^y^o^n
"FIA",798.2,0,10)

"FIA",798.2,0,11)
I $E($P($G(^ROR(798.2,Y,0)),U),1,7)="VA HEPC"
"FIA",798.2,0,"RLRO")

"FIA",798.2,0,"VR")
1.0^ROR
"FIA",798.2,798.2)
0
"FIA",798.2,798.25)
0
"FIA",798.2,798.26)
0
"FIA",798.3)
ROR PENDING PATIENT
"FIA",798.3,0)
^RORDATA(798.3,
"FIA",798.3,0,0)
798.3P
"FIA",798.3,0,1)
y^y^f^^y^^n^o^n
"FIA",798.3,0,10)

"FIA",798.3,0,11)

"FIA",798.3,0,"RLRO")

"FIA",798.3,0,"VR")
1.0^ROR
"FIA",798.3,798.3)
0
"FIA",798.3,798.31)
0
"FIA",798.3,798.32)
0
"FIA",798.4)
ROR PATIENT
"FIA",798.4,0)
^RORDATA(798.4,
"FIA",798.4,0,0)
798.4P
"FIA",798.4,0,1)
y^y^f^^^^n
"FIA",798.4,0,10)

"FIA",798.4,0,11)

"FIA",798.4,0,"RLRO")

"FIA",798.4,0,"VR")
1.0^ROR
"FIA",798.4,798.4)
0
"FIA",798.4,798.41)
0
"FIA",798.5)
ROR HDT TASK
"FIA",798.5,0)
^RORDATA(798.5,
"FIA",798.5,0,0)
798.5
"FIA",798.5,0,1)
y^y^f^^^^n
"FIA",798.5,0,10)

"FIA",798.5,0,11)

"FIA",798.5,0,"RLRO")

"FIA",798.5,0,"VR")
1.0^ROR
"FIA",798.5,798.5)
0
"FIA",798.5,798.53)
0
"FIA",798.6)
ROR PHARMACY CODE
"FIA",798.6,0)
^ROR(798.6,
"FIA",798.6,0,0)
798.6P
"FIA",798.6,0,1)
y^y^f^^^^n
"FIA",798.6,0,10)

"FIA",798.6,0,11)

"FIA",798.6,0,"RLRO")

"FIA",798.6,0,"VR")
1.0^ROR
"FIA",798.6,798.6)
0
"FIA",798.7)
ROR LOG
"FIA",798.7,0)
^RORDATA(798.7,
"FIA",798.7,0,0)
798.7D
"FIA",798.7,0,1)
y^y^f^^^^n
"FIA",798.7,0,10)

"FIA",798.7,0,11)

"FIA",798.7,0,"RLRO")

"FIA",798.7,0,"VR")
1.0^ROR
"FIA",798.7,798.7)
0
"FIA",798.7,798.73)
0
"FIA",798.7,798.74)
0
"FIA",798.7,798.744)
0
"FIA",798.9)
ROR LAB SEARCH
"FIA",798.9,0)
^ROR(798.9,
"FIA",798.9,0,0)
798.9
"FIA",798.9,0,1)
y^y^f^^n^^y^m^n
"FIA",798.9,0,10)

"FIA",798.9,0,11)
I $E($P($G(^ROR(798.9,Y,0)),U),1,7)="VA HEPC"
"FIA",798.9,0,"RLRO")

"FIA",798.9,0,"VR")
1.0^ROR
"FIA",798.9,798.9)
0
"FIA",798.9,798.92)
0
"FIA",799.1)
ROR LIST ITEM
"FIA",799.1,0)
^ROR(799.1,
"FIA",799.1,0,0)
799.1
"FIA",799.1,0,1)
y^y^f^^y^^y^o^n
"FIA",799.1,0,10)

"FIA",799.1,0,11)

"FIA",799.1,0,"RLRO")

"FIA",799.1,0,"VR")
1.0^ROR
"FIA",799.1,799.1)
0
"FIA",799.2)
ROR METADATA
"FIA",799.2,0)
^ROR(799.2,
"FIA",799.2,0,0)
799.2I
"FIA",799.2,0,1)
y^y^f^^n^^y^o^n
"FIA",799.2,0,10)

"FIA",799.2,0,11)

"FIA",799.2,0,"RLRO")

"FIA",799.2,0,"VR")
1.0^ROR
"FIA",799.2,799.2)
0
"FIA",799.2,799.22)
0
"FIA",799.2,799.23)
0
"FIA",799.2,799.25)
0
"INI")
START^RORPRE01
"INIT")
START^RORPOS01
"IX",798,798,"KEY",0)
798^KEY^Uniqueness Index for Key 'A' of File #798^R^^R^IR^I^798^^^^^LS
"IX",798,798,"KEY",.1,0)
^^3^3^3011005^
"IX",798,798,"KEY",.1,1,0)
This index guarantees uniqueness of the patient 
"IX",798,798,"KEY",.1,2,0)
record in the particular registry and allows to 
"IX",798,798,"KEY",.1,3,0)
easily find this record.
"IX",798,798,"KEY",1)
S ^RORDATA(798,"KEY",X(1),X(2),DA)=""
"IX",798,798,"KEY",2)
K ^RORDATA(798,"KEY",X(1),X(2),DA)
"IX",798,798,"KEY",2.5)
K ^RORDATA(798,"KEY")
"IX",798,798,"KEY",11.1,0)
^.114IA^2^2
"IX",798,798,"KEY",11.1,1,0)
1^F^798^.01^^1
"IX",798,798,"KEY",11.1,2,0)
2^F^798^.02^^2
"IX",798.1,798.1,"B",0)
798.1^B^Uniqueness Index for the "A" Key of the File # 798.1^R^^F^IR^I^798.1^^^^^LS
"IX",798.1,798.1,"B",1)
S ^ROR(798.1,"B",X,DA)=""
"IX",798.1,798.1,"B",2)
K ^ROR(798.1,"B",X,DA)
"IX",798.1,798.1,"B",2.5)
K ^ROR(798.1,"B")
"IX",798.1,798.1,"B",11.1,0)
^.114IA^1^1
"IX",798.1,798.1,"B",11.1,1,0)
1^F^798.1^.01^^1
"IX",798.1,798.13,"B",0)
798.13^B^Uniqueness Index for the "A" Key of Subfile #798.13^R^^F^IR^I^798.13^^^^^LS
"IX",798.1,798.13,"B",1)
S ^ROR(798.1,DA(1),1,"B",X,DA)=""
"IX",798.1,798.13,"B",2)
K ^ROR(798.1,DA(1),1,"B",X,DA)
"IX",798.1,798.13,"B",2.5)
K ^ROR(798.1,DA(1),1,"B")
"IX",798.1,798.13,"B",11.1,0)
^.114IA^1^1
"IX",798.1,798.13,"B",11.1,1,0)
1^F^798.13^.01^^1
"IX",798.1,798.19,"KEY",0)
798.19^KEY^Uniqueness Index for the "A" Key of Subfile #798.19^R^^R^IR^I^798.19^^^^^LS
"IX",798.1,798.19,"KEY",1)
S ^ROR(798.1,DA(1),6,"KEY",X(1),X(2),DA)=""
"IX",798.1,798.19,"KEY",2)
K ^ROR(798.1,DA(1),6,"KEY",X(1),X(2),DA)
"IX",798.1,798.19,"KEY",2.5)
K ^ROR(798.1,DA(1),6,"KEY")
"IX",798.1,798.19,"KEY",11.1,0)
^.114IA^2^2
"IX",798.1,798.19,"KEY",11.1,1,0)
1^F^798.19^.02^^1
"IX",798.1,798.19,"KEY",11.1,2,0)
2^F^798.19^.01^^2
"IX",798.2,798.2,"B",0)
798.2^B^Uniqueness Index for the "A" Key of File #798.2^R^^F^IR^I^798.2^^^^^LS
"IX",798.2,798.2,"B",1)
S ^ROR(798.2,"B",X,DA)=""
"IX",798.2,798.2,"B",2)
K ^ROR(798.2,"B",X,DA)
"IX",798.2,798.2,"B",2.5)
K ^ROR(798.2,"B")
"IX",798.2,798.2,"B",11.1,0)
^.114IA^1^1
"IX",798.2,798.2,"B",11.1,1,0)
1^F^798.2^.01^^1
"IX",798.2,798.26,"B",0)
798.26^B^Uniqueness Index for the "A" Key of Subfile #798.26^R^^F^IR^I^798.26^^^^^LS
"IX",798.2,798.26,"B",1)
S ^ROR(798.2,DA(1),4,"B",X,DA)=""
"IX",798.2,798.26,"B",2)
K ^ROR(798.2,DA(1),4,"B",X,DA)
"IX",798.2,798.26,"B",2.5)
K ^ROR(798.2,DA(1),4,"B")
"IX",798.2,798.26,"B",11.1,0)
^.114IA^1^1
"IX",798.2,798.26,"B",11.1,1,0)
1^F^798.26^.01^^1
"IX",798.3,798.31,"B",0)
798.31^B^Uniqueness Index for the "A" key of Subfile #798.31^R^^F^IR^I^798.31^^^^^LS
"IX",798.3,798.31,"B",1)
S ^RORDATA(798.3,DA(1),1,"B",X,DA)=""
"IX",798.3,798.31,"B",2)
K ^RORDATA(798.3,DA(1),1,"B",X,DA)
"IX",798.3,798.31,"B",2.5)
K ^RORDATA(798.3,DA(1),1,"B")
"IX",798.3,798.31,"B",11.1,0)
^.114IA^1^1
"IX",798.3,798.31,"B",11.1,1,0)
1^F^798.31^.01^^1
"IX",798.3,798.32,"AD",0)
798.32^AD^Data Area, Date^MU^^R^IR^I^798.32^^^^^S
"IX",798.3,798.32,"AD",1)
S ^RORDATA(798.3,DA(1),2,"AD",X(1),X(2)\1,DA)=""
"IX",798.3,798.32,"AD",2)
K ^RORDATA(798.3,DA(1),2,"AD",X(1),X(2)\1,DA)
"IX",798.3,798.32,"AD",2.5)
K ^RORDATA(798.3,DA(1),2,"AD")
"IX",798.3,798.32,"AD",11.1,0)
^.114IA^2^2
"IX",798.3,798.32,"AD",11.1,1,0)
1^F^798.32^1^^1^F
"IX",798.3,798.32,"AD",11.1,2,0)
2^F^798.32^2^^2^F
"IX",798.3,798.32,"AT",0)
798.32^AT^Data Area, Timestamp^R^^R^IR^I^798.32^^^^^S
"IX",798.3,798.32,"AT",1)
S ^RORDATA(798.3,DA(1),2,"AT",X(1),X(2),DA)=""
"IX",798.3,798.32,"AT",2)
K ^RORDATA(798.3,DA(1),2,"AT",X(1),X(2),DA)
"IX",798.3,798.32,"AT",2.5)
K ^RORDATA(798.3,DA(1),2,"AT")
"IX",798.3,798.32,"AT",11.1,0)
^.114IA^2^2
"IX",798.3,798.32,"AT",11.1,1,0)
1^F^798.32^1^^1^F
"IX",798.3,798.32,"AT",11.1,2,0)
2^F^798.32^.01^^2^F
"IX",798.5,798.5,"C",0)
798.5^C^Uniqueness Index for the "A" Key of File #798.5^R^^R^IR^I^798.5^^^^^LS
"IX",798.5,798.5,"C",1)
S ^RORDATA(798.5,"C",X(1),X(2),DA)=""
"IX",798.5,798.5,"C",2)
K ^RORDATA(798.5,"C",X(1),X(2),DA)
"IX",798.5,798.5,"C",2.5)
K ^RORDATA(798.5,"C")
"IX",798.5,798.5,"C",11.1,0)
^.114IA^2^2
"IX",798.5,798.5,"C",11.1,1,0)
1^F^798.5^.02^^1
"IX",798.5,798.5,"C",11.1,2,0)
2^F^798.5^.01^^2
"IX",798.5,798.5,"DF",0)
798.5^DF^Uniqueness Index for the "B" Key of File #798.5^R^^R^IR^I^798.5^^^^^LS
"IX",798.5,798.5,"DF",1)
S ^RORDATA(798.5,"DF",X(1),X(2),DA)=""
"IX",798.5,798.5,"DF",2)
K ^RORDATA(798.5,"DF",X(1),X(2),DA)
"IX",798.5,798.5,"DF",2.5)
K ^RORDATA(798.5,"DF")
"IX",798.5,798.5,"DF",11.1,0)
^.114IA^2^2
"IX",798.5,798.5,"DF",11.1,1,0)
1^F^798.5^.02^^1
"IX",798.5,798.5,"DF",11.1,2,0)
2^F^798.5^1.01^^2
"IX",798.7,798.7,"ARD",0)
798.7^ARD^Registry & Start date^R^^R^IR^W^798.73^^^^^S
"IX",798.7,798.7,"ARD",.1,0)
^^2^2^3011011^^
"IX",798.7,798.7,"ARD",.1,1,0)
This index can be used to get a chronological list
"IX",798.7,798.7,"ARD",.1,2,0)
of logs associated with the particular registry.
"IX",798.7,798.7,"ARD",1)
S ^RORDATA(798.7,"ARD",X(1),X(2),DA(1),DA)=""
"IX",798.7,798.7,"ARD",2)
K ^RORDATA(798.7,"ARD",X(1),X(2),DA(1),DA)
"IX",798.7,798.7,"ARD",2.5)
K ^RORDATA(798.7,"ARD")
"IX",798.7,798.7,"ARD",11.1,0)
^.114IA^2^2
"IX",798.7,798.7,"ARD",11.1,1,0)
1^F^798.73^.01^^1^F
"IX",798.7,798.7,"ARD",11.1,2,0)
2^C^^^^2
"IX",798.7,798.7,"ARD",11.1,2,1.5)
S X=$P($G(^RORDATA(798.7,DA(1),0)),U)
"IX",798.9,798.9,"B",0)
798.9^B^Uniqueness Index for the "A" Key of File #798.9^R^^F^IR^I^798.9^^^^^LS
"IX",798.9,798.9,"B",1)
S ^ROR(798.9,"B",X,DA)=""
"IX",798.9,798.9,"B",2)
K ^ROR(798.9,"B",X,DA)
"IX",798.9,798.9,"B",2.5)
K ^ROR(798.9,"B")
"IX",798.9,798.9,"B",11.1,0)
^.114IA^1^1
"IX",798.9,798.9,"B",11.1,1,0)
1^F^798.9^.01^^1
"IX",799.1,799.1,"KEY",0)
799.1^KEY^Uniqueness Index for the "A" Key of File #799.1^R^^R^IR^I^799.1^^^^^LS
"IX",799.1,799.1,"KEY",1)
S ^ROR(799.1,"KEY",X(1),X(2),X(3),DA)=""
"IX",799.1,799.1,"KEY",2)
K ^ROR(799.1,"KEY",X(1),X(2),X(3),DA)
"IX",799.1,799.1,"KEY",2.5)
K ^ROR(799.1,"KEY")
"IX",799.1,799.1,"KEY",11.1,0)
^.114IA^3^3
"IX",799.1,799.1,"KEY",11.1,1,0)
1^F^799.1^.02^^1
"IX",799.1,799.1,"KEY",11.1,2,0)
2^F^799.1^.03^^2
"IX",799.1,799.1,"KEY",11.1,3,0)
3^F^799.1^.04^^3
"IX",799.2,799.2,"DEC",0)
799.2^DEC^Global list of Data Element Codes.^R^^F^IR^W^799.22^^^^^LS
"IX",799.2,799.2,"DEC",1)
S ^ROR(799.2,"DEC",X,DA(1),DA)=""
"IX",799.2,799.2,"DEC",2)
K ^ROR(799.2,"DEC",X,DA(1),DA)
"IX",799.2,799.2,"DEC",2.5)
K ^ROR(799.2,"DEC")
"IX",799.2,799.2,"DEC",11.1,0)
^.114IA^1^1
"IX",799.2,799.2,"DEC",11.1,1,0)
1^F^799.22^.02^^1^F
"IX",799.2,799.22,"B",0)
799.22^B^Data element name uniqueness index.^R^^F^IR^I^799.22^^^^^LS
"IX",799.2,799.22,"B",1)
S ^ROR(799.2,DA(1),2,"B",$E(X,1,30),DA)=""
"IX",799.2,799.22,"B",2)
K ^ROR(799.2,DA(1),2,"B",$E(X,1,30),DA)
"IX",799.2,799.22,"B",2.5)
K ^ROR(799.2,DA(1),2,"B")
"IX",799.2,799.22,"B",11.1,0)
^.114IA^1^1
"IX",799.2,799.22,"B",11.1,1,0)
1^F^799.22^.01^30^1^F
"KEY",798,798,"A",0)
798^A^P^100
"KEY",798,798,"A",2,0)
^.312IA^2^2
"KEY",798,798,"A",2,1,0)
.01^798^1
"KEY",798,798,"A",2,2,0)
.02^798^2
"KEY",798.1,798.1,"A",0)
798.1^A^P^101
"KEY",798.1,798.1,"A",2,0)
^.312IA^1^1
"KEY",798.1,798.1,"A",2,1,0)
.01^798.1^1
"KEY",798.1,798.13,"A",0)
798.13^A^P^102
"KEY",798.1,798.13,"A",2,0)
^.312IA^1^1
"KEY",798.1,798.13,"A",2,1,0)
.01^798.13^1
"KEY",798.1,798.19,"A",0)
798.19^A^P^113
"KEY",798.1,798.19,"A",2,0)
^.312IA^2^2
"KEY",798.1,798.19,"A",2,1,0)
.02^798.19^1
"KEY",798.1,798.19,"A",2,2,0)
.01^798.19^2
"KEY",798.2,798.2,"A",0)
798.2^A^P^103
"KEY",798.2,798.2,"A",2,0)
^.312IA^1^1
"KEY",798.2,798.2,"A",2,1,0)
.01^798.2^1
"KEY",798.2,798.26,"A",0)
798.26^A^P^104
"KEY",798.2,798.26,"A",2,0)
^.312IA^1^1
"KEY",798.2,798.26,"A",2,1,0)
.01^798.26^1
"KEY",798.3,798.31,"A",0)
798.31^A^P^162
"KEY",798.3,798.31,"A",2,0)
^.312IA^1^1
"KEY",798.3,798.31,"A",2,1,0)
.01^798.31^1
"KEY",798.5,798.5,"A",0)
798.5^A^P^144
"KEY",798.5,798.5,"A",2,0)
^.312IA^2^2
"KEY",798.5,798.5,"A",2,1,0)
.02^798.5^1
"KEY",798.5,798.5,"A",2,2,0)
.01^798.5^2
"KEY",798.5,798.5,"B",0)
798.5^B^S^145
"KEY",798.5,798.5,"B",2,0)
^.312IA^2^2
"KEY",798.5,798.5,"B",2,1,0)
.02^798.5^1
"KEY",798.5,798.5,"B",2,2,0)
1.01^798.5^2
"KEY",798.9,798.9,"A",0)
798.9^A^P^117
"KEY",798.9,798.9,"A",2,0)
^.312IA^1^1
"KEY",798.9,798.9,"A",2,1,0)
.01^798.9^1
"KEY",799.1,799.1,"A",0)
799.1^A^P^143
"KEY",799.1,799.1,"A",2,0)
^.312IA^3^3
"KEY",799.1,799.1,"A",2,1,0)
.02^799.1^1
"KEY",799.1,799.1,"A",2,2,0)
.03^799.1^2
"KEY",799.1,799.1,"A",2,3,0)
.04^799.1^3
"KEY",799.2,799.22,"A",0)
799.22^A^S^159
"KEY",799.2,799.22,"A",2,0)
^.312IA^1^1
"KEY",799.2,799.22,"A",2,1,0)
.02^799.22^1
"KEY",799.2,799.22,"B",0)
799.22^B^P^160
"KEY",799.2,799.22,"B",2,0)
^.312IA^1^1
"KEY",799.2,799.22,"B",2,1,0)
.01^799.22^1
"KEYPTR",798,798,"A")
798^KEY
"KEYPTR",798.1,798.1,"A")
798.1^B
"KEYPTR",798.1,798.13,"A")
798.13^B
"KEYPTR",798.1,798.19,"A")
798.19^KEY
"KEYPTR",798.2,798.2,"A")
798.2^B
"KEYPTR",798.2,798.26,"A")
798.26^B
"KEYPTR",798.3,798.31,"A")
798.31^B
"KEYPTR",798.5,798.5,"A")
798.5^C
"KEYPTR",798.5,798.5,"B")
798.5^DF
"KEYPTR",798.9,798.9,"A")
798.9^B
"KEYPTR",799.1,799.1,"A")
799.1^KEY
"KEYPTR",799.2,799.22,"A")
799.2^DEC
"KEYPTR",799.2,799.22,"B")
799.22^B
"KRN",.4,2183,-1)
0^2
"KRN",.4,2183,0)
ROR LOG^3011030.1109^^798.7^^@^3020404
"KRN",.4,2183,"%D",0)
^^2^2^3020403^
"KRN",.4,2183,"%D",1,0)
This template is used by the [RORMNT PRINT LOGS] option to print 
"KRN",.4,2183,"%D",2,0)
messages from the log files.
"KRN",.4,2183,"F",1)
4,.01;S1;C1~4,1~4,3~4,2;C4~4,4,.01;C4~
"KRN",.4,2183,"H")
CLINICAL REGISTRIES LOG FILE(S)
"KRN",.4,2303,-1)
0^1
"KRN",.4,2303,0)
ROR DATA ELEMENTS^3020404.1407^^799.2^^@^3020405
"KRN",.4,2303,"F",1)
2,.02;R4;"Code"~2,.01;L25;"Data Name"~2,S DIP(1)=$S($D(^ROR(799.2,D0,0)):^(0),1:"") S X=$P(DIP(1),U,1) W X K DIP;L;"File";Z;"FILE"~
"KRN",.4,2303,"F",2)
2,6;L;"Field Number"~2,2;"Req"~2,1;"API"~
"KRN",.4,2303,"F",3)
2,S DIP(1)=$S($D(^ROR(799.2,D0,2,D1,0)):^(0),1:"") S X=$P(DIP(1),U,4),X=X W X K DIP;"VT";Z;"INTERNAL(VALUE TYPE)"~2,4.1;L20;"External Data"~
"KRN",.4,2303,"F",4)
2,4.2;L20;"Internal Data"~
"KRN",.4,2303,"H")
ROR METADATA LIST
"KRN",.401,1513,-1)
0^2
"KRN",.401,1513,0)
ROR LOG^3011102.1204^^798.7^^@^3020404
"KRN",.401,1513,2,0)
^.4014^3^3
"KRN",.401,1513,2,1,0)
798.7^0^NUMBER^@^^^^^^2
"KRN",.401,1513,2,1,"IX")
^RORDATA(798.7,^RORDATA(798.7,^1
"KRN",.401,1513,2,1,"QCON")
I D0'=""
"KRN",.401,1513,2,1,"SER")
0^0
"KRN",.401,1513,2,1,"TXT")
NUMBER not null
"KRN",.401,1513,2,2,0)
798.7^.01^START DATE/TIME^^;S1;"LOG DATE/TIME: "^^^^^1
"KRN",.401,1513,2,2,"ASK")
1
"KRN",.401,1513,2,2,"GET")
S DISX(2)=$P($G(^RORDATA(798.7,D0,0)),U)
"KRN",.401,1513,2,2,"IX")
^RORDATA(798.7,"B",^RORDATA(798.7,^2
"KRN",.401,1513,2,2,"QCON")
I DISX(2)'=""
"KRN",.401,1513,2,2,"SER")
0^0
"KRN",.401,1513,2,2,"TXT")
START DATE/TIME not null
"KRN",.401,1513,2,3,0)
798.74^.01^DATE/TIME^^^^^^^1
"KRN",.401,1513,2,3,1,0)
^.40141^1^1
"KRN",.401,1513,2,3,1,1,0)
798.7^2
"KRN",.401,1513,2,3,1,"B",798.7,1)

"KRN",.401,1513,2,3,"GET")
S DISX(3)=$P($G(^RORDATA(798.7,D0,2,D1,0)),U)
"KRN",.401,1513,2,3,"QCON")
I DISX(3)'=""
"KRN",.401,1513,2,3,"TXT")
DATE/TIME not null
"KRN",.401,1513,2,"B",798.7,1)

"KRN",.401,1513,2,"B",798.7,2)

"KRN",.401,1513,2,"B",798.74,3)

"KRN",.401,1513,"%D",0)
^.4012^2^2^3020403^^
"KRN",.401,1513,"%D",1,0)
This template is used by the [RORMNT PRINT LOGS] option to print 
"KRN",.401,1513,"%D",2,0)
messages from the log files.
"KRN",.401,1513,"DIPT")
ROR LOG
"KRN",.401,1518,-1)
0^1
"KRN",.401,1518,0)
ROR DATA ELEMENTS^3020404.1303^^799.2^^@^3020405
"KRN",.401,1518,2,0)
^.4014^1^1
"KRN",.401,1518,2,1,0)
799.22^.02^CODE^^^^^^^2
"KRN",.401,1518,2,1,1,0)
^.40141^1^1
"KRN",.401,1518,2,1,1,1,0)
799.2^2
"KRN",.401,1518,2,1,1,"B",799.2,1)

"KRN",.401,1518,2,1,"GET")
S DISX(1)=$P($G(^ROR(799.2,D0,2,D1,0)),U,2) S:DISX(1)]"" DISX(1)=+DISX(1)
"KRN",.401,1518,2,1,"IX")
^ROR(799.2,"DEC",^ROR(799.2,^2
"KRN",.401,1518,2,1,"QCON")
I DISX(1)'=""
"KRN",.401,1518,2,1,"TXT")
CODE not null
"KRN",.401,1518,2,"B",799.22,1)

"KRN",.401,1518,"DIPT")
ROR DATA ELEMENTS
"KRN",.402,2098,-1)
0^3
"KRN",.402,2098,0)
RORMNT AWAITING ACK^3020401.1016^^798.1^^@^3020401
"KRN",.402,2098,"%D",0)
^^2^2^3020403^
"KRN",.402,2098,"%D",1,0)
This template is used by the [RORMNT AWAITING ACK] menu option to
"KRN",.402,2098,"%D",2,0)
edit the AWAITING ACKNOWLEDGEMENT flag.
"KRN",.402,2098,"DR",1,798.1)
2.2;
"KRN",.402,2099,-1)
0^5
"KRN",.402,2099,0)
RORMNT EDIT REG PARAMS^3020418.0932^^798.1^^@^3020507
"KRN",.402,2099,"%D",0)
^.4021^2^2^3020418^^
"KRN",.402,2099,"%D",1,0)
This template is used by the [RORMNT EDIT REG PARAMS] menu option to
"KRN",.402,2099,"%D",2,0)
review/edit the registry parameters.
"KRN",.402,2099,"DIAB",1,1,798.11,0)
ALL
"KRN",.402,2099,"DIAB",1,1,798.114,0)
ALL
"KRN",.402,2099,"DR",1,798.1)
1;2;7;8;8.1;11;14;15.1;15.9;25;
"KRN",.402,2099,"DR",2,798.11)
.01
"KRN",.402,2099,"DR",2,798.114)
.01
"KRN",.402,2100,-1)
0^1
"KRN",.402,2100,0)
RORHDT EDIT PARAMS^3011108.1515^^798.1^^@^3020419
"KRN",.402,2100,"%D",0)
^^2^2^3020403^
"KRN",.402,2100,"%D",1,0)
This template is used by the [RORHDT EDIT REGISTRY] menu option to
"KRN",.402,2100,"%D",2,0)
edit parameters of the registry historical data extraction.
"KRN",.402,2100,"DIAB",1,0,798.1,0)
21.03;"Output Directory";REQ
"KRN",.402,2100,"DIAB",2,0,798.1,0)
21.01;"Start Date";REQ
"KRN",.402,2100,"DIAB",3,0,798.1,0)
21.02;"End Date";REQ
"KRN",.402,2100,"DR",1,798.1)
21.03R~Output Directory~;21.01R~Start Date~;21.02R~End Date~;
"KRN",.402,2101,-1)
0^2
"KRN",.402,2101,0)
RORHDT EDIT TASK^3011108.1519^^798.5^^@^3020325
"KRN",.402,2101,"%D",0)
^^2^2^3020403^
"KRN",.402,2101,"%D",1,0)
This template is used by the [RORHDT EDIT TASK] menu option to edit 
"KRN",.402,2101,"%D",2,0)
parameters of the historical data extraction tasks.
"KRN",.402,2101,"DIAB",1,0,798.5,0)
FILE NAME;"Output File Name";REQ
"KRN",.402,2101,"DIAB",2,0,798.5,0)
NEXT RECORD;"Next Record to Process"
"KRN",.402,2101,"DR",1,798.5)
1.01R~Output File Name~;4Next Record to Process~;
"KRN",.402,2102,-1)
0^4
"KRN",.402,2102,0)
RORMNT EDIT LAB SEARCH^3020305.102^^798.9^^@^3020311
"KRN",.402,2102,"DR",1,798.9)
2;1;
"KRN",.402,2102,"DR",2,798.92)
.01;1;2;
"KRN",19,11319,-1)
0^1
"KRN",19,11319,0)
ROR GUI MENU^Hepatitis C Registry GUI Menu^^B^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11319,1,0)
^19.06^2^2^3011016^^
"KRN",19,11319,1,1,0)
This option holds the references to the package RPC Broker Calls used by
"KRN",19,11319,1,2,0)
the GUI to create an application context (for security purposes).
"KRN",19,11319,99.1)
58933,40931
"KRN",19,11319,200.9)
^y
"KRN",19,11319,"RPC",0)
^19.05P^28^28
"KRN",19,11319,"RPC",1,0)
ROR ACTIVATE INACTIVATE
"KRN",19,11319,"RPC",2,0)
ROR ACTIVATE PATIENT GET
"KRN",19,11319,"RPC",3,0)
ROR EDIT PATIENT GET
"KRN",19,11319,"RPC",4,0)
ROR ENTER EDIT PATIENT
"KRN",19,11319,"RPC",5,0)
ROR IDRUGS PATIENT SET
"KRN",19,11319,"RPC",6,0)
ROR PATIENT SEARCH
"KRN",19,11319,"RPC",7,0)
ROR REG PARAMS GET
"KRN",19,11319,"RPC",8,0)
ROR REPORT
"KRN",19,11319,"RPC",10,0)
XWB GET VARIABLE VALUE
"KRN",19,11319,"RPC",11,0)
ROR ACTIVITY DETAILS
"KRN",19,11319,"RPC",12,0)
ROR ACTIVITY LOG
"KRN",19,11319,"RPC",13,0)
ROR INV DRUGS
"KRN",19,11319,"RPC",14,0)
ROR LOG MESSAGE DETAILS
"KRN",19,11319,"RPC",15,0)
ROR PATIENT CHECKS
"KRN",19,11319,"RPC",16,0)
XUS GET USER INFO
"KRN",19,11319,"RPC",17,0)
XUS KEY CHECK
"KRN",19,11319,"RPC",18,0)
ROR DRUG REPORT
"KRN",19,11319,"RPC",19,0)
XWB DEFERRED RPC
"KRN",19,11319,"RPC",20,0)
XWB DEFERRED CLEAR
"KRN",19,11319,"RPC",21,0)
XWB DEFERRED STATUS
"KRN",19,11319,"RPC",22,0)
XWB DEFERRED GETDATA
"KRN",19,11319,"RPC",23,0)
ROR STORE RPC HANDLE
"KRN",19,11319,"RPC",24,0)
ROR GET RPC HANDLE
"KRN",19,11319,"RPC",25,0)
ROR GET CODE LIST
"KRN",19,11319,"RPC",26,0)
ROR GET GUI PARAMS
"KRN",19,11319,"RPC",27,0)
ROR SET GUI PARAMS
"KRN",19,11319,"RPC",28,0)
ROR CLEAR RPC HANDLE
"KRN",19,11319,"U")
HEPATITIS C REGISTRY GUI MENU
"KRN",19,11321,-1)
0^9
"KRN",19,11321,0)
RORHDT MAIN^Historical Data Extraction^^M^^^^^^^^CLINICAL CASE REGISTRIES^^1^1
"KRN",19,11321,1,0)
^^16^16^3011214^
"KRN",19,11321,1,1,0)
 
"KRN",19,11321,1,2,0)
This is a top level management option for the historical data extraction
"KRN",19,11321,1,3,0)
that gathers historical data for each registry patient that exists on the
"KRN",19,11321,1,4,0)
'ROR REGISTRY' file and creates flat text files that can be FTP'd to a
"KRN",19,11321,1,5,0)
pre-defined area at the AAC. This is done independently of daily updates
"KRN",19,11321,1,6,0)
and extracts and requires some intervention of an IRM.
"KRN",19,11321,1,7,0)
 
"KRN",19,11321,1,8,0)
Each data extraction task will get the historical data patient by patient
"KRN",19,11321,1,9,0)
and write it to a flat text file in HL7 format. If any data errors are
"KRN",19,11321,1,10,0)
found they will be reported on log file, the task will then continue onto
"KRN",19,11321,1,11,0)
the next patient on the registry.
"KRN",19,11321,1,12,0)
 
"KRN",19,11321,1,13,0)
IRM's can check the status of the task using this user interface and view
"KRN",19,11321,1,14,0)
the log file if any errors have been found.  The log will provide enough
"KRN",19,11321,1,15,0)
information for the IRM to fix the errors.  After errors are fixed the 
"KRN",19,11321,1,16,0)
task can be re-started via this interface.
"KRN",19,11321,10,0)
^19.01IP^6^6
"KRN",19,11321,10,1,0)
11322^DS^10
"KRN",19,11321,10,1,"^")
RORHDT STATUS
"KRN",19,11321,10,3,0)
11324^ST^20
"KRN",19,11321,10,3,"^")
RORHDT START
"KRN",19,11321,10,4,0)
11325^TT^25
"KRN",19,11321,10,4,"^")
RORHDT STOP
"KRN",19,11321,10,5,0)
11326^ED^15
"KRN",19,11321,10,5,"^")
RORHDT EDIT
"KRN",19,11321,10,6,0)
11328^DL^30
"KRN",19,11321,10,6,"^")
RORHDT LOG
"KRN",19,11321,15)
K RORHDT
"KRN",19,11321,20)
K RORHDT
"KRN",19,11321,99)
58906,56464
"KRN",19,11321,200.9)
^y
"KRN",19,11321,"U")
HISTORICAL DATA EXTRACTION
"KRN",19,11322,-1)
0^11
"KRN",19,11322,0)
RORHDT STATUS^Display Extraction Status^^R^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11322,1,0)
^^17^17^3011214^
"KRN",19,11322,1,1,0)
 
"KRN",19,11322,1,2,0)
This option displays the extraction status of a selected registry. The 
"KRN",19,11322,1,3,0)
historical data extraction start and end dates, the output directory name,
"KRN",19,11322,1,4,0)
and task table are displayed. For each task in the table the following
"KRN",19,11322,1,5,0)
information is displayed:
"KRN",19,11322,1,6,0)
 
"KRN",19,11322,1,7,0)
Start IEN: IEN within the local registry from which the extraction will 
"KRN",19,11322,1,8,0)
start.  The task processes registry records from this IEN up until the 
"KRN",19,11322,1,9,0)
'Start IEN' of the next transfer task.
"KRN",19,11322,1,10,0)
 
"KRN",19,11322,1,11,0)
File name: Unique name based on site number and sequential number of the
"KRN",19,11322,1,12,0)
task.  This file will contain the extracted data when the task has run; it
"KRN",19,11322,1,13,0)
will reside in the designated output directory.
"KRN",19,11322,1,14,0)
 
"KRN",19,11322,1,15,0)
Task: Task number assigned by the Taskman for the data extraction task.
"KRN",19,11322,1,16,0)
 
"KRN",19,11322,1,17,0)
Status: Indicates the current status of the task.
"KRN",19,11322,25)
STATUS^RORHDT
"KRN",19,11322,99)
58659,36996
"KRN",19,11322,"U")
DISPLAY EXTRACTION STATUS
"KRN",19,11323,-1)
0^4
"KRN",19,11323,0)
RORHDT CREATE^Create Extraction Tasks^^R^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11323,1,0)
^19.06^8^8^3020423^^^
"KRN",19,11323,1,1,0)
 
"KRN",19,11323,1,2,0)
This option allows users to spread historical data processing over several
"KRN",19,11323,1,3,0)
tasks and thus avoid creating one large task that could use up too many 
"KRN",19,11323,1,4,0)
system resources by taking a long time to complete.
"KRN",19,11323,1,5,0)
 
"KRN",19,11323,1,6,0)
The option displays the amount of patients that reside in the registry.  
"KRN",19,11323,1,7,0)
Users have the option to spread the processing of all these patients over
"KRN",19,11323,1,8,0)
up to twelve separate tasks.
"KRN",19,11323,25)
CREATE^RORHDT
"KRN",19,11323,99)
58659,37007
"KRN",19,11323,"U")
CREATE EXTRACTION TASKS
"KRN",19,11324,-1)
0^10
"KRN",19,11324,0)
RORHDT START^Start a Task^^R^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11324,1,0)
^^5^5^3011214^
"KRN",19,11324,1,1,0)
 
"KRN",19,11324,1,2,0)
This option displays data extraction tasks that were created with the
"KRN",19,11324,1,3,0)
'Create Extraction Tasks' option. Users can select a task and enter a date
"KRN",19,11324,1,4,0)
and time that they want the task to run. This option can be re-entered to
"KRN",19,11324,1,5,0)
re-schedule a previously scheduled task.
"KRN",19,11324,25)
START^RORHDT
"KRN",19,11324,"U")
START A TASK
"KRN",19,11325,-1)
0^12
"KRN",19,11325,0)
RORHDT STOP^Stop a Task^^R^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11325,1,0)
^19.06^3^3^3011214^^
"KRN",19,11325,1,1,0)
 
"KRN",19,11325,1,2,0)
This option allows users to stop a running task or de-queue a task that 
"KRN",19,11325,1,3,0)
is scheduled to run in the future.
"KRN",19,11325,25)
STOP^RORHDT
"KRN",19,11325,"U")
STOP A TASK
"KRN",19,11326,-1)
0^5
"KRN",19,11326,0)
RORHDT EDIT^Edit^^M^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11326,1,0)
^19.06^4^4^3011214^^^^
"KRN",19,11326,1,1,0)
 
"KRN",19,11326,1,2,0)
This option displays a submenu when selected. The submenu contains options
"KRN",19,11326,1,3,0)
that are used to create and edit the parameters of the historical data
"KRN",19,11326,1,4,0)
extraction.
"KRN",19,11326,10,0)
^19.01IP^3^3
"KRN",19,11326,10,1,0)
11323^CT^10
"KRN",19,11326,10,1,"^")
RORHDT CREATE
"KRN",19,11326,10,2,0)
11327^ER^15
"KRN",19,11326,10,2,"^")
RORHDT EDIT REGISTRY
"KRN",19,11326,10,3,0)
11370^ET^20
"KRN",19,11326,10,3,"^")
RORHDT EDIT TASK
"KRN",19,11326,99)
58906,56464
"KRN",19,11326,"U")
EDIT
"KRN",19,11327,-1)
0^6
"KRN",19,11327,0)
RORHDT EDIT REGISTRY^Edit Registry Descriptor^^E^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11327,1,0)
^19.06^9^9^3020429^^^
"KRN",19,11327,1,1,0)
 
"KRN",19,11327,1,2,0)
This option allows users to edit parameters of historical data extraction
"KRN",19,11327,1,3,0)
in the 'ROR REGISTRY PARAMETERS' file.
"KRN",19,11327,1,4,0)
 
"KRN",19,11327,1,5,0)
IRM's should predominately use this option to enter details of the
"KRN",19,11327,1,6,0)
required output directory, it is not encouraged to edit any of the other
"KRN",19,11327,1,7,0)
fields as they will either be automatically populated during the install
"KRN",19,11327,1,8,0)
of the KIDS build or via the other options within this historical data
"KRN",19,11327,1,9,0)
extraction interface.
"KRN",19,11327,30)
ROR(798.1,
"KRN",19,11327,31)
AEMQ
"KRN",19,11327,50)
ROR(798.1,
"KRN",19,11327,51)
[RORHDT EDIT PARAMS]
"KRN",19,11327,"U")
EDIT REGISTRY DESCRIPTOR
"KRN",19,11328,-1)
0^8
"KRN",19,11328,0)
RORHDT LOG^Display Task Log^^R^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11328,1,0)
^19.06^4^4^3011214^^
"KRN",19,11328,1,1,0)
 
"KRN",19,11328,1,2,0)
The 'Display Task Log' option lets users see a log of any running/finished
"KRN",19,11328,1,3,0)
data extraction task. If any errors have been found, they would be logged
"KRN",19,11328,1,4,0)
here. Any errors should be fixed and then the task re-started.
"KRN",19,11328,25)
LOG^RORHDT
"KRN",19,11328,"U")
DISPLAY TASK LOG
"KRN",19,11336,-1)
0^3
"KRN",19,11336,0)
ROR TASK^Registry Update & Data Extraction^^R^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11336,1,0)
^^35^35^3020424^
"KRN",19,11336,1,1,0)
 
"KRN",19,11336,1,2,0)
This option starts the registry update and data extraction task that
"KRN",19,11336,1,3,0)
processes registries defined by the TASK PARAMETERS field. The field must
"KRN",19,11336,1,4,0)
contain a list of registry names separated by commas.
"KRN",19,11336,1,5,0)
 
"KRN",19,11336,1,6,0)
The following task parameters are optional. They can be defined on the
"KRN",19,11336,1,7,0)
second page of the option scheduling form (as the pairs of the variable 
"KRN",19,11336,1,8,0)
names and values).
"KRN",19,11336,1,9,0)
 
"KRN",19,11336,1,10,0)
RORFLCLR, RORFLSET (Default: "")
"KRN",19,11336,1,11,0)
 
"KRN",19,11336,1,12,0)
These two parameters override the values of the flags that control the 
"KRN",19,11336,1,13,0)
processing. Add the flags to the RORFLCLR variable to clear them and to
"KRN",19,11336,1,14,0)
the RORFLSET variable to set them. Below are the possible values of the 
"KRN",19,11336,1,15,0)
parameters (can be combined):
"KRN",19,11336,1,16,0)
 
"KRN",19,11336,1,17,0)
  "E" - Use the event references (file #798.3)
"KRN",19,11336,1,18,0)
 
"KRN",19,11336,1,19,0)
RORMNTSK (Default: "2-3-AUTO")
"KRN",19,11336,1,20,0)
 
"KRN",19,11336,1,21,0)
Maximum number of the registry update subtasks. If this parameter is less
"KRN",19,11336,1,22,0)
than 2, all patients will be processed by the single main task. Otherwise,
"KRN",19,11336,1,23,0)
all patients can be distributed among several subtasks.
"KRN",19,11336,1,24,0)
 
"KRN",19,11336,1,25,0)
If "N-M-AUTO" is passed as the value of this parameter and difference
"KRN",19,11336,1,26,0)
between the end and start dates of the registry update is more than M days
"KRN",19,11336,1,27,0)
then N subtasks will be started. Otherwise, the single task will run.
"KRN",19,11336,1,28,0)
 
"KRN",19,11336,1,29,0)
RORSUSP (Default: "")
"KRN",19,11336,1,30,0)
 
"KRN",19,11336,1,31,0)
Suspension parameters of the registry update subtasks. The subtasks are
"KRN",19,11336,1,32,0)
not suspended by default. Parameter should contain start and end times of
"KRN",19,11336,1,33,0)
the suspension (in external format) separated by the "-". For example, the
"KRN",19,11336,1,34,0)
"7:00-18:00" value will suspend the subtasks from 7am until 6pm each day
"KRN",19,11336,1,35,0)
except weekends and holidays.
"KRN",19,11336,2)
n
"KRN",19,11336,25)
TASK^ROR
"KRN",19,11336,200.9)
y^y
"KRN",19,11336,"U")
REGISTRY UPDATE & DATA EXTRACT
"KRN",19,11363,-1)
0^16
"KRN",19,11363,0)
RORMNT MAIN^Clinical Case Registries Maintenance^^M^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11363,1,0)
^19.06^3^3^3011114^^^^
"KRN",19,11363,1,1,0)
 
"KRN",19,11363,1,2,0)
This menu contains miscellaneous maintenance options for the Clinical 
"KRN",19,11363,1,3,0)
Registries package. Usually, they should be used only for troubleshooting.
"KRN",19,11363,10,0)
^19.01IP^4^4
"KRN",19,11363,10,1,0)
11364^PLF
"KRN",19,11363,10,1,"^")
RORMNT PRINT LOGS
"KRN",19,11363,10,2,0)
11365^EAA
"KRN",19,11363,10,2,"^")
RORMNT AWAITING ACK
"KRN",19,11363,10,3,0)
11366^ERP
"KRN",19,11363,10,3,"^")
RORMNT EDIT REG PARAMS
"KRN",19,11363,10,4,0)
11372^ELS
"KRN",19,11363,10,4,"^")
RORMNT EDIT LAB SEARCH
"KRN",19,11363,99)
58906,56464
"KRN",19,11363,200.9)
^y
"KRN",19,11363,"U")
CLINICAL CASE REGISTRIES MAINT
"KRN",19,11364,-1)
0^17
"KRN",19,11364,0)
RORMNT PRINT LOGS^Print Log Files^^P^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11364,1,0)
^19.06^3^3^3011114^^
"KRN",19,11364,1,1,0)
 
"KRN",19,11364,1,2,0)
This option can be used to print messages recorded by different clinical 
"KRN",19,11364,1,3,0)
registries processes.
"KRN",19,11364,60)
RORDATA(798.7,
"KRN",19,11364,62)
0
"KRN",19,11364,63)
[ROR LOG]
"KRN",19,11364,64)
[ROR LOG]
"KRN",19,11364,65)

"KRN",19,11364,66)

"KRN",19,11364,"U")
PRINT LOG FILES
"KRN",19,11365,-1)
0^13
"KRN",19,11365,0)
RORMNT AWAITING ACK^Edit 'Awaiting ACK' flag^^E^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11365,1,0)
^19.06^7^7^3011114^^
"KRN",19,11365,1,1,0)
 
"KRN",19,11365,1,2,0)
This option can be used for editing the 'AWAITING ACKNOWLEDGEMENT' field
"KRN",19,11365,1,3,0)
in the 'REGISTRY PARAMETERS' file.
"KRN",19,11365,1,4,0)
 
"KRN",19,11365,1,5,0)
If you are absolutely sure that there will be no acknowledgement from the
"KRN",19,11365,1,6,0)
AAC (for example, due a past malfunction), you can delete the value of
"KRN",19,11365,1,7,0)
the field to resume regular data transmissions.
"KRN",19,11365,30)
ROR(798.1,
"KRN",19,11365,31)
AEMQ
"KRN",19,11365,50)
ROR(798.1,
"KRN",19,11365,51)
[RORMNT AWAITING ACK]
"KRN",19,11365,"U")
EDIT 'AWAITING ACK' FLAG
"KRN",19,11366,-1)
0^15
"KRN",19,11366,0)
RORMNT EDIT REG PARAMS^Edit Registry Parameters^^E^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11366,1,0)
^19.06^3^3^3011114^^
"KRN",19,11366,1,1,0)
 
"KRN",19,11366,1,2,0)
This option can be used to edit registry parameters in the 'ROR REGISTRY 
"KRN",19,11366,1,3,0)
PARAMETERS' file.
"KRN",19,11366,30)
ROR(798.1,
"KRN",19,11366,31)
AEMQ
"KRN",19,11366,50)
ROR(798.1,
"KRN",19,11366,51)
[RORMNT EDIT REG PARAMS]
"KRN",19,11366,"U")
EDIT REGISTRY PARAMETERS
"KRN",19,11370,-1)
0^7
"KRN",19,11370,0)
RORHDT EDIT TASK^Edit Task Descriptor^^E^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11370,1,0)
^19.06^3^3^3011214^^
"KRN",19,11370,1,1,0)
 
"KRN",19,11370,1,2,0)
This option allows users to edit parameters of historical data extraction
"KRN",19,11370,1,3,0)
tasks in the 'ROR HDT TASK' file.
"KRN",19,11370,30)
RORDATA(798.5,
"KRN",19,11370,31)
AEMQ
"KRN",19,11370,50)
RORDATA(798.5,
"KRN",19,11370,51)
[RORHDT EDIT TASK]
"KRN",19,11370,"U")
EDIT TASK DESCRIPTOR
"KRN",19,11372,-1)
0^14
"KRN",19,11372,0)
RORMNT EDIT LAB SEARCH^Edit Lab Search Criteria^^E^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11372,30)
ROR(798.9,
"KRN",19,11372,31)
AEMQ
"KRN",19,11372,50)
ROR(798.9,
"KRN",19,11372,51)
[RORMNT EDIT LAB SEARCH]
"KRN",19,11372,"U")
EDIT LAB SEARCH CRITERIA
"KRN",19,11483,-1)
0^2
"KRN",19,11483,0)
ROR SETUP HEPC^HepC Registry Setup^^R^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11483,1,0)
^^4^4^3020426^
"KRN",19,11483,1,1,0)
 
"KRN",19,11483,1,2,0)
This option allows the user to enter parameters of the registry 
"KRN",19,11483,1,3,0)
setup process and schedule the task that will populate the HepC 
"KRN",19,11483,1,4,0)
registry.
"KRN",19,11483,2)
y
"KRN",19,11483,25)
RORSET01
"KRN",19,11483,200.9)
n^y
"KRN",19,11483,"U")
HEPC REGISTRY SETUP
"KRN",19.1,414,-1)
0^1
"KRN",19.1,414,0)
ROR VA HEPC ADMIN^Clinical Registries Admin^l
"KRN",19.1,414,1,0)
^^1^1^3011005^
"KRN",19.1,414,1,1,0)
Clinical Registries Administrator
"KRN",19.1,415,-1)
0^2
"KRN",19.1,415,0)
ROR VA HEPC USER^Clinical Registries User^l
"KRN",19.1,415,1,0)
^^1^1^3011005^
"KRN",19.1,415,1,1,0)
Clinical Registries User
"KRN",101,1074,-1)
2^8
"KRN",101,1074,0)
DGPM MOVEMENT EVENTS^MOVEMENT EVENTS v 5.0^^X^1901^^^^^^^3
"KRN",101,1074,10,0)
^101.01PA^36^36
"KRN",101,1074,10,36,0)
5279^^^
"KRN",101,1074,10,36,"^")
ROR EVENT PTF
"KRN",101,2559,-1)
2^5
"KRN",101,2559,0)
PXK VISIT DATA EVENT^VISIT RELATED DATA^^X^1901^^^^^^^
"KRN",101,2559,10,-1,0)
^
"KRN",101,2559,10,0)
^101.01PA^4^4
"KRN",101,2559,10,4,0)
5278^^^
"KRN",101,2559,10,4,"^")
ROR EVENT VISIT
"KRN",101,3446,-1)
2^3
"KRN",101,3446,0)
LR7O ALL EVSEND RESULTS^LAB RESULTS => EXTERNAL PACKAGE^^X^222222227^^^^^^^
"KRN",101,3446,10,0)
^101.01PA^1^1
"KRN",101,3446,10,1,0)
5276^^^
"KRN",101,3446,10,1,"^")
ROR EVENT LAB
"KRN",101,5274,-1)
0^1
"KRN",101,5274,0)
ROR-SITE-DRIVER^Clinical Registries Client^^E^^^^^^^^
"KRN",101,5274,99)
58906,56461
"KRN",101,5274,770)
ROR SITE^^CSU^C09^25^^^AL^AL^2.3.1^
"KRN",101,5274,772)
D PROCESS^RORACK
"KRN",101,5274,775,0)
^101.0775PA^2^1
"KRN",101,5274,775,2,0)
5275
"KRN",101,5274,775,2,"^")
ROR-SITE-SUBSCRIBER
"KRN",101,5275,-1)
0^2
"KRN",101,5275,0)
ROR-SITE-SUBSCRIBER^Clinical Registries Server^^S^^^^^^^^
"KRN",101,5275,99)
58906,56461
"KRN",101,5275,770)
^ROR AAC^^C09^^^ROR SEND^^^^ACK
"KRN",101,5275,771)

"KRN",101,5275,773)
1^0^0
"KRN",101,5276,-1)
0^4
"KRN",101,5276,0)
ROR EVENT LAB^LAB RESULTS => ROR PENDING PATIENT^^A^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",101,5276,1,0)
^^12^12^3020418^
"KRN",101,5276,1,1,0)
This protocol is used by the Clinical Case Registries package to
"KRN",101,5276,1,2,0)
maintain references to patients who have lab results. The protocol 
"KRN",101,5276,1,3,0)
should be subscribed to the LR7O ALL EVSEND RESULTS protocol (this is
"KRN",101,5276,1,4,0)
done by the KIDS during the installation).
"KRN",101,5276,1,5,0)
 
"KRN",101,5276,1,6,0)
If at least one of the defined registries enables event protocols,
"KRN",101,5276,1,7,0)
this protocol will process the Lab events and create references in
"KRN",101,5276,1,8,0)
the ROR PENDING PATIENT file (#798.3).
"KRN",101,5276,1,9,0)
                                 
"KRN",101,5276,1,10,0)
Otherwise, the protocol will be executed (if it is not disabled or
"KRN",101,5276,1,11,0)
unsubscribed manually) but will not call the processing routine 
"KRN",101,5276,1,12,0)
(LAB^ROREVT01).
"KRN",101,5276,20)
D:$D(^ROR(798.1,"AEP"))>1 LAB^ROREVT01
"KRN",101,5276,99)
58912,35191
"KRN",101,5278,-1)
0^6
"KRN",101,5278,0)
ROR EVENT VISIT^VISIT DATA => ROR PENDING PATIENT^^A^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",101,5278,1,0)
^^13^13^3020418^
"KRN",101,5278,1,1,0)
This protocol is used by the Clinical Case Registries package to 
"KRN",101,5278,1,2,0)
maintain references to patients who have new data in the V-files
"KRN",101,5278,1,3,0)
(VISIT, V POV, etc). The protocol should be subscribed to the PXK
"KRN",101,5278,1,4,0)
VISIT DATA EVENT protocol (this is done by the KIDS during the
"KRN",101,5278,1,5,0)
installation).
"KRN",101,5278,1,6,0)
 
"KRN",101,5278,1,7,0)
If at least one of the defined registries enables event protocols,
"KRN",101,5278,1,8,0)
this protocol will process the Lab events and create references in
"KRN",101,5278,1,9,0)
the ROR PENDING PATIENT file (#798.3).
"KRN",101,5278,1,10,0)
                                 
"KRN",101,5278,1,11,0)
Otherwise, the protocol will be executed (if it is not disabled or
"KRN",101,5278,1,12,0)
unsubscribed manually) but will not call the processing routine 
"KRN",101,5278,1,13,0)
(VISIT^ROREVT01).
"KRN",101,5278,20)
D:$D(^ROR(798.1,"AEP"))>1 VISIT^ROREVT01
"KRN",101,5278,99)
58912,43186
"KRN",101,5279,-1)
0^7
"KRN",101,5279,0)
ROR EVENT PTF^ADMISSION DATA => ROR PENDING PATIENT^^A^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",101,5279,1,0)
^^12^12^3020418^
"KRN",101,5279,1,1,0)
This protocol is used by the Clinical Case Registries package to 
"KRN",101,5279,1,2,0)
maintain references to patients who have new admissions. The protocol
"KRN",101,5279,1,3,0)
should be subscribed to the DGPM MOVEMENT EVENT protocol (this is
"KRN",101,5279,1,4,0)
done by the KIDS during the installation).
"KRN",101,5279,1,5,0)
 
"KRN",101,5279,1,6,0)
If at least one of the defined registries enables event protocols,
"KRN",101,5279,1,7,0)
this protocol will process the Lab events and create references in
"KRN",101,5279,1,8,0)
the ROR PENDING PATIENT file (#798.3).
"KRN",101,5279,1,9,0)
                                 
"KRN",101,5279,1,10,0)
Otherwise, the protocol will be executed (if it is not disabled or
"KRN",101,5279,1,11,0)
unsubscribed manually) but will not call the processing routine 
"KRN",101,5279,1,12,0)
(PTF^ROREVT01).
"KRN",101,5279,20)
D:$D(^ROR(798.1,"AEP"))>1 PTF^ROREVT01
"KRN",101,5279,99)
58912,47449
"KRN",771,58,-1)
0^2
"KRN",771,58,0)
ROR SITE^a^^^^^US
"KRN",771,58,"EC")
^~\&
"KRN",771,58,"FS")
|
"KRN",771,59,-1)
0^1
"KRN",771,59,0)
ROR AAC^a^^^^^US
"KRN",771,59,"EC")
^~\&
"KRN",771,59,"FS")
|
"KRN",870,35,-1)
0^2
"KRN",870,35,0)
ROR SEND^^TCP^^^^^^^^^^^^^^^^^^10
"KRN",870,35,200)
^^^30^180^^^^^
"KRN",870,35,400)
10.224.187.9^7000^C^^10^^
"KRN",870,52,-1)
1^3
"KRN",870,52,0)
ROR RECV
"KRN",8989.51,4751,-1)
0^1
"KRN",8989.51,4751,0)
ROR VA HEPC GUI SETTINGS^VA HEPC GUI SETTINGS^1^Name (Form.Control)^Settings^1
"KRN",8989.51,4751,1)
F
"KRN",8989.51,4751,6)
F
"KRN",8989.51,4751,30,0)
^8989.513I^3^3
"KRN",8989.51,4751,30,1,0)
1^200
"KRN",8989.51,4751,30,2,0)
2^4
"KRN",8989.51,4751,30,3,0)
3^9.4
"KRN",8994,1368,-1)
0^7
"KRN",8994,1368,0)
ROR EDIT PATIENT GET^EN1^RORRP2^2^A
"KRN",8994,1368,2,0)
^8994.02A^2^2
"KRN",8994,1368,2,1,0)
RORDPT^1^^1^1
"KRN",8994,1368,2,1,1,0)
^^1^1^3010703^
"KRN",8994,1368,2,1,1,1,0)
PATIENT IEN
"KRN",8994,1368,2,2,0)
RORREG^1^^1^2
"KRN",8994,1368,2,2,1,0)
^8994.021^1^1^3010706^^^
"KRN",8994,1368,2,2,1,1,0)
REGISTRY NAME
"KRN",8994,1368,2,"B","RORDPT",1)

"KRN",8994,1368,2,"B","RORREG",2)

"KRN",8994,1368,2,"PARAMSEQ",1,1)

"KRN",8994,1368,2,"PARAMSEQ",2,2)

"KRN",8994,1370,-1)
0^8
"KRN",8994,1370,0)
ROR ENTER EDIT PATIENT^SETDATA^RORRP1^1^A
"KRN",8994,1370,2,0)
^8994.02A^5^5
"KRN",8994,1370,2,1,0)
DFN^1^15^1^1
"KRN",8994,1370,2,2,0)
REGISTRY^1^15^1^2
"KRN",8994,1370,2,3,0)
EVIDENCE^1^1^1^3
"KRN",8994,1370,2,4,0)
IDRUGS^1^1^1^4
"KRN",8994,1370,2,5,0)
SELECT^2^40^0^5
"KRN",8994,1370,2,"B","DFN",1)

"KRN",8994,1370,2,"B","EVIDENCE",3)

"KRN",8994,1370,2,"B","IDRUGS",4)

"KRN",8994,1370,2,"B","REGISTRY",2)

"KRN",8994,1370,2,"B","SELECT",5)

"KRN",8994,1370,2,"PARAMSEQ",1,1)

"KRN",8994,1370,2,"PARAMSEQ",2,2)

"KRN",8994,1370,2,"PARAMSEQ",3,3)

"KRN",8994,1370,2,"PARAMSEQ",4,4)

"KRN",8994,1370,2,"PARAMSEQ",5,5)

"KRN",8994,1397,-1)
0^2
"KRN",8994,1397,0)
ROR ACTIVATE PATIENT GET^EN2^RORRP2^2^A
"KRN",8994,1397,2,0)
^8994.02A^2^2
"KRN",8994,1397,2,1,0)
RORDPT^1^^1^1
"KRN",8994,1397,2,1,1,0)
^^1^1^3010706^
"KRN",8994,1397,2,1,1,1,0)
File #798.4 IEN
"KRN",8994,1397,2,2,0)
RORREG^1^^1^2
"KRN",8994,1397,2,2,1,0)
^^1^1^3010706^
"KRN",8994,1397,2,2,1,1,0)
REGISTRY NAME
"KRN",8994,1397,2,"B","RORDPT",1)

"KRN",8994,1397,2,"B","RORREG",2)

"KRN",8994,1397,2,"PARAMSEQ",1,1)

"KRN",8994,1397,2,"PARAMSEQ",2,2)

"KRN",8994,1397,3,0)
^^4^4^3010706^
"KRN",8994,1397,3,1,0)
RES(1)   = 0 if not on Local Registry, else IEN (File#798)
"KRN",8994,1397,3,2,0)
RES(2)   = Date of death in File 2 ^ in File 798.4
"KRN",8994,1397,3,3,0)
RES(3)   = Inactivation Date^Reason^Reactivation Date
"KRN",8994,1397,3,4,0)
RES(4-n) = Selection Rule(s) (File#798 Field#3.1)
"KRN",8994,1398,-1)
0^1
"KRN",8994,1398,0)
ROR ACTIVATE INACTIVATE^UPDATE^RORRP3^1^A
"KRN",8994,1398,2,0)
^8994.02A^5^5
"KRN",8994,1398,2,1,0)
DFN^1^10^1^1
"KRN",8994,1398,2,2,0)
REGISTRY^1^10^1^2
"KRN",8994,1398,2,3,0)
MODE^1^1^1^3
"KRN",8994,1398,2,4,0)
REASON^1^1^0^4
"KRN",8994,1398,2,5,0)
DATE^1^^1^5
"KRN",8994,1398,2,5,1,0)
^8994.021^1^1^3010710^^
"KRN",8994,1398,2,5,1,1,0)
DATE TIME ACTIVATED/INACTIVATED
"KRN",8994,1398,2,"B","DATE",5)

"KRN",8994,1398,2,"B","DFN",1)

"KRN",8994,1398,2,"B","MODE",3)

"KRN",8994,1398,2,"B","REASON",4)

"KRN",8994,1398,2,"B","REGISTRY",2)

"KRN",8994,1398,2,"PARAMSEQ",1,1)

"KRN",8994,1398,2,"PARAMSEQ",2,2)

"KRN",8994,1398,2,"PARAMSEQ",3,3)

"KRN",8994,1398,2,"PARAMSEQ",4,4)

"KRN",8994,1398,2,"PARAMSEQ",5,5)

"KRN",8994,1399,-1)
0^19
"KRN",8994,1399,0)
ROR REPORT^GETDATA^RORRP4^4^A^^^1
"KRN",8994,1399,2,0)
^8994.02A^6^6
"KRN",8994,1399,2,1,0)
REGISTRY^1^10^1^1
"KRN",8994,1399,2,2,0)
START^1^10^0^2
"KRN",8994,1399,2,3,0)
END^1^10^0^3
"KRN",8994,1399,2,4,0)
MODE^1^1^0^4
"KRN",8994,1399,2,5,0)
SORTBY^1^2^1^5
"KRN",8994,1399,2,6,0)
FIELDS^1^15^1^6
"KRN",8994,1399,2,"B","END",3)

"KRN",8994,1399,2,"B","FIELDS",6)

"KRN",8994,1399,2,"B","MODE",4)

"KRN",8994,1399,2,"B","REGISTRY",1)

"KRN",8994,1399,2,"B","SORTBY",5)

"KRN",8994,1399,2,"B","START",2)

"KRN",8994,1399,2,"PARAMSEQ",1,1)

"KRN",8994,1399,2,"PARAMSEQ",2,2)

"KRN",8994,1399,2,"PARAMSEQ",3,3)

"KRN",8994,1399,2,"PARAMSEQ",4,4)

"KRN",8994,1399,2,"PARAMSEQ",5,5)

"KRN",8994,1399,2,"PARAMSEQ",6,6)

"KRN",8994,1400,-1)
0^18
"KRN",8994,1400,0)
ROR REG PARAMS GET^EN4^RORRP2^2^A
"KRN",8994,1400,1,0)
^^1^1^3010716^
"KRN",8994,1400,1,1,0)
Return Registry Parameters from File #798.1
"KRN",8994,1400,2,0)
^8994.02A^1^1
"KRN",8994,1400,2,1,0)
RORREG^1^^1^1
"KRN",8994,1400,2,1,1,0)
^^1^1^3010716^
"KRN",8994,1400,2,1,1,1,0)
Registry Name
"KRN",8994,1400,2,"B","RORREG",1)

"KRN",8994,1400,2,"PARAMSEQ",1,1)

"KRN",8994,1400,3,0)
^^6^6^3010716^
"KRN",8994,1400,3,1,0)
Return array:
"KRN",8994,1400,3,2,0)
 
"KRN",8994,1400,3,3,0)
RES(1): 0 if invalid Registry, else IEN (File#798.1)
"KRN",8994,1400,3,4,0)
RES(2): Short Description (Field # 4)
"KRN",8994,1400,3,5,0)
RES(3): Last Update Date (Field #1)
"KRN",8994,1400,3,6,0)
RES(4): Last Extract Date (Field #2)
"KRN",8994,1401,-1)
0^17
"KRN",8994,1401,0)
ROR PATIENT SEARCH^EN1^RORRP5^4^A^^^1
"KRN",8994,1401,1,0)
^^1^1^3010718^
"KRN",8994,1401,1,1,0)
Seach Patient File on Partial Match and return array of options
"KRN",8994,1401,2,0)
^8994.02A^5^5
"KRN",8994,1401,2,1,0)
RORREG^1^^1^1
"KRN",8994,1401,2,1,1,0)
^^1^1^3010718^
"KRN",8994,1401,2,1,1,1,0)
Registry Name
"KRN",8994,1401,2,2,0)
RORPART^1^^1^2
"KRN",8994,1401,2,2,1,0)
^^1^1^3010718^
"KRN",8994,1401,2,2,1,1,0)
Partial Match (Could be null string)
"KRN",8994,1401,2,3,0)
RORDIR^1^^1^3
"KRN",8994,1401,2,3,1,0)
^^1^1^3010718^
"KRN",8994,1401,2,3,1,1,0)
Direction to search (1=Forward, -1=Backward)
"KRN",8994,1401,2,4,0)
RORFILE^1^^1^4
"KRN",8994,1401,2,4,1,0)
^^1^1^3010718^
"KRN",8994,1401,2,4,1,1,0)
Patient File to Search. 2=PATIENT FILE, 798=ROR PATIENT FILE
"KRN",8994,1401,2,5,0)
RORSCRN^1^^^5
"KRN",8994,1401,2,5,1,0)
^^1^1^3010718^
"KRN",8994,1401,2,5,1,1,0)
Screen Date. If RORFILE=798, set screen date to screen on DATE ENTERED
"KRN",8994,1401,2,"B","RORDIR",3)

"KRN",8994,1401,2,"B","RORFILE",4)

"KRN",8994,1401,2,"B","RORPART",2)

"KRN",8994,1401,2,"B","RORREG",1)

"KRN",8994,1401,2,"B","RORSCRN",5)

"KRN",8994,1401,2,"PARAMSEQ",1,1)

"KRN",8994,1401,2,"PARAMSEQ",2,2)

"KRN",8994,1401,2,"PARAMSEQ",3,3)

"KRN",8994,1401,2,"PARAMSEQ",4,4)

"KRN",8994,1401,2,"PARAMSEQ",5,5)

"KRN",8994,1401,3,0)
^^1^1^3010912^
"KRN",8994,1401,3,1,0)
^TMP($J,"ROR-SEARCH",n)=NAME^SSN^DOB^IEN
"KRN",8994,1405,-1)
0^13
"KRN",8994,1405,0)
ROR IDRUGS PATIENT SET^EN3^RORRP2^1^A
"KRN",8994,1405,2,0)
^8994.02A^4^4
"KRN",8994,1405,2,1,0)
RORDPT^1^^1^1
"KRN",8994,1405,2,1,1,0)
^^1^1^3010803^
"KRN",8994,1405,2,1,1,1,0)
Patient IEN
"KRN",8994,1405,2,2,0)
RORREG^1^^1^2
"KRN",8994,1405,2,2,1,0)
^^1^1^3010803^
"KRN",8994,1405,2,2,1,1,0)
Registry Name
"KRN",8994,1405,2,3,0)
RORIDRUG^1^1^1^3
"KRN",8994,1405,2,3,1,0)
^^3^3^3010803^
"KRN",8994,1405,2,3,1,1,0)
Patient Receiving Investigational Drugs?
"KRN",8994,1405,2,3,1,2,0)
1 or Y = YES
"KRN",8994,1405,2,3,1,3,0)
0 or N = NO
"KRN",8994,1405,2,4,0)
RORPROF^1^1^0^4
"KRN",8994,1405,2,4,1,0)
^^4^4^3010803^
"KRN",8994,1405,2,4,1,1,0)
Is the investigational medication in patient profile?
"KRN",8994,1405,2,4,1,2,0)
1 or Y = YES
"KRN",8994,1405,2,4,1,3,0)
0 or N = NO
"KRN",8994,1405,2,4,1,4,0)
(Only required if RORIDRUG is set to YES)
"KRN",8994,1405,2,"B","RORDPT",1)

"KRN",8994,1405,2,"B","RORIDRUG",3)

"KRN",8994,1405,2,"B","RORPROF",4)

"KRN",8994,1405,2,"B","RORREG",2)

"KRN",8994,1405,2,"PARAMSEQ",1,1)

"KRN",8994,1405,2,"PARAMSEQ",2,2)

"KRN",8994,1405,2,"PARAMSEQ",3,3)

"KRN",8994,1405,2,"PARAMSEQ",4,4)

"KRN",8994,1405,3,0)
^^1^1^3010803^
"KRN",8994,1405,3,1,0)
1^Success or 0^Error description
"KRN",8994,1406,-1)
0^14
"KRN",8994,1406,0)
ROR INV DRUGS^DRUGS^RORRP6^4^A^^^1
"KRN",8994,1406,2,0)
^8994.02A^2^2
"KRN",8994,1406,2,1,0)
REG^1^10^1^1
"KRN",8994,1406,2,2,0)
DFN^1^20^1^2
"KRN",8994,1406,2,"B","DFN",2)

"KRN",8994,1406,2,"B","REG",1)

"KRN",8994,1406,2,"PARAMSEQ",1,1)

"KRN",8994,1406,2,"PARAMSEQ",2,2)

"KRN",8994,1413,-1)
0^4
"KRN",8994,1413,0)
ROR ACTIVITY LOG^EN1^RORRP7^4^A^^^1
"KRN",8994,1413,2,0)
^8994.02A^3^3
"KRN",8994,1413,2,1,0)
RORREG^1^^1^1
"KRN",8994,1413,2,2,0)
RORSTDT^1^^^2
"KRN",8994,1413,2,3,0)
RORENDT^1^^^3
"KRN",8994,1413,2,"B","RORENDT",3)

"KRN",8994,1413,2,"B","RORREG",1)

"KRN",8994,1413,2,"B","RORSTDT",2)

"KRN",8994,1413,2,"PARAMSEQ",1,1)

"KRN",8994,1413,2,"PARAMSEQ",2,2)

"KRN",8994,1413,2,"PARAMSEQ",3,3)

"KRN",8994,1414,-1)
0^16
"KRN",8994,1414,0)
ROR PATIENT CHECKS^RPC^RORRP8^4^A^^^1
"KRN",8994,1415,-1)
0^3
"KRN",8994,1415,0)
ROR ACTIVITY DETAILS^EN2^RORRP7^2^A^^^1
"KRN",8994,1415,2,0)
^8994.02A^1^1
"KRN",8994,1415,2,1,0)
RORIEN^1^^1^1
"KRN",8994,1415,2,"B","RORIEN",1)

"KRN",8994,1415,2,"PARAMSEQ",1,1)

"KRN",8994,1416,-1)
0^15
"KRN",8994,1416,0)
ROR LOG MESSAGE DETAILS^EN3^RORRP7^2^A^^^1
"KRN",8994,1416,2,0)
^8994.02A^1^1
"KRN",8994,1416,2,1,0)
RORIEN^1^^1^1
"KRN",8994,1416,2,"B","RORIEN",1)

"KRN",8994,1416,2,"PARAMSEQ",1,1)

"KRN",8994,1434,-1)
0^12
"KRN",8994,1434,0)
ROR GET USER NAME^GETNAME^RORRP9^1^A
"KRN",8994,1434,2,0)
^8994.02A^1^1
"KRN",8994,1434,2,1,0)
DUZ^1^^1^1
"KRN",8994,1434,2,"B","DUZ",1)

"KRN",8994,1434,2,"PARAMSEQ",1,1)

"KRN",8994,1435,-1)
0^6
"KRN",8994,1435,0)
ROR DRUG REPORT^EN1^RORRP9^4^^^^1
"KRN",8994,1435,2,0)
^8994.02A^3^3
"KRN",8994,1435,2,1,0)
RORSTDT^1^^1^2
"KRN",8994,1435,2,2,0)
RORENDT^1^^1^3
"KRN",8994,1435,2,3,0)
RORREG^1^^1^1
"KRN",8994,1435,2,"B","RORENDT",2)

"KRN",8994,1435,2,"B","RORREG",3)

"KRN",8994,1435,2,"B","RORSTDT",1)

"KRN",8994,1435,2,"PARAMSEQ",1,3)

"KRN",8994,1435,2,"PARAMSEQ",2,1)

"KRN",8994,1435,2,"PARAMSEQ",3,2)

"KRN",8994,1437,-1)
0^21
"KRN",8994,1437,0)
ROR STORE RPC HANDLE^EN2^RORRP9^2^A
"KRN",8994,1437,2,0)
^8994.02A^3^3
"KRN",8994,1437,2,1,0)
RORREG^1^^1^1
"KRN",8994,1437,2,2,0)
RORHNDL^1^^1^2
"KRN",8994,1437,2,3,0)
RORFLD^1^2^0^3
"KRN",8994,1437,2,3,1,0)
^^2^2^3011130^
"KRN",8994,1437,2,3,1,1,0)
Set to 16 if setting the Drug Report Handle, set to 18 if setting the 
"KRN",8994,1437,2,3,1,2,0)
Local Registry Report Handle
"KRN",8994,1437,2,"B","RORFLD",3)

"KRN",8994,1437,2,"B","RORHNDL",2)

"KRN",8994,1437,2,"B","RORREG",1)

"KRN",8994,1437,2,"PARAMSEQ",1,1)

"KRN",8994,1437,2,"PARAMSEQ",2,2)

"KRN",8994,1437,2,"PARAMSEQ",3,3)

"KRN",8994,1438,-1)
0^11
"KRN",8994,1438,0)
ROR GET RPC HANDLE^EN3^RORRP9^2^A
"KRN",8994,1438,2,0)
^8994.02A^2^2
"KRN",8994,1438,2,1,0)
RORREG^1^^1^1
"KRN",8994,1438,2,2,0)
RORFLD^1^2^0^2
"KRN",8994,1438,2,2,1,0)
^^2^2^3011130^
"KRN",8994,1438,2,2,1,1,0)
Set to 16 if searching for Drug Report Handle, set to 18 if searching for 
"KRN",8994,1438,2,2,1,2,0)
Local Registry Report Handle
"KRN",8994,1438,2,"B","RORFLD",2)

"KRN",8994,1438,2,"B","RORREG",1)

"KRN",8994,1438,2,"PARAMSEQ",1,1)

"KRN",8994,1438,2,"PARAMSEQ",2,2)

"KRN",8994,1439,-1)
0^9
"KRN",8994,1439,0)
ROR GET CODE LIST^EN5^RORRP2^2^A
"KRN",8994,1439,2,0)
^8994.02A^2^2
"KRN",8994,1439,2,1,0)
RORREG^1^^1^1
"KRN",8994,1439,2,2,0)
RORTYP^1^^1^2
"KRN",8994,1439,2,"B","RORREG",1)

"KRN",8994,1439,2,"B","RORTYP",2)

"KRN",8994,1439,2,"PARAMSEQ",1,1)

"KRN",8994,1439,2,"PARAMSEQ",2,2)

"KRN",8994,1445,-1)
0^10
"KRN",8994,1445,0)
ROR GET GUI PARAMS^GET^RORRP10^1^A
"KRN",8994,1445,2,0)
^8994.02A^2^2
"KRN",8994,1445,2,1,0)
RORREG^1^^1^1
"KRN",8994,1445,2,2,0)
RORINST^1^^1^2
"KRN",8994,1445,2,"B","RORINST",2)

"KRN",8994,1445,2,"B","RORREG",1)

"KRN",8994,1445,2,"PARAMSEQ",1,1)

"KRN",8994,1445,2,"PARAMSEQ",2,2)

"KRN",8994,1446,-1)
0^20
"KRN",8994,1446,0)
ROR SET GUI PARAMS^SET^RORRP10^1
"KRN",8994,1446,2,0)
^8994.02A^3^3
"KRN",8994,1446,2,1,0)
RORREG^1^^1^1
"KRN",8994,1446,2,2,0)
RORINST^1^^1^2
"KRN",8994,1446,2,3,0)
RORVAL^1^^1^3
"KRN",8994,1446,2,"B","RORINST",2)

"KRN",8994,1446,2,"B","RORREG",1)

"KRN",8994,1446,2,"B","RORVAL",3)

"KRN",8994,1446,2,"PARAMSEQ",1,1)

"KRN",8994,1446,2,"PARAMSEQ",2,2)

"KRN",8994,1446,2,"PARAMSEQ",3,3)

"KRN",8994,1477,-1)
0^5
"KRN",8994,1477,0)
ROR CLEAR RPC HANDLE^EN4^RORRP9^1^A
"KRN",8994,1477,1,0)
^^1^1^3011221^
"KRN",8994,1477,1,1,0)
Clear RPC Handle for report process
"KRN",8994,1477,2,0)
^8994.02A^2^2
"KRN",8994,1477,2,1,0)
RORREG^1^^1^1
"KRN",8994,1477,2,1,1,0)
^^1^1^3011221^
"KRN",8994,1477,2,1,1,1,0)
Registry Name
"KRN",8994,1477,2,2,0)
RORFLD^1^^1^2
"KRN",8994,1477,2,2,1,0)
^^1^1^3011221^
"KRN",8994,1477,2,2,1,1,0)
16 for Drug Rep Handle, 18 for Loc Reg Rep Handle
"KRN",8994,1477,2,"B","RORFLD",2)

"KRN",8994,1477,2,"B","RORREG",1)

"KRN",8994,1477,2,"PARAMSEQ",1,1)

"KRN",8994,1477,2,"PARAMSEQ",2,2)

"KRN",8994,1477,3,0)
^^1^1^3011221^
"KRN",8994,1477,3,1,0)
-1 if failed or 1 if success
"MBREQ")
0
"ORD",0,9.8)
9.8;;1;RTNF^XPDTA;RTNE^XPDTA
"ORD",0,9.8,0)
ROUTINE
"ORD",3,19.1)
19.1;3;1;;KEY^XPDTA1;;;;;KEYDEL^XPDIA1
"ORD",3,19.1,0)
SECURITY KEY
"ORD",5,.4)
.4;5;;;EDEOUT^DIFROMSO(.4,DA,"",XPDA);FPRE^DIFROMSI(.4,"",XPDA);EPRE^DIFROMSI(.4,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.4,DA,"",XPDA);DEL^DIFROMSK(.4,"",%)
"ORD",5,.4,0)
PRINT TEMPLATE
"ORD",6,.401)
.401;6;;;EDEOUT^DIFROMSO(.401,DA,"",XPDA);FPRE^DIFROMSI(.401,"",XPDA);EPRE^DIFROMSI(.401,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.401,DA,"",XPDA);DEL^DIFROMSK(.401,"",%)
"ORD",6,.401,0)
SORT TEMPLATE
"ORD",7,.402)
.402;7;;;EDEOUT^DIFROMSO(.402,DA,"",XPDA);FPRE^DIFROMSI(.402,"",XPDA);EPRE^DIFROMSI(.402,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.402,DA,"",XPDA);DEL^DIFROMSK(.402,"",%)
"ORD",7,.402,0)
INPUT TEMPLATE
"ORD",13,870)
870;13;1;;HLLL^XPDTA1;;HLLLE^XPDIA1;;;
"ORD",13,870,0)
HL LOGICAL LINK
"ORD",14,771)
771;14;;;HLAP^XPDTA1;HLAPF1^XPDIA1;HLAPE1^XPDIA1;HLAPF2^XPDIA1;;
"ORD",14,771,0)
HL7 APPLICATION PARAMETER
"ORD",15,101)
101;15;;;PRO^XPDTA;PROF1^XPDIA;PROE1^XPDIA;PROF2^XPDIA;;PRODEL^XPDIA
"ORD",15,101,0)
PROTOCOL
"ORD",16,8994)
8994;16;1;;;;;;;RPCDEL^XPDIA1
"ORD",16,8994,0)
REMOTE PROCEDURE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"ORD",20,8989.51)
8989.51;20;;;PAR1E1^XPDTA2;PAR1F1^XPDIA3;PAR1E1^XPDIA3;PAR1F2^XPDIA3
"ORD",20,8989.51,0)
PARAMETER DEFINITION
"PKG",389,-1)
1^1
"PKG",389,0)
CLINICAL CASE REGISTRIES^ROR^CLINICAL REGISTRIES
"PKG",389,20,0)
^9.402P^^
"PKG",389,22,0)
^9.49I^1^1
"PKG",389,22,1,0)
1.0^3020515^3020129^222222227
"PKG",389,22,1,1,0)
^^12^12^3020515
"PKG",389,22,1,1,1,0)
The Clinical Case Registry package automatically collects and creates
"PKG",389,22,1,1,2,0)
local registries of patients using the predefined search criteria.
"PKG",389,22,1,1,3,0)
 
"PKG",389,22,1,1,4,0)
This release contains the infrastructure and definitions of the Hepatitis
"PKG",389,22,1,1,5,0)
C registry. The software will search for patients that pass the
"PKG",389,22,1,1,6,0)
pre-defined selection rules that identify a patient with Hepatitis C
"PKG",389,22,1,1,7,0)
(e.g., ICD-9 code relating to Hepatitis C, positive laboratory serology
"PKG",389,22,1,1,8,0)
test results for Hepatitis C testing).
"PKG",389,22,1,1,9,0)
 
"PKG",389,22,1,1,10,0)
Local sites have the ability to review the local registry list before
"PKG",389,22,1,1,11,0)
automated data extraction and transmission. Data extraction and
"PKG",389,22,1,1,12,0)
transmission will be timed daily and will not require manual intervention.
"PKG",389,"VERSION")
1.0
"PRE")
RORENV01
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
82
"RTN","ROR")
0^1^B20578803
"RTN","ROR",1,0)
ROR ;HCIOFO/SG - CLINICAL REGISTRIES ; 5/8/02 11:50am
"RTN","ROR",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","ROR",3,0)
 ;
"RTN","ROR",4,0)
 ; RORERRDL ------------ DEFAULT ERROR LOCATION
"RTN","ROR",5,0)
 ;
"RTN","ROR",6,0)
 ; RORERROR ------------ ERROR PROCESSING DATA
"RTN","ROR",7,0)
 ;
"RTN","ROR",8,0)
 ; RORERROR("ES",        Index of the top of the stack
"RTN","ROR",9,0)
 ;   Index,                ^1: Error code
"RTN","ROR",10,0)
 ;                         ^2: Message text
"RTN","ROR",11,0)
 ;     1)                Place of the error (LABEL^ROUTINE)
"RTN","ROR",12,0)
 ;     2,Seq#)           Additional information (opt'l)
"RTN","ROR",13,0)
 ;
"RTN","ROR",14,0)
 ; RORPARM ------------- PACKAGE-WIDE CONSTANTS AND VARIABLES
"RTN","ROR",15,0)
 ;
"RTN","ROR",16,0)
 ; RORPARM("DEBUG")      Debug mode (opt'l):
"RTN","ROR",17,0)
 ;                         0  Disabled (default)
"RTN","ROR",18,0)
 ;                         1  Enabled
"RTN","ROR",19,0)
 ;                         2  Enabled; and all messages are not only
"RTN","ROR",20,0)
 ;                            logged but displayed on the screen too
"RTN","ROR",21,0)
 ;                         3  The same as 2 but registry update or
"RTN","ROR",22,0)
 ;                            data extraction is aborted immediately
"RTN","ROR",23,0)
 ;                            after processing a patient with errors
"RTN","ROR",24,0)
 ;
"RTN","ROR",25,0)
 ; RORPARM("DEVELOPER")  If this node is defined and not zero,
"RTN","ROR",26,0)
 ;                       national definitions (registry parameters,
"RTN","ROR",27,0)
 ;                       selection rules, etc) can be edited.
"RTN","ROR",28,0)
 ;                       Otherwise, editing is prohibited.
"RTN","ROR",29,0)
 ;
"RTN","ROR",30,0)
 ; RORPARM("ERR")        Enable/disable extended error processing:
"RTN","ROR",31,0)
 ;                         0  Disabled (default)
"RTN","ROR",32,0)
 ;                         1  Enabled
"RTN","ROR",33,0)
 ;
"RTN","ROR",34,0)
 ; RORPARM("KIDS",       This node is defined and non-zero only during
"RTN","ROR",35,0)
 ;                       the KIDS installation process:
"RTN","ROR",36,0)
 ;                         1  Pre-install
"RTN","ROR",37,0)
 ;                         2  Post-install
"RTN","ROR",38,0)
 ;   ParamName)          Value of an installation parameter
"RTN","ROR",39,0)
 ;
"RTN","ROR",40,0)
 ; RORPARM("LOG",        Enable/disable log collection:
"RTN","ROR",41,0)
 ;                         0  Disabled (default)
"RTN","ROR",42,0)
 ;                         1  Enabled
"RTN","ROR",43,0)
 ;   Type)               Enable (1) collection of only particular
"RTN","ROR",44,0)
 ;                       events (optional, all events by default)
"RTN","ROR",45,0)
 ;                       See the LOG EVENTS field in the ROR REGISTRY
"RTN","ROR",46,0)
 ;                       PARAMETERS file #798.1 for possible values.
"RTN","ROR",47,0)
 ;
"RTN","ROR",48,0)
 ; RORPARM("SETUP")      This node is defined and non-zero only
"RTN","ROR",49,0)
 ;                       during the registry setup.
"RTN","ROR",50,0)
 ;
"RTN","ROR",51,0)
 ; TEMPORARY NODE ------ DESCRIPTION
"RTN","ROR",52,0)
 ;
"RTN","ROR",53,0)
 ; ^TMP("RORACK")        Control data of acknowledgement processing
"RTN","ROR",54,0)
 ; ^TMP("RORHDT")        Control data of historical data extraction
"RTN","ROR",55,0)
 ; ^TMP("RORTMP")        Temporary storage
"RTN","ROR",56,0)
 ; ^TMP("RORUPD")        Registry update temporary data
"RTN","ROR",57,0)
 ;
"RTN","ROR",58,0)
 ; ^XTMP("RORHDT")       Control data of historical data extraction
"RTN","ROR",59,0)
 ; ^XTMP("RORUPDJ")      Registry update temporary data (multitask)
"RTN","ROR",60,0)
 ; ^XTMP("RORUPDR")      Registry update temporary data (installation)
"RTN","ROR",61,0)
 ;
"RTN","ROR",62,0)
 ; See detailed description of the temporary global nodes in
"RTN","ROR",63,0)
 ; the source code of the ^ROR01 routine.
"RTN","ROR",64,0)
 ;
"RTN","ROR",65,0)
 ; NAMESPACE ----------- DESCRIPTION
"RTN","ROR",66,0)
 ;
"RTN","ROR",67,0)
 ; RORACK*               Acknowldgement processing
"RTN","ROR",68,0)
 ; RORAPI*               Supported APIs
"RTN","ROR",69,0)
 ; RORDD*                Routines used by the Data Dictionary
"RTN","ROR",70,0)
 ; RORENV*               Environment check routines (KIDS)
"RTN","ROR",71,0)
 ; RORERR*               Error processing
"RTN","ROR",72,0)
 ; ROREVT*               Event protocols
"RTN","ROR",73,0)
 ; ROREX*                Regular data extraction & transmission
"RTN","ROR",74,0)
 ; RORHDT*               Historical data extraction
"RTN","ROR",75,0)
 ; RORHL*                HL7
"RTN","ROR",76,0)
 ; RORKIDS*              Low-level installation utilities (KIDS)
"RTN","ROR",77,0)
 ; RORLOG*               Error recording
"RTN","ROR",78,0)
 ; RORPOS*               Post-install routines (KIDS)
"RTN","ROR",79,0)
 ; RORPRE*               Pre-install routines (KIDS)
"RTN","ROR",80,0)
 ; RORRP*                Remote procedures
"RTN","ROR",81,0)
 ; RORSET*               Setup routines
"RTN","ROR",82,0)
 ; RORUP*                Registry update
"RTN","ROR",83,0)
 ; RORUTL*               Utilities
"RTN","ROR",84,0)
 ;
"RTN","ROR",85,0)
 ; MENU OPTION --------- DESCRIPTION
"RTN","ROR",86,0)
 ;
"RTN","ROR",87,0)
 ; [ROR TASK]            Registry update and data extraction option
"RTN","ROR",88,0)
 ;                       (must be scheduled; do not run it directly)
"RTN","ROR",89,0)
 ; [ROR SETUP HEPC]      Setup the HepC registry
"RTN","ROR",90,0)
 ; [RORHDT MAIN]         Historical data extraction menu
"RTN","ROR",91,0)
 ; [RORMNT MAIN]         Maintenance menu
"RTN","ROR",92,0)
 ;
"RTN","ROR",93,0)
 ; SPECIAL ENTRY POINT - DESCRIPTION
"RTN","ROR",94,0)
 ;
"RTN","ROR",95,0)
 ;    START^RORTSITE     Prepares test sites for going live
"RTN","ROR",96,0)
 ;         ^RORUTL06     Registry definition validator
"RTN","ROR",97,0)
 ; DISTPREP^RORUTL06     Prepares registry parameters for KIDS distr.
"RTN","ROR",98,0)
 ;   PRTMDE^RORUTL06     Prints the data element metadata
"RTN","ROR",99,0)
 ;
"RTN","ROR",100,0)
 ;  EXTRACT^RORUTL07     Data extraction & transmission in debug mode
"RTN","ROR",101,0)
 ;   UPDATE^RORUTL07     Registry update in debug mode
"RTN","ROR",102,0)
 ;
"RTN","ROR",103,0)
 ; INITIALS ------------ DEVELOPER
"RTN","ROR",104,0)
 ;
"RTN","ROR",105,0)
 ; BH                    Brent Hicks
"RTN","ROR",106,0)
 ; CRT                   Cameron Taylor
"RTN","ROR",107,0)
 ; SG                    Sergey Gavrilov
"RTN","ROR",108,0)
 ;
"RTN","ROR",109,0)
 Q
"RTN","ROR",110,0)
 ;
"RTN","ROR",111,0)
 ;***** REGISTRY UPDATE AND DATA EXTRACTION TASK
"RTN","ROR",112,0)
 ;
"RTN","ROR",113,0)
 ; ZTQPARAM      String that contains a list of registry names
"RTN","ROR",114,0)
 ;               separated by commas. You must define the list as
"RTN","ROR",115,0)
 ;               a value of the TASK PARAMETERS field during
"RTN","ROR",116,0)
 ;               scheduling of the [ROR TASK] option that uses
"RTN","ROR",117,0)
 ;               this entry point.
"RTN","ROR",118,0)
 ;
"RTN","ROR",119,0)
 ; The following task parameters are optional. They can be defined
"RTN","ROR",120,0)
 ; on the second page of the option scheduling form as the pairs of
"RTN","ROR",121,0)
 ; variable names and values. See description of the ROR TASK option
"RTN","ROR",122,0)
 ; for more details regarding these parameters.
"RTN","ROR",123,0)
 ;
"RTN","ROR",124,0)
 ; [RORFLCLR]    Clear flags to control processing.
"RTN","ROR",125,0)
 ; [RORFLSET]    Set flags to control processing.
"RTN","ROR",126,0)
 ;
"RTN","ROR",127,0)
 ; [RORMNTSK]    Maximum number of the registry update subtasks.
"RTN","ROR",128,0)
 ;               The default value of the parameter is "2-3-AUTO".
"RTN","ROR",129,0)
 ;
"RTN","ROR",130,0)
 ; [RORSUSP]     Suspension parameters of the registry update sub-
"RTN","ROR",131,0)
 ;               tasks. The subtasks are not suspended by default.
"RTN","ROR",132,0)
 ;
"RTN","ROR",133,0)
TASK ;
"RTN","ROR",134,0)
 N RORERROR      ; Error processing data
"RTN","ROR",135,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","ROR",136,0)
 N RORPARM       ; Application parameters
"RTN","ROR",137,0)
 ;
"RTN","ROR",138,0)
 N CNT,I,RC,REGLST,REGNAME,RGEXLST
"RTN","ROR",139,0)
 ;--- Check the task parameters
"RTN","ROR",140,0)
 I $G(ZTQPARAM)?." "  K ZTQPARAM  S RC=ZTQPARAM
"RTN","ROR",141,0)
 S RORFLCLR=$G(RORFLCLR)
"RTN","ROR",142,0)
 S RORFLSET=$G(RORFLSET)
"RTN","ROR",143,0)
 S RORMNTSK=$S($G(RORMNTSK)'="":$TR(RORMNTSK,"-","^"),1:"2^3^AUTO")
"RTN","ROR",144,0)
 I $G(RORSUSP)'=""  D
"RTN","ROR",145,0)
 . N %DT,DTOUT,TMP,X,Y
"RTN","ROR",146,0)
 . S TMP=RORSUSP,RORSUSP=""
"RTN","ROR",147,0)
 . F I=1,2  D  S:$G(Y)>0 $P(RORSUSP,"^",I)=Y#1
"RTN","ROR",148,0)
 . . S X=$P(TMP,"-",I),%DT="R"  D ^%DT
"RTN","ROR",149,0)
 E  S RORSUSP=""
"RTN","ROR",150,0)
 ;--- Initialize constants and variables
"RTN","ROR",151,0)
 D INIT^RORUTL01("ROR",1)
"RTN","ROR",152,0)
 ;S RORPARM("DEBUG")=1 ; Remove the first ';' to start in debug mode
"RTN","ROR",153,0)
 S RORPARM("ERR")=1
"RTN","ROR",154,0)
 ;--- Extract registry names from the task parameters
"RTN","ROR",155,0)
 F I=1:1  S REGNAME=$P(ZTQPARAM,",",I)  Q:REGNAME=""  D
"RTN","ROR",156,0)
 . S REGNAME=$$TRIM^XLFSTR(REGNAME)
"RTN","ROR",157,0)
 . S:REGNAME'="" REGLST(REGNAME)=""
"RTN","ROR",158,0)
 ;--- Open a new log
"RTN","ROR",159,0)
 S RC=$$SETUP^RORLOG(.REGLST)
"RTN","ROR",160,0)
 S RC=$$OPEN^RORLOG(.REGLST,,"ROR TASK STARTED")
"RTN","ROR",161,0)
 ;--- Clear expired 'Awaiting Acknowledgement' flags
"RTN","ROR",162,0)
 S RC=$$CLRACK^RORUTL05(.REGLST)
"RTN","ROR",163,0)
 ;--- Update the registries
"RTN","ROR",164,0)
 S RC=$$UPDATE^RORUPD(.REGLST,.RGEXLST,RORMNTSK,RORSUSP,RORFLCLR,RORFLSET)
"RTN","ROR",165,0)
 ;--- Process the errors
"RTN","ROR",166,0)
 I RC<0  D  I RC<0  D CLOSE^RORLOG("ROR TASK ABORTED")  Q
"RTN","ROR",167,0)
 . ;--- Quit if stop is requested (via the TaskMan User option)
"RTN","ROR",168,0)
 . I RC=-42  D ALERT^RORUTL01(.REGLST,-42)  S ZTSTOP=1  Q
"RTN","ROR",169,0)
 . ;--- Do not send the alert for some warnings
"RTN","ROR",170,0)
 . I RC=-28  S RC=0  Q
"RTN","ROR",171,0)
 . ;--- Send the alert in case of other errors/warnings
"RTN","ROR",172,0)
 . D ALERT^RORUTL01(.REGLST,-43,,,,"registry update")
"RTN","ROR",173,0)
 . S RC=0
"RTN","ROR",174,0)
 ;--- Mark registry records 3 weeks after the installation so that
"RTN","ROR",175,0)
 ;    the local registry data and demographic data will be resent
"RTN","ROR",176,0)
 ;--- to restore the data overwritten with the historical data
"RTN","ROR",177,0)
 S RC=$$REMARK^RORUTL05(.RGEXLST,21)
"RTN","ROR",178,0)
 ;--- Schedule the data extraction task(s)
"RTN","ROR",179,0)
 S REGNAME=""  K ZTSAVE
"RTN","ROR",180,0)
 F CNT=1:1  S REGNAME=$O(RGEXLST(REGNAME))  Q:REGNAME=""  D
"RTN","ROR",181,0)
 . S ZTRTN="TASK^ROREXT",ZTIO=""
"RTN","ROR",182,0)
 . S ZTDTH=$$FMADD^XLFDT($$NOW^XLFDT,,,,(CNT-1)*30)
"RTN","ROR",183,0)
 . S ZTDESC="Data Extraction ("_REGNAME_")"
"RTN","ROR",184,0)
 . S ZTSAVE("RORREG")=REGNAME
"RTN","ROR",185,0)
 . D ^%ZTLOAD
"RTN","ROR",186,0)
 ;--- Purge the old logs
"RTN","ROR",187,0)
 S RC=$$PURGE^RORLOG(14)
"RTN","ROR",188,0)
 ;--- Purge the old event references
"RTN","ROR",189,0)
 S RC=$$EPDATE^RORUTL05()
"RTN","ROR",190,0)
 S:RC>0 RC=$$PURGE^RORUPP02(RC)
"RTN","ROR",191,0)
 ;---
"RTN","ROR",192,0)
 D CLOSE^RORLOG("ROR TASK COMPLETED")
"RTN","ROR",193,0)
 S ZTREQ="@"
"RTN","ROR",194,0)
 Q
"RTN","ROR01")
0^2^B15130
"RTN","ROR01",1,0)
ROR01 ;HCIOFO/SG - CLINICAL REGISTRIES (TEMPOR. GLOBALS) ; 3/28/02 1:18pm
"RTN","ROR01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","ROR01",3,0)
 ;
"RTN","ROR01",4,0)
 ; ^TMP("RORACK") ------ CONTROL DATA OF ACKNOWLEDGEMENT PROCESSING
"RTN","ROR01",5,0)
 ;
"RTN","ROR01",6,0)
 ; ^TMP("RORACK",$J,
"RTN","ROR01",7,0)
 ;   "PR",IEN)           List of IENs of registry records that
"RTN","ROR01",8,0)
 ;                       acknowledgements have been processed for.
"RTN","ROR01",9,0)
 ;
"RTN","ROR01",10,0)
 ; ^TMP("RORHDT") ------ CONTROL DATA OF HISTORICAL DATA EXTRACTION
"RTN","ROR01",11,0)
 ;
"RTN","ROR01",12,0)
 ; ^TMP("RORHDT",$J,
"RTN","ROR01",13,0)
 ;   "PR",               List of IENs of registry records processed
"RTN","ROR01",14,0)
 ;                       in the re-extraction section of function
"RTN","ROR01",15,0)
 ;                       $$EXTRACT^RORHDT04.
"RTN","ROR01",16,0)
 ;     IEN)              Return code of the record processing. If this
"RTN","ROR01",17,0)
 ;                       value is less than zero, data extraction was
"RTN","ROR01",18,0)
 ;                       not successful again.
"RTN","ROR01",19,0)
 ;
"RTN","ROR01",20,0)
 ; ^TMP("RORTMP",$J) --- TEMPORARY STORAGE
"RTN","ROR01",21,0)
 ;
"RTN","ROR01",22,0)
 ; ^TMP("RORUPD") ------ REGISTRY UPDATE TEMPORARY DATA
"RTN","ROR01",23,0)
 ;
"RTN","ROR01",24,0)
 ; ^TMP("RORUPD",$J,
"RTN","ROR01",25,0)
 ;
"RTN","ROR01",26,0)
 ;   1,File#,
"RTN","ROR01",27,0)
 ;     "S",Rule Name)    List of selection rules
"RTN","ROR01",28,0)
 ;     "F",DataCode,     List of data elements to load
"RTN","ROR01",29,0)
 ;       "E")            If expression implementing the selection
"RTN","ROR01",30,0)
 ;                       rule references an external value of the
"RTN","ROR01",31,0)
 ;                       element, the "E" sub-node will be defined.
"RTN","ROR01",32,0)
 ;       "I")            If expression implementing the selection
"RTN","ROR01",33,0)
 ;                       rule references an internal value of the
"RTN","ROR01",34,0)
 ;                       element, the "I" sub-node will be defined.
"RTN","ROR01",35,0)
 ;
"RTN","ROR01",36,0)
 ;   2,Registry#)        Registry Name
"RTN","ROR01",37,0)
 ;
"RTN","ROR01",38,0)
 ;   3,Rule Name,        Selection rule descriptor
"RTN","ROR01",39,0)
 ;                         ^1: Rule#
"RTN","ROR01",40,0)
 ;                         ^2: File Number
"RTN","ROR01",41,0)
 ;                         ^3: 1 if already processed, otherwise
"RTN","ROR01",42,0)
 ;                             empty string
"RTN","ROR01",43,0)
 ;                         ^4: 1 if registry should be updated (in
"RTN","ROR01",44,0)
 ;                             case of matched condition, of course)
"RTN","ROR01",45,0)
 ;     1)                MUMPS function entry point
"RTN","ROR01",46,0)
 ;     2,Registry#)      List of affected registries
"RTN","ROR01",47,0)
 ;     3,Rule Name)      List of rules that this rule depend on
"RTN","ROR01",48,0)
 ;
"RTN","ROR01",49,0)
 ;   4,LabSearch#)       List of Lab search IENs
"RTN","ROR01",50,0)
 ;
"RTN","ROR01",51,0)
 ;   "LS",
"RTN","ROR01",52,0)
 ;     Result Code,
"RTN","ROR01",53,0)
 ;       LabSearch#,
"RTN","ROR01",54,0)
 ;         Seq#)         Condition to check the result
"RTN","ROR01",55,0)
 ;                         ^1: Indicator
"RTN","ROR01",56,0)
 ;                         ^2: Indicated Value
"RTN","ROR01",57,0)
 ;
"RTN","ROR01",58,0)
 ;   "U",Patient#,       This node is defined if the patient has been 
"RTN","ROR01",59,0)
 ;                       processed
"RTN","ROR01",60,0)
 ;     2,Registry#,      This node is defined if the registry should
"RTN","ROR01",61,0)
 ;                       be updated
"RTN","ROR01",62,0)
 ;       Rule#)          Trigger date of the rule
"RTN","ROR01",63,0)
 ;
"RTN","ROR01",64,0)
 ; ^XTMP("RORHDT"_) ---- CONTROL DATA OF HISTORICAL DATA EXTRACTION
"RTN","ROR01",65,0)
 ;
"RTN","ROR01",66,0)
 ; ^XTMP("RORHDT"_Registry#,
"RTN","ROR01",67,0)
 ;   0)                  Node descriptor
"RTN","ROR01",68,0)
 ;                         ^1: purge date  (FileMan)
"RTN","ROR01",69,0)
 ;                         ^2: create date (FileMan)
"RTN","ROR01",70,0)
 ;                         ^3: description
"RTN","ROR01",71,0)
 ;
"RTN","ROR01",72,0)
 ;   "T",Task#)          This node is LOCKed by the historical data
"RTN","ROR01",73,0)
 ;                       extraction task while it is running. If a
"RTN","ROR01",74,0)
 ;                       non-zero value is asssigned to this node
"RTN","ROR01",75,0)
 ;                       during task execution, the task will stop.
"RTN","ROR01",76,0)
 ;
"RTN","ROR01",77,0)
 ; ^XTMP("RORUPD"_) ---- REGISTRY UPDATE TEMPORARY DATA (MULTITASK)
"RTN","ROR01",78,0)
 ;
"RTN","ROR01",79,0)
 ;                       If the registry update starts in the
"RTN","ROR01",80,0)
 ;                       multitask mode, all temporary data from the
"RTN","ROR01",81,0)
 ;                       ^TMP("RORUPD",$J) node is merged to this
"RTN","ROR01",82,0)
 ;                       node so that it will be available for all
"RTN","ROR01",83,0)
 ;                       registry update subtasks.
"RTN","ROR01",84,0)
 ;
"RTN","ROR01",85,0)
 ; ^XTMP("RORUPDJ"_$J,
"RTN","ROR01",86,0)
 ;                       If the regular registry update is run in the
"RTN","ROR01",87,0)
 ;                       multitask mode, the ^XTMP("RORUPDJ"_$J) node
"RTN","ROR01",88,0)
 ;                       is used. $J is the job number of the main
"RTN","ROR01",89,0)
 ;                       registry update task.
"RTN","ROR01",90,0)
 ;
"RTN","ROR01",91,0)
 ; ^XTMP("RORUPDR"_Registry#,
"RTN","ROR01",92,0)
 ;                       During the initial registry population
"RTN","ROR01",93,0)
 ;                       (performed by the post-install routines),
"RTN","ROR01",94,0)
 ;                       the ^XTMP("RORUPDR"_Registry#) node is used.
"RTN","ROR01",95,0)
 ;                       The list of processed patients (the "U"
"RTN","ROR01",96,0)
 ;                       subscript) is used to restart the process
"RTN","ROR01",97,0)
 ;                       after an error or a crash.
"RTN","ROR01",98,0)
 ;
"RTN","ROR01",99,0)
 ;   0)                  Node descriptor
"RTN","ROR01",100,0)
 ;                         ^1: purge date  (FileMan)
"RTN","ROR01",101,0)
 ;                         ^2: create date (FileMan)
"RTN","ROR01",102,0)
 ;                         ^3: description
"RTN","ROR01",103,0)
 ;
"RTN","ROR01",104,0)
 ;   "T",Task#)          This node is LOCKed while the (sub)task is
"RTN","ROR01",105,0)
 ;                       running (subscript of the main task is 0).
"RTN","ROR01",106,0)
 ;
"RTN","ROR01",107,0)
 ;                       Otherwise, "S" means that the subtask has
"RTN","ROR01",108,0)
 ;                       been scheduled but not started yet.
"RTN","ROR01",109,0)
 ;
"RTN","ROR01",110,0)
 ;                       A negative value of the non-locked node
"RTN","ROR01",111,0)
 ;                       represents the error code (for example,
"RTN","ROR01",112,0)
 ;                       -60 means that the subtask has crashed).
"RTN","ROR01",113,0)
 ;
"RTN","ROR01",114,0)
 ;                       Non-negative value of the node means that
"RTN","ROR01",115,0)
 ;                       the subtask has been completed. The value
"RTN","ROR01",116,0)
 ;                       has the following structure:
"RTN","ROR01",117,0)
 ;                         ^1: Number of processed patients
"RTN","ROR01",118,0)
 ;                         ^2: Number of patients processed with
"RTN","ROR01",119,0)
 ;                             errors
"RTN","ROR01",120,0)
 ;
"RTN","ROR01",121,0)
 Q
"RTN","RORACK")
0^3^B12656056
"RTN","RORACK",1,0)
RORACK ;HCIOFO/SG - ACKNOWLEDGEMENT PROCESSING ; 5/13/02 11:22am
"RTN","RORACK",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORACK",3,0)
 ;
"RTN","RORACK",4,0)
 Q
"RTN","RORACK",5,0)
 ;
"RTN","RORACK",6,0)
 ;***** PROCESSES THE BATCH HEADER OF THE ACKNOWLEDGEMENT
"RTN","RORACK",7,0)
 ;
"RTN","RORACK",8,0)
 ; .REGLST       Reference to a local variable where the list of
"RTN","RORACK",9,0)
 ;               registries associated with the original batch
"RTN","RORACK",10,0)
 ;               message will be returned to. The list will have
"RTN","RORACK",11,0)
 ;               the following structure:
"RTN","RORACK",12,0)
 ;
"RTN","RORACK",13,0)
 ;                 REGLST(RegistryName)=RegistryIEN^BatchID
"RTN","RORACK",14,0)
 ;
"RTN","RORACK",15,0)
 ; Return Values:
"RTN","RORACK",16,0)
 ;        <0  Error Code
"RTN","RORACK",17,0)
 ;         0  Ok
"RTN","RORACK",18,0)
 ;
"RTN","RORACK",19,0)
HEADER(REGLST) ;
"RTN","RORACK",20,0)
 N FS,I,RC,REFMID,REGNAME,RORBUF,RORMSG,TMP
"RTN","RORACK",21,0)
 K REGLST
"RTN","RORACK",22,0)
 ;--- Get the BHS segment
"RTN","RORACK",23,0)
 X HLNEXT
"RTN","RORACK",24,0)
 I (HLQUIT'>0)!($E($G(HLNODE),1,3)'="BHS")  D  Q RC
"RTN","RORACK",25,0)
 . S RC=$$ERROR^RORERR(-68,"HEADER^RORACK")
"RTN","RORACK",26,0)
 S RORBUF=HLNODE,I=""
"RTN","RORACK",27,0)
 F  S I=$O(HLNODE(I))  Q:I=""  S RORBUF=RORBUF_HLNODE(I)
"RTN","RORACK",28,0)
 S FS=$E(RORBUF,4)
"RTN","RORACK",29,0)
 ;--- Load the batch parameters
"RTN","RORACK",30,0)
 S REFMID=$P(RORBUF,FS,12)
"RTN","RORACK",31,0)
 ;--- Record some of the parameters
"RTN","RORACK",32,0)
 K RORMSG
"RTN","RORACK",33,0)
 S RORMSG(1)="Message IEN:  "_$G(HLMTIENS)
"RTN","RORACK",34,0)
 S RORMSG(2)="Message ID:   "_$G(HL("MID"))
"RTN","RORACK",35,0)
 S TMP=$$HL7TFM^XLFDT($G(HL("DTM")))
"RTN","RORACK",36,0)
 S RORMSG(3)="Message Date: "_$$FMTE^XLFDT(TMP)
"RTN","RORACK",37,0)
 S RORMSG(4)="Reference ID: "_REFMID
"RTN","RORACK",38,0)
 D LOG^RORLOG(2,"Processing the HL7 batch message",,.RORMSG)
"RTN","RORACK",39,0)
 K RORMSG
"RTN","RORACK",40,0)
 ;--- Get a list of registries associated with the batch and
"RTN","RORACK",41,0)
 ;--- awaiting application acknowledgements
"RTN","RORACK",42,0)
 S TMP="@;.01;2.1",I="I $P($G(^(0)),U,9)"
"RTN","RORACK",43,0)
 D FIND^DIC(798.1,,TMP,"X",REFMID,,"AM",I,,"RORBUF","RORMSG")
"RTN","RORACK",44,0)
 Q:$G(DIERR)>0 $$DBS^RORERR("RORMSG",-9,"HEADER^RORACK",,798.1)
"RTN","RORACK",45,0)
 I $G(RORBUF("DILIST",0))'>0  D  Q RC
"RTN","RORACK",46,0)
 . S TMP="Message ID: "_$G(HL("MID"))
"RTN","RORACK",47,0)
 . S RC=$$ERROR^RORERR(-73,"HEADER^RORACK",TMP)
"RTN","RORACK",48,0)
 ;--- Compile the list of registries
"RTN","RORACK",49,0)
 S I=""
"RTN","RORACK",50,0)
 F  S I=$O(RORBUF("DILIST","ID",I))  Q:I=""  D
"RTN","RORACK",51,0)
 . S REGNAME=$G(RORBUF("DILIST","ID",I,.01))  Q:REGNAME=""
"RTN","RORACK",52,0)
 . S $P(REGLST(REGNAME),U,1)=$G(RORBUF("DILIST",2,I))
"RTN","RORACK",53,0)
 . S $P(REGLST(REGNAME),U,2)=$G(RORBUF("DILIST","ID",I,2.1))
"RTN","RORACK",54,0)
 Q 0
"RTN","RORACK",55,0)
 ;
"RTN","RORACK",56,0)
 ;***** PROCESSES HL7 APPLICATION ACKNOWLEDGEMENT
"RTN","RORACK",57,0)
PROCESS ;
"RTN","RORACK",58,0)
 N RORERROR      ; Error processing data
"RTN","RORACK",59,0)
 N RORERRDL      ; Default error location
"RTN","RORACK",60,0)
 N RORLOG        ; Log susbsystem data
"RTN","RORACK",61,0)
 N RORPARM       ; Application parameters
"RTN","RORACK",62,0)
 ;
"RTN","RORACK",63,0)
 N RC,REGLST,TMP
"RTN","RORACK",64,0)
 D INIT^RORUTL01("RORACK"),CLEAR^RORERR("PROCESS^RORACK")
"RTN","RORACK",65,0)
 S RORPARM("LOG")=1
"RTN","RORACK",66,0)
 ;--- Open a new log
"RTN","RORACK",67,0)
 S TMP=$$OPEN^RORLOG(,3,"ACKNOWLEDGEMENT PROCESSING STARTED")
"RTN","RORACK",68,0)
 D
"RTN","RORACK",69,0)
 . ;--- Process the batch header
"RTN","RORACK",70,0)
 . S RC=$$HEADER(.REGLST)            Q:RC<0
"RTN","RORACK",71,0)
 . ;--- Associate the log with the registries
"RTN","RORACK",72,0)
 . S RC=$$SETRGLST^RORLOG(.REGLST)
"RTN","RORACK",73,0)
 . S:RC<0 RORPARM("LOG")=1
"RTN","RORACK",74,0)
 . ;--- Process the acknowldgements
"RTN","RORACK",75,0)
 . S RC=$$PROCMSG^RORACK01(.REGLST)  Q:RC<0
"RTN","RORACK",76,0)
 . S RC=$$PROCREM^RORACK01(.REGLST)  Q:RC<0
"RTN","RORACK",77,0)
 ;
"RTN","RORACK",78,0)
 I RC<0  S:RC'=-73 HLERR="RORACK: Error Code: "_RC
"RTN","RORACK",79,0)
 S TMP=$$UPDPARMS(.REGLST)
"RTN","RORACK",80,0)
 I TMP<0  S:RC'<0 RC=TMP
"RTN","RORACK",81,0)
 ;--- Statistics & Cleanup
"RTN","RORACK",82,0)
 S TMP="ACKNOWLEDGEMENT PROCESSING "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","RORACK",83,0)
 D CLOSE^RORLOG(TMP)
"RTN","RORACK",84,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("RORACK")
"RTN","RORACK",85,0)
 Q
"RTN","RORACK",86,0)
 ;
"RTN","RORACK",87,0)
 ;***** UPDATES REGISTRY PARAMETERS
"RTN","RORACK",88,0)
 ;
"RTN","RORACK",89,0)
 ; .REGLST       Reference to a local variable containing a list
"RTN","RORACK",90,0)
 ;               of registries (registry names as the subscripts
"RTN","RORACK",91,0)
 ;               and registry IENs as the values).
"RTN","RORACK",92,0)
 ;
"RTN","RORACK",93,0)
 ; Return Values:
"RTN","RORACK",94,0)
 ;        <0  Error Code
"RTN","RORACK",95,0)
 ;         0  Ok
"RTN","RORACK",96,0)
 ;
"RTN","RORACK",97,0)
UPDPARMS(REGLST) ;
"RTN","RORACK",98,0)
 N IR,RC,REGIENS,RORFDA,RORMSG
"RTN","RORACK",99,0)
 S IR="",RC=0
"RTN","RORACK",100,0)
 F  S IR=$O(REGLST(IR))  Q:IR=""  D  Q:RC<0
"RTN","RORACK",101,0)
 . S REGIENS=+REGLST(IR)_","  Q:REGIENS'>0
"RTN","RORACK",102,0)
 . S RORFDA(798.1,REGIENS,2.2)="@"
"RTN","RORACK",103,0)
 . S RORFDA(798.1,REGIENS,2.3)="@"
"RTN","RORACK",104,0)
 . ;--- Update the registry parameters
"RTN","RORACK",105,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORACK",106,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"UPDPARMS^RORACK")
"RTN","RORACK",107,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORACK01")
0^4^B35934745
"RTN","RORACK01",1,0)
RORACK01 ;HCIOFO/SG - ACKNOWLEDGEMENT PROCESSING ; 5/2/02 10:29am
"RTN","RORACK01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORACK01",3,0)
 ;
"RTN","RORACK01",4,0)
 Q
"RTN","RORACK01",5,0)
 ;
"RTN","RORACK01",6,0)
 ;***** RECORDS ERROR CODE AND LOCATION
"RTN","RORACK01",7,0)
 ;
"RTN","RORACK01",8,0)
 ; ERRLOC        Error code and location from the ERR segment
"RTN","RORACK01",9,0)
 ; PATIEN        Patient IEN
"RTN","RORACK01",10,0)
 ;
"RTN","RORACK01",11,0)
 ; Return Values:
"RTN","RORACK01",12,0)
 ;        <0  Error Code
"RTN","RORACK01",13,0)
 ;        >0  IEN of the registry record
"RTN","RORACK01",14,0)
 ;
"RTN","RORACK01",15,0)
ERR(ERRLOC,PATIEN) ;
"RTN","RORACK01",16,0)
 N CS,ERR,FLD,II,INFO,MSG,SCS,SEG,SQN,TMP,TYPE
"RTN","RORACK01",17,0)
 S CS=$E($G(HL("ECH")),1),SCS=$E($G(HL("ECH")),4)
"RTN","RORACK01",18,0)
 Q:(CS="")!(SCS="") $$ERROR^RORERR(-40,"ERR^RORACK01",,,"HL")
"RTN","RORACK01",19,0)
 S II=0,TYPE=6
"RTN","RORACK01",20,0)
 ;--- Extracts the information
"RTN","RORACK01",21,0)
 S SEG=$P(ERRLOC,CS,1)
"RTN","RORACK01",22,0)
 S SQN=$P(ERRLOC,CS,2)
"RTN","RORACK01",23,0)
 S FLD=$P(ERRLOC,CS,3)
"RTN","RORACK01",24,0)
 S ERR=$P(ERRLOC,CS,4)
"RTN","RORACK01",25,0)
 ;--- Prepare HL7 information
"RTN","RORACK01",26,0)
 S TMP=""
"RTN","RORACK01",27,0)
 S:SEG'="" TMP=TMP_", Segment: '"_SEG_"'"
"RTN","RORACK01",28,0)
 S:SQN TMP=TMP_", Sequence#: "_+SQN
"RTN","RORACK01",29,0)
 S:FLD TMP=TMP_", Field#: "_+FLD
"RTN","RORACK01",30,0)
 S:TMP'="" II=II+1,INFO(II)="HL7 INFO: "_$P(TMP,", ",2,999)
"RTN","RORACK01",31,0)
 ;--- Prepare the message and error location data
"RTN","RORACK01",32,0)
 I ERR?1.8UN.(1":".E)  D
"RTN","RORACK01",33,0)
 . S MSG=$$MSG^RORERR10($P(ERR,":"),.TYPE)
"RTN","RORACK01",34,0)
 . ;
"RTN","RORACK01",35,0)
 . I "OBR,OBX,NTE"[SEG  D  Q
"RTN","RORACK01",36,0)
 . . S TMP=$P(ERR,":",2)  D:TMP'=""
"RTN","RORACK01",37,0)
 . . . S II=II+1,INFO(II)="Placer Order Number: '"_TMP_"'"
"RTN","RORACK01",38,0)
 . . S TMP=$P(ERR,":",3)  D:TMP'=""
"RTN","RORACK01",39,0)
 . . . S TMP=$$FMTE^XLFDT($$HL7TFM^XLFDT(TMP))
"RTN","RORACK01",40,0)
 . . . S II=II+1,INFO(II)="Date/Time of Transaction: "_TMP
"RTN","RORACK01",41,0)
 . ;
"RTN","RORACK01",42,0)
 . I "ORC,RXE"[SEG  D  Q
"RTN","RORACK01",43,0)
 . . S TMP=$P(ERR,":",2)  D:TMP'=""
"RTN","RORACK01",44,0)
 . . . S II=II+1,INFO(II)="Filler Order Number: '"_TMP_"'"
"RTN","RORACK01",45,0)
 . . S TMP=$P(ERR,":",3)  D:TMP'=""
"RTN","RORACK01",46,0)
 . . . S TMP=$$FMTE^XLFDT($$HL7TFM^XLFDT(TMP))
"RTN","RORACK01",47,0)
 . . . S II=II+1,INFO(II)="Observation Date/Time: "_TMP
"RTN","RORACK01",48,0)
 . ;
"RTN","RORACK01",49,0)
 E  S MSG=ERR
"RTN","RORACK01",50,0)
 ;--- Record the error
"RTN","RORACK01",51,0)
 S:$G(MSG)="" MSG="Unknown error"
"RTN","RORACK01",52,0)
 D LOG^RORLOG(TYPE,MSG,$G(PATIEN),.INFO)
"RTN","RORACK01",53,0)
 Q 0
"RTN","RORACK01",54,0)
 ;
"RTN","RORACK01",55,0)
 ;***** ANALYZES THE ERROR CODE
"RTN","RORACK01",56,0)
 ;
"RTN","RORACK01",57,0)
 ; .RC           Error code (it can be modified inside the function)
"RTN","RORACK01",58,0)
 ;
"RTN","RORACK01",59,0)
 ; Return Values:
"RTN","RORACK01",60,0)
 ;         0  Continue
"RTN","RORACK01",61,0)
 ;         1  Stop and exit
"RTN","RORACK01",62,0)
 ;
"RTN","RORACK01",63,0)
EXIT(RC) ;
"RTN","RORACK01",64,0)
 Q:RC'<0 0
"RTN","RORACK01",65,0)
 S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORACK01",66,0)
 Q RC<0
"RTN","RORACK01",67,0)
 ;
"RTN","RORACK01",68,0)
 ;***** FINDS THE REGISTRY RECORD BY THE HL7 MESSAGE ID
"RTN","RORACK01",69,0)
 ;
"RTN","RORACK01",70,0)
 ; MSGID         HL7 message ID
"RTN","RORACK01",71,0)
 ; .PATIEN       Patient IEN is returned via this parameter
"RTN","RORACK01",72,0)
 ; .REGIEN       Registry IEN is returned via this parameter
"RTN","RORACK01",73,0)
 ;
"RTN","RORACK01",74,0)
 ; Return Values:
"RTN","RORACK01",75,0)
 ;        <0  Error Code
"RTN","RORACK01",76,0)
 ;        >0  IEN of the registry record
"RTN","RORACK01",77,0)
 ;
"RTN","RORACK01",78,0)
FINDREC(MSGID,PATIEN,REGIEN) ;
"RTN","RORACK01",79,0)
 N IEN,RC,RORBUF,RORMSG,TMP
"RTN","RORACK01",80,0)
 ;--- Find the registry record
"RTN","RORACK01",81,0)
 D FIND^DIC(798,,".01I;.02I","QX",MSGID,2,"AM",,,"RORBUF","RORMSG")
"RTN","RORACK01",82,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"PROCESS^RORACK01",,798)
"RTN","RORACK01",83,0)
 S TMP=+$G(RORBUF("DILIST",0))
"RTN","RORACK01",84,0)
 Q:TMP<1 $$ERROR^RORERR(-52,"FINDREC^RORACK01",,,MSGID)
"RTN","RORACK01",85,0)
 Q:TMP>1 $$ERROR^RORERR(-39,"FINDREC^RORACK01",,,MSGID)
"RTN","RORACK01",86,0)
 ;--- Get the data
"RTN","RORACK01",87,0)
 S IEN=RORBUF("DILIST",2,1)
"RTN","RORACK01",88,0)
 S PATIEN=$G(RORBUF("DILIST","ID",1,.01))
"RTN","RORACK01",89,0)
 S REGIEN=$G(RORBUF("DILIST","ID",1,.02))
"RTN","RORACK01",90,0)
 Q IEN
"RTN","RORACK01",91,0)
 ;
"RTN","RORACK01",92,0)
 ;***** PROCESSES HL7 BATCH OF ACKNOWLEDGEMENTS
"RTN","RORACK01",93,0)
 ;
"RTN","RORACK01",94,0)
 ; .REGLST       Reference to a local variable containing the list
"RTN","RORACK01",95,0)
 ;               of registries associated with the original batch
"RTN","RORACK01",96,0)
 ;               message. The list must have the following structure:
"RTN","RORACK01",97,0)
 ;
"RTN","RORACK01",98,0)
 ;                 REGLST(RegistryName)=RegistryIEN^BatchID
"RTN","RORACK01",99,0)
 ;
"RTN","RORACK01",100,0)
 ; This function should be called only from the acknowledgement
"RTN","RORACK01",101,0)
 ; processing routine.
"RTN","RORACK01",102,0)
 ;
"RTN","RORACK01",103,0)
 ; Global node ^TMP("DILIST",$J) is used by this function.
"RTN","RORACK01",104,0)
 ;
"RTN","RORACK01",105,0)
 ; Return Values:
"RTN","RORACK01",106,0)
 ;        <0  Error Code
"RTN","RORACK01",107,0)
 ;         0  Ok
"RTN","RORACK01",108,0)
 ;
"RTN","RORACK01",109,0)
PROCMSG(REGLST) ;
"RTN","RORACK01",110,0)
 N ACKCODE,BTS,CS,FS,IEN,MSACNT,MSGID,NEXT,PATIEN,RC,REGIEN,RILST,TMP
"RTN","RORACK01",111,0)
 S FS=$G(HL("FS")),CS=$E($G(HL("ECH")),1)
"RTN","RORACK01",112,0)
 Q:(FS="")!(CS="") $$ERROR^RORERR(-40,"PROCESS^RORACK01",,,"HL")
"RTN","RORACK01",113,0)
 K ^TMP("RORACK",$J,"PR")
"RTN","RORACK01",114,0)
 ;--- Compile a list of registry IENs
"RTN","RORACK01",115,0)
 S TMP=""
"RTN","RORACK01",116,0)
 F  S TMP=$O(REGLST(TMP))  Q:TMP=""  D
"RTN","RORACK01",117,0)
 . S IEN=+REGLST(TMP)  S:IEN RILST(IEN)=""
"RTN","RORACK01",118,0)
 ;--- Process acknowledgement messages
"RTN","RORACK01",119,0)
 S RC=0,NEXT=1,(BTS,MSACNT)=0
"RTN","RORACK01",120,0)
 F  X:NEXT HLNEXT  Q:HLQUIT'>0  D  Q:BTS!$$EXIT(.RC)
"RTN","RORACK01",121,0)
 . S NEXT=1
"RTN","RORACK01",122,0)
 . I $P(HLNODE,FS)="BTS"  S BTS=+$P(HLNODE,FS,2)  Q
"RTN","RORACK01",123,0)
 . Q:$P(HLNODE,FS)'="MSA"
"RTN","RORACK01",124,0)
 . S MSACNT=MSACNT+1
"RTN","RORACK01",125,0)
 . S ACKCODE=$P(HLNODE,FS,2),MSGID=$P(HLNODE,FS,3)
"RTN","RORACK01",126,0)
 . Q:$P(MSGID,"-")=""
"RTN","RORACK01",127,0)
 . ;--- Find the registry record
"RTN","RORACK01",128,0)
 . S IEN=$$FINDREC(MSGID,.PATIEN,.REGIEN)
"RTN","RORACK01",129,0)
 . I IEN<0  S RC=IEN  Q
"RTN","RORACK01",130,0)
 . S ^TMP("RORACK",$J,"PR",IEN)=""
"RTN","RORACK01",131,0)
 . Q:'$D(RILST(+REGIEN))
"RTN","RORACK01",132,0)
 . ;--- Analyze the MSA segment and record the message
"RTN","RORACK01",133,0)
 . I ACKCODE="AA"  S RC=$$UPDRREC(IEN)    Q
"RTN","RORACK01",134,0)
 . I ACKCODE="AR"  S RC=$$UPDRREC(IEN,1)  Q
"RTN","RORACK01",135,0)
 . S TMP=$P(HLNODE,FS,4)
"RTN","RORACK01",136,0)
 . D:'(TMP?." ") LOG^RORLOG(6,TMP,PATIEN)
"RTN","RORACK01",137,0)
 . ;--- Record content of the ERR segments
"RTN","RORACK01",138,0)
 . S NEXT=0
"RTN","RORACK01",139,0)
 . F  X HLNEXT  Q:HLQUIT'>0  Q:$P(HLNODE,FS)'="ERR"  D
"RTN","RORACK01",140,0)
 . . S TMP=$$ERR($P(HLNODE,FS,2),PATIEN)
"RTN","RORACK01",141,0)
 ;--- Check if the actual number of messages in the batch is
"RTN","RORACK01",142,0)
 ;--- the same as that from the BTS-2 field
"RTN","RORACK01",143,0)
 I RC'<0  D:BTS'=MSACNT
"RTN","RORACK01",144,0)
 . S TMP="HL7 Batch Message ID: "_$G(HL("MID"))
"RTN","RORACK01",145,0)
 . S RC=$$ERROR^RORERR(-74,"PROCESS^RORACK01",TMP)
"RTN","RORACK01",146,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORACK01",147,0)
 ;
"RTN","RORACK01",148,0)
 ;***** PROCESSES REMAINING REGISTRY RECORDS
"RTN","RORACK01",149,0)
 ;
"RTN","RORACK01",150,0)
 ; .REGLST       Reference to a local variable containing the list
"RTN","RORACK01",151,0)
 ;               of registries associated with the original batch
"RTN","RORACK01",152,0)
 ;               message. The list must have the following structure:
"RTN","RORACK01",153,0)
 ;
"RTN","RORACK01",154,0)
 ;                 REGLST(RegistryName)=RegistryIEN^BatchID
"RTN","RORACK01",155,0)
 ;
"RTN","RORACK01",156,0)
 ; Return Values:
"RTN","RORACK01",157,0)
 ;        <0  Error Code
"RTN","RORACK01",158,0)
 ;         0  Ok
"RTN","RORACK01",159,0)
 ;
"RTN","RORACK01",160,0)
PROCREM(REGLST) ;
"RTN","RORACK01",161,0)
 N BATCHID,BIDLST,IEN,IR,RC,RORMSG,TMP
"RTN","RORACK01",162,0)
 ;--- Compile a list of batch message IDs
"RTN","RORACK01",163,0)
 S IR=""
"RTN","RORACK01",164,0)
 F  S IR=$O(REGLST(IR))  Q:IR=""  D
"RTN","RORACK01",165,0)
 . S TMP=$P(REGLST(IR),U,2)  S:TMP'="" BIDLST(TMP)=""
"RTN","RORACK01",166,0)
 ;--- Acnowledge all remaining messages of the batches
"RTN","RORACK01",167,0)
 S BATCHID="",RC=0
"RTN","RORACK01",168,0)
 F  S BATCHID=$O(BIDLST(BATCHID))  Q:BATCHID=""  D  Q:RC<0
"RTN","RORACK01",169,0)
 . S TMP=BATCHID_"-"
"RTN","RORACK01",170,0)
 . D LIST^DIC(798,,"@","",,TMP,TMP,"AM",,,,"RORMSG")
"RTN","RORACK01",171,0)
 . I $G(DIERR)  D  Q
"RTN","RORACK01",172,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"PROCREM^RORACK01",,798)
"RTN","RORACK01",173,0)
 . S IR=""
"RTN","RORACK01",174,0)
 . F  S IR=$O(^TMP("DILIST",$J,2,IR))  Q:IR=""  D  Q:$$EXIT(.RC)
"RTN","RORACK01",175,0)
 . . S IEN=^TMP("DILIST",$J,2,IR)
"RTN","RORACK01",176,0)
 . . S:'$D(^TMP("RORACK",$J,"PR",IEN)) RC=$$UPDRREC(IEN)
"RTN","RORACK01",177,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORACK01",178,0)
 ;
"RTN","RORACK01",179,0)
 ;***** UPDATES REGISTRY RECORD
"RTN","RORACK01",180,0)
 ;
"RTN","RORACK01",181,0)
 ; IEN           IEN of the local registry record
"RTN","RORACK01",182,0)
 ; [REJECT]      Non-zero value indicates that the message was
"RTN","RORACK01",183,0)
 ;               rejected for reasons unrelated to the content or
"RTN","RORACK01",184,0)
 ;               format (0 by default)
"RTN","RORACK01",185,0)
 ;
"RTN","RORACK01",186,0)
 ; Return Values:
"RTN","RORACK01",187,0)
 ;        <0  Error Code
"RTN","RORACK01",188,0)
 ;         0  Ok
"RTN","RORACK01",189,0)
 ;
"RTN","RORACK01",190,0)
UPDRREC(IEN,REJECT) ;
"RTN","RORACK01",191,0)
 N IENS,RC,RORBUF,RORFDA,RORMSG,TMP
"RTN","RORACK01",192,0)
 S IENS=IEN_","
"RTN","RORACK01",193,0)
 I '$G(REJECT)  S RC=0  D  Q:RC<0 RC
"RTN","RORACK01",194,0)
 . ;--- Load data from the registry record
"RTN","RORACK01",195,0)
 . D GETS^DIQ(798,IENS,"9.1;9.2","I","RORBUF","RORMSG")
"RTN","RORACK01",196,0)
 . I $G(DIERR)  D  Q
"RTN","RORACK01",197,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"UPDRREC^RORACK01",,798,IENS)
"RTN","RORACK01",198,0)
 . ;--- Reset flags and update dates
"RTN","RORACK01",199,0)
 . S RORFDA(798,IENS,3)="@"   ; New patient
"RTN","RORACK01",200,0)
 . S RORFDA(798,IENS,4)="@"   ; Update demographics
"RTN","RORACK01",201,0)
 . S RORFDA(798,IENS,5)="@"   ; Update local registry data
"RTN","RORACK01",202,0)
 . S TMP=$G(RORBUF(798,IENS,9.2,"I"))
"RTN","RORACK01",203,0)
 . S:TMP>$G(RORBUF(798,IENS,9.1,"I")) RORFDA(798,IENS,9.1)=TMP
"RTN","RORACK01",204,0)
 S RORFDA(798,IENS,10)="@"    ; Last message ID
"RTN","RORACK01",205,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORACK01",206,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"UPDRREC^RORACK01",,798,IENS)
"RTN","RORACK01",207,0)
 Q 0
"RTN","RORAPI01")
0^5^B10528729
"RTN","RORAPI01",1,0)
RORAPI01 ;HCIOFO/SG - CLINICAL REGISTRIES API ; 3/29/02 10:22am
"RTN","RORAPI01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORAPI01",3,0)
 ;
"RTN","RORAPI01",4,0)
 ;***** EXAMPLE
"RTN","RORAPI01",5,0)
 ;
"RTN","RORAPI01",6,0)
 N IDSC,INCTVDT,RC
"RTN","RORAPI01",7,0)
 W !!,"Patients",!
"RTN","RORAPI01",8,0)
 S RC=$$PATITER^RORAPI01(.IDSC,"VA HEPC")
"RTN","RORAPI01",9,0)
 I RC<0  W "RC= ",RC,!  Q
"RTN","RORAPI01",10,0)
 F  S RC=$$NEXTPAT^RORAPI01(.IDSC)  Q:RC'>0  D
"RTN","RORAPI01",11,0)
 . S INCTVDT=$P(RC,"^",2)
"RTN","RORAPI01",12,0)
 . W !,$J(+RC,6),$S(INCTVDT:"  "_INCTVDT,1:"")
"RTN","RORAPI01",13,0)
 ;
"RTN","RORAPI01",14,0)
 W !!,"Registries",!
"RTN","RORAPI01",15,0)
 S RC=$$REGITER^RORAPI01(.IDSC,2)
"RTN","RORAPI01",16,0)
 I RC<0  W "RC= ",RC,!  Q
"RTN","RORAPI01",17,0)
 F  S RC=$$NEXTREG^RORAPI01(.IDSC)  Q:RC'>0  D
"RTN","RORAPI01",18,0)
 . S INCTVDT=$P(RC,"^",2)
"RTN","RORAPI01",19,0)
 . W !,$J(+RC,6),$S(INCTVDT:"  "_INCTVDT,1:"")
"RTN","RORAPI01",20,0)
 Q
"RTN","RORAPI01",21,0)
 ;
"RTN","RORAPI01",22,0)
 ;***** RETURNS THE NEXT PATIENT IN THE REGISTRY
"RTN","RORAPI01",23,0)
 ;
"RTN","RORAPI01",24,0)
 ; .IDESC        Reference to the iterator descriptor created
"RTN","RORAPI01",25,0)
 ;               by PATITER^RORAPI01
"RTN","RORAPI01",26,0)
 ;
"RTN","RORAPI01",27,0)
 ; Return Values:
"RTN","RORAPI01",28,0)
 ;       <0  Error code
"RTN","RORAPI01",29,0)
 ;       ""  No more patients in the registry
"RTN","RORAPI01",30,0)
 ;       >0  Patient IEN^Inactivation Date
"RTN","RORAPI01",31,0)
 ;
"RTN","RORAPI01",32,0)
NEXTPAT(IDESC) ;
"RTN","RORAPI01",33,0)
 N IENS,RC,RORFDA,RORMSG
"RTN","RORAPI01",34,0)
 S RC=0
"RTN","RORAPI01",35,0)
 F  D  Q:RC
"RTN","RORAPI01",36,0)
 . ; Get an IEN of the next record in the registry
"RTN","RORAPI01",37,0)
 . S IDESC("IEN")=$O(^RORDATA(798,"AC",IDESC("REGIEN"),IDESC("IEN")))
"RTN","RORAPI01",38,0)
 . I 'IDESC("IEN")  S RC="1^END"  Q
"RTN","RORAPI01",39,0)
 . ;--- Load values of the fields
"RTN","RORAPI01",40,0)
 . S IENS=IDESC("IEN")_","  K RORFDA,RORMSG
"RTN","RORAPI01",41,0)
 . D GETS^DIQ(798,IENS,".01;2;8","EI","RORFDA","RORMSG")
"RTN","RORAPI01",42,0)
 . S RC=$$DBS^RORERR("RORMSG")
"RTN","RORAPI01",43,0)
 . I RC  S RC="-9^"_RC  Q
"RTN","RORAPI01",44,0)
 . ;--- Screen records
"RTN","RORAPI01",45,0)
 . I $G(RORFDA(798,IENS,8,"E"))  D:IDESC("ACT")
"RTN","RORAPI01",46,0)
 . . S RC=RORFDA(798,IENS,.01,"I")
"RTN","RORAPI01",47,0)
 . E  D:IDESC("INACT")
"RTN","RORAPI01",48,0)
 . . S RC=RORFDA(798,IENS,.01,"I")_"^"_$G(RORFDA(798,IENS,2,"I"))
"RTN","RORAPI01",49,0)
 Q $S(RC="1^END":"",1:RC)
"RTN","RORAPI01",50,0)
 ;
"RTN","RORAPI01",51,0)
 ;***** RETURNS THE NEXT REGISTRY FOR THE PATIENT
"RTN","RORAPI01",52,0)
 ;
"RTN","RORAPI01",53,0)
 ; .IDESC        Reference to the iterator descriptor created
"RTN","RORAPI01",54,0)
 ;               by REGITER^RORAPI01
"RTN","RORAPI01",55,0)
 ;
"RTN","RORAPI01",56,0)
 ; Return Values:
"RTN","RORAPI01",57,0)
 ;       <0  Error code
"RTN","RORAPI01",58,0)
 ;       ""  No more registries for the patient
"RTN","RORAPI01",59,0)
 ;       >0  Registry IEN^Inactivation Date
"RTN","RORAPI01",60,0)
 ;
"RTN","RORAPI01",61,0)
NEXTREG(IDESC) ;
"RTN","RORAPI01",62,0)
 N IENS,RC,RORFDA,RORMSG
"RTN","RORAPI01",63,0)
 S RC=0
"RTN","RORAPI01",64,0)
 F  D  Q:RC
"RTN","RORAPI01",65,0)
 . ; Get an IEN of the next record in the registry
"RTN","RORAPI01",66,0)
 . S IDESC("IEN")=$O(^RORDATA(798,"B",IDESC("PATIEN"),IDESC("IEN")))
"RTN","RORAPI01",67,0)
 . I 'IDESC("IEN")  S RC="1^END"  Q
"RTN","RORAPI01",68,0)
 . ;--- Load values of the fields
"RTN","RORAPI01",69,0)
 . S IENS=IDESC("IEN")_","  K RORFDA,RORMSG
"RTN","RORAPI01",70,0)
 . D GETS^DIQ(798,IENS,".02;2;8","EI","RORFDA","RORMSG")
"RTN","RORAPI01",71,0)
 . S RC=$$DBS^RORERR("RORMSG")
"RTN","RORAPI01",72,0)
 . I RC  S RC="-9^"_RC  Q
"RTN","RORAPI01",73,0)
 . ;--- Screen records
"RTN","RORAPI01",74,0)
 . I $G(RORFDA(798,IENS,8,"E"))  D:IDESC("ACT")
"RTN","RORAPI01",75,0)
 . . S RC=RORFDA(798,IENS,.02,"I")
"RTN","RORAPI01",76,0)
 . E  D:IDESC("INACT")
"RTN","RORAPI01",77,0)
 . . S RC=RORFDA(798,IENS,.02,"I")_"^"_$G(RORFDA(798,IENS,2,"I"))
"RTN","RORAPI01",78,0)
 Q $S(RC="1^END":"",1:RC)
"RTN","RORAPI01",79,0)
 ;
"RTN","RORAPI01",80,0)
 ;***** CREATES AN ITERATOR OF PATIENTS IN THE REGISTRY
"RTN","RORAPI01",81,0)
 ;
"RTN","RORAPI01",82,0)
 ; .IDESC        Reference to a local variable where an iterator
"RTN","RORAPI01",83,0)
 ;               descriptor will be created
"RTN","RORAPI01",84,0)
 ; REGNAME       Registry name
"RTN","RORAPI01",85,0)
 ; [MODE]        Bit flags that define iteration mode (3 by default)
"RTN","RORAPI01",86,0)
 ;                 1  Active patients
"RTN","RORAPI01",87,0)
 ;                 2  Inactive patients
"RTN","RORAPI01",88,0)
 ;
"RTN","RORAPI01",89,0)
 ; Return Values:
"RTN","RORAPI01",90,0)
 ;       <0  Error code
"RTN","RORAPI01",91,0)
 ;        0  Ok
"RTN","RORAPI01",92,0)
 ;
"RTN","RORAPI01",93,0)
PATITER(IDESC,REGNAME,MODE) ;
"RTN","RORAPI01",94,0)
 N REGIEN  K IDESC
"RTN","RORAPI01",95,0)
 ;--- Get an IEN of the Registry Parameters
"RTN","RORAPI01",96,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORAPI01",97,0)
 Q:REGIEN<0 REGIEN
"RTN","RORAPI01",98,0)
 ;--- Setup the descriptor
"RTN","RORAPI01",99,0)
 S MODE=$S($G(MODE):MODE,1:3)
"RTN","RORAPI01",100,0)
 S IDESC("REGNAME")=REGNAME
"RTN","RORAPI01",101,0)
 S IDESC("REGIEN")=REGIEN
"RTN","RORAPI01",102,0)
 S IDESC("ACT")=MODE#2
"RTN","RORAPI01",103,0)
 S IDESC("INACT")=MODE\2#2
"RTN","RORAPI01",104,0)
 S IDESC("ROOT")=$$ROOT^DILFD(798,"",1)
"RTN","RORAPI01",105,0)
 S IDESC("IEN")=0
"RTN","RORAPI01",106,0)
 Q 0
"RTN","RORAPI01",107,0)
 ;
"RTN","RORAPI01",108,0)
 ;***** CREATES AN ITERATOR OF THE PATIENT REGISTRIES
"RTN","RORAPI01",109,0)
 ;
"RTN","RORAPI01",110,0)
 ; .IDESC        Reference to a local variable where an iterator
"RTN","RORAPI01",111,0)
 ;               descriptor will be created
"RTN","RORAPI01",112,0)
 ; PATIEN        Patient IEN
"RTN","RORAPI01",113,0)
 ; [MODE]        Bit flags that define iteration mode (3 by default)
"RTN","RORAPI01",114,0)
 ;                 1  Registries where the patient is active
"RTN","RORAPI01",115,0)
 ;                 2  Registries where the patient is inactive
"RTN","RORAPI01",116,0)
 ;
"RTN","RORAPI01",117,0)
 ; Return Values:
"RTN","RORAPI01",118,0)
 ;       <0  Error code
"RTN","RORAPI01",119,0)
 ;        0  Ok
"RTN","RORAPI01",120,0)
 ;
"RTN","RORAPI01",121,0)
REGITER(IDESC,PATIEN,MODE) ;
"RTN","RORAPI01",122,0)
 K IDESC
"RTN","RORAPI01",123,0)
 ;--- Setup the descriptor
"RTN","RORAPI01",124,0)
 S MODE=$S($G(MODE):MODE,1:3)
"RTN","RORAPI01",125,0)
 S IDESC("PATIEN")=PATIEN
"RTN","RORAPI01",126,0)
 S IDESC("ACT")=MODE#2
"RTN","RORAPI01",127,0)
 S IDESC("INACT")=MODE\2#2
"RTN","RORAPI01",128,0)
 S IDESC("ROOT")=$$ROOT^DILFD(798,"",1)
"RTN","RORAPI01",129,0)
 S IDESC("IEN")=0
"RTN","RORAPI01",130,0)
 Q 0
"RTN","RORDD")
0^6^B15127310
"RTN","RORDD",1,0)
RORDD ;HCIOFO/SG - DATA DICTIONARY UTILITIES ; 4/9/02 10:12am
"RTN","RORDD",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORDD",3,0)
 ;
"RTN","RORDD",4,0)
 Q
"RTN","RORDD",5,0)
 ;
"RTN","RORDD",6,0)
 ;***** CHECKS IF THE REGISTRY RECORD IS ACTIVE
"RTN","RORDD",7,0)
 ;
"RTN","RORDD",8,0)
 ; INACTDT       Inactivation date
"RTN","RORDD",9,0)
 ; REACTDT       Reactivation date
"RTN","RORDD",10,0)
 ;
"RTN","RORDD",11,0)
 ; Return Values:
"RTN","RORDD",12,0)
 ;        0  The record is inactive
"RTN","RORDD",13,0)
 ;        1  The record is active
"RTN","RORDD",14,0)
 ;
"RTN","RORDD",15,0)
ACTIVE(INACTDT,REACTDT) ;
"RTN","RORDD",16,0)
 Q $S('INACTDT:1,INACTDT>$$NOW^XLFDT:1,INACTDT<REACTDT:1,1:0)
"RTN","RORDD",17,0)
 ;
"RTN","RORDD",18,0)
 ;***** DISPLAYS A LIST OF APIs DEFINED IN THE SUBFILE #799.23
"RTN","RORDD",19,0)
 ;
"RTN","RORDD",20,0)
 ; IEN           IEN of the current record of the file #799.2
"RTN","RORDD",21,0)
 ;
"RTN","RORDD",22,0)
APILST(IEN) ;
"RTN","RORDD",23,0)
 N D,DIC,DLAYGO,DZ,RORMSG
"RTN","RORDD",24,0)
 S DIC=$$ROOT^DILFD(799.23,","_(+IEN)_",")  Q:DIC=""
"RTN","RORDD",25,0)
 S D=$$GET1^DID(799.23,.01,,"FIELD LENGTH",,"RORMSG")
"RTN","RORDD",26,0)
 D EN^DDIOL($J(1,D),,"?2"),EN^DDIOL("GETS^DIQ",,"?10")
"RTN","RORDD",27,0)
 S DIC(0)="",D="B",DZ="??"
"RTN","RORDD",28,0)
 S DIC("W")="D EN^DDIOL($P(^(0),U,3)_""^""_$P(^(0),U,2),,""?10"")"
"RTN","RORDD",29,0)
 D DQ^DICQ
"RTN","RORDD",30,0)
 Q
"RTN","RORDD",31,0)
 ;
"RTN","RORDD",32,0)
 ;***** VALIDATES A NAME OF THE CALLBACK FUNCTION
"RTN","RORDD",33,0)
 ;
"RTN","RORDD",34,0)
 ; MNFP          Minimal number of formal parameters (opt'l).
"RTN","RORDD",35,0)
 ;               If this parameter has a value greater than 1, the
"RTN","RORDD",36,0)
 ;               function makes very simple check of the number of
"RTN","RORDD",37,0)
 ;               formal parameters in the source code.
"RTN","RORDD",38,0)
 ;
"RTN","RORDD",39,0)
 ; This function is intended for use in the input transforms
"RTN","RORDD",40,0)
 ; of registry definition fields. It kills the X variable if it
"RTN","RORDD",41,0)
 ; contains illegal value.
"RTN","RORDD",42,0)
 ;
"RTN","RORDD",43,0)
 ; The function does not allow to use '%' in the routine and
"RTN","RORDD",44,0)
 ; tag names (this is prohibited by VistA SAC).
"RTN","RORDD",45,0)
 ;
"RTN","RORDD",46,0)
 ; If the function cannot obtain the source code of the callback
"RTN","RORDD",47,0)
 ; function (because the code does not exist yet or has been stripped)
"RTN","RORDD",48,0)
 ; or there are not enough formal parameters in the definition of the
"RTN","RORDD",49,0)
 ; function, it issues a warning but does not reject the value.
"RTN","RORDD",50,0)
 ;
"RTN","RORDD",51,0)
 ; Return Values:
"RTN","RORDD",52,0)
 ;        0  Ok
"RTN","RORDD",53,0)
 ;        1  Illegal name (X is killed)
"RTN","RORDD",54,0)
 ;
"RTN","RORDD",55,0)
EP(MNFP) ;
"RTN","RORDD",56,0)
 Q:$G(X)="" 0
"RTN","RORDD",57,0)
 N ENTPNT,TMP
"RTN","RORDD",58,0)
 ;--- Check if the value has the "$$TAG^ROUTINE" format
"RTN","RORDD",59,0)
 I '(X?2"$"1.8UN1"^"1.8UN)  K X  Q 1
"RTN","RORDD",60,0)
 ;--- Check if the routine exists
"RTN","RORDD",61,0)
 S ENTPNT=X,X=$P(X,U,2)
"RTN","RORDD",62,0)
 X ^%ZOSF("TEST")  E  D  K X  Q 1
"RTN","RORDD",63,0)
 . D EN^DDIOL("The '"_X_"' routine does not exist!")
"RTN","RORDD",64,0)
 S X=ENTPNT
"RTN","RORDD",65,0)
 ;--- Skip the enhanced checks when verifying fields
"RTN","RORDD",66,0)
 Q:$G(DIUTIL)="VERIFY FIELDS" 0
"RTN","RORDD",67,0)
 ;--- Get the line of source code
"RTN","RORDD",68,0)
 S ENTPNT=$P(X,"$$",2),TMP=$TR($P($T(@ENTPNT),";")," ")
"RTN","RORDD",69,0)
 ;--- Display a warning if there is no source line
"RTN","RORDD",70,0)
 I TMP=""  D  Q 0
"RTN","RORDD",71,0)
 . S TMP="Make sure that the '"_$P(ENTPNT,U)_"' tag"
"RTN","RORDD",72,0)
 . D EN^DDIOL(TMP_" exists in the '"_$P(ENTPNT,U,2)_"' routine.")
"RTN","RORDD",73,0)
 ;--- Display a warning if there are not enough formal parameters
"RTN","RORDD",74,0)
 I $G(MNFP)>1,$L(TMP,",")<MNFP  D  Q 0
"RTN","RORDD",75,0)
 . S TMP="Make sure that the entry point has at least "_MNFP
"RTN","RORDD",76,0)
 . D EN^DDIOL(TMP_" formal parameter(s).")
"RTN","RORDD",77,0)
 Q 0
"RTN","RORDD",78,0)
 ;
"RTN","RORDD",79,0)
 ;***** VALIDATES A SELECTION RULE EXPRESSION
"RTN","RORDD",80,0)
 ;
"RTN","RORDD",81,0)
 ; FILE          File number that the expression is associated with
"RTN","RORDD",82,0)
 ;
"RTN","RORDD",83,0)
 ; This function is intended for use in the input transforms
"RTN","RORDD",84,0)
 ; of registry definition fields. It kills the X variable if
"RTN","RORDD",85,0)
 ; it contains an illegal value.
"RTN","RORDD",86,0)
 ;
"RTN","RORDD",87,0)
 ; Return Values:
"RTN","RORDD",88,0)
 ;        0  Ok
"RTN","RORDD",89,0)
 ;        1  Illegal expression (X is killed)
"RTN","RORDD",90,0)
 ;
"RTN","RORDD",91,0)
EXPR(FILE) ;
"RTN","RORDD",92,0)
 Q:($G(FILE)'>0)!($G(X)="") 0
"RTN","RORDD",93,0)
 N EXPR,RC,RESULT,RORERROR,RORLOG,RORPARM,TMP
"RTN","RORDD",94,0)
 ;--- Check if the parser routine exists in the UCI
"RTN","RORDD",95,0)
 S EXPR=X,X="RORUPEX"  X ^%ZOSF("TEST")  S X=EXPR  E  Q 0
"RTN","RORDD",96,0)
 ;--- Parse and validate the expression
"RTN","RORDD",97,0)
 S RC=$$PARSER^RORUPEX(FILE,X,.RESULT)
"RTN","RORDD",98,0)
 Q:RC'<0 0  K X
"RTN","RORDD",99,0)
 ;--- Field does not exist
"RTN","RORDD",100,0)
 I RC=-7   D  Q 1
"RTN","RORDD",101,0)
 . S TMP="One of the referenced fields"
"RTN","RORDD",102,0)
 . D EN^DDIOL(TMP_" does not exist in the file #"_FILE_"!")
"RTN","RORDD",103,0)
 ;--- Syntax error in the expression
"RTN","RORDD",104,0)
 I RC=-21  D  Q 1
"RTN","RORDD",105,0)
 . D EN^DDIOL("Invalid expression: '"_EXPR_"'")
"RTN","RORDD",106,0)
 . D EN^DDIOL("Parsed to: '"_$G(RESULT)_"' ")
"RTN","RORDD",107,0)
 ;--- File does not exist
"RTN","RORDD",108,0)
 I RC=-58  D  Q 1
"RTN","RORDD",109,0)
 . D EN^DDIOL("Referenced file #"_FILE_" does not exist!")
"RTN","RORDD",110,0)
 Q 1
"RTN","RORDD",111,0)
 ;
"RTN","RORDD",112,0)
 ;***** CHECKS IF A FIELD OF A NATIONAL DEFINITION CAN BE DELETED
"RTN","RORDD",113,0)
 ;
"RTN","RORDD",114,0)
 ; FILE          Top-level file number
"RTN","RORDD",115,0)
 ; [IEN]         IEN of the current record of the top-level file
"RTN","RORDD",116,0)
 ; [FIELD]       Number of the NATIONAL field.
"RTN","RORDD",117,0)
 ;               If value of this parameter less than zero, local
"RTN","RORDD",118,0)
 ;               modifications of all records will be prohibited.
"RTN","RORDD",119,0)
 ;               By default, the .09 field is used.
"RTN","RORDD",120,0)
 ;
"RTN","RORDD",121,0)
 ; This function is intended for use in the "DEL" node logic
"RTN","RORDD",122,0)
 ; of registry definition fields.
"RTN","RORDD",123,0)
 ;
"RTN","RORDD",124,0)
 ; Return Values:
"RTN","RORDD",125,0)
 ;        0  The value of the field can be deleted
"RTN","RORDD",126,0)
 ;        1  Deletion is prohibited
"RTN","RORDD",127,0)
 ;
"RTN","RORDD",128,0)
VADEL(FILE,IEN,FIELD) ;
"RTN","RORDD",129,0)
 Q:$G(XPDNM)'="" 0
"RTN","RORDD",130,0)
 ;--- An authorized developer can delete anything
"RTN","RORDD",131,0)
 Q:$G(RORPARM("DEVELOPER")) 0
"RTN","RORDD",132,0)
 ;--- Check if the registry definition is a national one
"RTN","RORDD",133,0)
 N RC,RORMSG
"RTN","RORDD",134,0)
 I $G(FIELD)'<0  S RC=0  D:$G(IEN)>0  Q:'RC 0
"RTN","RORDD",135,0)
 . S:'$G(FIELD) FIELD=.09
"RTN","RORDD",136,0)
 . S RC=$$GET1^DIQ(FILE,IEN_",",FIELD,"I",,"RORMSG")
"RTN","RORDD",137,0)
 D EN^DDIOL("You cannot edit a national registry definition!")
"RTN","RORDD",138,0)
 Q 1
"RTN","RORDD",139,0)
 ;
"RTN","RORDD",140,0)
 ;***** CHECKS IF A FIELD OF A NATIONAL DEFINITION CAN BE EDITED
"RTN","RORDD",141,0)
 ;
"RTN","RORDD",142,0)
 ; FILE          Top-level file number
"RTN","RORDD",143,0)
 ; [IEN]         IEN of the current record of the top-level file
"RTN","RORDD",144,0)
 ; [FIELD]       Number of the NATIONAL field.
"RTN","RORDD",145,0)
 ;               If value of this parameter less than zero, local
"RTN","RORDD",146,0)
 ;               modifications of all records will be prohibited.
"RTN","RORDD",147,0)
 ;               By default, the .09 field is used.
"RTN","RORDD",148,0)
 ;
"RTN","RORDD",149,0)
 ; This function is intended for use in the input transforms
"RTN","RORDD",150,0)
 ; of registry definition fields. It kills the X variable if
"RTN","RORDD",151,0)
 ; it contains illegal value.
"RTN","RORDD",152,0)
 ;
"RTN","RORDD",153,0)
 ; Return Values:
"RTN","RORDD",154,0)
 ;        0  The field can be edited
"RTN","RORDD",155,0)
 ;        1  Editing is prohibited (X is killed)
"RTN","RORDD",156,0)
 ;
"RTN","RORDD",157,0)
VAEDT(FILE,IEN,FIELD) ;
"RTN","RORDD",158,0)
 Q:($G(DIUTIL)="VERIFY FIELDS")!($G(XPDNM)'="") 0
"RTN","RORDD",159,0)
 ;--- An authorized developer can edit anything
"RTN","RORDD",160,0)
 Q:$G(RORPARM("DEVELOPER")) 0
"RTN","RORDD",161,0)
 ;--- Check if the registry definition is a national one
"RTN","RORDD",162,0)
 N RC,RORMSG
"RTN","RORDD",163,0)
 I $G(FIELD)'<0  S RC=0  D:$G(IEN)>0  Q:'RC 0
"RTN","RORDD",164,0)
 . S:'$G(FIELD) FIELD=.09
"RTN","RORDD",165,0)
 . S RC=$$GET1^DIQ(FILE,IEN_",",FIELD,"I",,"RORMSG")
"RTN","RORDD",166,0)
 K X
"RTN","RORDD",167,0)
 D EN^DDIOL("You cannot edit a national registry definition!")
"RTN","RORDD",168,0)
 Q 1
"RTN","RORENV01")
0^7^B3204733
"RTN","RORENV01",1,0)
RORENV01 ;HCIOFO/SG - ENVIRONMENT CHECK ROUTINE (VA HEPC) ; 4/29/02 3:54pm
"RTN","RORENV01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORENV01",3,0)
 ;
"RTN","RORENV01",4,0)
 ; This routine uses the following IAs:
"RTN","RORENV01",5,0)
 ;
"RTN","RORENV01",6,0)
 ; #3557         Access to the field 95.3 of the file #69.9
"RTN","RORENV01",7,0)
 ;
"RTN","RORENV01",8,0)
 ;
"RTN","RORENV01",9,0)
 ;***** CHECKS THE ENVIRONMENT BEFORE THE INSTALLATION
"RTN","RORENV01",10,0)
START ;
"RTN","RORENV01",11,0)
 ;--- Check if any registry process is running
"RTN","RORENV01",12,0)
 D:$G(XPDENV)
"RTN","RORENV01",13,0)
 . L +^RORDATA(798):1  E  D  S XPDABORT=2  Q
"RTN","RORENV01",14,0)
 . . W !,"All registry processes must be stopped before the installation!",!
"RTN","RORENV01",15,0)
 . L -^RORDATA(798)
"RTN","RORENV01",16,0)
 ;--- Check if the historical LOINC mapping has been done
"RTN","RORENV01",17,0)
 I $$LOINCMAP()'>0  S XPDABORT=2  Q
"RTN","RORENV01",18,0)
 ;--- Idle all package event protocols (test sites)
"RTN","RORENV01",19,0)
 K:$G(XPDENV) ^ROR(798.1,"AEP")
"RTN","RORENV01",20,0)
 Q
"RTN","RORENV01",21,0)
 ;
"RTN","RORENV01",22,0)
 ;***** CHECKS IF THE HISTORICAL LOINC MAPPING HAS BEEN DONE
"RTN","RORENV01",23,0)
 ;
"RTN","RORENV01",24,0)
 ; The function checks if the LOINC HISTORICAL MAPPING DATE field
"RTN","RORENV01",25,0)
 ; (95.3) exist in the LABORATORY SITE file (#69.9) and has a
"RTN","RORENV01",26,0)
 ; valid date as a value. This means that the LOINC historical
"RTN","RORENV01",27,0)
 ; mapping has been completed and the Clinical Case Registry
"RTN","RORENV01",28,0)
 ; application can be installed.
"RTN","RORENV01",29,0)
 ;
"RTN","RORENV01",30,0)
 ; FIELD         Field number to check (opt'l, 95.3 by default)
"RTN","RORENV01",31,0)
 ;
"RTN","RORENV01",32,0)
 ; Return Values:
"RTN","RORENV01",33,0)
 ;       <0  Error code
"RTN","RORENV01",34,0)
 ;        0  The mapping has not been done
"RTN","RORENV01",35,0)
 ;        1  Mapping completed
"RTN","RORENV01",36,0)
 ;
"RTN","RORENV01",37,0)
LOINCMAP(FIELD) ;
"RTN","RORENV01",38,0)
 N DATE,RC,RORBUF,RORMSG
"RTN","RORENV01",39,0)
 S FIELD=$S($G(FIELD)>0:+FIELD,1:95.3)
"RTN","RORENV01",40,0)
 ;--- Check if the field exists in the file
"RTN","RORENV01",41,0)
 I '$$VFIELD^DILFD(69.9,FIELD)  D  Q 0
"RTN","RORENV01",42,0)
 . W !,"The LR*5.2*279 patch has not been installed properly!",!
"RTN","RORENV01",43,0)
 ;--- Load the date
"RTN","RORENV01",44,0)
 D LIST^DIC(69.9,,"@;"_FIELD_"I",,1,,,"#",,,"RORBUF","RORMSG")
"RTN","RORENV01",45,0)
 I $G(DIERR)>0  D  Q -9
"RTN","RORENV01",46,0)
 . W !,"FileMan DBS call error(s); File #69.9",!
"RTN","RORENV01",47,0)
 . D MSG^DIALOG("EW",,,,"RORMSG"),CLEAN^DILF
"RTN","RORENV01",48,0)
 . W !,"Cannot get the laboratory site parameters!",!
"RTN","RORENV01",49,0)
 ;--- Check the LOINC historical mapping date
"RTN","RORENV01",50,0)
 S DATE=$G(RORBUF("DILIST","ID",1,FIELD))
"RTN","RORENV01",51,0)
 I DATE'>0  D  Q 0
"RTN","RORENV01",52,0)
 . W !,"You must complete LOINC historical mapping first!",!
"RTN","RORENV01",53,0)
 Q 1
"RTN","RORERR")
0^8^B12068753
"RTN","RORERR",1,0)
RORERR ;HCIOFO/SG - ERROR PROCESSING  ; 3/29/02 10:27am
"RTN","RORERR",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORERR",3,0)
 ;
"RTN","RORERR",4,0)
 Q
"RTN","RORERR",5,0)
 ;
"RTN","RORERR",6,0)
 ;***** INITIALIZES THE ERROR STACK
"RTN","RORERR",7,0)
 ;
"RTN","RORERR",8,0)
 ; [DEFLOC]      Default error location
"RTN","RORERR",9,0)
 ; 
"RTN","RORERR",10,0)
 ; Do not forget to NEW the RORERRDL variable before calling
"RTN","RORERR",11,0)
 ; this procedure!
"RTN","RORERR",12,0)
 ;
"RTN","RORERR",13,0)
CLEAR(DEFLOC) ;
"RTN","RORERR",14,0)
 I $G(RORPARM("ERR"))  K RORERROR("ES")  S:$D(DEFLOC) RORERRDL=DEFLOC
"RTN","RORERR",15,0)
 D CLEAN^DILF
"RTN","RORERR",16,0)
 Q
"RTN","RORERR",17,0)
 ;
"RTN","RORERR",18,0)
 ;***** CHECKS THE ERRORS AFTER A FILEMAN DBS CALL
"RTN","RORERR",19,0)
 ;
"RTN","RORERR",20,0)
 ; ROR8MSG       Closed reference of the error messages array
"RTN","RORERR",21,0)
 ;               (from DBS calls)
"RTN","RORERR",22,0)
 ; [ERRCODE]     Error code to assign
"RTN","RORERR",23,0)
 ; [PLACE]       Location of the error (see the $$ERROR)
"RTN","RORERR",24,0)
 ; [PATIEN]      Patient IEN
"RTN","RORERR",25,0)
 ; [FILE]        File number used in the DBS call
"RTN","RORERR",26,0)
 ; [IENS]        IENS used in the DBS call
"RTN","RORERR",27,0)
 ;
"RTN","RORERR",28,0)
 ; The $$DBS^RORERR function checks the DIERR and @ROR8MSG variables
"RTN","RORERR",29,0)
 ; for errors after a FileMan DBS call.
"RTN","RORERR",30,0)
 ; 
"RTN","RORERR",31,0)
 ; Return Values:
"RTN","RORERR",32,0)
 ;
"RTN","RORERR",33,0)
 ; If there are no errors found, it returns an empty string.
"RTN","RORERR",34,0)
 ; In case of errors, the result depends on value of the ERRCODE
"RTN","RORERR",35,0)
 ; parameter:
"RTN","RORERR",36,0)
 ;
"RTN","RORERR",37,0)
 ; If ERRCODE is omitted or equals 0, the function returns a string
"RTN","RORERR",38,0)
 ; containing the list of error codes separated by comma.
"RTN","RORERR",39,0)
 ; 
"RTN","RORERR",40,0)
 ; If ERRCODE is not zero, the $$ERROR^RORERR function is called and
"RTN","RORERR",41,0)
 ; its return value is returned.
"RTN","RORERR",42,0)
 ;
"RTN","RORERR",43,0)
DBS(ROR8MSG,ERRCODE,PLACE,PATIEN,FILE,IENS) ;
"RTN","RORERR",44,0)
 Q:'$G(DIERR) ""
"RTN","RORERR",45,0)
 N ERRLST,ERRNODE,I,MSGTEXT
"RTN","RORERR",46,0)
 S ERRNODE=$S($G(ROR8MSG)'="":$NA(@ROR8MSG@("DIERR")),1:$NA(^TMP("DIERR",$J)))
"RTN","RORERR",47,0)
 Q:$D(@ERRNODE)<10 ""
"RTN","RORERR",48,0)
 I '$G(ERRCODE)  D  Q $P(ERRLST,",",2,99)
"RTN","RORERR",49,0)
 . S ERRLST="",I=0
"RTN","RORERR",50,0)
 . F  S I=$O(@ERRNODE@(I))  Q:'I  S ERRLST=ERRLST_","_@ERRNODE@(I)
"RTN","RORERR",51,0)
 . D CLEAN^DILF
"RTN","RORERR",52,0)
 D MSG^DIALOG("AE",.MSGTEXT,,,$G(ROR8MSG)),CLEAN^DILF
"RTN","RORERR",53,0)
 S I=$S($G(FILE):"; File #"_FILE,1:"")
"RTN","RORERR",54,0)
 S:$G(IENS)'="" I=I_"; IENS: """_IENS_""""
"RTN","RORERR",55,0)
 Q $$ERROR(ERRCODE,$G(PLACE),.MSGTEXT,.PATIEN,I)
"RTN","RORERR",56,0)
 ;
"RTN","RORERR",57,0)
 ;***** SETS DEFAULT ERROR LOCATION
"RTN","RORERR",58,0)
 ;
"RTN","RORERR",59,0)
 ; DEFLOC        Default error location
"RTN","RORERR",60,0)
 ; 
"RTN","RORERR",61,0)
 ; Do not forget to NEW the RORERRDL variable before calling
"RTN","RORERR",62,0)
 ; this procedure!
"RTN","RORERR",63,0)
 ;
"RTN","RORERR",64,0)
DFLTLOC(DEFLOC) ;
"RTN","RORERR",65,0)
 I $G(RORPARM("ERR"))  S RORERRDL=DEFLOC
"RTN","RORERR",66,0)
 D CLEAN^DILF
"RTN","RORERR",67,0)
 Q
"RTN","RORERR",68,0)
 ;
"RTN","RORERR",69,0)
 ;***** DISPLAYS CONTENT OF THE ERROR STACK
"RTN","RORERR",70,0)
DSPSTK() ;
"RTN","RORERR",71,0)
 Q:'$G(RORPARM("ERR"))!($D(RORERROR("ES"))<10)
"RTN","RORERR",72,0)
 N EPTR,I,TMP
"RTN","RORERR",73,0)
 D DSPSTKL("Err   Message Text",1)
"RTN","RORERR",74,0)
 D DSPSTKL("      Additional info")
"RTN","RORERR",75,0)
 S EPTR=""
"RTN","RORERR",76,0)
 F  S EPTR=$O(RORERROR("ES",EPTR))  Q:EPTR=""  D
"RTN","RORERR",77,0)
 . S TMP=RORERROR("ES",EPTR)
"RTN","RORERR",78,0)
 . D DSPSTKL($J(+TMP,4)_"  "_$P(TMP,U,2),1)
"RTN","RORERR",79,0)
 . S TMP=$G(RORERROR("ES",EPTR,1))
"RTN","RORERR",80,0)
 . D:TMP'="" DSPSTKL("      Location: "_TMP)
"RTN","RORERR",81,0)
 . S I=""
"RTN","RORERR",82,0)
 . F  S I=$O(RORERROR("ES",EPTR,2,I))  Q:I=""  D
"RTN","RORERR",83,0)
 . . D DSPSTKL("      "_RORERROR("ES",EPTR,2,I))
"RTN","RORERR",84,0)
 Q
"RTN","RORERR",85,0)
 ;
"RTN","RORERR",86,0)
 ; MSG           Message to display
"RTN","RORERR",87,0)
 ; [SKIP]        Skip a line before the output
"RTN","RORERR",88,0)
 ;
"RTN","RORERR",89,0)
DSPSTKL(MSG,SKIP) ;
"RTN","RORERR",90,0)
 I '$G(RORPARM("KIDS"))  W:$G(SKIP) !  W MSG,!  Q
"RTN","RORERR",91,0)
 I $G(SKIP)  D BMES^XPDUTL(MSG)  Q
"RTN","RORERR",92,0)
 D MES^XPDUTL(MSG)
"RTN","RORERR",93,0)
 Q
"RTN","RORERR",94,0)
 ;
"RTN","RORERR",95,0)
 ;***** PUTS THE ERROR IN THE ERROR STACK AND LOG FILE
"RTN","RORERR",96,0)
 ;
"RTN","RORERR",97,0)
 ; ERRCODE       Error code. Debug messages, information messages,
"RTN","RORERR",98,0)
 ;               data quality warnings and warnings are not placed
"RTN","RORERR",99,0)
 ;               into the stack. However, they are logged and
"RTN","RORERR",100,0)
 ;               displayed if this is enabled.
"RTN","RORERR",101,0)
 ;
"RTN","RORERR",102,0)
 ; [PLACE]       Location of the error (TAG^ROUTINE).
"RTN","RORERR",103,0)
 ;               If parameter is omitted or empty, default location
"RTN","RORERR",104,0)
 ;               is used (that has been set by CLEAR or DFLTLOC).
"RTN","RORERR",105,0)
 ;
"RTN","RORERR",106,0)
 ; [[.]RORINFO]  Optional additional information (either a string or
"RTN","RORERR",107,0)
 ;               a reference to a local array that contains strings
"RTN","RORERR",108,0)
 ;               prepared for storing in a word processing field)
"RTN","RORERR",109,0)
 ;
"RTN","RORERR",110,0)
 ; [PATIEN]      Patient IEN
"RTN","RORERR",111,0)
 ;
"RTN","RORERR",112,0)
 ; [ARG2-ARG5]   Optional parameters as for $$MSG^RORERR20
"RTN","RORERR",113,0)
 ;               (|1| is substituted by the value of the PATIEN)
"RTN","RORERR",114,0)
 ;
"RTN","RORERR",115,0)
 ; Return Values:
"RTN","RORERR",116,0)
 ;       <0  Error code (value of the ERRCODE)
"RTN","RORERR",117,0)
 ;        0  Ok (if ERRCOCE'<0)
"RTN","RORERR",118,0)
 ;
"RTN","RORERR",119,0)
ERROR(ERRCODE,PLACE,RORINFO,PATIEN,ARG2,ARG3,ARG4,ARG5) ;
"RTN","RORERR",120,0)
 Q:ERRCODE'<0 0
"RTN","RORERR",121,0)
 N IR,MSG,TOP,TYPE
"RTN","RORERR",122,0)
 S:$G(PLACE)="" PLACE=$G(RORERRDL)
"RTN","RORERR",123,0)
 I $D(RORINFO)=1  S IR=RORINFO  K RORINFO  S RORINFO(1)=IR,IR=1
"RTN","RORERR",124,0)
 E  S IR=$O(RORINFO(""),-1)
"RTN","RORERR",125,0)
 S MSG=$$MSG^RORERR20(+ERRCODE,.TYPE,.PATIEN,.ARG2,.ARG3,.ARG4,.ARG5)
"RTN","RORERR",126,0)
 ;--- Put the error to the error stack
"RTN","RORERR",127,0)
 D:$G(RORPARM("ERR"))&(TYPE>4)
"RTN","RORERR",128,0)
 . S (RORERROR("ES"),TOP)=$G(RORERROR("ES"))+1
"RTN","RORERR",129,0)
 . S RORERROR("ES",TOP)=+ERRCODE_U_MSG
"RTN","RORERR",130,0)
 . S RORERROR("ES",TOP,1)=PLACE
"RTN","RORERR",131,0)
 . M:$D(RORINFO) RORERROR("ES",TOP,2)=RORINFO
"RTN","RORERR",132,0)
 ;--- Log the message
"RTN","RORERR",133,0)
 S IR=IR+1,RORINFO(IR)="Location: "_PLACE
"RTN","RORERR",134,0)
 D LOG^RORLOG(TYPE,MSG,$G(PATIEN),.RORINFO),CLEAN^DILF
"RTN","RORERR",135,0)
 Q ERRCODE
"RTN","RORERR10")
0^9^B63310887
"RTN","RORERR10",1,0)
RORERR10 ;HCIOFO/SG - AAC ERROR MESSAGES  ; 4/8/02 9:10am
"RTN","RORERR10",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORERR10",3,0)
 ;
"RTN","RORERR10",4,0)
 Q
"RTN","RORERR10",5,0)
 ;
"RTN","RORERR10",6,0)
 ;***** RETURNS TEXT OF THE MESSAGE
"RTN","RORERR10",7,0)
 ;
"RTN","RORERR10",8,0)
 ; ERRCODE       Error code
"RTN","RORERR10",9,0)
 ; [.TYPE]       Type of the error
"RTN","RORERR10",10,0)
 ;
"RTN","RORERR10",11,0)
MSG(ERRCODE,TYPE) ;
"RTN","RORERR10",12,0)
 S TYPE=6
"RTN","RORERR10",13,0)
 Q:'(ERRCODE?1.8UN) "Illegal error code: '"_ERRCODE_"'"
"RTN","RORERR10",14,0)
 N I,MSG
"RTN","RORERR10",15,0)
 S MSG=$P($T(@ERRCODE),";;",2)
"RTN","RORERR10",16,0)
 S I=+$TR($P(MSG,U)," "),MSG=$P(MSG,U,4,999)
"RTN","RORERR10",17,0)
 S:I>0 TYPE=I
"RTN","RORERR10",18,0)
 Q:MSG?." " "Unknown error ("_ERRCODE_")"
"RTN","RORERR10",19,0)
 Q $$TRIM^XLFSTR(MSG)
"RTN","RORERR10",20,0)
 ;
"RTN","RORERR10",21,0)
 ;***** LIST OF THE MESSAGES (THERE SHOULD BE NOTHING AFTER THE LIST!)
"RTN","RORERR10",22,0)
 ;
"RTN","RORERR10",23,0)
 ; Message Type:
"RTN","RORERR10",24,0)
 ;               1  Debug          4  Warning
"RTN","RORERR10",25,0)
 ;               2  Information    5  Database Error
"RTN","RORERR10",26,0)
 ;               3  Data Quality   6  Error
"RTN","RORERR10",27,0)
 ;
"RTN","RORERR10",28,0)
 ;Type Seg Fld  Message Text
"RTN","RORERR10",29,0)
0 ;; 2 ^   ^   ^ Message accepted
"RTN","RORERR10",30,0)
100 ;; 6 ^   ^   ^ Segment sequence error
"RTN","RORERR10",31,0)
101 ;; 6 ^   ^   ^ Required field missing
"RTN","RORERR10",32,0)
102 ;; 6 ^   ^   ^ Data type error
"RTN","RORERR10",33,0)
103 ;; 6 ^   ^   ^ Table value not found
"RTN","RORERR10",34,0)
200 ;; 6 ^   ^   ^ Unsupported message type
"RTN","RORERR10",35,0)
201 ;; 6 ^   ^   ^ Unsupported event code
"RTN","RORERR10",36,0)
202 ;; 6 ^   ^   ^ Unsupported processing ID
"RTN","RORERR10",37,0)
203 ;; 6 ^   ^   ^ Unsupported version ID
"RTN","RORERR10",38,0)
204 ;; 6 ^   ^   ^ Unknown key identifier
"RTN","RORERR10",39,0)
205 ;; 6 ^   ^   ^ Duplicate key identifier
"RTN","RORERR10",40,0)
206 ;; 6 ^   ^   ^ Application record locked
"RTN","RORERR10",41,0)
207 ;; 6 ^   ^   ^ Application internal error
"RTN","RORERR10",42,0)
010201 ;; 6 ^PID^  2^ Non-numeric ICN
"RTN","RORERR10",43,0)
010202 ;; 6 ^PID^  2^ ICN longer than 16 characters
"RTN","RORERR10",44,0)
010301 ;; 6 ^PID^  3^ Non-numeric DFN
"RTN","RORERR10",45,0)
010302 ;; 6 ^PID^  3^ Non-numeric station number
"RTN","RORERR10",46,0)
010303 ;; 6 ^PID^  3^ Station longer than 3 characters
"RTN","RORERR10",47,0)
010501 ;; 6 ^PID^  5^ Non-alphabetic characters in Family Name
"RTN","RORERR10",48,0)
010502 ;; 6 ^PID^  5^ Family name longer than 35 characters
"RTN","RORERR10",49,0)
010503 ;; 6 ^PID^  5^ Non-alphabetic characters in Given Name
"RTN","RORERR10",50,0)
010504 ;; 6 ^PID^  5^ Given name longer than 25 characters
"RTN","RORERR10",51,0)
010505 ;; 6 ^PID^  5^ Non-alphabetic characters in Middle Initial or Name
"RTN","RORERR10",52,0)
010506 ;; 6 ^PID^  5^ Middle Initial or Name longer than 25 characters
"RTN","RORERR10",53,0)
010701 ;; 6 ^PID^  7^ Non-numeric Date of Birth
"RTN","RORERR10",54,0)
010702 ;; 6 ^PID^  7^ Date of Birth formatted incorrectly
"RTN","RORERR10",55,0)
010801 ;; 6 ^PID^  8^ Invalid Sex value
"RTN","RORERR10",56,0)
011001 ;; 6 ^PID^ 10^ Invalid Race indicator
"RTN","RORERR10",57,0)
011101 ;; 6 ^PID^ 11^ Invalid Zip Code length
"RTN","RORERR10",58,0)
011102 ;; 6 ^PID^ 11^ Zip Code contains non-numeric characters
"RTN","RORERR10",59,0)
011901 ;; 6 ^PID^ 19^ Non-numeric SSN
"RTN","RORERR10",60,0)
011902 ;; 6 ^PID^ 19^ SSN longer than 9 characters
"RTN","RORERR10",61,0)
011903 ;; 6 ^PID^ 19^ SSN shorter than 9 characters
"RTN","RORERR10",62,0)
011904 ;; 6 ^PID^ 19^ Invalid Pseudo SSN indicator
"RTN","RORERR10",63,0)
012901 ;; 6 ^PID^ 29^ Non-numeric Date of Death
"RTN","RORERR10",64,0)
012902 ;; 6 ^PID^ 29^ Date of Death formatted incorrectly
"RTN","RORERR10",65,0)
020201 ;; 6 ^ZSP^  2^ Service Connected Indicator invalid
"RTN","RORERR10",66,0)
020301 ;; 6 ^ZSP^  3^ Service Connected Combined % value non-numeric
"RTN","RORERR10",67,0)
020302 ;; 6 ^ZSP^  3^ Service Connected Combined % over 100
"RTN","RORERR10",68,0)
020401 ;; 6 ^ZSP^  4^ Veteran Era of Service is non alphanumeric
"RTN","RORERR10",69,0)
020402 ;; 6 ^ZSP^  4^ Veteran Era of Service longer than 1 character
"RTN","RORERR10",70,0)
030201 ;; 6 ^ZRD^  2^ Service Connected Codes (Rated Disability) out of bounds
"RTN","RORERR10",71,0)
030301 ;; 6 ^ZRD^  3^ Service Connected % value non-numeric
"RTN","RORERR10",72,0)
030302 ;; 6 ^ZRD^  3^ Service Connected % over 100
"RTN","RORERR10",73,0)
040101 ;; 6 ^CSR^  1^ Registry identifier contains non-alphanumeric characters
"RTN","RORERR10",74,0)
040102 ;; 6 ^CSR^  1^ Registry identifier longer than 30 characters
"RTN","RORERR10",75,0)
040103 ;; 6 ^CSR^  1^ Registry identifier shorter than 3 characters
"RTN","RORERR10",76,0)
040301 ;; 6 ^CSR^  3^ Non-numeric Station number
"RTN","RORERR10",77,0)
040302 ;; 6 ^CSR^  3^ Station longer than 3 characters
"RTN","RORERR10",78,0)
040401 ;; 6 ^CSR^  4^ Non-numeric DFN
"RTN","RORERR10",79,0)
040601 ;; 6 ^CSR^  6^ Date entered into registry has invalid format
"RTN","RORERR10",80,0)
041001 ;; 6 ^CSR^ 10^ Invalid Hep C supporting evidence field
"RTN","RORERR10",81,0)
041401 ;; 6 ^CSR^ 14^ Investigational drugs/Medication in profile indicator non-numeric
"RTN","RORERR10",82,0)
041402 ;; 6 ^CSR^ 14^ Investigational drugs/Medication in profile indicator contains too many characters
"RTN","RORERR10",83,0)
041501 ;; 6 ^CSR^ 15^ Inactivation date has invalid format
"RTN","RORERR10",84,0)
041601 ;; 6 ^CSR^ 16^ Invalid Hep C reason for inactivation
"RTN","RORERR10",85,0)
050101 ;; 6 ^CSP^  1^ Invalid new patient field
"RTN","RORERR10",86,0)
050201 ;; 6 ^CSP^  2^ Reactivation date has invalid format
"RTN","RORERR10",87,0)
060201 ;; 6 ^CSS^  2^ Date of last extraction has invalid format
"RTN","RORERR10",88,0)
070301 ;; 6 ^ORC^  3^ Released date/time has invalid format
"RTN","RORERR10",89,0)
071201 ;; 6 ^ORC^ 12^ Non-integer provider ID
"RTN","RORERR10",90,0)
071501 ;; 6 ^ORC^ 15^ Reactivation date has invalid format
"RTN","RORERR10",91,0)
071701 ;; 6 ^ORC^ 17^ Station has invalid length
"RTN","RORERR10",92,0)
071702 ;; 6 ^ORC^ 17^ Station contains non-alphanumeric characters
"RTN","RORERR10",93,0)
080201 ;; 6 ^RXE^  2^ NDC code has invalid length
"RTN","RORERR10",94,0)
080202 ;; 6 ^RXE^  2^ Drug name has invalid length
"RTN","RORERR10",95,0)
080203 ;; 6 ^RXE^  2^ VA Drug class has invalid length
"RTN","RORERR10",96,0)
080204 ;; 6 ^RXE^  2^ VA Product name has an invalid length
"RTN","RORERR10",97,0)
080205 ;; 6 ^RXE^  2^ VA drug code out of range
"RTN","RORERR10",98,0)
080701 ;; 6 ^RXE^  7^ SIG has invalid length
"RTN","RORERR10",99,0)
081001 ;; 6 ^RXE^ 10^ Amount value below valid range
"RTN","RORERR10",100,0)
081002 ;; 6 ^RXE^ 10^ Amount has invalid length
"RTN","RORERR10",101,0)
081003 ;; 6 ^RXE^ 10^ Amount can only have 2 decimal places
"RTN","RORERR10",102,0)
081004 ;; 6 ^RXE^ 10^ Invalid integer value
"RTN","RORERR10",103,0)
081801 ;; 6 ^RXE^ 18^ Fill date/time has invalid format
"RTN","RORERR10",104,0)
081802 ;; 6 ^RXE^ 18^ Stop date/time has invalid format
"RTN","RORERR10",105,0)
081901 ;; 6 ^RXE^ 19^ Days supply has invalid length
"RTN","RORERR10",106,0)
082001 ;; 6 ^RXE^ 20^ Invalid CMOP indicator
"RTN","RORERR10",107,0)
082401 ;; 6 ^RXE^ 24^ Non-numeric unit/dose
"RTN","RORERR10",108,0)
082402 ;; 6 ^RXE^ 24^ Unit/dose value out of range
"RTN","RORERR10",109,0)
082403 ;; 6 ^RXE^ 24^ Unit/dose can only have 2 decimal places
"RTN","RORERR10",110,0)
083001 ;; 6 ^RXE^ 30^ Invalid Mail/Window code
"RTN","RORERR10",111,0)
090401 ;; 6 ^OBR^  4^ Radiology CPT code does not exist on the CPT-4 Procedure Code File
"RTN","RORERR10",112,0)
090402 ;; 6 ^OBR^  4^ CPT-4 Procedure code longer than 5 characters
"RTN","RORERR10",113,0)
090403 ;; 6 ^OBR^  4^ CPT-4 Procedure code less than 5 characters
"RTN","RORERR10",114,0)
090404 ;; 6 ^OBR^  4^ Invalid procedure code type for CPT-4
"RTN","RORERR10",115,0)
090406 ;; 6 ^OBR^  4^ NLT code shorter than 5 characters
"RTN","RORERR10",116,0)
090407 ;; 6 ^OBR^  4^ NLT code longer than 15 characters
"RTN","RORERR10",117,0)
090701 ;; 6 ^OBR^  7^ Liver Biopsy date has invalid format
"RTN","RORERR10",118,0)
090702 ;; 6 ^OBR^  7^ Autopsy date has invalid format
"RTN","RORERR10",119,0)
090703 ;; 6 ^OBR^  7^ Exam date has invalid format
"RTN","RORERR10",120,0)
090704 ;; 6 ^OBR^  7^ Accession date has invalid format
"RTN","RORERR10",121,0)
091601 ;; 6 ^OBR^ 16^ Non-integer provider ID
"RTN","RORERR10",122,0)
094401 ;; 6 ^OBR^ 44^ Liver Biopsy station non-alphanumeric
"RTN","RORERR10",123,0)
094402 ;; 6 ^OBR^ 44^ Liver Biopsy station less than 3 characters long
"RTN","RORERR10",124,0)
094403 ;; 6 ^OBR^ 44^ Liver Biopsy station longer than 7 characters long
"RTN","RORERR10",125,0)
094404 ;; 6 ^OBR^ 44^ Autopsy station non-alphanumeric
"RTN","RORERR10",126,0)
094405 ;; 6 ^OBR^ 44^ Autopsy station less than 3 characters long
"RTN","RORERR10",127,0)
094406 ;; 6 ^OBR^ 44^ Autopsy station longer than 7 characters long
"RTN","RORERR10",128,0)
094407 ;; 6 ^OBR^ 44^ Radiology station non-alphanumeric
"RTN","RORERR10",129,0)
094408 ;; 6 ^OBR^ 44^ Radiology station less than 3 characters long
"RTN","RORERR10",130,0)
094409 ;; 6 ^OBR^ 44^ Radiology station longer than 7 characters long
"RTN","RORERR10",131,0)
094410 ;; 6 ^OBR^ 44^ Lab station non-alphanumeric
"RTN","RORERR10",132,0)
094411 ;; 6 ^OBR^ 44^ Lab station less than 3 characters long
"RTN","RORERR10",133,0)
094412 ;; 6 ^OBR^ 44^ Lab station longer than 7 characters long
"RTN","RORERR10",134,0)
100301 ;; 6 ^OBX^  3^ Code does not exist within Loinc table
"RTN","RORERR10",135,0)
100302 ;; 6 ^OBX^  3^ NLT code shorter than 5 characters
"RTN","RORERR10",136,0)
100303 ;; 6 ^OBX^  3^ NLT code longer than 15 characters
"RTN","RORERR10",137,0)
100501 ;; 6 ^OBX^  5^ Result longer than 60 characters
"RTN","RORERR10",138,0)
100601 ;; 6 ^OBX^  6^ Units shorter than 2 characters
"RTN","RORERR10",139,0)
100602 ;; 6 ^OBX^  6^ Units longer than 10 characters
"RTN","RORERR10",140,0)
100701 ;; 6 ^OBX^  7^ Range High longer than 50 characters
"RTN","RORERR10",141,0)
100702 ;; 6 ^OBX^  7^ Range Low longer than 50 characters
"RTN","RORERR10",142,0)
101501 ;; 6 ^OBX^ 15^ Site/specimen shorter than 2 characters
"RTN","RORERR10",143,0)
101502 ;; 6 ^OBX^ 15^ Site/specimen longer than 80 characters
"RTN","RORERR10",144,0)
110301 ;; 6 ^NTE^  3^ Comment shorter than 1 character
"RTN","RORERR10",145,0)
110302 ;; 6 ^NTE^  3^ Comment longer than 68 characters
"RTN","RORERR20")
0^10^B35894669
"RTN","RORERR20",1,0)
RORERR20 ;HCIOFO/SG - LIST OF ERROR MESSAGES  ; 5/6/02 9:48am
"RTN","RORERR20",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORERR20",3,0)
 ;
"RTN","RORERR20",4,0)
 ;***** RETURNS TEXT OF THE MESSAGE
"RTN","RORERR20",5,0)
 ;
"RTN","RORERR20",6,0)
 ; ERRCODE       Error code
"RTN","RORERR20",7,0)
 ; [.TYPE]       Type of the error
"RTN","RORERR20",8,0)
 ; [ARG1-ARG5]   Optional parameters that substitute the |n| "windows"
"RTN","RORERR20",9,0)
 ;               in the text of the message (for example, the |2| will
"RTN","RORERR20",10,0)
 ;               be substituted by the value of the ARG2).
"RTN","RORERR20",11,0)
 ;
"RTN","RORERR20",12,0)
MSG(ERRCODE,TYPE,ARG1,ARG2,ARG3,ARG4,ARG5) ;
"RTN","RORERR20",13,0)
 S TYPE=6  Q:ERRCODE'<0 ""
"RTN","RORERR20",14,0)
 N ARG,I1,I2,MSG
"RTN","RORERR20",15,0)
 ;--- Get a descriptor of the message
"RTN","RORERR20",16,0)
 S I1=-ERRCODE,MSG=$P($T(MSGLIST+I1),";;",2)
"RTN","RORERR20",17,0)
 S I1=+$TR($P(MSG,U,2)," "),MSG=$P(MSG,U,3,999)
"RTN","RORERR20",18,0)
 S:I1>0 TYPE=I1
"RTN","RORERR20",19,0)
 Q:MSG?." " "Unknown error ("_ERRCODE_")"
"RTN","RORERR20",20,0)
 ;--- Substitute parameters
"RTN","RORERR20",21,0)
 S I1=2
"RTN","RORERR20",22,0)
 F  S I1=$F(MSG,"|",I1-1)  Q:'I1  D
"RTN","RORERR20",23,0)
 . S I2=$F(MSG,"|",I1)  Q:'I2
"RTN","RORERR20",24,0)
 . X "S ARG=$G(ARG"_+$TR($E(MSG,I1,I2-2)," ")_")"
"RTN","RORERR20",25,0)
 . S $E(MSG,I1-1,I2-1)=ARG
"RTN","RORERR20",26,0)
 Q $$TRIM^XLFSTR(MSG)
"RTN","RORERR20",27,0)
 ;
"RTN","RORERR20",28,0)
 ;***** RETURNS TYPE OF THE MESSAGE
"RTN","RORERR20",29,0)
 ;
"RTN","RORERR20",30,0)
 ; ERRCODE       Error code
"RTN","RORERR20",31,0)
 ;
"RTN","RORERR20",32,0)
TYPE(ERRCODE) ;
"RTN","RORERR20",33,0)
 Q:ERRCODE'<0 0
"RTN","RORERR20",34,0)
 N I,TYPE  S I=-ERRCODE
"RTN","RORERR20",35,0)
 S I=$P($T(MSGLIST+I),";;",2),TYPE=+$TR($P(I,U,2)," ")
"RTN","RORERR20",36,0)
 Q $S(TYPE>0:TYPE,1:6)
"RTN","RORERR20",37,0)
 ;
"RTN","RORERR20",38,0)
 ;***** LIST OF THE MESSAGES (THERE SHOULD BE NOTHING AFTER THE LIST!)
"RTN","RORERR20",39,0)
 ;
"RTN","RORERR20",40,0)
 ; The error codes are provided in the table only for clarity.
"RTN","RORERR20",41,0)
 ; Text of the messages are extracted using the $TEXT function and
"RTN","RORERR20",42,0)
 ; absolute values of the ERRCODE parameter.
"RTN","RORERR20",43,0)
 ;
"RTN","RORERR20",44,0)
 ; Message Type:
"RTN","RORERR20",45,0)
 ;               1  Debug          4  Warning
"RTN","RORERR20",46,0)
 ;               2  Information    5  Database Error
"RTN","RORERR20",47,0)
 ;               3  Data Quality   6  Error
"RTN","RORERR20",48,0)
 ;
"RTN","RORERR20",49,0)
MSGLIST ; Code Type  Message Text
"RTN","RORERR20",50,0)
 ;;  -1 ^ 6 ^ Cannot find a descriptor of the registry
"RTN","RORERR20",51,0)
 ;;  -2 ^ 6 ^ Duplicate registry names
"RTN","RORERR20",52,0)
 ;;  -3 ^ 6 ^ Cannot find a descriptor of the rule
"RTN","RORERR20",53,0)
 ;;  -4 ^ 6 ^ Duplicate rule names
"RTN","RORERR20",54,0)
 ;;  -5 ^ 6 ^ Circle rule references
"RTN","RORERR20",55,0)
 ;;  -6 ^ 6 ^ Illegal update entry point: |2|
"RTN","RORERR20",56,0)
 ;;  -7 ^ 6 ^ Field '|2|' not found
"RTN","RORERR20",57,0)
 ;;  -8 ^ 6 ^ Duplicate patients in the registry
"RTN","RORERR20",58,0)
 ;;  -9 ^ 5 ^ FileMan DBS call error(s)|2|
"RTN","RORERR20",59,0)
 ;; -10 ^ 6 ^ Bad registry name: '|2|'
"RTN","RORERR20",60,0)
 ;; -11 ^ 6 ^ Cannot lock the record(s) of |2|
"RTN","RORERR20",61,0)
 ;; -12 ^ 6 ^ Cannot load and prepare lab search data
"RTN","RORERR20",62,0)
 ;; -13 ^ 6 ^ Cannot lock the registries
"RTN","RORERR20",63,0)
 ;; -14 ^ 6 ^ Cannot prepare selection rules
"RTN","RORERR20",64,0)
 ;; -15 ^ 6 ^ Error(s) during processing of the patient data
"RTN","RORERR20",65,0)
 ;; -16 ^ 6 ^ Cannot update demographic data
"RTN","RORERR20",66,0)
 ;; -17 ^ 6 ^ Illegal entry point: '|2|'
"RTN","RORERR20",67,0)
 ;; -18 ^ 6 ^ Routine '|2|' does not exist
"RTN","RORERR20",68,0)
 ;; -19 ^ 6 ^ Cannot load the selection rules
"RTN","RORERR20",69,0)
 ;; -20 ^ 6 ^ Cannot sort the selection rules
"RTN","RORERR20",70,0)
 ;; -21 ^ 6 ^ Syntax error in the expression
"RTN","RORERR20",71,0)
 ;; -22 ^ 6 ^ Cannot prepare data extraction definitions
"RTN","RORERR20",72,0)
 ;; -23 ^ 6 ^ Cannot set up HL7 environment variables
"RTN","RORERR20",73,0)
 ;; -24 ^ 6 ^ Cannot send the batch HL7 message
"RTN","RORERR20",74,0)
 ;; -25 ^ 6 ^ No event driver protocol
"RTN","RORERR20",75,0)
 ;; -26 ^ 3 ^ Neither ICN nor SSN is available
"RTN","RORERR20",76,0)
 ;; -27 ^ 5 ^ Cannot obtain results of the Lab tests
"RTN","RORERR20",77,0)
 ;; -28 ^ 4 ^ No active registries to |2|!
"RTN","RORERR20",78,0)
 ;; -29 ^ 6 ^ Non-exisitent LOINC code |2| in the registry parameters
"RTN","RORERR20",79,0)
 ;; -30 ^ 5 ^ Duplicate records in the file #95.3 for LOINC code |2|
"RTN","RORERR20",80,0)
 ;; -31 ^ 4 ^ Cannot remove the patient #|1| from the pending list
"RTN","RORERR20",81,0)
 ;; -32 ^ 6 ^ Incorrect data extraction period: '|2|-|3|'
"RTN","RORERR20",82,0)
 ;; -33 ^ 6 ^ Cannot deque data extraction task
"RTN","RORERR20",83,0)
 ;; -34 ^ 6 ^ Cannot open an output file
"RTN","RORERR20",84,0)
 ;; -35 ^ 6 ^ Device Handler error
"RTN","RORERR20",85,0)
 ;; -36 ^ 6 ^ Cannot retrieve Patient details (DFN:|2|) from File #|3|
"RTN","RORERR20",86,0)
 ;; -37 ^ 6 ^ Cannot retrieve details of medication
"RTN","RORERR20",87,0)
 ;; -38 ^ 6 ^ Cannot retrieve CPT code
"RTN","RORERR20",88,0)
 ;; -39 ^ 6 ^ Duplicate HL7 message ID in the file #798: '|2|'
"RTN","RORERR20",89,0)
 ;; -40 ^ 6 ^ Undefined variable: '|2|'
"RTN","RORERR20",90,0)
 ;; -41 ^ 2 ^ Registry setup has been completed
"RTN","RORERR20",91,0)
 ;; -42 ^ 4 ^ Task has been interrupted by user
"RTN","RORERR20",92,0)
 ;; -43 ^ 6 ^ Error during the |2|. See log files.
"RTN","RORERR20",93,0)
 ;; -44 ^ 6 ^ Illegal extraction entry point: |2|
"RTN","RORERR20",94,0)
 ;; -45 ^ 6 ^ Illegal or missing IEN of selection rule
"RTN","RORERR20",95,0)
 ;; -46 ^ 5 ^ Cannot load registry parameters
"RTN","RORERR20",96,0)
 ;; -47 ^ 5 ^ Cannot find the '|2|' drug class
"RTN","RORERR20",97,0)
 ;; -48 ^ 2 ^ Registry '|2|' is inactive
"RTN","RORERR20",98,0)
 ;; -49 ^ 4 ^ Registry '|2|' is awaiting ACK
"RTN","RORERR20",99,0)
 ;; -50 ^ 6 ^ Cannot create the '|2|' checkpoint!
"RTN","RORERR20",100,0)
 ;; -51 ^ 6 ^ Cannot complete the '|2|' checkpoint!
"RTN","RORERR20",101,0)
 ;; -52 ^ 6 ^ Cannot find HL7 message ID in the file #798: '|2|'
"RTN","RORERR20",102,0)
 ;; -53 ^ 6 ^ Cannot enable the '|2|' protocol
"RTN","RORERR20",103,0)
 ;; -54 ^ 6 ^ The '|2|' Lab Search is not defined
"RTN","RORERR20",104,0)
 ;; -55 ^ 4 ^ No indicators are defined for the '|2|' Lab Search
"RTN","RORERR20",105,0)
 ;; -56 ^ 6 ^ Error code '|2|' is returned by the '|3|'
"RTN","RORERR20",106,0)
 ;; -57 ^ 3 ^ Error code '|2|' is returned by the '|3|'
"RTN","RORERR20",107,0)
 ;; -58 ^ 6 ^ File '|2|' not found
"RTN","RORERR20",108,0)
 ;; -59 ^ 3 ^ ICN checksum is shorter than 6 digits
"RTN","RORERR20",109,0)
 ;; -60 ^ 6 ^ Subtask #|2| crashed (see TaskMan logs)
"RTN","RORERR20",110,0)
 ;; -61 ^ 6 ^ Cannot start the registry update in multitask mode
"RTN","RORERR20",111,0)
 ;; -62 ^ 2 ^ Registry Update subtask #|2| has been scheduled
"RTN","RORERR20",112,0)
 ;; -63 ^ 6 ^ Data search in file #|2| is not supported
"RTN","RORERR20",113,0)
 ;; -64 ^ 6 ^ Data element #|3| (file #|2|) is not supported
"RTN","RORERR20",114,0)
 ;; -65 ^ 6 ^ |4| value of element #|3| (file #|2|) is not supported
"RTN","RORERR20",115,0)
 ;; -66 ^ 1 ^ Patient was skipped due to counter in the file #798.3
"RTN","RORERR20",116,0)
 ;; -67 ^ 6 ^ No application acknowledgement for |2| day(s)
"RTN","RORERR20",117,0)
 ;; -68 ^ 6 ^ Illegal header of the HL7 message (or no header at all)
"RTN","RORERR20",118,0)
 ;; -69 ^ 6 ^ Cannot find the data element
"RTN","RORERR20",119,0)
 ;; -70 ^ 6 ^ Duplicate names of the data element
"RTN","RORERR20",120,0)
 ;; -71 ^ 1 ^ User entered the "^"
"RTN","RORERR20",121,0)
 ;; -72 ^ 6 ^ Timeout
"RTN","RORERR20",122,0)
 ;; -73 ^ 4 ^ Invalid or expired applic. acknowledgement was received
"RTN","RORERR20",123,0)
 ;; -74 ^ 6 ^ Number of messages in the batch does not match the BTS
"RTN","ROREVT01")
0^80^B4150665
"RTN","ROREVT01",1,0)
ROREVT01 ;HCIOFO/SG - EVENT PROTOCOLS  ; 5/8/02 8:11am
"RTN","ROREVT01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","ROREVT01",3,0)
 ;
"RTN","ROREVT01",4,0)
 ; This routine uses the following IAs:
"RTN","ROREVT01",5,0)
 ;
"RTN","ROREVT01",6,0)
 ; #1181         Subscription to the DGPM MOVEMENT EVENT protocol
"RTN","ROREVT01",7,0)
 ; #1298         Subscription to the PXK VISIT DATA EVENT protocol
"RTN","ROREVT01",8,0)
 ; #3565         Subscription to the LR7O ALL EVSEND RESULTS protocol
"RTN","ROREVT01",9,0)
 ;
"RTN","ROREVT01",10,0)
 Q
"RTN","ROREVT01",11,0)
 ;
"RTN","ROREVT01",12,0)
 ;***** 'ROR EVENT LAB' PROTOCOL IMPLEMENTATION (DATA AREA #1)
"RTN","ROREVT01",13,0)
LAB ;
"RTN","ROREVT01",14,0)
 Q:$G(OREMSG)=""
"RTN","ROREVT01",15,0)
 N BUF,DATE,DONE,FS,I,PATIEN
"RTN","ROREVT01",16,0)
 S I="",DONE="00"
"RTN","ROREVT01",17,0)
 F  S I=$O(@OREMSG@(I))  Q:I=""  D  Q:DONE="11"
"RTN","ROREVT01",18,0)
 . S BUF=$G(@OREMSG@(I))
"RTN","ROREVT01",19,0)
 . ;--- Get the HL7 field separator
"RTN","ROREVT01",20,0)
 . I $G(FS)=""  S:$E(BUF,1,3)="MSH" FS=$E(BUF,4)  Q:$G(FS)=""
"RTN","ROREVT01",21,0)
 . ;--- Get the patient IEN
"RTN","ROREVT01",22,0)
 . I $P(BUF,FS)="PID"  D:'$E(DONE,1)  Q
"RTN","ROREVT01",23,0)
 . . S PATIEN=+$P(BUF,FS,4)              ; PID-3
"RTN","ROREVT01",24,0)
 . . S:PATIEN>0 $E(DONE,1)="1"
"RTN","ROREVT01",25,0)
 . ;--- Get the specimen date
"RTN","ROREVT01",26,0)
 . I $P(BUF,FS)="OBR"  D:'$E(DONE,2)  Q
"RTN","ROREVT01",27,0)
 . . S DATE=$$HL7TFM^XLFDT($P(BUF,FS,8)) ; OBR-7
"RTN","ROREVT01",28,0)
 . . S $E(DONE,2)="1"
"RTN","ROREVT01",29,0)
 ;--- Create the event reference
"RTN","ROREVT01",30,0)
 S:DONE="11" I=$$ADD^RORUPP02(PATIEN,1,DATE)
"RTN","ROREVT01",31,0)
 Q
"RTN","ROREVT01",32,0)
 ;
"RTN","ROREVT01",33,0)
 ;***** RETURNS THE LIST OF PACKAGE EVENT PROTOCOLS
"RTN","ROREVT01",34,0)
 ;
"RTN","ROREVT01",35,0)
 ; .EPLST        Reference to a local variable. The list of
"RTN","ROREVT01",36,0)
 ;               package event protocols will be returned via
"RTN","ROREVT01",37,0)
 ;               this parameter: EPLST(ProtocolName)=""
"RTN","ROREVT01",38,0)
 ;
"RTN","ROREVT01",39,0)
LIST(EPLST) ;
"RTN","ROREVT01",40,0)
 K EPLST
"RTN","ROREVT01",41,0)
 S EPLST("ROR EVENT LAB")=""
"RTN","ROREVT01",42,0)
 S EPLST("ROR EVENT PTF")=""
"RTN","ROREVT01",43,0)
 S EPLST("ROR EVENT VISIT")=""
"RTN","ROREVT01",44,0)
 Q
"RTN","ROREVT01",45,0)
 ;
"RTN","ROREVT01",46,0)
 ;***** 'ROR EVENT PTF' PROTOCOL IMPLEMENTATION (DATA AREA #3)
"RTN","ROREVT01",47,0)
PTF ;
"RTN","ROREVT01",48,0)
 N PATIEN,RC
"RTN","ROREVT01",49,0)
 S PATIEN=$P($G(DGPMA),"^",3)  Q:PATIEN'>0
"RTN","ROREVT01",50,0)
 ;--- Create the event reference
"RTN","ROREVT01",51,0)
 S RC=$$ADD^RORUPP02(PATIEN,3,$P(DGPMA,"^"))
"RTN","ROREVT01",52,0)
 Q
"RTN","ROREVT01",53,0)
 ;
"RTN","ROREVT01",54,0)
 ;***** 'ROR EVENT VISIT' PROTOCOL IMPLEMENTATION (DATA AREA #2)
"RTN","ROREVT01",55,0)
VISIT ;
"RTN","ROREVT01",56,0)
 N BUF,IEN,PATIEN,RC,VSIEN
"RTN","ROREVT01",57,0)
 S VSIEN=""
"RTN","ROREVT01",58,0)
 F  S VSIEN=$O(^TMP("PXKCO",$J,VSIEN))  Q:VSIEN=""  D
"RTN","ROREVT01",59,0)
 . S IEN=""
"RTN","ROREVT01",60,0)
 . F  S IEN=$O(^TMP("PXKCO",$J,VSIEN,"VST",IEN))  Q:IEN=""  D
"RTN","ROREVT01",61,0)
 . . S BUF=$G(^TMP("PXKCO",$J,VSIEN,"VST",IEN,0,"AFTER"))
"RTN","ROREVT01",62,0)
 . . S PATIEN=$P(BUF,"^",5)  Q:(PATIEN'>0)!$P(BUF,"^",11)
"RTN","ROREVT01",63,0)
 . . ;--- Create the event reference
"RTN","ROREVT01",64,0)
 . . S RC=$$ADD^RORUPP02(PATIEN,2,$P(BUF,"^",2))
"RTN","ROREVT01",65,0)
 Q
"RTN","ROREXPR")
0^11^B8210396
"RTN","ROREXPR",1,0)
ROREXPR ;HCIOFO/SG - PREPARATION FOR DATA EXTRACTION  ; 4/5/02 9:06am
"RTN","ROREXPR",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","ROREXPR",3,0)
 ;
"RTN","ROREXPR",4,0)
 Q
"RTN","ROREXPR",5,0)
 ;
"RTN","ROREXPR",6,0)
 ;***** PREPARES VARIABLES FOR DATA EXTRACTION
"RTN","ROREXPR",7,0)
 ;
"RTN","ROREXPR",8,0)
 ; REGNAME       Registry name
"RTN","ROREXPR",9,0)
 ;
"RTN","ROREXPR",10,0)
 ; [DXBEG]       Data extraction start date (individual start
"RTN","ROREXPR",11,0)
 ;               date for each patient by default).
"RTN","ROREXPR",12,0)
 ;               Time part of the parameter value is ignored.
"RTN","ROREXPR",13,0)
 ;
"RTN","ROREXPR",14,0)
 ; [DXEND]       Data extraction end date (TODAY by default)
"RTN","ROREXPR",15,0)
 ;               Time part of the parameter value is ignored.
"RTN","ROREXPR",16,0)
 ;
"RTN","ROREXPR",17,0)
 ; DXBEG and DXEND parameters may be used only for historical data
"RTN","ROREXPR",18,0)
 ; extraction. Use of these parameters for regular data extraction
"RTN","ROREXPR",19,0)
 ; process will negatively affect the package!
"RTN","ROREXPR",20,0)
 ;
"RTN","ROREXPR",21,0)
 ; Return Values:
"RTN","ROREXPR",22,0)
 ;        0  Ok
"RTN","ROREXPR",23,0)
 ;       <0  Error code
"RTN","ROREXPR",24,0)
 ;
"RTN","ROREXPR",25,0)
PREPARE(REGNAME,DXBEG,DXEND) ;
"RTN","ROREXPR",26,0)
 N RORERRDL      ; Default error location
"RTN","ROREXPR",27,0)
 ;
"RTN","ROREXPR",28,0)
 N DTAREA,IL,IR,RC,REGIEN,RORMSG,SEGNAME,TMP
"RTN","ROREXPR",29,0)
 D DFLTLOC^RORERR("PREPARE^ROREXPR")
"RTN","ROREXPR",30,0)
 K ROREXT("HL7"),ROREXT("DXBEG"),ROREXT("LD"),RORLRC
"RTN","ROREXPR",31,0)
 S DXBEG=$G(DXBEG)\1,DXEND=$G(DXEND)\1
"RTN","ROREXPR",32,0)
 ;--- Data extraction period
"RTN","ROREXPR",33,0)
 S ROREXT("DXEND")=$S(DXEND>0:DXEND,1:$$DT^XLFDT)
"RTN","ROREXPR",34,0)
 I DXBEG>0  S RC=0  D  Q:RC<0 RC
"RTN","ROREXPR",35,0)
 . S ROREXT("DXBEG")=DXBEG  Q:DXBEG'>ROREXT("DXEND")
"RTN","ROREXPR",36,0)
 . S RC=$$ERROR^RORERR(-32,"PREPARE^ROREXPR",,,DXBEG,ROREXT("DXEND"))
"RTN","ROREXPR",37,0)
 ;--- Get the registry IEN and some parameters
"RTN","ROREXPR",38,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME,"7;10;13E;15.1",.RORBUF)
"RTN","ROREXPR",39,0)
 Q:REGIEN<0 REGIEN
"RTN","ROREXPR",40,0)
 S ROREXT("EXTRDAYS")=$G(RORBUF("DILIST","ID",1,7))
"RTN","ROREXPR",41,0)
 S ROREXT("HL7PROT")=$G(RORBUF("DILIST","ID",1,13))
"RTN","ROREXPR",42,0)
 ;--- Setup the lag interval (for regular data extraction only)
"RTN","ROREXPR",43,0)
 D:'$G(ROREXT("DXBEG"))
"RTN","ROREXPR",44,0)
 . S TMP=$G(RORBUF("DILIST","ID",1,15.1))
"RTN","ROREXPR",45,0)
 . S ROREXT("LD",1)=$S(TMP>0:TMP,1:1)
"RTN","ROREXPR",46,0)
 ;--- Setup the message builder call-back entry point
"RTN","ROREXPR",47,0)
 S TMP=$$TRIM^XLFSTR($G(RORBUF("DILIST","ID",1,10)))
"RTN","ROREXPR",48,0)
 I TMP'=""  D  Q:RC<0 $$ERROR^RORERR(-44,,REGNAME,,TMP)
"RTN","ROREXPR",49,0)
 . S RC=$$VERIFYEP^RORUTL01(TMP)
"RTN","ROREXPR",50,0)
 . S:RC'<0 ROREXT("MSGBLD")=TMP
"RTN","ROREXPR",51,0)
 ;--- Load and prepare segment descriptors
"RTN","ROREXPR",52,0)
 S TMP=","_REGIEN_","
"RTN","ROREXPR",53,0)
 D LIST^DIC(798.19,TMP,"@;.01;.02I;1",,,,,"B",,,,"RORMSG")
"RTN","ROREXPR",54,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.19,TMP)
"RTN","ROREXPR",55,0)
 S IR=""
"RTN","ROREXPR",56,0)
 F  S IR=$O(^TMP("DILIST",$J,"ID",IR))  Q:IR=""  D
"RTN","ROREXPR",57,0)
 . S SEGNAME=^TMP("DILIST",$J,"ID",IR,.01)
"RTN","ROREXPR",58,0)
 . S DTAREA=+$G(^TMP("DILIST",$J,"ID",IR,.02))
"RTN","ROREXPR",59,0)
 . S TMP=$G(^TMP("DILIST",$J,"ID",IR,1))
"RTN","ROREXPR",60,0)
 . S $P(ROREXT("HL7",DTAREA,SEGNAME),U,2)=TMP
"RTN","ROREXPR",61,0)
 ;--- Load list of codes of extracted Lab results
"RTN","ROREXPR",62,0)
 S TMP=","_REGIEN_","
"RTN","ROREXPR",63,0)
 D LIST^DIC(798.112,TMP,"@;.01;.02",,,,,"B",,,,"RORMSG")
"RTN","ROREXPR",64,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"PREPARE^ROREXPR",,798.112,TMP)
"RTN","ROREXPR",65,0)
 Q:'$G(^TMP("DILIST",$J,0)) 0
"RTN","ROREXPR",66,0)
 S (IL,IR,RC)=0
"RTN","ROREXPR",67,0)
 F  S IR=$O(^TMP("DILIST",$J,"ID",IR))  Q:IR=""  D  Q:RC
"RTN","ROREXPR",68,0)
 . S TMP=$G(^TMP("DILIST",$J,"ID",IR,.01))
"RTN","ROREXPR",69,0)
 . I TMP="*"  K RORLRC  S RORLRC="*",RC=1  Q
"RTN","ROREXPR",70,0)
 . I TMP>0  D  Q:RC<0  S IL=IL+1,RORLRC(IL)=TMP_"^LN"
"RTN","ROREXPR",71,0)
 . . S TMP=$$LNCODE^RORUTL02(TMP)  S:TMP<0 RC=TMP
"RTN","ROREXPR",72,0)
 . S TMP=$G(^TMP("DILIST",$J,"ID",IR,.02))
"RTN","ROREXPR",73,0)
 . S:TMP>0 IL=IL+1,RORLRC(IL)=TMP_"^NLT"
"RTN","ROREXPR",74,0)
 D CLEAN^DILF
"RTN","ROREXPR",75,0)
 Q $S(RC<0:RC,1:0)
"RTN","ROREXT")
0^12^B17997555
"RTN","ROREXT",1,0)
ROREXT ;HCIOFO/SG - DATA EXTRACT & TRANSMISSION ; 5/7/02 3:43pm
"RTN","ROREXT",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","ROREXT",3,0)
 ;
"RTN","ROREXT",4,0)
 ; ROREXT -------------- DATA EXTRACTION DESCRIPTOR
"RTN","ROREXT",5,0)
 ;
"RTN","ROREXT",6,0)
 ; ROREXT("DXBEG")       Start date of the data extraction (opt'l)
"RTN","ROREXT",7,0)
 ;                       If this node is defined and greater than
"RTN","ROREXT",8,0)
 ;                       zero, data extraction starts from this date
"RTN","ROREXT",9,0)
 ;                       (instead of individual start date for each
"RTN","ROREXT",10,0)
 ;                       patient in the registry).
"RTN","ROREXT",11,0)
 ; ROREXT("DXEND")       End date of the data extraction
"RTN","ROREXT",12,0)
 ;                       (these nodes are set by $$PREPARE^ROREXPR).
"RTN","ROREXT",13,0)
 ;
"RTN","ROREXT",14,0)
 ; ROREXT("EXTRDAYS")    Extraction period for a new patient
"RTN","ROREXT",15,0)
 ;
"RTN","ROREXT",16,0)
 ; ROREXT("HL7",
"RTN","ROREXT",17,0)
 ;   Data Area,          Data area where the segments are used
"RTN","ROREXT",18,0)
 ;                       (see the field .02 of the multiple 9 in the
"RTN","ROREXT",19,0)
 ;                       file #798.1)
"RTN","ROREXT",20,0)
 ;                          1  Patient
"RTN","ROREXT",21,0)
 ;                          2  Laboratory
"RTN","ROREXT",22,0)
 ;                          3  Pharmacy
"RTN","ROREXT",23,0)
 ;                          4  Radiology
"RTN","ROREXT",24,0)
 ;                          5  Inpatient
"RTN","ROREXT",25,0)
 ;                          6  Outpatient
"RTN","ROREXT",26,0)
 ;                          7  Pathology-Autopsy
"RTN","ROREXT",27,0)
 ;                          8  Pathology-Liver Biopsy
"RTN","ROREXT",28,0)
 ;     Segment Name)     HL7 segment descriptor
"RTN","ROREXT",29,0)
 ;                         ^1: reserved
"RTN","ROREXT",30,0)
 ;                         ^2: List of fields (separated by commas)
"RTN","ROREXT",31,0)
 ;                             that should be created in the segment.
"RTN","ROREXT",32,0)
 ;
"RTN","ROREXT",33,0)
 ; ROREXT("HL7CNT")      Counter of the messages in the batch
"RTN","ROREXT",34,0)
 ; ROREXT("HL7DT")       Date of the batch message creation (FileMan)
"RTN","ROREXT",35,0)
 ; ROREXT("HL7MID")      Message ID of the "stub" message
"RTN","ROREXT",36,0)
 ; ROREXT("HL7MTIEN")    IEN in the File #772 for the "stub" message
"RTN","ROREXT",37,0)
 ; ROREXT("HL7PROT")     Name of the event driver protocol
"RTN","ROREXT",38,0)
 ;
"RTN","ROREXT",39,0)
 ; ROREXT("LD",
"RTN","ROREXT",40,0)
 ;   1)                  Number of lag days for the data extraction
"RTN","ROREXT",41,0)
 ;
"RTN","ROREXT",42,0)
 ; ROREXT("MSGBLD")      Message builder call-back entry point (opt'l)
"RTN","ROREXT",43,0)
 ;
"RTN","ROREXT",44,0)
 ; RORHL --------------- HL7 ENVIRONMENT VARIABLES
"RTN","ROREXT",45,0)
 ;
"RTN","ROREXT",46,0)
 ;                       This local array contains HL7 environment
"RTN","ROREXT",47,0)
 ;                       variables initialized by INIT^HLFNC2 ("FS",
"RTN","ROREXT",48,0)
 ;                       "ECH" and others).
"RTN","ROREXT",49,0)
 ;
"RTN","ROREXT",50,0)
 ; RORLRC -------------- LIST OF EXTRACTED LAB RESULTS
"RTN","ROREXT",51,0)
 ;
"RTN","ROREXT",52,0)
 ; RORLRC(               Either a list of codes of a Lab results to
"RTN","ROREXT",53,0)
 ;                       extract or "*" for all results (see the LA7SC
"RTN","ROREXT",54,0)
 ;                       parameter of the GCPR^LA7QRY entry point)
"RTN","ROREXT",55,0)
 ;   Seq#)               Lab result code
"RTN","ROREXT",56,0)
 ;                         ^1: Result code
"RTN","ROREXT",57,0)
 ;                         ^2: Coding system ("LN" or "NLT")
"RTN","ROREXT",58,0)
 ;
"RTN","ROREXT",59,0)
 Q
"RTN","ROREXT",60,0)
 ;
"RTN","ROREXT",61,0)
 ;***** PRINT SOME DEBUG INFORMATION
"RTN","ROREXT",62,0)
DEBUG1 ;
"RTN","ROREXT",63,0)
 D ZW^RORUTL01("ROREXT","Control Data")
"RTN","ROREXT",64,0)
 D ZW^RORUTL01("RORLRC","Lab Results to extract")
"RTN","ROREXT",65,0)
 W !,"Job number: ",$J,!
"RTN","ROREXT",66,0)
 Q
"RTN","ROREXT",67,0)
 ;
"RTN","ROREXT",68,0)
 ;***** EXTRACTS AND SENDS REGISTRY DATA
"RTN","ROREXT",69,0)
 ;
"RTN","ROREXT",70,0)
 ; REGNAME       Registry name
"RTN","ROREXT",71,0)
 ;
"RTN","ROREXT",72,0)
 ; [DXBEG]       Data extraction start date (individual start
"RTN","ROREXT",73,0)
 ;               date for each patient by default).
"RTN","ROREXT",74,0)
 ;               Time part of the parameter value is ignored.
"RTN","ROREXT",75,0)
 ;
"RTN","ROREXT",76,0)
 ; Return Values:
"RTN","ROREXT",77,0)
 ;       <0  Error Code (see MSGLIST^RORERR20)
"RTN","ROREXT",78,0)
 ;        0  Ok
"RTN","ROREXT",79,0)
 ;
"RTN","ROREXT",80,0)
EXTRACT(REGNAME,DXBEG) ;
"RTN","ROREXT",81,0)
 N RORERRDL      ; Default error location
"RTN","ROREXT",82,0)
 N ROREXT        ; Data extraction descriptor
"RTN","ROREXT",83,0)
 N RORHL         ; HL7 variables
"RTN","ROREXT",84,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","ROREXT",85,0)
 N RORLRC        ; List of codes of Lab results to be extracted
"RTN","ROREXT",86,0)
 ;
"RTN","ROREXT",87,0)
 N COUNTERS,MID,RC,REGLST,RGLIST,TMP
"RTN","ROREXT",88,0)
 D INIT^RORUTL01("ROREXT"),CLEAR^RORERR("EXTRACT^ROREXT")
"RTN","ROREXT",89,0)
 S RGLIST(REGNAME)=""
"RTN","ROREXT",90,0)
 ;--- Open a new log
"RTN","ROREXT",91,0)
 S TMP=$$SETUP^RORLOG(.RGLIST)
"RTN","ROREXT",92,0)
 S TMP=$$OPEN^RORLOG(.RGLIST,2,"DATA EXTRACTION STARTED")
"RTN","ROREXT",93,0)
 D
"RTN","ROREXT",94,0)
 . ;--- Create a list of active registries
"RTN","ROREXT",95,0)
 . S RC=$$ARLST^RORUTL02(.RGLIST,.REGLST)  Q:RC<0
"RTN","ROREXT",96,0)
 . I $D(REGLST)<10  D  Q
"RTN","ROREXT",97,0)
 . . S RC=$$ERROR^RORERR(-28,"EXTRACT^ROREXT",,,"extract data")
"RTN","ROREXT",98,0)
 . ;--- Lock parameters of the registries being processed
"RTN","ROREXT",99,0)
 . S RC=$$LOCKREG^RORUTL02(.REGLST,1)  Q:RC<0
"RTN","ROREXT",100,0)
 . I 'RC  D  Q
"RTN","ROREXT",101,0)
 . . S RC=$$ERROR^RORERR(-11,,,,"registries being processed")
"RTN","ROREXT",102,0)
 . ;--- Prepare data extraction rules
"RTN","ROREXT",103,0)
 . S RC=$$PREPARE^ROREXPR(REGNAME,$G(DXBEG))
"RTN","ROREXT",104,0)
 . I RC<0  S RC=$$ERROR^RORERR(-22)  Q
"RTN","ROREXT",105,0)
 . D:$G(RORPARM("DEBUG"))>1 DEBUG1
"RTN","ROREXT",106,0)
 . ;--- Extract registry data
"RTN","ROREXT",107,0)
 . S RC=$$PROCESS^ROREXT01(REGNAME)  Q:RC<0
"RTN","ROREXT",108,0)
 . S COUNTERS=RC,RC=0
"RTN","ROREXT",109,0)
 . ;--- Send the batch HL7 message
"RTN","ROREXT",110,0)
 . W:$G(RORPARM("DEBUG"))>1 !,"HL7 Batch ID:   ",$G(ROREXT("HL7MID"))
"RTN","ROREXT",111,0)
 . S RC=$$SEND^RORHL7(.MID)  Q:RC<0
"RTN","ROREXT",112,0)
 . I $G(MID)'=""  D  D LOG^RORLOG(2,TMP)
"RTN","ROREXT",113,0)
 . . S TMP="HL7 batch message "_MID_" has been generated"
"RTN","ROREXT",114,0)
 . ;--- Update registry parameters
"RTN","ROREXT",115,0)
 . S TMP=$$TMSTMP^ROREXTUT(.REGLST,$S('RC:$G(MID),1:""))
"RTN","ROREXT",116,0)
 ;
"RTN","ROREXT",117,0)
 ;--- Unlock parameters of processed registries
"RTN","ROREXT",118,0)
 S TMP=$$LOCKREG^RORUTL02(.REGLST,0)
"RTN","ROREXT",119,0)
 ;--- Statistics & Cleanup
"RTN","ROREXT",120,0)
 S TMP="DATA EXTRACTION "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","ROREXT",121,0)
 D CLOSE^RORLOG(TMP,$G(COUNTERS))
"RTN","ROREXT",122,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("ROREXT")
"RTN","ROREXT",123,0)
 Q $S(RC<0:RC,1:0)
"RTN","ROREXT",124,0)
 ;
"RTN","ROREXT",125,0)
 ;***** ENTRY POINT OF DATA EXTRACTION TASK
"RTN","ROREXT",126,0)
 ;
"RTN","ROREXT",127,0)
 ; RORREG        Registry name
"RTN","ROREXT",128,0)
 ;
"RTN","ROREXT",129,0)
TASK ;
"RTN","ROREXT",130,0)
 N RORERROR      ; Error processing data
"RTN","ROREXT",131,0)
 N RORPARM       ; Application parameters
"RTN","ROREXT",132,0)
 ;
"RTN","ROREXT",133,0)
 N RC
"RTN","ROREXT",134,0)
 ;--- Force "UNDEF" error if registry name is not defined
"RTN","ROREXT",135,0)
 I $G(RORREG)?." "  K RORREG  S RC=RORREG
"RTN","ROREXT",136,0)
 ;--- Initialize parameters
"RTN","ROREXT",137,0)
 ;S RORPARM("DEBUG")=1 ; Remove the first ';' to start in debug mode
"RTN","ROREXT",138,0)
 S RORPARM("ERR")=1
"RTN","ROREXT",139,0)
 ;--- Run the data extraction
"RTN","ROREXT",140,0)
 S RC=$$EXTRACT(RORREG)  S:RC<0 ZTSTOP=1
"RTN","ROREXT",141,0)
 I RC=-42  D ALERT^RORUTL01(RORREG,-42)  Q
"RTN","ROREXT",142,0)
 D:RC<0 ALERT^RORUTL01(RORREG,-43,,,,"data extraction")
"RTN","ROREXT",143,0)
 S ZTREQ="@"
"RTN","ROREXT",144,0)
 Q
"RTN","ROREXT01")
0^13^B9006451
"RTN","ROREXT01",1,0)
ROREXT01 ;HCIOFO/SG - EXTRACTION & TRANSMISSION PROCESS ; 5/8/02 10:11am
"RTN","ROREXT01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","ROREXT01",3,0)
 ;
"RTN","ROREXT01",4,0)
 Q
"RTN","ROREXT01",5,0)
 ;
"RTN","ROREXT01",6,0)
 ;***** SCANS THE REGISTRY AND EXTRACTS THE DATA
"RTN","ROREXT01",7,0)
 ;
"RTN","ROREXT01",8,0)
 ; REGNAME       Registry name
"RTN","ROREXT01",9,0)
 ;
"RTN","ROREXT01",10,0)
 ; Return Values:
"RTN","ROREXT01",11,0)
 ;       <0  Error Code
"RTN","ROREXT01",12,0)
 ;      >=0  Statistics
"RTN","ROREXT01",13,0)
 ;             ^1: Total number of processed patients
"RTN","ROREXT01",14,0)
 ;             ^2: Number of patients processed with errors
"RTN","ROREXT01",15,0)
 ;
"RTN","ROREXT01",16,0)
 ; In normal mode this function processes all patients and returns
"RTN","ROREXT01",17,0)
 ; total number of patients and number of patients processed with
"RTN","ROREXT01",18,0)
 ; errors.
"RTN","ROREXT01",19,0)
 ;
"RTN","ROREXT01",20,0)
 ; However, in debug mode 3 the function stops after the first
"RTN","ROREXT01",21,0)
 ; patient processed with error and returns an error code.
"RTN","ROREXT01",22,0)
 ;
"RTN","ROREXT01",23,0)
PROCESS(REGNAME) ;
"RTN","ROREXT01",24,0)
 N CNT,ECNT,IIEN,PATIEN,RC,REGIEN,ROOT
"RTN","ROREXT01",25,0)
 S ROOT=$$ROOT^DILFD(798,,1)
"RTN","ROREXT01",26,0)
 ;--- Get the registry IEN
"RTN","ROREXT01",27,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","ROREXT01",28,0)
 Q:REGIEN<0 REGIEN
"RTN","ROREXT01",29,0)
 ;--- Loop through the patients of the registry
"RTN","ROREXT01",30,0)
 S IIEN="",(CNT,ECNT,RC)=0
"RTN","ROREXT01",31,0)
 F  S IIEN=$O(@ROOT@("AC",REGIEN,IIEN))  Q:IIEN=""  D  Q:RC<0
"RTN","ROREXT01",32,0)
 . ;--- Check if task stop has been requested
"RTN","ROREXT01",33,0)
 . I $D(ZTQUEUED),$$S^%ZTLOAD  D  Q
"RTN","ROREXT01",34,0)
 . . S RC=$$ERROR^RORERR(-42,"PROCESS^ROREXT01")
"RTN","ROREXT01",35,0)
 . ;--- Process the registry record
"RTN","ROREXT01",36,0)
 . S CNT=CNT+1
"RTN","ROREXT01",37,0)
 . I $G(RORPARM("DEBUG"))>1  W:$E($G(IOST),1,2)="C-" *13,CNT
"RTN","ROREXT01",38,0)
 . S RC=$$PROCREC(REGIEN,IIEN,.PATIEN)
"RTN","ROREXT01",39,0)
 . ;--- Process the error (if any)
"RTN","ROREXT01",40,0)
 . I RC<0  D  S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","ROREXT01",41,0)
 . . S ECNT=ECNT+1
"RTN","ROREXT01",42,0)
 . . S RC=$$ERROR^RORERR(-15,"PROCESS^ROREXT01",,,$G(PATIEN))
"RTN","ROREXT01",43,0)
 ;---
"RTN","ROREXT01",44,0)
 Q $S(RC<0:RC,1:CNT_U_ECNT)
"RTN","ROREXT01",45,0)
 ;
"RTN","ROREXT01",46,0)
 ;***** PROCESS THE PATIENT'S RECORD IN THE REGISTRY
"RTN","ROREXT01",47,0)
 ;
"RTN","ROREXT01",48,0)
 ; REGIEN        Registry IEN
"RTN","ROREXT01",49,0)
 ; IIEN          IEN of the patient record in the registry
"RTN","ROREXT01",50,0)
 ; [.PATIEN]     Patient IEN is returned by this parameter
"RTN","ROREXT01",51,0)
 ;
"RTN","ROREXT01",52,0)
 ; Return Values:
"RTN","ROREXT01",53,0)
 ;       <0  Error Code
"RTN","ROREXT01",54,0)
 ;        0  Ok
"RTN","ROREXT01",55,0)
 ;
"RTN","ROREXT01",56,0)
PROCREC(REGIEN,IIEN,PATIEN) ;
"RTN","ROREXT01",57,0)
 N RORERRDL      ; Default error location
"RTN","ROREXT01",58,0)
 ;
"RTN","ROREXT01",59,0)
 N ENDT,IENS,MSHPTR,RC,RORFDA,RORMSG,RORMSH,SDT,TMP
"RTN","ROREXT01",60,0)
 D CLEAR^RORERR("PROCREC^ROREXT01")
"RTN","ROREXT01",61,0)
 S IENS=IIEN_",",PATIEN=0
"RTN","ROREXT01",62,0)
 ;--- Get the registry record data
"RTN","ROREXT01",63,0)
 D GETS^DIQ(798,IENS,".01;11","EI","RORFDA","RORMSG")
"RTN","ROREXT01",64,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","ROREXT01",65,0)
 S PATIEN=RORFDA(798,IENS,.01,"I")
"RTN","ROREXT01",66,0)
 ;--- Skip a record tagged as "DON'T SEND"
"RTN","ROREXT01",67,0)
 Q:$G(RORFDA(798,IENS,11,"I")) 0
"RTN","ROREXT01",68,0)
 ;--- Prepare extract dates
"RTN","ROREXT01",69,0)
 S RC=$$DXPERIOD^ROREXTUT(IIEN,.SDT,.ENDT)
"RTN","ROREXT01",70,0)
 I RC  Q:RC<0 RC  D:$G(RORPARM("DEBUG"))  Q 0
"RTN","ROREXT01",71,0)
 . S TMP="Data extraction period: '"_$G(SDT)_"-"_$G(ENDT)_"'"
"RTN","ROREXT01",72,0)
 . D LOG^RORLOG(4,"Nothing has been extracted",PATIEN,TMP)
"RTN","ROREXT01",73,0)
 ;--- Create HL7 message for the patient (if necessary)
"RTN","ROREXT01",74,0)
 S MSHPTR=$$CREATE^RORHL7(.RORMSH)  Q:MSHPTR<0 MSHPTR
"RTN","ROREXT01",75,0)
 I $G(ROREXT("MSGBLD"))'=""  D
"RTN","ROREXT01",76,0)
 . X "S RC="_ROREXT("MSGBLD")_"(IIEN,PATIEN,SDT,ENDT)"
"RTN","ROREXT01",77,0)
 E  S RC=$$MESSAGE^ROREXT02(IIEN,PATIEN,SDT,ENDT)
"RTN","ROREXT01",78,0)
 ;--- Store Message ID in the registry record if everything is Ok.
"RTN","ROREXT01",79,0)
 ;    Otherwise, delete an unfinished message from ^TMP("HLS",$J).
"RTN","ROREXT01",80,0)
 I 'RC,$O(^TMP("HLS",$J,""),-1)'=MSHPTR  D
"RTN","ROREXT01",81,0)
 . N FS  K RORFDA,RORMSG
"RTN","ROREXT01",82,0)
 . S FS=$E(RORMSH,4),IENS=IIEN_","
"RTN","ROREXT01",83,0)
 . S RORFDA(798,IENS,9.2)=ENDT
"RTN","ROREXT01",84,0)
 . S RORFDA(798,IENS,10)=$P(RORMSH,FS,10)
"RTN","ROREXT01",85,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","ROREXT01",86,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,798,IENS)
"RTN","ROREXT01",87,0)
 E  D ROLLBACK^RORHL7(MSHPTR)
"RTN","ROREXT01",88,0)
 Q $S(RC<0:RC,1:0)
"RTN","ROREXT02")
0^14^B21368107
"RTN","ROREXT02",1,0)
ROREXT02 ;HCIOFO/SG - BODY OF A HL7 MESSAGE ; 5/6/02 1:34pm
"RTN","ROREXT02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","ROREXT02",3,0)
 ;
"RTN","ROREXT02",4,0)
 Q
"RTN","ROREXT02",5,0)
 ;
"RTN","ROREXT02",6,0)
 ;***** EXTRACTS AND PREPARES LABORATORY DATA
"RTN","ROREXT02",7,0)
 ;
"RTN","ROREXT02",8,0)
 ; PATIEN        Patient IEN
"RTN","ROREXT02",9,0)
 ;
"RTN","ROREXT02",10,0)
 ; STDT          Extract from this date
"RTN","ROREXT02",11,0)
 ; ENDT          Extract until this date
"RTN","ROREXT02",12,0)
 ;
"RTN","ROREXT02",13,0)
 ; .PTR          Refefrence  to a local variable containing subscript
"RTN","ROREXT02",14,0)
 ;               of the last sub-node in the ^TMP("HLS",$J). Value of
"RTN","ROREXT02",15,0)
 ;               this parameter is updated by the function.
"RTN","ROREXT02",16,0)
 ;
"RTN","ROREXT02",17,0)
 ; [HDTMODE]     If this parameter is defined and non-zero, start and
"RTN","ROREXT02",18,0)
 ;               end dates are specimen collection dates. Otherwise,
"RTN","ROREXT02",19,0)
 ;               they are dates of the results.
"RTN","ROREXT02",20,0)
 ;
"RTN","ROREXT02",21,0)
 ; The function uses node ^TMP("RORTMP",$J) as a temporary storage.
"RTN","ROREXT02",22,0)
 ;
"RTN","ROREXT02",23,0)
 ; Return Values:
"RTN","ROREXT02",24,0)
 ;       <0  Error Code
"RTN","ROREXT02",25,0)
 ;        0  Ok
"RTN","ROREXT02",26,0)
 ;
"RTN","ROREXT02",27,0)
LABDATA(PATIEN,STDT,ENDT,PTR,HDTMODE) ;
"RTN","ROREXT02",28,0)
 N I,J,RC,RORDST,SEG,TMP
"RTN","ROREXT02",29,0)
 S RORDST=$NA(^TMP("RORTMP",$J))
"RTN","ROREXT02",30,0)
 ;--- Get the Lab results
"RTN","ROREXT02",31,0)
 S TMP=$S($G(HDTMODE):"^CD",1:"^RAD")
"RTN","ROREXT02",32,0)
 S RC=$$LABRSLTS^RORUTL02(PATIEN,STDT_TMP,ENDT_TMP)
"RTN","ROREXT02",33,0)
 Q:RC<0 RC
"RTN","ROREXT02",34,0)
 ;--- Add the results to the message
"RTN","ROREXT02",35,0)
 S I=0
"RTN","ROREXT02",36,0)
 F  S I=$O(@RORDST@(I))  Q:I=""  D
"RTN","ROREXT02",37,0)
 . S SEG=$P(@RORDST@(I),RORHL("FS"))
"RTN","ROREXT02",38,0)
 . Q:'$D(ROREXT("HL7",2,SEG))
"RTN","ROREXT02",39,0)
 . S PTR=PTR+1
"RTN","ROREXT02",40,0)
 . S ^TMP("HLS",$J,PTR)=$TR(@RORDST@(I),$C(9,10,13),"   ")
"RTN","ROREXT02",41,0)
 . S J=0
"RTN","ROREXT02",42,0)
 . F  S J=$O(@RORDST@(I,J))  Q:J=""  D
"RTN","ROREXT02",43,0)
 . . S ^TMP("HLS",$J,PTR,J)=$TR(@RORDST@(I,J),$C(9,10,13),"   ")
"RTN","ROREXT02",44,0)
 K @RORDST
"RTN","ROREXT02",45,0)
 Q 0
"RTN","ROREXT02",46,0)
 ;
"RTN","ROREXT02",47,0)
 ;***** EXTRACTS PATIENT DATA AND CREATES A MESSAGE BODY
"RTN","ROREXT02",48,0)
 ;
"RTN","ROREXT02",49,0)
 ; RORIEN        IEN of the patient record in the registry
"RTN","ROREXT02",50,0)
 ; PATIEN        Patient IEN
"RTN","ROREXT02",51,0)
 ; STDT          Extract from this date (include)
"RTN","ROREXT02",52,0)
 ; ENDT          Extract until this date (do not include)
"RTN","ROREXT02",53,0)
 ; [HDTMODE]     This parameter is defined and non-zero during the
"RTN","ROREXT02",54,0)
 ;               historical data extraction.
"RTN","ROREXT02",55,0)
 ;
"RTN","ROREXT02",56,0)
 ; Return Values:
"RTN","ROREXT02",57,0)
 ;       <0  Error Code
"RTN","ROREXT02",58,0)
 ;        0  Ok
"RTN","ROREXT02",59,0)
 ;       >0  Nothing to send
"RTN","ROREXT02",60,0)
 ;
"RTN","ROREXT02",61,0)
MESSAGE(RORIEN,PATIEN,STDT,ENDT,HDTMODE) ;
"RTN","ROREXT02",62,0)
 N RORDEM        ; Update demographics
"RTN","ROREXT02",63,0)
 N RORFDA        ; Array containing values from the registry record
"RTN","ROREXT02",64,0)
 N RORLOC        ; Update local registry data
"RTN","ROREXT02",65,0)
 N RORPTR        ; Current subnode of the ^TMP("HLS",$J)
"RTN","ROREXT02",66,0)
 ;
"RTN","ROREXT02",67,0)
 N DATAPTR,DEMPTR,FIELDS,IENS,LOCPTR,RBPTR,RC,RORBUF,RORMSG
"RTN","ROREXT02",68,0)
 S IENS=RORIEN_","
"RTN","ROREXT02",69,0)
 ;--- Get the registry record data
"RTN","ROREXT02",70,0)
 D GETS^DIQ(798,IENS,"4;5","EI","RORFDA","RORMSG")
"RTN","ROREXT02",71,0)
 I $G(DIERR)  D  Q RC
"RTN","ROREXT02",72,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"MESSAGE^ROREXT02",PATIEN,798,IENS)
"RTN","ROREXT02",73,0)
 S RORDEM=+$G(RORFDA(798,IENS,4,"I"))
"RTN","ROREXT02",74,0)
 S RORLOC=+$G(RORFDA(798,IENS,5,"I"))
"RTN","ROREXT02",75,0)
 ;--- Initialize environment variables
"RTN","ROREXT02",76,0)
 S RC=$$INIT^RORHL7()  Q:RC<0 RC
"RTN","ROREXT02",77,0)
 S RORPTR=$O(^TMP("HLS",$J,""),-1)
"RTN","ROREXT02",78,0)
 ;--- Add patient data segments
"RTN","ROREXT02",79,0)
 S DEMPTR=RORPTR
"RTN","ROREXT02",80,0)
 S RC=$$PID^RORHL01(PATIEN,.RORPTR,HLFS,HLECH)  Q:RC<0 RC
"RTN","ROREXT02",81,0)
 I RORDEM  D  Q:RC<0 RC
"RTN","ROREXT02",82,0)
 . I $D(ROREXT("HL7",1,"ZSP"))  D  Q:RC<0      ; Period of Servise
"RTN","ROREXT02",83,0)
 . . S RC=$$ZSP^RORHL01(PATIEN,.RORPTR,HLFS,HLECH)
"RTN","ROREXT02",84,0)
 . I $D(ROREXT("HL7",1,"ZRD"))  D  Q:RC<0      ; Rated Disabilities
"RTN","ROREXT02",85,0)
 . . S RC=$$ZRD^RORHL01(PATIEN,.RORPTR,HLFS,HLECH)
"RTN","ROREXT02",86,0)
 ;--- Add local registry data segments
"RTN","ROREXT02",87,0)
 S LOCPTR=RORPTR
"RTN","ROREXT02",88,0)
 I $D(ROREXT("HL7",1,"CSR"))  D  Q:RC<0 RC
"RTN","ROREXT02",89,0)
 . S FIELDS=$P(ROREXT("HL7",1,"CSR"),U,2)
"RTN","ROREXT02",90,0)
 . S RC=$$CSR^RORHL02(IENS,FIELDS,.RORPTR,HLFS,HLECH)
"RTN","ROREXT02",91,0)
 I $D(ROREXT("HL7",1,"CSP"))  D  Q:RC<0 RC
"RTN","ROREXT02",92,0)
 . S FIELDS=$P(ROREXT("HL7",1,"CSP"),U,2)
"RTN","ROREXT02",93,0)
 . S RC=$$CSP^RORHL02(IENS,FIELDS,.RORPTR,HLFS,HLECH)
"RTN","ROREXT02",94,0)
 I $D(ROREXT("HL7",1,"CSS"))  D  Q:RC<0 RC
"RTN","ROREXT02",95,0)
 . S FIELDS=$P(ROREXT("HL7",1,"CSS"),U,2)
"RTN","ROREXT02",96,0)
 . S RC=$$CSS^RORHL02(IENS,FIELDS,.RORPTR,HLFS,HLECH)
"RTN","ROREXT02",97,0)
 ;--- Add encounter data segments
"RTN","ROREXT02",98,0)
 S DATAPTR=RORPTR
"RTN","ROREXT02",99,0)
 I $D(ROREXT("HL7",3))>1  D  Q:RC<0 RC        ; Pharmacy
"RTN","ROREXT02",100,0)
 . S RC=$$EN1^RORHL03(PATIEN,STDT,ENDT,.RORPTR,,HLFS,HLECH)
"RTN","ROREXT02",101,0)
 I $D(ROREXT("HL7",4))>1  D  Q:RC<0 RC        ; Radiology
"RTN","ROREXT02",102,0)
 . S RC=$$EN1^RORHL04(PATIEN,STDT,ENDT,.RORPTR,,HLFS,HLECH)
"RTN","ROREXT02",103,0)
 I $D(ROREXT("HL7",7))>1  D  Q:RC<0 RC        ; Autopsy
"RTN","ROREXT02",104,0)
 . S RC=$$EN1^RORHL05(PATIEN,.RORPTR,,HLFS,HLECH)
"RTN","ROREXT02",105,0)
 I $D(ROREXT("HL7",8))>1  D  Q:RC<0 RC        ; Liver Biopsy
"RTN","ROREXT02",106,0)
 . S RC=$$EN1^RORHL06(PATIEN,STDT,ENDT,.RORPTR,,HLFS,HLECH)
"RTN","ROREXT02",107,0)
 ;--- Add Lab data
"RTN","ROREXT02",108,0)
 I $D(ROREXT("HL7",2))>1  D  Q:RC<0 RC
"RTN","ROREXT02",109,0)
 . S RC=$$LABDATA(PATIEN,STDT,ENDT,.RORPTR,+$G(HDTMODE))
"RTN","ROREXT02",110,0)
 ;--- Analyze structure of the message
"RTN","ROREXT02",111,0)
 S RC=0
"RTN","ROREXT02",112,0)
 I RORPTR'>DATAPTR  D
"RTN","ROREXT02",113,0)
 . S RBPTR=RORPTR
"RTN","ROREXT02",114,0)
 . ;--- Do not send local registry data segments if the UPDATE LOCAL
"RTN","ROREXT02",115,0)
 . ;    REGISTRY DATA flag is not set and there is no other
"RTN","ROREXT02",116,0)
 . ;    VistA data to be sent
"RTN","ROREXT02",117,0)
 . I 'RORLOC!(RORPTR'>LOCPTR)  S RBPTR=LOCPTR  D
"RTN","ROREXT02",118,0)
 . . ;--- Do not send a message containing only the PID segment
"RTN","ROREXT02",119,0)
 . . ;    if the UPDATE DEMOGRAPHICS flag is not set
"RTN","ROREXT02",120,0)
 . . S:'RORDEM RBPTR=DEMPTR
"RTN","ROREXT02",121,0)
 . ;--- Delete unnecessary segments
"RTN","ROREXT02",122,0)
 . F  Q:RORPTR'>RBPTR  D  S RORPTR=$O(^TMP("HLS",$J,RORPTR),-1)
"RTN","ROREXT02",123,0)
 . . K ^TMP("HLS",$J,RORPTR)
"RTN","ROREXT02",124,0)
 . S RC=RORPTR'>DEMPTR
"RTN","ROREXT02",125,0)
 Q RC
"RTN","ROREXTUT")
0^15^B16857910
"RTN","ROREXTUT",1,0)
ROREXTUT ;HCIOFO/SG - DATA EXTRACT UTILITIES  ; 5/13/02 8:49am
"RTN","ROREXTUT",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","ROREXTUT",3,0)
 ;
"RTN","ROREXTUT",4,0)
 Q
"RTN","ROREXTUT",5,0)
 ;
"RTN","ROREXTUT",6,0)
 ;***** CHECKS ACKNOWLEDGEMENT FLAG OF THE REGISTRY
"RTN","ROREXTUT",7,0)
 ;
"RTN","ROREXTUT",8,0)
 ; REGNAME       Registry name
"RTN","ROREXTUT",9,0)
 ;
"RTN","ROREXTUT",10,0)
 ; Return Values:
"RTN","ROREXTUT",11,0)
 ;       <0  Error Code
"RTN","ROREXTUT",12,0)
 ;        0  Ok
"RTN","ROREXTUT",13,0)
 ;        1  The acknowledgement flag is set
"RTN","ROREXTUT",14,0)
 ;
"RTN","ROREXTUT",15,0)
ACKWAIT(REGNAME) ;
"RTN","ROREXTUT",16,0)
 N REGIEN,RC,TMP
"RTN","ROREXTUT",17,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)  Q:REGIEN<0 REGIEN
"RTN","ROREXTUT",18,0)
 S TMP=+$$GET1^DIQ(798.1,REGIEN_",",2.2,"I",,"RORMSG")
"RTN","ROREXTUT",19,0)
 I $G(DIERR)  D  Q RC
"RTN","ROREXTUT",20,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"ACKWAIT^ROREXTUT",,798.1,REGIEN)
"RTN","ROREXTUT",21,0)
 Q TMP
"RTN","ROREXTUT",22,0)
 ;
"RTN","ROREXTUT",23,0)
 ;***** RETURNS A DATA EXTRACTION PERIOD FOR THE PATIENT
"RTN","ROREXTUT",24,0)
 ;
"RTN","ROREXTUT",25,0)
 ; IEN           IEN of the patient record in the registry
"RTN","ROREXTUT",26,0)
 ; .SDT          Start date of the data extraction (output)
"RTN","ROREXTUT",27,0)
 ; .EDT          End date of the data extraction (output)
"RTN","ROREXTUT",28,0)
 ;
"RTN","ROREXTUT",29,0)
 ; Return Values:
"RTN","ROREXTUT",30,0)
 ;        <0  Error Code
"RTN","ROREXTUT",31,0)
 ;         0  Ok
"RTN","ROREXTUT",32,0)
 ;        >0  Skip the patient
"RTN","ROREXTUT",33,0)
 ;
"RTN","ROREXTUT",34,0)
 ; If the special extraction start date for all patients is defined
"RTN","ROREXTUT",35,0)
 ; then it is returned as a value of the SDT parameter. Usually,
"RTN","ROREXTUT",36,0)
 ; this mode is not used. ;-)
"RTN","ROREXTUT",37,0)
 ;
"RTN","ROREXTUT",38,0)
 ; If the field #9.1 of the patient record in the registry (#798)
"RTN","ROREXTUT",39,0)
 ; has a value then this value is returned (data have already been
"RTN","ROREXTUT",40,0)
 ; extracted until that date). Usually, this field should be empty
"RTN","ROREXTUT",41,0)
 ; for new patients.
"RTN","ROREXTUT",42,0)
 ;
"RTN","ROREXTUT",43,0)
 ; The function tries to get the earliest date when a selection rule
"RTN","ROREXTUT",44,0)
 ; has been triggered for the newly added patient. If the patient has
"RTN","ROREXTUT",45,0)
 ; been added manually and there are no selection rules in the
"RTN","ROREXTUT",46,0)
 ; SELECTION RULE multiple of the registry record then a date when
"RTN","ROREXTUT",47,0)
 ; the patient was added to the registry is used.
"RTN","ROREXTUT",48,0)
 ;
"RTN","ROREXTUT",49,0)
 ; After that, extract period for new patients (value of the field
"RTN","ROREXTUT",50,0)
 ; #7 of the file #798.1) is subtracted from the date and the result
"RTN","ROREXTUT",51,0)
 ; is returned. If the extract period is not set for the registry,
"RTN","ROREXTUT",52,0)
 ; a default value (365) is used.
"RTN","ROREXTUT",53,0)
 ;
"RTN","ROREXTUT",54,0)
DXPERIOD(IEN,SDT,EDT) ;
"RTN","ROREXTUT",55,0)
 N DTENT,IENS,INCTVDT,LCH,NEWPAT,RC,RORBUF,RORMSG,TMP
"RTN","ROREXTUT",56,0)
 S (EDT,SDT)="",IENS=IEN_",",LCH=0
"RTN","ROREXTUT",57,0)
 ;--- Get the registry record data
"RTN","ROREXTUT",58,0)
 D GETS^DIQ(798,IENS,"1;2;3;4;5;8;9.1","EI","RORBUF","RORMSG")
"RTN","ROREXTUT",59,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"DXPERIOD^ROREXTUT",,798,IENS)
"RTN","ROREXTUT",60,0)
 S EDT=$$FMADD^XLFDT(ROREXT("DXEND"),-$G(ROREXT("LD",1)))
"RTN","ROREXTUT",61,0)
 F TMP=3,4,5  S:$G(RORBUF(798,IENS,TMP,"I")) LCH=1
"RTN","ROREXTUT",62,0)
 ;--- Data is not extracted after the inactivation date
"RTN","ROREXTUT",63,0)
 I '$G(RORBUF(798,IENS,8,"E"))  D  S:EDT>INCTVDT EDT=INCTVDT
"RTN","ROREXTUT",64,0)
 . S INCTVDT=$G(RORBUF(798,IENS,2,"I"))\1
"RTN","ROREXTUT",65,0)
 ;--- Special start date for ALL patients (if defined)
"RTN","ROREXTUT",66,0)
 S SDT=$G(ROREXT("DXBEG"))
"RTN","ROREXTUT",67,0)
 I SDT'>0  D
"RTN","ROREXTUT",68,0)
 . ;--- Start date from the patient's record in the registry
"RTN","ROREXTUT",69,0)
 . S SDT=$G(RORBUF(798,IENS,9.1,"I"))\1  Q:SDT>0
"RTN","ROREXTUT",70,0)
 . ;--- Determine the start date for a newly added patient
"RTN","ROREXTUT",71,0)
 . S DTENT=$G(RORBUF(798,IENS,1,"I"))
"RTN","ROREXTUT",72,0)
 . S NEWPAT=+$G(RORBUF(798,IENS,3,"I"))
"RTN","ROREXTUT",73,0)
 . I (NEWPAT=1)!(NEWPAT=2)  D
"RTN","ROREXTUT",74,0)
 . . S TMP=$$ROOT^DILFD(798.01,","_IENS,1)  Q:TMP=""
"RTN","ROREXTUT",75,0)
 . . S SDT=$O(@TMP@("AD","")) ; The earliest selection rule
"RTN","ROREXTUT",76,0)
 . . I SDT'>0  S SDT=DTENT  Q:SDT'>0
"RTN","ROREXTUT",77,0)
 . . S TMP=+$G(ROREXT("EXTRDAYS"))
"RTN","ROREXTUT",78,0)
 . . S SDT=$$FMADD^XLFDT(SDT,-$S(TMP>0:TMP,1:365))\1
"RTN","ROREXTUT",79,0)
 . S:SDT'>0 SDT=DTENT\1
"RTN","ROREXTUT",80,0)
 ;--- Check the dates
"RTN","ROREXTUT",81,0)
 I (SDT'>0)!(EDT'>0)  D  Q RC
"RTN","ROREXTUT",82,0)
 . S RC=$$ERROR^RORERR(-32,"DXPERIOD^ROREXTUT",,PATIEN,SDT,EDT)
"RTN","ROREXTUT",83,0)
 Q:SDT<EDT 0
"RTN","ROREXTUT",84,0)
 I LCH  S SDT=EDT  Q 0
"RTN","ROREXTUT",85,0)
 Q 1
"RTN","ROREXTUT",86,0)
 ;
"RTN","ROREXTUT",87,0)
 ;***** UPDATES DATA EXTRACTION PARAMETERS OF THE REGISTRY
"RTN","ROREXTUT",88,0)
 ;
"RTN","ROREXTUT",89,0)
 ; .REGLST       Reference to a local array containing registry names
"RTN","ROREXTUT",90,0)
 ;               as subscripts and optional registry IENs as values
"RTN","ROREXTUT",91,0)
 ; MID           Batch message ID returned by the GENERATE^HLMA
"RTN","ROREXTUT",92,0)
 ;
"RTN","ROREXTUT",93,0)
 ; Return values:
"RTN","ROREXTUT",94,0)
 ;       <0  Error code
"RTN","ROREXTUT",95,0)
 ;        0  Ok
"RTN","ROREXTUT",96,0)
 ;
"RTN","ROREXTUT",97,0)
TMSTMP(REGLST,MID) ;
"RTN","ROREXTUT",98,0)
 N DATE,RC,REGIEN,REGIENS,REGNAME,RORFDA,RORMSG
"RTN","ROREXTUT",99,0)
 S DATE=ROREXT("DXEND")\1
"RTN","ROREXTUT",100,0)
 S REGNAME="",RC=0
"RTN","ROREXTUT",101,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","ROREXTUT",102,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","ROREXTUT",103,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=+REGIEN  Q
"RTN","ROREXTUT",104,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","ROREXTUT",105,0)
 . S REGIENS=REGIEN_","
"RTN","ROREXTUT",106,0)
 . ;--- Check if the new date until that data are extracted is
"RTN","ROREXTUT",107,0)
 . ;    greater than that stored in the registry parameters
"RTN","ROREXTUT",108,0)
 . S TMP=$$GET1^DIQ(798.1,REGIENS,2,"I",,"RORMSG")
"RTN","ROREXTUT",109,0)
 . I $G(DIERR)  D  Q
"RTN","ROREXTUT",110,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"TMSTMP^ROREXTUT",,798.1,REGIENS)
"RTN","ROREXTUT",111,0)
 . S:DATE>TMP RORFDA(798.1,REGIENS,2)=DATE
"RTN","ROREXTUT",112,0)
 . ;--- Update the Last Batch info only if something has been sent
"RTN","ROREXTUT",113,0)
 . D:$G(MID)'=""
"RTN","ROREXTUT",114,0)
 . . S RORFDA(798.1,REGIENS,2.1)=$G(ROREXT("HL7MID"))
"RTN","ROREXTUT",115,0)
 . . S RORFDA(798.1,REGIENS,2.2)=$$NOW^XLFDT
"RTN","ROREXTUT",116,0)
 . . S RORFDA(798.1,REGIENS,2.3)=MID
"RTN","ROREXTUT",117,0)
 . ;--- Update registry parameters
"RTN","ROREXTUT",118,0)
 . Q:$D(RORFDA)<10
"RTN","ROREXTUT",119,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","ROREXTUT",120,0)
 . I $G(DIERR)  D  Q
"RTN","ROREXTUT",121,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"TMSTMP^ROREXTUT",,798.1,REGIENS)
"RTN","ROREXTUT",122,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORFIX")
1^79
"RTN","RORHDT")
0^16^B14169030
"RTN","RORHDT",1,0)
RORHDT ;HCIOFO/SG - HISTORICAL DATA EXTRACTION ; 3/12/02 11:25am
"RTN","RORHDT",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHDT",3,0)
 ;
"RTN","RORHDT",4,0)
 ; RORHDT -------------- HISTORICAL DATA EXTRACTION DESCRIPTOR
"RTN","RORHDT",5,0)
 ;
"RTN","RORHDT",6,0)
 ; RORHDT("BHS")         If this node has a non-zero value, the
"RTN","RORHDT",7,0)
 ;                       $$COMMIT^RORHDT05 function outputs a BHS
"RTN","RORHDT",8,0)
 ;                       segment before writing the data from the
"RTN","RORHDT",9,0)
 ;                       ^TMP("HLS",$J) node. Then it kills the
"RTN","RORHDT",10,0)
 ;                       RORHDT("BHS") node.
"RTN","RORHDT",11,0)
 ;
"RTN","RORHDT",12,0)
 ; RORHDT("DFLT",
"RTN","RORHDT",13,0)
 ;   "REG")              Name of default registry
"RTN","RORHDT",14,0)
 ;   "TSK")              IEN of default data extraction task
"RTN","RORHDT",15,0)
 ;
"RTN","RORHDT",16,0)
 ; See also descriptions of the ^TMP("RORHDT") and ^XTMP("RORHDT")
"RTN","RORHDT",17,0)
 ; nodes in the ^ROR01 routine.
"RTN","RORHDT",18,0)
 ;
"RTN","RORHDT",19,0)
 Q
"RTN","RORHDT",20,0)
 ;
"RTN","RORHDT",21,0)
 ;***** (RE)CREATES A DATA EXTRACTION TASK TABLE
"RTN","RORHDT",22,0)
CREATE ;
"RTN","RORHDT",23,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT",24,0)
 N RORERROR      ; Error processing data
"RTN","RORHDT",25,0)
 N RORPARM       ; Application parameters
"RTN","RORHDT",26,0)
 ;
"RTN","RORHDT",27,0)
 N RC,REGIEN
"RTN","RORHDT",28,0)
 S RORPARM("ERR")=1
"RTN","RORHDT",29,0)
 ;S RORPARM("DEBUG")=2 ; Remove the first ';' to start in debug mode
"RTN","RORHDT",30,0)
 D CLEAR^RORERR("CREATE^RORHDT")
"RTN","RORHDT",31,0)
 ;--- Select a registry
"RTN","RORHDT",32,0)
 S REGIEN=$$SELREG^RORHDTUT()                  G:REGIEN<0 ERROR
"RTN","RORHDT",33,0)
 Q:'REGIEN
"RTN","RORHDT",34,0)
 ;--- Create a new task table
"RTN","RORHDT",35,0)
 S RC=$$CREATE^RORHDTAC(REGIEN)                    G:RC<0 ERROR
"RTN","RORHDT",36,0)
 I RC  S RC=$$CREATE^RORHDT02(REGIEN)              G:RC<0 ERROR  D
"RTN","RORHDT",37,0)
 . W:'RC "New task table has been created.",!
"RTN","RORHDT",38,0)
 Q
"RTN","RORHDT",39,0)
 ;
"RTN","RORHDT",40,0)
 ;***** DISPLAYS THE ERRORS
"RTN","RORHDT",41,0)
ERROR ;
"RTN","RORHDT",42,0)
 D DSPSTK^RORERR()
"RTN","RORHDT",43,0)
 Q
"RTN","RORHDT",44,0)
 ;
"RTN","RORHDT",45,0)
 ;***** DISPLAYS THE LATEST LOG OF THE TASK
"RTN","RORHDT",46,0)
LOG ;
"RTN","RORHDT",47,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT",48,0)
 N RORERROR      ; Error processing data
"RTN","RORHDT",49,0)
 N RORPARM       ; Application parameters
"RTN","RORHDT",50,0)
 ;
"RTN","RORHDT",51,0)
 N POP,RC,REGIEN,TASKIEN
"RTN","RORHDT",52,0)
 S RORPARM("ERR")=1
"RTN","RORHDT",53,0)
 ;S RORPARM("DEBUG")=2 ; Remove the first ';' to start in debug mode
"RTN","RORHDT",54,0)
 D CLEAR^RORERR("LOG^RORHDT")
"RTN","RORHDT",55,0)
 ;--- Select registry and task
"RTN","RORHDT",56,0)
 S REGIEN=$$SELREG^RORHDTUT()                  G:REGIEN<0 ERROR
"RTN","RORHDT",57,0)
 Q:'REGIEN
"RTN","RORHDT",58,0)
 S TASKIEN=$$SELTASK^RORHDTUT(REGIEN)         G:TASKIEN<0 ERROR
"RTN","RORHDT",59,0)
 Q:'TASKIEN
"RTN","RORHDT",60,0)
 ;--- Display the log
"RTN","RORHDT",61,0)
 S RC=$$LOG^RORHDT01(REGIEN,TASKIEN)               G:RC<0 ERROR
"RTN","RORHDT",62,0)
 Q
"RTN","RORHDT",63,0)
 ;
"RTN","RORHDT",64,0)
 ;***** STARTS A DATA EXTRACTION TASK
"RTN","RORHDT",65,0)
START ;
"RTN","RORHDT",66,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT",67,0)
 N RORERROR      ; Error processing data
"RTN","RORHDT",68,0)
 N RORPARM       ; Application parameters
"RTN","RORHDT",69,0)
 ;
"RTN","RORHDT",70,0)
 N FAM,RC,REGIEN,TASKIEN
"RTN","RORHDT",71,0)
 S RORPARM("ERR")=1
"RTN","RORHDT",72,0)
 ;S RORPARM("DEBUG")=2 ; Remove the first ';' to start in debug mode
"RTN","RORHDT",73,0)
 D CLEAR^RORERR("START^RORHDT")
"RTN","RORHDT",74,0)
 ;--- Select registry and task
"RTN","RORHDT",75,0)
 S REGIEN=$$SELREG^RORHDTUT()                  G:REGIEN<0 ERROR
"RTN","RORHDT",76,0)
 Q:'REGIEN
"RTN","RORHDT",77,0)
 S TASKIEN=$$SELTASK^RORHDTUT(REGIEN)         G:TASKIEN<0 ERROR
"RTN","RORHDT",78,0)
 Q:'TASKIEN
"RTN","RORHDT",79,0)
 ;--- Start the task
"RTN","RORHDT",80,0)
 S RC=$$START^RORHDTAC(REGIEN,TASKIEN,.FAM)        G:RC<0 ERROR
"RTN","RORHDT",81,0)
 I RC  S RC=$$START^RORHDT03(REGIEN,TASKIEN,FAM)   G:RC<0 ERROR
"RTN","RORHDT",82,0)
 Q
"RTN","RORHDT",83,0)
 ;
"RTN","RORHDT",84,0)
 ;***** DISPLAYS DATA EXTRACTION STATUS
"RTN","RORHDT",85,0)
STATUS ;
"RTN","RORHDT",86,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT",87,0)
 N RORERROR      ; Error processing data
"RTN","RORHDT",88,0)
 N RORPARM       ; Application parameters
"RTN","RORHDT",89,0)
 ;
"RTN","RORHDT",90,0)
 N DIR,POP,RC,REGIEN,TMP
"RTN","RORHDT",91,0)
 S RORPARM("ERR")=1
"RTN","RORHDT",92,0)
 ;S RORPARM("DEBUG")=2 ; Remove the first ';' to start in debug mode
"RTN","RORHDT",93,0)
 D CLEAR^RORERR("STATUS^RORHDT")
"RTN","RORHDT",94,0)
 ;--- Select a registry
"RTN","RORHDT",95,0)
 S REGIEN=$$SELREG^RORHDTUT()                  G:REGIEN<0 ERROR
"RTN","RORHDT",96,0)
 Q:'REGIEN
"RTN","RORHDT",97,0)
 ;--- Display status of the data extraction
"RTN","RORHDT",98,0)
 S RC=$$STATUS^RORHDT01(REGIEN)
"RTN","RORHDT",99,0)
 D PAUSE^RORHDTUT,^%ZISC                           G:RC<0 ERROR
"RTN","RORHDT",100,0)
 Q
"RTN","RORHDT",101,0)
 ;
"RTN","RORHDT",102,0)
 ;***** STOPS A DATA EXTRACTION TASK
"RTN","RORHDT",103,0)
STOP ;
"RTN","RORHDT",104,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT",105,0)
 N RORERROR      ; Error processing data
"RTN","RORHDT",106,0)
 N RORPARM       ; Application parameters
"RTN","RORHDT",107,0)
 ;
"RTN","RORHDT",108,0)
 N RC,REGIEN,TASKIEN
"RTN","RORHDT",109,0)
 S RORPARM("ERR")=1
"RTN","RORHDT",110,0)
 ;S RORPARM("DEBUG")=2 ; Remove the first ';' to start in debug mode
"RTN","RORHDT",111,0)
 D CLEAR^RORERR("STOP^RORHDT")
"RTN","RORHDT",112,0)
 ;--- Select registry and task
"RTN","RORHDT",113,0)
 S REGIEN=$$SELREG^RORHDTUT()                  G:REGIEN<0 ERROR
"RTN","RORHDT",114,0)
 Q:'REGIEN
"RTN","RORHDT",115,0)
 S TASKIEN=$$SELTASK^RORHDTUT(REGIEN)         G:TASKIEN<0 ERROR
"RTN","RORHDT",116,0)
 Q:'TASKIEN
"RTN","RORHDT",117,0)
 ;--- Stop the task
"RTN","RORHDT",118,0)
 S RC=$$STOP^RORHDTAC(REGIEN,TASKIEN)              G:RC<0 ERROR
"RTN","RORHDT",119,0)
 I RC  S RC=$$STOP^RORHDT03(REGIEN,TASKIEN)        G:RC<0 ERROR
"RTN","RORHDT",120,0)
 Q
"RTN","RORHDT01")
0^17^B8808254
"RTN","RORHDT01",1,0)
RORHDT01 ;HCIOFO/SG - HISTORICAL DATA EXTRACTION STATUS ; 12/19/01 9:14am
"RTN","RORHDT01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHDT01",3,0)
 ;
"RTN","RORHDT01",4,0)
 Q
"RTN","RORHDT01",5,0)
 ;
"RTN","RORHDT01",6,0)
 ;***** DISPLAYS A LINE OF THE STATUS TABLE
"RTN","RORHDT01",7,0)
 ;
"RTN","RORHDT01",8,0)
 ; RORBUF        Field values from the record of the file #798.5
"RTN","RORHDT01",9,0)
 ;               returned by LIST^DIC
"RTN","RORHDT01",10,0)
 ;
"RTN","RORHDT01",11,0)
 ; IT            Index in the table
"RTN","RORHDT01",12,0)
 ;
"RTN","RORHDT01",13,0)
DSL(IT) ;
"RTN","RORHDT01",14,0)
 ;;!?2^StartIEN^$J($G(RORBUF("DILIST","ID",IT,.01)),8)
"RTN","RORHDT01",15,0)
 ;;?12^File Name^$G(RORBUF("DILIST","ID",IT,1.01))
"RTN","RORHDT01",16,0)
 ;;?45^Task^$G(RORBUF("DILIST","ID",IT,2.01))
"RTN","RORHDT01",17,0)
 ;;?55^Status^$G(RORBUF("DILIST","ID",IT,2.03))
"RTN","RORHDT01",18,0)
 ;
"RTN","RORHDT01",19,0)
 N I,TMP
"RTN","RORHDT01",20,0)
 ;--- Display the headers
"RTN","RORHDT01",21,0)
 I '$G(IT)  D  Q
"RTN","RORHDT01",22,0)
 . F I=1:1  S TMP=$P($T(DSL+I),";;",2,999)  Q:TMP=""  D
"RTN","RORHDT01",23,0)
 . . W @$TR($P(TMP,"^")," "),$P(TMP,"^",2)
"RTN","RORHDT01",24,0)
 ;--- Display the values
"RTN","RORHDT01",25,0)
 F I=1:1  S TMP=$P($T(DSL+I),";;",2,999)  Q:TMP=""  D
"RTN","RORHDT01",26,0)
 . W @$TR($P(TMP,"^")," "),@$P(TMP,"^",3)
"RTN","RORHDT01",27,0)
 Q
"RTN","RORHDT01",28,0)
 ;
"RTN","RORHDT01",29,0)
 ;***** DISPLAYS THE LATEST TASK LOG
"RTN","RORHDT01",30,0)
 ;
"RTN","RORHDT01",31,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT01",32,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT01",33,0)
 ;
"RTN","RORHDT01",34,0)
 ; Return Values:
"RTN","RORHDT01",35,0)
 ;       <0  Error code
"RTN","RORHDT01",36,0)
 ;        0  Ok
"RTN","RORHDT01",37,0)
 ;
"RTN","RORHDT01",38,0)
LOG(REGIEN,TASKIEN) ;
"RTN","RORHDT01",39,0)
 N IENS,IOP,LOGIEN,RC,RORMSG,TMP
"RTN","RORHDT01",40,0)
 ;--- Get the latest log IEN of the task
"RTN","RORHDT01",41,0)
 S IENS=TASKIEN_","
"RTN","RORHDT01",42,0)
 S LOGIEN=+$$GET1^DIQ(798.5,IENS,2.04,"I",,"RORMSG")
"RTN","RORHDT01",43,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"LOG^RORHDT01",,798.5,IENS)
"RTN","RORHDT01",44,0)
 ;--- Check if the log exists
"RTN","RORHDT01",45,0)
 I 'LOGIEN!'$D(^RORDATA(798.7,LOGIEN))  D  Q 0
"RTN","RORHDT01",46,0)
 . W !,"Sorry. The log is not available.",!
"RTN","RORHDT01",47,0)
 ;--- Print the log
"RTN","RORHDT01",48,0)
 S L=0,DIC=798.7
"RTN","RORHDT01",49,0)
 S BY="NUMBER;@,4,.01;@",FLDS="[ROR LOG]"
"RTN","RORHDT01",50,0)
 S (FR,TO)=LOGIEN
"RTN","RORHDT01",51,0)
 D EN1^DIP
"RTN","RORHDT01",52,0)
 Q 0
"RTN","RORHDT01",53,0)
 ;
"RTN","RORHDT01",54,0)
 ;***** DISPLAYS DATA EXTRACTION STATUS OF THE REGISTRY
"RTN","RORHDT01",55,0)
 ;
"RTN","RORHDT01",56,0)
 ; RORREG       Registry IEN
"RTN","RORHDT01",57,0)
 ;
"RTN","RORHDT01",58,0)
 ; Return Values:
"RTN","RORHDT01",59,0)
 ;       <0  Error code
"RTN","RORHDT01",60,0)
 ;        0  Ok
"RTN","RORHDT01",61,0)
 ;
"RTN","RORHDT01",62,0)
STATUS(RORREG) ;
"RTN","RORHDT01",63,0)
 N IENS,IT,RC,RORBUF,RORMSG,RUNNING,SCR,TASKIEN,TMP
"RTN","RORHDT01",64,0)
 S IENS=RORREG_","
"RTN","RORHDT01",65,0)
 ;--- Get values from the main record
"RTN","RORHDT01",66,0)
 D GETS^DIQ(798.1,IENS,".01;21.01;21.02;21.03","EI","RORBUF","RORMSG")
"RTN","RORHDT01",67,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"STATUS^RORHDT01",,798.1,IENS)
"RTN","RORHDT01",68,0)
 ;--- Display the registry information
"RTN","RORHDT01",69,0)
 W !,"Registry: ",$G(RORBUF(798.1,IENS,.01,"E"))
"RTN","RORHDT01",70,0)
 W !,"========"
"RTN","RORHDT01",71,0)
 W !,"Start Date: ",$G(RORBUF(798.1,IENS,21.01,"E"))
"RTN","RORHDT01",72,0)
 W ?40,"End Date: ",$G(RORBUF(798.1,IENS,21.02,"E"))
"RTN","RORHDT01",73,0)
 W !,"Output Directory: ",$G(RORBUF(798.1,IENS,21.03,"E"))
"RTN","RORHDT01",74,0)
 ;--- Get a list of tasks
"RTN","RORHDT01",75,0)
 K RORBUF,RORMSG
"RTN","RORHDT01",76,0)
 S TMP="@;.01E;1.01E;2.01;2.02"
"RTN","RORHDT01",77,0)
 ;
"RTN","RORHDT01",78,0)
 S SCR="I $P(^(0),U,2)=RORREG"
"RTN","RORHDT01",79,0)
 D LIST^DIC(798.5,,TMP,"Q",,,RORREG,"C",SCR,,"RORBUF","RORMSG")
"RTN","RORHDT01",80,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"STATUS^RORHDT01",,798.5)
"RTN","RORHDT01",81,0)
 I $G(RORBUF("DILIST",0))<1  D  Q 0
"RTN","RORHDT01",82,0)
 . W !!,?10,"No tasks have been defined",!
"RTN","RORHDT01",83,0)
 ;--- Get status of the tasks
"RTN","RORHDT01",84,0)
 S IT=""
"RTN","RORHDT01",85,0)
 F  S IT=$O(RORBUF("DILIST","ID",IT))  Q:IT=""  D
"RTN","RORHDT01",86,0)
 . S TASKIEN=+RORBUF("DILIST",2,IT)
"RTN","RORHDT01",87,0)
 . S TMP=$$STATUS^RORHDTUT(RORREG,TASKIEN)
"RTN","RORHDT01",88,0)
 . S RORBUF("DILIST","ID",IT,2.03)=$P(TMP,U,2)
"RTN","RORHDT01",89,0)
 ;--- Display the task table
"RTN","RORHDT01",90,0)
 W !  D DSL()  W !
"RTN","RORHDT01",91,0)
 S IT=""
"RTN","RORHDT01",92,0)
 F  S IT=$O(RORBUF("DILIST","ID",IT))  Q:IT=""  D DSL(IT)
"RTN","RORHDT01",93,0)
 W !
"RTN","RORHDT01",94,0)
 Q 0
"RTN","RORHDT02")
0^18^B3532335
"RTN","RORHDT02",1,0)
RORHDT02 ;HCIOFO/SG - CREATE EXTRACTION TASK RECORDS ; 3/29/02 10:33am
"RTN","RORHDT02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHDT02",3,0)
 ;
"RTN","RORHDT02",4,0)
 Q
"RTN","RORHDT02",5,0)
 ;
"RTN","RORHDT02",6,0)
 ;***** (RE)CREATES THE TASK TABLE
"RTN","RORHDT02",7,0)
 ;
"RTN","RORHDT02",8,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT02",9,0)
 ; [NTSK]        Number of tasks to create
"RTN","RORHDT02",10,0)
 ;
"RTN","RORHDT02",11,0)
 ; Return Values:
"RTN","RORHDT02",12,0)
 ;       <0  Error code
"RTN","RORHDT02",13,0)
 ;        0  Ok
"RTN","RORHDT02",14,0)
 ;        1  Timeout or "^"
"RTN","RORHDT02",15,0)
 ;
"RTN","RORHDT02",16,0)
CREATE(REGIEN,NTSK) ;
"RTN","RORHDT02",17,0)
 N FNAME,HIGHIEN,I,IDL,IENS,LOWIEN,NRE,RORFDA,RORMSG,RRIEN,UI
"RTN","RORHDT02",18,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,X,Y
"RTN","RORHDT02",19,0)
 S FNAME="S"_+$$SITE^VASITE()_"T"
"RTN","RORHDT02",20,0)
 S UI='$G(NTSK)
"RTN","RORHDT02",21,0)
 ;--- Count number of records in the registry
"RTN","RORHDT02",22,0)
 W:UI !,"Calculating size of the registry ..."
"RTN","RORHDT02",23,0)
 S NRE=$$REGSIZE^RORUTL02(REGIEN,.LOWIEN,.HIGHIEN)
"RTN","RORHDT02",24,0)
 W:UI *13,"Number of patients in the registry: ",NRE,!
"RTN","RORHDT02",25,0)
 ;--- Ask for a number of data extraction tasks if the registry con-
"RTN","RORHDT02",26,0)
 ;    tains more than 1000 patients. Otherwise, create a single task.
"RTN","RORHDT02",27,0)
 S DIR("A")="Number of data extraction tasks"
"RTN","RORHDT02",28,0)
 I UI,NRE>1000  D  Q:$D(DIRUT) 1  S NTSK=+Y
"RTN","RORHDT02",29,0)
 . S DIR(0)="N^1:12:0"
"RTN","RORHDT02",30,0)
 . S DIR("B")="1"
"RTN","RORHDT02",31,0)
 . D ^DIR  W !
"RTN","RORHDT02",32,0)
 E  S:'$G(NTSK) NTSK=1  W:UI DIR("A")_": ",NTSK,!
"RTN","RORHDT02",33,0)
 ;--- Prepare records in the FDA.
"RTN","RORHDT02",34,0)
 ;    Use 1 instead of LOWIEN as a start value of the RRIEN so that
"RTN","RORHDT02",35,0)
 ;    no records will be missed (just in case)
"RTN","RORHDT02",36,0)
 S RRIEN=1,IDL=(HIGHIEN-LOWIEN)\NTSK,RC=0
"RTN","RORHDT02",37,0)
 S:IDL'>0 NTSK=1
"RTN","RORHDT02",38,0)
 F I=1:1:NTSK  D
"RTN","RORHDT02",39,0)
 . S IENS="+"_I_","
"RTN","RORHDT02",40,0)
 . S RORFDA(798.5,IENS,.01)=RRIEN
"RTN","RORHDT02",41,0)
 . S RORFDA(798.5,IENS,.02)=REGIEN
"RTN","RORHDT02",42,0)
 . S RORFDA(798.5,IENS,1.01)=FNAME_$TR($J(I,2)," ","0")_".HDT"
"RTN","RORHDT02",43,0)
 . S RRIEN=LOWIEN+(I*IDL)
"RTN","RORHDT02",44,0)
 ;--- Ask for the final confirmation
"RTN","RORHDT02",45,0)
 I UI  D  Q:$D(DIRUT)!'$G(Y) 1
"RTN","RORHDT02",46,0)
 . S DIR(0)="Y"
"RTN","RORHDT02",47,0)
 . S DIR("A")="Create the new task table"
"RTN","RORHDT02",48,0)
 . S DIR("B")="NO"
"RTN","RORHDT02",49,0)
 . D ^DIR  W !
"RTN","RORHDT02",50,0)
 ;--- Create the new task table
"RTN","RORHDT02",51,0)
 S RC=$$CLRTTBL^RORHDTUT(REGIEN)  Q:RC<0 RC
"RTN","RORHDT02",52,0)
 D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORHDT02",53,0)
 Q $$DBS^RORERR("RORMSG",-9,"CREATE^RORHDT02")
"RTN","RORHDT03")
0^19^B23638721
"RTN","RORHDT03",1,0)
RORHDT03 ;HCIOFO/SG - MANIPULATIONS WITH EXTRACTION TASKS ; 3/29/02 10:36am
"RTN","RORHDT03",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHDT03",3,0)
 ;
"RTN","RORHDT03",4,0)
 Q
"RTN","RORHDT03",5,0)
 ;
"RTN","RORHDT03",6,0)
 ;***** CHECKS FOR A STOP REQUESTS (TASKMAN & PROPRIETARY)
"RTN","RORHDT03",7,0)
 ;
"RTN","RORHDT03",8,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT03",9,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT03",10,0)
 ;
"RTN","RORHDT03",11,0)
 ; Return Values:
"RTN","RORHDT03",12,0)
 ;        0  Continue running
"RTN","RORHDT03",13,0)
 ;        1  Stop the task
"RTN","RORHDT03",14,0)
 ;
"RTN","RORHDT03",15,0)
CHKSTOP(REGIEN,TASKIEN) ;
"RTN","RORHDT03",16,0)
 S ZTSTOP=$G(^XTMP("RORHDT"_REGIEN,"T",TASKIEN))!$$S^%ZTLOAD
"RTN","RORHDT03",17,0)
 Q ZTSTOP
"RTN","RORHDT03",18,0)
 ;
"RTN","RORHDT03",19,0)
 ;***** STARTS THE DATA EXTRACTION TASK
"RTN","RORHDT03",20,0)
 ;
"RTN","RORHDT03",21,0)
 ; RORREG        Registry IEN
"RTN","RORHDT03",22,0)
 ; RORTASK       Task IEN
"RTN","RORHDT03",23,0)
 ; RORFAM        File Access Mode:
"RTN","RORHDT03",24,0)
 ;                 "A"  Append new messages to the file
"RTN","RORHDT03",25,0)
 ;                 "O"  Overwrite the file
"RTN","RORHDT03",26,0)
 ;                 "N"  Modify file name and create a new file
"RTN","RORHDT03",27,0)
 ; [ZTDTH]       Start date/time
"RTN","RORHDT03",28,0)
 ;
"RTN","RORHDT03",29,0)
 ; Return Values:
"RTN","RORHDT03",30,0)
 ;       <0  Error code
"RTN","RORHDT03",31,0)
 ;        0  Ok
"RTN","RORHDT03",32,0)
 ;        1  Start time has not been entered
"RTN","RORHDT03",33,0)
 ;        2  Already running or pending
"RTN","RORHDT03",34,0)
 ;
"RTN","RORHDT03",35,0)
START(RORREG,RORTASK,RORFAM,ZTDTH) ;
"RTN","RORHDT03",36,0)
 N I,RC,RORDUZ,RORMSG,STATUS,TASKNUM
"RTN","RORHDT03",37,0)
 N ZTCPU,ZTDESC,ZTIO,ZTKIL,ZTPRI,ZTRTN,ZTSAVE,ZTSK,ZTSYNC,ZTUCI
"RTN","RORHDT03",38,0)
 ;--- Uncomment the next line of code if you want that an alert
"RTN","RORHDT03",39,0)
 ;    to be sent to initiator of a task upon its completion
"RTN","RORHDT03",40,0)
 S RORDUZ=$G(DUZ)
"RTN","RORHDT03",41,0)
 ;--- Get a name of the registry
"RTN","RORHDT03",42,0)
 S $P(RORREG,U,2)=$$GET1^DIQ(798.1,RORREG_",",.01,,,"RORMSG")
"RTN","RORHDT03",43,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"START^RORHDT03",,798.1,RORREG)
"RTN","RORHDT03",44,0)
 ;--- Check status of the task
"RTN","RORHDT03",45,0)
 S STATUS=+$$STATUS^RORHDTUT(+RORREG,RORTASK,3)
"RTN","RORHDT03",46,0)
 Q:(STATUS=1)!(STATUS=2) 2
"RTN","RORHDT03",47,0)
 ;--- Start/schedule the task
"RTN","RORHDT03",48,0)
 S ZTRTN="TASK^RORHDT03",ZTIO=""
"RTN","RORHDT03",49,0)
 S ZTDESC="Historical data extraction"
"RTN","RORHDT03",50,0)
 F I="RORDUZ","RORFAM","RORREG","RORTASK"  S ZTSAVE(I)=""
"RTN","RORHDT03",51,0)
 D ^%ZTLOAD  S TASKNUM=$G(ZTSK)
"RTN","RORHDT03",52,0)
 ;--- Update task number
"RTN","RORHDT03",53,0)
 S RC=$$UPDTASK(+RORREG,RORTASK,TASKNUM,"","")
"RTN","RORHDT03",54,0)
 Q $S(TASKNUM:RC,1:1)
"RTN","RORHDT03",55,0)
 ;
"RTN","RORHDT03",56,0)
 ;***** STOPS THE DATA EXTRACTION TASK
"RTN","RORHDT03",57,0)
 ;
"RTN","RORHDT03",58,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT03",59,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT03",60,0)
 ;
"RTN","RORHDT03",61,0)
 ; Return Values:
"RTN","RORHDT03",62,0)
 ;       <0  Error code
"RTN","RORHDT03",63,0)
 ;        0  Ok
"RTN","RORHDT03",64,0)
 ;
"RTN","RORHDT03",65,0)
STOP(REGIEN,TASKIEN) ;
"RTN","RORHDT03",66,0)
 N IENS,RC,STATUS,ZTSK
"RTN","RORHDT03",67,0)
 ;--- Get status of the task
"RTN","RORHDT03",68,0)
 S STATUS=+$$STATUS^RORHDTUT(REGIEN,TASKIEN)
"RTN","RORHDT03",69,0)
 ;--- If task is pending, deque it
"RTN","RORHDT03",70,0)
 I STATUS=1  D  Q RC
"RTN","RORHDT03",71,0)
 . S IENS=TASKIEN_","
"RTN","RORHDT03",72,0)
 . S ZTSK=$$GET1^DIQ(798.5,IENS,2.01,,,"RORMSG")
"RTN","RORHDT03",73,0)
 . I $G(DIERR)  D  Q
"RTN","RORHDT03",74,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"STOP^RORHDT03",,798.5,IENS)
"RTN","RORHDT03",75,0)
 . D DQ^%ZTLOAD
"RTN","RORHDT03",76,0)
 . S RC=$S('$G(ZTSK(0)):$$ERROR^RORERR(-33,"STOP^RORHDT03"),1:0)
"RTN","RORHDT03",77,0)
 ;--- If task is running, stop it
"RTN","RORHDT03",78,0)
 I STATUS=2  S ^XTMP("RORHDT"_REGIEN,"T",TASKIEN)=1  Q 0
"RTN","RORHDT03",79,0)
 Q 0
"RTN","RORHDT03",80,0)
 ;
"RTN","RORHDT03",81,0)
 ;***** HISTORICAL DATA EXTRACTION TASK
"RTN","RORHDT03",82,0)
 ;
"RTN","RORHDT03",83,0)
 ; [RORDUZ]      DUZ of a task initiator.
"RTN","RORHDT03",84,0)
 ;               If this variable is defined and greater than zero,
"RTN","RORHDT03",85,0)
 ;               an alert is sent to initiator of a task upon the
"RTN","RORHDT03",86,0)
 ;               task completion.
"RTN","RORHDT03",87,0)
 ;
"RTN","RORHDT03",88,0)
 ; RORFAM        File Access Mode:
"RTN","RORHDT03",89,0)
 ;                 "A"  Append new messages to the file
"RTN","RORHDT03",90,0)
 ;                 "O"  Overwrite the file
"RTN","RORHDT03",91,0)
 ;                 "N"  Modify file name and create a new file
"RTN","RORHDT03",92,0)
 ;
"RTN","RORHDT03",93,0)
 ; RORREG        Registry to process
"RTN","RORHDT03",94,0)
 ;                 ^1: Registry IEN
"RTN","RORHDT03",95,0)
 ;                 ^2: Registry Name
"RTN","RORHDT03",96,0)
 ;
"RTN","RORHDT03",97,0)
 ; RORTASK       IEN of the data extraction task in the ROR HDT
"RTN","RORHDT03",98,0)
 ;               TASK file
"RTN","RORHDT03",99,0)
 ;
"RTN","RORHDT03",100,0)
TASK ;
"RTN","RORHDT03",101,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT03",102,0)
 N RORERROR      ; Error processing data
"RTN","RORHDT03",103,0)
 N RORLOG        ; Log susbsystem data
"RTN","RORHDT03",104,0)
 N RORPARM       ; Application parameters
"RTN","RORHDT03",105,0)
 ;
"RTN","RORHDT03",106,0)
 N COUNTERS,HDTNODE,RC,REGLST,TMP,XQA,XQAFLG,XQAMSG
"RTN","RORHDT03",107,0)
 ;--- Force "UNDEF" error if task parameters are not defined
"RTN","RORHDT03",108,0)
 I '("ANO"[$G(RORFAM))  K RORFAM   S RC=RORFAM
"RTN","RORHDT03",109,0)
 I $G(RORREG)'>0        K RORREG   S RC=RORREG
"RTN","RORHDT03",110,0)
 I $G(RORTASK)'>0       K RORTASK  S RC=RORTASK
"RTN","RORHDT03",111,0)
 ;--- Initialize constants and variables
"RTN","RORHDT03",112,0)
 D INIT^RORUTL01("RORHDT"),CLEAR^RORERR("TASK^RORHDT03")
"RTN","RORHDT03",113,0)
 S HDTNODE=$NA(^XTMP("RORHDT"_+RORREG))
"RTN","RORHDT03",114,0)
 ;S RORPARM("DEBUG")=1 ; Remove the first ';' to start in debug mode
"RTN","RORHDT03",115,0)
 S RORPARM("ERR")=1
"RTN","RORHDT03",116,0)
 S RORPARM("LOG")=1
"RTN","RORHDT03",117,0)
 ;--- Check if the task is running
"RTN","RORHDT03",118,0)
 L +@HDTNODE@("T",RORTASK):3
"RTN","RORHDT03",119,0)
 E  S ZTSTOP=1  Q
"RTN","RORHDT03",120,0)
 K @HDTNODE@("T",RORTASK)
"RTN","RORHDT03",121,0)
 ;--- Update node descriptor in the ^XTMP global
"RTN","RORHDT03",122,0)
 D XTMPHDR^RORUTL01("RORHDT"_+RORREG,30,"TASK-RORHDT03")
"RTN","RORHDT03",123,0)
 ;--- Open a new log
"RTN","RORHDT03",124,0)
 S REGLST($P(RORREG,U,2))=+RORREG
"RTN","RORHDT03",125,0)
 S TMP=$$OPEN^RORLOG(.REGLST,4,"HISTORICAL DATA EXTRACTION STARTED")
"RTN","RORHDT03",126,0)
 K REGLST
"RTN","RORHDT03",127,0)
 ;--- Historical data extraction
"RTN","RORHDT03",128,0)
 D
"RTN","RORHDT03",129,0)
 . S RC=$$UPDTASK(+RORREG,RORTASK,ZTSK,$J,"",$$LOGIEN^RORLOG)  Q:RC<0
"RTN","RORHDT03",130,0)
 . S RC=$$EXTRACT^RORHDT04(RORREG,RORTASK,RORFAM)              Q:RC<0
"RTN","RORHDT03",131,0)
 . S COUNTERS=RC,TMP='$G(ZTSTOP)&'$P(RC,U,2)
"RTN","RORHDT03",132,0)
 . S TMP=$$UPDTASK(+RORREG,RORTASK,,"",TMP)
"RTN","RORHDT03",133,0)
 ;
"RTN","RORHDT03",134,0)
 ;--- Statistics & Cleanup
"RTN","RORHDT03",135,0)
 S TMP=$S($G(ZTSTOP):"WAS STOPPED",RC<0:"ABORTED",1:"FINISHED")
"RTN","RORHDT03",136,0)
 D CLOSE^RORLOG("HISTORICAL DATA EXTRACTION "_TMP,$G(COUNTERS))
"RTN","RORHDT03",137,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("RORHDT")
"RTN","RORHDT03",138,0)
 ;--- Reset "Running" flag
"RTN","RORHDT03",139,0)
 K @HDTNODE@("T",RORTASK)
"RTN","RORHDT03",140,0)
 L -@HDTNODE@("T",RORTASK)
"RTN","RORHDT03",141,0)
 ;--- Send an alert to the user
"RTN","RORHDT03",142,0)
 I $G(RORDUZ)>0  D  D SETUP^XQALERT
"RTN","RORHDT03",143,0)
 . S XQA(RORDUZ)="",XQAFLG="D"
"RTN","RORHDT03",144,0)
 . S XQAMSG="Historical data extraction task has finished (RC="_RC_")"
"RTN","RORHDT03",145,0)
 S ZTREQ="@"
"RTN","RORHDT03",146,0)
 Q
"RTN","RORHDT03",147,0)
 ;
"RTN","RORHDT03",148,0)
 ;***** UPDATES TASK RECORD
"RTN","RORHDT03",149,0)
 ;
"RTN","RORHDT03",150,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT03",151,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT03",152,0)
 ; [TASKNUM]     Task number
"RTN","RORHDT03",153,0)
 ; [JOBNUM]      Job number
"RTN","RORHDT03",154,0)
 ; [LOGIEN]      IEN of the latest task log
"RTN","RORHDT03",155,0)
 ;
"RTN","RORHDT03",156,0)
 ; The function updates task record fields with values of the
"RTN","RORHDT03",157,0)
 ; parameters. If a parameter is omitted, corresponding field retain
"RTN","RORHDT03",158,0)
 ; its current value.
"RTN","RORHDT03",159,0)
 ;
"RTN","RORHDT03",160,0)
 ; If the JOBNUM parameter is defined and not zero (it means that a
"RTN","RORHDT03",161,0)
 ; new job is being started), the COMPLETED field is always cleared.
"RTN","RORHDT03",162,0)
 ;
"RTN","RORHDT03",163,0)
 ; If the CMPLTD parameter is defined and not zero (the task has been
"RTN","RORHDT03",164,0)
 ; completed successfully), the TASKNUM field is always cleared.
"RTN","RORHDT03",165,0)
 ;
"RTN","RORHDT03",166,0)
 ; Return Values:
"RTN","RORHDT03",167,0)
 ;       <0  Error code
"RTN","RORHDT03",168,0)
 ;        0  Ok
"RTN","RORHDT03",169,0)
 ;
"RTN","RORHDT03",170,0)
UPDTASK(REGIEN,TASKIEN,TASKNUM,JOBNUM,CMPLTD,LOGIEN) ;
"RTN","RORHDT03",171,0)
 N IENS,RORFDA,RORMSG
"RTN","RORHDT03",172,0)
 S IENS=TASKIEN_","
"RTN","RORHDT03",173,0)
 I $D(JOBNUM)#2  D  S:JOBNUM CMPLTD=""
"RTN","RORHDT03",174,0)
 . S RORFDA(798.5,IENS,2.02)=JOBNUM
"RTN","RORHDT03",175,0)
 I $D(CMPLTD)#2  D  S:CMPLTD TASKNUM=""
"RTN","RORHDT03",176,0)
 . S RORFDA(798.5,IENS,2.03)=CMPLTD
"RTN","RORHDT03",177,0)
 S:$D(TASKNUM)#2 RORFDA(798.5,IENS,2.01)=TASKNUM
"RTN","RORHDT03",178,0)
 S:$D(LOGIEN)#2 RORFDA(798.5,IENS,2.04)=LOGIEN
"RTN","RORHDT03",179,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORHDT03",180,0)
 Q $$DBS^RORERR("RORMSG",-9,"UPDTASK^RORHDT03")
"RTN","RORHDT04")
0^20^B30783840
"RTN","RORHDT04",1,0)
RORHDT04 ;HCIOFO/SG - HISTORICAL DATA EXTRACTION PROCESS ; 3/29/02 10:36am
"RTN","RORHDT04",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHDT04",3,0)
 ;
"RTN","RORHDT04",4,0)
 Q
"RTN","RORHDT04",5,0)
 ;
"RTN","RORHDT04",6,0)
 ;***** DATA EXTRACTION PROCESS
"RTN","RORHDT04",7,0)
 ;
"RTN","RORHDT04",8,0)
 ; REGISTRY      Registry to process
"RTN","RORHDT04",9,0)
 ;                 ^1: Registry IEN
"RTN","RORHDT04",10,0)
 ;                 ^2: Registry Name
"RTN","RORHDT04",11,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT04",12,0)
 ; FAM           File Access Mode
"RTN","RORHDT04",13,0)
 ;
"RTN","RORHDT04",14,0)
 ; Return Values:
"RTN","RORHDT04",15,0)
 ;       <0  Error code
"RTN","RORHDT04",16,0)
 ;      >=0  Statistics
"RTN","RORHDT04",17,0)
 ;             ^1: Total number of processed patients
"RTN","RORHDT04",18,0)
 ;             ^2: Number of patients processed with errors
"RTN","RORHDT04",19,0)
 ;
"RTN","RORHDT04",20,0)
EXTRACT(REGISTRY,TASKIEN,FAM) ;
"RTN","RORHDT04",21,0)
 N RORDATE       ; Date/time when the first registry update finished
"RTN","RORHDT04",22,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT04",23,0)
 N ROREXT        ; Data extraction descriptor
"RTN","RORHDT04",24,0)
 N RORHL         ; HL7 variables
"RTN","RORHDT04",25,0)
 N RORLRC        ; List of codes of Lab results to be extracted
"RTN","RORHDT04",26,0)
 ;
"RTN","RORHDT04",27,0)
 N CNT           ; Number of processed registry records
"RTN","RORHDT04",28,0)
 N ECNT          ; Number of records processed with errors
"RTN","RORHDT04",29,0)
 N FILE          ; Name of the output file
"RTN","RORHDT04",30,0)
 N OUTDIR        ; Name of the output directory
"RTN","RORHDT04",31,0)
 ;
"RTN","RORHDT04",32,0)
 N BDT,EDT,POP,RC,REGIEN,REGLST,REGNAME,RRBIEN,RREIEN,STOP,TMP
"RTN","RORHDT04",33,0)
 D DFLTLOC^RORERR("EXTRACT^RORHDT04")
"RTN","RORHDT04",34,0)
 K ^TMP("RORHDT",$J,"PR")
"RTN","RORHDT04",35,0)
 S REGNAME=$P(REGISTRY,U,2),(REGLST(REGNAME),REGIEN)=+REGISTRY
"RTN","RORHDT04",36,0)
 S (CNT,ECNT,STOP)=0
"RTN","RORHDT04",37,0)
 S RORHDT("BHS")=(FAM'="A")
"RTN","RORHDT04",38,0)
 ;--- Load parameters
"RTN","RORHDT04",39,0)
 S RC=$$REGPARM^RORHDT05(REGIEN,.BDT,.EDT,.OUTDIR,.RORDATE)
"RTN","RORHDT04",40,0)
 Q:RC<0 RC
"RTN","RORHDT04",41,0)
 S RC=$$TASKPARM^RORHDT05(REGIEN,TASKIEN,.RRBIEN,.RREIEN,.FILE)
"RTN","RORHDT04",42,0)
 Q:RC<0 RC
"RTN","RORHDT04",43,0)
 ;--- Prepare data extraction rules
"RTN","RORHDT04",44,0)
 S RC=$$PREPARE^ROREXPR(REGNAME,BDT,EDT)
"RTN","RORHDT04",45,0)
 Q:RC<0 $$ERROR^RORERR(-22)
"RTN","RORHDT04",46,0)
 K ROREXT("LD") ; Do not use lag intervals
"RTN","RORHDT04",47,0)
 S RC=$$INIT^RORHL7()  Q:RC<0 RC
"RTN","RORHDT04",48,0)
 ;--- Create/Verify the output file
"RTN","RORHDT04",49,0)
 D OPEN^%ZISH("HL7FILE",OUTDIR,FILE,$S(FAM="A":"A",1:"W"))
"RTN","RORHDT04",50,0)
 Q:$G(POP) $$ERROR^RORERR(-34,,OUTDIR_FILE)
"RTN","RORHDT04",51,0)
 U IO  W ""  D CLOSE^%ZISH("HL7FILE")
"RTN","RORHDT04",52,0)
 ;---
"RTN","RORHDT04",53,0)
 D
"RTN","RORHDT04",54,0)
 . N IEN,LAST,NODE,NRTC,PATIEN
"RTN","RORHDT04",55,0)
 . S NRTC=100 ; Number of records to commit
"RTN","RORHDT04",56,0)
 . ;--- Try to re-extract erroneous records
"RTN","RORHDT04",57,0)
 . S NODE=$$ROOT^DILFD(798.53,","_TASKIEN_",",1)
"RTN","RORHDT04",58,0)
 . S NODE=$NA(@NODE@("B"))
"RTN","RORHDT04",59,0)
 . S IEN=0,RC=0
"RTN","RORHDT04",60,0)
 . F  D  Q:RC!STOP!(IEN="")
"RTN","RORHDT04",61,0)
 . . K ^TMP("HLS",$J)
"RTN","RORHDT04",62,0)
 . . F  S IEN=$O(@NODE@(IEN))  Q:IEN=""  D  Q:RC!'((CNT-ECNT)#NRTC)
"RTN","RORHDT04",63,0)
 . . . S RC=$$CHKSTOP^RORHDT03(REGIEN,TASKIEN)
"RTN","RORHDT04",64,0)
 . . . I RC  S STOP=1  Q
"RTN","RORHDT04",65,0)
 . . . S RC=$$PROCREC(REGIEN,IEN,.PATIEN),CNT=CNT+1
"RTN","RORHDT04",66,0)
 . . . S ^TMP("RORHDT",$J,"PR",IEN)=RC
"RTN","RORHDT04",67,0)
 . . . I RC'<0  S RC=0  Q
"RTN","RORHDT04",68,0)
 . . . ;--- Proccess the error
"RTN","RORHDT04",69,0)
 . . . S RC=$$ERROR^RORERR(-15,,,$G(PATIEN)),ECNT=ECNT+1
"RTN","RORHDT04",70,0)
 . . . S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORHDT04",71,0)
 . . Q:RC<0
"RTN","RORHDT04",72,0)
 . . ;--- Commit the data
"RTN","RORHDT04",73,0)
 . . S TMP=$$COMMIT^RORHDT05(OUTDIR,FILE)
"RTN","RORHDT04",74,0)
 . . S:TMP<0 RC=TMP
"RTN","RORHDT04",75,0)
 . Q:STOP
"RTN","RORHDT04",76,0)
 . ;--- Extract the remaining registry data
"RTN","RORHDT04",77,0)
 . S NODE=$$ROOT^DILFD(798,,1)
"RTN","RORHDT04",78,0)
 . S NODE=$NA(@NODE@("AC",REGIEN))
"RTN","RORHDT04",79,0)
 . S IEN=$S(RRBIEN>0:RRBIEN-1,1:0)
"RTN","RORHDT04",80,0)
 . S RC=0
"RTN","RORHDT04",81,0)
 . F  D  Q:RC!STOP!(IEN'>0)
"RTN","RORHDT04",82,0)
 . . K ^TMP("HLS",$J)
"RTN","RORHDT04",83,0)
 . . F  S IEN=$O(@NODE@(IEN))  Q:IEN'>0  D  Q:RC!'((CNT-ECNT)#NRTC)
"RTN","RORHDT04",84,0)
 . . . S RC=$$CHKSTOP^RORHDT03(REGIEN,TASKIEN)
"RTN","RORHDT04",85,0)
 . . . I RC  S STOP=1  Q
"RTN","RORHDT04",86,0)
 . . . I RREIEN>0,IEN'<RREIEN  S IEN="",RC=1  Q
"RTN","RORHDT04",87,0)
 . . . Q:$D(^TMP("RORHDT",$J,"PR",IEN))
"RTN","RORHDT04",88,0)
 . . . S RC=$$PROCREC(REGIEN,IEN,.PATIEN),CNT=CNT+1
"RTN","RORHDT04",89,0)
 . . . I RC'<0  S RC=0  Q
"RTN","RORHDT04",90,0)
 . . . ;--- Proccess the error
"RTN","RORHDT04",91,0)
 . . . S RC=$$ERROR^RORERR(-15,,,,$G(PATIEN)),ECNT=ECNT+1
"RTN","RORHDT04",92,0)
 . . . S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORHDT04",93,0)
 . . . S TMP=$$ADDERR^RORHDT05(REGIEN,TASKIEN,IEN)
"RTN","RORHDT04",94,0)
 . . . S:TMP<0 RC=TMP
"RTN","RORHDT04",95,0)
 . . Q:RC<0
"RTN","RORHDT04",96,0)
 . . ;--- If completed with errors, use IEN of the last processed
"RTN","RORHDT04",97,0)
 . . ;    registry record instead of an empty string. When the task
"RTN","RORHDT04",98,0)
 . . ;    is restarted, it will try to re-extract only erroneous
"RTN","RORHDT04",99,0)
 . . ;    records and will not process already extracted data (RRBIEN
"RTN","RORHDT04",100,0)
 . . ;    will not be less than RREIEN).
"RTN","RORHDT04",101,0)
 . . ;--- If the task completed successfuly, the NEXT RECORD IEN
"RTN","RORHDT04",102,0)
 . . ;    field is set to an empty string. If the task is restarted
"RTN","RORHDT04",103,0)
 . . ;    afterwards, it will re-extract all data again.
"RTN","RORHDT04",104,0)
 . . S LAST=$S(IEN>0:IEN,'ECNT:"",RREIEN>0:RREIEN,1:$O(@NODE@(""),-1))
"RTN","RORHDT04",105,0)
 . . ;--- Commit the data
"RTN","RORHDT04",106,0)
 . . S TMP=$$COMMIT^RORHDT05(OUTDIR,FILE,LAST,REGIEN,TASKIEN)
"RTN","RORHDT04",107,0)
 . . S:TMP<0 RC=TMP
"RTN","RORHDT04",108,0)
 ;
"RTN","RORHDT04",109,0)
 ;--- Write the batch trailer segment (if the batch is not empty)
"RTN","RORHDT04",110,0)
 D:'$G(RORHDT("BHS"))
"RTN","RORHDT04",111,0)
 . D OPEN^%ZISH("HL7FILE",OUTDIR,FILE,"A")
"RTN","RORHDT04",112,0)
 . Q:$G(POP)  U IO
"RTN","RORHDT04",113,0)
 . S TMP=$S(ECNT!(RC<0):"Completed with errors",STOP:"Stopped",1:"")
"RTN","RORHDT04",114,0)
 . W $$BTS^RORHL7($$MSGCNT^RORHL7,TMP),$C(13)
"RTN","RORHDT04",115,0)
 . D CLOSE^%ZISH("HL7FILE")
"RTN","RORHDT04",116,0)
 ;--- Cleanup
"RTN","RORHDT04",117,0)
 S:RC'<0 RC=$$CLRERRS^RORHDT05(REGIEN,TASKIEN)
"RTN","RORHDT04",118,0)
 Q $S(RC<0:RC,1:CNT_U_ECNT)
"RTN","RORHDT04",119,0)
 ;
"RTN","RORHDT04",120,0)
 ;***** PROCESSES A RECORD IN THE REGISTRY
"RTN","RORHDT04",121,0)
 ;
"RTN","RORHDT04",122,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT04",123,0)
 ; IEN           IEN of a record in the registry
"RTN","RORHDT04",124,0)
 ; [.PATIEN]     Patient IEN is returned by this parameter
"RTN","RORHDT04",125,0)
 ;
"RTN","RORHDT04",126,0)
 ; Return Values:
"RTN","RORHDT04",127,0)
 ;       <0  Error code
"RTN","RORHDT04",128,0)
 ;        0  Ok
"RTN","RORHDT04",129,0)
 ;        1  Nothing has been extracted
"RTN","RORHDT04",130,0)
 ;
"RTN","RORHDT04",131,0)
PROCREC(REGIEN,IEN,PATIEN) ;
"RTN","RORHDT04",132,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT04",133,0)
 ;
"RTN","RORHDT04",134,0)
 N ACTIVE,BDT,EDT,IENS,INCTVDT,MSHPTR,RC,RORFDA,RORMSG
"RTN","RORHDT04",135,0)
 D CLEAR^RORERR("PROCREC^RORHDT04")
"RTN","RORHDT04",136,0)
 S IENS=IEN_",",PATIEN=0
"RTN","RORHDT04",137,0)
 ;--- Get the registry record data
"RTN","RORHDT04",138,0)
 D GETS^DIQ(798,IENS,".01;1;2;8","EI","RORFDA","RORMSG")
"RTN","RORHDT04",139,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","RORHDT04",140,0)
 S PATIEN=RORFDA(798,IENS,.01,"I")
"RTN","RORHDT04",141,0)
 S INCTVDT=$G(RORFDA(798,IENS,2,"I"))\1
"RTN","RORHDT04",142,0)
 S ACTIVE=$G(RORFDA(798,IENS,8,"E"))
"RTN","RORHDT04",143,0)
 ;--- Skip the record if it was not added by the first update
"RTN","RORHDT04",144,0)
 I RORDATE  Q:$G(RORFDA(798,IENS,1,"I"))>RORDATE 0
"RTN","RORHDT04",145,0)
 ;--- Prepare extract dates
"RTN","RORHDT04",146,0)
 S BDT=$G(ROREXT("DXBEG")),EDT=$G(ROREXT("DXEND"))
"RTN","RORHDT04",147,0)
 I 'ACTIVE  Q:INCTVDT'>BDT 0  S:EDT>INCTVDT EDT=INCTVDT
"RTN","RORHDT04",148,0)
 ;--- Create HL7 message for the patient
"RTN","RORHDT04",149,0)
 S MSHPTR=$$CREATE^RORHL7()  Q:MSHPTR<0 MSHPTR
"RTN","RORHDT04",150,0)
 S RC=$$MESSAGE^ROREXT02(IEN,PATIEN,BDT,EDT,1)
"RTN","RORHDT04",151,0)
 ;--- Rollback incomplete message if necessary
"RTN","RORHDT04",152,0)
 S:RC'<0 RC=($O(^TMP("HLS",$J,""),-1)'>MSHPTR)
"RTN","RORHDT04",153,0)
 D:RC ROLLBACK^RORHL7(MSHPTR)
"RTN","RORHDT04",154,0)
 Q RC
"RTN","RORHDT05")
0^21^B16124761
"RTN","RORHDT05",1,0)
RORHDT05 ;HCIOFO/SG - HISTORICAL DATA EXTRACTION FUNCTIONS ; 3/29/02 10:38am
"RTN","RORHDT05",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHDT05",3,0)
 ;
"RTN","RORHDT05",4,0)
 Q
"RTN","RORHDT05",5,0)
 ;
"RTN","RORHDT05",6,0)
 ;***** ADDS A RECORD TO THE 'ERROR' MULTIPLE OF THE TASK RECORD
"RTN","RORHDT05",7,0)
 ;
"RTN","RORHDT05",8,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT05",9,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT05",10,0)
 ; IEN           IEN of the erroneous registry record
"RTN","RORHDT05",11,0)
 ;
"RTN","RORHDT05",12,0)
 ; Return Values:
"RTN","RORHDT05",13,0)
 ;       <0  Error code
"RTN","RORHDT05",14,0)
 ;        0  Ok
"RTN","RORHDT05",15,0)
 ;
"RTN","RORHDT05",16,0)
ADDERR(REGIEN,TASKIEN,IEN) ;
"RTN","RORHDT05",17,0)
 N IENS,RC,RORFDA,RORIEN,RORMSG
"RTN","RORHDT05",18,0)
 S IENS="+1,"_TASKIEN_",",RORIEN(1)=IEN
"RTN","RORHDT05",19,0)
 S RORFDA(798.53,IENS,.01)=IEN
"RTN","RORHDT05",20,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORHDT05",21,0)
 Q $$DBS^RORERR("RORMSG",-9,"ADDERR^RORHDT05",,798.53,IENS)
"RTN","RORHDT05",22,0)
 ;
"RTN","RORHDT05",23,0)
 ;***** DELETES RECORDS FROM THE 'ERROR' MULTIPLE OF THE TASK RECORD
"RTN","RORHDT05",24,0)
 ;
"RTN","RORHDT05",25,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT05",26,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT05",27,0)
 ;
"RTN","RORHDT05",28,0)
 ; This functions deletes all erroneous records from the ERROR
"RTN","RORHDT05",29,0)
 ; multiple of the task record that have been re-extracted without
"RTN","RORHDT05",30,0)
 ; errors. So, there is no reason to keep them anymore.
"RTN","RORHDT05",31,0)
 ;
"RTN","RORHDT05",32,0)
 ; Return Values:
"RTN","RORHDT05",33,0)
 ;       <0  Error code
"RTN","RORHDT05",34,0)
 ;        0  Ok
"RTN","RORHDT05",35,0)
 ;
"RTN","RORHDT05",36,0)
CLRERRS(REGIEN,TASKIEN) ;
"RTN","RORHDT05",37,0)
 N I,IEN,RC,RORFDA,RORMSG,SFI
"RTN","RORHDT05",38,0)
 S SFI=","_TASKIEN_",",RC=0
"RTN","RORHDT05",39,0)
 S IEN=""
"RTN","RORHDT05",40,0)
 F  D  Q:(RC<0)!(IEN="")
"RTN","RORHDT05",41,0)
 . F I=1:1:10  S IEN=$O(^TMP("RORHDT",$J,"PR",IEN))  Q:IEN=""  D
"RTN","RORHDT05",42,0)
 . . S:^TMP("RORHDT",$J,"PR",IEN)'<0 RORFDA(798.53,IEN_SFI,.01)="@"
"RTN","RORHDT05",43,0)
 . Q:$D(RORFDA)<10
"RTN","RORHDT05",44,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORHDT05",45,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,"CLRERRS^RORHDT05",,798.53)
"RTN","RORHDT05",46,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORHDT05",47,0)
 ;
"RTN","RORHDT05",48,0)
 ;***** COMMITS HL7 DATA TO THE OUTPUT FILE
"RTN","RORHDT05",49,0)
 ;
"RTN","RORHDT05",50,0)
 ; OUTDIR        Output directory
"RTN","RORHDT05",51,0)
 ; FILE          Output file name
"RTN","RORHDT05",52,0)
 ; [LASTREC]     IEN of the last processed record
"RTN","RORHDT05",53,0)
 ; [REGIEN]      Registry IEN
"RTN","RORHDT05",54,0)
 ; [TASKIEN]     Task IEN
"RTN","RORHDT05",55,0)
 ;
"RTN","RORHDT05",56,0)
 ; If the REGIEN or TASKIEN is omitted or not greater than 0, the
"RTN","RORHDT05",57,0)
 ; NEXT RECORD IEN field in the task record is not updated.
"RTN","RORHDT05",58,0)
 ;
"RTN","RORHDT05",59,0)
 ; Return Values:
"RTN","RORHDT05",60,0)
 ;       <0  Error code
"RTN","RORHDT05",61,0)
 ;        0  Ok
"RTN","RORHDT05",62,0)
 ;
"RTN","RORHDT05",63,0)
COMMIT(OUTDIR,FILE,LASTREC,REGIEN,TASKIEN) ;
"RTN","RORHDT05",64,0)
 N CR,I,J,BUF,POP,RC,RORFDA,RORMSG
"RTN","RORHDT05",65,0)
 ;--- Commit the data (if any)
"RTN","RORHDT05",66,0)
 I $D(^TMP("HLS",$J))>1  D  Q:$G(RC)<0 RC
"RTN","RORHDT05",67,0)
 . S CR=$C(13)
"RTN","RORHDT05",68,0)
 . ;--- Reopen the file
"RTN","RORHDT05",69,0)
 . D OPEN^%ZISH("HL7FILE",OUTDIR,FILE,"A")
"RTN","RORHDT05",70,0)
 . I $G(POP)  D  Q
"RTN","RORHDT05",71,0)
 . . S RC=$$ERROR^RORERR(-34,"COMMIT^RORHDT05",OUTDIR_FILE)
"RTN","RORHDT05",72,0)
 . U IO
"RTN","RORHDT05",73,0)
 . ;--- Write a BHS segment if necessary
"RTN","RORHDT05",74,0)
 . I $G(RORHDT("BHS"))  D  K RORHDT("BHS")
"RTN","RORHDT05",75,0)
 . . N MID,DATE
"RTN","RORHDT05",76,0)
 . . S MID=$G(ROREXT("HL7MID")),DATE=$G(ROREXT("HL7DT"))
"RTN","RORHDT05",77,0)
 . . W $$BHS^RORHL7(MID,DATE,"HISTORICAL DATA"),CR
"RTN","RORHDT05",78,0)
 . ;--- Write the segments
"RTN","RORHDT05",79,0)
 . S I=0
"RTN","RORHDT05",80,0)
 . F  S I=$O(^TMP("HLS",$J,I))  Q:I=""  D
"RTN","RORHDT05",81,0)
 . . S BUF=^TMP("HLS",$J,I),J=""
"RTN","RORHDT05",82,0)
 . . F  S J=$O(^TMP("HLS",$J,I,J))  Q:J=""  S BUF=BUF_^(J)
"RTN","RORHDT05",83,0)
 . . W BUF,CR
"RTN","RORHDT05",84,0)
 . ;--- Close the output file to commit the data
"RTN","RORHDT05",85,0)
 . D CLOSE^%ZISH("HL7FILE")
"RTN","RORHDT05",86,0)
 ;--- Update the NEXT RECORD IEN field in the task record
"RTN","RORHDT05",87,0)
 Q:($G(REGIEN)'>0)!($G(TASKIEN)'>0) 0
"RTN","RORHDT05",88,0)
 S RORFDA(798.5,TASKIEN_",",4)=$S($G(LASTREC):LASTREC+1,1:"")
"RTN","RORHDT05",89,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORHDT05",90,0)
 Q $$DBS^RORERR("RORMSG",-9,"COMMIT^RORHDT05",,798.5,TASKIEN)
"RTN","RORHDT05",91,0)
 ;
"RTN","RORHDT05",92,0)
 ;***** LOADS REGISTRY PARAMETERS
"RTN","RORHDT05",93,0)
 ;
"RTN","RORHDT05",94,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT05",95,0)
 ; [.BDT]        Start date of the data extract
"RTN","RORHDT05",96,0)
 ; [.EDT]        End date of the data extract
"RTN","RORHDT05",97,0)
 ; [.OUTDIR]     Output directory
"RTN","RORHDT05",98,0)
 ; [.DATE]       Date/time when first registry update finished
"RTN","RORHDT05",99,0)
 ;
"RTN","RORHDT05",100,0)
 ; Return Values:
"RTN","RORHDT05",101,0)
 ;       <0  Error code
"RTN","RORHDT05",102,0)
 ;        0  Ok
"RTN","RORHDT05",103,0)
 ;
"RTN","RORHDT05",104,0)
REGPARM(REGIEN,BDT,EDT,OUTDIR,DATE) ;
"RTN","RORHDT05",105,0)
 N IENS,RC,RORBUF,RORMSG,TMP
"RTN","RORHDT05",106,0)
 S IENS=REGIEN_","
"RTN","RORHDT05",107,0)
 ;--- Get data from the registry descriptor
"RTN","RORHDT05",108,0)
 D GETS^DIQ(798.1,IENS,"21.01;21.02;21.03;21.05","I","RORBUF","RORMSG")
"RTN","RORHDT05",109,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"REGPARM^RORHDT05",,798.1,IENS)
"RTN","RORHDT05",110,0)
 S BDT=$G(RORBUF(798.1,IENS,21.01,"I"))
"RTN","RORHDT05",111,0)
 S EDT=$G(RORBUF(798.1,IENS,21.02,"I"))
"RTN","RORHDT05",112,0)
 S OUTDIR=$G(RORBUF(798.1,IENS,21.03,"I"))
"RTN","RORHDT05",113,0)
 S DATE=$G(RORBUF(798.1,IENS,21.05,"I"))
"RTN","RORHDT05",114,0)
 I (BDT'>0)!(EDT'>0)!(BDT>EDT)  D  Q RC
"RTN","RORHDT05",115,0)
 . S RC=$$ERROR^RORERR(-32,"REGPARM^RORHDT05",,,BDT,EDT)
"RTN","RORHDT05",116,0)
 Q 0
"RTN","RORHDT05",117,0)
 ;
"RTN","RORHDT05",118,0)
 ;***** LOADS TASK PARAMETERS
"RTN","RORHDT05",119,0)
 ;
"RTN","RORHDT05",120,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT05",121,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT05",122,0)
 ; [.RBIEN]      Start record IEN
"RTN","RORHDT05",123,0)
 ; [.REIEN]      End record IEN
"RTN","RORHDT05",124,0)
 ; [.FILE]       File name
"RTN","RORHDT05",125,0)
 ;
"RTN","RORHDT05",126,0)
 ; Return Values:
"RTN","RORHDT05",127,0)
 ;       <0  Error code
"RTN","RORHDT05",128,0)
 ;        0  Ok
"RTN","RORHDT05",129,0)
 ;
"RTN","RORHDT05",130,0)
TASKPARM(REGIEN,TASKIEN,RBIEN,REIEN,FILE) ;
"RTN","RORHDT05",131,0)
 N IENS,RC,ROOT,RORBUF,RORMSG,TMP
"RTN","RORHDT05",132,0)
 ;--- Load data from the task record
"RTN","RORHDT05",133,0)
 S IENS=TASKIEN_","
"RTN","RORHDT05",134,0)
 D GETS^DIQ(798.5,IENS,".01;1.01;4","I","RORBUF","RORMSG")
"RTN","RORHDT05",135,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"TASKPARM^RORHDT05",,798.5,IENS)
"RTN","RORHDT05",136,0)
 S RBIEN=$G(RORBUF(798.5,IENS,.01,"I"))
"RTN","RORHDT05",137,0)
 S FILE=$G(RORBUF(798.5,IENS,1.01,"I"))
"RTN","RORHDT05",138,0)
 ;--- Get the end record IEN from the next task record
"RTN","RORHDT05",139,0)
 S ROOT=$$ROOT^DILFD(798.5,,1)
"RTN","RORHDT05",140,0)
 S REIEN=$O(@ROOT@("C",REGIEN,RBIEN))
"RTN","RORHDT05",141,0)
 ;--- If an IEN of the record is available from the previous run,
"RTN","RORHDT05",142,0)
 ;    use it as start record IEN
"RTN","RORHDT05",143,0)
 S TMP=$G(RORBUF(798.5,IENS,4,"I"))
"RTN","RORHDT05",144,0)
 S:TMP>0 RBIEN=TMP
"RTN","RORHDT05",145,0)
 Q 0
"RTN","RORHDTAC")
0^22^B12776687
"RTN","RORHDTAC",1,0)
RORHDTAC ;HCIOFO/SG - DATA EXTRACTION ACTION CONFIRMATIONS ; 12/14/01 10:01am
"RTN","RORHDTAC",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHDTAC",3,0)
 ;
"RTN","RORHDTAC",4,0)
 Q
"RTN","RORHDTAC",5,0)
 ;
"RTN","RORHDTAC",6,0)
 ;***** CONFIRMATION TO CREATE A NEW TASK TABLE
"RTN","RORHDTAC",7,0)
 ;
"RTN","RORHDTAC",8,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTAC",9,0)
 ;
"RTN","RORHDTAC",10,0)
 ; Return Values:
"RTN","RORHDTAC",11,0)
 ;       <0  Error code
"RTN","RORHDTAC",12,0)
 ;        0  Cancel
"RTN","RORHDTAC",13,0)
 ;        1  Create a table
"RTN","RORHDTAC",14,0)
 ;
"RTN","RORHDTAC",15,0)
CREATE(REGIEN) ;
"RTN","RORHDTAC",16,0)
 N IENS,RC,RORBUF,RORMSG
"RTN","RORHDTAC",17,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,X,Y
"RTN","RORHDTAC",18,0)
 ;--- Display status of the registry
"RTN","RORHDTAC",19,0)
 S RC=$$STATUS^RORHDT01(REGIEN)  Q:RC<0 RC
"RTN","RORHDTAC",20,0)
 ;--- Check if registry task table is not empty
"RTN","RORHDTAC",21,0)
 D FIND^DIC(798.5,,"@","QX",REGIEN,1,"AR",,,"RORBUF","RORMSG")
"RTN","RORHDTAC",22,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"CREATE^RORHDTAC",,798.5)
"RTN","RORHDTAC",23,0)
 ;--- Ask for a confirmation to overwrite
"RTN","RORHDTAC",24,0)
 I $G(RORBUF("DILIST",0))>0  D  Q:RC 0
"RTN","RORHDTAC",25,0)
 . K DIR  S DIR(0)="Y"
"RTN","RORHDTAC",26,0)
 . S DIR("A")="Overwrite the existing task table"
"RTN","RORHDTAC",27,0)
 . S DIR("B")="NO"
"RTN","RORHDTAC",28,0)
 . D ^DIR  W !  S RC=$D(DIRUT)!'$G(Y)
"RTN","RORHDTAC",29,0)
 Q 1
"RTN","RORHDTAC",30,0)
 ;
"RTN","RORHDTAC",31,0)
 ;***** CONFIRMATIONS TO START THE TASK
"RTN","RORHDTAC",32,0)
 ;
"RTN","RORHDTAC",33,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTAC",34,0)
 ; TASKIEN       Task IEN
"RTN","RORHDTAC",35,0)
 ; .FAM          File Access Mode is returned via this parameter
"RTN","RORHDTAC",36,0)
 ;
"RTN","RORHDTAC",37,0)
 ; Return Values:
"RTN","RORHDTAC",38,0)
 ;       <0  Error code
"RTN","RORHDTAC",39,0)
 ;        0  Cancel
"RTN","RORHDTAC",40,0)
 ;        1  Start the task
"RTN","RORHDTAC",41,0)
 ;
"RTN","RORHDTAC",42,0)
START(REGIEN,TASKIEN,FAM) ;
"RTN","RORHDTAC",43,0)
 N FILE,OUTDIR,RC,RORDST,RORSRC,STATUS
"RTN","RORHDTAC",44,0)
 N DA,DIDEL,DIE,DIR,DIROUT,DIRUT,DR,DTOUT,DUOUT,X,Y
"RTN","RORHDTAC",45,0)
 S FAM=""
"RTN","RORHDTAC",46,0)
 ;--- Check status of the task
"RTN","RORHDTAC",47,0)
 S STATUS=+$$STATUS^RORHDTUT(REGIEN,TASKIEN)
"RTN","RORHDTAC",48,0)
 I STATUS=1  D  Q:RC $S(RC<0:RC,1:0)
"RTN","RORHDTAC",49,0)
 . K DIR  S DIR(0)="Y"
"RTN","RORHDTAC",50,0)
 . S DIR("A")="The task is pending. Do you want to rescheduled it"
"RTN","RORHDTAC",51,0)
 . S DIR("B")="NO"
"RTN","RORHDTAC",52,0)
 . D ^DIR  W !  S RC=$D(DIRUT)!'$G(Y)
"RTN","RORHDTAC",53,0)
 . S:'RC RC=$$STOP^RORHDT03(REGIEN,TASKIEN)
"RTN","RORHDTAC",54,0)
 I STATUS=2  D  Q 0
"RTN","RORHDTAC",55,0)
 . W !,"The task is running already",!
"RTN","RORHDTAC",56,0)
 I STATUS=100  D  Q:RC 0
"RTN","RORHDTAC",57,0)
 . K DIR  S DIR(0)="Y"
"RTN","RORHDTAC",58,0)
 . S DIR("A")="The task is completed. Do you want to rerun it"
"RTN","RORHDTAC",59,0)
 . S DIR("B")="NO"
"RTN","RORHDTAC",60,0)
 . D ^DIR  W !  S RC=$D(DIRUT)!'$G(Y)
"RTN","RORHDTAC",61,0)
 ;--- Check if the output file exists already
"RTN","RORHDTAC",62,0)
 S RC=$$TASKFILE^RORHDTUT(REGIEN,TASKIEN,.OUTDIR,.FILE)  Q:RC<0 RC
"RTN","RORHDTAC",63,0)
 S RORSRC(FILE)=""
"RTN","RORHDTAC",64,0)
 S RC=$$LIST^%ZISH(OUTDIR,"RORSRC","RORDST")
"RTN","RORHDTAC",65,0)
 I RC,$D(RORDST)>1  D  Q:RC 0
"RTN","RORHDTAC",66,0)
 . K DIR  S DIR(0)="SAB^A:Append;N:New file;O:Overwrite"
"RTN","RORHDTAC",67,0)
 . S DIR("A",1)="Output file "_FILE_" exists already."
"RTN","RORHDTAC",68,0)
 . S DIR("A")="Overwrite or create a New file? "
"RTN","RORHDTAC",69,0)
 . S DIR("B")=$S(STATUS=101:"Overwrite",1:"New file")
"RTN","RORHDTAC",70,0)
 . D ^DIR  W !  S RC=$D(DIRUT)
"RTN","RORHDTAC",71,0)
 . S:'RC FAM=Y
"RTN","RORHDTAC",72,0)
 ;--- Confirm/modify the new file name
"RTN","RORHDTAC",73,0)
 I FAM["N"  D  Q:RC $S(RC<0:RC,1:0)
"RTN","RORHDTAC",74,0)
 . N RORFDA,RORMSG
"RTN","RORHDTAC",75,0)
 . S RC=$$NEWFILE^RORHDTUT(REGIEN,TASKIEN,.FILE,1)  Q:RC<0
"RTN","RORHDTAC",76,0)
 . K DIR  S DIR(0)="798.5,1.01"
"RTN","RORHDTAC",77,0)
 . S DIR("A")="File Name"
"RTN","RORHDTAC",78,0)
 . S DIR("B")=FILE
"RTN","RORHDTAC",79,0)
 . D ^DIR  W !  I $D(DIRUT)  S RC=1  Q
"RTN","RORHDTAC",80,0)
 . ;--- Store the new file name
"RTN","RORHDTAC",81,0)
 . S RORFDA(798.5,TASKIEN_",",1.01)=Y
"RTN","RORHDTAC",82,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORHDTAC",83,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"START^RORHDTAC")
"RTN","RORHDTAC",84,0)
 Q 1
"RTN","RORHDTAC",85,0)
 ;
"RTN","RORHDTAC",86,0)
 ;***** CONFIRMATION TO STOP THE TASK
"RTN","RORHDTAC",87,0)
 ;
"RTN","RORHDTAC",88,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTAC",89,0)
 ; TASKIEN       Task IEN
"RTN","RORHDTAC",90,0)
 ;
"RTN","RORHDTAC",91,0)
 ; Return Values:
"RTN","RORHDTAC",92,0)
 ;       <0  Error code
"RTN","RORHDTAC",93,0)
 ;        0  Cancel
"RTN","RORHDTAC",94,0)
 ;        1  Stop the task
"RTN","RORHDTAC",95,0)
 ;
"RTN","RORHDTAC",96,0)
STOP(REGIEN,TASKIEN) ;
"RTN","RORHDTAC",97,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,STATUS,X,Y,ZTSK
"RTN","RORHDTAC",98,0)
 ;--- Check status of the task
"RTN","RORHDTAC",99,0)
 S STATUS=+$$STATUS^RORHDTUT(REGIEN,TASKIEN)
"RTN","RORHDTAC",100,0)
 Q:(STATUS'=1)&(STATUS'=2) 0 ; Neither running nor pending
"RTN","RORHDTAC",101,0)
 ;--- Get the task number
"RTN","RORHDTAC",102,0)
 S ZTSK=$$GET1^DIQ(798.5,TASKIEN_",",2.01,,,"RORMSG")
"RTN","RORHDTAC",103,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"STOP^RORHDTAC",,798.5,TASKIEN)
"RTN","RORHDTAC",104,0)
 ;--- Ask for the final confirmation
"RTN","RORHDTAC",105,0)
 K DIR  S DIR(0)="Y"
"RTN","RORHDTAC",106,0)
 S DIR("A")=$S(STATUS=2:"Stop",1:"Dequeue")_" the task #"_ZTSK
"RTN","RORHDTAC",107,0)
 S DIR("B")="NO"
"RTN","RORHDTAC",108,0)
 D ^DIR  W !
"RTN","RORHDTAC",109,0)
 Q '$D(DIRUT)&$G(Y)
"RTN","RORHDTUT")
0^23^B28999251
"RTN","RORHDTUT",1,0)
RORHDTUT ;HCIOFO/SG - HISTORICAL DATA EXTRACTION UTILITIES ; 3/29/02 10:40am
"RTN","RORHDTUT",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHDTUT",3,0)
 ;
"RTN","RORHDTUT",4,0)
 Q
"RTN","RORHDTUT",5,0)
 ;
"RTN","RORHDTUT",6,0)
 ;***** DELETES THE REGISTRY TASK RECORDS
"RTN","RORHDTUT",7,0)
 ;
"RTN","RORHDTUT",8,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTUT",9,0)
 ;
"RTN","RORHDTUT",10,0)
 ; Return Values:
"RTN","RORHDTUT",11,0)
 ;       <0  Error code
"RTN","RORHDTUT",12,0)
 ;        0  Ok
"RTN","RORHDTUT",13,0)
 ;
"RTN","RORHDTUT",14,0)
CLRTTBL(REGIEN) ;
"RTN","RORHDTUT",15,0)
 N IENS,IR,RC,RORBUF,RORFDA,RORMSG
"RTN","RORHDTUT",16,0)
 ;--- Load a list of task records
"RTN","RORHDTUT",17,0)
 D FIND^DIC(798.5,,"@","QX",REGIEN,,"AR",,,"RORBUF","RORMSG")
"RTN","RORHDTUT",18,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"CLRTTBL^RORHDTUT",,798.5)
"RTN","RORHDTUT",19,0)
 Q:$G(RORBUF("DILIST",0))<1 0
"RTN","RORHDTUT",20,0)
 ;--- Prepare the FDA
"RTN","RORHDTUT",21,0)
 S IR=""
"RTN","RORHDTUT",22,0)
 F  S IR=$O(RORBUF("DILIST",2,IR))  Q:IR=""  D
"RTN","RORHDTUT",23,0)
 . S RORFDA(798.5,RORBUF("DILIST",2,IR)_",",.01)="@"
"RTN","RORHDTUT",24,0)
 ;--- Delete the registry tasks
"RTN","RORHDTUT",25,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORHDTUT",26,0)
 Q $$DBS^RORERR("RORMSG",-9,"CLRTTBL^RORHDTUT",,798.5)
"RTN","RORHDTUT",27,0)
 ;
"RTN","RORHDTUT",28,0)
 ;***** GENERATES A NEW UNUSED FILE NAME FOR THE TASK
"RTN","RORHDTUT",29,0)
 ;
"RTN","RORHDTUT",30,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTUT",31,0)
 ; TASKIEN       Task IEN
"RTN","RORHDTUT",32,0)
 ; [.FILE]       New name is returned via this parameter
"RTN","RORHDTUT",33,0)
 ; [GNONLY]      Only generate a new name but do not store it into
"RTN","RORHDTUT",34,0)
 ;               task record
"RTN","RORHDTUT",35,0)
 ;
"RTN","RORHDTUT",36,0)
 ; Return Values:
"RTN","RORHDTUT",37,0)
 ;       <0  Error code
"RTN","RORHDTUT",38,0)
 ;        0  Ok
"RTN","RORHDTUT",39,0)
 ;
"RTN","RORHDTUT",40,0)
NEWFILE(REGIEN,TASKIEN,FILE,GNONLY) ;
"RTN","RORHDTUT",41,0)
 N BASE,EXT,FN,NAME,OUTDIR,RC,RORBUF,RORLST,RORMSG,TMP
"RTN","RORHDTUT",42,0)
 S RC=$$TASKFILE(REGIEN,TASKIEN,.OUTDIR,.FILE)  Q:RC<0 RC
"RTN","RORHDTUT",43,0)
 S BASE=$P($P(FILE,"."),"-"),EXT=$P($P(FILE,".",2),";")
"RTN","RORHDTUT",44,0)
 ;--- Get a list of files in the output directory
"RTN","RORHDTUT",45,0)
 S RORBUF(BASE_"*."_EXT)=""
"RTN","RORHDTUT",46,0)
 Q:'$$LIST^%ZISH(OUTDIR,"RORBUF","RORLST") 0
"RTN","RORHDTUT",47,0)
 Q:$D(RORLST)<10 0
"RTN","RORHDTUT",48,0)
 K RORBUF
"RTN","RORHDTUT",49,0)
 ;--- Generate a new name
"RTN","RORHDTUT",50,0)
 S NAME="",FN=0
"RTN","RORHDTUT",51,0)
 F  S NAME=$O(RORLST(NAME))  Q:NAME=""  D
"RTN","RORHDTUT",52,0)
 . S TMP=+$P(NAME,"-",2)  S:TMP>FN FN=TMP
"RTN","RORHDTUT",53,0)
 S FILE=BASE_"-"_$TR($J(FN+1,2)," ","0")_"."_EXT
"RTN","RORHDTUT",54,0)
 Q:$G(GNONLY) 0
"RTN","RORHDTUT",55,0)
 K RORLST
"RTN","RORHDTUT",56,0)
 ;--- Store it to the task record
"RTN","RORHDTUT",57,0)
 S RORBUF(798.5,TASKIEN_",",1.01)=FILE
"RTN","RORHDTUT",58,0)
 D FILE^DIE(,"RORBUF","RORMSG")
"RTN","RORHDTUT",59,0)
 Q $$DBS^RORERR("RORMSG",-9,"NEWFILE^RORHDTUT",,798.5,TASKIEN)
"RTN","RORHDTUT",60,0)
 ;
"RTN","RORHDTUT",61,0)
 ;***** WAITS FOR [ENTER] FROM THE KEYBOARD
"RTN","RORHDTUT",62,0)
PAUSE ;
"RTN","RORHDTUT",63,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,X,Y
"RTN","RORHDTUT",64,0)
 I IO=IO(0)  D  D ^DIR
"RTN","RORHDTUT",65,0)
 . S DIR(0)="FAO",DIR("A")="Press Enter to continue ..."
"RTN","RORHDTUT",66,0)
 Q
"RTN","RORHDTUT",67,0)
 ;
"RTN","RORHDTUT",68,0)
 ;***** SELECTS A REGISTRY DESCRIPTOR IN THE FILE #798.1
"RTN","RORHDTUT",69,0)
 ;
"RTN","RORHDTUT",70,0)
 ; [.REGNAME]    Registry name is returned via this parameter
"RTN","RORHDTUT",71,0)
 ;
"RTN","RORHDTUT",72,0)
 ; Return Values:
"RTN","RORHDTUT",73,0)
 ;       <0  Error code
"RTN","RORHDTUT",74,0)
 ;       ""  Timeout, "^" entered, or an error in ^DIC
"RTN","RORHDTUT",75,0)
 ;        0  There are no records in the file #798.1
"RTN","RORHDTUT",76,0)
 ;       >0  IEN of the selected registry
"RTN","RORHDTUT",77,0)
 ;
"RTN","RORHDTUT",78,0)
SELREG(REGNAME) ;
"RTN","RORHDTUT",79,0)
 N DA,DIC,DLAYGO,DTOUT,DUOUT,RC,RORBUF,RORMSG,X,Y
"RTN","RORHDTUT",80,0)
 S REGNAME=""
"RTN","RORHDTUT",81,0)
 ;--- If there are less than two records, do not ask a user
"RTN","RORHDTUT",82,0)
 D LIST^DIC(798.1,,"@;.01E",,2,,,"B",,,"RORBUF","RORMSG")
"RTN","RORHDTUT",83,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"SELREG^RORHDTUT",,798.1)
"RTN","RORHDTUT",84,0)
 I $G(RORBUF("DILIST",0))<2  D  Q +$G(RORBUF("DILIST",2,1))
"RTN","RORHDTUT",85,0)
 . S REGNAME=$G(RORBUF("DILIST","ID",1,.01))
"RTN","RORHDTUT",86,0)
 ;--- Select a registry
"RTN","RORHDTUT",87,0)
 S DIC=798.1,DIC(0)="AENQZ"
"RTN","RORHDTUT",88,0)
 S DIC("A")="Select a Registry: "
"RTN","RORHDTUT",89,0)
 S DIC("B")=$G(RORHDT("DFLT","REG"))
"RTN","RORHDTUT",90,0)
 D ^DIC  W !
"RTN","RORHDTUT",91,0)
 S:Y>0 (RORHDT("DFLT","REG"),REGNAME)=Y(0,0)
"RTN","RORHDTUT",92,0)
 Q $S($D(DTOUT)!$D(DUOUT):"",Y<0:"",1:+Y)
"RTN","RORHDTUT",93,0)
 ;
"RTN","RORHDTUT",94,0)
 ;***** SELECTS A DATA EXTRACTION TASK
"RTN","RORHDTUT",95,0)
 ;
"RTN","RORHDTUT",96,0)
 ; RORREG        Registry IEN
"RTN","RORHDTUT",97,0)
 ;
"RTN","RORHDTUT",98,0)
 ; Return Values:
"RTN","RORHDTUT",99,0)
 ;       <0  Error code
"RTN","RORHDTUT",100,0)
 ;       ""  Timeout, "^" entered, or an error in the ^DIC
"RTN","RORHDTUT",101,0)
 ;        0  There are no tasks defined in the file #798.5
"RTN","RORHDTUT",102,0)
 ;       >0  IEN of the selected task
"RTN","RORHDTUT",103,0)
 ;
"RTN","RORHDTUT",104,0)
SELTASK(RORREG) ;
"RTN","RORHDTUT",105,0)
 N DA,DIC,DLAYGO,DTOUT,DUOUT,RC,RORBUF,RORMSG,X,Y
"RTN","RORHDTUT",106,0)
 ;--- If there are less than two records, do not ask a user
"RTN","RORHDTUT",107,0)
 D FIND^DIC(798.5,,"@","QX",RORREG,2,"AR",,,"RORBUF","RORMSG")
"RTN","RORHDTUT",108,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"SELTASK^RORHDTUT",,798.5)
"RTN","RORHDTUT",109,0)
 Q:$G(RORBUF("DILIST",0))<2 +$G(RORBUF("DILIST",2,1))
"RTN","RORHDTUT",110,0)
 ;--- Display status of the tasks
"RTN","RORHDTUT",111,0)
 S RC=$$STATUS^RORHDT01(RORREG)  Q:RC<0 RC
"RTN","RORHDTUT",112,0)
 ;--- Select a task
"RTN","RORHDTUT",113,0)
 S DIC=798.5,DIC(0)="AEQS"
"RTN","RORHDTUT",114,0)
 S DIC("A")="Select a Task: "
"RTN","RORHDTUT",115,0)
 S DIC("B")=$G(RORHDT("DFLT","TSK"))
"RTN","RORHDTUT",116,0)
 S DIC("S")="I $P(^(0),U,2)=RORREG"
"RTN","RORHDTUT",117,0)
 D ^DIC  W !
"RTN","RORHDTUT",118,0)
 S:Y>0 RORHDT("DFLT","TSK")=+Y
"RTN","RORHDTUT",119,0)
 Q $S($D(DTOUT)!$D(DUOUT):"",Y<0:"",1:+Y)
"RTN","RORHDTUT",120,0)
 ;
"RTN","RORHDTUT",121,0)
 ;***** RETURNS STATUS OF THE TASK
"RTN","RORHDTUT",122,0)
 ;
"RTN","RORHDTUT",123,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTUT",124,0)
 ; TASKIEN       Task IEN
"RTN","RORHDTUT",125,0)
 ; [LTO]         LOCK timeout
"RTN","RORHDTUT",126,0)
 ;
"RTN","RORHDTUT",127,0)
 ; Return Values:
"RTN","RORHDTUT",128,0)
 ;       <0  Error code
"RTN","RORHDTUT",129,0)
 ;        0  Unknown Status
"RTN","RORHDTUT",130,0)
 ;       >0  Status (Code^Description)
"RTN","RORHDTUT",131,0)
 ;
"RTN","RORHDTUT",132,0)
 ;               1  Active: Pending
"RTN","RORHDTUT",133,0)
 ;               2  Active: Running
"RTN","RORHDTUT",134,0)
 ;               3  Inactive: Finished
"RTN","RORHDTUT",135,0)
 ;               4  Inactive: Available
"RTN","RORHDTUT",136,0)
 ;               5  Inactive: Interrupted
"RTN","RORHDTUT",137,0)
 ;
"RTN","RORHDTUT",138,0)
 ;             100  Completed
"RTN","RORHDTUT",139,0)
 ;             101  Inactive: Crashed
"RTN","RORHDTUT",140,0)
 ;             102  Completed with Errors
"RTN","RORHDTUT",141,0)
 ;
"RTN","RORHDTUT",142,0)
STATUS(REGIEN,TASKIEN,LTO) ;
"RTN","RORHDTUT",143,0)
 N HDTNODE,IENS,RC,RORBUF,RORMSG,STATUS,ZTSK
"RTN","RORHDTUT",144,0)
 S HDTNODE=$NA(^XTMP("RORHDT"_REGIEN))
"RTN","RORHDTUT",145,0)
 ;---Check if the task is running
"RTN","RORHDTUT",146,0)
 L +@HDTNODE@("T",TASKIEN):$G(LTO)
"RTN","RORHDTUT",147,0)
 E  Q "2^Active: Running"
"RTN","RORHDTUT",148,0)
 L -@HDTNODE@("T",TASKIEN)
"RTN","RORHDTUT",149,0)
 ;--- Load some data from the task record
"RTN","RORHDTUT",150,0)
 S IENS=TASKIEN_","
"RTN","RORHDTUT",151,0)
 D GETS^DIQ(798.5,IENS,"2.01;2.02;2.03","EI","RORBUF","RORMSG")
"RTN","RORHDTUT",152,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"STATUS^RORHDTUT",,798.5,IENS)
"RTN","RORHDTUT",153,0)
 ;--- Check the JOB NUMBER and COMPLETED fields
"RTN","RORHDTUT",154,0)
 Q:$G(RORBUF(798.5,IENS,2.03,"I")) "100^Completed"
"RTN","RORHDTUT",155,0)
 Q:$G(RORBUF(798.5,IENS,2.02,"I")) "101^Inactive: Crashed"
"RTN","RORHDTUT",156,0)
 S STATUS=0
"RTN","RORHDTUT",157,0)
 ;--- Try to get status from the Taskman
"RTN","RORHDTUT",158,0)
 S ZTSK=$G(RORBUF(798.5,IENS,2.01,"I"))
"RTN","RORHDTUT",159,0)
 I ZTSK  D  Q:STATUS STATUS
"RTN","RORHDTUT",160,0)
 . D STAT^%ZTLOAD  Q:'$G(ZTSK(0))!'$G(ZTSK(1))
"RTN","RORHDTUT",161,0)
 . S:ZTSK(1)'=2 STATUS=ZTSK(1)_U_ZTSK(2) ; Ignore 'Active:Running'
"RTN","RORHDTUT",162,0)
 ;--- Check the ERROR multiple
"RTN","RORHDTUT",163,0)
 D LIST^DIC(798.53,","_IENS,"@",,1,,,"B",,,"RORBUF","RORMSG")
"RTN","RORHDTUT",164,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"STATUS^RORHDTUT",,798.53)
"RTN","RORHDTUT",165,0)
 Q $S($G(RORBUF("DILIST",0))>0:"102^Completed with Errors",1:0)
"RTN","RORHDTUT",166,0)
 ;
"RTN","RORHDTUT",167,0)
 ;***** GETS A NAME OF THE TASK OUTPUT FILE
"RTN","RORHDTUT",168,0)
 ;
"RTN","RORHDTUT",169,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTUT",170,0)
 ; TASKIEN       Task IEN
"RTN","RORHDTUT",171,0)
 ; .OUTDIR       Output directory is returned via this parameter
"RTN","RORHDTUT",172,0)
 ; .FILE         File name is returned via the parameter
"RTN","RORHDTUT",173,0)
 ;
"RTN","RORHDTUT",174,0)
 ; Return Values:
"RTN","RORHDTUT",175,0)
 ;       <0  Error code
"RTN","RORHDTUT",176,0)
 ;        0  Ok
"RTN","RORHDTUT",177,0)
 ;
"RTN","RORHDTUT",178,0)
TASKFILE(REGIEN,TASKIEN,OUTDIR,FILE) ;
"RTN","RORHDTUT",179,0)
 N IENS,RC,RORMSG
"RTN","RORHDTUT",180,0)
 S (OUTDIR,FILE)=""
"RTN","RORHDTUT",181,0)
 ;--- Get the output directory
"RTN","RORHDTUT",182,0)
 S IENS=REGIEN_","
"RTN","RORHDTUT",183,0)
 S OUTDIR=$$GET1^DIQ(798.1,IENS,21.03,,,"RORMSG")
"RTN","RORHDTUT",184,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"TASKFILE^RORHDTUT",,798.1,IENS)
"RTN","RORHDTUT",185,0)
 ;--- Get the file name
"RTN","RORHDTUT",186,0)
 S IENS=TASKIEN_","
"RTN","RORHDTUT",187,0)
 S FILE=$$GET1^DIQ(798.5,IENS,1.01,,,"RORMSG")
"RTN","RORHDTUT",188,0)
 Q $$DBS^RORERR("RORMSG",-9,"TASKFILE^RORHDTUT",,798.5,IENS)
"RTN","RORHDTUT",189,0)
 ;
"RTN","RORHDTUT",190,0)
 ;***** RETURNS TASK JOB NUMBER
"RTN","RORHDTUT",191,0)
 ;
"RTN","RORHDTUT",192,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTUT",193,0)
 ; TASKIEN       Task IEN
"RTN","RORHDTUT",194,0)
 ;
"RTN","RORHDTUT",195,0)
 ; Return Values:
"RTN","RORHDTUT",196,0)
 ;       <0  Error code
"RTN","RORHDTUT",197,0)
 ;        0  Task is not active
"RTN","RORHDTUT",198,0)
 ;       >0  Job number
"RTN","RORHDTUT",199,0)
 ;
"RTN","RORHDTUT",200,0)
TASKJOB(REGIEN,TASKIEN) ;
"RTN","RORHDTUT",201,0)
 N IENS,JOBNUM,RC,RORMSG
"RTN","RORHDTUT",202,0)
 S IENS=TASKIEN_","
"RTN","RORHDTUT",203,0)
 S JOBNUM=+$$GET1^DIQ(798.5,IENS,2.02,"I",,"RORMSG")
"RTN","RORHDTUT",204,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"TASKJOB^RORHDTUT",,798.5,IENS)
"RTN","RORHDTUT",205,0)
 Q JOBNUM
"RTN","RORHL01")
0^24^B11470148
"RTN","RORHL01",1,0)
RORHL01 ;HOIFO/CRT - Clinical Registries Segment APIs ; 5/6/02 1:17pm
"RTN","RORHL01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHL01",3,0)
 ;
"RTN","RORHL01",4,0)
 Q
"RTN","RORHL01",5,0)
 ;
"RTN","RORHL01",6,0)
PID(RORDFN,RORPTR,HLFS,HLECH) ; PID SEGMENT
"RTN","RORHL01",7,0)
 ;
"RTN","RORHL01",8,0)
 ; INPUT:  RORDFN - DFN of Patient Record in File #2          (Req'd)
"RTN","RORHL01",9,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                  (Opt'l)
"RTN","RORHL01",10,0)
 ;         HLFS   - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL01",11,0)
 ;         HLECH  - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL01",12,0)
 ;
"RTN","RORHL01",13,0)
 N CS,I,RORFLDS,RORMSG,RORRES,RORSEG,RORSITE,SCS,TMP,VAFPID
"RTN","RORHL01",14,0)
 ;
"RTN","RORHL01",15,0)
 S RORRES=0
"RTN","RORHL01",16,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL01",17,0)
 ;
"RTN","RORHL01",18,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL01",19,0)
 S CS=$E(HLECH,1),SCS=$E(HLECH,4)
"RTN","RORHL01",20,0)
 ;
"RTN","RORHL01",21,0)
 S RORDFN=+$G(RORDFN)  I '$D(^DPT(RORDFN))  D  Q RORRES
"RTN","RORHL01",22,0)
 . S RORRES=$$ERROR^RORERR(-36,"PID^RORHL01",,,RORDFN,2)
"RTN","RORHL01",23,0)
 ;
"RTN","RORHL01",24,0)
 S RORFLDS="2,3,5,7,8,10,11,19,29" ; Default HL7 fields
"RTN","RORHL01",25,0)
 ;
"RTN","RORHL01",26,0)
 ; Call Standard PID Segment builder
"RTN","RORHL01",27,0)
 S RORSEG=$$EN^VAFHLPID(RORDFN,RORFLDS)
"RTN","RORHL01",28,0)
 I $D(VAFPID(1)) S RORSEG(1)=VAFPID(1)
"RTN","RORHL01",29,0)
 ;
"RTN","RORHL01",30,0)
 ; PID-2 ICN
"RTN","RORHL01",31,0)
 S TMP=$$ICN^RORUTL02(RORDFN)
"RTN","RORHL01",32,0)
 I TMP>0  S $P(RORSEG,HLFS,3)=$TR(TMP,"V",CS)_CS_"ISO"_CS_"VAMPI"
"RTN","RORHL01",33,0)
 E  S $P(RORSEG,HLFS,3)=""
"RTN","RORHL01",34,0)
 ;
"RTN","RORHL01",35,0)
 ; PID-3 DFN + Old-ICN and Old-SSN if applicable
"RTN","RORHL01",36,0)
 S TMP=""
"RTN","RORHL01",37,0)
 S $P(TMP,CS,1,3)=$$M10^HLFNC(RORDFN,CS)
"RTN","RORHL01",38,0)
 S $P(TMP,CS,5)="PI"
"RTN","RORHL01",39,0)
 S $P(TMP,CS,6)=$$SITE^RORUTL03(SCS)
"RTN","RORHL01",40,0)
 S $P(RORSEG,HLFS,4)=TMP
"RTN","RORHL01",41,0)
 ;
"RTN","RORHL01",42,0)
 ; PID-5 Encrypt Patient Name
"RTN","RORHL01",43,0)
 S $P(RORSEG,HLFS,6)=$$ENCRYPT^RORUTL03($P(RORSEG,HLFS,6))
"RTN","RORHL01",44,0)
 ;
"RTN","RORHL01",45,0)
 ; PID-11 Remove Address (leave ZIP only)
"RTN","RORHL01",46,0)
 S $P(RORSEG,HLFS,12)=CS_CS_CS_CS_$P($P(RORSEG,HLFS,12),CS,5)
"RTN","RORHL01",47,0)
 ;
"RTN","RORHL01",48,0)
 ; PID-19 Encrypt SSN
"RTN","RORHL01",49,0)
 S $P(RORSEG,HLFS,20)=$$ENCRYPT^RORUTL03($P(RORSEG,HLFS,20))
"RTN","RORHL01",50,0)
 ;
"RTN","RORHL01",51,0)
 ; PID-29 Date of Death (not supported by EN^VAFHLPID)
"RTN","RORHL01",52,0)
 S TMP=$$GET1^DIQ(2,RORDFN,.351,"I",,"RORMSG")
"RTN","RORHL01",53,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"PID^RORHL01",,2,RORDFN)
"RTN","RORHL01",54,0)
 S:TMP $P(RORSEG,HLFS,30)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL01",55,0)
 ;
"RTN","RORHL01",56,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL01",57,0)
 S RORPTR=RORPTR+1  M ^TMP("HLS",$J,RORPTR)=RORSEG
"RTN","RORHL01",58,0)
 ;
"RTN","RORHL01",59,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL01",60,0)
 ;
"RTN","RORHL01",61,0)
ZSP(RORDFN,RORPTR,HLFS,HLECH) ; ZSP SEGMENT
"RTN","RORHL01",62,0)
 ;
"RTN","RORHL01",63,0)
 ; INPUT:  RORDFN - DFN of Patient Record in File #2          (Req'd)
"RTN","RORHL01",64,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                  (Opt'l)
"RTN","RORHL01",65,0)
 ;         HLFS   - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL01",66,0)
 ;         HLECH  - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL01",67,0)
 ;
"RTN","RORHL01",68,0)
 N I,RORFLDS,RORRES,RORSEG
"RTN","RORHL01",69,0)
 ;
"RTN","RORHL01",70,0)
 S RORRES=0
"RTN","RORHL01",71,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL01",72,0)
 ;
"RTN","RORHL01",73,0)
 S RORDFN=+$G(RORDFN)  I '$D(^DPT(RORDFN))  D  Q RORRES
"RTN","RORHL01",74,0)
 . S RORRES=$$ERROR^RORERR(-36,"ZSP^RORHL01",,,RORDFN,2)
"RTN","RORHL01",75,0)
 ;
"RTN","RORHL01",76,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL01",77,0)
 ;
"RTN","RORHL01",78,0)
 S RORFLDS="1,2,3,4" ; Default HL7 fields
"RTN","RORHL01",79,0)
 ;
"RTN","RORHL01",80,0)
 ; Call Standard ZSP Segment Builder
"RTN","RORHL01",81,0)
 S RORSEG=$$EN^VAFHLZSP(RORDFN)
"RTN","RORHL01",82,0)
 ;
"RTN","RORHL01",83,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL01",84,0)
 S RORPTR=RORPTR+1,^TMP("HLS",$J,RORPTR)=$TR(RORSEG,$C(9,10,13),"   ")
"RTN","RORHL01",85,0)
 ;
"RTN","RORHL01",86,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL01",87,0)
 ;
"RTN","RORHL01",88,0)
ZRD(RORDFN,RORPTR,HLFS,HLECH) ; ZRD SEGMENT(S)
"RTN","RORHL01",89,0)
 ;
"RTN","RORHL01",90,0)
 ; INPUT:  RORDFN - DFN of Patient Record in File #2          (Req'd)
"RTN","RORHL01",91,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                  (Opt'l)
"RTN","RORHL01",92,0)
 ;         HLFS   - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL01",93,0)
 ;         HLECH  - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL01",94,0)
 ;
"RTN","RORHL01",95,0)
 N I,RORFLDS,RORRES,RORSEG
"RTN","RORHL01",96,0)
 ;
"RTN","RORHL01",97,0)
 S RORRES=0
"RTN","RORHL01",98,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL01",99,0)
 ;
"RTN","RORHL01",100,0)
 S RORDFN=+$G(RORDFN) I '$D(^DPT(RORDFN))  D  Q RORRES
"RTN","RORHL01",101,0)
 . S RORRES=$$ERROR^RORERR(-36,"ZRD^RORHL01",,,RORDFN,2)
"RTN","RORHL01",102,0)
 ;
"RTN","RORHL01",103,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL01",104,0)
 ;
"RTN","RORHL01",105,0)
 S RORFLDS="1,2,3,4" ; Default HL7 fields
"RTN","RORHL01",106,0)
 ;
"RTN","RORHL01",107,0)
 ; Call Standard ZRD Segment Builder
"RTN","RORHL01",108,0)
 D EN^VAFHLZRD(RORDFN,RORFLDS,,HLFS,"RORSEG")
"RTN","RORHL01",109,0)
 ;
"RTN","RORHL01",110,0)
 ;--- Store the segment(s) in ^TMP("HLS",$J)
"RTN","RORHL01",111,0)
 S I=""
"RTN","RORHL01",112,0)
 F  S I=$O(RORSEG(I))  Q:I=""  Q:$P($G(RORSEG(I,0)),HLFS,3)=""  D
"RTN","RORHL01",113,0)
 . S RORPTR=RORPTR+1
"RTN","RORHL01",114,0)
 . S ^TMP("HLS",$J,RORPTR)=$TR(RORSEG(I,0),$C(9,10,13),"   ")
"RTN","RORHL01",115,0)
 ;
"RTN","RORHL01",116,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL01",117,0)
 ;
"RTN","RORHL02")
0^25^B44292323
"RTN","RORHL02",1,0)
RORHL02 ;HOIFO/CRT - Clinical Registries Segment APIs - REGISTRY DATA ; 5/6/02 1:20pm
"RTN","RORHL02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHL02",3,0)
 ;
"RTN","RORHL02",4,0)
 Q
"RTN","RORHL02",5,0)
 ;
"RTN","RORHL02",6,0)
CSR(RORIEN,RORFLDS,RORPTR,HLFS,HLECH) ; CSR SEGMENT
"RTN","RORHL02",7,0)
 ;
"RTN","RORHL02",8,0)
 ; INPUT:  RORIEN - IEN of Patient Record in Registry File 798 (Req'd)
"RTN","RORHL02",9,0)
 ;         RORFLDS - Segment Fields to populate                (Opt'l)
"RTN","RORHL02",10,0)
 ;                   (1,3,4,6,10,14,15,16 available)
"RTN","RORHL02",11,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                   (Opt'l)
"RTN","RORHL02",12,0)
 ;         HLFS   - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL02",13,0)
 ;         HLECH  - Encoding Characters. Deafults to ^~\&      (Opt'l)
"RTN","RORHL02",14,0)
 ;
"RTN","RORHL02",15,0)
 N CS,FLDS,RORMSG,ROROUT,RORRES,RORSEG,RORTXT,SCS,TMP
"RTN","RORHL02",16,0)
 ;
"RTN","RORHL02",17,0)
 S RORRES=0
"RTN","RORHL02",18,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL02",19,0)
 ;
"RTN","RORHL02",20,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORHL02",21,0)
 ;
"RTN","RORHL02",22,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL02",23,0)
 S CS=$E(HLECH,1),SCS=$E(HLECH,4)
"RTN","RORHL02",24,0)
 ;
"RTN","RORHL02",25,0)
 S FLDS=".01;.02;1;2;2.2;3.2;6;6.1"
"RTN","RORHL02",26,0)
 D GETS^DIQ(798,RORIEN,FLDS,"IE","ROROUT","RORMSG")
"RTN","RORHL02",27,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"CSR^RORHL02",,798,RORIEN)
"RTN","RORHL02",28,0)
 ;
"RTN","RORHL02",29,0)
 I $G(RORFLDS)'=""  D
"RTN","RORHL02",30,0)
 . S:$E(RORFLDS)'="," RORFLDS=","_RORFLDS
"RTN","RORHL02",31,0)
 . S:$E(RORFLDS,$L(RORFLDS))'="," RORFLDS=RORFLDS_","
"RTN","RORHL02",32,0)
 E  S RORFLDS=",1,3,4,6,8,10,14,15,16," ; Default HL7 fields
"RTN","RORHL02",33,0)
 ;
"RTN","RORHL02",34,0)
 S $P(RORSEG,HLFS,1)="CSR"
"RTN","RORHL02",35,0)
 ;
"RTN","RORHL02",36,0)
 ; CSR-1 - Name of the registry
"RTN","RORHL02",37,0)
 I RORFLDS[",1," D
"RTN","RORHL02",38,0)
 .S $P(RORSEG,HLFS,2)=$G(ROROUT(798,RORIEN,.02,"E"))_CS_"VA"
"RTN","RORHL02",39,0)
 ;
"RTN","RORHL02",40,0)
 ; CSR-3 - Inpatient Division or User Division if fails
"RTN","RORHL02",41,0)
 I RORFLDS[",3," D
"RTN","RORHL02",42,0)
 .S $P(RORSEG,HLFS,4)=$$SITE^RORUTL03(CS)
"RTN","RORHL02",43,0)
 ;
"RTN","RORHL02",44,0)
 ; CSR-4 - Patient ID
"RTN","RORHL02",45,0)
 I RORFLDS[",4," D
"RTN","RORHL02",46,0)
 .S TMP=$$M10^HLFNC(ROROUT(798,RORIEN,.01,"I"),CS)
"RTN","RORHL02",47,0)
 .S:+TMP $P(RORSEG,HLFS,5)=TMP_CS_CS_"PI"_CS_$TR($P(RORSEG,HLFS,4),CS,SCS)
"RTN","RORHL02",48,0)
 ;
"RTN","RORHL02",49,0)
 ; CSR-6 - Date when entered to the registry
"RTN","RORHL02",50,0)
 I RORFLDS[",6," D
"RTN","RORHL02",51,0)
 .S TMP=$G(ROROUT(798,RORIEN,1,"I"))
"RTN","RORHL02",52,0)
 .S:TMP $P(RORSEG,HLFS,7)=$$FMTHL7^XLFDT($P(TMP,"."))
"RTN","RORHL02",53,0)
 ;
"RTN","RORHL02",54,0)
 ; CSR-10 - Supporting evidence AND  Reasons added
"RTN","RORHL02",55,0)
 ;
"RTN","RORHL02",56,0)
 I RORFLDS[",10," D
"RTN","RORHL02",57,0)
 . S TMP=$$GETAUTO(RORIEN,CS)
"RTN","RORHL02",58,0)
 . I TMP>0  S $P(RORSEG,HLFS,11)=TMP  Q
"RTN","RORHL02",59,0)
 . S TMP=$$ITEMCODE^RORUTL01($G(ROROUT(798,RORIEN,3.2,"I")),.RORTXT)
"RTN","RORHL02",60,0)
 . S:TMP>0 $P(RORSEG,HLFS,11)=TMP_CS_RORTXT_CS_"99VA79832"
"RTN","RORHL02",61,0)
 ;
"RTN","RORHL02",62,0)
 ; CSR-14 - Investigational drugs + Medication in Profile
"RTN","RORHL02",63,0)
 I RORFLDS[",14," D
"RTN","RORHL02",64,0)
 .S TMP=""
"RTN","RORHL02",65,0)
 .S $P(TMP,CS,1)=+$G(ROROUT(798,RORIEN,6,"I"))_+$G(ROROUT(798,RORIEN,6.1,"I"))
"RTN","RORHL02",66,0)
 .S $P(TMP,CS,2)="Investigational Drugs "_$S($G(ROROUT(798,RORIEN,6,"I")):"",1:"Not ")_"Used."
"RTN","RORHL02",67,0)
 .I +$G(ROROUT(798,RORIEN,6,"I")) D
"RTN","RORHL02",68,0)
 ..S $P(TMP,CS,2)=$P(TMP,CS,2)_" Medication "_$S($G(ROROUT(798,RORIEN,6.1,"I")):"",1:"not ")_"in Profile."
"RTN","RORHL02",69,0)
 .S $P(RORSEG,HLFS,15)=TMP_CS_"99VA7986"
"RTN","RORHL02",70,0)
 ;
"RTN","RORHL02",71,0)
 ; CSR-15 - Inactivation date
"RTN","RORHL02",72,0)
 I RORFLDS[",15," D
"RTN","RORHL02",73,0)
 .S TMP=$G(ROROUT(798,RORIEN,2,"I"))
"RTN","RORHL02",74,0)
 .S:TMP $P(RORSEG,HLFS,16)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL02",75,0)
 ;
"RTN","RORHL02",76,0)
 ; CSR-16 - Inactivation Reason
"RTN","RORHL02",77,0)
 I RORFLDS[",16," D
"RTN","RORHL02",78,0)
 .Q:'$G(ROROUT(798,RORIEN,2.2,"I"))
"RTN","RORHL02",79,0)
 .S TMP=""
"RTN","RORHL02",80,0)
 .S TMP=$$ITEMCODE^RORUTL01($G(ROROUT(798,RORIEN,2.2,"I")),.RORTXT)
"RTN","RORHL02",81,0)
 .S $P(TMP,CS,2)=RORTXT
"RTN","RORHL02",82,0)
 .S $P(TMP,CS,3)="99VA79822"
"RTN","RORHL02",83,0)
 .S:+TMP $P(RORSEG,HLFS,17)=TMP
"RTN","RORHL02",84,0)
 ;
"RTN","RORHL02",85,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL02",86,0)
 S RORPTR=RORPTR+1,^TMP("HLS",$J,RORPTR)=$TR(RORSEG,$C(9,10,13),"   ")
"RTN","RORHL02",87,0)
 ;
"RTN","RORHL02",88,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL02",89,0)
 ;
"RTN","RORHL02",90,0)
CSP(RORIEN,RORFLDS,RORPTR,HLFS,HLECH) ; CSP SEGMENT
"RTN","RORHL02",91,0)
 ;
"RTN","RORHL02",92,0)
 ; INPUT:  RORIEN - IEN of Patient Record in Registry File #798 (Req'd)
"RTN","RORHL02",93,0)
 ;         RORFLDS - Segment Fields to populate                 (Opt'l)
"RTN","RORHL02",94,0)
 ;                   (1,2,3 available)
"RTN","RORHL02",95,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                    (Opt'l)
"RTN","RORHL02",96,0)
 ;         HLFS - Field Separator. Defaults to |               (Opt'l)
"RTN","RORHL02",97,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&       (Opt'l)
"RTN","RORHL02",98,0)
 ;
"RTN","RORHL02",99,0)
 N CS,FLDS,RORMSG,ROROUT,RORRES,RORSEG,TMP
"RTN","RORHL02",100,0)
 ;
"RTN","RORHL02",101,0)
 S RORRES=0
"RTN","RORHL02",102,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL02",103,0)
 ;
"RTN","RORHL02",104,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORHL02",105,0)
 ;
"RTN","RORHL02",106,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL02",107,0)
 S CS=$E(HLECH,1)
"RTN","RORHL02",108,0)
 ;
"RTN","RORHL02",109,0)
 I $G(RORFLDS)'=""  D
"RTN","RORHL02",110,0)
 . S:$E(RORFLDS)'="," RORFLDS=","_RORFLDS
"RTN","RORHL02",111,0)
 . S:$E(RORFLDS,$L(RORFLDS))'="" RORFLDS=RORFLDS_","
"RTN","RORHL02",112,0)
 E  S RORFLDS=",1,2,3," ; Default HL7 fields
"RTN","RORHL02",113,0)
 ;
"RTN","RORHL02",114,0)
 S FLDS="1;2;3;7"
"RTN","RORHL02",115,0)
 ;
"RTN","RORHL02",116,0)
 D GETS^DIQ(798,RORIEN,FLDS,"IE","ROROUT","RORMSG")
"RTN","RORHL02",117,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"CSP^RORHL02",,798,RORIEN)
"RTN","RORHL02",118,0)
 ;
"RTN","RORHL02",119,0)
 S $P(RORSEG,HLFS,1)="CSP"
"RTN","RORHL02",120,0)
 ;
"RTN","RORHL02",121,0)
 ; CSP-1 - New Patient?
"RTN","RORHL02",122,0)
 I RORFLDS[",1," D
"RTN","RORHL02",123,0)
 . S TMP=$G(ROROUT(798,RORIEN,3,"I"))_CS_$G(ROROUT(798,RORIEN,3,"E"))
"RTN","RORHL02",124,0)
 . S $P(RORSEG,HLFS,2)=$S(TMP>0:TMP,1:"0"_CS_"Edit")_CS_"99VA7983"
"RTN","RORHL02",125,0)
 ;
"RTN","RORHL02",126,0)
 ; CSP-2 - Registration Date or Reactivation Date
"RTN","RORHL02",127,0)
 I RORFLDS[",2," D
"RTN","RORHL02",128,0)
 .S TMP=$G(ROROUT(798,RORIEN,7,"I"))
"RTN","RORHL02",129,0)
 .S:TMP="" TMP=$G(ROROUT(798,RORIEN,1,"I"))
"RTN","RORHL02",130,0)
 .S:TMP $P(RORSEG,HLFS,3)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL02",131,0)
 ;
"RTN","RORHL02",132,0)
 ; CSP-3 - Inactivation Date or null
"RTN","RORHL02",133,0)
 I RORFLDS[",3," D
"RTN","RORHL02",134,0)
 .I $G(ROROUT(798,RORIEN,2,"I"))>$G(ROROUT(798,RORIEN,7,"I")) D
"RTN","RORHL02",135,0)
 ..S TMP=$G(ROROUT(798,RORIEN,2,"I"))
"RTN","RORHL02",136,0)
 ..S:TMP $P(RORSEG,HLFS,4)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL02",137,0)
 ;
"RTN","RORHL02",138,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL02",139,0)
 S RORPTR=RORPTR+1,^TMP("HLS",$J,RORPTR)=$TR(RORSEG,$C(9,10,13),"   ")
"RTN","RORHL02",140,0)
 ;
"RTN","RORHL02",141,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL02",142,0)
 ;
"RTN","RORHL02",143,0)
CSS(RORIEN,RORFLDS,RORPTR,HLFS,HLECH) ; CSS SEGMENT
"RTN","RORHL02",144,0)
 ;
"RTN","RORHL02",145,0)
 ; INPUT:  RORIEN - IEN of Patient Record in Registry File #798 (Req'd)
"RTN","RORHL02",146,0)
 ;         RORFLDS - Segment Fields to populate                 (Opt'l)
"RTN","RORHL02",147,0)
 ;                   (1,2 available)
"RTN","RORHL02",148,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                    (Opt'l)
"RTN","RORHL02",149,0)
 ;         HLFS - Field Separator. Defaults to |               (Opt'l)
"RTN","RORHL02",150,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&       (Opt'l)
"RTN","RORHL02",151,0)
 ;
"RTN","RORHL02",152,0)
 N CS,FLDS,IEN7981,RORMSG,RORRES,RORSEG,TMP
"RTN","RORHL02",153,0)
 ;
"RTN","RORHL02",154,0)
 S RORRES=0
"RTN","RORHL02",155,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL02",156,0)
 ;
"RTN","RORHL02",157,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORHL02",158,0)
 ;
"RTN","RORHL02",159,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL02",160,0)
 S CS=$E(HLECH,1)
"RTN","RORHL02",161,0)
 ;
"RTN","RORHL02",162,0)
 I RORFLDS'=""  D
"RTN","RORHL02",163,0)
 . S:$E(RORFLDS)'="," RORFLDS=","_RORFLDS
"RTN","RORHL02",164,0)
 . S:$E(RORFLDS,$L(RORFLDS))'="" RORFLDS=RORFLDS_","
"RTN","RORHL02",165,0)
 E  S RORFLDS=",1,2," ; Default HL7 fields
"RTN","RORHL02",166,0)
 ;
"RTN","RORHL02",167,0)
 S $P(RORSEG,HLFS,1)="CSS"
"RTN","RORHL02",168,0)
 ;
"RTN","RORHL02",169,0)
 ; CSS-1 Required Field. Set to "O"
"RTN","RORHL02",170,0)
 I RORFLDS[",1," D
"RTN","RORHL02",171,0)
 .S $P(RORSEG,HLFS,2)="O"_CS_"ONE TIME ONLY"_CS_"L"
"RTN","RORHL02",172,0)
 ;
"RTN","RORHL02",173,0)
 ; CSS-2 Last Extract Date
"RTN","RORHL02",174,0)
 I RORFLDS[",2," D  Q:RORRES<0 RORRES
"RTN","RORHL02",175,0)
 .S IEN7981=$$GET1^DIQ(798,RORIEN,.02,"I",,"RORMSG")
"RTN","RORHL02",176,0)
 .I $G(DIERR)  D  Q
"RTN","RORHL02",177,0)
 ..S RORRES=$$DBS^RORERR("RORMSG",-9,"CSS^RORHL02",,798,RORIEN)
"RTN","RORHL02",178,0)
 .I IEN7981 D  Q:RORRES<0
"RTN","RORHL02",179,0)
 ..S TMP=$$GET1^DIQ(798.1,IEN7981,"2","I",,"RORMSG")
"RTN","RORHL02",180,0)
 ..I $G(DIERR)  D  Q
"RTN","RORHL02",181,0)
 ...S RORRES=$$DBS^RORERR("RORMSG",-9,"CSS^RORHL02",,798.1,IEN7981)
"RTN","RORHL02",182,0)
 ..S:TMP $P(RORSEG,HLFS,3)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL02",183,0)
 ;
"RTN","RORHL02",184,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL02",185,0)
 S RORPTR=RORPTR+1,^TMP("HLS",$J,RORPTR)=$TR(RORSEG,$C(9,10,13),"   ")
"RTN","RORHL02",186,0)
 ;
"RTN","RORHL02",187,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL02",188,0)
 ;
"RTN","RORHL02",189,0)
GETAUTO(RORIEN,CS) ;
"RTN","RORHL02",190,0)
 ;  Patient added automatically so get automatic reason(s)
"RTN","RORHL02",191,0)
 ;  fopr addition into registry.
"RTN","RORHL02",192,0)
 ; Any Reasons ?
"RTN","RORHL02",193,0)
 ;
"RTN","RORHL02",194,0)
 N K4,RARRAY,RPNTR,VALUE,TMPIEN
"RTN","RORHL02",195,0)
 ;
"RTN","RORHL02",196,0)
 ; Remove "," from RORIEN.
"RTN","RORHL02",197,0)
 S TMPIEN=$TR(RORIEN,",")
"RTN","RORHL02",198,0)
 ;
"RTN","RORHL02",199,0)
 Q:$D(^RORDATA(798,TMPIEN,1,"B"))<10 ""
"RTN","RORHL02",200,0)
 ;
"RTN","RORHL02",201,0)
 S K4=0
"RTN","RORHL02",202,0)
 F  S K4=$O(^RORDATA(798,TMPIEN,1,K4))  Q:'K4  D
"RTN","RORHL02",203,0)
 . S RPNTR=$P(^RORDATA(798,TMPIEN,1,K4,0),"^")
"RTN","RORHL02",204,0)
 . S VALUE=$P($G(^ROR(798.2,RPNTR,0)),"^")
"RTN","RORHL02",205,0)
 . Q:VALUE=""
"RTN","RORHL02",206,0)
 . I VALUE="VA HEPC LAB"         S RARRAY("LAB")=""   Q
"RTN","RORHL02",207,0)
 . I VALUE="VA HEPC PROBLEM"     S RARRAY("ICD9")=""  Q
"RTN","RORHL02",208,0)
 . I VALUE="VA HEPC PTF"         S RARRAY("ICD9")=""  Q
"RTN","RORHL02",209,0)
 . I VALUE="VA HEPC PTF HIST"    S RARRAY("ICD9")=""  Q
"RTN","RORHL02",210,0)
 . I VALUE="VA HEPC VISIT HIST"  S RARRAY("ICD9")=""  Q
"RTN","RORHL02",211,0)
 . I VALUE="VA HEPC VPOV"        S RARRAY("ICD9")=""  Q
"RTN","RORHL02",212,0)
 ;
"RTN","RORHL02",213,0)
 I $D(RARRAY("ICD9")),$D(RARRAY("LAB")) Q "9"_CS_"Automatically Added - ICD9 and Lab"_CS_"99VA79832"
"RTN","RORHL02",214,0)
 Q:$D(RARRAY("LAB")) "8"_CS_"Automatically Added - Lab"_CS_"99VA79832"
"RTN","RORHL02",215,0)
 Q:$D(RARRAY("ICD9")) "7"_CS_"Automatically Added - ICD9"_CS_"99VA79832"
"RTN","RORHL02",216,0)
 ;
"RTN","RORHL02",217,0)
 Q ""
"RTN","RORHL03")
0^26^B64738074
"RTN","RORHL03",1,0)
RORHL03 ;HOIFO/CRT - Clinical Registries Segment APIs - OP PHARMACY ; 5/6/02 1:23pm
"RTN","RORHL03",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHL03",3,0)
 ;
"RTN","RORHL03",4,0)
 ; External reference to OCL^PSOORRL supported by DBIA 3142
"RTN","RORHL03",5,0)
 ; External reference to OEL^PSOORRL supported by DBIA 3143
"RTN","RORHL03",6,0)
 Q
"RTN","RORHL03",7,0)
 ;
"RTN","RORHL03",8,0)
EN1(RORDFN,RORSTDT,RORENDT,RORPTR,RORFILE,HLFS,HLECH) ;
"RTN","RORHL03",9,0)
 ; Search OP Pharmacy Data
"RTN","RORHL03",10,0)
 ;
"RTN","RORHL03",11,0)
 ; INPUT:  RORDFN - DFN on Patient File #2                     (Req'd)
"RTN","RORHL03",12,0)
 ;         RORSTDT - Start Date/Time          (Fileman format) (Req'd)
"RTN","RORHL03",13,0)
 ;         RORENDT - End Date/Time            (Fileman format) (Req'd)
"RTN","RORHL03",14,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)      (Opt'l)
"RTN","RORHL03",15,0)
 ;         HLFS - Field Separator. Defaults to |               (Opt'l)
"RTN","RORHL03",16,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&       (Opt'l)
"RTN","RORHL03",17,0)
 ;
"RTN","RORHL03",18,0)
 N II,RORRES,RORIEN,RORIENS,RORINC,RORMSG
"RTN","RORHL03",19,0)
 ;
"RTN","RORHL03",20,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL03",21,0)
 ;
"RTN","RORHL03",22,0)
 S RORRES=0
"RTN","RORHL03",23,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL03",24,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL03",25,0)
 ;
"RTN","RORHL03",26,0)
 S RORDFN=+$G(RORDFN)
"RTN","RORHL03",27,0)
 I '$D(^DPT(RORDFN)) D  Q RORRES
"RTN","RORHL03",28,0)
 .S RORRES=$$ERROR^RORERR(-36,"EN1^RORHL03",,,RORDFN,2)
"RTN","RORHL03",29,0)
 ;
"RTN","RORHL03",30,0)
 K ^TMP("PS",$J)
"RTN","RORHL03",31,0)
 D OCL^PSOORRL(RORDFN,RORSTDT,RORENDT)                   ; DBIA #3142
"RTN","RORHL03",32,0)
 I '$D(^TMP("PS",$J)) Q RORRES
"RTN","RORHL03",33,0)
 M ^TMP($J,"ROR-PS")=^TMP("PS",$J)
"RTN","RORHL03",34,0)
 K ^TMP("PS",$J)
"RTN","RORHL03",35,0)
 ;
"RTN","RORHL03",36,0)
 S II=0 F  S II=$O(^TMP($J,"ROR-PS",II)) Q:'II  D  Q:RORRES<0
"RTN","RORHL03",37,0)
 .N RORRXE,RORIDATE
"RTN","RORHL03",38,0)
 .S RORIEN=$P(^TMP($J,"ROR-PS",II,0),"^",1)
"RTN","RORHL03",39,0)
 .Q:"R,U"'[$E($P(RORIEN,";"),$L($P(RORIEN,";")))
"RTN","RORHL03",40,0)
 .;
"RTN","RORHL03",41,0)
 .I $E($P(RORIEN,";"),$L($P(RORIEN,";")))="U" D  I ((RORIDATE<RORSTDT)!(RORIDATE'<RORENDT)) Q
"RTN","RORHL03",42,0)
 ..S RORIDATE=$P($G(^TMP($J,"ROR-PS",II,0)),"^",15)
"RTN","RORHL03",43,0)
 .I $E($P(RORIEN,";"),$L($P(RORIEN,";")))="R" D  Q:RORIDATE<RORSTDT
"RTN","RORHL03",44,0)
 ..S RORIDATE=$P($G(^TMP($J,"ROR-PS",II,0)),"^",10)
"RTN","RORHL03",45,0)
 .;
"RTN","RORHL03",46,0)
 .K ^TMP("PS",$J)
"RTN","RORHL03",47,0)
 .D OEL^PSOORRL(RORDFN,RORIEN)                             ; DBIA #3143
"RTN","RORHL03",48,0)
 .Q:'$D(^TMP("PS",$J))
"RTN","RORHL03",49,0)
 .M RORRXE=^TMP("PS",$J)
"RTN","RORHL03",50,0)
 .K ^TMP("PS",$J)
"RTN","RORHL03",51,0)
 .;
"RTN","RORHL03",52,0)
 .I $P(RORIEN,";",2)="O" D  Q:'RORINC
"RTN","RORHL03",53,0)
 ..N RORII,RORDATE
"RTN","RORHL03",54,0)
 ..D REFILL
"RTN","RORHL03",55,0)
 ..; Check if orginal presc or one of the refills falls within date range
"RTN","RORHL03",56,0)
 ..S RORINC=0
"RTN","RORHL03",57,0)
 ..S RORII="" F  S RORII=$O(RORRXE("REF",RORII)) Q:RORII=""  D
"RTN","RORHL03",58,0)
 ...S RORDATE=$P($G(RORRXE("REF",RORII,0)),"^",1)
"RTN","RORHL03",59,0)
 ...I ((RORDATE<RORSTDT)!(RORDATE'<RORENDT)) D  Q
"RTN","RORHL03",60,0)
 ....K RORRXE("REF",RORII,0)
"RTN","RORHL03",61,0)
 ...S RORINC=1
"RTN","RORHL03",62,0)
 .;
"RTN","RORHL03",63,0)
 .I $P(RORIEN,";",2)="O" D
"RTN","RORHL03",64,0)
 ..S RORIENS=+$P(RORIEN,";")
"RTN","RORHL03",65,0)
 ..S RORRES=$$ORC(RORIENS,.RORRXE,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL03",66,0)
 ..Q:RORRES<0
"RTN","RORHL03",67,0)
 ..S RORRES=$$RXE(RORIENS,.RORRXE,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL03",68,0)
 .E  D
"RTN","RORHL03",69,0)
 ..S RORIENS=+$P(RORIEN,";")_","_RORDFN_","
"RTN","RORHL03",70,0)
 ..S RORRES=$$ORC^RORHL07(RORIENS,.RORRXE,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL03",71,0)
 ..Q:RORRES<0
"RTN","RORHL03",72,0)
 ..S RORRES=$$RXE^RORHL07(RORIENS,.RORRXE,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL03",73,0)
 ;
"RTN","RORHL03",74,0)
 K ^TMP($J,"ROR-PS")
"RTN","RORHL03",75,0)
 ;
"RTN","RORHL03",76,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL03",77,0)
 ;
"RTN","RORHL03",78,0)
ORC(RORIEN,RORORC,RORPTR,RORFILE,HLFS,HLECH) ; ORC SEGMENT (OP Pharmacy Data)
"RTN","RORHL03",79,0)
 ;
"RTN","RORHL03",80,0)
 ; INPUT:  RORIEN - IEN of Record in Prescription File #52      (Req'd)
"RTN","RORHL03",81,0)
 ;         RORORC - Array containing info (from OEL^PSOORRL)    (Req'd)
"RTN","RORHL03",82,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)       (Opt'l)
"RTN","RORHL03",83,0)
 ;         HLFS - Field Separator. Defaults to |               (Opt'l)
"RTN","RORHL03",84,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&       (Opt'l)
"RTN","RORHL03",85,0)
 ;
"RTN","RORHL03",86,0)
 N CS,FLDS,IEN59,RORMSG,ROROUT,RORRES,RORSEG,TMP
"RTN","RORHL03",87,0)
 ;
"RTN","RORHL03",88,0)
 S RORRES=0
"RTN","RORHL03",89,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL03",90,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL03",91,0)
 ;
"RTN","RORHL03",92,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL03",93,0)
 S CS=$E(HLECH,1)
"RTN","RORHL03",94,0)
 ;
"RTN","RORHL03",95,0)
 S $P(RORSEG,HLFS,1)="ORC"
"RTN","RORHL03",96,0)
 ;
"RTN","RORHL03",97,0)
 ; ORC-1 - Order Control 
"RTN","RORHL03",98,0)
 S $P(RORSEG,HLFS,2)="NW"
"RTN","RORHL03",99,0)
 ;
"RTN","RORHL03",100,0)
 ; ORC-2 - Placer Order Number
"RTN","RORHL03",101,0)
 S $P(RORSEG,HLFS,3)=+RORIEN_CS_"OP"
"RTN","RORHL03",102,0)
 ;
"RTN","RORHL03",103,0)
 ; ORC-9 - Release Date/Time
"RTN","RORHL03",104,0)
 S TMP=$P($G(RORORC("RXN",0)),"^",2)
"RTN","RORHL03",105,0)
 S:TMP $P(RORSEG,HLFS,10)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL03",106,0)
 ;
"RTN","RORHL03",107,0)
 ; ORC-12 - Provider
"RTN","RORHL03",108,0)
 S $P(RORSEG,HLFS,13)=$P($G(RORORC("P",0)),"^")
"RTN","RORHL03",109,0)
 ;
"RTN","RORHL03",110,0)
 ; ORC-15 - Order Date/Time
"RTN","RORHL03",111,0)
 S TMP=$P($G(RORORC(0)),"^",5)
"RTN","RORHL03",112,0)
 S:TMP $P(RORSEG,HLFS,16)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL03",113,0)
 ;
"RTN","RORHL03",114,0)
 ; ORC-16 - Control Code Reason
"RTN","RORHL03",115,0)
 S $P(RORSEG,HLFS,17)=CS_CS_CS_CS_"NEW"
"RTN","RORHL03",116,0)
 ;
"RTN","RORHL03",117,0)
 ; ORC-17 - Division
"RTN","RORHL03",118,0)
 S $P(RORSEG,HLFS,18)=$$SITE^RORUTL03(CS)
"RTN","RORHL03",119,0)
 S TMP=""
"RTN","RORHL03",120,0)
 S IEN59=+$$GET1^DIQ(52,+RORIEN,20,"I",,"RORMSG")_","
"RTN","RORHL03",121,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ORC^RORHL03",,52,+RORIEN)
"RTN","RORHL03",122,0)
 D GETS^DIQ(59,IEN59,100,"IE","ROROUT","RORMSG")
"RTN","RORHL03",123,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ORC^RORHL03",,59,IEN59)
"RTN","RORHL03",124,0)
 S $P(TMP,CS,1)=$$GET1^DIQ(4,+$G(ROROUT(59,IEN59,100,"I")),99,"I")
"RTN","RORHL03",125,0)
 S $P(TMP,CS,2)=$G(ROROUT(59,IEN59,100,"E"))
"RTN","RORHL03",126,0)
 S $P(TMP,CS,3)="99VA4"
"RTN","RORHL03",127,0)
 S:$P(TMP,CS)]"" $P(RORSEG,HLFS,18)=TMP
"RTN","RORHL03",128,0)
 ;
"RTN","RORHL03",129,0)
 ;
"RTN","RORHL03",130,0)
 ;--- Store the segment
"RTN","RORHL03",131,0)
 I $P($G(RORSEG),HLFS,3)]"" D
"RTN","RORHL03",132,0)
 . S RORPTR=RORPTR+1
"RTN","RORHL03",133,0)
 . S @RORFILE@(RORPTR)=$TR(RORSEG,$C(9,10,13),"   ")
"RTN","RORHL03",134,0)
 ;
"RTN","RORHL03",135,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL03",136,0)
 ;
"RTN","RORHL03",137,0)
RXE(RORIEN,RORRXE,RORPTR,RORFILE,HLFS,HLECH) ; RXE SEGMENT (OP Pharmacy Data)
"RTN","RORHL03",138,0)
 ;
"RTN","RORHL03",139,0)
 ; INPUT:  RORIEN - IEN of Record in Prescription File #52      (Req'd)
"RTN","RORHL03",140,0)
 ;         RORRXE - Array containing info (from OEL^PSOORRL)    (Req'd)
"RTN","RORHL03",141,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)       (Opt'l)
"RTN","RORHL03",142,0)
 ;         HLFS - Field Separator. Defaults to |               (Opt'l)
"RTN","RORHL03",143,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&       (Opt'l)
"RTN","RORHL03",144,0)
 ;
"RTN","RORHL03",145,0)
 N CS,II,RORMSG,ROROUT,RORRES
"RTN","RORHL03",146,0)
 ;
"RTN","RORHL03",147,0)
 S RORRES=0
"RTN","RORHL03",148,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL03",149,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL03",150,0)
 ;
"RTN","RORHL03",151,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL03",152,0)
 S CS=$E(HLECH,1)
"RTN","RORHL03",153,0)
 ;
"RTN","RORHL03",154,0)
 Q:$P($G(RORRXE(0)),"^",1)="" RORRES
"RTN","RORHL03",155,0)
 ;
"RTN","RORHL03",156,0)
 S II="" F  S II=$O(RORRXE("REF",II)) Q:II=""  D  Q:RORRES<0
"RTN","RORHL03",157,0)
 .N CMOP,IDGN,INDF,J,RORLIST,RORSEG,TMP
"RTN","RORHL03",158,0)
 .;
"RTN","RORHL03",159,0)
 .S $P(RORSEG,HLFS,1)="RXE"
"RTN","RORHL03",160,0)
 .;
"RTN","RORHL03",161,0)
 .; RXE-1 - Quantity/Timing
"RTN","RORHL03",162,0)
 .S $P(RORSEG,HLFS,2)=""""""
"RTN","RORHL03",163,0)
 .;
"RTN","RORHL03",164,0)
 .; RXE-2 - Give Code
"RTN","RORHL03",165,0)
 .S TMP=""
"RTN","RORHL03",166,0)
 .S IDGN=+$P($G(RORRXE("DD",1,0)),"^",3)                ; File #50 IEN
"RTN","RORHL03",167,0)
 .S:'IDGN IDGN=+$P($G(RORRXE("DD",1,0)),"^",1)
"RTN","RORHL03",168,0)
 .S RORRES=$$RXE2(IDGN,CS,.TMP) Q:RORRES<0
"RTN","RORHL03",169,0)
 .S $P(RORSEG,HLFS,3)=TMP
"RTN","RORHL03",170,0)
 .;
"RTN","RORHL03",171,0)
 .; RXE-3 - Give Amount (Min)
"RTN","RORHL03",172,0)
 .S $P(RORSEG,HLFS,4)=""""""
"RTN","RORHL03",173,0)
 .;
"RTN","RORHL03",174,0)
 .; RXE-5 - Give Units
"RTN","RORHL03",175,0)
 .S TMP=""
"RTN","RORHL03",176,0)
 .S INDF=+$$GET1^DIQ(50,IDGN,22,"I",,"RORMSG")_","   ; File #50.68 IEN
"RTN","RORHL03",177,0)
 .I $G(DIERR)  D  Q
"RTN","RORHL03",178,0)
 ..S RORRES=$$DBS^RORERR("RORMSG",-9,"RXE^RORHL03",,50,IDGN)
"RTN","RORHL03",179,0)
 .D GETS^DIQ(50.68,INDF,3,"IE","ROROUT","RORMSG")
"RTN","RORHL03",180,0)
 .I $G(DIERR)  D  Q
"RTN","RORHL03",181,0)
 ..S RORRES=$$DBS^RORERR("RORMSG",-9,"RXE^RORHL03",,50.68,INDF)
"RTN","RORHL03",182,0)
 .S $P(TMP,CS,4)=$G(ROROUT(50.68,INDF,3,"I"))
"RTN","RORHL03",183,0)
 .S $P(TMP,CS,5)=$G(ROROUT(50.68,INDF,3,"E"))
"RTN","RORHL03",184,0)
 .S $P(TMP,CS,6)="99PSU"
"RTN","RORHL03",185,0)
 .S $P(RORSEG,HLFS,6)=TMP
"RTN","RORHL03",186,0)
 .;
"RTN","RORHL03",187,0)
 .; RXE-7 - SIG1
"RTN","RORHL03",188,0)
 .S $P(RORSEG,HLFS,8)=CS_$$ESCAPE^RORHL7($G(RORRXE("SIG",1,0)))
"RTN","RORHL03",189,0)
 .;
"RTN","RORHL03",190,0)
 .; RXE-10 - Dispense Amount
"RTN","RORHL03",191,0)
 .S $P(RORSEG,HLFS,11)=$P($G(RORRXE("REF",II,0)),"^",3)
"RTN","RORHL03",192,0)
 .;
"RTN","RORHL03",193,0)
 .; RXE-18 - Fill Date/Time
"RTN","RORHL03",194,0)
 .S TMP=$P($G(RORRXE("REF",II,0)),"^",1)
"RTN","RORHL03",195,0)
 .S:TMP $P(RORSEG,HLFS,19)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL03",196,0)
 .;
"RTN","RORHL03",197,0)
 .; RXE-19 - Daily Dose
"RTN","RORHL03",198,0)
 .S $P(RORSEG,HLFS,20)=$P($G(RORRXE("REF",II,0)),"^",2)
"RTN","RORHL03",199,0)
 .;
"RTN","RORHL03",200,0)
 .; RXE-20 - CMOP?
"RTN","RORHL03",201,0)
 .S TMP=0
"RTN","RORHL03",202,0)
 .D LIST^DIC(52.01,","_RORIEN_",","2;3","I",,,,,,,"RORLIST","RORMSG")
"RTN","RORHL03",203,0)
 .I $G(DIERR)  D  Q
"RTN","RORHL03",204,0)
 ..S RORRES=$$DBS^RORERR("RORMSG",-9,"RXE^RORHL03",,52.01)
"RTN","RORHL03",205,0)
 .S J=0 F  S J=$O(RORLIST("DILIST","ID",J)) Q:J=""  D  Q:TMP
"RTN","RORHL03",206,0)
 ..I $G(RORLIST("DILIST","ID",J,2))=II D
"RTN","RORHL03",207,0)
 ...S:$G(RORLIST("DILIST","ID",J,3))'=3 TMP=1
"RTN","RORHL03",208,0)
 .S $P(RORSEG,HLFS,21)=$S(TMP=1:"Y",1:"N")
"RTN","RORHL03",209,0)
 .;
"RTN","RORHL03",210,0)
 .; RXE-30 Mail/Window
"RTN","RORHL03",211,0)
 .S TMP=$P($G(RORRXE("REF",II,0)),"^",5)
"RTN","RORHL03",212,0)
 .S $P(RORSEG,HLFS,31)=$S(TMP="M":"AD",TMP="W":"TR",1:"")
"RTN","RORHL03",213,0)
 .;
"RTN","RORHL03",214,0)
 .;--- Store the segment
"RTN","RORHL03",215,0)
 .I $G(RORSEG)]"" D
"RTN","RORHL03",216,0)
 ..S RORPTR=RORPTR+1
"RTN","RORHL03",217,0)
 ..S @RORFILE@(RORPTR)=$TR(RORSEG,$C(9,10,13),"   ")
"RTN","RORHL03",218,0)
 ;
"RTN","RORHL03",219,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL03",220,0)
 ;
"RTN","RORHL03",221,0)
REFILL ; Make orginal fill like refills to reuse code
"RTN","RORHL03",222,0)
 S RORRXE("REF",0,0)=""
"RTN","RORHL03",223,0)
 S $P(RORRXE("REF",0,0),"^",1)=$P(RORRXE("RXN",0),"^",6)
"RTN","RORHL03",224,0)
 S $P(RORRXE("REF",0,0),"^",2)=$P(RORRXE(0),"^",7)
"RTN","RORHL03",225,0)
 S $P(RORRXE("REF",0,0),"^",3)=$P(RORRXE(0),"^",8)
"RTN","RORHL03",226,0)
 S $P(RORRXE("REF",0,0),"^",4)=$P(RORRXE("RXN",0),"^",7)
"RTN","RORHL03",227,0)
 S $P(RORRXE("REF",0,0),"^",5)=$P(RORRXE("RXN",0),"^",3)
"RTN","RORHL03",228,0)
 Q
"RTN","RORHL03",229,0)
 ;
"RTN","RORHL03",230,0)
RXE2(IDGN,CS,RXE2) ; RXE-2 Give Code
"RTN","RORHL03",231,0)
 ;
"RTN","RORHL03",232,0)
 ; INPUT:  IDGN - IEN of Drug File #50                        (Req'd)
"RTN","RORHL03",233,0)
 ;         CS - Component Separator (defaults to "^")         (Opt'l)
"RTN","RORHL03",234,0)
 ;         RXE2 - RXE-2 Field (Call by reference)
"RTN","RORHL03",235,0)
 ;
"RTN","RORHL03",236,0)
 N INDF,RORMSG,ROROUT,RORRES,TMP
"RTN","RORHL03",237,0)
 ;
"RTN","RORHL03",238,0)
 S RORRES=0
"RTN","RORHL03",239,0)
 S RXE2=""
"RTN","RORHL03",240,0)
 ;
"RTN","RORHL03",241,0)
 S CS=$G(CS) S:CS="" CS="^"
"RTN","RORHL03",242,0)
 S IDGN=+$G(IDGN)_","                                    ; File 50 IEN
"RTN","RORHL03",243,0)
 ;
"RTN","RORHL03",244,0)
 D GETS^DIQ(50,IDGN,".01;2;20;22;27;31","IE","ROROUT","RORMSG")
"RTN","RORHL03",245,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"RXE2^RORHL03",,50,IDGN)
"RTN","RORHL03",246,0)
 ;
"RTN","RORHL03",247,0)
 S INDF=+$G(ROROUT(50,IDGN,22,"I"))_","               ; File 50.68 IEN
"RTN","RORHL03",248,0)
 ;
"RTN","RORHL03",249,0)
 D GETS^DIQ(50.68,INDF,".01;6","E","ROROUT","RORMSG")
"RTN","RORHL03",250,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"RXE2^RORHL03",,50.68,INDF)
"RTN","RORHL03",251,0)
 ;
"RTN","RORHL03",252,0)
 S $P(RXE2,CS)=$G(ROROUT(50,IDGN,31,"E"))        ; NDC
"RTN","RORHL03",253,0)
 ;
"RTN","RORHL03",254,0)
 S $P(RXE2,CS,2)=$G(ROROUT(50.68,INDF,.01,"E"))  ; VA Product Name
"RTN","RORHL03",255,0)
 ;
"RTN","RORHL03",256,0)
 S $P(RXE2,CS,3)="PSNDF"
"RTN","RORHL03",257,0)
 ;
"RTN","RORHL03",258,0)
 S TMP=""
"RTN","RORHL03",259,0)
 S $P(TMP,"-",1)=$G(ROROUT(50,IDGN,20,"I"))      ; VA Drug Code
"RTN","RORHL03",260,0)
 S $P(TMP,"-",2)=$G(ROROUT(50,IDGN,2,"E"))       ; VA Drug Class
"RTN","RORHL03",261,0)
 S $P(RXE2,CS,4)=TMP
"RTN","RORHL03",262,0)
 ;
"RTN","RORHL03",263,0)
 S $P(RXE2,CS,5)=$G(ROROUT(50,IDGN,.01,"E"))     ; Drug Name
"RTN","RORHL03",264,0)
 ;
"RTN","RORHL03",265,0)
 S $P(RXE2,CS,6)="99PSD"
"RTN","RORHL03",266,0)
 ;
"RTN","RORHL03",267,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL03",268,0)
 ;
"RTN","RORHL04")
0^27^B14087804
"RTN","RORHL04",1,0)
RORHL04 ;HOIFO/CRT - Clinical Registries Segment APIs - RADIOLOGY ; 5/6/02 1:23pm
"RTN","RORHL04",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHL04",3,0)
 ;
"RTN","RORHL04",4,0)
 Q
"RTN","RORHL04",5,0)
 ;
"RTN","RORHL04",6,0)
EN1(RORDFN,RORSTDT,RORENDT,RORPTR,RORFILE,HLFS,HLECH) ;
"RTN","RORHL04",7,0)
 ; Search Radiology for Data
"RTN","RORHL04",8,0)
 ;
"RTN","RORHL04",9,0)
 ; INPUT:  RORDFN - DFN of Patient in File #2                  (Req'd)
"RTN","RORHL04",10,0)
 ;         RORSTDT - Start Date (FileMan Format)               (Req'd)
"RTN","RORHL04",11,0)
 ;         RORENDT - End Date   (FileMan Format)               (Req'd)
"RTN","RORHL04",12,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)      (Opt'l)
"RTN","RORHL04",13,0)
 ;         HLFS - Field Separator. Defaults to |               (Opt'l)
"RTN","RORHL04",14,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&       (Opt'l)
"RTN","RORHL04",15,0)
 ;
"RTN","RORHL04",16,0)
 N DATE,RACNI,RADPT,RADTI,RAIENS,RORRES
"RTN","RORHL04",17,0)
 ;
"RTN","RORHL04",18,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL04",19,0)
 ;
"RTN","RORHL04",20,0)
 S RORRES=0
"RTN","RORHL04",21,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL04",22,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL04",23,0)
 ;
"RTN","RORHL04",24,0)
 S RORDFN=+$G(RORDFN)
"RTN","RORHL04",25,0)
 I '$D(^DPT(RORDFN)) D  Q RORRES
"RTN","RORHL04",26,0)
 .S RORRES=$$ERROR^RORERR(-36,"EN1^RORHL04",,,RORDFN,2)
"RTN","RORHL04",27,0)
 ;
"RTN","RORHL04",28,0)
 I '$D(^RADPT(RORDFN)) Q RORRES
"RTN","RORHL04",29,0)
 ;
"RTN","RORHL04",30,0)
 S DATE=$$FMADD^XLFDT(RORSTDT,,,,-1) ; Subtract 1 second
"RTN","RORHL04",31,0)
 F  S DATE=$O(^RADPT(RORDFN,"DT","B",DATE)) Q:DATE=""!(DATE'<RORENDT)  D  Q:RORRES<0
"RTN","RORHL04",32,0)
 .S RADTI=$O(^RADPT(RORDFN,"DT","B",DATE,0))
"RTN","RORHL04",33,0)
 .S RACNI=0
"RTN","RORHL04",34,0)
 .F  S RACNI=$O(^RADPT(RORDFN,"DT",RADTI,"P",RACNI)) Q:'+RACNI  D  Q:RORRES<0
"RTN","RORHL04",35,0)
 ..S RADPT=$G(^RADPT(RORDFN,"DT",RADTI,"P",RACNI,0)) Q:RADPT=""
"RTN","RORHL04",36,0)
 ..S RAIENS=RACNI_","_RADTI_","_RORDFN_","
"RTN","RORHL04",37,0)
 ..S RORRES=$$OBR(RAIENS,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL04",38,0)
 ;
"RTN","RORHL04",39,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL04",40,0)
 ;
"RTN","RORHL04",41,0)
OBR(RORIEN,RORPTR,RORFILE,HLFS,HLECH) ; OBR SEGMENT (Radiology Data)
"RTN","RORHL04",42,0)
 ;
"RTN","RORHL04",43,0)
 ; INPUT:  RORIEN - IENS of Radiology Record in File #70.03   (Req'd)
"RTN","RORHL04",44,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)     (Opt'l)
"RTN","RORHL04",45,0)
 ;         HLFS - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL04",46,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL04",47,0)
 ;
"RTN","RORHL04",48,0)
 N CS,IEN7002,RACN0,RADTE,RORMSG,ROROUT,RORRES,RORSEG,STR,TMP
"RTN","RORHL04",49,0)
 ;
"RTN","RORHL04",50,0)
 S RORRES=0
"RTN","RORHL04",51,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL04",52,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL04",53,0)
 ;
"RTN","RORHL04",54,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORHL04",55,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL04",56,0)
 S CS=$E(HLECH,1)
"RTN","RORHL04",57,0)
 ;
"RTN","RORHL04",58,0)
 D GETS^DIQ(70.03,RORIEN,".01;2;14","IE","ROROUT","RORMSG")
"RTN","RORHL04",59,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL04",,70.03,RORIEN)
"RTN","RORHL04",60,0)
 S IEN7002=$P(RORIEN,",",2,3)_","
"RTN","RORHL04",61,0)
 D GETS^DIQ(70.02,IEN7002,".01;3","IE","ROROUT","RORMSG")
"RTN","RORHL04",62,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL04",,70.02,IEN7002)
"RTN","RORHL04",63,0)
 ;
"RTN","RORHL04",64,0)
 S $P(RORSEG,HLFS,1)="OBR"
"RTN","RORHL04",65,0)
 ;
"RTN","RORHL04",66,0)
 ; OBR-3 - Unique Accession #
"RTN","RORHL04",67,0)
 S TMP=""
"RTN","RORHL04",68,0)
 S $P(TMP,CS,1)=$P(RORIEN,",",2)_"-"_$P(RORIEN,",",1)
"RTN","RORHL04",69,0)
 S RADTE=$P($G(ROROUT(70.02,IEN7002,.01,"I")),".")
"RTN","RORHL04",70,0)
 S RACN0=$G(ROROUT(70.03,RORIEN,.01,"I"))
"RTN","RORHL04",71,0)
 S $P(TMP,CS,2)=$E(RADTE,4,7)_$E(RADTE,2,3)_"-"_+RACN0
"RTN","RORHL04",72,0)
 S $P(TMP,CS,3)="L"
"RTN","RORHL04",73,0)
 S:$P(TMP,CS)'="" $P(RORSEG,HLFS,4)=TMP
"RTN","RORHL04",74,0)
 ;
"RTN","RORHL04",75,0)
 ; OBR-4 - Procedure & CPT Code
"RTN","RORHL04",76,0)
 S TMP=""
"RTN","RORHL04",77,0)
 S $P(TMP,CS,6)="99RAP"
"RTN","RORHL04",78,0)
 S $P(TMP,CS,5)=$$ESCAPE^RORHL7($G(ROROUT(70.03,RORIEN,2,"E")))
"RTN","RORHL04",79,0)
 S $P(TMP,CS,4)=$G(ROROUT(70.03,RORIEN,2,"I"))
"RTN","RORHL04",80,0)
 S $P(TMP,CS,3)="C4"
"RTN","RORHL04",81,0)
 S $P(TMP,CS,1)=$$GET1^DIQ(71,+$P(TMP,CS,4),9,"I",,"RORMSG")
"RTN","RORHL04",82,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL04",,71,+$P(TMP,CS,4))
"RTN","RORHL04",83,0)
 S STR=$$GET1^DIQ(81,+$P(TMP,CS,1),2,"E")
"RTN","RORHL04",84,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL04",,81,+$P(TMP,CS,1))
"RTN","RORHL04",85,0)
 S $P(TMP,CS,2)=$$ESCAPE^RORHL7(STR)
"RTN","RORHL04",86,0)
 S $P(RORSEG,HLFS,5)=TMP
"RTN","RORHL04",87,0)
 ;
"RTN","RORHL04",88,0)
 ; OBR-7 - Exam Date/Time
"RTN","RORHL04",89,0)
 S TMP=$G(ROROUT(70.02,IEN7002,.01,"I"))
"RTN","RORHL04",90,0)
 S:TMP $P(RORSEG,HLFS,8)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL04",91,0)
 ;
"RTN","RORHL04",92,0)
 ; OBR-16 - Requesting Physician
"RTN","RORHL04",93,0)
 S $P(RORSEG,HLFS,17)=$G(ROROUT(70.03,RORIEN,14,"I"))
"RTN","RORHL04",94,0)
 ;
"RTN","RORHL04",95,0)
 ; OBR-24 - Service Section ID
"RTN","RORHL04",96,0)
 S $P(RORSEG,HLFS,25)="RAD"
"RTN","RORHL04",97,0)
 ;
"RTN","RORHL04",98,0)
 ; OBR-44 - Division
"RTN","RORHL04",99,0)
 S $P(RORSEG,HLFS,45)=$$SITE1^RORUTL03(CS)
"RTN","RORHL04",100,0)
 S TMP=""
"RTN","RORHL04",101,0)
 S $P(TMP,CS,3)=$$GET1^DIQ(4,+$G(ROROUT(70.02,IEN7002,3,"I")),99,"I")
"RTN","RORHL04",102,0)
 S $P(TMP,CS,2)="99VA4"
"RTN","RORHL04",103,0)
 S $P(TMP,CS,1)=$G(ROROUT(70.02,IEN7002,3,"E"))
"RTN","RORHL04",104,0)
 S:$P(TMP,CS,3)]"" $P(RORSEG,HLFS,45)=TMP
"RTN","RORHL04",105,0)
 ;
"RTN","RORHL04",106,0)
 ;--- Store the segment
"RTN","RORHL04",107,0)
 S RORPTR=RORPTR+1
"RTN","RORHL04",108,0)
 S @RORFILE@(RORPTR)=$TR(RORSEG,$C(9,10,13),"   ")
"RTN","RORHL04",109,0)
 ;
"RTN","RORHL04",110,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL04",111,0)
 ;
"RTN","RORHL05")
0^28^B9259613
"RTN","RORHL05",1,0)
RORHL05 ;HOIFO/CRT - Clinical Registries Segment APIs - AUTOPSY ; 5/6/02 1:24pm
"RTN","RORHL05",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHL05",3,0)
 ;
"RTN","RORHL05",4,0)
 ; External reference to LRDFN^LR7OR1 supported by DBIA 2503
"RTN","RORHL05",5,0)
 Q
"RTN","RORHL05",6,0)
 ;
"RTN","RORHL05",7,0)
EN1(RORDFN,RORPTR,RORFILE,HLFS,HLECH) ;
"RTN","RORHL05",8,0)
 ; Search Lab Data for Autopsy Info & Create OBR
"RTN","RORHL05",9,0)
 ;
"RTN","RORHL05",10,0)
 ; INPUT:  RORDFN - DFN of Patient in File #2                 (Req'd)
"RTN","RORHL05",11,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)     (Opt'l)
"RTN","RORHL05",12,0)
 ;         HLFS - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL05",13,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL05",14,0)
 ;
"RTN","RORHL05",15,0)
 N RORIEN,LRDFN,RORRES
"RTN","RORHL05",16,0)
 ;
"RTN","RORHL05",17,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL05",18,0)
 ;
"RTN","RORHL05",19,0)
 S RORRES=0
"RTN","RORHL05",20,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL05",21,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL05",22,0)
 ;
"RTN","RORHL05",23,0)
 S RORDFN=+$G(RORDFN)
"RTN","RORHL05",24,0)
 I '$D(^DPT(RORDFN)) D  Q RORRES
"RTN","RORHL05",25,0)
 .S RORRES=$$ERROR^RORERR(-36,"EN1^RORHL05",,,RORDFN,2)
"RTN","RORHL05",26,0)
 ;
"RTN","RORHL05",27,0)
 S LRDFN=+$$LRDFN^LR7OR1(RORDFN)                           ; DBIA #2503
"RTN","RORHL05",28,0)
 I 'LRDFN Q RORRES
"RTN","RORHL05",29,0)
 ;
"RTN","RORHL05",30,0)
 I $$GET1^DIQ(63,LRDFN,11,"I")'="" D
"RTN","RORHL05",31,0)
 .S RORRES=$$OBR(LRDFN,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL05",32,0)
 ;
"RTN","RORHL05",33,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL05",34,0)
 ;
"RTN","RORHL05",35,0)
OBR(LRDFN,RORPTR,RORFILE,FS,ECH) ; OBR SEGMENT (Autopsy Data)
"RTN","RORHL05",36,0)
 ;
"RTN","RORHL05",37,0)
 ; INPUT:  LRDFN - IEN of Lab Patient Record in File #63      (Req'd)
"RTN","RORHL05",38,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)     (Opt'l)
"RTN","RORHL05",39,0)
 ;         HLFS - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL05",40,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL05",41,0)
 ;
"RTN","RORHL05",42,0)
 N CS,FLDS,RORIEN,RORMSG,ROROUT,RORRES,RORSEG,TMP
"RTN","RORHL05",43,0)
 ;
"RTN","RORHL05",44,0)
 S RORRES=0
"RTN","RORHL05",45,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL05",46,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL05",47,0)
 ;
"RTN","RORHL05",48,0)
 S LRDFN=+$G(LRDFN)_","
"RTN","RORHL05",49,0)
 ;
"RTN","RORHL05",50,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL05",51,0)
 S CS=$E(HLECH,1)
"RTN","RORHL05",52,0)
 ;
"RTN","RORHL05",53,0)
 S FLDS="11;12.1;14;14.1"
"RTN","RORHL05",54,0)
 ;
"RTN","RORHL05",55,0)
 D GETS^DIQ(63,LRDFN,FLDS,"IE","ROROUT","RORMSG")
"RTN","RORHL05",56,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"EN1^RORHL05",,63,LRDFN)
"RTN","RORHL05",57,0)
 ;
"RTN","RORHL05",58,0)
 S $P(RORSEG,HLFS,1)="OBR"
"RTN","RORHL05",59,0)
 ;
"RTN","RORHL05",60,0)
 ; OBR-3 - Order #
"RTN","RORHL05",61,0)
 S $P(RORSEG,HLFS,4)=$G(ROROUT(63,LRDFN,14,"E"))
"RTN","RORHL05",62,0)
 ;
"RTN","RORHL05",63,0)
 ; OBR-4 - CPT Code
"RTN","RORHL05",64,0)
 S TMP=""
"RTN","RORHL05",65,0)
 S $P(TMP,CS,3)="C4"
"RTN","RORHL05",66,0)
 S $P(TMP,CS,1)=88099
"RTN","RORHL05",67,0)
 S $P(TMP,CS,2)=$$ESCAPE^RORHL7($$GET1^DIQ(81,88099,2,"E"))
"RTN","RORHL05",68,0)
 S $P(RORSEG,HLFS,5)=TMP
"RTN","RORHL05",69,0)
 ;
"RTN","RORHL05",70,0)
 ; OBR-7 - Autopsy Date/Time
"RTN","RORHL05",71,0)
 S TMP=$G(ROROUT(63,LRDFN,11,"I"))
"RTN","RORHL05",72,0)
 S:TMP $P(RORSEG,HLFS,8)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL05",73,0)
 ;
"RTN","RORHL05",74,0)
 ; OBR-16 - Ordering Provider
"RTN","RORHL05",75,0)
 S $P(RORSEG,HLFS,17)=$G(ROROUT(63,LRDFN,12.1,"I"))
"RTN","RORHL05",76,0)
 ;
"RTN","RORHL05",77,0)
 ; OBR-24 - Diagnostic Service ID
"RTN","RORHL05",78,0)
 S $P(RORSEG,HLFS,25)="SP"
"RTN","RORHL05",79,0)
 ;
"RTN","RORHL05",80,0)
 ; OBR-44 - Division
"RTN","RORHL05",81,0)
 S $P(RORSEG,HLFS,45)=$$SITE1^RORUTL03(CS)
"RTN","RORHL05",82,0)
 S TMP=""
"RTN","RORHL05",83,0)
 S RORIEN=$G(ROROUT(63,LRDFN,14.1,"I"))
"RTN","RORHL05",84,0)
 I RORIEN]"" D  Q:RORRES<0 RORRES
"RTN","RORHL05",85,0)
 .S RORIEN=+$O(^SC("B",RORIEN,0))
"RTN","RORHL05",86,0)
 .I RORIEN D
"RTN","RORHL05",87,0)
 ..S RORIEN=RORIEN_","
"RTN","RORHL05",88,0)
 ..D GETS^DIQ(44,RORIEN,3,"IE","ROROUT","RORMSG")
"RTN","RORHL05",89,0)
 ..I $G(DIERR)  D  Q
"RTN","RORHL05",90,0)
 ...S RORRES=$$DBS^RORERR("RORMSG",-9,"EN1^RORHL05",,44,RORIEN)
"RTN","RORHL05",91,0)
 ..S $P(TMP,CS,3)=$$GET1^DIQ(4,+$G(ROROUT(44,RORIEN,3,"I")),99,"I")
"RTN","RORHL05",92,0)
 ..S $P(TMP,CS,2)="99VA4"
"RTN","RORHL05",93,0)
 ..S $P(TMP,CS,1)=$G(ROROUT(44,RORIEN,3,"E"))
"RTN","RORHL05",94,0)
 S:$P(TMP,CS,3)]"" $P(RORSEG,HLFS,45)=TMP
"RTN","RORHL05",95,0)
 ;
"RTN","RORHL05",96,0)
 ;--- Store the segment
"RTN","RORHL05",97,0)
 S RORPTR=RORPTR+1
"RTN","RORHL05",98,0)
 S @RORFILE@(RORPTR)=$TR(RORSEG,$C(9,10,13),"   ")
"RTN","RORHL05",99,0)
 ;
"RTN","RORHL05",100,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL05",101,0)
 ;
"RTN","RORHL06")
0^29^B27080892
"RTN","RORHL06",1,0)
RORHL06 ;HOIFO/BH,CRT - Clinical Registries Segment APIs - Liver Biopsy ; 5/6/02 1:25pm
"RTN","RORHL06",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHL06",3,0)
 ;
"RTN","RORHL06",4,0)
 ; External reference to LRDFN^LR7OR1 supported by DBIA 2503
"RTN","RORHL06",5,0)
 Q
"RTN","RORHL06",6,0)
 ;
"RTN","RORHL06",7,0)
EN1(RORDFN,RORSTDT,RORENDT,RORPTR,RORFILE,HLFS,HLECH) ;
"RTN","RORHL06",8,0)
 ; Search Liver Biopsy for Data
"RTN","RORHL06",9,0)
 ;
"RTN","RORHL06",10,0)
 ; INPUT:  RORDFN - DFN of Patient in File #2                 (Req'd)
"RTN","RORHL06",11,0)
 ;         RORSTDT - Start Date (FileMan Format)              (Req'd)
"RTN","RORHL06",12,0)
 ;         RORENDT - End Date   (FileMan Format)              (Req'd)
"RTN","RORHL06",13,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)     (Opt'l)
"RTN","RORHL06",14,0)
 ;         HLFS - Field Separator. Defaults to |              (Opt'l)
"RTN","RORHL06",15,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&      (Opt'l)
"RTN","RORHL06",16,0)
 ;
"RTN","RORHL06",17,0)
 N FLDS,K5,LRDFN,QUIT,RORIEN,RORRES,SPECIMEN
"RTN","RORHL06",18,0)
 ;
"RTN","RORHL06",19,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL06",20,0)
 ;
"RTN","RORHL06",21,0)
 S RORRES=0
"RTN","RORHL06",22,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL06",23,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL06",24,0)
 ;
"RTN","RORHL06",25,0)
 S RORDFN=+$G(RORDFN)
"RTN","RORHL06",26,0)
 I '$D(^DPT(RORDFN)) D  Q RORRES
"RTN","RORHL06",27,0)
 . S RORRES=$$ERROR^RORERR(-36,"EN1^RORHL05",,,RORDFN,2)
"RTN","RORHL06",28,0)
 ;
"RTN","RORHL06",29,0)
 S LRDFN=+$$LRDFN^LR7OR1(RORDFN)                            ; DBIA #2503
"RTN","RORHL06",30,0)
 I 'LRDFN Q RORRES
"RTN","RORHL06",31,0)
 ;
"RTN","RORHL06",32,0)
 S FLDS="1.1;1.4"
"RTN","RORHL06",33,0)
 ;
"RTN","RORHL06",34,0)
 S RORENDT=$$INVDATE^RORUTL01(RORENDT)
"RTN","RORHL06",35,0)
 S RORSTDT=$$INVDATE^RORUTL01(RORSTDT)
"RTN","RORHL06",36,0)
 ;
"RTN","RORHL06",37,0)
 F  S RORENDT=$O(^LR(LRDFN,"SP",RORENDT)) Q:'RORENDT!(RORENDT>RORSTDT)  D  Q:RORRES<0
"RTN","RORHL06",38,0)
 .S K5=0,QUIT=0
"RTN","RORHL06",39,0)
 .F  S K5=$O(^LR(LRDFN,"SP",RORENDT,.1,K5)) Q:'K5  D  Q:QUIT  Q:RORRES<0
"RTN","RORHL06",40,0)
 ..S RORIEN=K5_","_RORENDT_","_LRDFN_","
"RTN","RORHL06",41,0)
 ..S SPECIMEN=$$GET1^DIQ(63.812,RORIEN,.01)
"RTN","RORHL06",42,0)
 ..I $$UP^XLFSTR(SPECIMEN)["LIVER" D
"RTN","RORHL06",43,0)
 ...S RORRES=$$OBR(RORENDT_","_LRDFN_",",.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL06",44,0)
 ...Q:RORRES<0
"RTN","RORHL06",45,0)
 ...S RORRES=$$OBX(RORENDT_","_LRDFN_",",FLDS,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL06",46,0)
 ...Q:RORRES<0
"RTN","RORHL06",47,0)
 ...S QUIT=1
"RTN","RORHL06",48,0)
 ;
"RTN","RORHL06",49,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL06",50,0)
 ;
"RTN","RORHL06",51,0)
OBR(RORIEN,RORPTR,RORFILE,HLFS,HLECH) ; OBR SEGMENT (Liver Biopsy Data)
"RTN","RORHL06",52,0)
 ;
"RTN","RORHL06",53,0)
 ; INPUT:  RORIEN - IENS of Liver Biopsy Record in File #63.08 (Req'd)
"RTN","RORHL06",54,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)      (Opt'l)
"RTN","RORHL06",55,0)
 ;         HLFS - Field Separator. Defaults to |              (Opt'l)
"RTN","RORHL06",56,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&      (Opt'l)
"RTN","RORHL06",57,0)
 ;
"RTN","RORHL06",58,0)
 N CS,FLDS,IEN44,RORMSG,ROROUT,RORRES,RORSEG,TMP
"RTN","RORHL06",59,0)
 ;
"RTN","RORHL06",60,0)
 S RORRES=0
"RTN","RORHL06",61,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL06",62,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL06",63,0)
 ;
"RTN","RORHL06",64,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORHL06",65,0)
 ;
"RTN","RORHL06",66,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL06",67,0)
 S CS=$E(HLECH,1)
"RTN","RORHL06",68,0)
 ;
"RTN","RORHL06",69,0)
 S FLDS=".01;.06;.07;.08"
"RTN","RORHL06",70,0)
 ;
"RTN","RORHL06",71,0)
 D GETS^DIQ(63.08,RORIEN,FLDS,"IE","ROROUT","RORMSG")
"RTN","RORHL06",72,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL06",,63.08,RORIEN)
"RTN","RORHL06",73,0)
 ;
"RTN","RORHL06",74,0)
 S $P(RORSEG,HLFS,1)="OBR"
"RTN","RORHL06",75,0)
 ;
"RTN","RORHL06",76,0)
 ; OBR-3 - Surgical Path Acc #
"RTN","RORHL06",77,0)
 S $P(RORSEG,HLFS,4)=$G(ROROUT(63.08,RORIEN,.06,"E"))
"RTN","RORHL06",78,0)
 ;
"RTN","RORHL06",79,0)
 ; OBR-4 - Liver Biopsy CPT Code
"RTN","RORHL06",80,0)
 S TMP=""
"RTN","RORHL06",81,0)
 S $P(TMP,CS,1)=47000
"RTN","RORHL06",82,0)
 S $P(TMP,CS,2)=$$GET1^DIQ(81,47000,2,"E",,"RORMSG")
"RTN","RORHL06",83,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL06",,81,47000)
"RTN","RORHL06",84,0)
 S $P(TMP,CS,3)="C4"
"RTN","RORHL06",85,0)
 S $P(RORSEG,HLFS,5)=TMP
"RTN","RORHL06",86,0)
 ;
"RTN","RORHL06",87,0)
 ; OBR-7 - Date/Time Specimen Taken
"RTN","RORHL06",88,0)
 S TMP=$G(ROROUT(63.08,RORIEN,.01,"I"))
"RTN","RORHL06",89,0)
 S:TMP $P(RORSEG,HLFS,8)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL06",90,0)
 ;
"RTN","RORHL06",91,0)
 ; OBR-16 - Surgeon/Physican
"RTN","RORHL06",92,0)
 S $P(RORSEG,HLFS,17)=$G(ROROUT(63.08,RORIEN,.07,"I"))
"RTN","RORHL06",93,0)
 ;
"RTN","RORHL06",94,0)
 ; OBR-24 - Service Section ID
"RTN","RORHL06",95,0)
 S $P(RORSEG,HLFS,25)="SP"
"RTN","RORHL06",96,0)
 ;
"RTN","RORHL06",97,0)
 ; OBR-44 - Divsion
"RTN","RORHL06",98,0)
 S $P(RORSEG,HLFS,45)=$$SITE1^RORUTL03(CS)
"RTN","RORHL06",99,0)
 S TMP=""
"RTN","RORHL06",100,0)
 S IEN44=$G(ROROUT(63.08,RORIEN,.08,"E"))
"RTN","RORHL06",101,0)
 I IEN44]"" D  Q:RORRES<0 RORRES
"RTN","RORHL06",102,0)
 .S IEN44=+$O(^SC("B",IEN44,0))
"RTN","RORHL06",103,0)
 .I IEN44 D
"RTN","RORHL06",104,0)
 ..S IEN44=IEN44_","
"RTN","RORHL06",105,0)
 ..D GETS^DIQ(44,IEN44,3,"IE","ROROUT","RORMSG")
"RTN","RORHL06",106,0)
 ..I $G(DIERR)  D  Q
"RTN","RORHL06",107,0)
 ...S RORRES=$$DBS^RORERR("RORMSG",-9,"EN1^RORHL05",,44,IEN44)
"RTN","RORHL06",108,0)
 ..S $P(TMP,CS,3)=$$GET1^DIQ(4,+$G(ROROUT(44,IEN44,3,"I")),99,"I")
"RTN","RORHL06",109,0)
 ..S $P(TMP,CS,2)="99VA4"
"RTN","RORHL06",110,0)
 ..S $P(TMP,CS,1)=$G(ROROUT(44,IEN44,3,"E"))
"RTN","RORHL06",111,0)
 S:$P(TMP,CS,3)]"" $P(RORSEG,HLFS,45)=TMP
"RTN","RORHL06",112,0)
 ;
"RTN","RORHL06",113,0)
 ;--- Store the segment
"RTN","RORHL06",114,0)
 S RORPTR=RORPTR+1
"RTN","RORHL06",115,0)
 S @RORFILE@(RORPTR)=$TR(RORSEG,$C(9,10,13),"   ")
"RTN","RORHL06",116,0)
 ;
"RTN","RORHL06",117,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL06",118,0)
 ;
"RTN","RORHL06",119,0)
OBX(RORIEN,RORFLDS,RORPTR,RORFILE,HLFS,HLECH) ; OBX SEGMENT(S) (Liver Biopsy)
"RTN","RORHL06",120,0)
 ;
"RTN","RORHL06",121,0)
 ; INPUT:  RORIEN - IENS of Liver Biopsy Record in 63.08         (Req'd)
"RTN","RORHL06",122,0)
 ;         RORFLDS - List of WP fields to return as OBX segments (Req'd)
"RTN","RORHL06",123,0)
 ;                   Delimited by ';'    eg. "1.1;1.4"
"RTN","RORHL06",124,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)        (Opt'l)
"RTN","RORHL06",125,0)
 ;         HLFS - Field Separator. Defaults to |                (Opt'l)
"RTN","RORHL06",126,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&        (Opt'l)
"RTN","RORHL06",127,0)
 ;
"RTN","RORHL06",128,0)
 N CNT,CS,FLD,I,PZ,RORMSG,ROROUT,RORRES,RORSEG,SCS,TMP
"RTN","RORHL06",129,0)
 ;
"RTN","RORHL06",130,0)
 S RORRES=0
"RTN","RORHL06",131,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL06",132,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL06",133,0)
 ;
"RTN","RORHL06",134,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORHL06",135,0)
 ;
"RTN","RORHL06",136,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL06",137,0)
 S CS=$E(HLECH),SCS=$E(HLECH,4)
"RTN","RORHL06",138,0)
 ;
"RTN","RORHL06",139,0)
 D GETS^DIQ(63.08,RORIEN,RORFLDS,"IE","ROROUT","RORMSG")
"RTN","RORHL06",140,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBX^RORHL06",,63.08,RORIEN)
"RTN","RORHL06",141,0)
 ;
"RTN","RORHL06",142,0)
 S $P(RORSEG,HLFS,1)="OBX"
"RTN","RORHL06",143,0)
 ;
"RTN","RORHL06",144,0)
 ; OBX-2
"RTN","RORHL06",145,0)
 S $P(RORSEG,HLFS,3)="FT"
"RTN","RORHL06",146,0)
 ;
"RTN","RORHL06",147,0)
 ; OBX-11
"RTN","RORHL06",148,0)
 S $P(RORSEG,HLFS,12)="F"
"RTN","RORHL06",149,0)
 ;
"RTN","RORHL06",150,0)
 F PZ=1:1 S FLD=$P(RORFLDS,";",PZ) Q:FLD=""  D  Q:RORRES<0
"RTN","RORHL06",151,0)
 .S TMP=""
"RTN","RORHL06",152,0)
 .S $P(TMP,SCS,1)=47000
"RTN","RORHL06",153,0)
 .S $P(TMP,SCS,2)=$P($G(^DD(63.08,FLD,0)),"^")
"RTN","RORHL06",154,0)
 .S $P(TMP,CS,2)=$$GET1^DIQ(81,47000,2,"E",,"RORMSG")
"RTN","RORHL06",155,0)
 .I $G(DIERR)  D  Q
"RTN","RORHL06",156,0)
 ..S RORRES=$$DBS^RORERR("RORMSG",-9,"OBX^RORHL06",,81,47000)
"RTN","RORHL06",157,0)
 .S $P(TMP,CS,3)="C4"
"RTN","RORHL06",158,0)
 .S $P(RORSEG,HLFS,4)=TMP
"RTN","RORHL06",159,0)
 .K ^UTILITY($J,"W")
"RTN","RORHL06",160,0)
 .N DIWL,DIWF,DIWR S DIWL=1,DIWR=72
"RTN","RORHL06",161,0)
 .S I=0 F  S I=$O(ROROUT(63.08,RORIEN,FLD,I)) Q:'I  D
"RTN","RORHL06",162,0)
 ..S X=ROROUT(63.08,RORIEN,FLD,I)
"RTN","RORHL06",163,0)
 ..D ^DIWP
"RTN","RORHL06",164,0)
 .S I=0 F  S I=$O(^UTILITY($J,"W",DIWL,I)) Q:'I  D
"RTN","RORHL06",165,0)
 ..S CNT=$G(CNT)+1
"RTN","RORHL06",166,0)
 ..S $P(RORSEG,HLFS,2)=CNT
"RTN","RORHL06",167,0)
 ..S $P(RORSEG,HLFS,6)=$G(^UTILITY($J,"W",DIWL,I,0))
"RTN","RORHL06",168,0)
 ..;
"RTN","RORHL06",169,0)
 ..;--- Store the segment
"RTN","RORHL06",170,0)
 ..S RORPTR=RORPTR+1
"RTN","RORHL06",171,0)
 ..S @RORFILE@(RORPTR)=$TR(RORSEG,$C(9,10,13),"   ")
"RTN","RORHL06",172,0)
 ;
"RTN","RORHL06",173,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL06",174,0)
 ;
"RTN","RORHL07")
0^30^B16116026
"RTN","RORHL07",1,0)
RORHL07 ;HOIFO/BH - Clinical Registries Segment APIs - IP Pharmacy ; 5/6/02 1:25pm
"RTN","RORHL07",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHL07",3,0)
 ;
"RTN","RORHL07",4,0)
 Q
"RTN","RORHL07",5,0)
 ;
"RTN","RORHL07",6,0)
ORC(RORIEN,RORORC,RORPTR,RORFILE,HLFS,HLECH) ; ORC SEGMENT (IP Pharmacy Data)
"RTN","RORHL07",7,0)
 ;
"RTN","RORHL07",8,0)
 ; INPUT:  RORIEN - IEN of Unit/Dose in subfile #55.06        (Req'd)
"RTN","RORHL07",9,0)
 ;         RORORC - Array containing info (from OEL^PSJORRL)  (Req'd)
"RTN","RORHL07",10,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)     (Opt'l)
"RTN","RORHL07",11,0)
 ;         HLFS - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL07",12,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL07",13,0)
 ;
"RTN","RORHL07",14,0)
 N CS,FLDS,IEN42,IEN44,RORMSG,ROROUT,RORRES,RORSEG,TMP
"RTN","RORHL07",15,0)
 ;
"RTN","RORHL07",16,0)
 S RORRES=0
"RTN","RORHL07",17,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL07",18,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL07",19,0)
 ;
"RTN","RORHL07",20,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORHL07",21,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL07",22,0)
 S CS=$E(HLECH,1)
"RTN","RORHL07",23,0)
 ;
"RTN","RORHL07",24,0)
 S $P(RORSEG,HLFS,1)="ORC"
"RTN","RORHL07",25,0)
 ;
"RTN","RORHL07",26,0)
 ; ORC-1 - Order Control 
"RTN","RORHL07",27,0)
 S $P(RORSEG,HLFS,2)="NW"
"RTN","RORHL07",28,0)
 ;
"RTN","RORHL07",29,0)
 ; ORC-2 - Placer Order Number
"RTN","RORHL07",30,0)
 S $P(RORSEG,HLFS,3)=$P(RORIEN,",",1)_CS_"IP"
"RTN","RORHL07",31,0)
 ;
"RTN","RORHL07",32,0)
 ; ORC-12 - Provider
"RTN","RORHL07",33,0)
 S $P(RORSEG,HLFS,13)=$P($G(RORORC("P",0)),"^")
"RTN","RORHL07",34,0)
 ;
"RTN","RORHL07",35,0)
 ; ORC-15 - Order Date/Time
"RTN","RORHL07",36,0)
 S TMP=$P($G(RORORC(0)),"^",5)
"RTN","RORHL07",37,0)
 S:TMP $P(RORSEG,HLFS,16)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL07",38,0)
 ;
"RTN","RORHL07",39,0)
 ; ORC-16 - Control Code Reason
"RTN","RORHL07",40,0)
 S $P(RORSEG,HLFS,17)=CS_CS_CS_CS_"NEW"
"RTN","RORHL07",41,0)
 ;
"RTN","RORHL07",42,0)
 ; ORC-17 - Division
"RTN","RORHL07",43,0)
 S $P(RORSEG,HLFS,18)=$$SITE^RORUTL03(CS)
"RTN","RORHL07",44,0)
 S TMP=""
"RTN","RORHL07",45,0)
 S IEN42=+$G(ROROUT(55.06,RORIEN,9,"I"))
"RTN","RORHL07",46,0)
 I IEN42 D  Q:RORRES<0 RORRES
"RTN","RORHL07",47,0)
 .S IEN44=+$$GET1^DIQ(42,IEN42,44,"I",,"RORMSG")
"RTN","RORHL07",48,0)
 .I $G(DIERR)  D  Q
"RTN","RORHL07",49,0)
 ..S RORRES=$$DBS^RORERR("RORMSG",-9,"ORC^RORHL03",,42,IEN42)
"RTN","RORHL07",50,0)
 .I IEN44 D  Q:RORRES<0
"RTN","RORHL07",51,0)
 ..S IEN44=IEN44_","
"RTN","RORHL07",52,0)
 ..D GETS^DIQ(44,IEN44,3,"IE","ROROUT","RORMSG")
"RTN","RORHL07",53,0)
 ..I $G(DIERR)  D  Q
"RTN","RORHL07",54,0)
 ...S RORRES=$$DBS^RORERR("RORMSG",-9,"ORC^RORHL03",,44,IEN44)
"RTN","RORHL07",55,0)
 ..S $P(TMP,CS,1)=$$GET1^DIQ(4,+$G(ROROUT(44,IEN44,3,"I")),99,"I")
"RTN","RORHL07",56,0)
 ..S $P(TMP,CS,2)=$G(ROROUT(44,IEN44,3,"E"))
"RTN","RORHL07",57,0)
 ..S $P(TMP,CS,3)="99VA4"
"RTN","RORHL07",58,0)
 S:$P(TMP,CS,1)]"" $P(RORSEG,HLFS,18)=TMP
"RTN","RORHL07",59,0)
 ;
"RTN","RORHL07",60,0)
 ;--- Store the segment
"RTN","RORHL07",61,0)
 I $P($G(RORSEG),HLFS,3)]"" D
"RTN","RORHL07",62,0)
 .S RORPTR=RORPTR+1
"RTN","RORHL07",63,0)
 .S @RORFILE@(RORPTR)=$TR(RORSEG,$C(9,10,13),"   ")
"RTN","RORHL07",64,0)
 ;
"RTN","RORHL07",65,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL07",66,0)
 ;
"RTN","RORHL07",67,0)
RXE(RORIEN,RORRXE,RORPTR,RORFILE,HLFS,HLECH) ; RXE SEGMENT (IP Pharmacy Data)
"RTN","RORHL07",68,0)
 ;
"RTN","RORHL07",69,0)
 ; INPUT:  RORIEN - IENS of Pharmacy Record in subfile #55.06 (Req'd)
"RTN","RORHL07",70,0)
 ;         RORRXE - Array containing info (from OEL^PSJORRL)  (Req'd)
"RTN","RORHL07",71,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)     (Opt'l)
"RTN","RORHL07",72,0)
 ;         HLFS - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL07",73,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL07",74,0)
 ;
"RTN","RORHL07",75,0)
 N CS,II,RORMSG,ROROUT,RORRES,TMP
"RTN","RORHL07",76,0)
 ;
"RTN","RORHL07",77,0)
 S RORRES=0
"RTN","RORHL07",78,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL07",79,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL07",80,0)
 ;
"RTN","RORHL07",81,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL07",82,0)
 S CS=$E(HLECH,1)
"RTN","RORHL07",83,0)
 ;
"RTN","RORHL07",84,0)
 Q:$P($G(RORRXE(0)),"^")="" RES
"RTN","RORHL07",85,0)
 ;
"RTN","RORHL07",86,0)
 S II=0 F  S II=$O(RORRXE("DD",II)) Q:II=""  D  Q:RORRES<0
"RTN","RORHL07",87,0)
 .N RORSEG,IDGN,INDF
"RTN","RORHL07",88,0)
 .;
"RTN","RORHL07",89,0)
 .S $P(RORSEG,HLFS,1)="RXE"
"RTN","RORHL07",90,0)
 .;
"RTN","RORHL07",91,0)
 .; RXE-1 - Quantity/Timing
"RTN","RORHL07",92,0)
 .S $P(RORSEG,HLFS,2)=""""""
"RTN","RORHL07",93,0)
 .;
"RTN","RORHL07",94,0)
 .; RXE-2 - Give Code
"RTN","RORHL07",95,0)
 .S IDGN=+$P($G(RORRXE("DD",II,0)),"^")
"RTN","RORHL07",96,0)
 .S:'IDGN IDGN=+$P($G(RORRXE("DD",II,0)),"^",3)
"RTN","RORHL07",97,0)
 .S RORRES=$$RXE2^RORHL03(IDGN,CS,.TMP) Q:RORRES<0
"RTN","RORHL07",98,0)
 .S $P(RORSEG,HLFS,3)=TMP
"RTN","RORHL07",99,0)
 .;
"RTN","RORHL07",100,0)
 .; RXE-3 - Give Amount (Min)
"RTN","RORHL07",101,0)
 .S $P(RORSEG,HLFS,4)=""""""
"RTN","RORHL07",102,0)
 .;
"RTN","RORHL07",103,0)
 .; RXE-5 - Give Units
"RTN","RORHL07",104,0)
 .S INDF=+$$GET1^DIQ(50,IDGN,22,"I",,"RORMSG")_"," ; File #50.68 IEN
"RTN","RORHL07",105,0)
 .I $G(DIERR)  D  Q
"RTN","RORHL07",106,0)
 ..S RORRES=$$DBS^RORERR("RORMSG",-9,"RXE^RORHL03",,50,IDGN)
"RTN","RORHL07",107,0)
 .S TMP=""
"RTN","RORHL07",108,0)
 .D GETS^DIQ(50.68,INDF,3,"IE","ROROUT","RORMSG")
"RTN","RORHL07",109,0)
 .I $G(DIERR)  D  Q
"RTN","RORHL07",110,0)
 ..S RORRES=$$DBS^RORERR("RORMSG",-9,"RXE^RORHL03",,50.68,INDF)
"RTN","RORHL07",111,0)
 .S $P(TMP,CS,4)=$G(ROROUT(50.68,INDF,3,"I"))
"RTN","RORHL07",112,0)
 .S $P(TMP,CS,5)=$G(ROROUT(50.68,INDF,3,"E"))
"RTN","RORHL07",113,0)
 .S $P(TMP,CS,6)="99PSU"
"RTN","RORHL07",114,0)
 .S $P(RORSEG,HLFS,6)=TMP
"RTN","RORHL07",115,0)
 .;
"RTN","RORHL07",116,0)
 .; RXE-18 - Stop Date/Time
"RTN","RORHL07",117,0)
 .S TMP=$P($G(RORRXE(0)),"^",3)
"RTN","RORHL07",118,0)
 .S:TMP $P(RORSEG,HLFS,19)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL07",119,0)
 .;
"RTN","RORHL07",120,0)
 .; RXE-24 - Units per dose
"RTN","RORHL07",121,0)
 .S $P(RORSEG,HLFS,25)=$P($G(RORRXE("DD",II,0)),"^",2)
"RTN","RORHL07",122,0)
 .;
"RTN","RORHL07",123,0)
 .;--- Store the segment
"RTN","RORHL07",124,0)
 .I $G(RORSEG)]"" D
"RTN","RORHL07",125,0)
 ..S RORPTR=RORPTR+1
"RTN","RORHL07",126,0)
 ..S @RORFILE@(RORPTR)=$TR(RORSEG,$C(9,10,13),"   ")
"RTN","RORHL07",127,0)
 ;
"RTN","RORHL07",128,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL07",129,0)
 ;
"RTN","RORHL7")
0^31^B17035317
"RTN","RORHL7",1,0)
RORHL7 ;HCIOFO/SG - HL7 TRANSMISSION ; 4/5/02 8:41am
"RTN","RORHL7",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORHL7",3,0)
 ;
"RTN","RORHL7",4,0)
 Q
"RTN","RORHL7",5,0)
 ;
"RTN","RORHL7",6,0)
 ;***** RETURNS THE BHS SEGMENT
"RTN","RORHL7",7,0)
 ;
"RTN","RORHL7",8,0)
 ; BID           Batch message ID
"RTN","RORHL7",9,0)
 ;
"RTN","RORHL7",10,0)
 ; [BDT]         Batch message creation time in internal FileMan
"RTN","RORHL7",11,0)
 ;               format (NOW by default)
"RTN","RORHL7",12,0)
 ;
"RTN","RORHL7",13,0)
 ; [COMMENT]     Optional comment
"RTN","RORHL7",14,0)
 ;
"RTN","RORHL7",15,0)
 ; The RORHL local variable must be initialized by the $$INIT^RORHL7
"RTN","RORHL7",16,0)
 ; function before calling this entry point.
"RTN","RORHL7",17,0)
 ;
"RTN","RORHL7",18,0)
BHS(BID,BDT,COMMENT) ;
"RTN","RORHL7",19,0)
 N SEG
"RTN","RORHL7",20,0)
 D BHS^HLFNC3(.RORHL,BID,.SEG)
"RTN","RORHL7",21,0)
 Q:$G(SEG)="" ""
"RTN","RORHL7",22,0)
 ;---
"RTN","RORHL7",23,0)
 S SEG=SEG_$G(SEG(1))
"RTN","RORHL7",24,0)
 S:$G(BDT)'>0 BDT=$$NOW^XLFDT
"RTN","RORHL7",25,0)
 S $P(SEG,RORHL("FS"),7)=$$FMTHL7^XLFDT(BDT)
"RTN","RORHL7",26,0)
 S $P(SEG,RORHL("FS"),10)=$G(COMMENT)
"RTN","RORHL7",27,0)
 Q SEG
"RTN","RORHL7",28,0)
 ;
"RTN","RORHL7",29,0)
 ;***** RETURNS BTS SEGMENT
"RTN","RORHL7",30,0)
 ;
"RTN","RORHL7",31,0)
 ; MSGCNT        Batch message count
"RTN","RORHL7",32,0)
 ; [COMMENT]     Batch comment
"RTN","RORHL7",33,0)
 ;
"RTN","RORHL7",34,0)
 ; The RORHL variable must be initialized by the INIT^HLFNC2 before
"RTN","RORHL7",35,0)
 ; calling this entry point
"RTN","RORHL7",36,0)
 ;
"RTN","RORHL7",37,0)
BTS(MSGCNT,COMMENT) ;
"RTN","RORHL7",38,0)
 Q "BTS"_RORHL("FS")_MSGCNT_RORHL("FS")_$G(COMMENT)
"RTN","RORHL7",39,0)
 ;
"RTN","RORHL7",40,0)
 ;***** CREATES A NEW MESSAGE IN THE BATCH
"RTN","RORHL7",41,0)
 ;
"RTN","RORHL7",42,0)
 ; The function adds a new message header to the batch. If the batch
"RTN","RORHL7",43,0)
 ; does not exist yet, it is created.
"RTN","RORHL7",44,0)
 ;
"RTN","RORHL7",45,0)
 ; [.RORMSH]     Reference to a variable in what a MSH segment of
"RTN","RORHL7",46,0)
 ;               the message is returned.
"RTN","RORHL7",47,0)
 ;
"RTN","RORHL7",48,0)
 ; Return Values:
"RTN","RORHL7",49,0)
 ;        <0  Error Code
"RTN","RORHL7",50,0)
 ;        >0  Index of a subnode of the ^TMP("HLS",$J) that
"RTN","RORHL7",51,0)
 ;            contains the new MSH segment.
"RTN","RORHL7",52,0)
 ;
"RTN","RORHL7",53,0)
 ; MSH segment is returned as a value of the RORMSH parameter. In case
"RTN","RORHL7",54,0)
 ; of a long segment, continuations are returned as subnodes.
"RTN","RORHL7",55,0)
 ;
"RTN","RORHL7",56,0)
 ; Several nodes (HL7*) in ROREXT are set and the ^TMP("HLS",$J) node
"RTN","RORHL7",57,0)
 ; is deleted by this entry point before it creates a new batch.
"RTN","RORHL7",58,0)
 ;
"RTN","RORHL7",59,0)
CREATE(RORMSH) ;
"RTN","RORHL7",60,0)
 N NDX,RC,TMP  K RORMSH
"RTN","RORHL7",61,0)
 Q:$G(ROREXT("HL7PROT"))="" $$ERROR^RORERR(-25,"CREATE^RORHL7")
"RTN","RORHL7",62,0)
 ;--- Create a message stub for the new batch message
"RTN","RORHL7",63,0)
 ;    (if it has not been created before)
"RTN","RORHL7",64,0)
 I '$G(ROREXT("HL7MTIEN"))  D  Q:$G(RC)<0 RC
"RTN","RORHL7",65,0)
 . N RORMID,RORIEN,RORDT
"RTN","RORHL7",66,0)
 . ;--- Set up HL7 environment variables
"RTN","RORHL7",67,0)
 . D INIT^HLFNC2(ROREXT("HL7PROT"),.RORHL)
"RTN","RORHL7",68,0)
 . I $G(RORHL)  S RC=$$ERROR^RORERR(-23,"CREATE^RORHL7",RORHL)  Q
"RTN","RORHL7",69,0)
 . ;--- Create a stub
"RTN","RORHL7",70,0)
 . D CREATE^HLTF(.RORMID,.RORIEN,.RORDT)
"RTN","RORHL7",71,0)
 . ;--- Save parameters of the new batch message
"RTN","RORHL7",72,0)
 . S ROREXT("HL7CNT")=0
"RTN","RORHL7",73,0)
 . S ROREXT("HL7DT")=RORDT
"RTN","RORHL7",74,0)
 . S ROREXT("HL7MID")=RORMID
"RTN","RORHL7",75,0)
 . S ROREXT("HL7MTIEN")=RORIEN
"RTN","RORHL7",76,0)
 . ;--- Initialize temporary storage
"RTN","RORHL7",77,0)
 . K ^TMP("HLS",$J)
"RTN","RORHL7",78,0)
 ;--- Initialize the HL7 environment variables
"RTN","RORHL7",79,0)
 D INIT^HLFNC2(ROREXT("HL7PROT"),.RORHL)
"RTN","RORHL7",80,0)
 Q:$G(RORHL) $$ERROR^RORERR(-23,"CREATE^RORHL7",RORHL)
"RTN","RORHL7",81,0)
 ;--- Create and store a MSH segment for individual message
"RTN","RORHL7",82,0)
 S ROREXT("HL7CNT")=ROREXT("HL7CNT")+1
"RTN","RORHL7",83,0)
 S TMP=ROREXT("HL7MID")_"-"_ROREXT("HL7CNT")
"RTN","RORHL7",84,0)
 D MSH^HLFNC2(.RORHL,TMP,.RORMSH)
"RTN","RORHL7",85,0)
 S NDX=$O(^TMP("HLS",$J,""),-1)+1
"RTN","RORHL7",86,0)
 M ^TMP("HLS",$J,NDX)=RORMSH
"RTN","RORHL7",87,0)
 Q NDX
"RTN","RORHL7",88,0)
 ;
"RTN","RORHL7",89,0)
 ;***** REPLACES ENCODING CHARACTERS WITH ESCAPE CODES
"RTN","RORHL7",90,0)
 ;
"RTN","RORHL7",91,0)
 ; STR           Source string
"RTN","RORHL7",92,0)
 ;
"RTN","RORHL7",93,0)
 ; The HLECH variable must be initialized (either by the INIT^HLFNC2
"RTN","RORHL7",94,0)
 ; or manually) before calling this function.
"RTN","RORHL7",95,0)
 ;
"RTN","RORHL7",96,0)
 ; The function returns the source string with encoding
"RTN","RORHL7",97,0)
 ; characters replaced with corresponding escape codes.
"RTN","RORHL7",98,0)
 ;
"RTN","RORHL7",99,0)
ESCAPE(STR) ;
"RTN","RORHL7",100,0)
 Q:STR="" STR
"RTN","RORHL7",101,0)
 N BUF,ESC,CH,I1,I2
"RTN","RORHL7",102,0)
 ;--- Find all occurences of encoding characters and
"RTN","RORHL7",103,0)
 ;    save their positions to a local array
"RTN","RORHL7",104,0)
 F I1=1:1:4  D
"RTN","RORHL7",105,0)
 . S CH=$E(HLECH,I1),I2=1
"RTN","RORHL7",106,0)
 . F  S I2=$F(STR,CH,I2)  Q:'I2  S BUF(I2-1)=I1
"RTN","RORHL7",107,0)
 Q:$D(BUF)<10 STR
"RTN","RORHL7",108,0)
 ;--- Replace encoding characters with escape codes
"RTN","RORHL7",109,0)
 S (BUF,I2)="",ESC=$E(HLECH,3)  S:ESC="" ESC="\"
"RTN","RORHL7",110,0)
 F  S I1=I2,I2=$O(BUF(I2))  Q:I2=""  D
"RTN","RORHL7",111,0)
 . S BUF=BUF_$E(STR,I1+1,I2-1)_ESC_$E("SRET",BUF(I2))_ESC
"RTN","RORHL7",112,0)
 Q BUF_$E(STR,I1+1,$L(STR))
"RTN","RORHL7",113,0)
 ;
"RTN","RORHL7",114,0)
 ;***** INITIALIZES RORHL ARRAY WITH HL7 ENVIRONMENT PARAMETERS
"RTN","RORHL7",115,0)
INIT() ;
"RTN","RORHL7",116,0)
 K RORHL  D INIT^HLFNC2(ROREXT("HL7PROT"),.RORHL)
"RTN","RORHL7",117,0)
 Q $S($G(RORHL):$$ERROR^RORERR(-23,"INIT^RORHL7",RORHL),1:0)
"RTN","RORHL7",118,0)
 ;
"RTN","RORHL7",119,0)
 ;***** RETURNS NUMBER OF MESSAGES IN THE CURRENT BATCH
"RTN","RORHL7",120,0)
MSGCNT() ;
"RTN","RORHL7",121,0)
 Q $G(ROREXT("HL7CNT"))
"RTN","RORHL7",122,0)
 ;
"RTN","RORHL7",123,0)
 ;***** DELETES AN INCOMPLETE MESSAGE FROM THE ^TMP("HLS",$J)
"RTN","RORHL7",124,0)
 ;
"RTN","RORHL7",125,0)
 ; MSHPTR        An index of the MSH segment in the ^TMP("HLS",$J)
"RTN","RORHL7",126,0)
 ;
"RTN","RORHL7",127,0)
ROLLBACK(MSHPTR) ;
"RTN","RORHL7",128,0)
 N I  S I=+MSHPTR
"RTN","RORHL7",129,0)
 F  Q:I=""  K ^TMP("HLS",$J,I)  S I=$O(^TMP("HLS",$J,I))
"RTN","RORHL7",130,0)
 S:$G(ROREXT("HL7CNT"))>0 ROREXT("HL7CNT")=ROREXT("HL7CNT")-1
"RTN","RORHL7",131,0)
 Q
"RTN","RORHL7",132,0)
 ;
"RTN","RORHL7",133,0)
 ;***** SENDS THE BATCH MESSAGE
"RTN","RORHL7",134,0)
 ;
"RTN","RORHL7",135,0)
 ; .MID          Reference to a local variable where the batch
"RTN","RORHL7",136,0)
 ;               message ID (returned by the GENERATE^HLMA) is
"RTN","RORHL7",137,0)
 ;               returned to.
"RTN","RORHL7",138,0)
 ;
"RTN","RORHL7",139,0)
 ; Return Values:
"RTN","RORHL7",140,0)
 ;        <0  Error Code
"RTN","RORHL7",141,0)
 ;         0  Ok
"RTN","RORHL7",142,0)
 ;        >0  There was nothing to send
"RTN","RORHL7",143,0)
 ;
"RTN","RORHL7",144,0)
 ; Several nodes (HL7*) in the ROREXT and the ^TMP("HLS",$J) node
"RTN","RORHL7",145,0)
 ; are deleted by this entry point.
"RTN","RORHL7",146,0)
 ;
"RTN","RORHL7",147,0)
SEND(MID) ;
"RTN","RORHL7",148,0)
 N RC,RORBUF  S MID=""
"RTN","RORHL7",149,0)
 Q:$G(ROREXT("HL7PROT"))="" $$ERROR^RORERR(-25,"SEND^RORHL7")
"RTN","RORHL7",150,0)
 ;--- Quit if there is nothing to send
"RTN","RORHL7",151,0)
 Q:'$G(ROREXT("HL7MTIEN"))!($D(^TMP("HLS",$J))<10) 1
"RTN","RORHL7",152,0)
 ;--- Set up the HL7 environment variables
"RTN","RORHL7",153,0)
 D INIT^HLFNC2(ROREXT("HL7PROT"),.RORHL)
"RTN","RORHL7",154,0)
 Q:$G(RORHL) $$ERROR^RORERR(-23,"SEND^RORHL7",RORHL)
"RTN","RORHL7",155,0)
 ;--- Send the message
"RTN","RORHL7",156,0)
 D GENERATE^HLMA(ROREXT("HL7PROT"),"GB",1,.RORBUF,ROREXT("HL7MTIEN"))
"RTN","RORHL7",157,0)
 ;D DIRECT^HLMA(ROREXT("HL7PROT"),"GB",1,.RORBUF,ROREXT("HL7MTIEN"))
"RTN","RORHL7",158,0)
 S RC=$S($P(RORBUF,U,2):$$ERROR^RORERR(-24,"SEND^RORHL7",RORBUF),1:0)
"RTN","RORHL7",159,0)
 S MID=$P(RORBUF,U)
"RTN","RORHL7",160,0)
 ;--- Cleanup if there is no error or not in debug mode
"RTN","RORHL7",161,0)
 D:'$G(RORPARM("DEBUG"))!(RC'<0)
"RTN","RORHL7",162,0)
 . F TMP="HL7CNT","HL7DT","HL7MTIEN"  K ROREXT(TMP)
"RTN","RORHL7",163,0)
 . K ^TMP("HLS",$J)
"RTN","RORHL7",164,0)
 Q RC
"RTN","RORKIDS")
0^32^B14852443
"RTN","RORKIDS",1,0)
RORKIDS ;HCIOFO/SG - INSTALL UTILITIES (LOW-LEVEL) ; 5/6/02 3:10pm
"RTN","RORKIDS",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORKIDS",3,0)
 ;
"RTN","RORKIDS",4,0)
 Q
"RTN","RORKIDS",5,0)
 ;
"RTN","RORKIDS",6,0)
 ;***** DISPLAYS THE MESSAGE IF THE INSTALLATION ABORTS
"RTN","RORKIDS",7,0)
ABTMSG() ;
"RTN","RORKIDS",8,0)
 N INFO,MODE
"RTN","RORKIDS",9,0)
 S MODE=+$G(RORPARM("KIDS"))
"RTN","RORKIDS",10,0)
 S MODE=$S(MODE=1:"pre-install",MODE=2:"post-install",1:"")
"RTN","RORKIDS",11,0)
 Q:MODE=""
"RTN","RORKIDS",12,0)
 S INFO(1)="Fix the error(s) and restart the installation."
"RTN","RORKIDS",13,0)
 D BMES("Fatal error(s) during the registry "_MODE_"!",.INFO)
"RTN","RORKIDS",14,0)
 Q
"RTN","RORKIDS",15,0)
 ;
"RTN","RORKIDS",16,0)
 ;***** SENDS AN ALERT
"RTN","RORKIDS",17,0)
 ;
"RTN","RORKIDS",18,0)
 ; DUZ           DUZ of the addressee
"RTN","RORKIDS",19,0)
 ;
"RTN","RORKIDS",20,0)
 ; MSG           Text of the message or negative error code. The '^'
"RTN","RORKIDS",21,0)
 ;               characters are replaced with spaces in the text.
"RTN","RORKIDS",22,0)
 ;
"RTN","RORKIDS",23,0)
 ; [REGNAME]     Registry name
"RTN","RORKIDS",24,0)
 ;
"RTN","RORKIDS",25,0)
 ; [PATIEN]      Patient IEN
"RTN","RORKIDS",26,0)
 ;
"RTN","RORKIDS",27,0)
 ; [ARG2-ARG5]   Optional parameters as for $$ERROR^RORERR
"RTN","RORKIDS",28,0)
 ;
"RTN","RORKIDS",29,0)
ALERT(DUZ,MSG,REGNAME,PATIEN,ARG2,ARG3,ARG4,ARG5) ;
"RTN","RORKIDS",30,0)
 Q:'$G(DUZ)
"RTN","RORKIDS",31,0)
 N XQA,XQADATA,XQAFLG,XQAMSG,XQAROU,TMP
"RTN","RORKIDS",32,0)
 S XQA(DUZ)=""
"RTN","RORKIDS",33,0)
 ;--- Get text of the error message
"RTN","RORKIDS",34,0)
 I +MSG=MSG  Q:MSG'<0  D
"RTN","RORKIDS",35,0)
 . S MSG=$$MSG^RORERR20(+MSG,,.PATIEN,.ARG2,.ARG3,.ARG4,.ARG5)
"RTN","RORKIDS",36,0)
 S MSG=$TR(MSG,"^"," "),XQAMSG="ROR: ",TMP=70-$L(XQAMSG)-3
"RTN","RORKIDS",37,0)
 S XQAMSG=XQAMSG_$S($L(MSG)>TMP:$E(MSG,1,TMP)_"...",1:MSG)
"RTN","RORKIDS",38,0)
 ;--- Setup alert processing routine
"RTN","RORKIDS",39,0)
 S $P(XQADATA,U,1)=$E(MSG,1,78)
"RTN","RORKIDS",40,0)
 S $P(XQADATA,U,2)=$G(REGNAME)
"RTN","RORKIDS",41,0)
 S $P(XQADATA,U,3)=$G(PATIEN)
"RTN","RORKIDS",42,0)
 S XQAROU="ALERTRTN^RORKIDS"
"RTN","RORKIDS",43,0)
 ;--- Send the alert
"RTN","RORKIDS",44,0)
 S XQAFLG="D"  D SETUP^XQALERT
"RTN","RORKIDS",45,0)
 Q
"RTN","RORKIDS",46,0)
 ;
"RTN","RORKIDS",47,0)
 ;***** ALERT PROCESSING ROUTINE
"RTN","RORKIDS",48,0)
 ;
"RTN","RORKIDS",49,0)
 ; XQADATA       Alert data
"RTN","RORKIDS",50,0)
 ;                 ^1: Message
"RTN","RORKIDS",51,0)
 ;                 ^2: Registry name
"RTN","RORKIDS",52,0)
 ;                 ^3: Patient DFN
"RTN","RORKIDS",53,0)
 ;
"RTN","RORKIDS",54,0)
ALERTRTN ;
"RTN","RORKIDS",55,0)
 ;;Registry Name:
"RTN","RORKIDS",56,0)
 ;;Patient DFN:
"RTN","RORKIDS",57,0)
 ;
"RTN","RORKIDS",58,0)
 Q:$G(XQADATA)=""
"RTN","RORKIDS",59,0)
 N I,TMP
"RTN","RORKIDS",60,0)
 W !!,$P(XQADATA,"^"),!
"RTN","RORKIDS",61,0)
 F I=1:1:2  S TMP=$P(XQADATA,"^",I+1)  D:TMP'=""
"RTN","RORKIDS",62,0)
 . W $P($T(ALERTRTN+I),";;",2),?15,TMP,!
"RTN","RORKIDS",63,0)
 Q
"RTN","RORKIDS",64,0)
 ;
"RTN","RORKIDS",65,0)
 ;***** OUTPUTS THE MESSAGE AND PUTS IT INTO THE LOG
"RTN","RORKIDS",66,0)
BMES(MSG,INFO) ;
"RTN","RORKIDS",67,0)
 N I
"RTN","RORKIDS",68,0)
 D BMES^XPDUTL("   "_MSG)
"RTN","RORKIDS",69,0)
 S I=""
"RTN","RORKIDS",70,0)
 F  S I=$O(INFO(I))  Q:I=""  D MES^XPDUTL("   "_INFO(I))
"RTN","RORKIDS",71,0)
 D LOG^RORLOG(,MSG,,.INFO)
"RTN","RORKIDS",72,0)
 Q
"RTN","RORKIDS",73,0)
 ;
"RTN","RORKIDS",74,0)
 ;***** PROCESSES THE INSTALL CHECKPOINT
"RTN","RORKIDS",75,0)
 ;
"RTN","RORKIDS",76,0)
 ; CPNAME        Checkpoint name
"RTN","RORKIDS",77,0)
 ;
"RTN","RORKIDS",78,0)
 ; CALLBACK      Callback entry point ($$TAG^ROUTINE). This function
"RTN","RORKIDS",79,0)
 ;               accepts no parameters and must return either 0 if
"RTN","RORKIDS",80,0)
 ;               everything is Ok or a negative error code.
"RTN","RORKIDS",81,0)
 ;
"RTN","RORKIDS",82,0)
 ; [PARAM]       Value to set checkpoint parameter to.
"RTN","RORKIDS",83,0)
 ;
"RTN","RORKIDS",84,0)
 ; The function checks if the checkpoint is completed. If it is not,
"RTN","RORKIDS",85,0)
 ; the callback entry point is XECUTEd. If everything is Ok, the
"RTN","RORKIDS",86,0)
 ; function will complete the checkpoint.
"RTN","RORKIDS",87,0)
 ;
"RTN","RORKIDS",88,0)
 ; Return Values:
"RTN","RORKIDS",89,0)
 ;       <0  Error code
"RTN","RORKIDS",90,0)
 ;        0  Ok
"RTN","RORKIDS",91,0)
 ;
"RTN","RORKIDS",92,0)
CP(CPNAME,CALLBACK,PARAM) ;
"RTN","RORKIDS",93,0)
 N RC
"RTN","RORKIDS",94,0)
 ;--- Verify the checkpoint and quit if it is completed
"RTN","RORKIDS",95,0)
 S RC=$$VERCP^XPDUTL(CPNAME)  Q:RC>0 0
"RTN","RORKIDS",96,0)
 ;--- Create the new checkpoint
"RTN","RORKIDS",97,0)
 I RC<0  D  Q:'RC $$ERROR^RORERR(-50,"CP^RORKIDS",,,CPNAME)
"RTN","RORKIDS",98,0)
 . S RC=$$NEWCP^XPDUTL(CPNAME,,.PARAM)
"RTN","RORKIDS",99,0)
 ;--- Reset the KIDS progress bar
"RTN","RORKIDS",100,0)
 S XPDIDTOT=0  D UPDATE^XPDID(0)
"RTN","RORKIDS",101,0)
 ;--- Execute the callback entry point
"RTN","RORKIDS",102,0)
 X "S RC="_CALLBACK  Q:RC<0 RC
"RTN","RORKIDS",103,0)
 ;--- Complete the check point
"RTN","RORKIDS",104,0)
 S RC=$$COMCP^XPDUTL(CPNAME)
"RTN","RORKIDS",105,0)
 Q:'RC $$ERROR^RORERR(-51,"CP^RORKIDS",,,CPNAME)
"RTN","RORKIDS",106,0)
 Q 0
"RTN","RORKIDS",107,0)
 ;
"RTN","RORKIDS",108,0)
 ;***** DELETES THE (SUB)FILE DD AND DATA (IF REQUESTED)
"RTN","RORKIDS",109,0)
 ;
"RTN","RORKIDS",110,0)
 ; FILE          File number
"RTN","RORKIDS",111,0)
 ;
"RTN","RORKIDS",112,0)
 ; [FLAGS]       String that contains flags for EN^DIU2:
"RTN","RORKIDS",113,0)
 ;                 "D"  Delete the data as well as the DD
"RTN","RORKIDS",114,0)
 ;                 "E"  Echo back information during deletion
"RTN","RORKIDS",115,0)
 ;                 "S"  Subfile data dictionary is to be deleted
"RTN","RORKIDS",116,0)
 ;                 "T"  Templates are to be deleted
"RTN","RORKIDS",117,0)
 ;
"RTN","RORKIDS",118,0)
 ; [SILENT]      If this parameters is defined and non-zero, the
"RTN","RORKIDS",119,0)
 ;               function will work in "silent" mode.
"RTN","RORKIDS",120,0)
 ;               Nothing (except error messages if debug mode >1 is
"RTN","RORKIDS",121,0)
 ;               enabled) will be displayed on the console or stored
"RTN","RORKIDS",122,0)
 ;               into the INSTALLATION file.
"RTN","RORKIDS",123,0)
 ;
"RTN","RORKIDS",124,0)
 ; Return Values:
"RTN","RORKIDS",125,0)
 ;       <0  Error code
"RTN","RORKIDS",126,0)
 ;        0  Ok
"RTN","RORKIDS",127,0)
 ;
"RTN","RORKIDS",128,0)
DELFILE(FILE,FLAGS,SILENT) ;
"RTN","RORKIDS",129,0)
 Q:'$$VFILE^DILFD(+FILE) 0
"RTN","RORKIDS",130,0)
 N DIU,FT,RC
"RTN","RORKIDS",131,0)
 S DIU=+FILE,DIU(0)=$G(FLAGS)
"RTN","RORKIDS",132,0)
 I '$G(SILENT)  D
"RTN","RORKIDS",133,0)
 . S FT=$S(DIU(0)["S":"subfile",1:"file")
"RTN","RORKIDS",134,0)
 . D BMES("Deleting the "_FT_" #"_(+FILE)_"...")
"RTN","RORKIDS",135,0)
 D EN^DIU2
"RTN","RORKIDS",136,0)
 D:'$G(SILENT) MES("The "_FT_" has been deleted.")
"RTN","RORKIDS",137,0)
 Q 0
"RTN","RORKIDS",138,0)
 ;
"RTN","RORKIDS",139,0)
 ;***** DELETES FIELD DEFENITIONS FROM THE DD
"RTN","RORKIDS",140,0)
 ;
"RTN","RORKIDS",141,0)
 ; FILE          File number
"RTN","RORKIDS",142,0)
 ;
"RTN","RORKIDS",143,0)
 ; FLDLST        String that contains list of field numbers to
"RTN","RORKIDS",144,0)
 ;               delete (separated with the ';').
"RTN","RORKIDS",145,0)
 ;
"RTN","RORKIDS",146,0)
 ; [SILENT]      If this parameters is defined and non-zero, the
"RTN","RORKIDS",147,0)
 ;               function will work in "silent" mode.
"RTN","RORKIDS",148,0)
 ;               Nothing (except error messages if debug mode >1 is
"RTN","RORKIDS",149,0)
 ;               enabled) will be displayed on the console or stored
"RTN","RORKIDS",150,0)
 ;               into the INSTALLATION file.
"RTN","RORKIDS",151,0)
 ;
"RTN","RORKIDS",152,0)
 ; Return Values:
"RTN","RORKIDS",153,0)
 ;       <0  Error code
"RTN","RORKIDS",154,0)
 ;        0  Ok
"RTN","RORKIDS",155,0)
 ;
"RTN","RORKIDS",156,0)
DELFLDS(FILE,FLDLST,SILENT) ;
"RTN","RORKIDS",157,0)
 Q:'$$VFILE^DILFD(+FILE) 0
"RTN","RORKIDS",158,0)
 N DA,DIK,I,RC,ROOT
"RTN","RORKIDS",159,0)
 D:'$G(SILENT)
"RTN","RORKIDS",160,0)
 . D BMES("Deleting the field definitions...")
"RTN","RORKIDS",161,0)
 . D MES("File #"_(+FILE)_", Fields: '"_FLDLST_"'")
"RTN","RORKIDS",162,0)
 S DA(1)=+FILE,DIK="^DD("_DA(1)_","
"RTN","RORKIDS",163,0)
 F I=1:1  S DA=$P(FLDLST,";",I)  Q:'DA  D ^DIK
"RTN","RORKIDS",164,0)
 D:'$G(SILENT) MES("The definitions have been deleted.")
"RTN","RORKIDS",165,0)
 Q 0
"RTN","RORKIDS",166,0)
 ;
"RTN","RORKIDS",167,0)
 ;***** OUTPUTS THE MESSAGE AND PUTS IT INTO THE LOG
"RTN","RORKIDS",168,0)
MES(MSG,INFO) ;
"RTN","RORKIDS",169,0)
 N I
"RTN","RORKIDS",170,0)
 D MES^XPDUTL("   "_MSG)
"RTN","RORKIDS",171,0)
 S I=""
"RTN","RORKIDS",172,0)
 F  S I=$O(INFO(I))  Q:I=""  D MES^XPDUTL("   "_INFO(I))
"RTN","RORKIDS",173,0)
 D LOG^RORLOG(,MSG,,.INFO)
"RTN","RORKIDS",174,0)
 Q
"RTN","RORKIDS",175,0)
 ;
"RTN","RORKIDS",176,0)
 ;***** RETURNS A VALUE OF THE INSTALLATION PARAMETER
"RTN","RORKIDS",177,0)
 ;
"RTN","RORKIDS",178,0)
 ; NAME          Name of the parameter
"RTN","RORKIDS",179,0)
 ;
"RTN","RORKIDS",180,0)
PARAM(NAME) ;
"RTN","RORKIDS",181,0)
 Q $G(RORPARM("KIDS",NAME))
"RTN","RORLOG")
0^33^B38793443
"RTN","RORLOG",1,0)
RORLOG ;HCIOFO/SG - LOG FILE MANAGEMENT ; 3/29/02 10:49am
"RTN","RORLOG",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORLOG",3,0)
 ;
"RTN","RORLOG",4,0)
 ; RORLOG -------------- CONSTANT & VARIABLES OF THE LOG SUSBSYSTEM
"RTN","RORLOG",5,0)
 ;
"RTN","RORLOG",6,0)
 ; RORLOG("IEN")         IEN of the main record in the ROR LOG file
"RTN","RORLOG",7,0)
 ;
"RTN","RORLOG",8,0)
 Q
"RTN","RORLOG",9,0)
 ;
"RTN","RORLOG",10,0)
 ;***** CLOSES THE CURRENT LOG
"RTN","RORLOG",11,0)
 ;
"RTN","RORLOG",12,0)
 ; [MESSAGE]     Text of the final message
"RTN","RORLOG",13,0)
 ; [COUNTERS]    Statistic counters
"RTN","RORLOG",14,0)
 ;                 ^1: Total number of processed patients
"RTN","RORLOG",15,0)
 ;                 ^2: Number of patients processed with errors
"RTN","RORLOG",16,0)
 ;
"RTN","RORLOG",17,0)
CLOSE(MESSAGE,COUNTERS) ;
"RTN","RORLOG",18,0)
 Q:$G(RORLOG("IEN"))'>0
"RTN","RORLOG",19,0)
 N BDT,EDT,IENS,RATE,RORFDA,RORINFO,RORMSG,TMP
"RTN","RORLOG",20,0)
 S EDT=$$NOW^XLFDT
"RTN","RORLOG",21,0)
 S IENS=RORLOG("IEN")_","
"RTN","RORLOG",22,0)
 ;--- Prepare statistic data
"RTN","RORLOG",23,0)
 D:$G(COUNTERS)>0
"RTN","RORLOG",24,0)
 . S RORINFO(1)="Patients:     "_+$P(COUNTERS,U)
"RTN","RORLOG",25,0)
 . S RORINFO(2)="Errors:       "_+$P(COUNTERS,U,2)
"RTN","RORLOG",26,0)
 . S BDT=$$GET1^DIQ(798.7,IENS,.01,"I",,"RORMSG")
"RTN","RORLOG",27,0)
 . Q:$G(BDT)'>0
"RTN","RORLOG",28,0)
 . S TMP=$$FMDIFF^XLFDT(EDT,BDT,2)
"RTN","RORLOG",29,0)
 . S RATE=$S(TMP>0:$J(COUNTERS/TMP,0,3),1:"")
"RTN","RORLOG",30,0)
 . S RORINFO(3)="Time (sec):   "_TMP
"RTN","RORLOG",31,0)
 . S:RATE RORINFO(4)="Patients/sec: "_RATE
"RTN","RORLOG",32,0)
 . ;--- Data for the log header
"RTN","RORLOG",33,0)
 . S RORFDA(798.7,IENS,6.01)=$P(COUNTERS,U,1)
"RTN","RORLOG",34,0)
 . S RORFDA(798.7,IENS,6.02)=$P(COUNTERS,U,2)
"RTN","RORLOG",35,0)
 . S:RATE RORFDA(798.7,IENS,6.03)=RATE
"RTN","RORLOG",36,0)
 ;--- Store data in the header and log the final message (if any)
"RTN","RORLOG",37,0)
 S RORFDA(798.7,IENS,5)=EDT
"RTN","RORLOG",38,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORLOG",39,0)
 D:$G(MESSAGE)'="" LOG^RORLOG(,MESSAGE,,.RORINFO)
"RTN","RORLOG",40,0)
 K RORLOG
"RTN","RORLOG",41,0)
 Q
"RTN","RORLOG",42,0)
 ;
"RTN","RORLOG",43,0)
 ;***** PUTS MESSAGE IN THE LOG
"RTN","RORLOG",44,0)
 ;
"RTN","RORLOG",45,0)
 ; [TYPE]        Type of the event:
"RTN","RORLOG",46,0)
 ;                 1  Debug
"RTN","RORLOG",47,0)
 ;                 2  Information
"RTN","RORLOG",48,0)
 ;                 3  Data quality
"RTN","RORLOG",49,0)
 ;                 4  Warning
"RTN","RORLOG",50,0)
 ;                 5  Database error
"RTN","RORLOG",51,0)
 ;                 6  Error
"RTN","RORLOG",52,0)
 ;
"RTN","RORLOG",53,0)
 ;       If value of the parameter is omitted or equals 0, the message
"RTN","RORLOG",54,0)
 ;       is logged as "information" (if log is enabled). This mode is
"RTN","RORLOG",55,0)
 ;       intended for log headers and separators.
"RTN","RORLOG",56,0)
 ;
"RTN","RORLOG",57,0)
 ; MESSAGE       Message text
"RTN","RORLOG",58,0)
 ; [PATIEN]      Patient IEN
"RTN","RORLOG",59,0)
 ;
"RTN","RORLOG",60,0)
 ; [[.]RORINFO]  Optional additional information (either a string or
"RTN","RORLOG",61,0)
 ;               a reference to a local array that contains strings
"RTN","RORLOG",62,0)
 ;               prepared for storing in a word processing field)
"RTN","RORLOG",63,0)
 ;
"RTN","RORLOG",64,0)
LOG(TYPE,MESSAGE,PATIEN,RORINFO) ;
"RTN","RORLOG",65,0)
 ;--- Do not do anything if log is disabled
"RTN","RORLOG",66,0)
 Q:'$G(RORPARM("LOG"))
"RTN","RORLOG",67,0)
 ;--- Check if collection of this kind of event is enabled.
"RTN","RORLOG",68,0)
 ;    Debug messages could be enabled only explicitly.
"RTN","RORLOG",69,0)
 I '$G(TYPE)  S TYPE=2
"RTN","RORLOG",70,0)
 E  I ($D(RORPARM("LOG"))>1)!(TYPE=1)  Q:'$G(RORPARM("LOG",+TYPE))
"RTN","RORLOG",71,0)
 ;---
"RTN","RORLOG",72,0)
 N CURRIO,DATETIME,I,IENS,RC,RORFDA,RORMSG,TMP
"RTN","RORLOG",73,0)
 I $D(RORINFO)=1  S TMP=RORINFO  K RORINFO  S RORINFO(1)=TMP  K TMP
"RTN","RORLOG",74,0)
 S DATETIME=$$NOW^XLFDT
"RTN","RORLOG",75,0)
 ;--- Add a new record to the log (if it has been open)
"RTN","RORLOG",76,0)
 D:$G(RORLOG("IEN"))>0
"RTN","RORLOG",77,0)
 . S IENS="+1,"_RORLOG("IEN")_","
"RTN","RORLOG",78,0)
 . S RORFDA(798.74,IENS,.01)=DATETIME
"RTN","RORLOG",79,0)
 . S RORFDA(798.74,IENS,1)=+TYPE
"RTN","RORLOG",80,0)
 . S RORFDA(798.74,IENS,2)=$E(MESSAGE,1,70)
"RTN","RORLOG",81,0)
 . S:$G(PATIEN) RORFDA(798.74,IENS,3)=+PATIEN
"RTN","RORLOG",82,0)
 . S:$D(RORINFO)>1 RORFDA(798.74,IENS,4)="RORINFO"
"RTN","RORLOG",83,0)
 . D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORLOG",84,0)
 ;--- Display message (if debug mode 2 is enabled)
"RTN","RORLOG",85,0)
 I $G(RORPARM("DEBUG"))>1  U $G(IO(0))  D  U IO
"RTN","RORLOG",86,0)
 . W !,$P($$FMTE^XLFDT(DATETIME,"2FS"),"@",2)_" "_$E(MESSAGE,1,70),!
"RTN","RORLOG",87,0)
 . S I=""
"RTN","RORLOG",88,0)
 . F  S I=$O(RORINFO(I))  Q:I=""  D  W ?9,TMP,!
"RTN","RORLOG",89,0)
 . . S TMP=$G(RORINFO(I))  S:TMP="" TMP=$G(RORINFO(I,0))
"RTN","RORLOG",90,0)
 . W:$G(PATIEN) ?9,"Patient IEN: "_PATIEN,!
"RTN","RORLOG",91,0)
 Q
"RTN","RORLOG",92,0)
 ;
"RTN","RORLOG",93,0)
 ;***** RETURNS AN IEN OF THE CURRENT LOG
"RTN","RORLOG",94,0)
LOGIEN() ;
"RTN","RORLOG",95,0)
 Q +$G(RORLOG("IEN"))
"RTN","RORLOG",96,0)
 ;
"RTN","RORLOG",97,0)
 ;***** OPENS A NEW LOG
"RTN","RORLOG",98,0)
 ;
"RTN","RORLOG",99,0)
 ; [[.]REGLST]   Either name of the registry or reference to a local
"RTN","RORLOG",100,0)
 ;               array containing registry names as subscripts and
"RTN","RORLOG",101,0)
 ;               optional registry IENs as values
"RTN","RORLOG",102,0)
 ;
"RTN","RORLOG",103,0)
 ; [ACTIVITY]    Type of the activity:
"RTN","RORLOG",104,0)
 ;                 0  Other (default)
"RTN","RORLOG",105,0)
 ;                 1  Registry update
"RTN","RORLOG",106,0)
 ;                 2  Data Extract
"RTN","RORLOG",107,0)
 ;                 3  Acknowledgement
"RTN","RORLOG",108,0)
 ;                 4  Hist. Extraction
"RTN","RORLOG",109,0)
 ;
"RTN","RORLOG",110,0)
 ; [MESSAGE]     Text of the first message
"RTN","RORLOG",111,0)
 ;
"RTN","RORLOG",112,0)
 ; Return Values:
"RTN","RORLOG",113,0)
 ;       <0  Error code
"RTN","RORLOG",114,0)
 ;        0  Ok
"RTN","RORLOG",115,0)
 ;
"RTN","RORLOG",116,0)
OPEN(REGLST,ACTIVITY,MESSAGE) ;
"RTN","RORLOG",117,0)
 Q:'$G(RORPARM("LOG")) 0
"RTN","RORLOG",118,0)
 N I,IENS,RC,REGIEN,REGNAME,RORFDA,RORIEN,RORINFO,RORMSG
"RTN","RORLOG",119,0)
 K RORLOG
"RTN","RORLOG",120,0)
 ;--- Prepare the list of registries
"RTN","RORLOG",121,0)
 S:$D(REGLST)=1 REGLST(REGLST)=""
"RTN","RORLOG",122,0)
 S REGNAME="",(I,RC)=0
"RTN","RORLOG",123,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORLOG",124,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORLOG",125,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=REGIEN  Q
"RTN","RORLOG",126,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORLOG",127,0)
 . S I=I+1,RORINFO(I)=REGNAME
"RTN","RORLOG",128,0)
 . S RORFDA(798.73,"+"_(I+10)_",+1,",.01)=REGIEN
"RTN","RORLOG",129,0)
 Q:RC<0 RC
"RTN","RORLOG",130,0)
 ;--- Add a log header (main record) to the ROR LOG file
"RTN","RORLOG",131,0)
 S IENS="+1,"
"RTN","RORLOG",132,0)
 S RORFDA(798.7,IENS,.01)=$$NOW^XLFDT
"RTN","RORLOG",133,0)
 S:$G(ACTIVITY)>0 RORFDA(798.7,IENS,1)=ACTIVITY
"RTN","RORLOG",134,0)
 S RORFDA(798.7,IENS,2)=$J
"RTN","RORLOG",135,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORLOG",136,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"OPEN^RORLOG")  Q:RC<0 RC
"RTN","RORLOG",137,0)
 ;--- Initialize variables and write a header (if any)
"RTN","RORLOG",138,0)
 S RORLOG("IEN")=RORIEN(1)
"RTN","RORLOG",139,0)
 D:$G(MESSAGE)'="" LOG(,MESSAGE,,.RORINFO)
"RTN","RORLOG",140,0)
 Q 0
"RTN","RORLOG",141,0)
 ;
"RTN","RORLOG",142,0)
 ;***** PURGES THE OLD LOGS
"RTN","RORLOG",143,0)
 ;
"RTN","RORLOG",144,0)
 ; [DKEEP]       Days to keep logs in the file (by default = 31)
"RTN","RORLOG",145,0)
 ;
"RTN","RORLOG",146,0)
 ; Return Values:
"RTN","RORLOG",147,0)
 ;       <0  Error code
"RTN","RORLOG",148,0)
 ;        0  Ok
"RTN","RORLOG",149,0)
 ;
"RTN","RORLOG",150,0)
PURGE(DKEEP) ;
"RTN","RORLOG",151,0)
 N HDR,IENS,IR,RC,RORFDA,RORFROM,RORMSG
"RTN","RORLOG",152,0)
 S RORFROM=$$FMADD^XLFDT($$DT^XLFDT,-$G(DKEEP,31))+1
"RTN","RORLOG",153,0)
 S RC=0
"RTN","RORLOG",154,0)
 F  D  Q:'$P($G(HDR),U,3)!(RC<0)
"RTN","RORLOG",155,0)
 . K RORFDA,RORMSG
"RTN","RORLOG",156,0)
 . ;--- Get the next ten records
"RTN","RORLOG",157,0)
 . D LIST^DIC(798.7,,"@","B",10,.RORFROM,,"B",,,"RORFDA","RORMSG")
"RTN","RORLOG",158,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"PURGE^RORLOG")  Q:RC<0
"RTN","RORLOG",159,0)
 . ;--- Stop if no records left
"RTN","RORLOG",160,0)
 . S HDR=$G(RORFDA("DILIST",0))  Q:'HDR
"RTN","RORLOG",161,0)
 . ;--- Prepare the data
"RTN","RORLOG",162,0)
 . S IR=""
"RTN","RORLOG",163,0)
 . F  S IR=$O(RORFDA("DILIST",2,IR),-1)  Q:IR=""  D
"RTN","RORLOG",164,0)
 . . S RORFDA(798.7,RORFDA("DILIST",2,IR)_",",.01)="@"
"RTN","RORLOG",165,0)
 . K RORFDA("DILIST")
"RTN","RORLOG",166,0)
 . ;--- Delete the records
"RTN","RORLOG",167,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORLOG",168,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"PURGE^RORLOG")
"RTN","RORLOG",169,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORLOG",170,0)
 ;
"RTN","RORLOG",171,0)
 ;***** REPLACES LIST OF REGISTRIES ASSOCIATED WITH THE CURRENT LOG
"RTN","RORLOG",172,0)
 ;
"RTN","RORLOG",173,0)
 ; [.]REGLST     Either name of the registry or a reference to a local
"RTN","RORLOG",174,0)
 ;               array containing registry names as subscripts and
"RTN","RORLOG",175,0)
 ;               optional registry IENs as values.
"RTN","RORLOG",176,0)
 ;
"RTN","RORLOG",177,0)
 ; [NOLP]        If this parameter is defined and non-zero, the log
"RTN","RORLOG",178,0)
 ;               subsystem parameters will not be updated according
"RTN","RORLOG",179,0)
 ;               to the new list of associated registries.
"RTN","RORLOG",180,0)
 ;
"RTN","RORLOG",181,0)
 ; Return Values:
"RTN","RORLOG",182,0)
 ;       <0  Error code
"RTN","RORLOG",183,0)
 ;        0  Ok
"RTN","RORLOG",184,0)
 ;
"RTN","RORLOG",185,0)
SETRGLST(REGLST,NOLP) ;
"RTN","RORLOG",186,0)
 N I,IENS,RC,REGIEN,RILST,RORBUF,RORFDA,RORMSG
"RTN","RORLOG",187,0)
 S IENS=$$LOGIEN()_","
"RTN","RORLOG",188,0)
 Q:'$G(RORPARM("LOG"))!(IENS'>0) 0
"RTN","RORLOG",189,0)
 ;--- Compile a list of registry IENs (as subscripts)
"RTN","RORLOG",190,0)
 S:$D(REGLST)=1 REGLST(REGLST)=""
"RTN","RORLOG",191,0)
 S I="",RC=0
"RTN","RORLOG",192,0)
 F  S I=$O(REGLST(I))  Q:I=""  D  Q:RC<0
"RTN","RORLOG",193,0)
 . S REGIEN=+$G(REGLST(I))
"RTN","RORLOG",194,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=REGIEN  Q
"RTN","RORLOG",195,0)
 . . S REGIEN=$$REGIEN^RORUTL02(I)
"RTN","RORLOG",196,0)
 . S RILST(REGIEN)=""
"RTN","RORLOG",197,0)
 Q:RC<0 RC
"RTN","RORLOG",198,0)
 ;--- Delete old registries from the multiple of the log record
"RTN","RORLOG",199,0)
 D LIST^DIC(798.73,","_IENS,"@;.01I",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORLOG",200,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"SETRGLST^RORLOG")  Q:RC<0 RC
"RTN","RORLOG",201,0)
 S I=""
"RTN","RORLOG",202,0)
 F  S I=$O(RORBUF("DILIST",2,I))  Q:I=""  D
"RTN","RORLOG",203,0)
 . S REGIEN=RORBUF("DILIST","ID",I,.01)
"RTN","RORLOG",204,0)
 . I $D(RILST(REGIEN))  K RILST(REGIEN)  Q
"RTN","RORLOG",205,0)
 . S RORFDA(798.73,RORBUF("DILIST",2,I)_","_IENS,.01)="@"
"RTN","RORLOG",206,0)
 I $D(RORFDA)>1  D  Q:RC<0 RC
"RTN","RORLOG",207,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORLOG",208,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"SETRGLST^RORLOG")
"RTN","RORLOG",209,0)
 ;--- Add new registries to the multiple
"RTN","RORLOG",210,0)
 S REGIEN=""
"RTN","RORLOG",211,0)
 F I=1:1  S REGIEN=$O(RILST(REGIEN))  Q:REGIEN=""  D
"RTN","RORLOG",212,0)
 . S RORFDA(798.73,"+"_I_","_IENS,.01)=REGIEN
"RTN","RORLOG",213,0)
 I $D(RORFDA)>1  D  Q:RC<0 RC
"RTN","RORLOG",214,0)
 . D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORLOG",215,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"SETRGLST^RORLOG")
"RTN","RORLOG",216,0)
 ;--- Reload parameters (if necessary)
"RTN","RORLOG",217,0)
 I '$G(NOLP)  D  Q:RC<0 RC
"RTN","RORLOG",218,0)
 . K RORPARM("LOG")  S RC=$$PARAMS^RORLOG01(.REGLST)
"RTN","RORLOG",219,0)
 Q 0
"RTN","RORLOG",220,0)
 ;
"RTN","RORLOG",221,0)
 ;***** INITIALIZES THE LOG SUBSYSTEM
"RTN","RORLOG",222,0)
 ;
"RTN","RORLOG",223,0)
 ; [[.]REGLST]   Either a reference to a local array containing names
"RTN","RORLOG",224,0)
 ;               of the registries to process (as subscripts) or a
"RTN","RORLOG",225,0)
 ;               string that contains a name of the single registry.
"RTN","RORLOG",226,0)
 ;
"RTN","RORLOG",227,0)
 ; Return Values:
"RTN","RORLOG",228,0)
 ;       <0  Error code
"RTN","RORLOG",229,0)
 ;        0  Ok
"RTN","RORLOG",230,0)
 ;
"RTN","RORLOG",231,0)
SETUP(REGLST) ;
"RTN","RORLOG",232,0)
 K RORPARM("LOG"),RORLOG
"RTN","RORLOG",233,0)
 S:$D(REGLST)=1 REGLST(REGLST)=""
"RTN","RORLOG",234,0)
 Q $$PARAMS^RORLOG01(.REGLST)
"RTN","RORLOG01")
0^34^B3453989
"RTN","RORLOG01",1,0)
RORLOG01 ;HCIOFO/SG - LOG FILE MANAGEMENT (UTILITIES) ; 3/25/02 12:55pm
"RTN","RORLOG01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORLOG01",3,0)
 ;
"RTN","RORLOG01",4,0)
 Q
"RTN","RORLOG01",5,0)
 ;
"RTN","RORLOG01",6,0)
 ;***** LOADS THE LOG SUBSYSTEM PARAMETERS
"RTN","RORLOG01",7,0)
 ;
"RTN","RORLOG01",8,0)
 ; .RORLST       Reference to a local array containing names
"RTN","RORLOG01",9,0)
 ;               of the registries to process (as subscripts).
"RTN","RORLOG01",10,0)
 ;
"RTN","RORLOG01",11,0)
 ; Return Values:
"RTN","RORLOG01",12,0)
 ;       <0  Error code
"RTN","RORLOG01",13,0)
 ;        0  Ok
"RTN","RORLOG01",14,0)
 ;
"RTN","RORLOG01",15,0)
PARAMS(RORLST) ;
"RTN","RORLOG01",16,0)
 N ENABLE,IENS,IR,IRS,RC,RORBUF,RORMSG,RORSB,SCR,TYPE
"RTN","RORLOG01",17,0)
 ;--- Load a list of parameters of active registries
"RTN","RORLOG01",18,0)
 S SCR="I '$P(^(0),U,7),$D(RORLST(+$P(^(0),U)))"
"RTN","RORLOG01",19,0)
 D LIST^DIC(798.1,,"@;8I",,"*",,,"B",SCR,,"RORBUF","RORMSG")
"RTN","RORLOG01",20,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"PARAMS^RORLOG01")  Q:RC<0 RC
"RTN","RORLOG01",21,0)
 I '$G(RORBUF("DILIST",0))  S RORPARM("LOG")=1  Q 0
"RTN","RORLOG01",22,0)
 ;--- Process the list of log parameters
"RTN","RORLOG01",23,0)
 S IR="",RC=0
"RTN","RORLOG01",24,0)
 F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D  Q:RC
"RTN","RORLOG01",25,0)
 . ;--- Check if the log is enabled
"RTN","RORLOG01",26,0)
 . Q:'$G(RORBUF("DILIST","ID",IR,8))
"RTN","RORLOG01",27,0)
 . S ENABLE=1
"RTN","RORLOG01",28,0)
 . ;--- Load a list of event types to log
"RTN","RORLOG01",29,0)
 . S IRS=","_RORBUF("DILIST",2,IR)_","  K RORSB
"RTN","RORLOG01",30,0)
 . D LIST^DIC(798.11,IRS,"@;.01I",,"*",,,"B",,,"RORSB","RORMSG")
"RTN","RORLOG01",31,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"PARAMS^RORLOG01")  Q:RC<0
"RTN","RORLOG01",32,0)
 . ;--- If there are no event types, log all events
"RTN","RORLOG01",33,0)
 . I '$G(RORSB("DILIST",0))  D  Q
"RTN","RORLOG01",34,0)
 . . K RORPARM("LOG")  S RC=1
"RTN","RORLOG01",35,0)
 . ;--- Process the list of event types
"RTN","RORLOG01",36,0)
 . S IRS=""
"RTN","RORLOG01",37,0)
 . F  S IRS=$O(RORSB("DILIST","ID",IRS))  Q:IRS=""  D
"RTN","RORLOG01",38,0)
 . . S TYPE=+$G(RORSB("DILIST","ID",IRS,.01))
"RTN","RORLOG01",39,0)
 . . S:TYPE RORPARM("LOG",TYPE)=1
"RTN","RORLOG01",40,0)
 S:$G(ENABLE) RORPARM("LOG")=1
"RTN","RORLOG01",41,0)
 ;--- If not all types of errors are recorded,
"RTN","RORLOG01",42,0)
 ;    enable recording of the type "Error"
"RTN","RORLOG01",43,0)
 S:$D(RORPARM("LOG"))>1 RORPARM("LOG",6)=1
"RTN","RORLOG01",44,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORNTEG")
0^82^B7742531
"RTN","RORNTEG",1,0)
RORNTEG ;ISC/XTSUMBLD KERNEL - Package checksum checker ;3020515.082738
"RTN","RORNTEG",2,0)
 ;;0.0;
"RTN","RORNTEG",3,0)
 ;;7.3;3020515.082738
"RTN","RORNTEG",4,0)
 S XT4="I 1",X=$T(+3) W !!,"Checksum routine created on ",$P(X,";",4)," by KERNEL V",$P(X,";",3),!
"RTN","RORNTEG",5,0)
CONT F XT1=1:1 S XT2=$T(ROU+XT1) Q:XT2=""  S X=$P(XT2," ",1),XT3=$P(XT2,";",3) X XT4 I $T W !,X X ^%ZOSF("TEST") S:'$T XT3=0 X:XT3 ^%ZOSF("RSUM") W ?10,$S('XT3:"Routine not in UCI",XT3'=Y:"Calculated "_$C(7)_Y_", off by "_(Y-XT3),1:"ok")
"RTN","RORNTEG",6,0)
 ;
"RTN","RORNTEG",7,0)
 K %1,%2,%3,X,Y,XT1,XT2,XT3,XT4 Q
"RTN","RORNTEG",8,0)
ONE S XT4="I $D(^UTILITY($J,X))",X=$T(+3) W !!,"Checksum routine created on ",$P(X,";",4)," by KERNEL V",$P(X,";",3),!
"RTN","RORNTEG",9,0)
 W !,"Check a subset of routines:" K ^UTILITY($J) X ^%ZOSF("RSEL")
"RTN","RORNTEG",10,0)
 W ! G CONT
"RTN","RORNTEG",11,0)
ROU ;;
"RTN","RORNTEG",12,0)
ROR ;;2602553
"RTN","RORNTEG",13,0)
ROR01 ;;1117
"RTN","RORNTEG",14,0)
RORACK ;;3432402
"RTN","RORNTEG",15,0)
RORACK01 ;;6003542
"RTN","RORNTEG",16,0)
RORAPI01 ;;2614007
"RTN","RORNTEG",17,0)
RORDD ;;3052752
"RTN","RORNTEG",18,0)
RORENV01 ;;1326700
"RTN","RORNTEG",19,0)
RORERR ;;2587128
"RTN","RORNTEG",20,0)
RORERR10 ;;17181044
"RTN","RORNTEG",21,0)
RORERR20 ;;9184360
"RTN","RORNTEG",22,0)
ROREVT01 ;;1432188
"RTN","RORNTEG",23,0)
ROREXPR ;;2628241
"RTN","RORNTEG",24,0)
ROREXT ;;3425862
"RTN","RORNTEG",25,0)
ROREXT01 ;;2546090
"RTN","RORNTEG",26,0)
ROREXT02 ;;4989515
"RTN","RORNTEG",27,0)
ROREXTUT ;;4029089
"RTN","RORNTEG",28,0)
RORHDT ;;3515691
"RTN","RORNTEG",29,0)
RORHDT01 ;;2568846
"RTN","RORNTEG",30,0)
RORHDT02 ;;1373692
"RTN","RORNTEG",31,0)
RORHDT03 ;;4452836
"RTN","RORNTEG",32,0)
RORHDT04 ;;7363755
"RTN","RORNTEG",33,0)
RORHDT05 ;;3499618
"RTN","RORNTEG",34,0)
RORHDTAC ;;3499153
"RTN","RORNTEG",35,0)
RORHDTUT ;;5260009
"RTN","RORNTEG",36,0)
RORHL01 ;;3279393
"RTN","RORNTEG",37,0)
RORHL02 ;;8157445
"RTN","RORNTEG",38,0)
RORHL03 ;;9558685
"RTN","RORNTEG",39,0)
RORHL04 ;;4173457
"RTN","RORNTEG",40,0)
RORHL05 ;;2497117
"RTN","RORNTEG",41,0)
RORHL06 ;;5442182
"RTN","RORNTEG",42,0)
RORHL07 ;;3631549
"RTN","RORNTEG",43,0)
RORHL7 ;;3159952
"RTN","RORNTEG",44,0)
RORKIDS ;;2814003
"RTN","RORNTEG",45,0)
RORLOG ;;5635247
"RTN","RORNTEG",46,0)
RORLOG01 ;;1572747
"RTN","RORNTEG",47,0)
RORPOS01 ;;4925130
"RTN","RORNTEG",48,0)
RORPOSU1 ;;665251
"RTN","RORNTEG",49,0)
RORPRE01 ;;2036630
"RTN","RORNTEG",50,0)
RORRP1 ;;2796927
"RTN","RORNTEG",51,0)
RORRP10 ;;476541
"RTN","RORNTEG",52,0)
RORRP2 ;;4565833
"RTN","RORNTEG",53,0)
RORRP3 ;;3482249
"RTN","RORNTEG",54,0)
RORRP4 ;;5196987
"RTN","RORNTEG",55,0)
RORRP5 ;;1673654
"RTN","RORNTEG",56,0)
RORRP6 ;;3979336
"RTN","RORNTEG",57,0)
RORRP7 ;;4903176
"RTN","RORNTEG",58,0)
RORRP8 ;;3614530
"RTN","RORNTEG",59,0)
RORRP9 ;;7828261
"RTN","RORNTEG",60,0)
RORSET01 ;;4109746
"RTN","RORNTEG",61,0)
RORSETU1 ;;4862121
"RTN","RORNTEG",62,0)
RORSETU2 ;;3422125
"RTN","RORNTEG",63,0)
RORTSITE ;;4570058
"RTN","RORNTEG",64,0)
RORUPD ;;3639699
"RTN","RORNTEG",65,0)
RORUPD01 ;;7724802
"RTN","RORNTEG",66,0)
RORUPD04 ;;4980025
"RTN","RORNTEG",67,0)
RORUPD05 ;;6719693
"RTN","RORNTEG",68,0)
RORUPD06 ;;2672977
"RTN","RORNTEG",69,0)
RORUPD07 ;;2080523
"RTN","RORNTEG",70,0)
RORUPD08 ;;3974187
"RTN","RORNTEG",71,0)
RORUPD09 ;;2605824
"RTN","RORNTEG",72,0)
RORUPD50 ;;3750312
"RTN","RORNTEG",73,0)
RORUPD51 ;;9684486
"RTN","RORNTEG",74,0)
RORUPD52 ;;2507568
"RTN","RORNTEG",75,0)
RORUPDUT ;;7306215
"RTN","RORNTEG",76,0)
RORUPEX ;;3446189
"RTN","RORNTEG",77,0)
RORUPP01 ;;3975391
"RTN","RORNTEG",78,0)
RORUPP02 ;;2060193
"RTN","RORNTEG",79,0)
RORUPR ;;5615794
"RTN","RORNTEG",80,0)
RORUPR1 ;;11381037
"RTN","RORNTEG",81,0)
RORUTL01 ;;5264165
"RTN","RORNTEG",82,0)
RORUTL02 ;;5300006
"RTN","RORNTEG",83,0)
RORUTL03 ;;7542123
"RTN","RORNTEG",84,0)
RORUTL04 ;;2076790
"RTN","RORNTEG",85,0)
RORUTL05 ;;6503220
"RTN","RORNTEG",86,0)
RORUTL06 ;;7468553
"RTN","RORNTEG",87,0)
RORUTL07 ;;2738279
"RTN","RORPOS01")
0^35^B20385618
"RTN","RORPOS01",1,0)
RORPOS01 ;HCIOFO/SG - POST-INSTALL ROUTINE (VA HEPC) ; 4/30/02 11:54am
"RTN","RORPOS01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORPOS01",3,0)
 ;
"RTN","RORPOS01",4,0)
 Q
"RTN","RORPOS01",5,0)
 ;
"RTN","RORPOS01",6,0)
 ;***** POST-INSTALL ENTRY POINT FOR THE "VA HEPC" REGISTRY
"RTN","RORPOS01",7,0)
START ;
"RTN","RORPOS01",8,0)
 N RORERROR      ; Error processing data
"RTN","RORPOS01",9,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORPOS01",10,0)
 N RORPARM       ; Application parameters
"RTN","RORPOS01",11,0)
 ;
"RTN","RORPOS01",12,0)
 N RC,REGIEN,REGNAME,RORMSG,TMP
"RTN","RORPOS01",13,0)
 S RORPARM("DEVELOPER")=1   ; Enable modifications
"RTN","RORPOS01",14,0)
 S RORPARM("ERR")=1         ; Enable error processing
"RTN","RORPOS01",15,0)
 S RORPARM("KIDS")=2        ; Post-install indicator
"RTN","RORPOS01",16,0)
 S RORPARM("LOG")=1         ; Enable error recording
"RTN","RORPOS01",17,0)
 ;
"RTN","RORPOS01",18,0)
 ;--- IEN and name of the registry
"RTN","RORPOS01",19,0)
 S REGNAME="VA HEPC"
"RTN","RORPOS01",20,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)  G:REGIEN<0 ERROR
"RTN","RORPOS01",21,0)
 S RORPARM("KIDS","RORREG")=REGIEN_U_REGNAME
"RTN","RORPOS01",22,0)
 ;
"RTN","RORPOS01",23,0)
 ;--- Name of the HL7 event driver
"RTN","RORPOS01",24,0)
 S RORPARM("KIDS","HL7PROTOCOL")="ROR-SITE-DRIVER"
"RTN","RORPOS01",25,0)
 ;
"RTN","RORPOS01",26,0)
 ;--- Open a new log
"RTN","RORPOS01",27,0)
 S TMP=$$OPEN^RORLOG(REGNAME,0,"REGISTRY POST-INSTALL STARTED")
"RTN","RORPOS01",28,0)
 ;
"RTN","RORPOS01",29,0)
 ;--- Update registry parameters in the file #798.1
"RTN","RORPOS01",30,0)
 G:$$CP^RORKIDS("POS05","$$REGPARM^RORPOS01")<0 ERROR
"RTN","RORPOS01",31,0)
 ;
"RTN","RORPOS01",32,0)
 ;--- Set up the ROR PHARMACY CODE file
"RTN","RORPOS01",33,0)
 G:$$CP^RORKIDS("POS10","$$IDRUG^RORPOS01")<0 ERROR
"RTN","RORPOS01",34,0)
 ;
"RTN","RORPOS01",35,0)
 ;--- Populate the INACTIVATION DATE field at the beta sites
"RTN","RORPOS01",36,0)
 S TMP=$$VERSION^XPDUTL("ROR")
"RTN","RORPOS01",37,0)
 I TMP'>1,TMP["T",$P(TMP,"T",2)<11  S RC=0  D  G:RC<0 ERROR
"RTN","RORPOS01",38,0)
 . Q:$D(^RORDATA(798,"AC",REGIEN))<10
"RTN","RORPOS01",39,0)
 . S RC=$$CP^RORKIDS("POS12","$$INACTFIX^RORPOS01")
"RTN","RORPOS01",40,0)
 ;
"RTN","RORPOS01",41,0)
 ;--- Enable the event protocols
"RTN","RORPOS01",42,0)
 G:$$CP^RORKIDS("POS15","$$ENPROTS^RORPOS01")<0 ERROR
"RTN","RORPOS01",43,0)
 ;
"RTN","RORPOS01",44,0)
 K ^XTMP("RORUPDR"_REGIEN)
"RTN","RORPOS01",45,0)
 ;--- Close the log
"RTN","RORPOS01",46,0)
 D CLOSE^RORLOG("REGISTRY POST-INSTALL COMPLETED")
"RTN","RORPOS01",47,0)
 Q
"RTN","RORPOS01",48,0)
ERROR ;--- Display the errors
"RTN","RORPOS01",49,0)
 S XPDABORT=1
"RTN","RORPOS01",50,0)
 D:$D(ZTQUEUED) ALERT^RORKIDS(DUZ,-43,REGNAME,,"post-install")
"RTN","RORPOS01",51,0)
 D DSPSTK^RORERR(),ABTMSG^RORKIDS()
"RTN","RORPOS01",52,0)
 ;--- Close the log
"RTN","RORPOS01",53,0)
 D CLOSE^RORLOG("REGISTRY POST-INSTALL ABORTED")
"RTN","RORPOS01",54,0)
 Q
"RTN","RORPOS01",55,0)
 ;
"RTN","RORPOS01",56,0)
 ;***** RE-ENABLES THE PACKAGE EVENT PROTOCOLS
"RTN","RORPOS01",57,0)
ENPROTS() ;
"RTN","RORPOS01",58,0)
 N DA,DIK,EPLST,PN,RC  S RC=0
"RTN","RORPOS01",59,0)
 D BMES^RORKIDS("Enabling the event protocols...")
"RTN","RORPOS01",60,0)
 ;--- Re-create the cross-reference that controls the protocols
"RTN","RORPOS01",61,0)
 S DIK=$$ROOT^DILFD(798.1),DIK(1)="25^AEP"
"RTN","RORPOS01",62,0)
 D EN1^DIK
"RTN","RORPOS01",63,0)
 ;--- Enable the package event protocols
"RTN","RORPOS01",64,0)
 D LIST^ROREVT01(.EPLST)
"RTN","RORPOS01",65,0)
 S PN=""
"RTN","RORPOS01",66,0)
 F  S PN=$O(EPLST(PN))  Q:PN=""  D  Q:RC<0
"RTN","RORPOS01",67,0)
 . I '$$PRODE^XPDUTL(PN,1)  D  Q
"RTN","RORPOS01",68,0)
 . . S RC=$$ERROR^RORERR(-53,"ENPROTS^RORPOS01",,,PN)
"RTN","RORPOS01",69,0)
 Q:RC<0 RC
"RTN","RORPOS01",70,0)
 ;--- Success
"RTN","RORPOS01",71,0)
 D MES^RORKIDS("The protocols have been enabled.")
"RTN","RORPOS01",72,0)
 Q 0
"RTN","RORPOS01",73,0)
 ;
"RTN","RORPOS01",74,0)
 ;***** SETS THE POINTER TO THE INVESTIGATIONAL DRUG CLASS IN140
"RTN","RORPOS01",75,0)
 ;
"RTN","RORPOS01",76,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPOS01",77,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPOS01",78,0)
 ;
"RTN","RORPOS01",79,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPOS01",80,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPOS01",81,0)
 ; sub-nodes of the same name.
"RTN","RORPOS01",82,0)
 ;
"RTN","RORPOS01",83,0)
 ; Return Values:
"RTN","RORPOS01",84,0)
 ;       <0  Error code
"RTN","RORPOS01",85,0)
 ;        0  Ok
"RTN","RORPOS01",86,0)
 ;
"RTN","RORPOS01",87,0)
IDRUG(RORREG) ;
"RTN","RORPOS01",88,0)
 N IENS,K4,RC,RORFDA,RORMSG
"RTN","RORPOS01",89,0)
 D BMES^RORKIDS("Updating the ROR PHARMACY CODE file...")
"RTN","RORPOS01",90,0)
 ;--- Get the registry
"RTN","RORPOS01",91,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPOS01",92,0)
 ;--- IN140 will exist as PSN*4.0*53 is the required patch
"RTN","RORPOS01",93,0)
 S K4=$O(^PS(50.605,"B","IN140",""))
"RTN","RORPOS01",94,0)
 Q:'K4 $$ERROR^RORERR(-47,"IDRUG^RORPOSO1",,,"IN140")
"RTN","RORPOS01",95,0)
 ;--- Create the record
"RTN","RORPOS01",96,0)
 S IENS="?+1,"
"RTN","RORPOS01",97,0)
 S RORFDA(798.6,IENS,.01)=K4
"RTN","RORPOS01",98,0)
 S RORFDA(798.6,IENS,.02)=+RORREG
"RTN","RORPOS01",99,0)
 D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORPOS01",100,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"IDRUG^RORPOSO1")  Q:RC<0 RC
"RTN","RORPOS01",101,0)
 ;--- Success
"RTN","RORPOS01",102,0)
 D MES^RORKIDS("The file has been updated successfully.")
"RTN","RORPOS01",103,0)
 Q 0
"RTN","RORPOS01",104,0)
 ;
"RTN","RORPOS01",105,0)
 ;***** POPULATES THE INACTIVATION DATE FIELD ON BETA TEST SITES
"RTN","RORPOS01",106,0)
 ;
"RTN","RORPOS01",107,0)
 ; Return Values:
"RTN","RORPOS01",108,0)
 ;       <0  Error code
"RTN","RORPOS01",109,0)
 ;        0  Ok
"RTN","RORPOS01",110,0)
 ;
"RTN","RORPOS01",111,0)
INACTFIX() ;
"RTN","RORPOS01",112,0)
 N CNT,PATIEN,RC,RORFDA,RORMSG,XPDIDTOT
"RTN","RORPOS01",113,0)
 D BMES^RORKIDS("Populating the INACTIVATION DATE field...")
"RTN","RORPOS01",114,0)
 S XPDIDTOT=$$GET1^DID(798.4,,,"ENTRIES",,"RORMSG")
"RTN","RORPOS01",115,0)
 ;--- Process all patients
"RTN","RORPOS01",116,0)
 S (CNT,PATIEN,RC)=0
"RTN","RORPOS01",117,0)
 F  S PATIEN=$O(^RORDATA(798.4,PATIEN))  Q:PATIEN'>0  D  Q:RC<0
"RTN","RORPOS01",118,0)
 . S CNT=CNT+1  D:'(CNT#50) UPDATE^XPDID(CNT)
"RTN","RORPOS01",119,0)
 . S RORFDA(798.4,PATIEN_",",.351)="@"
"RTN","RORPOS01",120,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORPOS01",121,0)
 . I $G(DIERR)  D  Q
"RTN","RORPOS01",122,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"PATCH^RORFIX",PATIEN,798.4)
"RTN","RORPOS01",123,0)
 . S RC=$$UPDPTDEM^RORUPD51(PATIEN)
"RTN","RORPOS01",124,0)
 Q:RC<0 RC
"RTN","RORPOS01",125,0)
 ;--- Success
"RTN","RORPOS01",126,0)
 D MES^RORKIDS("The dates have been corrected.")
"RTN","RORPOS01",127,0)
 S XPDIDTOT=0  D UPDATE^XPDID(0)
"RTN","RORPOS01",128,0)
 Q 0
"RTN","RORPOS01",129,0)
 ;
"RTN","RORPOS01",130,0)
 ;***** UPDATES REGISTRY PARAMETERS IN THE FILE #798.1
"RTN","RORPOS01",131,0)
 ;
"RTN","RORPOS01",132,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPOS01",133,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPOS01",134,0)
 ;
"RTN","RORPOS01",135,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPOS01",136,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPOS01",137,0)
 ; sub-nodes of the same name.
"RTN","RORPOS01",138,0)
 ;
"RTN","RORPOS01",139,0)
 ; Return Values:
"RTN","RORPOS01",140,0)
 ;       <0  Error code
"RTN","RORPOS01",141,0)
 ;        0  Ok
"RTN","RORPOS01",142,0)
 ;
"RTN","RORPOS01",143,0)
REGPARM(RORREG) ;
"RTN","RORPOS01",144,0)
 N IENS,RC,RORFDA,RORMSG
"RTN","RORPOS01",145,0)
 D BMES^RORKIDS("Updating the registry parameters...")
"RTN","RORPOS01",146,0)
 ;--- Get the registry
"RTN","RORPOS01",147,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPOS01",148,0)
 S IENS=+RORREG_","
"RTN","RORPOS01",149,0)
 ;--- Update pointer to the PROTOCOL file
"RTN","RORPOS01",150,0)
 S RORFDA(798.1,IENS,13)=$$PARAM^RORKIDS("HL7PROTOCOL")
"RTN","RORPOS01",151,0)
 D FILE^DIE("E","RORFDA","RORMSG")
"RTN","RORPOS01",152,0)
 I $G(DIERR)>0  D  Q RC
"RTN","RORPOS01",153,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"REGPARM^RORPOS01",,798.1,IENS)
"RTN","RORPOS01",154,0)
 ;--- Success
"RTN","RORPOS01",155,0)
 D MES^RORKIDS("Parameters have been updated successfully.")
"RTN","RORPOS01",156,0)
 Q 0
"RTN","RORPOSU1")
0^36^B1428774
"RTN","RORPOSU1",1,0)
RORPOSU1 ;HCIOFO/SG - POST-INSTALL UTILITIES (HIGH-LEVEL) ; 4/12/02 2:37pm
"RTN","RORPOSU1",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORPOSU1",3,0)
 ;
"RTN","RORPOSU1",4,0)
 Q
"RTN","RORPOSU1",5,0)
 ;
"RTN","RORPOSU1",6,0)
 ;***** UPDATES (POPULATES) THE LOCAL REGISTRY
"RTN","RORPOSU1",7,0)
 ;
"RTN","RORPOSU1",8,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPOSU1",9,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPOSU1",10,0)
 ; [MAXNTSK]     Maximum number of registry update subtasks
"RTN","RORPOSU1",11,0)
 ; [SUSPEND]     Suspend update (sub)tasks during the peak hours
"RTN","RORPOSU1",12,0)
 ;               (StartTime^EndTime)
"RTN","RORPOSU1",13,0)
 ;
"RTN","RORPOSU1",14,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPOSU1",15,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPOSU1",16,0)
 ; sub-nodes of the same name.
"RTN","RORPOSU1",17,0)
 ;
"RTN","RORPOSU1",18,0)
 ; Return Values:
"RTN","RORPOSU1",19,0)
 ;       <0  Error code
"RTN","RORPOSU1",20,0)
 ;        0  Ok
"RTN","RORPOSU1",21,0)
 ;
"RTN","RORPOSU1",22,0)
UPDATE(RORREG,MAXNTSK,SUSPEND) ;
"RTN","RORPOSU1",23,0)
 N EC,REGLST
"RTN","RORPOSU1",24,0)
 D BMES^RORKIDS("Updating the local registry...")
"RTN","RORPOSU1",25,0)
 ;--- Get the parameters
"RTN","RORPOSU1",26,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPOSU1",27,0)
 S:RORREG REGLST($P(RORREG,U,2))=+RORREG
"RTN","RORPOSU1",28,0)
 S:$G(MAXNTSK)="" MAXNTSK=$$PARAM^RORKIDS("MAXNTSK")
"RTN","RORPOSU1",29,0)
 S:$G(SUSPEND)="" SUSPEND=$$PARAM^RORKIDS("SUSPEND")
"RTN","RORPOSU1",30,0)
 ;--- Update the registry
"RTN","RORPOSU1",31,0)
 S RC=$$UPDATE^RORUPD(.REGLST,,MAXNTSK,SUSPEND)  Q:RC<0 RC
"RTN","RORPOSU1",32,0)
 ;--- Success
"RTN","RORPOSU1",33,0)
 D MES^RORKIDS("Registry update completed.")
"RTN","RORPOSU1",34,0)
 Q 0
"RTN","RORPOSUT")
1^76
"RTN","RORPRE01")
0^37^B4743801
"RTN","RORPRE01",1,0)
RORPRE01 ;HCIOFO/SG - PRE-INSTALL ROUTINE (VA HEPC) ; 5/2/02 8:46am
"RTN","RORPRE01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORPRE01",3,0)
 ;
"RTN","RORPRE01",4,0)
 Q
"RTN","RORPRE01",5,0)
 ;
"RTN","RORPRE01",6,0)
 ;***** PRE-INSTALL ENTRY POINT FOR THE 'VA HEPC' REGISTRY
"RTN","RORPRE01",7,0)
START ;
"RTN","RORPRE01",8,0)
 N RORERROR      ; Error processing data
"RTN","RORPRE01",9,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORPRE01",10,0)
 N RORPARM       ; Application parameters
"RTN","RORPRE01",11,0)
 ;
"RTN","RORPRE01",12,0)
 S RORPARM("DEVELOPER")=1   ; Enable modifications
"RTN","RORPRE01",13,0)
 S RORPARM("ERR")=1         ; Enable error processing
"RTN","RORPRE01",14,0)
 S RORPARM("KIDS")=1        ; Pre-install indicator
"RTN","RORPRE01",15,0)
 ;
"RTN","RORPRE01",16,0)
 N RC,REGNAME,TMP,VER
"RTN","RORPRE01",17,0)
 S VER=$$VERSION^XPDUTL("ROR")
"RTN","RORPRE01",18,0)
 ;
"RTN","RORPRE01",19,0)
 ;--- Delete some (sub)files if they exist (test sites)
"RTN","RORPRE01",20,0)
 I VER'>1,VER["T",$P(VER,"T",2)<12  D
"RTN","RORPRE01",21,0)
 . S RC=$$DELFILE^RORKIDS(798.26,"DS",1) ; DATA ELEMENT
"RTN","RORPRE01",22,0)
 . S RC=$$DELFILE^RORKIDS(798.3,"D",1)   ; ROR PENDING PATIENT
"RTN","RORPRE01",23,0)
 . S RC=$$DELFILE^RORKIDS(799.2,"D",1)   ; ROR METADATA
"RTN","RORPRE01",24,0)
 ;
"RTN","RORPRE01",25,0)
 ;--- Quit if the ROR REGISTRY PARAMETERS file does not exist
"RTN","RORPRE01",26,0)
 ;--- (most probably the first-time installation)
"RTN","RORPRE01",27,0)
 Q:'$$VFILE^DILFD(798.1)
"RTN","RORPRE01",28,0)
 ;
"RTN","RORPRE01",29,0)
 ;--- The IEN and name of the registry
"RTN","RORPRE01",30,0)
 S REGNAME="VA HEPC"
"RTN","RORPRE01",31,0)
 S TMP=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORPRE01",32,0)
 I TMP<0  Q:TMP=-1  G ERROR
"RTN","RORPRE01",33,0)
 S RORPARM("KIDS","RORREG")=TMP_U_REGNAME
"RTN","RORPRE01",34,0)
 ;
"RTN","RORPRE01",35,0)
 ;--- Clear the SELECTION RULE multiple
"RTN","RORPRE01",36,0)
 G:$$CP^RORKIDS("PRE05","$$CLEAR^RORPRE01")<0 ERROR
"RTN","RORPRE01",37,0)
 ;
"RTN","RORPRE01",38,0)
 ;--- Delete some field definitions if they exist (test sites)
"RTN","RORPRE01",39,0)
 I VER'>1,VER["T",$P(VER,"T",2)<14  D
"RTN","RORPRE01",40,0)
 . S RC=$$DELFLDS^RORKIDS(798.1,"16;18",1)
"RTN","RORPRE01",41,0)
 Q
"RTN","RORPRE01",42,0)
ERROR ;--- Display the errors
"RTN","RORPRE01",43,0)
 S XPDABORT=1
"RTN","RORPRE01",44,0)
 D:$D(ZTQUEUED) ALERT^RORKIDS(DUZ,-43,REGNAME,,"pre-install")
"RTN","RORPRE01",45,0)
 D DSPSTK^RORERR(),ABTMSG^RORKIDS()
"RTN","RORPRE01",46,0)
 Q
"RTN","RORPRE01",47,0)
 ;
"RTN","RORPRE01",48,0)
 ;***** CLEARS THE 'SELECTION RULE' MULTIPLE
"RTN","RORPRE01",49,0)
 ;
"RTN","RORPRE01",50,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPRE01",51,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPRE01",52,0)
 ;
"RTN","RORPRE01",53,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPRE01",54,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPRE01",55,0)
 ; sub-nodes of the same name.
"RTN","RORPRE01",56,0)
 ;
"RTN","RORPRE01",57,0)
 ; Return Values:
"RTN","RORPRE01",58,0)
 ;       <0  Error code
"RTN","RORPRE01",59,0)
 ;        0  Ok
"RTN","RORPRE01",60,0)
 ;
"RTN","RORPRE01",61,0)
CLEAR(RORREG) ;
"RTN","RORPRE01",62,0)
 N RC
"RTN","RORPRE01",63,0)
 D BMES^RORKIDS("Clearing the SELECTION RULE multiple...")
"RTN","RORPRE01",64,0)
 ;--- Get the registry
"RTN","RORPRE01",65,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPRE01",66,0)
 ;--- Delete all selection rules
"RTN","RORPRE01",67,0)
 S RC=$$CLEAR^RORUTL05(798.13,","_(+RORREG)_",")  Q:RC<0 RC
"RTN","RORPRE01",68,0)
 ;--- Display a message (in case of success)
"RTN","RORPRE01",69,0)
 D MES^RORKIDS("The multiple has been cleared successfully.")
"RTN","RORPRE01",70,0)
 Q 0
"RTN","RORRP1")
0^38^B9768883
"RTN","RORRP1",1,0)
RORRP1 ;HCIOFO/BH - MANUAL REGISTRY UPDATE ; 12/6/01 1:19pm
"RTN","RORRP1",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORRP1",3,0)
 ;
"RTN","RORRP1",4,0)
 Q
"RTN","RORRP1",5,0)
 ;
"RTN","RORRP1",6,0)
 ;  This routine uses the following IA's:
"RTN","RORRP1",7,0)
 ;  #10061  ^VADPT calls  (supported)
"RTN","RORRP1",8,0)
 ;  #2701   $$GETICN^MPIF001 Gets ICN (supported)
"RTN","RORRP1",9,0)
 ;  #174    Direct global read of Rated disability's (private)
"RTN","RORRP1",10,0)
 ;
"RTN","RORRP1",11,0)
SETDATA(RESULT,DFN,REGISTRY,EVIDENCE,IDRUGS,SELECT) ;
"RTN","RORRP1",12,0)
 ;
"RTN","RORRP1",13,0)
 ; Update files when a patient is manually entered or edited into
"RTN","RORRP1",14,0)
 ; the Hep C registry.
"RTN","RORRP1",15,0)
 ;
"RTN","RORRP1",16,0)
 ; Input for New Patients:
"RTN","RORRP1",17,0)
 ;       DFN=DFN
"RTN","RORRP1",18,0)
 ;       REGISTRY=External Registry Name (i.e. VA HEPC)
"RTN","RORRP1",19,0)
 ;       IDRUGS=Investigational drugs (Boolean)
"RTN","RORRP1",20,0)
 ;       EVIDENCE=Evidence of Hep C Diagnosis (Pointer to 799.1)
"RTN","RORRP1",21,0)
 ;       SELECT(n)=IEN of Selection rule^Date Passed rule.
"RTN","RORRP1",22,0)
 ;                 (may not be defined if no rules passed)
"RTN","RORRP1",23,0)
 ; Input for edited patients:
"RTN","RORRP1",24,0)
 ;       DFN=DFN
"RTN","RORRP1",25,0)
 ;       REGISTRY=External Registry Name (i.e. "VA HEPC")
"RTN","RORRP1",26,0)
 ;       IDRUGS=Investigational drugs (Boolean)
"RTN","RORRP1",27,0)
 ;       EVIDENCE=Evidence of Hep C Diagnosis (Numeric 1-5)
"RTN","RORRP1",28,0)
 ;
"RTN","RORRP1",29,0)
 ; Output : String - "1^" Success
"RTN","RORRP1",30,0)
 ;                 - "0^Reason for failure" 
"RTN","RORRP1",31,0)
 ;  
"RTN","RORRP1",32,0)
 I $G(REGISTRY)=""  D  Q
"RTN","RORRP1",33,0)
 . S RESULT="0^No registry passed to remote procedure."
"RTN","RORRP1",34,0)
 S DFN=+$G(DFN)
"RTN","RORRP1",35,0)
 I 'DFN  S RESULT="0^No DFN passed to remote procedure."  Q
"RTN","RORRP1",36,0)
 ;
"RTN","RORRP1",37,0)
 N NEWPAT,RC,REGIEN
"RTN","RORRP1",38,0)
 S REGIEN=$$REG(REGISTRY)
"RTN","RORRP1",39,0)
 I 'REGIEN  S RESULT="0^Invalid Registry."  Q
"RTN","RORRP1",40,0)
 ;---
"RTN","RORRP1",41,0)
 I '$D(^RORDATA(798,"KEY",DFN,REGIEN))  D  Q:RC<0
"RTN","RORRP1",42,0)
 . S RC=$$ADDPAT^RORUPD06(DFN,REGISTRY,.SELECT),NEWPAT=1
"RTN","RORRP1",43,0)
 . S:RC<0 RESULT="0^"_$$MSG^RORERR20(RC)
"RTN","RORRP1",44,0)
 ;---
"RTN","RORRP1",45,0)
 S RESULT=$$EDIT(DFN,REGIEN,IDRUGS,EVIDENCE)
"RTN","RORRP1",46,0)
 I $G(NEWPAT),'RESULT  D  Q
"RTN","RORRP1",47,0)
 . N IEN,RORFDA,RORMSG
"RTN","RORRP1",48,0)
 . S IEN=$O(^RORDATA(798,"KEY",DFN,REGIEN,""))  Q:IEN'>0
"RTN","RORRP1",49,0)
 . S RORFDA(798,IEN_",",.01)="@"
"RTN","RORRP1",50,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORRP1",51,0)
 ;--- If no selection rules exist for the new patient, send VA Alert
"RTN","RORRP1",52,0)
 I $G(NEWPAT)  D:$D(SELECT)<10 ALERT(DFN)
"RTN","RORRP1",53,0)
 S RESULT="1^"
"RTN","RORRP1",54,0)
 Q
"RTN","RORRP1",55,0)
 ;
"RTN","RORRP1",56,0)
 ;
"RTN","RORRP1",57,0)
CHECK(ERR) ; Checks for Errors after calling FILE^DIE
"RTN","RORRP1",58,0)
 N K4,STR
"RTN","RORRP1",59,0)
 S STR="Error occured during update process."
"RTN","RORRP1",60,0)
 S K4=$O(ERR("DIERR",1,"TEXT",""))
"RTN","RORRP1",61,0)
 I K4'="" D
"RTN","RORRP1",62,0)
 . I $G(ERR("DIERR",1,"TEXT",K4))'="" S STR=ERR("DIERR",1,"TEXT",K4)
"RTN","RORRP1",63,0)
 Q "0^"_STR
"RTN","RORRP1",64,0)
 ;
"RTN","RORRP1",65,0)
EDIT(DFN,REGISTRY,IDRUGS,EVIDENCE) ;  Entry point for editing existing patients
"RTN","RORRP1",66,0)
 N IENS,RORMSG,RORFDA
"RTN","RORRP1",67,0)
 S IENS=$O(^RORDATA(798,"KEY",+DFN,REGISTRY,""))_","
"RTN","RORRP1",68,0)
 Q:'IENS "0^Patient does not exist on the Hepatitis C registry."
"RTN","RORRP1",69,0)
 S RORFDA(798,IENS,3)=2 ; Added manually
"RTN","RORRP1",70,0)
 S RORFDA(798,IENS,5)=1 ; Update local data
"RTN","RORRP1",71,0)
 S RORFDA(798,IENS,6)=IDRUGS
"RTN","RORRP1",72,0)
 S RORFDA(798,IENS,3.2)=EVIDENCE
"RTN","RORRP1",73,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORRP1",74,0)
 ;
"RTN","RORRP1",75,0)
 Q $S($G(DIERR):$$CHECK(.RORMSG),1:"1^")
"RTN","RORRP1",76,0)
 ;
"RTN","RORRP1",77,0)
REG(REG) ; Get internal # of registry
"RTN","RORRP1",78,0)
 Q +$O(^ROR(798.1,"B",REG,""))
"RTN","RORRP1",79,0)
 ;
"RTN","RORRP1",80,0)
ALERT(DFN) ;  Send an Alert for patients added to registry that have not
"RTN","RORRP1",81,0)
 ;          passed any selection rules.
"RTN","RORRP1",82,0)
 ;
"RTN","RORRP1",83,0)
 N NAME,SSN,VADM
"RTN","RORRP1",84,0)
 D DEM^VADPT
"RTN","RORRP1",85,0)
 S NAME=VADM(1),SSN=$P(VADM(2),"^",1),SSN=$E(SSN,6,9)
"RTN","RORRP1",86,0)
 S XQAMSG="Hepatitis C Registry." S XQADATA=NAME_"^"_SSN
"RTN","RORRP1",87,0)
 S XQAROU="MSG^RORRP1",XQA(DUZ)="" D SETUP^XQALERT
"RTN","RORRP1",88,0)
 Q
"RTN","RORRP1",89,0)
 ;
"RTN","RORRP1",90,0)
MSG ;
"RTN","RORRP1",91,0)
 W !!
"RTN","RORRP1",92,0)
 W "Please ensure that you add the appropriate ICD-9 code to the Problem List for:",!
"RTN","RORRP1",93,0)
 W "Patient: "_$P(XQADATA,"^",1)_"   Last four: "_$P(XQADATA,"^",2)
"RTN","RORRP1",94,0)
 W !
"RTN","RORRP1",95,0)
 Q
"RTN","RORRP10")
0^39^B743662
"RTN","RORRP10",1,0)
RORRP10 ;HOIFO/CRT - Set/Get GUI Settings RPC
"RTN","RORRP10",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORRP10",3,0)
 ;
"RTN","RORRP10",4,0)
SET(RES,RORREG,RORINST,RORVAL) ;
"RTN","RORRP10",5,0)
 ;
"RTN","RORRP10",6,0)
 ; INPUT: RORREG - Registry Name                           (Required)
"RTN","RORRP10",7,0)
 ;        RORINST - Instance (Delphi Form Name)            (Required)
"RTN","RORRP10",8,0)
 ;        RORENDT - Values to store (delimited by ';')       (Required)
"RTN","RORRP10",9,0)
 ;
"RTN","RORRP10",10,0)
 S RES=""
"RTN","RORRP10",11,0)
 Q:$G(RORREG)=""
"RTN","RORRP10",12,0)
 ;
"RTN","RORRP10",13,0)
 D PUT^XPAR(DUZ_";VA(200,","ROR "_RORREG_" GUI SETTINGS",$G(RORINST,1),$G(RORVAL),.RES)
"RTN","RORRP10",14,0)
 Q
"RTN","RORRP10",15,0)
 ;
"RTN","RORRP10",16,0)
GET(RES,RORREG,RORINST) ;
"RTN","RORRP10",17,0)
 ;
"RTN","RORRP10",18,0)
 ; INPUT: RORREG - Registry Name                           (Required)
"RTN","RORRP10",19,0)
 ;        RORINST - Instance (Delphi Form Name)            (Required)
"RTN","RORRP10",20,0)
 ;
"RTN","RORRP10",21,0)
 S RES=""
"RTN","RORRP10",22,0)
 Q:$G(RORREG)=""
"RTN","RORRP10",23,0)
 ;
"RTN","RORRP10",24,0)
 S RES=$$GET^XPAR("ALL","ROR "_RORREG_" GUI SETTINGS",$G(RORINST,1))
"RTN","RORRP10",25,0)
 Q
"RTN","RORRP10",26,0)
 ;
"RTN","RORRP2")
0^40^B21485444
"RTN","RORRP2",1,0)
RORRP2 ;HOIFO/CRT - CLINICAL REGISTRIES - Remote Procedures ; 2/8/02 3:17pm
"RTN","RORRP2",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORRP2",3,0)
 ;
"RTN","RORRP2",4,0)
EN1(RES,RORDPT,RORREG) ; ROR EDIT PATIENT GET
"RTN","RORRP2",5,0)
 ;
"RTN","RORRP2",6,0)
 ; INPUT:  RORDPT: Pateint IEN (File #2) (Req'd)
"RTN","RORRP2",7,0)
 ;         RORREG: Registry Name (File #798.1) (Req'd)
"RTN","RORRP2",8,0)
 ; OUTPUT: RES(1)       = 0 if not on Local Registry, else IEN (File#798)
"RTN","RORRP2",9,0)
 ;         RES(2)       = Evidence of Diag (File#798 Field#3.2)
"RTN","RORRP2",10,0)
 ;         RES(3)       = Investigational Drugs (File#798 Field#6)
"RTN","RORRP2",11,0)
 ;         RES(4-n) = Selection Rule(s) (File#798 Field#3.1)
"RTN","RORRP2",12,0)
 ;
"RTN","RORRP2",13,0)
 N OK,RORULES,CNT
"RTN","RORRP2",14,0)
 ;
"RTN","RORRP2",15,0)
 S (RES(1),RES(2),RES(3))=0
"RTN","RORRP2",16,0)
 S CNT=3
"RTN","RORRP2",17,0)
 ;
"RTN","RORRP2",18,0)
 S RES(1)=$$IEN798(RORDPT,RORREG) ; Registry IEN
"RTN","RORRP2",19,0)
 ;
"RTN","RORRP2",20,0)
 S RES(2)=+$$GET1^DIQ(798,RES(1),3.2,"I") ; Evidence Code
"RTN","RORRP2",21,0)
 ;
"RTN","RORRP2",22,0)
 S RES(3)=+$$GET1^DIQ(798,RES(1),6,"I") ; Invst Drug?
"RTN","RORRP2",23,0)
 ;
"RTN","RORRP2",24,0)
 ; If existing patient get Selection Rule(s), else search from rules
"RTN","RORRP2",25,0)
 I RES(1) D
"RTN","RORRP2",26,0)
 .D RULES(RES(1),.RORULES)
"RTN","RORRP2",27,0)
 .I $D(RORULES) D
"RTN","RORRP2",28,0)
 ..N I S I=0 F  S I=$O(RORULES(I)) Q:'I  D
"RTN","RORRP2",29,0)
 ...S CNT=CNT+1,RES(CNT)=RORULES(I)
"RTN","RORRP2",30,0)
 E  D
"RTN","RORRP2",31,0)
 .S OK=$$UPDPAT^RORUPD06(RORDPT,RORREG,.RORULES,1)
"RTN","RORRP2",32,0)
 .I $D(RORULES) D
"RTN","RORRP2",33,0)
 ..N I
"RTN","RORRP2",34,0)
 ..S I=0 F  S I=$O(RORULES(I)) Q:I=""  D
"RTN","RORRP2",35,0)
 ...S CNT=CNT+1
"RTN","RORRP2",36,0)
 ...S RES(CNT)=$P($G(^ROR(798.2,I,0)),"^",3)_"^"_RORULES(I)_"^"_I
"RTN","RORRP2",37,0)
 ;
"RTN","RORRP2",38,0)
 Q
"RTN","RORRP2",39,0)
 ;
"RTN","RORRP2",40,0)
EN2(RES,RORDPT,RORREG) ; ROR ACTIVATE PATIENT GET
"RTN","RORRP2",41,0)
 ;
"RTN","RORRP2",42,0)
 ; INPUT:  RORDPT: Pateint IEN (File #2) (Req'd)
"RTN","RORRP2",43,0)
 ;         RORREG: Registry Name (File #798.1) (Req'd)
"RTN","RORRP2",44,0)
 ; OUTPUT: RES(1)       = 0 if not on Local Registry, else IEN (File#798)
"RTN","RORRP2",45,0)
 ;         RES(2)       = Date of death in File 2 ^ in File 798.4
"RTN","RORRP2",46,0)
 ;         RES(3)       = Inactivation Date^Reason^Reactivation Date
"RTN","RORRP2",47,0)
 ;         RES(4-n) = Selection Rule(s) (File#798 Field#3.1)
"RTN","RORRP2",48,0)
 ;
"RTN","RORRP2",49,0)
 N RORULES,CNT,RORDOD,RORDOD2,RORX
"RTN","RORRP2",50,0)
 ;
"RTN","RORRP2",51,0)
 S RES(1)=0
"RTN","RORRP2",52,0)
 S (RES(2),RES(3))=""
"RTN","RORRP2",53,0)
 S CNT=3
"RTN","RORRP2",54,0)
 ;
"RTN","RORRP2",55,0)
 S RES(1)=$$IEN798(RORDPT,RORREG) Q:'RES(1)  ; Registry IEN
"RTN","RORRP2",56,0)
 ;
"RTN","RORRP2",57,0)
 S RORDOD2=$$GET1^DIQ(2,RORDPT,.351,"I") ; Date of Death
"RTN","RORRP2",58,0)
 S RORDOD=$$GET1^DIQ(798.4,RORDPT,.351,"I") ; Date of Death
"RTN","RORRP2",59,0)
 S RES(2)=RORDOD2_"^"_RORDOD
"RTN","RORRP2",60,0)
 ;
"RTN","RORRP2",61,0)
 S $P(RES(3),"^",1)=$$GET1^DIQ(798,RES(1),2,"I") ; Inactivation Date
"RTN","RORRP2",62,0)
 S $P(RES(3),"^",2)=$$GET1^DIQ(798,RES(1),2.2,"I") ; Inact Reason
"RTN","RORRP2",63,0)
 S $P(RES(3),"^",3)=$$GET1^DIQ(798,RES(1),7,"I") ; Reactivation Date
"RTN","RORRP2",64,0)
 S $P(RES(3),"^",4)=$$GET1^DIQ(798,RES(1),8) ; Active?
"RTN","RORRP2",65,0)
 ;
"RTN","RORRP2",66,0)
 D RULES(RES(1),.RORULES) ; Selection Rule(s)
"RTN","RORRP2",67,0)
 I $D(RORULES) D
"RTN","RORRP2",68,0)
 .N I S I=0 F  S I=$O(RORULES(I)) Q:'I  D
"RTN","RORRP2",69,0)
 ..S CNT=CNT+1,RES(CNT)=RORULES(I)
"RTN","RORRP2",70,0)
 ;
"RTN","RORRP2",71,0)
 ; Check if deceased in File 798.4 but not in 2 or vice versa
"RTN","RORRP2",72,0)
 I ((RORDOD]"")&(RORDOD2=""))!((RORDOD2]"")&(RORDOD="")) D
"RTN","RORRP2",73,0)
 .S RORX=$$UPDPTDEM^RORUPD51(RORDPT)
"RTN","RORRP2",74,0)
 ;
"RTN","RORRP2",75,0)
 Q
"RTN","RORRP2",76,0)
 ;
"RTN","RORRP2",77,0)
EN3(RES,RORDPT,RORREG,RORIDRUG,RORPROF) ; ROR IDRUGS PATIENT SET
"RTN","RORRP2",78,0)
 ;
"RTN","RORRP2",79,0)
 ; INPUT:  RORDPT:   Pateint IEN (File #2) (Req'd)
"RTN","RORRP2",80,0)
 ;         RORREG:   Registry Name (File #798.1) (Req'd)
"RTN","RORRP2",81,0)
 ;         RORIDRUG: Investigational Drugs (File #798 Field 6) (Req'd)
"RTN","RORRP2",82,0)
 ;         RORPROF:  Medication in Profile (File #798 Field 6.1)
"RTN","RORRP2",83,0)
 ; OUTPUT: RES:      1^Success or 0^Error Message
"RTN","RORRP2",84,0)
 ;
"RTN","RORRP2",85,0)
 N RORFDA,RORIEN,RORMSG
"RTN","RORRP2",86,0)
 ;
"RTN","RORRP2",87,0)
 S RORIEN=$$IEN798(RORDPT,RORREG)
"RTN","RORRP2",88,0)
 I 'RORIEN S RES="0^Failed to find patient in Local Registry" Q
"RTN","RORRP2",89,0)
 S RORIEN=RORIEN_","
"RTN","RORRP2",90,0)
 ;
"RTN","RORRP2",91,0)
 S RORIDRUG=$G(RORIDRUG)
"RTN","RORRP2",92,0)
 S RORIDRUG=$S(RORIDRUG=1:1,$E(RORIDRUG)="Y":1,1:0)
"RTN","RORRP2",93,0)
 S RORPROF=$G(RORPROF)
"RTN","RORRP2",94,0)
 S RORPROF=$S(RORIDRUG=0:"@",$E(RORPROF)="Y":1,1:RORPROF)
"RTN","RORRP2",95,0)
 ;
"RTN","RORRP2",96,0)
 S RORFDA(798,RORIEN,5)=1
"RTN","RORRP2",97,0)
 S RORFDA(798,RORIEN,6)=RORIDRUG
"RTN","RORRP2",98,0)
 S RORFDA(798,RORIEN,6.1)=RORPROF
"RTN","RORRP2",99,0)
 ;
"RTN","RORRP2",100,0)
 D UPDATE^DIE("","RORFDA","","RORMSG")
"RTN","RORRP2",101,0)
 ;
"RTN","RORRP2",102,0)
 I $G(DIERR)'="" S RES=$$CHECK^RORRP1(.RORMSG) Q
"RTN","RORRP2",103,0)
 ;
"RTN","RORRP2",104,0)
 S RES="1^Success"
"RTN","RORRP2",105,0)
 Q
"RTN","RORRP2",106,0)
 ;
"RTN","RORRP2",107,0)
EN4(RES,RORREG) ; Get ROR Registry Parameters - ROR REG PARAMS GET
"RTN","RORRP2",108,0)
 ;
"RTN","RORRP2",109,0)
 ; INPUT:  RORREG: Registry Name (File #798.1) (Req'd)
"RTN","RORRP2",110,0)
 ; OUTPUT: RES(1): 0 if invalid Registry, else IEN (File#798.1)
"RTN","RORRP2",111,0)
 ;         RES(2): Short Description (Field # 4)
"RTN","RORRP2",112,0)
 ;         RES(3): Last Update Date (Field #1)
"RTN","RORRP2",113,0)
 ;         RES(4): Last Extract Date (Field #2)
"RTN","RORRP2",114,0)
 ;         RES(5): # of Active Patients (Field #19.2)
"RTN","RORRP2",115,0)
 ;
"RTN","RORRP2",116,0)
 S RES(1)=+$O(^ROR(798.1,"B",RORREG,0)) Q:'RES(1)
"RTN","RORRP2",117,0)
 ;
"RTN","RORRP2",118,0)
 S RES(2)=$$GET1^DIQ(798.1,RES(1),4) ; Short Description
"RTN","RORRP2",119,0)
 ;
"RTN","RORRP2",120,0)
 S RES(3)=$$GET1^DIQ(798.1,RES(1),1,"I") ; Last Update Date
"RTN","RORRP2",121,0)
 ;
"RTN","RORRP2",122,0)
 S RES(4)=$$GET1^DIQ(798.1,RES(1),2,"I") ; Last Extract Date
"RTN","RORRP2",123,0)
 ;
"RTN","RORRP2",124,0)
 S RES(5)=$$GET1^DIQ(798.1,RES(1),19.2)  ; # of Active Patients
"RTN","RORRP2",125,0)
 ;
"RTN","RORRP2",126,0)
 Q
"RTN","RORRP2",127,0)
 ;
"RTN","RORRP2",128,0)
EN5(RES,RORREG,RORTYP) ; Get ROR Codes
"RTN","RORRP2",129,0)
 ;
"RTN","RORRP2",130,0)
 N CNT,CODE,RC,RORBUF
"RTN","RORRP2",131,0)
 S RORREG=$$REG^RORRP1($G(RORREG))  Q:RORREG'>0
"RTN","RORRP2",132,0)
 S RORTYP=$G(RORTYP)                Q:RORTYP'>0
"RTN","RORRP2",133,0)
 ;
"RTN","RORRP2",134,0)
 Q:$$ITEMLIST^RORUTL01(RORTYP,RORREG,.RORBUF)<0
"RTN","RORRP2",135,0)
 ;
"RTN","RORRP2",136,0)
 S CODE="",CNT=0
"RTN","RORRP2",137,0)
 F  S CODE=$O(RORBUF(CODE))  Q:CODE=""  D
"RTN","RORRP2",138,0)
 . S CNT=CNT+1,RES(CNT)=$P(RORBUF(CODE),"^",1,2)
"RTN","RORRP2",139,0)
 Q
"RTN","RORRP2",140,0)
 ;
"RTN","RORRP2",141,0)
IEN798(RORDPT,RORREG) ; Get File #798 IEN
"RTN","RORRP2",142,0)
 ;
"RTN","RORRP2",143,0)
 N RORRES
"RTN","RORRP2",144,0)
 ;
"RTN","RORRP2",145,0)
 S RORRES=0
"RTN","RORRP2",146,0)
 ;
"RTN","RORRP2",147,0)
 Q:'+RORDPT RORRES
"RTN","RORRP2",148,0)
 ;
"RTN","RORRP2",149,0)
 S RORREG=+$O(^ROR(798.1,"B",RORREG,0)) Q:'RORREG RORRES
"RTN","RORRP2",150,0)
 S RORRES=+$O(^RORDATA(798,"KEY",+RORDPT,+RORREG,0))
"RTN","RORRP2",151,0)
 Q RORRES
"RTN","RORRP2",152,0)
 ;
"RTN","RORRP2",153,0)
RULES(RORIEN,RORULES) ; Get Selection Rules
"RTN","RORRP2",154,0)
 ;
"RTN","RORRP2",155,0)
 ; INPUT: RORIEN - File #798 IEN (Req'd)
"RTN","RORRP2",156,0)
 ;        RORULES  - Name of array to store rules (Req'd) - Pass by ref
"RTN","RORRP2",157,0)
 ;
"RTN","RORRP2",158,0)
 N I
"RTN","RORRP2",159,0)
 ;
"RTN","RORRP2",160,0)
 S I=0 F  S I=$O(^RORDATA(798,RORIEN,1,I)) Q:'I  D
"RTN","RORRP2",161,0)
 .N RORRULE,RORSRIEN,Y
"RTN","RORRP2",162,0)
 .S RORSRIEN=$P($G(^RORDATA(798,RORIEN,1,I,0)),"^",1) Q:'+RORSRIEN
"RTN","RORRP2",163,0)
 .S RORRULE=$P($G(^ROR(798.2,RORSRIEN,0)),"^",3)
"RTN","RORRP2",164,0)
 .S Y=$P($G(^RORDATA(798,RORIEN,1,I,0)),"^",2)
"RTN","RORRP2",165,0)
 .S RORULES(I)=RORRULE_"^"_Y_"^"_RORSRIEN
"RTN","RORRP2",166,0)
 Q
"RTN","RORRP2",167,0)
 ;
"RTN","RORRP3")
0^41^B9592243
"RTN","RORRP3",1,0)
RORRP3 ;HCIOFO/BH - Activate/Inactivate ; 12/11/01 9:08am
"RTN","RORRP3",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORRP3",3,0)
 ;
"RTN","RORRP3",4,0)
 Q
"RTN","RORRP3",5,0)
 ;
"RTN","RORRP3",6,0)
UPDATE(RESULT,DFN,REGISTRY,MODE,REASON,DATE) ;
"RTN","RORRP3",7,0)
 N RORFDA,ERR,REG,K4,IEN S IEN=""
"RTN","RORRP3",8,0)
 S DATE=$$NOW^XLFDT
"RTN","RORRP3",9,0)
 S REG=$$REG^RORRP1(REGISTRY)
"RTN","RORRP3",10,0)
 S IEN=$O(^RORDATA(798,"KEY",+DFN,REG,IEN))
"RTN","RORRP3",11,0)
 I IEN="" S RESULT="0^Patient does not exist on the Hepatitis C registry." Q
"RTN","RORRP3",12,0)
 I MODE="A" S RESULT=$$ACTIVATE()
"RTN","RORRP3",13,0)
 I MODE="I" S RESULT=$$INACT()
"RTN","RORRP3",14,0)
 Q
"RTN","RORRP3",15,0)
 ;
"RTN","RORRP3",16,0)
ACTIVATE() ;  Re-activation processing
"RTN","RORRP3",17,0)
 ;
"RTN","RORRP3",18,0)
 N RORFDA,ERR,K4
"RTN","RORRP3",19,0)
 ;
"RTN","RORRP3",20,0)
 S RORFDA(798,IEN_",",7)=DATE
"RTN","RORRP3",21,0)
 S RORFDA(798,IEN_",",7.1)=DUZ
"RTN","RORRP3",22,0)
 S RORFDA(798,IEN_",",3)=3
"RTN","RORRP3",23,0)
 S RORFDA(798,IEN_",",2.2)=""
"RTN","RORRP3",24,0)
 S RORFDA(798,IEN_",",5)="1"
"RTN","RORRP3",25,0)
 D UPDATE^DIE("","RORFDA","","ERR")
"RTN","RORRP3",26,0)
 ;
"RTN","RORRP3",27,0)
 I $G(DIERR)'="" S RESULT=$$CHECK^RORRP1(.ERR) Q RESULT
"RTN","RORRP3",28,0)
 S K4=0
"RTN","RORRP3",29,0)
 S K4=$O(^RORDATA(798,IEN,1,K4)) I 'K4 D ALERT(DFN,2)
"RTN","RORRP3",30,0)
 Q "1^ACTIVATED"
"RTN","RORRP3",31,0)
 ;
"RTN","RORRP3",32,0)
INACT() ; Inactivation processing
"RTN","RORRP3",33,0)
 ;
"RTN","RORRP3",34,0)
 N RORFDA,ERR,TRANSMIT,K4,ALERT,OUTPUT
"RTN","RORRP3",35,0)
 S (K4,ALERT)=0,OUTPUT="INACTIVATED"
"RTN","RORRP3",36,0)
 ;
"RTN","RORRP3",37,0)
 ; Get Data Extracted Until field.  This indicates if patient data has 
"RTN","RORRP3",38,0)
 ; ever been sent.
"RTN","RORRP3",39,0)
 S TRANSMIT=$$GET1^DIQ(798,IEN,9.2) I $L(TRANSMIT)>1 S TRANSMIT=1
"RTN","RORRP3",40,0)
 ; patient passed any selection rules ? - if so an alert is sent
"RTN","RORRP3",41,0)
 S K4=$O(^RORDATA(798,IEN,1,K4)) I K4 S ALERT=1
"RTN","RORRP3",42,0)
 ; If data previously sent update record
"RTN","RORRP3",43,0)
 I TRANSMIT D  I $G(DIERR)'="" S RESULT=$$CHECK^RORRP1(.ERR) Q RESULT
"RTN","RORRP3",44,0)
 . S RORFDA(798,IEN_",",2)=DATE
"RTN","RORRP3",45,0)
 . S RORFDA(798,IEN_",",2.1)=DUZ
"RTN","RORRP3",46,0)
 . S RORFDA(798,IEN_",",5)="1"
"RTN","RORRP3",47,0)
 . S RORFDA(798,IEN_",",2.2)=REASON
"RTN","RORRP3",48,0)
 . D UPDATE^DIE("","RORFDA","","ERR")
"RTN","RORRP3",49,0)
 . S OUTPUT="INACTIVATED"
"RTN","RORRP3",50,0)
 ; If not previously sent delete record
"RTN","RORRP3",51,0)
 I 'TRANSMIT D
"RTN","RORRP3",52,0)
 . N A
"RTN","RORRP3",53,0)
 . S A(798,IEN_",",.01)="@" D FILE^DIE("","A","")
"RTN","RORRP3",54,0)
 . S OUTPUT="DELETED"
"RTN","RORRP3",55,0)
 ;
"RTN","RORRP3",56,0)
 I ALERT D ALERT(DFN,1)
"RTN","RORRP3",57,0)
 Q "1^"_OUTPUT
"RTN","RORRP3",58,0)
 ;
"RTN","RORRP3",59,0)
ALERT(DFN,PARAM) ;
"RTN","RORRP3",60,0)
 N NAME,SSN,VADM
"RTN","RORRP3",61,0)
 D DEM^VADPT
"RTN","RORRP3",62,0)
 S NAME=VADM(1),SSN=$P(VADM(2),"^",1),SSN=$E(SSN,6,9)
"RTN","RORRP3",63,0)
 S XQAMSG="Hepatitis C Registry." S XQADATA=NAME_"^"_SSN
"RTN","RORRP3",64,0)
 I PARAM=1 S XQAROU="MSG^RORRP3"
"RTN","RORRP3",65,0)
 I PARAM=2 S XQAROU="MSG1^RORRP3"
"RTN","RORRP3",66,0)
 S XQA(DUZ)="" D SETUP^XQALERT
"RTN","RORRP3",67,0)
 Q
"RTN","RORRP3",68,0)
 ;
"RTN","RORRP3",69,0)
MSG W !!
"RTN","RORRP3",70,0)
 W "Patient "_$P(XQADATA,"^",1)_" "_$P(XQADATA,"^",2)_" has an ICD-9 code or hepatitis serology"
"RTN","RORRP3",71,0)
 W !,"test result consistent with hepatitis C infection but has been inactivated"
"RTN","RORRP3",72,0)
 W !,"from the Hepatitis C registry.  Please make sure that the patient has the"
"RTN","RORRP3",73,0)
 W !,"correct diagnosis in the medical record.",!!
"RTN","RORRP3",74,0)
 Q
"RTN","RORRP3",75,0)
 ;
"RTN","RORRP3",76,0)
MSG1 W !!
"RTN","RORRP3",77,0)
 W "Please ensure that you add the appropriate ICD-9 code to the Problem List for"
"RTN","RORRP3",78,0)
 W !,"patient "_$P(XQADATA,"^",1)_" "_$P(XQADATA,"^",2),!
"RTN","RORRP3",79,0)
 Q
"RTN","RORRP3",80,0)
 ;
"RTN","RORRP4")
0^42^B20577791
"RTN","RORRP4",1,0)
RORRP4 ;HOIFO/BH - CLINICAL REGISTRIES - Remote Procedures - Report
"RTN","RORRP4",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORRP4",3,0)
 ;
"RTN","RORRP4",4,0)
GETDATA(RESULT,REGISTRY,START,END,MODE,SORTBY,FIELDS) ;
"RTN","RORRP4",5,0)
 ;
"RTN","RORRP4",6,0)
 ; Input: Registry - i.e. "VA HEPC"
"RTN","RORRP4",7,0)
 ;        Start    - Start date for report
"RTN","RORRP4",8,0)
 ;        End      - End date for report
"RTN","RORRP4",9,0)
 ;        Mode     - Either "I","A" or "B" (inactive, active or both)
"RTN","RORRP4",10,0)
 ;        Sortby   - Integer 0-7
"RTN","RORRP4",11,0)
 ;                   0-Name  1-DFN 2-ICN  
"RTN","RORRP4",12,0)
 ;                   3-DOB   4-Date Entered
"RTN","RORRP4",13,0)
 ;                   5-Date Inactivated  6-Date Re-Activated
"RTN","RORRP4",14,0)
 ;                   7-Investigational Drugs
"RTN","RORRP4",15,0)
 ;        Fields   - Delimited string conatining 9 pieces of boolean 
"RTN","RORRP4",16,0)
 ;                   data, these values indicate what fields are wanted
"RTN","RORRP4",17,0)
 ;                   on the user interface.
"RTN","RORRP4",18,0)
 ;                   P1=DFN  P2=ICN
"RTN","RORRP4",19,0)
 ;                   P3=DOB  P4=Date entered into registry 
"RTN","RORRP4",20,0)
 ;                   P5=Date Inactivated  P6=Reason Inactivated  
"RTN","RORRP4",21,0)
 ;                   P7=Date Reactivated  P8=Investigational Drugs
"RTN","RORRP4",22,0)
 ;                   P9=Reason Addes to Reg. 
"RTN","RORRP4",23,0)
 ;
"RTN","RORRP4",24,0)
 N LEN,DOB,DTE,STATUS,RULE,REG,SORT,RSNINACT
"RTN","RORRP4",25,0)
 S STR=".01;",DTE="",RULE=""
"RTN","RORRP4",26,0)
 ;
"RTN","RORRP4",27,0)
 S SORT=$S(SORTBY=1:"DFN",SORTBY=2:"ICN",SORTBY=3:"DOB",SORTBY=4:"ENTERED",SORTBY=5:"DATEIN",SORTBY=6:"DATERE",SORTBY=7:"DRUGS",1:"NAME")
"RTN","RORRP4",28,0)
 S RESULT=$NA(^TMP("ROR REPORT",$J))
"RTN","RORRP4",29,0)
 S REG=$$REG^RORRP1(REGISTRY)
"RTN","RORRP4",30,0)
 ; Make up string for GETS FM call.
"RTN","RORRP4",31,0)
 I $P(FIELDS,"^",4) S STR=STR_"1;"
"RTN","RORRP4",32,0)
 I $P(FIELDS,"^",5) S STR=STR_"2;"
"RTN","RORRP4",33,0)
 I $P(FIELDS,"^",6) S STR=STR_"2.2;"
"RTN","RORRP4",34,0)
 I $P(FIELDS,"^",7) S STR=STR_"7;"
"RTN","RORRP4",35,0)
 I $P(FIELDS,"^",8) S STR=STR_"6;"
"RTN","RORRP4",36,0)
 I $P(FIELDS,"^",9) S RULE=1
"RTN","RORRP4",37,0)
 S LEN=$L(STR) I $E(STR,LEN,LEN)=";" S STR=$E(STR,1,LEN-1)
"RTN","RORRP4",38,0)
 ;
"RTN","RORRP4",39,0)
 ; If start date specified -1 off to allow for $O.
"RTN","RORRP4",40,0)
 I START'="" S X1=START,X2="-1" D C^%DTC S DTE=X_".235959"
"RTN","RORRP4",41,0)
 ; If no End value set false 9999999 for Quit logic.
"RTN","RORRP4",42,0)
 I END="" S END=9999999
"RTN","RORRP4",43,0)
 S:$P(END,".",2)="" $P(END,".",2)=235959
"RTN","RORRP4",44,0)
 S CNT=0
"RTN","RORRP4",45,0)
 F  S DTE=$O(^RORDATA(798,"AD",DTE)) Q:DTE>END!('DTE)  D
"RTN","RORRP4",46,0)
 . S IEN=""
"RTN","RORRP4",47,0)
 . F  S IEN=$O(^RORDATA(798,"AD",DTE,IEN)) Q:'IEN  D
"RTN","RORRP4",48,0)
 . . S ACTIVE=$$GET1^DIQ(798,IEN,8)
"RTN","RORRP4",49,0)
 . . ; If called for Active patients and patient is inactive Quit.
"RTN","RORRP4",50,0)
 . . I MODE="A",'ACTIVE Q
"RTN","RORRP4",51,0)
 . . ; If called for Inactive patients and patient is Active Quit.
"RTN","RORRP4",52,0)
 . . I MODE="I",ACTIVE Q
"RTN","RORRP4",53,0)
 . . ;
"RTN","RORRP4",54,0)
 . . ; If entry is not for Hep Registry Quit.
"RTN","RORRP4",55,0)
 . . I $$GET1^DIQ(798,IEN,.02,"I")'=REG Q
"RTN","RORRP4",56,0)
 . . ;
"RTN","RORRP4",57,0)
 . . S DFN=$P(^RORDATA(798,IEN,0),"^",1)
"RTN","RORRP4",58,0)
 . . S DOB=$P(^RORDATA(798.4,DFN,0),"^",3)
"RTN","RORRP4",59,0)
 . . S DOB=$$FORMAT(DOB)
"RTN","RORRP4",60,0)
 . . S SSN=$P(^RORDATA(798.4,DFN,0),"^",5),SSN=$E(SSN,6,9)
"RTN","RORRP4",61,0)
 . . S ICN=$$ICN^RORUTL02(DFN)
"RTN","RORRP4",62,0)
 . . S ICN=$P(ICN,"V",1)
"RTN","RORRP4",63,0)
 . . S:ICN<0 ICN=""
"RTN","RORRP4",64,0)
 . . ;
"RTN","RORRP4",65,0)
 . . N RORDATA
"RTN","RORRP4",66,0)
 . . D GETS^DIQ(798,IEN_",",STR,"IE","RORDATA")
"RTN","RORRP4",67,0)
 . . ;
"RTN","RORRP4",68,0)
 . . S NAME=RORDATA(798,IEN_",",.01,"E")
"RTN","RORRP4",69,0)
 . . S ENTERED=$P($G(RORDATA(798,IEN_",",1,"I")),".",1)
"RTN","RORRP4",70,0)
 . . I ENTERED'="" S ENTERED=$$FORMAT(ENTERED)
"RTN","RORRP4",71,0)
 . . S DATEIN=$P($G(RORDATA(798,IEN_",",2,"I")),".",1)
"RTN","RORRP4",72,0)
 . . I DATEIN'="" S DATEIN=$$FORMAT(DATEIN)
"RTN","RORRP4",73,0)
 . . S RSNINACT=$G(RORDATA(798,IEN_",",2.2,"E"))
"RTN","RORRP4",74,0)
 . . S DATERE=$P($G(RORDATA(798,IEN_",",7,"I")),".",1)
"RTN","RORRP4",75,0)
 . . I DATERE'="" S DATERE=$$FORMAT(DATERE)
"RTN","RORRP4",76,0)
 . . S DRUGS=$G(RORDATA(798,IEN_",",6,"E")) I DRUGS="" S DRUGS="NO"
"RTN","RORRP4",77,0)
 . . ;
"RTN","RORRP4",78,0)
 . . ; If sort value is undefined quit. 
"RTN","RORRP4",79,0)
 . . S CNT=CNT+1,K4=@SORT I K4="" Q
"RTN","RORRP4",80,0)
 . . S K4=$P(K4,"~",1)
"RTN","RORRP4",81,0)
 . . I SORTBY=3!(SORTBY=4) S K4=9999999-K4
"RTN","RORRP4",82,0)
 . . ;
"RTN","RORRP4",83,0)
 . . N REASON
"RTN","RORRP4",84,0)
 . . S REASON(1)=""
"RTN","RORRP4",85,0)
 . . I RULE D REASON(IEN)
"RTN","RORRP4",86,0)
 . . ;
"RTN","RORRP4",87,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",1)=NAME
"RTN","RORRP4",88,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",2)=SSN
"RTN","RORRP4",89,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",3)=DFN
"RTN","RORRP4",90,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",4)=ICN
"RTN","RORRP4",91,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",5)=$P(DOB,"~",2)
"RTN","RORRP4",92,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",6)=$P(ENTERED,"~",2)
"RTN","RORRP4",93,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",7)=$P(DATEIN,"~",2)
"RTN","RORRP4",94,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",8)=RSNINACT
"RTN","RORRP4",95,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",9)=$P(DATERE,"~",2)
"RTN","RORRP4",96,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",10)=DRUGS
"RTN","RORRP4",97,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",11)=REASON(1) I 'RULE Q
"RTN","RORRP4",98,0)
 . . ;  If no more selection rules for patient Quit
"RTN","RORRP4",99,0)
 . . I $G(REASON(2))="" Q
"RTN","RORRP4",100,0)
 . . ;  Loop through all remaining rules and write to global
"RTN","RORRP4",101,0)
 . . N I S I=1
"RTN","RORRP4",102,0)
 . . F  S I=$O(REASON(I)) Q:'I  D
"RTN","RORRP4",103,0)
 . . . S CNT=CNT+1
"RTN","RORRP4",104,0)
 . . . S $P(@RESULT@(K4,NAME,CNT),"^",11)=REASON(I)
"RTN","RORRP4",105,0)
 . . Q
"RTN","RORRP4",106,0)
 K CNT
"RTN","RORRP4",107,0)
 Q
"RTN","RORRP4",108,0)
 ;
"RTN","RORRP4",109,0)
FORMAT(FDATE) ;  Concatinates passed in FM date with a formatted version of
"RTN","RORRP4",110,0)
 ;          itself.
"RTN","RORRP4",111,0)
 N M,D,Y,C,TC
"RTN","RORRP4",112,0)
 S C=""
"RTN","RORRP4",113,0)
 S M=$E(FDATE,4,5),Y=$E(FDATE,2,3),D=$E(FDATE,6,7)
"RTN","RORRP4",114,0)
 S TC=$E(FDATE,1,1)
"RTN","RORRP4",115,0)
 I TC=1 S C=18
"RTN","RORRP4",116,0)
 I TC=2 S C=19
"RTN","RORRP4",117,0)
 I TC=3 S C=20
"RTN","RORRP4",118,0)
 S FDATE=FDATE_"~"_M_"/"_D_"/"_C_Y
"RTN","RORRP4",119,0)
 Q FDATE
"RTN","RORRP4",120,0)
 ;
"RTN","RORRP4",121,0)
REASON(IEN) ;  Get short description of selection rules passed if none 
"RTN","RORRP4",122,0)
 ;          exist pass back 'Manual entry'.
"RTN","RORRP4",123,0)
 ;
"RTN","RORRP4",124,0)
 N DESC,K4,STR,POINTER,COUNT
"RTN","RORRP4",125,0)
 S K4="0",STR="",COUNT=0,DESC=""
"RTN","RORRP4",126,0)
 S REASON(1)="Manual Entry"
"RTN","RORRP4",127,0)
 F  S K4=$O(^RORDATA(798,IEN,1,K4)) Q:'K4  D
"RTN","RORRP4",128,0)
 . S STR=$G(^RORDATA(798,IEN,1,K4,0)) Q:STR=""
"RTN","RORRP4",129,0)
 . S POINTER=$P(STR,"^",1)
"RTN","RORRP4",130,0)
 . S DESC=$P(^ROR(798.2,POINTER,0),"^",3) Q:DESC=""
"RTN","RORRP4",131,0)
 . S COUNT=COUNT+1
"RTN","RORRP4",132,0)
 . S REASON(COUNT)=DESC
"RTN","RORRP4",133,0)
 . Q
"RTN","RORRP4",134,0)
 Q
"RTN","RORRP4",135,0)
 ;          
"RTN","RORRP4",136,0)
 ;
"RTN","RORRP5")
0^43^B3269199
"RTN","RORRP5",1,0)
RORRP5 ;HOIFO/CRT - Clinical Registries Pateint Search RPC
"RTN","RORRP5",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORRP5",3,0)
 ;
"RTN","RORRP5",4,0)
EN1(RES,RORREG,RORPART,RORDIR,RORFILE,RORSCRN) ; Return (Partial) Patient List
"RTN","RORRP5",5,0)
 ;
"RTN","RORRP5",6,0)
 ; Remote Procedure: ROR PATIENT SEARCH
"RTN","RORRP5",7,0)
 ; Input: RORREG - Registry Name (Req'd)
"RTN","RORRP5",8,0)
 ;        RORPART - Partial Match (Req'd)
"RTN","RORRP5",9,0)
 ;        RORDIR - Direction. 1 = forward, -1 = back. (Req'd)
"RTN","RORRP5",10,0)
 ;        RORFILE - Search File. 2 or 798 (Req'd)
"RTN","RORRP5",11,0)
 ;        RORSCRN - Date to screen file 798 on (opt'l)
"RTN","RORRP5",12,0)
 ; Output: RES - List of Patients (#2). NAME^SSN^DOB^IEN
"RTN","RORRP5",13,0)
 ;
"RTN","RORRP5",14,0)
 N CNT,I,INDEX,LOOP,SCREEN
"RTN","RORRP5",15,0)
 ;
"RTN","RORRP5",16,0)
 S RES=$NA(^TMP($J,"ROR-SEARCH")) K @RES
"RTN","RORRP5",17,0)
 ;
"RTN","RORRP5",18,0)
 S SCREEN=""
"RTN","RORRP5",19,0)
 S RORREG=$G(RORREG) Q:RORREG=""
"RTN","RORRP5",20,0)
 S RORINDX=$S(RORPART?4N:"BS",RORPART?1U4N:"BS5",RORPART?9N.1"P":"SSN",1:"B")
"RTN","RORRP5",21,0)
 S RORFILE=$S($G(RORFILE)=798:798.4,1:2)
"RTN","RORRP5",22,0)
 S RORDIR=$S(RORDIR="-1":"B",1:"")
"RTN","RORRP5",23,0)
 S RORSCRN=$G(RORSCRN)
"RTN","RORRP5",24,0)
 I RORFILE=798.4 D
"RTN","RORRP5",25,0)
 .S SCREEN="I $$IEN798^RORRP2(+Y,RORREG)"
"RTN","RORRP5",26,0)
 .I RORSCRN'="" S SCREEN=SCREEN_",($P(^RORDATA(798,$$IEN798^RORRP2(+Y,RORREG),0),""^"",3)'<RORSCRN)"
"RTN","RORRP5",27,0)
 ;
"RTN","RORRP5",28,0)
 D LIST^DIC(RORFILE,,".01;.03;.09",RORDIR,,,RORPART,RORINDX,SCREEN,,"^TMP($J,""ROROUT"")","RORMSG")
"RTN","RORRP5",29,0)
 ;
"RTN","RORRP5",30,0)
 S I=0 F  S I=$O(^TMP($J,"ROROUT","DILIST","ID",I)) Q:'I  D
"RTN","RORRP5",31,0)
 .S @RES@(I)=$$ADD(I)
"RTN","RORRP5",32,0)
 ;
"RTN","RORRP5",33,0)
 K ^TMP($J,"ROROUT")
"RTN","RORRP5",34,0)
 ;
"RTN","RORRP5",35,0)
 Q
"RTN","RORRP5",36,0)
 ;
"RTN","RORRP5",37,0)
ADD(J) ;
"RTN","RORRP5",38,0)
 N RESULT
"RTN","RORRP5",39,0)
 ;
"RTN","RORRP5",40,0)
 S $P(RESULT,"^",1)=^TMP($J,"ROROUT","DILIST","ID",J,.01)
"RTN","RORRP5",41,0)
 S $P(RESULT,"^",2)=^TMP($J,"ROROUT","DILIST","ID",J,.09)
"RTN","RORRP5",42,0)
 S $P(RESULT,"^",3)=^TMP($J,"ROROUT","DILIST","ID",J,.03)
"RTN","RORRP5",43,0)
 S $P(RESULT,"^",4)=^TMP($J,"ROROUT","DILIST",2,J)
"RTN","RORRP5",44,0)
 ;
"RTN","RORRP5",45,0)
 Q RESULT
"RTN","RORRP6")
0^44^B16009386
"RTN","RORRP6",1,0)
RORRP6 ;HOIFO/BH - CLINICAL REGISTRIES - Remote Procedures
"RTN","RORRP6",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORRP6",3,0)
 ;
"RTN","RORRP6",4,0)
DRUGS(RESULT,REG,DFN) ;
"RTN","RORRP6",5,0)
 ;
"RTN","RORRP6",6,0)
 ;  Input  REG    = .01 field of the registry entry
"RTN","RORRP6",7,0)
 ;
"RTN","RORRP6",8,0)
 ;  Output RESULT = Array of drugs the patient has had within the   
"RTN","RORRP6",9,0)
 ;                  last year that have the classification specified
"RTN","RORRP6",10,0)
 ;                  for the registry on file 798.6.
"RTN","RORRP6",11,0)
 ;
"RTN","RORRP6",12,0)
 N RORI,J,REGIEN,COUNT,EDATE,SDATE,INVESDGS,CODEROR,PSJX,DESC,INCL,IDATE
"RTN","RORRP6",13,0)
 ;
"RTN","RORRP6",14,0)
 ; Get internal IEN of registry
"RTN","RORRP6",15,0)
 S REGIEN=$$REG^RORRP1(REG) I 'REGIEN S @RESULT@(0)="0^No registry corresponds to "_REG Q
"RTN","RORRP6",16,0)
 ;
"RTN","RORRP6",17,0)
 K ^TMP("ROR IDRUGS",$J)
"RTN","RORRP6",18,0)
 S RESULT=$NA(^TMP("ROR IDRUGS",$J))
"RTN","RORRP6",19,0)
 ;
"RTN","RORRP6",20,0)
 S INVESDGS=$$INVES(DFN,REGIEN)
"RTN","RORRP6",21,0)
 I $P(INVESDGS,"^",1)=0 S @RESULT@(0)=INVESDGS Q
"RTN","RORRP6",22,0)
 ;
"RTN","RORRP6",23,0)
 S @RESULT@(0)="1^"_$P(INVESDGS,"^",2)_"^"_$P(INVESDGS,"^",3)
"RTN","RORRP6",24,0)
 ;
"RTN","RORRP6",25,0)
 D CODEROR(.CODEROR,REGIEN) I '$D(CODEROR) Q
"RTN","RORRP6",26,0)
 ;
"RTN","RORRP6",27,0)
 D CODEPS(.PSJX,.CODEROR) I '$D(PSJX) Q
"RTN","RORRP6",28,0)
 ;
"RTN","RORRP6",29,0)
 S EDATE=$P($$NOW^XLFDT,".",1)
"RTN","RORRP6",30,0)
 S X1=EDATE,X2="-365" D C^%DTC S SDATE=X
"RTN","RORRP6",31,0)
 ;
"RTN","RORRP6",32,0)
 K ^TMP("PS",$J)
"RTN","RORRP6",33,0)
 D OCL^PSOORRL(DFN,SDATE,EDATE)
"RTN","RORRP6",34,0)
 I '$D(^TMP("PS",$J)) Q
"RTN","RORRP6",35,0)
 M ^TMP("ROR-PS",$J)=^TMP("PS",$J)
"RTN","RORRP6",36,0)
 K ^TMP("PS",$J)
"RTN","RORRP6",37,0)
 ;
"RTN","RORRP6",38,0)
 S COUNT=0
"RTN","RORRP6",39,0)
 S RORI=0 F  S RORI=$O(^TMP("ROR-PS",$J,RORI)) Q:'RORI  D
"RTN","RORRP6",40,0)
 . N RORTYP
"RTN","RORRP6",41,0)
 . S RORTYP=$P($G(^TMP("ROR-PS",$J,RORI,0)),"^",1)
"RTN","RORRP6",42,0)
 . I ((RORTYP'["R;O")&(RORTYP'["U;I")) Q
"RTN","RORRP6",43,0)
 . I RORTYP["U;I" D  I ((IDATE<SDATE)!(IDATE>EDATE)) Q
"RTN","RORRP6",44,0)
 . . S IDATE=$P($G(^TMP("ROR-PS",$J,RORI,0)),"^",15)
"RTN","RORRP6",45,0)
 . I RORTYP["R;O" D  Q:IDATE<SDATE
"RTN","RORRP6",46,0)
 . . S IDATE=$P($G(^TMP("ROR-PS",$J,RORI,0)),"^",10)
"RTN","RORRP6",47,0)
 . S DESC=$P($G(^TMP("ROR-PS",$J,RORI,0)),"^",2)
"RTN","RORRP6",48,0)
 . S INCL=0
"RTN","RORRP6",49,0)
 . S J="" F  S J=$O(PSJX(J)) Q:J=""  D  Q:INCL
"RTN","RORRP6",50,0)
 . . I J=DESC S INCL=1 Q
"RTN","RORRP6",51,0)
 . I INCL D COMPILE(DFN,$P(^TMP("ROR-PS",$J,RORI,0),"^"),SDATE,EDATE,.COUNT)
"RTN","RORRP6",52,0)
 ;
"RTN","RORRP6",53,0)
 K ^TMP("ROR-PS",$J)
"RTN","RORRP6",54,0)
 ;
"RTN","RORRP6",55,0)
 Q
"RTN","RORRP6",56,0)
 ;
"RTN","RORRP6",57,0)
CODEPS(PSJX,CODEROR) ;
"RTN","RORRP6",58,0)
 N K1,PSIEN,DRG
"RTN","RORRP6",59,0)
 S K1=""
"RTN","RORRP6",60,0)
 F  S K1=$O(CODEROR(K1)) Q:'K1  D
"RTN","RORRP6",61,0)
 . S PSIEN=0
"RTN","RORRP6",62,0)
 . F  S PSIEN=$O(^PSDRUG("VAC",K1,PSIEN)) Q:'PSIEN  D
"RTN","RORRP6",63,0)
 . . S DRG=$$GET1^DIQ(50,+PSIEN,.01,"E")
"RTN","RORRP6",64,0)
 . . S:DRG]"" PSJX(DRG)=""
"RTN","RORRP6",65,0)
 . . S DRG=$$GET1^DIQ(50.68,+$$GET1^DIQ(50,+PSIEN,22,"I"),4)
"RTN","RORRP6",66,0)
 . . S:DRG]"" PSJX(DRG)=""
"RTN","RORRP6",67,0)
 Q
"RTN","RORRP6",68,0)
 ;
"RTN","RORRP6",69,0)
CODEROR(CODEROR,REGIEN) ; Get class codes IEN for the registry
"RTN","RORRP6",70,0)
 N K4
"RTN","RORRP6",71,0)
 S K4=0
"RTN","RORRP6",72,0)
 F  S K4=$O(^ROR(798.6,"AC",REGIEN,K4)) Q:'K4  D
"RTN","RORRP6",73,0)
 . S CODEROR($P(^ROR(798.6,K4,0),"^",1))=""
"RTN","RORRP6",74,0)
 Q
"RTN","RORRP6",75,0)
 ;
"RTN","RORRP6",76,0)
COMPILE(DFN,ROROCL,SDATE,EDATE,COUNT) ;  Compiles an array of inv. drugs
"RTN","RORRP6",77,0)
 ;
"RTN","RORRP6",78,0)
 N RORDATE,RORDESC,RORIEN,RORII,ROROEL,RORRXN
"RTN","RORRP6",79,0)
 ;
"RTN","RORRP6",80,0)
 S DFN=$G(DFN) Q:'DFN
"RTN","RORRP6",81,0)
 S ROROCL=$G(ROROCL) Q:ROROCL=""
"RTN","RORRP6",82,0)
 ;
"RTN","RORRP6",83,0)
 K ^TMP("PS",$J)
"RTN","RORRP6",84,0)
 D OEL^PSOORRL(DFN,ROROCL)
"RTN","RORRP6",85,0)
 Q:'$D(^TMP("PS",$J))
"RTN","RORRP6",86,0)
 ;
"RTN","RORRP6",87,0)
 S ROROEL=^TMP("PS",$J,0)
"RTN","RORRP6",88,0)
 S RORRXN=$G(^TMP("PS",$J,"RXN",0))
"RTN","RORRP6",89,0)
 S RORDESC=$P(ROROEL,"^",1)
"RTN","RORRP6",90,0)
 S RORIEN=$P($G(^TMP("PS",$J,"DD",1,0)),"^",1)
"RTN","RORRP6",91,0)
 S:RORIEN="" RORIEN=$P($G(^TMP("PS",$J,"DD",1,0)),"^",3)
"RTN","RORRP6",92,0)
 S:RORIEN RORDESC=$$GET1^DIQ(50,RORIEN,.01,"E")
"RTN","RORRP6",93,0)
 ;
"RTN","RORRP6",94,0)
 I ROROCL["R;O" D
"RTN","RORRP6",95,0)
 . S ^TMP("PS",$J,"REF",0,0)=$P(RORRXN,"^",6)
"RTN","RORRP6",96,0)
 . S RORII="" F  S RORII=$O(^TMP("PS",$J,"REF",RORII)) Q:RORII=""  D
"RTN","RORRP6",97,0)
 . . S RORDATE=$P($G(^TMP("PS",$J,"REF",RORII,0)),"^")
"RTN","RORRP6",98,0)
 . . I ((RORDATE<SDATE)!(RORDATE>EDATE)) Q
"RTN","RORRP6",99,0)
 . . S RORDATE=$$FORMAT(RORDATE)
"RTN","RORRP6",100,0)
 . . D COMPILE1
"RTN","RORRP6",101,0)
 ;
"RTN","RORRP6",102,0)
 I ROROCL["U;I" D
"RTN","RORRP6",103,0)
 .S RORDATE=$$FORMAT($P(ROROEL,"^",5))
"RTN","RORRP6",104,0)
 .D COMPILE1
"RTN","RORRP6",105,0)
 ;
"RTN","RORRP6",106,0)
 K ^TMP("PS",$J)
"RTN","RORRP6",107,0)
 Q
"RTN","RORRP6",108,0)
COMPILE1 ;
"RTN","RORRP6",109,0)
 S COUNT=$G(COUNT)+1
"RTN","RORRP6",110,0)
 S @RESULT@(COUNT)=RORDATE_"^"_RORDESC
"RTN","RORRP6",111,0)
 Q
"RTN","RORRP6",112,0)
 ;
"RTN","RORRP6",113,0)
FORMAT(FDATE) ;
"RTN","RORRP6",114,0)
 ;
"RTN","RORRP6",115,0)
 S M=$E(FDATE,4,5),Y=1700+$E(FDATE,1,3),D=$E(FDATE,6,7)
"RTN","RORRP6",116,0)
 Q M_"/"_D_"/"_Y
"RTN","RORRP6",117,0)
 ;
"RTN","RORRP6",118,0)
INVES(DFN,REGIEN) ;
"RTN","RORRP6",119,0)
 N IEN,ROR,RORMSG,INV,MEDPRO
"RTN","RORRP6",120,0)
 S IEN=""
"RTN","RORRP6",121,0)
 S IEN=$O(^RORDATA(798,"KEY",+DFN,REGIEN,IEN))
"RTN","RORRP6",122,0)
 I 'IEN Q "0^Patient does not exist on the reistry"
"RTN","RORRP6",123,0)
 D GETS^DIQ(798,IEN,"6;6.1","I","ROR","RORMSG")
"RTN","RORRP6",124,0)
 S INV=$G(ROR(798,IEN_",",6,"I"))
"RTN","RORRP6",125,0)
 S MEDPRO=$G(ROR(798,IEN_",",6.1,"I"))
"RTN","RORRP6",126,0)
 Q "1^"_INV_"^"_MEDPRO
"RTN","RORRP6",127,0)
 ;
"RTN","RORRP7")
0^45^B17450253
"RTN","RORRP7",1,0)
RORRP7 ; HOIFO/CRT - Activity Log RPC ; 5/7/02 1:56pm
"RTN","RORRP7",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORRP7",3,0)
 ;
"RTN","RORRP7",4,0)
EN1(RES,RORREG,RORSTDT,RORENDT) ; ROR ACTIVITY LOG
"RTN","RORRP7",5,0)
 ;
"RTN","RORRP7",6,0)
 ; INPUT:  RORREG  - Registry Name   (Req'd)
"RTN","RORRP7",7,0)
 ;         RORSTDT - Start Date/Time (Optional)
"RTN","RORRP7",8,0)
 ;         RORENDT - End Date/Time   (Optional)
"RTN","RORRP7",9,0)
 ; OUTPUT: RES     - ^TMP($J,"ROR RPC LOG",n)
"RTN","RORRP7",10,0)
 ;
"RTN","RORRP7",11,0)
 N CNT,IEN,I,J,K,L,M
"RTN","RORRP7",12,0)
 ;
"RTN","RORRP7",13,0)
 S RES=$NA(^TMP($J,"ROR RPC LOG"))
"RTN","RORRP7",14,0)
 K @RES
"RTN","RORRP7",15,0)
 ;
"RTN","RORRP7",16,0)
 S RORREG=$G(RORREG) Q:RORREG=""
"RTN","RORRP7",17,0)
 S RORREG=$O(^ROR(798.1,"B",RORREG,0))
"RTN","RORRP7",18,0)
 ;
"RTN","RORRP7",19,0)
 S RORSTDT=$P($G(RORSTDT),".")
"RTN","RORRP7",20,0)
 ;
"RTN","RORRP7",21,0)
 S RORENDT=$P($G(RORENDT),".")
"RTN","RORRP7",22,0)
 I RORENDT]"" S RORENDT=+RORENDT_".235959"
"RTN","RORRP7",23,0)
 I RORENDT="" S RORENDT=9999999.999999
"RTN","RORRP7",24,0)
 ;
"RTN","RORRP7",25,0)
 S I=RORSTDT F  S I=$O(^RORDATA(798.7,"ARD",RORREG,I)) Q:I=""  Q:I>RORENDT  D
"RTN","RORRP7",26,0)
 .S J=0 F  S J=$O(^RORDATA(798.7,"ARD",RORREG,I,J)) Q:'+J  D
"RTN","RORRP7",27,0)
 ..S IEN=J_","
"RTN","RORRP7",28,0)
 ..S CNT=$G(CNT)+1
"RTN","RORRP7",29,0)
 ..S $P(@RES@(CNT),"^",1)="A"
"RTN","RORRP7",30,0)
 ..S $P(@RES@(CNT),"^",2)=$$GET1^DIQ(798.7,IEN,.01)
"RTN","RORRP7",31,0)
 ..S $P(@RES@(CNT),"^",3)=$$GET1^DIQ(798.7,IEN,1)
"RTN","RORRP7",32,0)
 ..S $P(@RES@(CNT),"^",4)=J
"RTN","RORRP7",33,0)
 ..S L=0 F  S L=$O(^RORDATA(798.7,J,2,L)) Q:'+L  D
"RTN","RORRP7",34,0)
 ...N IEN3
"RTN","RORRP7",35,0)
 ...S IEN3=L_","_J_","
"RTN","RORRP7",36,0)
 ...S CNT=$G(CNT)+1
"RTN","RORRP7",37,0)
 ...S $P(@RES@(CNT),"^",1)="M"
"RTN","RORRP7",38,0)
 ...S $P(@RES@(CNT),"^",2)=$$GET1^DIQ(798.74,IEN3,1,"I")
"RTN","RORRP7",39,0)
 ...S $P(@RES@(CNT),"^",3)=$$GET1^DIQ(798.74,IEN3,2)
"RTN","RORRP7",40,0)
 ...S $P(@RES@(CNT),"^",4)=L_","_J
"RTN","RORRP7",41,0)
 ..S CNT=$G(CNT)+1
"RTN","RORRP7",42,0)
 ..S @RES@(CNT)="$$ENDOFACTIVITY"
"RTN","RORRP7",43,0)
 Q
"RTN","RORRP7",44,0)
 ;
"RTN","RORRP7",45,0)
EN2(RES,RORIEN) ; ROR ACTIVITY DETAILS
"RTN","RORRP7",46,0)
 ;
"RTN","RORRP7",47,0)
 ; INPUT:  RORIEN  - Activity Log IEN (File #798.7)  (Req'd)
"RTN","RORRP7",48,0)
 ; OUTPUT: RES(1-n)  - Activity Details Display
"RTN","RORRP7",49,0)
 ;
"RTN","RORRP7",50,0)
 N CNT,I,ROROUT,ROROUT2,ROROUT3,RORMSG
"RTN","RORRP7",51,0)
 ;
"RTN","RORRP7",52,0)
 S CNT=1
"RTN","RORRP7",53,0)
 S RES(1)="-1^Failed to retrieve activity details"
"RTN","RORRP7",54,0)
 ;
"RTN","RORRP7",55,0)
 S RORIEN=$G(RORIEN)  Q:RORIEN=""
"RTN","RORRP7",56,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORRP7",57,0)
 ;
"RTN","RORRP7",58,0)
 D GETS^DIQ(798.7,RORIEN,"*",,"ROROUT","RORMSG")
"RTN","RORRP7",59,0)
 Q:$G(DIERR)
"RTN","RORRP7",60,0)
 ;
"RTN","RORRP7",61,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.7,RORIEN,1) ; Activity
"RTN","RORRP7",62,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.7,RORIEN,2) ; Job#
"RTN","RORRP7",63,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.7,RORIEN,.01) ; StartDateTime
"RTN","RORRP7",64,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.7,RORIEN,5) ; EndDateTime
"RTN","RORRP7",65,0)
 ;
"RTN","RORRP7",66,0)
 D LIST^DIC(798.73,","_RORIEN,"@;.01",,,,,"B",,,"ROROUT2","RORMSG")
"RTN","RORRP7",67,0)
 I '$G(DIERR),$G(ROROUT2("DILIST",0))>0  D
"RTN","RORRP7",68,0)
 . S CNT=CNT+1,RES(CNT)="$$STARTREGISTRYLIST"
"RTN","RORRP7",69,0)
 . S I=0  F  S I=$O(ROROUT2("DILIST","ID",I))  Q:'I  D
"RTN","RORRP7",70,0)
 . . S CNT=CNT+1,RES(CNT)=ROROUT2("DILIST","ID",I,.01) ; Registry
"RTN","RORRP7",71,0)
 . S CNT=CNT+1,RES(CNT)="$$ENDREGISTRYLIST"
"RTN","RORRP7",72,0)
 ;
"RTN","RORRP7",73,0)
 D LIST^DIC(798.74,","_RORIEN,"@;2.1",,,,,"B",,,"ROROUT3","RORMSG")
"RTN","RORRP7",74,0)
 I '$G(DIERR),$G(ROROUT3("DILIST",0))>0  D
"RTN","RORRP7",75,0)
 . S CNT=CNT+1,RES(CNT)="$$STARTMESSAGELIST"
"RTN","RORRP7",76,0)
 . S I=0  F  S I=$O(ROROUT3("DILIST","ID",I))  Q:'I  D
"RTN","RORRP7",77,0)
 . . S CNT=CNT+1,RES(CNT)=ROROUT3("DILIST","ID",I,2.1) ; Message Text
"RTN","RORRP7",78,0)
 . S CNT=CNT+1,RES(CNT)="$$ENDMESSAGELIST"
"RTN","RORRP7",79,0)
 ;
"RTN","RORRP7",80,0)
 I ROROUT(798.7,RORIEN,6.01)'=""  D
"RTN","RORRP7",81,0)
 . S CNT=CNT+1,RES(CNT)="$$STARTADDINFO"
"RTN","RORRP7",82,0)
 . S CNT=CNT+1,RES(CNT)=ROROUT(798.7,RORIEN,6.01) ; Patients Processed
"RTN","RORRP7",83,0)
 . S CNT=CNT+1,RES(CNT)=ROROUT(798.7,RORIEN,6.02) ; Patients with Errors
"RTN","RORRP7",84,0)
 . S CNT=CNT+1,RES(CNT)=ROROUT(798.7,RORIEN,6.03) ; Rate
"RTN","RORRP7",85,0)
  .S CNT=CNT+1,RES(CNT)="$$ENDADDINFO"
"RTN","RORRP7",86,0)
 ;
"RTN","RORRP7",87,0)
 S RES(1)="1^Success"
"RTN","RORRP7",88,0)
 Q
"RTN","RORRP7",89,0)
EN3(RES,RORIEN) ; ROR LOG MESSAGE DETAILS
"RTN","RORRP7",90,0)
 ;
"RTN","RORRP7",91,0)
 ; INPUT:  RORIEN  -  Message IEN in Log File (File #798.74)  (Req'd)
"RTN","RORRP7",92,0)
 ; OUTPUT: RES(1-n)  - Activity Details Display
"RTN","RORRP7",93,0)
 ;
"RTN","RORRP7",94,0)
 N CNT,I,RORMSG,ROROUT
"RTN","RORRP7",95,0)
 ;
"RTN","RORRP7",96,0)
 S CNT=1
"RTN","RORRP7",97,0)
 S RES(1)="-1^Failed to retrieve message details"
"RTN","RORRP7",98,0)
 ;
"RTN","RORRP7",99,0)
 S RORIEN=$G(RORIEN)  Q:RORIEN=""
"RTN","RORRP7",100,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORRP7",101,0)
 ;
"RTN","RORRP7",102,0)
 D GETS^DIQ(798.74,RORIEN,"*",,"ROROUT","RORMSG")
"RTN","RORRP7",103,0)
 Q:$G(DIERR)
"RTN","RORRP7",104,0)
 ;
"RTN","RORRP7",105,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.74,RORIEN,1) ; Type
"RTN","RORRP7",106,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.74,RORIEN,2) ; Message
"RTN","RORRP7",107,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.74,RORIEN,.01) ; DateTime
"RTN","RORRP7",108,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.74,RORIEN,3) ; Patient
"RTN","RORRP7",109,0)
 ;
"RTN","RORRP7",110,0)
 I $D(ROROUT(798.74,RORIEN,4,1))  D
"RTN","RORRP7",111,0)
 . S I=0  F  S I=$O(ROROUT(798.74,RORIEN,4,I))  Q:'I  D
"RTN","RORRP7",112,0)
 . . S CNT=CNT+1,RES(CNT)=ROROUT(798.74,RORIEN,4,I) ; Additional Info
"RTN","RORRP7",113,0)
 ;
"RTN","RORRP7",114,0)
 S RES(1)="1^Success"
"RTN","RORRP7",115,0)
 Q
"RTN","RORRP8")
0^46^B14331338
"RTN","RORRP8",1,0)
RORRP8 ; HOIFO/CRT - Patient Sensitivity Checks RPC ; [06-22-2001 12:25]
"RTN","RORRP8",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORRP8",3,0)
 ;
"RTN","RORRP8",4,0)
ADD(X) ; [Procedure] Add line to @RESULTS@(...
"RTN","RORRP8",5,0)
 ; Input parameters
"RTN","RORRP8",6,0)
 ;  1. X [Literal/Required] No description
"RTN","RORRP8",7,0)
 ;
"RTN","RORRP8",8,0)
 ; Input parameters
"RTN","RORRP8",9,0)
 ;  1. X [Literal/Required] Data to add to @RESULTS@(...
"RTN","RORRP8",10,0)
 S @RESULTS@(+$O(@RESULTS@(""),-1)+1)=X
"RTN","RORRP8",11,0)
 Q
"RTN","RORRP8",12,0)
 ;
"RTN","RORRP8",13,0)
LOGSEC ; [Procedure] Log Security
"RTN","RORRP8",14,0)
 D NOTICE^DGSEC4(.RESULTS,DFN,DATA,1)
"RTN","RORRP8",15,0)
 S @RESULTS@(0)=$S(RESULTS:"1^Logged",1:"-1^Unable to log")
"RTN","RORRP8",16,0)
 Q
"RTN","RORRP8",17,0)
 ;
"RTN","RORRP8",18,0)
RPC(RESULTS,OPTION,DFN,DATA) ; [Procedure] Main RPC call tag
"RTN","RORRP8",19,0)
 ; Input parameters
"RTN","RORRP8",20,0)
 ;  1. RESULTS [Literal/Required] No description
"RTN","RORRP8",21,0)
 ;  2. OPTION [Literal/Required] No description
"RTN","RORRP8",22,0)
 ;  3. DFN [Literal/Required] No description
"RTN","RORRP8",23,0)
 ;  4. DATA [Literal/Required] No description
"RTN","RORRP8",24,0)
 ;
"RTN","RORRP8",25,0)
 ; RPC: [MD TMDPATIENT]
"RTN","RORRP8",26,0)
 ; Input parameters
"RTN","RORRP8",27,0)
 ;  1. RESULTS [Literal/Required] RPC return array
"RTN","RORRP8",28,0)
 ;  2. OPTION [Literal/Required] Call method for RPC
"RTN","RORRP8",29,0)
 ;  3. DFN [Literal/Required] Patient IEN
"RTN","RORRP8",30,0)
 ;  4. DATA [Literal/Optional] Other data as required for call
"RTN","RORRP8",31,0)
 S RESULTS=$NA(^TMP($J)) K @RESULTS
"RTN","RORRP8",32,0)
 D:$T(@OPTION)]"" @OPTION
"RTN","RORRP8",33,0)
 D:'$D(@RESULTS) BADRPC("MD TMDPATIENT","MDRPCOP",OPTION)
"RTN","RORRP8",34,0)
 D CLEAN^DILF
"RTN","RORRP8",35,0)
 Q
"RTN","RORRP8",36,0)
 ;
"RTN","RORRP8",37,0)
SELECT ; [Procedure] Select patient
"RTN","RORRP8",38,0)
 ; Calls required utilities to check security and
"RTN","RORRP8",39,0)
 ; return associated warnings/alerts about a
"RTN","RORRP8",40,0)
 ; patient being selected.
"RTN","RORRP8",41,0)
 ; Variables:
"RTN","RORRP8",42,0)
 ;  IENS: [Private] Fileman IENS
"RTN","RORRP8",43,0)
 ;  MDDFN: [Private] Scratch
"RTN","RORRP8",44,0)
 ;  MDFLD: [Private] FIeld number
"RTN","RORRP8",45,0)
 ;  MDID: [Private] Identifier array
"RTN","RORRP8",46,0)
 ;  MDRET: [Private] Scratch
"RTN","RORRP8",47,0)
 ;  MDX: [Private] Scratch
"RTN","RORRP8",48,0)
 ; New private variables
"RTN","RORRP8",49,0)
 NEW IENS,MDDFN,MDFLD,MDID,MDRET,MDX
"RTN","RORRP8",50,0)
 I '$D(^DPT(+$G(DFN),0))#2 S @RESULTS@(0)="-1^No such patient" Q
"RTN","RORRP8",51,0)
 S @RESULTS@(0)="1^Required Identifiers & messages"
"RTN","RORRP8",52,0)
 S IENS=DFN_","
"RTN","RORRP8",53,0)
 D FILE^DID(2,,"REQUIRED IDENTIFIERS","MDIDS")
"RTN","RORRP8",54,0)
 F MDX=0:0 S MDX=$O(MDIDS("REQUIRED IDENTIFIERS",MDX)) Q:'MDX  D
"RTN","RORRP8",55,0)
 .S MDFLD=MDIDS("REQUIRED IDENTIFIERS",MDX,"FIELD")
"RTN","RORRP8",56,0)
 .S MDID="$$PTID^"_$$GET1^DID(2,MDFLD,"","LABEL")
"RTN","RORRP8",57,0)
 .S MDID=MDID_U_$$GET1^DIQ(2,IENS,MDFLD)
"RTN","RORRP8",58,0)
 .D:MDFLD=.03
"RTN","RORRP8",59,0)
 ..S MDID=MDID_" ("_$$GET1^DIQ(2,IENS,.033)_")"
"RTN","RORRP8",60,0)
 ..S MDID=MDID_U_$$DOB^DPTLK1(+IENS)
"RTN","RORRP8",61,0)
 .D:MDFLD=.09
"RTN","RORRP8",62,0)
 ..S X=$P(MDID,U,3),X=$E(X,1,3)_"-"_$E(X,4,5)_"-"_$E(X,6,10)
"RTN","RORRP8",63,0)
 ..S $P(MDID,U,3)=X,$P(MDID,U,4)=$$SSN^DPTLK1(+IENS)
"RTN","RORRP8",64,0)
 .S @RESULTS@($O(@RESULTS@(""),-1)+1)=MDID
"RTN","RORRP8",65,0)
 ; Add ward and Room/Bed
"RTN","RORRP8",66,0)
 S MDID="$$PTID^"_$$GET1^DID(2,.1,"","LABEL")
"RTN","RORRP8",67,0)
 S MDID=MDID_U_$$GET1^DIQ(2,IENS,.1)
"RTN","RORRP8",68,0)
 S @RESULTS@($O(@RESULTS@(""),-1)+1)=MDID
"RTN","RORRP8",69,0)
 S MDID="$$PTID^"_$$GET1^DID(2,.101,"","LABEL")
"RTN","RORRP8",70,0)
 S MDID=MDID_U_$$GET1^DIQ(2,IENS,.101)
"RTN","RORRP8",71,0)
 S @RESULTS@($O(@RESULTS@(""),-1)+1)=MDID
"RTN","RORRP8",72,0)
 ; ------- Clevland Alert -------
"RTN","RORRP8",73,0)
 K MDRET
"RTN","RORRP8",74,0)
 D GUIBS5A^DPTLK6(.MDRET,DFN) D:MDRET(1)=1
"RTN","RORRP8",75,0)
 .D ADD("$$MSGHDR^2^SAME LAST NAME AND LAST 4")
"RTN","RORRP8",76,0)
 .S MDX=1
"RTN","RORRP8",77,0)
 .F  S MDX=$O(MDRET(MDX)) Q:'MDX!(+$G(MDRET(MDX)))  D
"RTN","RORRP8",78,0)
 ..D ADD($P(MDRET(MDX),U,2))
"RTN","RORRP8",79,0)
 .D ADD(" ")
"RTN","RORRP8",80,0)
 .S MDX=1
"RTN","RORRP8",81,0)
 .F  S MDX=$O(MDRET(MDX)) Q:'MDX  D:+MDRET(MDX)
"RTN","RORRP8",82,0)
 ..S MDDFN=+$P(MDRET(MDX),U,2)
"RTN","RORRP8",83,0)
 ..D ADD($$GET1^DIQ(2,MDDFN_",",.01)_"    "_$$DOB^DPTLK1(MDDFN)_"    "_$$SSN^DPTLK1(MDDFN))
"RTN","RORRP8",84,0)
 .D ADD(" ")
"RTN","RORRP8",85,0)
 .D ADD("Please review carefully before continuing")
"RTN","RORRP8",86,0)
 .D ADD("$$MSGEND")
"RTN","RORRP8",87,0)
 ; ------- Sensitive Record? -------
"RTN","RORRP8",88,0)
 K MDRET
"RTN","RORRP8",89,0)
 D PTSEC^DGSEC4(.MDRET,DFN) D:MDRET(1)'=0
"RTN","RORRP8",90,0)
 .D:MDRET(1)=3
"RTN","RORRP8",91,0)
 ..D ADD("$$MSGHDR^0^CAN'T ACCESS YOUR OWN RECORD!!")
"RTN","RORRP8",92,0)
 .D:MDRET(1)=-1
"RTN","RORRP8",93,0)
 ..D ADD("$$MSGHDR^0^INCOMPLETE INFORMATION - CAN'T PROCEED")
"RTN","RORRP8",94,0)
 .D:MDRET(1)=1
"RTN","RORRP8",95,0)
 ..D ADD("$$MSGHDR^1^SENSITIVE RECORD ACCESS")
"RTN","RORRP8",96,0)
 .D:MDRET(1)'=-1&(MDRET(1)'=3)&(MDRET(1)'=1)
"RTN","RORRP8",97,0)
 ..D ADD("$$MSGHDR^3^SENSITIVE RECORD ACCESS")
"RTN","RORRP8",98,0)
 .S MDX=1
"RTN","RORRP8",99,0)
 .F  S MDX=$O(MDRET(MDX)) Q:'MDX  D ADD($TR(MDRET(MDX),"*"," "))
"RTN","RORRP8",100,0)
 .D ADD("$$MSGEND")
"RTN","RORRP8",101,0)
 ; ------- Means Test Information? -------
"RTN","RORRP8",102,0)
 D GUIMTD^DPTLK6(.MDRET,DFN) D:MDRET(1)=1
"RTN","RORRP8",103,0)
 .D ADD("$$MSGHDR^1^NOTICE")
"RTN","RORRP8",104,0)
 .F MDX=1:0 S MDX=$O(MDRET(MDX)) Q:'MDX  D ADD(MDRET(MDX))
"RTN","RORRP8",105,0)
 .D ADD("$$MSGEND")
"RTN","RORRP8",106,0)
 Q
"RTN","RORRP8",107,0)
 ;
"RTN","RORRP8",108,0)
X2FM(X) ; [Function] return FM date given relative date
"RTN","RORRP8",109,0)
 ; Input parameters
"RTN","RORRP8",110,0)
 ;  1. X [Literal/Required] No description
"RTN","RORRP8",111,0)
 ;
"RTN","RORRP8",112,0)
 ; Input parameters
"RTN","RORRP8",113,0)
 ;  1. X [Literal/Required] Relative date (i.e. T-2)
"RTN","RORRP8",114,0)
 N %DT S %DT="TS" D ^%DT
"RTN","RORRP8",115,0)
 Q Y
"RTN","RORRP8",116,0)
 ;
"RTN","RORRP8",117,0)
BADRPC(RPC,RTN,OPTION) ; [Procedure] When an RPC gets lost
"RTN","RORRP8",118,0)
 ; Input parameters
"RTN","RORRP8",119,0)
 ;  1. RPC [Literal/Required] No description
"RTN","RORRP8",120,0)
 ;  2. RTN [Literal/Required] No description
"RTN","RORRP8",121,0)
 ;  3. OPTION [Literal/Required] No description
"RTN","RORRP8",122,0)
 ;
"RTN","RORRP8",123,0)
 S @RESULTS@(0)="-1^Error calling RPC: "_RPC_" at "_OPTION_U_RTN
"RTN","RORRP8",124,0)
 Q
"RTN","RORRP8",125,0)
 ;
"RTN","RORRP9")
0^47^B45009195
"RTN","RORRP9",1,0)
RORRP9 ; HOIFO/CRT - HepC Drug Therapy List RPC ; [06-22-2001 12:25]
"RTN","RORRP9",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORRP9",3,0)
 ;
"RTN","RORRP9",4,0)
 Q
"RTN","RORRP9",5,0)
 ;
"RTN","RORRP9",6,0)
DFN(RORIEN,RORSDT) ; Return Patient DFN, or 0 if excluded
"RTN","RORRP9",7,0)
 ;
"RTN","RORRP9",8,0)
 N RORACT,RORDFN,RORDOD,RORINACT
"RTN","RORRP9",9,0)
 ;
"RTN","RORRP9",10,0)
 S RORDFN=+$$GET1^DIQ(798,+$G(RORIEN),.01,"I")
"RTN","RORRP9",11,0)
 I 'RORDFN Q 0                   ; Exclude (Unknown DFN)
"RTN","RORRP9",12,0)
 ;
"RTN","RORRP9",13,0)
 S RORDOD=+$$GET1^DIQ(798.4,RORDFN,.351,"I")
"RTN","RORRP9",14,0)
 I RORDOD,RORDOD<$G(RORSDT) Q 0  ; Exclude (Deceased before start)
"RTN","RORRP9",15,0)
 ;
"RTN","RORRP9",16,0)
 S RORINACT=+$$GET1^DIQ(798,+$G(RORIEN),2,"I")
"RTN","RORRP9",17,0)
 I 'RORINACT Q RORDFN
"RTN","RORRP9",18,0)
 S RORACT=+$$GET1^DIQ(798,+$G(RORIEN),7,"I")
"RTN","RORRP9",19,0)
 I RORACT>RORINACT Q RORDFN
"RTN","RORRP9",20,0)
 I RORINACT<+$G(RORSDT) Q 0  ; Exclude (Inactivated before start)
"RTN","RORRP9",21,0)
 Q RORDFN
"RTN","RORRP9",22,0)
 ;
"RTN","RORRP9",23,0)
ADD(RORDFN,ROROCL,RORNEW,RORSTDT,RORENDT,RORCNT) ;
"RTN","RORRP9",24,0)
 ;
"RTN","RORRP9",25,0)
 N RORDATE,RORDESC,RORII,RORNAME,RORNDC,ROROEL,RORRXN,RORSSN
"RTN","RORRP9",26,0)
 ;
"RTN","RORRP9",27,0)
 S RORDFN=+$G(RORDFN) Q:'RORDFN
"RTN","RORRP9",28,0)
 S ROROCL=$G(ROROCL) Q:ROROCL=""
"RTN","RORRP9",29,0)
 S RORNEW=+$G(RORNEW)
"RTN","RORRP9",30,0)
 ;
"RTN","RORRP9",31,0)
 S RORNAME=$$GET1^DIQ(798.4,RORDFN,.01)
"RTN","RORRP9",32,0)
 S RORSSN=$E($$GET1^DIQ(798.4,RORDFN,.09),6,9)
"RTN","RORRP9",33,0)
 ;
"RTN","RORRP9",34,0)
 K ^TMP("PS",$J)
"RTN","RORRP9",35,0)
 D OEL^PSOORRL(RORDFN,ROROCL)
"RTN","RORRP9",36,0)
 Q:'$D(^TMP("PS",$J))
"RTN","RORRP9",37,0)
 ;
"RTN","RORRP9",38,0)
 S ROROEL=^TMP("PS",$J,0)
"RTN","RORRP9",39,0)
 S RORRXN=$G(^TMP("PS",$J,"RXN",0))
"RTN","RORRP9",40,0)
 S RORDESC=$P($G(ROROEL),"^",1)
"RTN","RORRP9",41,0)
 ;
"RTN","RORRP9",42,0)
 I ROROCL["R;O" D
"RTN","RORRP9",43,0)
 .S ^TMP("PS",$J,"REF",0,0)=$P(RORRXN,"^",6)_"^"_$P(ROROEL,"^",7)_"^"_$P(ROROEL,"^",8)_"^"_$P(RORRXN,"^",7)_"^"_$P(RORRXN,"^",3)
"RTN","RORRP9",44,0)
 ;
"RTN","RORRP9",45,0)
 S RORNDC=$P($G(^TMP("PS",$J,"DD",1,0)),"^",1)
"RTN","RORRP9",46,0)
 S:RORNDC="" RORNDC=$P($G(^TMP("PS",$J,"DD",1,0)),"^",3)
"RTN","RORRP9",47,0)
 I RORNDC D
"RTN","RORRP9",48,0)
 .S RORDESC=$$GET1^DIQ(50,RORNDC,.01,"E")
"RTN","RORRP9",49,0)
 .S RORNDC=$$GET1^DIQ(50,RORNDC,31)
"RTN","RORRP9",50,0)
 ;
"RTN","RORRP9",51,0)
 I ROROCL["U;I" D
"RTN","RORRP9",52,0)
 .S RORDATE=$$FORMAT^RORRP6($P($G(ROROEL),"^",5))
"RTN","RORRP9",53,0)
 .D ADD1(.RORNEW)
"RTN","RORRP9",54,0)
 ;
"RTN","RORRP9",55,0)
 I ROROCL["R;O" D
"RTN","RORRP9",56,0)
 .S RORII="" F  S RORII=$O(^TMP("PS",$J,"REF",RORII)) Q:RORII=""  D
"RTN","RORRP9",57,0)
 ..S RORDATE=+$P($G(^TMP("PS",$J,"REF",RORII,0)),"^")
"RTN","RORRP9",58,0)
 ..I ((RORDATE<RORSTDT)!(RORDATE>RORENDT)) Q
"RTN","RORRP9",59,0)
 ..S RORDATE=$$FORMAT^RORRP6(RORDATE)
"RTN","RORRP9",60,0)
 ..D ADD1(.RORNEW)
"RTN","RORRP9",61,0)
 ;
"RTN","RORRP9",62,0)
 K ^TMP("PS",$J)
"RTN","RORRP9",63,0)
 ;
"RTN","RORRP9",64,0)
 Q
"RTN","RORRP9",65,0)
 ;
"RTN","RORRP9",66,0)
ADD1(RORNEW) ;
"RTN","RORRP9",67,0)
 S RORCNT=$G(RORCNT)+1
"RTN","RORRP9",68,0)
 S @RES@(RORCNT)="^^"_RORDESC_"^"_RORNDC_"^"_RORDATE
"RTN","RORRP9",69,0)
 S:RORNEW $P(@RES@(RORCNT),"^",1,2)=RORNAME_"^"_RORSSN
"RTN","RORRP9",70,0)
 S RORNEW=0
"RTN","RORRP9",71,0)
 Q
"RTN","RORRP9",72,0)
 ;
"RTN","RORRP9",73,0)
EN1(RES,RORREG,RORSTDT,RORENDT) ;
"RTN","RORRP9",74,0)
 ;
"RTN","RORRP9",75,0)
 ; INPUT: RORREG - Registry Name                           (Required)
"RTN","RORRP9",76,0)
 ;        RORSTDT - Start Date (FileMan Format)            (Optional)
"RTN","RORRP9",77,0)
 ;        RORENDT - End Date (FileMan Format)              (Optional)
"RTN","RORRP9",78,0)
 ;
"RTN","RORRP9",79,0)
 N RORCODE,RORCNT,RORDESC,RORDFN,RORI,RORIDATE,RORINC,RORJ,RORNEW,RORRX
"RTN","RORRP9",80,0)
 N X,X1,X2,Y
"RTN","RORRP9",81,0)
 ;
"RTN","RORRP9",82,0)
 S RES=$NA(^XTMP("ROR DRUG LIST"_$J))
"RTN","RORRP9",83,0)
 K @RES
"RTN","RORRP9",84,0)
 I '$G(DT) D NOW^%DTC S DT=X
"RTN","RORRP9",85,0)
 S X1=DT,X2=30
"RTN","RORRP9",86,0)
 D C^%DTC
"RTN","RORRP9",87,0)
 S @RES@(0)=X_"^"_DT_"^ROR DRUG LIST REPORT"
"RTN","RORRP9",88,0)
 ;
"RTN","RORRP9",89,0)
 S RORSTDT=$P($G(RORSTDT),".")
"RTN","RORRP9",90,0)
 S RORENDT=$P($G(RORENDT),".")
"RTN","RORRP9",91,0)
 S @RES@(1)=RORSTDT_"^"_RORENDT
"RTN","RORRP9",92,0)
 S:RORSTDT="" RORSTDT=1
"RTN","RORRP9",93,0)
 S:RORENDT="" RORENDT=9999999
"RTN","RORRP9",94,0)
 ;
"RTN","RORRP9",95,0)
 S RORREG=$$REG^RORRP1($G(RORREG)) Q:'RORREG
"RTN","RORRP9",96,0)
 ;
"RTN","RORRP9",97,0)
 D RORLIST(.RORRX,RORREG)
"RTN","RORRP9",98,0)
 ;
"RTN","RORRP9",99,0)
 D CODEROR^RORRP6(.RORCODE,RORREG)
"RTN","RORRP9",100,0)
 ;
"RTN","RORRP9",101,0)
 D CODEPS^RORRP6(.RORRX,.RORCODE)
"RTN","RORRP9",102,0)
 ;
"RTN","RORRP9",103,0)
 I '$D(RORRX) Q
"RTN","RORRP9",104,0)
 ;
"RTN","RORRP9",105,0)
 S RORCNT=1
"RTN","RORRP9",106,0)
 S RORIEN=0 F  S RORIEN=$O(^RORDATA(798,"AC",RORREG,RORIEN)) Q:'RORIEN  D
"RTN","RORRP9",107,0)
 . S RORNEW=1
"RTN","RORRP9",108,0)
 . S RORDFN=$$DFN(RORIEN,RORSTDT) Q:'RORDFN
"RTN","RORRP9",109,0)
 . K ^TMP("PS",$J),^TMP("ROR-PS-LIST",$J)
"RTN","RORRP9",110,0)
 . D OCL^PSOORRL(RORDFN,RORSTDT,RORENDT)
"RTN","RORRP9",111,0)
 . Q:'$D(^TMP("PS",$J))
"RTN","RORRP9",112,0)
 . M ^TMP("ROR-PS-LIST",$J)=^TMP("PS",$J)
"RTN","RORRP9",113,0)
 . K ^TMP("PS",$J)
"RTN","RORRP9",114,0)
 . S RORI=0 F  S RORI=$O(^TMP("ROR-PS-LIST",$J,RORI)) Q:'RORI  D
"RTN","RORRP9",115,0)
 . . N RORTYP
"RTN","RORRP9",116,0)
 . . S RORTYP=$P($G(^TMP("ROR-PS-LIST",$J,RORI,0)),"^",1)
"RTN","RORRP9",117,0)
 . . I ((RORTYP'["R;O")&(RORTYP'["U;I")) Q
"RTN","RORRP9",118,0)
 . . I RORTYP["U;I" D  I ((RORIDATE<RORSTDT)!(RORIDATE>RORENDT)) Q
"RTN","RORRP9",119,0)
 . . . S RORIDATE=+$P($G(^TMP("ROR-PS-LIST",$J,RORI,0)),"^",15)
"RTN","RORRP9",120,0)
 . . I RORTYP["R;O" D  Q:RORIDATE<RORSTDT
"RTN","RORRP9",121,0)
 . . . S RORIDATE=+$P($G(^TMP("ROR-PS-LIST",$J,RORI,0)),"^",10)
"RTN","RORRP9",122,0)
 . . S RORDESC=$P($G(^TMP("ROR-PS-LIST",$J,RORI,0)),"^",2)
"RTN","RORRP9",123,0)
 . . S RORINC=0
"RTN","RORRP9",124,0)
 . . S RORJ="" F  S RORJ=$O(RORRX(RORJ)) Q:RORJ=""  D  Q:RORINC
"RTN","RORRP9",125,0)
 . . . I RORJ=RORDESC S RORINC=1 Q
"RTN","RORRP9",126,0)
 . . I RORINC D ADD(RORDFN,$P(^TMP("ROR-PS-LIST",$J,RORI,0),"^"),.RORNEW,RORSTDT,RORENDT,.RORCNT)
"RTN","RORRP9",127,0)
 K ^TMP("ROR-PS-LIST",$J)
"RTN","RORRP9",128,0)
 ;
"RTN","RORRP9",129,0)
 Q
"RTN","RORRP9",130,0)
 ;
"RTN","RORRP9",131,0)
EN2(RES,RORREG,RORHNDL,RORFLD) ; ROR STORE RPC HANDLE
"RTN","RORRP9",132,0)
 ;
"RTN","RORRP9",133,0)
 ; INPUT: RORREG - Registry Name                           (Required)
"RTN","RORRP9",134,0)
 ;        RORHNDL - Deferred RPC Handle                    (Required)
"RTN","RORRP9",135,0)
 ;        RORFLD - 16 for Drug Rep Handle, 18 for Loc Reg Rep Handle
"RTN","RORRP9",136,0)
 ;                 (16 and 18 used to refer to the field numbers,
"RTN","RORRP9",137,0)
 ;                  but these have changed in the data dictionary,
"RTN","RORRP9",138,0)
 ;                  which is why they appear a bit random!!!!!!)
"RTN","RORRP9",139,0)
 ;
"RTN","RORRP9",140,0)
 N RORNODE,RORPREV,RORRES,RORRES
"RTN","RORRP9",141,0)
 ;
"RTN","RORRP9",142,0)
 S RORREG=+$$REG^RORRP1($G(RORREG)) I RORREG<0 D  Q
"RTN","RORRP9",143,0)
 .S RES(0)="-1^Invalid Registry"
"RTN","RORRP9",144,0)
 ;
"RTN","RORRP9",145,0)
 S RORHNDL=$G(RORHNDL) I RORHNDL="" D  Q
"RTN","RORRP9",146,0)
 .S RES(0)="-1^Unknown Handle"
"RTN","RORRP9",147,0)
 ;
"RTN","RORRP9",148,0)
 S RORFLD=$S($G(RORFLD)="18":"3",1:"2")
"RTN","RORRP9",149,0)
 ;
"RTN","RORRP9",150,0)
 S RORNODE=+$O(^ROR(798.1,RORREG,13,"B",DUZ,0))
"RTN","RORRP9",151,0)
 I RORNODE D
"RTN","RORRP9",152,0)
 .S RORPREV=$P($G(^ROR(798.1,RORREG,13,RORNODE,0)),"^",RORFLD)
"RTN","RORRP9",153,0)
 .D:RORPREV]"" CLEAR^XWBDRPC(.RORRES,RORPREV)
"RTN","RORRP9",154,0)
 .S $P(^ROR(798.1,RORREG,13,RORNODE,0),"^",RORFLD)=RORHNDL
"RTN","RORRP9",155,0)
 E  D
"RTN","RORRP9",156,0)
 .N ROR1,NIEN,ERR
"RTN","RORRP9",157,0)
 .S ROR1(798.116,"+1,"_RORREG_",",.01)=DUZ
"RTN","RORRP9",158,0)
 .S ROR1(798.116,"+1,"_RORREG_",",RORFLD-1)=RORHNDL
"RTN","RORRP9",159,0)
 .D UPDATE^DIE("","ROR1","NIEN","ERR")
"RTN","RORRP9",160,0)
 ;
"RTN","RORRP9",161,0)
 S RES(0)=RORHNDL
"RTN","RORRP9",162,0)
 ;
"RTN","RORRP9",163,0)
 Q
"RTN","RORRP9",164,0)
 ;
"RTN","RORRP9",165,0)
EN3(RES,RORREG,RORFLD) ; ROR GET RPC HANDLE
"RTN","RORRP9",166,0)
 ;
"RTN","RORRP9",167,0)
 ; INPUT: RORREG - Registry Name                           (Required)
"RTN","RORRP9",168,0)
 ;        RORFLD - 16 for Drug Rep Handle, 18 for Loc Reg Rep Handle
"RTN","RORRP9",169,0)
 ;                 (16 and 18 used to refer to the field numbers,
"RTN","RORRP9",170,0)
 ;                  but these have changed in the data dictionary,
"RTN","RORRP9",171,0)
 ;                  which is why they appear a bit random!!!!!!)
"RTN","RORRP9",172,0)
 ;
"RTN","RORRP9",173,0)
 N RORNODE,RORRES
"RTN","RORRP9",174,0)
 ;
"RTN","RORRP9",175,0)
 S RORREG=+$$REG^RORRP1($G(RORREG)) I RORREG<0 D  Q
"RTN","RORRP9",176,0)
 .S RES(0)="-1^Invalid Registry"
"RTN","RORRP9",177,0)
 ;
"RTN","RORRP9",178,0)
 S RORFLD=$S($G(RORFLD)="18":"3",1:"2")
"RTN","RORRP9",179,0)
 ;
"RTN","RORRP9",180,0)
 S RORNODE=+$O(^ROR(798.1,RORREG,13,"B",DUZ,0))
"RTN","RORRP9",181,0)
 S RES(0)=$P($G(^ROR(798.1,RORREG,13,RORNODE,0)),"^",RORFLD)
"RTN","RORRP9",182,0)
 ;
"RTN","RORRP9",183,0)
 I RES(0)="" D  Q
"RTN","RORRP9",184,0)
 .S RES(0)=""
"RTN","RORRP9",185,0)
 .S RES(1)="Never Run"
"RTN","RORRP9",186,0)
 .S RES(2)=""
"RTN","RORRP9",187,0)
 ;
"RTN","RORRP9",188,0)
 D RPCCHK^XWBDRPC(.RORRES,RES(0))
"RTN","RORRP9",189,0)
 S RES(1)=$P(RORRES(0),"^",2)
"RTN","RORRP9",190,0)
 S RES(2)=$G(^XTMP(RES(0),"TASKID"))
"RTN","RORRP9",191,0)
 ; 
"RTN","RORRP9",192,0)
 Q
"RTN","RORRP9",193,0)
 ;
"RTN","RORRP9",194,0)
EN4(RES,RORREG,RORFLD) ; ROR CLEAR RPC HANDLE
"RTN","RORRP9",195,0)
 ;
"RTN","RORRP9",196,0)
 ; INPUT: RORREG - Registry Name                           (Required)
"RTN","RORRP9",197,0)
 ;        RORFLD - 16 for Drug Rep Handle, 18 for Loc Reg Rep Handle
"RTN","RORRP9",198,0)
 ;                 (16 and 18 used to refer to the field numbers,
"RTN","RORRP9",199,0)
 ;                  but these have changed in the data dictionary,
"RTN","RORRP9",200,0)
 ;                  which is why they appear a bit random!!!!!!)
"RTN","RORRP9",201,0)
 ;
"RTN","RORRP9",202,0)
 N RORNODE,RORPREV,RORRES
"RTN","RORRP9",203,0)
 ;
"RTN","RORRP9",204,0)
 S RORREG=+$$REG^RORRP1($G(RORREG)) I RORREG<0 D  Q
"RTN","RORRP9",205,0)
 .S RES="-1^Invalid Registry"
"RTN","RORRP9",206,0)
 ;
"RTN","RORRP9",207,0)
 S RORFLD=$S($G(RORFLD)="18":"3",1:"2")
"RTN","RORRP9",208,0)
 ;
"RTN","RORRP9",209,0)
 S RORNODE=+$O(^ROR(798.1,RORREG,13,"B",DUZ,0))
"RTN","RORRP9",210,0)
 ;
"RTN","RORRP9",211,0)
 S RORPREV=$P($G(^ROR(798.1,RORREG,13,RORNODE,0)),"^",RORFLD)
"RTN","RORRP9",212,0)
 ;
"RTN","RORRP9",213,0)
 I RORPREV]"" D
"RTN","RORRP9",214,0)
 .D CLEAR^XWBDRPC(.RORRES,RORPREV)
"RTN","RORRP9",215,0)
 .S $P(^ROR(798.1,RORREG,13,RORNODE,0),"^",RORFLD)=""
"RTN","RORRP9",216,0)
 ;
"RTN","RORRP9",217,0)
 S RES="1^Success"
"RTN","RORRP9",218,0)
 ;
"RTN","RORRP9",219,0)
 Q
"RTN","RORRP9",220,0)
 ;
"RTN","RORRP9",221,0)
RORLIST(RORCODE,RORREG) ;
"RTN","RORRP9",222,0)
 ;
"RTN","RORRP9",223,0)
 N RORDRG,RORIEN,RORNDC
"RTN","RORRP9",224,0)
 ;
"RTN","RORRP9",225,0)
 Q:'$G(RORREG)
"RTN","RORRP9",226,0)
 ;
"RTN","RORRP9",227,0)
 S RORNDC=0
"RTN","RORRP9",228,0)
 F  S RORNDC=$O(^ROR(798.1,RORREG,12,"B",RORNDC)) Q:'RORNDC  D
"RTN","RORRP9",229,0)
 .I '$D(^PSDRUG("NDC",RORNDC)) Q
"RTN","RORRP9",230,0)
 .S RORIEN=""
"RTN","RORRP9",231,0)
 .F  S RORIEN=$O(^PSDRUG("NDC",RORNDC,RORIEN)) Q:'RORIEN  D
"RTN","RORRP9",232,0)
 ..S RORDRG=$$GET1^DIQ(50,+RORIEN,.01,"E")
"RTN","RORRP9",233,0)
 ..S:RORDRG]"" RORCODE(RORDRG)=""
"RTN","RORRP9",234,0)
 ..S RORDRG=$$GET1^DIQ(50.68,+$$GET1^DIQ(50,+RORIEN,22,"I"),4)
"RTN","RORRP9",235,0)
 ..S:RORDRG]"" RORCODE(RORDRG)=""
"RTN","RORRP9",236,0)
 Q
"RTN","RORSET01")
0^48^B13765779
"RTN","RORSET01",1,0)
RORSET01 ;HCIOFO/SG - REGISTRY SETUP ROUTINE (VA HEPC) ; 4/29/02 9:50am
"RTN","RORSET01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORSET01",3,0)
 ;
"RTN","RORSET01",4,0)
 ;***** HEPC REGISTRY SETUP
"RTN","RORSET01",5,0)
 ;
"RTN","RORSET01",6,0)
 N RORERROR      ; Error processing data
"RTN","RORSET01",7,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORSET01",8,0)
 N RORPARM       ; Application parameters
"RTN","RORSET01",9,0)
 ;
"RTN","RORSET01",10,0)
 N LSNAME,RC,RORMNTSK,RORREG,RORSUSP,TMP
"RTN","RORSET01",11,0)
 N ZTCPU,ZTDESC,ZTIO,ZTKIL,ZTPRI,ZTRTN,ZTSAVE,ZTSK,ZTSYNC,ZTUCI
"RTN","RORSET01",12,0)
 S RORPARM("ERR")=1         ; Enable error processing
"RTN","RORSET01",13,0)
 S RORPARM("SETUP")=1       ; Registry setup indicator
"RTN","RORSET01",14,0)
 ;
"RTN","RORSET01",15,0)
 S LSNAME="VA HEPC"
"RTN","RORSET01",16,0)
 ;--- IEN and name of the registry
"RTN","RORSET01",17,0)
 S $P(RORREG,U,2)="VA HEPC"
"RTN","RORSET01",18,0)
 S TMP=$$REGIEN^RORUTL02($P(RORREG,U,2))  G:TMP<0 ERROR
"RTN","RORSET01",19,0)
 S $P(RORREG,U,1)=TMP
"RTN","RORSET01",20,0)
 ;
"RTN","RORSET01",21,0)
 ;--- Check the Lab Search
"RTN","RORSET01",22,0)
 S RC=$$LABSRCH^RORSETU2(LSNAME)
"RTN","RORSET01",23,0)
 I RC<0  G:RC'=-55 ERROR  D  Q:RC<1  ;----------> ERROR
"RTN","RORSET01",24,0)
 . S RC=$$LSCONF^RORSETU1(LSNAME)
"RTN","RORSET01",25,0)
 ;
"RTN","RORSET01",26,0)
 ;--- Request setup parameters
"RTN","RORSET01",27,0)
 S RC=$$ASKPARMS^RORSETU1(.RORMNTSK,.RORSUSP)
"RTN","RORSET01",28,0)
 I RC<0  Q:(RC=-71)!(RC=-72)                    G ERROR
"RTN","RORSET01",29,0)
 ;
"RTN","RORSET01",30,0)
 ;--- Schedule the setup task
"RTN","RORSET01",31,0)
 S ZTRTN="TASK^RORSET01",ZTIO=""
"RTN","RORSET01",32,0)
 S ZTDESC="Registry Setup ("_$P(RORREG,U,2)_")"
"RTN","RORSET01",33,0)
 F TMP="RORMNTSK","RORREG","RORSUSP"  S ZTSAVE(TMP)=""
"RTN","RORSET01",34,0)
 D ^%ZTLOAD
"RTN","RORSET01",35,0)
 Q
"RTN","RORSET01",36,0)
ERROR ;--- Display the errors
"RTN","RORSET01",37,0)
 D DSPSTK^RORERR()
"RTN","RORSET01",38,0)
 Q
"RTN","RORSET01",39,0)
 ;
"RTN","RORSET01",40,0)
 ;***** REPLACES THE SELECTION RULES
"RTN","RORSET01",41,0)
 ;
"RTN","RORSET01",42,0)
 ; RORREG        Registry IEN and registry name separated by the '^'
"RTN","RORSET01",43,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORSET01",44,0)
 ; FROM,TO       Codes of the rule groups (1-regular, 2-historical)
"RTN","RORSET01",45,0)
 ;
"RTN","RORSET01",46,0)
 ; Return Values:
"RTN","RORSET01",47,0)
 ;       <0  Error code
"RTN","RORSET01",48,0)
 ;        0  Ok
"RTN","RORSET01",49,0)
 ;
"RTN","RORSET01",50,0)
RULES(RORREG,FROM,TO) ;
"RTN","RORSET01",51,0)
 ;;VA HEPC PTF^VA HEPC PTF HIST
"RTN","RORSET01",52,0)
 ;;VA HEPC VPOV^VA HEPC VISIT HIST
"RTN","RORSET01",53,0)
 ;
"RTN","RORSET01",54,0)
 N I,IEN,IENS,NAMES,RC,RORFDA,RORMSG
"RTN","RORSET01",55,0)
 S IENS=","_(+RORREG)_",",RC=0
"RTN","RORSET01",56,0)
 ;--- Replace the selection rules
"RTN","RORSET01",57,0)
 F I=1,2  D  Q:RC<0
"RTN","RORSET01",58,0)
 . S NAMES=$P($T(RULES+I),";;",2)  Q:NAMES?."^"
"RTN","RORSET01",59,0)
 . S IEN=$$FIND1^DIC(798.13,IENS,"X",$P(NAMES,U,FROM),"B",,"RORMSG")
"RTN","RORSET01",60,0)
 . Q:IEN=0
"RTN","RORSET01",61,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"RULES^RORPOSO1",,798.13)
"RTN","RORSET01",62,0)
 . Q:RC<0
"RTN","RORSET01",63,0)
 . S RORFDA(798.13,IEN_IENS,.01)=$P(NAMES,U,TO)
"RTN","RORSET01",64,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORSET01",65,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"RULES^RORPOSO1",,798.13,IEN_IENS)
"RTN","RORSET01",66,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORSET01",67,0)
 ;
"RTN","RORSET01",68,0)
 ;***** ENTRY POINT OF THE REGISTRY SETUP TASK
"RTN","RORSET01",69,0)
 ;
"RTN","RORSET01",70,0)
 ; RORMNTSK      Maximum number of the registry update subtasks
"RTN","RORSET01",71,0)
 ; RORREG        RegistryIEN^RegistryName
"RTN","RORSET01",72,0)
 ; RORSUSP       Task suspension time frame (StartTime^EndTime)
"RTN","RORSET01",73,0)
 ;
"RTN","RORSET01",74,0)
TASK ;
"RTN","RORSET01",75,0)
 N RORERROR      ; Error processing data
"RTN","RORSET01",76,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORSET01",77,0)
 N RORPARM       ; Application parameters
"RTN","RORSET01",78,0)
 ;
"RTN","RORSET01",79,0)
 N RC,REGLST,TMP
"RTN","RORSET01",80,0)
 S RORPARM("DEVELOPER")=1   ; Enable modifications
"RTN","RORSET01",81,0)
 S RORPARM("ERR")=1         ; Enable error processing
"RTN","RORSET01",82,0)
 S RORPARM("LOG")=1         ; Enable event recording
"RTN","RORSET01",83,0)
 S RORPARM("SETUP")=1       ; Registry setup indicator
"RTN","RORSET01",84,0)
 ;
"RTN","RORSET01",85,0)
 S REGLST($P(RORREG,U,2))=+RORREG
"RTN","RORSET01",86,0)
 ;--- Open a new log
"RTN","RORSET01",87,0)
 S RC=$$OPEN^RORLOG(.REGLST,0,"REGISTRY SETUP STARTED")
"RTN","RORSET01",88,0)
 D
"RTN","RORSET01",89,0)
 . ;--- Replace the selection rules with historical ones
"RTN","RORSET01",90,0)
 . S RC=$$RULES(RORREG,1,2)                             Q:RC<0
"RTN","RORSET01",91,0)
 . ;--- Populate the registry
"RTN","RORSET01",92,0)
 . S RC=$$UPDATE^RORUPD(.REGLST,,RORMNTSK,RORSUSP,"E")  Q:RC<0
"RTN","RORSET01",93,0)
 . D LOG^RORLOG(2,"The registry has been populated.")
"RTN","RORSET01",94,0)
 . ;--- Setup the registry
"RTN","RORSET01",95,0)
 . S RC=$$PREPARE^RORSETU2(RORREG)
"RTN","RORSET01",96,0)
 ;
"RTN","RORSET01",97,0)
 ;--- Restore the regular selection rules
"RTN","RORSET01",98,0)
 S TMP=$$RULES(RORREG,2,1)  I TMP<0  S:RC'<0 RC=TMP
"RTN","RORSET01",99,0)
 ;--- Close the log
"RTN","RORSET01",100,0)
 S TMP="REGISTRY SETUP "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","RORSET01",101,0)
 D CLOSE^RORLOG(TMP)
"RTN","RORSET01",102,0)
 ;--- Send an alert to the originator of the task
"RTN","RORSET01",103,0)
 S TMP=$S(RC<0:-43,1:-41)
"RTN","RORSET01",104,0)
 D ALERT^RORKIDS(DUZ,TMP,$P(RORREG,U,2),,"registry setup")
"RTN","RORSET01",105,0)
 I RC'<0  D  S ZTREQ="@"
"RTN","RORSET01",106,0)
 . K ^XTMP("RORUPDR"_+RORREG)
"RTN","RORSET01",107,0)
 Q
"RTN","RORSETU1")
0^49^B18226974
"RTN","RORSETU1",1,0)
RORSETU1 ;HCIOFO/SG - SETUP UTILITIES (USER INTERFACE) ; 4/19/02 10:05am
"RTN","RORSETU1",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORSETU1",3,0)
 ;
"RTN","RORSETU1",4,0)
 Q
"RTN","RORSETU1",5,0)
 ;
"RTN","RORSETU1",6,0)
 ;***** REQUESTS SETUP PARAMETERS FROM THE USER
"RTN","RORSETU1",7,0)
 ;
"RTN","RORSETU1",8,0)
 ; .MAXNTSK      Maximum number of registry update subtasks is
"RTN","RORSETU1",9,0)
 ;               returned via this parameter
"RTN","RORSETU1",10,0)
 ;
"RTN","RORSETU1",11,0)
 ; .SUSPEND      Start and end times of registry setup suspension
"RTN","RORSETU1",12,0)
 ;               are returned via this parameter
"RTN","RORSETU1",13,0)
 ;
"RTN","RORSETU1",14,0)
 ; Return Values:
"RTN","RORSETU1",15,0)
 ;       <0  Error code
"RTN","RORSETU1",16,0)
 ;        0  Ok
"RTN","RORSETU1",17,0)
 ;
"RTN","RORSETU1",18,0)
ASKPARMS(MAXNTSK,SUSPEND) ;
"RTN","RORSETU1",19,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,RC,X,Y
"RTN","RORSETU1",20,0)
 S MAXNTSK=0,SUSPEND=""
"RTN","RORSETU1",21,0)
 ;---
"RTN","RORSETU1",22,0)
 S DIR(0)="N^0:10:0",DIR("B")=5
"RTN","RORSETU1",23,0)
 S DIR("A")="Maximum number of registry update subtasks"
"RTN","RORSETU1",24,0)
 D LOADPRM("PRM01"),^DIR
"RTN","RORSETU1",25,0)
 Q:$D(DUOUT) -71  Q:$D(DTOUT) -72
"RTN","RORSETU1",26,0)
 S MAXNTSK=Y
"RTN","RORSETU1",27,0)
 ;---
"RTN","RORSETU1",28,0)
 S DIR(0)="Y",DIR("B")="NO"
"RTN","RORSETU1",29,0)
 S DIR("A")="Suspend the post-install during the peak hours"
"RTN","RORSETU1",30,0)
 D LOADPRM("PRM02"),^DIR
"RTN","RORSETU1",31,0)
 Q:$D(DUOUT) -71  Q:$D(DTOUT) -72
"RTN","RORSETU1",32,0)
 ;---
"RTN","RORSETU1",33,0)
 S RC=0
"RTN","RORSETU1",34,0)
 F  Q:'$G(Y)  D  Q:RC<0
"RTN","RORSETU1",35,0)
 . S DIR(0)="D^::R",DIR("B")="7:00AM"
"RTN","RORSETU1",36,0)
 . S DIR("A")="Suspension start time"
"RTN","RORSETU1",37,0)
 . D LOADPRM("PRM03"),^DIR
"RTN","RORSETU1",38,0)
 . I $D(DUOUT)  S RC=-71  Q
"RTN","RORSETU1",39,0)
 . I $D(DTOUT)  S RC=-72  Q
"RTN","RORSETU1",40,0)
 . S $P(SUSPEND,U,1)=Y#1
"RTN","RORSETU1",41,0)
 . ;---
"RTN","RORSETU1",42,0)
 . S DIR(0)="D^::R",DIR("B")="6:00PM"
"RTN","RORSETU1",43,0)
 . S DIR("A")="Suspension end time"
"RTN","RORSETU1",44,0)
 . D LOADPRM("PRM04"),^DIR
"RTN","RORSETU1",45,0)
 . I $D(DUOUT)  S RC=-71  Q
"RTN","RORSETU1",46,0)
 . I $D(DTOUT)  S RC=-72  Q
"RTN","RORSETU1",47,0)
 . S $P(SUSPEND,U,2)=Y#1
"RTN","RORSETU1",48,0)
 . ;---
"RTN","RORSETU1",49,0)
 . I $P(SUSPEND,U,2)>$P(SUSPEND,U,1)  S Y=0  Q
"RTN","RORSETU1",50,0)
 . W " ??",!!,"The end time must be later than the start time.",!
"RTN","RORSETU1",51,0)
 ;---
"RTN","RORSETU1",52,0)
 Q RC
"RTN","RORSETU1",53,0)
 ;
"RTN","RORSETU1",54,0)
 ;***** LOADS TEXT OF THE PROMPT(S) INTO DIR("?")
"RTN","RORSETU1",55,0)
 ;
"RTN","RORSETU1",56,0)
 ; TAG           Name of TAG in this routine that is followed by
"RTN","RORSETU1",57,0)
 ;               the text of the prompt
"RTN","RORSETU1",58,0)
 ;
"RTN","RORSETU1",59,0)
LOADPRM(TAG) ;
"RTN","RORSETU1",60,0)
 N I,TMP  K DIR("?")
"RTN","RORSETU1",61,0)
 S DIR("?")=$P($T(@TAG+1),";;",2)
"RTN","RORSETU1",62,0)
 F I=2:1  S TMP=$T(@TAG+I)  Q:TMP'[";;"  S DIR("?",I-1)=$P(TMP,";;",2)
"RTN","RORSETU1",63,0)
 Q
"RTN","RORSETU1",64,0)
 ;
"RTN","RORSETU1",65,0)
 ;***** ASKS FOR CONFIRMATION IF THERE ARE NO SEARCH INDICATORS
"RTN","RORSETU1",66,0)
 ;
"RTN","RORSETU1",67,0)
 ; LSNAME        Name of the Lab Search
"RTN","RORSETU1",68,0)
 ;
"RTN","RORSETU1",69,0)
 ; Return Values:
"RTN","RORSETU1",70,0)
 ;       <0  Error code
"RTN","RORSETU1",71,0)
 ;        0  Exit the registry setup
"RTN","RORSETU1",72,0)
 ;       >1  Continue the setup
"RTN","RORSETU1",73,0)
 ;
"RTN","RORSETU1",74,0)
LSCONF(LSNAME) ;
"RTN","RORSETU1",75,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,RC,X,Y
"RTN","RORSETU1",76,0)
 S DIR(0)="Y",DIR("B")="NO"
"RTN","RORSETU1",77,0)
 S DIR("A")="Continue the registry setup"
"RTN","RORSETU1",78,0)
 S DIR("A",1)=""
"RTN","RORSETU1",79,0)
 S DIR("A",2)="The '"_LSNAME_"' Lab Search contains no active search indicators."
"RTN","RORSETU1",80,0)
 D ^DIR
"RTN","RORSETU1",81,0)
 Q $S($D(DUOUT):-71,$D(DTOUT):-72,1:+Y)
"RTN","RORSETU1",82,0)
 ;
"RTN","RORSETU1",83,0)
 ;***** TEXT OF THE PROMPTS
"RTN","RORSETU1",84,0)
PRM01 ;
"RTN","RORSETU1",85,0)
 ;;Enter a number between 0 and 10, 0 decimal digits.
"RTN","RORSETU1",86,0)
 ;;During the initial registry population performed by the post-
"RTN","RORSETU1",87,0)
 ;;install routine several registry update subtask can be scheduled.
"RTN","RORSETU1",88,0)
PRM02 ;
"RTN","RORSETU1",89,0)
 ;;Enter either 'Y' or 'N'.
"RTN","RORSETU1",90,0)
 ;;If you answer YES to this question, registry update subtasks that
"RTN","RORSETU1",91,0)
 ;;populate the registry will be suspended during the peak weekday
"RTN","RORSETU1",92,0)
 ;;hours to conserve the CPU resources.
"RTN","RORSETU1",93,0)
 ;;
"RTN","RORSETU1",94,0)
 ;;The tasks will not be suspended on weekends and holidays. If the
"RTN","RORSETU1",95,0)
 ;;initial registry update runs in the single-task mode, it will never
"RTN","RORSETU1",96,0)
 ;;be suspended.
"RTN","RORSETU1",97,0)
 ;;
"RTN","RORSETU1",98,0)
 ;;Two additional prompts will be displayed asking you to enter start 
"RTN","RORSETU1",99,0)
 ;;and end time of the suspension.
"RTN","RORSETU1",100,0)
PRM03 ;
"RTN","RORSETU1",101,0)
 ;;Enter time of the day (e.g. 8AM)
"RTN","RORSETU1",102,0)
 ;;Registry update subtasks will be suspended after this time every
"RTN","RORSETU1",103,0)
 ;;day except the weekends and holidays. However, they will be
"RTN","RORSETU1",104,0)
 ;;checking for a stop request every hour during the suspension.
"RTN","RORSETU1",105,0)
PRM04 ;
"RTN","RORSETU1",106,0)
 ;;Enter time of the day (e.g. 5PM)
"RTN","RORSETU1",107,0)
 ;;The registry update subtasks will be resumed at this time every
"RTN","RORSETU1",108,0)
 ;;day. The suspension end time must be later than the suspension
"RTN","RORSETU1",109,0)
 ;;start time.
"RTN","RORSETU2")
0^50^B12631212
"RTN","RORSETU2",1,0)
RORSETU2 ;HCIOFO/SG - SETUP UTILITIES (REGISTRY) ; 5/3/02 9:26am
"RTN","RORSETU2",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORSETU2",3,0)
 ;
"RTN","RORSETU2",4,0)
 Q
"RTN","RORSETU2",5,0)
 ;
"RTN","RORSETU2",6,0)
 ;***** DRAWS THE BOUNDARY BETWEEN HISTORICAL AND REGULAR EXTRACTIONS
"RTN","RORSETU2",7,0)
 ;
"RTN","RORSETU2",8,0)
 ; REGIEN        Registry IEN
"RTN","RORSETU2",9,0)
 ; .BNDRYDT      Date that represents a boundary between historical
"RTN","RORSETU2",10,0)
 ;               data extraction and regular data extracts is returned
"RTN","RORSETU2",11,0)
 ;               via this parameter.
"RTN","RORSETU2",12,0)
 ;
"RTN","RORSETU2",13,0)
 ; Return Values:
"RTN","RORSETU2",14,0)
 ;       <0  Error code
"RTN","RORSETU2",15,0)
 ;      >=0  Statistics
"RTN","RORSETU2",16,0)
 ;             ^1: Total number of processed records
"RTN","RORSETU2",17,0)
 ;             ^2: Number of records processed with errors
"RTN","RORSETU2",18,0)
 ;
"RTN","RORSETU2",19,0)
 ; The function calculates a date that will be a boundary between
"RTN","RORSETU2",20,0)
 ; historical data extraction and regular data extractions. This date
"RTN","RORSETU2",21,0)
 ; is stored to all records of the registry. Moreover, the date is
"RTN","RORSETU2",22,0)
 ; returned as a value of the second parameter.
"RTN","RORSETU2",23,0)
 ;
"RTN","RORSETU2",24,0)
BNDRYDT(REGIEN,BNDRYDT) ;
"RTN","RORSETU2",25,0)
 N CNT,DATE,ECNT,IEN,IENS,LD1,PATIEN,RC,ROOT,RORFDA,RORMSG,TMP
"RTN","RORSETU2",26,0)
 S ROOT=$$ROOT^DILFD(798,,1)
"RTN","RORSETU2",27,0)
 ;--- Get the lag period
"RTN","RORSETU2",28,0)
 S LD1=$$GET1^DIQ(798.1,REGIEN_",",15.1,,,"RORMSG")
"RTN","RORSETU2",29,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"BNDRYDT^RORSETU2")  Q:RC<0 RC
"RTN","RORSETU2",30,0)
 ;--- Calculate the date
"RTN","RORSETU2",31,0)
 S BNDRYDT=$$FMADD^XLFDT($$DT^XLFDT,-$S(LD1>0:LD1,1:1)-1)
"RTN","RORSETU2",32,0)
 ;--- Store the date into the records of the registry
"RTN","RORSETU2",33,0)
 S IEN="",(CNT,ECNT)=0
"RTN","RORSETU2",34,0)
 F  S IEN=$O(@ROOT@("AC",REGIEN,IEN))  Q:IEN=""  D
"RTN","RORSETU2",35,0)
 . S CNT=CNT+1,IENS=IEN_",",DATE=BNDRYDT
"RTN","RORSETU2",36,0)
 . ;--- Check the inactivation date
"RTN","RORSETU2",37,0)
 . S TMP=$$GET1^DIQ(798,IENS,2,"I",,"RORMSG")\1
"RTN","RORSETU2",38,0)
 . I $G(DIERR)  D  S ECNT=ECNT+1  Q
"RTN","RORSETU2",39,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"BNDRYDT^RORSETU2")
"RTN","RORSETU2",40,0)
 . I TMP>0  S:DATE>TMP DATE=TMP
"RTN","RORSETU2",41,0)
 . ;--- Update the record
"RTN","RORSETU2",42,0)
 . S RORFDA(798,IENS,9.1)=DATE
"RTN","RORSETU2",43,0)
 . S RORFDA(798,IENS,9.2)=DATE
"RTN","RORSETU2",44,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORSETU2",45,0)
 . I $G(DIERR)  D  S ECNT=ECNT+1  Q
"RTN","RORSETU2",46,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"BNDRYDT^RORSETU2")
"RTN","RORSETU2",47,0)
 Q $S(RC<0:-9,1:CNT_U_ECNT)
"RTN","RORSETU2",48,0)
 ;
"RTN","RORSETU2",49,0)
 ;***** CHECKS THE LAB SEARCH CRITERION
"RTN","RORSETU2",50,0)
 ;
"RTN","RORSETU2",51,0)
 ; LSNAME        Name of the Lab search criterion
"RTN","RORSETU2",52,0)
 ;
"RTN","RORSETU2",53,0)
 ; This function uses the ^TMP("DILIST",$J) global node.
"RTN","RORSETU2",54,0)
 ;
"RTN","RORSETU2",55,0)
 ; Return Values:
"RTN","RORSETU2",56,0)
 ;       <0  Error code
"RTN","RORSETU2",57,0)
 ;        0  Ok
"RTN","RORSETU2",58,0)
 ;
"RTN","RORSETU2",59,0)
LABSRCH(LSNAME) ;
"RTN","RORSETU2",60,0)
 N IEN,IENS,IR,LSICNT,RC,RORMSG,TMP
"RTN","RORSETU2",61,0)
 ;--- Find the definition
"RTN","RORSETU2",62,0)
 S IENS=$$FIND1^DIC(798.9,,"X",LSNAME,"B",,"RORMSG")_","
"RTN","RORSETU2",63,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"LABSRCH^RORSETU2")  Q:RC<0 RC
"RTN","RORSETU2",64,0)
 Q:IENS'>0 $$ERROR^RORERR(-54,"LABSRCH^RORSETU2",,,LSNAME)
"RTN","RORSETU2",65,0)
 ;--- Load the search indicators
"RTN","RORSETU2",66,0)
 D LIST^DIC(798.92,","_IENS,"@;1I",,,,,"B",,,,"RORMSG")
"RTN","RORSETU2",67,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"LABSRCH^RORSETU2")  Q:RC<0 RC
"RTN","RORSETU2",68,0)
 ;--- Check the search indicators
"RTN","RORSETU2",69,0)
 S IR="",LSICNT=0
"RTN","RORSETU2",70,0)
 F  S IR=$O(^TMP("DILIST",$J,"ID",IR))  Q:IR=""  D
"RTN","RORSETU2",71,0)
 . S:$G(^TMP("DILIST",$J,"ID",IR,1))>0 LSICNT=LSICNT+1
"RTN","RORSETU2",72,0)
 ;--- Process the errors (if any)
"RTN","RORSETU2",73,0)
 Q:LSICNT'>0 $$ERROR^RORERR(-55,"LABSRCH^RORSETU2",,,LSNAME)
"RTN","RORSETU2",74,0)
 Q 0
"RTN","RORSETU2",75,0)
 ;
"RTN","RORSETU2",76,0)
 ;***** PREPARES REGISTRY RECORDS
"RTN","RORSETU2",77,0)
 ;
"RTN","RORSETU2",78,0)
 ; RORREG        Registry IEN and registry name separated by the '^'
"RTN","RORSETU2",79,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORSETU2",80,0)
 ;
"RTN","RORSETU2",81,0)
 ; Return Values:
"RTN","RORSETU2",82,0)
 ;       <0  Error code
"RTN","RORSETU2",83,0)
 ;        0  Ok
"RTN","RORSETU2",84,0)
 ;
"RTN","RORSETU2",85,0)
PREPARE(RORREG) ;
"RTN","RORSETU2",86,0)
 ;;Data extraction boundary (historical/regular) has been established.
"RTN","RORSETU2",87,0)
 ;;Parameters of the historical data extraction have been updated.
"RTN","RORSETU2",88,0)
 ;
"RTN","RORSETU2",89,0)
 N DATE,RC,TMP
"RTN","RORSETU2",90,0)
 ;--- Modify records of the registry
"RTN","RORSETU2",91,0)
 S RC=$$BNDRYDT(+RORREG,.DATE)  Q:RC<0 RC
"RTN","RORSETU2",92,0)
 S TMP="Processed records: "_+RC_", Errors: "_+$P(RC,U,2)
"RTN","RORSETU2",93,0)
 D LOG^RORLOG(2,$P($T(PREPARE+1),";;",2),,TMP)
"RTN","RORSETU2",94,0)
 ;--- Update registry parameters of the historical data extraction
"RTN","RORSETU2",95,0)
 S RC=$$UPDHDTRP(+RORREG,DATE)  Q:RC<0 RC
"RTN","RORSETU2",96,0)
 D LOG^RORLOG(2,$P($T(PREPARE+2),";;",2))
"RTN","RORSETU2",97,0)
 Q 0
"RTN","RORSETU2",98,0)
 ;
"RTN","RORSETU2",99,0)
 ;***** UPDATES REGISTRY PARAMETERS OF THE HISTORICAL DATA EXTRACTION
"RTN","RORSETU2",100,0)
 ;
"RTN","RORSETU2",101,0)
 ; REGIEN        Registry IEN
"RTN","RORSETU2",102,0)
 ; HDTEDT        Date that represents a boundary between historical
"RTN","RORSETU2",103,0)
 ;               data extraction and regular data extracts
"RTN","RORSETU2",104,0)
 ;
"RTN","RORSETU2",105,0)
 ; Return Values:
"RTN","RORSETU2",106,0)
 ;       <0  Error code
"RTN","RORSETU2",107,0)
 ;        0  Ok
"RTN","RORSETU2",108,0)
 ;
"RTN","RORSETU2",109,0)
UPDHDTRP(REGIEN,HDTEDT) ;
"RTN","RORSETU2",110,0)
 N IENS,RC,RORFDA,RORMSG
"RTN","RORSETU2",111,0)
 S IENS=REGIEN_","
"RTN","RORSETU2",112,0)
 ;--- Prepare the data
"RTN","RORSETU2",113,0)
 S RORFDA(798.1,IENS,21.02)=HDTEDT           ; Historical End Date
"RTN","RORSETU2",114,0)
 S RORFDA(798.1,IENS,21.05)=$$NOW^XLFDT      ; Timestamp
"RTN","RORSETU2",115,0)
 ;--- Update historical data extraction parameters
"RTN","RORSETU2",116,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORSETU2",117,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"UPDHDTRP^RORSETU2")  Q:RC<0 RC
"RTN","RORSETU2",118,0)
 ;--- Create the default data extraction task
"RTN","RORSETU2",119,0)
 S RC=$$CREATE^RORHDT02(REGIEN,1)
"RTN","RORSETU2",120,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORTSITE")
0^81^B13329926
"RTN","RORTSITE",1,0)
RORTSITE ;HCIOFO/SG - PREPARE TEST SITES FOR GOING LIVE ; 5/10/02 11:43am
"RTN","RORTSITE",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORTSITE",3,0)
 ;
"RTN","RORTSITE",4,0)
 Q
"RTN","RORTSITE",5,0)
 ;
"RTN","RORTSITE",6,0)
 ;***** PREPARE TEST SITE
"RTN","RORTSITE",7,0)
START ;
"RTN","RORTSITE",8,0)
 N RORERROR      ; Error processing data
"RTN","RORTSITE",9,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORTSITE",10,0)
 N RORPARM       ; Application parameters
"RTN","RORTSITE",11,0)
 ;
"RTN","RORTSITE",12,0)
 N DA,DATE,DIR,DIROUT,DIRUT,DTOUT,DUOUT,RC,REGIEN,X,Y
"RTN","RORTSITE",13,0)
 K DIR  S DIR(0)="Y",DIR("B")="NO"
"RTN","RORTSITE",14,0)
 S DIR("A")="Prepare the site for going live"
"RTN","RORTSITE",15,0)
 D ^DIR  W !  Q:$D(DIRUT)!'$G(Y)
"RTN","RORTSITE",16,0)
 ;
"RTN","RORTSITE",17,0)
 S RORPARM("DEBUG")=2       ; Debug mode (display messages)
"RTN","RORTSITE",18,0)
 S RORPARM("ERR")=1         ; Enable error processing
"RTN","RORTSITE",19,0)
 S RORPARM("LOG")=1         ; Enable error recording
"RTN","RORTSITE",20,0)
 D INIT^RORUTL01("ROR",1)
"RTN","RORTSITE",21,0)
 ;
"RTN","RORTSITE",22,0)
 S REGIEN=$$REGIEN^RORUTL02("VA HEPC")
"RTN","RORTSITE",23,0)
 I REGIEN<0  D:REGIEN>-3  G ERROR
"RTN","RORTSITE",24,0)
 . S RC=$$ERROR^RORERR(REGIEN,"START^RORTSITE")
"RTN","RORTSITE",25,0)
 ;
"RTN","RORTSITE",26,0)
 W !,"Updating registry records...",!
"RTN","RORTSITE",27,0)
 S RC=$$RECORDS(REGIEN,.DATE)  G:RC<0 ERROR
"RTN","RORTSITE",28,0)
 W "Processed records: "_+RC_", Errors: "_+$P(RC,U,2),!
"RTN","RORTSITE",29,0)
 ;
"RTN","RORTSITE",30,0)
 W !,"Updating registry parameters..."
"RTN","RORTSITE",31,0)
 G:$$REGPARM(REGIEN,DATE)<0 ERROR
"RTN","RORTSITE",32,0)
 W !,"Ok",!
"RTN","RORTSITE",33,0)
 Q
"RTN","RORTSITE",34,0)
 ;
"RTN","RORTSITE",35,0)
 ;***** DISPLAYS THE ERRORS
"RTN","RORTSITE",36,0)
ERROR ;
"RTN","RORTSITE",37,0)
 D DSPSTK^RORERR()
"RTN","RORTSITE",38,0)
 Q
"RTN","RORTSITE",39,0)
 ;
"RTN","RORTSITE",40,0)
 ;***** PREPARE REGISTRY RECORDS
"RTN","RORTSITE",41,0)
RECORDS(REGIEN,BNDRYDT) ;
"RTN","RORTSITE",42,0)
 N CNT,DATE,ECNT,IEN,IENS,LD1,PATIEN,RC,ROOT,RORBUF,RORFDA,RORMSG,TMP
"RTN","RORTSITE",43,0)
 S ROOT=$$ROOT^DILFD(798,,1)
"RTN","RORTSITE",44,0)
 ;--- Get the lag period
"RTN","RORTSITE",45,0)
 S LD1=$$GET1^DIQ(798.1,REGIEN_",",15.1,,,"RORMSG")
"RTN","RORTSITE",46,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"RECORDS^RORTSITE")  Q:RC<0 RC
"RTN","RORTSITE",47,0)
 ;--- Calculate the date
"RTN","RORTSITE",48,0)
 S BNDRYDT=$$FMADD^XLFDT($$DT^XLFDT,-$S(LD1>0:LD1,1:1)-1)
"RTN","RORTSITE",49,0)
 ;--- Store the date into the records of the registry
"RTN","RORTSITE",50,0)
 S IEN="",(CNT,ECNT)=0
"RTN","RORTSITE",51,0)
 F  S IEN=$O(@ROOT@("AC",REGIEN,IEN))  Q:IEN=""  D
"RTN","RORTSITE",52,0)
 . S CNT=CNT+1  W:'(CNT#10) *13,CNT
"RTN","RORTSITE",53,0)
 . S IENS=IEN_",",DATE=BNDRYDT
"RTN","RORTSITE",54,0)
 . K RORBUF,RORMSG
"RTN","RORTSITE",55,0)
 . D GETS^DIQ(798,IENS,"2;8","EI","RORBUF","RORMSG")
"RTN","RORTSITE",56,0)
 . I $G(DIERR)  D  S ECNT=ECNT+1  Q
"RTN","RORTSITE",57,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"RECORDS^RORTSITE")
"RTN","RORTSITE",58,0)
 . ;--- Check the inactivation date if the record is not active
"RTN","RORTSITE",59,0)
 . I '$G(RORBUF(798,IENS,8,"E"))  D  S:DATE>TMP DATE=TMP
"RTN","RORTSITE",60,0)
 . . S TMP=$G(RORBUF(798,IENS,2,"I"))
"RTN","RORTSITE",61,0)
 . ;--- Update the record
"RTN","RORTSITE",62,0)
 . S RORFDA(798,IENS,3)=1               ; NEW PATIENT
"RTN","RORTSITE",63,0)
 . S RORFDA(798,IENS,4)=1               ; UPDATE DEMOGRAPHICS
"RTN","RORTSITE",64,0)
 . S RORFDA(798,IENS,5)=1               ; UPDATE LOCAL REGISTRY DATA
"RTN","RORTSITE",65,0)
 . S RORFDA(798,IENS,9.1)=DATE          ; DATA ACKNOWLEDGED UNTIL
"RTN","RORTSITE",66,0)
 . S RORFDA(798,IENS,9.2)=DATE          ; DATA EXTRACTED UNTIL
"RTN","RORTSITE",67,0)
 . S RORFDA(798,IENS,10)="@"            ; MESSAGE ID
"RTN","RORTSITE",68,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORTSITE",69,0)
 . I $G(DIERR)  D  S ECNT=ECNT+1  Q
"RTN","RORTSITE",70,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"RECORDS^RORTSITE")
"RTN","RORTSITE",71,0)
 W:IEN="" *13
"RTN","RORTSITE",72,0)
 Q $S(RC<0:-9,1:CNT_U_ECNT)
"RTN","RORTSITE",73,0)
 ;
"RTN","RORTSITE",74,0)
 ;***** PREPARE REGISTRY PARAMETERS
"RTN","RORTSITE",75,0)
REGPARM(REGIEN,DATE) ;
"RTN","RORTSITE",76,0)
 N IENS,RC,RORFDA,RORMSG
"RTN","RORTSITE",77,0)
 S IENS=REGIEN_","
"RTN","RORTSITE",78,0)
 S RORFDA(798.1,IENS,2)=2960101         ; DATA EXTRACTED UNTIL
"RTN","RORTSITE",79,0)
 S RORFDA(798.1,IENS,2.1)="@"           ; LAST BATCH ID
"RTN","RORTSITE",80,0)
 S RORFDA(798.1,IENS,2.2)="@"           ; AWAITING ACKNOWLEDGEMENT
"RTN","RORTSITE",81,0)
 S RORFDA(798.1,IENS,2.3)="@"           ; LAST MESSAGE ID
"RTN","RORTSITE",82,0)
 S RORFDA(798.1,IENS,15.9)=1            ; DAYS TO WAIT FOR ACK
"RTN","RORTSITE",83,0)
 S RORFDA(798.1,IENS,21.02)=DATE        ; HDT END DATE
"RTN","RORTSITE",84,0)
 S RORFDA(798.1,IENS,21.05)=$$NOW^XLFDT ; HDT DATE/TIME
"RTN","RORTSITE",85,0)
 S RORFDA(798.1,IENS,25)=1              ; ENABLE PROTOCOLS
"RTN","RORTSITE",86,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORTSITE",87,0)
 Q $$DBS^RORERR("RORMSG",-9,"REGPARM^RORTSITE",,798.1,IENS)
"RTN","RORUPD")
0^51^B29619781
"RTN","RORUPD",1,0)
RORUPD ;HCIOFO/SG - REGISTRY UPDATE ; 5/6/02 8:51am
"RTN","RORUPD",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPD",3,0)
 ;
"RTN","RORUPD",4,0)
 ; RORLRC -------------- LIST OF LAB RESULT CODES TO CHECK
"RTN","RORUPD",5,0)
 ;
"RTN","RORUPD",6,0)
 ; RORLRC(Seq#)          Lab result code (see the LA7SC parameter of
"RTN","RORUPD",7,0)
 ;                       the GCPR^LA7QRY entry point)
"RTN","RORUPD",8,0)
 ;                         ^1: Result code
"RTN","RORUPD",9,0)
 ;                         ^2: Coding system ("LN" or "NLT")
"RTN","RORUPD",10,0)
 ;
"RTN","RORUPD",11,0)
 ; RORUPD -------------- REGISTRY UPDATE DESCRIPTOR
"RTN","RORUPD",12,0)
 ;
"RTN","RORUPD",13,0)
 ; RORUPD("DT")          Date/time when update process started
"RTN","RORUPD",14,0)
 ;
"RTN","RORUPD",15,0)
 ; RORUPD("DSBEG")       Start date of the data scan
"RTN","RORUPD",16,0)
 ; RORUPD("DSEND")       End date of the data scan
"RTN","RORUPD",17,0)
 ;                       (these nodes are set by $$PREPARE1^RORUPR)
"RTN","RORUPD",18,0)
 ;
"RTN","RORUPD",19,0)
 ; RORUPD("EETS")        Timestamp of the earliest event reference
"RTN","RORUPD",20,0)
 ;
"RTN","RORUPD",21,0)
 ; RORUPD("ERRCNT")      Counter of errors during processing of the
"RTN","RORUPD",22,0)
 ;                       current patient
"RTN","RORUPD",23,0)
 ;
"RTN","RORUPD",24,0)
 ; RORUPD("FLAGS")       Flags to control processing. The possible
"RTN","RORUPD",25,0)
 ;                       values (can be combined) are:
"RTN","RORUPD",26,0)
 ;                         "E" Use event references (file #798.3)
"RTN","RORUPD",27,0)
 ;
"RTN","RORUPD",28,0)
 ; RORUPD("JOB")         Job number of the main task. This node is
"RTN","RORUPD",29,0)
 ;                       defined only if the registry update is
"RTN","RORUPD",30,0)
 ;                       running in the multitask mode.
"RTN","RORUPD",31,0)
 ;
"RTN","RORUPD",32,0)
 ; RORUPD("LD",          Instead of checking data in the interval
"RTN","RORUPD",33,0)
 ;                       from start date till end date, update process
"RTN","RORUPD",34,0)
 ;                       starts checks from the start date minus
"RTN","RORUPD",35,0)
 ;                       appropriate number of lag days. Thus, data
"RTN","RORUPD",36,0)
 ;                       entered retrospectively will not be missed.
"RTN","RORUPD",37,0)
 ;   1)                  Lag days for data examination
"RTN","RORUPD",38,0)
 ;
"RTN","RORUPD",39,0)
 ; RORUPD("LM",          Loop control mode. It defines when to stop
"RTN","RORUPD",40,0)
 ;                       looping through records of the patient:
"RTN","RORUPD",41,0)
 ;                         0  always loop through all records
"RTN","RORUPD",42,0)
 ;                         1  all top level rules have been triggered
"RTN","RORUPD",43,0)
 ;                            for the patient (default)
"RTN","RORUPD",44,0)
 ;                         2  patient has been marked for addition to
"RTN","RORUPD",45,0)
 ;                            all registries being processed
"RTN","RORUPD",46,0)
 ;   1,Rule Name)        Current list of names of top level rules
"RTN","RORUPD",47,0)
 ;   2,Registry#)        Current list of registry IENs
"RTN","RORUPD",48,0)
 ;
"RTN","RORUPD",49,0)
 ; RORUPD("LM1",         STATIC LIST OF TOP LEVEL RULES
"RTN","RORUPD",50,0)
 ;   Rule Name)
"RTN","RORUPD",51,0)
 ;
"RTN","RORUPD",52,0)
 ; RORUPD("LM2",         STATIC LIST OF REGISTRIES
"RTN","RORUPD",53,0)
 ;   Registry#)            0  the patient is already in the registry
"RTN","RORUPD",54,0)
 ;                         1  the patient is not in the registry
"RTN","RORUPD",55,0)
 ;
"RTN","RORUPD",56,0)
 ; RORUPD("MAXPPCNT")    When counters in the ROR PENDING PATIENT
"RTN","RORUPD",57,0)
 ;                       file reach a value stored in this node, the
"RTN","RORUPD",58,0)
 ;                       corresponding patient will be skipped until
"RTN","RORUPD",59,0)
 ;                       someone fixes the error(s) and resets the
"RTN","RORUPD",60,0)
 ;                       counters to 1.
"RTN","RORUPD",61,0)
 ;
"RTN","RORUPD",62,0)
 ; RORUPD("ROOT",File#)  Closed root of the file
"RTN","RORUPD",63,0)
 ;
"RTN","RORUPD",64,0)
 ; RORUPD("SR",          PREPARED SELECTION RULES
"RTN","RORUPD",65,0)
 ;   File#,              This node is defined if the file should be
"RTN","RORUPD",66,0)
 ;                       processed
"RTN","RORUPD",67,0)
 ;
"RTN","RORUPD",68,0)
 ;     "A",              List of rules that should be applied after
"RTN","RORUPD",69,0)
 ;                       processing sub-files and linked files.
"RTN","RORUPD",70,0)
 ;     "B",              List of rules that should be applied before
"RTN","RORUPD",71,0)
 ;                       processing sub-files and linked files.
"RTN","RORUPD",72,0)
 ;       Seq#,             ^1: Selection Rule Name
"RTN","RORUPD",73,0)
 ;                         ^2: Rule# (Selection Rule IEN)
"RTN","RORUPD",74,0)
 ;                         ^3: 1 if registry should be updated if
"RTN","RORUPD",75,0)
 ;                             the expression evaluated as True
"RTN","RORUPD",76,0)
 ;                             (top-level seelction rule)
"RTN","RORUPD",77,0)
 ;         1)            MUMPS expression that implements the rule
"RTN","RORUPD",78,0)
 ;         2,Registry#)  List of IENs of affected registries
"RTN","RORUPD",79,0)
 ;
"RTN","RORUPD",80,0)
 ;     "F",              A list of data elements that should be loaded
"RTN","RORUPD",81,0)
 ;                       before applying selection rules is created
"RTN","RORUPD",82,0)
 ;                       under this node. The elements are grouped by
"RTN","RORUPD",83,0)
 ;                       the APIs used to load the values.
"RTN","RORUPD",84,0)
 ;       API#,           For API #1 (FileMan GETS^DIQ) this node
"RTN","RORUPD",85,0)
 ;                       contains a list of fields separated by ';'.
"RTN","RORUPD",86,0)
 ;         DataCode,     For data elements associated with the API #1
"RTN","RORUPD",87,0)
 ;                       this node stores the field number.
"RTN","RORUPD",88,0)
 ;           "E")        If an external value of the field should be
"RTN","RORUPD",89,0)
 ;                       loaded, a value of the field 4.1 of the
"RTN","RORUPD",90,0)
 ;                       subfile #799.22 is assigned to this node.
"RTN","RORUPD",91,0)
 ;           "I")        If an internal value of the field should be
"RTN","RORUPD",92,0)
 ;                       loaded, a value of the field 4.2 of the
"RTN","RORUPD",93,0)
 ;                       subfile #799.22 is assigned to this node.
"RTN","RORUPD",94,0)
 ;
"RTN","RORUPD",95,0)
 ; RORUPD("SUSPEND")     SUBTASKS SUSPENSION PARAMETERS
"RTN","RORUPD",96,0)
 ;                         ^1: Suspension start time (FileMan)
"RTN","RORUPD",97,0)
 ;                         ^2: Suspension end time (FileMan)
"RTN","RORUPD",98,0)
 ;
"RTN","RORUPD",99,0)
 ;                       For example, to suspend subtasks from
"RTN","RORUPD",100,0)
 ;                       7:00 until 18:00 this node should have
"RTN","RORUPD",101,0)
 ;                       the following value: ".07^.18".
"RTN","RORUPD",102,0)
 ;
"RTN","RORUPD",103,0)
 ; RORUPD("UPD",         CALL-BACK ENTRY POINTS
"RTN","RORUPD",104,0)
 ;   Registry#,1)        Entry point of a MUMPS external function
"RTN","RORUPD",105,0)
 ;                       that assign values of additional fields to
"RTN","RORUPD",106,0)
 ;                       the registry FDA before registry update
"RTN","RORUPD",107,0)
 ;                       (opt'l).
"RTN","RORUPD",108,0)
 ;   Registry#,2)        Entry point of a MUMPS external function
"RTN","RORUPD",109,0)
 ;                       that is called right after registry update
"RTN","RORUPD",110,0)
 ;                       (opt'l).
"RTN","RORUPD",111,0)
 ;
"RTN","RORUPD",112,0)
 ; RORUPDPI ------------ CLOSED ROOT OF THE TEMPORARY STORAGE
"RTN","RORUPD",113,0)
 ;                       (the ^TMP("RORUPD",$J), ^XTMP("RORUPDJ"_$J)
"RTN","RORUPD",114,0)
 ;                       or ^XTMP("RORUPDR"_Registry#) node)
"RTN","RORUPD",115,0)
 ;
"RTN","RORUPD",116,0)
 ; See also a description of ^XTMP("RORUPD"_) in the ^ROR01 routine.
"RTN","RORUPD",117,0)
 ;
"RTN","RORUPD",118,0)
 Q
"RTN","RORUPD",119,0)
 ;
"RTN","RORUPD",120,0)
 ;***** UPDATES THE REGISTRIES
"RTN","RORUPD",121,0)
 ;
"RTN","RORUPD",122,0)
 ; .RGLIST       Reference to a local array containing
"RTN","RORUPD",123,0)
 ;               registry names as subscripts
"RTN","RORUPD",124,0)
 ;
"RTN","RORUPD",125,0)
 ; [.REGLST]     Reference to a local variable where list of actually
"RTN","RORUPD",126,0)
 ;               processed registries is returned to (registries from
"RTN","RORUPD",127,0)
 ;               the source list except inactive and awaiting
"RTN","RORUPD",128,0)
 ;               acknowledgements). It contains registry names as
"RTN","RORUPD",129,0)
 ;               subscripts and registry IENs as values.
"RTN","RORUPD",130,0)
 ;
"RTN","RORUPD",131,0)
 ; [MAXNTSK]     Maximum number of the data processing subtasks.
"RTN","RORUPD",132,0)
 ;               See description of the $$PROCESS^RORUPD05 function
"RTN","RORUPD",133,0)
 ;               for details.
"RTN","RORUPD",134,0)
 ;
"RTN","RORUPD",135,0)
 ; [SUSPEND]     Subtask suspension parameters:
"RTN","RORUPD",136,0)
 ;               See description of the RORUPD("SUSPEND") node
"RTN","RORUPD",137,0)
 ;               for details.
"RTN","RORUPD",138,0)
 ;
"RTN","RORUPD",139,0)
 ; [CLRFLG]      Clear flags to control processing.
"RTN","RORUPD",140,0)
 ; [SETFLG]      Set flags to control processing.
"RTN","RORUPD",141,0)
 ;               See description of the RORUPD("FLAGS") node for
"RTN","RORUPD",142,0)
 ;               the possible values of the parameters.
"RTN","RORUPD",143,0)
 ;
"RTN","RORUPD",144,0)
 ; Return Values:
"RTN","RORUPD",145,0)
 ;       <0  Error code (see MSGLIST^RORERR20)
"RTN","RORUPD",146,0)
 ;        0  Ok
"RTN","RORUPD",147,0)
 ;
"RTN","RORUPD",148,0)
UPDATE(RGLIST,REGLST,MAXNTSK,SUSPEND,CLRFLG,SETFLG) ;
"RTN","RORUPD",149,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD",150,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORUPD",151,0)
 N RORLRC        ; List of Lab result codes to check
"RTN","RORUPD",152,0)
 N RORUPD        ; Update descriptor
"RTN","RORUPD",153,0)
 N RORUPDPI      ; Closed root of the temporary storage
"RTN","RORUPD",154,0)
 N RORVALS       ; Calculated values
"RTN","RORUPD",155,0)
 ;
"RTN","RORUPD",156,0)
 N COUNTERS,RC,REGNAME,REGIEN,TMP
"RTN","RORUPD",157,0)
 D INIT^RORUTL01("RORUPD")  K REGLST
"RTN","RORUPD",158,0)
 D CLEAR^RORERR("UPDATE^RORUPD")
"RTN","RORUPD",159,0)
 ;--- Value of the RORUPDPI variable is modified by the
"RTN","RORUPD",160,0)
 ;    $$PROCESS^RORUPD05 function if the registry update
"RTN","RORUPD",161,0)
 ;--- process runs in the multi-task mode.
"RTN","RORUPD",162,0)
 S RORUPDPI=$NA(^TMP("RORUPD",$J))
"RTN","RORUPD",163,0)
 ;--- Open a new log
"RTN","RORUPD",164,0)
 S TMP=$$SETUP^RORLOG(.RGLIST)
"RTN","RORUPD",165,0)
 S TMP=$$OPEN^RORLOG(.RGLIST,1,"REGISTRY UPDATE STARTED")
"RTN","RORUPD",166,0)
 D
"RTN","RORUPD",167,0)
 . ;--- Create a list of active registries
"RTN","RORUPD",168,0)
 . S RC=$$ARLST^RORUTL02(.RGLIST,.REGLST)  Q:RC<0
"RTN","RORUPD",169,0)
 . I $D(REGLST)<10  D  Q
"RTN","RORUPD",170,0)
 . . S RC=$$ERROR^RORERR(-28,"UPDATE^RORUPD",,,"update")
"RTN","RORUPD",171,0)
 . ;--- Lock parameters of the registries being processed
"RTN","RORUPD",172,0)
 . S RC=$$LOCKREG^RORUTL02(.REGLST,1)  Q:RC<0
"RTN","RORUPD",173,0)
 . I 'RC  D  K REGLST  Q
"RTN","RORUPD",174,0)
 . . S RC=$$ERROR^RORERR(-11,,,,"registries being processed")
"RTN","RORUPD",175,0)
 . ;--- Prepare selection rules
"RTN","RORUPD",176,0)
 . S:$G(SUSPEND) RORUPD("SUSPEND")=SUSPEND
"RTN","RORUPD",177,0)
 . S RC=$$PREPARE^RORUPR(.REGLST)
"RTN","RORUPD",178,0)
 . I RC<0  S RC=$$ERROR^RORERR(-14)  Q
"RTN","RORUPD",179,0)
 . ;--- Clear/Set the flags (override the default value)
"RTN","RORUPD",180,0)
 . S CLRFLG=$$UP^XLFSTR($G(CLRFLG))
"RTN","RORUPD",181,0)
 . S SETFLG=$$UP^XLFSTR($G(SETFLG))
"RTN","RORUPD",182,0)
 . S RORUPD("FLAGS")=$TR($G(RORUPD("FLAGS")),CLRFLG_SETFLG)_SETFLG
"RTN","RORUPD",183,0)
 . ;--- Display the debug information
"RTN","RORUPD",184,0)
 . D:$G(RORPARM("DEBUG"))>1 DEBUG^RORUPDUT
"RTN","RORUPD",185,0)
 . ;--- Look for new patients and update the registries
"RTN","RORUPD",186,0)
 . S RC=$$PROCESS^RORUPD05($G(MAXNTSK))  Q:RC<0
"RTN","RORUPD",187,0)
 . S COUNTERS=RC
"RTN","RORUPD",188,0)
 . ;--- Update registry parameters
"RTN","RORUPD",189,0)
 . S TMP=$$TMSTMP^RORUPD01(.REGLST)
"RTN","RORUPD",190,0)
 . ;--- Update demographic data
"RTN","RORUPD",191,0)
 . D LOG^RORLOG(,"DEMOGRAPHIC UPDATE STARTED")
"RTN","RORUPD",192,0)
 . S RC=$$UPDDEM^RORUPD51(.REGLST)
"RTN","RORUPD",193,0)
 ;
"RTN","RORUPD",194,0)
 ;--- Unlock parameters of processed registries
"RTN","RORUPD",195,0)
 S TMP=$$LOCKREG^RORUTL02(.REGLST,0)
"RTN","RORUPD",196,0)
 ;--- Statistics & Cleanup
"RTN","RORUPD",197,0)
 S TMP="REGISTRY UPDATE "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","RORUPD",198,0)
 D CLOSE^RORLOG(TMP,$G(COUNTERS))
"RTN","RORUPD",199,0)
 D:'$G(RORPARM("DEBUG"))
"RTN","RORUPD",200,0)
 . D INIT^RORUTL01("RORUPD")
"RTN","RORUPD",201,0)
 . ;--- Do not kill the list of processed patients ("U" subnode)
"RTN","RORUPD",202,0)
 . ;    in case of an error or crash during the initial registry
"RTN","RORUPD",203,0)
 . ;--- population (registry setup).
"RTN","RORUPD",204,0)
 . K:'$G(RORPARM("SETUP"))!(RC'<0) @RORUPDPI
"RTN","RORUPD",205,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPD01")
0^52^B59537811
"RTN","RORUPD01",1,0)
RORUPD01 ;HCIOFO/SG - PROCESSING OF THE FILES  ; 5/2/02 1:08pm
"RTN","RORUPD01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPD01",3,0)
 ;
"RTN","RORUPD01",4,0)
 ; This routine uses the following IA's:
"RTN","RORUPD01",5,0)
 ;
"RTN","RORUPD01",6,0)
 ; #3301         Access to the field #.6 of the file #2
"RTN","RORUPD01",7,0)
 ; #10035        Browse through IENs of the file #2
"RTN","RORUPD01",8,0)
 ;
"RTN","RORUPD01",9,0)
 Q
"RTN","RORUPD01",10,0)
 ;
"RTN","RORUPD01",11,0)
 ;***** CHECKS FOR A STOP REQUESTS (TASKMAN & PROPRIETARY)
"RTN","RORUPD01",12,0)
 ;
"RTN","RORUPD01",13,0)
 ; Return Values:
"RTN","RORUPD01",14,0)
 ;        0  Continue running
"RTN","RORUPD01",15,0)
 ;        1  Stop the subtask
"RTN","RORUPD01",16,0)
 ;
"RTN","RORUPD01",17,0)
CHKSTOP() ;
"RTN","RORUPD01",18,0)
 Q:'$G(RORUPD("JOB")) $$S^%ZTLOAD
"RTN","RORUPD01",19,0)
 L +@RORUPDPI@("T",0):0
"RTN","RORUPD01",20,0)
 I  L -@RORUPDPI@("T",0)  Q 1
"RTN","RORUPD01",21,0)
 Q $$S^%ZTLOAD
"RTN","RORUPD01",22,0)
 ;
"RTN","RORUPD01",23,0)
 ;***** LOAD DATA ELEMENTS
"RTN","RORUPD01",24,0)
 ;
"RTN","RORUPD01",25,0)
 ; IENS          IENS of the current record
"RTN","RORUPD01",26,0)
 ;
"RTN","RORUPD01",27,0)
 ; Return values:
"RTN","RORUPD01",28,0)
 ;       <0  Error code
"RTN","RORUPD01",29,0)
 ;        0  Ok
"RTN","RORUPD01",30,0)
 ;
"RTN","RORUPD01",31,0)
LOAD(IENS) ;
"RTN","RORUPD01",32,0)
 N RC  S RC=0
"RTN","RORUPD01",33,0)
 ;--- API #1
"RTN","RORUPD01",34,0)
 I $D(RORUPD("SR",2,"F",1))  D  Q:RC<0 RC
"RTN","RORUPD01",35,0)
 . S RC=$$LOADFLDS^RORUPDUT(2,IENS)
"RTN","RORUPD01",36,0)
 ;--- API #2
"RTN","RORUPD01",37,0)
 Q 0
"RTN","RORUPD01",38,0)
 ;
"RTN","RORUPD01",39,0)
 ;***** INITIALIZES LOOP CONTROL LISTS
"RTN","RORUPD01",40,0)
 ;
"RTN","RORUPD01",41,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD01",42,0)
 ;
"RTN","RORUPD01",43,0)
 ; Return Values:
"RTN","RORUPD01",44,0)
 ;       <0  Error code
"RTN","RORUPD01",45,0)
 ;        0  Ok
"RTN","RORUPD01",46,0)
 ;
"RTN","RORUPD01",47,0)
 ; The RORUPD("LM",1,Rule Name) list contains names of the top level
"RTN","RORUPD01",48,0)
 ; rules that have not been triggered by now.
"RTN","RORUPD01",49,0)
 ;
"RTN","RORUPD01",50,0)
 ; The RORUPD("LM",2,Registry#) list contains IENs of the registries
"RTN","RORUPD01",51,0)
 ; that do not contain the patient by now.
"RTN","RORUPD01",52,0)
 ;
"RTN","RORUPD01",53,0)
LOOPINIT(PATIEN) ;
"RTN","RORUPD01",54,0)
 N I,REGIEN
"RTN","RORUPD01",55,0)
 M RORUPD("LM",1)=RORUPD("LM1")
"RTN","RORUPD01",56,0)
 S REGIEN=""
"RTN","RORUPD01",57,0)
 F  S REGIEN=$O(RORUPD("LM2",REGIEN))  Q:REGIEN=""  D
"RTN","RORUPD01",58,0)
 . S RORUPD("LM2",REGIEN)='$D(^RORDATA(798,"KEY",PATIEN,REGIEN))
"RTN","RORUPD01",59,0)
 . S:RORUPD("LM2",REGIEN) RORUPD("LM",2,REGIEN)=""
"RTN","RORUPD01",60,0)
 Q 0
"RTN","RORUPD01",61,0)
 ;
"RTN","RORUPD01",62,0)
 ;***** PROCESS EVERY PATIENT IN THE 'PATIENT' FILE
"RTN","RORUPD01",63,0)
 ;
"RTN","RORUPD01",64,0)
 ; BEGIEN        Start IEN in the PATIENT file
"RTN","RORUPD01",65,0)
 ; ENDIEN        End IEN in the PATIENT file
"RTN","RORUPD01",66,0)
 ;
"RTN","RORUPD01",67,0)
 ; Return Values:
"RTN","RORUPD01",68,0)
 ;       <0  Error code
"RTN","RORUPD01",69,0)
 ;      >=0  Statistics
"RTN","RORUPD01",70,0)
 ;             ^1: Total number of processed patients
"RTN","RORUPD01",71,0)
 ;             ^2: Number of patients processed with errors
"RTN","RORUPD01",72,0)
 ;
"RTN","RORUPD01",73,0)
 ; If there is an error in processing of a patient, routine behavior
"RTN","RORUPD01",74,0)
 ; depends on the mode of execution:
"RTN","RORUPD01",75,0)
 ;
"RTN","RORUPD01",76,0)
 ; In the normal mode program logs the errors, adds a record to the
"RTN","RORUPD01",77,0)
 ; ROR PENDING PATIENT file (#798.3), and continues processing of
"RTN","RORUPD01",78,0)
 ; the remaining patients. Next registry update wil start data scan
"RTN","RORUPD01",79,0)
 ; for this patient from the date stored in the file #798.3.
"RTN","RORUPD01",80,0)
 ;
"RTN","RORUPD01",81,0)
 ; In the debug mode 3 program is aborted if there is an error
"RTN","RORUPD01",82,0)
 ; during processing of a patient.
"RTN","RORUPD01",83,0)
 ;
"RTN","RORUPD01",84,0)
PROCESS(BEGIEN,ENDIEN) ;
"RTN","RORUPD01",85,0)
 N CNT,DTNEXT,ECNT,EXIT,PATIEN,RC,TH,TMP
"RTN","RORUPD01",86,0)
 ;--- Loop through the patients
"RTN","RORUPD01",87,0)
 S:$G(ENDIEN)'>0 ENDIEN=0
"RTN","RORUPD01",88,0)
 S PATIEN=$S($G(BEGIEN)>0:$O(^DPT(BEGIEN),-1),1:0)
"RTN","RORUPD01",89,0)
 S (CNT,ECNT,EXIT,RC)=0
"RTN","RORUPD01",90,0)
 F  S PATIEN=$O(^DPT(PATIEN))  Q:PATIEN'>0  D  Q:EXIT!(RC<0)
"RTN","RORUPD01",91,0)
 . I ENDIEN,PATIEN'<ENDIEN  S EXIT=1  Q
"RTN","RORUPD01",92,0)
 . ;--- For a queued task only
"RTN","RORUPD01",93,0)
 . I $D(ZTQUEUED)  S RC=0  D  Q:RC<0
"RTN","RORUPD01",94,0)
 . . ;--- Check if task stop has been requested
"RTN","RORUPD01",95,0)
 . . I $$CHKSTOP()  S RC=$$ERROR^RORERR(-42,"PROCESS^RORUPD01")  Q
"RTN","RORUPD01",96,0)
 . . ;--- Check if the task should be suspended
"RTN","RORUPD01",97,0)
 . . Q:'$G(RORUPD("SUSPEND"))
"RTN","RORUPD01",98,0)
 . . Q:$$NOW^XLFDT<$G(DTNEXT)
"RTN","RORUPD01",99,0)
 . . Q:'$$SUSPEND(.DTNEXT)
"RTN","RORUPD01",100,0)
 . . ;--- Suspend the task during the peak hours
"RTN","RORUPD01",101,0)
 . . F  D  Q:'TH!(RC<0)
"RTN","RORUPD01",102,0)
 . . . S TH=$$FMDIFF^XLFDT(DTNEXT,$$NOW^XLFDT,2)
"RTN","RORUPD01",103,0)
 . . . I TH<60  S TH=0  Q       ; Do not HANG for less than a
"RTN","RORUPD01",104,0)
 . . . H $S(TH>3600:3600,1:TH)  ; minute and more than an hour
"RTN","RORUPD01",105,0)
 . . . ;--- Check if task stop has been requested
"RTN","RORUPD01",106,0)
 . . . S:$$CHKSTOP() RC=$$ERROR^RORERR(-42,"PROCESS^RORUPD01")
"RTN","RORUPD01",107,0)
 . ;--- Update the progress indicator
"RTN","RORUPD01",108,0)
 . S CNT=CNT+1
"RTN","RORUPD01",109,0)
 . I $G(RORPARM("DEBUG"))>1  W:$E($G(IOST),1,2)="C-" *13,CNT
"RTN","RORUPD01",110,0)
 . ;--- Process the patient
"RTN","RORUPD01",111,0)
 . S RC=$$PROCPAT(PATIEN)
"RTN","RORUPD01",112,0)
 . I $G(RORPARM("SETUP"))  D:'(CNT#1000)
"RTN","RORUPD01",113,0)
 . . D LOG^RORLOG(2,"Number of patients processed by now: "_CNT)
"RTN","RORUPD01",114,0)
 . ;--- Process the error (if any)
"RTN","RORUPD01",115,0)
 . I RC<0  D  S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORUPD01",116,0)
 . . I RC=-66  S RC=0  Q        ; Counter in the file #798.3
"RTN","RORUPD01",117,0)
 . . S ECNT=ECNT+1
"RTN","RORUPD01",118,0)
 . . S RC=$$ERROR^RORERR(-15,"PROCESS^RORUPD01",,PATIEN)
"RTN","RORUPD01",119,0)
 . . ;--- Create a record in the file #798.3
"RTN","RORUPD01",120,0)
 . . S TMP=$$ADD^RORUPP01(PATIEN,RORUPD("DSBEG"))
"RTN","RORUPD01",121,0)
 . . S:TMP<0 RC=TMP
"RTN","RORUPD01",122,0)
 Q $S(RC<0:RC,1:CNT_"^"_ECNT)
"RTN","RORUPD01",123,0)
 ;
"RTN","RORUPD01",124,0)
 ;***** PROCESSES PATIENT'S DATA (EXCEPT DEMOGRAPHIC DATA)
"RTN","RORUPD01",125,0)
 ;
"RTN","RORUPD01",126,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD01",127,0)
 ; [NOUPD]       Disable registry update (0 by default)
"RTN","RORUPD01",128,0)
 ;
"RTN","RORUPD01",129,0)
 ; Return Values:
"RTN","RORUPD01",130,0)
 ;       <0  Error code
"RTN","RORUPD01",131,0)
 ;        0  Ok
"RTN","RORUPD01",132,0)
 ;
"RTN","RORUPD01",133,0)
 ; If there is a record for the patient in the ROR PENDING PATIENT
"RTN","RORUPD01",134,0)
 ; file (#798.3) and date in that record is less than a value of the
"RTN","RORUPD01",135,0)
 ; RORUPD("DSBEG") then it is used as a start date of the data scan
"RTN","RORUPD01",136,0)
 ; for the patient. Otherwise, the RORUPD("DSBEG") is used.
"RTN","RORUPD01",137,0)
 ;
"RTN","RORUPD01",138,0)
PROCPAT(PATIEN,NOUPD) ;
"RTN","RORUPD01",139,0)
 ;--- Quit if the patient has already been processed
"RTN","RORUPD01",140,0)
 Q:$D(@RORUPDPI@("U",PATIEN)) 0
"RTN","RORUPD01",141,0)
 ;--- Quit if the patient's record has been merged
"RTN","RORUPD01",142,0)
 Q:$G(^DPT(PATIEN,-9)) 0
"RTN","RORUPD01",143,0)
 ;--- Do not update the registries with a "test patient"
"RTN","RORUPD01",144,0)
 I '$G(NOUPD),$P($G(^DPT(PATIEN,0)),U,21)  D  Q 0
"RTN","RORUPD01",145,0)
 . S @RORUPDPI@("U",PATIEN)=""
"RTN","RORUPD01",146,0)
 ;
"RTN","RORUPD01",147,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD01",148,0)
 ;
"RTN","RORUPD01",149,0)
 N PATIENS,RC,RLST,RORMSG,SDSDT,TMP,UPDREG,UPDSTART
"RTN","RORUPD01",150,0)
 S PATIENS=PATIEN_","
"RTN","RORUPD01",151,0)
 ;--- Initialize the variables
"RTN","RORUPD01",152,0)
 D CLEAR^RORERR("PROCPAT^RORUPD01"),CLREC^RORUPDUT
"RTN","RORUPD01",153,0)
 K RORVALS ; Clear all calculated values
"RTN","RORUPD01",154,0)
 S RC=$$LOOPINIT(PATIEN)  Q:RC<0 RC
"RTN","RORUPD01",155,0)
 ;
"RTN","RORUPD01",156,0)
 ;--- If the loop control list of registries is empty, the patient
"RTN","RORUPD01",157,0)
 ;    is already in all the registries that we are going to process.
"RTN","RORUPD01",158,0)
 S UPDREG=0
"RTN","RORUPD01",159,0)
 I $D(RORUPD("LM",2))>1  S RC=0  D  G:RC<0 PPEX  S UPDREG='$G(NOUPD)
"RTN","RORUPD01",160,0)
 . ;--- Determine start date of the data scan
"RTN","RORUPD01",161,0)
 . S UPDSTART=RORUPD("DSBEG")
"RTN","RORUPD01",162,0)
 . S SDSDT=$$SDSDATE^RORUPP01(PATIEN)
"RTN","RORUPD01",163,0)
 . I SDSDT<0  S RC=SDSDT  Q
"RTN","RORUPD01",164,0)
 . I SDSDT  S:SDSDT<UPDSTART UPDSTART=SDSDT
"RTN","RORUPD01",165,0)
 . S UPDSTART=$$FMADD^XLFDT(UPDSTART\1,-RORUPD("LD",1))
"RTN","RORUPD01",166,0)
 . ;--- Load necessary data elements
"RTN","RORUPD01",167,0)
 . I $D(RORUPD("SR",2,"F"))>1  D  Q:RC<0
"RTN","RORUPD01",168,0)
 . . S RC=$$LOAD(PATIENS)
"RTN","RORUPD01",169,0)
 . D SETVAL^RORUPDUT("ROR DFN",PATIEN)
"RTN","RORUPD01",170,0)
 . ;--- Apply "before" rules
"RTN","RORUPD01",171,0)
 . S RC=$$APLRULES^RORUPDUT(2,PATIENS,"B")  Q:RC
"RTN","RORUPD01",172,0)
 . ;
"RTN","RORUPD01",173,0)
 . ;--- Process patient data from other VistA files
"RTN","RORUPD01",174,0)
 . I $D(RORUPD("SR",9000010))  D  Q:RC
"RTN","RORUPD01",175,0)
 . . S RC=$$VISIT^RORUPD08(UPDSTART,PATIEN)
"RTN","RORUPD01",176,0)
 . I $D(RORUPD("SR",9000011))  D  Q:RC
"RTN","RORUPD01",177,0)
 . . S RC=$$PROBLEM^RORUPD07(UPDSTART,PATIEN)
"RTN","RORUPD01",178,0)
 . I $D(RORUPD("SR",45))  D       Q:RC
"RTN","RORUPD01",179,0)
 . . S RC=$$PTF^RORUPD09(UPDSTART,PATIEN)
"RTN","RORUPD01",180,0)
 . I $D(RORUPD("SR",63))  D       Q:RC
"RTN","RORUPD01",181,0)
 . . S RC=$$LAB^RORUPD04(UPDSTART,PATIEN)
"RTN","RORUPD01",182,0)
 . ; <--- Insert processing of other files here. Do not forget to add
"RTN","RORUPD01",183,0)
 . ;      definitions of these files into the 'ROR METADATA' file.
"RTN","RORUPD01",184,0)
 . ;
"RTN","RORUPD01",185,0)
 . ;--- Apply "after" rules
"RTN","RORUPD01",186,0)
 . S RC=$$APLRULES^RORUPDUT(2,PATIENS,"A")  Q:RC
"RTN","RORUPD01",187,0)
 ;
"RTN","RORUPD01",188,0)
 ;--- Update the registries if necessary
"RTN","RORUPD01",189,0)
 I UPDREG  S RC=$$UPDREG^RORUPD50(PATIEN)  G:RC<0 PPEX
"RTN","RORUPD01",190,0)
 ;--- Error processing
"RTN","RORUPD01",191,0)
 I $$GETEC^RORUPDUT  D  S RC=-15
"RTN","RORUPD01",192,0)
 . S RLST=$NA(@RORUPDPI@("U",PATIEN,2))
"RTN","RORUPD01",193,0)
 E  S RLST="",RC=0
"RTN","RORUPD01",194,0)
 ;--- If there are records in the file #798.3 for the patient,
"RTN","RORUPD01",195,0)
 ;    remove them (log a warning if cannot remove). If the patient
"RTN","RORUPD01",196,0)
 ;    has been processed with errors, remove only records associated
"RTN","RORUPD01",197,0)
 ;--- with the registries that the patient has been added to.
"RTN","RORUPD01",198,0)
 D:$G(SDSDT)
"RTN","RORUPD01",199,0)
 . S TMP=$$REMOVE^RORUPP01(PATIEN,RLST)
"RTN","RORUPD01",200,0)
 . S:TMP<0 TMP=$$ERROR^RORERR(-31,,,PATIEN)
"RTN","RORUPD01",201,0)
 ;--- Mark the patient as processed
"RTN","RORUPD01",202,0)
 S @RORUPDPI@("U",PATIEN)=""
"RTN","RORUPD01",203,0)
PPEX ;--- Cleanup
"RTN","RORUPD01",204,0)
 D CLRDES^RORUPDUT(2)
"RTN","RORUPD01",205,0)
 Q RC
"RTN","RORUPD01",206,0)
 ;
"RTN","RORUPD01",207,0)
 ;***** CHECKS IF THE TASK SHOULD BE SUSPENDED
"RTN","RORUPD01",208,0)
 ;
"RTN","RORUPD01",209,0)
 ; .DTNEXT       Date/Time of the next event (suspend/resume)
"RTN","RORUPD01",210,0)
 ;               is returned via this parameter
"RTN","RORUPD01",211,0)
 ;
"RTN","RORUPD01",212,0)
 ; Return Values:
"RTN","RORUPD01",213,0)
 ;        0  Continue/Resume
"RTN","RORUPD01",214,0)
 ;        1  Suspend
"RTN","RORUPD01",215,0)
 ;
"RTN","RORUPD01",216,0)
SUSPEND(DTNEXT) ;
"RTN","RORUPD01",217,0)
 N DATE,NOW,SUSPEND,TIME,TS,TR
"RTN","RORUPD01",218,0)
 S TS=$P(RORUPD("SUSPEND"),U,1)
"RTN","RORUPD01",219,0)
 S TR=$P(RORUPD("SUSPEND"),U,2)
"RTN","RORUPD01",220,0)
 S NOW=$$NOW^XLFDT,DATE=NOW\1
"RTN","RORUPD01",221,0)
 ;--- A working day
"RTN","RORUPD01",222,0)
 I $$WDCHK^RORUTL01(DATE)  D  Q SUSPEND
"RTN","RORUPD01",223,0)
 . S TIME=NOW-DATE,SUSPEND=0
"RTN","RORUPD01",224,0)
 . I TIME<TS   S DTNEXT=DATE+TS  Q
"RTN","RORUPD01",225,0)
 . I TIME'<TR  S DTNEXT=$$WDNEXT^RORUTL01(DATE)+TS  Q
"RTN","RORUPD01",226,0)
 . S DTNEXT=DATE+TR,SUSPEND=1
"RTN","RORUPD01",227,0)
 ;--- Saturday, Sunday or Holiday
"RTN","RORUPD01",228,0)
 S DTNEXT=$$WDNEXT^RORUTL01(DATE)+TS
"RTN","RORUPD01",229,0)
 Q 0
"RTN","RORUPD01",230,0)
 ;
"RTN","RORUPD01",231,0)
 ;***** UPDATES REGISTRY UPDATE PARAMETERS
"RTN","RORUPD01",232,0)
 ;
"RTN","RORUPD01",233,0)
 ; .REGLST       Reference to a local array containing registry names
"RTN","RORUPD01",234,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUPD01",235,0)
 ;
"RTN","RORUPD01",236,0)
 ; Return values:
"RTN","RORUPD01",237,0)
 ;       <0  Error code
"RTN","RORUPD01",238,0)
 ;        0  Ok
"RTN","RORUPD01",239,0)
 ;
"RTN","RORUPD01",240,0)
TMSTMP(REGLST) ;
"RTN","RORUPD01",241,0)
 N DATE,RC,REGIEN,REGIENS,REGNAME,RORFDA,RORMSG,TMP
"RTN","RORUPD01",242,0)
 S REGNAME="",RC=0
"RTN","RORUPD01",243,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPD01",244,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUPD01",245,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=+REGIEN  Q
"RTN","RORUPD01",246,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUPD01",247,0)
 . S REGIENS=REGIEN_","
"RTN","RORUPD01",248,0)
 . ;--- Check if the new date until that registry is updated is
"RTN","RORUPD01",249,0)
 . ;    greater than that stored in the registry parameters
"RTN","RORUPD01",250,0)
 . S TMP=$$GET1^DIQ(798.1,REGIENS,1,"I",,"RORMSG")
"RTN","RORUPD01",251,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD01",252,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"TMSTMP^RORUPD01",,798.1,REGIENS)
"RTN","RORUPD01",253,0)
 . S DATE=RORUPD("DSEND")\1
"RTN","RORUPD01",254,0)
 . S:DATE>TMP RORFDA(798.1,REGIENS,1)=DATE
"RTN","RORUPD01",255,0)
 . ;--- Update registry parameters (if necessary)
"RTN","RORUPD01",256,0)
 . Q:$D(RORFDA)<10
"RTN","RORUPD01",257,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUPD01",258,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD01",259,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"TMSTMP^RORUPD01",,798.1,REGIENS)
"RTN","RORUPD01",260,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPD02")
1^77
"RTN","RORUPD03")
1^78
"RTN","RORUPD04")
0^53^B30947880
"RTN","RORUPD04",1,0)
RORUPD04 ;HCIOFO/SG - PROCESSING OF THE LAB DATA  ; 4/18/02 2:09pm
"RTN","RORUPD04",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPD04",3,0)
 ;
"RTN","RORUPD04",4,0)
 ; This routine uses the following IA's:
"RTN","RORUPD04",5,0)
 ;
"RTN","RORUPD04",6,0)
 ; #10035        Access to the field #63 of the file #2
"RTN","RORUPD04",7,0)
 ;
"RTN","RORUPD04",8,0)
 Q
"RTN","RORUPD04",9,0)
 ;
"RTN","RORUPD04",10,0)
 ;***** CHECKS AN INDICATOR CONDITION
"RTN","RORUPD04",11,0)
 ;
"RTN","RORUPD04",12,0)
 ; LSI           Indicator (internal value)
"RTN","RORUPD04",13,0)
 ; VAL           Indicated value
"RTN","RORUPD04",14,0)
 ; .RESULT(      Result value
"RTN","RORUPD04",15,0)
 ;   "RH")       Reference high
"RTN","RORUPD04",16,0)
 ;   "RL")       Reference low
"RTN","RORUPD04",17,0)
 ;
"RTN","RORUPD04",18,0)
 ; Return Values:
"RTN","RORUPD04",19,0)
 ;        0  False
"RTN","RORUPD04",20,0)
 ;       >0  True
"RTN","RORUPD04",21,0)
 ;
"RTN","RORUPD04",22,0)
CHKIND(LSI,VAL,RESULT) ;
"RTN","RORUPD04",23,0)
 I LSI=1  D  Q LSI
"RTN","RORUPD04",24,0)
 . I $G(RESULT("RL"))'=""  Q:RESULT<RESULT("RL")
"RTN","RORUPD04",25,0)
 . I $G(RESULT("RH"))'=""  Q:RESULT>RESULT("RH")
"RTN","RORUPD04",26,0)
 . S LSI=0
"RTN","RORUPD04",27,0)
 ;--- Compare to the value
"RTN","RORUPD04",28,0)
 Q:VAL="" 0
"RTN","RORUPD04",29,0)
 I LSI=3  Q (RESULT>VAL)
"RTN","RORUPD04",30,0)
 I LSI=4  Q (RESULT<VAL)
"RTN","RORUPD04",31,0)
 S VAL=$$UP^XLFSTR(VAL)
"RTN","RORUPD04",32,0)
 S RESULT=$$UP^XLFSTR(RESULT)
"RTN","RORUPD04",33,0)
 I LSI=2  Q (RESULT[VAL)
"RTN","RORUPD04",34,0)
 I LSI=5  Q (RESULT=VAL)
"RTN","RORUPD04",35,0)
 Q 0
"RTN","RORUPD04",36,0)
 ;
"RTN","RORUPD04",37,0)
 ;***** PROCESSING OF THE 'LAB DATA' FILE
"RTN","RORUPD04",38,0)
 ;
"RTN","RORUPD04",39,0)
 ; UPDSTART      Date of the earliest update (DO NOT pass by
"RTN","RORUPD04",40,0)
 ;               reference)
"RTN","RORUPD04",41,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD04",42,0)
 ;
"RTN","RORUPD04",43,0)
 ; The function uses ^TMP("RORTMP",$J) node as a temporary storage.
"RTN","RORUPD04",44,0)
 ;
"RTN","RORUPD04",45,0)
 ; Return values:
"RTN","RORUPD04",46,0)
 ;       <0  Error code
"RTN","RORUPD04",47,0)
 ;        0  Continue processing of the current patient
"RTN","RORUPD04",48,0)
 ;        1  Stop processing
"RTN","RORUPD04",49,0)
 ;
"RTN","RORUPD04",50,0)
LAB(UPDSTART,PATIEN) ;
"RTN","RORUPD04",51,0)
 N RORFILE       ; File number
"RTN","RORUPD04",52,0)
 ;
"RTN","RORUPD04",53,0)
 N DM,DSEND,LABIENS,RC,TMP
"RTN","RORUPD04",54,0)
 S RORFILE=63,DSEND=RORUPD("DSEND")
"RTN","RORUPD04",55,0)
 K RORVALS("LS")
"RTN","RORUPD04",56,0)
 ;--- If the start date is more than 60 days in the past, results
"RTN","RORUPD04",57,0)
 ;    should be loaded using collection dates. Otherwise, dates of
"RTN","RORUPD04",58,0)
 ;--- the results are used).
"RTN","RORUPD04",59,0)
 S DM=$S($$FMDIFF^XLFDT(DT,UPDSTART)>60:"^CD",1:"^RAD")
"RTN","RORUPD04",60,0)
 ;--- Check the event references if the events are enabled
"RTN","RORUPD04",61,0)
 I $G(RORUPD("FLAGS"))["E"  D  Q:RC'>0 RC
"RTN","RORUPD04",62,0)
 . S RC=$$GET^RORUPP02(PATIEN,1,.UPDSTART,.DSEND)
"RTN","RORUPD04",63,0)
 . ;--- If dates have been modified according to the event references,
"RTN","RORUPD04",64,0)
 . ;--- they are the collection dates/times.
"RTN","RORUPD04",65,0)
 . S:RC>1 UPDSTART=UPDSTART\1,DSEND=$$FMADD^XLFDT(DSEND\1,1),DM="^CD"
"RTN","RORUPD04",66,0)
 ;---
"RTN","RORUPD04",67,0)
 S RC=0,LABIENS=$$LABREF(PATIEN)_","  Q:LABIENS'>0 0
"RTN","RORUPD04",68,0)
 D
"RTN","RORUPD04",69,0)
 . ;--- Load the Lab results
"RTN","RORUPD04",70,0)
 . S RC=$$LABRSLTS^RORUTL02(PATIEN,UPDSTART_DM,DSEND_DM)
"RTN","RORUPD04",71,0)
 . I RC<0  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD04",72,0)
 . ;--- Process the results
"RTN","RORUPD04",73,0)
 . Q:$$RESULTS(PATIEN)<0
"RTN","RORUPD04",74,0)
 . ;--- Load necessary data elements
"RTN","RORUPD04",75,0)
 . I $D(RORUPD("SR",RORFILE,"F"))>1  D  I TMP<0  D INCEC^RORUPDUT()  Q
"RTN","RORUPD04",76,0)
 . . S TMP=$$LOAD(LABIENS)
"RTN","RORUPD04",77,0)
 . ;--- Apply "before" rules
"RTN","RORUPD04",78,0)
 . S RC=$$APLRULES^RORUPDUT(RORFILE,LABIENS,"B")
"RTN","RORUPD04",79,0)
 . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD04",80,0)
 . ;--- Apply "after" rules
"RTN","RORUPD04",81,0)
 . S RC=$$APLRULES^RORUPDUT(RORFILE,LABIENS,"A")
"RTN","RORUPD04",82,0)
 . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD04",83,0)
 ;
"RTN","RORUPD04",84,0)
 D CLRDES^RORUPDUT(RORFILE)
"RTN","RORUPD04",85,0)
 Q RC
"RTN","RORUPD04",86,0)
 ;
"RTN","RORUPD04",87,0)
 ;***** RETURNS A LAB REFERENCE (IEN IN 'LAB DATA') OF THE PATIENT
"RTN","RORUPD04",88,0)
 ;
"RTN","RORUPD04",89,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD04",90,0)
 ;
"RTN","RORUPD04",91,0)
 ; Return values:
"RTN","RORUPD04",92,0)
 ;       <0  Error code
"RTN","RORUPD04",93,0)
 ;        0  Patient has no laboratory data
"RTN","RORUPD04",94,0)
 ;       >0  IEN of the record in LAB DATA file
"RTN","RORUPD04",95,0)
 ;
"RTN","RORUPD04",96,0)
LABREF(PATIEN) ;
"RTN","RORUPD04",97,0)
 N LABREF,RC,RORMSG
"RTN","RORUPD04",98,0)
 S LABREF=+$$GET1^DIQ(2,PATIEN_",",63,"I",,"RORMSG")
"RTN","RORUPD04",99,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"LABREF^RORUPD04",PATIEN,2)
"RTN","RORUPD04",100,0)
 Q LABREF
"RTN","RORUPD04",101,0)
 ;
"RTN","RORUPD04",102,0)
 ;***** LOAD DATA ELEMENTS
"RTN","RORUPD04",103,0)
 ;
"RTN","RORUPD04",104,0)
 ; IENS          IENS of the current record
"RTN","RORUPD04",105,0)
 ;
"RTN","RORUPD04",106,0)
 ; Return values:
"RTN","RORUPD04",107,0)
 ;       <0  Error code
"RTN","RORUPD04",108,0)
 ;        0  Ok
"RTN","RORUPD04",109,0)
 ;
"RTN","RORUPD04",110,0)
LOAD(IENS) ;
"RTN","RORUPD04",111,0)
 N RC  S RC=0
"RTN","RORUPD04",112,0)
 ;--- API #1
"RTN","RORUPD04",113,0)
 I $D(RORUPD("SR",RORFILE,"F",1))  D  Q:RC<0 RC
"RTN","RORUPD04",114,0)
 . S RC=$$LOADFLDS^RORUPDUT(RORFILE,IENS)
"RTN","RORUPD04",115,0)
 ;--- API #2
"RTN","RORUPD04",116,0)
 Q 0
"RTN","RORUPD04",117,0)
 ;
"RTN","RORUPD04",118,0)
 ;***** EXTRACTS PROPER RESULT CODE FROM THE OBSERVATION ID
"RTN","RORUPD04",119,0)
 ;
"RTN","RORUPD04",120,0)
 ; OID           Observation ID in HL7 format
"RTN","RORUPD04",121,0)
 ; CS            HL7 component separator
"RTN","RORUPD04",122,0)
 ;
"RTN","RORUPD04",123,0)
 ; Return values:
"RTN","RORUPD04",124,0)
 ;           Lab result code (see the LA7SC parameter of
"RTN","RORUPD04",125,0)
 ;           the GCPR^LA7QRY entry point)
"RTN","RORUPD04",126,0)
 ;             ^1: Result code
"RTN","RORUPD04",127,0)
 ;             ^2: Coding system ("LN" or "NLT")
"RTN","RORUPD04",128,0)
 ;           Or an empty string if coding system is unknown or there
"RTN","RORUPD04",129,0)
 ;           are no active search indicators exist for this code.
"RTN","RORUPD04",130,0)
 ;
"RTN","RORUPD04",131,0)
RESCODE(OID,CS) ;
"RTN","RORUPD04",132,0)
 N CODE,I,RESCODE,TYPE
"RTN","RORUPD04",133,0)
 S RESCODE=""
"RTN","RORUPD04",134,0)
 F I=1,4  D  Q:RESCODE'=""
"RTN","RORUPD04",135,0)
 . S CODE=$P(OID,CS,I),TYPE=$P(OID,CS,I+2)             Q:CODE=""
"RTN","RORUPD04",136,0)
 . S TYPE=$S(TYPE="LN":"LN",TYPE="99VA64":"NLT",1:"")  Q:TYPE=""
"RTN","RORUPD04",137,0)
 . ;--- Check if the search indicators exist for this code
"RTN","RORUPD04",138,0)
 . S RESCODE=CODE_U_TYPE
"RTN","RORUPD04",139,0)
 . S:$D(@RORUPDPI@("LS",RESCODE))<10 RESCODE=""
"RTN","RORUPD04",140,0)
 Q RESCODE
"RTN","RORUPD04",141,0)
 ;
"RTN","RORUPD04",142,0)
 ;***** LOADS AND PROCESSES RESULTS OF THE TESTS
"RTN","RORUPD04",143,0)
 ;
"RTN","RORUPD04",144,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD04",145,0)
 ; ^TMP("RORTMP",
"RTN","RORUPD04",146,0)
 ;   $J,...)     HL7 message created by GCPR^LA7QRY
"RTN","RORUPD04",147,0)
 ;
"RTN","RORUPD04",148,0)
 ; Return values:
"RTN","RORUPD04",149,0)
 ;       <0  Error code
"RTN","RORUPD04",150,0)
 ;        0  Ok
"RTN","RORUPD04",151,0)
 ;
"RTN","RORUPD04",152,0)
RESULTS(PATIEN) ;
"RTN","RORUPD04",153,0)
 N DATE,I,ISEG,LSIEN,LSNODE,RC,RESCODE,RESVAL,SEG,SEGTYPE,TMP
"RTN","RORUPD04",154,0)
 N CS,FS,SCS ; HL7 Separators
"RTN","RORUPD04",155,0)
 S ISEG="",RC=0
"RTN","RORUPD04",156,0)
 F  S ISEG=$O(^TMP("RORTMP",$J,ISEG))  Q:ISEG=""  D  Q:RC<0
"RTN","RORUPD04",157,0)
 . S SEG=^TMP("RORTMP",$J,ISEG)
"RTN","RORUPD04",158,0)
 . ;--- Extract separators from the MSH segment
"RTN","RORUPD04",159,0)
 . I $E(SEG,1,3)="MSH"  D  Q
"RTN","RORUPD04",160,0)
 . . S FS=$E(SEG,4),TMP=$P(SEG,FS,2)
"RTN","RORUPD04",161,0)
 . . S CS=$E(TMP,1),SCS=$E(TMP,4)
"RTN","RORUPD04",162,0)
 . ;--- Skip all segments except OBX
"RTN","RORUPD04",163,0)
 . S SEGTYPE=$P(SEG,FS)
"RTN","RORUPD04",164,0)
 . Q:SEGTYPE'="OBX"
"RTN","RORUPD04",165,0)
 . S SEG=$P(SEG,FS,2,999)
"RTN","RORUPD04",166,0)
 . ;--- Get lab result code
"RTN","RORUPD04",167,0)
 . S RESCODE=$$RESCODE($P(SEG,FS,3),CS)  Q:RESCODE=""
"RTN","RORUPD04",168,0)
 . ;--- Load the full segment
"RTN","RORUPD04",169,0)
 . S I=""
"RTN","RORUPD04",170,0)
 . F  S I=$O(^TMP("RORTMP",$J,ISEG,I))  Q:I=""  S SEG=SEG_^(I)
"RTN","RORUPD04",171,0)
 . ;--- Get the result data
"RTN","RORUPD04",172,0)
 . S RESVAL=$P(SEG,FS,5),TMP=$P(SEG,FS,7)
"RTN","RORUPD04",173,0)
 . S RESVAL("RL")=$P(TMP,"-",1) ; Reference Low
"RTN","RORUPD04",174,0)
 . S RESVAL("RH")=$P(TMP,"-",2) ; Reference High
"RTN","RORUPD04",175,0)
 . S DATE=$$HL7TFM^XLFDT($P(SEG,FS,14),"L")\1
"RTN","RORUPD04",176,0)
 . ;--- Analyze the result
"RTN","RORUPD04",177,0)
 . S LSNODE=$NA(@RORUPDPI@("LS",RESCODE))
"RTN","RORUPD04",178,0)
 . S LSIEN=""
"RTN","RORUPD04",179,0)
 . F  S LSIEN=$O(@LSNODE@(LSIEN))  Q:LSIEN=""  D  Q:RC<0
"RTN","RORUPD04",180,0)
 . . S I="",RC=0
"RTN","RORUPD04",181,0)
 . . F  S I=$O(@LSNODE@(LSIEN,I))  Q:I=""  D  Q:RC
"RTN","RORUPD04",182,0)
 . . . S TMP=$G(@LSNODE@(LSIEN,I))
"RTN","RORUPD04",183,0)
 . . . S RC=$$CHKIND(+TMP,$P(TMP,U,2),.RESVAL)
"RTN","RORUPD04",184,0)
 . . Q:RC'>0
"RTN","RORUPD04",185,0)
 . . S TMP=+$G(RORVALS("LS",LSIEN))
"RTN","RORUPD04",186,0)
 . . S:'TMP!(DATE&(DATE<TMP)) RORVALS("LS",LSIEN)=DATE
"RTN","RORUPD04",187,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPD04",188,0)
 ;
"RTN","RORUPD04",189,0)
 ;***** IMPLEMENTATION OF THE SELECTION RULE
"RTN","RORUPD04",190,0)
 ;
"RTN","RORUPD04",191,0)
 ; LSIEN         Lab Search IEN
"RTN","RORUPD04",192,0)
 ;
"RTN","RORUPD04",193,0)
 ; Return values:
"RTN","RORUPD04",194,0)
 ;        0  Skip the patient
"RTN","RORUPD04",195,0)
 ;        1  Add the patient
"RTN","RORUPD04",196,0)
 ;
"RTN","RORUPD04",197,0)
RULE(LSIEN) ;
"RTN","RORUPD04",198,0)
 I $D(RORVALS("LS",LSIEN))  D  Q 1
"RTN","RORUPD04",199,0)
 . N DATE  S DATE=$G(RORVALS("LS",LSIEN))  Q:DATE'>0
"RTN","RORUPD04",200,0)
 . S:DATE<RORVALS("SV","ROR SRDT") RORVALS("SV","ROR SRDT")=DATE
"RTN","RORUPD04",201,0)
 Q 0
"RTN","RORUPD05")
0^54^B43865246
"RTN","RORUPD05",1,0)
RORUPD05 ;HCIOFO/SG - REGISTRY UPDATE (MULTITASK) ; 4/23/02 3:43pm
"RTN","RORUPD05",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPD05",3,0)
 ;
"RTN","RORUPD05",4,0)
 Q
"RTN","RORUPD05",5,0)
 ;
"RTN","RORUPD05",6,0)
 ;***** MONITORS THE SUBTASKS
"RTN","RORUPD05",7,0)
 ;
"RTN","RORUPD05",8,0)
 ; Return Values:
"RTN","RORUPD05",9,0)
 ;       <0  Error code
"RTN","RORUPD05",10,0)
 ;      >=0  Combined statistics returned by the $$PROCESS^RORUPD01
"RTN","RORUPD05",11,0)
 ;           function of each subtask
"RTN","RORUPD05",12,0)
 ;
"RTN","RORUPD05",13,0)
MONITOR() ;
"RTN","RORUPD05",14,0)
 N CNT,ECNT,EXIT,RC,TASK
"RTN","RORUPD05",15,0)
 S (CNT,ECNT,EXIT)=0
"RTN","RORUPD05",16,0)
 F  H 60  D  Q:EXIT
"RTN","RORUPD05",17,0)
 . ;--- Exit if all subtasks finished
"RTN","RORUPD05",18,0)
 . I $D(@RORUPDPI@("T"))<10  S EXIT=1  Q
"RTN","RORUPD05",19,0)
 . ;--- Check for a request to stop
"RTN","RORUPD05",20,0)
 . I $D(ZTQUEUED),$$S^%ZTLOAD  D  Q
"RTN","RORUPD05",21,0)
 . . S EXIT=$$ERROR^RORERR(-42,"MONITOR^RORUPD05")
"RTN","RORUPD05",22,0)
 . ;--- Browse through the list of subtasks
"RTN","RORUPD05",23,0)
 . S TASK=0
"RTN","RORUPD05",24,0)
 . F  S TASK=$O(@RORUPDPI@("T",TASK))  Q:TASK=""  D
"RTN","RORUPD05",25,0)
 . . S RC=@RORUPDPI@("T",TASK)
"RTN","RORUPD05",26,0)
 . . ;--- Skip a subtask that was scheduled but has not started yet
"RTN","RORUPD05",27,0)
 . . I RC="S"  Q
"RTN","RORUPD05",28,0)
 . . ;--- Skip a running subtask
"RTN","RORUPD05",29,0)
 . . L +@RORUPDPI@("T",TASK):0  E  Q
"RTN","RORUPD05",30,0)
 . . L -@RORUPDPI@("T",TASK)
"RTN","RORUPD05",31,0)
 . . ;--- The subtask has crashed
"RTN","RORUPD05",32,0)
 . . I RC=-60  D  Q
"RTN","RORUPD05",33,0)
 . . . S EXIT=$$ERROR^RORERR(-60,"PROCESS^RORUPD05",,,TASK)
"RTN","RORUPD05",34,0)
 . . ;--- Fatal error in the subtask
"RTN","RORUPD05",35,0)
 . . I RC<0  S EXIT=+RC  Q
"RTN","RORUPD05",36,0)
 . . ;--- The subtask is completed (accumulate the statistics)
"RTN","RORUPD05",37,0)
 . . S CNT=CNT+$P(RC,U),ECNT=ECNT+$P(RC,U,2)
"RTN","RORUPD05",38,0)
 . . K @RORUPDPI@("T",TASK)
"RTN","RORUPD05",39,0)
 Q $S(EXIT<0:EXIT,1:CNT_U_ECNT)
"RTN","RORUPD05",40,0)
 ;
"RTN","RORUPD05",41,0)
 ;***** PROCESSES THE DATA (SINGLE TASK OR MULTITASK MODE)
"RTN","RORUPD05",42,0)
 ;
"RTN","RORUPD05",43,0)
 ; [MAXNTSK]     Maximum number of data processing subtasks.
"RTN","RORUPD05",44,0)
 ;               If this parameter is less than 2, all patients
"RTN","RORUPD05",45,0)
 ;               will be processed by the single main task.
"RTN","RORUPD05",46,0)
 ;               Otherwise, all patients can be distributed among
"RTN","RORUPD05",47,0)
 ;               several subtasks.
"RTN","RORUPD05",48,0)
 ;
"RTN","RORUPD05",49,0)
 ;               If "N^M^AUTO" is passed as a value of this parameter
"RTN","RORUPD05",50,0)
 ;               and difference between the end and start dates is
"RTN","RORUPD05",51,0)
 ;               more than M days then N subtasks will be created.
"RTN","RORUPD05",52,0)
 ;
"RTN","RORUPD05",53,0)
 ; Return Values:
"RTN","RORUPD05",54,0)
 ;       <0  Error code
"RTN","RORUPD05",55,0)
 ;      >=0  Statistics returned by the $$MONITOR function
"RTN","RORUPD05",56,0)
 ;
"RTN","RORUPD05",57,0)
 ; The main task will wait for completion of the subtasks. If one
"RTN","RORUPD05",58,0)
 ; of them fails, all other (including the main one) will fail too.
"RTN","RORUPD05",59,0)
 ;
"RTN","RORUPD05",60,0)
PROCESS(MAXNTSK) ;
"RTN","RORUPD05",61,0)
 N COUNTERS,NTSK,OLDPI,RC,SUBSCR,TASKTBL,TMP
"RTN","RORUPD05",62,0)
 ;--- Calculate number of tasks and create the task table
"RTN","RORUPD05",63,0)
 D:$G(MAXNTSK)["AUTO"
"RTN","RORUPD05",64,0)
 . S TMP=$$FMDIFF^XLFDT(RORUPD("DSEND"),RORUPD("DSBEG"),1)
"RTN","RORUPD05",65,0)
 . S MAXNTSK=$S(TMP>$P(MAXNTSK,U,2):+MAXNTSK,1:0)
"RTN","RORUPD05",66,0)
 I $G(MAXNTSK)>1  D  Q:NTSK<0 NTSK
"RTN","RORUPD05",67,0)
 . S NTSK=$$TASKTBL(MAXNTSK,.TASKTBL)
"RTN","RORUPD05",68,0)
 ;--- Process all patients by the main task
"RTN","RORUPD05",69,0)
 I $G(NTSK)<2  D  Q $$PROCESS^RORUPD01()
"RTN","RORUPD05",70,0)
 . K RORUPD("SUSPEND")  ; Never suspend the single task
"RTN","RORUPD05",71,0)
 ;
"RTN","RORUPD05",72,0)
 S RORUPD("JOB")=$J,OLDPI=RORUPDPI
"RTN","RORUPD05",73,0)
 ;--- Initialize the node in the ^XTMP global
"RTN","RORUPD05",74,0)
 I $G(RORPARM("SETUP"))  D
"RTN","RORUPD05",75,0)
 . S SUBSCR="RORUPDR"_+$O(RORUPD("LM2",""))
"RTN","RORUPD05",76,0)
 . S RORUPDPI=$NA(^XTMP(SUBSCR)),I=0
"RTN","RORUPD05",77,0)
 . F  S I=$O(@RORUPDPI@(I))  Q:I=""  K:I'="U" @RORUPDPI@(I)
"RTN","RORUPD05",78,0)
 E  D
"RTN","RORUPD05",79,0)
 . S SUBSCR="RORUPDJ"_$J
"RTN","RORUPD05",80,0)
 . S RORUPDPI=$NA(^XTMP(SUBSCR))
"RTN","RORUPD05",81,0)
 . K @RORUPDPI
"RTN","RORUPD05",82,0)
 D XTMPHDR^RORUTL01(SUBSCR,30,"PROCESS-RORUPD05")
"RTN","RORUPD05",83,0)
 M @RORUPDPI=@OLDPI
"RTN","RORUPD05",84,0)
 ;--- Indicate that the main task is running
"RTN","RORUPD05",85,0)
 L +@RORUPDPI@("T",0):5
"RTN","RORUPD05",86,0)
 E  Q $$ERROR^RORERR(-61,"PROCESS^RORUPD05")
"RTN","RORUPD05",87,0)
 ;
"RTN","RORUPD05",88,0)
 ;--- Start the subtasks
"RTN","RORUPD05",89,0)
 S TMP=$$START(.TASKTBL)
"RTN","RORUPD05",90,0)
 ;--- Monitor the subtasks
"RTN","RORUPD05",91,0)
 S COUNTERS=$$MONITOR()
"RTN","RORUPD05",92,0)
 ;
"RTN","RORUPD05",93,0)
 ;--- Clear "running" flag of the main task
"RTN","RORUPD05",94,0)
 ;    (request all unfinished subtasks to stop)
"RTN","RORUPD05",95,0)
 L -@RORUPDPI@("T",0)
"RTN","RORUPD05",96,0)
 ;--- Cleanup
"RTN","RORUPD05",97,0)
 I COUNTERS<0  D
"RTN","RORUPD05",98,0)
 . N TASK,ZTSK
"RTN","RORUPD05",99,0)
 . ;--- Dequeue subtasks that have not started yet
"RTN","RORUPD05",100,0)
 . S TASK=0
"RTN","RORUPD05",101,0)
 . F  S TASK=$O(@RORUPDPI@("T",TASK))  Q:TASK=""  D
"RTN","RORUPD05",102,0)
 . . S ZTSK=TASK  D DQ^%ZTLOAD
"RTN","RORUPD05",103,0)
 . ;--- Wait for all unfinished subtasks to stop
"RTN","RORUPD05",104,0)
 . L +@RORUPDPI@("T"):300  L -@RORUPDPI@("T")
"RTN","RORUPD05",105,0)
 K @RORUPDPI@("T")
"RTN","RORUPD05",106,0)
 Q COUNTERS
"RTN","RORUPD05",107,0)
 ;
"RTN","RORUPD05",108,0)
 ;***** STARTS THE SUBTASKS
"RTN","RORUPD05",109,0)
 ;
"RTN","RORUPD05",110,0)
 ; .TASKTBL      Reference to a local variable containing the table
"RTN","RORUPD05",111,0)
 ;               of subtask parameters. See the TASKSPLT and TASKTBL
"RTN","RORUPD05",112,0)
 ;               entry points for details.
"RTN","RORUPD05",113,0)
 ;
"RTN","RORUPD05",114,0)
 ; Return Values:
"RTN","RORUPD05",115,0)
 ;       <0  Error code
"RTN","RORUPD05",116,0)
 ;        0  Ok
"RTN","RORUPD05",117,0)
 ;
"RTN","RORUPD05",118,0)
START(TASKTBL) ;
"RTN","RORUPD05",119,0)
 N CNT,I,TYPE,ZTDESC,ZTDTH,ZTIO,ZTPRI,ZTRTN,ZTSAVE,ZTSK
"RTN","RORUPD05",120,0)
 K @RORUPDPI@("T")
"RTN","RORUPD05",121,0)
 ;--- Do not allow subtasks to proceed before everything is ready
"RTN","RORUPD05",122,0)
 L +@RORUPDPI@("T"):5
"RTN","RORUPD05",123,0)
 E  Q $$ERROR^RORERR(-61,"START^RORUPD05")
"RTN","RORUPD05",124,0)
 ;--- Start the subtasks
"RTN","RORUPD05",125,0)
 S I=""
"RTN","RORUPD05",126,0)
 F CNT=1:1  S I=$O(TASKTBL(I))  Q:I=""  D
"RTN","RORUPD05",127,0)
 . S ZTRTN="SUBTASK^RORUPD05",ZTIO=""
"RTN","RORUPD05",128,0)
 . S ZTDTH=$$FMADD^XLFDT($$NOW^XLFDT,,,,CNT*30)
"RTN","RORUPD05",129,0)
 . S ZTDESC="Registry Update Subtask ("_$TR(TASKTBL(I),U,"-")_")"
"RTN","RORUPD05",130,0)
 . S ZTSAVE("RORIENS")=TASKTBL(I)
"RTN","RORUPD05",131,0)
 . S ZTSAVE("RORLRC(")=""
"RTN","RORUPD05",132,0)
 . S ZTSAVE("RORPARM(")=""
"RTN","RORUPD05",133,0)
 . S ZTSAVE("RORUPD(")=""
"RTN","RORUPD05",134,0)
 . S ZTSAVE("RORUPDPI")=""
"RTN","RORUPD05",135,0)
 . D ^%ZTLOAD
"RTN","RORUPD05",136,0)
 . ;--- Indicate that the subtask has been scheduled
"RTN","RORUPD05",137,0)
 . S @RORUPDPI@("T",ZTSK)="S"
"RTN","RORUPD05",138,0)
 . S TMP=$$MSG^RORERR20(-62,.TYPE,,ZTSK)
"RTN","RORUPD05",139,0)
 . D LOG^RORLOG(TYPE,TMP)
"RTN","RORUPD05",140,0)
 ;--- The subtasks may proceed now
"RTN","RORUPD05",141,0)
 L -@RORUPDPI@("T")
"RTN","RORUPD05",142,0)
 Q 0
"RTN","RORUPD05",143,0)
 ;
"RTN","RORUPD05",144,0)
 ;***** DATA PROCESSING SUBTASK
"RTN","RORUPD05",145,0)
 ;
"RTN","RORUPD05",146,0)
 ; RORIENS       Diapason of IENs in the 'PATIENT' file
"RTN","RORUPD05",147,0)
 ;                 ^1: Start IEN
"RTN","RORUPD05",148,0)
 ;                 ^2: End IEN
"RTN","RORUPD05",149,0)
 ; RORLRC        List of Lab result codes to check
"RTN","RORUPD05",150,0)
 ; RORPARM       Application parameters
"RTN","RORUPD05",151,0)
 ; RORUPD        Registry update descriptor
"RTN","RORUPD05",152,0)
 ; RORUPDPI      Closed root of the temporary storage
"RTN","RORUPD05",153,0)
 ;
"RTN","RORUPD05",154,0)
SUBTASK ;
"RTN","RORUPD05",155,0)
 N RORERROR      ; Error processing data
"RTN","RORUPD05",156,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORUPD05",157,0)
 ;
"RTN","RORUPD05",158,0)
 N RC,TASK,TMP,TYPE
"RTN","RORUPD05",159,0)
 S TASK=ZTSK
"RTN","RORUPD05",160,0)
 ;--- We are not in the KIDS environment anymore
"RTN","RORUPD05",161,0)
 K RORPARM("KIDS")
"RTN","RORUPD05",162,0)
 ;--- Disable debug output (subtask has no device)
"RTN","RORUPD05",163,0)
 S:$G(RORPARM("DEBUG"))>1 RORPARM("DEBUG")=1
"RTN","RORUPD05",164,0)
 ;--- Indicate that the subtask is running
"RTN","RORUPD05",165,0)
 L +@RORUPDPI@("T",TASK):180
"RTN","RORUPD05",166,0)
 E  S RC=$$ERROR^RORERR(-61,"SUBTASK^RORUPD05")  Q
"RTN","RORUPD05",167,0)
 ;--- Check if the main task is running
"RTN","RORUPD05",168,0)
 L +@RORUPDPI@("T",0):0
"RTN","RORUPD05",169,0)
 I  D
"RTN","RORUPD05",170,0)
 . ;--- Cleanup if the main task is not running
"RTN","RORUPD05",171,0)
 . L -@RORUPDPI@("T",0)
"RTN","RORUPD05",172,0)
 . K @RORUPDPI@("T",TASK)
"RTN","RORUPD05",173,0)
 E  D
"RTN","RORUPD05",174,0)
 . N REGIEN,REGLST
"RTN","RORUPD05",175,0)
 . ;--- Error code that will be in effect if the subtask crashes
"RTN","RORUPD05",176,0)
 . S @RORUPDPI@("T",TASK)=-60
"RTN","RORUPD05",177,0)
 . ;--- Initialize the variables
"RTN","RORUPD05",178,0)
 . D INIT^RORUTL01(),CLEAR^RORERR("SUBTASK^RORUPD05")
"RTN","RORUPD05",179,0)
 . S REGIEN=""
"RTN","RORUPD05",180,0)
 . F  S REGIEN=$O(@RORUPDPI@(2,REGIEN))  Q:REGIEN=""  D
"RTN","RORUPD05",181,0)
 . . S TMP=$P(@RORUPDPI@(2,REGIEN),U)  S:TMP'="" REGLST(TMP)=REGIEN
"RTN","RORUPD05",182,0)
 . S TMP="REGISTRY UPDATE SUBTASK #"_TASK_" STARTED"
"RTN","RORUPD05",183,0)
 . S TMP=$$OPEN^RORLOG(.REGLST,1,TMP)
"RTN","RORUPD05",184,0)
 . ;--- Process the patients from 'Start IEN' to 'End IEN'
"RTN","RORUPD05",185,0)
 . S RC=$$PROCESS^RORUPD01($P(RORIENS,U),$P(RORIENS,U,2))
"RTN","RORUPD05",186,0)
 . ;--- Set the error code returned by the registry update process
"RTN","RORUPD05",187,0)
 . S @RORUPDPI@("T",TASK)=RC
"RTN","RORUPD05",188,0)
 . ;--- Cleanup and error processing
"RTN","RORUPD05",189,0)
 . S:RC=-42 ZTSTOP=1
"RTN","RORUPD05",190,0)
 . S TMP="REGISTRY UPDATE SUBTASK "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","RORUPD05",191,0)
 . D CLOSE^RORLOG(TMP,$S(RC'<0:RC,1:""))
"RTN","RORUPD05",192,0)
 ;--- Clear "running" flag of the subtask
"RTN","RORUPD05",193,0)
 L -@RORUPDPI@("T",TASK)
"RTN","RORUPD05",194,0)
 S ZTREQ="@"
"RTN","RORUPD05",195,0)
 Q
"RTN","RORUPD05",196,0)
 ;
"RTN","RORUPD05",197,0)
 ;***** CALCULATES TABLE OF SUBTASKS
"RTN","RORUPD05",198,0)
 ;
"RTN","RORUPD05",199,0)
 ; MAXNTSK       Maximum number of data processing subtasks
"RTN","RORUPD05",200,0)
 ;
"RTN","RORUPD05",201,0)
 ; .TASKTBL      Reference to a local variable where table of
"RTN","RORUPD05",202,0)
 ;               subtask parameters is returned:
"RTN","RORUPD05",203,0)
 ;
"RTN","RORUPD05",204,0)
 ;               TASKTBL       Number of subtasks
"RTN","RORUPD05",205,0)
 ;               TASKTBL(I)    Subtask parameters
"RTN","RORUPD05",206,0)
 ;                               ^1: Start IEN
"RTN","RORUPD05",207,0)
 ;                               ^2: End IEN
"RTN","RORUPD05",208,0)
 ;
"RTN","RORUPD05",209,0)
 ; Return Values:
"RTN","RORUPD05",210,0)
 ;       <0  Error code
"RTN","RORUPD05",211,0)
 ;        0  Process all data by the main task
"RTN","RORUPD05",212,0)
 ;       >1  Number of subtasks
"RTN","RORUPD05",213,0)
 ;
"RTN","RORUPD05",214,0)
 ; If the PATIENT file contains more than 100,000 records, up to
"RTN","RORUPD05",215,0)
 ; MAXNTSK data processing subtasks may be defined. Otherwise, the
"RTN","RORUPD05",216,0)
 ; data should be processed by the main task.
"RTN","RORUPD05",217,0)
 ;
"RTN","RORUPD05",218,0)
 ; The function uses the ^TMP("RORTMP",$J) global node.
"RTN","RORUPD05",219,0)
 ;
"RTN","RORUPD05",220,0)
TASKTBL(MAXNTSK,RORTBL) ;
"RTN","RORUPD05",221,0)
 N I,IEN,INC,LST,NR
"RTN","RORUPD05",222,0)
 K RORTBL,^TMP("RORTMP",$J)
"RTN","RORUPD05",223,0)
 ;--- Get number of records in the PATIENT file
"RTN","RORUPD05",224,0)
 S NR=$$GET1^DID(2,,,"ENTRIES",,"RORMSG")
"RTN","RORUPD05",225,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"TASKTBL^RORUPD05")
"RTN","RORUPD05",226,0)
 Q:NR'>100000 0
"RTN","RORUPD05",227,0)
 ;--- Generate IEN intervals (no more than 300)
"RTN","RORUPD05",228,0)
 S INC=NR\300,NR=0  S:INC<1 INC=1
"RTN","RORUPD05",229,0)
 F IEN=0:INC  S IEN=$O(^DPT(IEN))  Q:IEN'>0  D
"RTN","RORUPD05",230,0)
 . S NR=NR+1,^TMP("RORTMP",$J,NR)=IEN
"RTN","RORUPD05",231,0)
 ;--- Generate the task table
"RTN","RORUPD05",232,0)
 S IEN=1,INC=NR/MAXNTSK
"RTN","RORUPD05",233,0)
 F RORTBL=1:1  D  Q:(RORTBL'<MAXNTSK)!(IEN'>0)
"RTN","RORUPD05",234,0)
 . S RORTBL(RORTBL)=IEN
"RTN","RORUPD05",235,0)
 . S I=$J(RORTBL*INC,0,0),IEN=$G(^TMP("RORTMP",$J,I))
"RTN","RORUPD05",236,0)
 . S $P(RORTBL(RORTBL),U,2)=IEN
"RTN","RORUPD05",237,0)
 K ^TMP("RORTMP",$J)
"RTN","RORUPD05",238,0)
 ;--- Analize the result
"RTN","RORUPD05",239,0)
 I $G(RORTBL)<2  K RORTBL
"RTN","RORUPD05",240,0)
 E  S $P(RORTBL(RORTBL),U,2)=$O(^DPT(" "),-1)
"RTN","RORUPD05",241,0)
 Q +$G(RORTBL)
"RTN","RORUPD06")
0^55^B10084571
"RTN","RORUPD06",1,0)
RORUPD06 ;HCIOFO/SG - REGISTRY UPDATE (MISCELLANEOUS) ; 3/28/02 10:43am
"RTN","RORUPD06",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPD06",3,0)
 ;
"RTN","RORUPD06",4,0)
 Q
"RTN","RORUPD06",5,0)
 ;
"RTN","RORUPD06",6,0)
 ;***** ADDS THE PATIENT TO THE REGISTRY (UNCONDITIONALLY)
"RTN","RORUPD06",7,0)
 ;
"RTN","RORUPD06",8,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD06",9,0)
 ; REGNAME       Registry name
"RTN","RORUPD06",10,0)
 ; .RULES        Reference to a local array containing list of
"RTN","RORUPD06",11,0)
 ;               triggered selection rules: RULES(n)=RuleIEN^Date
"RTN","RORUPD06",12,0)
 ;
"RTN","RORUPD06",13,0)
 ; Return Values:
"RTN","RORUPD06",14,0)
 ;       <0  Error code (see MSGLIST^RORERR20)
"RTN","RORUPD06",15,0)
 ;        0  Ok
"RTN","RORUPD06",16,0)
 ;
"RTN","RORUPD06",17,0)
ADDPAT(PATIEN,REGNAME,RULES) ;
"RTN","RORUPD06",18,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD06",19,0)
 N RORUPD        ; Update descriptor
"RTN","RORUPD06",20,0)
 N RORUPDPI      ; Closed root of the temporary storage
"RTN","RORUPD06",21,0)
 ;
"RTN","RORUPD06",22,0)
 N I,RC,REGIEN,REGLST,RORLRC,RORSRLST,RULEIEN
"RTN","RORUPD06",23,0)
 D INIT^RORUTL01("RORUPD")
"RTN","RORUPD06",24,0)
 D CLEAR^RORERR("ADDPAT^RORUPD06")
"RTN","RORUPD06",25,0)
 S RORUPDPI=$NA(^TMP("RORUPD",$J))
"RTN","RORUPD06",26,0)
 ;--- Check the registry name
"RTN","RORUPD06",27,0)
 Q:REGNAME?." " $$ERROR^RORERR(-10,,,PATIEN,REGNAME)
"RTN","RORUPD06",28,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)  Q:REGIEN<0 REGIEN
"RTN","RORUPD06",29,0)
 S REGLST(REGNAME)=REGIEN
"RTN","RORUPD06",30,0)
 ;--- Prepare list of triggered selection rules
"RTN","RORUPD06",31,0)
 S I="",RC=0
"RTN","RORUPD06",32,0)
 F  S I=$O(RULES(I))  Q:I=""  D  Q:RC<0
"RTN","RORUPD06",33,0)
 . S RULEIEN=$P(RULES(I),U)
"RTN","RORUPD06",34,0)
 . I RULEIEN'>0  S RC=$$ERROR^RORERR(-45)  Q
"RTN","RORUPD06",35,0)
 . S RORSRLST(RULEIEN)=$P(RULES(I),U,2)
"RTN","RORUPD06",36,0)
 Q:RC<0 RC
"RTN","RORUPD06",37,0)
 ;--- Prepare update descriptor
"RTN","RORUPD06",38,0)
 S RC=$$PREPARE1^RORUPR(.REGLST)
"RTN","RORUPD06",39,0)
 Q:RC<0 $$ERROR^RORERR(-14,,,PATIEN)
"RTN","RORUPD06",40,0)
 ;--- Add the patient to the registry
"RTN","RORUPD06",41,0)
 S RC=$$ADDPDATA^RORUPD50(PATIEN)  Q:RC<0 RC
"RTN","RORUPD06",42,0)
 S RC=$$ADD^RORUPD50(PATIEN,REGIEN,"RORSRLST")
"RTN","RORUPD06",43,0)
 ;--- Update patient demographic data
"RTN","RORUPD06",44,0)
 S RC=$$UPDPTDEM^RORUPD51(PATIEN)
"RTN","RORUPD06",45,0)
 Q:RC<0 $$ERROR^RORERR(-16,,,PATIEN)
"RTN","RORUPD06",46,0)
 ;--- Cleanup
"RTN","RORUPD06",47,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("RORUPD")
"RTN","RORUPD06",48,0)
 Q 0
"RTN","RORUPD06",49,0)
 ;
"RTN","RORUPD06",50,0)
 ;***** CHECKS/UPDATES THE SINGLE PATIENT IN THE REGISTRY
"RTN","RORUPD06",51,0)
 ;
"RTN","RORUPD06",52,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD06",53,0)
 ; REGNAME       Registry name
"RTN","RORUPD06",54,0)
 ;
"RTN","RORUPD06",55,0)
 ; .UPDBYRUL     Reference to a local array for the list of rules that
"RTN","RORUPD06",56,0)
 ;               the patient is selected by (output). The list has
"RTN","RORUPD06",57,0)
 ;               the following structure: UPDBYRUL(Rule#)=Date, where
"RTN","RORUPD06",58,0)
 ;               "Rule#" is an IEN of the selection rule in the file
"RTN","RORUPD06",59,0)
 ;               #798.2 and "Date" is the date when the patient has
"RTN","RORUPD06",60,0)
 ;               passed the selection rule for the first time.
"RTN","RORUPD06",61,0)
 ;
"RTN","RORUPD06",62,0)
 ; [CHKONLY]     If this optional parameter is undefined (default)
"RTN","RORUPD06",63,0)
 ;               or equals to zero then the function checks a patient
"RTN","RORUPD06",64,0)
 ;               against selection rules and adds him to the registry 
"RTN","RORUPD06",65,0)
 ;               if he passes at least one of the rules.
"RTN","RORUPD06",66,0)
 ;               Otherwise, the patient is only checked against the
"RTN","RORUPD06",67,0)
 ;               rules but registry is not updated.
"RTN","RORUPD06",68,0)
 ;
"RTN","RORUPD06",69,0)
 ; Return Values:
"RTN","RORUPD06",70,0)
 ;       <0  Error code (see MSGLIST^RORERR20)
"RTN","RORUPD06",71,0)
 ;        0  Ok
"RTN","RORUPD06",72,0)
 ;
"RTN","RORUPD06",73,0)
 ; If a local array passed as the UPDBYRUL parameter is undefined
"RTN","RORUPD06",74,0)
 ; after return from the function then the patient has not pass any
"RTN","RORUPD06",75,0)
 ; selection rule.
"RTN","RORUPD06",76,0)
 ;
"RTN","RORUPD06",77,0)
UPDPAT(PATIEN,REGNAME,UPDBYRUL,CHKONLY) ;
"RTN","RORUPD06",78,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD06",79,0)
 N RORLRC        ; List of Lab result codes to check
"RTN","RORUPD06",80,0)
 N RORUPD        ; Update descriptor
"RTN","RORUPD06",81,0)
 N RORUPDPI      ; Closed root of the temporary storage
"RTN","RORUPD06",82,0)
 N RORVALS       ; Calculated values
"RTN","RORUPD06",83,0)
 ;
"RTN","RORUPD06",84,0)
 N RC,REGIEN,REGLST
"RTN","RORUPD06",85,0)
 D INIT^RORUTL01("RORUPD")
"RTN","RORUPD06",86,0)
 D CLEAR^RORERR("UPDPAT^RORUPD06")
"RTN","RORUPD06",87,0)
 S RORUPDPI=$NA(^TMP("RORUPD",$J))
"RTN","RORUPD06",88,0)
 ;--- Check the registry name
"RTN","RORUPD06",89,0)
 Q:REGNAME?." " $$ERROR^RORERR(-10,,,PATIEN,REGNAME)
"RTN","RORUPD06",90,0)
 S REGLST(REGNAME)=""  K UPDBYRUL
"RTN","RORUPD06",91,0)
 ;--- Prepare selection rules
"RTN","RORUPD06",92,0)
 S RC=$$PREPARE^RORUPR(.REGLST)
"RTN","RORUPD06",93,0)
 Q:RC<0 $$ERROR^RORERR(-14,,,PATIEN)
"RTN","RORUPD06",94,0)
 D:$G(RORPARM("DEBUG"))>1 DEBUG^RORUPDUT
"RTN","RORUPD06",95,0)
 ;--- Check the patient and update the registry
"RTN","RORUPD06",96,0)
 S RC=$$PROCPAT^RORUPD01(PATIEN,$G(CHKONLY))
"RTN","RORUPD06",97,0)
 Q:RC<0 $$ERROR^RORERR(-15,,,PATIEN)
"RTN","RORUPD06",98,0)
 ;--- Update patient demographic data
"RTN","RORUPD06",99,0)
 I '$G(CHKONLY)  D  Q:RC<0 $$ERROR^RORERR(-16,,,PATIEN)
"RTN","RORUPD06",100,0)
 . S RC=$$UPDPTDEM^RORUPD51(PATIEN)
"RTN","RORUPD06",101,0)
 ;--- Load the list of triggered rules
"RTN","RORUPD06",102,0)
 S REGIEN=""
"RTN","RORUPD06",103,0)
 F  S REGIEN=$O(@RORUPDPI@("U",PATIEN,2,REGIEN))  Q:REGIEN=""  D
"RTN","RORUPD06",104,0)
 . M UPDBYRUL=@RORUPDPI@("U",PATIEN,2,REGIEN)
"RTN","RORUPD06",105,0)
 ;--- Cleanup
"RTN","RORUPD06",106,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("RORUPD")
"RTN","RORUPD06",107,0)
 Q 0
"RTN","RORUPD07")
0^56^B6845655
"RTN","RORUPD07",1,0)
RORUPD07 ;HCIOFO/SG - PROCESSING OF THE 'PROBLEM' FILE  ; 4/18/02 2:06pm
"RTN","RORUPD07",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPD07",3,0)
 ;
"RTN","RORUPD07",4,0)
 ; This routine uses the following IAs:
"RTN","RORUPD07",5,0)
 ;
"RTN","RORUPD07",6,0)
 ; #928          ACTIVE^GMPLUTL
"RTN","RORUPD07",7,0)
 ; #2977         GETFLDS^GMPLEDT3
"RTN","RORUPD07",8,0)
 ;
"RTN","RORUPD07",9,0)
 Q
"RTN","RORUPD07",10,0)
 ;
"RTN","RORUPD07",11,0)
 ;***** LOADS DATA ELEMENT VALUES
"RTN","RORUPD07",12,0)
 ;
"RTN","RORUPD07",13,0)
 ; IENS          IENS of the current record
"RTN","RORUPD07",14,0)
 ;
"RTN","RORUPD07",15,0)
 ; Return values:
"RTN","RORUPD07",16,0)
 ;       <0  Error code
"RTN","RORUPD07",17,0)
 ;        0  Ok
"RTN","RORUPD07",18,0)
 ;
"RTN","RORUPD07",19,0)
LOAD(IENS) ;
"RTN","RORUPD07",20,0)
 N RC  S RC=0
"RTN","RORUPD07",21,0)
 ;--- API #1
"RTN","RORUPD07",22,0)
 I $D(RORUPD("SR",RORFILE,"F",1))  D  Q:RC<0 RC
"RTN","RORUPD07",23,0)
 . S RC=$$LOADFLDS^RORUPDUT(RORFILE,IENS)
"RTN","RORUPD07",24,0)
 ;--- API #2
"RTN","RORUPD07",25,0)
 I $D(RORUPD("SR",RORFILE,"F",2))  D  Q:RC<0 RC
"RTN","RORUPD07",26,0)
 . N DE,GMPFLD,GMPORIG,GMPROV,GMVAMC,IN,IP,VT
"RTN","RORUPD07",27,0)
 . S (GMPVAMC,GMPROV)=0
"RTN","RORUPD07",28,0)
 . D GETFLDS^GMPLEDT3(+IENS)
"RTN","RORUPD07",29,0)
 . ;---
"RTN","RORUPD07",30,0)
 . S DE=""
"RTN","RORUPD07",31,0)
 . F  S DE=$O(RORUPD("SR",RORFILE,"F",2,DE))  Q:DE=""  D
"RTN","RORUPD07",32,0)
 . . S VT=""
"RTN","RORUPD07",33,0)
 . . F  S VT=$O(RORUPD("SR",RORFILE,"F",2,DE,VT))  Q:VT=""  D
"RTN","RORUPD07",34,0)
 . . . S IP=+$P(RORUPD("SR",RORFILE,"F",2,DE,VT),U,1)  Q:IP'>0
"RTN","RORUPD07",35,0)
 . . . S IN=+$P(RORUPD("SR",RORFILE,"F",2,DE,VT),U,2)
"RTN","RORUPD07",36,0)
 . . . S RORVALS("DV",RORFILE,DE,VT)=$P($G(GMPFLD(IN)),U,IP)
"RTN","RORUPD07",37,0)
 Q 0
"RTN","RORUPD07",38,0)
 ;
"RTN","RORUPD07",39,0)
 ;***** PROCESSING OF THE 'PROBLEM' FILE
"RTN","RORUPD07",40,0)
 ;
"RTN","RORUPD07",41,0)
 ; UPDSTART      Date of the earliest update
"RTN","RORUPD07",42,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD07",43,0)
 ;
"RTN","RORUPD07",44,0)
 ; Return values:
"RTN","RORUPD07",45,0)
 ;       <0  Error code
"RTN","RORUPD07",46,0)
 ;        0  Continue processing of the current patient
"RTN","RORUPD07",47,0)
 ;        1  Stop processing
"RTN","RORUPD07",48,0)
 ;
"RTN","RORUPD07",49,0)
PROBLEM(UPDSTART,PATIEN) ;
"RTN","RORUPD07",50,0)
 N RORFILE       ; File number
"RTN","RORUPD07",51,0)
 N RORPLST       ; List of patient problems
"RTN","RORUPD07",52,0)
 ;
"RTN","RORUPD07",53,0)
 N DATE,IS,PROBIENS,RC,TMP
"RTN","RORUPD07",54,0)
 S RORFILE=9000011
"RTN","RORUPD07",55,0)
 ;--- Check if the problem list has been modified in
"RTN","RORUPD07",56,0)
 ;    the data scan period of the patient.
"RTN","RORUPD07",57,0)
 Q:$$MOD^GMPLUTL3(PATIEN)<UPDSTART 0
"RTN","RORUPD07",58,0)
 ;--- Load a list of active problems
"RTN","RORUPD07",59,0)
 D ACTIVE^GMPLUTL(PATIEN,.RORPLST)
"RTN","RORUPD07",60,0)
 ;
"RTN","RORUPD07",61,0)
 ;--- Browse through the problems
"RTN","RORUPD07",62,0)
 S (IS,RC)=0
"RTN","RORUPD07",63,0)
 F  S IS=$O(RORPLST(IS))  Q:IS=""  D  Q:RC
"RTN","RORUPD07",64,0)
 . S PROBIENS=+RORPLST(IS,0)_","
"RTN","RORUPD07",65,0)
 . ;--- Load necessary data elements
"RTN","RORUPD07",66,0)
 . I $D(RORUPD("SR",RORFILE,"F"))>1  D  I TMP<0 D INCEC^RORUPDUT() Q
"RTN","RORUPD07",67,0)
 . . S TMP=$$LOAD(PROBIENS)
"RTN","RORUPD07",68,0)
 . ;--- Ignore problems entered not in the data scan period
"RTN","RORUPD07",69,0)
 . S DATE=$$GETDE^RORUPDUT(RORFILE,118)
"RTN","RORUPD07",70,0)
 . Q:(DATE<UPDSTART)!(DATE'<RORUPD("DSEND"))
"RTN","RORUPD07",71,0)
 . ;--- Apply "before" rules
"RTN","RORUPD07",72,0)
 . S RC=$$APLRULES^RORUPDUT(RORFILE,PROBIENS,"B",DATE)
"RTN","RORUPD07",73,0)
 . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD07",74,0)
 . ;--- Apply "after" rules
"RTN","RORUPD07",75,0)
 . S RC=$$APLRULES^RORUPDUT(RORFILE,PROBIENS,"A",DATE)
"RTN","RORUPD07",76,0)
 . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD07",77,0)
 ;
"RTN","RORUPD07",78,0)
 D CLRDES^RORUPDUT(RORFILE)
"RTN","RORUPD07",79,0)
 Q RC
"RTN","RORUPD08")
0^57^B18764845
"RTN","RORUPD08",1,0)
RORUPD08 ;HCIOFO/SG - PROCESSING OF 'VISIT' & 'V POV' FILES  ; 5/2/02 2:51pm
"RTN","RORUPD08",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPD08",3,0)
 ;
"RTN","RORUPD08",4,0)
 ; This routine uses the following IAs:
"RTN","RORUPD08",5,0)
 ;
"RTN","RORUPD08",6,0)
 ; #1554         POV^PXAPIIB
"RTN","RORUPD08",7,0)
 ; #1905         SELECTED^VSIT
"RTN","RORUPD08",8,0)
 ; #1906         LOOKUP^VSIT
"RTN","RORUPD08",9,0)
 ;
"RTN","RORUPD08",10,0)
 Q
"RTN","RORUPD08",11,0)
 ;
"RTN","RORUPD08",12,0)
 ;***** LOADS 'V POV' DATA ELEMENTS
"RTN","RORUPD08",13,0)
 ;
"RTN","RORUPD08",14,0)
 ; IENS          IENS of the current record
"RTN","RORUPD08",15,0)
 ;
"RTN","RORUPD08",16,0)
 ; Return values:
"RTN","RORUPD08",17,0)
 ;       <0  Error code
"RTN","RORUPD08",18,0)
 ;        0  Ok
"RTN","RORUPD08",19,0)
 ;
"RTN","RORUPD08",20,0)
LOADVPOV(IENS) ;
"RTN","RORUPD08",21,0)
 N RC  S RC=0
"RTN","RORUPD08",22,0)
 ;--- API #1
"RTN","RORUPD08",23,0)
 I $D(RORUPD("SR",RORFILE,"F",1))  D  Q:RC<0 RC
"RTN","RORUPD08",24,0)
 . S RC=$$LOADFLDS^RORUPDUT(RORFILE,IENS)
"RTN","RORUPD08",25,0)
 ;--- API #2
"RTN","RORUPD08",26,0)
 I $D(RORUPD("SR",RORFILE,"F",2))  D  Q:RC<0 RC
"RTN","RORUPD08",27,0)
 . N BUF,DE,IP,RORMSG,TMP,VT
"RTN","RORUPD08",28,0)
 . S BUF=$G(RORVPLST(+IENS)),DE=""
"RTN","RORUPD08",29,0)
 . F  S DE=$O(RORUPD("SR",RORFILE,"F",2,DE))  Q:DE=""  D
"RTN","RORUPD08",30,0)
 . . S VT=""
"RTN","RORUPD08",31,0)
 . . F  S VT=$O(RORUPD("SR",RORFILE,"F",2,DE,VT))  Q:VT=""  D
"RTN","RORUPD08",32,0)
 . . . S IP=+$P(RORUPD("SR",RORFILE,"F",2,DE,VT),U)
"RTN","RORUPD08",33,0)
 . . . S:IP>0 RORVALS("DV",RORFILE,DE,VT)=$P(BUF,U,IP)
"RTN","RORUPD08",34,0)
 . ;--- External value of the POV field (.01)
"RTN","RORUPD08",35,0)
 . I $D(RORUPD("SR",RORFILE,"F",2,112,"E"))  D  Q:RC<0
"RTN","RORUPD08",36,0)
 . . S TMP=$P(BUF,U)_","  Q:TMP'>0
"RTN","RORUPD08",37,0)
 . . S RORVALS("DV",RORFILE,112,"E")=$$GET1^DIQ(80,TMP,.01,,,"RORMSG")
"RTN","RORUPD08",38,0)
 . . I $G(DIERR)  D  Q
"RTN","RORUPD08",39,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,"LOADVPOV^RORUPD08",,80,TMP)
"RTN","RORUPD08",40,0)
 Q 0
"RTN","RORUPD08",41,0)
 ;
"RTN","RORUPD08",42,0)
 ;***** LOAD 'VISIT' DATA ELEMENTS
"RTN","RORUPD08",43,0)
 ;
"RTN","RORUPD08",44,0)
 ; IENS          IENS of the current record
"RTN","RORUPD08",45,0)
 ;
"RTN","RORUPD08",46,0)
 ; Return values:
"RTN","RORUPD08",47,0)
 ;       <0  Error code
"RTN","RORUPD08",48,0)
 ;        0  Ok
"RTN","RORUPD08",49,0)
 ;
"RTN","RORUPD08",50,0)
LOADVSIT(IENS) ;
"RTN","RORUPD08",51,0)
 N RC  S RC=0
"RTN","RORUPD08",52,0)
 ;--- API #1
"RTN","RORUPD08",53,0)
 I $D(RORUPD("SR",RORFILE,"F",1))  D  Q:RC<0 RC
"RTN","RORUPD08",54,0)
 . S RC=$$LOADFLDS^RORUPDUT(RORFILE,IENS)
"RTN","RORUPD08",55,0)
 ;--- API #2
"RTN","RORUPD08",56,0)
 I $D(RORUPD("SR",RORFILE,"F",2))  D  Q:RC<0 RC
"RTN","RORUPD08",57,0)
 . N API,TMP,VSIT
"RTN","RORUPD08",58,0)
 . S TMP=$$LOOKUP^VSIT(+IENS,"B",0)
"RTN","RORUPD08",59,0)
 . I TMP<0  S API="$$LOOKUP^VSIT"  D  Q
"RTN","RORUPD08",60,0)
 . . S RC=$$ERROR^RORERR(-57,"LOADVSIT^RORUPD08",,,TMP,API)
"RTN","RORUPD08",61,0)
 . ;---
"RTN","RORUPD08",62,0)
 Q 0
"RTN","RORUPD08",63,0)
 ;
"RTN","RORUPD08",64,0)
 ;***** PROCESSING OF THE 'VISIT' FILE
"RTN","RORUPD08",65,0)
 ;
"RTN","RORUPD08",66,0)
 ; UPDSTART      Date of the earliest update
"RTN","RORUPD08",67,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD08",68,0)
 ;
"RTN","RORUPD08",69,0)
 ; Return values:
"RTN","RORUPD08",70,0)
 ;       <0  Error code
"RTN","RORUPD08",71,0)
 ;        0  Continue processing of the current patient
"RTN","RORUPD08",72,0)
 ;        1  Stop processing
"RTN","RORUPD08",73,0)
 ;
"RTN","RORUPD08",74,0)
 ; The function uses the ^TMP("VSIT",$J) global node.
"RTN","RORUPD08",75,0)
 ;
"RTN","RORUPD08",76,0)
VISIT(UPDSTART,PATIEN) ;
"RTN","RORUPD08",77,0)
 N RORFILE       ; File number
"RTN","RORUPD08",78,0)
 ;
"RTN","RORUPD08",79,0)
 N DATE,DSEND,IEN,RC,TMP,VISIENS
"RTN","RORUPD08",80,0)
 S RORFILE=9000010,DSEND=RORUPD("DSEND")
"RTN","RORUPD08",81,0)
 ;--- Check the event references if the events are enabled
"RTN","RORUPD08",82,0)
 I $G(RORUPD("FLAGS"))["E"  D  Q:RC'>0 RC
"RTN","RORUPD08",83,0)
 . S RC=$$GET^RORUPP02(PATIEN,2,.UPDSTART,.DSEND)
"RTN","RORUPD08",84,0)
 . S:RC>1 UPDSTART=UPDSTART\1,DSEND=$$FMADD^XLFDT(DSEND\1,1)
"RTN","RORUPD08",85,0)
 ;--- Get a list of visits
"RTN","RORUPD08",86,0)
 D SELECTED^VSIT(PATIEN,UPDSTART,DSEND)
"RTN","RORUPD08",87,0)
 ;
"RTN","RORUPD08",88,0)
 ;--- Browse through the visits
"RTN","RORUPD08",89,0)
 S (IEN,RC)=0
"RTN","RORUPD08",90,0)
 F  S IEN=$O(^TMP("VSIT",$J,IEN))  Q:IEN=""  D  Q:RC
"RTN","RORUPD08",91,0)
 . S VISIENS=IEN_",",TMP=+$O(^TMP("VSIT",$J,IEN,""))
"RTN","RORUPD08",92,0)
 . S DATE=$P($G(^TMP("VSIT",$J,IEN,TMP)),U)
"RTN","RORUPD08",93,0)
 . ;--- Load necessary data elements
"RTN","RORUPD08",94,0)
 . I $D(RORUPD("SR",RORFILE,"F"))>1  D  I TMP<0 D INCEC^RORUPDUT() Q
"RTN","RORUPD08",95,0)
 . . S TMP=$$LOADVSIT(VISIENS)
"RTN","RORUPD08",96,0)
 . ;--- Apply "before" rules
"RTN","RORUPD08",97,0)
 . S RC=$$APLRULES^RORUPDUT(RORFILE,VISIENS,"B",DATE)
"RTN","RORUPD08",98,0)
 . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD08",99,0)
 . ;
"RTN","RORUPD08",100,0)
 . ;--- Process V POV file
"RTN","RORUPD08",101,0)
 . I $D(RORUPD("SR",9000010.07))  D  I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD08",102,0)
 . . S RC=$$VPOV(IEN,DATE)
"RTN","RORUPD08",103,0)
 . ;
"RTN","RORUPD08",104,0)
 . ;--- Apply "after" rules
"RTN","RORUPD08",105,0)
 . S RC=$$APLRULES^RORUPDUT(RORFILE,VISIENS,"A",DATE)
"RTN","RORUPD08",106,0)
 . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD08",107,0)
 ;
"RTN","RORUPD08",108,0)
 K ^TMP("VSIT",$J)
"RTN","RORUPD08",109,0)
 D CLRDES^RORUPDUT(RORFILE)
"RTN","RORUPD08",110,0)
 Q RC
"RTN","RORUPD08",111,0)
 ;
"RTN","RORUPD08",112,0)
 ;***** PROCESSING OF THE 'V POV' FILE
"RTN","RORUPD08",113,0)
 ;
"RTN","RORUPD08",114,0)
 ; VISITIEN      IEN of the visit (in the "VISIT" file)
"RTN","RORUPD08",115,0)
 ; DATE          Visit date
"RTN","RORUPD08",116,0)
 ;
"RTN","RORUPD08",117,0)
 ; Return values:
"RTN","RORUPD08",118,0)
 ;       <0  Error code
"RTN","RORUPD08",119,0)
 ;        0  Continue processing of the current patient
"RTN","RORUPD08",120,0)
 ;        1  Stop processing
"RTN","RORUPD08",121,0)
 ;
"RTN","RORUPD08",122,0)
VPOV(VISITIEN,DATE) ;
"RTN","RORUPD08",123,0)
 N RORFILE       ; File number
"RTN","RORUPD08",124,0)
 N RORVPLST      ; List of records in the file
"RTN","RORUPD08",125,0)
 ;
"RTN","RORUPD08",126,0)
 N IEN,NODE,RC,TMP,VPIENS
"RTN","RORUPD08",127,0)
 S RORFILE=9000010.07
"RTN","RORUPD08",128,0)
 D CLRVALS^RORUPDUT(RORFILE)
"RTN","RORUPD08",129,0)
 ;--- Get a list of records
"RTN","RORUPD08",130,0)
 D POV^PXAPIIB(VISITIEN,.RORVPLST)
"RTN","RORUPD08",131,0)
 ;
"RTN","RORUPD08",132,0)
 S (IEN,RC)=0
"RTN","RORUPD08",133,0)
 F  S IEN=$O(RORVPLST(IEN))  Q:IEN=""  D  Q:RC
"RTN","RORUPD08",134,0)
 . S VPIENS=IEN_","
"RTN","RORUPD08",135,0)
 . ;--- Load necessary data elements
"RTN","RORUPD08",136,0)
 . I $D(RORUPD("SR",RORFILE,"F"))>1  D  I TMP<0 D INCEC^RORUPDUT() Q
"RTN","RORUPD08",137,0)
 . . S TMP=$$LOADVPOV(VPIENS)
"RTN","RORUPD08",138,0)
 . ;--- Apply "before" rules
"RTN","RORUPD08",139,0)
 . S RC=$$APLRULES^RORUPDUT(RORFILE,VPIENS,"B",DATE)
"RTN","RORUPD08",140,0)
 . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD08",141,0)
 . ;--- Apply "after" rules
"RTN","RORUPD08",142,0)
 . S RC=$$APLRULES^RORUPDUT(RORFILE,VPIENS,"A",DATE)
"RTN","RORUPD08",143,0)
 . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD08",144,0)
 ;
"RTN","RORUPD08",145,0)
 D CLRDES^RORUPDUT(RORFILE)
"RTN","RORUPD08",146,0)
 Q RC
"RTN","RORUPD09")
0^58^B8526659
"RTN","RORUPD09",1,0)
RORUPD09 ;HCIOFO/SG - PROCESSING OF THE 'PTF' FILE  ; 4/18/02 2:06pm
"RTN","RORUPD09",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPD09",3,0)
 ;
"RTN","RORUPD09",4,0)
 ; This routine uses the following IAs:
"RTN","RORUPD09",5,0)
 ;
"RTN","RORUPD09",6,0)
 ; #3157         RPC^DGPTFAPI
"RTN","RORUPD09",7,0)
 ; #3545         Access to the "AAD" cross-reference and the field 80
"RTN","RORUPD09",8,0)
 ;
"RTN","RORUPD09",9,0)
 Q
"RTN","RORUPD09",10,0)
 ;
"RTN","RORUPD09",11,0)
 ;***** LOADS DATA ELEMENT VALUES
"RTN","RORUPD09",12,0)
 ;
"RTN","RORUPD09",13,0)
 ; IENS          IENS of the current record
"RTN","RORUPD09",14,0)
 ;
"RTN","RORUPD09",15,0)
 ; Return values:
"RTN","RORUPD09",16,0)
 ;       <0  Error code
"RTN","RORUPD09",17,0)
 ;        0  Ok
"RTN","RORUPD09",18,0)
 ;
"RTN","RORUPD09",19,0)
LOAD(IENS) ;
"RTN","RORUPD09",20,0)
 N RC  S RC=0
"RTN","RORUPD09",21,0)
 ;--- API #1
"RTN","RORUPD09",22,0)
 I $D(RORUPD("SR",RORFILE,"F",1))  D  Q:RC<0 RC
"RTN","RORUPD09",23,0)
 . S RC=$$LOADFLDS^RORUPDUT(RORFILE,IENS)
"RTN","RORUPD09",24,0)
 ;--- API #2
"RTN","RORUPD09",25,0)
 I $D(RORUPD("SR",RORFILE,"F",2))  D  Q:RC<0 RC
"RTN","RORUPD09",26,0)
 . N API,DE,IN,IP,RORBUF,VT
"RTN","RORUPD09",27,0)
 . D RPC^DGPTFAPI(.RORBUF,+IENS)
"RTN","RORUPD09",28,0)
 . I $G(RORBUF(0))<0  S API="RPC^DGPTFAPI"  D  Q
"RTN","RORUPD09",29,0)
 . . S RC=$$ERROR^RORERR(-57,"LOADFLDS^RORUPD09",,,RORBUF(0),API)
"RTN","RORUPD09",30,0)
 . ;---
"RTN","RORUPD09",31,0)
 . S DE=""
"RTN","RORUPD09",32,0)
 . F  S DE=$O(RORUPD("SR",RORFILE,"F",2,DE))  Q:DE=""  D
"RTN","RORUPD09",33,0)
 . . S VT=""
"RTN","RORUPD09",34,0)
 . . F  S VT=$O(RORUPD("SR",RORFILE,"F",2,DE,VT))  Q:VT=""  D
"RTN","RORUPD09",35,0)
 . . . S IP=+$P(RORUPD("SR",RORFILE,"F",2,DE,VT),U,1)  Q:IP'>0
"RTN","RORUPD09",36,0)
 . . . S IN=+$P(RORUPD("SR",RORFILE,"F",2,DE,VT),U,2)
"RTN","RORUPD09",37,0)
 . . . S RORVALS("DV",RORFILE,DE,VT)=$P($G(RORBUF(IN)),U,IP)
"RTN","RORUPD09",38,0)
 Q 0
"RTN","RORUPD09",39,0)
 ;
"RTN","RORUPD09",40,0)
 ;***** PROCESSING OF THE 'PTF' FILE
"RTN","RORUPD09",41,0)
 ;
"RTN","RORUPD09",42,0)
 ; UPDSTART      Date of the earliest update
"RTN","RORUPD09",43,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD09",44,0)
 ;
"RTN","RORUPD09",45,0)
 ; Return values:
"RTN","RORUPD09",46,0)
 ;       <0  Error code
"RTN","RORUPD09",47,0)
 ;        0  Continue processing of the current patient
"RTN","RORUPD09",48,0)
 ;        1  Stop processing
"RTN","RORUPD09",49,0)
 ;
"RTN","RORUPD09",50,0)
PTF(UPDSTART,PATIEN) ;
"RTN","RORUPD09",51,0)
 N RORFILE       ; File number
"RTN","RORUPD09",52,0)
 ;
"RTN","RORUPD09",53,0)
 N ADMDT,ADMIENS,EDT,IEN,NODE,RC,TMP
"RTN","RORUPD09",54,0)
 S RORFILE=45,EDT=RORUPD("DSEND")
"RTN","RORUPD09",55,0)
 ;--- Check the event references if the events are enabled
"RTN","RORUPD09",56,0)
 I $G(RORUPD("FLAGS"))["E"  D  Q:RC'>0 RC
"RTN","RORUPD09",57,0)
 . S RC=$$GET^RORUPP02(PATIEN,3,.UPDSTART,.EDT)
"RTN","RORUPD09",58,0)
 . S:RC>1 UPDSTART=UPDSTART\1,EDT=$$FMADD^XLFDT(EDT\1,1)
"RTN","RORUPD09",59,0)
 ;--- Subtract 1 second from the start date to include
"RTN","RORUPD09",60,0)
 ;    it into the interval
"RTN","RORUPD09",61,0)
 S ADMDT=$$FMADD^XLFDT(UPDSTART,,,,-1)
"RTN","RORUPD09",62,0)
 ;
"RTN","RORUPD09",63,0)
 ;--- Browse through the admissions
"RTN","RORUPD09",64,0)
 S NODE=RORUPD("ROOT",RORFILE),NODE=$NA(@NODE@("AAD",PATIEN))
"RTN","RORUPD09",65,0)
 S RC=0
"RTN","RORUPD09",66,0)
 F  S ADMDT=$O(@NODE@(ADMDT))  Q:(ADMDT="")!(ADMDT'<EDT)  D  Q:RC
"RTN","RORUPD09",67,0)
 . S IEN=""
"RTN","RORUPD09",68,0)
 . F  S IEN=$O(@NODE@(ADMDT,IEN))  Q:IEN=""  D  Q:RC
"RTN","RORUPD09",69,0)
 . . S ADMIENS=IEN_","
"RTN","RORUPD09",70,0)
 . . ;--- Load necessary data elements
"RTN","RORUPD09",71,0)
 . . I $D(RORUPD("SR",RORFILE,"F"))>1  D  I TMP<0 D INCEC^RORUPDUT() Q
"RTN","RORUPD09",72,0)
 . . . S TMP=$$LOAD(ADMIENS)
"RTN","RORUPD09",73,0)
 . . ;--- Apply "before" rules
"RTN","RORUPD09",74,0)
 . . S RC=$$APLRULES^RORUPDUT(RORFILE,ADMIENS,"B",ADMDT)
"RTN","RORUPD09",75,0)
 . . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD09",76,0)
 . . ;--- Apply "after" rules
"RTN","RORUPD09",77,0)
 . . S RC=$$APLRULES^RORUPDUT(RORFILE,ADMIENS,"A",ADMDT)
"RTN","RORUPD09",78,0)
 . . I RC  D INCEC^RORUPDUT(.RC)  Q
"RTN","RORUPD09",79,0)
 ;
"RTN","RORUPD09",80,0)
 D CLRDES^RORUPDUT(RORFILE)
"RTN","RORUPD09",81,0)
 Q RC
"RTN","RORUPD09",82,0)
 ;
"RTN","RORUPD09",83,0)
 ;***** IMPLEMENTATION OF THE 'VA HEPC PTF' RULE
"RTN","RORUPD09",84,0)
PTFRULE(ICD) ;
"RTN","RORUPD09",85,0)
 N DATELMT,RC
"RTN","RORUPD09",86,0)
 S RC=0
"RTN","RORUPD09",87,0)
 F DATELMT=111,101,102,103,104,105,106,107,108,109,110  D  Q:RC
"RTN","RORUPD09",88,0)
 . S RC=ICD[(","_$G(RORVALS("DV",45,DATELMT,"E"))_",")
"RTN","RORUPD09",89,0)
 Q RC
"RTN","RORUPD50")
0^59^B13391732
"RTN","RORUPD50",1,0)
RORUPD50 ;HCIOFO/SG - UPDATE THE PATIENT IN THE REGISTRIES  ; 4/23/02 11:58am
"RTN","RORUPD50",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPD50",3,0)
 ;
"RTN","RORUPD50",4,0)
 ; This routine uses the following IAs:
"RTN","RORUPD50",5,0)
 ;
"RTN","RORUPD50",6,0)
 ; #3301         Access to the field #.6 of the file #2
"RTN","RORUPD50",7,0)
 ;
"RTN","RORUPD50",8,0)
 Q
"RTN","RORUPD50",9,0)
 ;
"RTN","RORUPD50",10,0)
 ;***** ADDS THE PATIENT TO THE REGISTRY
"RTN","RORUPD50",11,0)
 ;
"RTN","RORUPD50",12,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD50",13,0)
 ; REGIEN        Registry IEN
"RTN","RORUPD50",14,0)
 ;
"RTN","RORUPD50",15,0)
 ; [ROR8RULS]    Closed root of a local array containing list of
"RTN","RORUPD50",16,0)
 ;               triggered selection rules:
"RTN","RORUPD50",17,0)
 ;                 @ROR8RULS@(RuleIEN)=Date
"RTN","RORUPD50",18,0)
 ;               If this parameter is not defined or equals to
"RTN","RORUPD50",19,0)
 ;               an empty string, selection rules are loaded from
"RTN","RORUPD50",20,0)
 ;               corresponding sub-node of the ^TMP("RORUPD",$J,"U").
"RTN","RORUPD50",21,0)
 ;
"RTN","RORUPD50",22,0)
 ; [[.]DOD]      Date of death. If this parameter is undefined,
"RTN","RORUPD50",23,0)
 ;               its value will be taken from the ROR PATIENT file.
"RTN","RORUPD50",24,0)
 ;               If you are going to call this function several times
"RTN","RORUPD50",25,0)
 ;               for the same patient (for different registries),
"RTN","RORUPD50",26,0)
 ;               pass a reference to undefined local variable (the
"RTN","RORUPD50",27,0)
 ;               DOD will be read from the file only once).
"RTN","RORUPD50",28,0)
 ;
"RTN","RORUPD50",29,0)
 ; Return values:
"RTN","RORUPD50",30,0)
 ;       <0  Error code
"RTN","RORUPD50",31,0)
 ;        0  Ok
"RTN","RORUPD50",32,0)
 ;        1  Patient has already existed in the registry
"RTN","RORUPD50",33,0)
 ;
"RTN","RORUPD50",34,0)
ADD(PATIEN,REGIEN,ROR8RULS,DOD) ;
"RTN","RORUPD50",35,0)
 N FINDVAL,I,IENS,IENS01,RC,RORFDA,RORIEN,RORMSG,RULEIEN,TMP
"RTN","RORUPD50",36,0)
 ;--- Try to find the patient in the registry
"RTN","RORUPD50",37,0)
 S FINDVAL(1)=PATIEN,FINDVAL(2)=REGIEN
"RTN","RORUPD50",38,0)
 D FIND^DIC(798,,"@","QX",.FINDVAL,1,"KEY",,,"RORFDA","RORMSG")
"RTN","RORUPD50",39,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ADD^RORUPD50",,798)
"RTN","RORUPD50",40,0)
 ;--- Patient already in the registry
"RTN","RORUPD50",41,0)
 Q:$G(RORFDA("DILIST",0)) 1
"RTN","RORUPD50",42,0)
 ;--- Prepare registry data
"RTN","RORUPD50",43,0)
 K RORFDA  S IENS="+1,"
"RTN","RORUPD50",44,0)
 S RORFDA(798,IENS,.01)=PATIEN           ; Patient Name
"RTN","RORUPD50",45,0)
 S RORFDA(798,IENS,.02)=REGIEN           ; Registry
"RTN","RORUPD50",46,0)
 S RORFDA(798,IENS,1)=$$NOW^XLFDT        ; Date/time entered
"RTN","RORUPD50",47,0)
 S RORFDA(798,IENS,3)=1                  ; Status (AUTO)
"RTN","RORUPD50",48,0)
 S RORFDA(798,IENS,4)=1                  ; Update Demographics
"RTN","RORUPD50",49,0)
 S RORFDA(798,IENS,5)=1                  ; Update local data
"RTN","RORUPD50",50,0)
 ;--- Populate the inactivation date field if necessary
"RTN","RORUPD50",51,0)
 S:'($D(DOD)#10) DOD=$$GET1^DIQ(798.4,PATIEN_",",.351,"I",,"RORMSG")
"RTN","RORUPD50",52,0)
 S RORFDA(798,IENS,2)=$$INACTDOD^RORUPDUT(DOD)
"RTN","RORUPD50",53,0)
 ;--- Set the DON'T SEND flag for a "test patient"
"RTN","RORUPD50",54,0)
 S TMP=$$GET1^DIQ(2,PATIEN_",",.6,"I",,"RORMSG")
"RTN","RORUPD50",55,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ADD^RORUPD50",PATIEN,2)
"RTN","RORUPD50",56,0)
 S:TMP RORFDA(798,IENS,11)=1
"RTN","RORUPD50",57,0)
 ;--- Load list of triggered rules
"RTN","RORUPD50",58,0)
 S:$G(ROR8RULS)="" ROR8RULS=$NA(@RORUPDPI@("U",PATIEN,2,REGIEN))
"RTN","RORUPD50",59,0)
 S RULEIEN=""
"RTN","RORUPD50",60,0)
 F I=1:1  S RULEIEN=$O(@ROR8RULS@(RULEIEN))  Q:RULEIEN=""  D
"RTN","RORUPD50",61,0)
 . S IENS01="+"_(1000+I)_","_IENS
"RTN","RORUPD50",62,0)
 . S RORFDA(798.01,IENS01,.01)=RULEIEN
"RTN","RORUPD50",63,0)
 . S RORFDA(798.01,IENS01,1)=$P(@ROR8RULS@(RULEIEN),U)\1
"RTN","RORUPD50",64,0)
 ;--- Call "before update" entry point
"RTN","RORUPD50",65,0)
 S ENTRY=$G(RORUPD("UPD",REGIEN,1))
"RTN","RORUPD50",66,0)
 I ENTRY'=""  X "S RC="_ENTRY_"(.RORFDA,PATIEN,REGIEN)"  Q:RC<0 RC
"RTN","RORUPD50",67,0)
 ;--- Update the registry
"RTN","RORUPD50",68,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORUPD50",69,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ADD^RORUPD50")
"RTN","RORUPD50",70,0)
 ;--- Call "after update" entry point
"RTN","RORUPD50",71,0)
 S ENTRY=$G(RORUPD("UPD",REGIEN,2))
"RTN","RORUPD50",72,0)
 I ENTRY'=""  X "S RC="_ENTRY_"(RORIEN(1),PATIEN,REGIEN)"  Q:RC<0 RC
"RTN","RORUPD50",73,0)
 Q 0
"RTN","RORUPD50",74,0)
 ;
"RTN","RORUPD50",75,0)
 ;***** ADDS PATIENT DATA TO THE 'ROR PATIENT' FILE
"RTN","RORUPD50",76,0)
 ;
"RTN","RORUPD50",77,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD50",78,0)
 ;
"RTN","RORUPD50",79,0)
 ; Return values:
"RTN","RORUPD50",80,0)
 ;       <0  Error code
"RTN","RORUPD50",81,0)
 ;        0  Ok
"RTN","RORUPD50",82,0)
 ;        1  Patient data have already existed
"RTN","RORUPD50",83,0)
 ;
"RTN","RORUPD50",84,0)
ADDPDATA(PATIEN) ;
"RTN","RORUPD50",85,0)
 N IENS,RC,RORBUF,RORPAT,RORIEN,RORMSG
"RTN","RORUPD50",86,0)
 ;--- Try to find patient data
"RTN","RORUPD50",87,0)
 D FIND^DIC(798.4,,"@","QX",PATIEN,1,"B",,,"RORBUF","RORMSG")
"RTN","RORUPD50",88,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ADDPDATA^RORUPD50",,798.4)
"RTN","RORUPD50",89,0)
 ;--- Patient data already exist in the file
"RTN","RORUPD50",90,0)
 Q:$G(RORBUF("DILIST",0)) 1
"RTN","RORUPD50",91,0)
 ;--- Prepare patient data
"RTN","RORUPD50",92,0)
 S IENS="+1,"
"RTN","RORUPD50",93,0)
 S RC=$$PATDATA^RORUPD52(PATIEN_",",.RORPAT,IENS)  Q:RC<0 RC
"RTN","RORUPD50",94,0)
 S RORIEN(1)=PATIEN                      ; IEN of the new record
"RTN","RORUPD50",95,0)
 S RORPAT(798.4,IENS,.01)=PATIEN         ; Patient Name
"RTN","RORUPD50",96,0)
 ;--- Add the patient record to the file
"RTN","RORUPD50",97,0)
 D UPDATE^DIE(,"RORPAT","RORIEN","RORMSG")
"RTN","RORUPD50",98,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ADDPDATA^RORUPD50",,798.4)
"RTN","RORUPD50",99,0)
 Q 0
"RTN","RORUPD50",100,0)
 ;
"RTN","RORUPD50",101,0)
 ;***** ADDS THE PATIENT TO MARKED REGISTRIES
"RTN","RORUPD50",102,0)
 ;
"RTN","RORUPD50",103,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD50",104,0)
 ;
"RTN","RORUPD50",105,0)
 ; Return values:
"RTN","RORUPD50",106,0)
 ;       <0  Error code
"RTN","RORUPD50",107,0)
 ;        0  Patient should not be added to the registry
"RTN","RORUPD50",108,0)
 ;       >0  Patient has been added to the registry
"RTN","RORUPD50",109,0)
 ;
"RTN","RORUPD50",110,0)
UPDREG(PATIEN) ;
"RTN","RORUPD50",111,0)
 N DOD,ENTRY,INCTVDT,RC,REGIEN
"RTN","RORUPD50",112,0)
 ;--- Check if patient should be added to any registry
"RTN","RORUPD50",113,0)
 Q:$D(@RORUPDPI@("U",PATIEN,2))<10 0
"RTN","RORUPD50",114,0)
 ;--- Add patient data
"RTN","RORUPD50",115,0)
 S RC=$$ADDPDATA(PATIEN)  Q:RC<0 RC
"RTN","RORUPD50",116,0)
 ;--- Update all marked registries
"RTN","RORUPD50",117,0)
 S REGIEN="",RC=0
"RTN","RORUPD50",118,0)
 F  D  Q:REGIEN=""  S RC=$$ADD(PATIEN,REGIEN,,.DOD)  Q:RC<0
"RTN","RORUPD50",119,0)
 . S REGIEN=$O(@RORUPDPI@("U",PATIEN,2,REGIEN))
"RTN","RORUPD50",120,0)
 Q $S(RC<0:RC,1:1)
"RTN","RORUPD51")
0^60^B53647533
"RTN","RORUPD51",1,0)
RORUPD51 ;HCIOFO/SG - UPDATE PATIENT'S DEMOGRAPHIC DATA (1) ; 4/23/02 11:02am
"RTN","RORUPD51",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPD51",3,0)
 ;
"RTN","RORUPD51",4,0)
 ; This routine uses the following IAs:
"RTN","RORUPD51",5,0)
 ;
"RTN","RORUPD51",6,0)
 ; #174          Access to the multiple #.3721 of the file #2
"RTN","RORUPD51",7,0)
 ;
"RTN","RORUPD51",8,0)
 Q
"RTN","RORUPD51",9,0)
 ;
"RTN","RORUPD51",10,0)
 ;***** MARKS REGISTRIES (UPDATE DEMOGRAPHICS AND INACTIVE DATE)
"RTN","RORUPD51",11,0)
 ;
"RTN","RORUPD51",12,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD51",13,0)
 ; [DOD]         Date of death
"RTN","RORUPD51",14,0)
 ;
"RTN","RORUPD51",15,0)
 ; Return Values:
"RTN","RORUPD51",16,0)
 ;       <0  Error code
"RTN","RORUPD51",17,0)
 ;        0  Ok
"RTN","RORUPD51",18,0)
 ;
"RTN","RORUPD51",19,0)
MARKREGS(PATIEN,DOD) ;
"RTN","RORUPD51",20,0)
 N ACTIVE,ECNT,I,IENS,INACTDT,RC,REACTDT,RI
"RTN","RORUPD51",21,0)
 N RORBUF,RORFDA,RORMSG,RORSRC
"RTN","RORUPD51",22,0)
 ;--- Compile a list of associated registries
"RTN","RORUPD51",23,0)
 D FIND^DIC(798,,"@","QX",PATIEN,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPD51",24,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"MARKREGS^RORUPD51",,798)
"RTN","RORUPD51",25,0)
 ;--- Mark patient records of the registries
"RTN","RORUPD51",26,0)
 S RI="",ECNT=0
"RTN","RORUPD51",27,0)
 F  S RI=$O(RORBUF("DILIST",2,RI))  Q:RI=""  D  L -^RORDATA(798,+IENS)
"RTN","RORUPD51",28,0)
 . S IENS=RORBUF("DILIST",2,RI)_","
"RTN","RORUPD51",29,0)
 . K RORFDA,RORSRC
"RTN","RORUPD51",30,0)
 . ;--- Try to lock the record; if this fails, continue anyway
"RTN","RORUPD51",31,0)
 . L +^RORDATA(798,+IENS):1
"RTN","RORUPD51",32,0)
 . ;--- Load the field values
"RTN","RORUPD51",33,0)
 . D GETS^DIQ(798,IENS,"2;2.2;4;7;8","EI","RORSRC","RORMSG")
"RTN","RORUPD51",34,0)
 . I $G(DIERR)  D  S ECNT=ECNT+1  Q
"RTN","RORUPD51",35,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"MARKREGS^RORUPD51",,798,IENS)
"RTN","RORUPD51",36,0)
 . S ACTIVE=+$G(RORSRC(798,IENS,8,"E"))
"RTN","RORUPD51",37,0)
 . S INACTDT=$G(RORSRC(798,IENS,2,"I"))
"RTN","RORUPD51",38,0)
 . S REACTDT=$G(RORSRC(798,IENS,7,"I"))
"RTN","RORUPD51",39,0)
 . ;--- Update inactivation date only if the DOD parameter
"RTN","RORUPD51",40,0)
 . ;    is defined and the patient has not been inactivated
"RTN","RORUPD51",41,0)
 . ;    by a reason other than death
"RTN","RORUPD51",42,0)
 . I $D(DOD),'$G(RORSRC(798,IENS,2.2,"I"))  D
"RTN","RORUPD51",43,0)
 . . ;--- Do nothing if the patient is alive and there is no
"RTN","RORUPD51",44,0)
 . . ;    inactivation date in his record
"RTN","RORUPD51",45,0)
 . . I 'DOD  Q:'INACTDT
"RTN","RORUPD51",46,0)
 . . S (RORFDA(798,IENS,2),INACTDT)=$$INACTDOD^RORUPDUT(DOD)
"RTN","RORUPD51",47,0)
 . . S RORFDA(798,IENS,2.1)="@"
"RTN","RORUPD51",48,0)
 . ;--- Do not mark again if already marked
"RTN","RORUPD51",49,0)
 . I '$G(RORSRC(798,IENS,4,"I"))  S RC=0  D  Q:RC<0
"RTN","RORUPD51",50,0)
 . . ;--- Check the new status of the record if it was
"RTN","RORUPD51",51,0)
 . . ;    not active before
"RTN","RORUPD51",52,0)
 . . S:'ACTIVE ACTIVE=$$ACTIVE^RORDD(INACTDT,REACTDT)
"RTN","RORUPD51",53,0)
 . . ;--- Mark only active (now or before) records
"RTN","RORUPD51",54,0)
 . . S:ACTIVE RORFDA(798,IENS,4)=1
"RTN","RORUPD51",55,0)
 . ;--- Update registry data record
"RTN","RORUPD51",56,0)
 . I $D(RORFDA)>1  S RC=0  D  Q:RC<0
"RTN","RORUPD51",57,0)
 . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUPD51",58,0)
 . . I $G(DIERR)  D  S ECNT=ECNT+1
"RTN","RORUPD51",59,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,"MARKREGS^RORUPD51",,798,IENS)
"RTN","RORUPD51",60,0)
 Q $S(ECNT>0:-9,1:0)
"RTN","RORUPD51",61,0)
 ;
"RTN","RORUPD51",62,0)
 ;***** COMPARES/UPDATES CONTENT OF A MULTIPLE FIELD
"RTN","RORUPD51",63,0)
 ;
"RTN","RORUPD51",64,0)
 ; SFN2          Sub-file number in the PATIENT file
"RTN","RORUPD51",65,0)
 ; IENS2         IENS of the main record
"RTN","RORUPD51",66,0)
 ; SFN798        Sub-file number in the ROR PATIENT file
"RTN","RORUPD51",67,0)
 ; IENS798       IENS of the main record
"RTN","RORUPD51",68,0)
 ; FLDLST        List of fields separated by semicolon
"RTN","RORUPD51",69,0)
 ;
"RTN","RORUPD51",70,0)
 ; Return Values:
"RTN","RORUPD51",71,0)
 ;       <0  Error code
"RTN","RORUPD51",72,0)
 ;        0  Data in the multiple have not been changed
"RTN","RORUPD51",73,0)
 ;       >0  Data have been changed
"RTN","RORUPD51",74,0)
 ;
"RTN","RORUPD51",75,0)
PATMULT(SFN2,IENS2,SFN798,IENS798,FLDLST) ;
"RTN","RORUPD51",76,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD51",77,0)
 ;
"RTN","RORUPD51",78,0)
 N COUNT,FLD,I,IEN,IENS,IENSD,IR,RC,ROOT2,ROOT798
"RTN","RORUPD51",79,0)
 N RORB2,RORB798,RORFDA,RORIEN,RORMSG,VAL,TMP
"RTN","RORUPD51",80,0)
 D DFLTLOC^RORERR("PATMULT^RORUPD51")
"RTN","RORUPD51",81,0)
 S ROOT2=$$ROOT^DILFD(SFN2,","_IENS2,1),COUNT=0
"RTN","RORUPD51",82,0)
 ;--- Delete unnecesary sub-file records from the destination file
"RTN","RORUPD51",83,0)
 I IENS798?1.N.1","  S RC=0  D  Q:RC<0 RC
"RTN","RORUPD51",84,0)
 . S ROOT798=$$ROOT^DILFD(SFN798,","_IENS798,1)
"RTN","RORUPD51",85,0)
 . S IEN=0
"RTN","RORUPD51",86,0)
 . F  S IEN=$O(@ROOT798@(IEN))  Q:'IEN  D:'$D(@ROOT2@(IEN))  Q:RC<0
"RTN","RORUPD51",87,0)
 . . S IENS=IEN_","_IENS798
"RTN","RORUPD51",88,0)
 . . S RORFDA(SFN798,IENS,.01)="@",COUNT=COUNT+1
"RTN","RORUPD51",89,0)
 . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUPD51",90,0)
 . . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,SFN798,IENS)
"RTN","RORUPD51",91,0)
 E  S ROOT798=""
"RTN","RORUPD51",92,0)
 ;--- Add/Update records of the sub-file in the destination file
"RTN","RORUPD51",93,0)
 S (IEN,IR,RC)=0
"RTN","RORUPD51",94,0)
 F  S IEN=$O(@ROOT2@(IEN))  Q:'IEN  D  Q:RC<0
"RTN","RORUPD51",95,0)
 . K RORB2,RORB798
"RTN","RORUPD51",96,0)
 . S IENS=IEN_","_IENS2
"RTN","RORUPD51",97,0)
 . D GETS^DIQ(SFN2,IENS,FLDLST,"I","RORB2","RORMSG")
"RTN","RORUPD51",98,0)
 . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,SFN2,IENS)  Q
"RTN","RORUPD51",99,0)
 . ;--- Update the existing record
"RTN","RORUPD51",100,0)
 . I ROOT798'="",$D(@ROOT798@(IEN))  D  Q
"RTN","RORUPD51",101,0)
 . . S IENSD=IEN_","_IENS798
"RTN","RORUPD51",102,0)
 . . D GETS^DIQ(SFN798,IENSD,FLDLST,"I","RORB798","RORMSG")
"RTN","RORUPD51",103,0)
 . . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,SFN798,IENSD)  Q
"RTN","RORUPD51",104,0)
 . . F I=1:1  S FLD=$P(FLDLST,";",I)  Q:FLD=""  D
"RTN","RORUPD51",105,0)
 . . . S VAL=$G(RORB2(SFN2,IENS,FLD,"I"))
"RTN","RORUPD51",106,0)
 . . . S TMP=$G(RORB798(SFN798,IENSD,FLD,"I"))
"RTN","RORUPD51",107,0)
 . . . S:TMP'=VAL RORFDA(SFN798,IENSD,FLD)=VAL
"RTN","RORUPD51",108,0)
 . . Q:$D(RORFDA)<10
"RTN","RORUPD51",109,0)
 . . ;--- Update the record
"RTN","RORUPD51",110,0)
 . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUPD51",111,0)
 . . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,SFN798,IENS798)  Q
"RTN","RORUPD51",112,0)
 . . S COUNT=COUNT+1
"RTN","RORUPD51",113,0)
 . ;--- Add a new record
"RTN","RORUPD51",114,0)
 . S IR=IR+1,IENSD="+"_(IR+100)_","_IENS798
"RTN","RORUPD51",115,0)
 . F I=1:1  S FLD=$P(FLDLST,";",I)  Q:FLD=""  D
"RTN","RORUPD51",116,0)
 . . S RORFDA(SFN798,IENSD,FLD)=$G(RORB2(SFN2,IENS,FLD,"I"))
"RTN","RORUPD51",117,0)
 . S RORIEN(IR+100)=IEN
"RTN","RORUPD51",118,0)
 . Q:$D(RORFDA)<10
"RTN","RORUPD51",119,0)
 . ;--- Add the record
"RTN","RORUPD51",120,0)
 . D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORUPD51",121,0)
 . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,SFN798,IENS798)  Q
"RTN","RORUPD51",122,0)
 . S COUNT=COUNT+1
"RTN","RORUPD51",123,0)
 Q $S(RC<0:RC,1:COUNT)
"RTN","RORUPD51",124,0)
 ;
"RTN","RORUPD51",125,0)
 ;***** SCANS PATIENTS AND UPDATES DEMOGRAPHIC DATA (IF NECESSARY)
"RTN","RORUPD51",126,0)
 ;
"RTN","RORUPD51",127,0)
 ; .REGLST       Reference to a local array containing
"RTN","RORUPD51",128,0)
 ;               registry names as subscripts
"RTN","RORUPD51",129,0)
 ;
"RTN","RORUPD51",130,0)
 ; Return Values:
"RTN","RORUPD51",131,0)
 ;       <0  Error code
"RTN","RORUPD51",132,0)
 ;        0  Ok
"RTN","RORUPD51",133,0)
 ;
"RTN","RORUPD51",134,0)
UPDDEM(REGLST) ;
"RTN","RORUPD51",135,0)
 N CNT,IR,PATIEN,RC,REGIEN,REGNAME,ROOT,SCR,UPD,UPDCNT
"RTN","RORUPD51",136,0)
 N RORLOR,RORLST,RORMSG
"RTN","RORUPD51",137,0)
 S ROOT=$$ROOT^DILFD(798,,1)
"RTN","RORUPD51",138,0)
 ;--- Compile a list of registry internal entry numbers
"RTN","RORUPD51",139,0)
 S REGNAME="",RC=0
"RTN","RORUPD51",140,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPD51",141,0)
 . S RC=+$G(REGLST(REGNAME))
"RTN","RORUPD51",142,0)
 . S:RC'>0 RC=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUPD51",143,0)
 . S:RC>0 RORLOR(+RC)=""
"RTN","RORUPD51",144,0)
 Q:RC<0 RC
"RTN","RORUPD51",145,0)
 ;--- Loop through the patients of the registries
"RTN","RORUPD51",146,0)
 S PATIEN="",(CNT,RC)=0
"RTN","RORUPD51",147,0)
 F  S PATIEN=$O(@ROOT@("B",PATIEN))  Q:PATIEN=""  D  Q:RC<0
"RTN","RORUPD51",148,0)
 . ;--- Check if task stop has been requested
"RTN","RORUPD51",149,0)
 . I $D(ZTQUEUED),$$S^%ZTLOAD  D  Q
"RTN","RORUPD51",150,0)
 . . S RC=$$ERROR^RORERR(-42,"UPDDEM^RORUPD51")
"RTN","RORUPD51",151,0)
 . S CNT=CNT+1
"RTN","RORUPD51",152,0)
 . I $G(RORPARM("DEBUG"))>1  W:$E($G(IOST),1,2)="C-" *13,CNT
"RTN","RORUPD51",153,0)
 . ;--- Load a list of patient's registry records
"RTN","RORUPD51",154,0)
 . S SCR="S Y=+$P($G(^(0)),U,2) I Y,$D(RORLOR(Y))"
"RTN","RORUPD51",155,0)
 . D FIND^DIC(798,,"@;.02I;2.2I;8E","QX",PATIEN,,"B",SCR,,"RORLST","RORMSG")
"RTN","RORUPD51",156,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD51",157,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"UPDDEM^RORUPD51")
"RTN","RORUPD51",158,0)
 . ;--- Demographic data should be checked only if at least one of
"RTN","RORUPD51",159,0)
 . ;    the registry records of the patient is either active or the
"RTN","RORUPD51",160,0)
 . ;    REASON FOR INACTIVATION field (798,2.2) has no value (this
"RTN","RORUPD51",161,0)
 . ;    means that the patient has been inactivated because of death).
"RTN","RORUPD51",162,0)
 . S IR="",UPDCNT=0
"RTN","RORUPD51",163,0)
 . F  S IR=$O(RORLST("DILIST","ID",IR))  Q:IR=""  D
"RTN","RORUPD51",164,0)
 . . S UPD=+$G(RORLST("DILIST","ID",IR,8))
"RTN","RORUPD51",165,0)
 . . S REGIEN=+$G(RORLST("DILIST","ID",IR,.02))
"RTN","RORUPD51",166,0)
 . . S CNT(REGIEN,UPD)=$G(CNT(REGIEN,UPD))+1
"RTN","RORUPD51",167,0)
 . . ;---
"RTN","RORUPD51",168,0)
 . . S:'UPD UPD='$G(RORLST("DILIST","ID",IR,2.2))
"RTN","RORUPD51",169,0)
 . . S:UPD UPDCNT=UPDCNT+1
"RTN","RORUPD51",170,0)
 . S:UPDCNT RC=$$UPDPTDEM(PATIEN)
"RTN","RORUPD51",171,0)
 D:RC'<0 UPDRCNT(.CNT)
"RTN","RORUPD51",172,0)
 Q RC
"RTN","RORUPD51",173,0)
 ;
"RTN","RORUPD51",174,0)
 ;***** UPDATES DEMOGRAPHIC DATA OF THE PATIENT (IF NECESSARY)
"RTN","RORUPD51",175,0)
 ;
"RTN","RORUPD51",176,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD51",177,0)
 ;
"RTN","RORUPD51",178,0)
 ; Return Values:
"RTN","RORUPD51",179,0)
 ;       <0  Error code
"RTN","RORUPD51",180,0)
 ;        0  Ok
"RTN","RORUPD51",181,0)
 ;
"RTN","RORUPD51",182,0)
UPDPTDEM(PATIEN) ;
"RTN","RORUPD51",183,0)
 N CF,DOD,IENS,RC,RORMSG,RORPAT
"RTN","RORUPD51",184,0)
 S IENS=PATIEN_",",CF=0
"RTN","RORUPD51",185,0)
 ;--- Try to lock the record of the ROR PATIENT file
"RTN","RORUPD51",186,0)
 L +^RORDATA(798.4,PATIEN):1
"RTN","RORUPD51",187,0)
 E  Q $$ERROR^RORERR(-11,"UPDPTDEM^RORUPD51",,PATIEN,"file #798.4")
"RTN","RORUPD51",188,0)
 D
"RTN","RORUPD51",189,0)
 . ;--- Compare demographic data
"RTN","RORUPD51",190,0)
 . S RC=$$PATDATA^RORUPD52(IENS,.RORPAT,IENS,.DOD)  Q:RC<0
"RTN","RORUPD51",191,0)
 . S:RC CF=1
"RTN","RORUPD51",192,0)
 . ;--- Compare/update list of disabilities
"RTN","RORUPD51",193,0)
 . S RC=$$PATMULT(2.04,IENS,798.41,IENS,".01;2;3")  Q:RC<0
"RTN","RORUPD51",194,0)
 . S:RC CF=1
"RTN","RORUPD51",195,0)
 . ;--- Mark registry records of the patient
"RTN","RORUPD51",196,0)
 . I CF  S RC=$$MARKREGS(PATIEN,$G(DOD))  Q:RC<0
"RTN","RORUPD51",197,0)
 . ;--- Update demographic data
"RTN","RORUPD51",198,0)
 . I CF,$D(RORPAT)  S RC=0  D  Q:RC<0
"RTN","RORUPD51",199,0)
 . . D FILE^DIE(,"RORPAT","RORMSG")
"RTN","RORUPD51",200,0)
 . . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,"UPDPTDEM^RORUPD51")
"RTN","RORUPD51",201,0)
 ;
"RTN","RORUPD51",202,0)
 L -^RORDATA(798.4,PATIEN)
"RTN","RORUPD51",203,0)
 Q 0
"RTN","RORUPD51",204,0)
 ;
"RTN","RORUPD51",205,0)
 ;***** UPDATES RECORD COUNTERS IN THE 'ROR REGISTRY PARAMETERS' FILE
"RTN","RORUPD51",206,0)
 ;
"RTN","RORUPD51",207,0)
 ; .CNT(         Reference to a local array containg registry
"RTN","RORUPD51",208,0)
 ;               record counters
"RTN","RORUPD51",209,0)
 ;   Registry#,
"RTN","RORUPD51",210,0)
 ;     0)        Number of inactive records
"RTN","RORUPD51",211,0)
 ;     1)        Number of active records
"RTN","RORUPD51",212,0)
 ;
"RTN","RORUPD51",213,0)
UPDRCNT(CNT) ;
"RTN","RORUPD51",214,0)
 N IENS,RC,REGIEN,RORFDA,RORMSG
"RTN","RORUPD51",215,0)
 S REGIEN=0
"RTN","RORUPD51",216,0)
 F  S REGIEN=$O(CNT(REGIEN))  Q:REGIEN=""  D
"RTN","RORUPD51",217,0)
 . S IENS=REGIEN_","
"RTN","RORUPD51",218,0)
 . S RORFDA(798.1,IENS,19.1)=$G(CNT(REGIEN,0))+$G(CNT(REGIEN,1))
"RTN","RORUPD51",219,0)
 . S RORFDA(798.1,IENS,19.2)=$G(CNT(REGIEN,1))
"RTN","RORUPD51",220,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUPD51",221,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD51",222,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"UPDRCNT^RORUPD51",798.1,IENS)
"RTN","RORUPD51",223,0)
 Q
"RTN","RORUPD52")
0^61^B8252177
"RTN","RORUPD52",1,0)
RORUPD52 ;HCIOFO/SG - UPDATE PATIENT'S DEMOGRAPHIC DATA (2) ; 3/28/02 10:49am
"RTN","RORUPD52",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPD52",3,0)
 ;
"RTN","RORUPD52",4,0)
 ; This routine uses the following IAs:
"RTN","RORUPD52",5,0)
 ;
"RTN","RORUPD52",6,0)
 ; #2701         $$GETICN^MPIF001  Gets ICN
"RTN","RORUPD52",7,0)
 ; #10035        Access to fields .02,.03,.06,.09,.351 of the file #2
"RTN","RORUPD52",8,0)
 ; #10061        6^VADPT
"RTN","RORUPD52",9,0)
 ;
"RTN","RORUPD52",10,0)
 Q
"RTN","RORUPD52",11,0)
 ;
"RTN","RORUPD52",12,0)
 ;***** LOADS THE DATA FROM THE 'PATIENT' FILE USING APIs
"RTN","RORUPD52",13,0)
 ;
"RTN","RORUPD52",14,0)
 ; RORIENS       Patient IENS in the PATIENT file
"RTN","RORUPD52",15,0)
 ; .RORBUF       Reference to the buffer for field values
"RTN","RORUPD52",16,0)
 ;
"RTN","RORUPD52",17,0)
 ; Return Values:
"RTN","RORUPD52",18,0)
 ;       <0  Error code
"RTN","RORUPD52",19,0)
 ;        0  Ok
"RTN","RORUPD52",20,0)
 ;
"RTN","RORUPD52",21,0)
LOAD(RORIENS,RORBUF) ;
"RTN","RORUPD52",22,0)
 N DFN,TMP,VADM,VAEL,VAERR,VAHOW,VAPA,VAROOT
"RTN","RORUPD52",23,0)
 S DFN=+RORIENS  D 6^VADPT
"RTN","RORUPD52",24,0)
 D:'$G(VAERR)
"RTN","RORUPD52",25,0)
 . ;--- Service connected
"RTN","RORUPD52",26,0)
 . S RORBUF(2,RORIENS,.301,"I")=$S($G(VAEL(3)):"Y",1:"N")
"RTN","RORUPD52",27,0)
 . ;---Service connected percentage
"RTN","RORUPD52",28,0)
 . S RORBUF(2,RORIENS,.302,"I")=$P($G(VAEL(3)),U,2)
"RTN","RORUPD52",29,0)
 . ;--- Period of service
"RTN","RORUPD52",30,0)
 . S RORBUF(2,RORIENS,.323,"I")=$P($G(VAEL(2)),U)
"RTN","RORUPD52",31,0)
 . ;--- ZIP+4
"RTN","RORUPD52",32,0)
 . S RORBUF(2,RORIENS,.1112,"I")=$P($G(VAPA(11)),U)
"RTN","RORUPD52",33,0)
 ;--- Integration Control Number
"RTN","RORUPD52",34,0)
 S TMP=$$GETICN^MPIF001(+RORIENS)
"RTN","RORUPD52",35,0)
 S:TMP>0 RORBUF(2,RORIENS,991.01,"I")=$P(TMP,"V")
"RTN","RORUPD52",36,0)
 Q 0
"RTN","RORUPD52",37,0)
 ;
"RTN","RORUPD52",38,0)
 ;***** GETS AND PREPARES PATIENT'S DATA
"RTN","RORUPD52",39,0)
 ;
"RTN","RORUPD52",40,0)
 ; PATIENS       Patient IENS in the PATIENT file
"RTN","RORUPD52",41,0)
 ; .RORPAT       Reference to the FDA for field values
"RTN","RORUPD52",42,0)
 ; RORIENS       IENS of the record in the ROR PATIENT file
"RTN","RORUPD52",43,0)
 ; [.DOD]        Date of death is returned via this parameter
"RTN","RORUPD52",44,0)
 ;
"RTN","RORUPD52",45,0)
 ; Return Values:
"RTN","RORUPD52",46,0)
 ;       <0  Error code
"RTN","RORUPD52",47,0)
 ;        0  Patient data has not been changed
"RTN","RORUPD52",48,0)
 ;       >0  Data has been changed
"RTN","RORUPD52",49,0)
 ;
"RTN","RORUPD52",50,0)
PATDATA(PATIENS,RORPAT,RORIENS,DOD) ;
"RTN","RORUPD52",51,0)
 N COUNT,FIELD,FLDLST,I,OLDVAL,RC,RORBUF,RORMSG,TMP
"RTN","RORUPD52",52,0)
 S DOD="",FLDLST=$$PATFLDS(1)
"RTN","RORUPD52",53,0)
 S:PATIENS'["," PATIENS=PATIENS_","
"RTN","RORUPD52",54,0)
 S:RORIENS'["," RORIENS=RORIENS_","
"RTN","RORUPD52",55,0)
 ;--- Load values of demographic fields from the PATIENT file
"RTN","RORUPD52",56,0)
 D GETS^DIQ(2,PATIENS,$$PATFLDS(),"IN","RORBUF","RORMSG")
"RTN","RORUPD52",57,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"PATDATA^RORUPD52",+PATIENS,2)
"RTN","RORUPD52",58,0)
 S RC=$$LOAD(PATIENS,.RORBUF)  Q:RC<0 RC
"RTN","RORUPD52",59,0)
 S DOD=$P($G(RORBUF(2,PATIENS,.351,"I")),".")
"RTN","RORUPD52",60,0)
 ;--- Load values of demographic fields from the ROR PATIENT file
"RTN","RORUPD52",61,0)
 I RORIENS?1.N.1","  S RC=0  D  Q:RC<0 RC
"RTN","RORUPD52",62,0)
 . D GETS^DIQ(798.4,RORIENS,FLDLST,"IN","RORPAT","RORMSG")
"RTN","RORUPD52",63,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD52",64,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"PATDATA^RORUPD52",,798.4,RORIENS)
"RTN","RORUPD52",65,0)
 ;--- Check if something has been changed
"RTN","RORUPD52",66,0)
 S COUNT=0
"RTN","RORUPD52",67,0)
 F I=1:1  S FIELD=$P(FLDLST,";",I)  Q:'FIELD  D
"RTN","RORUPD52",68,0)
 . S OLDVAL=$G(RORPAT(798.4,RORIENS,FIELD,"I"))
"RTN","RORUPD52",69,0)
 . K RORPAT(798.4,RORIENS,FIELD)
"RTN","RORUPD52",70,0)
 . Q:$G(RORBUF(2,PATIENS,FIELD,"I"))=OLDVAL
"RTN","RORUPD52",71,0)
 . ;--- Store the new value
"RTN","RORUPD52",72,0)
 . S RORPAT(798.4,RORIENS,FIELD)=$G(RORBUF(2,PATIENS,FIELD,"I"))
"RTN","RORUPD52",73,0)
 . S COUNT=COUNT+1
"RTN","RORUPD52",74,0)
 . ;--- Save previous values of the special fields
"RTN","RORUPD52",75,0)
 . I FIELD=.09  D  Q
"RTN","RORUPD52",76,0)
 . . S RORPAT(798.4,RORIENS,10.1)=OLDVAL         ; Old SSN
"RTN","RORUPD52",77,0)
 . I FIELD=991.01  D  Q
"RTN","RORUPD52",78,0)
 . . S RORPAT(798.4,RORIENS,10.2)=OLDVAL         ; Old ICN
"RTN","RORUPD52",79,0)
 Q COUNT
"RTN","RORUPD52",80,0)
 ;
"RTN","RORUPD52",81,0)
 ;***** RETURNS A LIST OF DEMOGRAPHIC FIELDS
"RTN","RORUPD52",82,0)
PATFLDS(MODE) ;
"RTN","RORUPD52",83,0)
 Q ".02;.03;.06;.09;.351"_$S($G(MODE):";.1112;.301;.302;.323;991.01",1:"")
"RTN","RORUPDPP")
1^62
"RTN","RORUPDUT")
0^63^B47472833
"RTN","RORUPDUT",1,0)
RORUPDUT ;HCIOFO/SG - REGISTRY UPDATE UTILITIES  ; 4/19/02 8:58am
"RTN","RORUPDUT",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPDUT",3,0)
 ;
"RTN","RORUPDUT",4,0)
 ; RORVALS ------------- CALCULATED VALUES
"RTN","RORUPDUT",5,0)
 ;
"RTN","RORUPDUT",6,0)
 ; RORVALS("DV",         VALUES OF THE DATA ELEMENTS
"RTN","RORUPDUT",7,0)
 ;   File#,DataCode,"E") External value
"RTN","RORUPDUT",8,0)
 ;   File#,DataCode,"I") Internal value
"RTN","RORUPDUT",9,0)
 ;
"RTN","RORUPDUT",10,0)
 ; RORVALS("LS",         LIST OF TRIGGERED LAB SEARCHES
"RTN","RORUPDUT",11,0)
 ;   LabSearch#)         Date/time of the observation
"RTN","RORUPDUT",12,0)
 ;
"RTN","RORUPDUT",13,0)
 ; RORVALS("SV",         VALUES OF THE SELECTION RULES
"RTN","RORUPDUT",14,0)
 ;   Rule Name,          Current value
"RTN","RORUPDUT",15,0)
 ;     "AVG")            Average value
"RTN","RORUPDUT",16,0)
 ;     "CNT")            Counter
"RTN","RORUPDUT",17,0)
 ;     "DTF")            Used by the {SDF} and {SDL} macros to store
"RTN","RORUPDUT",18,0)
 ;     "DTL")            the earliest and the latest trigger dates
"RTN","RORUPDUT",19,0)
 ;     "MAX")            Maximum value
"RTN","RORUPDUT",20,0)
 ;     "MIN")            Minimum value
"RTN","RORUPDUT",21,0)
 ;     "SUM")            Total value
"RTN","RORUPDUT",22,0)
 ;
"RTN","RORUPDUT",23,0)
 ; PREPDEFINED NAME ---- VALUE AND DESCRIPTION
"RTN","RORUPDUT",24,0)
 ;
"RTN","RORUPDUT",25,0)
 ; "ROR DFN"             IEN of the patient being processed
"RTN","RORUPDUT",26,0)
 ; "ROR SRDT"            Date when the current selection rule was
"RTN","RORUPDUT",27,0)
 ;                       triggered (it is set by APLRULES^RORUPDUT
"RTN","RORUPDUT",28,0)
 ;                       but could be changed by selection rules).
"RTN","RORUPDUT",29,0)
 ;                       The {GDF} and {GDL} macros modify this
"RTN","RORUPDUT",30,0)
 ;                       value as well.
"RTN","RORUPDUT",31,0)
 ;
"RTN","RORUPDUT",32,0)
 Q
"RTN","RORUPDUT",33,0)
 ;
"RTN","RORUPDUT",34,0)
 ;***** APPLIES SELECTION RULES TO THE RECORD
"RTN","RORUPDUT",35,0)
 ;
"RTN","RORUPDUT",36,0)
 ; FILE          File/Subfile number
"RTN","RORUPDUT",37,0)
 ; IENS          IENS of the current record
"RTN","RORUPDUT",38,0)
 ; MODE          "B" (process before subfiles) or
"RTN","RORUPDUT",39,0)
 ;               "A" (process after subfiles)
"RTN","RORUPDUT",40,0)
 ; [DATE]        Trigger date (TODAY by default)
"RTN","RORUPDUT",41,0)
 ;
"RTN","RORUPDUT",42,0)
 ; Return values:
"RTN","RORUPDUT",43,0)
 ;       <0  Error code
"RTN","RORUPDUT",44,0)
 ;        0  Continue processing of the current patient
"RTN","RORUPDUT",45,0)
 ;        1  Stop looping
"RTN","RORUPDUT",46,0)
 ;
"RTN","RORUPDUT",47,0)
APLRULES(FILE,IENS,MODE,DATE) ;
"RTN","RORUPDUT",48,0)
 N EXPR,HDR,LM,PATIEN,RC,REGIEN,RI,RULENAME,RULENODE
"RTN","RORUPDUT",49,0)
 S:'$G(DATE) DATE=$$DT^XLFDT
"RTN","RORUPDUT",50,0)
 ;--- Loop through the selection rules
"RTN","RORUPDUT",51,0)
 S RI="",RC=0
"RTN","RORUPDUT",52,0)
 F  S RI=$O(RORUPD("SR",FILE,MODE,RI))  Q:RI=""  D  Q:RC<0
"RTN","RORUPDUT",53,0)
 . S RULENODE=$NA(RORUPD("SR",FILE,MODE,RI))
"RTN","RORUPDUT",54,0)
 . S RORVALS("SV","ROR SRDT")=$P(DATE,".")
"RTN","RORUPDUT",55,0)
 . S HDR=$G(@RULENODE),RULENAME=$P(HDR,U)
"RTN","RORUPDUT",56,0)
 . ;--- If a top level rule does not exist in the control list, this
"RTN","RORUPDUT",57,0)
 . ;    rule has been already triggered for the patient. So, there is
"RTN","RORUPDUT",58,0)
 . ;    no need to check it again.
"RTN","RORUPDUT",59,0)
 . I $P(HDR,U,3)  Q:'$D(RORUPD("LM",1,RULENAME))
"RTN","RORUPDUT",60,0)
 . ;--- Compute the expression of the selection rule
"RTN","RORUPDUT",61,0)
 . X "S RC="_@RULENODE@(1)
"RTN","RORUPDUT",62,0)
 . I $P(HDR,U,3)  Q:'RC  D               ; TOP LEVEL RULE
"RTN","RORUPDUT",63,0)
 . . S PATIEN=$$GETVAL("ROR DFN"),REGIEN=""
"RTN","RORUPDUT",64,0)
 . . F  S REGIEN=$O(@RULENODE@(2,REGIEN))  Q:REGIEN=""  D
"RTN","RORUPDUT",65,0)
 . . . ;--- Check if the patient is already in the registry
"RTN","RORUPDUT",66,0)
 . . . Q:'$G(RORUPD("LM2",REGIEN))
"RTN","RORUPDUT",67,0)
 . . . ;--- Save rule name and date for the registry and new patient
"RTN","RORUPDUT",68,0)
 . . . S @RORUPDPI@("U",PATIEN,2,REGIEN,+$P(HDR,U,2))=RORVALS("SV","ROR SRDT")
"RTN","RORUPDUT",69,0)
 . . . ;--- Remove the registry from the control list
"RTN","RORUPDUT",70,0)
 . . . K RORUPD("LM",2,REGIEN)
"RTN","RORUPDUT",71,0)
 . . ;--- Remove the rule from the control list
"RTN","RORUPDUT",72,0)
 . . K RORUPD("LM",1,RULENAME)
"RTN","RORUPDUT",73,0)
 . E  D SETVAL(RULENAME,RC)              ; LOWER LEVEL RULE
"RTN","RORUPDUT",74,0)
 . S RC=0
"RTN","RORUPDUT",75,0)
 S LM=+$G(RORUPD("LM")) ; Loop mode
"RTN","RORUPDUT",76,0)
 ;--- If the loop mode equals 0, continue processing of the patient
"RTN","RORUPDUT",77,0)
 ;    in any case. Otherwise, stop processing if the corresponding
"RTN","RORUPDUT",78,0)
 ;    control list is empty.
"RTN","RORUPDUT",79,0)
 Q $S(RC<0:RC,LM:$D(RORUPD("LM",LM))<10,1:0)
"RTN","RORUPDUT",80,0)
 ;
"RTN","RORUPDUT",81,0)
 ;***** CLEARS DATA ELEMENT VALUES
"RTN","RORUPDUT",82,0)
 ;
"RTN","RORUPDUT",83,0)
 ; FILE          File/Subfile number
"RTN","RORUPDUT",84,0)
 ;
"RTN","RORUPDUT",85,0)
CLRDES(FILE) ;
"RTN","RORUPDUT",86,0)
 K RORVALS("DV",FILE)
"RTN","RORUPDUT",87,0)
 Q
"RTN","RORUPDUT",88,0)
 ;
"RTN","RORUPDUT",89,0)
 ;***** CLEARS VALUE OF THE ERROR COUNTER
"RTN","RORUPDUT",90,0)
CLREC ;
"RTN","RORUPDUT",91,0)
 K RORUPD("ERRCNT")
"RTN","RORUPDUT",92,0)
 Q
"RTN","RORUPDUT",93,0)
 ;
"RTN","RORUPDUT",94,0)
 ;***** CLEARS VALUES OF THE SELECTION RULES ASSOCIATED WITH THE FILE
"RTN","RORUPDUT",95,0)
 ;
"RTN","RORUPDUT",96,0)
 ; FILE          File/Subfile number
"RTN","RORUPDUT",97,0)
 ;
"RTN","RORUPDUT",98,0)
CLRVALS(FILE) ;
"RTN","RORUPDUT",99,0)
 N MODE,RI,RULENAME
"RTN","RORUPDUT",100,0)
 F MODE="B","A"  D
"RTN","RORUPDUT",101,0)
 . S RI=""
"RTN","RORUPDUT",102,0)
 . F  S RI=$O(RORUPD("SR",FILE,MODE,RI))  Q:RI=""  D
"RTN","RORUPDUT",103,0)
 . . S RULENAME=$P($G(RORUPD("SR",FILE,MODE,RI)),U)
"RTN","RORUPDUT",104,0)
 . . K:RULENAME'="" RORVALS("SV",RULENAME)
"RTN","RORUPDUT",105,0)
 Q
"RTN","RORUPDUT",106,0)
 ;
"RTN","RORUPDUT",107,0)
 ;***** RETURNS A CODE OF THE DATA ELEMENT
"RTN","RORUPDUT",108,0)
 ;
"RTN","RORUPDUT",109,0)
 ; FILE          File number
"RTN","RORUPDUT",110,0)
 ; NAME          Name of the data element
"RTN","RORUPDUT",111,0)
 ;
"RTN","RORUPDUT",112,0)
 ; Return values:
"RTN","RORUPDUT",113,0)
 ;       <0  Error code
"RTN","RORUPDUT",114,0)
 ;       >0  Code of the data element
"RTN","RORUPDUT",115,0)
 ;
"RTN","RORUPDUT",116,0)
DATACODE(FILE,NAME) ;
"RTN","RORUPDUT",117,0)
 N IENS,RC,RORBUF,RORMSG
"RTN","RORUPDUT",118,0)
 S IENS=","_FILE_","
"RTN","RORUPDUT",119,0)
 D FIND^DIC(799.22,IENS,"@;.02I","X",NAME,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPDUT",120,0)
 I $G(DIERR)  D  Q RC
"RTN","RORUPDUT",121,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"DATACODE^RORUPDUT",,799.22,IENS)
"RTN","RORUPDUT",122,0)
 S RC=+$G(RORBUF("DILIST",0))
"RTN","RORUPDUT",123,0)
 Q:RC<1 $$ERROR^RORERR(-69,"DATACODE^RORUPDUT",NAME)
"RTN","RORUPDUT",124,0)
 Q:RC>1 $$ERROR^RORERR(-70,"DATACODE^RORUPDUT",NAME)
"RTN","RORUPDUT",125,0)
 Q +$G(RORBUF("DILIST","ID",1,.02))
"RTN","RORUPDUT",126,0)
 ;
"RTN","RORUPDUT",127,0)
 ;***** PRINTS SOME DEBUG INFORMATION
"RTN","RORUPDUT",128,0)
DEBUG ;
"RTN","RORUPDUT",129,0)
 N I
"RTN","RORUPDUT",130,0)
 D ZW^RORUTL01($NA(RORUPD("FLAGS")),"Control Flags")
"RTN","RORUPDUT",131,0)
 D ZW^RORUTL01($NA(RORUPD("SR")),"Selection Rules")
"RTN","RORUPDUT",132,0)
 D ZW^RORUTL01($NA(RORUPD("UPD")),"Call-back Entry Points")
"RTN","RORUPDUT",133,0)
 W !,"Control Lists",!!
"RTN","RORUPDUT",134,0)
 F I="LM1","LM2"  D ZW^RORUTL01($NA(RORUPD(I)))
"RTN","RORUPDUT",135,0)
 D ZW^RORUTL01("RORLRC","Lab Results to check")
"RTN","RORUPDUT",136,0)
 W !,"Job number: ",$J,!
"RTN","RORUPDUT",137,0)
 Q
"RTN","RORUPDUT",138,0)
 ;
"RTN","RORUPDUT",139,0)
 ;***** GETS A VALUE OF THE DATA ELEMENT
"RTN","RORUPDUT",140,0)
 ;
"RTN","RORUPDUT",141,0)
 ; FILE          File number
"RTN","RORUPDUT",142,0)
 ; DATELMT       Code of the data element
"RTN","RORUPDUT",143,0)
 ; [TYPE]        Type of the value
"RTN","RORUPDUT",144,0)
 ;                 "E"  External
"RTN","RORUPDUT",145,0)
 ;                 "I"  Internal (default)
"RTN","RORUPDUT",146,0)
 ;
"RTN","RORUPDUT",147,0)
GETDE(FILE,DATELMT,TYPE) ;
"RTN","RORUPDUT",148,0)
 Q $G(RORVALS("DV",FILE,DATELMT,$G(TYPE,"I")))
"RTN","RORUPDUT",149,0)
 ;
"RTN","RORUPDUT",150,0)
 ;***** RETURNS VALUE OF THE ERROR COUNTER
"RTN","RORUPDUT",151,0)
GETEC() ;
"RTN","RORUPDUT",152,0)
 Q +$G(RORUPD("ERRCNT"))
"RTN","RORUPDUT",153,0)
 ;
"RTN","RORUPDUT",154,0)
 ;***** GETS VALUE OF THE SELECTION RULE
"RTN","RORUPDUT",155,0)
 ;
"RTN","RORUPDUT",156,0)
 ; RULENAME      Name of the rule
"RTN","RORUPDUT",157,0)
 ; [PFX]         Prefix of the value
"RTN","RORUPDUT",158,0)
 ;                 ""     Value itself (default)
"RTN","RORUPDUT",159,0)
 ;                 "AVG"  Average value
"RTN","RORUPDUT",160,0)
 ;                 "CNT"  Counter
"RTN","RORUPDUT",161,0)
 ;                 "MAX"  Maximum value
"RTN","RORUPDUT",162,0)
 ;                 "MIN"  Minimum value
"RTN","RORUPDUT",163,0)
 ;                 "SUM"  Total sum
"RTN","RORUPDUT",164,0)
 ;
"RTN","RORUPDUT",165,0)
GETVAL(RULENAME,PFX) ;
"RTN","RORUPDUT",166,0)
 Q $S($G(PFX)="":$G(RORVALS("SV",RULENAME)),1:$G(RORVALS("SV",RULENAME,PFX)))
"RTN","RORUPDUT",167,0)
 ;
"RTN","RORUPDUT",168,0)
 ;***** RETURNS INACTIVATION DATE FOR A DECEASED PATIENT
"RTN","RORUPDUT",169,0)
 ;
"RTN","RORUPDUT",170,0)
 ; DOD           Date of death
"RTN","RORUPDUT",171,0)
 ;
"RTN","RORUPDUT",172,0)
INACTDOD(DOD) ;
"RTN","RORUPDUT",173,0)
 Q $S(DOD:$$FMADD^XLFDT(DOD,31),1:"")
"RTN","RORUPDUT",174,0)
 ;
"RTN","RORUPDUT",175,0)
 ;***** INCREMENTS VALUE OF THE ERROR COUNTER
"RTN","RORUPDUT",176,0)
 ;
"RTN","RORUPDUT",177,0)
 ; [RC]          Reference to a variable containing the error code
"RTN","RORUPDUT",178,0)
 ;
"RTN","RORUPDUT",179,0)
INCEC(RC) ;
"RTN","RORUPDUT",180,0)
 S:$G(RC,-1)<0 RORUPD("ERRCNT")=$G(RORUPD("ERRCNT"))+1,RC=0
"RTN","RORUPDUT",181,0)
 Q
"RTN","RORUPDUT",182,0)
 ;
"RTN","RORUPDUT",183,0)
 ;***** LOADS DATA ELEMENT VALUES FROM CORRESPONDING FIELDS
"RTN","RORUPDUT",184,0)
 ;
"RTN","RORUPDUT",185,0)
 ; FILE          File/Subfile number
"RTN","RORUPDUT",186,0)
 ; IENS          IENS of the current record
"RTN","RORUPDUT",187,0)
 ;
"RTN","RORUPDUT",188,0)
 ; Return values:
"RTN","RORUPDUT",189,0)
 ;       <0  Error code
"RTN","RORUPDUT",190,0)
 ;        0  Ok
"RTN","RORUPDUT",191,0)
 ;
"RTN","RORUPDUT",192,0)
LOADFLDS(FILE,IENS) ;
"RTN","RORUPDUT",193,0)
 N DE,FLD,RC,RORFDA,RORMSG,VT  K RORVALS("DV",FILE)
"RTN","RORUPDUT",194,0)
 S FLD=$G(RORUPD("SR",FILE,"F",1))  Q:FLD="" 0
"RTN","RORUPDUT",195,0)
 ;--- Load the field values
"RTN","RORUPDUT",196,0)
 D GETS^DIQ(FILE,IENS,FLD,"EIN","RORFDA","RORMSG")
"RTN","RORUPDUT",197,0)
 I $G(DIERR)  D  Q RC
"RTN","RORUPDUT",198,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"LOADFLDS^RORUPDUT",,FILE,IENS)
"RTN","RORUPDUT",199,0)
 ;--- Copy the field values from the FDA
"RTN","RORUPDUT",200,0)
 S DE=""
"RTN","RORUPDUT",201,0)
 F  S DE=$O(RORUPD("SR",FILE,"F",1,DE))  Q:DE=""  D
"RTN","RORUPDUT",202,0)
 . S FLD=+$G(RORUPD("SR",FILE,"F",1,DE))  Q:'FLD
"RTN","RORUPDUT",203,0)
 . S VT=""
"RTN","RORUPDUT",204,0)
 . F  S VT=$O(RORUPD("SR",FILE,"F",1,DE,VT))  Q:VT=""  D
"RTN","RORUPDUT",205,0)
 . . S RORVALS("DV",FILE,DE,VT)=$G(RORFDA(FILE,IENS,FLD,VT))
"RTN","RORUPDUT",206,0)
 Q 0
"RTN","RORUPDUT",207,0)
 ;
"RTN","RORUPDUT",208,0)
 ;***** SETS THE EARLIEST DATE FOR THE RULE
"RTN","RORUPDUT",209,0)
 ;
"RTN","RORUPDUT",210,0)
 ; NAME          Name of the selection rule
"RTN","RORUPDUT",211,0)
 ; COND          Result value of the logical condition
"RTN","RORUPDUT",212,0)
 ;
"RTN","RORUPDUT",213,0)
 ; Return values:
"RTN","RORUPDUT",214,0)
 ;        0  COND equals to zero
"RTN","RORUPDUT",215,0)
 ;        1  COND is not zero
"RTN","RORUPDUT",216,0)
 ;
"RTN","RORUPDUT",217,0)
SDF(NAME,COND) ;
"RTN","RORUPDUT",218,0)
 Q:'$G(COND) 0
"RTN","RORUPDUT",219,0)
 N DATE
"RTN","RORUPDUT",220,0)
 S DATE=$G(RORVALS("SV","ROR SRDT"))
"RTN","RORUPDUT",221,0)
 D:DATE>0
"RTN","RORUPDUT",222,0)
 . I $G(RORVALS("SV",NAME,"DTF"))'>0  D  Q
"RTN","RORUPDUT",223,0)
 . . S RORVALS("SV",NAME,"DTF")=DATE
"RTN","RORUPDUT",224,0)
 . S:DATE<RORVALS("SV",NAME,"DTF") RORVALS("SV",NAME,"DTF")=DATE
"RTN","RORUPDUT",225,0)
 Q 1
"RTN","RORUPDUT",226,0)
 ;
"RTN","RORUPDUT",227,0)
 ;***** SETS THE LATEST DATE FOR THE RULE
"RTN","RORUPDUT",228,0)
 ;
"RTN","RORUPDUT",229,0)
 ; NAME          Name of the selection rule
"RTN","RORUPDUT",230,0)
 ; COND          Result value of the logical condition
"RTN","RORUPDUT",231,0)
 ;
"RTN","RORUPDUT",232,0)
 ; Return values:
"RTN","RORUPDUT",233,0)
 ;        0  COND equals to zero
"RTN","RORUPDUT",234,0)
 ;        1  COND is not zero
"RTN","RORUPDUT",235,0)
 ;
"RTN","RORUPDUT",236,0)
SDL(NAME,COND) ;
"RTN","RORUPDUT",237,0)
 Q:'$G(COND) 0
"RTN","RORUPDUT",238,0)
 N DATE
"RTN","RORUPDUT",239,0)
 S DATE=$G(RORVALS("SV","ROR SRDT"))
"RTN","RORUPDUT",240,0)
 D:DATE>0
"RTN","RORUPDUT",241,0)
 . S:DATE>$G(RORVALS("SV",NAME,"DTL")) RORVALS("SV",NAME,"DTL")=DATE
"RTN","RORUPDUT",242,0)
 Q 1
"RTN","RORUPDUT",243,0)
 ;
"RTN","RORUPDUT",244,0)
 ;***** SETS VALUE OF THE SELECTION RULE
"RTN","RORUPDUT",245,0)
 ;
"RTN","RORUPDUT",246,0)
 ; RULENAME      Name of the rule
"RTN","RORUPDUT",247,0)
 ; VALUE         New value
"RTN","RORUPDUT",248,0)
 ;
"RTN","RORUPDUT",249,0)
SETVAL(RULENAME,VALUE) ;
"RTN","RORUPDUT",250,0)
 S RORVALS("SV",RULENAME)=VALUE
"RTN","RORUPDUT",251,0)
 S RORVALS("SV",RULENAME,"CNT")=$G(RORVALS("SV",RULENAME,"CNT"))+1
"RTN","RORUPDUT",252,0)
 S RORVALS("SV",RULENAME,"SUM")=$G(RORVALS("SV",RULENAME,"SUM"))+VALUE
"RTN","RORUPDUT",253,0)
 S RORVALS("SV",RULENAME,"AVG")=RORVALS("SV",RULENAME,"SUM")/RORVALS("SV",RULENAME,"CNT")
"RTN","RORUPDUT",254,0)
 ;
"RTN","RORUPDUT",255,0)
 I $G(RORVALS("SV",RULENAME,"MIN"))=""  S RORVALS("SV",RULENAME,"MIN")=VALUE
"RTN","RORUPDUT",256,0)
 E   S:VALUE<RORVALS("SV",RULENAME,"MIN") RORVALS("SV",RULENAME,"MIN")=VALUE
"RTN","RORUPDUT",257,0)
 ;
"RTN","RORUPDUT",258,0)
 I $G(RORVALS("SV",RULENAME,"MAX"))=""  S RORVALS("SV",RULENAME,"MAX")=VALUE
"RTN","RORUPDUT",259,0)
 E   S:VALUE>RORVALS("SV",RULENAME,"MAX") RORVALS("SV",RULENAME,"MAX")=VALUE
"RTN","RORUPDUT",260,0)
 Q
"RTN","RORUPDUT",261,0)
 ;
"RTN","RORUPDUT",262,0)
 ;***** GETS THE TRIGGER DATE OF THE RULE
"RTN","RORUPDUT",263,0)
 ;
"RTN","RORUPDUT",264,0)
 ; NAME          Name of the selection rule
"RTN","RORUPDUT",265,0)
 ; PFX           Prefix of the value ("GDF" or "GDL")
"RTN","RORUPDUT",266,0)
 ; COND          Result value of the logical condition
"RTN","RORUPDUT",267,0)
 ;
"RTN","RORUPDUT",268,0)
 ; Return values:
"RTN","RORUPDUT",269,0)
 ;        0  COND equals to zero
"RTN","RORUPDUT",270,0)
 ;        1  COND is not zero
"RTN","RORUPDUT",271,0)
 ;
"RTN","RORUPDUT",272,0)
SRDT(NAME,PFX,COND) ;
"RTN","RORUPDUT",273,0)
 Q:'$G(COND) 0
"RTN","RORUPDUT",274,0)
 N DATE
"RTN","RORUPDUT",275,0)
 S DATE=$G(RORVALS("SV",NAME,$S(PFX="GDL":"DTL",1:"DTF")))
"RTN","RORUPDUT",276,0)
 I DATE  S:DATE<$G(RORVALS("SV","ROR SRDT")) RORVALS("SV","ROR SRDT")=DATE
"RTN","RORUPDUT",277,0)
 Q 1
"RTN","RORUPEX")
0^64^B14495956
"RTN","RORUPEX",1,0)
RORUPEX ;HCIOFO/SG - SELECTION RULE EXPRESSION PARSER  ; 3/28/02 1:04pm
"RTN","RORUPEX",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPEX",3,0)
 ;
"RTN","RORUPEX",4,0)
 Q
"RTN","RORUPEX",5,0)
 ;
"RTN","RORUPEX",6,0)
 ;***** GETS THE NEXT CHARACTER FROM THE EXPRESSION
"RTN","RORUPEX",7,0)
GETCHAR ;
"RTN","RORUPEX",8,0)
 S LOOK=$E(EXPR,EPTR),EPTR=EPTR+1
"RTN","RORUPEX",9,0)
 Q
"RTN","RORUPEX",10,0)
 ;
"RTN","RORUPEX",11,0)
 ;***** TRANSLATES FIELD OR RULE MACRO TO MUMPS CODE
"RTN","RORUPEX",12,0)
 ;
"RTN","RORUPEX",13,0)
 ; The function returns a string containing MUMPS expression
"RTN","RORUPEX",14,0)
 ; that implements the selection rule macro.
"RTN","RORUPEX",15,0)
 ;
"RTN","RORUPEX",16,0)
GETMACRO() ;
"RTN","RORUPEX",17,0)
 ;;AVG,CNT,E,GDF,GDL,I,LS,MAX,MIN,SDF,SDL,SUM
"RTN","RORUPEX",18,0)
 ;
"RTN","RORUPEX",19,0)
 Q:'$$MATCH("{") ""
"RTN","RORUPEX",20,0)
 N BI,BUF,DATELMT,NAME,PFX,PFXLST,RC,RORMSG,SFX,TMP,XCODE
"RTN","RORUPEX",21,0)
 S PFXLST=","_$P($T(GETMACRO+1),";;",2)_","
"RTN","RORUPEX",22,0)
 S BI=1,RC=0
"RTN","RORUPEX",23,0)
 F  D  Q:RC
"RTN","RORUPEX",24,0)
 . I LOOK="}"  D GETCHAR  S RC=1  Q
"RTN","RORUPEX",25,0)
 . I LOOK=":"  D GETCHAR  S BI=BI+1  Q
"RTN","RORUPEX",26,0)
 . I LOOK="{"  D  Q
"RTN","RORUPEX",27,0)
 . . I BI<3  D SNTXERR("GETMACRO^RORUPEX")  S RC=1  Q
"RTN","RORUPEX",28,0)
 . . S BUF(BI)=$G(BUF(BI))_$$GETMACRO()
"RTN","RORUPEX",29,0)
 . S BUF(BI)=$G(BUF(BI))_LOOK
"RTN","RORUPEX",30,0)
 . D GETCHAR
"RTN","RORUPEX",31,0)
 Q:ERRCODE<0 ""
"RTN","RORUPEX",32,0)
 ;--- Get the parts of the macro
"RTN","RORUPEX",33,0)
 S BI=1,(NAME,PFX,SFX)=""
"RTN","RORUPEX",34,0)
 S TMP=$$UP^XLFSTR($$TRIM^XLFSTR($G(BUF(BI))))
"RTN","RORUPEX",35,0)
 S:PFXLST[(","_TMP_",") PFX=TMP,BI=BI+1
"RTN","RORUPEX",36,0)
 S NAME=$$TRIM^XLFSTR($G(BUF(BI))),BI=BI+1
"RTN","RORUPEX",37,0)
 S SFX=$$TRIM^XLFSTR($G(BUF(BI))),BI=BI+1
"RTN","RORUPEX",38,0)
 ;--- Data element value
"RTN","RORUPEX",39,0)
 I (PFX="E")!(PFX="I")  S XCODE=""  D  Q XCODE
"RTN","RORUPEX",40,0)
 . S DATELMT=$S(+NAME=NAME:+NAME,1:$$DATACODE^RORUPDUT(FILE,NAME))
"RTN","RORUPEX",41,0)
 . I DATELMT<0  S ERRCODE=DATELMT  Q
"RTN","RORUPEX",42,0)
 . S XCODE="$G(RORVALS(""DV"","_FILE_","_DATELMT_","""_PFX_"""))"
"RTN","RORUPEX",43,0)
 . S RESULT("F",DATELMT,PFX)=""
"RTN","RORUPEX",44,0)
 ;--- Lab Search (replace a name of the Lab Search with the IEN)
"RTN","RORUPEX",45,0)
 I PFX="LS"  D  Q "$$RULE^RORUPD04("_TMP_")"
"RTN","RORUPEX",46,0)
 . I FILE'=63  D SNTXERR("GETMACRO^RORUPEX")  S TMP=""  Q
"RTN","RORUPEX",47,0)
 . S TMP="I '$P(^(0),U,2)" ; Only Active
"RTN","RORUPEX",48,0)
 . S TMP=+$$FIND1^DIC(798.9,"","X",NAME,"B",TMP,"RORMSG")
"RTN","RORUPEX",49,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"GETMACRO^RORUPEX",,798.9)
"RTN","RORUPEX",50,0)
 . S:RC<0 ERRCODE=RC,TMP=0
"RTN","RORUPEX",51,0)
 . S:TMP RESULT("L",TMP)=""
"RTN","RORUPEX",52,0)
 ;--- Trigger date macros (set)
"RTN","RORUPEX",53,0)
 I PFX="SDF"  Q "$$SDF^RORUPDUT("""_NAME_""","_SFX_")"
"RTN","RORUPEX",54,0)
 I PFX="SDL"  Q "$$SDL^RORUPDUT("""_NAME_""","_SFX_")"
"RTN","RORUPEX",55,0)
 ;--- Macros processed after this point cannot reference
"RTN","RORUPEX",56,0)
 ;    the rule that they are part of the expression of
"RTN","RORUPEX",57,0)
 S RESULT("R",NAME)=""
"RTN","RORUPEX",58,0)
 ;--- Trigger date macros (get)
"RTN","RORUPEX",59,0)
 I (PFX="GDF")!(PFX="GDL")  D  Q XCODE
"RTN","RORUPEX",60,0)
 . S XCODE="$$SRDT^RORUPDUT("""_NAME_""","""_PFX_""","_SFX_")"
"RTN","RORUPEX",61,0)
 ;--- Value of the selection rule
"RTN","RORUPEX",62,0)
 Q:PFX="" "$G(RORVALS(""SV"","""_NAME_"""))"
"RTN","RORUPEX",63,0)
 Q "$G(RORVALS(""SV"","""_NAME_""","""_PFX_"""))"
"RTN","RORUPEX",64,0)
 ;
"RTN","RORUPEX",65,0)
 ;***** GETS A STRING CONSTANT FROM THE EXPRESSION
"RTN","RORUPEX",66,0)
 ;
"RTN","RORUPEX",67,0)
 ; The function returns a string argument from the expression.
"RTN","RORUPEX",68,0)
 ;
"RTN","RORUPEX",69,0)
GETSTR() ;
"RTN","RORUPEX",70,0)
 Q:'$$MATCH("""") ""
"RTN","RORUPEX",71,0)
 N RC,STR
"RTN","RORUPEX",72,0)
 S STR="",RC=0
"RTN","RORUPEX",73,0)
 F  D  Q:RC
"RTN","RORUPEX",74,0)
 . I LOOK=""""  D  Q:RC
"RTN","RORUPEX",75,0)
 . . D GETCHAR
"RTN","RORUPEX",76,0)
 . . I LOOK'=""""  S RC=1  Q
"RTN","RORUPEX",77,0)
 . . S STR=STR_""""
"RTN","RORUPEX",78,0)
 . S STR=STR_LOOK
"RTN","RORUPEX",79,0)
 . D GETCHAR
"RTN","RORUPEX",80,0)
 Q STR
"RTN","RORUPEX",81,0)
 ;
"RTN","RORUPEX",82,0)
 ;***** INITIALIZES PARSING PROCESS
"RTN","RORUPEX",83,0)
INIT ;
"RTN","RORUPEX",84,0)
 S EPTR=1,ERRCODE=0,RESULT=""
"RTN","RORUPEX",85,0)
 D GETCHAR,SKIPWHT
"RTN","RORUPEX",86,0)
 Q
"RTN","RORUPEX",87,0)
 ;
"RTN","RORUPEX",88,0)
 ;***** COMPARES LOOK-AHEAD CHARACTER TO THE ARGUMENT
"RTN","RORUPEX",89,0)
MATCH(CH) ;
"RTN","RORUPEX",90,0)
 I LOOK=CH  D GETCHAR  Q 1
"RTN","RORUPEX",91,0)
 D SNTXERR("MATCH^RORUPEX")
"RTN","RORUPEX",92,0)
 Q 0
"RTN","RORUPEX",93,0)
 ;
"RTN","RORUPEX",94,0)
 ;***** PARSES THE EXPRESSION
"RTN","RORUPEX",95,0)
 ;
"RTN","RORUPEX",96,0)
 ; FILE          File number
"RTN","RORUPEX",97,0)
 ; EXPR          Source expression
"RTN","RORUPEX",98,0)
 ; .RESULT(      Resulting MUMPS code
"RTN","RORUPEX",99,0)
 ;   "F",        List of data elements to load
"RTN","RORUPEX",100,0)
 ;     DataCode)
"RTN","RORUPEX",101,0)
 ;   "L",LS#)    List of Lab Search IENs
"RTN","RORUPEX",102,0)
 ;   "R",Rule#)  List of rules that this expression depend on
"RTN","RORUPEX",103,0)
 ;
"RTN","RORUPEX",104,0)
 ; Return values:
"RTN","RORUPEX",105,0)
 ;       <0  Error code
"RTN","RORUPEX",106,0)
 ;        0  Ok
"RTN","RORUPEX",107,0)
 ;
"RTN","RORUPEX",108,0)
PARSER(FILE,EXPR,RESULT) ;
"RTN","RORUPEX",109,0)
 N EPTR          ; Current position in the expression
"RTN","RORUPEX",110,0)
 N ERRCODE       ; Error code
"RTN","RORUPEX",111,0)
 N LOOK          ; Look-ahead character
"RTN","RORUPEX",112,0)
 ;
"RTN","RORUPEX",113,0)
 ;--- Check if the file exists and supported
"RTN","RORUPEX",114,0)
 Q:'$$VFILE^DILFD(FILE) $$ERROR^RORERR(-58,"PARSER^RORUPEX",,,FILE)
"RTN","RORUPEX",115,0)
 Q:'$D(^ROR(799.2,FILE)) $$ERROR^RORERR(-63,"PARSER^RORUPEX",,,FILE)
"RTN","RORUPEX",116,0)
 ;--- Parse the expression
"RTN","RORUPEX",117,0)
 D INIT
"RTN","RORUPEX",118,0)
 F  Q:LOOK=""  D  Q:ERRCODE<0
"RTN","RORUPEX",119,0)
 . I LOOK=""""  D  Q
"RTN","RORUPEX",120,0)
 . . S RESULT=RESULT_""""_$$GETSTR()_""""
"RTN","RORUPEX",121,0)
 . I LOOK="{"  D  Q
"RTN","RORUPEX",122,0)
 . . S RESULT=RESULT_$$GETMACRO()
"RTN","RORUPEX",123,0)
 . S RESULT=RESULT_LOOK
"RTN","RORUPEX",124,0)
 . D GETCHAR
"RTN","RORUPEX",125,0)
 ;
"RTN","RORUPEX",126,0)
 Q $S(ERRCODE<0:ERRCODE,1:0)
"RTN","RORUPEX",127,0)
 ;
"RTN","RORUPEX",128,0)
 ;***** PROCESSES A SYNTAX ERROR
"RTN","RORUPEX",129,0)
SNTXERR(PLACE,MSG) ;
"RTN","RORUPEX",130,0)
 N I,INFO  S I=0
"RTN","RORUPEX",131,0)
 S:$G(MSG)'="" I=I+1,INFO(I)=MSG
"RTN","RORUPEX",132,0)
 S I=I+1,INFO(I)="Position: "_EPTR
"RTN","RORUPEX",133,0)
 S:LOOK'="" INFO(I)=INFO(I)_", Character: '"_LOOK_"'"
"RTN","RORUPEX",134,0)
 S ERRCODE=$$ERROR^RORERR(-21,$G(PLACE),.INFO)
"RTN","RORUPEX",135,0)
 Q
"RTN","RORUPEX",136,0)
 ;
"RTN","RORUPEX",137,0)
 ;***** SKIPS WHITE SPACES IN THE EXPRESSION
"RTN","RORUPEX",138,0)
SKIPWHT ;
"RTN","RORUPEX",139,0)
 F  Q:(" "'[LOOK)!(LOOK="")  D GETCHAR
"RTN","RORUPEX",140,0)
 Q
"RTN","RORUPP01")
0^75^B15079582
"RTN","RORUPP01",1,0)
RORUPP01 ;HCIOFO/SG - PENDING PATIENTS (ERRORS)  ; 4/15/02 3:29pm
"RTN","RORUPP01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPP01",3,0)
 ;
"RTN","RORUPP01",4,0)
 ; RORUPD("LM2",         Static list of registries must be defined
"RTN","RORUPP01",5,0)
 ;   Registry#)          if you are going to use these functions.
"RTN","RORUPP01",6,0)
 ;
"RTN","RORUPP01",7,0)
 ; RORUPD("MAXPPCNT")    This node should have a positive value if
"RTN","RORUPP01",8,0)
 ;                       you are going to use these functions.
"RTN","RORUPP01",9,0)
 ;                       Otherwise, 14 will be used by default.
"RTN","RORUPP01",10,0)
 ;
"RTN","RORUPP01",11,0)
 ; See source code of the ^RORUPD routine for detailed description
"RTN","RORUPP01",12,0)
 ; of these nodes.
"RTN","RORUPP01",13,0)
 ;
"RTN","RORUPP01",14,0)
 Q
"RTN","RORUPP01",15,0)
 ;
"RTN","RORUPP01",16,0)
 ;***** ADDS THE REFERENCES TO THE LIST
"RTN","RORUPP01",17,0)
 ;
"RTN","RORUPP01",18,0)
 ; PATIEN        Patient IEN
"RTN","RORUPP01",19,0)
 ; DATE          Date to start next registry update
"RTN","RORUPP01",20,0)
 ;
"RTN","RORUPP01",21,0)
 ; Return Values:
"RTN","RORUPP01",22,0)
 ;       <0  Error code
"RTN","RORUPP01",23,0)
 ;        0  Ok
"RTN","RORUPP01",24,0)
 ;
"RTN","RORUPP01",25,0)
ADD(PATIEN,DATE) ;
"RTN","RORUPP01",26,0)
 N I,IENS,MAXCNT,RC,REGIEN,RORBUF,RORFDA,RORIEN,RORMSG,TMP,URLST
"RTN","RORUPP01",27,0)
 S MAXCNT=$$MAXCNT()
"RTN","RORUPP01",28,0)
 I $D(^RORDATA(798.3,PATIEN,1,"B"))>1  S RC=0  D  Q:RC<0 RC
"RTN","RORUPP01",29,0)
 . ;--- Get a list of existing patient error records
"RTN","RORUPP01",30,0)
 . S IENS=","_PATIEN_",",I="I $D(RORUPD(""LM2"",+$P(^(0),U)))"
"RTN","RORUPP01",31,0)
 . D LIST^DIC(798.31,IENS,"@;.01I;1I;2",,,,,"B",I,,"RORBUF","RORMSG")
"RTN","RORUPP01",32,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPP01",33,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"ADD^RORUPP01",,798.31,IENS)
"RTN","RORUPP01",34,0)
 . Q:'$G(RORBUF("DILIST",0))
"RTN","RORUPP01",35,0)
 . ;--- Prepare FDA for records to update
"RTN","RORUPP01",36,0)
 . S I=""
"RTN","RORUPP01",37,0)
 . F  S I=$O(RORBUF("DILIST",2,I))  Q:I=""  D
"RTN","RORUPP01",38,0)
 . . S REGIEN=+$G(RORBUF("DILIST","ID",I,.01))
"RTN","RORUPP01",39,0)
 . . S URLST(REGIEN)=""
"RTN","RORUPP01",40,0)
 . . Q:$G(RORBUF("DILIST","ID",I,2))'<MAXCNT
"RTN","RORUPP01",41,0)
 . . S IENS=RORBUF("DILIST",2,I)_","_PATIEN_","
"RTN","RORUPP01",42,0)
 . . S TMP=$G(RORBUF("DILIST","ID",I,1))
"RTN","RORUPP01",43,0)
 . . S RORFDA(798.31,IENS,1)=$S(TMP&(TMP<DATE):TMP,1:DATE)
"RTN","RORUPP01",44,0)
 . . S RORFDA(798.31,IENS,2)=$G(RORBUF("DILIST","ID",I,2))+1
"RTN","RORUPP01",45,0)
 . Q:$D(RORFDA)<10
"RTN","RORUPP01",46,0)
 . ;--- Update the records
"RTN","RORUPP01",47,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUPP01",48,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,"ADD^RORUPP01",,798.31)
"RTN","RORUPP01",49,0)
 ;--- Prepare FDA for records to create
"RTN","RORUPP01",50,0)
 S REGIEN="",I=1
"RTN","RORUPP01",51,0)
 F  S REGIEN=$O(RORUPD("LM2",REGIEN))  Q:REGIEN=""  D
"RTN","RORUPP01",52,0)
 . Q:$D(URLST(REGIEN))
"RTN","RORUPP01",53,0)
 . S I=I+1,IENS="+"_I_",?+1,"
"RTN","RORUPP01",54,0)
 . S RORFDA(798.31,IENS,.01)=REGIEN
"RTN","RORUPP01",55,0)
 . S RORFDA(798.31,IENS,1)=DATE
"RTN","RORUPP01",56,0)
 . S RORFDA(798.31,IENS,2)=1
"RTN","RORUPP01",57,0)
 ;--- Create the records
"RTN","RORUPP01",58,0)
 I $D(RORFDA)>1  S RC=0  D  Q:RC<0 RC
"RTN","RORUPP01",59,0)
 . S (RORFDA(798.3,"?+1,",.01),RORIEN(1))=PATIEN
"RTN","RORUPP01",60,0)
 . D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORUPP01",61,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,"ADD^RORUPP01",,798.31)
"RTN","RORUPP01",62,0)
 Q 0
"RTN","RORUPP01",63,0)
 ;
"RTN","RORUPP01",64,0)
 ;***** RETURNS THE THRESHOLD VALUE OF THE ERROR COUNTER
"RTN","RORUPP01",65,0)
MAXCNT() ;
"RTN","RORUPP01",66,0)
 Q $S($G(RORUPD("MAXPPCNT"))>0:+RORUPD("MAXPPCNT"),1:14)
"RTN","RORUPP01",67,0)
 ;
"RTN","RORUPP01",68,0)
 ;***** REMOVES THE REFERNCES FROM THE LIST
"RTN","RORUPP01",69,0)
 ;
"RTN","RORUPP01",70,0)
 ; PATIEN        Patient IEN
"RTN","RORUPP01",71,0)
 ; [ROR8LST]     Closed root of an array containg list of registry
"RTN","RORUPP01",72,0)
 ;               IENs as subscripts. $NA(RORUPD("LM2")) is used
"RTN","RORUPP01",73,0)
 ;               by default. Only records associated with these
"RTN","RORUPP01",74,0)
 ;               registries will be removed.
"RTN","RORUPP01",75,0)
 ;
"RTN","RORUPP01",76,0)
 ; Return Values:
"RTN","RORUPP01",77,0)
 ;       <0  Error code
"RTN","RORUPP01",78,0)
 ;        0  Ok
"RTN","RORUPP01",79,0)
 ;
"RTN","RORUPP01",80,0)
REMOVE(PATIEN,ROR8LST) ;
"RTN","RORUPP01",81,0)
 Q:$D(^RORDATA(798.3,PATIEN,1,"B"))<10 0
"RTN","RORUPP01",82,0)
 N I,IENS,RC,RORBUF,RORFDA,RORMSG
"RTN","RORUPP01",83,0)
 S:$G(ROR8LST)="" ROR8LST=$NA(RORUPD("LM2"))
"RTN","RORUPP01",84,0)
 S IENS=","_PATIEN_",",I="I $D(@ROR8LST@(+$P(^(0),U)))"
"RTN","RORUPP01",85,0)
 D LIST^DIC(798.31,IENS,"@",,,,,"B",I,,"RORBUF","RORMSG")
"RTN","RORUPP01",86,0)
 I $G(DIERR)  D  Q RC
"RTN","RORUPP01",87,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"REMOVE^RORUPP01",,798.31,IENS)
"RTN","RORUPP01",88,0)
 Q:'$G(RORBUF("DILIST",0)) 0
"RTN","RORUPP01",89,0)
 S I=""
"RTN","RORUPP01",90,0)
 F  S I=$O(RORBUF("DILIST",2,I))  Q:I=""  D
"RTN","RORUPP01",91,0)
 . S IENS=RORBUF("DILIST",2,I)_","_PATIEN_","
"RTN","RORUPP01",92,0)
 . S RORFDA(798.31,IENS,.01)="@"
"RTN","RORUPP01",93,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUPP01",94,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"REMOVE^RORUPP01",,798.31)
"RTN","RORUPP01",95,0)
 Q 0
"RTN","RORUPP01",96,0)
 ;
"RTN","RORUPP01",97,0)
 ;***** RETURNS START DATE FOR THE DATA SCAN (IF ANY)
"RTN","RORUPP01",98,0)
 ;
"RTN","RORUPP01",99,0)
 ; PATIEN        Patient IEN
"RTN","RORUPP01",100,0)
 ;
"RTN","RORUPP01",101,0)
 ; Return Values:
"RTN","RORUPP01",102,0)
 ;       <0  Error code
"RTN","RORUPP01",103,0)
 ;       ""  There is no date for the patient in the file
"RTN","RORUPP01",104,0)
 ;       >0  Start date
"RTN","RORUPP01",105,0)
 ;
"RTN","RORUPP01",106,0)
SDSDATE(PATIEN) ;
"RTN","RORUPP01",107,0)
 Q:$D(^RORDATA(798.3,PATIEN,1,"B"))<10 ""
"RTN","RORUPP01",108,0)
 N CNT,DATE,I,IENS,MAXCNT,RC,RORBUF,RORMSG,TMP
"RTN","RORUPP01",109,0)
 ;--- Load the pending references (in chronological order)
"RTN","RORUPP01",110,0)
 S IENS=","_PATIEN_",",I="I $D(RORUPD(""LM2"",+$P(^(0),U)))"
"RTN","RORUPP01",111,0)
 D LIST^DIC(798.31,IENS,"@;1I;2",,,,,"AD",I,,"RORBUF","RORMSG")
"RTN","RORUPP01",112,0)
 I $G(DIERR)  D  Q RC
"RTN","RORUPP01",113,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"SDSDATE^RORUPP01",,798.31,IENS)
"RTN","RORUPP01",114,0)
 Q:'$G(RORBUF("DILIST",0)) ""
"RTN","RORUPP01",115,0)
 ;--- Get and return the earliest date
"RTN","RORUPP01",116,0)
 S MAXCNT=$$MAXCNT()
"RTN","RORUPP01",117,0)
 S (DATE,I)="",CNT=0
"RTN","RORUPP01",118,0)
 F  S I=$O(RORBUF("DILIST","ID",I))  Q:I=""  D  Q:CNT&DATE
"RTN","RORUPP01",119,0)
 . S:$G(RORBUF("DILIST","ID",I,2))<MAXCNT CNT=CNT+1
"RTN","RORUPP01",120,0)
 . S:'DATE DATE=$G(RORBUF("DILIST","ID",I,1))
"RTN","RORUPP01",121,0)
 Q $S('CNT:$$ERROR^RORERR(-66,,,PATIEN),1:DATE)
"RTN","RORUPP02")
0^74^B8476762
"RTN","RORUPP02",1,0)
RORUPP02 ;HCIOFO/SG - PENDING PATIENTS (EVENTS)  ; 5/2/02 3:19pm
"RTN","RORUPP02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPP02",3,0)
 ;
"RTN","RORUPP02",4,0)
 Q
"RTN","RORUPP02",5,0)
 ;
"RTN","RORUPP02",6,0)
 ;***** ADDS THE EVENT REFERENCE
"RTN","RORUPP02",7,0)
 ;
"RTN","RORUPP02",8,0)
 ; PATIEN        Patient IEN
"RTN","RORUPP02",9,0)
 ;
"RTN","RORUPP02",10,0)
 ; AREA          Data area of the event (see the DATA AREA field
"RTN","RORUPP02",11,0)
 ;               of the file #798.3 for details)
"RTN","RORUPP02",12,0)
 ;
"RTN","RORUPP02",13,0)
 ; [DATE]        Date/Time associated with the event (the current
"RTN","RORUPP02",14,0)
 ;               date/time is used by default).
"RTN","RORUPP02",15,0)
 ;
"RTN","RORUPP02",16,0)
 ; Return Values:
"RTN","RORUPP02",17,0)
 ;       <0  Error code
"RTN","RORUPP02",18,0)
 ;        0  Ok
"RTN","RORUPP02",19,0)
 ;
"RTN","RORUPP02",20,0)
ADD(PATIEN,AREA,DATE) ;
"RTN","RORUPP02",21,0)
 N IENS,LDT,RORFDA,RORIEN,RORMSG
"RTN","RORUPP02",22,0)
 S:$G(DATE)'>0 DATE=$$NOW^XLFDT
"RTN","RORUPP02",23,0)
 ;--- Do not record more than one reference per associated date.
"RTN","RORUPP02",24,0)
 ;    Maybe in the future all references will be recorded but we
"RTN","RORUPP02",25,0)
 ;--- need only daily precision at the moment.
"RTN","RORUPP02",26,0)
 Q:$D(^RORDATA(798.3,+PATIEN,2,"AD",AREA,DATE\1)) 0
"RTN","RORUPP02",27,0)
 ;--- Create the new event reference
"RTN","RORUPP02",28,0)
 S (RORFDA(798.3,"?+1,",.01),RORIEN(1))=+PATIEN
"RTN","RORUPP02",29,0)
 S IENS="+2,?+1,"
"RTN","RORUPP02",30,0)
 S RORFDA(798.32,IENS,.01)=$$NOW^XLFDT
"RTN","RORUPP02",31,0)
 S RORFDA(798.32,IENS,1)=AREA
"RTN","RORUPP02",32,0)
 S RORFDA(798.32,IENS,2)=$G(DATE)
"RTN","RORUPP02",33,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORUPP02",34,0)
 Q $S('$G(DIERR):0,1:-9)
"RTN","RORUPP02",35,0)
 ;
"RTN","RORUPP02",36,0)
 ;***** CHECKS THE EVENTS
"RTN","RORUPP02",37,0)
 ;
"RTN","RORUPP02",38,0)
 ; PATIEN        Patient IEN
"RTN","RORUPP02",39,0)
 ;
"RTN","RORUPP02",40,0)
 ; AREA          Data area of the event (see the DATA AREA field
"RTN","RORUPP02",41,0)
 ;               of the file #798.3 for details)
"RTN","RORUPP02",42,0)
 ;
"RTN","RORUPP02",43,0)
 ; .SDT          Reference to a local variable containing the start
"RTN","RORUPP02",44,0)
 ;               date. The date can be modified by the function and
"RTN","RORUPP02",45,0)
 ;               returned via this parameter.
"RTN","RORUPP02",46,0)
 ;
"RTN","RORUPP02",47,0)
 ; .EDT          Reference to a local variable containing the end
"RTN","RORUPP02",48,0)
 ;               date. The date can be modified by the function and
"RTN","RORUPP02",49,0)
 ;               returned via this parameter.
"RTN","RORUPP02",50,0)
 ;
"RTN","RORUPP02",51,0)
 ; Return Values:
"RTN","RORUPP02",52,0)
 ;       <0  Error code
"RTN","RORUPP02",53,0)
 ;        0  No events (skip)
"RTN","RORUPP02",54,0)
 ;        1  Events have been found (proceed)
"RTN","RORUPP02",55,0)
 ;        2  The same as 1 + dates (SDT & EDT) have been modified
"RTN","RORUPP02",56,0)
 ;
"RTN","RORUPP02",57,0)
GET(PATIEN,AREA,SDT,EDT) ;
"RTN","RORUPP02",58,0)
 N ED,FDTC,FEVT,IEN,NEWEDT,NEWSDT,ROOT,TMP
"RTN","RORUPP02",59,0)
 S ROOT=$NA(^RORDATA(798.3,+PATIEN,2))
"RTN","RORUPP02",60,0)
 S NEWSDT=999999999,NEWEDT=0,(FDTC,FEVT)=0
"RTN","RORUPP02",61,0)
 ;--- If the data search time frame is too wide and some of the
"RTN","RORUPP02",62,0)
 ;    event references have been purged already then the time
"RTN","RORUPP02",63,0)
 ;    frame cannot be shrinked according to the references and the
"RTN","RORUPP02",64,0)
 ;--- patient cannot be skipped if there are no references at all.
"RTN","RORUPP02",65,0)
 S:SDT<$G(RORUPD("EETS")) NEWSDT=SDT,NEWEDT=EDT,FEVT=1
"RTN","RORUPP02",66,0)
 ;--- Browse through the event references
"RTN","RORUPP02",67,0)
 S ED=$O(@ROOT@("AT",AREA,SDT),-1)
"RTN","RORUPP02",68,0)
 F  S ED=$O(@ROOT@("AT",AREA,ED))  Q:(ED="")!(ED'<EDT)  D
"RTN","RORUPP02",69,0)
 . S IEN=""
"RTN","RORUPP02",70,0)
 . F  S IEN=$O(@ROOT@("AT",AREA,ED,IEN))  Q:IEN=""  D
"RTN","RORUPP02",71,0)
 . . S TMP=$P($G(@ROOT@(IEN,0)),"^",3),FEVT=1
"RTN","RORUPP02",72,0)
 . . Q:TMP'>0
"RTN","RORUPP02",73,0)
 . . S:TMP<NEWSDT NEWSDT=TMP,FDTC=1
"RTN","RORUPP02",74,0)
 . . S:TMP>NEWEDT NEWEDT=TMP,FDTC=1
"RTN","RORUPP02",75,0)
 Q:'FEVT 0
"RTN","RORUPP02",76,0)
 I FDTC  S SDT=NEWSDT,EDT=NEWEDT  Q 2
"RTN","RORUPP02",77,0)
 Q 1
"RTN","RORUPP02",78,0)
 ;
"RTN","RORUPP02",79,0)
 ;***** PURGES THE OLD EVENT REFERENCES
"RTN","RORUPP02",80,0)
 ;
"RTN","RORUPP02",81,0)
 ; DATE          Keep the references starting from this date
"RTN","RORUPP02",82,0)
 ;
"RTN","RORUPP02",83,0)
 ; Return Values:
"RTN","RORUPP02",84,0)
 ;       <0  Error code
"RTN","RORUPP02",85,0)
 ;        0  Ok
"RTN","RORUPP02",86,0)
 ;
"RTN","RORUPP02",87,0)
PURGE(DATE) ;
"RTN","RORUPP02",88,0)
 N CNT,IEN,IEN1,IENS,RC,ROOT,RORFDA,RORMSG
"RTN","RORUPP02",89,0)
 S ROOT=$$ROOT^DILFD(798.3,,1)
"RTN","RORUPP02",90,0)
 S DATE=DATE\1,(CNT,RC)=0
"RTN","RORUPP02",91,0)
 F  S DATE=$O(@ROOT@("AT",DATE),-1)  Q:DATE=""  D  Q:RC<0
"RTN","RORUPP02",92,0)
 . S IEN=""
"RTN","RORUPP02",93,0)
 . F  S IEN=$O(@ROOT@("AT",DATE,IEN))  Q:IEN=""  D  Q:RC<0
"RTN","RORUPP02",94,0)
 . . S IEN1=""
"RTN","RORUPP02",95,0)
 . . F  S IEN1=$O(@ROOT@("AT",DATE,IEN,IEN1))  Q:IEN1=""  D  Q:RC<0
"RTN","RORUPP02",96,0)
 . . . S IENS=IEN1_","_IEN_","
"RTN","RORUPP02",97,0)
 . . . S RORFDA(798.32,IENS,.01)="@"
"RTN","RORUPP02",98,0)
 . . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUPP02",99,0)
 . . . I $G(DIERR)  D  Q
"RTN","RORUPP02",100,0)
 . . . . S RC=$$DBS^RORERR("RORMSG",-9,"PURGE^RORUPP02",,798.32,IENS)
"RTN","RORUPP02",101,0)
 . . . S CNT=CNT+1
"RTN","RORUPP02",102,0)
 D:CNT>0 LOG^RORLOG(2,CNT_" events were purged from the file #798.3")
"RTN","RORUPP02",103,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR")
0^65^B28519730
"RTN","RORUPR",1,0)
RORUPR ;HCIOFO/SG - SELECTION RULES PREPARATION  ; 4/24/02 8:25am
"RTN","RORUPR",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPR",3,0)
 ;
"RTN","RORUPR",4,0)
 Q
"RTN","RORUPR",5,0)
 ;
"RTN","RORUPR",6,0)
 ;***** PREPARES SELECTION RULES AND OTHER DATA
"RTN","RORUPR",7,0)
 ;
"RTN","RORUPR",8,0)
 ; .REGLST       Reference to a local array containing registry names
"RTN","RORUPR",9,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUPR",10,0)
 ; [LMODE]       When stop looping through records of the patient:
"RTN","RORUPR",11,0)
 ;                 0  always loop through all records
"RTN","RORUPR",12,0)
 ;                 1  all top level rules have been triggered (deflt)
"RTN","RORUPR",13,0)
 ;                 2  patient has been marked for addition to all
"RTN","RORUPR",14,0)
 ;                    registries being processed
"RTN","RORUPR",15,0)
 ; [DSBEG]       Start date/time of the data scan (the earliest
"RTN","RORUPR",16,0)
 ;               registry update date by default)
"RTN","RORUPR",17,0)
 ; [DSEND]       End date/time of the data scan (NOW by default)
"RTN","RORUPR",18,0)
 ;
"RTN","RORUPR",19,0)
 ; Return Values:
"RTN","RORUPR",20,0)
 ;        0  Ok
"RTN","RORUPR",21,0)
 ;       <0  Error code
"RTN","RORUPR",22,0)
 ;
"RTN","RORUPR",23,0)
PREPARE(REGLST,LMODE,DSBEG,DSEND) ;
"RTN","RORUPR",24,0)
 N RORERRDL      ; Default error location
"RTN","RORUPR",25,0)
 ;
"RTN","RORUPR",26,0)
 N FILE,I,RC
"RTN","RORUPR",27,0)
 D DFLTLOC^RORERR("PREPARE^RORUPR")
"RTN","RORUPR",28,0)
 ;--- Clear loop control lists
"RTN","RORUPR",29,0)
 F I="LM","LM1","LM2"  K RORUPD(I)
"RTN","RORUPR",30,0)
 S RORUPD("LM")=+$G(LMODE,1)
"RTN","RORUPR",31,0)
 ;--- Load registry parameters
"RTN","RORUPR",32,0)
 S RC=$$PREPARE1(.REGLST,$G(DSBEG),$G(DSEND))  Q:RC<0 RC
"RTN","RORUPR",33,0)
 ;--- Load selection rules
"RTN","RORUPR",34,0)
 S RC=$$LOAD^RORUPR1(.REGLST)        Q:RC<0 $$ERROR^RORERR(-19)
"RTN","RORUPR",35,0)
 ;--- Load and prepare Lab search data
"RTN","RORUPR",36,0)
 S RC=$$LABSRCH^RORUPR1()            Q:RC<0 $$ERROR^RORERR(-12)
"RTN","RORUPR",37,0)
 ;--- Sort loaded rules
"RTN","RORUPR",38,0)
 S RC=$$SORT()                       Q:RC<0 $$ERROR^RORERR(-20)
"RTN","RORUPR",39,0)
 ;--- Load and prepare metadata
"RTN","RORUPR",40,0)
 S RC=$$METADATA^RORUPR1()           Q:RC<0 RC
"RTN","RORUPR",41,0)
 Q 0
"RTN","RORUPR",42,0)
 ;
"RTN","RORUPR",43,0)
 ;***** LOADS REGISTRY PARAMETERS
"RTN","RORUPR",44,0)
 ;
"RTN","RORUPR",45,0)
 ; .REGLST       Reference to a local array containing
"RTN","RORUPR",46,0)
 ;               registry names as subscripts
"RTN","RORUPR",47,0)
 ;
"RTN","RORUPR",48,0)
 ; [DSBEG]       Start date of the data scan (the earliest registry
"RTN","RORUPR",49,0)
 ;               update date by default). Time part of the parameter
"RTN","RORUPR",50,0)
 ;               value is ignored.
"RTN","RORUPR",51,0)
 ;
"RTN","RORUPR",52,0)
 ; [DSEND]       End date/time of the data scan (NOW by default).
"RTN","RORUPR",53,0)
 ;
"RTN","RORUPR",54,0)
 ; Return Values:
"RTN","RORUPR",55,0)
 ;        0  Ok
"RTN","RORUPR",56,0)
 ;       <0  Error code
"RTN","RORUPR",57,0)
 ;
"RTN","RORUPR",58,0)
PREPARE1(REGLST,DSBEG,DSEND) ;
"RTN","RORUPR",59,0)
 N DATE,EVTPROT,I,RC,REGIEN,REGNAME,RORBUF,TMP,UPDSTART
"RTN","RORUPR",60,0)
 K RORUPD("LD"),RORUPD("UPD")
"RTN","RORUPR",61,0)
 S DSBEG=$G(DSBEG)\1,DSEND=+$G(DSEND)
"RTN","RORUPR",62,0)
 S UPDSTART=$$DT^XLFDT,EVTPROT=0
"RTN","RORUPR",63,0)
 ;---
"RTN","RORUPR",64,0)
 S REGNAME="",RC=0
"RTN","RORUPR",65,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPR",66,0)
 . S REGIEN=$$REGIEN^RORUTL02(REGNAME,"1I;6.1;6.2;15.1;25I",.RORBUF)
"RTN","RORUPR",67,0)
 . I REGIEN'>0  S RC=$$ERROR^RORERR(-46,"PREPARE1^RORUPR",REGNAME)  Q
"RTN","RORUPR",68,0)
 . ;--- Load and verify update entry points
"RTN","RORUPR",69,0)
 . S RC=0
"RTN","RORUPR",70,0)
 . F I=1,2  D  Q:RC<0
"RTN","RORUPR",71,0)
 . . S TMP=$G(RORBUF("DILIST","ID",1,+("6."_I)))
"RTN","RORUPR",72,0)
 . . S TMP=$$TRIM^XLFSTR(TMP)  Q:TMP=""
"RTN","RORUPR",73,0)
 . . S RC=$$VERIFYEP^RORUTL01(TMP)
"RTN","RORUPR",74,0)
 . . S:RC'<0 RORUPD("UPD",REGIEN,I)=TMP
"RTN","RORUPR",75,0)
 . I RC<0  S RC=$$ERROR^RORERR(-6,"PREPARE1^RORUPR",REGNAME,,TMP)  Q
"RTN","RORUPR",76,0)
 . ;--- Calculate the earliest update date for the registries
"RTN","RORUPR",77,0)
 . ;    being processed
"RTN","RORUPR",78,0)
 . S DATE=$G(RORBUF("DILIST","ID",1,1))\1
"RTN","RORUPR",79,0)
 . I DATE  S:DATE<UPDSTART UPDSTART=DATE
"RTN","RORUPR",80,0)
 . ;--- Calculate the longest lag interval
"RTN","RORUPR",81,0)
 . S TMP=$G(RORBUF("DILIST","ID",1,15.1))
"RTN","RORUPR",82,0)
 . S:TMP>$G(RORUPD("LD",1)) RORUPD("LD",1)=TMP
"RTN","RORUPR",83,0)
 . ;--- Check if event references should be used
"RTN","RORUPR",84,0)
 . S:$G(RORBUF("DILIST","ID",1,25)) EVTPROT=1
"RTN","RORUPR",85,0)
 Q:RC<0 RC
"RTN","RORUPR",86,0)
 ;--- Check the lag interval
"RTN","RORUPR",87,0)
 S:$G(RORUPD("LD",1))'>0 RORUPD("LD",1)=1
"RTN","RORUPR",88,0)
 ;--- Define data scan period
"RTN","RORUPR",89,0)
 S RORUPD("DT")=$$NOW^XLFDT
"RTN","RORUPR",90,0)
 S RORUPD("DSBEG")=$S(DSBEG:DSBEG,1:UPDSTART)
"RTN","RORUPR",91,0)
 S RORUPD("DSEND")=$S(DSEND:DSEND,1:RORUPD("DT"))
"RTN","RORUPR",92,0)
 ;--- Check if we have event references in the file #798.3
"RTN","RORUPR",93,0)
 S RORUPD("EETS")=$O(^RORDATA(798.3,"AT",""))
"RTN","RORUPR",94,0)
 S:'RORUPD("EETS") EVTPROT=0
"RTN","RORUPR",95,0)
 ;--- Add all necessary flags
"RTN","RORUPR",96,0)
 S RORUPD("FLAGS")=$TR($G(RORUPD("FLAGS")),"E")
"RTN","RORUPR",97,0)
 S:EVTPROT RORUPD("FLAGS")=RORUPD("FLAGS")_"E"
"RTN","RORUPR",98,0)
 Q 0
"RTN","RORUPR",99,0)
 ;
"RTN","RORUPR",100,0)
 ;***** PUTS THE RULE INTO THE LIST
"RTN","RORUPR",101,0)
 ;
"RTN","RORUPR",102,0)
 ; RULENAME      Name of the rule
"RTN","RORUPR",103,0)
 ; MODE          "A" (process after subfiles) or
"RTN","RORUPR",104,0)
 ;               "B" (process before subfiles)
"RTN","RORUPR",105,0)
 ; PARENT        Name of the parent rule
"RTN","RORUPR",106,0)
 ; 
"RTN","RORUPR",107,0)
 ; Return Values:
"RTN","RORUPR",108,0)
 ;        0  Ok
"RTN","RORUPR",109,0)
 ;       <0  Error code
"RTN","RORUPR",110,0)
 ;
"RTN","RORUPR",111,0)
PUTRULE(RULENAME,MODE,PARENT) ;
"RTN","RORUPR",112,0)
 N CODE,DSTNODE,DEPNAME,HDR,FILE,IR,IC
"RTN","RORUPR",113,0)
 S HDR=$G(@RORUPDPI@(3,RULENAME)),FILE=+$P(HDR,U,2)
"RTN","RORUPR",114,0)
 ;--- If the rule has already been processed, try to remove it from
"RTN","RORUPR",115,0)
 ;    the dependency list of the parent rule
"RTN","RORUPR",116,0)
 I $P(HDR,U,3)  D REMOVE(RULENAME,FILE,MODE,$G(PARENT))  Q 0
"RTN","RORUPR",117,0)
 ;--- If the rule is in the list of parent rules already, it has been
"RTN","RORUPR",118,0)
 ;    mentioned ; somewhere above in the current processing path.
"RTN","RORUPR",119,0)
 ;    So, we have "cirle refrenece" (the rule directly or inderectly
"RTN","RORUPR",120,0)
 ;    depends on itself)
"RTN","RORUPR",121,0)
 Q:$D(LSTRUL(RULENAME)) $$ERROR^RORERR(-5,"PUTRULE^RORUPR",RULENAME)
"RTN","RORUPR",122,0)
 ;--- Put the rule into the list of parent rules
"RTN","RORUPR",123,0)
 S LSTRUL(RULENAME)=""
"RTN","RORUPR",124,0)
 ;--- Process the rules that this one depends on
"RTN","RORUPR",125,0)
 S DEPNAME=""
"RTN","RORUPR",126,0)
 F  S DEPNAME=$O(@RORUPDPI@(3,RULENAME,3,DEPNAME))  Q:DEPNAME=""  D  Q:RC<0
"RTN","RORUPR",127,0)
 . S RC=$$PUTRULE(DEPNAME,MODE,RULENAME)
"RTN","RORUPR",128,0)
 ;--- Remove the rule from the list of parent rules
"RTN","RORUPR",129,0)
 K LSTRUL(RULENAME)  Q:RC<0 RC
"RTN","RORUPR",130,0)
 ;--- Process the rule (put it in the sorted list of rules) if there
"RTN","RORUPR",131,0)
 ;    are no rules left in its dependency list
"RTN","RORUPR",132,0)
 D:$D(@RORUPDPI@(3,RULENAME,3))<10
"RTN","RORUPR",133,0)
 . S IR=$O(RORUPD("SR",FILE,MODE,""),-1)+1
"RTN","RORUPR",134,0)
 . S DSTNODE=$NA(RORUPD("SR",FILE,MODE,IR))
"RTN","RORUPR",135,0)
 . S @DSTNODE=RULENAME_U_+HDR_U_$P(HDR,U,4)
"RTN","RORUPR",136,0)
 . S @DSTNODE@(1)=@RORUPDPI@(3,RULENAME,1)
"RTN","RORUPR",137,0)
 . M @DSTNODE@(2)=@RORUPDPI@(3,RULENAME,2)
"RTN","RORUPR",138,0)
 . S $P(@RORUPDPI@(3,RULENAME),U,3)=1
"RTN","RORUPR",139,0)
 . ;--- Try to remove the rule from the dependency list of
"RTN","RORUPR",140,0)
 . ;    the parent rule
"RTN","RORUPR",141,0)
 . D REMOVE(RULENAME,FILE,MODE,$G(PARENT))
"RTN","RORUPR",142,0)
 Q 0
"RTN","RORUPR",143,0)
 ;
"RTN","RORUPR",144,0)
 ;***** REMOVES THE RULE FROM THE DEPENDENCY LIST OF THE PARENT RULE
"RTN","RORUPR",145,0)
 ;
"RTN","RORUPR",146,0)
 ; RULENAME      Name of the rule
"RTN","RORUPR",147,0)
 ; FILE          File number
"RTN","RORUPR",148,0)
 ; MODE          "A" (process after subfiles) or
"RTN","RORUPR",149,0)
 ;               "B" (process before subfiles)
"RTN","RORUPR",150,0)
 ; PARENT        Name of the parent rule
"RTN","RORUPR",151,0)
 ;
"RTN","RORUPR",152,0)
 ; During the first pass of the sort ("before" rules) a rule is
"RTN","RORUPR",153,0)
 ; removed from the parent's dependency list only if the rule is
"RTN","RORUPR",154,0)
 ; associated with the same file as its parent.
"RTN","RORUPR",155,0)
 ;
"RTN","RORUPR",156,0)
 ; Rules are always removed from the dependency list during
"RTN","RORUPR",157,0)
 ; the second sort pass ("after" rules").
"RTN","RORUPR",158,0)
 ;
"RTN","RORUPR",159,0)
REMOVE(RULENAME,FILE,MODE,PARENT) ;
"RTN","RORUPR",160,0)
 Q:$G(PARENT)=""
"RTN","RORUPR",161,0)
 K:(+$P($G(@RORUPDPI@(3,PARENT)),U,2)=FILE)!(MODE="A") @RORUPDPI@(3,PARENT,3,RULENAME)
"RTN","RORUPR",162,0)
 Q
"RTN","RORUPR",163,0)
 ;
"RTN","RORUPR",164,0)
 ;***** SORTS SELECTION RULES
"RTN","RORUPR",165,0)
 ;
"RTN","RORUPR",166,0)
 ; Return Values:
"RTN","RORUPR",167,0)
 ;        0  Ok
"RTN","RORUPR",168,0)
 ;       <0  Error code
"RTN","RORUPR",169,0)
 ;
"RTN","RORUPR",170,0)
SORT() ;
"RTN","RORUPR",171,0)
 N LSTRUL        ; List of names of the parent rules above in the path
"RTN","RORUPR",172,0)
 N RORERRDL      ; Default error location
"RTN","RORUPR",173,0)
 ;
"RTN","RORUPR",174,0)
 N FILE,MODE,RC,RULENAME
"RTN","RORUPR",175,0)
 D DFLTLOC^RORERR("SORT^RORUPR")
"RTN","RORUPR",176,0)
 S RC=0  K RORUPD("SR")
"RTN","RORUPR",177,0)
 ;--- Process "before" selection rules first and then process
"RTN","RORUPR",178,0)
 ;  "after" rules
"RTN","RORUPR",179,0)
 F MODE="B","A"  D  Q:RC
"RTN","RORUPR",180,0)
 . S FILE=""             ; Loop through affected files
"RTN","RORUPR",181,0)
 . F  S FILE=$O(@RORUPDPI@(1,FILE))  Q:FILE=""  D  Q:RC
"RTN","RORUPR",182,0)
 . . S RULENAME=""       ; Loop through top level rules
"RTN","RORUPR",183,0)
 . . F  S RULENAME=$O(@RORUPDPI@(1,FILE,"S",RULENAME))  Q:RULENAME=""  D  Q:RC<0
"RTN","RORUPR",184,0)
 . . . S RC=$$PUTRULE(RULENAME,MODE)
"RTN","RORUPR",185,0)
 ;---
"RTN","RORUPR",186,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1")
0^66^B72168761
"RTN","RORUPR1",1,0)
RORUPR1 ;HCIOFO/SG - SELECTION RULES PREPARATION  ; 3/28/02 1:34pm
"RTN","RORUPR1",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUPR1",3,0)
 ;
"RTN","RORUPR1",4,0)
 Q
"RTN","RORUPR1",5,0)
 ;
"RTN","RORUPR1",6,0)
 ;***** MARKS PARENT FILES TO PROCESS
"RTN","RORUPR1",7,0)
 ;
"RTN","RORUPR1",8,0)
 ; This function analyzes file dependencies defined by the 'ROR
"RTN","RORUPR1",9,0)
 ; METADATA' file and guaranties that all necessary files will be
"RTN","RORUPR1",10,0)
 ; processed during the registry update.
"RTN","RORUPR1",11,0)
 ;
"RTN","RORUPR1",12,0)
FILETREE() ;
"RTN","RORUPR1",13,0)
 N FILE,PF,RC
"RTN","RORUPR1",14,0)
 S FILE="",RC=0
"RTN","RORUPR1",15,0)
 F  S FILE=$O(RORUPD("SR",FILE))  Q:FILE=""  D  Q:RC<0
"RTN","RORUPR1",16,0)
 . S PF=+FILE,RC=0
"RTN","RORUPR1",17,0)
 . ;--- Follow a path that leads from this file to
"RTN","RORUPR1",18,0)
 . ;    the root of the "file-processing tree".
"RTN","RORUPR1",19,0)
 . F  D  Q:RC
"RTN","RORUPR1",20,0)
 . . ;--- Check if metadata for the file is defined
"RTN","RORUPR1",21,0)
 . . I '$D(^ROR(799.2,PF))  D  Q
"RTN","RORUPR1",22,0)
 . . . S RC=$$ERROR^RORERR(-63,"METADATA^RORUPR1",,,PF)
"RTN","RORUPR1",23,0)
 . . ;--- Get the number of the parent file
"RTN","RORUPR1",24,0)
 . . S PF=+$$GET1^DIQ(799.2,PF_",",1,"I",,"RORMSG")
"RTN","RORUPR1",25,0)
 . . I $G(DIERR)  D  Q
"RTN","RORUPR1",26,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,"METADATA^RORUPR1")
"RTN","RORUPR1",27,0)
 . . ;--- Stop if the root of the "file-processing tree" has been
"RTN","RORUPR1",28,0)
 . . ;    reached or the file is already marked for processing.
"RTN","RORUPR1",29,0)
 . . ;    Otherwise, mark the file and continue moving up.
"RTN","RORUPR1",30,0)
 . . I 'PF!$D(RORUPD("SR",PF))  S RC=1  Q
"RTN","RORUPR1",31,0)
 . . S RORUPD("SR",PF)=""
"RTN","RORUPR1",32,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1",33,0)
 ;
"RTN","RORUPR1",34,0)
 ;***** RETURNS LEVEL OF THE FILE IN 'THE FILE PROCESSING' TREE
"RTN","RORUPR1",35,0)
 ;
"RTN","RORUPR1",36,0)
 ; FILE          File number
"RTN","RORUPR1",37,0)
 ;
"RTN","RORUPR1",38,0)
FLEVEL(FILE) ;
"RTN","RORUPR1",39,0)
 N LEVEL
"RTN","RORUPR1",40,0)
 S LEVEL=1
"RTN","RORUPR1",41,0)
 F  S FILE=+$P($G(^ROR(799.2,FILE,0)),U,2)  Q:'FILE  S LEVEL=LEVEL+1
"RTN","RORUPR1",42,0)
 Q LEVEL
"RTN","RORUPR1",43,0)
 ;
"RTN","RORUPR1",44,0)
 ;***** LOADS AND PREPARES LAB SEARCH INDICATORS
"RTN","RORUPR1",45,0)
 ;
"RTN","RORUPR1",46,0)
 ; Return Values:
"RTN","RORUPR1",47,0)
 ;        0  Ok
"RTN","RORUPR1",48,0)
 ;       <0  Error code
"RTN","RORUPR1",49,0)
 ;
"RTN","RORUPR1",50,0)
LABSRCH() ;
"RTN","RORUPR1",51,0)
 N I,IND,IR,LRCODE,LSICNT,LSIEN,RC,RORBUF,RORMSG,TMP,VAL
"RTN","RORUPR1",52,0)
 K RORLRC
"RTN","RORUPR1",53,0)
 ;--- Browse through the list of Lab searches
"RTN","RORUPR1",54,0)
 S LSIEN="",RC=0
"RTN","RORUPR1",55,0)
 F  S LSIEN=$O(@RORUPDPI@(4,LSIEN))  Q:LSIEN=""  D  Q:RC<0
"RTN","RORUPR1",56,0)
 . S TMP=","_LSIEN_","
"RTN","RORUPR1",57,0)
 . D LIST^DIC(798.92,TMP,"@;.01;.02;1I;2",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",58,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"LABSRCH^RORUPR1")  Q:RC<0
"RTN","RORUPR1",59,0)
 . ;--- Browse through the list of search indicators
"RTN","RORUPR1",60,0)
 . S IR="",LSICNT=0
"RTN","RORUPR1",61,0)
 . F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D  Q:RC<0
"RTN","RORUPR1",62,0)
 . . K LRCODE
"RTN","RORUPR1",63,0)
 . . S LRCODE=$G(RORBUF("DILIST","ID",IR,.01))
"RTN","RORUPR1",64,0)
 . . I LRCODE>0  D  Q:RC<0  S LRCODE(LRCODE_"^LN")=""
"RTN","RORUPR1",65,0)
 . . . S LRCODE=$$LNCODE^RORUTL02(LRCODE)
"RTN","RORUPR1",66,0)
 . . . S:LRCODE<0 RC=LRCODE
"RTN","RORUPR1",67,0)
 . . S LRCODE=$G(RORBUF("DILIST","ID",IR,.02))
"RTN","RORUPR1",68,0)
 . . S:LRCODE>0 LRCODE(LRCODE_"^NLT")=""
"RTN","RORUPR1",69,0)
 . . M RORLRC("B")=LRCODE
"RTN","RORUPR1",70,0)
 . . ;--- Load a search indicator
"RTN","RORUPR1",71,0)
 . . S IND=$G(RORBUF("DILIST","ID",IR,1))  Q:IND'>0
"RTN","RORUPR1",72,0)
 . . S VAL=$G(RORBUF("DILIST","ID",IR,2))  Q:(IND>1)&(VAL="")
"RTN","RORUPR1",73,0)
 . . S LSICNT=LSICNT+1
"RTN","RORUPR1",74,0)
 . . S LRCODE=""
"RTN","RORUPR1",75,0)
 . . F  S LRCODE=$O(LRCODE(LRCODE))  Q:LRCODE=""  D
"RTN","RORUPR1",76,0)
 . . . S I=$O(@RORUPDPI@("LS",LRCODE,LSIEN,""),-1)+1
"RTN","RORUPR1",77,0)
 . . . S @RORUPDPI@("LS",LRCODE,LSIEN,I)=IND_U_VAL
"RTN","RORUPR1",78,0)
 . Q:(RC<0)!(LSICNT>0)
"RTN","RORUPR1",79,0)
 . ;--- Record a warning if no indicators are defined
"RTN","RORUPR1",80,0)
 . S TMP=$$GET1^DIQ(798.9,LSIEN_",",.01,,,"RORMSG")
"RTN","RORUPR1",81,0)
 . S TMP=$$ERROR^RORERR(-55,"LABSRCH^RORUPR1",,,TMP)
"RTN","RORUPR1",82,0)
 Q:RC<0 RC
"RTN","RORUPR1",83,0)
 ;--- Prepare a list of Lab result codes for GCPR^LA7QRY
"RTN","RORUPR1",84,0)
 S LRCODE=""
"RTN","RORUPR1",85,0)
 F IR=1:1  S LRCODE=$O(RORLRC("B",LRCODE))  Q:LRCODE=""  D
"RTN","RORUPR1",86,0)
 . S RORLRC(IR)=LRCODE
"RTN","RORUPR1",87,0)
 K RORLRC("B")
"RTN","RORUPR1",88,0)
 Q 0
"RTN","RORUPR1",89,0)
 ;
"RTN","RORUPR1",90,0)
 ;***** LOADS SELECTION RULES DATA
"RTN","RORUPR1",91,0)
 ;
"RTN","RORUPR1",92,0)
 ; .REGLST       Reference to a local array containing registry names
"RTN","RORUPR1",93,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUPR1",94,0)
 ;
"RTN","RORUPR1",95,0)
 ; Return Values:
"RTN","RORUPR1",96,0)
 ;        0  Ok
"RTN","RORUPR1",97,0)
 ;       <0  Error code
"RTN","RORUPR1",98,0)
 ;
"RTN","RORUPR1",99,0)
LOAD(REGLST) ;
"RTN","RORUPR1",100,0)
 N RORERRDL      ; Default error location
"RTN","RORUPR1",101,0)
 ;
"RTN","RORUPR1",102,0)
 N I,IENS,RC,REGIEN,REGNAME,RORBUF,RORMSG,RULENAME
"RTN","RORUPR1",103,0)
 D DFLTLOC^RORERR("LOAD^RORUPR1")
"RTN","RORUPR1",104,0)
 S REGNAME="",RC=0
"RTN","RORUPR1",105,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPR1",106,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUPR1",107,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=REGIEN  Q
"RTN","RORUPR1",108,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUPR1",109,0)
 . S @RORUPDPI@(2,REGIEN)=REGNAME
"RTN","RORUPR1",110,0)
 . S RORUPD("LM2",REGIEN)=""
"RTN","RORUPR1",111,0)
 . ;--- Load selection rules
"RTN","RORUPR1",112,0)
 . K RORBUF  S IENS=","_REGIEN_","
"RTN","RORUPR1",113,0)
 . D LIST^DIC(798.13,IENS,"@;.01E",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",114,0)
 . S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0
"RTN","RORUPR1",115,0)
 . S I=""
"RTN","RORUPR1",116,0)
 . F  S I=$O(RORBUF("DILIST","ID",I))  Q:I=""  D  Q:RC<0
"RTN","RORUPR1",117,0)
 . . S RULENAME=RORBUF("DILIST","ID",I,.01)
"RTN","RORUPR1",118,0)
 . . S RC=$$LOADRULE(RULENAME,REGIEN)
"RTN","RORUPR1",119,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1",120,0)
 ;
"RTN","RORUPR1",121,0)
 ;***** LOADS THE SELECTION RULE
"RTN","RORUPR1",122,0)
 ;
"RTN","RORUPR1",123,0)
 ; RULENAME      Name of the rule
"RTN","RORUPR1",124,0)
 ; REGIEN        Registry IEN
"RTN","RORUPR1",125,0)
 ; [LEVEL]       Level of the rule (O for top level rules)
"RTN","RORUPR1",126,0)
 ;
"RTN","RORUPR1",127,0)
 ; Return Values:
"RTN","RORUPR1",128,0)
 ;        0  Ok
"RTN","RORUPR1",129,0)
 ;       <0  Error code
"RTN","RORUPR1",130,0)
 ;
"RTN","RORUPR1",131,0)
LOADRULE(RULENAME,REGIEN,LEVEL) ;
"RTN","RORUPR1",132,0)
 N RORERRDL      ; Default error location
"RTN","RORUPR1",133,0)
 ;
"RTN","RORUPR1",134,0)
 ;--- Quit if the rule has already been loaded
"RTN","RORUPR1",135,0)
 I $D(@RORUPDPI@(3,RULENAME))  D  Q 0
"RTN","RORUPR1",136,0)
 . S @RORUPDPI@(3,RULENAME,2,REGIEN)=""
"RTN","RORUPR1",137,0)
 ;---
"RTN","RORUPR1",138,0)
 N DATELMT,DEPRLC,EXPR,FILE,I,IENS,RORBUF,RORMSG,RULIEN,TMP
"RTN","RORUPR1",139,0)
 D DFLTLOC^RORERR("LOADRULE^RORUPR1")
"RTN","RORUPR1",140,0)
 ;--- Load the rule data
"RTN","RORUPR1",141,0)
 D FIND^DIC(798.2,,"@;1;2I","X",RULENAME,2,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",142,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORUPR1",143,0)
 Q:$G(RORBUF("DILIST",0))<1 $$ERROR^RORERR(-3,,RULENAME)
"RTN","RORUPR1",144,0)
 Q:$G(RORBUF("DILIST",0))>1 $$ERROR^RORERR(-4,,RULENAME)
"RTN","RORUPR1",145,0)
 S RULIEN=+RORBUF("DILIST",2,1),IENS=","_RULIEN_","
"RTN","RORUPR1",146,0)
 S FILE=+RORBUF("DILIST","ID",1,2)
"RTN","RORUPR1",147,0)
 ;--- Put the rule data into the temporary global
"RTN","RORUPR1",148,0)
 S @RORUPDPI@(1,FILE,"S",RULENAME)=""
"RTN","RORUPR1",149,0)
 S @RORUPDPI@(3,RULENAME)=RULIEN_U_FILE_"^^"_'$G(LEVEL)
"RTN","RORUPR1",150,0)
 S RC=$$PARSER^RORUPEX(FILE,RORBUF("DILIST","ID",1,1),.EXPR)
"RTN","RORUPR1",151,0)
 Q:RC<0 RC
"RTN","RORUPR1",152,0)
 S @RORUPDPI@(3,RULENAME,1)=EXPR
"RTN","RORUPR1",153,0)
 S @RORUPDPI@(3,RULENAME,2,REGIEN)=""
"RTN","RORUPR1",154,0)
 M @RORUPDPI@(1,FILE,"F")=EXPR("F")
"RTN","RORUPR1",155,0)
 S:'$G(LEVEL) RORUPD("LM1",RULENAME)=""
"RTN","RORUPR1",156,0)
 M @RORUPDPI@(4)=EXPR("L")
"RTN","RORUPR1",157,0)
 ;--- Load the rules that this rule depends on
"RTN","RORUPR1",158,0)
 S DEPRLC=""
"RTN","RORUPR1",159,0)
 F  S DEPRLC=$O(EXPR("R",DEPRLC))  Q:DEPRLC=""  D  Q:RC<0
"RTN","RORUPR1",160,0)
 . S RC=$$LOADRULE(DEPRLC,REGIEN,$G(LEVEL)+1)
"RTN","RORUPR1",161,0)
 . S:RC'<0 @RORUPDPI@(3,RULENAME,3,DEPRLC)=""
"RTN","RORUPR1",162,0)
 Q:RC<0 RC
"RTN","RORUPR1",163,0)
 ;--- Load a list of additional data elements
"RTN","RORUPR1",164,0)
 K EXPR,RORBUF,RORMSG
"RTN","RORUPR1",165,0)
 D LIST^DIC(798.26,IENS,"@;.01I;1I",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",166,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORUPR1",167,0)
 S I=""
"RTN","RORUPR1",168,0)
 F  S I=$O(RORBUF("DILIST","ID",I))  Q:I=""  D
"RTN","RORUPR1",169,0)
 . S DATELMT=RORBUF("DILIST","ID",I,.01)
"RTN","RORUPR1",170,0)
 . S TMP=$G(RORBUF("DILIST","ID",I,1))  S:TMP="" TMP="EI"
"RTN","RORUPR1",171,0)
 . S:TMP["E" @RORUPDPI@(1,FILE,"F",DATELMT,"E")=""
"RTN","RORUPR1",172,0)
 . S:TMP["I" @RORUPDPI@(1,FILE,"F",DATELMT,"I")=""
"RTN","RORUPR1",173,0)
 Q 0
"RTN","RORUPR1",174,0)
 ;
"RTN","RORUPR1",175,0)
 ;***** LOADS AND PREPARES THE METADATA
"RTN","RORUPR1",176,0)
METADATA() ;
"RTN","RORUPR1",177,0)
 N API,DATELMT,DEFL,FILE,I,IENS,IS,PIF,RC,ROOT,RORBUF,RORMSG,TMP,VT
"RTN","RORUPR1",178,0)
 S RC=$$FILETREE()  Q:RC<0 RC
"RTN","RORUPR1",179,0)
 S DEFL="@;.02I;1I;4I;4.1;4.2;6I"
"RTN","RORUPR1",180,0)
 ;--- Load and process the metadata
"RTN","RORUPR1",181,0)
 S FILE="",RC=0
"RTN","RORUPR1",182,0)
 F  S FILE=$O(RORUPD("SR",FILE))  Q:FILE=""  D  Q:RC<0
"RTN","RORUPR1",183,0)
 . S IENS=","_FILE_",",PIF=$NA(@RORUPDPI@(1,FILE))
"RTN","RORUPR1",184,0)
 . ;--- Global root of the file
"RTN","RORUPR1",185,0)
 . S RORUPD("ROOT",FILE)=$$ROOT^DILFD(FILE,,1)
"RTN","RORUPR1",186,0)
 . ;--- Associate data elements with APIs
"RTN","RORUPR1",187,0)
 . S DATELMT=""
"RTN","RORUPR1",188,0)
 . F  S DATELMT=$O(@PIF@("F",DATELMT))  Q:DATELMT=""  D  Q:RC<0
"RTN","RORUPR1",189,0)
 . . ;--- Find and load defintion of the data element
"RTN","RORUPR1",190,0)
 . . K RORBUF,RORMSG
"RTN","RORUPR1",191,0)
 . . D FIND^DIC(799.22,IENS,DEFL,"X",DATELMT,,"C",,,"RORBUF","RORMSG")
"RTN","RORUPR1",192,0)
 . . I $G(DIERR)  D  Q
"RTN","RORUPR1",193,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,"METADATA^RORUPR1",,799.22,IENS)
"RTN","RORUPR1",194,0)
 . . ;--- Check if search on this element is supported
"RTN","RORUPR1",195,0)
 . . S API=+$G(RORBUF("DILIST","ID",1,1))
"RTN","RORUPR1",196,0)
 . . I 'API  D  Q
"RTN","RORUPR1",197,0)
 . . . S RC=$$ERROR^RORERR(-64,"METADATA^RORUPR1",,,FILE,DATELMT)
"RTN","RORUPR1",198,0)
 . . ;--- Store the field number (if necessary)
"RTN","RORUPR1",199,0)
 . . I API=1  D  S RORUPD("SR",FILE,"F",API,DATELMT)=TMP
"RTN","RORUPR1",200,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",1,6))
"RTN","RORUPR1",201,0)
 . . ;--- Associate the data element with the API
"RTN","RORUPR1",202,0)
 . . S VT=$G(RORBUF("DILIST","ID",1,4)),RC=0
"RTN","RORUPR1",203,0)
 . . F I="E","I"  I $D(@PIF@("F",DATELMT,I))  D  Q:RC<0
"RTN","RORUPR1",204,0)
 . . . ;--- Check if type of the requested value is supported
"RTN","RORUPR1",205,0)
 . . . I VT'[I  D  Q
"RTN","RORUPR1",206,0)
 . . . . S TMP=$$EXTERNAL^DILFD(799.22,4,,I,"RORMSG")
"RTN","RORUPR1",207,0)
 . . . . S RC=$$ERROR^RORERR(-65,"METADATA^RORUPR1",,,FILE,DATELMT,TMP)
"RTN","RORUPR1",208,0)
 . . . ;--- Add the API-Element pair to the list
"RTN","RORUPR1",209,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",1,$$VTFN(I)))
"RTN","RORUPR1",210,0)
 . . . S RORUPD("SR",FILE,"F",API,DATELMT,I)=TMP
"RTN","RORUPR1",211,0)
 . Q:RC<0
"RTN","RORUPR1",212,0)
 . ;--- Add required elements (if any) to the list
"RTN","RORUPR1",213,0)
 . K RORBUF,RORMSG
"RTN","RORUPR1",214,0)
 . D FIND^DIC(799.22,IENS,DEFL,"X",1,,"AR",,,"RORBUF","RORMSG")
"RTN","RORUPR1",215,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPR1",216,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"METADATA^RORUPR1",,799.22,IENS)
"RTN","RORUPR1",217,0)
 . S IS=""
"RTN","RORUPR1",218,0)
 . F  S IS=$O(RORBUF("DILIST","ID",IS))  Q:IS=""  D
"RTN","RORUPR1",219,0)
 . . S DATELMT=+$G(RORBUF("DILIST","ID",IS,.02))  Q:'DATELMT
"RTN","RORUPR1",220,0)
 . . S API=+$G(RORBUF("DILIST","ID",IS,1))        Q:'API
"RTN","RORUPR1",221,0)
 . . S VT=$G(RORBUF("DILIST","ID",IS,4))
"RTN","RORUPR1",222,0)
 . . F I="E","I"  D:VT[I
"RTN","RORUPR1",223,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",IS,$$VTFN(I)))
"RTN","RORUPR1",224,0)
 . . . S RORUPD("SR",FILE,"F",API,DATELMT,I)=TMP
"RTN","RORUPR1",225,0)
 . . ;--- Store the field number (if necessary)
"RTN","RORUPR1",226,0)
 . . I API=1  D  S RORUPD("SR",FILE,"F",API,DATELMT)=TMP
"RTN","RORUPR1",227,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",IS,6))
"RTN","RORUPR1",228,0)
 . ;--- Compile a list of fields (separated by ';') for the GETS^DIQ
"RTN","RORUPR1",229,0)
 . Q:$D(RORUPD("SR",FILE,"F",1))<10
"RTN","RORUPR1",230,0)
 . S (DATELMT,RORBUF)=""
"RTN","RORUPR1",231,0)
 . F  S DATELMT=$O(RORUPD("SR",FILE,"F",1,DATELMT))  Q:DATELMT=""  D
"RTN","RORUPR1",232,0)
 . . S TMP=+$G(RORUPD("SR",FILE,"F",1,DATELMT))
"RTN","RORUPR1",233,0)
 . . S:TMP>0 RORBUF=RORBUF_";"_TMP
"RTN","RORUPR1",234,0)
 . S RORUPD("SR",FILE,"F",1)=$S(RORBUF'="":$P(RORBUF,";",2,999),1:"")
"RTN","RORUPR1",235,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1",236,0)
 ;
"RTN","RORUPR1",237,0)
 ;***** RETURNS FIELD NUMBER OF ADDITIONAL DATA
"RTN","RORUPR1",238,0)
VTFN(VT) ;
"RTN","RORUPR1",239,0)
 Q $S(VT="E":4.1,1:4.2)
"RTN","RORUTL01")
0^67^B34602700
"RTN","RORUTL01",1,0)
RORUTL01 ;HCIOFO/SG - UTILITIES  ; 4/19/02 7:54am
"RTN","RORUTL01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUTL01",3,0)
 ;
"RTN","RORUTL01",4,0)
 ; This routine uses the following IAs:
"RTN","RORUTL01",5,0)
 ;
"RTN","RORUTL01",6,0)
 ; #10038        Access to the HOLIDAY file (supported)
"RTN","RORUTL01",7,0)
 Q
"RTN","RORUTL01",8,0)
 ;
"RTN","RORUTL01",9,0)
 ;***** SENDS ALERT TO REGISTRY COORDINATORS
"RTN","RORUTL01",10,0)
 ;
"RTN","RORUTL01",11,0)
 ; [.]REGLST     Either name of the registry or reference to a local
"RTN","RORUTL01",12,0)
 ;               array containing registry names as subscripts and
"RTN","RORUTL01",13,0)
 ;               optional registry IENs as values
"RTN","RORUTL01",14,0)
 ;
"RTN","RORUTL01",15,0)
 ; MSG           Text of the message or negative error code. The '^'
"RTN","RORUTL01",16,0)
 ;               characters are replaced with spaces in the text.
"RTN","RORUTL01",17,0)
 ;
"RTN","RORUTL01",18,0)
 ; [XQAROU]      Indicates a ROUTINE or TAG^ROUTINE to run when
"RTN","RORUTL01",19,0)
 ;               the alert is processed
"RTN","RORUTL01",20,0)
 ;
"RTN","RORUTL01",21,0)
 ; [XQADATA]     Use this to store a package-specific data string,
"RTN","RORUTL01",22,0)
 ;               in any format
"RTN","RORUTL01",23,0)
 ;
"RTN","RORUTL01",24,0)
 ; [PATIEN]      Patient IEN
"RTN","RORUTL01",25,0)
 ;
"RTN","RORUTL01",26,0)
 ; [ARG2-ARG5]   Optional parameters as for the $$ERROR^RORERR
"RTN","RORUTL01",27,0)
 ;
"RTN","RORUTL01",28,0)
ALERT(REGLST,MSG,XQAROU,XQADATA,PATIEN,ARG2,ARG3,ARG4,ARG5) ;
"RTN","RORUTL01",29,0)
 N IR,RC,REGIEN,REGNAME,RORBUF,RORMSG,TMP,XQA,XQAFLG,XQAMSG
"RTN","RORUTL01",30,0)
 ;--- Prepare a list of coordinators
"RTN","RORUTL01",31,0)
 S:$D(REGLST)=1 REGLST(REGLST)=""
"RTN","RORUTL01",32,0)
 S REGNAME="",RC=0
"RTN","RORUTL01",33,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D
"RTN","RORUTL01",34,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUTL01",35,0)
 . I REGIEN'>0  D  Q:REGIEN'>0
"RTN","RORUTL01",36,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUTL01",37,0)
 . ;--- Load a list of coordinators from the registry parameters
"RTN","RORUTL01",38,0)
 . S TMP=","_REGIEN_","
"RTN","RORUTL01",39,0)
 . D LIST^DIC(798.114,TMP,"@;.01I",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL01",40,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"ALERT^RORUTL01")  Q:RC<0
"RTN","RORUTL01",41,0)
 . S IR=""
"RTN","RORUTL01",42,0)
 . F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D
"RTN","RORUTL01",43,0)
 . . S TMP=+$G(RORBUF("DILIST","ID",IR,.01))  S:TMP>0 XQA(TMP)=""
"RTN","RORUTL01",44,0)
 Q:$D(XQA)<10
"RTN","RORUTL01",45,0)
 ;--- Get text of the error message (if necessary)
"RTN","RORUTL01",46,0)
 I +MSG=MSG  Q:MSG'<0  D
"RTN","RORUTL01",47,0)
 . S MSG=$$MSG^RORERR20(+MSG,,.PATIEN,.ARG2,.ARG3,.ARG4,.ARG5)
"RTN","RORUTL01",48,0)
 S MSG=$TR(MSG,"^"," "),XQAMSG="ROR: ",TMP=70-$L(XQAMSG)-3
"RTN","RORUTL01",49,0)
 S XQAMSG=XQAMSG_$S($L(MSG)>TMP:$E(MSG,1,TMP)_"...",1:MSG)
"RTN","RORUTL01",50,0)
 ;--- Setup default alert processing routine
"RTN","RORUTL01",51,0)
 I $G(XQAROU)="",$G(XQADATA)=""  D
"RTN","RORUTL01",52,0)
 . S XQADATA=$E(MSG,1,78)_U_$G(PATIEN)
"RTN","RORUTL01",53,0)
 . S REGNAME=""
"RTN","RORUTL01",54,0)
 . F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D
"RTN","RORUTL01",55,0)
 . . S XQADATA=XQADATA_U_REGNAME
"RTN","RORUTL01",56,0)
 . S XQAROU="ALERTRTN^RORUTL01"
"RTN","RORUTL01",57,0)
 ;--- Send the alert
"RTN","RORUTL01",58,0)
 S XQAFLG="D"  D SETUP^XQALERT
"RTN","RORUTL01",59,0)
 Q
"RTN","RORUTL01",60,0)
 ;
"RTN","RORUTL01",61,0)
 ;***** DEFAULT ALERT PROCESSING ROUTINE
"RTN","RORUTL01",62,0)
 ;
"RTN","RORUTL01",63,0)
 ; XQADATA       Alert data
"RTN","RORUTL01",64,0)
 ;                 ^1: Message
"RTN","RORUTL01",65,0)
 ;                 ^2: Patient DFN
"RTN","RORUTL01",66,0)
 ;                 ^3: Registry name
"RTN","RORUTL01",67,0)
 ;                     ...
"RTN","RORUTL01",68,0)
 ;                 ^N: Registry name
"RTN","RORUTL01",69,0)
 ;
"RTN","RORUTL01",70,0)
ALERTRTN ;
"RTN","RORUTL01",71,0)
 Q:$G(XQADATA)=""
"RTN","RORUTL01",72,0)
 N I,REGNAME
"RTN","RORUTL01",73,0)
 W !!,$P(XQADATA,"^"),!
"RTN","RORUTL01",74,0)
 W:$P(XQADATA,"^",2) "Patient DFN: ",$P(XQADATA,"^",2),!
"RTN","RORUTL01",75,0)
 W "Processed Registries",!
"RTN","RORUTL01",76,0)
 F I=3:1  S REGNAME=$P(XQADATA,"^",I)  Q:REGNAME=""  W ?3,REGNAME,!
"RTN","RORUTL01",77,0)
 Q
"RTN","RORUTL01",78,0)
 ;
"RTN","RORUTL01",79,0)
 ;***** INITIALIZES THE VARIABLES
"RTN","RORUTL01",80,0)
 ;
"RTN","RORUTL01",81,0)
 ; NAMESP        Namespace to kill in the ^TMP global
"RTN","RORUTL01",82,0)
 ;               (must start with "ROR")
"RTN","RORUTL01",83,0)
 ; [XPURGE]      Purge namespaced nodes in the ^XTMP global.
"RTN","RORUTL01",84,0)
 ;               The ^XTMP(NAMESP_$J) node is always killed.
"RTN","RORUTL01",85,0)
 ;
"RTN","RORUTL01",86,0)
INIT(NAMESP,XPURGE) ;
"RTN","RORUTL01",87,0)
 N I,L,NOW  K ^TMP($J)
"RTN","RORUTL01",88,0)
 S:$G(U)="" U="^"  S:'$G(DT) DT=$$DT^XLFDT
"RTN","RORUTL01",89,0)
 Q:$E($G(NAMESP),1,3)'="ROR"
"RTN","RORUTL01",90,0)
 ;--- Kill namespaced nodes in the ^TMP global
"RTN","RORUTL01",91,0)
 S I=NAMESP,L=$L(NAMESP)
"RTN","RORUTL01",92,0)
 F  K ^TMP(I,$J)  S I=$O(^TMP(I))  Q:$E(I,1,L)'=NAMESP
"RTN","RORUTL01",93,0)
 ;--- Purge old namespaced nodes in the ^XTMP global
"RTN","RORUTL01",94,0)
 K ^XTMP(NAMESP_$J)
"RTN","RORUTL01",95,0)
 D:$G(XPURGE)
"RTN","RORUTL01",96,0)
 . S NOW=$$NOW^XLFDT,I=NAMESP,L=$L(NAMESP)
"RTN","RORUTL01",97,0)
 . F  D  S I=$O(^XTMP(I))  Q:$E(I,1,L)'=NAMESP
"RTN","RORUTL01",98,0)
 . . K:$G(^XTMP(I,0))<NOW ^XTMP(I)
"RTN","RORUTL01",99,0)
 Q
"RTN","RORUTL01",100,0)
 ;
"RTN","RORUTL01",101,0)
 ;***** INVERTS THE DATE
"RTN","RORUTL01",102,0)
 ;
"RTN","RORUTL01",103,0)
 ; DATE          Date in FileMan format
"RTN","RORUTL01",104,0)
 ; [MODE]        Mode of inversion
"RTN","RORUTL01",105,0)
 ;                 1  Strip the time BEFORE inversion
"RTN","RORUTL01",106,0)
 ;                 2  Strip the time AFTER inversion
"RTN","RORUTL01",107,0)
 ;                 3  Do not invert the time
"RTN","RORUTL01",108,0)
 ;
"RTN","RORUTL01",109,0)
INVDATE(DATE,MODE) ;
"RTN","RORUTL01",110,0)
 Q:$G(MODE)=1 9999999-$P(DATE,".")
"RTN","RORUTL01",111,0)
 Q:$G(MODE)=2 $P(9999999-DATE,".")
"RTN","RORUTL01",112,0)
 I $G(MODE)=3  Q:$P(DATE,".",2) (9999999-$P(DATE,"."))_"."_+$P(DATE,".",2)
"RTN","RORUTL01",113,0)
 Q 9999999-DATE
"RTN","RORUTL01",114,0)
 ;
"RTN","RORUTL01",115,0)
 ;***** RETURNS CODE AND TEXT OF AN ITEM IN THE FILE #799.1
"RTN","RORUTL01",116,0)
 ;
"RTN","RORUTL01",117,0)
 ; ITEMIEN       IEN of the item
"RTN","RORUTL01",118,0)
 ; [.TEXT]       Text of the item is returned via this parameter
"RTN","RORUTL01",119,0)
 ;
"RTN","RORUTL01",120,0)
 ; Return Values:
"RTN","RORUTL01",121,0)
 ;       <0  Error code
"RTN","RORUTL01",122,0)
 ;       ""  Code is not available
"RTN","RORUTL01",123,0)
 ;       >0  Code of the item
"RTN","RORUTL01",124,0)
 ;
"RTN","RORUTL01",125,0)
ITEMCODE(ITEMIEN,TEXT) ;
"RTN","RORUTL01",126,0)
 S TEXT=""  Q:'ITEMIEN ""
"RTN","RORUTL01",127,0)
 N IENS,RC,RORBUF,RORMSG
"RTN","RORUTL01",128,0)
 S IENS=(+ITEMIEN)_","
"RTN","RORUTL01",129,0)
 D GETS^DIQ(799.1,IENS,".01;.04",,"RORBUF","RORMSG")
"RTN","RORUTL01",130,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ITEMCODE^RORUTL01",,799.1,IENS)
"RTN","RORUTL01",131,0)
 S TEXT=$G(RORBUF(799.1,IENS,.01))
"RTN","RORUTL01",132,0)
 Q $G(RORBUF(799.1,IENS,.04))
"RTN","RORUTL01",133,0)
 ;
"RTN","RORUTL01",134,0)
 ;***** RETURNS A LIST OF ITEMS FROM THE FILE #799.1
"RTN","RORUTL01",135,0)
 ;
"RTN","RORUTL01",136,0)
 ; TYPE          Type of the items:
"RTN","RORUTL01",137,0)
 ;                 1  Reason for inactivation
"RTN","RORUTL01",138,0)
 ;                 2  Supporting evidence
"RTN","RORUTL01",139,0)
 ;
"RTN","RORUTL01",140,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL01",141,0)
 ;
"RTN","RORUTL01",142,0)
 ; .ROR8DST      Reference to a destination array.
"RTN","RORUTL01",143,0)
 ;               Items are returned into this array in the following
"RTN","RORUTL01",144,0)
 ;               format: ROR8DST(ItemCode)=ItemIEN^ItemText
"RTN","RORUTL01",145,0)
 ;
"RTN","RORUTL01",146,0)
 ; [CDT]         "Current" Date/Time (NOW by default)
"RTN","RORUTL01",147,0)
 ;
"RTN","RORUTL01",148,0)
 ;               If this date/time is equal or later that the
"RTN","RORUTL01",149,0)
 ;               inactivation date from the item record (only if
"RTN","RORUTL01",150,0)
 ;               there is any) then the item is considered inactive
"RTN","RORUTL01",151,0)
 ;               and will be skipped.
"RTN","RORUTL01",152,0)
 ;
"RTN","RORUTL01",153,0)
 ;               To include both active and inactive items in the
"RTN","RORUTL01",154,0)
 ;               list, pass a negative number as the value of this
"RTN","RORUTL01",155,0)
 ;               parameter.
"RTN","RORUTL01",156,0)
 ;
"RTN","RORUTL01",157,0)
 ; Return Values:
"RTN","RORUTL01",158,0)
 ;       <0  Error code
"RTN","RORUTL01",159,0)
 ;        0  Ok
"RTN","RORUTL01",160,0)
 ;
"RTN","RORUTL01",161,0)
ITEMLIST(TYPE,REGIEN,ROR8DST,CDT) ;
"RTN","RORUTL01",162,0)
 N CODE,IEN,IENS,INCTVDT,NODE,RC,RORBUF,RORMSG
"RTN","RORUTL01",163,0)
 S NODE=$NA(^ROR(799.1,"KEY",TYPE,REGIEN))  K ROR8DST
"RTN","RORUTL01",164,0)
 S:'$G(CDT) CDT=$$NOW^XLFDT
"RTN","RORUTL01",165,0)
 ;--- Load the active list items
"RTN","RORUTL01",166,0)
 S CODE="",(CNT,RC)=0
"RTN","RORUTL01",167,0)
 F  S CODE=$O(@NODE@(CODE))  Q:CODE=""  D  Q:RC<0
"RTN","RORUTL01",168,0)
 . S IEN=$O(@NODE@(CODE,""))  Q:'IEN
"RTN","RORUTL01",169,0)
 . S IENS=IEN_","
"RTN","RORUTL01",170,0)
 . ;--- Load text and inactivation date
"RTN","RORUTL01",171,0)
 . D GETS^DIQ(799.1,IENS,".01;1","IE","RORBUF","RORMSG")
"RTN","RORUTL01",172,0)
 . I $G(DIERR)  D  Q
"RTN","RORUTL01",173,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"ITEMLIST^RORUTL01",,799.1,IENS)
"RTN","RORUTL01",174,0)
 . ;--- Skip inactive items
"RTN","RORUTL01",175,0)
 . S INCTVDT=$G(RORBUF(799.1,IENS,1,"I"))
"RTN","RORUTL01",176,0)
 . I INCTVDT>0  Q:CDT'<INCTVDT
"RTN","RORUTL01",177,0)
 . ;--- Create a record in the destination array
"RTN","RORUTL01",178,0)
 . S ROR8DST(CODE)=IEN_U_$G(RORBUF(799.1,IENS,.01,"E"))
"RTN","RORUTL01",179,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL01",180,0)
 ;
"RTN","RORUTL01",181,0)
 ;***** VERIFY THE ENTRY POINT
"RTN","RORUTL01",182,0)
 ;
"RTN","RORUTL01",183,0)
 ; ENTRY         Entry point of the external MUMPS function
"RTN","RORUTL01",184,0)
 ;
"RTN","RORUTL01",185,0)
 ; Return Values:
"RTN","RORUTL01",186,0)
 ;       -18  Illegal entry point
"RTN","RORUTL01",187,0)
 ;       -17  Routine does not exist
"RTN","RORUTL01",188,0)
 ;         0  Ok
"RTN","RORUTL01",189,0)
 ;
"RTN","RORUTL01",190,0)
VERIFYEP(ENTRY) ;
"RTN","RORUTL01",191,0)
 N X
"RTN","RORUTL01",192,0)
 S X="S Y="_ENTRY  D ^DIM  Q:'$D(X) -17
"RTN","RORUTL01",193,0)
 S X=$P(ENTRY,U,2)
"RTN","RORUTL01",194,0)
 X ^%ZOSF("TEST")  E  Q -18
"RTN","RORUTL01",195,0)
 Q 0
"RTN","RORUTL01",196,0)
 ;
"RTN","RORUTL01",197,0)
 ;***** CHECKS IF THE DATE IS A WORKING DAY
"RTN","RORUTL01",198,0)
 ;
"RTN","RORUTL01",199,0)
 ; DATE          The date to be checked
"RTN","RORUTL01",200,0)
 ;
"RTN","RORUTL01",201,0)
 ; Return Values:
"RTN","RORUTL01",202,0)
 ;        0  Weekend or Holiday
"RTN","RORUTL01",203,0)
 ;        1  Working day
"RTN","RORUTL01",204,0)
 ;
"RTN","RORUTL01",205,0)
WDCHK(DATE) ;
"RTN","RORUTL01",206,0)
 N DOW,RORMSG
"RTN","RORUTL01",207,0)
 ;--- Return zero if Saturday (6) or Sunday (0)
"RTN","RORUTL01",208,0)
 S DOW=$$DOW^XLFDT(DATE,1)  Q:'DOW!(DOW>5) 0
"RTN","RORUTL01",209,0)
 ;--- Return 1 if cannot be found in the HOLIDAY file
"RTN","RORUTL01",210,0)
 Q $$FIND1^DIC(40.5,,"QX",DATE\1,"B",,"RORMSG")'>0
"RTN","RORUTL01",211,0)
 ;
"RTN","RORUTL01",212,0)
 ;***** RETURNS THE NEXT WORKING DAY DATE
"RTN","RORUTL01",213,0)
 ;
"RTN","RORUTL01",214,0)
 ; DATE          The source date
"RTN","RORUTL01",215,0)
 ;
"RTN","RORUTL01",216,0)
 ; The function returns a date of the next working day.
"RTN","RORUTL01",217,0)
 ;
"RTN","RORUTL01",218,0)
WDNEXT(DATE) ;
"RTN","RORUTL01",219,0)
 N DOW,RORMSG
"RTN","RORUTL01",220,0)
 F  D  Q:$$FIND1^DIC(40.5,,"QX",DATE,"B",,"RORMSG")'>0
"RTN","RORUTL01",221,0)
 . S DOW=$$DOW^XLFDT(DATE,1)  S:'DOW DOW=7
"RTN","RORUTL01",222,0)
 . ;--- Get the next day and skip a weekend if necessary
"RTN","RORUTL01",223,0)
 . S DATE=$$FMADD^XLFDT(DATE,$S(DOW<5:1,1:8-DOW))
"RTN","RORUTL01",224,0)
 Q DATE
"RTN","RORUTL01",225,0)
 ;
"RTN","RORUTL01",226,0)
 ;***** CREATES A HEADER OF THE NODE IN THE ^XTMP GLOBAL
"RTN","RORUTL01",227,0)
 ;
"RTN","RORUTL01",228,0)
 ; SUBSCR        Subscript of the node in the ^XTMP global
"RTN","RORUTL01",229,0)
 ; [DKEEP]       Number of days to keep the node (1 by default)
"RTN","RORUTL01",230,0)
 ; [DESCR]       Description of the node
"RTN","RORUTL01",231,0)
 ;
"RTN","RORUTL01",232,0)
XTMPHDR(SUBSCR,DKEEP,DESCR) ;
"RTN","RORUTL01",233,0)
 N DATE  S DATE=$$DT^XLFDT  S:$G(DKEEP)'>0 DKEEP=1
"RTN","RORUTL01",234,0)
 S ^XTMP(SUBSCR,0)=$$FMADD^XLFDT(DATE,DKEEP)_U_DATE_U_$G(DESCR)
"RTN","RORUTL01",235,0)
 Q
"RTN","RORUTL01",236,0)
 ;
"RTN","RORUTL01",237,0)
 ;***** EMULATES AND EXTENDS THE ZWRITE COMMAND :-)
"RTN","RORUTL01",238,0)
 ;
"RTN","RORUTL01",239,0)
 ; ROR8NODE      Closed root of the sub-tree to display
"RTN","RORUTL01",240,0)
 ;               (either local array or global variable)
"RTN","RORUTL01",241,0)
 ; [TITLE]       Title of the output
"RTN","RORUTL01",242,0)
 ;
"RTN","RORUTL01",243,0)
ZW(ROR8NODE,TITLE) ;
"RTN","RORUTL01",244,0)
 Q:ROR8NODE=""  Q:'$D(@ROR8NODE)
"RTN","RORUTL01",245,0)
 N FLT,L,PI  W !
"RTN","RORUTL01",246,0)
 W:$G(TITLE)'="" TITLE,!!
"RTN","RORUTL01",247,0)
 W:$D(@ROR8NODE)#10 ROR8NODE_"="_@ROR8NODE,!
"RTN","RORUTL01",248,0)
 S L=$L(ROR8NODE)  S:$E(ROR8NODE,L)=")" L=L-1
"RTN","RORUTL01",249,0)
 S FLT=$E(ROR8NODE,1,L),PI=ROR8NODE
"RTN","RORUTL01",250,0)
 F  S PI=$Q(@PI)  Q:$E(PI,1,L)'=FLT  W PI_"="_@PI,!
"RTN","RORUTL01",251,0)
 Q
"RTN","RORUTL02")
0^68^B33272685
"RTN","RORUTL02",1,0)
RORUTL02 ;HCIOFO/SG - UTILITIES  ; 4/29/02 11:11am
"RTN","RORUTL02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUTL02",3,0)
 ;
"RTN","RORUTL02",4,0)
 ; This routine uses the following IAs:
"RTN","RORUTL02",5,0)
 ;
"RTN","RORUTL02",6,0)
 ; #2701         $$GETICN^MPIF001 Gets ICN (supported)
"RTN","RORUTL02",7,0)
 ; #3556         $$GCPR^LA7QRY
"RTN","RORUTL02",8,0)
 ; #3557         Access to the field .01 and x-ref "B"
"RTN","RORUTL02",9,0)
 ;               of the file 95.3
"RTN","RORUTL02",10,0)
 ; #10035        Access to the field #.09 of the file #2
"RTN","RORUTL02",11,0)
 ;
"RTN","RORUTL02",12,0)
 Q
"RTN","RORUTL02",13,0)
 ;
"RTN","RORUTL02",14,0)
 ;***** CREATES A LIST OF ACTIVE REGISTRIES
"RTN","RORUTL02",15,0)
 ;
"RTN","RORUTL02",16,0)
 ; .SRCLST       A source list of registry names (as subscripts)
"RTN","RORUTL02",17,0)
 ; .DSTLST(      A list of names and IENs of active registries
"RTN","RORUTL02",18,0)
 ;   RegName)    Registry IEN
"RTN","RORUTL02",19,0)
 ;
"RTN","RORUTL02",20,0)
 ; Return values:
"RTN","RORUTL02",21,0)
 ;       <0  Error code
"RTN","RORUTL02",22,0)
 ;        0  Ok
"RTN","RORUTL02",23,0)
 ;
"RTN","RORUTL02",24,0)
 ; The function stores names and IENs of those registries from the
"RTN","RORUTL02",25,0)
 ; source list which are active and not awaiting acknowledgements
"RTN","RORUTL02",26,0)
 ; into a local variable passed as the second parameter.
"RTN","RORUTL02",27,0)
 ;
"RTN","RORUTL02",28,0)
 ; Moreover, it records corresponding messages about skipped
"RTN","RORUTL02",29,0)
 ; registries to the current open log.
"RTN","RORUTL02",30,0)
 ;
"RTN","RORUTL02",31,0)
ARLST(SRCLST,DSTLST) ;
"RTN","RORUTL02",32,0)
 N RC,REGIEN,REGNAME,RORBUF,TMP  K DSTLST
"RTN","RORUTL02",33,0)
 S REGNAME="",RC=0
"RTN","RORUTL02",34,0)
 F  S REGNAME=$O(SRCLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUTL02",35,0)
 . S REGIEN=$$REGIEN(REGNAME,"@;2.2I;11I",.RORBUF)
"RTN","RORUTL02",36,0)
 . I REGIEN'>0  D  Q                        ; Error
"RTN","RORUTL02",37,0)
 . . S RC=$$ERROR^RORERR(REGIEN,"ARLST^RORUTL02",REGNAME)
"RTN","RORUTL02",38,0)
 . I $G(RORBUF("DILIST","ID",1,11))  D  Q   ; Inactive
"RTN","RORUTL02",39,0)
 . . S TMP=$$ERROR^RORERR(-48,,,,REGNAME)
"RTN","RORUTL02",40,0)
 . I $G(RORBUF("DILIST","ID",1,2.2))  D  Q  ; Awaiting ACK
"RTN","RORUTL02",41,0)
 . . S TMP=$$ERROR^RORERR(-49,,,,REGNAME)
"RTN","RORUTL02",42,0)
 . S DSTLST(REGNAME)=REGIEN
"RTN","RORUTL02",43,0)
 Q RC
"RTN","RORUTL02",44,0)
 ;
"RTN","RORUTL02",45,0)
 ;***** RETURNS A FULL ICN OF THE PATIENT
"RTN","RORUTL02",46,0)
 ;
"RTN","RORUTL02",47,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",48,0)
 ;
"RTN","RORUTL02",49,0)
 ; Return Values:
"RTN","RORUTL02",50,0)
 ;       <0  Error code
"RTN","RORUTL02",51,0)
 ;       ""  ICN has not been assigned
"RTN","RORUTL02",52,0)
 ;       >0  Patient ICN
"RTN","RORUTL02",53,0)
 ;
"RTN","RORUTL02",54,0)
ICN(PATIEN) ;
"RTN","RORUTL02",55,0)
 N ICN,L,TMP
"RTN","RORUTL02",56,0)
 S ICN=$$GETICN^MPIF001(PATIEN)
"RTN","RORUTL02",57,0)
 I ICN'>0  D  Q ""
"RTN","RORUTL02",58,0)
 . S TMP=$$ERROR^RORERR(-57,"ICN^RORUTL02",$P(ICN,U,2),PATIEN,+ICN,"$$GETICN^MPIF001")
"RTN","RORUTL02",59,0)
 ;--- Validate the checksum (just in case ;-)
"RTN","RORUTL02",60,0)
 S L=$L($P(ICN,"V",2))
"RTN","RORUTL02",61,0)
 Q $S(L<6:$P(ICN,"V")_"V"_$E("000000",1,6-L)_$P(ICN,"V",2),1:ICN)
"RTN","RORUTL02",62,0)
 ;
"RTN","RORUTL02",63,0)
 ;I L<6  D  Q $P(ICN,"V")_"V"_$E("000000",1,6-L)_$P(ICN,"V",2)
"RTN","RORUTL02",64,0)
 ;. S TMP=$$ERROR^RORERR(-59,"ICN^RORUTL02",,PATIEN)
"RTN","RORUTL02",65,0)
 ;Q ICN
"RTN","RORUTL02",66,0)
 ;
"RTN","RORUTL02",67,0)
 ;***** LOADS THE LAB RESULTS
"RTN","RORUTL02",68,0)
 ;
"RTN","RORUTL02",69,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",70,0)
 ; SDT           Start date of the results
"RTN","RORUTL02",71,0)
 ; EDT           End date of the results
"RTN","RORUTL02",72,0)
 ;
"RTN","RORUTL02",73,0)
 ; Return values:
"RTN","RORUTL02",74,0)
 ;       <0  Error code
"RTN","RORUTL02",75,0)
 ;        0  Ok
"RTN","RORUTL02",76,0)
 ;
"RTN","RORUTL02",77,0)
 ; The function loads Lab results into the ^TMP("RORTMP",$J).
"RTN","RORUTL02",78,0)
 ;
"RTN","RORUTL02",79,0)
LABRSLTS(PATIEN,SDT,EDT) ;
"RTN","RORUTL02",80,0)
 N DST,H7CH,RC,RORMSG,TMP
"RTN","RORUTL02",81,0)
 S DST=$NA(^TMP("RORTMP",$J))  K @DST
"RTN","RORUTL02",82,0)
 Q:$D(RORLRC)<10 0
"RTN","RORUTL02",83,0)
 ;--- Get the Patient ID (ICN or SSN)
"RTN","RORUTL02",84,0)
 S PTID=$$PTID(PATIEN)  Q:PTID<0 PTID
"RTN","RORUTL02",85,0)
 ;--- Get the Lab data
"RTN","RORUTL02",86,0)
 S H7CH=$G(RORHL("FS"))_$G(RORHL("ECH"))
"RTN","RORUTL02",87,0)
 S RC=$$GCPR^LA7QRY(PTID,SDT,EDT,.RORLRC,"*",.RORMSG,DST,H7CH)
"RTN","RORUTL02",88,0)
 I $D(RORMSG)>1  D
"RTN","RORUTL02",89,0)
 . N ERR,I,LST
"RTN","RORUTL02",90,0)
 . S (ERR,LST)=""
"RTN","RORUTL02",91,0)
 . F I=1:1  S ERR=$O(RORMSG(ERR))  Q:ERR=""  D
"RTN","RORUTL02",92,0)
 . . S LST=LST_","_ERR,TMP=RORMSG(ERR)
"RTN","RORUTL02",93,0)
 . . K RORMSG(ERR)  S RORMSG(I)=TMP
"RTN","RORUTL02",94,0)
 . S LST=$P(LST,",",2,999)  Q:(LST=3)!(LST=99)
"RTN","RORUTL02",95,0)
 . S RC=$$ERROR^RORERR(-27,"LABRSLTS^RORUTL02",.RORMSG,PATIEN)
"RTN","RORUTL02",96,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL02",97,0)
 ;
"RTN","RORUTL02",98,0)
 ;***** RETURNS THE LOINC CODE WITH THE CONTROL DIGIT
"RTN","RORUTL02",99,0)
 ;
"RTN","RORUTL02",100,0)
 ; LNCODE        LOINC code
"RTN","RORUTL02",101,0)
 ;
"RTN","RORUTL02",102,0)
 ; Besides adding a control digit to the LOINC code, the function
"RTN","RORUTL02",103,0)
 ; checks the code against the LAB LOINC file (#95.3).
"RTN","RORUTL02",104,0)
 ;
"RTN","RORUTL02",105,0)
 ; Return values:
"RTN","RORUTL02",106,0)
 ;       <0  Error code
"RTN","RORUTL02",107,0)
 ;       >0  LOINC code with the control digit
"RTN","RORUTL02",108,0)
 ;
"RTN","RORUTL02",109,0)
LNCODE(LNCODE) ;
"RTN","RORUTL02",110,0)
 N RC,RORBUF,RORMSG
"RTN","RORUTL02",111,0)
 D FIND^DIC(95.3,,"@;.01E","X",$P(LNCODE,"-"),2,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL02",112,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"LNCODE^RORUTL02",,95.3)
"RTN","RORUTL02",113,0)
 I $G(RORBUF("DILIST",0))<1  D  Q RC ; Non-existent code
"RTN","RORUTL02",114,0)
 . S RC=$$ERROR^RORERR(-29,"LNCODE^RORUTL02",,,LNCODE)
"RTN","RORUTL02",115,0)
 I $G(RORBUF("DILIST",0))>1  D  Q RC ; Duplicate records
"RTN","RORUTL02",116,0)
 . S RC=$$ERROR^RORERR(-30,"LNCODE^RORUTL02",,,LNCODE)
"RTN","RORUTL02",117,0)
 Q RORBUF("DILIST","ID",1,.01)
"RTN","RORUTL02",118,0)
 ;
"RTN","RORUTL02",119,0)
 ;***** LOCK/UNLOCK REGISTRIES BEING PROCESSED
"RTN","RORUTL02",120,0)
 ;
"RTN","RORUTL02",121,0)
 ; .REGLST       Reference to a local array containing registry names 
"RTN","RORUTL02",122,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUTL02",123,0)
 ; [MODE]        0 - Unlock (default), 1 - Lock
"RTN","RORUTL02",124,0)
 ; [TO]          LOCK timeout (3 sec by defualt)
"RTN","RORUTL02",125,0)
 ;
"RTN","RORUTL02",126,0)
 ; Return Values:
"RTN","RORUTL02",127,0)
 ;       <0  Error code
"RTN","RORUTL02",128,0)
 ;        0  Some of the registries has been locked by another job
"RTN","RORUTL02",129,0)
 ;        1  Ok
"RTN","RORUTL02",130,0)
 ;
"RTN","RORUTL02",131,0)
LOCKREG(REGLST,MODE,TO) ;
"RTN","RORUTL02",132,0)
 Q:$D(REGLST)<10 1
"RTN","RORUTL02",133,0)
 N ARG,LOCKLST,LT,REGIEN,REGNAME
"RTN","RORUTL02",134,0)
 S (REGNAME,LOCKLST)=""
"RTN","RORUTL02",135,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:REGIEN<0
"RTN","RORUTL02",136,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUTL02",137,0)
 . I REGIEN'>0  S REGIEN=$$REGIEN^RORUTL02(REGNAME)  Q:REGIEN'>0
"RTN","RORUTL02",138,0)
 . S LOCKLST=LOCKLST_","_$NA(^ROR(798.1,REGIEN))
"RTN","RORUTL02",139,0)
 Q:$G(REGIEN)<0 REGIEN
"RTN","RORUTL02",140,0)
 Q:LOCKLST="" 1
"RTN","RORUTL02",141,0)
 S ARG=$S($G(MODE):"+",1:"-")_"("_$P(LOCKLST,",",2,999)_")"
"RTN","RORUTL02",142,0)
 X "L "_ARG_":"_+$G(TO,3)_"  S LT=$T"
"RTN","RORUTL02",143,0)
 Q LT
"RTN","RORUTL02",144,0)
 ;
"RTN","RORUTL02",145,0)
 ;***** RETURNS A PATIENT ID (ICN OR SSN)
"RTN","RORUTL02",146,0)
 ;
"RTN","RORUTL02",147,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",148,0)
 ;
"RTN","RORUTL02",149,0)
 ; Return Values:
"RTN","RORUTL02",150,0)
 ;       <0  Error code
"RTN","RORUTL02",151,0)
 ;       ""  Neither ICN nor SSN has been assigned
"RTN","RORUTL02",152,0)
 ;       >0  Patient ICN (or SSN if ICN is not available)
"RTN","RORUTL02",153,0)
 ;
"RTN","RORUTL02",154,0)
PTID(PATIEN) ;
"RTN","RORUTL02",155,0)
 N L,PTID,RC,RORMSG
"RTN","RORUTL02",156,0)
 S PTID=$$GETICN^MPIF001(PATIEN)
"RTN","RORUTL02",157,0)
 I PTID>0  D  Q PTID
"RTN","RORUTL02",158,0)
 . ;--- Validate the checksum (just in case ;-)
"RTN","RORUTL02",159,0)
 . S L=$L($P(PTID,"V",2))  Q:L'<6
"RTN","RORUTL02",160,0)
 . ;S RC=$$ERROR^RORERR(-59,"PTID^RORUTL02",,PATIEN)
"RTN","RORUTL02",161,0)
 . S $P(PTID,"V",2)=$E("000000",1,6-L)_$P(PTID,"V",2)
"RTN","RORUTL02",162,0)
 ;--- Get SSN if ICN is not available
"RTN","RORUTL02",163,0)
 S PTID=$$GET1^DIQ(2,PATIEN_",",.09,,,"RORMSG")
"RTN","RORUTL02",164,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"PTID^RORUTL02",PATIEN,2)
"RTN","RORUTL02",165,0)
 Q PTID
"RTN","RORUTL02",166,0)
 ;
"RTN","RORUTL02",167,0)
 ;***** RETURNS IEN OF THE REGISTRY PARAMETERS
"RTN","RORUTL02",168,0)
 ;
"RTN","RORUTL02",169,0)
 ; REGNAME       Name of the registry
"RTN","RORUTL02",170,0)
 ; [FIELDS]      List of fields (separated by semicolons) to load
"RTN","RORUTL02",171,0)
 ; [.RORTRGT]    Reference to a local variable where field values will
"RTN","RORUTL02",172,0)
 ;               be stored by the FIND^DIC call
"RTN","RORUTL02",173,0)
 ;
"RTN","RORUTL02",174,0)
 ; Return Values:
"RTN","RORUTL02",175,0)
 ;       <0  Error code
"RTN","RORUTL02",176,0)
 ;       >0  Registry parameters IEN
"RTN","RORUTL02",177,0)
 ;
"RTN","RORUTL02",178,0)
REGIEN(REGNAME,FIELDS,RORTRGT) ;
"RTN","RORUTL02",179,0)
 N RC,REGIEN,RORMSG  K RORTRGT
"RTN","RORUTL02",180,0)
 D FIND^DIC(798.1,,"@;"_$G(FIELDS),"X",REGNAME,2,"B",,,"RORTRGT","RORMSG")
"RTN","RORUTL02",181,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"REGIEN^RORUTL02",,798.1)
"RTN","RORUTL02",182,0)
 S RC=+$G(RORTRGT("DILIST",0))
"RTN","RORUTL02",183,0)
 Q $S(RC<1:-1,RC>1:-2,1:+RORTRGT("DILIST",2,1))
"RTN","RORUTL02",184,0)
 ;
"RTN","RORUTL02",185,0)
 ;***** RETURNS NUMBER OF RECORDS IN THE REGISTRY
"RTN","RORUTL02",186,0)
 ;
"RTN","RORUTL02",187,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL02",188,0)
 ; [.LOWIEN]     The smallest IEN will be returned via this parameter
"RTN","RORUTL02",189,0)
 ; [.HIGHIEN]    The biggest IEN will be returned via this parameter
"RTN","RORUTL02",190,0)
 ;
"RTN","RORUTL02",191,0)
 ; Return Values:
"RTN","RORUTL02",192,0)
 ;       <0  Error code
"RTN","RORUTL02",193,0)
 ;        0  The registry is empty
"RTN","RORUTL02",194,0)
 ;       >0  Number of records in the registry
"RTN","RORUTL02",195,0)
 ;
"RTN","RORUTL02",196,0)
REGSIZE(REGIEN,LOWIEN,HIGHIEN) ;
"RTN","RORUTL02",197,0)
 N I,NODE,NRE,RC,RORFDA,RORMSG
"RTN","RORUTL02",198,0)
 S NODE=$NA(^RORDATA(798,"AC",REGIEN))
"RTN","RORUTL02",199,0)
 S LOWIEN=$O(@NODE@(""))
"RTN","RORUTL02",200,0)
 S HIGHIEN=$O(@NODE@(""),-1)
"RTN","RORUTL02",201,0)
 ;--- Get number of records from the parameters
"RTN","RORUTL02",202,0)
 S NRE=$$GET1^DIQ(798.1,REGIEN_",",19.1,,,"RORMSG")
"RTN","RORUTL02",203,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"REGSIZE^RORUTL02",,798.1,REGIEN)
"RTN","RORUTL02",204,0)
 Q:NRE>0 NRE
"RTN","RORUTL02",205,0)
 ;--- Count the records of the registry
"RTN","RORUTL02",206,0)
 S I="",NRE=0
"RTN","RORUTL02",207,0)
 F  S I=$O(@NODE@(I))  Q:I=""  S NRE=NRE+1
"RTN","RORUTL02",208,0)
 ;--- Store the value in the parameters
"RTN","RORUTL02",209,0)
 S RORFDA(798.1,REGIEN_",",19.1)=NRE
"RTN","RORUTL02",210,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUTL02",211,0)
 Q NRE
"RTN","RORUTL02",212,0)
 ;
"RTN","RORUTL02",213,0)
 ;***** RETURNS IEN OF THE SELECTION RULE
"RTN","RORUTL02",214,0)
 ;
"RTN","RORUTL02",215,0)
 ; RULENAME      Name of the selection rule
"RTN","RORUTL02",216,0)
 ; [FIELDS]      List of fields (separated by semicolons) to load
"RTN","RORUTL02",217,0)
 ; [.RORTRGT]    Reference to a local variable where field values will
"RTN","RORUTL02",218,0)
 ;               be stored by the FIND^DIC call.
"RTN","RORUTL02",219,0)
 ;
"RTN","RORUTL02",220,0)
 ; Return Values:
"RTN","RORUTL02",221,0)
 ;       <0  Error code
"RTN","RORUTL02",222,0)
 ;       >0  Selection rule IEN
"RTN","RORUTL02",223,0)
 ;
"RTN","RORUTL02",224,0)
SRLIEN(RULENAME,FIELDS,RORTRGT) ;
"RTN","RORUTL02",225,0)
 N RC,RULEIEN,RORMSG  K RORTRGT
"RTN","RORUTL02",226,0)
 D FIND^DIC(798.2,,"@;"_$G(FIELDS),"X",RULENAME,2,"B",,,"RORTRGT","RORMSG")
"RTN","RORUTL02",227,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"SRLIEN^RORUTL02",,798.2)
"RTN","RORUTL02",228,0)
 S RC=+$G(RORTRGT("DILIST",0))
"RTN","RORUTL02",229,0)
 Q $S(RC<1:-3,RC>1:-4,1:+RORTRGT("DILIST",2,1))
"RTN","RORUTL03")
0^69^B16590829
"RTN","RORUTL03",1,0)
RORUTL03 ;HOIFO/CRT - Encryption/Decryption ;09/21/99  11:35
"RTN","RORUTL03",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUTL03",3,0)
 ;
"RTN","RORUTL03",4,0)
 Q
"RTN","RORUTL03",5,0)
 ;
"RTN","RORUTL03",6,0)
SITE1(CS) ; Return Default Site, for HL7 messages
"RTN","RORUTL03",7,0)
 ;
"RTN","RORUTL03",8,0)
 N RORSITE
"RTN","RORUTL03",9,0)
 ;
"RTN","RORUTL03",10,0)
 S CS=$S($G(CS)="":"^",1:CS)
"RTN","RORUTL03",11,0)
 ;
"RTN","RORUTL03",12,0)
 S RORSITE=$$SITE^VASITE
"RTN","RORUTL03",13,0)
 Q $P(RORSITE,"^",2)_CS_"99VA4"_CS_$P(RORSITE,"^",3)
"RTN","RORUTL03",14,0)
 ;
"RTN","RORUTL03",15,0)
SITE(CS) ;
"RTN","RORUTL03",16,0)
 ;
"RTN","RORUTL03",17,0)
 S CS=$S($G(CS)="":"^",1:CS)
"RTN","RORUTL03",18,0)
 S RORSITE=$$SITE^VASITE
"RTN","RORUTL03",19,0)
 Q $P(RORSITE,"^")_CS_$P(RORSITE,"^",2)_CS_"99VA4"
"RTN","RORUTL03",20,0)
 ;
"RTN","RORUTL03",21,0)
DECRYPT(S) ;decrypt passed string
"RTN","RORUTL03",22,0)
 ;
"RTN","RORUTL03",23,0)
 N ASSOCIX,IDIX,ASSOCSTR,IDSTR
"RTN","RORUTL03",24,0)
 ;
"RTN","RORUTL03",25,0)
 S ASSOCIX=$A($E(S,$L(S)))-31
"RTN","RORUTL03",26,0)
 S IDIX=$A($E(S))-31
"RTN","RORUTL03",27,0)
 ;
"RTN","RORUTL03",28,0)
 S ASSOCSTR=$P($T(Z+ASSOCIX),";",3,9)
"RTN","RORUTL03",29,0)
 S IDSTR=$P($T(Z+IDIX),";",3,9)
"RTN","RORUTL03",30,0)
 ;
"RTN","RORUTL03",31,0)
 Q $TR($E(S,2,$L(S)-1),ASSOCSTR,IDSTR)
"RTN","RORUTL03",32,0)
 ;
"RTN","RORUTL03",33,0)
ENCRYPT(S) ;encrypt passed string
"RTN","RORUTL03",34,0)
 ;
"RTN","RORUTL03",35,0)
 N %,ASSOCIX,IDIX,ASSOCSTR,IDSTR
"RTN","RORUTL03",36,0)
 ;
"RTN","RORUTL03",37,0)
 S ASSOCIX=$R(20)+1
"RTN","RORUTL03",38,0)
 F  S IDIX=$R(20)+1 Q:ASSOCIX'=IDIX
"RTN","RORUTL03",39,0)
 ;
"RTN","RORUTL03",40,0)
 S ASSOCSTR=$P($T(Z+ASSOCIX),";",3,9)
"RTN","RORUTL03",41,0)
 S IDSTR=$P($T(Z+IDIX),";",3,9)
"RTN","RORUTL03",42,0)
 ;
"RTN","RORUTL03",43,0)
 Q $C(IDIX+31)_$TR(S,IDSTR,ASSOCSTR)_$C(ASSOCIX+31)
"RTN","RORUTL03",44,0)
 ;
"RTN","RORUTL03",45,0)
Z ;;
"RTN","RORUTL03",46,0)
 ;;ko-ZJtdG)49K{nX1BS$vH<:Myf*>Ae0!jQW=;#PwsO`E'%+rmb[gpqN,l6/hFC@DcUa ]zR}"ViIxu?872.(TYL5_3
"RTN","RORUTL03",47,0)
 ;;`R;M/9BqAF%tSs#Vh)dO1DZP>r *fX'u[.4KlY=-mg_ci802N7LTG<]!CWo:3?{v+,5Q}(@jaExn$pIyHwzU"k6Jeb
"RTN","RORUTL03",48,0)
 ;;ZJk"WQmCn!Y,y@1d+8s?[lNMxgHE(t=uwX:qSLjAI*}6zoF{T3#;cap)/h5%`P4$r]G'9e2if_>UDKb7V<v0- RBO.
"RTN","RORUTL03",49,0)
 ;;dpjt3g4W)qD0VNJarseB "?OYhcu[<M%Z`RIL_6:]AX-zG.#}$@vk7/5x*m;(yb2Fn+l'PwUof1K{9,EQi>H=CT8S!
"RTN","RORUTL03",50,0)
 ;;:1}K$byP;jk)7'`x90Bcq@iSsEnu,(Nl-hf.Y_?J#R]+voQXZU8mrV[!p4tgOWMez CAaGFD6H53%L/dT2<*>"{wI=
"RTN","RORUTL03",51,0)
 ;;J<oZ9phXVNn)m K`t/SI%]A5qOWe?;jTM!fz1l>[D_0xR32ic*4.P"G{r7}E8wvUgyudF+6-:B=$(sCY,LkbHa#'@Q
"RTN","RORUTL03",52,0)
 ;;X,'4Ty;[a8/{6lF_V"}qLI!@x(D7bRmUHh]W15J%N0BYPkrs9:$)Zj>uvzwQ=ieC-oGA.#?tfdcOM3gp`S+En K2*<
"RTN","RORUTL03",53,0)
 ;;W5[];4'<C$/xrZ(k{>?ghBzIFN}fAK"#`p_T!qtD*1E37XGVs@0nmdjSe+Y6Qyo-aUu%i8c=H2vJ) R:MLb.9,wlOP
"RTN","RORUTL03",54,0)
 ;;tjEM+!=xXb)7,ZV{*ci3"8@_l-HS69L>2]AUF/Q%:qD?1m(yvO0e'hT<#o$p4dnIzKP`NrkaGg.ufCRB[; sJYwW}5
"RTN","RORUTL03",55,0)
 ;;/zl-9y:Pj=(R'7QJI *CTX"p0]_3.idcuOBefVU#omwNZ`$vFs?L+1Sk<5,b)hM4A6[Y%aDrg@KqEW8t>H};n!2xG{
"RTN","RORUTL03",56,0)
 ;;0Bo@_HfnK>LR}qWXV+D6`Y28=4CmsG/7-5Ab9!a#rPF.lM$hc3ijQk;),TvzUd<[:I"u1'NZSOw]*gxtE{eJpy (?%
"RTN","RORUTL03",57,0)
 ;;D}LJyGO8`$*ZqH .j>cMh<d=fimszv[#-53F!+a;NC'6T91IV?(0@x/{B)w"]QY,UWprk4:ol%g2nE7teRKbAPuS_X
"RTN","RORUTL03",58,0)
 ;;Y#_0*H<B=Q+FML6]s;r2:e8R}[icKA 1w{)vV5d,.$u"xD/Pg?IyfthO@CzjWp%!`N4Z'3-(oJ9XUE7kTlqSb>anGm
"RTN","RORUTL03",59,0)
 ;;1']_GU<X`NgM?LS9{"jT%s$}y[nvtlefB2RKJW(/cIxDCPow4,>#zm+:5b@06O3Ap8=V*7ZFY!H-uEQk;a .q)irhd
"RTN","RORUTL03",60,0)
 ;;z7AG@QX."%3Lq>METUo{Pp_ a6<0dYVSv8:bI)W9NK`(r'4fswimkRe]C2hg=HOj$1B*/nxt,;cJ#y+![?lFuZ-5D}
"RTN","RORUTL03",61,0)
 ;;Ge6F Hx>q$mC%MTn,:"o'tX/*yP.{lZ!YkiVhuw_<KE5aR[;}W0gjsz3]@7cI2QN?f#4pvbr1OUBD9)=-L(JA+d`S8
"RTN","RORUTL03",62,0)
 ;;>ym};d)-7DZ"Fe/Y<B:xwojR,Vh]O0Sc[`$sg8GXE!I1Qrzp._W%TNKk(=J 3i*2abuHA4C'?MvPq{n#56LftUl@9+
"RTN","RORUTL03",63,0)
 ;;)9 WidFN,1KsmwQ>GJM{I4:C%}#Ep(?HB/r;t.U8ol['Lg"2hRDyZ5`nbf]qjc0!zS-TkYO<_=76a*X@$Pe3+AxVvu
"RTN","RORUTL03",64,0)
 ;;jf"5VdHc#uA,W1i+v'6@pr{n;DJ!8(btPGaQM.LT3oeg?NB/9>Z`-}02*%x<7Ylsqz4OS E$R]KI[:UwC_=h)kXmyF
"RTN","RORUTL03",65,0)
 ;;ar.{YU7mBZR@-K2 "+`M%8sq4JhPo<_XSg3WC;Tuxz,fvEiQ1p9=w}FAIj/keD0c?)LN6OHV]lG:5y'$*>nd[(tb!#
"RTN","RORUTL04")
0^70^B5896522
"RTN","RORUTL04",1,0)
RORUTL04 ;HCIOFO/BH - Registry Stat Report ; 1/16/02 12:30pm
"RTN","RORUTL04",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUTL04",3,0)
 ;
"RTN","RORUTL04",4,0)
EN1 D COMP
"RTN","RORUTL04",5,0)
 D DISPLAY
"RTN","RORUTL04",6,0)
 Q 
"RTN","RORUTL04",7,0)
 ;
"RTN","RORUTL04",8,0)
COMP N K2,K4,PATIEN,DATE,TMP,CODE,RULE
"RTN","RORUTL04",9,0)
 ;
"RTN","RORUTL04",10,0)
 K ^TMP("ROR STAT REPORT")
"RTN","RORUTL04",11,0)
 S K2=0
"RTN","RORUTL04",12,0)
 F  S K2=$O(^RORDATA(798,K2)) Q:'K2  D
"RTN","RORUTL04",13,0)
 . S PATIEN=$P(^RORDATA(798,K2,0),"^",1)
"RTN","RORUTL04",14,0)
 . S K4=0,CNT=0 K TMP
"RTN","RORUTL04",15,0)
 . F  S K4=$O(^RORDATA(798,K2,1,K4)) Q:'K4  D
"RTN","RORUTL04",16,0)
 . . S CNT=CNT+1
"RTN","RORUTL04",17,0)
 . . S DATE=$P(^RORDATA(798,K2,1,K4,0),"^",2)
"RTN","RORUTL04",18,0)
 . . S CODE=$P(^RORDATA(798,K2,1,K4,0),"^",1)
"RTN","RORUTL04",19,0)
 . . S TMP(DATE)=CODE
"RTN","RORUTL04",20,0)
 . I CNT<1 Q   ;  No selection rules
"RTN","RORUTL04",21,0)
 . S K1=""
"RTN","RORUTL04",22,0)
 . S K1=$O(TMP(K1))
"RTN","RORUTL04",23,0)
 . S RULE=$$GETRULE(.TMP,CNT,K1)
"RTN","RORUTL04",24,0)
 . S ^TMP("ROR STAT REPORT",RULE,K1,PATIEN)=""
"RTN","RORUTL04",25,0)
 Q
"RTN","RORUTL04",26,0)
 ;
"RTN","RORUTL04",27,0)
GETRULE(TMP,CNT,K1) ;
"RTN","RORUTL04",28,0)
 N MARKER,KK1,RULE1,RESULT
"RTN","RORUTL04",29,0)
 I CNT=1 D  Q RESULT
"RTN","RORUTL04",30,0)
 . S RULE1=TMP(K1)
"RTN","RORUTL04",31,0)
 . I RULE1=8 S RESULT="Only_Lab"
"RTN","RORUTL04",32,0)
 . I RULE1'=8 S RESULT="Only_ICD9"
"RTN","RORUTL04",33,0)
 ;
"RTN","RORUTL04",34,0)
 S KK1="",MARKER=0
"RTN","RORUTL04",35,0)
 F  S KK1=$O(TMP(KK1)) Q:'KK1  D
"RTN","RORUTL04",36,0)
 . I TMP(KK1)=8 S MARKER=1
"RTN","RORUTL04",37,0)
 S SEL=TMP(K1)
"RTN","RORUTL04",38,0)
 I MARKER,SEL=8 Q "BOTHL"
"RTN","RORUTL04",39,0)
 I MARKER,SEL'=8 Q "BOTHI"
"RTN","RORUTL04",40,0)
 Q "All_ICD9"
"RTN","RORUTL04",41,0)
 ;
"RTN","RORUTL04",42,0)
DISPLAY ;
"RTN","RORUTL04",43,0)
 N STRING,I,RES
"RTN","RORUTL04",44,0)
 S STRING="Only_Lab^Only_ICD9^BOTHI^BOTHL^All_ICD9"
"RTN","RORUTL04",45,0)
 F I=1:1:5 D
"RTN","RORUTL04",46,0)
 . S RES=$P(STRING,"^",I)
"RTN","RORUTL04",47,0)
 . D LOOP(RES)
"RTN","RORUTL04",48,0)
 Q
"RTN","RORUTL04",49,0)
 ;
"RTN","RORUTL04",50,0)
LOOP(RES) ;
"RTN","RORUTL04",51,0)
 N NAME,SSN,LABEL,DATE,IEN
"RTN","RORUTL04",52,0)
 S LABEL=RES
"RTN","RORUTL04",53,0)
 I $E(LABEL,1,4)="BOTH" D
"RTN","RORUTL04",54,0)
 . I $E(LABEL,5,5)="I" S LABEL="Both_ICD9_&_Lab.  ICD9_was_Earliest."
"RTN","RORUTL04",55,0)
 . I $E(LABEL,5,5)="L" S LABEL="Both_ICD9_&_Lab.  Lab_was_Earliest."
"RTN","RORUTL04",56,0)
 W !,"Reason_Added. "_LABEL,!
"RTN","RORUTL04",57,0)
 ;
"RTN","RORUTL04",58,0)
 S DATE=""
"RTN","RORUTL04",59,0)
 I $O(^TMP("ROR STAT REPORT",RES,DATE))="" W "No_data_to_display.",!
"RTN","RORUTL04",60,0)
 F  S DATE=$O(^TMP("ROR STAT REPORT",RES,DATE)) Q:'DATE  D
"RTN","RORUTL04",61,0)
 . S IEN=""
"RTN","RORUTL04",62,0)
 . F  S IEN=$O(^TMP("ROR STAT REPORT",RES,DATE,IEN)) Q:'IEN  D
"RTN","RORUTL04",63,0)
 . . S NAME=$P(^DPT(IEN,0),"^",1)
"RTN","RORUTL04",64,0)
 . . S NAME=$TR(NAME," ","_")
"RTN","RORUTL04",65,0)
 . . S SSN=$P(^DPT(IEN,0),"^",9)
"RTN","RORUTL04",66,0)
 . . W NAME_"  "_SSN_"  "_$E(DATE,4,5)_"/"_$E(DATE,6,7)_"/"_$E(DATE,2,3),!
"RTN","RORUTL04",67,0)
 ;
"RTN","RORUTL04",68,0)
 ;
"RTN","RORUTL05")
0^71^B32076010
"RTN","RORUTL05",1,0)
RORUTL05 ;HCIOFO/SG - MISCELLANEOUS UTILITIES ; 5/15/02 8:20am
"RTN","RORUTL05",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUTL05",3,0)
 ;
"RTN","RORUTL05",4,0)
 Q
"RTN","RORUTL05",5,0)
 ;
"RTN","RORUTL05",6,0)
 ;***** DELETES ALL RECORDS FROM THE (SUB)FILE
"RTN","RORUTL05",7,0)
 ;
"RTN","RORUTL05",8,0)
 ; FILE          File/Subfile number
"RTN","RORUTL05",9,0)
 ; [IENS]        IENS of the subfile
"RTN","RORUTL05",10,0)
 ;
"RTN","RORUTL05",11,0)
 ; Return Values:
"RTN","RORUTL05",12,0)
 ;       <0  Error code
"RTN","RORUTL05",13,0)
 ;        0  Ok
"RTN","RORUTL05",14,0)
 ;
"RTN","RORUTL05",15,0)
CLEAR(FILE,IENS) ;
"RTN","RORUTL05",16,0)
 N IEN,RC,ROOT,RORFDA,RORMSG
"RTN","RORUTL05",17,0)
 S ROOT=$$ROOT^DILFD(FILE,$G(IENS),1)
"RTN","RORUTL05",18,0)
 S:$G(IENS)="" IENS=","
"RTN","RORUTL05",19,0)
 ;--- Delete the records
"RTN","RORUTL05",20,0)
 S (IEN,RC)=0
"RTN","RORUTL05",21,0)
 F  S IEN=$O(@ROOT@(IEN))  Q:'IEN  D  Q:RC<0
"RTN","RORUTL05",22,0)
 . S RORFDA(FILE,IEN_IENS,.01)="@"
"RTN","RORUTL05",23,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL05",24,0)
 . I $G(DIERR)  D  Q
"RTN","RORUTL05",25,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"CLEAR^RORUTL05",,FILE,IEN_IENS)
"RTN","RORUTL05",26,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL05",27,0)
 ;
"RTN","RORUTL05",28,0)
 ;***** CLEARS EXPIRED 'AWAITING ACKNOWLEDGEMENT' FLAGS
"RTN","RORUTL05",29,0)
 ;
"RTN","RORUTL05",30,0)
 ; .REGLST       Reference to a local array containing
"RTN","RORUTL05",31,0)
 ;               registry names as subscripts
"RTN","RORUTL05",32,0)
 ;
"RTN","RORUTL05",33,0)
CLRACK(REGLST) ;
"RTN","RORUTL05",34,0)
 N AWD,EXPDT,IENS,NOW,RC,REGIEN,REGNAME
"RTN","RORUTL05",35,0)
 N RORBUF,RORFDA,RORINFO,RORMSG,TMP
"RTN","RORUTL05",36,0)
 S NOW=$$NOW^XLFDT
"RTN","RORUTL05",37,0)
 ;---
"RTN","RORUTL05",38,0)
 S REGNAME="",RORINFO=0
"RTN","RORUTL05",39,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D
"RTN","RORUTL05",40,0)
 . K RORBUF,RORFDA,RORMSG
"RTN","RORUTL05",41,0)
 . ;--- Get the registry IEN and parameters
"RTN","RORUTL05",42,0)
 . S REGIEN=$$REGIEN^RORUTL02(REGNAME,"2.2I;2.3I;15.9I",.RORBUF)
"RTN","RORUTL05",43,0)
 . Q:REGIEN'>0  Q:'$G(RORBUF("DILIST","ID",1,2.2))
"RTN","RORUTL05",44,0)
 . ;--- Check the expiration date/time
"RTN","RORUTL05",45,0)
 . S AWD=$G(RORBUF("DILIST","ID",1,15.9))
"RTN","RORUTL05",46,0)
 . S:(AWD="")!(AWD<0) AWD=3
"RTN","RORUTL05",47,0)
 . S EXPDT=$$FMADD^XLFDT(RORBUF("DILIST","ID",1,2.2),AWD)
"RTN","RORUTL05",48,0)
 . Q:EXPDT>NOW
"RTN","RORUTL05",49,0)
 . ;--- Clear the flag
"RTN","RORUTL05",50,0)
 . S IENS=REGIEN_","
"RTN","RORUTL05",51,0)
 . S RORFDA(798.1,IENS,2.2)="@" ; AWAITING ACKNOWLEDGEMENT
"RTN","RORUTL05",52,0)
 . S RORFDA(798.1,IENS,2.3)="@" ; LAST MESSAGE ID
"RTN","RORUTL05",53,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL05",54,0)
 . I $G(DIERR)  D  Q
"RTN","RORUTL05",55,0)
 . . S TMP=$$DBS^RORERR("RORMSG",-9,"CLRACK^RORUTL05",,798.1,IENS)
"RTN","RORUTL05",56,0)
 . S RORINFO=RORINFO+1,RORINFO(RORINFO)=REGNAME
"RTN","RORUTL05",57,0)
 . ;--- Cancel the previous HL7 message
"RTN","RORUTL05",58,0)
 . S TMP=$G(RORBUF("DILIST","ID",1,2.3))
"RTN","RORUTL05",59,0)
 . S:TMP'="" TMP=$$MSGACT^HLUTIL(TMP,1)
"RTN","RORUTL05",60,0)
 . ;--- Send an alert to the coordinators
"RTN","RORUTL05",61,0)
 . D ALERT^RORUTL01(REGNAME,-67,,,,$S(AWD:"more than "_AWD,1:1))
"RTN","RORUTL05",62,0)
 ;---
"RTN","RORUTL05",63,0)
 I $D(RORINFO)>1  D  D LOG^RORLOG(4,TMP,,.RORINFO)
"RTN","RORUTL05",64,0)
 . S TMP="Expired 'Awaiting Acknowledgement' flag has been cleared."
"RTN","RORUTL05",65,0)
 Q 0
"RTN","RORUTL05",66,0)
 ;
"RTN","RORUTL05",67,0)
 ;***** CLEARS THE FIELDS OF THE RECORDS FOUND BY NAME
"RTN","RORUTL05",68,0)
 ;
"RTN","RORUTL05",69,0)
 ; FILE          File number
"RTN","RORUTL05",70,0)
 ; [IENS]        IENS of the subfile
"RTN","RORUTL05",71,0)
 ; NAME          Name of the record (value of the .01 field)
"RTN","RORUTL05",72,0)
 ; FIELDS        List of field numbers separated by semicolons
"RTN","RORUTL05",73,0)
 ;
"RTN","RORUTL05",74,0)
 ; Return Values:
"RTN","RORUTL05",75,0)
 ;       <0  Error code
"RTN","RORUTL05",76,0)
 ;        0  Ok
"RTN","RORUTL05",77,0)
 ;
"RTN","RORUTL05",78,0)
CLRFLDS(FILE,IENS,NAME,FIELDS) ;
"RTN","RORUTL05",79,0)
 N FLD,I,IEN,IENS1,IS,RC,RORBUF,RORFDA,RORMSG
"RTN","RORUTL05",80,0)
 ;--- Find the record(s)
"RTN","RORUTL05",81,0)
 D FIND^DIC(FILE,$G(IENS),"@","X",NAME,,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL05",82,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"CLRFLDS^RORUTL05",,FILE)  Q:RC<0 RC
"RTN","RORUTL05",83,0)
 S:$G(IENS)="" IENS=","  S FIELDS=$TR(FIELDS," ")
"RTN","RORUTL05",84,0)
 ;--- Delete the record(s)
"RTN","RORUTL05",85,0)
 S IS="",RC=0
"RTN","RORUTL05",86,0)
 F  S IS=$O(RORBUF("DILIST",2,IS))  Q:IS=""  D  Q:RC<0
"RTN","RORUTL05",87,0)
 . S IEN=RORBUF("DILIST",2,IS)  Q:IEN'>0
"RTN","RORUTL05",88,0)
 . S IENS1=IEN_IENS
"RTN","RORUTL05",89,0)
 . F I=1:1  S FLD=$P(FIELDS,";",I)  Q:FLD'>0  D
"RTN","RORUTL05",90,0)
 . . S RORFDA(FILE,IENS1,+FLD)="@"
"RTN","RORUTL05",91,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL05",92,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"CLRFLDS^RORUTL05",,FILE,IENS1)
"RTN","RORUTL05",93,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL05",94,0)
 ;
"RTN","RORUTL05",95,0)
 ;***** RETURNS THE END DATE FOR THE EVENT PURGE
"RTN","RORUTL05",96,0)
EPDATE() ;
"RTN","RORUTL05",97,0)
 N DATE,IR,RC,RORBUF,RORMSG,TMP
"RTN","RORUTL05",98,0)
 D LIST^DIC(798.1,,"@;1I;2I",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL05",99,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"EPDATE^RORUTL05",,798.1)
"RTN","RORUTL05",100,0)
 ;--- Get the oldest date of registry updates
"RTN","RORUTL05",101,0)
 S IR="",DATE=$$DT^XLFDT
"RTN","RORUTL05",102,0)
 F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D
"RTN","RORUTL05",103,0)
 . S TMP=$G(RORBUF("DILIST","ID",IR,1)) ; REGISTRY UPDATED UNTIL
"RTN","RORUTL05",104,0)
 . I TMP>0  S:TMP<DATE DATE=TMP
"RTN","RORUTL05",105,0)
 . ;S TMP=$G(RORBUF("DILIST","ID",IR,2)) ; DATA EXTRACTED UNTIL
"RTN","RORUTL05",106,0)
 . ;I TMP>0  S:TMP<DATE DATE=TMP
"RTN","RORUTL05",107,0)
 ;--- Subtract additional 14 days (just in case)
"RTN","RORUTL05",108,0)
 S DATE=$$FMADD^XLFDT(DATE\1,-14)
"RTN","RORUTL05",109,0)
 ;--- No more than 60 days in the past
"RTN","RORUTL05",110,0)
 S TMP=$$FMADD^XLFDT($$DT^XLFDT,-60)
"RTN","RORUTL05",111,0)
 Q $S(DATE>TMP:DATE,1:TMP)
"RTN","RORUTL05",112,0)
 ;
"RTN","RORUTL05",113,0)
 ;***** MARKS THE REGISTRY RECORDS FOR RESENDING THE LOCAL DATA
"RTN","RORUTL05",114,0)
 ;
"RTN","RORUTL05",115,0)
 ; .REGLST       Reference to a local array containing registry names 
"RTN","RORUTL05",116,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUTL05",117,0)
 ; WD            Number of days to wait before marking the records
"RTN","RORUTL05",118,0)
 ;               for resending the local registry data
"RTN","RORUTL05",119,0)
 ;
"RTN","RORUTL05",120,0)
 ; Return Values:
"RTN","RORUTL05",121,0)
 ;       <0  Error code
"RTN","RORUTL05",122,0)
 ;        0  Ok
"RTN","RORUTL05",123,0)
 ;
"RTN","RORUTL05",124,0)
REMARK(REGLST,WD) ;
"RTN","RORUTL05",125,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL05",126,0)
 ;
"RTN","RORUTL05",127,0)
 N DATE,IEN,IENS,REGIEN,REGNAME,ROOT,RORFDA,RORMSG,TMP
"RTN","RORUTL05",128,0)
 D DFLTLOC^RORERR("REMARK^RORUTL05")
"RTN","RORUTL05",129,0)
 S ROOT=$$ROOT^DILFD(798,,1)
"RTN","RORUTL05",130,0)
 S DATE=$$FMADD^XLFDT($$DT^XLFDT,-WD)
"RTN","RORUTL05",131,0)
 ;--- Process the registries from the list
"RTN","RORUTL05",132,0)
 S REGNAME=""
"RTN","RORUTL05",133,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D
"RTN","RORUTL05",134,0)
 . S REGIEN=+REGLST(REGNAME)
"RTN","RORUTL05",135,0)
 . I REGIEN'>0  S REGIEN=$$REGIEN^RORUTL02(REGNAME)  Q:REGIEN'>0
"RTN","RORUTL05",136,0)
 . S IENS=REGIEN_","
"RTN","RORUTL05",137,0)
 . ;--- Get the registry parameters
"RTN","RORUTL05",138,0)
 . D GETS^DIQ(798.1,IENS,"21.04;21.05","I","RORFDA","RORMSG")
"RTN","RORUTL05",139,0)
 . I $G(DIERR)  S TMP=$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)  Q
"RTN","RORUTL05",140,0)
 . ;--- Local data has been resent already
"RTN","RORUTL05",141,0)
 . Q:$G(RORFDA(798.1,IENS,21.04,"I"))
"RTN","RORUTL05",142,0)
 . ;--- The registry has not been populated yet
"RTN","RORUTL05",143,0)
 . Q:'$G(RORFDA(798.1,IENS,21.05,"I"))
"RTN","RORUTL05",144,0)
 . ;--- It is too early for resending the local data
"RTN","RORUTL05",145,0)
 . Q:RORFDA(798.1,IENS,21.05,"I")>DATE
"RTN","RORUTL05",146,0)
 . K RORFDA,RORMSG
"RTN","RORUTL05",147,0)
 . ;--- Mark registry records as modified
"RTN","RORUTL05",148,0)
 . S (IEN,RC)=0
"RTN","RORUTL05",149,0)
 . F  S IEN=$O(@ROOT@("AC",REGIEN,IEN))  Q:'IEN  D  Q:RC<0
"RTN","RORUTL05",150,0)
 . . S IENS=IEN_","
"RTN","RORUTL05",151,0)
 . . S RORFDA(798,IENS,4)=1  ; UPDATE DEMOGRAPHICS
"RTN","RORUTL05",152,0)
 . . S RORFDA(798,IENS,5)=1  ; UPDATE LOCAL REGISTRY DATA
"RTN","RORUTL05",153,0)
 . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL05",154,0)
 . . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,798,IENS)  Q
"RTN","RORUTL05",155,0)
 . Q:RC<0
"RTN","RORUTL05",156,0)
 . ;--- Update registry parameters
"RTN","RORUTL05",157,0)
 . S IENS=REGIEN_","
"RTN","RORUTL05",158,0)
 . S RORFDA(798.1,IENS,21.04)=$$NOW^XLFDT
"RTN","RORUTL05",159,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUTL05",160,0)
 . I $G(DIERR)  S TMP=$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)  Q
"RTN","RORUTL05",161,0)
 . ;--- Record the message
"RTN","RORUTL05",162,0)
 . S TMP="Local registry and demographic data will be resent to AAC"
"RTN","RORUTL05",163,0)
 . D LOG^RORLOG(2,TMP,,"Registry Name: "_REGNAME)
"RTN","RORUTL05",164,0)
 Q 0
"RTN","RORUTL06")
0^72^B45063527
"RTN","RORUTL06",1,0)
RORUTL06 ;HCIOFO/SG - DEVELOPER ENTRY POINTS ; 5/10/02 12:50pm
"RTN","RORUTL06",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUTL06",3,0)
 ;
"RTN","RORUTL06",4,0)
 ;***** VERIFIES REGISTRY DEFINITION
"RTN","RORUTL06",5,0)
START ;
"RTN","RORUTL06",6,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL06",7,0)
 N RORERROR      ; Error processing data
"RTN","RORUTL06",8,0)
 N RORPARM       ; Application parameters
"RTN","RORUTL06",9,0)
 ;
"RTN","RORUTL06",10,0)
 N RC,REGLST,REGNAME
"RTN","RORUTL06",11,0)
 W !,"REGISTRY DEFINITION VERIFIER",!
"RTN","RORUTL06",12,0)
 D KILL^XUSCLEAN,INIT^RORUTL01("ROR")
"RTN","RORUTL06",13,0)
 S RORPARM("DEBUG")=2
"RTN","RORUTL06",14,0)
 S RORPARM("ERR")=1
"RTN","RORUTL06",15,0)
 D CLEAR^RORERR("START^RORUTL06")
"RTN","RORUTL06",16,0)
 ;--- Select a registry
"RTN","RORUTL06",17,0)
 S RC=$$SELREG^RORHDTUT(.REGNAME)  G:RC<0 ERROR
"RTN","RORUTL06",18,0)
 Q:RC'>0  S REGLST(REGNAME)=""
"RTN","RORUTL06",19,0)
 ;--- Validate registry update defintion
"RTN","RORUTL06",20,0)
 S RC=$$UPDDEF(.REGLST)            G:RC<0 ERROR
"RTN","RORUTL06",21,0)
 ;--- Validate data extraction defintion
"RTN","RORUTL06",22,0)
 S RC=$$EXTDEF(REGNAME)            G:RC<0 ERROR
"RTN","RORUTL06",23,0)
 ;--- Cleanup
"RTN","RORUTL06",24,0)
 D INIT^RORUTL01("ROR")
"RTN","RORUTL06",25,0)
 Q
"RTN","RORUTL06",26,0)
 ;
"RTN","RORUTL06",27,0)
 ;***** PREPARES THE REGISTRY FOR KIDS DISTRIBUTION
"RTN","RORUTL06",28,0)
DISTPREP ;
"RTN","RORUTL06",29,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL06",30,0)
 N RORERROR      ; Error processing data
"RTN","RORUTL06",31,0)
 N RORPARM       ; Application parameters
"RTN","RORUTL06",32,0)
 ;
"RTN","RORUTL06",33,0)
 N IENS,FLD,RC,REGIEN,REGNAME,RORFDA,RORMSG
"RTN","RORUTL06",34,0)
 N DA,DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","RORUTL06",35,0)
 W !,"REGISTRY PREPARATION FOR KIDS DISTRIBUTION",!
"RTN","RORUTL06",36,0)
 D KILL^XUSCLEAN
"RTN","RORUTL06",37,0)
 S RORPARM("ERR")=1
"RTN","RORUTL06",38,0)
 D CLEAR^RORERR("DISTPREP^RORUTL06")
"RTN","RORUTL06",39,0)
 ;--- Select a registry
"RTN","RORUTL06",40,0)
 S RC=$$SELREG^RORHDTUT(.REGNAME)  G:RC<0 ERROR
"RTN","RORUTL06",41,0)
 Q:RC'>0  S REGIEN=RC
"RTN","RORUTL06",42,0)
 ;--- Request a confirmation
"RTN","RORUTL06",43,0)
 S DIR(0)="Y",DIR("B")="NO"
"RTN","RORUTL06",44,0)
 S DIR("A",1)="Some fields of the '"_REGNAME_"' registry parameters"
"RTN","RORUTL06",45,0)
 S DIR("A",2)="will be cleared to prepare them for KIDS distribution."
"RTN","RORUTL06",46,0)
 S DIR("A")="Do you really want to do this"
"RTN","RORUTL06",47,0)
 D ^DIR  Q:'$G(Y)
"RTN","RORUTL06",48,0)
 ;--- Registry parameters (single-valued)
"RTN","RORUTL06",49,0)
 S IENS=REGIEN_","
"RTN","RORUTL06",50,0)
 F FLD=2.1,2.2,2.3,19.1,19.2,21.02,21.03,21.05  D
"RTN","RORUTL06",51,0)
 . S RORFDA(798.1,IENS,FLD)="@"
"RTN","RORUTL06",52,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL06",53,0)
 G:$$DBS^RORERR("RORMSG",-9,,,798.1,IENS) ERROR
"RTN","RORUTL06",54,0)
 ;--- Registry parameters (multiples)
"RTN","RORUTL06",55,0)
 S IENS=","_REGIEN_","
"RTN","RORUTL06",56,0)
 G:$$CLEAR^RORUTL05(798.114,IENS)<0 ERROR  ; COORDINATOR (14)
"RTN","RORUTL06",57,0)
 G:$$CLEAR^RORUTL05(798.116,IENS)<0 ERROR  ; USER (16)
"RTN","RORUTL06",58,0)
 ;--- Success
"RTN","RORUTL06",59,0)
 W !,"Registry parameters are ready for distribution."
"RTN","RORUTL06",60,0)
 Q
"RTN","RORUTL06",61,0)
 ;
"RTN","RORUTL06",62,0)
 ;***** DISPLAYS THE ERRORS
"RTN","RORUTL06",63,0)
ERROR ;
"RTN","RORUTL06",64,0)
 D DSPSTK^RORERR()
"RTN","RORUTL06",65,0)
 Q
"RTN","RORUTL06",66,0)
 ;
"RTN","RORUTL06",67,0)
 ;***** VALIDATES DATA EXTRACTION DEFINITION
"RTN","RORUTL06",68,0)
 ;
"RTN","RORUTL06",69,0)
 ; REGNAME       Registry name
"RTN","RORUTL06",70,0)
 ;
"RTN","RORUTL06",71,0)
 ; Return Values:
"RTN","RORUTL06",72,0)
 ;       <0  Error Code
"RTN","RORUTL06",73,0)
 ;        0  Ok
"RTN","RORUTL06",74,0)
 ;
"RTN","RORUTL06",75,0)
EXTDEF(REGNAME) ;
"RTN","RORUTL06",76,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL06",77,0)
 N ROREXT        ; Data extraction descriptor
"RTN","RORUTL06",78,0)
 N RORHL         ; HL7 variables
"RTN","RORUTL06",79,0)
 N RORLRC        ; List of codes of Lab results to be extracted
"RTN","RORUTL06",80,0)
 ;
"RTN","RORUTL06",81,0)
 N RC
"RTN","RORUTL06",82,0)
 W !,"DATA EXTRACTION DEFINITION",!
"RTN","RORUTL06",83,0)
 D CLEAR^RORERR("UPDDEF^RORUTL06")
"RTN","RORUTL06",84,0)
 S RC=$$PREPARE^ROREXPR(REGNAME)
"RTN","RORUTL06",85,0)
 D:RC'<0 DEBUG1^ROREXT
"RTN","RORUTL06",86,0)
 Q RC
"RTN","RORUTL06",87,0)
 ;
"RTN","RORUTL06",88,0)
 ;***** PRINTS THE DATA ELEMENT METADATA
"RTN","RORUTL06",89,0)
PRTMDE ;
"RTN","RORUTL06",90,0)
 N RORCOLS       ; Lits of column descriptors
"RTN","RORUTL06",91,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL06",92,0)
 N RORERROR      ; Error processing data
"RTN","RORUTL06",93,0)
 N RORLST        ; List of files grouped by parents
"RTN","RORUTL06",94,0)
 N RORPAGE       ; Current page number
"RTN","RORUTL06",95,0)
 N RORPARM       ; Application parameters
"RTN","RORUTL06",96,0)
 N RORTTL        ; Title of the report
"RTN","RORUTL06",97,0)
 ;
"RTN","RORUTL06",98,0)
 N DIR,DIRUT,DTOUT,DUOUT,MODE,TMP,X,Y
"RTN","RORUTL06",99,0)
 D KILL^XUSCLEAN
"RTN","RORUTL06",100,0)
 S (DDBDMSG,RORTTL)="METADATA OF THE DATA ELEMENTS"
"RTN","RORUTL06",101,0)
 W !,RORTTL,!  S RORPARM("ERR")=1
"RTN","RORUTL06",102,0)
 D CLEAR^RORERR("PRTMDE^RORUTL06")
"RTN","RORUTL06",103,0)
 ;---Request report sort mode from user
"RTN","RORUTL06",104,0)
 S DIR(0)="S^H:Hierarhical;L:List of codes"
"RTN","RORUTL06",105,0)
 S DIR("A")="Sort mode",DIR("B")="List of codes"
"RTN","RORUTL06",106,0)
 D ^DIR  Q:$D(DIRUT)  S MODE=Y
"RTN","RORUTL06",107,0)
 ;--- Generate and print the report
"RTN","RORUTL06",108,0)
 I MODE="H"  S RC=0  D
"RTN","RORUTL06",109,0)
 . N %ZIS,I,FILE,PARENT,ROOT,RORMSG
"RTN","RORUTL06",110,0)
 . S ROOT=$$ROOT^DILFD(799.2,,1),RORPAGE=0
"RTN","RORUTL06",111,0)
 . ;--- Load column descriptors
"RTN","RORUTL06",112,0)
 . F I=1:1  S TMP=$P($T(PRTMDEH+I),";;",2)  Q:TMP=""  D
"RTN","RORUTL06",113,0)
 . . S RORCOLS(I)=$TR($P(TMP,U,1,3)," ")_U_$P(TMP,U,4)
"RTN","RORUTL06",114,0)
 . ;--- Load file list
"RTN","RORUTL06",115,0)
 . S FILE=0,RC=0
"RTN","RORUTL06",116,0)
 . F  S FILE=$O(@ROOT@(FILE))  Q:FILE'>0  D  Q:RC<0
"RTN","RORUTL06",117,0)
 . . S PARENT=+$$GET1^DIQ(799.2,FILE_",",1,"I",,"RORMSG")
"RTN","RORUTL06",118,0)
 . . I $G(DIERR)  D  Q
"RTN","RORUTL06",119,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,,,799.2,FILE_",")
"RTN","RORUTL06",120,0)
 . . S RORLST(PARENT,FILE)=""
"RTN","RORUTL06",121,0)
 . Q:RC<0
"RTN","RORUTL06",122,0)
 . ;--- Print the report
"RTN","RORUTL06",123,0)
 . S %ZIS("B")=""
"RTN","RORUTL06",124,0)
 . D ^%ZIS   Q:$G(POP)  U IO
"RTN","RORUTL06",125,0)
 . S RC=$$PRTMDEH()  S:RC'<0 RC=$$PRTMDE1(0,1)
"RTN","RORUTL06",126,0)
 . D ^%ZISC
"RTN","RORUTL06",127,0)
 E  S RC=$$PRTMDE2()
"RTN","RORUTL06",128,0)
 G:RC<0 ERROR
"RTN","RORUTL06",129,0)
 Q
"RTN","RORUTL06",130,0)
 ;
"RTN","RORUTL06",131,0)
 ;***** PRINTS A LEVEL OF THE "FILE-PROCESSING TREE"
"RTN","RORUTL06",132,0)
 ;
"RTN","RORUTL06",133,0)
 ; PARENT        Parent file number
"RTN","RORUTL06",134,0)
 ; LEVEL         Number of the current level in the tree
"RTN","RORUTL06",135,0)
 ;
"RTN","RORUTL06",136,0)
 ; Return Values:
"RTN","RORUTL06",137,0)
 ;       <0  Error Code
"RTN","RORUTL06",138,0)
 ;        0  Ok
"RTN","RORUTL06",139,0)
 ;
"RTN","RORUTL06",140,0)
PRTMDE1(PARENT,LEVEL) ;
"RTN","RORUTL06",141,0)
 N FIELDS,FILE,FLD,I,IENS,IR,L,RORBUF,RORMSG
"RTN","RORUTL06",142,0)
 S FIELDS="@;.01E;.02I;1I;2E;4I;4.1;4.2;6I"
"RTN","RORUTL06",143,0)
 ;---
"RTN","RORUTL06",144,0)
 S FILE="",RC=0
"RTN","RORUTL06",145,0)
 F  S FILE=$O(RORLST(PARENT,FILE))  Q:FILE=""  D  Q:RC<0
"RTN","RORUTL06",146,0)
 . ;--- Load descriptors of the data elements
"RTN","RORUTL06",147,0)
 . S IENS=","_FILE_","
"RTN","RORUTL06",148,0)
 . D LIST^DIC(799.22,IENS,FIELDS,,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL06",149,0)
 . ;--- Print header (if necessary) and file number
"RTN","RORUTL06",150,0)
 . I ($Y+5)>IOSL  S RC=$$PRTMDEH()  Q:RC<0
"RTN","RORUTL06",151,0)
 . D PRTMDEL(LEVEL-1),PRTMDEL(LEVEL-1,FILE)
"RTN","RORUTL06",152,0)
 . ;--- Print data element descriptors
"RTN","RORUTL06",153,0)
 . S IR="",RC=0
"RTN","RORUTL06",154,0)
 . F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D  Q:RC<0  W !
"RTN","RORUTL06",155,0)
 . . I ($Y+5)>IOSL  S RC=$$PRTMDEH()  Q:RC<0
"RTN","RORUTL06",156,0)
 . . D:IR>1 PRTMDEL(LEVEL,"")
"RTN","RORUTL06",157,0)
 . . S I=""
"RTN","RORUTL06",158,0)
 . . F  S I=$O(RORCOLS(I))  Q:I=""  D
"RTN","RORUTL06",159,0)
 . . . S FLD=+$P(RORCOLS(I),U,2)  Q:FLD'>0
"RTN","RORUTL06",160,0)
 . . . S L=+$P(RORCOLS(I),U,3)  S:L'>0 L=999
"RTN","RORUTL06",161,0)
 . . . W ?(+RORCOLS(I)),$E($G(RORBUF("DILIST","ID",IR,FLD)),1,L)
"RTN","RORUTL06",162,0)
 . Q:RC<0
"RTN","RORUTL06",163,0)
 . S:$D(RORLST(FILE))>1 RC=$$PRTMDE1(FILE,LEVEL+1)
"RTN","RORUTL06",164,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL06",165,0)
 ;
"RTN","RORUTL06",166,0)
 ;***** PRINTS A TABLE OF DATA ELEMENTS
"RTN","RORUTL06",167,0)
PRTMDE2() ;
"RTN","RORUTL06",168,0)
 N BY,DHD,FR,L,DIC,FLDS,TO
"RTN","RORUTL06",169,0)
 S L=0,DIC=799.2,DHD=RORTTL
"RTN","RORUTL06",170,0)
 S BY="[ROR DATA ELEMENTS]",FLDS="[ROR DATA ELEMENTS]"
"RTN","RORUTL06",171,0)
 D EN1^DIP
"RTN","RORUTL06",172,0)
 Q 0
"RTN","RORUTL06",173,0)
 ;
"RTN","RORUTL06",174,0)
 ;***** PRINTS A HEADER OF THE DATA ELEMENT REPORT
"RTN","RORUTL06",175,0)
 ;  X  Field Width Title
"RTN","RORUTL06",176,0)
PRTMDEH() ;
"RTN","RORUTL06",177,0)
 ;;  0^     ^     ^File
"RTN","RORUTL06",178,0)
 ;; 22^  .01^   25^Data Name
"RTN","RORUTL06",179,0)
 ;; 49^  .02^     ^Code
"RTN","RORUTL06",180,0)
 ;; 55^ 2   ^     ^Req
"RTN","RORUTL06",181,0)
 ;; 60^ 1   ^     ^API
"RTN","RORUTL06",182,0)
 ;; 65^ 6   ^     ^Field Number
"RTN","RORUTL06",183,0)
 ;; 82^ 4   ^     ^VT
"RTN","RORUTL06",184,0)
 ;; 86^ 4.1 ^   20^External
"RTN","RORUTL06",185,0)
 ;;108^ 4.2 ^   20^Internal
"RTN","RORUTL06",186,0)
 ;
"RTN","RORUTL06",187,0)
 N DIR,DIRUT,DTOUT,DUOUT,I,X,Y
"RTN","RORUTL06",188,0)
 I RORPAGE,$E(IOST,1,2)="C-"  D  Q:'Y $S(Y="":-72,1:-71)
"RTN","RORUTL06",189,0)
 . S DIR(0)="E"  D ^DIR
"RTN","RORUTL06",190,0)
 W:RORPAGE!($E(IOST,1,2)="C-") @IOF
"RTN","RORUTL06",191,0)
 S RORPAGE=RORPAGE+1,I=""  W RORTTL,!
"RTN","RORUTL06",192,0)
 F  S I=$O(RORCOLS(I))  Q:I=""  W ?(+RORCOLS(I)),$P(RORCOLS(I),U,4)
"RTN","RORUTL06",193,0)
 S X="",$P(X,"-",IOM)=""
"RTN","RORUTL06",194,0)
 W !,X,!
"RTN","RORUTL06",195,0)
 Q 0
"RTN","RORUTL06",196,0)
 ;
"RTN","RORUTL06",197,0)
 ;***** PRINTS THE LEVEL INDICATOR
"RTN","RORUTL06",198,0)
 ;
"RTN","RORUTL06",199,0)
 ; N             Number of dots in the indicator
"RTN","RORUTL06",200,0)
 ; [FILE]        File number
"RTN","RORUTL06",201,0)
 ;
"RTN","RORUTL06",202,0)
PRTMDEL(N,FILE) ;
"RTN","RORUTL06",203,0)
 N I  W:$X>0 !  F I=1:1:N  W ". "
"RTN","RORUTL06",204,0)
 W:$D(FILE) FILE  W:'$D(FILE) !
"RTN","RORUTL06",205,0)
 Q
"RTN","RORUTL06",206,0)
 ;
"RTN","RORUTL06",207,0)
 ;***** VALIDATES REGISTRY UPDATE DEFINITION
"RTN","RORUTL06",208,0)
 ;
"RTN","RORUTL06",209,0)
 ; .REGLST       Reference to a local array containing
"RTN","RORUTL06",210,0)
 ;               registry names as subscripts
"RTN","RORUTL06",211,0)
 ;
"RTN","RORUTL06",212,0)
 ; Return Values:
"RTN","RORUTL06",213,0)
 ;       <0  Error Code
"RTN","RORUTL06",214,0)
 ;        0  Ok
"RTN","RORUTL06",215,0)
 ;
"RTN","RORUTL06",216,0)
UPDDEF(REGLST) ;
"RTN","RORUTL06",217,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL06",218,0)
 N RORLRC        ; List of Lab result codes to check
"RTN","RORUTL06",219,0)
 N RORUPD        ; Update descriptor
"RTN","RORUTL06",220,0)
 N RORUPDPI      ; Closed root of the temporary storage
"RTN","RORUTL06",221,0)
 N RORVALS       ; Calculated values
"RTN","RORUTL06",222,0)
 ;
"RTN","RORUTL06",223,0)
 N RC
"RTN","RORUTL06",224,0)
 W !,"REGISTRY UPDATE DEFINITION",!
"RTN","RORUTL06",225,0)
 D CLEAR^RORERR("UPDDEF^RORUTL06")
"RTN","RORUTL06",226,0)
 S RORUPDPI=$NA(^TMP("RORUPD",$J))
"RTN","RORUTL06",227,0)
 S RC=$$PREPARE^RORUPR(.REGLST)
"RTN","RORUTL06",228,0)
 D:RC'<0 DEBUG^RORUPDUT
"RTN","RORUTL06",229,0)
 Q RC
"RTN","RORUTL07")
0^73^B9724841
"RTN","RORUTL07",1,0)
RORUTL07 ;HCIOFO/SG - TEST ENTRY POINTS ; 4/19/02 8:59am
"RTN","RORUTL07",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;;May 14, 2002
"RTN","RORUTL07",3,0)
 ;
"RTN","RORUTL07",4,0)
 Q
"RTN","RORUTL07",5,0)
 ;
"RTN","RORUTL07",6,0)
 ;***** RESETS THE 'AWAITING ACK' FLAG
"RTN","RORUTL07",7,0)
 ;
"RTN","RORUTL07",8,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL07",9,0)
 ;
"RTN","RORUTL07",10,0)
 ; Return Values:
"RTN","RORUTL07",11,0)
 ;       <0  Error Code
"RTN","RORUTL07",12,0)
 ;        0  Ok
"RTN","RORUTL07",13,0)
 ;       >0  The flag has not been reset
"RTN","RORUTL07",14,0)
 ;
"RTN","RORUTL07",15,0)
ACKFLAG(REGIEN) ;
"RTN","RORUTL07",16,0)
 N DIR,DIRUT,DTOUT,DUOUT,IENS,RORFDA,RORMSG,X,Y
"RTN","RORUTL07",17,0)
 S IENS=REGIEN_","
"RTN","RORUTL07",18,0)
 ;--- Get a value of the flag
"RTN","RORUTL07",19,0)
 S Y=$$GET1^DIQ(798.1,IENS,2.2,"I",,"RORMSG")
"RTN","RORUTL07",20,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ACKFLAG^RORUTL07",,798.1,IENS)
"RTN","RORUTL07",21,0)
 ;--- Ask confirmation to reset the flag
"RTN","RORUTL07",22,0)
 I Y  D  Q:RC RC
"RTN","RORUTL07",23,0)
 . S DIR(0)="Y",DIR("B")="YES"
"RTN","RORUTL07",24,0)
 . S DIR("A")="Reset the 'Awaiting ACK' flag"
"RTN","RORUTL07",25,0)
 . D ^DIR
"RTN","RORUTL07",26,0)
 . S RC=$S($D(DIRUT):-72,1:'$G(Y))
"RTN","RORUTL07",27,0)
 ;--- Clear the flag
"RTN","RORUTL07",28,0)
 S RORFDA(798.1,IENS,2.2)="@"
"RTN","RORUTL07",29,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUTL07",30,0)
 Q +$$DBS^RORERR("RORMSG",-9,"ACKFLAG^RORUTL07",,798.1,IENS)
"RTN","RORUTL07",31,0)
 ;
"RTN","RORUTL07",32,0)
 ;***** DISPLAYS THE ERRORS
"RTN","RORUTL07",33,0)
ERROR ;
"RTN","RORUTL07",34,0)
 D DSPSTK^RORERR()
"RTN","RORUTL07",35,0)
 Q
"RTN","RORUTL07",36,0)
 ;
"RTN","RORUTL07",37,0)
 ;***** DATA EXTRACTION TEST ENTRY POINT
"RTN","RORUTL07",38,0)
EXTRACT ;
"RTN","RORUTL07",39,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL07",40,0)
 N RORERROR      ; Error processing data
"RTN","RORUTL07",41,0)
 N RORPARM       ; Application parameters
"RTN","RORUTL07",42,0)
 ;
"RTN","RORUTL07",43,0)
 N RC,REGIEN,REGNAME,SDT
"RTN","RORUTL07",44,0)
 W !,"DATA EXTRACTION & TRANSMISSION IN DEBUG MODE",!
"RTN","RORUTL07",45,0)
 D KILL^XUSCLEAN
"RTN","RORUTL07",46,0)
 S RORPARM("DEBUG")=2
"RTN","RORUTL07",47,0)
 S RORPARM("ERR")=1
"RTN","RORUTL07",48,0)
 D CLEAR^RORERR("EXTRACT^RORUTL07")
"RTN","RORUTL07",49,0)
 ;--- Select a registry
"RTN","RORUTL07",50,0)
 S RC=$$SELREG^RORHDTUT(.REGNAME)        G:RC<0 ERROR
"RTN","RORUTL07",51,0)
 Q:RC'>0  S REGIEN=RC
"RTN","RORUTL07",52,0)
 ;--- Request a start date
"RTN","RORUTL07",53,0)
 S SDT=$$GETSDT()                       G:SDT<0 ERROR
"RTN","RORUTL07",54,0)
 ;--- Check/Reset the 'Awaiting Acknowledgement' flag
"RTN","RORUTL07",55,0)
 S RC=$$ACKFLAG(REGIEN)                  G:RC<0 ERROR
"RTN","RORUTL07",56,0)
 ;--- Extract the registry data
"RTN","RORUTL07",57,0)
 S RC=$$EXTRACT^ROREXT(REGNAME,$G(SDT))  G:RC<0 ERROR
"RTN","RORUTL07",58,0)
 Q
"RTN","RORUTL07",59,0)
 ;
"RTN","RORUTL07",60,0)
 ;***** REQESTS A START DATE FROM A USER
"RTN","RORUTL07",61,0)
 ;
"RTN","RORUTL07",62,0)
 ; Return Values:
"RTN","RORUTL07",63,0)
 ;       <0  Error Code
"RTN","RORUTL07",64,0)
 ;       ""  No start date (default)
"RTN","RORUTL07",65,0)
 ;       >0  Start date
"RTN","RORUTL07",66,0)
 ;
"RTN","RORUTL07",67,0)
GETSDT() ;
"RTN","RORUTL07",68,0)
 ;;If you enter an empty string then the individual start date
"RTN","RORUTL07",69,0)
 ;;(from the registry record) will be used for each patient.
"RTN","RORUTL07",70,0)
 ;
"RTN","RORUTL07",71,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,RC,X,Y
"RTN","RORUTL07",72,0)
 S DIR(0)="DO^:DT:EX"
"RTN","RORUTL07",73,0)
 S DIR("A")="Start date for data extraction"
"RTN","RORUTL07",74,0)
 F X=1:1  S Y=$P($T(GETSDT+X),";;",2)  Q:Y=""  S DIR("?",X)=Y
"RTN","RORUTL07",75,0)
 S DIR("?")="This response must be a date."
"RTN","RORUTL07",76,0)
 D ^DIR
"RTN","RORUTL07",77,0)
 S RC=$S($D(DTOUT):-72,$D(DUOUT):-71,1:0)
"RTN","RORUTL07",78,0)
 Q $S(RC<0:RC,1:$G(Y))
"RTN","RORUTL07",79,0)
 ;
"RTN","RORUTL07",80,0)
 ;***** REGISTRY UPDATE TEST ENTRY POINT
"RTN","RORUTL07",81,0)
UPDATE ;
"RTN","RORUTL07",82,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL07",83,0)
 N RORERROR      ; Error processing data
"RTN","RORUTL07",84,0)
 N RORPARM       ; Application parameters
"RTN","RORUTL07",85,0)
 ;
"RTN","RORUTL07",86,0)
 N RC,REGLST,REGNAME
"RTN","RORUTL07",87,0)
 W !,"REGISTRY UPDATE IN DEBUG MODE",!
"RTN","RORUTL07",88,0)
 D KILL^XUSCLEAN
"RTN","RORUTL07",89,0)
 S RORPARM("DEBUG")=2
"RTN","RORUTL07",90,0)
 S RORPARM("ERR")=1
"RTN","RORUTL07",91,0)
 D CLEAR^RORERR("UPDATE^RORUTL07")
"RTN","RORUTL07",92,0)
 ;--- Select a registry
"RTN","RORUTL07",93,0)
 S RC=$$SELREG^RORHDTUT(.REGNAME)  G:RC<0 ERROR
"RTN","RORUTL07",94,0)
 Q:RC'>0  S REGLST(REGNAME)=""
"RTN","RORUTL07",95,0)
 ;--- Update the registry
"RTN","RORUTL07",96,0)
 S RC=$$UPDATE^RORUPD(.REGLST)     G:RC<0 ERROR
"RTN","RORUTL07",97,0)
 Q
"SEC","^DD",798.1,798.1,21.03,9)

"SEC","^DD",798.1,798.1,21.04,8)

"SEC","^DD",798.3,798.31,2,8.5)

"SEC","^DD",798.3,798.31,2,9)

"SEC","^DD",798.7,798.74,2,9)

"SEC","^DD",799.1,799.1,.02,8)

"SEC","^DIC",798,798,0,"AUDIT")

"SEC","^DIC",798,798,0,"DD")
@
"SEC","^DIC",798,798,0,"DEL")
@
"SEC","^DIC",798,798,0,"LAYGO")
@
"SEC","^DIC",798,798,0,"RD")

"SEC","^DIC",798,798,0,"WR")
@
"SEC","^DIC",798.1,798.1,0,"AUDIT")

"SEC","^DIC",798.1,798.1,0,"DD")
@
"SEC","^DIC",798.1,798.1,0,"DEL")
@
"SEC","^DIC",798.1,798.1,0,"LAYGO")
@
"SEC","^DIC",798.1,798.1,0,"RD")

"SEC","^DIC",798.1,798.1,0,"WR")
@
"SEC","^DIC",798.2,798.2,0,"AUDIT")

"SEC","^DIC",798.2,798.2,0,"DD")
@
"SEC","^DIC",798.2,798.2,0,"DEL")
@
"SEC","^DIC",798.2,798.2,0,"LAYGO")
@
"SEC","^DIC",798.2,798.2,0,"RD")

"SEC","^DIC",798.2,798.2,0,"WR")
@
"SEC","^DIC",798.3,798.3,0,"AUDIT")

"SEC","^DIC",798.3,798.3,0,"DD")
@
"SEC","^DIC",798.3,798.3,0,"DEL")
@
"SEC","^DIC",798.3,798.3,0,"LAYGO")
@
"SEC","^DIC",798.3,798.3,0,"RD")

"SEC","^DIC",798.3,798.3,0,"WR")
@
"SEC","^DIC",798.4,798.4,0,"AUDIT")

"SEC","^DIC",798.4,798.4,0,"DD")
@
"SEC","^DIC",798.4,798.4,0,"DEL")
@
"SEC","^DIC",798.4,798.4,0,"LAYGO")
@
"SEC","^DIC",798.4,798.4,0,"RD")

"SEC","^DIC",798.4,798.4,0,"WR")
@
"SEC","^DIC",798.5,798.5,0,"AUDIT")

"SEC","^DIC",798.5,798.5,0,"DD")
@
"SEC","^DIC",798.5,798.5,0,"DEL")
@
"SEC","^DIC",798.5,798.5,0,"LAYGO")
@
"SEC","^DIC",798.5,798.5,0,"RD")

"SEC","^DIC",798.5,798.5,0,"WR")
@
"SEC","^DIC",798.6,798.6,0,"AUDIT")

"SEC","^DIC",798.6,798.6,0,"DD")
@
"SEC","^DIC",798.6,798.6,0,"DEL")
@
"SEC","^DIC",798.6,798.6,0,"LAYGO")
@
"SEC","^DIC",798.6,798.6,0,"RD")

"SEC","^DIC",798.6,798.6,0,"WR")
@
"SEC","^DIC",798.7,798.7,0,"AUDIT")

"SEC","^DIC",798.7,798.7,0,"DD")
@
"SEC","^DIC",798.7,798.7,0,"DEL")
@
"SEC","^DIC",798.7,798.7,0,"LAYGO")
@
"SEC","^DIC",798.7,798.7,0,"RD")

"SEC","^DIC",798.7,798.7,0,"WR")
@
"SEC","^DIC",798.9,798.9,0,"AUDIT")

"SEC","^DIC",798.9,798.9,0,"DD")
@
"SEC","^DIC",798.9,798.9,0,"DEL")
@
"SEC","^DIC",798.9,798.9,0,"LAYGO")
@
"SEC","^DIC",798.9,798.9,0,"RD")

"SEC","^DIC",798.9,798.9,0,"WR")
@
"SEC","^DIC",799.1,799.1,0,"AUDIT")

"SEC","^DIC",799.1,799.1,0,"DD")
@
"SEC","^DIC",799.1,799.1,0,"DEL")
@
"SEC","^DIC",799.1,799.1,0,"LAYGO")
@
"SEC","^DIC",799.1,799.1,0,"RD")

"SEC","^DIC",799.1,799.1,0,"WR")
@
"SEC","^DIC",799.2,799.2,0,"AUDIT")

"SEC","^DIC",799.2,799.2,0,"DD")
@
"SEC","^DIC",799.2,799.2,0,"DEL")
@
"SEC","^DIC",799.2,799.2,0,"LAYGO")
@
"SEC","^DIC",799.2,799.2,0,"RD")

"SEC","^DIC",799.2,799.2,0,"WR")
@
"VER")
8.0^22
"^DD",798,798,0)
FIELD^^11^20
"^DD",798,798,0,"DDA")
N
"^DD",798,798,0,"DT")
3011120
"^DD",798,798,0,"IX","AC",798,.02)

"^DD",798,798,0,"IX","AD",798,1)

"^DD",798,798,0,"IX","AM",798,10)

"^DD",798,798,0,"IX","B",798,.01)

"^DD",798,798,0,"NM","ROR LOCAL REGISTRY")

"^DD",798,798,0,"PT",798.53,.01)

"^DD",798,798,0,"VRPK")
ROR
"^DD",798,798,.01,0)
PATIENT NAME^RP798.4^RORDATA(798.4,^0;1^Q
"^DD",798,798,.01,1,0)
^.1
"^DD",798,798,.01,1,1,0)
798^B
"^DD",798,798,.01,1,1,1)
S ^RORDATA(798,"B",$E(X,1,30),DA)=""
"^DD",798,798,.01,1,1,2)
K ^RORDATA(798,"B",$E(X,1,30),DA)
"^DD",798,798,.01,1,1,3)
Do not delete!
"^DD",798,798,.01,1,1,"%D",0)
^^2^2^3011005^
"^DD",798,798,.01,1,1,"%D",1,0)
Patient records in all defined registries can be
"^DD",798,798,.01,1,1,"%D",2,0)
found using this cross-reference.
"^DD",798,798,.01,3)

"^DD",798,798,.01,8.5)
@
"^DD",798,798,.01,9)
@
"^DD",798,798,.01,21,0)
^^4^4^3020402^
"^DD",798,798,.01,21,1,0)
The PATIENT NAME field identifies a patient in the
"^DD",798,798,.01,21,2,0)
registry. You can select a patient either from the
"^DD",798,798,.01,21,3,0)
local registry or the ROR PATIENT file, or you can
"^DD",798,798,.01,21,4,0)
add a new patient from the PATIENT file.
"^DD",798,798,.01,23,0)
^^6^6^3020402^
"^DD",798,798,.01,23,1,0)
An internal value of this field is the patient IEN in
"^DD",798,798,.01,23,2,0)
the PATIENT file (#2) because records in the ROR
"^DD",798,798,.01,23,3,0)
PATIENT file (#798.4) have the same internal entry
"^DD",798,798,.01,23,4,0)
numbers as corresponding records in the PATIENT file.
"^DD",798,798,.01,23,5,0)
Patient records in all registries can be found by
"^DD",798,798,.01,23,6,0)
traditional "B" cross-reference.
"^DD",798,798,.01,"DT")
3010612
"^DD",798,798,.02,0)
REGISTRY^RP798.1'I^ROR(798.1,^0;2^Q
"^DD",798,798,.02,1,0)
^.1
"^DD",798,798,.02,1,1,0)
798^AC
"^DD",798,798,.02,1,1,1)
S ^RORDATA(798,"AC",$E(X,1,30),DA)=""
"^DD",798,798,.02,1,1,2)
K ^RORDATA(798,"AC",$E(X,1,30),DA)
"^DD",798,798,.02,1,1,3)
Do not delete!
"^DD",798,798,.02,1,1,"%D",0)
^^2^2^3011005^
"^DD",798,798,.02,1,1,"%D",1,0)
This cross-reference is used to link all records
"^DD",798,798,.02,1,1,"%D",2,0)
of the registry together.
"^DD",798,798,.02,1,1,"DT")
3000406
"^DD",798,798,.02,1,2,0)
^^TRIGGER^798^1
"^DD",798,798,.02,1,2,1)
X ^DD(798,.02,1,2,1.3) I X S X=DIV S Y(1)=$S($D(^RORDATA(798,D0,0)):^(0),1:"") S X=$P(Y(1),U,3),X=X S DIU=X K Y S X=DIV S %=$P($H,",",2),X=DT_(%\60#60/100+(%\3600)+(%#60/10000)/100) X ^DD(798,.02,1,2,1.4)
"^DD",798,798,.02,1,2,1.3)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(0)=X S Y(1)=$S($D(^RORDATA(798,D0,0)):^(0),1:"") S X='$P(Y(1),U,3)
"^DD",798,798,.02,1,2,1.4)
S DIH=$G(^RORDATA(798,DIV(0),0)),DIV=X S $P(^(0),U,3)=DIV,DIH=798,DIG=1 D ^DICR
"^DD",798,798,.02,1,2,2)
Q
"^DD",798,798,.02,1,2,3)
Do not delete!
"^DD",798,798,.02,1,2,"%D",0)
^^2^2^3020402^
"^DD",798,798,.02,1,2,"%D",1,0)
This trigger populates the DATE ENTERED field 
"^DD",798,798,.02,1,2,"%D",2,0)
when the patient is added to the registry.
"^DD",798,798,.02,1,2,"CREATE CONDITION")
'DATE ENTERED
"^DD",798,798,.02,1,2,"CREATE VALUE")
NOW
"^DD",798,798,.02,1,2,"DELETE VALUE")
NO EFFECT
"^DD",798,798,.02,1,2,"DT")
3011119
"^DD",798,798,.02,1,2,"FIELD")
DATE
"^DD",798,798,.02,8.5)
@
"^DD",798,798,.02,9)
@
"^DD",798,798,.02,21,0)
^^2^2^3020402^
"^DD",798,798,.02,21,1,0)
The REGISTRY field identifies the registry that 
"^DD",798,798,.02,21,2,0)
the record belongs to.
"^DD",798,798,.02,23,0)
^^2^2^3020402^
"^DD",798,798,.02,23,1,0)
Traditional cross-reference "AC" is used to link all 
"^DD",798,798,.02,23,2,0)
records of the registry together.
"^DD",798,798,.02,"DT")
3011119
"^DD",798,798,1,0)
DATE ENTERED^DI^^0;3^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798,1,1,0)
^.1
"^DD",798,798,1,1,1,0)
798^AD
"^DD",798,798,1,1,1,1)
S ^RORDATA(798,"AD",$E(X,1,30),DA)=""
"^DD",798,798,1,1,1,2)
K ^RORDATA(798,"AD",$E(X,1,30),DA)
"^DD",798,798,1,1,1,3)
Do not delete!
"^DD",798,798,1,1,1,"%D",0)
^^2^2^3011005^
"^DD",798,798,1,1,1,"%D",1,0)
This cross-reference can be used to search for
"^DD",798,798,1,1,1,"%D",2,0)
recently added patients.  
"^DD",798,798,1,1,1,"DT")
3010709
"^DD",798,798,1,5,1,0)
798^.02^2
"^DD",798,798,1,8.5)
@
"^DD",798,798,1,9)
@
"^DD",798,798,1,20,0)
^.3LA^^0
"^DD",798,798,1,21,0)
^^3^3^3020402^
"^DD",798,798,1,21,1,0)
The DATE ENTERED field is automatically populated
"^DD",798,798,1,21,2,0)
by the trigger associated with the REGISTRY field
"^DD",798,798,1,21,3,0)
when the patient is added to the registry.
"^DD",798,798,1,"DT")
3011115
"^DD",798,798,2,0)
INACTIVATION DATE^DX^^0;4^S %DT="ESTX" K Y S:$G(DIUTIL)'="VERIFY FIELDS" Y(9.2)=$P($G(^RORDATA(798,DA,2)),U,2),Y(7)=$P($G(^(0)),U,11),Y=$S(Y(9.2)>Y(7):Y(9.2),1:Y(7)) S:$G(Y)>0 %DT(0)=Y D ^%DT S X=Y K:Y<1 X K %DT,Y
"^DD",798,798,2,1,0)
^.1^^0
"^DD",798,798,2,3)
Enter the inactivation date for the patient.
"^DD",798,798,2,4)

"^DD",798,798,2,21,0)
^^8^8^3020402^
"^DD",798,798,2,21,1,0)
When present the INACTIVATION DATE field contains
"^DD",798,798,2,21,2,0)
the latest inactivation date/time of the patient
"^DD",798,798,2,21,3,0)
in the registry.
"^DD",798,798,2,21,4,0)
 
"^DD",798,798,2,21,5,0)
The new inactivation date could be in the future
"^DD",798,798,2,21,6,0)
or in the past but it should be not earlier than
"^DD",798,798,2,21,7,0)
the date of the last data extraction or the date
"^DD",798,798,2,21,8,0)
of re-activation (if present).
"^DD",798,798,2,23,0)
^^5^5^3020402^
"^DD",798,798,2,23,1,0)
Patient's record is active if there is no inactivation 
"^DD",798,798,2,23,2,0)
date. Otherwise, values of both the INACTIVATION DATE
"^DD",798,798,2,23,3,0)
and REACTIVATION DATE fields should be analyzed along
"^DD",798,798,2,23,4,0)
with the current date/time. See description of the 
"^DD",798,798,2,23,5,0)
ACTIVE computed field (#798, 8) for further details.
"^DD",798,798,2,"DT")
3011120
"^DD",798,798,2.1,0)
INACTIVATED BY^P200'^VA(200,^0;10^Q
"^DD",798,798,2.1,21,0)
^^3^3^3020402^
"^DD",798,798,2.1,21,1,0)
The INACTIVATED BY field identifies a person who
"^DD",798,798,2.1,21,2,0)
has inactivated a patient record in the registry
"^DD",798,798,2.1,21,3,0)
for the last time.
"^DD",798,798,2.1,23,0)
^^4^4^3020402^
"^DD",798,798,2.1,23,1,0)
This field is automatically populated by the
"^DD",798,798,2.1,23,2,0)
inactivation remote procedure. If the patient record
"^DD",798,798,2.1,23,3,0)
has been automatically inactivated because of patient
"^DD",798,798,2.1,23,4,0)
death, this field will have no value.
"^DD",798,798,2.1,"DT")
3000504
"^DD",798,798,2.2,0)
REASON FOR INACTIVATION^*P799.1'X^ROR(799.1,^0;13^S Y=$P($G(^RORDATA(798,DA,0)),U,2),DIC("S")="S D=$G(^(0)) I $P(D,U,2)=1"_$S(Y>0:",$P(D,U,3)="_Y,1:"") D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",798,798,2.2,3)

"^DD",798,798,2.2,12)
Only reasons for inactivation can be selected.
"^DD",798,798,2.2,12.1)
S DIC("S")="I $P(^(0),U,2)=1"
"^DD",798,798,2.2,21,0)
^.001^3^3^3011120^^^^
"^DD",798,798,2.2,21,1,0)
Value of this field indicates a reason for the 
"^DD",798,798,2.2,21,2,0)
latest manual inactivation of the patient record
"^DD",798,798,2.2,21,3,0)
in the registry.
"^DD",798,798,2.2,23,0)
^.001^5^5^3011120^^^^
"^DD",798,798,2.2,23,1,0)
This field is only ever populated via the GUI manual
"^DD",798,798,2.2,23,2,0)
entry option.
"^DD",798,798,2.2,23,3,0)
 
"^DD",798,798,2.2,23,4,0)
If a patient was inactivated because of death, this 
"^DD",798,798,2.2,23,5,0)
field MUST be empty!
"^DD",798,798,2.2,"DT")
3011120
"^DD",798,798,3,0)
NEW PATIENT^S^0:NO;1:AUTO;2:MANUAL;3:REACTIVATED;^0;5^Q
"^DD",798,798,3,21,0)
^^2^2^3020402^
"^DD",798,798,3,21,1,0)
The NEW PATIENT field describes how the patient 
"^DD",798,798,3,21,2,0)
has been added/updated in the registry.
"^DD",798,798,3,23,0)
^^7^7^3020402^
"^DD",798,798,3,23,1,0)
Usually, this field contains 0 or no value at all. The
"^DD",798,798,3,23,2,0)
field is automatically populated by the registry
"^DD",798,798,3,23,3,0)
update, patient reactivation and GUI manual entry
"^DD",798,798,3,23,4,0)
processing.
"^DD",798,798,3,23,5,0)
 
"^DD",798,798,3,23,6,0)
After acknowledgement of the successful processing of
"^DD",798,798,3,23,7,0)
transmitted data the value of this field is deleted.
"^DD",798,798,3,"DT")
3000426
"^DD",798,798,3.1,0)
SELECTION RULE^798.01P^^1;0
"^DD",798,798,3.1,21,0)
^^3^3^3020402^
"^DD",798,798,3.1,21,1,0)
The SELECTION RULE multiple contains a list of
"^DD",798,798,3.1,21,2,0)
selection rules that the patient passed when added
"^DD",798,798,3.1,21,3,0)
to the registry.
"^DD",798,798,3.1,23,0)
^^2^2^3020402^
"^DD",798,798,3.1,23,1,0)
The list is automatically populated by the registry
"^DD",798,798,3.1,23,2,0)
update and the GUI manual patient entry processing.
"^DD",798,798,3.2,0)
SUPPORTING EVIDENCE^*P799.1'X^ROR(799.1,^0;14^S Y=$P($G(^RORDATA(798,DA,0)),U,2),DIC("S")="S D=$G(^(0)) I $P(D,U,2)=2"_$S(Y>0:",$P(D,U,3)="_Y,1:"") D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",798,798,3.2,3)

"^DD",798,798,3.2,12)
Only supporting evidences can be selected.
"^DD",798,798,3.2,12.1)
S DIC("S")="I $P(^(0),U,2)=2"
"^DD",798,798,3.2,21,0)
^.001^2^2^3020402^^^
"^DD",798,798,3.2,21,1,0)
This field indicates a reason for manual addition
"^DD",798,798,3.2,21,2,0)
of the patient to the registry.
"^DD",798,798,3.2,23,0)
^^2^2^3020402^
"^DD",798,798,3.2,23,1,0)
The HEPC SUPPORT EVIDENCE field is only ever populated
"^DD",798,798,3.2,23,2,0)
via the GUI manual entry option.
"^DD",798,798,3.2,"DT")
3011009
"^DD",798,798,4,0)
UPDATE DEMOGRAPHICS^S^0:NO;1:YES;^0;6^Q
"^DD",798,798,4,21,0)
^^3^3^3020402^
"^DD",798,798,4,21,1,0)
Usually, you should not edit this field. Set a 
"^DD",798,798,4,21,2,0)
value of this field to "Yes" if you want the
"^DD",798,798,4,21,3,0)
patient demographic data to be sent to AAC.
"^DD",798,798,4,23,0)
^^12^12^3020402^
"^DD",798,798,4,23,1,0)
During the registry update, demographic fields of each
"^DD",798,798,4,23,2,0)
record of the ROR PATIENT file are compared with
"^DD",798,798,4,23,3,0)
corresponding fields of the PATIENT file.
"^DD",798,798,4,23,4,0)
 
"^DD",798,798,4,23,5,0)
If some of the fields have different values, an 
"^DD",798,798,4,23,6,0)
internal value of 1 is assigned to the UPDATE
"^DD",798,798,4,23,7,0)
DEMOGRAPHICS field of all active patient records in 
"^DD",798,798,4,23,8,0)
local registries. As a result, demographic data is
"^DD",798,798,4,23,9,0)
transmitted to the national registries.
"^DD",798,798,4,23,10,0)
 
"^DD",798,798,4,23,11,0)
After acknowledgement of the successful processing of
"^DD",798,798,4,23,12,0)
transmitted data the value of this field is deleted.
"^DD",798,798,4,"DT")
3000323
"^DD",798,798,5,0)
UPDATE LOCAL REGISTRY DATA^S^0:NO;1:YES;^0;7^Q
"^DD",798,798,5,21,0)
^^4^4^3020402^
"^DD",798,798,5,21,1,0)
Usually, you should not edit this field. Set a 
"^DD",798,798,5,21,2,0)
value of this field to "Yes" if you have changed
"^DD",798,798,5,21,3,0)
any local registry data of the patient and want 
"^DD",798,798,5,21,4,0)
this data to be sent to AAC.
"^DD",798,798,5,23,0)
^^8^8^3020402^
"^DD",798,798,5,23,1,0)
Any changes of local registry data result in assignment
"^DD",798,798,5,23,2,0)
of 1 as an internal value of the UPDATE LOCAL REGISTRY
"^DD",798,798,5,23,3,0)
DATA field (by registry update process or remote
"^DD",798,798,5,23,4,0)
procedures). This is an indication to transmit local
"^DD",798,798,5,23,5,0)
data to the national registry.
"^DD",798,798,5,23,6,0)
 
"^DD",798,798,5,23,7,0)
After acknowledgement of the successful processing of
"^DD",798,798,5,23,8,0)
transmitted data the value of this field is deleted.
"^DD",798,798,5,"DT")
3000327
"^DD",798,798,6,0)
INVESTIGATIONAL DRUGS^S^0:NO;1:YES;^0;8^Q
"^DD",798,798,6,21,0)
^^3^3^3020402^
"^DD",798,798,6,21,1,0)
Set this field to "Yes" if any investigational 
"^DD",798,798,6,21,2,0)
drugs related to the registry are/were used in
"^DD",798,798,6,21,3,0)
the treatment of the patient.
"^DD",798,798,6,23,0)
^^6^6^3020402^
"^DD",798,798,6,23,1,0)
The internal value of 1 in the INVESTIGATIONAL DRUGS
"^DD",798,798,6,23,2,0)
field indicates that these drugs are used in the
"^DD",798,798,6,23,3,0)
treatment of the patient.
"^DD",798,798,6,23,4,0)
 
"^DD",798,798,6,23,5,0)
Value of this field is controlled by a user (via
"^DD",798,798,6,23,6,0)
the corresponding check-box in the GUI).
"^DD",798,798,6,"DT")
3000327
"^DD",798,798,6.1,0)
MEDICATION IN PROFILE^S^0:NO;1:YES;^0;9^Q
"^DD",798,798,6.1,21,0)
^^3^3^3020402^
"^DD",798,798,6.1,21,1,0)
Enter "Yes" if the drugs that the patient is
"^DD",798,798,6.1,21,2,0)
currently taking are in the medication profile
"^DD",798,798,6.1,21,3,0)
that exists within VistA or CPRS.
"^DD",798,798,6.1,23,0)
^.001^2^2^3020402^^^
"^DD",798,798,6.1,23,1,0)
Value of this field is controlled by a user (via
"^DD",798,798,6.1,23,2,0)
the corresponding check-box in the GUI).
"^DD",798,798,6.1,"DT")
3000327
"^DD",798,798,7,0)
REACTIVATION DATE^DX^^0;11^S %DT="ESTX" K Y S:$G(DIUTIL)'="VERIFY FIELDS" Y(9.2)=$P($G(^RORDATA(798,DA,2)),U,2),Y(2)=$P($G(^(0)),U,4),Y=$S(Y(9.2)>Y(2):Y(9.2),1:Y(2)) S:$G(Y)>0 %DT(0)=Y D ^%DT S X=Y K:(Y<1)!(Y>$$NOW^XLFDT) X K %DT,Y
"^DD",798,798,7,3)
Enter the reactivation date for the patient.
"^DD",798,798,7,4)

"^DD",798,798,7,21,0)
^^7^7^3020402^
"^DD",798,798,7,21,1,0)
The REACTIVATION DATE field contains a date/time
"^DD",798,798,7,21,2,0)
of the latest reactivation of the patient in the
"^DD",798,798,7,21,3,0)
registry.
"^DD",798,798,7,21,4,0)
 
"^DD",798,798,7,21,5,0)
The new reactivation date cannot be earlier than 
"^DD",798,798,7,21,6,0)
the date of the latest data extract or the date of
"^DD",798,798,7,21,7,0)
inactivation. You cannot enter a future date.
"^DD",798,798,7,23,0)
^^5^5^3020402^
"^DD",798,798,7,23,1,0)
You must evaluate both REACTIVATION DATE and 
"^DD",798,798,7,23,2,0)
INACTIVATION DATE fields along with the current 
"^DD",798,798,7,23,3,0)
date/time to determine whether the patient record is
"^DD",798,798,7,23,4,0)
active or not. See the description of the ACTIVE
"^DD",798,798,7,23,5,0)
computed field (#798, 8) for further details.
"^DD",798,798,7,"DT")
3011011
"^DD",798,798,7.1,0)
REACTIVATED BY^P200'^VA(200,^0;12^Q
"^DD",798,798,7.1,21,0)
^^2^2^3020402^
"^DD",798,798,7.1,21,1,0)
The REACTIVATED BY field identifies a person who
"^DD",798,798,7.1,21,2,0)
last re-activated the patient.
"^DD",798,798,7.1,23,0)
^.001^2^2^3020402^^
"^DD",798,798,7.1,23,1,0)
This field is automatically populated by the 
"^DD",798,798,7.1,23,2,0)
re-activation processing within the GUI.
"^DD",798,798,7.1,"DT")
3000504
"^DD",798,798,8,0)
ACTIVE^CJ1,0^^ ; ^S Y(0)=$G(^RORDATA(798,D0,0)),X=$$ACTIVE^RORDD($P(Y(0),U,4),$P(Y(0),U,11))
"^DD",798,798,8,9)
^
"^DD",798,798,8,9.01)

"^DD",798,798,8,9.1)
S Y(0)=$G(^RORDATA(798,D0,0)),X=$$ACTIVE^RORDD($P(Y(0),U,4),$P(Y(0),U,11))
"^DD",798,798,8,21,0)
^.001^3^3^3020409^^^^
"^DD",798,798,8,21,1,0)
This is a computed field that indicates the 
"^DD",798,798,8,21,2,0)
current status of the patient in the local
"^DD",798,798,8,21,3,0)
registry.
"^DD",798,798,8,23,0)
^.001^8^8^3020409^^
"^DD",798,798,8,23,1,0)
Patient is active if there is no inactivation date. 
"^DD",798,798,8,23,2,0)
Otherwise, the patient is active only if:
"^DD",798,798,8,23,3,0)
 
"^DD",798,798,8,23,4,0)
 (INACTIVATION DATE > NOW) or 
"^DD",798,798,8,23,5,0)
 (INACTIVATION DATE < REACTIVATION DATE)
"^DD",798,798,8,23,6,0)
 
"^DD",798,798,8,23,7,0)
Please, remember that REACTIVATION DATE cannot be in 
"^DD",798,798,8,23,8,0)
the future.
"^DD",798,798,8,"DT")
3011011
"^DD",798,798,9.1,0)
DATA ACKNOWLEDGED UNTIL^D^^2;1^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798,9.1,21,0)
^^3^3^3020402^
"^DD",798,798,9.1,21,1,0)
The DATA ACKNOWLEDGED UNTIL field contains a date
"^DD",798,798,9.1,21,2,0)
that the patient data has been extracted until,
"^DD",798,798,9.1,21,3,0)
successfully transmitted and acknowledged.
"^DD",798,798,9.1,23,0)
^^7^7^3020402^
"^DD",798,798,9.1,23,1,0)
A regular data extraction for the patient in the 
"^DD",798,798,9.1,23,2,0)
registry starts from this date.
"^DD",798,798,9.1,23,3,0)
 
"^DD",798,798,9.1,23,4,0)
Acknowledgement processing copies the value of the
"^DD",798,798,9.1,23,5,0)
DATA EXTRACTED UNTIL field into this field upon
"^DD",798,798,9.1,23,6,0)
receiving and processing the HL7 acknowledgement from 
"^DD",798,798,9.1,23,7,0)
the AAC.
"^DD",798,798,9.1,"DT")
3010830
"^DD",798,798,9.2,0)
DATA EXTRACTED UNTIL^D^^2;2^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798,9.2,21,0)
^.001^3^3^3011004^^
"^DD",798,798,9.2,21,1,0)
This field contains a date that registry data of 
"^DD",798,798,9.2,21,2,0)
the patient has been extracted until, transmitted
"^DD",798,798,9.2,21,3,0)
but not acknowledged yet.
"^DD",798,798,9.2,23,0)
^^8^8^3020402^
"^DD",798,798,9.2,23,1,0)
The field is automatically populated by the regular
"^DD",798,798,9.2,23,2,0)
data extraction process if the data is extracted
"^DD",798,798,9.2,23,3,0)
successfully.
"^DD",798,798,9.2,23,4,0)
 
"^DD",798,798,9.2,23,5,0)
Acknowledgement processing routine copies value of this
"^DD",798,798,9.2,23,6,0)
field into the DATA ACKNOWLEDGED UNTIL field upon
"^DD",798,798,9.2,23,7,0)
receiving and processing HL7 acknowledgement from the
"^DD",798,798,9.2,23,8,0)
AAC.
"^DD",798,798,9.2,"DT")
3010830
"^DD",798,798,10,0)
MESSAGE ID^FX^^2;3^K:X[""""!($A(X)=45) X I $D(X) K:$L(X)>20!(X'?1.E1"-"1.N) X
"^DD",798,798,10,1,0)
^.1
"^DD",798,798,10,1,1,0)
798^AM
"^DD",798,798,10,1,1,1)
S ^RORDATA(798,"AM",$E(X,1,30),DA)=""
"^DD",798,798,10,1,1,2)
K ^RORDATA(798,"AM",$E(X,1,30),DA)
"^DD",798,798,10,1,1,3)
Do not delete!
"^DD",798,798,10,1,1,"%D",0)
^^3^3^3011005^
"^DD",798,798,10,1,1,"%D",1,0)
The cross-reference allows to find a patient 
"^DD",798,798,10,1,1,"%D",2,0)
record in the registry using an ID of an HL7
"^DD",798,798,10,1,1,"%D",3,0)
message sent to the national registry.
"^DD",798,798,10,1,1,"DT")
3010824
"^DD",798,798,10,3)
The unique ID of the latest HL7 message (1-20 characters).
"^DD",798,798,10,21,0)
^^8^8^3020402^
"^DD",798,798,10,21,1,0)
The MESSAGE ID field contains an identifier of 
"^DD",798,798,10,21,2,0)
the latest individual HL7 message created for this
"^DD",798,798,10,21,3,0)
registry record.
"^DD",798,798,10,21,4,0)
 
"^DD",798,798,10,21,5,0)
Value of this field should have the following
"^DD",798,798,10,21,6,0)
format: BatchID-N, where BatchID is an ID of an
"^DD",798,798,10,21,7,0)
HL7 batch message, and N is a sequential number of
"^DD",798,798,10,21,8,0)
the message in the batch.
"^DD",798,798,10,23,0)
^.001^3^3^3020402^^^
"^DD",798,798,10,23,1,0)
This field is automatically populated by the regular
"^DD",798,798,10,23,2,0)
data extraction process every time an HL7 message is
"^DD",798,798,10,23,3,0)
generated.
"^DD",798,798,10,"DT")
3011005
"^DD",798,798,11,0)
DON'T SEND^S^0:NO;1:YES;^2;4^Q
"^DD",798,798,11,21,0)
^^3^3^3020402^
"^DD",798,798,11,21,1,0)
Set this field to "Yes" if you do not want any 
"^DD",798,798,11,21,2,0)
data to be sent to the national registry for this
"^DD",798,798,11,21,3,0)
record.
"^DD",798,798,11,23,0)
^^4^4^3020402^
"^DD",798,798,11,23,1,0)
Usually, this field is populated only automatically by
"^DD",798,798,11,23,2,0)
the registry update processing if a patient is defined
"^DD",798,798,11,23,3,0)
in the PATIENT file as a "test patient" (internal value
"^DD",798,798,11,23,4,0)
of the TEST PATIENT INDICATOR field equals to 1).
"^DD",798,798,11,"DT")
3010919
"^DD",798,798.01,0)
SELECTION RULE SUB-FIELD^^1^2
"^DD",798,798.01,0,"DT")
3011009
"^DD",798,798.01,0,"IX","AD",798.01,1)

"^DD",798,798.01,0,"IX","B",798.01,.01)

"^DD",798,798.01,0,"NM","SELECTION RULE")

"^DD",798,798.01,0,"UP")
798
"^DD",798,798.01,.01,0)
SELECTION RULE^MP798.2'^ROR(798.2,^0;1^Q
"^DD",798,798.01,.01,1,0)
^.1
"^DD",798,798.01,.01,1,1,0)
798.01^B
"^DD",798,798.01,.01,1,1,1)
S ^RORDATA(798,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",798,798.01,.01,1,1,2)
K ^RORDATA(798,DA(1),1,"B",$E(X,1,30),DA)
"^DD",798,798.01,.01,1,1,3)
Do not delete!
"^DD",798,798.01,.01,21,0)
^.001^2^2^3011009^^
"^DD",798,798.01,.01,21,1,0)
This field identifies the selection rule that has 
"^DD",798,798.01,.01,21,2,0)
caused addition of the patient to the registry.
"^DD",798,798.01,.01,"DT")
3011009
"^DD",798,798.01,1,0)
DATE^D^^0;2^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798.01,1,1,0)
^.1
"^DD",798,798.01,1,1,1,0)
798.01^AD
"^DD",798,798.01,1,1,1,1)
S ^RORDATA(798,DA(1),1,"AD",$E(X,1,30),DA)=""
"^DD",798,798.01,1,1,1,2)
K ^RORDATA(798,DA(1),1,"AD",$E(X,1,30),DA)
"^DD",798,798.01,1,1,1,3)
Do not delete!
"^DD",798,798.01,1,1,1,"DT")
3000426
"^DD",798,798.01,1,21,0)
^^2^2^3020402^
"^DD",798,798.01,1,21,1,0)
The DATE field contains the date when the patient
"^DD",798,798.01,1,21,2,0)
passed the rule for the first time.
"^DD",798,798.01,1,"DT")
3000426
"^DD",798.1,798.1,0)
FIELD^^21.04^33
"^DD",798.1,798.1,0,"DDA")
N
"^DD",798.1,798.1,0,"DT")
3020508
"^DD",798.1,798.1,0,"ID","WRITE")
D EN^DDIOL("  "_$P($G(^(0)),U,4),,"?30")
"^DD",798.1,798.1,0,"IX","AEP",798.1,25)

"^DD",798.1,798.1,0,"IX","AM",798.1,2.3)

"^DD",798.1,798.1,0,"IX","ARULES",798.13,.01)

"^DD",798.1,798.1,0,"NM","ROR REGISTRY PARAMETERS")

"^DD",798.1,798.1,0,"PT",798,.02)

"^DD",798.1,798.1,0,"PT",798.31,.01)

"^DD",798.1,798.1,0,"PT",798.5,.02)

"^DD",798.1,798.1,0,"PT",798.6,.02)

"^DD",798.1,798.1,0,"PT",798.73,.01)

"^DD",798.1,798.1,0,"PT",799.1,.03)

"^DD",798.1,798.1,0,"VRPK")
ROR
"^DD",798.1,798.1,.01,0)
REGISTRY NAME^RFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA))  K:$L(X)>30!($L(X)<3)!'(X?1.UNP) X
"^DD",798.1,798.1,.01,1,0)
^.1^^0
"^DD",798.1,798.1,.01,3)
Enter the unique registry name (3-30 characters).
"^DD",798.1,798.1,.01,8.5)
@
"^DD",798.1,798.1,.01,9)
@
"^DD",798.1,798.1,.01,21,0)
^.001^6^6^3011112^^^^
"^DD",798.1,798.1,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,.01,21,3,0)
 
"^DD",798.1,798.1,.01,21,4,0)
You can either select an existing registry or add 
"^DD",798.1,798.1,.01,21,5,0)
a new one. Registry names must be unique. Names of
"^DD",798.1,798.1,.01,21,6,0)
the National registries must start with "VA".
"^DD",798.1,798.1,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,.01,"DT")
3011112
"^DD",798.1,798.1,.09,0)
NATIONAL^SX^0:NO;1:YES;^0;11^Q:$$VAEDT^RORDD(798.1,,-1)
"^DD",798.1,798.1,.09,8.5)
@
"^DD",798.1,798.1,.09,9)
@
"^DD",798.1,798.1,.09,21,0)
^^6^6^3020403^
"^DD",798.1,798.1,.09,21,1,0)
ONLY AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN
"^DD",798.1,798.1,.09,21,2,0)
EDIT THIS FIELD!
"^DD",798.1,798.1,.09,21,3,0)
 
"^DD",798.1,798.1,.09,21,4,0)
The national registries must have this field set
"^DD",798.1,798.1,.09,21,5,0)
to "Yes". This prevents local editing of other 
"^DD",798.1,798.1,.09,21,6,0)
fields of national registry definitions.
"^DD",798.1,798.1,.09,"DEL",1,0)
I $$VADEL^RORDD(798.1,,-1)
"^DD",798.1,798.1,.09,"DT")
3011120
"^DD",798.1,798.1,1,0)
REGISTRY UPDATED UNTIL^D^^0;2^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,1,21,0)
^^9^9^3020403^
"^DD",798.1,798.1,1,21,1,0)
This field indicates the date of the last 
"^DD",798.1,798.1,1,21,2,0)
successful run of the regular registry update
"^DD",798.1,798.1,1,21,3,0)
process. The search engine looks for new patients
"^DD",798.1,798.1,1,21,4,0)
starting from this date.
"^DD",798.1,798.1,1,21,5,0)
 
"^DD",798.1,798.1,1,21,6,0)
Usually, this field should not be manually edited;
"^DD",798.1,798.1,1,21,7,0)
it is updated automatically. Before initial
"^DD",798.1,798.1,1,21,8,0)
population of the registry enter the date that the
"^DD",798.1,798.1,1,21,9,0)
data search should start from.
"^DD",798.1,798.1,1,23,0)
^^3^3^3020403^
"^DD",798.1,798.1,1,23,1,0)
This field is updated automatically by the registry 
"^DD",798.1,798.1,1,23,2,0)
update process after successful completion (see the 
"^DD",798.1,798.1,1,23,3,0)
$$TMSTMP^RORUPD01 function for details).
"^DD",798.1,798.1,1,"DT")
3010928
"^DD",798.1,798.1,2,0)
DATA EXTRACTED UNTIL^D^^0;3^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,2,21,0)
^^3^3^3011005^
"^DD",798.1,798.1,2,21,1,0)
This field indicates the date of the last 
"^DD",798.1,798.1,2,21,2,0)
successful run of the regular data extraction
"^DD",798.1,798.1,2,21,3,0)
process. Do not edit this field.
"^DD",798.1,798.1,2,23,0)
^^3^3^3020403^
"^DD",798.1,798.1,2,23,1,0)
This field is updated automatically by the regular data
"^DD",798.1,798.1,2,23,2,0)
extraction process after its successful completion (see
"^DD",798.1,798.1,2,23,3,0)
the $$TMSTMP^ROREXTUT function for details).
"^DD",798.1,798.1,2,"DT")
3010928
"^DD",798.1,798.1,2.1,0)
LAST BATCH ID^FXI^^0;8^K:X[""""!($A(X)=45) X I $D(X) K:$L(X)>20!($L(X)<1) X
"^DD",798.1,798.1,2.1,3)
The unique ID of the latest batch HL7 message (1-20 characters).
"^DD",798.1,798.1,2.1,8.5)
@
"^DD",798.1,798.1,2.1,9)
@
"^DD",798.1,798.1,2.1,21,0)
^.001^7^7^3020403^^
"^DD",798.1,798.1,2.1,21,1,0)
This field contains an identifier of the latest
"^DD",798.1,798.1,2.1,21,2,0)
batch HL7 message created for the registry.
"^DD",798.1,798.1,2.1,21,3,0)
 
"^DD",798.1,798.1,2.1,21,4,0)
Control ID of each individual messages of the
"^DD",798.1,798.1,2.1,21,5,0)
batch is constructed from the value of this field
"^DD",798.1,798.1,2.1,21,6,0)
and a sequential number separated by the '-' 
"^DD",798.1,798.1,2.1,21,7,0)
character.
"^DD",798.1,798.1,2.1,23,0)
^^8^8^3020403^
"^DD",798.1,798.1,2.1,23,1,0)
The LAST BATCH ID field is automatically populated by
"^DD",798.1,798.1,2.1,23,2,0)
the regular data extraction process every time a batch
"^DD",798.1,798.1,2.1,23,3,0)
HL7 message is successfully generated for the registry.
"^DD",798.1,798.1,2.1,23,4,0)
 
"^DD",798.1,798.1,2.1,23,5,0)
This field is populated with the message control ID
"^DD",798.1,798.1,2.1,23,6,0)
returned by the CREATE^HLTF procedure (see the 
"^DD",798.1,798.1,2.1,23,7,0)
$$CREATE^RORHL7 and $$TMSTMP^ROREXTUT functions for 
"^DD",798.1,798.1,2.1,23,8,0)
details).
"^DD",798.1,798.1,2.1,"DT")
3011121
"^DD",798.1,798.1,2.2,0)
AWAITING ACKNOWLEDGEMENT^D^^0;9^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,2.2,1,0)
^.1
"^DD",798.1,798.1,2.2,1,1,0)
^^TRIGGER^798.1^2.3
"^DD",798.1,798.1,2.2,1,1,1)
Q
"^DD",798.1,798.1,2.2,1,1,2)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(0)=X S Y(1)=$S($D(^ROR(798.1,D0,0)):^(0),1:"") S X=$P(Y(1),U,9)="" I X S X=DIV S Y(1)=$S($D(^ROR(798.1,D0,0)):^(0),1:"") S X=$P(Y(1),U,13),X=X S DIU=X K Y S X="" X ^DD(798.1,2.2,1,1,2.4)
"^DD",798.1,798.1,2.2,1,1,2.4)
S DIH=$G(^ROR(798.1,DIV(0),0)),DIV=X S $P(^(0),U,13)=DIV,DIH=798.1,DIG=2.3 D ^DICR
"^DD",798.1,798.1,2.2,1,1,3)
Do not delete!
"^DD",798.1,798.1,2.2,1,1,"%D",0)
^^4^4^3020403^
"^DD",798.1,798.1,2.2,1,1,"%D",1,0)
This trigger cleares the LAST MESSAGE ID field
"^DD",798.1,798.1,2.2,1,1,"%D",2,0)
when the AWAITING ACKNOWLEDGEMENT field is
"^DD",798.1,798.1,2.2,1,1,"%D",3,0)
cleared. This guaranties that if the expired 
"^DD",798.1,798.1,2.2,1,1,"%D",4,0)
acknowledgement arrives later, it will be ignored.
"^DD",798.1,798.1,2.2,1,1,"CREATE VALUE")
NO EFFECT
"^DD",798.1,798.1,2.2,1,1,"DELETE CONDITION")
AWAITING ACKNOWLEDGEMENT=""
"^DD",798.1,798.1,2.2,1,1,"DELETE VALUE")
""
"^DD",798.1,798.1,2.2,1,1,"FIELD")
LAST MESSAGE ID
"^DD",798.1,798.1,2.2,3)

"^DD",798.1,798.1,2.2,21,0)
^^14^14^3020401^
"^DD",798.1,798.1,2.2,21,1,0)
This field is set to current date/time after the
"^DD",798.1,798.1,2.2,21,2,0)
data has been successfully sent to the national
"^DD",798.1,798.1,2.2,21,3,0)
registry. Upon successful receiving and processing
"^DD",798.1,798.1,2.2,21,4,0)
of the acknowledgement the value of this field is
"^DD",798.1,798.1,2.2,21,5,0)
deleted.
"^DD",798.1,798.1,2.2,21,6,0)
 
"^DD",798.1,798.1,2.2,21,7,0)
Usually, you should not edit this field. However, 
"^DD",798.1,798.1,2.2,21,8,0)
if some data is sent but the acknowledgement is
"^DD",798.1,798.1,2.2,21,9,0)
not received, no further data transmissions will
"^DD",798.1,798.1,2.2,21,10,0)
take place. If you are absolutely sure that there
"^DD",798.1,798.1,2.2,21,11,0)
will be no acknowledgement from the AAC (for
"^DD",798.1,798.1,2.2,21,12,0)
example, due to a past malfunction), you can
"^DD",798.1,798.1,2.2,21,13,0)
delete the value of this field to resume regular
"^DD",798.1,798.1,2.2,21,14,0)
registry updates and data transmissions.
"^DD",798.1,798.1,2.2,23,0)
^^12^12^3020403^
"^DD",798.1,798.1,2.2,23,1,0)
This field is populated by the regular data extraction
"^DD",798.1,798.1,2.2,23,2,0)
process (see the $$TMSTMP^ROREXTUT function) and
"^DD",798.1,798.1,2.2,23,3,0)
cleared by the acknowledgement processing (see the
"^DD",798.1,798.1,2.2,23,4,0)
$$UPDPARMS^RORACK function) after its successful
"^DD",798.1,798.1,2.2,23,5,0)
completion.
"^DD",798.1,798.1,2.2,23,6,0)
 
"^DD",798.1,798.1,2.2,23,7,0)
Moreover, if the application acknowledgement is not 
"^DD",798.1,798.1,2.2,23,8,0)
received from AAC during the time frame defined by the
"^DD",798.1,798.1,2.2,23,9,0)
value of the DAYS TO WAIT FOR ACK field, the AWAITING 
"^DD",798.1,798.1,2.2,23,10,0)
ACKNOWLEDGEMENT field will be cleared by the regular 
"^DD",798.1,798.1,2.2,23,11,0)
registry update and data extraction task (see the 
"^DD",798.1,798.1,2.2,23,12,0)
$$CLRACK^RORUTL05 function for details).
"^DD",798.1,798.1,2.2,"DT")
3020401
"^DD",798.1,798.1,2.3,0)
LAST MESSAGE ID^FI^^0;13^K:$L(X)>20!($L(X)<1) X
"^DD",798.1,798.1,2.3,1,0)
^.1
"^DD",798.1,798.1,2.3,1,1,0)
798.1^AM
"^DD",798.1,798.1,2.3,1,1,1)
S ^ROR(798.1,"AM",$E(X,1,30),DA)=""
"^DD",798.1,798.1,2.3,1,1,2)
K ^ROR(798.1,"AM",$E(X,1,30),DA)
"^DD",798.1,798.1,2.3,1,1,3)
Do not delete!
"^DD",798.1,798.1,2.3,1,1,"%D",0)
^^6^6^3020403^
"^DD",798.1,798.1,2.3,1,1,"%D",1,0)
The application acknowledgement handler searches
"^DD",798.1,798.1,2.3,1,1,"%D",2,0)
this cross-reference for the reference message ID
"^DD",798.1,798.1,2.3,1,1,"%D",3,0)
(extracted from the header of the application
"^DD",798.1,798.1,2.3,1,1,"%D",4,0)
acknowledgement) to find the parameters of the
"^DD",798.1,798.1,2.3,1,1,"%D",5,0)
registry that generated the original batch HL7
"^DD",798.1,798.1,2.3,1,1,"%D",6,0)
message.
"^DD",798.1,798.1,2.3,1,1,"DT")
3020325
"^DD",798.1,798.1,2.3,3)
The unique ID of the latest batch HL7 message (1-20 characters).
"^DD",798.1,798.1,2.3,5,1,0)
798.1^2.2^1
"^DD",798.1,798.1,2.3,8.5)
@
"^DD",798.1,798.1,2.3,9)
@
"^DD",798.1,798.1,2.3,21,0)
^^5^5^3020403^
"^DD",798.1,798.1,2.3,21,1,0)
This field contains a message control ID of the
"^DD",798.1,798.1,2.3,21,2,0)
latest batch HL7 message sent to AAC.
"^DD",798.1,798.1,2.3,21,3,0)
 
"^DD",798.1,798.1,2.3,21,4,0)
The application acknowledgement from the AAC will
"^DD",798.1,798.1,2.3,21,5,0)
reference this ID.
"^DD",798.1,798.1,2.3,23,0)
^^11^11^3020403^
"^DD",798.1,798.1,2.3,23,1,0)
This field is automatically populated by the regular
"^DD",798.1,798.1,2.3,23,2,0)
data extraction process every time a batch HL7 message
"^DD",798.1,798.1,2.3,23,3,0)
is sent to AAC. 
"^DD",798.1,798.1,2.3,23,4,0)
 
"^DD",798.1,798.1,2.3,23,5,0)
The control message ID returned by the GENERATE^HLMA
"^DD",798.1,798.1,2.3,23,6,0)
procedure is used to poulate this field. This value may
"^DD",798.1,798.1,2.3,23,7,0)
be different from the value of the LAST BATCH ID field.
"^DD",798.1,798.1,2.3,23,8,0)
 
"^DD",798.1,798.1,2.3,23,9,0)
The field is cleared by the application acknowledgement
"^DD",798.1,798.1,2.3,23,10,0)
handler after successful processing of received batch
"^DD",798.1,798.1,2.3,23,11,0)
acknowledgement (see the $$UPDPARMS^RORACK function).
"^DD",798.1,798.1,2.3,"DT")
3020401
"^DD",798.1,798.1,3,0)
SELECTION RULE^798.13^^1;0
"^DD",798.1,798.1,3,9)
@
"^DD",798.1,798.1,3,21,0)
^^8^8^3020403^
"^DD",798.1,798.1,3,21,1,0)
The SELECTION RULE field contains a list of the 
"^DD",798.1,798.1,3,21,2,0)
top-level selection rules that are used to screen
"^DD",798.1,798.1,3,21,3,0)
the patients to be added to the registry.
"^DD",798.1,798.1,3,21,4,0)
 
"^DD",798.1,798.1,3,21,5,0)
The records of the multiple are uniquely 
"^DD",798.1,798.1,3,21,6,0)
identified by the selection rule names. The "A"
"^DD",798.1,798.1,3,21,7,0)
primary key and the uniqueness index "B" are used
"^DD",798.1,798.1,3,21,8,0)
for this purpose.
"^DD",798.1,798.1,4,0)
SHORT DESCRIPTION^RFX^^0;4^Q:$$VAEDT^RORDD(798.1,$G(DA))  K:$L(X)>40!($L(X)<3) X
"^DD",798.1,798.1,4,3)
Enter a short description of the registry (3-40 characters).
"^DD",798.1,798.1,4,8.5)
@
"^DD",798.1,798.1,4,9)
@
"^DD",798.1,798.1,4,21,0)
^.001^2^2^3020403^^
"^DD",798.1,798.1,4,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,4,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,4,"DT")
3011109
"^DD",798.1,798.1,5,0)
DESCRIPTION^798.15^^2;0
"^DD",798.1,798.1,5,21,0)
^.001^2^2^3011009^^^
"^DD",798.1,798.1,5,21,1,0)
Any additional reference information related to
"^DD",798.1,798.1,5,21,2,0)
the registry may be stored in this field.
"^DD",798.1,798.1,5,23,0)
^.001^1^1^3011009^^
"^DD",798.1,798.1,5,23,1,0)
Content of this field is not used by the application.
"^DD",798.1,798.1,6.1,0)
BEFORE UPDATE^FX^^4;E1,245^Q:$$VAEDT^RORDD(798.1,$G(DA))  Q:$$EP^RORDD(3)
"^DD",798.1,798.1,6.1,3)
Answer must be $$TAG^ROUTINE (5-19 characters in length).
"^DD",798.1,798.1,6.1,8.5)
@
"^DD",798.1,798.1,6.1,9)
@
"^DD",798.1,798.1,6.1,21,0)
^.001^7^7^3020424^^
"^DD",798.1,798.1,6.1,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,6.1,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,6.1,21,3,0)
 
"^DD",798.1,798.1,6.1,21,4,0)
Enter a full name ($$TAG^ROUTINE) of the external
"^DD",798.1,798.1,6.1,21,5,0)
MUMPS function that will be called before adding a
"^DD",798.1,798.1,6.1,21,6,0)
new record to the registry. This entry point can
"^DD",798.1,798.1,6.1,21,7,0)
be used to prepare any additional data.
"^DD",798.1,798.1,6.1,23,0)
^.001^20^20^3020424^^
"^DD",798.1,798.1,6.1,23,1,0)
The call-back entry point must accept three parameters:
"^DD",798.1,798.1,6.1,23,2,0)
 
"^DD",798.1,798.1,6.1,23,3,0)
FDA - A reference to a local array that contains 
"^DD",798.1,798.1,6.1,23,4,0)
prepared data (for the UPDATE^DIE FileMan DSB call)
"^DD",798.1,798.1,6.1,23,5,0)
that should be stored as a new record in the ROR LOCAL
"^DD",798.1,798.1,6.1,23,6,0)
REGISTRY (#798) file.
"^DD",798.1,798.1,6.1,23,7,0)
 
"^DD",798.1,798.1,6.1,23,8,0)
The main record uses "+1," placeholder and records of
"^DD",798.1,798.1,6.1,23,9,0)
the SELECTION RULE multiple use placeholders with
"^DD",798.1,798.1,6.1,23,10,0)
numbers starting from 1001.
"^DD",798.1,798.1,6.1,23,11,0)
 
"^DD",798.1,798.1,6.1,23,12,0)
See the source code of the $$ADD^RORUPD50 function and
"^DD",798.1,798.1,6.1,23,13,0)
the FileMan Programmer Manual for further details.
"^DD",798.1,798.1,6.1,23,14,0)
 
"^DD",798.1,798.1,6.1,23,15,0)
PATIEN - Patient IEN (in the file #2)
"^DD",798.1,798.1,6.1,23,16,0)
 
"^DD",798.1,798.1,6.1,23,17,0)
REGIEN - Registry IEN (in the file #798.1)
"^DD",798.1,798.1,6.1,23,18,0)
 
"^DD",798.1,798.1,6.1,23,19,0)
The function should return a negative number in case of
"^DD",798.1,798.1,6.1,23,20,0)
errors. Otherwise, zero should be returned.
"^DD",798.1,798.1,6.1,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,6.1,"DT")
3011120
"^DD",798.1,798.1,6.2,0)
AFTER UPDATE^FX^^5;E1,245^Q:$$VAEDT^RORDD(798.1,$G(DA))  Q:$$EP^RORDD(3)
"^DD",798.1,798.1,6.2,3)
Answer must be $$TAG^ROUTINE (5-19 characters in length).
"^DD",798.1,798.1,6.2,8.5)
@
"^DD",798.1,798.1,6.2,9)
@
"^DD",798.1,798.1,6.2,21,0)
^^8^8^3020403^
"^DD",798.1,798.1,6.2,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,6.2,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,6.2,21,3,0)
 
"^DD",798.1,798.1,6.2,21,4,0)
Enter a full name ($$TAG^ROUTINE) of the external
"^DD",798.1,798.1,6.2,21,5,0)
MUMPS function that will be called after adding a
"^DD",798.1,798.1,6.2,21,6,0)
new record to the registry. This entry point can
"^DD",798.1,798.1,6.2,21,7,0)
be used to create record(s) in additional linked
"^DD",798.1,798.1,6.2,21,8,0)
file(s) of the local registry.
"^DD",798.1,798.1,6.2,23,0)
^^11^11^3020403^
"^DD",798.1,798.1,6.2,23,1,0)
The call-back function must accept three parameters:
"^DD",798.1,798.1,6.2,23,2,0)
 
"^DD",798.1,798.1,6.2,23,3,0)
IEN - An IEN of the newly added record of the ROR LOCAL
"^DD",798.1,798.1,6.2,23,4,0)
REGISTRY file
"^DD",798.1,798.1,6.2,23,5,0)
 
"^DD",798.1,798.1,6.2,23,6,0)
PATIEN - Patient IEN (in file #2)
"^DD",798.1,798.1,6.2,23,7,0)
 
"^DD",798.1,798.1,6.2,23,8,0)
REGIEN - Registry IEN (in file #798.1)
"^DD",798.1,798.1,6.2,23,9,0)
 
"^DD",798.1,798.1,6.2,23,10,0)
The function should return a negative number in case of
"^DD",798.1,798.1,6.2,23,11,0)
errors. Otherwise, zero should be returned.
"^DD",798.1,798.1,6.2,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,6.2,"DT")
3011120
"^DD",798.1,798.1,7,0)
EXTRACT PERIOD FOR NEW PATIENT^NJ4,0X^^0;5^Q:$$VAEDT^RORDD(798.1,$G(DA))  K:+X'=X!(X>3650)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,7,3)
Enter number of days between 1 and 3650.
"^DD",798.1,798.1,7,8.5)
@
"^DD",798.1,798.1,7,9)
@
"^DD",798.1,798.1,7,21,0)
^^11^11^3020404^
"^DD",798.1,798.1,7,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,7,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,7,21,3,0)
 
"^DD",798.1,798.1,7,21,4,0)
Enter the number of days that should be subtracted
"^DD",798.1,798.1,7,21,5,0)
from the earliest date when the patient passed one
"^DD",798.1,798.1,7,21,6,0)
of the selection rules. The result will be used as
"^DD",798.1,798.1,7,21,7,0)
the start date of the data extraction for this new
"^DD",798.1,798.1,7,21,8,0)
patient.
"^DD",798.1,798.1,7,21,9,0)
 
"^DD",798.1,798.1,7,21,10,0)
If this field is empty, the default value of 3650
"^DD",798.1,798.1,7,21,11,0)
is used.
"^DD",798.1,798.1,7,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,7,"DT")
3011109
"^DD",798.1,798.1,7,"V",0)
^.12P
"^DD",798.1,798.1,8,0)
ENABLE LOG^S^0:NO;1:YES;^0;6^Q
"^DD",798.1,798.1,8,21,0)
^^3^3^3020403^
"^DD",798.1,798.1,8,21,1,0)
Select "Yes" to enable recording of different 
"^DD",798.1,798.1,8,21,2,0)
kinds of events (debug messages, errors, etc.)
"^DD",798.1,798.1,8,21,3,0)
generated by registry processes.
"^DD",798.1,798.1,8,23,0)
^^10^10^3020403^
"^DD",798.1,798.1,8,23,1,0)
The ENABLE LOG field controls recording of the errors
"^DD",798.1,798.1,8,23,2,0)
and other events in the log file.
"^DD",798.1,798.1,8,23,3,0)
 
"^DD",798.1,798.1,8,23,4,0)
If internal value of the field is 0 or the field is 
"^DD",798.1,798.1,8,23,5,0)
empty, the recording of all events associated with the
"^DD",798.1,798.1,8,23,6,0)
registry is disabled.
"^DD",798.1,798.1,8,23,7,0)
 
"^DD",798.1,798.1,8,23,8,0)
If internal value of the field is 1, content of the
"^DD",798.1,798.1,8,23,9,0)
LOG EVENTS multiple is analyzed to determine which
"^DD",798.1,798.1,8,23,10,0)
events (errors, warnings, etc.) should be recorded.
"^DD",798.1,798.1,8,"DT")
3000503
"^DD",798.1,798.1,8.1,0)
LOG EVENTS^798.11S^^3;0
"^DD",798.1,798.1,8.1,21,0)
^^8^8^3020403^
"^DD",798.1,798.1,8.1,21,1,0)
The LOG EVENTS multiple contain a list of event 
"^DD",798.1,798.1,8.1,21,2,0)
types that are enabled to record. 
"^DD",798.1,798.1,8.1,21,3,0)
 
"^DD",798.1,798.1,8.1,21,4,0)
If the list is empty and recording is enabled, 
"^DD",798.1,798.1,8.1,21,5,0)
all events except debug messages will be recorded.
"^DD",798.1,798.1,8.1,21,6,0)
 
"^DD",798.1,798.1,8.1,21,7,0)
Otherwise, only recording of the events from the
"^DD",798.1,798.1,8.1,21,8,0)
list and error messages will be enabled.
"^DD",798.1,798.1,9,0)
HL7 SEGMENT^798.19I^^6;0
"^DD",798.1,798.1,9,9)
@
"^DD",798.1,798.1,9,21,0)
^^16^16^3020403^
"^DD",798.1,798.1,9,21,1,0)
This multiple contains a list of segments that the
"^DD",798.1,798.1,9,21,2,0)
registry HL7 message is composed from. 
"^DD",798.1,798.1,9,21,3,0)
 
"^DD",798.1,798.1,9,21,4,0)
Records of the multiple are uniquely identified by
"^DD",798.1,798.1,9,21,5,0)
the data area code and segment name. The "A" 
"^DD",798.1,798.1,9,21,6,0)
primary key and uniqueness index "KEY" are used
"^DD",798.1,798.1,9,21,7,0)
for this purpose.
"^DD",798.1,798.1,9,21,8,0)
 
"^DD",798.1,798.1,9,21,9,0)
The general structure of the message is hard-coded
"^DD",798.1,798.1,9,21,10,0)
in the message builder (either default or defined
"^DD",798.1,798.1,9,21,11,0)
by the MESSAGE BUILDER field) but you can exclude
"^DD",798.1,798.1,9,21,12,0)
some segments (or fields) from the message by
"^DD",798.1,798.1,9,21,13,0)
deleting them from this list.
"^DD",798.1,798.1,9,21,14,0)
 
"^DD",798.1,798.1,9,21,15,0)
See the source code of the $$MESSAGE^ROREXT02
"^DD",798.1,798.1,9,21,16,0)
function for the further details.
"^DD",798.1,798.1,10,0)
MESSAGE BUILDER^FX^^7;E1,245^Q:$$VAEDT^RORDD(798.1,$G(DA))  Q:$$EP^RORDD(4)
"^DD",798.1,798.1,10,3)
Answer must be $$TAG^ROUTINE (5-19 characters in length).
"^DD",798.1,798.1,10,8.5)
@
"^DD",798.1,798.1,10,9)
@
"^DD",798.1,798.1,10,21,0)
^^9^9^3020403^
"^DD",798.1,798.1,10,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,10,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,10,21,3,0)
 
"^DD",798.1,798.1,10,21,4,0)
Enter a full name ($$TAG^ROUTINE) of the external 
"^DD",798.1,798.1,10,21,5,0)
MUMPS function that will be called to generate the
"^DD",798.1,798.1,10,21,6,0)
HL7 message for each record of the registry.
"^DD",798.1,798.1,10,21,7,0)
 
"^DD",798.1,798.1,10,21,8,0)
If this field has no value, the default entry 
"^DD",798.1,798.1,10,21,9,0)
point ($$MESSAGE^ROREXT02) will be used.
"^DD",798.1,798.1,10,23,0)
^^23^23^3020403^
"^DD",798.1,798.1,10,23,1,0)
The call-back function must accept four parameters:
"^DD",798.1,798.1,10,23,2,0)
 
"^DD",798.1,798.1,10,23,3,0)
IEN - IEN of the registry record
"^DD",798.1,798.1,10,23,4,0)
 
"^DD",798.1,798.1,10,23,5,0)
PATIEN - Patient IEN (in the file #2)
"^DD",798.1,798.1,10,23,6,0)
 
"^DD",798.1,798.1,10,23,7,0)
STDT - Extract the data from this date
"^DD",798.1,798.1,10,23,8,0)
 
"^DD",798.1,798.1,10,23,9,0)
ENDT - Extract the data until this date
"^DD",798.1,798.1,10,23,10,0)
 
"^DD",798.1,798.1,10,23,11,0)
The function should add the text of the HL7 message 
"^DD",798.1,798.1,10,23,12,0)
after already existing nodes in the standard location:
"^DD",798.1,798.1,10,23,13,0)
^TMP("HLS",$J). DO NOT KILL THIS NODE! It contains the
"^DD",798.1,798.1,10,23,14,0)
previous messages of the batch.
"^DD",798.1,798.1,10,23,15,0)
 
"^DD",798.1,798.1,10,23,16,0)
If the message was generated successfully, the function
"^DD",798.1,798.1,10,23,17,0)
should return zero. Otherwise, either a negative error
"^DD",798.1,798.1,10,23,18,0)
code (in case of an error) or a positive value (if the
"^DD",798.1,798.1,10,23,19,0)
message should be discarded for some reason) must be
"^DD",798.1,798.1,10,23,20,0)
returned. 
"^DD",798.1,798.1,10,23,21,0)
                                                                    
"^DD",798.1,798.1,10,23,22,0)
See the source code of the $$MESSAGE^ROREXT02 function 
"^DD",798.1,798.1,10,23,23,0)
for further details.
"^DD",798.1,798.1,10,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,10,"DT")
3011120
"^DD",798.1,798.1,11,0)
REGISTRY STATUS^S^0:ACTIVE;1:INACTIVE;^0;7^Q
"^DD",798.1,798.1,11,1,0)
^.1^^0
"^DD",798.1,798.1,11,21,0)
^^3^3^3020403^
"^DD",798.1,798.1,11,21,1,0)
Select the "INACTIVE" code if you want to exclude
"^DD",798.1,798.1,11,21,2,0)
the registry from the regular registry updates and
"^DD",798.1,798.1,11,21,3,0)
data transmissions.
"^DD",798.1,798.1,11,"DT")
3020424
"^DD",798.1,798.1,12,0)
EXTRACTED RESULT^798.112I^^8;0
"^DD",798.1,798.1,12,9)
@
"^DD",798.1,798.1,12,21,0)
^^3^3^3011012^
"^DD",798.1,798.1,12,21,1,0)
This multiple contains a list of Lab result codes.
"^DD",798.1,798.1,12,21,2,0)
These results will be extracted and transmitted to
"^DD",798.1,798.1,12,21,3,0)
AAC.
"^DD",798.1,798.1,12,"DT")
3010629
"^DD",798.1,798.1,13,0)
PROTOCOL^*P101'X^ORD(101,^9;1^Q:$$VAEDT^RORDD(798.1,$G(DA))  S DIC("S")="S D=$G(^(0)) I $E($P(D,U),1,3)=""ROR"",$P(D,U,4)=""E""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",798.1,798.1,13,3)

"^DD",798.1,798.1,13,8.5)
@
"^DD",798.1,798.1,13,9)
@
"^DD",798.1,798.1,13,12)
Only Event Drivers from the "ROR" namespace can be selected!
"^DD",798.1,798.1,13,12.1)
S DIC("S")="S D=$G(^(0)) I $E($P(D,U),1,3)=""ROR"",$P(D,U,4)=""E"""
"^DD",798.1,798.1,13,21,0)
^^6^6^3020403^
"^DD",798.1,798.1,13,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.1,798.1,13,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,13,21,3,0)
 
"^DD",798.1,798.1,13,21,4,0)
This field contains a pointer to the protocol in 
"^DD",798.1,798.1,13,21,5,0)
the PROTOCOL file that is used as the event driver
"^DD",798.1,798.1,13,21,6,0)
for sending HL7 messages.
"^DD",798.1,798.1,13,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,13,"DT")
3011112
"^DD",798.1,798.1,14,0)
COORDINATOR^798.114P^^10;0
"^DD",798.1,798.1,14,21,0)
^^2^2^3011012^
"^DD",798.1,798.1,14,21,1,0)
This multiple contains a list of the registry 
"^DD",798.1,798.1,14,21,2,0)
coordinators.
"^DD",798.1,798.1,15.1,0)
LAG DAYS^NJ1,0^^11;1^K:+X'=X!(X>7)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,15.1,3)
Enter number of days between 1 and 7.
"^DD",798.1,798.1,15.1,21,0)
^.001^12^12^3020426^^
"^DD",798.1,798.1,15.1,21,1,0)
Number of days that defines an overlap of the data
"^DD",798.1,798.1,15.1,21,2,0)
searches during the registry updates and a data
"^DD",798.1,798.1,15.1,21,3,0)
extraction delay during the regular data
"^DD",798.1,798.1,15.1,21,4,0)
extractions.
"^DD",798.1,798.1,15.1,21,5,0)
 
"^DD",798.1,798.1,15.1,21,6,0)
If this field is empty, the default value of 1 is 
"^DD",798.1,798.1,15.1,21,7,0)
used by the registry update and data extraction
"^DD",798.1,798.1,15.1,21,8,0)
processes.
"^DD",798.1,798.1,15.1,21,9,0)
 
"^DD",798.1,798.1,15.1,21,10,0)
See the package documentation or Technical
"^DD",798.1,798.1,15.1,21,11,0)
Description of the field in the data dictionary
"^DD",798.1,798.1,15.1,21,12,0)
for more information.
"^DD",798.1,798.1,15.1,23,0)
^.001^37^37^3020426^^
"^DD",798.1,798.1,15.1,23,1,0)
Clinical data may be entered to the VistA system later
"^DD",798.1,798.1,15.1,23,2,0)
than they are available. For example, an encounter that
"^DD",798.1,798.1,15.1,23,3,0)
occurred today may not get entered into the system
"^DD",798.1,798.1,15.1,23,4,0)
until tomorrow.
"^DD",798.1,798.1,15.1,23,5,0)
 
"^DD",798.1,798.1,15.1,23,6,0)
Because of this data may be missed by the registry
"^DD",798.1,798.1,15.1,23,7,0)
update and data extraction processes if they look for
"^DD",798.1,798.1,15.1,23,8,0)
the data until the current date and then continue from
"^DD",798.1,798.1,15.1,23,9,0)
that point next time.
"^DD",798.1,798.1,15.1,23,10,0)
 
"^DD",798.1,798.1,15.1,23,11,0)
To avoid this problem data search intervals are 
"^DD",798.1,798.1,15.1,23,12,0)
overlapped by the number of days indicated by this 
"^DD",798.1,798.1,15.1,23,13,0)
field. The registry update process looks for new data 
"^DD",798.1,798.1,15.1,23,14,0)
not from the end date of its previous run but from the 
"^DD",798.1,798.1,15.1,23,15,0)
date that is earlier by the number of days from this 
"^DD",798.1,798.1,15.1,23,16,0)
field. This overlap increases chances of the data
"^DD",798.1,798.1,15.1,23,17,0)
entered retrospectively to be found by the next run of
"^DD",798.1,798.1,15.1,23,18,0)
the registry update process.
"^DD",798.1,798.1,15.1,23,19,0)
 
"^DD",798.1,798.1,15.1,23,20,0)
Moreover, the regular data extraction process extracts
"^DD",798.1,798.1,15.1,23,21,0)
data not until the date when the process is run but
"^DD",798.1,798.1,15.1,23,22,0)
until the date that is earlier by the number of days
"^DD",798.1,798.1,15.1,23,23,0)
from this field. So, this is a delay that increases
"^DD",798.1,798.1,15.1,23,24,0)
chances of the data to be entered retrospectively
"^DD",798.1,798.1,15.1,23,25,0)
before the next data extraction.
"^DD",798.1,798.1,15.1,23,26,0)
 
"^DD",798.1,798.1,15.1,23,27,0)
If the value of this field is too small, you may miss 
"^DD",798.1,798.1,15.1,23,28,0)
some data entered retrospectively. If it is too big,
"^DD",798.1,798.1,15.1,23,29,0)
the national registry will not contain the up to date
"^DD",798.1,798.1,15.1,23,30,0)
information (data will be delayed by the number of days
"^DD",798.1,798.1,15.1,23,31,0)
indicated by this field) and the registry update
"^DD",798.1,798.1,15.1,23,32,0)
process will take more time to complete (this time will
"^DD",798.1,798.1,15.1,23,33,0)
be spent processing the data from the overlap
"^DD",798.1,798.1,15.1,23,34,0)
interval).
"^DD",798.1,798.1,15.1,23,35,0)
 
"^DD",798.1,798.1,15.1,23,36,0)
When several registries are processed at the same time,
"^DD",798.1,798.1,15.1,23,37,0)
the maximum value of the LAG DAYS field is used.
"^DD",798.1,798.1,15.1,"DT")
3020426
"^DD",798.1,798.1,15.9,0)
DAYS TO WAIT FOR ACK^NJ1,0^^11;2^K:+X'=X!(X>7)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,15.9,3)
Type a number of days between 0 and 7.
"^DD",798.1,798.1,15.9,21,0)
^.001^4^4^3020426^^^^
"^DD",798.1,798.1,15.9,21,1,0)
The value of this field determines how many days
"^DD",798.1,798.1,15.9,21,2,0)
the package waits for an application
"^DD",798.1,798.1,15.9,21,3,0)
acknowledgement from the AAC. The default waiting
"^DD",798.1,798.1,15.9,21,4,0)
time is 3 days.
"^DD",798.1,798.1,15.9,23,0)
^.001^12^12^3020426^^^^
"^DD",798.1,798.1,15.9,23,1,0)
If the acknowledgement is not received in the time
"^DD",798.1,798.1,15.9,23,2,0)
frame defined by the value of this field, the fields
"^DD",798.1,798.1,15.9,23,3,0)
related to the most recent data transmission (AWAITING
"^DD",798.1,798.1,15.9,23,4,0)
ACKNOWLEDGEMENT, LAST MESSAGE ID, etc) will be cleared
"^DD",798.1,798.1,15.9,23,5,0)
automatically. This will resume the regular registry
"^DD",798.1,798.1,15.9,23,6,0)
updates and data transmissions.
"^DD",798.1,798.1,15.9,23,7,0)
 
"^DD",798.1,798.1,15.9,23,8,0)
If this particular acknowledgement arrives later, it
"^DD",798.1,798.1,15.9,23,9,0)
will be ignored because a new data transmission will
"^DD",798.1,798.1,15.9,23,10,0)
probably have taken place already (it will include data
"^DD",798.1,798.1,15.9,23,11,0)
that has not been delivered by the previous
"^DD",798.1,798.1,15.9,23,12,0)
transmission along with the new data).
"^DD",798.1,798.1,15.9,"DT")
3020425
"^DD",798.1,798.1,16,0)
USER^798.116A^^13;0
"^DD",798.1,798.1,17,0)
DRUG THERAPY LIST^798.117^^12;0
"^DD",798.1,798.1,17,9)
@
"^DD",798.1,798.1,17,21,0)
^.001^3^3^3020122^^^
"^DD",798.1,798.1,17,21,1,0)
A list of National Drug Codes to use in the Drug 
"^DD",798.1,798.1,17,21,2,0)
Therapy report. Use of the drugs listed here will
"^DD",798.1,798.1,17,21,3,0)
be reported in the Drug Therapy report.
"^DD",798.1,798.1,19.1,0)
NUMBER OF PATIENTS^NJ9,0I^^19;1^K:+X'=X!(X>999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,19.1,3)
Type a Number between 0 and 999999999, 0 Decimal Digits
"^DD",798.1,798.1,19.1,8.5)
@
"^DD",798.1,798.1,19.1,9)
@
"^DD",798.1,798.1,19.1,21,0)
^^3^3^3020403^
"^DD",798.1,798.1,19.1,21,1,0)
The NUMBER OF PATIENTS field contains total number
"^DD",798.1,798.1,19.1,21,2,0)
of patients in the registry right after the last
"^DD",798.1,798.1,19.1,21,3,0)
registry update.
"^DD",798.1,798.1,19.1,23,0)
^^3^3^3020403^
"^DD",798.1,798.1,19.1,23,1,0)
The field cannot be edited. It is updated automatically
"^DD",798.1,798.1,19.1,23,2,0)
by the $$UPDDEM^RORUPD51 function during the registry
"^DD",798.1,798.1,19.1,23,3,0)
update.
"^DD",798.1,798.1,19.1,"DT")
3020131
"^DD",798.1,798.1,19.2,0)
NUMBER OF ACTIVE PATIENTS^NJ9,0I^^19;2^K:+X'=X!(X>999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,19.2,3)
Type a Number between 0 and 999999999, 0 Decimal Digits
"^DD",798.1,798.1,19.2,8.5)
@
"^DD",798.1,798.1,19.2,9)
@
"^DD",798.1,798.1,19.2,21,0)
^^3^3^3020403^
"^DD",798.1,798.1,19.2,21,1,0)
The NUMBER OF ACTIVE PATIENTS field contains 
"^DD",798.1,798.1,19.2,21,2,0)
number of active patients in the registry right
"^DD",798.1,798.1,19.2,21,3,0)
after the last registry update.
"^DD",798.1,798.1,19.2,23,0)
^^3^3^3020403^
"^DD",798.1,798.1,19.2,23,1,0)
The field cannot be edited. It is updated automatically
"^DD",798.1,798.1,19.2,23,2,0)
by the $$UPDDEM^RORUPD51 function during the registry
"^DD",798.1,798.1,19.2,23,3,0)
update.
"^DD",798.1,798.1,19.2,"DT")
3020131
"^DD",798.1,798.1,21.01,0)
HDT START DATE^RD^^21;1^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,21.01,21,0)
^.001^6^6^3011109^^
"^DD",798.1,798.1,21.01,21,1,0)
This field indicates the start date for the 
"^DD",798.1,798.1,21.01,21,2,0)
historical data extraction.  
"^DD",798.1,798.1,21.01,21,3,0)
                                 
"^DD",798.1,798.1,21.01,21,4,0)
Usually, this field should not be edited. Its
"^DD",798.1,798.1,21.01,21,5,0)
predefined value is distributed within the package
"^DD",798.1,798.1,21.01,21,6,0)
KIDS build.
"^DD",798.1,798.1,21.01,"DT")
3011109
"^DD",798.1,798.1,21.02,0)
HDT END DATE^D^^21;2^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,21.02,21,0)
^^6^6^3020508^
"^DD",798.1,798.1,21.02,21,1,0)
This field indicates the end date for the 
"^DD",798.1,798.1,21.02,21,2,0)
historical data extraction.
"^DD",798.1,798.1,21.02,21,3,0)
 
"^DD",798.1,798.1,21.02,21,4,0)
Usually, this field should not be edited. It is 
"^DD",798.1,798.1,21.02,21,5,0)
populated automatically by the registry setup 
"^DD",798.1,798.1,21.02,21,6,0)
task.
"^DD",798.1,798.1,21.02,23,0)
^^1^1^3020508^
"^DD",798.1,798.1,21.02,23,1,0)
See the $$UPDHDTRP^RORSETU2 function for details.
"^DD",798.1,798.1,21.02,"DT")
3011107
"^DD",798.1,798.1,21.03,0)
HDT OUTPUT DIRECTORY^F^^21.03;E1,245^K:$L(X)>245!($L(X)<1) X
"^DD",798.1,798.1,21.03,3)
Enter a valid name of the output directory (1-245 characters).
"^DD",798.1,798.1,21.03,21,0)
^^19^19^3011107^
"^DD",798.1,798.1,21.03,21,1,0)
A directory must be created within the file system
"^DD",798.1,798.1,21.03,21,2,0)
of the host operating system (VMS, Windows,
"^DD",798.1,798.1,21.03,21,3,0)
etc).  Text files containing historical data in
"^DD",798.1,798.1,21.03,21,4,0)
the HL7 format will be created in this directory
"^DD",798.1,798.1,21.03,21,5,0)
by the data extraction tasks.
"^DD",798.1,798.1,21.03,21,6,0)
                                 
"^DD",798.1,798.1,21.03,21,7,0)
The full name of the directory must be entered as
"^DD",798.1,798.1,21.03,21,8,0)
a value of this field. For example, the value can
"^DD",798.1,798.1,21.03,21,9,0)
look something like this: 
"^DD",798.1,798.1,21.03,21,10,0)
                                 
"^DD",798.1,798.1,21.03,21,11,0)
 VA2$:[OUTPUT] - VAX VMS 
"^DD",798.1,798.1,21.03,21,12,0)
 D:\Output\    - Windows, MS-DOS 
"^DD",798.1,798.1,21.03,21,13,0)
                                 
"^DD",798.1,798.1,21.03,21,14,0)
Because a file name will be concatenated to the
"^DD",798.1,798.1,21.03,21,15,0)
directory name, the trailing slash in the Windows
"^DD",798.1,798.1,21.03,21,16,0)
directory name is required.  
"^DD",798.1,798.1,21.03,21,17,0)
                                 
"^DD",798.1,798.1,21.03,21,18,0)
Do not forget to enable read/write access to this
"^DD",798.1,798.1,21.03,21,19,0)
directory for M processes!
"^DD",798.1,798.1,21.03,"DT")
3011108
"^DD",798.1,798.1,21.04,0)
LOCAL DATA RESENT^D^^21;3^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,21.04,8.5)
@
"^DD",798.1,798.1,21.04,9)
@
"^DD",798.1,798.1,21.04,21,0)
^^10^10^3020508^
"^DD",798.1,798.1,21.04,21,1,0)
This field holds the date when all local registry 
"^DD",798.1,798.1,21.04,21,2,0)
data was resent to AAC after the installation (to 
"^DD",798.1,798.1,21.04,21,3,0)
fix the data incorrectly overwritten with the 
"^DD",798.1,798.1,21.04,21,4,0)
historical data).
"^DD",798.1,798.1,21.04,21,5,0)
 
"^DD",798.1,798.1,21.04,21,6,0)
Usually, you should not modify this field. If, by
"^DD",798.1,798.1,21.04,21,7,0)
some reason, you need to resend all local registry
"^DD",798.1,798.1,21.04,21,8,0)
and demographic data to AAC, you should clear this
"^DD",798.1,798.1,21.04,21,9,0)
field. The data will be resent automatically 
"^DD",798.1,798.1,21.04,21,10,0)
during the next nightly transmission.
"^DD",798.1,798.1,21.04,23,0)
^^4^4^3020508^
"^DD",798.1,798.1,21.04,23,1,0)
The value of this field is analyzed and modified by the
"^DD",798.1,798.1,21.04,23,2,0)
$$REMARK^RORUTL05 function. The function is called by
"^DD",798.1,798.1,21.04,23,3,0)
the nightly registry update and data transmission task
"^DD",798.1,798.1,21.04,23,4,0)
(TASK^ROR).
"^DD",798.1,798.1,21.04,"DT")
3020508
"^DD",798.1,798.1,21.05,0)
HDT DATE/TIME^DI^^21;4^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,21.05,8.5)
@
"^DD",798.1,798.1,21.05,9)
@
"^DD",798.1,798.1,21.05,21,0)
^^4^4^3020508^
"^DD",798.1,798.1,21.05,21,1,0)
This field is initialized with the current 
"^DD",798.1,798.1,21.05,21,2,0)
date/time by the registry setup task upon
"^DD",798.1,798.1,21.05,21,3,0)
successful completion of the initial registry
"^DD",798.1,798.1,21.05,21,4,0)
population.
"^DD",798.1,798.1,21.05,23,0)
^^10^10^3020508^
"^DD",798.1,798.1,21.05,23,1,0)
The field is populated by the $$UPDHDTRP^RORSETU2 
"^DD",798.1,798.1,21.05,23,2,0)
function during the registry setup.
"^DD",798.1,798.1,21.05,23,3,0)
 
"^DD",798.1,798.1,21.05,23,4,0)
The historical data extraction tasks do not process the
"^DD",798.1,798.1,21.05,23,5,0)
registry records that were added after this date. This
"^DD",798.1,798.1,21.05,23,6,0)
prevents sending the same data twice (by the regular
"^DD",798.1,798.1,21.05,23,7,0)
data extraction process and the historical data
"^DD",798.1,798.1,21.05,23,8,0)
extraction task).
"^DD",798.1,798.1,21.05,23,9,0)
 
"^DD",798.1,798.1,21.05,23,10,0)
Do not delete value of this field!
"^DD",798.1,798.1,21.05,"DT")
3020401
"^DD",798.1,798.1,25,0)
ENABLE PROTOCOLS^S^0:NO;1:YES;^0;14^Q
"^DD",798.1,798.1,25,1,0)
^.1
"^DD",798.1,798.1,25,1,1,0)
798.1^AEP^MUMPS
"^DD",798.1,798.1,25,1,1,1)
S:X ^ROR(798.1,"AEP",DA)=""
"^DD",798.1,798.1,25,1,1,2)
K ^ROR(798.1,"AEP",DA)
"^DD",798.1,798.1,25,1,1,3)
Do not delete!
"^DD",798.1,798.1,25,1,1,"%D",0)
^^10^10^3020418^
"^DD",798.1,798.1,25,1,1,"%D",1,0)
This cross-reference controls the package event 
"^DD",798.1,798.1,25,1,1,"%D",2,0)
protocols.
"^DD",798.1,798.1,25,1,1,"%D",3,0)
 
"^DD",798.1,798.1,25,1,1,"%D",4,0)
If at least one registry has the ENABLE PROTOCOLS
"^DD",798.1,798.1,25,1,1,"%D",5,0)
field set to "YES", the ^ROR(798.1,"AEP") node
"^DD",798.1,798.1,25,1,1,"%D",6,0)
will be defined and the protocols will call the
"^DD",798.1,798.1,25,1,1,"%D",7,0)
processing routines.
"^DD",798.1,798.1,25,1,1,"%D",8,0)
 
"^DD",798.1,798.1,25,1,1,"%D",9,0)
Otherwise, they will run idle (unless they are 
"^DD",798.1,798.1,25,1,1,"%D",10,0)
disabled or unsubscribed manually).
"^DD",798.1,798.1,25,1,1,"DT")
3020418
"^DD",798.1,798.1,25,21,0)
^^13^13^3020418^
"^DD",798.1,798.1,25,21,1,0)
If this field is set to "Yes", event protocols
"^DD",798.1,798.1,25,21,2,0)
will be used by the package to speed up the 
"^DD",798.1,798.1,25,21,3,0)
registry processing.
"^DD",798.1,798.1,25,21,4,0)
 
"^DD",798.1,798.1,25,21,5,0)
The protocols create references to patient events
"^DD",798.1,798.1,25,21,6,0)
in the ROR PENDING PATIENT file. Only those 
"^DD",798.1,798.1,25,21,7,0)
patients that have new references will be 
"^DD",798.1,798.1,25,21,8,0)
processed by the next registry update.
"^DD",798.1,798.1,25,21,9,0)
 
"^DD",798.1,798.1,25,21,10,0)
If several registries are updated at the same 
"^DD",798.1,798.1,25,21,11,0)
time and at least one of them has this field set 
"^DD",798.1,798.1,25,21,12,0)
to "Yes", all these registries will be processed 
"^DD",798.1,798.1,25,21,13,0)
using event references.
"^DD",798.1,798.1,25,23,0)
^^11^11^3020418^
"^DD",798.1,798.1,25,23,1,0)
This field controls both the registry update engine 
"^DD",798.1,798.1,25,23,2,0)
and the event protocols.
"^DD",798.1,798.1,25,23,3,0)
 
"^DD",798.1,798.1,25,23,4,0)
If at least one of the defined registries enables the
"^DD",798.1,798.1,25,23,5,0)
protocols, they will process the events and create
"^DD",798.1,798.1,25,23,6,0)
references in the ROR PENDING PATIENT file (#798.3).
"^DD",798.1,798.1,25,23,7,0)
 
"^DD",798.1,798.1,25,23,8,0)
Otherwise, the protocols will be executed (if they are
"^DD",798.1,798.1,25,23,9,0)
not disabled or unsubscribed manually) but will not
"^DD",798.1,798.1,25,23,10,0)
call processing routines and will not create references
"^DD",798.1,798.1,25,23,11,0)
in the file #798.3.
"^DD",798.1,798.1,25,"DT")
3020418
"^DD",798.1,798.11,0)
LOG EVENTS SUB-FIELD^^.01^1
"^DD",798.1,798.11,0,"DT")
3010712
"^DD",798.1,798.11,0,"IX","B",798.11,.01)

"^DD",798.1,798.11,0,"NM","LOG EVENTS")

"^DD",798.1,798.11,0,"UP")
798.1
"^DD",798.1,798.11,.01,0)
LOG EVENT TYPE^MS^1:Debug;2:Information;3:Data Quality;4:Warning;5:Database Error;6:Error;^0;1^Q
"^DD",798.1,798.11,.01,1,0)
^.1
"^DD",798.1,798.11,.01,1,1,0)
798.11^B
"^DD",798.1,798.11,.01,1,1,1)
S ^ROR(798.1,DA(1),3,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.11,.01,1,1,2)
K ^ROR(798.1,DA(1),3,"B",$E(X,1,30),DA)
"^DD",798.1,798.11,.01,1,1,3)
Do not delete!
"^DD",798.1,798.11,.01,21,0)
^^10^10^3020403^
"^DD",798.1,798.11,.01,21,1,0)
Select the type of the event if you want to enable
"^DD",798.1,798.11,.01,21,2,0)
recording of these events. If the list is empty,
"^DD",798.1,798.11,.01,21,3,0)
recording of all events is enabled. Otherwise,
"^DD",798.1,798.11,.01,21,4,0)
only events from the list and error messages will 
"^DD",798.1,798.11,.01,21,5,0)
be recorded.
"^DD",798.1,798.11,.01,21,6,0)
 
"^DD",798.1,798.11,.01,21,7,0)
Debug messages are exclusions from this rule (they
"^DD",798.1,798.11,.01,21,8,0)
are not logged if the ENABLE LOG field is set to
"^DD",798.1,798.11,.01,21,9,0)
"Yes" and this multiple is empty). Their recording
"^DD",798.1,798.11,.01,21,10,0)
can be enabled only explicitly.
"^DD",798.1,798.11,.01,23,0)
^^9^9^3020403^
"^DD",798.1,798.11,.01,23,1,0)
If several registries are processed at the same time,
"^DD",798.1,798.11,.01,23,2,0)
the recording parameters are combined.
"^DD",798.1,798.11,.01,23,3,0)
 
"^DD",798.1,798.11,.01,23,4,0)
If one of the registries requests recording of all 
"^DD",798.1,798.11,.01,23,5,0)
events, all events except the debug messages (type 1)
"^DD",798.1,798.11,.01,23,6,0)
will be recorded for all registries.
"^DD",798.1,798.11,.01,23,7,0)
 
"^DD",798.1,798.11,.01,23,8,0)
Otherwise, merged content of the LOG EVENT TYPE
"^DD",798.1,798.11,.01,23,9,0)
multiples will determine the events to be recorded.
"^DD",798.1,798.11,.01,"DT")
3010712
"^DD",798.1,798.112,0)
EXTRACTED RESULT SUB-FIELD^^.02^2
"^DD",798.1,798.112,0,"DT")
3010629
"^DD",798.1,798.112,0,"ID","WRITE")
D EN^DDIOL($P(^(0),U,2),"","?20")
"^DD",798.1,798.112,0,"IX","B",798.112,.01)

"^DD",798.1,798.112,0,"IX","C",798.112,.02)

"^DD",798.1,798.112,0,"NM","EXTRACTED RESULT")

"^DD",798.1,798.112,0,"UP")
798.1
"^DD",798.1,798.112,.01,0)
LOINC CODE^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:X'?1(1.7N,1"*") X
"^DD",798.1,798.112,.01,1,0)
^.1
"^DD",798.1,798.112,.01,1,1,0)
798.112^B
"^DD",798.1,798.112,.01,1,1,1)
S ^ROR(798.1,DA(1),8,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.112,.01,1,1,2)
K ^ROR(798.1,DA(1),8,"B",$E(X,1,30),DA)
"^DD",798.1,798.112,.01,1,1,3)
Do not delete!
"^DD",798.1,798.112,.01,1,1,"DT")
3010716
"^DD",798.1,798.112,.01,3)
Answer must be 1-7 characters in length.
"^DD",798.1,798.112,.01,8.5)
@
"^DD",798.1,798.112,.01,9)
@
"^DD",798.1,798.112,.01,21,0)
^^11^11^3011015^
"^DD",798.1,798.112,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.112,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.112,.01,21,3,0)
 
"^DD",798.1,798.112,.01,21,4,0)
Enter the unique numeric LOINC code (without the
"^DD",798.1,798.112,.01,21,5,0)
check digit) of the Lab result to be extracted. If
"^DD",798.1,798.112,.01,21,6,0)
you want to use only NLT code, enter zero as the
"^DD",798.1,798.112,.01,21,7,0)
value of this field.
"^DD",798.1,798.112,.01,21,8,0)
 
"^DD",798.1,798.112,.01,21,9,0)
If you want to extract all results, create a
"^DD",798.1,798.112,.01,21,10,0)
record in this multiple containing the "*" 
"^DD",798.1,798.112,.01,21,11,0)
character in this field.
"^DD",798.1,798.112,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.112,.01,"DT")
3010716
"^DD",798.1,798.112,.02,0)
NLT CODE^FX^^0;2^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:'(X?5N1"."4.5N) X
"^DD",798.1,798.112,.02,1,0)
^.1
"^DD",798.1,798.112,.02,1,1,0)
798.112^C
"^DD",798.1,798.112,.02,1,1,1)
S ^ROR(798.1,DA(1),8,"C",$E(X,1,30),DA)=""
"^DD",798.1,798.112,.02,1,1,2)
K ^ROR(798.1,DA(1),8,"C",$E(X,1,30),DA)
"^DD",798.1,798.112,.02,1,1,3)
Do not delete!
"^DD",798.1,798.112,.02,1,1,"DT")
3010716
"^DD",798.1,798.112,.02,3)
Answer must be 10-11 characters in length.
"^DD",798.1,798.112,.02,8.5)
@
"^DD",798.1,798.112,.02,9)
@
"^DD",798.1,798.112,.02,21,0)
^^8^8^3011015^
"^DD",798.1,798.112,.02,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.112,.02,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.112,.02,21,3,0)
 
"^DD",798.1,798.112,.02,21,4,0)
Enter the unique NLT code of the Lab result to be
"^DD",798.1,798.112,.02,21,5,0)
extracted. Both LOINC and NLT codes (if available)
"^DD",798.1,798.112,.02,21,6,0)
are used for searching the Lab results. If you 
"^DD",798.1,798.112,.02,21,7,0)
want to use only the LOINC code, leave this field 
"^DD",798.1,798.112,.02,21,8,0)
empty.
"^DD",798.1,798.112,.02,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.112,.02,"DT")
3010716
"^DD",798.1,798.114,0)
COORDINATOR SUB-FIELD^^.01^1
"^DD",798.1,798.114,0,"DT")
3010907
"^DD",798.1,798.114,0,"IX","B",798.114,.01)

"^DD",798.1,798.114,0,"NM","COORDINATOR")

"^DD",798.1,798.114,0,"UP")
798.1
"^DD",798.1,798.114,.01,0)
COORDINATOR^MP200'X^VA(200,^0;1^S:$D(X) DINUM=X
"^DD",798.1,798.114,.01,1,0)
^.1
"^DD",798.1,798.114,.01,1,1,0)
798.114^B
"^DD",798.1,798.114,.01,1,1,1)
S ^ROR(798.1,DA(1),10,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.114,.01,1,1,2)
K ^ROR(798.1,DA(1),10,"B",$E(X,1,30),DA)
"^DD",798.1,798.114,.01,1,1,3)
Do not delete!
"^DD",798.1,798.114,.01,21,0)
^^4^4^3020403^
"^DD",798.1,798.114,.01,21,1,0)
Select the registry coordinator or add a new one
"^DD",798.1,798.114,.01,21,2,0)
from the NEW PERSON file. People defined as 
"^DD",798.1,798.114,.01,21,3,0)
registry coordinators will be receiving alerts 
"^DD",798.1,798.114,.01,21,4,0)
regarding problems with the registry processes.
"^DD",798.1,798.114,.01,"DT")
3010907
"^DD",798.1,798.116,0)
USER SUB-FIELD^^2^3
"^DD",798.1,798.116,0,"DT")
3020426
"^DD",798.1,798.116,0,"IX","B",798.116,.01)

"^DD",798.1,798.116,0,"NM","USER")

"^DD",798.1,798.116,0,"UP")
798.1
"^DD",798.1,798.116,.01,0)
USER^NJ10,0X^^0;1^S X=X
"^DD",798.1,798.116,.01,1,0)
^.1
"^DD",798.1,798.116,.01,1,1,0)
798.116^B
"^DD",798.1,798.116,.01,1,1,1)
S ^ROR(798.1,DA(1),13,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.116,.01,1,1,2)
K ^ROR(798.1,DA(1),13,"B",$E(X,1,30),DA)
"^DD",798.1,798.116,.01,3)
Type a Number between 1 and 9999999999, 0 Decimal Digits
"^DD",798.1,798.116,.01,"DT")
3020426
"^DD",798.1,798.116,1,0)
RPC HANDLE^F^^0;2^K:$L(X)>30!($L(X)<1) X
"^DD",798.1,798.116,1,3)
Answer must be 1-30 characters in length.
"^DD",798.1,798.116,1,21,0)
^.001^2^2^3020426^^^
"^DD",798.1,798.116,1,21,1,0)
This field holds a reference to the last deferred remote procedure that
"^DD",798.1,798.116,1,21,2,0)
created a drug report.
"^DD",798.1,798.116,1,23,0)
^.001^4^4^3020426^^
"^DD",798.1,798.116,1,23,1,0)
This field should not be set manually. It holds a free-text handle to
"^DD",798.1,798.116,1,23,2,0)
identify the last deferred remote procedure that was scheduled.  It is 
"^DD",798.1,798.116,1,23,3,0)
used by the GUI to fetch the drug report created by the deferred remote 
"^DD",798.1,798.116,1,23,4,0)
procedure.  See the EN2^RORRP9 procedure for details.
"^DD",798.1,798.116,1,"DT")
3020426
"^DD",798.1,798.116,2,0)
RPC HANDLE 2^F^^0;3^K:$L(X)>30!($L(X)<1) X
"^DD",798.1,798.116,2,3)
Answer must be 1-30 characters in length.
"^DD",798.1,798.116,2,21,0)
^^2^2^3020426^
"^DD",798.1,798.116,2,21,1,0)
This field holds a reference to the last deferred remote procedure that
"^DD",798.1,798.116,2,21,2,0)
created a Hepatitis C Local Registry report.
"^DD",798.1,798.116,2,23,0)
^^1^1^3020426^
"^DD",798.1,798.116,2,23,1,0)
See the EN2^RORRP9 procedure for details.
"^DD",798.1,798.116,2,"DT")
3020426
"^DD",798.1,798.117,0)
DRUG THERAPY LIST SUB-FIELD^^.01^1
"^DD",798.1,798.117,0,"DT")
3011112
"^DD",798.1,798.117,0,"IX","B",798.117,.01)

"^DD",798.1,798.117,0,"NM","DRUG THERAPY LIST")

"^DD",798.1,798.117,0,"UP")
798.1
"^DD",798.1,798.117,.01,0)
NDC^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:'(X?12N) X
"^DD",798.1,798.117,.01,1,0)
^.1
"^DD",798.1,798.117,.01,1,1,0)
798.117^B
"^DD",798.1,798.117,.01,1,1,1)
S ^ROR(798.1,DA(1),12,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.117,.01,1,1,2)
K ^ROR(798.1,DA(1),12,"B",$E(X,1,30),DA)
"^DD",798.1,798.117,.01,1,1,3)
Do not delete!
"^DD",798.1,798.117,.01,3)
Answer must be 12 characters in length.
"^DD",798.1,798.117,.01,21,0)
^.001^2^2^3020122^^^
"^DD",798.1,798.117,.01,21,1,0)
National Drug Code to include in Drug Therapy 
"^DD",798.1,798.117,.01,21,2,0)
Report.
"^DD",798.1,798.117,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.117,.01,"DT")
3011112
"^DD",798.1,798.13,0)
SELECTION RULE SUB-FIELD^^.01^1
"^DD",798.1,798.13,0,"DT")
3000410
"^DD",798.1,798.13,0,"NM","SELECTION RULE")

"^DD",798.1,798.13,0,"UP")
798.1
"^DD",798.1,798.13,.01,0)
SELECTION RULE^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:$L(X)>30!($L(X)<3)!'(X?3.UNP) X I $D(X) K:'$D(^ROR(798.2,"B",$E(X,1,30))) X
"^DD",798.1,798.13,.01,1,0)
^.1^^-1
"^DD",798.1,798.13,.01,1,2,0)
798.1^ARULES
"^DD",798.1,798.13,.01,1,2,1)
S ^ROR(798.1,"ARULES",$E(X,1,30),DA(1),DA)=""
"^DD",798.1,798.13,.01,1,2,2)
K ^ROR(798.1,"ARULES",$E(X,1,30),DA(1),DA)
"^DD",798.1,798.13,.01,1,2,3)
Do not delete!
"^DD",798.1,798.13,.01,1,2,"%D",0)
^^2^2^3011015^
"^DD",798.1,798.13,.01,1,2,"%D",1,0)
This cross-reference can be used to find all 
"^DD",798.1,798.13,.01,1,2,"%D",2,0)
registries that use the selection rule.
"^DD",798.1,798.13,.01,1,2,"DT")
3000406
"^DD",798.1,798.13,.01,3)
Enter a name of the selection rule (3-30 characters).
"^DD",798.1,798.13,.01,4)
I $G(X)="?" N D,DIC,DZ S DIC="^ROR(798.2,",DIC(0)="",D="B",DZ="??" D DQ^DICQ,EN^DDIOL("",,"!")
"^DD",798.1,798.13,.01,8.5)
@
"^DD",798.1,798.13,.01,9)
@
"^DD",798.1,798.13,.01,21,0)
^.001^8^8^3020403^^^
"^DD",798.1,798.13,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.13,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.13,.01,21,3,0)
 
"^DD",798.1,798.13,.01,21,4,0)
Enter a name of the selection rule that will be 
"^DD",798.1,798.13,.01,21,5,0)
used to select patients for addition to the
"^DD",798.1,798.13,.01,21,6,0)
registry. The name should be entered exactly as it
"^DD",798.1,798.13,.01,21,7,0)
appears in the list of selection rules (file 
"^DD",798.1,798.13,.01,21,8,0)
#798.2).
"^DD",798.1,798.13,.01,23,0)
^.001^3^3^3020403^^^
"^DD",798.1,798.13,.01,23,1,0)
Names of the selection rules are used here instead of 
"^DD",798.1,798.13,.01,23,2,0)
pointers because the KIDS pointer resolving feature 
"^DD",798.1,798.13,.01,23,3,0)
does not work for .01 fields.
"^DD",798.1,798.13,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.13,.01,"DT")
3011109
"^DD",798.1,798.15,0)
DESCRIPTION SUB-FIELD^^.01^1
"^DD",798.1,798.15,0,"NM","DESCRIPTION")

"^DD",798.1,798.15,0,"UP")
798.1
"^DD",798.1,798.15,.01,0)
DESCRIPTION^W^^0;1^Q
"^DD",798.1,798.15,.01,"DT")
3000313
"^DD",798.1,798.19,0)
HL7 SEGMENT SUB-FIELD^^1^3
"^DD",798.1,798.19,0,"DT")
3010913
"^DD",798.1,798.19,0,"IX","B",798.19,.01)

"^DD",798.1,798.19,0,"NM","HL7 SEGMENT")

"^DD",798.1,798.19,0,"UP")
798.1
"^DD",798.1,798.19,.01,0)
HL7 SEGMENT^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:'(X?3UN) X
"^DD",798.1,798.19,.01,1,0)
^.1
"^DD",798.1,798.19,.01,1,1,0)
798.19^B
"^DD",798.1,798.19,.01,1,1,1)
S ^ROR(798.1,DA(1),6,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.19,.01,1,1,2)
K ^ROR(798.1,DA(1),6,"B",$E(X,1,30),DA)
"^DD",798.1,798.19,.01,1,1,3)
Do not delete!
"^DD",798.1,798.19,.01,3)
Enter a name of the HL7 segment (3 characters).
"^DD",798.1,798.19,.01,8.5)
@
"^DD",798.1,798.19,.01,9)
@
"^DD",798.1,798.19,.01,21,0)
^.001^9^9^3020403^^
"^DD",798.1,798.19,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.19,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.19,.01,21,3,0)
 
"^DD",798.1,798.19,.01,21,4,0)
Enter a name of the HL7 segment that should be 
"^DD",798.1,798.19,.01,21,5,0)
included in the message sent to AAC. The general 
"^DD",798.1,798.19,.01,21,6,0)
structure of the registry HL7 message is hard 
"^DD",798.1,798.19,.01,21,7,0)
coded in the message builder routine. Therefore, 
"^DD",798.1,798.19,.01,21,8,0)
the segments that are not generated by the builder
"^DD",798.1,798.19,.01,21,9,0)
will be ignored if added to this multiple.
"^DD",798.1,798.19,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.19,.01,"DT")
3011015
"^DD",798.1,798.19,.02,0)
DATA AREA^RSX^1:Patient;2:Laboratory;3:Pharmacy;4:Radiology;5:Inpatient;6:Outpatient;7:Pathology-Autopsy;8:Pathology-Liver Biopsy;^0;3^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.19,.02,8.5)
@
"^DD",798.1,798.19,.02,9)
@
"^DD",798.1,798.19,.02,21,0)
^^6^6^3011121^
"^DD",798.1,798.19,.02,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.19,.02,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.19,.02,21,3,0)
 
"^DD",798.1,798.19,.02,21,4,0)
The same HL7 segments can be used in different 
"^DD",798.1,798.19,.02,21,5,0)
contexts to store different data. The data area
"^DD",798.1,798.19,.02,21,6,0)
code is used to distinguish between them.
"^DD",798.1,798.19,.02,"DT")
3011109
"^DD",798.1,798.19,1,0)
FIELDS^FX^^1;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:$L(X)>200!($L(X)<1) X
"^DD",798.1,798.19,1,3)
Enter a list of HL7 field numbers separated by commas (1-200 characters).
"^DD",798.1,798.19,1,8.5)
@
"^DD",798.1,798.19,1,9)
@
"^DD",798.1,798.19,1,21,0)
^.001^11^11^3011121^^^
"^DD",798.1,798.19,1,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.19,1,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.19,1,21,3,0)
 
"^DD",798.1,798.19,1,21,4,0)
The values of the segment fields listed here 
"^DD",798.1,798.19,1,21,5,0)
(field numbers should be separated by commas) will
"^DD",798.1,798.19,1,21,6,0)
be extracted and sent to AAC. If this field is 
"^DD",798.1,798.19,1,21,7,0)
empty, the values of all fields will be sent.
"^DD",798.1,798.19,1,21,8,0)
 
"^DD",798.1,798.19,1,21,9,0)
Some existing VistA APIs do not support this 
"^DD",798.1,798.19,1,21,10,0)
feature. So, sometimes the value of this field may
"^DD",798.1,798.19,1,21,11,0)
be ignored and all values will be sent instead.
"^DD",798.1,798.19,1,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.19,1,"DT")
3010622
"^DD",798.2,798.2,0)
FIELD^^6^7
"^DD",798.2,798.2,0,"DDA")
N
"^DD",798.2,798.2,0,"DT")
3020326
"^DD",798.2,798.2,0,"ID","WRITE")
D EN^DDIOL("  "_$P($G(^(0)),U,3),,"?30")
"^DD",798.2,798.2,0,"NM","ROR SELECTION RULE")

"^DD",798.2,798.2,0,"PT",798.01,.01)

"^DD",798.2,798.2,0,"VRPK")
ROR
"^DD",798.2,798.2,.01,0)
RULE NAME^FX^^0;1^Q:$$VAEDT^RORDD(798.2,$G(DA))  K:$L(X)>30!($L(X)<3)!'(X?1.UNP) X
"^DD",798.2,798.2,.01,1,0)
^.1^^0
"^DD",798.2,798.2,.01,3)
Enter a unique namespaced rule name (3-30 characters).
"^DD",798.2,798.2,.01,8.5)
@
"^DD",798.2,798.2,.01,9)
@
"^DD",798.2,798.2,.01,21,0)
^.001^6^6^3011010^^
"^DD",798.2,798.2,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.2,798.2,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.2,798.2,.01,21,3,0)
 
"^DD",798.2,798.2,.01,21,4,0)
Selection rule name must be unique and name 
"^DD",798.2,798.2,.01,21,5,0)
spaced. Names of the rules that are used for
"^DD",798.2,798.2,.01,21,6,0)
National Registries must start with "VA".
"^DD",798.2,798.2,.01,"DEL",1,0)
I $$VADEL^RORDD(798.2,$G(DA))
"^DD",798.2,798.2,.01,"DT")
3020314
"^DD",798.2,798.2,.09,0)
NATIONAL^SX^0:NO;1:YES;^0;4^Q:$$VAEDT^RORDD(798.2,,-1)
"^DD",798.2,798.2,.09,1,0)
^.1^^0
"^DD",798.2,798.2,.09,8.5)
@
"^DD",798.2,798.2,.09,9)
@
"^DD",798.2,798.2,.09,21,0)
^.001^6^6^3020403^^
"^DD",798.2,798.2,.09,21,1,0)
ONLY AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN
"^DD",798.2,798.2,.09,21,2,0)
EDIT THIS FIELD!
"^DD",798.2,798.2,.09,21,3,0)
 
"^DD",798.2,798.2,.09,21,4,0)
Selection rules of the national registries must
"^DD",798.2,798.2,.09,21,5,0)
have this field set to "Yes". This prevents local
"^DD",798.2,798.2,.09,21,6,0)
editing of other fields of rule definitions.
"^DD",798.2,798.2,.09,"DEL",1,0)
I $$VADEL^RORDD(798.2,,,-1)
"^DD",798.2,798.2,.09,"DT")
3011121
"^DD",798.2,798.2,1,0)
EXPRESSION^RFX^^1;E1,245^Q:$$VAEDT^RORDD(798.2,$G(DA))  K:$L(X)>250!($L(X)<1) X I $D(X) Q:$$EXPR^RORDD($P($G(^ROR(798.2,DA,0)),U,2))
"^DD",798.2,798.2,1,3)
Enter M expression that implements the selection rule (1-250 characters).
"^DD",798.2,798.2,1,8.5)
@
"^DD",798.2,798.2,1,9)
@
"^DD",798.2,798.2,1,21,0)
^^5^5^3011010^
"^DD",798.2,798.2,1,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.2,798.2,1,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.2,798.2,1,21,3,0)
 
"^DD",798.2,798.2,1,21,4,0)
Enter a MUMPS expression (it may contain special
"^DD",798.2,798.2,1,21,5,0)
macros) that implements the selection rule.
"^DD",798.2,798.2,1,23,0)
^^62^62^3020403^
"^DD",798.2,798.2,1,23,1,0)
MUMPS expression that implements the selection rule can
"^DD",798.2,798.2,1,23,2,0)
contain special macros:
"^DD",798.2,798.2,1,23,3,0)
 
"^DD",798.2,798.2,1,23,4,0)
 {E: Field Name} - External value of the field
"^DD",798.2,798.2,1,23,5,0)
 {E: Field Number}
"^DD",798.2,798.2,1,23,6,0)
 
"^DD",798.2,798.2,1,23,7,0)
 {I: Field Name} - Internal value of the field
"^DD",798.2,798.2,1,23,8,0)
 {I: Field Number}
"^DD",798.2,798.2,1,23,9,0)
 
"^DD",798.2,798.2,1,23,10,0)
 {Rule Name} - Result value of the lower level
"^DD",798.2,798.2,1,23,11,0)
selection rule
"^DD",798.2,798.2,1,23,12,0)
 
"^DD",798.2,798.2,1,23,13,0)
 {AVG: Rule Name} - Average value of the rule
"^DD",798.2,798.2,1,23,14,0)
 
"^DD",798.2,798.2,1,23,15,0)
 {CNT: Rule Name} - Number of calculations of the rule
"^DD",798.2,798.2,1,23,16,0)
 
"^DD",798.2,798.2,1,23,17,0)
 {MAX: Rule Name} - Maximum value of the rule
"^DD",798.2,798.2,1,23,18,0)
 
"^DD",798.2,798.2,1,23,19,0)
 {MIN: Rule Name} - Minimum value of the rule
"^DD",798.2,798.2,1,23,20,0)
 
"^DD",798.2,798.2,1,23,21,0)
 {SUM: Rule Name} - Total of the selection rule values
"^DD",798.2,798.2,1,23,22,0)
 
"^DD",798.2,798.2,1,23,23,0)
 {LS: Lab Search Name} - This macro can be used only in
"^DD",798.2,798.2,1,23,24,0)
the selection rules associated with the LAB DATA file
"^DD",798.2,798.2,1,23,25,0)
(#63). It is evaluated as 1 if some of the patient
"^DD",798.2,798.2,1,23,26,0)
lab results pass the Lab search criteria (from the file
"^DD",798.2,798.2,1,23,27,0)
#798.9). Otherwise, it is evaluated as zero.
"^DD",798.2,798.2,1,23,28,0)
 
"^DD",798.2,798.2,1,23,29,0)
Return values of the top-level rules:
"^DD",798.2,798.2,1,23,30,0)
 
"^DD",798.2,798.2,1,23,31,0)
 0        - Skip the patient
"^DD",798.2,798.2,1,23,32,0)
 Non-zero - Add the patient to the registry
"^DD",798.2,798.2,1,23,33,0)
 
"^DD",798.2,798.2,1,23,34,0)
Return values of the lower level rules:
"^DD",798.2,798.2,1,23,35,0)
 
"^DD",798.2,798.2,1,23,36,0)
Return values can be used in the expressions of the
"^DD",798.2,798.2,1,23,37,0)
other rules. Some additional values are calculated
"^DD",798.2,798.2,1,23,38,0)
automatically (minimum, maximum, average, etc) for each
"^DD",798.2,798.2,1,23,39,0)
rule.
"^DD",798.2,798.2,1,23,40,0)
 
"^DD",798.2,798.2,1,23,41,0)
Avoid circular references in the expressions. If a 
"^DD",798.2,798.2,1,23,42,0)
rule directly or indirectly depends on itself, it
"^DD",798.2,798.2,1,23,43,0)
cannot be evaluated. An example of the circular
"^DD",798.2,798.2,1,23,44,0)
reference:
"^DD",798.2,798.2,1,23,45,0)
 
"^DD",798.2,798.2,1,23,46,0)
 Rule A: {MAX:B}<10
"^DD",798.2,798.2,1,23,47,0)
 Rule B: {I:23}+{C}
"^DD",798.2,798.2,1,23,48,0)
 Rule C: {CNT:A}
"^DD",798.2,798.2,1,23,49,0)
 
"^DD",798.2,798.2,1,23,50,0)
The rule A cannot be evaluated because it depends on 
"^DD",798.2,798.2,1,23,51,0)
the rule B, which depends on rule C, and C depends on
"^DD",798.2,798.2,1,23,52,0)
A.
"^DD",798.2,798.2,1,23,53,0)
 
"^DD",798.2,798.2,1,23,54,0)
Complex selection rules could be implemented by 
"^DD",798.2,798.2,1,23,55,0)
external MUMPS functions. In that case the expression
"^DD",798.2,798.2,1,23,56,0)
should contains a full reference to the function
"^DD",798.2,798.2,1,23,57,0)
($$TAG^ROUTINE). Values of the necessary data elements
"^DD",798.2,798.2,1,23,58,0)
can be loaded automatically (see descriptiion of the
"^DD",798.2,798.2,1,23,59,0)
DATA ELEMENT multiple).
"^DD",798.2,798.2,1,23,60,0)
 
"^DD",798.2,798.2,1,23,61,0)
See the Programmer's reference manual for more details 
"^DD",798.2,798.2,1,23,62,0)
regarding the selection rule expressions.
"^DD",798.2,798.2,1,"DEL",1,0)
I $$VADEL^RORDD(798.2,$G(DA))
"^DD",798.2,798.2,1,"DT")
3011109
"^DD",798.2,798.2,2,0)
FILE^RNJ22,9X^^0;2^Q:$$VAEDT^RORDD(798.2,$G(DA))  K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."10N.N) X I $D(X) K:'$$VFILE^DILFD(X) X
"^DD",798.2,798.2,2,3)
Enter (sub)file number between 1 and 999999999999, 9 Decimal Digits.
"^DD",798.2,798.2,2,8.5)
@
"^DD",798.2,798.2,2,9)
@
"^DD",798.2,798.2,2,21,0)
^.001^6^6^3020403^^
"^DD",798.2,798.2,2,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.2,798.2,2,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.2,798.2,2,21,3,0)
 
"^DD",798.2,798.2,2,21,4,0)
Enter a file/sub-file number that the selection 
"^DD",798.2,798.2,2,21,5,0)
rule is associated with. Each selection rule can
"^DD",798.2,798.2,2,21,6,0)
be associated with only one file.
"^DD",798.2,798.2,2,"DEL",1,0)
I $$VADEL^RORDD(798.2,$G(DA))
"^DD",798.2,798.2,2,"DT")
3011109
"^DD",798.2,798.2,4,0)
SHORT DESCRIPTION^FX^^0;3^Q:$$VAEDT^RORDD(798.2,$G(DA))  K:$L(X)>30!($L(X)<3) X
"^DD",798.2,798.2,4,3)
Enter a short description of the selection rule (3-30 characters).
"^DD",798.2,798.2,4,8.5)
@
"^DD",798.2,798.2,4,9)
@
"^DD",798.2,798.2,4,21,0)
^^5^5^3020403^
"^DD",798.2,798.2,4,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.2,798.2,4,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.2,798.2,4,21,3,0)
 
"^DD",798.2,798.2,4,21,4,0)
The short description of the selection rule is 
"^DD",798.2,798.2,4,21,5,0)
used in the reports and GUI dialogs.
"^DD",798.2,798.2,4,"DEL",1,0)
I $$VADEL^RORDD(798.2,$G(DA))
"^DD",798.2,798.2,4,"DT")
3011109
"^DD",798.2,798.2,5,0)
DESCRIPTION^798.25^^3;0
"^DD",798.2,798.2,5,21,0)
^^3^3^3020403^
"^DD",798.2,798.2,5,21,1,0)
You can enter any additional reference information
"^DD",798.2,798.2,5,21,2,0)
related to the selection rule. The content of this
"^DD",798.2,798.2,5,21,3,0)
field is not used by the application.
"^DD",798.2,798.2,6,0)
DATA ELEMENT^798.26^^4;0
"^DD",798.2,798.2,6,9)
@
"^DD",798.2,798.2,6,21,0)
^^12^12^3020328^
"^DD",798.2,798.2,6,21,1,0)
The DATA ELEMENT multiple contains a list of 
"^DD",798.2,798.2,6,21,2,0)
additional data elements to load. 
"^DD",798.2,798.2,6,21,3,0)
 
"^DD",798.2,798.2,6,21,4,0)
Values of all the data elements referenced in the
"^DD",798.2,798.2,6,21,5,0)
selection rule expression are loaded
"^DD",798.2,798.2,6,21,6,0)
automatically.
"^DD",798.2,798.2,6,21,7,0)
 
"^DD",798.2,798.2,6,21,8,0)
However, if the rule is implemented by an external
"^DD",798.2,798.2,6,21,9,0)
function, you can enter codes of all necessary
"^DD",798.2,798.2,6,21,10,0)
data elements into this multiple. Their values
"^DD",798.2,798.2,6,21,11,0)
will be loaded automatically and will be
"^DD",798.2,798.2,6,21,12,0)
accessible in the function.
"^DD",798.2,798.2,6,"DT")
3020326
"^DD",798.2,798.25,0)
DESCRIPTION SUB-FIELD^^.01^1
"^DD",798.2,798.25,0,"NM","DESCRIPTION")

"^DD",798.2,798.25,0,"UP")
798.2
"^DD",798.2,798.25,.01,0)
DESCRIPTION^W^^0;1^Q
"^DD",798.2,798.25,.01,"DT")
3000313
"^DD",798.2,798.26,0)
DATA ELEMENT SUB-FIELD^^1^2
"^DD",798.2,798.26,0,"DT")
3020326
"^DD",798.2,798.26,0,"NM","DATA ELEMENT")

"^DD",798.2,798.26,0,"UP")
798.2
"^DD",798.2,798.26,.01,0)
ELEMENT CODE^MNJ9,0X^^0;1^Q:$$VAEDT^RORDD(798.2,$G(DA(1)))  K:+X'=X!(X>999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.2,798.26,.01,1,0)
^.1^^0
"^DD",798.2,798.26,.01,3)
Type a Number between 1 and 999999999, 0 Decimal Digits.
"^DD",798.2,798.26,.01,8.5)
@
"^DD",798.2,798.26,.01,9)
@
"^DD",798.2,798.26,.01,21,0)
^^8^8^3020328^
"^DD",798.2,798.26,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.2,798.26,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.2,798.26,.01,21,3,0)
 
"^DD",798.2,798.26,.01,21,4,0)
Enter the code of the data element that should be 
"^DD",798.2,798.26,.01,21,5,0)
loaded before evaluation of the expression. Values
"^DD",798.2,798.26,.01,21,6,0)
of all data elements referenced in the selection
"^DD",798.2,798.26,.01,21,7,0)
rule expression are loaded automatically (you do
"^DD",798.2,798.26,.01,21,8,0)
not need to enter them here).
"^DD",798.2,798.26,.01,"DEL",1,0)
I $$VADEL^RORDD(798.2,$G(DA(1)))
"^DD",798.2,798.26,.01,"DT")
3020326
"^DD",798.2,798.26,1,0)
VALUE TYPE^RSX^E:External;I:Internal;EI:Both;^0;2^Q:$$VAEDT^RORDD(798.2,$G(DA(1)))
"^DD",798.2,798.26,1,8.5)
@
"^DD",798.2,798.26,1,9)
@
"^DD",798.2,798.26,1,21,0)
^^3^3^3020328^
"^DD",798.2,798.26,1,21,1,0)
This field holds required value type(s) of the
"^DD",798.2,798.26,1,21,2,0)
data element. The type(s) must be supported by the
"^DD",798.2,798.26,1,21,3,0)
search engine.
"^DD",798.2,798.26,1,"DT")
3020311
"^DD",798.3,798.3,0)
FIELD^^2^3
"^DD",798.3,798.3,0,"DDA")
N
"^DD",798.3,798.3,0,"DT")
3020502
"^DD",798.3,798.3,0,"IX","AT",798.32,.01)

"^DD",798.3,798.3,0,"IX","B",798.3,.01)

"^DD",798.3,798.3,0,"NM","ROR PENDING PATIENT")

"^DD",798.3,798.3,0,"VRPK")
ROR
"^DD",798.3,798.3,.01,0)
PATIENT NAME^RP2'X^DPT(^0;1^S:$D(X) DINUM=X
"^DD",798.3,798.3,.01,1,0)
^.1
"^DD",798.3,798.3,.01,1,1,0)
798.3^B
"^DD",798.3,798.3,.01,1,1,1)
S ^RORDATA(798.3,"B",$E(X,1,30),DA)=""
"^DD",798.3,798.3,.01,1,1,2)
K ^RORDATA(798.3,"B",$E(X,1,30),DA)
"^DD",798.3,798.3,.01,1,1,3)
Do not delete!
"^DD",798.3,798.3,.01,3)

"^DD",798.3,798.3,.01,8.5)
@
"^DD",798.3,798.3,.01,9)
@
"^DD",798.3,798.3,.01,21,0)
^^2^2^3020424^
"^DD",798.3,798.3,.01,21,1,0)
The PATIENT NAME field identifies the patient. You
"^DD",798.3,798.3,.01,21,2,0)
can add a patient from the PATIENT file.
"^DD",798.3,798.3,.01,"DT")
3020415
"^DD",798.3,798.3,1,0)
ERROR^798.31P^^1;0
"^DD",798.3,798.3,1,9)
@
"^DD",798.3,798.3,1,21,0)
^^44^44^3020424^
"^DD",798.3,798.3,1,21,1,0)
This multiple stores references to those
"^DD",798.3,798.3,1,21,2,0)
registries that have the patient processed with
"^DD",798.3,798.3,1,21,3,0)
errors and has not been added to the registry.
"^DD",798.3,798.3,1,21,4,0)
     
"^DD",798.3,798.3,1,21,5,0)
When the problems are fixed, the data search must 
"^DD",798.3,798.3,1,21,6,0)
start not from the date of the previous run of the
"^DD",798.3,798.3,1,21,7,0)
registry update process but from the date that 
"^DD",798.3,798.3,1,21,8,0)
was used when the problem arose. Otherwise, the
"^DD",798.3,798.3,1,21,9,0)
data in the interval between those dates will not
"^DD",798.3,798.3,1,21,10,0)
be checked and some important information may be
"^DD",798.3,798.3,1,21,11,0)
missed.
"^DD",798.3,798.3,1,21,12,0)
     
"^DD",798.3,798.3,1,21,13,0)
This date cannot be stored in the registry file 
"^DD",798.3,798.3,1,21,14,0)
(#798) because the patient has not been added to
"^DD",798.3,798.3,1,21,15,0)
the registry yet. So, the date is stored in this
"^DD",798.3,798.3,1,21,16,0)
multiple.  
"^DD",798.3,798.3,1,21,17,0)
     
"^DD",798.3,798.3,1,21,18,0)
Before the registry update process begins 
"^DD",798.3,798.3,1,21,19,0)
searching the data of the patient, it tries to
"^DD",798.3,798.3,1,21,20,0)
find a record for that patient in this multiple.
"^DD",798.3,798.3,1,21,21,0)
If it exists, the date from the record is used in
"^DD",798.3,798.3,1,21,22,0)
the search instead of regular date (from the
"^DD",798.3,798.3,1,21,23,0)
REGISTRY UPDATED UNTIL field of the REGISTRY
"^DD",798.3,798.3,1,21,24,0)
PARAMETERS file.
"^DD",798.3,798.3,1,21,25,0)
     
"^DD",798.3,798.3,1,21,26,0)
After successfully processing the patient data 
"^DD",798.3,798.3,1,21,27,0)
the corresponding record is deleted from this
"^DD",798.3,798.3,1,21,28,0)
multiple.  
"^DD",798.3,798.3,1,21,29,0)
     
"^DD",798.3,798.3,1,21,30,0)
Records of the multiple are uniquely identified by
"^DD",798.3,798.3,1,21,31,0)
the registry IEN. The "A" primary key and the "B"
"^DD",798.3,798.3,1,21,32,0)
uniqueness index are used for this purpose.
"^DD",798.3,798.3,1,21,33,0)
 
"^DD",798.3,798.3,1,21,34,0)
Usually, records within this multiple should not
"^DD",798.3,798.3,1,21,35,0)
be edited. Its content is handled automatically by
"^DD",798.3,798.3,1,21,36,0)
entry points from the routine RORUPP01 during the
"^DD",798.3,798.3,1,21,37,0)
registry update.  
"^DD",798.3,798.3,1,21,38,0)
     
"^DD",798.3,798.3,1,21,39,0)
However, if the errors are not corrected in the 
"^DD",798.3,798.3,1,21,40,0)
predefined time frame (2 weeks at the moment),
"^DD",798.3,798.3,1,21,41,0)
patient data will not be analized by the 
"^DD",798.3,798.3,1,21,42,0)
subsequent registry updates until someone fixes 
"^DD",798.3,798.3,1,21,43,0)
the errors and resets the the COUNTER field of the
"^DD",798.3,798.3,1,21,44,0)
patient records in this multiple.  
"^DD",798.3,798.3,2,0)
EVENT^798.32D^^2;0
"^DD",798.3,798.3,2,9)
@
"^DD",798.3,798.3,2,21,0)
^^9^9^3020424^
"^DD",798.3,798.3,2,21,1,0)
This multiple stores event references created by
"^DD",798.3,798.3,2,21,2,0)
the event protocols. The registry update uses
"^DD",798.3,798.3,2,21,3,0)
these references to speed up the processing.
"^DD",798.3,798.3,2,21,4,0)
 
"^DD",798.3,798.3,2,21,5,0)
The event references are grouped by the data areas
"^DD",798.3,798.3,2,21,6,0)
(protocols) and only one reference per associated 
"^DD",798.3,798.3,2,21,7,0)
date (the DATE field) for each data area is stored
"^DD",798.3,798.3,2,21,8,0)
at the moment. The "AD" cross-reference is used by
"^DD",798.3,798.3,2,21,9,0)
the $$ADD^RORUPP02 function for this purpose.
"^DD",798.3,798.3,2,"DT")
3020415
"^DD",798.3,798.31,0)
ERROR SUB-FIELD^^2^3
"^DD",798.3,798.31,0,"DT")
3020415
"^DD",798.3,798.31,0,"IX","AD",798.31,1)

"^DD",798.3,798.31,0,"NM","ERROR")

"^DD",798.3,798.31,0,"UP")
798.3
"^DD",798.3,798.31,.01,0)
REGISTRY^MP798.1'IX^ROR(798.1,^0;1^Q
"^DD",798.3,798.31,.01,1,0)
^.1^^0
"^DD",798.3,798.31,.01,8.5)
@
"^DD",798.3,798.31,.01,9)
@
"^DD",798.3,798.31,.01,21,0)
^.001^2^2^3020415^^
"^DD",798.3,798.31,.01,21,1,0)
The REGISTRY field identifies the registry that 
"^DD",798.3,798.31,.01,21,2,0)
the record is associated with.
"^DD",798.3,798.31,.01,"DT")
3020415
"^DD",798.3,798.31,1,0)
DATE^RD^^0;2^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798.3,798.31,1,1,0)
^.1
"^DD",798.3,798.31,1,1,1,0)
798.31^AD
"^DD",798.3,798.31,1,1,1,1)
S ^RORDATA(798.3,DA(1),1,"AD",$E(X,1,30),DA)=""
"^DD",798.3,798.31,1,1,1,2)
K ^RORDATA(798.3,DA(1),1,"AD",$E(X,1,30),DA)
"^DD",798.3,798.31,1,1,1,3)
Do not delete!
"^DD",798.3,798.31,1,1,1,"DT")
3020415
"^DD",798.3,798.31,1,8.5)
@
"^DD",798.3,798.31,1,9)
@
"^DD",798.3,798.31,1,21,0)
^^5^5^3020424^
"^DD",798.3,798.31,1,21,1,0)
The field holds the date that was used as the 
"^DD",798.3,798.31,1,21,2,0)
start date of the data search when problems arose
"^DD",798.3,798.31,1,21,3,0)
during the processing of patient data. After the
"^DD",798.3,798.31,1,21,4,0)
problems are fixed, the next data search will
"^DD",798.3,798.31,1,21,5,0)
start from this date (minus lag days).
"^DD",798.3,798.31,1,23,0)
^.001^4^4^3020424^^^
"^DD",798.3,798.31,1,23,1,0)
The value of this field is used instead of the regular
"^DD",798.3,798.31,1,23,2,0)
start date from the REGISTRY UPDATED UNTIL field of the
"^DD",798.3,798.31,1,23,3,0)
REGISTRY PARAMETERS file during the search for patient
"^DD",798.3,798.31,1,23,4,0)
data.
"^DD",798.3,798.31,1,"DT")
3020415
"^DD",798.3,798.31,2,0)
COUNTER^NJ2,0^^0;3^K:+X'=X!(X>99)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.3,798.31,2,3)
Type a Number between 1 and 99, 0 Decimal Digits
"^DD",798.3,798.31,2,21,0)
^^10^10^3020424^
"^DD",798.3,798.31,2,21,1,0)
When a patient is added to the ROR PENDING PATIENT
"^DD",798.3,798.31,2,21,2,0)
file (due to errors during the registry update),
"^DD",798.3,798.31,2,21,3,0)
this field is populated with 1.
"^DD",798.3,798.31,2,21,4,0)
 
"^DD",798.3,798.31,2,21,5,0)
Until someone fixes the error(s), every subsequent
"^DD",798.3,798.31,2,21,6,0)
registry update will increment a value of this 
"^DD",798.3,798.31,2,21,7,0)
field by 1. When it reaches a predefined threshold
"^DD",798.3,798.31,2,21,8,0)
value, the registry updates will skip this patient
"^DD",798.3,798.31,2,21,9,0)
until someone fixes the error(s) and resets this
"^DD",798.3,798.31,2,21,10,0)
field to 1.
"^DD",798.3,798.31,2,23,0)
^^10^10^3020424^
"^DD",798.3,798.31,2,23,1,0)
The $$ADD^RORUPP01 function initializes this field with
"^DD",798.3,798.31,2,23,2,0)
1 when the record is created. Then it increments its
"^DD",798.3,798.31,2,23,3,0)
value each time when the record is updated until the
"^DD",798.3,798.31,2,23,4,0)
field value become not less than a value of the local
"^DD",798.3,798.31,2,23,5,0)
RORUPD(MAXPPCNT") node (or 14 by default).
"^DD",798.3,798.31,2,23,6,0)
 
"^DD",798.3,798.31,2,23,7,0)
The function $$SDSDATE^RORUPP01 analizes the value of
"^DD",798.3,798.31,2,23,8,0)
the field and returns an error if the counters
"^DD",798.3,798.31,2,23,9,0)
associated with all processed registries have reached
"^DD",798.3,798.31,2,23,10,0)
the threshold.
"^DD",798.3,798.31,2,"DT")
3020415
"^DD",798.3,798.32,0)
EVENT SUB-FIELD^^2^3
"^DD",798.3,798.32,0,"DT")
3020502
"^DD",798.3,798.32,0,"IX","B",798.32,.01)

"^DD",798.3,798.32,0,"NM","EVENT")

"^DD",798.3,798.32,0,"UP")
798.3
"^DD",798.3,798.32,.01,0)
TIMESTAMP^MD^^0;1^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798.3,798.32,.01,1,0)
^.1
"^DD",798.3,798.32,.01,1,1,0)
798.32^B
"^DD",798.3,798.32,.01,1,1,1)
S ^RORDATA(798.3,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",798.3,798.32,.01,1,1,2)
K ^RORDATA(798.3,DA(1),2,"B",$E(X,1,30),DA)
"^DD",798.3,798.32,.01,1,1,3)
Do not delete!
"^DD",798.3,798.32,.01,1,2,0)
798.3^AT
"^DD",798.3,798.32,.01,1,2,1)
S ^RORDATA(798.3,"AT",$E(X,1,30),DA(1),DA)=""
"^DD",798.3,798.32,.01,1,2,2)
K ^RORDATA(798.3,"AT",$E(X,1,30),DA(1),DA)
"^DD",798.3,798.32,.01,1,2,3)
Do not delete!
"^DD",798.3,798.32,.01,1,2,"%D",0)
^^3^3^3020424^
"^DD",798.3,798.32,.01,1,2,"%D",1,0)
This cross-reference is used by the 
"^DD",798.3,798.32,.01,1,2,"%D",2,0)
$$PURGE^RORUPP02 function to purge the old event 
"^DD",798.3,798.32,.01,1,2,"%D",3,0)
references.
"^DD",798.3,798.32,.01,1,2,"DT")
3020419
"^DD",798.3,798.32,.01,8.5)
@
"^DD",798.3,798.32,.01,9)
@
"^DD",798.3,798.32,.01,21,0)
^.001^3^3^3020502^^
"^DD",798.3,798.32,.01,21,1,0)
This field stores the timestamp of the event
"^DD",798.3,798.32,.01,21,2,0)
reference (the current date and time when the
"^DD",798.3,798.32,.01,21,3,0)
reference was created).
"^DD",798.3,798.32,.01,"DT")
3020502
"^DD",798.3,798.32,1,0)
DATA AREA^RS^1:Lab;2:Visit;3:PTF;^0;2^Q
"^DD",798.3,798.32,1,8.5)
@
"^DD",798.3,798.32,1,9)
@
"^DD",798.3,798.32,1,21,0)
^.001^3^3^3020426^^
"^DD",798.3,798.32,1,21,1,0)
Internal value of this field is the code defining
"^DD",798.3,798.32,1,21,2,0)
the data area (protocol) that this event reference
"^DD",798.3,798.32,1,21,3,0)
associated with.
"^DD",798.3,798.32,1,23,0)
^^6^6^3020426^
"^DD",798.3,798.32,1,23,1,0)
The codes are associated with the event protocols as
"^DD",798.3,798.32,1,23,2,0)
follow:
"^DD",798.3,798.32,1,23,3,0)
 
"^DD",798.3,798.32,1,23,4,0)
 1 - ROR EVENT LAB (LR7O ALL EVSEND RESULTS)
"^DD",798.3,798.32,1,23,5,0)
 2 - ROR EVENT VISIT (PXK VISIT DATA EVENT)
"^DD",798.3,798.32,1,23,6,0)
 3 - ROR EVENT PTF (DGPM MOVEMENT EVENTS)
"^DD",798.3,798.32,1,"DT")
3020419
"^DD",798.3,798.32,2,0)
DATE^D^^0;3^S %DT="EST" D ^%DT S X=Y K:Y<1 X
"^DD",798.3,798.32,2,1,0)
^.1^^0
"^DD",798.3,798.32,2,8.5)
@
"^DD",798.3,798.32,2,9)
@
"^DD",798.3,798.32,2,21,0)
^.001^3^3^3020424^^
"^DD",798.3,798.32,2,21,1,0)
This field stores the date and time associated
"^DD",798.3,798.32,2,21,2,0)
with the event. For example, collection date/time
"^DD",798.3,798.32,2,21,3,0)
of the specimen is stored here for the Lab event.
"^DD",798.3,798.32,2,"DT")
3020419
"^DD",798.4,798.4,0)
FIELD^^991.01^14
"^DD",798.4,798.4,0,"DDA")
N
"^DD",798.4,798.4,0,"DT")
3020502
"^DD",798.4,798.4,0,"IX","B",798.4,.01)

"^DD",798.4,798.4,0,"IX","BS",798.4,.09)

"^DD",798.4,798.4,0,"IX","BS5",798.4,.09)

"^DD",798.4,798.4,0,"IX","SSN",798.4,.09)

"^DD",798.4,798.4,0,"NM","ROR PATIENT")

"^DD",798.4,798.4,0,"PT",798,.01)

"^DD",798.4,798.4,0,"VRPK")
ROR
"^DD",798.4,798.4,.01,0)
PATIENT NAME^RP2'X^DPT(^0;1^S:$D(X) DINUM=X
"^DD",798.4,798.4,.01,1,0)
^.1
"^DD",798.4,798.4,.01,1,1,0)
798.4^B
"^DD",798.4,798.4,.01,1,1,1)
S ^RORDATA(798.4,"B",$E(X,1,30),DA)=""
"^DD",798.4,798.4,.01,1,1,2)
K ^RORDATA(798.4,"B",$E(X,1,30),DA)
"^DD",798.4,798.4,.01,1,1,3)
Do not delete!
"^DD",798.4,798.4,.01,1,1,"DT")
3000523
"^DD",798.4,798.4,.01,3)

"^DD",798.4,798.4,.01,21,0)
^^2^2^3020403^
"^DD",798.4,798.4,.01,21,1,0)
You can select an existing patient or add a new 
"^DD",798.4,798.4,.01,21,2,0)
one from the PATIENT file (#2).
"^DD",798.4,798.4,.01,23,0)
^^4^4^3020403^
"^DD",798.4,798.4,.01,23,1,0)
The PATIENT NAME field points to the patient record in 
"^DD",798.4,798.4,.01,23,2,0)
the PATIENT file (#2). Internal value of this field is
"^DD",798.4,798.4,.01,23,3,0)
used as internal entry number of the record ("DINUM"
"^DD",798.4,798.4,.01,23,4,0)
feature).
"^DD",798.4,798.4,.01,"DEL",1,0)
I $D(^RORDATA(798,"B",+$G(DA)))
"^DD",798.4,798.4,.01,"DT")
3000523
"^DD",798.4,798.4,.02,0)
SEX^SI^M:MALE;F:FEMALE;^0;2^Q
"^DD",798.4,798.4,.02,21,0)
^.001^1^1^3020403^^
"^DD",798.4,798.4,.02,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.02,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.02,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.02,"DT")
3011120
"^DD",798.4,798.4,.03,0)
DATE OF BIRTH^RDOI^^0;3^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.4,798.4,.03,2)
S Y(0)=Y S Y(0)=Y S X=Y(0) S:X X=$E(X,4,5)_"/"_$E(X,6,7)_"/"_(1700+$E(X,1,3)) S Y=X
"^DD",798.4,798.4,.03,2.1)
S Y(0)=Y S X=Y(0) S:X X=$E(X,4,5)_"/"_$E(X,6,7)_"/"_(1700+$E(X,1,3)) S Y=X
"^DD",798.4,798.4,.03,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,.03,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.03,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.03,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.03,"DT")
3011120
"^DD",798.4,798.4,.06,0)
RACE^P10'I^DIC(10,^0;4^Q
"^DD",798.4,798.4,.06,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,.06,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.06,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.06,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.06,"DT")
3011120
"^DD",798.4,798.4,.09,0)
SOCIAL SECURITY NUMBER^RFOI^^0;5^K:$L(X)>11!($L(X)<9) X
"^DD",798.4,798.4,.09,1,0)
^.1
"^DD",798.4,798.4,.09,1,1,0)
798.4^BS^MUMPS
"^DD",798.4,798.4,.09,1,1,1)
S ^RORDATA(798.4,"BS",$E(X,6,9),DA)=""
"^DD",798.4,798.4,.09,1,1,2)
K ^RORDATA(798.4,"BS",$E(X,6,9),DA)
"^DD",798.4,798.4,.09,1,1,3)
Do not delete!
"^DD",798.4,798.4,.09,1,1,"%D",0)
^.101^1^1^3011220^^
"^DD",798.4,798.4,.09,1,1,"%D",1,0)
The cross-reference on the last four digits of the SSN.
"^DD",798.4,798.4,.09,1,1,"DT")
3000426
"^DD",798.4,798.4,.09,1,2,0)
798.4^BS5^MUMPS
"^DD",798.4,798.4,.09,1,2,1)
S ^RORDATA(798.4,"BS5",$E(^DPT(DA,0),1)_$E(X,6,9),DA)=""
"^DD",798.4,798.4,.09,1,2,2)
K ^RORDATA(798.4,"BS5",$E(^DPT(DA,0),1)_$E(X,6,9),DA)
"^DD",798.4,798.4,.09,1,2,3)
Do not delete!
"^DD",798.4,798.4,.09,1,2,"%D",0)
^^3^3^3020403^
"^DD",798.4,798.4,.09,1,2,"%D",1,0)
This cross-reference contains values combined from
"^DD",798.4,798.4,.09,1,2,"%D",2,0)
the first letter of the last name and last four
"^DD",798.4,798.4,.09,1,2,"%D",3,0)
digits of the SSN.
"^DD",798.4,798.4,.09,1,2,"DT")
3011220
"^DD",798.4,798.4,.09,1,3,0)
798.4^SSN
"^DD",798.4,798.4,.09,1,3,1)
S ^RORDATA(798.4,"SSN",$E(X,1,30),DA)=""
"^DD",798.4,798.4,.09,1,3,2)
K ^RORDATA(798.4,"SSN",$E(X,1,30),DA)
"^DD",798.4,798.4,.09,1,3,3)
Do not delete!
"^DD",798.4,798.4,.09,1,3,"DT")
3011221
"^DD",798.4,798.4,.09,2)
S Y(0)=Y S:$L(Y)=11 Y=$E(Y,10,11)_$E(Y,1,9)
"^DD",798.4,798.4,.09,2.1)
S:$L(Y)=11 Y=$E(Y,10,11)_$E(Y,1,9)
"^DD",798.4,798.4,.09,3)
Answer must be 9-11 characters in length.
"^DD",798.4,798.4,.09,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,.09,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.09,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.09,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.09,"DT")
3020403
"^DD",798.4,798.4,.1112,0)
ZIP+4^FI^^0;6^K:$L(X)>9!($L(X)<5) X
"^DD",798.4,798.4,.1112,3)
Answer must be 5-9 characters in length.
"^DD",798.4,798.4,.1112,21,0)
^^1^1^3011101^
"^DD",798.4,798.4,.1112,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.1112,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.1112,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.1112,"DT")
3011120
"^DD",798.4,798.4,.301,0)
SERVICE CONNECTED?^RSI^Y:YES;N:NO;^0;7^Q
"^DD",798.4,798.4,.301,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,.301,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.301,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.301,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.301,"DT")
3011120
"^DD",798.4,798.4,.302,0)
SERVICE CONNECTED PERCENTAGE^NJ3,0I^^0;9^K:+X'=X!(X>100)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.4,798.4,.302,3)
Type a Number between 0 and 100, 0 Decimal Digits
"^DD",798.4,798.4,.302,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,.302,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.302,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.302,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.302,"DT")
3011120
"^DD",798.4,798.4,.323,0)
PERIOD OF SERVICE^P21'I^DIC(21,^0;11^Q
"^DD",798.4,798.4,.323,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,.323,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.323,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.323,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.323,"DT")
3011120
"^DD",798.4,798.4,.351,0)
DATE OF DEATH^DI^^0;8^S %DT="ET" D ^%DT S X=Y K:Y<1 X
"^DD",798.4,798.4,.351,21,0)
^.001^1^1^3020502^^^^
"^DD",798.4,798.4,.351,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.351,23,0)
^.001^1^1^3020502^^^^
"^DD",798.4,798.4,.351,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.351,"DT")
3020502
"^DD",798.4,798.4,.3721,0)
RATED DISABILITIES (VA)^798.41P^^.372;0
"^DD",798.4,798.4,.3721,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,.3721,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.3721,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.3721,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,10.1,0)
OLD SSN^FI^^0;12^K:$L(X)>11!($L(X)<9) X
"^DD",798.4,798.4,10.1,3)
Answer must be 9-11 characters in length.
"^DD",798.4,798.4,10.1,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,10.1,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,10.1,23,0)
^^3^3^3011011^
"^DD",798.4,798.4,10.1,23,1,0)
This field contains the previous value of the patient 
"^DD",798.4,798.4,10.1,23,2,0)
SSN. The registry extraction process transmits both new
"^DD",798.4,798.4,10.1,23,3,0)
and old values of the SSN to the national registries.
"^DD",798.4,798.4,10.1,"DT")
3011120
"^DD",798.4,798.4,10.2,0)
OLD ICN^NJ12,0I^^0;13^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.4,798.4,10.2,3)
Type a Number between 0 and 999999999999, 0 Decimal Digits
"^DD",798.4,798.4,10.2,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,10.2,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,10.2,23,0)
^^4^4^3011011^
"^DD",798.4,798.4,10.2,23,1,0)
This field contains the previous value of the patient 
"^DD",798.4,798.4,10.2,23,2,0)
INTEGRATION CONTROL NUMBER. The registry extraction
"^DD",798.4,798.4,10.2,23,3,0)
process transmits both new and old values of the ICN to
"^DD",798.4,798.4,10.2,23,4,0)
the national registries.
"^DD",798.4,798.4,10.2,"DT")
3011120
"^DD",798.4,798.4,991.01,0)
INTEGRATION CONTROL NUMBER^NJ12,0I^^0;10^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.4,798.4,991.01,3)
Type a Number between 0 and 999999999999, 0 Decimal Digits
"^DD",798.4,798.4,991.01,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,991.01,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,991.01,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,991.01,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,991.01,"DT")
3011120
"^DD",798.4,798.41,0)
RATED DISABILITIES (VA) SUB-FIELD^^3^3
"^DD",798.4,798.41,0,"DT")
3000426
"^DD",798.4,798.41,0,"IX","B",798.41,.01)

"^DD",798.4,798.41,0,"NM","RATED DISABILITIES (VA)")

"^DD",798.4,798.41,0,"UP")
798.4
"^DD",798.4,798.41,.01,0)
RATED DISABILITIES (VA)^MP31'I^DIC(31,^0;1^Q
"^DD",798.4,798.41,.01,1,0)
^.1
"^DD",798.4,798.41,.01,1,1,0)
798.41^B
"^DD",798.4,798.41,.01,1,1,1)
S ^RORDATA(798.4,DA(1),.372,"B",$E(X,1,30),DA)=""
"^DD",798.4,798.41,.01,1,1,2)
K ^RORDATA(798.4,DA(1),.372,"B",$E(X,1,30),DA)
"^DD",798.4,798.41,.01,1,1,3)
Do not delete!
"^DD",798.4,798.41,.01,21,0)
^^1^1^3011011^
"^DD",798.4,798.41,.01,21,1,0)
Do not edit this field!
"^DD",798.4,798.41,.01,23,0)
^^1^1^3020403^
"^DD",798.4,798.41,.01,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.41,.01,"DT")
3011120
"^DD",798.4,798.41,2,0)
DISABILITY %^RNJ3,0I^^0;2^K:+X'=X!(X>100)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.4,798.41,2,3)
Type a Number between 0 and 100, 0 Decimal Digits
"^DD",798.4,798.41,2,21,0)
^^1^1^3011011^
"^DD",798.4,798.41,2,21,1,0)
Do not edit this field!
"^DD",798.4,798.41,2,23,0)
^^1^1^3020403^
"^DD",798.4,798.41,2,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.41,2,"DT")
3011120
"^DD",798.4,798.41,3,0)
SERVICE CONNECTED^SI^0:NO;1:YES;^0;3^Q
"^DD",798.4,798.41,3,21,0)
^^1^1^3011011^
"^DD",798.4,798.41,3,21,1,0)
Do not edit this field!
"^DD",798.4,798.41,3,23,0)
^^1^1^3020403^
"^DD",798.4,798.41,3,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.41,3,"DT")
3011120
"^DD",798.5,798.5,0)
FIELD^^4^9
"^DD",798.5,798.5,0,"DDA")
N
"^DD",798.5,798.5,0,"DT")
3011114
"^DD",798.5,798.5,0,"IX","AR",798.5,.02)

"^DD",798.5,798.5,0,"IX","B",798.5,.01)

"^DD",798.5,798.5,0,"IX","T",798.5,2.01)

"^DD",798.5,798.5,0,"NM","ROR HDT TASK")

"^DD",798.5,798.5,0,"VRPK")
ROR
"^DD",798.5,798.5,.01,0)
START RECORD IEN^RNJ12,0^^0;1^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.5,798.5,.01,1,0)
^.1
"^DD",798.5,798.5,.01,1,1,0)
798.5^B
"^DD",798.5,798.5,.01,1,1,1)
S ^RORDATA(798.5,"B",$E(X,1,30),DA)=""
"^DD",798.5,798.5,.01,1,1,2)
K ^RORDATA(798.5,"B",$E(X,1,30),DA)
"^DD",798.5,798.5,.01,1,1,3)
Do not delete!
"^DD",798.5,798.5,.01,3)
Enter an IEN of the registry record (1-999999999999, 0 Decimal Digits).
"^DD",798.5,798.5,.01,8.5)
@
"^DD",798.5,798.5,.01,9)
@
"^DD",798.5,798.5,.01,21,0)
^^16^16^3011108^
"^DD",798.5,798.5,.01,21,1,0)
All patients in the registry are distributed 
"^DD",798.5,798.5,.01,21,2,0)
between the data extraction tasks. Each task
"^DD",798.5,798.5,.01,21,3,0)
extracts the data of the patients whose registry
"^DD",798.5,798.5,.01,21,4,0)
records have IENs that are not less than the value
"^DD",798.5,798.5,.01,21,5,0)
of this field in the task record and are less than
"^DD",798.5,798.5,.01,21,6,0)
the value of the field in the next task record.
"^DD",798.5,798.5,.01,21,7,0)
                                 
"^DD",798.5,798.5,.01,21,8,0)
The first task always has 1 as a value of this
"^DD",798.5,798.5,.01,21,9,0)
field (just in case).  
"^DD",798.5,798.5,.01,21,10,0)
                                 
"^DD",798.5,798.5,.01,21,11,0)
The last task extracts the data of all patients
"^DD",798.5,798.5,.01,21,12,0)
whose registry records have IENs not less than the
"^DD",798.5,798.5,.01,21,13,0)
value of this field.  
"^DD",798.5,798.5,.01,21,14,0)
                                 
"^DD",798.5,798.5,.01,21,15,0)
Usually, this field should not be edited. It is
"^DD",798.5,798.5,.01,21,16,0)
populated automatically when the task is created.
"^DD",798.5,798.5,.01,23,0)
^^7^7^3020403^
"^DD",798.5,798.5,.01,23,1,0)
The value of this field is not a real pointer to the 
"^DD",798.5,798.5,.01,23,2,0)
ROR LOCAL REGISTRY file. There can be no record in the
"^DD",798.5,798.5,.01,23,3,0)
local registry with an IEN stored in this field.
"^DD",798.5,798.5,.01,23,4,0)
 
"^DD",798.5,798.5,.01,23,5,0)
The historical data extraction task will start 
"^DD",798.5,798.5,.01,23,6,0)
processing from the registry record with IEN that is
"^DD",798.5,798.5,.01,23,7,0)
not less than the value of this field.
"^DD",798.5,798.5,.01,"DT")
3011108
"^DD",798.5,798.5,.02,0)
REGISTRY^P798.1'I^ROR(798.1,^0;2^Q
"^DD",798.5,798.5,.02,1,0)
^.1
"^DD",798.5,798.5,.02,1,1,0)
798.5^AR
"^DD",798.5,798.5,.02,1,1,1)
S ^RORDATA(798.5,"AR",$E(X,1,30),DA)=""
"^DD",798.5,798.5,.02,1,1,2)
K ^RORDATA(798.5,"AR",$E(X,1,30),DA)
"^DD",798.5,798.5,.02,1,1,3)
Do not delete!
"^DD",798.5,798.5,.02,1,1,"DT")
3011108
"^DD",798.5,798.5,.02,8.5)
@
"^DD",798.5,798.5,.02,9)
@
"^DD",798.5,798.5,.02,21,0)
^^2^2^3011108^
"^DD",798.5,798.5,.02,21,1,0)
This field identifies the registry that the task
"^DD",798.5,798.5,.02,21,2,0)
is associated with.
"^DD",798.5,798.5,.02,"DT")
3011116
"^DD",798.5,798.5,1.01,0)
FILE NAME^FX^^0;3^K:$L(X)>30!($L(X)<3)!($L($TR(X,"*?/\[]|"":<>"))<$L(X)) X
"^DD",798.5,798.5,1.01,3)
Answer must be 3-30 characters in length.
"^DD",798.5,798.5,1.01,8.5)
@
"^DD",798.5,798.5,1.01,9)
@
"^DD",798.5,798.5,1.01,21,0)
^.001^18^18^3011114^^^
"^DD",798.5,798.5,1.01,21,1,0)
The output file name is stored in this field. This
"^DD",798.5,798.5,1.01,21,2,0)
name is generated automatically when the task is
"^DD",798.5,798.5,1.01,21,3,0)
created. The name has the following structure:
"^DD",798.5,798.5,1.01,21,4,0)
                                 
"^DD",798.5,798.5,1.01,21,5,0)
 SsssTtt.HDT 
"^DD",798.5,798.5,1.01,21,6,0)
                                 
"^DD",798.5,798.5,1.01,21,7,0)
where 'sss' is the site number and 'tt' is the
"^DD",798.5,798.5,1.01,21,8,0)
sequential number of the task.  
"^DD",798.5,798.5,1.01,21,9,0)
                                 
"^DD",798.5,798.5,1.01,21,10,0)
If the task is restarted, the optional numeric
"^DD",798.5,798.5,1.01,21,11,0)
modifier 'nn' can be added to the name so that the
"^DD",798.5,798.5,1.01,21,12,0)
already extracted data will not be overwritten:
"^DD",798.5,798.5,1.01,21,13,0)
                                 
"^DD",798.5,798.5,1.01,21,14,0)
 SsssTtt-nn.HDT 
"^DD",798.5,798.5,1.01,21,15,0)
                                 
"^DD",798.5,798.5,1.01,21,16,0)
Usually, this field should not be edited. It is
"^DD",798.5,798.5,1.01,21,17,0)
populated automatically when the task is created
"^DD",798.5,798.5,1.01,21,18,0)
or restarted.  
"^DD",798.5,798.5,1.01,23,0)
^^3^3^3020403^
"^DD",798.5,798.5,1.01,23,1,0)
Uniqueness of the output file names (for the same 
"^DD",798.5,798.5,1.01,23,2,0)
registry) is guaranteed by the "B" secondary key and
"^DD",798.5,798.5,1.01,23,3,0)
the "DF" index.
"^DD",798.5,798.5,1.01,"DT")
3011114
"^DD",798.5,798.5,2.01,0)
TASK NUMBER^NJ10,0I^^0;4^K:+X'=X!(X>9899999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.5,798.5,2.01,1,0)
^.1
"^DD",798.5,798.5,2.01,1,1,0)
798.5^T
"^DD",798.5,798.5,2.01,1,1,1)
S ^RORDATA(798.5,"T",$E(X,1,30),DA)=""
"^DD",798.5,798.5,2.01,1,1,2)
K ^RORDATA(798.5,"T",$E(X,1,30),DA)
"^DD",798.5,798.5,2.01,1,1,3)
Do not delete!
"^DD",798.5,798.5,2.01,1,1,"%D",0)
^^3^3^3011108^
"^DD",798.5,798.5,2.01,1,1,"%D",1,0)
This cross-reference can be used to find a 
"^DD",798.5,798.5,2.01,1,1,"%D",2,0)
historical data extraction task using the task
"^DD",798.5,798.5,2.01,1,1,"%D",3,0)
number assigned by TaskMan.
"^DD",798.5,798.5,2.01,1,1,"DT")
3011108
"^DD",798.5,798.5,2.01,3)
Type a Number between 1 and 9899999999, 0 Decimal Digits.
"^DD",798.5,798.5,2.01,8.5)
@
"^DD",798.5,798.5,2.01,9)
@
"^DD",798.5,798.5,2.01,21,0)
^^6^6^3011108^
"^DD",798.5,798.5,2.01,21,1,0)
This field contains the number of the Taskman task
"^DD",798.5,798.5,2.01,21,2,0)
(scheduled or running) that does the data
"^DD",798.5,798.5,2.01,21,3,0)
extraction.  
"^DD",798.5,798.5,2.01,21,4,0)
                                 
"^DD",798.5,798.5,2.01,21,5,0)
This field cannot be edited. It is updated
"^DD",798.5,798.5,2.01,21,6,0)
automatically by the data extraction task.
"^DD",798.5,798.5,2.01,"DT")
3011116
"^DD",798.5,798.5,2.02,0)
JOB NUMBER^NJ12,0I^^0;5^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.5,798.5,2.02,3)
Type a Number between 1 and 999999999999, 0 Decimal Digits.
"^DD",798.5,798.5,2.02,8.5)
@
"^DD",798.5,798.5,2.02,9)
@
"^DD",798.5,798.5,2.02,21,0)
^^5^5^3011108^
"^DD",798.5,798.5,2.02,21,1,0)
This field contains the job number of the M 
"^DD",798.5,798.5,2.02,21,2,0)
process that does/did the data extraction.
"^DD",798.5,798.5,2.02,21,3,0)
                                 
"^DD",798.5,798.5,2.02,21,4,0)
This field cannot be edited. It is updated
"^DD",798.5,798.5,2.02,21,5,0)
automatically by the data extraction task.
"^DD",798.5,798.5,2.02,23,0)
^.001^2^2^3020403^^
"^DD",798.5,798.5,2.02,23,1,0)
The task has crashed or has been forced to exit if it
"^DD",798.5,798.5,2.02,23,2,0)
is not running and this field has a value.
"^DD",798.5,798.5,2.02,"DT")
3011116
"^DD",798.5,798.5,2.03,0)
COMPLETED^SI^0:NO;1:YES;^0;6^Q
"^DD",798.5,798.5,2.03,8.5)
@
"^DD",798.5,798.5,2.03,9)
@
"^DD",798.5,798.5,2.03,21,0)
^^5^5^3020403^
"^DD",798.5,798.5,2.03,21,1,0)
This field is set to "Yes" if the data extraction
"^DD",798.5,798.5,2.03,21,2,0)
task has been completed without any errors.
"^DD",798.5,798.5,2.03,21,3,0)
                                 
"^DD",798.5,798.5,2.03,21,4,0)
This field cannot be edited. It is updated
"^DD",798.5,798.5,2.03,21,5,0)
automatically by the data extraction task.
"^DD",798.5,798.5,2.03,"DT")
3011119
"^DD",798.5,798.5,2.04,0)
LOG^P798.7'I^RORDATA(798.7,^0;7^Q
"^DD",798.5,798.5,2.04,8.5)
@
"^DD",798.5,798.5,2.04,9)
@
"^DD",798.5,798.5,2.04,21,0)
^^6^6^3011108^
"^DD",798.5,798.5,2.04,21,1,0)
This fields contains a pointer to the log file 
"^DD",798.5,798.5,2.04,21,2,0)
that was created during the last run of the data
"^DD",798.5,798.5,2.04,21,3,0)
extraction task.  
"^DD",798.5,798.5,2.04,21,4,0)
                                 
"^DD",798.5,798.5,2.04,21,5,0)
This field cannot be edited. It is updated
"^DD",798.5,798.5,2.04,21,6,0)
automatically by the data extraction task.
"^DD",798.5,798.5,2.04,"DT")
3011116
"^DD",798.5,798.5,3,0)
ERROR^798.53P^^3;0
"^DD",798.5,798.5,3,9)
@
"^DD",798.5,798.5,3,21,0)
^^11^11^3020403^
"^DD",798.5,798.5,3,21,1,0)
This multiple contains a list of registry records
"^DD",798.5,798.5,3,21,2,0)
that were processed with errors.  
"^DD",798.5,798.5,3,21,3,0)
 
"^DD",798.5,798.5,3,21,4,0)
When the data extraction task is restarted, it
"^DD",798.5,798.5,3,21,5,0)
tries to re-extract the data for these patients.  
"^DD",798.5,798.5,3,21,6,0)
If it succeeds, it deletes the corresponding
"^DD",798.5,798.5,3,21,7,0)
records from the list.  
"^DD",798.5,798.5,3,21,8,0)
 
"^DD",798.5,798.5,3,21,9,0)
The records of the multiple have the same IENs as
"^DD",798.5,798.5,3,21,10,0)
the corresponding registry records in the ROR
"^DD",798.5,798.5,3,21,11,0)
LOCAL REGISTRY file.
"^DD",798.5,798.5,4,0)
NEXT RECORD IEN^NJ12,0^^0;8^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.5,798.5,4,3)
Enter an IEN of the registry record (1-999999999999, 0 Decimal Digits).
"^DD",798.5,798.5,4,8.5)
@
"^DD",798.5,798.5,4,9)
@
"^DD",798.5,798.5,4,21,0)
^^10^10^3011214^
"^DD",798.5,798.5,4,21,1,0)
If the data extraction task is stopped, it finishes
"^DD",798.5,798.5,4,21,2,0)
processing the current registry record and stores
"^DD",798.5,798.5,4,21,3,0)
an IEN of the record that should be processed next
"^DD",798.5,798.5,4,21,4,0)
as a value of this field.  
"^DD",798.5,798.5,4,21,5,0)
                                 
"^DD",798.5,798.5,4,21,6,0)
When the task is restarted, it starts from the
"^DD",798.5,798.5,4,21,7,0)
the registry record IEN stored in this field.
"^DD",798.5,798.5,4,21,8,0)
                                 
"^DD",798.5,798.5,4,21,9,0)
Usually, this field should not be edited. It is
"^DD",798.5,798.5,4,21,10,0)
updated automatically by the data extraction task.
"^DD",798.5,798.5,4,23,0)
^^7^7^3020403^
"^DD",798.5,798.5,4,23,1,0)
The value of this field is not a real pointer to the 
"^DD",798.5,798.5,4,23,2,0)
ROR LOCAL REGISTRY file. There can be no record in the
"^DD",798.5,798.5,4,23,3,0)
local registry with an IEN stored in this field.
"^DD",798.5,798.5,4,23,4,0)
 
"^DD",798.5,798.5,4,23,5,0)
The restarted historical data extraction task will 
"^DD",798.5,798.5,4,23,6,0)
continue processing from the registry record with IEN
"^DD",798.5,798.5,4,23,7,0)
that is not less than the value of this field.
"^DD",798.5,798.5,4,"DT")
3011109
"^DD",798.5,798.53,0)
ERROR SUB-FIELD^^.01^1
"^DD",798.5,798.53,0,"DT")
3011108
"^DD",798.5,798.53,0,"IX","B",798.53,.01)

"^DD",798.5,798.53,0,"NM","ERROR")

"^DD",798.5,798.53,0,"UP")
798.5
"^DD",798.5,798.53,.01,0)
RECORD^MP798'X^RORDATA(798,^0;1^S:$D(X) DINUM=X
"^DD",798.5,798.53,.01,1,0)
^.1
"^DD",798.5,798.53,.01,1,1,0)
798.53^B
"^DD",798.5,798.53,.01,1,1,1)
S ^RORDATA(798.5,DA(1),3,"B",$E(X,1,30),DA)=""
"^DD",798.5,798.53,.01,1,1,2)
K ^RORDATA(798.5,DA(1),3,"B",$E(X,1,30),DA)
"^DD",798.5,798.53,.01,1,1,3)
Do not delete!
"^DD",798.5,798.53,.01,8.5)
@
"^DD",798.5,798.53,.01,9)
@
"^DD",798.5,798.53,.01,21,0)
^^6^6^3011108^
"^DD",798.5,798.53,.01,21,1,0)
This field holds a pointer to the registry record
"^DD",798.5,798.53,.01,21,2,0)
that was processed with errors. If the task is
"^DD",798.5,798.53,.01,21,3,0)
restarted, it tries to re-extract this data.
"^DD",798.5,798.53,.01,21,4,0)
                                   
"^DD",798.5,798.53,.01,21,5,0)
Usually, this field should not be edited. It is
"^DD",798.5,798.53,.01,21,6,0)
updated automatically by the data extraction task.
"^DD",798.5,798.53,.01,"DT")
3011108
"^DD",798.6,798.6,0)
FIELD^^.02^2
"^DD",798.6,798.6,0,"DDA")
N
"^DD",798.6,798.6,0,"DT")
3000423
"^DD",798.6,798.6,0,"IX","AC",798.6,.02)

"^DD",798.6,798.6,0,"IX","B",798.6,.01)

"^DD",798.6,798.6,0,"NM","ROR PHARMACY CODE")

"^DD",798.6,798.6,0,"VRPK")
ROR
"^DD",798.6,798.6,.01,0)
DRUG CLASS^RP50.605'^PS(50.605,^0;1^Q
"^DD",798.6,798.6,.01,1,0)
^.1
"^DD",798.6,798.6,.01,1,1,0)
798.6^B
"^DD",798.6,798.6,.01,1,1,1)
S ^ROR(798.6,"B",$E(X,1,30),DA)=""
"^DD",798.6,798.6,.01,1,1,2)
K ^ROR(798.6,"B",$E(X,1,30),DA)
"^DD",798.6,798.6,.01,1,1,3)
Do not delete!
"^DD",798.6,798.6,.01,3)

"^DD",798.6,798.6,.01,21,0)
^^2^2^3011102^
"^DD",798.6,798.6,.01,21,1,0)
Select a Drug Class from any of the Class's on 
"^DD",798.6,798.6,.01,21,2,0)
the VA DRUG CLASS FILE (#50.605).
"^DD",798.6,798.6,.01,23,0)
^^3^3^3020403^
"^DD",798.6,798.6,.01,23,1,0)
This field is a pointer to the VA DRUG CLASS file
"^DD",798.6,798.6,.01,23,2,0)
(#50.605).  This Class or Class's represent groupings
"^DD",798.6,798.6,.01,23,3,0)
of registry related drugs.
"^DD",798.6,798.6,.01,"DT")
3000423
"^DD",798.6,798.6,.02,0)
REGISTRY^RP798.1'^ROR(798.1,^0;2^Q
"^DD",798.6,798.6,.02,1,0)
^.1
"^DD",798.6,798.6,.02,1,1,0)
798.6^AC
"^DD",798.6,798.6,.02,1,1,1)
S ^ROR(798.6,"AC",$E(X,1,30),DA)=""
"^DD",798.6,798.6,.02,1,1,2)
K ^ROR(798.6,"AC",$E(X,1,30),DA)
"^DD",798.6,798.6,.02,1,1,3)
Do not delete!
"^DD",798.6,798.6,.02,1,1,"%D",0)
^^2^2^3011120^
"^DD",798.6,798.6,.02,1,1,"%D",1,0)
This cross-reference links all drug classes
"^DD",798.6,798.6,.02,1,1,"%D",2,0)
associated with the registry together.
"^DD",798.6,798.6,.02,1,1,"DT")
3010803
"^DD",798.6,798.6,.02,21,0)
^^2^2^3020403^
"^DD",798.6,798.6,.02,21,1,0)
The REGISTRY field identifies the registry that 
"^DD",798.6,798.6,.02,21,2,0)
the record belongs to.
"^DD",798.6,798.6,.02,23,0)
^^3^3^3020403^
"^DD",798.6,798.6,.02,23,1,0)
Traditional cross-reference "AC" is used to link 
"^DD",798.6,798.6,.02,23,2,0)
all drug classes associated with the the registry
"^DD",798.6,798.6,.02,23,3,0)
together.
"^DD",798.6,798.6,.02,"DT")
3010803
"^DD",798.7,798.7,0)
FIELD^^6.03^9
"^DD",798.7,798.7,0,"DDA")
N
"^DD",798.7,798.7,0,"DT")
3011109
"^DD",798.7,798.7,0,"IX","B",798.7,.01)

"^DD",798.7,798.7,0,"IX","C",798.7,2)

"^DD",798.7,798.7,0,"NM","ROR LOG")

"^DD",798.7,798.7,0,"PT",798.5,2.04)

"^DD",798.7,798.7,0,"VRPK")
ROR
"^DD",798.7,798.7,.01,0)
START DATE/TIME^RDI^^0;1^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798.7,798.7,.01,1,0)
^.1
"^DD",798.7,798.7,.01,1,1,0)
798.7^B
"^DD",798.7,798.7,.01,1,1,1)
S ^RORDATA(798.7,"B",$E(X,1,30),DA)=""
"^DD",798.7,798.7,.01,1,1,2)
K ^RORDATA(798.7,"B",$E(X,1,30),DA)
"^DD",798.7,798.7,.01,1,1,3)
Do not delete!
"^DD",798.7,798.7,.01,3)

"^DD",798.7,798.7,.01,21,0)
^^2^2^3020403^
"^DD",798.7,798.7,.01,21,1,0)
This field contains the date/time when this log 
"^DD",798.7,798.7,.01,21,2,0)
was created.
"^DD",798.7,798.7,.01,23,0)
^^2^2^3020403^
"^DD",798.7,798.7,.01,23,1,0)
The $$OPEN^RORLOG function populates this field
"^DD",798.7,798.7,.01,23,2,0)
automatically when a new log is created.
"^DD",798.7,798.7,.01,"DT")
3010807
"^DD",798.7,798.7,1,0)
ACTIVITY^S^0:Other;1:Registry Update;2:Data Extraction;3:Acknowledgement;4:Hist. Extraction;^0;3^Q
"^DD",798.7,798.7,1,21,0)
^^2^2^3011011^
"^DD",798.7,798.7,1,21,1,0)
The value of this field indicates the activity
"^DD",798.7,798.7,1,21,2,0)
performed by the process that created the log.
"^DD",798.7,798.7,1,23,0)
^^2^2^3020403^
"^DD",798.7,798.7,1,23,1,0)
This field is populated by the $$OPEN^RORLOG function 
"^DD",798.7,798.7,1,23,2,0)
with the value passed as one of the parameters.
"^DD",798.7,798.7,1,"DT")
3011011
"^DD",798.7,798.7,2,0)
JOB NUMBER^NJ12,0^^0;4^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.7,798.7,2,1,0)
^.1
"^DD",798.7,798.7,2,1,1,0)
798.7^C
"^DD",798.7,798.7,2,1,1,1)
S ^RORDATA(798.7,"C",$E(X,1,30),DA)=""
"^DD",798.7,798.7,2,1,1,2)
K ^RORDATA(798.7,"C",$E(X,1,30),DA)
"^DD",798.7,798.7,2,1,1,3)
Do not delete!
"^DD",798.7,798.7,2,1,1,"%D",0)
^^3^3^3011011^
"^DD",798.7,798.7,2,1,1,"%D",1,0)
This cross-reference can be used in the 
"^DD",798.7,798.7,2,1,1,"%D",2,0)
troubleshooting process to find the log by the job
"^DD",798.7,798.7,2,1,1,"%D",3,0)
number.
"^DD",798.7,798.7,2,1,1,"DT")
3010813
"^DD",798.7,798.7,2,3)
Enter a job number between 1 and 999999999999, 0 Decimal Digits.
"^DD",798.7,798.7,2,21,0)
^^2^2^3020403^
"^DD",798.7,798.7,2,21,1,0)
Value of the JOB NUMBER field is the job number 
"^DD",798.7,798.7,2,21,2,0)
($JOB) of the process that has created this log.
"^DD",798.7,798.7,2,23,0)
^^2^2^3020403^
"^DD",798.7,798.7,2,23,1,0)
This field is populated automatically by the 
"^DD",798.7,798.7,2,23,2,0)
$$OPEN^RORLOG function.
"^DD",798.7,798.7,2,"DT")
3010813
"^DD",798.7,798.7,3,0)
REGISTRY^798.73P^^1;0
"^DD",798.7,798.7,3,21,0)
^^8^8^3020403^
"^DD",798.7,798.7,3,21,1,0)
This multiple contains a list of the registries 
"^DD",798.7,798.7,3,21,2,0)
that were processed. Events recorded in the log
"^DD",798.7,798.7,3,21,3,0)
are associated with these registries.
"^DD",798.7,798.7,3,21,4,0)
 
"^DD",798.7,798.7,3,21,5,0)
Records of this multiple are indexed by the "ARD"
"^DD",798.7,798.7,3,21,6,0)
index (whole file). So, it is possible to get a
"^DD",798.7,798.7,3,21,7,0)
list of log files associated with the particular
"^DD",798.7,798.7,3,21,8,0)
registry.
"^DD",798.7,798.7,4,0)
MESSAGE^798.74D^^2;0
"^DD",798.7,798.7,4,21,0)
^^2^2^3020403^
"^DD",798.7,798.7,4,21,1,0)
This multiple contains all messages recorded in 
"^DD",798.7,798.7,4,21,2,0)
the log.
"^DD",798.7,798.7,4,23,0)
^^4^4^3020403^
"^DD",798.7,798.7,4,23,1,0)
Every call of the LOG^RORLOG procedure adds a new 
"^DD",798.7,798.7,4,23,2,0)
record to this multiple. The $$OPEN^RORLOG and 
"^DD",798.7,798.7,4,23,3,0)
CLOSE^RORLOG entry points can also call the LOG^RORLOG
"^DD",798.7,798.7,4,23,4,0)
automatically to add header and footer to the log.
"^DD",798.7,798.7,5,0)
END DATE/TIME^D^^0;2^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798.7,798.7,5,21,0)
^^2^2^3020403^
"^DD",798.7,798.7,5,21,1,0)
This field contains the date/time when the 
"^DD",798.7,798.7,5,21,2,0)
log was closed.
"^DD",798.7,798.7,5,23,0)
^^2^2^3020403^
"^DD",798.7,798.7,5,23,1,0)
The CLOSE^RORLOG procedure populates this field
"^DD",798.7,798.7,5,23,2,0)
automatically when the log is closed.
"^DD",798.7,798.7,5,"DT")
3010807
"^DD",798.7,798.7,6.01,0)
PROCESSED PATIENTS^NJ12,0^^0;5^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.7,798.7,6.01,3)
Type a Number between 0 and 999999999999, 0 Decimal Digits.
"^DD",798.7,798.7,6.01,21,0)
^.001^2^2^3011011^^
"^DD",798.7,798.7,6.01,21,1,0)
The value of this field indicates the number of 
"^DD",798.7,798.7,6.01,21,2,0)
processed patients.
"^DD",798.7,798.7,6.01,23,0)
^.001^2^2^3020403^^
"^DD",798.7,798.7,6.01,23,1,0)
The value of this field is also duplicated in the last
"^DD",798.7,798.7,6.01,23,2,0)
message of the log (footer).
"^DD",798.7,798.7,6.01,"DT")
3010807
"^DD",798.7,798.7,6.02,0)
PATIENTS WITH ERRORS^NJ12,0^^0;6^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.7,798.7,6.02,3)
Type a Number between 0 and 999999999999, 0 Decimal Digits.
"^DD",798.7,798.7,6.02,21,0)
^^2^2^3011011^
"^DD",798.7,798.7,6.02,21,1,0)
The value of this field indicates the number of 
"^DD",798.7,798.7,6.02,21,2,0)
patients processed with errors.
"^DD",798.7,798.7,6.02,23,0)
^.001^2^2^3020403^^
"^DD",798.7,798.7,6.02,23,1,0)
The value of this field is also duplicated in the last
"^DD",798.7,798.7,6.02,23,2,0)
message of the log (footer).
"^DD",798.7,798.7,6.02,"DT")
3010807
"^DD",798.7,798.7,6.03,0)
RATE^NJ16,3^^0;7^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."4N.N) X
"^DD",798.7,798.7,6.03,3)
Type a Number between 0 and 999999999999, 3 Decimal Digits.
"^DD",798.7,798.7,6.03,21,0)
^^2^2^3011011^
"^DD",798.7,798.7,6.03,21,1,0)
The value of this field indicates the rate of 
"^DD",798.7,798.7,6.03,21,2,0)
patient processing (patients per second).
"^DD",798.7,798.7,6.03,23,0)
^.001^2^2^3020403^^
"^DD",798.7,798.7,6.03,23,1,0)
The value of this field is also duplicated in the last
"^DD",798.7,798.7,6.03,23,2,0)
message of the log (footer).
"^DD",798.7,798.7,6.03,"DT")
3010807
"^DD",798.7,798.73,0)
REGISTRY SUB-FIELD^^.01^1
"^DD",798.7,798.73,0,"DT")
3010807
"^DD",798.7,798.73,0,"IX","B",798.73,.01)

"^DD",798.7,798.73,0,"NM","REGISTRY")

"^DD",798.7,798.73,0,"UP")
798.7
"^DD",798.7,798.73,.01,0)
REGISTRY^MP798.1'X^ROR(798.1,^0;1^S:$D(X) DINUM=X
"^DD",798.7,798.73,.01,1,0)
^.1^^-1
"^DD",798.7,798.73,.01,1,1,0)
798.73^B
"^DD",798.7,798.73,.01,1,1,1)
S ^RORDATA(798.7,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",798.7,798.73,.01,1,1,2)
K ^RORDATA(798.7,DA(1),1,"B",$E(X,1,30),DA)
"^DD",798.7,798.73,.01,1,1,3)
Do not delete!
"^DD",798.7,798.73,.01,21,0)
^^4^4^3020403^
"^DD",798.7,798.73,.01,21,1,0)
The value of this field is a pointer to a record 
"^DD",798.7,798.73,.01,21,2,0)
of the ROR REGISTRY PARAMETERS file. The registry
"^DD",798.7,798.73,.01,21,3,0)
represented by that record was processed by the
"^DD",798.7,798.73,.01,21,4,0)
job that created this log.
"^DD",798.7,798.73,.01,"DT")
3010906
"^DD",798.7,798.74,0)
MESSAGE SUB-FIELD^^4^5
"^DD",798.7,798.74,0,"DT")
3011109
"^DD",798.7,798.74,0,"IX","B",798.74,.01)

"^DD",798.7,798.74,0,"NM","MESSAGE")

"^DD",798.7,798.74,0,"UP")
798.7
"^DD",798.7,798.74,.01,0)
DATE/TIME^MD^^0;1^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798.7,798.74,.01,1,0)
^.1
"^DD",798.7,798.74,.01,1,1,0)
798.74^B
"^DD",798.7,798.74,.01,1,1,1)
S ^RORDATA(798.7,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",798.7,798.74,.01,1,1,2)
K ^RORDATA(798.7,DA(1),2,"B",$E(X,1,30),DA)
"^DD",798.7,798.74,.01,1,1,3)
Do not delete!
"^DD",798.7,798.74,.01,21,0)
^^2^2^3011011^
"^DD",798.7,798.74,.01,21,1,0)
This field contains the date/time of the recorded
"^DD",798.7,798.74,.01,21,2,0)
event.
"^DD",798.7,798.74,.01,23,0)
^^2^2^3020403^
"^DD",798.7,798.74,.01,23,1,0)
The field is populated automatically by the LOG^RORLOG 
"^DD",798.7,798.74,.01,23,2,0)
procedure with the current date and time.
"^DD",798.7,798.74,.01,"DT")
3010807
"^DD",798.7,798.74,1,0)
TYPE^RS^1:Debug;2:Information;3:Data Quality;4:Warning;5:Database Error;6:Error;^0;2^Q
"^DD",798.7,798.74,1,21,0)
^^6^6^3020403^
"^DD",798.7,798.74,1,21,1,0)
The value of this field indicates the type of the
"^DD",798.7,798.74,1,21,2,0)
recorded event.
"^DD",798.7,798.74,1,21,3,0)
 
"^DD",798.7,798.74,1,21,4,0)
You can control which events are recorded and 
"^DD",798.7,798.74,1,21,5,0)
which are not via the LOG EVENTS multiple of the
"^DD",798.7,798.74,1,21,6,0)
ROR REGISTRY PARAMETERS file.
"^DD",798.7,798.74,1,"DT")
3010807
"^DD",798.7,798.74,2,0)
MESSAGE^RF^^2;E1,245^K:$L(X)>70!($L(X)<1) X
"^DD",798.7,798.74,2,3)
Answer must be 1-70 characters in length.
"^DD",798.7,798.74,2,21,0)
^^2^2^3011109^
"^DD",798.7,798.74,2,21,1,0)
This field contains a text message describing the 
"^DD",798.7,798.74,2,21,2,0)
recorded event.
"^DD",798.7,798.74,2,"DT")
3011109
"^DD",798.7,798.74,3,0)
PATIENT^P2'^DPT(^0;4^Q
"^DD",798.7,798.74,3,21,0)
^^3^3^3020403^
"^DD",798.7,798.74,3,21,1,0)
If the recorded event can be associated with a 
"^DD",798.7,798.74,3,21,2,0)
particular patient, this field contains a pointer 
"^DD",798.7,798.74,3,21,3,0)
to the patient record in the PATIENT file (DFN).
"^DD",798.7,798.74,3,"DT")
3010807
"^DD",798.7,798.74,4,0)
ADDITIONAL INFO^798.744^^1;0
"^DD",798.7,798.74,4,21,0)
^.001^2^2^3011011^^^
"^DD",798.7,798.74,4,21,1,0)
This field contains any additional information 
"^DD",798.7,798.74,4,21,2,0)
describing the event.
"^DD",798.7,798.744,0)
ADDITIONAL INFO SUB-FIELD^^.01^1
"^DD",798.7,798.744,0,"DT")
3010807
"^DD",798.7,798.744,0,"NM","ADDITIONAL INFO")

"^DD",798.7,798.744,0,"UP")
798.74
"^DD",798.7,798.744,.01,0)
ADDITIONAL INFO^WL^^0;1^Q
"^DD",798.7,798.744,.01,21,0)
^^2^2^3011011^
"^DD",798.7,798.744,.01,21,1,0)
This field contains any additional information 
"^DD",798.7,798.744,.01,21,2,0)
describing the event.
"^DD",798.7,798.744,.01,"DT")
3010807
"^DD",798.9,798.9,0)
FIELD^^2^4
"^DD",798.9,798.9,0,"DDA")
N
"^DD",798.9,798.9,0,"DT")
3020429
"^DD",798.9,798.9,0,"IX","ALN",798.92,.01)

"^DD",798.9,798.9,0,"IX","ANLT",798.92,.02)

"^DD",798.9,798.9,0,"NM","ROR LAB SEARCH")

"^DD",798.9,798.9,0,"VRPK")
ROR
"^DD",798.9,798.9,.01,0)
NAME^RFX^^0;1^Q:$$VAEDT^RORDD(798.9,$G(DA))  K:$L(X)>30!($L(X)<3) X
"^DD",798.9,798.9,.01,1,0)
^.1^^0
"^DD",798.9,798.9,.01,3)
Enter a unique name spaced criterion name (3-30 characters).
"^DD",798.9,798.9,.01,8.5)
@
"^DD",798.9,798.9,.01,9)
@
"^DD",798.9,798.9,.01,21,0)
^^6^6^3011016^
"^DD",798.9,798.9,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.9,798.9,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.9,798.9,.01,21,3,0)
 
"^DD",798.9,798.9,.01,21,4,0)
The criterion name must be unique and name spaced.
"^DD",798.9,798.9,.01,21,5,0)
The names that are used for National Registries
"^DD",798.9,798.9,.01,21,6,0)
must start with "VA".
"^DD",798.9,798.9,.01,"DEL",1,0)
I $$VADEL^RORDD(798.9,$G(DA))
"^DD",798.9,798.9,.01,"DT")
3010720
"^DD",798.9,798.9,.09,0)
NATIONAL^SX^0:NO;1:YES;^0;3^Q:$$VAEDT^RORDD(798.9,,-1)
"^DD",798.9,798.9,.09,8.5)
@
"^DD",798.9,798.9,.09,9)
@
"^DD",798.9,798.9,.09,21,0)
^^6^6^3020403^
"^DD",798.9,798.9,.09,21,1,0)
ONLY AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN
"^DD",798.9,798.9,.09,21,2,0)
EDIT THIS FIELD!
"^DD",798.9,798.9,.09,21,3,0)
 
"^DD",798.9,798.9,.09,21,4,0)
The national registries must have this field set
"^DD",798.9,798.9,.09,21,5,0)
to "Yes". This prevents local editing of other
"^DD",798.9,798.9,.09,21,6,0)
fields of national registry definitions.
"^DD",798.9,798.9,.09,"DEL",1,0)
I $$VADEL^RORDD(798.9,,-1)
"^DD",798.9,798.9,.09,"DT")
3011119
"^DD",798.9,798.9,1,0)
STATUS^S^0:ACTIVE;1:INACTIVE;^0;2^Q
"^DD",798.9,798.9,1,21,0)
^^2^2^3020403^
"^DD",798.9,798.9,1,21,1,0)
Select the "INACTIVE" code if you want to disable
"^DD",798.9,798.9,1,21,2,0)
the criterion temporarily.
"^DD",798.9,798.9,1,"DT")
3011016
"^DD",798.9,798.9,2,0)
LAB TEST^798.92^^1;0
"^DD",798.9,798.9,2,9)
@
"^DD",798.9,798.9,2,21,0)
^^9^9^3011119^
"^DD",798.9,798.9,2,21,1,0)
This multiple contains a list of the Lab search 
"^DD",798.9,798.9,2,21,2,0)
indicators used by the registry update process.
"^DD",798.9,798.9,2,21,3,0)
 
"^DD",798.9,798.9,2,21,4,0)
If at least one of the indicators is evaluated as 
"^DD",798.9,798.9,2,21,5,0)
True, the macro referencing the search criterion
"^DD",798.9,798.9,2,21,6,0)
will be evaluated as True as well.
"^DD",798.9,798.9,2,21,7,0)
 
"^DD",798.9,798.9,2,21,8,0)
This multiple can contain several records for the
"^DD",798.9,798.9,2,21,9,0)
same Lab test.
"^DD",798.9,798.92,0)
LAB TEST SUB-FIELD^^2^4
"^DD",798.9,798.92,0,"DT")
3011119
"^DD",798.9,798.92,0,"IX","B",798.92,.01)

"^DD",798.9,798.92,0,"NM","LAB TEST")

"^DD",798.9,798.92,0,"UP")
798.9
"^DD",798.9,798.92,.01,0)
LOINC CODE^MNJ7,0^^0;1^K:+X'=X!(X>9999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.9,798.92,.01,1,0)
^.1
"^DD",798.9,798.92,.01,1,1,0)
798.92^B
"^DD",798.9,798.92,.01,1,1,1)
S ^ROR(798.9,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",798.9,798.92,.01,1,1,2)
K ^ROR(798.9,DA(1),1,"B",$E(X,1,30),DA)
"^DD",798.9,798.92,.01,1,1,3)
Do not delete!
"^DD",798.9,798.92,.01,1,2,0)
798.9^ALN
"^DD",798.9,798.92,.01,1,2,1)
S ^ROR(798.9,"ALN",$E(X,1,30),DA(1),DA)=""
"^DD",798.9,798.92,.01,1,2,2)
K ^ROR(798.9,"ALN",$E(X,1,30),DA(1),DA)
"^DD",798.9,798.92,.01,1,2,3)
Do not delete!
"^DD",798.9,798.92,.01,1,2,"%D",0)
^^3^3^3011016^
"^DD",798.9,798.92,.01,1,2,"%D",1,0)
This cross-reference can be used to find all 
"^DD",798.9,798.92,.01,1,2,"%D",2,0)
criteria that look for the Lab results with the
"^DD",798.9,798.92,.01,1,2,"%D",3,0)
particular LOINC code.
"^DD",798.9,798.92,.01,1,2,"DT")
3010621
"^DD",798.9,798.92,.01,3)
Enter the LOINC code without a control digit.
"^DD",798.9,798.92,.01,8.5)
@
"^DD",798.9,798.92,.01,9)
@
"^DD",798.9,798.92,.01,21,0)
^.001^4^4^3011119^^
"^DD",798.9,798.92,.01,21,1,0)
Enter the numeric LOINC code (without the check
"^DD",798.9,798.92,.01,21,2,0)
digit) of the Lab result to be searched for. If
"^DD",798.9,798.92,.01,21,3,0)
you want to use only NLT code, enter zero as the
"^DD",798.9,798.92,.01,21,4,0)
value of this field.
"^DD",798.9,798.92,.01,"DT")
3011119
"^DD",798.9,798.92,.02,0)
NLT CODE^F^^0;2^K:'(X?5N1"."4.5N) X
"^DD",798.9,798.92,.02,1,0)
^.1
"^DD",798.9,798.92,.02,1,1,0)
798.9^ANLT
"^DD",798.9,798.92,.02,1,1,1)
S ^ROR(798.9,"ANLT",$E(X,1,30),DA(1),DA)=""
"^DD",798.9,798.92,.02,1,1,2)
K ^ROR(798.9,"ANLT",$E(X,1,30),DA(1),DA)
"^DD",798.9,798.92,.02,1,1,3)
Do not delete!
"^DD",798.9,798.92,.02,1,1,"%D",0)
^^3^3^3011016^
"^DD",798.9,798.92,.02,1,1,"%D",1,0)
This cross-reference can be used to find all 
"^DD",798.9,798.92,.02,1,1,"%D",2,0)
criteria that look for the Lab results with the
"^DD",798.9,798.92,.02,1,1,"%D",3,0)
particular NLT code.
"^DD",798.9,798.92,.02,1,1,"DT")
3010621
"^DD",798.9,798.92,.02,3)
Enter the NLT code (NNNNN.MMMM[M]).
"^DD",798.9,798.92,.02,8.5)
@
"^DD",798.9,798.92,.02,9)
@
"^DD",798.9,798.92,.02,21,0)
^.001^5^5^3011119^^^
"^DD",798.9,798.92,.02,21,1,0)
Enter the NLT code of the Lab result to be 
"^DD",798.9,798.92,.02,21,2,0)
searched for. Both LOINC and NLT codes (if
"^DD",798.9,798.92,.02,21,3,0)
available) are used for searching the Lab results.
"^DD",798.9,798.92,.02,21,4,0)
If you want to use only the LOINC code, leave this
"^DD",798.9,798.92,.02,21,5,0)
field empty.
"^DD",798.9,798.92,.02,"DT")
3011119
"^DD",798.9,798.92,1,0)
INDICATOR^RS^0:Ignore;1:Use Reference Range;2:Contains;3:Greater Than;4:Less Than;5:Equal To;^0;3^Q
"^DD",798.9,798.92,1,8.5)
@
"^DD",798.9,798.92,1,9)
@
"^DD",798.9,798.92,1,21,0)
^^18^18^3020403^
"^DD",798.9,798.92,1,21,1,0)
The value of this field indicates the comparison
"^DD",798.9,798.92,1,21,2,0)
operation applied to the Lab result. The Lab
"^DD",798.9,798.92,1,21,3,0)
result is compared to the value of the INDICATED 
"^DD",798.9,798.92,1,21,4,0)
VALUE field. 
"^DD",798.9,798.92,1,21,5,0)
 
"^DD",798.9,798.92,1,21,6,0)
For example, if the internal value of this field 
"^DD",798.9,798.92,1,21,7,0)
is equal to 3 ("Greater Than") and the value of
"^DD",798.9,798.92,1,21,8,0)
the INDICATED VALUE field is 5 then this indicator
"^DD",798.9,798.92,1,21,9,0)
will be evaluated as True for all numeric Lab 
"^DD",798.9,798.92,1,21,10,0)
results values greater than 5.
"^DD",798.9,798.92,1,21,11,0)
 
"^DD",798.9,798.92,1,21,12,0)
The "Contains" indicator checks if the indicated
"^DD",798.9,798.92,1,21,13,0)
value is contained in the Lab result value.
"^DD",798.9,798.92,1,21,14,0)
 
"^DD",798.9,798.92,1,21,15,0)
The only exception is the "Use Reference Range"
"^DD",798.9,798.92,1,21,16,0)
indicator which checks if the result value is
"^DD",798.9,798.92,1,21,17,0)
outside of the reference range defined for the 
"^DD",798.9,798.92,1,21,18,0)
Lab test.
"^DD",798.9,798.92,1,"DT")
3011023
"^DD",798.9,798.92,2,0)
INDICATED VALUE^F^^0;4^K:$L(X)>30!($L(X)<1) X
"^DD",798.9,798.92,2,3)
Answer must be 1-30 characters in length.
"^DD",798.9,798.92,2,8.5)
@
"^DD",798.9,798.92,2,9)
@
"^DD",798.9,798.92,2,21,0)
^^3^3^3020403^
"^DD",798.9,798.92,2,21,1,0)
This field holds the value that the Lab results
"^DD",798.9,798.92,2,21,2,0)
are compared to (except the "Use Reference Range"
"^DD",798.9,798.92,2,21,3,0)
indicator).
"^DD",798.9,798.92,2,"DT")
3010621
"^DD",799.1,799.1,0)
FIELD^^1^5
"^DD",799.1,799.1,0,"DDA")
N
"^DD",799.1,799.1,0,"DT")
3011112
"^DD",799.1,799.1,0,"IX","B",799.1,.01)

"^DD",799.1,799.1,0,"NM","ROR LIST ITEM")

"^DD",799.1,799.1,0,"PT",798,2.2)

"^DD",799.1,799.1,0,"PT",798,3.2)

"^DD",799.1,799.1,0,"VRPK")
ROR
"^DD",799.1,799.1,.01,0)
TEXT^RFX^^0;1^Q:$$VAEDT^RORDD(799.1,,-1)  K:$L(X)>60!($L(X)<1) X
"^DD",799.1,799.1,.01,1,0)
^.1
"^DD",799.1,799.1,.01,1,1,0)
799.1^B
"^DD",799.1,799.1,.01,1,1,1)
S ^ROR(799.1,"B",$E(X,1,30),DA)=""
"^DD",799.1,799.1,.01,1,1,2)
K ^ROR(799.1,"B",$E(X,1,30),DA)
"^DD",799.1,799.1,.01,1,1,3)
Do not delete!
"^DD",799.1,799.1,.01,3)
Enter text of the item (1-60 characters).
"^DD",799.1,799.1,.01,8.5)
@
"^DD",799.1,799.1,.01,9)
@
"^DD",799.1,799.1,.01,21,0)
^^6^6^3020403^
"^DD",799.1,799.1,.01,21,1,0)
This field contains a text representation of the
"^DD",799.1,799.1,.01,21,2,0)
item (external value). The text is displayed by 
"^DD",799.1,799.1,.01,21,3,0)
the GUI in the list of possible values of the
"^DD",799.1,799.1,.01,21,4,0)
registry field (for example, the REASON FOR 
"^DD",799.1,799.1,.01,21,5,0)
INACTIVATION field of the ROR LOCAL REGISTRY file)
"^DD",799.1,799.1,.01,21,6,0)
that this item is associated with.
"^DD",799.1,799.1,.01,"DEL",1,0)
I $$VADEL^RORDD(799.1,,-1)
"^DD",799.1,799.1,.01,"DT")
3011112
"^DD",799.1,799.1,.02,0)
TYPE^RSX^1:Reason for inactivation;2:Supporting evidence;^0;2^Q:$$VAEDT^RORDD(799.1,,-1)
"^DD",799.1,799.1,.02,8.5)
@
"^DD",799.1,799.1,.02,9)
@
"^DD",799.1,799.1,.02,21,0)
^.001^3^3^3011112^^
"^DD",799.1,799.1,.02,21,1,0)
An internal value of this field links the item to
"^DD",799.1,799.1,.02,21,2,0)
the registry field. The items with the same type
"^DD",799.1,799.1,.02,21,3,0)
define the possible values of the registry field.
"^DD",799.1,799.1,.02,23,0)
^.001^3^3^3011112^^
"^DD",799.1,799.1,.02,23,1,0)
When a new registry field needs to be added, add
"^DD",799.1,799.1,.02,23,2,0)
another code to the definition of this field and create
"^DD",799.1,799.1,.02,23,3,0)
the corresponding item records.
"^DD",799.1,799.1,.02,"DT")
3011112
"^DD",799.1,799.1,.03,0)
REGISTRY^RP798.1'X^ROR(798.1,^0;3^Q:$$VAEDT^RORDD(799.1,,-1)
"^DD",799.1,799.1,.03,8.5)
@
"^DD",799.1,799.1,.03,9)
@
"^DD",799.1,799.1,.03,21,0)
^.001^2^2^3011112^^
"^DD",799.1,799.1,.03,21,1,0)
This field identifies the registry that the item
"^DD",799.1,799.1,.03,21,2,0)
is associated with.
"^DD",799.1,799.1,.03,"DT")
3011112
"^DD",799.1,799.1,.04,0)
CODE^RNJ2,0X^^0;4^Q:$$VAEDT^RORDD(799.1,,-1)  K:+X'=X!(X>99)!(X<1)!(X?.E1"."1N.N) X
"^DD",799.1,799.1,.04,3)
Type a Number between 1 and 99, 0 Decimal Digits.
"^DD",799.1,799.1,.04,8.5)
@
"^DD",799.1,799.1,.04,9)
@
"^DD",799.1,799.1,.04,21,0)
^.001^3^3^3020403^^
"^DD",799.1,799.1,.04,21,1,0)
This field contains a code (internal value) of the
"^DD",799.1,799.1,.04,21,2,0)
item. The codes are unique only among the items of
"^DD",799.1,799.1,.04,21,3,0)
the same type associated with the same registry.
"^DD",799.1,799.1,.04,"DT")
3011112
"^DD",799.1,799.1,1,0)
DATE OF INACTIVATION^D^^0;5^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",799.1,799.1,1,21,0)
^^4^4^3011017^
"^DD",799.1,799.1,1,21,1,0)
If this field has a value, the item will be
"^DD",799.1,799.1,1,21,2,0)
considered inactive after this date. Use this 
"^DD",799.1,799.1,1,21,3,0)
field to disable unnecessary items instead of
"^DD",799.1,799.1,1,21,4,0)
deleting them.
"^DD",799.1,799.1,1,23,0)
^^3^3^3011017^
"^DD",799.1,799.1,1,23,1,0)
The $$ITEMLIST^RORUTL01 function analyzes this field 
"^DD",799.1,799.1,1,23,2,0)
when it loads the requested list of items and skips the
"^DD",799.1,799.1,1,23,3,0)
inactive items.
"^DD",799.1,799.1,1,"DT")
3011017
"^DD",799.2,799.2,0)
FIELD^^5^5
"^DD",799.2,799.2,0,"DDA")
N
"^DD",799.2,799.2,0,"DT")
3020326
"^DD",799.2,799.2,0,"ID","WRITE")
N RORMSG D EN^DDIOL($$GET1^DID(Y,,,"NAME",,"RORMSG"),,"?30")
"^DD",799.2,799.2,0,"IX","B",799.2,.01)

"^DD",799.2,799.2,0,"NM","ROR METADATA")

"^DD",799.2,799.2,0,"PT",799.2,1)

"^DD",799.2,799.2,0,"VRPK")
ROR
"^DD",799.2,799.2,.01,0)
FILE^RNJ22,9X^^0;1^Q:$$VAEDT^RORDD(799.2,,-1)  K:+X'=X!(X>999999999999)!(X<2)!(X?.E1"."10.N) X I $D(X) K:'$$VFILE^DILFD(X) X S:$D(X) DINUM=X
"^DD",799.2,799.2,.01,1,0)
^.1
"^DD",799.2,799.2,.01,1,1,0)
799.2^B
"^DD",799.2,799.2,.01,1,1,1)
S ^ROR(799.2,"B",$E(X,1,30),DA)=""
"^DD",799.2,799.2,.01,1,1,2)
K ^ROR(799.2,"B",$E(X,1,30),DA)
"^DD",799.2,799.2,.01,1,1,3)
Do not delete!
"^DD",799.2,799.2,.01,3)
Enter (sub)file number between 2 and 999999999999, 9 Decimal Digits.
"^DD",799.2,799.2,.01,8.5)
@
"^DD",799.2,799.2,.01,9)
@
"^DD",799.2,799.2,.01,21,0)
^^4^4^3020321^
"^DD",799.2,799.2,.01,21,1,0)
The value of this field is the number of the
"^DD",799.2,799.2,.01,21,2,0)
(sub)file that can be searched for new data by the
"^DD",799.2,799.2,.01,21,3,0)
registry update process and is a part of the
"^DD",799.2,799.2,.01,21,4,0)
file-processing tree.
"^DD",799.2,799.2,.01,23,0)
^.001^2^2^3020403^^^
"^DD",799.2,799.2,.01,23,1,0)
The internal value of this field is used as the
"^DD",799.2,799.2,.01,23,2,0)
internal entry number of the record ('DINUM' feature).
"^DD",799.2,799.2,.01,"DEL",1,0)
I $$VADEL^RORDD(799.2,,-1)
"^DD",799.2,799.2,.01,"DT")
3020313
"^DD",799.2,799.2,1,0)
PARENT^*P799.2'X^ROR(799.2,^0;2^Q:$$VAEDT^RORDD(799.2,,-1)  S DIC("S")="I Y'="_+$G(DA) D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",799.2,799.2,1,8.5)
@
"^DD",799.2,799.2,1,9)
@
"^DD",799.2,799.2,1,12)
A record cannot be parent record of itself.
"^DD",799.2,799.2,1,12.1)
S DIC("S")="I Y'="_+$G(DA)
"^DD",799.2,799.2,1,21,0)
^^12^12^3020328^
"^DD",799.2,799.2,1,21,1,0)
This field holds the number of the (sub)file that
"^DD",799.2,799.2,1,21,2,0)
is a parent of the current file in the
"^DD",799.2,799.2,1,21,3,0)
file-processing tree. You can choose only from the
"^DD",799.2,799.2,1,21,4,0)
files that have descriptors in the ROR METADATA
"^DD",799.2,799.2,1,21,5,0)
file. However, the current record cannot be
"^DD",799.2,799.2,1,21,6,0)
selected as the parent of itself.
"^DD",799.2,799.2,1,21,7,0)
 
"^DD",799.2,799.2,1,21,8,0)
Leave this field empty for the "root" file (the 
"^DD",799.2,799.2,1,21,9,0)
PATIENT file (#2) most probably).
"^DD",799.2,799.2,1,21,10,0)
 
"^DD",799.2,799.2,1,21,11,0)
See the technical description of the field for 
"^DD",799.2,799.2,1,21,12,0)
more information.
"^DD",799.2,799.2,1,23,0)
^^24^24^3020328^
"^DD",799.2,799.2,1,23,1,0)
During the registry update VistA files are processed in
"^DD",799.2,799.2,1,23,2,0)
the predetermined hierarchic sequence called
"^DD",799.2,799.2,1,23,3,0)
"file-processing tree". A sample structure of the
"^DD",799.2,799.2,1,23,4,0)
"tree" is illustrated below:
"^DD",799.2,799.2,1,23,5,0)
 
"^DD",799.2,799.2,1,23,6,0)
 . PATIENT (#2)
"^DD",799.2,799.2,1,23,7,0)
 .    VISIT (#9000010)
"^DD",799.2,799.2,1,23,8,0)
 .       V POV (#9000010.07)
"^DD",799.2,799.2,1,23,9,0)
 .    PROBLEM (#9000011)
"^DD",799.2,799.2,1,23,10,0)
 .    PTF (#45)
"^DD",799.2,799.2,1,23,11,0)
 .    LAB DATA (#63)
"^DD",799.2,799.2,1,23,12,0)
 
"^DD",799.2,799.2,1,23,13,0)
This means that for each patient a record in file #2 is
"^DD",799.2,799.2,1,23,14,0)
processed first. Then patient visits from file #9000010
"^DD",799.2,799.2,1,23,15,0)
are processed. During processing of each visit record
"^DD",799.2,799.2,1,23,16,0)
all linked "purpose of visit" records in file
"^DD",799.2,799.2,1,23,17,0)
#9000010.07 are processed. After that, all patient
"^DD",799.2,799.2,1,23,18,0)
record from the problem list are processed. Next in
"^DD",799.2,799.2,1,23,19,0)
line are the patient records from file #45 and the lab
"^DD",799.2,799.2,1,23,20,0)
results.
"^DD",799.2,799.2,1,23,21,0)
 
"^DD",799.2,799.2,1,23,22,0)
The structure of the tree is defined by the routines
"^DD",799.2,799.2,1,23,23,0)
that conduct the search (hard coded loops). However, it
"^DD",799.2,799.2,1,23,24,0)
MUST be reflected in this file.
"^DD",799.2,799.2,1,"DEL",1,0)
I $$VADEL^RORDD(799.2,,-1)
"^DD",799.2,799.2,1,"DT")
3020313
"^DD",799.2,799.2,2,0)
DATA ELEMENT^799.22I^^2;0
"^DD",799.2,799.2,2,9)
@
"^DD",799.2,799.2,2,21,0)
^^8^8^3020403^
"^DD",799.2,799.2,2,21,1,0)
This multiple stores a list of data elements 
"^DD",799.2,799.2,2,21,2,0)
supported by the search engine. These elements can
"^DD",799.2,799.2,2,21,3,0)
be referenced by selection rules associated with
"^DD",799.2,799.2,2,21,4,0)
the file.
"^DD",799.2,799.2,2,21,5,0)
 
"^DD",799.2,799.2,2,21,6,0)
Records of the multiple are uniquely identified by
"^DD",799.2,799.2,2,21,7,0)
the data element name (the primary key "B" and the
"^DD",799.2,799.2,2,21,8,0)
uniqueness index "B" are used for this purpose).
"^DD",799.2,799.2,2,"DT")
3020326
"^DD",799.2,799.2,3,0)
API^799.23I^^3;0
"^DD",799.2,799.2,3,9)
@
"^DD",799.2,799.2,3,21,0)
^^9^9^3020321^
"^DD",799.2,799.2,3,21,1,0)
This multiple stores descriptors of the APIs that
"^DD",799.2,799.2,3,21,2,0)
are used to load values of the search fields.
"^DD",799.2,799.2,3,21,3,0)
 
"^DD",799.2,799.2,3,21,4,0)
Codes of the APIs are unique only in the file
"^DD",799.2,799.2,3,21,5,0)
context. For example, the definition of any file
"^DD",799.2,799.2,3,21,6,0)
can have a descriptor of the API #2.
"^DD",799.2,799.2,3,21,7,0)
 
"^DD",799.2,799.2,3,21,8,0)
Internal entry numbers of the records in this 
"^DD",799.2,799.2,3,21,9,0)
multiple are equal to the codes of the APIs.
"^DD",799.2,799.2,5,0)
DESCRIPTION^799.25^^5;0
"^DD",799.2,799.2,5,9)
@
"^DD",799.2,799.2,5,21,0)
^^3^3^3020403^
"^DD",799.2,799.2,5,21,1,0)
You can enter any additional reference information
"^DD",799.2,799.2,5,21,2,0)
related to the file definition. The content of this
"^DD",799.2,799.2,5,21,3,0)
field is not used by the application.
"^DD",799.2,799.22,0)
DATA ELEMENT SUB-FIELD^^6^8
"^DD",799.2,799.22,0,"DT")
3020326
"^DD",799.2,799.22,0,"ID","WRITE")
D EN^DDIOL("  "_$P(^(0),U,2),,"?35")
"^DD",799.2,799.22,0,"IX","AR",799.22,2)

"^DD",799.2,799.22,0,"IX","C",799.22,.02)

"^DD",799.2,799.22,0,"NM","DATA ELEMENT")

"^DD",799.2,799.22,0,"UP")
799.2
"^DD",799.2,799.22,.01,0)
DATA NAME^MFX^^0;1^Q:$$VAEDT^RORDD(799.2,,-1)  K:($L(X)>30)!($L(X)<3)!(+X=X) X
"^DD",799.2,799.22,.01,1,0)
^.1^^0
"^DD",799.2,799.22,.01,3)
Answer must be 3-30 characters in length.
"^DD",799.2,799.22,.01,8.5)
@
"^DD",799.2,799.22,.01,9)
@
"^DD",799.2,799.22,.01,21,0)
^.001^9^9^3020327^^
"^DD",799.2,799.22,.01,21,1,0)
The value of this field is the name of the data
"^DD",799.2,799.22,.01,21,2,0)
element supported by the search engine. The names 
"^DD",799.2,799.22,.01,21,3,0)
must be unique in the file context.
"^DD",799.2,799.22,.01,21,4,0)
 
"^DD",799.2,799.22,.01,21,5,0)
The data element is supported if either the
"^DD",799.2,799.22,.01,21,6,0)
routine that processes the file can load the value
"^DD",799.2,799.22,.01,21,7,0)
using an application API or there is a DBIA that
"^DD",799.2,799.22,.01,21,8,0)
allows access to the corresponding field via the
"^DD",799.2,799.22,.01,21,9,0)
'GETS^DIQ' FileMan procedure.
"^DD",799.2,799.22,.01,23,0)
^^2^2^3020328^
"^DD",799.2,799.22,.01,23,1,0)
The primary "B" key and the "B" index (new style)
"^DD",799.2,799.22,.01,23,2,0)
guaranty uniqueness of the names in the file context.
"^DD",799.2,799.22,.01,"DEL",1,0)
I $$VADEL^RORDD(799.2,,-1)
"^DD",799.2,799.22,.01,"DT")
3020328
"^DD",799.2,799.22,.02,0)
CODE^RNJ9,0XI^^0;2^Q:$$VAEDT^RORDD(799.2,,-1)  S:X="+" X=$O(^ROR(799.2,"DEC",""),-1)+1 K:+X'=X!(X>999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",799.2,799.22,.02,1,0)
^.1
"^DD",799.2,799.22,.02,1,1,0)
799.22^C
"^DD",799.2,799.22,.02,1,1,1)
S ^ROR(799.2,DA(1),2,"C",$E(X,1,30),DA)=""
"^DD",799.2,799.22,.02,1,1,2)
K ^ROR(799.2,DA(1),2,"C",$E(X,1,30),DA)
"^DD",799.2,799.22,.02,1,1,3)
List of data element codes.
"^DD",799.2,799.22,.02,1,1,"DT")
3020326
"^DD",799.2,799.22,.02,3)
Type a Number between 1 and 999999999, 0 Decimal Digits
"^DD",799.2,799.22,.02,8.5)
@
"^DD",799.2,799.22,.02,9)
@
"^DD",799.2,799.22,.02,21,0)
^^7^7^3020327^
"^DD",799.2,799.22,.02,21,1,0)
This field stores the unique code of the data 
"^DD",799.2,799.22,.02,21,2,0)
element. Data elements can be referenced either by
"^DD",799.2,799.22,.02,21,3,0)
their names (only in the file context) or by their
"^DD",799.2,799.22,.02,21,4,0)
codes.
"^DD",799.2,799.22,.02,21,5,0)
 
"^DD",799.2,799.22,.02,21,6,0)
You can enter "+" to get the next available code 
"^DD",799.2,799.22,.02,21,7,0)
for a new data element.
"^DD",799.2,799.22,.02,23,0)
^^3^3^3020327^
"^DD",799.2,799.22,.02,23,1,0)
The secondary "A" key and the whole-file "DEC" index 
"^DD",799.2,799.22,.02,23,2,0)
(new style) guaranty uniqueness of the data element
"^DD",799.2,799.22,.02,23,3,0)
codes.
"^DD",799.2,799.22,.02,"DT")
3020327
"^DD",799.2,799.22,1,0)
LOADER API^RNJ2,0X^^0;5^Q:$$VAEDT^RORDD(799.2,,-1)  K:+X'=X!(X>99)!(X<1)!(X?.E1"."1N.N) X
"^DD",799.2,799.22,1,3)
Type a Number between 1 and 99, 0 Decimal Digits.
"^DD",799.2,799.22,1,4)
D APILST^RORDD($G(DA(1)))
"^DD",799.2,799.22,1,8.5)
@
"^DD",799.2,799.22,1,9)
@
"^DD",799.2,799.22,1,21,0)
^^8^8^3020403^
"^DD",799.2,799.22,1,21,1,0)
This field stores the code of the API that is used
"^DD",799.2,799.22,1,21,2,0)
to load a value of the data element defined by the
"^DD",799.2,799.22,1,21,3,0)
descriptor.
"^DD",799.2,799.22,1,21,4,0)
 
"^DD",799.2,799.22,1,21,5,0)
The descriptor of this API must be defined in the
"^DD",799.2,799.22,1,21,6,0)
"API" multiple (subfile #799.23). The only
"^DD",799.2,799.22,1,21,7,0)
exception is the API #1. It is always considered
"^DD",799.2,799.22,1,21,8,0)
as the 'GETS^DIQ' FileMan procedure.
"^DD",799.2,799.22,1,"DT")
3020326
"^DD",799.2,799.22,2,0)
REQUIRED^SX^0:NO;1:YES;^0;3^Q:$$VAEDT^RORDD(799.2,,-1)
"^DD",799.2,799.22,2,1,0)
^.1
"^DD",799.2,799.22,2,1,1,0)
799.22^AR
"^DD",799.2,799.22,2,1,1,1)
S ^ROR(799.2,DA(1),2,"AR",$E(X,1,30),DA)=""
"^DD",799.2,799.22,2,1,1,2)
K ^ROR(799.2,DA(1),2,"AR",$E(X,1,30),DA)
"^DD",799.2,799.22,2,1,1,3)
List of required fields.
"^DD",799.2,799.22,2,1,1,"DT")
3020308
"^DD",799.2,799.22,2,8.5)
@
"^DD",799.2,799.22,2,9)
@
"^DD",799.2,799.22,2,21,0)
^^5^5^3020403^
"^DD",799.2,799.22,2,21,1,0)
If the value of the data element is required by
"^DD",799.2,799.22,2,21,2,0)
the search engine itself, the REQUIRED field
"^DD",799.2,799.22,2,21,3,0)
should be set to "Yes" so that the value of the
"^DD",799.2,799.22,2,21,4,0)
element will be loaded whether it is referenced by
"^DD",799.2,799.22,2,21,5,0)
the selection rules or not.
"^DD",799.2,799.22,2,"DEL",1,0)
I $$VADEL^RORDD(799.2,,-1)
"^DD",799.2,799.22,2,"DT")
3020308
"^DD",799.2,799.22,4,0)
VALUE TYPE^RSX^E:External;I:Internal;EI:Both;^0;4^Q:$$VAEDT^RORDD(799.2,,-1)
"^DD",799.2,799.22,4,8.5)
@
"^DD",799.2,799.22,4,9)
@
"^DD",799.2,799.22,4,21,0)
^^4^4^3020328^
"^DD",799.2,799.22,4,21,1,0)
The VALUE TYPE field contains the code of the data
"^DD",799.2,799.22,4,21,2,0)
element value type(s) supported by the search
"^DD",799.2,799.22,4,21,3,0)
engine. The corresponding API must be able to load
"^DD",799.2,799.22,4,21,4,0)
the value(s).
"^DD",799.2,799.22,4,"DT")
3020308
"^DD",799.2,799.22,4.1,0)
EXTERNAL DATA^FX^^4.1;E1,50^Q:$$VAEDT^RORDD(799.2,,-1)  K:$L(X)>50!($L(X)<1) X
"^DD",799.2,799.22,4.1,3)
Answer must be 1-50 characters in length.
"^DD",799.2,799.22,4.1,8.5)
@
"^DD",799.2,799.22,4.1,9)
@
"^DD",799.2,799.22,4.1,21,0)
^^10^10^3020327^
"^DD",799.2,799.22,4.1,21,1,0)
This field can contain any optional data that 
"^DD",799.2,799.22,4.1,21,2,0)
helps to load the external value of the data
"^DD",799.2,799.22,4.1,21,3,0)
element (variable name, subscript, position, etc).
"^DD",799.2,799.22,4.1,21,4,0)
 
"^DD",799.2,799.22,4.1,21,5,0)
Many data elements use the following data
"^DD",799.2,799.22,4.1,21,6,0)
structure: PN[^SN]. The 'SN' is a subscript of the
"^DD",799.2,799.22,4.1,21,7,0)
node in the local array (optional) and the 'PN' is
"^DD",799.2,799.22,4.1,21,8,0)
the number of the "^"-piece of the node value.
"^DD",799.2,799.22,4.1,21,9,0)
These values are used to extract the value from
"^DD",799.2,799.22,4.1,21,10,0)
the local variable created by the API.
"^DD",799.2,799.22,4.1,23,0)
^.001^3^3^3020327^^^^
"^DD",799.2,799.22,4.1,23,1,0)
See definition of the API #2 associated with the file
"^DD",799.2,799.22,4.1,23,2,0)
#45 and source code of the $$LOADFLDS^RORUPD09 function
"^DD",799.2,799.22,4.1,23,3,0)
for an example.
"^DD",799.2,799.22,4.1,"DEL",1,0)
I $$VADEL^RORDD(799.2,,-1)
"^DD",799.2,799.22,4.1,"DT")
3020311
"^DD",799.2,799.22,4.2,0)
INTERNAL DATA^FX^^4.2;E1,50^Q:$$VAEDT^RORDD(799.2,,-1)  K:$L(X)>50!($L(X)<1) X
"^DD",799.2,799.22,4.2,3)
Answer must be 1-50 characters in length.
"^DD",799.2,799.22,4.2,8.5)
@
"^DD",799.2,799.22,4.2,9)
@
"^DD",799.2,799.22,4.2,21,0)
^^10^10^3020327^
"^DD",799.2,799.22,4.2,21,1,0)
This field can contain any optional data that
"^DD",799.2,799.22,4.2,21,2,0)
helps to load the internal value of the data 
"^DD",799.2,799.22,4.2,21,3,0)
element (variable name, subscript, position, etc).
"^DD",799.2,799.22,4.2,21,4,0)
 
"^DD",799.2,799.22,4.2,21,5,0)
Many data elements use the following data
"^DD",799.2,799.22,4.2,21,6,0)
structure: PN[^SN]. The 'SN' is a subscript of the
"^DD",799.2,799.22,4.2,21,7,0)
node in the local array (optional) and the 'PN' is
"^DD",799.2,799.22,4.2,21,8,0)
the number of the "^"-piece of the node value.
"^DD",799.2,799.22,4.2,21,9,0)
These values are used to extract the value from
"^DD",799.2,799.22,4.2,21,10,0)
the local variable created by the API.
"^DD",799.2,799.22,4.2,23,0)
^.001^3^3^3020327^^^^
"^DD",799.2,799.22,4.2,23,1,0)
See definition of the API #2 associated with the file 
"^DD",799.2,799.22,4.2,23,2,0)
#45 and source code of the $$LOADFLDS^RORUPD09 function
"^DD",799.2,799.22,4.2,23,3,0)
for an example.
"^DD",799.2,799.22,4.2,"DEL",1,0)
I $$VADEL^RORDD(799.2,,-1)
"^DD",799.2,799.22,4.2,"DT")
3020311
"^DD",799.2,799.22,6,0)
FIELD NUMBER^NJ19,9X^^0;6^Q:$$VAEDT^RORDD(799.2,,-1)  K:+X'=X!(X>999999999)!(X<0)!(X?.E1"."10.N) X X:$D(X)&$G(DA(1)) "N RORFILE S RORFILE=$P($G(^ROR(799.2,DA(1),0)),U) I RORFILE K:'$$VFIELD^DILFD(RORFILE,X) X"
"^DD",799.2,799.22,6,3)
Type a field number between .000000001 and 999999999, 9 Decimal Digits
"^DD",799.2,799.22,6,8.5)
@
"^DD",799.2,799.22,6,9)
@
"^DD",799.2,799.22,6,21,0)
^^10^10^3020401^
"^DD",799.2,799.22,6,21,1,0)
The FIELD NUMBER field holds the number of the
"^DD",799.2,799.22,6,21,2,0)
field (referenced hereinafter as the search field)
"^DD",799.2,799.22,6,21,3,0)
that the data element is loaded from.
"^DD",799.2,799.22,6,21,4,0)
 
"^DD",799.2,799.22,6,21,5,0)
If the FileMan API #1 (GETS^DIQ) is used to load 
"^DD",799.2,799.22,6,21,6,0)
the value of the data element, the FIELD NUMBER
"^DD",799.2,799.22,6,21,7,0)
field must have a value.
"^DD",799.2,799.22,6,21,8,0)
 
"^DD",799.2,799.22,6,21,9,0)
Otherwise, this field can be empty. However, it is
"^DD",799.2,799.22,6,21,10,0)
recommended to populate it for clarity.
"^DD",799.2,799.22,6,"DEL",1,0)
I $$VADEL^RORDD(799.2,,-1)
"^DD",799.2,799.22,6,"DT")
3020326
"^DD",799.2,799.23,0)
API SUB-FIELD^^2^4
"^DD",799.2,799.23,0,"DT")
3020307
"^DD",799.2,799.23,0,"ID","WRITE")
D EN^DDIOL($P(^(0),U,3)_"^"_$P(^(0),U,2),,"?10")
"^DD",799.2,799.23,0,"IX","B",799.23,.01)

"^DD",799.2,799.23,0,"NM","API")

"^DD",799.2,799.23,0,"UP")
799.2
"^DD",799.2,799.23,.01,0)
API CODE^MNJ2,0X^^0;1^Q:$$VAEDT^RORDD(799.2,,-1)  K:+X'=X!(X>99)!(X<2)!(X?.E1"."1.N) X S:$D(X) DINUM=X
"^DD",799.2,799.23,.01,1,0)
^.1
"^DD",799.2,799.23,.01,1,1,0)
799.23^B
"^DD",799.2,799.23,.01,1,1,1)
S ^ROR(799.2,DA(1),3,"B",$E(X,1,30),DA)=""
"^DD",799.2,799.23,.01,1,1,2)
K ^ROR(799.2,DA(1),3,"B",$E(X,1,30),DA)
"^DD",799.2,799.23,.01,1,1,3)
Do not delete!
"^DD",799.2,799.23,.01,3)
Type a Number between 2 and 99, 0 Decimal Digits.
"^DD",799.2,799.23,.01,8.5)
@
"^DD",799.2,799.23,.01,9)
@
"^DD",799.2,799.23,.01,21,0)
^^7^7^3020321^
"^DD",799.2,799.23,.01,21,1,0)
This field stores the code of the API. These codes
"^DD",799.2,799.23,.01,21,2,0)
are used by the corresponding routines of the
"^DD",799.2,799.23,.01,21,3,0)
search engine to distinguish between the APIs.
"^DD",799.2,799.23,.01,21,4,0)
 
"^DD",799.2,799.23,.01,21,5,0)
Codes of the APIs are unique only in the file
"^DD",799.2,799.23,.01,21,6,0)
context. For example, the definition of any file
"^DD",799.2,799.23,.01,21,7,0)
can have a descriptor of the API #2.
"^DD",799.2,799.23,.01,23,0)
^.001^2^2^3020403^^
"^DD",799.2,799.23,.01,23,1,0)
Internal value of this field is used as the internal
"^DD",799.2,799.23,.01,23,2,0)
entry number of the record ('DINUM' feature).
"^DD",799.2,799.23,.01,"DEL",1,0)
I $$VADEL^RORDD(799.2,,-1)
"^DD",799.2,799.23,.01,"DT")
3020308
"^DD",799.2,799.23,1.1,0)
ROUTINE^RFX^^0;2^Q:$$VAEDT^RORDD(799.2,,-1)  K:'(X?1.8UN) X
"^DD",799.2,799.23,1.1,3)
Answer must be a valid routine name (1-8 characters in length).
"^DD",799.2,799.23,1.1,8.5)
@
"^DD",799.2,799.23,1.1,9)
@
"^DD",799.2,799.23,1.1,21,0)
^.001^2^2^3020319^^^
"^DD",799.2,799.23,1.1,21,1,0)
This field stores name of the routine implementing
"^DD",799.2,799.23,1.1,21,2,0)
the API.
"^DD",799.2,799.23,1.1,"DT")
3020308
"^DD",799.2,799.23,1.2,0)
TAG^FX^^0;3^Q:$$VAEDT^RORDD(799.2,,-1)  K:'(X?1.8UN) X
"^DD",799.2,799.23,1.2,3)
Answer must be a valid tag name (1-8 characters in length).
"^DD",799.2,799.23,1.2,8.5)
@
"^DD",799.2,799.23,1.2,9)
@
"^DD",799.2,799.23,1.2,21,0)
^^3^3^3020320^
"^DD",799.2,799.23,1.2,21,1,0)
This field contains a tag name inside the API
"^DD",799.2,799.23,1.2,21,2,0)
routine. If the routine should be executed from 
"^DD",799.2,799.23,1.2,21,3,0)
the beginning, leave this field empty.
"^DD",799.2,799.23,1.2,"DEL",1,0)
I $$VADEL^RORDD(799.2,,-1)
"^DD",799.2,799.23,1.2,"DT")
3020308
"^DD",799.2,799.23,2,0)
IA#^NJ9,0X^^0;4^Q:$$VAEDT^RORDD(799.2,,-1)  K:+X'=X!(X>999999999)!(X<1)!(X?.E1"."1.N) X
"^DD",799.2,799.23,2,.1)

"^DD",799.2,799.23,2,3)
Type a Number between 1 and 999999999, 0 Decimal Digits
"^DD",799.2,799.23,2,8.5)
@
"^DD",799.2,799.23,2,9)
@
"^DD",799.2,799.23,2,21,0)
^^2^2^3020403^
"^DD",799.2,799.23,2,21,1,0)
The IA# field stores a reference number of the 
"^DD",799.2,799.23,2,21,2,0)
integration agreement that describes this API.
"^DD",799.2,799.23,2,"DEL",1,0)
I $$VADEL^RORDD(799.2,,-1)
"^DD",799.2,799.23,2,"DT")
3020308
"^DD",799.2,799.25,0)
DESCRIPTION SUB-FIELD^^.01^1
"^DD",799.2,799.25,0,"DT")
3020308
"^DD",799.2,799.25,0,"NM","DESCRIPTION")

"^DD",799.2,799.25,0,"UP")
799.2
"^DD",799.2,799.25,.01,0)
DESCRIPTION^W^^0;1^Q
"^DD",799.2,799.25,.01,8.5)
@
"^DD",799.2,799.25,.01,9)
@
"^DD",799.2,799.25,.01,"DT")
3020308
"^DIC",798,798,0)
ROR LOCAL REGISTRY^798
"^DIC",798,798,0,"GL")
^RORDATA(798,
"^DIC",798,798,"%",0)
^1.005^^0
"^DIC",798,798,"%D",0)
^^11^11^3020402^
"^DIC",798,798,"%D",1,0)
The ROR LOCAL REGISTRY file contains records of 
"^DIC",798,798,"%D",2,0)
local registries. Each record associates a patient
"^DIC",798,798,"%D",3,0)
with a registry and contains registry specific and
"^DIC",798,798,"%D",4,0)
additional service information (when the patient 
"^DIC",798,798,"%D",5,0)
has been added to the registry, if the patient
"^DIC",798,798,"%D",6,0)
record is active or not, etc).
"^DIC",798,798,"%D",7,0)
 
"^DIC",798,798,"%D",8,0)
Records of the file are uniquely identified by 
"^DIC",798,798,"%D",9,0)
the patient and the registry (the "A" primary key
"^DIC",798,798,"%D",10,0)
and the uniqueness index "KEY" are used for that
"^DIC",798,798,"%D",11,0)
purpose).
"^DIC",798,"B","ROR LOCAL REGISTRY",798)

"^DIC",798.1,798.1,0)
ROR REGISTRY PARAMETERS^798.1
"^DIC",798.1,798.1,0,"GL")
^ROR(798.1,
"^DIC",798.1,798.1,"%",0)
^1.005^^0
"^DIC",798.1,798.1,"%D",0)
^^8^8^3020403^
"^DIC",798.1,798.1,"%D",1,0)
Records of the ROR REGISTRY PARAMETERS file 
"^DIC",798.1,798.1,"%D",2,0)
contain various registry parameters and the data
"^DIC",798.1,798.1,"%D",3,0)
that indicates current registry state. Every 
"^DIC",798.1,798.1,"%D",4,0)
registry must have a record in this file.
"^DIC",798.1,798.1,"%D",5,0)
 
"^DIC",798.1,798.1,"%D",6,0)
Records of the file are uniquely identified by the
"^DIC",798.1,798.1,"%D",7,0)
registry name (the "A" primary key and the
"^DIC",798.1,798.1,"%D",8,0)
uniqueness index "B" are used for that purpose).
"^DIC",798.1,"B","ROR REGISTRY PARAMETERS",798.1)

"^DIC",798.2,798.2,0)
ROR SELECTION RULE^798.2
"^DIC",798.2,798.2,0,"GL")
^ROR(798.2,
"^DIC",798.2,798.2,"%",0)
^1.005^^0
"^DIC",798.2,798.2,"%D",0)
^^30^30^3020403^
"^DIC",798.2,798.2,"%D",1,0)
The ROR SELECTION RULES file contains definitions
"^DIC",798.2,798.2,"%D",2,0)
of the selection rules that are used to screen
"^DIC",798.2,798.2,"%D",3,0)
patients for addition to the registries. There are
"^DIC",798.2,798.2,"%D",4,0)
two kinds of rules: top-level and lower level.
"^DIC",798.2,798.2,"%D",5,0)
 
"^DIC",798.2,798.2,"%D",6,0)
If a rule is referenced by the ROR REGISTRY 
"^DIC",798.2,798.2,"%D",7,0)
PARAMETERS file, it is the top-level rule.
"^DIC",798.2,798.2,"%D",8,0)
Non-zero value of any top-level rule expression 
"^DIC",798.2,798.2,"%D",9,0)
directly determines that the patient should be
"^DIC",798.2,798.2,"%D",10,0)
added to the corresponding registry.
"^DIC",798.2,798.2,"%D",11,0)
 
"^DIC",798.2,798.2,"%D",12,0)
Lower level rules are referenced only by other 
"^DIC",798.2,798.2,"%D",13,0)
rules (by rule macros in the expressions). Their
"^DIC",798.2,798.2,"%D",14,0)
expressions are evaluated in the proper order, and
"^DIC",798.2,798.2,"%D",15,0)
the result values are used in the expressions of 
"^DIC",798.2,798.2,"%D",16,0)
other rules. Lower level rules have an indirect
"^DIC",798.2,798.2,"%D",17,0)
impact on the final result and can be used for
"^DIC",798.2,798.2,"%D",18,0)
complex processing of linked files and multiples.
"^DIC",798.2,798.2,"%D",19,0)
 
"^DIC",798.2,798.2,"%D",20,0)
For example, a lower level rule can calculate 
"^DIC",798.2,798.2,"%D",21,0)
maximum and minimum values of a parameter in the
"^DIC",798.2,798.2,"%D",22,0)
sub-file, and a top-level rule will analyze these
"^DIC",798.2,798.2,"%D",23,0)
values and decide if the patient should be added 
"^DIC",798.2,798.2,"%D",24,0)
to the registry. Moreover, they could be used to
"^DIC",798.2,798.2,"%D",25,0)
split a very complex rule into several simpler
"^DIC",798.2,798.2,"%D",26,0)
rules.
"^DIC",798.2,798.2,"%D",27,0)
 
"^DIC",798.2,798.2,"%D",28,0)
Records of the file are uniquely identified by the
"^DIC",798.2,798.2,"%D",29,0)
rule name (the "A" primary key and the uniqueness
"^DIC",798.2,798.2,"%D",30,0)
index "B" are used for this purpose).
"^DIC",798.2,"B","ROR SELECTION RULE",798.2)

"^DIC",798.3,798.3,0)
ROR PENDING PATIENT^798.3
"^DIC",798.3,798.3,0,"GL")
^RORDATA(798.3,
"^DIC",798.3,798.3,"%",0)
^1.005^^0
"^DIC",798.3,798.3,"%D",0)
^1.001^13^13^3020419^^^^
"^DIC",798.3,798.3,"%D",1,0)
The ROR PENDING PATIENT file is used to store 
"^DIC",798.3,798.3,"%D",2,0)
references to those patients that were processed 
"^DIC",798.3,798.3,"%D",3,0)
with errors and were not added to the registry 
"^DIC",798.3,798.3,"%D",4,0)
(see the ERROR multiple).
"^DIC",798.3,798.3,"%D",5,0)
 
"^DIC",798.3,798.3,"%D",6,0)
Moreover, the data references generated by the 
"^DIC",798.3,798.3,"%D",7,0)
event protocols are stored in this file (see the 
"^DIC",798.3,798.3,"%D",8,0)
EVENT multiple). These references are used to 
"^DIC",798.3,798.3,"%D",9,0)
speed up the regular registry updates.
"^DIC",798.3,798.3,"%D",10,0)
 
"^DIC",798.3,798.3,"%D",11,0)
Records of the file have the same internal entry 
"^DIC",798.3,798.3,"%D",12,0)
numbers as the internal values of the PATIENT NAME
"^DIC",798.3,798.3,"%D",13,0)
field ('DINUM' feature).
"^DIC",798.3,"B","ROR PENDING PATIENT",798.3)

"^DIC",798.4,798.4,0)
ROR PATIENT^798.4
"^DIC",798.4,798.4,0,"GL")
^RORDATA(798.4,
"^DIC",798.4,798.4,"%",0)
^1.005^^0
"^DIC",798.4,798.4,"%D",0)
^^22^22^3020403^
"^DIC",798.4,798.4,"%D",1,0)
The ROR PATIENT file contains patient information
"^DIC",798.4,798.4,"%D",2,0)
that is common for all local registries (mostly,
"^DIC",798.4,798.4,"%D",3,0)
demographic information).
"^DIC",798.4,798.4,"%D",4,0)
 
"^DIC",798.4,798.4,"%D",5,0)
Most of the fields in the file have the same 
"^DIC",798.4,798.4,"%D",6,0)
numbers and names as the corresponding fields in
"^DIC",798.4,798.4,"%D",7,0)
the PATIENT file.
"^DIC",798.4,798.4,"%D",8,0)
 
"^DIC",798.4,798.4,"%D",9,0)
Demographic data from this file is compared to
"^DIC",798.4,798.4,"%D",10,0)
that from the PATIENT file (#2) to determine if it
"^DIC",798.4,798.4,"%D",11,0)
has been changed since the last registry data
"^DIC",798.4,798.4,"%D",12,0)
extraction. These fields are updated with the
"^DIC",798.4,798.4,"%D",13,0)
values from the PATIENT file and the UPDATE
"^DIC",798.4,798.4,"%D",14,0)
DEMOGRAPHICS flag is set to "Yes" in all active
"^DIC",798.4,798.4,"%D",15,0)
registry records of the patient.
"^DIC",798.4,798.4,"%D",16,0)
 
"^DIC",798.4,798.4,"%D",17,0)
Records in the file have the same internal entry 
"^DIC",798.4,798.4,"%D",18,0)
numbers as the patients' records in the PATIENT
"^DIC",798.4,798.4,"%D",19,0)
file.
"^DIC",798.4,798.4,"%D",20,0)
 
"^DIC",798.4,798.4,"%D",21,0)
Records of the file are uniquely identified by 
"^DIC",798.4,798.4,"%D",22,0)
internal value of the PATIENT NAME field.
"^DIC",798.4,"B","ROR PATIENT",798.4)

"^DIC",798.5,798.5,0)
ROR HDT TASK^798.5
"^DIC",798.5,798.5,0,"GL")
^RORDATA(798.5,
"^DIC",798.5,798.5,"%",0)
^1.005^^0
"^DIC",798.5,798.5,"%D",0)
^^14^14^3020508^
"^DIC",798.5,798.5,"%D",1,0)
Several data extraction tasks can be defined to 
"^DIC",798.5,798.5,"%D",2,0)
speed up the historical data extraction process.  
"^DIC",798.5,798.5,"%D",3,0)
Records of this file contain task parameters and
"^DIC",798.5,798.5,"%D",4,0)
data indicating the current state of the tasks.
"^DIC",798.5,798.5,"%D",5,0)
                                 
"^DIC",798.5,798.5,"%D",6,0)
By default, the single task is defined for the 
"^DIC",798.5,798.5,"%D",7,0)
registry by the setup task.
"^DIC",798.5,798.5,"%D",8,0)
 
"^DIC",798.5,798.5,"%D",9,0)
Records of the file are uniquely identified by the
"^DIC",798.5,798.5,"%D",10,0)
registry (the REGISTRY field) and IEN of the local
"^DIC",798.5,798.5,"%D",11,0)
registry record that the historical data
"^DIC",798.5,798.5,"%D",12,0)
extraction starts from (the START RECORD IEN
"^DIC",798.5,798.5,"%D",13,0)
field). The "A" primary key and the "C" uniqueness
"^DIC",798.5,798.5,"%D",14,0)
index are used for this purpose.
"^DIC",798.5,"B","ROR HDT TASK",798.5)

"^DIC",798.6,798.6,0)
ROR PHARMACY CODE^798.6
"^DIC",798.6,798.6,0,"GL")
^ROR(798.6,
"^DIC",798.6,798.6,"%",0)
^1.005^^0
"^DIC",798.6,798.6,"%D",0)
^^8^8^3020403^
"^DIC",798.6,798.6,"%D",1,0)
This file contains a list of pointers to the VA 
"^DIC",798.6,798.6,"%D",2,0)
Drug Class file (#50.605). Within the Pharmacy
"^DIC",798.6,798.6,"%D",3,0)
package each Class is linked to a drug or group of
"^DIC",798.6,798.6,"%D",4,0)
drugs.  Each class on this file has an associated 
"^DIC",798.6,798.6,"%D",5,0)
registry, the "AC" cross-reference groups all
"^DIC",798.6,798.6,"%D",6,0)
entries by registry.  Using the registry group of
"^DIC",798.6,798.6,"%D",7,0)
class's it is possible to compile a list of drugs 
"^DIC",798.6,798.6,"%D",8,0)
that sites have associated with each registry.
"^DIC",798.6,"B","ROR PHARMACY CODE",798.6)

"^DIC",798.7,798.7,0)
ROR LOG^798.7
"^DIC",798.7,798.7,0,"GL")
^RORDATA(798.7,
"^DIC",798.7,798.7,"%",0)
^1.005^^0
"^DIC",798.7,798.7,"%D",0)
^^9^9^3020403^
"^DIC",798.7,798.7,"%D",1,0)
The ROR LOG file is used for recording different
"^DIC",798.7,798.7,"%D",2,0)
kinds of events (errors, debug messages, etc.)
"^DIC",798.7,798.7,"%D",3,0)
that are generated by registry processes.
"^DIC",798.7,798.7,"%D",4,0)
 
"^DIC",798.7,798.7,"%D",5,0)
You may control event recording via parameters in
"^DIC",798.7,798.7,"%D",6,0)
the ROR REGISTRY PARAMETERS file.
"^DIC",798.7,798.7,"%D",7,0)
 
"^DIC",798.7,798.7,"%D",8,0)
Look for additional information in the RORLOG and 
"^DIC",798.7,798.7,"%D",9,0)
RORERR routines.
"^DIC",798.7,"B","ROR LOG",798.7)

"^DIC",798.9,798.9,0)
ROR LAB SEARCH^798.9
"^DIC",798.9,798.9,0,"GL")
^ROR(798.9,
"^DIC",798.9,798.9,"%",0)
^1.005^^0
"^DIC",798.9,798.9,"%D",0)
^^10^10^3020403^
"^DIC",798.9,798.9,"%D",1,0)
Lab search criteria are stored in this file. These
"^DIC",798.9,798.9,"%D",2,0)
criteria are referenced by the selection rules and
"^DIC",798.9,798.9,"%D",3,0)
used in the search for Lab results.
"^DIC",798.9,798.9,"%D",4,0)
 
"^DIC",798.9,798.9,"%D",5,0)
It is possible but not recommended to use the same
"^DIC",798.9,798.9,"%D",6,0)
criterion for several different registries.
"^DIC",798.9,798.9,"%D",7,0)
 
"^DIC",798.9,798.9,"%D",8,0)
Records of the file are uniquely identified by the
"^DIC",798.9,798.9,"%D",9,0)
criterion name. The "A" primary key and the "B"
"^DIC",798.9,798.9,"%D",10,0)
uniqueness index are used for this purpose.
"^DIC",798.9,"B","ROR LAB SEARCH",798.9)

"^DIC",799.1,799.1,0)
ROR LIST ITEM^799.1
"^DIC",799.1,799.1,0,"GL")
^ROR(799.1,
"^DIC",799.1,799.1,"%",0)
^1.005^^0
"^DIC",799.1,799.1,"%D",0)
^^22^22^3020403^
"^DIC",799.1,799.1,"%D",1,0)
THIS FILE MUST NOT BE MODIFIED LOCALLY! ONLY 
"^DIC",799.1,799.1,"%D",2,0)
AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN EDIT
"^DIC",799.1,799.1,"%D",3,0)
THIS FILE!
"^DIC",799.1,799.1,"%D",4,0)
 
"^DIC",799.1,799.1,"%D",5,0)
This file contains code sets used within different
"^DIC",799.1,799.1,"%D",6,0)
registries.
"^DIC",799.1,799.1,"%D",7,0)
 
"^DIC",799.1,799.1,"%D",8,0)
For example, the REASON FOR INACTIVATION field of
"^DIC",799.1,799.1,"%D",9,0)
the ROR LOCAL REGISTRY file may have different
"^DIC",799.1,799.1,"%D",10,0)
sets of possible values for different registries.
"^DIC",799.1,799.1,"%D",11,0)
All these values (for all registries) are stored
"^DIC",799.1,799.1,"%D",12,0)
in this file. The same is true for the SUPPORTING
"^DIC",799.1,799.1,"%D",13,0)
EVIDENCE field of the same file.
"^DIC",799.1,799.1,"%D",14,0)
 
"^DIC",799.1,799.1,"%D",15,0)
Records of the file are uniquely identified by the
"^DIC",799.1,799.1,"%D",16,0)
type (it associates the set of values with the 
"^DIC",799.1,799.1,"%D",17,0)
registry field), registry and item code. The "A"
"^DIC",799.1,799.1,"%D",18,0)
primary key and the "KEY" uniqueness index are
"^DIC",799.1,799.1,"%D",19,0)
used for this purpose.
"^DIC",799.1,799.1,"%D",20,0)
 
"^DIC",799.1,799.1,"%D",21,0)
DO NOT DELETE RECORDS FROM THIS FILE IF THEY HAVE 
"^DIC",799.1,799.1,"%D",22,0)
BEEN DISTRIBUTED TO THE SITES ALREADY!
"^DIC",799.1,"B","ROR LIST ITEM",799.1)

"^DIC",799.2,799.2,0)
ROR METADATA^799.2
"^DIC",799.2,799.2,0,"GL")
^ROR(799.2,
"^DIC",799.2,799.2,"%",0)
^1.005^^0
"^DIC",799.2,799.2,"%D",0)
^^33^33^3020328^^
"^DIC",799.2,799.2,"%D",1,0)
THIS FILE MUST NOT BE MODIFIED LOCALLY! ONLY 
"^DIC",799.2,799.2,"%D",2,0)
AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN EDIT
"^DIC",799.2,799.2,"%D",3,0)
THIS FILE!
"^DIC",799.2,799.2,"%D",4,0)
 
"^DIC",799.2,799.2,"%D",5,0)
The ROR METADATA file contains descriptors of the
"^DIC",799.2,799.2,"%D",6,0)
files, data elements and APIs used by the registry
"^DIC",799.2,799.2,"%D",7,0)
update subsystem (search engine). These
"^DIC",799.2,799.2,"%D",8,0)
descriptors define relationships between files
"^DIC",799.2,799.2,"%D",9,0)
("file-processing tree") used by the search
"^DIC",799.2,799.2,"%D",10,0)
engine, data elements and APIs.
"^DIC",799.2,799.2,"%D",11,0)
 
"^DIC",799.2,799.2,"%D",12,0)
The expression parser uses data stored in this 
"^DIC",799.2,799.2,"%D",13,0)
file to validate expressions that implement
"^DIC",799.2,799.2,"%D",14,0)
selection rules.
"^DIC",799.2,799.2,"%D",15,0)
 
"^DIC",799.2,799.2,"%D",16,0)
Data from this file loaded and prepared by the
"^DIC",799.2,799.2,"%D",17,0)
$$METADATA^RORUPR1 function is used by the
"^DIC",799.2,799.2,"%D",18,0)
registry update process to load values of the data
"^DIC",799.2,799.2,"%D",19,0)
elements using appropriate APIs.
"^DIC",799.2,799.2,"%D",20,0)
 
"^DIC",799.2,799.2,"%D",21,0)
Developers can use this file as a source of 
"^DIC",799.2,799.2,"%D",22,0)
information required for definition of new 
"^DIC",799.2,799.2,"%D",23,0)
selection rules for new national or local
"^DIC",799.2,799.2,"%D",24,0)
registries (supported files and data elements,
"^DIC",799.2,799.2,"%D",25,0)
APIs, DBIAs, etc).
"^DIC",799.2,799.2,"%D",26,0)
 
"^DIC",799.2,799.2,"%D",27,0)
All modifications of the registry update routines
"^DIC",799.2,799.2,"%D",28,0)
that affect the file-processing tree, APIs or
"^DIC",799.2,799.2,"%D",29,0)
supported data elements MUST be reflected in the 
"^DIC",799.2,799.2,"%D",30,0)
ROR METADATA file.
"^DIC",799.2,799.2,"%D",31,0)
 
"^DIC",799.2,799.2,"%D",32,0)
Records of this file have internal entry numbers 
"^DIC",799.2,799.2,"%D",33,0)
equal to the corresponding file numbers.
"^DIC",799.2,"B","ROR METADATA",799.2)

**END**
**END**
