Released XWB*1.1*35 SEQ #30
Extracted from mail message
**KIDS**:XWB*1.1*35^

**INSTALL NAME**
XWB*1.1*35
"BLD",420,0)
XWB*1.1*35^RPC BROKER^0^3041209^y
"BLD",420,1,0)
^^2^2^3030408^^
"BLD",420,1,1,0)
Please refer to the Description in the FORUM Patch Module for details.
"BLD",420,1,2,0)
Patch XWB*1.1*35.
"BLD",420,4,0)
^9.64PA^8994.1^1
"BLD",420,4,8994.1,0)
8994.1
"BLD",420,4,8994.1,222)
y^y^f^^^^n
"BLD",420,4,"B",8994.1,8994.1)

"BLD",420,"KRN",0)
^9.67PA^8989.52^19
"BLD",420,"KRN",.4,0)
.4
"BLD",420,"KRN",.401,0)
.401
"BLD",420,"KRN",.402,0)
.402
"BLD",420,"KRN",.402,"NM",0)
^9.68A^1^1
"BLD",420,"KRN",.402,"NM",1,0)
XWB LISTENER EDIT    FILE #8994.1^8994.1^0
"BLD",420,"KRN",.402,"NM","B","XWB LISTENER EDIT    FILE #8994.1",1)

"BLD",420,"KRN",.403,0)
.403
"BLD",420,"KRN",.5,0)
.5
"BLD",420,"KRN",.84,0)
.84
"BLD",420,"KRN",3.6,0)
3.6
"BLD",420,"KRN",3.8,0)
3.8
"BLD",420,"KRN",9.2,0)
9.2
"BLD",420,"KRN",9.8,0)
9.8
"BLD",420,"KRN",9.8,"NM",0)
^9.68A^14^12
"BLD",420,"KRN",9.8,"NM",1,0)
XWBTCPM^^0^B53101617
"BLD",420,"KRN",9.8,"NM",2,0)
XWBPRS^^0^B38481438
"BLD",420,"KRN",9.8,"NM",4,0)
XWBTCPM1^^0^B7265734
"BLD",420,"KRN",9.8,"NM",5,0)
XWBTCP^^0^B48888024
"BLD",420,"KRN",9.8,"NM",6,0)
XWBTCPC^^0^B32111075
"BLD",420,"KRN",9.8,"NM",7,0)
XWBLIB^^0^B10132147
"BLD",420,"KRN",9.8,"NM",8,0)
XWBTCPL^^0^B59791683
"BLD",420,"KRN",9.8,"NM",9,0)
XWBSEC^^0^B5461544
"BLD",420,"KRN",9.8,"NM",11,0)
XWBEXMPL^^0^B5787669
"BLD",420,"KRN",9.8,"NM",12,0)
XWBBRK^^0^B34093927
"BLD",420,"KRN",9.8,"NM",13,0)
XWBRW^^0^B8441815
"BLD",420,"KRN",9.8,"NM",14,0)
XWBDLOG^^0^B6484698
"BLD",420,"KRN",9.8,"NM","B","XWBBRK",12)

"BLD",420,"KRN",9.8,"NM","B","XWBDLOG",14)

"BLD",420,"KRN",9.8,"NM","B","XWBEXMPL",11)

"BLD",420,"KRN",9.8,"NM","B","XWBLIB",7)

"BLD",420,"KRN",9.8,"NM","B","XWBPRS",2)

"BLD",420,"KRN",9.8,"NM","B","XWBRW",13)

"BLD",420,"KRN",9.8,"NM","B","XWBSEC",9)

"BLD",420,"KRN",9.8,"NM","B","XWBTCP",5)

"BLD",420,"KRN",9.8,"NM","B","XWBTCPC",6)

"BLD",420,"KRN",9.8,"NM","B","XWBTCPL",8)

"BLD",420,"KRN",9.8,"NM","B","XWBTCPM",1)

"BLD",420,"KRN",9.8,"NM","B","XWBTCPM1",4)

"BLD",420,"KRN",19,0)
19
"BLD",420,"KRN",19,"NM",0)
^9.68A^10^8
"BLD",420,"KRN",19,"NM",1,0)
XWB LISTENER STARTER^^0
"BLD",420,"KRN",19,"NM",2,0)
XWB LISTENER STOP ALL^^0
"BLD",420,"KRN",19,"NM",3,0)
XWB LISTENER EDIT^^0
"BLD",420,"KRN",19,"NM",4,0)
XWB DEBUG EDIT^^0
"BLD",420,"KRN",19,"NM",5,0)
XWB MENU^^2
"BLD",420,"KRN",19,"NM",8,0)
XWB LOG VIEW^^0
"BLD",420,"KRN",19,"NM",9,0)
XWB LOG CLEAR^^0
"BLD",420,"KRN",19,"NM",10,0)
XWB BROKER EXAMPLE^^0
"BLD",420,"KRN",19,"NM","B","XWB BROKER EXAMPLE",10)

"BLD",420,"KRN",19,"NM","B","XWB DEBUG EDIT",4)

"BLD",420,"KRN",19,"NM","B","XWB LISTENER EDIT",3)

"BLD",420,"KRN",19,"NM","B","XWB LISTENER STARTER",1)

"BLD",420,"KRN",19,"NM","B","XWB LISTENER STOP ALL",2)

"BLD",420,"KRN",19,"NM","B","XWB LOG CLEAR",9)

"BLD",420,"KRN",19,"NM","B","XWB LOG VIEW",8)

"BLD",420,"KRN",19,"NM","B","XWB MENU",5)

"BLD",420,"KRN",19.1,0)
19.1
"BLD",420,"KRN",101,0)
101
"BLD",420,"KRN",409.61,0)
409.61
"BLD",420,"KRN",771,0)
771
"BLD",420,"KRN",870,0)
870
"BLD",420,"KRN",8989.51,0)
8989.51
"BLD",420,"KRN",8989.51,"NM",0)
^9.68A^1^1
"BLD",420,"KRN",8989.51,"NM",1,0)
XWBDEBUG^^0
"BLD",420,"KRN",8989.51,"NM","B","XWBDEBUG",1)

"BLD",420,"KRN",8989.52,0)
8989.52
"BLD",420,"KRN",8989.52,"NM",0)
^9.68A^^
"BLD",420,"KRN",8994,0)
8994
"BLD",420,"KRN",8994,"NM",0)
^9.68A^2^2
"BLD",420,"KRN",8994,"NM",1,0)
XWB EXAMPLE GLOBAL SORT^^0
"BLD",420,"KRN",8994,"NM",2,0)
XWB EXAMPLE BIG TEXT^^0
"BLD",420,"KRN",8994,"NM","B","XWB EXAMPLE BIG TEXT",2)

"BLD",420,"KRN",8994,"NM","B","XWB EXAMPLE GLOBAL SORT",1)

"BLD",420,"KRN","B",.4,.4)

"BLD",420,"KRN","B",.401,.401)

"BLD",420,"KRN","B",.402,.402)

"BLD",420,"KRN","B",.403,.403)

"BLD",420,"KRN","B",.5,.5)

"BLD",420,"KRN","B",.84,.84)

"BLD",420,"KRN","B",3.6,3.6)

"BLD",420,"KRN","B",3.8,3.8)

"BLD",420,"KRN","B",9.2,9.2)

"BLD",420,"KRN","B",9.8,9.8)

"BLD",420,"KRN","B",19,19)

"BLD",420,"KRN","B",19.1,19.1)

"BLD",420,"KRN","B",101,101)

"BLD",420,"KRN","B",409.61,409.61)

"BLD",420,"KRN","B",771,771)

"BLD",420,"KRN","B",870,870)

"BLD",420,"KRN","B",8989.51,8989.51)

"BLD",420,"KRN","B",8989.52,8989.52)

"BLD",420,"KRN","B",8994,8994)

"BLD",420,"QUES",0)
^9.62^^
"BLD",420,"REQB",0)
^9.611^2^2
"BLD",420,"REQB",1,0)
XWB*1.1*26^2
"BLD",420,"REQB",2,0)
XWB*1.1*22^2
"BLD",420,"REQB","B","XWB*1.1*22",2)

"BLD",420,"REQB","B","XWB*1.1*26",1)

"FIA",8994.1)
RPC BROKER SITE PARAMETERS
"FIA",8994.1,0)
^XWB(8994.1,
"FIA",8994.1,0,0)
8994.1P
"FIA",8994.1,0,1)
y^y^f^^^^n
"FIA",8994.1,0,10)

"FIA",8994.1,0,11)

"FIA",8994.1,0,"RLRO")

"FIA",8994.1,0,"VR")
1.1^XWB
"FIA",8994.1,8994.1)
0
"FIA",8994.1,8994.17)
0
"FIA",8994.1,8994.171)
0
"KRN",.402,44,-1)
0^1
"KRN",.402,44,0)
XWB LISTENER EDIT^3030701.0852^^8994.1^^@^3040909
"KRN",.402,44,"DR",1,8994.1)
7;
"KRN",.402,44,"DR",2,8994.17)
.01;1;
"KRN",.402,44,"DR",3,8994.171)
.01;1;.5;2;
"KRN",19,631,-1)
0^1
"KRN",19,631,0)
XWB LISTENER STARTER^Start All RPC Broker Listeners^^R^^^^^^^^RPC BROKER^y
"KRN",19,631,1,0)
^19.06^10^10^3040325^^^
"KRN",19,631,1,1,0)
This option will Start/Restart all the RPC Broker listeners under the
"KRN",19,631,1,2,0)
control of the RPC BROKER SITE PARAMETERS file.
"KRN",19,631,1,3,0)
It is normally setup as a STARTUP type option in the taskman option
"KRN",19,631,1,4,0)
scheduling file. This option will first STOP ALL listeners and then START
"KRN",19,631,1,5,0)
ALL the listeners through Taskman.  (VMS sites need to be running Taskman
"KRN",19,631,1,6,0)
in DCL context).
"KRN",19,631,1,7,0)
The XWB LISTENER STARTER cannot be used to start one particular listener.
"KRN",19,631,1,8,0)
To do this, in programmer mode, use STRT^XWBTCP(portnumber) on the node
"KRN",19,631,1,9,0)
the listener needs to run on. Or use the XWB LISTENER EDIT option to
"KRN",19,631,1,10,0)
change the status of the one listener.
"KRN",19,631,25)
RESTART^XWBTCP
"KRN",19,631,200.9)
s
"KRN",19,631,"U")
START ALL RPC BROKER LISTENERS
"KRN",19,633,-1)
0^10
"KRN",19,633,0)
XWB BROKER EXAMPLE^RPC BROKER PROGRAMMING EXAMPLE^^B^^^^^^^^
"KRN",19,633,1,0)
^^22^22^3010612^
"KRN",19,633,1,1,0)
This option is the RPC Boroker Example appliation context.  RPC Broker
"KRN",19,633,1,2,0)
Example exists as a teaching tool for someone learning to program using
"KRN",19,633,1,3,0)
VA Remote Procedure Broker.  The entire application consists of this option,
"KRN",19,633,1,4,0)
XWBEXMPL routine and
"KRN",19,633,1,5,0)
 
"KRN",19,633,1,6,0)
Remote procedures:
"KRN",19,633,1,7,0)
     XWB EXAMPLE ECHO STRING  
"KRN",19,633,1,8,0)
     XWB EXAMPLE GET LIST  
"KRN",19,633,1,9,0)
     XWB EXAMPLE SORT NUMBERS  
"KRN",19,633,1,10,0)
     XWB EXAMPLE WPTEXT  
"KRN",19,633,1,11,0)
     XWB GET VARIABLE VALUE
"KRN",19,633,1,12,0)
     XWB EXAMPLE TRAP PARAMS
"KRN",19,633,1,13,0)
 
"KRN",19,633,1,14,0)
Delphi Object Pascal source files:
"KRN",19,633,1,15,0)
     BrokerExample.DPR 
"KRN",19,633,1,16,0)
     BrokerExampleFrm.DFM
"KRN",19,633,1,17,0)
     BrokerExampleFrm.PAS
"KRN",19,633,1,18,0)
     BrokerExampleAboutFrm.DFM
"KRN",19,633,1,19,0)
     BrokerExampleAboutFrm.PAS
"KRN",19,633,1,20,0)
 
"KRN",19,633,1,21,0)
Standard VistA infrastructure including Kernel, ToolKit, FileMan and RPC
"KRN",19,633,1,22,0)
Broker, is required of course.
"KRN",19,633,99.1)
59304,21399
"KRN",19,633,"RPC",0)
^19.05P^8^8
"KRN",19,633,"RPC",1,0)
XWB EXAMPLE ECHO STRING
"KRN",19,633,"RPC",2,0)
XWB EXAMPLE GET LIST
"KRN",19,633,"RPC",3,0)
XWB EXAMPLE SORT NUMBERS
"KRN",19,633,"RPC",4,0)
XWB EXAMPLE WPTEXT
"KRN",19,633,"RPC",5,0)
XWB GET VARIABLE VALUE
"KRN",19,633,"RPC",6,0)
XWB EXAMPLE TRAP PARAMS
"KRN",19,633,"RPC",7,0)
XWB EXAMPLE GLOBAL SORT
"KRN",19,633,"RPC",8,0)
XWB EXAMPLE BIG TEXT
"KRN",19,633,"U")
RPC BROKER PROGRAMMING EXAMPLE
"KRN",19,721,-1)
0^2
"KRN",19,721,0)
XWB LISTENER STOP ALL^Stop All RPC Broker Listeners^^R^^^^^^^^RPC BROKER^y
"KRN",19,721,1,0)
^^2^2^2991103^
"KRN",19,721,1,1,0)
This option will Stop all the RPC Broker listeners under the control of
"KRN",19,721,1,2,0)
the RPC BROKER SITE PARAMETERS file.
"KRN",19,721,25)
STOPALL^XWBTCP
"KRN",19,721,"U")
STOP ALL RPC BROKER LISTENERS
"KRN",19,722,-1)
2^5
"KRN",19,722,0)
XWB MENU^RPC Broker Management Menu^^M^2^^^^^^^7^n
"KRN",19,722,10,0)
^19.01IP^6^6
"KRN",19,722,10,1,0)
721^^3
"KRN",19,722,10,1,"^")
XWB LISTENER STOP ALL
"KRN",19,722,10,2,0)
723^^1
"KRN",19,722,10,2,"^")
XWB LISTENER EDIT
"KRN",19,722,10,3,0)
631^^2
"KRN",19,722,10,3,"^")
XWB LISTENER STARTER
"KRN",19,722,10,4,0)
794
"KRN",19,722,10,4,"^")
XWB DEBUG EDIT
"KRN",19,722,10,5,0)
802
"KRN",19,722,10,5,"^")
XWB LOG CLEAR
"KRN",19,722,10,6,0)
801
"KRN",19,722,10,6,"^")
XWB LOG VIEW
"KRN",19,722,"U")
RPC BROKER MANAGEMENT MENU
"KRN",19,723,-1)
0^3
"KRN",19,723,0)
XWB LISTENER EDIT^RPC Listener Edit^^E^^^^^^^^RPC BROKER^n
"KRN",19,723,1,0)
^^2^2^3000106^^
"KRN",19,723,1,1,0)
This option allows for editing the RPC BROKER SITE PARAMETERS file
"KRN",19,723,1,2,0)
(#8994.1).
"KRN",19,723,30)
XWB(8994.1,
"KRN",19,723,31)
AEMQ
"KRN",19,723,50)
XWB(8994.1,
"KRN",19,723,51)
[XWB LISTENER EDIT]
"KRN",19,723,99.1)
59178,54308
"KRN",19,723,"U")
RPC LISTENER EDIT
"KRN",19,794,-1)
0^4
"KRN",19,794,0)
XWB DEBUG EDIT^Debug Parameter Edit^^R^^^^^^^^^y
"KRN",19,794,1,0)
^^1^1^3031008^
"KRN",19,794,1,1,0)
This option allows the editing of the BROKER debug parameter.
"KRN",19,794,25)
DEBUG^XWBTCP
"KRN",19,794,"U")
DEBUG PARAMETER EDIT
"KRN",19,801,-1)
0^8
"KRN",19,801,0)
XWB LOG VIEW^View XWB Log^^R^^^^^^^^RPC BROKER^y
"KRN",19,801,1,0)
^^2^2^3040413^
"KRN",19,801,1,1,0)
This option allow the user to view the debug log files that the Broker 
"KRN",19,801,1,2,0)
can set.  The parameter XWBDEBUG must be set for log files to be recorded.
"KRN",19,801,25)
VIEW^XWBDLOG
"KRN",19,801,"U")
VIEW XWB LOG
"KRN",19,802,-1)
0^9
"KRN",19,802,0)
XWB LOG CLEAR^Clear XWB Log Files^^R^^^^^^^^RPC BROKER^y
"KRN",19,802,1,0)
^^1^1^3040413^
"KRN",19,802,1,1,0)
This option allows the user to clear (KILL) the XWB log files.
"KRN",19,802,25)
KILLALL^XWBDLOG
"KRN",19,802,"U")
CLEAR XWB LOG FILES
"KRN",8989.51,3,-1)
0^1
"KRN",8989.51,3,0)
XWBDEBUG^RPCBroker debug logging^0^^Enable Broker Logging
"KRN",8989.51,3,1)
S^0:No;1:Yes;2:Verbose;3:very Verbose
"KRN",8989.51,3,20,0)
^8989.512^2^2^3030923^^
"KRN",8989.51,3,20,1,0)
This parameter controls if the RPC Broker records log data 
"KRN",8989.51,3,20,2,0)
in ^TMP("XWBDBUG",$J).
"KRN",8989.51,3,30,0)
^8989.513I^1^1
"KRN",8989.51,3,30,1,0)
1^4.2
"KRN",8994,99,-1)
0^1
"KRN",8994,99,0)
XWB EXAMPLE GLOBAL SORT^GSORT^XWBEXMPL^4^R^0^^1
"KRN",8994,99,1,0)
^^3^3^3040708^
"KRN",8994,99,1,1,0)
 This RPC uses the new Global call to send down a BIG list of number to 
"KRN",8994,99,1,2,0)
 sort.  In the old Broker it would cause an allocation error but this one 
"KRN",8994,99,1,3,0)
 saves the data into a temp global.  
"KRN",8994,115,-1)
0^2
"KRN",8994,115,0)
XWB EXAMPLE BIG TEXT^BIGTXT^XWBEXMPL^1
"MBREQ")
0
"ORD",7,.402)
.402;7;;;EDEOUT^DIFROMSO(.402,DA,"",XPDA);FPRE^DIFROMSI(.402,"",XPDA);EPRE^DIFROMSI(.402,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.402,DA,"",XPDA);DEL^DIFROMSK(.402,"",%)
"ORD",7,.402,0)
INPUT TEMPLATE
"ORD",16,8994)
8994;16;1;;;;;;;RPCDEL^XPDIA1
"ORD",16,8994,0)
REMOTE PROCEDURE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"ORD",20,8989.51)
8989.51;20;;;PAR1E1^XPDTA2;PAR1F1^XPDIA3;PAR1E1^XPDIA3;PAR1F2^XPDIA3
"ORD",20,8989.51,0)
PARAMETER DEFINITION
"PKG",7,-1)
1^1
"PKG",7,0)
RPC BROKER^XWB^Remote Procedure Call Broker
"PKG",7,20,0)
^9.402P^^
"PKG",7,22,0)
^9.49I^1^1
"PKG",7,22,1,0)
1.1^2970918^2990407^126
"PKG",7,22,1,"PAH",1,0)
35^3041209
"PKG",7,22,1,"PAH",1,1,0)
^^2^2^3041209
"PKG",7,22,1,"PAH",1,1,1,0)
Please refer to the Description in the FORUM Patch Module for details.
"PKG",7,22,1,"PAH",1,1,2,0)
Patch XWB*1.1*35.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
12
"RTN","XWBBRK")
0^12^B34093927
"RTN","XWBBRK",1,0)
XWBBRK ;ISC-SF/EG - DHCP BROKER PROTOYPE ;07/08/2004  11:08
"RTN","XWBBRK",2,0)
 ;;1.1;RPC BROKER;**2,4,10,16,26,35**;Mar 28, 1997
"RTN","XWBBRK",3,0)
PRSP(P) ;Parse Protocol
"RTN","XWBBRK",4,0)
 ;M Extrinsic Function
"RTN","XWBBRK",5,0)
 ;
"RTN","XWBBRK",6,0)
 ;Inputs
"RTN","XWBBRK",7,0)
 ;P        Protocol string with the form
"RTN","XWBBRK",8,0)
 ;         Protocol := Protocol Header^Message where
"RTN","XWBBRK",9,0)
 ;         Protocol Header := LLLWKID;WINH;PRCH;WISH;MESG
"RTN","XWBBRK",10,0)
 ;           LLL  := length of protocol header (3 numeric)
"RTN","XWBBRK",11,0)
 ;           WKID := Workstation ID (ALPHA)
"RTN","XWBBRK",12,0)
 ;           WINH := Window handle (ALPHA)
"RTN","XWBBRK",13,0)
 ;           PRCH := Process handle (ALPHA)
"RTN","XWBBRK",14,0)
 ;           WISH := Window server handle (ALPHA)
"RTN","XWBBRK",15,0)
 ;           MESG := Unparsed message
"RTN","XWBBRK",16,0)
 ;Outputs
"RTN","XWBBRK",17,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",18,0)
 ;
"RTN","XWBBRK",19,0)
 N ERR,C,M,R,X,U
"RTN","XWBBRK",20,0)
 S U="U",R=0,C=";",ERR=0,M=512 ;Maximum buffer input
"RTN","XWBBRK",21,0)
 IF $E(P,1,5)="{XWB}" S P=$E(P,6,$L(P)) ;drop out prefix
"RTN","XWBBRK",22,0)
 IF '+$G(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",23,0)
 IF +ERR=0 D
"RTN","XWBBRK",24,0)
 . S XWB(R,"LENG")=+$E(P,1,3)
"RTN","XWBBRK",25,0)
 . S X=$E(P,4,XWB(R,"LENG")+3)
"RTN","XWBBRK",26,0)
 . S XWB(R,"MESG")=$E(P,XWB(R,"LENG")+4,M)
"RTN","XWBBRK",27,0)
 . S XWB(R,"WKID")=$P(X,C)
"RTN","XWBBRK",28,0)
 . S XWB(R,"WINH")=$P(X,C,2)
"RTN","XWBBRK",29,0)
 . S XWB(R,"PRCH")=$P(X,C,3)
"RTN","XWBBRK",30,0)
 . S XWB(R,"WISH")=$P(X,C,4)
"RTN","XWBBRK",31,0)
 Q ERR
"RTN","XWBBRK",32,0)
 ;
"RTN","XWBBRK",33,0)
PRSM(P) ;Parse message
"RTN","XWBBRK",34,0)
 ;M Extrinsic Function
"RTN","XWBBRK",35,0)
 ;
"RTN","XWBBRK",36,0)
 ;Inputs
"RTN","XWBBRK",37,0)
 ;P        Message string with the form
"RTN","XWBBRK",38,0)
 ;         Message := Header^Content
"RTN","XWBBRK",39,0)
 ;           Header  := LLL;FLAG
"RTN","XWBBRK",40,0)
 ;             LLL     := length of entire message (3 numeric)
"RTN","XWBBRK",41,0)
 ;             FLAG    := 1 indicates variables follow
"RTN","XWBBRK",42,0)
 ;           Content := Contains API call information
"RTN","XWBBRK",43,0)
 ;Outputs
"RTN","XWBBRK",44,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",45,0)
 N C,ERR,M,R,X,U
"RTN","XWBBRK",46,0)
 S U="^",R=1,C=";",ERR=0,M=512 ;Max buffer
"RTN","XWBBRK",47,0)
 IF '+$G(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",48,0)
 IF +ERR=0 D
"RTN","XWBBRK",49,0)
 . S XWB(R,"LENG")=+$E(P,1,5)
"RTN","XWBBRK",50,0)
 . S XWB(R,"FLAG")=$E(P,6,6)
"RTN","XWBBRK",51,0)
 . S XWB(R,"TEXT")=$E(P,7,M)
"RTN","XWBBRK",52,0)
 Q ERR
"RTN","XWBBRK",53,0)
 ;
"RTN","XWBBRK",54,0)
PRSA(P) ;Parse API information, get calling info
"RTN","XWBBRK",55,0)
 ;M Extrinsic Function
"RTN","XWBBRK",56,0)
 ;Inputs
"RTN","XWBBRK",57,0)
 ;P        Content := API Name^Param string
"RTN","XWBBRK",58,0)
 ;           API     := .01 field of API file
"RTN","XWBBRK",59,0)
 ;           Param   := Parameter information
"RTN","XWBBRK",60,0)
 ;Outputs
"RTN","XWBBRK",61,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",62,0)
 ;
"RTN","XWBBRK",63,0)
 N C,DR,ERR,M,R,T,X,U
"RTN","XWBBRK",64,0)
 S U="^",R=2,C=";",ERR=0,M=512 ;Max buffer
"RTN","XWBBRK",65,0)
 IF '+$L(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",66,0)
 IF +ERR=0 D
"RTN","XWBBRK",67,0)
 . S XWB(R,"CAPI")=$P(P,U)
"RTN","XWBBRK",68,0)
 . S XWB(R,"PARM")=$E(P,$F(P,U),M)
"RTN","XWBBRK",69,0)
 . S T=$O(^XWB(8994,"B",XWB(R,"CAPI"),0))
"RTN","XWBBRK",70,0)
 . I '+T S ERR="-1^Remote Procedure '"_XWB(R,"CAPI")_"' doesn't exist on the server." Q  ;P10 - dpc
"RTN","XWBBRK",71,0)
 . S T(0)=$G(^XWB(8994,T,0))
"RTN","XWBBRK",72,0)
 . I $P(T(0),U,6)=1!($P(T(0),U,6)=2) S ERR="-1^Remote Procedure '"_XWB(R,"CAPI")_"' cannot be run at this time." Q  ;P10. Check INACTIVE field. - dpc.
"RTN","XWBBRK",73,0)
 . S XWB(R,"NAME")=$P(T(0),"^")
"RTN","XWBBRK",74,0)
 . S XWB(R,"RTAG")=$P(T(0),"^",2)
"RTN","XWBBRK",75,0)
 . S XWB(R,"RNAM")=$P(T(0),"^",3)
"RTN","XWBBRK",76,0)
 . S XWBPTYPE=$P(T(0),"^",4)
"RTN","XWBBRK",77,0)
 . S XWBWRAP=+$P(T(0),"^",8)
"RTN","XWBBRK",78,0)
 Q ERR
"RTN","XWBBRK",79,0)
 ;
"RTN","XWBBRK",80,0)
PRSB(P) ;Parse Parameter information
"RTN","XWBBRK",81,0)
 ;M Extrinsic Function
"RTN","XWBBRK",82,0)
 ;Inputs
"RTN","XWBBRK",83,0)
 ;P        Param   := M parameter list
"RTN","XWBBRK",84,0)
 ;           Param   := LLL,Name,Value
"RTN","XWBBRK",85,0)
 ;             LLL     := length of variable name and value
"RTN","XWBBRK",86,0)
 ;             Name    := name of M variable
"RTN","XWBBRK",87,0)
 ;             Value   := a string
"RTN","XWBBRK",88,0)
 ;Outputs
"RTN","XWBBRK",89,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",90,0)
 ;
"RTN","XWBBRK",91,0)
 N A,ERR,F,FL,I,K,L,M,P1,P2,P3,P4,P5,MAXP,R
"RTN","XWBBRK",92,0)
 S R=3,MAXP=+$E(P,1,5)
"RTN","XWBBRK",93,0)
 S P1=$E(P,6,MAXP+5) ;only param string
"RTN","XWBBRK",94,0)
 S ERR=0,F=3,M=512
"RTN","XWBBRK",95,0)
 IF '+$D(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",96,0)
 S FL=+$G(XWB(1,"FLAG"))
"RTN","XWBBRK",97,0)
 S I=0
"RTN","XWBBRK",98,0)
 IF '+ERR D
"RTN","XWBBRK",99,0)
 . ;IF 'FL S P1=$E(P,F+1,MAXP) Q
"RTN","XWBBRK",100,0)
 . IF 'FL,+MAXP=0 S P1="",ERR=1 Q
"RTN","XWBBRK",101,0)
 . F  D  Q:P1=""
"RTN","XWBBRK",102,0)
 . . Q:P1=""
"RTN","XWBBRK",103,0)
 . . S L=+$E(P1,1,3)-1
"RTN","XWBBRK",104,0)
 . . S P3=+$E(P1,4,4)
"RTN","XWBBRK",105,0)
 . . S P1=$E(P1,5,MAXP)
"RTN","XWBBRK",106,0)
 . . S XWB(R,"P",I)=$S(P3'=1:$E(P1,1,L),1:$$GETV($E(P1,1,L)))
"RTN","XWBBRK",107,0)
 . . IF FL=1,P3=2 D  ;XWB*1.1*2
"RTN","XWBBRK",108,0)
 . . . S A=$$OARY^XWBBRK2,XWBARY=A
"RTN","XWBBRK",109,0)
 . . . S XWB(R,"P",I)=$$CREF^XWBBRK2(A,XWB(R,"P",I))
"RTN","XWBBRK",110,0)
 . . S P1=$E(P1,L+1,MAXP)
"RTN","XWBBRK",111,0)
 . . S K=I,I=I+1
"RTN","XWBBRK",112,0)
 . IF 'FL Q
"RTN","XWBBRK",113,0)
 . S P3=P
"RTN","XWBBRK",114,0)
 . S L=+$E(P3,1,5)
"RTN","XWBBRK",115,0)
 . S P1=$E(P3,F+3,L+F)
"RTN","XWBBRK",116,0)
 . ;IF FL=1 S P1=$$CREF^XWBBRK2(A,P1) ;convert array ref to namespace ref
"RTN","XWBBRK",117,0)
 . S P2=$E(P3,L+F+3,M)
"RTN","XWBBRK",118,0)
 . ;instantiate array
"RTN","XWBBRK",119,0)
 . ;S DM=0
"RTN","XWBBRK",120,0)
 . F  D  Q:+L=0
"RTN","XWBBRK",121,0)
 . . ;Sumtimes the array is null, so there isn't data for first read.
"RTN","XWBBRK",122,0)
 . . S L=+$$BREAD^XWBRW(3,15,1) Q:L=0  S P3=$$BREAD^XWBRW(L)
"RTN","XWBBRK",123,0)
 . . S L=+$$BREAD^XWBRW(3) IF L'=0 S P4=$$BREAD^XWBRW(L)
"RTN","XWBBRK",124,0)
 . . IF L=0 Q
"RTN","XWBBRK",125,0)
 . . IF P3=0,P4="" S L=0 Q  ; P4=0 changed to P4="" JLI 021114
"RTN","XWBBRK",126,0)
 . . IF FL=1 D LINST(A,P3,P4)
"RTN","XWBBRK",127,0)
 . . IF FL=2 D GINST
"RTN","XWBBRK",128,0)
 IF ERR Q P1
"RTN","XWBBRK",129,0)
 S P1=""
"RTN","XWBBRK",130,0)
 D  Q P1
"RTN","XWBBRK",131,0)
 . F I=0:1:K D
"RTN","XWBBRK",132,0)
 . . IF FL,$E(XWB(R,"P",I),1,5)=".XWBS" D  Q  ;XWB*1.1*2
"RTN","XWBBRK",133,0)
 . . . S P1=P1_"."_$E(XWB(R,"P",I),2,$L(XWB(R,"P",I)))
"RTN","XWBBRK",134,0)
 . . . IF I'=K S P1=P1_","
"RTN","XWBBRK",135,0)
 . . S P1=P1_"XWB("_R_",""P"","_I_")"
"RTN","XWBBRK",136,0)
 . . IF I'=K S P1=P1_","
"RTN","XWBBRK",137,0)
 IF '+ERR Q P1
"RTN","XWBBRK",138,0)
 Q ERR
"RTN","XWBBRK",139,0)
 ;
"RTN","XWBBRK",140,0)
CALLP(XWBP,P,DEBUG) ;make API call using Protocol string
"RTN","XWBBRK",141,0)
 ;ERR will be 0 or "-1^text"
"RTN","XWBBRK",142,0)
 N ERR,S
"RTN","XWBBRK",143,0)
 S ERR=0
"RTN","XWBBRK",144,0)
 IF '$D(DEBUG) S DEBUG=0
"RTN","XWBBRK",145,0)
 ;IF 'DEBUG D:$D(XRTL) T0^%ZOSV ;start RTL
"RTN","XWBBRK",146,0)
 S ERR=$$PRSP(P)
"RTN","XWBBRK",147,0)
 IF '+ERR S ERR=$$PRSM(XWB(0,"MESG"))
"RTN","XWBBRK",148,0)
 IF '+ERR S ERR=$$PRSA(XWB(1,"TEXT")) I $G(XWB(2,"CAPI"))="XUS SET SHARED" S XWBSHARE=1 Q
"RTN","XWBBRK",149,0)
 I +ERR S XWBSEC=$P(ERR,U,2) ;P10 -- dpc
"RTN","XWBBRK",150,0)
 IF '+ERR S S=$$PRSB(XWB(2,"PARM"))
"RTN","XWBBRK",151,0)
 ;Check OK
"RTN","XWBBRK",152,0)
 I '+ERR D CHKPRMIT^XWBSEC(XWB(2,"CAPI")) ;checks if RPC allowed to run
"RTN","XWBBRK",153,0)
 S:$L($G(XWBSEC)) ERR="-1^"_XWBSEC
"RTN","XWBBRK",154,0)
 ;IF 'DEBUG S:$D(XRT0) XRTN="RPC BROKER READ/PARSE" D:$D(XRT0) T1^%ZOSV ;stop RTL
"RTN","XWBBRK",155,0)
 IF '+ERR,(+S=0)!(+S>0) D
"RTN","XWBBRK",156,0)
 . ;Logging
"RTN","XWBBRK",157,0)
 . I $G(XWBDEBUG)>1 D LOG^XWBDLOG("RPC: "_XWB(2,"CAPI"))
"RTN","XWBBRK",158,0)
 . D CAPI^XWBBRK2(.XWBP,XWB(2,"RTAG"),XWB(2,"RNAM"),S)
"RTN","XWBBRK",159,0)
 E  D CLRBUF ;p10
"RTN","XWBBRK",160,0)
 IF 'DEBUG K XWB
"RTN","XWBBRK",161,0)
 IF $D(XWBARY) K @XWBARY,XWBARY
"RTN","XWBBRK",162,0)
 Q
"RTN","XWBBRK",163,0)
 ;
"RTN","XWBBRK",164,0)
LINST(A,X,XWBY) ;instantiate local array
"RTN","XWBBRK",165,0)
 IF XWBY=$C(1) S XWBY=""
"RTN","XWBBRK",166,0)
 S X=A_"("_X_")"
"RTN","XWBBRK",167,0)
 S @X=XWBY
"RTN","XWBBRK",168,0)
 Q
"RTN","XWBBRK",169,0)
GINST ;instantiate global
"RTN","XWBBRK",170,0)
 N DONE,N,T,T1
"RTN","XWBBRK",171,0)
 S (DONE,I)=0
"RTN","XWBBRK",172,0)
 ;find piece with global ref - recover $C(44)
"RTN","XWBBRK",173,0)
 S REF=$TR(REF,$C(23),$C(44))
"RTN","XWBBRK",174,0)
 F  D  Q:DONE
"RTN","XWBBRK",175,0)
 . S N=$NA(^TMP("XWB",$J,$P($H,",",2)))
"RTN","XWBBRK",176,0)
 . S XWB("FRM")=REF
"RTN","XWBBRK",177,0)
 . S XWB("TO")=N
"RTN","XWBBRK",178,0)
 . IF '$D(@N) S DONE=1 Q
"RTN","XWBBRK",179,0)
 ;loop through all and instantiate
"RTN","XWBBRK",180,0)
 S DONE=0
"RTN","XWBBRK",181,0)
 F  D  Q:DONE
"RTN","XWBBRK",182,0)
 . S T=$E(@REF@(I),4,M)
"RTN","XWBBRK",183,0)
 . IF T="" S DONE=1 Q
"RTN","XWBBRK",184,0)
 . S @N@("XWB")="" ;set naked indicator
"RTN","XWBBRK",185,0)
 . S @T
"RTN","XWBBRK",186,0)
 . S I=I+1
"RTN","XWBBRK",187,0)
 K @N@("XWB")
"RTN","XWBBRK",188,0)
 Q
"RTN","XWBBRK",189,0)
 ;
"RTN","XWBBRK",190,0)
GETV(V) ;get value of V - reference parameter
"RTN","XWBBRK",191,0)
 N X
"RTN","XWBBRK",192,0)
 S X=V
"RTN","XWBBRK",193,0)
 IF $E(X,1,2)="$$" Q ""
"RTN","XWBBRK",194,0)
 IF $C(34,36)[$E(V) X "S V="_$$VCHK(V)
"RTN","XWBBRK",195,0)
 E  S V=@V
"RTN","XWBBRK",196,0)
 Q V
"RTN","XWBBRK",197,0)
 ;
"RTN","XWBBRK",198,0)
VCHK(S) ;Parse string for first argument
"RTN","XWBBRK",199,0)
 N C,I,P
"RTN","XWBBRK",200,0)
 F I=1:1 S C=$E(S,I) D VCHKP:C="(",VCHKQ:C=$C(34) Q:" ,"[C
"RTN","XWBBRK",201,0)
 Q $E(S,1,I-1)
"RTN","XWBBRK",202,0)
VCHKP S P=1 ;Find closing paren
"RTN","XWBBRK",203,0)
 F I=I+1:1 S C=$E(S,I) Q:P=0!(C="")  I "()"""[C D VCHKQ:C=$C(34) S P=P+$S("("[C:1,")"[C:-1,1:0)
"RTN","XWBBRK",204,0)
 Q
"RTN","XWBBRK",205,0)
VCHKQ ;Find closing quote
"RTN","XWBBRK",206,0)
 F I=I+1:1 S C=$E(S,I) Q:C=""!(C=$C(34))
"RTN","XWBBRK",207,0)
 Q
"RTN","XWBBRK",208,0)
CLRBUF ;p10  Empties Input buffer
"RTN","XWBBRK",209,0)
 N %
"RTN","XWBBRK",210,0)
 F  R %#1:XWBTIME(1) Q:%=""
"RTN","XWBBRK",211,0)
 Q
"RTN","XWBDLOG")
0^14^B6484698
"RTN","XWBDLOG",1,0)
XWBDLOG ;ISF/RWF - Debug Logging for Broker ;12/08/2004  08:54
"RTN","XWBDLOG",2,0)
 ;;1.1;RPC BROKER;**35**;Mar 28, 1997
"RTN","XWBDLOG",3,0)
 Q
"RTN","XWBDLOG",4,0)
 ;
"RTN","XWBDLOG",5,0)
 ;Setup the log, Clear the log location.
"RTN","XWBDLOG",6,0)
LOGSTART(RTN) ;Clear the debug log
"RTN","XWBDLOG",7,0)
 Q:'$G(XWBDEBUG)
"RTN","XWBDLOG",8,0)
 K ^XTMP("XWBLOG"_$J)
"RTN","XWBDLOG",9,0)
 S ^XTMP("XWBLOG"_$J,0)=$$HTFM^XLFDT($$HADD^XLFDT($H,7))_"^"_$$DT^XLFDT
"RTN","XWBDLOG",10,0)
 S ^XTMP("XWBLOG"_$J,.1)=0
"RTN","XWBDLOG",11,0)
 D LOG("Log start: "_$$HTE^XLFDT($H)),LOG(RTN)
"RTN","XWBDLOG",12,0)
 Q
"RTN","XWBDLOG",13,0)
LOG(MSG) ;Record Debug Info
"RTN","XWBDLOG",14,0)
 Q:'$G(XWBDEBUG)
"RTN","XWBDLOG",15,0)
 N CNT
"RTN","XWBDLOG",16,0)
 S CNT=1+$G(^XTMP("XWBLOG"_$J,.1)),^(.1)=CNT,^(CNT)=$E($H_"^"_MSG,1,255)
"RTN","XWBDLOG",17,0)
 Q
"RTN","XWBDLOG",18,0)
 ;
"RTN","XWBDLOG",19,0)
 ;
"RTN","XWBDLOG",20,0)
VIEW ;View log files
"RTN","XWBDLOG",21,0)
 N DIRUT,XWB,DIR,IX,X,CON
"RTN","XWBDLOG",22,0)
 D HOME^%ZIS
"RTN","XWBDLOG",23,0)
 W !,"Log Files"
"RTN","XWBDLOG",24,0)
 S XWB="XWBLOG",CON=""
"RTN","XWBDLOG",25,0)
 F  S XWB=$O(^XTMP(XWB)) Q:XWB'["XWBLOG"  D
"RTN","XWBDLOG",26,0)
 . D V1(.XWB)
"RTN","XWBDLOG",27,0)
 . I $$WAIT(.CON) S:CON=3 XWB="XWC"
"RTN","XWBDLOG",28,0)
 . Q
"RTN","XWBDLOG",29,0)
 Q
"RTN","XWBDLOG",30,0)
 ;
"RTN","XWBDLOG",31,0)
V1(XWB) ;View one log
"RTN","XWBDLOG",32,0)
 N IX,X,CNT
"RTN","XWBDLOG",33,0)
 S IX=.9,X=$G(^XTMP(XWB,IX)),CON=0,CNT=+$G(^XTMP(XWB,.1))
"RTN","XWBDLOG",34,0)
 Q:CNT<1
"RTN","XWBDLOG",35,0)
 W !!,"Log from Job ",$E(XWB,7,99)," ",CNT," Lines"
"RTN","XWBDLOG",36,0)
 F  S IX=$O(^XTMP(XWB,IX)) Q:'$L(IX)  S X=^XTMP(XWB,IX) D VL1(IX,X)
"RTN","XWBDLOG",37,0)
 Q
"RTN","XWBDLOG",38,0)
 ;
"RTN","XWBDLOG",39,0)
VL1(J,K) ;Write a line
"RTN","XWBDLOG",40,0)
 I $Y'<IOSL,$$WAIT(.CON) S IX="A" S:CON=3 XWB="XWC" Q
"RTN","XWBDLOG",41,0)
 Q:'$D(^XTMP(XWB,IX))
"RTN","XWBDLOG",42,0)
 N H,D,T,I
"RTN","XWBDLOG",43,0)
 S H=$P($$HTE^XLFDT($P(K,"^"),"2S"),"@",2)_" = "
"RTN","XWBDLOG",44,0)
 S D=$P(K,"^",2,99),K=D
"RTN","XWBDLOG",45,0)
 I D?.E1C.E D
"RTN","XWBDLOG",46,0)
 . S D=""
"RTN","XWBDLOG",47,0)
 . F I=1:1:$L(K) S T=$A(K,I),D=D_$S(T>31:$E(K,I),1:"\"_$E((1000+T),3,4))
"RTN","XWBDLOG",48,0)
 S T=$L(H)
"RTN","XWBDLOG",49,0)
 F  W !,H,?T,$E(D,1,68) S H="",D=$E(D,69,999) Q:'$L(D)
"RTN","XWBDLOG",50,0)
 Q
"RTN","XWBDLOG",51,0)
 ;
"RTN","XWBDLOG",52,0)
WAIT(CON) ;continue/kill/exit
"RTN","XWBDLOG",53,0)
 S DIR("?")="Enter RETURN to continue, Next for next log, Kill to remove log, Exit to quit log view."
"RTN","XWBDLOG",54,0)
 S DIR("A")="Return to continue, Next log, Exit: "
"RTN","XWBDLOG",55,0)
 S DIR(0)="SAB^1:Continue;2:Next;3:Exit;4:Kill",DIR("B")="Continue"
"RTN","XWBDLOG",56,0)
 D ^DIR
"RTN","XWBDLOG",57,0)
 S CON=+Y
"RTN","XWBDLOG",58,0)
 I Y=4 D K1(XWB,0) H 1
"RTN","XWBDLOG",59,0)
 I Y=1 W @IOF
"RTN","XWBDLOG",60,0)
 Q Y>1
"RTN","XWBDLOG",61,0)
 ;
"RTN","XWBDLOG",62,0)
K1(REF,S) ;Kill one
"RTN","XWBDLOG",63,0)
 I REF["XWBLOG" K ^XTMP(REF)
"RTN","XWBDLOG",64,0)
 I 'S W !,"Log "_REF_" deleted."
"RTN","XWBDLOG",65,0)
 Q
"RTN","XWBDLOG",66,0)
 ;
"RTN","XWBDLOG",67,0)
KILLALL ;KILL ALL LOG Entries
"RTN","XWBDLOG",68,0)
 N DIR,XWB
"RTN","XWBDLOG",69,0)
 S DIR(0)="Y",DIR("A")="Remove all XWB log entries",DIR("B")="No"
"RTN","XWBDLOG",70,0)
 D ^DIR Q:Y'=1
"RTN","XWBDLOG",71,0)
 S XWB="XWBLOG"
"RTN","XWBDLOG",72,0)
 F  S XWB=$O(^XTMP(XWB)) Q:XWB'["XWBLOG"  D K1(XWB,1)
"RTN","XWBDLOG",73,0)
 W !,"Done"
"RTN","XWBDLOG",74,0)
 Q
"RTN","XWBEXMPL")
0^11^B5787669
"RTN","XWBEXMPL",1,0)
XWBEXMPL ;ISC-SF/VYD - RPC BROKER EXAMPLE ;07/13/2004  15:03
"RTN","XWBEXMPL",2,0)
 ;;1.1;RPC BROKER;**22,35**;Mar 28, 1997
"RTN","XWBEXMPL",3,0)
ECHOSTR(RESULT,OSTRING) ;receive string and return it
"RTN","XWBEXMPL",4,0)
 S RESULT=OSTRING
"RTN","XWBEXMPL",5,0)
 Q
"RTN","XWBEXMPL",6,0)
 ;
"RTN","XWBEXMPL",7,0)
 ;
"RTN","XWBEXMPL",8,0)
GETLIST(RESULT,WHAT,QTY) ; -- return list
"RTN","XWBEXMPL",9,0)
 ;WHAT - LINES or KILOBYTES, QTY - number of lines of kilobytes
"RTN","XWBEXMPL",10,0)
 ;here the resulting list can get quite large - use global structure
"RTN","XWBEXMPL",11,0)
 N I,J,L,V                ;looping vars
"RTN","XWBEXMPL",12,0)
 S $P(L,"-+",128)=" "
"RTN","XWBEXMPL",13,0)
 K ^TMP($J,"XWB RESULTS") ;clean out temporary storage
"RTN","XWBEXMPL",14,0)
 I WHAT="LINES" D         ;lines requested
"RTN","XWBEXMPL",15,0)
 . F I=1:1:QTY D
"RTN","XWBEXMPL",16,0)
 . . S V="Line #"_I,V=V_$S(I'>$L(V):"",1:$E(L,1,$S(QTY+$L(V)>255:255-$L(V),1:QTY-$L(V))))
"RTN","XWBEXMPL",17,0)
 . . S ^TMP($J,"XWB RESULTS",I)=V
"RTN","XWBEXMPL",18,0)
 . . ;S ^TMP($J,"XWB RESULTS",I)="Line #"_I
"RTN","XWBEXMPL",19,0)
 ;
"RTN","XWBEXMPL",20,0)
 E  D                     ;kilobytes of data requested
"RTN","XWBEXMPL",21,0)
 . F I=1:1:QTY D
"RTN","XWBEXMPL",22,0)
 . . F J=1:1:64 D         ;64 lines * 16 chars = 1K
"RTN","XWBEXMPL",23,0)
 . . . S ^TMP($J,"XWB RESULTS",I*100+J)=$E(I_"-Kilobyte******",1,16)
"RTN","XWBEXMPL",24,0)
 ;
"RTN","XWBEXMPL",25,0)
 S RESULT=$NA(^TMP($J,"XWB RESULTS")) ;give Broker data root
"RTN","XWBEXMPL",26,0)
 Q
"RTN","XWBEXMPL",27,0)
 ;
"RTN","XWBEXMPL",28,0)
 ;
"RTN","XWBEXMPL",29,0)
WPTEXT(RESULT) ;return word processing text
"RTN","XWBEXMPL",30,0)
 N TEXT
"RTN","XWBEXMPL",31,0)
 ;use DBS call to get REMOTE PROCEDURE file description
"RTN","XWBEXMPL",32,0)
 D FILE^DID(8994,"","DESCRIPTION","TEXT")
"RTN","XWBEXMPL",33,0)
 M RESULT=TEXT("DESCRIPTION")
"RTN","XWBEXMPL",34,0)
 Q
"RTN","XWBEXMPL",35,0)
 ;
"RTN","XWBEXMPL",36,0)
 ;
"RTN","XWBEXMPL",37,0)
SORTNUM(RESULT,DIRCTN,ARRAY) ; -- sort numbers and return sorted
"RTN","XWBEXMPL",38,0)
 ;DIRCTN - direction to sort in HI or LO
"RTN","XWBEXMPL",39,0)
 ;ARRAY - array of numbers to sort
"RTN","XWBEXMPL",40,0)
 ;S $ECODE=",U411," Q
"RTN","XWBEXMPL",41,0)
 N I,J
"RTN","XWBEXMPL",42,0)
 IF DIRCTN="LO" D        ;sort LOW -> HIGH
"RTN","XWBEXMPL",43,0)
 . S I="" F  S I=$O(ARRAY(I)) Q:I=""  S J=ARRAY(I) D
"RTN","XWBEXMPL",44,0)
 . . S RESULT(J)=J
"RTN","XWBEXMPL",45,0)
 . . S JLIN=$G(JLIN)+1,^TMP("JLI",JLIN)=I_U_J
"RTN","XWBEXMPL",46,0)
 E  D                    ;sort HIGH -> LOW
"RTN","XWBEXMPL",47,0)
 . S I="" F  S I=$O(ARRAY(I)) Q:I=""  S J=ARRAY(I) D
"RTN","XWBEXMPL",48,0)
 . . S RESULT(99999999-J)=J
"RTN","XWBEXMPL",49,0)
 Q
"RTN","XWBEXMPL",50,0)
 ;
"RTN","XWBEXMPL",51,0)
GSORT(RESULT,DIRCTN,ROOT) ; -- Sort numbers in a global array
"RTN","XWBEXMPL",52,0)
 ;DIRCTN - direction to sort in HI or LO
"RTN","XWBEXMPL",53,0)
 ;ROOT - Closed Root of the Global array of numbers to sort 
"RTN","XWBEXMPL",54,0)
 ;Data is in ^TMP("XWB",$J,n)
"RTN","XWBEXMPL",55,0)
 N I,V K ^TMP($J)
"RTN","XWBEXMPL",56,0)
 IF DIRCTN="LO" D        ;sort LOW -> HIGH
"RTN","XWBEXMPL",57,0)
 . S I="" F  S I=$O(@ROOT@(I)) Q:I=""  D
"RTN","XWBEXMPL",58,0)
 . . S V=$G(@ROOT@(I)) I $L(V) S ^TMP($J,V)=V
"RTN","XWBEXMPL",59,0)
 E  D                    ;sort HIGH -> LOW
"RTN","XWBEXMPL",60,0)
 . S I="" F  S I=$O(@ROOT@(I)) Q:I=""  D
"RTN","XWBEXMPL",61,0)
 . . S V=$G(@ROOT@(I)) I $L(V) S ^TMP($J,99999999-V)=V
"RTN","XWBEXMPL",62,0)
 S RESULT=$NA(^TMP($J))
"RTN","XWBEXMPL",63,0)
 M ^RWF($J)=@ROOT
"RTN","XWBEXMPL",64,0)
 Q
"RTN","XWBEXMPL",65,0)
 ;
"RTN","XWBEXMPL",66,0)
BIGTXT(RESULT,ARRAY) ;-- Accept a big text block.
"RTN","XWBEXMPL",67,0)
 ;Return count. char^lines
"RTN","XWBEXMPL",68,0)
 N CC,LC,I
"RTN","XWBEXMPL",69,0)
 S CC=0,LC=0,I=""
"RTN","XWBEXMPL",70,0)
 F  S I=$O(ARRAY(I)) Q:I=""  S LC=LC+1,CC=CC+$L(ARRAY(I))
"RTN","XWBEXMPL",71,0)
 K ^TMP($J) M ^TMP($J)=ARRAY
"RTN","XWBEXMPL",72,0)
 S RESULT=CC_"^"_LC
"RTN","XWBEXMPL",73,0)
 Q
"RTN","XWBLIB")
0^7^B10132147
"RTN","XWBLIB",1,0)
XWBLIB ;SFISC/VYD - Various remote procedure library ;06/16/2004  17:53
"RTN","XWBLIB",2,0)
 ;;1.1;RPC BROKER;**6,10,26,35**;Mar 28, 1997
"RTN","XWBLIB",3,0)
 Q
"RTN","XWBLIB",4,0)
 ;
"RTN","XWBLIB",5,0)
BROKER() ;EF. Running under the Broker or Vlink
"RTN","XWBLIB",6,0)
 Q $D(XWBOS)!$D(XOBDATA)
"RTN","XWBLIB",7,0)
 ;
"RTN","XWBLIB",8,0)
RTRNFMT(X,WRAP) ;EF. set the RPC return type and wrap flag
"RTN","XWBLIB",9,0)
 N Y
"RTN","XWBLIB",10,0)
 S:$D(WRAP) XWBWRAP=+WRAP
"RTN","XWBLIB",11,0)
 S X=$G(X)
"RTN","XWBLIB",12,0)
 IF X=+X,X>0,X<6 S XWBPTYPE=X Q X
"RTN","XWBLIB",13,0)
 S X=$$UP^XLFSTR(X)
"RTN","XWBLIB",14,0)
 S X=$S(X="SINGLE VALUE":1,X="ARRAY":2,X="WORD PROCESSING":3,X="GLOBAL ARRAY":4,X="GLOBAL INSTANCE":5,1:0)
"RTN","XWBLIB",15,0)
 IF X=0 Q 0
"RTN","XWBLIB",16,0)
 S XWBPTYPE=X
"RTN","XWBLIB",17,0)
 Q X
"RTN","XWBLIB",18,0)
 ;
"RTN","XWBLIB",19,0)
VARVAL(RESULT,VARIABLE) ;returns value of passed in variable
"RTN","XWBLIB",20,0)
 S RESULT=VARIABLE ;can do this with the REFERENCE type parameter
"RTN","XWBLIB",21,0)
 Q
"RTN","XWBLIB",22,0)
 ;See GETV^XWBBRK for how we get the REFERENCE type parameter
"RTN","XWBLIB",23,0)
 ;
"RTN","XWBLIB",24,0)
IMHERE(RESULT) ;P6
"RTN","XWBLIB",25,0)
 ;Entry point for XWB IM HERE remote procedure
"RTN","XWBLIB",26,0)
 S RESULT=1
"RTN","XWBLIB",27,0)
 Q
"RTN","XWBLIB",28,0)
 ;
"RTN","XWBLIB",29,0)
BRKRINFO(RESULT) ;P6
"RTN","XWBLIB",30,0)
 ;Entry point for XWB GET BROKER INFO RPC.
"RTN","XWBLIB",31,0)
 ;R(0) = Length of handler read timeout
"RTN","XWBLIB",32,0)
 S RESULT(0)=$$BAT^XUPARAM
"RTN","XWBLIB",33,0)
 Q
"RTN","XWBLIB",34,0)
 ;
"RTN","XWBLIB",35,0)
CKRPC(RESULT,RPCNAME,RPCUSE,VERNUM) ;P10
"RTN","XWBLIB",36,0)
 ;Entry point for "XWB IS RPC AVIALABLE" RPC.
"RTN","XWBLIB",37,0)
 ;RPCUSE("L" or "R") and VERNUM are optional.
"RTN","XWBLIB",38,0)
 ;Checks if RPC exists and if INACTIVE flag is set for specified use.
"RTN","XWBLIB",39,0)
 ;Also checks version number if passed.
"RTN","XWBLIB",40,0)
 ;Result = 1 for can be run; 0 for can't be run.
"RTN","XWBLIB",41,0)
 N RPCIEN
"RTN","XWBLIB",42,0)
 S RESULT=0
"RTN","XWBLIB",43,0)
 S RPCIEN=$$RPCIEN($G(RPCNAME))
"RTN","XWBLIB",44,0)
 I RPCIEN,$$RPCAVAIL(RPCIEN,$G(RPCUSE),$G(VERNUM)) S RESULT=1
"RTN","XWBLIB",45,0)
 Q
"RTN","XWBLIB",46,0)
 ;
"RTN","XWBLIB",47,0)
CKRPCS(RESULT,RPCUSE,RPC) ;P10
"RTN","XWBLIB",48,0)
 ;Entry point for "XWB ARE RPCS AVIALABLE" RPC.
"RTN","XWBLIB",49,0)
 ;RPCUSE("L" or "R") and VERNUM are optional.
"RTN","XWBLIB",50,0)
 ;RPC() array has format RPCName^RPCVersionNumber.
"RTN","XWBLIB",51,0)
 ;Checks if RPC exists and version number (if not null).
"RTN","XWBLIB",52,0)
 ;Check INACTIVE flag if set for specified use.
"RTN","XWBLIB",53,0)
 ;Result(I) = 1 for can be run; 0 for can't be run.
"RTN","XWBLIB",54,0)
 N I
"RTN","XWBLIB",55,0)
 S I=""
"RTN","XWBLIB",56,0)
 F  S I=$O(RPC(I)) Q:I=""  D
"RTN","XWBLIB",57,0)
 . N RPCNAME,VERNUM,RPCIEN
"RTN","XWBLIB",58,0)
 . S RESULT(I)=0
"RTN","XWBLIB",59,0)
 . S RPCNAME=$P(RPC(I),U)
"RTN","XWBLIB",60,0)
 . S VERNUM=$P(RPC(I),U,2)
"RTN","XWBLIB",61,0)
 . S RPCIEN=$$RPCIEN($G(RPCNAME))
"RTN","XWBLIB",62,0)
 . I RPCIEN,$$RPCAVAIL(RPCIEN,$G(RPCUSE),$G(VERNUM)) S RESULT(I)=1
"RTN","XWBLIB",63,0)
 Q
"RTN","XWBLIB",64,0)
 ;
"RTN","XWBLIB",65,0)
RPCIEN(RPCNAME) ;P10
"RTN","XWBLIB",66,0)
 ;Function that returns IEN of RPC based on name.
"RTN","XWBLIB",67,0)
 ;Returns 0 if RPC does not exist.
"RTN","XWBLIB",68,0)
 I RPCNAME="" Q 0
"RTN","XWBLIB",69,0)
 Q +$O(^XWB(8994,"B",RPCNAME,0))
"RTN","XWBLIB",70,0)
 ;
"RTN","XWBLIB",71,0)
RPCAVAIL(RPCIEN,RPCUSE,VERNUM) ;P10
"RTN","XWBLIB",72,0)
 ;Boolean function, identifies if RPC is active and correct version.
"RTN","XWBLIB",73,0)
 ;RPCUSE (optional) = L check local use; R check remote use.
"RTN","XWBLIB",74,0)
 ;VERNUM (optional) only checked for remote RPCs.
"RTN","XWBLIB",75,0)
 N RPC0,INACT
"RTN","XWBLIB",76,0)
 S RPC0=$G(^XWB(8994,+RPCIEN,0))
"RTN","XWBLIB",77,0)
 Q:RPC0="" 0
"RTN","XWBLIB",78,0)
 S INACT=+$P(RPC0,U,6)
"RTN","XWBLIB",79,0)
 I INACT=1 Q 0 ;RPC marked inactive.
"RTN","XWBLIB",80,0)
 S RPCUSE=$G(RPCUSE)
"RTN","XWBLIB",81,0)
 I RPCUSE="" Q 1 ;Local and remote check not needed.
"RTN","XWBLIB",82,0)
 I RPCUSE="L",INACT=2 Q 0 ;Local use, RPC is remote only.
"RTN","XWBLIB",83,0)
 I RPCUSE="R",INACT=3 Q 0 ;Remote use, RPC is local only.
"RTN","XWBLIB",84,0)
 I RPCUSE="R",+$G(VERNUM),'$$CKVERNUM(VERNUM,+$P(RPC0,U,9)) Q 0 ;Failed version # check.
"RTN","XWBLIB",85,0)
 Q 1 ;Must be ok.
"RTN","XWBLIB",86,0)
 ;
"RTN","XWBLIB",87,0)
CKVERNUM(VERNUM,RPCVER,RPCIEN) ;P10
"RTN","XWBLIB",88,0)
 ;Boolean function. Returns 1 if RPC verion is > or = version number to be checked.
"RTN","XWBLIB",89,0)
 ;VERNUM = version number passed in (i.e., from client ap) to be checked.
"RTN","XWBLIB",90,0)
 ;RPCVER = version number in Remote Procedure file. (optional)
"RTN","XWBLIB",91,0)
 ;RPCIEN of RPC being checked. Needed if RPCVER not sent.
"RTN","XWBLIB",92,0)
 I +$G(RPCIEN),'+$G(RPCVER) S RPCVER=$P($G(^XWB(8994,RPCIEN,0)),U,9)
"RTN","XWBLIB",93,0)
 I +RPCVER<+VERNUM Q 0
"RTN","XWBLIB",94,0)
 Q 1
"RTN","XWBLIB",95,0)
 ;
"RTN","XWBLIB",96,0)
VARLST ;;XWB,XWBAPVER,XWBCLMAN,XWBNULL,XWBODEV,XWBOS,XWBP,XWBPTYPE,XWBR,XWBSEC,XWBSTATE,XWBTBUF,XWBTDEV,XWBTIME,XWBTIP,XWBTOS,XWBTSKT,XWBVER,XWBWRAP,XWBY,DEBUG,XWBSHARE,XWBDEBUG,XWBT
"RTN","XWBLIB",97,0)
 ;P10.  Variable for exclusive NEW in KILL^XUSCLEAN
"RTN","XWBLIB",98,0)
 ;P26.  Added XWBSHARE
"RTN","XWBLIB",99,0)
 ;P35.  Added XWBDEBUG,XWBT
"RTN","XWBPRS")
0^2^B38481438
"RTN","XWBPRS",1,0)
XWBPRS ;ISF/STAFF - VISTA BROKER MSG PARSER ;12/08/2004  13:52
"RTN","XWBPRS",2,0)
 ;;1.1;RPC BROKER;**35**;Mar 28, 1997
"RTN","XWBPRS",3,0)
 ;XWB holds info from the message used by the RPC
"RTN","XWBPRS",4,0)
CALLP(XWBP,XWBDEBUG) ;make API call using Protocol string
"RTN","XWBPRS",5,0)
 N ERR,S,XWBARY K XWB
"RTN","XWBPRS",6,0)
 S ERR=0
"RTN","XWBPRS",7,0)
 S ERR=$$PRSP("[XWB]") ;Read the rest of the protocol header
"RTN","XWBPRS",8,0)
 I '+ERR S ERR=$$PRSM ;Read and parse message
"RTN","XWBPRS",9,0)
 I $G(XWB(2,"RPC"))="XUS SET SHARED" S XWBSHARE=1 Q
"RTN","XWBPRS",10,0)
 I '+ERR S ERR=$$RPC ;Check the RPC
"RTN","XWBPRS",11,0)
 I +ERR S XWBSEC=$P(ERR,U,2) ;P10 -- dpc
"RTN","XWBPRS",12,0)
 I '+ERR D CHKPRMIT^XWBSEC($G(XWB(2,"RPC"))) ;checks if RPC allowed to run
"RTN","XWBPRS",13,0)
 S:$L($G(XWBSEC)) ERR="-1^"_XWBSEC
"RTN","XWBPRS",14,0)
 I '+ERR D
"RTN","XWBPRS",15,0)
 . D CAPI(.XWBP,XWB("PARAM"))
"RTN","XWBPRS",16,0)
 E  I ($G(XWBTCMD)'="#BYE#") D LOG^XWBTCPM("Bad Msg"_ERR),CLRBUF
"RTN","XWBPRS",17,0)
 I 'XWBDEBUG K XWB
"RTN","XWBPRS",18,0)
 I $D(XWBARY) K @XWBARY,XWBARY
"RTN","XWBPRS",19,0)
 Q
"RTN","XWBPRS",20,0)
 ;
"RTN","XWBPRS",21,0)
PRSP(P) ;ef, Parse Protocol
"RTN","XWBPRS",22,0)
 ;M Extrinsic Function
"RTN","XWBPRS",23,0)
 ;Outputs
"RTN","XWBPRS",24,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBPRS",25,0)
 ;
"RTN","XWBPRS",26,0)
 N ERR,C,M,R,X
"RTN","XWBPRS",27,0)
 S R=0,C=";",ERR=0
"RTN","XWBPRS",28,0)
 S P=$$BREAD^XWBRW(4)
"RTN","XWBPRS",29,0)
 IF $L(P)'=4 S ERR="-1^Short Header info"
"RTN","XWBPRS",30,0)
 IF +ERR=0 D
"RTN","XWBPRS",31,0)
 . S XWB(R,"VER")=+$E(P,1)
"RTN","XWBPRS",32,0)
 . S XWB(R,"TYPE")=+$E(P,2)
"RTN","XWBPRS",33,0)
 . S (XWBENVL,XWB(R,"LENV"))=+$E(P,3)
"RTN","XWBPRS",34,0)
 . S (XWBPRT,XWB(R,"RT"))=+$E(P,4)
"RTN","XWBPRS",35,0)
 I XWBENVL<1 S (XWBENVL,XWB(R,"LENV"))=3
"RTN","XWBPRS",36,0)
 Q ERR
"RTN","XWBPRS",37,0)
 ;
"RTN","XWBPRS",38,0)
PRSM() ;ef, Parse message
"RTN","XWBPRS",39,0)
 ;M Extrinsic Function
"RTN","XWBPRS",40,0)
 ;See document on msg format
"RTN","XWBPRS",41,0)
 ;Outputs
"RTN","XWBPRS",42,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBPRS",43,0)
 N C,EX1,ERR,R,X,CNK
"RTN","XWBPRS",44,0)
 S R=1,C=";",CNK=0,EX1=0 ;Max buffer
"RTN","XWBPRS",45,0)
 S ERR="-1^Invalid Chunk"
"RTN","XWBPRS",46,0)
 F  S CNK=$$BREAD^XWBRW(1) Q:("12345"'[CNK)  D  Q:EX1
"RTN","XWBPRS",47,0)
 . S EX1=(CNK=5),@("ERR=$$PRS"_CNK)
"RTN","XWBPRS",48,0)
 Q ERR
"RTN","XWBPRS",49,0)
 ;
"RTN","XWBPRS",50,0)
PRS1() ;Parse the HEADER chunk
"RTN","XWBPRS",51,0)
 N %,L,R
"RTN","XWBPRS",52,0)
 S R=1
"RTN","XWBPRS",53,0)
 S XWB(R,"VER")=$$SREAD
"RTN","XWBPRS",54,0)
 S XWB(R,"RETURN")=$$SREAD
"RTN","XWBPRS",55,0)
 Q 0
"RTN","XWBPRS",56,0)
 ;
"RTN","XWBPRS",57,0)
PRS2() ;Parse the RPC chunk
"RTN","XWBPRS",58,0)
 N L,R
"RTN","XWBPRS",59,0)
 S R=2
"RTN","XWBPRS",60,0)
 S (XWBAPVER,XWB(R,"VER"))=$$SREAD ;RPC version
"RTN","XWBPRS",61,0)
 S XWB(R,"RPC")=$$SREAD
"RTN","XWBPRS",62,0)
 I $G(XWBDEBUG)>1 D LOG^XWBTCPM("RPC: "_XWB(R,"RPC"))
"RTN","XWBPRS",63,0)
 Q 0
"RTN","XWBPRS",64,0)
PRS3() ;Parse the Security chunk
"RTN","XWBPRS",65,0)
 N L,R
"RTN","XWBPRS",66,0)
 S R=3
"RTN","XWBPRS",67,0)
 Q 0
"RTN","XWBPRS",68,0)
PRS4() ;Parse the Command chunk
"RTN","XWBPRS",69,0)
 N R
"RTN","XWBPRS",70,0)
 S R=4,XWBTCMD=$$SREAD,XWB(R,"CMD")=XWBTCMD
"RTN","XWBPRS",71,0)
 I $G(XWBDEBUG)>1 D LOG^XWBTCPM("CMD: "_XWBTCMD)
"RTN","XWBPRS",72,0)
 Q ("TCPConnect^#BYE#"[XWBTCMD)
"RTN","XWBPRS",73,0)
 ;
"RTN","XWBPRS",74,0)
PRS5() ;Parse Data Parameter chunk
"RTN","XWBPRS",75,0)
 ;M Extrinsic Function
"RTN","XWBPRS",76,0)
 ;Outputs
"RTN","XWBPRS",77,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBPRS",78,0)
 ;
"RTN","XWBPRS",79,0)
 N CONT,DONE,ERR,F,FL,IX,K,L,P1,P2,P3,P4,P5,MAXP,R,TY,VA
"RTN","XWBPRS",80,0)
 S R=5,ERR=0,F=3,IX=0,DONE=0,CONT="f",XWB("PARAM")=""
"RTN","XWBPRS",81,0)
 F  S:CONT="f" TY=$$BREAD^XWBRW(1) D  Q:DONE  S CONT=$$BREAD^XWBRW(1) S:CONT'="t" IX=IX+1
"RTN","XWBPRS",82,0)
 . K VA,P1
"RTN","XWBPRS",83,0)
 . IF TY=$C(4) S DONE=1 Q  ;EOT
"RTN","XWBPRS",84,0)
 . IF TY=0 D  Q  ;literal
"RTN","XWBPRS",85,0)
 . . D LREAD("VA")
"RTN","XWBPRS",86,0)
 . . S XWB(R,"P",IX)=VA(1) D PARAM($NA(XWB(R,"P",IX)))
"RTN","XWBPRS",87,0)
 . . Q
"RTN","XWBPRS",88,0)
 . IF TY=1 D  Q  ;reference
"RTN","XWBPRS",89,0)
 . . D LREAD("VA")
"RTN","XWBPRS",90,0)
 . . S XWB(R,"P",IX)=$$GETV(VA(1)) D PARAM($NA(XWB(R,"P",IX)))
"RTN","XWBPRS",91,0)
 . . Q
"RTN","XWBPRS",92,0)
 . IF TY=2 D  Q  ;list
"RTN","XWBPRS",93,0)
 . . I CONT'="t" D
"RTN","XWBPRS",94,0)
 . . . S XWBARY=$$OARY,XWB(R,"P",IX)="."_XWBARY
"RTN","XWBPRS",95,0)
 . . . D PARAM(XWB(R,"P",IX))
"RTN","XWBPRS",96,0)
 . . D LREAD("P1") Q:P1(1)=""  D LREAD("VA")
"RTN","XWBPRS",97,0)
 . . D LINST(XWBARY,P1(1),VA(1))
"RTN","XWBPRS",98,0)
 . . Q
"RTN","XWBPRS",99,0)
 . IF TY=3 D  Q  ;global
"RTN","XWBPRS",100,0)
 . . I CONT'="t" D
"RTN","XWBPRS",101,0)
 . . . S XWBARY=$NA(^TMP("XWBA",$J,IX)),XWB(R,"P",IX)=XWBARY
"RTN","XWBPRS",102,0)
 . . . K @XWBARY S @XWBARY=""
"RTN","XWBPRS",103,0)
 . . . D PARAM(XWBARY)
"RTN","XWBPRS",104,0)
 . . D LREAD("P1") Q:P1(1)=""  D LREAD("VA")
"RTN","XWBPRS",105,0)
 . . D GINST(XWBARY,P1(1),VA(1))
"RTN","XWBPRS",106,0)
 . . Q
"RTN","XWBPRS",107,0)
 . IF TY=4 D  Q  ;empty - ,,
"RTN","XWBPRS",108,0)
 . . S XWB(R,"XWB",IX)=""
"RTN","XWBPRS",109,0)
 . . Q
"RTN","XWBPRS",110,0)
 . IF TY=5 D  Q
"RTN","XWBPRS",111,0)
 . . ;stream still to be done
"RTN","XWBPRS",112,0)
 . Q  ;End of loop
"RTN","XWBPRS",113,0)
 Q ERR
"RTN","XWBPRS",114,0)
PARAM(NA) ;Add a new parameter to the list
"RTN","XWBPRS",115,0)
 N A
"RTN","XWBPRS",116,0)
 S A=$G(XWB("PARAM")) S:'$L(NA) NA="""""" ;Empty
"RTN","XWBPRS",117,0)
 S A=A_$S($L(A):",",1:"")_$S(TY=3:"$NA(",1:"")_NA_$S(TY=3:")",1:"")
"RTN","XWBPRS",118,0)
 S XWB("PARAM")=A
"RTN","XWBPRS",119,0)
 Q
"RTN","XWBPRS",120,0)
 ;
"RTN","XWBPRS",121,0)
RPC() ;Check the rpc information.
"RTN","XWBPRS",122,0)
 ;M Extrinsic Function
"RTN","XWBPRS",123,0)
 ;Outputs
"RTN","XWBPRS",124,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBPRS",125,0)
 ;
"RTN","XWBPRS",126,0)
 N C,DR,ERR,M,R,RPC,T,X
"RTN","XWBPRS",127,0)
 S R=2,C=";",ERR=0,M=512 ;Max buffer
"RTN","XWBPRS",128,0)
 S RPC=$G(XWB(R,"RPC")) I '$L(RPC) Q "-1^No RPC sent"
"RTN","XWBPRS",129,0)
 S T=$O(^XWB(8994,"B",RPC,0))
"RTN","XWBPRS",130,0)
 I '+T Q "-1^Remote Procedure '"_RPC_"' doesn't exist on the server."
"RTN","XWBPRS",131,0)
 S T(0)=$G(^XWB(8994,T,0))
"RTN","XWBPRS",132,0)
 I $P(T(0),U,6)=1!($P(T(0),U,6)=2) Q "-1^Remote Procedure '"_RPC_"' cannot be run at this time."  ;P10. Check INACTIVE field. - dpc.
"RTN","XWBPRS",133,0)
 S XWB(R,"RTAG")=$P(T(0),"^",2)
"RTN","XWBPRS",134,0)
 S XWB(R,"RNAM")=$P(T(0),"^",3)
"RTN","XWBPRS",135,0)
 S XWBPTYPE=$P(T(0),"^",4)
"RTN","XWBPRS",136,0)
 S XWBWRAP=+$P(T(0),"^",8)
"RTN","XWBPRS",137,0)
 Q ERR
"RTN","XWBPRS",138,0)
 ;
"RTN","XWBPRS",139,0)
SREAD() ;Read a S_PACK
"RTN","XWBPRS",140,0)
 N L,V7
"RTN","XWBPRS",141,0)
 S L=$$BREAD^XWBRW(1),L=$A(L)
"RTN","XWBPRS",142,0)
 S V7=$$BREAD^XWBRW(L)
"RTN","XWBPRS",143,0)
 Q V7
"RTN","XWBPRS",144,0)
LREAD(ROOT) ;Read a L_PACK
"RTN","XWBPRS",145,0)
 N L,TL,V7,I,MAX
"RTN","XWBPRS",146,0)
 S I=1,MAX=256,@ROOT@(I)=""
"RTN","XWBPRS",147,0)
 S L=$$BREAD^XWBRW(XWBENVL),(TL,L)=+L
"RTN","XWBPRS",148,0)
 I L>MAX F  S V7=$$BREAD^XWBRW(MAX),L=L-$L(V7),@ROOT@(I)=V7,I=I+1 Q:(L'>MAX)
"RTN","XWBPRS",149,0)
 I L>0 S V7=$$BREAD^XWBRW(L),@ROOT@(I)=V7,I=I+1
"RTN","XWBPRS",150,0)
 Q
"RTN","XWBPRS",151,0)
 ;
"RTN","XWBPRS",152,0)
 ;X can be something like '"TEXT",1,0'.
"RTN","XWBPRS",153,0)
LINST(A,X,XWBY) ;instantiate local array
"RTN","XWBPRS",154,0)
 IF XWBY=$C(1) S XWBY=""
"RTN","XWBPRS",155,0)
 S X=A_"("_X_")"
"RTN","XWBPRS",156,0)
 S @X=XWBY
"RTN","XWBPRS",157,0)
 Q
"RTN","XWBPRS",158,0)
 ;
"RTN","XWBPRS",159,0)
 ;S can be something like '"TEXT",1,0'.
"RTN","XWBPRS",160,0)
GINST(R,S,V) ;instantiate global
"RTN","XWBPRS",161,0)
 N N
"RTN","XWBPRS",162,0)
 I V=$C(1) S V=""
"RTN","XWBPRS",163,0)
 S N=$P(R,")")_","_S_")"
"RTN","XWBPRS",164,0)
 S @N=V
"RTN","XWBPRS",165,0)
 Q
"RTN","XWBPRS",166,0)
 ;
"RTN","XWBPRS",167,0)
GETV(V) ;get value of V - reference parameter
"RTN","XWBPRS",168,0)
 N X
"RTN","XWBPRS",169,0)
 S X=V
"RTN","XWBPRS",170,0)
 IF $E(X,1,2)="$$" Q ""
"RTN","XWBPRS",171,0)
 IF $C(34,36)[$E(V) X "S V="_$$VCHK(V)
"RTN","XWBPRS",172,0)
 E  S V=@V
"RTN","XWBPRS",173,0)
 Q V
"RTN","XWBPRS",174,0)
 ;
"RTN","XWBPRS",175,0)
VCHK(S) ;Parse string for first argument
"RTN","XWBPRS",176,0)
 N C,I,P
"RTN","XWBPRS",177,0)
 F I=1:1 S C=$E(S,I) D VCHKP:C="(",VCHKQ:C=$C(34) Q:" ,"[C
"RTN","XWBPRS",178,0)
 Q $E(S,1,I-1)
"RTN","XWBPRS",179,0)
VCHKP S P=1 ;Find closing paren
"RTN","XWBPRS",180,0)
 F I=I+1:1 S C=$E(S,I) Q:P=0!(C="")  I "()"""[C D VCHKQ:C=$C(34) S P=P+$S("("[C:1,")"[C:-1,1:0)
"RTN","XWBPRS",181,0)
 Q
"RTN","XWBPRS",182,0)
VCHKQ ;Find closing quote
"RTN","XWBPRS",183,0)
 F I=I+1:1 S C=$E(S,I) Q:C=""!(C=$C(34))
"RTN","XWBPRS",184,0)
 Q
"RTN","XWBPRS",185,0)
CLRBUF ;Empties Input buffer
"RTN","XWBPRS",186,0)
 N %
"RTN","XWBPRS",187,0)
 F  R *%:2 Q:'$T!(%=4)  ;!(%=-1)
"RTN","XWBPRS",188,0)
 Q
"RTN","XWBPRS",189,0)
ZZZ(X) ;Convert
"RTN","XWBPRS",190,0)
 N I
"RTN","XWBPRS",191,0)
 F  S I=$F(X,"$C(") Q:'I  S J=$F(X,")",I),X=$E(X,1,I-4)_$C($E(X,I,J-2))_$E(X,J,999)
"RTN","XWBPRS",192,0)
 Q X
"RTN","XWBPRS",193,0)
 ;
"RTN","XWBPRS",194,0)
CAPI(XWBY,PAR) ;make API call
"RTN","XWBPRS",195,0)
 N XWBCALL,T,DX,DY
"RTN","XWBPRS",196,0)
 S XWBCALL=XWB(2,"RTAG")_"^"_XWB(2,"RNAM")_"(.XWBY"_$S($L(PAR):","_PAR,1:"")_")",XWBCALL2=""
"RTN","XWBPRS",197,0)
 K PAR
"RTN","XWBPRS",198,0)
 U XWBNULL
"RTN","XWBPRS",199,0)
 ;
"RTN","XWBPRS",200,0)
 I $G(XWBDEBUG)>2 D LOG^XWBDLOG("Call: "_$E(XWBCALL,1,247))
"RTN","XWBPRS",201,0)
 ;start RUM for RPC
"RTN","XWBPRS",202,0)
 I $G(XWB(2,"CAPI"))]"" D LOGRSRC^%ZOSV(XWB(2,"CAPI"),2,1)
"RTN","XWBPRS",203,0)
 ;
"RTN","XWBPRS",204,0)
 D @XWBCALL S XWBCALL2=XWBCALL ;Save call for debug
"RTN","XWBPRS",205,0)
 ;
"RTN","XWBPRS",206,0)
 ;restart RUM for handler
"RTN","XWBPRS",207,0)
 D LOGRSRC^%ZOSV("$BROKER HANDLER$",2,1)
"RTN","XWBPRS",208,0)
 ;
"RTN","XWBPRS",209,0)
 U XWBTDEV
"RTN","XWBPRS",210,0)
 Q
"RTN","XWBPRS",211,0)
 ;
"RTN","XWBPRS",212,0)
OARY() ;create storage array
"RTN","XWBPRS",213,0)
 N A,DONE,I
"RTN","XWBPRS",214,0)
 S I=1+$G(XWB("ARRAY")),XWB("ARRAY")=I
"RTN","XWBPRS",215,0)
 S A="XWBS"_I
"RTN","XWBPRS",216,0)
 K @A ;temp fix for single array
"RTN","XWBPRS",217,0)
 S @A="" ;set naked
"RTN","XWBPRS",218,0)
 Q A
"RTN","XWBPRS",219,0)
 ;
"RTN","XWBPRS",220,0)
CREF(R,P) ;Convert array contained in P to reference A
"RTN","XWBPRS",221,0)
 N I,X,DONE,F1,S
"RTN","XWBPRS",222,0)
 S DONE=0
"RTN","XWBPRS",223,0)
 S S=""
"RTN","XWBPRS",224,0)
 F I=1:1  D  Q:DONE
"RTN","XWBPRS",225,0)
 . IF $P(P,",",I)="" S DONE=1 Q
"RTN","XWBPRS",226,0)
 . S X(I)=$P(P,",",I)
"RTN","XWBPRS",227,0)
 . IF X(I)?1"."1A.E D
"RTN","XWBPRS",228,0)
 . . S F1=$F(X(I),".")
"RTN","XWBPRS",229,0)
 . . S X(I)="."_R
"RTN","XWBPRS",230,0)
 . S S=S_X(I)_","
"RTN","XWBPRS",231,0)
 Q $E(S,1,$L(S)-1)
"RTN","XWBPRS",232,0)
 ;
"RTN","XWBRW")
0^13^B8441815
"RTN","XWBRW",1,0)
XWBRW ;ISF/RWF - Read/Write for Broker TCP ;08/03/2004  15:09
"RTN","XWBRW",2,0)
 ;;1.1;RPC BROKER;**35**;Mar 28, 1997
"RTN","XWBRW",3,0)
 Q
"RTN","XWBRW",4,0)
 ;
"RTN","XWBRW",5,0)
 ;XWBRBUF is global
"RTN","XWBRW",6,0)
 ;SE is a flag to skip error for short read. From PRSB+41^XWBBRK
"RTN","XWBRW",7,0)
BREAD(L,TO,SE) ;read tcp buffer, L is length, TO is timeout
"RTN","XWBRW",8,0)
 N R,S,DONE,C
"RTN","XWBRW",9,0)
 I L'>0 Q ""
"RTN","XWBRW",10,0)
 I $L(XWBRBUF)'<L S R=$E(XWBRBUF,1,L),XWBRBUF=$E(XWBRBUF,L+1,999999) Q R
"RTN","XWBRW",11,0)
 S R="",DONE=0,L=+L,C=0
"RTN","XWBRW",12,0)
 S TO=$S($G(TO)>0:TO,$G(XWBTIME(1))>0:XWBTIME(1),1:60)/2+1
"RTN","XWBRW",13,0)
 U XWBTDEV
"RTN","XWBRW",14,0)
 F  D  Q:DONE
"RTN","XWBRW",15,0)
 . S S=L-$L(R),R=R_$E(XWBRBUF,1,S),XWBRBUF=$E(XWBRBUF,S+1,999999)
"RTN","XWBRW",16,0)
 . I ($L(R)=L)!(R[$C(4))!(C>TO) S DONE=1 Q
"RTN","XWBRW",17,0)
 . R XWBRBUF:2 S:'$T C=C+1 S:$L(XWBRBUF) C=0
"RTN","XWBRW",18,0)
 . I $G(XWBDEBUG)>2,$L(XWBRBUF) D LOG^XWBDLOG("rd: "_$E(XWBRBUF,1,252))
"RTN","XWBRW",19,0)
 . Q
"RTN","XWBRW",20,0)
 I $L(R)<L,'$G(SE) S $ECODE=",U411," ;Throw Error, Did not read full length
"RTN","XWBRW",21,0)
 Q R
"RTN","XWBRW",22,0)
 ;
"RTN","XWBRW",23,0)
QSND(XWBR) ;Quick send
"RTN","XWBRW",24,0)
 S XWBPTYPE=1,XWBERROR="",XWBSEC="" D SND
"RTN","XWBRW",25,0)
 Q
"RTN","XWBRW",26,0)
 ;
"RTN","XWBRW",27,0)
ESND(XWBR) ;Send from ETRAP
"RTN","XWBRW",28,0)
 S XWBPTYPE=1 D SND
"RTN","XWBRW",29,0)
 Q
"RTN","XWBRW",30,0)
 ;
"RTN","XWBRW",31,0)
SND ; Send a responce
"RTN","XWBRW",32,0)
 N XWBSBUF S XWBSBUF=""
"RTN","XWBRW",33,0)
 U XWBTDEV
"RTN","XWBRW",34,0)
 ;
"RTN","XWBRW",35,0)
 D SNDERR ;Send any error info
"RTN","XWBRW",36,0)
 D SNDDATA ;Send the data
"RTN","XWBRW",37,0)
 ;D WRITE($C(4)) ;EOT
"RTN","XWBRW",38,0)
 D WRITE($C(4)),WBF
"RTN","XWBRW",39,0)
 Q
"RTN","XWBRW",40,0)
 ;
"RTN","XWBRW",41,0)
SNDDATA ;Send the data part
"RTN","XWBRW",42,0)
 N I,D
"RTN","XWBRW",43,0)
 ; -- single value
"RTN","XWBRW",44,0)
 I XWBPTYPE=1 D WRITE($G(XWBR)) Q
"RTN","XWBRW",45,0)
 ; -- table delimited by CR+LF
"RTN","XWBRW",46,0)
 I XWBPTYPE=2 D  Q
"RTN","XWBRW",47,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  D WRITE(XWBR(I)),WRITE($C(13,10))
"RTN","XWBRW",48,0)
 ; -- word processing
"RTN","XWBRW",49,0)
 I XWBPTYPE=3 D  Q
"RTN","XWBRW",50,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  D WRITE(XWBR(I)) D:XWBWRAP WRITE($C(13,10))
"RTN","XWBRW",51,0)
 ; -- global array
"RTN","XWBRW",52,0)
 I XWBPTYPE=4 D  Q
"RTN","XWBRW",53,0)
 . I $E($G(XWBR))'="^" Q
"RTN","XWBRW",54,0)
 . S I=$G(XWBR) Q:I=""  S T=$E(I,1,$L(I)-1)
"RTN","XWBRW",55,0)
 . ;Only send root node if non-null.
"RTN","XWBRW",56,0)
 . I $D(@I)>10 S D=@I I $L(D) D WRITE(D),WRITE($C(13,10)):XWBWRAP&(D'=$C(13,10))
"RTN","XWBRW",57,0)
 . F  S I=$Q(@I) Q:I=""!(I'[T)  S D=@I D WRITE(D),WRITE($C(13,10)):XWBWRAP&(D'=$C(13,10))
"RTN","XWBRW",58,0)
 . I $D(@XWBR) K @XWBR
"RTN","XWBRW",59,0)
 ; -- global instance
"RTN","XWBRW",60,0)
 I XWBPTYPE=5 D  Q
"RTN","XWBRW",61,0)
 . I $E($G(XWBR))'="^" Q
"RTN","XWBRW",62,0)
 . S XWBR=$G(@XWBR) D WRITE(XWBR) Q
"RTN","XWBRW",63,0)
 ; -- variable length records only good upto 255 char)
"RTN","XWBRW",64,0)
 I XWBPTYPE=6 D
"RTN","XWBRW",65,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  D WRITE($C($L(XWBR(I)))),WRITE(XWBR(I))
"RTN","XWBRW",66,0)
 Q
"RTN","XWBRW",67,0)
 ;
"RTN","XWBRW",68,0)
SNDERR ;send error information
"RTN","XWBRW",69,0)
 ;XWBSEC is the security packet, XWBERROR is application packet
"RTN","XWBRW",70,0)
 N X
"RTN","XWBRW",71,0)
 S $X=0 ;Start with zero
"RTN","XWBRW",72,0)
 S X=$E($G(XWBSEC),1,255)
"RTN","XWBRW",73,0)
 D WRITE($C($L(X))_X)
"RTN","XWBRW",74,0)
 S X=$E($G(XWBERROR),1,255)
"RTN","XWBRW",75,0)
 D WRITE($C($L(X))_X)
"RTN","XWBRW",76,0)
 S XWBERROR="",XWBSEC="" ;clears parameters
"RTN","XWBRW",77,0)
 Q
"RTN","XWBRW",78,0)
 ;
"RTN","XWBRW",79,0)
WRITE(STR) ;Write a data string
"RTN","XWBRW",80,0)
 ; send data for DSM (requires buffer flush (!) every 511 chars)
"RTN","XWBRW",81,0)
 ;IF XWBOS="DSM"!(XWBOS="UNIX")!(XWBOS="OpenM) next line
"RTN","XWBRW",82,0)
 F  Q:'$L(STR)  D
"RTN","XWBRW",83,0)
 . I $L(XWBSBUF)+$L(STR)>240 D WBF
"RTN","XWBRW",84,0)
 . S XWBSBUF=XWBSBUF_$E(STR,1,255),STR=$E(STR,256,99999)
"RTN","XWBRW",85,0)
 Q
"RTN","XWBRW",86,0)
WBF ;Write Buffer Flush
"RTN","XWBRW",87,0)
 Q:'$L(XWBSBUF)
"RTN","XWBRW",88,0)
 I $G(XWBDEBUG)>2,$L(XWBSBUF) D LOG^XWBDLOG("wrt ("_$L(XWBSBUF)_"): "_$E(XWBSBUF,1,247))
"RTN","XWBRW",89,0)
 W XWBSBUF,@XWBT("BF")
"RTN","XWBRW",90,0)
 S XWBSBUF=""
"RTN","XWBRW",91,0)
 Q
"RTN","XWBSEC")
0^9^B5461544
"RTN","XWBSEC",1,0)
XWBSEC ;SFISC/VYD - RPC BROKER ;09/23/2004  13:01
"RTN","XWBSEC",2,0)
 ;;1.1;RPC BROKER;**3,6,10,35**;Mar 28, 1997
"RTN","XWBSEC",3,0)
CHKPRMIT(XWBRP) ;checks to see if remote procedure is permited to run
"RTN","XWBSEC",4,0)
 ;Input:  XWBRP - Remote procedure to check
"RTN","XWBSEC",5,0)
 Q:$$KCHK^XUSRB("XUPROGMODE")
"RTN","XWBSEC",6,0)
 N ERR,XWBPRMIT,XWBALLOW
"RTN","XWBSEC",7,0)
 S U="^",XWBSEC="" ;Return XWBSEC="" if OK to run RPC
"RTN","XWBSEC",8,0)
 ;
"RTN","XWBSEC",9,0)
 ;In the beginning, when no DUZ is defined and no context exist, setup
"RTN","XWBSEC",10,0)
 ;default signon context
"RTN","XWBSEC",11,0)
 S:'$G(DUZ) DUZ=0,XQY0="XUS SIGNON"   ;set up default context
"RTN","XWBSEC",12,0)
 ;
"RTN","XWBSEC",13,0)
 ;These RPC's are allowed in any context, so we can just quit
"RTN","XWBSEC",14,0)
 I "^XWB IM HERE^XWB CREATE CONTEXT^XWB RPC LIST^XWB IS RPC AVAILABLE^XUS GET USER INFO^XUS GET TOKEN^"[(U_XWBRP_U) Q
"RTN","XWBSEC",15,0)
 ;VistAlink RPC's that are always allowed.
"RTN","XWBSEC",16,0)
 I "^XUS KAAJEE GET USER INFO^XUS KAAJEE LOGOUT^"[(U_XWBRP_U) Q
"RTN","XWBSEC",17,0)
 ;
"RTN","XWBSEC",18,0)
 ;If in Signon context, only allow XUS and XWB rpc's
"RTN","XWBSEC",19,0)
 I $G(XQY0)="XUS SIGNON","^XUS^XWB^"'[(U_$E(XWBRP,1,3)_U) S XWBSEC="Application context has not been created!" Q
"RTN","XWBSEC",20,0)
 ;XQCS allows all users access to the XUS SIGNON context.
"RTN","XWBSEC",21,0)
 ;Also to any context in the XUCOMMAND menu.
"RTN","XWBSEC",22,0)
 ;
"RTN","XWBSEC",23,0)
 I $G(XQY0)'="" D  ;1.1*6. XQY0="" after XUS SIGNON context deleted.
"RTN","XWBSEC",24,0)
 . S XWBALLOW=$$CHK^XQCS(DUZ,$P(XQY0,U),XWBRP)         ;do the check
"RTN","XWBSEC",25,0)
 . S:'XWBALLOW XWBSEC=XWBALLOW
"RTN","XWBSEC",26,0)
 E  S XWBSEC="Application context has not been created!"
"RTN","XWBSEC",27,0)
 Q
"RTN","XWBSEC",28,0)
 ;
"RTN","XWBSEC",29,0)
 ;
"RTN","XWBSEC",30,0)
CRCONTXT(RESULT,OPTION) ;creates context for the passed in option
"RTN","XWBSEC",31,0)
 K XQY0,XQY N XWB1,XABPGMOD,XWBPGMOD S RESULT=0
"RTN","XWBSEC",32,0)
 S OPTION=$$DECRYP^XUSRB1(OPTION) ;S:OPTION="" OPTION="\"
"RTN","XWBSEC",33,0)
 I OPTION="" S XQY=0,XQY0="",RESULT=1 Q  ;delete context if "" passed in.
"RTN","XWBSEC",34,0)
 S XWB1=$$OPTLK^XQCS(OPTION)
"RTN","XWBSEC",35,0)
 I XWB1="" S (XWBSEC,RESULT)="The context '"_OPTION_"' does not exist on server." Q  ;P10
"RTN","XWBSEC",36,0)
 S RESULT=$$CHK^XQCS(DUZ,XWB1)
"RTN","XWBSEC",37,0)
 ;Access or programmer
"RTN","XWBSEC",38,0)
 S XWBPGMOD=$$KCHK^XUSRB("XUPROGMODE")
"RTN","XWBSEC",39,0)
 I RESULT!XWBPGMOD S XQY0=OPTION,XQY=XWB1,RESULT=1
"RTN","XWBSEC",40,0)
 E  S XWBSEC=RESULT
"RTN","XWBSEC",41,0)
 Q
"RTN","XWBSEC",42,0)
 ;
"RTN","XWBSEC",43,0)
 ;
"RTN","XWBSEC",44,0)
STATE(%) ;Return a state value
"RTN","XWBSEC",45,0)
 Q:'$L($G(%)) $G(XWBSTATE)
"RTN","XWBSEC",46,0)
 Q $G(XWBSTATE(%))
"RTN","XWBSEC",47,0)
 ;
"RTN","XWBSEC",48,0)
 ;
"RTN","XWBSEC",49,0)
SET(%,VALUE) ;Set the state variable
"RTN","XWBSEC",50,0)
 I $G(%)="" S XWBSTATE=VALUE
"RTN","XWBSEC",51,0)
 S XWBSTATE(%)=VALUE
"RTN","XWBSEC",52,0)
 Q
"RTN","XWBSEC",53,0)
KILL(%) ;Kill state variable
"RTN","XWBSEC",54,0)
 I $L($G(%)) K XWBSTATE(%)
"RTN","XWBSEC",55,0)
 Q
"RTN","XWBTCP")
0^5^B48888024
"RTN","XWBTCP",1,0)
XWBTCP ;ISC-SF/EG - Control TCP listener ;07/08/2004  16:11
"RTN","XWBTCP",2,0)
 ;;1.1;RPC BROKER;**1,9,35**;Mar 28, 1997
"RTN","XWBTCP",3,0)
 ;
"RTN","XWBTCP",4,0)
EN ; -- entry point for interactive use
"RTN","XWBTCP",5,0)
 N X1,X2,XWBTDBG,XWBIP
"RTN","XWBTCP",6,0)
 S XWBIP=""
"RTN","XWBTCP",7,0)
 S:$G(IO("IP"))]"" XWBIP=IO("IP")
"RTN","XWBTCP",8,0)
 W !,"Enter client address: "_XWBIP_"//" R X1:300 Q:'$T  Q:X1="^"
"RTN","XWBTCP",9,0)
 W !,"   Enter client port: " R X2:300 Q:'$T  Q:X2="^"
"RTN","XWBTCP",10,0)
 W ! S XWBTDBG=""
"RTN","XWBTCP",11,0)
 IF X1="" S X1=XWBIP
"RTN","XWBTCP",12,0)
 IF $L(X1),$L(X2) D EN^XWBTCPC(X1,X2,"","1.08")
"RTN","XWBTCP",13,0)
 Q
"RTN","XWBTCP",14,0)
 ;
"RTN","XWBTCP",15,0)
STATSCRN(XWBNEW) ;Port STATUS field screen
"RTN","XWBTCP",16,0)
 ;DA: FileMan DA array.  See STATCHG tag bellow for detailed descr.
"RTN","XWBTCP",17,0)
 ;XWBCUR: Current value of STATUS field
"RTN","XWBTCP",18,0)
 ;XWBNEW: New/requested value of STATUS field
"RTN","XWBTCP",19,0)
 ;        The domain for XWBCUR and XWBNEW is the same as for the
"RTN","XWBTCP",20,0)
 ;        ACTION variable, described at STATCHG tag bellow.
"RTN","XWBTCP",21,0)
 N C,XWBCUR,RESULT
"RTN","XWBTCP",22,0)
 S C=","
"RTN","XWBTCP",23,0)
 S XWBCUR=$$GET1^DIQ(8994.171,DA_C_DA(1)_C_DA(2)_C,"STATUS","I")
"RTN","XWBTCP",24,0)
 S RESULT=0
"RTN","XWBTCP",25,0)
 I XWBCUR=3,XWBNEW=4 S RESULT=1 ;if stopping a running listener
"RTN","XWBTCP",26,0)
 I XWBCUR=6,XWBNEW=1 S RESULT=1 ;if starting a stopped listener
"RTN","XWBTCP",27,0)
 ;    the next two cases are most usefull whenever some error occurs
"RTN","XWBTCP",28,0)
 ;    and the STATUS field is stuck in STARTING or RUNNING state
"RTN","XWBTCP",29,0)
 I XWBCUR=2,XWBNEW=3 S RESULT=1 ;change to RUNNING if it's starting
"RTN","XWBTCP",30,0)
 I XWBCUR=5,XWBNEW=6 S RESULT=1 ;change to STOPPED if it's stopping
"RTN","XWBTCP",31,0)
 Q RESULT
"RTN","XWBTCP",32,0)
 ;
"RTN","XWBTCP",33,0)
 ;
"RTN","XWBTCP",34,0)
STATCHG(DA,ACTION) ;STATUS field X-ref SET logic
"RTN","XWBTCP",35,0)
 ;DA: FileMan DA array
"RTN","XWBTCP",36,0)
 ;  DA    =IEN of the port
"RTN","XWBTCP",37,0)
 ;  DA(1) =IEN of the BOX-VOLUME
"RTN","XWBTCP",38,0)
 ;  DA(2) =IEN of site/domain
"RTN","XWBTCP",39,0)
 ;ACTION: Requested value for the STATUS field.  Possible values are:
"RTN","XWBTCP",40,0)
 ;  1 = START, 2 = STARTING, 3 = RUNNING,
"RTN","XWBTCP",41,0)
 ;  4 = STOP,  5 = STOPPING, 6 = STOPPED
"RTN","XWBTCP",42,0)
 N C,ZTCPU,TYPE,XWBPORT,XWBFDA
"RTN","XWBTCP",43,0)
 S C=","
"RTN","XWBTCP",44,0)
 ;
"RTN","XWBTCP",45,0)
 I ACTION=1!(ACTION=4) D
"RTN","XWBTCP",46,0)
 . S ZTCPU=$$GET1^DIQ(8994.17,DA(1)_C_DA(2)_C,"BOX-VOLUME PAIR")
"RTN","XWBTCP",47,0)
 . S XWBPORT=$$GET1^DIQ(8994.171,DA_C_DA(1)_C_DA(2)_C,"PORT")
"RTN","XWBTCP",48,0)
 . S TYPE=$$GET1^DIQ(8994.171,DA_C_DA(1)_C_DA(2)_C,"TYPE OF LISTENER","I")
"RTN","XWBTCP",49,0)
 . ;UCI is no longer derived from the file, but comes from current
"RTN","XWBTCP",50,0)
 . ;environment.  The reason for that is it makes no sense to start
"RTN","XWBTCP",51,0)
 . ;a listener in a UCI where ^XWB can't be reached to change status.
"RTN","XWBTCP",52,0)
 . D GETENV^%ZOSV
"RTN","XWBTCP",53,0)
 . S ZTUCI=$P(Y,U),ZTIO="",ZTREQ="@",ZTDTH=$H ;run it ASAP
"RTN","XWBTCP",54,0)
 . I ACTION=1 D    ; -- START listener
"RTN","XWBTCP",55,0)
 . . S ZTDESC="RPC Broker Listener START on "_ZTUCI_"-"_ZTCPU_", port "_XWBPORT
"RTN","XWBTCP",56,0)
 . . S ZTRTN=$S(TYPE=1:"ZISTCP^XWBTCPM1("_XWBPORT_")",1:"EN^XWBTCPL("_XWBPORT_")")
"RTN","XWBTCP",57,0)
 . E  D            ; -- STOP listener
"RTN","XWBTCP",58,0)
 . . S ZTDESC="RPC Broker Listener STOP on "_ZTUCI_"-"_ZTCPU_", port "_XWBPORT
"RTN","XWBTCP",59,0)
 . . S ZTRTN="STOP^XWBTCP("_XWBPORT_")"
"RTN","XWBTCP",60,0)
 . D EN^DDIOL("Task: "_ZTDESC,"","!?10") ;inform user
"RTN","XWBTCP",61,0)
 . D ^%ZTLOAD      ; queue it
"RTN","XWBTCP",62,0)
 . D EN^DDIOL("has been queued as task "_ZTSK,"","!?10") ;inform user
"RTN","XWBTCP",63,0)
 . ; --  change STATUS from START to STARTING or from STOP to STOPPING
"RTN","XWBTCP",64,0)
 . D FDA^DILF(8994.171,DA_C_DA(1)_C_DA(2)_C,1,"R",ACTION+1,"XWBFDA")
"RTN","XWBTCP",65,0)
 . D FILE^DIE("K","XWBFDA")
"RTN","XWBTCP",66,0)
 Q
"RTN","XWBTCP",67,0)
 ;
"RTN","XWBTCP",68,0)
 ;
"RTN","XWBTCP",69,0)
STRT(XWBTSKT) ;start TCP Listener.  Interactive entry point
"RTN","XWBTCP",70,0)
 N IP,REF,Y,%
"RTN","XWBTCP",71,0)
 S U="^" D HOME^%ZIS
"RTN","XWBTCP",72,0)
 W "Start TCP Listener...",!
"RTN","XWBTCP",73,0)
 X ^%ZOSF("UCI") S REF=Y
"RTN","XWBTCP",74,0)
 S IP="0.0.0.0" ;get server IP at some point
"RTN","XWBTCP",75,0)
 IF $G(XWBTSKT)="" S XWBTSKT=9000 ;default service port is 9000
"RTN","XWBTCP",76,0)
 ;
"RTN","XWBTCP",77,0)
 ; -- see if 'running flag' for listener is set
"RTN","XWBTCP",78,0)
 I '$$SEMAPHOR^XWBTCPL(XWBTSKT,"LOCK") W "TCP Listener on port "_XWBTSKT_" appears to be running already.",! Q
"RTN","XWBTCP",79,0)
 S %=$$SEMAPHOR^XWBTCPL(XWBTSKT,"UNLOCK")
"RTN","XWBTCP",80,0)
 ;
"RTN","XWBTCP",81,0)
 D MARKER(XWBTSKT,1) ;record problem marker
"RTN","XWBTCP",82,0)
 ; -- start the listener
"RTN","XWBTCP",83,0)
 J EN^XWBTCPL(XWBTSKT)::5 ;Used in place of TaskMan, Need to start on any node.
"RTN","XWBTCP",84,0)
 I '$T W "Unable to run TCP Listener in background.",! Q
"RTN","XWBTCP",85,0)
 F %=1:1:5 D  Q:%=0
"RTN","XWBTCP",86,0)
 . W "Checking if TCP Listener has started...",!
"RTN","XWBTCP",87,0)
 . H 3
"RTN","XWBTCP",88,0)
 . S:'$$MARKER(XWBTSKT,0) %=0
"RTN","XWBTCP",89,0)
 I $$MARKER(XWBTSKT,0) D
"RTN","XWBTCP",90,0)
 . W !,"TCP Listener could not be started!",!
"RTN","XWBTCP",91,0)
 . W "Check if port "_XWBTSKT_" is busy on this CPU.",!
"RTN","XWBTCP",92,0)
 . D MARKER(XWBTSKT,-1) ;clear marker
"RTN","XWBTCP",93,0)
 E  W "TCP Listener started successfully."
"RTN","XWBTCP",94,0)
 Q
"RTN","XWBTCP",95,0)
 ;
"RTN","XWBTCP",96,0)
MARKER(PORT,MODE) ;Set/Test/Clear Problem Marker, Mode=0 is a function
"RTN","XWBTCP",97,0)
 N IP,Y,%,REF X ^%ZOSF("UCI") S REF=Y,IP="0.0.0.0",%=0
"RTN","XWBTCP",98,0)
 L +^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")
"RTN","XWBTCP",99,0)
 I MODE=1 S ^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")=1
"RTN","XWBTCP",100,0)
 I MODE=0 S:$D(^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")) %=1
"RTN","XWBTCP",101,0)
 I MODE=-1 K ^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")
"RTN","XWBTCP",102,0)
 L -^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")
"RTN","XWBTCP",103,0)
 Q:MODE=0 % Q
"RTN","XWBTCP",104,0)
 ;
"RTN","XWBTCP",105,0)
STRTALL ;XWB LISTENER STARTER option entry point
"RTN","XWBTCP",106,0)
 ;here all listener entries in RPC Broker Site Parameters file that
"RTN","XWBTCP",107,0)
 ;have CONTROLLED BY LISTENER STARTER set to 1/Yes will be started.
"RTN","XWBTCP",108,0)
 N E,LSTN,LSTNID,LSTNIENS,PORTID,XWBSCR,XWBDA
"RTN","XWBTCP",109,0)
 ;XWBDA: Namespaced FileMan DA array
"RTN","XWBTCP",110,0)
 ;  XWBDA    =IEN of the port
"RTN","XWBTCP",111,0)
 ;  XWBDA(1) =IEN of the BOX-VOLUME
"RTN","XWBTCP",112,0)
 ;  XWBDA(2) =IEN of site/domain
"RTN","XWBTCP",113,0)
 S E=""
"RTN","XWBTCP",114,0)
 S XWBDA(2)=1 ;hard set IEN of site/domain
"RTN","XWBTCP",115,0)
 ; -- screen out RUNNING (STATUS=3) listeners and those that aren't controlled by XWB LISTENER STARTER option.
"RTN","XWBTCP",116,0)
 S XWBSCR="I $P(^(0),U,2)'=3,$P(^(0),U,4)"
"RTN","XWBTCP",117,0)
 ; -- get top level listners box-volume
"RTN","XWBTCP",118,0)
 D LIST^DIC(8994.17,",1,",E,E,E,E,E,E,E,E,$NA(LSTN("LSTNR")))
"RTN","XWBTCP",119,0)
 S LSTNID=""
"RTN","XWBTCP",120,0)
 F  S LSTNID=$O(LSTN("LSTNR","DILIST",1,LSTNID)) Q:LSTNID=""  D
"RTN","XWBTCP",121,0)
 . S XWBDA(1)=LSTN("LSTNR","DILIST",2,LSTNID) ;IEN of each listener
"RTN","XWBTCP",122,0)
 . S LSTNIENS=","_XWBDA(1)_","_XWBDA(2)_","
"RTN","XWBTCP",123,0)
 . D LIST^DIC(8994.171,LSTNIENS,E,"P",E,E,E,E,XWBSCR,E,$NA(LSTN("PORT")))
"RTN","XWBTCP",124,0)
 . S PORTID=0
"RTN","XWBTCP",125,0)
 . F  S PORTID=$O(LSTN("PORT","DILIST",PORTID)) Q:PORTID=""  D
"RTN","XWBTCP",126,0)
 . . S XWBDA=$P(LSTN("PORT","DILIST",PORTID,0),U,1)
"RTN","XWBTCP",127,0)
 . . D STATCHG(.XWBDA,1) ;use STATUS field X-ref SET logic to queue up start of a listener
"RTN","XWBTCP",128,0)
 Q
"RTN","XWBTCP",129,0)
 ;
"RTN","XWBTCP",130,0)
STOPALL ;XWB LISTENER STOP ALL entry point
"RTN","XWBTCP",131,0)
 ;here all listener entries in RPC Broker Site Parameters file that
"RTN","XWBTCP",132,0)
 ;have CONTROLLED BY LISTENER STARTER set to 1/Yes will be stopped.
"RTN","XWBTCP",133,0)
 N E,LSTN,LSTNID,LSTNIENS,PORTID,XWBSCR,XWBDA
"RTN","XWBTCP",134,0)
 ;XWBDA: Namespaced FileMan DA array
"RTN","XWBTCP",135,0)
 ;  XWBDA    =IEN of the port
"RTN","XWBTCP",136,0)
 ;  XWBDA(1) =IEN of the BOX-VOLUME
"RTN","XWBTCP",137,0)
 ;  XWBDA(2) =IEN of site/domain
"RTN","XWBTCP",138,0)
 S E=""
"RTN","XWBTCP",139,0)
 S XWBDA(2)=1 ;hard set IEN of site/domain
"RTN","XWBTCP",140,0)
 ; -- screen out STOPPED (STATUS=3) listeners and those that aren't controlled by XWB LISTENER STARTER option.
"RTN","XWBTCP",141,0)
 S XWBSCR="I $P(^(0),U,2)'=6,$P(^(0),U,4)"
"RTN","XWBTCP",142,0)
 ; -- get top level listners box-volume
"RTN","XWBTCP",143,0)
 D LIST^DIC(8994.17,",1,",E,E,E,E,E,E,E,E,$NA(LSTN("LSTNR")))
"RTN","XWBTCP",144,0)
 S LSTNID=""
"RTN","XWBTCP",145,0)
 F  S LSTNID=$O(LSTN("LSTNR","DILIST",1,LSTNID)) Q:LSTNID=""  D
"RTN","XWBTCP",146,0)
 . S XWBDA(1)=LSTN("LSTNR","DILIST",2,LSTNID) ;IEN of each listener
"RTN","XWBTCP",147,0)
 . S LSTNIENS=","_XWBDA(1)_","_XWBDA(2)_","
"RTN","XWBTCP",148,0)
 . D LIST^DIC(8994.171,LSTNIENS,E,"P",E,E,E,E,XWBSCR,E,$NA(LSTN("PORT")))
"RTN","XWBTCP",149,0)
 . S PORTID=0
"RTN","XWBTCP",150,0)
 . F  S PORTID=$O(LSTN("PORT","DILIST",PORTID)) Q:PORTID=""  D
"RTN","XWBTCP",151,0)
 . . S XWBDA=$P(LSTN("PORT","DILIST",PORTID,0),U,1)
"RTN","XWBTCP",152,0)
 . . D STATCHG(.XWBDA,4) ;use STATUS field X-ref SET logic to queue up stop of a listener
"RTN","XWBTCP",153,0)
 Q
"RTN","XWBTCP",154,0)
 ;
"RTN","XWBTCP",155,0)
RESTART ;Stop and then Start all listeners.
"RTN","XWBTCP",156,0)
 D STOPALL H 15 D STRTALL
"RTN","XWBTCP",157,0)
 Q
"RTN","XWBTCP",158,0)
 ;
"RTN","XWBTCP",159,0)
STOP(XWBTSKT) ;stop TCP Listener.  Interactive and TaskMan entry point
"RTN","XWBTCP",160,0)
 N IP,REF,X,DEV,XWBOS,XWBIP,XWBENV
"RTN","XWBTCP",161,0)
 S U="^" D HOME^%ZIS,GETENV^%ZOSV S XWBENV=Y
"RTN","XWBTCP",162,0)
 D EN^DDIOL("Stop TCP Listener...")
"RTN","XWBTCP",163,0)
 X ^%ZOSF("UCI") S REF=Y
"RTN","XWBTCP",164,0)
 S IP="0.0.0.0" ;get server IP
"RTN","XWBTCP",165,0)
 IF $G(XWBTSKT)="" S XWBTSKT=9000 ;default service port is 9000
"RTN","XWBTCP",166,0)
 ;
"RTN","XWBTCP",167,0)
 S XWBOS=$S(^%ZOSF("OS")["DSM":"DSM",^("OS")["MSM":"MSM",^("OS")["OpenM":"OpenM",1:"") ;RWF
"RTN","XWBTCP",168,0)
 ;
"RTN","XWBTCP",169,0)
 ; -- make sure the listener is running
"RTN","XWBTCP",170,0)
 I $$SEMAPHOR^XWBTCPL(XWBTSKT,"LOCK") D  Q
"RTN","XWBTCP",171,0)
 . S %=$$SEMAPHOR^XWBTCPL(XWBTSKT,"UNLOCK")
"RTN","XWBTCP",172,0)
 . D EN^DDIOL("TCP Listener does not appear to be running.")
"RTN","XWBTCP",173,0)
 ;
"RTN","XWBTCP",174,0)
 S X=$$NODE^XWBTCPM1(XWBTSKT) ;Get node
"RTN","XWBTCP",175,0)
 I $P(X,"^",3)=1 D  Q
"RTN","XWBTCP",176,0)
 . D EN^DDIOL("New listener should stop on its own")
"RTN","XWBTCP",177,0)
 ;
"RTN","XWBTCP",178,0)
 ; -- send the shutdown message to the TCP Listener process
"RTN","XWBTCP",179,0)
 ;    using loopback address
"RTN","XWBTCP",180,0)
 S XWBIP="127.0.0.1"
"RTN","XWBTCP",181,0)
 D CALL^%ZISTCP("127.0.0.1",XWBTSKT) I POP D  Q
"RTN","XWBTCP",182,0)
 . S %=$$SEMAPHOR^XWBTCPL(XWBTSKT,"UNLOCK")
"RTN","XWBTCP",183,0)
 . D EN^DDIOL("TCP Listener does not appear to be running.")
"RTN","XWBTCP",184,0)
 U IO
"RTN","XWBTCP",185,0)
 ;
"RTN","XWBTCP",186,0)
 S X=$T(+2),X=$P(X,";;",2),X=$P(X,";")
"RTN","XWBTCP",187,0)
 IF X="" S X=0
"RTN","XWBTCP",188,0)
 S X=$C($L(X))_X
"RTN","XWBTCP",189,0)
 W "{XWB}00020|"_X_"00011TCPshutdown",!
"RTN","XWBTCP",190,0)
 R X:5
"RTN","XWBTCP",191,0)
 D CLOSE^%ZISTCP
"RTN","XWBTCP",192,0)
 IF X["ack" D EN^DDIOL("TCP Listener has been shutdown.")
"RTN","XWBTCP",193,0)
 ELSE  D EN^DDIOL("Shutdown Failed!")
"RTN","XWBTCP",194,0)
 Q
"RTN","XWBTCP",195,0)
 ;
"RTN","XWBTCP",196,0)
DEBUG ;Edit the debug parameter
"RTN","XWBTCP",197,0)
 W !!
"RTN","XWBTCP",198,0)
 D EDITPAR^XPAREDIT("XWBDEBUG")
"RTN","XWBTCP",199,0)
 W !!
"RTN","XWBTCP",200,0)
 Q
"RTN","XWBTCPC")
0^6^B32111075
"RTN","XWBTCPC",1,0)
XWBTCPC ;ISC-SF/EG/VYD - TCP/IP PROCESS HANDLER ;08/25/2004  14:18
"RTN","XWBTCPC",2,0)
 ;;1.1;RPC BROKER;**2,5,4,6,9,16,26,35**;Mar 28, 1997
"RTN","XWBTCPC",3,0)
 ;Based on: XQORTCPH ;SLC/KCM - Service TCP Messages
"RTN","XWBTCPC",4,0)
 ;Modified by ISC-SF/EG
"RTN","XWBTCPC",5,0)
 ; 0. No longer supports old style OERR messages
"RTN","XWBTCPC",6,0)
 ; 1. Makes call to RPC  broker
"RTN","XWBTCPC",7,0)
 ; 2. Result of an rpc call can be a closed form of global
"RTN","XWBTCPC",8,0)
 ; 3. Can receive a large local array, within limits of job
"RTN","XWBTCPC",9,0)
 ;    partition size.
"RTN","XWBTCPC",10,0)
 ; 4. Sets default device to NULL device prior to call, restores
"RTN","XWBTCPC",11,0)
 ;    at termination.  Prevents garbage from 'talking' calls.
"RTN","XWBTCPC",12,0)
 ; 5. All reads have a timeout.
"RTN","XWBTCPC",13,0)
 ; 6. Intro message is sent when first connected.
"RTN","XWBTCPC",14,0)
 ; 7. Uses callback model to connect to client
"RTN","XWBTCPC",15,0)
 ;
"RTN","XWBTCPC",16,0)
 ;
"RTN","XWBTCPC",17,0)
EN(XWBTIP,XWBTSKT,DUZ,XWBVER,XWBCLMAN) ; -- Main entry point
"RTN","XWBTCPC",18,0)
 N TYPE,XWBTBUF,XWBTBUF1,XWBTDEV,XWBTLEN,XWBTOS,XWBTRTN,XWBWRAP
"RTN","XWBTCPC",19,0)
 N X,XWBL,XWB1,XWB2,Y,XWBTIME,XWBPTYPE,XWBPLEN,XWBNULL,XWBODEV,XWBRBUF
"RTN","XWBTCPC",20,0)
 N XWBERROR,XWBSEC ;new error variable available to rpc calls
"RTN","XWBTCPC",21,0)
 N IO,IOP,L,XWBAPVER,VL,XWBTHDR,XWBT
"RTN","XWBTCPC",22,0)
 ;
"RTN","XWBTCPC",23,0)
 ;Set up the error trap
"RTN","XWBTCPC",24,0)
 S U="^",$ETRAP="D ^%ZTER,XUTL^XUSCLEAN H" ;XWB-30
"RTN","XWBTCPC",25,0)
 S XWBOS=$$OS
"RTN","XWBTCPC",26,0)
 S XWBT("BF")=$S(XWBOS="GT.M":"#",1:"!")
"RTN","XWBTCPC",27,0)
 ;start RUM for Broker Handler XWB*1.1*5
"RTN","XWBTCPC",28,0)
 D LOGRSRC^%ZOSV("$BROKER HANDLER$",2,1)
"RTN","XWBTCPC",29,0)
 ;
"RTN","XWBTCPC",30,0)
 S XWBCLMAN=$G(XWBCLMAN)
"RTN","XWBTCPC",31,0)
 I '$D(XWBDEBUG) D  ;(*p35)
"RTN","XWBTCPC",32,0)
 . S XWBDEBUG=$$GET^XPAR("SYS","XWBDEBUG")
"RTN","XWBTCPC",33,0)
 . D LOGSTART^XWBDLOG("XWBTCPC")
"RTN","XWBTCPC",34,0)
 . Q
"RTN","XWBTCPC",35,0)
 I XWBDEBUG D LOG("Callback: "_XWBTIP_" :"_XWBTSKT) ;(*p35)
"RTN","XWBTCPC",36,0)
 D SETTIME(1) ;Setup for sign-on time-out
"RTN","XWBTCPC",37,0)
 ;Use Kernel to open the connection back to the client on new port
"RTN","XWBTCPC",38,0)
 D CALL^%ZISTCP(XWBTIP,XWBTSKT) Q:POP  S XWBTDEV=IO,IO(0)=IO
"RTN","XWBTCPC",39,0)
 ;Attempt to share the license, Must have TCP port open first.
"RTN","XWBTCPC",40,0)
 U XWBTDEV I $T(SHARELIC^%ZOSV)'="" D SHARELIC^%ZOSV(1)
"RTN","XWBTCPC",41,0)
 ;setup null device "NULL"
"RTN","XWBTCPC",42,0)
 S %ZIS="0H",IOP="NULL" D ^%ZIS S XWBNULL=IO I POP S XWBERROR="No NULL device" D ^%ZTER Q
"RTN","XWBTCPC",43,0)
 D SAVDEV^%ZISUTL("XWBNULL")
"RTN","XWBTCPC",44,0)
 I XWBOS="GTM" S @("$ZINTERRUPT=""I $$JOBEXAM^ZU($ZPOSITION)""")
"RTN","XWBTCPC",45,0)
 ;change process name
"RTN","XWBTCPC",46,0)
 S X="ip"_$P(XWBTIP,".",3,4)_":"_XWBTSKT
"RTN","XWBTCPC",47,0)
 D SETNM^%ZOSV($E(X,1,15)),LOG("ProcName: "_X)
"RTN","XWBTCPC",48,0)
RESTART ;(*p35)
"RTN","XWBTCPC",49,0)
 N $ESTACK S $ETRAP="D ETRAP^XWBTCPC"
"RTN","XWBTCPC",50,0)
 S U="^",DUZ=0,DUZ(0)="",DTIME=300
"RTN","XWBTCPC",51,0)
 U XWBTDEV D MAIN
"RTN","XWBTCPC",52,0)
 ;Turn off the error trap for the exit
"RTN","XWBTCPC",53,0)
 S $ETRAP=""
"RTN","XWBTCPC",54,0)
 I $G(DUZ) D LOGOUT^XUSRB
"RTN","XWBTCPC",55,0)
 K XWBR,XWBARY
"RTN","XWBTCPC",56,0)
 ;stop RUM for handler XWB*1.1*5
"RTN","XWBTCPC",57,0)
 D LOGRSRC^%ZOSV("$BROKER HANDLER$",2,2)
"RTN","XWBTCPC",58,0)
 D LOG("DUZ="_$G(DUZ)_"  LOGGED OFF")
"RTN","XWBTCPC",59,0)
 D USE^%ZISUTL("XWBNULL"),CLOSE^%ZISUTL("XWBNULL")
"RTN","XWBTCPC",60,0)
 C XWBTDEV ;Close can get an error
"RTN","XWBTCPC",61,0)
 Q
"RTN","XWBTCPC",62,0)
 ;
"RTN","XWBTCPC",63,0)
MAIN ; -- main message processing loop
"RTN","XWBTCPC",64,0)
 N XCNT,XR
"RTN","XWBTCPC",65,0)
 F  D  Q:XWBTBUF="#BYE#"
"RTN","XWBTCPC",66,0)
 . S XWBAPVER=0,(XWBSEC,XWBERROR,XWBRBUF)=""
"RTN","XWBTCPC",67,0)
 . U XWBTDEV ;Make sure we are reading from the right device
"RTN","XWBTCPC",68,0)
 . ; -- read client request
"RTN","XWBTCPC",69,0)
 . ;F XCNT=0:0 R XR#1:XWBTIME Q:(XR="{")!(XR="#")  I '$T S XCNT=XCNT+1 Q:XCNT>5
"RTN","XWBTCPC",70,0)
 . S XR=$$BREAD^XWBRW(1,XWBTIME,1)
"RTN","XWBTCPC",71,0)
 . I '$L(XR) D LOG("Timeout"),TIMEOUT S XWBTBUF="#BYE#" Q
"RTN","XWBTCPC",72,0)
 . S XWBTHDR=XR_$$BREAD^XWBRW(4) ;(*p35)
"RTN","XWBTCPC",73,0)
 . I XWBTHDR["#BYE#" S XWBTBUF="#BYE#" Q  ;Clear $C(4)
"RTN","XWBTCPC",74,0)
 . S XWBTHDR=XWBTHDR_$$BREAD^XWBRW(6)
"RTN","XWBTCPC",75,0)
 . I $G(XWBDEBUG)>1 D LOG("HDR Read:"_XWBTHDR_":")
"RTN","XWBTCPC",76,0)
 . S TYPE=($E(XWBTHDR,1,5)="{XWB}")  ;check HDR
"RTN","XWBTCPC",77,0)
 . I 'TYPE D  Q
"RTN","XWBTCPC",78,0)
 . . D LOG("Bad Header: "_XWBTHDR) ;(*p35)
"RTN","XWBTCPC",79,0)
 . . S XWBTBUF="#BYE#" D QSND^XWBRW(XWBTBUF) ;(*p35)
"RTN","XWBTCPC",80,0)
 . . Q
"RTN","XWBTCPC",81,0)
 . S XWBTLEN=$E(XWBTHDR,6,10),L=$E(XWBTHDR,11)
"RTN","XWBTCPC",82,0)
 . I L="|" D  ;(*p35)  Save $T
"RTN","XWBTCPC",83,0)
 . . S VL=$$BREAD^XWBRW(1),VL=$A(VL)
"RTN","XWBTCPC",84,0)
 . . S XWBAPVER=$$BREAD^XWBRW(VL),XWBPLEN=$$BREAD^XWBRW(5) ;(*p35)
"RTN","XWBTCPC",85,0)
 . E  S XWBTBUF=$$BREAD^XWBRW(4),XWBPLEN=L_XWBTBUF ;(*p35)
"RTN","XWBTCPC",86,0)
 . S XWBTBUF=$$BREAD^XWBRW(XWBPLEN) ;(*p35)
"RTN","XWBTCPC",87,0)
 . I $P(XWBTBUF,U)="TCPconnect" D  Q
"RTN","XWBTCPC",88,0)
 . . D QSND^XWBRW("accept") ;Ack (*p35)
"RTN","XWBTCPC",89,0)
 . IF TYPE D
"RTN","XWBTCPC",90,0)
 . . K XWBR,XWBARY
"RTN","XWBTCPC",91,0)
 . . IF XWBTBUF="#BYE#" D QSND^XWBRW("#BYE#") Q  ; -- clean disconnect
"RTN","XWBTCPC",92,0)
 . . S XWBTLEN=XWBTLEN-15
"RTN","XWBTCPC",93,0)
 . . D CALLP^XWBBRK(.XWBR,XWBTBUF)
"RTN","XWBTCPC",94,0)
 . . S XWBPTYPE=$S('$D(XWBPTYPE):1,XWBPTYPE<1:1,XWBPTYPE>6:1,1:XWBPTYPE)
"RTN","XWBTCPC",95,0)
 . IF XWBTBUF="#BYE#" D LOG("APP set #BYE#") Q  ;(*p35)
"RTN","XWBTCPC",96,0)
 . U XWBTDEV
"RTN","XWBTCPC",97,0)
 . D SND^XWBRW ;Does SNDERR,SND,WRITE($C(4))
"RTN","XWBTCPC",98,0)
 . I $G(XWBSHARE) D KILL1^XUSCLEAN ; CLEAN OUT PARTITION FOR SHARED BROKER
"RTN","XWBTCPC",99,0)
 Q  ;End Of Main
"RTN","XWBTCPC",100,0)
 ;
"RTN","XWBTCPC",101,0)
ETRAP ; -- on trapped error, send error info to client
"RTN","XWBTCPC",102,0)
 N XWBERC,XWBERR
"RTN","XWBTCPC",103,0)
 ;Change trapping during trap.
"RTN","XWBTCPC",104,0)
 S $ETRAP="D ^%ZTER,BYE^XUSCLEAN,XUTL^XUSCLEAN HALT" ;XWB-30
"RTN","XWBTCPC",105,0)
 S XWBERC=$E($$EC^%ZOSV,1,200),XWBERR="M  ERROR="_XWBERC_$C(13,10)_"LAST REF="_$$LGR^%ZOSV
"RTN","XWBTCPC",106,0)
 S XWBOS=$$OS
"RTN","XWBTCPC",107,0)
 ;Check for short read, Tell Client to resend.
"RTN","XWBTCPC",108,0)
 I $EC["U411" S XWBERROR="U411",XWBSEC="",XWBERR="Data Transfer Error to Server"
"RTN","XWBTCPC",109,0)
 D ^%ZTER ;%ZTER clears $ZE and $ECODE
"RTN","XWBTCPC",110,0)
 I $G(XWBDEBUG) D LOG("In ETRAP: "_XWBERC) ;(*p35)
"RTN","XWBTCPC",111,0)
 I ($G(XWBERC)["READ")!($G(XWBERC)["WRITE")!($G(XWBERC)["SYSTEM-F")!('$D(XWBERC)) D:$G(DUZ) LOGOUT^XUSRB HALT  ; XWB-30
"RTN","XWBTCPC",112,0)
 U XWBTDEV
"RTN","XWBTCPC",113,0)
 L  ;Clear locks (*p35)
"RTN","XWBTCPC",114,0)
ETX ;Exit for trap
"RTN","XWBTCPC",115,0)
 D ESND^XWBRW($C(24)_XWBERR_$C(4)) ;(p*35)
"RTN","XWBTCPC",116,0)
 S $ETRAP="Q:($ESTACK&'$QUIT)  Q:$ESTACK -9 S $ECODE="""" G RESTART^XWBTCPC",$ECODE=",U99,"
"RTN","XWBTCPC",117,0)
 Q
"RTN","XWBTCPC",118,0)
 ;
"RTN","XWBTCPC",119,0)
STYPE(X,WRAP) ;For backward compatability only
"RTN","XWBTCPC",120,0)
 I $D(WRAP) Q $$RTRNFMT^XWBLIB($G(X),WRAP)
"RTN","XWBTCPC",121,0)
 Q $$RTRNFMT^XWBLIB(X)
"RTN","XWBTCPC",122,0)
 ;
"RTN","XWBTCPC",123,0)
SETTIME(%) ;Set the Read timeout 0=RPC, 1=sign-on
"RTN","XWBTCPC",124,0)
 ; Increased timeout period (%=1) during signon from 90 to 180 for accessibility reasons
"RTN","XWBTCPC",125,0)
 S XWBTIME=$S($G(%):180,$G(XWBVER)>1.105:$$BAT^XUPARAM,1:36000),XWBTIME(1)=5 ; (*p35)
"RTN","XWBTCPC",126,0)
 I $G(%) S XWBTIME=$S($G(XWBVER)>1.1:90,1:36000)
"RTN","XWBTCPC",127,0)
 Q
"RTN","XWBTCPC",128,0)
TIMEOUT ;Do this on MAIN  loop timeout
"RTN","XWBTCPC",129,0)
 I $G(DUZ)>0 D QSND^XWBRW("#BYE#"_$C(4)) Q
"RTN","XWBTCPC",130,0)
 ;Sign-on timeout
"RTN","XWBTCPC",131,0)
 S XWBR(0)=0,XWBR(1)=1,XWBR(2)="",XWBR(3)="TIME-OUT",XWBPTYPE=2
"RTN","XWBTCPC",132,0)
 D SND^XWBRW
"RTN","XWBTCPC",133,0)
 Q
"RTN","XWBTCPC",134,0)
 ;
"RTN","XWBTCPC",135,0)
MSM ;entry point for MSERVER service - used by MSM
"RTN","XWBTCPC",136,0)
 N XWBVER,LEN,MSG,X
"RTN","XWBTCPC",137,0)
 S XWBVER=0
"RTN","XWBTCPC",138,0)
 R LEN#11:3600 IF $E(LEN,1,5)'="{XWB}" D  Q  ;bad client, abort
"RTN","XWBTCPC",139,0)
 . W "RPC broker disconnect!",!
"RTN","XWBTCPC",140,0)
 . C 56
"RTN","XWBTCPC",141,0)
 . Q
"RTN","XWBTCPC",142,0)
 IF $E(LEN,11,11)="|" D
"RTN","XWBTCPC",143,0)
 . R X#1:60
"RTN","XWBTCPC",144,0)
 . R XWBVER#$A(X):60
"RTN","XWBTCPC",145,0)
 . R LEN#5:60
"RTN","XWBTCPC",146,0)
 . R MSG#LEN:60
"RTN","XWBTCPC",147,0)
 . Q
"RTN","XWBTCPC",148,0)
 ELSE  S X=$E(LEN,11,11),LEN=$E(LEN,6,10)-1 R MSG#LEN:60 S MSG=X_MSG
"RTN","XWBTCPC",149,0)
 IF $P(MSG,"^")="TCPconnect" D
"RTN","XWBTCPC",150,0)
 . D QSND^XWBRW("accept")
"RTN","XWBTCPC",151,0)
 . C 56
"RTN","XWBTCPC",152,0)
 . D EN($P(MSG,"^",2),$P(MSG,"^",3),$P(X,"^"),XWBVER,$P(MSG,"^",4))
"RTN","XWBTCPC",153,0)
 IF $P(MSG,"^")="TCPdebug" D
"RTN","XWBTCPC",154,0)
 . D QSND^XWBRW("accept")
"RTN","XWBTCPC",155,0)
 C 56
"RTN","XWBTCPC",156,0)
 Q
"RTN","XWBTCPC",157,0)
OS() ;Return the OS
"RTN","XWBTCPC",158,0)
 N % S %=^%ZOSF("OS") ;(*p35)
"RTN","XWBTCPC",159,0)
 Q $S(%["DSM":"DSM",%["OpenM":"OpenM",%["GT.M":"GTM",1:"MSM") ;(*p35)
"RTN","XWBTCPC",160,0)
 ;
"RTN","XWBTCPC",161,0)
LOG(TX) ;DeBug Logging (*p35)
"RTN","XWBTCPC",162,0)
 D:$G(XWBDEBUG) LOG^XWBDLOG(TX)
"RTN","XWBTCPC",163,0)
 Q
"RTN","XWBTCPL")
0^8^B59791683
"RTN","XWBTCPL",1,0)
XWBTCPL ;SLC/KCM - Listener for TCP connects ;12/09/2004  07:33
"RTN","XWBTCPL",2,0)
 ;;1.1;RPC BROKER;**1,7,9,15,16,35**;Mar 28, 1997
"RTN","XWBTCPL",3,0)
 ;ISC-SF/EG - DHCP Broker
"RTN","XWBTCPL",4,0)
 ;
"RTN","XWBTCPL",5,0)
 ; This routine is the background process that listens for client
"RTN","XWBTCPL",6,0)
 ; requests to connect to M.  When a request is received, This
"RTN","XWBTCPL",7,0)
 ; procedure will job a routine to handle the requests of the client.
"RTN","XWBTCPL",8,0)
 ;
"RTN","XWBTCPL",9,0)
 ; This job may be started in the background with:  D STRT^XWBTCP(PORT)
"RTN","XWBTCPL",10,0)
 ;
"RTN","XWBTCPL",11,0)
 ; When running, this job may be stopped with:      D STOP^XWBTCP(PORT)
"RTN","XWBTCPL",12,0)
 ;
"RTN","XWBTCPL",13,0)
 ; Where port is the known service port to listen for connections
"RTN","XWBTCPL",14,0)
 ; p*35 Moved reads and writes to XWBRW
"RTN","XWBTCPL",15,0)
 ;
"RTN","XWBTCPL",16,0)
EN(XWBTSKT) ; -- accept clients and start the individual message handler
"RTN","XWBTCPL",17,0)
 N $ETRAP,$ESTACK S $ETRAP="D ^%ZTER J EN^XWBTCPL($G(XWBTSKT)) HALT"
"RTN","XWBTCPL",18,0)
 N RETRY,X,XWBVER,XWBVOL,LEN,MSG,XWBOS,DONE,DSMTCP,NATIP,XWBRBUF
"RTN","XWBTCPL",19,0)
 N XWBTIME
"RTN","XWBTCPL",20,0)
 S U="^",RETRY="START"
"RTN","XWBTCPL",21,0)
 X ^%ZOSF("UCI") S XWBVOL=$P(Y,",",2) ;(*p7,p9*)
"RTN","XWBTCPL",22,0)
 IF $G(XWBTSKT)="" S XWBTSKT=9000 ; default service port
"RTN","XWBTCPL",23,0)
 S XWBTDEV=XWBTSKT
"RTN","XWBTCPL",24,0)
 ;
"RTN","XWBTCPL",25,0)
 Q:'$$SEMAPHOR(XWBTSKT,"LOCK")  ; -- quit if job is already running
"RTN","XWBTCPL",26,0)
 ;
"RTN","XWBTCPL",27,0)
 S XWBDEBUG=$$GET^XPAR("SYS","XWBDEBUG") ;(*p35)
"RTN","XWBTCPL",28,0)
 I XWBDEBUG D LOGSTART^XWBDLOG("XWBTCPL") ;(*p35)
"RTN","XWBTCPL",29,0)
 D UPDTREC(XWBTSKT,3) ;updt RPC BROKER SITE PARAMETER record as RUNNING
"RTN","XWBTCPL",30,0)
 D MARKER^XWBTCP(XWBTSKT,-1) ;Clear marker
"RTN","XWBTCPL",31,0)
 ;
"RTN","XWBTCPL",32,0)
 D SETNM^%ZOSV($E("RPCB_Port:"_XWBTSKT,1,15)) ;change process name
"RTN","XWBTCPL",33,0)
 ;
"RTN","XWBTCPL",34,0)
RESTART ;
"RTN","XWBTCPL",35,0)
 H 5 ;Hibernate so caller can clear (*p16,*p35)
"RTN","XWBTCPL",36,0)
 N $ESTACK S $ETRAP="D ETRAP^XWBTCPL"
"RTN","XWBTCPL",37,0)
 S DONE=0,X=0,XWBTIME=5,XWBTIME(1)=5
"RTN","XWBTCPL",38,0)
 S XWBOS=$S(^%ZOSF("OS")["DSM":"DSM",^("OS")["OpenM":"OpenM",^("OS")["GT.M":"GTM",^("OS")["MSM":"MSM",1:"")
"RTN","XWBTCPL",39,0)
 S XWBT("BF")=$S(XWBOS="GT.M":"#",1:"!") ;(*p35)
"RTN","XWBTCPL",40,0)
 ;
"RTN","XWBTCPL",41,0)
 S %T=0 ;Check for Open success (*p35)
"RTN","XWBTCPL",42,0)
 ;DSM
"RTN","XWBTCPL",43,0)
 I XWBOS="DSM" O XWBTSKT:TCPCHAN:5 S %T=$T ;Open listener
"RTN","XWBTCPL",44,0)
 ;Cache, Terminator = $C(4)512 buffers, queue = 10
"RTN","XWBTCPL",45,0)
 I XWBOS="OpenM" S XWBTDEV="|TCP|"_XWBTSKT O XWBTDEV:(:XWBTSKT:"A":$C(4):512:512:10):5 S %T=$T ;(*p35)
"RTN","XWBTCPL",46,0)
 ;GT.M (*p35)
"RTN","XWBTCPL",47,0)
 I XWBOS="GTM" D
"RTN","XWBTCPL",48,0)
 . S @("$ZINTERRUPT=""I $$JOBEXAM^ZU($ZPOSITION)""")
"RTN","XWBTCPL",49,0)
 . S XWBTDEV="SKD$"_$J,XWBTSKT=XWBTSKT
"RTN","XWBTCPL",50,0)
 . O XWBTDEV:(ZLISTEN=XWBTSKT_":TCP":NODELIMITER:ATTACH="listener"):5:"SOCKET" S %T=$T Q:'%T
"RTN","XWBTCPL",51,0)
 . U XWBTDEV S XWBTDEV("LISTENER")=$KEY
"RTN","XWBTCPL",52,0)
 . W /LISTEN(1)
"RTN","XWBTCPL",53,0)
 . U XWBTDEV S XWBTDEV("STATUS")=$KEY
"RTN","XWBTCPL",54,0)
 . Q
"RTN","XWBTCPL",55,0)
 ;Check if got device Open
"RTN","XWBTCPL",56,0)
 I '%T D LOG^XWBDLOG("Open "_XWBTSKT_" Fail") Q  ;(*p35)
"RTN","XWBTCPL",57,0)
 ;
"RTN","XWBTCPL",58,0)
 I XWBDEBUG D LOG^XWBDLOG("Port Open: "_XWBTSKT)
"RTN","XWBTCPL",59,0)
 F  D  Q:DONE
"RTN","XWBTCPL",60,0)
 . S DONE=0
"RTN","XWBTCPL",61,0)
 . ; -- listen for connect & get the initial message from the client
"RTN","XWBTCPL",62,0)
 . I XWBOS="DSM" U XWBTSKT S XWBTIME=60 ;Will wait at read
"RTN","XWBTCPL",63,0)
 . I XWBOS="MSM" S XWBTDEV=56 O 56 U 56::"TCP" W /SOCKET("",XWBTSKT)
"RTN","XWBTCPL",64,0)
 . I XWBOS="OpenM" U XWBTDEV R *X ;Cache will wait here for connection
"RTN","XWBTCPL",65,0)
 . I XWBOS="GTM" D
"RTN","XWBTCPL",66,0)
 . . K XWBTDEV("SOCKET")
"RTN","XWBTCPL",67,0)
 . . F  D  Q:$D(XWBTDEV("SOCKET"))
"RTN","XWBTCPL",68,0)
 . . . ;Wait for connection, $KEY will be "CONNECT|socket_handle|remote_ipaddress"
"RTN","XWBTCPL",69,0)
 . . . U XWBTDEV W /WAIT(10) S XWBTDEV("KEY")=$KEY
"RTN","XWBTCPL",70,0)
 . . . I XWBTDEV("KEY")="" Q
"RTN","XWBTCPL",71,0)
 . . . S XWBTDEV("SOCKET")=$P(XWBTDEV("KEY"),"|",2)
"RTN","XWBTCPL",72,0)
 . . . S (XWBTDEV("IP"),IO("GTM-IP"))=$P(XWBTDEV("KEY"),"|",3)
"RTN","XWBTCPL",73,0)
 . . . U XWBTDEV:(SOCKET=XWBTDEV("SOCKET"):WIDTH=512:NOWRAP:EXCEPTION="GOTO ETRAP")
"RTN","XWBTCPL",74,0)
 . . . Q
"RTN","XWBTCPL",75,0)
 . . Q
"RTN","XWBTCPL",76,0)
 . ;========================MAIN LOOP=======================
"RTN","XWBTCPL",77,0)
 . ;(*p35) change to use MSG, MSG1 and MSG2
"RTN","XWBTCPL",78,0)
 . S (MSG,MSG1,MSG2,XWBRBUF)=""
"RTN","XWBTCPL",79,0)
 . ;F XCNT=0:0 R MSG1#1:XWBTIME Q:$T  I '$T S XCNT=XCNT+1 Q:XCNT>5
"RTN","XWBTCPL",80,0)
 . F XCNT=0:0 S MSG1=$$BREAD^XWBRW(1,XWBTIME,1) Q:$L(MSG1)  S XCNT=XCNT+1 Q:XCNT>5
"RTN","XWBTCPL",81,0)
 . Q:XCNT>5
"RTN","XWBTCPL",82,0)
 . I MSG1'="{" D RELEASE(0) Q  ;Not the right start so Close.
"RTN","XWBTCPL",83,0)
 . S MSG1=MSG1_$$BREAD^XWBRW(4,,1) IF (MSG1'="{XWB}") D RELEASE(0) Q
"RTN","XWBTCPL",84,0)
 . S MSG1=MSG1_$$BREAD^XWBRW(6)
"RTN","XWBTCPL",85,0)
 . I $E(MSG1,11)="|" D
"RTN","XWBTCPL",86,0)
 . . S VL=$$BREAD^XWBRW(1),VL=$A(VL)
"RTN","XWBTCPL",87,0)
 . . S XWBVER=$$BREAD^XWBRW(VL)
"RTN","XWBTCPL",88,0)
 . . S LEN=$$BREAD^XWBRW(5)
"RTN","XWBTCPL",89,0)
 . . S MSG=$$BREAD^XWBRW(+LEN)
"RTN","XWBTCPL",90,0)
 . E  S X=$E(MSG1,11),LEN=$E(MSG1,6,10)-1,MSG2=$$BREAD^XWBRW(LEN),MSG=X_MSG2,XWBVER=0
"RTN","XWBTCPL",91,0)
 . ; -- msg should be:  action^client IP^client port^token
"RTN","XWBTCPL",92,0)
 . I XWBDEBUG D LOG^XWBDLOG("Hdr:"_MSG1_" Msg:"_MSG) ;(*p35)
"RTN","XWBTCPL",93,0)
 . ;
"RTN","XWBTCPL",94,0)
 . ; -- if the action is TCPconnect (usual case)
"RTN","XWBTCPL",95,0)
 . I $P(MSG,"^")="TCPconnect" D
"RTN","XWBTCPL",96,0)
 . . N DZ,%T S DZ="",%T=0,RETRY=$S($G(RETRY)>1:RETRY-1,1:0) ;(*p7*)
"RTN","XWBTCPL",97,0)
 . . ;Get the peer and use that IP, Allow use thru a NAT box.
"RTN","XWBTCPL",98,0)
 . . S NATIP=$$GETPEER^%ZOSV I $L(NATIP) S $P(MSG,"^",2)=NATIP ;(*p35)
"RTN","XWBTCPL",99,0)
 . . I '$$NEWJOB D QSND("reject") Q  ;(*p7,*p35)
"RTN","XWBTCPL",100,0)
 . . I XWBDEBUG>1 D LOG^XWBDLOG("JOB: "_MSG)
"RTN","XWBTCPL",101,0)
 . . ;Job a Server, X should be null
"RTN","XWBTCPL",102,0)
 . . J EN^XWBTCPC($P(MSG,"^",2),$P(MSG,"^",3),$P(DZ,"^"),XWBVER,$P(MSG,"^",4))::5 S %T=$T
"RTN","XWBTCPL",103,0)
 . . I %T D QSND("accept") ;(*p35)
"RTN","XWBTCPL",104,0)
 . . I '%T  D QSND("reject") ;(*p35)
"RTN","XWBTCPL",105,0)
 . ;
"RTN","XWBTCPL",106,0)
 . ; -- if the action is TCPdebug (when msg handler run interactively)
"RTN","XWBTCPL",107,0)
 . I $P(MSG,"^")="TCPdebug" D QSND("accept") ;(*p35)
"RTN","XWBTCPL",108,0)
 . ;
"RTN","XWBTCPL",109,0)
 . ; -- if the action is TCPshutdown, this listener will quit if the
"RTN","XWBTCPL",110,0)
 . ;    stop flag has been set.  This request comes from an M process.
"RTN","XWBTCPL",111,0)
 . I $P(MSG,"^")="TCPshutdown" S DONE=1 D QSND^XWBRW("ack")
"RTN","XWBTCPL",112,0)
 . D RELEASE(0) ;Now release the connection. (*p7*)
"RTN","XWBTCPL",113,0)
 . Q
"RTN","XWBTCPL",114,0)
 ; -- loop end
"RTN","XWBTCPL",115,0)
 ;
"RTN","XWBTCPL",116,0)
 S %=$$SEMAPHOR(XWBTSKT,"UNLOCK") ; destroy 'running flag'
"RTN","XWBTCPL",117,0)
 D LOG^XWBDLOG("Exit")
"RTN","XWBTCPL",118,0)
 D UPDTREC(XWBTSKT,6) ;updt RPC BROKER SITE PARAMETER record as STOPPED
"RTN","XWBTCPL",119,0)
 S $ETRAP="" ;(*p35) Turn off error trap
"RTN","XWBTCPL",120,0)
 IF XWBOS="DSM" C XWBTSKT ;Do Close last in case it gets an error
"RTN","XWBTCPL",121,0)
 Q
"RTN","XWBTCPL",122,0)
 ;
"RTN","XWBTCPL",123,0)
QSND(STR) ;Write output (*p35)
"RTN","XWBTCPL",124,0)
 D QSND^XWBRW(STR),LOG^XWBDLOG(STR)
"RTN","XWBTCPL",125,0)
 Q
"RTN","XWBTCPL",126,0)
 ;
"RTN","XWBTCPL",127,0)
ETRAP ; -- on trapped error, send error info to client
"RTN","XWBTCPL",128,0)
 N XWBERC,XWBERR S $ETRAP="D ^%ZTER J EN^XWBTCPL($G(XWBTSKT)) HALT"
"RTN","XWBTCPL",129,0)
 S XWBERC=$$EC^%ZOSV,XWBERR=$C(24)_"M  ERROR="_XWBERC_$C(13,10)_"LAST REF="_$$LGR^%ZOSV
"RTN","XWBTCPL",130,0)
 D ^%ZTER ;Record error and clear $ECODE
"RTN","XWBTCPL",131,0)
 D LOG^XWBDLOG("Error: "_$E(XWBERC,1,200))
"RTN","XWBTCPL",132,0)
 S RETRY=$G(RETRY)+1 H 3+(RETRY\5) ;(*p7*) Slow down but never stop
"RTN","XWBTCPL",133,0)
 ;Halt if DSM DUPNAME
"RTN","XWBTCPL",134,0)
 I XWBERC["F-DUPLNAM" D  HALT
"RTN","XWBTCPL",135,0)
 . S %=$$SEMAPHOR(XWBTSKT,"UNLOCK") ; destroy 'running flag'
"RTN","XWBTCPL",136,0)
 . D UPDTREC(XWBTSKT,6) ;updt RPC BROKER SITE PARAMETER record as STOPPED
"RTN","XWBTCPL",137,0)
 . Q
"RTN","XWBTCPL",138,0)
 S XWBDEBUG=$G(XWBDEBUG)
"RTN","XWBTCPL",139,0)
 ;Set new trap
"RTN","XWBTCPL",140,0)
 S $ETRAP="Q:($ESTACK&'$QUIT)  Q:$ESTACK -9 S $ECODE="""" G RESTART^XWBTCPL"
"RTN","XWBTCPL",141,0)
 ;
"RTN","XWBTCPL",142,0)
 I (XWBERC["READ")!(XWBERC["WRITE")!(XWBERC["SYSTEM-F") G ETRAPX
"RTN","XWBTCPL",143,0)
 IF XWBOS="DSM" D
"RTN","XWBTCPL",144,0)
 . I $D(XWBTLEN),XWBTLEN,XWBERC'["SYSTEM-F" D QSND(XWBERR) ;(p35)
"RTN","XWBTCPL",145,0)
 IF XWBOS="OpenM",XWBERC'["<WRITE>" D QSND(XWBERR) ;(*p7,35*)
"RTN","XWBTCPL",146,0)
 IF XWBOS="MSM" D QSND(XWBERR) ;(*p7,35*)
"RTN","XWBTCPL",147,0)
ETRAPX D RELEASE(1) ;Now close the connection. (*p7*)
"RTN","XWBTCPL",148,0)
 I XWBOS="DSM" H 15 ;Wait for device to close 
"RTN","XWBTCPL",149,0)
 S $ECODE=",U1," Q  ;Pass error up to pop stack.
"RTN","XWBTCPL",150,0)
 ;
"RTN","XWBTCPL",151,0)
FLUSH ;Flush the input buffer
"RTN","XWBTCPL",152,0)
 F  R X:0 Q:'$T
"RTN","XWBTCPL",153,0)
 Q
"RTN","XWBTCPL",154,0)
 ;
"RTN","XWBTCPL",155,0)
RELEASE(%) ;Now release the connection. (*p7*)
"RTN","XWBTCPL",156,0)
 ;Parameter is zero to Release, one to Close
"RTN","XWBTCPL",157,0)
 I XWBOS="DSM" D  Q  ;(*p35)
"RTN","XWBTCPL",158,0)
 . I $G(%) C XWBTSKT Q
"RTN","XWBTCPL",159,0)
 . U XWBTSKT:DISCONNECT ; release this socket
"RTN","XWBTCPL",160,0)
 I XWBOS="OpenM" D  Q  ;(*p35)
"RTN","XWBTCPL",161,0)
 . I $G(%) C XWBTDEV Q
"RTN","XWBTCPL",162,0)
 . W *-2 ;Release the socket
"RTN","XWBTCPL",163,0)
 I XWBOS="GTM" D  Q  ;(*p35)
"RTN","XWBTCPL",164,0)
 . I $G(%) C XWBTDEV Q
"RTN","XWBTCPL",165,0)
 . C XWBTDEV:(SOCKET=XWBTDEV("SOCKET")) ;release the socket
"RTN","XWBTCPL",166,0)
 I XWBOS="MSM" C 56
"RTN","XWBTCPL",167,0)
 Q
"RTN","XWBTCPL",168,0)
 ;
"RTN","XWBTCPL",169,0)
UPDTREC(XWBTSKT,STATE,XWBENV) ; -- update STATUS field and ^%ZIS X-ref of the
"RTN","XWBTCPL",170,0)
 ;RPC BROKER SITE PARAMETER file
"RTN","XWBTCPL",171,0)
 ;XWBTSKT: listener port
"RTN","XWBTCPL",172,0)
 N C,XWBOXIEN,XWBPOIEN,XWBFDA
"RTN","XWBTCPL",173,0)
 S C=",",U="^"
"RTN","XWBTCPL",174,0)
 I $G(XWBENV)'="" S Y=XWBENV
"RTN","XWBTCPL",175,0)
 E  D GETENV^%ZOSV ;get Y=UCI^VOL^NODE^BOXLOOKUP of current system
"RTN","XWBTCPL",176,0)
 ;I STATE=3 S ^%ZIS(8994.171,"RPCB Listener",$P(Y,U,2),$P(Y,U),$P(Y,U,4),XWBTSKT)=$J
"RTN","XWBTCPL",177,0)
 ;I STATE=6 K ^%ZIS(8994.171,"RPCB Listener",$P(Y,U,2),$P(Y,U),$P(Y,U,4),XWBTSKT)
"RTN","XWBTCPL",178,0)
 ;
"RTN","XWBTCPL",179,0)
 S XWBOXIEN=$$FIND1^DIC(8994.17,",1,","",$P(Y,U,4)) ;find rec for box
"RTN","XWBTCPL",180,0)
 S XWBPOIEN=$$FIND1^DIC(8994.171,C_XWBOXIEN_",1,","",XWBTSKT)
"RTN","XWBTCPL",181,0)
 D:XWBPOIEN>0  ;update STATUS field if entry was found
"RTN","XWBTCPL",182,0)
 . D FDA^DILF(8994.171,XWBPOIEN_C_XWBOXIEN_C_1_C,1,"R",STATE,"XWBFDA")
"RTN","XWBTCPL",183,0)
 . D FILE^DIE("","XWBFDA")
"RTN","XWBTCPL",184,0)
 Q
"RTN","XWBTCPL",185,0)
 ;
"RTN","XWBTCPL",186,0)
 ;
"RTN","XWBTCPL",187,0)
SEMAPHOR(XWBTSKT,XWBACT) ;Lock/Unlock listener semaphore
"RTN","XWBTCPL",188,0)
 ;XWBTSKT: listener port, XWBACT: "LOCK" | "UNLOCK" action to perform
"RTN","XWBTCPL",189,0)
 ;if LOCK is requested, it will be attempted with 1 sec timeout and if
"RTN","XWBTCPL",190,0)
 ;lock was obtained RESULT will be 1, otherwise it will be 0.  For
"RTN","XWBTCPL",191,0)
 ;unlock RESULT will always be 1.
"RTN","XWBTCPL",192,0)
 N RESULT
"RTN","XWBTCPL",193,0)
 S U="^",RESULT=1
"RTN","XWBTCPL",194,0)
 D GETENV^%ZOSV ;get Y=UCI^VOL^NODE^BOXLOOKUP of current system
"RTN","XWBTCPL",195,0)
 I XWBACT="LOCK" D
"RTN","XWBTCPL",196,0)
 . L +^%ZIS(8994.171,"RPCB Listener",$P(Y,U,2),$P(Y,U),$P(Y,U,4),XWBTSKT):1
"RTN","XWBTCPL",197,0)
 . S RESULT=$T
"RTN","XWBTCPL",198,0)
 E  L -^%ZIS(8994.171,"RPCB Listener",$P(Y,U,2),$P(Y,U),$P(Y,U,4),XWBTSKT)
"RTN","XWBTCPL",199,0)
 Q RESULT
"RTN","XWBTCPL",200,0)
 ;
"RTN","XWBTCPL",201,0)
NEWJOB() ;Check if OK to start a new job, Return 1 if OK, 0 if not OK.
"RTN","XWBTCPL",202,0)
 N X,Y,XQVOL,XUVOL
"RTN","XWBTCPL",203,0)
 S X=$O(^XTV(8989.3,1,4,"B",XWBVOL,0)),XUVOL=$S(X>0:^XTV(8989.3,1,4,X,0),1:"ROU^y^1"),XQVOL=XWBVOL
"RTN","XWBTCPL",204,0)
 S X=$$INHIBIT^XUSRB ;Returns 1 if new logons are inhibited.
"RTN","XWBTCPL",205,0)
 Q 'X
"RTN","XWBTCPM")
0^1^B53101617
"RTN","XWBTCPM",1,0)
XWBTCPM ;ISF/RWF - TCP/IP PROCESS HANDLER ;12/09/2004  08:38
"RTN","XWBTCPM",2,0)
 ;;1.1;RPC BROKER;**35**;Mar 28, 1997
"RTN","XWBTCPM",3,0)
 ;Based on: XWBTCPC & XWBTCPL, Modified by ISF/RWF
"RTN","XWBTCPM",4,0)
 ;Changed to be started by UCX or %ZISTCPS
"RTN","XWBTCPM",5,0)
 ;
"RTN","XWBTCPM",6,0)
DSM ;DSM called from ucx, % passed in with device.
"RTN","XWBTCPM",7,0)
 D ESET
"RTN","XWBTCPM",8,0)
 ;Open the device
"RTN","XWBTCPM",9,0)
 S XWBTDEV=% O XWBTDEV:(TCPDEV):60 ;Special UCX/DSM open
"RTN","XWBTCPM",10,0)
 ;Go find the connection type
"RTN","XWBTCPM",11,0)
 U XWBTDEV
"RTN","XWBTCPM",12,0)
 G CONNTYPE
"RTN","XWBTCPM",13,0)
 ;
"RTN","XWBTCPM",14,0)
CACHEVMS ;Cache'/VMS tcpip entry point, called from XWBTCP_START.COM file
"RTN","XWBTCPM",15,0)
 D ESET
"RTN","XWBTCPM",16,0)
 S XWBTDEV="SYS$NET"
"RTN","XWBTCPM",17,0)
 ; **Cache'/VMS specific code**
"RTN","XWBTCPM",18,0)
 O XWBTDEV::5
"RTN","XWBTCPM",19,0)
 X "U XWBTDEV:(::""-M"")" ;Packet mode like DSM
"RTN","XWBTCPM",20,0)
 G CONNTYPE
"RTN","XWBTCPM",21,0)
 ;
"RTN","XWBTCPM",22,0)
NT ;entry from ZISTCPS
"RTN","XWBTCPM",23,0)
 ;JOB LISTEN^%ZISTCPS("port","NT^XWBTCPM","stop code")
"RTN","XWBTCPM",24,0)
 D ESET
"RTN","XWBTCPM",25,0)
 S XWBTDEV=IO
"RTN","XWBTCPM",26,0)
 G CONNTYPE
"RTN","XWBTCPM",27,0)
 ;
"RTN","XWBTCPM",28,0)
GTMUCX(%) ;From ucx ZFOO
"RTN","XWBTCPM",29,0)
 ;If called from LISTEN^%ZISTCP(PORT,"GTM^XWBTCPM") S XWBTDEV=IO
"RTN","XWBTCPM",30,0)
 D ESET
"RTN","XWBTCPM",31,0)
 ;GTM specific code
"RTN","XWBTCPM",32,0)
 S @("$ZINTERRUPT=""I $$JOBEXAM^ZU($ZPOSITION)""")
"RTN","XWBTCPM",33,0)
 S XWBTDEV=% O %:(RECORDSIZE=512)
"RTN","XWBTCPM",34,0)
 G CONNTYPE
"RTN","XWBTCPM",35,0)
 ;
"RTN","XWBTCPM",36,0)
GTMLNX ;From Linux xinetd script
"RTN","XWBTCPM",37,0)
 D ESET
"RTN","XWBTCPM",38,0)
 ;GTM specific code
"RTN","XWBTCPM",39,0)
 S @("$ZINTERRUPT=""I $$JOBEXAM^ZU($ZPOSITION)""")
"RTN","XWBTCPM",40,0)
 S XWBTDEV=$P U XWBTDEV:(NOWRAP:RECORDSIZE=512)
"RTN","XWBTCPM",41,0)
 G CONNTYPE
"RTN","XWBTCPM",42,0)
 ;
"RTN","XWBTCPM",43,0)
ESET ;Set inital error trap
"RTN","XWBTCPM",44,0)
 S U="^",$ETRAP="D ^%ZTER H" ;Set up the error trap
"RTN","XWBTCPM",45,0)
 Q
"RTN","XWBTCPM",46,0)
 ;Find the type of connection and jump to the processing routine.
"RTN","XWBTCPM",47,0)
CONNTYPE ;
"RTN","XWBTCPM",48,0)
 N XWBDEBUG,XWBAPVER,XWBCLMAN,XWBENVL,XWBLOG,XWBOS,XWBPTYPE
"RTN","XWBTCPM",49,0)
 N XWBTBUF,XWBTIP,XWBTSKT,XWBVER,XWBWRAP,XWBSHARE,XWBT
"RTN","XWBTCPM",50,0)
 N SOCK,TYPE
"RTN","XWBTCPM",51,0)
 D INIT
"RTN","XWBTCPM",52,0)
 S XWB=$$BREAD^XWBRW(5,XWBTIME)
"RTN","XWBTCPM",53,0)
 D LOG("MSG format is "_XWB_" type "_$S(XWB="[XWB]":"NEW",XWB="{XWB}":"OLD",1:"Unk"))
"RTN","XWBTCPM",54,0)
 I XWB["[XWB]" G NEW
"RTN","XWBTCPM",55,0)
 I XWB["{XWB}" G OLD^XWBTCPM1
"RTN","XWBTCPM",56,0)
 ;I XWB["<XWB>" G M2M
"RTN","XWBTCPM",57,0)
 ;I XWB["???" G VISTALINK
"RTN","XWBTCPM",58,0)
 D LOG("Prefix not known: "_XWB)
"RTN","XWBTCPM",59,0)
 Q
"RTN","XWBTCPM",60,0)
 ;
"RTN","XWBTCPM",61,0)
NEWJOB() ;Check if OK to start a new job, Return 1 if OK, 0 if not OK.
"RTN","XWBTCPM",62,0)
 N X,Y,J,XWBVOL
"RTN","XWBTCPM",63,0)
 D GETENV^%ZOSV S XWBVOL=$P(Y,"^",2)
"RTN","XWBTCPM",64,0)
 S X=$O(^XTV(8989.3,1,4,"B",XWBVOL,0)),J=$S(X>0:^XTV(8989.3,1,4,X,0),1:"ROU^y^1")
"RTN","XWBTCPM",65,0)
 I $G(^%ZIS(14.5,"LOGON",XWBVOL)) Q 0 ;Check INHIBIT LOGONS?
"RTN","XWBTCPM",66,0)
 I $D(^%ZOSF("ACTJ")) X ^("ACTJ") I $P(J,U,3),($P(J,U,3)'>Y) Q 0
"RTN","XWBTCPM",67,0)
 Q 1
"RTN","XWBTCPM",68,0)
 ;
"RTN","XWBTCPM",69,0)
M2M ;
"RTN","XWBTCPM",70,0)
 Q
"RTN","XWBTCPM",71,0)
 ;
"RTN","XWBTCPM",72,0)
NEW ;New broker
"RTN","XWBTCPM",73,0)
 S U="^",DUZ=0,DUZ(0)="",XWBVER=1.108
"RTN","XWBTCPM",74,0)
 D SETTIME(1) ;Setup for sign-on timeout
"RTN","XWBTCPM",75,0)
 U XWBTDEV D
"RTN","XWBTCPM",76,0)
 . N XWB,ERR,NATIP
"RTN","XWBTCPM",77,0)
 . S ERR=$$PRSP^XWBPRS
"RTN","XWBTCPM",78,0)
 . S ERR=$$PRSM^XWBPRS
"RTN","XWBTCPM",79,0)
 . S MSG=$G(XWB(4,"CMD"))_U_$G(XWB(5,"P",0))_U_$G(XWB(5,"P",1))_U_$G(XWB(5,"P",2))
"RTN","XWBTCPM",80,0)
 . ;Get the peer and save that IP.
"RTN","XWBTCPM",81,0)
 . S NATIP=$$GETPEER^%ZOSV S:'$L(NATIP) NATIP=$P(MSG,"^",2)
"RTN","XWBTCPM",82,0)
 . I NATIP'=$P(MSG,"^",2) S $P(MSG,"^",2)=NATIP
"RTN","XWBTCPM",83,0)
 . Q
"RTN","XWBTCPM",84,0)
 S X=$$NEWJOB()
"RTN","XWBTCPM",85,0)
 I ($P(MSG,U)'="TCPConnect")!('X) D QSND^XWBRW("reject"),LOG("reject: "_MSG) Q
"RTN","XWBTCPM",86,0)
 D QSND^XWBRW("accept"),LOG("accept") ;Ack
"RTN","XWBTCPM",87,0)
 S IO("IP")=$P(MSG,U,2),XWBTSKT=$P(MSG,U,3),XWBCLMAN=$P(MSG,U,4)
"RTN","XWBTCPM",88,0)
 S XWBTIP=$G(IO("IP"))
"RTN","XWBTCPM",89,0)
 ;start RUM for Broker Handler XWB*1.1*5
"RTN","XWBTCPM",90,0)
 D LOGRSRC^%ZOSV("$BROKER HANDLER$",2,1)
"RTN","XWBTCPM",91,0)
 ;GTM
"RTN","XWBTCPM",92,0)
 I $G(XWBT("PCNT")) D
"RTN","XWBTCPM",93,0)
 . S X=$NA(^XUTL("XUSYS",$J,1)) L +@X:0
"RTN","XWBTCPM",94,0)
 . D COUNT^XUSCNT(1),SETLOCK^XUSCNT(X)
"RTN","XWBTCPM",95,0)
 ;We don't use a callback
"RTN","XWBTCPM",96,0)
 K XWB,CON,LEN,MSG ;Clean up
"RTN","XWBTCPM",97,0)
 ;Attempt to share license, Must have TCP port open first.
"RTN","XWBTCPM",98,0)
 U XWBTDEV D SHARELIC^%ZOSV(1)
"RTN","XWBTCPM",99,0)
 ;setup null device "NULL"
"RTN","XWBTCPM",100,0)
 S %ZIS="0H",IOP="NULL" D ^%ZIS S XWBNULL=IO I POP S XWBERROR="No NULL device" D ^%ZTER,EXIT Q
"RTN","XWBTCPM",101,0)
 D SAVDEV^%ZISUTL("XWBNULL")
"RTN","XWBTCPM",102,0)
 ;change process name
"RTN","XWBTCPM",103,0)
 D CHPRN("ip"_$P(XWBTIP,".",3,4)_":"_XWBTDEV)
"RTN","XWBTCPM",104,0)
 ;
"RTN","XWBTCPM",105,0)
RESTART ;The error trap returns to here
"RTN","XWBTCPM",106,0)
 N $ESTACK S $ETRAP="D ETRAP^XWBTCPM"
"RTN","XWBTCPM",107,0)
 S DT=$$DT^XLFDT,DTIME=30
"RTN","XWBTCPM",108,0)
 U XWBTDEV D MAIN
"RTN","XWBTCPM",109,0)
 D LOG("Exit: "_XWBTBUF)
"RTN","XWBTCPM",110,0)
 ;Turn off the error trap for the exit
"RTN","XWBTCPM",111,0)
 S $ETRAP=""
"RTN","XWBTCPM",112,0)
 D EXIT ;Logout
"RTN","XWBTCPM",113,0)
 K XWBR,XWBARY
"RTN","XWBTCPM",114,0)
 ;stop RUM for handler XWB*1.1*5
"RTN","XWBTCPM",115,0)
 D LOGRSRC^%ZOSV("$BROKER HANDLER$",2,2)
"RTN","XWBTCPM",116,0)
 D USE^%ZISUTL("XWBNULL"),CLOSE^%ZISUTL("XWBNULL")
"RTN","XWBTCPM",117,0)
 ;Close in the calling script
"RTN","XWBTCPM",118,0)
 K SOCK,TYPE,XWBSND,XWBTYPE,XWBRBUF
"RTN","XWBTCPM",119,0)
 Q
"RTN","XWBTCPM",120,0)
 ;
"RTN","XWBTCPM",121,0)
MAIN ; -- main message processing loop. debug at MAIN+1
"RTN","XWBTCPM",122,0)
 F  D  Q:XWBTBUF="#BYE#"
"RTN","XWBTCPM",123,0)
 . ;Setup
"RTN","XWBTCPM",124,0)
 . S XWBAPVER=0,XWBTBUF="",XWBTCMD="",XWBRBUF=""
"RTN","XWBTCPM",125,0)
 . K XWBR,XWBARY,XWBPRT
"RTN","XWBTCPM",126,0)
 . ; -- read client request
"RTN","XWBTCPM",127,0)
 . ;F XCNT=0:0 R XR#1:XWBTIME Q:$L(XR)&("[#"[XR)  I '$T S XCNT=XCNT+1 Q:XCNT>5
"RTN","XWBTCPM",128,0)
 . F XCNT=0:0 S XR=$$BREAD^XWBRW(1,XWBTIME,1) Q:$L(XR)&("[#"[XR)  I '$L(XR) S XCNT=XCNT+1 Q:XCNT>5
"RTN","XWBTCPM",129,0)
 . I XCNT>5 D LOG("Timeout: "_XCNT) S XWBTBUF="#BYE#" Q
"RTN","XWBTCPM",130,0)
 . S XR=XR_$$BREAD^XWBRW(4)
"RTN","XWBTCPM",131,0)
 . I XR="#BYE#" D  Q  ;Check for exit
"RTN","XWBTCPM",132,0)
 . . D QSND^XWBRW("#BYE#"),LOG("BYE CMD") S XWBTBUF="#BYE#"
"RTN","XWBTCPM",133,0)
 . . Q
"RTN","XWBTCPM",134,0)
 . S TYPE=(XR="[XWB]")  ;check HDR
"RTN","XWBTCPM",135,0)
 . I 'TYPE D LOG("Bad Header: "_XR) Q
"RTN","XWBTCPM",136,0)
 . D CALLP^XWBPRS(.XWBR,$G(XWBDEBUG)) ;Read the NEW Msg parameters and call RPC
"RTN","XWBTCPM",137,0)
 . IF XWBTCMD="#BYE#" D  Q
"RTN","XWBTCPM",138,0)
 . . D QSND^XWBRW("#BYE#"),LOG("BYE CMD") S XWBTBUF=XWBTCMD
"RTN","XWBTCPM",139,0)
 . . Q
"RTN","XWBTCPM",140,0)
 . U XWBTDEV
"RTN","XWBTCPM",141,0)
 . S XWBPTYPE=$S('$D(XWBPTYPE):1,XWBPTYPE<1:1,XWBPTYPE>6:1,1:XWBPTYPE)
"RTN","XWBTCPM",142,0)
 . ;I $G(XWBPRT) D RETURN^XWBPRS2 Q  ;New msg return
"RTN","XWBTCPM",143,0)
 . I '$G(XWBPRT) D SND^XWBRW ;Return data,flush buffer
"RTN","XWBTCPM",144,0)
 Q  ;End Of Main
"RTN","XWBTCPM",145,0)
 ;
"RTN","XWBTCPM",146,0)
 ;
"RTN","XWBTCPM",147,0)
ETRAP ; -- on trapped error, send error info to client
"RTN","XWBTCPM",148,0)
 N XWBERC,XWBERR
"RTN","XWBTCPM",149,0)
 ;Change trapping during trap.
"RTN","XWBTCPM",150,0)
 S $ETRAP="D ^%ZTER,EXIT^XWBTCPM HALT"
"RTN","XWBTCPM",151,0)
 S XWBERC=$E($$EC^%ZOSV,1,200),XWBERR="M  ERROR="_XWBERC_$C(13,10)_"LAST REF="_$$LGR^%ZOSV
"RTN","XWBTCPM",152,0)
 I $EC["U411" S XWBERROR="U411",XWBSEC="",XWBERR="Data Transfer Error to Server"
"RTN","XWBTCPM",153,0)
 D ^%ZTER ;%ZTER clears $ZE and $ZCODE
"RTN","XWBTCPM",154,0)
 D LOG("In ETRAP: "_XWBERC) ;Log
"RTN","XWBTCPM",155,0)
 I (XWBERC["READ")!(XWBERC["WRITE")!(XWBERC["SYSTEM-F") D EXIT HALT
"RTN","XWBTCPM",156,0)
 U XWBTDEV
"RTN","XWBTCPM",157,0)
 I $G(XWBT("PCNT")) L ^XUTL("XUSYS",$J,0)
"RTN","XWBTCPM",158,0)
 E  L  ;Clear Locks
"RTN","XWBTCPM",159,0)
 ;I XWBOS'="DSM" D
"RTN","XWBTCPM",160,0)
 S XWBPTYPE=1 ;So SNDERR won't check XWBR
"RTN","XWBTCPM",161,0)
 ;D SNDERR^XWBRW,WRITE^XWBRW($C(24)_XWBERR_$C(4))
"RTN","XWBTCPM",162,0)
 D ESND^XWBRW($C(24)_XWBERR_$C(4))
"RTN","XWBTCPM",163,0)
 S $ETRAP="Q:($ESTACK&'$QUIT)  Q:$ESTACK -9 S $ECODE="""" D CLEANP^XWBTCPM G RESTART^XWBTCPM",$ECODE=",U99,"
"RTN","XWBTCPM",164,0)
 Q
"RTN","XWBTCPM",165,0)
 ;
"RTN","XWBTCPM",166,0)
CLEANP ;Clean up the partion
"RTN","XWBTCPM",167,0)
 N XWBTDEV,XWBNULL D KILL^XUSCLEAN
"RTN","XWBTCPM",168,0)
 Q
"RTN","XWBTCPM",169,0)
 ;
"RTN","XWBTCPM",170,0)
STYPE(X,WRAP) ;For backward compatability only
"RTN","XWBTCPM",171,0)
 I $D(WRAP) Q $$RTRNFMT^XWBLIB($G(X),WRAP)
"RTN","XWBTCPM",172,0)
 Q $$RTRNFMT^XWBLIB(X)
"RTN","XWBTCPM",173,0)
 ;
"RTN","XWBTCPM",174,0)
BREAD(L,T) ;read tcp buffer, L is length
"RTN","XWBTCPM",175,0)
 Q $$BREAD^XWBRW(L,$G(T))
"RTN","XWBTCPM",176,0)
 ;
"RTN","XWBTCPM",177,0)
CHPRN(N) ;change process name
"RTN","XWBTCPM",178,0)
 ;Change process name to N
"RTN","XWBTCPM",179,0)
 D SETNM^%ZOSV($E(N,1,15))
"RTN","XWBTCPM",180,0)
 Q
"RTN","XWBTCPM",181,0)
 ;
"RTN","XWBTCPM",182,0)
SETTIME(%) ;Set the Read timeout 0=RPC, 1=sign-on
"RTN","XWBTCPM",183,0)
 S XWBTIME=$S($G(%):90,$G(XWBVER)>1.105:$$BAT^XUPARAM,1:36000),XWBTIME(1)=2
"RTN","XWBTCPM",184,0)
 I $G(%) S XWBTIME=$S($G(XWBVER)>1.1:90,1:36000)
"RTN","XWBTCPM",185,0)
 Q
"RTN","XWBTCPM",186,0)
TIMEOUT ;Do this on MAIN  loop timeout
"RTN","XWBTCPM",187,0)
 I $G(DUZ)>0 D QSND^XWBRW("#BYE#") Q
"RTN","XWBTCPM",188,0)
 ;Sign-on timeout
"RTN","XWBTCPM",189,0)
 S XWBR(0)=0,XWBR(1)=1,XWBR(2)="",XWBR(3)="TIME-OUT",XWBPTYPE=2
"RTN","XWBTCPM",190,0)
 D SND^XWBRW
"RTN","XWBTCPM",191,0)
 Q
"RTN","XWBTCPM",192,0)
 ;
"RTN","XWBTCPM",193,0)
OS() ;Return the OS
"RTN","XWBTCPM",194,0)
 Q $S(^%ZOSF("OS")["DSM":"DSM",^("OS")["UNIX":"UNIX",^("OS")["OpenM":"OpenM",1:"MSM")
"RTN","XWBTCPM",195,0)
 ;
"RTN","XWBTCPM",196,0)
INIT ;Setup
"RTN","XWBTCPM",197,0)
 S U="^",XWBTIME=10,XWBOS=$$OS,XWBDEBUG=0,XWBRBUF=""
"RTN","XWBTCPM",198,0)
 S XWBDEBUG=$$GET^XPAR("SYS","XWBDEBUG")
"RTN","XWBTCPM",199,0)
 S XWBT("BF")=$S(XWBOS="GT.M":"#",1:"!")
"RTN","XWBTCPM",200,0)
 S XWBT("PCNT")=0 I XWBOS="GT.M",$L($T(^XUSCNT)) S XWBT("PCNT")=1
"RTN","XWBTCPM",201,0)
 D LOGSTART^XWBDLOG("XWBTCPM")
"RTN","XWBTCPM",202,0)
 Q
"RTN","XWBTCPM",203,0)
 ;
"RTN","XWBTCPM",204,0)
DEBUG ;Entry point for debug, Build a server to get the connect
"RTN","XWBTCPM",205,0)
 ;DSM sample;ZDEBUG ON S $ZB(1)="SERV+1^XWBTCPM:1",$ZB="ETRAP+1^XWBTCPM:1"
"RTN","XWBTCPM",206,0)
 W !,"Before running this entry point set your debugger to stop at"
"RTN","XWBTCPM",207,0)
 W !,"the place you want to debug. Some spots to use:"
"RTN","XWBTCPM",208,0)
 W !,"'SERV+1^XWBTCPM', 'MAIN+1^XWBTCPM' or 'CAPI+1^XWBPRS.'",!
"RTN","XWBTCPM",209,0)
 W !,"or location of your choice.",!
"RTN","XWBTCPM",210,0)
 W !,"IP Socket to Listen on: " R SOCK:300 Q:'$T!(SOCK["^")
"RTN","XWBTCPM",211,0)
 ;Use %ZISTCP to do a single server
"RTN","XWBTCPM",212,0)
 D LISTEN^%ZISTCP(SOCK,"SERV^XWBTCPM")
"RTN","XWBTCPM",213,0)
 U $P W !,"Done"
"RTN","XWBTCPM",214,0)
 Q
"RTN","XWBTCPM",215,0)
SERV ;Callback from the server
"RTN","XWBTCPM",216,0)
 S XWBTDEV=IO,XWBTIME(1)=3600 D INIT
"RTN","XWBTCPM",217,0)
 S XWBDEBUG=1,MSG=$$BREAD^XWBRW(5,60) ;R MSG#5
"RTN","XWBTCPM",218,0)
 D NEW
"RTN","XWBTCPM",219,0)
 S IO("C")=1 ;Cause the Listenr to stop
"RTN","XWBTCPM",220,0)
 Q
"RTN","XWBTCPM",221,0)
 ;
"RTN","XWBTCPM",222,0)
EXIT ;Close out
"RTN","XWBTCPM",223,0)
 I $G(DUZ) D LOGOUT^XUSRB
"RTN","XWBTCPM",224,0)
 I $G(XWBT("PCNT")) D COUNT^XUSCNT(-1)
"RTN","XWBTCPM",225,0)
 Q
"RTN","XWBTCPM",226,0)
 ;
"RTN","XWBTCPM",227,0)
LOG(MSG) ;Record Debug Info
"RTN","XWBTCPM",228,0)
 D:$G(XWBDEBUG) LOG^XWBDLOG(MSG)
"RTN","XWBTCPM",229,0)
 Q
"RTN","XWBTCPM",230,0)
 ;
"RTN","XWBTCPM1")
0^4^B7265734
"RTN","XWBTCPM1",1,0)
XWBTCPM1 ;ISF/RWF - Support for XWBTCPM ;05/20/2004  10:14
"RTN","XWBTCPM1",2,0)
 ;;1.1;RPC BROKER;**35**;Mar 28, 1997
"RTN","XWBTCPM1",3,0)
 Q
"RTN","XWBTCPM1",4,0)
ZISTCP(XWBTSKT) ;Start ZISTCPS listener
"RTN","XWBTCPM1",5,0)
 ;
"RTN","XWBTCPM1",6,0)
 N XWBENV,XWBVOL,Y
"RTN","XWBTCPM1",7,0)
 D GETENV^%ZOSV S XWBENV=Y,XWBVOL=$P(Y,"^",2)
"RTN","XWBTCPM1",8,0)
 Q:'$$SEMAPHOR^XWBTCPL(XWBTSKT,"LOCK")  ;quit if job is already running
"RTN","XWBTCPM1",9,0)
 D UPDTREC^XWBTCPL(XWBTSKT,3) ;updt RPC BROKER SITE PARAMETER record as RUNNING
"RTN","XWBTCPM1",10,0)
 D MARKER^XWBTCP(XWBTSKT,-1) ;Clear marker
"RTN","XWBTCPM1",11,0)
 ;
"RTN","XWBTCPM1",12,0)
 D LISTEN^%ZISTCPS(XWBTSKT,"NT^XWBTCPM","D STAT^XWBTCPM1("_XWBTSKT_")")
"RTN","XWBTCPM1",13,0)
 ;
"RTN","XWBTCPM1",14,0)
 S %=$$SEMAPHOR^XWBTCPL(XWBTSKT,"UNLOCK") ; destroy 'running flag'
"RTN","XWBTCPM1",15,0)
 D UPDTREC^XWBTCPL(XWBTSKT,6) ;updt RPC BROKER SITE PARAMETER record as STOPPED
"RTN","XWBTCPM1",16,0)
 Q
"RTN","XWBTCPM1",17,0)
 ;
"RTN","XWBTCPM1",18,0)
OLD ;Call the old style broker
"RTN","XWBTCPM1",19,0)
 ;XWBRBUF setup in XWBTCPM
"RTN","XWBTCPM1",20,0)
 N XWBTCNT
"RTN","XWBTCPM1",21,0)
 S XWBTCNT=0
"RTN","XWBTCPM1",22,0)
 D READCONN ;Get the rest of the connect msg
"RTN","XWBTCPM1",23,0)
 ; -- msg should be:  action^client IP^client port^token
"RTN","XWBTCPM1",24,0)
 I $P(MSG,"^")="TCPconnect" D
"RTN","XWBTCPM1",25,0)
 . N DZ,%T,NATIP S DZ="",%T=0
"RTN","XWBTCPM1",26,0)
 . ;Get the peer and use that IP, Allow use thru a NAT box.
"RTN","XWBTCPM1",27,0)
 . S NATIP=$$GETPEER^%ZOSV S:'$L(NATIP) NATIP=$P(MSG,"^",2)
"RTN","XWBTCPM1",28,0)
 . I NATIP'=$P(MSG,"^",2) S $P(MSG,"^",2)=NATIP
"RTN","XWBTCPM1",29,0)
 . I '$$NEWJOB^XWBTCPM D LOG("No New Jobs"),QSND("reject") Q
"RTN","XWBTCPM1",30,0)
 . ;Keep the current job & Device.
"RTN","XWBTCPM1",31,0)
 . ;just call the old server code. Uses a extra socket.
"RTN","XWBTCPM1",32,0)
 . D QSND("accept"),LOG("accept")
"RTN","XWBTCPM1",33,0)
 . D EN^XWBTCPC($P(MSG,"^",2),$P(MSG,"^",3),$P(DZ,"^"),XWBVER,$P(MSG,"^",4))
"RTN","XWBTCPM1",34,0)
 Q
"RTN","XWBTCPM1",35,0)
 ;
"RTN","XWBTCPM1",36,0)
READCONN ;Read the rest of the connect message
"RTN","XWBTCPM1",37,0)
 N CON,VL,LEN,MSG2
"RTN","XWBTCPM1",38,0)
 S CON=$$BREAD(6,XWBTIME) I CON="" S CON="Timeout" D LOG(CON) Q
"RTN","XWBTCPM1",39,0)
 I $E(CON,6)="|" D
"RTN","XWBTCPM1",40,0)
 . S VL=$$BREAD(1),VL=$A(VL)
"RTN","XWBTCPM1",41,0)
 . S XWBVER=$$BREAD(VL)
"RTN","XWBTCPM1",42,0)
 . S LEN=$$BREAD(5)
"RTN","XWBTCPM1",43,0)
 . S MSG=$$BREAD(+LEN)
"RTN","XWBTCPM1",44,0)
 E  S X=$E(CON,6),LEN=$E(CON,1,5)-1,MSG2=$$BREAD(LEN),MSG=X_MSG2,XWBVER=0
"RTN","XWBTCPM1",45,0)
 D LOG("Connect: "_MSG)
"RTN","XWBTCPM1",46,0)
 Q
"RTN","XWBTCPM1",47,0)
 ;
"RTN","XWBTCPM1",48,0)
BREAD(L,TO) ;Buffer read
"RTN","XWBTCPM1",49,0)
 S XWBTIME(1)=$G(TO,5)
"RTN","XWBTCPM1",50,0)
 Q $$BREAD^XWBRW(L)
"RTN","XWBTCPM1",51,0)
 ;
"RTN","XWBTCPM1",52,0)
QSND(H) ;Quick send
"RTN","XWBTCPM1",53,0)
 D QSND^XWBRW(H)
"RTN","XWBTCPM1",54,0)
 Q
"RTN","XWBTCPM1",55,0)
LOG(H) ;
"RTN","XWBTCPM1",56,0)
 D:$G(XWBDEBUG) LOG^XWBDLOG(H)
"RTN","XWBTCPM1",57,0)
 Q
"RTN","XWBTCPM1",58,0)
 ;
"RTN","XWBTCPM1",59,0)
NODE(P) ;Get Listener node, XWBENV must be set first
"RTN","XWBTCPM1",60,0)
 N X,Y,BV
"RTN","XWBTCPM1",61,0)
 I '$D(XWBENV) D GETENV^%ZOSV S XWBENV=Y
"RTN","XWBTCPM1",62,0)
 S BV=$P(XWBENV,"^",4)
"RTN","XWBTCPM1",63,0)
 S IX1=$O(^%ZIS(14.7,"B",BV,0)) I IX1'>0 Q "Box-Vol 1"
"RTN","XWBTCPM1",64,0)
 S IX1=$O(^XWB(8994.1,1,7,"B",IX1,0)) I IX1'>0 Q "Box-Vol 2"
"RTN","XWBTCPM1",65,0)
 S IX2=$O(^XWB(8994.1,1,7,IX1,1,"B",P,0)) I IX2'>0 Q "Port"
"RTN","XWBTCPM1",66,0)
 S X=$G(^XWB(8994.1,1,7,IX1,1,IX2,0))
"RTN","XWBTCPM1",67,0)
 Q X
"RTN","XWBTCPM1",68,0)
 ;
"RTN","XWBTCPM1",69,0)
STAT(P) ;Check if should stop.
"RTN","XWBTCPM1",70,0)
 ;Called from ZRULE in %ZISTCPS
"RTN","XWBTCPM1",71,0)
 N X
"RTN","XWBTCPM1",72,0)
 S X=$$NODE(P)
"RTN","XWBTCPM1",73,0)
 S ZISQUIT=($P(X,"^",2)>3) ;Status Stop
"RTN","XWBTCPM1",74,0)
 Q
"SEC","^DIC",8994.1,8994.1,0,"AUDIT")
@
"SEC","^DIC",8994.1,8994.1,0,"DD")
@
"SEC","^DIC",8994.1,8994.1,0,"DEL")
@
"SEC","^DIC",8994.1,8994.1,0,"LAYGO")
@
"SEC","^DIC",8994.1,8994.1,0,"RD")
@
"SEC","^DIC",8994.1,8994.1,0,"WR")
@
"VER")
8.0^22.0
"^DD",8994.1,8994.1,0)
FIELD^^2^3
"^DD",8994.1,8994.1,0,"DDA")
N
"^DD",8994.1,8994.1,0,"DT")
3030331
"^DD",8994.1,8994.1,0,"IX","B",8994.1,.01)

"^DD",8994.1,8994.1,0,"IX","C",8994.171,1)

"^DD",8994.1,8994.1,0,"NM","RPC BROKER SITE PARAMETERS")

"^DD",8994.1,8994.1,0,"VRPK")
XWB
"^DD",8994.1,8994.1,.01,0)
DOMAIN NAME^RP4.2'X^DIC(4.2,^0;1^S DINUM=1
"^DD",8994.1,8994.1,.01,1,0)
^.1
"^DD",8994.1,8994.1,.01,1,1,0)
8994.1^B
"^DD",8994.1,8994.1,.01,1,1,1)
S ^XWB(8994.1,"B",$E(X,1,30),DA)=""
"^DD",8994.1,8994.1,.01,1,1,2)
K ^XWB(8994.1,"B",$E(X,1,30),DA)
"^DD",8994.1,8994.1,.01,3)

"^DD",8994.1,8994.1,.01,21,0)
^^4^4^2960829^^^^
"^DD",8994.1,8994.1,.01,21,1,0)
This is the name of this installation of the RPC Broker, as it is known
"^DD",8994.1,8994.1,.01,21,2,0)
to the rest of the network. It must appear in the DOMAIN file.
"^DD",8994.1,8994.1,.01,21,3,0)
This name applies to all CPUs or Volume sets which access this ^XWB
"^DD",8994.1,8994.1,.01,21,4,0)
global.
"^DD",8994.1,8994.1,.01,"DT")
2960829
"^DD",8994.1,8994.1,2,0)
MAIL GROUP FOR ALERTS^P3.8'^XMB(3.8,^0;2^Q
"^DD",8994.1,8994.1,2,21,0)
^^1^1^3000810^
"^DD",8994.1,8994.1,2,21,1,0)
This field points to the Mail Group file
"^DD",8994.1,8994.1,2,"DT")
3000810
"^DD",8994.1,8994.1,7,0)
LISTENER^8994.17P^^7;0
"^DD",8994.1,8994.1,7,21,0)
^^4^4^2991116^^^^
"^DD",8994.1,8994.1,7,21,1,0)
This field contains all the information that the Broker needs to run a
"^DD",8994.1,8994.1,7,21,2,0)
background process, which accepts incoming connection requests.  The listener
"^DD",8994.1,8994.1,7,21,3,0)
doesn't execute the client's RPCs.  The listener starts up other processes
"^DD",8994.1,8994.1,7,21,4,0)
as handlers, which run RPCs.
"^DD",8994.1,8994.17,0)
LISTENER SUB-FIELD^^1^2
"^DD",8994.1,8994.17,0,"DT")
3030331
"^DD",8994.1,8994.17,0,"IX","B",8994.17,.01)

"^DD",8994.1,8994.17,0,"NM","LISTENER")

"^DD",8994.1,8994.17,0,"UP")
8994.1
"^DD",8994.1,8994.17,.01,0)
BOX-VOLUME PAIR^P14.7'^%ZIS(14.7,^0;1^Q
"^DD",8994.1,8994.17,.01,1,0)
^.1
"^DD",8994.1,8994.17,.01,1,1,0)
8994.17^B
"^DD",8994.1,8994.17,.01,1,1,1)
S ^XWB(8994.1,DA(1),7,"B",$E(X,1,30),DA)=""
"^DD",8994.1,8994.17,.01,1,1,2)
K ^XWB(8994.1,DA(1),7,"B",$E(X,1,30),DA)
"^DD",8994.1,8994.17,.01,21,0)
^^1^1^2991116^^^^
"^DD",8994.1,8994.17,.01,21,1,0)
This field determines on what CPU and volume set the listener should run.
"^DD",8994.1,8994.17,.01,"DEL",1,0)
I $G(XWBCHK)'="ALLOW"
"^DD",8994.1,8994.17,.01,"DT")
2991116
"^DD",8994.1,8994.17,1,0)
PORT^8994.171^^1;0
"^DD",8994.1,8994.17,1,21,0)
^^10^10^2991116^
"^DD",8994.1,8994.17,1,21,1,0)
This is the TCP/IP port that the listener should monitor for incoming
"^DD",8994.1,8994.17,1,21,2,0)
connection requests.  This is the port which a client should use to
"^DD",8994.1,8994.17,1,21,3,0)
connect to a server.
"^DD",8994.1,8994.17,1,21,4,0)
 
"^DD",8994.1,8994.17,1,21,5,0)
Don't use a port that is already in use on the CPU where you want to run
"^DD",8994.1,8994.17,1,21,6,0)
the listener.  No two processes can share the same TCP/IP port on the
"^DD",8994.1,8994.17,1,21,7,0)
same CPU.
"^DD",8994.1,8994.17,1,21,8,0)
 
"^DD",8994.1,8994.17,1,21,9,0)
Typically, port numbers bellow 5000 are reserved for various common TCP/IP
"^DD",8994.1,8994.17,1,21,10,0)
services.  So you should use port numbers 9000 and above.
"^DD",8994.1,8994.171,0)
PORT SUB-FIELD^^2^4
"^DD",8994.1,8994.171,0,"DT")
3030331
"^DD",8994.1,8994.171,0,"IX","B",8994.171,.01)

"^DD",8994.1,8994.171,0,"NM","PORT")

"^DD",8994.1,8994.171,0,"UP")
8994.17
"^DD",8994.1,8994.171,.01,0)
PORT^NJ5,0^^0;1^K:+X'=X!(X>32000)!(X<9000)!(X?.E1"."1N.N) X
"^DD",8994.1,8994.171,.01,1,0)
^.1
"^DD",8994.1,8994.171,.01,1,1,0)
8994.171^B
"^DD",8994.1,8994.171,.01,1,1,1)
S ^XWB(8994.1,DA(2),7,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",8994.1,8994.171,.01,1,1,2)
K ^XWB(8994.1,DA(2),7,DA(1),1,"B",$E(X,1,30),DA)
"^DD",8994.1,8994.171,.01,1,2,0)
^^TRIGGER^8994.171^1
"^DD",8994.1,8994.171,.01,1,2,1)
K DIV S DIV=X,D0=DA(2),DIV(0)=D0,D1=DA(1),DIV(1)=D1,D2=DA,DIV(2)=D2 S Y(1)=$S($D(^XWB(8994.1,D0,7,D1,1,D2,0)):^(0),1:"") S X=$P(Y(1),U,2),X=X S DIU=X K Y S X=DIV S X="6" X ^DD(8994.171,.01,1,2,1.4)
"^DD",8994.1,8994.171,.01,1,2,1.4)
S DIH=$S($D(^XWB(8994.1,DIV(0),7,DIV(1),1,DIV(2),0)):^(0),1:""),DIV=X S $P(^(0),U,2)=DIV,DIH=8994.171,DIG=1 D ^DICR:$O(^DD(DIH,DIG,1,0))>0
"^DD",8994.1,8994.171,.01,1,2,2)
Q
"^DD",8994.1,8994.171,.01,1,2,"%D",0)
^^6^6^2960829^^
"^DD",8994.1,8994.171,.01,1,2,"%D",1,0)
This TRIGGER Xref initializes the STATUS field of the newly entered port
"^DD",8994.1,8994.171,.01,1,2,"%D",2,0)
to 6 (internal value of STOPPED).
"^DD",8994.1,8994.171,.01,1,2,"%D",3,0)

"^DD",8994.1,8994.171,.01,1,2,"%D",4,0)
This Xref is on the PORT (.01) field of the PORT (1) multiple.
"^DD",8994.1,8994.171,.01,1,2,"%D",5,0)
The SET logic is "6".
"^DD",8994.1,8994.171,.01,1,2,"%D",6,0)
No KILL logic.
"^DD",8994.1,8994.171,.01,1,2,"CREATE VALUE")
"6"
"^DD",8994.1,8994.171,.01,1,2,"DELETE VALUE")
NO EFFECT
"^DD",8994.1,8994.171,.01,1,2,"DT")
2960829
"^DD",8994.1,8994.171,.01,1,2,"FIELD")
STATUS
"^DD",8994.1,8994.171,.01,3)
Type a Number between 9000 and 32000, 0 Decimal Digits
"^DD",8994.1,8994.171,.01,"DT")
2991116
"^DD",8994.1,8994.171,.5,0)
TYPE OF LISTENER^S^0:Original;1:New Style;^0;3^Q
"^DD",8994.1,8994.171,.5,3)

"^DD",8994.1,8994.171,.5,21,0)
^^3^3^3030331^
"^DD",8994.1,8994.171,.5,21,1,0)
This is a flag to tell a Cache/NT site what kind of RPCBroker listener 
"^DD",8994.1,8994.171,.5,21,2,0)
to start.  It should not be needed for other types of RPCBroker listeners 
"^DD",8994.1,8994.171,.5,21,3,0)
because they will be under the control of TCPIP service.
"^DD",8994.1,8994.171,.5,"DT")
3030331
"^DD",8994.1,8994.171,1,0)
STATUS^*S^1:START;2:STARTING;3:RUNNING;4:STOP;5:STOPPING;6:STOPPED;^0;2^Q
"^DD",8994.1,8994.171,1,1,0)
^.1
"^DD",8994.1,8994.171,1,1,1,0)
8994.1^C^MUMPS
"^DD",8994.1,8994.171,1,1,1,1)
D STATCHG^XWBTCP(.DA,X)
"^DD",8994.1,8994.171,1,1,1,2)
Q
"^DD",8994.1,8994.171,1,1,1,"DT")
2960829
"^DD",8994.1,8994.171,1,12)
You can only set STATUS to START or STOP.  All other settings are controlled by the RPC Broker itself.
"^DD",8994.1,8994.171,1,12.1)
S DIC("S")="I $$STATSCRN^XWBTCP(Y)"
"^DD",8994.1,8994.171,1,"DT")
2960930
"^DD",8994.1,8994.171,2,0)
CONTROLLED BY LISTENER STARTER^S^0:NO;1:YES;^0;4^Q
"^DD",8994.1,8994.171,2,21,0)
^^9^9^2991116^^^^
"^DD",8994.1,8994.171,2,21,1,0)
If you want the Broker listener to start listening on this CPU-port-UCI
"^DD",8994.1,8994.171,2,21,2,0)
when the XWB LISTENER STARTER option is run, enter YES.  All of the
"^DD",8994.1,8994.171,2,21,3,0)
listener entries in this file that have CONTROLLED BY LISTENER STARTER
"^DD",8994.1,8994.171,2,21,4,0)
set to YES will be started when XWB LISTENER STARTER option is run.
"^DD",8994.1,8994.171,2,21,5,0)

"^DD",8994.1,8994.171,2,21,6,0)
Hint: XWB LISTENER STARTER option may be used to start all of the listeners
"^DD",8994.1,8994.171,2,21,7,0)
      you need automatically when the Task Manager is started.  Use the
"^DD",8994.1,8994.171,2,21,8,0)
      Schedule/Unschedule Options option.  In the SPECIAL QUEUEING field
"^DD",8994.1,8994.171,2,21,9,0)
      enter STARTUP.  Leave all other fields empty.
"^DD",8994.1,8994.171,2,"DT")
2961011
"^DIC",8994.1,8994.1,0)
RPC BROKER SITE PARAMETERS^8994.1
"^DIC",8994.1,8994.1,0,"GL")
^XWB(8994.1,
"^DIC",8994.1,8994.1,"%",0)
^1.005^1^1
"^DIC",8994.1,8994.1,"%",1,0)
XWB
"^DIC",8994.1,8994.1,"%","B","XWB",1)

"^DIC",8994.1,8994.1,"%D",0)
^^2^2^2960829^^^
"^DIC",8994.1,8994.1,"%D",1,0)
This file holds the site parameters for this installation of the RPC Broker.
"^DIC",8994.1,8994.1,"%D",2,0)
It will have only one entry -- the domain name of the installation site.
"^DIC",8994.1,"B","RPC BROKER SITE PARAMETERS",8994.1)

**END**
**END**
