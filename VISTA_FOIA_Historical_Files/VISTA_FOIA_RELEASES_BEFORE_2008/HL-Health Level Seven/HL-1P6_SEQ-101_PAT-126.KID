Released HL*1.6*126 SEQ #101
Extracted from mail message
**KIDS**:HL*1.6*126^

**INSTALL NAME**
HL*1.6*126
"BLD",838,0)
HL*1.6*126^HEALTH LEVEL SEVEN^0^3050921^y
"BLD",838,1,0)
^^1^1^3050131^^
"BLD",838,1,1,0)
HL7 2.0
"BLD",838,4,0)
^9.64PA^779.4^7
"BLD",838,4,777,0)
777
"BLD",838,4,777,222)
y^n^f^^^^n
"BLD",838,4,778,0)
778
"BLD",838,4,778,222)
y^n^f^^^^n
"BLD",838,4,779.1,0)
779.1
"BLD",838,4,779.1,222)
y^n^f^^^^n
"BLD",838,4,779.2,0)
779.2
"BLD",838,4,779.2,222)
y^n^f^^^^n
"BLD",838,4,779.3,0)
779.3
"BLD",838,4,779.3,222)
y^n^f^^y^^y^a^n
"BLD",838,4,779.4,0)
779.4
"BLD",838,4,779.4,222)
y^y^f^^^^n
"BLD",838,4,870,0)
870
"BLD",838,4,870,222)
y^n^f^^^^n
"BLD",838,4,"B",777,777)

"BLD",838,4,"B",778,778)

"BLD",838,4,"B",779.1,779.1)

"BLD",838,4,"B",779.2,779.2)

"BLD",838,4,"B",779.3,779.3)

"BLD",838,4,"B",779.4,779.4)

"BLD",838,4,"B",870,870)

"BLD",838,"ABPKG")
n
"BLD",838,"INID")
^n
"BLD",838,"INIT")
HLOPOST
"BLD",838,"KRN",0)
^9.67PA^8989.52^19
"BLD",838,"KRN",.4,0)
.4
"BLD",838,"KRN",.401,0)
.401
"BLD",838,"KRN",.402,0)
.402
"BLD",838,"KRN",.402,"NM",0)
^9.68A^1^1
"BLD",838,"KRN",.402,"NM",1,0)
HLOAPREG    FILE #779.2^779.2^0
"BLD",838,"KRN",.402,"NM","B","HLOAPREG    FILE #779.2",1)

"BLD",838,"KRN",.403,0)
.403
"BLD",838,"KRN",.403,"NM",0)
^9.68A^1^1
"BLD",838,"KRN",.403,"NM",1,0)
HL7 LOGICAL LINK    FILE #870^870^0
"BLD",838,"KRN",.403,"NM","B","HL7 LOGICAL LINK    FILE #870",1)

"BLD",838,"KRN",.5,0)
.5
"BLD",838,"KRN",.5,"NM",0)
^9.68A^^
"BLD",838,"KRN",.84,0)
.84
"BLD",838,"KRN",3.6,0)
3.6
"BLD",838,"KRN",3.8,0)
3.8
"BLD",838,"KRN",9.2,0)
9.2
"BLD",838,"KRN",9.8,0)
9.8
"BLD",838,"KRN",9.8,"NM",0)
^9.68A^49^38
"BLD",838,"KRN",9.8,"NM",1,0)
HLOAPI^^0^35456611
"BLD",838,"KRN",9.8,"NM",2,0)
HLOAPI1^^0^47488160
"BLD",838,"KRN",9.8,"NM",3,0)
HLOAPI2^^0^27708015
"BLD",838,"KRN",9.8,"NM",4,0)
HLOAPI3^^0^30983602
"BLD",838,"KRN",9.8,"NM",5,0)
HLOAPP^^0^4658819
"BLD",838,"KRN",9.8,"NM",6,0)
HLOASUB^^0^20309588
"BLD",838,"KRN",9.8,"NM",7,0)
HLOASUB1^^0^53189937
"BLD",838,"KRN",9.8,"NM",8,0)
HLOCLNT^^0^65447935
"BLD",838,"KRN",9.8,"NM",9,0)
HLOCLNT1^^0^25822354
"BLD",838,"KRN",9.8,"NM",10,0)
HLOCLNT2^^0^12124771
"BLD",838,"KRN",9.8,"NM",11,0)
HLOCLNT3^^0^3706254
"BLD",838,"KRN",9.8,"NM",20,0)
HLOF777^^0^12330869
"BLD",838,"KRN",9.8,"NM",21,0)
HLOF778^^0^26674072
"BLD",838,"KRN",9.8,"NM",22,0)
HLOF778A^^0^35675106
"BLD",838,"KRN",9.8,"NM",23,0)
HLOFILER^^0^18562276
"BLD",838,"KRN",9.8,"NM",24,0)
HLOMSG^^0^44340349
"BLD",838,"KRN",9.8,"NM",25,0)
HLOPBLD^^0^10420625
"BLD",838,"KRN",9.8,"NM",26,0)
HLOPBLD1^^0^18903926
"BLD",838,"KRN",9.8,"NM",27,0)
HLOPOST^^0^3878072
"BLD",838,"KRN",9.8,"NM",28,0)
HLOPROC^^0^24878795
"BLD",838,"KRN",9.8,"NM",29,0)
HLOPROC1^^0^37655107
"BLD",838,"KRN",9.8,"NM",32,0)
HLOPURGE^^0^28987748
"BLD",838,"KRN",9.8,"NM",33,0)
HLOQUE^^0^5007132
"BLD",838,"KRN",9.8,"NM",35,0)
HLOSITE^^0^5183865
"BLD",838,"KRN",9.8,"NM",36,0)
HLOSRVR^^0^67857069
"BLD",838,"KRN",9.8,"NM",37,0)
HLOSRVR1^^0^62638202
"BLD",838,"KRN",9.8,"NM",38,0)
HLOT^^0^2539193
"BLD",838,"KRN",9.8,"NM",39,0)
HLOTCP^^0^43009690
"BLD",838,"KRN",9.8,"NM",40,0)
HLOTLNK^^0^15931185
"BLD",838,"KRN",9.8,"NM",41,0)
HLOUSR^^0^88426707
"BLD",838,"KRN",9.8,"NM",42,0)
HLOUSR1^^0^64766610
"BLD",838,"KRN",9.8,"NM",43,0)
HLOUSR2^^0^44072105
"BLD",838,"KRN",9.8,"NM",44,0)
HLOMSG1^^0^6084209
"BLD",838,"KRN",9.8,"NM",45,0)
HLOUSR3^^0^18658983
"BLD",838,"KRN",9.8,"NM",46,0)
HLOCVU^^0^5066511
"BLD",838,"KRN",9.8,"NM",47,0)
HLOCNRT^^0^4743338
"BLD",838,"KRN",9.8,"NM",48,0)
HLMA3^^0^26373063
"BLD",838,"KRN",9.8,"NM",49,0)
HLOPRS^^0^30060156
"BLD",838,"KRN",9.8,"NM","B","HLMA3",48)

"BLD",838,"KRN",9.8,"NM","B","HLOAPI",1)

"BLD",838,"KRN",9.8,"NM","B","HLOAPI1",2)

"BLD",838,"KRN",9.8,"NM","B","HLOAPI2",3)

"BLD",838,"KRN",9.8,"NM","B","HLOAPI3",4)

"BLD",838,"KRN",9.8,"NM","B","HLOAPP",5)

"BLD",838,"KRN",9.8,"NM","B","HLOASUB",6)

"BLD",838,"KRN",9.8,"NM","B","HLOASUB1",7)

"BLD",838,"KRN",9.8,"NM","B","HLOCLNT",8)

"BLD",838,"KRN",9.8,"NM","B","HLOCLNT1",9)

"BLD",838,"KRN",9.8,"NM","B","HLOCLNT2",10)

"BLD",838,"KRN",9.8,"NM","B","HLOCLNT3",11)

"BLD",838,"KRN",9.8,"NM","B","HLOCNRT",47)

"BLD",838,"KRN",9.8,"NM","B","HLOCVU",46)

"BLD",838,"KRN",9.8,"NM","B","HLOF777",20)

"BLD",838,"KRN",9.8,"NM","B","HLOF778",21)

"BLD",838,"KRN",9.8,"NM","B","HLOF778A",22)

"BLD",838,"KRN",9.8,"NM","B","HLOFILER",23)

"BLD",838,"KRN",9.8,"NM","B","HLOMSG",24)

"BLD",838,"KRN",9.8,"NM","B","HLOMSG1",44)

"BLD",838,"KRN",9.8,"NM","B","HLOPBLD",25)

"BLD",838,"KRN",9.8,"NM","B","HLOPBLD1",26)

"BLD",838,"KRN",9.8,"NM","B","HLOPOST",27)

"BLD",838,"KRN",9.8,"NM","B","HLOPROC",28)

"BLD",838,"KRN",9.8,"NM","B","HLOPROC1",29)

"BLD",838,"KRN",9.8,"NM","B","HLOPRS",49)

"BLD",838,"KRN",9.8,"NM","B","HLOPURGE",32)

"BLD",838,"KRN",9.8,"NM","B","HLOQUE",33)

"BLD",838,"KRN",9.8,"NM","B","HLOSITE",35)

"BLD",838,"KRN",9.8,"NM","B","HLOSRVR",36)

"BLD",838,"KRN",9.8,"NM","B","HLOSRVR1",37)

"BLD",838,"KRN",9.8,"NM","B","HLOT",38)

"BLD",838,"KRN",9.8,"NM","B","HLOTCP",39)

"BLD",838,"KRN",9.8,"NM","B","HLOTLNK",40)

"BLD",838,"KRN",9.8,"NM","B","HLOUSR",41)

"BLD",838,"KRN",9.8,"NM","B","HLOUSR1",42)

"BLD",838,"KRN",9.8,"NM","B","HLOUSR2",43)

"BLD",838,"KRN",9.8,"NM","B","HLOUSR3",45)

"BLD",838,"KRN",19,0)
19
"BLD",838,"KRN",19,"NM",0)
^9.68A^7^7
"BLD",838,"KRN",19,"NM",1,0)
HLO APPLICATION REGISTRY^^0
"BLD",838,"KRN",19,"NM",2,0)
HLO COUNT RECORDS^^0
"BLD",838,"KRN",19,"NM",3,0)
HLO MAIN MENU^^0
"BLD",838,"KRN",19,"NM",4,0)
HLO MESSAGE VIEWER^^0
"BLD",838,"KRN",19,"NM",5,0)
HLO SYSTEM MONITOR^^0
"BLD",838,"KRN",19,"NM",6,0)
HLO SYSTEM STARTUP^^0
"BLD",838,"KRN",19,"NM",7,0)
HL MAIN MENU^^2
"BLD",838,"KRN",19,"NM","B","HL MAIN MENU",7)

"BLD",838,"KRN",19,"NM","B","HLO APPLICATION REGISTRY",1)

"BLD",838,"KRN",19,"NM","B","HLO COUNT RECORDS",2)

"BLD",838,"KRN",19,"NM","B","HLO MAIN MENU",3)

"BLD",838,"KRN",19,"NM","B","HLO MESSAGE VIEWER",4)

"BLD",838,"KRN",19,"NM","B","HLO SYSTEM MONITOR",5)

"BLD",838,"KRN",19,"NM","B","HLO SYSTEM STARTUP",6)

"BLD",838,"KRN",19.1,0)
19.1
"BLD",838,"KRN",19.1,"NM",0)
^9.68A^^
"BLD",838,"KRN",101,0)
101
"BLD",838,"KRN",101,"NM",0)
^9.68A^20^20
"BLD",838,"KRN",101,"NM",1,0)
HLO APPLICATION ERRORED MESSAGES^^0
"BLD",838,"KRN",101,"NM",2,0)
HLO BRIEF SYSTEM STATUS^^0
"BLD",838,"KRN",101,"NM",3,0)
HLO DISPLAY OUT-GOING QUEUES^^0
"BLD",838,"KRN",101,"NM",4,0)
HLO DISPLAY PROCESSES^^0
"BLD",838,"KRN",101,"NM",5,0)
HLO DISPLAY SINGLE MESSAGE^^0
"BLD",838,"KRN",101,"NM",6,0)
HLO DISPLAY SYSTEM ERRORED MESSAGES^^0
"BLD",838,"KRN",101,"NM",7,0)
HLO DOWN LINKS^^0
"BLD",838,"KRN",101,"NM",8,0)
HLO INCOMING QUEUES^^0
"BLD",838,"KRN",101,"NM",9,0)
HLO MESSAGE VIEWER MENU^^0
"BLD",838,"KRN",101,"NM",10,0)
HLO MONITOR MODE^^0
"BLD",838,"KRN",101,"NM",11,0)
HLO SCROLL MODE^^0
"BLD",838,"KRN",101,"NM",12,0)
HLO START MENU^^0
"BLD",838,"KRN",101,"NM",13,0)
HLO START/STOP ONE QUEUE^^0
"BLD",838,"KRN",101,"NM",14,0)
HLO STOP SYSTEM^^0
"BLD",838,"KRN",101,"NM",15,0)
HLO SYSTEM MONITOR MENU^^0
"BLD",838,"KRN",101,"NM",16,0)
HLO TEST LINK^^0
"BLD",838,"KRN",101,"NM",17,0)
HLO TRANSMISSION FAILURES^^0
"BLD",838,"KRN",101,"NM",18,0)
HLO VIEW A LINK^^0
"BLD",838,"KRN",101,"NM",19,0)
HLO MESSAGE SEARCH^^0
"BLD",838,"KRN",101,"NM",20,0)
HLO MESSAGE SEARCH MENU^^0
"BLD",838,"KRN",101,"NM","B","HLO APPLICATION ERRORED MESSAGES",1)

"BLD",838,"KRN",101,"NM","B","HLO BRIEF SYSTEM STATUS",2)

"BLD",838,"KRN",101,"NM","B","HLO DISPLAY OUT-GOING QUEUES",3)

"BLD",838,"KRN",101,"NM","B","HLO DISPLAY PROCESSES",4)

"BLD",838,"KRN",101,"NM","B","HLO DISPLAY SINGLE MESSAGE",5)

"BLD",838,"KRN",101,"NM","B","HLO DISPLAY SYSTEM ERRORED MESSAGES",6)

"BLD",838,"KRN",101,"NM","B","HLO DOWN LINKS",7)

"BLD",838,"KRN",101,"NM","B","HLO INCOMING QUEUES",8)

"BLD",838,"KRN",101,"NM","B","HLO MESSAGE SEARCH",19)

"BLD",838,"KRN",101,"NM","B","HLO MESSAGE SEARCH MENU",20)

"BLD",838,"KRN",101,"NM","B","HLO MESSAGE VIEWER MENU",9)

"BLD",838,"KRN",101,"NM","B","HLO MONITOR MODE",10)

"BLD",838,"KRN",101,"NM","B","HLO SCROLL MODE",11)

"BLD",838,"KRN",101,"NM","B","HLO START MENU",12)

"BLD",838,"KRN",101,"NM","B","HLO START/STOP ONE QUEUE",13)

"BLD",838,"KRN",101,"NM","B","HLO STOP SYSTEM",14)

"BLD",838,"KRN",101,"NM","B","HLO SYSTEM MONITOR MENU",15)

"BLD",838,"KRN",101,"NM","B","HLO TEST LINK",16)

"BLD",838,"KRN",101,"NM","B","HLO TRANSMISSION FAILURES",17)

"BLD",838,"KRN",101,"NM","B","HLO VIEW A LINK",18)

"BLD",838,"KRN",409.61,0)
409.61
"BLD",838,"KRN",409.61,"NM",0)
^9.68A^4^4
"BLD",838,"KRN",409.61,"NM",1,0)
HLO MESSAGE VIEWER^^0
"BLD",838,"KRN",409.61,"NM",2,0)
HLO SYSTEM MONITOR^^0
"BLD",838,"KRN",409.61,"NM",3,0)
HLO MESSAGE SEARCH^^0
"BLD",838,"KRN",409.61,"NM",4,0)
HLO SINGLE MESSAGE DISPLAY^^0
"BLD",838,"KRN",409.61,"NM","B","HLO MESSAGE SEARCH",3)

"BLD",838,"KRN",409.61,"NM","B","HLO MESSAGE VIEWER",1)

"BLD",838,"KRN",409.61,"NM","B","HLO SINGLE MESSAGE DISPLAY",4)

"BLD",838,"KRN",409.61,"NM","B","HLO SYSTEM MONITOR",2)

"BLD",838,"KRN",771,0)
771
"BLD",838,"KRN",870,0)
870
"BLD",838,"KRN",8989.51,0)
8989.51
"BLD",838,"KRN",8989.52,0)
8989.52
"BLD",838,"KRN",8994,0)
8994
"BLD",838,"KRN","B",.4,.4)

"BLD",838,"KRN","B",.401,.401)

"BLD",838,"KRN","B",.402,.402)

"BLD",838,"KRN","B",.403,.403)

"BLD",838,"KRN","B",.5,.5)

"BLD",838,"KRN","B",.84,.84)

"BLD",838,"KRN","B",3.6,3.6)

"BLD",838,"KRN","B",3.8,3.8)

"BLD",838,"KRN","B",9.2,9.2)

"BLD",838,"KRN","B",9.8,9.8)

"BLD",838,"KRN","B",19,19)

"BLD",838,"KRN","B",19.1,19.1)

"BLD",838,"KRN","B",101,101)

"BLD",838,"KRN","B",409.61,409.61)

"BLD",838,"KRN","B",771,771)

"BLD",838,"KRN","B",870,870)

"BLD",838,"KRN","B",8989.51,8989.51)

"BLD",838,"KRN","B",8989.52,8989.52)

"BLD",838,"KRN","B",8994,8994)

"BLD",838,"QUES",0)
^9.62^^0
"BLD",838,"REQB",0)
^9.611^3^3
"BLD",838,"REQB",1,0)
XU*8.0*388^2
"BLD",838,"REQB",2,0)
HL*1.6*84^2
"BLD",838,"REQB",3,0)
HL*1.6*118^2
"BLD",838,"REQB","B","HL*1.6*118",3)

"BLD",838,"REQB","B","HL*1.6*84",2)

"BLD",838,"REQB","B","XU*8.0*388",1)

"DATA",779.3,1,0)
PROCESS MANAGER^1^1^1^9999^3050601.121938^30^GETWORK^HLOPROC1^DOWORK^HLOPROC1^999^1^^0
"DATA",779.3,2,0)
CHECK PROCESS COUNTS^1^0^1^15^3050601.121356^2^QUIT1^HLOPROC1^RECOUNT^HLOPROC1^1^0
"DATA",779.3,3,0)
OUTGOING CLIENT LINK^1^2^10^10^3050601.121916^5^GETWORK^HLOCLNT^DOWORK^HLOCLNT^6^0
"DATA",779.3,4,0)
TASKMAN MULTI-LISTENER^0^1^1^30^3050203.060705^0^GETWORK^HLOSRVR^DOWORKM^HLOSRVR^9999^0^^0
"DATA",779.3,5,0)
VMS TCP LISTENER^0^1^1^9999^^1^ ^ ^^^0^0^^1
"DATA",779.3,6,0)
INCOMING QUEUES^1^2^10^15^3050601.121917^5^GETWORK^HLOFILER^DOWORK^HLOFILER^6^0^^0
"DATA",779.3,7,0)
PURGE OLD MESSAGES^1^0^3^20^3050601.1214^1^GETWORK^HLOPURGE^DOWORK^HLOPURGE^1^0
"DATA",779.3,8,0)
REMOVE BAD MESSAGES^1^0^1^120^3050601.121431^1^QUIT1^HLOPROC1^BADMSGS^HLOCLNT1^1^0^^0
"DATA",779.3,9,0)
CLIENT MESSAGE UPDATES^1^1^2^15^3050601.121913^2^GETWORK^HLOCLNT2^DOWORK^HLOCLNT2^7^0^^0
"DATA",779.3,10,0)
REPORT MISSING APP ACKS^1^0^1^480^3050601.121404^1^QUIT1^HLOPROC1^DOWORK^HLOCLNT3^1^0^^0
"DATA",779.3,11,0)
SET SEARCH X-REF^1^0^1^5^3050601.121408^2^GETWORK^HLOF778A^DOWORK^HLOF778A^2^0^^0
"DATA",779.3,12,0)
SINGLE LISTENER^0^1^1^30^^0^GETWORK^HLOSRVR^DOWORKS^HLOSRVR^9999^0^^0
"FIA",777)
HLO MESSAGE BODY
"FIA",777,0)
^HLA(
"FIA",777,0,0)
777D
"FIA",777,0,1)
y^n^f^^^^n
"FIA",777,0,10)

"FIA",777,0,11)

"FIA",777,0,"RLRO")

"FIA",777,0,"VR")
1.6^HL
"FIA",777,777)
0
"FIA",777,777.01)
0
"FIA",777,777.02)
0
"FIA",777,777.21)
0
"FIA",778)
HLO MESSAGES
"FIA",778,0)
^HLB(
"FIA",778,0,0)
778O
"FIA",778,0,1)
y^n^f^^^^n
"FIA",778,0,10)

"FIA",778,0,11)

"FIA",778,0,"RLRO")

"FIA",778,0,"VR")
1.6^HL
"FIA",778,778)
0
"FIA",778,778.03)
0
"FIA",779.1)
HLO SYSTEM PARAMETERS
"FIA",779.1,0)
^HLD(779.1,
"FIA",779.1,0,0)
779.1
"FIA",779.1,0,1)
y^n^f^^^^n
"FIA",779.1,0,10)

"FIA",779.1,0,11)

"FIA",779.1,0,"RLRO")

"FIA",779.1,0,"VR")
1.6^HL
"FIA",779.1,779.1)
0
"FIA",779.2)
HLO APPLICATION REGISTRY
"FIA",779.2,0)
^HLD(779.2,
"FIA",779.2,0,0)
779.2
"FIA",779.2,0,1)
y^n^f^^^^n
"FIA",779.2,0,10)

"FIA",779.2,0,11)

"FIA",779.2,0,"RLRO")

"FIA",779.2,0,"VR")
1.6^HL
"FIA",779.2,779.2)
0
"FIA",779.2,779.21)
0
"FIA",779.3)
HLO PROCESS REGISTRY
"FIA",779.3,0)
^HLD(779.3,
"FIA",779.3,0,0)
779.3
"FIA",779.3,0,1)
y^n^f^^y^^y^a^n
"FIA",779.3,0,10)

"FIA",779.3,0,11)

"FIA",779.3,0,"RLRO")

"FIA",779.3,0,"VR")
1.6^HL
"FIA",779.3,779.3)
0
"FIA",779.4)
HLO SUBSCRIPTION REGISTRY
"FIA",779.4,0)
^HLD(779.4,
"FIA",779.4,0,0)
779.4
"FIA",779.4,0,1)
y^y^f^^^^n
"FIA",779.4,0,10)

"FIA",779.4,0,11)

"FIA",779.4,0,"RLRO")

"FIA",779.4,0,"VR")
1.6^HL
"FIA",779.4,779.4)
0
"FIA",779.4,779.41)
0
"FIA",870)
HL LOGICAL LINK
"FIA",870,0)
^HLCS(870,
"FIA",870,0,0)
870
"FIA",870,0,1)
y^n^f^^^^n
"FIA",870,0,10)

"FIA",870,0,11)

"FIA",870,0,"RLRO")

"FIA",870,0,"VR")
1.6^HL
"FIA",870,870)
0
"FIA",870,870.01)
0
"FIA",870,870.019)
0
"FIA",870,870.13)
0
"FIA",870,870.193)
0
"INIT")
HLOPOST
"IX",779.2,779.2,"C",0)
779.2^C^Uniqueness Index for Key 'A' of File #779.2^R^^F^IR^I^779.2^^^^^LS
"IX",779.2,779.2,"C",1)
S ^HLD(779.2,"C",X,DA)=""
"IX",779.2,779.2,"C",2)
K ^HLD(779.2,"C",X,DA)
"IX",779.2,779.2,"C",2.5)
K ^HLD(779.2,"C")
"IX",779.2,779.2,"C",11.1,0)
^.114IA^1^1
"IX",779.2,779.2,"C",11.1,1,0)
1^F^779.2^.01^^1
"IX",779.2,779.21,"C",0)
779.21^C^Uniqueness Index for Key 'A' of Subfile #779.21^R^^R^IR^I^779.21^^^^^LS
"IX",779.2,779.21,"C",1)
S ^HLD(779.2,DA(1),1,"C",X(1),X(2),DA)=""
"IX",779.2,779.21,"C",2)
K ^HLD(779.2,DA(1),1,"C",X(1),X(2),DA)
"IX",779.2,779.21,"C",2.5)
K ^HLD(779.2,DA(1),1,"C")
"IX",779.2,779.21,"C",11.1,0)
^.114IA^2^2
"IX",779.2,779.21,"C",11.1,1,0)
1^F^779.21^.01^^1
"IX",779.2,779.21,"C",11.1,2,0)
2^F^779.21^.02^^2
"IX",779.3,779.3,"C",0)
779.3^C^Used to find active entries in the process registry.^R^^F^IR^I^779.3^^^^^LS
"IX",779.3,779.3,"C",1)
S ^HLD(779.3,"C",X,DA)=""
"IX",779.3,779.3,"C",1.4)
S X=$S('X(1):0,1:1)
"IX",779.3,779.3,"C",2)
K ^HLD(779.3,"C",X,DA)
"IX",779.3,779.3,"C",2.5)
K ^HLD(779.3,"C")
"IX",779.3,779.3,"C",11.1,0)
^.114IA^1^1
"IX",779.3,779.3,"C",11.1,1,0)
1^F^779.3^.02^^1^F
"IX",779.3,779.3,"D",0)
779.3^D^Uniqueness Index for Key 'A' of File #779.3^R^^F^IR^I^779.3^^^^^LS
"IX",779.3,779.3,"D",1)
S ^HLD(779.3,"D",X,DA)=""
"IX",779.3,779.3,"D",2)
K ^HLD(779.3,"D",X,DA)
"IX",779.3,779.3,"D",2.5)
K ^HLD(779.3,"D")
"IX",779.3,779.3,"D",11.1,0)
^.114IA^1^1
"IX",779.3,779.3,"D",11.1,1,0)
1^F^779.3^.01^^1
"IX",779.4,779.41,"AC",0)
779.41.^AC^Used to find recipients who have not been terminated.^MU^^R^IR^I^779.41^^^^^S
"IX",779.4,779.41,"AC",1)
S ^HLD(779.4,DA(1),2,"AC",DA)=""
"IX",779.4,779.41,"AC",1.4)
S X=$S($G(X2(2)):0,1:1)
"IX",779.4,779.41,"AC",2)
K ^HLD(779.4,DA(1),2,"AC",DA)
"IX",779.4,779.41,"AC",2.4)
S X=1
"IX",779.4,779.41,"AC",11.1,0)
^.114IA^2^2
"IX",779.4,779.41,"AC",11.1,1,0)
1^F^779.41^1.01^^1^F
"IX",779.4,779.41,"AC",11.1,1,3)

"IX",779.4,779.41,"AC",11.1,2,0)
2^F^779.41^1.02^^^F
"IX",779.4,779.41,"AC",11.1,2,3)

"IX",779.4,779.41,"AD",0)
779.41^AD^Used to determine if the recipient is already on the subscription list.^MU^^R^IR^I^779.41^^^^^S
"IX",779.4,779.41,"AD",1)
S ^HLD(779.4,DA(1),2,"AD",X2(1),X2(2),X2(3)_X2(4)_X2(5),DA)=""
"IX",779.4,779.41,"AD",2)
K ^HLD(779.4,DA(1),2,"AD",X1(1),X1(2),X1(3)_X1(4)_X1(5),DA)
"IX",779.4,779.41,"AD",11.1,0)
^.114IA^5^5
"IX",779.4,779.41,"AD",11.1,1,0)
1^F^779.41^.01^^1^F
"IX",779.4,779.41,"AD",11.1,1,3)

"IX",779.4,779.41,"AD",11.1,2,0)
2^F^779.41^.02^^2^F
"IX",779.4,779.41,"AD",11.1,2,3)

"IX",779.4,779.41,"AD",11.1,3,0)
3^F^779.41^.03^^^F
"IX",779.4,779.41,"AD",11.1,3,3)

"IX",779.4,779.41,"AD",11.1,4,0)
4^F^779.41^.04^^^F
"IX",779.4,779.41,"AD",11.1,4,3)

"IX",779.4,779.41,"AD",11.1,5,0)
5^F^779.41^.05^^^F
"IX",779.4,779.41,"AD",11.1,5,3)

"IX",870,870,"AC",0)
870^AC^Sorts entries by <station number>,<link name>,<ien>^MU^^R^IR^I^870^^^^^S
"IX",870,870,"AC",1)
S ^HLCS(870,"AC",$S($L($P($G(^DIC(4,+X2(1),99)),"^")):$P($G(^DIC(4,+X2(1),99)),"^"),1:" "),X2(2),DA)=""
"IX",870,870,"AC",2)
K ^HLCS(870,"AC",$S($L($P($G(^DIC(4,+X1(1),99)),"^")):$P($G(^DIC(4,+X1(1),99)),"^"),1:" "),X1(2),DA)
"IX",870,870,"AC",2.5)
K ^HLCS(870,"AC")
"IX",870,870,"AC",11.1,0)
^.114IA^2^2
"IX",870,870,"AC",11.1,1,0)
1^F^870^.02^^1^F
"IX",870,870,"AC",11.1,1,1)

"IX",870,870,"AC",11.1,1,1.5)

"IX",870,870,"AC",11.1,1,3)

"IX",870,870,"AC",11.1,2,0)
2^F^870^.01^^^F
"IX",870,870,"AD",0)
870^AD^Used to find the link over which to send the application acknowledgment.^MU^^R^IR^I^870^^^^^A
"IX",870,870,"AD",1)
D SET1^HLOTLNK(X(1),X(3))
"IX",870,870,"AD",1.4)
S X=0 I X(4)="C",X(2),$P($G(^HLCS(869.1,X(2),0)),"^")="TCP" S X=1
"IX",870,870,"AD",2)
D KILL1^HLOTLNK(X(1),X(3))
"IX",870,870,"AD",2.4)
S X=0 I X(4)="C",X(2),$P($G(^HLCS(869.1,X(2),0)),"^")="TCP" S X=1
"IX",870,870,"AD",2.5)

"IX",870,870,"AD",11.1,0)
^.114IA^5^4
"IX",870,870,"AD",11.1,1,0)
1^F^870^.01^30^1^F
"IX",870,870,"AD",11.1,2,0)
2^F^870^2^^2^F
"IX",870,870,"AD",11.1,4,0)
3^F^870^.03^^3^F
"IX",870,870,"AD",11.1,5,0)
4^F^870^400.03^^4^F
"IX",870,870,"AD",11.1,5,3)

"IX",870,870,"AD1",0)
870^AD1^Used to find the link overwhich to send the application acknowledgment.^MU^^R^IR^I^870^^^^^A
"IX",870,870,"AD1",1)
D SET2^HLOTLNK(X(1),X(3))
"IX",870,870,"AD1",1.4)
S X=0 I X(4)="C",X(2),$P($G(^HLCS(869.1,X(2),0)),"^")="TCP" S X=1
"IX",870,870,"AD1",2)
D KILL2^HLOTLNK(X(1),X(3))
"IX",870,870,"AD1",2.4)
S X=0 I X(4)="C",X(2),$P($G(^HLCS(869.1,X(2),0)),"^")="TCP" S X=1
"IX",870,870,"AD1",2.5)

"IX",870,870,"AD1",11.1,0)
^.114IA^4^4
"IX",870,870,"AD1",11.1,1,0)
1^F^870^.01^^1^F
"IX",870,870,"AD1",11.1,2,0)
2^F^870^2^^2^F
"IX",870,870,"AD1",11.1,3,0)
3^F^870^.08^^3^F
"IX",870,870,"AD1",11.1,4,0)
4^F^870^400.03^^4^F
"IX",870,870,"AD2",0)
870^AD2^Used to find the link overwhich to send an application acknowledgment.^MU^^R^IR^I^870^^^^^A
"IX",870,870,"AD2",1)
D SET3^HLOTLNK(X(1),X(3))
"IX",870,870,"AD2",1.4)
S X=0 I X(2),$P($G(^HLCS(869.1,X(2),0)),"^")="HLLP" S X=1
"IX",870,870,"AD2",2)
D KILL3^HLOTLNK(X(1),X(3))
"IX",870,870,"AD2",2.4)
S X=0 I X(2),$P($G(^HLCS(869.1,X(2),0)),"^")="HLLP" S X=1
"IX",870,870,"AD2",2.5)
K ^HLCS(870,"AD","HLLP")
"IX",870,870,"AD2",11.1,0)
^.114IA^3^3
"IX",870,870,"AD2",11.1,1,0)
1^F^870^.01^^1^F
"IX",870,870,"AD2",11.1,2,0)
2^F^870^2^^2^F
"IX",870,870,"AD2",11.1,3,0)
3^F^870^200.01^^3^F
"IX",870,870,"DNS",0)
870^DNS^This is a regular index of new-style cross-reference on the DNS Domain field^R^^F^IR^I^870^^^^^LS
"IX",870,870,"DNS",1)
S ^HLCS(870,"DNS",$E(X,1,70),DA)=""
"IX",870,870,"DNS",2)
K ^HLCS(870,"DNS",$E(X,1,70),DA)
"IX",870,870,"DNS",2.5)
K ^HLCS(870,"DNS")
"IX",870,870,"DNS",11.1,0)
^.114IA^1^1
"IX",870,870,"DNS",11.1,1,0)
1^F^870^.08^70^1^F
"IX",870,870,"DNS",11.1,1,3)

"IX",870,870,"DNS2",0)
870^DNS2^Regular index of new-style x-ref on the DNS Domain and Node fields^R^^R^IR^I^870^^^^^LS
"IX",870,870,"DNS2",1)
S ^HLCS(870,"DNS2",$E(X(1),1,70),$E(X(2),1,30),DA)=""
"IX",870,870,"DNS2",2)
K ^HLCS(870,"DNS2",$E(X(1),1,70),$E(X(2),1,30),DA)
"IX",870,870,"DNS2",2.5)
K ^HLCS(870,"DNS2")
"IX",870,870,"DNS2",11.1,0)
^.114IA^2^2
"IX",870,870,"DNS2",11.1,1,0)
1^F^870^.08^70^1^F
"IX",870,870,"DNS2",11.1,1,3)

"IX",870,870,"DNS2",11.1,2,0)
2^F^870^.01^30^2^F
"IX",870,870,"DNS2",11.1,2,3)

"IX",870,870,"IEN772IN",0)
870^IEN772IN^IEN772 whole file cross reference^R^^F^IR^W^870.019^^^^^LS
"IX",870,870,"IEN772IN",1)
S ^HLCS(870,"IEN772IN",X,DA(1),DA)=""
"IX",870,870,"IEN772IN",2)
K ^HLCS(870,"IEN772IN",X,DA(1),DA)
"IX",870,870,"IEN772IN",2.5)
K ^HLCS(870,"IEN772IN")
"IX",870,870,"IEN772IN",11.1,0)
^.114IA^1^1
"IX",870,870,"IEN772IN",11.1,1,0)
1^F^870.019^9^^1^F
"IX",870,870,"IEN772IN",11.1,1,3)

"IX",870,870,"IEN772OUT",0)
870^IEN772OUT^IEN772 whole file cross reference^R^^F^IR^W^870.01^^^^^LS
"IX",870,870,"IEN772OUT",1)
S ^HLCS(870,"IEN772OUT",X,DA(1),DA)=""
"IX",870,870,"IEN772OUT",2)
K ^HLCS(870,"IEN772OUT",X,DA(1),DA)
"IX",870,870,"IEN772OUT",2.5)
K ^HLCS(870,"IEN772OUT")
"IX",870,870,"IEN772OUT",11.1,0)
^.114IA^1^1
"IX",870,870,"IEN772OUT",11.1,1,0)
1^F^870.01^6^^1^F
"IX",870,870,"IEN772OUT",11.1,1,3)

"IX",870,870,"IP",0)
870^IP^IP Address cross reference^R^^F^IR^I^870^^^^^LS
"IX",870,870,"IP",1)
S ^HLCS(870,"IP",$E(X,1,40),DA)=""
"IX",870,870,"IP",2)
K ^HLCS(870,"IP",$E(X,1,40),DA)
"IX",870,870,"IP",2.5)
K ^HLCS(870,"IP")
"IX",870,870,"IP",11.1,0)
^.114IA^1^1
"IX",870,870,"IP",11.1,1,0)
1^F^870^400.01^40^1^F
"IX",870,870,"IP",11.1,1,3)

"KEY",779.2,779.2,"A",0)
779.2^A^P^68
"KEY",779.2,779.2,"A",2,0)
^.312IA^1^1
"KEY",779.2,779.2,"A",2,1,0)
.01^779.2^1
"KEY",779.2,779.21,"A",0)
779.21^A^P^69
"KEY",779.2,779.21,"A",2,0)
^.312IA^2^2
"KEY",779.2,779.21,"A",2,1,0)
.01^779.21^1
"KEY",779.2,779.21,"A",2,2,0)
.02^779.21^2
"KEY",779.3,779.3,"A",0)
779.3^A^P^83
"KEY",779.3,779.3,"A",2,0)
^.312IA^1^1
"KEY",779.3,779.3,"A",2,1,0)
.01^779.3^1
"KEYPTR",779.2,779.2,"A")
779.2^C
"KEYPTR",779.2,779.21,"A")
779.21^C
"KEYPTR",779.3,779.3,"A")
779.3^D
"KRN",.402,77,-1)
0^1
"KRN",.402,77,0)
HLOAPREG^3050527.1112^@^779.2^^@^3050527
"KRN",.402,77,"DIAB",1,1,779.21,0)
ALL
"KRN",.402,77,"DR",1,779.2)
.01;2;.09;.03;.06;.07;.08;.04;.05;1;
"KRN",.402,77,"DR",2,779.21)
.01:.05
"KRN",.403,30,-1)
0^1
"KRN",.403,30,0)
HL7 LOGICAL LINK^@^@^^2990706.1207^^^870^0^0^1
"KRN",.403,30,40,0)
^.4031I^5^5
"KRN",.403,30,40,1,0)
1^^1,1
"KRN",.403,30,40,1,1)
Page 1
"KRN",.403,30,40,1,40,0)
^.4032IP^144^2
"KRN",.403,30,40,1,40,143,0)
HL7 LL HEADER1^1^1,1^d
"KRN",.403,30,40,1,40,144,0)
HL7 LL BLK1^2^2,1^e
"KRN",.403,30,40,2,0)
3^^3,3^^^1^14,77
"KRN",.403,30,40,2,1)
Page 3
"KRN",.403,30,40,2,40,0)
^.4032IP^145^1
"KRN",.403,30,40,2,40,145,0)
HL7 LLP HLLP^1^1,2^e
"KRN",.403,30,40,2,40,145,1)

"KRN",.403,30,40,3,0)
5^^3,3^^^1^17,77
"KRN",.403,30,40,3,1)
Page 5
"KRN",.403,30,40,3,40,0)
^.4032IP^146^1
"KRN",.403,30,40,3,40,146,0)
HL7 LLP TCP^1^1,2^e
"KRN",.403,30,40,3,40,146,1)

"KRN",.403,30,40,4,0)
2^^3,3^^^1^7,77
"KRN",.403,30,40,4,1)
Page 2
"KRN",.403,30,40,4,40,0)
^.4032IP^147^1
"KRN",.403,30,40,4,40,147,0)
HL7 LLP MAIL^1^1,2^e
"KRN",.403,30,40,4,40,147,1)

"KRN",.403,30,40,5,0)
4^^3,3^^^1^14,77
"KRN",.403,30,40,5,1)
Page 4
"KRN",.403,30,40,5,40,0)
^.4032IP^148^1
"KRN",.403,30,40,5,40,148,0)
HL7 LLP X3.28^1^1,2^e
"KRN",.403,30,40,5,40,148,1)

"KRN",.404,143,0)
HL7 LL HEADER1^870^
"KRN",.404,143,40,0)
^.4044I^3^2
"KRN",.404,143,40,1,0)
1^HL7 LOGICAL LINK^1
"KRN",.404,143,40,1,2)
^^1,27
"KRN",.404,143,40,3,0)
3^--------------------------------------------------------------------------------^1
"KRN",.404,143,40,3,2)
^^2,1
"KRN",.404,144,0)
HL7 LL BLK1^870
"KRN",.404,144,40,0)
^.4044I^7^7
"KRN",.404,144,40,1,0)
1^NODE^3
"KRN",.404,144,40,1,1)
.01
"KRN",.404,144,40,1,2)
4,23^10^4,17
"KRN",.404,144,40,1,4)
1
"KRN",.404,144,40,2,0)
2^INSTITUTION^3
"KRN",.404,144,40,2,1)
.02
"KRN",.404,144,40,2,2)
6,23^30^6,10
"KRN",.404,144,40,3,0)
3^MAILMAN DOMAIN^3
"KRN",.404,144,40,3,1)
.03
"KRN",.404,144,40,3,2)
8,23^30^8,7
"KRN",.404,144,40,4,0)
6^LLP TYPE^3
"KRN",.404,144,40,4,1)
2
"KRN",.404,144,40,4,2)
14,23^30^14,13
"KRN",.404,144,40,4,4)
1
"KRN",.404,144,40,4,10)
S DDSSTACK="PAGE "_(1+X)
"KRN",.404,144,40,5,0)
4^AUTOSTART^3
"KRN",.404,144,40,5,1)
4.5
"KRN",.404,144,40,5,2)
10,23^8^10,12
"KRN",.404,144,40,6,0)
5^QUEUE SIZE^3
"KRN",.404,144,40,6,1)
21
"KRN",.404,144,40,6,2)
12,23^6^12,11
"KRN",.404,144,40,6,3)
10
"KRN",.404,144,40,7,0)
7^DNS DOMAIN^3
"KRN",.404,144,40,7,1)
.08
"KRN",.404,144,40,7,2)
16,23^30^16,11
"KRN",.404,145,0)
HL7 LLP HLLP^870
"KRN",.404,145,40,0)
^.4044I^11^10
"KRN",.404,145,40,1,0)
1^HLLP LOWER LEVEL PARAMETERS^1
"KRN",.404,145,40,1,2)
^^1,24
"KRN",.404,145,40,2,0)
2^^3
"KRN",.404,145,40,2,1)
.01
"KRN",.404,145,40,2,2)
2,24^30
"KRN",.404,145,40,2,4)
^^^1
"KRN",.404,145,40,4,0)
9^BLOCK SIZE^3
"KRN",.404,145,40,4,1)
200.03
"KRN",.404,145,40,4,2)
11,15^3^11,3
"KRN",.404,145,40,5,0)
3^HLLP DEVICE^3
"KRN",.404,145,40,5,1)
200.01
"KRN",.404,145,40,5,2)
5,15^30^5,2
"KRN",.404,145,40,6,0)
6^RE-TRANSMISION ATTEMPTS^3
"KRN",.404,145,40,6,1)
200.02
"KRN",.404,145,40,6,2)
7,70^2^7,45
"KRN",.404,145,40,7,0)
5^READ TIMEOUT^3
"KRN",.404,145,40,7,1)
200.04
"KRN",.404,145,40,7,2)
7,15^2^7,1
"KRN",.404,145,40,8,0)
7^ACK TIMEOUT^3
"KRN",.404,145,40,8,1)
200.05
"KRN",.404,145,40,8,2)
9,15^3^9,2
"KRN",.404,145,40,9,0)
8^LLP START BLOCK^3
"KRN",.404,145,40,9,1)
200.06
"KRN",.404,145,40,9,2)
9,70^2^9,53
"KRN",.404,145,40,10,0)
10^LLP END BLOCK^3
"KRN",.404,145,40,10,1)
200.07
"KRN",.404,145,40,10,2)
11,70^2^11,55
"KRN",.404,145,40,11,0)
4^PROTOCOL ID VERSION^3
"KRN",.404,145,40,11,1)
200.08
"KRN",.404,145,40,11,2)
5,70^3^5,49
"KRN",.404,146,0)
HL7 LLP TCP^870
"KRN",.404,146,40,0)
^.4044I^16^15
"KRN",.404,146,40,1,0)
1^TCP LOWER LEVEL PARAMETERS^1
"KRN",.404,146,40,1,2)
^^1,23
"KRN",.404,146,40,2,0)
2^^3
"KRN",.404,146,40,2,1)
.01
"KRN",.404,146,40,2,2)
2,23^30
"KRN",.404,146,40,2,4)
^^^1
"KRN",.404,146,40,4,0)
7^RE-TRANSMISION ATTEMPTS^3
"KRN",.404,146,40,4,1)
200.02
"KRN",.404,146,40,4,2)
9,64^2^9,39
"KRN",.404,146,40,5,0)
10^BLOCK SIZE^3
"KRN",.404,146,40,5,1)
200.03
"KRN",.404,146,40,5,2)
11,17^3^11,5
"KRN",.404,146,40,6,0)
8^READ TIMEOUT^3
"KRN",.404,146,40,6,1)
200.04
"KRN",.404,146,40,6,2)
10,17^2^10,3
"KRN",.404,146,40,7,0)
6^ACK TIMEOUT^3
"KRN",.404,146,40,7,1)
200.05
"KRN",.404,146,40,7,2)
9,17^3^9,4
"KRN",.404,146,40,8,0)
15^UNI-DIRECTIONAL WAIT^3
"KRN",.404,146,40,8,1)
200.09
"KRN",.404,146,40,8,2)
14,64^2^14,42
"KRN",.404,146,40,9,0)
4^TCP/IP ADDRESS^3
"KRN",.404,146,40,9,1)
400.01
"KRN",.404,146,40,9,2)
5,24^40^5,8
"KRN",.404,146,40,10,0)
5^TCP/IP PORT^3
"KRN",.404,146,40,10,1)
400.02
"KRN",.404,146,40,10,2)
6,24^5^6,11
"KRN",.404,146,40,11,0)
3^TCP/IP SERVICE TYPE^3
"KRN",.404,146,40,11,1)
400.03
"KRN",.404,146,40,11,2)
4,24^15^4,3
"KRN",.404,146,40,11,13)
I X'="C" F HLI=200.02,200.09,400.04,400.05 D UNED^DDSUTL(HLI,"","",1)
"KRN",.404,146,40,12,0)
13^PERSISTENT^3
"KRN",.404,146,40,12,1)
400.04
"KRN",.404,146,40,12,2)
13,64^3^13,52
"KRN",.404,146,40,13,0)
14^RETENTION^3
"KRN",.404,146,40,13,1)
400.05
"KRN",.404,146,40,13,2)
14,15^6^14,4
"KRN",.404,146,40,14,0)
12^STARTUP NODE^3
"KRN",.404,146,40,14,1)
400.06
"KRN",.404,146,40,14,2)
13,15^20^13,1
"KRN",.404,146,40,15,0)
9^EXCEED RE-TRANSMIT ACTION^3
"KRN",.404,146,40,15,1)
200.021
"KRN",.404,146,40,15,2)
10,64^10^10,37
"KRN",.404,146,40,15,4)
0
"KRN",.404,146,40,16,0)
11^SAY HELO^3
"KRN",.404,146,40,16,1)
400.07
"KRN",.404,146,40,16,2)
11,64^3^11,54
"KRN",.404,146,40,17,0)
5.1^TCP/IP PORT (OPTIMIZED)^3
"KRN",.404,146,40,17,1)
400.08
"KRN",.404,146,40,17,2)
7,36^5^7,11
"KRN",.404,147,0)
HL7 LLP MAIL^870
"KRN",.404,147,40,0)
^.4044I^5^3
"KRN",.404,147,40,1,0)
1^MAILMAN LOWER LEVEL PARAMETERS^1
"KRN",.404,147,40,1,2)
^^1,23
"KRN",.404,147,40,4,0)
2^MAIL GROUP^3
"KRN",.404,147,40,4,1)
100.01
"KRN",.404,147,40,4,2)
4,23^30^4,11
"KRN",.404,147,40,4,4)
0
"KRN",.404,147,40,5,0)
3^^3
"KRN",.404,147,40,5,1)
.01
"KRN",.404,147,40,5,2)
2,23^30
"KRN",.404,147,40,5,4)
^^^1
"KRN",.404,148,0)
HL7 LLP X3.28^870
"KRN",.404,148,40,0)
^.4044I^10^9
"KRN",.404,148,40,1,0)
1^X3.28 LOWER LEVEL PARAMETERS^1
"KRN",.404,148,40,1,2)
^^1,23
"KRN",.404,148,40,2,0)
2^^3
"KRN",.404,148,40,2,1)
.01
"KRN",.404,148,40,2,2)
2,23^30
"KRN",.404,148,40,2,4)
^^^1
"KRN",.404,148,40,4,0)
3^X3.28 DEVICE^3
"KRN",.404,148,40,4,1)
300.01
"KRN",.404,148,40,4,2)
5,24^30^5,10
"KRN",.404,148,40,5,0)
4^MAXIMUM MESSAGE SIZE^3
"KRN",.404,148,40,5,1)
300.02
"KRN",.404,148,40,5,2)
7,24^5^7,2
"KRN",.404,148,40,6,0)
5^MAXIMUM BLOCK SIZE^3
"KRN",.404,148,40,6,1)
300.03
"KRN",.404,148,40,6,2)
7,69^3^7,49
"KRN",.404,148,40,7,0)
6^TIMER A^3
"KRN",.404,148,40,7,1)
300.04
"KRN",.404,148,40,7,2)
9,24^2^9,15
"KRN",.404,148,40,8,0)
8^TIMER B^3
"KRN",.404,148,40,8,1)
300.05
"KRN",.404,148,40,8,2)
11,24^2^11,15
"KRN",.404,148,40,9,0)
7^TIMER D^3
"KRN",.404,148,40,9,1)
300.06
"KRN",.404,148,40,9,2)
9,69^2^9,60
"KRN",.404,148,40,10,0)
9^TIMER E^3
"KRN",.404,148,40,10,1)
300.07
"KRN",.404,148,40,10,2)
11,69^3^11,60
"KRN",19,634,-1)
2^7
"KRN",19,634,0)
HL MAIN MENU^HL7 Main Menu^^M^6^^^^^^y^9^y
"KRN",19,634,10,0)
^19.01IP^15^15
"KRN",19,634,10,15,0)
1047^HLO^7
"KRN",19,634,10,15,"^")
HLO MAIN MENU
"KRN",19,634,"U")
HL7 MAIN MENU
"KRN",19,1044,-1)
0^2
"KRN",19,1044,0)
HLO COUNT RECORDS^COUNT HL7 MESSAGE RECORDS^^A^^^^^^^n^HEALTH LEVEL SEVEN^^1
"KRN",19,1044,1,0)
^^1^1^3040928^
"KRN",19,1044,1,1,0)
This option will run daily on off-hours to count records in files 777 & 778.
"KRN",19,1044,20)
D UPDCNTS^HLOSITE
"KRN",19,1044,"U")
COUNT HL7 MESSAGE RECORDS
"KRN",19,1045,-1)
0^5
"KRN",19,1045,0)
HLO SYSTEM MONITOR^HLO SYSTEM MONITOR^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,1045,1,0)
^19.06^1^1^3050801^^
"KRN",19,1045,1,1,0)
This option is for IRM folks to monitor the operational aspects of HLO.
"KRN",19,1045,20)
D EN^HLOUSR
"KRN",19,1045,"U")
HLO SYSTEM MONITOR
"KRN",19,1046,-1)
0^4
"KRN",19,1046,0)
HLO MESSAGE VIEWER^HLO MESSAGE VIEWER^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,1046,1,0)
^19.06^2^2^3050418^^
"KRN",19,1046,1,1,0)
This option is for viewing messages.  It is a ListManager interface that provides
"KRN",19,1046,1,2,0)
a variety of methods for selecting messages for viewing.
"KRN",19,1046,20)
D EN^HLOUSR2
"KRN",19,1046,"U")
HLO MESSAGE VIEWER
"KRN",19,1047,-1)
0^3
"KRN",19,1047,0)
HLO MAIN MENU^HL7 (Optimized) MAIN MENU^^M^^^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1047,1,0)
^19.06^1^1^3050801^^^^
"KRN",19,1047,1,1,0)
This menu contains all the options developed for HLO.
"KRN",19,1047,10,0)
^19.01IP^3^3
"KRN",19,1047,10,1,0)
1045^SM^1
"KRN",19,1047,10,1,"^")
HLO SYSTEM MONITOR
"KRN",19,1047,10,2,0)
1046^MV^2
"KRN",19,1047,10,2,"^")
HLO MESSAGE VIEWER
"KRN",19,1047,10,3,0)
1061^APPS^3
"KRN",19,1047,10,3,"^")
HLO APPLICATION REGISTRY
"KRN",19,1047,99)
60162,30178
"KRN",19,1047,"U")
HL7 (OPTIMIZED) MAIN MENU
"KRN",19,1048,-1)
0^6
"KRN",19,1048,0)
HLO SYSTEM STARTUP^HL7 (Optimized) SYSTEM STARTUP^^A^^^^^^^n^HEALTH LEVEL SEVEN^^1
"KRN",19,1048,1,0)
^19.06^2^2^3050801^^
"KRN",19,1048,1,1,0)
This option should be scheduled upon system startup to start HLO
"KRN",19,1048,1,2,0)
running.
"KRN",19,1048,20)
D:'$$CHKSTOP^HLOPROC STARTHL7^HLOPROC1
"KRN",19,1048,"U")
HL7 (OPTIMIZED) SYSTEM STARTUP
"KRN",19,1061,-1)
0^1
"KRN",19,1061,0)
HLO APPLICATION REGISTRY^HLO APPPLICATION REGISTRY^^E^^^^^^^^HEALTH LEVEL SEVEN^y
"KRN",19,1061,1,0)
^19.06^2^2^3050801^^^^
"KRN",19,1061,1,1,0)
This option allows the user to register an HL7 (Optimized) application in 
"KRN",19,1061,1,2,0)
the Application Registry File (779.2).
"KRN",19,1061,30)
HLD(779.2,
"KRN",19,1061,31)
AEMQL
"KRN",19,1061,50)
HLD(779.2,
"KRN",19,1061,51)
[HLOAPREG]
"KRN",19,1061,"U")
HLO APPPLICATION REGISTRY
"KRN",101,412,-1)
0^15
"KRN",101,412,0)
HLO SYSTEM MONITOR MENU^^^M^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,412,1,0)
^101.06^1^1^3050215^^^^
"KRN",101,412,1,1,0)
This is the menu for the HL7 (Optimized) System Monitor.
"KRN",101,412,4)
26^4
"KRN",101,412,10,0)
^101.01PA^15^15
"KRN",101,412,10,4,0)
413^LP^1^^^LIST PROCESSES
"KRN",101,412,10,4,"^")
HLO DISPLAY PROCESSES
"KRN",101,412,10,5,0)
414^DL^2^^^DOWN LINKS
"KRN",101,412,10,5,"^")
HLO DOWN LINKS
"KRN",101,412,10,6,0)
415^OQ^3^^^OUTGOING QUEUES
"KRN",101,412,10,6,"^")
HLO DISPLAY OUT-GOING QUEUES
"KRN",101,412,10,7,0)
416^IQ^4^^^INCOMING QUEUES
"KRN",101,412,10,7,"^")
HLO INCOMING QUEUES
"KRN",101,412,10,8,0)
417^BS^5^^^BRIEF STATUS
"KRN",101,412,10,8,"^")
HLO BRIEF SYSTEM STATUS
"KRN",101,412,10,9,0)
418^ML^6^^^MONITOR LINK
"KRN",101,412,10,9,"^")
HLO VIEW A LINK
"KRN",101,412,10,10,0)
419^^7^^^STOP HLO
"KRN",101,412,10,10,"^")
HLO STOP SYSTEM
"KRN",101,412,10,11,0)
420^^8^^^START HLO
"KRN",101,412,10,11,"^")
HLO START MENU
"KRN",101,412,10,12,0)
421^TL^9^^^TEST TCP LINK
"KRN",101,412,10,12,"^")
HLO TEST LINK
"KRN",101,412,10,13,0)
427^RT^10^^^RealTime Mode
"KRN",101,412,10,13,"^")
HLO MONITOR MODE
"KRN",101,412,10,14,0)
428^SM^11^^^Scroll Mode
"KRN",101,412,10,14,"^")
HLO SCROLL MODE
"KRN",101,412,10,15,0)
429^SQ^12^^^STRT/STP QUE
"KRN",101,412,10,15,"^")
HLO START/STOP ONE QUEUE
"KRN",101,412,26)
D SHOW^VALM
"KRN",101,412,28)
Select Action:
"KRN",101,412,99)
60162,30178
"KRN",101,413,-1)
0^4
"KRN",101,413,0)
HLO DISPLAY PROCESSES^VIEW PROCESSES^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,413,1,0)
^101.06^1^1^3040921^^
"KRN",101,413,1,1,0)
Displays a list of the HL7 processes.
"KRN",101,413,2,0)
^101.02A^1^1
"KRN",101,413,2,1,0)
VP
"KRN",101,413,2,"B","VP",1)

"KRN",101,413,20)
D PROCS^HLOUSR S (HLSCREEN,VALMSG)="Running Processes"
"KRN",101,413,99)
60162,30178
"KRN",101,414,-1)
0^7
"KRN",101,414,0)
HLO DOWN LINKS^DOWN LINKS^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,414,1,0)
^101.06^1^1^3050208^^^^
"KRN",101,414,1,1,0)
This action lists the links that have been down for more than 5 minutes.
"KRN",101,414,2,0)
^101.02A^1^1
"KRN",101,414,2,1,0)
DL
"KRN",101,414,2,"B","DL",1)

"KRN",101,414,20)
D DOWNLINK^HLOUSR
"KRN",101,414,99)
60162,30178
"KRN",101,415,-1)
0^3
"KRN",101,415,0)
HLO DISPLAY OUT-GOING QUEUES^VIEW QUEUES^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,415,1,0)
^101.06^1^1^3040921^^^
"KRN",101,415,1,1,0)
Displays all the client links and their queues with pending messages.
"KRN",101,415,2,0)
^101.02A^2^1
"KRN",101,415,2,2,0)
VQ
"KRN",101,415,2,"B","VQ",2)

"KRN",101,415,20)
D OUTQUEUE^HLOUSR
"KRN",101,415,99)
60162,30178
"KRN",101,416,-1)
0^8
"KRN",101,416,0)
HLO INCOMING QUEUES^INCOMING QUEUES^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,416,1,0)
^101.06^1^1^3041116^^
"KRN",101,416,1,1,0)
Displays each incoming queue and a count of the messages on it.
"KRN",101,416,2,0)
^101.02A^1^1
"KRN",101,416,2,1,0)
IQ
"KRN",101,416,2,"B","IQ",1)

"KRN",101,416,20)
D INQUEUE^HLOUSR
"KRN",101,416,99)
60162,30178
"KRN",101,417,-1)
0^2
"KRN",101,417,0)
HLO BRIEF SYSTEM STATUS^BRIEF SYSTEM STATUS^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,417,1,0)
^^1^1^3040922^
"KRN",101,417,1,1,0)
Provides an overview of the system operational status.
"KRN",101,417,2,0)
^101.02A^1^1
"KRN",101,417,2,1,0)
BS
"KRN",101,417,2,"B","BS",1)

"KRN",101,417,20)
D BRIEF^HLOUSR S (HLSCREEN,VALMSG)="Brief System Status"
"KRN",101,417,99)
60162,30178
"KRN",101,418,-1)
0^18
"KRN",101,418,0)
HLO VIEW A LINK^VIEW LINK^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,418,1,0)
^^1^1^3040922^
"KRN",101,418,1,1,0)
Used to monitor in real-time the count of messages on a single link.
"KRN",101,418,2,0)
^101.02A^1^1
"KRN",101,418,2,1,0)
VL
"KRN",101,418,2,"B","VL",1)

"KRN",101,418,20)
D VIEWLINK^HLOUSR
"KRN",101,418,99)
60162,30178
"KRN",101,419,-1)
0^14
"KRN",101,419,0)
HLO STOP SYSTEM^STOP HLO^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,419,1,0)
^101.06^1^1^3050318^^^
"KRN",101,419,1,1,0)
Shuts down the HL7 (Optimized) message system.
"KRN",101,419,2,0)
^101.02A^^0
"KRN",101,419,20)
D STOP^HLOUSR
"KRN",101,419,99)
60162,30178
"KRN",101,420,-1)
0^12
"KRN",101,420,0)
HLO START MENU^START HLO^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,420,1,0)
^101.06^1^1^3050318^^^
"KRN",101,420,1,1,0)
This action is used to start the HL7 (Optimized) message engine.
"KRN",101,420,20)
D STARTHL7^HLOPROC1 H 4 D:HLSCREEN="Brief System Status" BRIEF^HLOUSR D:HLSCREEN="Running Processes" PROCS^HLOUSR S VALMBCK="R",VALMSG="HL7 (OPTIMIZED) has been started..."
"KRN",101,420,99)
60162,30178
"KRN",101,421,-1)
0^16
"KRN",101,421,0)
HLO TEST LINK^TEST LINK^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,421,1,0)
^^3^3^3040926^
"KRN",101,421,1,1,0)
This action allows the user to select a link.  The user is then informed
"KRN",101,421,1,2,0)
as to whether or not connectivity can be established with the link.
"KRN",101,421,1,3,0)
Applies only to TCP links
"KRN",101,421,2,0)
^101.02A^1^1
"KRN",101,421,2,1,0)
TL
"KRN",101,421,2,"B","TL",1)

"KRN",101,421,20)
D TESTLINK^HLOUSR S VALMSG=HLSCREEN,VALMBCK="R"
"KRN",101,421,99)
60162,30178
"KRN",101,422,-1)
0^9
"KRN",101,422,0)
HLO MESSAGE VIEWER MENU^MESSAGE VIEWER MENU^^M^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,422,1,0)
^101.06^1^1^3050314^^^^
"KRN",101,422,1,1,0)
This is the action menu for the List Template 'HLO MESSAGE VIEWER'.
"KRN",101,422,4)
26^4
"KRN",101,422,10,0)
^101.01PA^5^5
"KRN",101,422,10,1,0)
423^DM^1^^^DISPLAY MSG
"KRN",101,422,10,1,"^")
HLO DISPLAY SINGLE MESSAGE
"KRN",101,422,10,2,0)
424^SE^2^^^SYSTEM ERRORS
"KRN",101,422,10,2,"^")
HLO DISPLAY SYSTEM ERRORED MESSAGES
"KRN",101,422,10,3,0)
425^AE^3^^^APPLICATION ERRORS
"KRN",101,422,10,3,"^")
HLO APPLICATION ERRORED MESSAGES
"KRN",101,422,10,4,0)
426^TF^4^^^TRANSMISSION FAILURES
"KRN",101,422,10,4,"^")
HLO TRANSMISSION FAILURES
"KRN",101,422,10,5,0)
432^MS^5^^^MESSAGE SEARCH
"KRN",101,422,10,5,"^")
HLO MESSAGE SEARCH
"KRN",101,422,26)
D SHOW^VALM
"KRN",101,422,28)
Select Action:
"KRN",101,422,99)
60162,30178
"KRN",101,423,-1)
0^5
"KRN",101,423,0)
HLO DISPLAY SINGLE MESSAGE^DISPLAY A MESSAGE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,423,1,0)
^101.06^1^1^3050413^^
"KRN",101,423,1,1,0)
This action allows the user to select a message.  It is then displayed.
"KRN",101,423,2,0)
^101.02A^1^1
"KRN",101,423,2,1,0)
DM
"KRN",101,423,2,"B","DM",1)

"KRN",101,423,20)
D EN^HLOUSR1
"KRN",101,423,99)
60162,30178
"KRN",101,424,-1)
0^6
"KRN",101,424,0)
HLO DISPLAY SYSTEM ERRORED MESSAGES^SYSTEM ERRORED MESSAGES^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,424,1,0)
^101.06^3^3^3050203^^
"KRN",101,424,1,1,0)
This ListManager action displays a list of messages from the Redesigned
"KRN",101,424,1,2,0)
Optimized HL7 packagethat were determined to be in error by the receiving
"KRN",101,424,1,3,0)
system.
"KRN",101,424,20)
D SHOWLIST^HLOUSR2("SE")
"KRN",101,424,99)
60162,30178
"KRN",101,425,-1)
0^1
"KRN",101,425,0)
HLO APPLICATION ERRORED MESSAGES^HLO APPLICATION ERRORED MESSAGES^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,425,1,0)
^101.06^2^2^3050208^^^
"KRN",101,425,1,1,0)
This ListManager action displays a list of messages from the HLRO HL7 package
"KRN",101,425,1,2,0)
that were determined by the receiving application to be in error.
"KRN",101,425,20)
D SHOWLIST^HLOUSR2("AE")
"KRN",101,425,99)
60162,30178
"KRN",101,426,-1)
0^17
"KRN",101,426,0)
HLO TRANSMISSION FAILURES^HLO TRANSMISSION FAILURES^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,426,1,0)
^101.06^2^2^3050203^^^^
"KRN",101,426,1,1,0)
This ListManager action displays a list of messages from the Redesigned
"KRN",101,426,1,2,0)
Optimized HL7 package that failed to be transmitted.
"KRN",101,426,20)
D SHOWLIST^HLOUSR2("TF")
"KRN",101,426,99)
60162,30178
"KRN",101,427,-1)
0^10
"KRN",101,427,0)
HLO MONITOR MODE^MONITOR MODE^^A^^^^^^^^HL7 PERFORMANCE ENHANCMENTS
"KRN",101,427,1,0)
^^3^3^3041009^
"KRN",101,427,1,1,0)
This ListManager action allows the user to specify that the screen should 
"KRN",101,427,1,2,0)
operate in a dynamic mode where it is updated automatically every several
"KRN",101,427,1,3,0)
seconds.
"KRN",101,427,2,0)
^101.02A^1^1
"KRN",101,427,2,1,0)
MM
"KRN",101,427,2,"B","MM",1)

"KRN",101,427,20)
D UPDMODE^HLOUSR
"KRN",101,427,99)
60162,30178
"KRN",101,428,-1)
0^11
"KRN",101,428,0)
HLO SCROLL MODE^SCROLL MODE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,428,1,0)
^101.06^1^1^3041116^^
"KRN",101,428,1,1,0)
This ListManager action is to switch the display to automatic scrolling mode.
"KRN",101,428,2,0)
^101.02A^1^1
"KRN",101,428,2,1,0)
SM
"KRN",101,428,2,"B","SM",1)

"KRN",101,428,20)
D SCRLMODE^HLOUSR1
"KRN",101,428,99)
60162,30178
"KRN",101,429,-1)
0^13
"KRN",101,429,0)
HLO START/STOP ONE QUEUE^STRT/STP QUEUE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,429,1,0)
^^1^1^3041015^
"KRN",101,429,1,1,0)
This ListManager action is used to start or stop a queue.
"KRN",101,429,20)
D STRTSTPQ^HLOUSR2
"KRN",101,429,99)
60162,30178
"KRN",101,432,-1)
0^19
"KRN",101,432,0)
HLO MESSAGE SEARCH^MESSAGE SEARCH^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,432,1,0)
^101.06^2^2^3050315^^^
"KRN",101,432,1,1,0)
This action allows the user to enter search criteria, then up to 200 messages
"KRN",101,432,1,2,0)
that meet the criteria are displayed.
"KRN",101,432,2,0)
^101.02A^1^1
"KRN",101,432,2,1,0)
MS
"KRN",101,432,2,"B","MS",1)

"KRN",101,432,20)
D EN^HLOUSR3
"KRN",101,432,99)
60162,30178
"KRN",101,441,-1)
0^20
"KRN",101,441,0)
HLO MESSAGE SEARCH MENU^MESSAGE SEARCH^^M^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,441,1,0)
^101.06^1^1^3050801^^^
"KRN",101,441,1,1,0)
This is the protocol menu for the HLO Message Search Utility.
"KRN",101,441,4)
26^4
"KRN",101,441,10,0)
^101.01PA^1^1
"KRN",101,441,10,1,0)
423^DM^1^^^Display Message
"KRN",101,441,10,1,"^")
HLO DISPLAY SINGLE MESSAGE
"KRN",101,441,26)
D SHOW^VALM
"KRN",101,441,28)
Select Action:
"KRN",101,441,99)
60162,30178
"KRN",409.61,238,-1)
0^2
"KRN",409.61,238,0)
HLO SYSTEM MONITOR^1^1^80^3^18^1^1^HLO HL7 SYSTEM MONITOR^HLO SYSTEM MONITOR MENU^HLO SYSTEM MONITOR^1^^1
"KRN",409.61,238,1)
^VALM HIDDEN ACTIONS
"KRN",409.61,238,"ARRAY")
 ^TMP("HLO SYSTEM MONITOR",$J)
"KRN",409.61,238,"COL",0)
^409.621^1^1
"KRN",409.61,238,"COL",1,0)
COL 1^2^30^^RH^0
"KRN",409.61,238,"COL","AIDENT",0,1)

"KRN",409.61,238,"COL","B","COL 1",1)

"KRN",409.61,238,"FNL")
D EXIT^HLOUSR
"KRN",409.61,238,"HDR")

"KRN",409.61,238,"HLP")
D HELP^HLOUSR
"KRN",409.61,238,"INIT")
D BRIEF^HLOUSR
"KRN",409.61,239,-1)
0^1
"KRN",409.61,239,0)
HLO MESSAGE VIEWER^1^1^90^3^20^1^1^HLO MESSAGE VIEWER^HLO MESSAGE VIEWER MENU^HLO MESSAGE VIEWER^1^^1
"KRN",409.61,239,1)
^VALM HIDDEN ACTIONS
"KRN",409.61,239,"ARRAY")
 ^TMP("HLO MESSAGE VIEWER",$J)
"KRN",409.61,239,"COL",0)
^409.621^1^1
"KRN",409.61,239,"COL",1,0)
COL 1^2^78^ MsgID          MsgType  Dt/Tm                Error Text^RH^0
"KRN",409.61,239,"COL","AIDENT",0,1)

"KRN",409.61,239,"COL","B","COL 1",1)

"KRN",409.61,239,"FNL")
D EXIT^HLOUSR1
"KRN",409.61,239,"HDR")
D HEADER^HLOUSR2
"KRN",409.61,239,"HLP")
D HELP^HLOUSR1
"KRN",409.61,239,"INIT")
D BLANK^HLOUSR1
"KRN",409.61,240,-1)
0^3
"KRN",409.61,240,0)
HLO MESSAGE SEARCH^1^1^80^4^20^1^1^SEARCH LIST^HLO MESSAGE SEARCH MENU^Message Search^1
"KRN",409.61,240,1)
^VALM HIDDEN ACTIONS
"KRN",409.61,240,"ARRAY")
 ^TMP($J,"HLO MSG SEARCH")
"KRN",409.61,240,"COL",0)
^409.621^2^2
"KRN",409.61,240,"COL",1,0)
DT/TM^6^15^Dt/Tm^HR
"KRN",409.61,240,"COL",2,0)
FACILTITY^26^30^Facility^RH
"KRN",409.61,240,"COL","B","DT/TM",1)

"KRN",409.61,240,"COL","B","FACILTITY",2)

"KRN",409.61,240,"FNL")
D EXIT^HLOUSR3
"KRN",409.61,240,"HDR")
D HDR^HLOUSR3
"KRN",409.61,240,"HLP")
D HLP^HLOUSR3
"KRN",409.61,240,"INIT")
D SEARCH^HLOUSR3
"KRN",409.61,241,-1)
0^4
"KRN",409.61,241,0)
HLO SINGLE MESSAGE DISPLAY^2^1^80^3^20^1^1^MESSAGE^^Single Message Display^1
"KRN",409.61,241,1)
^VALM HIDDEN ACTIONS
"KRN",409.61,241,"ARRAY")
 ^TMP($J,"HLO SINGLE MESSAGE DISPLAY")
"KRN",409.61,241,"FNL")
D EXIT^HLOUSR3
"KRN",409.61,241,"HDR")
D HDR^HLOUSR1
"KRN",409.61,241,"HLP")
D HLP^HLOUSR1
"KRN",409.61,241,"INIT")
D DISPLAY^HLOUSR1
"MBREQ")
0
"ORD",7,.402)
.402;7;;;EDEOUT^DIFROMSO(.402,DA,"",XPDA);FPRE^DIFROMSI(.402,"",XPDA);EPRE^DIFROMSI(.402,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.402,DA,"",XPDA);DEL^DIFROMSK(.402,"",%)
"ORD",7,.402,0)
INPUT TEMPLATE
"ORD",8,.403)
.403;8;;;EDEOUT^DIFROMSO(.403,DA,"",XPDA);FPRE^DIFROMSI(.403,"",XPDA);EPRE^DIFROMSI(.403,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.403,DA,"",XPDA);DEL^DIFROMSK(.403,"",%)
"ORD",8,.403,0)
FORM
"ORD",15,101)
101;15;;;PRO^XPDTA;PROF1^XPDIA;PROE1^XPDIA;PROF2^XPDIA;;PRODEL^XPDIA
"ORD",15,101,0)
PROTOCOL
"ORD",17,409.61)
409.61;17;1;;;;;;;LMDEL^XPDIA1
"ORD",17,409.61,0)
LIST TEMPLATE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
126^3050921^1000061
"PKG",9,22,1,"PAH",1,1,0)
^^1^1^3050921
"PKG",9,22,1,"PAH",1,1,1,0)
HL7 2.0
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
38
"RTN","HLMA3")
0^48^B26373063
"RTN","HLMA3",1,0)
HLMA3 ;OIFO-O/RJH-API TO LOGICAL LINK FILE ;12/29/04  17:03
"RTN","HLMA3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLMA3",3,0)
 Q
"RTN","HLMA3",4,0)
 ;
"RTN","HLMA3",5,0)
IEDOMAIN() ;
"RTN","HLMA3",6,0)
 ; API for retrieving domain of site's local Interface Engine
"RTN","HLMA3",7,0)
 ; from logical link VA-VIE
"RTN","HLMA3",8,0)
 ; 
"RTN","HLMA3",9,0)
 ; no input
"RTN","HLMA3",10,0)
 ; output:
"RTN","HLMA3",11,0)
 ; return DNS domain if available, else return null string.
"RTN","HLMA3",12,0)
 ;
"RTN","HLMA3",13,0)
 N HLTEMP
"RTN","HLMA3",14,0)
 ; retrive data from DNS Domain field of file #870
"RTN","HLMA3",15,0)
 S HLTEMP("VA-VIE-IEN")=$O(^HLCS(870,"B","VA-VIE",0))
"RTN","HLMA3",16,0)
 S HLTEMP("DOMAIN")=$P($G(^HLCS(870,+$G(HLTEMP("VA-VIE-IEN")),0)),"^",8)
"RTN","HLMA3",17,0)
 Q HLTEMP("DOMAIN")
"RTN","HLMA3",18,0)
 ;
"RTN","HLMA3",19,0)
LINKAPI(LINK,DOMAIN,AUTOSTAR) ;
"RTN","HLMA3",20,0)
 ; API for updating fields, DNS Domain and Autostart, of logical link
"RTN","HLMA3",21,0)
 ; the API may only be applied to production account.
"RTN","HLMA3",22,0)
 ; inputs: 
"RTN","HLMA3",23,0)
 ; LINK -     1. ien of HL Logical Link file (#870), or 
"RTN","HLMA3",24,0)
 ;            2. name (field 'Node'- #.01) of HL Logical Link file
"RTN","HLMA3",25,0)
 ;               (#870)
"RTN","HLMA3",26,0)
 ; DOMAIN -   data for DNS domain field (field #.08)
"RTN","HLMA3",27,0)
 ; AUTOSTAR - data for Autostart field (field #4.5),
"RTN","HLMA3",28,0)
 ;            0 for Disabled, 1 for Enabled. 
"RTN","HLMA3",29,0)
 ;            Otherwise, data won't be updated
"RTN","HLMA3",30,0)
 ;
"RTN","HLMA3",31,0)
 ; output could be either of the following:
"RTN","HLMA3",32,0)
 ; 1^DOMAIN,AUTOSTART have been updated 
"RTN","HLMA3",33,0)
 ; 1^DOMAIN has been updated 
"RTN","HLMA3",34,0)
 ; 1^AUTOSTART has been updated 
"RTN","HLMA3",35,0)
 ; -1^none has been updated
"RTN","HLMA3",36,0)
 ; -1^the api may not be applied to non-production account 
"RTN","HLMA3",37,0)
 ;
"RTN","HLMA3",38,0)
 N HLTEMP,HLZ
"RTN","HLMA3",39,0)
 ;retrieve data from HL Communication Server Parameter file (#869.3)
"RTN","HLMA3",40,0)
 ; - Default Processing Id (#.03) 
"RTN","HLMA3",41,0)
 ;
"RTN","HLMA3",42,0)
 S HLTEMP("PARAM")=$$PARAM^HLCS2
"RTN","HLMA3",43,0)
 S HLTEMP("DEFAULT-PROCESSING-ID")=$P(HLTEMP("PARAM"),"^",3)
"RTN","HLMA3",44,0)
 ;
"RTN","HLMA3",45,0)
 ; quit if this is a non-production account
"RTN","HLMA3",46,0)
 Q:HLTEMP("DEFAULT-PROCESSING-ID")'="P" "-1^the api may not be applied to non-production account"
"RTN","HLMA3",47,0)
 ;
"RTN","HLMA3",48,0)
 ; get input data for link ien or name
"RTN","HLMA3",49,0)
 S HLTEMP("IEN")=$G(LINK)
"RTN","HLMA3",50,0)
 I 'HLTEMP("IEN")&($L(HLTEMP("IEN"))) S HLTEMP("IEN")=+$O(^HLCS(870,"B",HLTEMP("IEN"),0))
"RTN","HLMA3",51,0)
 ;
"RTN","HLMA3",52,0)
 ; quit if no ien
"RTN","HLMA3",53,0)
 Q:'HLTEMP("IEN") "-1^none has been updated"
"RTN","HLMA3",54,0)
 ;
"RTN","HLMA3",55,0)
 ; get input data for DNS domain field
"RTN","HLMA3",56,0)
 S HLTEMP("DOMAIN")=$G(DOMAIN)
"RTN","HLMA3",57,0)
 ;
"RTN","HLMA3",58,0)
 ; get IP address for the domain
"RTN","HLMA3",59,0)
 I $L(HLTEMP("DOMAIN")) S HLTEMP("IP")=$$ADDRESS^XLFNSLK(HLTEMP("DOMAIN"))
"RTN","HLMA3",60,0)
 ;
"RTN","HLMA3",61,0)
 ; invalid domain, set it to null
"RTN","HLMA3",62,0)
 I $L(HLTEMP("DOMAIN")),'$G(HLTEMP("IP")) S HLTEMP("DOMAIN")=""
"RTN","HLMA3",63,0)
 ;
"RTN","HLMA3",64,0)
 ; get input data for Autostart field
"RTN","HLMA3",65,0)
 S HLTEMP("AUTOSTART")=$G(AUTOSTAR)
"RTN","HLMA3",66,0)
 ;
"RTN","HLMA3",67,0)
 ; quit if invalid data for both fields
"RTN","HLMA3",68,0)
 Q:($L(HLTEMP("DOMAIN"),".")'>2)&'((HLTEMP("AUTOSTART")="0")!(HLTEMP("AUTOSTART")="1")) "-1^none has been updated"
"RTN","HLMA3",69,0)
 I $L(HLTEMP("DOMAIN"),".")>2 D
"RTN","HLMA3",70,0)
 . S HLZ(870,HLTEMP("IEN")_",",.08)=HLTEMP("DOMAIN")
"RTN","HLMA3",71,0)
 I (HLTEMP("AUTOSTART")="0")!(HLTEMP("AUTOSTART")="1") D
"RTN","HLMA3",72,0)
 . S HLZ(870,HLTEMP("IEN")_",",4.5)=HLTEMP("AUTOSTART")
"RTN","HLMA3",73,0)
 D FILE^DIE("S","HLZ","HLZ")
"RTN","HLMA3",74,0)
 ;
"RTN","HLMA3",75,0)
 ; both fields are updated
"RTN","HLMA3",76,0)
 Q:$D(HLZ(870,HLTEMP("IEN")_",",.08))&($D(HLZ(870,HLTEMP("IEN")_",",4.5))) "1^DOMAIN,AUTOSTART have been updated"
"RTN","HLMA3",77,0)
 ;
"RTN","HLMA3",78,0)
 ; only update DNS Domain field
"RTN","HLMA3",79,0)
 Q:$D(HLZ(870,HLTEMP("IEN")_",",.08)) "1^DOMAIN has been updated"
"RTN","HLMA3",80,0)
 ;
"RTN","HLMA3",81,0)
 ; only update Autostart field
"RTN","HLMA3",82,0)
 Q:$D(HLZ(870,HLTEMP("IEN")_",",4.5)) "1^AUTOSTART has been updated"
"RTN","HLMA3",83,0)
 ;
"RTN","HLMA3",84,0)
IP(DA,HLIP) ;
"RTN","HLMA3",85,0)
 ; 1. API to update field TCP/IP Address, #870,400.01.
"RTN","HLMA3",86,0)
 ; 2. called from input transform of #870,.08 DNS Domain to update
"RTN","HLMA3",87,0)
 ;    field TCP/IP Address, #870,400.01.
"RTN","HLMA3",88,0)
 ;
"RTN","HLMA3",89,0)
 ; input:
"RTN","HLMA3",90,0)
 ; DA -   1. ien of HL Logical Link file (#870), or 
"RTN","HLMA3",91,0)
 ;        2. name (field 'Node'- #.01) of HL Logical Link file (#870)
"RTN","HLMA3",92,0)
 ; HLIP - IP addresses
"RTN","HLMA3",93,0)
 ; 
"RTN","HLMA3",94,0)
 ; output:
"RTN","HLMA3",95,0)
 ; return IP address updated to the field if valid,
"RTN","HLMA3",96,0)
 ; else return null string.
"RTN","HLMA3",97,0)
 ;
"RTN","HLMA3",98,0)
 N HLZ,HLI,HLTEMP
"RTN","HLMA3",99,0)
 ; 
"RTN","HLMA3",100,0)
 ; get input data
"RTN","HLMA3",101,0)
 S DA=$G(DA)
"RTN","HLMA3",102,0)
 I 'DA&($L(DA)) S DA=+$O(^HLCS(870,"B",DA,0))
"RTN","HLMA3",103,0)
 ;
"RTN","HLMA3",104,0)
 ; invalid ien
"RTN","HLMA3",105,0)
 Q:'DA ""
"RTN","HLMA3",106,0)
 ;
"RTN","HLMA3",107,0)
 ; invalid ip
"RTN","HLMA3",108,0)
 Q:('HLIP) ""
"RTN","HLMA3",109,0)
 ;
"RTN","HLMA3",110,0)
 ; get port number
"RTN","HLMA3",111,0)
 S HLTEMP("PORT")=+$P($G(^HLCS(870,DA,400)),"^",2)
"RTN","HLMA3",112,0)
 ;
"RTN","HLMA3",113,0)
 ; invalid port
"RTN","HLMA3",114,0)
 Q:'HLTEMP("PORT") ""
"RTN","HLMA3",115,0)
 ;
"RTN","HLMA3",116,0)
 S HLTEMP("IP")=""
"RTN","HLMA3",117,0)
 S HLTEMP("IP-VALID")=0
"RTN","HLMA3",118,0)
 S HLTEMP("IP-COUNT")=$L($G(HLIP),",")
"RTN","HLMA3",119,0)
 F HLI=1:1:HLTEMP("IP-COUNT") D  Q:HLTEMP("IP-VALID")
"RTN","HLMA3",120,0)
 . S HLTEMP("IP")=$P(HLIP,",",HLI)
"RTN","HLMA3",121,0)
 . D CALL^%ZISTCP(HLTEMP("IP"),HLTEMP("PORT"))
"RTN","HLMA3",122,0)
 . I 'POP D
"RTN","HLMA3",123,0)
 .. D CLOSE^%ZISTCP
"RTN","HLMA3",124,0)
 .. S HLTEMP("IP-VALID")=HLTEMP("IP")
"RTN","HLMA3",125,0)
 ;
"RTN","HLMA3",126,0)
 ; invalid ip, return null
"RTN","HLMA3",127,0)
 Q:'HLTEMP("IP-VALID") ""
"RTN","HLMA3",128,0)
 ;
"RTN","HLMA3",129,0)
 ; valid data to update the field
"RTN","HLMA3",130,0)
 S HLZ(870,DA_",",400.01)=HLTEMP("IP-VALID")
"RTN","HLMA3",131,0)
 D FILE^DIE("E","HLZ","HLZ")
"RTN","HLMA3",132,0)
 ;
"RTN","HLMA3",133,0)
 ; return the valid ip
"RTN","HLMA3",134,0)
 Q HLTEMP("IP-VALID")
"RTN","HLMA3",135,0)
 ;
"RTN","HLMA3",136,0)
FACILITY(LINK,DELIMITR) ;
"RTN","HLMA3",137,0)
 ; API for retrieving the station number and domain fields of logical
"RTN","HLMA3",138,0)
 ; link (file #870) and to be usd for populating in field MSH-6 
"RTN","HLMA3",139,0)
 ; (receiving facility) of message header.
"RTN","HLMA3",140,0)
 ;
"RTN","HLMA3",141,0)
 ; output format: institution number<delimiter>domain<delimiter>DNS
"RTN","HLMA3",142,0)
 ;
"RTN","HLMA3",143,0)
 ; inputs:
"RTN","HLMA3",144,0)
 ; LINK -       1. ien of HL Logical Link file (#870), or
"RTN","HLMA3",145,0)
 ;              2. name (field 'Node'- #.01) of HL Logical Link file
"RTN","HLMA3",146,0)
 ;               (#870)
"RTN","HLMA3",147,0)
 ; DELIMITR -  such as "~", "^", etc.
"RTN","HLMA3",148,0)
 ;
"RTN","HLMA3",149,0)
 ; output:
"RTN","HLMA3",150,0)
 ;        1.  institution number<delimiter>domain<delimiter>DNS
"RTN","HLMA3",151,0)
 ;        2.  <null> if input data is invalid
"RTN","HLMA3",152,0)
 ;
"RTN","HLMA3",153,0)
 ; note: if the domain retrieved from DNS domain field with "HL7."
"RTN","HLMA3",154,0)
 ;       or "MPI." prefixed at the beginning of the domain, the
"RTN","HLMA3",155,0)
 ;       prifixed "HL7." or "MPI." will be removed, in order to
"RTN","HLMA3",156,0)
 ;       meet the current implementation of Vista HL7.  Current
"RTN","HLMA3",157,0)
 ;       VISTA HL7 domain is retrieved from MailMan domain field,
"RTN","HLMA3",158,0)
 ;       the "HL7." or "MPI." is not prefixed at the beginning of
"RTN","HLMA3",159,0)
 ;       the domain when it is populated in field MSH-6 (receiving
"RTN","HLMA3",160,0)
 ;       facility) of message header. 
"RTN","HLMA3",161,0)
 ;
"RTN","HLMA3",162,0)
 N HLLINK,HLCINS,HLCDOM
"RTN","HLMA3",163,0)
 ;
"RTN","HLMA3",164,0)
 ; get input data for link ien or name
"RTN","HLMA3",165,0)
 S HLLINK=$G(LINK)
"RTN","HLMA3",166,0)
 I 'HLLINK,HLLINK]"" D
"RTN","HLMA3",167,0)
 .S HLLINK=$O(^HLCS(870,"B",HLLINK,0))
"RTN","HLMA3",168,0)
 ;
"RTN","HLMA3",169,0)
 ; quit if no ien
"RTN","HLMA3",170,0)
 Q:'HLLINK ""
"RTN","HLMA3",171,0)
 ;
"RTN","HLMA3",172,0)
 ; get DELIMITR
"RTN","HLMA3",173,0)
 S DELIMITR=$G(DELIMITR)
"RTN","HLMA3",174,0)
 ;
"RTN","HLMA3",175,0)
 ; quit if invalid DELIMITR
"RTN","HLMA3",176,0)
 Q:$L(DELIMITR)'=1 ""
"RTN","HLMA3",177,0)
 ;
"RTN","HLMA3",178,0)
 ; retrive data from DNS Domain field of file #870
"RTN","HLMA3",179,0)
 S HLCDOM("DNS")=$P($G(^HLCS(870,+HLLINK,0)),"^",8)
"RTN","HLMA3",180,0)
 ;
"RTN","HLMA3",181,0)
 ; remove the first piece if the first piece is "HL7" or "MPI"
"RTN","HLMA3",182,0)
 I ($P(HLCDOM("DNS"),".")="HL7")!($P(HLCDOM("DNS"),".")="MPI") D
"RTN","HLMA3",183,0)
 . S HLCDOM("DNS")=$P(HLCDOM("DNS"),".",2,99)
"RTN","HLMA3",184,0)
 ;
"RTN","HLMA3",185,0)
 S (HLCINS,HLCDOM)=""
"RTN","HLMA3",186,0)
 S HLCINS=$P(^HLCS(870,HLLINK,0),U,2)
"RTN","HLMA3",187,0)
 S HLCDOM=$P(^HLCS(870,HLLINK,0),U,7)
"RTN","HLMA3",188,0)
 ;
"RTN","HLMA3",189,0)
 ; quit if no data in institution and domain fields
"RTN","HLMA3",190,0)
 Q:('HLCINS)&('HLCDOM)&('$L(HLCDOM("DNS"))) ""
"RTN","HLMA3",191,0)
 ;
"RTN","HLMA3",192,0)
 ; initialize result
"RTN","HLMA3",193,0)
 S HLLINK("RESULT")=""
"RTN","HLMA3",194,0)
 ;
"RTN","HLMA3",195,0)
 ; if instition ien exists
"RTN","HLMA3",196,0)
 I HLCINS D
"RTN","HLMA3",197,0)
 . S HLCINS=$P($G(^DIC(4,HLCINS,99)),U)
"RTN","HLMA3",198,0)
 . ;
"RTN","HLMA3",199,0)
 . ; if valid station number exists
"RTN","HLMA3",200,0)
 . I HLCINS D
"RTN","HLMA3",201,0)
 .. ; set station number to the first piece of the result
"RTN","HLMA3",202,0)
 .. S HLLINK("RESULT")=HLCINS
"RTN","HLMA3",203,0)
 ;
"RTN","HLMA3",204,0)
 ; if MailMan domain ien exists
"RTN","HLMA3",205,0)
 I HLCDOM D
"RTN","HLMA3",206,0)
 . ;get MailMan domain name
"RTN","HLMA3",207,0)
 . S HLCDOM=$P(^DIC(4.2,HLCDOM,0),U)
"RTN","HLMA3",208,0)
 ;
"RTN","HLMA3",209,0)
 ; DNS domain overides MailMan domain
"RTN","HLMA3",210,0)
 I ($L(HLCDOM("DNS"),".")>2) D
"RTN","HLMA3",211,0)
 . S HLCDOM=HLCDOM("DNS")
"RTN","HLMA3",212,0)
 ;
"RTN","HLMA3",213,0)
 ; set third piece as "DNS" if domain is valid
"RTN","HLMA3",214,0)
 I ($L(HLCDOM,".")>2) D
"RTN","HLMA3",215,0)
 . ; set domain to the 2nd and 3rd pieces of the result
"RTN","HLMA3",216,0)
 . S HLLINK("RESULT")=HLLINK("RESULT")_DELIMITR_HLCDOM_DELIMITR_"DNS"
"RTN","HLMA3",217,0)
 Q HLLINK("RESULT")
"RTN","HLMA3",218,0)
 ;
"RTN","HLOAPI")
0^1^B35456611
"RTN","HLOAPI",1,0)
HLOAPI ;ALB/CJM-HL7 - Developer API's for sending & receiving messages ;02/04/2004
"RTN","HLOAPI",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOAPI",3,0)
 ;
"RTN","HLOAPI",4,0)
NEWMSG(PARMS,HLMSTATE,ERROR) ;
"RTN","HLOAPI",5,0)
 ;Starts a new message.  
"RTN","HLOAPI",6,0)
 ;Input: 
"RTN","HLOAPI",7,0)
 ;   PARMS( *pass by reference*
"RTN","HLOAPI",8,0)
 ;     "COUNTRY")=3 character country code (optional)
"RTN","HLOAPI",9,0)
 ;     "CONTINUATION POINTER" -indicates a fragmented message
"RTN","HLOAPI",10,0)
 ;     "EVENT")=3 character event type (required)
"RTN","HLOAPI",11,0)
 ;     "FIELD SEPARATOR")=field separator (optional, defaults to "|")
"RTN","HLOAPI",12,0)
 ;     "ENCODING CHARACTERS")= 4 HL7 encoding characters (optional,defaults to "^~\&")
"RTN","HLOAPI",13,0)
 ;     "MESSAGE STRUCTURE" - MSH 9, component 3 - a code from the standard HL7 table (optional)
"RTN","HLOAPI",14,0)
 ;     "MESSAGE TYPE")=3 character message type (required)
"RTN","HLOAPI",15,0)
 ;     "PROCESSING MODE" - MSH 11, component 2 - a 1 character code (optional)
"RTN","HLOAPI",16,0)
 ;     "VERSION")=the HL7 Version ID, for example, "2.4" (optional, defaults to 2.4)
"RTN","HLOAPI",17,0)
 ;Output:
"RTN","HLOAPI",18,0)
 ;  Function- returns 1 on success, 0 on failure
"RTN","HLOAPI",19,0)
 ;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",20,0)
 ;  PARMS - left defined when the function returns
"RTN","HLOAPI",21,0)
 ;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",22,0)
 ;
"RTN","HLOAPI",23,0)
 ;
"RTN","HLOAPI",24,0)
 N DATA,I,SYSTEM,SUCCESS
"RTN","HLOAPI",25,0)
 S SUCCESS=0
"RTN","HLOAPI",26,0)
 K ERROR,HLMSTATE
"RTN","HLOAPI",27,0)
 D
"RTN","HLOAPI",28,0)
 .I $L($G(PARMS("PROCESSING MODE"))),$L(PARMS("PROCESSING MODE"))'=1 S ERROR="INVALID PROCESSING MODE" Q
"RTN","HLOAPI",29,0)
 .I $L($G(PARMS("COUNTRY"))),$L(PARMS("COUNTRY"))'=3 S ERROR="INVALID COUNTRY CODE" Q
"RTN","HLOAPI",30,0)
 .I $L($G(PARMS("EVENT")))'=3 S ERROR="INVALID EVENT CODE" Q
"RTN","HLOAPI",31,0)
 .I $L($G(PARMS("MESSAGE TYPE")))'=3 S ERROR="INVALID MESSAGE TYPE" Q
"RTN","HLOAPI",32,0)
 .I $L($G(PARMS("ENCODING CHARACTERS"))),$L(PARMS("ENCODING CHARACTERS"))'=4 S ERROR="INVALID ENCODING CHARACTERS" Q
"RTN","HLOAPI",33,0)
 .I $L($G(PARMS("FIELD SEPARATOR"))),$L(PARMS("FIELD SEPARATOR"))'=1 S ERROR="INVALID FIELD SEPARATOR" Q
"RTN","HLOAPI",34,0)
 .I '$L($G(PARMS("FIELD SEPARATOR"))) S PARMS("FIELD SEPARATOR")="|"
"RTN","HLOAPI",35,0)
 .I '$L($G(PARMS("ENCODING CHARACTERS"))) S PARMS("ENCODING CHARACTERS")="^~\&"
"RTN","HLOAPI",36,0)
 .I $G(PARMS("VERSION"))="" S PARMS("VERSION")="2.4"
"RTN","HLOAPI",37,0)
 .I ($L($G(PARMS("VERSION")))>20) S ERROR="VERSION > 20 CHARACTERS" Q
"RTN","HLOAPI",38,0)
 .F I="MESSAGE TYPE","EVENT","COUNTRY","FIELD SEPARATOR","ENCODING CHARACTERS","VERSION","CONTINUATION POINTER","MESSAGE STRUCTURE","PROCESSING MODE" S HLMSTATE("HDR",I)=$G(PARMS(I))
"RTN","HLOAPI",39,0)
 .S HLMSTATE("BATCH")=0 ;not a batch
"RTN","HLOAPI",40,0)
 .S HLMSTATE("DIRECTION")="OUT"
"RTN","HLOAPI",41,0)
 .S HLMSTATE("IEN")=""
"RTN","HLOAPI",42,0)
 .S HLMSTATE("BODY")="" ;record not yet created
"RTN","HLOAPI",43,0)
 .S HLMSTATE("CURRENT SEGMENT")=0 ;no segments cached
"RTN","HLOAPI",44,0)
 .S HLMSTATE("UNSTORED LINES")=0 ;nothing in cache
"RTN","HLOAPI",45,0)
 .S HLMSTATE("LINE COUNT")=0
"RTN","HLOAPI",46,0)
 .D GETSYS(.HLMSTATE)
"RTN","HLOAPI",47,0)
 .S SUCCESS=1
"RTN","HLOAPI",48,0)
 Q SUCCESS
"RTN","HLOAPI",49,0)
 ;
"RTN","HLOAPI",50,0)
NEWBATCH(PARMS,HLMSTATE,ERROR) ;
"RTN","HLOAPI",51,0)
 ;Starts a new batch message.  
"RTN","HLOAPI",52,0)
 ;Input: 
"RTN","HLOAPI",53,0)
 ;  PARMS( *pass by reference*
"RTN","HLOAPI",54,0)
 ;   "COUNTRY")=3 character country code (optional)
"RTN","HLOAPI",55,0)
 ;   "FIELD SEPARATOR")=field separator (optional, defaults to "|")
"RTN","HLOAPI",56,0)
 ;   "ENCODING CHARACTERS")= 4 HL7 encoding characters (optional,defaults to "^~\&") 
"RTN","HLOAPI",57,0)
 ;   "VERSION")=the HL7 Version ID, for example, "2.4" (optional, defaults to 2.4)
"RTN","HLOAPI",58,0)
 ;Output:
"RTN","HLOAPI",59,0)
 ;  Function - returns 1 on success, 0 on failure
"RTN","HLOAPI",60,0)
 ;  PARMS - left defined when the function returns
"RTN","HLOAPI",61,0)
 ;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",62,0)
 ;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",63,0)
 ;
"RTN","HLOAPI",64,0)
 ;
"RTN","HLOAPI",65,0)
 N DATA,I,SYSTEM,SUCCESS
"RTN","HLOAPI",66,0)
 S SUCCESS=0
"RTN","HLOAPI",67,0)
 K ERROR,HLMSTATE
"RTN","HLOAPI",68,0)
 D
"RTN","HLOAPI",69,0)
 .I $L($G(PARMS("COUNTRY"))),$L(PARMS("COUNTRY"))'=3 S ERROR="INVALID COUNTRY CODE" Q
"RTN","HLOAPI",70,0)
 .I $L($G(PARMS("ENCODING CHARACTERS"))),$L(PARMS("ENCODING CHARACTERS"))'=4 S ERROR="INVALID ENCODING CHARACTERS" Q
"RTN","HLOAPI",71,0)
 .I $L($G(PARMS("FIELD SEPARATOR"))),$L(PARMS("FIELD SEPARATOR"))'=1 S ERROR="INVALID FIELD SEPARATOR" Q
"RTN","HLOAPI",72,0)
 .I '$L($G(PARMS("FIELD SEPARATOR"))) S PARMS("FIELD SEPARATOR")="|"
"RTN","HLOAPI",73,0)
 .I '$L($G(PARMS("ENCODING CHARACTERS"))) S PARMS("ENCODING CHARACTERS")="^~\&"
"RTN","HLOAPI",74,0)
 .I $G(PARMS("VERSION"))="" S PARMS("VERSION")="2.4"
"RTN","HLOAPI",75,0)
 .I ($L(PARMS("VERSION"))>20) S ERROR="VERSION > 20 CHARACTERS" Q
"RTN","HLOAPI",76,0)
 .F I="COUNTRY","FIELD SEPARATOR","ENCODING CHARACTERS","VERSION" S HLMSTATE("HDR",I)=$G(PARMS(I))
"RTN","HLOAPI",77,0)
 .S HLMSTATE("IEN")=""
"RTN","HLOAPI",78,0)
 .S HLMSTATE("BODY")="" ;msg not yet stored
"RTN","HLOAPI",79,0)
 .S HLMSTATE("BATCH")=1
"RTN","HLOAPI",80,0)
 .S HLMSTATE("DIRECTION")="OUT"
"RTN","HLOAPI",81,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0 ;no messages in batch
"RTN","HLOAPI",82,0)
 .S HLMSTATE("CURRENT SEGMENT")=0 ;no segments in cache
"RTN","HLOAPI",83,0)
 .S HLMSTATE("UNSTORED LINES")=0 ;nothing in cache
"RTN","HLOAPI",84,0)
 .S HLMSTATE("LINE COUNT")=0 ;no lines within message stored
"RTN","HLOAPI",85,0)
 .D GETSYS(.HLMSTATE)
"RTN","HLOAPI",86,0)
 .S SUCCESS=1
"RTN","HLOAPI",87,0)
 Q SUCCESS
"RTN","HLOAPI",88,0)
 ;
"RTN","HLOAPI",89,0)
SET(SEG,VALUE,FIELD,COMP,SUBCOMP,REP) ;
"RTN","HLOAPI",90,0)
 ;Sets a value to the array SEG(), used for building segments.
"RTN","HLOAPI",91,0)
 ;Input:
"RTN","HLOAPI",92,0)
 ; SEG - (required, pass by reference) - this is the array where the segment is being built.
"RTN","HLOAPI",93,0)
 ; VALUE - the individual value to be set into the segment
"RTN","HLOAPI",94,0)
 ; FIELD - the sequence # of the field (optional, defaults to 0)
"RTN","HLOAPI",95,0)
 ;     *NOTE: FIELD=0 is used to denote the segment type.
"RTN","HLOAPI",96,0)
 ; COMP - the # of the component (optional, defaults to 1)
"RTN","HLOAPI",97,0)
 ; SUBCOMP - the # of the subcomponent (optional, defaults to 1)
"RTN","HLOAPI",98,0)
 ; REP - the occurrence# (optional, defaults to 1)  For a non-repeating field, the occurrence # need not be provided, because it would be 1.
"RTN","HLOAPI",99,0)
 ;Output: 
"RTN","HLOAPI",100,0)
 ;  SEG array
"RTN","HLOAPI",101,0)
 ;
"RTN","HLOAPI",102,0)
 ;  Example:
"RTN","HLOAPI",103,0)
 ;    D SET(.SEG,"MSA",0) creates an MSA segment 
"RTN","HLOAPI",104,0)
 ;    D SET(.SEG,"AE",1) will place the value into the array position
"RTN","HLOAPI",105,0)
 ;    reserved for the 1st field,1st occurence,1st comp,1st subcomp
"RTN","HLOAPI",106,0)
 ;
"RTN","HLOAPI",107,0)
 ;Implementation Note - This format is used for the segment array built by calls to SET: SEGMENT(<SEQ #>,<occurrence #>,<component #>,<subcomponent #>)=<subcomponent value> 
"RTN","HLOAPI",108,0)
 ;
"RTN","HLOAPI",109,0)
 S:'$G(FIELD) FIELD=0
"RTN","HLOAPI",110,0)
 S:'$G(COMP) COMP=1
"RTN","HLOAPI",111,0)
 S:'$G(SUBCOMP) SUBCOMP=1
"RTN","HLOAPI",112,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI",113,0)
 S SEG(FIELD,REP,COMP,SUBCOMP)=$G(VALUE)
"RTN","HLOAPI",114,0)
 Q
"RTN","HLOAPI",115,0)
 ;
"RTN","HLOAPI",116,0)
ADDSEG(HLMSTATE,SEG,ERROR) ;Adds a segment to the message.
"RTN","HLOAPI",117,0)
 ;Input:
"RTN","HLOAPI",118,0)
 ;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",119,0)
 ;  SEG() - (pass by reference, required) Contains the data.  It must be built by calls to SET prior to calling $$ADDSEG.
"RTN","HLOAPI",120,0)
 ;
"RTN","HLOAPI",121,0)
 ;Note#1:  The message control segments, including the MSH and BHS segments, are added automatically.
"RTN","HLOAPI",122,0)
 ;Note#2:  The 0th field must be a 3 character segment type
"RTN","HLOAPI",123,0)
 ;Note#3: ***SEG is killed upon successfully adding the segment***
"RTN","HLOAPI",124,0)
 ;
"RTN","HLOAPI",125,0)
 ;Output:
"RTN","HLOAPI",126,0)
 ;   HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.
"RTN","HLOAPI",127,0)
 ;  FUNCTION - returns 1 on success, 0 on failure
"RTN","HLOAPI",128,0)
 ;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",129,0)
 ;
"RTN","HLOAPI",130,0)
 ;
"RTN","HLOAPI",131,0)
 K ERROR
"RTN","HLOAPI",132,0)
 N TOARY,TYPE
"RTN","HLOAPI",133,0)
 ;
"RTN","HLOAPI",134,0)
 S TYPE=$G(SEG(0,1,1,1)) ;segment type
"RTN","HLOAPI",135,0)
 ;
"RTN","HLOAPI",136,0)
 ;if a 'generic' app ack MSA was built, add it as the first segment before this one
"RTN","HLOAPI",137,0)
 I $D(HLMSTATE("MSA")) D
"RTN","HLOAPI",138,0)
 .I TYPE'="MSA" S TOARY(1)=HLMSTATE("MSA") D ADDSEG^HLOMSG(.HLMSTATE,.TOARY) K TOARY
"RTN","HLOAPI",139,0)
 .K HLMSTATE("MSA")
"RTN","HLOAPI",140,0)
 ;
"RTN","HLOAPI",141,0)
 I ($L(TYPE)'=3) S ERROR="INVALID SEGMENT TYPE" Q 0
"RTN","HLOAPI",142,0)
 I (TYPE="MSH")!(TYPE="BHS")!(TYPE="BTS")!(TYPE="FHS")!(TYPE="FTS") S ERROR="INVALID SEGMENT TYPE" Q 0
"RTN","HLOAPI",143,0)
 I HLMSTATE("BATCH"),'HLMSTATE("BATCH","CURRENT MESSAGE") S ERROR="NO MESSAGES IN BATCH, SO SEGMENTS NOT ALLOWED" Q 0
"RTN","HLOAPI",144,0)
 I $$BUILDSEG^HLOPBLD(.HLMSTATE,.SEG,.TOARY,.ERROR) D ADDSEG^HLOMSG(.HLMSTATE,.TOARY) K SEG Q 1
"RTN","HLOAPI",145,0)
 Q 0
"RTN","HLOAPI",146,0)
 ;
"RTN","HLOAPI",147,0)
ADDMSG(HLMSTATE,PARMS,ERROR) ;
"RTN","HLOAPI",148,0)
 ;Begins a new message in the batch.
"RTN","HLOAPI",149,0)
 ;Input:
"RTN","HLOAPI",150,0)
 ;  HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI",151,0)
 ;  PARMS( *pass by reference*
"RTN","HLOAPI",152,0)
 ;    "EVENT")=3 character event type (required)
"RTN","HLOAPI",153,0)
 ;    "MESSAGE TYPE")=3 character message type (required)
"RTN","HLOAPI",154,0)
 ;
"RTN","HLOAPI",155,0)
 ;Output:
"RTN","HLOAPI",156,0)
 ;   FUNCTION - returns 1 on success, 0 on failure
"RTN","HLOAPI",157,0)
 ;   HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.
"RTN","HLOAPI",158,0)
 ;   PARMS - left defined when this function returns
"RTN","HLOAPI",159,0)
 ;   ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOAPI",160,0)
 ;
"RTN","HLOAPI",161,0)
 N I
"RTN","HLOAPI",162,0)
 K ERROR
"RTN","HLOAPI",163,0)
 ;if a 'generic' app ack MSA was built, add it as the first segment before this one
"RTN","HLOAPI",164,0)
 I $D(HLMSTATE("MSA")) D
"RTN","HLOAPI",165,0)
 .I TYPE'="MSA" N TOARY M TOARY=HLMSTATE("MSA") D ADDSEG^HLOMSG(.HLMSTATE,.TOARY) K TOARY
"RTN","HLOAPI",166,0)
 .K HLMSTATE("MSA")
"RTN","HLOAPI",167,0)
 I $L($G(PARMS("EVENT")))'=3 S ERROR="EVENT TYPE INVALID" Q 0
"RTN","HLOAPI",168,0)
 I $L($G(PARMS("MESSAGE TYPE")))'=3 S ERROR="MESSAGE TYPE INVALID" Q 0
"RTN","HLOAPI",169,0)
 D ADDMSG^HLOMSG(.HLMSTATE,.PARMS)
"RTN","HLOAPI",170,0)
 Q 1
"RTN","HLOAPI",171,0)
 ;
"RTN","HLOAPI",172,0)
GETSYS(HLMSTATE) ;
"RTN","HLOAPI",173,0)
 N SYS,SUB
"RTN","HLOAPI",174,0)
 D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOAPI",175,0)
 F SUB="DOMAIN","STATION","PROCESSING ID","MAXSTRING","ERROR PURGE","NORMAL PURGE","PORT" S HLMSTATE("SYSTEM",SUB)=SYS(SUB)
"RTN","HLOAPI",176,0)
 S HLMSTATE("SYSTEM","BUFFER")=SYS("USER BUFFER")
"RTN","HLOAPI",177,0)
 Q
"RTN","HLOAPI",178,0)
 ;
"RTN","HLOAPI",179,0)
MOVEMSG(HLMSTATE,ARY) ;
"RTN","HLOAPI",180,0)
 ;If a message was built in the 'old' way, and resides in an array, this  routine will move it into file 777 (HL7 Message Body)
"RTN","HLOAPI",181,0)
 ;Input:
"RTN","HLOAPI",182,0)
 ;  HLMSTATE (pass by reference) the array created by calling $$NEWMSG or $$NEWBATCH
"RTN","HLOAPI",183,0)
 ;  ARY - is the name of the array, local or global, where the message was built, used to reference the array by indirection.
"RTN","HLOAPI",184,0)
 ;
"RTN","HLOAPI",185,0)
 N I S I=0
"RTN","HLOAPI",186,0)
 F  S I=$O(@ARY@(I)) Q:'I  D
"RTN","HLOAPI",187,0)
 .N SEG,J,J2
"RTN","HLOAPI",188,0)
 .S J=0,J2=1
"RTN","HLOAPI",189,0)
 .S SEG(J2)=@ARY@(I)
"RTN","HLOAPI",190,0)
 .F  S J=$O(@ARY@(I,J)) Q:'J  S J2=J2+1,SEG(J2)=@ARY@(I,J)
"RTN","HLOAPI",191,0)
 .I 'HLMSTATE("BATCH") D
"RTN","HLOAPI",192,0)
 ..D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOAPI",193,0)
 .E  D
"RTN","HLOAPI",194,0)
 ..I $E(SEG(1),1,3)="MSH" D
"RTN","HLOAPI",195,0)
 ...D SPLITHDR^HLOSRVR1(.SEG)
"RTN","HLOAPI",196,0)
 ...D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOAPI",197,0)
 ..E  D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOAPI",198,0)
 Q
"RTN","HLOAPI1")
0^2^B47488160
"RTN","HLOAPI1",1,0)
HLOAPI1 ;ALB/CJM-HL7 - Developer API's for sending & receiving messages(continued) ;02/04/2004
"RTN","HLOAPI1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOAPI1",3,0)
 ;
"RTN","HLOAPI1",4,0)
SENDONE(HLMSTATE,PARMS,WHOTO,ERROR) ;
"RTN","HLOAPI1",5,0)
 ;Sends the message to a single receiving application.
"RTN","HLOAPI1",6,0)
 ;
"RTN","HLOAPI1",7,0)
 ;Input:
"RTN","HLOAPI1",8,0)
 ;HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it
"RTN","HLOAPI1",9,0)
 ;PARMS( *pass by reference*
"RTN","HLOAPI1",10,0)
 ;  "APP ACK RESPONSE")=<tag^routine> to call when the app ack is received (optional)
"RTN","HLOAPI1",11,0)
 ;    (NOTE: For batch messages, HLO best supports returning application
"RTN","HLOAPI1",12,0)
 ;     acknowledgments via a batch response.  However, non-VistA systems
"RTN","HLOAPI1",13,0)
 ;     may return individual messages as application acknowledgments to
"RTN","HLOAPI1",14,0)
 ;     messages within the original batch message, so for applications
"RTN","HLOAPI1",15,0)
 ;     sending batch messages might best code the "APP ACK RESPONSE"
"RTN","HLOAPI1",16,0)
 ;     routine to first check whether the response message is a batch.
"RTN","HLOAPI1",17,0)
 ; 
"RTN","HLOAPI1",18,0)
 ;  "ACCEPT ACK RESPONSE")=<tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI1",19,0)
 ;  "ACCEPT ACK TYPE") = <AL,NE> (optional, defaults to AL)
"RTN","HLOAPI1",20,0)
 ;  "APP ACK TYPE") = <AL,NE> (optional, defaults to NE)
"RTN","HLOAPI1",21,0)
 ;  "FAILURE RESPONSE" - <tag>^<routine> (optional) The sending application routine to execute when the transmission of the message fails, i.e., the message can not be sent or no commit ack is received.
"RTN","HLOAPI1",22,0)
 ;  "QUEUE" - (optional) An application can name its own private queue - just a string up to 20 characters, it should be namespaced.
"RTN","HLOAPI1",23,0)
 ;  "SECURITY")=security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI1",24,0)
 ;  "SENDING APPLICATION")=name of sending app (required, 60 maximum length)
"RTN","HLOAPI1",25,0)
 ;
"RTN","HLOAPI1",26,0)
 ;  WHOTO (required,pass by reference) an array specifying a single recipient. These subscripts are allowed:
"RTN","HLOAPI1",27,0)
 ;
"RTN","HLOAPI1",28,0)
 ;    "RECEIVING APPLICATION" - (string, 60 char max, required)
"RTN","HLOAPI1",29,0)
 ;
"RTN","HLOAPI1",30,0)
 ;  EXACTLY ONE of these parameters must be provided to identify the Receiving Facility:
"RTN","HLOAPI1",31,0)
 ;
"RTN","HLOAPI1",32,0)
 ;   "FACILITY LINK IEN" - ien of the logical link 
"RTN","HLOAPI1",33,0)
 ;   "FACILITY LINK NAME" - name of the logical link 
"RTN","HLOAPI1",34,0)
 ;   "INSTITUTION IEN" - ptr to the INSTITUTION file
"RTN","HLOAPI1",35,0)
 ;   "STATION NUMBER" -  station # with suffix
"RTN","HLOAPI1",36,0)
 ;
"RTN","HLOAPI1",37,0)
 ;  EXACTLY ONE of these MAY be provided - optionally - to identify the interface engine to route the message through:
"RTN","HLOAPI1",38,0)
 ;
"RTN","HLOAPI1",39,0)
 ;   "IE LINK IEN" -  ptr to a logical link for the interface engine 
"RTN","HLOAPI1",40,0)
 ;   "IE LINK NAME" - name of the logical link for the interface engine
"RTN","HLOAPI1",41,0)
 ;
"RTN","HLOAPI1",42,0)
 ;Output:
"RTN","HLOAPI1",43,0)
 ;  Function returns the ien of the message in file 778 on success, 0 on failure
"RTN","HLOAPI1",44,0)
 ;   HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI1",45,0)
 ;   ERROR (pass by reference, optional) - on failure, will contain an error message
"RTN","HLOAPI1",46,0)
 ;   PARMS - left undefined when the function returns
"RTN","HLOAPI1",47,0)
 ;   WHOTO - left undefined when the function returns
"RTN","HLOAPI1",48,0)
 ;
"RTN","HLOAPI1",49,0)
 ;
"RTN","HLOAPI1",50,0)
 N SUCCESS S SUCCESS=0
"RTN","HLOAPI1",51,0)
 D
"RTN","HLOAPI1",52,0)
 .I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) S ERROR="MESSAGE NOT YET CREATED" Q
"RTN","HLOAPI1",53,0)
 .;
"RTN","HLOAPI1",54,0)
 .I $$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERROR),$$CHKWHO(.HLMSTATE,.WHOTO,.ERROR) D
"RTN","HLOAPI1",55,0)
 ..I $$SEND(.HLMSTATE,.ERROR) S SUCCESS=1
"RTN","HLOAPI1",56,0)
 .E  D DONTSEND(.HLMSTATE,$G(ERROR))
"RTN","HLOAPI1",57,0)
 K PARMS,WHOTO
"RTN","HLOAPI1",58,0)
 Q $S(SUCCESS:HLMSTATE("IEN"),1:0)
"RTN","HLOAPI1",59,0)
 ;
"RTN","HLOAPI1",60,0)
SENDMANY(HLMSTATE,PARMS,WHOTO) ;
"RTN","HLOAPI1",61,0)
 ;Sends the message to a list of receiving applications
"RTN","HLOAPI1",62,0)
 ;
"RTN","HLOAPI1",63,0)
 ;Input: Same as for $$SENDONE, except WHOTO is a list.
"RTN","HLOAPI1",64,0)
 ;  WHOTO (pass by reference)
"RTN","HLOAPI1",65,0)
 ;    Specifies a list of recipients.  Each recipient should be on the
"RTN","HLOAPI1",66,0)
 ;    list as WHOTO(i), where i=1,2,3,4, etc. for as many messages as to
"RTN","HLOAPI1",67,0)
 ;    send.  At each subscript WHOTO(i), the same lower level subscripts
"RTN","HLOAPI1",68,0)
 ;    may be defined as in the $$SENDONE API.  For example:
"RTN","HLOAPI1",69,0)
 ;
"RTN","HLOAPI1",70,0)
 ;      WHOTO(1,"LINK NAME")="VAALB"
"RTN","HLOAPI1",71,0)
 ;      WHOTO(1,"RECEIVING APPLICATION")="MPI"
"RTN","HLOAPI1",72,0)
 ;      WHOTO(2,"STATION NUMBER")=500
"RTN","HLOAPI1",73,0)
 ;      WHOTO(2,"RECEIVING APPLICATION")="MPI"
"RTN","HLOAPI1",74,0)
 ;
"RTN","HLOAPI1",75,0)
 ;
"RTN","HLOAPI1",76,0)
 ;Output:
"RTN","HLOAPI1",77,0)
 ;  Function returns 1 if a message is queued to be sent to each intended recipient, 0 otherwise
"RTN","HLOAPI1",78,0)
 ;  PARMS - left undefined when the function returns
"RTN","HLOAPI1",79,0)
 ;  WHOTO (pass by reference) returns the status of each message to be sent in the format:
"RTN","HLOAPI1",80,0)
 ;    (<i>,"QUEUED")= <1 if queued to be sent, 0 otherwise)
"RTN","HLOAPI1",81,0)
 ;   (<i>,"IEN")=<ien, file 778>
"RTN","HLOAPI1",82,0)
 ;   (<i>,"ERROR")= error message if an error was encountered (status=0), not defined otherwise
"RTN","HLOAPI1",83,0)
 ;
"RTN","HLOAPI1",84,0)
 ;
"RTN","HLOAPI1",85,0)
 N ERROR,RETURN,WHO,STATE,I
"RTN","HLOAPI1",86,0)
 S RETURN=1
"RTN","HLOAPI1",87,0)
 I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) D  K PARMS Q 0
"RTN","HLOAPI1",88,0)
 .S ERROR="MESSAGE NOT YET CREATED"
"RTN","HLOAPI1",89,0)
 .S I=0 F  S I=$O(WHOTO(I)) Q:'I  S WHOTO(I,"QUEUED")=0,WHOTO(I,"IEN")=0,WHOTO(I,"ERROR")=ERROR
"RTN","HLOAPI1",90,0)
 ;
"RTN","HLOAPI1",91,0)
 I '$$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERROR) D  K PARMS Q 0
"RTN","HLOAPI1",92,0)
 .S I=0 F  S I=$O(WHOTO(I)) Q:'I  D
"RTN","HLOAPI1",93,0)
 ..K WHO M WHO=WHOTO(I)
"RTN","HLOAPI1",94,0)
 ..K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",95,0)
 ..S WHOTO(I,"QUEUED")=0
"RTN","HLOAPI1",96,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",97,0)
 ..S WHOTO(I,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",98,0)
 ..S WHOTO(I,"ERROR")=ERROR
"RTN","HLOAPI1",99,0)
 ;
"RTN","HLOAPI1",100,0)
 S I=0 F  S I=$O(WHOTO(I)) Q:'I  D
"RTN","HLOAPI1",101,0)
 .K WHO M WHO=WHOTO(I)
"RTN","HLOAPI1",102,0)
 .K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",103,0)
 .S ERROR=""
"RTN","HLOAPI1",104,0)
 .I $$CHKWHO(.STATE,.WHO,.ERROR) D
"RTN","HLOAPI1",105,0)
 ..I $$SEND(.STATE,.ERROR) D
"RTN","HLOAPI1",106,0)
 ...S WHOTO(I,"QUEUED")=1
"RTN","HLOAPI1",107,0)
 ...S WHOTO(I,"IEN")=STATE("IEN")
"RTN","HLOAPI1",108,0)
 ...S WHOTO(I,"ERROR")=""
"RTN","HLOAPI1",109,0)
 ..E  D
"RTN","HLOAPI1",110,0)
 ...S WHOTO(I,"QUEUED")=0
"RTN","HLOAPI1",111,0)
 ...S WHOTO(I,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",112,0)
 ...S WHOTO(I,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",113,0)
 ...S RETURN=0
"RTN","HLOAPI1",114,0)
 .E  D  ;who not adequately determined
"RTN","HLOAPI1",115,0)
 ..S WHOTO(I,"QUEUED")=0,RETURN=0
"RTN","HLOAPI1",116,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",117,0)
 ..S WHOTO(I,"IEN")=$G(STATE("IEN")),WHOTO(I,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",118,0)
 K PARMS
"RTN","HLOAPI1",119,0)
 Q RETURN
"RTN","HLOAPI1",120,0)
 ;
"RTN","HLOAPI1",121,0)
SENDSUB(HLMSTATE,PARMS,MESSAGES) ;
"RTN","HLOAPI1",122,0)
 ;Sends the message to a list of receiving applications based on the HL7 Subscription Registry
"RTN","HLOAPI1",123,0)
 ;
"RTN","HLOAPI1",124,0)
 ;Input:
"RTN","HLOAPI1",125,0)
 ;  HLMSTATE (pass by reference, required) same as $$SENDMANY
"RTN","HLOAPI1",126,0)
 ;  PARMS (pass by reference, required) same as $$SENDMANY, with one additional subscript:
"RTN","HLOAPI1",127,0)
 ;    "SUBSCRIPTION IEN" - the ien of an entry in the HL7 Subscription Registry, defining the intended recipients of this message
"RTN","HLOAPI1",128,0)
 ;
"RTN","HLOAPI1",129,0)
 ;Output:
"RTN","HLOAPI1",130,0)
 ;  Function returns 1 if a message is queued to be sent to each intended recipient, 0 otherwise
"RTN","HLOAPI1",131,0)
 ;  PARMS - left undefined when the function returns
"RTN","HLOAPI1",132,0)
 ;  MESSAGES (pass by reference) returns the status of each message to be sent in this format, where subien is the ien of the recipient in the RECIPEINTS subfile of the HL7 Subscription Registry
"RTN","HLOAPI1",133,0)
 ;   (<subien>,"QUEUED")= <1 if queued to be sent, 0 otherwise)
"RTN","HLOAPI1",134,0)
 ;   (<subien>,"IEN")=<ien, file 778>
"RTN","HLOAPI1",135,0)
 ;   (<subien>,"ERROR")= error message if an error was encountered (status=0), not defined otherwise
"RTN","HLOAPI1",136,0)
 ;
"RTN","HLOAPI1",137,0)
 ;
"RTN","HLOAPI1",138,0)
 K MESSAGES
"RTN","HLOAPI1",139,0)
 N ERROR,RETURN,STATE,SUBIEN,WHO
"RTN","HLOAPI1",140,0)
 ;
"RTN","HLOAPI1",141,0)
 S RETURN=1
"RTN","HLOAPI1",142,0)
 ;
"RTN","HLOAPI1",143,0)
 ;
"RTN","HLOAPI1",144,0)
 I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) S ERROR="MESSAGE NOT YET CREATED" K PARMS Q 0
"RTN","HLOAPI1",145,0)
 I '$G(PARMS("SUBSCRIPTION IEN")) S ERROR="SUBSCRIPTION REGISTRY IEN NOT PROVIDED" K PARMS Q 0
"RTN","HLOAPI1",146,0)
 ;
"RTN","HLOAPI1",147,0)
 I '$$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERROR) D  K PARMS Q 0
"RTN","HLOAPI1",148,0)
 .S SUBIEN=0 F  S SUBIEN=$$NEXT^HLOASUB(PARMS("SUBSCRIPTION IEN"),.WHO) Q:'SUBIEN  D
"RTN","HLOAPI1",149,0)
 ..N SARY,HARY
"RTN","HLOAPI1",150,0)
 ..S HARY="STATE(""HDR"")"
"RTN","HLOAPI1",151,0)
 ..S SARY="STATE(""STATUS"")"
"RTN","HLOAPI1",152,0)
 ..K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",153,0)
 ..;move parameters into HLMSTATE
"RTN","HLOAPI1",154,0)
 ..S @SARY@("LINK IEN")=WHO("LINK IEN")
"RTN","HLOAPI1",155,0)
 ..S @SARY@("LINK NAME")=WHO("LINK NAME")
"RTN","HLOAPI1",156,0)
 ..S @HARY@("RECEIVING APPLICATION")=WHO("RECEIVING APPLICATION")
"RTN","HLOAPI1",157,0)
 ..M @HARY@("RECEIVING FACILITY")=WHO("RECEIVING FACILITY")
"RTN","HLOAPI1",158,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",159,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=0
"RTN","HLOAPI1",160,0)
 ..S MESSAGES(SUBIEN,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",161,0)
 ..S MESSAGES(SUBIEN,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",162,0)
 ;
"RTN","HLOAPI1",163,0)
 F  S SUBIEN=$$NEXT^HLOASUB(PARMS("SUBSCRIPTION IEN"),.WHO) Q:'SUBIEN  D
"RTN","HLOAPI1",164,0)
 .N SARY,HARY
"RTN","HLOAPI1",165,0)
 .S HARY="STATE(""HDR"")"
"RTN","HLOAPI1",166,0)
 .S SARY="STATE(""STATUS"")"
"RTN","HLOAPI1",167,0)
 .K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",168,0)
 .;move parameters into HLMSTATE
"RTN","HLOAPI1",169,0)
 .S @SARY@("LINK IEN")=WHO("LINK IEN")
"RTN","HLOAPI1",170,0)
 .S @SARY@("LINK NAME")=WHO("LINK NAME")
"RTN","HLOAPI1",171,0)
 .S @HARY@("RECEIVING APPLICATION")=WHO("RECEIVING APPLICATION")
"RTN","HLOAPI1",172,0)
 .M @HARY@("RECEIVING FACILITY")=WHO("RECEIVING FACILITY")
"RTN","HLOAPI1",173,0)
 .S ERROR=""
"RTN","HLOAPI1",174,0)
 .I $$SEND(.STATE,.ERROR) D
"RTN","HLOAPI1",175,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=1
"RTN","HLOAPI1",176,0)
 .E  D
"RTN","HLOAPI1",177,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=0,RETURN=0
"RTN","HLOAPI1",178,0)
 .S MESSAGES(SUBIEN,"IEN")=$G(STATE("IEN")),MESSAGES(SUBIEN,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",179,0)
 K PARMS
"RTN","HLOAPI1",180,0)
 Q RETURN
"RTN","HLOAPI1",181,0)
 ;
"RTN","HLOAPI1",182,0)
SEND(HLMSTATE,ERROR) ;
"RTN","HLOAPI1",183,0)
 ;
"RTN","HLOAPI1",184,0)
 K ERROR
"RTN","HLOAPI1",185,0)
 I HLMSTATE("UNSTORED LINES"),'$$SAVEMSG^HLOF777(.HLMSTATE) S ERROR="$$SAVE^HLOF777 FAILED!" Q 0
"RTN","HLOAPI1",186,0)
 ;
"RTN","HLOAPI1",187,0)
 I '$$SAVEMSG^HLOF778(.HLMSTATE) S ERROR="$$SAVE^HLOF778 FAILED!" Q 0
"RTN","HLOAPI1",188,0)
 D OUTQUE^HLOQUE(HLMSTATE("STATUS","LINK NAME"),$G(HLMSTATE("STATUS","PORT")),HLMSTATE("STATUS","QUEUE"),HLMSTATE("IEN"))
"RTN","HLOAPI1",189,0)
 Q HLMSTATE("IEN")
"RTN","HLOAPI1",190,0)
 ;
"RTN","HLOAPI1",191,0)
DONTSEND(HLMSTATE,ERROR) ;
"RTN","HLOAPI1",192,0)
 ;This procedure does NOT send a message.  Rather, it creates an entry in file 778 with the
"RTN","HLOAPI1",193,0)
 ;of "SE".  
"RTN","HLOAPI1",194,0)
 ;Input:
"RTN","HLOAPI1",195,0)
 ;       HLMSTATE - pass-by-reference
"RTN","HLOAPI1",196,0)
 ;       ERROR (optional, pass-by-value) error text to store with the message
"RTN","HLOAPI1",197,0)
 ;Output: none
"RTN","HLOAPI1",198,0)
 ;
"RTN","HLOAPI1",199,0)
 I HLMSTATE("UNSTORED LINES"),'$$SAVEMSG^HLOF777(.HLMSTATE) ; just continue
"RTN","HLOAPI1",200,0)
 ;
"RTN","HLOAPI1",201,0)
 S HLMSTATE("STATUS")="SE"
"RTN","HLOAPI1",202,0)
 S HLSTATE("STATUS","PURGE")=$$FMADD^XLFDT(HLMSTATE("DT/TM CREATED"),HLMSTATE("SYSTEM","ERROR PURGE"))
"RTN","HLOAPI1",203,0)
 S HLMSTATE("STATUS","ERROR TEXT")=$G(ERROR)
"RTN","HLOAPI1",204,0)
 I '$$SAVEMSG^HLOF778(.HLMSTATE) ;already reported an error to the app
"RTN","HLOAPI1",205,0)
 Q
"RTN","HLOAPI1",206,0)
 ;
"RTN","HLOAPI1",207,0)
CHKWHO(HLMSTATE,WHOTO,ERROR) ;
"RTN","HLOAPI1",208,0)
 N RETURN,I
"RTN","HLOAPI1",209,0)
 S ERROR=""
"RTN","HLOAPI1",210,0)
 S RETURN=1
"RTN","HLOAPI1",211,0)
 I '$$CHECKWHO^HLOASUB1(.WHOTO,.RETURN,.ERROR) S RETURN=0
"RTN","HLOAPI1",212,0)
 ;
"RTN","HLOAPI1",213,0)
 ;move parameters into HLMSTATE
"RTN","HLOAPI1",214,0)
 S HLMSTATE("STATUS","LINK IEN")=$G(RETURN("LINK IEN"))
"RTN","HLOAPI1",215,0)
 S HLMSTATE("STATUS","LINK NAME")=$G(RETURN("LINK NAME"))
"RTN","HLOAPI1",216,0)
 S HLMSTATE("STATUS","PORT")=$P($G(RETURN("RECEIVING FACILITY",2)),":",2)
"RTN","HLOAPI1",217,0)
 S HLMSTATE("HDR","RECEIVING APPLICATION")=$G(RETURN("RECEIVING APPLICATION"))
"RTN","HLOAPI1",218,0)
 F I=1:1:3 S HLMSTATE("HDR","RECEIVING FACILITY",I)=$G(RETURN("RECEIVING FACILITY",I))
"RTN","HLOAPI1",219,0)
 Q RETURN
"RTN","HLOAPI2")
0^3^B27708015
"RTN","HLOAPI2",1,0)
HLOAPI2 ;ALB/CJM-HL7 - Developer API's for sending application acks ;02/04/2004
"RTN","HLOAPI2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOAPI2",3,0)
 ;
"RTN","HLOAPI2",4,0)
ACK(HLMSTATE,PARMS,ACK,ERROR) ;Default behavior is to return a general
"RTN","HLOAPI2",5,0)
 ;application ack. The application may optionally specify the message
"RTN","HLOAPI2",6,0)
 ;type and event or call $$ADDSEG^HLOAPI to add segments.
"RTN","HLOAPI2",7,0)
 ;A generic MSA segment (components 1-3) is added automatically IF the
"RTN","HLOAPI2",8,0)
 ;application doesn't call $$ADDSEG^HLOAPI to add an MSA segment as the
"RTN","HLOAPI2",9,0)
 ;FIRST segment following the header.
"RTN","HLOAPI2",10,0)
 ;$$SENDACK must be called when the ack is completed. The return
"RTN","HLOAPI2",11,0)
 ;destination is determined automatically from the original message
"RTN","HLOAPI2",12,0)
 ;
"RTN","HLOAPI2",13,0)
 ;This API should NOT be called for batch messages, use $$BATCHACK instead.
"RTN","HLOAPI2",14,0)
 ;Input:
"RTN","HLOAPI2",15,0)
 ;  HLMSTATE (pass by reference, required) the array obtained by calling $$STARTMSG^HLOPRS when parsing the original message 
"RTN","HLOAPI2",16,0)
 ;  PARMS (pass by reference) These subscripts may be defined:
"RTN","HLOAPI2",17,0)
 ;    "ACK CODE" (required) MSA1[ {AA,AE,AR}
"RTN","HLOAPI2",18,0)
 ;    "ERROR MESSAGE" - MSA3, should be used only if AE or AR
"RTN","HLOAPI2",19,0)
 ;    "ACCEPT ACK RESPONSE" - the <tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI2",20,0)
 ;    "ACCEPT ACK TYPE" - {AL,NE} (optional, defaults to AL)
"RTN","HLOAPI2",21,0)
 ;    "CONTINUATION POINTER" (optional)indicates a fragmented message
"RTN","HLOAPI2",22,0)
 ;    "COUNTRY" - the 3 character country code (optional)
"RTN","HLOAPI2",23,0)
 ;    "EVENT" - the 3 character event type (optional, defaults to the event code of the original message)
"RTN","HLOAPI2",24,0)
 ;     "ENCODING CHARACTERS" - the four HL7 encoding characters (optional,defaults to "^~\&"
"RTN","HLOAPI2",25,0)
 ;    "FAILURE RESPONSE" (optional) the <tag>^<routine> that the sending application routine should execute if the transmission of the message fails, i.e., the message can not be sent or a requested commit ack is not received.
"RTN","HLOAPI2",26,0)
 ;    "FIELD SEPARATOR" - field separator (optional, defaults to "|")
"RTN","HLOAPI2",27,0)
 ;    "MESSAGE TYPE" - if not defined, ACK is used
"RTN","HLOAPI2",28,0)
 ;    "MESSAGE STRUCTURE" (optional)
"RTN","HLOAPI2",29,0)
 ;    "QUEUE" - (optional) An application can name its own private queue (a string under 20 characters,namespaced). The default is the name of the queue of the original message
"RTN","HLOAPI2",30,0)
 ;    "SECURITY" (optional) security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI2",31,0)
 ;    "VERSION" - the HL7 Version ID (optional, defaults to 2.4)
"RTN","HLOAPI2",32,0)
 ;Output:
"RTN","HLOAPI2",33,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI2",34,0)
 ;  PARMS - left undefined when the function returns
"RTN","HLOAPI2",35,0)
 ;  ACK (pass by reference, required) the acknowledgment message being built.
"RTN","HLOAPI2",36,0)
 ;  ERROR (pass by reference) error msg
"RTN","HLOAPI2",37,0)
 N I,SEG,TOLINK,SUCCESS
"RTN","HLOAPI2",38,0)
 S SUCCESS=0
"RTN","HLOAPI2",39,0)
 ;
"RTN","HLOAPI2",40,0)
 D
"RTN","HLOAPI2",41,0)
 .N PORT
"RTN","HLOAPI2",42,0)
 .I $G(PARMS("ACK CODE"))'="AA",$G(PARMS("ACK CODE"))'="AE",$G(PARMS("ACK CODE"))'="AR" S ERROR="INVALID ACK CODE" Q
"RTN","HLOAPI2",43,0)
 .;
"RTN","HLOAPI2",44,0)
 .I '$G(HLMSTATE("IEN")) S ERROR="ORIGINAL MESSAGE TO ACKNOWLEDGE IS NOT IDENTIFIED" Q
"RTN","HLOAPI2",45,0)
 .I $G(HLMSTATE("BATCH")) S ERROR="BATCH ACKNOWLEDGMENTS MUST USE $$BATCHACK^HLOAPI3" Q
"RTN","HLOAPI2",46,0)
 .;
"RTN","HLOAPI2",47,0)
 .I $G(HLMSTATE("HDR","MESSAGE CONTROL ID"))="" S ERROR="MESSAGE CONTROL ID MUST EXIST TO RETURN AN APPLICATION ACK" Q
"RTN","HLOAPI2",48,0)
 .;
"RTN","HLOAPI2",49,0)
 .;if the return link can not be determined, the HL Logical Link file has a problem that must be fixed at the site
"RTN","HLOAPI2",50,0)
 .S TOLINK=$$ACKLINK(.HLMSTATE)
"RTN","HLOAPI2",51,0)
 .I TOLINK="" S ERROR="TRANSMISSION LINK FOR APPLICATION ACK CANNOT BE DETERMINED" Q
"RTN","HLOAPI2",52,0)
 .S PORT=$P(HLMSTATE("HDR","SENDING FACILITY",2),":",2)
"RTN","HLOAPI2",53,0)
 .I 'PORT S PORT=$$PORT2^HLOTLNK(TOLINK)
"RTN","HLOAPI2",54,0)
 .;
"RTN","HLOAPI2",55,0)
 .S PARMS("MESSAGE TYPE")=$G(PARMS("MESSAGE TYPE"),"ACK")
"RTN","HLOAPI2",56,0)
 .S:PARMS("MESSAGE TYPE")="ACK" PARMS("MESSAGE STRUCTURE")="ACK"
"RTN","HLOAPI2",57,0)
 .S PARMS("EVENT")=$G(PARMS("EVENT"),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOAPI2",58,0)
 .I $$NEWMSG^HLOAPI(.PARMS,.ACK)  ;can't fail!
"RTN","HLOAPI2",59,0)
 .S ACK("STATUS","QUEUE")=$G(PARMS("QUEUE"),$G(HLMSTATE("STATUS","QUEUE")))
"RTN","HLOAPI2",60,0)
 .S ACK("STATUS","PORT")=PORT
"RTN","HLOAPI2",61,0)
 .S ACK("HDR","SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI2",62,0)
 .S ACK("HDR","SENDING APPLICATION")=$G(HLMSTATE("HDR","RECEIVING APPLICATION"))
"RTN","HLOAPI2",63,0)
 .S ACK("HDR","RECEIVING APPLICATION")=$G(HLMSTATE("HDR","SENDING APPLICATION"))
"RTN","HLOAPI2",64,0)
 .F I=1:1:3 S ACK("HDR","RECEIVING FACILITY",I)=$G(HLMSTATE("HDR","SENDING FACILITY",I))
"RTN","HLOAPI2",65,0)
 .S ACK("HDR","APP ACK TYPE")="NE"
"RTN","HLOAPI2",66,0)
 .S ACK("HDR","ACCEPT ACK TYPE")=$G(PARMS("ACCEPT ACK TYPE"),"AL")
"RTN","HLOAPI2",67,0)
 .S ACK("ACK TO","STATUS")=$S(PARMS("ACK CODE")="AA":"SU",1:"AE")
"RTN","HLOAPI2",68,0)
 .S ACK("ACK TO")=$G(HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOAPI2",69,0)
 .S ACK("ACK TO","IEN")=HLMSTATE("IEN")
"RTN","HLOAPI2",70,0)
 .S ACK("STATUS","LINK NAME")=TOLINK
"RTN","HLOAPI2",71,0)
 .S ACK("LINE COUNT")=0
"RTN","HLOAPI2",72,0)
 .S ACK("MSA")="MSA|"_PARMS("ACK CODE")_"|"_$G(HLMSTATE("HDR","MESSAGE CONTROL ID"))_"|"_$G(PARMS("ERROR MESSAGE"))
"RTN","HLOAPI2",73,0)
 .S SUCCESS=1
"RTN","HLOAPI2",74,0)
 K PARMS
"RTN","HLOAPI2",75,0)
 Q SUCCESS
"RTN","HLOAPI2",76,0)
 ;
"RTN","HLOAPI2",77,0)
SENDACK(ACK,ERROR) ;This is used to signal that an application acknowledgment is complete.
"RTN","HLOAPI2",78,0)
 ;Input:
"RTN","HLOAPI2",79,0)
 ;  ACK (pass by reference,required) An array that contains the acknowledgment msg
"RTN","HLOAPI2",80,0)
 ;Output:
"RTN","HLOAPI2",81,0)
 ; Function returns 1 on success, 0 on failure
"RTN","HLOAPI2",82,0)
 ; ERROR (pass by reference) error msg
"RTN","HLOAPI2",83,0)
 ;
"RTN","HLOAPI2",84,0)
 N SEG
"RTN","HLOAPI2",85,0)
 ;if the application added its own MSA, then the ACK("MSA") node was killed
"RTN","HLOAPI2",86,0)
 I $D(ACK("MSA")) S SEG(1)=ACK("MSA") D ADDSEG^HLOMSG(.ACK,.SEG)
"RTN","HLOAPI2",87,0)
 ;
"RTN","HLOAPI2",88,0)
 I $$SEND^HLOAPI1(.ACK,.ERROR) Q 1
"RTN","HLOAPI2",89,0)
 Q 0
"RTN","HLOAPI2",90,0)
 ;
"RTN","HLOAPI2",91,0)
ACKLINK(HLMSTATE) ;
"RTN","HLOAPI2",92,0)
 ;Finds the link to return the application ack to.
"RTN","HLOAPI2",93,0)
 N LINK
"RTN","HLOAPI2",94,0)
 S LINK=$$RTRNLNK^HLOAPP($G(HLMSTATE("HDR","RECEIVING APPLICATION")))
"RTN","HLOAPI2",95,0)
 Q:LINK]"" LINK
"RTN","HLOAPI2",96,0)
 S LINK=$$RTRNLNK^HLOTLNK($G(HLMSTATE("HDR","SENDING FACILITY",1)),$G(HLMSTATE("HDR","SENDING FACILITY",2)),$G(HLMSTATE("HDR","SENDING FACILITY",3)))
"RTN","HLOAPI2",97,0)
 Q LINK
"RTN","HLOAPI2",98,0)
 ;
"RTN","HLOAPI2",99,0)
CHKPARMS(HLMSTATE,PARMS,ERROR) ;
"RTN","HLOAPI2",100,0)
 N LEN,SARY,HARY
"RTN","HLOAPI2",101,0)
 ;
"RTN","HLOAPI2",102,0)
 ;shortcut to reference the header sub-array
"RTN","HLOAPI2",103,0)
 S HARY="HLMSTATE(""HDR"")"
"RTN","HLOAPI2",104,0)
 ;
"RTN","HLOAPI2",105,0)
 ;shortcut to reference the status sub-array
"RTN","HLOAPI2",106,0)
 S SARY="HLMSTATE(""STATUS"")"
"RTN","HLOAPI2",107,0)
 ;
"RTN","HLOAPI2",108,0)
 S ERROR=""
"RTN","HLOAPI2",109,0)
 I $G(PARMS("ACCEPT ACK TYPE"))="" S PARMS("ACCEPT ACK TYPE")="AL"
"RTN","HLOAPI2",110,0)
 I $G(PARMS("APP ACK TYPE"))="" S PARMS("APP ACK TYPE")="NE"
"RTN","HLOAPI2",111,0)
 I PARMS("ACCEPT ACK TYPE")'="NE",PARMS("ACCEPT ACK TYPE")'="AL" S ERROR="INVALID ACCEPT ACKNOWLEDGMENT TYPE"
"RTN","HLOAPI2",112,0)
 I PARMS("APP ACK TYPE")'="NE",PARMS("APP ACK TYPE")'="AL" S ERROR="INVALID APPLICATION ACKNOWLEDGMENT TYPE"
"RTN","HLOAPI2",113,0)
 S LEN=$L($G(PARMS("QUEUE")))
"RTN","HLOAPI2",114,0)
 I LEN>20 S ERROR="QUEUE PARAMETER IS MAX 20 LENGTH",PARMS("QUEUE")=$E(PARMS("QUEUE"),1,20)
"RTN","HLOAPI2",115,0)
 I 'LEN S PARMS("QUEUE")="DEFAULT"
"RTN","HLOAPI2",116,0)
 I $G(PARMS("SENDING APPLICATION"))="" D
"RTN","HLOAPI2",117,0)
 .S ERROR="SENDING APPLICATION IS REQUIRED"
"RTN","HLOAPI2",118,0)
 .S PARMS("SENDING APPLICATION")=""
"RTN","HLOAPI2",119,0)
 E  D
"RTN","HLOAPI2",120,0)
 .I '$D(^HLD(779.2,"C",PARMS("SENDING APPLICATION"))) S ERROR="SENDING APPLICATION NOT FOUND IN THE HLO APPLICATION REGISTRY"
"RTN","HLOAPI2",121,0)
 ;
"RTN","HLOAPI2",122,0)
 ;move parameters into HLMSTATE
"RTN","HLOAPI2",123,0)
 S @HARY@("ACCEPT ACK TYPE")=PARMS("ACCEPT ACK TYPE")
"RTN","HLOAPI2",124,0)
 S @HARY@("APP ACK TYPE")=PARMS("APP ACK TYPE")
"RTN","HLOAPI2",125,0)
 S @HARY@("SENDING APPLICATION")=$E(PARMS("SENDING APPLICATION"),1,60)
"RTN","HLOAPI2",126,0)
 S @HARY@("SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI2",127,0)
 S @SARY@("APP ACK RESPONSE")=$G(PARMS("APP ACK RESPONSE"))
"RTN","HLOAPI2",128,0)
 S @SARY@("ACCEPT ACK RESPONSE")=$G(PARMS("ACCEPT ACK RESPONSE"))
"RTN","HLOAPI2",129,0)
 S @SARY@("FAILURE RESPONSE")=$G(PARMS("FAILURE RESPONSE"))
"RTN","HLOAPI2",130,0)
 S @SARY@("QUEUE")=PARMS("QUEUE")
"RTN","HLOAPI2",131,0)
 Q:$L(ERROR) 0
"RTN","HLOAPI2",132,0)
 Q 1
"RTN","HLOAPI3")
0^4^B30983602
"RTN","HLOAPI3",1,0)
HLOAPI3 ;ALB/CJM-HL7 - Developer API's for sending application acks ;02/04/2004
"RTN","HLOAPI3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOAPI3",3,0)
 ;
"RTN","HLOAPI3",4,0)
BATCHACK(HLMSTATE,PARMS,ACK,ERROR) ;This API begins the creation of a batch
"RTN","HLOAPI3",5,0)
 ;message that is the response to a batch of messages. Individual acks
"RTN","HLOAPI3",6,0)
 ;are placed in the batch by calling $$ADDACK. $$SENDACK^HLOAPI2 must be
"RTN","HLOAPI3",7,0)
 ;called ;when the batch of acks is complete. The return destination is
"RTN","HLOAPI3",8,0)
 ;determined automatically from the original message.
"RTN","HLOAPI3",9,0)
 ;
"RTN","HLOAPI3",10,0)
 ;Input:
"RTN","HLOAPI3",11,0)
 ;  HLMSTATE (pass by reference, required) the array obtained by calling $$STARTMSG^HLOPRS when parsing the original message 
"RTN","HLOAPI3",12,0)
 ;  PARMS (optional, pass by reference) These subscripts may be defined:
"RTN","HLOAPI3",13,0)
 ;    "ACCEPT ACK RESPONSE")=<tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI3",14,0)
 ;    "ACCEPT ACK TYPE") = <AL,NE> (optional, defaults to AL)
"RTN","HLOAPI3",15,0)
 ;    "COUNTRY") - a 3 character country code from the HL7 standard table (optional)
"RTN","HLOAPI3",16,0)
 ;     "ENCODING CHARACTERS" - the 4 HL7 encoding characters (optional,defaults to "^~\&"
"RTN","HLOAPI3",17,0)
 ;    "FAILURE RESPONSE" (optional) the <tag>^<routine> that the sending application routine should execute if the transmission of the message fails, i.e., the message can not be sent or a requested commit ack is not received.
"RTN","HLOAPI3",18,0)
 ;     "FIELD SEPARATOR" - the field separator (optional, defaults to "|")
"RTN","HLOAPI3",19,0)
 ;     "QUEUE" (optional) An application can name a private queue (a string under 20 characters, namespaced). The default is the name of the queue of the original message
"RTN","HLOAPI3",20,0)
 ;     "SECURITY" - security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI3",21,0)
 ;    "VERSION" - the HL7 Version ID (optional, defaults to 2.4)
"RTN","HLOAPI3",22,0)
 ;Output:
"RTN","HLOAPI3",23,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",24,0)
 ;  PARMS - left undefined upon completion
"RTN","HLOAPI3",25,0)
 ;  ACK (pass by reference, required) the batch acknowledgment message being built.
"RTN","HLOAPI3",26,0)
 ;  ERROR (pass by reference) error message
"RTN","HLOAPI3",27,0)
 N I,TOLINK,SUCCESS
"RTN","HLOAPI3",28,0)
 S SUCCESS=0
"RTN","HLOAPI3",29,0)
 ;
"RTN","HLOAPI3",30,0)
 D
"RTN","HLOAPI3",31,0)
 .N PORT
"RTN","HLOAPI3",32,0)
 .I '$G(HLMSTATE("IEN")) S ERROR="ORIGINAL MESSAGE TO ACKNOWLEDGMENT IS NOT IDENTIFIED" Q
"RTN","HLOAPI3",33,0)
 .;if the return link can not be determined, the HL Logical Link file has a problem
"RTN","HLOAPI3",34,0)
 .S TOLINK=$$ACKLINK^HLOAPI2(.HLMSTATE)
"RTN","HLOAPI3",35,0)
 .I TOLINK="" S ERROR="TRANSMISSION LINK FOR APPLICATION ACK CANNOT BE DETERMINED" Q
"RTN","HLOAPI3",36,0)
 .S PORT=$P(HLMSTATE("HDR","SENDING FACILITY",2),":",2)
"RTN","HLOAPI3",37,0)
 .I 'PORT S PORT=$$PORT2^HLOTLNK(TOLINK)
"RTN","HLOAPI3",38,0)
 .;
"RTN","HLOAPI3",39,0)
 .I $$NEWBATCH^HLOAPI(.PARMS,.ACK)  ;can't fail!
"RTN","HLOAPI3",40,0)
 .S ACK("STATUS","QUEUE")=$G(PARMS("QUEUE"),$G(HLMSTATE("STATUS","QUEUE")))
"RTN","HLOAPI3",41,0)
 .S ACK("STATUS","PORT")=PORT
"RTN","HLOAPI3",42,0)
 .S ACK("HDR","SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI3",43,0)
 .S ACK("HDR","SENDING APPLICATION")=$G(HLMSTATE("HDR","RECEIVING APPLICATION"))
"RTN","HLOAPI3",44,0)
 .S ACK("HDR","RECEIVING APPLICATION")=$G(HLMSTATE("HDR","SENDING APPLICATION"))
"RTN","HLOAPI3",45,0)
 .F I=1:1:3 S ACK("HDR","RECEIVING FACILITY",I)=$G(HLMSTATE("HDR","SENDING FACILITY",I))
"RTN","HLOAPI3",46,0)
 .S ACK("HDR","APP ACK TYPE")="NE"
"RTN","HLOAPI3",47,0)
 .S ACK("HDR","ACCEPT ACK TYPE")=$G(PARMS("ACCEPT ACK TYPE"),"AL")
"RTN","HLOAPI3",48,0)
 .S ACK("ACK TO")=$G(HLMSTATE("HDR","BATCH CONTROL ID"))
"RTN","HLOAPI3",49,0)
 .S ACK("ACK TO","IEN")=HLMSTATE("IEN")
"RTN","HLOAPI3",50,0)
 .S ACK("ACK TO","BODY")=$G(HLMSTATE("BODY"))
"RTN","HLOAPI3",51,0)
 .S ACK("STATUS","LINK NAME")=TOLINK
"RTN","HLOAPI3",52,0)
 .S ACK("LINE COUNT")=0
"RTN","HLOAPI3",53,0)
 .S SUCCESS=1
"RTN","HLOAPI3",54,0)
 K PARMS
"RTN","HLOAPI3",55,0)
 Q SUCCESS
"RTN","HLOAPI3",56,0)
 ;
"RTN","HLOAPI3",57,0)
ADDACK(ACK,PARMS,ERROR) ;This API adds an application acknowledgment to a batch
"RTN","HLOAPI3",58,0)
 ;of acknowledgments that was started by calling $$BATCHACK.
"RTN","HLOAPI3",59,0)
 ;The Default behavior is to return a general application ack.
"RTN","HLOAPI3",60,0)
 ;The application may optionally specify the message
"RTN","HLOAPI3",61,0)
 ;type and event and/or call $$ADDSEG^HLOAPI to add segments.
"RTN","HLOAPI3",62,0)
 ;A generic MSA segment (components 1-3) will be added automatically
"RTN","HLOAPI3",63,0)
 ;if the application doesn't call $$ADDSEG^HLOAPI to add an MSA segment
"RTN","HLOAPI3",64,0)
 ;as the FIRST segment following the MSH segment.
"RTN","HLOAPI3",65,0)
 ;$$SENDACK^HLOAPI2 must be called when the batch is complete.
"RTN","HLOAPI3",66,0)
 ;
"RTN","HLOAPI3",67,0)
 ;Input:
"RTN","HLOAPI3",68,0)
 ;  ACK (pass by reference,required) the batch of acks that is being built 
"RTN","HLOAPI3",69,0)
 ;  PARMS (pass by reference) These subscripts may be defined:
"RTN","HLOAPI3",70,0)
 ;    "ACK CODE" (required) MSA1[ {AA,AE,AR}
"RTN","HLOAPI3",71,0)
 ;    "ERROR MESSAGE" (optional) MSA3, should be used only if AE or AR
"RTN","HLOAPI3",72,0)
 ;    "EVENT" - 3 character event type (optional, defaults to the event code of the original message)
"RTN","HLOAPI3",73,0)
 ;    "MESSAGE CONTROL ID" (required) this is the message control id of the original individual message within the batch which is being acknowledged
"RTN","HLOAPI3",74,0)
 ;    "MESSAGE STRUCTURE" (optional)
"RTN","HLOAPI3",75,0)
 ;    "MESSAGE TYPE" (optional, defaults to ACK)
"RTN","HLOAPI3",76,0)
 ;    "SECURITY" (optional) security information to include in the header segment SEQ 8
"RTN","HLOAPI3",77,0)
 ;Output:
"RTN","HLOAPI3",78,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",79,0)
 ;  ACK (pass by reference, required) The batch, updated with another ack
"RTN","HLOAPI3",80,0)
 ;  PARMS  - left undefined when this function returns
"RTN","HLOAPI3",81,0)
 ;  ERROR (pass by reference) error msg
"RTN","HLOAPI3",82,0)
 ;
"RTN","HLOAPI3",83,0)
 N SUB,SUCCESS
"RTN","HLOAPI3",84,0)
 S SUCCESS=0
"RTN","HLOAPI3",85,0)
 D
"RTN","HLOAPI3",86,0)
 .I $G(PARMS("ACK CODE"))'="AA",$G(PARMS("ACK CODE"))'="AE",$G(PARMS("ACK CODE"))'="AR" S ERROR="INVALID ACK CODE" Q
"RTN","HLOAPI3",87,0)
 .;
"RTN","HLOAPI3",88,0)
 .I $G(PARMS("MESSAGE CONTROL ID"))="" S ERROR="MESSAGE CONTROL ID MUST EXIST TO RETURN AN APPLICATION ACK" Q
"RTN","HLOAPI3",89,0)
 .S SUB=""
"RTN","HLOAPI3",90,0)
 .F  S SUB=$O(^HLB("AE",PARMS("MESSAGE CONTROL ID"),SUB)) Q:SUB=""  I $P(SUB,"^")=ACK("ACK TO","IEN"),$P(SUB,"^",2) S PARMS("ACK TO","IEN")=SUB Q
"RTN","HLOAPI3",91,0)
 .S PARMS("MESSAGE TYPE")=$G(PARMS("MESSAGE TYPE"),"ACK")
"RTN","HLOAPI3",92,0)
 .S:PARMS("MESSAGE TYPE")="ACK" PARMS("MESSAGE STRUCTURE")="ACK"
"RTN","HLOAPI3",93,0)
 .S PARMS("EVENT")=$G(PARMS("EVENT"))
"RTN","HLOAPI3",94,0)
 .I PARMS("EVENT")="",ACK("ACK TO","BODY"),$P(SUB,"^",2) S PARMS("EVENT")=$P($G(^HLA(ACK("ACK TO","BODY"),2,$P(SUB,"^",2),0)),"^",3)
"RTN","HLOAPI3",95,0)
 .S PARMS("ACK TO")=PARMS("MESSAGE CONTROL ID")
"RTN","HLOAPI3",96,0)
 .S PARMS("ACK TO","STATUS")=$S(PARMS("ACK CODE")="AA":"SU",1:"AE")
"RTN","HLOAPI3",97,0)
 .Q:'$$ADDMSG^HLOAPI(.ACK,.PARMS,.ERROR)
"RTN","HLOAPI3",98,0)
 .S ACK("MSA")="MSA|"_PARMS("ACK CODE")_"|"_PARMS("MESSAGE CONTROL ID")_"|"_$G(PARMS("ERROR MESSAGE"))
"RTN","HLOAPI3",99,0)
 .S SUCCESS=1
"RTN","HLOAPI3",100,0)
 K PARMS
"RTN","HLOAPI3",101,0)
 Q SUCCESS
"RTN","HLOAPI3",102,0)
 ;
"RTN","HLOAPI3",103,0)
RESEND(MSGIEN,ERROR) ;
"RTN","HLOAPI3",104,0)
 ;Description: This message will re-transmit an out-going message.  It
"RTN","HLOAPI3",105,0)
 ;does this by making a copy of the message, reusing all the original
"RTN","HLOAPI3",106,0)
 ;parameters. Then the message is placed on the same out-going queue.
"RTN","HLOAPI3",107,0)
 ;
"RTN","HLOAPI3",108,0)
 ;Input:
"RTN","HLOAPI3",109,0)
 ;  MSGIEN - the ien (file #778) of the message that is to be sent
"RTN","HLOAPI3",110,0)
 ;Output:
"RTN","HLOAPI3",111,0)
 ;  Function returns the ien of the message in file 778 on success, 0 on failure
"RTN","HLOAPI3",112,0)
 ;  ERROR (pass by reference, optional) - on failure, will contain an error message
"RTN","HLOAPI3",113,0)
 ;
"RTN","HLOAPI3",114,0)
 N MSG,SUB,HDR
"RTN","HLOAPI3",115,0)
 I '$$STARTMSG^HLOPRS(.MSG,MSGIEN) S ERROR="MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",116,0)
 I MSG("DIRECTION")'="OUT" S ERROR="MESSAGE IS NOT OUTGOING" Q 0
"RTN","HLOAPI3",117,0)
 I MSG("STATUS","LINK NAME")="" S ERROR="LINK NOT DEFINED" Q 0
"RTN","HLOAPI3",118,0)
 F SUB="ID","IEN","DT/TM","ACK BY","STATUS" S MSG(SUB)=""
"RTN","HLOAPI3",119,0)
 F SUB="PURGE" K MSG("STATUS",SUB)
"RTN","HLOAPI3",120,0)
 D GETSYS^HLOAPI(.MSG)
"RTN","HLOAPI3",121,0)
 I $$SAVEMSG^HLOF778(.MSG) D OUTQUE^HLOQUE(MSG("STATUS","LINK NAME"),$G(MSG("STATUS","PORT")),MSG("STATUS","QUEUE"),MSG("IEN")) Q +MSG("IEN")
"RTN","HLOAPI3",122,0)
 Q 0
"RTN","HLOAPI3",123,0)
 ;
"RTN","HLOAPI3",124,0)
SETPURGE(MSGIEN,TIME) ;
"RTN","HLOAPI3",125,0)
 ;Resets the purge date/time.
"RTN","HLOAPI3",126,0)
 ;Input:
"RTN","HLOAPI3",127,0)
 ;   MSGIEN (required) ien of the message, file #778
"RTN","HLOAPI3",128,0)
 ;   TIME (optional) dt/time to set the purge time to, defaults to NOW
"RTN","HLOAPI3",129,0)
 ;Output:
"RTN","HLOAPI3",130,0)
 ;   Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",131,0)
 N NODE,OLDTIME,HLDIR
"RTN","HLOAPI3",132,0)
 Q:'$G(MSGIEN) 0
"RTN","HLOAPI3",133,0)
 S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOAPI3",134,0)
 Q:NODE="" 0
"RTN","HLOAPI3",135,0)
 S OLDTIME=$P(NODE,"^",9)
"RTN","HLOAPI3",136,0)
 S:'$G(TIME) TIME=$$NOW^XLFDT
"RTN","HLOAPI3",137,0)
 S HLDIR=$S($E($P(NODE,"^",4))="I":"IN",1:"OUT")
"RTN","HLOAPI3",138,0)
 K:OLDTIME ^HLB("AD",HLDIR,OLDTIME,MSGIEN)
"RTN","HLOAPI3",139,0)
 S $P(^HLB(MSGIEN,0),"^",9)=TIME
"RTN","HLOAPI3",140,0)
 S ^HLB("AD",HLDIR,TIME,MSGIEN)=""
"RTN","HLOAPI3",141,0)
 Q 1
"RTN","HLOAPI3",142,0)
 ;
"RTN","HLOAPI3",143,0)
REPROC(MSGIEN,ERROR) ;
"RTN","HLOAPI3",144,0)
 ;Description: This message will re-process an incoming message by placing it on the appropriate incoming queue. If successful the message is set to be purged.
"RTN","HLOAPI3",145,0)
 ;
"RTN","HLOAPI3",146,0)
 ;Input:
"RTN","HLOAPI3",147,0)
 ;  MSGIEN - the ien (file #778) of the message that is to be sent
"RTN","HLOAPI3",148,0)
 ;Output:
"RTN","HLOAPI3",149,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",150,0)
 ;  ERROR (pass by reference, optional) - on failure, will contain an error message
"RTN","HLOAPI3",151,0)
 ;
"RTN","HLOAPI3",152,0)
 N MSG,HDR,ACTION,QUEUE,FROM
"RTN","HLOAPI3",153,0)
 ;
"RTN","HLOAPI3",154,0)
 I '$$STARTMSG^HLOPRS(.MSG,MSGIEN) S ERROR="MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",155,0)
 I MSG("DIRECTION")'="IN" S ERROR="MESSAGE IS NOT INCOMING" Q 0
"RTN","HLOAPI3",156,0)
 M HDR=MSG("HDR")
"RTN","HLOAPI3",157,0)
 I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE),$G(MSG("ACK TO"))="" S ERROR="RECEIVING APPLICATION NOT DEFINED"
"RTN","HLOAPI3",158,0)
 ;If this message references an earlier message, get the action specified by the original message
"RTN","HLOAPI3",159,0)
 I $G(MSG("ACK TO"))]"" D
"RTN","HLOAPI3",160,0)
 .N NODE,IEN
"RTN","HLOAPI3",161,0)
 .S IEN=$O(^HLB("B",$P(MSG("ACK TO"),"-"),0))
"RTN","HLOAPI3",162,0)
 .S:IEN NODE=$G(^HLB(IEN,0))
"RTN","HLOAPI3",163,0)
 .I ($P(NODE,"^",11)]"") S ACTION=$P(NODE,"^",10,11),QUEUE=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")
"RTN","HLOAPI3",164,0)
 I ACTION="" S ERROR="ORIGINAL MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",165,0)
 S FROM=$S(MSG("HDR","SENDING FACILITY",2)]"":MSG("HDR","SENDING FACILITY",2),1:MSG("HDR","SENDING FACILITY",1))
"RTN","HLOAPI3",166,0)
 D INQUE^HLOQUE(FROM,QUEUE,MSGIEN,ACTION,1)
"RTN","HLOAPI3",167,0)
 Q 1
"RTN","HLOAPP")
0^5^B4658819
"RTN","HLOAPP",1,0)
HLOAPP ;ALB/CJM-HL7 -Application Registry ;02/04/2004
"RTN","HLOAPP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOAPP",3,0)
 ;
"RTN","HLOAPP",4,0)
GETIEN(NAME) ;given the application name, it finds the ien.  Returns 0 on failure
"RTN","HLOAPP",5,0)
 Q:'$L($G(NAME)) 0
"RTN","HLOAPP",6,0)
 N IEN,SUB
"RTN","HLOAPP",7,0)
 S SUB=$E(NAME,1,60)
"RTN","HLOAPP",8,0)
 S IEN=0
"RTN","HLOAPP",9,0)
 F  S IEN=$O(^HLD(779.2,"B",SUB,IEN)) Q:'IEN  Q:$P($G(^HLD(779.2,IEN,0)),"^")=NAME
"RTN","HLOAPP",10,0)
 Q +IEN
"RTN","HLOAPP",11,0)
 ;
"RTN","HLOAPP",12,0)
ACTION(HEADER,ACTION,QUEUE) ;Given the parsed header of a message it returns both the action that should be performed in response to the message and the incoming queue that it should be placed on.
"RTN","HLOAPP",13,0)
 ;
"RTN","HLOAPP",14,0)
 ;Input:
"RTN","HLOAPP",15,0)
 ;  HEADER() subscripts are used: "RECEIVING APPLICATION","SEGMENT TYPE", "MESSAGE TYPE", "EVENT"
"RTN","HLOAPP",16,0)
 ;Output:
"RTN","HLOAPP",17,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPP",18,0)
 ;  ACTION (pass by reference) <tag>^<rtn>
"RTN","HLOAPP",19,0)
 ;  QUEUE (pass by reference) returns the named queue if there is one, else "DEFAULT"
"RTN","HLOAPP",20,0)
 ;
"RTN","HLOAPP",21,0)
 N IEN
"RTN","HLOAPP",22,0)
 S (ACTION,QUEUE)=""
"RTN","HLOAPP",23,0)
 S IEN=$$GETIEN(HEADER("RECEIVING APPLICATION"))
"RTN","HLOAPP",24,0)
 Q:'$G(IEN) 0
"RTN","HLOAPP",25,0)
 I $G(HEADER("SEGMENT TYPE"))="BHS" D
"RTN","HLOAPP",26,0)
 .S NODE=$G(^HLD(779.2,IEN,0))
"RTN","HLOAPP",27,0)
 .I $P(NODE,"^",5)]"" D
"RTN","HLOAPP",28,0)
 ..S ACTION=$P(NODE,"^",4,5)
"RTN","HLOAPP",29,0)
 .E  I $P(NODE,"^",7)]"" S ACTION=$P(NODE,"^",6,7)
"RTN","HLOAPP",30,0)
 .I $P(NODE,"^",8)]"" D
"RTN","HLOAPP",31,0)
 ..S QUEUE=$P(NODE,"^",8)
"RTN","HLOAPP",32,0)
 .E  I $P(NODE,"^",3)]"" S QUEUE=$P(NODE,"^",3)
"RTN","HLOAPP",33,0)
 E  I HEADER("SEGMENT TYPE")="MSH" D
"RTN","HLOAPP",34,0)
 .I HEADER("MESSAGE TYPE")'="",HEADER("EVENT")'="" D
"RTN","HLOAPP",35,0)
 ..N SUBIEN,NODE
"RTN","HLOAPP",36,0)
 ..S SUBIEN=$O(^HLD(779.2,IEN,1,"C",HEADER("MESSAGE TYPE"),HEADER("EVENT"),0))
"RTN","HLOAPP",37,0)
 ..I SUBIEN D
"RTN","HLOAPP",38,0)
 ...S NODE=$G(^HLD(779.2,IEN,1,SUBIEN,0))
"RTN","HLOAPP",39,0)
 ...I $P(NODE,"^",5)]"" S ACTION=$P(NODE,"^",4,5)
"RTN","HLOAPP",40,0)
 ...I $P(NODE,"^",3)]"" S QUEUE=$P(NODE,"^",3)
"RTN","HLOAPP",41,0)
 ..I ACTION="" S NODE=$G(^HLD(779.2,IEN,0)) I $P(NODE,"^",7)]"" S ACTION=$P(NODE,"^",6,7)
"RTN","HLOAPP",42,0)
 ..I QUEUE="" S NODE=$G(^HLD(779.2,IEN,0)) I $P(NODE,"^",3)]"" S QUEUE=$P(NODE,"^",3)
"RTN","HLOAPP",43,0)
 I QUEUE="" S QUEUE="DEFAULT"
"RTN","HLOAPP",44,0)
 I ACTION="" Q 0
"RTN","HLOAPP",45,0)
 Q 1
"RTN","HLOAPP",46,0)
 ;
"RTN","HLOAPP",47,0)
RTRNLNK(APPNAME) ;
"RTN","HLOAPP",48,0)
 ;given the name of a receiving application, this returns the return
"RTN","HLOAPP",49,0)
 ;link for application acks if one is provided.  Otherwise, return
"RTN","HLOAPP",50,0)
 ;acks are routed based on the information provide in the message hdr
"RTN","HLOAPP",51,0)
 ;
"RTN","HLOAPP",52,0)
 Q:(APPNAME="") ""
"RTN","HLOAPP",53,0)
 N IEN
"RTN","HLOAPP",54,0)
 S IEN=$$GETIEN(APPNAME)
"RTN","HLOAPP",55,0)
 Q:IEN $P($G(^HLD(779.2,IEN,0)),"^",2)
"RTN","HLOAPP",56,0)
 Q ""
"RTN","HLOAPP",57,0)
 ;
"RTN","HLOAPP",58,0)
RTRNPORT(APPNAME) ;
"RTN","HLOAPP",59,0)
 ;Given the name of the sending application, IF the application has its
"RTN","HLOAPP",60,0)
 ;own listener, its port # is returned.  Application acks should be
"RTN","HLOAPP",61,0)
 ;returned using that port
"RTN","HLOAPP",62,0)
 Q:(APPNAME="") ""
"RTN","HLOAPP",63,0)
 N IEN,LINK
"RTN","HLOAPP",64,0)
 S IEN=$$GETIEN(APPNAME)
"RTN","HLOAPP",65,0)
 Q:'IEN ""
"RTN","HLOAPP",66,0)
 S LINK=$P($G(^HLD(779.2,IEN,0)),"^",9)
"RTN","HLOAPP",67,0)
 Q:'LINK ""
"RTN","HLOAPP",68,0)
 Q $$PORT^HLOTLNK(LINK)
"RTN","HLOASUB")
0^6^B20309588
"RTN","HLOASUB",1,0)
HLOASUB ;IRMFO-ALB/CJM - Subscription Registry ;03/24/2004  14:43
"RTN","HLOASUB",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOASUB",3,0)
 ;
"RTN","HLOASUB",4,0)
CREATE(OWNER,DESCRIP,ERROR) ;
"RTN","HLOASUB",5,0)
 ;This API is used to create a new entry in the HLO Subscription Registry.
"RTN","HLOASUB",6,0)
 ;Input:
"RTN","HLOASUB",7,0)
 ;  OWNER - (required) The name of the owning application. The name of the owner. It should be prefixed with the package namespace to ensure uniqueness.
"RTN","HLOASUB",8,0)
 ;  DESCRIPTION - (optional) a brief (1 line) description
"RTN","HLOASUB",9,0)
 ;Output:
"RTN","HLOASUB",10,0)
 ;  Function returns new file 779.4 ien, or 0 if error
"RTN","HLOASUB",11,0)
 ;  ERROR (optional, pass by reference) an message on error
"RTN","HLOASUB",12,0)
 ;
"RTN","HLOASUB",13,0)
 N IEN,DATA
"RTN","HLOASUB",14,0)
 K ERROR
"RTN","HLOASUB",15,0)
 I '$L($G(OWNER)) S ERROR="OWNER NOT SPECIFIED" Q 0
"RTN","HLOASUB",16,0)
 L +^HLD(779.4,0):60
"RTN","HLOASUB",17,0)
 I '$T S ERROR="UNABLE TO LOCK THE HL7 SUBSCRIPTION REGISTRY" Q 0
"RTN","HLOASUB",18,0)
 S IEN=$O(^HLD(779.4,":"),-1),IEN=IEN+1
"RTN","HLOASUB",19,0)
 L -^HLD(779.4,0)
"RTN","HLOASUB",20,0)
 S DATA(.01)=IEN
"RTN","HLOASUB",21,0)
 S DATA(.02)=OWNER
"RTN","HLOASUB",22,0)
 S DATA(.03)=$G(DESCRIP)
"RTN","HLOASUB",23,0)
 Q $$ADD^HLOASUB1(779.4,,.DATA,.ERROR,IEN)
"RTN","HLOASUB",24,0)
 ;
"RTN","HLOASUB",25,0)
ONLIST(IEN,LINKIEN,APPNAME,FAC1,FAC2,FAC3) ;
"RTN","HLOASUB",26,0)
 ;Determines whether the recipient is already on the subscription list.
"RTN","HLOASUB",27,0)
 ;Input:
"RTN","HLOASUB",28,0)
 ;  IEN - (required) ien of the subscription list
"RTN","HLOASUB",29,0)
 ;  LINKIEN - ien of the logical link
"RTN","HLOASUB",30,0)
 ;  APPNAME - receiving application
"RTN","HLOASUB",31,0)
 ;  FAC1 -  component 1 of the receiving facility
"RTN","HLOASUB",32,0)
 ;  FAC2 - component 2
"RTN","HLOASUB",33,0)
 ;  FAC3 - component 3
"RTN","HLOASUB",34,0)
 ;Output:
"RTN","HLOASUB",35,0)
 ;  Function returns 0 if not found, otherwise the ien in the subfile
"RTN","HLOASUB",36,0)
 ;
"RTN","HLOASUB",37,0)
 Q +$O(^HLD(779.4,IEN,2,"AD",APPNAME,LINKIEN,FAC1_FAC2_FAC3,0))
"RTN","HLOASUB",38,0)
 ;
"RTN","HLOASUB",39,0)
ADD(IEN,WHO,ERROR) ;
"RTN","HLOASUB",40,0)
 ;Adds a new recipient to the list of recipients for this Subscription Registry Entry.
"RTN","HLOASUB",41,0)
 ;Input:
"RTN","HLOASUB",42,0)
 ;  IEN- the ien of the entry in the HL7 SUBSCRIPTION REGISTRY file.
"RTN","HLOASUB",43,0)
 ;  WHO (pass by reference) an array containing the information for a single new
"RTN","HLOASUB",44,0)
 ;    recipient to be added to the list. These subscripts are allowed:
"RTN","HLOASUB",45,0)
 ;
"RTN","HLOASUB",46,0)
 ;    "RECEIVING APPLICATION" - (string, 60 char max, required)
"RTN","HLOASUB",47,0)
 ;
"RTN","HLOASUB",48,0)
 ;  EXACTLY ONE of these parameters must be provided to identify the Receiving Facility:
"RTN","HLOASUB",49,0)
 ;
"RTN","HLOASUB",50,0)
 ;   "FACILITY LINK IEN" - ien of the logical link 
"RTN","HLOASUB",51,0)
 ;   "FACILITY LINK NAME" - name of the logical link 
"RTN","HLOASUB",52,0)
 ;   "INSTITUTION IEN" - ptr to the INSTITUTION file
"RTN","HLOASUB",53,0)
 ;   "STATION NUMBER" -  station # with suffix
"RTN","HLOASUB",54,0)
 ;
"RTN","HLOASUB",55,0)
 ;  EXACTLY ONE of these MAY be provided - optionally - to identify the interface engine to route the message through:
"RTN","HLOASUB",56,0)
 ;
"RTN","HLOASUB",57,0)
 ;   "IE LINK IEN" -  ptr to a logical link for the interface engine 
"RTN","HLOASUB",58,0)
 ;   "IE LINK NAME" - name of the logical link for the interface engine
"RTN","HLOASUB",59,0)
 ;
"RTN","HLOASUB",60,0)
 ;
"RTN","HLOASUB",61,0)
 ;Output:
"RTN","HLOASUB",62,0)
 ;   Function returns on success the ien of the recipient on the RECIPIENTS multiple , or 0 on failure
"RTN","HLOASUB",63,0)
 ;   WHO - left undefined when this function returns
"RTN","HLOASUB",64,0)
 ;   ERROR (optional, pass by reference) These error messages may be returned:
"RTN","HLOASUB",65,0)
 ;SUBSCRIPTION REGISTRY ENTRY NOT FOUND
"RTN","HLOASUB",66,0)
 ;RECEIVING FACILTY LOGICAL LINK NOT FOUND
"RTN","HLOASUB",67,0)
 ;RECEIVING APPLICATION NOT FOUND
"RTN","HLOASUB",68,0)
 ;INTERFACE ENGINE LOGICAL LINK PROVIDED BUT NOT FOUND
"RTN","HLOASUB",69,0)
 ;FAILED TO ACTIVATE SUBSCRIBER
"RTN","HLOASUB",70,0)
 ;
"RTN","HLOASUB",71,0)
 N PARMS,SUBIEN,DATA,DA,OK
"RTN","HLOASUB",72,0)
 K ERROR
"RTN","HLOASUB",73,0)
 S OK=0
"RTN","HLOASUB",74,0)
 D
"RTN","HLOASUB",75,0)
 .I '$G(IEN) S ERROR="SUBSCRIPITION REGISTRY ENTRY NOT FOUND" Q
"RTN","HLOASUB",76,0)
 .Q:'$$CHECKWHO^HLOASUB1(.WHO,.PARMS,.ERROR)
"RTN","HLOASUB",77,0)
 .S SUBIEN=$$ONLIST(IEN,PARMS("LINK IEN"),PARMS("RECEIVING APPLICATION"),PARMS("RECEIVING FACILITY",1),PARMS("RECEIVING FACILITY",2),PARMS("RECEIVING FACILITY",3))
"RTN","HLOASUB",78,0)
 .I SUBIEN S OK=1 D  Q
"RTN","HLOASUB",79,0)
 ..S DA=SUBIEN,DA(1)=IEN
"RTN","HLOASUB",80,0)
 ..I $P(^HLD(779.4,IEN,2,SUBIEN,1),"^",2) S DATA(1.01)=$$NOW^XLFDT,DATA(1.02)="" S OK=$$UPD^HLOASUB1(779.41,.DA,.DATA) I 'OK S ERROR="FAILED TO ACTIVATE SUBSCRIBER"
"RTN","HLOASUB",81,0)
 .;
"RTN","HLOASUB",82,0)
 .S DA(1)=IEN
"RTN","HLOASUB",83,0)
 .S DATA(.01)=PARMS("RECEIVING APPLICATION")
"RTN","HLOASUB",84,0)
 .S DATA(.02)=PARMS("LINK IEN")
"RTN","HLOASUB",85,0)
 .S DATA(.03)=PARMS("RECEIVING FACILITY",1)
"RTN","HLOASUB",86,0)
 .S DATA(.04)=PARMS("RECEIVING FACILITY",2)
"RTN","HLOASUB",87,0)
 .S DATA(.05)=PARMS("RECEIVING FACILITY",3)
"RTN","HLOASUB",88,0)
 .S DATA(1.01)=$$NOW^XLFDT
"RTN","HLOASUB",89,0)
 .S OK=$$ADD^HLOASUB1(779.41,.DA,.DATA,.ERROR)
"RTN","HLOASUB",90,0)
 K WHO
"RTN","HLOASUB",91,0)
 Q OK
"RTN","HLOASUB",92,0)
 ;
"RTN","HLOASUB",93,0)
NEXT(IEN,RECIP) ;
"RTN","HLOASUB",94,0)
 ;gets the next recipient on the list. It ignores recipients
"RTN","HLOASUB",95,0)
 ;that have a value for the DT/TM DELETED field.
"RTN","HLOASUB",96,0)
 ;Input:
"RTN","HLOASUB",97,0)
 ;  IEN (required) - the IEN assigned to this subscription
"RTN","HLOASUB",98,0)
 ;  RECIP - if empty, it gets the first recipient on the list, else it uses the value of RECIP("SUBIEN") to find the next recipient
"RTN","HLOASUB",99,0)
 ;Output:
"RTN","HLOASUB",100,0)
 ;RECIP(pass by reference, required) - returns the next recipient on the list. These subscripts are returned:
"RTN","HLOASUB",101,0)
 ;  "LINK IEN"
"RTN","HLOASUB",102,0)
 ;  "LINK NAME"
"RTN","HLOASUB",103,0)
 ;  "RECEIVING APPLICATION" 
"RTN","HLOASUB",104,0)
 ; ("RECEIVING FACILITY",1)  - Component 1
"RTN","HLOASUB",105,0)
 ; ("RECEIVING FACILITY",2)  - Component 2
"RTN","HLOASUB",106,0)
 ; ("RECEIVING FACILITY",3)  - Component 2
"RTN","HLOASUB",107,0)
 ;  "SUBIEN" - the ien in the multiple, used to find the next on the list.  
"RTN","HLOASUB",108,0)
 ;Function Value - IEN in the subfile on success, 0 if there are no more recipients found on the list (in which case, set "SUBIEN"=-1, set all other subscripts to ""
"RTN","HLOASUB",109,0)
 ;
"RTN","HLOASUB",110,0)
 N LAST,NEXT,NODE
"RTN","HLOASUB",111,0)
 S LAST=+$G(RECIP("SUBIEN"))
"RTN","HLOASUB",112,0)
 Q:(LAST=-1) 0
"RTN","HLOASUB",113,0)
 Q:'$G(IEN) 0
"RTN","HLOASUB",114,0)
 S NEXT=$O(^HLD(779.4,IEN,2,"AC",LAST))
"RTN","HLOASUB",115,0)
 I 'NEXT D  Q 0
"RTN","HLOASUB",116,0)
 .S RECIP("RECEIVING APPLICATION")=""
"RTN","HLOASUB",117,0)
 .S RECIP("LINK IEN")=""
"RTN","HLOASUB",118,0)
 .S RECIP("LINK NAME")=""
"RTN","HLOASUB",119,0)
 .S RECIP("RECEIVING FACILITY",1)=""
"RTN","HLOASUB",120,0)
 .S RECIP("RECEIVING FACILITY",2)=""
"RTN","HLOASUB",121,0)
 .S RECIP("RECEIVING FACILITY",3)=""
"RTN","HLOASUB",122,0)
 .S RECIP("SUBIEN")=-1
"RTN","HLOASUB",123,0)
 ;
"RTN","HLOASUB",124,0)
 S RECIP("SUBIEN")=NEXT
"RTN","HLOASUB",125,0)
 S NODE=$G(^HLD(779.4,IEN,2,NEXT,0))
"RTN","HLOASUB",126,0)
 S RECIP("LINK IEN")=$P(NODE,"^",2)
"RTN","HLOASUB",127,0)
 S RECIP("LINK NAME")=$S($P(NODE,"^",2):$P($G(^HLCS(870,$P(NODE,"^",2),0)),"^"),1:"")
"RTN","HLOASUB",128,0)
 S RECIP("RECEIVING APPLICATION")=$P(NODE,"^")
"RTN","HLOASUB",129,0)
 S RECIP("RECEIVING FACILITY",1)=$P(NODE,"^",3)
"RTN","HLOASUB",130,0)
 S RECIP("RECEIVING FACILITY",2)=$P(NODE,"^",4)
"RTN","HLOASUB",131,0)
 S RECIP("RECEIVING FACILITY",3)=$P(NODE,"^",5)
"RTN","HLOASUB",132,0)
 Q NEXT
"RTN","HLOASUB",133,0)
 ;
"RTN","HLOASUB",134,0)
END(IEN,WHO) ;will terminate a recipient from the list.The sub-record isn't
"RTN","HLOASUB",135,0)
 ;deleted, but the DATE/TIME TERMINATED field is entered with the current
"RTN","HLOASUB",136,0)
 ; date/time
"RTN","HLOASUB",137,0)
 ;Input:
"RTN","HLOASUB",138,0)
 ;  IEN - the ien of the HL7 Subscription Registry entry (required)
"RTN","HLOASUB",139,0)
 ;  WHO - (required, pass by reference)  If WHO("SUBIEN") is defined, then it should be the ien of the sub-record to be terminated.  Otherwise, set the parameters as per $$ADD.
"RTN","HLOASUB",140,0)
 ;Output: 
"RTN","HLOASUB",141,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOASUB",142,0)
 ;  WHO - left undefined when the function returns
"RTN","HLOASUB",143,0)
 ;
"RTN","HLOASUB",144,0)
 N SUBIEN,DATA,DA,OK
"RTN","HLOASUB",145,0)
 S OK=0
"RTN","HLOASUB",146,0)
 D
"RTN","HLOASUB",147,0)
 .S SUBIEN=0
"RTN","HLOASUB",148,0)
 .Q:'$G(IEN)
"RTN","HLOASUB",149,0)
 .I $G(WHO("SUBIEN")) D
"RTN","HLOASUB",150,0)
 ..S SUBIEN=WHO("SUBIEN")
"RTN","HLOASUB",151,0)
 .E  D
"RTN","HLOASUB",152,0)
 ..N PARMS
"RTN","HLOASUB",153,0)
 ..S:$$CHECKWHO^HLOASUB1(.WHO,.PARMS) SUBIEN=$$ONLIST(IEN,PARMS("LINK IEN"),PARMS("RECEIVING APPLICATION"),PARMS("RECEIVING FACILITY",1),PARMS("RECEIVING FACILITY",2),PARMS("RECEIVING FACILITY",3))
"RTN","HLOASUB",154,0)
 .I 'SUBIEN S OK=1 Q
"RTN","HLOASUB",155,0)
 .S DA(1)=IEN,DA=SUBIEN
"RTN","HLOASUB",156,0)
 .S DATA(1.02)=$$NOW^XLFDT
"RTN","HLOASUB",157,0)
 .S OK=$$UPD^HLOASUB1(779.41,.DA,.DATA)
"RTN","HLOASUB",158,0)
 K WHO
"RTN","HLOASUB",159,0)
 Q OK
"RTN","HLOASUB",160,0)
 ;
"RTN","HLOASUB",161,0)
DELETE(IEN) ;Deletes the entry in the HL7 Subscription Registry.
"RTN","HLOASUB",162,0)
 Q $$DELETE^HLOASUB1(779.4,$G(IEN))
"RTN","HLOASUB1")
0^7^B53189937
"RTN","HLOASUB1",1,0)
HLOASUB1 ;IRMFO-ALB/CJM - Subscription Registry (continued) ;03/24/2004  14:43
"RTN","HLOASUB1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995;
"RTN","HLOASUB1",3,0)
 ;
"RTN","HLOASUB1",4,0)
INDEX(IEN,PARMARY) ;
"RTN","HLOASUB1",5,0)
 ;Description: This allows an application to build an index of its
"RTN","HLOASUB1",6,0)
 ;subscriptions.  This is optional, but using this function allows the
"RTN","HLOASUB1",7,0)
 ;application to easily find subscriptions without storing the ien.
"RTN","HLOASUB1",8,0)
 ;
"RTN","HLOASUB1",9,0)
 ;Input:
"RTN","HLOASUB1",10,0)
 ;  IEN - ien of the entry in the Subscription Registry
"RTN","HLOASUB1",11,0)
 ;  PARMARY - **pass by reference** an array of parameters with which to build the index.  The format is: PARMARY(1)=<first parameter>, PARMARY(2)=<second parameter>  If PARMARY(i)=null, the parameter will be translated to a single space.
"RTN","HLOASUB1",12,0)
 ;Output:
"RTN","HLOASUB1",13,0)
 ;  function returns 1 on success, 0 otherwise
"RTN","HLOASUB1",14,0)
 ;  PARMARY - left undefined
"RTN","HLOASUB1",15,0)
 ;
"RTN","HLOASUB1",16,0)
 N OK S OK=0
"RTN","HLOASUB1",17,0)
 D
"RTN","HLOASUB1",18,0)
 .Q:'$G(IEN)
"RTN","HLOASUB1",19,0)
 .N OWNER,INDEX,I
"RTN","HLOASUB1",20,0)
 .S OWNER=$P($G(^HLD(779.4,IEN,0)),"^",2)
"RTN","HLOASUB1",21,0)
 .Q:'$L(OWNER)
"RTN","HLOASUB1",22,0)
 .Q:'$D(PARMARY)
"RTN","HLOASUB1",23,0)
 .S INDEX="^HLD(779.4,""AH"",OWNER,"
"RTN","HLOASUB1",24,0)
 .S I=0
"RTN","HLOASUB1",25,0)
 .F  S I=$O(PARMARY(I)) Q:'I  S INDEX=INDEX_""""_$S($L(PARMARY(I)):PARMARY(I),1:" ")_""","
"RTN","HLOASUB1",26,0)
 .S INDEX=$E(INDEX,1,$L(INDEX)-1)_")"
"RTN","HLOASUB1",27,0)
 .S @INDEX=IEN
"RTN","HLOASUB1",28,0)
 .S ^HLD(779.4,"AH KILL",IEN,""""_OWNER_""","_$P(INDEX,"^HLD(779.4,""AH"",OWNER,",2))=""
"RTN","HLOASUB1",29,0)
 .S OK=1
"RTN","HLOASUB1",30,0)
 K PARMARY
"RTN","HLOASUB1",31,0)
 Q OK
"RTN","HLOASUB1",32,0)
 ;
"RTN","HLOASUB1",33,0)
KILLAH(IEN) ;kills the AH x~ref on file 779.4 for a particular subscription registry entry=ien
"RTN","HLOASUB1",34,0)
 Q:'$G(IEN)
"RTN","HLOASUB1",35,0)
 N NEXT,LOCATION
"RTN","HLOASUB1",36,0)
 S NEXT=""
"RTN","HLOASUB1",37,0)
 F  S NEXT=$O(^HLD(779.4,"AH KILL",IEN,NEXT)) Q:'$L(NEXT)  D
"RTN","HLOASUB1",38,0)
 .S LOCATION="^HLD(779.4,""AH"","_NEXT
"RTN","HLOASUB1",39,0)
 .K @LOCATION
"RTN","HLOASUB1",40,0)
 K ^HLD(779.4,"AH KILL",IEN)
"RTN","HLOASUB1",41,0)
 Q
"RTN","HLOASUB1",42,0)
 ;
"RTN","HLOASUB1",43,0)
FIND(OWNER,PARMARY) ;
"RTN","HLOASUB1",44,0)
 ;Description: This allows an application to find a subscription
"RTN","HLOASUB1",45,0)
 ;list.  The application must maintain a private index in order to
"RTN","HLOASUB1",46,0)
 ;utilize this function, via $$INDEX^HLOASUB()
"RTN","HLOASUB1",47,0)
 ;
"RTN","HLOASUB1",48,0)
 ;Input:
"RTN","HLOASUB1",49,0)
 ;  OWNER - owning application name
"RTN","HLOASUB1",50,0)
 ;  PARMARY  **pass by reference** an array of parameters with which the index was built.  The format is: PARMARY(1)=<first parameter>, PARMARY(2)=<second parameter>  If PARMARY(i)=null, the parameter will be translated to a single space.
"RTN","HLOASUB1",51,0)
 ;Output:
"RTN","HLOASUB1",52,0)
 ;  function returns the ien of the subscription list if found, 0 otherwise
"RTN","HLOASUB1",53,0)
 ; PARMARY - left undefined
"RTN","HLOASUB1",54,0)
 ;
"RTN","HLOASUB1",55,0)
 N OK S OK=0
"RTN","HLOASUB1",56,0)
 ;
"RTN","HLOASUB1",57,0)
 D
"RTN","HLOASUB1",58,0)
 .Q:'$D(PARMARY)
"RTN","HLOASUB1",59,0)
 .Q:'$L($G(OWNER))
"RTN","HLOASUB1",60,0)
 .N INDEX,I
"RTN","HLOASUB1",61,0)
 .S INDEX="^HLD(779.4,""AH"",OWNER,"
"RTN","HLOASUB1",62,0)
 .S I=0
"RTN","HLOASUB1",63,0)
 .F  S I=$O(PARMARY(I)) Q:'I  S INDEX=INDEX_""""_$S($L(PARMARY(I)):PARMARY(I),1:" ")_""","
"RTN","HLOASUB1",64,0)
 .S INDEX=$E(INDEX,1,$L(INDEX)-1)_")"
"RTN","HLOASUB1",65,0)
 .S OK=+$G(@INDEX)
"RTN","HLOASUB1",66,0)
 K PARMARY
"RTN","HLOASUB1",67,0)
 Q OK
"RTN","HLOASUB1",68,0)
 ;
"RTN","HLOASUB1",69,0)
UPD(FILE,DA,DATA,ERROR) ;File data into an existing record.
"RTN","HLOASUB1",70,0)
 ; Input:
"RTN","HLOASUB1",71,0)
 ;   FILE - File or sub-file number
"RTN","HLOASUB1",72,0)
 ;   DA - Traditional DA array, with same meaning.
"RTN","HLOASUB1",73,0)
 ;            Pass by reference.
"RTN","HLOASUB1",74,0)
 ;   DATA - Data array to file (pass by reference)
"RTN","HLOASUB1",75,0)
 ;          Format: DATA(<field #>)=<value>
"RTN","HLOASUB1",76,0)
 ;
"RTN","HLOASUB1",77,0)
 ; Output:
"RTN","HLOASUB1",78,0)
 ;  Function Value -     0=error and 1=no error
"RTN","HLOASUB1",79,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","HLOASUB1",80,0)
 ;
"RTN","HLOASUB1",81,0)
 ; Example: To update a record in subfile 2.0361 in record with ien=353,
"RTN","HLOASUB1",82,0)
 ;          subrecord ien=68, with the field .01 value = 21:
"RTN","HLOASUB1",83,0)
 ;    S DATA(.01)=21,DA=68,DA(1)=353 I $$UPDS(2.0361,.DA,.DATA,.ERROR) W !,"DONE"
"RTN","HLOASUB1",84,0)
 ;
"RTN","HLOASUB1",85,0)
 N FDA,FIELD,IENS,ERRORS
"RTN","HLOASUB1",86,0)
 ;
"RTN","HLOASUB1",87,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","HLOASUB1",88,0)
 ;FDA - the FDA array as defined by FM
"RTN","HLOASUB1",89,0)
 ;
"RTN","HLOASUB1",90,0)
 I '$G(DA) S ERROR="IEN OF RECORD TO BE UPDATED NOT SPECIFIED" Q 0
"RTN","HLOASUB1",91,0)
 S IENS=$$IENS^DILF(.DA)
"RTN","HLOASUB1",92,0)
 S FIELD=0
"RTN","HLOASUB1",93,0)
 F  S FIELD=$O(DATA(FIELD)) Q:'FIELD  D
"RTN","HLOASUB1",94,0)
 .S FDA(FILE,IENS,FIELD)=$G(DATA(FIELD))
"RTN","HLOASUB1",95,0)
 D FILE^DIE("","FDA","ERRORS(1)")
"RTN","HLOASUB1",96,0)
 I +$G(DIERR) D
"RTN","HLOASUB1",97,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","HLOASUB1",98,0)
 E  D
"RTN","HLOASUB1",99,0)
 .S ERROR=""
"RTN","HLOASUB1",100,0)
 ;
"RTN","HLOASUB1",101,0)
 D CLEAN^DILF
"RTN","HLOASUB1",102,0)
 Q $S(+$G(DIERR):0,1:1)
"RTN","HLOASUB1",103,0)
 ;
"RTN","HLOASUB1",104,0)
ADD(FILE,DA,DATA,ERROR,IEN) ;
"RTN","HLOASUB1",105,0)
 ;Description: Creates a new record and files the data.
"RTN","HLOASUB1",106,0)
 ; Input:
"RTN","HLOASUB1",107,0)
 ;   FILE - File or sub-file number
"RTN","HLOASUB1",108,0)
 ;   DA - Traditional FileMan DA array with same
"RTN","HLOASUB1",109,0)
 ;            meaning. Pass by reference.  Only needed if adding to a
"RTN","HLOASUB1",110,0)
 ;            subfile.
"RTN","HLOASUB1",111,0)
 ;   DATA - Data array to file, pass by reference
"RTN","HLOASUB1",112,0)
 ;          Format: DATA(<field #>)=<value>
"RTN","HLOASUB1",113,0)
 ;   IEN - internal entry number to use (optional)
"RTN","HLOASUB1",114,0)
 ;
"RTN","HLOASUB1",115,0)
 ; Output:
"RTN","HLOASUB1",116,0)
 ;   Function Value - If no error then it returns the ien of the created record, else returns NULL.
"RTN","HLOASUB1",117,0)
 ;  DA - returns the ien of the new record, NULL if none created.  If needed, pass by reference.
"RTN","HLOASUB1",118,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","HLOASUB1",119,0)
 ;
"RTN","HLOASUB1",120,0)
 ; Example: To add a record in subfile 2.0361 in the record with ien=353
"RTN","HLOASUB1",121,0)
 ;          with the field .01 value = 21:
"RTN","HLOASUB1",122,0)
 ;  S DATA(.01)=21,DA(1)=353 I $$ADD(2.0361,.DA,.DATA) W !,"DONE"
"RTN","HLOASUB1",123,0)
 ;
"RTN","HLOASUB1",124,0)
 ; Example: If creating a record not in a subfile, would look like this:
"RTN","HLOASUB1",125,0)
 ;          S DATA(.01)=21 I $$ADD(867,,.DATA) W !,"DONE"
"RTN","HLOASUB1",126,0)
 ;
"RTN","HLOASUB1",127,0)
 N FDA,FIELD,IENA,IENS,ERRORS
"RTN","HLOASUB1",128,0)
 ;
"RTN","HLOASUB1",129,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","HLOASUB1",130,0)
 ;IENA - the Internal Entry Number Array defined by FM
"RTN","HLOASUB1",131,0)
 ;FDA - the FDA array defined by FM
"RTN","HLOASUB1",132,0)
 ;IEN - the ien of the new record
"RTN","HLOASUB1",133,0)
 ;
"RTN","HLOASUB1",134,0)
 S DA="+1"
"RTN","HLOASUB1",135,0)
 S IENS=$$IENS^DILF(.DA)
"RTN","HLOASUB1",136,0)
 S FIELD=0
"RTN","HLOASUB1",137,0)
 F  S FIELD=$O(DATA(FIELD)) Q:'FIELD  D
"RTN","HLOASUB1",138,0)
 .S FDA(FILE,IENS,FIELD)=$G(DATA(FIELD))
"RTN","HLOASUB1",139,0)
 I $G(IEN) S IENA(1)=IEN
"RTN","HLOASUB1",140,0)
 D UPDATE^DIE("","FDA","IENA","ERRORS(1)")
"RTN","HLOASUB1",141,0)
 I +$G(DIERR) D
"RTN","HLOASUB1",142,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","HLOASUB1",143,0)
 .S IEN=""
"RTN","HLOASUB1",144,0)
 E  D
"RTN","HLOASUB1",145,0)
 .S IEN=IENA(1)
"RTN","HLOASUB1",146,0)
 .S ERROR=""
"RTN","HLOASUB1",147,0)
 D CLEAN^DILF
"RTN","HLOASUB1",148,0)
 S DA=IEN
"RTN","HLOASUB1",149,0)
 Q IEN
"RTN","HLOASUB1",150,0)
 ;
"RTN","HLOASUB1",151,0)
DELETE(FILE,DA,ERROR)   ;Delete an existing record.
"RTN","HLOASUB1",152,0)
 N DATA
"RTN","HLOASUB1",153,0)
 S DATA(.01)="@"
"RTN","HLOASUB1",154,0)
 Q $$UPD^HLEMU(FILE,.DA,.DATA,.ERROR)
"RTN","HLOASUB1",155,0)
 Q
"RTN","HLOASUB1",156,0)
 ;
"RTN","HLOASUB1",157,0)
STATNUM(IEN) ;
"RTN","HLOASUB1",158,0)
 ;Description:  Given an ien to the Institution file, returns as the function value the station number. If IEN is NOT passed in, it assumes the local site.  Returns "" on failure.
"RTN","HLOASUB1",159,0)
 ;
"RTN","HLOASUB1",160,0)
 N STATION,RETURN
"RTN","HLOASUB1",161,0)
 S RETURN=""
"RTN","HLOASUB1",162,0)
 I $G(IEN) D
"RTN","HLOASUB1",163,0)
 .Q:'$D(^DIC(4,IEN,0))
"RTN","HLOASUB1",164,0)
 .S STATION=$P($$NNT^XUAF4(IEN),"^",2)
"RTN","HLOASUB1",165,0)
 .S RETURN=$S(+STATION:STATION,1:"")
"RTN","HLOASUB1",166,0)
 E  D
"RTN","HLOASUB1",167,0)
 .S RETURN=$P($$SITE^VASITE(),"^",3)
"RTN","HLOASUB1",168,0)
 Q RETURN
"RTN","HLOASUB1",169,0)
 ;
"RTN","HLOASUB1",170,0)
CHECKWHO(WHO,PARMS,ERROR) ;
"RTN","HLOASUB1",171,0)
 ;Checks the parameters provided in WHO() (see $$ADD).  They must resolve
"RTN","HLOASUB1",172,0)
 ;the link, receiving app and receiving facility.
"RTN","HLOASUB1",173,0)
 ;INPUT:
"RTN","HLOASUB1",174,0)
 ;  WHO - (required, pass by reference) - see $$ADD.
"RTN","HLOASUB1",175,0)
 ;
"RTN","HLOASUB1",176,0)
 ;  WHO("PORT") - if this is valued, it will be used as the remote port
"RTN","HLOASUB1",177,0)
 ;    to connect with rather than the port associated with the link
"RTN","HLOASUB1",178,0)
 ;Output:
"RTN","HLOASUB1",179,0)
 ;  Function returns 1 if the input is resolved successfully, 0 otherwise
"RTN","HLOASUB1",180,0)
 ;    PARMS - (pass by reference)  These subscripts are returned:
"RTN","HLOASUB1",181,0)
 ;     "LINK IEN" - ien of the link 
"RTN","HLOASUB1",182,0)
 ;     "LINK NAME" - name of the link
"RTN","HLOASUB1",183,0)
 ;     "RECEIVING APPLICATION"  - name of the receiving app
"RTN","HLOASUB1",184,0)
 ;     "RECEIVING FACILITY",1)  - component 1
"RTN","HLOASUB1",185,0)
 ;     "RECEIVING FACILITY",2) - component 2
"RTN","HLOASUB1",186,0)
 ;     "RECEIVING FACILITY",3) - component 3
"RTN","HLOASUB1",187,0)
 ;   ERROR - (pass by reference) - if unsuccessful, an error message is returned.
"RTN","HLOASUB1",188,0)
 ;
"RTN","HLOASUB1",189,0)
 N OK
"RTN","HLOASUB1",190,0)
 K ERROR
"RTN","HLOASUB1",191,0)
 S OK=1
"RTN","HLOASUB1",192,0)
 S PARMS("LINK IEN")="",PARMS("LINK NAME")=""
"RTN","HLOASUB1",193,0)
 ;must identify the receiving app
"RTN","HLOASUB1",194,0)
 ;
"RTN","HLOASUB1",195,0)
 D
"RTN","HLOASUB1",196,0)
 .N LEN
"RTN","HLOASUB1",197,0)
 .S LEN=$L($G(WHO("RECEIVING APPLICATION")))
"RTN","HLOASUB1",198,0)
 .I 'LEN S OK=0
"RTN","HLOASUB1",199,0)
 .E  I LEN>60 S OK=0
"RTN","HLOASUB1",200,0)
 .S:'OK ERROR="RECEIVING APPLICATION NOT VALID"
"RTN","HLOASUB1",201,0)
 .S PARMS("RECEIVING APPLICATION")=$G(WHO("RECEIVING APPLICATION"))
"RTN","HLOASUB1",202,0)
 ;
"RTN","HLOASUB1",203,0)
 ;find the station # if Institution ien known
"RTN","HLOASUB1",204,0)
 S:$G(WHO("INSTITUTION IEN")) WHO("STATION NUMBER")=$$STATNUM^HLOASUB1(WHO("INSTITUTION IEN"))
"RTN","HLOASUB1",205,0)
 ;
"RTN","HLOASUB1",206,0)
 ;if destination link specified by name, get its ien
"RTN","HLOASUB1",207,0)
 I '$G(WHO("FACILITY LINK IEN")),$L($G(WHO("FACILITY LINK NAME"))) S WHO("FACILITY LINK IEN")=$O(^HLCS(870,"B",WHO("FACILITY LINK NAME"),0))
"RTN","HLOASUB1",208,0)
 ;
"RTN","HLOASUB1",209,0)
 ;if destination link not specified, find it based on station #
"RTN","HLOASUB1",210,0)
 I +$G(WHO("STATION NUMBER")),'$G(WHO("FACILITY LINK IEN")) S WHO("FACILITY LINK IEN")=$$FINDLINK^HLOTLNK(WHO("STATION NUMBER"))
"RTN","HLOASUB1",211,0)
 ;
"RTN","HLOASUB1",212,0)
 ;if station # not known, find it based on destination link
"RTN","HLOASUB1",213,0)
 I '$G(WHO("STATION NUMBER")),$G(WHO("FACILITY LINK IEN")) S WHO("STATION NUMBER")=$$STATNUM^HLOTLNK(WHO("FACILITY LINK IEN"))
"RTN","HLOASUB1",214,0)
 ;
"RTN","HLOASUB1",215,0)
 S PARMS("RECEIVING FACILITY",1)=$G(WHO("STATION NUMBER"))
"RTN","HLOASUB1",216,0)
 ;
"RTN","HLOASUB1",217,0)
 ;if the destination link is known, get the domain
"RTN","HLOASUB1",218,0)
 S PARMS("RECEIVING FACILITY",2)=$S($G(WHO("FACILITY LINK IEN")):$$DOMAIN^HLOTLNK(WHO("FACILITY LINK IEN")),1:"")
"RTN","HLOASUB1",219,0)
 ;
"RTN","HLOASUB1",220,0)
 S PARMS("RECEIVING FACILITY",3)="DNS"
"RTN","HLOASUB1",221,0)
 ;
"RTN","HLOASUB1",222,0)
 ;find the link to send over - need name & ien
"RTN","HLOASUB1",223,0)
 I $G(WHO("IE LINK IEN")) D
"RTN","HLOASUB1",224,0)
 .S PARMS("LINK IEN")=WHO("IE LINK IEN")
"RTN","HLOASUB1",225,0)
 .S PARMS("LINK NAME")=$P($G(^HLCS(870,PARMS("LINK IEN"),0)),"^")
"RTN","HLOASUB1",226,0)
 .I OK,'$L(PARMS("LINK NAME")) S OK=0,ERROR="INTERFACE ENGINE LOGICAL LINK PROVIDED BUT NOT FOUND"
"RTN","HLOASUB1",227,0)
 E  I $L($G(WHO("IE LINK NAME"))) D
"RTN","HLOASUB1",228,0)
 .S PARMS("LINK NAME")=WHO("IE LINK NAME")
"RTN","HLOASUB1",229,0)
 .S PARMS("LINK IEN")=$O(^HLCS(870,"B",WHO("IE LINK NAME"),0))
"RTN","HLOASUB1",230,0)
 .I OK,'PARMS("LINK IEN") S OK=0,ERROR="INTERFACE ENGINE LOGICAL LINK PROVIDED BUT NOT FOUND"
"RTN","HLOASUB1",231,0)
 E  I $G(WHO("FACILITY LINK IEN")) D
"RTN","HLOASUB1",232,0)
 .S PARMS("LINK IEN")=WHO("FACILITY LINK IEN")
"RTN","HLOASUB1",233,0)
 .S PARMS("LINK NAME")=$P($G(^HLCS(870,PARMS("LINK IEN"),0)),"^")
"RTN","HLOASUB1",234,0)
 .I OK,'$L(PARMS("LINK NAME")) S OK=0,ERROR="RECEIVING FACILITY LOGICAL LINK NOT FOUND"
"RTN","HLOASUB1",235,0)
 E  I $L($G(WHO("FACILITY LINK NAME"))) D
"RTN","HLOASUB1",236,0)
 .S PARMS("LINK NAME")=WHO("FACILITY LINK NAME")
"RTN","HLOASUB1",237,0)
 .S PARMS("LINK IEN")=$O(^HLCS(870,"B",WHO("FACILITY LINK NAME"),0))
"RTN","HLOASUB1",238,0)
 .I OK,'PARMS("LINK IEN") S OK=0,ERROR="RECEIVING FACILITY LOGICAL LINK NOT FOUND"
"RTN","HLOASUB1",239,0)
 I OK,(('PARMS("LINK IEN"))!(PARMS("LINK NAME")="")) S OK=0,ERROR="LOGICAL LINK TO TRANSMIT OVER NOT SPECIFIED"
"RTN","HLOASUB1",240,0)
 ;
"RTN","HLOASUB1",241,0)
 ;need the station # or domain for msg header
"RTN","HLOASUB1",242,0)
 I OK,'$L(PARMS("RECEIVING FACILITY",2)),'PARMS("RECEIVING FACILITY",1) S OK=0,ERROR="RECEIVING FACILITY STATION # AND DOMAIN NOT SPECIFIED"
"RTN","HLOASUB1",243,0)
 ;
"RTN","HLOASUB1",244,0)
 ;append the port#
"RTN","HLOASUB1",245,0)
 I '$G(WHO("PORT")) S PARMS("RECEIVING FACILITY",2)=PARMS("RECEIVING FACILITY",2)_":"_$$PORT^HLOTLNK($G(WHO("FACILITY LINK IEN")))
"RTN","HLOASUB1",246,0)
 E  S PARMS("RECEIVING FACILITY",2)=PARMS("RECEIVING FACILITY",2)_":"_WHO("PORT")
"RTN","HLOASUB1",247,0)
 ;
"RTN","HLOASUB1",248,0)
 Q OK
"RTN","HLOCLNT")
0^8^B65447935
"RTN","HLOCLNT",1,0)
HLOCLNT ;ALB/CJM- Client for sending messages - 10/4/94 1pm
"RTN","HLOCLNT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOCLNT",3,0)
 ;
"RTN","HLOCLNT",4,0)
 ;GET WORK function for the process running under the Process Manager
"RTN","HLOCLNT",5,0)
GETWORK(QUE) ;
"RTN","HLOCLNT",6,0)
 ;Input:
"RTN","HLOCLNT",7,0)
 ;  QUE - (pass by reference) These subscripts are used:
"RTN","HLOCLNT",8,0)
 ;    ("LINK")  - <link name>_":"_<port> last obtained
"RTN","HLOCLNT",9,0)
 ;    ("QUEUE") - name of the queue last obtained
"RTN","HLOCLNT",10,0)
 ;Output:
"RTN","HLOCLNT",11,0)
 ;  Function returns 1 if success, 0 if no more work
"RTN","HLOCLNT",12,0)
 ;  QUE -  updated to identify next queue of messages to process.
"RTN","HLOCLNT",13,0)
 ;    ("LINK") - <link name>_":"_<port>
"RTN","HLOCLNT",14,0)
 ;    ("QUEUE") - the named queue on the link
"RTN","HLOCLNT",15,0)
 ;    ("DOWN") - =1 means that the last OPEN attempt failed
"RTN","HLOCLNT",16,0)
 ;
"RTN","HLOCLNT",17,0)
 N LINK,QUEUE
"RTN","HLOCLNT",18,0)
 S LINK=$G(QUE("LINK")),QUEUE=$G(QUE("QUEUE"))
"RTN","HLOCLNT",19,0)
 I (LINK]""),(QUEUE]"") D
"RTN","HLOCLNT",20,0)
 .L -^HLB("QUEUE","OUT",LINK,QUEUE)
"RTN","HLOCLNT",21,0)
 .I '$$CNNCTD(LINK),$$FAILING(.LINK) S QUEUE="" Q
"RTN","HLOCLNT",22,0)
 .F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0  Q:$T
"RTN","HLOCLNT",23,0)
 I (LINK]""),(QUEUE="") D
"RTN","HLOCLNT",24,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",25,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",26,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",27,0)
 I LINK="" D
"RTN","HLOCLNT",28,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",29,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",30,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",31,0)
 S QUE("LINK")=LINK,QUE("QUEUE")=QUEUE,QUE("DOWN")=$G(LINK("DOWN"))
"RTN","HLOCLNT",32,0)
 Q:$L(QUEUE) 1
"RTN","HLOCLNT",33,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",34,0)
 Q 0
"RTN","HLOCLNT",35,0)
 ;
"RTN","HLOCLNT",36,0)
FAILING(LINK) ;
"RTN","HLOCLNT",37,0)
 ;Returns 1 if the link has failed in the last 30 seconds, 0 otherwise
"RTN","HLOCLNT",38,0)
 ;Also returns LINK("DOWN")=1 if the link was failing > 30 seconds ago, not yet known if its up
"RTN","HLOCLNT",39,0)
 ;
"RTN","HLOCLNT",40,0)
 N LASTTIME,SET
"RTN","HLOCLNT",41,0)
 S LINK("DOWN")=0
"RTN","HLOCLNT",42,0)
 S LASTTIME=$G(^HLB("QUEUE","OUT",LINK))
"RTN","HLOCLNT",43,0)
 S SET=$S(LASTTIME]"":1,1:0)
"RTN","HLOCLNT",44,0)
 I SET D
"RTN","HLOCLNT",45,0)
 .I $$HDIFF^XLFDT($H,LASTTIME,2)>30 S ^HLB("QUEUE","OUT",LINK)="",SET=0,LINK("DOWN")=1
"RTN","HLOCLNT",46,0)
 I $D(^HLTMP("FAILING LINKS",LINK)) S LINK("DOWN")=1
"RTN","HLOCLNT",47,0)
 Q SET
"RTN","HLOCLNT",48,0)
 ;
"RTN","HLOCLNT",49,0)
LINKDOWN(HLCSTATE) ;
"RTN","HLOCLNT",50,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",51,0)
 I $D(HLCSTATE("LINK","NAME")),$D(HLCSTATE("LINK","PORT")) D
"RTN","HLOCLNT",52,0)
 .S TO=HLCSTATE("LINK","NAME")_":"_HLCSTATE("LINK","PORT")
"RTN","HLOCLNT",53,0)
 .S ^HLB("QUEUE","OUT",TO)=$H
"RTN","HLOCLNT",54,0)
 .S:'$D(^HLTMP("FAILING LINKS",TO)) ^HLTMP("FAILING LINKS",TO)=$H
"RTN","HLOCLNT",55,0)
 Q
"RTN","HLOCLNT",56,0)
 ;
"RTN","HLOCLNT",57,0)
ERROR ;error trap
"RTN","HLOCLNT",58,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOCLNT",59,0)
 D DEQUE()
"RTN","HLOCLNT",60,0)
 D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",61,0)
 ;
"RTN","HLOCLNT",62,0)
 ;while debugging quit on all errors - this will return the process to the Process Manager error trap
"RTN","HLOCLNT",63,0)
 I $G(^HLTMP("LOG ALL ERRORS")) QUIT
"RTN","HLOCLNT",64,0)
 ;
"RTN","HLOCLNT",65,0)
 ;don't log some common errors
"RTN","HLOCLNT",66,0)
 I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D
"RTN","HLOCLNT",67,0)
 .;
"RTN","HLOCLNT",68,0)
 E  D
"RTN","HLOCLNT",69,0)
 .D ^%ZTER
"RTN","HLOCLNT",70,0)
 ;
"RTN","HLOCLNT",71,0)
 ;a lot of errors of the same type may indicate an endless loop, so keep a count
"RTN","HLOCLNT",72,0)
 S ^TMP("HL7 ERRORS",$J,$ECODE)=$G(^TMP("HL7 ERRORS",$J,$ECODE))+1
"RTN","HLOCLNT",73,0)
 ;
"RTN","HLOCLNT",74,0)
 QUIT:($G(^TMP("HL7 ERRORS",$J,$ECODE))>100)  ;return to the Process Manager error trap
"RTN","HLOCLNT",75,0)
 D UNWIND^%ZTER
"RTN","HLOCLNT",76,0)
 Q
"RTN","HLOCLNT",77,0)
 ;
"RTN","HLOCLNT",78,0)
DOWORK(QUEUE) ;sends the messages on the queue
"RTN","HLOCLNT",79,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOCLNT"
"RTN","HLOCLNT",80,0)
 N MSGIEN,DEQUE,SUCCESS,MSGCOUNT
"RTN","HLOCLNT",81,0)
 S DEQUE=0
"RTN","HLOCLNT",82,0)
 S SUCCESS=1
"RTN","HLOCLNT",83,0)
 I '$$CNNCTD(QUEUE("LINK")),'$$CONNECT^HLOCLNT1($P(QUEUE("LINK"),":"),$P(QUEUE("LINK"),":",2),.HLCSTATE) Q
"RTN","HLOCLNT",84,0)
 ;
"RTN","HLOCLNT",85,0)
 S (MSGCOUNT,MSGIEN)=0
"RTN","HLOCLNT",86,0)
 F  S MSGIEN=$O(^HLB("QUEUE","OUT",QUEUE("LINK"),QUEUE("QUEUE"),MSGIEN)) Q:'MSGIEN  D  Q:'SUCCESS  Q:MSGCOUNT>1000
"RTN","HLOCLNT",87,0)
 .N UPDATE
"RTN","HLOCLNT",88,0)
 .I $$INC^HLOSITE($NA(^HLB(MSGIEN,"TRIES"))) S SUCCESS=0
"RTN","HLOCLNT",89,0)
 .S:$$TRANSMIT(.HLCSTATE,MSGIEN,.UPDATE) SUCCESS=1
"RTN","HLOCLNT",90,0)
 .Q:'SUCCESS
"RTN","HLOCLNT",91,0)
 .D DEQUE(.UPDATE)
"RTN","HLOCLNT",92,0)
 .S MSGCOUNT=MSGCOUNT+1
"RTN","HLOCLNT",93,0)
 .;
"RTN","HLOCLNT",94,0)
 .;if the queue was on the down list, mark it as up, since a message has been successfully transmitted across it
"RTN","HLOCLNT",95,0)
 .I $G(QUEUE("DOWN"))!$$FAILING(QUEUE("LINK")) S QUEUE("DOWN")=0,^HLB("QUEUE","OUT",QUEUE("LINK"))="" K ^HLTMP("FAILING LINKS",QUEUE("LINK"))
"RTN","HLOCLNT",96,0)
 ;
"RTN","HLOCLNT",97,0)
 D DEQUE()
"RTN","HLOCLNT",98,0)
 Q
"RTN","HLOCLNT",99,0)
CNNCTD(LINK) ;
"RTN","HLOCLNT",100,0)
 ;Connected to LINK?  HLCSTATE must be defined, LINK=<link name>:<port>
"RTN","HLOCLNT",101,0)
 ;
"RTN","HLOCLNT",102,0)
 I ($G(HLCSTATE("LINK","NAME"))=$P(LINK,":")),($G(HLCSTATE("LINK","PORT"))=$P(LINK,":",2)),$G(HLCSTATE("CONNECTED")) Q 1
"RTN","HLOCLNT",103,0)
 Q 0
"RTN","HLOCLNT",104,0)
 ;
"RTN","HLOCLNT",105,0)
DEQUE(UPDATE) ;
"RTN","HLOCLNT",106,0)
 I $D(UPDATE) S DEQUE=DEQUE+1,DEQUE(+UPDATE)=$P(UPDATE,"^",2,99) S:$G(UPDATE("MSA"))]"" DEQUE(+UPDATE,"MSA")=UPDATE("MSA") S:$G(UPDATE("ACTION"))]"" DEQUE(+UPDATE,"ACTION")=UPDATE("ACTION")
"RTN","HLOCLNT",107,0)
 I '$D(UPDATE)!(DEQUE>15) D
"RTN","HLOCLNT",108,0)
 .N MSGIEN S MSGIEN=0
"RTN","HLOCLNT",109,0)
 .F  S MSGIEN=$O(DEQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOCLNT",110,0)
 ..N NODE,TIME
"RTN","HLOCLNT",111,0)
 ..D DEQUE^HLOQUE(QUEUE("LINK"),QUEUE("QUEUE"),"OUT",MSGIEN)
"RTN","HLOCLNT",112,0)
 ..S TIME=$P(DEQUE(MSGIEN),"^")
"RTN","HLOCLNT",113,0)
 ..S NODE=QUEUE("LINK")_"^"_QUEUE("QUEUE")_"^"_$P(DEQUE(MSGIEN),"^",2,99)
"RTN","HLOCLNT",114,0)
 ..S ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN)=NODE
"RTN","HLOCLNT",115,0)
 ..S:$G(DEQUE(MSGIEN,"MSA"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"MSA")=DEQUE(MSGIEN,"MSA")
"RTN","HLOCLNT",116,0)
 ..S:$G(DEQUE(MSGIEN,"ACTION"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"ACTION")=DEQUE(MSGIEN,"ACTION")
"RTN","HLOCLNT",117,0)
 .K DEQUE S DEQUE=0
"RTN","HLOCLNT",118,0)
 Q
"RTN","HLOCLNT",119,0)
 ;
"RTN","HLOCLNT",120,0)
TRANSMIT(HLCSTATE,MSGIEN,UPDATE) ;
"RTN","HLOCLNT",121,0)
 ;Transmits a single message and if a commit ack was requested reads it.  Updates file 778 with the result.  Queues for the infiler the application accept action if one was requested.
"RTN","HLOCLNT",122,0)
 ;Input:
"RTN","HLOCLNT",123,0)
 ;   HLCSTATE (pass by reference)
"RTN","HLOCLNT",124,0)
 ;   MSGIEN - ien, file 778, of message to be transmitted
"RTN","HLOCLNT",125,0)
 ;Output:
"RTN","HLOCLNT",126,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT",127,0)
 ;  UPDATE - (pass by reference) to contain updates needed for message
"RTN","HLOCLNT",128,0)
 ;
"RTN","HLOCLNT",129,0)
 N HLMSTATE,MSA,HDR,SUCCESS
"RTN","HLOCLNT",130,0)
 ;get the message that is to be sent
"RTN","HLOCLNT",131,0)
 S UPDATE=MSGIEN_"^"_$$NOW^XLFDT
"RTN","HLOCLNT",132,0)
 ;
"RTN","HLOCLNT",133,0)
 S SUCCESS=0
"RTN","HLOCLNT",134,0)
 S HLCSTATE("ATTEMPT")=0
"RTN","HLOCLNT",135,0)
RETRY ;
"RTN","HLOCLNT",136,0)
 S HLCSTATE("ATTEMPT")=HLCSTATE("ATTEMPT")+1
"RTN","HLOCLNT",137,0)
 I ('HLCSTATE("CONNECTED"))!(HLCSTATE("ATTEMPT")>1) G GIVEUP
"RTN","HLOCLNT",138,0)
 ;
"RTN","HLOCLNT",139,0)
 Q:'$$GETMSG(MSGIEN,.HLMSTATE) 1  ;returns 1 so the message will be removed from the queue
"RTN","HLOCLNT",140,0)
 I HLMSTATE("DT/TM"),HLMSTATE("STATUS","ACCEPTED")!(HLMSTATE("HDR","ACCEPT ACK TYPE")="NE") Q 1
"RTN","HLOCLNT",141,0)
 ;
"RTN","HLOCLNT",142,0)
 ;try to send the message
"RTN","HLOCLNT",143,0)
 Q:'$$WRITEMSG^HLOCLNT1(.HLCSTATE,.HLMSTATE) 0
"RTN","HLOCLNT",144,0)
 ;does the message need an accept ack?
"RTN","HLOCLNT",145,0)
 I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" D  G:'SUCCESS RETRY
"RTN","HLOCLNT",146,0)
 .N FS
"RTN","HLOCLNT",147,0)
READACK .;GOTO within a inside dotted DO is on purpose - if the read of ack fails, it will try again, discarding whatever was received.  The remote server must follow the protocol. 
"RTN","HLOCLNT",148,0)
 .Q:'$$READACK^HLOCLNT1(.HLCSTATE,.HDR,.MSA)
"RTN","HLOCLNT",149,0)
 .;does the MSA refer to the correct control id?
"RTN","HLOCLNT",150,0)
 .S FS=$E(HDR(1),4)
"RTN","HLOCLNT",151,0)
 .I $P(MSA,FS,3)'=$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID")) G READACK
"RTN","HLOCLNT",152,0)
 .N ACKID,ACKCODE
"RTN","HLOCLNT",153,0)
 .S ACKCODE=$P(MSA,FS,2)
"RTN","HLOCLNT",154,0)
 .S ACKID=$S($E(HDR(1),1,3)="MSH":$P(HDR(2),FS,5),1:$P(HDR(2),FS,6))
"RTN","HLOCLNT",155,0)
 .S $P(UPDATE,"^",5)=1
"RTN","HLOCLNT",156,0)
 .S UPDATE("MSA")=ACKID_"^"_MSA
"RTN","HLOCLNT",157,0)
 .I '(ACKCODE="CA") S $P(UPDATE,"^",3)="SE",$P(UPDATE,"^",4)=2
"RTN","HLOCLNT",158,0)
 .I ACKCODE="CA",HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=$S(HLMSTATE("BATCH"):"2",1:1)
"RTN","HLOCLNT",159,0)
 .I ($P(UPDATE,"^",3)="SE") S $P(UPDATE,"^",6)=$P(HLMSTATE("HDR",1),FS,5) ;errors need the application for xref
"RTN","HLOCLNT",160,0)
 .;
"RTN","HLOCLNT",161,0)
 .;did the app request notification of accept ack?
"RTN","HLOCLNT",162,0)
 .S UPDATE("ACTION")=HLMSTATE("ACCEPT ACK RESPONSE")
"RTN","HLOCLNT",163,0)
 .S SUCCESS=1
"RTN","HLOCLNT",164,0)
 E  D  ;accept ack wasn't requested
"RTN","HLOCLNT",165,0)
 .S SUCCESS=1
"RTN","HLOCLNT",166,0)
 .I HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=$S(HLMSTATE("BATCH"):2,1:1)
"RTN","HLOCLNT",167,0)
 ;
"RTN","HLOCLNT",168,0)
 G:'SUCCESS RETRY ;only executes if reading the ack failed
"RTN","HLOCLNT",169,0)
 ;
"RTN","HLOCLNT",170,0)
GIVEUP ;
"RTN","HLOCLNT",171,0)
 I ('HLCSTATE("CONNECTED"))!('SUCCESS) D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",172,0)
 Q SUCCESS
"RTN","HLOCLNT",173,0)
 ;
"RTN","HLOCLNT",174,0)
GETMSG(IEN,MSG) ;
"RTN","HLOCLNT",175,0)
 ;Description: given the message ien=MSGIEN (required), it returns the MSG array containing information about the message, defined below.
"RTN","HLOCLNT",176,0)
 ;Input:
"RTN","HLOCLNT",177,0)
 ;  IEN - the ien of the message in file 778
"RTN","HLOCLNT",178,0)
 ;Output:
"RTN","HLOCLNT",179,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT",180,0)
 ;  MSG (pass by reference, required) These are the subscripts returned:
"RTN","HLOCLNT",181,0)
 ;    "BATCH"  = 1 if this is a batch message, 0  if not
"RTN","HLOCLNT",182,0)
 ;       "CURRENT MESSAGE" - defined only for batch messages -  a counter used during building and parsing messages to indicate the current message.  It will be set to 0 initially.
"RTN","HLOCLNT",183,0)
 ;   "BODY" - ptr to file 778 which contains the body of the message.
"RTN","HLOCLNT",184,0)
 ;   "ACCEPT ACK RESPONSE" - if the sending app requested notification of the accept ack, this is the routine to perform
"RTN","HLOCLNT",185,0)
 ;   "LINE COUNT" -  a counter used during writing of the
"RTN","HLOCLNT",186,0)
 ;     messages to indicate the current line. For
"RTN","HLOCLNT",187,0)
 ;     batch messages where each message within the batch is stored
"RTN","HLOCLNT",188,0)
 ;     separately, this field indicates the position within the current
"RTN","HLOCLNT",189,0)
 ;     individual message
"RTN","HLOCLNT",190,0)
 ;   "HDR" at these lower subscripts:
"RTN","HLOCLNT",191,0)
 ;       1    - components 1-6
"RTN","HLOCLNT",192,0)
 ;       2    - components 7-end
"RTN","HLOCLNT",193,0)
 ;       "ACCEPT ACK TYPE" = "AL" or "NE"
"RTN","HLOCLNT",194,0)
 ;       "APP ACK TYPE" = "AL" or "NE"
"RTN","HLOCLNT",195,0)
 ;       "MESSAGE CONTROL ID" - defined if NOT batch
"RTN","HLOCLNT",196,0)
 ;       "BATCH CONTROL ID" - defined if batch
"RTN","HLOCLNT",197,0)
 ;
"RTN","HLOCLNT",198,0)
 ;
"RTN","HLOCLNT",199,0)
 ;   "IEN" - ien, file 778
"RTN","HLOCLNT",200,0)
 ;
"RTN","HLOCLNT",201,0)
 K MSG
"RTN","HLOCLNT",202,0)
 Q:'$G(IEN) 0
"RTN","HLOCLNT",203,0)
 N NODE,FS
"RTN","HLOCLNT",204,0)
 S MSG("IEN")=IEN
"RTN","HLOCLNT",205,0)
 S NODE=$G(^HLB(IEN,0))
"RTN","HLOCLNT",206,0)
 S MSG("BODY")=$P(NODE,"^",2)
"RTN","HLOCLNT",207,0)
 Q:'MSG("BODY") 0
"RTN","HLOCLNT",208,0)
 S MSG("STATUS","ACCEPTED")=$P(NODE,"^",17)
"RTN","HLOCLNT",209,0)
 S MSG("DT/TM")=$P(NODE,"^",16)
"RTN","HLOCLNT",210,0)
 S MSG("STATUS","QUEUE")=$P(NODE,"^",6)
"RTN","HLOCLNT",211,0)
 I MSG("STATUS","QUEUE")="" S MSG("STATUS","QUEUE")="DEFAULT"
"RTN","HLOCLNT",212,0)
 S MSG("ACCEPT ACK RESPONSE")=$P(NODE,"^",12,13)
"RTN","HLOCLNT",213,0)
 I MSG("ACCEPT ACK RESPONSE")="^" S MSG("ACCEPT ACK RESPONSE")=""
"RTN","HLOCLNT",214,0)
 ;
"RTN","HLOCLNT",215,0)
 S MSG("BATCH")=+$P($G(^HLA(MSG("BODY"),0)),"^",2)
"RTN","HLOCLNT",216,0)
 I MSG("BATCH") S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOCLNT",217,0)
 S MSG("LINE COUNT")=0
"RTN","HLOCLNT",218,0)
 S MSG("HDR",1)=$G(^HLB(IEN,1))
"RTN","HLOCLNT",219,0)
 S MSG("HDR",2)=$G(^HLB(IEN,2))
"RTN","HLOCLNT",220,0)
 S FS=$E(MSG("HDR",1),4)
"RTN","HLOCLNT",221,0)
 S MSG("HDR","FIELD SEPARATOR")=FS
"RTN","HLOCLNT",222,0)
 I 'MSG("BATCH") D
"RTN","HLOCLNT",223,0)
 .S MSG("HDR","ACCEPT ACK TYPE")=$E($P(MSG("HDR",2),FS,10),1,2)
"RTN","HLOCLNT",224,0)
 .S MSG("HDR","APP ACK TYPE")=$E($P(MSG("HDR",2),FS,11),1,2)
"RTN","HLOCLNT",225,0)
 .S MSG("HDR","MESSAGE CONTROL ID")=$P(MSG("HDR",2),FS,5)
"RTN","HLOCLNT",226,0)
 E  D
"RTN","HLOCLNT",227,0)
 .S MSG("HDR","BATCH CONTROL ID")=$P(MSG("HDR",2),FS,6)
"RTN","HLOCLNT",228,0)
 .S MSG("HDR","ACCEPT ACK TYPE")=$E($P($P(MSG("HDR",2),FS,4),"ACCEPT ACK TYPE=",2),1,2)
"RTN","HLOCLNT",229,0)
 .S MSG("HDR","APP ACK TYPE")=$E($P($P(MSG("HDR",2),FS,4),"APP ACK TYPE=",2),1,2)
"RTN","HLOCLNT",230,0)
 Q 1
"RTN","HLOCLNT1")
0^9^B25822354
"RTN","HLOCLNT1",1,0)
HLOCLNT1 ;IRMFO-ALB/CJM - Writing messages, reading acks;03/24/2004  14:43
"RTN","HLOCLNT1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOCLNT1",3,0)
 ;
"RTN","HLOCLNT1",4,0)
 ;
"RTN","HLOCLNT1",5,0)
WRITEMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOCLNT1",6,0)
 ;Description:  This function uses the services offered by the transport layer to send a message over an open communication channel.
"RTN","HLOCLNT1",7,0)
 ;
"RTN","HLOCLNT1",8,0)
 ;Input:
"RTN","HLOCLNT1",9,0)
 ;  HLCSTATE (pass by reference, required) Defines the communication channel and its state.
"RTN","HLOCLNT1",10,0)
 ;  HLMSTATE (pass by reference, required) Defines the message and its state.
"RTN","HLOCLNT1",11,0)
 ;Output:
"RTN","HLOCLNT1",12,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT1",13,0)
 ;
"RTN","HLOCLNT1",14,0)
 N SEG,QUIT,HDR
"RTN","HLOCLNT1",15,0)
 S QUIT=0
"RTN","HLOCLNT1",16,0)
 Q:'$G(HLMSTATE("IEN")) 0
"RTN","HLOCLNT1",17,0)
 S HDR(1)=HLMSTATE("HDR",1),HDR(2)=HLMSTATE("HDR",2)
"RTN","HLOCLNT1",18,0)
 Q:'$$WRITEHDR^HLOT(.HLCSTATE,.HDR) 0
"RTN","HLOCLNT1",19,0)
 I HLMSTATE("BATCH") D
"RTN","HLOCLNT1",20,0)
 .N LAST S LAST=0
"RTN","HLOCLNT1",21,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0
"RTN","HLOCLNT1",22,0)
 .F  Q:'$$NEXTMSG^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",23,0)
 ..S LAST=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOCLNT1",24,0)
 ..I '$$WRITESEG^HLOT(.HLCSTATE,.SEG) S QUIT=1 Q
"RTN","HLOCLNT1",25,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",26,0)
 ...I '$$WRITESEG^HLOT(.HLCSTATE,.SEG) S QUIT=1 Q
"RTN","HLOCLNT1",27,0)
 .K SEG S SEG(1)="BTS"_HLMSTATE("HDR","FIELD SEPARATOR")_LAST
"RTN","HLOCLNT1",28,0)
 .S:'$$WRITESEG^HLOT(.HLCSTATE,.SEG) QUIT=1
"RTN","HLOCLNT1",29,0)
 E  D
"RTN","HLOCLNT1",30,0)
 .F  Q:'$$HLNEXT^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",31,0)
 ..S:'$$WRITESEG^HLOT(.HLCSTATE,.SEG) QUIT=1
"RTN","HLOCLNT1",32,0)
 S:'$$ENDMSG^HLOT(.HLCSTATE) QUIT=1
"RTN","HLOCLNT1",33,0)
 Q 'QUIT
"RTN","HLOCLNT1",34,0)
 ;
"RTN","HLOCLNT1",35,0)
READACK(HLCSTATE,HDR,MSA) ;
"RTN","HLOCLNT1",36,0)
 ;Description:  This function uses the services offered by the transport layer to read an accept ack.
"RTN","HLOCLNT1",37,0)
 ;
"RTN","HLOCLNT1",38,0)
 ;Input:
"RTN","HLOCLNT1",39,0)
 ;  HLCSTATE (pass by reference, required) Defines the communication channel and its state.
"RTN","HLOCLNT1",40,0)
 ;Output:
"RTN","HLOCLNT1",41,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT1",42,0)
 ;  HDR (pass by reference) the message header:
"RTN","HLOCLNT1",43,0)
 ;   HDR(1) is components 1-6
"RTN","HLOCLNT1",44,0)
 ;   HDR(2) is components 7-end
"RTN","HLOCLNT1",45,0)
 ;  MSA (pass by reference) the MSA segment as an unsubscripted variable
"RTN","HLOCLNT1",46,0)
 ;
"RTN","HLOCLNT1",47,0)
 N SEG
"RTN","HLOCLNT1",48,0)
 K HDR,MSA,MAX,I
"RTN","HLOCLNT1",49,0)
 S MAX=HLCSTATE("SYSTEM","MAXSTRING")-40 ;MAX is the maximum that can be safely stored on a node, leaving room for the other fields stored with MSA seg
"RTN","HLOCLNT1",50,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.HDR) 0
"RTN","HLOCLNT1",51,0)
 F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOCLNT1",52,0)
 .I $E($E(SEG(1),1,3)_$E($G(SEG(2)),1,3),1,3)="MSA" D
"RTN","HLOCLNT1",53,0)
 ..S MSA=""
"RTN","HLOCLNT1",54,0)
 ..F I=1:1 Q:'$D(SEG(I))  S MSA=MSA_$S((MAX-$L(MSA))<1:"",1:$E(SEG(I),1,MAX))
"RTN","HLOCLNT1",55,0)
 I $D(MSA),HLCSTATE("MESSAGE ENDED") D SPLITHDR^HLOSRVR1(.HDR) Q 1
"RTN","HLOCLNT1",56,0)
 Q 0
"RTN","HLOCLNT1",57,0)
 ;
"RTN","HLOCLNT1",58,0)
CONNECT(LINK,PORT,HLCSTATE) ;
"RTN","HLOCLNT1",59,0)
 ;sets up HLCSTATE() and opens a client connection
"RTN","HLOCLNT1",60,0)
 ;Input:
"RTN","HLOCLNT1",61,0)
 ;  LINK - name of the link to connect to
"RTN","HLOCLNT1",62,0)
 ;  PORT - port # to connect to (optional)
"RTN","HLOCLNT1",63,0)
 ;Output:
"RTN","HLOCLNT1",64,0)
 ;   HLCSTATE - array to hold the connection state
"RTN","HLOCLNT1",65,0)
 ;
"RTN","HLOCLNT1",66,0)
 I $G(HLCSTATE("CONNECTED")) D  Q:$G(HLCSTATE("CONNECTED"))
"RTN","HLOCLNT1",67,0)
 .I $G(HLCSTATE("LINK","NAME"))]"",($G(HLCSTATE("LINK","NAME"))'=LINK) D CLOSE^HLOT(.HLCSTATE) Q
"RTN","HLOCLNT1",68,0)
 .I $G(HLCSTATE("LINK","NAME"))]"",$G(PORT),($G(HLCSTATE("LINK","PORT"))'=PORT) D CLOSE^HLOT(.HLCSTATE) Q
"RTN","HLOCLNT1",69,0)
 .I (HLCSTATE("SYSTEM","OS")="CACHE") D  Q
"RTN","HLOCLNT1",70,0)
 ..S HLCSTATE("CONNECTED")=($ZA\8192#2)
"RTN","HLOCLNT1",71,0)
 ..I 'HLCSTATE("CONNECTED") D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",72,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",73,0)
 K HLCSTATE
"RTN","HLOCLNT1",74,0)
 N ARY,NODE
"RTN","HLOCLNT1",75,0)
 I '$$GETLINK^HLOTLNK(LINK,.ARY) S HLCSTATE("LINK","NAME")=LINK,HLCSTATE("LINK","PORT")=$G(PORT) D LINKDOWN^HLOCLNT(.HLCSTATE) Q 0
"RTN","HLOCLNT1",76,0)
 M HLCSTATE("LINK")=ARY
"RTN","HLOCLNT1",77,0)
 ;overlay the port if supplied from the queue
"RTN","HLOCLNT1",78,0)
 S:$G(PORT) HLCSTATE("LINK","PORT")=PORT
"RTN","HLOCLNT1",79,0)
 S HLCSTATE("ATTEMPT")=0
"RTN","HLOCLNT1",80,0)
 S HLCSTATE("READ")="" ;where the reads are stored
"RTN","HLOCLNT1",81,0)
 ;
"RTN","HLOCLNT1",82,0)
 ;HLCSTATE("BUFFER",<seg>,<line>) serves as a write buffer so that a lot can be written all at once
"RTN","HLOCLNT1",83,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of BYTES in buffer
"RTN","HLOCLNT1",84,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOCLNT1",85,0)
 ;
"RTN","HLOCLNT1",86,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOCLNT1",87,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOCLNT1",88,0)
 S HLCSTATE("SERVER")=0
"RTN","HLOCLNT1",89,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOCLNT1",90,0)
 I HLCSTATE("SYSTEM","OS")="" D LINKDOWN^HLOCLNT(.HLCSTATE) Q 0
"RTN","HLOCLNT1",91,0)
 D
"RTN","HLOCLNT1",92,0)
 .N SYS
"RTN","HLOCLNT1",93,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOCLNT1",94,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOCLNT1",95,0)
 .S HLCSTATE("SYSTEM","MAXSTRING")=SYS("MAXSTRING")
"RTN","HLOCLNT1",96,0)
 .S HLCSTATE("SYSTEM","NORMAL PURGE")=SYS("NORMAL PURGE")
"RTN","HLOCLNT1",97,0)
 .S HLCSTATE("SYSTEM","ERROR PURGE")=SYS("ERROR PURGE")
"RTN","HLOCLNT1",98,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOCLNT1",99,0)
 .D OPEN^HLOTCP(.HLCSTATE)
"RTN","HLOCLNT1",100,0)
 E  I HLCSTATE("LINK","LLP")="HLLP" D  ;serial
"RTN","HLOCLNT1",101,0)
 .;implementation of serial LLP has been deferred
"RTN","HLOCLNT1",102,0)
 ;
"RTN","HLOCLNT1",103,0)
 ;mark the failure time for the link so other processes know not to try for a while
"RTN","HLOCLNT1",104,0)
 I 'HLCSTATE("CONNECTED") D LINKDOWN^HLOCLNT(.HLCSTATE)
"RTN","HLOCLNT1",105,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOCLNT1",106,0)
 ;
"RTN","HLOCLNT1",107,0)
BADMSGS(WORK) ;
"RTN","HLOCLNT1",108,0)
 ;finds messages that won't transmit and takes them off the outgoing queue
"RTN","HLOCLNT1",109,0)
 N LINK
"RTN","HLOCLNT1",110,0)
 S LINK=""
"RTN","HLOCLNT1",111,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D
"RTN","HLOCLNT1",112,0)
 .N TIME,QUE,COUNT
"RTN","HLOCLNT1",113,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOCLNT1",114,0)
 .Q:$$HDIFF^XLFDT($H,TIME,2)<7200
"RTN","HLOCLNT1",115,0)
 .Q:'$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOCLNT1",116,0)
 .L +^HLB("QUEUE","OUT",LINK):0
"RTN","HLOCLNT1",117,0)
 .S QUE=""
"RTN","HLOCLNT1",118,0)
 .F  S QUE=$O(^HLB("QUEUE","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOCLNT1",119,0)
 ..N MSG S MSG=0
"RTN","HLOCLNT1",120,0)
 ..S MSG=$O(^HLB("QUEUE","OUT",LINK,QUE,MSG))
"RTN","HLOCLNT1",121,0)
 ..Q:'MSG
"RTN","HLOCLNT1",122,0)
 ..S COUNT=$G(^HLB(MSG,"TRIES"))
"RTN","HLOCLNT1",123,0)
 ..I COUNT>20 D
"RTN","HLOCLNT1",124,0)
 ...N NODE,TIME,APP,FS,ACTION
"RTN","HLOCLNT1",125,0)
 ...S NODE=$G(^HLB(MSG,0))
"RTN","HLOCLNT1",126,0)
 ...Q:'$P(NODE,"^",2)
"RTN","HLOCLNT1",127,0)
 ...S TIME=+$G(^HLA($P(NODE,"^",2),0))
"RTN","HLOCLNT1",128,0)
 ...S NODE=$G(^HLB(MSG,1))
"RTN","HLOCLNT1",129,0)
 ...S FS=$E(NODE,4)
"RTN","HLOCLNT1",130,0)
 ...Q:FS=""
"RTN","HLOCLNT1",131,0)
 ...S APP=$P(NODE,FS,3)
"RTN","HLOCLNT1",132,0)
 ...Q:APP=""
"RTN","HLOCLNT1",133,0)
 ...S $P(^HLB(MSG,0),"^",21)=COUNT_" FAILED TRANSMISSIONS"
"RTN","HLOCLNT1",134,0)
 ...S $P(^HLB(MSG,0),"^",20)="TF"
"RTN","HLOCLNT1",135,0)
 ...S ^HLB("ERRORS","TF",APP,TIME,MSG)=""
"RTN","HLOCLNT1",136,0)
 ...S ACTION=$P(NODE,"^",14,15)
"RTN","HLOCLNT1",137,0)
 ...I ACTION'="^",ACTION]"" D INQUE^HLOQUE(LINK,QUE,MSG,ACTION,1)
"RTN","HLOCLNT1",138,0)
 ...D DEQUE^HLOQUE(LINK,QUE,"OUT",MSG)
"RTN","HLOCLNT1",139,0)
 .L -^HLB("QUEUE","OUT",LINK)
"RTN","HLOCLNT1",140,0)
 Q
"RTN","HLOCLNT2")
0^10^B12124771
"RTN","HLOCLNT2",1,0)
HLOCLNT2 ;ALB/CJM- Performs message updates for the client - 10/4/94 1pm
"RTN","HLOCLNT2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOCLNT2",3,0)
 ;
"RTN","HLOCLNT2",4,0)
GETWORK(WORK) ;
"RTN","HLOCLNT2",5,0)
 ;
"RTN","HLOCLNT2",6,0)
 N OLD,DOLLARJ,SUCCESS,NOW
"RTN","HLOCLNT2",7,0)
 S SUCCESS=0
"RTN","HLOCLNT2",8,0)
 S NOW=$$NOW^XLFDT
"RTN","HLOCLNT2",9,0)
 S (OLD,DOLLARJ)=$G(WORK("DOLLARJ"))
"RTN","HLOCLNT2",10,0)
 F  S DOLLARJ=$O(^HLTMP("CLIENT UPDATES",DOLLARJ)) Q:DOLLARJ=""  D  Q:SUCCESS
"RTN","HLOCLNT2",11,0)
 .L +^HLTMP("CLIENT UPDATES",DOLLARJ):0
"RTN","HLOCLNT2",12,0)
 .Q:'$T
"RTN","HLOCLNT2",13,0)
 .N TIME S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,""))
"RTN","HLOCLNT2",14,0)
 .I $$FMDIFF^XLFDT(NOW,TIME,2)<2 L -^HLTMP("CLIENT UPDATES",DOLLARJ) Q
"RTN","HLOCLNT2",15,0)
 .S SUCCESS=1
"RTN","HLOCLNT2",16,0)
 ;
"RTN","HLOCLNT2",17,0)
 I OLD'="",'SUCCESS F  S DOLLARJ=$O(^HLTMP("CLIENT UPDATES",DOLLARJ)) Q:DOLLARJ=""  Q:DOLLARJ>OLD  D  Q:SUCCESS
"RTN","HLOCLNT2",18,0)
 .L +^HLTMP("CLIENT UPDATES",DOLLARJ):0
"RTN","HLOCLNT2",19,0)
 .Q:'$T
"RTN","HLOCLNT2",20,0)
 .N TIME S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,""))
"RTN","HLOCLNT2",21,0)
 .I $$FMDIFF^XLFDT(NOW,TIME,2)<2 L -^HLTMP("CLIENT UPDATES",DOLLARJ) Q
"RTN","HLOCLNT2",22,0)
 .S SUCCESS=1
"RTN","HLOCLNT2",23,0)
 S WORK("DOLLARJ")=DOLLARJ,WORK("NOW")=NOW
"RTN","HLOCLNT2",24,0)
 Q $S($L(WORK("DOLLARJ")):1,1:0)
"RTN","HLOCLNT2",25,0)
 ;
"RTN","HLOCLNT2",26,0)
DOWORK(WORK) ;
"RTN","HLOCLNT2",27,0)
 ;
"RTN","HLOCLNT2",28,0)
 N DOLLARJ,TIME,IEN,PARMS,SYSTEM
"RTN","HLOCLNT2",29,0)
 S TIME=""
"RTN","HLOCLNT2",30,0)
 S DOLLARJ=WORK("DOLLARJ")
"RTN","HLOCLNT2",31,0)
 D SYSPARMS^HLOSITE(.SYSTEM)
"RTN","HLOCLNT2",32,0)
 F  S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME)) Q:TIME=""  Q:$$FMDIFF^XLFDT(WORK("NOW"),TIME,2)<2  D
"RTN","HLOCLNT2",33,0)
 .S IEN=0
"RTN","HLOCLNT2",34,0)
 .F  S IEN=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN)) Q:'IEN  D
"RTN","HLOCLNT2",35,0)
 ..N NODE
"RTN","HLOCLNT2",36,0)
 ..S NODE=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN))
"RTN","HLOCLNT2",37,0)
 ..S PARMS("LINK")=$P(NODE,"^")
"RTN","HLOCLNT2",38,0)
 ..S PARMS("QUEUE")=$P(NODE,"^",2)
"RTN","HLOCLNT2",39,0)
 ..S PARMS("STATUS")=$P(NODE,"^",3)
"RTN","HLOCLNT2",40,0)
 ..S PARMS("PURGE TYPE")=$P(NODE,"^",4)
"RTN","HLOCLNT2",41,0)
 ..S PARMS("ACCEPT ACK")=$P(NODE,"^",5)
"RTN","HLOCLNT2",42,0)
 ..S PARMS("RECEIVING APP")=$P(NODE,"^",6)
"RTN","HLOCLNT2",43,0)
 ..S:PARMS("RECEIVING APP")="" PARMS("RECEIVING APP")="UNKNOWN RECEIVING APPLICATION"
"RTN","HLOCLNT2",44,0)
 ..S PARMS("MSA")=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN,"MSA"))
"RTN","HLOCLNT2",45,0)
 ..S PARMS("ACTION")=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN,"ACTION"))
"RTN","HLOCLNT2",46,0)
 ..D UPDATE(IEN,TIME,.PARMS)
"RTN","HLOCLNT2",47,0)
 ..K ^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN)
"RTN","HLOCLNT2",48,0)
 L -^HLTMP("CLIENT UPDATES",DOLLARJ)
"RTN","HLOCLNT2",49,0)
 Q
"RTN","HLOCLNT2",50,0)
 ;
"RTN","HLOCLNT2",51,0)
UPDATE(MSGIEN,TIME,PARMS) ;
"RTN","HLOCLNT2",52,0)
 S:PARMS("STATUS")]"" $P(^HLB(MSGIEN,0),"^",20)=PARMS("STATUS")
"RTN","HLOCLNT2",53,0)
 S:PARMS("STATUS")="SE" ^HLB("ERRORS","SE",PARMS("RECEIVING APP"),TIME,MSGIEN)=""
"RTN","HLOCLNT2",54,0)
 S:PARMS("STATUS")="AE" ^HLB("ERRORS","AE",PARMS("RECEIVING APP"),TIME,MSGIEN_"^")=""
"RTN","HLOCLNT2",55,0)
 S:PARMS("ACCEPT ACK") $P(^HLB(MSGIEN,0),"^",17)=PARMS("ACCEPT ACK")
"RTN","HLOCLNT2",56,0)
 S $P(^HLB(MSGIEN,0),"^",16)=TIME
"RTN","HLOCLNT2",57,0)
 S:PARMS("MSA")]"" ^HLB(MSGIEN,4)=TIME_"^"_PARMS("MSA")
"RTN","HLOCLNT2",58,0)
 I PARMS("PURGE TYPE"),PARMS("ACTION")="" D
"RTN","HLOCLNT2",59,0)
 .;don't set purge if going on the infiler - let infiler do it
"RTN","HLOCLNT2",60,0)
 .N PTIME
"RTN","HLOCLNT2",61,0)
 .S:(PARMS("PURGE TYPE")=2) PTIME=$$FMADD^XLFDT(TIME,SYSTEM("ERROR PURGE")) ;error purge is in days
"RTN","HLOCLNT2",62,0)
 .S:(PARMS("PURGE TYPE")'=2) PTIME=$$FMADD^XLFDT(TIME,,SYSTEM("NORMAL PURGE")) ;normal purge is in hours
"RTN","HLOCLNT2",63,0)
 .S $P(^HLB(MSGIEN,0),"^",9)=PTIME,^HLB("AD","OUT",PTIME,MSGIEN)=""
"RTN","HLOCLNT2",64,0)
 D:PARMS("ACTION")]"" INQUE^HLOQUE(PARMS("LINK"),PARMS("QUEUE"),MSGIEN,PARMS("ACTION"),$S(PARMS("PURGE TYPE"):1,1:0))
"RTN","HLOCLNT2",65,0)
 Q
"RTN","HLOCLNT3")
0^11^B3706254
"RTN","HLOCLNT3",1,0)
HLOCLNT3 ;ALB/CJM- Updates messages missing application acks - 10/4/94 1pm
"RTN","HLOCLNT3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOCLNT3",3,0)
 ;
"RTN","HLOCLNT3",4,0)
DOWORK(WORK) ;
"RTN","HLOCLNT3",5,0)
 ;
"RTN","HLOCLNT3",6,0)
 N CUTOFF,MSGIEN,QUIT
"RTN","HLOCLNT3",7,0)
 S QUIT=0
"RTN","HLOCLNT3",8,0)
 ;
"RTN","HLOCLNT3",9,0)
 ;7 day wait for an application ack is more than reasonable
"RTN","HLOCLNT3",10,0)
 S CUTOFF=$$FMADD^XLFDT($$NOW^XLFDT,-3)
"RTN","HLOCLNT3",11,0)
 ;
"RTN","HLOCLNT3",12,0)
 S MSGIEN=+$G(^HLTMP("LAST IEN CHECKED FOR MISSING APPLICATION ACK"))
"RTN","HLOCLNT3",13,0)
 F  S MSGIEN=$O(^HLB(MSGIEN)) Q:'MSGIEN  Q:MSGIEN>99999999999  D  Q:QUIT
"RTN","HLOCLNT3",14,0)
 .N MSG,HDR
"RTN","HLOCLNT3",15,0)
 .Q:'$$GETMSG^HLOMSG(MSGIEN,.MSG)
"RTN","HLOCLNT3",16,0)
 .Q:'MSG("DT/TM")
"RTN","HLOCLNT3",17,0)
 .Q:'MSG("BODY")
"RTN","HLOCLNT3",18,0)
 .I MSG("DT/TM")>CUTOFF S:MSG("DT/TM CREATED")>CUTOFF QUIT=1,MSGIEN=MSGIEN-1 Q
"RTN","HLOCLNT3",19,0)
 .Q:MSG("STATUS")'=""
"RTN","HLOCLNT3",20,0)
 .Q:MSG("DIRECTION")'="OUT"
"RTN","HLOCLNT3",21,0)
 .Q:MSG("BATCH")
"RTN","HLOCLNT3",22,0)
 .Q:MSG("STATUS","APP ACK'D")
"RTN","HLOCLNT3",23,0)
 .;Q:MSG("STATUS","APP ACK RESPONSE")=""
"RTN","HLOCLNT3",24,0)
 .;message has been in a non-complete status for a longtime, pending an application ack - set status to error
"RTN","HLOCLNT3",25,0)
 .S $P(^HLB(MSGIEN,0),"^",20)="AE"
"RTN","HLOCLNT3",26,0)
 .S $P(^HLB(MSGIEN,0),"^",21)="MISSING APPLICATION ACKNOWLEDGMENT"
"RTN","HLOCLNT3",27,0)
 .M HDR=MSG("HDR")
"RTN","HLOCLNT3",28,0)
 .Q:'$$PARSEHDR^HLOPRS(.HDR)
"RTN","HLOCLNT3",29,0)
 .S ^HLB("ERRORS","AE",$S($L(HDR("RECEIVING APPLICATION")):HDR("RECEIVING APPLICATION"),1:"UNKNOWN"),MSG("DT/TM CREATED"),MSGIEN)=""
"RTN","HLOCLNT3",30,0)
 S:MSGIEN>99999999999 MSGIEN=0
"RTN","HLOCLNT3",31,0)
 S ^HLTMP("LAST IEN CHECKED FOR MISSING APPLICATION ACK")=MSGIEN
"RTN","HLOCLNT3",32,0)
 Q
"RTN","HLOCNRT")
0^47^B4743338
"RTN","HLOCNRT",1,0)
HLOCNRT ;DAOU/ALA-Generate HL7 Optimized Message ; 17 Jun 2005  12:57 PM
"RTN","HLOCNRT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOCNRT",3,0)
 ;
"RTN","HLOCNRT",4,0)
 ;**Program Description**
"RTN","HLOCNRT",5,0)
 ;  This program takes a current HL7 1.6 message and converts
"RTN","HLOCNRT",6,0)
 ;  it to use the new HL Optimized code if it follows the standard
"RTN","HLOCNRT",7,0)
 ;  1.6 methodology of protocols.
"RTN","HLOCNRT",8,0)
 ;
"RTN","HLOCNRT",9,0)
 ;  **If the VistA HL7 Protocol does not exist, calls to HL Optimized
"RTN","HLOCNRT",10,0)
 ;  will have to be coded separately and this program cannot be used**
"RTN","HLOCNRT",11,0)
 Q
"RTN","HLOCNRT",12,0)
 ;
"RTN","HLOCNRT",13,0)
EN(HLOPRTCL,ARYTYP,HLP) ;Entry Point
"RTN","HLOCNRT",14,0)
 ;  Input Parameters
"RTN","HLOCNRT",15,0)
 ;   HLOPRTCL = Protocol IEN or Protocol Name
"RTN","HLOCNRT",16,0)
 ;   ARYTYP = The array where HL7 message resides
"RTN","HLOCNRT",17,0)
 ;   HLP = Additional HL7 message parameters
"RTN","HLOCNRT",18,0)
 ;
"RTN","HLOCNRT",19,0)
 ;  Output
"RTN","HLOCNRT",20,0)
 ;    ZTSTOP = Stop processing flag (used by HDR)
"RTN","HLOCNRT",21,0)
 ;    HLORESL = Error parameter
"RTN","HLOCNRT",22,0)
 ;
"RTN","HLOCNRT",23,0)
 NEW HLORESL,HLMSTATE,APPARMS,WHOTO,WHO,ERROR,HLOMESG
"RTN","HLOCNRT",24,0)
 S ZTSTOP=0,HLORESL=1
"RTN","HLOCNRT",25,0)
 ;
"RTN","HLOCNRT",26,0)
 ;  Get IEN of protocol if name is passed
"RTN","HLOCNRT",27,0)
 I HLOPRTCL'?.N S HLOPRTCL=+$O(^ORD(101,"B",HLOPRTCL,0))
"RTN","HLOCNRT",28,0)
 I '$D(^ORD(101,HLOPRTCL)) S HLORESL="^99^HL7 1.6 Protocol not found",ZTSTOP=1 Q HLORESL
"RTN","HLOCNRT",29,0)
 ;
"RTN","HLOCNRT",30,0)
 ;  If the VistA HL7 Protocol exists, call the Conversion Utility
"RTN","HLOCNRT",31,0)
 ;  to set up the APPARMS, WHO or WHOTO arrays from protocol
"RTN","HLOCNRT",32,0)
 ;  logical link
"RTN","HLOCNRT",33,0)
 D APAR^HLOCVU(HLOPRTCL,.APPARMS,.WHO,.WHOTO)
"RTN","HLOCNRT",34,0)
 ;
"RTN","HLOCNRT",35,0)
 ; If special HLP parameters are defined, convert them
"RTN","HLOCNRT",36,0)
 I $D(HLP) D
"RTN","HLOCNRT",37,0)
 . I $G(HLP("SECURITY"))'="" S APPARMS("SECURITY")=HLP("SECURITY")
"RTN","HLOCNRT",38,0)
 . I $G(HLP("CONTPTR"))'="" S APPARMS("CONTINUATION POINTER")=HLP("CONTPTR")
"RTN","HLOCNRT",39,0)
 . I $G(HLP("QUEUE"))'="" S APPARMS("QUEUE")=HLP("QUEUE")
"RTN","HLOCNRT",40,0)
 ;
"RTN","HLOCNRT",41,0)
 ;  Create HL Optimized message
"RTN","HLOCNRT",42,0)
 I '$$NEWMSG^HLOAPI(.APPARMS,.HLMSTATE,.ERROR) S HLORESL="^99^"_ERROR,ZTSTOP=1 Q HLORESL
"RTN","HLOCNRT",43,0)
 I $E(ARYTYP,1)="G" S HLOMESG="^TMP(""HLS"",$J)"
"RTN","HLOCNRT",44,0)
 I $E(ARYTYP,1)="L" S HLOMESG="HLA(""HLS"")"
"RTN","HLOCNRT",45,0)
 ;
"RTN","HLOCNRT",46,0)
 ;  Move the existing message from array into HL Optimized
"RTN","HLOCNRT",47,0)
 D MOVEMSG^HLOAPI(.HLMSTATE,HLOMESG)
"RTN","HLOCNRT",48,0)
 ; 
"RTN","HLOCNRT",49,0)
 ;  Send message via HL Optimized
"RTN","HLOCNRT",50,0)
 I $D(WHOTO) D  Q HLORESL
"RTN","HLOCNRT",51,0)
 . I '$$SENDMANY^HLOAPI1(.HLMSTATE,.APPARMS,.WHOTO) S HLORESL="^99^Unable to send message",ZTSTOP=1 Q
"RTN","HLOCNRT",52,0)
 . S HLORESL=1
"RTN","HLOCNRT",53,0)
 ;
"RTN","HLOCNRT",54,0)
 I '$$SENDONE^HLOAPI1(.HLMSTATE,.APPARMS,.WHO,.ERROR) S HLORESL="^99^"_ERROR,ZTSTOP=1 Q HLORESL
"RTN","HLOCNRT",55,0)
 Q HLORESL
"RTN","HLOCVU")
0^46^B5066511
"RTN","HLOCVU",1,0)
HLOCVU ;DAOU/ALA-Conversion Utility ; 04 Aug 2005  4:26 PM
"RTN","HLOCVU",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOCVU",3,0)
 ;
"RTN","HLOCVU",4,0)
 Q
"RTN","HLOCVU",5,0)
 ;
"RTN","HLOCVU",6,0)
APAR(HLOEID,APPARMS,WHO,WHOTO) ;  Set up APPARMS array from Protocols
"RTN","HLOCVU",7,0)
 ;
"RTN","HLOCVU",8,0)
 ;  Input Parameter
"RTN","HLOCVU",9,0)
 ;   HLOEID = IEN of the event protocol
"RTN","HLOCVU",10,0)
 ;
"RTN","HLOCVU",11,0)
 ;  Output
"RTN","HLOCVU",12,0)
 ;    APPARMS array
"RTN","HLOCVU",13,0)
 ;    WHO or WHOTO array
"RTN","HLOCVU",14,0)
 NEW HLOTEXT,HLARY,FLDS,HLOSID,CT
"RTN","HLOCVU",15,0)
 S FLDS="770.1;770.3;770.4;770.8;770.9;770.95"
"RTN","HLOCVU",16,0)
 D GETS^DIQ(101,HLOEID,FLDS,"R","HLOTEXT")
"RTN","HLOCVU",17,0)
 ;
"RTN","HLOCVU",18,0)
 S APPARMS("COUNTRY")="USA"
"RTN","HLOCVU",19,0)
 S APPARMS("EVENT")=$G(HLOTEXT(101,HLOEID_",","EVENT TYPE"))
"RTN","HLOCVU",20,0)
 S APPARMS("MESSAGE TYPE")=$G(HLOTEXT(101,HLOEID_",","TRANSACTION MESSAGE TYPE"))
"RTN","HLOCVU",21,0)
 S APPARMS("VERSION")=$G(HLOTEXT(101,HLOEID_",","VERSION ID"))
"RTN","HLOCVU",22,0)
 S APPARMS("SENDING APPLICATION")=$G(HLOTEXT(101,HLOEID_",","SENDING APPLICATION"))
"RTN","HLOCVU",23,0)
 S APPARMS("APP ACK TYPE")=$G(HLOTEXT(101,HLOEID_",","APPLICATION ACK TYPE"))
"RTN","HLOCVU",24,0)
 S APPARMS("ACCEPT ACK TYPE")=$G(HLOTEXT(101,HLOEID_",","ACCEPT ACK CODE"))
"RTN","HLOCVU",25,0)
 I $G(HLFS)'="" S APPARMS("FIELD SEPARATOR")=HLFS
"RTN","HLOCVU",26,0)
 I $G(HLECH)'="" S APPARMS("ENCODING CHARACTERS")=HLECH
"RTN","HLOCVU",27,0)
 ;
"RTN","HLOCVU",28,0)
 K HLOTEXT,FLDS
"RTN","HLOCVU",29,0)
 D ITEM^HLUTIL2(HLOEID,"PTR")
"RTN","HLOCVU",30,0)
 I $G(HLARY(0))>1 D MANY Q
"RTN","HLOCVU",31,0)
 S HLOSID=$O(HLARY(0))
"RTN","HLOCVU",32,0)
 S FLDS="770.2;770.4;770.7"
"RTN","HLOCVU",33,0)
 D GETS^DIQ(101,HLOSID,FLDS,"R","HLOTEXT")
"RTN","HLOCVU",34,0)
 S WHO("RECEIVING APPLICATION")=$G(HLOTEXT(101,HLOSID_",","RECEIVING APPLICATION"))
"RTN","HLOCVU",35,0)
 S WHO("FACILITY LINK NAME")=$G(HLOTEXT(101,HLOSID_",","LOGICAL LINK"))
"RTN","HLOCVU",36,0)
 Q
"RTN","HLOCVU",37,0)
 ;
"RTN","HLOCVU",38,0)
MANY ;  If multiple subscribers
"RTN","HLOCVU",39,0)
 S HLOSID=0,CT=0
"RTN","HLOCVU",40,0)
 S FLDS="770.2;770.4;770.7"
"RTN","HLOCVU",41,0)
 F  S HLOSID=$O(HLARY(HLOSID)) Q:'HLOSID  D
"RTN","HLOCVU",42,0)
 . K HLOTEXT
"RTN","HLOCVU",43,0)
 . D GETS^DIQ(101,HLOSID,FLDS,"R","HLOTEXT")
"RTN","HLOCVU",44,0)
 . S CT=CT+1
"RTN","HLOCVU",45,0)
 . S WHOTO(CT,"RECEIVING APPLICATION")=$G(HLOTEXT(101,HLOSID_",","RECEIVING APPLICATION"))
"RTN","HLOCVU",46,0)
 . S WHOTO(CT,"FACILITY LINK NAME")=$G(HLOTEXT(101,HLOSID_",","LOGICAL LINK"))
"RTN","HLOCVU",47,0)
 ;
"RTN","HLOCVU",48,0)
 Q
"RTN","HLOF777")
0^20^B12330869
"RTN","HLOF777",1,0)
HLOF777  ;ALB/CJM-HL7 - API'S for saving data to file 777 ;02/04/2004
"RTN","HLOF777",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOF777",3,0)
 ;
"RTN","HLOF777",4,0)
SAVEMSG(HLMSTATE) ;
"RTN","HLOF777",5,0)
 ;If a record has not yet been created in file 777, then it will be created.  Otherwise, it just stores the segments not yet stored.
"RTN","HLOF777",6,0)
 ;Input:
"RTN","HLOF777",7,0)
 ;  HLMSTATE (pass by reference) - contains information about the message
"RTN","HLOF777",8,0)
 ;    These subscripts must be defined:
"RTN","HLOF777",9,0)
 ;    ("BATCH")=1 if batch, 0 otherwise
"RTN","HLOF777",10,0)
 ;    ("BODY")=ien file 777
"RTN","HLOF777",11,0)
 ;  ("UNSTORED LINES") - count of lines to be stored. The lines are stored at a lower subscript <message#>,<segment#>,<line#>
"RTN","HLOF777",12,0)
 ;Output:
"RTN","HLOF777",13,0)
 ;  HLMSTATE("UNSTORED LINES")-set to 0
"RTN","HLOF777",14,0)
 ;
"RTN","HLOF777",15,0)
 ;if the record has not been created yet,then create it
"RTN","HLOF777",16,0)
 I 'HLMSTATE("BODY"),'$$NEW(.HLMSTATE) Q 0
"RTN","HLOF777",17,0)
 ;
"RTN","HLOF777",18,0)
 ;any segments to store to disk?
"RTN","HLOF777",19,0)
 Q:'HLMSTATE("UNSTORED LINES") HLMSTATE("BODY")
"RTN","HLOF777",20,0)
 ;
"RTN","HLOF777",21,0)
 I 'HLMSTATE("BATCH") D
"RTN","HLOF777",22,0)
 .N ARY,SEG,LINE
"RTN","HLOF777",23,0)
 .S ARY="^HLA("_HLMSTATE("BODY")_",1)"
"RTN","HLOF777",24,0)
 .S SEG=0
"RTN","HLOF777",25,0)
 .F  S SEG=$O(HLMSTATE("UNSTORED LINES",1,SEG)) Q:'SEG  D
"RTN","HLOF777",26,0)
 ..S LINE=0
"RTN","HLOF777",27,0)
 ..F  S LINE=$O(HLMSTATE("UNSTORED LINES",1,SEG,LINE)) Q:'LINE  S @ARY@(LINE,0)=HLMSTATE("UNSTORED LINES",1,SEG,LINE)
"RTN","HLOF777",28,0)
 .;
"RTN","HLOF777",29,0)
 I HLMSTATE("BATCH") D
"RTN","HLOF777",30,0)
 .;NOTE: will not store any segments that come before the first MSH!
"RTN","HLOF777",31,0)
 .N MSG S MSG=0
"RTN","HLOF777",32,0)
 .F  S MSG=$O(HLMSTATE("UNSTORED LINES",MSG)) Q:'MSG  D
"RTN","HLOF777",33,0)
 ..N ARY,SEG,LINE
"RTN","HLOF777",34,0)
 ..S ARY="^HLA("_HLMSTATE("BODY")_",2,"_MSG_")"
"RTN","HLOF777",35,0)
 ..;
"RTN","HLOF777",36,0)
 ..;if starting a new message, add its 0 node.  The message type and event are stored in HLMSTATE("UNSTORED LINES",MSG)
"RTN","HLOF777",37,0)
 ..I '$D(@ARY@(0)) D
"RTN","HLOF777",38,0)
 ...S @ARY@(0)=MSG_"^"_$G(HLMSTATE("UNSTORED LINES",MSG))
"RTN","HLOF777",39,0)
 ...;
"RTN","HLOF777",40,0)
 ...S ^HLA(HLMSTATE("BODY"),2,"B",MSG,MSG)=""
"RTN","HLOF777",41,0)
 ..;
"RTN","HLOF777",42,0)
 ..S SEG=0
"RTN","HLOF777",43,0)
 ..F  S SEG=$O(HLMSTATE("UNSTORED LINES",MSG,SEG)) Q:'SEG  D
"RTN","HLOF777",44,0)
 ...S LINE=0
"RTN","HLOF777",45,0)
 ...F  S LINE=$O(HLMSTATE("UNSTORED LINES",MSG,SEG,LINE)) Q:'LINE  S @ARY@(1,LINE,0)=HLMSTATE("UNSTORED LINES",MSG,SEG,LINE)
"RTN","HLOF777",46,0)
 ;
"RTN","HLOF777",47,0)
 ;clear the cache
"RTN","HLOF777",48,0)
 K HLMSTATE("UNSTORED LINES")
"RTN","HLOF777",49,0)
 S HLMSTATE("UNSTORED LINES")=0
"RTN","HLOF777",50,0)
 ;S:HLMSTATE("BATCH") HLMSTATE("BATCH","CURRENT MESSAGE")=0
"RTN","HLOF777",51,0)
 Q HLMSTATE("BODY")
"RTN","HLOF777",52,0)
 ;
"RTN","HLOF777",53,0)
NEW(HLMSTATE) ;
"RTN","HLOF777",54,0)
 ;This function creates a new entry in file 777.
"RTN","HLOF777",55,0)
 ;Input:
"RTN","HLOF777",56,0)
 ;   HLMSTATE (required, pass by reference) These subscripts are expected:
"RTN","HLOF777",57,0)
 ;     "DIRECTION"
"RTN","HLOF777",58,0)
 ;     "DT/TM"   (optional, $$NOW used as default)
"RTN","HLOF777",59,0)
 ;     "BATCH"
"RTN","HLOF777",60,0)
 ;     "HDR","ENCODING CHARACTERS"
"RTN","HLOF777",61,0)
 ;     "HDR","EVENT"
"RTN","HLOF777",62,0)
 ;     "HDR","FIELD SEPARATOR"
"RTN","HLOF777",63,0)
 ;     "HDR","MESSAGE TYPE"
"RTN","HLOF777",64,0)
 ;     "HDR","VERSION"
"RTN","HLOF777",65,0)
 ;
"RTN","HLOF777",66,0)
 ;Output - the function returns the ien of the newly created record
"RTN","HLOF777",67,0)
 ;
"RTN","HLOF777",68,0)
 N IEN,TIME,NODE
"RTN","HLOF777",69,0)
 S IEN=$$NEWIEN(HLMSTATE("DIRECTION"),$$TCP^HLOF778A)
"RTN","HLOF777",70,0)
 Q:'IEN 0
"RTN","HLOF777",71,0)
 K ^HLA(IEN)
"RTN","HLOF777",72,0)
 S HLMSTATE("DT/TM CREATED")=$S($G(HLMSTATE("DT/TM")):HLMSTATE("DT/TM"),1:$$NOW^XLFDT)
"RTN","HLOF777",73,0)
 ;
"RTN","HLOF777",74,0)
 S NODE=HLMSTATE("DT/TM CREATED")_"^"_HLMSTATE("BATCH")_"^^^"_$G(HLMSTATE("HDR","VERSION"))
"RTN","HLOF777",75,0)
 I 'HLMSTATE("BATCH") S $P(NODE,"^",3)=HLMSTATE("HDR","MESSAGE TYPE"),$P(NODE,"^",4)=HLMSTATE("HDR","EVENT")
"RTN","HLOF777",76,0)
 S $P(NODE,"^",20)=HLMSTATE("HDR","FIELD SEPARATOR")_HLMSTATE("HDR","ENCODING CHARACTERS")
"RTN","HLOF777",77,0)
 S ^HLA(IEN,0)=NODE
"RTN","HLOF777",78,0)
 ;
"RTN","HLOF777",79,0)
 ;for incoming msgs, set the "B" xref later
"RTN","HLOF777",80,0)
 S:HLMSTATE("DIRECTION")="OUT" ^HLA("B",HLMSTATE("DT/TM CREATED"),IEN)=""
"RTN","HLOF777",81,0)
 ;
"RTN","HLOF777",82,0)
 S HLMSTATE("BODY")=IEN
"RTN","HLOF777",83,0)
 Q IEN
"RTN","HLOF777",84,0)
 ;
"RTN","HLOF777",85,0)
NEWIEN(DIR,TCP) ;
"RTN","HLOF777",86,0)
 ;This function uses a counter to get the next available ien for file 777. There are 3 different counters, each assigned a specific number range, selected via the input parameters. It does not create a record.
"RTN","HLOF777",87,0)
 ;Inputs:
"RTN","HLOF777",88,0)
 ;  DIR = "IN" or "OUT" (required)
"RTN","HLOF777",89,0)
 ;  TCP = 1,0 (optional)
"RTN","HLOF777",90,0)
 ;Output - the function returns the next available ien. Several counters are used:
"RTN","HLOF777",91,0)
 ;   <"OUT">
"RTN","HLOF777",92,0)
 ;   <"IN","TCP">
"RTN","HLOF777",93,0)
 ;   <"IN","NOT TCP">
"RTN","HLOF777",94,0)
 ;
"RTN","HLOF777",95,0)
 N IEN,COUNTER
"RTN","HLOF777",96,0)
 S:DIR="IN" COUNTER=$NA(^HLC("FILE777",DIR,$S(+$G(TCP):"TCP",1:"NOT TCP")))
"RTN","HLOF777",97,0)
 S:DIR="OUT" COUNTER=$NA(^HLC("FILE777",DIR))
"RTN","HLOF777",98,0)
AGAIN ;
"RTN","HLOF777",99,0)
 S IEN=$$INC^HLOSITE(COUNTER,1)
"RTN","HLOF777",100,0)
 I IEN>100000000000 D
"RTN","HLOF777",101,0)
 .L +@COUNTER:200
"RTN","HLOF777",102,0)
 .I $T,@COUNTER>100000000000 S @COUNTER=1,IEN=1
"RTN","HLOF777",103,0)
 .L -@COUNTER
"RTN","HLOF777",104,0)
 I IEN>100000000000 G AGAIN
"RTN","HLOF777",105,0)
 Q (IEN+$S(DIR="OUT":0,+$G(TCP):100000000000,1:200000000000))
"RTN","HLOF778")
0^21^B26674072
"RTN","HLOF778",1,0)
HLOF778 ;ALB/CJM-HL7 - Saving messages to file 778 ;02/04/2004
"RTN","HLOF778",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOF778",3,0)
 ;
"RTN","HLOF778",4,0)
 ;
"RTN","HLOF778",5,0)
SAVEMSG(HLMSTATE) ;
"RTN","HLOF778",6,0)
 ;If a record has not yet been created in file 778, then it will be created. Will file any segments into 777 not yet stored.  For batch messages, will store the MSH segments in 778 as the individual messages are stored in 777.
"RTN","HLOF778",7,0)
 ;Input:
"RTN","HLOF778",8,0)
 ;  HLMSTATE (pass by reference) - contains information about the message
"RTN","HLOF778",9,0)
 ;    These subscripts must be defined:
"RTN","HLOF778",10,0)
 ;  ("BATCH")=1 if batch, 0 otherwise
"RTN","HLOF778",11,0)
 ;  ("BATCH","BTS")=BTS segment if end of batch reached
"RTN","HLOF778",12,0)
 ;  ("BODY")=ien file 777 if stored
"RTN","HLOF778",13,0)
 ;  ("DIRECTION")=<"IN" or "OUT">
"RTN","HLOF778",14,0)
 ;  ("IEN")=ien,file 778 if stored
"RTN","HLOF778",15,0)
 ;  ("UNSTORED LINES") - count of lines to be stored.  The lines are at the a lower subscript level <msg>,<segment>,<line>=<line to be stored>
"RTN","HLOF778",16,0)
 ;  ("UNSTORED MSH") For batch messages, set to 1 if there are MSH in cache. Cached MSH at ("UNSTORED MSH",<subfile ien>,<1 & 2>)
"RTN","HLOF778",17,0)
 ;
"RTN","HLOF778",18,0)
 ;Output:
"RTN","HLOF778",19,0)
 ;  Function - returns the ien of the msg (file 778)
"RTN","HLOF778",20,0)
 ;  HLMSTATE
"RTN","HLOF778",21,0)
 ;   ("BODY") - set to ien, file 777 if newly created
"RTN","HLOF778",22,0)
 ;   ("IEN") - set to ien, file 778 if newly created
"RTN","HLOF778",23,0)
 ;   ("UNSTORED LINES")-set to 0 as this function will store them
"RTN","HLOF778",24,0)
 ;   ("UNSTORED MSH")- set to 0 as this function will store it
"RTN","HLOF778",25,0)
 ;
"RTN","HLOF778",26,0)
 ;
"RTN","HLOF778",27,0)
 I '$D(HLMSTATE("DT/TM")) S HLMSTATE("DT/TM")=$S(HLMSTATE("DIRECTION")="IN":$$NOW^XLFDT,1:"")
"RTN","HLOF778",28,0)
 ;
"RTN","HLOF778",29,0)
 ;insure that 777 entry created & all segments stored
"RTN","HLOF778",30,0)
 I ('HLMSTATE("BODY"))!($G(HLMSTATE("UNSTORED LINES")))!($L($G(HLMSTATE("BATCH","BTS")))),'$$SAVEMSG^HLOF777(.HLMSTATE) Q 0
"RTN","HLOF778",31,0)
 ;
"RTN","HLOF778",32,0)
 ;insure 778 entry created
"RTN","HLOF778",33,0)
 I 'HLMSTATE("IEN") Q:'$$NEW^HLOF778A(.HLMSTATE) 0
"RTN","HLOF778",34,0)
 ;
"RTN","HLOF778",35,0)
 ;for batch messages, store MSH segments in 778
"RTN","HLOF778",36,0)
 I HLMSTATE("BATCH") D
"RTN","HLOF778",37,0)
 .N IEN S IEN=HLMSTATE("IEN")
"RTN","HLOF778",38,0)
 .;
"RTN","HLOF778",39,0)
 .;incoming messages cache the MSH segments in memory
"RTN","HLOF778",40,0)
 .I HLMSTATE("DIRECTION")="IN",HLMSTATE("UNSTORED MSH") D
"RTN","HLOF778",41,0)
 ..N ORDER S ORDER=0
"RTN","HLOF778",42,0)
 ..F  S ORDER=$O(HLMSTATE("UNSTORED MSH",ORDER)) Q:'ORDER  D
"RTN","HLOF778",43,0)
 ...N FS,MSGID
"RTN","HLOF778",44,0)
 ...S FS=$E(HLMSTATE("UNSTORED MSH",ORDER,1),4)
"RTN","HLOF778",45,0)
 ...S MSGID=$P(HLMSTATE("UNSTORED MSH",ORDER,2),FS,5)
"RTN","HLOF778",46,0)
 ...S ^HLB(IEN,3,ORDER,0)=ORDER_"^"_MSGID_"^"_$G(HLMSTATE("BATCH","ACK TO",ORDER))
"RTN","HLOF778",47,0)
 ...S ^HLB(IEN,3,ORDER,1)=HLMSTATE("UNSTORED MSH",ORDER,1)
"RTN","HLOF778",48,0)
 ...S ^HLB(IEN,3,ORDER,2)=HLMSTATE("UNSTORED MSH",ORDER,2)
"RTN","HLOF778",49,0)
 ...S ^HLB(IEN,3,"B",ORDER,ORDER)=""
"RTN","HLOF778",50,0)
 ...I MSGID]"" S ^HLB("AE",MSGID,IEN_"^"_ORDER)="" ;whole file index for individual message id
"RTN","HLOF778",51,0)
 ..K HLMSTATE("UNSTORED MSH") S HLMSTATE("UNSTORED MSH")=0
"RTN","HLOF778",52,0)
 .;
"RTN","HLOF778",53,0)
 .;
"RTN","HLOF778",54,0)
 .I HLMSTATE("DIRECTION")="OUT" D
"RTN","HLOF778",55,0)
 ..;must build the MSH segments!
"RTN","HLOF778",56,0)
 ..N HDR,FS,MSG,CS
"RTN","HLOF778",57,0)
 ..S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOF778",58,0)
 ..S CS=$E(HLMSTATE("HDR","ENCODING CHARACTERS"),1)
"RTN","HLOF778",59,0)
 ..S HLMSTATE("HDR","MESSAGE TYPE")="   "
"RTN","HLOF778",60,0)
 ..S HLMSTATE("HDR","EVENT")="   "
"RTN","HLOF778",61,0)
 ..D BUILDHDR^HLOPBLD1(.HLMSTATE,"MSH",.HDR)
"RTN","HLOF778",62,0)
 ..S HLMSTATE("BATCH","CURRENT MESSAGE")=$O(^HLB(HLMSTATE("IEN"),3,"B",";"),-1)
"RTN","HLOF778",63,0)
 ..F  Q:'$$NEXTMSG(.HLMSTATE,.MSG)  D
"RTN","HLOF778",64,0)
 ...N MSGID,CUR
"RTN","HLOF778",65,0)
 ...S CUR=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOF778",66,0)
 ...S MSGID=HLMSTATE("HDR","BATCH CONTROL ID")_"-"_CUR
"RTN","HLOF778",67,0)
 ...S $P(HDR(2),FS,4)=MSG("MESSAGE TYPE")_CS_MSG("EVENT")
"RTN","HLOF778",68,0)
 ...S $P(HDR(2),FS,5)=MSGID
"RTN","HLOF778",69,0)
 ...S ^HLB(IEN,3,CUR,0)=CUR_"^"_MSGID_"^"_$G(HLMSTATE("BATCH","ACK TO",CUR))
"RTN","HLOF778",70,0)
 ...S ^HLB(IEN,3,CUR,1)=HDR(1)
"RTN","HLOF778",71,0)
 ...S ^HLB(IEN,3,CUR,2)=HDR(2)
"RTN","HLOF778",72,0)
 ...S ^HLB(IEN,3,"B",CUR,CUR)=""
"RTN","HLOF778",73,0)
 ...S ^HLB("AE",MSGID,IEN_"^"_CUR)="" ;whole file index for individual message id
"RTN","HLOF778",74,0)
 ..;
"RTN","HLOF778",75,0)
 .;if the messages are application acks, then update the original message
"RTN","HLOF778",76,0)
 .N SUBIEN S SUBIEN=0
"RTN","HLOF778",77,0)
 .F  S SUBIEN=$O(HLMSTATE("BATCH","ACK TO",SUBIEN)) Q:'SUBIEN  I $G(HLMSTATE("BATCH","ACK TO",SUBIEN,"IEN"))]"" D
"RTN","HLOF778",78,0)
 ..N ACKTO
"RTN","HLOF778",79,0)
 ..M ACKTO=HLMSTATE("BATCH","ACK TO",SUBIEN)
"RTN","HLOF778",80,0)
 ..;
"RTN","HLOF778",81,0)
 ..;for outgoing msgs, we just created the msgid, for incoming msgs we already had it
"RTN","HLOF778",82,0)
 ..S:HLMSTATE("DIRECTION")="OUT" ACKTO("ACK BY")=HLMSTATE("HDR","BATCH CONTROL ID")_"-"_SUBIEN
"RTN","HLOF778",83,0)
 ..;
"RTN","HLOF778",84,0)
 ..D ACKTO(.HLMSTATE,.ACKTO)
"RTN","HLOF778",85,0)
 .K HLMSTATE("BATCH","ACK TO")
"RTN","HLOF778",86,0)
 ;
"RTN","HLOF778",87,0)
 ;if the msg is an app ack, update the original if not done already
"RTN","HLOF778",88,0)
 I $G(HLMSTATE("ACK TO","IEN"))]"",'$G(HLMSTATE("ACK TO","DONE")) D
"RTN","HLOF778",89,0)
 .N ACKTO
"RTN","HLOF778",90,0)
 .M ACKTO=HLMSTATE("ACK TO")
"RTN","HLOF778",91,0)
 .S ACKTO("ACK BY")=$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOF778",92,0)
 .D ACKTO(.HLMSTATE,.ACKTO)
"RTN","HLOF778",93,0)
 .S HLMSTATE("ACK TO","DONE")=1 ;so the update isn't done again
"RTN","HLOF778",94,0)
 ;
"RTN","HLOF778",95,0)
 Q HLMSTATE("IEN")
"RTN","HLOF778",96,0)
 ;
"RTN","HLOF778",97,0)
NEXTMSG(HLMSTATE,MSG) ;
"RTN","HLOF778",98,0)
 ;Traverses file 777 to return the next message in the batch - as
"RTN","HLOF778",99,0)
 ;indicated by HLMSTATE("BATCH","CURRENT MESSAGE")  Set to 0 to start,
"RTN","HLOF778",100,0)
 ;returns 0 when there are no more messages
"RTN","HLOF778",101,0)
 ;
"RTN","HLOF778",102,0)
 ;Input:  HLMSTATE (pass by reference,required)
"RTN","HLOF778",103,0)
 ;Output:
"RTN","HLOF778",104,0)
 ;  HLMSTATE
"RTN","HLOF778",105,0)
 ;     ("BATCH","CURRENT MESSAGE")
"RTN","HLOF778",106,0)
 ;  MSG -pass by reference:
"RTN","HLOF778",107,0)
 ;     ("EVENT")
"RTN","HLOF778",108,0)
 ;     ("MESSAGE TYPE")
"RTN","HLOF778",109,0)
 ;
"RTN","HLOF778",110,0)
 ;
"RTN","HLOF778",111,0)
 N SUBIEN,NODE
"RTN","HLOF778",112,0)
 K MSG
"RTN","HLOF778",113,0)
 Q:'$G(HLMSTATE("BODY")) 0
"RTN","HLOF778",114,0)
 S SUBIEN=$O(^HLA(HLMSTATE("BODY"),2,HLMSTATE("BATCH","CURRENT MESSAGE")))
"RTN","HLOF778",115,0)
 Q:'SUBIEN 0
"RTN","HLOF778",116,0)
 S NODE=$G(^HLA(HLMSTATE("BODY"),2,SUBIEN,0))
"RTN","HLOF778",117,0)
 S MSG("MESSAGE TYPE")=$P(NODE,"^",2)
"RTN","HLOF778",118,0)
 S MSG("EVENT")=$P(NODE,"^",3)
"RTN","HLOF778",119,0)
 S HLMSTATE("BATCH","CURRENT MESSAGE")=SUBIEN
"RTN","HLOF778",120,0)
 Q SUBIEN
"RTN","HLOF778",121,0)
 ;
"RTN","HLOF778",122,0)
ACKTO(HLMSTATE,ACKTO) ;if this is an application ack, update the original message
"RTN","HLOF778",123,0)
 ;ACKTO = (msgid of msg being ack'd)
"RTN","HLOF778",124,0)
 ;        uses these subscripts ("IEN"=ien^subien),("ACK BY"=msgid of acking msg),("STATUS"=status for the initial msg determined by the ack)
"RTN","HLOF778",125,0)
 ;
"RTN","HLOF778",126,0)
 N STATUS,IEN,SUBIEN,NODE
"RTN","HLOF778",127,0)
 S STATUS=$G(ACKTO("STATUS"))
"RTN","HLOF778",128,0)
 S IEN=+ACKTO("IEN"),SUBIEN=$P(ACKTO("IEN"),"^",2)
"RTN","HLOF778",129,0)
 S NODE=$G(^HLB(IEN,0))
"RTN","HLOF778",130,0)
 I 'SUBIEN D
"RTN","HLOF778",131,0)
 .;ack is to a message NOT in a batch
"RTN","HLOF778",132,0)
 .I STATUS="" S STATUS="SU"
"RTN","HLOF778",133,0)
 .S $P(NODE,"^",7)=ACKTO("ACK BY")
"RTN","HLOF778",134,0)
 .S $P(NODE,"^",20)=STATUS
"RTN","HLOF778",135,0)
 .S ^HLB(IEN,0)=NODE
"RTN","HLOF778",136,0)
 E  D
"RTN","HLOF778",137,0)
 .;ack is to a message that IS in a batch
"RTN","HLOF778",138,0)
 .S $P(^HLB(IEN,3,SUBIEN,0),"^",4)=$G(ACKTO("ACK BY"))
"RTN","HLOF778",139,0)
 .S $P(^HLB(IEN,3,SUBIEN,0),"^",5)=STATUS
"RTN","HLOF778",140,0)
 I (STATUS="AE"),HLMSTATE("HDR","SENDING APPLICATION")]"" D
"RTN","HLOF778",141,0)
 .N TIME,BODY
"RTN","HLOF778",142,0)
 .S BODY=$P(NODE,"^",2)
"RTN","HLOF778",143,0)
 .S:BODY TIME=+$G(^HLA(BODY,0))
"RTN","HLOF778",144,0)
 .I $G(TIME) S ^HLB("ERRORS","AE",HLMSTATE("HDR","SENDING APPLICATION"),TIME,ACKTO("IEN"))=""
"RTN","HLOF778",145,0)
 Q
"RTN","HLOF778A")
0^22^B35675106
"RTN","HLOF778A",1,0)
HLOF778A ;ALB/CJM-HL7 - Saving messages to file 778 (continued) ;02/04/2004
"RTN","HLOF778A",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOF778A",3,0)
 ;
"RTN","HLOF778A",4,0)
 ;
"RTN","HLOF778A",5,0)
NEW(HLMSTATE) ;
"RTN","HLOF778A",6,0)
 ;This function creates a new entry in file 778.
"RTN","HLOF778A",7,0)
 ;Input:
"RTN","HLOF778A",8,0)
 ;   HLMSTATE (required, pass by reference) These subscripts are expected:
"RTN","HLOF778A",9,0)
 ;
"RTN","HLOF778A",10,0)
 ;Output - the function returns the ien of the newly created record
"RTN","HLOF778A",11,0)
 ;
"RTN","HLOF778A",12,0)
 N IEN,NODE,ID,STAT
"RTN","HLOF778A",13,0)
 S STAT="HLMSTATE(""STATUS"")"
"RTN","HLOF778A",14,0)
 S IEN=$$NEWIEN(HLMSTATE("DIRECTION"),$$TCP)
"RTN","HLOF778A",15,0)
 Q:'IEN 0
"RTN","HLOF778A",16,0)
 S HLMSTATE("IEN")=IEN
"RTN","HLOF778A",17,0)
 ;
"RTN","HLOF778A",18,0)
 D  ;build the message header
"RTN","HLOF778A",19,0)
 .N HDR
"RTN","HLOF778A",20,0)
 .;for incoming messages the header segment should already exist
"RTN","HLOF778A",21,0)
 .;for outgoing messages must build the header segment
"RTN","HLOF778A",22,0)
 .I HLMSTATE("DIRECTION")="OUT" D  Q
"RTN","HLOF778A",23,0)
 ..I HLMSTATE("BATCH"),$G(HLMSTATE("ACK TO"))]"" S HLMSTATE("HDR","REFERENCE BATCH CONTROL ID")=HLMSTATE("ACK TO")
"RTN","HLOF778A",24,0)
 ..D BUILDHDR^HLOPBLD1(.HLMSTATE,$S(HLMSTATE("BATCH"):"BHS",1:"MSH"),.HDR)
"RTN","HLOF778A",25,0)
 ..S HLMSTATE("HDR",1)=HDR(1),HLMSTATE("HDR",2)=HDR(2)
"RTN","HLOF778A",26,0)
 ;
"RTN","HLOF778A",27,0)
 K ^HLB(IEN)
"RTN","HLOF778A",28,0)
 S ID=$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOF778A",29,0)
 S NODE=ID_"^"_HLMSTATE("BODY")_"^"_$G(HLMSTATE("ACK TO"))_"^"_$S(HLMSTATE("DIRECTION")="IN":"I",1:"O")_"^"
"RTN","HLOF778A",30,0)
 S $P(NODE,"^",5)=$G(@STAT@("LINK NAME"))
"RTN","HLOF778A",31,0)
 S $P(NODE,"^",6)=$G(@STAT@("QUEUE"))
"RTN","HLOF778A",32,0)
 S $P(NODE,"^",8)=$G(@STAT@("PORT"))
"RTN","HLOF778A",33,0)
 S $P(NODE,"^",20)=$G(@STAT)
"RTN","HLOF778A",34,0)
 S $P(NODE,"^",21)=$G(@STAT@("ERROR TEXT"))
"RTN","HLOF778A",35,0)
 S $P(NODE,"^",16)=HLMSTATE("DT/TM")
"RTN","HLOF778A",36,0)
 ;
"RTN","HLOF778A",37,0)
 I HLMSTATE("DIRECTION")="OUT" D
"RTN","HLOF778A",38,0)
 .S $P(NODE,"^",10)=$P($G(@STAT@("APP ACK RESPONSE")),"^")
"RTN","HLOF778A",39,0)
 .S $P(NODE,"^",11)=$P($G(@STAT@("APP ACK RESPONSE")),"^",2)
"RTN","HLOF778A",40,0)
 .S $P(NODE,"^",12)=$P($G(@STAT@("ACCEPT ACK RESPONSE")),"^")
"RTN","HLOF778A",41,0)
 .S $P(NODE,"^",13)=$P($G(@STAT@("ACCEPT ACK RESPONSE")),"^",2)
"RTN","HLOF778A",42,0)
 .S $P(NODE,"^",14)=$P($G(@STAT@("FAILURE RESPONSE")),"^")
"RTN","HLOF778A",43,0)
 .S $P(NODE,"^",15)=$P($G(@STAT@("FAILURE RESPONSE")),"^",2)
"RTN","HLOF778A",44,0)
 .;
"RTN","HLOF778A",45,0)
 .;for outgoing set these x-refs now, for incoming msgs set them later
"RTN","HLOF778A",46,0)
 .S ^HLB("B",ID,IEN)=""
"RTN","HLOF778A",47,0)
 .S ^HLB("C",HLMSTATE("BODY"),IEN)=""
"RTN","HLOF778A",48,0)
 .I ($G(@STAT)="SE") S ^HLB("ERRORS","SE",$S($L($G(HLMSTATE("HDR","RECEIVING APPLICATION"))):HLMSTATE("HDR","RECEIVING APPLICATION"),1:"UNKNOWN"),HLMSTATE("DT/TM CREATED"),IEN)=""
"RTN","HLOF778A",49,0)
 .;
"RTN","HLOF778A",50,0)
 .;save some space for the ack
"RTN","HLOF778A",51,0)
 .S:($G(HLMSTATE("HDR","ACCEPT ACK TYPE"))="AL") ^HLB(IEN,4)="^^^                                                                 "
"RTN","HLOF778A",52,0)
 I $G(HLMSTATE("STATUS","PURGE")) S $P(NODE,"^",9)=HLMSTATE("STATUS","PURGE"),^HLB("AD","OUT",HLMSTATE("STATUS","PURGE"),HLMSTATE("IEN"))=""
"RTN","HLOF778A",53,0)
 S ^HLB(IEN,0)=NODE
"RTN","HLOF778A",54,0)
 ;
"RTN","HLOF778A",55,0)
 ;store the message header
"RTN","HLOF778A",56,0)
 S ^HLB(IEN,1)=HLMSTATE("HDR",1)
"RTN","HLOF778A",57,0)
 S ^HLB(IEN,2)=HLMSTATE("HDR",2)
"RTN","HLOF778A",58,0)
 ;
"RTN","HLOF778A",59,0)
 ;if the msg is an app ack, update the original msg
"RTN","HLOF778A",60,0)
 I $G(HLMSTATE("ACK TO","IEN"))]"" D
"RTN","HLOF778A",61,0)
 .N ACKTO
"RTN","HLOF778A",62,0)
 .M ACKTO=HLMSTATE("ACK TO")
"RTN","HLOF778A",63,0)
 .S ACKTO("ACK BY")=$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOF778A",64,0)
 .D ACKTO^HLOF778(.HLMSTATE,.ACKTO)
"RTN","HLOF778A",65,0)
 .S HLMSTATE("ACK TO","DONE")=1 ;because the update was already done, otherwise it might be done again
"RTN","HLOF778A",66,0)
 ;
"RTN","HLOF778A",67,0)
 ;The "SEARCH" x-ref will be created asynchronously
"RTN","HLOF778A",68,0)
 S ^HLTMP("PENDING SEARCH X-REF",$J,HLMSTATE("DT/TM CREATED"),IEN)=""
"RTN","HLOF778A",69,0)
 ;
"RTN","HLOF778A",70,0)
 Q IEN
"RTN","HLOF778A",71,0)
 ;
"RTN","HLOF778A",72,0)
NEWIEN(DIR,TCP) ;
"RTN","HLOF778A",73,0)
 ;This function uses a counter to get the next available ien for file 778. There are 4 different counters, each assigned as range of numbers, selected via the input parameters. It does not create a record.
"RTN","HLOF778A",74,0)
 ;Inputs:
"RTN","HLOF778A",75,0)
 ;  DIR = "IN" or "OUT" (required)
"RTN","HLOF778A",76,0)
 ;  TCP = 1,0 (optional)
"RTN","HLOF778A",77,0)
 ;Output - the function returns the next available ien. Several counters are used:
"RTN","HLOF778A",78,0)
 ;
"RTN","HLOF778A",79,0)
 ;   <"OUT","TCP">
"RTN","HLOF778A",80,0)
 ;   <"OUT","NOT TCP">
"RTN","HLOF778A",81,0)
 ;   <"IN","TCP">
"RTN","HLOF778A",82,0)
 ;   <"IN","NOT TCP">
"RTN","HLOF778A",83,0)
 ;
"RTN","HLOF778A",84,0)
 N IEN,COUNTER,INC
"RTN","HLOF778A",85,0)
 I DIR="OUT" S INC=$S(+$G(TCP):0,1:100000000000)
"RTN","HLOF778A",86,0)
 I DIR="IN" S INC=$S(+$G(TCP):200000000000,1:300000000000)
"RTN","HLOF778A",87,0)
 S COUNTER=$NA(^HLC("FILE778",DIR,$S(+$G(TCP):"TCP",1:"NOT TCP")))
"RTN","HLOF778A",88,0)
AGAIN ;
"RTN","HLOF778A",89,0)
 S IEN=$$INC^HLOSITE(COUNTER,1)
"RTN","HLOF778A",90,0)
 I IEN>100000000000 D
"RTN","HLOF778A",91,0)
 .L +@COUNTER:200
"RTN","HLOF778A",92,0)
 .I $T,@COUNTER>100000000000 S @COUNTER=1,IEN=1
"RTN","HLOF778A",93,0)
 .L -@COUNTER
"RTN","HLOF778A",94,0)
 I IEN>100000000000 G AGAIN
"RTN","HLOF778A",95,0)
 Q (IEN+INC)
"RTN","HLOF778A",96,0)
 ;
"RTN","HLOF778A",97,0)
TCP() ;checks the link to see if its TCP, return 1 if yes, 0 if no or not defined
"RTN","HLOF778A",98,0)
 N IEN,TCP
"RTN","HLOF778A",99,0)
 S TCP=1
"RTN","HLOF778A",100,0)
 S IEN=$G(HLMSTATE("STATUS","LINK IEN"))
"RTN","HLOF778A",101,0)
 I IEN,$P($G(^HLCS(869.1,+$P($G(^HLCS(870,IEN,0)),"^",3),0)),"^")'="TCP" S TCP=0
"RTN","HLOF778A",102,0)
 Q TCP
"RTN","HLOF778A",103,0)
 ;
"RTN","HLOF778A",104,0)
GETWORK(WORK) ; Used by the Process Manager.
"RTN","HLOF778A",105,0)
 ;Are there any messages that need the "SEARCH" x-ref set?
"RTN","HLOF778A",106,0)
 ;Inputs:
"RTN","HLOF778A",107,0)
 ;  WORK (required, pass-by-reference)
"RTN","HLOF778A",108,0)
 ;    ("DOLLARJ")
"RTN","HLOF778A",109,0)
 ;    ("NOW") (required by the process manager, pass-by-reference)
"RTN","HLOF778A",110,0)
 ;
"RTN","HLOF778A",111,0)
 L +^HLTMP("PENDING SEARCH X-REF"):0
"RTN","HLOF778A",112,0)
 Q:'$T 0
"RTN","HLOF778A",113,0)
 N OLD,DOLLARJ,SUCCESS,NOW
"RTN","HLOF778A",114,0)
 S SUCCESS=0
"RTN","HLOF778A",115,0)
 S NOW=$$SEC^XLFDT($H)
"RTN","HLOF778A",116,0)
 S (OLD,DOLLARJ)=$G(WORK("DOLLARJ"))
"RTN","HLOF778A",117,0)
 F  S DOLLARJ=$O(^HLTMP("PENDING SEARCH X-REF",DOLLARJ)) Q:DOLLARJ=""  D  Q:SUCCESS
"RTN","HLOF778A",118,0)
 .N TIME S TIME=$O(^HLTMP("PENDING SEARCH X-REF",DOLLARJ,""))
"RTN","HLOF778A",119,0)
 .S:(NOW-$$SEC^XLFDT(TIME)>100) SUCCESS=1
"RTN","HLOF778A",120,0)
 ;
"RTN","HLOF778A",121,0)
 I OLD'="",'SUCCESS F  S DOLLARJ=$O(^HLTMP("PENDING SEARCH X-REF",DOLLARJ)) Q:DOLLARJ=""  Q:DOLLARJ>OLD  D  Q:SUCCESS
"RTN","HLOF778A",122,0)
 .N TIME S TIME=$O(^HLTMP("PENDING SEARCH X-REF",DOLLARJ,""))
"RTN","HLOF778A",123,0)
 .S:(NOW-$$SEC^XLFDT(TIME)>100) SUCCESS=1
"RTN","HLOF778A",124,0)
 S WORK("DOLLARJ")=DOLLARJ,WORK("NOW")=NOW
"RTN","HLOF778A",125,0)
 Q:WORK("DOLLARJ")]"" 1
"RTN","HLOF778A",126,0)
 L -^HLTMP("PENDING SEARCH X-REF")
"RTN","HLOF778A",127,0)
 Q 0
"RTN","HLOF778A",128,0)
 ;
"RTN","HLOF778A",129,0)
DOWORK(WORK) ;Used by the Process Manager
"RTN","HLOF778A",130,0)
 ;Sets the "SEARCH" x-ref, running 100 seconds behind when the message record was created.
"RTN","HLOF778A",131,0)
 ;
"RTN","HLOF778A",132,0)
 N MSGIEN,TIME
"RTN","HLOF778A",133,0)
 S TIME=0
"RTN","HLOF778A",134,0)
 F  S TIME=$O(^HLTMP("PENDING SEARCH X-REF",WORK("DOLLARJ"),TIME)) Q:'TIME  Q:((WORK("NOW")-$$SEC^XLFDT(TIME))<100)  D
"RTN","HLOF778A",135,0)
 .S MSGIEN=0
"RTN","HLOF778A",136,0)
 .F  S MSGIEN=$O(^HLTMP("PENDING SEARCH X-REF",WORK("DOLLARJ"),TIME,MSGIEN)) Q:'MSGIEN  D
"RTN","HLOF778A",137,0)
 ..N MSG
"RTN","HLOF778A",138,0)
 ..I $$GETMSG^HLOMSG(MSGIEN,.MSG) D
"RTN","HLOF778A",139,0)
 ...Q:'MSG("DT/TM CREATED")
"RTN","HLOF778A",140,0)
 ...I MSG("BATCH") D
"RTN","HLOF778A",141,0)
 ....N HDR
"RTN","HLOF778A",142,0)
 ....F  Q:'$$NEXTMSG^HLOMSG(.MSG,.HDR)  S MSG("HDR",1)=HDR(1),MSG("HDR",2)=HDR(2) D SET(.MSG)
"RTN","HLOF778A",143,0)
 ...E  D
"RTN","HLOF778A",144,0)
 ....D SET(.MSG)
"RTN","HLOF778A",145,0)
 ..K ^HLTMP("PENDING SEARCH X-REF",WORK("DOLLARJ"),TIME,MSGIEN)
"RTN","HLOF778A",146,0)
 L -^HLTMP("PENDING SEARCH X-REF")
"RTN","HLOF778A",147,0)
 Q
"RTN","HLOF778A",148,0)
 ;
"RTN","HLOF778A",149,0)
SET(MSG) ;
"RTN","HLOF778A",150,0)
 ;sets the ^HLB("SEARCH") x-ref
"RTN","HLOF778A",151,0)
 ;
"RTN","HLOF778A",152,0)
 N APP,FS,CS,IEN
"RTN","HLOF778A",153,0)
 I MSG("DIRECTION")'="IN",MSG("DIRECTION")'="OUT" Q
"RTN","HLOF778A",154,0)
 S FS=$E(MSG("HDR",1),4)
"RTN","HLOF778A",155,0)
 Q:FS=""
"RTN","HLOF778A",156,0)
 S CS=$E(MSG("HDR",1),5)
"RTN","HLOF778A",157,0)
 S APP=$S(MSG("DIRECTION")="IN":$P($P(MSG("HDR",1),FS,5),CS),1:$P($P(MSG("HDR",1),FS,3),CS))
"RTN","HLOF778A",158,0)
 I APP="" S APP="UNKNOWN"
"RTN","HLOF778A",159,0)
 I MSG("BATCH") D
"RTN","HLOF778A",160,0)
 .N VALUE
"RTN","HLOF778A",161,0)
 .S VALUE=$P(MSG("HDR",2),FS,4)
"RTN","HLOF778A",162,0)
 .S MSG("MESSAGE TYPE")=$P(VALUE,CS)
"RTN","HLOF778A",163,0)
 .S MSG("EVENT")=$P(VALUE,CS,2)
"RTN","HLOF778A",164,0)
 Q:MSG("MESSAGE TYPE")=""
"RTN","HLOF778A",165,0)
 Q:MSG("EVENT")=""
"RTN","HLOF778A",166,0)
 S IEN=MSG("IEN")
"RTN","HLOF778A",167,0)
 I MSG("BATCH") S IEN=IEN_"^"_MSG("BATCH","CURRENT MESSAGE")
"RTN","HLOF778A",168,0)
 S ^HLB("SEARCH",MSG("DIRECTION"),MSG("DT/TM CREATED"),APP,MSG("MESSAGE TYPE"),MSG("EVENT"),IEN)=""
"RTN","HLOF778A",169,0)
 Q
"RTN","HLOFILER")
0^23^B18562276
"RTN","HLOFILER",1,0)
HLOFILER ;ALB/CJM- Passes messages on the incoming queue to the applications - 10/4/94 1pm
"RTN","HLOFILER",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOFILER",3,0)
 ;
"RTN","HLOFILER",4,0)
 ;GET WORK function for the process running under the Process Manager
"RTN","HLOFILER",5,0)
GETWORK(QUE) ;
"RTN","HLOFILER",6,0)
 ;Input:
"RTN","HLOFILER",7,0)
 ;  QUE - (pass by reference) These subscripts are used:
"RTN","HLOFILER",8,0)
 ;    ("FROM") - sending facility last obtained
"RTN","HLOFILER",9,0)
 ;    ("QUEUE") - name of the queue last obtained
"RTN","HLOFILER",10,0)
 ;Output:
"RTN","HLOFILER",11,0)
 ;  Function returns 1 if success, 0 if no more work
"RTN","HLOFILER",12,0)
 ;  QUE-  updated to identify next queu of messages to process.
"RTN","HLOFILER",13,0)
 ;
"RTN","HLOFILER",14,0)
 N FROM,QUEUE
"RTN","HLOFILER",15,0)
 I '$D(QUE("SYSTEM")) D
"RTN","HLOFILER",16,0)
 .N SYS
"RTN","HLOFILER",17,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOFILER",18,0)
 .S QUE("SYSTEM","NORMAL PURGE")=SYS("NORMAL PURGE")
"RTN","HLOFILER",19,0)
 .S QUE("SYSTEM","ERROR PURGE")=SYS("ERROR PURGE")
"RTN","HLOFILER",20,0)
 S FROM=$G(QUE("FROM")),QUEUE=$G(QUE("QUEUE"))
"RTN","HLOFILER",21,0)
 I ($G(FROM)]""),($G(QUEUE)]"") D
"RTN","HLOFILER",22,0)
 .L -^HLB("QUEUE","IN",FROM,QUEUE)
"RTN","HLOFILER",23,0)
 .F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0  Q:$T
"RTN","HLOFILER",24,0)
 I ($G(FROM)]""),($G(QUEUE)="") D
"RTN","HLOFILER",25,0)
 .F  S FROM=$O(^HLB("QUEUE","IN",FROM)) Q:FROM=""  D  Q:($G(QUEUE)]"")
"RTN","HLOFILER",26,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0 Q:$T
"RTN","HLOFILER",27,0)
 I FROM="" D
"RTN","HLOFILER",28,0)
 .F  S FROM=$O(^HLB("QUEUE","IN",FROM)) Q:FROM=""  D  Q:($G(QUEUE)]"")
"RTN","HLOFILER",29,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0 Q:$T
"RTN","HLOFILER",30,0)
 S QUE("FROM")=FROM,QUE("QUEUE")=QUEUE
"RTN","HLOFILER",31,0)
 Q:(QUEUE]"") 1
"RTN","HLOFILER",32,0)
 Q 0
"RTN","HLOFILER",33,0)
 ;
"RTN","HLOFILER",34,0)
DOWORK(QUEUE) ;sends the messages on the queue
"RTN","HLOFILER",35,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOFILER"
"RTN","HLOFILER",36,0)
 ;
"RTN","HLOFILER",37,0)
 N MSGIEN,DEQUE,QUE
"RTN","HLOFILER",38,0)
 M QUE=QUEUE
"RTN","HLOFILER",39,0)
 S DEQUE=0
"RTN","HLOFILER",40,0)
 S MSGIEN=0
"RTN","HLOFILER",41,0)
 ;
"RTN","HLOFILER",42,0)
 F  S MSGIEN=$O(^HLB("QUEUE","IN",QUEUE("FROM"),QUEUE("QUEUE"),MSGIEN)) Q:'MSGIEN  D  M QUEUE=QUE
"RTN","HLOFILER",43,0)
 .N MCODE,ACTION,QUE,PURGE,ACKTOIEN,NODE
"RTN","HLOFILER",44,0)
 .S NODE=$G(^HLB("QUEUE","IN",QUEUE("FROM"),QUEUE("QUEUE"),MSGIEN))
"RTN","HLOFILER",45,0)
 .S ACTION=$P(NODE,"^",1,2)
"RTN","HLOFILER",46,0)
 .S PURGE=$P(NODE,"^",3)
"RTN","HLOFILER",47,0)
 .S ACKTOIEN=$P(NODE,"^",4)
"RTN","HLOFILER",48,0)
 .D DEQUE(MSGIEN,PURGE,ACKTOIEN)
"RTN","HLOFILER",49,0)
 .I ACTION]"" D
"RTN","HLOFILER",50,0)
 ..N HLMSGIEN,MCODE,DEQUE,DUZ
"RTN","HLOFILER",51,0)
 ..N $ETRAP,$ESTACK S $ETRAP="G ERROR2^HLOFILER"
"RTN","HLOFILER",52,0)
 ..S HLMSGIEN=MSGIEN
"RTN","HLOFILER",53,0)
 ..S MCODE="D "_ACTION
"RTN","HLOFILER",54,0)
 ..N MSGIEN,X
"RTN","HLOFILER",55,0)
 ..D DUZ^XUP(.5)
"RTN","HLOFILER",56,0)
 ..X MCODE
"RTN","HLOFILER",57,0)
 ..;kill the apps variables
"RTN","HLOFILER",58,0)
 ..D
"RTN","HLOFILER",59,0)
 ...N ZTSK
"RTN","HLOFILER",60,0)
 ...D KILL^XUSCLEAN
"RTN","HLOFILER",61,0)
 ;
"RTN","HLOFILER",62,0)
ENDWORK ;where the execution resumes upon an error
"RTN","HLOFILER",63,0)
 D DEQUE()
"RTN","HLOFILER",64,0)
 Q
"RTN","HLOFILER",65,0)
 ;
"RTN","HLOFILER",66,0)
DEQUE(MSGIEN,PURGE,ACKTOIEN) ;
"RTN","HLOFILER",67,0)
 ;Dequeues the message.  Also sets up the purge dt/tm and the completion status.
"RTN","HLOFILER",68,0)
 S:$G(MSGIEN) DEQUE=$G(DEQUE)+1,DEQUE(MSGIEN)=PURGE_"^"_ACKTOIEN
"RTN","HLOFILER",69,0)
 I '$G(MSGIEN)!(DEQUE>25) S MSGIEN=0 D
"RTN","HLOFILER",70,0)
 .F  S MSGIEN=$O(DEQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOFILER",71,0)
 ..N NODE,PURGE,ACKTOIEN
"RTN","HLOFILER",72,0)
 ..S NODE=DEQUE(MSGIEN)
"RTN","HLOFILER",73,0)
 ..S PURGE=$P(NODE,"^"),ACKTOIEN=$P(NODE,"^",2)
"RTN","HLOFILER",74,0)
 ..D DEQUE^HLOQUE(QUEUE("FROM"),QUEUE("QUEUE"),"IN",MSGIEN)
"RTN","HLOFILER",75,0)
 ..S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOFILER",76,0)
 ..Q:NODE=""
"RTN","HLOFILER",77,0)
 ..S $P(NODE,"^",19)=1 ;sets the flag to show that the app handoff was done
"RTN","HLOFILER",78,0)
 ..D:PURGE
"RTN","HLOFILER",79,0)
 ...N STATUS
"RTN","HLOFILER",80,0)
 ...S STATUS=$P(NODE,"^",20)
"RTN","HLOFILER",81,0)
 ...S:STATUS="" $P(NODE,"^",20)="SU",STATUS="SU"
"RTN","HLOFILER",82,0)
 ...S $P(NODE,"^",9)=$$FMADD^XLFDT($$NOW^XLFDT,,$S(STATUS'="SU":24*QUEUE("SYSTEM","ERROR PURGE"),$D(^HLB(MSGIEN,3,1,0)):24*QUEUE("SYSTEM","ERROR PURGE"),1:QUEUE("SYSTEM","NORMAL PURGE")))
"RTN","HLOFILER",83,0)
 ...S ^HLB("AD",$S($E($P(NODE,"^",4))="I":"IN",1:"OUT"),$P(NODE,"^",9),MSGIEN)=""
"RTN","HLOFILER",84,0)
 ...I ACKTOIEN,$D(^HLB(ACKTOIEN,0)) S $P(^HLB(ACKTOIEN,0),"^",9)=$P(NODE,"^",9),^HLB("AD",$S($E($P(NODE,"^",4))="I":"OUT",1:"IN"),$P(NODE,"^",9),ACKTOIEN)=""
"RTN","HLOFILER",85,0)
 ..S ^HLB(MSGIEN,0)=NODE
"RTN","HLOFILER",86,0)
 .K DEQUE S DEQUE=0
"RTN","HLOFILER",87,0)
 Q
"RTN","HLOFILER",88,0)
 ;
"RTN","HLOFILER",89,0)
ERROR ;error trap
"RTN","HLOFILER",90,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOFILER",91,0)
 ;
"RTN","HLOFILER",92,0)
 ;while debugging quit on all errors - returns to the Process Manager error trap
"RTN","HLOFILER",93,0)
 I $G(^HLTMP("LOG ALL ERRORS")) QUIT
"RTN","HLOFILER",94,0)
 ;
"RTN","HLOFILER",95,0)
 D DEQUE()
"RTN","HLOFILER",96,0)
 ;
"RTN","HLOFILER",97,0)
 ;a lot of errors of the same type may indicate an endless loop, so keep  a count
"RTN","HLOFILER",98,0)
 S ^TMP("HL7 ERRORS",$J,$ECODE)=$G(^TMP("HL7 ERRORS",$J,$ECODE))+1
"RTN","HLOFILER",99,0)
 Q:($G(^TMP("HL7 ERRORS",$J,$ECODE))>100)  ;return to the Process Manager error trap
"RTN","HLOFILER",100,0)
 ;
"RTN","HLOFILER",101,0)
 D:'($ECODE[",HL7 APP,") ^%ZTER
"RTN","HLOFILER",102,0)
 D UNWIND^%ZTER
"RTN","HLOFILER",103,0)
 Q
"RTN","HLOFILER",104,0)
 ;
"RTN","HLOFILER",105,0)
ERROR2 ;error trap for application context
"RTN","HLOFILER",106,0)
 D ^%ZTER
"RTN","HLOFILER",107,0)
 ;
"RTN","HLOFILER",108,0)
 ;kill the apps variables
"RTN","HLOFILER",109,0)
 D
"RTN","HLOFILER",110,0)
 .N ZTSK
"RTN","HLOFILER",111,0)
 .D KILL^XUSCLEAN
"RTN","HLOFILER",112,0)
 ;
"RTN","HLOFILER",113,0)
 ;release all the locks the app may have set, except Taskman lock
"RTN","HLOFILER",114,0)
 L ^%ZTSCH("TASK",ZTSK):1
"RTN","HLOFILER",115,0)
 ;reset HLO's lock
"RTN","HLOFILER",116,0)
 L +^HLTMP("HL7 RUNNING PROCESSES",$J):0
"RTN","HLOFILER",117,0)
 ;
"RTN","HLOFILER",118,0)
 S $ETRAP="G ERROR^HLOFILER"
"RTN","HLOFILER",119,0)
 S $ECODE=",HL7 APP,"
"RTN","HLOFILER",120,0)
 Q
"RTN","HLOMSG")
0^24^B44340349
"RTN","HLOMSG",1,0)
HLOMSG ;ALB/CJM-HL7 - APIs for files 777/778 ;02/04/2004
"RTN","HLOMSG",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOMSG",3,0)
 ;
"RTN","HLOMSG",4,0)
GETMSG(IEN,MSG) ;
"RTN","HLOMSG",5,0)
 ;Description: given the message ien=MSGIEN (required), it returns the MSG array containing information about the message, defined below.
"RTN","HLOMSG",6,0)
 ;Input:
"RTN","HLOMSG",7,0)
 ;  IEN - the ien of the message in file 778
"RTN","HLOMSG",8,0)
 ;Output:
"RTN","HLOMSG",9,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOMSG",10,0)
 ;  MSG (pass by reference, required) These are the subscripts returned:
"RTN","HLOMSG",11,0)
 ;
"RTN","HLOMSG",12,0)
 ;   "ACK BY" - msg id of msg that acknowledges this one
"RTN","HLOMSG",13,0)
 ;   "ACK BY IEN" - msg IEN of msg that acknowledges this one.  If the message is in the batch, the value is <ien>^<subien>
"RTN","HLOMSG",14,0)
 ;   "ACK TO" - msg id of msg that this msg acknowledges
"RTN","HLOMSG",15,0)
 ;   "ACK TO IEN" - msg IEN of msg that this msg acknowledges. If the message is in a batch, the value is <ien>^<subien>
"RTN","HLOMSG",16,0)
 ;  "BATCH"  = 1 if this is a batch message, 0  if not
"RTN","HLOMSG",17,0)
 ;     "CURRENT MESSAGE" - defined only for batch messages -  a counter used during building and parsing messages to indicate the current message.  It will be set to 0 initially.
"RTN","HLOMSG",18,0)
 ;  "BODY" - ptr to file 778 which contains the body of the message.
"RTN","HLOMSG",19,0)
 ;  "DIRECTION" - "IN" if incoming, "OUT" if outgoing
"RTN","HLOMSG",20,0)
 ;  "DT/TM" - date/time the message was sent or received
"RTN","HLOMSG",21,0)
 ;  "DT/TM CREATED" - date/time the record was created (.01 field, file #777)
"RTN","HLOMSG",22,0)
 ;  "LINE COUNT" -  a counter used during building and parsing of
"RTN","HLOMSG",23,0)
 ;     messages to indicate the current line within the message. For
"RTN","HLOMSG",24,0)
 ;     batch messages where each message within the batch is stored
"RTN","HLOMSG",25,0)
 ;     separately, this field indicates the position within the current
"RTN","HLOMSG",26,0)
 ;     individual message
"RTN","HLOMSG",27,0)
 ;  "HDR" - the header segment, NOT parsed, as HDR(1) and HDR(2)
"RTN","HLOMSG",28,0)
 ;  "ID" - Message Control ID for an individual message, Batch Control ID for a batch message
"RTN","HLOMSG",29,0)
 ;  "IEN" - ien, file 778
"RTN","HLOMSG",30,0)
 ;  "EVENT" - HL7 event, only defined if NOT batch
"RTN","HLOMSG",31,0)
 ;  "MESSAGE TYPE" - HL7 message type, only defined if NOT batch
"RTN","HLOMSG",32,0)
 ;  "STATUS" - the completion status
"RTN","HLOMSG",33,0)
 ;
"RTN","HLOMSG",34,0)
 ;     These are lower level subscripts of "STATUS":
"RTN","HLOMSG",35,0)
 ;     "ACCEPT ACK RESPONSE" - the application's <tag>^<rtn> to Xecute when the accept ack is received
"RTN","HLOMSG",36,0)
 ;     "ACCEPT ACK'D" - 1 if an accept ack was sent or received in response to this message
"RTN","HLOMSG",37,0)
 ;     "APP ACK RESPONSE" - the application's <tag>^<rtn> to Xecute when app ack is received
"RTN","HLOMSG",38,0)
 ;     "APP ACK'D" - 1 if an application ack was sent or received in response to this message
"RTN","HLOMSG",39,0)
 ;     "ERROR TEXT" - if in error status, a description of the error
"RTN","HLOMSG",40,0)
 ;     "LINK NAME" the link the message was transmitted through
"RTN","HLOMSG",41,0)
 ;     "PORT" - remote port over which the message was transmitted
"RTN","HLOMSG",42,0)
 ;     "PURGE" - scheduled purge dt/tm
"RTN","HLOMSG",43,0)
 ;     "QUEUE" - the queue that the message was placed on
"RTN","HLOMSG",44,0)
 ;
"RTN","HLOMSG",45,0)
 K MSG
"RTN","HLOMSG",46,0)
 Q:'$G(IEN) 0
"RTN","HLOMSG",47,0)
 N NODE
"RTN","HLOMSG",48,0)
 S MSG("IEN")=IEN
"RTN","HLOMSG",49,0)
 S NODE=$G(^HLB(IEN,0))
"RTN","HLOMSG",50,0)
 S MSG("ID")=$P(NODE,"^")
"RTN","HLOMSG",51,0)
 S MSG("BODY")=$P(NODE,"^",2)
"RTN","HLOMSG",52,0)
 Q:'MSG("BODY") 0
"RTN","HLOMSG",53,0)
 S MSG("DIRECTION")=$S($E($P(NODE,"^",4))="O":"OUT",$E($P(NODE,"^",4))="I":"IN",1:"")
"RTN","HLOMSG",54,0)
 S MSG("ACK TO")=$P(NODE,"^",3)
"RTN","HLOMSG",55,0)
 S MSG("ACK BY")=$P(NODE,"^",7)
"RTN","HLOMSG",56,0)
 I MSG("ACK TO")]"" S MSG("ACK TO IEN")=$$ACKTOIEN^HLOMSG1($P(NODE,"^"),MSG("ACK TO"))
"RTN","HLOMSG",57,0)
 I MSG("ACK BY")]"" S MSG("ACK BY IEN")=$$ACKBYIEN^HLOMSG1($P(NODE,"^"),MSG("ACK BY"))
"RTN","HLOMSG",58,0)
 S MSG("DT/TM")=$P(NODE,"^",16)
"RTN","HLOMSG",59,0)
 S MSG("STATUS")=$P(NODE,"^",20)
"RTN","HLOMSG",60,0)
 ;
"RTN","HLOMSG",61,0)
 D
"RTN","HLOMSG",62,0)
 .N NODE4
"RTN","HLOMSG",63,0)
 .S NODE4=$G(^HLB(IEN,4))
"RTN","HLOMSG",64,0)
 .S MSG("STATUS","QUEUE")=$P(NODE,"^",6)
"RTN","HLOMSG",65,0)
 .S MSG("STATUS","LINK NAME")=$P(NODE,"^",5)
"RTN","HLOMSG",66,0)
 .S MSG("STATUS","PORT")=$P(NODE,"^",8)
"RTN","HLOMSG",67,0)
 .S MSG("STATUS","PURGE")=$P(NODE,"^",9)
"RTN","HLOMSG",68,0)
 .S MSG("STATUS","ERROR TEXT")=$P(NODE,"^",21)
"RTN","HLOMSG",69,0)
 .S MSG("STATUS","APP ACK RESPONSE")=$P(NODE,"^",10,11)
"RTN","HLOMSG",70,0)
 .I MSG("STATUS","APP ACK RESPONSE")="^" S MSG("STATUS","APP ACK RESPONSE")=""
"RTN","HLOMSG",71,0)
 .S MSG("STATUS","ACCEPT ACK RESPONSE")=$P(NODE,"^",12,13)
"RTN","HLOMSG",72,0)
 .I MSG("STATUS","ACCEPT ACK RESPONSE")="^" S MSG("STATUS","ACCEPT ACK RESPONSE")=""
"RTN","HLOMSG",73,0)
 .S MSG("STATUS","ACCEPT ACK'D")=$P(NODE,"^",17)
"RTN","HLOMSG",74,0)
 .S MSG("STATUS","APP ACK'D")=$P(NODE,"^",18)
"RTN","HLOMSG",75,0)
 .S MSG("STATUS")=$P(NODE,"^",20)
"RTN","HLOMSG",76,0)
 .S MSG("STATUS","APP HANDOFF")=$P(NODE,"^",19)
"RTN","HLOMSG",77,0)
 .S MSG("STATUS","ACCEPT ACK DT/TM")=$P(NODE4,"^")
"RTN","HLOMSG",78,0)
 .S MSG("STATUS","ACCEPT ACK ID")=$P(NODE4,"^",2)
"RTN","HLOMSG",79,0)
 .S MSG("STATUS","ACCEPT ACK MSA")=$P(NODE4,"^",3,99)
"RTN","HLOMSG",80,0)
 ;
"RTN","HLOMSG",81,0)
 S NODE=$G(^HLA(MSG("BODY"),0))
"RTN","HLOMSG",82,0)
 S MSG("DT/TM CREATED")=+NODE
"RTN","HLOMSG",83,0)
 S MSG("BATCH")=+$P(NODE,"^",2)
"RTN","HLOMSG",84,0)
 I MSG("BATCH") S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOMSG",85,0)
 I 'MSG("BATCH") D
"RTN","HLOMSG",86,0)
 .S MSG("MESSAGE TYPE")=$P(NODE,"^",3)
"RTN","HLOMSG",87,0)
 .S MSG("EVENT")=$P(NODE,"^",4)
"RTN","HLOMSG",88,0)
 S MSG("LINE COUNT")=0
"RTN","HLOMSG",89,0)
 S MSG("HDR",1)=$G(^HLB(IEN,1))
"RTN","HLOMSG",90,0)
 S MSG("HDR",2)=$G(^HLB(IEN,2))
"RTN","HLOMSG",91,0)
 Q 1
"RTN","HLOMSG",92,0)
 ;
"RTN","HLOMSG",93,0)
HLNEXT(MSG,SEG) ;
"RTN","HLOMSG",94,0)
 ;Description:  Returns the next segment as a set of lines stored in SEG.
"RTN","HLOMSG",95,0)
 ;Input:
"RTN","HLOMSG",96,0)
 ;  MSG (pass by reference, required)
"RTN","HLOMSG",97,0)
 ;Output:
"RTN","HLOMSG",98,0)
 ;  Function returns 1 on success, 0 on failure (no more segments)
"RTN","HLOMSG",99,0)
 ;  SEG (pass by reference, required)
"RTN","HLOMSG",100,0)
 ;
"RTN","HLOMSG",101,0)
 K SEG
"RTN","HLOMSG",102,0)
 Q:MSG("LINE COUNT")=-1 0
"RTN","HLOMSG",103,0)
 I 'MSG("BATCH") D
"RTN","HLOMSG",104,0)
 .N I,J,NODE,START
"RTN","HLOMSG",105,0)
 .S START=0
"RTN","HLOMSG",106,0)
 .S J=1,I=MSG("LINE COUNT")
"RTN","HLOMSG",107,0)
 .F  S I=$O(^HLA(MSG("BODY"),1,I)) Q:'I  S NODE=$G(^HLA(MSG("BODY"),1,I,0)) Q:(START&(NODE=""))  I NODE'="" S SEG(J)=NODE,J=J+1,START=1
"RTN","HLOMSG",108,0)
 .I 'I D
"RTN","HLOMSG",109,0)
 ..S MSG("LINE COUNT")=-1
"RTN","HLOMSG",110,0)
 .E  S MSG("LINE COUNT")=I
"RTN","HLOMSG",111,0)
 I MSG("BATCH") D
"RTN","HLOMSG",112,0)
 .N I,J,NODE,START
"RTN","HLOMSG",113,0)
 .S J=1,I=MSG("LINE COUNT"),START=0
"RTN","HLOMSG",114,0)
 .F  S I=$O(^HLA(MSG("BODY"),2,MSG("BATCH","CURRENT MESSAGE"),1,I)) Q:'I  S NODE=$G(^HLA(MSG("BODY"),2,MSG("BATCH","CURRENT MESSAGE"),1,I,0)) Q:(START&(NODE=""))  I NODE'="" S SEG(J)=NODE,J=J+1,START=1
"RTN","HLOMSG",115,0)
 .I 'I D
"RTN","HLOMSG",116,0)
 ..S MSG("LINE COUNT")=-1
"RTN","HLOMSG",117,0)
 .E  S MSG("LINE COUNT")=I
"RTN","HLOMSG",118,0)
 Q $S($D(SEG):1,1:0)
"RTN","HLOMSG",119,0)
 ;
"RTN","HLOMSG",120,0)
NEXTMSG(MSG,HDR) ;
"RTN","HLOMSG",121,0)
 ;Advances to the next message in the batch
"RTN","HLOMSG",122,0)
 ;Input:
"RTN","HLOMSG",123,0)
 ;  MSG (pass by reference, required) - defined by $$GETMSG()
"RTN","HLOMSG",124,0)
 ;Output:
"RTN","HLOMSG",125,0)
 ;  Function returns 1 on success, 0 if no more messages
"RTN","HLOMSG",126,0)
 ;  MSG - updated with current position in the message
"RTN","HLOMSG",127,0)
 ;  HDR (pass by reference, required) returns the header as an array of lines
"RTN","HLOMSG",128,0)
 ;
"RTN","HLOMSG",129,0)
 ;
"RTN","HLOMSG",130,0)
 K HDR
"RTN","HLOMSG",131,0)
 S MSG("LINE COUNT")=0
"RTN","HLOMSG",132,0)
 N SUBIEN,I
"RTN","HLOMSG",133,0)
 ;
"RTN","HLOMSG",134,0)
 ;if completed parsing, don't start over
"RTN","HLOMSG",135,0)
 I MSG("BATCH","CURRENT MESSAGE")=-1 Q 0
"RTN","HLOMSG",136,0)
 ;
"RTN","HLOMSG",137,0)
 S I=$O(^HLB(MSG("IEN"),3,"B",MSG("BATCH","CURRENT MESSAGE")))
"RTN","HLOMSG",138,0)
 I 'I S MSG("BATCH","CURRENT MESSAGE")=-1 Q 0
"RTN","HLOMSG",139,0)
 S MSG("BATCH","CURRENT MESSAGE")=I
"RTN","HLOMSG",140,0)
 S SUBIEN=$O(^HLB(MSG("IEN"),3,"B",I,0))
"RTN","HLOMSG",141,0)
 S HDR(1)=$G(^HLB(MSG("IEN"),3,SUBIEN,1))
"RTN","HLOMSG",142,0)
 S HDR(2)=$G(^HLB(MSG("IEN"),3,SUBIEN,2))
"RTN","HLOMSG",143,0)
 Q $S($D(HDR):1,1:0)
"RTN","HLOMSG",144,0)
 ;
"RTN","HLOMSG",145,0)
ADDSEG(HLMSTATE,SEG) ;Adds a segment to the message.
"RTN","HLOMSG",146,0)
 ;Input:
"RTN","HLOMSG",147,0)
 ;  HLMSTATE() - (pass by reference, required)
"RTN","HLOMSG",148,0)
 ;  SEG() - (pass by reference, required) The segment as lines SEG(<i>)
"RTN","HLOMSG",149,0)
 ;
"RTN","HLOMSG",150,0)
 ;Output:
"RTN","HLOMSG",151,0)
 ;   HLMSTATE()
"RTN","HLOMSG",152,0)
 ;
"RTN","HLOMSG",153,0)
 N I,J S I=0
"RTN","HLOMSG",154,0)
 S J=HLMSTATE("LINE COUNT")
"RTN","HLOMSG",155,0)
 ;
"RTN","HLOMSG",156,0)
 ;insure a blank line between segments
"RTN","HLOMSG",157,0)
 I J S J=J+1,HLMSTATE("UNSTORED LINES",$S(HLMSTATE("BATCH"):HLMSTATE("BATCH","CURRENT MESSAGE"),1:1),HLMSTATE("CURRENT SEGMENT"),J)=""
"RTN","HLOMSG",158,0)
 ;
"RTN","HLOMSG",159,0)
 S HLMSTATE("CURRENT SEGMENT")=HLMSTATE("CURRENT SEGMENT")+1
"RTN","HLOMSG",160,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOMSG",161,0)
 .S J=J+1
"RTN","HLOMSG",162,0)
 .S HLMSTATE("UNSTORED LINES",$S(HLMSTATE("BATCH"):HLMSTATE("BATCH","CURRENT MESSAGE"),1:1),HLMSTATE("CURRENT SEGMENT"),J)=SEG(I),HLMSTATE("UNSTORED LINES")=HLMSTATE("UNSTORED LINES")+$L(SEG(I))+50
"RTN","HLOMSG",163,0)
 .I HLMSTATE("UNSTORED LINES")>HLMSTATE("SYSTEM","BUFFER") D
"RTN","HLOMSG",164,0)
 ..I HLMSTATE("DIRECTION")="IN",$$SAVEMSG^HLOF778(.HLMSTATE) Q
"RTN","HLOMSG",165,0)
 ..I HLMSTATE("DIRECTION")="OUT",$$SAVEMSG^HLOF777(.HLMSTATE)
"RTN","HLOMSG",166,0)
 ;
"RTN","HLOMSG",167,0)
 S HLMSTATE("LINE COUNT")=J
"RTN","HLOMSG",168,0)
 Q
"RTN","HLOMSG",169,0)
 ;
"RTN","HLOMSG",170,0)
ADDMSG(HLMSTATE,PARMS) ;
"RTN","HLOMSG",171,0)
 ;For outgoing messages, adds a message in the batch. There is no MSH yet, just the message type and event.  
"RTN","HLOMSG",172,0)
 ;Input:
"RTN","HLOMSG",173,0)
 ;  HLMSTATE() - (pass by reference, required)
"RTN","HLOMSG",174,0)
 ;  PARMS("EVENT")
"RTN","HLOMSG",175,0)
 ;  PARMS("MESSAGE TYPE")
"RTN","HLOMSG",176,0)
 ;
"RTN","HLOMSG",177,0)
 ;Output:
"RTN","HLOMSG",178,0)
 ;   HLMSTATE() - (pass by reference, required)
"RTN","HLOMSG",179,0)
 ;
"RTN","HLOMSG",180,0)
 N I
"RTN","HLOMSG",181,0)
 S I=HLMSTATE("BATCH","CURRENT MESSAGE")+1,HLMSTATE("BATCH","CURRENT MESSAGE")=I
"RTN","HLOMSG",182,0)
 S HLMSTATE("UNSTORED LINES",I)=PARMS("MESSAGE TYPE")_"^"_PARMS("EVENT")
"RTN","HLOMSG",183,0)
 M:$G(PARMS("ACK TO"))]"" HLMSTATE("BATCH","ACK TO",I)=PARMS("ACK TO")
"RTN","HLOMSG",184,0)
 S HLMSTATE("CURRENT SEGMENT")=0
"RTN","HLOMSG",185,0)
 S HLMSTATE("LINE COUNT")=0
"RTN","HLOMSG",186,0)
 S HLMSTATE("UNSTORED LINES")=HLMSTATE("UNSTORED LINES")+100
"RTN","HLOMSG",187,0)
 Q
"RTN","HLOMSG",188,0)
 ;
"RTN","HLOMSG",189,0)
ADDMSG2(HLMSTATE,MSH) ;
"RTN","HLOMSG",190,0)
 ;For incoming messages adds a message to the batch. This differs from ADDMSG in that the MSH segment is passed in to be stored in file 778.
"RTN","HLOMSG",191,0)
 ;Input:
"RTN","HLOMSG",192,0)
 ;  HLMSTATE() - (pass by reference, required)
"RTN","HLOMSG",193,0)
 ;  MSH(<i>) - the MSH segment as a set of lines
"RTN","HLOMSG",194,0)
 ;
"RTN","HLOMSG",195,0)
 ;Output:
"RTN","HLOMSG",196,0)
 ;   HLMSTATE() - (pass by reference, required)
"RTN","HLOMSG",197,0)
 ;
"RTN","HLOMSG",198,0)
 N FS,CS,VALUE
"RTN","HLOMSG",199,0)
 S HLMSTATE("BATCH","CURRENT MESSAGE")=HLMSTATE("BATCH","CURRENT MESSAGE")+1
"RTN","HLOMSG",200,0)
 S FS=$E(MSH(1),4)
"RTN","HLOMSG",201,0)
 S CS=$E(MSH(1),5)
"RTN","HLOMSG",202,0)
 S VALUE=$P(MSH(2),FS,4)
"RTN","HLOMSG",203,0)
 S HLMSTATE("UNSTORED LINES",HLMSTATE("BATCH","CURRENT MESSAGE"))=$P(VALUE,CS)_"^"_$P(VALUE,CS,2)
"RTN","HLOMSG",204,0)
 S HLMSTATE("UNSTORED MSH")=1
"RTN","HLOMSG",205,0)
 M HLMSTATE("UNSTORED MSH",HLMSTATE("BATCH","CURRENT MESSAGE"))=MSH
"RTN","HLOMSG",206,0)
 S HLMSTATE("CURRENT SEGMENT")=0
"RTN","HLOMSG",207,0)
 S HLMSTATE("LINE COUNT")=0
"RTN","HLOMSG",208,0)
 S HLMSTATE("UNSTORED LINES")=HLMSTATE("UNSTORED LINES")+200
"RTN","HLOMSG",209,0)
 I HLMSTATE("UNSTORED LINES")>HLMSTATE("SYSTEM","BUFFER"),$$SAVEMSG^HLOF778(.HLMSTATE) ;first stores stuff in 777, then headers in file 778
"RTN","HLOMSG",210,0)
 Q
"RTN","HLOMSG1")
0^44^B6084209
"RTN","HLOMSG1",1,0)
HLOMSG1 ;ALB/CJM-HL7 - APIs for files 777/778 (CONTINUED) ;02/04/2004
"RTN","HLOMSG1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOMSG1",3,0)
 ;
"RTN","HLOMSG1",4,0)
FINDMSG(MSGID,LIST) ;
"RTN","HLOMSG1",5,0)
 ;Given a message id, this function finds the file 778 entries having that message id.  The count is returned as the function value. If the message
"RTN","HLOMSG1",6,0)
 ;is within a batch, it might be in the subfile.  The list of found
"RTN","HLOMSG1",7,0)
 ;records is in the format LIST(1)=<IEN>^<SUBIEN>,LIST(2)=<IEN>^<SUBIEN>,
"RTN","HLOMSG1",8,0)
 ;etc., where SUBIEN="" if the message is not within a batch.
"RTN","HLOMSG1",9,0)
 ;
"RTN","HLOMSG1",10,0)
 N COUNT,MSG
"RTN","HLOMSG1",11,0)
 K LIST
"RTN","HLOMSG1",12,0)
 Q:$G(MSGID)="" 0
"RTN","HLOMSG1",13,0)
 S (MSG,COUNT)=0
"RTN","HLOMSG1",14,0)
 F  S MSG=$O(^HLB("B",MSGID,MSG)) Q:'MSG  S COUNT=COUNT+1,LIST(COUNT)=MSG
"RTN","HLOMSG1",15,0)
 S MSG=""
"RTN","HLOMSG1",16,0)
 F  S MSG=$O(^HLB("AE",MSGID,MSG)) Q:MSG=""  S COUNT=COUNT+1,LIST(COUNT)=MSG
"RTN","HLOMSG1",17,0)
 Q COUNT
"RTN","HLOMSG1",18,0)
 ;
"RTN","HLOMSG1",19,0)
ACKTOIEN(MSGID,ACKTO) ;
"RTN","HLOMSG1",20,0)
 ;finds the ien of the initial message
"RTN","HLOMSG1",21,0)
 ;Input:
"RTN","HLOMSG1",22,0)
 ;  MSGID - the msg id of the ack message
"RTN","HLOMSG1",23,0)
 ;  ACKTO - msgid of the original message
"RTN","HLOMSG1",24,0)
 ;Output: Function returns "" if not found, otherwise the IEN, or, if the message is in a batch, the <ien>^<subien>
"RTN","HLOMSG1",25,0)
 ;
"RTN","HLOMSG1",26,0)
 N LIST,RETURN
"RTN","HLOMSG1",27,0)
 S RETURN=""
"RTN","HLOMSG1",28,0)
 I $$FINDMSG(ACKTO,.LIST) D
"RTN","HLOMSG1",29,0)
 .N COUNT
"RTN","HLOMSG1",30,0)
 .S COUNT=0
"RTN","HLOMSG1",31,0)
 .F  S COUNT=$O(LIST(COUNT)) Q:'COUNT  D  Q:RETURN
"RTN","HLOMSG1",32,0)
 ..N IEN,SUBIEN
"RTN","HLOMSG1",33,0)
 ..S IEN=$P(LIST(COUNT),"^"),SUBIEN=$P(LIST(COUNT),"^",2)
"RTN","HLOMSG1",34,0)
 ..I 'SUBIEN D
"RTN","HLOMSG1",35,0)
 ...I $P($G(^HLB(IEN,0)),"^",7)=MSGID S RETURN=IEN
"RTN","HLOMSG1",36,0)
 ..E  D
"RTN","HLOMSG1",37,0)
 ...I $P($G(^HLB(IEN,3,SUBIEN,0)),"^",4)=MSGID S RETURN=IEN_"^"_SUBIEN
"RTN","HLOMSG1",38,0)
 Q RETURN
"RTN","HLOMSG1",39,0)
 ;
"RTN","HLOMSG1",40,0)
 ;
"RTN","HLOMSG1",41,0)
ACKBYIEN(MSGID,ACKBY) ;
"RTN","HLOMSG1",42,0)
 ;finds the ien of the ack message
"RTN","HLOMSG1",43,0)
 ;Input:
"RTN","HLOMSG1",44,0)
 ;  MSGID - the msg id of the initial message
"RTN","HLOMSG1",45,0)
 ;  ACKBY - msgid of the ack message
"RTN","HLOMSG1",46,0)
 ;Output: Function returns "" if not found, otherwise the IEN, or, if the message is in a batch, the <ien>^<subien>
"RTN","HLOMSG1",47,0)
 ;
"RTN","HLOMSG1",48,0)
 N LIST,RETURN
"RTN","HLOMSG1",49,0)
 S RETURN=""
"RTN","HLOMSG1",50,0)
 I $$FINDMSG(ACKBY,.LIST) D
"RTN","HLOMSG1",51,0)
 .N COUNT
"RTN","HLOMSG1",52,0)
 .S COUNT=0
"RTN","HLOMSG1",53,0)
 .F  S COUNT=$O(LIST(COUNT)) Q:'COUNT  D  Q:RETURN
"RTN","HLOMSG1",54,0)
 ..N IEN,SUBIEN
"RTN","HLOMSG1",55,0)
 ..S IEN=$P(LIST(COUNT),"^"),SUBIEN=$P(LIST(COUNT),"^",2)
"RTN","HLOMSG1",56,0)
 ..I 'SUBIEN D
"RTN","HLOMSG1",57,0)
 ...I $P($G(^HLB(IEN,0)),"^",3)=MSGID S RETURN=IEN
"RTN","HLOMSG1",58,0)
 ..E  D
"RTN","HLOMSG1",59,0)
 ...I $P($G(^HLB(IEN,3,SUBIEN,0)),"^",3)=MSGID S RETURN=IEN_"^"_SUBIEN
"RTN","HLOMSG1",60,0)
 Q RETURN
"RTN","HLOMSG1",61,0)
 ;
"RTN","HLOMSG1",62,0)
GETMSGB(MSG,SUBIEN,SUBMSG) ;
"RTN","HLOMSG1",63,0)
 ;gets a message from within a batch
"RTN","HLOMSG1",64,0)
 ;Input:
"RTN","HLOMSG1",65,0)
 ;  MSG (required, pass by reference) from $$GETMSG
"RTN","HLOMSG1",66,0)
 ;  SUBIEN - the subrecord #
"RTN","HLOMSG1",67,0)
 ;Output:
"RTN","HLOMSG1",68,0)
 ;  SUBMSG (pass by reference)  These subscripts are returned:
"RTN","HLOMSG1",69,0)
 ;    "ACK BY" - if this msg was app acked, the msg id if this msg that was app
"RTN","HLOMSG1",70,0)
 ;    "ACK TO" - if this msg is an app ack, the msg id of msg being acked
"RTN","HLOMSG1",71,0)
 ;    "EVENT" - HL7 Event
"RTN","HLOMSG1",72,0)
 ;    "HDR",1) - fields 1-6 of the header segment
"RTN","HLOMSG1",73,0)
 ;    "HDR",2) - fields 7-End of the header segment
"RTN","HLOMSG1",74,0)
 ;    "ID" - Message Control ID
"RTN","HLOMSG1",75,0)
 ;    "MESSAGE TYPE" - HL7 Message Type
"RTN","HLOMSG1",76,0)
 ;    "STATUS" - completion status for the individual message
"RTN","HLOMSG1",77,0)
 ;
"RTN","HLOMSG1",78,0)
 N NODE
"RTN","HLOMSG1",79,0)
 S NODE=$G(^HLB(MSG("IEN"),3,SUBIEN,0))
"RTN","HLOMSG1",80,0)
 S SUBMSG("ID")=$P(NODE,"^",2)
"RTN","HLOMSG1",81,0)
 S SUBMSG("ACK TO")=$P(NODE,"^",3)
"RTN","HLOMSG1",82,0)
 S SUBMSG("ACK BY")=$P(NODE,"^",4)
"RTN","HLOMSG1",83,0)
 S SUBMSG("STATUS")=$P(NODE,"^",5)
"RTN","HLOMSG1",84,0)
 S SUBMSG("HDR",1)=$G(^HLB(MSG("IEN"),3,SUBIEN,1)),SUBMSG("HDR",2)=$G(^(2))
"RTN","HLOMSG1",85,0)
 S NODE=$G(^HLA(MSG("BODY"),2,SUBIEN,0))
"RTN","HLOMSG1",86,0)
 S SUBMSG("MESSAGE TYPE")=$P(NODE,"^",2)
"RTN","HLOMSG1",87,0)
 S SUBMSG("EVENT")=$P(NODE,"^",3)
"RTN","HLOMSG1",88,0)
 Q
"RTN","HLOPBLD")
0^25^B10420625
"RTN","HLOPBLD",1,0)
HLOPBLD ;ALB/CJM-HL7 - Building segments ;02/04/2004
"RTN","HLOPBLD",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOPBLD",3,0)
 ;
"RTN","HLOPBLD",4,0)
BUILDSEG(HLMSTATE,SEG,TOARY,ERROR) ;Builds the segment from the individual values
"RTN","HLOPBLD",5,0)
 ;Input:
"RTN","HLOPBLD",6,0)
 ;  HLMSTATE() - (pass by reference, required) Used to track the progress of the message. Uses these subscripts:
"RTN","HLOPBLD",7,0)
 ;    ("HDR","FIELD SEPARATOR")
"RTN","HLOPBLD",8,0)
 ;    ("HDR","ENCODING CHARACTERS")
"RTN","HLOPBLD",9,0)
 ;  SEG() - (pass by reference, required) Contains the data.  It must be built by calls to SET^HLOAPI prior to calling $$BUILDSEG.
"RTN","HLOPBLD",10,0)
 ;
"RTN","HLOPBLD",11,0)
 ;Note#1:  The '0' field must be a 3 character segment type
"RTN","HLOPBLD",12,0)
 ;Note#2: ***SEG is killed upon successfully adding the segment***
"RTN","HLOPBLD",13,0)
 ;
"RTN","HLOPBLD",14,0)
 ;Output:
"RTN","HLOPBLD",15,0)
 ;  Function - returns 1 on success, 0 on failure
"RTN","HLOPBLD",16,0)
 ;  TOARY (pass by reference) This will return the segment in an array format TOARY(1),TOARY(2),... For segments that are shorter than the MUMPS maximum string length, there will be only TOARY(1)
"RTN","HLOPBLD",17,0)
 ;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOPBLD",18,0)
 ;
"RTN","HLOPBLD",19,0)
 ;
"RTN","HLOPBLD",20,0)
 K ERROR,TOARY
"RTN","HLOPBLD",21,0)
 N TEMP1,TEMP2,LINE,LAST,SEQ,MAX,COUNT,SEGTYPE
"RTN","HLOPBLD",22,0)
 S COUNT=0
"RTN","HLOPBLD",23,0)
 S MAX=HLMSTATE("SYSTEM","MAXSTRING")-1 ;save some room for the <CR>
"RTN","HLOPBLD",24,0)
 S SEGTYPE=$G(SEG(0,1,1,1))
"RTN","HLOPBLD",25,0)
 S LAST=0,(TEMP1,TEMP2)="",LINE=SEGTYPE_HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOPBLD",26,0)
 F  S SEQ=$O(SEG(LAST)) Q:'SEQ  D
"RTN","HLOPBLD",27,0)
 .S TEMP2="",$P(TEMP2,HLMSTATE("HDR","FIELD SEPARATOR"),$S(LAST=0:SEQ,1:SEQ-LAST+1))=""
"RTN","HLOPBLD",28,0)
 .S TEMP1=TEMP2
"RTN","HLOPBLD",29,0)
 .S LAST=SEQ
"RTN","HLOPBLD",30,0)
 .N REP,LAST
"RTN","HLOPBLD",31,0)
 .S LAST=0
"RTN","HLOPBLD",32,0)
 .F  S REP=$O(SEG(SEQ,LAST)) Q:'REP  D
"RTN","HLOPBLD",33,0)
 ..S TEMP2="",$P(TEMP2,$E(HLMSTATE("HDR","ENCODING CHARACTERS"),2),$S(LAST=0:REP,1:REP-LAST+1))=""
"RTN","HLOPBLD",34,0)
 ..S TEMP1=TEMP1_TEMP2
"RTN","HLOPBLD",35,0)
 ..S LAST=REP
"RTN","HLOPBLD",36,0)
 ..;
"RTN","HLOPBLD",37,0)
 ..N COMP,LAST
"RTN","HLOPBLD",38,0)
 ..S LAST=0
"RTN","HLOPBLD",39,0)
 ..F  S COMP=$O(SEG(SEQ,REP,LAST)) Q:'COMP  D
"RTN","HLOPBLD",40,0)
 ...S TEMP2="",$P(TEMP2,$E(HLMSTATE("HDR","ENCODING CHARACTERS"),1),$S(LAST=0:COMP,1:COMP-LAST+1))=""
"RTN","HLOPBLD",41,0)
 ...S TEMP1=TEMP1_TEMP2
"RTN","HLOPBLD",42,0)
 ...S LAST=COMP
"RTN","HLOPBLD",43,0)
 ...;
"RTN","HLOPBLD",44,0)
 ...N SUBCOMP,LAST
"RTN","HLOPBLD",45,0)
 ...S LAST=0
"RTN","HLOPBLD",46,0)
 ...F  S SUBCOMP=$O(SEG(SEQ,REP,COMP,LAST)) Q:'SUBCOMP  D
"RTN","HLOPBLD",47,0)
 ....N VALUE
"RTN","HLOPBLD",48,0)
 ....S TEMP2="",$P(TEMP2,$E(HLMSTATE("HDR","ENCODING CHARACTERS"),4),$S(LAST=0:SUBCOMP,1:SUBCOMP-LAST+1))=""
"RTN","HLOPBLD",49,0)
 ....S VALUE=$G(SEG(SEQ,REP,COMP,SUBCOMP))
"RTN","HLOPBLD",50,0)
 ....K SEG(SEQ,REP,COMP,SUBCOMP)
"RTN","HLOPBLD",51,0)
 ....S:((SEGTYPE'="MSH")&(SEGTYPE'="BHS"))!(SEQ'=2) VALUE=$$ESCAPE(.HLMSTATE,VALUE)
"RTN","HLOPBLD",52,0)
 ....S TEMP2=TEMP2_VALUE
"RTN","HLOPBLD",53,0)
 ....S TEMP1=TEMP1_TEMP2
"RTN","HLOPBLD",54,0)
 ....I $L(LINE)+$L(TEMP1)<MAX D
"RTN","HLOPBLD",55,0)
 .....S LINE=LINE_TEMP1
"RTN","HLOPBLD",56,0)
 ....E  D
"RTN","HLOPBLD",57,0)
 .....D ADDLINE(.TOARY,LINE_$E(TEMP1,1,MAX-$L(LINE)),.COUNT)
"RTN","HLOPBLD",58,0)
 .....S LINE=$E(TEMP1,MAX-$L(LINE)+1,MAX+100)
"RTN","HLOPBLD",59,0)
 ....S TEMP1=""
"RTN","HLOPBLD",60,0)
 ....S LAST=SUBCOMP
"RTN","HLOPBLD",61,0)
 I $L(LINE) D ADDLINE(.TOARY,LINE,.COUNT)
"RTN","HLOPBLD",62,0)
 K SEG
"RTN","HLOPBLD",63,0)
 Q 1
"RTN","HLOPBLD",64,0)
 ;
"RTN","HLOPBLD",65,0)
ADDLINE(TOARY,LINE,COUNT) ;
"RTN","HLOPBLD",66,0)
 S COUNT=COUNT+1
"RTN","HLOPBLD",67,0)
 S TOARY(COUNT)=LINE
"RTN","HLOPBLD",68,0)
 Q
"RTN","HLOPBLD",69,0)
 ;
"RTN","HLOPBLD",70,0)
ESCAPE(HLMSTATE,VALUE) ;
"RTN","HLOPBLD",71,0)
 ;Replaces the HL7 encoding characters with the corresponding escape sequences and returns the result as the function value
"RTN","HLOPBLD",72,0)
 ;
"RTN","HLOPBLD",73,0)
 N ESC,CHARS,I,NEWVALUE,LEN,CUR
"RTN","HLOPBLD",74,0)
 S CHARS=HLMSTATE("HDR","ENCODING CHARACTERS")
"RTN","HLOPBLD",75,0)
 S ESC=$E(CHARS,3)
"RTN","HLOPBLD",76,0)
 S NEWVALUE="",LEN=$L(VALUE)
"RTN","HLOPBLD",77,0)
 F I=1:1:LEN D
"RTN","HLOPBLD",78,0)
 .S CUR=$E(VALUE,I)
"RTN","HLOPBLD",79,0)
 .S NEWVALUE=NEWVALUE_$S(CUR=ESC:ESC_"E"_ESC,CUR=$E(CHARS,1):ESC_"S"_ESC,CUR=$E(CHARS,4):ESC_"T"_ESC,CUR=$E(CHARS,2):ESC_"R"_ESC,1:CUR)
"RTN","HLOPBLD",80,0)
 Q NEWVALUE
"RTN","HLOPBLD",81,0)
 ;
"RTN","HLOPBLD",82,0)
REPLACE(VALUE,CHAR,STRING) ;
"RTN","HLOPBLD",83,0)
 ;Takes the input string=VALUE and replaces each instance of the character
"RTN","HLOPBLD",84,0)
 ;=CHAR with the string=STRING and returns the resultant string
"RTN","HLOPBLD",85,0)
 ;as the function value
"RTN","HLOPBLD",86,0)
 ;
"RTN","HLOPBLD",87,0)
 N I,NEWVALUE,CURCHAR
"RTN","HLOPBLD",88,0)
 S NEWVALUE=""
"RTN","HLOPBLD",89,0)
 F I=1:1:$L(VALUE) D
"RTN","HLOPBLD",90,0)
 .S CURCHAR=$E(VALUE,I)
"RTN","HLOPBLD",91,0)
 .S NEWVALUE=NEWVALUE_$S(CURCHAR=CHAR:STRING,1:CURCHAR)
"RTN","HLOPBLD",92,0)
 Q NEWVALUE
"RTN","HLOPBLD1")
0^26^B18903926
"RTN","HLOPBLD1",1,0)
HLOPBLD1 ;ALB/CJM-HL7 - Building segments (CONTINUED) ;02/04/2004
"RTN","HLOPBLD1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOPBLD1",3,0)
 ;
"RTN","HLOPBLD1",4,0)
BUILDHDR(HLMSTATE,TYPE,HDR) ;Builds the header segment in 2 lines, line 1 is components 1-6
"RTN","HLOPBLD1",5,0)
 ;Input:
"RTN","HLOPBLD1",6,0)
 ;  HLMSTATE("HDR") - (pass by reference, required) These subscripts are used:
"RTN","HLOPBLD1",7,0)
 ;    "FIELD SEPARATOR"
"RTN","HLOPBLD1",8,0)
 ;    "ENCODING CHARACTERS"
"RTN","HLOPBLD1",9,0)
 ;    "SENDING APPLICATION"
"RTN","HLOPBLD1",10,0)
 ;    "RECEIVING APPLICATION"
"RTN","HLOPBLD1",11,0)
 ;    "RECEIVING FACILITY",1  and ,2  and ,3
"RTN","HLOPBLD1",12,0)
 ;    "DT/TM OF MESSAGE"
"RTN","HLOPBLD1",13,0)
 ;    "SECURITY"
"RTN","HLOPBLD1",14,0)
 ;    "ACCEPT ACK TYPE"
"RTN","HLOPBLD1",15,0)
 ;    "APP ACK TYPE"
"RTN","HLOPBLD1",16,0)
 ;    "PROCESSING ID"
"RTN","HLOPBLD1",17,0)
 ;
"RTN","HLOPBLD1",18,0)
 ;     *MSH ONLY*
"RTN","HLOPBLD1",19,0)
 ;    "CONTINUATION POINTER"
"RTN","HLOPBLD1",20,0)
 ;    "COUNTRY"
"RTN","HLOPBLD1",21,0)
 ;    "EVENT"
"RTN","HLOPBLD1",22,0)
 ;    "MESSAGE STRUCTURE"
"RTN","HLOPBLD1",23,0)
 ;    "MESSAGE TYPE"
"RTN","HLOPBLD1",24,0)
 ;    "PROCESSING MODE"
"RTN","HLOPBLD1",25,0)
 ;    "VERSION"
"RTN","HLOPBLD1",26,0)
 ;
"RTN","HLOPBLD1",27,0)
 ;    *BHS ONLY*
"RTN","HLOPBLD1",28,0)
 ;    "REFERENCE BATCH CONTROL ID"
"RTN","HLOPBLD1",29,0)
 ;
"RTN","HLOPBLD1",30,0)
 ;  HLMSTATE("BATCH")
"RTN","HLOPBLD1",31,0)
 ;  HLMSTATE("BATCH","CURRENT MESSAGE") - batch messages only
"RTN","HLOPBLD1",32,0)
 ;  HLMSTATE("IEN") - ien, file 778
"RTN","HLOPBLD1",33,0)
 ;
"RTN","HLOPBLD1",34,0)
 ;  TYPE - must be either "MSH" or "BHS"
"RTN","HLOPBLD1",35,0)
 ;
"RTN","HLOPBLD1",36,0)
 ;Output:
"RTN","HLOPBLD1",37,0)
 ;  HLMSTATE("HDR") - these subscripts will be added, unless building an MSH within a batch:
"RTN","HLOPBLD1",38,0)
 ;     "SENDING FACILITY",1  and ,2   and ,3
"RTN","HLOPBLD1",39,0)
 ;     "PROCESSING ID"
"RTN","HLOPBLD1",40,0)
 ;     "MESSAGE CONTROL ID"   (MSH ONLY)
"RTN","HLOPBLD1",41,0)
 ;     "BATCH CONTROL ID"     (BHS ONLY)
"RTN","HLOPBLD1",42,0)
 ;     "DT/TM OF MESSAGE"
"RTN","HLOPBLD1",43,0)
 ;  HDR (pass by reference) This will return the segment in an array form at HDR(1),HDR(2) (two lines).
"RTN","HLOPBLD1",44,0)
 ;
"RTN","HLOPBLD1",45,0)
 K HDR
"RTN","HLOPBLD1",46,0)
 N SEG,BATCH,LEN,FS,CS
"RTN","HLOPBLD1",47,0)
 ;
"RTN","HLOPBLD1",48,0)
 ;shortcuts
"RTN","HLOPBLD1",49,0)
 S HDR="HLMSTATE(""HDR"")"
"RTN","HLOPBLD1",50,0)
 S BATCH=HLMSTATE("BATCH")
"RTN","HLOPBLD1",51,0)
 S FS=@HDR@("FIELD SEPARATOR")
"RTN","HLOPBLD1",52,0)
 S CS=$E(@HDR@("ENCODING CHARACTERS"),1)
"RTN","HLOPBLD1",53,0)
 ;
"RTN","HLOPBLD1",54,0)
 S HDR(1)=TYPE_FS_@HDR@("ENCODING CHARACTERS")_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("SENDING APPLICATION")))
"RTN","HLOPBLD1",55,0)
 ;
"RTN","HLOPBLD1",56,0)
 ;If building an MSH segment for a batch message, these parameters should already be determined
"RTN","HLOPBLD1",57,0)
 D:(('HLMSTATE("BATCH"))!(TYPE="BHS"))
"RTN","HLOPBLD1",58,0)
 .N PORT
"RTN","HLOPBLD1",59,0)
 .S PORT=$$RTRNPORT^HLOAPP($G(@HDR@("SENDING APPLICATION")))
"RTN","HLOPBLD1",60,0)
 .S:'PORT PORT=HLMSTATE("SYSTEM","PORT")
"RTN","HLOPBLD1",61,0)
 .S @HDR@("SENDING FACILITY",1)=HLMSTATE("SYSTEM","STATION")
"RTN","HLOPBLD1",62,0)
 .S @HDR@("SENDING FACILITY",2)=HLMSTATE("SYSTEM","DOMAIN")_":"_PORT
"RTN","HLOPBLD1",63,0)
 .S @HDR@("SENDING FACILITY",3)="DNS"
"RTN","HLOPBLD1",64,0)
 .;
"RTN","HLOPBLD1",65,0)
 .;create the unique message ids, using the ien from file 778
"RTN","HLOPBLD1",66,0)
 .S:TYPE="BHS" @HDR@("BATCH CONTROL ID")=HLMSTATE("SYSTEM","STATION")_" "_HLMSTATE("IEN")
"RTN","HLOPBLD1",67,0)
 .S:TYPE="MSH" @HDR@("MESSAGE CONTROL ID")=HLMSTATE("SYSTEM","STATION")_" "_HLMSTATE("IEN")
"RTN","HLOPBLD1",68,0)
 .;
"RTN","HLOPBLD1",69,0)
 .S @HDR@("PROCESSING ID")=HLMSTATE("SYSTEM","PROCESSING ID")
"RTN","HLOPBLD1",70,0)
 .S @HDR@("DT/TM OF MESSAGE")=$$HLDATE^HLFNC($$NOW^XLFDT,"TS")
"RTN","HLOPBLD1",71,0)
 ;
"RTN","HLOPBLD1",72,0)
 S HDR(1)=HDR(1)_FS_$G(@HDR@("SENDING FACILITY",1))_CS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("SENDING FACILITY",2)))_CS_"DNS"
"RTN","HLOPBLD1",73,0)
 S HDR(1)=HDR(1)_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,@HDR@("RECEIVING APPLICATION"))_FS_$G(@HDR@("RECEIVING FACILITY",1))_CS_$$ESCAPE^HLOPBLD(.HLMSTATE,@HDR@("RECEIVING FACILITY",2))_CS_@HDR@("RECEIVING FACILITY",3)
"RTN","HLOPBLD1",74,0)
 S HDR(2)=FS_@HDR@("DT/TM OF MESSAGE")_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("SECURITY")))
"RTN","HLOPBLD1",75,0)
 ;
"RTN","HLOPBLD1",76,0)
 I TYPE="MSH" D
"RTN","HLOPBLD1",77,0)
 .N ID
"RTN","HLOPBLD1",78,0)
 .S HDR(2)=HDR(2)_FS_@HDR@("MESSAGE TYPE")_CS_@HDR@("EVENT")_CS_$G(@HDR@("MESSAGE STRUCTURE"))
"RTN","HLOPBLD1",79,0)
 .S:BATCH ID=@HDR@("BATCH CONTROL ID")_$$ESCAPE^HLOPBLD(.HLMSTATE,"-")_$G(HLMSTATE("BATCH","CURRENT MESSAGE"))
"RTN","HLOPBLD1",80,0)
 .S:'BATCH ID=@HDR@("MESSAGE CONTROL ID")
"RTN","HLOPBLD1",81,0)
 .S HDR(2)=HDR(2)_FS_ID_FS_@HDR@("PROCESSING ID")_CS_$G(@HDR@("PROCESSING MODE"))_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,@HDR@("VERSION"))
"RTN","HLOPBLD1",82,0)
 .S HDR(2)=HDR(2)_FS_FS_$G(@HDR@("CONTINUATION POINTER"))_FS_@HDR@("ACCEPT ACK TYPE")_FS_@HDR@("APP ACK TYPE")_FS_$G(@HDR@("COUNTRY"))
"RTN","HLOPBLD1",83,0)
 ;
"RTN","HLOPBLD1",84,0)
 I TYPE="BHS" D
"RTN","HLOPBLD1",85,0)
 .N TEXT
"RTN","HLOPBLD1",86,0)
 .S TEXT="PROCESSING ID"_$$ESCAPE^HLOPBLD(.HLMSTATE,"=")_@HDR@("PROCESSING ID")_" "
"RTN","HLOPBLD1",87,0)
 .I $L($G(@HDR@("ACCEPT ACK TYPE"))) S TEXT=TEXT_"ACCEPT ACK TYPE"_$$ESCAPE^HLOPBLD(.HLMSTATE,"=")_@HDR@("ACCEPT ACK TYPE")_" "
"RTN","HLOPBLD1",88,0)
 .I $L($G(@HDR@("APP ACK TYPE"))) S TEXT=TEXT_"APP ACK TYPE"_$$ESCAPE^HLOPBLD(.HLMSTATE,"=")_@HDR@("APP ACK TYPE")_" "
"RTN","HLOPBLD1",89,0)
 .S HDR(2)=HDR(2)_FS_TEXT_FS_FS_@HDR@("BATCH CONTROL ID")_FS_$G(@HDR@("REFERENCE BATCH CONTROL ID"))
"RTN","HLOPBLD1",90,0)
 Q
"RTN","HLOPOST")
0^27^B3878072
"RTN","HLOPOST",1,0)
HLOPOST ;IRMFO-ALB/CJM -Post-Install routine for HLO;03/24/2004  14:43
"RTN","HLOPOST",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOPOST",3,0)
 ;
"RTN","HLOPOST",4,0)
 N SYSTEM,DATA,VASITE,OLDSITE
"RTN","HLOPOST",5,0)
 D IDXLINKS
"RTN","HLOPOST",6,0)
 D SYSPARMS^HLOSITE(.SYSTEM)
"RTN","HLOPOST",7,0)
 S VASITE=$$SITE^VASITE
"RTN","HLOPOST",8,0)
 S OLDSITE=$G(^HLCS(869.3,1,0))
"RTN","HLOPOST",9,0)
 S DATA(.01)=SYSTEM("DOMAIN")
"RTN","HLOPOST",10,0)
 I DATA(.01)="" D
"RTN","HLOPOST",11,0)
 .I $P(OLDSITE,"^",2) S DATA(.01)="HL7."_$P($G(^DIC(4.2,$P(OLDSITE,"^",2),0)),"^")
"RTN","HLOPOST",12,0)
 I DATA(.01)="" D
"RTN","HLOPOST",13,0)
 .N INST,DOMAIN
"RTN","HLOPOST",14,0)
 .S INST=$P(VASITE,"^")
"RTN","HLOPOST",15,0)
 .Q:'INST
"RTN","HLOPOST",16,0)
 .S DOMAIN=$P($G(^DIC(4,INST,6)),"^")
"RTN","HLOPOST",17,0)
 .I DOMAIN S DOMAIN=$P($G(^DIC(4.2,DOMAIN,0)),"^") I DOMAIN'="" S DATA(.01)="HL7."_DOMAIN
"RTN","HLOPOST",18,0)
 I DATA(.01)="" D BMES^XPDUTL("Post-Install failed, system missing INSTITUTION or DOMAIN file entry") Q
"RTN","HLOPOST",19,0)
 S DATA(.02)=SYSTEM("STATION")
"RTN","HLOPOST",20,0)
 I DATA(.02)="",$P(OLDSITE,"^",4) S DATA(.02)=$P($G(^DIC(4,$P(OLDSITE,"^",4),99)),"^")
"RTN","HLOPOST",21,0)
 I DATA(.02)="" S DATA(.02)=$P(VASITE,"^",3)
"RTN","HLOPOST",22,0)
 S DATA(.03)=$P(OLDSITE,"^",3)
"RTN","HLOPOST",23,0)
 S DATA(.04)=SYSTEM("MAXSTRING")
"RTN","HLOPOST",24,0)
 S DATA(.05)=SYSTEM("HL7 BUFFER")
"RTN","HLOPOST",25,0)
 S DATA(.06)=SYSTEM("USER BUFFER")
"RTN","HLOPOST",26,0)
 S DATA(.07)=SYSTEM("NORMAL PURGE")
"RTN","HLOPOST",27,0)
 S DATA(.08)=SYSTEM("ERROR PURGE")
"RTN","HLOPOST",28,0)
 I $D(^HLD(779.1,1,0)) D
"RTN","HLOPOST",29,0)
 .N ERROR
"RTN","HLOPOST",30,0)
 .I '$$UPD^HLOASUB1(779.1,1,.DATA,.ERROR) D BMES^XPDUTL("Post-Install failed -"_$G(ERROR))
"RTN","HLOPOST",31,0)
 E  D
"RTN","HLOPOST",32,0)
 .N ERROR
"RTN","HLOPOST",33,0)
 .I '$$ADD^HLOASUB1(779.1,,.DATA,.ERROR,1) D BMES^XPDUTL("Post-Install failed -"_$G(ERROR))
"RTN","HLOPOST",34,0)
 Q
"RTN","HLOPOST",35,0)
IDXLINKS ;
"RTN","HLOPOST",36,0)
 ;set the "AC" and "AD" indicies on the HL Logical Link file
"RTN","HLOPOST",37,0)
 N DIK
"RTN","HLOPOST",38,0)
 S DIK="^HLCS(870,"
"RTN","HLOPOST",39,0)
 S DIK(1)=".01^AC^AD^AD1^AD2"
"RTN","HLOPOST",40,0)
 D ENALL^DIK
"RTN","HLOPOST",41,0)
 Q
"RTN","HLOPROC")
0^28^B24878795
"RTN","HLOPROC",1,0)
HLOPROC ;ALB/CJM- Generic HL7 Process - 10/4/94 1pm
"RTN","HLOPROC",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOPROC",3,0)
 ;
"RTN","HLOPROC",4,0)
PROCESS ;queued entry point
"RTN","HLOPROC",5,0)
 ;
"RTN","HLOPROC",6,0)
 ;insure just one process manager
"RTN","HLOPROC",7,0)
 I PROCNAME="PROCESS MANAGER" N RUNNING L +^HLTMP(PROCNAME):1 S RUNNING='$T D  Q:RUNNING
"RTN","HLOPROC",8,0)
 .I 'RUNNING D
"RTN","HLOPROC",9,0)
 ..D SETNM^%ZOSV($E("HLOmgr:"_$J,1,17))
"RTN","HLOPROC",10,0)
 .E  D
"RTN","HLOPROC",11,0)
 ..L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",12,0)
 ..K:$D(ZTSK) ^HLTMP("HL7 QUEUED PROCESSES",ZTSK)
"RTN","HLOPROC",13,0)
 ..S ^HLC("HL7 PROCESS COUNTS","RUNNING","PROCESS MANAGER")=1
"RTN","HLOPROC",14,0)
 ..S ^HLC("HL7 PROCESS COUNTS","QUEUED","PROCESS MANAGER")=0
"RTN","HLOPROC",15,0)
 ..L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",16,0)
 ..S ZTREQ="@"
"RTN","HLOPROC",17,0)
 ;
"RTN","HLOPROC",18,0)
 ;invoke the framework process
"RTN","HLOPROC",19,0)
 D HL7PROC(PROCNAME)
"RTN","HLOPROC",20,0)
 ;
"RTN","HLOPROC",21,0)
 I PROCNAME="PROCESS MANAGER" L -^HLTMP(PROCNAME)
"RTN","HLOPROC",22,0)
 S ZTREQ="@"
"RTN","HLOPROC",23,0)
 Q
"RTN","HLOPROC",24,0)
 ;
"RTN","HLOPROC",25,0)
HL7PROC(PROCNAME) ;
"RTN","HLOPROC",26,0)
 ;This is the generic HL7 process used by all processes started under the HL7 Process Manager
"RTN","HLOPROC",27,0)
 ;Input:
"RTN","HLOPROC",28,0)
 ;  PROCNAME - the name of a process found in the HL7 Process Registry
"RTN","HLOPROC",29,0)
 ;  OUTPUT - none
"RTN","HLOPROC",30,0)
 ;
"RTN","HLOPROC",31,0)
 N PROCESS,HL7STOP,WORK
"RTN","HLOPROC",32,0)
 ;
"RTN","HLOPROC",33,0)
 S ^HL7TMP("HL7 PROCESS NAME",$J)=PROCNAME
"RTN","HLOPROC",34,0)
 ;
"RTN","HLOPROC",35,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",36,0)
 I $D(ZTQUEUED) D
"RTN","HLOPROC",37,0)
 .K:$D(ZTSK) ^HLTMP("HL7 QUEUED PROCESSES",ZTSK)
"RTN","HLOPROC",38,0)
 .I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROCNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROCNAME)))
"RTN","HLOPROC",39,0)
 L +^HLTMP("HL7 RUNNING PROCESSES",$J):0
"RTN","HLOPROC",40,0)
 I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)))
"RTN","HLOPROC",41,0)
 S ^HLTMP("HL7 RUNNING PROCESSES",$J)=$H_"^"_$G(ZTSK)_"^"_PROCNAME
"RTN","HLOPROC",42,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",43,0)
 ;
"RTN","HLOPROC",44,0)
 ;
"RTN","HLOPROC",45,0)
 I $$GETPROC(PROCNAME,.PROCESS),'$$CHK4STOP(.PROCESS) D
"RTN","HLOPROC",46,0)
 .S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",47,0)
 .;
"RTN","HLOPROC",48,0)
 .;should this task be made persistent?
"RTN","HLOPROC",49,0)
 .I PROCESS("PERSISTENT"),$G(ZTQUEUED),$$PSET^%ZTLOAD(ZTQUEUED)
"RTN","HLOPROC",50,0)
 .;
"RTN","HLOPROC",51,0)
 .S HL7STOP=0
"RTN","HLOPROC",52,0)
 .F  D  Q:HL7STOP
"RTN","HLOPROC",53,0)
 ..N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOPROC"
"RTN","HLOPROC",54,0)
 ..N HL7TRIES,GOTWORK
"RTN","HLOPROC",55,0)
 ..F HL7TRIES=1:1 D  Q:GOTWORK  Q:HL7STOP
"RTN","HLOPROC",56,0)
 ...S GOTWORK=$$GETWORK(.PROCESS,.WORK)
"RTN","HLOPROC",57,0)
 ...Q:GOTWORK
"RTN","HLOPROC",58,0)
 ...;since there is no work, don't want another process starting
"RTN","HLOPROC",59,0)
 ...S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",60,0)
 ...H PROCESS("HANG")
"RTN","HLOPROC",61,0)
 ...S HL7STOP=$$CHK4STOP(.PROCESS,HL7TRIES)
"RTN","HLOPROC",62,0)
 ..Q:HL7STOP
"RTN","HLOPROC",63,0)
 ..I GOTWORK D DOWORK(.PROCESS,.WORK) S HL7TRIES=0
"RTN","HLOPROC",64,0)
 ..S:'$G(HL7STOP) HL7STOP=$$CHK4STOP(.PROCESS,.HL7TRIES)
"RTN","HLOPROC",65,0)
 ;
"RTN","HLOPROC",66,0)
 S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",67,0)
 ;
"RTN","HLOPROC",68,0)
END ;
"RTN","HLOPROC",69,0)
 S HL7STOP=1
"RTN","HLOPROC",70,0)
 K ^HL7TMP("HL7 PROCESS NAME",$J)
"RTN","HLOPROC",71,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",72,0)
 K ^HLTMP("HL7 RUNNING PROCESSES",$J)
"RTN","HLOPROC",73,0)
 I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)),1)
"RTN","HLOPROC",74,0)
 L -^HLTMP("HL7 RUNNING PROCESSES",$J)
"RTN","HLOPROC",75,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",76,0)
 K ^TMP("HL7 ERRORS",$J)
"RTN","HLOPROC",77,0)
 ;
"RTN","HLOPROC",78,0)
 Q
"RTN","HLOPROC",79,0)
 ;
"RTN","HLOPROC",80,0)
ERROR ;error trap
"RTN","HLOPROC",81,0)
 ;
"RTN","HLOPROC",82,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOPROC",83,0)
 ;
"RTN","HLOPROC",84,0)
 ;while debugging always quit on error
"RTN","HLOPROC",85,0)
 I $G(^HLTMP("LOG ALL ERRORS")) D  QUIT
"RTN","HLOPROC",86,0)
 .D ^%ZTER
"RTN","HLOPROC",87,0)
 .S:'$D(PROCNAME) PROCNAME=$G(^HL7TMP("HL7 PROCESS NAME",$J))
"RTN","HLOPROC",88,0)
 .D END
"RTN","HLOPROC",89,0)
 ;
"RTN","HLOPROC",90,0)
 ;a lot of errors of the same type may indicate an endless loop, so quit
"RTN","HLOPROC",91,0)
 ;to be on the safe side.  Decrement the process count.
"RTN","HLOPROC",92,0)
 S $ECODE=$P($ECODE,",",1,2)
"RTN","HLOPROC",93,0)
 S ^TMP("HL7 ERRORS",$J,$ECODE)=$G(^TMP("HL7 ERRORS",$J,$ECODE))+1
"RTN","HLOPROC",94,0)
 I $G(^TMP("HL7 ERRORS",$J,$ECODE))>100 D  QUIT
"RTN","HLOPROC",95,0)
 .D ^%ZTER
"RTN","HLOPROC",96,0)
 .S:'$D(PROCNAME) PROCNAME=$G(^HL7TMP("HL7 PROCESS NAME",$J))
"RTN","HLOPROC",97,0)
 .D END
"RTN","HLOPROC",98,0)
 ;
"RTN","HLOPROC",99,0)
 D ^%ZTER
"RTN","HLOPROC",100,0)
 D UNWIND^%ZTER
"RTN","HLOPROC",101,0)
 Q
"RTN","HLOPROC",102,0)
 ;
"RTN","HLOPROC",103,0)
GETPROC(PROCNAME,PROCESS) ;
"RTN","HLOPROC",104,0)
 ;using PROCNAME to find the entry in the HL7 Process Registry, returns the entry as a subscripted array in .PROCESS
"RTN","HLOPROC",105,0)
 ;
"RTN","HLOPROC",106,0)
 ;Output: Function returns 0 on failure, 1 on success
"RTN","HLOPROC",107,0)
 ;
"RTN","HLOPROC",108,0)
 N IEN,NODE
"RTN","HLOPROC",109,0)
 S IEN=$O(^HLD(779.3,"B",PROCNAME,0))
"RTN","HLOPROC",110,0)
 Q:'IEN 0
"RTN","HLOPROC",111,0)
 S PROCESS("NAME")=PROCNAME
"RTN","HLOPROC",112,0)
 S PROCESS("IEN")=IEN
"RTN","HLOPROC",113,0)
 S NODE=$G(^HLD(779.3,IEN,0))
"RTN","HLOPROC",114,0)
 S PROCESS("MINIMUM")=+$P(NODE,"^",3)
"RTN","HLOPROC",115,0)
 S PROCESS("MAXIMUM")=+$P(NODE,"^",4)
"RTN","HLOPROC",116,0)
 S PROCESS("HANG")=+$P(NODE,"^",7)
"RTN","HLOPROC",117,0)
 I 'PROCESS("HANG") S PROCESS("HANG")=1
"RTN","HLOPROC",118,0)
 S PROCESS("GET WORK")=$P(NODE,"^",8,9)
"RTN","HLOPROC",119,0)
 S PROCESS("DO WORK")=$P(NODE,"^",10,11)
"RTN","HLOPROC",120,0)
 S PROCESS("MAX TRIES")=$P(NODE,"^",12)
"RTN","HLOPROC",121,0)
 I 'PROCESS("MAX TRIES") S PROCESS("MAX TRIES")=999
"RTN","HLOPROC",122,0)
 S PROCESS("PERSISTENT")=+$P(NODE,"^",13)
"RTN","HLOPROC",123,0)
 S PROCESS("LINK")=$P(NODE,"^",14)
"RTN","HLOPROC",124,0)
 Q 1
"RTN","HLOPROC",125,0)
 ;
"RTN","HLOPROC",126,0)
GETWORK(PROCESS,WORK) ;
"RTN","HLOPROC",127,0)
 N RETURN,XECUTE
"RTN","HLOPROC",128,0)
 I PROCESS("LINK")]"" S WORK("LINK")=PROCESS("LINK")
"RTN","HLOPROC",129,0)
 S XECUTE="S RETURN=$$"_PROCESS("GET WORK")_"(.WORK)"
"RTN","HLOPROC",130,0)
 D
"RTN","HLOPROC",131,0)
 .N PROCESS
"RTN","HLOPROC",132,0)
 .X XECUTE
"RTN","HLOPROC",133,0)
 Q RETURN
"RTN","HLOPROC",134,0)
 ;
"RTN","HLOPROC",135,0)
DOWORK(PROCESS,WORK) ;
"RTN","HLOPROC",136,0)
 N XECUTE
"RTN","HLOPROC",137,0)
 M PARMS=WORK
"RTN","HLOPROC",138,0)
 S XECUTE="D "_PROCESS("DO WORK")_"(.WORK)"
"RTN","HLOPROC",139,0)
 D
"RTN","HLOPROC",140,0)
 .N PROCESS,HL7TRIES,PARMS,PROCNAME
"RTN","HLOPROC",141,0)
 .X XECUTE
"RTN","HLOPROC",142,0)
 M WORK=PARMS
"RTN","HLOPROC",143,0)
 Q
"RTN","HLOPROC",144,0)
 ;
"RTN","HLOPROC",145,0)
CHK4STOP(PROCESS,HL7TRIES) ;
"RTN","HLOPROC",146,0)
 ;Determines if the process should stop, returns 1 if yes, 0 if no
"RTN","HLOPROC",147,0)
 ;
"RTN","HLOPROC",148,0)
 Q:$$CHKSTOP 1
"RTN","HLOPROC",149,0)
 Q:'$P($G(^HLD(779.3,PROCESS("IEN"),0)),"^",2) 1
"RTN","HLOPROC",150,0)
 I $G(HL7TRIES)>(PROCESS("MAX TRIES")-1),PROCESS("MINIMUM")<$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCESS("NAME"))) Q 1
"RTN","HLOPROC",151,0)
 Q:$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCESS("NAME")))>PROCESS("MAXIMUM") 1
"RTN","HLOPROC",152,0)
 Q 0
"RTN","HLOPROC",153,0)
 ;
"RTN","HLOPROC",154,0)
CHKSTOP() ;has HL7 been requested to stop?
"RTN","HLOPROC",155,0)
 Q '$P($G(^HLD(779.1,1,0)),"^",9)
"RTN","HLOPROC1")
0^29^B37655107
"RTN","HLOPROC1",1,0)
HLOPROC1 ;ALB/CJM- Process Manager - 10/4/94 1pm
"RTN","HLOPROC1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOPROC1",3,0)
 ;
"RTN","HLOPROC1",4,0)
 ;
"RTN","HLOPROC1",5,0)
GETWORK(PROCESS) ;
"RTN","HLOPROC1",6,0)
 ;finds a process that needs to be started
"RTN","HLOPROC1",7,0)
 ;
"RTN","HLOPROC1",8,0)
 N NAME,IEN,GOTWORK
"RTN","HLOPROC1",9,0)
 ;this is how  HL7 can be stopped via Taskman
"RTN","HLOPROC1",10,0)
 I $$S^%ZTLOAD D STOPHL7 Q 0
"RTN","HLOPROC1",11,0)
 S GOTWORK=0
"RTN","HLOPROC1",12,0)
 S IEN=+$G(PROCESS("IEN"))
"RTN","HLOPROC1",13,0)
 F  S IEN=$O(^HLD(779.3,"C",1,IEN)) Q:IEN=$G(PROCESS("IEN"))  I IEN D  Q:GOTWORK
"RTN","HLOPROC1",14,0)
 .N PROC,COUNT,QUEUED,RUNNING
"RTN","HLOPROC1",15,0)
 .Q:'$$GETPROC(IEN,.PROC)
"RTN","HLOPROC1",16,0)
 .Q:PROC("VMS SERVICE")
"RTN","HLOPROC1",17,0)
 .Q:PROC("NAME")="PROCESS MANAGER"
"RTN","HLOPROC1",18,0)
 .S PROCESS("COUNT")=1
"RTN","HLOPROC1",19,0)
 .S QUEUED=+$G(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC("NAME")))
"RTN","HLOPROC1",20,0)
 .S:QUEUED<0 QUEUED=0
"RTN","HLOPROC1",21,0)
 .S RUNNING=+$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC("NAME")))
"RTN","HLOPROC1",22,0)
 .S:RUNNING<0 RUNNING=0
"RTN","HLOPROC1",23,0)
 .S COUNT=QUEUED+RUNNING
"RTN","HLOPROC1",24,0)
 .I COUNT<PROC("MINIMUM") S GOTWORK=1,PROCESS("IEN")=IEN,PROCESS("NAME")=PROC("NAME"),PROCESS("COUNT")=(PROC("MINIMUM")-COUNT) Q
"RTN","HLOPROC1",25,0)
 .I COUNT<PROC("MAXIMUM"),$$FMDIFF^XLFDT($$NOW^XLFDT,PROC("LAST DT/TM"),2)>PROC("WAIT SECONDS"),'QUEUED S GOTWORK=1,PROCESS("IEN")=IEN,PROCESS("NAME")=PROC("NAME"),PROCESS("COUNT")=1 Q
"RTN","HLOPROC1",26,0)
 I 'GOTWORK K PROCESS
"RTN","HLOPROC1",27,0)
 Q GOTWORK
"RTN","HLOPROC1",28,0)
 ;
"RTN","HLOPROC1",29,0)
DOWORK(PROCESS) ;
"RTN","HLOPROC1",30,0)
 ;starts a process
"RTN","HLOPROC1",31,0)
 ;
"RTN","HLOPROC1",32,0)
 ;don't start a new task if stopped
"RTN","HLOPROC1",33,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOPROC1",34,0)
 ;
"RTN","HLOPROC1",35,0)
 N ZTRTN,ZTDESC,ZTSAVE,ZTIO,ZTSK,I,ZTDTH
"RTN","HLOPROC1",36,0)
 S:'$G(PROCESS("COUNT")) PROCESS("COUNT")=1
"RTN","HLOPROC1",37,0)
 F I=1:1:PROCESS("COUNT") D
"RTN","HLOPROC1",38,0)
 .S ZTRTN="PROCESS^HLOPROC"
"RTN","HLOPROC1",39,0)
 .S ZTDESC="HL7 - "_PROCESS("NAME")
"RTN","HLOPROC1",40,0)
 .S ZTIO=""
"RTN","HLOPROC1",41,0)
 .S ZTSAVE("PROCNAME")=PROCESS("NAME")
"RTN","HLOPROC1",42,0)
 .S ZTDTH=$H
"RTN","HLOPROC1",43,0)
 .D ^%ZTLOAD
"RTN","HLOPROC1",44,0)
 .I $D(ZTSK) D
"RTN","HLOPROC1",45,0)
 ..;lock before changing counts
"RTN","HLOPROC1",46,0)
 ..L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",47,0)
 ..I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROCESS("NAME"))))
"RTN","HLOPROC1",48,0)
 ..S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT,^HLTMP("HL7 QUEUED PROCESSES",ZTSK)=$H_"^"_PROCESS("NAME")
"RTN","HLOPROC1",49,0)
 ..L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",50,0)
 Q
"RTN","HLOPROC1",51,0)
 ;
"RTN","HLOPROC1",52,0)
GETPROC(IEN,PROCESS) ;
"RTN","HLOPROC1",53,0)
 ;given the ien of the HL7 Process Registry entry, returns the entry as a subscripted array in .PROCESS
"RTN","HLOPROC1",54,0)
 ;
"RTN","HLOPROC1",55,0)
 ;Output: Function returns 0 on failure, 1 on success
"RTN","HLOPROC1",56,0)
 ;
"RTN","HLOPROC1",57,0)
 N NODE
"RTN","HLOPROC1",58,0)
 S NODE=$G(^HLD(779.3,IEN,0))
"RTN","HLOPROC1",59,0)
 Q:NODE="" 0
"RTN","HLOPROC1",60,0)
 S PROCESS("NAME")=$P(NODE,"^")
"RTN","HLOPROC1",61,0)
 S PROCESS("IEN")=IEN
"RTN","HLOPROC1",62,0)
 S PROCESS("MINIMUM")=+$P(NODE,"^",3)
"RTN","HLOPROC1",63,0)
 S PROCESS("MAXIMUM")=+$P(NODE,"^",4)
"RTN","HLOPROC1",64,0)
 S PROCESS("WAIT SECONDS")=+($P(NODE,"^",5))*60
"RTN","HLOPROC1",65,0)
 I 'PROCESS("WAIT SECONDS") S PROCESS("WAIT SECONDS")=1000
"RTN","HLOPROC1",66,0)
 S PROCESS("LAST DT/TM")=$P(NODE,"^",6)
"RTN","HLOPROC1",67,0)
 S PROCESS("VMS SERVICE")=$P(NODE,"^",15)
"RTN","HLOPROC1",68,0)
 Q 1
"RTN","HLOPROC1",69,0)
 ;
"RTN","HLOPROC1",70,0)
STOPHL7 ;shut down HLO HL7
"RTN","HLOPROC1",71,0)
 N ZTSK,DOLLARJ
"RTN","HLOPROC1",72,0)
 ;let other processes know that starting/stopping is underway
"RTN","HLOPROC1",73,0)
 S $P(^HLD(779.1,1,0),"^",9)=0
"RTN","HLOPROC1",74,0)
 S ZTSK=""
"RTN","HLOPROC1",75,0)
 F  S ZTSK=$O(^HLTMP("HL7 QUEUED PROCESSES",ZTSK)) Q:ZTSK=""  D DQ^%ZTLOAD
"RTN","HLOPROC1",76,0)
 S DOLLARJ=""
"RTN","HLOPROC1",77,0)
 F  S DOLLARJ=$O(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)) Q:DOLLARJ=""  S ZTSK=$P($G(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)),"^",2) I ZTSK]"" D PCLEAR^%ZTLOAD(ZTSK) I $$ASKSTOP^%ZTLOAD(ZTSK)
"RTN","HLOPROC1",78,0)
 D CHKQUED
"RTN","HLOPROC1",79,0)
 Q
"RTN","HLOPROC1",80,0)
 ;
"RTN","HLOPROC1",81,0)
STARTHL7 ;start HL7 system, but first do some cleanup
"RTN","HLOPROC1",82,0)
 ;
"RTN","HLOPROC1",83,0)
 D RECOUNT()
"RTN","HLOPROC1",84,0)
 ;
"RTN","HLOPROC1",85,0)
 ;set the system status flag to active
"RTN","HLOPROC1",86,0)
 S $P(^HLD(779.1,1,0),"^",9)=1
"RTN","HLOPROC1",87,0)
 ;
"RTN","HLOPROC1",88,0)
 ;don't start a process manager if already running
"RTN","HLOPROC1",89,0)
 L +^HLTMP("PROCESS MANAGER"):1
"RTN","HLOPROC1",90,0)
 Q:'$T
"RTN","HLOPROC1",91,0)
 ;
"RTN","HLOPROC1",92,0)
 ;start the HL7 Process Manager, which will start everything else
"RTN","HLOPROC1",93,0)
 N PROCESS
"RTN","HLOPROC1",94,0)
 S PROCESS("NAME")="PROCESS MANAGER"
"RTN","HLOPROC1",95,0)
 S PROCESS("IEN")=$O(^HLD(779.3,"B","PROCESS MANAGER",0))
"RTN","HLOPROC1",96,0)
 D DOWORK(.PROCESS)
"RTN","HLOPROC1",97,0)
 L -^HLTMP("PROCESS MANAGER")
"RTN","HLOPROC1",98,0)
 Q
"RTN","HLOPROC1",99,0)
 ;
"RTN","HLOPROC1",100,0)
QUIT1(COUNT) ;just returns 1 as function value first time around,then 0, insuring that the DO WORK function is called just once
"RTN","HLOPROC1",101,0)
 I '$G(COUNT) S COUNT=1 Q 1
"RTN","HLOPROC1",102,0)
 Q 0
"RTN","HLOPROC1",103,0)
 ;
"RTN","HLOPROC1",104,0)
CHKDEAD(WORK) ;
"RTN","HLOPROC1",105,0)
 ;did any process terminate without erasing itself?
"RTN","HLOPROC1",106,0)
 ;WORK (pass by reference, not required) by the Process Manager that is not used and not required
"RTN","HLOPROC1",107,0)
 N DOLLARJ S DOLLARJ=""
"RTN","HLOPROC1",108,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",109,0)
 Q:'$T
"RTN","HLOPROC1",110,0)
 F  S DOLLARJ=$O(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)) Q:DOLLARJ=""  I DOLLARJ'=$J L +^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ):0 D:$T
"RTN","HLOPROC1",111,0)
 .L -^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)
"RTN","HLOPROC1",112,0)
 .N PROC
"RTN","HLOPROC1",113,0)
 .S PROC=$P($G(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)),"^",3)
"RTN","HLOPROC1",114,0)
 .K ^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)
"RTN","HLOPROC1",115,0)
 .Q:PROC=""
"RTN","HLOPROC1",116,0)
 .I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)),1)
"RTN","HLOPROC1",117,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",118,0)
 Q
"RTN","HLOPROC1",119,0)
CHKQUED ;did any queued task get dequeued without being erased?
"RTN","HLOPROC1",120,0)
 N PROC,JOB
"RTN","HLOPROC1",121,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",122,0)
 Q:'$T
"RTN","HLOPROC1",123,0)
 S JOB=""
"RTN","HLOPROC1",124,0)
 F  S JOB=$O(^HLTMP("HL7 QUEUED PROCESSES",JOB)) Q:JOB=""  I '$$QUEUED(JOB) D
"RTN","HLOPROC1",125,0)
 .N PROC
"RTN","HLOPROC1",126,0)
 .S PROC=$P($G(^HLTMP("HL7 QUEUED PROCESSES",JOB)),"^",2)
"RTN","HLOPROC1",127,0)
 .I PROC]"",$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)),1)
"RTN","HLOPROC1",128,0)
 .K ^HLTMP("HL7 QUEUED PROCESSES",JOB)
"RTN","HLOPROC1",129,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",130,0)
 Q
"RTN","HLOPROC1",131,0)
 ;
"RTN","HLOPROC1",132,0)
QUEUED(TASK) ;
"RTN","HLOPROC1",133,0)
 ;function returns 0 if ZTSK is not queued to run, 1 if it is
"RTN","HLOPROC1",134,0)
 N ZTSK
"RTN","HLOPROC1",135,0)
 S ZTSK=TASK
"RTN","HLOPROC1",136,0)
 D ISQED^%ZTLOAD
"RTN","HLOPROC1",137,0)
 Q:ZTSK(0) 1
"RTN","HLOPROC1",138,0)
 Q 0
"RTN","HLOPROC1",139,0)
 ;
"RTN","HLOPROC1",140,0)
CNTLIVE ;count the running processes
"RTN","HLOPROC1",141,0)
 N JOB,COUNTS,PROC
"RTN","HLOPROC1",142,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",143,0)
 Q:'$T
"RTN","HLOPROC1",144,0)
 S JOB=""
"RTN","HLOPROC1",145,0)
 F  S JOB=$O(^HLTMP("HL7 RUNNING PROCESSES",JOB)) Q:JOB=""  S PROC=$P($G(^HLTMP("HL7 RUNNING PROCESSES",JOB)),"^",3) I PROC]"" S COUNTS(PROC)=$G(COUNTS(PROC))+1
"RTN","HLOPROC1",146,0)
 S PROC="" F  S PROC=$O(COUNTS(PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)=COUNTS(PROC)
"RTN","HLOPROC1",147,0)
 S PROC="" F  S PROC=$O(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)=+$G(COUNTS(PROC))
"RTN","HLOPROC1",148,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",149,0)
 Q
"RTN","HLOPROC1",150,0)
 ;
"RTN","HLOPROC1",151,0)
CNTQUED ;count the queued tasks
"RTN","HLOPROC1",152,0)
 N JOB,COUNTS,PROC
"RTN","HLOPROC1",153,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",154,0)
 Q:'$T
"RTN","HLOPROC1",155,0)
 S JOB=""
"RTN","HLOPROC1",156,0)
 F  S JOB=$O(^HLTMP("HL7 QUEUED PROCESSES",JOB)) Q:JOB=""  S PROC=$P($G(^HLTMP("HL7 QUEUED PROCESSES",JOB)),"^",2) I PROC]"" S COUNTS(PROC)=$G(COUNTS(PROC))+1
"RTN","HLOPROC1",157,0)
 S PROC="" F  S PROC=$O(COUNTS(PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)=COUNTS(PROC)
"RTN","HLOPROC1",158,0)
 S PROC="" F  S PROC=$O(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)=+$G(COUNTS(PROC))
"RTN","HLOPROC1",159,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",160,0)
 Q
"RTN","HLOPROC1",161,0)
 ;
"RTN","HLOPROC1",162,0)
RECOUNT(RECOUNT) ;check that the processes that are supposed to be running actually are, same for the queued processes
"RTN","HLOPROC1",163,0)
 ;Input:
"RTN","HLOPROC1",164,0)
 ;  RECOUNT (pass by reference, optional) not used, but passed in by the process manager
"RTN","HLOPROC1",165,0)
 ;
"RTN","HLOPROC1",166,0)
 ;
"RTN","HLOPROC1",167,0)
 ;check for processes that are supposed to be running or queued but aren't
"RTN","HLOPROC1",168,0)
 D CHKDEAD(),CHKQUED
"RTN","HLOPROC1",169,0)
 ;
"RTN","HLOPROC1",170,0)
 ;recount the processes
"RTN","HLOPROC1",171,0)
 D CNTLIVE,CNTQUED
"RTN","HLOPROC1",172,0)
 Q
"RTN","HLOPRS")
0^49^B30060156
"RTN","HLOPRS",1,0)
HLOPRS ;IRMFO-ALB/CJM -RTNs for parsing messages;03/24/2004  14:43
"RTN","HLOPRS",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**118,126**;Oct 13, 1995
"RTN","HLOPRS",3,0)
 ;
"RTN","HLOPRS",4,0)
STARTMSG(MSG,IEN,HDR) ;
"RTN","HLOPRS",5,0)
 ;Description:  This function begins the parsing of the message, parsing
"RTN","HLOPRS",6,0)
 ;the header and returning the individual values in the array HDR().
"RTN","HLOPRS",7,0)
 ;Input: 
"RTN","HLOPRS",8,0)
 ;  IEN - The internal entry number of the message in file 778.
"RTN","HLOPRS",9,0)
 ;Output:
"RTN","HLOPRS",10,0)
 ;  Function returns 1 on success, 0 on failure.  Failure would indicate that the message was not found.
"RTN","HLOPRS",11,0)
 ;  MSG - (pass by reference, required) This array is used by the HL7 package to track the progress of parsing the message.  The application MUST NOT touch it!
"RTN","HLOPRS",12,0)
 ;  HDR (pass by reference, optional)   This array contains the results of parsing the message header.
"RTN","HLOPRS",13,0)
 K MSG,HDR
"RTN","HLOPRS",14,0)
 Q:'$G(IEN) 0
"RTN","HLOPRS",15,0)
 Q:'$$GETMSG^HLOMSG(IEN,.MSG) 0
"RTN","HLOPRS",16,0)
 M HDR=MSG("HDR")
"RTN","HLOPRS",17,0)
 Q:'$$PARSEHDR(.HDR) 0
"RTN","HLOPRS",18,0)
 M MSG("HDR")=HDR
"RTN","HLOPRS",19,0)
 Q 1
"RTN","HLOPRS",20,0)
 ;
"RTN","HLOPRS",21,0)
NEXTSEG(MSG,SEG) ;
"RTN","HLOPRS",22,0)
 ;Description:  Advances parsing to the next segment and returns the parsed values from that segment.
"RTN","HLOPRS",23,0)
 ;Input:
"RTN","HLOPRS",24,0)
 ;  MSG - (pass by reference, required) This array is used by the HL7 package to track the current position in the message.  The application MUST NOT touch it!
"RTN","HLOPRS",25,0)
 ;Output:
"RTN","HLOPRS",26,0)
 ;  Function  returns 1 on success, 0 if there are no more segments in this message.  For batch messages, a return value of 0 does not preclude the possibility that there are additional individual messages within the batch.
"RTN","HLOPRS",27,0)
 ;  MSG - (pass by reference, required)
"RTN","HLOPRS",28,0)
 ;  SEG - (pass by reference, required)  The segment is returned in this array.
"RTN","HLOPRS",29,0)
 ;
"RTN","HLOPRS",30,0)
 N TEMP,CODES
"RTN","HLOPRS",31,0)
 K SEG
"RTN","HLOPRS",32,0)
 I '$$HLNEXT^HLOMSG(.MSG,.TEMP) Q 0
"RTN","HLOPRS",33,0)
 S CODES=MSG("HDR","ENCODING CHARACTERS")
"RTN","HLOPRS",34,0)
 Q $$PARSE^HLOPRS1(MSG("HDR","FIELD SEPARATOR"),$E(CODES,2),$E(CODES,1),$E(CODES,4),$E(CODES,3),.TEMP,.SEG)
"RTN","HLOPRS",35,0)
 ;
"RTN","HLOPRS",36,0)
NEXTMSG(MSG,MSH) ;
"RTN","HLOPRS",37,0)
 ;Description:  Advances to the next message within the batch, with the MSH segment returned.
"RTN","HLOPRS",38,0)
 ;Input:
"RTN","HLOPRS",39,0)
 ; MSG (pass by reference, required) This array is used by the HL7 package to track the current position in the message.  The application MUST NOT touch it!
"RTN","HLOPRS",40,0)
 ;OUTPUT:
"RTN","HLOPRS",41,0)
 ;  Function returns 1 on success, 0 if there are no more messages
"RTN","HLOPRS",42,0)
 ;  MSG - (pass by reference)
"RTN","HLOPRS",43,0)
 ;  MSH - (pass by reference, required) Returns the parsed message header
"RTN","HLOPRS",44,0)
 ;
"RTN","HLOPRS",45,0)
 K MSH
"RTN","HLOPRS",46,0)
 N NODE
"RTN","HLOPRS",47,0)
 Q:'$$NEXTMSG^HLOMSG(.MSG,.MSH) 0
"RTN","HLOPRS",48,0)
 Q:'$$PARSEHDR(.MSH) 0
"RTN","HLOPRS",49,0)
 S MSG("BATCH","CURRENT MESSAGE","EVENT")=MSH("EVENT")
"RTN","HLOPRS",50,0)
 S MSG("BATCH","CURRENT MESSAGE","MESSAGE CONTROL ID")=MSH("MESSAGE CONTROL ID")
"RTN","HLOPRS",51,0)
 S NODE=$G(^HLB(MSG("IEN"),3,MSG("BATCH","CURRENT MESSAGE"),0))
"RTN","HLOPRS",52,0)
 S MSG("BATCH","CURRENT MESSAGE","ACK TO")=$P(NODE,"^",3)
"RTN","HLOPRS",53,0)
 S MSG("BATCH","CURRENT MESSAGE","ACK BY")=$P(NODE,"^",4)
"RTN","HLOPRS",54,0)
 ;
"RTN","HLOPRS",55,0)
 I MSG("BATCH","CURRENT MESSAGE","ACK TO")]"" S MSG("BATCH","CURRENT MESSAGE","ACK TO IEN")=$$ACKTOIEN^HLOMSG1(MSG("MESSAGE CONTROL ID"),MSG("BATCH","CURRENT MESSAGE","ACK TO"))
"RTN","HLOPRS",56,0)
 I MSG("BATCH","CURRENT MESSAGE","ACK BY")]"" S MSG("BATCH","CURRENT MESSAGE","ACK BY IEN")=$$ACKBYIEN^HLOMSG1(MSG("MESSAGE CONTROL ID"),MSG("BATCH","CURRENT MESSAGE","ACK BY"))
"RTN","HLOPRS",57,0)
 ;
"RTN","HLOPRS",58,0)
 Q 1
"RTN","HLOPRS",59,0)
 ;
"RTN","HLOPRS",60,0)
PARSEHDR(HDR) ;
"RTN","HLOPRS",61,0)
 ;Parses the segment (HDR, pass by reference) into the HDR() array using meaningful subscripts.
"RTN","HLOPRS",62,0)
 ;Input:
"RTN","HLOPRS",63,0)
 ;  HDR (pass by reference, required) contains the segment in the format HDR(1),HDR(2), etc..
"RTN","HLOPRS",64,0)
 ;Output:
"RTN","HLOPRS",65,0)
 ;  HDR (pass by reference, required) This array will contain all the individual values.  Also will contain HDR(1) with components 1-6 and HDR(2) with components 1-end
"RTN","HLOPRS",66,0)
 ;  Function - returns 1 if the segment is indeed an MSH or BHS segment, 0 otherwise
"RTN","HLOPRS",67,0)
 ;
"RTN","HLOPRS",68,0)
 N VALUE,FS,CS,REP,SUBCOMP,ESCAPE
"RTN","HLOPRS",69,0)
 S VALUE=$E(HDR(1),1,3)
"RTN","HLOPRS",70,0)
 I VALUE'="MSH",VALUE'="BHS" Q 0
"RTN","HLOPRS",71,0)
 S HDR("SEGMENT TYPE")=VALUE
"RTN","HLOPRS",72,0)
 S FS=$E(HDR(1),4)
"RTN","HLOPRS",73,0)
 S CS=$E(HDR(1),5)
"RTN","HLOPRS",74,0)
 S REP=$E(HDR(1),6)
"RTN","HLOPRS",75,0)
 S ESCAPE=$E(HDR(1),7)
"RTN","HLOPRS",76,0)
 S SUBCOMP=$E(HDR(1),8)
"RTN","HLOPRS",77,0)
 Q:$L(FS)'=1 0
"RTN","HLOPRS",78,0)
 Q:$L(CS)'=1 0
"RTN","HLOPRS",79,0)
 S HDR("FIELD SEPARATOR")=FS
"RTN","HLOPRS",80,0)
 S HDR("ENCODING CHARACTERS")=$E(HDR(1),5,8)
"RTN","HLOPRS",81,0)
 S HDR("COMPONENT SEPARATOR")=CS
"RTN","HLOPRS",82,0)
 S HDR("REPETITION SEPARATOR")=$E(HDR(1),6)
"RTN","HLOPRS",83,0)
 S HDR("ESCAPE CHARACTER")=$E(HDR(1),7)
"RTN","HLOPRS",84,0)
 S HDR("SUBCOMPONENT SEPARATOR")=$E(HDR(1),8)
"RTN","HLOPRS",85,0)
 S HDR("SENDING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(HDR(1),FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",86,0)
 S VALUE=$P(HDR(1),FS,4)
"RTN","HLOPRS",87,0)
 S HDR("SENDING FACILITY",1)=$P(VALUE,CS)
"RTN","HLOPRS",88,0)
 S HDR("SENDING FACILITY",2)=$$DESCAPE^HLOPRS1($P(VALUE,CS,2),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",89,0)
 S HDR("SENDING FACILITY",3)=$P(VALUE,CS,3)
"RTN","HLOPRS",90,0)
 S HDR("RECEIVING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(HDR(1),FS,5),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",91,0)
 S VALUE=$P(HDR(1),FS,6)
"RTN","HLOPRS",92,0)
 S HDR("RECEIVING FACILITY",1)=$P(VALUE,CS)
"RTN","HLOPRS",93,0)
 S HDR("RECEIVING FACILITY",2)=$$DESCAPE^HLOPRS1($P(VALUE,CS,2),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",94,0)
 S HDR("RECEIVING FACILITY",3)=$P(VALUE,CS,3)
"RTN","HLOPRS",95,0)
 S HDR("DT/TM OF MESSAGE")=$$FMDATE^HLFNC($P($P(HDR(2),FS,2),CS))
"RTN","HLOPRS",96,0)
 S HDR("SECURITY")=$$DESCAPE^HLOPRS1($P($P(HDR(2),FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",97,0)
 ;
"RTN","HLOPRS",98,0)
 I HDR("SEGMENT TYPE")="MSH" D
"RTN","HLOPRS",99,0)
 .S VALUE=$P(HDR(2),FS,4)
"RTN","HLOPRS",100,0)
 .S HDR("MESSAGE TYPE")=$P(VALUE,CS)
"RTN","HLOPRS",101,0)
 .S HDR("EVENT")=$P(VALUE,CS,2)
"RTN","HLOPRS",102,0)
 .S HDR("MESSAGE STRUCTURE")=$P(VALUE,CS,3)
"RTN","HLOPRS",103,0)
 .S HDR("MESSAGE CONTROL ID")=$P($P(HDR(2),FS,5),CS)
"RTN","HLOPRS",104,0)
 .S VALUE=$P(HDR(2),FS,6)
"RTN","HLOPRS",105,0)
 .S HDR("PROCESSING ID")=$P(VALUE,CS)
"RTN","HLOPRS",106,0)
 .S HDR("PROCESSING MODE")=$P(VALUE,CS,2)
"RTN","HLOPRS",107,0)
 .S HDR("VERSION")=$$DESCAPE^HLOPRS1($P($P(HDR(2),FS,7),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",108,0)
 .S HDR("CONTINUATION POINTER")=$P($P(HDR(2),FS,9),CS)
"RTN","HLOPRS",109,0)
 .S HDR("ACCEPT ACK TYPE")=$P($P(HDR(2),FS,10),CS)
"RTN","HLOPRS",110,0)
 .S HDR("APP ACK TYPE")=$P($P(HDR(2),FS,11),CS)
"RTN","HLOPRS",111,0)
 .S HDR("COUNTRY")=$P($P(HDR(2),FS,12),CS)
"RTN","HLOPRS",112,0)
 ;
"RTN","HLOPRS",113,0)
 I HDR("SEGMENT TYPE")="BHS" D
"RTN","HLOPRS",114,0)
 .S VALUE=$P(HDR(2),FS,4)
"RTN","HLOPRS",115,0)
 .S HDR("BATCH NAME/ID/TYPE")=$$DESCAPE^HLOPRS1(VALUE,FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",116,0)
 .S HDR("PROCESSING ID")=$E($P(VALUE,"PROCESSING ID=",2),1)
"RTN","HLOPRS",117,0)
 .S HDR("ACCEPT ACK TYPE")=$E($P(VALUE,"ACCEPT ACK TYPE=",2),1,2)
"RTN","HLOPRS",118,0)
 .S HDR("APP ACK TYPE")=$E($P(VALUE,"APP ACK TYPE=",2),1,2)
"RTN","HLOPRS",119,0)
 .S HDR("BATCH COMMENT")=$$DESCAPE^HLOPRS1($P(HDR(2),FS,5),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",120,0)
 .S HDR("BATCH CONTROL ID")=$P($P(HDR(2),FS,6),CS)
"RTN","HLOPRS",121,0)
 .S HDR("REFERENCE BATCH CONTROL ID")=$P($P(HDR(2),FS,7),CS)
"RTN","HLOPRS",122,0)
 .;
"RTN","HLOPRS",123,0)
 Q 1
"RTN","HLOPRS",124,0)
 ;
"RTN","HLOPRS",125,0)
GET(SEG,FIELD,COMP,SUBCOMP,REP) ;
"RTN","HLOPRS",126,0)
 ;This function gets a specified value from a segment that was parsed by
"RTN","HLOPRS",127,0)
 ;$$NEXTSEG. The FIELD,COMP,SUBCOMP,REP parameters are optional - if not
"RTN","HLOPRS",128,0)
 ;specified, they default to 1.
"RTN","HLOPRS",129,0)
 ;  Example:
"RTN","HLOPRS",130,0)
 ;    $$GET^HLOPRS(.SEG,1) will return the value of the first field, first
"RTN","HLOPRS",131,0)
 ;  component, first subcomponent, in the first occurrence of field #1.  
"RTN","HLOPRS",132,0)
 ;Input:
"RTN","HLOPRS",133,0)
 ;SEG - (required, pass by reference) - this is the array where the parsed segment was placed by $$NEXTSEG
"RTN","HLOPRS",134,0)
 ;FIELD - the sequence # of the field (optional, defaults to 1)
"RTN","HLOPRS",135,0)
 ;COMP - the # of the component (optional, defaults to 1)
"RTN","HLOPRS",136,0)
 ;SUBCOMP - the # of the subcomponent (optional, defaults to 1)
"RTN","HLOPRS",137,0)
 ;REP - the occurrence# (optional, defaults to 1)  For a non-repeating field, the occurrence # need not be provided, because it would be 1.
"RTN","HLOPRS",138,0)
 ;Output:
"RTN","HLOPRS",139,0)
 ;  Function returns the requested value on success, "" if not valued.
"RTN","HLOPRS",140,0)
 ;
"RTN","HLOPRS",141,0)
 ;allow the segment type to be obtained via field #0 (shorthand)
"RTN","HLOPRS",142,0)
 I $D(FIELD),$G(FIELD)=0 Q $G(SEG("SEGMENT TYPE"))
"RTN","HLOPRS",143,0)
 S:'$G(FIELD) FIELD=1
"RTN","HLOPRS",144,0)
 ;
"RTN","HLOPRS",145,0)
 ;for MSH or BHS, SEQ#1 is the  field separator
"RTN","HLOPRS",146,0)
 I FIELD=1,$G(SEG("SEGMENT TYPE"))="MSH"!($G(SEG("SEGMENT TYPE"))="BHS"),$G(REP)<2,$G(COMP)<2,$G(SUBCOMP)<2 Q SEG("FIELD SEPARATOR")
"RTN","HLOPRS",147,0)
 I FIELD=1,$G(SEG("SEGMENT TYPE"))="MSH"!($G(SEG("SEGMENT TYPE"))="BHS") Q ""
"RTN","HLOPRS",148,0)
 ;
"RTN","HLOPRS",149,0)
 ;For segments other than MSH or BHS, the first subscript in the SEG array needs to be incremented by 1, because SEG(1,1,1,1) is taken by the segment type, which technically isn't a field. (for convenience,we call it SEQ=0).  
"RTN","HLOPRS",150,0)
 I $G(SEG("SEGMENT TYPE"))'="BHS",$G(SEG("SEGMENT TYPE"))'="MSH" S FIELD=FIELD+1
"RTN","HLOPRS",151,0)
 S:'$G(COMP) COMP=1
"RTN","HLOPRS",152,0)
 S:'$G(SUBCOMP) SUBCOMP=1
"RTN","HLOPRS",153,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS",154,0)
 Q $G(SEG(FIELD,REP,COMP,SUBCOMP))
"RTN","HLOPRS",155,0)
 ;
"RTN","HLOPURGE")
0^32^B28987748
"RTN","HLOPURGE",1,0)
HLOPURGE ;IRMFO-ALB/CJM - Purging Old Messages;03/24/2004  14:43
"RTN","HLOPURGE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOPURGE",3,0)
 ;
"RTN","HLOPURGE",4,0)
GETWORK(WORK) ;
"RTN","HLOPURGE",5,0)
 ;
"RTN","HLOPURGE",6,0)
 N OK S OK=0
"RTN","HLOPURGE",7,0)
 I $G(WORK)]"" L -HLPURGE(WORK)
"RTN","HLOPURGE",8,0)
 F WORK="IN","OUT","OLD778","OLD777" I '$G(WORK("DONE",WORK)) L +HLPURGE(WORK):0 S OK=$T Q:OK
"RTN","HLOPURGE",9,0)
 Q OK
"RTN","HLOPURGE",10,0)
 ;
"RTN","HLOPURGE",11,0)
DOWORK(WORK) ;
"RTN","HLOPURGE",12,0)
 I WORK="OLD778" D OLD778
"RTN","HLOPURGE",13,0)
 I WORK="OLD777" D OLD777
"RTN","HLOPURGE",14,0)
 I (WORK="IN")!(WORK="OUT") D
"RTN","HLOPURGE",15,0)
 .N TIME,NOW
"RTN","HLOPURGE",16,0)
 .S NOW=$$NOW^XLFDT
"RTN","HLOPURGE",17,0)
 .S TIME=0
"RTN","HLOPURGE",18,0)
 .F  S TIME=$O(^HLB("AD",WORK,TIME)) Q:TIME=""  Q:TIME>NOW  D
"RTN","HLOPURGE",19,0)
 ..N MSGIEN
"RTN","HLOPURGE",20,0)
 ..S MSGIEN=0
"RTN","HLOPURGE",21,0)
 ..F  S MSGIEN=$O(^HLB("AD",WORK,TIME,MSGIEN)) Q:'MSGIEN  D
"RTN","HLOPURGE",22,0)
 ...D DELETE(MSGIEN)
"RTN","HLOPURGE",23,0)
 ...K ^HLB("AD",WORK,TIME,MSGIEN)
"RTN","HLOPURGE",24,0)
 S WORK("DONE",WORK)=1
"RTN","HLOPURGE",25,0)
 Q
"RTN","HLOPURGE",26,0)
OLD778 ;
"RTN","HLOPURGE",27,0)
 N OLD,START,END,APP,TYPE
"RTN","HLOPURGE",28,0)
 S OLD=$$FMADD^XLFDT($$DT^XLFDT,-45)
"RTN","HLOPURGE",29,0)
 F START=0,100000000000,200000000000,300000000000 D
"RTN","HLOPURGE",30,0)
 .S END=(START+100000000000)-1
"RTN","HLOPURGE",31,0)
 .N MSGIEN,QUIT
"RTN","HLOPURGE",32,0)
 .S QUIT=0
"RTN","HLOPURGE",33,0)
 .S MSGIEN=START
"RTN","HLOPURGE",34,0)
 .F  S MSGIEN=$O(^HLB(MSGIEN)) Q:'MSGIEN  Q:(MSGIEN>END)  D  Q:QUIT
"RTN","HLOPURGE",35,0)
 ..N WHEN,BODY,NODE
"RTN","HLOPURGE",36,0)
 ..S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOPURGE",37,0)
 ..S WHEN=$P(NODE,"^",16)
"RTN","HLOPURGE",38,0)
 ..I WHEN,WHEN<OLD D DELETE(MSGIEN) Q
"RTN","HLOPURGE",39,0)
 ..I 'WHEN D
"RTN","HLOPURGE",40,0)
 ...S BODY=$P(NODE,"^",2)
"RTN","HLOPURGE",41,0)
 ...Q:'BODY
"RTN","HLOPURGE",42,0)
 ...S WHEN=+$G(^HLA(BODY,0))
"RTN","HLOPURGE",43,0)
 ...I WHEN,WHEN<OLD D  Q
"RTN","HLOPURGE",44,0)
 ....;I've seen messages sitting on outgoing queues forever, but it should never happen for incoming
"RTN","HLOPURGE",45,0)
 ....I $E($P(NODE,"^",4))="O",$P(NODE,"^",5)]"",$P(NODE,"^",6)]"" D
"RTN","HLOPURGE",46,0)
 .....N FROM
"RTN","HLOPURGE",47,0)
 .....S FROM=$P(NODE,"^",5)
"RTN","HLOPURGE",48,0)
 .....I $P(NODE,"^",8) S FROM=FROM_":"_$P(NODE,"^",8)
"RTN","HLOPURGE",49,0)
 .....Q:'$D(^HLB("QUEUE","OUT",FROM,$P(NODE,"^",6),MSGIEN))
"RTN","HLOPURGE",50,0)
 .....D DEQUE^HLOQUE(FROM,$P(NODE,"^",6),"OUT",MSGIEN)
"RTN","HLOPURGE",51,0)
 ....D DELETE(MSGIEN) Q
"RTN","HLOPURGE",52,0)
 ...;stop looking for old records?
"RTN","HLOPURGE",53,0)
 ...I WHEN,WHEN>OLD S QUIT=1
"RTN","HLOPURGE",54,0)
 ;
"RTN","HLOPURGE",55,0)
 ;also kill old errors left lying around
"RTN","HLOPURGE",56,0)
 F TYPE="TF","AE","SE" S APP="" F  S APP=$O(^HLB("ERRORS",TYPE,APP)) Q:APP=""  D
"RTN","HLOPURGE",57,0)
 .N TIME
"RTN","HLOPURGE",58,0)
 .S TIME=0
"RTN","HLOPURGE",59,0)
 .F  S TIME=$O(^HLB("ERRORS",TYPE,APP,TIME)) Q:'TIME  Q:TIME>OLD  K ^HLB("ERRORS",TYPE,APP,TIME)
"RTN","HLOPURGE",60,0)
 Q
"RTN","HLOPURGE",61,0)
OLD777 ;
"RTN","HLOPURGE",62,0)
 N OLD,TIME
"RTN","HLOPURGE",63,0)
 S OLD=$$FMADD^XLFDT($$DT^XLFDT,-45)
"RTN","HLOPURGE",64,0)
 S TIME=0
"RTN","HLOPURGE",65,0)
 F  S TIME=$O(^HLA("B",TIME)) Q:'TIME  Q:TIME>OLD  D
"RTN","HLOPURGE",66,0)
 .N MSGIEN
"RTN","HLOPURGE",67,0)
 .S MSGIEN=0
"RTN","HLOPURGE",68,0)
 .F  S MSGIEN=$O(^HLA("B",TIME,MSGIEN)) Q:'MSGIEN  D
"RTN","HLOPURGE",69,0)
 ..N IEN778
"RTN","HLOPURGE",70,0)
 ..S IEN778=0
"RTN","HLOPURGE",71,0)
 ..F  S IEN778=$O(^HLB("C",MSGIEN,IEN778)) Q:'IEN778  D DELETE(IEN778,1)
"RTN","HLOPURGE",72,0)
 ..K ^HLB("C",MSGIEN),^HLA("B",TIME,MSGIEN),^HLA(MSGIEN)
"RTN","HLOPURGE",73,0)
 Q
"RTN","HLOPURGE",74,0)
 ;
"RTN","HLOPURGE",75,0)
DELETE(MSGIEN,FLAG) ;
"RTN","HLOPURGE",76,0)
 ;Input:
"RTN","HLOPURGE",77,0)
 ;  MSGIEN - IEN, file 778
"RTN","HLOPURGE",78,0)
 ;  FLAG - if $G(FLAG), will not delete the pointed to record in file 777
"RTN","HLOPURGE",79,0)
 N AC,SUBIEN,RAPP,SAPP,FS,CS
"RTN","HLOPURGE",80,0)
 Q:'$$GETMSG^HLOMSG(MSGIEN,.MSG)
"RTN","HLOPURGE",81,0)
 S (RAPP,SAPP)=""
"RTN","HLOPURGE",82,0)
 D
"RTN","HLOPURGE",83,0)
 .S FS=$E(MSG("HDR",1),4)
"RTN","HLOPURGE",84,0)
 .Q:FS=""
"RTN","HLOPURGE",85,0)
 .S CS=$E(MSG("HDR",1),5)
"RTN","HLOPURGE",86,0)
 .S SAPP=$P($P(MSG("HDR",1),FS,3),CS)
"RTN","HLOPURGE",87,0)
 .I SAPP="" S SAPP="UNKNOWN"
"RTN","HLOPURGE",88,0)
 .S RAPP=$P($P(MSG("HDR",1),FS,5),CS)
"RTN","HLOPURGE",89,0)
 .I RAPP="" S RAPP="UNKNOWN"
"RTN","HLOPURGE",90,0)
 ;
"RTN","HLOPURGE",91,0)
 I 'MSG("BATCH") D KSEARCH(.MSG,MSG("MESSAGE TYPE"),MSG("EVENT"),SAPP,RAPP,MSGIEN)
"RTN","HLOPURGE",92,0)
 ;if an error status,take care of the "ERRORS" x-ref
"RTN","HLOPURGE",93,0)
 I MSG("STATUS")'="",MSG("STATUS")'="SU",MSG("BODY") D
"RTN","HLOPURGE",94,0)
 .N APP
"RTN","HLOPURGE",95,0)
 .S APP=$S(MSG("STATUS")="TF":SAPP,1:RAPP)
"RTN","HLOPURGE",96,0)
 .K ^HLB("ERRORS",MSG("STATUS"),APP,MSG("DT/TM CREATED"),MSGIEN)
"RTN","HLOPURGE",97,0)
 .I MSG("STATUS")="AE" D
"RTN","HLOPURGE",98,0)
 ..N SUB
"RTN","HLOPURGE",99,0)
 ..S SUB=MSGIEN_"^"
"RTN","HLOPURGE",100,0)
 ..K ^HLB("ERRORS","AE",APP,MSG("DT/TM CREATED"),SUB)
"RTN","HLOPURGE",101,0)
 ..F  S SUB=$O(^HLB("ERRORS","AE",APP,MSG("DT/TM CREATED"),SUB)) Q:SUB=""  Q:+SUB'=MSGIEN  K ^HLB("ERRORS","AE",APP,MSG("DT/TM CREATED"),SUB)
"RTN","HLOPURGE",102,0)
 ;
"RTN","HLOPURGE",103,0)
 ;kill the whole-file xrefs for the message ien within a batch
"RTN","HLOPURGE",104,0)
 S SUBIEN=0
"RTN","HLOPURGE",105,0)
 F  S SUBIEN=$O(^HLB(MSGIEN,3,SUBIEN)) Q:'SUBIEN  D
"RTN","HLOPURGE",106,0)
 .N MSGID
"RTN","HLOPURGE",107,0)
 .I FS]"" D
"RTN","HLOPURGE",108,0)
 ..N VALUE,HDR2,MSGTYPE,EVENT
"RTN","HLOPURGE",109,0)
 ..S HDR2=$G(^HLB(MSGIEN,3,SUBIEN,2))
"RTN","HLOPURGE",110,0)
 ..S VALUE=$P(HDR2,FS,4)
"RTN","HLOPURGE",111,0)
 ..S MSGTYPE=$P(VALUE,CS)
"RTN","HLOPURGE",112,0)
 ..S EVENT=$P(VALUE,CS,2)
"RTN","HLOPURGE",113,0)
 ..D KSEARCH(.MSG,MSGTYPE,EVENT,SAPP,RAPP,MSGIEN_"^"_SUBIEN)
"RTN","HLOPURGE",114,0)
 .S MSGID=$P($G(^HLB(MSGIEN,3,SUBIEN,0)),"^",2)
"RTN","HLOPURGE",115,0)
 .I MSGID]"" K ^HLB("AE",MSGID,MSGIEN_"^"_SUBIEN)
"RTN","HLOPURGE",116,0)
 ;
"RTN","HLOPURGE",117,0)
 I MSG("DIRECTION")="IN" D
"RTN","HLOPURGE",118,0)
 .Q:FS=""
"RTN","HLOPURGE",119,0)
 .N VALUE,HDR
"RTN","HLOPURGE",120,0)
 .S HDR("SENDING APPLICATION")=$P(MSG("HDR",1),FS,3)
"RTN","HLOPURGE",121,0)
 .S VALUE=$P(MSG("HDR",1),FS,4)
"RTN","HLOPURGE",122,0)
 .S HDR("SENDING FACILITY",1)=$P(VALUE,CS)
"RTN","HLOPURGE",123,0)
 .S HDR("SENDING FACILITY",2)=$P(VALUE,CS,2)
"RTN","HLOPURGE",124,0)
 .S HDR("SENDING FACILITY",3)=$P(VALUE,CS,3)
"RTN","HLOPURGE",125,0)
 .S AC=$S(HDR("SENDING FACILITY",2)]"":HDR("SENDING FACILITY",2),1:HDR("SENDING FACILITY",1))_HDR("SENDING APPLICATION")_MSG("ID")
"RTN","HLOPURGE",126,0)
 K ^HLB(MSGIEN)
"RTN","HLOPURGE",127,0)
 I MSG("STATUS","PURGE"),MSG("DIRECTION")'="" K ^HLB("AD",MSG("DIRECTION"),MSG("STATUS","PURGE"),MSGIEN)
"RTN","HLOPURGE",128,0)
 K:(MSG("ID")]"") ^HLB("B",MSG("ID"),MSGIEN)
"RTN","HLOPURGE",129,0)
 I MSG("DIRECTION")="IN" D
"RTN","HLOPURGE",130,0)
 .K:(AC]"") ^HLB("AC",AC,MSGIEN)
"RTN","HLOPURGE",131,0)
 .I MSG("BODY"),'$G(FLAG) D KILL777(MSG("BODY"))
"RTN","HLOPURGE",132,0)
 I MSG("DIRECTION")="OUT" D
"RTN","HLOPURGE",133,0)
 .K ^HLB("C",+MSG("BODY"),MSGIEN)
"RTN","HLOPURGE",134,0)
 .I '$G(FLAG),'$O(^HLB("C",+MSG("BODY"),0)) D KILL777(MSG("BODY"))
"RTN","HLOPURGE",135,0)
 Q
"RTN","HLOPURGE",136,0)
 ;
"RTN","HLOPURGE",137,0)
KILL777(BODY) ;
"RTN","HLOPURGE",138,0)
 N TIME
"RTN","HLOPURGE",139,0)
 S TIME=$P($G(^HLA(BODY,0)),"^")
"RTN","HLOPURGE",140,0)
 K ^HLA(BODY)
"RTN","HLOPURGE",141,0)
 K:(TIME]"") ^HLA("B",TIME,BODY)
"RTN","HLOPURGE",142,0)
 Q
"RTN","HLOPURGE",143,0)
 ;
"RTN","HLOPURGE",144,0)
KSEARCH(MSG,MSGTYPE,EVENT,SAPP,RAPP,IEN) ;
"RTN","HLOPURGE",145,0)
 ;Kills the ^HLB("SEARCH") x-ref
"RTN","HLOPURGE",146,0)
 ;
"RTN","HLOPURGE",147,0)
 N APP
"RTN","HLOPURGE",148,0)
 Q:MSGTYPE=""
"RTN","HLOPURGE",149,0)
 Q:EVENT=""
"RTN","HLOPURGE",150,0)
 Q:'MSG("DT/TM CREATED")
"RTN","HLOPURGE",151,0)
 I MSG("DIRECTION")'="IN",MSG("DIRECTION")'="OUT" Q
"RTN","HLOPURGE",152,0)
 S APP=$S(MSG("DIRECTION")="IN":RAPP,1:SAPP)
"RTN","HLOPURGE",153,0)
 K ^HLB("SEARCH",MSG("DIRECTION"),MSG("DT/TM CREATED"),APP,MSGTYPE,EVENT,IEN)
"RTN","HLOPURGE",154,0)
 Q
"RTN","HLOQUE")
0^33^B5007132
"RTN","HLOQUE",1,0)
HLOQUE ;ALB/CJM- HL7 QUEUE MANAGEMENT - 10/4/94 1pm
"RTN","HLOQUE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOQUE",3,0)
 ;
"RTN","HLOQUE",4,0)
INQUE(FROM,QNAME,IEN778,ACTION,PURGE) ;
"RTN","HLOQUE",5,0)
 ;Will place the message=IEN778 on the IN queue, incoming
"RTN","HLOQUE",6,0)
 ;Input:
"RTN","HLOQUE",7,0)
 ;  FROM - sending facility from message header.
"RTN","HLOQUE",8,0)
 ;         For actions other than incoming messages, its the specified link.
"RTN","HLOQUE",9,0)
 ;  QNAME - queue named by the application
"RTN","HLOQUE",10,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",11,0)
 ;  ACTION - <tag^routine> that should be executed for the application
"RTN","HLOQUE",12,0)
 ;  PURGE (optional) - PURGE=1 indicates that the purge dt/tm needs to be set by the infiler
"RTN","HLOQUE",13,0)
 ;     If PURGE("ACKTOIEN") is set, it indicates that the purge dt/tm of
"RTN","HLOQUE",14,0)
 ;     the original message to this application ack also needs to be set.
"RTN","HLOQUE",15,0)
 ;Output: none
"RTN","HLOQUE",16,0)
 ;
"RTN","HLOQUE",17,0)
 I $G(FROM)="" S FROM="UNKNOWN"
"RTN","HLOQUE",18,0)
 I '$L($G(QNAME)) S QNAME="DEFAULT"
"RTN","HLOQUE",19,0)
 S ^HLB("QUEUE","IN",FROM,QNAME,IEN778)=ACTION_"^"_$G(PURGE)_"^"_$G(PURGE("ACKTOIEN"))
"RTN","HLOQUE",20,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","IN",FROM,QNAME)))
"RTN","HLOQUE",21,0)
 Q
"RTN","HLOQUE",22,0)
 ;
"RTN","HLOQUE",23,0)
OUTQUE(LINKNAME,PORT,QNAME,IEN778) ;
"RTN","HLOQUE",24,0)
 ;Will place the message=IEN778 on the out-going queue
"RTN","HLOQUE",25,0)
 ;Input:
"RTN","HLOQUE",26,0)
 ;  LINKNAME = name of (.01) the logical link
"RTN","HLOQUE",27,0)
 ;  PORT (optional) the port to connect to
"RTN","HLOQUE",28,0)
 ;  QNAME - queue named by the application
"RTN","HLOQUE",29,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",30,0)
 ;Output: none
"RTN","HLOQUE",31,0)
 ;
"RTN","HLOQUE",32,0)
 N SUB
"RTN","HLOQUE",33,0)
 S SUB=LINKNAME
"RTN","HLOQUE",34,0)
 I PORT S SUB=SUB_":"_PORT
"RTN","HLOQUE",35,0)
 I '$L($G(QNAME)) S QNAME="DEFAULT"
"RTN","HLOQUE",36,0)
 S ^HLB("QUEUE","OUT",SUB,QNAME,IEN778)=""
"RTN","HLOQUE",37,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","OUT",SUB,QNAME)))
"RTN","HLOQUE",38,0)
 Q
"RTN","HLOQUE",39,0)
 ;
"RTN","HLOQUE",40,0)
DEQUE(FROMORTO,QNAME,DIR,IEN778) ;
"RTN","HLOQUE",41,0)
 ;This routine will remove the message=IEN778 from its queue
"RTN","HLOQUE",42,0)
 ;Input:
"RTN","HLOQUE",43,0)
 ;  DIR = "IN" or "OUT", denoting the direction that the message is going in
"RTN","HLOQUE",44,0)
 ;  FROMORTO = for outgoing: the .01 field of the logical link
"RTN","HLOQUE",45,0)
 ;         for incoming: sending facility
"RTN","HLOQUE",46,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",47,0)
 ;Output: none
"RTN","HLOQUE",48,0)
 ;
"RTN","HLOQUE",49,0)
 Q:(FROMORTO="")
"RTN","HLOQUE",50,0)
 I ($G(QNAME)="") S QNAME="DEFAULT"
"RTN","HLOQUE",51,0)
 D
"RTN","HLOQUE",52,0)
 .I $E(DIR)="I" S DIR="IN" Q
"RTN","HLOQUE",53,0)
 .I $E(DIR)="O" S DIR="OUT" Q
"RTN","HLOQUE",54,0)
 I DIR'="IN",DIR'="OUT" Q
"RTN","HLOQUE",55,0)
 Q:'$G(IEN778)
"RTN","HLOQUE",56,0)
 I $D(^HLB("QUEUE",DIR,FROMORTO,QNAME,IEN778)) K ^HLB("QUEUE",DIR,FROMORTO,QNAME,IEN778) I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT",DIR,FROMORTO,QNAME)),-1)
"RTN","HLOQUE",57,0)
 Q
"RTN","HLOQUE",58,0)
 ;
"RTN","HLOQUE",59,0)
STOPQUE(DIR,QUEUE) ;
"RTN","HLOQUE",60,0)
 ;This API is used to set a stop flag on a named queue.
"RTN","HLOQUE",61,0)
 ;DIR=<"IN" or "OUT">
"RTN","HLOQUE",62,0)
 ;QUEUE - the name of the queue to be stopped
"RTN","HLOQUE",63,0)
 ;
"RTN","HLOQUE",64,0)
 Q:$G(DIR)=""
"RTN","HLOQUE",65,0)
 Q:$G(QUEUE)=""
"RTN","HLOQUE",66,0)
 S ^HLTMP("STOPPED QUEUES",DIR,QUEUE)=1
"RTN","HLOQUE",67,0)
 Q
"RTN","HLOQUE",68,0)
STARTQUE(DIR,QUEUE) ;
"RTN","HLOQUE",69,0)
 ;This API is used to REMOVE the stop flag on a named queue.
"RTN","HLOQUE",70,0)
 ;DIR=<"IN" or "OUT">
"RTN","HLOQUE",71,0)
 ;QUEUE - the name of the queue to be stopped
"RTN","HLOQUE",72,0)
 ;
"RTN","HLOQUE",73,0)
 Q:$G(DIR)=""
"RTN","HLOQUE",74,0)
 Q:$G(QUEUE)=""
"RTN","HLOQUE",75,0)
 K ^HLTMP("STOPPED QUEUES",DIR,QUEUE)
"RTN","HLOQUE",76,0)
 Q
"RTN","HLOQUE",77,0)
STOPPED(DIR,QUEUE) ;
"RTN","HLOQUE",78,0)
 ;This API is used to DETERMINE if the stop flag on a named queue is set.
"RTN","HLOQUE",79,0)
 ;Input:
"RTN","HLOQUE",80,0)
 ;  DIR=<"IN" or "OUT">
"RTN","HLOQUE",81,0)
 ;  QUEUE - the name of the queue to be checked
"RTN","HLOQUE",82,0)
 ;Output:
"RTN","HLOQUE",83,0)
 ;  Function returns 1 if the queue is stopped, 0 otherwise
"RTN","HLOQUE",84,0)
 Q:$G(DIR)="" 0
"RTN","HLOQUE",85,0)
 Q:$G(QUEUE)="" 0
"RTN","HLOQUE",86,0)
 I $G(^HLTMP("STOPPED QUEUES",DIR,QUEUE)) Q 1
"RTN","HLOQUE",87,0)
 Q 0
"RTN","HLOSITE")
0^35^B5183865
"RTN","HLOSITE",1,0)
HLOSITE ;ALB/CJM-HL7 - API for getting site parameters ;02/04/2004
"RTN","HLOSITE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOSITE",3,0)
 ;
"RTN","HLOSITE",4,0)
SYSPARMS(SYSTEM) ;Gets system parameters from file 779.1
"RTN","HLOSITE",5,0)
 ;Input: none
"RTN","HLOSITE",6,0)
 ;Output:
"RTN","HLOSITE",7,0)
 ;
"RTN","HLOSITE",8,0)
 N NODE,LINK
"RTN","HLOSITE",9,0)
 S NODE=$G(^HLD(779.1,1,0))
"RTN","HLOSITE",10,0)
 S SYSTEM("DOMAIN")=$P(NODE,"^")
"RTN","HLOSITE",11,0)
 S SYSTEM("STATION")=$P(NODE,"^",2)
"RTN","HLOSITE",12,0)
 S SYSTEM("PROCESSING ID")=$P(NODE,"^",3)
"RTN","HLOSITE",13,0)
 S SYSTEM("MAXSTRING")=$P(NODE,"^",4)
"RTN","HLOSITE",14,0)
 I 'SYSTEM("MAXSTRING") D
"RTN","HLOSITE",15,0)
 .N OS S OS=^%ZOSF("OS")
"RTN","HLOSITE",16,0)
 .S SYSTEM("MAXSTRING")=$S(OS["OpenM":512,OS["DSM":512,1:256)
"RTN","HLOSITE",17,0)
 S SYSTEM("HL7 BUFFER")=$P(NODE,"^",5)
"RTN","HLOSITE",18,0)
 S:'SYSTEM("HL7 BUFFER") SYSTEM("HL7 BUFFER")=15000
"RTN","HLOSITE",19,0)
 S SYSTEM("USER BUFFER")=$P(NODE,"^",6)
"RTN","HLOSITE",20,0)
 S:'SYSTEM("USER BUFFER") SYSTEM("USER BUFFER")=5000
"RTN","HLOSITE",21,0)
 S SYSTEM("NORMAL PURGE")=$P(NODE,"^",7)
"RTN","HLOSITE",22,0)
 I 'SYSTEM("NORMAL PURGE") S SYSTEM("NORMAL PURGE")=36
"RTN","HLOSITE",23,0)
 S SYSTEM("ERROR PURGE")=$P(NODE,"^",8)
"RTN","HLOSITE",24,0)
 I 'SYSTEM("ERROR PURGE") S SYSTEM("ERROR PURGE")=7
"RTN","HLOSITE",25,0)
 S LINK=$P(NODE,"^",10)
"RTN","HLOSITE",26,0)
 S:LINK SYSTEM("PORT")=$$PORT^HLOTLNK(LINK)
"RTN","HLOSITE",27,0)
 S:'$G(SYSTEM("PORT")) SYSTEM("PORT")=$S(SYSTEM("PROCESSING ID")="P":5001,1:5026)
"RTN","HLOSITE",28,0)
 Q
"RTN","HLOSITE",29,0)
 ;
"RTN","HLOSITE",30,0)
INC(VARIABLE,AMOUNT) ;
"RTN","HLOSITE",31,0)
 ;Increments VARIABLE by AMOUNT, using $I if available, otherwise by locking.
"RTN","HLOSITE",32,0)
 ;
"RTN","HLOSITE",33,0)
 N OS
"RTN","HLOSITE",34,0)
 ;if HLCSTATE has been defined, then we have already checked the OS, so use it.
"RTN","HLOSITE",35,0)
 I $D(HLCSTATE("SYSTEM","OS")) D
"RTN","HLOSITE",36,0)
 .S OS=HLCSTATE("SYSTEM","OS")
"RTN","HLOSITE",37,0)
 E  D
"RTN","HLOSITE",38,0)
 .S OS=^%ZOSF("OS")
"RTN","HLOSITE",39,0)
 I '$G(AMOUNT) S AMOUNT=1
"RTN","HLOSITE",40,0)
 I (OS["OpenM")!(OS["DSM")!(OS["CACHE") Q $I(@VARIABLE,AMOUNT)
"RTN","HLOSITE",41,0)
 L +VARIABLE:100
"RTN","HLOSITE",42,0)
 S @VARIABLE=@VARIABLE+AMOUNT
"RTN","HLOSITE",43,0)
 L -VARIABLE
"RTN","HLOSITE",44,0)
 Q @VARIABLE
"RTN","HLOSITE",45,0)
 ;
"RTN","HLOSITE",46,0)
COUNT778() ;
"RTN","HLOSITE",47,0)
 ;This function returns the # of records in file 778.
"RTN","HLOSITE",48,0)
 N COUNT,IEN
"RTN","HLOSITE",49,0)
 S (COUNT,IEN)=0
"RTN","HLOSITE",50,0)
 F  S IEN=$O(^HLB(IEN)) Q:'IEN  S COUNT=COUNT+1
"RTN","HLOSITE",51,0)
 Q COUNT
"RTN","HLOSITE",52,0)
COUNT777() ;
"RTN","HLOSITE",53,0)
 ;This function returns the # of records in file 777.
"RTN","HLOSITE",54,0)
 N COUNT,IEN
"RTN","HLOSITE",55,0)
 S (COUNT,IEN)=0
"RTN","HLOSITE",56,0)
 F  S IEN=$O(^HLA(IEN)) Q:'IEN  S COUNT=COUNT+1
"RTN","HLOSITE",57,0)
 Q COUNT
"RTN","HLOSITE",58,0)
 ;
"RTN","HLOSITE",59,0)
UPDCNTS ;update the record counts for file 777,778
"RTN","HLOSITE",60,0)
 N COUNT
"RTN","HLOSITE",61,0)
 S COUNT=$$COUNT777^HLOSITE
"RTN","HLOSITE",62,0)
 S $P(^HLA(0),"^",4)=COUNT
"RTN","HLOSITE",63,0)
 S ^HLTMP("FILE 777 RECORD COUNT")=COUNT_"^"_$$NOW^XLFDT
"RTN","HLOSITE",64,0)
 S COUNT=$$COUNT778^HLOSITE
"RTN","HLOSITE",65,0)
 S $P(^HLB(0),"^",4)=COUNT
"RTN","HLOSITE",66,0)
 S ^HLTMP("FILE 778 RECORD COUNT")=COUNT_"^"_$$NOW^XLFDT
"RTN","HLOSITE",67,0)
 Q
"RTN","HLOSRVR")
0^36^B67857069
"RTN","HLOSRVR",1,0)
HLOSRVR ;ALB/CJM- Server for receiving messages - 10/4/94 1pm
"RTN","HLOSRVR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOSRVR",3,0)
 ;
"RTN","HLOSRVR",4,0)
GETWORK(WORK) ;
"RTN","HLOSRVR",5,0)
 ;GET WORK function for a single server OR Taskman multi-server
"RTN","HLOSRVR",6,0)
 N LINK
"RTN","HLOSRVR",7,0)
 I '$$CHKSTOP^HLOPROC,$G(WORK("LINK"))]"",$$GETLINK^HLOTLNK(WORK("LINK"),.LINK),+LINK("SERVER") S WORK("PORT")=LINK("PORT") Q 1
"RTN","HLOSRVR",8,0)
 Q 0
"RTN","HLOSRVR",9,0)
 ;
"RTN","HLOSRVR",10,0)
DOWORKS(WORK) ;
"RTN","HLOSRVR",11,0)
 ;DO WORK rtn for a single server (non-concurrent)
"RTN","HLOSRVR",12,0)
 D SERVER(WORK("LINK"))
"RTN","HLOSRVR",13,0)
 Q
"RTN","HLOSRVR",14,0)
DOWORKM(WORK) ;
"RTN","HLOSRVR",15,0)
 ;DO WORK rtn for a Taskman multi-server (Cache systems only)
"RTN","HLOSRVR",16,0)
 D LISTEN^%ZISTCPS(WORK("PORT"),"SERVER^HLOSRVR("""_WORK("LINK")_""")")
"RTN","HLOSRVR",17,0)
 Q
"RTN","HLOSRVR",18,0)
 ;
"RTN","HLOSRVR",19,0)
VMS ;called from VMS TCP Service once a connection request has been received
"RTN","HLOSRVR",20,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",21,0)
 N LINKNAME,PROC
"RTN","HLOSRVR",22,0)
 S PROC=$O(^HLD(779.3,"B","VMS TCP LISTENER",0))
"RTN","HLOSRVR",23,0)
 I 'PROC D ^%ZTER Q
"RTN","HLOSRVR",24,0)
 S LINKNAME=$P($G(^HLD(779.3,PROC,0)),"^",14)
"RTN","HLOSRVR",25,0)
 I $G(LINKNAME)="" D ^%ZTER Q
"RTN","HLOSRVR",26,0)
 D SERVER(LINKNAME,"SYS$NET")
"RTN","HLOSRVR",27,0)
 Q
"RTN","HLOSRVR",28,0)
 ;
"RTN","HLOSRVR",29,0)
SERVER(LINKNAME,LOGICAL) ; LINKNAME identifies the logical link, which describes the communication channel to be used
"RTN","HLOSRVR",30,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOSRVR1"
"RTN","HLOSRVR",31,0)
 N HLCSTATE,INQUE
"RTN","HLOSRVR",32,0)
 S INQUE=0
"RTN","HLOSRVR",33,0)
 Q:'$$CONNECT(.HLCSTATE,LINKNAME,.LOGICAL)
"RTN","HLOSRVR",34,0)
 K LINKNAME
"RTN","HLOSRVR",35,0)
 F  Q:'HLCSTATE("CONNECTED")  D  Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",36,0)
 .N HLMSTATE,SENT
"RTN","HLOSRVR",37,0)
 .I $$READMSG^HLOSRVR1(.HLCSTATE,.HLMSTATE) D
"RTN","HLOSRVR",38,0)
 ..;$$READMSG also parses the hdr and determines what to do - HLMSTATE("MSA",1) is the ack to return= <"","CA","CE","CR","AE">
"RTN","HLOSRVR",39,0)
 ..;send an ack if required and save the MSA segment
"RTN","HLOSRVR",40,0)
 ..I (HLMSTATE("MSA",1)]"") S SENT=$$WRITEACK(.HLCSTATE,.HLMSTATE) D:HLMSTATE("IEN") SAVEACK(.HLMSTATE,SENT)
"RTN","HLOSRVR",41,0)
 ..I HLMSTATE("IEN") D UPDATE(.HLMSTATE,.HLCSTATE)
"RTN","HLOSRVR",42,0)
 .E  D INQUE() H 1
"RTN","HLOSRVR",43,0)
 ;
"RTN","HLOSRVR",44,0)
END D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR",45,0)
 D INQUE()
"RTN","HLOSRVR",46,0)
 Q
"RTN","HLOSRVR",47,0)
 ;
"RTN","HLOSRVR",48,0)
CONNECT(HLCSTATE,LINKNAME,LOGICAL) ;
"RTN","HLOSRVR",49,0)
 ;sets up HLCSTATE() and opens a server connection
"RTN","HLOSRVR",50,0)
 ;
"RTN","HLOSRVR",51,0)
 N LINK,NODE
"RTN","HLOSRVR",52,0)
 Q:'$$GETLINK^HLOTLNK(LINKNAME,.LINK) 0
"RTN","HLOSRVR",53,0)
 Q:+LINK("SERVER")'=1 0
"RTN","HLOSRVR",54,0)
 S HLCSTATE("SERVER")=LINK("SERVER")
"RTN","HLOSRVR",55,0)
 M HLCSTATE("LINK")=LINK
"RTN","HLOSRVR",56,0)
 S HLCSTATE("ATTEMPT")=1 ;count of #of read attempts, incremented if a message hdr is read but the read fails before the end
"RTN","HLOSRVR",57,0)
 S HLCSTATE("READ")="" ;where the reads are stored
"RTN","HLOSRVR",58,0)
 ;
"RTN","HLOSRVR",59,0)
 ;HLCSTATE("BUFFER",<seg>,<line>) serves as a write buffer so that a lot can be written all at once
"RTN","HLOSRVR",60,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of BYTES in buffer
"RTN","HLOSRVR",61,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOSRVR",62,0)
 ;
"RTN","HLOSRVR",63,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOSRVR",64,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOSRVR",65,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOSRVR",66,0)
 Q:HLCSTATE("SYSTEM","OS")="" 0
"RTN","HLOSRVR",67,0)
 D  ;get necessary system parameters
"RTN","HLOSRVR",68,0)
 .N SYS,SUB
"RTN","HLOSRVR",69,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOSRVR",70,0)
 .F SUB="MAXSTRING","DOMAIN","STATION","PROCESSING ID","NORMAL PURGE","ERROR PURGE" S HLCSTATE("SYSTEM",SUB)=SYS(SUB)
"RTN","HLOSRVR",71,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOSRVR",72,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOSRVR",73,0)
 .D OPEN^HLOTCP(.HLCSTATE,.LOGICAL)
"RTN","HLOSRVR",74,0)
 ;E  I HLCSTATE("LINK","LLP")="HLLP" D  ;serial
"RTN","HLOSRVR",75,0)
 ;.;serial connections are deferred for later development
"RTN","HLOSRVR",76,0)
 ;
"RTN","HLOSRVR",77,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOSRVR",78,0)
 ;
"RTN","HLOSRVR",79,0)
INQUE(MSGIEN,PARMS) ;
"RTN","HLOSRVR",80,0)
 ;puts received messages on the incoming queue and sets the B x-refs
"RTN","HLOSRVR",81,0)
 I $G(MSGIEN) S INQUE=INQUE+1 M INQUE(MSGIEN)=PARMS
"RTN","HLOSRVR",82,0)
 I ('$G(MSGIEN))!(INQUE>20) S MSGIEN=0 D
"RTN","HLOSRVR",83,0)
 .F  S MSGIEN=$O(INQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOSRVR",84,0)
 ..S ^HLB("B",INQUE(MSGIEN,"MSGID"),MSGIEN)=""
"RTN","HLOSRVR",85,0)
 ..S ^HLA("B",INQUE(MSGIEN,"DT/TM"),INQUE(MSGIEN,"BODY"))=""
"RTN","HLOSRVR",86,0)
 ..D:INQUE(MSGIEN,"PASS")
"RTN","HLOSRVR",87,0)
 ...N PURGE
"RTN","HLOSRVR",88,0)
 ...S PURGE=+$G(INQUE(MSGIEN,"PURGE"))
"RTN","HLOSRVR",89,0)
 ...S PURGE("ACKTOIEN")=$G(INQUE(MSGIEN,"ACKTOIEN"))
"RTN","HLOSRVR",90,0)
 ...D INQUE^HLOQUE(INQUE(MSGIEN,"FROM"),INQUE(MSGIEN,"QUEUE"),MSGIEN,INQUE(MSGIEN,"ACTION"),.PURGE)
"RTN","HLOSRVR",91,0)
 .K INQUE S INQUE=0
"RTN","HLOSRVR",92,0)
 Q
"RTN","HLOSRVR",93,0)
 ;
"RTN","HLOSRVR",94,0)
SAVEACK(HLMSTATE,SENT) ;
"RTN","HLOSRVR",95,0)
 ;Input:
"RTN","HLOSRVR",96,0)
 ;  SENT - flag = 1 if transmission of ack succeeded, 0 otherwise
"RTN","HLOSRVR",97,0)
 ;
"RTN","HLOSRVR",98,0)
 N NODE,I
"RTN","HLOSRVR",99,0)
 S $P(NODE,"^")=HLMSTATE("MSA","DT/TM OF MESSAGE")
"RTN","HLOSRVR",100,0)
 S $P(NODE,"^",2)=HLMSTATE("MSA","MESSAGE CONTROL ID")
"RTN","HLOSRVR",101,0)
 S $P(NODE,"^",3)="MSA"
"RTN","HLOSRVR",102,0)
 F I=1:1:3 S NODE=NODE_"|"_$G(HLMSTATE("MSA",I))
"RTN","HLOSRVR",103,0)
 S ^HLB(HLMSTATE("IEN"),4)=NODE
"RTN","HLOSRVR",104,0)
 S:SENT $P(^HLB(HLMSTATE("IEN"),0),"^",$S($E(HLMSTATE("MSA",1))="A":18,1:17))=1
"RTN","HLOSRVR",105,0)
 Q
"RTN","HLOSRVR",106,0)
 ;
"RTN","HLOSRVR",107,0)
UPDATE(HLMSTATE,HLCSTATE) ;
"RTN","HLOSRVR",108,0)
 ;Updates status and purge date when appropriate
"RTN","HLOSRVR",109,0)
 ;Also, sets the "B" xrefs, files 777,778, and places message on the incoming queue
"RTN","HLOSRVR",110,0)
 ;
"RTN","HLOSRVR",111,0)
 N PARMS,PURGE,WAIT
"RTN","HLOSRVR",112,0)
 S PARMS("PASS")=0
"RTN","HLOSRVR",113,0)
 I HLMSTATE("STATUS","ACTION")]"",HLMSTATE("STATUS")'="SE" S PARMS("PASS")=1,$P(^HLB(HLMSTATE("IEN"),0),"^",6)=HLMSTATE("STATUS","QUEUE")
"RTN","HLOSRVR",114,0)
 D:'PARMS("PASS")  ;if not passing to the app, set the purge date
"RTN","HLOSRVR",115,0)
 .I HLMSTATE("STATUS")="" S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",116,0)
 .S:HLMSTATE("BATCH") WAIT=HLCSTATE("SYSTEM","ERROR PURGE")
"RTN","HLOSRVR",117,0)
 .S:'HLMSTATE("BATCH") WAIT=$S(HLMSTATE("STATUS")="SE":24*HLCSTATE("SYSTEM","ERROR PURGE"),1:HLCSTATE("SYSTEM","NORMAL PURGE"))
"RTN","HLOSRVR",118,0)
 .S PURGE=$$FMADD^XLFDT($$NOW^XLFDT,,WAIT)
"RTN","HLOSRVR",119,0)
 .S $P(^HLB(HLMSTATE("IEN"),0),"^",9)=PURGE
"RTN","HLOSRVR",120,0)
 .S ^HLB("AD","IN",PURGE,HLMSTATE("IEN"))=""
"RTN","HLOSRVR",121,0)
 ;
"RTN","HLOSRVR",122,0)
 ;if not waiting for an application ack, set the status now even if passing to the app - but don't set the purge until the infiler passes the message
"RTN","HLOSRVR",123,0)
 I HLMSTATE("STATUS")="",HLMSTATE("HDR","APP ACK TYPE")'="AL" S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",124,0)
 I HLMSTATE("STATUS")'="" S $P(^HLB(HLMSTATE("IEN"),0),"^",20)=HLMSTATE("STATUS") S:$G(HLMSTATE("MSA",3))]"" $P(^HLB(HLMSTATE("IEN"),0),"^",21)=HLMSTATE("MSA",3) D:HLMSTATE("STATUS")="SE"
"RTN","HLOSRVR",125,0)
 .N APP
"RTN","HLOSRVR",126,0)
 .S APP=HLMSTATE("HDR","RECEIVING APPLICATION") S:APP="" APP="UNKNOWN" S ^HLB("ERRORS","SE",APP,HLMSTATE("DT/TM"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR",127,0)
 ;
"RTN","HLOSRVR",128,0)
 ;set the necessary parms for passing the msg to the app via the infiler
"RTN","HLOSRVR",129,0)
 D:PARMS("PASS")
"RTN","HLOSRVR",130,0)
 .N I,FROM
"RTN","HLOSRVR",131,0)
 .S FROM=HLMSTATE("HDR","SENDING FACILITY",1)
"RTN","HLOSRVR",132,0)
 .I HLMSTATE("HDR","SENDING FACILITY",2)]"" S FROM=FROM_"~"_HLMSTATE("HDR","SENDING FACILITY",2)_"~"_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",133,0)
 .I FROM="" S FROM="UNKNOWN SENDING FACILITY"
"RTN","HLOSRVR",134,0)
 .S PARMS("FROM")=FROM,PARMS("QUEUE")=HLMSTATE("STATUS","QUEUE"),PARMS("ACTION")=HLMSTATE("STATUS","ACTION")
"RTN","HLOSRVR",135,0)
 .I HLMSTATE("STATUS")'="" S PARMS("PURGE")=1
"RTN","HLOSRVR",136,0)
 .S:$G(HLMSTATE("ACK TO","IEN")) PARMS("ACKTOIEN")=HLMSTATE("ACK TO","IEN") ;to insure that the infiler will know to set the purge date at the same time as the initial message
"RTN","HLOSRVR",137,0)
 ;
"RTN","HLOSRVR",138,0)
 S PARMS("BODY")=HLMSTATE("BODY")
"RTN","HLOSRVR",139,0)
 S PARMS("DT/TM")=HLMSTATE("DT/TM")
"RTN","HLOSRVR",140,0)
 S PARMS("MSGID")=$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOSRVR",141,0)
 D INQUE(HLMSTATE("IEN"),.PARMS)
"RTN","HLOSRVR",142,0)
 Q
"RTN","HLOSRVR",143,0)
 ;
"RTN","HLOSRVR",144,0)
WRITEACK(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR",145,0)
 ;Sends an accept ack
"RTN","HLOSRVR",146,0)
 ;
"RTN","HLOSRVR",147,0)
 ;Input:
"RTN","HLOSRVR",148,0)
 ;  HLCSTATE (pass by reference) defines the communication channel
"RTN","HLOSRVR",149,0)
 ;  HLMSTATE (pass by reference) the message being acked
"RTN","HLOSRVR",150,0)
 ;     ("MSA",1) - value to put in MSA-1
"RTN","HLOSRVR",151,0)
 ;     ("MSA",2) - value to put in MSA-2
"RTN","HLOSRVR",152,0)
 ;     ("MSA",3) - value to put in MSA-3
"RTN","HLOSRVR",153,0)
 ;     ("HDR") - parsed values for the message being ack'd
"RTN","HLOSRVR",154,0)
 ;Output:
"RTN","HLOSRVR",155,0)
 ;  Function returns 1 if successful, 0 otherwise
"RTN","HLOSRVR",156,0)
 ;  HLMSTATE("MSA","MESSAGE CONTROL ID") - the msg id of the ack
"RTN","HLOSRVR",157,0)
 ;  HLMSTATE(,"MSA","DT/TM OF MESSAGE") - from the ack header
"RTN","HLOSRVR",158,0)
 ;
"RTN","HLOSRVR",159,0)
 N HDR,SUB,FS,CS,MSA,ACKID,TIME
"RTN","HLOSRVR",160,0)
 ;for simplicity, hard-code the delimiters, the standard requires that the receiving system accept the delimiters listed in the header
"RTN","HLOSRVR",161,0)
 S FS="|"
"RTN","HLOSRVR",162,0)
 S CS="^"
"RTN","HLOSRVR",163,0)
 S TIME=$$NOW^XLFDT
"RTN","HLOSRVR",164,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=TIME
"RTN","HLOSRVR",165,0)
 S ACKID=HLCSTATE("SYSTEM","STATION")_" "_$$NEWIEN^HLOF778A("OUT")
"RTN","HLOSRVR",166,0)
 S HLMSTATE("MSA","MESSAGE CONTROL ID")=ACKID
"RTN","HLOSRVR",167,0)
 ;
"RTN","HLOSRVR",168,0)
 S HDR(1)="MSH"_FS_"^~\&"_FS_HLMSTATE("HDR","RECEIVING APPLICATION")_FS_HLCSTATE("SYSTEM","STATION")_CS_HLCSTATE("SYSTEM","DOMAIN")_CS_"DNS"_FS
"RTN","HLOSRVR",169,0)
 S HDR(1)=HDR(1)_HLMSTATE("HDR","SENDING APPLICATION")_FS_HLMSTATE("HDR","SENDING FACILITY",1)_CS_HLMSTATE("HDR","SENDING FACILITY",2)_CS_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",170,0)
 ;
"RTN","HLOSRVR",171,0)
 S HDR(2)=FS_$$HLDATE^HLFNC(TIME,"TS")_FS_FS_"ACK"_FS_ACKID_FS_HLMSTATE("HDR","PROCESSING ID")_FS_"2.4"_FS_FS_FS_"NE"_FS_"NE"
"RTN","HLOSRVR",172,0)
 ;
"RTN","HLOSRVR",173,0)
 S MSA(1)="MSA"_FS
"RTN","HLOSRVR",174,0)
 F SUB=1:1:3 S MSA(1)=MSA(1)_HLMSTATE("MSA",SUB)_FS
"RTN","HLOSRVR",175,0)
 I $$WRITEHDR^HLOT(.HLCSTATE,.HDR),$$WRITESEG^HLOT(.HLCSTATE,.MSA),$$ENDMSG^HLOT(.HLCSTATE) Q 1
"RTN","HLOSRVR",176,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=""
"RTN","HLOSRVR",177,0)
 Q 0
"RTN","HLOSRVR",178,0)
 ;
"RTN","HLOSRVR",179,0)
NEWSTATE(HLCSTATE,HLMSTATE,HDR,MSA) ;
"RTN","HLOSRVR",180,0)
 ;Inputs:
"RTN","HLOSRVR",181,0)
 ;  HLCSTATE (pass by reference)
"RTN","HLOSRVR",182,0)
 ;  HDR (pass by reference) parsed header
"RTN","HLOSRVR",183,0)
 ;  MSA - (pass by reference) the values to return in the accept ack
"RTN","HLOSRVR",184,0)
 ;Output:
"RTN","HLOSRVR",185,0)
 ;  HLMSTATE (pass by reference)
"RTN","HLOSRVR",186,0)
 ;
"RTN","HLOSRVR",187,0)
 ;initialize the HLMSTATE array with the header, in preparation for reading the rest of the message
"RTN","HLOSRVR",188,0)
 S HLMSTATE("IEN")=""
"RTN","HLOSRVR",189,0)
 S HLMSTATE("BODY")=""
"RTN","HLOSRVR",190,0)
 S HLMSTATE("DIRECTION")="IN"
"RTN","HLOSRVR",191,0)
 S HLMSTATE("CURRENT SEGMENT")=0 ;no segments in cache
"RTN","HLOSRVR",192,0)
 S HLMSTATE("UNSTORED LINES")=1 ;just the header in cache so far
"RTN","HLOSRVR",193,0)
 S HLMSTATE("LINE COUNT")=0 ;no lines within message stored to disk
"RTN","HLOSRVR",194,0)
 I HDR("SEGMENT TYPE")="BHS" D
"RTN","HLOSRVR",195,0)
 .S HLMSTATE("BATCH")=1
"RTN","HLOSRVR",196,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0 ;no messages in batch
"RTN","HLOSRVR",197,0)
 .S HLMSTATE("UNSTORED MSH")=0
"RTN","HLOSRVR",198,0)
 E  S HLMSTATE("BATCH")=0
"RTN","HLOSRVR",199,0)
 M HLMSTATE("HDR")=HDR
"RTN","HLOSRVR",200,0)
 M HLMSTATE("MSA")=MSA
"RTN","HLOSRVR",201,0)
 S HLMSTATE("STATUS")=""
"RTN","HLOSRVR",202,0)
 M HLMSTATE("SYSTEM")=HLCSTATE("SYSTEM")
"RTN","HLOSRVR",203,0)
 S HLMSTATE("STATUS","LINK NAME")=HLCSTATE("LINK","NAME")
"RTN","HLOSRVR",204,0)
 S HLMSTATE("STATUS","PORT")=$P(HDR("SENDING FACILITY",2),":",2)
"RTN","HLOSRVR",205,0)
 ;
"RTN","HLOSRVR",206,0)
 ;if this is a batch, and it references another batch, assume it is a batch of application acks.  That is the only time HLO uses that field.
"RTN","HLOSRVR",207,0)
 I HLMSTATE("BATCH"),HLMSTATE("HDR","REFERENCE BATCH CONTROL ID")]"" D
"RTN","HLOSRVR",208,0)
 .N IEN
"RTN","HLOSRVR",209,0)
 .S HLMSTATE("ACK TO")=HLMSTATE("HDR","REFERENCE BATCH CONTROL ID")
"RTN","HLOSRVR",210,0)
 .S HLMSTATE("ACK TO","STATUS")="SU"
"RTN","HLOSRVR",211,0)
 .S IEN=$O(^HLB("B",HLMSTATE("HDR","REFERENCE BATCH CONTROL ID"),0))
"RTN","HLOSRVR",212,0)
 .I IEN S HLMSTATE("ACK TO","IEN")=IEN_"^"
"RTN","HLOSRVR",213,0)
 E  S HLMSTATE("ACK TO")=""
"RTN","HLOSRVR",214,0)
 Q
"RTN","HLOSRVR1")
0^37^B62638202
"RTN","HLOSRVR1",1,0)
HLOSRVR1 ;IRMFO-ALB/CJM - Reading messages, sending acks;03/24/2004  14:43
"RTN","HLOSRVR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOSRVR1",3,0)
 ;
"RTN","HLOSRVR1",4,0)
READMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR1",5,0)
 ;This function uses the services provided by the transport layer to receive a message.  The header is parsed. Does these checks:
"RTN","HLOSRVR1",6,0)
 ; 1) Duplicate?
"RTN","HLOSRVR1",7,0)
 ; 2) Wrong Receiving Facility?
"RTN","HLOSRVR1",8,0)
 ; 3) Can the Receiving App accept this message, based on type of message & event?
"RTN","HLOSRVR1",9,0)
 ; 4) Processing ID must match the receiving system
"RTN","HLOSRVR1",10,0)
 ; 5) Must have a control ID
"RTN","HLOSRVR1",11,0)
 ; 6) Header must be BHS or MSH
"RTN","HLOSRVR1",12,0)
 ;
"RTN","HLOSRVR1",13,0)
 ;Output:
"RTN","HLOSRVR1",14,0)
 ;  Function returns 1 if the message was read fully, 0 otherwise
"RTN","HLOSRVR1",15,0)
 ;  HLMSTATE (pass by reference) the message.  It will include the fields for the return ack in HLMSTATE("MSA")
"RTN","HLOSRVR1",16,0)
 ;
"RTN","HLOSRVR1",17,0)
 N ACK,SEG,STORE,MSA,I
"RTN","HLOSRVR1",18,0)
 F I=1:1:3 S MSA(I)=""
"RTN","HLOSRVR1",19,0)
 ;
"RTN","HLOSRVR1",20,0)
 S STORE=1
"RTN","HLOSRVR1",21,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.SEG) 0
"RTN","HLOSRVR1",22,0)
 D SPLITHDR(.SEG)
"RTN","HLOSRVR1",23,0)
 S:'$$PARSEHDR^HLOPRS(.SEG) STORE=0
"RTN","HLOSRVR1",24,0)
 I STORE S MSA(2)=$S(SEG("SEGMENT TYPE")="BHS":SEG("BATCH CONTROL ID"),1:SEG("MESSAGE CONTROL ID")) I MSA(2)="" S STORE=0 I SEG("ACCEPT ACK TYPE")="AL" S MSA(1)="CE",MSA("3")="CONTROL ID MISSING"
"RTN","HLOSRVR1",25,0)
 I STORE,$$DUP(.SEG,.MSA) S STORE=0 ;$$DUP returns the prior MSA segment if this message is a duplicate
"RTN","HLOSRVR1",26,0)
 D NEWSTATE^HLOSRVR(.HLCSTATE,.HLMSTATE,.SEG,.MSA)
"RTN","HLOSRVR1",27,0)
 ;
"RTN","HLOSRVR1",28,0)
 ;if the message is not to be stored, just read it and discard the segments
"RTN","HLOSRVR1",29,0)
 I 'STORE D
"RTN","HLOSRVR1",30,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)
"RTN","HLOSRVR1",31,0)
 ;
"RTN","HLOSRVR1",32,0)
 ;else the message is to be stored
"RTN","HLOSRVR1",33,0)
 E  D
"RTN","HLOSRVR1",34,0)
 .N FS
"RTN","HLOSRVR1",35,0)
 .S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOSRVR1",36,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOSRVR1",37,0)
 ..N MSA,SEGTYPE,OLDMSGID,CODE,IEN,NEWMSGID
"RTN","HLOSRVR1",38,0)
 ..S SEGTYPE=$E($E(SEG(1),1,3)_$E($G(SEG(2)),1,2),1,3)
"RTN","HLOSRVR1",39,0)
 ..I SEGTYPE="MSA" D
"RTN","HLOSRVR1",40,0)
 ...S MSA=SEG(1)_$G(SEG(2))_$G(SEG(3))
"RTN","HLOSRVR1",41,0)
 ...S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2)
"RTN","HLOSRVR1",42,0)
 ...I $E(CODE,1)'="A" S SEGTYPE="" Q
"RTN","HLOSRVR1",43,0)
 ...S:$P(OLDMSGID,"-")]"" IEN=$O(^HLB("B",$P(OLDMSGID,"-"),0))
"RTN","HLOSRVR1",44,0)
 ...S:$G(IEN) IEN=IEN_"^"_$P(OLDMSGID,"-",2)
"RTN","HLOSRVR1",45,0)
 ..I 'HLMSTATE("BATCH") D
"RTN","HLOSRVR1",46,0)
 ...D:SEGTYPE="MSA"
"RTN","HLOSRVR1",47,0)
 ....S HLMSTATE("ACK TO")=OLDMSGID
"RTN","HLOSRVR1",48,0)
 ....S HLMSTATE("ACK TO","ACK BY")=HLMSTATE("HDR","MESSAGE CONTROL ID")
"RTN","HLOSRVR1",49,0)
 ....S HLMSTATE("ACK TO","STATUS")=$S(CODE="AA":"SU",1:"AE")
"RTN","HLOSRVR1",50,0)
 ....S:$D(IEN) HLMSTATE("ACK TO","IEN")=IEN
"RTN","HLOSRVR1",51,0)
 ...D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",52,0)
 ..E  D  ;batch
"RTN","HLOSRVR1",53,0)
 ...I SEGTYPE="MSH" D
"RTN","HLOSRVR1",54,0)
 ....D SPLITHDR(.SEG)
"RTN","HLOSRVR1",55,0)
 ....S NEWMSGID=$P(SEG(2),FS,5)
"RTN","HLOSRVR1",56,0)
 ....D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",57,0)
 ...E  D  ;not MSH
"RTN","HLOSRVR1",58,0)
 ....D:SEGTYPE="MSA"
"RTN","HLOSRVR1",59,0)
 .....N SUBIEN S SUBIEN=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOSRVR1",60,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN)=OLDMSGID
"RTN","HLOSRVR1",61,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"ACK BY")=NEWMSGID
"RTN","HLOSRVR1",62,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"STATUS")=$S(CODE="AA":"SU",1:"AE")
"RTN","HLOSRVR1",63,0)
 .....S:$D(IEN) HLMSTATE("BATCH","ACK TO",SUBIEN,"IEN")=IEN
"RTN","HLOSRVR1",64,0)
 ....D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",65,0)
 .I HLMSTATE("UNSTORED LINES"),HLCSTATE("MESSAGE ENDED"),$$SAVEMSG^HLOF778(.HLMSTATE)
"RTN","HLOSRVR1",66,0)
 ;
"RTN","HLOSRVR1",67,0)
 I STORE,'HLCSTATE("MESSAGE ENDED") D
"RTN","HLOSRVR1",68,0)
 .;reading failed before the end, there is no need to keep anything
"RTN","HLOSRVR1",69,0)
 .D:HLMSTATE("IEN") DEL778(HLMSTATE("IEN")) D:HLMSTATE("BODY") DEL777(HLMSTATE("BODY"))
"RTN","HLOSRVR1",70,0)
 .S HLMSTATE("IEN")="",HLMSTATE("BODY")=""
"RTN","HLOSRVR1",71,0)
 E  D:STORE
"RTN","HLOSRVR1",72,0)
 .D CHECKMSG(.HLMSTATE)
"RTN","HLOSRVR1",73,0)
 .D ADDAC(.HLMSTATE) ;so that future duplicates can be detected
"RTN","HLOSRVR1",74,0)
 ;
"RTN","HLOSRVR1",75,0)
 I 'HLCSTATE("MESSAGE ENDED") D
"RTN","HLOSRVR1",76,0)
 .S HLCSTATE("ATTEMPT")=HLCSTATE("ATTEMPT")+1
"RTN","HLOSRVR1",77,0)
 .;read keeps failing, give up
"RTN","HLOSRVR1",78,0)
 .I HLCSTATE("ATTEMPT")>4 D CLOSE^HLOT(.HLCSTATE) QUIT
"RTN","HLOSRVR1",79,0)
 E  S HLCSTATE("ATTEMPT")=1
"RTN","HLOSRVR1",80,0)
 Q HLCSTATE("MESSAGE ENDED")
"RTN","HLOSRVR1",81,0)
 ;
"RTN","HLOSRVR1",82,0)
ADDAC(HLMSTATE) ;adds the AC xref for the message that was just received
"RTN","HLOSRVR1",83,0)
 ;The AC xref allows duplicates to be detected.
"RTN","HLOSRVR1",84,0)
 ;
"RTN","HLOSRVR1",85,0)
 N FROM
"RTN","HLOSRVR1",86,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",87,0)
 S ^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID")),HLMSTATE("IEN"))=""
"RTN","HLOSRVR1",88,0)
 Q
"RTN","HLOSRVR1",89,0)
 ;
"RTN","HLOSRVR1",90,0)
DUP(HDR,MSA) ;
"RTN","HLOSRVR1",91,0)
 ;Function returns 1 if the message is a duplicate, 0 otherwise
"RTN","HLOSRVR1",92,0)
 ;Input:
"RTN","HLOSRVR1",93,0)
 ; HDR (pass by reference) the parsed header segment
"RTN","HLOSRVR1",94,0)
 ;Output:
"RTN","HLOSRVR1",95,0)
 ;  Function returns 1 if the message is a duplicate, 0 otherwise
"RTN","HLOSRVR1",96,0)
 ;  MSA (pass by reference) IF the message is a duplicate, returns the prior MSA segment
"RTN","HLOSRVR1",97,0)
 N MSGID,IEN,FROM,DUP
"RTN","HLOSRVR1",98,0)
 S (IEN,DUP)=0
"RTN","HLOSRVR1",99,0)
 S MSGID=$S(HDR("SEGMENT TYPE")="BHS":HDR("BATCH CONTROL ID"),HDR("SEGMENT TYPE")="MSH":HDR("MESSAGE CONTROL ID"),1:"")
"RTN","HLOSRVR1",100,0)
 Q:MSGID="" 0  ;no way to determine!  Bad header will be rejected
"RTN","HLOSRVR1",101,0)
 S FROM=$S(HDR("SENDING FACILITY",2)]"":HDR("SENDING FACILITY",2),1:HDR("SENDING FACILITY",1))
"RTN","HLOSRVR1",102,0)
 F  S IEN=$O(^HLB("AC",FROM_HDR("SENDING APPLICATION")_MSGID,IEN)) Q:'IEN  D  Q:DUP
"RTN","HLOSRVR1",103,0)
 .I HDR("ACCEPT ACK TYPE")="NE" S DUP=1 Q
"RTN","HLOSRVR1",104,0)
 .N NODE,I
"RTN","HLOSRVR1",105,0)
 .S NODE=$P($G(^HLB(IEN,4)),"^",3,10)
"RTN","HLOSRVR1",106,0)
 .S MSA(1)=$P(NODE,"|",2)
"RTN","HLOSRVR1",107,0)
 .Q:$E(MSA(1))'="C"
"RTN","HLOSRVR1",108,0)
 .S MSA(2)=$P(NODE,"|",3)
"RTN","HLOSRVR1",109,0)
 .S MSA(3)=$P(NODE,"|",4,10)
"RTN","HLOSRVR1",110,0)
 .S DUP=1
"RTN","HLOSRVR1",111,0)
 Q DUP
"RTN","HLOSRVR1",112,0)
 ;
"RTN","HLOSRVR1",113,0)
CHECKMSG(HLMSTATE) ;
"RTN","HLOSRVR1",114,0)
 ;Checks the header & MSA segment, sets HLMSTATE("STATUS","ACTION") if the message needs to be passed, determines if completion status should be set
"RTN","HLOSRVR1",115,0)
 ;Input:
"RTN","HLOSRVR1",116,0)
 ;  HLMSTATE("HDR") - the parsed header segment
"RTN","HLOSRVR1",117,0)
 ;Output:
"RTN","HLOSRVR1",118,0)
 ;  HLMSTATE("STATUS")="SE" if an error is detected
"RTN","HLOSRVR1",119,0)
 ;  HLMSTATE("STATUS","QUEUE") queue to put the message on
"RTN","HLOSRVR1",120,0)
 ;  HLMSTATE("STATUS","ACTION")  <tag^rtn> that is the processing routine for the receiving application
"RTN","HLOSRVR1",121,0)
 ;  HLMSTATE("MSA") - MSA(1)=accept code to be returned, MSA(3)= error txt
"RTN","HLOSRVR1",122,0)
 ;
"RTN","HLOSRVR1",123,0)
 N WANTACK,PASS,ACTION,QUEUE
"RTN","HLOSRVR1",124,0)
 M HDR=HLMSTATE("HDR")
"RTN","HLOSRVR1",125,0)
 S WANTACK=$S(HDR("ACCEPT ACK TYPE")="AL":1,1:0)
"RTN","HLOSRVR1",126,0)
 S HLMSTATE("MSA",1)="",HLMSTATE("STATUS")="",HLMSTATE("STATUS","QUEUE")="",HLMSTATE("STATUS","ACTION")=""
"RTN","HLOSRVR1",127,0)
 ;
"RTN","HLOSRVR1",128,0)
 I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE),$G(HLMSTATE("ACK TO"))="" S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="SE" Q
"RTN","HLOSRVR1",129,0)
 S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",130,0)
 ;
"RTN","HLOSRVR1",131,0)
 I (HDR("ACCEPT ACK TYPE")=""),(HDR("APP ACK TYPE")="") S HLMSTATE("MSA",1)="AE",HLMSTATE("MSA",3)="THIS INTERFACE DOES NOT IMPLEMENT ORIGINAL MODE APPLICATION ACKOWLEDGMENTS",HLMSTATE("STATUS")="SE" Q
"RTN","HLOSRVR1",132,0)
 ;
"RTN","HLOSRVR1",133,0)
 ;If this is an application ack, does the original message exist?
"RTN","HLOSRVR1",134,0)
 I $G(HLMSTATE("ACK TO"))]"" D  Q:HLMSTATE("STATUS")="SE"
"RTN","HLOSRVR1",135,0)
 .N NODE
"RTN","HLOSRVR1",136,0)
 .S:+$G(HLMSTATE("ACK TO","IEN")) NODE=$G(^HLB(+HLMSTATE("ACK TO","IEN"),0))
"RTN","HLOSRVR1",137,0)
 .I $G(NODE)="" S HLMSTATE("STATUS")="SE" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE TO APPLICATION ACKNOWLEDGMENT NOT FOUND" Q
"RTN","HLOSRVR1",138,0)
 .I ($P(NODE,"^",11)]"") S HLMSTATE("STATUS","ACTION")=$P(NODE,"^",10,11),HLMSTATE("STATUS","QUEUE")=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")
"RTN","HLOSRVR1",139,0)
 ;
"RTN","HLOSRVR1",140,0)
 I HDR("PROCESSING ID")'=HLCSTATE("SYSTEM","PROCESSING ID") S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("STATUS")="SE",HLMSTATE("MSA",3)="SYSTEM PROCESSING ID="_HLCSTATE("SYSTEM","PROCESSING ID") Q
"RTN","HLOSRVR1",141,0)
 ;
"RTN","HLOSRVR1",142,0)
 ;
"RTN","HLOSRVR1",143,0)
 ;wrong receiving facility?  This is hard to check if the sender is not VistA, because the HL7 standard permits different coding systems to be used. This check is only for DNS or station number.
"RTN","HLOSRVR1",144,0)
 S PASS=0
"RTN","HLOSRVR1",145,0)
 D
"RTN","HLOSRVR1",146,0)
 .;if its an ack to an existing message, don't check the receiving facility
"RTN","HLOSRVR1",147,0)
 .I $G(HLMSTATE("ACK TO"))]"" S PASS=1 Q
"RTN","HLOSRVR1",148,0)
 .I HDR("RECEIVING FACILITY",1)=HLCSTATE("SYSTEM","STATION") S PASS=1 Q
"RTN","HLOSRVR1",149,0)
 .I HDR("RECEIVING FACILITY",3)'="DNS" S PASS=1 Q
"RTN","HLOSRVR1",150,0)
 .I HDR("RECEIVING FACILITY",2)="" S PASS=1 Q
"RTN","HLOSRVR1",151,0)
 .I $P(HDR("RECEIVING FACILITY",2),":")[HLCSTATE("SYSTEM","DOMAIN") S PASS=1 Q
"RTN","HLOSRVR1",152,0)
 .I HLCSTATE("SYSTEM","DOMAIN")[$P(HDR("RECEIVING FACILITY",2),":") S PASS=1 Q
"RTN","HLOSRVR1",153,0)
 I 'PASS S HLMSTATE("STATUS")="SE",HLMSTATE("MSA",3)="RECEIVING FACILITY IS "_HLCSTATE("SYSTEM","DOMAIN") S:WANTACK HLMSTATE("MSA",1)="CE"
"RTN","HLOSRVR1",154,0)
 I PASS,WANTACK S HLMSTATE("MSA",1)="CA"
"RTN","HLOSRVR1",155,0)
 Q
"RTN","HLOSRVR1",156,0)
 ;
"RTN","HLOSRVR1",157,0)
DEL777(IEN777) ;delete a record from file 777 where the read did not complete
"RTN","HLOSRVR1",158,0)
 ;
"RTN","HLOSRVR1",159,0)
 K ^HLA(IEN777,0)
"RTN","HLOSRVR1",160,0)
 Q
"RTN","HLOSRVR1",161,0)
DEL778(IEN778) ;delete a record from file 778 where the read did not complete
"RTN","HLOSRVR1",162,0)
 ;
"RTN","HLOSRVR1",163,0)
 K ^HLB(IEN778,0)
"RTN","HLOSRVR1",164,0)
 Q
"RTN","HLOSRVR1",165,0)
 ;
"RTN","HLOSRVR1",166,0)
SPLITHDR(HDR) ;
"RTN","HLOSRVR1",167,0)
 ;splits hdr segment into two lines, first being just components 1-6
"RTN","HLOSRVR1",168,0)
 ;
"RTN","HLOSRVR1",169,0)
 N TEMP,FS
"RTN","HLOSRVR1",170,0)
 D SQUISH(.HDR)
"RTN","HLOSRVR1",171,0)
 S FS=$E(HDR(1),4)
"RTN","HLOSRVR1",172,0)
 S TEMP(1)=$P(HDR(1),FS,1,6)
"RTN","HLOSRVR1",173,0)
 S TEMP(2)=""
"RTN","HLOSRVR1",174,0)
 I $L(TEMP(1))<$L(HDR(1)) S TEMP(2)=FS_$P(HDR(1),FS,7,20)
"RTN","HLOSRVR1",175,0)
 S HDR(2)=TEMP(2)_$G(HDR(2))
"RTN","HLOSRVR1",176,0)
 S HDR(1)=TEMP(1)
"RTN","HLOSRVR1",177,0)
 Q
"RTN","HLOSRVR1",178,0)
 ;
"RTN","HLOSRVR1",179,0)
SQUISH(SEG) ;
"RTN","HLOSRVR1",180,0)
 ;squish the header segment =SEG(i) into at most 2 lines
"RTN","HLOSRVR1",181,0)
 ;
"RTN","HLOSRVR1",182,0)
 Q:'$O(SEG(1))
"RTN","HLOSRVR1",183,0)
 I '$O(SEG(2)) D  Q
"RTN","HLOSRVR1",184,0)
 .N LEN
"RTN","HLOSRVR1",185,0)
 .S LEN=$L(SEG(1))
"RTN","HLOSRVR1",186,0)
 .Q:LEN>255
"RTN","HLOSRVR1",187,0)
 .S SEG(1)=SEG(1)_$E(SEG(2),1,256-LEN)
"RTN","HLOSRVR1",188,0)
 .S SEG(2)=$E(SEG(2),257-LEN,99999)
"RTN","HLOSRVR1",189,0)
 ;
"RTN","HLOSRVR1",190,0)
 N A,DONE,I
"RTN","HLOSRVR1",191,0)
 S (I,DONE)=0
"RTN","HLOSRVR1",192,0)
 S A(1)=SEG(1) K SEG(1)
"RTN","HLOSRVR1",193,0)
 F  S I=$O(SEG(I)) Q:'I  D  Q:DONE
"RTN","HLOSRVR1",194,0)
 .N LEN
"RTN","HLOSRVR1",195,0)
 .S LEN=$L(A(1))
"RTN","HLOSRVR1",196,0)
 .I (LEN+$L(SEG(I)))>256 D
"RTN","HLOSRVR1",197,0)
 ..S A(1)=A(1)_$E(SEG(I),1,256-LEN)
"RTN","HLOSRVR1",198,0)
 ..S A(2)=$E(SEG(I),257-LEN,99999)
"RTN","HLOSRVR1",199,0)
 ..S DONE=1
"RTN","HLOSRVR1",200,0)
 .E  D
"RTN","HLOSRVR1",201,0)
 ..S A(1)=A(1)_SEG(I)
"RTN","HLOSRVR1",202,0)
 .K SEG(I)
"RTN","HLOSRVR1",203,0)
 ;
"RTN","HLOSRVR1",204,0)
 ;if there are any lines left in SEG(), put them in A(2)
"RTN","HLOSRVR1",205,0)
 F  S I=$O(SEG(I)) Q:'I  D  Q:DONE
"RTN","HLOSRVR1",206,0)
 .N LEN
"RTN","HLOSRVR1",207,0)
 .S LEN=$L($G(A(2)))
"RTN","HLOSRVR1",208,0)
 .I (LEN+$L(SEG(I)))>256 D
"RTN","HLOSRVR1",209,0)
 ..S A(2)=A(2)_$E(SEG(I),1,256-LEN)
"RTN","HLOSRVR1",210,0)
 ..S DONE=1
"RTN","HLOSRVR1",211,0)
 .E  D
"RTN","HLOSRVR1",212,0)
 ..S A(2)=$G(A(2))_SEG(I)
"RTN","HLOSRVR1",213,0)
 .K SEG(I)
"RTN","HLOSRVR1",214,0)
 K SEG
"RTN","HLOSRVR1",215,0)
 M SEG=A
"RTN","HLOSRVR1",216,0)
 Q
"RTN","HLOSRVR1",217,0)
 ;
"RTN","HLOSRVR1",218,0)
ERROR ;error trap
"RTN","HLOSRVR1",219,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOSRVR1",220,0)
 D END^HLOSRVR
"RTN","HLOSRVR1",221,0)
 ;
"RTN","HLOSRVR1",222,0)
 ;while debugging quit on all errors
"RTN","HLOSRVR1",223,0)
 I $G(^HLTMP("LOG ALL ERRORS")) D ^%ZTER QUIT
"RTN","HLOSRVR1",224,0)
 ;
"RTN","HLOSRVR1",225,0)
 ;don't log these common errors
"RTN","HLOSRVR1",226,0)
 I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D
"RTN","HLOSRVR1",227,0)
 .;
"RTN","HLOSRVR1",228,0)
 E  D
"RTN","HLOSRVR1",229,0)
 .D ^%ZTER
"RTN","HLOSRVR1",230,0)
 ;
"RTN","HLOSRVR1",231,0)
 ;concurrent server connections (multi-listener) should stop execution, only a single server may continue
"RTN","HLOSRVR1",232,0)
 Q:$P($G(HLCSTATE("LINK","SERVER")),"^",2)'="S"
"RTN","HLOSRVR1",233,0)
 ;
"RTN","HLOSRVR1",234,0)
 ;a lot of errors of the same time may indicate an endless loop, so keep a count
"RTN","HLOSRVR1",235,0)
 S ^TMP("HL7 ERRORS",$J,$ECODE)=$G(^TMP("HL7 ERRORS",$J,$ECODE))+1
"RTN","HLOSRVR1",236,0)
 ;
"RTN","HLOSRVR1",237,0)
 I ($G(^TMP("HL7 ERRORS",$J,$ECODE))>100) K ^TMP("HL7 ERRORS",$J) QUIT
"RTN","HLOSRVR1",238,0)
 ;
"RTN","HLOSRVR1",239,0)
 ;resume execution for the single listener
"RTN","HLOSRVR1",240,0)
 D UNWIND^%ZTER
"RTN","HLOSRVR1",241,0)
 Q
"RTN","HLOT")
0^38^B2539193
"RTN","HLOT",1,0)
HLOT ;IRMFO-ALB/CJM - Services provided by the transport layer;03/24/2004  14:43
"RTN","HLOT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOT",3,0)
 ;
"RTN","HLOT",4,0)
 ;
"RTN","HLOT",5,0)
READHDR(HLCSTATE,HDR) ;
"RTN","HLOT",6,0)
 N SUCCESS,SEG
"RTN","HLOT",7,0)
 N MCODE
"RTN","HLOT",8,0)
 S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOT",9,0)
 S MCODE="S SUCCESS=$$"_HLCSTATE("READ HEADER")_"(.HLCSTATE,.HDR)"
"RTN","HLOT",10,0)
 X MCODE
"RTN","HLOT",11,0)
 Q SUCCESS
"RTN","HLOT",12,0)
 ;
"RTN","HLOT",13,0)
READSEG(HLCSTATE,SEG) ;
"RTN","HLOT",14,0)
 N RETURN
"RTN","HLOT",15,0)
 N MCODE
"RTN","HLOT",16,0)
 S MCODE="S RETURN=$$"_HLCSTATE("READ SEGMENT")_"(.HLCSTATE,.SEG)"
"RTN","HLOT",17,0)
 X MCODE
"RTN","HLOT",18,0)
 Q RETURN
"RTN","HLOT",19,0)
 ;
"RTN","HLOT",20,0)
OPEN(HLCSTATE) ;
"RTN","HLOT",21,0)
 N MCODE
"RTN","HLOT",22,0)
 S MCODE="D "_HLCSTATE("OPEN")_"(.HLCSTATE)"
"RTN","HLOT",23,0)
 X MCODE
"RTN","HLOT",24,0)
 Q
"RTN","HLOT",25,0)
 ;
"RTN","HLOT",26,0)
CLOSE(HLCSTATE) ;
"RTN","HLOT",27,0)
 N MCODE
"RTN","HLOT",28,0)
 S MCODE="D "_HLCSTATE("CLOSE")_"(.HLCSTATE)"
"RTN","HLOT",29,0)
 X MCODE
"RTN","HLOT",30,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOT",31,0)
 Q
"RTN","HLOT",32,0)
 ;
"RTN","HLOT",33,0)
WRITESEG(HLCSTATE,SEG) ;
"RTN","HLOT",34,0)
 N RETURN
"RTN","HLOT",35,0)
 N MCODE
"RTN","HLOT",36,0)
 S MCODE="S RETURN=$$"_HLCSTATE("WRITE SEGMENT")_"(.HLCSTATE,.SEG)"
"RTN","HLOT",37,0)
 X MCODE
"RTN","HLOT",38,0)
 Q RETURN
"RTN","HLOT",39,0)
 ;
"RTN","HLOT",40,0)
WRITEHDR(HLCSTATE,HDR) ;
"RTN","HLOT",41,0)
 N SUCCESS
"RTN","HLOT",42,0)
 N MCODE
"RTN","HLOT",43,0)
 S MCODE="S SUCCESS=$$"_HLCSTATE("WRITE HEADER")_"(.HLCSTATE,.HDR)"
"RTN","HLOT",44,0)
 X MCODE
"RTN","HLOT",45,0)
 Q SUCCESS
"RTN","HLOT",46,0)
 ;
"RTN","HLOT",47,0)
ENDMSG(HLCSTATE) ;
"RTN","HLOT",48,0)
 N RETURN
"RTN","HLOT",49,0)
 N MCODE
"RTN","HLOT",50,0)
 S MCODE="S RETURN=$$"_HLCSTATE("END MESSAGE")_"(.HLCSTATE)"
"RTN","HLOT",51,0)
 X MCODE
"RTN","HLOT",52,0)
 Q RETURN
"RTN","HLOTCP")
0^39^B43009690
"RTN","HLOTCP",1,0)
HLOTCP ;ALB/CJM- TCP/IP I/O - 10/4/94 1pm
"RTN","HLOTCP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOTCP",3,0)
 ;
"RTN","HLOTCP",4,0)
OPEN(HLCSTATE,LOGICAL) ;
"RTN","HLOTCP",5,0)
 ;This may be called either in the context of a client or a server.
"RTN","HLOTCP",6,0)
 ;For the server, there are 3 situations:
"RTN","HLOTCP",7,0)
 ; 1) The server is not concurrent.  In this case the TCP device should be opened.
"RTN","HLOTCP",8,0)
 ; 2) The server is concurrent, but this process was spawned by the OS
"RTN","HLOTCP",9,0)
 ;    (via a VMS TCP Service)  In this case, the device should be opened
"RTN","HLOTCP",10,0)
 ;    via the LOGICAL that was passed in.
"RTN","HLOTCP",11,0)
 ;  3) The server is concurrent, but this process was spawned by the
"RTN","HLOTCP",12,0)
 ;     TaskMan multi-listener.  In this case TaskMan already opened the
"RTN","HLOTCP",13,0)
 ;     device.  This case can be determined by the absence of the LOGICAL
"RTN","HLOTCP",14,0)
 ;     input parameter.
"RTN","HLOTCP",15,0)
 ;
"RTN","HLOTCP",16,0)
 N IP,PORT,DNSFLAG
"RTN","HLOTCP",17,0)
 ;
"RTN","HLOTCP",18,0)
 S DNSFLAG=0 ;DNS has not been contacted for IP
"RTN","HLOTCP",19,0)
 ;
"RTN","HLOTCP",20,0)
 S:'$G(HLCSTATE("SERVER")) IP=HLCSTATE("LINK","IP")
"RTN","HLOTCP",21,0)
 S PORT=HLCSTATE("LINK","PORT")
"RTN","HLOTCP",22,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOTCP",23,0)
 S HLCSTATE("READ HEADER")="READHDR^HLOTCP"
"RTN","HLOTCP",24,0)
 S HLCSTATE("WRITE HEADER")="WRITEHDR^HLOTCP"
"RTN","HLOTCP",25,0)
 S HLCSTATE("READ SEGMENT")="READSEG^HLOTCP"
"RTN","HLOTCP",26,0)
 S HLCSTATE("WRITE SEGMENT")="WRITESEG^HLOTCP"
"RTN","HLOTCP",27,0)
 S HLCSTATE("END MESSAGE")="ENDMSG^HLOTCP"
"RTN","HLOTCP",28,0)
 S HLCSTATE("CLOSE")="CLOSE^HLOTCP"
"RTN","HLOTCP",29,0)
 ;
"RTN","HLOTCP",30,0)
 ;spawned by TaskMan multi-listener? If so, the device has already been opened
"RTN","HLOTCP",31,0)
 I $G(HLCSTATE("SERVER")),$G(HLCSTATE("LINK","SERVER"))="1^M",$G(LOGICAL)="" D  Q
"RTN","HLOTCP",32,0)
 .S HLCSTATE("DEVICE")=IO(0),HLCSTATE("FLUSH")="!",HLCSTATE("TCP BUFFER SIZE")=510
"RTN","HLOTCP",33,0)
 .S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",34,0)
 ;
"RTN","HLOTCP",35,0)
 ;if no IP, not a server, give DNS a shot
"RTN","HLOTCP",36,0)
 I '$G(HLCSTATE("SERVER")),IP="" S DNSFLAG=1,IP=$$DNS(HLCSTATE("LINK","DOMAIN")),HLCSTATE("LINK","IP")=IP Q:IP=""
"RTN","HLOTCP",37,0)
 ;
"RTN","HLOTCP",38,0)
RETRY I HLCSTATE("SYSTEM","OS")="DSM" D
"RTN","HLOTCP",39,0)
 .S HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",40,0)
 .I $G(LOGICAL)]"" S HLCSTATE("DEVICE")=LOGICAL
"RTN","HLOTCP",41,0)
 .E  S HLCSTATE("DEVICE")=PORT
"RTN","HLOTCP",42,0)
 .S HLCSTATE("FLUSH")="!"
"RTN","HLOTCP",43,0)
 .I $G(HLCSTATE("SERVER")) D
"RTN","HLOTCP",44,0)
 ..O:$G(LOGICAL)]"" HLCSTATE("DEVICE"):(TCPDEV,BLOCKSIZE=512):30
"RTN","HLOTCP",45,0)
 ..O:$G(LOGICAL)="" HLCSTATE("DEVICE"):(TCPCHAN,BLOCKSIZE=512):30
"RTN","HLOTCP",46,0)
 ..I $T D
"RTN","HLOTCP",47,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",48,0)
 ...U HLCSTATE("DEVICE"):NOECHO
"RTN","HLOTCP",49,0)
 .E  D  ;client
"RTN","HLOTCP",50,0)
 ..O HLCSTATE("DEVICE"):(TCPCHAN,ADDRESS=IP,BLOCKSIZE=512):30
"RTN","HLOTCP",51,0)
 ..I $T D
"RTN","HLOTCP",52,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",53,0)
 ...U HLCSTATE("DEVICE"):NOECHO
"RTN","HLOTCP",54,0)
 E  I HLCSTATE("SYSTEM","OS")="CACHE" D
"RTN","HLOTCP",55,0)
 .S HLCSTATE("FLUSH")="!"
"RTN","HLOTCP",56,0)
 .I $G(LOGICAL)]"" S HLCSTATE("DEVICE")=LOGICAL
"RTN","HLOTCP",57,0)
 .E  S HLCSTATE("DEVICE")="|TCP|"_PORT
"RTN","HLOTCP",58,0)
 .S HLCSTATE("TCP BUFFER SIZE")=510
"RTN","HLOTCP",59,0)
 .I $G(HLCSTATE("SERVER")) D
"RTN","HLOTCP",60,0)
 ..I HLCSTATE("SERVER")="1^S" D  Q
"RTN","HLOTCP",61,0)
 ...;single server (no concurrent connections)
"RTN","HLOTCP",62,0)
 ...O HLCSTATE("DEVICE"):(:PORT:"+A-S":::):30
"RTN","HLOTCP",63,0)
 ...I $T D
"RTN","HLOTCP",64,0)
 ....N A
"RTN","HLOTCP",65,0)
 ....S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",66,0)
 ....U HLCSTATE("DEVICE")
"RTN","HLOTCP",67,0)
 ....F  R *A:60 Q:$T  I $$CHKSTOP^HLOPROC S HLCSTATE("CONNECTED")=0 Q
"RTN","HLOTCP",68,0)
 ..;
"RTN","HLOTCP",69,0)
 ..;multi-server spawned by OS - VMS TCP Services
"RTN","HLOTCP",70,0)
 ..O HLCSTATE("DEVICE")::5 I '$T S HLCSTATE("CONNECTED")=0 Q
"RTN","HLOTCP",71,0)
 ..S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",72,0)
 ..U HLCSTATE("DEVICE"):(::"-S")
"RTN","HLOTCP",73,0)
 ..;
"RTN","HLOTCP",74,0)
 .E  D  ;client
"RTN","HLOTCP",75,0)
 ..S HLCSTATE("TCP BUFFER SIZE")=510
"RTN","HLOTCP",76,0)
 ..O HLCSTATE("DEVICE"):(IP:PORT:"-S":::):30
"RTN","HLOTCP",77,0)
 ..I $T D
"RTN","HLOTCP",78,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",79,0)
 E  D  ;any other system but Cache or DSM
"RTN","HLOTCP",80,0)
 .S HLCSTATE("TCP BUFFER SIZE")=256
"RTN","HLOTCP",81,0)
 .D CALL^%ZISTCP(IP,PORT)
"RTN","HLOTCP",82,0)
 .S HLCSTATE("CONNECTED")='POP
"RTN","HLOTCP",83,0)
 .I HLCSTATE("CONNECTED") S HLCSTATE("DEVICE")=IO
"RTN","HLOTCP",84,0)
 ;
"RTN","HLOTCP",85,0)
 ;if not connected, not the server, give DNS a shot if not tried already
"RTN","HLOTCP",86,0)
 I '$G(HLCSTATE("SERVER")),'HLCSTATE("CONNECTED"),'DNSFLAG S DNSFLAG=1,IP=$$DNS(HLCSTATE("LINK","DOMAIN")) I IP]"",IP'=HLCSTATE("LINK","IP") S HLCSTATE("LINK","IP")=IP G RETRY
"RTN","HLOTCP",87,0)
 I HLCSTATE("CONNECTED"),DNSFLAG S $P(^HLCS(870,HLCSTATE("LINK","IEN"),400),"^")=IP
"RTN","HLOTCP",88,0)
 Q
"RTN","HLOTCP",89,0)
 ;
"RTN","HLOTCP",90,0)
DNS(DOMAIN) ;
"RTN","HLOTCP",91,0)
 Q $P($$ADDRESS^XLFNSLK(DOMAIN),",")
"RTN","HLOTCP",92,0)
 ;
"RTN","HLOTCP",93,0)
WRITEHDR(HLCSTATE,HDR) ;
"RTN","HLOTCP",94,0)
 ;
"RTN","HLOTCP",95,0)
 ;insure that package buffer is empty
"RTN","HLOTCP",96,0)
 K HLCSTATE("BUFFER")
"RTN","HLOTCP",97,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0
"RTN","HLOTCP",98,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0
"RTN","HLOTCP",99,0)
 S HLCSTATE("FIRST WRITE")=1 ;so that FLUSH knows $X should be 0
"RTN","HLOTCP",100,0)
 ;
"RTN","HLOTCP",101,0)
 ;Start the message with <SB>, then write the header
"RTN","HLOTCP",102,0)
 N SEG
"RTN","HLOTCP",103,0)
 S SEG(1)=$C(11)_HDR(1)
"RTN","HLOTCP",104,0)
 S SEG(2)=HDR(2)
"RTN","HLOTCP",105,0)
 Q $$WRITESEG(.HLCSTATE,.SEG)
"RTN","HLOTCP",106,0)
 ;
"RTN","HLOTCP",107,0)
WRITESEG(HLCSTATE,SEG) ;
"RTN","HLOTCP",108,0)
 N I,LAST
"RTN","HLOTCP",109,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=HLCSTATE("BUFFER","SEGMENT COUNT")+1
"RTN","HLOTCP",110,0)
 S I=0,LAST=$O(SEG(99999),-1)
"RTN","HLOTCP",111,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOTCP",112,0)
 .I HLCSTATE("BUFFER","BYTE COUNT")>HLCSTATE("SYSTEM","BUFFER") D FLUSH
"RTN","HLOTCP",113,0)
 .I I=LAST S SEG(I)=SEG(I)_$C(13)
"RTN","HLOTCP",114,0)
 .S HLCSTATE("BUFFER",HLCSTATE("BUFFER","SEGMENT COUNT"),I)=SEG(I),HLCSTATE("BUFFER","BYTE COUNT")=HLCSTATE("BUFFER","BYTE COUNT")+$L(SEG(I))+20
"RTN","HLOTCP",115,0)
 Q 1
"RTN","HLOTCP",116,0)
 ;
"RTN","HLOTCP",117,0)
FLUSH ;flushes the HL7 package buffer, and the system TCP buffer when full
"RTN","HLOTCP",118,0)
 N SEGMENT,MAX
"RTN","HLOTCP",119,0)
 S SEGMENT=0
"RTN","HLOTCP",120,0)
 S MAX=HLCSTATE("TCP BUFFER SIZE")
"RTN","HLOTCP",121,0)
 U HLCSTATE("DEVICE")
"RTN","HLOTCP",122,0)
 F  S SEGMENT=$O(HLCSTATE("BUFFER",SEGMENT)) Q:'SEGMENT  D
"RTN","HLOTCP",123,0)
 .N I S I=0
"RTN","HLOTCP",124,0)
 .F  S I=$O(HLCSTATE("BUFFER",SEGMENT,I)) Q:'I  D
"RTN","HLOTCP",125,0)
 ..N LINE,J
"RTN","HLOTCP",126,0)
 ..S J=$S(HLCSTATE("FIRST WRITE"):0,1:$X)
"RTN","HLOTCP",127,0)
 ..S HLCSTATE("FIRST WRITE")=0
"RTN","HLOTCP",128,0)
 ..S LINE=HLCSTATE("BUFFER",SEGMENT,I)
"RTN","HLOTCP",129,0)
 ..F  Q:'(J+$L(LINE)>MAX)  D
"RTN","HLOTCP",130,0)
 ...W $E(LINE,1,MAX-J),@HLCSTATE("FLUSH")
"RTN","HLOTCP",131,0)
 ...S LINE=$E(LINE,(MAX-J)+1,99999)
"RTN","HLOTCP",132,0)
 ...S J=0
"RTN","HLOTCP",133,0)
 ..W:(LINE]"") LINE
"RTN","HLOTCP",134,0)
 K HLCSTATE("BUFFER")
"RTN","HLOTCP",135,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=1
"RTN","HLOTCP",136,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0
"RTN","HLOTCP",137,0)
 S HLCSTATE("FIRST WRITE")=0
"RTN","HLOTCP",138,0)
 Q
"RTN","HLOTCP",139,0)
 ;
"RTN","HLOTCP",140,0)
READSEG(HLCSTATE,SEG) ;
"RTN","HLOTCP",141,0)
 ;
"RTN","HLOTCP",142,0)
 ;Output:
"RTN","HLOTCP",143,0)
 ;  SEG - returns the segment (pass by reference)
"RTN","HLOTCP",144,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOTCP",145,0)
 ;
"RTN","HLOTCP",146,0)
 N SUCCESS,COUNT,BUF,TIMEOUT
"RTN","HLOTCP",147,0)
 S TIMEOUT=8*HLCSTATE("ATTEMPT") ;start off at 8 seconds, and double each attempt
"RTN","HLOTCP",148,0)
 S (COUNT,SUCCESS)=0
"RTN","HLOTCP",149,0)
 K SEG
"RTN","HLOTCP",150,0)
 ;
"RTN","HLOTCP",151,0)
 ;anything left from last read?
"RTN","HLOTCP",152,0)
 S BUF=HLCSTATE("READ")
"RTN","HLOTCP",153,0)
 S HLCSTATE("READ")=""
"RTN","HLOTCP",154,0)
 I BUF]"" D  ;something was left!
"RTN","HLOTCP",155,0)
 .S COUNT=1
"RTN","HLOTCP",156,0)
 .I BUF[$C(13) D  Q
"RTN","HLOTCP",157,0)
 ..S SEG(1)=$P(BUF,$C(13)),BUF=$P(BUF,$C(13),2,9999)
"RTN","HLOTCP",158,0)
 ..S SUCCESS=1
"RTN","HLOTCP",159,0)
 .S SEG(1)=BUF,BUF=""
"RTN","HLOTCP",160,0)
 I 'SUCCESS U HLCSTATE("DEVICE") F  R BUF:TIMEOUT Q:'$T  D  Q:SUCCESS
"RTN","HLOTCP",161,0)
 .I BUF[$C(13) S SUCCESS=1,COUNT=COUNT+1,SEG(COUNT)=$P(BUF,$C(13)),BUF=$P(BUF,$C(13),2,9999) Q
"RTN","HLOTCP",162,0)
 .S COUNT=COUNT+1,SEG(COUNT)=BUF
"RTN","HLOTCP",163,0)
 ;
"RTN","HLOTCP",164,0)
 I SUCCESS D
"RTN","HLOTCP",165,0)
 .S HLCSTATE("READ")=BUF ;save the leftover
"RTN","HLOTCP",166,0)
 .I COUNT>1,SEG(COUNT)="" K SEG(COUNT) S COUNT=COUNT-1
"RTN","HLOTCP",167,0)
 ;Cache can return the connection status
"RTN","HLOTCP",168,0)
 E  I (HLCSTATE("SYSTEM","OS")="CACHE") S HLCSTATE("CONNECTED")=($ZA\8192#2) I 'HLCSTATE("CONNECTED") D CLOSE(.HLCSTATE)
"RTN","HLOTCP",169,0)
 ;
"RTN","HLOTCP",170,0)
 ;if the <EB> character was encountered, then there are no more segments in the message, set the end of message flag
"RTN","HLOTCP",171,0)
 I SUCCESS,SEG(COUNT)[$C(28) D
"RTN","HLOTCP",172,0)
 .K SEG
"RTN","HLOTCP",173,0)
 .S SUCCESS=0
"RTN","HLOTCP",174,0)
 .S HLCSTATE("MESSAGE ENDED")=1
"RTN","HLOTCP",175,0)
 Q SUCCESS
"RTN","HLOTCP",176,0)
 ;
"RTN","HLOTCP",177,0)
READHDR(HLCSTATE,HDR) ;
"RTN","HLOTCP",178,0)
 ;reads the next header segment in the message stream, discarding everything that comes before it
"RTN","HLOTCP",179,0)
 ;
"RTN","HLOTCP",180,0)
 N SEG,SUCCESS,J,I
"RTN","HLOTCP",181,0)
 S SUCCESS=0
"RTN","HLOTCP",182,0)
 K HDR
"RTN","HLOTCP",183,0)
 F  Q:'$$READSEG(.HLCSTATE,.SEG)  D  Q:SUCCESS
"RTN","HLOTCP",184,0)
 .S I=0
"RTN","HLOTCP",185,0)
 .;look for the <SB>
"RTN","HLOTCP",186,0)
 .;perhaps the <SB> isn't in the first line
"RTN","HLOTCP",187,0)
 .F  S I=$O(SEG(I)) Q:'I  D  Q:SUCCESS
"RTN","HLOTCP",188,0)
 ..I (SEG(I)'[$C(11)) K SEG(I) Q
"RTN","HLOTCP",189,0)
 ..S SEG(I)=$P(SEG(I),$C(11),2)
"RTN","HLOTCP",190,0)
 ..S SUCCESS=1
"RTN","HLOTCP",191,0)
 ..K:SEG(I)="" SEG(I)
"RTN","HLOTCP",192,0)
 I SUCCESS S (I,J)=0 F  S J=$O(SEG(J)) Q:'J  S I=I+1,HDR(I)=SEG(J)
"RTN","HLOTCP",193,0)
 Q SUCCESS
"RTN","HLOTCP",194,0)
 ;
"RTN","HLOTCP",195,0)
CLOSE(HLCSTATE) ;
"RTN","HLOTCP",196,0)
 CLOSE HLCSTATE("DEVICE")
"RTN","HLOTCP",197,0)
 Q
"RTN","HLOTCP",198,0)
 ;
"RTN","HLOTCP",199,0)
ENDMSG(HLCSTATE)        ;
"RTN","HLOTCP",200,0)
 N SEG
"RTN","HLOTCP",201,0)
 S SEG(1)=$C(28)
"RTN","HLOTCP",202,0)
 I $$WRITESEG(.HLCSTATE,.SEG) D  Q 1
"RTN","HLOTCP",203,0)
 .D FLUSH
"RTN","HLOTCP",204,0)
 .U HLCSTATE("DEVICE")
"RTN","HLOTCP",205,0)
 .W:$X @HLCSTATE("FLUSH")
"RTN","HLOTCP",206,0)
 Q 0
"RTN","HLOTLNK")
0^40^B15931185
"RTN","HLOTLNK",1,0)
HLOTLNK ;IRMFO-ALB/CJM - APIs for the HL Logical Link file;03/24/2004  14:43
"RTN","HLOTLNK",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOTLNK",3,0)
 ;
"RTN","HLOTLNK",4,0)
DOMAIN(LINKIEN) ;
"RTN","HLOTLNK",5,0)
 ;Returns the domain associated with this link
"RTN","HLOTLNK",6,0)
 ;
"RTN","HLOTLNK",7,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",8,0)
 N NODE,DOMAIN
"RTN","HLOTLNK",9,0)
 S DOMAIN=""
"RTN","HLOTLNK",10,0)
 S NODE=$G(^HLCS(870,LINKIEN,0))
"RTN","HLOTLNK",11,0)
 I $P(NODE,"^",7) D
"RTN","HLOTLNK",12,0)
 .S DOMAIN=$P($G(^DIC(4.2,$P(NODE,"^",7),0)),"^")
"RTN","HLOTLNK",13,0)
 .S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",14,0)
 I '$L(DOMAIN) S DOMAIN=$P(NODE,"^",8)
"RTN","HLOTLNK",15,0)
 Q DOMAIN
"RTN","HLOTLNK",16,0)
PORT(LINKIEN) ;
"RTN","HLOTLNK",17,0)
 ;Returns the HLO port associated with this link
"RTN","HLOTLNK",18,0)
 ;
"RTN","HLOTLNK",19,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",20,0)
 N NODE,PORT
"RTN","HLOTLNK",21,0)
 S NODE=$G(^HLCS(870,LINKIEN,400))
"RTN","HLOTLNK",22,0)
 S PORT=$P(NODE,"^",8)
"RTN","HLOTLNK",23,0)
 S:'PORT PORT=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":5001,1:5026)
"RTN","HLOTLNK",24,0)
 Q PORT
"RTN","HLOTLNK",25,0)
 ;
"RTN","HLOTLNK",26,0)
PORT2(LINKNAME) ;given the name of the link, returns its HLO port
"RTN","HLOTLNK",27,0)
 Q $$PORT($O(^HLCS(870,"B",LINKNAME,0)))
"RTN","HLOTLNK",28,0)
 ;
"RTN","HLOTLNK",29,0)
STATNUM(LINKIEN) ;
"RTN","HLOTLNK",30,0)
 ;Given the ien of the link, this function returns the station #.
"RTN","HLOTLNK",31,0)
 ;
"RTN","HLOTLNK",32,0)
 Q:'$G(LINKIEN) ""
"RTN","HLOTLNK",33,0)
 N INST
"RTN","HLOTLNK",34,0)
 S INST=$P($G(^HLCS(870,LINKIEN,0)),"^",2)
"RTN","HLOTLNK",35,0)
 Q:'INST ""
"RTN","HLOTLNK",36,0)
 Q $P($G(^DIC(4,INST,99)),"^")
"RTN","HLOTLNK",37,0)
 ;
"RTN","HLOTLNK",38,0)
FINDLINK(STATN) ;
"RTN","HLOTLNK",39,0)
 ;Returns the link ien based on the station # =STATN
"RTN","HLOTLNK",40,0)
 ;The link found must have a name starting with "VA", as these are
"RTN","HLOTLNK",41,0)
 ;reserved for officially released links associated with VHA institutions
"RTN","HLOTLNK",42,0)
 ;** EXCEPTION** MPIVA is an official link associated with 200M
"RTN","HLOTLNK",43,0)
 ;
"RTN","HLOTLNK",44,0)
 Q:'$L($G(STATN)) 0
"RTN","HLOTLNK",45,0)
 ;
"RTN","HLOTLNK",46,0)
 N NAME,IEN
"RTN","HLOTLNK",47,0)
 S (NAME,IEN)=""
"RTN","HLOTLNK",48,0)
 F  S NAME=$O(^HLCS(870,"AC",STATN,NAME)) Q:NAME=""  I (NAME'="VA-VIE"),($E(NAME,1,2)="VA")!(NAME="MPIVA") S IEN=$O(^HLCS(870,"AC",STATN,NAME,0)) Q
"RTN","HLOTLNK",49,0)
 Q IEN
"RTN","HLOTLNK",50,0)
 ;
"RTN","HLOTLNK",51,0)
GETLINK(LINKNAME,LINK) ;
"RTN","HLOTLNK",52,0)
 N IEN
"RTN","HLOTLNK",53,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",54,0)
 Q:'IEN 0
"RTN","HLOTLNK",55,0)
 Q $$GET(IEN,.LINK)
"RTN","HLOTLNK",56,0)
GET(IEN,LINK) ;
"RTN","HLOTLNK",57,0)
 N NODE,PTR
"RTN","HLOTLNK",58,0)
 K LINK
"RTN","HLOTLNK",59,0)
 S NODE=$G(^HLCS(870,IEN,0))
"RTN","HLOTLNK",60,0)
 Q:NODE="" 0
"RTN","HLOTLNK",61,0)
 S LINK("NAME")=$P(NODE,"^")
"RTN","HLOTLNK",62,0)
 S LINK("IEN")=IEN
"RTN","HLOTLNK",63,0)
 I $P(NODE,"^",7) D
"RTN","HLOTLNK",64,0)
 .S LINK("DOMAIN")=$P(^DIC(4.2,$P(NODE,"^",7),0),"^")
"RTN","HLOTLNK",65,0)
 .S LINK("DOMAIN")=$S($L(LINK("DOMAIN")):"HL7."_LINK("DOMAIN"),1:"")
"RTN","HLOTLNK",66,0)
 I $G(LINK("DOMAIN"))="" S LINK("DOMAIN")=$P(NODE,"^",8)
"RTN","HLOTLNK",67,0)
 S PTR=$P(NODE,"^",3)
"RTN","HLOTLNK",68,0)
 S LINK("LLP")=$S('PTR:"",1:$P($G(^HLCS(869.1,PTR,0)),"^"))
"RTN","HLOTLNK",69,0)
 S LINK("SERVER")=""
"RTN","HLOTLNK",70,0)
 I LINK("LLP")="TCP" D
"RTN","HLOTLNK",71,0)
 .S LINK("SERVER")=1
"RTN","HLOTLNK",72,0)
 .S NODE=$G(^HLCS(870,IEN,400))
"RTN","HLOTLNK",73,0)
 .S LINK("IP")=$P(NODE,"^")
"RTN","HLOTLNK",74,0)
 .S LINK("PORT")=$P(NODE,"^",8)
"RTN","HLOTLNK",75,0)
 .S:'LINK("PORT") LINK("PORT")=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":5001,1:5026)
"RTN","HLOTLNK",76,0)
 .S:$P(NODE,"^",3)="C" LINK("SERVER")=0
"RTN","HLOTLNK",77,0)
 .I LINK("SERVER") S LINK("SERVER")=LINK("SERVER")_"^"_$P(NODE,"^",3)
"RTN","HLOTLNK",78,0)
 Q 1
"RTN","HLOTLNK",79,0)
 ;
"RTN","HLOTLNK",80,0)
SET1(LINK,MDOMAIN) ;
"RTN","HLOTLNK",81,0)
 N DOMAIN
"RTN","HLOTLNK",82,0)
 Q:'$L(MDOMAIN)
"RTN","HLOTLNK",83,0)
 S DOMAIN=$P($G(^DIC(4.2,MDOMAIN,0)),"^")
"RTN","HLOTLNK",84,0)
 S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",85,0)
 I DOMAIN'="" S ^HLCS(870,"AD","TCP",DOMAIN,LINK)=""
"RTN","HLOTLNK",86,0)
 Q
"RTN","HLOTLNK",87,0)
KILL1(LINK,MDOMAIN) ;
"RTN","HLOTLNK",88,0)
 N DOMAIN
"RTN","HLOTLNK",89,0)
 Q:'$L(MDOMAIN)
"RTN","HLOTLNK",90,0)
 S DOMAIN=$P($G(^DIC(4.2,MDOMAIN,0)),"^")
"RTN","HLOTLNK",91,0)
 S DOMAIN=$S($L(DOMAIN):"HL7."_DOMAIN,1:"")
"RTN","HLOTLNK",92,0)
 I DOMAIN'="" K ^HLCS(870,"AD","TCP",DOMAIN,LINK)
"RTN","HLOTLNK",93,0)
 Q
"RTN","HLOTLNK",94,0)
SET2(LINK,DOMAIN) ;
"RTN","HLOTLNK",95,0)
 I DOMAIN'="" S ^HLCS(870,"AD","TCP",DOMAIN,LINK)=""
"RTN","HLOTLNK",96,0)
 Q
"RTN","HLOTLNK",97,0)
KILL2(LINK,DOMAIN) ;
"RTN","HLOTLNK",98,0)
 I DOMAIN'="" K ^HLCS(870,"AD","TCP",DOMAIN,LINK)
"RTN","HLOTLNK",99,0)
 Q
"RTN","HLOTLNK",100,0)
SET3(LINK,DEVICE) ;
"RTN","HLOTLNK",101,0)
 Q:'DEVICE
"RTN","HLOTLNK",102,0)
 S ^HLCS(870,"AD","HLLP",DEVICE,LINK)=""
"RTN","HLOTLNK",103,0)
 Q
"RTN","HLOTLNK",104,0)
KILL3(LINK,DEVICE) ;
"RTN","HLOTLNK",105,0)
 Q:'DEVICE
"RTN","HLOTLNK",106,0)
 S ^HLCS(870,"AD","HLLP",DEVICE,LINK)=""
"RTN","HLOTLNK",107,0)
 Q
"RTN","HLOTLNK",108,0)
LLP(LINKNAME) ;
"RTN","HLOTLNK",109,0)
 ;finds the type of LLP for a named link
"RTN","HLOTLNK",110,0)
 N IEN,LLP
"RTN","HLOTLNK",111,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",112,0)
 Q:'IEN ""
"RTN","HLOTLNK",113,0)
 S LLP=$P($G(^HLCS(870,IEN,0)),"^",3)
"RTN","HLOTLNK",114,0)
 Q:'LLP ""
"RTN","HLOTLNK",115,0)
 Q $P($G(^HLCS(869.1,LLP,0)),"^")
"RTN","HLOTLNK",116,0)
 ;
"RTN","HLOTLNK",117,0)
DEVICE(LINKNAME) ;
"RTN","HLOTLNK",118,0)
 N IEN
"RTN","HLOTLNK",119,0)
 S IEN=$O(^HLCS(870,"B",LINKNAME,0))
"RTN","HLOTLNK",120,0)
 Q:'IEN ""
"RTN","HLOTLNK",121,0)
 Q $P($G(^HLCS(870,IEN,200)),"^")
"RTN","HLOTLNK",122,0)
 ;
"RTN","HLOTLNK",123,0)
RTRNLNK(COMP1,COMP2,COMP3) ;
"RTN","HLOTLNK",124,0)
 ;based on the sending facility from the original header, this function finds the return link, or "" if not successful
"RTN","HLOTLNK",125,0)
 ;Inputs:
"RTN","HLOTLNK",126,0)
 ;  COMP1,COMP2,COMP3 - 3 components of the sending facility from the original message
"RTN","HLOTLNK",127,0)
 ;
"RTN","HLOTLNK",128,0)
 N LINK,IEN
"RTN","HLOTLNK",129,0)
 S LINK=""
"RTN","HLOTLNK",130,0)
 I $G(COMP3)="DNS",$P($G(COMP2),":")]"" S LINK=$O(^HLCS(870,"AD","TCP",$P(COMP2,":"),""))
"RTN","HLOTLNK",131,0)
 I LINK="",$L($G(COMP1)) S IEN=$$FINDLINK(COMP1) S:IEN LINK=$P($G(^HLCS(870,IEN,0)),"^")
"RTN","HLOTLNK",132,0)
 Q LINK
"RTN","HLOTLNK",133,0)
 ;
"RTN","HLOTLNK",134,0)
 ;HLLP is not implemented in HLO
"RTN","HLOTLNK",135,0)
 ;I LLP="HLLP" N DEVICE S DEVICE=$$DEVICE(FROMLINK) I DEVICE Q $O(^HLCS(870,"AD","TCP",DEVICE,""))
"RTN","HLOTLNK",136,0)
 ;Q ""
"RTN","HLOTLNK",137,0)
 ;
"RTN","HLOTLNK",138,0)
CHKLINK(LINK) ;
"RTN","HLOTLNK",139,0)
 Q:'$L(LINK) 0
"RTN","HLOTLNK",140,0)
 Q:'$O(^HLCS(870,"B",LINK,0)) 0
"RTN","HLOTLNK",141,0)
 Q 1
"RTN","HLOUSR")
0^41^B88426707
"RTN","HLOUSR",1,0)
HLOUSR ;ALB/CJM -ListManager Screen for viewing system status;12 JUN 1997 10:00 am
"RTN","HLOUSR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOUSR",3,0)
 ;
"RTN","HLOUSR",4,0)
EN ;
"RTN","HLOUSR",5,0)
 ;
"RTN","HLOUSR",6,0)
 N HLSCREEN,TESTOPEN,HLRFRSH
"RTN","HLOUSR",7,0)
 D WAIT^DICD
"RTN","HLOUSR",8,0)
 D EN^VALM("HLO SYSTEM MONITOR")
"RTN","HLOUSR",9,0)
 Q
"RTN","HLOUSR",10,0)
 ;
"RTN","HLOUSR",11,0)
BRIEF ;Init variables and list array
"RTN","HLOUSR",12,0)
 N COUNT,LINK,QUE,FROM,TIME,STATUS,TEMP
"RTN","HLOUSR",13,0)
 S HLRFRSH="BRIEF^HLOUSR"
"RTN","HLOUSR",14,0)
 S (HLSCREEN,VALMSG)="Brief System Status"
"RTN","HLOUSR",15,0)
 S VALMCNT=8
"RTN","HLOUSR",16,0)
 ;K @VALMAR
"RTN","HLOUSR",17,0)
 D CLEAN^VALM10
"RTN","HLOUSR",18,0)
 S VALMBG=1
"RTN","HLOUSR",19,0)
 S VALMBCK="R"
"RTN","HLOUSR",20,0)
 K VALMDDF("COL 2"),VALMDDF("COL 3"),VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",21,0)
 D CHGCAP^VALM("COL 1","Brief Operational Overview")
"RTN","HLOUSR",22,0)
 S @VALMAR@(1,0)="SYSTEM STATUS:             "_$S($$CHKSTOP^HLOPROC:"STOPPED",1:"RUNNING")
"RTN","HLOUSR",23,0)
 S @VALMAR@(2,0)="PROCESS MANAGER:           "_$S($$RUNNING:"RUNNING",1:"STOPPED")
"RTN","HLOUSR",24,0)
 ;
"RTN","HLOUSR",25,0)
 S TIME=$P($G(TESTOPEN("LISTENER")),"^",2)
"RTN","HLOUSR",26,0)
 I TIME,$$FMDIFF^XLFDT($$NOW^XLFDT,TIME,2)<300 D
"RTN","HLOUSR",27,0)
 .S STATUS=+TESTOPEN("LISTENER")
"RTN","HLOUSR",28,0)
 E  D
"RTN","HLOUSR",29,0)
 .S STATUS=0
"RTN","HLOUSR",30,0)
 .S LINK=$P($G(^HLD(779.1,1,0)),"^",10)
"RTN","HLOUSR",31,0)
 .I LINK S LINK=$P($G(^HLCS(870,LINK,0)),"^") Q:'$L(LINK)  S STATUS=$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOUSR",32,0)
 .S TESTOPEN("LISTENER")=STATUS_"^"_$$NOW^XLFDT
"RTN","HLOUSR",33,0)
 ;
"RTN","HLOUSR",34,0)
 S @VALMAR@(3,0)="STANDARD LISTENER:         "_$S(STATUS:"OPERATIONAL",1:"NOT OPERATIONAL")
"RTN","HLOUSR",35,0)
 ;
"RTN","HLOUSR",36,0)
 S TIME=$P($G(TESTOPEN("IE")),"^",2)
"RTN","HLOUSR",37,0)
 I TIME,$$FMDIFF^XLFDT($$NOW^XLFDT,TIME,2)<300 D
"RTN","HLOUSR",38,0)
 .S STATUS=+TESTOPEN("IE")
"RTN","HLOUSR",39,0)
 E  D
"RTN","HLOUSR",40,0)
 .S STATUS=$$IFOPEN^HLOUSR1("VA-VIE")
"RTN","HLOUSR",41,0)
 .S TESTOPEN("IE")=STATUS_"^"_$$NOW^XLFDT
"RTN","HLOUSR",42,0)
 S @VALMAR@(4,0)="INTERFACE ENGINE:          "_$S(STATUS:"OPERATIONAL",1:"NOT OPERATIONAL")
"RTN","HLOUSR",43,0)
 S @VALMAR@(5,0)="TASKMAN:                   "_$S($$TM^%ZTLOAD:"RUNNING",1:"NOT RUNNING")
"RTN","HLOUSR",44,0)
 ;
"RTN","HLOUSR",45,0)
 S COUNT=0,LINK=""
"RTN","HLOUSR",46,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D
"RTN","HLOUSR",47,0)
 .N TIME,QUE
"RTN","HLOUSR",48,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOUSR",49,0)
 .Q:$$HDIFF^XLFDT($H,TIME,2)<300
"RTN","HLOUSR",50,0)
 .S COUNT=COUNT+1
"RTN","HLOUSR",51,0)
 S @VALMAR@(6,0)="DOWN LINKS:                "_+COUNT
"RTN","HLOUSR",52,0)
 S @VALMAR@(7,0)="CLIENT LINK PROCESSES:     "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","OUTGOING CLIENT LINK"))
"RTN","HLOUSR",53,0)
 S @VALMAR@(8,0)="IN-FILER PROCESSES:        "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","INCOMING QUEUES"))
"RTN","HLOUSR",54,0)
 S COUNT=0,LINK=""
"RTN","HLOUSR",55,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  S QUE=""  F  S QUE=$O(^(LINK,QUE)) Q:QUE=""  S COUNT=COUNT+$G(^(QUE))
"RTN","HLOUSR",56,0)
 S @VALMAR@(9,0)="MESSAGES PENDING TRANSMISSION:      "_+COUNT
"RTN","HLOUSR",57,0)
 S TEMP="STOPPED OUTGOING QUEUES: "
"RTN","HLOUSR",58,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",59,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","OUT",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",60,0)
 S @VALMAR@(10,0)=TEMP
"RTN","HLOUSR",61,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",62,0)
 F  S QUE=$O(^HLC("QUEUECOUNT","IN",QUE)) Q:QUE=""  S FROM=""  F  S FROM=$O(^(QUE,FROM)) Q:FROM=""  S COUNT=COUNT+$G(^(FROM))
"RTN","HLOUSR",63,0)
 S @VALMAR@(11,0)="MESSAGES PENDING ON APPLICATIONS:   "_+COUNT
"RTN","HLOUSR",64,0)
 S TEMP="STOPPED INCOMING QUEUES: "
"RTN","HLOUSR",65,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",66,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","IN",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",67,0)
 S @VALMAR@(12,0)=TEMP
"RTN","HLOUSR",68,0)
 S @VALMAR@(13,0)="FILE 777 RECORD COUNT:              "_$P($G(^HLTMP("FILE 777 RECORD COUNT")),"^")_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^",2))
"RTN","HLOUSR",69,0)
 S @VALMAR@(14,0)="FILE 778 RECORD COUNT:              "_$P($G(^HLTMP("FILE 778 RECORD COUNT")),"^")_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^",2))
"RTN","HLOUSR",70,0)
 Q
"RTN","HLOUSR",71,0)
 ;
"RTN","HLOUSR",72,0)
 ;
"RTN","HLOUSR",73,0)
HELP ;Help code
"RTN","HLOUSR",74,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLOUSR",75,0)
 Q
"RTN","HLOUSR",76,0)
 ;
"RTN","HLOUSR",77,0)
EXIT ;Exit code
"RTN","HLOUSR",78,0)
 D CLEAN^VALM10
"RTN","HLOUSR",79,0)
 D CLEAR^VALM1
"RTN","HLOUSR",80,0)
 ;
"RTN","HLOUSR",81,0)
 Q
"RTN","HLOUSR",82,0)
 ;
"RTN","HLOUSR",83,0)
EXPND ;Expand code
"RTN","HLOUSR",84,0)
 Q
"RTN","HLOUSR",85,0)
 ;
"RTN","HLOUSR",86,0)
PROCS ;
"RTN","HLOUSR",87,0)
 S HLRFRSH="PROCS^HLOUSR"
"RTN","HLOUSR",88,0)
 ;K @VALMAR
"RTN","HLOUSR",89,0)
 D CLEAN^VALM10
"RTN","HLOUSR",90,0)
 S VALMCNT=0
"RTN","HLOUSR",91,0)
 S VALMBCK="R"
"RTN","HLOUSR",92,0)
 S VALMDDF("COL 2")="COL 2^35^10^MIN^H"
"RTN","HLOUSR",93,0)
 S VALMDDF("COL 3")="COL 3^47^10^MAX^H"
"RTN","HLOUSR",94,0)
 S VALMDDF("COL 4")="COL 4^59^10^#RUNNING^H"
"RTN","HLOUSR",95,0)
 S VALMDDF("COL 5")="COL 5^71^10^#QUEUED^IOBON"
"RTN","HLOUSR",96,0)
 D CHGCAP^VALM("COL 1","Process Type")
"RTN","HLOUSR",97,0)
 N IEN
"RTN","HLOUSR",98,0)
 S IEN=0
"RTN","HLOUSR",99,0)
 F  S IEN=$O(^HLD(779.3,"C",1,IEN)) Q:'IEN  D
"RTN","HLOUSR",100,0)
 .N PROC
"RTN","HLOUSR",101,0)
 .Q:'$$GETPROC^HLOPROC1(IEN,.PROC)
"RTN","HLOUSR",102,0)
 .Q:PROC("NAME")="VMS TCP LISTENER"
"RTN","HLOUSR",103,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",104,0)
 .S @VALMAR@(VALMCNT,0)=$$LJ(PROC("NAME"),30)_$$RJ(PROC("MINIMUM"),6)_$$RJ(PROC("MAXIMUM"),12)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC("NAME"))),14)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC("NAME"))),12)
"RTN","HLOUSR",105,0)
 S VALMCNT=VALMCNT+1,@VALMAR@(VALMCNT,0)=""
"RTN","HLOUSR",106,0)
 S IEN=""
"RTN","HLOUSR",107,0)
 F  S IEN=$O(^HLTMP("HL7 RUNNING PROCESSES",IEN)) Q:IEN=""  D
"RTN","HLOUSR",108,0)
 .N NODE
"RTN","HLOUSR",109,0)
 .S NODE=$G(^HLTMP("HL7 RUNNING PROCESSES",IEN))
"RTN","HLOUSR",110,0)
 .Q:NODE=""
"RTN","HLOUSR",111,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",112,0)
 .S @VALMAR@(VALMCNT,0)="$J: "_$$LJ(IEN,9)_" ->"_$$CJ($P(NODE,"^",3),28)_"<- started at "_$$HTE^XLFDT($P(NODE,"^"))
"RTN","HLOUSR",113,0)
 Q
"RTN","HLOUSR",114,0)
DOWNLINK ;
"RTN","HLOUSR",115,0)
 N LINK
"RTN","HLOUSR",116,0)
 D CLEAN^VALM10
"RTN","HLOUSR",117,0)
 ;K @VALMAR
"RTN","HLOUSR",118,0)
 S (HLSCREEN,VALMSG)="Down Client Links"
"RTN","HLOUSR",119,0)
 S HLRFRSH="DOWNLINK^HLOUSR"
"RTN","HLOUSR",120,0)
 S VALMCNT=0
"RTN","HLOUSR",121,0)
 S VALMBCK="R"
"RTN","HLOUSR",122,0)
 S VALMDDF("COL 2")="COL 2^20^20^Pending Messages^H"
"RTN","HLOUSR",123,0)
 S VALMDDF("COL 3")="COL 3^47^20^Date/Time Down^H"
"RTN","HLOUSR",124,0)
 K VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",125,0)
 D CHGCAP^VALM("COL 1","Client Link")
"RTN","HLOUSR",126,0)
 S LINK=""
"RTN","HLOUSR",127,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D
"RTN","HLOUSR",128,0)
 .N TIME,COUNT,QUE
"RTN","HLOUSR",129,0)
 .S TIME=$G(^(LINK)) Q:TIME=""
"RTN","HLOUSR",130,0)
 .Q:$$HDIFF^XLFDT($H,TIME,2)<300
"RTN","HLOUSR",131,0)
 .S TIME=$$HTE^XLFDT(TIME)
"RTN","HLOUSR",132,0)
 .S COUNT=0
"RTN","HLOUSR",133,0)
 .S QUE=""
"RTN","HLOUSR",134,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  S COUNT=COUNT+$G(^(QUE))
"RTN","HLOUSR",135,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",136,0)
 .S @VALMAR@(VALMCNT,0)=$$LJ(LINK,15)_$$RJ(COUNT,15)_"    "_$$RJ(TIME,30)
"RTN","HLOUSR",137,0)
 Q
"RTN","HLOUSR",138,0)
 ;
"RTN","HLOUSR",139,0)
OUTQUEUE ;
"RTN","HLOUSR",140,0)
 N LINK
"RTN","HLOUSR",141,0)
 D CLEAN^VALM10
"RTN","HLOUSR",142,0)
 ;K @VALMAR
"RTN","HLOUSR",143,0)
 S HLRFRSH="OUTQUEUE^HLOUSR"
"RTN","HLOUSR",144,0)
 S (HLSCREEN,VALMSG)="Outgoing Queues *down links !stopped queues"
"RTN","HLOUSR",145,0)
 S VALMCNT=0
"RTN","HLOUSR",146,0)
 S VALMBCK="R"
"RTN","HLOUSR",147,0)
 S VALMDDF("COL 1")="COL 1^2^20^ Link^H"
"RTN","HLOUSR",148,0)
 S VALMDDF("COL 2")="COL 2^28^20^Queue^H"
"RTN","HLOUSR",149,0)
 S VALMDDF("COL 3")="COL 3^50^20^Count^H"
"RTN","HLOUSR",150,0)
 K VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",151,0)
 D CHGCAP^VALM("COL 1"," Link")
"RTN","HLOUSR",152,0)
 S LINK=""
"RTN","HLOUSR",153,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOUSR",154,0)
 .N COUNT,QUE,SHOW
"RTN","HLOUSR",155,0)
 .S SHOW=LINK
"RTN","HLOUSR",156,0)
 .I $D(^HLTMP("FAILING LINKS",SHOW)) S SHOW="*"_SHOW
"RTN","HLOUSR",157,0)
 .S QUE=""
"RTN","HLOUSR",158,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOUSR",159,0)
 ..S COUNT=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE))
"RTN","HLOUSR",160,0)
 ..Q:'COUNT
"RTN","HLOUSR",161,0)
 ..S VALMCNT=VALMCNT+1
"RTN","HLOUSR",162,0)
 ..I $E(SHOW)="*" D
"RTN","HLOUSR",163,0)
 ...S @VALMAR@(VALMCNT,0)=$$LJ(SHOW,20)_$$CJ($S($$STOPPED^HLOQUE("OUT",QUE):"!",1:"")_QUE,21)_"   "_$$RJ(COUNT,10),SHOW=""
"RTN","HLOUSR",164,0)
 ...D CNTRL^VALM10(VALMCNT,1,1,IOBON,IOBOFF)
"RTN","HLOUSR",165,0)
 ..E  S @VALMAR@(VALMCNT,0)=$$LJ(SHOW,20)_$$CJ($S($$STOPPED^HLOQUE("OUT",QUE):"!",1:"")_QUE,21)_"   "_$$RJ(COUNT,10),SHOW=""
"RTN","HLOUSR",166,0)
 Q
"RTN","HLOUSR",167,0)
 ;
"RTN","HLOUSR",168,0)
INQUEUE ;
"RTN","HLOUSR",169,0)
 N FROM
"RTN","HLOUSR",170,0)
 D CLEAN^VALM10
"RTN","HLOUSR",171,0)
 ;K @VALMAR
"RTN","HLOUSR",172,0)
 S HLRFRSH="INQUEUE^HLOUSR"
"RTN","HLOUSR",173,0)
 S (HLSCREEN,VALMSG)="Incoming Queues ('!' = stopped queues)"
"RTN","HLOUSR",174,0)
 S VALMCNT=0
"RTN","HLOUSR",175,0)
 S VALMBCK="R"
"RTN","HLOUSR",176,0)
 S VALMDDF("COL 1")="COL 1^1^40^ From^H"
"RTN","HLOUSR",177,0)
 S VALMDDF("COL 2")="COL 2^45^20^Queue^H"
"RTN","HLOUSR",178,0)
 S VALMDDF("COL 3")="COL 3^70^10^Count^H"
"RTN","HLOUSR",179,0)
 K VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",180,0)
 D CHGCAP^VALM("COL 1"," From")
"RTN","HLOUSR",181,0)
 S FROM=""
"RTN","HLOUSR",182,0)
 F  S FROM=$O(^HLC("QUEUECOUNT","IN",FROM)) Q:FROM=""  D
"RTN","HLOUSR",183,0)
 .N COUNT,QUE,SHOW
"RTN","HLOUSR",184,0)
 .S SHOW=$$LJ(FROM,40)_"  "
"RTN","HLOUSR",185,0)
 .S QUE=""
"RTN","HLOUSR",186,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","IN",FROM,QUE)) Q:QUE=""  D
"RTN","HLOUSR",187,0)
 ..S COUNT=$G(^HLC("QUEUECOUNT","IN",FROM,QUE))
"RTN","HLOUSR",188,0)
 ..Q:'COUNT
"RTN","HLOUSR",189,0)
 ..S VALMCNT=VALMCNT+1
"RTN","HLOUSR",190,0)
 ..S @VALMAR@(VALMCNT,0)=SHOW_$$LJ($S($$STOPPED^HLOQUE("IN",QUE):"!",1:"")_QUE,21)_" "_$$RJ(COUNT,10)
"RTN","HLOUSR",191,0)
 ..S SHOW=$$LJ("",40)_"  "
"RTN","HLOUSR",192,0)
 Q
"RTN","HLOUSR",193,0)
VIEWLINK ;
"RTN","HLOUSR",194,0)
 N C,QUIT,LINK
"RTN","HLOUSR",195,0)
 S (QUIT,C,LINK)=""
"RTN","HLOUSR",196,0)
 S VALMBCK="R"
"RTN","HLOUSR",197,0)
 ;
"RTN","HLOUSR",198,0)
 ;currently HL7 (Optimized) only does TCP, when serial added a change is needed here
"RTN","HLOUSR",199,0)
 S LINK=$$ASKLINK
"RTN","HLOUSR",200,0)
 Q:LINK=""
"RTN","HLOUSR",201,0)
 W !,"Hit any key to stop...",!
"RTN","HLOUSR",202,0)
 F  D  Q:QUIT
"RTN","HLOUSR",203,0)
 .N COUNT,QUE
"RTN","HLOUSR",204,0)
 .S (COUNT,QUE)=""
"RTN","HLOUSR",205,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  S COUNT=COUNT+$G(^(QUE))
"RTN","HLOUSR",206,0)
 .W $C(13),"                             ",$C(13),"MESSAGES PENDING TRANSMISSION: ",IOBON,$$RJ(COUNT,10),IOBOFF
"RTN","HLOUSR",207,0)
 .R *C:1 I $T S QUIT=1
"RTN","HLOUSR",208,0)
 Q
"RTN","HLOUSR",209,0)
 ;
"RTN","HLOUSR",210,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR",211,0)
 Q $$CJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",212,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR",213,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",214,0)
RJ(STRING,LEN) ;
"RTN","HLOUSR",215,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",216,0)
 ;
"RTN","HLOUSR",217,0)
RUNNING() ;Is the Process Manager running?
"RTN","HLOUSR",218,0)
 N RUNNING
"RTN","HLOUSR",219,0)
 L +^HLTMP("PROCESS MANAGER"):0
"RTN","HLOUSR",220,0)
 S RUNNING='$T
"RTN","HLOUSR",221,0)
 I 'RUNNING L -^HLTMP("PROCESS MANAGER")
"RTN","HLOUSR",222,0)
 Q RUNNING
"RTN","HLOUSR",223,0)
 ;
"RTN","HLOUSR",224,0)
TESTLINK ;
"RTN","HLOUSR",225,0)
 N LINK,LINKNAME,OK
"RTN","HLOUSR",226,0)
 S VALMBCK="R"
"RTN","HLOUSR",227,0)
 S LINKNAME=$$ASKLINK
"RTN","HLOUSR",228,0)
 Q:LINKNAME=""
"RTN","HLOUSR",229,0)
 S OK=$$IFOPEN^HLOUSR1(LINKNAME)
"RTN","HLOUSR",230,0)
 I OK W !,LINKNAME_" IS operational..."
"RTN","HLOUSR",231,0)
 E  W !,LINKNAME_" is NOT operational..."
"RTN","HLOUSR",232,0)
 W !,"Hit any key to continue..."
"RTN","HLOUSR",233,0)
 R *C:DTIME
"RTN","HLOUSR",234,0)
 Q
"RTN","HLOUSR",235,0)
 ;
"RTN","HLOUSR",236,0)
ASKLINK() ;
"RTN","HLOUSR",237,0)
 N DIC,TCP,X,Y,DTOUT,DUOUT
"RTN","HLOUSR",238,0)
 S DIC=870
"RTN","HLOUSR",239,0)
 S DIC(0)="AE"
"RTN","HLOUSR",240,0)
 S TCP=$O(^HLCS(869.1,"B","TCP",0))
"RTN","HLOUSR",241,0)
 S DIC("A")="Select a TCP link:"
"RTN","HLOUSR",242,0)
 S DIC("S")="I $P(^(0),U,3)=TCP"
"RTN","HLOUSR",243,0)
 D FULL^VALM1
"RTN","HLOUSR",244,0)
 D ^DIC
"RTN","HLOUSR",245,0)
 I +Y'=-1,'$D(DTOUT),'$D(DUOUT) Q $P(Y,"^",2)
"RTN","HLOUSR",246,0)
 Q ""
"RTN","HLOUSR",247,0)
 ;
"RTN","HLOUSR",248,0)
STOP ;
"RTN","HLOUSR",249,0)
 I '$$ASKYESNO^HLOUSR2("Are you SURE that you want to stop sending and receiving messages","NO") S VALMBCK="" Q
"RTN","HLOUSR",250,0)
 ;
"RTN","HLOUSR",251,0)
 D STOPHL7^HLOPROC1
"RTN","HLOUSR",252,0)
 S VALMBCK="R",VALMSG="HL7 (Optimized) has been stopped...."
"RTN","HLOUSR",253,0)
 H 5
"RTN","HLOUSR",254,0)
 D:HLSCREEN="Brief System Status" BRIEF^HLOUSR
"RTN","HLOUSR",255,0)
 D:HLSCREEN="Running Processes" PROCS^HLOUSR
"RTN","HLOUSR",256,0)
 Q
"RTN","HLOUSR",257,0)
 ;
"RTN","HLOUSR",258,0)
UPDMODE ;update mode
"RTN","HLOUSR",259,0)
 Q:'$L(HLRFRSH)
"RTN","HLOUSR",260,0)
 N QUIT,NEW,TOP,BOTTOM,DX,DY,IOTM,IOBM,I
"RTN","HLOUSR",261,0)
 W !!,IOINHI,"Hit any key to escape realtime display mode...",IOINORM
"RTN","HLOUSR",262,0)
 S IOTM=3,IOBM=23
"RTN","HLOUSR",263,0)
 W @IOSTBM
"RTN","HLOUSR",264,0)
 S DX=1,DY=$S(VALMCNT<17:VALMCNT+1,1:17) X IOXY
"RTN","HLOUSR",265,0)
 I VALMCNT>16 F I=17:1:$S(VALMCNT<22:VALMCNT,1:21) W !,@VALMAR@(I,0)
"RTN","HLOUSR",266,0)
 S QUIT=0
"RTN","HLOUSR",267,0)
 S TOP=VALMBG
"RTN","HLOUSR",268,0)
 S BOTTOM=TOP+23
"RTN","HLOUSR",269,0)
 S OLD=VALMAR
"RTN","HLOUSR",270,0)
 S VALMAR="NEW"
"RTN","HLOUSR",271,0)
 S VALMCNT=0
"RTN","HLOUSR",272,0)
 F  D  Q:QUIT
"RTN","HLOUSR",273,0)
 .N LINE
"RTN","HLOUSR",274,0)
 .R *C:3 I $T S QUIT=1
"RTN","HLOUSR",275,0)
 .S (VALMCNT,I)=0
"RTN","HLOUSR",276,0)
 .D @HLRFRSH
"RTN","HLOUSR",277,0)
 .F LINE=TOP:1:BOTTOM IF $G(@OLD@(LINE,0))'=$G(@VALMAR@(LINE,0)) D WRITE^VALM10(LINE)
"RTN","HLOUSR",278,0)
 K @OLD M @OLD=@VALMAR S VALMAR=OLD
"RTN","HLOUSR",279,0)
 S VALMBCK="R"
"RTN","HLOUSR",280,0)
 Q
"RTN","HLOUSR1")
0^42^B64766610
"RTN","HLOUSR1",1,0)
HLOUSR1 ;ALB/CJM -ListManager Screen for viewing messages;12 JUN 1997 10:00 am ;03/14/2005  08:08
"RTN","HLOUSR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOUSR1",3,0)
 ;
"RTN","HLOUSR1",4,0)
EN ;
"RTN","HLOUSR1",5,0)
 N MSGIEN
"RTN","HLOUSR1",6,0)
 S MSGIEN=$$PICKMSG
"RTN","HLOUSR1",7,0)
 I 'MSGIEN S VALMBCK="R" Q
"RTN","HLOUSR1",8,0)
 D EN^VALM("HLO SINGLE MESSAGE DISPLAY")
"RTN","HLOUSR1",9,0)
 Q
"RTN","HLOUSR1",10,0)
 ;
"RTN","HLOUSR1",11,0)
HDR ;
"RTN","HLOUSR1",12,0)
 Q
"RTN","HLOUSR1",13,0)
 ;
"RTN","HLOUSR1",14,0)
BLANK ;
"RTN","HLOUSR1",15,0)
 S VALMCNT=0
"RTN","HLOUSR1",16,0)
 D EXIT
"RTN","HLOUSR1",17,0)
 Q
"RTN","HLOUSR1",18,0)
DISPLAY ;
"RTN","HLOUSR1",19,0)
 K @VALMAR
"RTN","HLOUSR1",20,0)
 S VALMBCK="R"
"RTN","HLOUSR1",21,0)
 N MSG
"RTN","HLOUSR1",22,0)
 S VALMBG=1
"RTN","HLOUSR1",23,0)
 Q:'MSGIEN
"RTN","HLOUSR1",24,0)
 D SHOWMSG($P(MSGIEN,"^"),$P(MSGIEN,"^",2))
"RTN","HLOUSR1",25,0)
 Q
"RTN","HLOUSR1",26,0)
 ;
"RTN","HLOUSR1",27,0)
PICKMSG() ;
"RTN","HLOUSR1",28,0)
 ;ask the user to select a message & return its ien
"RTN","HLOUSR1",29,0)
 N MSGIEN,DIR,COUNT,LIST
"RTN","HLOUSR1",30,0)
 D FULL^VALM1
"RTN","HLOUSR1",31,0)
 S DIR(0)="F3:30"
"RTN","HLOUSR1",32,0)
 S DIR("A")="Message ID"
"RTN","HLOUSR1",33,0)
 S DIR("?")="Enter the full Message Control ID or Batch Control ID of the message, or '^' to exit."
"RTN","HLOUSR1",34,0)
PICK D ^DIR
"RTN","HLOUSR1",35,0)
 I $D(DIRUT)!(Y="") Q 0
"RTN","HLOUSR1",36,0)
 I $G(@VALMAR@("INDEX",Y)) Q $G(@VALMAR@("INDEX",Y))
"RTN","HLOUSR1",37,0)
 S COUNT=$$FINDMSG^HLOMSG1(Y,.LIST)
"RTN","HLOUSR1",38,0)
 I COUNT="0" W !!,"That message can not be found! Try Again",! G PICK
"RTN","HLOUSR1",39,0)
 I COUNT=1 Q LIST(1)
"RTN","HLOUSR1",40,0)
 I COUNT>1 D
"RTN","HLOUSR1",41,0)
 .N ITEM
"RTN","HLOUSR1",42,0)
 .W !,"There is more than one message with that ID! You must choose one to display.",1
"RTN","HLOUSR1",43,0)
 .S ITEM=0
"RTN","HLOUSR1",44,0)
 .F  S ITEM=$O(LIST(ITEM)) Q:'ITEM  D
"RTN","HLOUSR1",45,0)
 ..N MSG
"RTN","HLOUSR1",46,0)
 ..Q:'$$GETMSG^HLOMSG(+LIST(ITEM),.MSG)
"RTN","HLOUSR1",47,0)
 ..W !,"[",ITEM,"]","  DT/TM: ",$$FMTE^XLFDT(MSG("DT/TM CREATED"),2),"   STATUS: ",MSG("STATUS")
"RTN","HLOUSR1",48,0)
 .S DIR(0)="NO^1:"_COUNT,DIR("A")="Choose",DIR("?")="Choose one message from the list"
"RTN","HLOUSR1",49,0)
 .D ^DIR
"RTN","HLOUSR1",50,0)
 .I Y S Y=LIST(Y)
"RTN","HLOUSR1",51,0)
 Q Y
"RTN","HLOUSR1",52,0)
 ;
"RTN","HLOUSR1",53,0)
HELP ;Help code
"RTN","HLOUSR1",54,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLOUSR1",55,0)
 Q
"RTN","HLOUSR1",56,0)
 ;
"RTN","HLOUSR1",57,0)
EXIT ;Exit code
"RTN","HLOUSR1",58,0)
 D CLEAN^VALM10
"RTN","HLOUSR1",59,0)
 D CLEAR^VALM1
"RTN","HLOUSR1",60,0)
 S VALMBCK="R"
"RTN","HLOUSR1",61,0)
 ;
"RTN","HLOUSR1",62,0)
 Q
"RTN","HLOUSR1",63,0)
 ;
"RTN","HLOUSR1",64,0)
EXPND ;Expand code
"RTN","HLOUSR1",65,0)
 Q
"RTN","HLOUSR1",66,0)
 ;
"RTN","HLOUSR1",67,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR1",68,0)
 Q $$CJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR1",69,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR1",70,0)
 Q $$LJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR1",71,0)
SP(LEN,CHAR) ;
"RTN","HLOUSR1",72,0)
 ;return padding - " " is the default pad character
"RTN","HLOUSR1",73,0)
 N STR
"RTN","HLOUSR1",74,0)
 S:$G(CHAR)="" CHAR=" "
"RTN","HLOUSR1",75,0)
 S $P(STR,CHAR,LEN)=CHAR
"RTN","HLOUSR1",76,0)
 Q STR
"RTN","HLOUSR1",77,0)
 ;
"RTN","HLOUSR1",78,0)
SHOWMSG(MSGIEN,SUBIEN) ;
"RTN","HLOUSR1",79,0)
 ;Description:
"RTN","HLOUSR1",80,0)
 ;
"RTN","HLOUSR1",81,0)
 ;Input:
"RTN","HLOUSR1",82,0)
 ;Output:
"RTN","HLOUSR1",83,0)
 ;
"RTN","HLOUSR1",84,0)
 N MSG,I,TEMP,LINE
"RTN","HLOUSR1",85,0)
 S VALMCNT=0
"RTN","HLOUSR1",86,0)
 S SUBIEN=+$G(SUBIEN)
"RTN","HLOUSR1",87,0)
 I '$$GETMSG^HLOMSG(MSGIEN,.MSG) W !,"UNABLE TO DISPLAY THE MESSAGE",!! Q
"RTN","HLOUSR1",88,0)
 I SUBIEN D GETMSGB^HLOMSG1(.MSG,SUBIEN,.MSG)
"RTN","HLOUSR1",89,0)
 ;
"RTN","HLOUSR1",90,0)
 S I=0
"RTN","HLOUSR1",91,0)
 ;** administrative information **
"RTN","HLOUSR1",92,0)
 S @VALMAR@($$I,0)=$$CJ("Administrative Information",80)
"RTN","HLOUSR1",93,0)
 D CNTRL^VALM10(VALMCNT,26,30,IORVON,IORVOFF)
"RTN","HLOUSR1",94,0)
 S LINE="MsgID: "_$$LJ(MSG("ID"),18)
"RTN","HLOUSR1",95,0)
 S LINE=LINE_"Status: "_$$LJ(MSG("STATUS"),5)
"RTN","HLOUSR1",96,0)
 S:MSG("ACK TO")]"" LINE=LINE_$$LJ(" Ack To:",14)_MSG("ACK TO")
"RTN","HLOUSR1",97,0)
 S:MSG("ACK BY")]"" LINE=LINE_$$LJ(" Ack'd By:",14)_MSG("ACK BY")
"RTN","HLOUSR1",98,0)
 S @VALMAR@($$I,0)=LINE
"RTN","HLOUSR1",99,0)
 I MSG("STATUS","ERROR TEXT")]"" S @VALMAR@($$I,0)="Error: "_"** "_MSG("STATUS","ERROR TEXT")_" **"
"RTN","HLOUSR1",100,0)
 S @VALMAR@($$I,0)="Dir:   "_$$LJ($S(MSG("DIRECTION")="IN":"INCOMING",1:"OUTGOING"),30)_$$LJ("  Trans Dt/Tm: ",12)_$$FMTE^XLFDT(MSG("DT/TM"),2)
"RTN","HLOUSR1",101,0)
 S @VALMAR@($$I,0)="Link:  "_$$LJ(MSG("STATUS","LINK NAME"),29)_"   "_$$LJ("Queue: ",13)_MSG("STATUS","QUEUE")
"RTN","HLOUSR1",102,0)
 I MSG("STATUS","ACCEPT ACK'D") D
"RTN","HLOUSR1",103,0)
 .S @VALMAR@($$I,0)="Accept Ack: "_$$LJ(MSG("STATUS","ACCEPT ACK ID"),26)_$$LJ(" At: ",14)_$$FMTE^XLFDT(MSG("STATUS","ACCEPT ACK DT/TM"),2)
"RTN","HLOUSR1",104,0)
 .S @VALMAR@($$I,0)="   "_MSG("STATUS","ACCEPT ACK MSA")
"RTN","HLOUSR1",105,0)
 I MSG("DIRECTION")="IN" D
"RTN","HLOUSR1",106,0)
 .N ACTION,HDR
"RTN","HLOUSR1",107,0)
 .S LINE="App Response Rtn: "
"RTN","HLOUSR1",108,0)
 .M HDR=MSG("HDR")
"RTN","HLOUSR1",109,0)
 .I $$PARSEHDR^HLOPRS(.HDR),$$ACTION^HLOAPP(.HDR,.ACTION) S LINE=$$LJ(LINE_ACTION,38)_" Executed: "_$S(MSG("STATUS","APP HANDOFF"):"   YES",1:"   NO")
"RTN","HLOUSR1",110,0)
 .S @VALMAR@($$I,0)=LINE
"RTN","HLOUSR1",111,0)
 I MSG("DIRECTION")="OUT",(MSG("STATUS","APP ACK'D")!MSG("STATUS","ACCEPT ACK'D")) D
"RTN","HLOUSR1",112,0)
 .S LINE=""
"RTN","HLOUSR1",113,0)
 .I MSG("STATUS","ACCEPT ACK'D") D
"RTN","HLOUSR1",114,0)
 ..I MSG("STATUS","ACCEPT ACK RESPONSE")="" S MSG("STATUS","ACCEPT ACK RESPONSE")="n/a"
"RTN","HLOUSR1",115,0)
 ..S LINE="Accept Ack Rtn: "_MSG("STATUS","ACCEPT ACK RESPONSE")
"RTN","HLOUSR1",116,0)
 .S LINE=$$LJ(LINE,39)
"RTN","HLOUSR1",117,0)
 .I MSG("STATUS","APP ACK'D") D
"RTN","HLOUSR1",118,0)
 ..I MSG("STATUS","APP ACK RESPONSE")="" S MSG("STATUS","APP ACK RESPONSE")="n/a"
"RTN","HLOUSR1",119,0)
 ..S LINE=LINE_"App Ack Rtn: "_MSG("STATUS","APP ACK RESPONSE")
"RTN","HLOUSR1",120,0)
 .S @VALMAR@($$I,0)=LINE
"RTN","HLOUSR1",121,0)
 ;
"RTN","HLOUSR1",122,0)
 ;** the message text **
"RTN","HLOUSR1",123,0)
 S @VALMAR@($$I,0)=""
"RTN","HLOUSR1",124,0)
 I '$G(SUBIEN) D
"RTN","HLOUSR1",125,0)
 .S @VALMAR@($$I,0)=$$CJ("Message Text",80)
"RTN","HLOUSR1",126,0)
 .D CNTRL^VALM10(VALMCNT,33,16,IORVON,IORVOFF)
"RTN","HLOUSR1",127,0)
 E  D
"RTN","HLOUSR1",128,0)
 .S @VALMAR@($$I,0)=$$CJ("Individual Message Text (Batched)",80)
"RTN","HLOUSR1",129,0)
 .D CNTRL^VALM10(VALMCNT,23,35,IORVON,IORVOFF)
"RTN","HLOUSR1",130,0)
 D SHOWBODY(.MSG,$G(SUBIEN))
"RTN","HLOUSR1",131,0)
 ;
"RTN","HLOUSR1",132,0)
 ;** display its application acknowledgment **
"RTN","HLOUSR1",133,0)
 I MSG("ACK BY")]"",$$FINDMSG^HLOMSG1(MSG("ACK BY"),.TEMP)=1 S MSGIEN=TEMP(1) D
"RTN","HLOUSR1",134,0)
 .N MSG
"RTN","HLOUSR1",135,0)
 .Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR1",136,0)
 .I $P(MSGIEN,"^",2) D GETMSGB^HLOMSG1(.MSG,$P(MSGIEN,"^",2),.MSG)
"RTN","HLOUSR1",137,0)
 .S @VALMAR@($$I,0)=""
"RTN","HLOUSR1",138,0)
 .S @VALMAR@($$I,0)=$$CJ("Application Acknowledgment",80)
"RTN","HLOUSR1",139,0)
 .D CNTRL^VALM10(VALMCNT,26,30,IORVON,IORVOFF)
"RTN","HLOUSR1",140,0)
 .D SHOWBODY(.MSG,$P(MSGIEN,"^",2))
"RTN","HLOUSR1",141,0)
 Q
"RTN","HLOUSR1",142,0)
 ;
"RTN","HLOUSR1",143,0)
SHOWBODY(MSG,SUBIEN) ;
"RTN","HLOUSR1",144,0)
 N NODE,I,SEG,QUIT
"RTN","HLOUSR1",145,0)
 S QUIT=0
"RTN","HLOUSR1",146,0)
 M SEG=MSG("HDR")
"RTN","HLOUSR1",147,0)
 D ADD(.SEG)
"RTN","HLOUSR1",148,0)
 S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOUSR1",149,0)
 I MSG("BATCH") D
"RTN","HLOUSR1",150,0)
 .I $G(SUBIEN) D  Q
"RTN","HLOUSR1",151,0)
 ..S MSG("BATCH","CURRENT MESSAGE")=SUBIEN
"RTN","HLOUSR1",152,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  D ADD(.SEG)
"RTN","HLOUSR1",153,0)
 .S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOUSR1",154,0)
 .N LAST S LAST=0
"RTN","HLOUSR1",155,0)
 .F  Q:'$$NEXTMSG^HLOMSG(.MSG,.SEG)  D  Q:QUIT
"RTN","HLOUSR1",156,0)
 ..D ADD(.SEG)
"RTN","HLOUSR1",157,0)
 ..S LAST=MSG("BATCH","CURRENT MESSAGE")
"RTN","HLOUSR1",158,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  D ADD(.SEG)
"RTN","HLOUSR1",159,0)
 .I MSG("DIRECTION")="OUT" K SEG S SEG(1)="BTS"_$E($G(NODE(1)),4)_LAST D ADD(.SEG)
"RTN","HLOUSR1",160,0)
 E  D
"RTN","HLOUSR1",161,0)
 .F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  D  Q:QUIT
"RTN","HLOUSR1",162,0)
 ..D ADD(.SEG)
"RTN","HLOUSR1",163,0)
 Q
"RTN","HLOUSR1",164,0)
I() ;
"RTN","HLOUSR1",165,0)
 S VALMCNT=VALMCNT+1
"RTN","HLOUSR1",166,0)
 Q VALMCNT
"RTN","HLOUSR1",167,0)
ADD(SEG) ;
"RTN","HLOUSR1",168,0)
 N QUIT,I,J,LINE
"RTN","HLOUSR1",169,0)
 S QUIT=0
"RTN","HLOUSR1",170,0)
 S (I,J)=1
"RTN","HLOUSR1",171,0)
 S LINE(1)=$E(SEG(1),1,80),SEG(1)=$E(SEG(1),81,9999)
"RTN","HLOUSR1",172,0)
 I SEG(1)="" K SEG(1)
"RTN","HLOUSR1",173,0)
 D SHIFT(.I,.J)
"RTN","HLOUSR1",174,0)
 S @VALMAR@($$I,0)=LINE(1)
"RTN","HLOUSR1",175,0)
 S I=1
"RTN","HLOUSR1",176,0)
 F  S I=$O(LINE(I)) Q:'I  D
"RTN","HLOUSR1",177,0)
 .S @VALMAR@($$I,0)=LINE(I)
"RTN","HLOUSR1",178,0)
 .D CNTRL^VALM10(VALMCNT,1,1,IORVON,IORVOFF)
"RTN","HLOUSR1",179,0)
 Q
"RTN","HLOUSR1",180,0)
 ;
"RTN","HLOUSR1",181,0)
SHIFT(I,J) ;
"RTN","HLOUSR1",182,0)
 I '$D(SEG(I)) S I=$O(SEG(0)) Q:'I
"RTN","HLOUSR1",183,0)
 I $L(LINE(J))<80 D
"RTN","HLOUSR1",184,0)
 .N LEN
"RTN","HLOUSR1",185,0)
 .S LEN=$L(LINE(J))
"RTN","HLOUSR1",186,0)
 .S LINE(J)=LINE(J)_$E(SEG(I),1,80-LEN)
"RTN","HLOUSR1",187,0)
 .S SEG(I)=$E(SEG(I),81-LEN,9999)
"RTN","HLOUSR1",188,0)
 .I SEG(I)="" K SEG(I)
"RTN","HLOUSR1",189,0)
 E  D
"RTN","HLOUSR1",190,0)
 .S J=J+1
"RTN","HLOUSR1",191,0)
 .S LINE(J)="-"
"RTN","HLOUSR1",192,0)
 D SHIFT(.I,.J)
"RTN","HLOUSR1",193,0)
 Q
"RTN","HLOUSR1",194,0)
 ;
"RTN","HLOUSR1",195,0)
SCRLMODE ;scroll mode
"RTN","HLOUSR1",196,0)
 Q:'$L(HLRFRSH)
"RTN","HLOUSR1",197,0)
 N QUIT,IOTM,IOBM,DX,DY,LINE,IOTM,IOBM
"RTN","HLOUSR1",198,0)
 W !!,IOINHI,"Hit any key to escape scroll mode...",IOINORM
"RTN","HLOUSR1",199,0)
 S IOTM=3,IOBM=23
"RTN","HLOUSR1",200,0)
 S QUIT=0
"RTN","HLOUSR1",201,0)
 S LINE=$S(VALMCNT<17:1,1:17)
"RTN","HLOUSR1",202,0)
 W @IOSTBM
"RTN","HLOUSR1",203,0)
 S DX=1,DY=$S(VALMCNT<17:VALMCNT+1,1:17) X IOXY
"RTN","HLOUSR1",204,0)
 F I=1:1 D  Q:QUIT
"RTN","HLOUSR1",205,0)
 .;every 10 seconds refresh the data
"RTN","HLOUSR1",206,0)
 .I I>42 D @HLRFRSH S I=0
"RTN","HLOUSR1",207,0)
 .I LINE+1>VALMCNT D
"RTN","HLOUSR1",208,0)
 ..S TEMP=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR1",209,0)
 ..W !,IOUON,TEMP_$$SP(80-$L(TEMP)),IOUOFF
"RTN","HLOUSR1",210,0)
 .E  W !,$G(@VALMAR@(LINE,0))
"RTN","HLOUSR1",211,0)
 .S LINE=LINE+1
"RTN","HLOUSR1",212,0)
 .I LINE>VALMCNT S LINE=1
"RTN","HLOUSR1",213,0)
 .I (I=22)!(I=43) R *C:5 I $T S QUIT=1 Q
"RTN","HLOUSR1",214,0)
 S VALMBG=LINE-23 I VALMBG<0 S VALMBG=1
"RTN","HLOUSR1",215,0)
 S VALMBCK="R"
"RTN","HLOUSR1",216,0)
 Q
"RTN","HLOUSR1",217,0)
HLP ;
"RTN","HLOUSR1",218,0)
 Q
"RTN","HLOUSR1",219,0)
 ;
"RTN","HLOUSR1",220,0)
IFOPEN(LINK) ;
"RTN","HLOUSR1",221,0)
 ;returns 1 if the link can be opened, otherwise 0
"RTN","HLOUSR1",222,0)
 ;
"RTN","HLOUSR1",223,0)
 ;Inputs:
"RTN","HLOUSR1",224,0)
 ;  LINK - name of the link (required), optionally post-fixed with ":"_<port #>, will default to that defined for link
"RTN","HLOUSR1",225,0)
 ;
"RTN","HLOUSR1",226,0)
 N LINKNAME,LINKARY,POP,IO,IOF,IOST,OPEN,PORT
"RTN","HLOUSR1",227,0)
 S OPEN=0
"RTN","HLOUSR1",228,0)
 S LINKNAME=$P(LINK,":")
"RTN","HLOUSR1",229,0)
 S PORT=$P(LINK,":",2)
"RTN","HLOUSR1",230,0)
 Q:LINKNAME="" 0
"RTN","HLOUSR1",231,0)
 Q:'$$GETLINK^HLOTLNK(LINKNAME,.LINKARY) 0
"RTN","HLOUSR1",232,0)
 S:PORT LINKARY("PORT")=PORT
"RTN","HLOUSR1",233,0)
 Q:'$G(LINKARY("PORT")) 0
"RTN","HLOUSR1",234,0)
 I LINKARY("IP")="",LINKARY("DOMAIN")="",LINKARY("LLP")="TCP",LINKARY("SERVER") D
"RTN","HLOUSR1",235,0)
 .N DATA
"RTN","HLOUSR1",236,0)
 .S LINKARY("DOMAIN")=$P($G(^HLD(779.1,1,0)),"^")
"RTN","HLOUSR1",237,0)
 .Q:LINKARY("DOMAIN")=""
"RTN","HLOUSR1",238,0)
 .S DATA(.08)=LINKARY("DOMAIN")
"RTN","HLOUSR1",239,0)
 .Q:$$UPD^HLOASUB1(870,LINKARY("IEN"),.DATA)
"RTN","HLOUSR1",240,0)
 D:$G(LINKARY("IP"))'=""
"RTN","HLOUSR1",241,0)
 .D CALL^%ZISTCP(LINKARY("IP"),LINKARY("PORT"),15)
"RTN","HLOUSR1",242,0)
 .S OPEN='POP
"RTN","HLOUSR1",243,0)
 I 'OPEN,LINKARY("DOMAIN")'="",$G(^HLTMP("DNS LAST",LINKARY("IEN")))<$$DT^XLFDT D
"RTN","HLOUSR1",244,0)
 .N IP
"RTN","HLOUSR1",245,0)
 .S ^HLTMP("DNS LAST",LINKARY("IEN"))=$$DT^XLFDT
"RTN","HLOUSR1",246,0)
 .S IP=$$DNS^HLOTCP(LINKARY("DOMAIN"))
"RTN","HLOUSR1",247,0)
 .I IP'="",IP'=LINKARY("IP") D
"RTN","HLOUSR1",248,0)
 ..N DATA
"RTN","HLOUSR1",249,0)
 ..S DATA(400.01)=IP,LINKARY("IP")=IP
"RTN","HLOUSR1",250,0)
 ..Q:$$UPD^HLOASUB1(870,LINKARY("IEN"),.DATA)
"RTN","HLOUSR1",251,0)
 ..D CALL^%ZISTCP(LINKARY("IP"),LINKARY("PORT"),15)
"RTN","HLOUSR1",252,0)
 ..S OPEN='POP
"RTN","HLOUSR1",253,0)
 C:OPEN IO
"RTN","HLOUSR1",254,0)
 ;D CLOSE^%ZISTCP
"RTN","HLOUSR1",255,0)
 Q OPEN
"RTN","HLOUSR2")
0^43^B44072105
"RTN","HLOUSR2",1,0)
HLOUSR2 ;ALB/CJM -ListManager Screen for viewing messages(continued);12 JUN 1997 10:00 am
"RTN","HLOUSR2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOUSR2",3,0)
 ;
"RTN","HLOUSR2",4,0)
EN ;
"RTN","HLOUSR2",5,0)
 D WAIT^DICD
"RTN","HLOUSR2",6,0)
 D EN^VALM("HLO MESSAGE VIEWER")
"RTN","HLOUSR2",7,0)
 Q
"RTN","HLOUSR2",8,0)
 ;
"RTN","HLOUSR2",9,0)
SHOWLIST(TYPE) ;
"RTN","HLOUSR2",10,0)
 ;TYPE= "SE", "AE", "TF"
"RTN","HLOUSR2",11,0)
 N PARMS,I
"RTN","HLOUSR2",12,0)
 S (VALMBG,VALMCNT,I)=0
"RTN","HLOUSR2",13,0)
 D CLEAN^VALM10
"RTN","HLOUSR2",14,0)
 S VALMBG=1
"RTN","HLOUSR2",15,0)
 I '$$ASKPARMS(.PARMS) S VALMBCK="" Q
"RTN","HLOUSR2",16,0)
 I PARMS("ALL") D
"RTN","HLOUSR2",17,0)
 .N APP
"RTN","HLOUSR2",18,0)
 .S APP=""
"RTN","HLOUSR2",19,0)
 .F  S APP=$O(^HLB("ERRORS",TYPE,APP)) Q:APP=""  Q:I>500  D
"RTN","HLOUSR2",20,0)
 ..N TIME,IEN
"RTN","HLOUSR2",21,0)
 ..S TIME=PARMS("START")
"RTN","HLOUSR2",22,0)
 ..Q:($O(^HLB("ERRORS",TYPE,APP,TIME))="")
"RTN","HLOUSR2",23,0)
 ..S @VALMAR@($$I,0)="Application: "_APP
"RTN","HLOUSR2",24,0)
 ..D CNTRL^VALM10(VALMCNT,14,$L(APP),IOINHI,IOINORM)
"RTN","HLOUSR2",25,0)
 ..F  S TIME=$O(^HLB("ERRORS",TYPE,APP,TIME)) Q:'TIME  Q:VALMCNT>500  S IEN="" F  S IEN=$O(^HLB("ERRORS",TYPE,APP,TIME,IEN)) Q:IEN=""  Q:VALMCNT>500  D ADDTO(TYPE,IEN,TIME)
"RTN","HLOUSR2",26,0)
 E  D
"RTN","HLOUSR2",27,0)
 .N APP
"RTN","HLOUSR2",28,0)
 .S APP=PARMS("APP")
"RTN","HLOUSR2",29,0)
 .N TIME,IEN
"RTN","HLOUSR2",30,0)
 .S TIME=PARMS("START")
"RTN","HLOUSR2",31,0)
 .Q:$O(^HLB("ERRORS",TYPE,APP,TIME))=""
"RTN","HLOUSR2",32,0)
 .S @VALMAR@($$I,0)="Application: "_APP
"RTN","HLOUSR2",33,0)
 .D CNTRL^VALM10(VALMCNT,14,$L(APP),IOINHI,IOINORM)
"RTN","HLOUSR2",34,0)
 .F  S TIME=$O(^HLB("ERRORS",TYPE,APP,TIME)) Q:'TIME  Q:VALMCNT>500  S IEN="" F  S IEN=$O(^HLB("ERRORS",TYPE,APP,TIME,IEN)) Q:IEN=""  Q:VALMCNT>500  D ADDTO(TYPE,IEN,TIME)
"RTN","HLOUSR2",35,0)
 ;
"RTN","HLOUSR2",36,0)
SHOW S VALMBCK="R"
"RTN","HLOUSR2",37,0)
 ;
"RTN","HLOUSR2",38,0)
 Q
"RTN","HLOUSR2",39,0)
ADDTO(LTYPE,IEN,TIME) ;
"RTN","HLOUSR2",40,0)
 N NODE,MSG
"RTN","HLOUSR2",41,0)
 Q:'$$GETMSG^HLOMSG(+IEN,.MSG)
"RTN","HLOUSR2",42,0)
 I LTYPE'="AE" D
"RTN","HLOUSR2",43,0)
 .N TYPE
"RTN","HLOUSR2",44,0)
 .S TYPE=$S(MSG("BATCH"):"BATCH",1:MSG("MESSAGE TYPE")_"~"_MSG("EVENT"))
"RTN","HLOUSR2",45,0)
 .S @VALMAR@($$I,0)="  "_$$LJ(MSG("ID"),15)_$$LJ(TYPE,8)_$$LJ($$FMTE^XLFDT(TIME,2),20)_MSG("STATUS","ERROR TEXT")
"RTN","HLOUSR2",46,0)
 .D CNTRL^VALM10(VALMCNT,3,15,IOINHI,IOINORM)
"RTN","HLOUSR2",47,0)
 .S:MSG("ID")]"" @VALMAR@("INDEX",MSG("ID"))=IEN
"RTN","HLOUSR2",48,0)
 E  D
"RTN","HLOUSR2",49,0)
 .;application errors - could be an error to a msg within a batch
"RTN","HLOUSR2",50,0)
 .;also, need to go to the ack msg to get the error text from the MSA segment
"RTN","HLOUSR2",51,0)
 .;
"RTN","HLOUSR2",52,0)
 .N SUBIEN,MSA,ERRTEXT
"RTN","HLOUSR2",53,0)
 .S (ERRTEXT,MSA)=""
"RTN","HLOUSR2",54,0)
 .S SUBIEN=$P(IEN,"^",2)
"RTN","HLOUSR2",55,0)
 .;within batch?
"RTN","HLOUSR2",56,0)
 .D:SUBIEN GETMSGB^HLOMSG1(.MSG,SUBIEN,.MSG)
"RTN","HLOUSR2",57,0)
 .I MSG("ACK BY")]"",($$FINDMSG^HLOMSG1(MSG("ACK BY"),.LIST)=1) D
"RTN","HLOUSR2",58,0)
 ..N MSG,SEG,FS
"RTN","HLOUSR2",59,0)
 ..S IEN=+LIST(1),SUBIEN=$P(LIST(1),"^",2)
"RTN","HLOUSR2",60,0)
 ..Q:'$$GETMSG^HLOMSG(IEN,.MSG)
"RTN","HLOUSR2",61,0)
 ..I SUBIEN S MSG("BATCH","CURRENT MESSAGE")=SUBIEN,MSG("LINE COUNT")=0
"RTN","HLOUSR2",62,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  I $E(SEG(1),1,3)="MSA" S MSA=SEG(1),FS=$E(MSA,4),ERRTEXT=$P(MSA,FS,4) Q
"RTN","HLOUSR2",63,0)
 .S:ERRTEXT="" ERRTEXT=MSG("STATUS","ERROR TEXT")
"RTN","HLOUSR2",64,0)
 .S @VALMAR@($$I,0)="  "_$$LJ(MSG("ID"),15)_$$LJ(MSG("MESSAGE TYPE")_"~"_MSG("EVENT"),8)_$$LJ($$FMTE^XLFDT(MSG("DT/TM CREATED"),2),20)_$E(ERRTEXT,1,37)
"RTN","HLOUSR2",65,0)
 .D CNTRL^VALM10(VALMCNT,3,15,IOINHI,IOINORM)
"RTN","HLOUSR2",66,0)
 .I $L(ERRTEXT)>37 D
"RTN","HLOUSR2",67,0)
 ..S @VALMAR@($$I,0)="~"_$E(ERRTEXT,38,112)
"RTN","HLOUSR2",68,0)
 ..D CNTRL^VALM10(VALMCNT,1,1,IORVON,IORVOFF)
"RTN","HLOUSR2",69,0)
 .S:MSG("ID")]"" @VALMAR@("INDEX",MSG("ID"))=IEN
"RTN","HLOUSR2",70,0)
 Q
"RTN","HLOUSR2",71,0)
 ;
"RTN","HLOUSR2",72,0)
ASKPARMS(PARMS) ;
"RTN","HLOUSR2",73,0)
 K PARMS
"RTN","HLOUSR2",74,0)
 S PARMS("START")=$$ASKBEGIN("T-1")
"RTN","HLOUSR2",75,0)
 I 'PARMS("START") Q 0
"RTN","HLOUSR2",76,0)
 S PARMS("ALL")=$$ASKYESNO("Include ALL applications","YES")
"RTN","HLOUSR2",77,0)
 I PARMS("ALL") Q 1
"RTN","HLOUSR2",78,0)
 I PARMS("ALL")="" Q 0
"RTN","HLOUSR2",79,0)
 S PARMS("APP")=$$ASKAPP
"RTN","HLOUSR2",80,0)
 I PARMS("APP")="" Q 0
"RTN","HLOUSR2",81,0)
 Q 1
"RTN","HLOUSR2",82,0)
 ;
"RTN","HLOUSR2",83,0)
ASKAPP() ;
"RTN","HLOUSR2",84,0)
 D FULL^VALM1
"RTN","HLOUSR2",85,0)
 S VALMBCK="R"
"RTN","HLOUSR2",86,0)
 N DIR
"RTN","HLOUSR2",87,0)
 S DIR(0)="F^3:60"
"RTN","HLOUSR2",88,0)
 S DIR("A")="Application"
"RTN","HLOUSR2",89,0)
 S DIR("?")="Enter the full name of the application, or '^' to exit."
"RTN","HLOUSR2",90,0)
 S DIR("?",1)="For transmission failures, enter the sending application. "
"RTN","HLOUSR2",91,0)
 S DIR("?",2)="For other errors, enter the name of the receiving application. "
"RTN","HLOUSR2",92,0)
 D ^DIR
"RTN","HLOUSR2",93,0)
 I $D(DIRUT)!(Y="") Q ""
"RTN","HLOUSR2",94,0)
 Q Y
"RTN","HLOUSR2",95,0)
 ;
"RTN","HLOUSR2",96,0)
ASKYESNO(PROMPT,DEFAULT) ;
"RTN","HLOUSR2",97,0)
 ;Description: Displays PROMPT, appending '?'.  Expects a YES NO response
"RTN","HLOUSR2",98,0)
 ;Input:
"RTN","HLOUSR2",99,0)
 ;   PROMPT - text to display as prompt.  Appends '?'
"RTN","HLOUSR2",100,0)
 ;   DEFAULT - (optional) YES or NO.  If not passed, defaults to YES
"RTN","HLOUSR2",101,0)
 ;Output:
"RTN","HLOUSR2",102,0)
 ;  Function value: 1 if yes, 0 if no, "" if '^' entered or timeout
"RTN","HLOUSR2",103,0)
 ;
"RTN","HLOUSR2",104,0)
 N DIR,Y
"RTN","HLOUSR2",105,0)
 S DIR(0)="Y"
"RTN","HLOUSR2",106,0)
 S DIR("A")=PROMPT
"RTN","HLOUSR2",107,0)
 S DIR("B")=$S($G(DEFAULT)="NO":"NO",1:"YES")
"RTN","HLOUSR2",108,0)
 D ^DIR
"RTN","HLOUSR2",109,0)
 Q:$D(DIRUT) ""
"RTN","HLOUSR2",110,0)
 Q Y
"RTN","HLOUSR2",111,0)
 ;
"RTN","HLOUSR2",112,0)
STRTSTPQ ;
"RTN","HLOUSR2",113,0)
 ;action to start or stop a queue, either incoming or outgoing
"RTN","HLOUSR2",114,0)
 ;
"RTN","HLOUSR2",115,0)
 N STOP,INOROUT,QUE
"RTN","HLOUSR2",116,0)
 S VALMBCK="R"
"RTN","HLOUSR2",117,0)
 D FULL^VALM1
"RTN","HLOUSR2",118,0)
 ;ask if stop or start
"RTN","HLOUSR2",119,0)
 D  Q:STOP=""
"RTN","HLOUSR2",120,0)
 .N DIR
"RTN","HLOUSR2",121,0)
 .S DIR(0)="S^1:START;2:STOP"
"RTN","HLOUSR2",122,0)
 .S DIR("A")="Do you want to START or STOP a queue"
"RTN","HLOUSR2",123,0)
 .S DIR("B")="1"
"RTN","HLOUSR2",124,0)
 .D ^DIR
"RTN","HLOUSR2",125,0)
 .S STOP=$S(Y=1:0,Y=2:1,1:"")
"RTN","HLOUSR2",126,0)
 ;ask if in or out
"RTN","HLOUSR2",127,0)
 D  Q:INOROUT=""
"RTN","HLOUSR2",128,0)
 .N DIR
"RTN","HLOUSR2",129,0)
 .S DIR(0)="S^I:INCOMING;O:OUTGOING"
"RTN","HLOUSR2",130,0)
 .S DIR("A")="Do you want to "_$S(STOP:"stop",1:"start")_" an incoming queue or an outgoing queue"
"RTN","HLOUSR2",131,0)
 .S DIR("B")="I"
"RTN","HLOUSR2",132,0)
 .D ^DIR
"RTN","HLOUSR2",133,0)
 .S INOROUT=$S(Y="I":"IN",Y="O":"OUT",1:"")
"RTN","HLOUSR2",134,0)
 S QUE=$$ASKQUE(INOROUT)
"RTN","HLOUSR2",135,0)
 Q:QUE=""
"RTN","HLOUSR2",136,0)
 I STOP=$$STOPPED^HLOQUE(INOROUT,QUE) D
"RTN","HLOUSR2",137,0)
 .N C
"RTN","HLOUSR2",138,0)
 .I STOP D
"RTN","HLOUSR2",139,0)
 ..W !,"That queue is already stopped!"
"RTN","HLOUSR2",140,0)
 .E  W !,"That queue is not stopped!"
"RTN","HLOUSR2",141,0)
 .W !,IOINHI,"Hit any key to continue...",IOINORM
"RTN","HLOUSR2",142,0)
 .R *C:DTIME
"RTN","HLOUSR2",143,0)
 E  D
"RTN","HLOUSR2",144,0)
 .N C
"RTN","HLOUSR2",145,0)
 .D:STOP STOPQUE^HLOQUE(INOROUT,QUE)
"RTN","HLOUSR2",146,0)
 .D:'STOP STARTQUE^HLOQUE(INOROUT,QUE)
"RTN","HLOUSR2",147,0)
 .W !,"DONE!"
"RTN","HLOUSR2",148,0)
 .W !,IOINHI,"Hit any key to continue...",IOINORM
"RTN","HLOUSR2",149,0)
 .R *C:DTIME
"RTN","HLOUSR2",150,0)
 .D @HLRFRSH
"RTN","HLOUSR2",151,0)
 Q
"RTN","HLOUSR2",152,0)
 ;
"RTN","HLOUSR2",153,0)
ASKQUE(DIR) ;
"RTN","HLOUSR2",154,0)
 N QUEUE
"RTN","HLOUSR2",155,0)
AGAIN W !,"Enter the full, exact name of queue:"
"RTN","HLOUSR2",156,0)
 S QUEUE=""
"RTN","HLOUSR2",157,0)
 R QUEUE:60 I '$T Q ""
"RTN","HLOUSR2",158,0)
 I $E(QUEUE)="?" W !,"Each message is placed on a queue that has an arbitrary name up to 20",!,"characters long." I $$ASKYESNO("Would you like to see a list of the queues that currently exist","NO") D  G AGAIN
"RTN","HLOUSR2",159,0)
 .N SUB,QUE,QUIT,COUNT
"RTN","HLOUSR2",160,0)
 .K ^TMP($J,"HLO QUEUES")
"RTN","HLOUSR2",161,0)
 .S SUB=""
"RTN","HLOUSR2",162,0)
 .F  S SUB=$O(^HLB("QUEUE",DIR,SUB)) Q:SUB=""  D
"RTN","HLOUSR2",163,0)
 ..S QUE=""
"RTN","HLOUSR2",164,0)
 ..F  S QUE=$O(^HLB("QUEUE",DIR,SUB,QUE)) Q:QUE=""  S ^TMP($J,"HLO QUEUES",QUE)=""
"RTN","HLOUSR2",165,0)
 .S QUE=""
"RTN","HLOUSR2",166,0)
 .S IOSL=$G(IOSL,20)
"RTN","HLOUSR2",167,0)
 .S (COUNT,QUIT)=0
"RTN","HLOUSR2",168,0)
 .W !
"RTN","HLOUSR2",169,0)
 .F  S QUE=$O(^TMP($J,"HLO QUEUES",QUE)) Q:QUE=""  Q:QUIT  D
"RTN","HLOUSR2",170,0)
 ..W !,QUE
"RTN","HLOUSR2",171,0)
 ..S COUNT=COUNT+1
"RTN","HLOUSR2",172,0)
 ..I COUNT>(IOSL-3) D
"RTN","HLOUSR2",173,0)
 ...N Y
"RTN","HLOUSR2",174,0)
 ...D PAUSE^VALM1
"RTN","HLOUSR2",175,0)
 ...I 'Y S QUIT=1
"RTN","HLOUSR2",176,0)
 ...S COUNT=0
"RTN","HLOUSR2",177,0)
 .W !
"RTN","HLOUSR2",178,0)
 .K ^TMP($J,"HLO QUEUES")
"RTN","HLOUSR2",179,0)
 Q:$E(QUEUE)="?" ""
"RTN","HLOUSR2",180,0)
 Q:$E(QUEUE)="^" ""
"RTN","HLOUSR2",181,0)
 Q QUEUE
"RTN","HLOUSR2",182,0)
 ;
"RTN","HLOUSR2",183,0)
ASKBEGIN(DEFAULT) ;
"RTN","HLOUSR2",184,0)
 ;Description: Asks the user to enter a beginning date.
"RTN","HLOUSR2",185,0)
 ;Input: DEFAULT - the suggested default dt/time (optional)
"RTN","HLOUSR2",186,0)
 ;Output: Returns the date as the function value, or 0 if the user does not select a date
"RTN","HLOUSR2",187,0)
 ;
"RTN","HLOUSR2",188,0)
 ;
"RTN","HLOUSR2",189,0)
 N %DT
"RTN","HLOUSR2",190,0)
 S %DT="AEST"
"RTN","HLOUSR2",191,0)
 S %DT("A")="Enter the beginning date/time: "
"RTN","HLOUSR2",192,0)
 S %DT("B")=$$FMTE^XLFDT($S($L($G(DEFAULT)):DEFAULT,1:$$FMADD^XLFDT(DT,-1)))
"RTN","HLOUSR2",193,0)
 S %DT(0)="-NOW"
"RTN","HLOUSR2",194,0)
 Q:$D(DTOUT) 0
"RTN","HLOUSR2",195,0)
 D ^%DT
"RTN","HLOUSR2",196,0)
 I Y=-1 Q 0
"RTN","HLOUSR2",197,0)
 Q Y
"RTN","HLOUSR2",198,0)
 ;
"RTN","HLOUSR2",199,0)
ASKEND(BEGIN) ;
"RTN","HLOUSR2",200,0)
 ;Description: Asks the user to enter an ending date/time
"RTN","HLOUSR2",201,0)
 ;Input: BEGIN - the earliest date/time allowed
"RTN","HLOUSR2",202,0)
 ;Output: Returns the date as the function value, or 0 if the user does not select a date/time
"RTN","HLOUSR2",203,0)
 ;
"RTN","HLOUSR2",204,0)
 N %DT
"RTN","HLOUSR2",205,0)
 S %DT="AEST"
"RTN","HLOUSR2",206,0)
 S %DT("A")="Enter the ending date/time: "
"RTN","HLOUSR2",207,0)
 S %DT("B")="NOW"
"RTN","HLOUSR2",208,0)
 S %DT(0)=BEGIN
"RTN","HLOUSR2",209,0)
 Q:$D(DTOUT) 0
"RTN","HLOUSR2",210,0)
 D ^%DT
"RTN","HLOUSR2",211,0)
 I Y=-1 Q 0
"RTN","HLOUSR2",212,0)
 Q Y
"RTN","HLOUSR2",213,0)
 ;
"RTN","HLOUSR2",214,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR2",215,0)
 Q $$LJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR2",216,0)
 ;
"RTN","HLOUSR2",217,0)
I() ;
"RTN","HLOUSR2",218,0)
 S VALMCNT=VALMCNT+1
"RTN","HLOUSR2",219,0)
 Q VALMCNT
"RTN","HLOUSR2",220,0)
 ;
"RTN","HLOUSR2",221,0)
HEADER ;
"RTN","HLOUSR2",222,0)
 Q
"RTN","HLOUSR3")
0^45^B18658983
"RTN","HLOUSR3",1,0)
HLOUSR3 ;ALB/CJM -ListManager Screen for viewing messages(continued);12 JUN 1997 10:00 am
"RTN","HLOUSR3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126**;Oct 13, 1995
"RTN","HLOUSR3",3,0)
 ;
"RTN","HLOUSR3",4,0)
 ;
"RTN","HLOUSR3",5,0)
EN ;
"RTN","HLOUSR3",6,0)
 N HLPARMS
"RTN","HLOUSR3",7,0)
 D FULL^VALM1
"RTN","HLOUSR3",8,0)
 I '$$ASK(.HLPARMS) S VALMBCK="R" Q
"RTN","HLOUSR3",9,0)
 D WAIT^DICD
"RTN","HLOUSR3",10,0)
 D EN^VALM("HLO MESSAGE SEARCH")
"RTN","HLOUSR3",11,0)
 Q
"RTN","HLOUSR3",12,0)
SEARCH ;
"RTN","HLOUSR3",13,0)
 N I,APP,START,END,DIR,MSG,EVENT,TIME
"RTN","HLOUSR3",14,0)
 D EXIT
"RTN","HLOUSR3",15,0)
 S I=""
"RTN","HLOUSR3",16,0)
 F  S I=$O(HLPARMS(I)) Q:I=""  S @I=HLPARMS(I)
"RTN","HLOUSR3",17,0)
 K HLPARMS
"RTN","HLOUSR3",18,0)
 S (VALMCNT,I)=0
"RTN","HLOUSR3",19,0)
 S TIME=START
"RTN","HLOUSR3",20,0)
 F  S TIME=$O(^HLB("SEARCH",DIR,TIME)) Q:'TIME  Q:TIME>END  Q:VALMCNT>600  D
"RTN","HLOUSR3",21,0)
 .N SAPP S SAPP=""
"RTN","HLOUSR3",22,0)
 .S:APP'="" SAPP=$O(^HLB("SEARCH",DIR,TIME,APP),-1)
"RTN","HLOUSR3",23,0)
 .F  S SAPP=$O(^HLB("SEARCH",DIR,TIME,SAPP)) Q:SAPP=""  Q:$E(SAPP,1,$L(APP))]APP  Q:VALMCNT>600  D:$E(SAPP,1,$L(APP))=APP
"RTN","HLOUSR3",24,0)
 ..N SMSG S SMSG=""
"RTN","HLOUSR3",25,0)
 ..S:MSG'="" SMSG=$O(^HLB("SEARCH",DIR,TIME,SAPP,MSG),-1)
"RTN","HLOUSR3",26,0)
 ..F  S SMSG=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG)) Q:SMSG=""  Q:$E(SMSG,1,$L(MSG))]MSG  Q:VALMCNT>600  D:$E(SMSG,1,$L(MSG))=MSG
"RTN","HLOUSR3",27,0)
 ...N SEVENT S SEVENT=""
"RTN","HLOUSR3",28,0)
 ...S:EVENT'="" SEVENT=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,EVENT),-1)
"RTN","HLOUSR3",29,0)
 ...F  S SEVENT=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,SEVENT)) Q:SEVENT=""  Q:$E(SEVENT,1,$L(EVENT))]EVENT  Q:VALMCNT>600  D:$E(SEVENT,1,$L(EVENT))=EVENT
"RTN","HLOUSR3",30,0)
 ....N IEN
"RTN","HLOUSR3",31,0)
 ....S IEN=""
"RTN","HLOUSR3",32,0)
 ....F  S IEN=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,SEVENT,IEN)) Q:IEN=""  Q:VALMCNT>600  D ADDTO(DIR,TIME,SAPP,SMSG,SEVENT,IEN)
"RTN","HLOUSR3",33,0)
 ;
"RTN","HLOUSR3",34,0)
 ;
"RTN","HLOUSR3",35,0)
END S VALMBCK="R"
"RTN","HLOUSR3",36,0)
 ;
"RTN","HLOUSR3",37,0)
 Q
"RTN","HLOUSR3",38,0)
ADDTO(DIR,TIME,APP,MSG,EVENT,IEN) ;
"RTN","HLOUSR3",39,0)
 N HDR,FS,LOC,MSGID
"RTN","HLOUSR3",40,0)
 S MSGID=$S($P(IEN,"^",2):$P($G(^HLB(+IEN,3,$P(IEN,"^",2),0)),"^",2),1:$P($G(^HLB(IEN,0)),"^",1))
"RTN","HLOUSR3",41,0)
 S HDR=$G(^HLB(+IEN,1))
"RTN","HLOUSR3",42,0)
 S FS=$E(HDR,4)
"RTN","HLOUSR3",43,0)
 I FS'="" D
"RTN","HLOUSR3",44,0)
 .I DIR="IN" S LOC=$P(HDR,FS,4)
"RTN","HLOUSR3",45,0)
 .I DIR'="IN" S LOC=$P(HDR,FS,6)
"RTN","HLOUSR3",46,0)
 E  S LOC=""
"RTN","HLOUSR3",47,0)
 S @VALMAR@($$I,0)=$$LJ(MSGID,25)_$$LJ(APP,30)_" "_MSG_"~"_EVENT
"RTN","HLOUSR3",48,0)
 D CNTRL^VALM10(VALMCNT,1,25,IOINHI,IOINORM)
"RTN","HLOUSR3",49,0)
 S @VALMAR@($$I,0)="     "_$$LJ($$FMTE^XLFDT(TIME,2),20)_$$LJ(LOC,60)
"RTN","HLOUSR3",50,0)
 S @VALMAR@($$I,0)=""
"RTN","HLOUSR3",51,0)
 Q
"RTN","HLOUSR3",52,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR3",53,0)
 Q $$LJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR3",54,0)
 ;
"RTN","HLOUSR3",55,0)
I() ;
"RTN","HLOUSR3",56,0)
 S VALMCNT=VALMCNT+1
"RTN","HLOUSR3",57,0)
 Q VALMCNT
"RTN","HLOUSR3",58,0)
 ;
"RTN","HLOUSR3",59,0)
ASK(PARMS) ;
"RTN","HLOUSR3",60,0)
 N SUB
"RTN","HLOUSR3",61,0)
 F SUB="START","END","EVENT","APP","MSG","DIR" S PARMS(SUB)=""
"RTN","HLOUSR3",62,0)
 S PARMS("START")=$$ASKBEGIN^HLOUSR2()
"RTN","HLOUSR3",63,0)
 Q:'PARMS("START") 0
"RTN","HLOUSR3",64,0)
 S PARMS("END")=$$ASKEND^HLOUSR2(PARMS("START"))
"RTN","HLOUSR3",65,0)
 Q:'PARMS("END") 0
"RTN","HLOUSR3",66,0)
 S PARMS("APP")=$$ASKAPP()
"RTN","HLOUSR3",67,0)
 Q:PARMS("APP")=-1 0
"RTN","HLOUSR3",68,0)
 S PARMS("MSG")=$$ASKMSG()
"RTN","HLOUSR3",69,0)
 Q:PARMS("MSG")=-1 0
"RTN","HLOUSR3",70,0)
 S PARMS("EVENT")=$$ASKEVENT()
"RTN","HLOUSR3",71,0)
 Q:PARMS("EVENT")=-1 0
"RTN","HLOUSR3",72,0)
 S PARMS("DIR")=$$ASKDIR()
"RTN","HLOUSR3",73,0)
 Q:PARMS("DIR")=-1 0
"RTN","HLOUSR3",74,0)
 S PARMS("DIR")=$S(PARMS("DIR")="I":"IN",1:"OUT")
"RTN","HLOUSR3",75,0)
 Q 1
"RTN","HLOUSR3",76,0)
 ;
"RTN","HLOUSR3",77,0)
ASKAPP() ;
"RTN","HLOUSR3",78,0)
 N DIR
"RTN","HLOUSR3",79,0)
 S DIR(0)="FO^0:60"
"RTN","HLOUSR3",80,0)
 S DIR("A")="Application"
"RTN","HLOUSR3",81,0)
 S DIR("?",1)="Enter the name of the application, or '^' to exit."
"RTN","HLOUSR3",82,0)
 S DIR("?")="You can enter just the first part of the name."
"RTN","HLOUSR3",83,0)
 D ^DIR
"RTN","HLOUSR3",84,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",85,0)
 Q X
"RTN","HLOUSR3",86,0)
ASKMSG() ;
"RTN","HLOUSR3",87,0)
 N DIR
"RTN","HLOUSR3",88,0)
 S DIR(0)="FO^0:3"
"RTN","HLOUSR3",89,0)
 S DIR("A")="HL7 Message Type"
"RTN","HLOUSR3",90,0)
 S DIR("?",1)="Enter the 3 character message type (e.g. MFN, ADT), or '^' to exit."
"RTN","HLOUSR3",91,0)
 S DIR("?")="You can enter just the first character or two."
"RTN","HLOUSR3",92,0)
 D ^DIR
"RTN","HLOUSR3",93,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",94,0)
 Q X
"RTN","HLOUSR3",95,0)
ASKEVENT() ;
"RTN","HLOUSR3",96,0)
 N DIR
"RTN","HLOUSR3",97,0)
 S DIR(0)="FO^0:3"
"RTN","HLOUSR3",98,0)
 S DIR("A")="HL7 Event"
"RTN","HLOUSR3",99,0)
 S DIR("?",1)="Enter the 3 character event type, or '^' to exit."
"RTN","HLOUSR3",100,0)
 S DIR("?")="You can enter just the first character or two."
"RTN","HLOUSR3",101,0)
 D ^DIR
"RTN","HLOUSR3",102,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",103,0)
 Q X
"RTN","HLOUSR3",104,0)
ASKDIR() ;
"RTN","HLOUSR3",105,0)
 N DIR
"RTN","HLOUSR3",106,0)
 S DIR(0)="S^I:INCOMING;O:OUTGOING"
"RTN","HLOUSR3",107,0)
 S DIR("A")="Incoming or Outgoing"
"RTN","HLOUSR3",108,0)
 S DIR("?",1)="Are you searching for an incoming message or an outgoing message?"
"RTN","HLOUSR3",109,0)
 S DIR("?")="You can enter '^' to exit"
"RTN","HLOUSR3",110,0)
 D ^DIR
"RTN","HLOUSR3",111,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",112,0)
 Q X
"RTN","HLOUSR3",113,0)
HDR ;
"RTN","HLOUSR3",114,0)
 S VALMHDR(1)="MsgID                    Application                    MsgType"
"RTN","HLOUSR3",115,0)
 Q
"RTN","HLOUSR3",116,0)
HLP ;
"RTN","HLOUSR3",117,0)
 Q
"RTN","HLOUSR3",118,0)
EXIT ;
"RTN","HLOUSR3",119,0)
 D CLEAN^VALM10
"RTN","HLOUSR3",120,0)
 D CLEAR^VALM1
"RTN","HLOUSR3",121,0)
 S VALMBCK="R"
"RTN","HLOUSR3",122,0)
 Q
"SEC","^DIC",779.4,779.4,0,"AUDIT")
@
"SEC","^DIC",779.4,779.4,0,"DD")
@
"SEC","^DIC",779.4,779.4,0,"DEL")
@
"SEC","^DIC",779.4,779.4,0,"LAYGO")
@
"SEC","^DIC",779.4,779.4,0,"RD")
@
"SEC","^DIC",779.4,779.4,0,"WR")
@
"VER")
8.0^22.0
"^DD",777,777,0)
FIELD^^3^9
"^DD",777,777,0,"DDA")
N
"^DD",777,777,0,"DT")
3040813
"^DD",777,777,0,"IX","B",777,.01)

"^DD",777,777,0,"NM","HLO MESSAGE BODY")

"^DD",777,777,0,"PT",778,.02)

"^DD",777,777,0,"VRPK")
HL
"^DD",777,777,.01,0)
DATE/TIME ENTERED^RD^^0;1^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",777,777,.01,1,0)
^.1
"^DD",777,777,.01,1,1,0)
777^B
"^DD",777,777,.01,1,1,1)
S ^HLA("B",$E(X,1,30),DA)=""
"^DD",777,777,.01,1,1,2)
K ^HLA("B",$E(X,1,30),DA)
"^DD",777,777,.01,3)
Enter the exact time that this entry was created.
"^DD",777,777,.01,"DT")
3040726
"^DD",777,777,.02,0)
BATCH^S^0:NO;1:YES;^0;2^Q
"^DD",777,777,.02,3)
Enter YES if this is a batch message.
"^DD",777,777,.02,"DT")
3040726
"^DD",777,777,.03,0)
MESSAGE TYPE^F^^0;3^K:$L(X)>3!($L(X)<3) X
"^DD",777,777,.03,3)
Enter the 3 character HL7 message type.
"^DD",777,777,.03,"DT")
3040726
"^DD",777,777,.04,0)
EVENT^F^^0;4^K:$L(X)>3!($L(X)<3) X
"^DD",777,777,.04,3)
Enter the 3 character HL7 event.
"^DD",777,777,.04,"DT")
3040726
"^DD",777,777,.05,0)
HL7 VERSION^RF^^0;5^K:$L(X)>20!($L(X)<1) X
"^DD",777,777,.05,3)
Identify the version of the HL7 standard that this message conforms to.
"^DD",777,777,.05,"DT")
3040726
"^DD",777,777,.2,0)
HL7 ENCODING CHARACTERS^RF^^0;20^K:$L(X)>5!($L(X)<5) X
"^DD",777,777,.2,3)
The 5 HL7 encoding characters in this order: Field Separator, Component Separator, Repetition Separator, Escape Character, Subcomponent Separator
"^DD",777,777,.2,23,0)
^^1^1^3040726^
"^DD",777,777,.2,23,1,0)
No other fields may follow this one on the 0 node!
"^DD",777,777,.2,"DT")
3050317
"^DD",777,777,1,0)
SEGMENTS (NOT BATCHED)^777.01A^^1;0
"^DD",777,777,2,0)
BATCHED MESSAGES^777.02A^^2;0
"^DD",777,777,3,0)
BTS^F^^3;1^K:$L(X)>250!($L(X)<1) X
"^DD",777,777,3,3)
Answer must be 1-250 characters in length.
"^DD",777,777,3,21,0)
^^2^2^3041116^^
"^DD",777,777,3,21,1,0)
For incoming batch messages only, the BTS segment is stored in this field,
"^DD",777,777,3,21,2,0)
which is a separate node.
"^DD",777,777,3,"DT")
3041116
"^DD",777,777.01,0)
SEGMENTS (NOT BATCHED) SUB-FIELD^^.01^1
"^DD",777,777.01,0,"DT")
3040726
"^DD",777,777.01,0,"IX","B",777.01,.01)

"^DD",777,777.01,0,"NM","SEGMENTS (NOT BATCHED)")

"^DD",777,777.01,0,"UP")
777
"^DD",777,777.01,.01,0)
SEGMENTS^WL^^0;1^K:$L(X)>250!($L(X)<1) X
"^DD",777,777.01,.01,1,0)
^.1
"^DD",777,777.01,.01,1,1,0)
777.01^B
"^DD",777,777.01,.01,1,1,1)
S ^HLA(DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",777,777.01,.01,1,1,2)
K ^HLA(DA(1),1,"B",$E(X,1,30),DA)
"^DD",777,777.01,.01,3)
Segments should be separated with an empty line.
"^DD",777,777.01,.01,"DT")
3040726
"^DD",777,777.02,0)
BATCHED MESSAGES SUB-FIELD^^1^4
"^DD",777,777.02,0,"DT")
3040726
"^DD",777,777.02,0,"IX","B",777.02,.01)

"^DD",777,777.02,0,"NM","BATCHED MESSAGES")

"^DD",777,777.02,0,"UP")
777
"^DD",777,777.02,.01,0)
MESSAGE^NJ6,0^^0;1^K:+X'=X!(X>999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",777,777.02,.01,1,0)
^.1
"^DD",777,777.02,.01,1,1,0)
777.02^B
"^DD",777,777.02,.01,1,1,1)
S ^HLA(DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",777,777.02,.01,1,1,2)
K ^HLA(DA(1),2,"B",$E(X,1,30),DA)
"^DD",777,777.02,.01,3)
Enter a number to identify the sequence of this message within the batch, starting with 1, 2, 3, etc.
"^DD",777,777.02,.01,"DT")
3040726
"^DD",777,777.02,.02,0)
MESSAGE TYPE^RF^^0;2^K:$L(X)>3!($L(X)<3) X
"^DD",777,777.02,.02,3)
Enter the 3 character HL7 message type.
"^DD",777,777.02,.02,"DT")
3040726
"^DD",777,777.02,.03,0)
EVENT^RF^^0;3^K:$L(X)>3!($L(X)<3) X
"^DD",777,777.02,.03,3)
Enter the 3 character HL7 event type.
"^DD",777,777.02,.03,"DT")
3040726
"^DD",777,777.02,1,0)
MESSAGE SEGMENTS^777.21A^^1;0
"^DD",777,777.21,0)
MESSAGE SEGMENTS SUB-FIELD^^.01^1
"^DD",777,777.21,0,"DT")
3040726
"^DD",777,777.21,0,"IX","B",777.21,.01)

"^DD",777,777.21,0,"NM","MESSAGE SEGMENTS")

"^DD",777,777.21,0,"UP")
777.02
"^DD",777,777.21,.01,0)
SEGMENTS (BATCH)^WL^^0;E1,250^K:$L(X)>250!($L(X)<1) X
"^DD",777,777.21,.01,1,0)
^.1
"^DD",777,777.21,.01,1,1,0)
777.21^B
"^DD",777,777.21,.01,1,1,1)
S ^HLA(DA(2),2,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",777,777.21,.01,1,1,2)
K ^HLA(DA(2),2,DA(1),1,"B",$E(X,1,30),DA)
"^DD",777,777.21,.01,3)
Enter each segment as a sequence of lines, with each segment separated by a blank line.
"^DD",777,777.21,.01,"DT")
3040812
"^DD",778,778,0)
FIELD^^4.03^27
"^DD",778,778,0,"DDA")
N
"^DD",778,778,0,"DT")
3050504
"^DD",778,778,0,"IX","AC",778,.01)

"^DD",778,778,0,"IX","AD",778,.09)

"^DD",778,778,0,"IX","AE",778.03,.02)

"^DD",778,778,0,"IX","B",778,.01)

"^DD",778,778,0,"IX","C",778,.02)

"^DD",778,778,0,"NM","HLO MESSAGES")

"^DD",778,778,0,"VRPK")
HL
"^DD",778,778,.01,0)
MESSAGE ID^RF^^0;1^K:$L(X)>20!($L(X)<3) X
"^DD",778,778,.01,1,0)
^.1
"^DD",778,778,.01,1,1,0)
778^B
"^DD",778,778,.01,1,1,1)
S ^HLB("B",$E(X,1,30),DA)=""
"^DD",778,778,.01,1,1,2)
K ^HLB("B",$E(X,1,30),DA)
"^DD",778,778,.01,1,2,0)
778^AC^MUMPS
"^DD",778,778,.01,1,2,1)
Q
"^DD",778,778,.01,1,2,2)
Q
"^DD",778,778,.01,1,2,"%D",0)
^.101^3^3^3041116^^
"^DD",778,778,.01,1,2,"%D",1,0)
This x-ref is maintained by the HL7 package.  It is used to detect if an
"^DD",778,778,.01,1,2,"%D",2,0)
incoming message is a duplicate.  The format is:
"^DD",778,778,.01,1,2,"%D",3,0)
^HLB("AC"sending facility>_<sending application>_<msg id>,ien)=0
"^DD",778,778,.01,1,2,"DT")
3040812
"^DD",778,778,.01,3)
Answer must be 3-20 characters in length
"^DD",778,778,.01,"DT")
3050504
"^DD",778,778,.02,0)
MESSAGE BODY^RP777'^HLA(^0;2^Q
"^DD",778,778,.02,1,0)
^.1
"^DD",778,778,.02,1,1,0)
778^C^MUMPS
"^DD",778,778,.02,1,1,1)
S ^HLB("C",X,DA)=""
"^DD",778,778,.02,1,1,2)
K ^HLB("C",X,DA)
"^DD",778,778,.02,1,1,"%D",0)
^.101^2^2^3050317^^
"^DD",778,778,.02,1,1,"%D",1,0)
Used to find all the messages that point to the same entry in file 777. Only
"^DD",778,778,.02,1,1,"%D",2,0)
set for outgoing messages.
"^DD",778,778,.02,1,1,"DT")
3040815
"^DD",778,778,.02,3)
Which record in file #777 contains the body of the message?
"^DD",778,778,.02,"DT")
3050317
"^DD",778,778,.03,0)
APPLICATION ACKNOWLEDGMENT TO^F^^0;3^K:$L(X)>30!($L(X)<3) X
"^DD",778,778,.03,3)
Enter the Message Control ID of the message to which this one is an acknowledgment.
"^DD",778,778,.03,21,0)
^^2^2^3050317^^
"^DD",778,778,.03,21,1,0)
This is the Message Control ID of the original message to which this message
"^DD",778,778,.03,21,2,0)
is an application acknowledgment.
"^DD",778,778,.03,"DT")
3050317
"^DD",778,778,.04,0)
DIRECTION^RS^I:INCOMING;O:OUTGOING;^0;4^Q
"^DD",778,778,.04,3)
Is the message INCOMING or OUTGOING?
"^DD",778,778,.04,"DT")
3041116
"^DD",778,778,.05,0)
LINK^RF^^0;5^K:$L(X)>10!($L(X)<3) X
"^DD",778,778,.05,3)
Enter the name of the logical link over which the message is being transmitted.
"^DD",778,778,.05,"DT")
3041116
"^DD",778,778,.06,0)
QUEUE^F^^0;6^K:$L(X)>20!($L(X)<3) X
"^DD",778,778,.06,3)
Is the queue on which this message was placed.
"^DD",778,778,.06,"DT")
3040729
"^DD",778,778,.07,0)
APPLICATION ACKNOWLEDGMENT BY^F^^0;7^K:$L(X)>30!($L(X)<3) X
"^DD",778,778,.07,3)
If this message has received an application response then enter the responses Message Control ID.
"^DD",778,778,.07,"DT")
3040930
"^DD",778,778,.08,0)
REMOTE PORT^NJ5,0^^0;8^K:+X'=X!(X>65535)!(X<1)!(X?.E1"."1.N) X
"^DD",778,778,.08,3)
Enter the remote port indicated in the Facility field of the message header.
"^DD",778,778,.08,21,0)
^^4^4^3050504^^
"^DD",778,778,.08,21,1,0)
This is the remote port # that may be found in the message header. For outgoing
"^DD",778,778,.08,21,2,0)
messages, it is in the Receiving Facility field, for incoming messages it is
"^DD",778,778,.08,21,3,0)
in tthe Sending Facility. For application acknowledgments, the port provided in
"^DD",778,778,.08,21,4,0)
the original message is used to return the acknowledgment. 
"^DD",778,778,.08,"DT")
3050504
"^DD",778,778,.09,0)
SCHEDULED PURGE DATE/TIME^D^^0;9^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",778,778,.09,1,0)
^.1
"^DD",778,778,.09,1,1,0)
778^AD^MUMPS
"^DD",778,778,.09,1,1,1)
Q
"^DD",778,778,.09,1,1,2)
Q
"^DD",778,778,.09,1,1,3)
DO NOT DELETE!
"^DD",778,778,.09,1,1,"%D",0)
^.101^4^4^3040828^^
"^DD",778,778,.09,1,1,"%D",1,0)
This cross-reference will be used to control the purging process.  It will
"^DD",778,778,.09,1,1,"%D",2,0)
be maintained within the HL7 package and will not be set via Fileman.
"^DD",778,778,.09,1,1,"%D",3,0)
The format is:
"^DD",778,778,.09,1,1,"%D",4,0)
^HLB("AD",<"IN" or "OUT">,<dt/tm for purging>,<message ien>)="
"^DD",778,778,.09,1,1,"DT")
3040819
"^DD",778,778,.09,3)
When can this message be purged?
"^DD",778,778,.09,"DT")
3040819
"^DD",778,778,.1,0)
APPLICATION ACK RSPNS TAG^F^^0;10^K:$L(X)>8!($L(X)<1) X
"^DD",778,778,.1,3)
Answer must be 1-8 characters in length.
"^DD",778,778,.1,21,0)
^^4^4^3040727^
"^DD",778,778,.1,21,1,0)
The sending application routine to execute when the application ack is received.
"^DD",778,778,.1,21,2,0)

"^DD",778,778,.1,21,3,0)
This is part one of a two-part field which is the entry point.  The second part
"^DD",778,778,.1,21,4,0)
names the routine.  
"^DD",778,778,.1,"DT")
3040727
"^DD",778,778,.11,0)
APPLICATION ACK RSPNS RTN^F^^0;11^K:$L(X)>8!($L(X)<1) X
"^DD",778,778,.11,3)
Answer must be 1-8 characters in length.
"^DD",778,778,.11,21,0)
^^7^7^3040727^
"^DD",778,778,.11,21,1,0)
Answer must be 1-8 characters in length. 
"^DD",778,778,.11,21,2,0)
The sending application routine to execute when
"^DD",778,778,.11,21,3,0)
the application ack is received.  
"^DD",778,778,.11,21,4,0)
 
"^DD",778,778,.11,21,5,0)
This is part two of a two-part field which is
"^DD",778,778,.11,21,6,0)
the routine name.  The first part names the
"^DD",778,778,.11,21,7,0)
entry point.  
"^DD",778,778,.11,"DT")
3040727
"^DD",778,778,.12,0)
ACCEPT ACK RSPNS TAG^F^^0;12^K:$L(X)>8!($L(X)<1) X
"^DD",778,778,.12,3)
Answer must be 1-8 characters in length.
"^DD",778,778,.12,21,0)
^.001^7^7^3041116^^^
"^DD",778,778,.12,21,1,0)
The sending application's routine to execute when the transmission of the
"^DD",778,778,.12,21,2,0)
message fails, i.e., the message cannot be sent or no acceptack is received.  
"^DD",778,778,.12,21,3,0)
 
"^DD",778,778,.12,21,4,0)
This is part one of a two-part field, naming the entry point of the routine to
"^DD",778,778,.12,21,5,0)
be called.  The second part names the routine.  
"^DD",778,778,.12,21,6,0)
  
"^DD",778,778,.12,21,7,0)
  
"^DD",778,778,.12,"DT")
3041116
"^DD",778,778,.13,0)
ACCEPT ACK RESPNS RTN^F^^0;13^K:$L(X)>8!($L(X)<1) X
"^DD",778,778,.13,3)
Answer must be 1-8 characters in length.
"^DD",778,778,.13,21,0)
^.001^6^6^3041116^^^^
"^DD",778,778,.13,21,1,0)
The sending application routine to execute whe the commit ack is received.     
"^DD",778,778,.13,21,2,0)
 
"^DD",778,778,.13,21,3,0)
This is part two of a two-part field, consisting of the routine name. The first
"^DD",778,778,.13,21,4,0)
part names the entry point with the M routine.
"^DD",778,778,.13,21,5,0)
  
"^DD",778,778,.13,21,6,0)
  
"^DD",778,778,.13,"DT")
3041116
"^DD",778,778,.14,0)
TRANSMISSION FAILURE RSPNS TAG^F^^0;14^K:$L(X)>8!($L(X)<1) X
"^DD",778,778,.14,3)
Answer must be 1-8 characters in length.
"^DD",778,778,.14,21,0)
^^8^8^3040727^
"^DD",778,778,.14,21,1,0)
The sending application's routine to execute
"^DD",778,778,.14,21,2,0)
when the transmission of the message fails,
"^DD",778,778,.14,21,3,0)
i.e., the message can not be sent or no commit
"^DD",778,778,.14,21,4,0)
ack is received.  
"^DD",778,778,.14,21,5,0)
 
"^DD",778,778,.14,21,6,0)
This is part one of a two-part field which is
"^DD",778,778,.14,21,7,0)
the entry point.  The second part names the
"^DD",778,778,.14,21,8,0)
routine.  
"^DD",778,778,.14,"DT")
3040727
"^DD",778,778,.15,0)
TRANSMISSION FAILURE RSPNS RTN^F^^0;15^K:$L(X)>8!($L(X)<1) X
"^DD",778,778,.15,3)
Answer must be 1-8 characters in length.
"^DD",778,778,.15,21,0)
^^8^8^3040727^
"^DD",778,778,.15,21,1,0)
The sending application's routine to execute
"^DD",778,778,.15,21,2,0)
when the transmission of the message fails,
"^DD",778,778,.15,21,3,0)
i.e., the message can not be sent or no commit
"^DD",778,778,.15,21,4,0)
ack is received.  
"^DD",778,778,.15,21,5,0)
 
"^DD",778,778,.15,21,6,0)
This is part two of a two-part field which is
"^DD",778,778,.15,21,7,0)
the routine's name.  The first part names the
"^DD",778,778,.15,21,8,0)
entry point.  
"^DD",778,778,.15,"DT")
3040727
"^DD",778,778,.16,0)
TRANSMISSION DATE/TIME^D^^0;16^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",778,778,.16,3)

"^DD",778,778,.16,21,0)
^^1^1^3040728^
"^DD",778,778,.16,21,1,0)
This is the date and time that the message was either received or sent.
"^DD",778,778,.16,"DT")
3040728
"^DD",778,778,.17,0)
ACCEPT ACK'D^S^1:YES;^0;17^Q
"^DD",778,778,.17,3)
Enter 1 if an accept ack was sent or received.
"^DD",778,778,.17,"DT")
3040823
"^DD",778,778,.18,0)
APPLICATION ACK'D^S^1:YES;^0;18^Q
"^DD",778,778,.18,21,0)
^.001^3^3^3041116^^^
"^DD",778,778,.18,21,1,0)
For incoming messages, this flag indicates that an application ack was
"^DD",778,778,.18,21,2,0)
returned.  For outgoing messages, this field indicates that the application
"^DD",778,778,.18,21,3,0)
ack was sent.
"^DD",778,778,.18,"DT")
3041116
"^DD",778,778,.19,0)
APPLICATION HANDOFF^S^1:YES;^0;19^Q
"^DD",778,778,.19,21,0)
^^4^4^3040728^
"^DD",778,778,.19,21,1,0)
This flag indicates that this message was handed to the application.  That
"^DD",778,778,.19,21,2,0)
may be for initial processing, or it may be in response to one of the other
"^DD",778,778,.19,21,3,0)
conditions that an application may register its need to respond, such
"^DD",778,778,.19,21,4,0)
as a failure of the remote system to accept the message.
"^DD",778,778,.19,"DT")
3040728
"^DD",778,778,.2,0)
COMPLETION STATUS^S^SU:SUCCESSFUL;TF:TRANSMISSION FAILURE;SE:RECEIVING SYSTEM DETERMINED ERROR;AE:RECEIVING APPLICATION DETERMINED ERROR;^0;20^Q
"^DD",778,778,.2,3)
Enter the code that indicates the final status of the message.
"^DD",778,778,.2,21,0)
^.001^3^3^3040820^^^^
"^DD",778,778,.2,21,1,0)
This field indicates the final status of the message.
"^DD",778,778,.2,21,2,0)
Any code but SU (SUCCESSFUL) indicates that an error occurred.
"^DD",778,778,.2,21,3,0)
No value indicates that the message has not completed.
"^DD",778,778,.2,"DT")
3040820
"^DD",778,778,.21,0)
ERROR TEXT^F^^0;21^K:$L(X)>30!($L(X)<1) X
"^DD",778,778,.21,3)
Answer must be 1-30 characters in length.
"^DD",778,778,.21,21,0)
^^3^3^3040928^^
"^DD",778,778,.21,21,1,0)
The HL7 package may use this field to document errors that prevent transmission.
"^DD",778,778,.21,21,2,0)
Errors determined by the remote system are contained in the MSA segment of the 
"^DD",778,778,.21,21,3,0)
response message.
"^DD",778,778,.21,"DT")
3040928
"^DD",778,778,1,0)
HDR SEGMENT,COMPONENTS 1-6^RF^^1;E1,250^K:$L(X)>250!($L(X)<8) X
"^DD",778,778,1,3)
The first 6 components of the message header segment.
"^DD",778,778,1,"DT")
3040729
"^DD",778,778,2,0)
HDR SEGMENT,COMPONENTS 7-END^RF^^2;E1,250^K:$L(X)>250!($L(X)<15) X
"^DD",778,778,2,3)
Enter the header segment begining with component 7
"^DD",778,778,2,"DT")
3041116
"^DD",778,778,3,0)
MSH SEGMENTS FOR BATCH^778.03A^^3;0
"^DD",778,778,4.01,0)
DATE/TIME OF ACCEPT ACK^D^^4;1^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",778,778,4.01,3)
Enter the date and time of the ack.
"^DD",778,778,4.01,21,0)
^^1^1^3040928^^
"^DD",778,778,4.01,21,1,0)
This field will be used to record the accept ack.
"^DD",778,778,4.01,"DT")
3040928
"^DD",778,778,4.02,0)
ACCEPT ACK MESSAGE ID^F^^4;2^K:$L(X)>30!($L(X)<1) X
"^DD",778,778,4.02,3)
Answer must be 1-30 characters in length.
"^DD",778,778,4.02,"DT")
3040928
"^DD",778,778,4.03,0)
ACCEPT ACK MSA SEGMENT^F^^4;3^K:$L(X)>210!($L(X)<3) X
"^DD",778,778,4.03,3)
Answer must be 3-210 characters in length.
"^DD",778,778,4.03,"DT")
3040928
"^DD",778,778.03,0)
MSH SEGMENTS FOR BATCH SUB-FIELD^^2^7
"^DD",778,778.03,0,"DT")
3040930
"^DD",778,778.03,0,"IX","B",778.03,.01)

"^DD",778,778.03,0,"NM","MSH SEGMENTS FOR BATCH")

"^DD",778,778.03,0,"UP")
778
"^DD",778,778.03,.01,0)
MESSAGE IN BATCH^NJ5,0^^0;1^K:+X'=X!(X>99999)!(X<1)!(X?.E1"."1N.N) X
"^DD",778,778.03,.01,1,0)
^.1
"^DD",778,778.03,.01,1,1,0)
778.03^B
"^DD",778,778.03,.01,1,1,1)
S ^HLB(DA(1),3,"B",$E(X,1,30),DA)=""
"^DD",778,778.03,.01,1,1,2)
K ^HLB(DA(1),3,"B",$E(X,1,30),DA)
"^DD",778,778.03,.01,3)
Enter a number to sequence each message within the batch, starting with 1,2,3,...etc.
"^DD",778,778.03,.01,"DT")
3040726
"^DD",778,778.03,.02,0)
MESSAGE ID^RF^^0;2^K:$L(X)>30!($L(X)<1) X
"^DD",778,778.03,.02,1,0)
^.1
"^DD",778,778.03,.02,1,1,0)
778^AE^MUMPS
"^DD",778,778.03,.02,1,1,1)
Q
"^DD",778,778.03,.02,1,1,2)
Q
"^DD",778,778.03,.02,1,1,"%D",0)
^.101^5^5^3041006^^
"^DD",778,778.03,.02,1,1,"%D",1,0)
This cross-reference is maintained outside of Fileman. It is for finding
"^DD",778,778.03,.02,1,1,"%D",2,0)
individual messages within a batch using the individual Message Control ID.
"^DD",778,778.03,.02,1,1,"%D",3,0)
Its format is:
"^DD",778,778.03,.02,1,1,"%D",4,0)

"^DD",778,778.03,.02,1,1,"%D",5,0)
"AE",<Message Control ID>,<ien, file 778>^<subien>)=""
"^DD",778,778.03,.02,1,1,"DT")
3041006
"^DD",778,778.03,.02,3)
Answer must be 1-30 characters in length.
"^DD",778,778.03,.02,"DT")
3041006
"^DD",778,778.03,.03,0)
APPLICATION ACKNOWLEDGMENT TO^F^^0;3^K:$L(X)>30!($L(X)<3) X
"^DD",778,778.03,.03,3)
Enter the Message Control ID of the message to which this one is a response.
"^DD",778,778.03,.03,21,0)
^^1^1^3040928^
"^DD",778,778.03,.03,21,1,0)
This field is completed only if this message is an application acknowledgment.
"^DD",778,778.03,.03,"DT")
3040928
"^DD",778,778.03,.04,0)
APPLICATION ACKNOWLEDGMENT BY^F^^0;4^K:$L(X)>30!($L(X)<3) X
"^DD",778,778.03,.04,3)
 Enter the Message Control ID of the application response.
"^DD",778,778.03,.04,"DT")
3040929
"^DD",778,778.03,.05,0)
COMPLETION STATUS^S^SU:SUCCESS;AE:APPLICATION ERROR;^0;5^Q
"^DD",778,778.03,.05,3)
Enter only if an application acknowledgment is received. SU is for successfully completed messages, AE if an error is returned.
"^DD",778,778.03,.05,"DT")
3040930
"^DD",778,778.03,1,0)
MSH SEGMENT, COMPONENTS 1-6^RF^^1;E1,250^K:$L(X)>250!($L(X)<8) X
"^DD",778,778.03,1,3)
Answer must be 8-250 characters in length.
"^DD",778,778.03,1,"DT")
3040729
"^DD",778,778.03,2,0)
MSH SEGMENT, COMPONENTS 7-END^F^^2;E1,250^K:$L(X)>250!($L(X)<15) X
"^DD",778,778.03,2,3)
Answer must be 15-250 characters in length.
"^DD",778,778.03,2,"DT")
3040729
"^DD",779.1,779.1,0)
FIELD^^.1^10
"^DD",779.1,779.1,0,"DDA")
N
"^DD",779.1,779.1,0,"DT")
3050601
"^DD",779.1,779.1,0,"IX","B",779.1,.01)

"^DD",779.1,779.1,0,"NM","HLO SYSTEM PARAMETERS")

"^DD",779.1,779.1,0,"VRPK")
HL
"^DD",779.1,779.1,.01,0)
DOMAIN NAME^RF^^0;1^K:$L(X)>64!($L(X)<3)!'(X'?1P.E) X
"^DD",779.1,779.1,.01,1,0)
^.1
"^DD",779.1,779.1,.01,1,1,0)
779.1^B
"^DD",779.1,779.1,.01,1,1,1)
S ^HLD(779.1,"B",$E(X,1,60),DA)=""
"^DD",779.1,779.1,.01,1,1,2)
K ^HLD(779.1,"B",$E(X,1,60),DA)
"^DD",779.1,779.1,.01,3)
The domain name for this system.  It will be used to populate component 2 of the Sending Facility field of the HL7 message header.
"^DD",779.1,779.1,.01,21,0)
^^2^2^3040805^
"^DD",779.1,779.1,.01,21,1,0)
The domain name for this system.  It will be used to populate component 2
"^DD",779.1,779.1,.01,21,2,0)
of the Sending Facility field of the HL7 message headers.
"^DD",779.1,779.1,.01,"DT")
3040805
"^DD",779.1,779.1,.02,0)
STATION NUMBER^F^^0;2^K:$L(X)>7!($L(X)<3) X
"^DD",779.1,779.1,.02,3)
Enter the station number with suffix that this system belongs under.  It will be used in component 1 of the Sending Facility field of the HL7 message header.
"^DD",779.1,779.1,.02,"DT")
3040805
"^DD",779.1,779.1,.03,0)
PRODUCTION ID^RS^P:production;T:training;^0;3^Q
"^DD",779.1,779.1,.03,3)
ENTER P if this is a production system, T otherwise.
"^DD",779.1,779.1,.03,"DT")
3040805
"^DD",779.1,779.1,.04,0)
MAXIMUM STRING LENGTH^NJ5,0^^0;4^K:+X'=X!(X>99999)!(X<1)!(X?.E1"."1N.N) X
"^DD",779.1,779.1,.04,3)
This is the maximum length for strings built by HLO when local applications create new messages to send.
"^DD",779.1,779.1,.04,21,0)
^^4^4^3050706^
"^DD",779.1,779.1,.04,21,1,0)
This parameter determines the maximum length for strings that HLO will create
"^DD",779.1,779.1,.04,21,2,0)
when messages are being built.  It doesn't apply to servers, as the size of
"^DD",779.1,779.1,.04,21,3,0)
input buffer used by TCP/IP determines the maximum string length created by a
"^DD",779.1,779.1,.04,21,4,0)
single read.
"^DD",779.1,779.1,.04,"DT")
3050706
"^DD",779.1,779.1,.05,0)
BUFFER SIZE FOR HL7 (BYTES)^NJ5,0^^0;5^K:+X'=X!(X>20000)!(X<10000)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.05,3)
This parameter represents the size of the buffer used by HLO for its background processes.  It defaults to 15000 bytes, but may be set from 10,000 bytes to 20,000 bytes.
"^DD",779.1,779.1,.05,"DT")
3050805
"^DD",779.1,779.1,.06,0)
BUFFER SIZE FOR USER (BYTES)^NJ5,0^^0;6^K:+X'=X!(X>10000)!(X<512)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.06,3)
This parameter is the size of the buffer used by HLO in the context of an online user.  It defaults to 5000, but may be reset to between 512 and 10000 bytes.
"^DD",779.1,779.1,.06,"DT")
3050805
"^DD",779.1,779.1,.07,0)
NORMAL MSG RETENTION (HOURS)^NJ2,0^^0;7^K:+X'=X!(X>96)!(X<36)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.07,3)
How many hours should successfully completed messages remain on your system? (36-96 hours, defaults to 36 hours) 
"^DD",779.1,779.1,.07,21,0)
^^7^7^3050317^^^
"^DD",779.1,779.1,.07,21,1,0)
This field controls the purging of HL7 messages whose completion status
"^DD",779.1,779.1,.07,21,2,0)
is SUCCESSFUL. It is in hours, since messages normally should be purged 
"^DD",779.1,779.1,.07,21,3,0)
very soon after completion, with an allowed range of 36 to 94 hours.
"^DD",779.1,779.1,.07,21,4,0)
 
"^DD",779.1,779.1,.07,21,5,0)
36 is the default because this 1) will result in most messages being purged
"^DD",779.1,779.1,.07,21,6,0)
at night and 2) provides sufficient time for the Capacity Planning statistics
"^DD",779.1,779.1,.07,21,7,0)
to be extracted. 
"^DD",779.1,779.1,.07,"DT")
3050317
"^DD",779.1,779.1,.08,0)
BAD MESSAGE RETENTION (DAYS)^NJ2,0^^0;8^K:+X'=X!(X>45)!(X<5)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.08,3)
How many days should message with errors remain on your system?  (7-45 days, defaults to 7 days)
"^DD",779.1,779.1,.08,21,0)
^^4^4^3041115^
"^DD",779.1,779.1,.08,21,1,0)
This field controls the purging of HL7 messages that do not complete
"^DD",779.1,779.1,.08,21,2,0)
successfully.  The period should be reasonably long to allow
"^DD",779.1,779.1,.08,21,3,0)
investigation, but because of the extremely high daily volume of
"^DD",779.1,779.1,.08,21,4,0)
messages purging must occur quickly.
"^DD",779.1,779.1,.08,"DT")
3041115
"^DD",779.1,779.1,.09,0)
HLO ON/OFF SWITCH^S^0:OFF;1:ON;^0;9^Q
"^DD",779.1,779.1,.09,3)
Set to 0 to turn off messaging and all HL7 processes.
"^DD",779.1,779.1,.09,"DT")
3050503
"^DD",779.1,779.1,.1,0)
HLO STANDARD LISTENER^*P870'^HLCS(870,^0;10^S DIC("S")="I ($P($G(^HLCS(870,Y,400)),""^"",3)=""M"")!($P($G(^HLCS(870,Y,400)),""^"",3)=""S"")" D ^DIC K DIC S DIC=$G(DIE),X=+Y K:Y<0 X
"^DD",779.1,779.1,.1,3)
Select an entry from the HL Logical Link file that is the listener that remote applications will normally connect to.
"^DD",779.1,779.1,.1,12)
This screen allows only server entries to be selected.
"^DD",779.1,779.1,.1,12.1)
S DIC("S")="I ($P($G(^HLCS(870,Y,400)),""^"",3)=""M"")!($P($G(^HLCS(870,Y,400)),""^"",3)=""S"")"
"^DD",779.1,779.1,.1,"DT")
3050601
"^DD",779.2,779.2,0)
FIELD^^2^11
"^DD",779.2,779.2,0,"DDA")
N
"^DD",779.2,779.2,0,"DT")
3050503
"^DD",779.2,779.2,0,"IX","B",779.2,.01)

"^DD",779.2,779.2,0,"NM","HLO APPLICATION REGISTRY")

"^DD",779.2,779.2,0,"VRPK")
HL
"^DD",779.2,779.2,.01,0)
APPLICATION NAME^RF^^0;1^K:$L(X)>60!($L(X)<3)!'(X'?1P.E) X
"^DD",779.2,779.2,.01,1,0)
^.1
"^DD",779.2,779.2,.01,1,1,0)
779.2^B
"^DD",779.2,779.2,.01,1,1,1)
S ^HLD(779.2,"B",$E(X,1,30),DA)=""
"^DD",779.2,779.2,.01,1,1,2)
K ^HLD(779.2,"B",$E(X,1,30),DA)
"^DD",779.2,779.2,.01,3)
Answer must be 3-60 characters in length. It must be unique and should be name-spaced.
"^DD",779.2,779.2,.01,"DT")
3050125
"^DD",779.2,779.2,.02,0)
RESPONSE LINK (OPTIONAL)^FX^^0;2^K:'$$CHKLINK^HLOTLNK(X) X
"^DD",779.2,779.2,.02,3)
If the return link cannot be identified via the Sending Facility (i.e., sent via an IE), what link should the application ack be sent through?
"^DD",779.2,779.2,.02,21,0)
^^5^5^3041116^^
"^DD",779.2,779.2,.02,21,1,0)
This field applies only if: 1) The receiving application is expected to 
"^DD",779.2,779.2,.02,21,2,0)
return application acknowledgments.  2) The initial message is  received 
"^DD",779.2,779.2,.02,21,3,0)
indirectly through the IE, and the  receiving application in turn does 
"^DD",779.2,779.2,.02,21,4,0)
not want to send the application acknowledgment directly back to the 
"^DD",779.2,779.2,.02,21,5,0)
sending facility identified in the message header.  
"^DD",779.2,779.2,.02,"DT")
3041116
"^DD",779.2,779.2,.03,0)
DEFAULT PRIVATE IN-QUEUE^F^^0;3^K:$L(X)>20!($L(X)<3) X
"^DD",779.2,779.2,.03,3)
You may create an optional default private in-queue by entering a unique name up to 20 characters in length. Queues specified for specific message types take precedence.
"^DD",779.2,779.2,.03,"DT")
3050317
"^DD",779.2,779.2,.04,0)
BATCH ACTION TAG^F^^0;4^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.2,.04,3)
If the application utilizes batch messages, the action to perform upon receipt of the message should be entered in the BATCH ACTION TAG and BATCH ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.2,.04,"DT")
3040814
"^DD",779.2,779.2,.05,0)
BATCH ACTION ROUTINE^F^^0;5^K:$L(X)>8!($L(X)<3) X
"^DD",779.2,779.2,.05,3)
If the application utilizes batch messages, the action to perform upon receipt of the message should be entered in the BATCH ACTION TAG and BATCH ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.2,.05,"DT")
3040814
"^DD",779.2,779.2,.06,0)
DEFAULT ACTION TAG^F^^0;6^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.2,.06,3)
You can enter the action to perform upon  receipt of a message where no other action applies by entering the DEFAULT ACTION TAG and DEFAULT ACTION ROUTINE fields as <tag>^<routine>. 
"^DD",779.2,779.2,.06,"DT")
3040815
"^DD",779.2,779.2,.07,0)
DEFAULT ACTION ROUTINE^F^^0;7^K:$L(X)>8!($L(X)<3) X
"^DD",779.2,779.2,.07,3)
You can enter the action to perform upon receipt of a message where no other action applies by entering the DEFAULT ACTION TAG and DEFAULT ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.2,.07,"DT")
3040814
"^DD",779.2,779.2,.08,0)
BATCH PRIVATE IN-QUEUE^F^^0;8^K:$L(X)>20!($L(X)<3) X
"^DD",779.2,779.2,.08,3)
You may establish a private queue for your batch messages by entering a unique name (name-spaced) up to 20 characters long.
"^DD",779.2,779.2,.08,"DT")
3050317
"^DD",779.2,779.2,.09,0)
APPLICATION SPECIFIC LISTENER^*P870'^HLCS(870,^0;9^S DIC("S")="I $E($P(^HLCS(870,Y,0),""^"",4),2)=""S""" D ^DIC K DIC S DIC=$G(DIE),X=+Y K:Y<0 X
"^DD",779.2,779.2,.09,3)
If your application requires its own listener (HIGHLY DISCOURAGED), enter it here.
"^DD",779.2,779.2,.09,12)
The link entered must be a listener.
"^DD",779.2,779.2,.09,12.1)
S DIC("S")="I $E($P(^HLCS(870,Y,0),""^"",4),2)=""S"""
"^DD",779.2,779.2,.09,21,0)
^^6^6^3050503^
"^DD",779.2,779.2,.09,21,1,0)
Applications are highly discouraged from establishing their own listeners.  The
"^DD",779.2,779.2,.09,21,2,0)
use of the multi-listeners provide concurrent processing of many connections
"^DD",779.2,779.2,.09,21,3,0)
over the same port, so a dedicated listener will not provide an application
"^DD",779.2,779.2,.09,21,4,0)
with a performance boost, while it will cause the site additional work to
"^DD",779.2,779.2,.09,21,5,0)
maintain. So before establishing a dedicated listener, the application
"^DD",779.2,779.2,.09,21,6,0)
developer should verify the need.
"^DD",779.2,779.2,.09,"DT")
3050527
"^DD",779.2,779.2,1,0)
MESSAGE TYPE ACTIONS^779.21^^1;0
"^DD",779.2,779.2,2,0)
Package File Link^RP9.4'^DIC(9.4,^2;1^Q
"^DD",779.2,779.2,2,3)
Enter the package responsible for these messages.
"^DD",779.2,779.2,2,21,0)
^^3^3^3050919^^
"^DD",779.2,779.2,2,21,1,0)
This field holds a pointer to the Package File for the Package 
"^DD",779.2,779.2,2,21,2,0)
responsible for these messages.
"^DD",779.2,779.2,2,21,3,0)

"^DD",779.2,779.2,2,"DT")
3050919
"^DD",779.2,779.21,0)
MESSAGE TYPE ACTIONS SUB-FIELD^^.05^5
"^DD",779.2,779.21,0,"DT")
3040815
"^DD",779.2,779.21,0,"IX","B",779.21,.01)

"^DD",779.2,779.21,0,"NM","MESSAGE TYPE ACTIONS")

"^DD",779.2,779.21,0,"UP")
779.2
"^DD",779.2,779.21,.01,0)
HL7 MESSAGE TYPE^MF^^0;1^K:$L(X)>3!($L(X)<3) X
"^DD",779.2,779.21,.01,1,0)
^.1
"^DD",779.2,779.21,.01,1,1,0)
779.21^B
"^DD",779.2,779.21,.01,1,1,1)
S ^HLD(779.2,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",779.2,779.21,.01,1,1,2)
K ^HLD(779.2,DA(1),1,"B",$E(X,1,30),DA)
"^DD",779.2,779.21,.01,3)
Enter the 3 character HL7 Message Type.
"^DD",779.2,779.21,.01,21,0)
^^3^3^3040814^
"^DD",779.2,779.21,.01,21,1,0)
An application should use this multiple to define the action that the receiving
"^DD",779.2,779.21,.01,21,2,0)
application needs to perform upon receipt of a specific type of HL7 message,
"^DD",779.2,779.21,.01,21,3,0)
identified by the HL7 MESSAGE TYPE and HL7 EVENT fields.
"^DD",779.2,779.21,.01,"DT")
3040815
"^DD",779.2,779.21,.02,0)
HL7 EVENT^RF^^0;2^K:$L(X)>3!($L(X)<3) X
"^DD",779.2,779.21,.02,3)
Enter the 3 character HL7 event type.
"^DD",779.2,779.21,.02,"DT")
3040815
"^DD",779.2,779.21,.03,0)
PRIVATE IN-QUEUE^F^^0;3^K:$L(X)>20!($L(X)<3) X
"^DD",779.2,779.21,.03,3)
You may create a private in-queue for message of this type by entering a unique name up to 20 characters long.
"^DD",779.2,779.21,.03,"DT")
3050919
"^DD",779.2,779.21,.04,0)
ACTION TAG^F^^0;4^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.21,.04,3)
You must enter the action to perform upon receipt of this type by entering the ACTION TAG and ACTION ROUTINE fields as <tag>^<routine>. The tag is optional. 
"^DD",779.2,779.21,.04,"DT")
3040815
"^DD",779.2,779.21,.05,0)
ACTION ROUTINE^RF^^0;5^K:$L(X)>8!($L(X)<3) X
"^DD",779.2,779.21,.05,3)
You must enter the action to perform upon receipt of this type by entering the ACTION TAG and ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.21,.05,"DT")
3050919
"^DD",779.3,779.3,0)
FIELD^^.15^15
"^DD",779.3,779.3,0,"DDA")
N
"^DD",779.3,779.3,0,"DT")
3041221
"^DD",779.3,779.3,0,"IX","B",779.3,.01)

"^DD",779.3,779.3,0,"NM","HLO PROCESS REGISTRY")

"^DD",779.3,779.3,0,"VRPK")
HL
"^DD",779.3,779.3,.01,0)
PROCESS NAME^RF^^0;1^K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E) X
"^DD",779.3,779.3,.01,1,0)
^.1
"^DD",779.3,779.3,.01,1,1,0)
779.3^B
"^DD",779.3,779.3,.01,1,1,1)
S ^HLD(779.3,"B",$E(X,1,30),DA)=""
"^DD",779.3,779.3,.01,1,1,2)
K ^HLD(779.3,"B",$E(X,1,30),DA)
"^DD",779.3,779.3,.01,3)
Give the type of process a unique name, 3-30 characters.
"^DD",779.3,779.3,.01,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.01,21,1,0)
A unique name for the type of process.
"^DD",779.3,779.3,.01,"DT")
3041115
"^DD",779.3,779.3,.02,0)
ACTIVE^S^0:NO;1:YES;^0;2^Q
"^DD",779.3,779.3,.02,3)
Enter 1 to activate these processes, 0 to inactivate.
"^DD",779.3,779.3,.02,21,0)
^^4^4^3050805^^^^
"^DD",779.3,779.3,.02,21,1,0)
A flag that indicates whether or not this type of process is active under 
"^DD",779.3,779.3,.02,21,2,0)
the HLO Process Manager. Some processes may not apply to some 
"^DD",779.3,779.3,.02,21,3,0)
systems, for example, a particular site may not use the Taskman 
"^DD",779.3,779.3,.02,21,4,0)
multi-listener. 
"^DD",779.3,779.3,.02,"DT")
3050805
"^DD",779.3,779.3,.03,0)
MINIMUM ACTIVE PROCESSES^NJ2,0^^0;3^K:+X'=X!(X>99)!(X<0)!(X?.E1"."1.N) X
"^DD",779.3,779.3,.03,3)
How many of these processes should be running at a minimum when HL7 messaging is on?
"^DD",779.3,779.3,.03,21,0)
^^3^3^3050805^^^
"^DD",779.3,779.3,.03,21,1,0)
This field indicates the minimum number of concurrent processes of this 
"^DD",779.3,779.3,.03,21,2,0)
type.  The exact number changes as the HLO Process Manager starts and 
"^DD",779.3,779.3,.03,21,3,0)
stops processes in response to changes in workload.
"^DD",779.3,779.3,.03,"DT")
3050805
"^DD",779.3,779.3,.04,0)
MAXIMUM ACTIVE PROCESSES^NJ3,0^^0;4^K:+X'=X!(X>999)!(X<1)!(X?.E1"."1.N) X
"^DD",779.3,779.3,.04,3)
How many of these processes should be running at a maximum when the HL7 messaging system is on?
"^DD",779.3,779.3,.04,"DT")
3040907
"^DD",779.3,779.3,.05,0)
SCHEDULING FREQUENCY (minutes)^NJ4,0^^0;5^K:+X'=X!(X>9999)!(X<0)!(X?.E1"."1N.N) X
"^DD",779.3,779.3,.05,3)
This is how long the Process Manager should wait between checks to see if another process of this type should be started.  Enter 0 to 9999.
"^DD",779.3,779.3,.05,21,0)
^.001^2^2^3041221^^
"^DD",779.3,779.3,.05,21,1,0)
This is how long the Process Manager should wait between checks to see if 
"^DD",779.3,779.3,.05,21,2,0)
another process of this type should be started.
"^DD",779.3,779.3,.05,"DT")
3050919
"^DD",779.3,779.3,.06,0)
DT/TM LAST STARTED OR STOPPED^D^^0;6^S %DT="ESTR" D ^%DT S X=Y K:Y<1 X
"^DD",779.3,779.3,.06,3)
DT/TM the process manager last started or stopped one of these.
"^DD",779.3,779.3,.06,21,0)
^^2^2^3041115^
"^DD",779.3,779.3,.06,21,1,0)
The date and time when a process of this type was last started or 
"^DD",779.3,779.3,.06,21,2,0)
stopped.
"^DD",779.3,779.3,.06,"DT")
3041115
"^DD",779.3,779.3,.07,0)
HANG TIME (seconds)^NJ3,0^^0;7^K:+X'=X!(X>999)!(X<0)!(X?.E1"."1.N) X
"^DD",779.3,779.3,.07,3)
If the process cannot find work, how many seconds should it hang before looking again?
"^DD",779.3,779.3,.07,21,0)
^^2^2^3041115^
"^DD",779.3,779.3,.07,21,1,0)
This is how long a process should wait between attempts to find work to 
"^DD",779.3,779.3,.07,21,2,0)
do.
"^DD",779.3,779.3,.07,"DT")
3041115
"^DD",779.3,779.3,.08,0)
GET WORK FUNCTION (TAG)^RF^^0;8^K:$L(X)>8!($L(X)<1) X
"^DD",779.3,779.3,.08,3)
What function will this process call to find work (optional routine entry point)
"^DD",779.3,779.3,.08,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.08,21,1,0)
The M entry point to the GET WORK function for this process type.
"^DD",779.3,779.3,.08,"DT")
3041115
"^DD",779.3,779.3,.09,0)
GET WORK FUNCTION (ROUTINE)^RF^^0;9^K:$L(X)>8!($L(X)<1) X
"^DD",779.3,779.3,.09,3)
What function should this process call to find work? (routine name only)
"^DD",779.3,779.3,.09,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.09,21,1,0)
The routine in which this process type has located its GET WORK function.
"^DD",779.3,779.3,.09,"DT")
3041115
"^DD",779.3,779.3,.1,0)
DO WORK FUNCTION (TAG)^F^^0;10^K:$L(X)>8!($L(X)<1) X
"^DD",779.3,779.3,.1,3)
What function should this process call to do its work? Enter the optional entry point only in this field.
"^DD",779.3,779.3,.1,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.1,21,1,0)
The M entry point for the process's DO WORK function.
"^DD",779.3,779.3,.1,"DT")
3041115
"^DD",779.3,779.3,.11,0)
DO WORK FUNCTION (ROUTINE)^F^^0;11^K:$L(X)>8!($L(X)<1) X
"^DD",779.3,779.3,.11,3)
What function should this process call to do its work?  Enter the routine name only in this field.
"^DD",779.3,779.3,.11,21,0)
^^1^1^3041115^
"^DD",779.3,779.3,.11,21,1,0)
The routine in which the process's DO WORK function is located.
"^DD",779.3,779.3,.11,"DT")
3041115
"^DD",779.3,779.3,.12,0)
MAX TRIES FINDING WORK^NJ4,0^^0;12^K:+X'=X!(X>9999)!(X<0)!(X?.E1"."1.N) X
"^DD",779.3,779.3,.12,3)
How many times should the process look for work before giving up?
"^DD",779.3,779.3,.12,21,0)
^^3^3^3041115^
"^DD",779.3,779.3,.12,21,1,0)
How many times should the process look for work and then quit if it 
"^DD",779.3,779.3,.12,21,2,0)
cannot find anything to do?  It'll hang between attempts the specified 
"^DD",779.3,779.3,.12,21,3,0)
length of time.
"^DD",779.3,779.3,.12,"DT")
3041115
"^DD",779.3,779.3,.13,0)
PERSISTENT^S^0:NO;1:YES;^0;13^Q
"^DD",779.3,779.3,.13,3)
Should processes of this type be restarted automatically if they die?
"^DD",779.3,779.3,.13,21,0)
^^2^2^3041115^
"^DD",779.3,779.3,.13,21,1,0)
Setting this field to YES results in the process being made persistent 
"^DD",779.3,779.3,.13,21,2,0)
via the Taskman persistent parameter.
"^DD",779.3,779.3,.13,"DT")
3041115
"^DD",779.3,779.3,.14,0)
DEDICATED LINK^FX^^0;14^K:$L(X)>10!($L(X)<3) X
"^DD",779.3,779.3,.14,3)
If this process is a listener, you must enter the name of an HL LOGICAL LINK that is a listener and whose TCP/IP PORT (OPTIMIZED) field contains the correct port number.
"^DD",779.3,779.3,.14,4)

"^DD",779.3,779.3,.14,21,0)
^^4^4^3041115^
"^DD",779.3,779.3,.14,21,1,0)
The primary use of this field is for TCP/IP listener processes, and 
"^DD",779.3,779.3,.14,21,2,0)
indicates which port (via the HL Logical Link) that the process should be 
"^DD",779.3,779.3,.14,21,3,0)
listening on.  However, it could be used to dedicate a client link 
"^DD",779.3,779.3,.14,21,4,0)
process to a particular link.
"^DD",779.3,779.3,.14,"DT")
3050706
"^DD",779.3,779.3,.15,0)
VMS TCP SERVICE^S^1:YES;0:NO;^0;15^Q
"^DD",779.3,779.3,.15,3)
If this process is a listener, enter YES if it is a VMS TCP service rather than a Taskman process.
"^DD",779.3,779.3,.15,21,0)
^^5^5^3040923^
"^DD",779.3,779.3,.15,21,1,0)
VMS services are not started or stopped via the HL7 Process Manager.  
"^DD",779.3,779.3,.15,21,2,0)
However, on a VMS system, these services are an important part of the HL7
"^DD",779.3,779.3,.15,21,3,0)
system, and so an entry in the HL7 Process Registry should be created for 
"^DD",779.3,779.3,.15,21,4,0)
them.  The Process Manager will use the PING functionality to verify that 
"^DD",779.3,779.3,.15,21,5,0)
the listener is running.
"^DD",779.3,779.3,.15,"DT")
3040923
"^DD",779.4,779.4,0)
FIELD^^20^4
"^DD",779.4,779.4,0,"DDA")
N
"^DD",779.4,779.4,0,"DT")
3050113
"^DD",779.4,779.4,0,"IX","AH",779.4,.02)

"^DD",779.4,779.4,0,"IX","B",779.4,.01)

"^DD",779.4,779.4,0,"NM","HLO SUBSCRIPTION REGISTRY")

"^DD",779.4,779.4,0,"VRPK")
HL
"^DD",779.4,779.4,.01,0)
NAME^RFX^^0;1^K:+X'=X!(X>99999999)!(X<1)!(X?.E1"."1N.N) X S:$D(X) DINUM=X
"^DD",779.4,779.4,.01,1,0)
^.1
"^DD",779.4,779.4,.01,1,1,0)
779.4^B
"^DD",779.4,779.4,.01,1,1,1)
S ^HLD(779.4,"B",$E(X,1,30),DA)=""
"^DD",779.4,779.4,.01,1,1,2)
K ^HLD(779.4,"B",$E(X,1,30),DA)
"^DD",779.4,779.4,.01,3)
NAME MUST BE 3-30 CHARACTERS, NOT NUMERIC OR STARTING WITH PUNCTUATION
"^DD",779.4,779.4,.01,21,0)
^^2^2^3050308^^^^
"^DD",779.4,779.4,.01,21,1,0)
This file should not be used to edit this file. Instead, a set of developer
"^DD",779.4,779.4,.01,21,2,0)
APIs that was released with this file should be used.
"^DD",779.4,779.4,.01,"DT")
3050308
"^DD",779.4,779.4,.02,0)
OWNER^F^^0;2^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,.02,1,0)
^.1
"^DD",779.4,779.4,.02,1,1,0)
779.4^AH^MUMPS
"^DD",779.4,779.4,.02,1,1,1)
Q
"^DD",779.4,779.4,.02,1,1,2)
D KILLAH^HLOASUB1(DA)
"^DD",779.4,779.4,.02,1,1,"%D",0)
^.101^9^9^3041116^^
"^DD",779.4,779.4,.02,1,1,"%D",1,0)
The AH x-ref is maintained by the owner of the subscription.  It represents
"^DD",779.4,779.4,.02,1,1,"%D",2,0)
a private index by which the application my perform a lookup to find a
"^DD",779.4,779.4,.02,1,1,"%D",3,0)
subscription.  The use of a private index is optional, the alternative being
"^DD",779.4,779.4,.02,1,1,"%D",4,0)
that the owning application may store the ien of the subscription entry
"^DD",779.4,779.4,.02,1,1,"%D",5,0)
with the application's data.
"^DD",779.4,779.4,.02,1,1,"%D",6,0)

"^DD",779.4,779.4,.02,1,1,"%D",7,0)
The format of the index is as follows:
"^DD",779.4,779.4,.02,1,1,"%D",8,0)

"^DD",779.4,779.4,.02,1,1,"%D",9,0)
^HLS(779.4,"AH",<owner>,<list of lookup values....>,<DA>)=""
"^DD",779.4,779.4,.02,1,1,"DT")
3040601
"^DD",779.4,779.4,.02,3)
Answer must be 1-40 characters in length.
"^DD",779.4,779.4,.02,21,0)
^^2^2^3040526^^
"^DD",779.4,779.4,.02,21,1,0)
This is the application or package responsible for creating this
"^DD",779.4,779.4,.02,21,2,0)
subscription.
"^DD",779.4,779.4,.02,"DT")
3040601
"^DD",779.4,779.4,.03,0)
DESCRIPTION^F^^1;1^K:$L(X)>75!($L(X)<1) X
"^DD",779.4,779.4,.03,3)
Answer must be 1-75 characters in length
"^DD",779.4,779.4,.03,"DT")
2991207
"^DD",779.4,779.4,20,0)
RECIPIENTS^779.41^^2;0
"^DD",779.4,779.41,0)
RECIPIENTS SUB-FIELD^^1.02^7
"^DD",779.4,779.41,0,"DT")
3040817
"^DD",779.4,779.41,0,"IX","B",774.02,.01)

"^DD",779.4,779.41,0,"IX","B",779.41,.01)

"^DD",779.4,779.41,0,"NM","RECIPIENTS")

"^DD",779.4,779.41,0,"UP")
779.4
"^DD",779.4,779.41,.01,0)
RECEIVING APPLICATON^MRF^^0;1^K:$L(X)>60!($L(X)<1) X
"^DD",779.4,779.41,.01,1,0)
^.1
"^DD",779.4,779.41,.01,1,1,0)
779.41^B
"^DD",779.4,779.41,.01,1,1,1)
S ^HLS(779.4,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",779.4,779.41,.01,1,1,2)
K ^HLS(779.4,DA(1),2,"B",$E(X,1,30),DA)
"^DD",779.4,779.41,.01,3)
Enter the name of the application that will receive the message, up to 60 characters.
"^DD",779.4,779.41,.01,"DT")
3040817
"^DD",779.4,779.41,.02,0)
LOGICAL LINK^RP870'^HLCS(870,^0;2^Q
"^DD",779.4,779.41,.02,3)
Over which communication link should the messages be sent?
"^DD",779.4,779.41,.02,"DT")
3040527
"^DD",779.4,779.41,.03,0)
RECEIVING FACILITY COMPONENT 1^F^^0;3^K:$L(X)>50!($L(X)<1) X
"^DD",779.4,779.41,.03,3)
Answer must be 1-50 characters in length
"^DD",779.4,779.41,.03,21,0)
^^2^2^3040526^
"^DD",779.4,779.41,.03,21,1,0)
This is the value that should be placed in component 1 of the receiving
"^DD",779.4,779.41,.03,21,2,0)
facility field of the message header.
"^DD",779.4,779.41,.03,"DT")
3040527
"^DD",779.4,779.41,.04,0)
RECEIVING FACILITY COMPONENT 2^F^^0;4^K:$L(X)>50!($L(X)<1) X
"^DD",779.4,779.41,.04,3)
Answer must be 1-50 characters in length
"^DD",779.4,779.41,.04,21,0)
^^2^2^3040526^
"^DD",779.4,779.41,.04,21,1,0)
This is the value that should be placed in component 2 of the receiving
"^DD",779.4,779.41,.04,21,2,0)
facility field of the message header.
"^DD",779.4,779.41,.04,"DT")
3040527
"^DD",779.4,779.41,.05,0)
RECEIVING FACILITY COMPONENT 3^F^^0;5^K:$L(X)>10!($L(X)<1) X
"^DD",779.4,779.41,.05,3)
Answer must be 1-10 characters in length
"^DD",779.4,779.41,.05,21,0)
^^2^2^3041116^
"^DD",779.4,779.41,.05,21,1,0)
This is the value that should be placed in component 3 of the receiving
"^DD",779.4,779.41,.05,21,2,0)
facility field of the message header.
"^DD",779.4,779.41,.05,"DT")
3041116
"^DD",779.4,779.41,1.01,0)
DATE/TIME ADDED^RD^^1;1^S %DT="ESTXR" D ^%DT S X=Y K:X<1 X
"^DD",779.4,779.41,1.01,3)
Enter the date and time that this recipient was added to the subscription list.
"^DD",779.4,779.41,1.01,"DT")
3040526
"^DD",779.4,779.41,1.02,0)
DATE/TIME TERMINATED^D^^1;2^S %DT="ESTXR" D ^%DT S X=Y K:X<1 X
"^DD",779.4,779.41,1.02,3)
Enter the date and time that this recipient was dropped from the subscription list
"^DD",779.4,779.41,1.02,"DT")
3040526
"^DD",870,870,0)
FIELD^^400.08^47
"^DD",870,870,0,"DDA")
N
"^DD",870,870,0,"DT")
3041221
"^DD",870,870,0,"IX","AISTAT",870.019,1)

"^DD",870,870,0,"IX","ALLP",870,2)

"^DD",870,870,0,"IX","B",870,.01)

"^DD",870,870,0,"IX","C",870,.02)

"^DD",870,870,0,"IX","D",870,.03)

"^DD",870,870,0,"IX","E",870,400.03)

"^DD",870,870,0,"NM","HL LOGICAL LINK")

"^DD",870,870,0,"PT",101,770.7)

"^DD",870,870,0,"PT",772,11)

"^DD",870,870,0,"PT",773,7)

"^DD",870,870,0,"PT",773,17)

"^DD",870,870,0,"PT",774.01,3)

"^DD",870,870,0,"PT",774.02,.02)

"^DD",870,870,0,"PT",779.1,.1)

"^DD",870,870,0,"PT",779.2,.09)

"^DD",870,870,0,"PT",779.41,.02)

"^DD",870,870,0,"PT",869.311,.01)

"^DD",870,870,0,"VRPK")
HL
"^DD",870,870,.01,0)
NODE^RF^^0;1^K:$L(X)>10!($L(X)<3)!'(X'?1P.E) X
"^DD",870,870,.01,1,0)
^.1^^-1
"^DD",870,870,.01,1,1,0)
870^B
"^DD",870,870,.01,1,1,1)
S ^HLCS(870,"B",$E(X,1,30),DA)=""
"^DD",870,870,.01,1,1,2)
K ^HLCS(870,"B",$E(X,1,30),DA)
"^DD",870,870,.01,3)
Enter the name of the logical link (3-10 characters)
"^DD",870,870,.01,21,0)
^^5^5^2990217^^^^
"^DD",870,870,.01,21,1,0)
This is the name of the logical link that data will be communicated on.
"^DD",870,870,.01,21,2,0)
It is this name that will be displayed in the "NODE" column of the
"^DD",870,870,.01,21,3,0)
SYSTEMS LINK MONITOR display option.
"^DD",870,870,.01,21,4,0)
It is suggested that this name be the same name as the commercial
"^DD",870,870,.01,21,5,0)
application e.g. KURZWEIL1,KURZWEIL2,COPATH, or SUNQUEST1.
"^DD",870,870,.01,"DT")
3050308
"^DD",870,870,.02,0)
INSTITUTION^P4'X^DIC(4,^0;2^K:$O(^HLCS(870,"C",X,0)) X
"^DD",870,870,.02,1,0)
^.1
"^DD",870,870,.02,1,1,0)
870^C
"^DD",870,870,.02,1,1,1)
S ^HLCS(870,"C",$E(X,1,30),DA)=""
"^DD",870,870,.02,1,1,2)
K ^HLCS(870,"C",$E(X,1,30),DA)
"^DD",870,870,.02,1,1,"DT")
2970123
"^DD",870,870,.02,3)
Select an institution that has not been associated with another link.
"^DD",870,870,.02,21,0)
^^5^5^2990804^
"^DD",870,870,.02,21,1,0)
It may be necessary for an application to determine the appropriate link
"^DD",870,870,.02,21,2,0)
to use when the only information it has is the institution. This field is
"^DD",870,870,.02,21,3,0)
used to associate a link with that institution. There is a 1:1
"^DD",870,870,.02,21,4,0)
correspondence between institution and logical link. An institution cannot
"^DD",870,870,.02,21,5,0)
be associated with more than one logical link.
"^DD",870,870,.02,"DT")
3040528
"^DD",870,870,.03,0)
MAILMAN DOMAIN^P4.2'X^DIC(4.2,^0;7^K:$O(^HLCS(870,"D",X,0)) X
"^DD",870,870,.03,1,0)
^.1^^-1
"^DD",870,870,.03,1,1,0)
870^D
"^DD",870,870,.03,1,1,1)
S ^HLCS(870,"D",$E(X,1,30),DA)=""
"^DD",870,870,.03,1,1,2)
K ^HLCS(870,"D",$E(X,1,30),DA)
"^DD",870,870,.03,1,1,"DT")
2980321
"^DD",870,870,.03,3)
Enter the Mailman domain corresponding to this link.
"^DD",870,870,.03,21,0)
^^2^2^3040528^^
"^DD",870,870,.03,21,1,0)
Either this field or the OTHER DOMAIN field should have a value.  The domain is
"^DD",870,870,.03,21,2,0)
used to formulate the RECEIVING FACILITY field of the message header.
"^DD",870,870,.03,"DT")
3050308
"^DD",870,870,.08,0)
DNS DOMAIN^FX^^0;8^K:$L(X)>70!($L(X)<4) X S HLIP=$$ADDRESS^XLFNSLK(X) K:('HLIP)&($P($G(^HLCS(869.3,1,0)),"^",3)="P")&($P($$SITE^VASITE,"^",3)) X I HLIP S HLIP=$$IP^HLMA3(DA,HLIP)
"^DD",870,870,.08,3)
Enter the full domain name as registered with DNS.
"^DD",870,870,.08,21,0)
^.001^1^1^3041221^^^
"^DD",870,870,.08,21,1,0)
The domain name as registered with DNS.
"^DD",870,870,.08,"DT")
3050309
"^DD",870,870,2,0)
LLP TYPE^RP869.1'^HLCS(869.1,^0;3^Q
"^DD",870,870,2,1,0)
^.1^^-1
"^DD",870,870,2,1,1,0)
870^ALLP
"^DD",870,870,2,1,1,1)
S ^HLCS(870,"ALLP",$E(X,1,30),DA)=""
"^DD",870,870,2,1,1,2)
K ^HLCS(870,"ALLP",$E(X,1,30),DA)
"^DD",870,870,2,1,1,"%D",0)
^^3^3^2950227^
"^DD",870,870,2,1,1,"%D",1,0)
This cross-reference is used to link the HL Lower Layer Parameter
"^DD",870,870,2,1,1,"%D",2,0)
file (#869.2) with the HL Logical Link file. Using this x-ref you can
"^DD",870,870,2,1,1,"%D",3,0)
locate the parameter associated with this link.
"^DD",870,870,2,1,1,"DT")
2950227
"^DD",870,870,2,3)
Enter the  LLP used for this logical link.
"^DD",870,870,2,21,0)
^.001^4^4^3040826^^
"^DD",870,870,2,21,1,0)
Enter the type of Lower Level Protocol for this logical link. Selection of
"^DD",870,870,2,21,2,0)
TCP implies that the MLLP protocol will be used. Each of the supported
"^DD",870,870,2,21,3,0)
LLP's are described in detail in Appendix C of the HL7 Implementation
"^DD",870,870,2,21,4,0)
Guide.
"^DD",870,870,2,"DT")
3050308
"^DD",870,870,3,0)
DEVICE TYPE^S^PC:Persistent Client;NC:Non-Persistent Client;SS:Single-threaded Server;MS:Multi-threaded Server;SH:Serial HLLP;SX:Serial X3.28;MM:MailMan;^0;4^Q
"^DD",870,870,3,1,0)
^.1^^0
"^DD",870,870,3,3)
Not editable from any user option. See field description.
"^DD",870,870,3,21,0)
^.001^3^3^3040826^^^^
"^DD",870,870,3,21,1,0)
This field is not editable from any user option. It is used purely
"^DD",870,870,3,21,2,0)
for display purposes in the DEVICE TYPE column of the SYSTEMS LINK
"^DD",870,870,3,21,3,0)
MONITOR display option.
"^DD",870,870,3,"DT")
3030710
"^DD",870,870,4,0)
STATE^F^^0;5^K:$L(X)>10!($L(X)<1) X
"^DD",870,870,4,3)
Not editable from any user option. See field description.
"^DD",870,870,4,21,0)
^.001^3^3^3050118^^^^
"^DD",870,870,4,21,1,0)
This field is not editable from any user option. It is used purely for
"^DD",870,870,4,21,2,0)
display purposes in the STATE column of the SYSTEMS LINK MONITOR
"^DD",870,870,4,21,3,0)
display option.
"^DD",870,870,4,"DT")
2941006
"^DD",870,870,4.5,0)
AUTOSTART^S^0:Disabled;1:Enabled;^0;6^Q
"^DD",870,870,4.5,21,0)
^^2^2^2980831^^
"^DD",870,870,4.5,21,1,0)
This field permits the link to be restarted by Taskman after a system
"^DD",870,870,4.5,21,2,0)
reboot. If disabled, the link will not be restarted.
"^DD",870,870,4.5,"DT")
2961120
"^DD",870,870,5,0)
IN QUEUE FRONT POINTER^NJ14,0^^IN QUEUE FRONT POINTER;1^K:+X'=X!(X>99999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,5,3)
This field is not editable from any user option. See Field Description.
"^DD",870,870,5,21,0)
^^2^2^3041221^
"^DD",870,870,5,21,1,0)
The queue structure relies on two queues, INcoming and OUTgoing.
"^DD",870,870,5,21,2,0)
This pointer is used to point to the first message in the FIFO queue.
"^DD",870,870,5,"DT")
3041221
"^DD",870,870,6,0)
IN QUEUE BACK POINTER^NJ14,0^^IN QUEUE BACK POINTER;1^K:+X'=X!(X>99999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,6,3)
Type a Number between 0 and 99999999999999, 0 Decimal Digits
"^DD",870,870,6,21,0)
^^2^2^3041221^
"^DD",870,870,6,21,1,0)
The queue structure relies on two queues-INcoming and OUTgoing.
"^DD",870,870,6,21,2,0)
This pointer points to the last message in the FIFO queue.
"^DD",870,870,6,"DT")
3041221
"^DD",870,870,7,0)
OUT QUEUE FRONT POINTER^NJ14,0^^OUT QUEUE FRONT POINTER;1^K:+X'=X!(X>99999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,7,3)
This field is not editable from any user option. See Field Description.
"^DD",870,870,7,21,0)
^^2^2^3041221^
"^DD",870,870,7,21,1,0)
The queue structure relies on two queues-INcoming and OUTgoing.
"^DD",870,870,7,21,2,0)
This pointer points to the first message in the FIFO queue.
"^DD",870,870,7,"DT")
3041221
"^DD",870,870,8,0)
OUT QUEUE BACK POINTER^NJ14,0^^OUT QUEUE BACK POINTER;1^K:+X'=X!(X>99999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,8,3)
This field is not editable from any user option. See field description.
"^DD",870,870,8,21,0)
^^2^2^3041221^
"^DD",870,870,8,21,1,0)
The queue structure relies on two queues, INcoming and OUTgoing.
"^DD",870,870,8,21,2,0)
This pointer points to the last message in the FIFO queue.
"^DD",870,870,8,"DT")
3041221
"^DD",870,870,9,0)
TIME STARTED^D^^0;10^S %DT="EST" D ^%DT S X=Y K:Y<1 X
"^DD",870,870,9,3)
This field is not editable from any user option. See Field Description.
"^DD",870,870,9,21,0)
^^3^3^2950222^^^^
"^DD",870,870,9,21,1,0)
This field contains the Date/Time the Lower Layer Protocol was
"^DD",870,870,9,21,2,0)
last launched for the Logical Link. Only applicable to Lower Layer
"^DD",870,870,9,21,3,0)
Protocols, not Mailman.
"^DD",870,870,9,"DT")
2941006
"^DD",870,870,10,0)
TIME STOPPED^D^^0;11^S %DT="EST" D ^%DT S X=Y K:Y<1 X
"^DD",870,870,10,3)
This field is not editable from any user option. See Field Description.
"^DD",870,870,10,21,0)
^^3^3^2941212^^^
"^DD",870,870,10,21,1,0)
This field contains the Date/Time the Lower Layer Protocol was
"^DD",870,870,10,21,2,0)
last shutdown for the Logical Link. Only applicable to Lower Layer
"^DD",870,870,10,21,3,0)
Protocols, not Mailman.
"^DD",870,870,10,"DT")
2941006
"^DD",870,870,11,0)
TASK NUMBER^NJ15,0^^0;12^K:+X'=X!(X>999999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,11,3)
This field is not editable from any user option. See Field Description.
"^DD",870,870,11,21,0)
^^2^2^2941212^^^
"^DD",870,870,11,21,1,0)
This is the task number assigned by TaskMan when the Lower Layer Protocol
"^DD",870,870,11,21,2,0)
is launched in the background.
"^DD",870,870,11,"DT")
2941006
"^DD",870,870,14,0)
SHUTDOWN LLP ?^S^0:NO;1:YES;^0;15^Q
"^DD",870,870,14,3)
Setting this field to 'Y' through the STOP HYBRID LLP option, shuts down the lower layer protocol and closes the device.
"^DD",870,870,14,21,0)
^^3^3^2950222^^^^
"^DD",870,870,14,21,1,0)
This field is editable through the STOP HYBRID LLP option. When the
"^DD",870,870,14,21,2,0)
Lower Layer Protocol is running, and this field is set to 'Y' the
"^DD",870,870,14,21,3,0)
Lower Layer Protocol will shutdown and close the device.
"^DD",870,870,14,"DT")
2950222
"^DD",870,870,16,0)
SHUTDOWN OUTGOING HLO MESSAGES^S^0:NO;1:YES;^0;16^Q
"^DD",870,870,16,3)
Enter YES to stop HLO messages from being transmitted to this destinations.
"^DD",870,870,16,21,0)
^^2^2^3050914^
"^DD",870,870,16,21,1,0)
This field affects only HLO messages.
"^DD",870,870,16,21,2,0)

"^DD",870,870,16,"DT")
3050914
"^DD",870,870,18,0)
GROSS COMMUNICATIONS ERROR^P771.7'^HL(771.7,^0;19^Q
"^DD",870,870,18,3)
This field contains the most recent communications error which has occured on a particular link.
"^DD",870,870,18,21,0)
^^10^10^2941213^^^^
"^DD",870,870,18,21,1,0)
This field contains the most recent gross communications error. It
"^DD",870,870,18,21,2,0)
serves a two purposes. It is a flag for the SYSTEMS LINK MONITOR.
"^DD",870,870,18,21,3,0)
In other words, if this field is defined it means a communications
"^DD",870,870,18,21,4,0)
error has occured on the link. This is indicated by the NODE field
"^DD",870,870,18,21,5,0)
flashing on the SYSTEMS LINK MONITOR. 
"^DD",870,870,18,21,6,0)
The error can be viewed by using the SHOW COMMUNICATION ERROR option.
"^DD",870,870,18,21,7,0)
The error can be cleared by using the CLEAR COMMUNICATION ERROR option.
"^DD",870,870,18,21,8,0)
If set, an error occurred while transmitting (timeout for example).
"^DD",870,870,18,21,9,0)
This field can be viewed using the 'Show Gross LLP Error' and cleared
"^DD",870,870,18,21,10,0)
using the 'Clear Gross LLP Error' options.
"^DD",870,870,18,"DT")
2941213
"^DD",870,870,19,0)
IN QUEUE^870.019^^1;0
"^DD",870,870,19,21,0)
^^1^1^3050414^
"^DD",870,870,19,21,1,0)
This multiple contains the queue for incoming messages.
"^DD",870,870,19,"DT")
3041012
"^DD",870,870,20,0)
OUT QUEUE^870.01A^^2;0
"^DD",870,870,20,21,0)
^^1^1^3050414^
"^DD",870,870,20,21,1,0)
This multiple contains the queue for outgoing messages.
"^DD",870,870,20,"DT")
3041012
"^DD",870,870,21,0)
QUEUE SIZE^NJ6,0^^0;21^K:+X'=X!(X>100000)!(X<2)!(X?.E1"."1N.N) X
"^DD",870,870,21,3)
Type a Number between 2 and 100000, 0 Decimal Digits
"^DD",870,870,21,21,0)
^^3^3^3041221^
"^DD",870,870,21,21,1,0)
This is the steady-state size of the queue. The queue may dynamically
"^DD",870,870,21,21,2,0)
grow beyond this size, under certain conditions. See Users Manual, for
"^DD",870,870,21,21,3,0)
more information.
"^DD",870,870,21,"DT")
3041221
"^DD",870,870,100.01,0)
MAIL GROUP^P3.8^XMB(3.8,^100;1^Q
"^DD",870,870,100.01,3)
Enter the mail group that messages should be sent to.
"^DD",870,870,100.01,21,0)
^^10^10^2990707^
"^DD",870,870,100.01,21,1,0)
If you are building a logical link that will use Mailman as a transport,
"^DD",870,870,100.01,21,2,0)
you must define a mail group that contains the remote member, 
"^DD",870,870,100.01,21,3,0)
 
"^DD",870,870,100.01,21,4,0)
S.HL V16 SERVER@your target domain
"^DD",870,870,100.01,21,5,0)
 
"^DD",870,870,100.01,21,6,0)
The HL7 package will place outbound messages in file 870's outque. The
"^DD",870,870,100.01,21,7,0)
link must be running for messages to be handed off to Mailman.
"^DD",870,870,100.01,21,8,0)
 
"^DD",870,870,100.01,21,9,0)
Inbound messages that are received by the server option are placed
"^DD",870,870,100.01,21,10,0)
directly in file 772.
"^DD",870,870,100.01,"DT")
2990707
"^DD",870,870,200.01,0)
HLLP DEVICE^P3.5'^%ZIS(1,^200;1^Q
"^DD",870,870,200.01,3)
Enter the device to be used for the HLLP protocol.
"^DD",870,870,200.01,21,0)
^^3^3^2990707^
"^DD",870,870,200.01,21,1,0)
This is an entry in the Device file (#3.5). It is opened when this logical
"^DD",870,870,200.01,21,2,0)
link is started up and remains open until the link is shut down. Normally,
"^DD",870,870,200.01,21,3,0)
Vista will initiate and the connection with this serial device.
"^DD",870,870,200.01,"DT")
3050308
"^DD",870,870,200.02,0)
RE-TRANSMISSION ATTEMPTS^NJ3,0^^200;2^K:+X'=X!(X>999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,200.02,3)
Type a Number between 0 and 999, 0 Decimal Digits
"^DD",870,870,200.02,21,0)
^^3^3^2990707^
"^DD",870,870,200.02,21,1,0)
Enter the number of times to re-try sending a message.  The default is 5
"^DD",870,870,200.02,21,2,0)
tries if this field is left blank. If a single message exceeds this value
"^DD",870,870,200.02,21,3,0)
an Alert is sent to the HL7 mail group and the link is shutdown.
"^DD",870,870,200.02,"DT")
2990707
"^DD",870,870,200.021,0)
EXCEED RE-TRANSMIT ACTION^S^I:ignore;R:restart;S:shutdown;^200;10^Q
"^DD",870,870,200.021,21,0)
^^5^5^2990820^
"^DD",870,870,200.021,21,1,0)
This field determines what to do when a message exceeds the number of
"^DD",870,870,200.021,21,2,0)
 retry attempts for this Logical Link.  Actions are:
"^DD",870,870,200.021,21,3,0)
  Ignore   = send alert once and keep trying to resend
"^DD",870,870,200.021,21,4,0)
  Restart  = send alert once and shutdown link then start link
"^DD",870,870,200.021,21,5,0)
  Shutdown = send alert once and shutdown link
"^DD",870,870,200.021,"DT")
2990820
"^DD",870,870,200.03,0)
BLOCK SIZE^NJ3,0^^200;3^K:+X'=X!(X>512)!(X<9)!(X?.E1"."1N.N) X
"^DD",870,870,200.03,3)
Type a Number between 9 and 512, 0 Decimal Digits245 is the recommended default.
"^DD",870,870,200.03,"DT")
2990707
"^DD",870,870,200.04,0)
READ TIMEOUT^NJ3,0^^200;4^K:+X'=X!(X>600)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,200.04,3)
Type a Number between 1 and 600, 0 Decimal Digits
"^DD",870,870,200.04,21,0)
^^3^3^2990708^
"^DD",870,870,200.04,21,1,0)
Enter the number of seconds the Lower Layer Protocol remains in a read
"^DD",870,870,200.04,21,2,0)
state for data to come in on the link. The default is 10 seconds if this
"^DD",870,870,200.04,21,3,0)
field is left blank.
"^DD",870,870,200.04,"DT")
2990708
"^DD",870,870,200.05,0)
ACK TIMEOUT^NJ3,0^^200;5^K:+X'=X!(X>600)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,200.05,3)
Type a Number between 0 and 600, 0 Decimal Digits
"^DD",870,870,200.05,21,0)
^^4^4^3000418^^
"^DD",870,870,200.05,21,1,0)
The number of seconds the Lower Layer Protocol waits for an
"^DD",870,870,200.05,21,2,0)
acknowledgement from the receiving application. The default
"^DD",870,870,200.05,21,3,0)
is 60.  If this field is less than the READ TIMEOUT field, 
"^DD",870,870,200.05,21,4,0)
the READ TIMEOUT value will be used.
"^DD",870,870,200.05,"DT")
3000418
"^DD",870,870,200.06,0)
LLP START BLOCK^NJ3,0^^200;6^K:+X'=X!(X>300)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,200.06,3)
Type a Number between 1 and 300, 0 Decimal Digits
"^DD",870,870,200.06,21,0)
^^5^5^2990709^
"^DD",870,870,200.06,21,1,0)
Enter the numeric value of the control character used by the HLLP
"^DD",870,870,200.06,21,2,0)
communications protocol as a START BLOCK CHARACTER. While this character
"^DD",870,870,200.06,21,3,0)
is negotiable, the HL7 implementation guide recommends the use of the 'VT'
"^DD",870,870,200.06,21,4,0)
character. If this field is left blank, the default value of 11 will be
"^DD",870,870,200.06,21,5,0)
used.
"^DD",870,870,200.06,"DT")
2990709
"^DD",870,870,200.07,0)
LLP END BLOCK^NJ3,0^^200;7^K:+X'=X!(X>300)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,200.07,3)
Type a Number between 1 and 300, 0 Decimal Digits
"^DD",870,870,200.07,21,0)
^^4^4^2990709^
"^DD",870,870,200.07,21,1,0)
Enter the numeric value of the control character defined in the HLLP
"^DD",870,870,200.07,21,2,0)
specification as the END BLOCK CHARACTER. The recommended value is 28. If
"^DD",870,870,200.07,21,3,0)
this field is left blank, the default value will be 28 for the 'FS'
"^DD",870,870,200.07,21,4,0)
character.
"^DD",870,870,200.07,"DT")
2990709
"^DD",870,870,200.08,0)
PROTOCOL ID VERSION^S^21:2.1;22:2.2;23:2.3;^200;8^Q
"^DD",870,870,200.08,3)
Enter the version of HLLP as specified by the lates HL7 Implementation Guide
"^DD",870,870,200.08,21,0)
^^3^3^2990709^
"^DD",870,870,200.08,21,1,0)
The latest specification for the HLLP communications protocol is
"^DD",870,870,200.08,21,2,0)
identified by a version number, which may be different from the HL7
"^DD",870,870,200.08,21,3,0)
standard itself.
"^DD",870,870,200.08,"DT")
2990805
"^DD",870,870,200.09,0)
UNI-DIRECTIONAL WAIT^NJ2,0^^200;9^K:+X'=X!(X>10)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,200.09,3)
Type a Number between 0 and 10, 0 Decimal Digits
"^DD",870,870,200.09,21,0)
^^3^3^2990709^
"^DD",870,870,200.09,21,1,0)
The number of seconds the Lower Layer Protocol waits after sending a
"^DD",870,870,200.09,21,2,0)
messages.  This is only used if the message doesn't want an
"^DD",870,870,200.09,21,3,0)
acknowledgment.  
"^DD",870,870,200.09,"DT")
2990709
"^DD",870,870,300.01,0)
X3.28 DEVICE^P3.5^%ZIS(1,^300;1^Q
"^DD",870,870,300.01,3)
Enter the device from the Device File.
"^DD",870,870,300.01,21,0)
^^4^4^2990709^
"^DD",870,870,300.01,21,1,0)
X3.28 is a serial protocol like HLLP. It requires the remote system be
"^DD",870,870,300.01,21,2,0)
configured as a device (bi-directional) in the Device and terminal type
"^DD",870,870,300.01,21,3,0)
files. The Vista system will normally open and maintain the connection.
"^DD",870,870,300.01,21,4,0)
See the HL7 Implementation Guide for details of this protocol.
"^DD",870,870,300.01,"DT")
2990709
"^DD",870,870,300.02,0)
MAXIMUM MESSAGE SIZE^NJ7,0^^300;2^K:+X'=X!(X>9999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,300.02,3)
Type a Number between 1 and 9999999, 0 Decimal Digits
"^DD",870,870,300.02,21,0)
^^1^1^2990709^
"^DD",870,870,300.02,21,1,0)
See the HL7 Implementation Guide for details of the x3.28 protcol.
"^DD",870,870,300.02,"DT")
2990709
"^DD",870,870,300.03,0)
MAXIMUM BLOCK SIZE^NJ3,0^^300;3^K:+X'=X!(X>245)!(X<9)!(X?.E1"."1N.N) X
"^DD",870,870,300.03,3)
Type a Number between 9 and 245, 0 Decimal Digits
"^DD",870,870,300.03,21,0)
^.001^1^1^3010312^^
"^DD",870,870,300.03,21,1,0)
See the HL7 Implementation Guide for details of the x3.28 protcol.
"^DD",870,870,300.03,"DT")
2990709
"^DD",870,870,300.04,0)
TIMER A^NJ2,0^^300;4^K:+X'=X!(X>60)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,300.04,3)
Type a Number between 1 and 60, 0 Decimal Digits
"^DD",870,870,300.04,21,0)
^^2^2^2990709^
"^DD",870,870,300.04,21,1,0)
Enter the time in seconds for the Response Timer. The default is 6 seconds
"^DD",870,870,300.04,21,2,0)
if no time is entered.
"^DD",870,870,300.04,"DT")
2990709
"^DD",870,870,300.05,0)
TIMER B^NJ2,0^^300;5^K:+X'=X!(X>60)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,300.05,3)
Type a Number between 1 and 60, 0 Decimal Digits
"^DD",870,870,300.05,21,0)
^^2^2^2990709^
"^DD",870,870,300.05,21,1,0)
Enter the time in seconds for the Receive Timer. The default is 3 seconds
"^DD",870,870,300.05,21,2,0)
if no time is entered.
"^DD",870,870,300.05,"DT")
2990709
"^DD",870,870,300.06,0)
TIMER D^NJ2,0^^300;6^K:+X'=X!(X>60)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,300.06,3)
Type a Number between 1 and 60, 0 Decimal Digits
"^DD",870,870,300.06,21,0)
^^2^2^2990709^
"^DD",870,870,300.06,21,1,0)
Enter the time for the Inter-Block timer. The default is 30 seconds if no
"^DD",870,870,300.06,21,2,0)
time is specified.
"^DD",870,870,300.06,"DT")
2990709
"^DD",870,870,300.07,0)
TIMER E^NJ3,0^^300;7^K:+X'=X!(X>600)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,300.07,3)
Type a Number between 1 and 600, 0 Decimal Digits
"^DD",870,870,300.07,21,0)
^^2^2^2990709^
"^DD",870,870,300.07,21,1,0)
Enter the time for the Line Check Timer. The default is 180 seconds is no
"^DD",870,870,300.07,21,2,0)
time is specified.
"^DD",870,870,300.07,"DT")
2990709
"^DD",870,870,400.01,0)
TCP/IP ADDRESS^F^^400;1^K:$L(X)>40!($L(X)<7) X
"^DD",870,870,400.01,3)
Answer must be 7-40 characters in length.
"^DD",870,870,400.01,21,0)
^^1^1^2990709^
"^DD",870,870,400.01,21,1,0)
Enter the numeric address of the remote site using the syntax, nn.nn.nn.nn
"^DD",870,870,400.01,"DT")
3041012
"^DD",870,870,400.02,0)
TCP/IP PORT^NJ5,0^^400;2^K:+X'=X!(X>65535)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,400.02,3)
Type a Number between 1 and 65535, 0 Decimal Digits
"^DD",870,870,400.02,21,0)
^^3^3^2990709^
"^DD",870,870,400.02,21,1,0)
This is the port over which the HL7 service will create a socket for
"^DD",870,870,400.02,21,2,0)
message exchange. In VA, this port will be 5000 between production
"^DD",870,870,400.02,21,3,0)
systems.
"^DD",870,870,400.02,"DT")
2990709
"^DD",870,870,400.03,0)
TCP/IP SERVICE TYPE^S^C:CLIENT (SENDER);S:SINGLE LISTENER;M:MULTI LISTENER;^400;3^Q
"^DD",870,870,400.03,1,0)
^.1
"^DD",870,870,400.03,1,1,0)
870^E
"^DD",870,870,400.03,1,1,1)
S ^HLCS(870,"E",$E(X,1,30),DA)=""
"^DD",870,870,400.03,1,1,2)
K ^HLCS(870,"E",$E(X,1,30),DA)
"^DD",870,870,400.03,1,1,"DT")
3030710
"^DD",870,870,400.03,3)
Does this link send a connection request or receive connection requests?
"^DD",870,870,400.03,21,0)
^.001^12^12^3040826^^
"^DD",870,870,400.03,21,1,0)
This field determines if the Logical Link is the client (sender) or a
"^DD",870,870,400.03,21,2,0)
listener (server) of a message.  Choose from:
"^DD",870,870,400.03,21,3,0)
 
"^DD",870,870,400.03,21,4,0)
                                
"^DD",870,870,400.03,21,5,0)
 CLIENT (SENDER): Indicates that this Logical Link connects to a target
"^DD",870,870,400.03,21,6,0)
system, with the current system acting as the sender.
"^DD",870,870,400.03,21,7,0)
 
"^DD",870,870,400.03,21,8,0)
 SINGLE LISTENER: Designates that the current system is a server
"^DD",870,870,400.03,21,9,0)
(listener), using a single M process to do the listening.
"^DD",870,870,400.03,21,10,0)
                                 
"^DD",870,870,400.03,21,11,0)
 MULTI LISTENER: Designates that the current system is a server
"^DD",870,870,400.03,21,12,0)
(listener), creating multiple background processes.
"^DD",870,870,400.03,"DT")
3050308
"^DD",870,870,400.04,0)
PERSISTENT^S^Y:YES;N:NO;^400;4^Q
"^DD",870,870,400.04,21,0)
^^5^5^2990709^
"^DD",870,870,400.04,21,1,0)
Enter 'YES' if this connection needs to remain open even if there are no
"^DD",870,870,400.04,21,2,0)
messages to send. The connection will remain open until it is disconnected
"^DD",870,870,400.04,21,3,0)
by either side via shutting-down the logical link.  A setting of 'YES' is
"^DD",870,870,400.04,21,4,0)
appropriate for connecting to a COTS device with a high volume of
"^DD",870,870,400.04,21,5,0)
messages.  
"^DD",870,870,400.04,"DT")
2990709
"^DD",870,870,400.05,0)
RETENTION^NJ6,0^^400;5^K:+X'=X!(X>999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870,400.05,3)
Type a Number between 0 and 999999, 0 Decimal Digits
"^DD",870,870,400.05,21,0)
^^6^6^2990709^
"^DD",870,870,400.05,21,1,0)
Retention is the maximum time in seconds in which a non-persistent LLP
"^DD",870,870,400.05,21,2,0)
will wait after the associated queue has been emptied.  If further
"^DD",870,870,400.05,21,3,0)
messages arrive in the queue before the retention time has expired, the
"^DD",870,870,400.05,21,4,0)
LLP will continue to dequeue and send messages. Otherwise, the LLP will
"^DD",870,870,400.05,21,5,0)
become inactive and will remain inactive until further messages are
"^DD",870,870,400.05,21,6,0)
queued.  
"^DD",870,870,400.05,"DT")
2990709
"^DD",870,870,400.06,0)
STARTUP NODE^P14.7'^%ZIS(14.7,^400;6^Q
"^DD",870,870,400.06,3)
Enter the Taskman node to start this LLP on.
"^DD",870,870,400.06,21,0)
^^5^5^2990709^
"^DD",870,870,400.06,21,1,0)
This field is ONLY for VMS sites running Dual Taskman in DCL. This field
"^DD",870,870,400.06,21,2,0)
is used to specify what Taskman node you want to job the Lower Level
"^DD",870,870,400.06,21,3,0)
Protocol. It should only be used if you have two Taskmans running and only
"^DD",870,870,400.06,21,4,0)
want the LLP to run on a particular node.  It will only work if you are
"^DD",870,870,400.06,21,5,0)
running the dual Taskmans in DCL context on a VMS system.
"^DD",870,870,400.06,"DT")
2990709
"^DD",870,870,400.07,0)
SAY HELO^S^Y:YES;N:NO;^400;7^Q
"^DD",870,870,400.07,3)
Send initial HELO for Cache/NT TCP links?
"^DD",870,870,400.07,21,0)
^.001^6^6^3001103^^^^
"^DD",870,870,400.07,21,1,0)
This field is applicable only to Cache/NT sites with TCP links.
"^DD",870,870,400.07,21,2,0)
If you are not a Cache/NT site, or this is not a TCP link, this field
"^DD",870,870,400.07,21,3,0)
does not apply, AND will be ignored.
"^DD",870,870,400.07,21,4,0)

"^DD",870,870,400.07,21,5,0)
If this TCP link is for a VA site, answer YES.
"^DD",870,870,400.07,21,6,0)
If this TCP link is for a COTS system, answer NO.  This is the default.
"^DD",870,870,400.07,23,0)
^.001^4^4^3001103^^^
"^DD",870,870,400.07,23,1,0)
When sending HL7 transactions to other VA sites over TCP links, Cache/NT
"^DD",870,870,400.07,23,2,0)
sites must send an initial HELO to overcome buffering issues.  However,
"^DD",870,870,400.07,23,3,0)
the initial HELO is not part of the HL7 standard, and may cause a reject
"^DD",870,870,400.07,23,4,0)
error when sent to a COTS system.
"^DD",870,870,400.07,"DT")
3001102
"^DD",870,870,400.08,0)
TCP/IP PORT (OPTIMIZED)^NJ5,0^^400;8^K:+X'=X!(X>65535)!(X<1)!(X?.E1"."1N.N) X
"^DD",870,870,400.08,3)
Enter the port to use for the new HL7 'optimized' server, a number between 1 and 65535. 5001 is the default.
"^DD",870,870,400.08,21,0)
^.001^4^4^3050216^^^
"^DD",870,870,400.08,21,1,0)
The new HL7 'optimized' server will operate concurrently with the  old
"^DD",870,870,400.08,21,2,0)
HL7 1.6 server.  To  enable that, the two servers are assigned different ports
"^DD",870,870,400.08,21,3,0)
to listen on.  The default port for the old HL7 server is 5000, whereas 
"^DD",870,870,400.08,21,4,0)
the new optimized HL7 server uses port 5001.
"^DD",870,870,400.08,"DT")
3050216
"^DD",870,870.01,0)
OUT QUEUE SUB-FIELD^^6^7
"^DD",870,870.01,0,"DIK")
HL870
"^DD",870,870.01,0,"DT")
3041014
"^DD",870,870.01,0,"IX","B",870.01,.01)

"^DD",870,870.01,0,"NM","OUT QUEUE")

"^DD",870,870.01,0,"UP")
870
"^DD",870,870.01,.01,0)
MESSAGE NUMBER^NJ15,0^^0;1^K:+X'=X!(X>999999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870.01,.01,1,0)
^.1^^-1
"^DD",870,870.01,.01,1,1,0)
870.01^B
"^DD",870,870.01,.01,1,1,1)
S ^HLCS(870,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",870,870.01,.01,1,1,2)
K ^HLCS(870,DA(1),2,"B",$E(X,1,30),DA)
"^DD",870,870.01,.01,3)
Not editable from any user option. See Field Description.
"^DD",870,870.01,.01,21,0)
^^2^2^2941213^
"^DD",870,870.01,.01,21,1,0)
This is the number assigned to the message when it is enque'd into
"^DD",870,870.01,.01,21,2,0)
the FIFO queue.
"^DD",870,870.01,.01,"DT")
2941102
"^DD",870,870.01,1,0)
STATUS^S^P:PENDING;D:DONE PROCESSING;S:STUB RECORD;^0;2^Q
"^DD",870,870.01,1,1,0)
^.1^^0
"^DD",870,870.01,1,3)
This is the status of an individual message in the queue. These statuses control the flow and processing of the message.
"^DD",870,870.01,1,21,0)
^^6^6^2941213^^
"^DD",870,870.01,1,21,1,0)
Status of a particular message. Can be Stub, Pending, or Done. These
"^DD",870,870.01,1,21,2,0)
statuses control the processing of a message. For example, a stub
"^DD",870,870.01,1,21,3,0)
record is created when a message is enque'd, it cannot be processed
"^DD",870,870.01,1,21,4,0)
until it's status is changed from a 'stub' to 'pending', this is
"^DD",870,870.01,1,21,5,0)
the last thing HLCS1 does when dequeueing a message from file #772
"^DD",870,870.01,1,21,6,0)
and enqueueing it into file #870.
"^DD",870,870.01,1,"DT")
3000508
"^DD",870,870.01,2,0)
ERROR^S^A:LLP ACKNOWLEDGED NO ERROR;C:LLP CHAR COUNT WRONG;X:LLP XOR WRONG;B:DATA TOO LONG;G:OTHER LLP ERROR;^0;3^Q
"^DD",870,870.01,2,3)
This field is not editable from any user option. See field description.
"^DD",870,870.01,2,21,0)
^^3^3^2941213^
"^DD",870,870.01,2,21,1,0)
If this field contains a "C","X","B", or a "G" it means an error has
"^DD",870,870.01,2,21,2,0)
occured while attempting to send a message to another application.
"^DD",870,870.01,2,21,3,0)
This field is not editable from any user option.
"^DD",870,870.01,2,"DT")
2941117
"^DD",870,870.01,3,0)
MESSAGE TEXT^870.13^^1;0
"^DD",870,870.01,3,21,0)
^^1^1^2941213^
"^DD",870,870.01,3,21,1,0)
This field contains the text of the message.
"^DD",870,870.01,4,0)
dhcp-longtitudinal checksum^F^^0;4^K:$L(X)>5!($L(X)<1) X
"^DD",870,870.01,4,3)
Answer must be 1-5 characters in length.
"^DD",870,870.01,4,"DT")
2950113
"^DD",870,870.01,5,0)
dhcp-xor checksum^F^^0;5^K:$L(X)>3!($L(X)<1) X
"^DD",870,870.01,5,3)
Answer must be 1-3 characters in length.
"^DD",870,870.01,5,"DT")
2950113
"^DD",870,870.01,6,0)
IEN772 OutQ-Non-TCP^F^^0;6^K:$L(X)>30!($L(X)<1)!'(X?.N) X
"^DD",870,870.01,6,3)
Answer must be 1-30 numeric digits in length.
"^DD",870,870.01,6,21,0)
^^1^1^3041221^
"^DD",870,870.01,6,21,1,0)
The ien of file #772, where this sub-entry is copied from.
"^DD",870,870.01,6,"DT")
3041221
"^DD",870,870.019,0)
IN QUEUE SUB-FIELD^^9^10
"^DD",870,870.019,0,"DIK")
HL870
"^DD",870,870.019,0,"DT")
3041014
"^DD",870,870.019,0,"IX","B",870.019,.01)

"^DD",870,870.019,0,"NM","IN QUEUE")

"^DD",870,870.019,0,"UP")
870
"^DD",870,870.019,.01,0)
MESSAGE NUMBER^NJ15,0^^0;1^K:+X'=X!(X>999999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",870,870.019,.01,1,0)
^.1^^-1
"^DD",870,870.019,.01,1,1,0)
870.019^B
"^DD",870,870.019,.01,1,1,1)
S ^HLCS(870,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",870,870.019,.01,1,1,2)
K ^HLCS(870,DA(1),1,"B",$E(X,1,30),DA)
"^DD",870,870.019,.01,3)
Not editable from any user option. See field description.
"^DD",870,870.019,.01,21,0)
^^2^2^2941213^^^
"^DD",870,870.019,.01,21,1,0)
This is the number assigned to the message when it is enqued into the
"^DD",870,870.019,.01,21,2,0)
FIFO queue.
"^DD",870,870.019,.01,"DT")
2941102
"^DD",870,870.019,1,0)
STATUS^S^P:PENDING;D:DONE PROCESSING;S:STUB RECORD;^0;2^Q
"^DD",870,870.019,1,1,0)
^.1
"^DD",870,870.019,1,1,1,0)
870^AISTAT
"^DD",870,870.019,1,1,1,1)
S ^HLCS(870,"AISTAT",$E(X,1,30),DA(1),DA)=""
"^DD",870,870.019,1,1,1,2)
K ^HLCS(870,"AISTAT",$E(X,1,30),DA(1),DA)
"^DD",870,870.019,1,1,1,"%D",0)
^.101^2^2^3001115^^^
"^DD",870,870.019,1,1,1,"%D",1,0)
Used to quickly identify links with messages in any status,
"^DD",870,870.019,1,1,1,"%D",2,0)
thus improving performance.
"^DD",870,870.019,1,1,1,"DT")
3000508
"^DD",870,870.019,1,3)
This is the status of an individual message in the queue. These statuses control the flow and processing of the message.
"^DD",870,870.019,1,21,0)
^.001^7^7^3001115^^^^
"^DD",870,870.019,1,21,1,0)
Status of a particular message. Can be Stub, Pending, or Done.
"^DD",870,870.019,1,21,2,0)
These statuses control the processing of a message. For example, a
"^DD",870,870.019,1,21,3,0)
stub record is created when a message is enqueued, and cannot be
"^DD",870,870.019,1,21,4,0)
processed until its status is changed from 'stub' to 'pending'.
"^DD",870,870.019,1,21,5,0)
Changing this status is the last thing the Low Layer Protocol does
"^DD",870,870.019,1,21,6,0)
after reading in a message.  Finally, once the message has been
"^DD",870,870.019,1,21,7,0)
processed, its status is changed to 'done'.
"^DD",870,870.019,1,"DT")
3000508
"^DD",870,870.019,2,0)
ERROR^S^A:LLP ACKNOWLEDGED NO ERROR;C:LLP CHAR COUNT WRONG;X:LLP XOR WRONG;B:DATA TOO LONG;G:OTHER LLP ERROR;^0;3^Q
"^DD",870,870.019,2,3)
This field is not editable from any user option. See Field Description.
"^DD",870,870.019,2,21,0)
^^3^3^2941213^^
"^DD",870,870.019,2,21,1,0)
If this field contains a "C","X","B", or a "G" it means an error has
"^DD",870,870.019,2,21,2,0)
ocurred while reading in a message. This field is not editable from
"^DD",870,870.019,2,21,3,0)
any user option.
"^DD",870,870.019,2,"DT")
2941027
"^DD",870,870.019,3,0)
MESSAGE TEXT^870.193^^1;0
"^DD",870,870.019,3,21,0)
^^1^1^2941213^^
"^DD",870,870.019,3,21,1,0)
This field contains the text of the message.
"^DD",870,870.019,4,0)
tvv^F^^0;4^K:$L(X)>3!($L(X)<3) X
"^DD",870,870.019,4,3)
Answer must be 3 characters in length.
"^DD",870,870.019,4,"DT")
2950112
"^DD",870,870.019,5,0)
ccccc^F^^0;5^K:$L(X)>5!($L(X)<1) X
"^DD",870,870.019,5,3)
Answer must be 1-5 characters in length.
"^DD",870,870.019,5,"DT")
2950113
"^DD",870,870.019,6,0)
xxx^F^^0;6^K:$L(X)>3!($L(X)<1) X
"^DD",870,870.019,6,3)
Answer must be 1-3 characters in length.
"^DD",870,870.019,6,"DT")
2950113
"^DD",870,870.019,7,0)
dhcp-longtitudinal checksum^F^^0;7^K:$L(X)>5!($L(X)<1) X
"^DD",870,870.019,7,3)
Answer must be 1-5 characters in length.
"^DD",870,870.019,7,"DT")
2950113
"^DD",870,870.019,8,0)
dhcp-xor checksum^F^^0;8^K:$L(X)>3!($L(X)<1) X
"^DD",870,870.019,8,3)
Answer must be 1-3 characters in length.
"^DD",870,870.019,8,"DT")
2950113
"^DD",870,870.019,9,0)
IEN772 InQ-Non-TCP^F^^0;9^K:$L(X)>30!($L(X)<1)!'(X?.N) X
"^DD",870,870.019,9,3)
Answer must be 1-30 numeric digits in length.
"^DD",870,870.019,9,21,0)
^^1^1^3041221^
"^DD",870,870.019,9,21,1,0)
The ien of file #772, where this sub-entry is copied to. 
"^DD",870,870.019,9,"DT")
3041221
"^DD",870,870.13,0)
MESSAGE TEXT SUB-FIELD^^.01^1
"^DD",870,870.13,0,"DT")
2941006
"^DD",870,870.13,0,"NM","MESSAGE TEXT")

"^DD",870,870.13,0,"UP")
870.01
"^DD",870,870.13,.01,0)
MESSAGE TEXT^WL^^0;1^Q
"^DD",870,870.13,.01,"DT")
2941006
"^DD",870,870.193,0)
MESSAGE TEXT SUB-FIELD^^.01^1
"^DD",870,870.193,0,"DT")
2941006
"^DD",870,870.193,0,"NM","MESSAGE TEXT")

"^DD",870,870.193,0,"UP")
870.019
"^DD",870,870.193,.01,0)
MESSAGE TEXT^WL^^0;1^Q
"^DD",870,870.193,.01,3)
This field contains the actual text of the message.
"^DD",870,870.193,.01,"DT")
2941006
"^DIC",777,777,0)
HLO MESSAGE BODY^777
"^DIC",777,777,0,"GL")
^HLA(
"^DIC",777,777,"%",0)
^1.005^^0
"^DIC",777,777,"%D",0)
^1.001^3^3^3050215^^^
"^DIC",777,777,"%D",1,0)
Contains the body of an HL7 message, which excludes the message header 
"^DIC",777,777,"%D",2,0)
segment.  For batch messages, it does not include the individual message 
"^DIC",777,777,"%D",3,0)
header segments or the batch trailer segment.
"^DIC",777,"B","HLO MESSAGE BODY",777)

"^DIC",778,778,0)
HLO MESSAGES^778
"^DIC",778,778,0,"GL")
^HLB(
"^DIC",778,778,"%",0)
^1.005^^0
"^DIC",778,778,"%D",0)
^1.001^3^3^3050317^^^
"^DIC",778,778,"%D",1,0)
Used to record each message as it is sent or received.  The content of the
"^DIC",778,778,"%D",2,0)
message is stored in a file #777, as it might be sent to multiple locations
"^DIC",778,778,"%D",3,0)
and applications.
"^DIC",778,"B","HLO MESSAGES",778)

"^DIC",779.1,779.1,0)
HLO SYSTEM PARAMETERS^779.1
"^DIC",779.1,779.1,0,"GL")
^HLD(779.1,
"^DIC",779.1,779.1,"%",0)
^1.005^^0
"^DIC",779.1,779.1,"%D",0)
^1.001^2^2^3050801^^^^
"^DIC",779.1,779.1,"%D",1,0)
This file contains parameters used by the HLO (HL7 Optimized)
"^DIC",779.1,779.1,"%D",2,0)
that are specific to the system the software is installed on.
"^DIC",779.1,"B","HLO SYSTEM PARAMETERS",779.1)

"^DIC",779.2,779.2,0)
HLO APPLICATION REGISTRY^779.2
"^DIC",779.2,779.2,0,"GL")
^HLD(779.2,
"^DIC",779.2,779.2,"%",0)
^1.005^^0
"^DIC",779.2,779.2,"%D",0)
^^12^12^3050801^^^^
"^DIC",779.2,779.2,"%D",1,0)
This file is used to register sending and receiving applications for HL7
"^DIC",779.2,779.2,"%D",2,0)
messaging. For receiving applications, the process of registration consists of
"^DIC",779.2,779.2,"%D",3,0)
registering what messages the application is prepared to receive.
"^DIC",779.2,779.2,"%D",4,0)

"^DIC",779.2,779.2,"%D",5,0)
For both sending and receiving applications, it is necessary to specify
"^DIC",779.2,779.2,"%D",6,0)
what package the application belongs to.  For sending applications, that is
"^DIC",779.2,779.2,"%D",7,0)
the only field that applies, other than the name of the sending application.
"^DIC",779.2,779.2,"%D",8,0)

"^DIC",779.2,779.2,"%D",9,0)
An application can be either a sender or a receiver of messages, or both. In 
"^DIC",779.2,779.2,"%D",10,0)
order for an application to receive messages, it must specify an action 
"^DIC",779.2,779.2,"%D",11,0)
(M tag^routine) for each type of message that it is capable of receiving, or a
"^DIC",779.2,779.2,"%D",12,0)
default action that applies when no messsage-specific action is defined.
"^DIC",779.2,"B","HLO APPLICATION REGISTRY",779.2)

"^DIC",779.3,779.3,0)
HLO PROCESS REGISTRY^779.3
"^DIC",779.3,779.3,0,"GL")
^HLD(779.3,
"^DIC",779.3,779.3,"%",0)
^1.005^^0
"^DIC",779.3,779.3,"%D",0)
^^2^2^3050801^^^
"^DIC",779.3,779.3,"%D",1,0)
The process registry is used by the HLO process manager to start, stop, and
"^DIC",779.3,779.3,"%D",2,0)
manage all of the processes used by the HLO system.
"^DIC",779.3,"B","HLO PROCESS REGISTRY",779.3)

"^DIC",779.4,779.4,0)
HLO SUBSCRIPTION REGISTRY^779.4
"^DIC",779.4,779.4,0,"GL")
^HLD(779.4,
"^DIC",779.4,779.4,"%",0)
^1.005^^0
"^DIC",779.4,779.4,"%D",0)
^1.001^6^6^3050215^^^
"^DIC",779.4,779.4,"%D",1,0)
This file is used to store static routing lists for messages.  
"^DIC",779.4,779.4,"%D",2,0)
 
"^DIC",779.4,779.4,"%D",3,0)
Static routing lists are lists of recipients that an application may create in
"^DIC",779.4,779.4,"%D",4,0)
advance for its messages.  The alternate routing method is dynamic routing, 
"^DIC",779.4,779.4,"%D",5,0)
whereby the recipient list is created by the application at the time the 
"^DIC",779.4,779.4,"%D",6,0)
message is created.
"^DIC",779.4,"B","HLO SUBSCRIPTION REGISTRY",779.4)

"^DIC",870,870,0)
HL LOGICAL LINK^870
"^DIC",870,870,0,"GL")
^HLCS(870,
"^DIC",870,870,"%",0)
^1.005^^0
"^DIC",870,870,"%D",0)
^^21^21^2990607^^^^
"^DIC",870,870,"%D",1,0)
This file serves two purposes. It is a fileman-compatible transmission
"^DIC",870,870,"%D",2,0)
log. The Low Layer Protocols write and read directly from this file.
"^DIC",870,870,"%D",3,0)
(See routines HLCSDR1 and HLCSDR2)
"^DIC",870,870,"%D",4,0)
 
"^DIC",870,870,"%D",5,0)
This file stores parameters that govern the behaviour of the Low Layer
"^DIC",870,870,"%D",6,0)
Protocols. Fields like: READ TIMEOUT, ACK TIMEOUT, LLP START BLOCK, and
"^DIC",870,870,"%D",7,0)
LLP END BLOCK, are fields that govern how long the finite state machine
"^DIC",870,870,"%D",8,0)
waits for data to come down the line (READ TIMEOUT), how long it waits
"^DIC",870,870,"%D",9,0)
for a lower level acknowledgement (ACK TIMEOUT), and which control
"^DIC",870,870,"%D",10,0)
characters define the beginning and end of a message (LLP START BLOCK
"^DIC",870,870,"%D",11,0)
and LLP END BLOCK).
"^DIC",870,870,"%D",12,0)
 
"^DIC",870,870,"%D",13,0)
This file also stores information that drives the SYSTEMS LINK MONITOR
"^DIC",870,870,"%D",14,0)
display option. Fields like, IN QUEUE FRONT POINTER, IN QUEUE BACK 
"^DIC",870,870,"%D",15,0)
POINTER are used to manage the data flow in the queues but they are
"^DIC",870,870,"%D",16,0)
also displayed on the SYSTEMS LINK MONITOR under the alias's MESSAGES
"^DIC",870,870,"%D",17,0)
PROCESSED and MESSAGES RECEIVED. Fields like STATE and DEVICE TYPE
"^DIC",870,870,"%D",18,0)
are also used to drive the SYSTEMS LINK MONITOR. These fields are
"^DIC",870,870,"%D",19,0)
updated by the lower layer protocols in order to give real-time feedback
"^DIC",870,870,"%D",20,0)
as to what is ocurring on a link. For example, when a message is 
"^DIC",870,870,"%D",21,0)
received (see HLCSDR1) the state transitions from "IDLE" to "READING".
"^DIC",870,"B","HL LOGICAL LINK",870)

"BLD",838,6)
^SEQ #101
**END**
**END**
