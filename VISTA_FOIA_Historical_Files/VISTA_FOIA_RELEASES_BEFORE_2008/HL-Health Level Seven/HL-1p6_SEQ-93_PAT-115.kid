EMERGENCY Released HL*1.6*115 SEQ #93
Extracted from mail message
**KIDS**:HL*1.6*115^

**INSTALL NAME**
HL*1.6*115
"BLD",810,0)
HL*1.6*115^HEALTH LEVEL SEVEN^0^3040317^y
"BLD",810,1,0)
^^2^2^3040226^^
"BLD",810,1,1,0)
Please see the patch description in the National Patch Module for a complete
"BLD",810,1,2,0)
description of this patch.
"BLD",810,4,0)
^9.64PA^^
"BLD",810,"ABPKG")
n
"BLD",810,"KRN",0)
^9.67PA^8989.52^19
"BLD",810,"KRN",.4,0)
.4
"BLD",810,"KRN",.401,0)
.401
"BLD",810,"KRN",.402,0)
.402
"BLD",810,"KRN",.403,0)
.403
"BLD",810,"KRN",.5,0)
.5
"BLD",810,"KRN",.84,0)
.84
"BLD",810,"KRN",3.6,0)
3.6
"BLD",810,"KRN",3.8,0)
3.8
"BLD",810,"KRN",9.2,0)
9.2
"BLD",810,"KRN",9.8,0)
9.8
"BLD",810,"KRN",9.8,"NM",0)
^9.68A^4^4
"BLD",810,"KRN",9.8,"NM",1,0)
HLTP3^^0^B59434010
"BLD",810,"KRN",9.8,"NM",2,0)
HLCSIN^^0^B18983334
"BLD",810,"KRN",9.8,"NM",3,0)
HLDIE773^^0^B17417520
"BLD",810,"KRN",9.8,"NM",4,0)
HLMA^^0^B36491876
"BLD",810,"KRN",9.8,"NM","B","HLCSIN",2)

"BLD",810,"KRN",9.8,"NM","B","HLDIE773",3)

"BLD",810,"KRN",9.8,"NM","B","HLMA",4)

"BLD",810,"KRN",9.8,"NM","B","HLTP3",1)

"BLD",810,"KRN",19,0)
19
"BLD",810,"KRN",19,"NM",0)
^9.68A^^
"BLD",810,"KRN",19.1,0)
19.1
"BLD",810,"KRN",19.1,"NM",0)
^9.68A^^
"BLD",810,"KRN",101,0)
101
"BLD",810,"KRN",409.61,0)
409.61
"BLD",810,"KRN",771,0)
771
"BLD",810,"KRN",870,0)
870
"BLD",810,"KRN",8989.51,0)
8989.51
"BLD",810,"KRN",8989.52,0)
8989.52
"BLD",810,"KRN",8994,0)
8994
"BLD",810,"KRN","B",.4,.4)

"BLD",810,"KRN","B",.401,.401)

"BLD",810,"KRN","B",.402,.402)

"BLD",810,"KRN","B",.403,.403)

"BLD",810,"KRN","B",.5,.5)

"BLD",810,"KRN","B",.84,.84)

"BLD",810,"KRN","B",3.6,3.6)

"BLD",810,"KRN","B",3.8,3.8)

"BLD",810,"KRN","B",9.2,9.2)

"BLD",810,"KRN","B",9.8,9.8)

"BLD",810,"KRN","B",19,19)

"BLD",810,"KRN","B",19.1,19.1)

"BLD",810,"KRN","B",101,101)

"BLD",810,"KRN","B",409.61,409.61)

"BLD",810,"KRN","B",771,771)

"BLD",810,"KRN","B",870,870)

"BLD",810,"KRN","B",8989.51,8989.51)

"BLD",810,"KRN","B",8989.52,8989.52)

"BLD",810,"KRN","B",8994,8994)

"BLD",810,"QUES",0)
^9.62^^
"BLD",810,"REQB",0)
^9.611^1^1
"BLD",810,"REQB",1,0)
HL*1.6*109^2
"BLD",810,"REQB","B","HL*1.6*109",1)

"MBREQ")
0
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
115^3040317
"PKG",9,22,1,"PAH",1,1,0)
^^2^2^3040317
"PKG",9,22,1,"PAH",1,1,1,0)
Please see the patch description in the National Patch Module for a complete
"PKG",9,22,1,"PAH",1,1,2,0)
description of this patch.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
4
"RTN","HLCSIN")
0^2^B18983334
"RTN","HLCSIN",1,0)
HLCSIN ;ALB/JRP - INCOMING FILER;01-MAY-95 ;11/15/2000  09:37
"RTN","HLCSIN",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**2,30,14,19,62,109,115**;Oct 13, 1995
"RTN","HLCSIN",3,0)
STARTIN ;Main entry point for incoming background filer
"RTN","HLCSIN",4,0)
 ;Create/find entry denoting this filer in the INCOMING FILER TASK
"RTN","HLCSIN",5,0)
 ; NUMBER multiple (field #20) of the HL COMMUNICATION SERVER PARAMETER
"RTN","HLCSIN",6,0)
 ; file (#869.3)
"RTN","HLCSIN",7,0)
 ;N HLOGLINK,HLNODE,HLPARENT,HLST1,TMP ; These vbls aren't used!
"RTN","HLCSIN",8,0)
 N HLFLG,HLEXIT,HLPTRFLR
"RTN","HLCSIN",9,0)
 S HLPTRFLR=+$$CRTFLR^HLCSUTL1(ZTSK,"IN")
"RTN","HLCSIN",10,0)
 ;Loop through Logical Links and check for incoming messages
"RTN","HLCSIN",11,0)
 S HLEXIT=0
"RTN","HLCSIN",12,0)
 F  D  Q:HLEXIT
"RTN","HLCSIN",13,0)
 . S HLFLG=0
"RTN","HLCSIN",14,0)
 . D DEFACK(.HLPTRFLR,.HLFLG,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",15,0)
 . D ACKNOW(.HLPTRFLR,.HLFLG,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",16,0)
 . Q:HLFLG
"RTN","HLCSIN",17,0)
 . I $$HDIFF^XLFDT($H,$G(HLPTRFLR("LASTDEL")),2)>3600 D  Q
"RTN","HLCSIN",18,0)
 . . S HLPTRFLR("LASTDEL")=$H    ; maintain queue sizes
"RTN","HLCSIN",19,0)
 . . D DELQUE(.HLPTRFLR,.HLEXIT) ; no more than once an hour.
"RTN","HLCSIN",20,0)
 . H 5
"RTN","HLCSIN",21,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",22,0)
 S ZTSTOP=1 ;Asked to stop
"RTN","HLCSIN",23,0)
 D DELFLR^HLCSUTL1(HLPTRFLR,"IN") ;Delete entry denoting this filer
"RTN","HLCSIN",24,0)
 S ZTREQ="@"
"RTN","HLCSIN",25,0)
 Q
"RTN","HLCSIN",26,0)
DEFACK(HLPTRFLR,HLFLG,HLEXIT) ; Process TCP links with a deferred response
"RTN","HLCSIN",27,0)
 N HLXX,HLD0,HLPCT
"RTN","HLCSIN",28,0)
 S HLXX=0
"RTN","HLCSIN",29,0)
 F  S HLXX=$O(^HLMA("AC","I",HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",30,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",31,0)
 . ; HL*1.6*109
"RTN","HLCSIN",32,0)
 . L +^HLMA("AC","I",HLXX):0 Q:'$T  ;*109*Does another filer have this?
"RTN","HLCSIN",33,0)
 . S HLD0=0,HLFLG=1
"RTN","HLCSIN",34,0)
 . ; HL*1.6*109 changes in for loop below, and post-quit code placed
"RTN","HLCSIN",35,0)
 . ; on following lines.
"RTN","HLCSIN",36,0)
 . S HLPCT=0 ; Counter whether filer should stop every 100th entry.
"RTN","HLCSIN",37,0)
 .;**109 - insure queue last processed at least 2 seconds ago
"RTN","HLCSIN",38,0)
 . I ($$HDIFF^XLFDT($H,$G(^XTMP("HL7-AC","I",HLXX)),2)<2) L -^HLMA("AC","I",HLXX) Q
"RTN","HLCSIN",39,0)
 . F  S HLD0=$O(^HLMA("AC","I",HLXX,HLD0)) Q:'HLD0!(HLEXIT)  D
"RTN","HLCSIN",40,0)
 . . S HLPCT=HLPCT+1
"RTN","HLCSIN",41,0)
 . . I '(HLPCT#100) D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",42,0)
 . . L +^HLMA(HLD0):0 Q:'$T
"RTN","HLCSIN",43,0)
 . . I '$$CHECKAC("I",HLXX,HLD0) L -^HLMA(HLD0) Q  ;-> Quit if not a valid AC xref
"RTN","HLCSIN",44,0)
 . . D DEFACK^HLTP3(HLXX,HLD0)
"RTN","HLCSIN",45,0)
 . . D DEQUE^HLCSREP(HLXX,"I",HLD0)
"RTN","HLCSIN",46,0)
 . . L -^HLMA(HLD0)
"RTN","HLCSIN",47,0)
 . ;**109 -add dt/tm stamp to time queue last processed
"RTN","HLCSIN",48,0)
 . S ^XTMP("HL7-AC","I",HLXX)=$H
"RTN","HLCSIN",49,0)
 . ;**109 -unlock the queue
"RTN","HLCSIN",50,0)
 . L -^HLMA("AC","I",HLXX)
"RTN","HLCSIN",51,0)
 Q
"RTN","HLCSIN",52,0)
 ;
"RTN","HLCSIN",53,0)
CHECKAC(WAY,IEN870,IEN773) ; If AC xref shouldn't exist, kill it...
"RTN","HLCSIN",54,0)
 ;
"RTN","HLCSIN",55,0)
 ; Check status and if 3 (processed) kill XREF...
"RTN","HLCSIN",56,0)
 I $P($G(^HLMA(+IEN773,"P")),U)=3 D  QUIT "" ;->
"RTN","HLCSIN",57,0)
 .  D DEQUE^HLCSREP(IEN870,WAY,IEN773)
"RTN","HLCSIN",58,0)
 ;
"RTN","HLCSIN",59,0)
 ; Add other checks here in the future...
"RTN","HLCSIN",60,0)
 ;
"RTN","HLCSIN",61,0)
 Q 1
"RTN","HLCSIN",62,0)
 ;
"RTN","HLCSIN",63,0)
ACKNOW(HLPTRFLR,HLFLG,HLEXIT) ; Process Logical Link's IN-queue for received message
"RTN","HLCSIN",64,0)
 N HLXX,HLD0,HLD1
"RTN","HLCSIN",65,0)
 S HLXX=0
"RTN","HLCSIN",66,0)
 F  S HLXX=$O(^HLCS(870,"AISTAT","P",HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",67,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",68,0)
 .; HL*1.6*109
"RTN","HLCSIN",69,0)
 . L +^HLCS(870,HLXX,"INFILER"):0 Q:'$T  ;Does another filer have this?
"RTN","HLCSIN",70,0)
 . F  D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT  S HLD0=$$DEQUEUE^HLCSQUE(HLXX,"IN") Q:+HLD0<0  D
"RTN","HLCSIN",71,0)
 . . ;Make sure message is ready to be received
"RTN","HLCSIN",72,0)
 . . S HLFLG=1
"RTN","HLCSIN",73,0)
 . . S HLD1=$P(HLD0,"^",2)
"RTN","HLCSIN",74,0)
 . . S HLD0=+HLD0 ; At this point, HLD0=HLXX
"RTN","HLCSIN",75,0)
 . . I $P($G(^HLCS(870,HLD0,1,HLD1,0)),"^",3)'="A" D  Q
"RTN","HLCSIN",76,0)
 . . . D MONITOR^HLCSDR2("D",2,HLD0,HLD1,"IN") ;Set status to DONE
"RTN","HLCSIN",77,0)
 . . D RECEIVE^HLMA0(HLD0,HLD1) ;Process received message
"RTN","HLCSIN",78,0)
 . . D MONITOR^HLCSDR2("D",2,HLD0,HLD1,"IN") ;Set status to DONE
"RTN","HLCSIN",79,0)
 . I HLD0<0,$D(^HLCS(870,"AISTAT","P",HLXX)) D
"RTN","HLCSIN",80,0)
 . . S HLD1=0 ; Make sure there aren't any loose xrefs hanging around.
"RTN","HLCSIN",81,0)
 . . F  S HLD1=$O(^HLCS(870,"AISTAT","P",HLXX,HLD1)) Q:'HLD1  D
"RTN","HLCSIN",82,0)
 . . . ;I '$D(^HLCS(870,HLXX,1,HLD1,0)) K ^HLCS(870,"AISTAT","P",HLXX,HLD1)
"RTN","HLCSIN",83,0)
 . . . I $P($G(^HLCS(870,HLXX,1,HLD1,0)),U,2)'="P" K ^HLCS(870,"AISTAT","P",HLXX,HLD1)
"RTN","HLCSIN",84,0)
 . L -^HLCS(870,HLXX,"INFILER")
"RTN","HLCSIN",85,0)
 Q
"RTN","HLCSIN",86,0)
DELQUE(HLPTRFLR,HLEXIT) ; Delete messages outside the 'queue size' window.
"RTN","HLCSIN",87,0)
 N HLDIR,HLXX,HLFRONT
"RTN","HLCSIN",88,0)
 S HLDIR=1,HLXX=0
"RTN","HLCSIN",89,0)
 F  S HLXX=$O(^HLCS(870,HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",90,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",91,0)
 . L +^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"):0 Q:'$T
"RTN","HLCSIN",92,0)
 . S HLFRONT=$G(^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"))
"RTN","HLCSIN",93,0)
 . L -^HLCS(870,HLXX,"IN QUEUE FRONT POINTER")
"RTN","HLCSIN",94,0)
 . D DELETE^HLCSQUE1(HLXX,HLDIR,HLFRONT)
"RTN","HLCSIN",95,0)
 Q
"RTN","HLCSIN",96,0)
CHKUPD(HLPTRFLR,HLEXIT) ;
"RTN","HLCSIN",97,0)
 Q:$$HDIFF^XLFDT($H,$G(HLPTRFLR("LASTUP")),2)<15
"RTN","HLCSIN",98,0)
 D SETFLRDH^HLCSUTL1(HLPTRFLR,"IN") ; Update LAST KNOWN $H (field #.03) for filer
"RTN","HLCSIN",99,0)
 S HLPTRFLR("LASTUP")=$H
"RTN","HLCSIN",100,0)
 D CHK4STOP^HLCSUTL2(HLPTRFLR,"IN",.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",101,0)
 Q
"RTN","HLDIE773")
0^3^B17417520
"RTN","HLDIE773",1,0)
HLDIE773 ;CIOFO-O/LJA - Direct 772 & 773 Sets ; 11/18/2003 11:17
"RTN","HLDIE773",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109,115**;Oct 13,1995
"RTN","HLDIE773",3,0)
 ;
"RTN","HLDIE773",4,0)
 ;
"RTN","HLDIE773",5,0)
F301 ; 773 - .01 - 0;1   [B] - DATE/TIME ENTERED
"RTN","HLDIE773",6,0)
 D UPD^HLDIE772(0,1,VALUE)
"RTN","HLDIE773",7,0)
 S XRF("B")=""
"RTN","HLDIE773",8,0)
 Q
"RTN","HLDIE773",9,0)
 ;
"RTN","HLDIE773",10,0)
F32 ; 773 - 2 - 0;2   [C,AH] - MESSAGE ID
"RTN","HLDIE773",11,0)
 D UPD^HLDIE772(0,2,VALUE)
"RTN","HLDIE773",12,0)
 S XRF("C")="",XRF("AH")=""
"RTN","HLDIE773",13,0)
 Q
"RTN","HLDIE773",14,0)
 ;
"RTN","HLDIE773",15,0)
F3202 ; 773 - 2.02 - 2;2 - FAST PURGE DT/TM
"RTN","HLDIE773",16,0)
 ; Only fire ^HLMA(AI) xref when STATUS is changed...
"RTN","HLDIE773",17,0)
 D UPD^HLDIE772(2,2,VALUE)
"RTN","HLDIE773",18,0)
 Q
"RTN","HLDIE773",19,0)
 ;
"RTN","HLDIE773",20,0)
F33 ; 773 - 3 - 0;3 - TRANSMISSION TYPE
"RTN","HLDIE773",21,0)
 D UPD^HLDIE772(0,3,VALUE)
"RTN","HLDIE773",22,0)
 Q
"RTN","HLDIE773",23,0)
 ;
"RTN","HLDIE773",24,0)
F34 ; 773 - 4 - 0;4 - PRIORITY
"RTN","HLDIE773",25,0)
 D UPD^HLDIE772(0,4,VALUE)
"RTN","HLDIE773",26,0)
 Q
"RTN","HLDIE773",27,0)
 ;
"RTN","HLDIE773",28,0)
F35 ; 773 - 5 - 0;5 - HEADER TYPE
"RTN","HLDIE773",29,0)
 D UPD^HLDIE772(0,5,VALUE)
"RTN","HLDIE773",30,0)
 Q
"RTN","HLDIE773",31,0)
 ;
"RTN","HLDIE773",32,0)
F36 ; 773 - 6 - 0;6   [AF] - INITIAL MESSAGE
"RTN","HLDIE773",33,0)
 D UPD^HLDIE772(0,6,VALUE)
"RTN","HLDIE773",34,0)
 S XRF("AF")=""
"RTN","HLDIE773",35,0)
 Q
"RTN","HLDIE773",36,0)
 ;
"RTN","HLDIE773",37,0)
F37 ; 773 - 7 - 0;7   [AC] - INITIAL MESSAGE
"RTN","HLDIE773",38,0)
 ; Under no circumstances should DD create AC; only by package!
"RTN","HLDIE773",39,0)
 D UPD^HLDIE772(0,7,VALUE)
"RTN","HLDIE773",40,0)
 Q
"RTN","HLDIE773",41,0)
 ;
"RTN","HLDIE773",42,0)
F38 ; 773 - 8 - 0;8 - SUBSCRIBER PROTOCOL
"RTN","HLDIE773",43,0)
 D UPD^HLDIE772(0,8,VALUE)
"RTN","HLDIE773",44,0)
 Q
"RTN","HLDIE773",45,0)
 ;
"RTN","HLDIE773",46,0)
F39 ; 773 - 9 - 0;9 - SECURITY
"RTN","HLDIE773",47,0)
 D UPD^HLDIE772(0,9,VALUE)
"RTN","HLDIE773",48,0)
 Q
"RTN","HLDIE773",49,0)
 ;
"RTN","HLDIE773",50,0)
F310 ; 773 - 10 - 2;1 - DON'T PURGE
"RTN","HLDIE773",51,0)
 D UPD^HLDIE772(2,1,VALUE)
"RTN","HLDIE773",52,0)
 Q
"RTN","HLDIE773",53,0)
 ;
"RTN","HLDIE773",54,0)
F311 ; 773 - 11 - 1;1 - CONTINUATION POINTER
"RTN","HLDIE773",55,0)
 D UPD^HLDIE772(1,1,VALUE)
"RTN","HLDIE773",56,0)
 Q
"RTN","HLDIE773",57,0)
 ;
"RTN","HLDIE773",58,0)
F312 ; 773 - 12 - 0;10 - ACKNOWLEDGEMENT TO
"RTN","HLDIE773",59,0)
 D UPD^HLDIE772(0,10,VALUE)
"RTN","HLDIE773",60,0)
 Q
"RTN","HLDIE773",61,0)
 ;
"RTN","HLDIE773",62,0)
F313 ; 773 - 13 - 0;11 - SENDING APPLICATION
"RTN","HLDIE773",63,0)
 D UPD^HLDIE772(0,11,VALUE)
"RTN","HLDIE773",64,0)
 Q
"RTN","HLDIE773",65,0)
 ;
"RTN","HLDIE773",66,0)
F314 ; 773 - 14 - 0;12   [ae->AH] - RECEIVING APPLICATION
"RTN","HLDIE773",67,0)
 D UPD^HLDIE772(0,12,VALUE)
"RTN","HLDIE773",68,0)
 S XRF("AH")=""
"RTN","HLDIE773",69,0)
 Q
"RTN","HLDIE773",70,0)
 ;
"RTN","HLDIE773",71,0)
F315 ; 773 - 15 - 0;13 - MESSAGE TYPE
"RTN","HLDIE773",72,0)
 D UPD^HLDIE772(0,13,VALUE)
"RTN","HLDIE773",73,0)
 Q
"RTN","HLDIE773",74,0)
 ;
"RTN","HLDIE773",75,0)
F316 ; 773 - 16 - 0;14 - EVENT TYPE
"RTN","HLDIE773",76,0)
 D UPD^HLDIE772(0,14,VALUE)
"RTN","HLDIE773",77,0)
 Q
"RTN","HLDIE773",78,0)
 ;
"RTN","HLDIE773",79,0)
F320 ; 773 - 20 - P;1   [AG,AI(index)] - STATUS
"RTN","HLDIE773",80,0)
 N LINK,WAY
"RTN","HLDIE773",81,0)
 ;
"RTN","HLDIE773",82,0)
 D UPD^HLDIE772("P",1,VALUE)
"RTN","HLDIE773",83,0)
 S XRF("AG")="",XRF("AI")=""
"RTN","HLDIE773",84,0)
 ;
"RTN","HLDIE773",85,0)
 ; Quit if status isn't being set to SUCCESSFULLY COMPLETED...
"RTN","HLDIE773",86,0)
 QUIT:VALUE'=3  ;->
"RTN","HLDIE773",87,0)
 ;
"RTN","HLDIE773",88,0)
 ; Get AC's logical link IEN from new field...
"RTN","HLDIE773",89,0)
 S WAY=$P($G(NODE(0,0)),U,3) QUIT:WAY']""  ;->
"RTN","HLDIE773",90,0)
 ;
"RTN","HLDIE773",91,0)
 S LINK=$S(WAY="O":$P($G(NODE(0,0)),U,7),1:$P($G(NODE(0,0)),U,17)) QUIT:LINK'>0  ;->
"RTN","HLDIE773",92,0)
 QUIT:+$G(IEN)'>0  ;->
"RTN","HLDIE773",93,0)
 ;
"RTN","HLDIE773",94,0)
 KILL ^HLMA("AC",WAY,LINK,+IEN)
"RTN","HLDIE773",95,0)
 ;
"RTN","HLDIE773",96,0)
 Q
"RTN","HLDIE773",97,0)
 ;
"RTN","HLDIE773",98,0)
F321 ; 773 - 21 - P;2 - STATUS UPDATE DATE/TIME
"RTN","HLDIE773",99,0)
 D UPD^HLDIE772("P",2,VALUE)
"RTN","HLDIE773",100,0)
 Q
"RTN","HLDIE773",101,0)
 ;
"RTN","HLDIE773",102,0)
F322 ; 773 - 22 - P;3 - ERROR MESSAGE
"RTN","HLDIE773",103,0)
 D UPD^HLDIE772("P",3,VALUE)
"RTN","HLDIE773",104,0)
 Q
"RTN","HLDIE773",105,0)
 ;
"RTN","HLDIE773",106,0)
F323 ; 773 - 23 - P;4 - ERROR TYPE
"RTN","HLDIE773",107,0)
 D UPD^HLDIE772("P",4,VALUE)
"RTN","HLDIE773",108,0)
 Q
"RTN","HLDIE773",109,0)
 ;
"RTN","HLDIE773",110,0)
F324 ; 773 - 24 - P;5 - TRANSMISSION ATTEMPTS
"RTN","HLDIE773",111,0)
 D UPD^HLDIE772("P",5,VALUE)
"RTN","HLDIE773",112,0)
 Q
"RTN","HLDIE773",113,0)
 ;
"RTN","HLDIE773",114,0)
F325 ; 773 - 25 - P;6 - OPEN ATTEMPTS
"RTN","HLDIE773",115,0)
 D UPD^HLDIE772("P",6,VALUE)
"RTN","HLDIE773",116,0)
 Q
"RTN","HLDIE773",117,0)
 ;
"RTN","HLDIE773",118,0)
F326 ; 773 - 26 - P;7 - ACK TIMEOUT
"RTN","HLDIE773",119,0)
 D UPD^HLDIE772("P",7,VALUE)
"RTN","HLDIE773",120,0)
 Q
"RTN","HLDIE773",121,0)
 ;
"RTN","HLDIE773",122,0)
F3100 ; 773 - 100 - S;1   [AD] - DATE/TIME PROCESSED
"RTN","HLDIE773",123,0)
 ; Only fire ^HLMA(AI) xref when STATUS is changed...
"RTN","HLDIE773",124,0)
 D UPD^HLDIE772("S",1,VALUE)
"RTN","HLDIE773",125,0)
 S XRF("AD")=""
"RTN","HLDIE773",126,0)
 Q
"RTN","HLDIE773",127,0)
 ;
"RTN","HLDIE773",128,0)
F3200 ; 773 - 200 - MSH - MSH
"RTN","HLDIE773",129,0)
 ; VALUE is set in EDITALL^HLDIE to the name of the local array
"RTN","HLDIE773",130,0)
 ; holding the MSH segment.  Use it...
"RTN","HLDIE773",131,0)
 N NO,TXT
"RTN","HLDIE773",132,0)
 ;
"RTN","HLDIE773",133,0)
 ; Set MSH itself into global...
"RTN","HLDIE773",134,0)
 S NO=0,NO(1)=""
"RTN","HLDIE773",135,0)
 F  S NO=$O(@VALUE@(NO)) Q:NO'>0  D
"RTN","HLDIE773",136,0)
 .  S TXT=$G(@VALUE@(NO)) QUIT:TXT']""  ;->
"RTN","HLDIE773",137,0)
 .  S ^HLMA(+IEN,"MSH",NO,0)=TXT
"RTN","HLDIE773",138,0)
 .  S NO(1)=NO
"RTN","HLDIE773",139,0)
 ;
"RTN","HLDIE773",140,0)
 ; Add MSH header...
"RTN","HLDIE773",141,0)
 S ^HLMA(+IEN,"MSH",0)="^773.01^"_NO(1)_"^"_NO(1)
"RTN","HLDIE773",142,0)
 ;
"RTN","HLDIE773",143,0)
 Q
"RTN","HLDIE773",144,0)
 ;
"RTN","HLDIE773",145,0)
 ; =================================================================
"RTN","HLDIE773",146,0)
 ;
"RTN","HLDIE773",147,0)
XRFAC ; AC XRF kills/sets...
"RTN","HLDIE773",148,0)
 ; Under no circumstances should DD create AC; only by package!
"RTN","HLDIE773",149,0)
 Q
"RTN","HLDIE773",150,0)
 ;
"RTN","HLDIE773",151,0)
XRFAD ; AD XRF kills/sets...
"RTN","HLDIE773",152,0)
 D XRFSET^HLDIE772(FILE,+IEN,"AD","S",1)
"RTN","HLDIE773",153,0)
 Q
"RTN","HLDIE773",154,0)
 ;
"RTN","HLDIE773",155,0)
XRFAF ; AF XRF kills/sets...
"RTN","HLDIE773",156,0)
 D XRFSET^HLDIE772(FILE,+IEN,"AF",0,6)
"RTN","HLDIE773",157,0)
 Q
"RTN","HLDIE773",158,0)
 ;
"RTN","HLDIE773",159,0)
XRFAG ; AG XRF kills/sets...
"RTN","HLDIE773",160,0)
 D XRFSET^HLDIE772(FILE,+IEN,"AG","P",1)
"RTN","HLDIE773",161,0)
 Q
"RTN","HLDIE773",162,0)
 ;
"RTN","HLDIE773",163,0)
XRFAH ; AH XRF kills/sets...
"RTN","HLDIE773",164,0)
 D XRFSETC^HLDIE772(FILE,+IEN,"AH",0,12,0,2)
"RTN","HLDIE773",165,0)
 Q
"RTN","HLDIE773",166,0)
 ;
"RTN","HLDIE773",167,0)
XRFAI ; AI INDEX code...
"RTN","HLDIE773",168,0)
 S STATUS=$P($G(NODE("P",1)),U)
"RTN","HLDIE773",169,0)
 D PXREF^HLUOPTF1(+$G(IEN),STATUS)
"RTN","HLDIE773",170,0)
 Q
"RTN","HLDIE773",171,0)
 ;
"RTN","HLDIE773",172,0)
XRFB ; B XRF kills/sets...
"RTN","HLDIE773",173,0)
 D XRFSET^HLDIE772(FILE,+IEN,"B",0,1)
"RTN","HLDIE773",174,0)
 Q
"RTN","HLDIE773",175,0)
 ;
"RTN","HLDIE773",176,0)
XRFC ; C XRF kills/sets...
"RTN","HLDIE773",177,0)
 D XRFSET^HLDIE772(FILE,IEN,"C",0,2)
"RTN","HLDIE773",178,0)
 Q
"RTN","HLDIE773",179,0)
 ;
"RTN","HLDIE773",180,0)
XRFFPD(IEN772,FPDOLD,FPDNEW) ; This API is called by XRFFPD^HLDIE772 when 
"RTN","HLDIE773",181,0)
 ; a 772 Fast Purge Date/time has been changed.  
"RTN","HLDIE773",182,0)
 ;
"RTN","HLDIE773",183,0)
 ; ASSUMPTION:  The Fast Purge Date/time should be the same in both
"RTN","HLDIE773",184,0)
 ;              772 and 773 entries.
"RTN","HLDIE773",185,0)
 ;
"RTN","HLDIE773",186,0)
 ; ASSUMPTION:  If the Fast Purge Date/time is changed in 773, the
"RTN","HLDIE773",187,0)
 ;              same value should be "echoed" (set into) file 772.
"RTN","HLDIE773",188,0)
 ;              and vice versa.
"RTN","HLDIE773",189,0)
 ;
"RTN","HLDIE773",190,0)
 ; ASSUMPTION:  The Fast Purge Date/time will NEVER be set unless
"RTN","HLDIE773",191,0)
 ;              the STATUS of both 772 and 773 entries is equal to
"RTN","HLDIE773",192,0)
 ;              SUCCESSFULLY COMPLETED.  (For this reason, the status
"RTN","HLDIE773",193,0)
 ;              will never be checked.
"RTN","HLDIE773",194,0)
 ;
"RTN","HLDIE773",195,0)
 ; The purpose of this call from 772 is to...
"RTN","HLDIE773",196,0)
 ;
"RTN","HLDIE773",197,0)
 ; * Kill all ^HLMA("AI") xrefs using the old Fast Purge Date/time
"RTN","HLDIE773",198,0)
 ;   for both files 772 and 773.
"RTN","HLDIE773",199,0)
 ; * Reset the Fast Purge Date/time in all 773 entries associated with
"RTN","HLDIE773",200,0)
 ;   the 772 entry whose Fast Purge Date/time field was just changed.
"RTN","HLDIE773",201,0)
 ; * Recreate the ^HLMA("AI") xrefs based on the new Fast Purge 
"RTN","HLDIE773",202,0)
 ;   Date/time.
"RTN","HLDIE773",203,0)
 ;
"RTN","HLDIE773",204,0)
 N IEN773
"RTN","HLDIE773",205,0)
 ;
"RTN","HLDIE773",206,0)
 ; Checks of data...  (Code commented per Jim Moore's suggestion. LJA)
"RTN","HLDIE773",207,0)
 ; QUIT:$G(^HL(772,+IEN772,0))']""  ;->
"RTN","HLDIE773",208,0)
 ; QUIT:FPDOLD'?7N1"."1.N  ;-> Check the original Fast Purge Date/time...
"RTN","HLDIE773",209,0)
 ; QUIT:FPDNEW'?7N1"."1.N  ;-> Check the new date...
"RTN","HLDIE773",210,0)
 ; QUIT:FPDOLD=FPDNEW  ;->  No change!
"RTN","HLDIE773",211,0)
 ;
"RTN","HLDIE773",212,0)
 ; Kill old 772 AI entry...
"RTN","HLDIE773",213,0)
 KILL ^HLMA("AI",FPDOLD,772,+IEN772) ; Kill 772 parent AI...
"RTN","HLDIE773",214,0)
 ;
"RTN","HLDIE773",215,0)
 ; Remove old 773 entries...
"RTN","HLDIE773",216,0)
 S IEN773=0
"RTN","HLDIE773",217,0)
 F  S IEN773=$O(^HLMA("B",+IEN772,IEN773)) Q:'IEN773  D
"RTN","HLDIE773",218,0)
 .  KILL ^HLMA("AI",FPDOLD,773,+IEN773) ; Kill 773 child AI...
"RTN","HLDIE773",219,0)
 .  S $P(^HLMA(+IEN773,2),U,2)=FPDNEW ; Set 773 to match 772...
"RTN","HLDIE773",220,0)
 ;
"RTN","HLDIE773",221,0)
 ; Now, all AI xrefs killed, and the Fast Purge Date/time in both 772
"RTN","HLDIE773",222,0)
 ; and 773 are set to the new value, so set the new xrefs...
"RTN","HLDIE773",223,0)
 S IEN773=0
"RTN","HLDIE773",224,0)
 F  S IEN773=$O(^HLMA("B",+IEN772,IEN773)) Q:'IEN773  D
"RTN","HLDIE773",225,0)
 .  D PXREF^HLUOPTF1(+IEN773,3)
"RTN","HLDIE773",226,0)
 ;
"RTN","HLDIE773",227,0)
 Q
"RTN","HLDIE773",228,0)
 ;
"RTN","HLDIE773",229,0)
XRFLLCT ; LLCNT^HLCSTCP(IEN870,3) XRF kills/sets...
"RTN","HLDIE773",230,0)
 ;XXX D LLCNT^HLCSTCP(IEN870,3)
"RTN","HLDIE773",231,0)
 Q
"RTN","HLDIE773",232,0)
 ;
"RTN","HLDIE773",233,0)
EOR ;HLDIE773 - Direct 772 & 773 Sets ; 11/18/2003 11:17
"RTN","HLMA")
0^4^B36491876
"RTN","HLMA",1,0)
HLMA ;AISC/SAW-Message Administration Module ;02/27/2004  12:34
"RTN","HLMA",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,58,63,66,82,91,109,115**;Oct 13, 1995
"RTN","HLMA",3,0)
GENERATE(HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLMTIEN,HLP) ;
"RTN","HLMA",4,0)
 ;Entry point to generate a deferred message
"RTN","HLMA",5,0)
 ;
"RTN","HLMA",6,0)
 ;This is a subroutine call with parameter passing.  It returns a
"RTN","HLMA",7,0)
 ;value in the variable HLRESLT with 1 to 3 pieces separated by uparrows
"RTN","HLMA",8,0)
 ;as follows:  1st message ID^error code^error description
"RTN","HLMA",9,0)
 ;If no error occurs, only the first piece is returned equal to a unique
"RTN","HLMA",10,0)
 ;ID for the 1st message.  If message was sent to more than 1 subscriber
"RTN","HLMA",11,0)
 ;than the other message IDs will be in the array HLRESLT(n)=ID
"RTN","HLMA",12,0)
 ;Otherwise, three pieces are returned with the
"RTN","HLMA",13,0)
 ;first piece equal to the message ID, if one was assigned, otherwise 0
"RTN","HLMA",14,0)
 ;
"RTN","HLMA",15,0)
 ;Required Input Parameters
"RTN","HLMA",16,0)
 ;     HLEID = Name or IEN of event driver protocol in the Protocol file
"RTN","HLMA",17,0)
 ;  HLARYTYP = Array type.  One of the following codes:
"RTN","HLMA",18,0)
 ;               LM = local array containing a single message
"RTN","HLMA",19,0)
 ;               LB = local array containig a batch of messages
"RTN","HLMA",20,0)
 ;               GM = global array containing a single message
"RTN","HLMA",21,0)
 ;               GB = global array containing a batch of messages
"RTN","HLMA",22,0)
 ;  HLFORMAT = Format of array, 1 for pre-formatted in HL7 format,
"RTN","HLMA",23,0)
 ;               otherwise 0
"RTN","HLMA",24,0)
 ;NOTE:  The parameter HLRESLT must be passed by reference
"RTN","HLMA",25,0)
 ;   HLRESLT = The variable that will be returned to the calling
"RTN","HLMA",26,0)
 ;               application as descibed above
"RTN","HLMA",27,0)
 ;Optional Parameters
"RTN","HLMA",28,0)
 ;   HLMTIEN = IEN of entry in Message Text file where the message
"RTN","HLMA",29,0)
 ;               being generated is to be stored.  This parameter is
"RTN","HLMA",30,0)
 ;               only passed for a batch type message
"RTN","HLMA",31,0)
 ;NOTE:  The parameter HLP used for the following parameters must be
"RTN","HLMA",32,0)
 ;       passed by reference
"RTN","HLMA",33,0)
 ;  HLP("SECURITY") = A 1 to 40 character string
"RTN","HLMA",34,0)
 ;   HLP("CONTPTR") = Continuation pointer, a 1 to 180 character string
"RTN","HLMA",35,0)
 ; HLP("NAMESPACE") = Passed in by application namespace - HL*1.6*91
"RTN","HLMA",36,0)
 ;
"RTN","HLMA",37,0)
 ;can't have link open when generating new message
"RTN","HLMA",38,0)
 N HLTCP,HLTCPO,HLPRIO,HLMIDAR
"RTN","HLMA",39,0)
 S HLPRIO="D"
"RTN","HLMA",40,0)
 ;Check for required parameters
"RTN","HLMA",41,0)
CONT I $G(HLEID)']""!($G(HLARYTYP)']"")!($G(HLFORMAT)']"") S HLRESLT="0^7^"_$G(^HL(771.7,7,0))_" at GENERATE^HLMA entry point" G EXIT
"RTN","HLMA",42,0)
 I 'HLEID S HLEID=$O(^ORD(101,"B",HLEID,0)) I 'HLEID S HLRESLT="0^1^"_$G(^HL(771.7,1,0)) G EXIT
"RTN","HLMA",43,0)
 I "GL"'[$E(HLARYTYP) S HLRESLT="0^4^"_$G(^HL(771.7,4,0)) G EXIT
"RTN","HLMA",44,0)
 I $L($G(HLP("SECURITY")))>40 S HLRESLT="0^6^"_$G(^HL(771.7,6,0)) G EXIT
"RTN","HLMA",45,0)
 I $L($G(HLP("CONTPTR")))>180 S HLRESLT="0^11^"_$G(^HL(771.7,11,0)) G EXIT
"RTN","HLMA",46,0)
 I $D(HLL("LINKS")) D  G:$G(HLRESLT)]"" EXIT
"RTN","HLMA",47,0)
 . N I,HLPNAM,HLPIEN,HLLNAM,HLLIEN
"RTN","HLMA",48,0)
 . S I=0
"RTN","HLMA",49,0)
 . F  S I=$O(HLL("LINKS",I)) Q:'I  D  Q:$G(HLRESLT)]""
"RTN","HLMA",50,0)
 . . S HLPNAM=$P(HLL("LINKS",I),U)
"RTN","HLMA",51,0)
 . . S HLPIEN=+$O(^ORD(101,"B",HLPNAM,0))
"RTN","HLMA",52,0)
 . . I $P($G(^ORD(101,HLPIEN,0)),U,4)'="S" S HLRESLT="0^15^Invalid Subscriber Protocol in HLL('LINKS'): "_HLL("LINKS",I) Q
"RTN","HLMA",53,0)
 . . S HLLNAM=$P(HLL("LINKS",I),U,2)
"RTN","HLMA",54,0)
 . . S HLLIEN=+$O(^HLCS(870,"B",HLLNAM,0))
"RTN","HLMA",55,0)
 . . I '$D(^HLCS(870,HLLIEN,0)) S HLRESLT="0^15^Invalid HL Node in HLL('LINKS'): "_HLL("LINKS",I) Q
"RTN","HLMA",56,0)
 ;Extract data from Protocol file
"RTN","HLMA",57,0)
 D EVENT^HLUTIL1(HLEID,"15,20,771",.HLN)
"RTN","HLMA",58,0)
 S HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15))
"RTN","HLMA",59,0)
 S HLP("GROUTINE")=$G(HLN(771)) K HLN I HLP("GROUTINE")']"",'HLFORMAT S HLRESLT="0^3^"_$G(^HL(771.7,3,0)) G EXIT
"RTN","HLMA",60,0)
 ;Create message ID and Message Text IEN if Message Text IEN not
"RTN","HLMA",61,0)
 ;previously created ('$G(HLMTIEN))
"RTN","HLMA",62,0)
 I '$G(HLMTIEN) D CREATE^HLTF(.HLMID,.HLMTIEN,.HLDT,.HLDT1)
"RTN","HLMA",63,0)
 ;Get message ID if Message Text IEN already created
"RTN","HLMA",64,0)
 I '$G(HLMID) D
"RTN","HLMA",65,0)
 .S HLDT=$G(^HL(772,HLMTIEN,0)),HLMID=$P(HLDT,"^",6),HLDT=+HLDT
"RTN","HLMA",66,0)
 .S HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLMA",67,0)
 S HLMIDAR=0,HLRESLT=HLMID,HLP("DT")=HLDT,HLP("DTM")=HLDT1
"RTN","HLMA",68,0)
 ;Execute entry action for event driver protocol
"RTN","HLMA",69,0)
 I HLENROU]"" X HLENROU
"RTN","HLMA",70,0)
 ;Invoke transaction processor
"RTN","HLMA",71,0)
 K HLDT,HLDT1,HLENROU
"RTN","HLMA",72,0)
 D GENERATE^HLTP(HLMID,HLMTIEN,HLEID,HLARYTYP,HLFORMAT,.HLRESLT1,.HLP)
"RTN","HLMA",73,0)
 ;HLMIDAR is array of message IDs, only set for broadcast messages
"RTN","HLMA",74,0)
 I HLMIDAR K HLMIDAR("N") M HLRESLT=HLMIDAR
"RTN","HLMA",75,0)
 S HLRESLT=HLRESLT_"^"_HLRESLT1
"RTN","HLMA",76,0)
 ;Execute exit action for event driver protocol
"RTN","HLMA",77,0)
 I HLEXROU]"" X HLEXROU
"RTN","HLMA",78,0)
EXIT ;Update status if Message Text file entry has been created
"RTN","HLMA",79,0)
 K HLTCP
"RTN","HLMA",80,0)
 I $D(HLMTIEN) D STATUS^HLTF0(HLMTIEN,$S($P(HLRESLT,"^",2):4,1:3),$S($P(HLRESLT,"^",2):$P(HLRESLT,"^",2),1:""),$S($P(HLRESLT,"^",2):$P(HLRESLT,"^",3),1:""))
"RTN","HLMA",81,0)
 K HLDT,HLDT1,HLMID,HLRESLT1,HLENROU,HLEXROU
"RTN","HLMA",82,0)
 Q
"RTN","HLMA",83,0)
DIRECT(HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLMTIENO,HLP) ;
"RTN","HLMA",84,0)
 ;Entry point to generate an immediate message, must be TCP Logical Link
"RTN","HLMA",85,0)
 ;input parameters are the same as GENERATE
"RTN","HLMA",86,0)
 N HLTCP,HLTCPO,HLPRIO,HLSAN,HLN,HLMIDAR,HLMTIENR,ZMID
"RTN","HLMA",87,0)
 ;HLMTIENO=ien passed in, batch message
"RTN","HLMA",88,0)
 S HLMTIEN=$G(HLMTIENO)
"RTN","HLMA",89,0)
 K HL,HLMTIENO
"RTN","HLMA",90,0)
 D INIT^HLFNC2(HLEID,.HL)
"RTN","HLMA",91,0)
 I $G(HL) S HLRESLT="0^"_HL Q
"RTN","HLMA",92,0)
 S HLPRIO="I" D CONT
"RTN","HLMA",93,0)
 ;HLMTIENO=original msg. ien in file 772, HLMTIENR=response ien set in HLMA2
"RTN","HLMA",94,0)
 S HLMTIENO=HLMTIEN,HLMTIEN=$G(HLMTIENR)
"RTN","HLMA",95,0)
 ;Set special HL variables
"RTN","HLMA",96,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLMA",97,0)
 Q
"RTN","HLMA",98,0)
 ;
"RTN","HLMA",99,0)
CLOSE(LOGLINK) ;close connection that was open in tag DIRECT
"RTN","HLMA",100,0)
 Q
"RTN","HLMA",101,0)
PING ;ping another VAMC to test Link
"RTN","HLMA",102,0)
 ;set HLQUIET =1 to skip writes
"RTN","HLMA",103,0)
 ;look for HLTPUT to get turnaround time over network.
"RTN","HLMA",104,0)
 N DA,DIC,HLDP,HLDPNM,HLDPDM,HLCSOUT,HLDBSIZE,HLDREAD,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL,HLPARAM
"RTN","HLMA",105,0)
 N HCS,HCSCMD,HLCS,HCSDAT,HCSER,HCSEXIT,HCSTRACE,HLDT1,HLDRETR,HLRETRA,HLDBACK,HLDWAIT,HLTCPCS,INPUT,OUTPUT,POP,X,Y,HLX1,HLX2
"RTN","HLMA",106,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA",107,0)
 S HLCS="",HCSTRACE="C: ",POP=1,INPUT="INPUT",OUTPUT="OUTPUT"
"RTN","HLMA",108,0)
 S DIC="^HLCS(870,",DIC(0)="QEAMZ"
"RTN","HLMA",109,0)
 D ^DIC Q:Y<0
"RTN","HLMA",110,0)
 S HLDP=+Y,HLDPNM=Y(0,0),HLDPDM=$P($$PARAM^HLCS2,U,2)
"RTN","HLMA",111,0)
 ;I $P($G(^HLCS(870,HLDP,400)),U)="" W !,"Missing IP Address" Q
"RTN","HLMA",112,0)
 D SETUP^HLCSAC G:HLCS PINGQ
"RTN","HLMA",113,0)
 ;PING header=MSH^PING^domain^PING^logical link^datetime
"RTN","HLMA",114,0)
 S INPUT(1)="MSH^PING^"_HLDPDM_"^PING^"_HLDPNM_"^"_$$HTE^XLFDT($H)
"RTN","HLMA",115,0)
 D OPEN^HLCSAC
"RTN","HLMA",116,0)
 I HLCS D DNS G:HLCS PINGQ
"RTN","HLMA",117,0)
 D
"RTN","HLMA",118,0)
 . N $ETRAP,$ESTACK S $ETRAP="D PINGERR^HLMA"
"RTN","HLMA",119,0)
 . ;non-standard HL7 header; start block,header,end block
"RTN","HLMA",120,0)
 . S HLX1=$H
"RTN","HLMA",121,0)
 . W $C(11)_INPUT(1)_$C(28)_$C(13),! ;HL*1.6*115, restored ! char
"RTN","HLMA",122,0)
 . ;read response
"RTN","HLMA",123,0)
 . R X:HLDREAD
"RTN","HLMA",124,0)
 . S HLX2=$H
"RTN","HLMA",125,0)
 . S X=$P(X,$C(28)),HLCS=$S(X=INPUT(1):"PING worked",X="":"No response",1:"Incorrect response")
"RTN","HLMA",126,0)
 . ;Get roundtrip time
"RTN","HLMA",127,0)
 . K HLTPUT I X]"" S HLTPUT=$$HDIFF^XLFDT(HLX2,HLX1,2)
"RTN","HLMA",128,0)
 D CLOSE^%ZISTCP
"RTN","HLMA",129,0)
PINGQ ;write back status and quit
"RTN","HLMA",130,0)
 I 'HLQUIET W !,HLCS,!
"RTN","HLMA",131,0)
 Q
"RTN","HLMA",132,0)
PINGERR ;process errors from PING
"RTN","HLMA",133,0)
 S $ETRAP="G UNWIND^%ZTER",HLCS="-1^Error"
"RTN","HLMA",134,0)
 ;I $ZE["READ" S HLCS="-1^Error during read"
"RTN","HLMA",135,0)
 ;I $ZE["WRITE" S HLCS="-1^Error during write"
"RTN","HLMA",136,0)
 ; HL*1.6*115, SACC compliance
"RTN","HLMA",137,0)
 I $$EC^%ZOSV["READ" S HLCS="-1^Error during read"
"RTN","HLMA",138,0)
 I $$EC^%ZOSV["WRITE" S HLCS="-1^Error during write"
"RTN","HLMA",139,0)
 G UNWIND^%ZTER
"RTN","HLMA",140,0)
DNS ;
"RTN","HLMA",141,0)
 ;openfail-try DNS lookup-Link must contain point to Domain Name
"RTN","HLMA",142,0)
 S POP=$G(POP)
"RTN","HLMA",143,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA",144,0)
 I 'HLQUIET W !,"Calling DNS"
"RTN","HLMA",145,0)
 N HLDOM,HLIP S HLCS=""
"RTN","HLMA",146,0)
 S HLDOM=$P(^HLCS(870,HLDP,0),U,7)
"RTN","HLMA",147,0)
 I 'HLDOM,'HLQUIET W !,"Domain Unknown" Q
"RTN","HLMA",148,0)
 I HLDOM S HLDOM=$P(^DIC(4.2,HLDOM,0),U)
"RTN","HLMA",149,0)
 I HLDOM]"" D  Q:'POP
"RTN","HLMA",150,0)
 . I HLDOM["VA.GOV"&(HLDOM'[".MED.") S HLDOM=$P(HLDOM,".VA.GOV")_".MED.VA.GOV"
"RTN","HLMA",151,0)
 . I HLTCPORT=5000 S HLDOM="HL7."_HLDOM
"RTN","HLMA",152,0)
 . I HLTCPORT=5500 S HLDOM="MPI."_HLDOM
"RTN","HLMA",153,0)
 . I 'HLQUIET W !,"Domain, "_HLDOM
"RTN","HLMA",154,0)
 . I 'HLQUIET W !,"Port: ",HLTCPORT
"RTN","HLMA",155,0)
 . S HLIP=$$ADDRESS^XLFNSLK(HLDOM)
"RTN","HLMA",156,0)
 . I HLIP]"",'HLQUIET W !,"DNS Returned: ",HLIP
"RTN","HLMA",157,0)
 . I HLIP]"" D
"RTN","HLMA",158,0)
 . . ;If more than one IP returned, try each, cache successful open
"RTN","HLMA",159,0)
 . . N HLI,HLJ,HLIP1
"RTN","HLMA",160,0)
 . . F HLJ=1:1:$L(HLIP,",") D  Q:'POP
"RTN","HLMA",161,0)
 . . . S HLIP1=$P(HLIP,",",HLJ)
"RTN","HLMA",162,0)
 . . . F HLI=1:1:HLDRETR W:'HLQUIET !,"Trying ",HLIP1 D CALL^%ZISTCP(HLIP1,HLTCPORT,1) Q:'POP
"RTN","HLMA",163,0)
 . . . I 'POP S $P(^HLCS(870,HLDP,400),U)=HLIP1
"RTN","HLMA",164,0)
 . . . U IO
"RTN","HLMA",165,0)
 I POP S HLCS="-1^DNS Lookup Failed"
"RTN","HLTP3")
0^1^B59434010
"RTN","HLTP3",1,0)
HLTP3 ;SFIRMFO/RSD - Transaction Processor for TCP ;01/30/2004  16:15
"RTN","HLTP3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,58,59,66,69,109,115**;Oct 13, 1995
"RTN","HLTP3",3,0)
 ;
"RTN","HLTP3",4,0)
 Q
"RTN","HLTP3",5,0)
NEW(X) ;process new msg. ien in 773^msg. ien in 772
"RTN","HLTP3",6,0)
 ;HLMTIENS=ien in #773, msg header; HLMTIEN=ien in #772, msg text
"RTN","HLTP3",7,0)
 ;HLHDRO=original header;  HLHDR=response header
"RTN","HLTP3",8,0)
 ;set error trap
"RTN","HLTP3",9,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP3",10,0)
 N HL,HLEID,HLEIDS,HLERR,HLHDR,HLHDRO,HLMTIEN,HLMTIENS,HLJ,HLMSA,HLQUIT,HLNODE,HLNEXT,HLRESLTA,HLDONE1,HLASTRSP
"RTN","HLTP3",11,0)
 D INIT^HLTP3A ;patch HL*1.6*109 - hltp3 routine split
"RTN","HLTP3",12,0)
 ;error with header, return commit/app reject
"RTN","HLTP3",13,0)
 I $G(HLRESLT) D  Q
"RTN","HLTP3",14,0)
 . ;set status & unlock record
"RTN","HLTP3",15,0)
 . D STATUS^HLTF0(HLMTIENS,4,,,1),EXIT
"RTN","HLTP3",16,0)
 . ;quit if no commit or app ack
"RTN","HLTP3",17,0)
 . I $G(HL("ACAT"))="NE",$G(HL("APAT"))="NE" Q
"RTN","HLTP3",18,0)
 . S X=$S($G(HL("ACAT"))="AL":"CR",1:"AR")
"RTN","HLTP3",19,0)
 . ;HLTCP=ien of acknowledgment msg. from ACK^HLTP4
"RTN","HLTP3",20,0)
 . D ACK^HLTP4(X,$P(HLRESLT,U,2)) Q:'$G(HLTCP)
"RTN","HLTP3",21,0)
 . ;update counter, msg. to send
"RTN","HLTP3",22,0)
 .; D LLCNT^HLCSTCP(HLDP,3) ;**109** done in ACK^HLTP4
"RTN","HLTP3",23,0)
 . ;write ack back over connection
"RTN","HLTP3",24,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",25,0)
 . ;update counter to sent
"RTN","HLTP3",26,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",27,0)
 . ;update status of ack to complete
"RTN","HLTP3",28,0)
 . D STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",29,0)
 ;
"RTN","HLTP3",30,0)
 ;check for duplicate msg., use rec. app and msg. id x-ref
"RTN","HLTP3",31,0)
 I $G(HL("MID")),$G(HL("RAP")) S X=$O(^HLMA("AH",HL("RAP"),HL("MID"),0)) D  Q:'$D(HLMTIENS)
"RTN","HLTP3",32,0)
 . ;HLASTMSG=last ien received during this connection
"RTN","HLTP3",33,0)
 . ;if no duplicate, save msg. ien and quit
"RTN","HLTP3",34,0)
 . I X=HLMTIENS!'X S HLASTMSG=HLMTIENS Q
"RTN","HLTP3",35,0)
 . N MSH,OIENS
"RTN","HLTP3",36,0)
 . S (OIENS,Y)=X D  S Y=HLMTIENS D
"RTN","HLTP3",37,0)
 .. ;combine MSH into single string
"RTN","HLTP3",38,0)
 .. S MSH(Y)="",I=0 F  S I=$O(^HLMA(Y,"MSH",I)) Q:'I  S MSH(Y)=MSH(Y)_$G(^(I,0))
"RTN","HLTP3",39,0)
 . ;if MSH is not identical, then msg. are different, quit
"RTN","HLTP3",40,0)
 . I MSH(HLMTIENS)'=MSH(OIENS) S HLASTMSG=HLMTIENS Q
"RTN","HLTP3",41,0)
 . ;msg is duplicate, set status as duplicate
"RTN","HLTP3",42,0)
 . D STATUS^HLTF0(HLMTIENS,4,109,"Duplicate with ien "_OIENS,1),EXIT
"RTN","HLTP3",43,0)
 . ;msg was resent during this connection, ignore it.
"RTN","HLTP3",44,0)
 . I HLASTMSG=HLMTIENS K HLMTIENS Q
"RTN","HLTP3",45,0)
 . ;msg was resent during another connection, resend original ack and skip processing
"RTN","HLTP3",46,0)
 .;**115** L +^HLMA(OIENS):0
"RTN","HLTP3",47,0)
 .;**115** I $T L -^HLMA(OIENS) I +$G(^HLMA(OIENS,"P"))'=3,'$$ONAC(OIENS) Q
"RTN","HLTP3",48,0)
 . ;find original response and send back
"RTN","HLTP3",49,0)
 . S HLASTRSP=$O(^HLMA("AF",OIENS,OIENS))
"RTN","HLTP3",50,0)
 ;
"RTN","HLTP3",51,0)
 ;Quit if this is acknowledgment to acknowledgement message
"RTN","HLTP3",52,0)
 I $G(HL("ACK")) D  Q
"RTN","HLTP3",53,0)
 . ;Update status of original acknowledgment message to successfully
"RTN","HLTP3",54,0)
 . D STATUS^HLTF0(HL("MTIENS"),3,,,1),STATUS^HLTF0(HLMTIENS,3,,,1)
"RTN","HLTP3",55,0)
 . ;unlock record
"RTN","HLTP3",56,0)
 . D EXIT
"RTN","HLTP3",57,0)
 ;
"RTN","HLTP3",58,0)
 ;enhance ack., send commit, quit if not an ack, msg will be processed by filer
"RTN","HLTP3",59,0)
 I $G(HL("ACAT"))="AL" D  Q:'$G(HL("MTIENS"))
"RTN","HLTP3",60,0)
 . ;msg is a resend, HLASTRSP=ien of original response
"RTN","HLTP3",61,0)
 .I $G(HLASTRSP) D
"RTN","HLTP3",62,0)
 ..S HLTCP=HLASTRSP
"RTN","HLTP3",63,0)
 ..D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",64,0)
 . E  D  Q:'$G(HLTCP)
"RTN","HLTP3",65,0)
 ..D ACK^HLTP4("CA") ;**109** LLCNT^HLCSTCP(HLDP,3) called in ACK^HLTP4
"RTN","HLTP3",66,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",67,0)
 . D LLCNT^HLCSTCP(HLDP,4),STATUS^HLTF0(HLTCP,3,,,1):'$G(HLASTRSP)
"RTN","HLTP3",68,0)
 . S HLTCP=""
"RTN","HLTP3",69,0)
 . ;if not an ack, set status to awaiting processing **109** and put on in queue
"RTN","HLTP3",70,0)
 . I '$G(HL("MTIENS")),'$G(HLASTRSP) D STATUS^HLTF0(HLMTIENS,9),EXIT,SETINQUE^HLTP31
"RTN","HLTP3",71,0)
 ;
"RTN","HLTP3",72,0)
 ;enhance ack., no commit & no app ack
"RTN","HLTP3",73,0)
 I $G(HL("ACAT"))="NE",$G(HL("APAT"))="NE" D  Q
"RTN","HLTP3",74,0)
 . ;set status to awaiting processing, **109** and put on in queue
"RTN","HLTP3",75,0)
 . I '$G(HLASTRSP) D STATUS^HLTF0(HLMTIENS,9),EXIT,SETINQUE^HLTP31
"RTN","HLTP3",76,0)
 ;
"RTN","HLTP3",77,0)
 ;resending old response, msg is a resend
"RTN","HLTP3",78,0)
 I $G(HLASTRSP) S HLTCP=HLASTRSP G ACK
"RTN","HLTP3",79,0)
CONT ;continue processing an enhance ack msg. called from DEFACK
"RTN","HLTP3",80,0)
 ;Set special HL variables for processing rtn
"RTN","HLTP3",81,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLTP3",82,0)
 ;
"RTN","HLTP3",83,0)
 ; message is an acknowledgement, HLMSA=ack code^id^text
"RTN","HLTP3",84,0)
 I ($G(HLMSA)]"") D  Q
"RTN","HLTP3",85,0)
 . ;X=1 if ack ok, 0=reject of error
"RTN","HLTP3",86,0)
 . S X=$E(HLMSA,2)="A"
"RTN","HLTP3",87,0)
 . ;Update status of original subscriber message and remove it from the out-going queue
"RTN","HLTP3",88,0)
 . D STATUS^HLTF0(HL("MTIENS"),$S(X:3,1:4),"",$S(X:"",1:$P(HLMSA,HL("FS"),3)),1)
"RTN","HLTP3",89,0)
 . D DEQUE^HLCSREP($P($G(^HLMA(HL("MTIENS"),0)),"^",7),"O",HL("MTIENS"))
"RTN","HLTP3",90,0)
 . D
"RTN","HLTP3",91,0)
 .. N HLTCP ;New variable to update status in file #772.
"RTN","HLTP3",92,0)
 .. D PROCACK^HLTP2(HLMTIEN,HL("EID"),.HLRESLT,.HL)
"RTN","HLTP3",93,0)
 . ;update status of incoming to complete & unlock
"RTN","HLTP3",94,0)
 . D STATUS^HLTF0(HLMTIENS,$S($G(HLRESLT):4,1:3),$S($G(HLRESLT):+$G(HLRESLT),1:""),$S($G(HLRESLT):$P(HLRESLT,U,2),1:""),1),EXIT
"RTN","HLTP3",95,0)
 ;
"RTN","HLTP3",96,0)
 ;get entry action, exit action and processing routine
"RTN","HLTP3",97,0)
 K HLHDR,HLLD0,HLLD1,HLMSA
"RTN","HLTP3",98,0)
 I HL("EIDS")="",$G(HLEIDS)]"" S HL("EIDS")=HLEIDS ;**CIRN**
"RTN","HLTP3",99,0)
 D EVENT^HLUTIL1(HL("EIDS"),"15,20,771",.HLN)
"RTN","HLTP3",100,0)
 S HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15)),HLPROU=$G(HLN(771))
"RTN","HLTP3",101,0)
 ;quit if no processing routine,update status and quit
"RTN","HLTP3",102,0)
 I HLPROU']"" S HLRESLT="10^"_$G(^HL(771.7,10,0)) D STATUS^HLTF0(HLMTIENS,3,,,1),EXIT Q
"RTN","HLTP3",103,0)
 ;HLORNOD=subscriber protocol for Fileman auditing, ien;global ref
"RTN","HLTP3",104,0)
 N HLORNODD S HLORNOD=HL("EIDS")_";ORD(101,"
"RTN","HLTP3",105,0)
 ;Execute entry action of client protocol
"RTN","HLTP3",106,0)
 X:HLENROU]"" HLENROU K HLENROU,HLDONE1
"RTN","HLTP3",107,0)
 ;
"RTN","HLTP3",108,0)
 ;Execute processing routine
"RTN","HLTP3",109,0)
 X HLPROU S HLRESLT=0 S:($D(HLERR)) HLRESLT="9^"_HLERR
"RTN","HLTP3",110,0)
 ;update status of incoming to complete & unlock
"RTN","HLTP3",111,0)
 D STATUS^HLTF0(HLMTIENS,$S(HLRESLT:4,1:3),$S(HLRESLT:+HLRESLT,1:""),$S(HLRESLT:$P(HLRESLT,U,2),1:""),1,$S($G(HLERR("SKIP_EVENT"))=1:1,1:0)),EXIT
"RTN","HLTP3",112,0)
 ;HLTCPO=link open, HLTCP=ien of acknowledgment msg. from GENACK
"RTN","HLTP3",113,0)
ACK I $G(HLTCPO),$G(HLTCP) D  Q
"RTN","HLTP3",114,0)
 . D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",115,0)
 . ;write ack back over open tcp link
"RTN","HLTP3",116,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",117,0)
 . ;update status of ack to complete
"RTN","HLTP3",118,0)
 . D:'$G(HLASTRSP) STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",119,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",120,0)
 Q
"RTN","HLTP3",121,0)
 ;
"RTN","HLTP3",122,0)
DEFACK(HLDP,X) ;process the deferred application ack, called from HLCSIN
"RTN","HLTP3",123,0)
 ;HLDP=logical link, X=ien in file 773
"RTN","HLTP3",124,0)
 ;set error trap
"RTN","HLTP3",125,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP3",126,0)
 N HLERR     ;patch HL*1.6*109
"RTN","HLTP3",127,0)
 Q:'$G(HLDP)!'$G(X)  Q:'$G(^HLMA(X,0))
"RTN","HLTP3",128,0)
 ;**109 START**
"RTN","HLTP3",129,0)
 ;try lock, quit if can't lock or x-ref is gone
"RTN","HLTP3",130,0)
 ;L +^HLMA(X):0 Q:'$T
"RTN","HLTP3",131,0)
 ;L +^HLMA("AC","I",HLDP,X):0 I '$T L -^HLMA(X) Q
"RTN","HLTP3",132,0)
 ;L -^HLMA("AC","I",HLDP,X)
"RTN","HLTP3",133,0)
 ;I '$D(^HLMA("AC","I",HLDP,X)) L -^HLMA(X) Q
"RTN","HLTP3",134,0)
 Q:'$D(^HLMA("AC","I",HLDP,X))
"RTN","HLTP3",135,0)
 ;**109 END**
"RTN","HLTP3",136,0)
 ;
"RTN","HLTP3",137,0)
 N HL,HLA,HLD0,HLEID,HLEIDS,HLHDR,HLHDRO,HLMTIEN,HLMTIENS,HLJ,HLMSA,HLN,HLQUIT,HLNODE,HLNEXT,HLRESLT,HLRESLTA,HLTCP,HLXX,Z,HLDONE1
"RTN","HLTP3",138,0)
 ;setup variables
"RTN","HLTP3",139,0)
 S HLMTIENS=X,X=^HLMA(HLMTIENS,0),HLMTIEN=+$P(X,U),HL("MID")=$P(X,U,2),HL("MTIENS")=$P(X,U,10),HL("LL")=$P(X,U,7),HLTCP="",HL("Q")=""""""
"RTN","HLTP3",140,0)
 S HL("EIDS")=$P(X,U,8),HL("SAP")=$P(X,U,11),HL("RAP")=$P(X,U,12),HL("MTP")=$P(X,U,13),HL("ETP")=$P(X,U,14)
"RTN","HLTP3",141,0)
 S:$P(X,U,15) HL("MTP_ETP")=$P(X,U,15)
"RTN","HLTP3",142,0)
 S:HL("SAP") HL("SAN")=$P($G(^HL(771,HL("SAP"),0)),U) S:HL("RAP") HL("RAN")=$P($G(^HL(771,HL("RAP"),0)),U)
"RTN","HLTP3",143,0)
 S:HL("MTP") HL("MTN")=$P($G(^HL(771.2,HL("MTP"),0)),U) S:HL("ETP") HL("ETN")=$P($G(^HL(779.001,HL("ETP"),0)),U)
"RTN","HLTP3",144,0)
 S:$G(HL("MTP_ETP")) HL("MTN_ETN")=$P($G(^HL(779.005,HL("MTP_ETP"),0)),U)
"RTN","HLTP3",145,0)
 S HL("EID")=$P($G(^HL(772,HLMTIEN,0)),U,10)
"RTN","HLTP3",146,0)
 M HLHDRO=^HLMA(HLMTIENS,"MSH")
"RTN","HLTP3",147,0)
 ; if no header quit
"RTN","HLTP3",148,0)
 ;**109**
"RTN","HLTP3",149,0)
 ;I '$O(HLHDRO(0)) L -^HLMA(HLMTIENS) Q
"RTN","HLTP3",150,0)
 Q:'$O(HLHDRO(0))
"RTN","HLTP3",151,0)
 ;
"RTN","HLTP3",152,0)
 S HL("FS")=$E(HLHDRO(1,0),4),HL("ECH")=$$P^HLTPCK2(.HLHDRO,2),HL("SFN")=$$P^HLTPCK2(.HLHDRO,4),HL("RFN")=$$P^HLTPCK2(.HLHDRO,6),HL("DTM")=$$P^HLTPCK2(.HLHDRO,7)
"RTN","HLTP3",153,0)
 ;
"RTN","HLTP3",154,0)
 ; patch HL*1.6*109 start
"RTN","HLTP3",155,0)
 ; quit if ien of #772 is not defined
"RTN","HLTP3",156,0)
 Q:'HLMTIEN
"RTN","HLTP3",157,0)
 ; quit if field separator is not defined
"RTN","HLTP3",158,0)
 Q:HL("FS")=""
"RTN","HLTP3",159,0)
 ; quit if this is a commit ack
"RTN","HLTP3",160,0)
 Q:$P(^HL(772,HLMTIEN,"IN",1,0),HL("FS"),2)["C"
"RTN","HLTP3",161,0)
 ; patch HL*1.6*109 end
"RTN","HLTP3",162,0)
 ;
"RTN","HLTP3",163,0)
 S X=$$P^HLTPCK2(.HLHDRO,1)
"RTN","HLTP3",164,0)
 I X="MSH" S HL("PID")=$$P^HLTPCK2(.HLHDRO,11),HL("VER")=$$P^HLTPCK2(.HLHDRO,12),HL("APAT")=$$P^HLTPCK2(.HLHDRO,16),HL("CC")=$$P^HLTPCK2(.HLHDRO,17)
"RTN","HLTP3",165,0)
 I X'="MSH" D
"RTN","HLTP3",166,0)
 . S X=$$P^HLTPCK2(.HLHDRO,9),Z=$E(HL("ECH")),HL("PID")=$P(X,Z,2),HL("VER")=$P(X,Z,4)
"RTN","HLTP3",167,0)
 . Q:$$P^HLTPCK2(.HLHDRO,10)=""
"RTN","HLTP3",168,0)
 . ;HLMSA=ack code^id^text
"RTN","HLTP3",169,0)
 . S HLMSA=$P($$P^HLTPCK2(.HLHDRO,10),$E(HL("ECH")),1),$P(HLMSA,HL("FS"),2)=$$P^HLTPCK2(.HLHDRO,12),$P(HLMSA,HL("FS"),3)=$P($$P^HLTPCK2(.HLHDRO,10),$E(HL("ECH")),2),HL("MSAID")=$P(HLMSA,HL("FS"),2)
"RTN","HLTP3",170,0)
 ;Set up destination for 2-phase commit
"RTN","HLTP3",171,0)
 ;If facility data didn't come from 771
"RTN","HLTP3",172,0)
 I $G(HL("SAP")) D
"RTN","HLTP3",173,0)
 .N HLSF,HLINST,HLLINK,HLI
"RTN","HLTP3",174,0)
 .N HLDOMAIN    ; patch HL*1.6*109
"RTN","HLTP3",175,0)
 .S HLSF=$P(^HL(771,HL("SAP"),0),U,3)
"RTN","HLTP3",176,0)
 .Q:HLSF]""  ;application-defined facility
"RTN","HLTP3",177,0)
 . ; patch HL*1.6*109
"RTN","HLTP3",178,0)
 .S HLDOMAIN=$P(HL("SFN"),$E(HL("ECH")),2)
"RTN","HLTP3",179,0)
 .I HLDOMAIN]"" D
"RTN","HLTP3",180,0)
 .. D LINK^HLUTIL3(HLDOMAIN,.HLI,"D")
"RTN","HLTP3",181,0)
 .. S HLLINK=$O(HLI(0))
"RTN","HLTP3",182,0)
 .. I HLLINK S HLL("LINKS",1)="^"_HLLINK
"RTN","HLTP3",183,0)
 .Q:$G(HLLINK)
"RTN","HLTP3",184,0)
 .S HLINST=$P(HL("SFN"),$E(HL("ECH")))
"RTN","HLTP3",185,0)
 .Q:HLINST']""
"RTN","HLTP3",186,0)
 .D LINK^HLUTIL3(HLINST,.HLI,"I")
"RTN","HLTP3",187,0)
 .S HLLINK=$O(HLI(0))
"RTN","HLTP3",188,0)
 .Q:'HLLINK
"RTN","HLTP3",189,0)
 . ; patch HL*1.6*109 end
"RTN","HLTP3",190,0)
 . ;
"RTN","HLTP3",191,0)
 .S HLL("LINKS",1)="^"_HLLINK
"RTN","HLTP3",192,0)
 D CONT
"RTN","HLTP3",193,0)
 Q
"RTN","HLTP3",194,0)
 ;
"RTN","HLTP3",195,0)
MSA(Y) ;Y=ien in 772, returns MSA segment
"RTN","HLTP3",196,0)
 ;ack code^msg being ack id^text
"RTN","HLTP3",197,0)
 N X
"RTN","HLTP3",198,0)
 S X=$G(^HL(772,Y,"IN",1,0)),X=$S($E(X,1,3)="MSA":$E(X,5,999),1:"")
"RTN","HLTP3",199,0)
 Q X
"RTN","HLTP3",200,0)
 ;
"RTN","HLTP3",201,0)
ERROR ;error trap
"RTN","HLTP3",202,0)
 D ^%ZTER
"RTN","HLTP3",203,0)
 I $G(HLMTIENS),$D(^HLMA(HLMTIENS,0)) D STATUS^HLTF0(HLMTIENS,4,,,1),EXIT
"RTN","HLTP3",204,0)
 ;*109* release all locks created by inbound filer
"RTN","HLTP3",205,0)
 L -^HLMA("AC","I",+$G(HLXX))
"RTN","HLTP3",206,0)
 G UNWIND^%ZTER
"RTN","HLTP3",207,0)
 ;
"RTN","HLTP3",208,0)
 ;
"RTN","HLTP3",209,0)
EXIT ;unlock
"RTN","HLTP3",210,0)
 I $G(HLMTIENS) L -^HLMA(HLMTIENS)
"RTN","HLTP3",211,0)
 Q
"RTN","HLTP3",212,0)
 ;
"RTN","HLTP3",213,0)
ONAC(IEN773) ;
"RTN","HLTP3",214,0)
 ;Returns 1 if the message is on the "AC","I" xref
"RTN","HLTP3",215,0)
 ;Returns 0 otherwise
"RTN","HLTP3",216,0)
 ;
"RTN","HLTP3",217,0)
 N LINK
"RTN","HLTP3",218,0)
 S LINK=$P($G(^HLMA(IEN773,0)),"^",17)
"RTN","HLTP3",219,0)
 Q:'LINK 0
"RTN","HLTP3",220,0)
 Q $D(^HLMA("AC","I",LINK,IEN773))
"VER")
8.0^22.0
**END**
**END**
