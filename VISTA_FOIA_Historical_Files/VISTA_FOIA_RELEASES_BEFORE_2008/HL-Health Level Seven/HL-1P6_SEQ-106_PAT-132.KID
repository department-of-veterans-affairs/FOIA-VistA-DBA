Released HL*1.6*132 SEQ #106
Extracted from mail message
**KIDS**:HL*1.6*132^

**INSTALL NAME**
HL*1.6*132
"BLD",968,0)
HL*1.6*132^HEALTH LEVEL SEVEN^0^3061102^y
"BLD",968,1,0)
^^2^2^3060901^
"BLD",968,1,1,0)
See the National Patch Module on Forum.
"BLD",968,1,2,0)

"BLD",968,4,0)
^9.64PA^779.2^1
"BLD",968,4,779.2,0)
779.2
"BLD",968,4,779.2,222)
y^n^f^^^^n
"BLD",968,4,"B",779.2,779.2)

"BLD",968,6.3)
6
"BLD",968,"KRN",0)
^9.67PA^8989.52^19
"BLD",968,"KRN",.4,0)
.4
"BLD",968,"KRN",.401,0)
.401
"BLD",968,"KRN",.402,0)
.402
"BLD",968,"KRN",.402,"NM",0)
^9.68A^1^1
"BLD",968,"KRN",.402,"NM",1,0)
HLOAPREG    FILE #779.2^779.2^0
"BLD",968,"KRN",.402,"NM","B","HLOAPREG    FILE #779.2",1)

"BLD",968,"KRN",.403,0)
.403
"BLD",968,"KRN",.5,0)
.5
"BLD",968,"KRN",.84,0)
.84
"BLD",968,"KRN",3.6,0)
3.6
"BLD",968,"KRN",3.8,0)
3.8
"BLD",968,"KRN",9.2,0)
9.2
"BLD",968,"KRN",9.8,0)
9.8
"BLD",968,"KRN",9.8,"NM",0)
^9.68A^11^11
"BLD",968,"KRN",9.8,"NM",1,0)
HLOAPP^^0^B9133319
"BLD",968,"KRN",9.8,"NM",2,0)
HLOQUE^^0^B5510606
"BLD",968,"KRN",9.8,"NM",3,0)
HLOAPI1^^0^B47955238
"BLD",968,"KRN",9.8,"NM",4,0)
HLOPBLD1^^0^B22231914
"BLD",968,"KRN",9.8,"NM",5,0)
HLCSTCP1^^0^B37159862
"BLD",968,"KRN",9.8,"NM",6,0)
HLOPRS^^0^B29583267
"BLD",968,"KRN",9.8,"NM",7,0)
HLOPBLD^^0^B11482408
"BLD",968,"KRN",9.8,"NM",8,0)
HLCS^^0^B32818553
"BLD",968,"KRN",9.8,"NM",9,0)
HLMA^^0^B41973628
"BLD",968,"KRN",9.8,"NM",10,0)
HLOCVU^^0^B6948622
"BLD",968,"KRN",9.8,"NM",11,0)
HLOCNRT^^0^B4616658
"BLD",968,"KRN",9.8,"NM","B","HLCS",8)

"BLD",968,"KRN",9.8,"NM","B","HLCSTCP1",5)

"BLD",968,"KRN",9.8,"NM","B","HLMA",9)

"BLD",968,"KRN",9.8,"NM","B","HLOAPI1",3)

"BLD",968,"KRN",9.8,"NM","B","HLOAPP",1)

"BLD",968,"KRN",9.8,"NM","B","HLOCNRT",11)

"BLD",968,"KRN",9.8,"NM","B","HLOCVU",10)

"BLD",968,"KRN",9.8,"NM","B","HLOPBLD",7)

"BLD",968,"KRN",9.8,"NM","B","HLOPBLD1",4)

"BLD",968,"KRN",9.8,"NM","B","HLOPRS",6)

"BLD",968,"KRN",9.8,"NM","B","HLOQUE",2)

"BLD",968,"KRN",19,0)
19
"BLD",968,"KRN",19,"NM",0)
^9.68A^^
"BLD",968,"KRN",19.1,0)
19.1
"BLD",968,"KRN",101,0)
101
"BLD",968,"KRN",409.61,0)
409.61
"BLD",968,"KRN",771,0)
771
"BLD",968,"KRN",870,0)
870
"BLD",968,"KRN",8989.51,0)
8989.51
"BLD",968,"KRN",8989.52,0)
8989.52
"BLD",968,"KRN",8994,0)
8994
"BLD",968,"KRN","B",.4,.4)

"BLD",968,"KRN","B",.401,.401)

"BLD",968,"KRN","B",.402,.402)

"BLD",968,"KRN","B",.403,.403)

"BLD",968,"KRN","B",.5,.5)

"BLD",968,"KRN","B",.84,.84)

"BLD",968,"KRN","B",3.6,3.6)

"BLD",968,"KRN","B",3.8,3.8)

"BLD",968,"KRN","B",9.2,9.2)

"BLD",968,"KRN","B",9.8,9.8)

"BLD",968,"KRN","B",19,19)

"BLD",968,"KRN","B",19.1,19.1)

"BLD",968,"KRN","B",101,101)

"BLD",968,"KRN","B",409.61,409.61)

"BLD",968,"KRN","B",771,771)

"BLD",968,"KRN","B",870,870)

"BLD",968,"KRN","B",8989.51,8989.51)

"BLD",968,"KRN","B",8989.52,8989.52)

"BLD",968,"KRN","B",8994,8994)

"BLD",968,"QUES",0)
^9.62^^
"BLD",968,"REQB",0)
^9.611^1^1
"BLD",968,"REQB",1,0)
HL*1.6*133^2
"BLD",968,"REQB","B","HL*1.6*133",1)

"FIA",779.2)
HLO APPLICATION REGISTRY
"FIA",779.2,0)
^HLD(779.2,
"FIA",779.2,0,0)
779.2
"FIA",779.2,0,1)
y^n^f^^^^n
"FIA",779.2,0,10)

"FIA",779.2,0,11)

"FIA",779.2,0,"RLRO")

"FIA",779.2,0,"VR")
1.6^HL
"FIA",779.2,779.2)
0
"FIA",779.2,779.21)
0
"IX",779.2,779.2,"C",0)
779.2^C^Uniqueness Index for Key 'A' of File #779.2^R^^F^IR^I^779.2^^^^^LS
"IX",779.2,779.2,"C",1)
S ^HLD(779.2,"C",X,DA)=""
"IX",779.2,779.2,"C",2)
K ^HLD(779.2,"C",X,DA)
"IX",779.2,779.2,"C",2.5)
K ^HLD(779.2,"C")
"IX",779.2,779.2,"C",11.1,0)
^.114IA^1^1
"IX",779.2,779.2,"C",11.1,1,0)
1^F^779.2^.01^^1
"IX",779.2,779.21,"C",0)
779.21^C^action by message type,event,version not specified^MU^^R^IR^I^779.21^^^^^LS
"IX",779.2,779.21,"C",.1,0)
^^4^4^3060626^
"IX",779.2,779.21,"C",.1,1,0)
This index is used to find the application action by message type and event
"IX",779.2,779.21,"C",.1,2,0)
in cases where the application has chosen NOT to also specify the action
"IX",779.2,779.21,"C",.1,3,0)
according to the HL7 version.
"IX",779.2,779.21,"C",.1,4,0)

"IX",779.2,779.21,"C",1)
S ^HLD(779.2,DA(1),1,"C",X(1),X(2),DA)=""
"IX",779.2,779.21,"C",1.4)
S:$P(^HLD(779.2,DA(1),1,DA,0),"^",6)="" X=1
"IX",779.2,779.21,"C",2)
K ^HLD(779.2,DA(1),1,"C",X(1),X(2),DA)
"IX",779.2,779.21,"C",2.5)
K ^HLD(779.2,DA(1),1,"C")
"IX",779.2,779.21,"C",11.1,0)
^.114IA^2^2
"IX",779.2,779.21,"C",11.1,1,0)
1^F^779.21^.01^^1
"IX",779.2,779.21,"C",11.1,2,0)
2^F^779.21^.02^^2^F
"IX",779.2,779.21,"D",0)
779.21^D^lookup message type including version^R^^R^IR^I^779.21^^^^^LS
"IX",779.2,779.21,"D",1)
S ^HLD(779.2,DA(1),1,"D",$E(X(1),1,30),$E(X(2),1,30),$E(X(3),1,30),DA)=""
"IX",779.2,779.21,"D",2)
K ^HLD(779.2,DA(1),1,"D",$E(X(1),1,30),$E(X(2),1,30),$E(X(3),1,30),DA)
"IX",779.2,779.21,"D",2.5)
K ^HLD(779.2,DA(1),1,"D")
"IX",779.2,779.21,"D",11.1,0)
^.114IA^3^3
"IX",779.2,779.21,"D",11.1,1,0)
1^F^779.21^.01^30^1^F
"IX",779.2,779.21,"D",11.1,1,3)

"IX",779.2,779.21,"D",11.1,2,0)
2^F^779.21^.02^30^2^F
"IX",779.2,779.21,"D",11.1,2,3)

"IX",779.2,779.21,"D",11.1,3,0)
3^F^779.21^.06^30^3^F
"IX",779.2,779.21,"D",11.1,3,3)

"KEY",779.2,779.2,"A",0)
779.2^A^P^68
"KEY",779.2,779.2,"A",2,0)
^.312IA^1^1
"KEY",779.2,779.2,"A",2,1,0)
.01^779.2^1
"KEYPTR",779.2,779.2,"A")
779.2^C
"KRN",.402,77,-1)
0^1
"KRN",.402,77,0)
HLOAPREG^3060626.1202^@^779.2^^@^3060626
"KRN",.402,77,"DIAB",1,1,779.21,0)
ALL
"KRN",.402,77,"DR",1,779.2)
.01;2;.09;.03;.06;.07;.08;.04;.05;1;
"KRN",.402,77,"DR",2,779.21)
.01:.07
"MBREQ")
0
"ORD",7,.402)
.402;7;;;EDEOUT^DIFROMSO(.402,DA,"",XPDA);FPRE^DIFROMSI(.402,"",XPDA);EPRE^DIFROMSI(.402,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.402,DA,"",XPDA);DEL^DIFROMSK(.402,"",%)
"ORD",7,.402,0)
INPUT TEMPLATE
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
132^3061102
"PKG",9,22,1,"PAH",1,1,0)
^^2^2^3061102
"PKG",9,22,1,"PAH",1,1,1,0)
See the National Patch Module on Forum.
"PKG",9,22,1,"PAH",1,1,2,0)

"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
11
"RTN","HLCS")
0^8^B32818553^B29807650
"RTN","HLCS",1,0)
HLCS ;ALB/RJS,MTC,JRP - COMMUNICATIONS SERVER - ;10/31/2006
"RTN","HLCS",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**2,9,14,19,43,57,109,132**;Oct 13, 1995;Build 6
"RTN","HLCS",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCS",4,0)
 ;
"RTN","HLCS",5,0)
 ;The SEND function is invoked by the transaction processor.
"RTN","HLCS",6,0)
 ;It's function is to $O through the ITEM multiple of the Event Driver
"RTN","HLCS",7,0)
 ;Protocol and create child entries in the Message Text file (#772)
"RTN","HLCS",8,0)
 ;for the message at HLMTIEN.  These child messages point back
"RTN","HLCS",9,0)
 ;to the parent message so that message text does not need to
"RTN","HLCS",10,0)
 ;be duplicated when a message is sent to multiple applications.
"RTN","HLCS",11,0)
 ;
"RTN","HLCS",12,0)
 ;The SENDACK function is also invoked by the transaction processor.
"RTN","HLCS",13,0)
 ;It's function is to create a child entry in the Message Text file
"RTN","HLCS",14,0)
 ;for the message at HLMTIENA and deliver the message to the
"RTN","HLCS",15,0)
 ;application the requested/sent information.
"RTN","HLCS",16,0)
 ;
"RTN","HLCS",17,0)
 ;For DHCP to DHCP messaging (i.e. internal to internal), an incoming
"RTN","HLCS",18,0)
 ;message is created in the Message Text file which is a duplication
"RTN","HLCS",19,0)
 ;of the outgoing message.  The incoming message is then processed by
"RTN","HLCS",20,0)
 ;calling the transaction processor.
"RTN","HLCS",21,0)
 ;
"RTN","HLCS",22,0)
 ;For DHCP to COTS messaging (i.e. internal to external), the message
"RTN","HLCS",23,0)
 ;is filed in the Message Text file with the Logical Link defined and
"RTN","HLCS",24,0)
 ;a status of PENDING TRANSMISSION.  These entries are picked up by
"RTN","HLCS",25,0)
 ;the background filer and transmitted to the appropriate COTS system.
"RTN","HLCS",26,0)
 ;
"RTN","HLCS",27,0)
SEND(HLMTIEN,HLEID,HLRESULT) ;Send an HL7 message
"RTN","HLCS",28,0)
 ;HLMTIEN=The IEN of the parent message in file # 772
"RTN","HLCS",29,0)
 ;HLEID=The IEN of the Event Driver protocol in file #101
"RTN","HLCS",30,0)
 ;HLRESULT=Variable for any error text (pass by reference)
"RTN","HLCS",31,0)
 ;
"RTN","HLCS",32,0)
 ;Declare variables
"RTN","HLCS",33,0)
 N HLARY,HLERROR,HLEIDS,HLCLIENT,HLOGLINK,HLMTIENS,HLMSGPTR
"RTN","HLCS",34,0)
 S HLERROR=""
"RTN","HLCS",35,0)
 ;Direct connect
"RTN","HLCS",36,0)
 I HLPRIO="I" D  Q
"RTN","HLCS",37,0)
 . D DC^HLMA2
"RTN","HLCS",38,0)
 . S HLRESULT=HLERROR
"RTN","HLCS",39,0)
 ;Get all subscribers to the message
"RTN","HLCS",40,0)
 D ITEM^HLUTIL2(HLEID,"PTR")
"RTN","HLCS",41,0)
 ;Quit if no subscribers (considered successful delivery)
"RTN","HLCS",42,0)
 G:($G(HLARY(0))'>0) EXIT
"RTN","HLCS",43,0)
 ;Deliver message to each subscriber
"RTN","HLCS",44,0)
 S HLEIDS=0
"RTN","HLCS",45,0)
 F  S HLEIDS=$O(HLARY(HLEIDS)) Q:(HLEIDS'>0)  D
"RTN","HLCS",46,0)
 .;
"RTN","HLCS",47,0)
 .;**132 excluded subscribers **
"RTN","HLCS",48,0)
 .N I,EXCLUDE
"RTN","HLCS",49,0)
 .S (EXCLUDE,I)=0
"RTN","HLCS",50,0)
 .F  S I=$O(HLP("EXCLUDE SUBSCRIBER",I)) Q:'I  I $G(HLP("EXCLUDE SUBSCRIBER",I))=HLEIDS S EXCLUDE=1 Q
"RTN","HLCS",51,0)
 .Q:EXCLUDE
"RTN","HLCS",52,0)
 .;** 132 end **
"RTN","HLCS",53,0)
 .;
"RTN","HLCS",54,0)
 .;Get pointer to receiving application
"RTN","HLCS",55,0)
 .S HLCLIENT=+HLARY(HLEIDS),HL("EIDS")=HLEIDS,HLERROR=""
"RTN","HLCS",56,0)
 .Q:(HLCLIENT'>0)
"RTN","HLCS",57,0)
 .;Check and execute ROUTING LOGIC **CIRN**
"RTN","HLCS",58,0)
 .S HLX=$G(^ORD(101,HLEIDS,774))
"RTN","HLCS",59,0)
 .I HLX]"" D  Q
"RTN","HLCS",60,0)
 ..N HLQUIT,HLNODE,HLNEXT
"RTN","HLCS",61,0)
 ..S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLCS",62,0)
 ..X HLX I $D(HLL("LINKS")) D FWD^HLCS2 K HLL ;**CIRN**
"RTN","HLCS",63,0)
 .;Get pointer to logical link
"RTN","HLCS",64,0)
 .S HLOGLINK=$P(HLARY(HLEIDS),"^",2)
"RTN","HLCS",65,0)
 .;Determine if receiving application is internal or external
"RTN","HLCS",66,0)
 .;  Logical link has a value for external applications
"RTN","HLCS",67,0)
 .;  Logical link is NULL for internal applications
"RTN","HLCS",68,0)
 .I (HLOGLINK) D COTS Q
"RTN","HLCS",69,0)
 .;Create 'incoming' message based on 'outgoing' message (internal)
"RTN","HLCS",70,0)
 .D DHCP(HLMTIEN,HLEIDS,HLCLIENT)
"RTN","HLCS",71,0)
 .Q:(HLERROR)
"RTN","HLCS",72,0)
 .;Process the 'incoming' message
"RTN","HLCS",73,0)
 .S HLERROR=""
"RTN","HLCS",74,0)
 .D PROCESS^HLTP0(HLMSGPTR,"DHCP","",.HLERROR)
"RTN","HLCS",75,0)
 .;Update Status of 'incoming' message to SUCCESSFULLY COMPLETED
"RTN","HLCS",76,0)
 .; or ERROR DURING TRANSMISSION
"RTN","HLCS",77,0)
 .D STATUS^HLTF0(HLMSGPTR,$S(HLERROR:4,1:3),$S(HLERROR:+HLERROR,1:""),$S(HLERROR:$P(HLERROR,"^",2),1:""),,$S($G(HLERR("SKIP_EVENT"))=1:1,1:0))
"RTN","HLCS",78,0)
 .I $D(HLL("LINKS")) D FWD^HLCS2 K HLL ;**CIRN**
"RTN","HLCS",79,0)
 D ADD^HLCS2 ;**CIRN**
"RTN","HLCS",80,0)
EXIT S HLRESULT=HLERROR
"RTN","HLCS",81,0)
 Q
"RTN","HLCS",82,0)
COTS ;Internal to external communication
"RTN","HLCS",83,0)
 ;Create child entry in Message Text file
"RTN","HLCS",84,0)
 N HLTCP,HLTCPI,HLTCPO
"RTN","HLCS",85,0)
 D SEND^HLMA2(HLEIDS,HLMTIEN,HLCLIENT,"D",.HLMTIENS,HLOGLINK)
"RTN","HLCS",86,0)
 I ((+HLMTIENS)'>0) S HLERROR=HLMTIENS Q
"RTN","HLCS",87,0)
 ;'Pass' message to background filer by setting status of child
"RTN","HLCS",88,0)
 ;  to PENDING TRANSMISSION
"RTN","HLCS",89,0)
 D STATUS^HLTF0(HLMTIENS,1)
"RTN","HLCS",90,0)
 Q
"RTN","HLCS",91,0)
DHCP(HLMTIEN,HLEIDS,HLCLIENT) ;Internal to internal communication
"RTN","HLCS",92,0)
 ;
"RTN","HLCS",93,0)
 ;Input  : HLMTIEN - Pointer to parent outgoing message (file #772)
"RTN","HLCS",94,0)
 ;         HLEIDS - Pointer to subscribing protocol (file #101)
"RTN","HLCS",95,0)
 ;         HLCLIENT - Pointer to receiving application (file # 771)
"RTN","HLCS",96,0)
 ;
"RTN","HLCS",97,0)
 ;Output : HLMTIENS - Pointer to child outgoing message (file #772)
"RTN","HLCS",98,0)
 ;         HLMSGPTR - Pointer to [parent] incoming message (file #772)
"RTN","HLCS",99,0)
 ;         HLERROR - ErrorCode ^ ErrorText
"RTN","HLCS",100,0)
 ;
"RTN","HLCS",101,0)
 ;Notes  : This module only copies the outgoing message into an incoming
"RTN","HLCS",102,0)
 ;         message.  Delivery of the message (i.e. processing of it)
"RTN","HLCS",103,0)
 ;         must be done by the calling application.
"RTN","HLCS",104,0)
 ;       : Message/batch header (MSH/BSH) is built and placed in the
"RTN","HLCS",105,0)
 ;         incoming message
"RTN","HLCS",106,0)
 ;       : HLMTIENS, HLMSGPTR, and HLERROR will be initialized
"RTN","HLCS",107,0)
 ;       : Existance and validity of input is assumed
"RTN","HLCS",108,0)
 ;
"RTN","HLCS",109,0)
 ;Declare variables
"RTN","HLCS",110,0)
 N MSGID,MSGDT,MSGDTH,HDR2BLD,TMP,HLHDR,BHSHDR
"RTN","HLCS",111,0)
 S HLERROR=""
"RTN","HLCS",112,0)
 S HLMTIENS=0
"RTN","HLCS",113,0)
 S HLMSGPTR=0
"RTN","HLCS",114,0)
 ;Create child entry in Message Text file
"RTN","HLCS",115,0)
 D SEND^HLMA2(HLEIDS,HLMTIEN,HLCLIENT,"D",.HLMTIENS)
"RTN","HLCS",116,0)
 I ((+HLMTIENS)'>0) S HLERROR=HLMTIENS Q
"RTN","HLCS",117,0)
 ;'Receive' message by making an incoming message
"RTN","HLCS",118,0)
 ;Determine type of header to build
"RTN","HLCS",119,0)
 S TMP=$G(^HL(772,HLMTIEN,0))
"RTN","HLCS",120,0)
 S HDR2BLD=$P(TMP,"^",14)
"RTN","HLCS",121,0)
 ;Build message header (MSH)
"RTN","HLCS",122,0)
 I (HDR2BLD="M") D  Q:(HLERROR)
"RTN","HLCS",123,0)
 .S TMP=""
"RTN","HLCS",124,0)
 .D HEADER^HLCSHDR(HLMTIENS,.TMP)
"RTN","HLCS",125,0)
 .Q:(TMP="")
"RTN","HLCS",126,0)
 .;Error building header
"RTN","HLCS",127,0)
 .S HLERROR="4^Unable to build message header => "_TMP
"RTN","HLCS",128,0)
 .D STATUS^HLTF0(HLMTIENS,4,0,$P(HLERROR,"^",2))
"RTN","HLCS",129,0)
 ;Build batch header (BHS or FHS)
"RTN","HLCS",130,0)
 I (HDR2BLD'="M") D  Q:(HLERROR)
"RTN","HLCS",131,0)
 .S TMP=""
"RTN","HLCS",132,0)
 .D BHSHDR^HLCSHDR(HLMTIENS)
"RTN","HLCS",133,0)
 .S:($E(HLHDR(1),1)="-") TMP=$P(HLHDR(1),"^",2)
"RTN","HLCS",134,0)
 .Q:(TMP="")
"RTN","HLCS",135,0)
 .;Error building header
"RTN","HLCS",136,0)
 .S HLERROR="4^Unable to build batch header => "_TMP
"RTN","HLCS",137,0)
 .D STATUS^HLTF0(HLMTIENS,4,0,$P(HLERROR,"^",2))
"RTN","HLCS",138,0)
 ;Create entry for 'incoming' message
"RTN","HLCS",139,0)
 D CREATE^HLTF(.MSGID,.HLMSGPTR,.MSGDT,.MSGDTH)
"RTN","HLCS",140,0)
 ;Move header and rest of message into 'incoming' message
"RTN","HLCS",141,0)
 I (HDR2BLD="M") D
"RTN","HLCS",142,0)
 .;Use MSH as header
"RTN","HLCS",143,0)
 .D MRGINT^HLTF1(HLMTIEN,HLMSGPTR,"HLHDR")
"RTN","HLCS",144,0)
 I (HDR2BLD'="M") D
"RTN","HLCS",145,0)
 .;Use BHS or FHS as header
"RTN","HLCS",146,0)
 .D MRGINT^HLTF1(HLMTIEN,HLMSGPTR,"BHSHDR")
"RTN","HLCS",147,0)
 ;Set status of outgoing message to AWAITING ACKNOWLEDGEMENT
"RTN","HLCS",148,0)
 D STATUS^HLTF0(HLMTIENS,$S($P(^HL(772,HLMTIEN,0),U,7):3,1:2))
"RTN","HLCS",149,0)
 ;Set status of 'incoming' message to AWAITING PROCESSING
"RTN","HLCS",150,0)
 D STATUS^HLTF0(HLMSGPTR,9)
"RTN","HLCS",151,0)
 Q
"RTN","HLCS",152,0)
SENDACK(HLMTIENA,HLEID,HLEIDS,HLRESULT) ;Send an HL7 acknowledgement/response
"RTN","HLCS",153,0)
 ;HLMTIENA=The IEN of the parent acknowledgment/response message in
"RTN","HLCS",154,0)
 ;         file # 772
"RTN","HLCS",155,0)
 ;HLEIDS=The IEN of the Subscribing protocol in file # 101
"RTN","HLCS",156,0)
 ;HLEID=The IEN of the Event Driver protocol in file #101
"RTN","HLCS",157,0)
 ;HLRESULT=Variable for any error text (pass by reference)
"RTN","HLCS",158,0)
 ;
"RTN","HLCS",159,0)
 N HLERROR,HLOGLINK,HLCLIENT,HLMTIENS,HLMSGPTR,HLCLNODE
"RTN","HLCS",160,0)
 I $G(HLMTIENA)=""!($G(HLEID)="")!($G(HLEIDS)="") S HLERROR="0^7^"_$G(^HL(771.7,7,0))_"at SENDACK^HLCS entry point" G EXIT2
"RTN","HLCS",161,0)
 S HLCLNODE=$G(^ORD(101,HLEID,770))
"RTN","HLCS",162,0)
 ;Get pointers to Logical Link & receiving application
"RTN","HLCS",163,0)
 S HLOGLINK=$P($G(^ORD(101,HLEIDS,770)),U,7)
"RTN","HLCS",164,0)
 ;Application needed to dynamically address the ACK (tcp/ip)
"RTN","HLCS",165,0)
 ;(set HLL("LINKS") array before calling GENACK)
"RTN","HLCS",166,0)
 I $D(HLL("LINKS")) D  Q:'HLOGLINK
"RTN","HLCS",167,0)
 .S HLOGLINK=$P(HLL("LINKS",1),"^",2) Q:HLOGLINK=""
"RTN","HLCS",168,0)
 .K HLL("LINKS")
"RTN","HLCS",169,0)
 .I +HLOGLINK'=HLOGLINK S HLOGLINK=$O(^HLCS(870,"B",HLOGLINK,0))
"RTN","HLCS",170,0)
 S HLCLIENT=$P(HLCLNODE,U,1)
"RTN","HLCS",171,0)
 Q:('HLCLIENT)
"RTN","HLCS",172,0)
 ;Determine if receiving application is internal or external
"RTN","HLCS",173,0)
 ;  Logical link has a value for external applications
"RTN","HLCS",174,0)
 ;  Logical link is NULL for internal applications
"RTN","HLCS",175,0)
 I (HLOGLINK) D COTSACK Q
"RTN","HLCS",176,0)
 ;Create 'incoming' message based on 'outgoing' message (internal)
"RTN","HLCS",177,0)
 D DHCP(HLMTIENA,HLEID,HLCLIENT)
"RTN","HLCS",178,0)
 ;Process the 'incoming' message
"RTN","HLCS",179,0)
 I (HLMSGPTR) D
"RTN","HLCS",180,0)
 .S HLERROR=""
"RTN","HLCS",181,0)
 .D PROCESS^HLTP0(HLMSGPTR,"DHCP","",.HLERROR)
"RTN","HLCS",182,0)
 ;Update Status of 'incoming' message to SUCCESSFULLY COMPLETED
"RTN","HLCS",183,0)
 ; or ERROR DURING TRANSMISSION
"RTN","HLCS",184,0)
 D STATUS^HLTF0(HLMSGPTR,$S(HLERROR:4,1:3),$S(HLERROR:+HLERROR,1:""),$S(HLERROR:$P(HLERROR,"^",2),1:""))
"RTN","HLCS",185,0)
EXIT2 ;
"RTN","HLCS",186,0)
 S HLRESULT=$G(HLERROR)
"RTN","HLCS",187,0)
 Q
"RTN","HLCS",188,0)
COTSACK ;Internal to external communication of acknowledgements/responses
"RTN","HLCS",189,0)
 ;Create child entry in Message Text file
"RTN","HLCS",190,0)
 D SEND^HLMA2(HLEID,HLMTIENA,HLCLIENT,"D",.HLMTIENS,HLOGLINK)
"RTN","HLCS",191,0)
 ;'Pass' message to background filer by setting status of child
"RTN","HLCS",192,0)
 ;  to PENDING TRANSMISSION
"RTN","HLCS",193,0)
 D STATUS^HLTF0(HLMTIENS,1)
"RTN","HLCS",194,0)
 Q
"RTN","HLCSTCP1")
0^5^B37159862^B31809732
"RTN","HLCSTCP1",1,0)
HLCSTCP1 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;11/02/2006
"RTN","HLCSTCP1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,64,71,133,132**;JUL 17,1995;Build 6
"RTN","HLCSTCP1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP1",4,0)
 ;Receiver
"RTN","HLCSTCP1",5,0)
 ;connection is initiated by sender and listener accepts connection
"RTN","HLCSTCP1",6,0)
 ;and calls this routine
"RTN","HLCSTCP1",7,0)
 ;
"RTN","HLCSTCP1",8,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP1"
"RTN","HLCSTCP1",9,0)
 N HLMIEN,HLASTMSG
"RTN","HLCSTCP1",10,0)
 D MON^HLCSTCP("Open")
"RTN","HLCSTCP1",11,0)
 K ^TMP("HLCSTCP",$J,0)
"RTN","HLCSTCP1",12,0)
 S HLMIEN=0,HLASTMSG=""
"RTN","HLCSTCP1",13,0)
 F  D  Q:$$STOP^HLCSTCP  I 'HLMIEN D MON^HLCSTCP("Idle") H 3
"RTN","HLCSTCP1",14,0)
 . S HLMIEN=$$READ
"RTN","HLCSTCP1",15,0)
 . Q:'HLMIEN
"RTN","HLCSTCP1",16,0)
 . D PROCESS
"RTN","HLCSTCP1",17,0)
 Q
"RTN","HLCSTCP1",18,0)
 ;
"RTN","HLCSTCP1",19,0)
PROCESS ;check message and reply
"RTN","HLCSTCP1",20,0)
 ;HLDP=LL in 870, update monitor, received msg.
"RTN","HLCSTCP1",21,0)
 N HLTCP,HLTCPI,HLTCPO
"RTN","HLCSTCP1",22,0)
 S HLTCP="",HLTCPO=HLDP,HLTCPI=+HLMIEN
"RTN","HLCSTCP1",23,0)
 ;update monitor, msg. received
"RTN","HLCSTCP1",24,0)
 D LLCNT^HLCSTCP(HLDP,1)
"RTN","HLCSTCP1",25,0)
 D NEW^HLTP3(HLMIEN)
"RTN","HLCSTCP1",26,0)
 ;update monitor, msg. processed
"RTN","HLCSTCP1",27,0)
 D LLCNT^HLCSTCP(HLDP,2)
"RTN","HLCSTCP1",28,0)
 Q
"RTN","HLCSTCP1",29,0)
 ;
"RTN","HLCSTCP1",30,0)
READ() ;read 1 message, returns ien in 773^ien in 772 for message
"RTN","HLCSTCP1",31,0)
 D MON^HLCSTCP("Reading")
"RTN","HLCSTCP1",32,0)
 N HLDB,HLDT,HLDEND,HLACKWT,HLDSTRT,HLHDR,HLIND1,HLINE,HLMSG,HLRDOUT,HLRS,HLX,X
"RTN","HLCSTCP1",33,0)
 ;HLDSTRT=start char., HLDEND=end char., HLRS=record seperator
"RTN","HLCSTCP1",34,0)
 S HLDSTRT=$C(11),HLDEND=$C(28),HLRS=$C(13)
"RTN","HLCSTCP1",35,0)
 ;HLRDOUT=exit read loop, HLINE=line count, HLIND1=ien 773^ien 772
"RTN","HLCSTCP1",36,0)
 ;HLHDR=have a header, ^TMP(...)=excess from last read, HLACKWT=wait for ack
"RTN","HLCSTCP1",37,0)
 S (HLRDOUT,HLINE,HLIND1,HLHDR)=0,HLX=$G(^TMP("HLCSTCP",$J,0)),HLACKWT=HLDBACK
"RTN","HLCSTCP1",38,0)
 K ^TMP("HLCSTCP",$J,0)
"RTN","HLCSTCP1",39,0)
 F  D RDBLK Q:HLRDOUT
"RTN","HLCSTCP1",40,0)
 ;
"RTN","HLCSTCP1",41,0)
 ;**132** moved from RDBLK
"RTN","HLCSTCP1",42,0)
 ;switch to null device if opened to prevent 'leakage'
"RTN","HLCSTCP1",43,0)
 I $G(IO(0))'="",$G(IO(0))'=IO U IO(0)
"RTN","HLCSTCP1",44,0)
 ;** 132 end **
"RTN","HLCSTCP1",45,0)
 ;
"RTN","HLCSTCP1",46,0)
 ;save any excess for next time
"RTN","HLCSTCP1",47,0)
 S:$L(HLX) ^TMP("HLCSTCP",$J,0)=HLX
"RTN","HLCSTCP1",48,0)
 I +HLIND1,'$P(HLIND1,U,3) D DELMSG(HLIND1) S HLIND1=0
"RTN","HLCSTCP1",49,0)
 Q HLIND1
"RTN","HLCSTCP1",50,0)
 ;
"RTN","HLCSTCP1",51,0)
RDBLK S HLDB=HLDBSIZE-$L(HLX)
"RTN","HLCSTCP1",52,0)
 ;
"RTN","HLCSTCP1",53,0)
 ;**132 **
"RTN","HLCSTCP1",54,0)
 ;U IO R X#HLDB:HLDREAD
"RTN","HLCSTCP1",55,0)
 N MAXWAIT
"RTN","HLCSTCP1",56,0)
 S MAXWAIT=$S((HLACKWT>HLDREAD):HLACKWT,1:HLDREAD)
"RTN","HLCSTCP1",57,0)
 ;if the header already came across, than give lots of time to complete
"RTN","HLCSTCP1",58,0)
 U IO R X#HLDB:MAXWAIT
"RTN","HLCSTCP1",59,0)
 I '$T,X="",HLX="" D:'HLHDR CLEAN Q
"RTN","HLCSTCP1",60,0)
 ;I '$T,X="",HLX="" S HLACKWT=HLACKWT-HLDREAD D:HLACKWT<0&'HLHDR CLEAN Q
"RTN","HLCSTCP1",61,0)
 ;** 132 end **
"RTN","HLCSTCP1",62,0)
 ;
"RTN","HLCSTCP1",63,0)
 ;**132 -  move to READ **
"RTN","HLCSTCP1",64,0)
 ;switch to null device if opened to prevent 'leakage'
"RTN","HLCSTCP1",65,0)
 ;I $G(IO(0))'="",$G(IO(0))'=IO U IO(0)
"RTN","HLCSTCP1",66,0)
 ;** 132 end **
"RTN","HLCSTCP1",67,0)
 ;
"RTN","HLCSTCP1",68,0)
 ;data stream: <sb>dddd<cr><eb><cr>
"RTN","HLCSTCP1",69,0)
 ;add incoming line to what wasn't processed in last read
"RTN","HLCSTCP1",70,0)
 S HLX=$G(HLX)_X
"RTN","HLCSTCP1",71,0)
 ;
"RTN","HLCSTCP1",72,0)
 ;** 132 **
"RTN","HLCSTCP1",73,0)
 ;if no segment end, HLX not full, go back for more 
"RTN","HLCSTCP1",74,0)
 I $L(HLX)<HLDBSIZE,HLX'[HLRS,HLX'[HLDEND Q
"RTN","HLCSTCP1",75,0)
 ;** 132 end **
"RTN","HLCSTCP1",76,0)
 ;
"RTN","HLCSTCP1",77,0)
 ; look for segment= <CR>
"RTN","HLCSTCP1",78,0)
 F  Q:HLX'[HLRS  D  Q:HLRDOUT
"RTN","HLCSTCP1",79,0)
 . ; Get the first piece, save the rest of the line
"RTN","HLCSTCP1",80,0)
 . S HLINE=HLINE+1,HLMSG(HLINE,0)=$P(HLX,HLRS),HLX=$P(HLX,HLRS,2,999)
"RTN","HLCSTCP1",81,0)
 . ; check for start block, Quit if no ien
"RTN","HLCSTCP1",82,0)
 . I HLMSG(HLINE,0)[HLDSTRT!HLHDR D  Q
"RTN","HLCSTCP1",83,0)
 .. D:HLMSG(HLINE,0)[HLDSTRT
"RTN","HLCSTCP1",84,0)
 ... S X=$L(HLMSG(HLINE,0),HLDSTRT)
"RTN","HLCSTCP1",85,0)
 ... S:X>2 HLMSG(HLINE,0)=HLDSTRT_$P(HLMSG(HLINE,0),HLDSTRT,X)
"RTN","HLCSTCP1",86,0)
 ... S HLMSG(HLINE,0)=$P(HLMSG(HLINE,0),HLDSTRT,2)
"RTN","HLCSTCP1",87,0)
 ... D RESET:(HLINE>1)
"RTN","HLCSTCP1",88,0)
 .. ;ping message
"RTN","HLCSTCP1",89,0)
 .. I $E(HLMSG(1,0),1,9)="MSH^PING^" D PING Q
"RTN","HLCSTCP1",90,0)
 .. ; get next ien to store
"RTN","HLCSTCP1",91,0)
 .. D MIEN
"RTN","HLCSTCP1",92,0)
 .. K HLMSG
"RTN","HLCSTCP1",93,0)
 .. S (HLINE,HLHDR)=0
"RTN","HLCSTCP1",94,0)
 . ; check for end block; HLMSG(HLINE) = <eb><cr>
"RTN","HLCSTCP1",95,0)
 . I HLMSG(HLINE,0)[HLDEND D
"RTN","HLCSTCP1",96,0)
 .. ;no msg. ien
"RTN","HLCSTCP1",97,0)
 .. Q:'HLIND1
"RTN","HLCSTCP1",98,0)
 .. ; Kill just the last line
"RTN","HLCSTCP1",99,0)
 .. K HLMSG(HLINE,0) S HLINE=HLINE-1
"RTN","HLCSTCP1",100,0)
 .. ; move into 772
"RTN","HLCSTCP1",101,0)
 .. D SAVE(.HLMSG,"^HL(772,"_+$P(HLIND1,U,2)_",""IN"")")
"RTN","HLCSTCP1",102,0)
 .. ;mark that end block has been received
"RTN","HLCSTCP1",103,0)
 .. ;HLIND1=ien in 773^ien in 772^1 if end block was received
"RTN","HLCSTCP1",104,0)
 .. S $P(HLIND1,U,3)=1
"RTN","HLCSTCP1",105,0)
 .. ;reset variables for next message
"RTN","HLCSTCP1",106,0)
 .. D CLEAN
"RTN","HLCSTCP1",107,0)
 . ;add blank line for carriage return
"RTN","HLCSTCP1",108,0)
 . I HLINE'=0,HLMSG(HLINE,0)]"" S HLINE=HLINE+1,HLMSG(HLINE,0)=""
"RTN","HLCSTCP1",109,0)
 Q:HLRDOUT
"RTN","HLCSTCP1",110,0)
 ;If the line is long and no <CR> move it into the array. 
"RTN","HLCSTCP1",111,0)
 I ($L(HLX)=HLDBSIZE),(HLX'[HLRS),(HLX'[HLDEND),(HLX'[HLDSTRT) D  Q
"RTN","HLCSTCP1",112,0)
 . S HLINE=HLINE+1,HLMSG(HLINE,0)=HLX,HLX=""
"RTN","HLCSTCP1",113,0)
 ;have start block but no record seperator
"RTN","HLCSTCP1",114,0)
 I HLX[HLDSTRT D  Q
"RTN","HLCSTCP1",115,0)
 . ;check for more than 1 start block
"RTN","HLCSTCP1",116,0)
 . S X=$L(HLX,HLDSTRT) S:X>2 HLX=HLDSTRT_$P(HLX,HLDSTRT,X)
"RTN","HLCSTCP1",117,0)
 . S:$L($P(HLX,HLDSTRT,2))>8 HLINE=HLINE+1,HLMSG(HLINE,0)=$P(HLX,HLDSTRT,2),HLX="",HLHDR=1
"RTN","HLCSTCP1",118,0)
 . D RESET:(HLHDR&(HLINE>1))
"RTN","HLCSTCP1",119,0)
 ;if no ien, then we don't have start block, reset
"RTN","HLCSTCP1",120,0)
 I 'HLIND1 D CLEAN Q
"RTN","HLCSTCP1",121,0)
 ; big message-merge from local to global every 100 lines
"RTN","HLCSTCP1",122,0)
 I (HLINE-$O(HLMSG(0)))>100 D
"RTN","HLCSTCP1",123,0)
 . M ^HL(772,+$P(HLIND1,U,2),"IN")=HLMSG
"RTN","HLCSTCP1",124,0)
 . ; reset working array
"RTN","HLCSTCP1",125,0)
 . K HLMSG
"RTN","HLCSTCP1",126,0)
 Q
"RTN","HLCSTCP1",127,0)
 ;
"RTN","HLCSTCP1",128,0)
SAVE(SRC,DEST) ;save into global & set top node
"RTN","HLCSTCP1",129,0)
 ;SRC=source array (passed by ref.), DEST=destination global
"RTN","HLCSTCP1",130,0)
 M @DEST=SRC
"RTN","HLCSTCP1",131,0)
 S @DEST@(0)="^^"_HLINE_"^"_HLINE_"^"_DT_"^"
"RTN","HLCSTCP1",132,0)
 Q
"RTN","HLCSTCP1",133,0)
 ;
"RTN","HLCSTCP1",134,0)
DELMSG(HLMAMT) ;delete message from Message Administration/Message Text files.
"RTN","HLCSTCP1",135,0)
 N DIK,DA
"RTN","HLCSTCP1",136,0)
 S DA=+HLMAMT,DIK="^HLMA("
"RTN","HLCSTCP1",137,0)
 D ^DIK
"RTN","HLCSTCP1",138,0)
 S DA=$P(HLMAMT,U,2),DIK="^HL(772,"
"RTN","HLCSTCP1",139,0)
 D ^DIK
"RTN","HLCSTCP1",140,0)
 Q
"RTN","HLCSTCP1",141,0)
MIEN ; sets HLIND1=ien in 773^ien in 772 for message
"RTN","HLCSTCP1",142,0)
 N HLMID,X
"RTN","HLCSTCP1",143,0)
 I HLIND1 D
"RTN","HLCSTCP1",144,0)
 . S:'$G(^HLMA(+HLIND1,0)) HLIND1=0
"RTN","HLCSTCP1",145,0)
 . S:'$G(^HL(772,+$P(HLIND1,U,2),0)) HLIND1=0
"RTN","HLCSTCP1",146,0)
 ;msg. id is 10th of MSH & 11th for BSH or FSH
"RTN","HLCSTCP1",147,0)
 S X=10+($E(HLMSG(1,0),1,3)'="MSH"),HLMID=$$PMSH(.HLMSG,X)
"RTN","HLCSTCP1",148,0)
 ;if HLIND1 is set, kill old message, use HLIND1 for new
"RTN","HLCSTCP1",149,0)
 ;message, it means we never got end block for 1st msg.
"RTN","HLCSTCP1",150,0)
 I HLIND1 D  Q
"RTN","HLCSTCP1",151,0)
 . ;get pointer to 772, kill header
"RTN","HLCSTCP1",152,0)
 . K ^HLMA(+HLIND1,"MSH")
"RTN","HLCSTCP1",153,0)
 . I $D(^HL(772,+$P(HLIND1,U,2),"IN")) K ^("IN")
"RTN","HLCSTCP1",154,0)
 . S X=$$MAID^HLTF(+HLIND1,HLMID)
"RTN","HLCSTCP1",155,0)
 . D SAVE(.HLMSG,"^HLMA("_+HLIND1_",""MSH"")")
"RTN","HLCSTCP1",156,0)
 . S:$P(HLIND1,U,3) $P(HLIND1,U,3)=""
"RTN","HLCSTCP1",157,0)
 D TCP^HLTF(.HLMID,.X,.HLDT)
"RTN","HLCSTCP1",158,0)
 I 'X D  Q
"RTN","HLCSTCP1",159,0)
 . ;error - record and reset array
"RTN","HLCSTCP1",160,0)
 . ;killing HLLSTN will allow MON^HLCSTCP to work with multi-server
"RTN","HLCSTCP1",161,0)
 . D CLEAN K HLLSTN
"RTN","HLCSTCP1",162,0)
 . ;error 100=LLP Could not Enqueue the Message, reset array
"RTN","HLCSTCP1",163,0)
 . D MONITOR^HLCSDR2(100,19,HLDP),MON^HLCSTCP("ERROR") H 30
"RTN","HLCSTCP1",164,0)
 ;HLIND1=ien in 773^ien in 772
"RTN","HLCSTCP1",165,0)
 S HLIND1=X_U_+$G(^HLMA(X,0))
"RTN","HLCSTCP1",166,0)
 ;save MSH into 773
"RTN","HLCSTCP1",167,0)
 D SAVE(.HLMSG,"^HLMA("_+HLIND1_",""MSH"")")
"RTN","HLCSTCP1",168,0)
 Q
"RTN","HLCSTCP1",169,0)
 ;
"RTN","HLCSTCP1",170,0)
PMSH(MSH,P) ;get piece P from MSH array (passed by ref.)
"RTN","HLCSTCP1",171,0)
 N FS,I,L,L1,L2,X,Y
"RTN","HLCSTCP1",172,0)
 S FS=$E(MSH(1,0),4),(L2,Y)=0,X=""
"RTN","HLCSTCP1",173,0)
 F I=1:1 S L1=$L($G(MSH(I,0)),FS),L=L1+Y-1 D  Q:$L(X)!'$D(MSH(I,0))
"RTN","HLCSTCP1",174,0)
 . S:L1=1 L=L+1
"RTN","HLCSTCP1",175,0)
 . S:P'>L X=$P($G(MSH(I-1,0)),FS,P-L2)_$P($G(MSH(I,0)),FS,(P-Y))
"RTN","HLCSTCP1",176,0)
 . S L2=Y,Y=L
"RTN","HLCSTCP1",177,0)
 Q X
"RTN","HLCSTCP1",178,0)
 ;
"RTN","HLCSTCP1",179,0)
PING ;process PING message
"RTN","HLCSTCP1",180,0)
 S X=HLMSG(1,0)
"RTN","HLCSTCP1",181,0)
 I X[HLDEND U IO W X,! I $G(IO(0))'="",$G(IO(0))'=IO U IO(0) ;switch to null device if opened to prevent 'leakage'
"RTN","HLCSTCP1",182,0)
 ;
"RTN","HLCSTCP1",183,0)
CLEAN ;reset var. for next message
"RTN","HLCSTCP1",184,0)
 K HLMSG
"RTN","HLCSTCP1",185,0)
 S HLINE=0,HLRDOUT=1
"RTN","HLCSTCP1",186,0)
 Q
"RTN","HLCSTCP1",187,0)
 ;
"RTN","HLCSTCP1",188,0)
ERROR ; Error trap for disconnect error and return back to the read loop.
"RTN","HLCSTCP1",189,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLCSTCP1",190,0)
 I $$EC^%ZOSV["READ"!($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D UNWIND^%ZTER Q
"RTN","HLCSTCP1",191,0)
 I $$EC^%ZOSV["WRITE" D CC("Wr-err") D UNWIND^%ZTER Q
"RTN","HLCSTCP1",192,0)
 S HLCSOUT=1 D ^%ZTER,CC("Error")
"RTN","HLCSTCP1",193,0)
 D UNWIND^%ZTER
"RTN","HLCSTCP1",194,0)
 Q
"RTN","HLCSTCP1",195,0)
 ;
"RTN","HLCSTCP1",196,0)
CC(X) ;cleanup and close
"RTN","HLCSTCP1",197,0)
 D MON^HLCSTCP(X)
"RTN","HLCSTCP1",198,0)
 H 2
"RTN","HLCSTCP1",199,0)
 Q
"RTN","HLCSTCP1",200,0)
RESET ;reset info as a result of no end block
"RTN","HLCSTCP1",201,0)
 N %
"RTN","HLCSTCP1",202,0)
 S HLMSG(1,0)=HLMSG(HLINE,0)
"RTN","HLCSTCP1",203,0)
 F %=2:1:HLINE K HLMSG(%,0)
"RTN","HLCSTCP1",204,0)
 S HLINE=1
"RTN","HLCSTCP1",205,0)
 Q
"RTN","HLMA")
0^9^B41973628^B41676692
"RTN","HLMA",1,0)
HLMA ;AISC/SAW-Message Administration Module ;10/25/2006
"RTN","HLMA",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,58,63,66,82,91,109,115,133,132**;Oct 13, 1995;Build 6
"RTN","HLMA",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLMA",4,0)
GENERATE(HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLMTIEN,HLP) ;
"RTN","HLMA",5,0)
 ;Entry point to generate a deferred message
"RTN","HLMA",6,0)
 ;
"RTN","HLMA",7,0)
 ;This is a subroutine call with parameter passing.  It returns a
"RTN","HLMA",8,0)
 ;value in the variable HLRESLT with 1 to 3 pieces separated by uparrows
"RTN","HLMA",9,0)
 ;as follows:  1st message ID^error code^error description
"RTN","HLMA",10,0)
 ;If no error occurs, only the first piece is returned equal to a unique
"RTN","HLMA",11,0)
 ;ID for the 1st message.  If message was sent to more than 1 subscriber
"RTN","HLMA",12,0)
 ;than the other message IDs will be in the array HLRESLT(n)=ID
"RTN","HLMA",13,0)
 ;Otherwise, three pieces are returned with the
"RTN","HLMA",14,0)
 ;first piece equal to the message ID, if one was assigned, otherwise 0
"RTN","HLMA",15,0)
 ;
"RTN","HLMA",16,0)
 ;Required Input Parameters
"RTN","HLMA",17,0)
 ;     HLEID = Name or IEN of event driver protocol in the Protocol file
"RTN","HLMA",18,0)
 ;  HLARYTYP = Array type.  One of the following codes:
"RTN","HLMA",19,0)
 ;               LM = local array containing a single message
"RTN","HLMA",20,0)
 ;               LB = local array containig a batch of messages
"RTN","HLMA",21,0)
 ;               GM = global array containing a single message
"RTN","HLMA",22,0)
 ;               GB = global array containing a batch of messages
"RTN","HLMA",23,0)
 ;  HLFORMAT = Format of array, 1 for pre-formatted in HL7 format,
"RTN","HLMA",24,0)
 ;               otherwise 0
"RTN","HLMA",25,0)
 ;NOTE:  The parameter HLRESLT must be passed by reference
"RTN","HLMA",26,0)
 ;   HLRESLT = The variable that will be returned to the calling
"RTN","HLMA",27,0)
 ;               application as descibed above
"RTN","HLMA",28,0)
 ;Optional Parameters
"RTN","HLMA",29,0)
 ;   HLMTIEN = IEN of entry in Message Text file where the message
"RTN","HLMA",30,0)
 ;               being generated is to be stored.  This parameter is
"RTN","HLMA",31,0)
 ;               only passed for a batch type message
"RTN","HLMA",32,0)
 ;NOTE:  The parameter HLP used for the following parameters must be
"RTN","HLMA",33,0)
 ;       passed by reference
"RTN","HLMA",34,0)
 ;  HLP("SECURITY") = A 1 to 40 character string
"RTN","HLMA",35,0)
 ;   HLP("CONTPTR") = Continuation pointer, a 1 to 180 character string
"RTN","HLMA",36,0)
 ; HLP("NAMESPACE") = Passed in by application namespace - HL*1.6*91
"RTN","HLMA",37,0)
 ; HLP("EXLCLUDE SUBSCRIBER",<n=1,2,3...>)=<subsciber protocol ien> - A list of protocols to dynamically drop from the event protocol's subscriber multiple.
"RTN","HLMA",38,0)
 ;
"RTN","HLMA",39,0)
 ;can't have link open when generating new message
"RTN","HLMA",40,0)
 N HLTCP,HLTCPO,HLPRIO,HLMIDAR
"RTN","HLMA",41,0)
 S HLPRIO="D"
"RTN","HLMA",42,0)
 S HLRESLT=""
"RTN","HLMA",43,0)
 ;Check for required parameters
"RTN","HLMA",44,0)
CONT I $G(HLEID)']""!($G(HLARYTYP)']"")!($G(HLFORMAT)']"") S HLRESLT="0^7^"_$G(^HL(771.7,7,0))_" at GENERATE^HLMA entry point" G EXIT
"RTN","HLMA",45,0)
 I 'HLEID S HLEID=$O(^ORD(101,"B",HLEID,0)) I 'HLEID S HLRESLT="0^1^"_$G(^HL(771.7,1,0)) G EXIT
"RTN","HLMA",46,0)
 N HLRESLT1,HLRESLTA S (HLRESLTA,HLRESLT1)=""
"RTN","HLMA",47,0)
 I "GL"'[$E(HLARYTYP) S HLRESLT="0^4^"_$G(^HL(771.7,4,0)) G EXIT
"RTN","HLMA",48,0)
 I $L($G(HLP("SECURITY")))>40 S HLRESLT="0^6^"_$G(^HL(771.7,6,0)) G EXIT
"RTN","HLMA",49,0)
 I $L($G(HLP("CONTPTR")))>180 S HLRESLT="0^11^"_$G(^HL(771.7,11,0)) G EXIT
"RTN","HLMA",50,0)
 I $D(HLL("LINKS")) D  G:$G(HLRESLT)]"" EXIT
"RTN","HLMA",51,0)
 . N I,HLPNAM,HLPIEN,HLLNAM,HLLIEN
"RTN","HLMA",52,0)
 . S I=0
"RTN","HLMA",53,0)
 . F  S I=$O(HLL("LINKS",I)) Q:'I  D  Q:$G(HLRESLT)]""
"RTN","HLMA",54,0)
 . . S HLPNAM=$P(HLL("LINKS",I),U)
"RTN","HLMA",55,0)
 . . S HLPIEN=+$O(^ORD(101,"B",HLPNAM,0))
"RTN","HLMA",56,0)
 . . I $P($G(^ORD(101,HLPIEN,0)),U,4)'="S" S HLRESLT="0^15^Invalid Subscriber Protocol in HLL('LINKS'): "_HLL("LINKS",I) Q
"RTN","HLMA",57,0)
 . . S HLLNAM=$P(HLL("LINKS",I),U,2)
"RTN","HLMA",58,0)
 . . S HLLIEN=+$O(^HLCS(870,"B",HLLNAM,0))
"RTN","HLMA",59,0)
 . . I '$D(^HLCS(870,HLLIEN,0)) S HLRESLT="0^15^Invalid HL Node in HLL('LINKS'): "_HLL("LINKS",I) Q
"RTN","HLMA",60,0)
 ;Extract data from Protocol file
"RTN","HLMA",61,0)
 D EVENT^HLUTIL1(HLEID,"15,20,771",.HLN)
"RTN","HLMA",62,0)
 S HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15))
"RTN","HLMA",63,0)
 S HLP("GROUTINE")=$G(HLN(771)) K HLN I HLP("GROUTINE")']"",'HLFORMAT S HLRESLT="0^3^"_$G(^HL(771.7,3,0)) G EXIT
"RTN","HLMA",64,0)
 ;Create message ID and Message Text IEN if Message Text IEN not
"RTN","HLMA",65,0)
 ;previously created ('$G(HLMTIEN))
"RTN","HLMA",66,0)
 I '$G(HLMTIEN) D CREATE^HLTF(.HLMID,.HLMTIEN,.HLDT,.HLDT1)
"RTN","HLMA",67,0)
 ;Get message ID if Message Text IEN already created
"RTN","HLMA",68,0)
 I '$G(HLMID) D
"RTN","HLMA",69,0)
 .S HLDT=$G(^HL(772,HLMTIEN,0)),HLMID=$P(HLDT,"^",6),HLDT=+HLDT
"RTN","HLMA",70,0)
 .S HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLMA",71,0)
 S HLMIDAR=0,HLRESLT=HLMID,HLP("DT")=HLDT,HLP("DTM")=HLDT1
"RTN","HLMA",72,0)
 ;Execute entry action for event driver protocol
"RTN","HLMA",73,0)
 I HLENROU]"" X HLENROU
"RTN","HLMA",74,0)
 ;Invoke transaction processor
"RTN","HLMA",75,0)
 K HLDT,HLDT1,HLENROU
"RTN","HLMA",76,0)
 D GENERATE^HLTP(HLMID,HLMTIEN,HLEID,HLARYTYP,HLFORMAT,.HLRESLT1,.HLP)
"RTN","HLMA",77,0)
 ;HLMIDAR is array of message IDs, only set for broadcast messages
"RTN","HLMA",78,0)
 I HLMIDAR K HLMIDAR("N") M HLRESLT=HLMIDAR
"RTN","HLMA",79,0)
 S HLRESLT=HLRESLT_"^"_HLRESLT1
"RTN","HLMA",80,0)
 ;Execute exit action for event driver protocol
"RTN","HLMA",81,0)
 I HLEXROU]"" X HLEXROU
"RTN","HLMA",82,0)
EXIT ;Update status if Message Text file entry has been created
"RTN","HLMA",83,0)
 K HLTCP
"RTN","HLMA",84,0)
 I $D(HLMTIEN) D STATUS^HLTF0(HLMTIEN,$S($P(HLRESLT,"^",2):4,1:3),$S($P(HLRESLT,"^",2):$P(HLRESLT,"^",2),1:""),$S($P(HLRESLT,"^",2):$P(HLRESLT,"^",3),1:""))
"RTN","HLMA",85,0)
 K HLDT,HLDT1,HLMID,HLRESLT1,HLENROU,HLEXROU
"RTN","HLMA",86,0)
 Q
"RTN","HLMA",87,0)
DIRECT(HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLMTIENO,HLP) ;
"RTN","HLMA",88,0)
 ;Entry point to generate an immediate message, must be TCP Logical Link
"RTN","HLMA",89,0)
 ;Input:
"RTN","HLMA",90,0)
 ;  The same as GENERATE,with one additional subscript to the HLP input array:
"RTN","HLMA",91,0)
 ; 
"RTN","HLMA",92,0)
 ;  HLP("OPEN TIMEOUT") (optional, pass by reference) a number between 
"RTN","HLMA",93,0)
 ;    1 and 120 that specifies how many seconds the DIRECT CONNECT should
"RTN","HLMA",94,0)
 ;    try to open a connection before failing.  It is killed upon completion.
"RTN","HLMA",95,0)
 ; 
"RTN","HLMA",96,0)
 N HLTCP,HLTCPO,HLPRIO,HLSAN,HLN,HLMIDAR,HLMTIENR,ZMID,HLDIRECT
"RTN","HLMA",97,0)
 S HLRESLT=""
"RTN","HLMA",98,0)
 ;HLMTIENO=ien passed in, batch message
"RTN","HLMA",99,0)
 S HLMTIEN=$G(HLMTIENO)
"RTN","HLMA",100,0)
 I $G(HLP("OPEN TIMEOUT")),((HLP("OPEN TIMEOUT")\1)'=+HLP("OPEN TIMEOUT"))!HLP("OPEN TIMEOUT")>120 Q "0^4^INVALID OPEN TIMEOUT PARAMETER"
"RTN","HLMA",101,0)
 I $G(HLP("OPEN TIMEOUT")) D
"RTN","HLMA",102,0)
 .S HLDIRECT("OPEN TIMEOUT")=HLP("OPEN TIMEOUT")
"RTN","HLMA",103,0)
 .K HLP("OPEN TIMEOUT")
"RTN","HLMA",104,0)
 K HL,HLMTIENO
"RTN","HLMA",105,0)
 D INIT^HLFNC2(HLEID,.HL)
"RTN","HLMA",106,0)
 I $G(HL) S HLRESLT="0^"_HL Q
"RTN","HLMA",107,0)
 S HLPRIO="I" D CONT
"RTN","HLMA",108,0)
 ;HLMTIENO=original msg. ien in file 772, HLMTIENR=response ien set in HLMA2
"RTN","HLMA",109,0)
 S HLMTIENO=HLMTIEN,HLMTIEN=$G(HLMTIENR)
"RTN","HLMA",110,0)
 ;Set special HL variables
"RTN","HLMA",111,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLMA",112,0)
 Q
"RTN","HLMA",113,0)
 ;
"RTN","HLMA",114,0)
CLOSE(LOGLINK) ;close connection that was open in tag DIRECT
"RTN","HLMA",115,0)
 Q
"RTN","HLMA",116,0)
PING ;ping another VAMC to test Link
"RTN","HLMA",117,0)
 ;set HLQUIET =1 to skip writes
"RTN","HLMA",118,0)
 ;look for HLTPUT to get turnaround time over network.
"RTN","HLMA",119,0)
 N DA,DIC,HLDP,HLDPNM,HLDPDM,HLCSOUT,HLDBSIZE,HLDREAD,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL,HLPARAM
"RTN","HLMA",120,0)
 N HCS,HCSCMD,HLCS,HCSDAT,HCSER,HCSEXIT,HCSTRACE,HLDT1,HLDRETR,HLRETRA,HLDBACK,HLDWAIT,HLTCPCS,INPUT,OUTPUT,POP,X,Y,HLX1,HLX2
"RTN","HLMA",121,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA",122,0)
 S HLCS="",HCSTRACE="C: ",POP=1,INPUT="INPUT",OUTPUT="OUTPUT"
"RTN","HLMA",123,0)
 S DIC="^HLCS(870,",DIC(0)="QEAMZ"
"RTN","HLMA",124,0)
 D ^DIC Q:Y<0
"RTN","HLMA",125,0)
 S HLDP=+Y,HLDPNM=Y(0,0),HLDPDM=$P($$PARAM^HLCS2,U,2)
"RTN","HLMA",126,0)
 ;I $P($G(^HLCS(870,HLDP,400)),U)="" W !,"Missing IP Address" Q
"RTN","HLMA",127,0)
 D SETUP^HLCSAC G:HLCS PINGQ
"RTN","HLMA",128,0)
 ;PING header=MSH^PING^domain^PING^logical link^datetime
"RTN","HLMA",129,0)
 S INPUT(1)="MSH^PING^"_HLDPDM_"^PING^"_HLDPNM_"^"_$$HTE^XLFDT($H)
"RTN","HLMA",130,0)
 D OPEN^HLCSAC
"RTN","HLMA",131,0)
 I HLCS D DNS G:HLCS PINGQ
"RTN","HLMA",132,0)
 D
"RTN","HLMA",133,0)
 . N $ETRAP,$ESTACK S $ETRAP="D PINGERR^HLMA"
"RTN","HLMA",134,0)
 . ;non-standard HL7 header; start block,header,end block
"RTN","HLMA",135,0)
 . S HLX1=$H
"RTN","HLMA",136,0)
 . W $C(11)_INPUT(1)_$C(28)_$C(13),! ;HL*1.6*115, restored ! char
"RTN","HLMA",137,0)
 . ;read response
"RTN","HLMA",138,0)
 . R X:HLDREAD
"RTN","HLMA",139,0)
 . S HLX2=$H
"RTN","HLMA",140,0)
 . S X=$P(X,$C(28)),HLCS=$S(X=INPUT(1):"PING worked",X="":"No response",1:"Incorrect response")
"RTN","HLMA",141,0)
 . ;Get roundtrip time
"RTN","HLMA",142,0)
 . K HLTPUT I X]"" S HLTPUT=$$HDIFF^XLFDT(HLX2,HLX1,2)
"RTN","HLMA",143,0)
 D CLOSE^%ZISTCP
"RTN","HLMA",144,0)
PINGQ ;write back status and quit
"RTN","HLMA",145,0)
 I 'HLQUIET W !,HLCS,!
"RTN","HLMA",146,0)
 Q
"RTN","HLMA",147,0)
PINGERR ;process errors from PING
"RTN","HLMA",148,0)
 S $ETRAP="G UNWIND^%ZTER",HLCS="-1^Error"
"RTN","HLMA",149,0)
 ;I $ZE["READ" S HLCS="-1^Error during read"
"RTN","HLMA",150,0)
 ;I $ZE["WRITE" S HLCS="-1^Error during write"
"RTN","HLMA",151,0)
 ; HL*1.6*115, SACC compliance
"RTN","HLMA",152,0)
 I $$EC^%ZOSV["READ" S HLCS="-1^Error during read"
"RTN","HLMA",153,0)
 I $$EC^%ZOSV["WRITE" S HLCS="-1^Error during write"
"RTN","HLMA",154,0)
 G UNWIND^%ZTER
"RTN","HLMA",155,0)
DNS ;
"RTN","HLMA",156,0)
 ;openfail-try DNS lookup-Link must contain point to Domain Name
"RTN","HLMA",157,0)
 S POP=$G(POP)
"RTN","HLMA",158,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA",159,0)
 I 'HLQUIET W !,"Calling DNS"
"RTN","HLMA",160,0)
 N HLDOM,HLIP S HLCS=""
"RTN","HLMA",161,0)
 S HLDOM=$P(^HLCS(870,HLDP,0),U,7)
"RTN","HLMA",162,0)
 I 'HLDOM,'HLQUIET W !,"Domain Unknown" Q
"RTN","HLMA",163,0)
 I HLDOM S HLDOM=$P(^DIC(4.2,HLDOM,0),U)
"RTN","HLMA",164,0)
 I HLDOM]"" D  Q:'POP
"RTN","HLMA",165,0)
 . I HLDOM["VA.GOV"&(HLDOM'[".MED.") S HLDOM=$P(HLDOM,".VA.GOV")_".MED.VA.GOV"
"RTN","HLMA",166,0)
 . I HLTCPORT=5000 S HLDOM="HL7."_HLDOM
"RTN","HLMA",167,0)
 . I HLTCPORT=5500 S HLDOM="MPI."_HLDOM
"RTN","HLMA",168,0)
 . I 'HLQUIET W !,"Domain, "_HLDOM
"RTN","HLMA",169,0)
 . I 'HLQUIET W !,"Port: ",HLTCPORT
"RTN","HLMA",170,0)
 . S HLIP=$$ADDRESS^XLFNSLK(HLDOM)
"RTN","HLMA",171,0)
 . I HLIP]"",'HLQUIET W !,"DNS Returned: ",HLIP
"RTN","HLMA",172,0)
 . I HLIP]"" D
"RTN","HLMA",173,0)
 . . ;If more than one IP returned, try each, cache successful open
"RTN","HLMA",174,0)
 . . N HLI,HLJ,HLIP1
"RTN","HLMA",175,0)
 . . F HLJ=1:1:$L(HLIP,",") D  Q:'POP
"RTN","HLMA",176,0)
 . . . S HLIP1=$P(HLIP,",",HLJ)
"RTN","HLMA",177,0)
 . . . F HLI=1:1:HLDRETR W:'HLQUIET !,"Trying ",HLIP1 D CALL^%ZISTCP(HLIP1,HLTCPORT,1) Q:'POP
"RTN","HLMA",178,0)
 . . . I 'POP S $P(^HLCS(870,HLDP,400),U)=HLIP1
"RTN","HLMA",179,0)
 . . . U IO
"RTN","HLMA",180,0)
 I POP S HLCS="-1^DNS Lookup Failed"
"RTN","HLOAPI1")
0^3^B47955238^B47488160
"RTN","HLOAPI1",1,0)
HLOAPI1 ;ALB/CJM-HL7 - Developer API's for sending & receiving messages(continued) ;10/31/2006
"RTN","HLOAPI1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132**;Oct 13, 1995;Build 6
"RTN","HLOAPI1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI1",4,0)
 ;
"RTN","HLOAPI1",5,0)
SENDONE(HLMSTATE,PARMS,WHOTO,ERROR) ;
"RTN","HLOAPI1",6,0)
 ;Sends the message to a single receiving application.
"RTN","HLOAPI1",7,0)
 ;
"RTN","HLOAPI1",8,0)
 ;Input:
"RTN","HLOAPI1",9,0)
 ;HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it
"RTN","HLOAPI1",10,0)
 ;PARMS( *pass by reference*
"RTN","HLOAPI1",11,0)
 ;  "APP ACK RESPONSE")=<tag^routine> to call when the app ack is received (optional)
"RTN","HLOAPI1",12,0)
 ;    (NOTE: For batch messages, HLO best supports returning application
"RTN","HLOAPI1",13,0)
 ;     acknowledgments via a batch response.  However, non-VistA systems
"RTN","HLOAPI1",14,0)
 ;     may return individual messages as application acknowledgments to
"RTN","HLOAPI1",15,0)
 ;     messages within the original batch message, so for applications
"RTN","HLOAPI1",16,0)
 ;     sending batch messages might best code the "APP ACK RESPONSE"
"RTN","HLOAPI1",17,0)
 ;     routine to first check whether the response message is a batch.
"RTN","HLOAPI1",18,0)
 ; 
"RTN","HLOAPI1",19,0)
 ;  "ACCEPT ACK RESPONSE")=<tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI1",20,0)
 ;  "ACCEPT ACK TYPE") = <AL,NE> (optional, defaults to AL)
"RTN","HLOAPI1",21,0)
 ;  "APP ACK TYPE") = <AL,NE> (optional, defaults to NE)
"RTN","HLOAPI1",22,0)
 ;  "FAILURE RESPONSE" - <tag>^<routine> (optional) The sending application routine to execute when the transmission of the message fails, i.e., the message can not be sent or no commit ack is received.
"RTN","HLOAPI1",23,0)
 ;  "QUEUE" - (optional) An application can name its own private queue - just a string up to 20 characters, it should be namespaced.
"RTN","HLOAPI1",24,0)
 ;  "SECURITY")=security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI1",25,0)
 ;  "SENDING APPLICATION")=name of sending app (required, 60 maximum length)
"RTN","HLOAPI1",26,0)
 ;
"RTN","HLOAPI1",27,0)
 ;  WHOTO (required,pass by reference) an array specifying a single recipient. These subscripts are allowed:
"RTN","HLOAPI1",28,0)
 ;
"RTN","HLOAPI1",29,0)
 ;    "RECEIVING APPLICATION" - (string, 60 char max, required)
"RTN","HLOAPI1",30,0)
 ;
"RTN","HLOAPI1",31,0)
 ;  EXACTLY ONE of these parameters must be provided to identify the Receiving Facility:
"RTN","HLOAPI1",32,0)
 ;
"RTN","HLOAPI1",33,0)
 ;   "FACILITY LINK IEN" - ien of the logical link 
"RTN","HLOAPI1",34,0)
 ;   "FACILITY LINK NAME" - name of the logical link 
"RTN","HLOAPI1",35,0)
 ;   "INSTITUTION IEN" - ptr to the INSTITUTION file
"RTN","HLOAPI1",36,0)
 ;   "STATION NUMBER" -  station # with suffix
"RTN","HLOAPI1",37,0)
 ;
"RTN","HLOAPI1",38,0)
 ;  EXACTLY ONE of these MAY be provided - optionally - to identify the interface engine to route the message through:
"RTN","HLOAPI1",39,0)
 ;
"RTN","HLOAPI1",40,0)
 ;   "IE LINK IEN" -  ptr to a logical link for the interface engine 
"RTN","HLOAPI1",41,0)
 ;   "IE LINK NAME" - name of the logical link for the interface engine
"RTN","HLOAPI1",42,0)
 ;
"RTN","HLOAPI1",43,0)
 ;Output:
"RTN","HLOAPI1",44,0)
 ;  Function returns the ien of the message in file 778 on success, 0 on failure
"RTN","HLOAPI1",45,0)
 ;   HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI1",46,0)
 ;   ERROR (pass by reference, optional) - on failure, will contain an error message
"RTN","HLOAPI1",47,0)
 ;   PARMS - left undefined when the function returns
"RTN","HLOAPI1",48,0)
 ;   WHOTO - left undefined when the function returns
"RTN","HLOAPI1",49,0)
 ;
"RTN","HLOAPI1",50,0)
 ;
"RTN","HLOAPI1",51,0)
 N SUCCESS,ERR1,ERR2
"RTN","HLOAPI1",52,0)
 S SUCCESS=0
"RTN","HLOAPI1",53,0)
 D
"RTN","HLOAPI1",54,0)
 .I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) S ERROR="MESSAGE NOT YET CREATED" Q
"RTN","HLOAPI1",55,0)
 .;
"RTN","HLOAPI1",56,0)
 .I $$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERR1)&$$CHKWHO(.HLMSTATE,.WHOTO,.ERR2) D
"RTN","HLOAPI1",57,0)
 ..I $$SEND(.HLMSTATE,.ERROR) S SUCCESS=1
"RTN","HLOAPI1",58,0)
 .E  D DONTSEND(.HLMSTATE,$G(ERR1)_": "_$G(ERR2))
"RTN","HLOAPI1",59,0)
 K PARMS,WHOTO
"RTN","HLOAPI1",60,0)
 Q $S(SUCCESS:HLMSTATE("IEN"),1:0)
"RTN","HLOAPI1",61,0)
 ;
"RTN","HLOAPI1",62,0)
SENDMANY(HLMSTATE,PARMS,WHOTO) ;
"RTN","HLOAPI1",63,0)
 ;Sends the message to a list of receiving applications
"RTN","HLOAPI1",64,0)
 ;
"RTN","HLOAPI1",65,0)
 ;Input: Same as for $$SENDONE, except WHOTO is a list.
"RTN","HLOAPI1",66,0)
 ;  WHOTO (pass by reference)
"RTN","HLOAPI1",67,0)
 ;    Specifies a list of recipients.  Each recipient should be on the
"RTN","HLOAPI1",68,0)
 ;    list as WHOTO(i), where i=1,2,3,4, etc. for as many messages as to
"RTN","HLOAPI1",69,0)
 ;    send.  At each subscript WHOTO(i), the same lower level subscripts
"RTN","HLOAPI1",70,0)
 ;    may be defined as in the $$SENDONE API.  For example:
"RTN","HLOAPI1",71,0)
 ;
"RTN","HLOAPI1",72,0)
 ;      WHOTO(1,"LINK NAME")="VAALB"
"RTN","HLOAPI1",73,0)
 ;      WHOTO(1,"RECEIVING APPLICATION")="MPI"
"RTN","HLOAPI1",74,0)
 ;      WHOTO(2,"STATION NUMBER")=500
"RTN","HLOAPI1",75,0)
 ;      WHOTO(2,"RECEIVING APPLICATION")="MPI"
"RTN","HLOAPI1",76,0)
 ;
"RTN","HLOAPI1",77,0)
 ;
"RTN","HLOAPI1",78,0)
 ;Output:
"RTN","HLOAPI1",79,0)
 ;  Function returns 1 if a message is queued to be sent to each intended recipient, 0 otherwise
"RTN","HLOAPI1",80,0)
 ;  PARMS - left undefined when the function returns
"RTN","HLOAPI1",81,0)
 ;  WHOTO (pass by reference) returns the status of each message to be sent in the format:
"RTN","HLOAPI1",82,0)
 ;    (<i>,"QUEUED")= <1 if queued to be sent, 0 otherwise)
"RTN","HLOAPI1",83,0)
 ;   (<i>,"IEN")=<ien, file 778>
"RTN","HLOAPI1",84,0)
 ;   (<i>,"ERROR")= error message if an error was encountered (status=0), not defined otherwise
"RTN","HLOAPI1",85,0)
 ;
"RTN","HLOAPI1",86,0)
 ;
"RTN","HLOAPI1",87,0)
 N ERROR,RETURN,WHO,STATE,I
"RTN","HLOAPI1",88,0)
 S RETURN=1
"RTN","HLOAPI1",89,0)
 I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) D  K PARMS Q 0
"RTN","HLOAPI1",90,0)
 .S ERROR="MESSAGE NOT YET CREATED"
"RTN","HLOAPI1",91,0)
 .S I=0 F  S I=$O(WHOTO(I)) Q:'I  S WHOTO(I,"QUEUED")=0,WHOTO(I,"IEN")=0,WHOTO(I,"ERROR")=ERROR
"RTN","HLOAPI1",92,0)
 ;
"RTN","HLOAPI1",93,0)
 I '$$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERROR) D  K PARMS Q 0
"RTN","HLOAPI1",94,0)
 .S I=0 F  S I=$O(WHOTO(I)) Q:'I  D
"RTN","HLOAPI1",95,0)
 ..K WHO M WHO=WHOTO(I)
"RTN","HLOAPI1",96,0)
 ..K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",97,0)
 ..S WHOTO(I,"QUEUED")=0
"RTN","HLOAPI1",98,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",99,0)
 ..S WHOTO(I,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",100,0)
 ..S WHOTO(I,"ERROR")=ERROR
"RTN","HLOAPI1",101,0)
 ;
"RTN","HLOAPI1",102,0)
 S I=0 F  S I=$O(WHOTO(I)) Q:'I  D
"RTN","HLOAPI1",103,0)
 .K WHO M WHO=WHOTO(I)
"RTN","HLOAPI1",104,0)
 .K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",105,0)
 .S ERROR=""
"RTN","HLOAPI1",106,0)
 .I $$CHKWHO(.STATE,.WHO,.ERROR) D
"RTN","HLOAPI1",107,0)
 ..I $$SEND(.STATE,.ERROR) D
"RTN","HLOAPI1",108,0)
 ...S WHOTO(I,"QUEUED")=1
"RTN","HLOAPI1",109,0)
 ...S WHOTO(I,"IEN")=STATE("IEN")
"RTN","HLOAPI1",110,0)
 ...S WHOTO(I,"ERROR")=""
"RTN","HLOAPI1",111,0)
 ..E  D
"RTN","HLOAPI1",112,0)
 ...S WHOTO(I,"QUEUED")=0
"RTN","HLOAPI1",113,0)
 ...S WHOTO(I,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",114,0)
 ...S WHOTO(I,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",115,0)
 ...S RETURN=0
"RTN","HLOAPI1",116,0)
 .E  D  ;who not adequately determined
"RTN","HLOAPI1",117,0)
 ..S WHOTO(I,"QUEUED")=0,RETURN=0
"RTN","HLOAPI1",118,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",119,0)
 ..S WHOTO(I,"IEN")=$G(STATE("IEN")),WHOTO(I,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",120,0)
 K PARMS
"RTN","HLOAPI1",121,0)
 Q RETURN
"RTN","HLOAPI1",122,0)
 ;
"RTN","HLOAPI1",123,0)
SENDSUB(HLMSTATE,PARMS,MESSAGES) ;
"RTN","HLOAPI1",124,0)
 ;Sends the message to a list of receiving applications based on the HL7 Subscription Registry
"RTN","HLOAPI1",125,0)
 ;
"RTN","HLOAPI1",126,0)
 ;Input:
"RTN","HLOAPI1",127,0)
 ;  HLMSTATE (pass by reference, required) same as $$SENDMANY
"RTN","HLOAPI1",128,0)
 ;  PARMS (pass by reference, required) same as $$SENDMANY, with one additional subscript:
"RTN","HLOAPI1",129,0)
 ;    "SUBSCRIPTION IEN" - the ien of an entry in the HL7 Subscription Registry, defining the intended recipients of this message
"RTN","HLOAPI1",130,0)
 ;
"RTN","HLOAPI1",131,0)
 ;Output:
"RTN","HLOAPI1",132,0)
 ;  Function returns 1 if a message is queued to be sent to each intended recipient, 0 otherwise
"RTN","HLOAPI1",133,0)
 ;  PARMS - left undefined when the function returns
"RTN","HLOAPI1",134,0)
 ;  MESSAGES (pass by reference) returns the status of each message to be sent in this format, where subien is the ien of the recipient in the RECIPEINTS subfile of the HL7 Subscription Registry
"RTN","HLOAPI1",135,0)
 ;   (<subien>,"QUEUED")= <1 if queued to be sent, 0 otherwise)
"RTN","HLOAPI1",136,0)
 ;   (<subien>,"IEN")=<ien, file 778>
"RTN","HLOAPI1",137,0)
 ;   (<subien>,"ERROR")= error message if an error was encountered (status=0), not defined otherwise
"RTN","HLOAPI1",138,0)
 ;
"RTN","HLOAPI1",139,0)
 ;
"RTN","HLOAPI1",140,0)
 K MESSAGES
"RTN","HLOAPI1",141,0)
 N ERROR,RETURN,STATE,SUBIEN,WHO
"RTN","HLOAPI1",142,0)
 ;
"RTN","HLOAPI1",143,0)
 S RETURN=1
"RTN","HLOAPI1",144,0)
 ;
"RTN","HLOAPI1",145,0)
 ;
"RTN","HLOAPI1",146,0)
 I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) S ERROR="MESSAGE NOT YET CREATED" K PARMS Q 0
"RTN","HLOAPI1",147,0)
 I '$G(PARMS("SUBSCRIPTION IEN")) S ERROR="SUBSCRIPTION REGISTRY IEN NOT PROVIDED" K PARMS Q 0
"RTN","HLOAPI1",148,0)
 ;
"RTN","HLOAPI1",149,0)
 I '$$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERROR) D  K PARMS Q 0
"RTN","HLOAPI1",150,0)
 .S SUBIEN=0 F  S SUBIEN=$$NEXT^HLOASUB(PARMS("SUBSCRIPTION IEN"),.WHO) Q:'SUBIEN  D
"RTN","HLOAPI1",151,0)
 ..N SARY,HARY
"RTN","HLOAPI1",152,0)
 ..S HARY="STATE(""HDR"")"
"RTN","HLOAPI1",153,0)
 ..S SARY="STATE(""STATUS"")"
"RTN","HLOAPI1",154,0)
 ..K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",155,0)
 ..;move parameters into HLMSTATE
"RTN","HLOAPI1",156,0)
 ..S @SARY@("LINK IEN")=WHO("LINK IEN")
"RTN","HLOAPI1",157,0)
 ..S @SARY@("LINK NAME")=WHO("LINK NAME")
"RTN","HLOAPI1",158,0)
 ..S @HARY@("RECEIVING APPLICATION")=WHO("RECEIVING APPLICATION")
"RTN","HLOAPI1",159,0)
 ..M @HARY@("RECEIVING FACILITY")=WHO("RECEIVING FACILITY")
"RTN","HLOAPI1",160,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",161,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=0
"RTN","HLOAPI1",162,0)
 ..S MESSAGES(SUBIEN,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",163,0)
 ..S MESSAGES(SUBIEN,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",164,0)
 ;
"RTN","HLOAPI1",165,0)
 F  S SUBIEN=$$NEXT^HLOASUB(PARMS("SUBSCRIPTION IEN"),.WHO) Q:'SUBIEN  D
"RTN","HLOAPI1",166,0)
 .N SARY,HARY
"RTN","HLOAPI1",167,0)
 .S HARY="STATE(""HDR"")"
"RTN","HLOAPI1",168,0)
 .S SARY="STATE(""STATUS"")"
"RTN","HLOAPI1",169,0)
 .K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",170,0)
 .;move parameters into HLMSTATE
"RTN","HLOAPI1",171,0)
 .S @SARY@("LINK IEN")=WHO("LINK IEN")
"RTN","HLOAPI1",172,0)
 .S @SARY@("LINK NAME")=WHO("LINK NAME")
"RTN","HLOAPI1",173,0)
 .S @HARY@("RECEIVING APPLICATION")=WHO("RECEIVING APPLICATION")
"RTN","HLOAPI1",174,0)
 .M @HARY@("RECEIVING FACILITY")=WHO("RECEIVING FACILITY")
"RTN","HLOAPI1",175,0)
 .S ERROR=""
"RTN","HLOAPI1",176,0)
 .I $$SEND(.STATE,.ERROR) D
"RTN","HLOAPI1",177,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=1
"RTN","HLOAPI1",178,0)
 .E  D
"RTN","HLOAPI1",179,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=0,RETURN=0
"RTN","HLOAPI1",180,0)
 .S MESSAGES(SUBIEN,"IEN")=$G(STATE("IEN")),MESSAGES(SUBIEN,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",181,0)
 K PARMS
"RTN","HLOAPI1",182,0)
 Q RETURN
"RTN","HLOAPI1",183,0)
 ;
"RTN","HLOAPI1",184,0)
SEND(HLMSTATE,ERROR) ;
"RTN","HLOAPI1",185,0)
 ;
"RTN","HLOAPI1",186,0)
 K ERROR
"RTN","HLOAPI1",187,0)
 I HLMSTATE("UNSTORED LINES"),'$$SAVEMSG^HLOF777(.HLMSTATE) S ERROR="$$SAVE^HLOF777 FAILED!" Q 0
"RTN","HLOAPI1",188,0)
 ;
"RTN","HLOAPI1",189,0)
 I '$$SAVEMSG^HLOF778(.HLMSTATE) S ERROR="$$SAVE^HLOF778 FAILED!" Q 0
"RTN","HLOAPI1",190,0)
 D OUTQUE^HLOQUE(HLMSTATE("STATUS","LINK NAME"),$G(HLMSTATE("STATUS","PORT")),HLMSTATE("STATUS","QUEUE"),HLMSTATE("IEN"))
"RTN","HLOAPI1",191,0)
 Q HLMSTATE("IEN")
"RTN","HLOAPI1",192,0)
 ;
"RTN","HLOAPI1",193,0)
DONTSEND(HLMSTATE,ERROR) ;
"RTN","HLOAPI1",194,0)
 ;This procedure does NOT send a message.  Rather, it creates an entry in file 778 with the
"RTN","HLOAPI1",195,0)
 ;of "SE".  
"RTN","HLOAPI1",196,0)
 ;Input:
"RTN","HLOAPI1",197,0)
 ;       HLMSTATE - pass-by-reference
"RTN","HLOAPI1",198,0)
 ;       ERROR (optional, pass-by-value) error text to store with the message
"RTN","HLOAPI1",199,0)
 ;Output: none
"RTN","HLOAPI1",200,0)
 ;
"RTN","HLOAPI1",201,0)
 I HLMSTATE("UNSTORED LINES"),'$$SAVEMSG^HLOF777(.HLMSTATE) ; just continue
"RTN","HLOAPI1",202,0)
 ;
"RTN","HLOAPI1",203,0)
 S HLMSTATE("STATUS")="SE"
"RTN","HLOAPI1",204,0)
 S HLMSTATE("STATUS","PURGE")=$$FMADD^XLFDT(HLMSTATE("DT/TM CREATED"),HLMSTATE("SYSTEM","ERROR PURGE"))
"RTN","HLOAPI1",205,0)
 S HLMSTATE("STATUS","ERROR TEXT")=$G(ERROR)
"RTN","HLOAPI1",206,0)
 I '$$SAVEMSG^HLOF778(.HLMSTATE) ;already reported an error to the app
"RTN","HLOAPI1",207,0)
 Q
"RTN","HLOAPI1",208,0)
 ;
"RTN","HLOAPI1",209,0)
CHKWHO(HLMSTATE,WHOTO,ERROR) ;
"RTN","HLOAPI1",210,0)
 N RETURN,I
"RTN","HLOAPI1",211,0)
 S RETURN=1
"RTN","HLOAPI1",212,0)
 I '$$CHECKWHO^HLOASUB1(.WHOTO,.RETURN,.ERROR) S RETURN=0
"RTN","HLOAPI1",213,0)
 ;
"RTN","HLOAPI1",214,0)
 ;move parameters into HLMSTATE
"RTN","HLOAPI1",215,0)
 S HLMSTATE("STATUS","LINK IEN")=$G(RETURN("LINK IEN"))
"RTN","HLOAPI1",216,0)
 S HLMSTATE("STATUS","LINK NAME")=$G(RETURN("LINK NAME"))
"RTN","HLOAPI1",217,0)
 S HLMSTATE("STATUS","PORT")=$P($G(RETURN("RECEIVING FACILITY",2)),":",2)
"RTN","HLOAPI1",218,0)
 S HLMSTATE("HDR","RECEIVING APPLICATION")=$G(RETURN("RECEIVING APPLICATION"))
"RTN","HLOAPI1",219,0)
 F I=1:1:3 S HLMSTATE("HDR","RECEIVING FACILITY",I)=$G(RETURN("RECEIVING FACILITY",I))
"RTN","HLOAPI1",220,0)
 Q RETURN
"RTN","HLOAPP")
0^1^B9133319^B4658819
"RTN","HLOAPP",1,0)
HLOAPP ;ALB/CJM-HL7 -Application Registry ;10/31/2006
"RTN","HLOAPP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132**;Oct 13, 1995;Build 6
"RTN","HLOAPP",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPP",4,0)
 ;
"RTN","HLOAPP",5,0)
GETIEN(NAME) ;given the application name, it finds the ien.  Returns 0 on failure
"RTN","HLOAPP",6,0)
 Q:'$L($G(NAME)) 0
"RTN","HLOAPP",7,0)
 N IEN,SUB
"RTN","HLOAPP",8,0)
 S SUB=$E(NAME,1,60)
"RTN","HLOAPP",9,0)
 S IEN=0
"RTN","HLOAPP",10,0)
 F  S IEN=$O(^HLD(779.2,"B",SUB,IEN)) Q:'IEN  Q:$P($G(^HLD(779.2,IEN,0)),"^")=NAME
"RTN","HLOAPP",11,0)
 Q +IEN
"RTN","HLOAPP",12,0)
 ;
"RTN","HLOAPP",13,0)
ACTION(HEADER,ACTION,QUEUE) ;Given the parsed header of a message it returns both the action that should be performed in response to the message and the incoming queue that it should be placed on.
"RTN","HLOAPP",14,0)
 ;
"RTN","HLOAPP",15,0)
 ;Input:
"RTN","HLOAPP",16,0)
 ;  HEADER() subscripts are used: "RECEIVING APPLICATION","SEGMENT TYPE", "MESSAGE TYPE", "EVENT", "VERSION"
"RTN","HLOAPP",17,0)
 ;Output:
"RTN","HLOAPP",18,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPP",19,0)
 ;  ACTION (pass by reference) <tag>^<rtn>
"RTN","HLOAPP",20,0)
 ;  QUEUE (pass by reference) returns the named queue if there is one, else "DEFAULT"
"RTN","HLOAPP",21,0)
 ;
"RTN","HLOAPP",22,0)
 N IEN
"RTN","HLOAPP",23,0)
 S (ACTION,QUEUE)=""
"RTN","HLOAPP",24,0)
 S IEN=$$GETIEN(HEADER("RECEIVING APPLICATION"))
"RTN","HLOAPP",25,0)
 Q:'$G(IEN) 0
"RTN","HLOAPP",26,0)
 I $G(HEADER("SEGMENT TYPE"))="BHS" D
"RTN","HLOAPP",27,0)
 .S NODE=$G(^HLD(779.2,IEN,0))
"RTN","HLOAPP",28,0)
 .I $P(NODE,"^",5)]"" D
"RTN","HLOAPP",29,0)
 ..S ACTION=$P(NODE,"^",4,5)
"RTN","HLOAPP",30,0)
 .E  I $P(NODE,"^",7)]"" S ACTION=$P(NODE,"^",6,7)
"RTN","HLOAPP",31,0)
 .I $P(NODE,"^",8)]"" D
"RTN","HLOAPP",32,0)
 ..S QUEUE=$P(NODE,"^",8)
"RTN","HLOAPP",33,0)
 .E  I $P(NODE,"^",3)]"" S QUEUE=$P(NODE,"^",3)
"RTN","HLOAPP",34,0)
 E  I HEADER("SEGMENT TYPE")="MSH" D
"RTN","HLOAPP",35,0)
 .I HEADER("MESSAGE TYPE")'="",HEADER("EVENT")'="" D
"RTN","HLOAPP",36,0)
 ..N SUBIEN,NODE
"RTN","HLOAPP",37,0)
 ..;did the application specify an action for the particular version of this message?
"RTN","HLOAPP",38,0)
 ..I HEADER("VERSION")'="" S SUBIEN=$O(^HLD(779.2,IEN,1,"D",HEADER("MESSAGE TYPE"),HEADER("EVENT"),HEADER("VERSION"),0))
"RTN","HLOAPP",39,0)
 ..;if not, look on the "C" index
"RTN","HLOAPP",40,0)
 ..S:'$G(SUBIEN) SUBIEN=$O(^HLD(779.2,IEN,1,"C",HEADER("MESSAGE TYPE"),HEADER("EVENT"),0))
"RTN","HLOAPP",41,0)
 ..;
"RTN","HLOAPP",42,0)
 ..I SUBIEN D
"RTN","HLOAPP",43,0)
 ...S NODE=$G(^HLD(779.2,IEN,1,SUBIEN,0))
"RTN","HLOAPP",44,0)
 ...I $P(NODE,"^",5)]"" S ACTION=$P(NODE,"^",4,5)
"RTN","HLOAPP",45,0)
 ...I $P(NODE,"^",3)]"" S QUEUE=$P(NODE,"^",3)
"RTN","HLOAPP",46,0)
 ..I ACTION="" S NODE=$G(^HLD(779.2,IEN,0)) I $P(NODE,"^",7)]"" S ACTION=$P(NODE,"^",6,7)
"RTN","HLOAPP",47,0)
 ..I QUEUE="" S NODE=$G(^HLD(779.2,IEN,0)) I $P(NODE,"^",3)]"" S QUEUE=$P(NODE,"^",3)
"RTN","HLOAPP",48,0)
 I QUEUE="" S QUEUE="DEFAULT"
"RTN","HLOAPP",49,0)
 I ACTION="" Q 0
"RTN","HLOAPP",50,0)
 Q 1
"RTN","HLOAPP",51,0)
 ;
"RTN","HLOAPP",52,0)
RTRNLNK(APPNAME) ;
"RTN","HLOAPP",53,0)
 ;given the name of a receiving application, this returns the return
"RTN","HLOAPP",54,0)
 ;link for application acks if one is provided.  Otherwise, return
"RTN","HLOAPP",55,0)
 ;acks are routed based on the information provide in the message hdr
"RTN","HLOAPP",56,0)
 ;
"RTN","HLOAPP",57,0)
 Q:(APPNAME="") ""
"RTN","HLOAPP",58,0)
 N IEN
"RTN","HLOAPP",59,0)
 S IEN=$$GETIEN(APPNAME)
"RTN","HLOAPP",60,0)
 Q:IEN $P($G(^HLD(779.2,IEN,0)),"^",2)
"RTN","HLOAPP",61,0)
 Q ""
"RTN","HLOAPP",62,0)
 ;
"RTN","HLOAPP",63,0)
RTRNPORT(APPNAME) ;
"RTN","HLOAPP",64,0)
 ;Given the name of the sending application, IF the application has its
"RTN","HLOAPP",65,0)
 ;own listener, its port # is returned.  Application acks should be
"RTN","HLOAPP",66,0)
 ;returned using that port
"RTN","HLOAPP",67,0)
 Q:(APPNAME="") ""
"RTN","HLOAPP",68,0)
 N IEN,LINK
"RTN","HLOAPP",69,0)
 S IEN=$$GETIEN(APPNAME)
"RTN","HLOAPP",70,0)
 Q:'IEN ""
"RTN","HLOAPP",71,0)
 S LINK=$P($G(^HLD(779.2,IEN,0)),"^",9)
"RTN","HLOAPP",72,0)
 Q:'LINK ""
"RTN","HLOAPP",73,0)
 Q $$PORT^HLOTLNK(LINK)
"RTN","HLOAPP",74,0)
 ;
"RTN","HLOAPP",75,0)
ACTIVE(APP,MSGTYPE,EVENT,VERSION) ;
"RTN","HLOAPP",76,0)
 ;Returns 1 if the message's INACTIVE flag has NOT been set.
"RTN","HLOAPP",77,0)
 ;
"RTN","HLOAPP",78,0)
 ;Input:
"RTN","HLOAPP",79,0)
 ;  APP (required) the name of the sending application
"RTN","HLOAPP",80,0)
 ;  MSGTYPE (required) 3 character HL7 message type
"RTN","HLOAPP",81,0)
 ;  EVENT (required) 3 character HL7 event
"RTN","HLOAPP",82,0)
 ;  VERSION (optional) HL7 version ID as it appears in the message header
"RTN","HLOAPP",83,0)
 ;Output:
"RTN","HLOAPP",84,0)
 ;  Function returns 1 if the message type specified by the input parameters has not been set to INACTIVE.  It returns 0 otherwise.
"RTN","HLOAPP",85,0)
 ;
"RTN","HLOAPP",86,0)
 N IEN,ACTIVE,SUBIEN
"RTN","HLOAPP",87,0)
 S ACTIVE=1
"RTN","HLOAPP",88,0)
 S IEN=$$GETIEN($G(APP))
"RTN","HLOAPP",89,0)
 Q:'$G(IEN) ACTIVE
"RTN","HLOAPP",90,0)
 Q:$G(MSGTYPE)="" ACTIVE
"RTN","HLOAPP",91,0)
 Q:$G(EVENT)="" ACTIVE
"RTN","HLOAPP",92,0)
 ;did the application specify an action for the particular version of this message?
"RTN","HLOAPP",93,0)
 I $G(VERSION)'="" S SUBIEN=$O(^HLD(779.2,IEN,1,"D",MSGTYPE,EVENT,VERSION,0))
"RTN","HLOAPP",94,0)
 ;if not, look on the "C" index
"RTN","HLOAPP",95,0)
 S:'$G(SUBIEN) SUBIEN=$O(^HLD(779.2,IEN,1,"C",MSGTYPE,EVENT,0))
"RTN","HLOAPP",96,0)
 ;
"RTN","HLOAPP",97,0)
 S:SUBIEN ACTIVE='(+$P($G(^HLD(779.2,IEN,1,SUBIEN,0)),"^",7))
"RTN","HLOAPP",98,0)
 Q ACTIVE
"RTN","HLOCNRT")
0^11^B4616658^B4743338
"RTN","HLOCNRT",1,0)
HLOCNRT ;DAOU/ALA-Generate HL7 Optimized Message ;10/26/2006
"RTN","HLOCNRT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132**;Oct 13, 1995;Build 6
"RTN","HLOCNRT",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCNRT",4,0)
 ;
"RTN","HLOCNRT",5,0)
 ;**Program Description**
"RTN","HLOCNRT",6,0)
 ;  This program takes a current HL7 1.6 message and converts
"RTN","HLOCNRT",7,0)
 ;  it to use the new HL Optimized code if it follows the standard
"RTN","HLOCNRT",8,0)
 ;  1.6 methodology of protocols.
"RTN","HLOCNRT",9,0)
 ;
"RTN","HLOCNRT",10,0)
 ;  **If the VistA HL7 Protocol does not exist, calls to HL Optimized
"RTN","HLOCNRT",11,0)
 ;  will have to be coded separately and this program cannot be used**
"RTN","HLOCNRT",12,0)
 Q
"RTN","HLOCNRT",13,0)
 ;
"RTN","HLOCNRT",14,0)
EN(HLOPRTCL,ARYTYP,HLP,HLL) ;Entry Point
"RTN","HLOCNRT",15,0)
 ;  Input Parameters
"RTN","HLOCNRT",16,0)
 ;   HLOPRTCL = Protocol IEN or Protocol Name
"RTN","HLOCNRT",17,0)
 ;   ARYTYP = The array where HL7 message resides
"RTN","HLOCNRT",18,0)
 ;   HLP = Additional HL7 message parameters (optional, pass by reference)
"RTN","HLOCNRT",19,0)
 ;   HLL  (optional, pass by reference) Additional message recipients being dynamically added
"RTN","HLOCNRT",20,0)
 ;
"RTN","HLOCNRT",21,0)
 ;  Output
"RTN","HLOCNRT",22,0)
 ;    ZTSTOP = Stop processing flag (used by HDR)
"RTN","HLOCNRT",23,0)
 ;    HLORESL = Error parameter
"RTN","HLOCNRT",24,0)
 ;
"RTN","HLOCNRT",25,0)
 NEW HLORESL,HLMSTATE,APPARMS,WHOTO,ERROR,HLOMESG
"RTN","HLOCNRT",26,0)
 S ZTSTOP=0,HLORESL=1
"RTN","HLOCNRT",27,0)
 ;
"RTN","HLOCNRT",28,0)
 ;  Get IEN of protocol if name is passed
"RTN","HLOCNRT",29,0)
 I HLOPRTCL'?.N S HLOPRTCL=+$O(^ORD(101,"B",HLOPRTCL,0))
"RTN","HLOCNRT",30,0)
 I '$D(^ORD(101,HLOPRTCL)) S HLORESL="^99^HL7 1.6 Protocol not found",ZTSTOP=1 Q HLORESL
"RTN","HLOCNRT",31,0)
 ;
"RTN","HLOCNRT",32,0)
 ;  If the VistA HL7 Protocol exists, call the Conversion Utility
"RTN","HLOCNRT",33,0)
 ;  to set up the APPARMS, WHOTO arrays from protocol logical link,
"RTN","HLOCNRT",34,0)
 ;   and the optional HLL and HLP arrays
"RTN","HLOCNRT",35,0)
 D APAR^HLOCVU(HLOPRTCL,.APPARMS,,.WHOTO,.HLP,.HLL)
"RTN","HLOCNRT",36,0)
 ;
"RTN","HLOCNRT",37,0)
 ; If special HLP parameters are defined, convert them
"RTN","HLOCNRT",38,0)
 I $D(HLP) D
"RTN","HLOCNRT",39,0)
 . I $G(HLP("SECURITY"))'="" S APPARMS("SECURITY")=HLP("SECURITY")
"RTN","HLOCNRT",40,0)
 . I $G(HLP("CONTPTR"))'="" S APPARMS("CONTINUATION POINTER")=HLP("CONTPTR")
"RTN","HLOCNRT",41,0)
 . I $G(HLP("QUEUE"))'="" S APPARMS("QUEUE")=HLP("QUEUE")
"RTN","HLOCNRT",42,0)
 ;
"RTN","HLOCNRT",43,0)
 ;  Create HL Optimized message
"RTN","HLOCNRT",44,0)
 I '$$NEWMSG^HLOAPI(.APPARMS,.HLMSTATE,.ERROR) S HLORESL="^99^"_ERROR,ZTSTOP=1 Q HLORESL
"RTN","HLOCNRT",45,0)
 I $E(ARYTYP,1)="G" S HLOMESG="^TMP(""HLS"",$J)"
"RTN","HLOCNRT",46,0)
 I $E(ARYTYP,1)="L" S HLOMESG="HLA(""HLS"")"
"RTN","HLOCNRT",47,0)
 ;
"RTN","HLOCNRT",48,0)
 ;  Move the existing message from array into HL Optimized
"RTN","HLOCNRT",49,0)
 D MOVEMSG^HLOAPI(.HLMSTATE,HLOMESG)
"RTN","HLOCNRT",50,0)
 ; 
"RTN","HLOCNRT",51,0)
 ;  Send message via HL Optimized
"RTN","HLOCNRT",52,0)
 I $D(WHOTO) D  Q HLORESL
"RTN","HLOCNRT",53,0)
 . I '$$SENDMANY^HLOAPI1(.HLMSTATE,.APPARMS,.WHOTO) S HLORESL="^99^Unable to send message",ZTSTOP=1 Q
"RTN","HLOCNRT",54,0)
 . S HLORESL=1
"RTN","HLOCNRT",55,0)
 ;
"RTN","HLOCNRT",56,0)
 E  S HLORESL="^99^Unable to send message",ZTSTOP=1 Q HLORESL
"RTN","HLOCNRT",57,0)
 Q HLORESL
"RTN","HLOCVU")
0^10^B6948622^B5066511
"RTN","HLOCVU",1,0)
HLOCVU ;DAOU/ALA-Conversion Utility ;10/27/2006
"RTN","HLOCVU",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132**;Oct 13, 1995;Build 6
"RTN","HLOCVU",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCVU",4,0)
 ;
"RTN","HLOCVU",5,0)
 Q
"RTN","HLOCVU",6,0)
 ;
"RTN","HLOCVU",7,0)
APAR(HLOEID,APPARMS,WHO,WHOTO,HLP,HLL) ;  Set up APPARMS array from Protocols
"RTN","HLOCVU",8,0)
 ;
"RTN","HLOCVU",9,0)
 ;  Input Parameter
"RTN","HLOCVU",10,0)
 ;   HLOEID = IEN of the event protocol
"RTN","HLOCVU",11,0)
 ;   HLP - "EXCLUDE SUBSCRIBER" subscript used to ignore specific subscribers
"RTN","HLOCVU",12,0)
 ;   HLL - dynamic addressing
"RTN","HLOCVU",13,0)
 ;
"RTN","HLOCVU",14,0)
 ;  Output
"RTN","HLOCVU",15,0)
 ;    APPARMS array
"RTN","HLOCVU",16,0)
 ;    WHO - not used
"RTN","HLOCVU",17,0)
 ;    WHOTO array
"RTN","HLOCVU",18,0)
 ;
"RTN","HLOCVU",19,0)
 NEW HLOTEXT,HLARY,FLDS,HLOSID,CT
"RTN","HLOCVU",20,0)
 S FLDS="770.1;770.3;770.4;770.8;770.9;770.95"
"RTN","HLOCVU",21,0)
 D GETS^DIQ(101,HLOEID,FLDS,"R","HLOTEXT")
"RTN","HLOCVU",22,0)
 ;
"RTN","HLOCVU",23,0)
 S APPARMS("COUNTRY")="USA"
"RTN","HLOCVU",24,0)
 S APPARMS("EVENT")=$G(HLOTEXT(101,HLOEID_",","EVENT TYPE"))
"RTN","HLOCVU",25,0)
 S APPARMS("MESSAGE TYPE")=$G(HLOTEXT(101,HLOEID_",","TRANSACTION MESSAGE TYPE"))
"RTN","HLOCVU",26,0)
 S APPARMS("VERSION")=$G(HLOTEXT(101,HLOEID_",","VERSION ID"))
"RTN","HLOCVU",27,0)
 S APPARMS("SENDING APPLICATION")=$G(HLOTEXT(101,HLOEID_",","SENDING APPLICATION"))
"RTN","HLOCVU",28,0)
 S APPARMS("APP ACK TYPE")=$G(HLOTEXT(101,HLOEID_",","APPLICATION ACK TYPE"))
"RTN","HLOCVU",29,0)
 S APPARMS("ACCEPT ACK TYPE")=$G(HLOTEXT(101,HLOEID_",","ACCEPT ACK CODE"))
"RTN","HLOCVU",30,0)
 I $G(HLFS)'="" S APPARMS("FIELD SEPARATOR")=HLFS
"RTN","HLOCVU",31,0)
 I $G(HLECH)'="" S APPARMS("ENCODING CHARACTERS")=HLECH
"RTN","HLOCVU",32,0)
 ;
"RTN","HLOCVU",33,0)
 K HLOTEXT,FLDS
"RTN","HLOCVU",34,0)
 D ITEM^HLUTIL2(HLOEID,"PTR")
"RTN","HLOCVU",35,0)
 S HLOSID=0,CT=0
"RTN","HLOCVU",36,0)
 S FLDS="770.2;770.4;770.7"
"RTN","HLOCVU",37,0)
 F  S HLOSID=$O(HLARY(HLOSID)) Q:'HLOSID  D
"RTN","HLOCVU",38,0)
 .;
"RTN","HLOCVU",39,0)
 .;**132 excluded subscribers **
"RTN","HLOCVU",40,0)
 .N I,EXCLUDE
"RTN","HLOCVU",41,0)
 .S (EXCLUDE,I)=0
"RTN","HLOCVU",42,0)
 .F  S I=$O(HLP("EXCLUDE SUBSCRIBER",I)) Q:'I  I $G(HLP("EXCLUDE SUBSCRIBER",I))=HLOSID S EXCLUDE=1 Q
"RTN","HLOCVU",43,0)
 .Q:EXCLUDE
"RTN","HLOCVU",44,0)
 .;** 132 end **
"RTN","HLOCVU",45,0)
 .;
"RTN","HLOCVU",46,0)
 . K HLOTEXT
"RTN","HLOCVU",47,0)
 . D GETS^DIQ(101,HLOSID,FLDS,"R","HLOTEXT")
"RTN","HLOCVU",48,0)
 . S CT=CT+1
"RTN","HLOCVU",49,0)
 . S WHOTO(CT,"RECEIVING APPLICATION")=$G(HLOTEXT(101,HLOSID_",","RECEIVING APPLICATION"))
"RTN","HLOCVU",50,0)
 . S WHOTO(CT,"FACILITY LINK NAME")=$G(HLOTEXT(101,HLOSID_",","LOGICAL LINK"))
"RTN","HLOCVU",51,0)
 ;
"RTN","HLOCVU",52,0)
 ;**132 add from HLL() **
"RTN","HLOCVU",53,0)
 N I
"RTN","HLOCVU",54,0)
 S I=0
"RTN","HLOCVU",55,0)
 F  S I=$O(HLL("LINKS",I)) Q:'I  D
"RTN","HLOCVU",56,0)
 .N LINK,PROTOCOL
"RTN","HLOCVU",57,0)
 .S CT=CT+1
"RTN","HLOCVU",58,0)
 .S PROTOCOL=$P(HLL("LINKS",I),"^")
"RTN","HLOCVU",59,0)
 .S LINK=$P(HLL("LINKS",I),"^",2)
"RTN","HLOCVU",60,0)
 .I PROTOCOL=+PROTOCOL S PROTOCOL=$P($G(^ORD(101,PROTOCOL,0)),"^")
"RTN","HLOCVU",61,0)
 .I LINK=+LINK S LINK=$P($G(^HLCS(870,LINK,0)),"^")
"RTN","HLOCVU",62,0)
 .S WHOTO(CT,"RECEIVING APPLICATION")=PROTOCOL
"RTN","HLOCVU",63,0)
 .S WHOTO(CT,"FACILITY LINK NAME")=LINK
"RTN","HLOCVU",64,0)
 ;**132 END **
"RTN","HLOCVU",65,0)
 Q
"RTN","HLOPBLD")
0^7^B11482408^B10420625
"RTN","HLOPBLD",1,0)
HLOPBLD ;ALB/CJM-HL7 - Building segments ;10/24/2006
"RTN","HLOPBLD",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132**;Oct 13, 1995;Build 6
"RTN","HLOPBLD",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPBLD",4,0)
 ;
"RTN","HLOPBLD",5,0)
 ;
"RTN","HLOPBLD",6,0)
BUILDSEG(HLMSTATE,SEG,TOARY,ERROR) ;Builds the segment from the individual values
"RTN","HLOPBLD",7,0)
 ;Input:
"RTN","HLOPBLD",8,0)
 ;  HLMSTATE() - (pass by reference, required) Used to track the progress of the message. Uses these subscripts:
"RTN","HLOPBLD",9,0)
 ;    ("HDR","FIELD SEPARATOR")
"RTN","HLOPBLD",10,0)
 ;    ("HDR","ENCODING CHARACTERS")
"RTN","HLOPBLD",11,0)
 ;  SEG() - (pass by reference, required) Contains the data.  It must be built by calls to SET^HLOAPI prior to calling $$BUILDSEG.
"RTN","HLOPBLD",12,0)
 ;
"RTN","HLOPBLD",13,0)
 ;Note#1:  The '0' field must be a 3 character segment type
"RTN","HLOPBLD",14,0)
 ;Note#2: ***SEG is killed upon successfully adding the segment***
"RTN","HLOPBLD",15,0)
 ;
"RTN","HLOPBLD",16,0)
 ;Output:
"RTN","HLOPBLD",17,0)
 ;  Function - returns 1 on success, 0 on failure
"RTN","HLOPBLD",18,0)
 ;  TOARY (pass by reference) This will return the segment in an array format TOARY(1),TOARY(2),... For segments that are shorter than the MUMPS maximum string length, there will be only TOARY(1)
"RTN","HLOPBLD",19,0)
 ;  ERROR (optional, pass by reference) - returns an error message on failure
"RTN","HLOPBLD",20,0)
 ;
"RTN","HLOPBLD",21,0)
 ;
"RTN","HLOPBLD",22,0)
 K ERROR,TOARY
"RTN","HLOPBLD",23,0)
 N TEMP1,TEMP2,LINE,LAST,SEQ,MAX,COUNT,SEGTYPE
"RTN","HLOPBLD",24,0)
 S COUNT=0
"RTN","HLOPBLD",25,0)
 S MAX=HLMSTATE("SYSTEM","MAXSTRING")-1 ;save some room for the <CR>
"RTN","HLOPBLD",26,0)
 S SEGTYPE=$G(SEG(0,1,1,1))
"RTN","HLOPBLD",27,0)
 S LAST=0,(TEMP1,TEMP2)="",LINE=SEGTYPE_HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOPBLD",28,0)
 F  S SEQ=$O(SEG(LAST)) Q:'SEQ  D
"RTN","HLOPBLD",29,0)
 .S TEMP2="",$P(TEMP2,HLMSTATE("HDR","FIELD SEPARATOR"),$S(LAST=0:SEQ,1:SEQ-LAST+1))=""
"RTN","HLOPBLD",30,0)
 .S TEMP1=TEMP2
"RTN","HLOPBLD",31,0)
 .S LAST=SEQ
"RTN","HLOPBLD",32,0)
 .N REP,LAST
"RTN","HLOPBLD",33,0)
 .S LAST=0
"RTN","HLOPBLD",34,0)
 .F  S REP=$O(SEG(SEQ,LAST)) Q:'REP  D
"RTN","HLOPBLD",35,0)
 ..S TEMP2="",$P(TEMP2,$E(HLMSTATE("HDR","ENCODING CHARACTERS"),2),$S(LAST=0:REP,1:REP-LAST+1))=""
"RTN","HLOPBLD",36,0)
 ..S TEMP1=TEMP1_TEMP2
"RTN","HLOPBLD",37,0)
 ..S LAST=REP
"RTN","HLOPBLD",38,0)
 ..;
"RTN","HLOPBLD",39,0)
 ..N COMP,LAST
"RTN","HLOPBLD",40,0)
 ..S LAST=0
"RTN","HLOPBLD",41,0)
 ..F  S COMP=$O(SEG(SEQ,REP,LAST)) Q:'COMP  D
"RTN","HLOPBLD",42,0)
 ...S TEMP2="",$P(TEMP2,$E(HLMSTATE("HDR","ENCODING CHARACTERS"),1),$S(LAST=0:COMP,1:COMP-LAST+1))=""
"RTN","HLOPBLD",43,0)
 ...S TEMP1=TEMP1_TEMP2
"RTN","HLOPBLD",44,0)
 ...S LAST=COMP
"RTN","HLOPBLD",45,0)
 ...;
"RTN","HLOPBLD",46,0)
 ...N SUBCOMP,LAST
"RTN","HLOPBLD",47,0)
 ...S LAST=0
"RTN","HLOPBLD",48,0)
 ...F  S SUBCOMP=$O(SEG(SEQ,REP,COMP,LAST)) Q:'SUBCOMP  D
"RTN","HLOPBLD",49,0)
 ....N VALUE
"RTN","HLOPBLD",50,0)
 ....S TEMP2="",$P(TEMP2,$E(HLMSTATE("HDR","ENCODING CHARACTERS"),4),$S(LAST=0:SUBCOMP,1:SUBCOMP-LAST+1))=""
"RTN","HLOPBLD",51,0)
 ....S VALUE=$G(SEG(SEQ,REP,COMP,SUBCOMP))
"RTN","HLOPBLD",52,0)
 ....K SEG(SEQ,REP,COMP,SUBCOMP)
"RTN","HLOPBLD",53,0)
 ....S:((SEGTYPE'="MSH")&(SEGTYPE'="BHS"))!(SEQ'=2) VALUE=$$ESCAPE(.HLMSTATE,VALUE)
"RTN","HLOPBLD",54,0)
 ....S TEMP2=TEMP2_VALUE
"RTN","HLOPBLD",55,0)
 ....S TEMP1=TEMP1_TEMP2
"RTN","HLOPBLD",56,0)
 ....I $L(LINE)+$L(TEMP1)<MAX D
"RTN","HLOPBLD",57,0)
 .....S LINE=LINE_TEMP1
"RTN","HLOPBLD",58,0)
 ....E  D
"RTN","HLOPBLD",59,0)
 .....D ADDLINE(.TOARY,LINE_$E(TEMP1,1,MAX-$L(LINE)),.COUNT)
"RTN","HLOPBLD",60,0)
 .....S LINE=$E(TEMP1,MAX-$L(LINE)+1,MAX+100)
"RTN","HLOPBLD",61,0)
 ....S TEMP1=""
"RTN","HLOPBLD",62,0)
 ....S LAST=SUBCOMP
"RTN","HLOPBLD",63,0)
 I $L(LINE) D ADDLINE(.TOARY,LINE,.COUNT)
"RTN","HLOPBLD",64,0)
 K SEG
"RTN","HLOPBLD",65,0)
 Q 1
"RTN","HLOPBLD",66,0)
 ;
"RTN","HLOPBLD",67,0)
ADDLINE(TOARY,LINE,COUNT) ;
"RTN","HLOPBLD",68,0)
 S COUNT=COUNT+1
"RTN","HLOPBLD",69,0)
 S TOARY(COUNT)=LINE
"RTN","HLOPBLD",70,0)
 Q
"RTN","HLOPBLD",71,0)
 ;
"RTN","HLOPBLD",72,0)
ESCAPE(HLMSTATE,VALUE) ;
"RTN","HLOPBLD",73,0)
 ;Replaces the HL7 encoding characters with the corresponding escape sequences and returns the result as the function value
"RTN","HLOPBLD",74,0)
 ;
"RTN","HLOPBLD",75,0)
 N ESC,CHARS,I,NEWVALUE,LEN,CUR
"RTN","HLOPBLD",76,0)
 S CHARS=HLMSTATE("HDR","ENCODING CHARACTERS")
"RTN","HLOPBLD",77,0)
 S ESC=$E(CHARS,3)
"RTN","HLOPBLD",78,0)
 S NEWVALUE="",LEN=$L(VALUE)
"RTN","HLOPBLD",79,0)
 F I=1:1:LEN D
"RTN","HLOPBLD",80,0)
 .S CUR=$E(VALUE,I)
"RTN","HLOPBLD",81,0)
 .S NEWVALUE=NEWVALUE_$S(CUR=HLMSTATE("HDR","FIELD SEPARATOR"):ESC_"F"_ESC,CUR=ESC:ESC_"E"_ESC,CUR=$E(CHARS,1):ESC_"S"_ESC,CUR=$E(CHARS,4):ESC_"T"_ESC,CUR=$E(CHARS,2):ESC_"R"_ESC,1:CUR)
"RTN","HLOPBLD",82,0)
 Q NEWVALUE
"RTN","HLOPBLD",83,0)
 ;
"RTN","HLOPBLD",84,0)
REPLACE(VALUE,CHAR,STRING) ;
"RTN","HLOPBLD",85,0)
 ;Takes the input string=VALUE and replaces each instance of the character
"RTN","HLOPBLD",86,0)
 ;=CHAR with the string=STRING and returns the resultant string
"RTN","HLOPBLD",87,0)
 ;as the function value
"RTN","HLOPBLD",88,0)
 ;
"RTN","HLOPBLD",89,0)
 N I,NEWVALUE,CURCHAR
"RTN","HLOPBLD",90,0)
 S NEWVALUE=""
"RTN","HLOPBLD",91,0)
 F I=1:1:$L(VALUE) D
"RTN","HLOPBLD",92,0)
 .S CURCHAR=$E(VALUE,I)
"RTN","HLOPBLD",93,0)
 .S NEWVALUE=NEWVALUE_$S(CURCHAR=CHAR:STRING,1:CURCHAR)
"RTN","HLOPBLD",94,0)
 Q NEWVALUE
"RTN","HLOPBLD1")
0^4^B22231914^B18903926
"RTN","HLOPBLD1",1,0)
HLOPBLD1 ;ALB/CJM-HL7 - Building segments (CONTINUED) ;10/24/2006
"RTN","HLOPBLD1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132**;Oct 13, 1995;Build 6
"RTN","HLOPBLD1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPBLD1",4,0)
 ;
"RTN","HLOPBLD1",5,0)
BUILDHDR(HLMSTATE,TYPE,HDR) ;Builds the header segment in 2 lines, line 1 is components 1-6
"RTN","HLOPBLD1",6,0)
 ;Input:
"RTN","HLOPBLD1",7,0)
 ;  HLMSTATE("HDR") - (pass by reference, required) These subscripts are used:
"RTN","HLOPBLD1",8,0)
 ;    "FIELD SEPARATOR"
"RTN","HLOPBLD1",9,0)
 ;    "ENCODING CHARACTERS"
"RTN","HLOPBLD1",10,0)
 ;    "SENDING APPLICATION"
"RTN","HLOPBLD1",11,0)
 ;    "RECEIVING APPLICATION"
"RTN","HLOPBLD1",12,0)
 ;    "RECEIVING FACILITY",1  and ,2  and ,3
"RTN","HLOPBLD1",13,0)
 ;    "DT/TM OF MESSAGE"
"RTN","HLOPBLD1",14,0)
 ;    "SECURITY"
"RTN","HLOPBLD1",15,0)
 ;    "ACCEPT ACK TYPE"
"RTN","HLOPBLD1",16,0)
 ;    "APP ACK TYPE"
"RTN","HLOPBLD1",17,0)
 ;    "PROCESSING ID"
"RTN","HLOPBLD1",18,0)
 ;
"RTN","HLOPBLD1",19,0)
 ;     *MSH ONLY*
"RTN","HLOPBLD1",20,0)
 ;    "CONTINUATION POINTER"
"RTN","HLOPBLD1",21,0)
 ;    "COUNTRY"
"RTN","HLOPBLD1",22,0)
 ;    "EVENT"
"RTN","HLOPBLD1",23,0)
 ;    "MESSAGE STRUCTURE"
"RTN","HLOPBLD1",24,0)
 ;    "MESSAGE TYPE"
"RTN","HLOPBLD1",25,0)
 ;    "PROCESSING MODE"
"RTN","HLOPBLD1",26,0)
 ;    "VERSION"
"RTN","HLOPBLD1",27,0)
 ;
"RTN","HLOPBLD1",28,0)
 ;    *BHS ONLY*
"RTN","HLOPBLD1",29,0)
 ;    "REFERENCE BATCH CONTROL ID"
"RTN","HLOPBLD1",30,0)
 ;
"RTN","HLOPBLD1",31,0)
 ;  HLMSTATE("BATCH")
"RTN","HLOPBLD1",32,0)
 ;  HLMSTATE("BATCH","CURRENT MESSAGE") - batch messages only
"RTN","HLOPBLD1",33,0)
 ;  HLMSTATE("IEN") - ien, file 778
"RTN","HLOPBLD1",34,0)
 ;
"RTN","HLOPBLD1",35,0)
 ;  TYPE - must be either "MSH" or "BHS"
"RTN","HLOPBLD1",36,0)
 ;
"RTN","HLOPBLD1",37,0)
 ;Output:
"RTN","HLOPBLD1",38,0)
 ;  HLMSTATE("HDR") - these subscripts will be added, unless building an MSH within a batch:
"RTN","HLOPBLD1",39,0)
 ;     "SENDING FACILITY",1  and ,2   and ,3
"RTN","HLOPBLD1",40,0)
 ;     "PROCESSING ID"
"RTN","HLOPBLD1",41,0)
 ;     "MESSAGE CONTROL ID"   (MSH ONLY)
"RTN","HLOPBLD1",42,0)
 ;     "BATCH CONTROL ID"     (BHS ONLY)
"RTN","HLOPBLD1",43,0)
 ;     "DT/TM OF MESSAGE"
"RTN","HLOPBLD1",44,0)
 ;  HDR (pass by reference) This will return the segment in an array form at HDR(1),HDR(2) (two lines).
"RTN","HLOPBLD1",45,0)
 ;
"RTN","HLOPBLD1",46,0)
 K HDR
"RTN","HLOPBLD1",47,0)
 N SEG,BATCH,LEN,FS,CS
"RTN","HLOPBLD1",48,0)
 ;
"RTN","HLOPBLD1",49,0)
 ;shortcuts
"RTN","HLOPBLD1",50,0)
 S HDR="HLMSTATE(""HDR"")"
"RTN","HLOPBLD1",51,0)
 S BATCH=HLMSTATE("BATCH")
"RTN","HLOPBLD1",52,0)
 S FS=@HDR@("FIELD SEPARATOR")
"RTN","HLOPBLD1",53,0)
 S CS=$E(@HDR@("ENCODING CHARACTERS"),1)
"RTN","HLOPBLD1",54,0)
 ;
"RTN","HLOPBLD1",55,0)
 S HDR(1)=TYPE_FS_@HDR@("ENCODING CHARACTERS")_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("SENDING APPLICATION")))
"RTN","HLOPBLD1",56,0)
 ;
"RTN","HLOPBLD1",57,0)
 ;If building an MSH segment for a batch message, these parameters should already be determined
"RTN","HLOPBLD1",58,0)
 D:(('HLMSTATE("BATCH"))!(TYPE="BHS"))
"RTN","HLOPBLD1",59,0)
 .N PORT
"RTN","HLOPBLD1",60,0)
 .S PORT=$$RTRNPORT^HLOAPP($G(@HDR@("SENDING APPLICATION")))
"RTN","HLOPBLD1",61,0)
 .S:'PORT PORT=HLMSTATE("SYSTEM","PORT")
"RTN","HLOPBLD1",62,0)
 .S @HDR@("SENDING FACILITY",1)=HLMSTATE("SYSTEM","STATION")
"RTN","HLOPBLD1",63,0)
 .S @HDR@("SENDING FACILITY",2)=HLMSTATE("SYSTEM","DOMAIN")_":"_PORT
"RTN","HLOPBLD1",64,0)
 .S @HDR@("SENDING FACILITY",3)="DNS"
"RTN","HLOPBLD1",65,0)
 .;
"RTN","HLOPBLD1",66,0)
 .;create the unique message ids, using the ien from file 778
"RTN","HLOPBLD1",67,0)
 .S:TYPE="BHS" @HDR@("BATCH CONTROL ID")=HLMSTATE("SYSTEM","STATION")_" "_HLMSTATE("IEN")
"RTN","HLOPBLD1",68,0)
 .S:TYPE="MSH" @HDR@("MESSAGE CONTROL ID")=HLMSTATE("SYSTEM","STATION")_" "_HLMSTATE("IEN")
"RTN","HLOPBLD1",69,0)
 .;
"RTN","HLOPBLD1",70,0)
 .S @HDR@("PROCESSING ID")=HLMSTATE("SYSTEM","PROCESSING ID")
"RTN","HLOPBLD1",71,0)
 .S @HDR@("DT/TM OF MESSAGE")=$$HLDATE^HLFNC($$NOW^XLFDT,"TS")
"RTN","HLOPBLD1",72,0)
 ;
"RTN","HLOPBLD1",73,0)
 S HDR(1)=HDR(1)_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("SENDING FACILITY",1)))_CS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("SENDING FACILITY",2)))_CS_"DNS"
"RTN","HLOPBLD1",74,0)
 S HDR(1)=HDR(1)_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("RECEIVING APPLICATION")))
"RTN","HLOPBLD1",75,0)
 S HDR(1)=HDR(1)_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("RECEIVING FACILITY",1)))_CS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("RECEIVING FACILITY",2)))
"RTN","HLOPBLD1",76,0)
 S HDR(1)=HDR(1)_CS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("RECEIVING FACILITY",3)))
"RTN","HLOPBLD1",77,0)
 S HDR(2)=FS_$$ESCAPE^HLOPBLD(.HLMSTATE,@HDR@("DT/TM OF MESSAGE"))_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("SECURITY")))
"RTN","HLOPBLD1",78,0)
 ;
"RTN","HLOPBLD1",79,0)
 I TYPE="MSH" D
"RTN","HLOPBLD1",80,0)
 .N ID
"RTN","HLOPBLD1",81,0)
 .S HDR(2)=HDR(2)_FS_@HDR@("MESSAGE TYPE")_CS_@HDR@("EVENT")_CS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("MESSAGE STRUCTURE")))
"RTN","HLOPBLD1",82,0)
 .S:BATCH ID=@HDR@("BATCH CONTROL ID")_"-"_$G(HLMSTATE("BATCH","CURRENT MESSAGE"))
"RTN","HLOPBLD1",83,0)
 .S:'BATCH ID=@HDR@("MESSAGE CONTROL ID")
"RTN","HLOPBLD1",84,0)
 .S HDR(2)=HDR(2)_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,ID)_FS_@HDR@("PROCESSING ID")_CS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("PROCESSING MODE")))_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,@HDR@("VERSION"))
"RTN","HLOPBLD1",85,0)
 .S HDR(2)=HDR(2)_FS_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("CONTINUATION POINTER")))_FS_@HDR@("ACCEPT ACK TYPE")_FS_@HDR@("APP ACK TYPE")_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("COUNTRY")))
"RTN","HLOPBLD1",86,0)
 ;
"RTN","HLOPBLD1",87,0)
 I TYPE="BHS" D
"RTN","HLOPBLD1",88,0)
 .N TEXT
"RTN","HLOPBLD1",89,0)
 .S TEXT="PROCESSING ID"_"="_@HDR@("PROCESSING ID")_" "
"RTN","HLOPBLD1",90,0)
 .I $L($G(@HDR@("ACCEPT ACK TYPE"))) S TEXT=TEXT_"ACCEPT ACK TYPE"_"="_@HDR@("ACCEPT ACK TYPE")_" "
"RTN","HLOPBLD1",91,0)
 .I $L($G(@HDR@("APP ACK TYPE"))) S TEXT=TEXT_"APP ACK TYPE"_"="_@HDR@("APP ACK TYPE")_" "
"RTN","HLOPBLD1",92,0)
 .S HDR(2)=HDR(2)_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,TEXT)_FS_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,@HDR@("BATCH CONTROL ID"))_FS_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(@HDR@("REFERENCE BATCH CONTROL ID")))
"RTN","HLOPBLD1",93,0)
 Q
"RTN","HLOPRS")
0^6^B29583267^B30775930
"RTN","HLOPRS",1,0)
HLOPRS ;IRMFO-ALB/CJM -RTNs for parsing messages;03/24/2004  14:43 ;10/24/2006
"RTN","HLOPRS",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**118,126,133,132**;Oct 13, 1995;Build 6
"RTN","HLOPRS",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPRS",4,0)
 ;
"RTN","HLOPRS",5,0)
STARTMSG(MSG,IEN,HDR) ;
"RTN","HLOPRS",6,0)
 ;Description:  This function begins the parsing of the message, parsing
"RTN","HLOPRS",7,0)
 ;the header and returning the individual values in the array HDR().
"RTN","HLOPRS",8,0)
 ;Input: 
"RTN","HLOPRS",9,0)
 ;  IEN - The internal entry number of the message in file 778.
"RTN","HLOPRS",10,0)
 ;Output:
"RTN","HLOPRS",11,0)
 ;  Function returns 1 on success, 0 on failure.  Failure would indicate that the message was not found.
"RTN","HLOPRS",12,0)
 ;  MSG - (pass by reference, required) This array is used by the HL7 package to track the progress of parsing the message.  The application MUST NOT touch it!
"RTN","HLOPRS",13,0)
 ;  HDR (pass by reference, optional)   This array contains the results of parsing the message header.
"RTN","HLOPRS",14,0)
 K MSG,HDR
"RTN","HLOPRS",15,0)
 Q:'$G(IEN) 0
"RTN","HLOPRS",16,0)
 Q:'$$GETMSG^HLOMSG(IEN,.MSG) 0
"RTN","HLOPRS",17,0)
 M HDR=MSG("HDR")
"RTN","HLOPRS",18,0)
 Q:'$$PARSEHDR(.HDR) 0
"RTN","HLOPRS",19,0)
 M MSG("HDR")=HDR
"RTN","HLOPRS",20,0)
 Q 1
"RTN","HLOPRS",21,0)
 ;
"RTN","HLOPRS",22,0)
NEXTSEG(MSG,SEG) ;
"RTN","HLOPRS",23,0)
 ;Description:  Advances parsing to the next segment and returns the parsed values from that segment.
"RTN","HLOPRS",24,0)
 ;Input:
"RTN","HLOPRS",25,0)
 ;  MSG - (pass by reference, required) This array is used by the HL7 package to track the current position in the message.  The application MUST NOT touch it!
"RTN","HLOPRS",26,0)
 ;Output:
"RTN","HLOPRS",27,0)
 ;  Function  returns 1 on success, 0 if there are no more segments in this message.  For batch messages, a return value of 0 does not preclude the possibility that there are additional individual messages within the batch.
"RTN","HLOPRS",28,0)
 ;  MSG - (pass by reference, required)
"RTN","HLOPRS",29,0)
 ;  SEG - (pass by reference, required)  The segment is returned in this array.
"RTN","HLOPRS",30,0)
 ;
"RTN","HLOPRS",31,0)
 N TEMP,CODES
"RTN","HLOPRS",32,0)
 K SEG
"RTN","HLOPRS",33,0)
 I '$$HLNEXT^HLOMSG(.MSG,.TEMP) Q 0
"RTN","HLOPRS",34,0)
 S CODES=MSG("HDR","ENCODING CHARACTERS")
"RTN","HLOPRS",35,0)
 Q $$PARSE^HLOPRS1(MSG("HDR","FIELD SEPARATOR"),$E(CODES,2),$E(CODES,1),$E(CODES,4),$E(CODES,3),.TEMP,.SEG)
"RTN","HLOPRS",36,0)
 ;
"RTN","HLOPRS",37,0)
NEXTMSG(MSG,MSH) ;
"RTN","HLOPRS",38,0)
 ;Description:  Advances to the next message within the batch, with the MSH segment returned.
"RTN","HLOPRS",39,0)
 ;Input:
"RTN","HLOPRS",40,0)
 ; MSG (pass by reference, required) This array is used by the HL7 package to track the current position in the message.  The application MUST NOT touch it!
"RTN","HLOPRS",41,0)
 ;OUTPUT:
"RTN","HLOPRS",42,0)
 ;  Function returns 1 on success, 0 if there are no more messages
"RTN","HLOPRS",43,0)
 ;  MSG - (pass by reference)
"RTN","HLOPRS",44,0)
 ;  MSH - (pass by reference, required) Returns the parsed message header
"RTN","HLOPRS",45,0)
 ;
"RTN","HLOPRS",46,0)
 K MSH
"RTN","HLOPRS",47,0)
 N NODE
"RTN","HLOPRS",48,0)
 Q:'$$NEXTMSG^HLOMSG(.MSG,.MSH) 0
"RTN","HLOPRS",49,0)
 Q:'$$PARSEHDR(.MSH) 0
"RTN","HLOPRS",50,0)
 S MSG("BATCH","CURRENT MESSAGE","EVENT")=MSH("EVENT")
"RTN","HLOPRS",51,0)
 S MSG("BATCH","CURRENT MESSAGE","MESSAGE CONTROL ID")=MSH("MESSAGE CONTROL ID")
"RTN","HLOPRS",52,0)
 S NODE=$G(^HLB(MSG("IEN"),3,MSG("BATCH","CURRENT MESSAGE"),0))
"RTN","HLOPRS",53,0)
 S MSG("BATCH","CURRENT MESSAGE","ACK TO")=$P(NODE,"^",3)
"RTN","HLOPRS",54,0)
 S MSG("BATCH","CURRENT MESSAGE","ACK BY")=$P(NODE,"^",4)
"RTN","HLOPRS",55,0)
 ;
"RTN","HLOPRS",56,0)
 I MSG("BATCH","CURRENT MESSAGE","ACK TO")]"" S MSG("BATCH","CURRENT MESSAGE","ACK TO IEN")=$$ACKTOIEN^HLOMSG1(MSG("MESSAGE CONTROL ID"),MSG("BATCH","CURRENT MESSAGE","ACK TO"))
"RTN","HLOPRS",57,0)
 I MSG("BATCH","CURRENT MESSAGE","ACK BY")]"" S MSG("BATCH","CURRENT MESSAGE","ACK BY IEN")=$$ACKBYIEN^HLOMSG1(MSG("MESSAGE CONTROL ID"),MSG("BATCH","CURRENT MESSAGE","ACK BY"))
"RTN","HLOPRS",58,0)
 ;
"RTN","HLOPRS",59,0)
 Q 1
"RTN","HLOPRS",60,0)
 ;
"RTN","HLOPRS",61,0)
PARSEHDR(HDR) ;
"RTN","HLOPRS",62,0)
 ;Parses the segment (HDR, pass by reference) into the HDR() array using meaningful subscripts.
"RTN","HLOPRS",63,0)
 ;Input:
"RTN","HLOPRS",64,0)
 ;  HDR (pass by reference, required) contains the segment in the format HDR(1),HDR(2), etc..
"RTN","HLOPRS",65,0)
 ;Output:
"RTN","HLOPRS",66,0)
 ;  HDR (pass by reference, required) This array will contain all the individual values.  Also will contain HDR(1) with components 1-6 and HDR(2) with components 1-end
"RTN","HLOPRS",67,0)
 ;  Function - returns 1 if the segment is indeed an MSH or BHS segment, 0 otherwise
"RTN","HLOPRS",68,0)
 ;
"RTN","HLOPRS",69,0)
 N VALUE,FS,CS,REP,SUBCOMP,ESCAPE
"RTN","HLOPRS",70,0)
 S VALUE=$E(HDR(1),1,3)
"RTN","HLOPRS",71,0)
 I VALUE'="MSH",VALUE'="BHS" Q 0
"RTN","HLOPRS",72,0)
 S HDR("SEGMENT TYPE")=VALUE
"RTN","HLOPRS",73,0)
 S FS=$E(HDR(1),4)
"RTN","HLOPRS",74,0)
 Q:FS="" 0
"RTN","HLOPRS",75,0)
 S HDR("ENCODING CHARACTERS")=$P(HDR(1),FS,2)
"RTN","HLOPRS",76,0)
 S CS=$E(HDR("ENCODING CHARACTERS"),1)
"RTN","HLOPRS",77,0)
 S REP=$E(HDR("ENCODING CHARACTERS"),2)
"RTN","HLOPRS",78,0)
 S ESCAPE=$E(HDR("ENCODING CHARACTERS"),3)
"RTN","HLOPRS",79,0)
 S SUBCOMP=$E(HDR("ENCODING CHARACTERS"),4)
"RTN","HLOPRS",80,0)
 Q:REP="" 0
"RTN","HLOPRS",81,0)
 S HDR("FIELD SEPARATOR")=FS
"RTN","HLOPRS",82,0)
 S HDR("COMPONENT SEPARATOR")=CS
"RTN","HLOPRS",83,0)
 S HDR("REPETITION SEPARATOR")=REP
"RTN","HLOPRS",84,0)
 S HDR("ESCAPE CHARACTER")=ESCAPE
"RTN","HLOPRS",85,0)
 S HDR("SUBCOMPONENT SEPARATOR")=SUBCOMP
"RTN","HLOPRS",86,0)
 S HDR("SENDING APPLICATION")=$$DESCAPE($P($P(HDR(1),FS,3),CS))
"RTN","HLOPRS",87,0)
 S VALUE=$P(HDR(1),FS,4)
"RTN","HLOPRS",88,0)
 S HDR("SENDING FACILITY",1)=$$DESCAPE($P(VALUE,CS))
"RTN","HLOPRS",89,0)
 S HDR("SENDING FACILITY",2)=$$DESCAPE($P(VALUE,CS,2))
"RTN","HLOPRS",90,0)
 S HDR("SENDING FACILITY",3)=$$DESCAPE($P(VALUE,CS,3))
"RTN","HLOPRS",91,0)
 S HDR("RECEIVING APPLICATION")=$$DESCAPE($P($P(HDR(1),FS,5),CS))
"RTN","HLOPRS",92,0)
 S VALUE=$P(HDR(1),FS,6)
"RTN","HLOPRS",93,0)
 S HDR("RECEIVING FACILITY",1)=$$DESCAPE($P(VALUE,CS))
"RTN","HLOPRS",94,0)
 S HDR("RECEIVING FACILITY",2)=$$DESCAPE($P(VALUE,CS,2))
"RTN","HLOPRS",95,0)
 S HDR("RECEIVING FACILITY",3)=$$DESCAPE($P(VALUE,CS,3))
"RTN","HLOPRS",96,0)
 S HDR("DT/TM OF MESSAGE")=$$FMDATE^HLFNC($$DESCAPE($P($P(HDR(2),FS,2),CS)))
"RTN","HLOPRS",97,0)
 S HDR("SECURITY")=$$DESCAPE($P($P(HDR(2),FS,3),CS))
"RTN","HLOPRS",98,0)
 ;
"RTN","HLOPRS",99,0)
 I HDR("SEGMENT TYPE")="MSH" D
"RTN","HLOPRS",100,0)
 .S VALUE=$P(HDR(2),FS,4)
"RTN","HLOPRS",101,0)
 .S HDR("MESSAGE TYPE")=$P(VALUE,CS)
"RTN","HLOPRS",102,0)
 .S HDR("EVENT")=$P(VALUE,CS,2)
"RTN","HLOPRS",103,0)
 .S HDR("MESSAGE STRUCTURE")=$$DESCAPE($P(VALUE,CS,3))
"RTN","HLOPRS",104,0)
 .S HDR("MESSAGE CONTROL ID")=$$DESCAPE($P($P(HDR(2),FS,5),CS))
"RTN","HLOPRS",105,0)
 .S VALUE=$P(HDR(2),FS,6)
"RTN","HLOPRS",106,0)
 .S HDR("PROCESSING ID")=$P(VALUE,CS)
"RTN","HLOPRS",107,0)
 .S HDR("PROCESSING MODE")=$$DESCAPE($P(VALUE,CS,2))
"RTN","HLOPRS",108,0)
 .S HDR("VERSION")=$$DESCAPE($P($P(HDR(2),FS,7),CS))
"RTN","HLOPRS",109,0)
 .S HDR("CONTINUATION POINTER")=$$DESCAPE($P($P(HDR(2),FS,9),CS))
"RTN","HLOPRS",110,0)
 .S HDR("ACCEPT ACK TYPE")=$P($P(HDR(2),FS,10),CS)
"RTN","HLOPRS",111,0)
 .S HDR("APP ACK TYPE")=$P($P(HDR(2),FS,11),CS)
"RTN","HLOPRS",112,0)
 .S HDR("COUNTRY")=$$DESCAPE($P($P(HDR(2),FS,12),CS))
"RTN","HLOPRS",113,0)
 ;
"RTN","HLOPRS",114,0)
 I HDR("SEGMENT TYPE")="BHS" D
"RTN","HLOPRS",115,0)
 .S VALUE=$P(HDR(2),FS,4)
"RTN","HLOPRS",116,0)
 .S HDR("BATCH NAME/ID/TYPE")=$$DESCAPE(VALUE)
"RTN","HLOPRS",117,0)
 .S HDR("PROCESSING ID")=$E($P(VALUE,"PROCESSING ID=",2),1)
"RTN","HLOPRS",118,0)
 .S HDR("ACCEPT ACK TYPE")=$E($P(VALUE,"ACCEPT ACK TYPE=",2),1,2)
"RTN","HLOPRS",119,0)
 .S HDR("APP ACK TYPE")=$E($P(VALUE,"APP ACK TYPE=",2),1,2)
"RTN","HLOPRS",120,0)
 .S HDR("BATCH COMMENT")=$$DESCAPE($P(HDR(2),FS,5))
"RTN","HLOPRS",121,0)
 .S HDR("BATCH CONTROL ID")=$$DESCAPE($P($P(HDR(2),FS,6),CS))
"RTN","HLOPRS",122,0)
 .S HDR("REFERENCE BATCH CONTROL ID")=$$DESCAPE($P($P(HDR(2),FS,7),CS))
"RTN","HLOPRS",123,0)
 .;
"RTN","HLOPRS",124,0)
 Q 1
"RTN","HLOPRS",125,0)
 ;
"RTN","HLOPRS",126,0)
DESCAPE(VALUE) ;
"RTN","HLOPRS",127,0)
 Q $$DESCAPE^HLOPRS1(VALUE,FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",128,0)
 ;
"RTN","HLOPRS",129,0)
GET(SEG,FIELD,COMP,SUBCOMP,REP) ;
"RTN","HLOPRS",130,0)
 ;This function gets a specified value from a segment that was parsed by
"RTN","HLOPRS",131,0)
 ;$$NEXTSEG. The FIELD,COMP,SUBCOMP,REP parameters are optional - if not
"RTN","HLOPRS",132,0)
 ;specified, they default to 1.
"RTN","HLOPRS",133,0)
 ;  Example:
"RTN","HLOPRS",134,0)
 ;    $$GET^HLOPRS(.SEG,1) will return the value of the first field, first
"RTN","HLOPRS",135,0)
 ;  component, first subcomponent, in the first occurrence of field #1.  
"RTN","HLOPRS",136,0)
 ;Input:
"RTN","HLOPRS",137,0)
 ;SEG - (required, pass by reference) - this is the array where the parsed segment was placed by $$NEXTSEG
"RTN","HLOPRS",138,0)
 ;FIELD - the sequence # of the field (optional, defaults to 1)
"RTN","HLOPRS",139,0)
 ;COMP - the # of the component (optional, defaults to 1)
"RTN","HLOPRS",140,0)
 ;SUBCOMP - the # of the subcomponent (optional, defaults to 1)
"RTN","HLOPRS",141,0)
 ;REP - the occurrence# (optional, defaults to 1)  For a non-repeating field, the occurrence # need not be provided, because it would be 1.
"RTN","HLOPRS",142,0)
 ;Output:
"RTN","HLOPRS",143,0)
 ;  Function returns the requested value on success, "" if not valued.
"RTN","HLOPRS",144,0)
 ;
"RTN","HLOPRS",145,0)
 ;allow the segment type to be obtained via field #0 (shorthand)
"RTN","HLOPRS",146,0)
 I $D(FIELD),$G(FIELD)=0 Q $G(SEG("SEGMENT TYPE"))
"RTN","HLOPRS",147,0)
 S:'$G(FIELD) FIELD=1
"RTN","HLOPRS",148,0)
 ;
"RTN","HLOPRS",149,0)
 ;for MSH or BHS, SEQ#1 is the  field separator
"RTN","HLOPRS",150,0)
 I FIELD=1,$G(SEG("SEGMENT TYPE"))="MSH"!($G(SEG("SEGMENT TYPE"))="BHS"),$G(REP)<2,$G(COMP)<2,$G(SUBCOMP)<2 Q SEG("FIELD SEPARATOR")
"RTN","HLOPRS",151,0)
 I FIELD=1,$G(SEG("SEGMENT TYPE"))="MSH"!($G(SEG("SEGMENT TYPE"))="BHS") Q ""
"RTN","HLOPRS",152,0)
 ;
"RTN","HLOPRS",153,0)
 ;For segments other than MSH or BHS, the first subscript in the SEG array needs to be incremented by 1, because SEG(1,1,1,1) is taken by the segment type, which technically isn't a field. (for convenience,we call it SEQ=0).  
"RTN","HLOPRS",154,0)
 I $G(SEG("SEGMENT TYPE"))'="BHS",$G(SEG("SEGMENT TYPE"))'="MSH" S FIELD=FIELD+1
"RTN","HLOPRS",155,0)
 S:'$G(COMP) COMP=1
"RTN","HLOPRS",156,0)
 S:'$G(SUBCOMP) SUBCOMP=1
"RTN","HLOPRS",157,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS",158,0)
 Q $G(SEG(FIELD,REP,COMP,SUBCOMP))
"RTN","HLOPRS",159,0)
 ;
"RTN","HLOQUE")
0^2^B5510606^B5007132
"RTN","HLOQUE",1,0)
HLOQUE ;ALB/CJM- HL7 QUEUE MANAGEMENT - 10/4/94 1pm ;09/01/2006
"RTN","HLOQUE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132**;Oct 13, 1995;Build 6
"RTN","HLOQUE",3,0)
 ;
"RTN","HLOQUE",4,0)
INQUE(FROM,QNAME,IEN778,ACTION,PURGE) ;
"RTN","HLOQUE",5,0)
 ;Will place the message=IEN778 on the IN queue, incoming
"RTN","HLOQUE",6,0)
 ;Input:
"RTN","HLOQUE",7,0)
 ;  FROM - sending facility from message header.
"RTN","HLOQUE",8,0)
 ;         For actions other than incoming messages, its the specified link.
"RTN","HLOQUE",9,0)
 ;  QNAME - queue named by the application
"RTN","HLOQUE",10,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",11,0)
 ;  ACTION - <tag^routine> that should be executed for the application
"RTN","HLOQUE",12,0)
 ;  PURGE (optional) - PURGE=1 indicates that the purge dt/tm needs to be set by the infiler
"RTN","HLOQUE",13,0)
 ;     If PURGE("ACKTOIEN") is set, it indicates that the purge dt/tm of
"RTN","HLOQUE",14,0)
 ;     the original message to this application ack also needs to be set.
"RTN","HLOQUE",15,0)
 ;Output: none
"RTN","HLOQUE",16,0)
 ;
"RTN","HLOQUE",17,0)
 I $G(FROM)="" S FROM="UNKNOWN"
"RTN","HLOQUE",18,0)
 I '$L($G(QNAME)) S QNAME="DEFAULT"
"RTN","HLOQUE",19,0)
 S ^HLB("QUEUE","IN",FROM,QNAME,IEN778)=ACTION_"^"_$G(PURGE)_"^"_$G(PURGE("ACKTOIEN"))
"RTN","HLOQUE",20,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","IN",FROM,QNAME)))
"RTN","HLOQUE",21,0)
 Q
"RTN","HLOQUE",22,0)
 ;
"RTN","HLOQUE",23,0)
OUTQUE(LINKNAME,PORT,QNAME,IEN778) ;
"RTN","HLOQUE",24,0)
 ;Will place the message=IEN778 on the out-going queue
"RTN","HLOQUE",25,0)
 ;Input:
"RTN","HLOQUE",26,0)
 ;  LINKNAME = name of (.01) the logical link
"RTN","HLOQUE",27,0)
 ;  PORT (optional) the port to connect to
"RTN","HLOQUE",28,0)
 ;  QNAME - queue named by the application
"RTN","HLOQUE",29,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",30,0)
 ;Output: none
"RTN","HLOQUE",31,0)
 ;
"RTN","HLOQUE",32,0)
 N SUB
"RTN","HLOQUE",33,0)
 S SUB=LINKNAME
"RTN","HLOQUE",34,0)
 I PORT S SUB=SUB_":"_PORT
"RTN","HLOQUE",35,0)
 I '$L($G(QNAME)) S QNAME="DEFAULT"
"RTN","HLOQUE",36,0)
 S ^HLB("QUEUE","OUT",SUB,QNAME,IEN778)=""
"RTN","HLOQUE",37,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","OUT",SUB,QNAME)))
"RTN","HLOQUE",38,0)
 Q
"RTN","HLOQUE",39,0)
 ;
"RTN","HLOQUE",40,0)
DEQUE(FROMORTO,QNAME,DIR,IEN778) ;
"RTN","HLOQUE",41,0)
 ;This routine will remove the message=IEN778 from its queue
"RTN","HLOQUE",42,0)
 ;Input:
"RTN","HLOQUE",43,0)
 ;  DIR = "IN" or "OUT", denoting the direction that the message is going in
"RTN","HLOQUE",44,0)
 ;  FROMORTO = for outgoing: the .01 field of the logical link
"RTN","HLOQUE",45,0)
 ;         for incoming: sending facility
"RTN","HLOQUE",46,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",47,0)
 ;Output: none
"RTN","HLOQUE",48,0)
 ;
"RTN","HLOQUE",49,0)
 Q:(FROMORTO="")
"RTN","HLOQUE",50,0)
 I ($G(QNAME)="") S QNAME="DEFAULT"
"RTN","HLOQUE",51,0)
 D
"RTN","HLOQUE",52,0)
 .I $E(DIR)="I" S DIR="IN" Q
"RTN","HLOQUE",53,0)
 .I $E(DIR)="O" S DIR="OUT" Q
"RTN","HLOQUE",54,0)
 I DIR'="IN",DIR'="OUT" Q
"RTN","HLOQUE",55,0)
 Q:'$G(IEN778)
"RTN","HLOQUE",56,0)
 I $D(^HLB("QUEUE",DIR,FROMORTO,QNAME,IEN778)) D
"RTN","HLOQUE",57,0)
 .N COUNT
"RTN","HLOQUE",58,0)
 .K ^HLB("QUEUE",DIR,FROMORTO,QNAME,IEN778)
"RTN","HLOQUE",59,0)
 .S COUNT=$$INC^HLOSITE($NA(^HLC("QUEUECOUNT",DIR,FROMORTO,QNAME)),-1)
"RTN","HLOQUE",60,0)
 .;don't let the count get below zero!
"RTN","HLOQUE",61,0)
 .I COUNT<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT",DIR,FROMORTO,QNAME)),-COUNT)
"RTN","HLOQUE",62,0)
 Q
"RTN","HLOQUE",63,0)
 ;
"RTN","HLOQUE",64,0)
STOPQUE(DIR,QUEUE) ;
"RTN","HLOQUE",65,0)
 ;This API is used to set a stop flag on a named queue.
"RTN","HLOQUE",66,0)
 ;DIR=<"IN" or "OUT">
"RTN","HLOQUE",67,0)
 ;QUEUE - the name of the queue to be stopped
"RTN","HLOQUE",68,0)
 ;
"RTN","HLOQUE",69,0)
 Q:$G(DIR)=""
"RTN","HLOQUE",70,0)
 Q:$G(QUEUE)=""
"RTN","HLOQUE",71,0)
 S ^HLTMP("STOPPED QUEUES",DIR,QUEUE)=1
"RTN","HLOQUE",72,0)
 Q
"RTN","HLOQUE",73,0)
STARTQUE(DIR,QUEUE) ;
"RTN","HLOQUE",74,0)
 ;This API is used to REMOVE the stop flag on a named queue.
"RTN","HLOQUE",75,0)
 ;DIR=<"IN" or "OUT">
"RTN","HLOQUE",76,0)
 ;QUEUE - the name of the queue to be stopped
"RTN","HLOQUE",77,0)
 ;
"RTN","HLOQUE",78,0)
 Q:$G(DIR)=""
"RTN","HLOQUE",79,0)
 Q:$G(QUEUE)=""
"RTN","HLOQUE",80,0)
 K ^HLTMP("STOPPED QUEUES",DIR,QUEUE)
"RTN","HLOQUE",81,0)
 Q
"RTN","HLOQUE",82,0)
STOPPED(DIR,QUEUE) ;
"RTN","HLOQUE",83,0)
 ;This API is used to DETERMINE if the stop flag on a named queue is set.
"RTN","HLOQUE",84,0)
 ;Input:
"RTN","HLOQUE",85,0)
 ;  DIR=<"IN" or "OUT">
"RTN","HLOQUE",86,0)
 ;  QUEUE - the name of the queue to be checked
"RTN","HLOQUE",87,0)
 ;Output:
"RTN","HLOQUE",88,0)
 ;  Function returns 1 if the queue is stopped, 0 otherwise
"RTN","HLOQUE",89,0)
 Q:$G(DIR)="" 0
"RTN","HLOQUE",90,0)
 Q:$G(QUEUE)="" 0
"RTN","HLOQUE",91,0)
 I $G(^HLTMP("STOPPED QUEUES",DIR,QUEUE)) Q 1
"RTN","HLOQUE",92,0)
 Q 0
"VER")
8.0^22.0
"^DD",779.2,779.2,0)
FIELD^^2^11
"^DD",779.2,779.2,0,"DDA")
N
"^DD",779.2,779.2,0,"DT")
3060626
"^DD",779.2,779.2,0,"IX","B",779.2,.01)

"^DD",779.2,779.2,0,"NM","HLO APPLICATION REGISTRY")

"^DD",779.2,779.2,0,"VRPK")
HL
"^DD",779.2,779.2,.01,0)
APPLICATION NAME^RF^^0;1^K:$L(X)>60!($L(X)<3)!'(X'?1P.E) X
"^DD",779.2,779.2,.01,1,0)
^.1
"^DD",779.2,779.2,.01,1,1,0)
779.2^B
"^DD",779.2,779.2,.01,1,1,1)
S ^HLD(779.2,"B",$E(X,1,30),DA)=""
"^DD",779.2,779.2,.01,1,1,2)
K ^HLD(779.2,"B",$E(X,1,30),DA)
"^DD",779.2,779.2,.01,3)
Answer must be 3-60 characters in length. It must be unique and should be name-spaced.
"^DD",779.2,779.2,.01,"DT")
3050125
"^DD",779.2,779.2,.02,0)
RESPONSE LINK (OPTIONAL)^FX^^0;2^K:'$$CHKLINK^HLOTLNK(X) X
"^DD",779.2,779.2,.02,3)
If the return link cannot be identified via the Sending Facility (i.e., sent via an IE), what link should the application ack be sent through?
"^DD",779.2,779.2,.02,21,0)
^^5^5^3041116^^
"^DD",779.2,779.2,.02,21,1,0)
This field applies only if: 1) The receiving application is expected to 
"^DD",779.2,779.2,.02,21,2,0)
return application acknowledgments.  2) The initial message is  received 
"^DD",779.2,779.2,.02,21,3,0)
indirectly through the IE, and the  receiving application in turn does 
"^DD",779.2,779.2,.02,21,4,0)
not want to send the application acknowledgment directly back to the 
"^DD",779.2,779.2,.02,21,5,0)
sending facility identified in the message header.  
"^DD",779.2,779.2,.02,"DT")
3041116
"^DD",779.2,779.2,.03,0)
DEFAULT PRIVATE IN-QUEUE^F^^0;3^K:$L(X)>20!($L(X)<3) X
"^DD",779.2,779.2,.03,3)
You may create an optional default private in-queue by entering a unique name up to 20 characters in length. Queues specified for specific message types take precedence.
"^DD",779.2,779.2,.03,"DT")
3050317
"^DD",779.2,779.2,.04,0)
BATCH ACTION TAG^F^^0;4^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.2,.04,3)
If the application utilizes batch messages, the action to perform upon receipt of the message should be entered in the BATCH ACTION TAG and BATCH ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.2,.04,"DT")
3040814
"^DD",779.2,779.2,.05,0)
BATCH ACTION ROUTINE^F^^0;5^K:$L(X)>8!($L(X)<3) X
"^DD",779.2,779.2,.05,3)
If the application utilizes batch messages, the action to perform upon receipt of the message should be entered in the BATCH ACTION TAG and BATCH ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.2,.05,"DT")
3040814
"^DD",779.2,779.2,.06,0)
DEFAULT ACTION TAG^F^^0;6^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.2,.06,3)
You can enter the action to perform upon  receipt of a message where no other action applies by entering the DEFAULT ACTION TAG and DEFAULT ACTION ROUTINE fields as <tag>^<routine>. 
"^DD",779.2,779.2,.06,"DT")
3040815
"^DD",779.2,779.2,.07,0)
DEFAULT ACTION ROUTINE^F^^0;7^K:$L(X)>8!($L(X)<3) X
"^DD",779.2,779.2,.07,3)
You can enter the action to perform upon receipt of a message where no other action applies by entering the DEFAULT ACTION TAG and DEFAULT ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.2,.07,"DT")
3040814
"^DD",779.2,779.2,.08,0)
BATCH PRIVATE IN-QUEUE^F^^0;8^K:$L(X)>20!($L(X)<3) X
"^DD",779.2,779.2,.08,3)
You may establish a private queue for your batch messages by entering a unique name (name-spaced) up to 20 characters long.
"^DD",779.2,779.2,.08,"DT")
3050317
"^DD",779.2,779.2,.09,0)
APPLICATION SPECIFIC LISTENER^*P870'^HLCS(870,^0;9^S DIC("S")="I $E($P(^HLCS(870,Y,0),""^"",4),2)=""S""" D ^DIC K DIC S DIC=$G(DIE),X=+Y K:Y<0 X
"^DD",779.2,779.2,.09,3)
If your application requires its own listener (HIGHLY DISCOURAGED), enter it here.
"^DD",779.2,779.2,.09,12)
The link entered must be a listener.
"^DD",779.2,779.2,.09,12.1)
S DIC("S")="I $E($P(^HLCS(870,Y,0),""^"",4),2)=""S"""
"^DD",779.2,779.2,.09,21,0)
^^6^6^3050503^
"^DD",779.2,779.2,.09,21,1,0)
Applications are highly discouraged from establishing their own listeners.  The
"^DD",779.2,779.2,.09,21,2,0)
use of the multi-listeners provide concurrent processing of many connections
"^DD",779.2,779.2,.09,21,3,0)
over the same port, so a dedicated listener will not provide an application
"^DD",779.2,779.2,.09,21,4,0)
with a performance boost, while it will cause the site additional work to
"^DD",779.2,779.2,.09,21,5,0)
maintain. So before establishing a dedicated listener, the application
"^DD",779.2,779.2,.09,21,6,0)
developer should verify the need.
"^DD",779.2,779.2,.09,"DT")
3050527
"^DD",779.2,779.2,1,0)
MESSAGE TYPE ACTIONS^779.21^^1;0
"^DD",779.2,779.2,1,21,0)
^^1^1^3060626^
"^DD",779.2,779.2,1,21,1,0)

"^DD",779.2,779.2,2,0)
Package File Link^RP9.4'^DIC(9.4,^2;1^Q
"^DD",779.2,779.2,2,3)
Enter the package responsible for these messages.
"^DD",779.2,779.2,2,21,0)
^^3^3^3050919^^
"^DD",779.2,779.2,2,21,1,0)
This field holds a pointer to the Package File for the Package 
"^DD",779.2,779.2,2,21,2,0)
responsible for these messages.
"^DD",779.2,779.2,2,21,3,0)

"^DD",779.2,779.2,2,"DT")
3050919
"^DD",779.2,779.21,0)
MESSAGE TYPE ACTIONS SUB-FIELD^^.07^7
"^DD",779.2,779.21,0,"DT")
3060626
"^DD",779.2,779.21,0,"IX","B",779.21,.01)

"^DD",779.2,779.21,0,"NM","MESSAGE TYPE ACTIONS")

"^DD",779.2,779.21,0,"UP")
779.2
"^DD",779.2,779.21,.01,0)
HL7 MESSAGE TYPE^MF^^0;1^K:$L(X)>3!($L(X)<3) X
"^DD",779.2,779.21,.01,1,0)
^.1
"^DD",779.2,779.21,.01,1,1,0)
779.21^B
"^DD",779.2,779.21,.01,1,1,1)
S ^HLD(779.2,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",779.2,779.21,.01,1,1,2)
K ^HLD(779.2,DA(1),1,"B",$E(X,1,30),DA)
"^DD",779.2,779.21,.01,3)
Enter the 3 character HL7 Message Type.
"^DD",779.2,779.21,.01,21,0)
^^3^3^3040814^
"^DD",779.2,779.21,.01,21,1,0)
An application should use this multiple to define the action that the receiving
"^DD",779.2,779.21,.01,21,2,0)
application needs to perform upon receipt of a specific type of HL7 message,
"^DD",779.2,779.21,.01,21,3,0)
identified by the HL7 MESSAGE TYPE and HL7 EVENT fields.
"^DD",779.2,779.21,.01,"DT")
3060626
"^DD",779.2,779.21,.02,0)
HL7 EVENT^RF^^0;2^K:$L(X)>3!($L(X)<3) X
"^DD",779.2,779.21,.02,3)
Enter the 3 character HL7 event type.
"^DD",779.2,779.21,.02,"DT")
3060626
"^DD",779.2,779.21,.03,0)
PRIVATE IN-QUEUE^F^^0;3^K:$L(X)>20!($L(X)<3) X
"^DD",779.2,779.21,.03,3)
You may create a private in-queue for message of this type by entering a unique name up to 20 characters long.
"^DD",779.2,779.21,.03,"DT")
3050919
"^DD",779.2,779.21,.04,0)
ACTION TAG^F^^0;4^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.21,.04,3)
You must enter the action to perform upon receipt of this type by entering the ACTION TAG and ACTION ROUTINE fields as <tag>^<routine>. The tag is optional. 
"^DD",779.2,779.21,.04,"DT")
3040815
"^DD",779.2,779.21,.05,0)
ACTION ROUTINE^RF^^0;5^K:$L(X)>8!($L(X)<3) X
"^DD",779.2,779.21,.05,3)
You must enter the action to perform upon receipt of this type by entering the ACTION TAG and ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.21,.05,"DT")
3050919
"^DD",779.2,779.21,.06,0)
HL7 VERSION^F^^0;6^K:$L(X)>20!($L(X)<1) X
"^DD",779.2,779.21,.06,3)
Leave blank UNLESS this action applies only to a specfic version of the message!  Enter the version exactly as it will appear in the message header.
"^DD",779.2,779.21,.06,"DT")
3060626
"^DD",779.2,779.21,.07,0)
INACTIVE^S^1:INACTIVE;^0;7^Q
"^DD",779.2,779.21,.07,3)
Enter '1' to stop the application from generating messages of this type.
"^DD",779.2,779.21,.07,21,0)
^^4^4^3060621^
"^DD",779.2,779.21,.07,21,1,0)
This flag is made available to the application, but it is up to the application
"^DD",779.2,779.21,.07,21,2,0)
to honor it.   In otherwords, its up to the application to check the flag and
"^DD",779.2,779.21,.07,21,3,0)
decide whether or not to generate messages of this type.
"^DD",779.2,779.21,.07,21,4,0)

"^DD",779.2,779.21,.07,"DT")
3060621
"^DIC",779.2,779.2,0)
HLO APPLICATION REGISTRY^779.2
"^DIC",779.2,779.2,0,"GL")
^HLD(779.2,
"^DIC",779.2,779.2,"%",0)
^1.005^^0
"^DIC",779.2,779.2,"%D",0)
^^12^12^3050801^^^^
"^DIC",779.2,779.2,"%D",1,0)
This file is used to register sending and receiving applications for HL7
"^DIC",779.2,779.2,"%D",2,0)
messaging. For receiving applications, the process of registration consists of
"^DIC",779.2,779.2,"%D",3,0)
registering what messages the application is prepared to receive.
"^DIC",779.2,779.2,"%D",4,0)

"^DIC",779.2,779.2,"%D",5,0)
For both sending and receiving applications, it is necessary to specify
"^DIC",779.2,779.2,"%D",6,0)
what package the application belongs to.  For sending applications, that is
"^DIC",779.2,779.2,"%D",7,0)
the only field that applies, other than the name of the sending application.
"^DIC",779.2,779.2,"%D",8,0)

"^DIC",779.2,779.2,"%D",9,0)
An application can be either a sender or a receiver of messages, or both. In 
"^DIC",779.2,779.2,"%D",10,0)
order for an application to receive messages, it must specify an action 
"^DIC",779.2,779.2,"%D",11,0)
(M tag^routine) for each type of message that it is capable of receiving, or a
"^DIC",779.2,779.2,"%D",12,0)
default action that applies when no messsage-specific action is defined.
"^DIC",779.2,"B","HLO APPLICATION REGISTRY",779.2)

"BLD",968,6)
^106
**END**
**END**
