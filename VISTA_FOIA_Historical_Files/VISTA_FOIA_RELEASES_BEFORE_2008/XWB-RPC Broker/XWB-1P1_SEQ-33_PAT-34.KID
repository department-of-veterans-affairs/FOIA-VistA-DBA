Released XWB*1.1*34 SEQ #33
Extracted from mail message
**KIDS**:XWB*1.1*34^

**INSTALL NAME**
XWB*1.1*34
"BLD",512,0)
XWB*1.1*34^RPC BROKER^0^3050608^y
"BLD",512,1,0)
^^2^2^3050531^
"BLD",512,1,1,0)
Please refer to the Description in the FORUM Patch Module for details.
"BLD",512,1,2,0)
Patch XWB*1.1*34.
"BLD",512,4,0)
^9.64PA^^
"BLD",512,"ABPKG")
n
"BLD",512,"KRN",0)
^9.67PA^8989.52^19
"BLD",512,"KRN",.4,0)
.4
"BLD",512,"KRN",.401,0)
.401
"BLD",512,"KRN",.402,0)
.402
"BLD",512,"KRN",.403,0)
.403
"BLD",512,"KRN",.5,0)
.5
"BLD",512,"KRN",.84,0)
.84
"BLD",512,"KRN",3.6,0)
3.6
"BLD",512,"KRN",3.8,0)
3.8
"BLD",512,"KRN",9.2,0)
9.2
"BLD",512,"KRN",9.8,0)
9.8
"BLD",512,"KRN",9.8,"NM",0)
^9.68A^6^6
"BLD",512,"KRN",9.8,"NM",1,0)
XWBVLL^^0^B15486790
"BLD",512,"KRN",9.8,"NM",2,0)
XWBRL^^0^B13318398
"BLD",512,"KRN",9.8,"NM",3,0)
XWBM2MC^^0^B58578138
"BLD",512,"KRN",9.8,"NM",4,0)
XWBUTL^^0^B10435731
"BLD",512,"KRN",9.8,"NM",5,0)
XWBRPC^^0^B59522634
"BLD",512,"KRN",9.8,"NM",6,0)
XWBRPCC^^0^B18044017
"BLD",512,"KRN",9.8,"NM","B","XWBM2MC",3)

"BLD",512,"KRN",9.8,"NM","B","XWBRL",2)

"BLD",512,"KRN",9.8,"NM","B","XWBRPC",5)

"BLD",512,"KRN",9.8,"NM","B","XWBRPCC",6)

"BLD",512,"KRN",9.8,"NM","B","XWBUTL",4)

"BLD",512,"KRN",9.8,"NM","B","XWBVLL",1)

"BLD",512,"KRN",19,0)
19
"BLD",512,"KRN",19,"NM",0)
^9.68A^1^1
"BLD",512,"KRN",19,"NM",1,0)
XWB M2M CACHE LISTENER^^0
"BLD",512,"KRN",19,"NM","B","XWB M2M CACHE LISTENER",1)

"BLD",512,"KRN",19.1,0)
19.1
"BLD",512,"KRN",19.1,"NM",0)
^9.68A^^
"BLD",512,"KRN",101,0)
101
"BLD",512,"KRN",101,"NM",0)
^9.68A^^
"BLD",512,"KRN",409.61,0)
409.61
"BLD",512,"KRN",771,0)
771
"BLD",512,"KRN",870,0)
870
"BLD",512,"KRN",8989.51,0)
8989.51
"BLD",512,"KRN",8989.52,0)
8989.52
"BLD",512,"KRN",8994,0)
8994
"BLD",512,"KRN","B",.4,.4)

"BLD",512,"KRN","B",.401,.401)

"BLD",512,"KRN","B",.402,.402)

"BLD",512,"KRN","B",.403,.403)

"BLD",512,"KRN","B",.5,.5)

"BLD",512,"KRN","B",.84,.84)

"BLD",512,"KRN","B",3.6,3.6)

"BLD",512,"KRN","B",3.8,3.8)

"BLD",512,"KRN","B",9.2,9.2)

"BLD",512,"KRN","B",9.8,9.8)

"BLD",512,"KRN","B",19,19)

"BLD",512,"KRN","B",19.1,19.1)

"BLD",512,"KRN","B",101,101)

"BLD",512,"KRN","B",409.61,409.61)

"BLD",512,"KRN","B",771,771)

"BLD",512,"KRN","B",870,870)

"BLD",512,"KRN","B",8989.51,8989.51)

"BLD",512,"KRN","B",8989.52,8989.52)

"BLD",512,"KRN","B",8994,8994)

"BLD",512,"QUES",0)
^9.62^^
"BLD",512,"REQB",0)
^9.611^^
"KRN",19,771,-1)
0^1
"KRN",19,771,0)
XWB M2M CACHE LISTENER^Start M2M RPC Broker Cache Listener^^R^^^^^^^y^RPC BROKER^^1^1
"KRN",19,771,1,0)
^19.06^4^4^3040826^^^
"KRN",19,771,1,1,0)
This option is for Cache/NT only.  It will start the listener for RPC 
"KRN",19,771,1,2,0)
Broker M2M.  This option called STRT^XWBVLL() and it is jobbed off.  
"KRN",19,771,1,3,0)
Option will prompt you for PORT# to start the listener on.  The default 
"KRN",19,771,1,4,0)
is 4800 which it the port use for M2M.
"KRN",19,771,10.1)

"KRN",19,771,15)
D STRT^XWBVLL(XWBPORT)
"KRN",19,771,20)
W !! S DIR(0)="N",DIR("B")="4800",DIR("A")="PORT" D ^DIR Q:$D(DIRUT)  S XWBPORT=Y
"KRN",19,771,25)

"KRN",19,771,99)
59625,62769
"KRN",19,771,"U")
START M2M RPC BROKER CACHE LIS
"MBREQ")
0
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",7,-1)
1^1
"PKG",7,0)
RPC BROKER^XWB^Remote Procedure Call Broker
"PKG",7,20,0)
^9.402P^^
"PKG",7,22,0)
^9.49I^1^1
"PKG",7,22,1,0)
1.1^2970918^2990407^126
"PKG",7,22,1,"PAH",1,0)
34^3050608
"PKG",7,22,1,"PAH",1,1,0)
^^2^2^3050608
"PKG",7,22,1,"PAH",1,1,1,0)
Please refer to the Description in the FORUM Patch Module for details.
"PKG",7,22,1,"PAH",1,1,2,0)
Patch XWB*1.1*34.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
6
"RTN","XWBM2MC")
0^3^B58578138
"RTN","XWBM2MC",1,0)
XWBM2MC ;OIFO-Oakland/REM - M2M Broker Client APIs  ;05/21/2002  17:55
"RTN","XWBM2MC",2,0)
 ;;1.1;RPC BROKER;**28,34**;Mar 28, 1997
"RTN","XWBM2MC",3,0)
 ;
"RTN","XWBM2MC",4,0)
 QUIT
"RTN","XWBM2MC",5,0)
 ;
"RTN","XWBM2MC",6,0)
 ;p34 -make sure RES is defined - CALLRPC.
"RTN","XWBM2MC",7,0)
 ;    -error exception if RPCNAM not defined - CALLRPC.
"RTN","XWBM2MC",8,0)
 ;    -kill XWBY before going to PARSE^XWBRPC - CALLRPC.
"RTN","XWBM2MC",9,0)
 ;    -return 0 when error occurs and XWBY=error msg - CALLRPC.
"RTN","XWBM2MC",10,0)
 ;    -new module to GET the division for a user - GETDIV.
"RTN","XWBM2MC",11,0)
 ;    -new module to SET the division for a user - SETDIV.
"RTN","XWBM2MC",12,0)
 ;    -kills entry for current context in ^TMP("XWBM2M",$J) - CLEAN.
"RTN","XWBM2MC",13,0)
 ;    -comment out line. Will do PRE in REQUEST^XWBRPCC - PARAM.
"RTN","XWBM2MC",14,0)
 ;    -send PORT;IP to ERROR so it's included in error msg - ERROR.
"RTN","XWBM2MC",15,0)
 ;    -add 2 more error msg for GETDIV and SETDIV - ERRMGS.
"RTN","XWBM2MC",16,0)
 ;
"RTN","XWBM2MC",17,0)
CONNECT(PORT,IP,AV) ;Establishes the connection to the server.
"RTN","XWBM2MC",18,0)
 ;CONNECT returns 1=successful, 0=failed
"RTN","XWBM2MC",19,0)
 ;PORT - PORT number where listener is running.
"RTN","XWBM2MC",20,0)
 ;IP - IP address where the listener is running.
"RTN","XWBM2MC",21,0)
 ;AV - Access and verify codes to sign on into VistA.
"RTN","XWBM2MC",22,0)
 ;DIV - User division.
"RTN","XWBM2MC",23,0)
 ;
"RTN","XWBM2MC",24,0)
 ;K XWBPARMS
"RTN","XWBM2MC",25,0)
 N XWBSTAT,XWBPARMS
"RTN","XWBM2MC",26,0)
 S XWBPARMS("ADDRESS")=IP,XWBPARMS("PORT")=PORT
"RTN","XWBM2MC",27,0)
 S XWBPARMS("RETRIES")=3 ;Retries 3 times to open
"RTN","XWBM2MC",28,0)
 ;
"RTN","XWBM2MC",29,0)
 ;p34-send PORT;IP to ERROR so it's included in error msg.
"RTN","XWBM2MC",30,0)
 I '$$OPEN^XWBRL(.XWBPARMS) D ERROR(1,PORT_";"_IP) Q 0
"RTN","XWBM2MC",31,0)
 D SAVDEV^%ZISUTL("XWBM2M PORT")
"RTN","XWBM2MC",32,0)
 ;
"RTN","XWBM2MC",33,0)
 ;XUS SIGNON SETUP RPC
"RTN","XWBM2MC",34,0)
 I '$$SIGNON() D ERROR(2) S X=$$CLOSE() Q 0
"RTN","XWBM2MC",35,0)
 ; Results from XUS Signon 
"RTN","XWBM2MC",36,0)
 ; 1=server name, 2=volume, 3=uci, 4=device, 5=# attempts
"RTN","XWBM2MC",37,0)
 ; 6=skip signon-screen
"RTN","XWBM2MC",38,0)
 ;M ^TMP("XWBM2M",$J,"XUS SIGNON")=^TMP("XWBM2MRPC",$J,"RESULTS") ;Remove after testing **REM
"RTN","XWBM2MC",39,0)
 ;
"RTN","XWBM2MC",40,0)
 ;Validate AV codes
"RTN","XWBM2MC",41,0)
 ;S AV=$$CHARCHK^XWBUTL(AV) ;Convert and special char
"RTN","XWBM2MC",42,0)
 I '$$VALIDAV(AV) D ERROR(3) S X=$$CLOSE() Q 0
"RTN","XWBM2MC",43,0)
 ;
"RTN","XWBM2MC",44,0)
 I $G(^TMP("XWBM2MRPC",$J,"RESULTS",1))'>0 D ERROR(4) S X=$$CLOSE() Q 0
"RTN","XWBM2MC",45,0)
 ;M ^TMP("XWBM2M",$J,"XUS AV CODE")=^TMP("XWBM2MRPC",$J,"RESULTS") ;Remove after testing **REM
"RTN","XWBM2MC",46,0)
 ;
"RTN","XWBM2MC",47,0)
 D USE^%ZISUTL("XWBM2M CLIENT") U IO
"RTN","XWBM2MC",48,0)
 S ^TMP("XWBM2M",$J,"CONNECTED")=1
"RTN","XWBM2MC",49,0)
 Q 1
"RTN","XWBM2MC",50,0)
 ;
"RTN","XWBM2MC",51,0)
ISCONT() ;Function to check connection status. 1=connect, 0=not connect
"RTN","XWBM2MC",52,0)
 Q $G(^TMP("XWBM2M",$J,"CONNECTED"),0)
"RTN","XWBM2MC",53,0)
 ;
"RTN","XWBM2MC",54,0)
SETCONTX(CONTXNA) ;Set context and returns 1=successful or 0=failed  
"RTN","XWBM2MC",55,0)
 N REQ,XWBPARMS,X
"RTN","XWBM2MC",56,0)
 S ^TMP("XWBM2M",$J,"CONTEXT")=""
"RTN","XWBM2MC",57,0)
 K ^TMP("XWBM2M",$J,"ERROR","SETCONTX")
"RTN","XWBM2MC",58,0)
 ;;D PRE,SETPARAM(1,"STRING",$$CHARCHK^XWBUTL($$ENCRYP^XUSRB1(CONTXNA)))
"RTN","XWBM2MC",59,0)
 D PRE,SETPARAM(1,"STRING",$$ENCRYP^XUSRB1(CONTXNA))
"RTN","XWBM2MC",60,0)
 S X=$$CALLRPC("XWB CREATE CONTEXT","REQ",1)
"RTN","XWBM2MC",61,0)
 S REQ=$G(REQ(1))
"RTN","XWBM2MC",62,0)
 I REQ'=1 S ^TMP("XWBM2ME",$J,"ERROR","SETCONTX")=REQ Q 0
"RTN","XWBM2MC",63,0)
 S ^TMP("XWBM2M",$J,"CONTEXT")=CONTXNA
"RTN","XWBM2MC",64,0)
 Q 1
"RTN","XWBM2MC",65,0)
 ;
"RTN","XWBM2MC",66,0)
GETCONTX(CONTEXT) ;Returns current context
"RTN","XWBM2MC",67,0)
 S CONTEXT=$G(^TMP("XWBM2M",$J,"CONTEXT"))
"RTN","XWBM2MC",68,0)
 I CONTEXT="" Q 0
"RTN","XWBM2MC",69,0)
 Q 1
"RTN","XWBM2MC",70,0)
 ;
"RTN","XWBM2MC",71,0)
SETPARAM(INDEX,TYPE,VALUE) ;Set a Params entry
"RTN","XWBM2MC",72,0)
 S XWBPARMS("PARAMS",INDEX,"TYPE")=TYPE
"RTN","XWBM2MC",73,0)
 S XWBPARMS("PARAMS",INDEX,"VALUE")=VALUE
"RTN","XWBM2MC",74,0)
 Q
"RTN","XWBM2MC",75,0)
 ;
"RTN","XWBM2MC",76,0)
PARAM(PARAMNUM,ROOT) ;Build the PARAM data structure
"RTN","XWBM2MC",77,0)
 ;p34-comment out line. Will do PRE in REQUEST^XWBRPCC
"RTN","XWBM2MC",78,0)
 ;
"RTN","XWBM2MC",79,0)
 I PARAMNUM=""!(ROOT="") Q 0
"RTN","XWBM2MC",80,0)
 ;D PRE ;*p34
"RTN","XWBM2MC",81,0)
 M XWBPARMS("PARAMS",PARAMNUM)=@ROOT
"RTN","XWBM2MC",82,0)
 Q 1
"RTN","XWBM2MC",83,0)
 ;
"RTN","XWBM2MC",84,0)
CALLRPC(RPCNAM,RES,CLRPARMS) ;Call to RPC and wraps RPC in XML
"RTN","XWBM2MC",85,0)
 ;RPCNAM -RPC name to run
"RTN","XWBM2MC",86,0)
 ;RES -location where to place results.  If no RES, then results will be
"RTN","XWBM2MC",87,0)
 ; placed in ^TMP("XWBM2M",$J,"RESULTS")
"RTN","XWBM2MC",88,0)
 ;CLRPARMS - 1=clear PARAMS, 0=do not clear PARAMS.  Default is 1.
"RTN","XWBM2MC",89,0)
 ;
"RTN","XWBM2MC",90,0)
 N ER,ERX,GL
"RTN","XWBM2MC",91,0)
 I '$D(RES) S RES="" ;*p34-make sure RES is defined.
"RTN","XWBM2MC",92,0)
 I '$D(RPCNAM) D  Q 0  ;*p34-error if RPCNAM not defined.
"RTN","XWBM2MC",93,0)
 .I $G(RES)'="" S @RES="Pass in NULL for RPCNAM."
"RTN","XWBM2MC",94,0)
 .I $G(RES)="" S ^TMP("XWBM2MRPC",$J,"RESULTS",1)="Pass in NULL for RPCNAM."
"RTN","XWBM2MC",95,0)
 K ^TMP("XWBM2MRPC",$J,"RESULTS") ;Clear before run new RPC
"RTN","XWBM2MC",96,0)
 K ^TMP("XWBM2ME",$J,"ERROR","CALLRPC")
"RTN","XWBM2MC",97,0)
 I '$$ISCONT() D ERROR(5) Q 0  ;Not connected so do not run RPC
"RTN","XWBM2MC",98,0)
 D SAVDEV^%ZISUTL("XWBM2M CLIENT")
"RTN","XWBM2MC",99,0)
 D USE^%ZISUTL("XWBM2M PORT") U IO
"RTN","XWBM2MC",100,0)
 S XWBPARMS("URI")=RPCNAM
"RTN","XWBM2MC",101,0)
 S XWBCRLFL=0
"RTN","XWBM2MC",102,0)
 D REQUEST^XWBRPCC(.XWBPARMS)
"RTN","XWBM2MC",103,0)
 I XWBCRLFL D  Q 0
"RTN","XWBM2MC",104,0)
 . I $G(CLRPARMS)'=0 K XWBPARMS("PARAMS")
"RTN","XWBM2MC",105,0)
 . K RES
"RTN","XWBM2MC",106,0)
 . D USE^%ZISUTL("XWBM2M CLIENT") U IO
"RTN","XWBM2MC",107,0)
 ;
"RTN","XWBM2MC",108,0)
 ;Check if needed!!  **REM
"RTN","XWBM2MC",109,0)
 ;;IF $G(XWBPARMS("RESULTS"))="" SET XWBPARMS("RESULTS")=$NA(^TMP("XWBRPC"))
"RTN","XWBM2MC",110,0)
 ;
"RTN","XWBM2MC",111,0)
 I '$$EXECUTE^XWBVLC(.XWBPARMS) D  Q 0  ;Run RPC and place raw XML results
"RTN","XWBM2MC",112,0)
 .D ERROR(6)
"RTN","XWBM2MC",113,0)
 .D USE^%ZISUTL("XWBM2M CLIENT") U IO
"RTN","XWBM2MC",114,0)
 ;
"RTN","XWBM2MC",115,0)
 S XWBY="" I RES'="" S XWBY=RES K @($G(XWBY)) ;*p34-kill XWBY before PARSE
"RTN","XWBM2MC",116,0)
 D PARSE^XWBRPC(.XWBPARMS,XWBY)
"RTN","XWBM2MC",117,0)
 ;
"RTN","XWBM2MC",118,0)
 ;*p34-return 0 when error occurs and XWBY=error msg.
"RTN","XWBM2MC",119,0)
 I ($G(RES))'="",($G(@XWBY))="",($G(@(XWBY_"("_1_")")))="" D  Q ERX
"RTN","XWBM2MC",120,0)
 .S ER=$G(^TMP("XWBM2MVLC",$J,"XML",2))
"RTN","XWBM2MC",121,0)
 .S ERX=$S(ER["ERROR":0,ER["ERRORS":0,ER["error":0,ER["errors":0,1:1)
"RTN","XWBM2MC",122,0)
 .I 'ERX S @XWBY=ER
"RTN","XWBM2MC",123,0)
 .D USE^%ZISUTL("XWBM2M CLIENT") U IO
"RTN","XWBM2MC",124,0)
 ;When RES in not defined.
"RTN","XWBM2MC",125,0)
 I ($G(RES))="",($G(^TMP("XWBM2MRPC",$J,"RESULTS")))="",($G(^TMP("XWBM2MRPC",$J,"RESULTS",1)))="" D  Q ERX
"RTN","XWBM2MC",126,0)
 .S ER=$G(^TMP("XWBM2MVLC",$J,"XML",2))
"RTN","XWBM2MC",127,0)
 .S ERX=$S(ER["ERROR":0,ER["ERRORS":0,ER["error":0,ER["errors":0,1:1)
"RTN","XWBM2MC",128,0)
 .I 'ERX S ^TMP("XWBM2MRPC",$J,"RESULTS",1)=ER
"RTN","XWBM2MC",129,0)
 .D USE^%ZISUTL("XWBM2M CLIENT") U IO
"RTN","XWBM2MC",130,0)
 ;
"RTN","XWBM2MC",131,0)
 I $G(CLRPARMS)'=0 K XWBPARMS("PARAMS") ;Default is to clear
"RTN","XWBM2MC",132,0)
 D USE^%ZISUTL("XWBM2M CLIENT") U IO
"RTN","XWBM2MC",133,0)
 Q 1
"RTN","XWBM2MC",134,0)
 ;
"RTN","XWBM2MC",135,0)
CLOSE() ;Close connection
"RTN","XWBM2MC",136,0)
 I '$$ISCONT() D ERROR(5) Q 0  ;Not connected
"RTN","XWBM2MC",137,0)
 D SAVDEV^%ZISUTL("XWBM2M CLIENT")
"RTN","XWBM2MC",138,0)
 D USE^%ZISUTL("XWBM2M PORT") U IO
"RTN","XWBM2MC",139,0)
 D CLOSE^XWBRL
"RTN","XWBM2MC",140,0)
 D RMDEV^%ZISUTL("XWBM2M PORT")
"RTN","XWBM2MC",141,0)
 D CLEAN
"RTN","XWBM2MC",142,0)
 S ^TMP("XWBM2M",$J,"CONNECTED")=0
"RTN","XWBM2MC",143,0)
 Q 1
"RTN","XWBM2MC",144,0)
 ;
"RTN","XWBM2MC",145,0)
CLEAN ;Clean up
"RTN","XWBM2MC",146,0)
 ;*p34-kills entry for current context in ^TMP("XWBM2M",$J)
"RTN","XWBM2MC",147,0)
 ;
"RTN","XWBM2MC",148,0)
 I '$G(XWBDBUG) K XWBPARMS
"RTN","XWBM2MC",149,0)
 K ^TMP("XWBM2M",$J),^TMP("XWBM2MRPC",$J),^TMP("XWBM2MVLC",$J)
"RTN","XWBM2MC",150,0)
 K ^TMP("XWBM2MRL"),^TMP("XWBM2ML",$J),^TMP("XWBVLL")
"RTN","XWBM2MC",151,0)
 K XWBTDEV,XWBTID,XWBVER,XWBCBK,XWBFIRST,XWBTO,XWBQUIT,XWBREAD
"RTN","XWBM2MC",152,0)
 K XWBRL,XWBROOT,XWBSTOP,XWBX,XWBY,XWBYX,XWBREQ,XWBCOK
"RTN","XWBM2MC",153,0)
 K XWBCLRFL
"RTN","XWBM2MC",154,0)
 Q
"RTN","XWBM2MC",155,0)
 ;
"RTN","XWBM2MC",156,0)
SIGNON() ;
"RTN","XWBM2MC",157,0)
 ;Encrpt AV before sending with RPC
"RTN","XWBM2MC",158,0)
 N XWBPARMS,XWBY
"RTN","XWBM2MC",159,0)
 K XWBPARMS
"RTN","XWBM2MC",160,0)
 S XWBPARMS("URI")="XUS SIGNON SETUP"
"RTN","XWBM2MC",161,0)
 S XWBCRLFL=0
"RTN","XWBM2MC",162,0)
 D REQUEST^XWBRPCC(.XWBPARMS)
"RTN","XWBM2MC",163,0)
 I XWBCRLFL Q 0
"RTN","XWBM2MC",164,0)
 ;
"RTN","XWBM2MC",165,0)
 ;Check if needed!!  **REM
"RTN","XWBM2MC",166,0)
 ;;IF $G(XWBPARMS("RESULTS"))="" SET XWBPARMS("RESULTS")=$NA(^TMP("XWBRPC",$J,"XML"))
"RTN","XWBM2MC",167,0)
 ;
"RTN","XWBM2MC",168,0)
 I '$$EXECUTE^XWBVLC(.XWBPARMS) Q 0 ;Run RPC and place raw XML results in ^TMP("XWBM2MVLC"
"RTN","XWBM2MC",169,0)
 S XWBY="" D PARSE^XWBRPC(.XWBPARMS,XWBY) ;Parse out raw XML and place results in ^TMP("XWBM2MRPC"
"RTN","XWBM2MC",170,0)
 Q 1
"RTN","XWBM2MC",171,0)
 ;
"RTN","XWBM2MC",172,0)
VALIDAV(AV) ;Check AV code
"RTN","XWBM2MC",173,0)
 K XWBPARMS
"RTN","XWBM2MC",174,0)
 S AV=$$ENCRYP^XUSRB1(AV) ;Encrypt access/verify codes
"RTN","XWBM2MC",175,0)
 D PRE
"RTN","XWBM2MC",176,0)
 ;
"RTN","XWBM2MC",177,0)
 ; -String parameter type
"RTN","XWBM2MC",178,0)
 S XWBPARMS("PARAMS",1,"TYPE")="STRING"
"RTN","XWBM2MC",179,0)
 ;;S XWBPARMS("PARAMS",1,"VALUE")=$$CHARCHK^XWBUTL(AV)
"RTN","XWBM2MC",180,0)
 S XWBPARMS("PARAMS",1,"VALUE")=AV
"RTN","XWBM2MC",181,0)
 S XWBPARMS("URI")="XUS AV CODE"
"RTN","XWBM2MC",182,0)
 S XWBCRLFL=0
"RTN","XWBM2MC",183,0)
 D REQUEST^XWBRPCC(.XWBPARMS)
"RTN","XWBM2MC",184,0)
 I XWBCRLFL Q 0
"RTN","XWBM2MC",185,0)
 ;
"RTN","XWBM2MC",186,0)
 ;Check if needed!!  **REM
"RTN","XWBM2MC",187,0)
 ;;IF $G(XWBPARMS("RESULTS"))="" SET XWBPARMS("RESULTS")=$NA(^TMP("XWBRPC",$J,"XML"))
"RTN","XWBM2MC",188,0)
 ;
"RTN","XWBM2MC",189,0)
 I '$$EXECUTE^XWBVLC(.XWBPARMS) Q 0 ;Run RPC and place raw XML results in ^TMP("XWBM2MVLC"
"RTN","XWBM2MC",190,0)
 S XWBY="" D PARSE^XWBRPC(.XWBPARMS,XWBY) ;Parse out raw XML and place results in ^TMP("XWBM2MRPC"
"RTN","XWBM2MC",191,0)
 K XWBPARMS
"RTN","XWBM2MC",192,0)
 Q 1
"RTN","XWBM2MC",193,0)
 ;
"RTN","XWBM2MC",194,0)
GETDIV(XWBDIVG) ;*p34-gets the division for a user.
"RTN","XWBM2MC",195,0)
 ;Returns 1-succuss, 0=fail
"RTN","XWBM2MC",196,0)
 ;XWBDIVG - where the division string will be places.
"RTN","XWBM2MC",197,0)
 ;Return value for XWBDIVG:
"RTN","XWBM2MC",198,0)
 ; XWBDIVG(1)=number of divisions
"RTN","XWBM2MC",199,0)
 ; XWBDIVG(#)='ien;station name;station#' delimitated with ";"
"RTN","XWBM2MC",200,0)
 ; If a user has only 1 divison, then XWBDIVG(1)=0 because Kernel
"RTN","XWBM2MC",201,0)
 ; will automatically assign that division as a default.  Use IEN to 
"RTN","XWBM2MC",202,0)
 ; set division in $$SETDIV.
"RTN","XWBM2MC",203,0)
 N RPC,ROOT
"RTN","XWBM2MC",204,0)
 K XWBPARMS
"RTN","XWBM2MC",205,0)
 D PRE,SETPARAM(1,"STRING","DUMBY")
"RTN","XWBM2MC",206,0)
 I '$$CALLRPC^XWBM2MC("XUS DIVISION GET",XWBDIVG,0) D ERROR(10) Q 0
"RTN","XWBM2MC",207,0)
 K XWBPARMS
"RTN","XWBM2MC",208,0)
 Q 1
"RTN","XWBM2MC",209,0)
 ;
"RTN","XWBM2MC",210,0)
SETDIV(XWBDIVS) ;*p34-sets the division for a user.
"RTN","XWBM2MC",211,0)
 ;Returns 1-success, 0=fail
"RTN","XWBM2MC",212,0)
 ;XWBDIVS - Division to set. Use IEN from $$GETDIV. 
"RTN","XWBM2MC",213,0)
 N REQ
"RTN","XWBM2MC",214,0)
 K XWBPARMS
"RTN","XWBM2MC",215,0)
 S REQ="RESULT"
"RTN","XWBM2MC",216,0)
 D PRE,SETPARAM(1,"STRING",XWBDIVS)
"RTN","XWBM2MC",217,0)
 I '$$CALLRPC^XWBM2MC("XUS DIVISION SET",REQ,0) D ERROR(11) Q 0
"RTN","XWBM2MC",218,0)
 K XWBPARMS
"RTN","XWBM2MC",219,0)
 Q 1
"RTN","XWBM2MC",220,0)
 ;
"RTN","XWBM2MC",221,0)
PRE ;Prepare the needed PARMS **REM might not need PRE
"RTN","XWBM2MC",222,0)
 ;S XWBCON="DSM" ;Check if needed!!  **REM
"RTN","XWBM2MC",223,0)
 ;
"RTN","XWBM2MC",224,0)
 S XWBPARMS("MODE")="RPCBroker"
"RTN","XWBM2MC",225,0)
 Q
"RTN","XWBM2MC",226,0)
 ;
"RTN","XWBM2MC",227,0)
ERROR(CODE,STR) ;Will write error msg and related API in TMP
"RTN","XWBM2MC",228,0)
 ;*p34-new STR to append to error msg.
"RTN","XWBM2MC",229,0)
 N API,X
"RTN","XWBM2MC",230,0)
 S API=$P($T(ERRMSG+CODE),";;",3)
"RTN","XWBM2MC",231,0)
 S X=$NA(^TMP("XWBM2ME",$J,"ERROR",API)),@X=$P($T(ERRMSG+CODE),";;",2)_$G(STR) ;*p34
"RTN","XWBM2MC",232,0)
 Q
"RTN","XWBM2MC",233,0)
 ;
"RTN","XWBM2MC",234,0)
ERRMSG ; Error messages
"RTN","XWBM2MC",235,0)
 ;*p34-add 2 more error msg for GETDIV and SETDIV.
"RTN","XWBM2MC",236,0)
 ;;Could not open connection ;;CONNECT
"RTN","XWBM2MC",237,0)
 ;;XUS SIGNON SETUP RPC failed ;;SIGNON
"RTN","XWBM2MC",238,0)
 ;;XUS AV CODE RPC failed ;;SIGNON
"RTN","XWBM2MC",239,0)
 ;;Invalid user, no DUZ returned ;;SIGNON
"RTN","XWBM2MC",240,0)
 ;;There is no connection ;;CALLRPC
"RTN","XWBM2MC",241,0)
 ;;RPC could not be processed ;;CALLRPC
"RTN","XWBM2MC",242,0)
 ;;Remote Procedure Unknown ;;SERVER
"RTN","XWBM2MC",243,0)
 ;;Control Character Found ;;CALLRPC
"RTN","XWBM2MC",244,0)
 ;;Error in division return ;;CONNECT
"RTN","XWBM2MC",245,0)
 ;;Could not obtain list of valid divisions for current user ;;GETDIV
"RTN","XWBM2MC",246,0)
 ;;Could not Set active Division for current user ;;SETDIV
"RTN","XWBM2MC",247,0)
 Q
"RTN","XWBRL")
0^2^B13318398
"RTN","XWBRL",1,0)
XWBRL ;OIFO-Oakland/REM - M2M Link Methods ;05/31/2005  15:13
"RTN","XWBRL",2,0)
 ;;1.1;RPC BROKER;**28,34**;Mar 28, 1997
"RTN","XWBRL",3,0)
 ;
"RTN","XWBRL",4,0)
 QUIT
"RTN","XWBRL",5,0)
 ;
"RTN","XWBRL",6,0)
 ;p34 -make sure that XWBOS is define - WRITE.
"RTN","XWBRL",7,0)
 ;    -modified code to support the new meaning of $X in Cache 
"RTN","XWBRL",8,0)
 ;     5.x - WRITE.
"RTN","XWBRL",9,0)
 ;    -removed intervening lines that call WBF - WRITE.
"RTN","XWBRL",10,0)
 ;    -added code to include option for GTM - WBF.
"RTN","XWBRL",11,0)
 ;    -add line for XWBTCPM to read by Wally's non-call back service.
"RTN","XWBRL",12,0)
 ; 
"RTN","XWBRL",13,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRL",14,0)
 ;                    Methods for Read from and to TCP/IP Socket
"RTN","XWBRL",15,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRL",16,0)
READ(XWBROOT,XWBREAD,XWBTO,XWBFIRST,XWBSTOP) ;
"RTN","XWBRL",17,0)
 NEW X,EOT,OUT,STR,LINE,PIECES,DONE,TOFLAG,XWBCNT,XWBLEN
"RTN","XWBRL",18,0)
 SET STR="",EOT=$C(4),DONE=0,LINE=0
"RTN","XWBRL",19,0)
 ;From XWBTCPM startup, One time thing *p34
"RTN","XWBRL",20,0)
 I $D(XWBRBUF)=1 S STR=XWBRBUF,XWBTO=0,XWBFIRST=0 K XWBRBUF
"RTN","XWBRL",21,0)
 ;
"RTN","XWBRL",22,0)
 ; -- READ needs work for length checking ; This needs work!!
"RTN","XWBRL",23,0)
 FOR  READ XWBX#XWBREAD:XWBTO SET TOFLAG=$T DO CHK DO:'XWBSTOP  QUIT:DONE
"RTN","XWBRL",24,0)
 . IF $L(STR)+$L(XWBX)>400 DO ADD(STR) S STR=""
"RTN","XWBRL",25,0)
 . SET STR=STR_XWBX
"RTN","XWBRL",26,0)
 . FOR  Q:STR'[$C(10)  DO ADD($P(STR,$C(10))) SET STR=$P(STR,$C(10),2,999)
"RTN","XWBRL",27,0)
 . IF STR[EOT SET STR=$P(STR,EOT) DO ADD(STR) SET DONE=1 QUIT
"RTN","XWBRL",28,0)
 . SET PIECES=$L(STR,">")
"RTN","XWBRL",29,0)
 . IF PIECES>1 DO ADD($P(STR,">",1,PIECES-1)_">") SET STR=$P(STR,">",PIECES,999)
"RTN","XWBRL",30,0)
 ;
"RTN","XWBRL",31,0)
 QUIT 1
"RTN","XWBRL",32,0)
 ;
"RTN","XWBRL",33,0)
ADD(TXT) ; -- add new intake line
"RTN","XWBRL",34,0)
 SET LINE=LINE+1
"RTN","XWBRL",35,0)
 SET @XWBROOT@(LINE)=TXT
"RTN","XWBRL",36,0)
 QUIT
"RTN","XWBRL",37,0)
 ;
"RTN","XWBRL",38,0)
CHK ; -- check if first read and change timeout and chars to read
"RTN","XWBRL",39,0)
 IF 'TOFLAG,XWBFIRST SET XWBSTOP=1,DONE=1 QUIT  ; -- could cause small msg to not process
"RTN","XWBRL",40,0)
 SET XWBFIRST=0
"RTN","XWBRL",41,0)
 SET XWBREAD=100,XWBTO=2 ;M2M changed XWBTO=2 
"RTN","XWBRL",42,0)
 QUIT
"RTN","XWBRL",43,0)
 ;
"RTN","XWBRL",44,0)
 ;
"RTN","XWBRL",45,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRL",46,0)
 ;                      Methods for Opening and Closing Socket
"RTN","XWBRL",47,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRL",48,0)
OPEN(XWBPARMS) ; -- Open tcp/ip socket
"RTN","XWBRL",49,0)
 NEW I,POP
"RTN","XWBRL",50,0)
 SET POP=1
"RTN","XWBRL",51,0)
 DO INIT
"RTN","XWBRL",52,0)
 DO SAVDEV^%ZISUTL("XWBM2M CLIENT") ;M2M changed name
"RTN","XWBRL",53,0)
 FOR I=1:1:XWBPARMS("RETRIES") DO CALL^%ZISTCP(XWBPARMS("ADDRESS"),XWBPARMS("PORT")) QUIT:'POP
"RTN","XWBRL",54,0)
 ; Device open
"RTN","XWBRL",55,0)
 ;
"RTN","XWBRL",56,0)
 IF 'POP USE IO QUIT 1
"RTN","XWBRL",57,0)
 ; Device not open
"RTN","XWBRL",58,0)
 QUIT 0
"RTN","XWBRL",59,0)
 ;
"RTN","XWBRL",60,0)
CLOSE ; -- close tcp/ip socket
"RTN","XWBRL",61,0)
 ; -- tell server to Stop() connection
"RTN","XWBRL",62,0)
 I $G(XWBOS)="" D INIT
"RTN","XWBRL",63,0)
 DO PRE
"RTN","XWBRL",64,0)
 DO WRITE($$XMLHDR^XWBUTL()_"<vistalink type='Gov.VA.Med.Foundations.CloseSocketRequest' ></vistalink>")
"RTN","XWBRL",65,0)
 DO POST
"RTN","XWBRL",66,0)
 ;
"RTN","XWBRL",67,0)
 ; -Read results from server close string.  **M2M
"RTN","XWBRL",68,0)
 IF $G(XWBPARMS("CCLOSERESULTS"))="" SET XWBPARMS("CCLOSERESULTS")=$NA(^TMP("XWBM2MRL",$J,"XML"))
"RTN","XWBRL",69,0)
 SET XWBROOT=XWBPARMS("CCLOSERESULTS") K @XWBROOT
"RTN","XWBRL",70,0)
 SET XWBREAD=20,XWBTO=1,XWBFIRST=0,XWBSTOP=0
"RTN","XWBRL",71,0)
 SET XWBCOK=$$READ^XWBRL(XWBROOT,.XWBREAD,.XWBTO,.XWBFIRST,.XWBSTOP)
"RTN","XWBRL",72,0)
 ;
"RTN","XWBRL",73,0)
 DO FINAL
"RTN","XWBRL",74,0)
 DO CLOSE^%ZISTCP
"RTN","XWBRL",75,0)
 DO USE^%ZISUTL("XWBM2M CLIENT") ; Change name **M2M
"RTN","XWBRL",76,0)
 DO RMDEV^%ZISUTL("XWBM2M CLIENT")
"RTN","XWBRL",77,0)
 QUIT
"RTN","XWBRL",78,0)
 ;
"RTN","XWBRL",79,0)
INIT ; -- set up variables needed in tcp/ip processing
"RTN","XWBRL",80,0)
 SET XWBOS=$S(^%ZOSF("OS")["DSM":"DSM",^("OS")["UNIX":"UNIX",^("OS")["OpenM":"OpenM",1:"MSM")
"RTN","XWBRL",81,0)
 QUIT
"RTN","XWBRL",82,0)
 ;
"RTN","XWBRL",83,0)
FINAL ; -- kill variables used in tcp/ip processing
"RTN","XWBRL",84,0)
 KILL XWBOS,XWBOS,XWBPARMS,XWBPARMS
"RTN","XWBRL",85,0)
 QUIT
"RTN","XWBRL",86,0)
 ;
"RTN","XWBRL",87,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRL",88,0)
 ;                          Methods for Writing to TCP/IP Socket
"RTN","XWBRL",89,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRL",90,0)
PRE ; -- prepare socket for writing
"RTN","XWBRL",91,0)
 SET $X=0
"RTN","XWBRL",92,0)
 QUIT
"RTN","XWBRL",93,0)
 ;
"RTN","XWBRL",94,0)
WRITE(STR) ; -- Write a data string to socket
"RTN","XWBRL",95,0)
 ;*p34-removed intervening lines that call WBF.
"RTN","XWBRL",96,0)
 ;
"RTN","XWBRL",97,0)
 I $G(XWBOS)="" D INIT ;*p34-make sure XWBOS is defined.
"RTN","XWBRL",98,0)
 IF XWBOS="MSM" WRITE STR QUIT
"RTN","XWBRL",99,0)
 ; send data for DSM (requires buffer flush (!) every 511 chars)
"RTN","XWBRL",100,0)
 ; GT.M is the same as DSM. 
"RTN","XWBRL",101,0)
 ; Use an arbitrary value of 255 as the Write limit.
"RTN","XWBRL",102,0)
 ;IF XWBOS="DSM"!(XWBOS="UNIX")!(XWBOS="OpenM) next line
"RTN","XWBRL",103,0)
 ;
"RTN","XWBRL",104,0)
 ;*p34-modified write to for Cache 5 in case less then 255 char.
"RTN","XWBRL",105,0)
 F  Q:'$L(STR)  W $E(STR,1,255) D WBF S STR=$E(STR,256,99999)
"RTN","XWBRL",106,0)
 ;
"RTN","XWBRL",107,0)
 ;Old code**
"RTN","XWBRL",108,0)
 ;;I $L(STR)<255 D:($X+$L(STR))>255 WBF W STR Q
"RTN","XWBRL",109,0)
 ;;D:$X>0 WBF ;Flush what is in the buffer
"RTN","XWBRL",110,0)
 ;;F  D WBF Q:'$L(STR)  W $E(STR,1,255) S STR=$E(STR,256,$L(STR))
"RTN","XWBRL",111,0)
 ;;F  Q:'$L(STR)  W $E(STR,1,255) D WBF S STR=$E(STR,256,99999)
"RTN","XWBRL",112,0)
 ;
"RTN","XWBRL",113,0)
 QUIT
"RTN","XWBRL",114,0)
 ;
"RTN","XWBRL",115,0)
WBF ;Write Buffer Flush - W !
"RTN","XWBRL",116,0)
 ;p34-included option for GTM
"RTN","XWBRL",117,0)
 I $G(XWBOS)="" D INIT
"RTN","XWBRL",118,0)
 W @$S(XWBOS'["GTM":"!",1:"#") ;*p34
"RTN","XWBRL",119,0)
 Q
"RTN","XWBRL",120,0)
 ;
"RTN","XWBRL",121,0)
POST ; -- send eot and flush socket buffer
"RTN","XWBRL",122,0)
 DO WRITE($C(4)),WBF:$X>0
"RTN","XWBRL",123,0)
 QUIT
"RTN","XWBRPC")
0^5^B59522634
"RTN","XWBRPC",1,0)
XWBRPC ;OIFO-Oakland/REM - M2M Broker Server MRH  ;08/20/2002  12:13
"RTN","XWBRPC",2,0)
 ;;1.1;RPC BROKER;**28,34**;Mar 28, 1997
"RTN","XWBRPC",3,0)
 ;
"RTN","XWBRPC",4,0)
 QUIT
"RTN","XWBRPC",5,0)
 ;
"RTN","XWBRPC",6,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRPC",7,0)
 ;                   RPC Server: Message Request Handler (MRH)         
"RTN","XWBRPC",8,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRPC",9,0)
 ;
"RTN","XWBRPC",10,0)
 ;p34 -added $$CHARCHK^XWBUTL before writing to WRITE^XWBRL to escape CR - PROCESS.
"RTN","XWBRPC",11,0)
 ;    -remove $C(13). CR were not being stripped out in result - PROCESS.
"RTN","XWBRPC",12,0)
 ;
"RTN","XWBRPC",13,0)
 ; 
"RTN","XWBRPC",14,0)
EN(XWBDATA) ; -- handle parsed messages request
"RTN","XWBRPC",15,0)
 NEW RPC0,RPCURI,RPCIEN,TAG,ROU,METHSIG,XWBR
"RTN","XWBRPC",16,0)
 ;
"RTN","XWBRPC",17,0)
 IF $G(XWBDATA("URI"))="" DO  GOTO ENQ
"RTN","XWBRPC",18,0)
 . DO ERROR(1,"NONE","No Remote Procedure Specified.")
"RTN","XWBRPC",19,0)
 ;
"RTN","XWBRPC",20,0)
 SET RPCURI=XWBDATA("URI")
"RTN","XWBRPC",21,0)
 ;
"RTN","XWBRPC",22,0)
 SET U="^"
"RTN","XWBRPC",23,0)
 ;May want to build/call common broker api for RPC lookup.  See XWBBRK
"RTN","XWBRPC",24,0)
 SET RPCIEN=$O(^XWB(8994,"B",RPCURI,""))
"RTN","XWBRPC",25,0)
 IF RPCIEN'>0 DO  GOTO ENQ
"RTN","XWBRPC",26,0)
 . DO ERROR(2,RPCURI,"Remote Procedure Unknown:  "_RPCURI_" cannot be found.")
"RTN","XWBRPC",27,0)
 .D ERROR^XWBM2MC(7) ;Write error in TMP **M2M
"RTN","XWBRPC",28,0)
 ;
"RTN","XWBRPC",29,0)
 SET RPC0=$GET(^XWB(8994,RPCIEN,0))
"RTN","XWBRPC",30,0)
 IF RPC0="" DO  GOTO ENQ
"RTN","XWBRPC",31,0)
 . DO ERROR(3,RPCURI,"Remote Procedure Blank: '"_RPCURI_"' contains no information.")
"RTN","XWBRPC",32,0)
 ;
"RTN","XWBRPC",33,0)
 SET RPCURI=$P(RPC0,U)
"RTN","XWBRPC",34,0)
 SET TAG=$P(RPC0,U,2)
"RTN","XWBRPC",35,0)
 SET ROU=$P(RPC0,U,3)
"RTN","XWBRPC",36,0)
 ;
"RTN","XWBRPC",37,0)
 ; -- check inactive flag
"RTN","XWBRPC",38,0)
 IF $P(RPC0,U,6)=1!($P(RPC0,U,6)=2) DO  GOTO ENQ
"RTN","XWBRPC",39,0)
 . DO ERROR(4,RPCURI,"Remote Procedure InActive: '"_RPCURI_"' cannot be run at this time.")
"RTN","XWBRPC",40,0)
 ;
"RTN","XWBRPC",41,0)
 SET XWBPTYPE=$P(RPC0,U,4)
"RTN","XWBRPC",42,0)
 SET XWBWRAP=$P(RPC0,U,8)
"RTN","XWBRPC",43,0)
 ;
"RTN","XWBRPC",44,0)
 ; -- build method signature and call rpc
"RTN","XWBRPC",45,0)
 SET METHSIG=TAG_"^"_ROU_"(.XWBR"_$G(XWBDATA("PARAMS"))_")"
"RTN","XWBRPC",46,0)
 ;
"RTN","XWBRPC",47,0)
 I $G(XWBDEBUG) D LOG(METHSIG)
"RTN","XWBRPC",48,0)
 ;See that the NULL device is current
"RTN","XWBRPC",49,0)
 DO @METHSIG
"RTN","XWBRPC",50,0)
 ;
"RTN","XWBRPC",51,0)
 ; -- send results
"RTN","XWBRPC",52,0)
 D USE^%ZISUTL("XWBM2M SERVER") U IO ;**M2M use server IO 
"RTN","XWBRPC",53,0)
 ;
"RTN","XWBRPC",54,0)
 I $G(XWBDEBUG) D LOG(.XWBR)
"RTN","XWBRPC",55,0)
 DO SEND(.XWBR)
"RTN","XWBRPC",56,0)
 ;
"RTN","XWBRPC",57,0)
ENQ ; -- end message handler
"RTN","XWBRPC",58,0)
 DO CLEAN
"RTN","XWBRPC",59,0)
 ;
"RTN","XWBRPC",60,0)
 QUIT
"RTN","XWBRPC",61,0)
 ;
"RTN","XWBRPC",62,0)
CLEAN ; -- clean up message handler environment
"RTN","XWBRPC",63,0)
 NEW POS
"RTN","XWBRPC",64,0)
 ; -- kill parameters
"RTN","XWBRPC",65,0)
 SET POS=0
"RTN","XWBRPC",66,0)
 FOR  S POS=$O(XWBDATA("PARAMS",POS)) Q:'POS  K @XWBDATA("PARAMS",POS)
"RTN","XWBRPC",67,0)
 Q
"RTN","XWBRPC",68,0)
 ;
"RTN","XWBRPC",69,0)
SEND(XWBR) ; -- stream rpc data to client
"RTN","XWBRPC",70,0)
 NEW XWBFMT,XWBFILL
"RTN","XWBRPC",71,0)
 SET XWBFMT=$$GETFMT()
"RTN","XWBRPC",72,0)
 ; -- prepare socket for writing
"RTN","XWBRPC",73,0)
 DO PRE^XWBRL
"RTN","XWBRPC",74,0)
 ; -- initialize
"RTN","XWBRPC",75,0)
 DO WRITE^XWBRL($$XMLHDR^XWBUTL())
"RTN","XWBRPC",76,0)
 ;DO DOCTYPE
"RTN","XWBRPC",77,0)
 DO WRITE^XWBRL("<vistalink type=""Gov.VA.Med.RPC.Response"" ><results type="""_XWBFMT_""" ><![CDATA[")
"RTN","XWBRPC",78,0)
 ; -- results
"RTN","XWBRPC",79,0)
 DO PROCESS
"RTN","XWBRPC",80,0)
 ; -- finalize
"RTN","XWBRPC",81,0)
 DO WRITE^XWBRL("]]></results></vistalink>")
"RTN","XWBRPC",82,0)
 ; -- send eot and flush buffer
"RTN","XWBRPC",83,0)
 DO POST^XWBRL
"RTN","XWBRPC",84,0)
 ;
"RTN","XWBRPC",85,0)
 QUIT
"RTN","XWBRPC",86,0)
 ;
"RTN","XWBRPC",87,0)
DOCTYPE ;
"RTN","XWBRPC",88,0)
 DO WRITE^XWBRL("<!DOCTYPE vistalink [<!ELEMENT vistalink (results) ><!ELEMENT results (#PCDATA)><!ATTLIST vistalink type CDATA ""Gov.VA.Med.RPC.Response"" ><!ATTLIST results type (array|string) >]>")
"RTN","XWBRPC",89,0)
 QUIT
"RTN","XWBRPC",90,0)
 ;
"RTN","XWBRPC",91,0)
GETFMT() ; -- determine response format type
"RTN","XWBRPC",92,0)
 IF XWBPTYPE=1!(XWBPTYPE=5)!(XWBPTYPE=6) QUIT "string"
"RTN","XWBRPC",93,0)
 IF XWBPTYPE=2 QUIT "array"
"RTN","XWBRPC",94,0)
 ;
"RTN","XWBRPC",95,0)
 QUIT $S(XWBWRAP:"array",1:"string")
"RTN","XWBRPC",96,0)
 ;
"RTN","XWBRPC",97,0)
PROCESS ; -- send the real results
"RTN","XWBRPC",98,0)
 NEW I,T,DEL,V
"RTN","XWBRPC",99,0)
 ;
"RTN","XWBRPC",100,0)
 ;*p34-Remove $C(13). CR were not being stripped out in results to escape CR.
"RTN","XWBRPC",101,0)
 ;S DEL=$S(XWBMODE="RPCBroker":$C(13,10),1:$C(10))
"RTN","XWBRPC",102,0)
 S DEL=$S(XWBMODE="RPCBroker":$C(10),1:$C(10))
"RTN","XWBRPC",103,0)
 ;
"RTN","XWBRPC",104,0)
 ;*p34-When write XWBR, go thru $$CHARCHK^XWBUTL first.
"RTN","XWBRPC",105,0)
 ; -- single value
"RTN","XWBRPC",106,0)
 IF XWBPTYPE=1 SET XWBR=$G(XWBR) DO WRITE^XWBRL($$CHARCHK^XWBUTL($G(XWBR))) QUIT
"RTN","XWBRPC",107,0)
 ; -- table delimited by CR+LF - ARRAY
"RTN","XWBRPC",108,0)
 IF XWBPTYPE=2 DO  QUIT
"RTN","XWBRPC",109,0)
 . SET I="" FOR  SET I=$O(XWBR(I)) QUIT:I=""  DO WRITE^XWBRL($$CHARCHK^XWBUTL($G(XWBR(I)))),WRITE^XWBRL(DEL)
"RTN","XWBRPC",110,0)
 ; -- word processing
"RTN","XWBRPC",111,0)
 IF XWBPTYPE=3 DO  QUIT
"RTN","XWBRPC",112,0)
 . SET I="" FOR  SET I=$O(XWBR(I)) QUIT:I=""  DO WRITE^XWBRL($$CHARCHK^XWBUTL($G(XWBR(I)))) DO:XWBWRAP WRITE^XWBRL(DEL)
"RTN","XWBRPC",113,0)
 ; -- global array
"RTN","XWBRPC",114,0)
 IF XWBPTYPE=4 DO  QUIT
"RTN","XWBRPC",115,0)
 . SET I=$G(XWBR) QUIT:I=""  SET T=$E(I,1,$L(I)-1)
"RTN","XWBRPC",116,0)
 . I $D(@I)>10 S V=@I D WRITE^XWBRL($$CHARCHK^XWBUTL($G(V)))
"RTN","XWBRPC",117,0)
 . FOR  SET I=$Q(@I) QUIT:I=""!(I'[T)  S V=@I D WRITE^XWBRL($$CHARCHK^XWBUTL($G(V))) D:XWBWRAP&(V'=DEL) WRITE^XWBRL(DEL)
"RTN","XWBRPC",118,0)
 . IF $D(@XWBR) KILL @XWBR
"RTN","XWBRPC",119,0)
 ; -- global instance
"RTN","XWBRPC",120,0)
 IF XWBPTYPE=5 S XWBR=$G(@XWBR) D WRITE^XWBRL($$CHARCHK^XWBUTL($G(XWBR))) QUIT
"RTN","XWBRPC",121,0)
 ; -- variable length records only good up to 255 char)
"RTN","XWBRPC",122,0)
 IF XWBPTYPE=6 SET I="" FOR  SET I=$O(XWBR(I)) QUIT:I=""  DO WRITE^XWBRL($C($L(XWBR(I)))),WRITE^XWBRL(XWBR(I))
"RTN","XWBRPC",123,0)
 QUIT
"RTN","XWBRPC",124,0)
 ;
"RTN","XWBRPC",125,0)
ERROR(CODE,RPCURI,MSG) ; -- send rpc application error
"RTN","XWBRPC",126,0)
 DO PRE^XWBRL
"RTN","XWBRPC",127,0)
 DO WRITE^XWBRL($$XMLHDR^XWBUTL())
"RTN","XWBRPC",128,0)
 DO WRITE^XWBRL("<vistalink type=""VA.RPC.Error"" >")
"RTN","XWBRPC",129,0)
 DO WRITE^XWBRL("<errors>")
"RTN","XWBRPC",130,0)
 DO WRITE^XWBRL("<error code="""_CODE_""" uri="""_$G(RPCURI)_""" >")
"RTN","XWBRPC",131,0)
 DO WRITE^XWBRL("<msg>"_$G(MSG)_"</msg>")
"RTN","XWBRPC",132,0)
 DO WRITE^XWBRL("</error>")
"RTN","XWBRPC",133,0)
 DO WRITE^XWBRL("</errors>")
"RTN","XWBRPC",134,0)
 DO WRITE^XWBRL("</vistalink>")
"RTN","XWBRPC",135,0)
 ; -- send eot and flush buffer
"RTN","XWBRPC",136,0)
 DO POST^XWBRL
"RTN","XWBRPC",137,0)
 QUIT
"RTN","XWBRPC",138,0)
 ;
"RTN","XWBRPC",139,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRPC",140,0)
 ;             RPC Server: Request Message XML SAX Parser Callbacks         
"RTN","XWBRPC",141,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRPC",142,0)
ELEST(ELE,ATR) ; -- element start event handler
"RTN","XWBRPC",143,0)
 IF ELE="vistalink" KILL XWBSESS,XWBPARAM,XWBPN,XWBPTYPE QUIT
"RTN","XWBRPC",144,0)
 ;
"RTN","XWBRPC",145,0)
 IF ELE="rpc" SET XWBDATA("URI")=$$ESC^XWBRMX($G(ATR("uri"),"##Unkown RPC##")) QUIT
"RTN","XWBRPC",146,0)
 ;
"RTN","XWBRPC",147,0)
 IF ELE="param" DO  QUIT
"RTN","XWBRPC",148,0)
 . SET XWBPARAM=1
"RTN","XWBRPC",149,0)
 . SET XWBPN="XWBP"_ATR("position")
"RTN","XWBRPC",150,0)
 . SET XWBDATA("PARAMS",ATR("position"))=XWBPN
"RTN","XWBRPC",151,0)
 . SET XWBPTYPE=ATR("type")
"RTN","XWBRPC",152,0)
 . S XWBCHRST="" ;To accumulate char
"RTN","XWBRPC",153,0)
 ;
"RTN","XWBRPC",154,0)
 IF ELE="index" DO  QUIT
"RTN","XWBRPC",155,0)
 . ;SET @XWBPN@($$ESC^XWBRMX(ATR("name")))=$$ESC^XWBRMX(ATR("value"))
"RTN","XWBRPC",156,0)
 . S XWBPN("name")=$$ESC^XWBRMX(ATR("name")) ;rwf
"RTN","XWBRPC",157,0)
 . S XWBCHRST=""
"RTN","XWBRPC",158,0)
 ;
"RTN","XWBRPC",159,0)
 QUIT
"RTN","XWBRPC",160,0)
 ;
"RTN","XWBRPC",161,0)
ELEND(ELE) ; -- element end event handler
"RTN","XWBRPC",162,0)
 IF ELE="vistalink" KILL XWBPOS,XWBSESS,XWBPARAM,XWBPN,XWBPTYPE,XWBCHRST QUIT
"RTN","XWBRPC",163,0)
 ;
"RTN","XWBRPC",164,0)
 IF ELE="params" DO  QUIT
"RTN","XWBRPC",165,0)
 . NEW POS,PARAMS
"RTN","XWBRPC",166,0)
 . SET PARAMS="",POS=0
"RTN","XWBRPC",167,0)
 . FOR  SET POS=$O(XWBDATA("PARAMS",POS)) Q:'POS  SET PARAMS=PARAMS_",."_XWBDATA("PARAMS",POS)
"RTN","XWBRPC",168,0)
 . SET XWBDATA("PARAMS")=PARAMS
"RTN","XWBRPC",169,0)
 ;
"RTN","XWBRPC",170,0)
 IF ELE="param" D  Q
"RTN","XWBRPC",171,0)
 . I $G(XWBDEBUG),$D(XWBPN),$D(@XWBPN) D LOG(.@XWBPN)
"RTN","XWBRPC",172,0)
 . KILL XWBPARAM,XWBCHRST
"RTN","XWBRPC",173,0)
 ;
"RTN","XWBRPC",174,0)
 QUIT
"RTN","XWBRPC",175,0)
 ;
"RTN","XWBRPC",176,0)
 ;This can be called more than once for one TEXT string.
"RTN","XWBRPC",177,0)
CHR(TEXT) ; -- character value event handler <tag>TEXT</tag)
"RTN","XWBRPC",178,0)
 ;
"RTN","XWBRPC",179,0)
 IF $G(XWBPARAM) DO
"RTN","XWBRPC",180,0)
 . ;What to do if string gets too long?
"RTN","XWBRPC",181,0)
 . ;IF XWBPTYPE="string" SET XWBCHRST=XWBCHRST_$$ESC^XWBRMX(TEXT),@XWBPN=XWBCHRST QUIT
"RTN","XWBRPC",182,0)
 . IF XWBPTYPE="string" SET XWBCHRST=XWBCHRST_TEXT,@XWBPN=XWBCHRST  QUIT
"RTN","XWBRPC",183,0)
 . ;IF XWBPTYPE="ref" SET @XWBPN=$G(@$$ESC^XWBRMX(TEXT)) QUIT
"RTN","XWBRPC",184,0)
 . IF XWBPTYPE="ref" SET XWBCHRST=XWBCHRST_TEXT,@XWBPN=@XWBCHRST QUIT
"RTN","XWBRPC",185,0)
 . I XWBPTYPE="array" S XWBCHRST=XWBCHRST_TEXT,@XWBPN@(XWBPN("name"))=XWBCHRST Q  ;rwf
"RTN","XWBRPC",186,0)
 QUIT
"RTN","XWBRPC",187,0)
 ;
"RTN","XWBRPC",188,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRPC",189,0)
 ;            Parse Results of Successful Legacy RPC Request
"RTN","XWBRPC",190,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRPC",191,0)
 ;              
"RTN","XWBRPC",192,0)
 ; [Public/Supported Method]
"RTN","XWBRPC",193,0)
PARSE(XWBPARMS,XWBY) ; -- parse legacy rpc results ; uses SAX parser
"RTN","XWBRPC",194,0)
 NEW XWBCHK,XWBOPT,XWBTYPE,XWBCNT
"RTN","XWBRPC",195,0)
 ;
"RTN","XWBRPC",196,0)
 ;**M2M Result will go here.
"RTN","XWBRPC",197,0)
 I XWBY="" D
"RTN","XWBRPC",198,0)
 .IF $G(XWBY)="" SET XWBY=$NA(^TMP("XWBM2MRPC",$J,"RESULTS"))
"RTN","XWBRPC",199,0)
 .SET XWBYX=XWBY
"RTN","XWBRPC",200,0)
 .KILL @XWBYX
"RTN","XWBRPC",201,0)
 ;
"RTN","XWBRPC",202,0)
 DO SET
"RTN","XWBRPC",203,0)
 SET XWBOPT=""
"RTN","XWBRPC",204,0)
 DO EN^MXMLPRSE(XWBPARMS("RESULTS"),.XWBCBK,.XWBOPT)
"RTN","XWBRPC",205,0)
 Q
"RTN","XWBRPC",206,0)
 ;
"RTN","XWBRPC",207,0)
SET ; -- set the event interface entry points ;
"RTN","XWBRPC",208,0)
 SET XWBCBK("STARTELEMENT")="RESELEST^XWBRPC"
"RTN","XWBRPC",209,0)
 SET XWBCBK("ENDELEMENT")="RESELEND^XWBRPC"
"RTN","XWBRPC",210,0)
 SET XWBCBK("CHARACTERS")="RESCHR^XWBRPC"
"RTN","XWBRPC",211,0)
 QUIT
"RTN","XWBRPC",212,0)
 ;
"RTN","XWBRPC",213,0)
RESELEST(ELE,ATR) ; -- element start event handler
"RTN","XWBRPC",214,0)
 IF ELE="results" SET XWBTYPE=$G(ATR("type")),XWBCNT=0
"RTN","XWBRPC",215,0)
 QUIT
"RTN","XWBRPC",216,0)
 ;
"RTN","XWBRPC",217,0)
RESELEND(ELE) ; -- element end event handler
"RTN","XWBRPC",218,0)
 KILL XWBCNT,XWBTYPE
"RTN","XWBRPC",219,0)
 QUIT
"RTN","XWBRPC",220,0)
 ;
"RTN","XWBRPC",221,0)
RESCHR(TEXT) ; -- character value event handler
"RTN","XWBRPC",222,0)
 QUIT:$G(XWBTYPE)=""
"RTN","XWBRPC",223,0)
 QUIT:'$L(TEXT)  ; -- Sometimes sends in empty string
"RTN","XWBRPC",224,0)
 ;
"RTN","XWBRPC",225,0)
 IF XWBCNT=0,TEXT=$C(10) QUIT  ; -- bug in parser? always starts with $C(10)
"RTN","XWBRPC",226,0)
 ;
"RTN","XWBRPC",227,0)
 IF XWBTYPE="string" DO  QUIT
"RTN","XWBRPC",228,0)
 . SET XWBCNT=XWBCNT+1
"RTN","XWBRPC",229,0)
 . SET @XWBY@(XWBCNT)=TEXT
"RTN","XWBRPC",230,0)
 ;
"RTN","XWBRPC",231,0)
 IF XWBTYPE="array" DO
"RTN","XWBRPC",232,0)
 . SET XWBCNT=XWBCNT+1
"RTN","XWBRPC",233,0)
 . SET @XWBY@(XWBCNT)=$P(TEXT,$C(10))
"RTN","XWBRPC",234,0)
 QUIT
"RTN","XWBRPC",235,0)
 ;
"RTN","XWBRPC",236,0)
PARSEX(XWBPARMS,XWBY) ; -- parse legacy rpc results ; uses DOM parser
"RTN","XWBRPC",237,0)
 NEW XWBDOM
"RTN","XWBRPC",238,0)
 SET XWBDOM=$$EN^MXMLDOM(XWBPARMS("RESULTS"),"")
"RTN","XWBRPC",239,0)
 DO TEXT^MXMLDOM(XWBDOM,2,XWBY)
"RTN","XWBRPC",240,0)
 DO DELETE^MXMLDOM(XWBDOM)
"RTN","XWBRPC",241,0)
 QUIT
"RTN","XWBRPC",242,0)
 ;
"RTN","XWBRPC",243,0)
LOG(MSG) ;Debug log
"RTN","XWBRPC",244,0)
 N CNT
"RTN","XWBRPC",245,0)
 S CNT=$G(^TMP("XWBM2ML",$J))+1,^($J)=CNT
"RTN","XWBRPC",246,0)
 M ^TMP("XWBM2ML",$J,CNT)=MSG
"RTN","XWBRPC",247,0)
 Q
"RTN","XWBRPC",248,0)
 ;
"RTN","XWBRPC",249,0)
 ; -------------------------------------------------------------------
"RTN","XWBRPC",250,0)
 ;                   Response Format Documentation
"RTN","XWBRPC",251,0)
 ; -------------------------------------------------------------------
"RTN","XWBRPC",252,0)
 ; 
"RTN","XWBRPC",253,0)
 ;                   
"RTN","XWBRPC",254,0)
 ; [ Sample XML produced by a successful call of EN^XWBRPC(.XWBPARMS). 
"RTN","XWBRPC",255,0)
 ;   SEND^XWBRPC does the actual work to produce response.             ]
"RTN","XWBRPC",256,0)
 ; 
"RTN","XWBRPC",257,0)
 ; <?xml version="1.0" encoding="utf-8" ?>
"RTN","XWBRPC",258,0)
 ; <vistalink type="Gov.VA.Med.RPC.Response" >
"RTN","XWBRPC",259,0)
 ;     <results type="array" >
"RTN","XWBRPC",260,0)
 ;         <![CDATA[4261;;2961001.08^2^274^166^105^^2961001.1123^1^^9^2^8^10^^^^^^^10G1-ALN
"RTN","XWBRPC",261,0)
 ;         4270;;2961002.08^2^274^166^112^^^1^^9^2^8^10^^^^^^^10G8-ALN
"RTN","XWBRPC",262,0)
 ;         4274;;2961003.08^2^274^166^116^^^1^^9^2^8^10^^^^^^^10GD-ALN
"RTN","XWBRPC",263,0)
 ;         4340;;2961117.08^2^274^166^182^^2961118.1425^1^^9^2^8^10^^^^^^^10K0-ALN
"RTN","XWBRPC",264,0)
 ;         4342;;2961108.13^2^108^207^183^^2961118.1546^1^^9^2^8^10^^^^^^^10K2-ALN
"RTN","XWBRPC",265,0)
 ;         6394;;3000607.084^2^165^68^6479^^3000622.13^1^^9^1^8^10^^^^^^^197M-ALN]]>
"RTN","XWBRPC",266,0)
 ;     </results>
"RTN","XWBRPC",267,0)
 ; </vistalink>
"RTN","XWBRPC",268,0)
 ; 
"RTN","XWBRPC",269,0)
 ; -------------------------------------------------------------------
"RTN","XWBRPC",270,0)
 ; 
"RTN","XWBRPC",271,0)
 ; [ Sample XML produced by a unsuccessful call of EN^XWBRPC(.XWBPARMS). 
"RTN","XWBRPC",272,0)
 ;   ERROR^XWBRPC does the actual work to produce response.             ]
"RTN","XWBRPC",273,0)
 ; 
"RTN","XWBRPC",274,0)
 ; <?xml version="1.0" encoding="utf-8" ?>
"RTN","XWBRPC",275,0)
 ; <vistalink type="Gov.VA..Med.RPC.Error" >
"RTN","XWBRPC",276,0)
 ;    <errors>
"RTN","XWBRPC",277,0)
 ;       <error code="2" uri="XWB BAD NAME" >
"RTN","XWBRPC",278,0)
 ;           <msg>
"RTN","XWBRPC",279,0)
 ;              Remote Procedure Unknown: 'XWB BAD NAME' cannot be found.
"RTN","XWBRPC",280,0)
 ;           </msg>
"RTN","XWBRPC",281,0)
 ;       </error>
"RTN","XWBRPC",282,0)
 ;    </errors>
"RTN","XWBRPC",283,0)
 ; </vistalink>
"RTN","XWBRPC",284,0)
 ; 
"RTN","XWBRPC",285,0)
 ; -------------------------------------------------------------------
"RTN","XWBRPC",286,0)
 ; 
"RTN","XWBRPCC")
0^6^B18044017
"RTN","XWBRPCC",1,0)
XWBRPCC ;OIFO-Oakland/REM - M2M Broker Client Utilities  ;06/05/2002  17:25
"RTN","XWBRPCC",2,0)
 ;;1.1;RPC BROKER;**28,34**;Mar 28, 1997
"RTN","XWBRPCC",3,0)
 ;
"RTN","XWBRPCC",4,0)
 QUIT
"RTN","XWBRPCC",5,0)
 ;
"RTN","XWBRPCC",6,0)
 ;p34 - added line to set "MODE" like in PRE^XWBM2MC. No longer will it
"RTN","XWBRPCC",7,0)
 ;      be set in PRE^XWBM2MC - REQUEST.
"RTN","XWBRPCC",8,0)
 ;
"RTN","XWBRPCC",9,0)
 ; -------------------------------------------------------------------
"RTN","XWBRPCC",10,0)
 ;                  RPC Client:  Methods Calls
"RTN","XWBRPCC",11,0)
 ; -------------------------------------------------------------------
"RTN","XWBRPCC",12,0)
 ; 
"RTN","XWBRPCC",13,0)
 ; [Public/Supported Method]
"RTN","XWBRPCC",14,0)
EXECUTE(XWBPARMS) ; -- execute rpc call
"RTN","XWBRPCC",15,0)
 ;
"RTN","XWBRPCC",16,0)
 ; -- validate parameters passed
"RTN","XWBRPCC",17,0)
 IF '$$VALIDATE(.XWBPARMS) QUIT 0
"RTN","XWBRPCC",18,0)
 ;
"RTN","XWBRPCC",19,0)
 ; -- call method to build request from parameters array
"RTN","XWBRPCC",20,0)
 DO REQUEST(.XWBPARMS)
"RTN","XWBRPCC",21,0)
 IF $G(XWBPARMS("RESULTS"))="" SET XWBPARMS("RESULTS")=$NA(^TMP("XWBRPC",$J,"XML"))
"RTN","XWBRPCC",22,0)
 QUIT $$EXECUTE^XWBVLC(.XWBPARMS)
"RTN","XWBRPCC",23,0)
 ;
"RTN","XWBRPCC",24,0)
VALIDATE(XWBPARMS) ; -- validate parameters sent in
"RTN","XWBRPCC",25,0)
 ; // TODO: Do checks and build validate error message
"RTN","XWBRPCC",26,0)
 QUIT 1
"RTN","XWBRPCC",27,0)
 ;
"RTN","XWBRPCC",28,0)
REQUEST(XWBPARMS) ; -- build XML request
"RTN","XWBRPCC",29,0)
 ;
"RTN","XWBRPCC",30,0)
 NEW XWBLINE,XWBPI,PTYPE
"RTN","XWBRPCC",31,0)
 SET XWBLINE=0
"RTN","XWBRPCC",32,0)
 SET XWBPARMS("MESSAGE TYPE")="Gov.VA.Med.RPC.Request"
"RTN","XWBRPCC",33,0)
 ;
"RTN","XWBRPCC",34,0)
 S XWBPARMS("MODE")="RPCBroker" ;*p34-added line to set "MODE" instead of in PRE^XWBM2MC.
"RTN","XWBRPCC",35,0)
 ;SET XWBPARMS("MODE")="single call" ;Comment out for **M2M
"RTN","XWBRPCC",36,0)
 ;
"RTN","XWBRPCC",37,0)
 IF $G(XWBPARMS("REQUEST"))="" SET XWBPARMS("REQUEST")=$NA(XWBPARMS("REQUEST","XML"))
"RTN","XWBRPCC",38,0)
 SET XWBREQ=XWBPARMS("REQUEST")
"RTN","XWBRPCC",39,0)
 KILL @XWBREQ
"RTN","XWBRPCC",40,0)
 ;
"RTN","XWBRPCC",41,0)
 DO ADD($$XMLHDR^XWBUTL())
"RTN","XWBRPCC",42,0)
 ;p34-added 'broker m2m' in XML message
"RTN","XWBRPCC",43,0)
 DO ADD("<vistalink type="""_$G(XWBPARMS("MESSAGE TYPE"))_""" mode="""_$G(XWBPARMS("MODE"))_""" >")
"RTN","XWBRPCC",44,0)
 ;
"RTN","XWBRPCC",45,0)
 I $G(XWBPARMS("MODE"))'="RPCBroker" D
"RTN","XWBRPCC",46,0)
 . DO ADD("<session>")
"RTN","XWBRPCC",47,0)
 . ;
"RTN","XWBRPCC",48,0)
 . ;**M2M - don't send DUZ 
"RTN","XWBRPCC",49,0)
 . DO ADD("<duz value="""_$G(XWBPARMS("DUZ"))_""" />")
"RTN","XWBRPCC",50,0)
 . DO ADD("<security>")
"RTN","XWBRPCC",51,0)
 . ;
"RTN","XWBRPCC",52,0)
 . DO ADD("<token value="""_$G(XWBPARMS("TOKEN"))_""" />")
"RTN","XWBRPCC",53,0)
 . DO ADD("</security>")
"RTN","XWBRPCC",54,0)
 . DO ADD("</session>")
"RTN","XWBRPCC",55,0)
 . Q
"RTN","XWBRPCC",56,0)
 DO ADD("<rpc uri="""_$G(XWBPARMS("URI"))_""" method="""_$G(XWBPARMS("METHOD"))_""" >")
"RTN","XWBRPCC",57,0)
 IF $D(XWBPARMS("PARAMS"))>9 DO
"RTN","XWBRPCC",58,0)
 . DO ADD("<params>")
"RTN","XWBRPCC",59,0)
 . SET XWBPI=0
"RTN","XWBRPCC",60,0)
 . FOR  SET XWBPI=$O(XWBPARMS("PARAMS",XWBPI)) Q:'XWBPI!(XWBCRLFL)  DO
"RTN","XWBRPCC",61,0)
 . . SET PTYPE=$G(XWBPARMS("PARAMS",XWBPI,"TYPE"))
"RTN","XWBRPCC",62,0)
 . . IF PTYPE="STRING" DO STRING QUIT
"RTN","XWBRPCC",63,0)
 . . IF PTYPE="ARRAY" DO ARRAY QUIT
"RTN","XWBRPCC",64,0)
 . . IF PTYPE="REF" DO REF QUIT
"RTN","XWBRPCC",65,0)
 . DO ADD("</params>")
"RTN","XWBRPCC",66,0)
 DO ADD("</rpc>")
"RTN","XWBRPCC",67,0)
 DO ADD("</vistalink>")
"RTN","XWBRPCC",68,0)
 QUIT
"RTN","XWBRPCC",69,0)
 ;
"RTN","XWBRPCC",70,0)
STRING ;
"RTN","XWBRPCC",71,0)
 ;;DO ADD("<param type=""string"" position="""_XWBPI_""" >"_$G(XWBPARMS("PARAMS",XWBPI,"VALUE"))_"</param>")
"RTN","XWBRPCC",72,0)
 I $$CTLCHK($G(XWBPARMS("PARAMS",XWBPI,"VALUE"))) S XWBCRLFL=1 D ERROR^XWBM2MC(8) Q
"RTN","XWBRPCC",73,0)
 DO ADD("<param type=""string"" position="""_XWBPI_""" >"_$$CHARCHK^XWBUTL($G(XWBPARMS("PARAMS",XWBPI,"VALUE")))_"</param>")
"RTN","XWBRPCC",74,0)
 QUIT
"RTN","XWBRPCC",75,0)
 ;
"RTN","XWBRPCC",76,0)
ARRAY ;
"RTN","XWBRPCC",77,0)
 NEW XWBNAME
"RTN","XWBRPCC",78,0)
 DO ADD("<param type=""array"" position="""_XWBPI_""" >")
"RTN","XWBRPCC",79,0)
 DO ADD("<indices>")
"RTN","XWBRPCC",80,0)
 ;
"RTN","XWBRPCC",81,0)
 SET XWBNAME="" FOR  SET XWBNAME=$O(XWBPARMS("PARAMS",XWBPI,"VALUE",XWBNAME)) Q:XWBNAME=""  DO
"RTN","XWBRPCC",82,0)
 . ;;DO ADD("<index name="""_XWBNAME_""" value="""_$G(XWBPARMS("PARAMS",XWBPI,"VALUE",XWBNAME))_""" />")
"RTN","XWBRPCC",83,0)
 . I $$CTLCHK($G(XWBPARMS("PARAMS",XWBPI,"VALUE",XWBNAME))) S XWBCRLFL=1 D ERROR^XWBM2MC(8) Q
"RTN","XWBRPCC",84,0)
 . DO ADD("<index name="""_XWBNAME_""" >"_$$CHARCHK^XWBUTL($G(XWBPARMS("PARAMS",XWBPI,"VALUE",XWBNAME)))_"</index>")
"RTN","XWBRPCC",85,0)
 DO ADD("</indices>")
"RTN","XWBRPCC",86,0)
 DO ADD("</param>")
"RTN","XWBRPCC",87,0)
 QUIT
"RTN","XWBRPCC",88,0)
 ;
"RTN","XWBRPCC",89,0)
REF ;
"RTN","XWBRPCC",90,0)
 I $$CTLCHK($G(XWBPARMS("PARAMS",XWBPI,"VALUE"))) S XWBCRLFL=1 D ERROR^XWBM2MC(8) Q
"RTN","XWBRPCC",91,0)
 DO ADD("<param type=""ref"" position="""_XWBPI_""" >"_$$CHARCHK^XWBUTL($G(XWBPARMS("PARAMS",XWBPI,"VALUE")))_"</param>")
"RTN","XWBRPCC",92,0)
 QUIT
"RTN","XWBRPCC",93,0)
 ;
"RTN","XWBRPCC",94,0)
ADD(STR) ; -- add string to array
"RTN","XWBRPCC",95,0)
 SET XWBLINE=XWBLINE+1
"RTN","XWBRPCC",96,0)
 ;
"RTN","XWBRPCC",97,0)
 I $G(XWBDBUG) S ^REM("M2MCL","REQUEST",XWBLINE)=STR
"RTN","XWBRPCC",98,0)
 ;
"RTN","XWBRPCC",99,0)
 SET @XWBREQ@(XWBLINE)=STR
"RTN","XWBRPCC",100,0)
 QUIT
"RTN","XWBRPCC",101,0)
 ;
"RTN","XWBRPCC",102,0)
CTLCHK(STR) ;Check for control character in string.  
"RTN","XWBRPCC",103,0)
 ;        Exception are $C(10)-LF, $C(13)-CR
"RTN","XWBRPCC",104,0)
 N I,Q,X
"RTN","XWBRPCC",105,0)
 S X=0
"RTN","XWBRPCC",106,0)
 I '(STR?.E1C.E) Q X
"RTN","XWBRPCC",107,0)
 S I="" F I=1:1:$L(STR) D
"RTN","XWBRPCC",108,0)
 .S Q="" F Q=1:1:31 D  Q:X
"RTN","XWBRPCC",109,0)
 ..;I Q=10!(Q=13) Q
"RTN","XWBRPCC",110,0)
 ..;W !,"I= ",I," Q= ",Q
"RTN","XWBRPCC",111,0)
 ..I $E(STR,I)[$C(Q) S X=1 Q
"RTN","XWBRPCC",112,0)
 Q X
"RTN","XWBRPCC",113,0)
 ;
"RTN","XWBRPCC",114,0)
 ; -------------------------------------------------------------------
"RTN","XWBRPCC",115,0)
 ;                   Request Format Documentation
"RTN","XWBRPCC",116,0)
 ; -------------------------------------------------------------------
"RTN","XWBRPCC",117,0)
 ; 
"RTN","XWBRPCC",118,0)
 ; [ Parameter Array Format -->> passed to REQUEST^XWBRPCC(.XWBPARMS) ] 
"RTN","XWBRPCC",119,0)
 ; 
"RTN","XWBRPCC",120,0)
 ; -- general information
"RTN","XWBRPCC",121,0)
 ; XWBPARMS("ADDRESS")="127.0.0.1"
"RTN","XWBRPCC",122,0)
 ; XWBPARMS("ADDRESS")="152.127.1.35"
"RTN","XWBRPCC",123,0)
 ; XWBPARMS("PORT")=9800
"RTN","XWBRPCC",124,0)
 ; XWBPARMS("DUZ")=990
"RTN","XWBRPCC",125,0)
 ; XWBPARMS("TOKEN")="SOMETHING"
"RTN","XWBRPCC",126,0)
 ; XWBPARMS("RPC NAME")="SDOE LIST ENCOUNTERS FOR PAT"
"RTN","XWBRPCC",127,0)
 ;
"RTN","XWBRPCC",128,0)
 ; -- string parameter type
"RTN","XWBRPCC",129,0)
 ; XWBPARMS("PARAMS",1,"TYPE")="STRING"
"RTN","XWBRPCC",130,0)
 ; XWBPARMS("PARAMS",1,"VALUE")=2
"RTN","XWBRPCC",131,0)
 ; XWBPARMS("PARAMS",2,"TYPE")="STRING"
"RTN","XWBRPCC",132,0)
 ; XWBPARMS("PARAMS",2,"VALUE")=2961001
"RTN","XWBRPCC",133,0)
 ; XWBPARMS("PARAMS",3,"TYPE")="STRING"
"RTN","XWBRPCC",134,0)
 ; XWBPARMS("PARAMS",3,"VALUE")=3030101
"RTN","XWBRPCC",135,0)
 ;
"RTN","XWBRPCC",136,0)
 ; -- sample array parameter type
"RTN","XWBRPCC",137,0)
 ; XWBPARMS("PARAMS",4,"TYPE")="ARRAY"
"RTN","XWBRPCC",138,0)
 ; XWBPARMS("PARAMS",4,"VALUE","FNAME")="JOE"
"RTN","XWBRPCC",139,0)
 ; XWBPARMS("PARAMS",4,"VALUE","LNAME")="GOODMAN"
"RTN","XWBRPCC",140,0)
 ;                   
"RTN","XWBRPCC",141,0)
 ; -------------------------------------------------------------------
"RTN","XWBRPCC",142,0)
 ;                   
"RTN","XWBRPCC",143,0)
 ; [ Sample XML produced by calling REQUEST^XWBRPCC(.XWBPARMS) ]
"RTN","XWBRPCC",144,0)
 ; 
"RTN","XWBRPCC",145,0)
 ; <?xml version="1.0" encoding="utf-8" ?>
"RTN","XWBRPCC",146,0)
 ; <vistalink type="Gov.VA.Med.RPC.Request" mode="single call" >
"RTN","XWBRPCC",147,0)
 ;   <rpc uri="XWB TEST CALL" >
"RTN","XWBRPCC",148,0)
 ;      <session>
"RTN","XWBRPCC",149,0)
 ;         <duz value="990" />
"RTN","XWBRPCC",150,0)
 ;         <security>
"RTN","XWBRPCC",151,0)
 ;            <token value="something" />
"RTN","XWBRPCC",152,0)
 ;         </security>
"RTN","XWBRPCC",153,0)
 ;      </session>
"RTN","XWBRPCC",154,0)
 ;      <params>
"RTN","XWBRPCC",155,0)
 ;         <param type="string" position="1" >2</param>
"RTN","XWBRPCC",156,0)
 ;         <param type="string" position="2" >2961001</param>
"RTN","XWBRPCC",157,0)
 ;         <param type="string" position="3" >3030101</param>
"RTN","XWBRPCC",158,0)
 ;         <param type="array" position="4" >
"RTN","XWBRPCC",159,0)
 ;            <indices>
"RTN","XWBRPCC",160,0)
 ;               <index name="status" value="veteran" />
"RTN","XWBRPCC",161,0)
 ;               <index name="gender" value="male" />
"RTN","XWBRPCC",162,0)
 ;            </indices>
"RTN","XWBRPCC",163,0)
 ;         </param>
"RTN","XWBRPCC",164,0)
 ;      </params>
"RTN","XWBRPCC",165,0)
 ;   </rpc>
"RTN","XWBRPCC",166,0)
 ; </vistalink>
"RTN","XWBRPCC",167,0)
 ;
"RTN","XWBRPCC",168,0)
 ; -------------------------------------------------------------------
"RTN","XWBRPCC",169,0)
 ;
"RTN","XWBUTL")
0^4^B10435731
"RTN","XWBUTL",1,0)
XWBUTL ;OIFO-Oakland/REM - M2M Programmer Utilities ;05/17/2002  17:46
"RTN","XWBUTL",2,0)
 ;;1.1;RPC BROKER;**28,34**;Mar 28, 1997
"RTN","XWBUTL",3,0)
 ;
"RTN","XWBUTL",4,0)
 QUIT
"RTN","XWBUTL",5,0)
 ;
"RTN","XWBUTL",6,0)
 ;p34 -correct typo changing ">" to "<" in QUIT:STR'[">" - CHARCHK.
"RTN","XWBUTL",7,0)
 ;    -add "[]" as escape characters - CHARCHK.
"RTN","XWBUTL",8,0)
 ;
"RTN","XWBUTL",9,0)
 ;
"RTN","XWBUTL",10,0)
XMLHDR() ; -- provides current XML standard header 
"RTN","XWBUTL",11,0)
 QUIT "<?xml version=""1.0"" encoding=""utf-8"" ?>"
"RTN","XWBUTL",12,0)
 ;
"RTN","XWBUTL",13,0)
ERROR(XWBDAT) ; -- send error type message
"RTN","XWBUTL",14,0)
 NEW XWBI,XWBY
"RTN","XWBUTL",15,0)
 SET XWBY="XWBY"
"RTN","XWBUTL",16,0)
 ; -- build xml
"RTN","XWBUTL",17,0)
 DO BUILD(.XWBY,.XWBDAT)
"RTN","XWBUTL",18,0)
 ;
"RTN","XWBUTL",19,0)
 ; -- write xml
"RTN","XWBUTL",20,0)
 DO PRE^XWBRL
"RTN","XWBUTL",21,0)
 SET XWBI=0 FOR  SET XWBI=$O(XWBY(XWBI)) Q:'XWBI  DO WRITE^XWBRL(XWBY(XWBI))
"RTN","XWBUTL",22,0)
 ; -- send eot and flush buffer
"RTN","XWBUTL",23,0)
 DO POST^XWBRL
"RTN","XWBUTL",24,0)
 QUIT
"RTN","XWBUTL",25,0)
 ;
"RTN","XWBUTL",26,0)
BUILD(XWBY,XWBDAT) ;  -- build xml in passed store reference (XWBY)
"RTN","XWBUTL",27,0)
 ; -- input format
"RTN","XWBUTL",28,0)
 ; XWBDAT("MESSAGE TYPE") = type of message (ex. Gov.VA.Med.RPC.Error) 
"RTN","XWBUTL",29,0)
 ; XWBDAT("ERRORS",<integer>,"CODE") = error code
"RTN","XWBUTL",30,0)
 ; XWBDAT("ERRORS",<integer>,"ERROR TYPE") = type of error (system/application/security)
"RTN","XWBUTL",31,0)
 ; XWBDAT("ERRORS",<integer>,"MESSAGE",<integer>) = error message
"RTN","XWBUTL",32,0)
 ; 
"RTN","XWBUTL",33,0)
 NEW XWBCODE,XWBI,XWBERR,XWBLINE,XWBETYPE
"RTN","XWBUTL",34,0)
 SET XWBLINE=0
"RTN","XWBUTL",35,0)
 ;
"RTN","XWBUTL",36,0)
 DO ADD($$XMLHDR())
"RTN","XWBUTL",37,0)
 DO ADD("<vistalink type="""_$G(XWBDAT("MESSAGE TYPE"))_""" >")
"RTN","XWBUTL",38,0)
 DO ADD("<errors>")
"RTN","XWBUTL",39,0)
 SET XWBERR=0
"RTN","XWBUTL",40,0)
 FOR  SET XWBERR=$O(XWBDAT("ERRORS",XWBERR)) Q:'XWBERR  DO
"RTN","XWBUTL",41,0)
 . SET XWBCODE=$G(XWBDAT("ERRORS",XWBERR,"CODE"),0)
"RTN","XWBUTL",42,0)
 . SET XWBETYPE=$G(XWBDAT("ERRORS",XWBERR,"ERROR TYPE"),0)
"RTN","XWBUTL",43,0)
 . DO ADD("<error type="""_XWBETYPE_""" code="""_XWBCODE_""" >")
"RTN","XWBUTL",44,0)
 . DO ADD("<msg>")
"RTN","XWBUTL",45,0)
 . IF $G(XWBDAT("ERRORS",XWBERR,"CDATA")) DO ADD("<![CDATA[")
"RTN","XWBUTL",46,0)
 . SET XWBI=0
"RTN","XWBUTL",47,0)
 . FOR  SET XWBI=$O(XWBDAT("ERRORS",XWBERR,"MESSAGE",XWBI)) Q:'XWBI  DO
"RTN","XWBUTL",48,0)
 . . DO ADD(XWBDAT("ERRORS",XWBERR,"MESSAGE",XWBI))
"RTN","XWBUTL",49,0)
 . IF $G(XWBDAT("ERRORS",XWBERR,"CDATA")) DO ADD("]]>")
"RTN","XWBUTL",50,0)
 . DO ADD("</msg>")
"RTN","XWBUTL",51,0)
 . DO ADD("</error>")
"RTN","XWBUTL",52,0)
 DO ADD("</errors>")
"RTN","XWBUTL",53,0)
 DO ADD("</vistalink>")
"RTN","XWBUTL",54,0)
 ;
"RTN","XWBUTL",55,0)
 QUIT
"RTN","XWBUTL",56,0)
 ;
"RTN","XWBUTL",57,0)
ADD(TXT) ; -- add line
"RTN","XWBUTL",58,0)
 SET XWBLINE=XWBLINE+1
"RTN","XWBUTL",59,0)
 SET @XWBY@(XWBLINE)=TXT
"RTN","XWBUTL",60,0)
 QUIT
"RTN","XWBUTL",61,0)
 ;
"RTN","XWBUTL",62,0)
CHARCHK(STR) ; -- replace xml character limits with entities
"RTN","XWBUTL",63,0)
 NEW A,I,X,Y,Z,NEWSTR
"RTN","XWBUTL",64,0)
 SET (Y,Z)=""
"RTN","XWBUTL",65,0)
 IF STR["&" SET NEWSTR=STR DO  SET STR=Y_Z
"RTN","XWBUTL",66,0)
 . FOR X=1:1  SET Y=Y_$PIECE(NEWSTR,"&",X)_"&amp;",Z=$PIECE(STR,"&",X+1,999) QUIT:Z'["&"
"RTN","XWBUTL",67,0)
 ;
"RTN","XWBUTL",68,0)
 ;*p34-typo, change ">" to "<" in Q:STR'[... 
"RTN","XWBUTL",69,0)
 IF STR["<" FOR  SET STR=$PIECE(STR,"<",1)_"&lt;"_$PIECE(STR,"<",2,99) Q:STR'["<"
"RTN","XWBUTL",70,0)
 IF STR[">" FOR  SET STR=$PIECE(STR,">",1)_"&gt;"_$PIECE(STR,">",2,99) Q:STR'[">"
"RTN","XWBUTL",71,0)
 IF STR["'" FOR  SET STR=$PIECE(STR,"'",1)_"&apos;"_$PIECE(STR,"'",2,99) Q:STR'["'"
"RTN","XWBUTL",72,0)
 IF STR["""" FOR  SET STR=$PIECE(STR,"""",1)_"&quot;"_$PIECE(STR,"""",2,99) QUIT:STR'[""""
"RTN","XWBUTL",73,0)
 ;
"RTN","XWBUTL",74,0)
 ;*p34-add "[]" as escape characters.
"RTN","XWBUTL",75,0)
 IF STR["[" FOR  SET STR=$PIECE(STR,"[",1)_"&#91;"_$PIECE(STR,"[",2,99) Q:STR'["["
"RTN","XWBUTL",76,0)
 IF STR["]" FOR  SET STR=$PIECE(STR,"]",1)_"&#93;"_$PIECE(STR,"]",2,99) Q:STR'["]"
"RTN","XWBUTL",77,0)
 ;
"RTN","XWBUTL",78,0)
 ;Remove ctrl char's
"RTN","XWBUTL",79,0)
 S STR=$TR(STR,$C(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31))
"RTN","XWBUTL",80,0)
 ;FOR I=1:1:$LENGTH(STR) DO
"RTN","XWBUTL",81,0)
 ;. SET X=$EXTRACT(STR,I)
"RTN","XWBUTL",82,0)
 ;. SET A=$ASCII(X)
"RTN","XWBUTL",83,0)
 ;. IF A<31 S STR=$P(STR,X,1)_$P(STR,X,2,99)
"RTN","XWBUTL",84,0)
 QUIT STR
"RTN","XWBUTL",85,0)
 ;
"RTN","XWBUTL",86,0)
 ;D=0 STR 2 NUM, D=1 NUM 2 STR
"RTN","XWBUTL",87,0)
NUM(STR,D) ;Convert a string to numbers
"RTN","XWBUTL",88,0)
 N I,Y
"RTN","XWBUTL",89,0)
 S Y="",D=$G(D,0)
"RTN","XWBUTL",90,0)
 I D=0 F I=1:1:$L(STR) S Y=Y_$E(1000+$A(STR,I),2,4)
"RTN","XWBUTL",91,0)
 I D=1 F I=1:3:$L(STR) S Y=Y_$C($E(STR,I,I+2))
"RTN","XWBUTL",92,0)
 Q Y
"RTN","XWBVLL")
0^1^B15486790
"RTN","XWBVLL",1,0)
XWBVLL ;OIFO-Oakland/REM - M2M Broker Listener  ;06/08/2005  10:48
"RTN","XWBVLL",2,0)
 ;;1.1;RPC BROKER;**28,41,34**;Mar 28, 1997
"RTN","XWBVLL",3,0)
 ;
"RTN","XWBVLL",4,0)
 QUIT
"RTN","XWBVLL",5,0)
 ;
"RTN","XWBVLL",6,0)
 ;p41 - fixed infinite loop bug in SYSERR.
"RTN","XWBVLL",7,0)
 ;    - new Cache/VMS tcpip entry point, called from XWBSERVER_START.COM file.
"RTN","XWBVLL",8,0)
 ;p34 - added "BrokerM2M" in message type - SYSERR.
"RTN","XWBVLL",9,0)
 ;    - removed the quotes (") after 'M:' - SYSERRS.
"RTN","XWBVLL",10,0)
 ;    - new entry point to job off the listener for Cashe- STRT^XWBVLL(PORT).
"RTN","XWBVLL",11,0)
 ;    - clear locks when error occurs - SYSERR.
"RTN","XWBVLL",12,0)
 ;    - halt for read/write errors - SYSERR
"RTN","XWBVLL",13,0)
 ; 
"RTN","XWBVLL",14,0)
START(SOCKET) ;Entry point for Cache/NT
"RTN","XWBVLL",15,0)
 ;May be called directly to start the listener.
"RTN","XWBVLL",16,0)
 ;SOCKET -is the port# to start the listener on.
"RTN","XWBVLL",17,0)
 I ^%ZOSF("OS")'["OpenM" Q  ;Quits if not a Cache OS.
"RTN","XWBVLL",18,0)
 D LISTEN^%ZISTCPS(SOCKET,"SPAWN^XWBVLL")
"RTN","XWBVLL",19,0)
 Q
"RTN","XWBVLL",20,0)
 ;
"RTN","XWBVLL",21,0)
UCX ;DMS/VMS UCX entry point, called from XWBSERVER_START.COM file,
"RTN","XWBVLL",22,0)
 ;listener,  % = <input variable>
"RTN","XWBVLL",23,0)
 ;IF $G(%)="" DO ^%ZTER QUIT
"RTN","XWBVLL",24,0)
 SET (IO,IO(0))="SYS$NET"
"RTN","XWBVLL",25,0)
 ; **VMS specific code, need to share device**
"RTN","XWBVLL",26,0)
 OPEN IO:(TCPDEV):60 ELSE  SET ^TMP("XWB DSM CONNECT FAILURE",$H)="" QUIT
"RTN","XWBVLL",27,0)
 USE IO
"RTN","XWBVLL",28,0)
 DO SPAWN
"RTN","XWBVLL",29,0)
 QUIT
"RTN","XWBVLL",30,0)
 ;
"RTN","XWBVLL",31,0)
STRT(PORT) ;*p34-This entry is called from option "XWB M2M CACHE LISTENER" and jobs off the listener for Cashe/NT.  Will call START.
"RTN","XWBVLL",32,0)
 ;PORT -is the port# to start the listener on.
"RTN","XWBVLL",33,0)
 J START^XWBVLL(PORT)::5 ;Used in place of TaskMan
"RTN","XWBVLL",34,0)
 Q
"RTN","XWBVLL",35,0)
 ;
"RTN","XWBVLL",36,0)
CACHEVMS ;Cache/VMS tcpip entry point, called from XWBSERVER_START.COM fLle *p41*
"RTN","XWBVLL",37,0)
 SET (IO,IO(0))="SYS$NET"
"RTN","XWBVLL",38,0)
 ; **CACHE/VMS specific code**
"RTN","XWBVLL",39,0)
 OPEN IO::60 ELSE  SET ^TMP("XWB DSM CONNECT FAILURE",$H)="" QUIT
"RTN","XWBVLL",40,0)
 X "U IO:(::""-M"")" ;Packet mode like DSM
"RTN","XWBVLL",41,0)
 DO SPAWN
"RTN","XWBVLL",42,0)
 QUIT
"RTN","XWBVLL",43,0)
 ;
"RTN","XWBVLL",44,0)
SPAWN ; -- spawned process
"RTN","XWBVLL",45,0)
 NEW XWBSTOP
"RTN","XWBVLL",46,0)
 SET XWBSTOP=0
"RTN","XWBVLL",47,0)
 ;
"RTN","XWBVLL",48,0)
 ; -- initialize tcp processing variables
"RTN","XWBVLL",49,0)
 DO INIT^XWBRL
"RTN","XWBVLL",50,0)
 ;
"RTN","XWBVLL",51,0)
 ; -- set error trap
"RTN","XWBVLL",52,0)
 NEW $ESTACK,$ETRAP S $ETRAP="D ^%ZTER HALT"
"RTN","XWBVLL",53,0)
 ;
"RTN","XWBVLL",54,0)
 ; -- change job name if possible
"RTN","XWBVLL",55,0)
 ;DO SETNM^%ZOSV("XWBSERVER: Server") ;**M2M - comment out for now
"RTN","XWBVLL",56,0)
 DO SAVDEV^%ZISUTL("XWBM2M SERVER") ;**M2M save off server IO
"RTN","XWBVLL",57,0)
 S XWBDEBUG=$$GET^XPAR("SYS","XWBDEBUG",,"Q")
"RTN","XWBVLL",58,0)
 I XWBDEBUG D LOG^XWBRPC("Server Start @ "_$$NOW^XLFDT)
"RTN","XWBVLL",59,0)
 ; -- loop until told to stop
"RTN","XWBVLL",60,0)
 FOR  DO NXTCALL QUIT:XWBSTOP
"RTN","XWBVLL",61,0)
 ;
"RTN","XWBVLL",62,0)
 ; -- final/clean tcp processing variables
"RTN","XWBVLL",63,0)
 D RMDEV^%ZISUTL("XWBM2M SERVER") ;**M2M remove server IO
"RTN","XWBVLL",64,0)
 Q
"RTN","XWBVLL",65,0)
 ;
"RTN","XWBVLL",66,0)
NXTCALL ; -- do next call
"RTN","XWBVLL",67,0)
 NEW U,DTIME,DT,X,XWBROOT,XWBREAD,XWBTO,XWBFIRST,XWBOK,XWBRL,BUG
"RTN","XWBVLL",68,0)
 ;
"RTN","XWBVLL",69,0)
 ; -- set error trap
"RTN","XWBVLL",70,0)
 NEW $ESTACK,$ETRAP S $ETRAP="D SYSERR^XWBVLL"
"RTN","XWBVLL",71,0)
 ;
"RTN","XWBVLL",72,0)
 ; -- setup environment variables
"RTN","XWBVLL",73,0)
 SET U="^",DTIME=900,DT=$$DT^XLFDT()
"RTN","XWBVLL",74,0)
 SET XWBREAD=20,XWBTO=36000,XWBFIRST=1
"RTN","XWBVLL",75,0)
 ;
"RTN","XWBVLL",76,0)
 ; -- setup intake global - root is request data
"RTN","XWBVLL",77,0)
 SET XWBROOT=$NA(^TMP("XWBVLL",$J))
"RTN","XWBVLL",78,0)
 KILL @XWBROOT
"RTN","XWBVLL",79,0)
 ;
"RTN","XWBVLL",80,0)
 ; -- set parameters for RawLink
"RTN","XWBVLL",81,0)
 SET XWBRL("TIME OUT")=36000
"RTN","XWBVLL",82,0)
 SET XWBRL("READ CHARACTERS")=20
"RTN","XWBVLL",83,0)
 SET XWBRL("FIRST READ")=1
"RTN","XWBVLL",84,0)
 SET XWBRL("STORE")=XWBROOT
"RTN","XWBVLL",85,0)
 SET XWBRL("STOP FLAG")=XWBSTOP
"RTN","XWBVLL",86,0)
 ;
"RTN","XWBVLL",87,0)
 ; -- read from socket
"RTN","XWBVLL",88,0)
 SET XWBOK=$$READ^XWBRL(XWBROOT,.XWBREAD,.XWBTO,.XWBFIRST,.XWBSTOP)
"RTN","XWBVLL",89,0)
 ;
"RTN","XWBVLL",90,0)
 ;**TESTING **REM
"RTN","XWBVLL",91,0)
 ;For debugging - hard set ^TMP(..."DEBUG") and ^TMP(..."CNT") to 1
"RTN","XWBVLL",92,0)
 I $G(^TMP("XWBM2M","DEBUG")) D
"RTN","XWBVLL",93,0)
 . S XWBCNT=(^TMP("XWBM2M","CNT"))+1
"RTN","XWBVLL",94,0)
 . M ^TMP("XWBM2MSV","REQUEST",XWBCNT)=^TMP("XWBVLL",$J)
"RTN","XWBVLL",95,0)
 . S ^TMP("XWBM2M","CNT")=XWBCNT
"RTN","XWBVLL",96,0)
 . Q
"RTN","XWBVLL",97,0)
 ;
"RTN","XWBVLL",98,0)
 ;**TESING **RWF
"RTN","XWBVLL",99,0)
 I $G(XWBDEBUG) D
"RTN","XWBVLL",100,0)
 . N CNT
"RTN","XWBVLL",101,0)
 . S CNT=$G(^TMP("XWBM2ML",$J))+1,^($J)=CNT
"RTN","XWBVLL",102,0)
 . M ^TMP("XWBM2ML",$J,CNT)=^TMP("XWBVLL",$J)
"RTN","XWBVLL",103,0)
 . Q
"RTN","XWBVLL",104,0)
 ;
"RTN","XWBVLL",105,0)
 IF 'XWBOK GOTO NXTCALLQ
"RTN","XWBVLL",106,0)
 ;
"RTN","XWBVLL",107,0)
 ; -- call request manager           
"RTN","XWBVLL",108,0)
 SET XWBOK=$$EN^XWBRM(XWBROOT)
"RTN","XWBVLL",109,0)
 ; 
"RTN","XWBVLL",110,0)
NXTCALLQ ; -- exit
"RTN","XWBVLL",111,0)
 ;
"RTN","XWBVLL",112,0)
 QUIT
"RTN","XWBVLL",113,0)
 ;
"RTN","XWBVLL",114,0)
 ; ---------------------------------------------------------------------
"RTN","XWBVLL",115,0)
 ;                                System Error Handler
"RTN","XWBVLL",116,0)
 ; ---------------------------------------------------------------------
"RTN","XWBVLL",117,0)
SYSERR ; -- send system error message
"RTN","XWBVLL",118,0)
 ;p41-don't new $Etrap, it was causing infinite loop.
"RTN","XWBVLL",119,0)
 ;p34-added "BrokerM2M" in message type in SYSERR.
"RTN","XWBVLL",120,0)
 ;   -halt for read/write errors
"RTN","XWBVLL",121,0)
 NEW XWBDAT,XWBMSG ;,$ETRAP ;*p41
"RTN","XWBVLL",122,0)
 S $ETRAP="D ^%ZTER HALT" ;If we get an error in the error handler just Halt
"RTN","XWBVLL",123,0)
 SET XWBMSG=$$EC^%ZOSV ;Get the error code
"RTN","XWBVLL",124,0)
 D ^%ZTER ;Save off the error
"RTN","XWBVLL",125,0)
 SET XWBDAT("MESSAGE TYPE")="Gov.VA.Med.BrokerM2M.Errors" ;*34
"RTN","XWBVLL",126,0)
 SET XWBDAT("ERRORS",1,"CODE")=1
"RTN","XWBVLL",127,0)
 SET XWBDAT("ERRORS",1,"ERROR TYPE")="system"
"RTN","XWBVLL",128,0)
 SET XWBDAT("ERRORS",1,"CDATA")=1
"RTN","XWBVLL",129,0)
 SET XWBDAT("ERRORS",1,"MESSAGE",1)=$P($TEXT(SYSERRS+1),";;",2)_XWBMSG
"RTN","XWBVLL",130,0)
 ;*p34-will halt for read/write errors
"RTN","XWBVLL",131,0)
 I XWBMSG["<READ>" HALT
"RTN","XWBVLL",132,0)
 DO ERROR^XWBUTL(.XWBDAT)
"RTN","XWBVLL",133,0)
 D UNWIND^%ZTER ;Return to NXTCALL loop
"RTN","XWBVLL",134,0)
 L  ;Clear locks *p34
"RTN","XWBVLL",135,0)
 Q
"RTN","XWBVLL",136,0)
 ;
"RTN","XWBVLL",137,0)
SYSERRS ; -- application errors
"RTN","XWBVLL",138,0)
 ;*p34-removed the quotes (") after 'M:'
"RTN","XWBVLL",139,0)
 ;;A system error occurred in M:
"VER")
8.0^22.0
"BLD",512,6)
^SEQ #33
**END**
**END**
