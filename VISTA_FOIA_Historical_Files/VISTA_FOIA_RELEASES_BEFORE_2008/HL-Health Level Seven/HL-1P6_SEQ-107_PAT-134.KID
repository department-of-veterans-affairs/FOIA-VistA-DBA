Released HL*1.6*134 SEQ #107
Extracted from mail message
**KIDS**:HL*1.6*134^

**INSTALL NAME**
HL*1.6*134
"BLD",980,0)
HL*1.6*134^HEALTH LEVEL SEVEN^0^3070418^y
"BLD",980,1,0)
^9.61A^3^3^3070122^^
"BLD",980,1,1,0)
Please see the National Patch Module for a full description.
"BLD",980,1,2,0)

"BLD",980,1,3,0)

"BLD",980,4,0)
^9.64PA^778^3
"BLD",980,4,778,0)
778
"BLD",980,4,778,2,0)
^9.641^778^1
"BLD",980,4,778,2,778,0)
HLO MESSAGES  (File-top level)
"BLD",980,4,778,2,778,1,0)
^9.6411^5^1
"BLD",980,4,778,2,778,1,5,0)
TRANMISSION ATTEMPTS
"BLD",980,4,778,222)
y^n^p^^^^n^^n
"BLD",980,4,778,224)

"BLD",980,4,779.2,0)
779.2
"BLD",980,4,779.2,2,0)
^9.641^779.2^1
"BLD",980,4,779.2,2,779.2,0)
HLO APPLICATION REGISTRY  (File-top level)
"BLD",980,4,779.2,2,779.2,1,0)
^9.6411^.09^1
"BLD",980,4,779.2,2,779.2,1,.09,0)
APPLICATION SPECIFIC LISTENER
"BLD",980,4,779.2,222)
y^n^p^^^^n^^n
"BLD",980,4,779.2,224)

"BLD",980,4,779.4,0)
779.4
"BLD",980,4,779.4,222)
y^n^f^^^^n
"BLD",980,4,"APDD",778,778)

"BLD",980,4,"APDD",778,778,5)

"BLD",980,4,"APDD",779.2,779.2)

"BLD",980,4,"APDD",779.2,779.2,.09)

"BLD",980,4,"B",778,778)

"BLD",980,4,"B",779.2,779.2)

"BLD",980,4,"B",779.4,779.4)

"BLD",980,6.3)
30
"BLD",980,"ABPKG")
n
"BLD",980,"INI")
CHECK^HLOPRE
"BLD",980,"INID")
^n^y
"BLD",980,"INIT")
P134^HLOPOST
"BLD",980,"KRN",0)
^9.67PA^779.2^20
"BLD",980,"KRN",.4,0)
.4
"BLD",980,"KRN",.401,0)
.401
"BLD",980,"KRN",.402,0)
.402
"BLD",980,"KRN",.403,0)
.403
"BLD",980,"KRN",.5,0)
.5
"BLD",980,"KRN",.84,0)
.84
"BLD",980,"KRN",3.6,0)
3.6
"BLD",980,"KRN",3.8,0)
3.8
"BLD",980,"KRN",9.2,0)
9.2
"BLD",980,"KRN",9.2,"NM",0)
^9.68A^^
"BLD",980,"KRN",9.8,0)
9.8
"BLD",980,"KRN",9.8,"NM",0)
^9.68A^30^29
"BLD",980,"KRN",9.8,"NM",1,0)
HLOPRS^^0^B28621487
"BLD",980,"KRN",9.8,"NM",2,0)
HLOAPI2^^0^B37390174
"BLD",980,"KRN",9.8,"NM",3,0)
HLOAPI4^^0^B21664349
"BLD",980,"KRN",9.8,"NM",4,0)
HLOPRS1^^0^B19883932
"BLD",980,"KRN",9.8,"NM",5,0)
HLOQUE^^0^B5560431
"BLD",980,"KRN",9.8,"NM",6,0)
HLOUSR^^0^B88986165
"BLD",980,"KRN",9.8,"NM",7,0)
HLOSTAT^^0^B56413629
"BLD",980,"KRN",9.8,"NM",8,0)
HLOESTAT^^0^B23707837
"BLD",980,"KRN",9.8,"NM",9,0)
HLOCLNT1^^0^B31098132
"BLD",980,"KRN",9.8,"NM",10,0)
HLOCLNT2^^0^B38024388
"BLD",980,"KRN",9.8,"NM",11,0)
HLOF778A^^0^B38921929
"BLD",980,"KRN",9.8,"NM",12,0)
HLOFILER^^0^B28742582
"BLD",980,"KRN",9.8,"NM",13,0)
HLOCLNT3^^0^B5680444
"BLD",980,"KRN",9.8,"NM",14,0)
HLOSRVR^^0^B71398107
"BLD",980,"KRN",9.8,"NM",15,0)
HLOCLNT^^0^B59494519
"BLD",980,"KRN",9.8,"NM",16,0)
HLOASUB1^^0^B62125339
"BLD",980,"KRN",9.8,"NM",17,0)
HLOAPI1^^0^B48519291
"BLD",980,"KRN",9.8,"NM",18,0)
HLOCVU^^0^B14731556
"BLD",980,"KRN",9.8,"NM",19,0)
HLOCNRT^^0^B11469805
"BLD",980,"KRN",9.8,"NM",20,0)
HLOUSR3^^0^B28592051
"BLD",980,"KRN",9.8,"NM",21,0)
HLOUSR1^^0^B71059198
"BLD",980,"KRN",9.8,"NM",22,0)
HLOF778^^0^B31810576
"BLD",980,"KRN",9.8,"NM",23,0)
HLOSRVR1^^0^B71810026
"BLD",980,"KRN",9.8,"NM",24,0)
HLOPURGE^^0^B33852841
"BLD",980,"KRN",9.8,"NM",25,0)
HLOUSR2^^0^B50803948
"BLD",980,"KRN",9.8,"NM",26,0)
HLOAPI3^^0^B45861231
"BLD",980,"KRN",9.8,"NM",27,0)
HLOPOST^^0^B10060576
"BLD",980,"KRN",9.8,"NM",28,0)
HLOPROC^^0^B26319281
"BLD",980,"KRN",9.8,"NM",29,0)
HLOTCP^^0^B45604114
"BLD",980,"KRN",9.8,"NM",30,0)
HLOMSG^^0^B46053749
"BLD",980,"KRN",9.8,"NM","B","HLOAPI1",17)

"BLD",980,"KRN",9.8,"NM","B","HLOAPI2",2)

"BLD",980,"KRN",9.8,"NM","B","HLOAPI3",26)

"BLD",980,"KRN",9.8,"NM","B","HLOAPI4",3)

"BLD",980,"KRN",9.8,"NM","B","HLOASUB1",16)

"BLD",980,"KRN",9.8,"NM","B","HLOCLNT",15)

"BLD",980,"KRN",9.8,"NM","B","HLOCLNT1",9)

"BLD",980,"KRN",9.8,"NM","B","HLOCLNT2",10)

"BLD",980,"KRN",9.8,"NM","B","HLOCLNT3",13)

"BLD",980,"KRN",9.8,"NM","B","HLOCNRT",19)

"BLD",980,"KRN",9.8,"NM","B","HLOCVU",18)

"BLD",980,"KRN",9.8,"NM","B","HLOESTAT",8)

"BLD",980,"KRN",9.8,"NM","B","HLOF778",22)

"BLD",980,"KRN",9.8,"NM","B","HLOF778A",11)

"BLD",980,"KRN",9.8,"NM","B","HLOFILER",12)

"BLD",980,"KRN",9.8,"NM","B","HLOMSG",30)

"BLD",980,"KRN",9.8,"NM","B","HLOPOST",27)

"BLD",980,"KRN",9.8,"NM","B","HLOPROC",28)

"BLD",980,"KRN",9.8,"NM","B","HLOPRS",1)

"BLD",980,"KRN",9.8,"NM","B","HLOPRS1",4)

"BLD",980,"KRN",9.8,"NM","B","HLOPURGE",24)

"BLD",980,"KRN",9.8,"NM","B","HLOQUE",5)

"BLD",980,"KRN",9.8,"NM","B","HLOSRVR",14)

"BLD",980,"KRN",9.8,"NM","B","HLOSRVR1",23)

"BLD",980,"KRN",9.8,"NM","B","HLOSTAT",7)

"BLD",980,"KRN",9.8,"NM","B","HLOTCP",29)

"BLD",980,"KRN",9.8,"NM","B","HLOUSR",6)

"BLD",980,"KRN",9.8,"NM","B","HLOUSR1",21)

"BLD",980,"KRN",9.8,"NM","B","HLOUSR2",25)

"BLD",980,"KRN",9.8,"NM","B","HLOUSR3",20)

"BLD",980,"KRN",19,0)
19
"BLD",980,"KRN",19,"NM",0)
^9.68A^9^4
"BLD",980,"KRN",19,"NM",2,0)
HLO ERROR STATISTICS REPORT^^0
"BLD",980,"KRN",19,"NM",7,0)
HLO MAIN MENU^^3
"BLD",980,"KRN",19,"NM",8,0)
HLO SYSTEM STARTUP^^0
"BLD",980,"KRN",19,"NM",9,0)
HLO DAILY STARTUP^^0
"BLD",980,"KRN",19,"NM","B","HLO DAILY STARTUP",9)

"BLD",980,"KRN",19,"NM","B","HLO ERROR STATISTICS REPORT",2)

"BLD",980,"KRN",19,"NM","B","HLO MAIN MENU",7)

"BLD",980,"KRN",19,"NM","B","HLO SYSTEM STARTUP",8)

"BLD",980,"KRN",19.1,0)
19.1
"BLD",980,"KRN",19.1,"NM",0)
^9.68A^^
"BLD",980,"KRN",101,0)
101
"BLD",980,"KRN",101,"NM",0)
^9.68A^3^3
"BLD",980,"KRN",101,"NM",1,0)
HLO SET PURGE^^0
"BLD",980,"KRN",101,"NM",2,0)
HLO DISPLAY SINGLE MESSAGE^^0
"BLD",980,"KRN",101,"NM",3,0)
HLO SINGLE MESSAGE ACTIONS MENU^^0
"BLD",980,"KRN",101,"NM","B","HLO DISPLAY SINGLE MESSAGE",2)

"BLD",980,"KRN",101,"NM","B","HLO SET PURGE",1)

"BLD",980,"KRN",101,"NM","B","HLO SINGLE MESSAGE ACTIONS MENU",3)

"BLD",980,"KRN",409.61,0)
409.61
"BLD",980,"KRN",409.61,"NM",0)
^9.68A^1^1
"BLD",980,"KRN",409.61,"NM",1,0)
HLO SINGLE MESSAGE DISPLAY^^0
"BLD",980,"KRN",409.61,"NM","B","HLO SINGLE MESSAGE DISPLAY",1)

"BLD",980,"KRN",771,0)
771
"BLD",980,"KRN",779.2,0)
779.2
"BLD",980,"KRN",779.2,"NM",0)
^9.68A^^
"BLD",980,"KRN",870,0)
870
"BLD",980,"KRN",8989.51,0)
8989.51
"BLD",980,"KRN",8989.52,0)
8989.52
"BLD",980,"KRN",8994,0)
8994
"BLD",980,"KRN","B",.4,.4)

"BLD",980,"KRN","B",.401,.401)

"BLD",980,"KRN","B",.402,.402)

"BLD",980,"KRN","B",.403,.403)

"BLD",980,"KRN","B",.5,.5)

"BLD",980,"KRN","B",.84,.84)

"BLD",980,"KRN","B",3.6,3.6)

"BLD",980,"KRN","B",3.8,3.8)

"BLD",980,"KRN","B",9.2,9.2)

"BLD",980,"KRN","B",9.8,9.8)

"BLD",980,"KRN","B",19,19)

"BLD",980,"KRN","B",19.1,19.1)

"BLD",980,"KRN","B",101,101)

"BLD",980,"KRN","B",409.61,409.61)

"BLD",980,"KRN","B",771,771)

"BLD",980,"KRN","B",779.2,779.2)

"BLD",980,"KRN","B",870,870)

"BLD",980,"KRN","B",8989.51,8989.51)

"BLD",980,"KRN","B",8989.52,8989.52)

"BLD",980,"KRN","B",8994,8994)

"BLD",980,"QUES",0)
^9.62^^
"BLD",980,"REQB",0)
^9.611^1^1
"BLD",980,"REQB",1,0)
HL*1.6*132^2
"BLD",980,"REQB","B","HL*1.6*132",1)

"FIA",778)
HLO MESSAGES
"FIA",778,0)
^HLB(
"FIA",778,0,0)
778O
"FIA",778,0,1)
y^n^p^^^^n^^n
"FIA",778,0,10)

"FIA",778,0,11)

"FIA",778,0,"RLRO")

"FIA",778,0,"VR")
1.6^HL
"FIA",778,778)
1
"FIA",778,778,5)

"FIA",779.2)
HLO APPLICATION REGISTRY
"FIA",779.2,0)
^HLD(779.2,
"FIA",779.2,0,0)
779.2
"FIA",779.2,0,1)
y^n^p^^^^n^^n
"FIA",779.2,0,10)

"FIA",779.2,0,11)

"FIA",779.2,0,"RLRO")

"FIA",779.2,0,"VR")
1.6^HL
"FIA",779.2,779.2)
1
"FIA",779.2,779.2,.09)

"FIA",779.4)
HLO SUBSCRIPTION REGISTRY
"FIA",779.4,0)
^HLD(779.4,
"FIA",779.4,0,0)
779.4
"FIA",779.4,0,1)
y^n^f^^^^n
"FIA",779.4,0,10)

"FIA",779.4,0,11)

"FIA",779.4,0,"RLRO")

"FIA",779.4,0,"VR")
1.6^HL
"FIA",779.4,779.4)
0
"FIA",779.4,779.41)
0
"INI")
CHECK^HLOPRE
"INIT")
P134^HLOPOST
"IX",779.4,779.4,"AH",0)
779.4^AH^LOOKUP^MU^^R^IR^I^779.4^^^^^A
"IX",779.4,779.4,"AH",.1,0)
^^3^3^3070124^^^
"IX",779.4,779.4,"AH",.1,1,0)

"IX",779.4,779.4,"AH",.1,2,0)

"IX",779.4,779.4,"AH",.1,3,0)

"IX",779.4,779.4,"AH",1)
D SETAH1^HLOASUB1(DA,X(1),X(2),X(3),X(4),X(5),X(6),X(7))
"IX",779.4,779.4,"AH",2)
D KILLAH1^HLOASUB1(X(1),X(2),X(3),X(4),X(5),X(6),X(7))
"IX",779.4,779.4,"AH",2.5)
K ^HLD(779.4,"AH")
"IX",779.4,779.4,"AH",11.1,0)
^.114IA^7^7
"IX",779.4,779.4,"AH",11.1,1,0)
1^F^779.4^.02^^1^F
"IX",779.4,779.4,"AH",11.1,2,0)
2^F^779.4^3.01^^^F
"IX",779.4,779.4,"AH",11.1,3,0)
3^F^779.4^3.02^^^F
"IX",779.4,779.4,"AH",11.1,3,1)

"IX",779.4,779.4,"AH",11.1,4,0)
4^F^779.4^3.03^^^F
"IX",779.4,779.4,"AH",11.1,5,0)
5^F^779.4^3.04^^^F
"IX",779.4,779.4,"AH",11.1,6,0)
6^F^779.4^3.05^^^F
"IX",779.4,779.4,"AH",11.1,7,0)
7^F^779.4^3.06^^^F
"IX",779.4,779.41,"AC",0)
779.41.^AC^Used to find recipients who have not been terminated.^MU^^R^IR^I^779.41^^^^^S
"IX",779.4,779.41,"AC",1)
S ^HLD(779.4,DA(1),2,"AC",DA)=""
"IX",779.4,779.41,"AC",1.4)
S X=$S($G(X2(2)):0,1:1)
"IX",779.4,779.41,"AC",2)
K ^HLD(779.4,DA(1),2,"AC",DA)
"IX",779.4,779.41,"AC",2.4)
S X=1
"IX",779.4,779.41,"AC",11.1,0)
^.114IA^2^2
"IX",779.4,779.41,"AC",11.1,1,0)
1^F^779.41^1.01^^1^F
"IX",779.4,779.41,"AC",11.1,1,3)

"IX",779.4,779.41,"AC",11.1,2,0)
2^F^779.41^1.02^^^F
"IX",779.4,779.41,"AC",11.1,2,3)

"IX",779.4,779.41,"AD",0)
779.41^AD^Used to determine if the recipient is already on the subscription list.^MU^^R^IR^I^779.41^^^^^S
"IX",779.4,779.41,"AD",1)
S ^HLD(779.4,DA(1),2,"AD",X2(1),X2(2),X2(3)_X2(4)_X2(5),DA)=""
"IX",779.4,779.41,"AD",2)
K ^HLD(779.4,DA(1),2,"AD",X1(1),X1(2),X1(3)_X1(4)_X1(5),DA)
"IX",779.4,779.41,"AD",11.1,0)
^.114IA^5^5
"IX",779.4,779.41,"AD",11.1,1,0)
1^F^779.41^.01^^1^F
"IX",779.4,779.41,"AD",11.1,1,3)

"IX",779.4,779.41,"AD",11.1,2,0)
2^F^779.41^.02^^2^F
"IX",779.4,779.41,"AD",11.1,2,3)

"IX",779.4,779.41,"AD",11.1,3,0)
3^F^779.41^.03^^^F
"IX",779.4,779.41,"AD",11.1,3,3)

"IX",779.4,779.41,"AD",11.1,4,0)
4^F^779.41^.04^^^F
"IX",779.4,779.41,"AD",11.1,4,3)

"IX",779.4,779.41,"AD",11.1,5,0)
5^F^779.41^.05^^^F
"IX",779.4,779.41,"AD",11.1,5,3)

"KRN",19,1047,-1)
3^7
"KRN",19,1047,0)
HLO MAIN MENU^HL7 (Optimized) MAIN MENU^^M^^^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1047,1,0)
^19.06^1^1^3051026^^^^
"KRN",19,1047,1,1,0)
This menu contains all the options developed for HLO.
"KRN",19,1047,10,0)
^19.01IP^5^5
"KRN",19,1047,10,5,0)
1244^ES^5
"KRN",19,1047,10,5,"^")
HLO ERROR STATISTICS REPORT
"KRN",19,1047,99)
60673,40947
"KRN",19,1047,"U")
HL7 (OPTIMIZED) MAIN MENU
"KRN",19,1048,-1)
0^8
"KRN",19,1048,0)
HLO SYSTEM STARTUP^HL7 (Optimized) SYSTEM STARTUP^^A^^^^^^^n^HEALTH LEVEL SEVEN^^1
"KRN",19,1048,1,0)
^19.06^2^2^3070314^^^^
"KRN",19,1048,1,1,0)
This option should be scheduled upon system startup to start HLO
"KRN",19,1048,1,2,0)
running.
"KRN",19,1048,20)
D STARTHL7^HLOPROC1
"KRN",19,1048,"U")
HL7 (OPTIMIZED) SYSTEM STARTUP
"KRN",19,1244,-1)
0^2
"KRN",19,1244,0)
HLO ERROR STATISTICS REPORT^HLO ERROR STATISTICS^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,1244,1,0)
^19.06^5^5^3070212^^^^
"KRN",19,1244,1,1,0)
This option is a report that displays by period the counts of messgage errors
"KRN",19,1244,1,2,0)
that occurred while sending and recieivng messages via HLO.  The counts are
"KRN",19,1244,1,3,0)
sub-categorized by application and message type.
"KRN",19,1244,1,4,0)

"KRN",19,1244,1,5,0)

"KRN",19,1244,10.1)
HLO MESSAGE STATISTICS REPORT
"KRN",19,1244,20)
D REPORT^HLOESTAT
"KRN",19,1244,"U")
HLO ERROR STATISTICS
"KRN",19,1249,-1)
0^9
"KRN",19,1249,0)
HLO DAILY STARTUP^HLO DAILY STARTUP^^A^^^^^^^n^HEALTH LEVEL SEVEN^^1
"KRN",19,1249,1,0)
^19.06^5^5^3070314^^^
"KRN",19,1249,1,1,0)
This option should be scheduled daily to insure that HLO stays up and running.
"KRN",19,1249,1,2,0)
It does NOT override the HLO ON/OFF SWITCH, i.e., if HLO was deliberately
"KRN",19,1249,1,3,0)
shutdown this option will not start it.  It is meant to re-start HLO if
"KRN",19,1249,1,4,0)
it unexpectely stops.
"KRN",19,1249,1,5,0)

"KRN",19,1249,20)
D:'$$CHKSTOP^HLOPROC STARTHL7^HLOPROC1
"KRN",19,1249,"U")
HLO DAILY STARTUP
"KRN",101,423,-1)
0^2
"KRN",101,423,0)
HLO DISPLAY SINGLE MESSAGE^DISPLAY A MESSAGE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,423,1,0)
^101.06^1^1^3070319^^^
"KRN",101,423,1,1,0)
This action allows the user to select a message.  It is then displayed.
"KRN",101,423,2,0)
^101.02A^1^1
"KRN",101,423,2,1,0)
DM
"KRN",101,423,2,"B","DM",1)

"KRN",101,423,20)
D EN^HLOUSR1
"KRN",101,423,99)
60162,30178
"KRN",101,496,-1)
0^1
"KRN",101,496,0)
HLO SET PURGE^SET PURGE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,496,1,0)
^^2^2^3070319^
"KRN",101,496,1,1,0)
Allows the purge date/time for the message to be set.
"KRN",101,496,1,2,0)

"KRN",101,496,2,0)
^101.02A^1^1
"KRN",101,496,2,1,0)
SP
"KRN",101,496,2,"B","SP",1)

"KRN",101,496,20)
D SETPURGE^HLOUSR3
"KRN",101,496,24)

"KRN",101,496,99)
60708,40895
"KRN",101,497,-1)
0^3
"KRN",101,497,0)
HLO SINGLE MESSAGE ACTIONS MENU^SINGLE MESSAGE ACTIONS MENU^^M^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,497,1,0)
^101.06^3^3^3070319^^^
"KRN",101,497,1,1,0)
Contains the actions that can be used on a single message that has already been
"KRN",101,497,1,2,0)
selected.
"KRN",101,497,1,3,0)

"KRN",101,497,4)
26^4
"KRN",101,497,10,0)
^101.01PA^1^1
"KRN",101,497,10,1,0)
496^SP^1^^^SET PURGE
"KRN",101,497,10,1,"^")
HLO SET PURGE
"KRN",101,497,24)

"KRN",101,497,26)
D SHOW^VALM
"KRN",101,497,28)
Select Action:
"KRN",101,497,99)
60722,35729
"KRN",409.61,241,-1)
0^1
"KRN",409.61,241,0)
HLO SINGLE MESSAGE DISPLAY^1^1^80^3^20^1^1^MESSAGE^HLO SINGLE MESSAGE ACTIONS MENU^Single Message Display^1
"KRN",409.61,241,1)
^VALM HIDDEN ACTIONS
"KRN",409.61,241,"ARRAY")
 ^TMP($J,"HLO SINGLE MESSAGE DISPLAY")
"KRN",409.61,241,"FNL")
D EXIT^HLOUSR3
"KRN",409.61,241,"HDR")
D HDR^HLOUSR1
"KRN",409.61,241,"HLP")
D HLP^HLOUSR1
"KRN",409.61,241,"INIT")
D DISPLAY^HLOUSR1
"MBREQ")
0
"ORD",15,101)
101;15;;;PRO^XPDTA;PROF1^XPDIA;PROE1^XPDIA;PROF2^XPDIA;;PRODEL^XPDIA
"ORD",15,101,0)
PROTOCOL
"ORD",17,409.61)
409.61;17;1;;;;;;;LMDEL^XPDIA1
"ORD",17,409.61,0)
LIST TEMPLATE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
134^3070418
"PKG",9,22,1,"PAH",1,1,0)
^^3^3^3070418
"PKG",9,22,1,"PAH",1,1,1,0)
Please see the National Patch Module for a full description.
"PKG",9,22,1,"PAH",1,1,2,0)

"PKG",9,22,1,"PAH",1,1,3,0)

"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
31
"RTN","HLOAPI1")
0^17^B48519291^B47955238
"RTN","HLOAPI1",1,0)
HLOAPI1 ;ALB/CJM-HL7 - Developer API's for sending & receiving messages(continued) ;02/06/2007
"RTN","HLOAPI1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132,134**;Oct 13, 1995;Build 30
"RTN","HLOAPI1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI1",4,0)
 ;
"RTN","HLOAPI1",5,0)
SENDONE(HLMSTATE,PARMS,WHOTO,ERROR) ;
"RTN","HLOAPI1",6,0)
 ;Sends the message to a single receiving application.
"RTN","HLOAPI1",7,0)
 ;
"RTN","HLOAPI1",8,0)
 ;Input:
"RTN","HLOAPI1",9,0)
 ;HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it
"RTN","HLOAPI1",10,0)
 ;PARMS( *pass by reference*
"RTN","HLOAPI1",11,0)
 ;  "APP ACK RESPONSE")=<tag^routine> to call when the app ack is received (optional)
"RTN","HLOAPI1",12,0)
 ;    (NOTE: For batch messages, HLO best supports returning application
"RTN","HLOAPI1",13,0)
 ;     acknowledgments via a batch response.  However, non-VistA systems
"RTN","HLOAPI1",14,0)
 ;     may return individual messages as application acknowledgments to
"RTN","HLOAPI1",15,0)
 ;     messages within the original batch message, so for applications
"RTN","HLOAPI1",16,0)
 ;     sending batch messages might best code the "APP ACK RESPONSE"
"RTN","HLOAPI1",17,0)
 ;     routine to first check whether the response message is a batch.
"RTN","HLOAPI1",18,0)
 ; 
"RTN","HLOAPI1",19,0)
 ;  "ACCEPT ACK RESPONSE")=<tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI1",20,0)
 ;  "ACCEPT ACK TYPE") = <AL,NE> (optional, defaults to AL)
"RTN","HLOAPI1",21,0)
 ;  "APP ACK TYPE") = <AL,NE> (optional, defaults to NE)
"RTN","HLOAPI1",22,0)
 ;  "FAILURE RESPONSE" - <tag>^<routine> (optional) The sending application routine to execute when the transmission of the message fails, i.e., the message can not be sent or no commit ack is received.
"RTN","HLOAPI1",23,0)
 ;  "QUEUE" - (optional) An application can name its own private queue - just a string up to 20 characters, it should be namespaced.
"RTN","HLOAPI1",24,0)
 ;  "SECURITY")=security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI1",25,0)
 ;  "SENDING APPLICATION")=name of sending app (required, 60 maximum length)
"RTN","HLOAPI1",26,0)
 ;
"RTN","HLOAPI1",27,0)
 ;  WHOTO (required,pass by reference) an array specifying a single recipient. These subscripts are allowed:
"RTN","HLOAPI1",28,0)
 ;
"RTN","HLOAPI1",29,0)
 ;    "RECEIVING APPLICATION" - (string, 60 char max, required)
"RTN","HLOAPI1",30,0)
 ;
"RTN","HLOAPI1",31,0)
 ;  EXACTLY ONE of these parameters must be provided to identify the Receiving Facility:
"RTN","HLOAPI1",32,0)
 ;
"RTN","HLOAPI1",33,0)
 ;   "FACILITY LINK IEN" - ien of the logical link 
"RTN","HLOAPI1",34,0)
 ;   "FACILITY LINK NAME" - name of the logical link 
"RTN","HLOAPI1",35,0)
 ;   "INSTITUTION IEN" - ptr to the INSTITUTION file
"RTN","HLOAPI1",36,0)
 ;   "STATION NUMBER" -  station # with suffix
"RTN","HLOAPI1",37,0)
 ;
"RTN","HLOAPI1",38,0)
 ;  EXACTLY ONE of these MAY be provided - optionally - to identify the interface engine to route the message through:
"RTN","HLOAPI1",39,0)
 ;
"RTN","HLOAPI1",40,0)
 ;   "IE LINK IEN" -  ptr to a logical link for the interface engine 
"RTN","HLOAPI1",41,0)
 ;   "IE LINK NAME" - name of the logical link for the interface engine
"RTN","HLOAPI1",42,0)
 ;
"RTN","HLOAPI1",43,0)
 ;Output:
"RTN","HLOAPI1",44,0)
 ;  Function returns the ien of the message in file 778 on success, 0 on failure
"RTN","HLOAPI1",45,0)
 ;   HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI1",46,0)
 ;   ERROR (pass by reference, optional) - on failure, will contain an error message
"RTN","HLOAPI1",47,0)
 ;   PARMS - left undefined when the function returns
"RTN","HLOAPI1",48,0)
 ;   WHOTO - left undefined when the function returns
"RTN","HLOAPI1",49,0)
 ;
"RTN","HLOAPI1",50,0)
 ;
"RTN","HLOAPI1",51,0)
 N SUCCESS,ERR1,ERR2
"RTN","HLOAPI1",52,0)
 S SUCCESS=0
"RTN","HLOAPI1",53,0)
 D
"RTN","HLOAPI1",54,0)
 .I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) S ERROR="MESSAGE NOT YET CREATED" Q
"RTN","HLOAPI1",55,0)
 .;
"RTN","HLOAPI1",56,0)
 .I $$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERR1)&$$CHKWHO(.HLMSTATE,.WHOTO,.ERR2) D
"RTN","HLOAPI1",57,0)
 ..I $$SEND(.HLMSTATE,.ERROR) S SUCCESS=1
"RTN","HLOAPI1",58,0)
 .E  D
"RTN","HLOAPI1",59,0)
 .S ERROR=$G(ERR1)_": "_$G(ERR2)
"RTN","HLOAPI1",60,0)
 .D DONTSEND(.HLMSTATE,ERROR)
"RTN","HLOAPI1",61,0)
 K PARMS,WHOTO
"RTN","HLOAPI1",62,0)
 Q $S(SUCCESS:HLMSTATE("IEN"),1:0)
"RTN","HLOAPI1",63,0)
 ;
"RTN","HLOAPI1",64,0)
SENDMANY(HLMSTATE,PARMS,WHOTO) ;
"RTN","HLOAPI1",65,0)
 ;Sends the message to a list of receiving applications
"RTN","HLOAPI1",66,0)
 ;
"RTN","HLOAPI1",67,0)
 ;Input: Same as for $$SENDONE, except WHOTO is a list.
"RTN","HLOAPI1",68,0)
 ;  WHOTO (pass by reference)
"RTN","HLOAPI1",69,0)
 ;    Specifies a list of recipients.  Each recipient should be on the
"RTN","HLOAPI1",70,0)
 ;    list as WHOTO(i), where i=1,2,3,4, etc. for as many messages as to
"RTN","HLOAPI1",71,0)
 ;    send.  At each subscript WHOTO(i), the same lower level subscripts
"RTN","HLOAPI1",72,0)
 ;    may be defined as in the $$SENDONE API.  For example:
"RTN","HLOAPI1",73,0)
 ;
"RTN","HLOAPI1",74,0)
 ;      WHOTO(1,"LINK NAME")="VAALB"
"RTN","HLOAPI1",75,0)
 ;      WHOTO(1,"RECEIVING APPLICATION")="MPI"
"RTN","HLOAPI1",76,0)
 ;      WHOTO(2,"STATION NUMBER")=500
"RTN","HLOAPI1",77,0)
 ;      WHOTO(2,"RECEIVING APPLICATION")="MPI"
"RTN","HLOAPI1",78,0)
 ;
"RTN","HLOAPI1",79,0)
 ;
"RTN","HLOAPI1",80,0)
 ;Output:
"RTN","HLOAPI1",81,0)
 ;  Function returns 1 if a message is queued to be sent to each intended recipient, 0 otherwise
"RTN","HLOAPI1",82,0)
 ;  PARMS - left undefined when the function returns
"RTN","HLOAPI1",83,0)
 ;  WHOTO (pass by reference) returns the status of each message to be sent in the format:
"RTN","HLOAPI1",84,0)
 ;    (<i>,"QUEUED")= <1 if queued to be sent, 0 otherwise)
"RTN","HLOAPI1",85,0)
 ;   (<i>,"IEN")=<ien, file 778>
"RTN","HLOAPI1",86,0)
 ;   (<i>,"ERROR")= error message if an error was encountered (status=0), not defined otherwise
"RTN","HLOAPI1",87,0)
 ;
"RTN","HLOAPI1",88,0)
 ;
"RTN","HLOAPI1",89,0)
 N ERROR,RETURN,WHO,STATE,I
"RTN","HLOAPI1",90,0)
 S RETURN=1
"RTN","HLOAPI1",91,0)
 I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) D  K PARMS Q 0
"RTN","HLOAPI1",92,0)
 .S ERROR="MESSAGE NOT YET CREATED"
"RTN","HLOAPI1",93,0)
 .S I=0 F  S I=$O(WHOTO(I)) Q:'I  S WHOTO(I,"QUEUED")=0,WHOTO(I,"IEN")=0,WHOTO(I,"ERROR")=ERROR
"RTN","HLOAPI1",94,0)
 ;
"RTN","HLOAPI1",95,0)
 I '$$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERROR) D  K PARMS Q 0
"RTN","HLOAPI1",96,0)
 .S I=0 F  S I=$O(WHOTO(I)) Q:'I  D
"RTN","HLOAPI1",97,0)
 ..K WHO M WHO=WHOTO(I)
"RTN","HLOAPI1",98,0)
 ..K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",99,0)
 ..S WHOTO(I,"QUEUED")=0
"RTN","HLOAPI1",100,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",101,0)
 ..S WHOTO(I,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",102,0)
 ..S WHOTO(I,"ERROR")=ERROR
"RTN","HLOAPI1",103,0)
 ;
"RTN","HLOAPI1",104,0)
 S I=0 F  S I=$O(WHOTO(I)) Q:'I  D
"RTN","HLOAPI1",105,0)
 .K WHO M WHO=WHOTO(I)
"RTN","HLOAPI1",106,0)
 .K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",107,0)
 .S ERROR=""
"RTN","HLOAPI1",108,0)
 .I $$CHKWHO(.STATE,.WHO,.ERROR) D
"RTN","HLOAPI1",109,0)
 ..I $$SEND(.STATE,.ERROR) D
"RTN","HLOAPI1",110,0)
 ...S WHOTO(I,"QUEUED")=1
"RTN","HLOAPI1",111,0)
 ...S WHOTO(I,"IEN")=STATE("IEN")
"RTN","HLOAPI1",112,0)
 ...S WHOTO(I,"ERROR")=""
"RTN","HLOAPI1",113,0)
 ..E  D
"RTN","HLOAPI1",114,0)
 ...S WHOTO(I,"QUEUED")=0
"RTN","HLOAPI1",115,0)
 ...S WHOTO(I,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",116,0)
 ...S WHOTO(I,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",117,0)
 ...S RETURN=0
"RTN","HLOAPI1",118,0)
 .E  D  ;who not adequately determined
"RTN","HLOAPI1",119,0)
 ..S WHOTO(I,"QUEUED")=0,RETURN=0
"RTN","HLOAPI1",120,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",121,0)
 ..S WHOTO(I,"IEN")=$G(STATE("IEN")),WHOTO(I,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",122,0)
 K PARMS
"RTN","HLOAPI1",123,0)
 Q RETURN
"RTN","HLOAPI1",124,0)
 ;
"RTN","HLOAPI1",125,0)
SENDSUB(HLMSTATE,PARMS,MESSAGES) ;
"RTN","HLOAPI1",126,0)
 ;Sends the message to a list of receiving applications based on the HL7 Subscription Registry
"RTN","HLOAPI1",127,0)
 ;
"RTN","HLOAPI1",128,0)
 ;Input:
"RTN","HLOAPI1",129,0)
 ;  HLMSTATE (pass by reference, required) same as $$SENDMANY
"RTN","HLOAPI1",130,0)
 ;  PARMS (pass by reference, required) same as $$SENDMANY, with one additional subscript:
"RTN","HLOAPI1",131,0)
 ;    "SUBSCRIPTION IEN" - the ien of an entry in the HL7 Subscription Registry, defining the intended recipients of this message
"RTN","HLOAPI1",132,0)
 ;
"RTN","HLOAPI1",133,0)
 ;Output:
"RTN","HLOAPI1",134,0)
 ;  Function returns 1 if a message is queued to be sent to each intended recipient, 0 otherwise
"RTN","HLOAPI1",135,0)
 ;  PARMS - left undefined when the function returns
"RTN","HLOAPI1",136,0)
 ;  MESSAGES (pass by reference) returns the status of each message to be sent in this format, where subien is the ien of the recipient in the RECIPEINTS subfile of the HL7 Subscription Registry
"RTN","HLOAPI1",137,0)
 ;   (<subien>,"QUEUED")= <1 if queued to be sent, 0 otherwise)
"RTN","HLOAPI1",138,0)
 ;   (<subien>,"IEN")=<ien, file 778>
"RTN","HLOAPI1",139,0)
 ;   (<subien>,"ERROR")= error message if an error was encountered (status=0), not defined otherwise
"RTN","HLOAPI1",140,0)
 ;
"RTN","HLOAPI1",141,0)
 ;
"RTN","HLOAPI1",142,0)
 K MESSAGES
"RTN","HLOAPI1",143,0)
 N ERROR,RETURN,STATE,SUBIEN,WHO
"RTN","HLOAPI1",144,0)
 ;
"RTN","HLOAPI1",145,0)
 S RETURN=1
"RTN","HLOAPI1",146,0)
 ;
"RTN","HLOAPI1",147,0)
 ;
"RTN","HLOAPI1",148,0)
 I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) S ERROR="MESSAGE NOT YET CREATED" K PARMS Q 0
"RTN","HLOAPI1",149,0)
 I '$G(PARMS("SUBSCRIPTION IEN")) S ERROR="SUBSCRIPTION REGISTRY IEN NOT PROVIDED" K PARMS Q 0
"RTN","HLOAPI1",150,0)
 ;
"RTN","HLOAPI1",151,0)
 I '$$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERROR) D  K PARMS Q 0
"RTN","HLOAPI1",152,0)
 .S SUBIEN=0 F  S SUBIEN=$$NEXT^HLOASUB(PARMS("SUBSCRIPTION IEN"),.WHO) Q:'SUBIEN  D
"RTN","HLOAPI1",153,0)
 ..N SARY,HARY
"RTN","HLOAPI1",154,0)
 ..S HARY="STATE(""HDR"")"
"RTN","HLOAPI1",155,0)
 ..S SARY="STATE(""STATUS"")"
"RTN","HLOAPI1",156,0)
 ..K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",157,0)
 ..;move parameters into HLMSTATE
"RTN","HLOAPI1",158,0)
 ..S @SARY@("LINK IEN")=WHO("LINK IEN")
"RTN","HLOAPI1",159,0)
 ..S @SARY@("LINK NAME")=WHO("LINK NAME")
"RTN","HLOAPI1",160,0)
 ..S @HARY@("RECEIVING APPLICATION")=WHO("RECEIVING APPLICATION")
"RTN","HLOAPI1",161,0)
 ..M @HARY@("RECEIVING FACILITY")=WHO("RECEIVING FACILITY")
"RTN","HLOAPI1",162,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",163,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=0
"RTN","HLOAPI1",164,0)
 ..S MESSAGES(SUBIEN,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",165,0)
 ..S MESSAGES(SUBIEN,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",166,0)
 ;
"RTN","HLOAPI1",167,0)
 F  S SUBIEN=$$NEXT^HLOASUB(PARMS("SUBSCRIPTION IEN"),.WHO) Q:'SUBIEN  D
"RTN","HLOAPI1",168,0)
 .N SARY,HARY
"RTN","HLOAPI1",169,0)
 .S HARY="STATE(""HDR"")"
"RTN","HLOAPI1",170,0)
 .S SARY="STATE(""STATUS"")"
"RTN","HLOAPI1",171,0)
 .K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",172,0)
 .;move parameters into HLMSTATE
"RTN","HLOAPI1",173,0)
 .S @SARY@("LINK IEN")=WHO("LINK IEN")
"RTN","HLOAPI1",174,0)
 .S @SARY@("LINK NAME")=WHO("LINK NAME")
"RTN","HLOAPI1",175,0)
 .S @HARY@("RECEIVING APPLICATION")=WHO("RECEIVING APPLICATION")
"RTN","HLOAPI1",176,0)
 .M @HARY@("RECEIVING FACILITY")=WHO("RECEIVING FACILITY")
"RTN","HLOAPI1",177,0)
 .S ERROR=""
"RTN","HLOAPI1",178,0)
 .I $$SEND(.STATE,.ERROR) D
"RTN","HLOAPI1",179,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=1
"RTN","HLOAPI1",180,0)
 .E  D
"RTN","HLOAPI1",181,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=0,RETURN=0
"RTN","HLOAPI1",182,0)
 .S MESSAGES(SUBIEN,"IEN")=$G(STATE("IEN")),MESSAGES(SUBIEN,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",183,0)
 K PARMS
"RTN","HLOAPI1",184,0)
 Q RETURN
"RTN","HLOAPI1",185,0)
 ;
"RTN","HLOAPI1",186,0)
SEND(HLMSTATE,ERROR) ;
"RTN","HLOAPI1",187,0)
 ;
"RTN","HLOAPI1",188,0)
 K ERROR
"RTN","HLOAPI1",189,0)
 I HLMSTATE("UNSTORED LINES"),'$$SAVEMSG^HLOF777(.HLMSTATE) S ERROR="$$SAVE^HLOF777 FAILED!" Q 0
"RTN","HLOAPI1",190,0)
 ;
"RTN","HLOAPI1",191,0)
 I '$$SAVEMSG^HLOF778(.HLMSTATE) S ERROR="$$SAVE^HLOF778 FAILED!" Q 0
"RTN","HLOAPI1",192,0)
 D OUTQUE^HLOQUE(HLMSTATE("STATUS","LINK NAME"),$G(HLMSTATE("STATUS","PORT")),HLMSTATE("STATUS","QUEUE"),HLMSTATE("IEN"))
"RTN","HLOAPI1",193,0)
 Q HLMSTATE("IEN")
"RTN","HLOAPI1",194,0)
 ;
"RTN","HLOAPI1",195,0)
DONTSEND(HLMSTATE,ERROR) ;
"RTN","HLOAPI1",196,0)
 ;This procedure does NOT send a message.  Rather, it creates an entry in file 778 with the
"RTN","HLOAPI1",197,0)
 ;of "SE".  
"RTN","HLOAPI1",198,0)
 ;Input:
"RTN","HLOAPI1",199,0)
 ;       HLMSTATE - pass-by-reference
"RTN","HLOAPI1",200,0)
 ;       ERROR (optional, pass-by-value) error text to store with the message
"RTN","HLOAPI1",201,0)
 ;Output: none
"RTN","HLOAPI1",202,0)
 ;
"RTN","HLOAPI1",203,0)
 I HLMSTATE("UNSTORED LINES"),'$$SAVEMSG^HLOF777(.HLMSTATE) ; just continue
"RTN","HLOAPI1",204,0)
 ;
"RTN","HLOAPI1",205,0)
 S HLMSTATE("STATUS")="SE"
"RTN","HLOAPI1",206,0)
 S HLMSTATE("STATUS","PURGE")=$$FMADD^XLFDT(HLMSTATE("DT/TM CREATED"),HLMSTATE("SYSTEM","ERROR PURGE"))
"RTN","HLOAPI1",207,0)
 S HLMSTATE("STATUS","ERROR TEXT")=$G(ERROR)
"RTN","HLOAPI1",208,0)
 I '$$SAVEMSG^HLOF778(.HLMSTATE) ;already reported an error to the app
"RTN","HLOAPI1",209,0)
 Q
"RTN","HLOAPI1",210,0)
 ;
"RTN","HLOAPI1",211,0)
CHKWHO(HLMSTATE,WHOTO,ERROR) ;
"RTN","HLOAPI1",212,0)
 N RETURN,I
"RTN","HLOAPI1",213,0)
 S RETURN=1
"RTN","HLOAPI1",214,0)
 I '$$CHECKWHO^HLOASUB1(.WHOTO,.RETURN,.ERROR) S RETURN=0
"RTN","HLOAPI1",215,0)
 ;
"RTN","HLOAPI1",216,0)
 ;move parameters into HLMSTATE
"RTN","HLOAPI1",217,0)
 S HLMSTATE("STATUS","LINK IEN")=$G(RETURN("LINK IEN"))
"RTN","HLOAPI1",218,0)
 S HLMSTATE("STATUS","LINK NAME")=$G(RETURN("LINK NAME"))
"RTN","HLOAPI1",219,0)
 S HLMSTATE("STATUS","PORT")=$P($G(RETURN("RECEIVING FACILITY",2)),":",2)
"RTN","HLOAPI1",220,0)
 S HLMSTATE("HDR","RECEIVING APPLICATION")=$G(RETURN("RECEIVING APPLICATION"))
"RTN","HLOAPI1",221,0)
 F I=1:1:3 S HLMSTATE("HDR","RECEIVING FACILITY",I)=$G(RETURN("RECEIVING FACILITY",I))
"RTN","HLOAPI1",222,0)
 Q RETURN
"RTN","HLOAPI2")
0^2^B37390174^B37578775
"RTN","HLOAPI2",1,0)
HLOAPI2 ;ALB/CJM-HL7 - Developer API's for sending application acks ;12/11/2006
"RTN","HLOAPI2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131,133,134**;Oct 13, 1995;Build 30
"RTN","HLOAPI2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI2",4,0)
 ;
"RTN","HLOAPI2",5,0)
ACK(HLMSTATE,PARMS,ACK,ERROR) ;Default behavior is to return a general
"RTN","HLOAPI2",6,0)
 ;application ack. The application may optionally specify the message
"RTN","HLOAPI2",7,0)
 ;type and event or call $$ADDSEG^HLOAPI to add segments.
"RTN","HLOAPI2",8,0)
 ;A generic MSA segment (components 1-3) is added automatically IF the
"RTN","HLOAPI2",9,0)
 ;application doesn't call $$ADDSEG^HLOAPI to add an MSA segment as the
"RTN","HLOAPI2",10,0)
 ;FIRST segment following the header.
"RTN","HLOAPI2",11,0)
 ;$$SENDACK must be called when the ack is completed. The return
"RTN","HLOAPI2",12,0)
 ;destination is determined automatically from the original message
"RTN","HLOAPI2",13,0)
 ;
"RTN","HLOAPI2",14,0)
 ;This API should NOT be called for batch messages, use $$BATCHACK instead.
"RTN","HLOAPI2",15,0)
 ;Input:
"RTN","HLOAPI2",16,0)
 ;  HLMSTATE (pass by reference, required) the array obtained by calling $$STARTMSG^HLOPRS when parsing the original message 
"RTN","HLOAPI2",17,0)
 ;  PARMS (pass by reference) These subscripts may be defined:
"RTN","HLOAPI2",18,0)
 ;    "ACK CODE" (required) MSA1[ {AA,AE,AR}
"RTN","HLOAPI2",19,0)
 ;    "ERROR MESSAGE" - MSA3, should be used only if AE or AR
"RTN","HLOAPI2",20,0)
 ;    "ACCEPT ACK RESPONSE" - the <tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI2",21,0)
 ;    "ACCEPT ACK TYPE" - {AL,NE} (optional, defaults to AL)
"RTN","HLOAPI2",22,0)
 ;    "CONTINUATION POINTER" (optional)indicates a fragmented message
"RTN","HLOAPI2",23,0)
 ;    "COUNTRY" - the 3 character country code (optional)
"RTN","HLOAPI2",24,0)
 ;    "EVENT" - the 3 character event type (optional, defaults to the event code of the original message)
"RTN","HLOAPI2",25,0)
 ;     "ENCODING CHARACTERS" - the four HL7 encoding characters (optional,defaults to "^~\&"
"RTN","HLOAPI2",26,0)
 ;    "FAILURE RESPONSE" (optional) the <tag>^<routine> that the sending application routine should execute if the transmission of the message fails, i.e., the message can not be sent or a requested commit ack is not received.
"RTN","HLOAPI2",27,0)
 ;    "FIELD SEPARATOR" - field separator (optional, defaults to "|")
"RTN","HLOAPI2",28,0)
 ;    "MESSAGE TYPE" - if not defined, ACK is used
"RTN","HLOAPI2",29,0)
 ;    "MESSAGE STRUCTURE" (optional)
"RTN","HLOAPI2",30,0)
 ;    "QUEUE" - (optional) An application can name its own private queue (a string under 20 characters,namespaced). The default is the name of the queue of the original message
"RTN","HLOAPI2",31,0)
 ;    "SECURITY" (optional) security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI2",32,0)
 ;    "VERSION" - the HL7 Version ID (optional, defaults to 2.4)
"RTN","HLOAPI2",33,0)
 ;Output:
"RTN","HLOAPI2",34,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI2",35,0)
 ;  PARMS - left undefined when the function returns
"RTN","HLOAPI2",36,0)
 ;  ACK (pass by reference, required) the acknowledgment message being built.
"RTN","HLOAPI2",37,0)
 ;  ERROR (pass by reference) error msg
"RTN","HLOAPI2",38,0)
 N I,SEG,TOLINK,SUCCESS
"RTN","HLOAPI2",39,0)
 S SUCCESS=0,ERROR=""
"RTN","HLOAPI2",40,0)
 ;
"RTN","HLOAPI2",41,0)
 D
"RTN","HLOAPI2",42,0)
 .N PORT
"RTN","HLOAPI2",43,0)
 .I $G(PARMS("ACK CODE"))'="AA",$G(PARMS("ACK CODE"))'="AE",$G(PARMS("ACK CODE"))'="AR" S ERROR="INVALID ACK CODE" Q
"RTN","HLOAPI2",44,0)
 .;
"RTN","HLOAPI2",45,0)
 .I '$G(HLMSTATE("IEN")) S ERROR="ORIGINAL MESSAGE TO ACKNOWLEDGE IS NOT IDENTIFIED" Q
"RTN","HLOAPI2",46,0)
 .I $G(HLMSTATE("BATCH")) S ERROR="BATCH ACKNOWLEDGMENTS MUST USE $$BATCHACK^HLOAPI3" Q
"RTN","HLOAPI2",47,0)
 .;
"RTN","HLOAPI2",48,0)
 .I $G(HLMSTATE("HDR","MESSAGE CONTROL ID"))="" S ERROR="MESSAGE CONTROL ID MUST EXIST TO RETURN AN APPLICATION ACK" Q
"RTN","HLOAPI2",49,0)
 .S PARMS("MESSAGE TYPE")=$G(PARMS("MESSAGE TYPE"),"ACK")
"RTN","HLOAPI2",50,0)
 .S:PARMS("MESSAGE TYPE")="ACK" PARMS("MESSAGE STRUCTURE")="ACK"
"RTN","HLOAPI2",51,0)
 .S PARMS("EVENT")=$G(PARMS("EVENT"),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOAPI2",52,0)
 .I $$NEWMSG^HLOAPI(.PARMS,.ACK)  ;can't fail!
"RTN","HLOAPI2",53,0)
 .;
"RTN","HLOAPI2",54,0)
 .;if the return link can not be determined, the HL Logical Link file has a problem that must be fixed at the site
"RTN","HLOAPI2",55,0)
 .S PORT=$P(HLMSTATE("HDR","SENDING FACILITY",2),":",2)
"RTN","HLOAPI2",56,0)
 .S TOLINK=$$ACKLINK(.HLMSTATE)
"RTN","HLOAPI2",57,0)
 .I TOLINK="" S ERROR="TRANSMISSION LINK FOR APPLICATION ACK CANNOT BE DETERMINED" Q
"RTN","HLOAPI2",58,0)
 .I 'PORT S PORT=$$PORT2^HLOTLNK(TOLINK)
"RTN","HLOAPI2",59,0)
 .;
"RTN","HLOAPI2",60,0)
 .S ACK("HDR","APP ACK TYPE")="NE"
"RTN","HLOAPI2",61,0)
 .S ACK("HDR","ACCEPT ACK TYPE")=$G(PARMS("ACCEPT ACK TYPE"),"AL")
"RTN","HLOAPI2",62,0)
 .S ACK("STATUS","QUEUE")=$G(PARMS("QUEUE"),$G(HLMSTATE("STATUS","QUEUE")))
"RTN","HLOAPI2",63,0)
 .S ACK("STATUS","PORT")=PORT
"RTN","HLOAPI2",64,0)
 .S ACK("HDR","SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI2",65,0)
 .S ACK("HDR","SENDING APPLICATION")=$G(HLMSTATE("HDR","RECEIVING APPLICATION"))
"RTN","HLOAPI2",66,0)
 .S ACK("HDR","RECEIVING APPLICATION")=$G(HLMSTATE("HDR","SENDING APPLICATION"))
"RTN","HLOAPI2",67,0)
 .F I=1:1:3 S ACK("HDR","RECEIVING FACILITY",I)=$G(HLMSTATE("HDR","SENDING FACILITY",I))
"RTN","HLOAPI2",68,0)
 .S ACK("ACK TO","STATUS")=$S(PARMS("ACK CODE")="AA":"SU",1:"AE")
"RTN","HLOAPI2",69,0)
 .S ACK("ACK TO")=$G(HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOAPI2",70,0)
 .S ACK("ACK TO","IEN")=HLMSTATE("IEN")
"RTN","HLOAPI2",71,0)
 .S ACK("STATUS","LINK NAME")=TOLINK
"RTN","HLOAPI2",72,0)
 .S ACK("LINE COUNT")=0
"RTN","HLOAPI2",73,0)
 .S ACK("MSA")="MSA"_ACK("HDR","FIELD SEPARATOR")_PARMS("ACK CODE")_ACK("HDR","FIELD SEPARATOR")_$G(HLMSTATE("HDR","MESSAGE CONTROL ID"))_ACK("HDR","FIELD SEPARATOR")_$G(PARMS("ERROR MESSAGE"))
"RTN","HLOAPI2",74,0)
 .S SUCCESS=1
"RTN","HLOAPI2",75,0)
 K PARMS
"RTN","HLOAPI2",76,0)
 K:'SUCCESS ACK
"RTN","HLOAPI2",77,0)
 Q SUCCESS
"RTN","HLOAPI2",78,0)
 ;
"RTN","HLOAPI2",79,0)
SENDACK(ACK,ERROR) ;This is used to signal that an application acknowledgment is complete.
"RTN","HLOAPI2",80,0)
 ;Input:
"RTN","HLOAPI2",81,0)
 ;  ACK (pass by reference,required) An array that contains the acknowledgment msg
"RTN","HLOAPI2",82,0)
 ;Output:
"RTN","HLOAPI2",83,0)
 ; Function returns 1 on success, 0 on failure
"RTN","HLOAPI2",84,0)
 ; ERROR (pass by reference) error msg
"RTN","HLOAPI2",85,0)
 ;
"RTN","HLOAPI2",86,0)
 N SEG
"RTN","HLOAPI2",87,0)
 ;if the application added its own MSA, then the ACK("MSA") node was killed
"RTN","HLOAPI2",88,0)
 I $D(ACK("MSA")) S SEG(1)=ACK("MSA") D ADDSEG^HLOMSG(.ACK,.SEG)
"RTN","HLOAPI2",89,0)
 ;
"RTN","HLOAPI2",90,0)
 I $$SEND^HLOAPI1(.ACK,.ERROR) Q 1
"RTN","HLOAPI2",91,0)
 Q 0
"RTN","HLOAPI2",92,0)
 ;
"RTN","HLOAPI2",93,0)
ACKLINK(HLMSTATE) ;
"RTN","HLOAPI2",94,0)
 ;Finds the link to return the application ack to.
"RTN","HLOAPI2",95,0)
 N LINK
"RTN","HLOAPI2",96,0)
 S LINK=$$RTRNLNK^HLOAPP($G(HLMSTATE("HDR","RECEIVING APPLICATION")))
"RTN","HLOAPI2",97,0)
 Q:LINK]"" LINK
"RTN","HLOAPI2",98,0)
 S LINK=$$RTRNLNK^HLOTLNK($G(HLMSTATE("HDR","SENDING FACILITY",1)),$G(HLMSTATE("HDR","SENDING FACILITY",2)),$G(HLMSTATE("HDR","SENDING FACILITY",3)))
"RTN","HLOAPI2",99,0)
 Q LINK
"RTN","HLOAPI2",100,0)
 ;
"RTN","HLOAPI2",101,0)
CHKPARMS(HLMSTATE,PARMS,ERROR) ;
"RTN","HLOAPI2",102,0)
 N LEN,SARY,HARY
"RTN","HLOAPI2",103,0)
 ;
"RTN","HLOAPI2",104,0)
 ;shortcut to reference the header sub-array
"RTN","HLOAPI2",105,0)
 S HARY="HLMSTATE(""HDR"")"
"RTN","HLOAPI2",106,0)
 ;
"RTN","HLOAPI2",107,0)
 ;shortcut to reference the status sub-array
"RTN","HLOAPI2",108,0)
 S SARY="HLMSTATE(""STATUS"")"
"RTN","HLOAPI2",109,0)
 ;
"RTN","HLOAPI2",110,0)
 S ERROR=""
"RTN","HLOAPI2",111,0)
 I $G(PARMS("ACCEPT ACK TYPE"))="" S PARMS("ACCEPT ACK TYPE")="AL"
"RTN","HLOAPI2",112,0)
 I $G(PARMS("APP ACK TYPE"))="" S PARMS("APP ACK TYPE")="NE"
"RTN","HLOAPI2",113,0)
 I PARMS("ACCEPT ACK TYPE")'="NE",PARMS("ACCEPT ACK TYPE")'="AL" S ERROR="INVALID ACCEPT ACKNOWLEDGMENT TYPE"
"RTN","HLOAPI2",114,0)
 I PARMS("APP ACK TYPE")'="NE",PARMS("APP ACK TYPE")'="AL" S ERROR="INVALID APPLICATION ACKNOWLEDGMENT TYPE"
"RTN","HLOAPI2",115,0)
 S LEN=$L($G(PARMS("QUEUE")))
"RTN","HLOAPI2",116,0)
 I $G(PARMS("QUEUE"))["^" S ERROR="QUEUE NAME MAY NOT CONTAIN '^'"
"RTN","HLOAPI2",117,0)
 I LEN>20 S ERROR="QUEUE PARAMETER IS MAX 20 LENGTH",PARMS("QUEUE")=$E(PARMS("QUEUE"),1,20)
"RTN","HLOAPI2",118,0)
 I 'LEN S PARMS("QUEUE")="DEFAULT"
"RTN","HLOAPI2",119,0)
 I $G(PARMS("SENDING APPLICATION"))="" D
"RTN","HLOAPI2",120,0)
 .S ERROR="SENDING APPLICATION IS REQUIRED"
"RTN","HLOAPI2",121,0)
 .S PARMS("SENDING APPLICATION")=""
"RTN","HLOAPI2",122,0)
 E  D
"RTN","HLOAPI2",123,0)
 .I '$D(^HLD(779.2,"C",PARMS("SENDING APPLICATION"))) S ERROR="SENDING APPLICATION NOT FOUND IN THE HLO APPLICATION REGISTRY"
"RTN","HLOAPI2",124,0)
 ;
"RTN","HLOAPI2",125,0)
 ;move parameters into HLMSTATE
"RTN","HLOAPI2",126,0)
 S @HARY@("ACCEPT ACK TYPE")=PARMS("ACCEPT ACK TYPE")
"RTN","HLOAPI2",127,0)
 S @HARY@("APP ACK TYPE")=PARMS("APP ACK TYPE")
"RTN","HLOAPI2",128,0)
 S @HARY@("SENDING APPLICATION")=$E(PARMS("SENDING APPLICATION"),1,60)
"RTN","HLOAPI2",129,0)
 S @HARY@("SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI2",130,0)
 S @SARY@("APP ACK RESPONSE")=$G(PARMS("APP ACK RESPONSE"))
"RTN","HLOAPI2",131,0)
 S @SARY@("ACCEPT ACK RESPONSE")=$G(PARMS("ACCEPT ACK RESPONSE"))
"RTN","HLOAPI2",132,0)
 S @SARY@("FAILURE RESPONSE")=$G(PARMS("FAILURE RESPONSE"))
"RTN","HLOAPI2",133,0)
 S @SARY@("QUEUE")=PARMS("QUEUE")
"RTN","HLOAPI2",134,0)
 Q:$L(ERROR) 0
"RTN","HLOAPI2",135,0)
 Q 1
"RTN","HLOAPI2",136,0)
 ;
"RTN","HLOAPI2",137,0)
SETCODE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI2",138,0)
 ;Implements SETCNE and SETCWE
"RTN","HLOAPI2",139,0)
 ;
"RTN","HLOAPI2",140,0)
 N SUB,VAR
"RTN","HLOAPI2",141,0)
 Q:'$G(FIELD)
"RTN","HLOAPI2",142,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI2",143,0)
 I '$G(COMP) D
"RTN","HLOAPI2",144,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI2",145,0)
 E  D
"RTN","HLOAPI2",146,0)
 .S VAR="SUB"
"RTN","HLOAPI2",147,0)
 S @VAR=1,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ID"))
"RTN","HLOAPI2",148,0)
 S @VAR=2,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("TEXT"))
"RTN","HLOAPI2",149,0)
 S @VAR=3,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("SYSTEM"))
"RTN","HLOAPI2",150,0)
 S @VAR=4,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE ID"))
"RTN","HLOAPI2",151,0)
 S @VAR=5,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE TEXT"))
"RTN","HLOAPI2",152,0)
 S @VAR=6,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE SYSTEM"))
"RTN","HLOAPI2",153,0)
 S @VAR=7,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("SYSTEM VERSION"))
"RTN","HLOAPI2",154,0)
 S @VAR=8,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE SYSTEM VERSION"))
"RTN","HLOAPI2",155,0)
 S @VAR=9,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ORIGINAL TEXT"))
"RTN","HLOAPI2",156,0)
 Q
"RTN","HLOAPI3")
0^26^B45861231^B43853464
"RTN","HLOAPI3",1,0)
HLOAPI3 ;ALB/CJM-HL7 - Developer API's for sending application acks ;03/13/2007
"RTN","HLOAPI3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,133,134**;Oct 13, 1995;Build 30
"RTN","HLOAPI3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI3",4,0)
 ;
"RTN","HLOAPI3",5,0)
BATCHACK(HLMSTATE,PARMS,ACK,ERROR) ;Starts a batch message that is the response to a batch message. Individual acks are placed in the batch by calling $$ADDACK.
"RTN","HLOAPI3",6,0)
 ;$$SENDACK^HLOAPI2 must be called when the batch of acks is complete. The return destination is determined automatically from the original message.
"RTN","HLOAPI3",7,0)
 ;
"RTN","HLOAPI3",8,0)
 ;Input:
"RTN","HLOAPI3",9,0)
 ;  HLMSTATE (pass by reference, required) the array obtained by calling $$STARTMSG^HLOPRS when parsing the original message 
"RTN","HLOAPI3",10,0)
 ;  PARMS (optional, pass by reference) These subscripts may be defined:
"RTN","HLOAPI3",11,0)
 ;    "ACCEPT ACK RESPONSE")=<tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI3",12,0)
 ;    "ACCEPT ACK TYPE") = <AL,NE> (optional, defaults to AL)
"RTN","HLOAPI3",13,0)
 ;    "COUNTRY") - a 3 character country code from the HL7 standard table (optional)
"RTN","HLOAPI3",14,0)
 ;     "ENCODING CHARACTERS" - the 4 HL7 encoding characters (optional,defaults to "^~\&"
"RTN","HLOAPI3",15,0)
 ;    "FAILURE RESPONSE" (optional) the <tag>^<routine> that the sending application routine should execute if the transmission of the message fails, i.e., the message can not be sent or a requested commit ack is not received.
"RTN","HLOAPI3",16,0)
 ;     "FIELD SEPARATOR" - the field separator (optional, defaults to "|")
"RTN","HLOAPI3",17,0)
 ;     "QUEUE" (optional) An application can name a private queue (a string under 20 characters, namespaced). The default is the name of the queue of the original message
"RTN","HLOAPI3",18,0)
 ;     "SECURITY" - security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI3",19,0)
 ;    "VERSION" - the HL7 Version ID (optional, defaults to 2.4)
"RTN","HLOAPI3",20,0)
 ;Output:
"RTN","HLOAPI3",21,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",22,0)
 ;  PARMS - left undefined upon completion
"RTN","HLOAPI3",23,0)
 ;  ACK (pass by reference, required) the batch acknowledgment message being built.
"RTN","HLOAPI3",24,0)
 ;  ERROR (pass by reference) error message
"RTN","HLOAPI3",25,0)
 N I,TOLINK,SUCCESS
"RTN","HLOAPI3",26,0)
 S SUCCESS=0
"RTN","HLOAPI3",27,0)
 ;
"RTN","HLOAPI3",28,0)
 D
"RTN","HLOAPI3",29,0)
 .N PORT
"RTN","HLOAPI3",30,0)
 .I '$G(HLMSTATE("IEN")) S ERROR="ORIGINAL MESSAGE TO ACKNOWLEDGMENT IS NOT IDENTIFIED" Q
"RTN","HLOAPI3",31,0)
 .;if the return link can not be determined, the HL Logical Link file has a problem
"RTN","HLOAPI3",32,0)
 .S TOLINK=$$ACKLINK^HLOAPI2(.HLMSTATE)
"RTN","HLOAPI3",33,0)
 .I TOLINK="" S ERROR="TRANSMISSION LINK FOR APPLICATION ACK CANNOT BE DETERMINED" Q
"RTN","HLOAPI3",34,0)
 .S PORT=$P(HLMSTATE("HDR","SENDING FACILITY",2),":",2)
"RTN","HLOAPI3",35,0)
 .I 'PORT S PORT=$$PORT2^HLOTLNK(TOLINK)
"RTN","HLOAPI3",36,0)
 .;
"RTN","HLOAPI3",37,0)
 .I $$NEWBATCH^HLOAPI(.PARMS,.ACK)  ;can't fail!
"RTN","HLOAPI3",38,0)
 .S ACK("STATUS","QUEUE")=$G(PARMS("QUEUE"),$G(HLMSTATE("STATUS","QUEUE")))
"RTN","HLOAPI3",39,0)
 .S ACK("STATUS","PORT")=PORT
"RTN","HLOAPI3",40,0)
 .S ACK("HDR","SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI3",41,0)
 .S ACK("HDR","SENDING APPLICATION")=$G(HLMSTATE("HDR","RECEIVING APPLICATION"))
"RTN","HLOAPI3",42,0)
 .S ACK("HDR","RECEIVING APPLICATION")=$G(HLMSTATE("HDR","SENDING APPLICATION"))
"RTN","HLOAPI3",43,0)
 .F I=1:1:3 S ACK("HDR","RECEIVING FACILITY",I)=$G(HLMSTATE("HDR","SENDING FACILITY",I))
"RTN","HLOAPI3",44,0)
 .S ACK("HDR","APP ACK TYPE")="NE"
"RTN","HLOAPI3",45,0)
 .S ACK("HDR","ACCEPT ACK TYPE")=$G(PARMS("ACCEPT ACK TYPE"),"AL")
"RTN","HLOAPI3",46,0)
 .S ACK("ACK TO")=$G(HLMSTATE("HDR","BATCH CONTROL ID"))
"RTN","HLOAPI3",47,0)
 .S ACK("ACK TO","IEN")=HLMSTATE("IEN")
"RTN","HLOAPI3",48,0)
 .S ACK("ACK TO","BODY")=$G(HLMSTATE("BODY"))
"RTN","HLOAPI3",49,0)
 .S ACK("STATUS","LINK NAME")=TOLINK
"RTN","HLOAPI3",50,0)
 .S ACK("LINE COUNT")=0
"RTN","HLOAPI3",51,0)
 .S SUCCESS=1
"RTN","HLOAPI3",52,0)
 K PARMS
"RTN","HLOAPI3",53,0)
 Q SUCCESS
"RTN","HLOAPI3",54,0)
 ;
"RTN","HLOAPI3",55,0)
ADDACK(ACK,PARMS,ERROR) ;This API adds an application acknowledgment to a batch
"RTN","HLOAPI3",56,0)
 ;of acknowledgments that was started by calling $$BATCHACK.
"RTN","HLOAPI3",57,0)
 ;The Default behavior is to return a general application ack.
"RTN","HLOAPI3",58,0)
 ;The application may optionally specify the message
"RTN","HLOAPI3",59,0)
 ;type and event and/or call $$ADDSEG^HLOAPI to add segments.
"RTN","HLOAPI3",60,0)
 ;A generic MSA segment (components 1-3) will be added automatically
"RTN","HLOAPI3",61,0)
 ;if the application doesn't call $$ADDSEG^HLOAPI to add an MSA segment
"RTN","HLOAPI3",62,0)
 ;as the FIRST segment following the MSH segment.
"RTN","HLOAPI3",63,0)
 ;$$SENDACK^HLOAPI2 must be called when the batch is complete.
"RTN","HLOAPI3",64,0)
 ;
"RTN","HLOAPI3",65,0)
 ;Input:
"RTN","HLOAPI3",66,0)
 ;  ACK (pass by reference,required) the batch of acks that is being built 
"RTN","HLOAPI3",67,0)
 ;  PARMS (pass by reference) These subscripts may be defined:
"RTN","HLOAPI3",68,0)
 ;    "ACK CODE" (required) MSA1[ {AA,AE,AR}
"RTN","HLOAPI3",69,0)
 ;    "ERROR MESSAGE" (optional) MSA3, should be used only if AE or AR
"RTN","HLOAPI3",70,0)
 ;    "EVENT" - 3 character event type (optional, defaults to the event code of the original message)
"RTN","HLOAPI3",71,0)
 ;    "MESSAGE CONTROL ID" (required) this is the message control id of the original individual message within the batch which is being acknowledged
"RTN","HLOAPI3",72,0)
 ;    "MESSAGE STRUCTURE" (optional)
"RTN","HLOAPI3",73,0)
 ;    "MESSAGE TYPE" (optional, defaults to ACK)
"RTN","HLOAPI3",74,0)
 ;    "SECURITY" (optional) security information to include in the header segment SEQ 8
"RTN","HLOAPI3",75,0)
 ;Output:
"RTN","HLOAPI3",76,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",77,0)
 ;  ACK (pass by reference, required) The batch, updated with another ack
"RTN","HLOAPI3",78,0)
 ;  PARMS  - left undefined when this function returns
"RTN","HLOAPI3",79,0)
 ;  ERROR (pass by reference) error msg
"RTN","HLOAPI3",80,0)
 ;
"RTN","HLOAPI3",81,0)
 N SUB,SUCCESS
"RTN","HLOAPI3",82,0)
 S SUCCESS=0
"RTN","HLOAPI3",83,0)
 D
"RTN","HLOAPI3",84,0)
 .I $G(PARMS("ACK CODE"))'="AA",$G(PARMS("ACK CODE"))'="AE",$G(PARMS("ACK CODE"))'="AR" S ERROR="INVALID ACK CODE" Q
"RTN","HLOAPI3",85,0)
 .;
"RTN","HLOAPI3",86,0)
 .I $G(PARMS("MESSAGE CONTROL ID"))="" S ERROR="MESSAGE CONTROL ID MUST EXIST TO RETURN AN APPLICATION ACK" Q
"RTN","HLOAPI3",87,0)
 .S SUB=""
"RTN","HLOAPI3",88,0)
 .F  S SUB=$O(^HLB("AE",PARMS("MESSAGE CONTROL ID"),SUB)) Q:SUB=""  I $P(SUB,"^")=ACK("ACK TO","IEN"),$P(SUB,"^",2) S PARMS("ACK TO","IEN")=SUB Q
"RTN","HLOAPI3",89,0)
 .S PARMS("MESSAGE TYPE")=$G(PARMS("MESSAGE TYPE"),"ACK")
"RTN","HLOAPI3",90,0)
 .S:PARMS("MESSAGE TYPE")="ACK" PARMS("MESSAGE STRUCTURE")="ACK"
"RTN","HLOAPI3",91,0)
 .S PARMS("EVENT")=$G(PARMS("EVENT"))
"RTN","HLOAPI3",92,0)
 .I PARMS("EVENT")="",ACK("ACK TO","BODY"),$P(SUB,"^",2) S PARMS("EVENT")=$P($G(^HLA(ACK("ACK TO","BODY"),2,$P(SUB,"^",2),0)),"^",3)
"RTN","HLOAPI3",93,0)
 .S PARMS("ACK TO")=PARMS("MESSAGE CONTROL ID")
"RTN","HLOAPI3",94,0)
 .S PARMS("ACK TO","STATUS")=$S(PARMS("ACK CODE")="AA":"SU",1:"AE")
"RTN","HLOAPI3",95,0)
 .Q:'$$ADDMSG^HLOAPI(.ACK,.PARMS,.ERROR)
"RTN","HLOAPI3",96,0)
 .S ACK("MSA")="MSA|"_PARMS("ACK CODE")_"|"_PARMS("MESSAGE CONTROL ID")_"|"_$G(PARMS("ERROR MESSAGE"))
"RTN","HLOAPI3",97,0)
 .S SUCCESS=1
"RTN","HLOAPI3",98,0)
 K PARMS
"RTN","HLOAPI3",99,0)
 Q SUCCESS
"RTN","HLOAPI3",100,0)
 ;
"RTN","HLOAPI3",101,0)
RESEND(MSGIEN,ERROR) ;
"RTN","HLOAPI3",102,0)
 ;This message will re-transmit an out-going message. It copies a copy the message, reusing all the original parameters. Then the message is requeued.
"RTN","HLOAPI3",103,0)
 ;
"RTN","HLOAPI3",104,0)
 ;Input:
"RTN","HLOAPI3",105,0)
 ;  MSGIEN - the ien (file #778) of the message that is to be sent
"RTN","HLOAPI3",106,0)
 ;Output:
"RTN","HLOAPI3",107,0)
 ;  Function returns the ien of the message in file 778 on success, 0 on failure
"RTN","HLOAPI3",108,0)
 ;  ERROR (pass by reference, optional)an error message
"RTN","HLOAPI3",109,0)
 ;
"RTN","HLOAPI3",110,0)
 N MSG,SUB,HDR
"RTN","HLOAPI3",111,0)
 I '$$STARTMSG^HLOPRS(.MSG,MSGIEN) S ERROR="MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",112,0)
 I MSG("DIRECTION")'="OUT" S ERROR="MESSAGE IS NOT OUTGOING" Q 0
"RTN","HLOAPI3",113,0)
 I MSG("STATUS","LINK NAME")="" S ERROR="LINK NOT DEFINED" Q 0
"RTN","HLOAPI3",114,0)
 F SUB="ID","IEN","DT/TM","ACK BY","STATUS" S MSG(SUB)=""
"RTN","HLOAPI3",115,0)
 F SUB="PURGE" K MSG("STATUS",SUB)
"RTN","HLOAPI3",116,0)
 D GETSYS^HLOAPI(.MSG)
"RTN","HLOAPI3",117,0)
 I $$SAVEMSG^HLOF778(.MSG) D OUTQUE^HLOQUE(MSG("STATUS","LINK NAME"),$G(MSG("STATUS","PORT")),MSG("STATUS","QUEUE"),MSG("IEN")) Q +MSG("IEN")
"RTN","HLOAPI3",118,0)
 Q 0
"RTN","HLOAPI3",119,0)
 ;
"RTN","HLOAPI3",120,0)
SETPURGE(MSGIEN,TIME) ;
"RTN","HLOAPI3",121,0)
 ;Resets the purge date/time.
"RTN","HLOAPI3",122,0)
 ;Input:
"RTN","HLOAPI3",123,0)
 ;   MSGIEN (required) ien of the message, file #778
"RTN","HLOAPI3",124,0)
 ;   TIME (optional) dt/time to set the purge time to, defaults to NOW
"RTN","HLOAPI3",125,0)
 ;Output:
"RTN","HLOAPI3",126,0)
 ;   Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",127,0)
 N NODE,OLDTIME,HLDIR
"RTN","HLOAPI3",128,0)
 Q:'$G(MSGIEN) 0
"RTN","HLOAPI3",129,0)
 S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOAPI3",130,0)
 Q:NODE="" 0
"RTN","HLOAPI3",131,0)
 S OLDTIME=$P(NODE,"^",9)
"RTN","HLOAPI3",132,0)
 S:'$G(TIME) TIME=$$NOW^XLFDT
"RTN","HLOAPI3",133,0)
 S HLDIR=$S($E($P(NODE,"^",4))="I":"IN",1:"OUT")
"RTN","HLOAPI3",134,0)
 K:OLDTIME ^HLB("AD",HLDIR,OLDTIME,MSGIEN)
"RTN","HLOAPI3",135,0)
 S $P(^HLB(MSGIEN,0),"^",9)=TIME
"RTN","HLOAPI3",136,0)
 S ^HLB("AD",HLDIR,TIME,MSGIEN)=""
"RTN","HLOAPI3",137,0)
 Q 1
"RTN","HLOAPI3",138,0)
 ;
"RTN","HLOAPI3",139,0)
REPROC(MSGIEN,ERROR) ;
"RTN","HLOAPI3",140,0)
 ;This message will re-process an incoming message by placing it on an incoming queue. If successful the message will be purged.
"RTN","HLOAPI3",141,0)
 ;
"RTN","HLOAPI3",142,0)
 ;Input:
"RTN","HLOAPI3",143,0)
 ;  MSGIEN - the ien (file #778) of the message that is to be processed
"RTN","HLOAPI3",144,0)
 ;Output:
"RTN","HLOAPI3",145,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",146,0)
 ;  ERROR (pass by reference, optional) an error message
"RTN","HLOAPI3",147,0)
 ;
"RTN","HLOAPI3",148,0)
 N MSG,HDR,ACTION,QUEUE,FROM
"RTN","HLOAPI3",149,0)
 ;
"RTN","HLOAPI3",150,0)
 I '$$STARTMSG^HLOPRS(.MSG,MSGIEN) S ERROR="MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",151,0)
 I MSG("DIRECTION")'="IN" S ERROR="MESSAGE IS NOT INCOMING" Q 0
"RTN","HLOAPI3",152,0)
 M HDR=MSG("HDR")
"RTN","HLOAPI3",153,0)
 I $G(MSG("ACK TO"))]"" S ACTION=MSG("STATUS","APP ACK RESPONSE")
"RTN","HLOAPI3",154,0)
 I ACTION="",'$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE),$G(MSG("ACK TO"))="" S ERROR="RECEIVING APPLICATION NOT DEFINED"
"RTN","HLOAPI3",155,0)
 ;If this message references an earlier message, get the action specified by the original message
"RTN","HLOAPI3",156,0)
 I ACTION="",$G(MSG("ACK TO"))]"" D
"RTN","HLOAPI3",157,0)
 .N NODE,IEN
"RTN","HLOAPI3",158,0)
 .S IEN=$O(^HLB("B",$P(MSG("ACK TO"),"-"),0))
"RTN","HLOAPI3",159,0)
 .S:IEN NODE=$G(^HLB(IEN,0))
"RTN","HLOAPI3",160,0)
 .I ($P(NODE,"^",11)]"") S ACTION=$P(NODE,"^",10,11),QUEUE=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")
"RTN","HLOAPI3",161,0)
 I ACTION="" S ERROR="ORIGINAL MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",162,0)
 S FROM=$S(MSG("HDR","SENDING FACILITY",2)]"":MSG("HDR","SENDING FACILITY",2),1:MSG("HDR","SENDING FACILITY",1))
"RTN","HLOAPI3",163,0)
 D INQUE^HLOQUE(FROM,QUEUE,MSGIEN,ACTION,1)
"RTN","HLOAPI3",164,0)
 Q 1
"RTN","HLOAPI3",165,0)
 ;
"RTN","HLOAPI3",166,0)
PROCNOW(MSGIEN,PURGE,ERROR) ;
"RTN","HLOAPI3",167,0)
 ;This message will re-process an incoming message immediately.
"RTN","HLOAPI3",168,0)
 ;
"RTN","HLOAPI3",169,0)
 ;Input:
"RTN","HLOAPI3",170,0)
 ;  MSGIEN - the ien (file #778) of the message that is to be processed
"RTN","HLOAPI3",171,0)
 ;Output:
"RTN","HLOAPI3",172,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",173,0)
 ;  PURGE (optional) a date/time to purge the message
"RTN","HLOAPI3",174,0)
 ;  ERROR (pass by reference, optional) an error message
"RTN","HLOAPI3",175,0)
 ;
"RTN","HLOAPI3",176,0)
 N MSG,HDR,ACTION,MCODE,HLMSGIEN
"RTN","HLOAPI3",177,0)
 ;
"RTN","HLOAPI3",178,0)
 S ERROR=""
"RTN","HLOAPI3",179,0)
 I '$$STARTMSG^HLOPRS(.MSG,MSGIEN) S ERROR="MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",180,0)
 I MSG("DIRECTION")'="IN" S ERROR="MESSAGE IS NOT INCOMING" Q 0
"RTN","HLOAPI3",181,0)
 M HDR=MSG("HDR")
"RTN","HLOAPI3",182,0)
 I $G(MSG("ACK TO"))]"" S ACTION=MSG("STATUS","APP ACK RESPONSE")
"RTN","HLOAPI3",183,0)
 I ACTION="",'$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE),$G(MSG("ACK TO"))="" S ERROR="RECEIVING APPLICATION NOT DEFINED" Q 0
"RTN","HLOAPI3",184,0)
 ;If this message references an earlier message, get the action specified by the original message
"RTN","HLOAPI3",185,0)
 I $G(ACTION)="",$G(MSG("ACK TO IEN")) S ACTION=$P($G(^HLB(+MSG("ACK TO IEN"),0)),"^",10,11) I $P(ACTION,"^",2)="" S ERROR="ORIGINAL MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",186,0)
 D:$G(PURGE)
"RTN","HLOAPI3",187,0)
 .K:MSG("STATUS","PURGE") ^HLB("AD","IN",MSG("STATUS","PURGE"),MSGIEN)
"RTN","HLOAPI3",188,0)
 .S $P(^HLB(MSGIEN,0),"^",9)=PURGE
"RTN","HLOAPI3",189,0)
 .S ^HLB("AD","IN",PURGE,MSGIEN)=""
"RTN","HLOAPI3",190,0)
 .I $G(MSG("ACK TO IEN")),$D(^HLB(MSG("ACK TO IEN"),0)) K ^HLB("AD","OUT",MSG("STATUS","PURGE"),MSG("ACK TO IEN")) S $P(^HLB(MSG("ACK TO IEN"),0),"^",9)=PURGE,^HLB("AD","OUT",PURGE,MSG("ACK TO IEN"))=""
"RTN","HLOAPI3",191,0)
 S HLMSGIEN=MSGIEN
"RTN","HLOAPI3",192,0)
 S $P(^HLB(MSGIEN,0),"^",19)=1
"RTN","HLOAPI3",193,0)
 S MCODE="D "_ACTION
"RTN","HLOAPI3",194,0)
 X MCODE
"RTN","HLOAPI3",195,0)
 Q 1
"RTN","HLOAPI4")
0^3^B21664349^B22068040
"RTN","HLOAPI4",1,0)
HLOAPI4 ;ALB/CJM-HL7 - Developer API's for sending & receiving messages(continued) ;12/11/2006
"RTN","HLOAPI4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**131,134**;Oct 13, 1995;Build 30
"RTN","HLOAPI4",3,0)
 ;
"RTN","HLOAPI4",4,0)
SETTS(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",5,0)
 ;Sets a value that is a timestamp in FM format into the segment in HL7
"RTN","HLOAPI4",6,0)
 ;format. The degree of precision may be optionally specified. The
"RTN","HLOAPI4",7,0)
 ;inserted value will include the timezone if the input included the time.
"RTN","HLOAPI4",8,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",9,0)
 ;
"RTN","HLOAPI4",10,0)
 ;Input:
"RTN","HLOAPI4",11,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",12,0)
 ;  VALUE  (required)to be set into the segment
"RTN","HLOAPI4",13,0)
 ;  VALUE("PRECISION") (optional) If included, VALUE must be passed by
"RTN","HLOAPI4",14,0)
 ;       reference.  Allowed values are:
"RTN","HLOAPI4",15,0)
 ;           "S" - seconds (default value)
"RTN","HLOAPI4",16,0)
 ;           "M" - minutes
"RTN","HLOAPI4",17,0)
 ;           "H" - hours
"RTN","HLOAPI4",18,0)
 ;           "D" - days
"RTN","HLOAPI4",19,0)
 ;  FIELD - the sequence # of the field
"RTN","HLOAPI4",20,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",21,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating.
"RTN","HLOAPI4",22,0)
 ;Output: 
"RTN","HLOAPI4",23,0)
 ;   SEG array
"RTN","HLOAPI4",24,0)
 ;
"RTN","HLOAPI4",25,0)
 ;Example:
"RTN","HLOAPI4",26,0)
 ;    D SETTS^HLOAPI4(.SEG,$$NOW^XLFDT,1) will place the current date/time into the segment in the 1st field,1st occurence.  The timezone is included.
"RTN","HLOAPI4",27,0)
 ;
"RTN","HLOAPI4",28,0)
 ;
"RTN","HLOAPI4",29,0)
 N TIME
"RTN","HLOAPI4",30,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",31,0)
 Q:'$G(VALUE)
"RTN","HLOAPI4",32,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",33,0)
 S:'$G(COMP) COMP=1
"RTN","HLOAPI4",34,0)
 S TIME=$$FMTHL7^XLFDT(VALUE)
"RTN","HLOAPI4",35,0)
 I $D(VALUE("PRECISION")) D
"RTN","HLOAPI4",36,0)
 .N TZ
"RTN","HLOAPI4",37,0)
 .S TZ=""
"RTN","HLOAPI4",38,0)
 .I TIME["+" S TZ="+"_$P(TIME,"+",2)
"RTN","HLOAPI4",39,0)
 .E  I TIME["-" S TZ="-"_$P(TIME,"-",2)
"RTN","HLOAPI4",40,0)
 .I VALUE("PRECISION")="D" D
"RTN","HLOAPI4",41,0)
 ..S TIME=$E(TIME,1,8)_TZ
"RTN","HLOAPI4",42,0)
 .E  I VALUE("PRECISION")="H" D
"RTN","HLOAPI4",43,0)
 ..S TIME=$E($$LJ^XLFSTR(+TIME,10,0),1,10)_TZ
"RTN","HLOAPI4",44,0)
 .E  I VALUE("PRECISION")="M" D
"RTN","HLOAPI4",45,0)
 ..S TIME=$E($$LJ^XLFSTR(+TIME,12,0),1,12)_TZ
"RTN","HLOAPI4",46,0)
 .E  I VALUE("PRECISION")="S" D
"RTN","HLOAPI4",47,0)
 ..S TIME=$E($$LJ^XLFSTR(+TIME,14,0),1,14)_TZ
"RTN","HLOAPI4",48,0)
 S SEG(FIELD,REP,COMP,1)=TIME
"RTN","HLOAPI4",49,0)
 Q
"RTN","HLOAPI4",50,0)
 ;
"RTN","HLOAPI4",51,0)
SETDT(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",52,0)
 ;Sets a value that is a date in FM format into the segment in HL7 format.  The degree of precision may be optionally specified.
"RTN","HLOAPI4",53,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",54,0)
 ;
"RTN","HLOAPI4",55,0)
 ;Input:
"RTN","HLOAPI4",56,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",57,0)
 ;  VALUE  (required)the date to be set into the segment
"RTN","HLOAPI4",58,0)
 ;  VALUE("PRECISION") (optional) If included, VALUE must be passed by
"RTN","HLOAPI4",59,0)
 ;       reference.  Allowed values are:
"RTN","HLOAPI4",60,0)
 ;           "D" - day (default value)
"RTN","HLOAPI4",61,0)
 ;           "L" - month
"RTN","HLOAPI4",62,0)
 ;           "Y" - year
"RTN","HLOAPI4",63,0)
 ;  FIELD - the sequence # of the field
"RTN","HLOAPI4",64,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",65,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating.
"RTN","HLOAPI4",66,0)
 ;Output:
"RTN","HLOAPI4",67,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",68,0)
 ;
"RTN","HLOAPI4",69,0)
 ;Example:
"RTN","HLOAPI4",70,0)
 ;    D SETDT^HLOAPI4(.SEG,$$TODAY^XLFDT,1) will place the current date into segment in the 1st field,1st occurence.
"RTN","HLOAPI4",71,0)
 ;
"RTN","HLOAPI4",72,0)
 ;
"RTN","HLOAPI4",73,0)
 N TIME
"RTN","HLOAPI4",74,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",75,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",76,0)
 S:'$G(COMP) COMP=1
"RTN","HLOAPI4",77,0)
 S TIME=$$FMTHL7^XLFDT(VALUE)
"RTN","HLOAPI4",78,0)
 I $D(VALUE("PRECISION")) D
"RTN","HLOAPI4",79,0)
 .I VALUE("PRECISION")="Y" D
"RTN","HLOAPI4",80,0)
 ..S TIME=$E(TIME,1,4)
"RTN","HLOAPI4",81,0)
 .E  I VALUE("PRECISION")="L" D
"RTN","HLOAPI4",82,0)
 ..S TIME=$E(TIME,1,6)
"RTN","HLOAPI4",83,0)
 .E  I VALUE("PRECISION")="D" D
"RTN","HLOAPI4",84,0)
 ..S TIME=$E(TIME,1,8)
"RTN","HLOAPI4",85,0)
 S SEG(FIELD,REP,COMP,1)=TIME
"RTN","HLOAPI4",86,0)
 Q
"RTN","HLOAPI4",87,0)
 ;
"RTN","HLOAPI4",88,0)
SETCE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",89,0)
 ;Sets a value that is an HL7 Coded Element data type (HL7 Section Reference 2.9.3) into the segment in the specified field.
"RTN","HLOAPI4",90,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",91,0)
 ;
"RTN","HLOAPI4",92,0)
 ;Input:
"RTN","HLOAPI4",93,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",94,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",95,0)
 ;    "ID" - the identifier
"RTN","HLOAPI4",96,0)
 ;    "TEXT" - 
"RTN","HLOAPI4",97,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOAPI4",98,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOAPI4",99,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOAPI4",100,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOAPI4",101,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",102,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",103,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",104,0)
 ;Output: 
"RTN","HLOAPI4",105,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",106,0)
 ;
"RTN","HLOAPI4",107,0)
 N SUB,VAR
"RTN","HLOAPI4",108,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",109,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",110,0)
 I '$G(COMP) D
"RTN","HLOAPI4",111,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI4",112,0)
 E  D
"RTN","HLOAPI4",113,0)
 .S VAR="SUB"
"RTN","HLOAPI4",114,0)
 S @VAR=1,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ID"))
"RTN","HLOAPI4",115,0)
 S @VAR=2,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("TEXT"))
"RTN","HLOAPI4",116,0)
 S @VAR=3,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("SYSTEM"))
"RTN","HLOAPI4",117,0)
 S @VAR=4,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE ID"))
"RTN","HLOAPI4",118,0)
 S @VAR=5,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE TEXT"))
"RTN","HLOAPI4",119,0)
 S @VAR=6,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE SYSTEM"))
"RTN","HLOAPI4",120,0)
 Q
"RTN","HLOAPI4",121,0)
 ;
"RTN","HLOAPI4",122,0)
SETHD(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",123,0)
 ;Sets a value that is an HL7 Hierarchic Designator data type (HL7 Section Reference 2.9.21) into the segment in the specified field.
"RTN","HLOAPI4",124,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",125,0)
 ;
"RTN","HLOAPI4",126,0)
 ;Input:
"RTN","HLOAPI4",127,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",128,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",129,0)
 ;    "NAMESPACE ID"
"RTN","HLOAPI4",130,0)
 ;    "UNIVERSAL ID"
"RTN","HLOAPI4",131,0)
 ;    "UNIVERSAL ID TYPE"
"RTN","HLOAPI4",132,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",133,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",134,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",135,0)
 ;Output: 
"RTN","HLOAPI4",136,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",137,0)
 ;
"RTN","HLOAPI4",138,0)
 N SUB,VAR
"RTN","HLOAPI4",139,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",140,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",141,0)
 I '$G(COMP) D
"RTN","HLOAPI4",142,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI4",143,0)
 E  D
"RTN","HLOAPI4",144,0)
 .S VAR="SUB"
"RTN","HLOAPI4",145,0)
 S @VAR=1,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("NAMESPACE ID"))
"RTN","HLOAPI4",146,0)
 S @VAR=2,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("UNIVERSAL ID"))
"RTN","HLOAPI4",147,0)
 S @VAR=3,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("UNIVERSAL ID TYPE"))
"RTN","HLOAPI4",148,0)
 Q
"RTN","HLOAPI4",149,0)
 ;
"RTN","HLOAPI4",150,0)
SETCNE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",151,0)
 ;Sets a value that is an HL7 Coded With No Exceptions  data type (HL7 Section Reference 2.9.8) into the segment in the specified field.
"RTN","HLOAPI4",152,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",153,0)
 ;
"RTN","HLOAPI4",154,0)
 ;Input:
"RTN","HLOAPI4",155,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",156,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",157,0)
 ;    "ID" - the identifier
"RTN","HLOAPI4",158,0)
 ;    "TEXT" - 
"RTN","HLOAPI4",159,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOAPI4",160,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOAPI4",161,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOAPI4",162,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOAPI4",163,0)
 ;    "SYSTEM VERSION" - version ID of the coding system
"RTN","HLOAPI4",164,0)
 ;    "ALTERNATE SYSTEM VERSION" - version ID of the alternate coding system
"RTN","HLOAPI4",165,0)
 ;    "ORIGINAL TEXT"
"RTN","HLOAPI4",166,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",167,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",168,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",169,0)
 ;Output: 
"RTN","HLOAPI4",170,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",171,0)
 D SETCODE^HLOAPI2(.SEG,.VALUE,.FIELD,.COMP,.REP)
"RTN","HLOAPI4",172,0)
 Q
"RTN","HLOAPI4",173,0)
 ;
"RTN","HLOAPI4",174,0)
SETCWE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",175,0)
 ;Sets a value that is an HL7 Coded With Exceptions  data type (HL7 Section Reference 2.9.11) into the segment in the specified field.
"RTN","HLOAPI4",176,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",177,0)
 ;
"RTN","HLOAPI4",178,0)
 ;Input:
"RTN","HLOAPI4",179,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",180,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",181,0)
 ;    "ID" - the identifier
"RTN","HLOAPI4",182,0)
 ;    "TEXT" - 
"RTN","HLOAPI4",183,0)
 ;    "SYSTEM" - name of the code system
"RTN","HLOAPI4",184,0)
 ;    "ALTERNATE ID" - alternate identifier
"RTN","HLOAPI4",185,0)
 ;    "ALTERNATE TEXT"
"RTN","HLOAPI4",186,0)
 ;    "ALTERNATE SYSTEM" - name of the alternate coding system
"RTN","HLOAPI4",187,0)
 ;    "SYSTEM VERSION" - version ID of the coding system
"RTN","HLOAPI4",188,0)
 ;    "ALTERNATE SYSTEM VERSION" - version ID of the alternate coding system
"RTN","HLOAPI4",189,0)
 ;    "ORIGINAL TEXT"
"RTN","HLOAPI4",190,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",191,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",192,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",193,0)
 ;Output: 
"RTN","HLOAPI4",194,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",195,0)
 D SETCODE^HLOAPI2(.SEG,.VALUE,.FIELD,.COMP,.REP)
"RTN","HLOAPI4",196,0)
 Q
"RTN","HLOAPI4",197,0)
 ;
"RTN","HLOAPI4",198,0)
SETAD(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOAPI4",199,0)
 ;Sets an AD data type (Address, HL7 Section Reference 2.9.1) into the segment in the specified field. It can also be used to set the 1st 8 components of the XAD (Extended Address) data type.
"RTN","HLOAPI4",200,0)
 ;IF the component is specified, then the data type is 'demoted' to a component, and its components are 'demoted' to subcomponents.
"RTN","HLOAPI4",201,0)
 ;
"RTN","HLOAPI4",202,0)
 ;Input:
"RTN","HLOAPI4",203,0)
 ;  SEG - (required, pass by reference) The array where the seg is being built.
"RTN","HLOAPI4",204,0)
 ;  VALUE  (required, pass-by-reference) These subscripts may be passed:
"RTN","HLOAPI4",205,0)
 ;    "STREET1" -street address
"RTN","HLOAPI4",206,0)
 ;    "STREET2" - other designation
"RTN","HLOAPI4",207,0)
 ;    "CITY"
"RTN","HLOAPI4",208,0)
 ;    "STATE" - state or province
"RTN","HLOAPI4",209,0)
 ;    "ZIP" - zip or postal code
"RTN","HLOAPI4",210,0)
 ;    "COUNTRY"
"RTN","HLOAPI4",211,0)
 ;    "TYPE"  - address type
"RTN","HLOAPI4",212,0)
 ;    "OTHER" - other geographic designation
"RTN","HLOAPI4",213,0)
 ;  FIELD (required) the sequence # of the field
"RTN","HLOAPI4",214,0)
 ;  COMP (optional) If specified, the data type is 'demoted' to a component value.
"RTN","HLOAPI4",215,0)
 ;  REP - the occurrence# (optional, defaults to 1)  For a non-repeating fields, this parameter is not necessary.
"RTN","HLOAPI4",216,0)
 ;Output: 
"RTN","HLOAPI4",217,0)
 ;   SEG - segment that is being built
"RTN","HLOAPI4",218,0)
 ;
"RTN","HLOAPI4",219,0)
 N SUB,VAR
"RTN","HLOAPI4",220,0)
 Q:'$G(FIELD)
"RTN","HLOAPI4",221,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI4",222,0)
 I '$G(COMP) D
"RTN","HLOAPI4",223,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI4",224,0)
 E  D
"RTN","HLOAPI4",225,0)
 .S VAR="SUB"
"RTN","HLOAPI4",226,0)
 S @VAR=1,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("STREET1"))
"RTN","HLOAPI4",227,0)
 S @VAR=2,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("STREET2"))
"RTN","HLOAPI4",228,0)
 S @VAR=3,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("CITY"))
"RTN","HLOAPI4",229,0)
 S @VAR=4,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("STATE"))
"RTN","HLOAPI4",230,0)
 S @VAR=5,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ZIP"))
"RTN","HLOAPI4",231,0)
 S @VAR=6,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("COUNTRY"))
"RTN","HLOAPI4",232,0)
 S @VAR=7,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("TYPE"))
"RTN","HLOAPI4",233,0)
 S @VAR=8,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("OTHER"))
"RTN","HLOAPI4",234,0)
 Q
"RTN","HLOASUB1")
0^16^B62125339^B53189937
"RTN","HLOASUB1",1,0)
HLOASUB1 ;IRMFO-ALB/CJM - Subscription Registry (continued) ;02/26/2007
"RTN","HLOASUB1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134**;Oct 13, 1995;Build 30
"RTN","HLOASUB1",3,0)
 ;Per VHA Directive 10-93-142, this routine should not be modified.
"RTN","HLOASUB1",4,0)
 ;
"RTN","HLOASUB1",5,0)
INDEX(IEN,PARMARY) ;
"RTN","HLOASUB1",6,0)
 ;Allows an application to optionally index its subscriptions.
"RTN","HLOASUB1",7,0)
 ;so that it can find find them without storing the ien.
"RTN","HLOASUB1",8,0)
 ;
"RTN","HLOASUB1",9,0)
 ;Input:
"RTN","HLOASUB1",10,0)
 ;  IEN - ien of the entry
"RTN","HLOASUB1",11,0)
 ;  PARMARY (pass by reference) An array of up to 6 lookup values with
"RTN","HLOASUB1",12,0)
 ;which to build the index.  The format is: PARMARY(1)=<first parameter>,
"RTN","HLOASUB1",13,0)
 ; up to PARMARY(6)
"RTN","HLOASUB1",14,0)
 ;Output:
"RTN","HLOASUB1",15,0)
 ;  function returns 1 on success, 0 otherwise
"RTN","HLOASUB1",16,0)
 ;  PARMARY - left undefined
"RTN","HLOASUB1",17,0)
 ;
"RTN","HLOASUB1",18,0)
 N OWNER,I,NODE
"RTN","HLOASUB1",19,0)
 Q:'$G(IEN) 0
"RTN","HLOASUB1",20,0)
 S OWNER=$P($G(^HLD(779.4,IEN,0)),"^",2)
"RTN","HLOASUB1",21,0)
 Q:'$L(OWNER) 0
"RTN","HLOASUB1",22,0)
 D KILLAH(IEN)
"RTN","HLOASUB1",23,0)
 F I=1:1:6 S:'$L($G(PARMARY(I))) PARMARY(I)=" "
"RTN","HLOASUB1",24,0)
 D SETAH(IEN,OWNER,.PARMARY)
"RTN","HLOASUB1",25,0)
 S NODE=""
"RTN","HLOASUB1",26,0)
 F I=1:1:6 S NODE=NODE_$G(PARMARY(I))_"^"
"RTN","HLOASUB1",27,0)
 S ^HLD(779.4,IEN,3)=NODE
"RTN","HLOASUB1",28,0)
 K PARMARY
"RTN","HLOASUB1",29,0)
 Q 1
"RTN","HLOASUB1",30,0)
 ;
"RTN","HLOASUB1",31,0)
SETAH(IEN,OWNER,PARMS) ;
"RTN","HLOASUB1",32,0)
 Q:'$G(IEN)
"RTN","HLOASUB1",33,0)
 Q:'$L($G(OWNER))
"RTN","HLOASUB1",34,0)
 N INDEX
"RTN","HLOASUB1",35,0)
 S INDEX="^HLD(779.4,""AH"",OWNER,"
"RTN","HLOASUB1",36,0)
 F I=1:1:6 D
"RTN","HLOASUB1",37,0)
 .S:'$L($G(PARMS(I))) PARMS(I)=" "
"RTN","HLOASUB1",38,0)
 .S INDEX=INDEX_""""_PARMS(I)_""","
"RTN","HLOASUB1",39,0)
 S INDEX=$E(INDEX,1,$L(INDEX)-1)_")"
"RTN","HLOASUB1",40,0)
 S @INDEX=IEN
"RTN","HLOASUB1",41,0)
 Q
"RTN","HLOASUB1",42,0)
 ;
"RTN","HLOASUB1",43,0)
SETAH1(DA,OWNER,X1,X2,X3,X4,X5,X6) ;
"RTN","HLOASUB1",44,0)
 Q:'$G(DA)
"RTN","HLOASUB1",45,0)
 Q:'$L($G(OWNER))
"RTN","HLOASUB1",46,0)
 N PARMS,I
"RTN","HLOASUB1",47,0)
 F I=1:1:6 I $L($G(@("X"_I))) S PARMS(I)=@("X"_I)
"RTN","HLOASUB1",48,0)
 D SETAH(DA,OWNER,.PARMS)
"RTN","HLOASUB1",49,0)
 Q
"RTN","HLOASUB1",50,0)
 ;
"RTN","HLOASUB1",51,0)
KILLAH1(OWNER,LOOKUP1,LOOKUP2,LOOKUP3,LOOKUP4,LOOKUP5,LOOKUP6) ;
"RTN","HLOASUB1",52,0)
 Q:'$L(OWNER)
"RTN","HLOASUB1",53,0)
 N I,INDEX
"RTN","HLOASUB1",54,0)
 S INDEX="^HLD(779.4,""AH"",OWNER"
"RTN","HLOASUB1",55,0)
 F I=1:1:6 D
"RTN","HLOASUB1",56,0)
 .S:'$L($G(@("LOOKUP"_I))) @("LOOKUP"_I)=" "
"RTN","HLOASUB1",57,0)
 .S INDEX=INDEX_","_""""_@("LOOKUP"_I)_""""
"RTN","HLOASUB1",58,0)
 S INDEX=INDEX_")"
"RTN","HLOASUB1",59,0)
 K @INDEX
"RTN","HLOASUB1",60,0)
 Q
"RTN","HLOASUB1",61,0)
 ;
"RTN","HLOASUB1",62,0)
KILLAH(IEN) ;kills the AH x~ref on file 779.4 for a particular subscription registry entry=ien
"RTN","HLOASUB1",63,0)
 Q:'$G(IEN)
"RTN","HLOASUB1",64,0)
 N OWNER,X1,X2,X3,X4,X5,X6,I,NODE
"RTN","HLOASUB1",65,0)
 S OWNER=$P($G(^HLD(779.4,IEN,0)),"^",2)
"RTN","HLOASUB1",66,0)
 Q:'$L(OWNER)
"RTN","HLOASUB1",67,0)
 S NODE=$G(^HLD(779.4,IEN,3))
"RTN","HLOASUB1",68,0)
 F I=1:1:6 I $L($P(NODE,"^",I)) S @("X"_I)=$P(NODE,"^",I)
"RTN","HLOASUB1",69,0)
 D KILLAH1(OWNER,.X1,.X2,.X3,.X4,.X5,.X6)
"RTN","HLOASUB1",70,0)
 Q
"RTN","HLOASUB1",71,0)
 ;
"RTN","HLOASUB1",72,0)
FIND(OWNER,PARMARY) ;
"RTN","HLOASUB1",73,0)
 ;Allows an application to find a subscription
"RTN","HLOASUB1",74,0)
 ;list.  The application must maintain a private index in order to
"RTN","HLOASUB1",75,0)
 ;utilize this function, via $$INDEX^HLOASUB()
"RTN","HLOASUB1",76,0)
 ;
"RTN","HLOASUB1",77,0)
 ;Input:
"RTN","HLOASUB1",78,0)
 ;  OWNER - owning application name
"RTN","HLOASUB1",79,0)
 ;  PARMARY  **pass by reference** an array of up to 6 lookup value with which the index was built.  The format is: PARMARY(1)=<first parameter>, PARMARY(2)=<second parameter>  If PARMARY(i)=null, the parameter will be ignored
"RTN","HLOASUB1",80,0)
 ;Output:
"RTN","HLOASUB1",81,0)
 ;  function returns the ien of the subscription list if found, 0 otherwise
"RTN","HLOASUB1",82,0)
 ; PARMARY - left undefined
"RTN","HLOASUB1",83,0)
 ;
"RTN","HLOASUB1",84,0)
 N OK S OK=0
"RTN","HLOASUB1",85,0)
 ;
"RTN","HLOASUB1",86,0)
 D
"RTN","HLOASUB1",87,0)
 .Q:'$D(PARMARY)
"RTN","HLOASUB1",88,0)
 .Q:'$L($G(OWNER))
"RTN","HLOASUB1",89,0)
 .N INDEX,I
"RTN","HLOASUB1",90,0)
 .S INDEX="^HLD(779.4,""AH"",OWNER"
"RTN","HLOASUB1",91,0)
 .F I=1:1:6 D
"RTN","HLOASUB1",92,0)
 ..S:'$L($G(PARMARY(I))) PARMARY(I)=" "
"RTN","HLOASUB1",93,0)
 ..S INDEX=INDEX_","_""""_PARMARY(I)_""""
"RTN","HLOASUB1",94,0)
 .S INDEX=INDEX_")"
"RTN","HLOASUB1",95,0)
 .S OK=+$G(@INDEX)
"RTN","HLOASUB1",96,0)
 K PARMARY
"RTN","HLOASUB1",97,0)
 Q OK
"RTN","HLOASUB1",98,0)
 ;
"RTN","HLOASUB1",99,0)
UPD(FILE,DA,DATA,ERROR) ;File data into an existing record.
"RTN","HLOASUB1",100,0)
 ; Input:
"RTN","HLOASUB1",101,0)
 ;   FILE - File or sub-file number
"RTN","HLOASUB1",102,0)
 ;   DA - Traditional DA array, with same meaning.
"RTN","HLOASUB1",103,0)
 ;            Pass by reference.
"RTN","HLOASUB1",104,0)
 ;   DATA - Data array to file (pass by reference)
"RTN","HLOASUB1",105,0)
 ;          Format: DATA(<field #>)=<value>
"RTN","HLOASUB1",106,0)
 ;
"RTN","HLOASUB1",107,0)
 ; Output:
"RTN","HLOASUB1",108,0)
 ;  Function Value -     0=error and 1=no error
"RTN","HLOASUB1",109,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","HLOASUB1",110,0)
 ;
"RTN","HLOASUB1",111,0)
 ; Example: To update a record in subfile 2.0361 in record with ien=353,
"RTN","HLOASUB1",112,0)
 ;          subrecord ien=68, with the field .01 value = 21:
"RTN","HLOASUB1",113,0)
 ;    S DATA(.01)=21,DA=68,DA(1)=353 I $$UPD(2.0361,.DA,.DATA,.ERROR) W !,"DONE"
"RTN","HLOASUB1",114,0)
 ;
"RTN","HLOASUB1",115,0)
 N FDA,FIELD,IENS,ERRORS
"RTN","HLOASUB1",116,0)
 ;
"RTN","HLOASUB1",117,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","HLOASUB1",118,0)
 ;FDA - the FDA array as defined by FM
"RTN","HLOASUB1",119,0)
 ;
"RTN","HLOASUB1",120,0)
 I '$G(DA) S ERROR="IEN OF RECORD TO BE UPDATED NOT SPECIFIED" Q 0
"RTN","HLOASUB1",121,0)
 S IENS=$$IENS^DILF(.DA)
"RTN","HLOASUB1",122,0)
 S FIELD=0
"RTN","HLOASUB1",123,0)
 F  S FIELD=$O(DATA(FIELD)) Q:'FIELD  D
"RTN","HLOASUB1",124,0)
 .S FDA(FILE,IENS,FIELD)=$G(DATA(FIELD))
"RTN","HLOASUB1",125,0)
 D FILE^DIE("","FDA","ERRORS(1)")
"RTN","HLOASUB1",126,0)
 I +$G(DIERR) D
"RTN","HLOASUB1",127,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","HLOASUB1",128,0)
 E  D
"RTN","HLOASUB1",129,0)
 .S ERROR=""
"RTN","HLOASUB1",130,0)
 ;
"RTN","HLOASUB1",131,0)
 D CLEAN^DILF
"RTN","HLOASUB1",132,0)
 Q $S(+$G(DIERR):0,1:1)
"RTN","HLOASUB1",133,0)
 ;
"RTN","HLOASUB1",134,0)
ADD(FILE,DA,DATA,ERROR,IEN) ;
"RTN","HLOASUB1",135,0)
 ;Description: Creates a new record and files the data.
"RTN","HLOASUB1",136,0)
 ; Input:
"RTN","HLOASUB1",137,0)
 ;   FILE - File or sub-file number
"RTN","HLOASUB1",138,0)
 ;   DA - Traditional FileMan DA array with same
"RTN","HLOASUB1",139,0)
 ;            meaning. Pass by reference.  Only needed if adding to a
"RTN","HLOASUB1",140,0)
 ;            subfile.
"RTN","HLOASUB1",141,0)
 ;   DATA - Data array to file, pass by reference
"RTN","HLOASUB1",142,0)
 ;          Format: DATA(<field #>)=<value>
"RTN","HLOASUB1",143,0)
 ;   IEN - internal entry number to use (optional)
"RTN","HLOASUB1",144,0)
 ;
"RTN","HLOASUB1",145,0)
 ; Output:
"RTN","HLOASUB1",146,0)
 ;   Function Value - If no error then it returns the ien of the created record, else returns NULL.
"RTN","HLOASUB1",147,0)
 ;  DA - returns the ien of the new record, NULL if none created.  If needed, pass by reference.
"RTN","HLOASUB1",148,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","HLOASUB1",149,0)
 ;
"RTN","HLOASUB1",150,0)
 ; Example: To add a record in subfile 2.0361 in the record with ien=353
"RTN","HLOASUB1",151,0)
 ;          with the field .01 value = 21:
"RTN","HLOASUB1",152,0)
 ;  S DATA(.01)=21,DA(1)=353 I $$ADD(2.0361,.DA,.DATA) W !,"DONE"
"RTN","HLOASUB1",153,0)
 ;
"RTN","HLOASUB1",154,0)
 ; Example: If creating a record not in a subfile, would look like this:
"RTN","HLOASUB1",155,0)
 ;          S DATA(.01)=21 I $$ADD(867,,.DATA) W !,"DONE"
"RTN","HLOASUB1",156,0)
 ;
"RTN","HLOASUB1",157,0)
 N FDA,FIELD,IENA,IENS,ERRORS
"RTN","HLOASUB1",158,0)
 ;
"RTN","HLOASUB1",159,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","HLOASUB1",160,0)
 ;IENA - the Internal Entry Number Array defined by FM
"RTN","HLOASUB1",161,0)
 ;FDA - the FDA array defined by FM
"RTN","HLOASUB1",162,0)
 ;IEN - the ien of the new record
"RTN","HLOASUB1",163,0)
 ;
"RTN","HLOASUB1",164,0)
 S DA="+1"
"RTN","HLOASUB1",165,0)
 S IENS=$$IENS^DILF(.DA)
"RTN","HLOASUB1",166,0)
 S FIELD=0
"RTN","HLOASUB1",167,0)
 F  S FIELD=$O(DATA(FIELD)) Q:'FIELD  D
"RTN","HLOASUB1",168,0)
 .S FDA(FILE,IENS,FIELD)=$G(DATA(FIELD))
"RTN","HLOASUB1",169,0)
 I $G(IEN) S IENA(1)=IEN
"RTN","HLOASUB1",170,0)
 D UPDATE^DIE("","FDA","IENA","ERRORS(1)")
"RTN","HLOASUB1",171,0)
 I +$G(DIERR) D
"RTN","HLOASUB1",172,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","HLOASUB1",173,0)
 .S IEN=""
"RTN","HLOASUB1",174,0)
 E  D
"RTN","HLOASUB1",175,0)
 .S IEN=IENA(1)
"RTN","HLOASUB1",176,0)
 .S ERROR=""
"RTN","HLOASUB1",177,0)
 D CLEAN^DILF
"RTN","HLOASUB1",178,0)
 S DA=IEN
"RTN","HLOASUB1",179,0)
 Q IEN
"RTN","HLOASUB1",180,0)
 ;
"RTN","HLOASUB1",181,0)
DELETE(FILE,DA,ERROR)   ;Delete an existing record.
"RTN","HLOASUB1",182,0)
 N DATA
"RTN","HLOASUB1",183,0)
 S DATA(.01)="@"
"RTN","HLOASUB1",184,0)
 Q $$UPD(FILE,.DA,.DATA,.ERROR)
"RTN","HLOASUB1",185,0)
 Q
"RTN","HLOASUB1",186,0)
 ;
"RTN","HLOASUB1",187,0)
STATNUM(IEN) ;
"RTN","HLOASUB1",188,0)
 ;Description:  Given an ien to the Institution file, returns as the function value the station number. If IEN is NOT passed in, it assumes the local site.  Returns "" on failure.
"RTN","HLOASUB1",189,0)
 ;
"RTN","HLOASUB1",190,0)
 N STATION,RETURN
"RTN","HLOASUB1",191,0)
 S RETURN=""
"RTN","HLOASUB1",192,0)
 I $G(IEN) D
"RTN","HLOASUB1",193,0)
 .Q:'$D(^DIC(4,IEN,0))
"RTN","HLOASUB1",194,0)
 .S STATION=$P($$NNT^XUAF4(IEN),"^",2)
"RTN","HLOASUB1",195,0)
 .S RETURN=$S(+STATION:STATION,1:"")
"RTN","HLOASUB1",196,0)
 E  D
"RTN","HLOASUB1",197,0)
 .S RETURN=$P($$SITE^VASITE(),"^",3)
"RTN","HLOASUB1",198,0)
 Q RETURN
"RTN","HLOASUB1",199,0)
 ;
"RTN","HLOASUB1",200,0)
CHECKWHO(WHO,PARMS,ERROR) ;
"RTN","HLOASUB1",201,0)
 ;Checks the parameters provided in WHO() (see $$ADD).  They must resolve
"RTN","HLOASUB1",202,0)
 ;the link, receiving app and receiving facility.
"RTN","HLOASUB1",203,0)
 ;INPUT:
"RTN","HLOASUB1",204,0)
 ;  WHO - (required, pass by reference) - see $$ADD.
"RTN","HLOASUB1",205,0)
 ;
"RTN","HLOASUB1",206,0)
 ;  WHO("PORT") - if this is valued, it will be used as the remote port
"RTN","HLOASUB1",207,0)
 ;    to connect with rather than the port associated with the link
"RTN","HLOASUB1",208,0)
 ;Output:
"RTN","HLOASUB1",209,0)
 ;  Function returns 1 if the input is resolved successfully, 0 otherwise
"RTN","HLOASUB1",210,0)
 ;    PARMS - (pass by reference)  These subscripts are returned:
"RTN","HLOASUB1",211,0)
 ;     "LINK IEN" - ien of the link 
"RTN","HLOASUB1",212,0)
 ;     "LINK NAME" - name of the link
"RTN","HLOASUB1",213,0)
 ;     "RECEIVING APPLICATION"  - name of the receiving app
"RTN","HLOASUB1",214,0)
 ;     "RECEIVING FACILITY",1)  - component 1
"RTN","HLOASUB1",215,0)
 ;     "RECEIVING FACILITY",2) - component 2
"RTN","HLOASUB1",216,0)
 ;     "RECEIVING FACILITY",3) - component 3
"RTN","HLOASUB1",217,0)
 ;   ERROR - (pass by reference) - if unsuccessful, an error message is returned.
"RTN","HLOASUB1",218,0)
 ;
"RTN","HLOASUB1",219,0)
 N OK
"RTN","HLOASUB1",220,0)
 K ERROR
"RTN","HLOASUB1",221,0)
 S OK=1
"RTN","HLOASUB1",222,0)
 S PARMS("LINK IEN")="",PARMS("LINK NAME")=""
"RTN","HLOASUB1",223,0)
 ;must identify the receiving app
"RTN","HLOASUB1",224,0)
 ;
"RTN","HLOASUB1",225,0)
 D
"RTN","HLOASUB1",226,0)
 .N LEN
"RTN","HLOASUB1",227,0)
 .S LEN=$L($G(WHO("RECEIVING APPLICATION")))
"RTN","HLOASUB1",228,0)
 .I 'LEN S OK=0
"RTN","HLOASUB1",229,0)
 .E  I LEN>60 S OK=0
"RTN","HLOASUB1",230,0)
 .S:'OK ERROR="RECEIVING APPLICATION NOT VALID"
"RTN","HLOASUB1",231,0)
 .S PARMS("RECEIVING APPLICATION")=$G(WHO("RECEIVING APPLICATION"))
"RTN","HLOASUB1",232,0)
 ;
"RTN","HLOASUB1",233,0)
 ;find the station # if Institution ien known
"RTN","HLOASUB1",234,0)
 S:$G(WHO("INSTITUTION IEN")) WHO("STATION NUMBER")=$$STATNUM^HLOASUB1(WHO("INSTITUTION IEN"))
"RTN","HLOASUB1",235,0)
 ;
"RTN","HLOASUB1",236,0)
 ;if destination link specified by name, get its ien
"RTN","HLOASUB1",237,0)
 I '$G(WHO("FACILITY LINK IEN")),$L($G(WHO("FACILITY LINK NAME"))) S WHO("FACILITY LINK IEN")=$O(^HLCS(870,"B",WHO("FACILITY LINK NAME"),0))
"RTN","HLOASUB1",238,0)
 ;
"RTN","HLOASUB1",239,0)
 ;if destination link not specified, find it based on station #
"RTN","HLOASUB1",240,0)
 I +$G(WHO("STATION NUMBER")),'$G(WHO("FACILITY LINK IEN")) S WHO("FACILITY LINK IEN")=$$FINDLINK^HLOTLNK(WHO("STATION NUMBER"))
"RTN","HLOASUB1",241,0)
 ;
"RTN","HLOASUB1",242,0)
 ;if station # not known, find it based on destination link
"RTN","HLOASUB1",243,0)
 I '$G(WHO("STATION NUMBER")),$G(WHO("FACILITY LINK IEN")) S WHO("STATION NUMBER")=$$STATNUM^HLOTLNK(WHO("FACILITY LINK IEN"))
"RTN","HLOASUB1",244,0)
 ;
"RTN","HLOASUB1",245,0)
 S PARMS("RECEIVING FACILITY",1)=$G(WHO("STATION NUMBER"))
"RTN","HLOASUB1",246,0)
 ;
"RTN","HLOASUB1",247,0)
 ;if the destination link is known, get the domain
"RTN","HLOASUB1",248,0)
 S PARMS("RECEIVING FACILITY",2)=$S($G(WHO("FACILITY LINK IEN")):$$DOMAIN^HLOTLNK(WHO("FACILITY LINK IEN")),1:"")
"RTN","HLOASUB1",249,0)
 ;
"RTN","HLOASUB1",250,0)
 S PARMS("RECEIVING FACILITY",3)="DNS"
"RTN","HLOASUB1",251,0)
 ;
"RTN","HLOASUB1",252,0)
 ;find the link to send over - need name & ien
"RTN","HLOASUB1",253,0)
 I $G(WHO("IE LINK IEN")) D
"RTN","HLOASUB1",254,0)
 .S PARMS("LINK IEN")=WHO("IE LINK IEN")
"RTN","HLOASUB1",255,0)
 .S PARMS("LINK NAME")=$P($G(^HLCS(870,PARMS("LINK IEN"),0)),"^")
"RTN","HLOASUB1",256,0)
 .I OK,'$L(PARMS("LINK NAME")) S OK=0,ERROR="INTERFACE ENGINE LOGICAL LINK PROVIDED BUT NOT FOUND"
"RTN","HLOASUB1",257,0)
 E  I $L($G(WHO("IE LINK NAME"))) D
"RTN","HLOASUB1",258,0)
 .S PARMS("LINK NAME")=WHO("IE LINK NAME")
"RTN","HLOASUB1",259,0)
 .S PARMS("LINK IEN")=$O(^HLCS(870,"B",WHO("IE LINK NAME"),0))
"RTN","HLOASUB1",260,0)
 .I OK,'PARMS("LINK IEN") S OK=0,ERROR="INTERFACE ENGINE LOGICAL LINK PROVIDED BUT NOT FOUND"
"RTN","HLOASUB1",261,0)
 E  I $G(WHO("FACILITY LINK IEN")) D
"RTN","HLOASUB1",262,0)
 .S PARMS("LINK IEN")=WHO("FACILITY LINK IEN")
"RTN","HLOASUB1",263,0)
 .S PARMS("LINK NAME")=$P($G(^HLCS(870,PARMS("LINK IEN"),0)),"^")
"RTN","HLOASUB1",264,0)
 .I OK,'$L(PARMS("LINK NAME")) S OK=0,ERROR="RECEIVING FACILITY LOGICAL LINK NOT FOUND"
"RTN","HLOASUB1",265,0)
 E  I $L($G(WHO("FACILITY LINK NAME"))) D
"RTN","HLOASUB1",266,0)
 .S PARMS("LINK NAME")=WHO("FACILITY LINK NAME")
"RTN","HLOASUB1",267,0)
 .S PARMS("LINK IEN")=$O(^HLCS(870,"B",WHO("FACILITY LINK NAME"),0))
"RTN","HLOASUB1",268,0)
 .I OK,'PARMS("LINK IEN") S OK=0,ERROR="RECEIVING FACILITY LOGICAL LINK NOT FOUND"
"RTN","HLOASUB1",269,0)
 I OK,(('PARMS("LINK IEN"))!(PARMS("LINK NAME")="")) S OK=0,ERROR="LOGICAL LINK TO TRANSMIT OVER NOT SPECIFIED"
"RTN","HLOASUB1",270,0)
 ;
"RTN","HLOASUB1",271,0)
 ;need the station # or domain for msg header
"RTN","HLOASUB1",272,0)
 I OK,'$L(PARMS("RECEIVING FACILITY",2)),'PARMS("RECEIVING FACILITY",1) S OK=0,ERROR="RECEIVING FACILITY STATION # AND DOMAIN NOT SPECIFIED"
"RTN","HLOASUB1",273,0)
 ;
"RTN","HLOASUB1",274,0)
 ;append the port#
"RTN","HLOASUB1",275,0)
 I '$G(WHO("PORT")) S PARMS("RECEIVING FACILITY",2)=PARMS("RECEIVING FACILITY",2)_":"_$$PORT^HLOTLNK($G(WHO("FACILITY LINK IEN")))
"RTN","HLOASUB1",276,0)
 E  S PARMS("RECEIVING FACILITY",2)=PARMS("RECEIVING FACILITY",2)_":"_WHO("PORT")
"RTN","HLOASUB1",277,0)
 ;
"RTN","HLOASUB1",278,0)
 Q OK
"RTN","HLOCLNT")
0^15^B59494519^B57442573
"RTN","HLOCLNT",1,0)
HLOCLNT ;ALB/CJM- Client for sending messages - 10/4/94 1pm ;03/22/2007
"RTN","HLOCLNT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134**;Oct 13, 1995;Build 30
"RTN","HLOCLNT",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT",4,0)
 ;
"RTN","HLOCLNT",5,0)
 ;GET WORK function for the process running under the Process Manager
"RTN","HLOCLNT",6,0)
GETWORK(QUE) ;
"RTN","HLOCLNT",7,0)
 ;Input:
"RTN","HLOCLNT",8,0)
 ;  QUE - (pass by reference) These subscripts are used:
"RTN","HLOCLNT",9,0)
 ;    ("LINK")  - <link name>_":"_<port> last obtained
"RTN","HLOCLNT",10,0)
 ;    ("QUEUE") - name of the queue last obtained
"RTN","HLOCLNT",11,0)
 ;Output:
"RTN","HLOCLNT",12,0)
 ;  Function returns 1 if success, 0 if no more work
"RTN","HLOCLNT",13,0)
 ;  QUE -  updated to identify next queue of messages to process.
"RTN","HLOCLNT",14,0)
 ;    ("LINK") - <link name>_":"_<port>
"RTN","HLOCLNT",15,0)
 ;    ("QUEUE") - the named queue on the link
"RTN","HLOCLNT",16,0)
 ;    ("DOWN") - =1 means that the last OPEN attempt failed
"RTN","HLOCLNT",17,0)
 ;
"RTN","HLOCLNT",18,0)
 N LINK,QUEUE
"RTN","HLOCLNT",19,0)
 S LINK=$G(QUE("LINK")),QUEUE=$G(QUE("QUEUE"))
"RTN","HLOCLNT",20,0)
 I (LINK]""),(QUEUE]"") D
"RTN","HLOCLNT",21,0)
 .L -^HLB("QUEUE","OUT",LINK,QUEUE)
"RTN","HLOCLNT",22,0)
 .I '$$CNNCTD(LINK),$$FAILING(.LINK) S QUEUE="" Q
"RTN","HLOCLNT",23,0)
 .F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0  Q:$T
"RTN","HLOCLNT",24,0)
 I (LINK]""),(QUEUE="") D
"RTN","HLOCLNT",25,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",26,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",27,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",28,0)
 I LINK="" D
"RTN","HLOCLNT",29,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",30,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",31,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",32,0)
 S QUE("LINK")=LINK,QUE("QUEUE")=QUEUE,QUE("DOWN")=$G(LINK("DOWN"))
"RTN","HLOCLNT",33,0)
 Q:$L(QUEUE) 1
"RTN","HLOCLNT",34,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",35,0)
 Q 0
"RTN","HLOCLNT",36,0)
 ;
"RTN","HLOCLNT",37,0)
FAILING(LINK) ;
"RTN","HLOCLNT",38,0)
 ;Returns 1 if the link has failed in the last 30 seconds, 0 otherwise
"RTN","HLOCLNT",39,0)
 ;Also returns LINK("DOWN")=1 if the link was failing > 30 seconds ago, not yet known if its up
"RTN","HLOCLNT",40,0)
 ;
"RTN","HLOCLNT",41,0)
 N LASTTIME,SET
"RTN","HLOCLNT",42,0)
 S LINK("DOWN")=0
"RTN","HLOCLNT",43,0)
 S LASTTIME=$G(^HLB("QUEUE","OUT",LINK))
"RTN","HLOCLNT",44,0)
 S SET=$S(LASTTIME]"":1,1:0)
"RTN","HLOCLNT",45,0)
 I SET D
"RTN","HLOCLNT",46,0)
 .I $$HDIFF^XLFDT($H,LASTTIME,2)>30 S ^HLB("QUEUE","OUT",LINK)="",SET=0,LINK("DOWN")=1
"RTN","HLOCLNT",47,0)
 I $D(^HLTMP("FAILING LINKS",LINK)) S LINK("DOWN")=1
"RTN","HLOCLNT",48,0)
 Q SET
"RTN","HLOCLNT",49,0)
 ;
"RTN","HLOCLNT",50,0)
LINKDOWN(HLCSTATE) ;
"RTN","HLOCLNT",51,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",52,0)
 I $D(HLCSTATE("LINK","NAME")),$D(HLCSTATE("LINK","PORT")) D
"RTN","HLOCLNT",53,0)
 .S TO=HLCSTATE("LINK","NAME")_":"_HLCSTATE("LINK","PORT")
"RTN","HLOCLNT",54,0)
 .S ^HLB("QUEUE","OUT",TO)=$H
"RTN","HLOCLNT",55,0)
 .S:'$D(^HLTMP("FAILING LINKS",TO)) ^HLTMP("FAILING LINKS",TO)=$H
"RTN","HLOCLNT",56,0)
 Q
"RTN","HLOCLNT",57,0)
 ;
"RTN","HLOCLNT",58,0)
ERROR ;error trap
"RTN","HLOCLNT",59,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOCLNT",60,0)
 N HOUR
"RTN","HLOCLNT",61,0)
 S HOUR=$E($$NOW^XLFDT,1,10)
"RTN","HLOCLNT",62,0)
 S ^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2))=$G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))+1
"RTN","HLOCLNT",63,0)
 D END
"RTN","HLOCLNT",64,0)
 D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",65,0)
 ;
"RTN","HLOCLNT",66,0)
 I ($ECODE["TOOMANYFILES")!($ECODE["EDITED") Q:$QUIT "" Q
"RTN","HLOCLNT",67,0)
 ;while debugging quit on all errors - this will return the process to the Process Manager error trap
"RTN","HLOCLNT",68,0)
 I $G(^HLTMP("LOG ALL ERRORS")) Q:$QUIT "" Q
"RTN","HLOCLNT",69,0)
 ;
"RTN","HLOCLNT",70,0)
 ;don't log some common errors
"RTN","HLOCLNT",71,0)
 I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D
"RTN","HLOCLNT",72,0)
 .;
"RTN","HLOCLNT",73,0)
 E  D
"RTN","HLOCLNT",74,0)
 .;but do log all the others
"RTN","HLOCLNT",75,0)
 .D ^%ZTER
"RTN","HLOCLNT",76,0)
 ;
"RTN","HLOCLNT",77,0)
 ;a lot of errors of the same type may indicate an endless loop
"RTN","HLOCLNT",78,0)
 ;return to the Process Manager error trap
"RTN","HLOCLNT",79,0)
 I ($G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))>30) Q:$QUIT "" Q
"RTN","HLOCLNT",80,0)
 ;
"RTN","HLOCLNT",81,0)
 ;resume execution of the process manager executing the client
"RTN","HLOCLNT",82,0)
 D UNWIND^%ZTER
"RTN","HLOCLNT",83,0)
 Q
"RTN","HLOCLNT",84,0)
 ;
"RTN","HLOCLNT",85,0)
DOWORK(QUEUE) ;sends the messages on the queue
"RTN","HLOCLNT",86,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOCLNT"
"RTN","HLOCLNT",87,0)
 N MSGIEN,DEQUE,SUCCESS,MSGCOUNT
"RTN","HLOCLNT",88,0)
 S DEQUE=0
"RTN","HLOCLNT",89,0)
 S SUCCESS=1
"RTN","HLOCLNT",90,0)
 ;
"RTN","HLOCLNT",91,0)
 I '$$CNNCTD(QUEUE("LINK")),'$$CONNECT^HLOCLNT1($P(QUEUE("LINK"),":"),$P(QUEUE("LINK"),":",2),30,.HLCSTATE) Q
"RTN","HLOCLNT",92,0)
 ;
"RTN","HLOCLNT",93,0)
 S (MSGCOUNT,MSGIEN)=0
"RTN","HLOCLNT",94,0)
 F  S MSGIEN=$O(^HLB("QUEUE","OUT",QUEUE("LINK"),QUEUE("QUEUE"),MSGIEN)) Q:'MSGIEN  D  Q:'SUCCESS  Q:MSGCOUNT>1000
"RTN","HLOCLNT",95,0)
 .N UPDATE
"RTN","HLOCLNT",96,0)
 .S ^HLB(MSGIEN,"TRIES")=$G(^HLB(MSGIEN,"TRIES"))+1
"RTN","HLOCLNT",97,0)
 .S SUCCESS=0
"RTN","HLOCLNT",98,0)
 .S:$$TRANSMIT(.HLCSTATE,MSGIEN,.UPDATE) SUCCESS=1
"RTN","HLOCLNT",99,0)
 .Q:('SUCCESS)!('$D(UPDATE))
"RTN","HLOCLNT",100,0)
 .D DEQUE(.UPDATE)
"RTN","HLOCLNT",101,0)
 .S MSGCOUNT=MSGCOUNT+1
"RTN","HLOCLNT",102,0)
 .D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOCLNT",103,0)
 .;
"RTN","HLOCLNT",104,0)
 .;if the queue was on the down list, and not since shutdown, mark it as up, since a message has been successfully transmitted across it
"RTN","HLOCLNT",105,0)
 .I $G(QUEUE("DOWN"))!$$FAILING(QUEUE("LINK")),'$$IFSHUT^HLOTLNK(QUEUE("LINK")) S QUEUE("DOWN")=0,^HLB("QUEUE","OUT",QUEUE("LINK"))="" K ^HLTMP("FAILING LINKS",QUEUE("LINK"))
"RTN","HLOCLNT",106,0)
 ;
"RTN","HLOCLNT",107,0)
END D DEQUE()
"RTN","HLOCLNT",108,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOCLNT",109,0)
 Q
"RTN","HLOCLNT",110,0)
CNNCTD(LINK) ;
"RTN","HLOCLNT",111,0)
 ;Connected to LINK?  HLCSTATE must be defined, LINK=<link name>:<port>
"RTN","HLOCLNT",112,0)
 ;
"RTN","HLOCLNT",113,0)
 I ($G(HLCSTATE("LINK","NAME"))=$P(LINK,":")),($G(HLCSTATE("LINK","PORT"))=$P(LINK,":",2)),$G(HLCSTATE("CONNECTED")) Q 1
"RTN","HLOCLNT",114,0)
 Q 0
"RTN","HLOCLNT",115,0)
 ;
"RTN","HLOCLNT",116,0)
DEQUE(UPDATE) ;
"RTN","HLOCLNT",117,0)
 I $D(UPDATE) S DEQUE=DEQUE+1,DEQUE(+UPDATE)=$P(UPDATE,"^",2,99) S:$G(UPDATE("MSA"))]"" DEQUE(+UPDATE,"MSA")=UPDATE("MSA") S:$G(UPDATE("ACTION"))]"" DEQUE(+UPDATE,"ACTION")=UPDATE("ACTION")
"RTN","HLOCLNT",118,0)
 I '$D(UPDATE)!(DEQUE>15) D
"RTN","HLOCLNT",119,0)
 .N MSGIEN S MSGIEN=0
"RTN","HLOCLNT",120,0)
 .F  S MSGIEN=$O(DEQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOCLNT",121,0)
 ..N NODE,TIME
"RTN","HLOCLNT",122,0)
 ..D DEQUE^HLOQUE(QUEUE("LINK"),QUEUE("QUEUE"),"OUT",MSGIEN)
"RTN","HLOCLNT",123,0)
 ..S TIME=$P(DEQUE(MSGIEN),"^")
"RTN","HLOCLNT",124,0)
 ..Q:'TIME
"RTN","HLOCLNT",125,0)
 ..S NODE=QUEUE("LINK")_"^"_QUEUE("QUEUE")_"^"_$P(DEQUE(MSGIEN),"^",2,99)
"RTN","HLOCLNT",126,0)
 ..S ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN)=NODE
"RTN","HLOCLNT",127,0)
 ..S:$G(DEQUE(MSGIEN,"MSA"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"MSA")=DEQUE(MSGIEN,"MSA")
"RTN","HLOCLNT",128,0)
 ..S:$G(DEQUE(MSGIEN,"ACTION"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"ACTION")=DEQUE(MSGIEN,"ACTION")
"RTN","HLOCLNT",129,0)
 .K DEQUE S DEQUE=0
"RTN","HLOCLNT",130,0)
 Q
"RTN","HLOCLNT",131,0)
 ;
"RTN","HLOCLNT",132,0)
TRANSMIT(HLCSTATE,MSGIEN,UPDATE) ;
"RTN","HLOCLNT",133,0)
 ;Transmits a single message and if a commit ack was requested reads it.  Updates file 778 with the result.  Queues for the infiler the application accept action if one was requested.
"RTN","HLOCLNT",134,0)
 ;Input:
"RTN","HLOCLNT",135,0)
 ;   HLCSTATE (pass by reference)
"RTN","HLOCLNT",136,0)
 ;   MSGIEN - ien, file 778, of message to be transmitted
"RTN","HLOCLNT",137,0)
 ;Output:
"RTN","HLOCLNT",138,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT",139,0)
 ;  UPDATE - (pass by reference) to contain updates needed for message
"RTN","HLOCLNT",140,0)
 ;
"RTN","HLOCLNT",141,0)
 N HLMSTATE,MSA,HDR,SUCCESS
"RTN","HLOCLNT",142,0)
 ;
"RTN","HLOCLNT",143,0)
 S SUCCESS=0
"RTN","HLOCLNT",144,0)
 S HLCSTATE("ATTEMPT")=0
"RTN","HLOCLNT",145,0)
 ;
"RTN","HLOCLNT",146,0)
 ;start saving updates needed after the message is transmitted
"RTN","HLOCLNT",147,0)
 S UPDATE=MSGIEN
"RTN","HLOCLNT",148,0)
 Q:'$$GETMSG^HLOCLNT2(MSGIEN,.HLMSTATE) 1  ;returns 1 so the message will be removed from the queue
"RTN","HLOCLNT",149,0)
 I HLMSTATE("DT/TM"),HLMSTATE("STATUS","ACCEPTED")!(HLMSTATE("HDR","ACCEPT ACK TYPE")="NE") Q 1  ;the message was already transmitted
"RTN","HLOCLNT",150,0)
 ;
"RTN","HLOCLNT",151,0)
 S UPDATE=UPDATE_"^"_$$NOW^XLFDT
"RTN","HLOCLNT",152,0)
RETRY D
"RTN","HLOCLNT",153,0)
 .S HLCSTATE("ATTEMPT")=HLCSTATE("ATTEMPT")+1
"RTN","HLOCLNT",154,0)
 .I 'HLCSTATE("CONNECTED") D OPEN^HLOT(.HLCSTATE) Q:'HLCSTATE("CONNECTED")
"RTN","HLOCLNT",155,0)
 .;
"RTN","HLOCLNT",156,0)
 .;try to send the message
"RTN","HLOCLNT",157,0)
 .Q:'$$WRITEMSG^HLOCLNT1(.HLCSTATE,.HLMSTATE)
"RTN","HLOCLNT",158,0)
 .;does the message need an accept ack?
"RTN","HLOCLNT",159,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" D
"RTN","HLOCLNT",160,0)
 ..N FS
"RTN","HLOCLNT",161,0)
 ..Q:'$$READACK^HLOCLNT1(.HLCSTATE,.HDR,.MSA)
"RTN","HLOCLNT",162,0)
 ..;does the MSA refer to the correct control id?
"RTN","HLOCLNT",163,0)
 ..S FS=$E(HDR(1),4)
"RTN","HLOCLNT",164,0)
 ..Q:$P(MSA,FS,3)'=HLMSTATE("ID")
"RTN","HLOCLNT",165,0)
 ..N ACKID,ACKCODE
"RTN","HLOCLNT",166,0)
 ..S ACKCODE=$P(MSA,FS,2)
"RTN","HLOCLNT",167,0)
 ..S ACKID=$S($E(HDR(1),1,3)="MSH":$P(HDR(2),FS,5),1:$P(HDR(2),FS,6))
"RTN","HLOCLNT",168,0)
 ..S $P(UPDATE,"^",5)=1
"RTN","HLOCLNT",169,0)
 ..S UPDATE("MSA")=ACKID_"^"_MSA
"RTN","HLOCLNT",170,0)
 ..I '(ACKCODE="CA") S $P(UPDATE,"^",3)="SE",$P(UPDATE,"^",4)=2
"RTN","HLOCLNT",171,0)
 ..I ACKCODE="CA",HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=$S(HLMSTATE("BATCH"):"2",1:1)
"RTN","HLOCLNT",172,0)
 ..I ($P(UPDATE,"^",3)="SE") S $P(UPDATE,"^",6)=$P(HLMSTATE("HDR",1),FS,5) ;errors need the application for xref
"RTN","HLOCLNT",173,0)
 ..;
"RTN","HLOCLNT",174,0)
 ..;did the app request notification of accept ack?
"RTN","HLOCLNT",175,0)
 ..S UPDATE("ACTION")=HLMSTATE("ACCEPT ACK RESPONSE")
"RTN","HLOCLNT",176,0)
 ..S SUCCESS=1
"RTN","HLOCLNT",177,0)
 .E  D  ;accept ack wasn't requested
"RTN","HLOCLNT",178,0)
 ..S SUCCESS=1
"RTN","HLOCLNT",179,0)
 ..I HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=$S(HLMSTATE("BATCH"):2,1:1)
"RTN","HLOCLNT",180,0)
 ;
"RTN","HLOCLNT",181,0)
 I 'SUCCESS,'HLCSTATE("CONNECTED"),(HLCSTATE("ATTEMPT")<2) G RETRY
"RTN","HLOCLNT",182,0)
 I SUCCESS D
"RTN","HLOCLNT",183,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOCLNT",184,0)
 .;if this is an ack to a message need to purge the original message, so store its ien with the purge date
"RTN","HLOCLNT",185,0)
 .S:$G(HLMSTATE("ACK TO IEN")) $P(UPDATE,"^",4)=$P(UPDATE,"^",4)_"-"_HLMSTATE("ACK TO IEN")
"RTN","HLOCLNT",186,0)
 I ('HLCSTATE("CONNECTED"))!('SUCCESS) D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",187,0)
 Q SUCCESS
"RTN","HLOCLNT1")
0^9^B31098132^B28062817
"RTN","HLOCLNT1",1,0)
HLOCLNT1 ;IRMFO-ALB/CJM - Writing messages, reading acks;03/24/2004  14:43 ;03/19/2007
"RTN","HLOCLNT1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134**;Oct 13, 1995;Build 30
"RTN","HLOCLNT1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT1",4,0)
 ;
"RTN","HLOCLNT1",5,0)
 ;
"RTN","HLOCLNT1",6,0)
WRITEMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOCLNT1",7,0)
 ;Description:  This function uses the services offered by the transport layer to send a message over an open communication channel.
"RTN","HLOCLNT1",8,0)
 ;
"RTN","HLOCLNT1",9,0)
 ;Input:
"RTN","HLOCLNT1",10,0)
 ;  HLCSTATE (pass by reference, required) Defines the LLP & its state
"RTN","HLOCLNT1",11,0)
 ;  HLMSTATE (pass by reference, required) The message
"RTN","HLOCLNT1",12,0)
 ;Output:
"RTN","HLOCLNT1",13,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT1",14,0)
 ;
"RTN","HLOCLNT1",15,0)
 N SEG,QUIT,HDR
"RTN","HLOCLNT1",16,0)
 S QUIT=0
"RTN","HLOCLNT1",17,0)
 Q:'$G(HLMSTATE("IEN")) 0
"RTN","HLOCLNT1",18,0)
 S HDR(1)=HLMSTATE("HDR",1),HDR(2)=HLMSTATE("HDR",2)
"RTN","HLOCLNT1",19,0)
 Q:'$$WRITEHDR^HLOT(.HLCSTATE,.HDR) 0
"RTN","HLOCLNT1",20,0)
 I HLMSTATE("BATCH") D
"RTN","HLOCLNT1",21,0)
 .N LAST S LAST=0
"RTN","HLOCLNT1",22,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0
"RTN","HLOCLNT1",23,0)
 .F  Q:'$$NEXTMSG^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",24,0)
 ..S LAST=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOCLNT1",25,0)
 ..I '$$WRITESEG^HLOT(.HLCSTATE,.SEG) S QUIT=1 Q
"RTN","HLOCLNT1",26,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",27,0)
 ...I '$$WRITESEG^HLOT(.HLCSTATE,.SEG) S QUIT=1 Q
"RTN","HLOCLNT1",28,0)
 .K SEG S SEG(1)="BTS"_HLMSTATE("HDR","FIELD SEPARATOR")_LAST
"RTN","HLOCLNT1",29,0)
 .S:'$$WRITESEG^HLOT(.HLCSTATE,.SEG) QUIT=1
"RTN","HLOCLNT1",30,0)
 E  D
"RTN","HLOCLNT1",31,0)
 .F  Q:'$$HLNEXT^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",32,0)
 ..S:'$$WRITESEG^HLOT(.HLCSTATE,.SEG) QUIT=1
"RTN","HLOCLNT1",33,0)
 S:'$$ENDMSG^HLOT(.HLCSTATE) QUIT=1
"RTN","HLOCLNT1",34,0)
 Q 'QUIT
"RTN","HLOCLNT1",35,0)
 ;
"RTN","HLOCLNT1",36,0)
READACK(HLCSTATE,HDR,MSA) ;
"RTN","HLOCLNT1",37,0)
 ;Description:  This function uses the services offered by the transport layer to read an accept ack.
"RTN","HLOCLNT1",38,0)
 ;
"RTN","HLOCLNT1",39,0)
 ;Input:
"RTN","HLOCLNT1",40,0)
 ;  HLCSTATE (pass by reference, required) Defines the communication channel and its state.
"RTN","HLOCLNT1",41,0)
 ;Output:
"RTN","HLOCLNT1",42,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT1",43,0)
 ;  HDR (pass by reference) the message header:
"RTN","HLOCLNT1",44,0)
 ;   HDR(1) is components 1-6
"RTN","HLOCLNT1",45,0)
 ;   HDR(2) is components 7-end
"RTN","HLOCLNT1",46,0)
 ;  MSA (pass by reference) the MSA segment as an unsubscripted variable
"RTN","HLOCLNT1",47,0)
 ;
"RTN","HLOCLNT1",48,0)
 N SEG
"RTN","HLOCLNT1",49,0)
 K HDR,MSA,MAX,I
"RTN","HLOCLNT1",50,0)
 S MAX=HLCSTATE("SYSTEM","MAXSTRING")-40 ;MAX is the maximum that can be safely stored on a node, leaving room for the other fields stored with MSA seg
"RTN","HLOCLNT1",51,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.HDR) 0
"RTN","HLOCLNT1",52,0)
 F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOCLNT1",53,0)
 .I $E($E(SEG(1),1,3)_$E($G(SEG(2)),1,3),1,3)="MSA" D
"RTN","HLOCLNT1",54,0)
 ..S MSA=""
"RTN","HLOCLNT1",55,0)
 ..F I=1:1 Q:'$D(SEG(I))  S MSA=MSA_$S((MAX-$L(MSA))<1:"",1:$E(SEG(I),1,MAX))
"RTN","HLOCLNT1",56,0)
 I $D(MSA),HLCSTATE("MESSAGE ENDED") D  Q 1
"RTN","HLOCLNT1",57,0)
 .D SPLITHDR^HLOSRVR1(.HDR)
"RTN","HLOCLNT1",58,0)
 .S HLCSTATE("COUNTS","ACKS")=$G(HLCSTATE("COUNTS","ACKS"))+1
"RTN","HLOCLNT1",59,0)
 Q 0
"RTN","HLOCLNT1",60,0)
 ;
"RTN","HLOCLNT1",61,0)
CONNECT(LINK,PORT,TIMEOUT,HLCSTATE) ;
"RTN","HLOCLNT1",62,0)
 ;sets up HLCSTATE() and opens a client connection
"RTN","HLOCLNT1",63,0)
 ;Input:
"RTN","HLOCLNT1",64,0)
 ;  LINK - name of the link to connect to
"RTN","HLOCLNT1",65,0)
 ;  PORT (optional) port # to connect to, defaults to that specified by the link
"RTN","HLOCLNT1",66,0)
 ;  TIMEOUT (optional) specifies the open timeout in seconds, defaults to 30
"RTN","HLOCLNT1",67,0)
 ;Output:
"RTN","HLOCLNT1",68,0)
 ;   HLCSTATE - array to hold the connection state
"RTN","HLOCLNT1",69,0)
 ;
"RTN","HLOCLNT1",70,0)
 I $G(HLCSTATE("CONNECTED")) D  Q:HLCSTATE("CONNECTED")
"RTN","HLOCLNT1",71,0)
 .I $G(HLCSTATE("LINK","NAME"))]"",($G(HLCSTATE("LINK","NAME"))'=LINK) D CLOSE^HLOT(.HLCSTATE) Q
"RTN","HLOCLNT1",72,0)
 .I $G(HLCSTATE("LINK","NAME"))]"",$G(PORT),($G(HLCSTATE("LINK","PORT"))'=PORT) D CLOSE^HLOT(.HLCSTATE) Q
"RTN","HLOCLNT1",73,0)
 .I (HLCSTATE("SYSTEM","OS")="CACHE") D  Q
"RTN","HLOCLNT1",74,0)
 ..U HLCSTATE("DEVICE") S HLCSTATE("CONNECTED")=($ZA\8192#2)
"RTN","HLOCLNT1",75,0)
 ..I 'HLCSTATE("CONNECTED") D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",76,0)
 .;D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",77,0)
 K HLCSTATE
"RTN","HLOCLNT1",78,0)
 N ARY,NODE
"RTN","HLOCLNT1",79,0)
 I '$$GETLINK^HLOTLNK(LINK,.ARY) S HLCSTATE("LINK","NAME")=LINK,HLCSTATE("LINK","PORT")=$G(PORT) D LINKDOWN^HLOCLNT(.HLCSTATE) Q 0
"RTN","HLOCLNT1",80,0)
 M HLCSTATE("LINK")=ARY
"RTN","HLOCLNT1",81,0)
 I HLCSTATE("LINK","SHUTDOWN") S HLCSTATE("CONNECTED")=0 D LINKDOWN^HLOCLNT(.HLCSTATE) Q 0
"RTN","HLOCLNT1",82,0)
 ;overlay the port if supplied from the queue
"RTN","HLOCLNT1",83,0)
 S:$G(PORT) HLCSTATE("LINK","PORT")=PORT
"RTN","HLOCLNT1",84,0)
 S HLCSTATE("READ TIMEOUT")=20
"RTN","HLOCLNT1",85,0)
 S HLCSTATE("OPEN TIMEOUT")=$S($G(TIMEOUT):TIMEOUT,1:30)
"RTN","HLOCLNT1",86,0)
 S HLCSTATE("COUNTS")=0
"RTN","HLOCLNT1",87,0)
 S HLCSTATE("READ")="" ;where the reads are stored
"RTN","HLOCLNT1",88,0)
 ;
"RTN","HLOCLNT1",89,0)
 ;HLCSTATE("BUFFER",<seg>,<line>) serves as a write buffer so that a lot can be written all at once
"RTN","HLOCLNT1",90,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of BYTES in buffer
"RTN","HLOCLNT1",91,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOCLNT1",92,0)
 ;
"RTN","HLOCLNT1",93,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOCLNT1",94,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOCLNT1",95,0)
 S HLCSTATE("SERVER")=0
"RTN","HLOCLNT1",96,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOCLNT1",97,0)
 I HLCSTATE("SYSTEM","OS")="" D LINKDOWN^HLOCLNT(.HLCSTATE) Q 0
"RTN","HLOCLNT1",98,0)
 D
"RTN","HLOCLNT1",99,0)
 .N SYS
"RTN","HLOCLNT1",100,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOCLNT1",101,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOCLNT1",102,0)
 .S HLCSTATE("SYSTEM","MAXSTRING")=SYS("MAXSTRING")
"RTN","HLOCLNT1",103,0)
 .S HLCSTATE("SYSTEM","NORMAL PURGE")=SYS("NORMAL PURGE")
"RTN","HLOCLNT1",104,0)
 .S HLCSTATE("SYSTEM","ERROR PURGE")=SYS("ERROR PURGE")
"RTN","HLOCLNT1",105,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOCLNT1",106,0)
 .S HLCSTATE("OPEN")="OPEN^HLOTCP"
"RTN","HLOCLNT1",107,0)
 E  ;no other LLP implemented
"RTN","HLOCLNT1",108,0)
 D OPEN^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",109,0)
 ;
"RTN","HLOCLNT1",110,0)
 ;mark the failure time for the link so other processes know not to try for a while
"RTN","HLOCLNT1",111,0)
 I 'HLCSTATE("CONNECTED") D LINKDOWN^HLOCLNT(.HLCSTATE)
"RTN","HLOCLNT1",112,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOCLNT1",113,0)
 ;
"RTN","HLOCLNT1",114,0)
BADMSGS(WORK) ;
"RTN","HLOCLNT1",115,0)
 ;finds messages that won't transmit after 8 hours of trying and takes them off the outgoing queue
"RTN","HLOCLNT1",116,0)
 N LINK
"RTN","HLOCLNT1",117,0)
 S LINK=""
"RTN","HLOCLNT1",118,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D
"RTN","HLOCLNT1",119,0)
 .N TIME,QUE,COUNT
"RTN","HLOCLNT1",120,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOCLNT1",121,0)
 .Q:$$HDIFF^XLFDT($H,TIME,2)<28800  ;8 hours
"RTN","HLOCLNT1",122,0)
 .Q:'$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOCLNT1",123,0)
 .L +^HLB("QUEUE","OUT",LINK):0
"RTN","HLOCLNT1",124,0)
 .S QUE=""
"RTN","HLOCLNT1",125,0)
 .F  S QUE=$O(^HLB("QUEUE","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOCLNT1",126,0)
 ..N MSG S MSG=0
"RTN","HLOCLNT1",127,0)
 ..S MSG=$O(^HLB("QUEUE","OUT",LINK,QUE,MSG))
"RTN","HLOCLNT1",128,0)
 ..Q:'MSG
"RTN","HLOCLNT1",129,0)
 ..S COUNT=$G(^HLB(MSG,"TRIES"))
"RTN","HLOCLNT1",130,0)
 ..I COUNT>20 D
"RTN","HLOCLNT1",131,0)
 ...N NODE0,NODE1,NODE2,TIME,RAPP,SAPP,FS,CS,ACTION,MTYPE,EVENT
"RTN","HLOCLNT1",132,0)
 ...S NODE0=$G(^HLB(MSG,0))
"RTN","HLOCLNT1",133,0)
 ...Q:'$P(NODE0,"^",2)
"RTN","HLOCLNT1",134,0)
 ...S TIME=$$NOW^XLFDT
"RTN","HLOCLNT1",135,0)
 ...S NODE1=$G(^HLB(MSG,1))
"RTN","HLOCLNT1",136,0)
 ...S NODE2=$G(^HLB(MSG,2))
"RTN","HLOCLNT1",137,0)
 ...S FS=$E(NODE1,4)
"RTN","HLOCLNT1",138,0)
 ...Q:FS=""
"RTN","HLOCLNT1",139,0)
 ...S CS=$E(NODE1,5)
"RTN","HLOCLNT1",140,0)
 ...Q:CS=""
"RTN","HLOCLNT1",141,0)
 ...S SAPP=$P(NODE1,FS,3)
"RTN","HLOCLNT1",142,0)
 ...S:SAPP="" SAPP="UNKNOWN"
"RTN","HLOCLNT1",143,0)
 ...S RAPP=$P(NODE1,FS,5)
"RTN","HLOCLNT1",144,0)
 ...S MTYPE=$P($P(NODE2,FS,4),CS)
"RTN","HLOCLNT1",145,0)
 ...S EVENT=$P($P(NODE2,FS,4),CS,2)
"RTN","HLOCLNT1",146,0)
 ...S $P(^HLB(MSG,0),"^",21)=COUNT_" FAILED TRANSMISSIONS"
"RTN","HLOCLNT1",147,0)
 ...S $P(^HLB(MSG,0),"^",20)="TF"
"RTN","HLOCLNT1",148,0)
 ...S ^HLB("ERRORS","TF",SAPP,TIME,MSG)=""
"RTN","HLOCLNT1",149,0)
 ...D COUNT^HLOESTAT("OUT",RAPP,SAPP,MTYPE,EVENT)
"RTN","HLOCLNT1",150,0)
 ...S ACTION=$P(NODE0,"^",14,15)
"RTN","HLOCLNT1",151,0)
 ...I ACTION'="^",ACTION]"" D INQUE^HLOQUE(LINK,QUE,MSG,ACTION,1)
"RTN","HLOCLNT1",152,0)
 ...D DEQUE^HLOQUE(LINK,QUE,"OUT",MSG)
"RTN","HLOCLNT1",153,0)
 .L -^HLB("QUEUE","OUT",LINK)
"RTN","HLOCLNT1",154,0)
 Q
"RTN","HLOCLNT2")
0^10^B38024388^B29898713
"RTN","HLOCLNT2",1,0)
HLOCLNT2 ;ALB/CJM- Performs message updates for the client - 10/4/94 1pm ;03/09/2007
"RTN","HLOCLNT2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,133,134**;Oct 13, 1995;Build 30
"RTN","HLOCLNT2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT2",4,0)
 ;
"RTN","HLOCLNT2",5,0)
GETWORK(WORK) ;
"RTN","HLOCLNT2",6,0)
 ;
"RTN","HLOCLNT2",7,0)
 N OLD,DOLLARJ,SUCCESS,NOW
"RTN","HLOCLNT2",8,0)
 S SUCCESS=0
"RTN","HLOCLNT2",9,0)
 S NOW=$$NOW^XLFDT
"RTN","HLOCLNT2",10,0)
 S (OLD,DOLLARJ)=$G(WORK("DOLLARJ"))
"RTN","HLOCLNT2",11,0)
 F  S DOLLARJ=$O(^HLTMP("CLIENT UPDATES",DOLLARJ)) Q:DOLLARJ=""  D  Q:SUCCESS
"RTN","HLOCLNT2",12,0)
 .L +^HLTMP("CLIENT UPDATES",DOLLARJ):0
"RTN","HLOCLNT2",13,0)
 .Q:'$T
"RTN","HLOCLNT2",14,0)
 .N TIME S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,""))
"RTN","HLOCLNT2",15,0)
 .I $$FMDIFF^XLFDT(NOW,TIME,2)<2 L -^HLTMP("CLIENT UPDATES",DOLLARJ) Q
"RTN","HLOCLNT2",16,0)
 .S SUCCESS=1
"RTN","HLOCLNT2",17,0)
 ;
"RTN","HLOCLNT2",18,0)
 I OLD'="",'SUCCESS F  S DOLLARJ=$O(^HLTMP("CLIENT UPDATES",DOLLARJ)) Q:DOLLARJ=""  Q:DOLLARJ>OLD  D  Q:SUCCESS
"RTN","HLOCLNT2",19,0)
 .L +^HLTMP("CLIENT UPDATES",DOLLARJ):0
"RTN","HLOCLNT2",20,0)
 .Q:'$T
"RTN","HLOCLNT2",21,0)
 .N TIME S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,""))
"RTN","HLOCLNT2",22,0)
 .I $$FMDIFF^XLFDT(NOW,TIME,2)<2 L -^HLTMP("CLIENT UPDATES",DOLLARJ) Q
"RTN","HLOCLNT2",23,0)
 .S SUCCESS=1
"RTN","HLOCLNT2",24,0)
 S WORK("DOLLARJ")=DOLLARJ,WORK("NOW")=NOW
"RTN","HLOCLNT2",25,0)
 Q $S($L(WORK("DOLLARJ")):1,1:0)
"RTN","HLOCLNT2",26,0)
 ;
"RTN","HLOCLNT2",27,0)
DOWORK(WORK) ;
"RTN","HLOCLNT2",28,0)
 ;
"RTN","HLOCLNT2",29,0)
 N DOLLARJ,TIME,IEN,PARMS,SYSTEM
"RTN","HLOCLNT2",30,0)
 S TIME=""
"RTN","HLOCLNT2",31,0)
 S DOLLARJ=WORK("DOLLARJ")
"RTN","HLOCLNT2",32,0)
 D SYSPARMS^HLOSITE(.SYSTEM)
"RTN","HLOCLNT2",33,0)
 F  S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME)) Q:TIME=""  Q:$$FMDIFF^XLFDT(WORK("NOW"),TIME,2)<2  D
"RTN","HLOCLNT2",34,0)
 .S IEN=0
"RTN","HLOCLNT2",35,0)
 .F  S IEN=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN)) Q:'IEN  D
"RTN","HLOCLNT2",36,0)
 ..N NODE
"RTN","HLOCLNT2",37,0)
 ..S NODE=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN))
"RTN","HLOCLNT2",38,0)
 ..S PARMS("LINK")=$P(NODE,"^")
"RTN","HLOCLNT2",39,0)
 ..S PARMS("QUEUE")=$P(NODE,"^",2)
"RTN","HLOCLNT2",40,0)
 ..S PARMS("STATUS")=$P(NODE,"^",3)
"RTN","HLOCLNT2",41,0)
 ..S PARMS("PURGE TYPE")=$P(NODE,"^",4)
"RTN","HLOCLNT2",42,0)
 ..S PARMS("ACK TO IEN")=+$P($P(NODE,"^",4),"-",2)
"RTN","HLOCLNT2",43,0)
 ..S PARMS("ACCEPT ACK")=$P(NODE,"^",5)
"RTN","HLOCLNT2",44,0)
 ..S PARMS("RECEIVING APP")=$P(NODE,"^",6)
"RTN","HLOCLNT2",45,0)
 ..S:PARMS("RECEIVING APP")="" PARMS("RECEIVING APP")="UNKNOWN RECEIVING APPLICATION"
"RTN","HLOCLNT2",46,0)
 ..S PARMS("MSA")=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN,"MSA"))
"RTN","HLOCLNT2",47,0)
 ..S PARMS("ACTION")=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN,"ACTION"))
"RTN","HLOCLNT2",48,0)
 ..D UPDATE(IEN,TIME,.PARMS)
"RTN","HLOCLNT2",49,0)
 ..K ^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN)
"RTN","HLOCLNT2",50,0)
 L -^HLTMP("CLIENT UPDATES",DOLLARJ)
"RTN","HLOCLNT2",51,0)
 Q
"RTN","HLOCLNT2",52,0)
 ;
"RTN","HLOCLNT2",53,0)
UPDATE(MSGIEN,TIME,PARMS) ;
"RTN","HLOCLNT2",54,0)
 S:PARMS("STATUS")]"" $P(^HLB(MSGIEN,0),"^",20)=PARMS("STATUS")
"RTN","HLOCLNT2",55,0)
 S:PARMS("STATUS")="SE" ^HLB("ERRORS","SE",PARMS("RECEIVING APP"),TIME,MSGIEN)=""
"RTN","HLOCLNT2",56,0)
 S:PARMS("STATUS")="AE" ^HLB("ERRORS","AE",PARMS("RECEIVING APP"),TIME,MSGIEN_"^")=""
"RTN","HLOCLNT2",57,0)
 I PARMS("STATUS")["E" D COUNT^HLOESTAT("OUT",PARMS("RECEIVING APP"),$$GETSAP(MSGIEN),$$GETMTYPE(MSGIEN))
"RTN","HLOCLNT2",58,0)
 S:PARMS("ACCEPT ACK") $P(^HLB(MSGIEN,0),"^",17)=PARMS("ACCEPT ACK")
"RTN","HLOCLNT2",59,0)
 S $P(^HLB(MSGIEN,0),"^",16)=TIME
"RTN","HLOCLNT2",60,0)
 S:PARMS("MSA")]"" ^HLB(MSGIEN,4)=TIME_"^"_PARMS("MSA")
"RTN","HLOCLNT2",61,0)
 I PARMS("PURGE TYPE"),PARMS("ACTION")="" D
"RTN","HLOCLNT2",62,0)
 .;don't set purge if going on the infiler - let infiler do it
"RTN","HLOCLNT2",63,0)
 .N PTIME
"RTN","HLOCLNT2",64,0)
 .S:(PARMS("PURGE TYPE")=2) PTIME=$$FMADD^XLFDT(TIME,SYSTEM("ERROR PURGE")) ;error purge is in days
"RTN","HLOCLNT2",65,0)
 .S:(PARMS("PURGE TYPE")'=2) PTIME=$$FMADD^XLFDT(TIME,,SYSTEM("NORMAL PURGE")) ;normal purge is in hours
"RTN","HLOCLNT2",66,0)
 .S $P(^HLB(MSGIEN,0),"^",9)=PTIME,^HLB("AD","OUT",PTIME,MSGIEN)=""
"RTN","HLOCLNT2",67,0)
 .I PARMS("ACK TO IEN"),$D(^HLB(PARMS("ACK TO IEN"),0)) S $P(^HLB(PARMS("ACK TO IEN"),0),"^",9)=PTIME,^HLB("AD","OUT",PTIME,PARMS("ACK TO IEN"))=""
"RTN","HLOCLNT2",68,0)
 D:PARMS("ACTION")]""
"RTN","HLOCLNT2",69,0)
 .N PURGE
"RTN","HLOCLNT2",70,0)
 .S PURGE=$S(PARMS("PURGE TYPE"):1,1:0)
"RTN","HLOCLNT2",71,0)
 .S:PARMS("ACK TO IEN") PURGE("ACKTOIEN")=PARMS("ACK TO IEN")
"RTN","HLOCLNT2",72,0)
 .D INQUE^HLOQUE(PARMS("LINK"),PARMS("QUEUE"),MSGIEN,PARMS("ACTION"),.PURGE)
"RTN","HLOCLNT2",73,0)
 Q
"RTN","HLOCLNT2",74,0)
 ;
"RTN","HLOCLNT2",75,0)
GETMSG(IEN,MSG) ;
"RTN","HLOCLNT2",76,0)
 ;
"RTN","HLOCLNT2",77,0)
 ;Description: given the message ien=MSGIEN (required), it returns the MSG array containing information about the message, defined below.
"RTN","HLOCLNT2",78,0)
 ;Input:
"RTN","HLOCLNT2",79,0)
 ;  IEN - the ien of the message in file 778
"RTN","HLOCLNT2",80,0)
 ;Output:
"RTN","HLOCLNT2",81,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT2",82,0)
 ;  MSG (pass by reference, required) These are the subscripts returned:
"RTN","HLOCLNT2",83,0)
 ;    "ACCEPT ACK RESPONSE" - if the sending app requested notification of the accept ack, this is the routine to perform
"RTN","HLOCLNT2",84,0)
 ;    "ACKTOIEN" - if this is an app ack to a message not in a batch, this is the ien of the original message
"RTN","HLOCLNT2",85,0)
 ;    "BATCH"  = 1 if this is a batch message, 0  if not
"RTN","HLOCLNT2",86,0)
 ;    "CURRENT MESSAGE" - defined only for batch messages -  a counterused during building and parsing messages to indicate the current message.  It will be set to 0 initially.
"RTN","HLOCLNT2",87,0)
 ;    "BODY" - ptr to file 778 which contains the body of the message.
"RTN","HLOCLNT2",88,0)
 ;    "LINE COUNT" -  a counter used during writing of the
"RTN","HLOCLNT2",89,0)
 ;     messages to indicate the current line. For
"RTN","HLOCLNT2",90,0)
 ;     batch messages where each message within the batch is stored
"RTN","HLOCLNT2",91,0)
 ;     separately, this field indicates the position within the current
"RTN","HLOCLNT2",92,0)
 ;     individual message
"RTN","HLOCLNT2",93,0)
 ;    "HDR" at these lower subscripts:
"RTN","HLOCLNT2",94,0)
 ;       1    - components 1-6
"RTN","HLOCLNT2",95,0)
 ;       2    - components 7-end
"RTN","HLOCLNT2",96,0)
 ;       "ACCEPT ACK TYPE" = "AL" or "NE"
"RTN","HLOCLNT2",97,0)
 ;       "APP ACK TYPE" = "AL" or "NE"
"RTN","HLOCLNT2",98,0)
 ;       "MESSAGE CONTROL ID" - defined if NOT batch
"RTN","HLOCLNT2",99,0)
 ;       "BATCH CONTROL ID" - defined if batch
"RTN","HLOCLNT2",100,0)
 ;
"RTN","HLOCLNT2",101,0)
 ;    "ID" - message id from the header
"RTN","HLOCLNT2",102,0)
 ;    "IEN" - ien, file 778
"RTN","HLOCLNT2",103,0)
 ;
"RTN","HLOCLNT2",104,0)
 K MSG
"RTN","HLOCLNT2",105,0)
 Q:'$G(IEN) 0
"RTN","HLOCLNT2",106,0)
 N NODE,FS,CS,REP,SUBCOMP,ESCAPE
"RTN","HLOCLNT2",107,0)
 S MSG("IEN")=IEN
"RTN","HLOCLNT2",108,0)
 S NODE=$G(^HLB(IEN,0))
"RTN","HLOCLNT2",109,0)
 S MSG("BODY")=$P(NODE,"^",2)
"RTN","HLOCLNT2",110,0)
 S MSG("ID")=$P(NODE,"^")
"RTN","HLOCLNT2",111,0)
 Q:'MSG("BODY") 0
"RTN","HLOCLNT2",112,0)
 S MSG("STATUS","ACCEPTED")=$P(NODE,"^",17)
"RTN","HLOCLNT2",113,0)
 S MSG("DT/TM")=$P(NODE,"^",16)
"RTN","HLOCLNT2",114,0)
 S MSG("STATUS","QUEUE")=$P(NODE,"^",6)
"RTN","HLOCLNT2",115,0)
 I MSG("STATUS","QUEUE")="" S MSG("STATUS","QUEUE")="DEFAULT"
"RTN","HLOCLNT2",116,0)
 S MSG("ACCEPT ACK RESPONSE")=$P(NODE,"^",12,13)
"RTN","HLOCLNT2",117,0)
 I MSG("ACCEPT ACK RESPONSE")="^" S MSG("ACCEPT ACK RESPONSE")=""
"RTN","HLOCLNT2",118,0)
 ;
"RTN","HLOCLNT2",119,0)
 S MSG("BATCH")=+$P($G(^HLA(MSG("BODY"),0)),"^",2)
"RTN","HLOCLNT2",120,0)
 I MSG("BATCH") D
"RTN","HLOCLNT2",121,0)
 .S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOCLNT2",122,0)
 E  D
"RTN","HLOCLNT2",123,0)
 .N ACKTO
"RTN","HLOCLNT2",124,0)
 .S ACKTO=$P(NODE,"^",3)
"RTN","HLOCLNT2",125,0)
 .I ACKTO]"" S ACKTO=$$ACKTOIEN^HLOMSG1(MSG("ID"),ACKTO)
"RTN","HLOCLNT2",126,0)
 .I ACKTO,+ACKTO=ACKTO S MSG("ACK TO IEN")=ACKTO
"RTN","HLOCLNT2",127,0)
 S MSG("LINE COUNT")=0
"RTN","HLOCLNT2",128,0)
 S MSG("HDR",1)=$G(^HLB(IEN,1))
"RTN","HLOCLNT2",129,0)
 S MSG("HDR",2)=$G(^HLB(IEN,2))
"RTN","HLOCLNT2",130,0)
 S FS=$E(MSG("HDR",1),4)
"RTN","HLOCLNT2",131,0)
 S CS=$E(MSG("HDR",1),5)
"RTN","HLOCLNT2",132,0)
 S REP=$E(MSG("HDR",1),6)
"RTN","HLOCLNT2",133,0)
 S ESCAPE=$E(MSG("HDR",1),7)
"RTN","HLOCLNT2",134,0)
 S SUBCOMP=$E(MSG("HDR",1),8)
"RTN","HLOCLNT2",135,0)
 S MSG("HDR","FIELD SEPARATOR")=FS
"RTN","HLOCLNT2",136,0)
 S MSG("HDR","SENDING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(MSG("HDR",1),FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOCLNT2",137,0)
 S MSG("HDR","RECEIVING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(MSG("HDR",1),FS,5),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOCLNT2",138,0)
 I 'MSG("BATCH") D
"RTN","HLOCLNT2",139,0)
 .S MSG("HDR","MESSAGE TYPE")=$P($P(MSG("HDR",2),FS,4),CS)
"RTN","HLOCLNT2",140,0)
 .S MSG("HDR","EVENT")=$P($P(MSG("HDR",2),FS,4),CS,2)
"RTN","HLOCLNT2",141,0)
 .S MSG("HDR","ACCEPT ACK TYPE")=$E($P(MSG("HDR",2),FS,10),1,2)
"RTN","HLOCLNT2",142,0)
 .S MSG("HDR","APP ACK TYPE")=$E($P(MSG("HDR",2),FS,11),1,2)
"RTN","HLOCLNT2",143,0)
 .S MSG("HDR","MESSAGE CONTROL ID")=MSG("ID")
"RTN","HLOCLNT2",144,0)
 E  D
"RTN","HLOCLNT2",145,0)
 .S MSG("HDR","BATCH CONTROL ID")=MSG("ID")
"RTN","HLOCLNT2",146,0)
 .S MSG("HDR","ACCEPT ACK TYPE")=$E($P($P(MSG("HDR",2),FS,4),"ACCEPT ACK TYPE=",2),1,2)
"RTN","HLOCLNT2",147,0)
 .S MSG("HDR","APP ACK TYPE")=$E($P($P(MSG("HDR",2),FS,4),"APP ACK TYPE=",2),1,2)
"RTN","HLOCLNT2",148,0)
 Q 1
"RTN","HLOCLNT2",149,0)
 ;
"RTN","HLOCLNT2",150,0)
GETMTYPE(MSGIEN) ;returns <message type>~<event> OR "BATCH"
"RTN","HLOCLNT2",151,0)
 Q:'$G(MSGIEN) "UNKNOWN"
"RTN","HLOCLNT2",152,0)
 N FS,CS,HDR1,HDR2
"RTN","HLOCLNT2",153,0)
 S HDR1=$G(^HLB(IEN,1))
"RTN","HLOCLNT2",154,0)
 I $E(HDR1,1,3)="BHS" Q "BATCH"
"RTN","HLOCLNT2",155,0)
 S HDR2=$G(^HLB(IEN,2))
"RTN","HLOCLNT2",156,0)
 S FS=$E(HDR1,4)
"RTN","HLOCLNT2",157,0)
 S CS=$E(HDR1,5)
"RTN","HLOCLNT2",158,0)
 Q $P($P(HDR2,FS,4),CS)_"~"_$P($P(HDR2,FS,4),CS,2)
"RTN","HLOCLNT2",159,0)
 ;
"RTN","HLOCLNT2",160,0)
GETEVENT(MSGIEN) ; returns event if not a batch message
"RTN","HLOCLNT2",161,0)
 Q:'$G(MSGIEN) ""
"RTN","HLOCLNT2",162,0)
 N FS,CS,HDR1,HDR2
"RTN","HLOCLNT2",163,0)
 S HDR1=$G(^HLB(MSGIEN,1))
"RTN","HLOCLNT2",164,0)
 I $E(HDR1,1,3)="BHS" Q ""
"RTN","HLOCLNT2",165,0)
 S HDR2=$G(^HLB(MSGIEN,2))
"RTN","HLOCLNT2",166,0)
 S FS=$E(HDR1,4)
"RTN","HLOCLNT2",167,0)
 S CS=$E(HDR1,5)
"RTN","HLOCLNT2",168,0)
 Q $P($P(HDR2,FS,4),CS,2)
"RTN","HLOCLNT2",169,0)
 ;
"RTN","HLOCLNT2",170,0)
GETSAP(MSGIEN) ;
"RTN","HLOCLNT2",171,0)
 ;
"RTN","HLOCLNT2",172,0)
 ;
"RTN","HLOCLNT2",173,0)
 Q:'$G(MSGIEN) "UNKNOWN"
"RTN","HLOCLNT2",174,0)
 N FS,CS,HDR1,REP,ESCAPE,SUBCOMP
"RTN","HLOCLNT2",175,0)
 S HDR1=$G(^HLB(MSGIEN,1))
"RTN","HLOCLNT2",176,0)
 S FS=$E(HDR1,4)
"RTN","HLOCLNT2",177,0)
 S CS=$E(HDR1,5)
"RTN","HLOCLNT2",178,0)
 S REP=$E(HDR1,6)
"RTN","HLOCLNT2",179,0)
 S ESCAPE=$E(HDR1,7)
"RTN","HLOCLNT2",180,0)
 S SUBCOMP=$E(HDR1,8)
"RTN","HLOCLNT2",181,0)
 Q $$DESCAPE^HLOPRS1($P($P(HDR1,FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOCLNT3")
0^13^B5680444^B3706254
"RTN","HLOCLNT3",1,0)
HLOCLNT3 ;ALB/CJM- Updates messages missing application acks - 10/4/94 1pm ;03/22/2007
"RTN","HLOCLNT3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,134**;Oct 13, 1995;Build 30
"RTN","HLOCLNT3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT3",4,0)
 ;
"RTN","HLOCLNT3",5,0)
DOWORK(WORK) ;
"RTN","HLOCLNT3",6,0)
 ;
"RTN","HLOCLNT3",7,0)
 N CUTOFF,MSGIEN,QUIT,NOW,SYSTEM
"RTN","HLOCLNT3",8,0)
 S NOW=$$NOW^XLFDT
"RTN","HLOCLNT3",9,0)
 S QUIT=0
"RTN","HLOCLNT3",10,0)
 D SYSPARMS^HLOSITE(.SYSTEM)
"RTN","HLOCLNT3",11,0)
 S PURGE=$$FMADD^XLFDT($$NOW^XLFDT,,24*SYSTEM("ERROR PURGE"))
"RTN","HLOCLNT3",12,0)
 ;
"RTN","HLOCLNT3",13,0)
 ;7 day wait for an application ack is more than reasonable
"RTN","HLOCLNT3",14,0)
 S CUTOFF=$$FMADD^XLFDT(NOW,-3)
"RTN","HLOCLNT3",15,0)
 ;
"RTN","HLOCLNT3",16,0)
 S MSGIEN=+$G(^HLTMP("LAST IEN CHECKED FOR MISSING APPLICATION ACK"))
"RTN","HLOCLNT3",17,0)
 F  S MSGIEN=$O(^HLB(MSGIEN)) Q:'MSGIEN  Q:MSGIEN>99999999999  D  Q:QUIT
"RTN","HLOCLNT3",18,0)
 .N MSG,HDR
"RTN","HLOCLNT3",19,0)
 .Q:'$$GETMSG^HLOMSG(MSGIEN,.MSG)
"RTN","HLOCLNT3",20,0)
 .Q:'MSG("DT/TM")
"RTN","HLOCLNT3",21,0)
 .Q:'MSG("BODY")
"RTN","HLOCLNT3",22,0)
 .I MSG("DT/TM")>CUTOFF S:MSG("DT/TM CREATED")>CUTOFF QUIT=1,MSGIEN=MSGIEN-1 Q
"RTN","HLOCLNT3",23,0)
 .Q:MSG("STATUS")'=""
"RTN","HLOCLNT3",24,0)
 .Q:MSG("DIRECTION")'="OUT"
"RTN","HLOCLNT3",25,0)
 .Q:MSG("BATCH")
"RTN","HLOCLNT3",26,0)
 .Q:MSG("STATUS","APP ACK'D")
"RTN","HLOCLNT3",27,0)
 .;Q:MSG("STATUS","APP ACK RESPONSE")=""
"RTN","HLOCLNT3",28,0)
 .;message has been in a non-complete status for a longtime, pending an application ack - set status to error and schedule for purging
"RTN","HLOCLNT3",29,0)
 .S $P(^HLB(MSGIEN,0),"^",9)=PURGE
"RTN","HLOCLNT3",30,0)
 .S ^HLB("AD","OUT",PURGE,MSGIEN)=""
"RTN","HLOCLNT3",31,0)
 .S $P(^HLB(MSGIEN,0),"^",20)="AE"
"RTN","HLOCLNT3",32,0)
 .S $P(^HLB(MSGIEN,0),"^",21)="MISSING APPLICATION ACKNOWLEDGMENT"
"RTN","HLOCLNT3",33,0)
 .M HDR=MSG("HDR")
"RTN","HLOCLNT3",34,0)
 .Q:'$$PARSEHDR^HLOPRS(.HDR)
"RTN","HLOCLNT3",35,0)
 .S ^HLB("ERRORS","AE",$S($L(HDR("RECEIVING APPLICATION")):HDR("RECEIVING APPLICATION"),1:"UNKNOWN"),NOW,MSGIEN)=""
"RTN","HLOCLNT3",36,0)
 .D COUNT^HLOESTAT("OUT",HDR("RECEIVING APPLICATION"),HDR("SENDING APPLICATION"),$S(MSG("BATCH"):"BATCH",1:$G(HDR("MESSAGE TYPE"))),$G(HDR("EVENT")))
"RTN","HLOCLNT3",37,0)
 S:MSGIEN>99999999999 MSGIEN=0
"RTN","HLOCLNT3",38,0)
 S ^HLTMP("LAST IEN CHECKED FOR MISSING APPLICATION ACK")=MSGIEN
"RTN","HLOCLNT3",39,0)
 Q
"RTN","HLOCNRT")
0^19^B11469805^B4616658
"RTN","HLOCNRT",1,0)
HLOCNRT ;DAOU/ALA-Generate HL7 Optimized Message ;03/15/2007
"RTN","HLOCNRT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132,134**;Oct 13, 1995;Build 30
"RTN","HLOCNRT",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCNRT",4,0)
 ;
"RTN","HLOCNRT",5,0)
 ;**Program Description**
"RTN","HLOCNRT",6,0)
 ;  This program takes a current HL7 1.6 message and converts
"RTN","HLOCNRT",7,0)
 ;  it to use the new HL Optimized code if it follows the standard
"RTN","HLOCNRT",8,0)
 ;  1.6 methodology of protocols.
"RTN","HLOCNRT",9,0)
 ;
"RTN","HLOCNRT",10,0)
 ;  **If the VistA HL7 Protocol does not exist, calls to HL Optimized
"RTN","HLOCNRT",11,0)
 ;  will have to be coded separately and this program cannot be used**
"RTN","HLOCNRT",12,0)
 Q
"RTN","HLOCNRT",13,0)
 ;
"RTN","HLOCNRT",14,0)
EN(HLOPRTCL,ARYTYP,HLP,HLL,RESULT) ;Entry Point
"RTN","HLOCNRT",15,0)
 ;  Input Parameters
"RTN","HLOCNRT",16,0)
 ;   HLOPRTCL = Protocol IEN or Protocol Name
"RTN","HLOCNRT",17,0)
 ;   ARYTYP = The array where HL7 message resides
"RTN","HLOCNRT",18,0)
 ;   HLP = Additional HL7 message parameters (optional, pass by reference)
"RTN","HLOCNRT",19,0)
 ;        These optional subscripts to HLL are supported for input:
"RTN","HLOCNRT",20,0)
 ;             "SECURITY"
"RTN","HLOCNRT",21,0)
 ;              "CONTPTR"
"RTN","HLOCNRT",22,0)
 ;              "APP ACK RESPONSE" = <tag^routine> to call when the app ack is received
"RTN","HLOCNRT",23,0)
 ;        
"RTN","HLOCNRT",24,0)
 ;   HLL  (optional, pass by reference) Additional message recipients being dynamically added
"RTN","HLOCNRT",25,0)
 ;
"RTN","HLOCNRT",26,0)
 ;  Output
"RTN","HLOCNRT",27,0)
 ;    RESULT (pass-by-reference)=<subscriber protocol ien>^<link ien>^<message id>^<0 if sucess, error code if failure>^<optional error message>
"RTN","HLOCNRT",28,0)
 ;             If the message was sent to more than 1 destination,
"RTN","HLOCNRT",29,0)
 ;             the addtional mssage ids returned as RESULT(1), RESULT(2), etc.
"RTN","HLOCNRT",30,0)
 ;    ZTSTOP = Stop processing flag (used by HDR)
"RTN","HLOCNRT",31,0)
 ;    Function returns 1 on success, else returns an error message
"RTN","HLOCNRT",32,0)
 ;
"RTN","HLOCNRT",33,0)
 NEW HLORESL,HLMSTATE,APPARMS,WHOTO,ERROR,WHO
"RTN","HLOCNRT",34,0)
 S ZTSTOP=0,HLORESL=1,RESULT=""
"RTN","HLOCNRT",35,0)
 ;
"RTN","HLOCNRT",36,0)
 ;  Get IEN of protocol if name is passed
"RTN","HLOCNRT",37,0)
 I '$L(HLOPRTCL) S HLORESL="^99^HL7 1.6 Protocol not found",RESULT="^^"_HLORESL,ZTSTOP=1 Q HLORESL
"RTN","HLOCNRT",38,0)
 I ('HLOPRTCL)!(HLOPRTCL'=+HLOPRTCL) S HLOPRTCL=+$O(^ORD(101,"B",HLOPRTCL,0))
"RTN","HLOCNRT",39,0)
 I 'HLOPRTCL S HLORESL="^99^HL7 1.6 Protocol not found",RESULT="^^"_HLORESL,ZTSTOP=1 Q HLORESL
"RTN","HLOCNRT",40,0)
 I '$D(^ORD(101,HLOPRTCL)) S HLORESL="^99^HL7 1.6 Protocol not found",RESULT="^^"_HLORESL,ZTSTOP=1 Q HLORESL
"RTN","HLOCNRT",41,0)
 ;
"RTN","HLOCNRT",42,0)
 ;  If the VistA HL7 Protocol exists, call the Conversion Utility
"RTN","HLOCNRT",43,0)
 ;  to set up the APPARMS, WHOTO arrays from protocol logical link,
"RTN","HLOCNRT",44,0)
 ;   and the optional HLL and HLP arrays
"RTN","HLOCNRT",45,0)
 D APAR^HLOCVU(HLOPRTCL,.APPARMS,.WHO,.WHOTO,.HLP,.HLL)
"RTN","HLOCNRT",46,0)
 ;
"RTN","HLOCNRT",47,0)
 ; If special HLP parameters are defined, convert them
"RTN","HLOCNRT",48,0)
 I $D(HLP) D
"RTN","HLOCNRT",49,0)
 . I $G(HLP("SECURITY"))'="" S APPARMS("SECURITY")=HLP("SECURITY")
"RTN","HLOCNRT",50,0)
 . I $G(HLP("CONTPTR"))'="" S APPARMS("CONTINUATION POINTER")=HLP("CONTPTR")
"RTN","HLOCNRT",51,0)
 . I $G(HLP("QUEUE"))'="" S APPARMS("QUEUE")=HLP("QUEUE")
"RTN","HLOCNRT",52,0)
 . I $G(HLP("APP ACK RESPONSE"))'="" S APPARMS("APP ACK RESPONSE")=HLP("APP ACK RESPONSE")
"RTN","HLOCNRT",53,0)
 ;
"RTN","HLOCNRT",54,0)
 ;  Create HL Optimized message
"RTN","HLOCNRT",55,0)
 I '$$NEWMSG^HLOAPI(.APPARMS,.HLMSTATE,.ERROR) S HLORESL="^99^"_ERROR,ZTSTOP=1,RESULT="^^"_HLORESL Q HLORESL
"RTN","HLOCNRT",56,0)
 I $E(ARYTYP,1)="G" S HLOMESG="^TMP(""HLS"",$J)"
"RTN","HLOCNRT",57,0)
 I $E(ARYTYP,1)="L" S HLOMESG="HLA(""HLS"")"
"RTN","HLOCNRT",58,0)
 ;
"RTN","HLOCNRT",59,0)
 ;  Move the existing message from array into HL Optimized
"RTN","HLOCNRT",60,0)
 D MOVEMSG^HLOAPI(.HLMSTATE,HLOMESG)
"RTN","HLOCNRT",61,0)
 ; 
"RTN","HLOCNRT",62,0)
 ;  Send message via HL Optimized
"RTN","HLOCNRT",63,0)
 I $D(WHOTO) D
"RTN","HLOCNRT",64,0)
 .N COUNT
"RTN","HLOCNRT",65,0)
 .I '$$SENDMANY^HLOAPI1(.HLMSTATE,.APPARMS,.WHOTO) D
"RTN","HLOCNRT",66,0)
 ..S HLORESL="^99^Unable to send message",ZTSTOP=1
"RTN","HLOCNRT",67,0)
 .I $G(WHOTO(1,"IEN")) D
"RTN","HLOCNRT",68,0)
 ..S RESULT=WHO(1)_"^"_$P($G(^HLB(WHOTO(1,"IEN"),0)),"^")_"^"_$S($G(WHOTO(1,"QUEUED")):0,1:1)_"^"_$G(WHOTO(1,"ERROR"))
"RTN","HLOCNRT",69,0)
 .E  D
"RTN","HLOCNRT",70,0)
 ..S RESULT=WH0(1)_"^^1^"_$G(WHOTO(1,"ERROR"))
"RTN","HLOCNRT",71,0)
 ..S HLORESL="^99^"_$G(WHOTO(1,"ERROR")),ZTSTOP=1
"RTN","HLOCNRT",72,0)
 .S COUNT=1
"RTN","HLOCNRT",73,0)
 .F  S COUNT=$O(WHOTO(COUNT)) Q:'COUNT  D
"RTN","HLOCNRT",74,0)
 ..I $G(WHOTO(COUNT,"IEN")) D
"RTN","HLOCNRT",75,0)
 ...S RESULT(COUNT-1)=WHO(COUNT)_"^"_$P($G(^HLB(WHOTO(COUNT,"IEN"),0)),"^")_"^"_$S($G(WHOTO(COUNT,"QUEUED")):0,1:1)_"^"_$G(WHOTO(COUNT,"ERROR"))
"RTN","HLOCNRT",76,0)
 ..E  D
"RTN","HLOCNRT",77,0)
 ...S RESULT(COUNT-1)=WH0(COUNT)_"^^1^"_$G(WHOTO(COUNT,"ERROR"))
"RTN","HLOCNRT",78,0)
 ;
"RTN","HLOCNRT",79,0)
 E  S HLORESL="^99^Unable to send message",ZTSTOP=1,RESULT="^^"_HLORESL
"RTN","HLOCNRT",80,0)
 Q HLORESL
"RTN","HLOCVU")
0^18^B14731556^B6948622
"RTN","HLOCVU",1,0)
HLOCVU ;DAOU/ALA-Conversion Utility ;03/15/2007
"RTN","HLOCVU",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132,134**;Oct 13, 1995;Build 30
"RTN","HLOCVU",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCVU",4,0)
 ;
"RTN","HLOCVU",5,0)
 Q
"RTN","HLOCVU",6,0)
 ;
"RTN","HLOCVU",7,0)
APAR(HLOEID,APARMS,WHO,WHOTO,HLP,HLL) ;  Set up PPARMS array from Protocols
"RTN","HLOCVU",8,0)
 ;
"RTN","HLOCVU",9,0)
 ;  Input Parameter
"RTN","HLOCVU",10,0)
 ;   HLOEID = IEN of the event protocol
"RTN","HLOCVU",11,0)
 ;   HLP - "EXCLUDE SUBSCRIBER" subscript used to ignore specific subscribers
"RTN","HLOCVU",12,0)
 ;   HLL - dynamic addressing
"RTN","HLOCVU",13,0)
 ;
"RTN","HLOCVU",14,0)
 ;  Output
"RTN","HLOCVU",15,0)
 ;    APARMS array
"RTN","HLOCVU",16,0)
 ;    WHO - correlates to WHOTO, providing <subscriber protocol ien>,<link ien> (pass by reference)
"RTN","HLOCVU",17,0)
 ;    WHOTO array
"RTN","HLOCVU",18,0)
 ;
"RTN","HLOCVU",19,0)
 N CT,NODE,I
"RTN","HLOCVU",20,0)
 K APARMS,WHO,WHOTO
"RTN","HLOCVU",21,0)
 S CT=0
"RTN","HLOCVU",22,0)
 Q:'$G(HLOEID)
"RTN","HLOCVU",23,0)
 S NODE=$G(^ORD(101,HLOEID,770))
"RTN","HLOCVU",24,0)
 S APARMS("EVENT")=$P(NODE,"^",4),APARMS("EVENT")=$S(APARMS("EVENT"):$P($G(^HL(779.001,APARMS("EVENT"),0)),"^"),1:"")
"RTN","HLOCVU",25,0)
 S APARMS("MESSAGE TYPE")=$P(NODE,"^",3),APARMS("MESSAGE TYPE")=$S(APARMS("MESSAGE TYPE"):$P($G(^HL(771.2,APARMS("MESSAGE TYPE"),0)),"^"),1:"")
"RTN","HLOCVU",26,0)
 S APARMS("APP ACK TYPE")=$P(NODE,"^",9),APARMS("APP ACK TYPE")=$S(APARMS("APP ACK TYPE"):$P($G(^HL(779.003,APARMS("APP ACK TYPE"),0)),"^"),1:"")
"RTN","HLOCVU",27,0)
 S APARMS("ACCEPT ACK TYPE")=$P(NODE,"^",8),APARMS("ACCEPT ACK TYPE")=$S(APARMS("ACCEPT ACK TYPE"):$P($G(^HL(779.003,APARMS("ACCEPT ACK TYPE"),0)),"^"),1:"")
"RTN","HLOCVU",28,0)
 S APARMS("VERSION")=$P(NODE,"^",10),APARMS("VERSION")=$S(APARMS("VERSION"):$P($G(^HL(771.5,APARMS("VERSION"),0)),"^"),1:"")
"RTN","HLOCVU",29,0)
 S APARMS("SENDING APPLICATION")=$P(NODE,"^")
"RTN","HLOCVU",30,0)
 I APARMS("SENDING APPLICATION") D
"RTN","HLOCVU",31,0)
 .S APARMS("FIELD SEPARATOR")=$E($G(^HL(771,APARMS("SENDING APPLICATION"),"FS")),1)
"RTN","HLOCVU",32,0)
 .S:APARMS("FIELD SEPARATOR")="" APARMS("FIELD SEPARATOR")="^"
"RTN","HLOCVU",33,0)
 .S APARMS("ENCODING CHARACTERS")=$E($G(^HL(771,APARMS("SENDING APPLICATION"),"EC")),1,4)
"RTN","HLOCVU",34,0)
 .S:APARMS("ENCODING CHARACTERS")="" APARMS("ENCODING CHARACTERS")="~|\&"
"RTN","HLOCVU",35,0)
 .S APARMS("SENDING APPLICATION")=$P($G(^HL(771,APARMS("SENDING APPLICATION"),0)),"^")
"RTN","HLOCVU",36,0)
 .I APARMS("SENDING APPLICATION")'="",'$O(^HLD(779.2,"C",APARMS("SENDING APPLICATION"),0)) D
"RTN","HLOCVU",37,0)
 ..;add the sending applcation to the registry
"RTN","HLOCVU",38,0)
 ..N DATA,ERROR
"RTN","HLOCVU",39,0)
 ..S DATA(.01)=APARMS("SENDING APPLICATION")
"RTN","HLOCVU",40,0)
 ..S DATA(2)=$P($G(^ORD(101,HLOEID,0)),"^",12)
"RTN","HLOCVU",41,0)
 ..I $$ADD^HLOASUB1(779.2,,.DATA,.ERROR) ;then will not generate an error
"RTN","HLOCVU",42,0)
 E  D
"RTN","HLOCVU",43,0)
 .S APARMS("SENDING APPLICATION")=""
"RTN","HLOCVU",44,0)
 .S APARMS("FIELD SEPARATOR")="^"
"RTN","HLOCVU",45,0)
 .S APARMS("ENCODING CHARACTERS")="~|\&"
"RTN","HLOCVU",46,0)
 ;
"RTN","HLOCVU",47,0)
 S APARMS("COUNTRY")="USA"
"RTN","HLOCVU",48,0)
 ;
"RTN","HLOCVU",49,0)
 ;get the subscribers
"RTN","HLOCVU",50,0)
 D
"RTN","HLOCVU",51,0)
 .N SUBIEN,HLOSID
"RTN","HLOCVU",52,0)
 .S SUBIEN=0
"RTN","HLOCVU",53,0)
 .F  S SUBIEN=$O(^ORD(101,HLOEID,775,SUBIEN)) Q:'SUBIEN  D
"RTN","HLOCVU",54,0)
 ..N NODE,APP,LINK,EXCLUDE
"RTN","HLOCVU",55,0)
 ..S NODE=$G(^ORD(101,HLOEID,775,SUBIEN,0))
"RTN","HLOCVU",56,0)
 ..S HLOSID=$P(NODE,"^")
"RTN","HLOCVU",57,0)
 ..Q:'HLOSID
"RTN","HLOCVU",58,0)
 ..S NODE=$G(^ORD(101,HLOSID,770))
"RTN","HLOCVU",59,0)
 ..S APP=$P(NODE,"^",2)
"RTN","HLOCVU",60,0)
 ..Q:'APP
"RTN","HLOCVU",61,0)
 ..S LINK=$P(NODE,"^",7)
"RTN","HLOCVU",62,0)
 ..Q:'LINK
"RTN","HLOCVU",63,0)
 ..;
"RTN","HLOCVU",64,0)
 ..;excluded?
"RTN","HLOCVU",65,0)
 ..S (EXCLUDE,I)=0
"RTN","HLOCVU",66,0)
 ..F  S I=$O(HLP("EXCLUDE SUBSCRIBER",I)) Q:'I  I $G(HLP("EXCLUDE SUBSCRIBER",I))=HLOSID S EXCLUDE=1 Q
"RTN","HLOCVU",67,0)
 ..Q:EXCLUDE
"RTN","HLOCVU",68,0)
 ..;
"RTN","HLOCVU",69,0)
 ..S CT=CT+1
"RTN","HLOCVU",70,0)
 ..S WHO(CT)=HLOSID_"^"_LINK
"RTN","HLOCVU",71,0)
 ..S WHOTO(CT,"RECEIVING APPLICATION")=$P($G(^HL(771,APP,0)),"^")
"RTN","HLOCVU",72,0)
 ..S WHOTO(CT,"FACILITY LINK NAME")=$P($G(^HLCS(870,LINK,0)),"^")
"RTN","HLOCVU",73,0)
 ;
"RTN","HLOCVU",74,0)
 S I=0
"RTN","HLOCVU",75,0)
 F  S I=$O(HLL("LINKS",I)) Q:'I  D
"RTN","HLOCVU",76,0)
 .N LINK,PROTOCOL
"RTN","HLOCVU",77,0)
 .S CT=CT+1
"RTN","HLOCVU",78,0)
 .S PROTOCOL=$P(HLL("LINKS",I),"^")
"RTN","HLOCVU",79,0)
 .S LINK=$P(HLL("LINKS",I),"^",2)
"RTN","HLOCVU",80,0)
 .I PROTOCOL=+PROTOCOL D
"RTN","HLOCVU",81,0)
 ..S WHO(CT)=PROTOCOL
"RTN","HLOCVU",82,0)
 ..S PROTOCOL=$P($G(^ORD(101,PROTOCOL,0)),"^")
"RTN","HLOCVU",83,0)
 .E  D
"RTN","HLOCVU",84,0)
 ..S WHO(CT)=$O(^ORD(101,"B",PROTOCOL,0))
"RTN","HLOCVU",85,0)
 .I LINK=+LINK D
"RTN","HLOCVU",86,0)
 ..S $P(WHO(CT),"^",2)=LINK
"RTN","HLOCVU",87,0)
 ..S LINK=$P($G(^HLCS(870,LINK,0)),"^")
"RTN","HLOCVU",88,0)
 .E  D
"RTN","HLOCVU",89,0)
 ..S $P(WHO(CT),"^",2)=$O(^HLCS(870,"B",LINK,0))
"RTN","HLOCVU",90,0)
 .S WHOTO(CT,"RECEIVING APPLICATION")=PROTOCOL
"RTN","HLOCVU",91,0)
 .S WHOTO(CT,"FACILITY LINK NAME")=LINK
"RTN","HLOCVU",92,0)
 Q
"RTN","HLOESTAT")
0^8^B23707837^n/a
"RTN","HLOESTAT",1,0)
HLOESTAT ;ALB/CJM- HLO ERROR STATISTICS- 10/4/94 1pm ;03/12/2007
"RTN","HLOESTAT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**134**;Oct 13, 1995;Build 30
"RTN","HLOESTAT",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOESTAT",4,0)
 ;
"RTN","HLOESTAT",5,0)
 ;
"RTN","HLOESTAT",6,0)
COUNT(DIR,RAP,SAP,MSGTYPE,EVENT) ;
"RTN","HLOESTAT",7,0)
 ;DIR="IN" or "OUT", the "E" appended to diferentiate error stats
"RTN","HLOESTAT",8,0)
 N TYPE
"RTN","HLOESTAT",9,0)
 S:RAP="" RAP="UNKNOWN"
"RTN","HLOESTAT",10,0)
 S:SAP="" SAP="UNKNOWN"
"RTN","HLOESTAT",11,0)
 S TYPE=$G(MSGTYPE)
"RTN","HLOESTAT",12,0)
 I $L($G(EVENT)) S TYPE=TYPE_"~"_$G(EVENT)
"RTN","HLOESTAT",13,0)
 S:$L(TYPE)<2 TYPE="UNKNOWN"
"RTN","HLOESTAT",14,0)
 I $$INC^HLOSITE($NA(^HLSTATS("E"_DIR,"HOURLY",+$E($$NOW^XLFDT,1,10),SAP,RAP,TYPE)))
"RTN","HLOESTAT",15,0)
 Q
"RTN","HLOESTAT",16,0)
 ;
"RTN","HLOESTAT",17,0)
REPORT ;Interactive option for printing the message error statistics report
"RTN","HLOESTAT",18,0)
 N DIR,TYPE,START,END
"RTN","HLOESTAT",19,0)
 W !,"Hourly, daily, and monthly error statistics are maintained."
"RTN","HLOESTAT",20,0)
 W !,"Hourly statistics are available for approximately the last 24 hours."
"RTN","HLOESTAT",21,0)
 W !,"Daily statistics are available for approximately the last 30 days."
"RTN","HLOESTAT",22,0)
 W !,"Monthly statistics are kept indefinitely"
"RTN","HLOESTAT",23,0)
 S DIR(0)="S^h:HOURLY;d:DAILY;m:MONTHLY"
"RTN","HLOESTAT",24,0)
 S DIR("A")="Which type of error statistics should be reported"
"RTN","HLOESTAT",25,0)
 S DIR("B")="MONTHLY"
"RTN","HLOESTAT",26,0)
 D ^DIR
"RTN","HLOESTAT",27,0)
 Q:$D(DIRUT)
"RTN","HLOESTAT",28,0)
 I Y'="h",Y'="d",Y'="m" Q
"RTN","HLOESTAT",29,0)
 S TYPE=$S(Y="h":"HOURLY",Y="d":"DAILY",1:"MONTHLY")
"RTN","HLOESTAT",30,0)
 S START=$S(TYPE="HOURLY":$E($$FMADD^XLFDT($$NOW^XLFDT,,-24),1,10),TYPE="DAILY":$$FMADD^XLFDT(DT,-7),1:$E($$FMADD^XLFDT(DT,-30),1,5)_"01")
"RTN","HLOESTAT",31,0)
 S START=$$ASKBEGIN^HLOUSR2(START)
"RTN","HLOESTAT",32,0)
 Q:'START
"RTN","HLOESTAT",33,0)
 S END=$$ASKEND^HLOUSR2(START)
"RTN","HLOESTAT",34,0)
 Q:'END
"RTN","HLOESTAT",35,0)
 S:TYPE="MONTHLY" START=$E(START,1,5)_"00"
"RTN","HLOESTAT",36,0)
 S:TYPE="DAILY" START=$E(START,1,7)
"RTN","HLOESTAT",37,0)
 S:TYPE="HOURLY" START=$E(START,1,10)
"RTN","HLOESTAT",38,0)
 D:$$DEVICE() PRINT(TYPE,START,END)
"RTN","HLOESTAT",39,0)
 Q
"RTN","HLOESTAT",40,0)
 ;
"RTN","HLOESTAT",41,0)
QUE ;entry point for queuing the message statistics report
"RTN","HLOESTAT",42,0)
 D PRINT($G(HLOPARMS("STATISTICS TYPE")),$G(HLOPARMS("START DT/TM")),$G(HLOPARMS("END DT/TM")))
"RTN","HLOESTAT",43,0)
 Q
"RTN","HLOESTAT",44,0)
 ;
"RTN","HLOESTAT",45,0)
PRINT(STATTYPE,START,END) ;
"RTN","HLOESTAT",46,0)
 ;
"RTN","HLOESTAT",47,0)
 N RAP,SAP,TIME,DIR,COUNT,PAGE,CRT,QUIT
"RTN","HLOESTAT",48,0)
 S QUIT=0
"RTN","HLOESTAT",49,0)
 S CRT=$S($E(IOST,1,2)="C-":1,1:0)
"RTN","HLOESTAT",50,0)
 ;
"RTN","HLOESTAT",51,0)
 U IO
"RTN","HLOESTAT",52,0)
 W:CRT @IOF
"RTN","HLOESTAT",53,0)
 W "HLO MESSAGE ERROR STATISTICS REPORT ",$$FMTE^XLFDT($$NOW^XLFDT),?70,"Page 1"
"RTN","HLOESTAT",54,0)
 D LINE($$LJ("Type:",15)_STATTYPE)
"RTN","HLOESTAT",55,0)
 D LINE($$LJ("Beginning:",15)_$S(STATTYPE="MONTHLY":$$FMTE^XLFDT(START),1:$$FMTE^XLFDT(START)))
"RTN","HLOESTAT",56,0)
 D LINE($$LJ("Ending:",15)_$$FMTE^XLFDT(END))
"RTN","HLOESTAT",57,0)
 S PAGE=1
"RTN","HLOESTAT",58,0)
 ;
"RTN","HLOESTAT",59,0)
 ;
"RTN","HLOESTAT",60,0)
 F DIR="EIN","EOUT" D  Q:QUIT
"RTN","HLOESTAT",61,0)
 .N TOTAL
"RTN","HLOESTAT",62,0)
 .S TOTAL=0
"RTN","HLOESTAT",63,0)
 .D LINE(" ")
"RTN","HLOESTAT",64,0)
 .S TIME=START
"RTN","HLOESTAT",65,0)
 .S:STATTYPE="MONTHLY" TIME=$E(TIME,1,5)
"RTN","HLOESTAT",66,0)
 .S TIME=TIME-.0001
"RTN","HLOESTAT",67,0)
 .D LINE($S(DIR="EIN":"INCOMING MESSAGES:",1:"OUTGOING MESSAGES:"))
"RTN","HLOESTAT",68,0)
 .Q:QUIT
"RTN","HLOESTAT",69,0)
 .F  S TIME=$O(^HLSTATS(DIR,STATTYPE,TIME)) Q:((TIME>$G(END))&$G(END))  Q:'TIME  D  Q:QUIT
"RTN","HLOESTAT",70,0)
 ..N SUBTOTAL
"RTN","HLOESTAT",71,0)
 ..S SUBTOTAL=0
"RTN","HLOESTAT",72,0)
 ..D LINE(" ")
"RTN","HLOESTAT",73,0)
 ..Q:QUIT
"RTN","HLOESTAT",74,0)
 ..D LINE("     Time Period: "_$S(STATTYPE="MONTHLY":$$FMTE^XLFDT(TIME_"00"),1:$$FMTE^XLFDT(TIME)))
"RTN","HLOESTAT",75,0)
 ..Q:QUIT
"RTN","HLOESTAT",76,0)
 ..S SAP=""
"RTN","HLOESTAT",77,0)
 ..F  S SAP=$O(^HLSTATS(DIR,STATTYPE,TIME,SAP)) Q:SAP=""  D  Q:QUIT
"RTN","HLOESTAT",78,0)
 ...D LINE("          Sending Application: "_SAP)
"RTN","HLOESTAT",79,0)
 ...Q:QUIT
"RTN","HLOESTAT",80,0)
 ...S RAP=""
"RTN","HLOESTAT",81,0)
 ...F  S RAP=$O(^HLSTATS(DIR,STATTYPE,TIME,SAP,RAP)) Q:RAP=""  D  Q:QUIT
"RTN","HLOESTAT",82,0)
 ....D LINE("               Receiving Application: "_RAP)
"RTN","HLOESTAT",83,0)
 ....Q:QUIT
"RTN","HLOESTAT",84,0)
 ....S TYPE=""
"RTN","HLOESTAT",85,0)
 ....F  S TYPE=$O(^HLSTATS(DIR,STATTYPE,TIME,SAP,RAP,TYPE)) Q:TYPE=""  D  Q:QUIT
"RTN","HLOESTAT",86,0)
 .....S COUNT=$G(^HLSTATS(DIR,STATTYPE,TIME,SAP,RAP,TYPE))
"RTN","HLOESTAT",87,0)
 .....S SUBTOTAL=SUBTOTAL+COUNT
"RTN","HLOESTAT",88,0)
 .....D LINE("                    Message Type: "_$$LJ(TYPE,25)_"   Count:"_$$RJ(COUNT,10))
"RTN","HLOESTAT",89,0)
 .....Q:QUIT
"RTN","HLOESTAT",90,0)
 ..I 'QUIT D
"RTN","HLOESTAT",91,0)
 ...S TOTAL=TOTAL+SUBTOTAL
"RTN","HLOESTAT",92,0)
 ...D LINE(" "),LINE($$RJ("**"_STATTYPE_" SUBTOTAL: ",68)_$$RJ(SUBTOTAL,10))
"RTN","HLOESTAT",93,0)
 .D:'QUIT LINE(" "),LINE($$RJ("** TOTAL "_$S(DIR="EIN":"INCOMING",1:"OUTGOING")_" MESSAGE ERRORS: ",68)_$$RJ(TOTAL,10))
"RTN","HLOESTAT",94,0)
 I CRT,'QUIT D PAUSE2
"RTN","HLOESTAT",95,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLOESTAT",96,0)
 D ^%ZISC
"RTN","HLOESTAT",97,0)
 Q
"RTN","HLOESTAT",98,0)
 ;
"RTN","HLOESTAT",99,0)
DEVICE() ;
"RTN","HLOESTAT",100,0)
 ;Description: allows the user to select a device.
"RTN","HLOESTAT",101,0)
 ;Input: none
"RTN","HLOESTAT",102,0)
 ;
"RTN","HLOESTAT",103,0)
 ;Output:
"RTN","HLOESTAT",104,0)
 ;  Function Value - Returns 0 if the user decides not to print or to
"RTN","HLOESTAT",105,0)
 ;    queue the report, 1 otherwise.
"RTN","HLOESTAT",106,0)
 ;
"RTN","HLOESTAT",107,0)
 N OK,HLOPARMS
"RTN","HLOESTAT",108,0)
 S OK=1
"RTN","HLOESTAT",109,0)
 S %ZIS="MQ"
"RTN","HLOESTAT",110,0)
 D ^%ZIS
"RTN","HLOESTAT",111,0)
 S:POP OK=0
"RTN","HLOESTAT",112,0)
 D:OK&$D(IO("Q"))
"RTN","HLOESTAT",113,0)
 .S HLOPARMS("STATISTICS TYPE")=TYPE,HLOPARMS("START DT/TM")=START,HLOPARMS("END DT/TM")=END
"RTN","HLOESTAT",114,0)
 .S ZTRTN="QUE^HLOESTAT",ZTDESC="HLO ERROR STATISTICS REPORT",ZTSAVE("HLOPARMS(")=""
"RTN","HLOESTAT",115,0)
 .D ^%ZTLOAD
"RTN","HLOESTAT",116,0)
 .W !,$S($D(ZTSK):"REQUEST QUEUED TASK="_ZTSK,1:"REQUEST CANCELLED")
"RTN","HLOESTAT",117,0)
 .D HOME^%ZIS
"RTN","HLOESTAT",118,0)
 .S OK=0
"RTN","HLOESTAT",119,0)
 Q OK
"RTN","HLOESTAT",120,0)
 ;
"RTN","HLOESTAT",121,0)
PAUSE ;
"RTN","HLOESTAT",122,0)
 ;First scrolls to the bottome of the page, then does a screen pause.  Sets QUIT=1 if user decides to quit.
"RTN","HLOESTAT",123,0)
 ;
"RTN","HLOESTAT",124,0)
 N DIR,X,Y
"RTN","HLOESTAT",125,0)
 F  Q:$Y>(IOSL-3)  W !
"RTN","HLOESTAT",126,0)
 S DIR(0)="E"
"RTN","HLOESTAT",127,0)
 D ^DIR
"RTN","HLOESTAT",128,0)
 I ('(+Y))!$D(DIRUT) S QUIT=1
"RTN","HLOESTAT",129,0)
 Q
"RTN","HLOESTAT",130,0)
PAUSE2 ;
"RTN","HLOESTAT",131,0)
 ;Screen pause without scrolling.  Sets QUIT=1 if user decides to quit.
"RTN","HLOESTAT",132,0)
 ;
"RTN","HLOESTAT",133,0)
 N DIR,X,Y
"RTN","HLOESTAT",134,0)
 S DIR(0)="E"
"RTN","HLOESTAT",135,0)
 D ^DIR
"RTN","HLOESTAT",136,0)
 I ('(+Y))!$D(DIRUT) S QUIT=1
"RTN","HLOESTAT",137,0)
 Q
"RTN","HLOESTAT",138,0)
 ;
"RTN","HLOESTAT",139,0)
LINE(LINE) ;Prints a line.
"RTN","HLOESTAT",140,0)
 ;
"RTN","HLOESTAT",141,0)
 I CRT,($Y>(IOSL-4)) D
"RTN","HLOESTAT",142,0)
 .D PAUSE
"RTN","HLOESTAT",143,0)
 .Q:QUIT
"RTN","HLOESTAT",144,0)
 .W @IOF
"RTN","HLOESTAT",145,0)
 .W LINE
"RTN","HLOESTAT",146,0)
 ;
"RTN","HLOESTAT",147,0)
 E  I ('CRT),($Y>(IOSL-2)) D
"RTN","HLOESTAT",148,0)
 .W @IOF
"RTN","HLOESTAT",149,0)
 .W ?70,"Page: ",PAGE
"RTN","HLOESTAT",150,0)
 .S PAGE=PAGE+1
"RTN","HLOESTAT",151,0)
 .W LINE
"RTN","HLOESTAT",152,0)
 ;
"RTN","HLOESTAT",153,0)
 E  W !,LINE
"RTN","HLOESTAT",154,0)
 Q
"RTN","HLOESTAT",155,0)
 ;
"RTN","HLOESTAT",156,0)
LJ(STRING,LEN) ;
"RTN","HLOESTAT",157,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOESTAT",158,0)
RJ(STRING,LEN) ;
"RTN","HLOESTAT",159,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOF778")
0^22^B31810576^B26674072
"RTN","HLOF778",1,0)
HLOF778 ;ALB/CJM-HL7 - Saving messages to file 778 ;03/15/2007
"RTN","HLOF778",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134**;Oct 13, 1995;Build 30
"RTN","HLOF778",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOF778",4,0)
 ;
"RTN","HLOF778",5,0)
 ;
"RTN","HLOF778",6,0)
SAVEMSG(HLMSTATE) ;
"RTN","HLOF778",7,0)
 ;If a record has not yet been created in file 778, then it will be created. Will file any segments into 777 not yet stored.  For batch messages, will store the MSH segments in 778 as the individual messages are stored in 777.
"RTN","HLOF778",8,0)
 ;Input:
"RTN","HLOF778",9,0)
 ;  HLMSTATE (pass by reference) - contains information about the message
"RTN","HLOF778",10,0)
 ;    These subscripts must be defined:
"RTN","HLOF778",11,0)
 ;  ("BATCH")=1 if batch, 0 otherwise
"RTN","HLOF778",12,0)
 ;  ("BATCH","BTS")=BTS segment if end of batch reached
"RTN","HLOF778",13,0)
 ;  ("BODY")=ien file 777 if stored
"RTN","HLOF778",14,0)
 ;  ("DIRECTION")=<"IN" or "OUT">
"RTN","HLOF778",15,0)
 ;  ("IEN")=ien,file 778 if stored
"RTN","HLOF778",16,0)
 ;  ("UNSTORED LINES") - count of lines to be stored.  The lines are at the a lower subscript level <msg>,<segment>,<line>=<line to be stored>
"RTN","HLOF778",17,0)
 ;  ("UNSTORED MSH") For batch messages, set to 1 if there are MSH in cache. Cached MSH at ("UNSTORED MSH",<subfile ien>,<1 & 2>)
"RTN","HLOF778",18,0)
 ;
"RTN","HLOF778",19,0)
 ;Output:
"RTN","HLOF778",20,0)
 ;  Function - returns the ien of the msg (file 778)
"RTN","HLOF778",21,0)
 ;  HLMSTATE
"RTN","HLOF778",22,0)
 ;   ("BODY") - set to ien, file 777 if newly created
"RTN","HLOF778",23,0)
 ;   ("IEN") - set to ien, file 778 if newly created
"RTN","HLOF778",24,0)
 ;   ("UNSTORED LINES")-set to 0 as this function will store them
"RTN","HLOF778",25,0)
 ;   ("UNSTORED MSH")- set to 0 as this function will store it
"RTN","HLOF778",26,0)
 ;
"RTN","HLOF778",27,0)
 ;
"RTN","HLOF778",28,0)
 I '$D(HLMSTATE("DT/TM")) S HLMSTATE("DT/TM")=$S(HLMSTATE("DIRECTION")="IN":$$NOW^XLFDT,1:"")
"RTN","HLOF778",29,0)
 ;
"RTN","HLOF778",30,0)
 ;insure that 777 entry created & all segments stored
"RTN","HLOF778",31,0)
 I ('HLMSTATE("BODY"))!($G(HLMSTATE("UNSTORED LINES")))!($L($G(HLMSTATE("BATCH","BTS")))),'$$SAVEMSG^HLOF777(.HLMSTATE) Q 0
"RTN","HLOF778",32,0)
 ;
"RTN","HLOF778",33,0)
 ;insure 778 entry created
"RTN","HLOF778",34,0)
 I 'HLMSTATE("IEN") Q:'$$NEW^HLOF778A(.HLMSTATE) 0
"RTN","HLOF778",35,0)
 ;
"RTN","HLOF778",36,0)
 ;for batch messages, store MSH segments in 778
"RTN","HLOF778",37,0)
 I HLMSTATE("BATCH") D
"RTN","HLOF778",38,0)
 .N IEN S IEN=HLMSTATE("IEN")
"RTN","HLOF778",39,0)
 .;
"RTN","HLOF778",40,0)
 .;incoming messages cache the MSH segments in memory
"RTN","HLOF778",41,0)
 .I HLMSTATE("DIRECTION")="IN",HLMSTATE("UNSTORED MSH") D
"RTN","HLOF778",42,0)
 ..N ORDER S ORDER=0
"RTN","HLOF778",43,0)
 ..F  S ORDER=$O(HLMSTATE("UNSTORED MSH",ORDER)) Q:'ORDER  D
"RTN","HLOF778",44,0)
 ...N FS,MSGID
"RTN","HLOF778",45,0)
 ...S FS=$E(HLMSTATE("UNSTORED MSH",ORDER,1),4)
"RTN","HLOF778",46,0)
 ...S MSGID=$P(HLMSTATE("UNSTORED MSH",ORDER,2),FS,5)
"RTN","HLOF778",47,0)
 ...S ^HLB(IEN,3,ORDER,0)=ORDER_"^"_MSGID_"^"_$G(HLMSTATE("BATCH","ACK TO",ORDER))
"RTN","HLOF778",48,0)
 ...S ^HLB(IEN,3,ORDER,1)=HLMSTATE("UNSTORED MSH",ORDER,1)
"RTN","HLOF778",49,0)
 ...S ^HLB(IEN,3,ORDER,2)=HLMSTATE("UNSTORED MSH",ORDER,2)
"RTN","HLOF778",50,0)
 ...S ^HLB(IEN,3,"B",ORDER,ORDER)=""
"RTN","HLOF778",51,0)
 ...I MSGID]"" S ^HLB("AE",MSGID,IEN_"^"_ORDER)="" ;whole file index for individual message id
"RTN","HLOF778",52,0)
 ..K HLMSTATE("UNSTORED MSH") S HLMSTATE("UNSTORED MSH")=0
"RTN","HLOF778",53,0)
 .;
"RTN","HLOF778",54,0)
 .;
"RTN","HLOF778",55,0)
 .I HLMSTATE("DIRECTION")="OUT" D
"RTN","HLOF778",56,0)
 ..;must build the MSH segments!
"RTN","HLOF778",57,0)
 ..N HDR,FS,MSG,CS
"RTN","HLOF778",58,0)
 ..S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOF778",59,0)
 ..S CS=$E(HLMSTATE("HDR","ENCODING CHARACTERS"),1)
"RTN","HLOF778",60,0)
 ..S HLMSTATE("HDR","MESSAGE TYPE")="   "
"RTN","HLOF778",61,0)
 ..S HLMSTATE("HDR","EVENT")="   "
"RTN","HLOF778",62,0)
 ..D BUILDHDR^HLOPBLD1(.HLMSTATE,"MSH",.HDR)
"RTN","HLOF778",63,0)
 ..S HLMSTATE("BATCH","CURRENT MESSAGE")=$O(^HLB(HLMSTATE("IEN"),3,"B",";"),-1)
"RTN","HLOF778",64,0)
 ..F  Q:'$$NEXTMSG(.HLMSTATE,.MSG)  D
"RTN","HLOF778",65,0)
 ...N MSGID,CUR
"RTN","HLOF778",66,0)
 ...S CUR=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOF778",67,0)
 ...S MSGID=HLMSTATE("HDR","BATCH CONTROL ID")_"-"_CUR
"RTN","HLOF778",68,0)
 ...S $P(HDR(2),FS,4)=MSG("MESSAGE TYPE")_CS_MSG("EVENT")
"RTN","HLOF778",69,0)
 ...S $P(HDR(2),FS,5)=MSGID
"RTN","HLOF778",70,0)
 ...S ^HLB(IEN,3,CUR,0)=CUR_"^"_MSGID_"^"_$G(HLMSTATE("BATCH","ACK TO",CUR))
"RTN","HLOF778",71,0)
 ...S ^HLB(IEN,3,CUR,1)=HDR(1)
"RTN","HLOF778",72,0)
 ...S ^HLB(IEN,3,CUR,2)=HDR(2)
"RTN","HLOF778",73,0)
 ...S ^HLB(IEN,3,"B",CUR,CUR)=""
"RTN","HLOF778",74,0)
 ...S ^HLB("AE",MSGID,IEN_"^"_CUR)="" ;whole file index for individual message id
"RTN","HLOF778",75,0)
 ..;
"RTN","HLOF778",76,0)
 .;if the messages are application acks, then update the original message
"RTN","HLOF778",77,0)
 .N SUBIEN S SUBIEN=0
"RTN","HLOF778",78,0)
 .F  S SUBIEN=$O(HLMSTATE("BATCH","ACK TO",SUBIEN)) Q:'SUBIEN  I $G(HLMSTATE("BATCH","ACK TO",SUBIEN,"IEN"))]"" D
"RTN","HLOF778",79,0)
 ..N ACKTO
"RTN","HLOF778",80,0)
 ..M ACKTO=HLMSTATE("BATCH","ACK TO",SUBIEN)
"RTN","HLOF778",81,0)
 ..;
"RTN","HLOF778",82,0)
 ..;for outgoing msgs, we just created the msgid, for incoming msgs we already had it
"RTN","HLOF778",83,0)
 ..S:HLMSTATE("DIRECTION")="OUT" ACKTO("ACK BY")=HLMSTATE("HDR","BATCH CONTROL ID")_"-"_SUBIEN
"RTN","HLOF778",84,0)
 ..;
"RTN","HLOF778",85,0)
 ..D ACKTO(.HLMSTATE,.ACKTO)
"RTN","HLOF778",86,0)
 .K HLMSTATE("BATCH","ACK TO")
"RTN","HLOF778",87,0)
 ;
"RTN","HLOF778",88,0)
 ;if the msg is an app ack, update the original if not done already
"RTN","HLOF778",89,0)
 I $G(HLMSTATE("ACK TO","IEN"))]"",'$G(HLMSTATE("ACK TO","DONE")) D
"RTN","HLOF778",90,0)
 .N ACKTO
"RTN","HLOF778",91,0)
 .M ACKTO=HLMSTATE("ACK TO")
"RTN","HLOF778",92,0)
 .S ACKTO("ACK BY")=$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOF778",93,0)
 .D ACKTO(.HLMSTATE,.ACKTO)
"RTN","HLOF778",94,0)
 .S HLMSTATE("ACK TO","DONE")=1 ;so the update isn't done again
"RTN","HLOF778",95,0)
 ;
"RTN","HLOF778",96,0)
 Q HLMSTATE("IEN")
"RTN","HLOF778",97,0)
 ;
"RTN","HLOF778",98,0)
NEXTMSG(HLMSTATE,MSG) ;
"RTN","HLOF778",99,0)
 ;Traverses file 777 to return the next message in the batch - as
"RTN","HLOF778",100,0)
 ;indicated by HLMSTATE("BATCH","CURRENT MESSAGE")  Set to 0 to start,
"RTN","HLOF778",101,0)
 ;returns 0 when there are no more messages
"RTN","HLOF778",102,0)
 ;
"RTN","HLOF778",103,0)
 ;Input:  HLMSTATE (pass by reference,required)
"RTN","HLOF778",104,0)
 ;Output:
"RTN","HLOF778",105,0)
 ;  HLMSTATE
"RTN","HLOF778",106,0)
 ;     ("BATCH","CURRENT MESSAGE")
"RTN","HLOF778",107,0)
 ;  MSG -pass by reference:
"RTN","HLOF778",108,0)
 ;     ("EVENT")
"RTN","HLOF778",109,0)
 ;     ("MESSAGE TYPE")
"RTN","HLOF778",110,0)
 ;
"RTN","HLOF778",111,0)
 ;
"RTN","HLOF778",112,0)
 N SUBIEN,NODE
"RTN","HLOF778",113,0)
 K MSG
"RTN","HLOF778",114,0)
 Q:'$G(HLMSTATE("BODY")) 0
"RTN","HLOF778",115,0)
 S SUBIEN=$O(^HLA(HLMSTATE("BODY"),2,HLMSTATE("BATCH","CURRENT MESSAGE")))
"RTN","HLOF778",116,0)
 Q:'SUBIEN 0
"RTN","HLOF778",117,0)
 S NODE=$G(^HLA(HLMSTATE("BODY"),2,SUBIEN,0))
"RTN","HLOF778",118,0)
 S MSG("MESSAGE TYPE")=$P(NODE,"^",2)
"RTN","HLOF778",119,0)
 S MSG("EVENT")=$P(NODE,"^",3)
"RTN","HLOF778",120,0)
 S HLMSTATE("BATCH","CURRENT MESSAGE")=SUBIEN
"RTN","HLOF778",121,0)
 Q SUBIEN
"RTN","HLOF778",122,0)
 ;
"RTN","HLOF778",123,0)
ACKTO(HLMSTATE,ACKTO) ;if this is an application ack, update the original message - but do not overlay if already valued
"RTN","HLOF778",124,0)
 ;ACKTO = (msgid of msg being ack'd)
"RTN","HLOF778",125,0)
 ;        uses these subscripts ("IEN"=ien^subien),("ACK BY"=msgid of acking msg),("STATUS"=status for the initial msg determined by the ack)
"RTN","HLOF778",126,0)
 ;
"RTN","HLOF778",127,0)
 N STATUS,IEN,SUBIEN,NODE,SKIP
"RTN","HLOF778",128,0)
 S SKIP=0
"RTN","HLOF778",129,0)
 S STATUS=$G(ACKTO("STATUS"))
"RTN","HLOF778",130,0)
 S IEN=+ACKTO("IEN"),SUBIEN=$P(ACKTO("IEN"),"^",2)
"RTN","HLOF778",131,0)
 S NODE=$G(^HLB(IEN,0))
"RTN","HLOF778",132,0)
 I 'SUBIEN D
"RTN","HLOF778",133,0)
 .;ack is to a message NOT in a batch
"RTN","HLOF778",134,0)
 .I $P(NODE,"^",7)'="",$P(NODE,"^",7)'=ACKTO("ACK BY") S SKIP=1 Q
"RTN","HLOF778",135,0)
 .I STATUS="" S STATUS="SU"
"RTN","HLOF778",136,0)
 .S $P(NODE,"^",7)=ACKTO("ACK BY")
"RTN","HLOF778",137,0)
 .S $P(NODE,"^",20)=STATUS
"RTN","HLOF778",138,0)
 .S $P(NODE,"^",21)=$G(ACKTO("ERROR TEXT"))
"RTN","HLOF778",139,0)
 .S ^HLB(IEN,0)=NODE
"RTN","HLOF778",140,0)
 E  D
"RTN","HLOF778",141,0)
 .;ack is to a message that IS in a batch
"RTN","HLOF778",142,0)
 .S $P(^HLB(IEN,3,SUBIEN,0),"^",4)=$G(ACKTO("ACK BY"))
"RTN","HLOF778",143,0)
 .S $P(^HLB(IEN,3,SUBIEN,0),"^",5)=STATUS
"RTN","HLOF778",144,0)
 I (STATUS="AE"),'SKIP D
"RTN","HLOF778",145,0)
 .N APP
"RTN","HLOF778",146,0)
 .S APP=HLMSTATE("HDR","SENDING APPLICATION")
"RTN","HLOF778",147,0)
 .I APP="" S APP="UNKNOWN"
"RTN","HLOF778",148,0)
 .S ^HLB("ERRORS","AE",APP,$$NOW^XLFDT,ACKTO("IEN"))=""
"RTN","HLOF778",149,0)
 .;don't count the error - the app ack was already counted as an error.
"RTN","HLOF778",150,0)
 .D COUNT^HLOESTAT("IN",$G(HLMSTATE("HDR","RECEIVING APPLICATION")),$G(HLMSTATE("HDR","SENDING APPLICATION")),$S(HLMSTATE("BATCH"):"BATCH",1:$G(HLMSTATE("HDR","MESSAGE TYPE"))),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOF778",151,0)
 Q
"RTN","HLOF778A")
0^11^B38921929^B35675106
"RTN","HLOF778A",1,0)
HLOF778A ;ALB/CJM-HL7 - Saving messages to file 778 (continued) ;03/07/2007
"RTN","HLOF778A",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134**;Oct 13, 1995;Build 30
"RTN","HLOF778A",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOF778A",4,0)
 ;
"RTN","HLOF778A",5,0)
 ;
"RTN","HLOF778A",6,0)
NEW(HLMSTATE) ;
"RTN","HLOF778A",7,0)
 ;This function creates a new entry in file 778.
"RTN","HLOF778A",8,0)
 ;Input:
"RTN","HLOF778A",9,0)
 ;   HLMSTATE (required, pass by reference) These subscripts are expected:
"RTN","HLOF778A",10,0)
 ;
"RTN","HLOF778A",11,0)
 ;Output - the function returns the ien of the newly created record
"RTN","HLOF778A",12,0)
 ;
"RTN","HLOF778A",13,0)
 N IEN,NODE,ID,STAT
"RTN","HLOF778A",14,0)
 S STAT="HLMSTATE(""STATUS"")"
"RTN","HLOF778A",15,0)
 S IEN=$$NEWIEN(HLMSTATE("DIRECTION"),$$TCP)
"RTN","HLOF778A",16,0)
 Q:'IEN 0
"RTN","HLOF778A",17,0)
 S HLMSTATE("IEN")=IEN
"RTN","HLOF778A",18,0)
 ;
"RTN","HLOF778A",19,0)
 D  ;build the message header
"RTN","HLOF778A",20,0)
 .N HDR
"RTN","HLOF778A",21,0)
 .;for incoming messages the header segment should already exist
"RTN","HLOF778A",22,0)
 .;for outgoing messages must build the header segment
"RTN","HLOF778A",23,0)
 .I HLMSTATE("DIRECTION")="OUT" D  Q
"RTN","HLOF778A",24,0)
 ..I HLMSTATE("BATCH"),$G(HLMSTATE("ACK TO"))]"" S HLMSTATE("HDR","REFERENCE BATCH CONTROL ID")=HLMSTATE("ACK TO")
"RTN","HLOF778A",25,0)
 ..D BUILDHDR^HLOPBLD1(.HLMSTATE,$S(HLMSTATE("BATCH"):"BHS",1:"MSH"),.HDR)
"RTN","HLOF778A",26,0)
 ..S HLMSTATE("HDR",1)=HDR(1),HLMSTATE("HDR",2)=HDR(2)
"RTN","HLOF778A",27,0)
 ;
"RTN","HLOF778A",28,0)
 K ^HLB(IEN)
"RTN","HLOF778A",29,0)
 S ID=$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOF778A",30,0)
 S NODE=ID_"^"_HLMSTATE("BODY")_"^"_$G(HLMSTATE("ACK TO"))_"^"_$S(HLMSTATE("DIRECTION")="IN":"I",1:"O")_"^"
"RTN","HLOF778A",31,0)
 S $P(NODE,"^",5)=$G(@STAT@("LINK NAME"))
"RTN","HLOF778A",32,0)
 S $P(NODE,"^",6)=$G(@STAT@("QUEUE"))
"RTN","HLOF778A",33,0)
 S $P(NODE,"^",8)=$G(@STAT@("PORT"))
"RTN","HLOF778A",34,0)
 S $P(NODE,"^",20)=$G(@STAT)
"RTN","HLOF778A",35,0)
 S $P(NODE,"^",21)=$G(@STAT@("ERROR TEXT"))
"RTN","HLOF778A",36,0)
 S $P(NODE,"^",16)=HLMSTATE("DT/TM")
"RTN","HLOF778A",37,0)
 ;
"RTN","HLOF778A",38,0)
 I HLMSTATE("DIRECTION")="OUT" D
"RTN","HLOF778A",39,0)
 .S $P(NODE,"^",10)=$P($G(@STAT@("APP ACK RESPONSE")),"^")
"RTN","HLOF778A",40,0)
 .S $P(NODE,"^",11)=$P($G(@STAT@("APP ACK RESPONSE")),"^",2)
"RTN","HLOF778A",41,0)
 .S $P(NODE,"^",12)=$P($G(@STAT@("ACCEPT ACK RESPONSE")),"^")
"RTN","HLOF778A",42,0)
 .S $P(NODE,"^",13)=$P($G(@STAT@("ACCEPT ACK RESPONSE")),"^",2)
"RTN","HLOF778A",43,0)
 .S $P(NODE,"^",14)=$P($G(@STAT@("FAILURE RESPONSE")),"^")
"RTN","HLOF778A",44,0)
 .S $P(NODE,"^",15)=$P($G(@STAT@("FAILURE RESPONSE")),"^",2)
"RTN","HLOF778A",45,0)
 .;
"RTN","HLOF778A",46,0)
 .;for outgoing set these x-refs now, for incoming msgs set them later
"RTN","HLOF778A",47,0)
 .S ^HLB("B",ID,IEN)=""
"RTN","HLOF778A",48,0)
 .S ^HLB("C",HLMSTATE("BODY"),IEN)=""
"RTN","HLOF778A",49,0)
 .I ($G(@STAT)="SE") D
"RTN","HLOF778A",50,0)
 ..S ^HLB("ERRORS","SE",$S($L($G(HLMSTATE("HDR","RECEIVING APPLICATION"))):HLMSTATE("HDR","RECEIVING APPLICATION"),1:"UNKNOWN"),HLMSTATE("DT/TM CREATED"),IEN)=""
"RTN","HLOF778A",51,0)
 ..D COUNT^HLOESTAT("OUT",$G(HLMSTATE("HDR","RECEIVING APPLICATION")),$G(HLMSTATE("HDR","SENDING APPLICATION")),$S(HLMSTATE("BATCH"):"BATCH",1:$G(HLMSTATE("HDR","MESSAGE TYPE"))),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOF778A",52,0)
 .;
"RTN","HLOF778A",53,0)
 .;save some space for the ack
"RTN","HLOF778A",54,0)
 .S:($G(HLMSTATE("HDR","ACCEPT ACK TYPE"))="AL") ^HLB(IEN,4)="^^^                                                                 "
"RTN","HLOF778A",55,0)
 I $G(HLMSTATE("STATUS","PURGE")) S $P(NODE,"^",9)=HLMSTATE("STATUS","PURGE"),^HLB("AD","OUT",HLMSTATE("STATUS","PURGE"),HLMSTATE("IEN"))=""
"RTN","HLOF778A",56,0)
 S ^HLB(IEN,0)=NODE
"RTN","HLOF778A",57,0)
 ;
"RTN","HLOF778A",58,0)
 ;store the message header
"RTN","HLOF778A",59,0)
 S ^HLB(IEN,1)=HLMSTATE("HDR",1)
"RTN","HLOF778A",60,0)
 S ^HLB(IEN,2)=HLMSTATE("HDR",2)
"RTN","HLOF778A",61,0)
 ;
"RTN","HLOF778A",62,0)
 ;if the msg is an app ack, update the original msg
"RTN","HLOF778A",63,0)
 I $G(HLMSTATE("ACK TO","IEN"))]"" D
"RTN","HLOF778A",64,0)
 .N ACKTO
"RTN","HLOF778A",65,0)
 .M ACKTO=HLMSTATE("ACK TO")
"RTN","HLOF778A",66,0)
 .S ACKTO("ACK BY")=$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOF778A",67,0)
 .D ACKTO^HLOF778(.HLMSTATE,.ACKTO)
"RTN","HLOF778A",68,0)
 .S HLMSTATE("ACK TO","DONE")=1 ;because the update was already done, otherwise it might be done again
"RTN","HLOF778A",69,0)
 ;
"RTN","HLOF778A",70,0)
 ;The "SEARCH" x-ref will be created asynchronously
"RTN","HLOF778A",71,0)
 S ^HLTMP("PENDING SEARCH X-REF",$J,HLMSTATE("DT/TM CREATED"),IEN)=""
"RTN","HLOF778A",72,0)
 ;
"RTN","HLOF778A",73,0)
 Q IEN
"RTN","HLOF778A",74,0)
 ;
"RTN","HLOF778A",75,0)
NEWIEN(DIR,TCP) ;
"RTN","HLOF778A",76,0)
 ;This function uses a counter to get the next available ien for file 778. There are 4 different counters, each assigned as range of numbers, selected via the input parameters. It does not create a record.
"RTN","HLOF778A",77,0)
 ;Inputs:
"RTN","HLOF778A",78,0)
 ;  DIR = "IN" or "OUT" (required)
"RTN","HLOF778A",79,0)
 ;  TCP = 1,0 (optional)
"RTN","HLOF778A",80,0)
 ;Output - the function returns the next available ien. Several counters are used:
"RTN","HLOF778A",81,0)
 ;
"RTN","HLOF778A",82,0)
 ;   <"OUT","TCP">
"RTN","HLOF778A",83,0)
 ;   <"OUT","NOT TCP">
"RTN","HLOF778A",84,0)
 ;   <"IN","TCP">
"RTN","HLOF778A",85,0)
 ;   <"IN","NOT TCP">
"RTN","HLOF778A",86,0)
 ;
"RTN","HLOF778A",87,0)
 N IEN,COUNTER,INC
"RTN","HLOF778A",88,0)
 I DIR="OUT" S INC=$S(+$G(TCP):0,1:100000000000)
"RTN","HLOF778A",89,0)
 I DIR="IN" S INC=$S(+$G(TCP):200000000000,1:300000000000)
"RTN","HLOF778A",90,0)
 S COUNTER=$NA(^HLC("FILE778",DIR,$S(+$G(TCP):"TCP",1:"NOT TCP")))
"RTN","HLOF778A",91,0)
AGAIN ;
"RTN","HLOF778A",92,0)
 S IEN=$$INC^HLOSITE(COUNTER,1)
"RTN","HLOF778A",93,0)
 I IEN>100000000000 D
"RTN","HLOF778A",94,0)
 .L +@COUNTER:200
"RTN","HLOF778A",95,0)
 .I $T,@COUNTER>100000000000 S @COUNTER=1,IEN=1
"RTN","HLOF778A",96,0)
 .L -@COUNTER
"RTN","HLOF778A",97,0)
 I IEN>100000000000 G AGAIN
"RTN","HLOF778A",98,0)
 Q (IEN+INC)
"RTN","HLOF778A",99,0)
 ;
"RTN","HLOF778A",100,0)
TCP() ;checks the link to see if its TCP, return 1 if yes, 0 if no or not defined
"RTN","HLOF778A",101,0)
 N IEN,TCP
"RTN","HLOF778A",102,0)
 S TCP=1
"RTN","HLOF778A",103,0)
 S IEN=$G(HLMSTATE("STATUS","LINK IEN"))
"RTN","HLOF778A",104,0)
 I IEN,$P($G(^HLCS(869.1,+$P($G(^HLCS(870,IEN,0)),"^",3),0)),"^")'="TCP" S TCP=0
"RTN","HLOF778A",105,0)
 Q TCP
"RTN","HLOF778A",106,0)
 ;
"RTN","HLOF778A",107,0)
GETWORK(WORK) ; Used by the Process Manager.
"RTN","HLOF778A",108,0)
 ;Are there any messages that need the "SEARCH" x-ref set?
"RTN","HLOF778A",109,0)
 ;Inputs:
"RTN","HLOF778A",110,0)
 ;  WORK (required, pass-by-reference)
"RTN","HLOF778A",111,0)
 ;    ("DOLLARJ")
"RTN","HLOF778A",112,0)
 ;    ("NOW") (required by the process manager, pass-by-reference)
"RTN","HLOF778A",113,0)
 ;
"RTN","HLOF778A",114,0)
 L +^HLTMP("PENDING SEARCH X-REF"):0
"RTN","HLOF778A",115,0)
 Q:'$T 0
"RTN","HLOF778A",116,0)
 N OLD,DOLLARJ,SUCCESS,NOW
"RTN","HLOF778A",117,0)
 S SUCCESS=0
"RTN","HLOF778A",118,0)
 S NOW=$$SEC^XLFDT($H)
"RTN","HLOF778A",119,0)
 S (OLD,DOLLARJ)=$G(WORK("DOLLARJ"))
"RTN","HLOF778A",120,0)
 F  S DOLLARJ=$O(^HLTMP("PENDING SEARCH X-REF",DOLLARJ)) Q:DOLLARJ=""  D  Q:SUCCESS
"RTN","HLOF778A",121,0)
 .N TIME S TIME=$O(^HLTMP("PENDING SEARCH X-REF",DOLLARJ,""))
"RTN","HLOF778A",122,0)
 .S:(NOW-$$SEC^XLFDT(TIME)>100) SUCCESS=1
"RTN","HLOF778A",123,0)
 ;
"RTN","HLOF778A",124,0)
 I OLD'="",'SUCCESS F  S DOLLARJ=$O(^HLTMP("PENDING SEARCH X-REF",DOLLARJ)) Q:DOLLARJ=""  Q:DOLLARJ>OLD  D  Q:SUCCESS
"RTN","HLOF778A",125,0)
 .N TIME S TIME=$O(^HLTMP("PENDING SEARCH X-REF",DOLLARJ,""))
"RTN","HLOF778A",126,0)
 .S:(NOW-$$SEC^XLFDT(TIME)>100) SUCCESS=1
"RTN","HLOF778A",127,0)
 S WORK("DOLLARJ")=DOLLARJ,WORK("NOW")=NOW
"RTN","HLOF778A",128,0)
 Q:WORK("DOLLARJ")]"" 1
"RTN","HLOF778A",129,0)
 L -^HLTMP("PENDING SEARCH X-REF")
"RTN","HLOF778A",130,0)
 Q 0
"RTN","HLOF778A",131,0)
 ;
"RTN","HLOF778A",132,0)
DOWORK(WORK) ;Used by the Process Manager
"RTN","HLOF778A",133,0)
 ;Sets the "SEARCH" x-ref, running 100 seconds behind when the message record was created.
"RTN","HLOF778A",134,0)
 ;
"RTN","HLOF778A",135,0)
 N MSGIEN,TIME
"RTN","HLOF778A",136,0)
 S TIME=0
"RTN","HLOF778A",137,0)
 F  S TIME=$O(^HLTMP("PENDING SEARCH X-REF",WORK("DOLLARJ"),TIME)) Q:'TIME  Q:((WORK("NOW")-$$SEC^XLFDT(TIME))<100)  D
"RTN","HLOF778A",138,0)
 .S MSGIEN=0
"RTN","HLOF778A",139,0)
 .F  S MSGIEN=$O(^HLTMP("PENDING SEARCH X-REF",WORK("DOLLARJ"),TIME,MSGIEN)) Q:'MSGIEN  D
"RTN","HLOF778A",140,0)
 ..N MSG
"RTN","HLOF778A",141,0)
 ..I $$GETMSG^HLOMSG(MSGIEN,.MSG) D
"RTN","HLOF778A",142,0)
 ...Q:'MSG("DT/TM CREATED")
"RTN","HLOF778A",143,0)
 ...I MSG("BATCH") D
"RTN","HLOF778A",144,0)
 ....N HDR
"RTN","HLOF778A",145,0)
 ....F  Q:'$$NEXTMSG^HLOMSG(.MSG,.HDR)  S MSG("HDR",1)=HDR(1),MSG("HDR",2)=HDR(2) D SET(.MSG)
"RTN","HLOF778A",146,0)
 ...E  D
"RTN","HLOF778A",147,0)
 ....D SET(.MSG)
"RTN","HLOF778A",148,0)
 ..K ^HLTMP("PENDING SEARCH X-REF",WORK("DOLLARJ"),TIME,MSGIEN)
"RTN","HLOF778A",149,0)
 L -^HLTMP("PENDING SEARCH X-REF")
"RTN","HLOF778A",150,0)
 Q
"RTN","HLOF778A",151,0)
 ;
"RTN","HLOF778A",152,0)
SET(MSG) ;
"RTN","HLOF778A",153,0)
 ;sets the ^HLB("SEARCH") x-ref
"RTN","HLOF778A",154,0)
 ;
"RTN","HLOF778A",155,0)
 N APP,FS,CS,IEN
"RTN","HLOF778A",156,0)
 I MSG("DIRECTION")'="IN",MSG("DIRECTION")'="OUT" Q
"RTN","HLOF778A",157,0)
 S FS=$E(MSG("HDR",1),4)
"RTN","HLOF778A",158,0)
 Q:FS=""
"RTN","HLOF778A",159,0)
 S CS=$E(MSG("HDR",1),5)
"RTN","HLOF778A",160,0)
 S APP=$S(MSG("DIRECTION")="IN":$P($P(MSG("HDR",1),FS,5),CS),1:$P($P(MSG("HDR",1),FS,3),CS))
"RTN","HLOF778A",161,0)
 I APP="" S APP="UNKNOWN"
"RTN","HLOF778A",162,0)
 I MSG("BATCH") D
"RTN","HLOF778A",163,0)
 .N VALUE
"RTN","HLOF778A",164,0)
 .S VALUE=$P(MSG("HDR",2),FS,4)
"RTN","HLOF778A",165,0)
 .S MSG("MESSAGE TYPE")=$P(VALUE,CS)
"RTN","HLOF778A",166,0)
 .S MSG("EVENT")=$P(VALUE,CS,2)
"RTN","HLOF778A",167,0)
 S:MSG("MESSAGE TYPE")="" MSG("MESSAGE TYPE")="<none>"
"RTN","HLOF778A",168,0)
 S:MSG("EVENT")="" MSG("EVENT")="<none>"
"RTN","HLOF778A",169,0)
 S IEN=MSG("IEN")
"RTN","HLOF778A",170,0)
 I MSG("BATCH") S IEN=IEN_"^"_MSG("BATCH","CURRENT MESSAGE")
"RTN","HLOF778A",171,0)
 S ^HLB("SEARCH",MSG("DIRECTION"),MSG("DT/TM CREATED"),APP,MSG("MESSAGE TYPE"),MSG("EVENT"),IEN)=""
"RTN","HLOF778A",172,0)
 Q
"RTN","HLOFILER")
0^12^B28742582^B25709739
"RTN","HLOFILER",1,0)
HLOFILER ;ALB/CJM- Passes messages on the incoming queue to the applications - 10/4/94 1pm ;03/28/2007
"RTN","HLOFILER",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131,134**;Oct 13, 1995;Build 30
"RTN","HLOFILER",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOFILER",4,0)
 ;
"RTN","HLOFILER",5,0)
 ;GET WORK function for the process running under the Process Manager
"RTN","HLOFILER",6,0)
GETWORK(QUE) ;
"RTN","HLOFILER",7,0)
 ;Input:
"RTN","HLOFILER",8,0)
 ;  QUE - (pass by reference) These subscripts are used:
"RTN","HLOFILER",9,0)
 ;    ("FROM") - sending facility last obtained
"RTN","HLOFILER",10,0)
 ;    ("QUEUE") - name of the queue last obtained
"RTN","HLOFILER",11,0)
 ;Output:
"RTN","HLOFILER",12,0)
 ;  Function returns 1 if success, 0 if no more work
"RTN","HLOFILER",13,0)
 ;  QUE-  updated to identify next queu of messages to process.
"RTN","HLOFILER",14,0)
 ;
"RTN","HLOFILER",15,0)
 N FROM,QUEUE
"RTN","HLOFILER",16,0)
 I '$D(QUE("SYSTEM")) D
"RTN","HLOFILER",17,0)
 .N SYS
"RTN","HLOFILER",18,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOFILER",19,0)
 .S QUE("SYSTEM","NORMAL PURGE")=SYS("NORMAL PURGE")
"RTN","HLOFILER",20,0)
 .S QUE("SYSTEM","ERROR PURGE")=SYS("ERROR PURGE")
"RTN","HLOFILER",21,0)
 S FROM=$G(QUE("FROM")),QUEUE=$G(QUE("QUEUE"))
"RTN","HLOFILER",22,0)
 I ($G(FROM)]""),($G(QUEUE)]"") D
"RTN","HLOFILER",23,0)
 .L -^HLB("QUEUE","IN",FROM,QUEUE)
"RTN","HLOFILER",24,0)
 .F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0  Q:$T
"RTN","HLOFILER",25,0)
 I ($G(FROM)]""),($G(QUEUE)="") D
"RTN","HLOFILER",26,0)
 .F  S FROM=$O(^HLB("QUEUE","IN",FROM)) Q:FROM=""  D  Q:($G(QUEUE)]"")
"RTN","HLOFILER",27,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0 Q:$T
"RTN","HLOFILER",28,0)
 I FROM="" D
"RTN","HLOFILER",29,0)
 .F  S FROM=$O(^HLB("QUEUE","IN",FROM)) Q:FROM=""  D  Q:($G(QUEUE)]"")
"RTN","HLOFILER",30,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0 Q:$T
"RTN","HLOFILER",31,0)
 S QUE("FROM")=FROM,QUE("QUEUE")=QUEUE
"RTN","HLOFILER",32,0)
 Q:(QUEUE]"") 1
"RTN","HLOFILER",33,0)
 Q 0
"RTN","HLOFILER",34,0)
 ;
"RTN","HLOFILER",35,0)
DOWORK(QUEUE) ;sends the messages on the queue
"RTN","HLOFILER",36,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOFILER"
"RTN","HLOFILER",37,0)
 ;
"RTN","HLOFILER",38,0)
 N MSGIEN,DEQUE,QUE
"RTN","HLOFILER",39,0)
 M QUE=QUEUE
"RTN","HLOFILER",40,0)
 S DEQUE=0
"RTN","HLOFILER",41,0)
 S MSGIEN=0
"RTN","HLOFILER",42,0)
 ;
"RTN","HLOFILER",43,0)
 F  S MSGIEN=$O(^HLB("QUEUE","IN",QUEUE("FROM"),QUEUE("QUEUE"),MSGIEN)) Q:'MSGIEN  D  M QUEUE=QUE
"RTN","HLOFILER",44,0)
 .N MCODE,ACTION,QUE,PURGE,ACKTOIEN,NODE
"RTN","HLOFILER",45,0)
 .N $ETRAP,$ESTACK S $ETRAP="G ERROR2^HLOFILER"
"RTN","HLOFILER",46,0)
 .S NODE=$G(^HLB("QUEUE","IN",QUEUE("FROM"),QUEUE("QUEUE"),MSGIEN))
"RTN","HLOFILER",47,0)
 .S ACTION=$P(NODE,"^",1,2)
"RTN","HLOFILER",48,0)
 .S PURGE=$P(NODE,"^",3)
"RTN","HLOFILER",49,0)
 .S ACKTOIEN=$P(NODE,"^",4)
"RTN","HLOFILER",50,0)
 .D DEQUE(MSGIEN,PURGE,ACKTOIEN)
"RTN","HLOFILER",51,0)
 .I ACTION]"" D
"RTN","HLOFILER",52,0)
 ..N HLMSGIEN,MCODE,DEQUE,DUZ
"RTN","HLOFILER",53,0)
 ..N $ETRAP,$ESTACK S $ETRAP="G ERROR3^HLOFILER"
"RTN","HLOFILER",54,0)
 ..S HLMSGIEN=MSGIEN
"RTN","HLOFILER",55,0)
 ..S MCODE="D "_ACTION
"RTN","HLOFILER",56,0)
 ..N MSGIEN,X
"RTN","HLOFILER",57,0)
 ..D DUZ^XUP(.5)
"RTN","HLOFILER",58,0)
 ..X MCODE
"RTN","HLOFILER",59,0)
 ..;kill the apps variables
"RTN","HLOFILER",60,0)
 ..D
"RTN","HLOFILER",61,0)
 ...N ZTSK
"RTN","HLOFILER",62,0)
 ...D KILL^XUSCLEAN
"RTN","HLOFILER",63,0)
 ;
"RTN","HLOFILER",64,0)
ENDWORK ;where the execution resumes upon an error
"RTN","HLOFILER",65,0)
 D DEQUE()
"RTN","HLOFILER",66,0)
 Q
"RTN","HLOFILER",67,0)
 ;
"RTN","HLOFILER",68,0)
DEQUE(MSGIEN,PURGE,ACKTOIEN) ;
"RTN","HLOFILER",69,0)
 ;Dequeues the message.  Also sets up the purge dt/tm and the completion status.
"RTN","HLOFILER",70,0)
 S:$G(MSGIEN) DEQUE=$G(DEQUE)+1,DEQUE(MSGIEN)=PURGE_"^"_ACKTOIEN
"RTN","HLOFILER",71,0)
 I '$G(MSGIEN)!($G(DEQUE)>25) S MSGIEN=0 D
"RTN","HLOFILER",72,0)
 .F  S MSGIEN=$O(DEQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOFILER",73,0)
 ..N NODE,PURGE,ACKTOIEN
"RTN","HLOFILER",74,0)
 ..S NODE=DEQUE(MSGIEN)
"RTN","HLOFILER",75,0)
 ..S PURGE=$P(NODE,"^"),ACKTOIEN=$P(NODE,"^",2)
"RTN","HLOFILER",76,0)
 ..D DEQUE^HLOQUE(QUEUE("FROM"),QUEUE("QUEUE"),"IN",MSGIEN)
"RTN","HLOFILER",77,0)
 ..S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOFILER",78,0)
 ..Q:NODE=""
"RTN","HLOFILER",79,0)
 ..S $P(NODE,"^",19)=1 ;sets the flag to show that the app handoff was done
"RTN","HLOFILER",80,0)
 ..D:PURGE
"RTN","HLOFILER",81,0)
 ...N STATUS
"RTN","HLOFILER",82,0)
 ...S STATUS=$P(NODE,"^",20)
"RTN","HLOFILER",83,0)
 ...S:STATUS="" $P(NODE,"^",20)="SU",STATUS="SU"
"RTN","HLOFILER",84,0)
 ...S $P(NODE,"^",9)=$$FMADD^XLFDT($$NOW^XLFDT,,$S(PURGE=2:24*QUEUE("SYSTEM","ERROR PURGE"),$D(^HLB(MSGIEN,3,1,0)):24*QUEUE("SYSTEM","ERROR PURGE"),1:QUEUE("SYSTEM","NORMAL PURGE")))
"RTN","HLOFILER",85,0)
 ...S ^HLB("AD",$S($E($P(NODE,"^",4))="I":"IN",1:"OUT"),$P(NODE,"^",9),MSGIEN)=""
"RTN","HLOFILER",86,0)
 ...I ACKTOIEN,$D(^HLB(ACKTOIEN,0)) S $P(^HLB(ACKTOIEN,0),"^",9)=$P(NODE,"^",9),^HLB("AD",$S($E($P(NODE,"^",4))="I":"OUT",1:"IN"),$P(NODE,"^",9),ACKTOIEN)=""
"RTN","HLOFILER",87,0)
 ..S ^HLB(MSGIEN,0)=NODE
"RTN","HLOFILER",88,0)
 .K DEQUE S DEQUE=0
"RTN","HLOFILER",89,0)
 Q
"RTN","HLOFILER",90,0)
 ;
"RTN","HLOFILER",91,0)
ERROR ;error trap
"RTN","HLOFILER",92,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOFILER",93,0)
 N HOUR
"RTN","HLOFILER",94,0)
 S HOUR=$E($$NOW^XLFDT,1,10)
"RTN","HLOFILER",95,0)
 S ^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2))=$G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))+1
"RTN","HLOFILER",96,0)
 ;
"RTN","HLOFILER",97,0)
 D DEQUE()
"RTN","HLOFILER",98,0)
 ;
"RTN","HLOFILER",99,0)
 ;a lot of errors of the same type may indicate an endless loop
"RTN","HLOFILER",100,0)
 ;return to the Process Manager error trap
"RTN","HLOFILER",101,0)
 I ($G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))>30) Q:$QUIT "" Q
"RTN","HLOFILER",102,0)
 ;
"RTN","HLOFILER",103,0)
 ;while debugging quit on all errors - returns to the Process Manager error trap
"RTN","HLOFILER",104,0)
 I $G(^HLTMP("LOG ALL ERRORS")) Q:$QUIT "" Q
"RTN","HLOFILER",105,0)
 I $ECODE["EDITED" Q:$QUIT "" Q
"RTN","HLOFILER",106,0)
 ;
"RTN","HLOFILER",107,0)
 D ^%ZTER
"RTN","HLOFILER",108,0)
 D UNWIND^%ZTER
"RTN","HLOFILER",109,0)
 Q:$QUIT ""
"RTN","HLOFILER",110,0)
 Q
"RTN","HLOFILER",111,0)
 ;
"RTN","HLOFILER",112,0)
ERROR2 ;
"RTN","HLOFILER",113,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOFILER",114,0)
 ;
"RTN","HLOFILER",115,0)
 D DEQUE()
"RTN","HLOFILER",116,0)
 ;
"RTN","HLOFILER",117,0)
 ;may need to change the status to Application Error
"RTN","HLOFILER",118,0)
 D
"RTN","HLOFILER",119,0)
 .N NODE,RAPP,SAPP,FS,CS,REP,ESCAPE,SUBCOMP,HDR,DIR,NOW
"RTN","HLOFILER",120,0)
 .S NOW=$$NOW^XLFDT
"RTN","HLOFILER",121,0)
 .S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOFILER",122,0)
 .Q:NODE=""
"RTN","HLOFILER",123,0)
 .Q:$P(NODE,"^",20)="AE"
"RTN","HLOFILER",124,0)
 .S $P(NODE,"^",20)="AE",$P(NODE,"^",21)="APPLICATION ROUTINE ERROR"
"RTN","HLOFILER",125,0)
 .S DIR=$S($E($P(NODE,"^",4))="I":"IN",1:"OUT")
"RTN","HLOFILER",126,0)
 .I $P(NODE,"^",9) K ^HLB("AD",DIR,$P(NODE,"^",9),MSGIEN)
"RTN","HLOFILER",127,0)
 .S $P(NODE,"^",9)=$$FMADD^XLFDT(NOW,,24*QUEUE("SYSTEM","ERROR PURGE"))
"RTN","HLOFILER",128,0)
 .S ^HLB(MSGIEN,0)=NODE
"RTN","HLOFILER",129,0)
 .S ^HLB("AD",DIR,$P(NODE,"^",9),MSGIEN)=""
"RTN","HLOFILER",130,0)
 .S HDR=$G(^HLB(MSGIEN,1))
"RTN","HLOFILER",131,0)
 .S FS=$E(HDR,4)
"RTN","HLOFILER",132,0)
 .Q:FS=""
"RTN","HLOFILER",133,0)
 .S CS=$E(HDR,5)
"RTN","HLOFILER",134,0)
 .S REP=$E(HDR,6)
"RTN","HLOFILER",135,0)
 .S ESCAPE=$E(HDR,7)
"RTN","HLOFILER",136,0)
 .S SUBCOMP=$E(HDR,8)
"RTN","HLOFILER",137,0)
 .S RAPP=$$DESCAPE^HLOPRS1($P($P(HDR,FS,5),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOFILER",138,0)
 .I RAPP="" S RAPP="UNKNOWN"
"RTN","HLOFILER",139,0)
 .S SAPP=$$DESCAPE^HLOPRS1($P($P(HDR,FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOFILER",140,0)
 .S ^HLB("ERRORS","AE",RAPP,NOW,MSGIEN)=""
"RTN","HLOFILER",141,0)
 .D COUNT^HLOESTAT(DIR,RAPP,SAPP,"UNKNOWN")
"RTN","HLOFILER",142,0)
 ;
"RTN","HLOFILER",143,0)
 ;kill the apps variables
"RTN","HLOFILER",144,0)
 D
"RTN","HLOFILER",145,0)
 .N ZTSK,MSGIEN,QUEUE
"RTN","HLOFILER",146,0)
 .D KILL^XUSCLEAN
"RTN","HLOFILER",147,0)
 ;
"RTN","HLOFILER",148,0)
 ;release all the locks the app may have set, except Taskman lock
"RTN","HLOFILER",149,0)
 L:$D(ZTSK) ^%ZTSCH("TASK",ZTSK):1
"RTN","HLOFILER",150,0)
 L:'$D(ZTSK)
"RTN","HLOFILER",151,0)
 ;reset HLO's lock
"RTN","HLOFILER",152,0)
 L +^HLTMP("HL7 RUNNING PROCESSES",$J):0
"RTN","HLOFILER",153,0)
 ;return to processing the next message on the queue
"RTN","HLOFILER",154,0)
 S $ECODE=""
"RTN","HLOFILER",155,0)
 ;
"RTN","HLOFILER",156,0)
 Q:$QUIT ""
"RTN","HLOFILER",157,0)
 Q
"RTN","HLOFILER",158,0)
ERROR3 ;error trap for application context
"RTN","HLOFILER",159,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOFILER",160,0)
 D ^%ZTER
"RTN","HLOFILER",161,0)
 S $ECODE=",UAPPLICATION ERROR,"
"RTN","HLOFILER",162,0)
 ;
"RTN","HLOFILER",163,0)
 ;drop to the ERROR2 error handler
"RTN","HLOFILER",164,0)
 Q:$QUIT ""
"RTN","HLOFILER",165,0)
 Q
"RTN","HLOMSG")
0^30^B46053749^B44340349
"RTN","HLOMSG",1,0)
HLOMSG ;ALB/CJM-HL7 - APIs for files 777/778 ;02/04/2004
"RTN","HLOMSG",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134**;Oct 13, 1995;Build 30
"RTN","HLOMSG",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOMSG",4,0)
 ;
"RTN","HLOMSG",5,0)
GETMSG(IEN,MSG) ;
"RTN","HLOMSG",6,0)
 ;Description: given the message ien=MSGIEN (required), it returns the MSG array containing information about the message, defined below.
"RTN","HLOMSG",7,0)
 ;Input:
"RTN","HLOMSG",8,0)
 ;  IEN - the ien of the message in file 778
"RTN","HLOMSG",9,0)
 ;Output:
"RTN","HLOMSG",10,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOMSG",11,0)
 ;  MSG (pass by reference, required) These are the subscripts returned:
"RTN","HLOMSG",12,0)
 ;
"RTN","HLOMSG",13,0)
 ;   "ACK BY" - msg id of msg that acknowledges this one
"RTN","HLOMSG",14,0)
 ;   "ACK BY IEN" - msg IEN of msg that acknowledges this one.  If the message is in the batch, the value is <ien>^<subien>
"RTN","HLOMSG",15,0)
 ;   "ACK TO" - msg id of msg that this msg acknowledges
"RTN","HLOMSG",16,0)
 ;   "ACK TO IEN" - msg IEN of msg that this msg acknowledges. If the message is in a batch, the value is <ien>^<subien>
"RTN","HLOMSG",17,0)
 ;  "BATCH"  = 1 if this is a batch message, 0  if not
"RTN","HLOMSG",18,0)
 ;     "CURRENT MESSAGE" - defined only for batch messages -  a counter used during building and parsing messages to indicate the current message.  It will be set to 0 initially.
"RTN","HLOMSG",19,0)
 ;  "BODY" - ptr to file 778 which contains the body of the message.
"RTN","HLOMSG",20,0)
 ;  "DIRECTION" - "IN" if incoming, "OUT" if outgoing
"RTN","HLOMSG",21,0)
 ;  "DT/TM" - date/time the message was sent or received
"RTN","HLOMSG",22,0)
 ;  "DT/TM CREATED" - date/time the record was created (.01 field, file #777)
"RTN","HLOMSG",23,0)
 ;  "LINE COUNT" -  a counter used during building and parsing of
"RTN","HLOMSG",24,0)
 ;     messages to indicate the current line within the message. For
"RTN","HLOMSG",25,0)
 ;     batch messages where each message within the batch is stored
"RTN","HLOMSG",26,0)
 ;     separately, this field indicates the position within the current
"RTN","HLOMSG",27,0)
 ;     individual message
"RTN","HLOMSG",28,0)
 ;  "HDR" - the header segment, NOT parsed, as HDR(1) and HDR(2)
"RTN","HLOMSG",29,0)
 ;  "ID" - Message Control ID for an individual message, Batch Control ID for a batch message
"RTN","HLOMSG",30,0)
 ;  "IEN" - ien, file 778
"RTN","HLOMSG",31,0)
 ;  "EVENT" - HL7 event, only defined if NOT batch
"RTN","HLOMSG",32,0)
 ;  "MESSAGE TYPE" - HL7 message type, only defined if NOT batch
"RTN","HLOMSG",33,0)
 ;  "STATUS" - the completion status
"RTN","HLOMSG",34,0)
 ;
"RTN","HLOMSG",35,0)
 ;     These are lower level subscripts of "STATUS":
"RTN","HLOMSG",36,0)
 ;     "ACCEPT ACK RESPONSE" - the application's <tag>^<rtn> to Xecute when the accept ack is received
"RTN","HLOMSG",37,0)
 ;     "ACCEPT ACK'D" - 1 if an accept ack was sent or received in response to this message
"RTN","HLOMSG",38,0)
 ;     "APP ACK RESPONSE" - the application's <tag>^<rtn> to Xecute when app ack is received
"RTN","HLOMSG",39,0)
 ;     "APP ACK'D" - 1 if an application ack was sent or received in response to this message
"RTN","HLOMSG",40,0)
 ;     "ERROR TEXT" - if in error status, a description of the error
"RTN","HLOMSG",41,0)
 ;     "LINK NAME" the link the message was transmitted through
"RTN","HLOMSG",42,0)
 ;     "PORT" - remote port over which the message was transmitted
"RTN","HLOMSG",43,0)
 ;     "PURGE" - scheduled purge dt/tm
"RTN","HLOMSG",44,0)
 ;     "QUEUE" - the queue that the message was placed on
"RTN","HLOMSG",45,0)
 ;
"RTN","HLOMSG",46,0)
 K MSG
"RTN","HLOMSG",47,0)
 Q:'$G(IEN) 0
"RTN","HLOMSG",48,0)
 N NODE
"RTN","HLOMSG",49,0)
 S MSG("IEN")=IEN
"RTN","HLOMSG",50,0)
 S NODE=$G(^HLB(IEN,0))
"RTN","HLOMSG",51,0)
 S MSG("ID")=$P(NODE,"^")
"RTN","HLOMSG",52,0)
 S MSG("BODY")=$P(NODE,"^",2)
"RTN","HLOMSG",53,0)
 S MSG("DIRECTION")=$S($E($P(NODE,"^",4))="O":"OUT",$E($P(NODE,"^",4))="I":"IN",1:"")
"RTN","HLOMSG",54,0)
 S MSG("ACK TO")=$P(NODE,"^",3)
"RTN","HLOMSG",55,0)
 S MSG("ACK BY")=$P(NODE,"^",7)
"RTN","HLOMSG",56,0)
 I MSG("ACK TO")]"" S MSG("ACK TO IEN")=$$ACKTOIEN^HLOMSG1($P(NODE,"^"),MSG("ACK TO"))
"RTN","HLOMSG",57,0)
 I MSG("ACK BY")]"" S MSG("ACK BY IEN")=$$ACKBYIEN^HLOMSG1($P(NODE,"^"),MSG("ACK BY"))
"RTN","HLOMSG",58,0)
 S MSG("DT/TM")=$P(NODE,"^",16)
"RTN","HLOMSG",59,0)
 S MSG("STATUS")=$P(NODE,"^",20)
"RTN","HLOMSG",60,0)
 ;
"RTN","HLOMSG",61,0)
 D
"RTN","HLOMSG",62,0)
 .N NODE4
"RTN","HLOMSG",63,0)
 .S NODE4=$G(^HLB(IEN,4))
"RTN","HLOMSG",64,0)
 .S MSG("STATUS","QUEUE")=$P(NODE,"^",6)
"RTN","HLOMSG",65,0)
 .S MSG("STATUS","LINK NAME")=$P(NODE,"^",5)
"RTN","HLOMSG",66,0)
 .S MSG("STATUS","PORT")=$P(NODE,"^",8)
"RTN","HLOMSG",67,0)
 .S MSG("STATUS","PURGE")=$P(NODE,"^",9)
"RTN","HLOMSG",68,0)
 .S MSG("STATUS","ERROR TEXT")=$P(NODE,"^",21)
"RTN","HLOMSG",69,0)
 .S MSG("STATUS","APP ACK RESPONSE")=$P(NODE,"^",10,11)
"RTN","HLOMSG",70,0)
 .I MSG("STATUS","APP ACK RESPONSE")="^" S MSG("STATUS","APP ACK RESPONSE")=""
"RTN","HLOMSG",71,0)
 .S MSG("STATUS","ACCEPT ACK RESPONSE")=$P(NODE,"^",12,13)
"RTN","HLOMSG",72,0)
 .I MSG("STATUS","ACCEPT ACK RESPONSE")="^" S MSG("STATUS","ACCEPT ACK RESPONSE")=""
"RTN","HLOMSG",73,0)
 .S MSG("STATUS","ACCEPT ACK'D")=$P(NODE,"^",17)
"RTN","HLOMSG",74,0)
 .S MSG("STATUS","APP ACK'D")=$P(NODE,"^",18)
"RTN","HLOMSG",75,0)
 .S MSG("STATUS")=$P(NODE,"^",20)
"RTN","HLOMSG",76,0)
 .S MSG("STATUS","APP HANDOFF")=$P(NODE,"^",19)
"RTN","HLOMSG",77,0)
 .S MSG("STATUS","ACCEPT ACK DT/TM")=$P(NODE4,"^")
"RTN","HLOMSG",78,0)
 .S MSG("STATUS","ACCEPT ACK ID")=$P(NODE4,"^",2)
"RTN","HLOMSG",79,0)
 .S MSG("STATUS","ACCEPT ACK MSA")=$P(NODE4,"^",3,99)
"RTN","HLOMSG",80,0)
 ;
"RTN","HLOMSG",81,0)
 S MSG("LINE COUNT")=0
"RTN","HLOMSG",82,0)
 S MSG("HDR",1)=$G(^HLB(IEN,1))
"RTN","HLOMSG",83,0)
 S MSG("HDR",2)=$G(^HLB(IEN,2))
"RTN","HLOMSG",84,0)
 I 'MSG("BODY") D  Q 0
"RTN","HLOMSG",85,0)
 .S MSG("DT/TM CREATED")=""
"RTN","HLOMSG",86,0)
 .S MSG("BATCH")=""
"RTN","HLOMSG",87,0)
 .S MSG("MESSAGE TYPE")=""
"RTN","HLOMSG",88,0)
 .S MSG("EVENT")=""
"RTN","HLOMSG",89,0)
 ;
"RTN","HLOMSG",90,0)
 S NODE=$G(^HLA(MSG("BODY"),0))
"RTN","HLOMSG",91,0)
 S MSG("DT/TM CREATED")=+NODE
"RTN","HLOMSG",92,0)
 S MSG("BATCH")=+$P(NODE,"^",2)
"RTN","HLOMSG",93,0)
 I MSG("BATCH") S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOMSG",94,0)
 I 'MSG("BATCH") D
"RTN","HLOMSG",95,0)
 .S MSG("MESSAGE TYPE")=$P(NODE,"^",3)
"RTN","HLOMSG",96,0)
 .S MSG("EVENT")=$P(NODE,"^",4)
"RTN","HLOMSG",97,0)
 Q 1
"RTN","HLOMSG",98,0)
 ;
"RTN","HLOMSG",99,0)
HLNEXT(MSG,SEG) ;
"RTN","HLOMSG",100,0)
 ;Description:  Returns the next segment as a set of lines stored in SEG.
"RTN","HLOMSG",101,0)
 ;Input:
"RTN","HLOMSG",102,0)
 ;  MSG (pass by reference, required)
"RTN","HLOMSG",103,0)
 ;Output:
"RTN","HLOMSG",104,0)
 ;  Function returns 1 on success, 0 on failure (no more segments)
"RTN","HLOMSG",105,0)
 ;  SEG (pass by reference, required)
"RTN","HLOMSG",106,0)
 ;
"RTN","HLOMSG",107,0)
 K SEG
"RTN","HLOMSG",108,0)
 Q:MSG("LINE COUNT")=-1 0
"RTN","HLOMSG",109,0)
 I 'MSG("BATCH") D
"RTN","HLOMSG",110,0)
 .N I,J,NODE,START
"RTN","HLOMSG",111,0)
 .S START=0
"RTN","HLOMSG",112,0)
 .S J=1,I=MSG("LINE COUNT")
"RTN","HLOMSG",113,0)
 .F  S I=$O(^HLA(MSG("BODY"),1,I)) Q:'I  S NODE=$G(^HLA(MSG("BODY"),1,I,0)) Q:(START&(NODE=""))  I NODE'="" S SEG(J)=NODE,J=J+1,START=1
"RTN","HLOMSG",114,0)
 .I 'I D
"RTN","HLOMSG",115,0)
 ..S MSG("LINE COUNT")=-1
"RTN","HLOMSG",116,0)
 .E  S MSG("LINE COUNT")=I
"RTN","HLOMSG",117,0)
 I MSG("BATCH") D
"RTN","HLOMSG",118,0)
 .N I,J,NODE,START
"RTN","HLOMSG",119,0)
 .S J=1,I=MSG("LINE COUNT"),START=0
"RTN","HLOMSG",120,0)
 .F  S I=$O(^HLA(MSG("BODY"),2,MSG("BATCH","CURRENT MESSAGE"),1,I)) Q:'I  S NODE=$G(^HLA(MSG("BODY"),2,MSG("BATCH","CURRENT MESSAGE"),1,I,0)) Q:(START&(NODE=""))  I NODE'="" S SEG(J)=NODE,J=J+1,START=1
"RTN","HLOMSG",121,0)
 .I 'I D
"RTN","HLOMSG",122,0)
 ..S MSG("LINE COUNT")=-1
"RTN","HLOMSG",123,0)
 .E  S MSG("LINE COUNT")=I
"RTN","HLOMSG",124,0)
 Q $S($D(SEG):1,1:0)
"RTN","HLOMSG",125,0)
 ;
"RTN","HLOMSG",126,0)
NEXTMSG(MSG,HDR) ;
"RTN","HLOMSG",127,0)
 ;Advances to the next message in the batch
"RTN","HLOMSG",128,0)
 ;Input:
"RTN","HLOMSG",129,0)
 ;  MSG (pass by reference, required) - defined by $$GETMSG()
"RTN","HLOMSG",130,0)
 ;Output:
"RTN","HLOMSG",131,0)
 ;  Function returns 1 on success, 0 if no more messages
"RTN","HLOMSG",132,0)
 ;  MSG - updated with current position in the message
"RTN","HLOMSG",133,0)
 ;  HDR (pass by reference, required) returns the header as an array of lines
"RTN","HLOMSG",134,0)
 ;
"RTN","HLOMSG",135,0)
 ;
"RTN","HLOMSG",136,0)
 K HDR
"RTN","HLOMSG",137,0)
 S MSG("LINE COUNT")=0
"RTN","HLOMSG",138,0)
 N SUBIEN,I
"RTN","HLOMSG",139,0)
 ;
"RTN","HLOMSG",140,0)
 ;if completed parsing, don't start over
"RTN","HLOMSG",141,0)
 I MSG("BATCH","CURRENT MESSAGE")=-1 Q 0
"RTN","HLOMSG",142,0)
 ;
"RTN","HLOMSG",143,0)
 S I=$O(^HLB(MSG("IEN"),3,"B",MSG("BATCH","CURRENT MESSAGE")))
"RTN","HLOMSG",144,0)
 I 'I S MSG("BATCH","CURRENT MESSAGE")=-1 Q 0
"RTN","HLOMSG",145,0)
 S MSG("BATCH","CURRENT MESSAGE")=I
"RTN","HLOMSG",146,0)
 S SUBIEN=$O(^HLB(MSG("IEN"),3,"B",I,0))
"RTN","HLOMSG",147,0)
 S HDR(1)=$G(^HLB(MSG("IEN"),3,SUBIEN,1))
"RTN","HLOMSG",148,0)
 S HDR(2)=$G(^HLB(MSG("IEN"),3,SUBIEN,2))
"RTN","HLOMSG",149,0)
 Q $S($D(HDR):1,1:0)
"RTN","HLOMSG",150,0)
 ;
"RTN","HLOMSG",151,0)
ADDSEG(HLMSTATE,SEG) ;Adds a segment to the message.
"RTN","HLOMSG",152,0)
 ;Input:
"RTN","HLOMSG",153,0)
 ;  HLMSTATE() - (pass by reference, required)
"RTN","HLOMSG",154,0)
 ;  SEG() - (pass by reference, required) The segment as lines SEG(<i>)
"RTN","HLOMSG",155,0)
 ;
"RTN","HLOMSG",156,0)
 ;Output:
"RTN","HLOMSG",157,0)
 ;   HLMSTATE()
"RTN","HLOMSG",158,0)
 ;
"RTN","HLOMSG",159,0)
 N I,J S I=0
"RTN","HLOMSG",160,0)
 S J=HLMSTATE("LINE COUNT")
"RTN","HLOMSG",161,0)
 ;
"RTN","HLOMSG",162,0)
 ;insure a blank line between segments
"RTN","HLOMSG",163,0)
 I J S J=J+1,HLMSTATE("UNSTORED LINES",$S(HLMSTATE("BATCH"):HLMSTATE("BATCH","CURRENT MESSAGE"),1:1),HLMSTATE("CURRENT SEGMENT"),J)=""
"RTN","HLOMSG",164,0)
 ;
"RTN","HLOMSG",165,0)
 S HLMSTATE("CURRENT SEGMENT")=HLMSTATE("CURRENT SEGMENT")+1
"RTN","HLOMSG",166,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOMSG",167,0)
 .S J=J+1
"RTN","HLOMSG",168,0)
 .S HLMSTATE("UNSTORED LINES",$S(HLMSTATE("BATCH"):HLMSTATE("BATCH","CURRENT MESSAGE"),1:1),HLMSTATE("CURRENT SEGMENT"),J)=SEG(I),HLMSTATE("UNSTORED LINES")=HLMSTATE("UNSTORED LINES")+$L(SEG(I))+50
"RTN","HLOMSG",169,0)
 .I HLMSTATE("UNSTORED LINES")>HLMSTATE("SYSTEM","BUFFER") D
"RTN","HLOMSG",170,0)
 ..I HLMSTATE("DIRECTION")="IN",$$SAVEMSG^HLOF778(.HLMSTATE) Q
"RTN","HLOMSG",171,0)
 ..I HLMSTATE("DIRECTION")="OUT",$$SAVEMSG^HLOF777(.HLMSTATE)
"RTN","HLOMSG",172,0)
 ;
"RTN","HLOMSG",173,0)
 S HLMSTATE("LINE COUNT")=J
"RTN","HLOMSG",174,0)
 Q
"RTN","HLOMSG",175,0)
 ;
"RTN","HLOMSG",176,0)
ADDMSG(HLMSTATE,PARMS) ;
"RTN","HLOMSG",177,0)
 ;For outgoing messages, adds a message in the batch. There is no MSH yet, just the message type and event.  
"RTN","HLOMSG",178,0)
 ;Input:
"RTN","HLOMSG",179,0)
 ;  HLMSTATE() - (pass by reference, required)
"RTN","HLOMSG",180,0)
 ;  PARMS("EVENT")
"RTN","HLOMSG",181,0)
 ;  PARMS("MESSAGE TYPE")
"RTN","HLOMSG",182,0)
 ;
"RTN","HLOMSG",183,0)
 ;Output:
"RTN","HLOMSG",184,0)
 ;   HLMSTATE() - (pass by reference, required)
"RTN","HLOMSG",185,0)
 ;
"RTN","HLOMSG",186,0)
 N I
"RTN","HLOMSG",187,0)
 S I=HLMSTATE("BATCH","CURRENT MESSAGE")+1,HLMSTATE("BATCH","CURRENT MESSAGE")=I
"RTN","HLOMSG",188,0)
 S HLMSTATE("UNSTORED LINES",I)=PARMS("MESSAGE TYPE")_"^"_PARMS("EVENT")
"RTN","HLOMSG",189,0)
 M:$G(PARMS("ACK TO"))]"" HLMSTATE("BATCH","ACK TO",I)=PARMS("ACK TO")
"RTN","HLOMSG",190,0)
 S HLMSTATE("CURRENT SEGMENT")=0
"RTN","HLOMSG",191,0)
 S HLMSTATE("LINE COUNT")=0
"RTN","HLOMSG",192,0)
 S HLMSTATE("UNSTORED LINES")=HLMSTATE("UNSTORED LINES")+100
"RTN","HLOMSG",193,0)
 Q
"RTN","HLOMSG",194,0)
 ;
"RTN","HLOMSG",195,0)
ADDMSG2(HLMSTATE,MSH) ;
"RTN","HLOMSG",196,0)
 ;For incoming messages adds a message to the batch. This differs from ADDMSG in that the MSH segment is passed in to be stored in file 778.
"RTN","HLOMSG",197,0)
 ;Input:
"RTN","HLOMSG",198,0)
 ;  HLMSTATE() - (pass by reference, required)
"RTN","HLOMSG",199,0)
 ;  MSH(<i>) - the MSH segment as a set of lines
"RTN","HLOMSG",200,0)
 ;
"RTN","HLOMSG",201,0)
 ;Output:
"RTN","HLOMSG",202,0)
 ;   HLMSTATE() - (pass by reference, required)
"RTN","HLOMSG",203,0)
 ;
"RTN","HLOMSG",204,0)
 N FS,CS,VALUE
"RTN","HLOMSG",205,0)
 S HLMSTATE("BATCH","CURRENT MESSAGE")=HLMSTATE("BATCH","CURRENT MESSAGE")+1
"RTN","HLOMSG",206,0)
 S FS=$E(MSH(1),4)
"RTN","HLOMSG",207,0)
 S CS=$E(MSH(1),5)
"RTN","HLOMSG",208,0)
 S VALUE=$P(MSH(2),FS,4)
"RTN","HLOMSG",209,0)
 S HLMSTATE("UNSTORED LINES",HLMSTATE("BATCH","CURRENT MESSAGE"))=$P(VALUE,CS)_"^"_$P(VALUE,CS,2)
"RTN","HLOMSG",210,0)
 S HLMSTATE("UNSTORED MSH")=1
"RTN","HLOMSG",211,0)
 M HLMSTATE("UNSTORED MSH",HLMSTATE("BATCH","CURRENT MESSAGE"))=MSH
"RTN","HLOMSG",212,0)
 S HLMSTATE("CURRENT SEGMENT")=0
"RTN","HLOMSG",213,0)
 S HLMSTATE("LINE COUNT")=0
"RTN","HLOMSG",214,0)
 S HLMSTATE("UNSTORED LINES")=HLMSTATE("UNSTORED LINES")+200
"RTN","HLOMSG",215,0)
 I HLMSTATE("UNSTORED LINES")>HLMSTATE("SYSTEM","BUFFER"),$$SAVEMSG^HLOF778(.HLMSTATE) ;first stores stuff in 777, then headers in file 778
"RTN","HLOMSG",216,0)
 Q
"RTN","HLOPOST")
0^27^B10060576^B3878072
"RTN","HLOPOST",1,0)
HLOPOST ;IRMFO-ALB/CJM -Post-Install routine for HLO;03/24/2004  14:43 ;03/14/2007
"RTN","HLOPOST",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134**;Oct 13, 1995;Build 30
"RTN","HLOPOST",3,0)
 ;
"RTN","HLOPOST",4,0)
 N SYSTEM,DATA,VASITE,OLDSITE
"RTN","HLOPOST",5,0)
 D IDXLINKS
"RTN","HLOPOST",6,0)
 D SYSPARMS^HLOSITE(.SYSTEM)
"RTN","HLOPOST",7,0)
 S VASITE=$$SITE^VASITE
"RTN","HLOPOST",8,0)
 S OLDSITE=$G(^HLCS(869.3,1,0))
"RTN","HLOPOST",9,0)
 S DATA(.01)=SYSTEM("DOMAIN")
"RTN","HLOPOST",10,0)
 I DATA(.01)="" D
"RTN","HLOPOST",11,0)
 .I $P(OLDSITE,"^",2) S DATA(.01)="HL7."_$P($G(^DIC(4.2,$P(OLDSITE,"^",2),0)),"^")
"RTN","HLOPOST",12,0)
 I DATA(.01)="" D
"RTN","HLOPOST",13,0)
 .N INST,DOMAIN
"RTN","HLOPOST",14,0)
 .S INST=$P(VASITE,"^")
"RTN","HLOPOST",15,0)
 .Q:'INST
"RTN","HLOPOST",16,0)
 .S DOMAIN=$P($G(^DIC(4,INST,6)),"^")
"RTN","HLOPOST",17,0)
 .I DOMAIN S DOMAIN=$P($G(^DIC(4.2,DOMAIN,0)),"^") I DOMAIN'="" S DATA(.01)="HL7."_DOMAIN
"RTN","HLOPOST",18,0)
 I DATA(.01)="" D BMES^XPDUTL("Post-Install failed, system missing INSTITUTION or DOMAIN file entry") Q
"RTN","HLOPOST",19,0)
 S DATA(.02)=SYSTEM("STATION")
"RTN","HLOPOST",20,0)
 I DATA(.02)="",$P(OLDSITE,"^",4) S DATA(.02)=$P($G(^DIC(4,$P(OLDSITE,"^",4),99)),"^")
"RTN","HLOPOST",21,0)
 I DATA(.02)="" S DATA(.02)=$P(VASITE,"^",3)
"RTN","HLOPOST",22,0)
 S DATA(.03)=$P(OLDSITE,"^",3)
"RTN","HLOPOST",23,0)
 S DATA(.04)=SYSTEM("MAXSTRING")
"RTN","HLOPOST",24,0)
 S DATA(.05)=SYSTEM("HL7 BUFFER")
"RTN","HLOPOST",25,0)
 S DATA(.06)=SYSTEM("USER BUFFER")
"RTN","HLOPOST",26,0)
 S DATA(.07)=SYSTEM("NORMAL PURGE")
"RTN","HLOPOST",27,0)
 S DATA(.08)=SYSTEM("ERROR PURGE")
"RTN","HLOPOST",28,0)
 I $D(^HLD(779.1,1,0)) D
"RTN","HLOPOST",29,0)
 .N ERROR
"RTN","HLOPOST",30,0)
 .I '$$UPD^HLOASUB1(779.1,1,.DATA,.ERROR) D BMES^XPDUTL("Post-Install failed -"_$G(ERROR))
"RTN","HLOPOST",31,0)
 E  D
"RTN","HLOPOST",32,0)
 .N ERROR
"RTN","HLOPOST",33,0)
 .I '$$ADD^HLOASUB1(779.1,,.DATA,.ERROR,1) D BMES^XPDUTL("Post-Install failed -"_$G(ERROR))
"RTN","HLOPOST",34,0)
 Q
"RTN","HLOPOST",35,0)
IDXLINKS ;
"RTN","HLOPOST",36,0)
 ;set the "AC" and "AD" indicies on the HL Logical Link file
"RTN","HLOPOST",37,0)
 N DIK
"RTN","HLOPOST",38,0)
 S DIK="^HLCS(870,"
"RTN","HLOPOST",39,0)
 S DIK(1)=".01^AC^AD^AD1^AD2"
"RTN","HLOPOST",40,0)
 D ENALL^DIK
"RTN","HLOPOST",41,0)
 Q
"RTN","HLOPOST",42,0)
 ;
"RTN","HLOPOST",43,0)
P134 ;
"RTN","HLOPOST",44,0)
 N DAILY,STARTUP,IEN,DATA
"RTN","HLOPOST",45,0)
 S DAILY=$O(^DIC(19,"B","HLO DAILY STARTUP",0))
"RTN","HLOPOST",46,0)
 I 'DAILY D BMES^XPDUTL("Failed to schedule the HLO DAILY STARTUP option!")
"RTN","HLOPOST",47,0)
 S STARTUP=$O(^DIC(19,"B","HLO SYSTEM STARTUP",0))
"RTN","HLOPOST",48,0)
 I 'STARTUP D BMES^XPDUTL("Failed to schedule the HLO SYSTEM STARTUP option!")
"RTN","HLOPOST",49,0)
 I STARTUP D
"RTN","HLOPOST",50,0)
 .S IEN=$O(^DIC(19.2,"B",STARTUP,0))
"RTN","HLOPOST",51,0)
 .S DATA(.01)=STARTUP
"RTN","HLOPOST",52,0)
 .S DATA(2)=""
"RTN","HLOPOST",53,0)
 .S DATA(6)=""
"RTN","HLOPOST",54,0)
 .S DATA(9)=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":"S",1:"")
"RTN","HLOPOST",55,0)
 .I IEN D
"RTN","HLOPOST",56,0)
 ..I '$$UPD^HLOASUB1(19.2,IEN,.DATA) D BMES^XPDUTL("Failed to schedule the HLO SYSTEM STARTUP option!")
"RTN","HLOPOST",57,0)
 .E  D
"RTN","HLOPOST",58,0)
 ..I '$$ADD^HLOASUB1(19.2,,.DATA) D BMES^XPDUTL("Failed to schedule the HLO SYSTEM STARTUP option!")
"RTN","HLOPOST",59,0)
 I DAILY D
"RTN","HLOPOST",60,0)
 .S IEN=$O(^DIC(19.2,"B",DAILY,0))
"RTN","HLOPOST",61,0)
 .S DATA(.01)=DAILY
"RTN","HLOPOST",62,0)
 .S DATA(2)=$$NOW^XLFDT
"RTN","HLOPOST",63,0)
 .S DATA(6)="1D"
"RTN","HLOPOST",64,0)
 .S DATA(9)=""
"RTN","HLOPOST",65,0)
 .I IEN D
"RTN","HLOPOST",66,0)
 ..I '$$UPD^HLOASUB1(19.2,IEN,.DATA) D BMES^XPDUTL("Failed to schedule the HLO DAILY STARTUP option!")
"RTN","HLOPOST",67,0)
 .E  D
"RTN","HLOPOST",68,0)
 ..I '$$ADD^HLOASUB1(19.2,,.DATA) D BMES^XPDUTL("Failed to schedule the HLO DAILY STARTUP option!")
"RTN","HLOPOST",69,0)
 Q
"RTN","HLOPRE")
0^^B871663^n/a
"RTN","HLOPRE",1,0)
HLOPRE ;ALB/CJM-Pre-install check for HLO patches ;03/08/2007
"RTN","HLOPRE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**134**;Oct 13, 1995;Build 30
"RTN","HLOPRE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPRE",4,0)
 ;
"RTN","HLOPRE",5,0)
CHECK ;
"RTN","HLOPRE",6,0)
 N WORK
"RTN","HLOPRE",7,0)
 L +^HLTMP("PROCESS MANAGER"):0
"RTN","HLOPRE",8,0)
 I '$T D ABORT Q
"RTN","HLOPRE",9,0)
 D CHKDEAD^HLOPROC1(.WORK)
"RTN","HLOPRE",10,0)
 I $O(^HLTMP("HL7 RUNNING PROCESSES",""))'="" D ABORT
"RTN","HLOPRE",11,0)
 L -^HLTMP("PROCESS MANAGER")
"RTN","HLOPRE",12,0)
 Q
"RTN","HLOPRE",13,0)
ABORT ;
"RTN","HLOPRE",14,0)
 S XPDABORT=1
"RTN","HLOPRE",15,0)
 D BMES^XPDUTL("HLO processes are still running and prevent this installation from completing")
"RTN","HLOPRE",16,0)
 Q
"RTN","HLOPROC")
0^28^B26319281^B24878795
"RTN","HLOPROC",1,0)
HLOPROC ;ALB/CJM- Generic HL7 Process - 10/4/94 1pm ;03/26/2007
"RTN","HLOPROC",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134**;Oct 13, 1995;Build 30
"RTN","HLOPROC",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPROC",4,0)
 ;
"RTN","HLOPROC",5,0)
PROCESS ;queued entry point
"RTN","HLOPROC",6,0)
 ;
"RTN","HLOPROC",7,0)
 ;insure just one process manager
"RTN","HLOPROC",8,0)
 I PROCNAME="PROCESS MANAGER" N RUNNING L +^HLTMP(PROCNAME):1 S RUNNING='$T D  Q:RUNNING
"RTN","HLOPROC",9,0)
 .I 'RUNNING D
"RTN","HLOPROC",10,0)
 ..D SETNM^%ZOSV($E("HLOmgr:"_$J,1,17))
"RTN","HLOPROC",11,0)
 .E  D
"RTN","HLOPROC",12,0)
 ..L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",13,0)
 ..K:$D(ZTSK) ^HLTMP("HL7 QUEUED PROCESSES",ZTSK)
"RTN","HLOPROC",14,0)
 ..S ^HLC("HL7 PROCESS COUNTS","RUNNING","PROCESS MANAGER")=1
"RTN","HLOPROC",15,0)
 ..S ^HLC("HL7 PROCESS COUNTS","QUEUED","PROCESS MANAGER")=0
"RTN","HLOPROC",16,0)
 ..L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",17,0)
 ..S ZTREQ="@"
"RTN","HLOPROC",18,0)
 ;
"RTN","HLOPROC",19,0)
 ;invoke the framework process
"RTN","HLOPROC",20,0)
 D HL7PROC(PROCNAME)
"RTN","HLOPROC",21,0)
 ;
"RTN","HLOPROC",22,0)
 I PROCNAME="PROCESS MANAGER" L -^HLTMP(PROCNAME)
"RTN","HLOPROC",23,0)
 S ZTREQ="@"
"RTN","HLOPROC",24,0)
 Q
"RTN","HLOPROC",25,0)
 ;
"RTN","HLOPROC",26,0)
HL7PROC(PROCNAME) ;
"RTN","HLOPROC",27,0)
 ;This is the generic HL7 process used by all processes started under the HL7 Process Manager
"RTN","HLOPROC",28,0)
 ;Input:
"RTN","HLOPROC",29,0)
 ;  PROCNAME - the name of a process found in the HL7 Process Registry
"RTN","HLOPROC",30,0)
 ;  OUTPUT - none
"RTN","HLOPROC",31,0)
 ;
"RTN","HLOPROC",32,0)
 N PROCESS,HL7STOP,WORK
"RTN","HLOPROC",33,0)
 ;
"RTN","HLOPROC",34,0)
 S ^HL7TMP("HL7 PROCESS NAME",$J)=PROCNAME
"RTN","HLOPROC",35,0)
 ;
"RTN","HLOPROC",36,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",37,0)
 I $D(ZTQUEUED) D
"RTN","HLOPROC",38,0)
 .K:$D(ZTSK) ^HLTMP("HL7 QUEUED PROCESSES",ZTSK)
"RTN","HLOPROC",39,0)
 .I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROCNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROCNAME)))
"RTN","HLOPROC",40,0)
 L +^HLTMP("HL7 RUNNING PROCESSES",$J):0
"RTN","HLOPROC",41,0)
 I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)))
"RTN","HLOPROC",42,0)
 S ^HLTMP("HL7 RUNNING PROCESSES",$J)=$H_"^"_$G(ZTSK)_"^"_PROCNAME
"RTN","HLOPROC",43,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",44,0)
 ;
"RTN","HLOPROC",45,0)
 ;
"RTN","HLOPROC",46,0)
 I $$GETPROC(PROCNAME,.PROCESS),'$$CHK4STOP(.PROCESS) D
"RTN","HLOPROC",47,0)
 .S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",48,0)
 .;
"RTN","HLOPROC",49,0)
 .;should this task be made persistent?
"RTN","HLOPROC",50,0)
 .I PROCESS("PERSISTENT"),$G(ZTQUEUED),$$PSET^%ZTLOAD(ZTQUEUED)
"RTN","HLOPROC",51,0)
 .;
"RTN","HLOPROC",52,0)
 .S HL7STOP=0
"RTN","HLOPROC",53,0)
 .F  D  Q:HL7STOP
"RTN","HLOPROC",54,0)
 ..N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOPROC"
"RTN","HLOPROC",55,0)
 ..N HL7TRIES,GOTWORK
"RTN","HLOPROC",56,0)
 ..F HL7TRIES=1:1 D  Q:GOTWORK  Q:$G(HL7STOP)
"RTN","HLOPROC",57,0)
 ...S GOTWORK=$$GETWORK(.PROCESS,.WORK)
"RTN","HLOPROC",58,0)
 ...Q:GOTWORK
"RTN","HLOPROC",59,0)
 ...;since there is no work, don't want another process starting
"RTN","HLOPROC",60,0)
 ...S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",61,0)
 ...H PROCESS("HANG")
"RTN","HLOPROC",62,0)
 ...S HL7STOP=$$CHK4STOP(.PROCESS,HL7TRIES)
"RTN","HLOPROC",63,0)
 ..Q:$G(HL7STOP)
"RTN","HLOPROC",64,0)
 ..I GOTWORK D DOWORK(.PROCESS,.WORK) S HL7TRIES=0
"RTN","HLOPROC",65,0)
 ..S:'$G(HL7STOP) HL7STOP=$$CHK4STOP(.PROCESS,.HL7TRIES)
"RTN","HLOPROC",66,0)
 ;
"RTN","HLOPROC",67,0)
 S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",68,0)
 ;
"RTN","HLOPROC",69,0)
END ;
"RTN","HLOPROC",70,0)
 S HL7STOP=1
"RTN","HLOPROC",71,0)
 K ^HL7TMP("HL7 PROCESS NAME",$J)
"RTN","HLOPROC",72,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",73,0)
 K ^HLTMP("HL7 RUNNING PROCESSES",$J)
"RTN","HLOPROC",74,0)
 I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)),1)
"RTN","HLOPROC",75,0)
 L -^HLTMP("HL7 RUNNING PROCESSES",$J)
"RTN","HLOPROC",76,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",77,0)
 K ^TMP("HL7 ERRORS",$J)
"RTN","HLOPROC",78,0)
 ;
"RTN","HLOPROC",79,0)
 Q
"RTN","HLOPROC",80,0)
 ;
"RTN","HLOPROC",81,0)
ERROR ;error trap
"RTN","HLOPROC",82,0)
 ;
"RTN","HLOPROC",83,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOPROC",84,0)
 ;
"RTN","HLOPROC",85,0)
 ;while debugging always quit on error
"RTN","HLOPROC",86,0)
 I $G(^HLTMP("LOG ALL ERRORS"))!($ECODE["TOOMANYFILES")!($ECODE["EDITED") D  Q:$QUIT "" Q
"RTN","HLOPROC",87,0)
 .D ^%ZTER
"RTN","HLOPROC",88,0)
 .S:'$D(PROCNAME) PROCNAME=$G(^HL7TMP("HL7 PROCESS NAME",$J))
"RTN","HLOPROC",89,0)
 .D END
"RTN","HLOPROC",90,0)
 ;
"RTN","HLOPROC",91,0)
 ;a lot of errors of the same type may indicate an endless loop, so quit
"RTN","HLOPROC",92,0)
 ;to be on the safe side.  Decrement the process count.
"RTN","HLOPROC",93,0)
 N HOUR
"RTN","HLOPROC",94,0)
 S HOUR=$E($$NOW^XLFDT,1,10)
"RTN","HLOPROC",95,0)
 I $G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))>30 D  Q:$QUIT "" Q
"RTN","HLOPROC",96,0)
 .;D ^%ZTER
"RTN","HLOPROC",97,0)
 .S:'$D(PROCNAME) PROCNAME=$G(^HL7TMP("HL7 PROCESS NAME",$J))
"RTN","HLOPROC",98,0)
 .D END
"RTN","HLOPROC",99,0)
 ;
"RTN","HLOPROC",100,0)
 ;can continue processing after logging the error
"RTN","HLOPROC",101,0)
 S ^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2))=$G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))+1
"RTN","HLOPROC",102,0)
 D ^%ZTER
"RTN","HLOPROC",103,0)
 D UNWIND^%ZTER
"RTN","HLOPROC",104,0)
 Q
"RTN","HLOPROC",105,0)
 ;
"RTN","HLOPROC",106,0)
GETPROC(PROCNAME,PROCESS) ;
"RTN","HLOPROC",107,0)
 ;using PROCNAME to find the entry in the HL7 Process Registry, returns the entry as a subscripted array in .PROCESS
"RTN","HLOPROC",108,0)
 ;
"RTN","HLOPROC",109,0)
 ;Output: Function returns 0 on failure, 1 on success
"RTN","HLOPROC",110,0)
 ;
"RTN","HLOPROC",111,0)
 N IEN,NODE
"RTN","HLOPROC",112,0)
 S IEN=$O(^HLD(779.3,"B",PROCNAME,0))
"RTN","HLOPROC",113,0)
 Q:'IEN 0
"RTN","HLOPROC",114,0)
 S PROCESS("NAME")=PROCNAME
"RTN","HLOPROC",115,0)
 S PROCESS("IEN")=IEN
"RTN","HLOPROC",116,0)
 S NODE=$G(^HLD(779.3,IEN,0))
"RTN","HLOPROC",117,0)
 S PROCESS("MINIMUM")=+$P(NODE,"^",3)
"RTN","HLOPROC",118,0)
 S PROCESS("MAXIMUM")=+$P(NODE,"^",4)
"RTN","HLOPROC",119,0)
 S PROCESS("HANG")=+$P(NODE,"^",7)
"RTN","HLOPROC",120,0)
 I 'PROCESS("HANG") S PROCESS("HANG")=1
"RTN","HLOPROC",121,0)
 S PROCESS("GET WORK")=$P(NODE,"^",8,9)
"RTN","HLOPROC",122,0)
 S PROCESS("DO WORK")=$P(NODE,"^",10,11)
"RTN","HLOPROC",123,0)
 S PROCESS("MAX TRIES")=$P(NODE,"^",12)
"RTN","HLOPROC",124,0)
 I 'PROCESS("MAX TRIES") S PROCESS("MAX TRIES")=999
"RTN","HLOPROC",125,0)
 S PROCESS("PERSISTENT")=+$P(NODE,"^",13)
"RTN","HLOPROC",126,0)
 S PROCESS("LINK")=$P(NODE,"^",14)
"RTN","HLOPROC",127,0)
 Q 1
"RTN","HLOPROC",128,0)
 ;
"RTN","HLOPROC",129,0)
GETWORK(PROCESS,WORK) ;
"RTN","HLOPROC",130,0)
 N RETURN,XECUTE
"RTN","HLOPROC",131,0)
 I PROCESS("LINK")]"" S WORK("LINK")=PROCESS("LINK")
"RTN","HLOPROC",132,0)
 S XECUTE="S RETURN=$$"_PROCESS("GET WORK")_"(.WORK)"
"RTN","HLOPROC",133,0)
 D
"RTN","HLOPROC",134,0)
 .N PROCESS
"RTN","HLOPROC",135,0)
 .X XECUTE
"RTN","HLOPROC",136,0)
 Q RETURN
"RTN","HLOPROC",137,0)
 ;
"RTN","HLOPROC",138,0)
DOWORK(PROCESS,WORK) ;
"RTN","HLOPROC",139,0)
 N XECUTE
"RTN","HLOPROC",140,0)
 M PARMS=WORK
"RTN","HLOPROC",141,0)
 S XECUTE="D "_PROCESS("DO WORK")_"(.WORK)"
"RTN","HLOPROC",142,0)
 D
"RTN","HLOPROC",143,0)
 .N PROCESS,HL7TRIES,PARMS,PROCNAME
"RTN","HLOPROC",144,0)
 .X XECUTE
"RTN","HLOPROC",145,0)
 M WORK=PARMS
"RTN","HLOPROC",146,0)
 Q
"RTN","HLOPROC",147,0)
 ;
"RTN","HLOPROC",148,0)
CHK4STOP(PROCESS,HL7TRIES) ;
"RTN","HLOPROC",149,0)
 ;Determines if the process should stop, returns 1 if yes, 0 if no
"RTN","HLOPROC",150,0)
 ;
"RTN","HLOPROC",151,0)
 Q:$$CHKSTOP 1
"RTN","HLOPROC",152,0)
 Q:'$P($G(^HLD(779.3,PROCESS("IEN"),0)),"^",2) 1
"RTN","HLOPROC",153,0)
 I $G(HL7TRIES)>(PROCESS("MAX TRIES")-1),PROCESS("MINIMUM")<$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCESS("NAME"))) Q 1
"RTN","HLOPROC",154,0)
 Q:$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCESS("NAME")))>PROCESS("MAXIMUM") 1
"RTN","HLOPROC",155,0)
 Q 0
"RTN","HLOPROC",156,0)
 ;
"RTN","HLOPROC",157,0)
CHKSTOP() ;has HL7 been requested to stop?
"RTN","HLOPROC",158,0)
 Q '$P($G(^HLD(779.1,1,0)),"^",9)
"RTN","HLOPRS")
0^1^B28621487^B29583267
"RTN","HLOPRS",1,0)
HLOPRS ;IRMFO-ALB/CJM -RTNs for parsing messages;03/24/2004  14:43 ;12/11/2006
"RTN","HLOPRS",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**118,126,133,132,134**;Oct 13, 1995;Build 30
"RTN","HLOPRS",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPRS",4,0)
 ;
"RTN","HLOPRS",5,0)
STARTMSG(MSG,IEN,HDR) ;
"RTN","HLOPRS",6,0)
 ;Description:  This function begins the parsing of the message, parsing
"RTN","HLOPRS",7,0)
 ;the header and returning the individual values in the array HDR().
"RTN","HLOPRS",8,0)
 ;Input: 
"RTN","HLOPRS",9,0)
 ;  IEN - The internal entry number of the message in file 778.
"RTN","HLOPRS",10,0)
 ;Output:
"RTN","HLOPRS",11,0)
 ;  Function returns 1 on success, 0 on failure.  Failure would indicate that the message was not found.
"RTN","HLOPRS",12,0)
 ;  MSG - (pass by reference, required) This array is used by the HL7 package to track the progress of parsing the message.  The application MUST NOT touch it!
"RTN","HLOPRS",13,0)
 ;  HDR (pass by reference, optional)   This array contains the results of parsing the message header.
"RTN","HLOPRS",14,0)
 K MSG,HDR
"RTN","HLOPRS",15,0)
 Q:'$G(IEN) 0
"RTN","HLOPRS",16,0)
 Q:'$$GETMSG^HLOMSG(IEN,.MSG) 0
"RTN","HLOPRS",17,0)
 M HDR=MSG("HDR")
"RTN","HLOPRS",18,0)
 Q:'$$PARSEHDR(.HDR) 0
"RTN","HLOPRS",19,0)
 M MSG("HDR")=HDR
"RTN","HLOPRS",20,0)
 Q 1
"RTN","HLOPRS",21,0)
 ;
"RTN","HLOPRS",22,0)
NEXTSEG(MSG,SEG) ;
"RTN","HLOPRS",23,0)
 ;Description:  Advances parsing to the next segment and returns the parsed values from that segment.
"RTN","HLOPRS",24,0)
 ;Input:
"RTN","HLOPRS",25,0)
 ;  MSG - (pass by reference, required) This array is used by the HL7 package to track the current position in the message.  The application MUST NOT touch it!
"RTN","HLOPRS",26,0)
 ;Output:
"RTN","HLOPRS",27,0)
 ;  Function  returns 1 on success, 0 if there are no more segments in this message.  For batch messages, a return value of 0 does not preclude the possibility that there are additional individual messages within the batch.
"RTN","HLOPRS",28,0)
 ;  MSG - (pass by reference, required)
"RTN","HLOPRS",29,0)
 ;  SEG - (pass by reference, required)  The segment is returned in this array.
"RTN","HLOPRS",30,0)
 ;
"RTN","HLOPRS",31,0)
 N TEMP,CODES
"RTN","HLOPRS",32,0)
 K SEG
"RTN","HLOPRS",33,0)
 I '$$HLNEXT^HLOMSG(.MSG,.TEMP) Q 0
"RTN","HLOPRS",34,0)
 S CODES=MSG("HDR","ENCODING CHARACTERS")
"RTN","HLOPRS",35,0)
 Q $$PARSE^HLOPRS1(MSG("HDR","FIELD SEPARATOR"),$E(CODES,2),$E(CODES,1),$E(CODES,4),$E(CODES,3),.TEMP,.SEG)
"RTN","HLOPRS",36,0)
 ;
"RTN","HLOPRS",37,0)
NEXTMSG(MSG,MSH) ;
"RTN","HLOPRS",38,0)
 ;Description:  Advances to the next message within the batch, with the MSH segment returned.
"RTN","HLOPRS",39,0)
 ;Input:
"RTN","HLOPRS",40,0)
 ; MSG (pass by reference, required) This array is used by the HL7 package to track the current position in the message.  The application MUST NOT touch it!
"RTN","HLOPRS",41,0)
 ;OUTPUT:
"RTN","HLOPRS",42,0)
 ;  Function returns 1 on success, 0 if there are no more messages
"RTN","HLOPRS",43,0)
 ;  MSG - (pass by reference)
"RTN","HLOPRS",44,0)
 ;  MSH - (pass by reference, required) Returns the parsed message header
"RTN","HLOPRS",45,0)
 ;
"RTN","HLOPRS",46,0)
 K MSH
"RTN","HLOPRS",47,0)
 N NODE
"RTN","HLOPRS",48,0)
 Q:'$$NEXTMSG^HLOMSG(.MSG,.MSH) 0
"RTN","HLOPRS",49,0)
 Q:'$$PARSEHDR(.MSH) 0
"RTN","HLOPRS",50,0)
 S MSG("BATCH","CURRENT MESSAGE","EVENT")=MSH("EVENT")
"RTN","HLOPRS",51,0)
 S MSG("BATCH","CURRENT MESSAGE","MESSAGE CONTROL ID")=MSH("MESSAGE CONTROL ID")
"RTN","HLOPRS",52,0)
 S NODE=$G(^HLB(MSG("IEN"),3,MSG("BATCH","CURRENT MESSAGE"),0))
"RTN","HLOPRS",53,0)
 S MSG("BATCH","CURRENT MESSAGE","ACK TO")=$P(NODE,"^",3)
"RTN","HLOPRS",54,0)
 S MSG("BATCH","CURRENT MESSAGE","ACK BY")=$P(NODE,"^",4)
"RTN","HLOPRS",55,0)
 ;
"RTN","HLOPRS",56,0)
 I MSG("BATCH","CURRENT MESSAGE","ACK TO")]"" S MSG("BATCH","CURRENT MESSAGE","ACK TO IEN")=$$ACKTOIEN^HLOMSG1(MSG("MESSAGE CONTROL ID"),MSG("BATCH","CURRENT MESSAGE","ACK TO"))
"RTN","HLOPRS",57,0)
 I MSG("BATCH","CURRENT MESSAGE","ACK BY")]"" S MSG("BATCH","CURRENT MESSAGE","ACK BY IEN")=$$ACKBYIEN^HLOMSG1(MSG("MESSAGE CONTROL ID"),MSG("BATCH","CURRENT MESSAGE","ACK BY"))
"RTN","HLOPRS",58,0)
 ;
"RTN","HLOPRS",59,0)
 Q 1
"RTN","HLOPRS",60,0)
 ;
"RTN","HLOPRS",61,0)
PARSEHDR(HDR) ;
"RTN","HLOPRS",62,0)
 ;Parses the segment (HDR, pass by reference) into the HDR() array using meaningful subscripts.
"RTN","HLOPRS",63,0)
 ;Input:
"RTN","HLOPRS",64,0)
 ;  HDR (pass by reference, required) contains the segment in the format HDR(1),HDR(2), etc..
"RTN","HLOPRS",65,0)
 ;Output:
"RTN","HLOPRS",66,0)
 ;  HDR (pass by reference, required) This array will contain all the individual values.  Also will contain HDR(1) with components 1-6 and HDR(2) with components 1-end
"RTN","HLOPRS",67,0)
 ;  Function - returns 1 if the segment is indeed an MSH or BHS segment, 0 otherwise
"RTN","HLOPRS",68,0)
 ;
"RTN","HLOPRS",69,0)
 N VALUE,FS,CS,REP,SUBCOMP,ESCAPE
"RTN","HLOPRS",70,0)
 S VALUE=$E(HDR(1),1,3)
"RTN","HLOPRS",71,0)
 I VALUE'="MSH",VALUE'="BHS" Q 0
"RTN","HLOPRS",72,0)
 S HDR("SEGMENT TYPE")=VALUE
"RTN","HLOPRS",73,0)
 S FS=$E(HDR(1),4)
"RTN","HLOPRS",74,0)
 Q:FS="" 0
"RTN","HLOPRS",75,0)
 S HDR("ENCODING CHARACTERS")=$P(HDR(1),FS,2)
"RTN","HLOPRS",76,0)
 S CS=$E(HDR("ENCODING CHARACTERS"),1)
"RTN","HLOPRS",77,0)
 S REP=$E(HDR("ENCODING CHARACTERS"),2)
"RTN","HLOPRS",78,0)
 S ESCAPE=$E(HDR("ENCODING CHARACTERS"),3)
"RTN","HLOPRS",79,0)
 S SUBCOMP=$E(HDR("ENCODING CHARACTERS"),4)
"RTN","HLOPRS",80,0)
 Q:REP="" 0
"RTN","HLOPRS",81,0)
 S HDR("FIELD SEPARATOR")=FS
"RTN","HLOPRS",82,0)
 S HDR("COMPONENT SEPARATOR")=CS
"RTN","HLOPRS",83,0)
 S HDR("REPETITION SEPARATOR")=REP
"RTN","HLOPRS",84,0)
 S HDR("ESCAPE CHARACTER")=ESCAPE
"RTN","HLOPRS",85,0)
 S HDR("SUBCOMPONENT SEPARATOR")=SUBCOMP
"RTN","HLOPRS",86,0)
 S HDR("SENDING APPLICATION")=$$DESCAPE($P($P(HDR(1),FS,3),CS))
"RTN","HLOPRS",87,0)
 S VALUE=$P(HDR(1),FS,4)
"RTN","HLOPRS",88,0)
 S HDR("SENDING FACILITY",1)=$$DESCAPE($P(VALUE,CS))
"RTN","HLOPRS",89,0)
 S HDR("SENDING FACILITY",2)=$$DESCAPE($P(VALUE,CS,2))
"RTN","HLOPRS",90,0)
 S HDR("SENDING FACILITY",3)=$$DESCAPE($P(VALUE,CS,3))
"RTN","HLOPRS",91,0)
 S HDR("RECEIVING APPLICATION")=$$DESCAPE($P($P(HDR(1),FS,5),CS))
"RTN","HLOPRS",92,0)
 S VALUE=$P(HDR(1),FS,6)
"RTN","HLOPRS",93,0)
 S HDR("RECEIVING FACILITY",1)=$$DESCAPE($P(VALUE,CS))
"RTN","HLOPRS",94,0)
 S HDR("RECEIVING FACILITY",2)=$$DESCAPE($P(VALUE,CS,2))
"RTN","HLOPRS",95,0)
 S HDR("RECEIVING FACILITY",3)=$$DESCAPE($P(VALUE,CS,3))
"RTN","HLOPRS",96,0)
 S HDR("DT/TM OF MESSAGE")=$$FMDATE^HLFNC($$DESCAPE($P($P(HDR(2),FS,2),CS)))
"RTN","HLOPRS",97,0)
 S HDR("SECURITY")=$$DESCAPE($P($P(HDR(2),FS,3),CS))
"RTN","HLOPRS",98,0)
 ;
"RTN","HLOPRS",99,0)
 I HDR("SEGMENT TYPE")="MSH" D
"RTN","HLOPRS",100,0)
 .S VALUE=$P(HDR(2),FS,4)
"RTN","HLOPRS",101,0)
 .S HDR("MESSAGE TYPE")=$P(VALUE,CS)
"RTN","HLOPRS",102,0)
 .S HDR("EVENT")=$P(VALUE,CS,2)
"RTN","HLOPRS",103,0)
 .S HDR("MESSAGE STRUCTURE")=$$DESCAPE($P(VALUE,CS,3))
"RTN","HLOPRS",104,0)
 .S HDR("MESSAGE CONTROL ID")=$$DESCAPE($P($P(HDR(2),FS,5),CS))
"RTN","HLOPRS",105,0)
 .S VALUE=$P(HDR(2),FS,6)
"RTN","HLOPRS",106,0)
 .S HDR("PROCESSING ID")=$P(VALUE,CS)
"RTN","HLOPRS",107,0)
 .S HDR("PROCESSING MODE")=$$DESCAPE($P(VALUE,CS,2))
"RTN","HLOPRS",108,0)
 .S HDR("VERSION")=$$DESCAPE($P($P(HDR(2),FS,7),CS))
"RTN","HLOPRS",109,0)
 .S HDR("CONTINUATION POINTER")=$$DESCAPE($P($P(HDR(2),FS,9),CS))
"RTN","HLOPRS",110,0)
 .S HDR("ACCEPT ACK TYPE")=$P($P(HDR(2),FS,10),CS)
"RTN","HLOPRS",111,0)
 .S HDR("APP ACK TYPE")=$P($P(HDR(2),FS,11),CS)
"RTN","HLOPRS",112,0)
 .S HDR("COUNTRY")=$$DESCAPE($P($P(HDR(2),FS,12),CS))
"RTN","HLOPRS",113,0)
 ;
"RTN","HLOPRS",114,0)
 I HDR("SEGMENT TYPE")="BHS" D
"RTN","HLOPRS",115,0)
 .S VALUE=$P(HDR(2),FS,4)
"RTN","HLOPRS",116,0)
 .S HDR("BATCH NAME/ID/TYPE")=$$DESCAPE(VALUE)
"RTN","HLOPRS",117,0)
 .S HDR("PROCESSING ID")=$E($P(VALUE,"PROCESSING ID=",2),1)
"RTN","HLOPRS",118,0)
 .S HDR("ACCEPT ACK TYPE")=$E($P(VALUE,"ACCEPT ACK TYPE=",2),1,2)
"RTN","HLOPRS",119,0)
 .S HDR("APP ACK TYPE")=$E($P(VALUE,"APP ACK TYPE=",2),1,2)
"RTN","HLOPRS",120,0)
 .S HDR("BATCH COMMENT")=$$DESCAPE($P(HDR(2),FS,5))
"RTN","HLOPRS",121,0)
 .S HDR("BATCH CONTROL ID")=$$DESCAPE($P($P(HDR(2),FS,6),CS))
"RTN","HLOPRS",122,0)
 .S HDR("REFERENCE BATCH CONTROL ID")=$$DESCAPE($P($P(HDR(2),FS,7),CS))
"RTN","HLOPRS",123,0)
 .;
"RTN","HLOPRS",124,0)
 Q 1
"RTN","HLOPRS",125,0)
 ;
"RTN","HLOPRS",126,0)
DESCAPE(VALUE) ;
"RTN","HLOPRS",127,0)
 Q $$DESCAPE^HLOPRS1(VALUE,FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",128,0)
 ;
"RTN","HLOPRS",129,0)
GET(SEG,FIELD,COMP,SUBCOMP,REP) ;
"RTN","HLOPRS",130,0)
 ;This function gets a specified value from a segment that was parsed by
"RTN","HLOPRS",131,0)
 ;$$NEXTSEG. The FIELD,COMP,SUBCOMP,REP parameters are optional - if not
"RTN","HLOPRS",132,0)
 ;specified, they default to 1.
"RTN","HLOPRS",133,0)
 ;  Example:
"RTN","HLOPRS",134,0)
 ;    $$GET^HLOPRS(.SEG,1) will return the value of the first field, first
"RTN","HLOPRS",135,0)
 ;  component, first subcomponent, in the first occurrence of field #1.  
"RTN","HLOPRS",136,0)
 ;Input:
"RTN","HLOPRS",137,0)
 ;SEG - (required, pass by reference) - this is the array where the parsed segment was placed by $$NEXTSEG
"RTN","HLOPRS",138,0)
 ;FIELD - the sequence # of the field (optional, defaults to 1)
"RTN","HLOPRS",139,0)
 ;COMP - the # of the component (optional, defaults to 1)
"RTN","HLOPRS",140,0)
 ;SUBCOMP - the # of the subcomponent (optional, defaults to 1)
"RTN","HLOPRS",141,0)
 ;REP - the occurrence# (optional, defaults to 1)  For a non-repeating field, the occurrence # need not be provided, because it would be 1.
"RTN","HLOPRS",142,0)
 ;Output:
"RTN","HLOPRS",143,0)
 ;  Function returns the requested value on success, "" if not valued.
"RTN","HLOPRS",144,0)
 ;
"RTN","HLOPRS",145,0)
 ;allow the segment type to be obtained via field #0 (shorthand)
"RTN","HLOPRS",146,0)
 I $D(FIELD),$G(FIELD)=0 Q $G(SEG("SEGMENT TYPE"))
"RTN","HLOPRS",147,0)
 S:'$G(FIELD) FIELD=1
"RTN","HLOPRS",148,0)
 ;
"RTN","HLOPRS",149,0)
 ;for MSH or BHS, SEQ#1 is the  field separator
"RTN","HLOPRS",150,0)
 I FIELD=1,$G(SEG("SEGMENT TYPE"))="MSH"!($G(SEG("SEGMENT TYPE"))="BHS"),$G(REP)<2,$G(COMP)<2,$G(SUBCOMP)<2 Q SEG("FIELD SEPARATOR")
"RTN","HLOPRS",151,0)
 I FIELD=1,$G(SEG("SEGMENT TYPE"))="MSH"!($G(SEG("SEGMENT TYPE"))="BHS") Q ""
"RTN","HLOPRS",152,0)
 ;
"RTN","HLOPRS",153,0)
 S:'$G(COMP) COMP=1
"RTN","HLOPRS",154,0)
 S:'$G(SUBCOMP) SUBCOMP=1
"RTN","HLOPRS",155,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS",156,0)
 Q $G(SEG(FIELD,REP,COMP,SUBCOMP))
"RTN","HLOPRS1")
0^4^B19883932^B19727557
"RTN","HLOPRS1",1,0)
HLOPRS1 ;IRMFO-ALB/CJM -RTNs for parsing messages (continued);03/24/2004  14:43 ;01/19/2007
"RTN","HLOPRS1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**118,131,133,134**;Oct 13, 1995;Build 30
"RTN","HLOPRS1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPRS1",4,0)
 ;
"RTN","HLOPRS1",5,0)
PARSE(FIELD,REP,COMP,SUBCOMP,ESCAPE,SEG,TO) ;
"RTN","HLOPRS1",6,0)
 ;Parses the segment stored in SEG(1),SEG(2),... into TO()
"RTN","HLOPRS1",7,0)
 ;Input:
"RTN","HLOPRS1",8,0)
 ;  FIELD - field separator
"RTN","HLOPRS1",9,0)
 ;  REP - field repetition separator
"RTN","HLOPRS1",10,0)
 ;  COMP - component separator
"RTN","HLOPRS1",11,0)
 ;  SUBCOMP - subcomponent separator
"RTN","HLOPRS1",12,0)
 ;  ESCAPE - escape character
"RTN","HLOPRS1",13,0)
 ;  SEG - (pass by reference) the array holding the unparsed segment.
"RTN","HLOPRS1",14,0)
 ;Output:
"RTN","HLOPRS1",15,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOPRS1",16,0)
 ;  TO - (pass by reference) - the parsed values
"RTN","HLOPRS1",17,0)
 ;  SEG- This input variable is deleted during the processing.  If it is needs to be retained, pass in a copy!
"RTN","HLOPRS1",18,0)
 ;
"RTN","HLOPRS1",19,0)
 N VALUE,CHAR,COUNTS
"RTN","HLOPRS1",20,0)
 K TO
"RTN","HLOPRS1",21,0)
 Q:$L($G(FIELD))'=1 0
"RTN","HLOPRS1",22,0)
 Q:$L($G(REP))'=1 0
"RTN","HLOPRS1",23,0)
 Q:$L($G(COMP))'=1 0
"RTN","HLOPRS1",24,0)
 Q:'$D(SUBCOMP) 0
"RTN","HLOPRS1",25,0)
 Q:'$D(SEG) 0
"RTN","HLOPRS1",26,0)
 S COUNTS("FIELD")=0
"RTN","HLOPRS1",27,0)
 S COUNTS("REP")=1
"RTN","HLOPRS1",28,0)
 S COUNTS("COMP")=1
"RTN","HLOPRS1",29,0)
 S COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",30,0)
 S VALUE=""
"RTN","HLOPRS1",31,0)
 S SEG("LINE")=$O(SEG(0)),SEG("CHAR")=0
"RTN","HLOPRS1",32,0)
 F  S CHAR=$$NEXTCHAR(.SEG) D  Q:'$L(CHAR)
"RTN","HLOPRS1",33,0)
 .I '$L(CHAR) D  Q
"RTN","HLOPRS1",34,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=VALUE
"RTN","HLOPRS1",35,0)
 .E  I CHAR=FIELD D  Q
"RTN","HLOPRS1",36,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",37,0)
 ..S COUNTS("FIELD")=COUNTS("FIELD")+1,COUNTS("REP")=1,COUNTS("COMP")=1,COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",38,0)
 .E  I CHAR=REP D  Q
"RTN","HLOPRS1",39,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",40,0)
 ..S COUNTS("REP")=COUNTS("REP")+1,COUNTS("COMP")=1,COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",41,0)
 .E  I CHAR=COMP D  Q
"RTN","HLOPRS1",42,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",43,0)
 ..S COUNTS("COMP")=COUNTS("COMP")+1,COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",44,0)
 .E  I CHAR=SUBCOMP D  Q
"RTN","HLOPRS1",45,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",46,0)
 ..S COUNTS("SUBCOMP")=COUNTS("SUBCOMP")+1
"RTN","HLOPRS1",47,0)
 .E  S VALUE=VALUE_CHAR
"RTN","HLOPRS1",48,0)
 S TO("SEGMENT TYPE")=$G(TO(0,1,1,1)),TO(0)=TO("SEGMENT TYPE")
"RTN","HLOPRS1",49,0)
 I (TO("SEGMENT TYPE")="BHS")!(TO("SEGMENT TYPE")="MSH") S TO("FIELD SEPARATOR")=FIELD
"RTN","HLOPRS1",50,0)
 Q 1
"RTN","HLOPRS1",51,0)
 ;
"RTN","HLOPRS1",52,0)
NEXTCHAR(SEG) ;
"RTN","HLOPRS1",53,0)
 ;returns the next character in the segment array
"RTN","HLOPRS1",54,0)
 ;
"RTN","HLOPRS1",55,0)
 Q:'SEG("LINE") ""
"RTN","HLOPRS1",56,0)
 N RET
"RTN","HLOPRS1",57,0)
 S SEG("CHAR")=SEG("CHAR")+1
"RTN","HLOPRS1",58,0)
 S RET=$E(SEG(SEG("LINE")),SEG("CHAR"))
"RTN","HLOPRS1",59,0)
 Q:RET]"" RET
"RTN","HLOPRS1",60,0)
 S SEG("LINE")=$O(SEG(SEG("LINE")))
"RTN","HLOPRS1",61,0)
 I SEG("LINE") S SEG("CHAR")=1 Q $E(SEG(SEG("LINE")))
"RTN","HLOPRS1",62,0)
 Q ""
"RTN","HLOPRS1",63,0)
 ;
"RTN","HLOPRS1",64,0)
DESCAPE(VALUE,FIELD,COMP,SUBCOMP,REP,ESCAPE) ;
"RTN","HLOPRS1",65,0)
 ;Replaces the escape sequences with the corresponding encoding character and returns the result as the function value
"RTN","HLOPRS1",66,0)
 ;
"RTN","HLOPRS1",67,0)
 Q:ESCAPE="" VALUE
"RTN","HLOPRS1",68,0)
 N NEWSTRNG,SUBSTRNG,SET,LEN,I,SUBLEN,CHAR
"RTN","HLOPRS1",69,0)
 S (NEWSTRNG,SUBSTRNG,SUBLEN)=""
"RTN","HLOPRS1",70,0)
 S SET="FSTRE"
"RTN","HLOPRS1",71,0)
 S LEN=$L(VALUE)
"RTN","HLOPRS1",72,0)
 F I=1:1:LEN S SUBSTRNG=SUBSTRNG_$E(VALUE,I),SUBLEN=SUBLEN+1 D:SUBLEN=3
"RTN","HLOPRS1",73,0)
 .S CHAR=$E(SUBSTRNG,2)
"RTN","HLOPRS1",74,0)
 .I $E(SUBSTRNG,1)=ESCAPE,$E(SUBSTRNG,3)=ESCAPE,SET[CHAR D
"RTN","HLOPRS1",75,0)
 ..I CHAR="F" S NEWSTRNG=NEWSTRNG_FIELD,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",76,0)
 ..I CHAR="S" S NEWSTRNG=NEWSTRNG_COMP,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",77,0)
 ..I CHAR="T" S NEWSTRNG=NEWSTRNG_SUBCOMP,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",78,0)
 ..I CHAR="R" S NEWSTRNG=NEWSTRNG_REP,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",79,0)
 ..I CHAR="E" S NEWSTRNG=NEWSTRNG_ESCAPE,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",80,0)
 .E  S NEWSTRNG=NEWSTRNG_$E(SUBSTRNG),SUBSTRNG=$E(SUBSTRNG,2,3),SUBLEN=2
"RTN","HLOPRS1",81,0)
 Q NEWSTRNG_SUBSTRNG
"RTN","HLOPRS1",82,0)
 ;
"RTN","HLOPRS1",83,0)
GETCODE(SEG,VALUE,FIELD,COMP,REP) ;
"RTN","HLOPRS1",84,0)
 ;Implements GETCNE and GETCWE
"RTN","HLOPRS1",85,0)
 ;
"RTN","HLOPRS1",86,0)
 N SUB,VAR
"RTN","HLOPRS1",87,0)
 Q:'$G(FIELD)
"RTN","HLOPRS1",88,0)
 I '$G(COMP) D
"RTN","HLOPRS1",89,0)
 .S VAR="COMP",SUB=1
"RTN","HLOPRS1",90,0)
 E  D
"RTN","HLOPRS1",91,0)
 .S VAR="SUB"
"RTN","HLOPRS1",92,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS1",93,0)
 S @VAR=1,VALUE("ID")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",94,0)
 S @VAR=2,VALUE("TEXT")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",95,0)
 S @VAR=3,VALUE("SYSTEM")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",96,0)
 S @VAR=4,VALUE("ALTERNATE ID")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",97,0)
 S @VAR=5,VALUE("ALTERNATE TEXT")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",98,0)
 S @VAR=6,VALUE("ALTERNATE SYSTEM")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,RE)
"RTN","HLOPRS1",99,0)
 S @VAR=7,VALUE("SYSTEM VERSION")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",100,0)
 S @VAR=8,VALUE("ALTERNATE SYSTEM VERSION")=$$GET^HLOPRS(.SEG,FIELD,COM)
"RTN","HLOPRS1",101,0)
 S @VAR=9,VALUE("ORIGINAL TEXT")=$$GET^HLOPRS(.SEG,FIELD,COMP,SUB,REP)
"RTN","HLOPRS1",102,0)
 Q
"RTN","HLOPURGE")
0^24^B33852841^B28987748
"RTN","HLOPURGE",1,0)
HLOPURGE ;IRMFO-ALB/CJM - Purging Old Messages;03/24/2004  14:43 ;04/18/2007
"RTN","HLOPURGE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134**;Oct 13, 1995;Build 30
"RTN","HLOPURGE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPURGE",4,0)
 ;
"RTN","HLOPURGE",5,0)
GETWORK(WORK) ;
"RTN","HLOPURGE",6,0)
 ;
"RTN","HLOPURGE",7,0)
 N TYPE,OK,ARRAY,LAST
"RTN","HLOPURGE",8,0)
 S OK=0
"RTN","HLOPURGE",9,0)
 S LAST=$G(WORK)
"RTN","HLOPURGE",10,0)
 F TYPE="IN","OUT","OLD778","OLD777" S ARRAY(TYPE)=""
"RTN","HLOPURGE",11,0)
 I $G(WORK)]"" L -HLPURGE(WORK)
"RTN","HLOPURGE",12,0)
 F  S WORK=$O(ARRAY($G(WORK))) Q:WORK=LAST  L +HLPURGE(WORK):0 S OK=$T Q:OK
"RTN","HLOPURGE",13,0)
 Q OK
"RTN","HLOPURGE",14,0)
 ;
"RTN","HLOPURGE",15,0)
DOWORK(WORK) ;
"RTN","HLOPURGE",16,0)
 I WORK="OLD778" D OLD778
"RTN","HLOPURGE",17,0)
 I WORK="OLD777" D OLD777
"RTN","HLOPURGE",18,0)
 I (WORK="IN")!(WORK="OUT") D
"RTN","HLOPURGE",19,0)
 .N TIME,NOW
"RTN","HLOPURGE",20,0)
 .S NOW=$$NOW^XLFDT
"RTN","HLOPURGE",21,0)
 .S TIME=0
"RTN","HLOPURGE",22,0)
 .F  S TIME=$O(^HLB("AD",WORK,TIME)) Q:TIME=""  Q:TIME>NOW  D
"RTN","HLOPURGE",23,0)
 ..N MSGIEN
"RTN","HLOPURGE",24,0)
 ..S MSGIEN=0
"RTN","HLOPURGE",25,0)
 ..F  S MSGIEN=$O(^HLB("AD",WORK,TIME,MSGIEN)) Q:'MSGIEN  D
"RTN","HLOPURGE",26,0)
 ...K ^HLB("AD",WORK,TIME,MSGIEN)
"RTN","HLOPURGE",27,0)
 ...D DELETE(MSGIEN)
"RTN","HLOPURGE",28,0)
 L -HLPURGE(WORK)
"RTN","HLOPURGE",29,0)
 Q
"RTN","HLOPURGE",30,0)
OLD778 ;
"RTN","HLOPURGE",31,0)
 N OLD,START,END,APP,TYPE,TODAY
"RTN","HLOPURGE",32,0)
 S TODAY=$$DT^XLFDT
"RTN","HLOPURGE",33,0)
 S OLD=$$FMADD^XLFDT(TODAY,-45)
"RTN","HLOPURGE",34,0)
 F START=0,100000000000,200000000000,300000000000 D
"RTN","HLOPURGE",35,0)
 .S END=(START+100000000000)-1
"RTN","HLOPURGE",36,0)
 .N MSGIEN,QUIT
"RTN","HLOPURGE",37,0)
 .S QUIT=0
"RTN","HLOPURGE",38,0)
 .S MSGIEN=START
"RTN","HLOPURGE",39,0)
 .F  S MSGIEN=$O(^HLB(MSGIEN)) Q:'MSGIEN  Q:(MSGIEN>END)  D  Q:QUIT
"RTN","HLOPURGE",40,0)
 ..N WHEN,BODY,NODE
"RTN","HLOPURGE",41,0)
 ..S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOPURGE",42,0)
 ..S WHEN=$P(NODE,"^",16)
"RTN","HLOPURGE",43,0)
 ..I WHEN,WHEN<OLD,$P(NODE,"^",9)<TODAY D DELETE(MSGIEN) Q
"RTN","HLOPURGE",44,0)
 ..I 'WHEN D
"RTN","HLOPURGE",45,0)
 ...S BODY=$P(NODE,"^",2)
"RTN","HLOPURGE",46,0)
 ...Q:'BODY
"RTN","HLOPURGE",47,0)
 ...S WHEN=+$G(^HLA(BODY,0))
"RTN","HLOPURGE",48,0)
 ...I WHEN,WHEN<OLD D  Q
"RTN","HLOPURGE",49,0)
 ....;I've seen messages sitting on outgoing queues forever, but it should never happen for incoming
"RTN","HLOPURGE",50,0)
 ....I $E($P(NODE,"^",4))="O",$P(NODE,"^",5)]"",$P(NODE,"^",6)]"" D
"RTN","HLOPURGE",51,0)
 .....N FROM
"RTN","HLOPURGE",52,0)
 .....S FROM=$P(NODE,"^",5)
"RTN","HLOPURGE",53,0)
 .....I $P(NODE,"^",8) S FROM=FROM_":"_$P(NODE,"^",8)
"RTN","HLOPURGE",54,0)
 .....Q:'$D(^HLB("QUEUE","OUT",FROM,$P(NODE,"^",6),MSGIEN))
"RTN","HLOPURGE",55,0)
 .....D DEQUE^HLOQUE(FROM,$P(NODE,"^",6),"OUT",MSGIEN)
"RTN","HLOPURGE",56,0)
 ....D DELETE(MSGIEN) Q
"RTN","HLOPURGE",57,0)
 ...;stop looking for old records?
"RTN","HLOPURGE",58,0)
 ...I WHEN,WHEN>OLD S QUIT=1
"RTN","HLOPURGE",59,0)
 ;
"RTN","HLOPURGE",60,0)
 ;also kill old errors left lying around
"RTN","HLOPURGE",61,0)
 F TYPE="TF","AE","SE" S APP="" F  S APP=$O(^HLB("ERRORS",TYPE,APP)) Q:APP=""  D
"RTN","HLOPURGE",62,0)
 .N TIME,PARMS
"RTN","HLOPURGE",63,0)
 .D SYSPARMS^HLOSITE(.PARMS)
"RTN","HLOPURGE",64,0)
 .S OLD=$$FMADD^XLFDT($$DT^XLFDT,-PARMS("ERROR PURGE"))
"RTN","HLOPURGE",65,0)
 .S TIME=0
"RTN","HLOPURGE",66,0)
 .F  S TIME=$O(^HLB("ERRORS",TYPE,APP,TIME)) Q:'TIME  Q:TIME>OLD  K ^HLB("ERRORS",TYPE,APP,TIME)
"RTN","HLOPURGE",67,0)
 Q
"RTN","HLOPURGE",68,0)
OLD777 ;
"RTN","HLOPURGE",69,0)
 N OLD,TIME,TODAY
"RTN","HLOPURGE",70,0)
 S TODAY=$$DT^XLFDT
"RTN","HLOPURGE",71,0)
 S OLD=$$FMADD^XLFDT(TODAY,-45)
"RTN","HLOPURGE",72,0)
 S TIME=0
"RTN","HLOPURGE",73,0)
 F  S TIME=$O(^HLA("B",TIME)) Q:'TIME  Q:TIME>OLD  D
"RTN","HLOPURGE",74,0)
 .N MSGIEN
"RTN","HLOPURGE",75,0)
 .S MSGIEN=0
"RTN","HLOPURGE",76,0)
 .F  S MSGIEN=$O(^HLA("B",TIME,MSGIEN)) Q:'MSGIEN  D
"RTN","HLOPURGE",77,0)
 ..N IEN778,STOP
"RTN","HLOPURGE",78,0)
 ..S (STOP,IEN778)=0
"RTN","HLOPURGE",79,0)
 ..F  S IEN778=$O(^HLB("C",MSGIEN,IEN778)) Q:'IEN778  D
"RTN","HLOPURGE",80,0)
 ...I $P($G(^HLB(IEN778,0)),"^",9)>TODAY S STOP=1 Q
"RTN","HLOPURGE",81,0)
 ...D DELETE(IEN778,1)
"RTN","HLOPURGE",82,0)
 ..K:'STOP ^HLB("C",MSGIEN),^HLA("B",TIME,MSGIEN),^HLA(MSGIEN)
"RTN","HLOPURGE",83,0)
 Q
"RTN","HLOPURGE",84,0)
 ;
"RTN","HLOPURGE",85,0)
DELETE(MSGIEN,FLAG) ;
"RTN","HLOPURGE",86,0)
 ;Input:
"RTN","HLOPURGE",87,0)
 ;  MSGIEN - IEN, file 778
"RTN","HLOPURGE",88,0)
 ;  FLAG - if $G(FLAG), will not delete the pointed to record in file 777
"RTN","HLOPURGE",89,0)
 N AC,SUBIEN,RAPP,SAPP,FS,CS,MSG
"RTN","HLOPURGE",90,0)
 I '$$GETMSG^HLOMSG(MSGIEN,.MSG) ;MSG is corrupted, but there sill may be nodes to delete
"RTN","HLOPURGE",91,0)
 S (RAPP,SAPP)=""
"RTN","HLOPURGE",92,0)
 D
"RTN","HLOPURGE",93,0)
 .S FS=$E(MSG("HDR",1),4)
"RTN","HLOPURGE",94,0)
 .Q:FS=""
"RTN","HLOPURGE",95,0)
 .S CS=$E(MSG("HDR",1),5)
"RTN","HLOPURGE",96,0)
 .S SAPP=$P($P(MSG("HDR",1),FS,3),CS)
"RTN","HLOPURGE",97,0)
 .I SAPP="" S SAPP="UNKNOWN"
"RTN","HLOPURGE",98,0)
 .S RAPP=$P($P(MSG("HDR",1),FS,5),CS)
"RTN","HLOPURGE",99,0)
 .I RAPP="" S RAPP="UNKNOWN"
"RTN","HLOPURGE",100,0)
 ;
"RTN","HLOPURGE",101,0)
 I 'MSG("BATCH") D KSEARCH(.MSG,MSG("MESSAGE TYPE"),MSG("EVENT"),SAPP,RAPP,MSGIEN)
"RTN","HLOPURGE",102,0)
 ;if an error status,take care of the "ERRORS" x-ref
"RTN","HLOPURGE",103,0)
 I MSG("STATUS")'="",MSG("STATUS")'="SU",MSG("BODY") D
"RTN","HLOPURGE",104,0)
 .N APP
"RTN","HLOPURGE",105,0)
 .S APP=$S(MSG("STATUS")="TF":SAPP,1:RAPP)
"RTN","HLOPURGE",106,0)
 .K ^HLB("ERRORS",MSG("STATUS"),APP,MSG("DT/TM CREATED"),MSGIEN)
"RTN","HLOPURGE",107,0)
 .I MSG("STATUS")="AE" D
"RTN","HLOPURGE",108,0)
 ..N SUB
"RTN","HLOPURGE",109,0)
 ..S SUB=MSGIEN_"^"
"RTN","HLOPURGE",110,0)
 ..K ^HLB("ERRORS","AE",APP,MSG("DT/TM CREATED"),SUB)
"RTN","HLOPURGE",111,0)
 ..F  S SUB=$O(^HLB("ERRORS","AE",APP,MSG("DT/TM CREATED"),SUB)) Q:SUB=""  Q:+SUB'=MSGIEN  K ^HLB("ERRORS","AE",APP,MSG("DT/TM CREATED"),SUB)
"RTN","HLOPURGE",112,0)
 ;
"RTN","HLOPURGE",113,0)
 ;kill the whole-file xrefs for the message ien within a batch
"RTN","HLOPURGE",114,0)
 S SUBIEN=0
"RTN","HLOPURGE",115,0)
 F  S SUBIEN=$O(^HLB(MSGIEN,3,SUBIEN)) Q:'SUBIEN  D
"RTN","HLOPURGE",116,0)
 .N MSGID
"RTN","HLOPURGE",117,0)
 .I FS]"" D
"RTN","HLOPURGE",118,0)
 ..N VALUE,HDR2,MSGTYPE,EVENT
"RTN","HLOPURGE",119,0)
 ..S HDR2=$G(^HLB(MSGIEN,3,SUBIEN,2))
"RTN","HLOPURGE",120,0)
 ..S VALUE=$P(HDR2,FS,4)
"RTN","HLOPURGE",121,0)
 ..S MSGTYPE=$P(VALUE,CS)
"RTN","HLOPURGE",122,0)
 ..S EVENT=$P(VALUE,CS,2)
"RTN","HLOPURGE",123,0)
 ..D KSEARCH(.MSG,MSGTYPE,EVENT,SAPP,RAPP,MSGIEN_"^"_SUBIEN)
"RTN","HLOPURGE",124,0)
 .S MSGID=$P($G(^HLB(MSGIEN,3,SUBIEN,0)),"^",2)
"RTN","HLOPURGE",125,0)
 .I MSGID]"" K ^HLB("AE",MSGID,MSGIEN_"^"_SUBIEN)
"RTN","HLOPURGE",126,0)
 ;
"RTN","HLOPURGE",127,0)
 I MSG("DIRECTION")="IN" D
"RTN","HLOPURGE",128,0)
 .Q:FS=""
"RTN","HLOPURGE",129,0)
 .N VALUE,HDR
"RTN","HLOPURGE",130,0)
 .S HDR("SENDING APPLICATION")=$P(MSG("HDR",1),FS,3)
"RTN","HLOPURGE",131,0)
 .S VALUE=$P(MSG("HDR",1),FS,4)
"RTN","HLOPURGE",132,0)
 .S HDR("SENDING FACILITY",1)=$P(VALUE,CS)
"RTN","HLOPURGE",133,0)
 .S HDR("SENDING FACILITY",2)=$P(VALUE,CS,2)
"RTN","HLOPURGE",134,0)
 .S HDR("SENDING FACILITY",3)=$P(VALUE,CS,3)
"RTN","HLOPURGE",135,0)
 .S AC=$S(HDR("SENDING FACILITY",2)]"":HDR("SENDING FACILITY",2),1:HDR("SENDING FACILITY",1))_HDR("SENDING APPLICATION")_MSG("ID")
"RTN","HLOPURGE",136,0)
 K ^HLB(MSGIEN)
"RTN","HLOPURGE",137,0)
 I MSG("STATUS","PURGE"),MSG("DIRECTION")'="" K ^HLB("AD",MSG("DIRECTION"),MSG("STATUS","PURGE"),MSGIEN)
"RTN","HLOPURGE",138,0)
 K:(MSG("ID")]"") ^HLB("B",MSG("ID"),MSGIEN)
"RTN","HLOPURGE",139,0)
 I MSG("DIRECTION")="IN" D
"RTN","HLOPURGE",140,0)
 .K:($G(AC)]"") ^HLB("AC",AC,MSGIEN)
"RTN","HLOPURGE",141,0)
 .I MSG("BODY"),'$G(FLAG) D KILL777(MSG("BODY"))
"RTN","HLOPURGE",142,0)
 I MSG("DIRECTION")="OUT" D
"RTN","HLOPURGE",143,0)
 .K ^HLB("C",+MSG("BODY"),MSGIEN)
"RTN","HLOPURGE",144,0)
 .I '$G(FLAG),'$O(^HLB("C",+MSG("BODY"),0)) D KILL777(MSG("BODY"))
"RTN","HLOPURGE",145,0)
 Q
"RTN","HLOPURGE",146,0)
 ;
"RTN","HLOPURGE",147,0)
KILL777(BODY) ;
"RTN","HLOPURGE",148,0)
 Q:'$G(BODY)
"RTN","HLOPURGE",149,0)
 N TIME
"RTN","HLOPURGE",150,0)
 S TIME=$P($G(^HLA(BODY,0)),"^")
"RTN","HLOPURGE",151,0)
 K ^HLA(BODY)
"RTN","HLOPURGE",152,0)
 K:(TIME]"") ^HLA("B",TIME,BODY)
"RTN","HLOPURGE",153,0)
 Q
"RTN","HLOPURGE",154,0)
 ;
"RTN","HLOPURGE",155,0)
KSEARCH(MSG,MSGTYPE,EVENT,SAPP,RAPP,IEN) ;
"RTN","HLOPURGE",156,0)
 ;Kills the ^HLB("SEARCH") x-ref
"RTN","HLOPURGE",157,0)
 ;
"RTN","HLOPURGE",158,0)
 N APP
"RTN","HLOPURGE",159,0)
 S:MSGTYPE="" MSGTYPE="<none>"
"RTN","HLOPURGE",160,0)
 S:EVENT="" EVENT="<none>"
"RTN","HLOPURGE",161,0)
 Q:'MSG("DT/TM CREATED")
"RTN","HLOPURGE",162,0)
 I MSG("DIRECTION")'="IN",MSG("DIRECTION")'="OUT" Q
"RTN","HLOPURGE",163,0)
 S APP=$S(MSG("DIRECTION")="IN":RAPP,1:SAPP)
"RTN","HLOPURGE",164,0)
 Q:APP=""
"RTN","HLOPURGE",165,0)
 K ^HLB("SEARCH",MSG("DIRECTION"),MSG("DT/TM CREATED"),APP,MSGTYPE,EVENT,IEN)
"RTN","HLOPURGE",166,0)
 Q
"RTN","HLOQUE")
0^5^B5560431^B5510606
"RTN","HLOQUE",1,0)
HLOQUE ;ALB/CJM- HL7 QUEUE MANAGEMENT - 10/4/94 1pm ;01/05/2007
"RTN","HLOQUE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132,134**;Oct 13, 1995;Build 30
"RTN","HLOQUE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOQUE",4,0)
 ;
"RTN","HLOQUE",5,0)
INQUE(FROM,QNAME,IEN778,ACTION,PURGE) ;
"RTN","HLOQUE",6,0)
 ;Will place the message=IEN778 on the IN queue, incoming
"RTN","HLOQUE",7,0)
 ;Input:
"RTN","HLOQUE",8,0)
 ;  FROM - sending facility from message header.
"RTN","HLOQUE",9,0)
 ;         For actions other than incoming messages, its the specified link.
"RTN","HLOQUE",10,0)
 ;  QNAME - queue named by the application
"RTN","HLOQUE",11,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",12,0)
 ;  ACTION - <tag^routine> that should be executed for the application
"RTN","HLOQUE",13,0)
 ;  PURGE (optional) - PURGE=1 indicates that the purge dt/tm needs to be set by the infiler
"RTN","HLOQUE",14,0)
 ;     If PURGE("ACKTOIEN") is set, it indicates that the purge dt/tm of
"RTN","HLOQUE",15,0)
 ;     the original message to this application ack also needs to be set.
"RTN","HLOQUE",16,0)
 ;Output: none
"RTN","HLOQUE",17,0)
 ;
"RTN","HLOQUE",18,0)
 I $G(FROM)="" S FROM="UNKNOWN"
"RTN","HLOQUE",19,0)
 I '$L($G(QNAME)) S QNAME="DEFAULT"
"RTN","HLOQUE",20,0)
 S ^HLB("QUEUE","IN",FROM,QNAME,IEN778)=ACTION_"^"_$G(PURGE)_"^"_$G(PURGE("ACKTOIEN"))
"RTN","HLOQUE",21,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","IN",FROM,QNAME)))
"RTN","HLOQUE",22,0)
 Q
"RTN","HLOQUE",23,0)
 ;
"RTN","HLOQUE",24,0)
OUTQUE(LINKNAME,PORT,QNAME,IEN778) ;
"RTN","HLOQUE",25,0)
 ;Will place the message=IEN778 on the out-going queue
"RTN","HLOQUE",26,0)
 ;Input:
"RTN","HLOQUE",27,0)
 ;  LINKNAME = name of (.01) the logical link
"RTN","HLOQUE",28,0)
 ;  PORT (optional) the port to connect to
"RTN","HLOQUE",29,0)
 ;  QNAME - queue named by the application
"RTN","HLOQUE",30,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",31,0)
 ;Output: none
"RTN","HLOQUE",32,0)
 ;
"RTN","HLOQUE",33,0)
 N SUB
"RTN","HLOQUE",34,0)
 S SUB=LINKNAME
"RTN","HLOQUE",35,0)
 I PORT S SUB=SUB_":"_PORT
"RTN","HLOQUE",36,0)
 I '$L($G(QNAME)) S QNAME="DEFAULT"
"RTN","HLOQUE",37,0)
 S ^HLB("QUEUE","OUT",SUB,QNAME,IEN778)=""
"RTN","HLOQUE",38,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","OUT",SUB,QNAME)))
"RTN","HLOQUE",39,0)
 Q
"RTN","HLOQUE",40,0)
 ;
"RTN","HLOQUE",41,0)
DEQUE(FROMORTO,QNAME,DIR,IEN778) ;
"RTN","HLOQUE",42,0)
 ;This routine will remove the message=IEN778 from its queue
"RTN","HLOQUE",43,0)
 ;Input:
"RTN","HLOQUE",44,0)
 ;  DIR = "IN" or "OUT", denoting the direction that the message is going in
"RTN","HLOQUE",45,0)
 ;  FROMORTO = for outgoing: the .01 field of the logical link
"RTN","HLOQUE",46,0)
 ;         for incoming: sending facility
"RTN","HLOQUE",47,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",48,0)
 ;Output: none
"RTN","HLOQUE",49,0)
 ;
"RTN","HLOQUE",50,0)
 Q:(FROMORTO="")
"RTN","HLOQUE",51,0)
 I ($G(QNAME)="") S QNAME="DEFAULT"
"RTN","HLOQUE",52,0)
 D
"RTN","HLOQUE",53,0)
 .I $E(DIR)="I" S DIR="IN" Q
"RTN","HLOQUE",54,0)
 .I $E(DIR)="O" S DIR="OUT" Q
"RTN","HLOQUE",55,0)
 I DIR'="IN",DIR'="OUT" Q
"RTN","HLOQUE",56,0)
 Q:'$G(IEN778)
"RTN","HLOQUE",57,0)
 D:$D(^HLB("QUEUE",DIR,FROMORTO,QNAME,IEN778))
"RTN","HLOQUE",58,0)
 .K ^HLB("QUEUE",DIR,FROMORTO,QNAME,IEN778)
"RTN","HLOQUE",59,0)
 .;don't let the count become negative
"RTN","HLOQUE",60,0)
 .I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT",DIR,FROMORTO,QNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT",DIR,FROMORTO,QNAME)))
"RTN","HLOQUE",61,0)
 Q
"RTN","HLOQUE",62,0)
 ;
"RTN","HLOQUE",63,0)
STOPQUE(DIR,QUEUE) ;
"RTN","HLOQUE",64,0)
 ;This API is used to set a stop flag on a named queue.
"RTN","HLOQUE",65,0)
 ;DIR=<"IN" or "OUT">
"RTN","HLOQUE",66,0)
 ;QUEUE - the name of the queue to be stopped
"RTN","HLOQUE",67,0)
 ;
"RTN","HLOQUE",68,0)
 Q:$G(DIR)=""
"RTN","HLOQUE",69,0)
 Q:$G(QUEUE)=""
"RTN","HLOQUE",70,0)
 S ^HLTMP("STOPPED QUEUES",DIR,QUEUE)=1
"RTN","HLOQUE",71,0)
 Q
"RTN","HLOQUE",72,0)
STARTQUE(DIR,QUEUE) ;
"RTN","HLOQUE",73,0)
 ;This API is used to REMOVE the stop flag on a named queue.
"RTN","HLOQUE",74,0)
 ;DIR=<"IN" or "OUT">
"RTN","HLOQUE",75,0)
 ;QUEUE - the name of the queue to be stopped
"RTN","HLOQUE",76,0)
 ;
"RTN","HLOQUE",77,0)
 Q:$G(DIR)=""
"RTN","HLOQUE",78,0)
 Q:$G(QUEUE)=""
"RTN","HLOQUE",79,0)
 K ^HLTMP("STOPPED QUEUES",DIR,QUEUE)
"RTN","HLOQUE",80,0)
 Q
"RTN","HLOQUE",81,0)
STOPPED(DIR,QUEUE) ;
"RTN","HLOQUE",82,0)
 ;This API is used to DETERMINE if the stop flag on a named queue is set.
"RTN","HLOQUE",83,0)
 ;Input:
"RTN","HLOQUE",84,0)
 ;  DIR=<"IN" or "OUT">
"RTN","HLOQUE",85,0)
 ;  QUEUE - the name of the queue to be checked
"RTN","HLOQUE",86,0)
 ;Output:
"RTN","HLOQUE",87,0)
 ;  Function returns 1 if the queue is stopped, 0 otherwise
"RTN","HLOQUE",88,0)
 Q:$G(DIR)="" 0
"RTN","HLOQUE",89,0)
 Q:$G(QUEUE)="" 0
"RTN","HLOQUE",90,0)
 I $G(^HLTMP("STOPPED QUEUES",DIR,QUEUE)) Q 1
"RTN","HLOQUE",91,0)
 Q 0
"RTN","HLOSRVR")
0^14^B71398107^B62293420
"RTN","HLOSRVR",1,0)
HLOSRVR ;ALB/CJM- Server for receiving messages - 10/4/94 1pm ;03/22/2007
"RTN","HLOSRVR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134**;Oct 13, 1995;Build 30
"RTN","HLOSRVR",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR",4,0)
 ;
"RTN","HLOSRVR",5,0)
GETWORK(WORK) ;
"RTN","HLOSRVR",6,0)
 ;GET WORK function for a single server or a Taskman multi-server
"RTN","HLOSRVR",7,0)
 N LINK
"RTN","HLOSRVR",8,0)
 I '$$CHKSTOP^HLOPROC,$G(WORK("LINK"))]"",$$GETLINK^HLOTLNK(WORK("LINK"),.LINK),+LINK("SERVER") S WORK("PORT")=LINK("PORT") Q 1
"RTN","HLOSRVR",9,0)
 Q 0
"RTN","HLOSRVR",10,0)
 ;
"RTN","HLOSRVR",11,0)
DOWORKS(WORK) ;
"RTN","HLOSRVR",12,0)
 ;DO WORK rtn for a single server (non-concurrent)
"RTN","HLOSRVR",13,0)
 D SERVER(WORK("LINK"))
"RTN","HLOSRVR",14,0)
 Q
"RTN","HLOSRVR",15,0)
DOWORKM(WORK) ;
"RTN","HLOSRVR",16,0)
 ;DO WORK rtn for a Taskman multi-server (Cache systems only)
"RTN","HLOSRVR",17,0)
 D LISTEN^%ZISTCPS(WORK("PORT"),"SERVER^HLOSRVR("""_WORK("LINK")_""")")
"RTN","HLOSRVR",18,0)
 Q
"RTN","HLOSRVR",19,0)
 ;
"RTN","HLOSRVR",20,0)
VMS2(LINKNAME) ;called from a VMS TCP Service once a connection request has been received.  This entry point should be used only if an additional VMS TCPIP Services are being created for HLO.
"RTN","HLOSRVR",21,0)
 ;Input:
"RTN","HLOSRVR",22,0)
 ;   LINKNAME - only pass it in if an additional service is being created on a different port
"RTN","HLOSRVR",23,0)
 Q:'$L(LINKNAME)
"RTN","HLOSRVR",24,0)
 D VMS
"RTN","HLOSRVR",25,0)
 Q
"RTN","HLOSRVR",26,0)
 ;
"RTN","HLOSRVR",27,0)
VMS ;Called from VMS TCP Service once a connection request has been received. This entry point should be used only by the standard HLO service that runs on the standard HLO port.
"RTN","HLOSRVR",28,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",29,0)
 D
"RTN","HLOSRVR",30,0)
 .Q:$L($G(LINKNAME))
"RTN","HLOSRVR",31,0)
 .;
"RTN","HLOSRVR",32,0)
 .N PROC,NODE
"RTN","HLOSRVR",33,0)
 .S PROC=$O(^HLD(779.3,"B","VMS TCP LISTENER",0))
"RTN","HLOSRVR",34,0)
 .I PROC S LINKNAME=$P($G(^HLD(779.3,PROC,0)),"^",14) Q:$L(LINKNAME)
"RTN","HLOSRVR",35,0)
 .S NODE=$G(^HLD(779.1,1,0)) I $P(NODE,"^",10) S LINKNAME=$P($G(^HLCS(870,$P(NODE,"^",10),0)),"^") Q:$L(LINKNAME) 
"RTN","HLOSRVR",36,0)
 .S LINKNAME="HLO DEFAULT LISTENER"
"RTN","HLOSRVR",37,0)
 ;
"RTN","HLOSRVR",38,0)
 D SERVER(LINKNAME,"SYS$NET")
"RTN","HLOSRVR",39,0)
 Q
"RTN","HLOSRVR",40,0)
 ;
"RTN","HLOSRVR",41,0)
SERVER(LINKNAME,LOGICAL) ; LINKNAME identifies the logical link, which describes the communication channel to be used
"RTN","HLOSRVR",42,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOSRVR1"
"RTN","HLOSRVR",43,0)
 N HLCSTATE,INQUE
"RTN","HLOSRVR",44,0)
 S INQUE=0
"RTN","HLOSRVR",45,0)
 Q:'$$CONNECT(.HLCSTATE,LINKNAME,.LOGICAL)
"RTN","HLOSRVR",46,0)
 K LINKNAME
"RTN","HLOSRVR",47,0)
 F  Q:'HLCSTATE("CONNECTED")  D  Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",48,0)
 .N HLMSTATE,SENT
"RTN","HLOSRVR",49,0)
 .;
"RTN","HLOSRVR",50,0)
 .;read msg and parse the hdr
"RTN","HLOSRVR",51,0)
 .;HLMSTATE("MSA",1) is set with type of ack to return
"RTN","HLOSRVR",52,0)
 .I $$READMSG^HLOSRVR1(.HLCSTATE,.HLMSTATE) D
"RTN","HLOSRVR",53,0)
 ..;
"RTN","HLOSRVR",54,0)
 ..;send an ack if required and save the MSA segment
"RTN","HLOSRVR",55,0)
 ..I (HLMSTATE("MSA",1)]"") S SENT=$$WRITEACK(.HLCSTATE,.HLMSTATE) D:HLMSTATE("IEN") SAVEACK(.HLMSTATE,SENT)
"RTN","HLOSRVR",56,0)
 ..D:HLMSTATE("IEN") UPDATE(.HLMSTATE,.HLCSTATE)
"RTN","HLOSRVR",57,0)
 ..D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",58,0)
 .E  D INQUE() H:HLCSTATE("CONNECTED") 1
"RTN","HLOSRVR",59,0)
 ;
"RTN","HLOSRVR",60,0)
END D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR",61,0)
 D INQUE()
"RTN","HLOSRVR",62,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",63,0)
 Q
"RTN","HLOSRVR",64,0)
 ;
"RTN","HLOSRVR",65,0)
CONNECT(HLCSTATE,LINKNAME,LOGICAL) ;
"RTN","HLOSRVR",66,0)
 ;sets up HLCSTATE() and opens a server connection
"RTN","HLOSRVR",67,0)
 ;
"RTN","HLOSRVR",68,0)
 N LINK,NODE
"RTN","HLOSRVR",69,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOSRVR",70,0)
 Q:'$$GETLINK^HLOTLNK(LINKNAME,.LINK) 0
"RTN","HLOSRVR",71,0)
 Q:+LINK("SERVER")'=1 0
"RTN","HLOSRVR",72,0)
 S HLCSTATE("SERVER")=LINK("SERVER")
"RTN","HLOSRVR",73,0)
 M HLCSTATE("LINK")=LINK
"RTN","HLOSRVR",74,0)
 S HLCSTATE("READ TIMEOUT")=20
"RTN","HLOSRVR",75,0)
 S HLCSTATE("OPEN TIMEOUT")=30
"RTN","HLOSRVR",76,0)
 S HLCSTATE("READ")="" ;buffer for reads
"RTN","HLOSRVR",77,0)
 ;
"RTN","HLOSRVR",78,0)
 ;HLCSTATE("BUFFER",<seg>,<line>)  write buffer
"RTN","HLOSRVR",79,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of bytes in buffer
"RTN","HLOSRVR",80,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOSRVR",81,0)
 ;
"RTN","HLOSRVR",82,0)
 S HLCSTATE("COUNTS")=0
"RTN","HLOSRVR",83,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOSRVR",84,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOSRVR",85,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOSRVR",86,0)
 Q:HLCSTATE("SYSTEM","OS")="" 0
"RTN","HLOSRVR",87,0)
 D  ;get necessary system parameters
"RTN","HLOSRVR",88,0)
 .N SYS,SUB
"RTN","HLOSRVR",89,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOSRVR",90,0)
 .F SUB="MAXSTRING","DOMAIN","STATION","PROCESSING ID","NORMAL PURGE","ERROR PURGE" S HLCSTATE("SYSTEM",SUB)=SYS(SUB)
"RTN","HLOSRVR",91,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOSRVR",92,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOSRVR",93,0)
 .D OPEN^HLOTCP(.HLCSTATE,.LOGICAL)
"RTN","HLOSRVR",94,0)
 E  ;no other LLP implemented
"RTN","HLOSRVR",95,0)
 ;
"RTN","HLOSRVR",96,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOSRVR",97,0)
 ;
"RTN","HLOSRVR",98,0)
INQUE(MSGIEN,PARMS) ;
"RTN","HLOSRVR",99,0)
 ;puts received messages on the incoming queue and sets the B x-refs
"RTN","HLOSRVR",100,0)
 I $G(MSGIEN) S INQUE=INQUE+1 M INQUE(MSGIEN)=PARMS
"RTN","HLOSRVR",101,0)
 I ('$G(MSGIEN))!(INQUE>20) S MSGIEN=0 D
"RTN","HLOSRVR",102,0)
 .F  S MSGIEN=$O(INQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOSRVR",103,0)
 ..S ^HLB("B",INQUE(MSGIEN,"MSGID"),MSGIEN)=""
"RTN","HLOSRVR",104,0)
 ..S ^HLA("B",INQUE(MSGIEN,"DT/TM"),INQUE(MSGIEN,"BODY"))=""
"RTN","HLOSRVR",105,0)
 ..D:INQUE(MSGIEN,"PASS")
"RTN","HLOSRVR",106,0)
 ...N PURGE
"RTN","HLOSRVR",107,0)
 ...S PURGE=+$G(INQUE(MSGIEN,"PURGE"))
"RTN","HLOSRVR",108,0)
 ...S PURGE("ACKTOIEN")=$G(INQUE(MSGIEN,"ACKTOIEN"))
"RTN","HLOSRVR",109,0)
 ...D INQUE^HLOQUE(INQUE(MSGIEN,"FROM"),INQUE(MSGIEN,"QUEUE"),MSGIEN,INQUE(MSGIEN,"ACTION"),.PURGE)
"RTN","HLOSRVR",110,0)
 .K INQUE S INQUE=0
"RTN","HLOSRVR",111,0)
 Q
"RTN","HLOSRVR",112,0)
 ;
"RTN","HLOSRVR",113,0)
SAVEACK(HLMSTATE,SENT) ;
"RTN","HLOSRVR",114,0)
 ;Input:
"RTN","HLOSRVR",115,0)
 ;  SENT - flag = 1 if transmission of ack succeeded, 0 otherwise
"RTN","HLOSRVR",116,0)
 ;
"RTN","HLOSRVR",117,0)
 N NODE,I
"RTN","HLOSRVR",118,0)
 S $P(NODE,"^")=HLMSTATE("MSA","DT/TM OF MESSAGE")
"RTN","HLOSRVR",119,0)
 S $P(NODE,"^",2)=HLMSTATE("MSA","MESSAGE CONTROL ID")
"RTN","HLOSRVR",120,0)
 S $P(NODE,"^",3)="MSA"
"RTN","HLOSRVR",121,0)
 F I=1:1:3 S NODE=NODE_"|"_$G(HLMSTATE("MSA",I))
"RTN","HLOSRVR",122,0)
 S ^HLB(HLMSTATE("IEN"),4)=NODE
"RTN","HLOSRVR",123,0)
 S:SENT $P(^HLB(HLMSTATE("IEN"),0),"^",$S($E(HLMSTATE("MSA",1))="A":18,1:17))=1
"RTN","HLOSRVR",124,0)
 Q
"RTN","HLOSRVR",125,0)
 ;
"RTN","HLOSRVR",126,0)
UPDATE(HLMSTATE,HLCSTATE) ;
"RTN","HLOSRVR",127,0)
 ;Updates status and purge date when appropriate
"RTN","HLOSRVR",128,0)
 ;Also, sets the "B" xrefs, files 777,778, and places message on the incoming queue
"RTN","HLOSRVR",129,0)
 ;
"RTN","HLOSRVR",130,0)
 N PARMS,PURGE,WAIT
"RTN","HLOSRVR",131,0)
 S PARMS("PASS")=0
"RTN","HLOSRVR",132,0)
 I HLMSTATE("STATUS","ACTION")]"",HLMSTATE("STATUS")'="SE" D
"RTN","HLOSRVR",133,0)
 .N IEN
"RTN","HLOSRVR",134,0)
 .S IEN=HLMSTATE("IEN")
"RTN","HLOSRVR",135,0)
 .S PARMS("PASS")=1,$P(^HLB(IEN,0),"^",6)=HLMSTATE("STATUS","QUEUE"),$P(^HLB(IEN,0),"^",10)=$P(HLMSTATE("STATUS","ACTION"),"^"),$P(^HLB(IEN,0),"^",11)=$P(HLMSTATE("STATUS","ACTION"),"^",2)
"RTN","HLOSRVR",136,0)
 D:'PARMS("PASS")  ;if not passing to the app, set the purge date
"RTN","HLOSRVR",137,0)
 .I HLMSTATE("STATUS")="" S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",138,0)
 .S:HLMSTATE("BATCH") WAIT=HLCSTATE("SYSTEM","ERROR PURGE")
"RTN","HLOSRVR",139,0)
 .S:'HLMSTATE("BATCH") WAIT=$S(($G(HLMSTATE("ACK TO","STATUS"))="AE"):24*HLCSTATE("SYSTEM","ERROR PURGE"),HLMSTATE("STATUS")="SE":24*HLCSTATE("SYSTEM","ERROR PURGE"),1:HLCSTATE("SYSTEM","NORMAL PURGE"))
"RTN","HLOSRVR",140,0)
 .S PURGE=$$FMADD^XLFDT($$NOW^XLFDT,,WAIT)
"RTN","HLOSRVR",141,0)
 .S $P(^HLB(HLMSTATE("IEN"),0),"^",9)=PURGE
"RTN","HLOSRVR",142,0)
 .S ^HLB("AD","IN",PURGE,HLMSTATE("IEN"))=""
"RTN","HLOSRVR",143,0)
 .;if this is an app ack, purge the original message at the same time
"RTN","HLOSRVR",144,0)
 .I $G(HLMSTATE("ACK TO","IEN")),'HLMSTATE("BATCH") D
"RTN","HLOSRVR",145,0)
 ..S $P(^HLB(+HLMSTATE("ACK TO","IEN"),0),"^",9)=PURGE
"RTN","HLOSRVR",146,0)
 ..S ^HLB("AD","IN",PURGE,+HLMSTATE("ACK TO","IEN"))=""
"RTN","HLOSRVR",147,0)
 ;
"RTN","HLOSRVR",148,0)
 ;if not waiting for an application ack, set the status now even if passing to the app - but don't set the purge until the infiler passes the message
"RTN","HLOSRVR",149,0)
 I HLMSTATE("STATUS")="",($G(HLMSTATE("ACK TO","IEN"))!HLMSTATE("HDR","APP ACK TYPE")'="AL") S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",150,0)
 I HLMSTATE("STATUS")'="" S $P(^HLB(HLMSTATE("IEN"),0),"^",20)=HLMSTATE("STATUS") S:$G(HLMSTATE("MSA",3))]"" $P(^HLB(HLMSTATE("IEN"),0),"^",21)=HLMSTATE("MSA",3) D:HLMSTATE("STATUS")="SE"
"RTN","HLOSRVR",151,0)
 .N APP
"RTN","HLOSRVR",152,0)
 .S APP=HLMSTATE("HDR","RECEIVING APPLICATION") S:APP="" APP="UNKNOWN" S ^HLB("ERRORS","SE",APP,HLMSTATE("DT/TM"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR",153,0)
 .D COUNT^HLOESTAT("IN",$G(HLMSTATE("HDR","RECEIVING APPLICATION")),$G(HLMSTATE("HDR","SENDING APPLICATION")),$S(HLMSTATE("BATCH"):"BATCH",1:$G(HLMSTATE("HDR","MESSAGE TYPE"))),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR",154,0)
 ;
"RTN","HLOSRVR",155,0)
 ;set the necessary parms for passing the msg to the app via the infiler
"RTN","HLOSRVR",156,0)
 D:PARMS("PASS")
"RTN","HLOSRVR",157,0)
 .N I,FROM
"RTN","HLOSRVR",158,0)
 .S FROM=HLMSTATE("HDR","SENDING FACILITY",1)
"RTN","HLOSRVR",159,0)
 .I HLMSTATE("HDR","SENDING FACILITY",2)]"" S FROM=FROM_"~"_HLMSTATE("HDR","SENDING FACILITY",2)_"~"_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",160,0)
 .I FROM="" S FROM="UNKNOWN SENDING FACILITY"
"RTN","HLOSRVR",161,0)
 .S PARMS("FROM")=FROM,PARMS("QUEUE")=HLMSTATE("STATUS","QUEUE"),PARMS("ACTION")=HLMSTATE("STATUS","ACTION")
"RTN","HLOSRVR",162,0)
 .I HLMSTATE("STATUS")'="" S PARMS("PURGE")=$S(HLMSTATE("STATUS")'="SU":2,$G(HLMSTATE("ACK TO","STATUS"))="AE":2,1:1)
"RTN","HLOSRVR",163,0)
 .S:$G(HLMSTATE("ACK TO","IEN")) PARMS("ACKTOIEN")=HLMSTATE("ACK TO","IEN") ;to insure that the infiler will know to set the purge date at the same time as the initial message
"RTN","HLOSRVR",164,0)
 ;
"RTN","HLOSRVR",165,0)
 S PARMS("BODY")=HLMSTATE("BODY")
"RTN","HLOSRVR",166,0)
 S PARMS("DT/TM")=HLMSTATE("DT/TM")
"RTN","HLOSRVR",167,0)
 S PARMS("MSGID")=HLMSTATE("ID")
"RTN","HLOSRVR",168,0)
 D INQUE(HLMSTATE("IEN"),.PARMS)
"RTN","HLOSRVR",169,0)
 Q
"RTN","HLOSRVR",170,0)
 ;
"RTN","HLOSRVR",171,0)
WRITEACK(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR",172,0)
 ;Sends an accept ack
"RTN","HLOSRVR",173,0)
 ;
"RTN","HLOSRVR",174,0)
 ;Input:
"RTN","HLOSRVR",175,0)
 ;  HLCSTATE (pass by reference) defines the communication channel
"RTN","HLOSRVR",176,0)
 ;  HLMSTATE (pass by reference) the message being acked
"RTN","HLOSRVR",177,0)
 ;     ("MSA",1) - value for MSA-1
"RTN","HLOSRVR",178,0)
 ;     ("MSA",2) - value for MSA-2
"RTN","HLOSRVR",179,0)
 ;     ("MSA",3) - value for MSA-3
"RTN","HLOSRVR",180,0)
 ;     ("HDR") - parsed values for the message being ack'd
"RTN","HLOSRVR",181,0)
 ;Output:
"RTN","HLOSRVR",182,0)
 ;  Function returns 1 if successful, 0 otherwise
"RTN","HLOSRVR",183,0)
 ;  HLMSTATE("MSA","MESSAGE CONTROL ID") - the msg id of the ack
"RTN","HLOSRVR",184,0)
 ;  HLMSTATE(,"MSA","DT/TM OF MESSAGE") - from the ack header
"RTN","HLOSRVR",185,0)
 ;
"RTN","HLOSRVR",186,0)
 N HDR,SUB,FS,CS,MSA,ACKID,TIME
"RTN","HLOSRVR",187,0)
 ;Hard-code the delimiters, the standard requires that the receiving system accept the delimiters listed in the header
"RTN","HLOSRVR",188,0)
 S FS="|"
"RTN","HLOSRVR",189,0)
 S CS="^"
"RTN","HLOSRVR",190,0)
 S TIME=$$NOW^XLFDT
"RTN","HLOSRVR",191,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=TIME
"RTN","HLOSRVR",192,0)
 S ACKID=HLCSTATE("SYSTEM","STATION")_" "_$$NEWIEN^HLOF778A("OUT")
"RTN","HLOSRVR",193,0)
 S HLMSTATE("MSA","MESSAGE CONTROL ID")=ACKID
"RTN","HLOSRVR",194,0)
 ;
"RTN","HLOSRVR",195,0)
 S HDR(1)="MSH"_FS_"^~\&"_FS_HLMSTATE("HDR","RECEIVING APPLICATION")_FS_HLCSTATE("SYSTEM","STATION")_CS_HLCSTATE("SYSTEM","DOMAIN")_CS_"DNS"_FS
"RTN","HLOSRVR",196,0)
 S HDR(1)=HDR(1)_HLMSTATE("HDR","SENDING APPLICATION")_FS_HLMSTATE("HDR","SENDING FACILITY",1)_CS_HLMSTATE("HDR","SENDING FACILITY",2)_CS_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",197,0)
 ;
"RTN","HLOSRVR",198,0)
 S HDR(2)=FS_$$HLDATE^HLFNC(TIME,"TS")_FS_FS_"ACK"_FS_ACKID_FS_HLMSTATE("HDR","PROCESSING ID")_FS_"2.4"_FS_FS_FS_"NE"_FS_"NE"
"RTN","HLOSRVR",199,0)
 ;
"RTN","HLOSRVR",200,0)
 S MSA(1)="MSA"_FS
"RTN","HLOSRVR",201,0)
 F SUB=1:1:3 S MSA(1)=MSA(1)_HLMSTATE("MSA",SUB)_FS
"RTN","HLOSRVR",202,0)
 I $$WRITEHDR^HLOT(.HLCSTATE,.HDR),$$WRITESEG^HLOT(.HLCSTATE,.MSA),$$ENDMSG^HLOT(.HLCSTATE) S HLCSTATE("COUNTS","ACKS")=$G(HLCSTATE("COUNTS","ACKS"))+1 Q 1
"RTN","HLOSRVR",203,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=""
"RTN","HLOSRVR",204,0)
 Q 0
"RTN","HLOSRVR1")
0^23^B71810026^B60360938
"RTN","HLOSRVR1",1,0)
HLOSRVR1 ;IRMFO-ALB/CJM - Reading messages, sending acks;03/24/2004  14:43 ;03/26/2007
"RTN","HLOSRVR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,133,134**;Oct 13, 1995;Build 30
"RTN","HLOSRVR1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR1",4,0)
 ;
"RTN","HLOSRVR1",5,0)
READMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR1",6,0)
 ;Reads a message.  The header is parsed. Does these checks:
"RTN","HLOSRVR1",7,0)
 ; 1) Duplicate?
"RTN","HLOSRVR1",8,0)
 ; 2) Wrong Receiving Facility?
"RTN","HLOSRVR1",9,0)
 ; 3) Can the Receiving App accept this message, based message type & event?
"RTN","HLOSRVR1",10,0)
 ; 4) Processing ID must match the receiving system
"RTN","HLOSRVR1",11,0)
 ; 5) Must have an ID
"RTN","HLOSRVR1",12,0)
 ; 6) Header must be BHS or MSH
"RTN","HLOSRVR1",13,0)
 ;
"RTN","HLOSRVR1",14,0)
 ;Output:
"RTN","HLOSRVR1",15,0)
 ;  Function returns 1 if the message was read fully, 0 otherwise
"RTN","HLOSRVR1",16,0)
 ;  HLMSTATE (pass by reference) the message.  It will include the fields for the return ack in HLMSTATE("MSA")
"RTN","HLOSRVR1",17,0)
 ;
"RTN","HLOSRVR1",18,0)
 N ACK,SEG,STORE,I
"RTN","HLOSRVR1",19,0)
 ;
"RTN","HLOSRVR1",20,0)
 S STORE=1
"RTN","HLOSRVR1",21,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.SEG) 0
"RTN","HLOSRVR1",22,0)
 D SPLITHDR(.SEG)
"RTN","HLOSRVR1",23,0)
 ;
"RTN","HLOSRVR1",24,0)
 ;parse the header, stop if unsuccessful because the server cannot know what to do next
"RTN","HLOSRVR1",25,0)
 I '$$PARSEHDR^HLOPRS(.SEG) D  Q 0
"RTN","HLOSRVR1",26,0)
 .S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOSRVR1",27,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",28,0)
 D NEWMSG^HLOSRVR2(.HLCSTATE,.HLMSTATE,.SEG)
"RTN","HLOSRVR1",29,0)
 I HLMSTATE("ID")="" D
"RTN","HLOSRVR1",30,0)
 .S STORE=0
"RTN","HLOSRVR1",31,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" S HLMSTATE("MSA",1)="CE",HLMSTATE("MSA",3)="CONTROL ID MISSING"
"RTN","HLOSRVR1",32,0)
 I STORE,$$DUP(.HLMSTATE) S STORE=0
"RTN","HLOSRVR1",33,0)
 ;
"RTN","HLOSRVR1",34,0)
 ;if the message is not to be stored, just read it and discard the segments
"RTN","HLOSRVR1",35,0)
 I 'STORE D
"RTN","HLOSRVR1",36,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)
"RTN","HLOSRVR1",37,0)
 ;
"RTN","HLOSRVR1",38,0)
 E  D
"RTN","HLOSRVR1",39,0)
 .N FS
"RTN","HLOSRVR1",40,0)
 .S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOSRVR1",41,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOSRVR1",42,0)
 ..N MSA,SEGTYPE,OLDMSGID,CODE,IEN,NEWMSGID,TEXT
"RTN","HLOSRVR1",43,0)
 ..S SEGTYPE=$E($E(SEG(1),1,3)_$E($G(SEG(2)),1,2),1,3)
"RTN","HLOSRVR1",44,0)
 ..I SEGTYPE="MSA" D
"RTN","HLOSRVR1",45,0)
 ...S MSA=SEG(1)_$G(SEG(2))_$G(SEG(3))
"RTN","HLOSRVR1",46,0)
 ...S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2),TEXT=$E($P(MSA,FS,4),1,30)
"RTN","HLOSRVR1",47,0)
 ...I $E(CODE,1)'="A" S SEGTYPE="" Q
"RTN","HLOSRVR1",48,0)
 ...S:$P(OLDMSGID,"-")]"" IEN=$O(^HLB("B",$P(OLDMSGID,"-"),0))
"RTN","HLOSRVR1",49,0)
 ...S:$G(IEN) IEN=IEN_"^"_$P(OLDMSGID,"-",2)
"RTN","HLOSRVR1",50,0)
 ..I 'HLMSTATE("BATCH") D
"RTN","HLOSRVR1",51,0)
 ...D:SEGTYPE="MSA"
"RTN","HLOSRVR1",52,0)
 ....S HLMSTATE("ACK TO")=OLDMSGID
"RTN","HLOSRVR1",53,0)
 ....S HLMSTATE("ACK TO","ACK BY")=HLMSTATE("ID")
"RTN","HLOSRVR1",54,0)
 ....S HLMSTATE("ACK TO","STATUS")=$S(CODE="AA":"SU",1:"AE")
"RTN","HLOSRVR1",55,0)
 ....S:$D(IEN) HLMSTATE("ACK TO","IEN")=IEN
"RTN","HLOSRVR1",56,0)
 ....S HLMSTATE("ACK TO","ERROR TEXT")=TEXT
"RTN","HLOSRVR1",57,0)
 ...D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",58,0)
 ..E  D  ;batch
"RTN","HLOSRVR1",59,0)
 ...I SEGTYPE="MSH" D
"RTN","HLOSRVR1",60,0)
 ....D SPLITHDR(.SEG)
"RTN","HLOSRVR1",61,0)
 ....S NEWMSGID=$P(SEG(2),FS,5)
"RTN","HLOSRVR1",62,0)
 ....D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",63,0)
 ...E  D  ;not MSH
"RTN","HLOSRVR1",64,0)
 ....D:SEGTYPE="MSA"
"RTN","HLOSRVR1",65,0)
 .....N SUBIEN S SUBIEN=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOSRVR1",66,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN)=OLDMSGID
"RTN","HLOSRVR1",67,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"ACK BY")=NEWMSGID
"RTN","HLOSRVR1",68,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"STATUS")=$S(CODE="AA":"SU",1:"AE")
"RTN","HLOSRVR1",69,0)
 .....S:$D(IEN) HLMSTATE("BATCH","ACK TO",SUBIEN,"IEN")=IEN
"RTN","HLOSRVR1",70,0)
 ....D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",71,0)
 .I HLMSTATE("UNSTORED LINES"),HLCSTATE("MESSAGE ENDED"),$$SAVEMSG^HLOF778(.HLMSTATE)
"RTN","HLOSRVR1",72,0)
 ;
"RTN","HLOSRVR1",73,0)
 I STORE,'HLCSTATE("MESSAGE ENDED") D
"RTN","HLOSRVR1",74,0)
 .;reading failed, don't store
"RTN","HLOSRVR1",75,0)
 .D:HLMSTATE("IEN") DEL778(HLMSTATE("IEN")) D:HLMSTATE("BODY") DEL777(HLMSTATE("BODY"))
"RTN","HLOSRVR1",76,0)
 .S HLMSTATE("IEN")="",HLMSTATE("BODY")=""
"RTN","HLOSRVR1",77,0)
 E  D:STORE
"RTN","HLOSRVR1",78,0)
 .D CHECKMSG(.HLMSTATE)
"RTN","HLOSRVR1",79,0)
 .D ADDAC(.HLMSTATE) ;so future duplicates are detected
"RTN","HLOSRVR1",80,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR1",81,0)
 ;
"RTN","HLOSRVR1",82,0)
 D:'HLCSTATE("MESSAGE ENDED") CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",83,0)
 Q HLCSTATE("MESSAGE ENDED")
"RTN","HLOSRVR1",84,0)
 ;
"RTN","HLOSRVR1",85,0)
ADDAC(HLMSTATE) ;adds the AC xref for duplicates detection
"RTN","HLOSRVR1",86,0)
 ;
"RTN","HLOSRVR1",87,0)
 N FROM
"RTN","HLOSRVR1",88,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",89,0)
 S ^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR1",90,0)
 Q
"RTN","HLOSRVR1",91,0)
 ;
"RTN","HLOSRVR1",92,0)
DUP(HLMSTATE) ;
"RTN","HLOSRVR1",93,0)
 ;Returns 1 if the message is a duplicate and its ack (if requested) is found, 0 otherwise
"RTN","HLOSRVR1",94,0)
 ;Input:
"RTN","HLOSRVR1",95,0)
 ; HLMSTATE (pass by reference) the message being read
"RTN","HLOSRVR1",96,0)
 ;Output:
"RTN","HLOSRVR1",97,0)
 ;  Function returns 1 if the message is a duplicate, 0 otherwise
"RTN","HLOSRVR1",98,0)
 ;  HLMSTATE (pass by reference) IF the message is a duplicate:
"RTN","HLOSRVR1",99,0)
 ;     returns the prior MSA segment in HLMSTATE("MSA")
"RTN","HLOSRVR1",100,0)
 ;
"RTN","HLOSRVR1",101,0)
 N IEN,FROM,DUP
"RTN","HLOSRVR1",102,0)
 S (IEN,DUP)=0
"RTN","HLOSRVR1",103,0)
 ;
"RTN","HLOSRVR1",104,0)
 ;no way to determine!  Bad header will be rejected
"RTN","HLOSRVR1",105,0)
 Q:(HLMSTATE("ID")="") 0
"RTN","HLOSRVR1",106,0)
 ;
"RTN","HLOSRVR1",107,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",108,0)
 F  S IEN=$O(^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),IEN)) Q:'IEN  D  Q:DUP
"RTN","HLOSRVR1",109,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="NE" S DUP=1 Q
"RTN","HLOSRVR1",110,0)
 .;need the MSA to return
"RTN","HLOSRVR1",111,0)
 .D  Q
"RTN","HLOSRVR1",112,0)
 ..N NODE
"RTN","HLOSRVR1",113,0)
 ..S NODE=$P($G(^HLB(IEN,4)),"^",3,10)
"RTN","HLOSRVR1",114,0)
 ..S HLMSTATE("MSA",1)=$P(NODE,"|",2)
"RTN","HLOSRVR1",115,0)
 ..Q:$L(HLMSTATE("MSA",1))'=2
"RTN","HLOSRVR1",116,0)
 ..S HLMSTATE("MSA",2)=$P(NODE,"|",3)
"RTN","HLOSRVR1",117,0)
 ..S HLMSTATE("MSA",3)=$P(NODE,"|",4,10)
"RTN","HLOSRVR1",118,0)
 ..S DUP=1
"RTN","HLOSRVR1",119,0)
 ;
"RTN","HLOSRVR1",120,0)
 Q DUP
"RTN","HLOSRVR1",121,0)
 ;
"RTN","HLOSRVR1",122,0)
CHECKMSG(HLMSTATE) ;
"RTN","HLOSRVR1",123,0)
 ;Checks the header & MSA segment, sets HLMSTATE("STATUS","ACTION") if the message needs to be passed, determines if completion status should be set
"RTN","HLOSRVR1",124,0)
 ;Input:
"RTN","HLOSRVR1",125,0)
 ;  HLMSTATE("HDR") - the parsed header segment
"RTN","HLOSRVR1",126,0)
 ;Output:
"RTN","HLOSRVR1",127,0)
 ;  HLMSTATE("STATUS")="SE" if an error is detected
"RTN","HLOSRVR1",128,0)
 ;  HLMSTATE("STATUS","QUEUE") queue to put the message on
"RTN","HLOSRVR1",129,0)
 ;  HLMSTATE("STATUS","ACTION")  <tag^rtn> that is the processing routine for the receiving application
"RTN","HLOSRVR1",130,0)
 ;  HLMSTATE("MSA") - MSA(1)=accept code to be returned, MSA(3)= error txt
"RTN","HLOSRVR1",131,0)
 ;
"RTN","HLOSRVR1",132,0)
 N WANTACK,PASS,ACTION,QUEUE,ERROR
"RTN","HLOSRVR1",133,0)
 M HDR=HLMSTATE("HDR")
"RTN","HLOSRVR1",134,0)
 S ERROR=0
"RTN","HLOSRVR1",135,0)
 I HDR("ACCEPT ACK TYPE")="NE",'HLMSTATE("ORIGINAL MODE") D
"RTN","HLOSRVR1",136,0)
 .S WANTACK=0
"RTN","HLOSRVR1",137,0)
 E  D
"RTN","HLOSRVR1",138,0)
 .S WANTACK=1
"RTN","HLOSRVR1",139,0)
 I HLMSTATE("ORIGINAL MODE") S HLMSTATE("MSA",1)="AE",HLMSTATE("MSA",3)="THIS INTERFACE DOES NOT IMPLEMENT ORIGINAL MODE APPLICATION ACKOWLEDGMENTS",HLMSTATE("STATUS")="SE" Q
"RTN","HLOSRVR1",140,0)
 I $G(HLMSTATE("ACK TO"))="" D  Q:ERROR
"RTN","HLOSRVR1",141,0)
 .I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE) S ERROR=1 S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="SE" Q
"RTN","HLOSRVR1",142,0)
 .S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",143,0)
 E  D  Q:ERROR  ;this is an app ack
"RTN","HLOSRVR1",144,0)
 .;does the original message exist?
"RTN","HLOSRVR1",145,0)
 .N NODE
"RTN","HLOSRVR1",146,0)
 .S:+$G(HLMSTATE("ACK TO","IEN")) NODE=$G(^HLB(+HLMSTATE("ACK TO","IEN"),0))
"RTN","HLOSRVR1",147,0)
 .I $G(NODE)="" S ERROR=1,HLMSTATE("STATUS")="SE",HLMSTATE("ACK TO","IEN")="" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE TO APPLICATION ACKNOWLEDGMENT NOT FOUND" Q
"RTN","HLOSRVR1",148,0)
 .I $P(NODE,"^",7)'="",$P(NODE,"^",7)'=HLMSTATE("ID") S ERROR=1,HLMSTATE("STATUS")="SE",HLMSTATE("ACK TO","IEN")="" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE WAS ALREADY ACKED" Q
"RTN","HLOSRVR1",149,0)
 .I ($P(NODE,"^",11)]"") S HLMSTATE("STATUS","ACTION")=$P(NODE,"^",10,11),HLMSTATE("STATUS","QUEUE")=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")  Q
"RTN","HLOSRVR1",150,0)
 .;processing routine for the app ack wasn't found with the original message, look in the HLO Application Registry
"RTN","HLOSRVR1",151,0)
 .I HLMSTATE("HDR","MESSAGE TYPE")="ACK",HLMSTATE("HDR","EVENT")="" S HDR("EVENT")=$$GETEVENT^HLOCLNT2(+HLMSTATE("ACK TO","IEN"))
"RTN","HLOSRVR1",152,0)
 .I $$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE) S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",153,0)
 ;
"RTN","HLOSRVR1",154,0)
 I HDR("PROCESSING ID")'=HLCSTATE("SYSTEM","PROCESSING ID") S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("STATUS")="SE",HLMSTATE("MSA",3)="SYSTEM PROCESSING ID="_HLCSTATE("SYSTEM","PROCESSING ID") Q
"RTN","HLOSRVR1",155,0)
 ;
"RTN","HLOSRVR1",156,0)
 ;wrong receiving facility?  This is hard to check if the sender is not VistA, because the HL7 standard permits different coding systems to be used. This check is only for DNS or station number.
"RTN","HLOSRVR1",157,0)
 S PASS=0
"RTN","HLOSRVR1",158,0)
 D
"RTN","HLOSRVR1",159,0)
 .;if its an ack to an existing message, don't check the receiving facility
"RTN","HLOSRVR1",160,0)
 .I $G(HLMSTATE("ACK TO"))]"" S PASS=1 Q
"RTN","HLOSRVR1",161,0)
 .I HDR("RECEIVING FACILITY",1)=HLCSTATE("SYSTEM","STATION") S PASS=1 Q
"RTN","HLOSRVR1",162,0)
 .I HDR("RECEIVING FACILITY",3)'="DNS" S PASS=1 Q
"RTN","HLOSRVR1",163,0)
 .I HDR("RECEIVING FACILITY",2)="" S PASS=1 Q
"RTN","HLOSRVR1",164,0)
 .I $P(HDR("RECEIVING FACILITY",2),":")[HLCSTATE("SYSTEM","DOMAIN") S PASS=1 Q
"RTN","HLOSRVR1",165,0)
 .I HLCSTATE("SYSTEM","DOMAIN")[$P(HDR("RECEIVING FACILITY",2),":") S PASS=1 Q
"RTN","HLOSRVR1",166,0)
 I 'PASS S HLMSTATE("STATUS")="SE",HLMSTATE("MSA",3)="RECEIVING FACILITY IS "_HLCSTATE("SYSTEM","DOMAIN") S:WANTACK HLMSTATE("MSA",1)="CE"
"RTN","HLOSRVR1",167,0)
 I PASS,WANTACK S HLMSTATE("MSA",1)="CA"
"RTN","HLOSRVR1",168,0)
 Q
"RTN","HLOSRVR1",169,0)
 ;
"RTN","HLOSRVR1",170,0)
DEL777(IEN777) ;delete a record from file 777 where the read did not complete
"RTN","HLOSRVR1",171,0)
 ;
"RTN","HLOSRVR1",172,0)
 K ^HLA(IEN777,0)
"RTN","HLOSRVR1",173,0)
 Q
"RTN","HLOSRVR1",174,0)
DEL778(IEN778) ;delete a record from file 778 where the read did not complete
"RTN","HLOSRVR1",175,0)
 ;
"RTN","HLOSRVR1",176,0)
 K ^HLB(IEN778,0)
"RTN","HLOSRVR1",177,0)
 Q
"RTN","HLOSRVR1",178,0)
 ;
"RTN","HLOSRVR1",179,0)
SPLITHDR(HDR) ;
"RTN","HLOSRVR1",180,0)
 ;splits hdr segment into two lines, first being just components 1-6
"RTN","HLOSRVR1",181,0)
 ;
"RTN","HLOSRVR1",182,0)
 N TEMP,FS
"RTN","HLOSRVR1",183,0)
 D SQUISH(.HDR)
"RTN","HLOSRVR1",184,0)
 S FS=$E($G(HDR(1)),4)
"RTN","HLOSRVR1",185,0)
 S TEMP(1)=$P($G(HDR(1)),FS,1,6)
"RTN","HLOSRVR1",186,0)
 S TEMP(2)=""
"RTN","HLOSRVR1",187,0)
 I $L(TEMP(1))<$L($G(HDR(1))) S TEMP(2)=FS_$P($G(HDR(1)),FS,7,20)
"RTN","HLOSRVR1",188,0)
 S HDR(2)=TEMP(2)_$G(HDR(2))
"RTN","HLOSRVR1",189,0)
 S HDR(1)=TEMP(1)
"RTN","HLOSRVR1",190,0)
 Q
"RTN","HLOSRVR1",191,0)
 ;
"RTN","HLOSRVR1",192,0)
SQUISH(SEG) ;
"RTN","HLOSRVR1",193,0)
 ;reformat the segment array into full lines
"RTN","HLOSRVR1",194,0)
 ;
"RTN","HLOSRVR1",195,0)
 ;nothing to do if less than 2 lines
"RTN","HLOSRVR1",196,0)
 Q:'$O(SEG(1))
"RTN","HLOSRVR1",197,0)
 ;
"RTN","HLOSRVR1",198,0)
 N A,I,J,K,MAX,COUNT,LEN
"RTN","HLOSRVR1",199,0)
 S MAX=$S($G(HLCSTATE("SYSTEM","MAXSTRING"))>256:HLCSTATE("SYSTEM","MAXSTRING"),1:256)
"RTN","HLOSRVR1",200,0)
 S (COUNT,I)=0,J=1
"RTN","HLOSRVR1",201,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOSRVR1",202,0)
 .S LEN=$L(SEG(I))
"RTN","HLOSRVR1",203,0)
 .F K=1:1:LEN D
"RTN","HLOSRVR1",204,0)
 ..S A(J)=$G(A(J))_$E(SEG(I),K)
"RTN","HLOSRVR1",205,0)
 ..S COUNT=COUNT+1
"RTN","HLOSRVR1",206,0)
 ..I (COUNT>(MAX-1)) S COUNT=0,J=J+1
"RTN","HLOSRVR1",207,0)
 K SEG
"RTN","HLOSRVR1",208,0)
 M SEG=A
"RTN","HLOSRVR1",209,0)
 Q
"RTN","HLOSRVR1",210,0)
 ;
"RTN","HLOSRVR1",211,0)
ERROR ;error trap
"RTN","HLOSRVR1",212,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOSRVR1",213,0)
 D END^HLOSRVR
"RTN","HLOSRVR1",214,0)
 ;
"RTN","HLOSRVR1",215,0)
 ;concurrent server connections (multi-listener) should stop execution, only a single server may continue
"RTN","HLOSRVR1",216,0)
 I $P($G(HLCSTATE("LINK","SERVER")),"^",2)'="S" D  Q:$QUIT "" Q
"RTN","HLOSRVR1",217,0)
 .;don't log these common errors
"RTN","HLOSRVR1",218,0)
 .I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D
"RTN","HLOSRVR1",219,0)
 ..;
"RTN","HLOSRVR1",220,0)
 .E  D
"RTN","HLOSRVR1",221,0)
 ..D ^%ZTER
"RTN","HLOSRVR1",222,0)
 ;
"RTN","HLOSRVR1",223,0)
 ;while debugging quit on all errors
"RTN","HLOSRVR1",224,0)
 I $G(^HLTMP("LOG ALL ERRORS"))!($ECODE["EDITED") Q:$QUIT "" Q
"RTN","HLOSRVR1",225,0)
 ;
"RTN","HLOSRVR1",226,0)
 ;a lot of errors of the same time may indicate an endless loop, so keep a count and quit if large count
"RTN","HLOSRVR1",227,0)
 N HOUR
"RTN","HLOSRVR1",228,0)
 S HOUR=$E($$NOW^XLFDT,1,10)
"RTN","HLOSRVR1",229,0)
 ;
"RTN","HLOSRVR1",230,0)
 I ($G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))>30) Q:$QUIT "" Q
"RTN","HLOSRVR1",231,0)
 ;
"RTN","HLOSRVR1",232,0)
 ;resume execution for the single listener
"RTN","HLOSRVR1",233,0)
 S ^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2))=$G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))+1
"RTN","HLOSRVR1",234,0)
 D UNWIND^%ZTER
"RTN","HLOSRVR1",235,0)
 Q
"RTN","HLOSTAT")
0^7^B56413629^B55442954
"RTN","HLOSTAT",1,0)
HLOSTAT ;ALB/CJM- HLO STATISTICS- 10/4/94 1pm ;01/05/2007
"RTN","HLOSTAT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**130,131,134**;Oct 13, 1995;Build 30
"RTN","HLOSTAT",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSTAT",4,0)
 ;
"RTN","HLOSTAT",5,0)
 ;
"RTN","HLOSTAT",6,0)
COUNT(HLCSTATE,RAP,SAP,TYPE) ;
"RTN","HLOSTAT",7,0)
 S:RAP="" RAP="UNKNOWN"
"RTN","HLOSTAT",8,0)
 S:SAP="" SAP="UNKNOWN"
"RTN","HLOSTAT",9,0)
 S:$L(TYPE)<2 TYPE="UNKNOWN"
"RTN","HLOSTAT",10,0)
 S HLCSTATE("COUNTS")=$G(HLCSTATE("COUNTS"))+1,HLCSTATE("COUNTS",SAP,RAP,TYPE)=1+$G(HLCSTATE("COUNTS",SAP,RAP,TYPE))
"RTN","HLOSTAT",11,0)
 Q
"RTN","HLOSTAT",12,0)
SAVECNTS(HLCSTATE) ;
"RTN","HLOSTAT",13,0)
 N TIME,DIR,RAP,SAP,TYPE,COUNT
"RTN","HLOSTAT",14,0)
 Q:'$G(HLCSTATE("COUNTS"))
"RTN","HLOSTAT",15,0)
 S TIME=$E($$NOW^XLFDT,1,10)
"RTN","HLOSTAT",16,0)
 S DIR=$S(+$G(HLCSTATE("SERVER")):"IN",1:"OUT")
"RTN","HLOSTAT",17,0)
 I $G(HLCSTATE("COUNTS","ACKS")) D
"RTN","HLOSTAT",18,0)
 .I $$INC^HLOSITE($NA(^HLSTATS($S(DIR="IN":"OUT",1:"IN"),"HOURLY",+TIME,"ACCEPT ACK")),HLCSTATE("COUNTS","ACKS"))
"RTN","HLOSTAT",19,0)
 S SAP=""
"RTN","HLOSTAT",20,0)
 F  S SAP=$O(HLCSTATE("COUNTS",SAP)) Q:SAP=""  D
"RTN","HLOSTAT",21,0)
 .S RAP=""
"RTN","HLOSTAT",22,0)
 .F  S RAP=$O(HLCSTATE("COUNTS",SAP,RAP)) Q:RAP=""  D
"RTN","HLOSTAT",23,0)
 ..S TYPE=""
"RTN","HLOSTAT",24,0)
 ..F  S TYPE=$O(HLCSTATE("COUNTS",SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOSTAT",25,0)
 ...S COUNT=HLCSTATE("COUNTS",SAP,RAP,TYPE)
"RTN","HLOSTAT",26,0)
 ...I $$INC^HLOSITE($NA(^HLSTATS(DIR,"HOURLY",+TIME,SAP,RAP,TYPE)),COUNT)
"RTN","HLOSTAT",27,0)
 K HLCSTATE("COUNTS") S HLCSTATE("COUNTS")=0
"RTN","HLOSTAT",28,0)
 Q
"RTN","HLOSTAT",29,0)
 ;
"RTN","HLOSTAT",30,0)
TOTAL(WORK) ;totals hours into days and days into months
"RTN","HLOSTAT",31,0)
 ;
"RTN","HLOSTAT",32,0)
 N RAP,SAP,TIME,LIMIT,DIR,COUNT,MONTH,START,END
"RTN","HLOSTAT",33,0)
 ;
"RTN","HLOSTAT",34,0)
 ;start totaling the next day after last date totaled
"RTN","HLOSTAT",35,0)
 S START=$G(^HLSTATS("END DATE"))
"RTN","HLOSTAT",36,0)
 S:START START=$$FMADD^XLFDT(START,1)
"RTN","HLOSTAT",37,0)
 ;
"RTN","HLOSTAT",38,0)
 ;end totaling in the last hour of yesterday and save it so that the next run knows where to start
"RTN","HLOSTAT",39,0)
 S END=$$FMADD^XLFDT($$DT^XLFDT,-1)
"RTN","HLOSTAT",40,0)
 S ^HLSTATS("END DATE")=END
"RTN","HLOSTAT",41,0)
 S END=END+.24
"RTN","HLOSTAT",42,0)
 ;
"RTN","HLOSTAT",43,0)
 ;total hours into days
"RTN","HLOSTAT",44,0)
 S LIMIT=$$FMADD^XLFDT($$DT^XLFDT,,-48) ;save ~48 hours of hourly data
"RTN","HLOSTAT",45,0)
 F DIR="IN","OUT","EIN","EOUT" D
"RTN","HLOSTAT",46,0)
 .S TIME=0
"RTN","HLOSTAT",47,0)
 .F  S TIME=$O(^HLSTATS(DIR,"HOURLY",TIME)) Q:'TIME  Q:(TIME>END)  D
"RTN","HLOSTAT",48,0)
 ..D:'(TIME<START)
"RTN","HLOSTAT",49,0)
 ...S:(DIR="IN")!(DIR="OUT") ^HLSTATS(DIR,"DAILY",$P(TIME,"."),"ACCEPT ACK")=$G(^HLSTATS(DIR,"DAILY",$P(TIME,"."),"ACCEPT ACK"))+$G(^HLSTATS(DIR,"HOURLY",TIME,"ACCEPT ACK"))
"RTN","HLOSTAT",50,0)
 ...S SAP=""
"RTN","HLOSTAT",51,0)
 ...F  S SAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP)) Q:SAP=""  D
"RTN","HLOSTAT",52,0)
 ....S RAP=""
"RTN","HLOSTAT",53,0)
 ....F  S RAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP)) Q:RAP=""  D
"RTN","HLOSTAT",54,0)
 .....S TYPE=""
"RTN","HLOSTAT",55,0)
 .....F  S TYPE=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOSTAT",56,0)
 ......S COUNT=$G(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE))
"RTN","HLOSTAT",57,0)
 ......S ^HLSTATS(DIR,"DAILY",$P(TIME,"."),SAP,RAP,TYPE)=$G(^HLSTATS(DIR,"DAILY",$P(TIME,"."),SAP,RAP,TYPE))+COUNT
"RTN","HLOSTAT",58,0)
 ..;get rid of old hourly stats
"RTN","HLOSTAT",59,0)
 ..K:(TIME<LIMIT) ^HLSTATS(DIR,"HOURLY",TIME)
"RTN","HLOSTAT",60,0)
 ;
"RTN","HLOSTAT",61,0)
 ;total days into months
"RTN","HLOSTAT",62,0)
 S LIMIT=$$FMADD^XLFDT($$DT^XLFDT,-30) ;save ~30 days of daily data
"RTN","HLOSTAT",63,0)
 F DIR="IN","OUT","EIN","EOUT" D
"RTN","HLOSTAT",64,0)
 .S TIME=0
"RTN","HLOSTAT",65,0)
 .F  S TIME=$O(^HLSTATS(DIR,"DAILY",TIME)) Q:'TIME  Q:(TIME>END)  D
"RTN","HLOSTAT",66,0)
 ..D:'(TIME<START)
"RTN","HLOSTAT",67,0)
 ...S MONTH=$E(TIME,1,5)
"RTN","HLOSTAT",68,0)
 ...S:(DIR="IN")!(DIR="OUT") ^HLSTATS(DIR,"MONTHLY",MONTH,"ACCEPT ACK")=$G(^HLSTATS(DIR,"MONTHLY",MONTH,"ACCEPT ACK"))+$G(^HLSTATS(DIR,"DAILY",TIME,"ACCEPT ACK"))
"RTN","HLOSTAT",69,0)
 ...S SAP=""
"RTN","HLOSTAT",70,0)
 ...F  S SAP=$O(^HLSTATS(DIR,"DAILY",TIME,SAP)) Q:SAP=""  D
"RTN","HLOSTAT",71,0)
 ....S RAP=""
"RTN","HLOSTAT",72,0)
 ....F  S RAP=$O(^HLSTATS(DIR,"DAILY",TIME,SAP,RAP)) Q:RAP=""  D
"RTN","HLOSTAT",73,0)
 .....S TYPE=""
"RTN","HLOSTAT",74,0)
 .....F  S TYPE=$O(^HLSTATS(DIR,"DAILY",TIME,SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOSTAT",75,0)
 ......S COUNT=$G(^HLSTATS(DIR,"DAILY",TIME,SAP,RAP,TYPE))
"RTN","HLOSTAT",76,0)
 ......S ^HLSTATS(DIR,"MONTHLY",MONTH,SAP,RAP,TYPE)=$G(^HLSTATS(DIR,"MONTHLY",MONTH,SAP,RAP,TYPE))+COUNT
"RTN","HLOSTAT",77,0)
 ..K:(TIME<LIMIT) ^HLSTATS(DIR,"DAILY",TIME)
"RTN","HLOSTAT",78,0)
 Q
"RTN","HLOSTAT",79,0)
REPORT ;Interactive option for printing the message statistics report
"RTN","HLOSTAT",80,0)
 N DIR,TYPE,START,END
"RTN","HLOSTAT",81,0)
 W !,"Hourly, daily, and monthly statistics are maintained."
"RTN","HLOSTAT",82,0)
 W !,"Hourly statistics are available for approximately the last 24 hours."
"RTN","HLOSTAT",83,0)
 W !,"Daily statistics are available for approximately the last 30 days."
"RTN","HLOSTAT",84,0)
 W !,"Monthly statistics are kept indefinitely"
"RTN","HLOSTAT",85,0)
 S DIR(0)="S^h:HOURLY;d:DAILY;m:MONTHLY"
"RTN","HLOSTAT",86,0)
 S DIR("A")="Which type of statistics should be reported"
"RTN","HLOSTAT",87,0)
 S DIR("B")="MONTHLY"
"RTN","HLOSTAT",88,0)
 D ^DIR
"RTN","HLOSTAT",89,0)
 Q:$D(DIRUT)
"RTN","HLOSTAT",90,0)
 I Y'="h",Y'="d",Y'="m" Q
"RTN","HLOSTAT",91,0)
 S TYPE=$S(Y="h":"HOURLY",Y="d":"DAILY",1:"MONTHLY")
"RTN","HLOSTAT",92,0)
 S START=$S(TYPE="HOURLY":$E($$FMADD^XLFDT($$NOW^XLFDT,,-24),1,10),TYPE="DAILY":$$FMADD^XLFDT(DT,-7),1:$E($$FMADD^XLFDT(DT,-30),1,5)_"01")
"RTN","HLOSTAT",93,0)
 S START=$$ASKBEGIN^HLOUSR2(START)
"RTN","HLOSTAT",94,0)
 Q:'START
"RTN","HLOSTAT",95,0)
 S END=$$ASKEND^HLOUSR2(START)
"RTN","HLOSTAT",96,0)
 Q:'END
"RTN","HLOSTAT",97,0)
 S:TYPE="MONTHLY" START=$E(START,1,5)_"00"
"RTN","HLOSTAT",98,0)
 S:TYPE="DAILY" START=$E(START,1,7)
"RTN","HLOSTAT",99,0)
 S:TYPE="HOURLY" START=$E(START,1,10)
"RTN","HLOSTAT",100,0)
 D:$$DEVICE() PRINT(TYPE,START,END)
"RTN","HLOSTAT",101,0)
 Q
"RTN","HLOSTAT",102,0)
 ;
"RTN","HLOSTAT",103,0)
QUE ;entry point for queuing the message statistics report
"RTN","HLOSTAT",104,0)
 D PRINT($G(HLOPARMS("STATISTICS TYPE")),$G(HLOPARMS("START DT/TM")),$G(HLOPARMS("END DT/TM")))
"RTN","HLOSTAT",105,0)
 Q
"RTN","HLOSTAT",106,0)
 ;
"RTN","HLOSTAT",107,0)
PRINT(STATTYPE,START,END) ;
"RTN","HLOSTAT",108,0)
 ;
"RTN","HLOSTAT",109,0)
 N RAP,SAP,TIME,DIR,COUNT,PAGE,CRT,QUIT
"RTN","HLOSTAT",110,0)
 S QUIT=0
"RTN","HLOSTAT",111,0)
 S CRT=$S($E(IOST,1,2)="C-":1,1:0)
"RTN","HLOSTAT",112,0)
 ;
"RTN","HLOSTAT",113,0)
 U IO
"RTN","HLOSTAT",114,0)
 W:CRT @IOF
"RTN","HLOSTAT",115,0)
 W "HLO MESSAGING STATISTICS REPORT ",$$FMTE^XLFDT($$NOW^XLFDT),?70,"Page 1"
"RTN","HLOSTAT",116,0)
 D LINE($$LJ("Type:",15)_STATTYPE)
"RTN","HLOSTAT",117,0)
 D LINE($$LJ("Beginning:",15)_$S(STATTYPE="MONTHLY":$$FMTE^XLFDT(START),1:$$FMTE^XLFDT(START)))
"RTN","HLOSTAT",118,0)
 D LINE($$LJ("Ending:",15)_$$FMTE^XLFDT(END))
"RTN","HLOSTAT",119,0)
 S PAGE=1
"RTN","HLOSTAT",120,0)
 ;
"RTN","HLOSTAT",121,0)
 ;
"RTN","HLOSTAT",122,0)
 F DIR="IN","OUT" D  Q:QUIT
"RTN","HLOSTAT",123,0)
 .N TOTAL
"RTN","HLOSTAT",124,0)
 .S TOTAL=0
"RTN","HLOSTAT",125,0)
 .D LINE(" ")
"RTN","HLOSTAT",126,0)
 .S TIME=START
"RTN","HLOSTAT",127,0)
 .S:STATTYPE="MONTHLY" TIME=$E(TIME,1,5)
"RTN","HLOSTAT",128,0)
 .S TIME=TIME-.0001
"RTN","HLOSTAT",129,0)
 .D LINE($S(DIR="IN":"Incoming Messages:",1:"Outgoing Messages:"))
"RTN","HLOSTAT",130,0)
 .Q:QUIT
"RTN","HLOSTAT",131,0)
 .F  S TIME=$O(^HLSTATS(DIR,STATTYPE,TIME)) Q:((TIME>$G(END))&$G(END))  Q:'TIME  D  Q:QUIT
"RTN","HLOSTAT",132,0)
 ..N SUBTOTAL
"RTN","HLOSTAT",133,0)
 ..S SUBTOTAL=0
"RTN","HLOSTAT",134,0)
 ..D LINE(" ")
"RTN","HLOSTAT",135,0)
 ..Q:QUIT
"RTN","HLOSTAT",136,0)
 ..D LINE("     Time Period: "_$S(STATTYPE="MONTHLY":$$FMTE^XLFDT(TIME_"00"),1:$$FMTE^XLFDT(TIME)))
"RTN","HLOSTAT",137,0)
 ..Q:QUIT
"RTN","HLOSTAT",138,0)
 ..S COUNT=$G(^HLSTATS(DIR,STATTYPE,TIME,"ACCEPT ACK"))
"RTN","HLOSTAT",139,0)
 ..I COUNT D  Q:QUIT
"RTN","HLOSTAT",140,0)
 ...D LINE(" ")
"RTN","HLOSTAT",141,0)
 ...Q:QUIT
"RTN","HLOSTAT",142,0)
 ...D LINE("          Accept Acknowledgments by All Applications          Count:"_$$RJ(COUNT,10))
"RTN","HLOSTAT",143,0)
 ...Q:QUIT
"RTN","HLOSTAT",144,0)
 ...D LINE(" ")
"RTN","HLOSTAT",145,0)
 ..S SAP=""
"RTN","HLOSTAT",146,0)
 ..F  S SAP=$O(^HLSTATS(DIR,STATTYPE,TIME,SAP)) Q:SAP=""  D  Q:QUIT
"RTN","HLOSTAT",147,0)
 ...Q:SAP="ACCEPT ACK"
"RTN","HLOSTAT",148,0)
 ...D LINE("          Sending Application: "_SAP)
"RTN","HLOSTAT",149,0)
 ...Q:QUIT
"RTN","HLOSTAT",150,0)
 ...S RAP=""
"RTN","HLOSTAT",151,0)
 ...F  S RAP=$O(^HLSTATS(DIR,STATTYPE,TIME,SAP,RAP)) Q:RAP=""  D  Q:QUIT
"RTN","HLOSTAT",152,0)
 ....D LINE("               Receiving Application: "_RAP)
"RTN","HLOSTAT",153,0)
 ....Q:QUIT
"RTN","HLOSTAT",154,0)
 ....S TYPE=""
"RTN","HLOSTAT",155,0)
 ....F  S TYPE=$O(^HLSTATS(DIR,STATTYPE,TIME,SAP,RAP,TYPE)) Q:TYPE=""  D  Q:QUIT
"RTN","HLOSTAT",156,0)
 .....S COUNT=$G(^HLSTATS(DIR,STATTYPE,TIME,SAP,RAP,TYPE))
"RTN","HLOSTAT",157,0)
 .....S SUBTOTAL=SUBTOTAL+COUNT
"RTN","HLOSTAT",158,0)
 .....D LINE("                    Message Type: "_$$LJ(TYPE,25)_"   Count:"_$$RJ(COUNT,10))
"RTN","HLOSTAT",159,0)
 .....Q:QUIT
"RTN","HLOSTAT",160,0)
 ..I 'QUIT D
"RTN","HLOSTAT",161,0)
 ...S TOTAL=TOTAL+SUBTOTAL
"RTN","HLOSTAT",162,0)
 ...D LINE(" "),LINE($$RJ("**"_STATTYPE_" SUBTOTAL ** (excluding commit acks):",68)_$$RJ(SUBTOTAL,10))
"RTN","HLOSTAT",163,0)
 .D:'QUIT LINE(" "),LINE($$RJ("** TOTAL "_$S(DIR="IN":"INCOMING",1:"OUTGOING")_" MESSAGES ** (excluding commit acks):",68)_$$RJ(TOTAL,10))
"RTN","HLOSTAT",164,0)
 I CRT,'QUIT D PAUSE2
"RTN","HLOSTAT",165,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLOSTAT",166,0)
 D ^%ZISC
"RTN","HLOSTAT",167,0)
 Q
"RTN","HLOSTAT",168,0)
 ;
"RTN","HLOSTAT",169,0)
DEVICE() ;
"RTN","HLOSTAT",170,0)
 ;Description: allows the user to select a device.
"RTN","HLOSTAT",171,0)
 ;Input: none
"RTN","HLOSTAT",172,0)
 ;
"RTN","HLOSTAT",173,0)
 ;Output:
"RTN","HLOSTAT",174,0)
 ;  Function Value - Returns 0 if the user decides not to print or to
"RTN","HLOSTAT",175,0)
 ;    queue the report, 1 otherwise.
"RTN","HLOSTAT",176,0)
 ;
"RTN","HLOSTAT",177,0)
 N OK,HLOPARMS
"RTN","HLOSTAT",178,0)
 S OK=1
"RTN","HLOSTAT",179,0)
 S %ZIS="MQ"
"RTN","HLOSTAT",180,0)
 D ^%ZIS
"RTN","HLOSTAT",181,0)
 S:POP OK=0
"RTN","HLOSTAT",182,0)
 D:OK&$D(IO("Q"))
"RTN","HLOSTAT",183,0)
 .S HLOPARMS("STATISTICS TYPE")=TYPE,HLOPARMS("START DT/TM")=START,HLOPARMS("END DT/TM")=END
"RTN","HLOSTAT",184,0)
 .S ZTRTN="QUE^HLOSTAT",ZTDESC="HLO MESSAGE STATISTICS REPORT",ZTSAVE("HLOPARMS(")=""
"RTN","HLOSTAT",185,0)
 .D ^%ZTLOAD
"RTN","HLOSTAT",186,0)
 .W !,$S($D(ZTSK):"REQUEST QUEUED TASK="_ZTSK,1:"REQUEST CANCELLED")
"RTN","HLOSTAT",187,0)
 .D HOME^%ZIS
"RTN","HLOSTAT",188,0)
 .S OK=0
"RTN","HLOSTAT",189,0)
 Q OK
"RTN","HLOSTAT",190,0)
 ;
"RTN","HLOSTAT",191,0)
PAUSE ;
"RTN","HLOSTAT",192,0)
 ;First scrolls to the bottome of the page, then does a screen pause.  Sets QUIT=1 if user decides to quit.
"RTN","HLOSTAT",193,0)
 ;
"RTN","HLOSTAT",194,0)
 N DIR,X,Y
"RTN","HLOSTAT",195,0)
 F  Q:$Y>(IOSL-3)  W !
"RTN","HLOSTAT",196,0)
 S DIR(0)="E"
"RTN","HLOSTAT",197,0)
 D ^DIR
"RTN","HLOSTAT",198,0)
 I ('(+Y))!$D(DIRUT) S QUIT=1
"RTN","HLOSTAT",199,0)
 Q
"RTN","HLOSTAT",200,0)
PAUSE2 ;
"RTN","HLOSTAT",201,0)
 ;Screen pause without scrolling.  Sets QUIT=1 if user decides to quit.
"RTN","HLOSTAT",202,0)
 ;
"RTN","HLOSTAT",203,0)
 N DIR,X,Y
"RTN","HLOSTAT",204,0)
 S DIR(0)="E"
"RTN","HLOSTAT",205,0)
 D ^DIR
"RTN","HLOSTAT",206,0)
 I ('(+Y))!$D(DIRUT) S QUIT=1
"RTN","HLOSTAT",207,0)
 Q
"RTN","HLOSTAT",208,0)
 ;
"RTN","HLOSTAT",209,0)
LINE(LINE) ;Prints a line.
"RTN","HLOSTAT",210,0)
 ;
"RTN","HLOSTAT",211,0)
 I CRT,($Y>(IOSL-4)) D
"RTN","HLOSTAT",212,0)
 .D PAUSE
"RTN","HLOSTAT",213,0)
 .Q:QUIT
"RTN","HLOSTAT",214,0)
 .W @IOF
"RTN","HLOSTAT",215,0)
 .W LINE
"RTN","HLOSTAT",216,0)
 ;
"RTN","HLOSTAT",217,0)
 E  I ('CRT),($Y>(IOSL-2)) D
"RTN","HLOSTAT",218,0)
 .W @IOF
"RTN","HLOSTAT",219,0)
 .W ?70,"Page: ",PAGE
"RTN","HLOSTAT",220,0)
 .S PAGE=PAGE+1
"RTN","HLOSTAT",221,0)
 .W LINE
"RTN","HLOSTAT",222,0)
 ;
"RTN","HLOSTAT",223,0)
 E  W !,LINE
"RTN","HLOSTAT",224,0)
 Q
"RTN","HLOSTAT",225,0)
 ;
"RTN","HLOSTAT",226,0)
LJ(STRING,LEN) ;
"RTN","HLOSTAT",227,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOSTAT",228,0)
RJ(STRING,LEN) ;
"RTN","HLOSTAT",229,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOTCP")
0^29^B45604114^B45043587
"RTN","HLOTCP",1,0)
HLOTCP ;ALB/CJM- TCP/IP I/O - 10/4/94 1pm ;03/22/2007
"RTN","HLOTCP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131,134**;Oct 13, 1995;Build 30
"RTN","HLOTCP",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOTCP",4,0)
 ;
"RTN","HLOTCP",5,0)
OPEN(HLCSTATE,LOGICAL) ;
"RTN","HLOTCP",6,0)
 ;This may be called either in the context of a client or a server.
"RTN","HLOTCP",7,0)
 ;For the server, there are 3 situations:
"RTN","HLOTCP",8,0)
 ; 1) The server is not concurrent.  In this case the TCP device should be opened.
"RTN","HLOTCP",9,0)
 ; 2) The server is concurrent, but this process was spawned by the OS
"RTN","HLOTCP",10,0)
 ;    (via a VMS TCP Service)  In this case, the device should be opened
"RTN","HLOTCP",11,0)
 ;    via the LOGICAL that was passed in.
"RTN","HLOTCP",12,0)
 ;  3) The server is concurrent, but this process was spawned by the
"RTN","HLOTCP",13,0)
 ;     TaskMan multi-listener.  In this case TaskMan already opened the
"RTN","HLOTCP",14,0)
 ;     device.  This case can be determined by the absence of the LOGICAL
"RTN","HLOTCP",15,0)
 ;     input parameter.
"RTN","HLOTCP",16,0)
 ;
"RTN","HLOTCP",17,0)
 N IP,PORT,DNSFLAG
"RTN","HLOTCP",18,0)
 ;
"RTN","HLOTCP",19,0)
 S DNSFLAG=0 ;DNS has not been contacted for IP
"RTN","HLOTCP",20,0)
 ;
"RTN","HLOTCP",21,0)
 S:'$G(HLCSTATE("SERVER")) IP=HLCSTATE("LINK","IP")
"RTN","HLOTCP",22,0)
 S PORT=HLCSTATE("LINK","PORT")
"RTN","HLOTCP",23,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOTCP",24,0)
 S HLCSTATE("READ HEADER")="READHDR^HLOTCP"
"RTN","HLOTCP",25,0)
 S HLCSTATE("WRITE HEADER")="WRITEHDR^HLOTCP"
"RTN","HLOTCP",26,0)
 S HLCSTATE("READ SEGMENT")="READSEG^HLOTCP"
"RTN","HLOTCP",27,0)
 S HLCSTATE("WRITE SEGMENT")="WRITESEG^HLOTCP"
"RTN","HLOTCP",28,0)
 S HLCSTATE("END MESSAGE")="ENDMSG^HLOTCP"
"RTN","HLOTCP",29,0)
 S HLCSTATE("CLOSE")="CLOSE^HLOTCP"
"RTN","HLOTCP",30,0)
 ;
"RTN","HLOTCP",31,0)
 ;spawned by TaskMan multi-listener? If so, the device has already been opened
"RTN","HLOTCP",32,0)
 I $G(HLCSTATE("SERVER")),$G(HLCSTATE("LINK","SERVER"))="1^M",$G(LOGICAL)="" D  Q
"RTN","HLOTCP",33,0)
 .S HLCSTATE("DEVICE")=IO(0),HLCSTATE("FLUSH")="!",HLCSTATE("TCP BUFFER SIZE")=510
"RTN","HLOTCP",34,0)
 .S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",35,0)
 ;
"RTN","HLOTCP",36,0)
 ;if no IP, not a server, give DNS a shot
"RTN","HLOTCP",37,0)
 I '$G(HLCSTATE("SERVER")),IP="" S DNSFLAG=1,IP=$$DNS(HLCSTATE("LINK","DOMAIN")),HLCSTATE("LINK","IP")=IP Q:IP=""
"RTN","HLOTCP",38,0)
 ;
"RTN","HLOTCP",39,0)
RETRY I HLCSTATE("SYSTEM","OS")="DSM" D
"RTN","HLOTCP",40,0)
 .S HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",41,0)
 .I $G(LOGICAL)]"" S HLCSTATE("DEVICE")=LOGICAL
"RTN","HLOTCP",42,0)
 .E  S HLCSTATE("DEVICE")=PORT
"RTN","HLOTCP",43,0)
 .S HLCSTATE("FLUSH")="!"
"RTN","HLOTCP",44,0)
 .I $G(HLCSTATE("SERVER")) D
"RTN","HLOTCP",45,0)
 ..O:$G(LOGICAL)]"" HLCSTATE("DEVICE"):(TCPDEV,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",46,0)
 ..O:$G(LOGICAL)="" HLCSTATE("DEVICE"):(TCPCHAN,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",47,0)
 ..I $T D
"RTN","HLOTCP",48,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",49,0)
 ...U HLCSTATE("DEVICE"):NOECHO
"RTN","HLOTCP",50,0)
 .E  D  ;client
"RTN","HLOTCP",51,0)
 ..O HLCSTATE("DEVICE"):(TCPCHAN,ADDRESS=IP,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",52,0)
 ..I $T D
"RTN","HLOTCP",53,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",54,0)
 ...U HLCSTATE("DEVICE"):NOECHO
"RTN","HLOTCP",55,0)
 E  I HLCSTATE("SYSTEM","OS")="CACHE" D
"RTN","HLOTCP",56,0)
 .S HLCSTATE("FLUSH")="!"
"RTN","HLOTCP",57,0)
 .I $G(LOGICAL)]"" S HLCSTATE("DEVICE")=LOGICAL
"RTN","HLOTCP",58,0)
 .E  S HLCSTATE("DEVICE")="|TCP|"_PORT
"RTN","HLOTCP",59,0)
 .S HLCSTATE("TCP BUFFER SIZE")=510
"RTN","HLOTCP",60,0)
 .I $G(HLCSTATE("SERVER")) D
"RTN","HLOTCP",61,0)
 ..I HLCSTATE("SERVER")="1^S" D  Q
"RTN","HLOTCP",62,0)
 ...;single server (no concurrent connections)
"RTN","HLOTCP",63,0)
 ...O HLCSTATE("DEVICE"):(:PORT:"+A-S":::):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",64,0)
 ...I $T D
"RTN","HLOTCP",65,0)
 ....N A
"RTN","HLOTCP",66,0)
 ....S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",67,0)
 ....U HLCSTATE("DEVICE")
"RTN","HLOTCP",68,0)
 ....F  R *A:HLCSTATE("READ TIMEOUT") Q:$T  I $$CHKSTOP^HLOPROC S HLCSTATE("CONNECTED")=0 D CLOSE(.HLCSTATE) Q
"RTN","HLOTCP",69,0)
 ..;
"RTN","HLOTCP",70,0)
 ..;multi-server spawned by OS - VMS TCP Services
"RTN","HLOTCP",71,0)
 ..O HLCSTATE("DEVICE")::HLCSTATE("OPEN TIMEOUT") I '$T S HLCSTATE("CONNECTED")=0 Q
"RTN","HLOTCP",72,0)
 ..S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",73,0)
 ..U HLCSTATE("DEVICE"):(::"-S")
"RTN","HLOTCP",74,0)
 ..;
"RTN","HLOTCP",75,0)
 .E  D  ;client
"RTN","HLOTCP",76,0)
 ..S HLCSTATE("TCP BUFFER SIZE")=510
"RTN","HLOTCP",77,0)
 ..O HLCSTATE("DEVICE"):(IP:PORT:"-S":::):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",78,0)
 ..I $T D
"RTN","HLOTCP",79,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",80,0)
 E  D  ;any other system but Cache or DSM
"RTN","HLOTCP",81,0)
 .S HLCSTATE("TCP BUFFER SIZE")=256
"RTN","HLOTCP",82,0)
 .D CALL^%ZISTCP(IP,PORT,HLCSTATE("OPEN TIMEOUT"))
"RTN","HLOTCP",83,0)
 .S HLCSTATE("CONNECTED")='POP
"RTN","HLOTCP",84,0)
 .I HLCSTATE("CONNECTED") S HLCSTATE("DEVICE")=IO
"RTN","HLOTCP",85,0)
 ;
"RTN","HLOTCP",86,0)
 ;if not connected, not the server, give DNS a shot if not tried already
"RTN","HLOTCP",87,0)
 I '$G(HLCSTATE("SERVER")),'HLCSTATE("CONNECTED"),'DNSFLAG S DNSFLAG=1,IP=$$DNS(HLCSTATE("LINK","DOMAIN")) I IP]"",IP'=HLCSTATE("LINK","IP") S HLCSTATE("LINK","IP")=IP G RETRY
"RTN","HLOTCP",88,0)
 I HLCSTATE("CONNECTED"),DNSFLAG S $P(^HLCS(870,HLCSTATE("LINK","IEN"),400),"^")=IP
"RTN","HLOTCP",89,0)
 Q
"RTN","HLOTCP",90,0)
 ;
"RTN","HLOTCP",91,0)
DNS(DOMAIN) ;
"RTN","HLOTCP",92,0)
 Q $P($$ADDRESS^XLFNSLK(DOMAIN),",")
"RTN","HLOTCP",93,0)
 ;
"RTN","HLOTCP",94,0)
WRITEHDR(HLCSTATE,HDR) ;
"RTN","HLOTCP",95,0)
 ;
"RTN","HLOTCP",96,0)
 ;insure that package buffer is empty
"RTN","HLOTCP",97,0)
 K HLCSTATE("BUFFER")
"RTN","HLOTCP",98,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0
"RTN","HLOTCP",99,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0
"RTN","HLOTCP",100,0)
 S HLCSTATE("FIRST WRITE")=1 ;so that FLUSH knows $X should be 0
"RTN","HLOTCP",101,0)
 ;
"RTN","HLOTCP",102,0)
 ;Start the message with <SB>, then write the header
"RTN","HLOTCP",103,0)
 N SEG
"RTN","HLOTCP",104,0)
 S SEG(1)=$C(11)_HDR(1)
"RTN","HLOTCP",105,0)
 S SEG(2)=HDR(2)
"RTN","HLOTCP",106,0)
 Q $$WRITESEG(.HLCSTATE,.SEG)
"RTN","HLOTCP",107,0)
 ;
"RTN","HLOTCP",108,0)
WRITESEG(HLCSTATE,SEG) ;
"RTN","HLOTCP",109,0)
 N I,LAST
"RTN","HLOTCP",110,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=HLCSTATE("BUFFER","SEGMENT COUNT")+1
"RTN","HLOTCP",111,0)
 S I=0,LAST=$O(SEG(99999),-1)
"RTN","HLOTCP",112,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOTCP",113,0)
 .I HLCSTATE("BUFFER","BYTE COUNT")>HLCSTATE("SYSTEM","BUFFER") D FLUSH
"RTN","HLOTCP",114,0)
 .I I=LAST S SEG(I)=SEG(I)_$C(13)
"RTN","HLOTCP",115,0)
 .S HLCSTATE("BUFFER",HLCSTATE("BUFFER","SEGMENT COUNT"),I)=SEG(I),HLCSTATE("BUFFER","BYTE COUNT")=HLCSTATE("BUFFER","BYTE COUNT")+$L(SEG(I))+20
"RTN","HLOTCP",116,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOTCP",117,0)
 ;
"RTN","HLOTCP",118,0)
FLUSH ;flushes the HL7 package buffer, and the system TCP buffer when full
"RTN","HLOTCP",119,0)
 N SEGMENT,MAX
"RTN","HLOTCP",120,0)
 S SEGMENT=0
"RTN","HLOTCP",121,0)
 S MAX=HLCSTATE("TCP BUFFER SIZE")
"RTN","HLOTCP",122,0)
 U HLCSTATE("DEVICE") I (HLCSTATE("SYSTEM","OS")="CACHE") S HLCSTATE("CONNECTED")=($ZA\8192#2) I 'HLCSTATE("CONNECTED") D CLOSE(.HLCSTATE)
"RTN","HLOTCP",123,0)
 F  S SEGMENT=$O(HLCSTATE("BUFFER",SEGMENT)) Q:'SEGMENT  D
"RTN","HLOTCP",124,0)
 .N I S I=0
"RTN","HLOTCP",125,0)
 .F  S I=$O(HLCSTATE("BUFFER",SEGMENT,I)) Q:'I  D
"RTN","HLOTCP",126,0)
 ..N LINE,J
"RTN","HLOTCP",127,0)
 ..S J=$S(HLCSTATE("FIRST WRITE"):0,1:$X)
"RTN","HLOTCP",128,0)
 ..S HLCSTATE("FIRST WRITE")=0
"RTN","HLOTCP",129,0)
 ..S LINE=HLCSTATE("BUFFER",SEGMENT,I)
"RTN","HLOTCP",130,0)
 ..F  Q:'(J+$L(LINE)>MAX)  D
"RTN","HLOTCP",131,0)
 ...W $E(LINE,1,MAX-J),@HLCSTATE("FLUSH")
"RTN","HLOTCP",132,0)
 ...S LINE=$E(LINE,(MAX-J)+1,99999)
"RTN","HLOTCP",133,0)
 ...S J=0
"RTN","HLOTCP",134,0)
 ..W:(LINE]"") LINE
"RTN","HLOTCP",135,0)
 K HLCSTATE("BUFFER")
"RTN","HLOTCP",136,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=1
"RTN","HLOTCP",137,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0
"RTN","HLOTCP",138,0)
 S HLCSTATE("FIRST WRITE")=0
"RTN","HLOTCP",139,0)
 Q
"RTN","HLOTCP",140,0)
 ;
"RTN","HLOTCP",141,0)
READSEG(HLCSTATE,SEG) ;
"RTN","HLOTCP",142,0)
 ;
"RTN","HLOTCP",143,0)
 ;Output:
"RTN","HLOTCP",144,0)
 ;  SEG - returns the segment (pass by reference)
"RTN","HLOTCP",145,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOTCP",146,0)
 ;
"RTN","HLOTCP",147,0)
 N SUCCESS,COUNT,BUF
"RTN","HLOTCP",148,0)
 S (COUNT,SUCCESS)=0
"RTN","HLOTCP",149,0)
 K SEG
"RTN","HLOTCP",150,0)
 ;
"RTN","HLOTCP",151,0)
 ;anything left from last read?
"RTN","HLOTCP",152,0)
 S BUF=HLCSTATE("READ")
"RTN","HLOTCP",153,0)
 S HLCSTATE("READ")=""
"RTN","HLOTCP",154,0)
 I BUF]"" D  ;something was left!
"RTN","HLOTCP",155,0)
 .S COUNT=1
"RTN","HLOTCP",156,0)
 .I BUF[$C(13) D  Q
"RTN","HLOTCP",157,0)
 ..S SEG(1)=$P(BUF,$C(13)),BUF=$P(BUF,$C(13),2,9999)
"RTN","HLOTCP",158,0)
 ..S SUCCESS=1
"RTN","HLOTCP",159,0)
 .S SEG(1)=BUF,BUF=""
"RTN","HLOTCP",160,0)
 I 'SUCCESS U HLCSTATE("DEVICE") F  R BUF:HLCSTATE("READ TIMEOUT") Q:'$T  D  Q:SUCCESS
"RTN","HLOTCP",161,0)
 .I BUF[$C(13) S SUCCESS=1,COUNT=COUNT+1,SEG(COUNT)=$P(BUF,$C(13)),BUF=$P(BUF,$C(13),2,9999) Q
"RTN","HLOTCP",162,0)
 .S COUNT=COUNT+1,SEG(COUNT)=BUF
"RTN","HLOTCP",163,0)
 ;
"RTN","HLOTCP",164,0)
 I SUCCESS D
"RTN","HLOTCP",165,0)
 .S HLCSTATE("READ")=BUF ;save the leftover
"RTN","HLOTCP",166,0)
 .I COUNT>1,SEG(COUNT)="" K SEG(COUNT) S COUNT=COUNT-1
"RTN","HLOTCP",167,0)
 ;Cache can return the connection status
"RTN","HLOTCP",168,0)
 E  I (HLCSTATE("SYSTEM","OS")="CACHE") S HLCSTATE("CONNECTED")=($ZA\8192#2) I 'HLCSTATE("CONNECTED") D CLOSE(.HLCSTATE)
"RTN","HLOTCP",169,0)
 ;
"RTN","HLOTCP",170,0)
 ;if the <EB> character was encountered, then there are no more segments in the message, set the end of message flag
"RTN","HLOTCP",171,0)
 I SUCCESS,SEG(COUNT)[$C(28) D
"RTN","HLOTCP",172,0)
 .K SEG
"RTN","HLOTCP",173,0)
 .S SUCCESS=0
"RTN","HLOTCP",174,0)
 .S HLCSTATE("MESSAGE ENDED")=1
"RTN","HLOTCP",175,0)
 Q SUCCESS
"RTN","HLOTCP",176,0)
 ;
"RTN","HLOTCP",177,0)
READHDR(HLCSTATE,HDR) ;
"RTN","HLOTCP",178,0)
 ;reads the next header segment in the message stream, discarding everything that comes before it
"RTN","HLOTCP",179,0)
 ;
"RTN","HLOTCP",180,0)
 N SEG,SUCCESS,J,I
"RTN","HLOTCP",181,0)
 S SUCCESS=0
"RTN","HLOTCP",182,0)
 K HDR
"RTN","HLOTCP",183,0)
 F  Q:'$$READSEG(.HLCSTATE,.SEG)  D  Q:SUCCESS
"RTN","HLOTCP",184,0)
 .S I=0
"RTN","HLOTCP",185,0)
 .;look for the <SB>
"RTN","HLOTCP",186,0)
 .;perhaps the <SB> isn't in the first line
"RTN","HLOTCP",187,0)
 .F  S I=$O(SEG(I)) Q:'I  D  Q:SUCCESS
"RTN","HLOTCP",188,0)
 ..I (SEG(I)'[$C(11)) K SEG(I) Q
"RTN","HLOTCP",189,0)
 ..S SEG(I)=$P(SEG(I),$C(11),2)
"RTN","HLOTCP",190,0)
 ..S SUCCESS=1
"RTN","HLOTCP",191,0)
 ..K:SEG(I)="" SEG(I)
"RTN","HLOTCP",192,0)
 I SUCCESS S (I,J)=0 F  S J=$O(SEG(J)) Q:'J  S I=I+1,HDR(I)=SEG(J)
"RTN","HLOTCP",193,0)
 Q SUCCESS
"RTN","HLOTCP",194,0)
 ;
"RTN","HLOTCP",195,0)
CLOSE(HLCSTATE) ;
"RTN","HLOTCP",196,0)
 CLOSE HLCSTATE("DEVICE")
"RTN","HLOTCP",197,0)
 Q
"RTN","HLOTCP",198,0)
 ;
"RTN","HLOTCP",199,0)
ENDMSG(HLCSTATE)        ;
"RTN","HLOTCP",200,0)
 N SEG
"RTN","HLOTCP",201,0)
 S SEG(1)=$C(28)
"RTN","HLOTCP",202,0)
 I $$WRITESEG(.HLCSTATE,.SEG) D  Q 1
"RTN","HLOTCP",203,0)
 .D FLUSH
"RTN","HLOTCP",204,0)
 .U HLCSTATE("DEVICE")
"RTN","HLOTCP",205,0)
 .W:$X @HLCSTATE("FLUSH")
"RTN","HLOTCP",206,0)
 Q 0
"RTN","HLOUSR")
0^6^B88986165^B88410850
"RTN","HLOUSR",1,0)
HLOUSR ;ALB/CJM -ListManager Screen for viewing system status;12 JUN 1997 10:00 am ;02/07/2007
"RTN","HLOUSR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,134**;Oct 13, 1995;Build 30
"RTN","HLOUSR",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR",4,0)
 ;
"RTN","HLOUSR",5,0)
EN ;
"RTN","HLOUSR",6,0)
 ;
"RTN","HLOUSR",7,0)
 N HLSCREEN,TESTOPEN,HLRFRSH
"RTN","HLOUSR",8,0)
 D WAIT^DICD
"RTN","HLOUSR",9,0)
 D EN^VALM("HLO SYSTEM MONITOR")
"RTN","HLOUSR",10,0)
 Q
"RTN","HLOUSR",11,0)
 ;
"RTN","HLOUSR",12,0)
BRIEF ;Init variables and list array
"RTN","HLOUSR",13,0)
 N COUNT,LINK,QUE,FROM,TIME,STATUS,TEMP,DIR,TODAY,LIST
"RTN","HLOUSR",14,0)
 S HLRFRSH="BRIEF^HLOUSR"
"RTN","HLOUSR",15,0)
 S (HLSCREEN,VALMSG)="Brief System Status"
"RTN","HLOUSR",16,0)
 S VALMCNT=8
"RTN","HLOUSR",17,0)
 ;K @VALMAR
"RTN","HLOUSR",18,0)
 D CLEAN^VALM10
"RTN","HLOUSR",19,0)
 S VALMBG=1
"RTN","HLOUSR",20,0)
 S VALMBCK="R"
"RTN","HLOUSR",21,0)
 K VALMDDF("COL 2"),VALMDDF("COL 3"),VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",22,0)
 D CHGCAP^VALM("COL 1","Brief Operational Overview")
"RTN","HLOUSR",23,0)
 S @VALMAR@(1,0)="SYSTEM STATUS:             "_$S($$CHKSTOP^HLOPROC:"STOPPED",1:"RUNNING")
"RTN","HLOUSR",24,0)
 S @VALMAR@(2,0)="PROCESS MANAGER:           "_$S($$RUNNING:"RUNNING",1:"STOPPED")
"RTN","HLOUSR",25,0)
 ;
"RTN","HLOUSR",26,0)
 S TIME=$P($G(TESTOPEN("LISTENER")),"^",2)
"RTN","HLOUSR",27,0)
 I TIME,$$FMDIFF^XLFDT($$NOW^XLFDT,TIME,2)<300 D
"RTN","HLOUSR",28,0)
 .S STATUS=+TESTOPEN("LISTENER")
"RTN","HLOUSR",29,0)
 E  D
"RTN","HLOUSR",30,0)
 .S STATUS=0
"RTN","HLOUSR",31,0)
 .S LINK=$P($G(^HLD(779.1,1,0)),"^",10)
"RTN","HLOUSR",32,0)
 .I LINK S LINK=$P($G(^HLCS(870,LINK,0)),"^") Q:'$L(LINK)  S STATUS=$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOUSR",33,0)
 .S TESTOPEN("LISTENER")=STATUS_"^"_$$NOW^XLFDT
"RTN","HLOUSR",34,0)
 ;
"RTN","HLOUSR",35,0)
 S @VALMAR@(3,0)="STANDARD LISTENER:         "_$S(STATUS:"OPERATIONAL",1:"NOT OPERATIONAL")
"RTN","HLOUSR",36,0)
 ;
"RTN","HLOUSR",37,0)
 S @VALMAR@(4,0)="TASKMAN:                   "_$S($$TM^%ZTLOAD:"RUNNING",1:"NOT RUNNING")
"RTN","HLOUSR",38,0)
 ;
"RTN","HLOUSR",39,0)
 S (LIST,LINK)=""
"RTN","HLOUSR",40,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D  I $L(LIST)>60 S LIST=LIST_",..." Q
"RTN","HLOUSR",41,0)
 .N TIME,QUE,LINKARY
"RTN","HLOUSR",42,0)
 .I $$GETLINK^HLOTLNK($P(LINK,":"),.LINKARY)
"RTN","HLOUSR",43,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOUSR",44,0)
 .I '$G(LINKARY("SHUTDOWN")),TIME="" Q
"RTN","HLOUSR",45,0)
 .I '$G(LINKARY("SHUTDOWN")),($$HDIFF^XLFDT($H,TIME,2)<300) Q
"RTN","HLOUSR",46,0)
 .S LIST=LIST_$S($L(LIST):", ",1:"")_$P(LINK,":")
"RTN","HLOUSR",47,0)
 S @VALMAR@(5,0)="DOWN LINKS: "_LIST
"RTN","HLOUSR",48,0)
 S @VALMAR@(6,0)="CLIENT LINK PROCESSES:     "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","OUTGOING CLIENT LINK"))
"RTN","HLOUSR",49,0)
 S @VALMAR@(7,0)="IN-FILER PROCESSES:        "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","INCOMING QUEUES"))
"RTN","HLOUSR",50,0)
 S COUNT=0,LINK=""
"RTN","HLOUSR",51,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOUSR",52,0)
 .S QUE=""
"RTN","HLOUSR",53,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOUSR",54,0)
 ..S TEMP=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE))
"RTN","HLOUSR",55,0)
 ..S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",56,0)
 S @VALMAR@(8,0)="MESSAGES PENDING TRANSMISSION:      "_+COUNT
"RTN","HLOUSR",57,0)
 S TEMP="STOPPED OUTGOING QUEUES: "
"RTN","HLOUSR",58,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",59,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","OUT",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",60,0)
 S @VALMAR@(9,0)=TEMP
"RTN","HLOUSR",61,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",62,0)
 F  S QUE=$O(^HLC("QUEUECOUNT","IN",QUE)) Q:QUE=""  D
"RTN","HLOUSR",63,0)
 .S FROM=""
"RTN","HLOUSR",64,0)
 .F  S FROM=$O(^HLC("QUEUECOUNT","IN",QUE,FROM)) Q:FROM=""  D
"RTN","HLOUSR",65,0)
 ..S TEMP=$G(^HLC("QUEUECOUNT","IN",QUE,FROM))
"RTN","HLOUSR",66,0)
 ..S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",67,0)
 S @VALMAR@(10,0)="MESSAGES PENDING ON APPLICATIONS:   "_+COUNT
"RTN","HLOUSR",68,0)
 S TEMP="STOPPED INCOMING QUEUES: "
"RTN","HLOUSR",69,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",70,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","IN",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",71,0)
 S @VALMAR@(11,0)=TEMP
"RTN","HLOUSR",72,0)
 S @VALMAR@(12,0)="FILE 777 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^",2))
"RTN","HLOUSR",73,0)
 S @VALMAR@(13,0)="FILE 778 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^",2))
"RTN","HLOUSR",74,0)
 S TODAY=$$DT^XLFDT
"RTN","HLOUSR",75,0)
 S @VALMAR@(14,0)="MESSAGES SENT TODAY:           "_$$RJ($$ADD("OUT"),10)
"RTN","HLOUSR",76,0)
 S @VALMAR@(15,0)="MESSAGES RECEIVED TODAY:       "_$$RJ($$ADD("IN"),10)
"RTN","HLOUSR",77,0)
 S @VALMAR@(16,0)="MESSAGE ERRORS TODAY:          "_$$RJ($$ADD("EOUT")+$$ADD("EIN"),10)
"RTN","HLOUSR",78,0)
 Q
"RTN","HLOUSR",79,0)
ADD(DIR) ;
"RTN","HLOUSR",80,0)
 N RAP,SAP,TIME,TOTAL
"RTN","HLOUSR",81,0)
 S TOTAL=0
"RTN","HLOUSR",82,0)
 S TIME=TODAY-.0001
"RTN","HLOUSR",83,0)
 F  S TIME=$O(^HLSTATS(DIR,"HOURLY",TIME)) Q:'TIME  Q:((TIME\1)>TODAY)  D
"RTN","HLOUSR",84,0)
 .S SAP=""
"RTN","HLOUSR",85,0)
 .F  S SAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP)) Q:SAP=""  D
"RTN","HLOUSR",86,0)
 ..Q:SAP="ACCEPT ACK"
"RTN","HLOUSR",87,0)
 ..S RAP=""
"RTN","HLOUSR",88,0)
 ..F  S RAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP)) Q:RAP=""  D
"RTN","HLOUSR",89,0)
 ...S TYPE=""
"RTN","HLOUSR",90,0)
 ...F  S TYPE=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOUSR",91,0)
 ....S TOTAL=TOTAL+$G(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE))
"RTN","HLOUSR",92,0)
 Q TOTAL
"RTN","HLOUSR",93,0)
 ;
"RTN","HLOUSR",94,0)
HELP ;Help code
"RTN","HLOUSR",95,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLOUSR",96,0)
 Q
"RTN","HLOUSR",97,0)
 ;
"RTN","HLOUSR",98,0)
EXIT ;Exit code
"RTN","HLOUSR",99,0)
 D CLEAN^VALM10
"RTN","HLOUSR",100,0)
 D CLEAR^VALM1
"RTN","HLOUSR",101,0)
 ;
"RTN","HLOUSR",102,0)
 Q
"RTN","HLOUSR",103,0)
 ;
"RTN","HLOUSR",104,0)
EXPND ;Expand code
"RTN","HLOUSR",105,0)
 Q
"RTN","HLOUSR",106,0)
 ;
"RTN","HLOUSR",107,0)
PROCS ;
"RTN","HLOUSR",108,0)
 S HLRFRSH="PROCS^HLOUSR"
"RTN","HLOUSR",109,0)
 ;K @VALMAR
"RTN","HLOUSR",110,0)
 D CLEAN^VALM10
"RTN","HLOUSR",111,0)
 S VALMCNT=0
"RTN","HLOUSR",112,0)
 S VALMBCK="R"
"RTN","HLOUSR",113,0)
 S VALMDDF("COL 2")="COL 2^35^10^MIN^H"
"RTN","HLOUSR",114,0)
 S VALMDDF("COL 3")="COL 3^47^10^MAX^H"
"RTN","HLOUSR",115,0)
 S VALMDDF("COL 4")="COL 4^59^10^#RUNNING^H"
"RTN","HLOUSR",116,0)
 S VALMDDF("COL 5")="COL 5^71^10^#QUEUED^IOBON"
"RTN","HLOUSR",117,0)
 D CHGCAP^VALM("COL 1","Process Type")
"RTN","HLOUSR",118,0)
 N IEN
"RTN","HLOUSR",119,0)
 S IEN=0
"RTN","HLOUSR",120,0)
 F  S IEN=$O(^HLD(779.3,"C",1,IEN)) Q:'IEN  D
"RTN","HLOUSR",121,0)
 .N PROC
"RTN","HLOUSR",122,0)
 .Q:'$$GETPROC^HLOPROC1(IEN,.PROC)
"RTN","HLOUSR",123,0)
 .Q:PROC("NAME")="VMS TCP LISTENER"
"RTN","HLOUSR",124,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",125,0)
 .S @VALMAR@(VALMCNT,0)=$$LJ(PROC("NAME"),30)_$$RJ(PROC("MINIMUM"),6)_$$RJ(PROC("MAXIMUM"),12)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC("NAME"))),14)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC("NAME"))),12)
"RTN","HLOUSR",126,0)
 S VALMCNT=VALMCNT+1,@VALMAR@(VALMCNT,0)=""
"RTN","HLOUSR",127,0)
 S IEN=""
"RTN","HLOUSR",128,0)
 F  S IEN=$O(^HLTMP("HL7 RUNNING PROCESSES",IEN)) Q:IEN=""  D
"RTN","HLOUSR",129,0)
 .N NODE
"RTN","HLOUSR",130,0)
 .S NODE=$G(^HLTMP("HL7 RUNNING PROCESSES",IEN))
"RTN","HLOUSR",131,0)
 .Q:NODE=""
"RTN","HLOUSR",132,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",133,0)
 .S @VALMAR@(VALMCNT,0)="$J: "_$$LJ(IEN,9)_" ->"_$$CJ($P(NODE,"^",3),28)_"<- started at "_$$HTE^XLFDT($P(NODE,"^"))
"RTN","HLOUSR",134,0)
 Q
"RTN","HLOUSR",135,0)
 ;
"RTN","HLOUSR",136,0)
OUTQUEUE ;
"RTN","HLOUSR",137,0)
 N LINK
"RTN","HLOUSR",138,0)
 D CLEAN^VALM10
"RTN","HLOUSR",139,0)
 ;K @VALMAR
"RTN","HLOUSR",140,0)
 S HLRFRSH="OUTQUEUE^HLOUSR"
"RTN","HLOUSR",141,0)
 S (HLSCREEN,VALMSG)="Outgoing Queues *down links !stopped queues"
"RTN","HLOUSR",142,0)
 S VALMCNT=0
"RTN","HLOUSR",143,0)
 S VALMBCK="R"
"RTN","HLOUSR",144,0)
 S VALMDDF("COL 1")="COL 1^2^20^ Link^H"
"RTN","HLOUSR",145,0)
 S VALMDDF("COL 2")="COL 2^28^20^Queue^H"
"RTN","HLOUSR",146,0)
 S VALMDDF("COL 3")="COL 3^50^20^Count^H"
"RTN","HLOUSR",147,0)
 K VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",148,0)
 D CHGCAP^VALM("COL 1"," Link")
"RTN","HLOUSR",149,0)
 S LINK=""
"RTN","HLOUSR",150,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOUSR",151,0)
 .N COUNT,QUE,SHOW
"RTN","HLOUSR",152,0)
 .S SHOW=LINK
"RTN","HLOUSR",153,0)
 .I $D(^HLTMP("FAILING LINKS",SHOW)) S SHOW="*"_SHOW
"RTN","HLOUSR",154,0)
 .S QUE=""
"RTN","HLOUSR",155,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOUSR",156,0)
 ..S COUNT=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE))
"RTN","HLOUSR",157,0)
 ..Q:COUNT<1
"RTN","HLOUSR",158,0)
 ..S VALMCNT=VALMCNT+1
"RTN","HLOUSR",159,0)
 ..I $E(SHOW)="*" D
"RTN","HLOUSR",160,0)
 ...S @VALMAR@(VALMCNT,0)=$$LJ(SHOW,20)_$$CJ($S($$STOPPED^HLOQUE("OUT",QUE):"!",1:"")_QUE,21)_"   "_$$RJ(COUNT,10),SHOW=""
"RTN","HLOUSR",161,0)
 ...D CNTRL^VALM10(VALMCNT,1,1,IOBON,IOBOFF)
"RTN","HLOUSR",162,0)
 ..E  S @VALMAR@(VALMCNT,0)=$$LJ(SHOW,20)_$$CJ($S($$STOPPED^HLOQUE("OUT",QUE):"!",1:"")_QUE,21)_"   "_$$RJ(COUNT,10),SHOW=""
"RTN","HLOUSR",163,0)
 Q
"RTN","HLOUSR",164,0)
 ;
"RTN","HLOUSR",165,0)
INQUEUE ;
"RTN","HLOUSR",166,0)
 N FROM
"RTN","HLOUSR",167,0)
 D CLEAN^VALM10
"RTN","HLOUSR",168,0)
 ;K @VALMAR
"RTN","HLOUSR",169,0)
 S HLRFRSH="INQUEUE^HLOUSR"
"RTN","HLOUSR",170,0)
 S (HLSCREEN,VALMSG)="Incoming Queues ('!' = stopped queues)"
"RTN","HLOUSR",171,0)
 S VALMCNT=0
"RTN","HLOUSR",172,0)
 S VALMBCK="R"
"RTN","HLOUSR",173,0)
 S VALMDDF("COL 1")="COL 1^1^40^ From^H"
"RTN","HLOUSR",174,0)
 S VALMDDF("COL 2")="COL 2^45^20^Queue^H"
"RTN","HLOUSR",175,0)
 S VALMDDF("COL 3")="COL 3^70^10^Count^H"
"RTN","HLOUSR",176,0)
 K VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",177,0)
 D CHGCAP^VALM("COL 1"," From")
"RTN","HLOUSR",178,0)
 S FROM=""
"RTN","HLOUSR",179,0)
 F  S FROM=$O(^HLC("QUEUECOUNT","IN",FROM)) Q:FROM=""  D
"RTN","HLOUSR",180,0)
 .N COUNT,QUE,SHOW
"RTN","HLOUSR",181,0)
 .S SHOW=$$LJ(FROM,40)_"  "
"RTN","HLOUSR",182,0)
 .S QUE=""
"RTN","HLOUSR",183,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","IN",FROM,QUE)) Q:QUE=""  D
"RTN","HLOUSR",184,0)
 ..S COUNT=$G(^HLC("QUEUECOUNT","IN",FROM,QUE))
"RTN","HLOUSR",185,0)
 ..Q:COUNT<0
"RTN","HLOUSR",186,0)
 ..S VALMCNT=VALMCNT+1
"RTN","HLOUSR",187,0)
 ..S @VALMAR@(VALMCNT,0)=SHOW_$$LJ($S($$STOPPED^HLOQUE("IN",QUE):"!",1:"")_QUE,21)_" "_$$RJ(COUNT,10)
"RTN","HLOUSR",188,0)
 ..S SHOW=$$LJ("",40)_"  "
"RTN","HLOUSR",189,0)
 Q
"RTN","HLOUSR",190,0)
VIEWLINK ;
"RTN","HLOUSR",191,0)
 N C,QUIT,LINK,LINKARY,TEMP
"RTN","HLOUSR",192,0)
 S (QUIT,C,LINK)=""
"RTN","HLOUSR",193,0)
 S VALMBCK="R"
"RTN","HLOUSR",194,0)
 ;
"RTN","HLOUSR",195,0)
 ;currently HL7 (Optimized) only does TCP, when serial added a change is needed here
"RTN","HLOUSR",196,0)
 S LINK=$$ASKLINK
"RTN","HLOUSR",197,0)
 Q:LINK=""
"RTN","HLOUSR",198,0)
 Q:'$$GETLINK^HLOTLNK(LINK,.LINKARY)
"RTN","HLOUSR",199,0)
 S LINK=LINK_":"_LINKARY("PORT")
"RTN","HLOUSR",200,0)
 W !,"Hit any key to stop...",!
"RTN","HLOUSR",201,0)
 F  D  Q:QUIT
"RTN","HLOUSR",202,0)
 .N COUNT,QUE
"RTN","HLOUSR",203,0)
 .S (COUNT,QUE)=""
"RTN","HLOUSR",204,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  S TEMP=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE)) S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",205,0)
 .W $C(13),"                             ",$C(13),"MESSAGES PENDING TRANSMISSION: ",IOBON,$$RJ(+COUNT,10),IOBOFF
"RTN","HLOUSR",206,0)
 .R *C:1 I $T S QUIT=1
"RTN","HLOUSR",207,0)
 Q
"RTN","HLOUSR",208,0)
 ;
"RTN","HLOUSR",209,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR",210,0)
 Q $$CJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",211,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR",212,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",213,0)
RJ(STRING,LEN) ;
"RTN","HLOUSR",214,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",215,0)
 ;
"RTN","HLOUSR",216,0)
RUNNING() ;Is the Process Manager running?
"RTN","HLOUSR",217,0)
 N RUNNING
"RTN","HLOUSR",218,0)
 L +^HLTMP("PROCESS MANAGER"):0
"RTN","HLOUSR",219,0)
 S RUNNING='$T
"RTN","HLOUSR",220,0)
 I 'RUNNING L -^HLTMP("PROCESS MANAGER")
"RTN","HLOUSR",221,0)
 Q RUNNING
"RTN","HLOUSR",222,0)
 ;
"RTN","HLOUSR",223,0)
TESTLINK ;
"RTN","HLOUSR",224,0)
 N LINK,LINKNAME,OK
"RTN","HLOUSR",225,0)
 S VALMBCK="R"
"RTN","HLOUSR",226,0)
 S LINKNAME=$$ASKLINK
"RTN","HLOUSR",227,0)
 Q:LINKNAME=""
"RTN","HLOUSR",228,0)
 S OK=$$IFOPEN^HLOUSR1(LINKNAME)
"RTN","HLOUSR",229,0)
 I OK W !,LINKNAME_" IS operational..."
"RTN","HLOUSR",230,0)
 E  W !,LINKNAME_" is NOT operational..."
"RTN","HLOUSR",231,0)
 W !,"Hit any key to continue..."
"RTN","HLOUSR",232,0)
 R *C:DTIME
"RTN","HLOUSR",233,0)
 Q
"RTN","HLOUSR",234,0)
 ;
"RTN","HLOUSR",235,0)
ASKLINK() ;
"RTN","HLOUSR",236,0)
 N DIC,TCP,X,Y,DTOUT,DUOUT
"RTN","HLOUSR",237,0)
 S DIC=870
"RTN","HLOUSR",238,0)
 S DIC(0)="AENQ"
"RTN","HLOUSR",239,0)
 S TCP=$O(^HLCS(869.1,"B","TCP",0))
"RTN","HLOUSR",240,0)
 S DIC("A")="Select a TCP link:"
"RTN","HLOUSR",241,0)
 S DIC("S")="I $P(^(0),U,3)=TCP"
"RTN","HLOUSR",242,0)
 D FULL^VALM1
"RTN","HLOUSR",243,0)
 D ^DIC
"RTN","HLOUSR",244,0)
 I +Y'=-1,'$D(DTOUT),'$D(DUOUT) Q $P(Y,"^",2)
"RTN","HLOUSR",245,0)
 Q ""
"RTN","HLOUSR",246,0)
 ;
"RTN","HLOUSR",247,0)
STOP ;
"RTN","HLOUSR",248,0)
 I '$$ASKYESNO^HLOUSR2("Are you SURE that you want to stop sending and receiving messages","NO") S VALMBCK="" Q
"RTN","HLOUSR",249,0)
 ;
"RTN","HLOUSR",250,0)
 D STOPHL7^HLOPROC1
"RTN","HLOUSR",251,0)
 S VALMBCK="R",VALMSG="HL7 (Optimized) has been stopped...."
"RTN","HLOUSR",252,0)
 H 5
"RTN","HLOUSR",253,0)
 D @HLRFRSH
"RTN","HLOUSR",254,0)
 ;D:HLSCREEN="Brief System Status" BRIEF^HLOUSR
"RTN","HLOUSR",255,0)
 ;D:HLSCREEN="Running Processes" PROCS^HLOUSR
"RTN","HLOUSR",256,0)
 Q
"RTN","HLOUSR",257,0)
 ;
"RTN","HLOUSR",258,0)
UPDMODE ;update mode
"RTN","HLOUSR",259,0)
 Q:'$L(HLRFRSH)
"RTN","HLOUSR",260,0)
 N QUIT,NEW,TOP,BOTTOM,DX,DY,IOTM,IOBM,I
"RTN","HLOUSR",261,0)
 W !!,IOINHI,"Hit any key to escape realtime display mode...",IOINORM
"RTN","HLOUSR",262,0)
 S IOTM=3,IOBM=23
"RTN","HLOUSR",263,0)
 W @IOSTBM
"RTN","HLOUSR",264,0)
 S DX=1,DY=$S(VALMCNT<17:VALMCNT+1,1:17) X IOXY
"RTN","HLOUSR",265,0)
 I VALMCNT>16 F I=17:1:$S(VALMCNT<22:VALMCNT,1:21) W !,@VALMAR@(I,0)
"RTN","HLOUSR",266,0)
 S QUIT=0
"RTN","HLOUSR",267,0)
 S TOP=VALMBG
"RTN","HLOUSR",268,0)
 S BOTTOM=TOP+23
"RTN","HLOUSR",269,0)
 S OLD=VALMAR
"RTN","HLOUSR",270,0)
 S VALMAR="NEW"
"RTN","HLOUSR",271,0)
 S VALMCNT=0
"RTN","HLOUSR",272,0)
 F  D  Q:QUIT
"RTN","HLOUSR",273,0)
 .N LINE
"RTN","HLOUSR",274,0)
 .R *C:3 I $T S QUIT=1
"RTN","HLOUSR",275,0)
 .S (VALMCNT,I)=0
"RTN","HLOUSR",276,0)
 .D @HLRFRSH
"RTN","HLOUSR",277,0)
 .F LINE=TOP:1:BOTTOM IF $G(@OLD@(LINE,0))'=$G(@VALMAR@(LINE,0)) D
"RTN","HLOUSR",278,0)
 ..S:'$D(@VALMAR@(LINE,0)) @VALMAR@(LINE,0)=" "
"RTN","HLOUSR",279,0)
 ..D WRITE^VALM10(LINE)
"RTN","HLOUSR",280,0)
 K @OLD M @OLD=@VALMAR S VALMAR=OLD
"RTN","HLOUSR",281,0)
 S VALMBCK="R"
"RTN","HLOUSR",282,0)
 Q
"RTN","HLOUSR1")
0^21^B71059198^B64766610
"RTN","HLOUSR1",1,0)
HLOUSR1 ;ALB/CJM -ListManager Screen for viewing messages;12 JUN 1997 10:00 am ;03/19/2007
"RTN","HLOUSR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134**;Oct 13, 1995;Build 30
"RTN","HLOUSR1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR1",4,0)
 ;
"RTN","HLOUSR1",5,0)
EN ;
"RTN","HLOUSR1",6,0)
 N MSGIEN
"RTN","HLOUSR1",7,0)
 S MSGIEN=$$PICKMSG
"RTN","HLOUSR1",8,0)
 I 'MSGIEN S VALMBCK="R" Q
"RTN","HLOUSR1",9,0)
 D EN^VALM("HLO SINGLE MESSAGE DISPLAY")
"RTN","HLOUSR1",10,0)
 Q
"RTN","HLOUSR1",11,0)
 ;
"RTN","HLOUSR1",12,0)
HDR ;
"RTN","HLOUSR1",13,0)
 Q
"RTN","HLOUSR1",14,0)
 ;
"RTN","HLOUSR1",15,0)
BLANK ;
"RTN","HLOUSR1",16,0)
 S VALMCNT=0
"RTN","HLOUSR1",17,0)
 D EXIT
"RTN","HLOUSR1",18,0)
 Q
"RTN","HLOUSR1",19,0)
DISPLAY ;
"RTN","HLOUSR1",20,0)
 K @VALMAR
"RTN","HLOUSR1",21,0)
 S VALMBCK="R"
"RTN","HLOUSR1",22,0)
 N MSG
"RTN","HLOUSR1",23,0)
 S VALMBG=1
"RTN","HLOUSR1",24,0)
 Q:'MSGIEN
"RTN","HLOUSR1",25,0)
 D SHOWMSG($P(MSGIEN,"^"),$P(MSGIEN,"^",2))
"RTN","HLOUSR1",26,0)
 Q
"RTN","HLOUSR1",27,0)
 ;
"RTN","HLOUSR1",28,0)
PICKMSG() ;
"RTN","HLOUSR1",29,0)
 ;ask the user to select a message & return its ien
"RTN","HLOUSR1",30,0)
 N MSGIEN,DIR,COUNT,LIST
"RTN","HLOUSR1",31,0)
 D FULL^VALM1
"RTN","HLOUSR1",32,0)
 S DIR(0)="F3:30"
"RTN","HLOUSR1",33,0)
 S DIR("A")="Message ID"
"RTN","HLOUSR1",34,0)
 S DIR("?")="Enter the full Message Control ID or Batch Control ID of the message, or '^' to exit."
"RTN","HLOUSR1",35,0)
PICK D ^DIR
"RTN","HLOUSR1",36,0)
 I $D(DIRUT)!(Y="") Q 0
"RTN","HLOUSR1",37,0)
 I $G(@VALMAR@("INDEX",Y)) Q $G(@VALMAR@("INDEX",Y))
"RTN","HLOUSR1",38,0)
 S COUNT=$$FINDMSG^HLOMSG1(Y,.LIST)
"RTN","HLOUSR1",39,0)
 I COUNT="0" W !!,"That message can not be found! Try Again",! G PICK
"RTN","HLOUSR1",40,0)
 I COUNT=1 Q LIST(1)
"RTN","HLOUSR1",41,0)
 I COUNT>1 D
"RTN","HLOUSR1",42,0)
 .N ITEM
"RTN","HLOUSR1",43,0)
 .W !,"There is more than one message with that ID! You must choose one to display.",1
"RTN","HLOUSR1",44,0)
 .S ITEM=0
"RTN","HLOUSR1",45,0)
 .F  S ITEM=$O(LIST(ITEM)) Q:'ITEM  D
"RTN","HLOUSR1",46,0)
 ..N MSG
"RTN","HLOUSR1",47,0)
 ..Q:'$$GETMSG^HLOMSG(+LIST(ITEM),.MSG)
"RTN","HLOUSR1",48,0)
 ..W !,"[",ITEM,"]","  DT/TM: ",$$FMTE^XLFDT(MSG("DT/TM CREATED"),2),"   STATUS: ",MSG("STATUS")
"RTN","HLOUSR1",49,0)
 .S DIR(0)="NO^1:"_COUNT,DIR("A")="Choose",DIR("?")="Choose one message from the list"
"RTN","HLOUSR1",50,0)
 .D ^DIR
"RTN","HLOUSR1",51,0)
 .I Y S Y=LIST(Y)
"RTN","HLOUSR1",52,0)
 Q Y
"RTN","HLOUSR1",53,0)
 ;
"RTN","HLOUSR1",54,0)
HELP ;Help code
"RTN","HLOUSR1",55,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLOUSR1",56,0)
 Q
"RTN","HLOUSR1",57,0)
 ;
"RTN","HLOUSR1",58,0)
EXIT ;Exit code
"RTN","HLOUSR1",59,0)
 D CLEAN^VALM10
"RTN","HLOUSR1",60,0)
 D CLEAR^VALM1
"RTN","HLOUSR1",61,0)
 S VALMBCK="R"
"RTN","HLOUSR1",62,0)
 ;
"RTN","HLOUSR1",63,0)
 Q
"RTN","HLOUSR1",64,0)
 ;
"RTN","HLOUSR1",65,0)
EXPND ;Expand code
"RTN","HLOUSR1",66,0)
 Q
"RTN","HLOUSR1",67,0)
 ;
"RTN","HLOUSR1",68,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR1",69,0)
 Q $$CJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR1",70,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR1",71,0)
 Q $$LJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR1",72,0)
SP(LEN,CHAR) ;
"RTN","HLOUSR1",73,0)
 ;return padding - " " is the default pad character
"RTN","HLOUSR1",74,0)
 N STR
"RTN","HLOUSR1",75,0)
 S:$G(CHAR)="" CHAR=" "
"RTN","HLOUSR1",76,0)
 S $P(STR,CHAR,LEN)=CHAR
"RTN","HLOUSR1",77,0)
 Q STR
"RTN","HLOUSR1",78,0)
 ;
"RTN","HLOUSR1",79,0)
SHOWMSG(MSGIEN,SUBIEN) ;
"RTN","HLOUSR1",80,0)
 ;Description:
"RTN","HLOUSR1",81,0)
 ;
"RTN","HLOUSR1",82,0)
 ;Input:
"RTN","HLOUSR1",83,0)
 ;Output:
"RTN","HLOUSR1",84,0)
 ;
"RTN","HLOUSR1",85,0)
 N MSG,I,TEMP,LINE
"RTN","HLOUSR1",86,0)
 S VALMCNT=0
"RTN","HLOUSR1",87,0)
 S SUBIEN=+$G(SUBIEN)
"RTN","HLOUSR1",88,0)
 I '$$GETMSG^HLOMSG(MSGIEN,.MSG) W !,"UNABLE TO DISPLAY THE MESSAGE",!! Q
"RTN","HLOUSR1",89,0)
 I SUBIEN D GETMSGB^HLOMSG1(.MSG,SUBIEN,.MSG)
"RTN","HLOUSR1",90,0)
 ;
"RTN","HLOUSR1",91,0)
 S I=0
"RTN","HLOUSR1",92,0)
 ;** administrative information **
"RTN","HLOUSR1",93,0)
 S @VALMAR@($$I,0)=$$CJ("Administrative Information",80)
"RTN","HLOUSR1",94,0)
 D CNTRL^VALM10(VALMCNT,26,30,IORVON,IORVOFF)
"RTN","HLOUSR1",95,0)
 S LINE="MsgID: "_$$LJ(MSG("ID"),18)
"RTN","HLOUSR1",96,0)
 S LINE=LINE_"Status: "_$$LJ(MSG("STATUS"),5)
"RTN","HLOUSR1",97,0)
 S:MSG("ACK TO")]"" LINE=LINE_$$LJ(" Ack To:",14)_MSG("ACK TO")
"RTN","HLOUSR1",98,0)
 S:MSG("ACK BY")]"" LINE=LINE_$$LJ(" Ack'd By:",14)_MSG("ACK BY")
"RTN","HLOUSR1",99,0)
 S @VALMAR@($$I,0)=LINE
"RTN","HLOUSR1",100,0)
 I MSG("STATUS","ERROR TEXT")]"" S @VALMAR@($$I,0)="Error: "_"** "_MSG("STATUS","ERROR TEXT")_" **"
"RTN","HLOUSR1",101,0)
 S @VALMAR@($$I,0)="Dir:   "_$$LJ($S(MSG("DIRECTION")="IN":"INCOMING",1:"OUTGOING"),10)_$$LJ("  Trans Dt/Tm: ",12)_$$FMTE^XLFDT(MSG("DT/TM"),2)_$$LJ("  Purge DT/TM: ",8)_$$FMTE^XLFDT(MSG("STATUS","PURGE"),2)
"RTN","HLOUSR1",102,0)
 S @VALMAR@($$I,0)="Link:  "_$$LJ(MSG("STATUS","LINK NAME"),29)_"   "_$$LJ("Queue: ",13)_MSG("STATUS","QUEUE")
"RTN","HLOUSR1",103,0)
 I MSG("STATUS","ACCEPT ACK'D") D
"RTN","HLOUSR1",104,0)
 .S @VALMAR@($$I,0)="Accept Ack: "_$$LJ(MSG("STATUS","ACCEPT ACK ID"),26)_$$LJ(" At: ",14)_$$FMTE^XLFDT(MSG("STATUS","ACCEPT ACK DT/TM"),2)
"RTN","HLOUSR1",105,0)
 .S @VALMAR@($$I,0)="   "_MSG("STATUS","ACCEPT ACK MSA")
"RTN","HLOUSR1",106,0)
 I MSG("DIRECTION")="IN" D
"RTN","HLOUSR1",107,0)
 .S LINE="App Response Rtn: "
"RTN","HLOUSR1",108,0)
 .I $L($G(MSG("STATUS","APP ACK RESPONSE"))) S LINE=$$LJ(LINE_MSG("STATUS","APP ACK RESPONSE"),38)_" Executed: "_$S(MSG("STATUS","APP HANDOFF"):"   YES",1:"   NO")
"RTN","HLOUSR1",109,0)
 .S @VALMAR@($$I,0)=LINE
"RTN","HLOUSR1",110,0)
 I MSG("DIRECTION")="OUT",(MSG("STATUS","APP ACK'D")!MSG("STATUS","ACCEPT ACK'D")) D
"RTN","HLOUSR1",111,0)
 .S LINE=""
"RTN","HLOUSR1",112,0)
 .I MSG("STATUS","ACCEPT ACK'D") D
"RTN","HLOUSR1",113,0)
 ..I MSG("STATUS","ACCEPT ACK RESPONSE")="" S MSG("STATUS","ACCEPT ACK RESPONSE")="n/a"
"RTN","HLOUSR1",114,0)
 ..S LINE="Accept Ack Rtn: "_MSG("STATUS","ACCEPT ACK RESPONSE")
"RTN","HLOUSR1",115,0)
 .S LINE=$$LJ(LINE,39)
"RTN","HLOUSR1",116,0)
 .I MSG("STATUS","APP ACK'D") D
"RTN","HLOUSR1",117,0)
 ..I MSG("STATUS","APP ACK RESPONSE")="" S MSG("STATUS","APP ACK RESPONSE")="n/a"
"RTN","HLOUSR1",118,0)
 ..S LINE=LINE_"App Ack Rtn: "_MSG("STATUS","APP ACK RESPONSE")
"RTN","HLOUSR1",119,0)
 .S @VALMAR@($$I,0)=LINE
"RTN","HLOUSR1",120,0)
 ;
"RTN","HLOUSR1",121,0)
 ;** the message text **
"RTN","HLOUSR1",122,0)
 S @VALMAR@($$I,0)=""
"RTN","HLOUSR1",123,0)
 I '$G(SUBIEN) D
"RTN","HLOUSR1",124,0)
 .S @VALMAR@($$I,0)=$$CJ("Message Text",80)
"RTN","HLOUSR1",125,0)
 .D CNTRL^VALM10(VALMCNT,33,16,IORVON,IORVOFF)
"RTN","HLOUSR1",126,0)
 E  D
"RTN","HLOUSR1",127,0)
 .S @VALMAR@($$I,0)=$$CJ("Individual Message Text (Batched)",80)
"RTN","HLOUSR1",128,0)
 .D CNTRL^VALM10(VALMCNT,23,35,IORVON,IORVOFF)
"RTN","HLOUSR1",129,0)
 D SHOWBODY(.MSG,$G(SUBIEN))
"RTN","HLOUSR1",130,0)
 ;
"RTN","HLOUSR1",131,0)
 ;** display its application acknowledgment **
"RTN","HLOUSR1",132,0)
 I MSG("ACK BY")]"",$$FINDMSG^HLOMSG1(MSG("ACK BY"),.TEMP)=1 S MSGIEN=TEMP(1) D
"RTN","HLOUSR1",133,0)
 .N MSG
"RTN","HLOUSR1",134,0)
 .Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR1",135,0)
 .I $P(MSGIEN,"^",2) D GETMSGB^HLOMSG1(.MSG,$P(MSGIEN,"^",2),.MSG)
"RTN","HLOUSR1",136,0)
 .S @VALMAR@($$I,0)=""
"RTN","HLOUSR1",137,0)
 .S @VALMAR@($$I,0)=$$CJ("Application Acknowledgment",80)
"RTN","HLOUSR1",138,0)
 .D CNTRL^VALM10(VALMCNT,26,30,IORVON,IORVOFF)
"RTN","HLOUSR1",139,0)
 .D SHOWBODY(.MSG,$P(MSGIEN,"^",2))
"RTN","HLOUSR1",140,0)
 ;
"RTN","HLOUSR1",141,0)
 ;** display the original message **
"RTN","HLOUSR1",142,0)
 I MSG("ACK TO")]"",$$FINDMSG^HLOMSG1(MSG("ACK TO"),.TEMP)=1 S MSGIEN=TEMP(1) D
"RTN","HLOUSR1",143,0)
 .N MSG
"RTN","HLOUSR1",144,0)
 .Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR1",145,0)
 .I $P(MSGIEN,"^",2) D GETMSGB^HLOMSG1(.MSG,$P(MSGIEN,"^",2),.MSG)
"RTN","HLOUSR1",146,0)
 .S @VALMAR@($$I,0)=""
"RTN","HLOUSR1",147,0)
 .S @VALMAR@($$I,0)=$$CJ("Original Message",80)
"RTN","HLOUSR1",148,0)
 .D CNTRL^VALM10(VALMCNT,26,30,IORVON,IORVOFF)
"RTN","HLOUSR1",149,0)
 .D SHOWBODY(.MSG,$P(MSGIEN,"^",2))
"RTN","HLOUSR1",150,0)
 Q
"RTN","HLOUSR1",151,0)
 ;
"RTN","HLOUSR1",152,0)
SHOWBODY(MSG,SUBIEN) ;
"RTN","HLOUSR1",153,0)
 N NODE,I,SEG,QUIT
"RTN","HLOUSR1",154,0)
 S QUIT=0
"RTN","HLOUSR1",155,0)
 M SEG=MSG("HDR")
"RTN","HLOUSR1",156,0)
 D ADD(.SEG)
"RTN","HLOUSR1",157,0)
 S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOUSR1",158,0)
 I MSG("BATCH") D
"RTN","HLOUSR1",159,0)
 .I $G(SUBIEN) D  Q
"RTN","HLOUSR1",160,0)
 ..S MSG("BATCH","CURRENT MESSAGE")=SUBIEN
"RTN","HLOUSR1",161,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  D ADD(.SEG)
"RTN","HLOUSR1",162,0)
 .S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOUSR1",163,0)
 .N LAST S LAST=0
"RTN","HLOUSR1",164,0)
 .F  Q:'$$NEXTMSG^HLOMSG(.MSG,.SEG)  D  Q:QUIT
"RTN","HLOUSR1",165,0)
 ..D ADD(.SEG)
"RTN","HLOUSR1",166,0)
 ..S LAST=MSG("BATCH","CURRENT MESSAGE")
"RTN","HLOUSR1",167,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  D ADD(.SEG)
"RTN","HLOUSR1",168,0)
 .I MSG("DIRECTION")="OUT" K SEG S SEG(1)="BTS"_$E($G(NODE(1)),4)_LAST D ADD(.SEG)
"RTN","HLOUSR1",169,0)
 E  D
"RTN","HLOUSR1",170,0)
 .F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  D  Q:QUIT
"RTN","HLOUSR1",171,0)
 ..D ADD(.SEG)
"RTN","HLOUSR1",172,0)
 Q
"RTN","HLOUSR1",173,0)
I() ;
"RTN","HLOUSR1",174,0)
 S VALMCNT=VALMCNT+1
"RTN","HLOUSR1",175,0)
 Q VALMCNT
"RTN","HLOUSR1",176,0)
ADD(SEG) ;
"RTN","HLOUSR1",177,0)
 N QUIT,I,J,LINE
"RTN","HLOUSR1",178,0)
 S QUIT=0
"RTN","HLOUSR1",179,0)
 S (I,J)=1
"RTN","HLOUSR1",180,0)
 S LINE(1)=$E(SEG(1),1,80),SEG(1)=$E(SEG(1),81,9999)
"RTN","HLOUSR1",181,0)
 I SEG(1)="" K SEG(1)
"RTN","HLOUSR1",182,0)
 D SHIFT(.I,.J)
"RTN","HLOUSR1",183,0)
 S @VALMAR@($$I,0)=LINE(1)
"RTN","HLOUSR1",184,0)
 S I=1
"RTN","HLOUSR1",185,0)
 F  S I=$O(LINE(I)) Q:'I  D
"RTN","HLOUSR1",186,0)
 .S @VALMAR@($$I,0)=LINE(I)
"RTN","HLOUSR1",187,0)
 .D CNTRL^VALM10(VALMCNT,1,1,IORVON,IORVOFF)
"RTN","HLOUSR1",188,0)
 Q
"RTN","HLOUSR1",189,0)
 ;
"RTN","HLOUSR1",190,0)
SHIFT(I,J) ;
"RTN","HLOUSR1",191,0)
 I '$D(SEG(I)) S I=$O(SEG(0)) Q:'I
"RTN","HLOUSR1",192,0)
 I $L(LINE(J))<80 D
"RTN","HLOUSR1",193,0)
 .N LEN
"RTN","HLOUSR1",194,0)
 .S LEN=$L(LINE(J))
"RTN","HLOUSR1",195,0)
 .S LINE(J)=LINE(J)_$E(SEG(I),1,80-LEN)
"RTN","HLOUSR1",196,0)
 .S SEG(I)=$E(SEG(I),81-LEN,9999)
"RTN","HLOUSR1",197,0)
 .I SEG(I)="" K SEG(I)
"RTN","HLOUSR1",198,0)
 E  D
"RTN","HLOUSR1",199,0)
 .S J=J+1
"RTN","HLOUSR1",200,0)
 .S LINE(J)="-"
"RTN","HLOUSR1",201,0)
 D SHIFT(.I,.J)
"RTN","HLOUSR1",202,0)
 Q
"RTN","HLOUSR1",203,0)
 ;
"RTN","HLOUSR1",204,0)
SCRLMODE ;scroll mode
"RTN","HLOUSR1",205,0)
 Q:'$L(HLRFRSH)
"RTN","HLOUSR1",206,0)
 N QUIT,IOTM,IOBM,DX,DY,LINE,IOTM,IOBM
"RTN","HLOUSR1",207,0)
 W !!,IOINHI,"Hit any key to escape scroll mode...",IOINORM
"RTN","HLOUSR1",208,0)
 S IOTM=3,IOBM=23
"RTN","HLOUSR1",209,0)
 S QUIT=0
"RTN","HLOUSR1",210,0)
 S LINE=$S(VALMCNT<17:1,1:17)
"RTN","HLOUSR1",211,0)
 W @IOSTBM
"RTN","HLOUSR1",212,0)
 S DX=1,DY=$S(VALMCNT<17:VALMCNT+1,1:17) X IOXY
"RTN","HLOUSR1",213,0)
 F I=1:1 D  Q:QUIT
"RTN","HLOUSR1",214,0)
 .;every 10 seconds refresh the data
"RTN","HLOUSR1",215,0)
 .I I>42 D @HLRFRSH S I=0
"RTN","HLOUSR1",216,0)
 .I LINE+1>VALMCNT D
"RTN","HLOUSR1",217,0)
 ..S TEMP=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR1",218,0)
 ..W !,IOUON,TEMP_$$SP(80-$L(TEMP)),IOUOFF
"RTN","HLOUSR1",219,0)
 .E  W !,$G(@VALMAR@(LINE,0))
"RTN","HLOUSR1",220,0)
 .S LINE=LINE+1
"RTN","HLOUSR1",221,0)
 .I LINE>VALMCNT S LINE=1
"RTN","HLOUSR1",222,0)
 .I (I=22)!(I=43) R *C:5 I $T S QUIT=1 Q
"RTN","HLOUSR1",223,0)
 S VALMBG=LINE-23 I VALMBG<0 S VALMBG=1
"RTN","HLOUSR1",224,0)
 S VALMBCK="R"
"RTN","HLOUSR1",225,0)
 Q
"RTN","HLOUSR1",226,0)
HLP ;
"RTN","HLOUSR1",227,0)
 Q
"RTN","HLOUSR1",228,0)
 ;
"RTN","HLOUSR1",229,0)
IFOPEN(LINK) ;
"RTN","HLOUSR1",230,0)
 ;returns 1 if the link can be opened, otherwise 0
"RTN","HLOUSR1",231,0)
 ;
"RTN","HLOUSR1",232,0)
 ;Inputs:
"RTN","HLOUSR1",233,0)
 ;  LINK - name of the link (required), optionally post-fixed with ":"_<port #>, will default to that defined for link
"RTN","HLOUSR1",234,0)
 ;
"RTN","HLOUSR1",235,0)
 N LINKNAME,LINKARY,POP,IO,IOF,IOST,OPEN,PORT
"RTN","HLOUSR1",236,0)
 S OPEN=0
"RTN","HLOUSR1",237,0)
 S LINKNAME=$P(LINK,":")
"RTN","HLOUSR1",238,0)
 S PORT=$P(LINK,":",2)
"RTN","HLOUSR1",239,0)
 Q:LINKNAME="" 0
"RTN","HLOUSR1",240,0)
 Q:'$$GETLINK^HLOTLNK(LINKNAME,.LINKARY) 0
"RTN","HLOUSR1",241,0)
 S:PORT LINKARY("PORT")=PORT
"RTN","HLOUSR1",242,0)
 Q:'$G(LINKARY("PORT")) 0
"RTN","HLOUSR1",243,0)
 I LINKARY("IP")="",LINKARY("DOMAIN")="",LINKARY("LLP")="TCP",LINKARY("SERVER") D
"RTN","HLOUSR1",244,0)
 .N DATA
"RTN","HLOUSR1",245,0)
 .S LINKARY("DOMAIN")=$P($G(^HLD(779.1,1,0)),"^")
"RTN","HLOUSR1",246,0)
 .Q:LINKARY("DOMAIN")=""
"RTN","HLOUSR1",247,0)
 .S DATA(.08)=LINKARY("DOMAIN")
"RTN","HLOUSR1",248,0)
 .Q:$$UPD^HLOASUB1(870,LINKARY("IEN"),.DATA)
"RTN","HLOUSR1",249,0)
 D:$G(LINKARY("IP"))'=""
"RTN","HLOUSR1",250,0)
 .D CALL^%ZISTCP(LINKARY("IP"),LINKARY("PORT"),15)
"RTN","HLOUSR1",251,0)
 .S OPEN='POP
"RTN","HLOUSR1",252,0)
 I 'OPEN,LINKARY("DOMAIN")'="",$G(^HLTMP("DNS LAST",LINKARY("IEN")))<$$DT^XLFDT D
"RTN","HLOUSR1",253,0)
 .N IP
"RTN","HLOUSR1",254,0)
 .S ^HLTMP("DNS LAST",LINKARY("IEN"))=$$DT^XLFDT
"RTN","HLOUSR1",255,0)
 .S IP=$$DNS^HLOTCP(LINKARY("DOMAIN"))
"RTN","HLOUSR1",256,0)
 .I IP'="",IP'=LINKARY("IP") D
"RTN","HLOUSR1",257,0)
 ..N DATA
"RTN","HLOUSR1",258,0)
 ..S DATA(400.01)=IP,LINKARY("IP")=IP
"RTN","HLOUSR1",259,0)
 ..Q:$$UPD^HLOASUB1(870,LINKARY("IEN"),.DATA)
"RTN","HLOUSR1",260,0)
 ..D CALL^%ZISTCP(LINKARY("IP"),LINKARY("PORT"),15)
"RTN","HLOUSR1",261,0)
 ..S OPEN='POP
"RTN","HLOUSR1",262,0)
 C:OPEN IO
"RTN","HLOUSR1",263,0)
 ;D CLOSE^%ZISTCP
"RTN","HLOUSR1",264,0)
 Q OPEN
"RTN","HLOUSR2")
0^25^B50803948^B44072105
"RTN","HLOUSR2",1,0)
HLOUSR2 ;ALB/CJM -ListManager Screen for viewing messages(continued);12 JUN 1997 10:00 am ;03/19/2007
"RTN","HLOUSR2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134**;Oct 13, 1995;Build 30
"RTN","HLOUSR2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified
"RTN","HLOUSR2",4,0)
 ;
"RTN","HLOUSR2",5,0)
EN ;
"RTN","HLOUSR2",6,0)
 D WAIT^DICD
"RTN","HLOUSR2",7,0)
 D EN^VALM("HLO MESSAGE VIEWER")
"RTN","HLOUSR2",8,0)
 Q
"RTN","HLOUSR2",9,0)
 ;
"RTN","HLOUSR2",10,0)
SHOWLIST(TYPE) ;
"RTN","HLOUSR2",11,0)
 ;TYPE= "SE", "AE", "TF"
"RTN","HLOUSR2",12,0)
 N PARMS,I,ERRCOUNT
"RTN","HLOUSR2",13,0)
 S (VALMBG,VALMCNT,I,ERRCOUNT)=0
"RTN","HLOUSR2",14,0)
 D CLEAN^VALM10
"RTN","HLOUSR2",15,0)
 S VALMBG=1
"RTN","HLOUSR2",16,0)
 I '$$ASKPARMS(.PARMS) S VALMBCK="" Q
"RTN","HLOUSR2",17,0)
 I PARMS("ALL") D
"RTN","HLOUSR2",18,0)
 .N APP
"RTN","HLOUSR2",19,0)
 .S APP=""
"RTN","HLOUSR2",20,0)
 .F  S APP=$O(^HLB("ERRORS",TYPE,APP)) Q:APP=""  D  Q:ERRCOUNT>PARMS("MAX")
"RTN","HLOUSR2",21,0)
 ..N TIME,IEN
"RTN","HLOUSR2",22,0)
 ..S TIME=PARMS("START")
"RTN","HLOUSR2",23,0)
 ..Q:($O(^HLB("ERRORS",TYPE,APP,TIME))="")
"RTN","HLOUSR2",24,0)
 ..S @VALMAR@($$I,0)="Application: "_APP
"RTN","HLOUSR2",25,0)
 ..D CNTRL^VALM10(VALMCNT,14,$L(APP),IOINHI,IOINORM)
"RTN","HLOUSR2",26,0)
 ..F  S TIME=$O(^HLB("ERRORS",TYPE,APP,TIME)) Q:'TIME  Q:ERRCOUNT>PARMS("MAX")  S IEN="" F  S IEN=$O(^HLB("ERRORS",TYPE,APP,TIME,IEN)) Q:IEN=""  D ADDTO(TYPE,IEN,TIME,.ERRCOUNT) Q:ERRCOUNT>PARMS("MAX")
"RTN","HLOUSR2",27,0)
 E  D
"RTN","HLOUSR2",28,0)
 .N APP
"RTN","HLOUSR2",29,0)
 .S APP=PARMS("APP")
"RTN","HLOUSR2",30,0)
 .N TIME,IEN
"RTN","HLOUSR2",31,0)
 .S TIME=PARMS("START")
"RTN","HLOUSR2",32,0)
 .Q:$O(^HLB("ERRORS",TYPE,APP,TIME))=""
"RTN","HLOUSR2",33,0)
 .S @VALMAR@($$I,0)="Application: "_APP
"RTN","HLOUSR2",34,0)
 .D CNTRL^VALM10(VALMCNT,14,$L(APP),IOINHI,IOINORM)
"RTN","HLOUSR2",35,0)
 .F  S TIME=$O(^HLB("ERRORS",TYPE,APP,TIME)) Q:'TIME  Q:ERRCOUNT>PARMS("MAX")  S IEN="" F  S IEN=$O(^HLB("ERRORS",TYPE,APP,TIME,IEN)) Q:IEN=""  D ADDTO(TYPE,IEN,TIME,.ERRCOUNT) Q:ERRCOUNT>PARMS("MAX")
"RTN","HLOUSR2",36,0)
 ;
"RTN","HLOUSR2",37,0)
SHOW S VALMBCK="R"
"RTN","HLOUSR2",38,0)
 ;
"RTN","HLOUSR2",39,0)
 Q
"RTN","HLOUSR2",40,0)
ADDTO(LTYPE,IEN,TIME,ERRCOUNT) ;
"RTN","HLOUSR2",41,0)
 N NODE,MSG
"RTN","HLOUSR2",42,0)
 Q:'$$GETMSG^HLOMSG(+IEN,.MSG)
"RTN","HLOUSR2",43,0)
 S ERRCOUNT=ERRCOUNT+1
"RTN","HLOUSR2",44,0)
 I LTYPE'="AE" D
"RTN","HLOUSR2",45,0)
 .N TYPE
"RTN","HLOUSR2",46,0)
 .S TYPE=$S(MSG("BATCH"):"BATCH",1:MSG("MESSAGE TYPE")_"~"_MSG("EVENT"))
"RTN","HLOUSR2",47,0)
 .S @VALMAR@($$I,0)="  "_$$LJ(MSG("ID"),15)_$$LJ(TYPE,8)_$$LJ($$FMTE^XLFDT(TIME,2),20)_MSG("STATUS","ERROR TEXT")
"RTN","HLOUSR2",48,0)
 .D CNTRL^VALM10(VALMCNT,3,15,IOINHI,IOINORM)
"RTN","HLOUSR2",49,0)
 .S:MSG("ID")]"" @VALMAR@("INDEX",MSG("ID"))=IEN
"RTN","HLOUSR2",50,0)
 E  D
"RTN","HLOUSR2",51,0)
 .;application errors - could be an error to a msg within a batch
"RTN","HLOUSR2",52,0)
 .;also, need to go to the ack msg to get the error text from the MSA segment
"RTN","HLOUSR2",53,0)
 .;
"RTN","HLOUSR2",54,0)
 .N SUBIEN,MSA,ERRTEXT
"RTN","HLOUSR2",55,0)
 .S (ERRTEXT,MSA)=""
"RTN","HLOUSR2",56,0)
 .S SUBIEN=$P(IEN,"^",2)
"RTN","HLOUSR2",57,0)
 .;within batch?
"RTN","HLOUSR2",58,0)
 .D:SUBIEN GETMSGB^HLOMSG1(.MSG,SUBIEN,.MSG)
"RTN","HLOUSR2",59,0)
 .S ERRTEXT=MSG("STATUS","ERROR TEXT")
"RTN","HLOUSR2",60,0)
 .I ERRTEXT="",MSG("ACK BY")]"",($$FINDMSG^HLOMSG1(MSG("ACK BY"),.LIST)=1) D
"RTN","HLOUSR2",61,0)
 ..N MSG,SEG,FS,AIEN
"RTN","HLOUSR2",62,0)
 ..S AIEN=+LIST(1),SUBIEN=$P(LIST(1),"^",2)
"RTN","HLOUSR2",63,0)
 ..Q:'$$GETMSG^HLOMSG(AIEN,.MSG)
"RTN","HLOUSR2",64,0)
 ..I SUBIEN S MSG("BATCH","CURRENT MESSAGE")=SUBIEN,MSG("LINE COUNT")=0
"RTN","HLOUSR2",65,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.MSG,.SEG)  I $E(SEG(1),1,3)="MSA" S MSA=SEG(1),FS=$E(MSA,4),ERRTEXT=$P(MSA,FS,4) Q
"RTN","HLOUSR2",66,0)
 .S @VALMAR@($$I,0)="  "_$$LJ(MSG("ID"),15)_$$LJ(MSG("MESSAGE TYPE")_"~"_MSG("EVENT"),8)_$$LJ($$FMTE^XLFDT(MSG("DT/TM CREATED"),2),20)_$E(ERRTEXT,1,37)
"RTN","HLOUSR2",67,0)
 .D CNTRL^VALM10(VALMCNT,3,15,IOINHI,IOINORM)
"RTN","HLOUSR2",68,0)
 .I $L(ERRTEXT)>37 D
"RTN","HLOUSR2",69,0)
 ..S @VALMAR@($$I,0)="~"_$E(ERRTEXT,38,112)
"RTN","HLOUSR2",70,0)
 ..D CNTRL^VALM10(VALMCNT,1,1,IORVON,IORVOFF)
"RTN","HLOUSR2",71,0)
 .S:MSG("ID")]"" @VALMAR@("INDEX",MSG("ID"))=IEN
"RTN","HLOUSR2",72,0)
 Q
"RTN","HLOUSR2",73,0)
 ;
"RTN","HLOUSR2",74,0)
ASKPARMS(PARMS) ;
"RTN","HLOUSR2",75,0)
 K PARMS
"RTN","HLOUSR2",76,0)
 S PARMS("START")=$$ASKBEGIN("T-1")
"RTN","HLOUSR2",77,0)
 I 'PARMS("START") Q 0
"RTN","HLOUSR2",78,0)
 S PARMS("MAX")=$$ASKMAX()
"RTN","HLOUSR2",79,0)
 Q:'(PARMS("MAX")>-1) 0
"RTN","HLOUSR2",80,0)
 S PARMS("ALL")=$$ASKYESNO("Include ALL applications","YES")
"RTN","HLOUSR2",81,0)
 I PARMS("ALL") Q 1
"RTN","HLOUSR2",82,0)
 I PARMS("ALL")="" Q 0
"RTN","HLOUSR2",83,0)
 S PARMS("APP")=$$ASKAPP
"RTN","HLOUSR2",84,0)
 I PARMS("APP")="" Q 0
"RTN","HLOUSR2",85,0)
 Q 1
"RTN","HLOUSR2",86,0)
 ;
"RTN","HLOUSR2",87,0)
ASKMAX()        ;
"RTN","HLOUSR2",88,0)
 N DIR
"RTN","HLOUSR2",89,0)
 S DIR(0)="N^1:30000:0"
"RTN","HLOUSR2",90,0)
 S DIR("A")="Maximum List Size"
"RTN","HLOUSR2",91,0)
 S DIR("B")=1000
"RTN","HLOUSR2",92,0)
 S DIR("?",1)="In case a large number of errors meet your search criteria, what are the"
"RTN","HLOUSR2",93,0)
 S DIR("?")="maximum number of errors to display? (30,000 maximum)"
"RTN","HLOUSR2",94,0)
 D ^DIR
"RTN","HLOUSR2",95,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR2",96,0)
 Q X-1
"RTN","HLOUSR2",97,0)
ASKAPP() ;
"RTN","HLOUSR2",98,0)
 D FULL^VALM1
"RTN","HLOUSR2",99,0)
 S VALMBCK="R"
"RTN","HLOUSR2",100,0)
 N DIR
"RTN","HLOUSR2",101,0)
 S DIR(0)="F^3:60"
"RTN","HLOUSR2",102,0)
 S DIR("A")="Application"
"RTN","HLOUSR2",103,0)
 S DIR("?")="Enter the full name of the application, or '^' to exit."
"RTN","HLOUSR2",104,0)
 S DIR("?",1)="For transmission failures, enter the sending application. "
"RTN","HLOUSR2",105,0)
 S DIR("?",2)="For other errors, enter the name of the receiving application. "
"RTN","HLOUSR2",106,0)
 D ^DIR
"RTN","HLOUSR2",107,0)
 I $D(DIRUT)!(Y="") Q ""
"RTN","HLOUSR2",108,0)
 Q Y
"RTN","HLOUSR2",109,0)
 ;
"RTN","HLOUSR2",110,0)
ASKYESNO(PROMPT,DEFAULT) ;
"RTN","HLOUSR2",111,0)
 ;Description: Displays PROMPT, appending '?'.  Expects a YES NO response
"RTN","HLOUSR2",112,0)
 ;Input:
"RTN","HLOUSR2",113,0)
 ;   PROMPT - text to display as prompt.  Appends '?'
"RTN","HLOUSR2",114,0)
 ;   DEFAULT - (optional) YES or NO.  If not passed, defaults to YES
"RTN","HLOUSR2",115,0)
 ;Output:
"RTN","HLOUSR2",116,0)
 ;  Function value: 1 if yes, 0 if no, "" if '^' entered or timeout
"RTN","HLOUSR2",117,0)
 ;
"RTN","HLOUSR2",118,0)
 N DIR,Y
"RTN","HLOUSR2",119,0)
 S DIR(0)="Y"
"RTN","HLOUSR2",120,0)
 S DIR("A")=PROMPT
"RTN","HLOUSR2",121,0)
 S DIR("B")=$S($G(DEFAULT)="NO":"NO",1:"YES")
"RTN","HLOUSR2",122,0)
 D ^DIR
"RTN","HLOUSR2",123,0)
 Q:$D(DIRUT) ""
"RTN","HLOUSR2",124,0)
 Q Y
"RTN","HLOUSR2",125,0)
 ;
"RTN","HLOUSR2",126,0)
STRTSTPQ ;
"RTN","HLOUSR2",127,0)
 ;action to start or stop a queue, either incoming or outgoing
"RTN","HLOUSR2",128,0)
 ;
"RTN","HLOUSR2",129,0)
 N STOP,INOROUT,QUE
"RTN","HLOUSR2",130,0)
 S VALMBCK="R"
"RTN","HLOUSR2",131,0)
 D FULL^VALM1
"RTN","HLOUSR2",132,0)
 ;ask if stop or start
"RTN","HLOUSR2",133,0)
 D  Q:STOP=""
"RTN","HLOUSR2",134,0)
 .N DIR
"RTN","HLOUSR2",135,0)
 .S DIR(0)="S^1:START;2:STOP"
"RTN","HLOUSR2",136,0)
 .S DIR("A")="Do you want to START or STOP a queue"
"RTN","HLOUSR2",137,0)
 .S DIR("B")="1"
"RTN","HLOUSR2",138,0)
 .D ^DIR
"RTN","HLOUSR2",139,0)
 .S STOP=$S(Y=1:0,Y=2:1,1:"")
"RTN","HLOUSR2",140,0)
 ;ask if in or out
"RTN","HLOUSR2",141,0)
 D  Q:INOROUT=""
"RTN","HLOUSR2",142,0)
 .N DIR
"RTN","HLOUSR2",143,0)
 .S DIR(0)="S^I:INCOMING;O:OUTGOING"
"RTN","HLOUSR2",144,0)
 .S DIR("A")="Do you want to "_$S(STOP:"stop",1:"start")_" an incoming queue or an outgoing queue"
"RTN","HLOUSR2",145,0)
 .S DIR("B")="I"
"RTN","HLOUSR2",146,0)
 .D ^DIR
"RTN","HLOUSR2",147,0)
 .S INOROUT=$S(Y="I":"IN",Y="O":"OUT",1:"")
"RTN","HLOUSR2",148,0)
 S QUE=$$ASKQUE(INOROUT)
"RTN","HLOUSR2",149,0)
 Q:QUE=""
"RTN","HLOUSR2",150,0)
 I STOP=$$STOPPED^HLOQUE(INOROUT,QUE) D
"RTN","HLOUSR2",151,0)
 .N C
"RTN","HLOUSR2",152,0)
 .I STOP D
"RTN","HLOUSR2",153,0)
 ..W !,"That queue is already stopped!"
"RTN","HLOUSR2",154,0)
 .E  W !,"That queue is not stopped!"
"RTN","HLOUSR2",155,0)
 .W !,IOINHI,"Hit any key to continue...",IOINORM
"RTN","HLOUSR2",156,0)
 .R *C:DTIME
"RTN","HLOUSR2",157,0)
 E  D
"RTN","HLOUSR2",158,0)
 .N C
"RTN","HLOUSR2",159,0)
 .D:STOP STOPQUE^HLOQUE(INOROUT,QUE)
"RTN","HLOUSR2",160,0)
 .D:'STOP STARTQUE^HLOQUE(INOROUT,QUE)
"RTN","HLOUSR2",161,0)
 .W !,"DONE!"
"RTN","HLOUSR2",162,0)
 .W !,IOINHI,"Hit any key to continue...",IOINORM
"RTN","HLOUSR2",163,0)
 .R *C:DTIME
"RTN","HLOUSR2",164,0)
 .D @HLRFRSH
"RTN","HLOUSR2",165,0)
 Q
"RTN","HLOUSR2",166,0)
 ;
"RTN","HLOUSR2",167,0)
ASKQUE(DIR) ;
"RTN","HLOUSR2",168,0)
 N QUEUE
"RTN","HLOUSR2",169,0)
AGAIN W !,"Enter the full, exact name of queue:"
"RTN","HLOUSR2",170,0)
 S QUEUE=""
"RTN","HLOUSR2",171,0)
 R QUEUE:60 I '$T Q ""
"RTN","HLOUSR2",172,0)
 I $E(QUEUE)="?" W !,"Each message is placed on a queue that has an arbitrary name up to 20",!,"characters long." I $$ASKYESNO("Would you like to see a list of the queues that currently exist","NO") D  G AGAIN
"RTN","HLOUSR2",173,0)
 .N SUB,QUE,QUIT,COUNT
"RTN","HLOUSR2",174,0)
 .K ^TMP($J,"HLO QUEUES")
"RTN","HLOUSR2",175,0)
 .S SUB=""
"RTN","HLOUSR2",176,0)
 .F  S SUB=$O(^HLB("QUEUE",DIR,SUB)) Q:SUB=""  D
"RTN","HLOUSR2",177,0)
 ..S QUE=""
"RTN","HLOUSR2",178,0)
 ..F  S QUE=$O(^HLB("QUEUE",DIR,SUB,QUE)) Q:QUE=""  S ^TMP($J,"HLO QUEUES",QUE)=""
"RTN","HLOUSR2",179,0)
 .S QUE=""
"RTN","HLOUSR2",180,0)
 .S IOSL=$G(IOSL,20)
"RTN","HLOUSR2",181,0)
 .S (COUNT,QUIT)=0
"RTN","HLOUSR2",182,0)
 .W !
"RTN","HLOUSR2",183,0)
 .F  S QUE=$O(^TMP($J,"HLO QUEUES",QUE)) Q:QUE=""  Q:QUIT  D
"RTN","HLOUSR2",184,0)
 ..W !,QUE
"RTN","HLOUSR2",185,0)
 ..S COUNT=COUNT+1
"RTN","HLOUSR2",186,0)
 ..I COUNT>(IOSL-3) D
"RTN","HLOUSR2",187,0)
 ...N Y
"RTN","HLOUSR2",188,0)
 ...D PAUSE^VALM1
"RTN","HLOUSR2",189,0)
 ...I 'Y S QUIT=1
"RTN","HLOUSR2",190,0)
 ...S COUNT=0
"RTN","HLOUSR2",191,0)
 .W !
"RTN","HLOUSR2",192,0)
 .K ^TMP($J,"HLO QUEUES")
"RTN","HLOUSR2",193,0)
 Q:$E(QUEUE)="?" ""
"RTN","HLOUSR2",194,0)
 Q:$E(QUEUE)="^" ""
"RTN","HLOUSR2",195,0)
 Q QUEUE
"RTN","HLOUSR2",196,0)
 ;
"RTN","HLOUSR2",197,0)
ASKBEGIN(DEFAULT) ;
"RTN","HLOUSR2",198,0)
 ;Description: Asks the user to enter a beginning date.
"RTN","HLOUSR2",199,0)
 ;Input: DEFAULT - the suggested default dt/time (optional)
"RTN","HLOUSR2",200,0)
 ;Output: Returns the date as the function value, or 0 if the user does not select a date
"RTN","HLOUSR2",201,0)
 ;
"RTN","HLOUSR2",202,0)
 ;
"RTN","HLOUSR2",203,0)
 N %DT
"RTN","HLOUSR2",204,0)
 S %DT="AEST"
"RTN","HLOUSR2",205,0)
 S %DT("A")="Enter the beginning date/time: "
"RTN","HLOUSR2",206,0)
 S %DT("B")=$$FMTE^XLFDT($S($L($G(DEFAULT)):DEFAULT,1:$$FMADD^XLFDT(DT,-1)))
"RTN","HLOUSR2",207,0)
 S %DT(0)="-NOW"
"RTN","HLOUSR2",208,0)
 Q:$D(DTOUT) 0
"RTN","HLOUSR2",209,0)
 D ^%DT
"RTN","HLOUSR2",210,0)
 I Y=-1 Q 0
"RTN","HLOUSR2",211,0)
 Q Y
"RTN","HLOUSR2",212,0)
 ;
"RTN","HLOUSR2",213,0)
ASKEND(BEGIN) ;
"RTN","HLOUSR2",214,0)
 ;Description: Asks the user to enter an ending date/time
"RTN","HLOUSR2",215,0)
 ;Input: BEGIN - the earliest date/time allowed
"RTN","HLOUSR2",216,0)
 ;Output: Returns the date as the function value, or 0 if the user does not select a date/time
"RTN","HLOUSR2",217,0)
 ;
"RTN","HLOUSR2",218,0)
 N %DT
"RTN","HLOUSR2",219,0)
 S %DT="AEST"
"RTN","HLOUSR2",220,0)
 S %DT("A")="Enter the ending date/time: "
"RTN","HLOUSR2",221,0)
 S %DT("B")="NOW"
"RTN","HLOUSR2",222,0)
 S %DT(0)=BEGIN
"RTN","HLOUSR2",223,0)
 Q:$D(DTOUT) 0
"RTN","HLOUSR2",224,0)
 D ^%DT
"RTN","HLOUSR2",225,0)
 I Y=-1 Q 0
"RTN","HLOUSR2",226,0)
 Q Y
"RTN","HLOUSR2",227,0)
 ;
"RTN","HLOUSR2",228,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR2",229,0)
 Q $$LJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR2",230,0)
 ;
"RTN","HLOUSR2",231,0)
I() ;
"RTN","HLOUSR2",232,0)
 S VALMCNT=VALMCNT+1
"RTN","HLOUSR2",233,0)
 Q VALMCNT
"RTN","HLOUSR2",234,0)
 ;
"RTN","HLOUSR2",235,0)
HEADER ;
"RTN","HLOUSR2",236,0)
 Q
"RTN","HLOUSR3")
0^20^B28592051^B18658983
"RTN","HLOUSR3",1,0)
HLOUSR3 ;ALB/CJM -ListManager Screen for viewing messages(continued);12 JUN 1997 10:00 am ;03/20/2007
"RTN","HLOUSR3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134**;Oct 13, 1995;Build 30
"RTN","HLOUSR3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR3",4,0)
 ;
"RTN","HLOUSR3",5,0)
 ;
"RTN","HLOUSR3",6,0)
EN ;
"RTN","HLOUSR3",7,0)
 N HLPARMS
"RTN","HLOUSR3",8,0)
 D FULL^VALM1
"RTN","HLOUSR3",9,0)
 I '$$ASK(.HLPARMS) S VALMBCK="R" Q
"RTN","HLOUSR3",10,0)
 D WAIT^DICD
"RTN","HLOUSR3",11,0)
 D EN^VALM("HLO MESSAGE SEARCH")
"RTN","HLOUSR3",12,0)
 Q
"RTN","HLOUSR3",13,0)
SEARCH ;
"RTN","HLOUSR3",14,0)
 N I,APP,START,END,DIR,MSG,EVENT,TIME
"RTN","HLOUSR3",15,0)
 D EXIT
"RTN","HLOUSR3",16,0)
 S I=""
"RTN","HLOUSR3",17,0)
 F  S I=$O(HLPARMS(I)) Q:I=""  S @I=HLPARMS(I)
"RTN","HLOUSR3",18,0)
 K HLPARMS
"RTN","HLOUSR3",19,0)
 S (VALMCNT,I)=0
"RTN","HLOUSR3",20,0)
 S TIME=START
"RTN","HLOUSR3",21,0)
 F  S TIME=$O(^HLB("SEARCH",DIR,TIME)) Q:'TIME  Q:TIME>END  Q:VALMCNT>MAX  D
"RTN","HLOUSR3",22,0)
 .N SAPP S SAPP=""
"RTN","HLOUSR3",23,0)
 .S:APP'="" SAPP=$O(^HLB("SEARCH",DIR,TIME,APP),-1)
"RTN","HLOUSR3",24,0)
 .F  S SAPP=$O(^HLB("SEARCH",DIR,TIME,SAPP)) Q:SAPP=""  Q:$E(SAPP,1,$L(APP))]APP  Q:VALMCNT>MAX  D:$E(SAPP,1,$L(APP))=APP
"RTN","HLOUSR3",25,0)
 ..N SMSG S SMSG=""
"RTN","HLOUSR3",26,0)
 ..S:MSG'="" SMSG=$O(^HLB("SEARCH",DIR,TIME,SAPP,MSG),-1)
"RTN","HLOUSR3",27,0)
 ..F  S SMSG=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG)) Q:SMSG=""  Q:$E(SMSG,1,$L(MSG))]MSG  Q:VALMCNT>MAX  D:$E(SMSG,1,$L(MSG))=MSG
"RTN","HLOUSR3",28,0)
 ...N SEVENT S SEVENT=""
"RTN","HLOUSR3",29,0)
 ...S:EVENT'="" SEVENT=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,EVENT),-1)
"RTN","HLOUSR3",30,0)
 ...F  S SEVENT=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,SEVENT)) Q:SEVENT=""  Q:$E(SEVENT,1,$L(EVENT))]EVENT  Q:VALMCNT>MAX  D:$E(SEVENT,1,$L(EVENT))=EVENT
"RTN","HLOUSR3",31,0)
 ....N IEN
"RTN","HLOUSR3",32,0)
 ....S IEN=""
"RTN","HLOUSR3",33,0)
 ....F  S IEN=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,SEVENT,IEN)) Q:IEN=""  Q:VALMCNT>MAX  D ADDTO(DIR,TIME,SAPP,SMSG,SEVENT,IEN)
"RTN","HLOUSR3",34,0)
 ;
"RTN","HLOUSR3",35,0)
 ;
"RTN","HLOUSR3",36,0)
END S VALMBCK="R"
"RTN","HLOUSR3",37,0)
 ;
"RTN","HLOUSR3",38,0)
 Q
"RTN","HLOUSR3",39,0)
ADDTO(DIR,TIME,APP,MSG,EVENT,IEN) ;
"RTN","HLOUSR3",40,0)
 N HDR,FS,LOC,MSGID
"RTN","HLOUSR3",41,0)
 S MSGID=$S($P(IEN,"^",2):$P($G(^HLB(+IEN,3,$P(IEN,"^",2),0)),"^",2),1:$P($G(^HLB(IEN,0)),"^",1))
"RTN","HLOUSR3",42,0)
 S HDR=$G(^HLB(+IEN,1))
"RTN","HLOUSR3",43,0)
 S FS=$E(HDR,4)
"RTN","HLOUSR3",44,0)
 I FS'="" D
"RTN","HLOUSR3",45,0)
 .I DIR="IN" S LOC=$P(HDR,FS,4)
"RTN","HLOUSR3",46,0)
 .I DIR'="IN" S LOC=$P(HDR,FS,6)
"RTN","HLOUSR3",47,0)
 E  S LOC=""
"RTN","HLOUSR3",48,0)
 S @VALMAR@($$I,0)=$$LJ(MSGID,25)_$$LJ(APP,30)_" "_MSG_"~"_EVENT
"RTN","HLOUSR3",49,0)
 D CNTRL^VALM10(VALMCNT,1,25,IOINHI,IOINORM)
"RTN","HLOUSR3",50,0)
 S @VALMAR@($$I,0)="     "_$$LJ($$FMTE^XLFDT(TIME,2),20)_$$LJ(LOC,60)
"RTN","HLOUSR3",51,0)
 S @VALMAR@($$I,0)=""
"RTN","HLOUSR3",52,0)
 Q
"RTN","HLOUSR3",53,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR3",54,0)
 Q $$LJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR3",55,0)
 ;
"RTN","HLOUSR3",56,0)
I() ;
"RTN","HLOUSR3",57,0)
 S VALMCNT=VALMCNT+1
"RTN","HLOUSR3",58,0)
 Q VALMCNT
"RTN","HLOUSR3",59,0)
 ;
"RTN","HLOUSR3",60,0)
ASK(PARMS) ;
"RTN","HLOUSR3",61,0)
 N SUB
"RTN","HLOUSR3",62,0)
 F SUB="START","END","EVENT","APP","MSG","DIR" S PARMS(SUB)=""
"RTN","HLOUSR3",63,0)
 S PARMS("START")=$$ASKBEGIN^HLOUSR2()
"RTN","HLOUSR3",64,0)
 Q:'PARMS("START") 0
"RTN","HLOUSR3",65,0)
 S PARMS("END")=$$ASKEND^HLOUSR2(PARMS("START"))
"RTN","HLOUSR3",66,0)
 Q:'PARMS("END") 0
"RTN","HLOUSR3",67,0)
 S PARMS("APP")=$$ASKAPP()
"RTN","HLOUSR3",68,0)
 Q:PARMS("APP")=-1 0
"RTN","HLOUSR3",69,0)
 S PARMS("MSG")=$$ASKMSG()
"RTN","HLOUSR3",70,0)
 Q:PARMS("MSG")=-1 0
"RTN","HLOUSR3",71,0)
 S PARMS("EVENT")=$$ASKEVENT()
"RTN","HLOUSR3",72,0)
 Q:PARMS("EVENT")=-1 0
"RTN","HLOUSR3",73,0)
 S PARMS("DIR")=$$ASKDIR()
"RTN","HLOUSR3",74,0)
 Q:PARMS("DIR")=-1 0
"RTN","HLOUSR3",75,0)
 S PARMS("DIR")=$S(PARMS("DIR")="I":"IN",1:"OUT")
"RTN","HLOUSR3",76,0)
 S PARMS("MAX")=$$ASKMAX()
"RTN","HLOUSR3",77,0)
 Q:'(PARMS("MAX")>-1) 0
"RTN","HLOUSR3",78,0)
 Q 1
"RTN","HLOUSR3",79,0)
 ;
"RTN","HLOUSR3",80,0)
ASKMAX() ;
"RTN","HLOUSR3",81,0)
 N DIR
"RTN","HLOUSR3",82,0)
 S DIR(0)="N^1:30000:0"
"RTN","HLOUSR3",83,0)
 S DIR("A")="Maximum List Size"
"RTN","HLOUSR3",84,0)
 S DIR("B")=1000
"RTN","HLOUSR3",85,0)
 S DIR("?",1)="In case a large number of messages meet your search criteria, what are the"
"RTN","HLOUSR3",86,0)
 S DIR("?")="maximum number of messages to display? (30,000 maximum)"
"RTN","HLOUSR3",87,0)
 D ^DIR
"RTN","HLOUSR3",88,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",89,0)
 Q 3*(X-1)
"RTN","HLOUSR3",90,0)
ASKAPP() ;
"RTN","HLOUSR3",91,0)
 N DIR
"RTN","HLOUSR3",92,0)
 S DIR(0)="FO^0:60"
"RTN","HLOUSR3",93,0)
 S DIR("A")="Application"
"RTN","HLOUSR3",94,0)
 S DIR("?",1)="Enter the name of the application, or '^' to exit."
"RTN","HLOUSR3",95,0)
 S DIR("?")="You can enter just the first part of the name."
"RTN","HLOUSR3",96,0)
 D ^DIR
"RTN","HLOUSR3",97,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",98,0)
 Q X
"RTN","HLOUSR3",99,0)
ASKMSG() ;
"RTN","HLOUSR3",100,0)
 N DIR
"RTN","HLOUSR3",101,0)
 S DIR(0)="FO^0:3"
"RTN","HLOUSR3",102,0)
 S DIR("A")="HL7 Message Type"
"RTN","HLOUSR3",103,0)
 S DIR("?",1)="Enter the 3 character message type (e.g. MFN, ADT), or '^' to exit."
"RTN","HLOUSR3",104,0)
 S DIR("?")="You can enter just the first character or two."
"RTN","HLOUSR3",105,0)
 D ^DIR
"RTN","HLOUSR3",106,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",107,0)
 Q X
"RTN","HLOUSR3",108,0)
ASKEVENT() ;
"RTN","HLOUSR3",109,0)
 N DIR
"RTN","HLOUSR3",110,0)
 S DIR(0)="FO^0:3"
"RTN","HLOUSR3",111,0)
 S DIR("A")="HL7 Event"
"RTN","HLOUSR3",112,0)
 S DIR("?",1)="Enter the 3 character event type, or '^' to exit."
"RTN","HLOUSR3",113,0)
 S DIR("?")="You can enter just the first character or two."
"RTN","HLOUSR3",114,0)
 D ^DIR
"RTN","HLOUSR3",115,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",116,0)
 Q X
"RTN","HLOUSR3",117,0)
ASKDIR() ;
"RTN","HLOUSR3",118,0)
 N DIR
"RTN","HLOUSR3",119,0)
 S DIR(0)="S^I:INCOMING;O:OUTGOING"
"RTN","HLOUSR3",120,0)
 S DIR("A")="Incoming or Outgoing"
"RTN","HLOUSR3",121,0)
 S DIR("?",1)="Are you searching for an incoming message or an outgoing message?"
"RTN","HLOUSR3",122,0)
 S DIR("?")="You can enter '^' to exit"
"RTN","HLOUSR3",123,0)
 D ^DIR
"RTN","HLOUSR3",124,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",125,0)
 Q X
"RTN","HLOUSR3",126,0)
HDR ;
"RTN","HLOUSR3",127,0)
 S VALMHDR(1)="MsgID                    Application                    MsgType"
"RTN","HLOUSR3",128,0)
 Q
"RTN","HLOUSR3",129,0)
HLP ;
"RTN","HLOUSR3",130,0)
 Q
"RTN","HLOUSR3",131,0)
EXIT ;
"RTN","HLOUSR3",132,0)
 D CLEAN^VALM10
"RTN","HLOUSR3",133,0)
 D CLEAR^VALM1
"RTN","HLOUSR3",134,0)
 S VALMBCK="R"
"RTN","HLOUSR3",135,0)
 Q
"RTN","HLOUSR3",136,0)
 ;
"RTN","HLOUSR3",137,0)
SETPURGE ;
"RTN","HLOUSR3",138,0)
 N MSG,DIR
"RTN","HLOUSR3",139,0)
 S VALMBCK="R"
"RTN","HLOUSR3",140,0)
 Q:'$G(MSGIEN)
"RTN","HLOUSR3",141,0)
 Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR3",142,0)
 I MSG("STATUS")="",'MSG("STATUS","PURGE") W !,"Can not set purge yet!" D PAUSE^VALM1 Q
"RTN","HLOUSR3",143,0)
 S DIR(0)="D^"_DT_":"_$$FMADD^XLFDT(DT,+45)_":E"
"RTN","HLOUSR3",144,0)
 S DIR("A")="When should the message be purged?"
"RTN","HLOUSR3",145,0)
 D ^DIR
"RTN","HLOUSR3",146,0)
 D:Y SETPURGE^HLOAPI3(+MSGIEN,Y),DISPLAY^HLOUSR1
"RTN","HLOUSR3",147,0)
 Q
"RTN","HLOUSR3",148,0)
SCREEN() ;
"RTN","HLOUSR3",149,0)
 N TRUE
"RTN","HLOUSR3",150,0)
 S TRUE=1
"RTN","HLOUSR3",151,0)
 I $P($G(X),"^",3)="SET PURGE" D  Q TRUE
"RTN","HLOUSR3",152,0)
 .N MSG
"RTN","HLOUSR3",153,0)
 .I '$G(MSGIEN) S TRUE=0 Q
"RTN","HLOUSR3",154,0)
 .I '$$GETMSG^HLOMSG(+MSGIEN,.MSG) S TRUE=0 Q
"RTN","HLOUSR3",155,0)
 .I MSG("STATUS")="",'MSG("STATUS","PURGE") S TRUE=0
"RTN","HLOUSR3",156,0)
 S:'TRUE VALMBCK="R"
"RTN","HLOUSR3",157,0)
 Q TRUE
"VER")
8.0^22.0
"^DD",778,778,5,0)
TRANMISSION ATTEMPTS^NJ8,0^^TRIES;1^K:+X'=X!(X>99999999)!(X<0)!(X?.E1"."1.N) X
"^DD",778,778,5,3)
How many times has HLO tried to transmit this message?
"^DD",778,778,5,21,0)
^^3^3^3070314^
"^DD",778,778,5,21,1,0)
For outgoing messages, this field is a counter of how many times HLO
"^DD",778,778,5,21,2,0)
attempted to send this message.
"^DD",778,778,5,21,3,0)

"^DD",778,778,5,"DT")
3070314
"^DD",779.2,779.2,.09,0)
APPLICATION SPECIFIC LISTENER^*P870'X^HLCS(870,^0;9^S DIC("S")="I $P($G(^HLCS(870,Y,400)),""^"",3)'="""",""SM""[$P(^HLCS(870,Y,400),""^"",3)" D ^DIC K DIC S DIC=$G(DIE),X=+Y K:Y<0 X
"^DD",779.2,779.2,.09,3)
If your application requires its own listener (HIGHLY DISCOURAGED), enter it here.
"^DD",779.2,779.2,.09,12)
The link entered must be a listener.
"^DD",779.2,779.2,.09,12.1)
S DIC("S")="I $P($G(^HLCS(870,Y,400)),""^"",3)'="""",""SM""[$P(^HLCS(870,Y,400),""^"",3)"
"^DD",779.2,779.2,.09,21,0)
^^6^6^3050503^
"^DD",779.2,779.2,.09,21,1,0)
Applications are highly discouraged from establishing their own listeners.  The
"^DD",779.2,779.2,.09,21,2,0)
use of the multi-listeners provide concurrent processing of many connections
"^DD",779.2,779.2,.09,21,3,0)
over the same port, so a dedicated listener will not provide an application
"^DD",779.2,779.2,.09,21,4,0)
with a performance boost, while it will cause the site additional work to
"^DD",779.2,779.2,.09,21,5,0)
maintain. So before establishing a dedicated listener, the application
"^DD",779.2,779.2,.09,21,6,0)
developer should verify the need.
"^DD",779.2,779.2,.09,"DT")
3061120
"^DD",779.4,779.4,0)
FIELD^^3.06^10
"^DD",779.4,779.4,0,"DDA")
N
"^DD",779.4,779.4,0,"DT")
3070124
"^DD",779.4,779.4,0,"IX","B",779.4,.01)

"^DD",779.4,779.4,0,"NM","HLO SUBSCRIPTION REGISTRY")

"^DD",779.4,779.4,0,"VRPK")
HL
"^DD",779.4,779.4,.01,0)
NAME^RFX^^0;1^K:+X'=X!(X>99999999)!(X<1)!(X?.E1"."1N.N) X S:$D(X) DINUM=X
"^DD",779.4,779.4,.01,1,0)
^.1
"^DD",779.4,779.4,.01,1,1,0)
779.4^B
"^DD",779.4,779.4,.01,1,1,1)
S ^HLD(779.4,"B",$E(X,1,30),DA)=""
"^DD",779.4,779.4,.01,1,1,2)
K ^HLD(779.4,"B",$E(X,1,30),DA)
"^DD",779.4,779.4,.01,3)
NAME MUST BE 3-30 CHARACTERS, NOT NUMERIC OR STARTING WITH PUNCTUATION
"^DD",779.4,779.4,.01,21,0)
^^2^2^3050308^^^^
"^DD",779.4,779.4,.01,21,1,0)
This file should not be used to edit this file. Instead, a set of developer
"^DD",779.4,779.4,.01,21,2,0)
APIs that was released with this file should be used.
"^DD",779.4,779.4,.01,"DT")
3050308
"^DD",779.4,779.4,.02,0)
OWNER APPLICATION^F^^0;2^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,.02,1,0)
^.1^^0
"^DD",779.4,779.4,.02,3)
Answer must be 1-40 characters in length.
"^DD",779.4,779.4,.02,21,0)
^^2^2^3040526^^
"^DD",779.4,779.4,.02,21,1,0)
This is the application or package responsible for creating this
"^DD",779.4,779.4,.02,21,2,0)
subscription.
"^DD",779.4,779.4,.02,"DT")
3070125
"^DD",779.4,779.4,.03,0)
DESCRIPTION^F^^1;1^K:$L(X)>75!($L(X)<1) X
"^DD",779.4,779.4,.03,3)
Answer must be 1-75 characters in length
"^DD",779.4,779.4,.03,"DT")
2991207
"^DD",779.4,779.4,3.01,0)
LOOKUP 1^F^^3;1^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,3.01,3)
Answer must be 1-40 characters in length
"^DD",779.4,779.4,3.01,"DT")
3070124
"^DD",779.4,779.4,3.02,0)
LOOKUP 2^F^^3;2^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,3.02,3)
Answer must be 1-40 characters in length
"^DD",779.4,779.4,3.02,"DT")
3070124
"^DD",779.4,779.4,3.03,0)
LOOKUP 3^F^^3;3^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,3.03,3)
Answer must be 1-40 characters in length
"^DD",779.4,779.4,3.03,"DT")
3070124
"^DD",779.4,779.4,3.04,0)
LOOKUP 4^F^^3;4^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,3.04,3)
Answer must be 1-40 characters in length
"^DD",779.4,779.4,3.04,"DT")
3070124
"^DD",779.4,779.4,3.05,0)
LOOKUP 5^F^^3;5^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,3.05,3)
Answer must be 1-40 characters in length
"^DD",779.4,779.4,3.05,"DT")
3070124
"^DD",779.4,779.4,3.06,0)
LOOKUP 6^F^^3;6^K:$L(X)>40!($L(X)<1) X
"^DD",779.4,779.4,3.06,3)
Answer must be 1-40 characters in length
"^DD",779.4,779.4,3.06,"DT")
3070124
"^DD",779.4,779.4,20,0)
RECIPIENTS^779.41^^2;0
"^DD",779.4,779.41,0)
RECIPIENTS SUB-FIELD^^1.02^7
"^DD",779.4,779.41,0,"DT")
3040817
"^DD",779.4,779.41,0,"IX","B",774.02,.01)

"^DD",779.4,779.41,0,"IX","B",779.41,.01)

"^DD",779.4,779.41,0,"NM","RECIPIENTS")

"^DD",779.4,779.41,0,"UP")
779.4
"^DD",779.4,779.41,.01,0)
RECEIVING APPLICATON^MRF^^0;1^K:$L(X)>60!($L(X)<1) X
"^DD",779.4,779.41,.01,1,0)
^.1
"^DD",779.4,779.41,.01,1,1,0)
779.41^B
"^DD",779.4,779.41,.01,1,1,1)
S ^HLS(779.4,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",779.4,779.41,.01,1,1,2)
K ^HLS(779.4,DA(1),2,"B",$E(X,1,30),DA)
"^DD",779.4,779.41,.01,3)
Enter the name of the application that will receive the message, up to 60 characters.
"^DD",779.4,779.41,.01,"DT")
3040817
"^DD",779.4,779.41,.02,0)
LOGICAL LINK^RP870'^HLCS(870,^0;2^Q
"^DD",779.4,779.41,.02,3)
Over which communication link should the messages be sent?
"^DD",779.4,779.41,.02,"DT")
3040527
"^DD",779.4,779.41,.03,0)
RECEIVING FACILITY COMPONENT 1^F^^0;3^K:$L(X)>50!($L(X)<1) X
"^DD",779.4,779.41,.03,3)
Answer must be 1-50 characters in length
"^DD",779.4,779.41,.03,21,0)
^^2^2^3040526^
"^DD",779.4,779.41,.03,21,1,0)
This is the value that should be placed in component 1 of the receiving
"^DD",779.4,779.41,.03,21,2,0)
facility field of the message header.
"^DD",779.4,779.41,.03,"DT")
3040527
"^DD",779.4,779.41,.04,0)
RECEIVING FACILITY COMPONENT 2^F^^0;4^K:$L(X)>50!($L(X)<1) X
"^DD",779.4,779.41,.04,3)
Answer must be 1-50 characters in length
"^DD",779.4,779.41,.04,21,0)
^^2^2^3040526^
"^DD",779.4,779.41,.04,21,1,0)
This is the value that should be placed in component 2 of the receiving
"^DD",779.4,779.41,.04,21,2,0)
facility field of the message header.
"^DD",779.4,779.41,.04,"DT")
3040527
"^DD",779.4,779.41,.05,0)
RECEIVING FACILITY COMPONENT 3^F^^0;5^K:$L(X)>10!($L(X)<1) X
"^DD",779.4,779.41,.05,3)
Answer must be 1-10 characters in length
"^DD",779.4,779.41,.05,21,0)
^^2^2^3041116^
"^DD",779.4,779.41,.05,21,1,0)
This is the value that should be placed in component 3 of the receiving
"^DD",779.4,779.41,.05,21,2,0)
facility field of the message header.
"^DD",779.4,779.41,.05,"DT")
3041116
"^DD",779.4,779.41,1.01,0)
DATE/TIME ADDED^RD^^1;1^S %DT="ESTXR" D ^%DT S X=Y K:X<1 X
"^DD",779.4,779.41,1.01,3)
Enter the date and time that this recipient was added to the subscription list.
"^DD",779.4,779.41,1.01,"DT")
3040526
"^DD",779.4,779.41,1.02,0)
DATE/TIME TERMINATED^D^^1;2^S %DT="ESTXR" D ^%DT S X=Y K:X<1 X
"^DD",779.4,779.41,1.02,3)
Enter the date and time that this recipient was dropped from the subscription list
"^DD",779.4,779.41,1.02,"DT")
3040526
"^DIC",779.4,779.4,0)
HLO SUBSCRIPTION REGISTRY^779.4
"^DIC",779.4,779.4,0,"GL")
^HLD(779.4,
"^DIC",779.4,779.4,"%",0)
^1.005^^0
"^DIC",779.4,779.4,"%D",0)
^1.001^6^6^3050215^^^
"^DIC",779.4,779.4,"%D",1,0)
This file is used to store static routing lists for messages.  
"^DIC",779.4,779.4,"%D",2,0)
 
"^DIC",779.4,779.4,"%D",3,0)
Static routing lists are lists of recipients that an application may create in
"^DIC",779.4,779.4,"%D",4,0)
advance for its messages.  The alternate routing method is dynamic routing, 
"^DIC",779.4,779.4,"%D",5,0)
whereby the recipient list is created by the application at the time the 
"^DIC",779.4,779.4,"%D",6,0)
message is created.
"^DIC",779.4,"B","HLO SUBSCRIPTION REGISTRY",779.4)

"BLD",980,6)
^107
**END**
**END**
