Released ROR*1*3 SEQ #3
Extracted from mail message
**KIDS**:ROR*1.0*3^

**INSTALL NAME**
ROR*1.0*3
"BLD",4002,0)
ROR*1.0*3^CLINICAL CASE REGISTRIES^0^3030121^y
"BLD",4002,1,0)
^^2^2^3021218^^
"BLD",4002,1,1,0)
This build contains modifications required by the new Race & Ethnicity 
"BLD",4002,1,2,0)
data model.
"BLD",4002,4,0)
^9.64PA^798.1^4
"BLD",4002,4,798,0)
798
"BLD",4002,4,798,222)
y^y^f^^^^n
"BLD",4002,4,798.1,0)
798.1
"BLD",4002,4,798.1,222)
y^y^f^^^^n
"BLD",4002,4,798.4,0)
798.4
"BLD",4002,4,798.4,222)
y^y^f^^^^n
"BLD",4002,4,798.7,0)
798.7
"BLD",4002,4,798.7,222)
y^y^f^^^^n
"BLD",4002,4,"B",798,798)
 
"BLD",4002,4,"B",798.1,798.1)
 
"BLD",4002,4,"B",798.4,798.4)
 
"BLD",4002,4,"B",798.7,798.7)
 
"BLD",4002,"INI")
PRE^RORP003
"BLD",4002,"INIT")
POS^RORP003
"BLD",4002,"KRN",0)
^9.67PA^8989.52^19
"BLD",4002,"KRN",.4,0)
.4
"BLD",4002,"KRN",.401,0)
.401
"BLD",4002,"KRN",.402,0)
.402
"BLD",4002,"KRN",.403,0)
.403
"BLD",4002,"KRN",.5,0)
.5
"BLD",4002,"KRN",.84,0)
.84
"BLD",4002,"KRN",.84,"NM",0)
^9.68A^2^2
"BLD",4002,"KRN",.84,"NM",1,0)
7980000.001^^0
"BLD",4002,"KRN",.84,"NM",2,0)
7980000.002^^0
"BLD",4002,"KRN",.84,"NM","B",7980000.001,1)
 
"BLD",4002,"KRN",.84,"NM","B",7980000.002,2)
 
"BLD",4002,"KRN",3.6,0)
3.6
"BLD",4002,"KRN",3.8,0)
3.8
"BLD",4002,"KRN",9.2,0)
9.2
"BLD",4002,"KRN",9.8,0)
9.8
"BLD",4002,"KRN",9.8,"NM",0)
^9.68A^37^36
"BLD",4002,"KRN",9.8,"NM",1,0)
RORUTL01^^0^B45944047
"BLD",4002,"KRN",9.8,"NM",2,0)
RORERR20^^0^B47811115
"BLD",4002,"KRN",9.8,"NM",3,0)
RORHDT04^^0^B37538188
"BLD",4002,"KRN",9.8,"NM",4,0)
RORHDT05^^0^B14700625
"BLD",4002,"KRN",9.8,"NM",5,0)
RORNTEG^^0^B7630417
"BLD",4002,"KRN",9.8,"NM",6,0)
RORUPD01^^0^B66304446
"BLD",4002,"KRN",9.8,"NM",7,0)
RORUPD50^^0^B12438529
"BLD",4002,"KRN",9.8,"NM",8,0)
RORHL01^^0^B11573225
"BLD",4002,"KRN",9.8,"NM",9,0)
RORUPD06^^0^B11277011
"BLD",4002,"KRN",9.8,"NM",10,0)
RORUTL02^^0^B36984726
"BLD",4002,"KRN",9.8,"NM",12,0)
RORERR^^0^B21685244
"BLD",4002,"KRN",9.8,"NM",13,0)
ROR^^0^B24080532
"BLD",4002,"KRN",9.8,"NM",14,0)
RORENV01^^1^
"BLD",4002,"KRN",9.8,"NM",15,0)
RORENV02^^1^
"BLD",4002,"KRN",9.8,"NM",16,0)
RORPRE01^^1^
"BLD",4002,"KRN",9.8,"NM",17,0)
RORPOS01^^1^
"BLD",4002,"KRN",9.8,"NM",18,0)
RORPOS02^^1^
"BLD",4002,"KRN",9.8,"NM",19,0)
RORPOS03^^1^
"BLD",4002,"KRN",9.8,"NM",20,0)
RORP003^^0^B27841401
"BLD",4002,"KRN",9.8,"NM",21,0)
RORUPD52^^0^B11989001
"BLD",4002,"KRN",9.8,"NM",22,0)
RORUPD51^^0^B27725577
"BLD",4002,"KRN",9.8,"NM",23,0)
RORRP7^^0^B17493831
"BLD",4002,"KRN",9.8,"NM",24,0)
RORLOG^^0^B38852696
"BLD",4002,"KRN",9.8,"NM",25,0)
RORACK^^0^B14435737
"BLD",4002,"KRN",9.8,"NM",26,0)
ROREXPR^^0^B9225176
"BLD",4002,"KRN",9.8,"NM",27,0)
RORLOG01^^0^B3482024
"BLD",4002,"KRN",9.8,"NM",28,0)
RORSET01^^0^B13775834
"BLD",4002,"KRN",9.8,"NM",29,0)
RORUPR1^^0^B71855148
"BLD",4002,"KRN",9.8,"NM",30,0)
RORUTL05^^0^B44301079
"BLD",4002,"KRN",9.8,"NM",31,0)
RORRP4^^0^B20576033
"BLD",4002,"KRN",9.8,"NM",32,0)
RORPUT01^^0^B39223972
"BLD",4002,"KRN",9.8,"NM",33,0)
RORPOSU1^^1^
"BLD",4002,"KRN",9.8,"NM",34,0)
RORTXT^^0^B339606
"BLD",4002,"KRN",9.8,"NM",35,0)
RORHL04^^0^B15650069
"BLD",4002,"KRN",9.8,"NM",36,0)
RORERR10^^0^B64056354
"BLD",4002,"KRN",9.8,"NM",37,0)
RORAPI01^^0^B8664218
"BLD",4002,"KRN",9.8,"NM","B","ROR",13)
 
"BLD",4002,"KRN",9.8,"NM","B","RORACK",25)
 
"BLD",4002,"KRN",9.8,"NM","B","RORAPI01",37)
 
"BLD",4002,"KRN",9.8,"NM","B","RORENV01",14)
 
"BLD",4002,"KRN",9.8,"NM","B","RORENV02",15)
 
"BLD",4002,"KRN",9.8,"NM","B","RORERR",12)
 
"BLD",4002,"KRN",9.8,"NM","B","RORERR10",36)
 
"BLD",4002,"KRN",9.8,"NM","B","RORERR20",2)
 
"BLD",4002,"KRN",9.8,"NM","B","ROREXPR",26)
 
"BLD",4002,"KRN",9.8,"NM","B","RORHDT04",3)
 
"BLD",4002,"KRN",9.8,"NM","B","RORHDT05",4)
 
"BLD",4002,"KRN",9.8,"NM","B","RORHL01",8)
 
"BLD",4002,"KRN",9.8,"NM","B","RORHL04",35)
 
"BLD",4002,"KRN",9.8,"NM","B","RORLOG",24)
 
"BLD",4002,"KRN",9.8,"NM","B","RORLOG01",27)
 
"BLD",4002,"KRN",9.8,"NM","B","RORNTEG",5)
 
"BLD",4002,"KRN",9.8,"NM","B","RORP003",20)
 
"BLD",4002,"KRN",9.8,"NM","B","RORPOS01",17)
 
"BLD",4002,"KRN",9.8,"NM","B","RORPOS02",18)
 
"BLD",4002,"KRN",9.8,"NM","B","RORPOS03",19)
 
"BLD",4002,"KRN",9.8,"NM","B","RORPOSU1",33)
 
"BLD",4002,"KRN",9.8,"NM","B","RORPRE01",16)
 
"BLD",4002,"KRN",9.8,"NM","B","RORPUT01",32)
 
"BLD",4002,"KRN",9.8,"NM","B","RORRP4",31)
 
"BLD",4002,"KRN",9.8,"NM","B","RORRP7",23)
 
"BLD",4002,"KRN",9.8,"NM","B","RORSET01",28)
 
"BLD",4002,"KRN",9.8,"NM","B","RORTXT",34)
 
"BLD",4002,"KRN",9.8,"NM","B","RORUPD01",6)
 
"BLD",4002,"KRN",9.8,"NM","B","RORUPD06",9)
 
"BLD",4002,"KRN",9.8,"NM","B","RORUPD50",7)
 
"BLD",4002,"KRN",9.8,"NM","B","RORUPD51",22)
 
"BLD",4002,"KRN",9.8,"NM","B","RORUPD52",21)
 
"BLD",4002,"KRN",9.8,"NM","B","RORUPR1",29)
 
"BLD",4002,"KRN",9.8,"NM","B","RORUTL01",1)
 
"BLD",4002,"KRN",9.8,"NM","B","RORUTL02",10)
 
"BLD",4002,"KRN",9.8,"NM","B","RORUTL05",30)
 
"BLD",4002,"KRN",19,0)
19
"BLD",4002,"KRN",19.1,0)
19.1
"BLD",4002,"KRN",19.1,"NM",0)
^9.68A^1^1
"BLD",4002,"KRN",19.1,"NM",1,0)
ROR VA IRM^^0
"BLD",4002,"KRN",19.1,"NM","B","ROR VA IRM",1)
 
"BLD",4002,"KRN",101,0)
101
"BLD",4002,"KRN",409.61,0)
409.61
"BLD",4002,"KRN",771,0)
771
"BLD",4002,"KRN",870,0)
870
"BLD",4002,"KRN",8989.51,0)
8989.51
"BLD",4002,"KRN",8989.52,0)
8989.52
"BLD",4002,"KRN",8994,0)
8994
"BLD",4002,"KRN","B",.4,.4)
 
"BLD",4002,"KRN","B",.401,.401)
 
"BLD",4002,"KRN","B",.402,.402)
 
"BLD",4002,"KRN","B",.403,.403)
 
"BLD",4002,"KRN","B",.5,.5)
 
"BLD",4002,"KRN","B",.84,.84)
 
"BLD",4002,"KRN","B",3.6,3.6)
 
"BLD",4002,"KRN","B",3.8,3.8)
 
"BLD",4002,"KRN","B",9.2,9.2)
 
"BLD",4002,"KRN","B",9.8,9.8)
 
"BLD",4002,"KRN","B",19,19)
 
"BLD",4002,"KRN","B",19.1,19.1)
 
"BLD",4002,"KRN","B",101,101)
 
"BLD",4002,"KRN","B",409.61,409.61)
 
"BLD",4002,"KRN","B",771,771)
 
"BLD",4002,"KRN","B",870,870)
 
"BLD",4002,"KRN","B",8989.51,8989.51)
 
"BLD",4002,"KRN","B",8989.52,8989.52)
 
"BLD",4002,"KRN","B",8994,8994)
 
"BLD",4002,"PRE")
RORP003
"BLD",4002,"PRET")
 
"BLD",4002,"QUES",0)
^9.62^^
"BLD",4002,"REQB",0)
^9.611^3^3
"BLD",4002,"REQB",1,0)
ROR*1.0*2^2
"BLD",4002,"REQB",2,0)
DG*5.3*415^2
"BLD",4002,"REQB",3,0)
SD*5.3*254^2
"BLD",4002,"REQB","B","DG*5.3*415",2)
 
"BLD",4002,"REQB","B","ROR*1.0*2",1)
 
"BLD",4002,"REQB","B","SD*5.3*254",3)
 
"FIA",798)
ROR LOCAL REGISTRY
"FIA",798,0)
^RORDATA(798,
"FIA",798,0,0)
798PAs
"FIA",798,0,1)
y^y^f^^^^n
"FIA",798,0,10)
 
"FIA",798,0,11)
 
"FIA",798,0,"RLRO")
 
"FIA",798,0,"VR")
1.0^ROR
"FIA",798,798)
0
"FIA",798,798.01)
0
"FIA",798.1)
ROR REGISTRY PARAMETERS
"FIA",798.1,0)
^ROR(798.1,
"FIA",798.1,0,0)
798.1Is
"FIA",798.1,0,1)
y^y^f^^^^n
"FIA",798.1,0,10)
 
"FIA",798.1,0,11)
 
"FIA",798.1,0,"RLRO")
 
"FIA",798.1,0,"VR")
1.0^ROR
"FIA",798.1,798.1)
0
"FIA",798.1,798.11)
0
"FIA",798.1,798.112)
0
"FIA",798.1,798.114)
0
"FIA",798.1,798.116)
0
"FIA",798.1,798.117)
0
"FIA",798.1,798.118)
0
"FIA",798.1,798.13)
0
"FIA",798.1,798.15)
0
"FIA",798.1,798.19)
0
"FIA",798.4)
ROR PATIENT
"FIA",798.4,0)
^RORDATA(798.4,
"FIA",798.4,0,0)
798.4Ps
"FIA",798.4,0,1)
y^y^f^^^^n
"FIA",798.4,0,10)
 
"FIA",798.4,0,11)
 
"FIA",798.4,0,"RLRO")
 
"FIA",798.4,0,"VR")
1.0^ROR
"FIA",798.4,798.4)
0
"FIA",798.7)
ROR LOG
"FIA",798.7,0)
^RORDATA(798.7,
"FIA",798.7,0,0)
798.7Ds
"FIA",798.7,0,1)
y^y^f^^^^n
"FIA",798.7,0,10)
 
"FIA",798.7,0,11)
 
"FIA",798.7,0,"RLRO")
 
"FIA",798.7,0,"VR")
1.0^ROR
"FIA",798.7,798.7)
0
"FIA",798.7,798.73)
0
"FIA",798.7,798.74)
0
"FIA",798.7,798.744)
0
"INI")
PRE^RORP003
"INIT")
POS^RORP003
"IX",798,798,"KEY",0)
798^KEY^Uniqueness Index for Key 'A' of File #798^R^^R^IR^I^798^^^^^LS
"IX",798,798,"KEY",.1,0)
^^3^3^3011005^
"IX",798,798,"KEY",.1,1,0)
This index guarantees uniqueness of the patient 
"IX",798,798,"KEY",.1,2,0)
record in the particular registry and allows to 
"IX",798,798,"KEY",.1,3,0)
easily find this record.
"IX",798,798,"KEY",1)
S ^RORDATA(798,"KEY",X(1),X(2),DA)=""
"IX",798,798,"KEY",2)
K ^RORDATA(798,"KEY",X(1),X(2),DA)
"IX",798,798,"KEY",2.5)
K ^RORDATA(798,"KEY")
"IX",798,798,"KEY",11.1,0)
^.114IA^2^2
"IX",798,798,"KEY",11.1,1,0)
1^F^798^.01^^1
"IX",798,798,"KEY",11.1,2,0)
2^F^798^.02^^2
"IX",798.1,798.1,"B",0)
798.1^B^Uniqueness Index for the "A" Key of the File # 798.1^R^^F^IR^I^798.1^^^^^LS
"IX",798.1,798.1,"B",1)
S ^ROR(798.1,"B",X,DA)=""
"IX",798.1,798.1,"B",2)
K ^ROR(798.1,"B",X,DA)
"IX",798.1,798.1,"B",2.5)
K ^ROR(798.1,"B")
"IX",798.1,798.1,"B",11.1,0)
^.114IA^1^1
"IX",798.1,798.1,"B",11.1,1,0)
1^F^798.1^.01^^1
"IX",798.1,798.13,"B",0)
798.13^B^Uniqueness Index for the "A" Key of Subfile #798.13^R^^F^IR^I^798.13^^^^^LS
"IX",798.1,798.13,"B",1)
S ^ROR(798.1,DA(1),1,"B",X,DA)=""
"IX",798.1,798.13,"B",2)
K ^ROR(798.1,DA(1),1,"B",X,DA)
"IX",798.1,798.13,"B",2.5)
K ^ROR(798.1,DA(1),1,"B")
"IX",798.1,798.13,"B",11.1,0)
^.114IA^1^1
"IX",798.1,798.13,"B",11.1,1,0)
1^F^798.13^.01^^1
"IX",798.1,798.19,"KEY",0)
798.19^KEY^Uniqueness Index for the "A" Key of Subfile #798.19^R^^R^IR^I^798.19^^^^^LS
"IX",798.1,798.19,"KEY",1)
S ^ROR(798.1,DA(1),6,"KEY",X(1),X(2),DA)=""
"IX",798.1,798.19,"KEY",2)
K ^ROR(798.1,DA(1),6,"KEY",X(1),X(2),DA)
"IX",798.1,798.19,"KEY",2.5)
K ^ROR(798.1,DA(1),6,"KEY")
"IX",798.1,798.19,"KEY",11.1,0)
^.114IA^2^2
"IX",798.1,798.19,"KEY",11.1,1,0)
1^F^798.19^.02^^1
"IX",798.1,798.19,"KEY",11.1,2,0)
2^F^798.19^.01^^2
"IX",798.7,798.7,"ARD",0)
798.7^ARD^Registry & Start date^R^^R^IR^W^798.73^^^^^S
"IX",798.7,798.7,"ARD",.1,0)
^^2^2^3011011^^
"IX",798.7,798.7,"ARD",.1,1,0)
This index can be used to get a chronological list
"IX",798.7,798.7,"ARD",.1,2,0)
of logs associated with the particular registry.
"IX",798.7,798.7,"ARD",1)
S ^RORDATA(798.7,"ARD",X(1),X(2),DA(1),DA)=""
"IX",798.7,798.7,"ARD",2)
K ^RORDATA(798.7,"ARD",X(1),X(2),DA(1),DA)
"IX",798.7,798.7,"ARD",2.5)
K ^RORDATA(798.7,"ARD")
"IX",798.7,798.7,"ARD",11.1,0)
^.114IA^2^2
"IX",798.7,798.7,"ARD",11.1,1,0)
1^F^798.73^.01^^1^F
"IX",798.7,798.7,"ARD",11.1,2,0)
2^C^^^^2
"IX",798.7,798.7,"ARD",11.1,2,1.5)
S X=$P($G(^RORDATA(798.7,DA(1),0)),U)
"KEY",798,798,"A",0)
798^A^P^100
"KEY",798,798,"A",2,0)
^.312IA^2^2
"KEY",798,798,"A",2,1,0)
.01^798^1
"KEY",798,798,"A",2,2,0)
.02^798^2
"KEY",798.1,798.1,"A",0)
798.1^A^P^101
"KEY",798.1,798.1,"A",2,0)
^.312IA^1^1
"KEY",798.1,798.1,"A",2,1,0)
.01^798.1^1
"KEY",798.1,798.13,"A",0)
798.13^A^P^102
"KEY",798.1,798.13,"A",2,0)
^.312IA^1^1
"KEY",798.1,798.13,"A",2,1,0)
.01^798.13^1
"KEY",798.1,798.19,"A",0)
798.19^A^P^113
"KEY",798.1,798.19,"A",2,0)
^.312IA^2^2
"KEY",798.1,798.19,"A",2,1,0)
.02^798.19^1
"KEY",798.1,798.19,"A",2,2,0)
.01^798.19^2
"KEYPTR",798,798,"A")
798^KEY
"KEYPTR",798.1,798.1,"A")
798.1^B
"KEYPTR",798.1,798.13,"A")
798.13^B
"KEYPTR",798.1,798.19,"A")
798.19^KEY
"KRN",.84,7980000.001,-1)
0^1
"KRN",.84,7980000.001,0)
7980000.001^1^^CLINICAL CASE REGISTRIES^Empty TASK PARAMETERS field
"KRN",.84,7980000.001,2,0)
^^3^3^3021213^
"KRN",.84,7980000.001,2,1,0)
You must enter registry name(s) into the TASK PARAMETERS field
"KRN",.84,7980000.001,2,2,0)
during scheduling the task. If several names are entered, they
"KRN",.84,7980000.001,2,3,0)
should be separated by commas.
"KRN",.84,7980000.001,5,0)
^.841^1^1
"KRN",.84,7980000.001,5,1,0)
ROR^TASK
"KRN",.84,7980000.001,5,"B","ROR",1)
 
"KRN",.84,7980000.002,-1)
0^2
"KRN",.84,7980000.002,0)
7980000.002^1^^CLINICAL CASE REGISTRIES^Awaiting ACK
"KRN",.84,7980000.002,2,0)
^^3^3^3021213^
"KRN",.84,7980000.002,2,1,0)
If you see this error several times in a row, first of all check
"KRN",.84,7980000.002,2,2,0)
if the ROR SEND HL7 link is started and messages are actually sent
"KRN",.84,7980000.002,2,3,0)
to AAC. Then contact AAC to resolve the transmission problem(s).
"KRN",.84,7980000.002,5,0)
^.841^1^1
"KRN",.84,7980000.002,5,1,0)
RORUTL02^ARLST
"KRN",.84,7980000.002,5,"B","RORUTL02",1)
 
"KRN",19.1,440,-1)
0^1
"KRN",19.1,440,0)
ROR VA IRM^Clinical Case Registry Support^l
"KRN",19.1,440,1,0)
^19.11^3^3^3021223^^^
"KRN",19.1,440,1,1,0)
This security key should be assigned to the IRM personnel designated to 
"KRN",19.1,440,1,2,0)
support the Clinical Case Registry application (patch installation, 
"KRN",19.1,440,1,3,0)
troubleshooting, etc).
"MBREQ")
0
"ORD",0,9.8)
9.8;;1;RTNF^XPDTA;RTNE^XPDTA
"ORD",0,9.8,0)
ROUTINE
"ORD",3,19.1)
19.1;3;1;;KEY^XPDTA1;;;;;KEYDEL^XPDIA1
"ORD",3,19.1,0)
SECURITY KEY
"ORD",9,.84)
.84;9;;;EDEOUT^DIFROMSO(.84,DA,"",XPDA);FPRE^DIFROMSI(.84,"",XPDA);EPRE^DIFROMSI(.84,DA,"",XPDA,"",OLDA);;EPOST^DIFROMSI(.84,DA,"",XPDA);DEL^DIFROMSK(.84,"",%)
"ORD",9,.84,0)
DIALOG
"PKG",389,-1)
1^1
"PKG",389,0)
CLINICAL CASE REGISTRIES^ROR^CLINICAL CASE REGISTRIES
"PKG",389,20,0)
^9.402P^^
"PKG",389,22,0)
^9.49I^1^1
"PKG",389,22,1,0)
1.0^3020515^3020726^222222227
"PKG",389,22,1,"PAH",1,0)
3^3030121^222222227
"PKG",389,22,1,"PAH",1,1,0)
^^2^2^3030121
"PKG",389,22,1,"PAH",1,1,1,0)
This build contains modifications required by the new Race & Ethnicity 
"PKG",389,22,1,"PAH",1,1,2,0)
data model.
"PRE")
RORP003
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")
 
"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
36
"RTN","ROR")
0^13^B24080532
"RTN","ROR",1,0)
ROR ;HCIOFO/SG - CLINICAL REGISTRIES ; 12/13/02 11:21am
"RTN","ROR",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3**;May 14, 2002
"RTN","ROR",3,0)
 ;
"RTN","ROR",4,0)
 ; RORERRDL ------------ DEFAULT ERROR LOCATION
"RTN","ROR",5,0)
 ;
"RTN","ROR",6,0)
 ; RORERROR ------------ ERROR PROCESSING DATA
"RTN","ROR",7,0)
 ;
"RTN","ROR",8,0)
 ; RORERROR("ES",        Index of the top of the stack
"RTN","ROR",9,0)
 ;   Index,                ^1: Error code
"RTN","ROR",10,0)
 ;                         ^2: Message text
"RTN","ROR",11,0)
 ;     1)                Place of the error (LABEL^ROUTINE)
"RTN","ROR",12,0)
 ;     2,Seq#)           Additional information (opt'l)
"RTN","ROR",13,0)
 ;
"RTN","ROR",14,0)
 ; RORERROR("DBS",       The $$DBS^RORERR function stores a list of
"RTN","ROR",15,0)
 ;   ErrCode)            FileMan DBS error codes here (as subnodes).
"RTN","ROR",16,0)
 ;
"RTN","ROR",17,0)
 ; RORPARM ------------- PACKAGE-WIDE CONSTANTS AND VARIABLES
"RTN","ROR",18,0)
 ;
"RTN","ROR",19,0)
 ; RORPARM("DEBUG")      Debug mode (opt'l):
"RTN","ROR",20,0)
 ;                         0  Disabled (default)
"RTN","ROR",21,0)
 ;                         1  Enabled
"RTN","ROR",22,0)
 ;                         2  Enabled; and all messages are not only
"RTN","ROR",23,0)
 ;                            logged but displayed on the screen too
"RTN","ROR",24,0)
 ;                         3  The same as 2 but registry update or
"RTN","ROR",25,0)
 ;                            data extraction is aborted immediately
"RTN","ROR",26,0)
 ;                            after processing a patient with errors
"RTN","ROR",27,0)
 ;
"RTN","ROR",28,0)
 ; RORPARM("DEVELOPER")  If this node is defined and not zero,
"RTN","ROR",29,0)
 ;                       national definitions (registry parameters,
"RTN","ROR",30,0)
 ;                       selection rules, etc) can be edited.
"RTN","ROR",31,0)
 ;                       Otherwise, editing is prohibited.
"RTN","ROR",32,0)
 ;
"RTN","ROR",33,0)
 ; RORPARM("ERR")        Enable/disable extended error processing:
"RTN","ROR",34,0)
 ;                         0  Disabled (default)
"RTN","ROR",35,0)
 ;                         1  Enabled
"RTN","ROR",36,0)
 ;
"RTN","ROR",37,0)
 ; RORPARM("KIDS",       This node is defined and non-zero only during
"RTN","ROR",38,0)
 ;                       the KIDS installation process:
"RTN","ROR",39,0)
 ;                         1  Pre-install
"RTN","ROR",40,0)
 ;                         2  Post-install
"RTN","ROR",41,0)
 ;   ParamName)          Value of an installation parameter
"RTN","ROR",42,0)
 ;
"RTN","ROR",43,0)
 ; RORPARM("LOG",        Enable/disable log collection:
"RTN","ROR",44,0)
 ;                         0  Disabled (default)
"RTN","ROR",45,0)
 ;                         1  Enabled
"RTN","ROR",46,0)
 ;   Type)               Enable (1) collection of only particular
"RTN","ROR",47,0)
 ;                       events (optional, all events by default)
"RTN","ROR",48,0)
 ;                       See the LOG EVENTS field in the ROR REGISTRY
"RTN","ROR",49,0)
 ;                       PARAMETERS file #798.1 for possible values.
"RTN","ROR",50,0)
 ;
"RTN","ROR",51,0)
 ; RORPARM("SETUP")      This node is defined and non-zero only
"RTN","ROR",52,0)
 ;                       during the registry setup.
"RTN","ROR",53,0)
 ;
"RTN","ROR",54,0)
 ; TEMPORARY NODE ------ DESCRIPTION
"RTN","ROR",55,0)
 ;
"RTN","ROR",56,0)
 ; ^TMP("RORACK")        Control data of acknowledgement processing
"RTN","ROR",57,0)
 ; ^TMP("RORHDT")        Control data of historical data extraction
"RTN","ROR",58,0)
 ; ^TMP("RORTMP")        Temporary storage
"RTN","ROR",59,0)
 ; ^TMP("RORUPD")        Registry update temporary data
"RTN","ROR",60,0)
 ;
"RTN","ROR",61,0)
 ; ^XTMP("RORHDT")       Control data of historical data extraction
"RTN","ROR",62,0)
 ; ^XTMP("RORUPDJ")      Registry update temporary data (multitask)
"RTN","ROR",63,0)
 ; ^XTMP("RORUPDR")      Registry update temporary data (installation)
"RTN","ROR",64,0)
 ;
"RTN","ROR",65,0)
 ; See detailed description of the temporary global nodes in
"RTN","ROR",66,0)
 ; the source code of the ^ROR01 routine.
"RTN","ROR",67,0)
 ;
"RTN","ROR",68,0)
 ; NAMESPACE ----------- DESCRIPTION
"RTN","ROR",69,0)
 ;
"RTN","ROR",70,0)
 ; RORACK*               Acknowldgement processing
"RTN","ROR",71,0)
 ; RORAPI*               Supported APIs
"RTN","ROR",72,0)
 ; RORDD*                Routines used by the Data Dictionary
"RTN","ROR",73,0)
 ; RORERR*               Error processing
"RTN","ROR",74,0)
 ; ROREVT*               Event protocols
"RTN","ROR",75,0)
 ; ROREX*                Regular data extraction & transmission
"RTN","ROR",76,0)
 ; RORHDT*               Historical data extraction
"RTN","ROR",77,0)
 ; RORHL*                HL7
"RTN","ROR",78,0)
 ; RORKIDS*              Low-level installation utilities (KIDS)
"RTN","ROR",79,0)
 ; RORLOG*               Error recording
"RTN","ROR",80,0)
 ;
"RTN","ROR",81,0)
 ; RORPnnn               Patch installation routines (KIDS)
"RTN","ROR",82,0)
 ;                         nnn - patch number
"RTN","ROR",83,0)
 ; RORPEnnn              Environment check routines
"RTN","ROR",84,0)
 ; RORPOnnn              Post-install routines
"RTN","ROR",85,0)
 ; RORPRnnn              Pre-install routines
"RTN","ROR",86,0)
 ; RORPUT*               High-level installation utilities
"RTN","ROR",87,0)
 ;
"RTN","ROR",88,0)
 ; RORRP*                Remote procedures
"RTN","ROR",89,0)
 ; RORSET*               Setup routines
"RTN","ROR",90,0)
 ; RORTXT*               Text resource routines
"RTN","ROR",91,0)
 ; RORUP*                Registry update
"RTN","ROR",92,0)
 ; RORUTL*               Utilities
"RTN","ROR",93,0)
 ;
"RTN","ROR",94,0)
 ; MENU OPTION --------- DESCRIPTION
"RTN","ROR",95,0)
 ;
"RTN","ROR",96,0)
 ; [ROR TASK]            Registry update and data extraction option
"RTN","ROR",97,0)
 ;                       (must be scheduled; do not run it directly)
"RTN","ROR",98,0)
 ; [ROR SETUP HEPC]      Setup the HepC registry
"RTN","ROR",99,0)
 ; [RORHDT MAIN]         Historical data extraction menu
"RTN","ROR",100,0)
 ; [RORMNT MAIN]         Maintenance menu
"RTN","ROR",101,0)
 ;
"RTN","ROR",102,0)
 ; SPECIAL ENTRY POINT - DESCRIPTION
"RTN","ROR",103,0)
 ;
"RTN","ROR",104,0)
 ;    START^RORTSITE     Prepares test sites for going live
"RTN","ROR",105,0)
 ;         ^RORUTL06     Registry definition validator
"RTN","ROR",106,0)
 ; DISTPREP^RORUTL06     Prepares registry parameters for KIDS distr.
"RTN","ROR",107,0)
 ;   PRTMDE^RORUTL06     Prints the data element metadata
"RTN","ROR",108,0)
 ;
"RTN","ROR",109,0)
 ;  EXTRACT^RORUTL07     Data extraction & transmission in debug mode
"RTN","ROR",110,0)
 ;   UPDATE^RORUTL07     Registry update in debug mode
"RTN","ROR",111,0)
 ;
"RTN","ROR",112,0)
 ; INITIALS ------------ DEVELOPER
"RTN","ROR",113,0)
 ;
"RTN","ROR",114,0)
 ; BH                    Brent Hicks
"RTN","ROR",115,0)
 ; CRT                   Cameron Taylor
"RTN","ROR",116,0)
 ; SG                    Sergey Gavrilov
"RTN","ROR",117,0)
 ;
"RTN","ROR",118,0)
 Q
"RTN","ROR",119,0)
 ;
"RTN","ROR",120,0)
 ;***** REGISTRY UPDATE AND DATA EXTRACTION TASK
"RTN","ROR",121,0)
 ;
"RTN","ROR",122,0)
 ; ZTQPARAM      String that contains a list of registry names
"RTN","ROR",123,0)
 ;               separated by commas. You must define the list as
"RTN","ROR",124,0)
 ;               a value of the TASK PARAMETERS field during
"RTN","ROR",125,0)
 ;               scheduling of the [ROR TASK] option that uses
"RTN","ROR",126,0)
 ;               this entry point.
"RTN","ROR",127,0)
 ;
"RTN","ROR",128,0)
 ; The following task parameters are optional. They can be defined
"RTN","ROR",129,0)
 ; on the second page of the option scheduling form as the pairs of
"RTN","ROR",130,0)
 ; variable names and values. See description of the ROR TASK option
"RTN","ROR",131,0)
 ; for more details regarding these parameters.
"RTN","ROR",132,0)
 ;
"RTN","ROR",133,0)
 ; [RORFLCLR]    Clear flags to control processing.
"RTN","ROR",134,0)
 ; [RORFLSET]    Set flags to control processing.
"RTN","ROR",135,0)
 ;
"RTN","ROR",136,0)
 ; [RORMNTSK]    Maximum number of the registry update subtasks.
"RTN","ROR",137,0)
 ;               The default value of the parameter is "2-3-AUTO".
"RTN","ROR",138,0)
 ;
"RTN","ROR",139,0)
 ; [RORSUSP]     Suspension parameters of the registry update sub-
"RTN","ROR",140,0)
 ;               tasks. The subtasks are not suspended by default.
"RTN","ROR",141,0)
 ;
"RTN","ROR",142,0)
TASK ;
"RTN","ROR",143,0)
 N RORERROR      ; Error processing data
"RTN","ROR",144,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","ROR",145,0)
 N RORPARM       ; Application parameters
"RTN","ROR",146,0)
 ;
"RTN","ROR",147,0)
 N CNT,I,RC,REGLST,REGNAME,RGEXLST  K ZTREQ
"RTN","ROR",148,0)
 ;--- Initialize constants and variables
"RTN","ROR",149,0)
 D INIT^RORUTL01("ROR",1)
"RTN","ROR",150,0)
 ;S RORPARM("DEBUG")=1 ; Remove the first ';' to start in debug mode
"RTN","ROR",151,0)
 S RORPARM("ERR")=1
"RTN","ROR",152,0)
 ;--- Open a new log
"RTN","ROR",153,0)
 S RC=$$SETUP^RORLOG(),RC=$$OPEN^RORLOG(,,"ROR TASK STARTED")
"RTN","ROR",154,0)
 ;--- Check the task parameters
"RTN","ROR",155,0)
 I $G(ZTQPARAM)?." "  D  K ZTQPARAM  S RC=ZTQPARAM
"RTN","ROR",156,0)
 . N INFO  D TEXT^RORTXT(7980000.001,.INFO)
"RTN","ROR",157,0)
 . S RC=$$ERROR^RORERR(-88,"TASK^ROR",.INFO,,"TASK PARAMETERS")
"RTN","ROR",158,0)
 S RORFLCLR=$G(RORFLCLR)
"RTN","ROR",159,0)
 S RORFLSET=$G(RORFLSET)
"RTN","ROR",160,0)
 S RORMNTSK=$S($G(RORMNTSK)'="":$TR(RORMNTSK,"-","^"),1:"2^3^AUTO")
"RTN","ROR",161,0)
 I $G(RORSUSP)'=""  D
"RTN","ROR",162,0)
 . N %DT,DTOUT,TMP,X,Y
"RTN","ROR",163,0)
 . S TMP=RORSUSP,RORSUSP=""
"RTN","ROR",164,0)
 . F I=1,2  D  S:$G(Y)>0 $P(RORSUSP,"^",I)=Y#1
"RTN","ROR",165,0)
 . . S X=$P(TMP,"-",I),%DT="R"  D ^%DT
"RTN","ROR",166,0)
 E  S RORSUSP=""
"RTN","ROR",167,0)
 ;--- Extract registry names from the task parameters
"RTN","ROR",168,0)
 F I=1:1  S REGNAME=$P(ZTQPARAM,",",I)  Q:REGNAME=""  D
"RTN","ROR",169,0)
 . S REGNAME=$$TRIM^XLFSTR(REGNAME)
"RTN","ROR",170,0)
 . S:REGNAME'="" REGLST(REGNAME)=""
"RTN","ROR",171,0)
 ;--- Associate the log with the registries
"RTN","ROR",172,0)
 S RC=$$SETRGLST^RORLOG(.REGLST)
"RTN","ROR",173,0)
 ;--- Rebuild the "ACL" cross-reference
"RTN","ROR",174,0)
 S RC=$$RNDXACL^RORUTL05()
"RTN","ROR",175,0)
 ;--- Clear expired 'Awaiting Acknowledgement' flags
"RTN","ROR",176,0)
 S RC=$$CLRACK^RORUTL05(.REGLST)
"RTN","ROR",177,0)
 ;--- Update the registries
"RTN","ROR",178,0)
 S RC=$$UPDATE^RORUPD(.REGLST,.RGEXLST,RORMNTSK,RORSUSP,RORFLCLR,RORFLSET)
"RTN","ROR",179,0)
 ;--- Process the errors
"RTN","ROR",180,0)
 I RC<0  D  G:RC<0 ABORT
"RTN","ROR",181,0)
 . ;--- Quit if stop is requested (via the TaskMan User option)
"RTN","ROR",182,0)
 . I RC=-42  D ALERT^RORUTL01(.REGLST,-42)  S ZTSTOP=1  Q
"RTN","ROR",183,0)
 . ;--- Do not send the alert for some warnings
"RTN","ROR",184,0)
 . I RC=-28  S RC=0  Q
"RTN","ROR",185,0)
 . ;--- Send the alert in case of other errors/warnings
"RTN","ROR",186,0)
 . D ALERT^RORUTL01(.REGLST,-43,,,,"registry update")
"RTN","ROR",187,0)
 . S RC=0
"RTN","ROR",188,0)
 ;--- Mark registry records 3 weeks after the installation so that
"RTN","ROR",189,0)
 ;    the local registry data and demographic data will be resent
"RTN","ROR",190,0)
 ;--- to restore the data overwritten with the historical data
"RTN","ROR",191,0)
 S RC=$$REMARK^RORUTL05(.RGEXLST,21)
"RTN","ROR",192,0)
 ;--- Schedule the data extraction task(s)
"RTN","ROR",193,0)
 S REGNAME=""  K ZTSAVE
"RTN","ROR",194,0)
 F CNT=1:1  S REGNAME=$O(RGEXLST(REGNAME))  Q:REGNAME=""  D
"RTN","ROR",195,0)
 . S ZTRTN="TASK^ROREXT",ZTIO=""
"RTN","ROR",196,0)
 . S ZTDTH=$$FMADD^XLFDT($$NOW^XLFDT,,,,(CNT-1)*30)
"RTN","ROR",197,0)
 . S ZTDESC="Data Extraction ("_REGNAME_")"
"RTN","ROR",198,0)
 . S ZTSAVE("RORREG")=REGNAME
"RTN","ROR",199,0)
 . D ^%ZTLOAD
"RTN","ROR",200,0)
 ;--- Purge the old logs
"RTN","ROR",201,0)
 S RC=$$PURGE^RORLOG(14)
"RTN","ROR",202,0)
 ;--- Purge the old event references
"RTN","ROR",203,0)
 S RC=$$EPDATE^RORUTL05()
"RTN","ROR",204,0)
 S:RC>0 RC=$$PURGE^RORUPP02(RC)
"RTN","ROR",205,0)
 ;---
"RTN","ROR",206,0)
 S ZTREQ="@"
"RTN","ROR",207,0)
ABORT ;
"RTN","ROR",208,0)
 S I=$S($G(ZTREQ)="@":"COMPLETED",1:"ABORTED")
"RTN","ROR",209,0)
 D CLOSE^RORLOG("ROR TASK "_I)
"RTN","ROR",210,0)
 Q
"RTN","RORACK")
0^25^B14435737
"RTN","RORACK",1,0)
RORACK ;HCIOFO/SG - ACKNOWLEDGEMENT PROCESSING ; 12/13/02 2:29pm
"RTN","RORACK",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORACK",3,0)
 ;
"RTN","RORACK",4,0)
 Q
"RTN","RORACK",5,0)
 ;
"RTN","RORACK",6,0)
 ;***** PROCESSES THE BATCH HEADER OF THE ACKNOWLEDGEMENT
"RTN","RORACK",7,0)
 ;
"RTN","RORACK",8,0)
 ; .REGLST       Reference to a local variable where the list of
"RTN","RORACK",9,0)
 ;               registries associated with the original batch
"RTN","RORACK",10,0)
 ;               message will be returned to. The list will have
"RTN","RORACK",11,0)
 ;               the following structure:
"RTN","RORACK",12,0)
 ;
"RTN","RORACK",13,0)
 ;                 REGLST(RegistryName)=RegistryIEN^BatchID
"RTN","RORACK",14,0)
 ;
"RTN","RORACK",15,0)
 ; Return Values:
"RTN","RORACK",16,0)
 ;        <0  Error Code
"RTN","RORACK",17,0)
 ;         0  Ok
"RTN","RORACK",18,0)
 ;
"RTN","RORACK",19,0)
HEADER(REGLST) ;
"RTN","RORACK",20,0)
 N CS,FS,I,PROCID,RC,REFMID,REGNAME,RORBUF,RORMSG,TMP
"RTN","RORACK",21,0)
 K REGLST
"RTN","RORACK",22,0)
 ;--- Get the BHS segment
"RTN","RORACK",23,0)
 X HLNEXT
"RTN","RORACK",24,0)
 I (HLQUIT'>0)!($E($G(HLNODE),1,3)'="BHS")  D  Q RC
"RTN","RORACK",25,0)
 . S RC=$$ERROR^RORERR(-68,"HEADER^RORACK")
"RTN","RORACK",26,0)
 S RORBUF=HLNODE,I=""
"RTN","RORACK",27,0)
 F  S I=$O(HLNODE(I))  Q:I=""  S RORBUF=RORBUF_HLNODE(I)
"RTN","RORACK",28,0)
 S FS=$E(RORBUF,4),CS=$E($P(RORBUF,FS,2),1)
"RTN","RORACK",29,0)
 ;--- Load the batch parameters
"RTN","RORACK",30,0)
 S PROCID=$P($P(RORBUF,FS,9),CS,2)
"RTN","RORACK",31,0)
 S REFMID=$P(RORBUF,FS,12)
"RTN","RORACK",32,0)
 ;--- Record some of the parameters
"RTN","RORACK",33,0)
 K RORMSG
"RTN","RORACK",34,0)
 S RORMSG(1)="Message IEN:  "_$G(HLMTIENS)
"RTN","RORACK",35,0)
 S RORMSG(2)="Message ID:   "_$G(HL("MID"))
"RTN","RORACK",36,0)
 S TMP=$$HL7TFM^XLFDT($G(HL("DTM")))
"RTN","RORACK",37,0)
 S RORMSG(3)="Message Date: "_$$FMTE^XLFDT(TMP)
"RTN","RORACK",38,0)
 S RORMSG(4)="Reference ID: "_REFMID
"RTN","RORACK",39,0)
 D LOG^RORLOG(2,"Processing the HL7 batch message",,.RORMSG)
"RTN","RORACK",40,0)
 K RORMSG
"RTN","RORACK",41,0)
 ;--- Check the Processing ID and quit if not 'Production'
"RTN","RORACK",42,0)
 S I=$$UP^XLFSTR(PROCID)
"RTN","RORACK",43,0)
 I I'="P"  D  Q RC
"RTN","RORACK",44,0)
 . S TMP=$S(I="D":"debug",I="T":"training",1:"unknown")
"RTN","RORACK",45,0)
 . S RC=$$ERROR^RORERR(-90,"HEADER^RORACK",,,TMP)
"RTN","RORACK",46,0)
 ;--- Get a list of registries associated with the batch and
"RTN","RORACK",47,0)
 ;--- awaiting application acknowledgements
"RTN","RORACK",48,0)
 S TMP="@;.01;2.1",I="I $P($G(^(0)),U,9)"
"RTN","RORACK",49,0)
 D FIND^DIC(798.1,,TMP,"UX",REFMID,,"AM",I,,"RORBUF","RORMSG")
"RTN","RORACK",50,0)
 Q:$G(DIERR)>0 $$DBS^RORERR("RORMSG",-9,"HEADER^RORACK",,798.1)
"RTN","RORACK",51,0)
 I $G(RORBUF("DILIST",0))'>0  D  Q RC
"RTN","RORACK",52,0)
 . S TMP="Message ID: "_$G(HL("MID"))
"RTN","RORACK",53,0)
 . S RC=$$ERROR^RORERR(-73,"HEADER^RORACK",TMP)
"RTN","RORACK",54,0)
 ;--- Compile the list of registries
"RTN","RORACK",55,0)
 S I=""
"RTN","RORACK",56,0)
 F  S I=$O(RORBUF("DILIST","ID",I))  Q:I=""  D
"RTN","RORACK",57,0)
 . S REGNAME=$G(RORBUF("DILIST","ID",I,.01))  Q:REGNAME=""
"RTN","RORACK",58,0)
 . S $P(REGLST(REGNAME),U,1)=$G(RORBUF("DILIST",2,I))
"RTN","RORACK",59,0)
 . S $P(REGLST(REGNAME),U,2)=$G(RORBUF("DILIST","ID",I,2.1))
"RTN","RORACK",60,0)
 Q 0
"RTN","RORACK",61,0)
 ;
"RTN","RORACK",62,0)
 ;***** PROCESSES HL7 APPLICATION ACKNOWLEDGEMENT
"RTN","RORACK",63,0)
PROCESS ;
"RTN","RORACK",64,0)
 N RORERROR      ; Error processing data
"RTN","RORACK",65,0)
 N RORERRDL      ; Default error location
"RTN","RORACK",66,0)
 N RORLOG        ; Log susbsystem data
"RTN","RORACK",67,0)
 N RORPARM       ; Application parameters
"RTN","RORACK",68,0)
 ;
"RTN","RORACK",69,0)
 N RC,REGLST,TMP
"RTN","RORACK",70,0)
 D INIT^RORUTL01("RORACK"),CLEAR^RORERR("PROCESS^RORACK")
"RTN","RORACK",71,0)
 ;S RORPARM("DEBUG")=1 ; Remove the first ';' to run in debug mode
"RTN","RORACK",72,0)
 S RORPARM("LOG")=1
"RTN","RORACK",73,0)
 ;--- Open a new log
"RTN","RORACK",74,0)
 S TMP=$$OPEN^RORLOG(,3,"ACKNOWLEDGEMENT PROCESSING STARTED")
"RTN","RORACK",75,0)
 D
"RTN","RORACK",76,0)
 . ;--- Process the batch header
"RTN","RORACK",77,0)
 . S RC=$$HEADER(.REGLST)            Q:RC<0
"RTN","RORACK",78,0)
 . ;--- Associate the log with the registries
"RTN","RORACK",79,0)
 . S RC=$$SETRGLST^RORLOG(.REGLST)
"RTN","RORACK",80,0)
 . S:RC<0 RORPARM("LOG")=1
"RTN","RORACK",81,0)
 . ;--- Process the acknowldgements
"RTN","RORACK",82,0)
 . S RC=$$PROCMSG^RORACK01(.REGLST)  Q:RC<0
"RTN","RORACK",83,0)
 . S RC=$$PROCREM^RORACK01(.REGLST)  Q:RC<0
"RTN","RORACK",84,0)
 ;--- Process the errors and update registry parameters
"RTN","RORACK",85,0)
 I (RC'=-73)&(RC'=-90)  D
"RTN","RORACK",86,0)
 . S:RC<0 HLERR="RORACK: Error Code: "_RC
"RTN","RORACK",87,0)
 . S TMP=$$UPDPARMS(.REGLST)
"RTN","RORACK",88,0)
 . I TMP<0  S:RC'<0 RC=TMP
"RTN","RORACK",89,0)
 ;--- Statistics & Cleanup
"RTN","RORACK",90,0)
 S TMP="ACKNOWLEDGEMENT PROCESSING "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","RORACK",91,0)
 D CLOSE^RORLOG(TMP)
"RTN","RORACK",92,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("RORACK")
"RTN","RORACK",93,0)
 Q
"RTN","RORACK",94,0)
 ;
"RTN","RORACK",95,0)
 ;***** UPDATES REGISTRY PARAMETERS
"RTN","RORACK",96,0)
 ;
"RTN","RORACK",97,0)
 ; .REGLST       Reference to a local variable containing a list
"RTN","RORACK",98,0)
 ;               of registries (registry names as the subscripts
"RTN","RORACK",99,0)
 ;               and registry IENs as the values).
"RTN","RORACK",100,0)
 ;
"RTN","RORACK",101,0)
 ; Return Values:
"RTN","RORACK",102,0)
 ;        <0  Error Code
"RTN","RORACK",103,0)
 ;         0  Ok
"RTN","RORACK",104,0)
 ;
"RTN","RORACK",105,0)
UPDPARMS(REGLST) ;
"RTN","RORACK",106,0)
 N IR,RC,REGIENS,RORFDA,RORMSG
"RTN","RORACK",107,0)
 S IR="",RC=0
"RTN","RORACK",108,0)
 F  S IR=$O(REGLST(IR))  Q:IR=""  D  Q:RC<0
"RTN","RORACK",109,0)
 . S REGIENS=+REGLST(IR)_","  Q:REGIENS'>0
"RTN","RORACK",110,0)
 . S RORFDA(798.1,REGIENS,2.2)="@"
"RTN","RORACK",111,0)
 . S RORFDA(798.1,REGIENS,2.3)="@"
"RTN","RORACK",112,0)
 . ;--- Update the registry parameters
"RTN","RORACK",113,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORACK",114,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"UPDPARMS^RORACK")
"RTN","RORACK",115,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORAPI01")
0^37^B8664218
"RTN","RORAPI01",1,0)
RORAPI01 ;HCIOFO/SG - CLINICAL REGISTRIES API ; 1/3/03 1:21pm
"RTN","RORAPI01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORAPI01",3,0)
 ;
"RTN","RORAPI01",4,0)
 ;***** EXAMPLE
"RTN","RORAPI01",5,0)
 ;
"RTN","RORAPI01",6,0)
 N IDSC,INCTVDT,RC
"RTN","RORAPI01",7,0)
 W !!,"Patients",!
"RTN","RORAPI01",8,0)
 S RC=$$PATITER^RORAPI01(.IDSC,"VA HEPC")
"RTN","RORAPI01",9,0)
 I RC<0  W "RC= ",RC,!  Q
"RTN","RORAPI01",10,0)
 F  S RC=$$NEXTPAT^RORAPI01(.IDSC)  Q:RC'>0  D
"RTN","RORAPI01",11,0)
 . S INCTVDT=$P(RC,"^",2)
"RTN","RORAPI01",12,0)
 . W !,$J(+RC,10),$S(INCTVDT:"  "_INCTVDT,1:"")
"RTN","RORAPI01",13,0)
 ;
"RTN","RORAPI01",14,0)
 W !!,"Registries",!
"RTN","RORAPI01",15,0)
 S RC=$$REGITER^RORAPI01(.IDSC,2)
"RTN","RORAPI01",16,0)
 I RC<0  W "RC= ",RC,!  Q
"RTN","RORAPI01",17,0)
 F  S RC=$$NEXTREG^RORAPI01(.IDSC)  Q:RC'>0  D
"RTN","RORAPI01",18,0)
 . S INCTVDT=$P(RC,"^",2)
"RTN","RORAPI01",19,0)
 . W !,$J(+RC,10),$S(INCTVDT:"  "_INCTVDT,1:"")
"RTN","RORAPI01",20,0)
 Q
"RTN","RORAPI01",21,0)
 ;
"RTN","RORAPI01",22,0)
 ;***** RETURNS THE NEXT PATIENT IN THE REGISTRY
"RTN","RORAPI01",23,0)
 ;
"RTN","RORAPI01",24,0)
 ; .IDESC        Reference to the iterator descriptor created
"RTN","RORAPI01",25,0)
 ;               by PATITER^RORAPI01
"RTN","RORAPI01",26,0)
 ;
"RTN","RORAPI01",27,0)
 ; Return Values:
"RTN","RORAPI01",28,0)
 ;       <0  Error code
"RTN","RORAPI01",29,0)
 ;       ""  No more patients in the registry
"RTN","RORAPI01",30,0)
 ;       >0  Patient IEN^Inactivation Date
"RTN","RORAPI01",31,0)
 ;
"RTN","RORAPI01",32,0)
NEXTPAT(IDESC) ;
"RTN","RORAPI01",33,0)
 N BUF,INDT,RC
"RTN","RORAPI01",34,0)
 S RC=0
"RTN","RORAPI01",35,0)
 F  D  Q:RC
"RTN","RORAPI01",36,0)
 . ; Get an IEN of the next record in the registry
"RTN","RORAPI01",37,0)
 . S IDESC("IEN")=$O(^RORDATA(798,"AC",IDESC("REGIEN"),IDESC("IEN")))
"RTN","RORAPI01",38,0)
 . I IDESC("IEN")'>0  S RC="1^END"  Q
"RTN","RORAPI01",39,0)
 . ;--- Load values of the fields
"RTN","RORAPI01",40,0)
 . S BUF=$G(^RORDATA(798,IDESC("IEN"),0)),INDT=$P(BUF,U,4)
"RTN","RORAPI01",41,0)
 . ;--- Screen records
"RTN","RORAPI01",42,0)
 . I $$ACTIVE^RORDD(INDT,$P(BUF,U,11))  S:IDESC("ACT") RC=$P(BUF,U)
"RTN","RORAPI01",43,0)
 . E  S:IDESC("INACT") RC=$P(BUF,U)_"^"_INDT
"RTN","RORAPI01",44,0)
 Q $S(RC="1^END":"",1:RC)
"RTN","RORAPI01",45,0)
 ;
"RTN","RORAPI01",46,0)
 ;***** RETURNS THE NEXT REGISTRY FOR THE PATIENT
"RTN","RORAPI01",47,0)
 ;
"RTN","RORAPI01",48,0)
 ; .IDESC        Reference to the iterator descriptor created
"RTN","RORAPI01",49,0)
 ;               by REGITER^RORAPI01
"RTN","RORAPI01",50,0)
 ;
"RTN","RORAPI01",51,0)
 ; Return Values:
"RTN","RORAPI01",52,0)
 ;       <0  Error code
"RTN","RORAPI01",53,0)
 ;       ""  No more registries for the patient
"RTN","RORAPI01",54,0)
 ;       >0  Registry IEN^Inactivation Date
"RTN","RORAPI01",55,0)
 ;
"RTN","RORAPI01",56,0)
NEXTREG(IDESC) ;
"RTN","RORAPI01",57,0)
 N BUF,INDT,RC
"RTN","RORAPI01",58,0)
 S RC=0
"RTN","RORAPI01",59,0)
 F  D  Q:RC
"RTN","RORAPI01",60,0)
 . ; Get an IEN of the next record in the registry
"RTN","RORAPI01",61,0)
 . S IDESC("IEN")=$O(^RORDATA(798,"B",IDESC("PATIEN"),IDESC("IEN")))
"RTN","RORAPI01",62,0)
 . I IDESC("IEN")'>0  S RC="1^END"  Q
"RTN","RORAPI01",63,0)
 . ;--- Load values of the fields
"RTN","RORAPI01",64,0)
 . S BUF=$G(^RORDATA(798,IDESC("IEN"),0)),INDT=$P(BUF,U,4)
"RTN","RORAPI01",65,0)
 . ;--- Screen records
"RTN","RORAPI01",66,0)
 . I $$ACTIVE^RORDD(INDT,$P(BUF,U,11))  S:IDESC("ACT") RC=$P(BUF,U,2)
"RTN","RORAPI01",67,0)
 . E  S:IDESC("INACT") RC=$P(BUF,U,2)_"^"_INDT
"RTN","RORAPI01",68,0)
 Q $S(RC="1^END":"",1:RC)
"RTN","RORAPI01",69,0)
 ;
"RTN","RORAPI01",70,0)
 ;***** CREATES AN ITERATOR OF PATIENTS IN THE REGISTRY
"RTN","RORAPI01",71,0)
 ;
"RTN","RORAPI01",72,0)
 ; .IDESC        Reference to a local variable where an iterator
"RTN","RORAPI01",73,0)
 ;               descriptor will be created
"RTN","RORAPI01",74,0)
 ; REGNAME       Registry name
"RTN","RORAPI01",75,0)
 ; [MODE]        Bit flags that define iteration mode (3 by default)
"RTN","RORAPI01",76,0)
 ;                 1  Active patients
"RTN","RORAPI01",77,0)
 ;                 2  Inactive patients
"RTN","RORAPI01",78,0)
 ;
"RTN","RORAPI01",79,0)
 ; Return Values:
"RTN","RORAPI01",80,0)
 ;       <0  Error code
"RTN","RORAPI01",81,0)
 ;        0  Ok
"RTN","RORAPI01",82,0)
 ;
"RTN","RORAPI01",83,0)
PATITER(IDESC,REGNAME,MODE) ;
"RTN","RORAPI01",84,0)
 N REGIEN  K IDESC
"RTN","RORAPI01",85,0)
 ;--- Get an IEN of the Registry Parameters
"RTN","RORAPI01",86,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORAPI01",87,0)
 Q:REGIEN<0 REGIEN
"RTN","RORAPI01",88,0)
 ;--- Setup the descriptor
"RTN","RORAPI01",89,0)
 S MODE=$S($G(MODE):MODE,1:3)
"RTN","RORAPI01",90,0)
 S IDESC("REGNAME")=REGNAME
"RTN","RORAPI01",91,0)
 S IDESC("REGIEN")=REGIEN
"RTN","RORAPI01",92,0)
 S IDESC("ACT")=MODE#2
"RTN","RORAPI01",93,0)
 S IDESC("INACT")=MODE\2#2
"RTN","RORAPI01",94,0)
 S IDESC("ROOT")=$$ROOT^DILFD(798,"",1)
"RTN","RORAPI01",95,0)
 S IDESC("IEN")=0
"RTN","RORAPI01",96,0)
 Q 0
"RTN","RORAPI01",97,0)
 ;
"RTN","RORAPI01",98,0)
 ;***** CREATES AN ITERATOR OF THE PATIENT REGISTRIES
"RTN","RORAPI01",99,0)
 ;
"RTN","RORAPI01",100,0)
 ; .IDESC        Reference to a local variable where an iterator
"RTN","RORAPI01",101,0)
 ;               descriptor will be created
"RTN","RORAPI01",102,0)
 ; PATIEN        Patient IEN
"RTN","RORAPI01",103,0)
 ; [MODE]        Bit flags that define iteration mode (3 by default)
"RTN","RORAPI01",104,0)
 ;                 1  Registries where the patient is active
"RTN","RORAPI01",105,0)
 ;                 2  Registries where the patient is inactive
"RTN","RORAPI01",106,0)
 ;
"RTN","RORAPI01",107,0)
 ; Return Values:
"RTN","RORAPI01",108,0)
 ;       <0  Error code
"RTN","RORAPI01",109,0)
 ;        0  Ok
"RTN","RORAPI01",110,0)
 ;
"RTN","RORAPI01",111,0)
REGITER(IDESC,PATIEN,MODE) ;
"RTN","RORAPI01",112,0)
 K IDESC
"RTN","RORAPI01",113,0)
 ;--- Setup the descriptor
"RTN","RORAPI01",114,0)
 S MODE=$S($G(MODE):MODE,1:3)
"RTN","RORAPI01",115,0)
 S IDESC("PATIEN")=PATIEN
"RTN","RORAPI01",116,0)
 S IDESC("ACT")=MODE#2
"RTN","RORAPI01",117,0)
 S IDESC("INACT")=MODE\2#2
"RTN","RORAPI01",118,0)
 S IDESC("ROOT")=$$ROOT^DILFD(798,"",1)
"RTN","RORAPI01",119,0)
 S IDESC("IEN")=0
"RTN","RORAPI01",120,0)
 Q 0
"RTN","RORENV01")
1^14
"RTN","RORENV02")
1^15
"RTN","RORERR")
0^12^B21685244
"RTN","RORERR",1,0)
RORERR ;HCIOFO/SG - ERROR PROCESSING  ; 1/14/03 11:10am
"RTN","RORERR",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORERR",3,0)
 ;
"RTN","RORERR",4,0)
 Q
"RTN","RORERR",5,0)
 ;
"RTN","RORERR",6,0)
 ;***** INITIALIZES THE ERROR STACK
"RTN","RORERR",7,0)
 ;
"RTN","RORERR",8,0)
 ; [DEFLOC]      Default error location
"RTN","RORERR",9,0)
 ; [ENABLE]      Enable extended error processing
"RTN","RORERR",10,0)
 ; 
"RTN","RORERR",11,0)
 ; Do not forget to NEW the RORERRDL variable before calling
"RTN","RORERR",12,0)
 ; this procedure!
"RTN","RORERR",13,0)
 ;
"RTN","RORERR",14,0)
CLEAR(DEFLOC,ENABLE) ;
"RTN","RORERR",15,0)
 S:$D(ENABLE) RORPARM("ERR")=+$G(ENABLE)
"RTN","RORERR",16,0)
 I $G(RORPARM("ERR"))  K RORERROR("ES")  S:$D(DEFLOC) RORERRDL=DEFLOC
"RTN","RORERR",17,0)
 D CLEAN^DILF
"RTN","RORERR",18,0)
 Q
"RTN","RORERR",19,0)
 ;
"RTN","RORERR",20,0)
 ;***** CHECKS THE ERRORS AFTER A FILEMAN DBS CALL
"RTN","RORERR",21,0)
 ;
"RTN","RORERR",22,0)
 ; ROR8MSG       Closed reference of the error messages array
"RTN","RORERR",23,0)
 ;               (from DBS calls)
"RTN","RORERR",24,0)
 ; [ERRCODE]     Error code to assign
"RTN","RORERR",25,0)
 ; [PLACE]       Location of the error (see the $$ERROR)
"RTN","RORERR",26,0)
 ; [PATIEN]      Patient IEN
"RTN","RORERR",27,0)
 ; [FILE]        File number used in the DBS call
"RTN","RORERR",28,0)
 ; [IENS]        IENS used in the DBS call
"RTN","RORERR",29,0)
 ;
"RTN","RORERR",30,0)
 ; The $$DBS^RORERR function checks the DIERR and @ROR8MSG variables
"RTN","RORERR",31,0)
 ; for errors after a FileMan DBS call.
"RTN","RORERR",32,0)
 ; 
"RTN","RORERR",33,0)
 ; Return Values:
"RTN","RORERR",34,0)
 ;
"RTN","RORERR",35,0)
 ; If there are no errors found, it returns an empty string.
"RTN","RORERR",36,0)
 ; In case of errors, the result depends on value of the ERRCODE
"RTN","RORERR",37,0)
 ; parameter:
"RTN","RORERR",38,0)
 ;
"RTN","RORERR",39,0)
 ; If ERRCODE is omitted or equals 0, the function returns a string
"RTN","RORERR",40,0)
 ; containing the list of error codes separated by comma.
"RTN","RORERR",41,0)
 ; 
"RTN","RORERR",42,0)
 ; If ERRCODE is not zero, the $$ERROR^RORERR function is called and
"RTN","RORERR",43,0)
 ; its return value is returned.
"RTN","RORERR",44,0)
 ;
"RTN","RORERR",45,0)
DBS(ROR8MSG,ERRCODE,PLACE,PATIEN,FILE,IENS) ;
"RTN","RORERR",46,0)
 K RORERROR("DBS")  Q:'$G(DIERR) ""
"RTN","RORERR",47,0)
 N ERRLST,ERRNODE,I,MSGTEXT
"RTN","RORERR",48,0)
 S ERRNODE=$S($G(ROR8MSG)'="":$NA(@ROR8MSG@("DIERR")),1:$NA(^TMP("DIERR",$J)))
"RTN","RORERR",49,0)
 Q:$D(@ERRNODE)<10 ""
"RTN","RORERR",50,0)
 ;--- Get a list of errors
"RTN","RORERR",51,0)
 S I=0
"RTN","RORERR",52,0)
 F  S I=$O(@ERRNODE@("E",I))  Q:'I  S RORERROR("DBS",I)=""
"RTN","RORERR",53,0)
 ;--- Return a list of errors
"RTN","RORERR",54,0)
 I '$G(ERRCODE)  D  Q $P(ERRLST,",",2,99)
"RTN","RORERR",55,0)
 . S ERRLST="",I=0
"RTN","RORERR",56,0)
 . F  S I=$O(RORERROR("DBS",I))  Q:'I  S ERRLST=ERRLST_","_I
"RTN","RORERR",57,0)
 . D CLEAN^DILF
"RTN","RORERR",58,0)
 ;--- Record/display the error message
"RTN","RORERR",59,0)
 D MSG^DIALOG("AE",.MSGTEXT,,,$G(ROR8MSG)),CLEAN^DILF
"RTN","RORERR",60,0)
 S I=$S($G(FILE):"; File #"_FILE,1:"")
"RTN","RORERR",61,0)
 S:$G(IENS)'="" I=I_"; IENS: """_IENS_""""
"RTN","RORERR",62,0)
 Q $$ERROR(ERRCODE,$G(PLACE),.MSGTEXT,.PATIEN,I)
"RTN","RORERR",63,0)
 ;
"RTN","RORERR",64,0)
 ;***** SETS DEFAULT ERROR LOCATION
"RTN","RORERR",65,0)
 ;
"RTN","RORERR",66,0)
 ; DEFLOC        Default error location
"RTN","RORERR",67,0)
 ; 
"RTN","RORERR",68,0)
 ; Do not forget to NEW the RORERRDL variable before calling
"RTN","RORERR",69,0)
 ; this procedure!
"RTN","RORERR",70,0)
 ;
"RTN","RORERR",71,0)
DFLTLOC(DEFLOC) ;
"RTN","RORERR",72,0)
 I $G(RORPARM("ERR"))  S RORERRDL=DEFLOC
"RTN","RORERR",73,0)
 D CLEAN^DILF
"RTN","RORERR",74,0)
 Q
"RTN","RORERR",75,0)
 ;
"RTN","RORERR",76,0)
 ;***** DISPLAYS CONTENT OF THE ERROR STACK
"RTN","RORERR",77,0)
DSPSTK() ;
"RTN","RORERR",78,0)
 Q:'$G(RORPARM("ERR"))!($D(RORERROR("ES"))<10)
"RTN","RORERR",79,0)
 N EPTR,I,TMP
"RTN","RORERR",80,0)
 D DSPSTKL("Err   Message Text",1)
"RTN","RORERR",81,0)
 D DSPSTKL("      Additional info")
"RTN","RORERR",82,0)
 S EPTR=""
"RTN","RORERR",83,0)
 F  S EPTR=$O(RORERROR("ES",EPTR))  Q:EPTR=""  D
"RTN","RORERR",84,0)
 . S TMP=RORERROR("ES",EPTR)
"RTN","RORERR",85,0)
 . D DSPSTKL($J(+TMP,4)_"  "_$P(TMP,U,2),1)
"RTN","RORERR",86,0)
 . S TMP=$G(RORERROR("ES",EPTR,1))
"RTN","RORERR",87,0)
 . D:TMP'="" DSPSTKL("      Location: "_TMP)
"RTN","RORERR",88,0)
 . S I=""
"RTN","RORERR",89,0)
 . F  S I=$O(RORERROR("ES",EPTR,2,I))  Q:I=""  D
"RTN","RORERR",90,0)
 . . D DSPSTKL("      "_RORERROR("ES",EPTR,2,I))
"RTN","RORERR",91,0)
 Q
"RTN","RORERR",92,0)
 ;
"RTN","RORERR",93,0)
 ; MSG           Message to display
"RTN","RORERR",94,0)
 ; [SKIP]        Skip a line before the output
"RTN","RORERR",95,0)
 ;
"RTN","RORERR",96,0)
DSPSTKL(MSG,SKIP) ;
"RTN","RORERR",97,0)
 I '$G(RORPARM("KIDS"))  W:$G(SKIP) !  W MSG,!  Q
"RTN","RORERR",98,0)
 I $G(SKIP)  D BMES^XPDUTL(MSG)  Q
"RTN","RORERR",99,0)
 D MES^XPDUTL(MSG)
"RTN","RORERR",100,0)
 Q
"RTN","RORERR",101,0)
 ;
"RTN","RORERR",102,0)
 ;***** PUTS THE ERROR IN THE ERROR STACK AND LOG FILE
"RTN","RORERR",103,0)
 ;
"RTN","RORERR",104,0)
 ; ERRCODE       Error code. Debug messages, information messages,
"RTN","RORERR",105,0)
 ;               data quality warnings and warnings are not placed
"RTN","RORERR",106,0)
 ;               into the stack. However, they are logged and
"RTN","RORERR",107,0)
 ;               displayed if this is enabled.
"RTN","RORERR",108,0)
 ;
"RTN","RORERR",109,0)
 ; [PLACE]       Location of the error (TAG^ROUTINE).
"RTN","RORERR",110,0)
 ;               If parameter is omitted or empty, default location
"RTN","RORERR",111,0)
 ;               is used (that has been set by CLEAR or DFLTLOC).
"RTN","RORERR",112,0)
 ;
"RTN","RORERR",113,0)
 ; [[.]RORINFO]  Optional additional information (either a string or
"RTN","RORERR",114,0)
 ;               a reference to a local array that contains strings
"RTN","RORERR",115,0)
 ;               prepared for storing in a word processing field)
"RTN","RORERR",116,0)
 ;
"RTN","RORERR",117,0)
 ; [PATIEN]      Patient IEN
"RTN","RORERR",118,0)
 ;
"RTN","RORERR",119,0)
 ; [ARG2-ARG5]   Optional parameters as for $$MSG^RORERR20
"RTN","RORERR",120,0)
 ;               (|1| is substituted by the value of the PATIEN)
"RTN","RORERR",121,0)
 ;
"RTN","RORERR",122,0)
 ; Return Values:
"RTN","RORERR",123,0)
 ;       <0  Error code (value of the ERRCODE)
"RTN","RORERR",124,0)
 ;        0  Ok (if ERRCOCE'<0)
"RTN","RORERR",125,0)
 ;
"RTN","RORERR",126,0)
ERROR(ERRCODE,PLACE,RORINFO,PATIEN,ARG2,ARG3,ARG4,ARG5) ;
"RTN","RORERR",127,0)
 Q:ERRCODE'<0 0
"RTN","RORERR",128,0)
 N IR,MSG,TOP,TYPE
"RTN","RORERR",129,0)
 S:$G(PLACE)="" PLACE=$G(RORERRDL)
"RTN","RORERR",130,0)
 I $D(RORINFO)=1  S IR=RORINFO  K RORINFO  S RORINFO(1)=IR,IR=1
"RTN","RORERR",131,0)
 E  S IR=$O(RORINFO(""),-1)
"RTN","RORERR",132,0)
 S MSG=$$MSG^RORERR20(+ERRCODE,.TYPE,.PATIEN,.ARG2,.ARG3,.ARG4,.ARG5)
"RTN","RORERR",133,0)
 ;--- Put the error to the error stack
"RTN","RORERR",134,0)
 D:$G(RORPARM("ERR"))&(TYPE>4)
"RTN","RORERR",135,0)
 . S (RORERROR("ES"),TOP)=$G(RORERROR("ES"))+1
"RTN","RORERR",136,0)
 . S RORERROR("ES",TOP)=+ERRCODE_U_MSG
"RTN","RORERR",137,0)
 . S RORERROR("ES",TOP,1)=PLACE
"RTN","RORERR",138,0)
 . M:$D(RORINFO) RORERROR("ES",TOP,2)=RORINFO
"RTN","RORERR",139,0)
 ;--- Log the message
"RTN","RORERR",140,0)
 S:PLACE'="" IR=IR+1,RORINFO(IR)="Location: "_PLACE
"RTN","RORERR",141,0)
 D LOG^RORLOG(TYPE,MSG,$G(PATIEN),.RORINFO),CLEAN^DILF
"RTN","RORERR",142,0)
 Q ERRCODE
"RTN","RORERR",143,0)
 ;
"RTN","RORERR",144,0)
 ;*****
"RTN","RORERR",145,0)
 ;
"RTN","RORERR",146,0)
 ; FILE          Number of the 'pointed from' file
"RTN","RORERR",147,0)
 ; IENS          IENS of the record of the file
"RTN","RORERR",148,0)
 ; FIELD         Number of the pointer field
"RTN","RORERR",149,0)
 ; [PLACE]       Location of the error (see the $$ERROR)
"RTN","RORERR",150,0)
 ; [PATIEN]      Patient IEN
"RTN","RORERR",151,0)
 ; [ERRCODE]     Error code to assign (-79 by default)
"RTN","RORERR",152,0)
 ;
"RTN","RORERR",153,0)
 ; The $$INVLDPTR^RORERR function checks the list of latest FileMan
"RTN","RORERR",154,0)
 ; DBS error codes for the pointer errors.
"RTN","RORERR",155,0)
 ; 
"RTN","RORERR",156,0)
 ; Return Values:
"RTN","RORERR",157,0)
 ;
"RTN","RORERR",158,0)
 ; If there are no pointer errors found, the function returns zero.
"RTN","RORERR",159,0)
 ; Otherwise, the $$ERROR^RORERR function is called and its value
"RTN","RORERR",160,0)
 ; is returned (a negative value of the ERRCODE or -79 by default).
"RTN","RORERR",161,0)
 ;
"RTN","RORERR",162,0)
INVLDPTR(FILE,IENS,FIELD,PLACE,PATIEN,ERRCODE) ;
"RTN","RORERR",163,0)
 Q:$D(RORERROR("DBS"))<10 0
"RTN","RORERR",164,0)
 N EC,TMP
"RTN","RORERR",165,0)
 F EC=601,0  Q:$D(RORERROR("DBS",EC))
"RTN","RORERR",166,0)
 Q:'EC 0
"RTN","RORERR",167,0)
 S TMP="File #"_FILE_"; IENS: """_IENS_"""; Field: "_FIELD
"RTN","RORERR",168,0)
 Q $$ERROR($S($G(ERRCODE)<0:ERRCODE,1:-79),$G(PLACE),.TMP,.PATIEN)
"RTN","RORERR",169,0)
 ;
"RTN","RORERR",170,0)
 ;***** RETURNS THE ERROR STACK FOR A REMOTE PROCEDURE
"RTN","RORERR",171,0)
 ;
"RTN","RORERR",172,0)
 ; .RESULT       Reference to a local variable where the error
"RTN","RORERR",173,0)
 ;               descriptors are returned to.
"RTN","RORERR",174,0)
 ;
"RTN","RORERR",175,0)
 ; LASTERR       The last error code
"RTN","RORERR",176,0)
 ;
"RTN","RORERR",177,0)
 ; Return Values:
"RTN","RORERR",178,0)
 ;
"RTN","RORERR",179,0)
 ; RESULT(0)             Result descriptor
"RTN","RORERR",180,0)
 ;                         ^1: The last error code (LASTERR)
"RTN","RORERR",181,0)
 ;                         ^2: Number of the error descriptors
"RTN","RORERR",182,0)
 ;
"RTN","RORERR",183,0)
 ; RESULT(i)             Error descriptor
"RTN","RORERR",184,0)
 ;                         ^1: Error code
"RTN","RORERR",185,0)
 ;                         ^2: Message
"RTN","RORERR",186,0)
 ;                         ^3: Place of the error
"RTN","RORERR",187,0)
 ;
"RTN","RORERR",188,0)
 ; Error descriptors are returned in reverse chronological order
"RTN","RORERR",189,0)
 ; (most recent first).
"RTN","RORERR",190,0)
 ; 
"RTN","RORERR",191,0)
RPCSTK(RESULT,LASTERR) ;
"RTN","RORERR",192,0)
 N CNT,EPTR,TMP
"RTN","RORERR",193,0)
 K RESULT  S RESULT(0)=(+LASTERR)_"^0"
"RTN","RORERR",194,0)
 Q:$D(RORERROR("ES"))<10
"RTN","RORERR",195,0)
 ;
"RTN","RORERR",196,0)
 S EPTR="",CNT=0
"RTN","RORERR",197,0)
 F  S EPTR=$O(RORERROR("ES",EPTR),-1)  Q:EPTR=""  D
"RTN","RORERR",198,0)
 . S TMP=$G(RORERROR("ES",EPTR)),CNT=CNT+1
"RTN","RORERR",199,0)
 . S RESULT(CNT)=(+TMP)_"^"_$TR($P(TMP,U,2,999),"^","~")
"RTN","RORERR",200,0)
 . S TMP=$G(RORERROR("ES",EPTR,1))
"RTN","RORERR",201,0)
 . S $P(RESULT(CNT),"^",3)=$TR(TMP,"^","~")
"RTN","RORERR",202,0)
 ;
"RTN","RORERR",203,0)
 S $P(RESULT(0),"^",2)=CNT
"RTN","RORERR",204,0)
 S TMP=$$RTRNFMT^XWBLIB(2,0)
"RTN","RORERR",205,0)
 Q
"RTN","RORERR10")
0^36^B64056354
"RTN","RORERR10",1,0)
RORERR10 ;HCIOFO/SG - AAC ERROR MESSAGES  ; 12/27/02 7:40am
"RTN","RORERR10",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORERR10",3,0)
 ;
"RTN","RORERR10",4,0)
 Q
"RTN","RORERR10",5,0)
 ;
"RTN","RORERR10",6,0)
 ;***** RETURNS TEXT OF THE MESSAGE
"RTN","RORERR10",7,0)
 ;
"RTN","RORERR10",8,0)
 ; ERRCODE       Error code
"RTN","RORERR10",9,0)
 ; [.TYPE]       Type of the error
"RTN","RORERR10",10,0)
 ;
"RTN","RORERR10",11,0)
MSG(ERRCODE,TYPE) ;
"RTN","RORERR10",12,0)
 S TYPE=6
"RTN","RORERR10",13,0)
 Q:'(ERRCODE?1.8UN) "Illegal error code: '"_ERRCODE_"'"
"RTN","RORERR10",14,0)
 N I,MSG
"RTN","RORERR10",15,0)
 S MSG=$P($T(@ERRCODE),";;",2)
"RTN","RORERR10",16,0)
 S I=+$TR($P(MSG,U)," "),MSG=$P(MSG,U,4,999)
"RTN","RORERR10",17,0)
 S:I>0 TYPE=I
"RTN","RORERR10",18,0)
 Q:MSG?." " "Unknown error ("_ERRCODE_")"
"RTN","RORERR10",19,0)
 Q $$TRIM^XLFSTR(MSG)
"RTN","RORERR10",20,0)
 ;
"RTN","RORERR10",21,0)
 ;***** LIST OF THE MESSAGES (THERE SHOULD BE NOTHING AFTER THE LIST!)
"RTN","RORERR10",22,0)
 ;
"RTN","RORERR10",23,0)
 ; Message Type:
"RTN","RORERR10",24,0)
 ;               1  Debug          4  Warning
"RTN","RORERR10",25,0)
 ;               2  Information    5  Database Error
"RTN","RORERR10",26,0)
 ;               3  Data Quality   6  Error
"RTN","RORERR10",27,0)
 ;
"RTN","RORERR10",28,0)
 ;Type Seg Fld  Message Text
"RTN","RORERR10",29,0)
0 ;; 2 ^   ^   ^ Message accepted
"RTN","RORERR10",30,0)
100 ;; 6 ^   ^   ^ Segment sequence error
"RTN","RORERR10",31,0)
101 ;; 6 ^   ^   ^ Required field missing
"RTN","RORERR10",32,0)
102 ;; 6 ^   ^   ^ Data type error
"RTN","RORERR10",33,0)
103 ;; 6 ^   ^   ^ Table value not found
"RTN","RORERR10",34,0)
200 ;; 6 ^   ^   ^ Unsupported message type
"RTN","RORERR10",35,0)
201 ;; 6 ^   ^   ^ Unsupported event code
"RTN","RORERR10",36,0)
202 ;; 6 ^   ^   ^ Unsupported processing ID
"RTN","RORERR10",37,0)
203 ;; 6 ^   ^   ^ Unsupported version ID
"RTN","RORERR10",38,0)
204 ;; 6 ^   ^   ^ Unknown key identifier
"RTN","RORERR10",39,0)
205 ;; 6 ^   ^   ^ Duplicate key identifier
"RTN","RORERR10",40,0)
206 ;; 6 ^   ^   ^ Application record locked
"RTN","RORERR10",41,0)
207 ;; 6 ^   ^   ^ Application internal error
"RTN","RORERR10",42,0)
010201 ;; 6 ^PID^  2^ Non-numeric ICN
"RTN","RORERR10",43,0)
010202 ;; 6 ^PID^  2^ ICN longer than 16 characters
"RTN","RORERR10",44,0)
010301 ;; 6 ^PID^  3^ Non-numeric DFN
"RTN","RORERR10",45,0)
010302 ;; 6 ^PID^  3^ Non-numeric station number
"RTN","RORERR10",46,0)
010303 ;; 6 ^PID^  3^ Station longer than 3 characters
"RTN","RORERR10",47,0)
010501 ;; 6 ^PID^  5^ Non-alphabetic characters in Family Name
"RTN","RORERR10",48,0)
010502 ;; 6 ^PID^  5^ Family name longer than 35 characters
"RTN","RORERR10",49,0)
010503 ;; 6 ^PID^  5^ Non-alphabetic characters in Given Name
"RTN","RORERR10",50,0)
010504 ;; 6 ^PID^  5^ Given name longer than 25 characters
"RTN","RORERR10",51,0)
010505 ;; 6 ^PID^  5^ Non-alphabetic characters in Middle Initial or Name
"RTN","RORERR10",52,0)
010506 ;; 6 ^PID^  5^ Middle Initial or Name longer than 25 characters
"RTN","RORERR10",53,0)
010701 ;; 6 ^PID^  7^ Non-numeric Date of Birth
"RTN","RORERR10",54,0)
010702 ;; 6 ^PID^  7^ Date of Birth formatted incorrectly
"RTN","RORERR10",55,0)
010801 ;; 6 ^PID^  8^ Invalid Sex value
"RTN","RORERR10",56,0)
011001 ;; 6 ^PID^ 10^ Invalid Race indicator
"RTN","RORERR10",57,0)
011101 ;; 6 ^PID^ 11^ Invalid Zip Code length
"RTN","RORERR10",58,0)
011102 ;; 6 ^PID^ 11^ Zip Code contains non-numeric characters
"RTN","RORERR10",59,0)
011901 ;; 6 ^PID^ 19^ Non-numeric SSN
"RTN","RORERR10",60,0)
011902 ;; 6 ^PID^ 19^ SSN longer than 9 characters
"RTN","RORERR10",61,0)
011903 ;; 6 ^PID^ 19^ SSN shorter than 9 characters
"RTN","RORERR10",62,0)
011904 ;; 6 ^PID^ 19^ Invalid Pseudo SSN indicator
"RTN","RORERR10",63,0)
012201 ;; 6 ^PID^ 22^ Invalid Ethnicity indicator
"RTN","RORERR10",64,0)
012901 ;; 6 ^PID^ 29^ Non-numeric Date of Death
"RTN","RORERR10",65,0)
012902 ;; 6 ^PID^ 29^ Date of Death formatted incorrectly
"RTN","RORERR10",66,0)
020201 ;; 6 ^ZSP^  2^ Service Connected Indicator invalid
"RTN","RORERR10",67,0)
020301 ;; 6 ^ZSP^  3^ Service Connected Combined % value non-numeric
"RTN","RORERR10",68,0)
020302 ;; 6 ^ZSP^  3^ Service Connected Combined % over 100
"RTN","RORERR10",69,0)
020401 ;; 6 ^ZSP^  4^ Veteran Era of Service is non alphanumeric
"RTN","RORERR10",70,0)
020402 ;; 6 ^ZSP^  4^ Veteran Era of Service longer than 1 character
"RTN","RORERR10",71,0)
030201 ;; 6 ^ZRD^  2^ Service Connected Codes (Rated Disability) out of bounds
"RTN","RORERR10",72,0)
030301 ;; 6 ^ZRD^  3^ Service Connected % value non-numeric
"RTN","RORERR10",73,0)
030302 ;; 6 ^ZRD^  3^ Service Connected % over 100
"RTN","RORERR10",74,0)
040101 ;; 6 ^CSR^  1^ Registry identifier contains non-alphanumeric characters
"RTN","RORERR10",75,0)
040102 ;; 6 ^CSR^  1^ Registry identifier longer than 30 characters
"RTN","RORERR10",76,0)
040103 ;; 6 ^CSR^  1^ Registry identifier shorter than 3 characters
"RTN","RORERR10",77,0)
040301 ;; 6 ^CSR^  3^ Non-numeric Station number
"RTN","RORERR10",78,0)
040302 ;; 6 ^CSR^  3^ Station longer than 3 characters
"RTN","RORERR10",79,0)
040401 ;; 6 ^CSR^  4^ Non-numeric DFN
"RTN","RORERR10",80,0)
040601 ;; 6 ^CSR^  6^ Date entered into registry has invalid format
"RTN","RORERR10",81,0)
041001 ;; 6 ^CSR^ 10^ Invalid Hep C supporting evidence field
"RTN","RORERR10",82,0)
041401 ;; 6 ^CSR^ 14^ Investigational drugs/Medication in profile indicator non-numeric
"RTN","RORERR10",83,0)
041402 ;; 6 ^CSR^ 14^ Investigational drugs/Medication in profile indicator contains too many characters
"RTN","RORERR10",84,0)
041501 ;; 6 ^CSR^ 15^ Inactivation date has invalid format
"RTN","RORERR10",85,0)
041601 ;; 6 ^CSR^ 16^ Invalid Hep C reason for inactivation
"RTN","RORERR10",86,0)
050101 ;; 6 ^CSP^  1^ Invalid new patient field
"RTN","RORERR10",87,0)
050201 ;; 6 ^CSP^  2^ Reactivation date has invalid format
"RTN","RORERR10",88,0)
060201 ;; 6 ^CSS^  2^ Date of last extraction has invalid format
"RTN","RORERR10",89,0)
070301 ;; 6 ^ORC^  3^ Released date/time has invalid format
"RTN","RORERR10",90,0)
071201 ;; 6 ^ORC^ 12^ Non-integer provider ID
"RTN","RORERR10",91,0)
071501 ;; 6 ^ORC^ 15^ Reactivation date has invalid format
"RTN","RORERR10",92,0)
071701 ;; 6 ^ORC^ 17^ Station has invalid length
"RTN","RORERR10",93,0)
071702 ;; 6 ^ORC^ 17^ Station contains non-alphanumeric characters
"RTN","RORERR10",94,0)
080201 ;; 6 ^RXE^  2^ NDC code has invalid length
"RTN","RORERR10",95,0)
080202 ;; 6 ^RXE^  2^ Drug name has invalid length
"RTN","RORERR10",96,0)
080203 ;; 6 ^RXE^  2^ VA Drug class has invalid length
"RTN","RORERR10",97,0)
080204 ;; 6 ^RXE^  2^ VA Product name has an invalid length
"RTN","RORERR10",98,0)
080205 ;; 6 ^RXE^  2^ VA drug code out of range
"RTN","RORERR10",99,0)
080701 ;; 6 ^RXE^  7^ SIG has invalid length
"RTN","RORERR10",100,0)
081001 ;; 6 ^RXE^ 10^ Amount value below valid range
"RTN","RORERR10",101,0)
081002 ;; 6 ^RXE^ 10^ Amount has invalid length
"RTN","RORERR10",102,0)
081003 ;; 6 ^RXE^ 10^ Amount can only have 2 decimal places
"RTN","RORERR10",103,0)
081004 ;; 6 ^RXE^ 10^ Invalid integer value
"RTN","RORERR10",104,0)
081801 ;; 6 ^RXE^ 18^ Fill date/time has invalid format
"RTN","RORERR10",105,0)
081802 ;; 6 ^RXE^ 18^ Stop date/time has invalid format
"RTN","RORERR10",106,0)
081901 ;; 6 ^RXE^ 19^ Days supply has invalid length
"RTN","RORERR10",107,0)
082001 ;; 6 ^RXE^ 20^ Invalid CMOP indicator
"RTN","RORERR10",108,0)
082401 ;; 6 ^RXE^ 24^ Non-numeric unit/dose
"RTN","RORERR10",109,0)
082402 ;; 6 ^RXE^ 24^ Unit/dose value out of range
"RTN","RORERR10",110,0)
082403 ;; 6 ^RXE^ 24^ Unit/dose can only have 2 decimal places
"RTN","RORERR10",111,0)
083001 ;; 6 ^RXE^ 30^ Invalid Mail/Window code
"RTN","RORERR10",112,0)
090401 ;; 6 ^OBR^  4^ Radiology CPT code does not exist on the CPT-4 Procedure Code File
"RTN","RORERR10",113,0)
090402 ;; 6 ^OBR^  4^ CPT-4 Procedure code longer than 5 characters
"RTN","RORERR10",114,0)
090403 ;; 6 ^OBR^  4^ CPT-4 Procedure code less than 5 characters
"RTN","RORERR10",115,0)
090404 ;; 6 ^OBR^  4^ Invalid procedure code type for CPT-4
"RTN","RORERR10",116,0)
090406 ;; 6 ^OBR^  4^ NLT code shorter than 5 characters
"RTN","RORERR10",117,0)
090407 ;; 6 ^OBR^  4^ NLT code longer than 15 characters
"RTN","RORERR10",118,0)
090701 ;; 6 ^OBR^  7^ Liver Biopsy date has invalid format
"RTN","RORERR10",119,0)
090702 ;; 6 ^OBR^  7^ Autopsy date has invalid format
"RTN","RORERR10",120,0)
090703 ;; 6 ^OBR^  7^ Exam date has invalid format
"RTN","RORERR10",121,0)
090704 ;; 6 ^OBR^  7^ Accession date has invalid format
"RTN","RORERR10",122,0)
091601 ;; 6 ^OBR^ 16^ Non-integer provider ID
"RTN","RORERR10",123,0)
094401 ;; 6 ^OBR^ 44^ Liver Biopsy station non-alphanumeric
"RTN","RORERR10",124,0)
094402 ;; 6 ^OBR^ 44^ Liver Biopsy station less than 3 characters long
"RTN","RORERR10",125,0)
094403 ;; 6 ^OBR^ 44^ Liver Biopsy station longer than 7 characters long
"RTN","RORERR10",126,0)
094404 ;; 6 ^OBR^ 44^ Autopsy station non-alphanumeric
"RTN","RORERR10",127,0)
094405 ;; 6 ^OBR^ 44^ Autopsy station less than 3 characters long
"RTN","RORERR10",128,0)
094406 ;; 6 ^OBR^ 44^ Autopsy station longer than 7 characters long
"RTN","RORERR10",129,0)
094407 ;; 6 ^OBR^ 44^ Radiology station non-alphanumeric
"RTN","RORERR10",130,0)
094408 ;; 6 ^OBR^ 44^ Radiology station less than 3 characters long
"RTN","RORERR10",131,0)
094409 ;; 6 ^OBR^ 44^ Radiology station longer than 7 characters long
"RTN","RORERR10",132,0)
094410 ;; 6 ^OBR^ 44^ Lab station non-alphanumeric
"RTN","RORERR10",133,0)
094411 ;; 6 ^OBR^ 44^ Lab station less than 3 characters long
"RTN","RORERR10",134,0)
094412 ;; 6 ^OBR^ 44^ Lab station longer than 7 characters long
"RTN","RORERR10",135,0)
100301 ;; 6 ^OBX^  3^ Code does not exist within Loinc table
"RTN","RORERR10",136,0)
100302 ;; 6 ^OBX^  3^ NLT code shorter than 5 characters
"RTN","RORERR10",137,0)
100303 ;; 6 ^OBX^  3^ NLT code longer than 15 characters
"RTN","RORERR10",138,0)
100501 ;; 6 ^OBX^  5^ Result longer than 60 characters
"RTN","RORERR10",139,0)
100601 ;; 6 ^OBX^  6^ Units shorter than 2 characters
"RTN","RORERR10",140,0)
100602 ;; 6 ^OBX^  6^ Units longer than 10 characters
"RTN","RORERR10",141,0)
100701 ;; 6 ^OBX^  7^ Range High longer than 50 characters
"RTN","RORERR10",142,0)
100702 ;; 6 ^OBX^  7^ Range Low longer than 50 characters
"RTN","RORERR10",143,0)
101501 ;; 6 ^OBX^ 15^ Site/specimen shorter than 2 characters
"RTN","RORERR10",144,0)
101502 ;; 6 ^OBX^ 15^ Site/specimen longer than 80 characters
"RTN","RORERR10",145,0)
110301 ;; 6 ^NTE^  3^ Comment shorter than 1 character
"RTN","RORERR10",146,0)
110302 ;; 6 ^NTE^  3^ Comment longer than 68 characters
"RTN","RORERR20")
0^2^B47811115
"RTN","RORERR20",1,0)
RORERR20 ;HCIOFO/SG - LIST OF ERROR MESSAGES  ; 12/13/02 2:26pm
"RTN","RORERR20",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3**;May 14, 2002
"RTN","RORERR20",3,0)
 ;
"RTN","RORERR20",4,0)
 ;***** RETURNS TEXT OF THE MESSAGE
"RTN","RORERR20",5,0)
 ;
"RTN","RORERR20",6,0)
 ; ERRCODE       Error code
"RTN","RORERR20",7,0)
 ; [.TYPE]       Type of the error
"RTN","RORERR20",8,0)
 ; [ARG1-ARG5]   Optional parameters that substitute the |n| "windows"
"RTN","RORERR20",9,0)
 ;               in the text of the message (for example, the |2| will
"RTN","RORERR20",10,0)
 ;               be substituted by the value of the ARG2).
"RTN","RORERR20",11,0)
 ;
"RTN","RORERR20",12,0)
MSG(ERRCODE,TYPE,ARG1,ARG2,ARG3,ARG4,ARG5) ;
"RTN","RORERR20",13,0)
 S TYPE=6  Q:ERRCODE'<0 ""
"RTN","RORERR20",14,0)
 N ARG,I1,I2,MSG
"RTN","RORERR20",15,0)
 ;--- Get a descriptor of the message
"RTN","RORERR20",16,0)
 S I1=-ERRCODE,MSG=$P($T(MSGLIST+I1),";;",2)
"RTN","RORERR20",17,0)
 S I1=+$TR($P(MSG,U,2)," "),MSG=$P(MSG,U,3,999)
"RTN","RORERR20",18,0)
 S:I1>0 TYPE=I1
"RTN","RORERR20",19,0)
 Q:MSG?." " "Unknown error ("_ERRCODE_")"
"RTN","RORERR20",20,0)
 ;--- Substitute parameters
"RTN","RORERR20",21,0)
 S I1=2
"RTN","RORERR20",22,0)
 F  S I1=$F(MSG,"|",I1-1)  Q:'I1  D
"RTN","RORERR20",23,0)
 . S I2=$F(MSG,"|",I1)  Q:'I2
"RTN","RORERR20",24,0)
 . X "S ARG=$G(ARG"_+$TR($E(MSG,I1,I2-2)," ")_")"
"RTN","RORERR20",25,0)
 . S $E(MSG,I1-1,I2-1)=ARG
"RTN","RORERR20",26,0)
 Q $$TRIM^XLFSTR(MSG)
"RTN","RORERR20",27,0)
 ;
"RTN","RORERR20",28,0)
 ;***** RETURNS TYPE OF THE MESSAGE
"RTN","RORERR20",29,0)
 ;
"RTN","RORERR20",30,0)
 ; ERRCODE       Error code
"RTN","RORERR20",31,0)
 ;
"RTN","RORERR20",32,0)
TYPE(ERRCODE) ;
"RTN","RORERR20",33,0)
 Q:ERRCODE'<0 0
"RTN","RORERR20",34,0)
 N I,TYPE  S I=-ERRCODE
"RTN","RORERR20",35,0)
 S I=$P($T(MSGLIST+I),";;",2),TYPE=+$TR($P(I,U,2)," ")
"RTN","RORERR20",36,0)
 Q $S(TYPE>0:TYPE,1:6)
"RTN","RORERR20",37,0)
 ;
"RTN","RORERR20",38,0)
 ;***** LIST OF THE MESSAGES (THERE SHOULD BE NOTHING AFTER THE LIST!)
"RTN","RORERR20",39,0)
 ;
"RTN","RORERR20",40,0)
 ; The error codes are provided in the table only for clarity.
"RTN","RORERR20",41,0)
 ; Text of the messages are extracted using the $TEXT function and
"RTN","RORERR20",42,0)
 ; absolute values of the ERRCODE parameter.
"RTN","RORERR20",43,0)
 ;
"RTN","RORERR20",44,0)
 ; Message Type:
"RTN","RORERR20",45,0)
 ;               1  Debug          4  Warning
"RTN","RORERR20",46,0)
 ;               2  Information    5  Database Error
"RTN","RORERR20",47,0)
 ;               3  Data Quality   6  Error
"RTN","RORERR20",48,0)
 ;
"RTN","RORERR20",49,0)
MSGLIST ; Code Type  Message Text
"RTN","RORERR20",50,0)
 ;;  -1 ^ 6 ^ Cannot find a descriptor of the registry
"RTN","RORERR20",51,0)
 ;;  -2 ^ 6 ^ Duplicate registry names
"RTN","RORERR20",52,0)
 ;;  -3 ^ 6 ^ Cannot find a descriptor of the rule
"RTN","RORERR20",53,0)
 ;;  -4 ^ 6 ^ Duplicate rule names
"RTN","RORERR20",54,0)
 ;;  -5 ^ 6 ^ Circle rule references
"RTN","RORERR20",55,0)
 ;;  -6 ^ 6 ^ Invalid update entry point: |2|
"RTN","RORERR20",56,0)
 ;;  -7 ^ 6 ^ Field '|2|' not found
"RTN","RORERR20",57,0)
 ;;  -8 ^ 6 ^ Duplicate patients in the registry
"RTN","RORERR20",58,0)
 ;;  -9 ^ 5 ^ FileMan DBS call error(s)|2|
"RTN","RORERR20",59,0)
 ;; -10 ^ 6 ^ Bad registry name: '|2|'
"RTN","RORERR20",60,0)
 ;; -11 ^ 6 ^ Cannot lock the record(s) of |2|
"RTN","RORERR20",61,0)
 ;; -12 ^ 6 ^ Cannot load and prepare lab search data
"RTN","RORERR20",62,0)
 ;; -13 ^ 6 ^ Cannot lock the registries
"RTN","RORERR20",63,0)
 ;; -14 ^ 6 ^ Cannot prepare selection rules
"RTN","RORERR20",64,0)
 ;; -15 ^ 6 ^ Error(s) during processing of the patient data
"RTN","RORERR20",65,0)
 ;; -16 ^ 6 ^ Cannot update demographic data
"RTN","RORERR20",66,0)
 ;; -17 ^ 6 ^ Invalid entry point: '|2|'
"RTN","RORERR20",67,0)
 ;; -18 ^ 6 ^ Routine '|2|' does not exist
"RTN","RORERR20",68,0)
 ;; -19 ^ 6 ^ Cannot load the selection rules
"RTN","RORERR20",69,0)
 ;; -20 ^ 6 ^ Cannot sort the selection rules
"RTN","RORERR20",70,0)
 ;; -21 ^ 6 ^ Syntax error in the expression
"RTN","RORERR20",71,0)
 ;; -22 ^ 6 ^ Cannot prepare data extraction definitions
"RTN","RORERR20",72,0)
 ;; -23 ^ 6 ^ Cannot set up HL7 environment variables
"RTN","RORERR20",73,0)
 ;; -24 ^ 6 ^ Cannot send the batch HL7 message
"RTN","RORERR20",74,0)
 ;; -25 ^ 6 ^ No event driver protocol
"RTN","RORERR20",75,0)
 ;; -26 ^ 3 ^ Neither ICN nor SSN is available
"RTN","RORERR20",76,0)
 ;; -27 ^ 5 ^ Cannot obtain results of the Lab tests
"RTN","RORERR20",77,0)
 ;; -28 ^ 4 ^ No active registries to |2|!
"RTN","RORERR20",78,0)
 ;; -29 ^ 6 ^ Non-existent LOINC code |2| in the registry parameters
"RTN","RORERR20",79,0)
 ;; -30 ^ 5 ^ Duplicate records in the file #95.3 for LOINC code |2|
"RTN","RORERR20",80,0)
 ;; -31 ^ 4 ^ Cannot remove the patient #|1| from the pending list
"RTN","RORERR20",81,0)
 ;; -32 ^ 6 ^ Incorrect data extraction period: '|2|-|3|'
"RTN","RORERR20",82,0)
 ;; -33 ^ 6 ^ Cannot de-queue data extraction task
"RTN","RORERR20",83,0)
 ;; -34 ^ 6 ^ Cannot open an output file
"RTN","RORERR20",84,0)
 ;; -35 ^ 6 ^ Device Handler error
"RTN","RORERR20",85,0)
 ;; -36 ^ 6 ^ Cannot retrieve Patient details (DFN:|1|) from File #|2|
"RTN","RORERR20",86,0)
 ;; -37 ^ 6 ^ Cannot retrieve details of medication
"RTN","RORERR20",87,0)
 ;; -38 ^ 6 ^ Cannot retrieve CPT code
"RTN","RORERR20",88,0)
 ;; -39 ^ 6 ^ Duplicate HL7 message ID in the file #798: '|2|'
"RTN","RORERR20",89,0)
 ;; -40 ^ 6 ^ Undefined variable: '|2|'
"RTN","RORERR20",90,0)
 ;; -41 ^ 2 ^ Registry setup has been completed
"RTN","RORERR20",91,0)
 ;; -42 ^ 4 ^ Task has been interrupted by user or by parent task
"RTN","RORERR20",92,0)
 ;; -43 ^ 6 ^ Error during the |2|. See log files.
"RTN","RORERR20",93,0)
 ;; -44 ^ 6 ^ Invalid extraction entry point: |2|
"RTN","RORERR20",94,0)
 ;; -45 ^ 6 ^ Invalid or missing IEN of selection rule
"RTN","RORERR20",95,0)
 ;; -46 ^ 5 ^ Cannot load registry parameters
"RTN","RORERR20",96,0)
 ;; -47 ^ 5 ^ Cannot find the '|2|' drug class
"RTN","RORERR20",97,0)
 ;; -48 ^ 2 ^ Registry '|2|' is inactive
"RTN","RORERR20",98,0)
 ;; -49 ^ 4 ^ Registry '|2|' is awaiting ACK
"RTN","RORERR20",99,0)
 ;; -50 ^ 6 ^ Cannot create the '|2|' checkpoint!
"RTN","RORERR20",100,0)
 ;; -51 ^ 6 ^ Cannot complete the '|2|' checkpoint!
"RTN","RORERR20",101,0)
 ;; -52 ^ 6 ^ Cannot find HL7 message ID in the file #798: '|2|'
"RTN","RORERR20",102,0)
 ;; -53 ^ 6 ^ Cannot enable the '|2|' protocol
"RTN","RORERR20",103,0)
 ;; -54 ^ 6 ^ The '|2|' Lab Search is not defined
"RTN","RORERR20",104,0)
 ;; -55 ^ 4 ^ No indicators are defined for the '|2|' Lab Search
"RTN","RORERR20",105,0)
 ;; -56 ^ 6 ^ Error code '|2|' is returned by the '|3|'
"RTN","RORERR20",106,0)
 ;; -57 ^ 4 ^ Error code '|2|' is returned by the '|3|'
"RTN","RORERR20",107,0)
 ;; -58 ^ 6 ^ File '|2|' not found
"RTN","RORERR20",108,0)
 ;; -59 ^ 3 ^ ICN checksum is shorter than 6 digits
"RTN","RORERR20",109,0)
 ;; -60 ^ 6 ^ Subtask #|2| crashed (see TaskMan logs)
"RTN","RORERR20",110,0)
 ;; -61 ^ 6 ^ Cannot start the registry update in multitask mode
"RTN","RORERR20",111,0)
 ;; -62 ^ 2 ^ Registry Update subtask #|2| has been scheduled
"RTN","RORERR20",112,0)
 ;; -63 ^ 6 ^ Data search in file #|2| is not supported
"RTN","RORERR20",113,0)
 ;; -64 ^ 6 ^ Data element #|3| (file #|2|) is not supported
"RTN","RORERR20",114,0)
 ;; -65 ^ 6 ^ |4| value of element #|3| (file #|2|) is not supported
"RTN","RORERR20",115,0)
 ;; -66 ^ 1 ^ Patient was skipped due to counter in the file #798.3
"RTN","RORERR20",116,0)
 ;; -67 ^ 6 ^ No application acknowledgement for |2| day(s)
"RTN","RORERR20",117,0)
 ;; -68 ^ 6 ^ Invalid header of the HL7 message (or no header at all)
"RTN","RORERR20",118,0)
 ;; -69 ^ 6 ^ Cannot find the data element
"RTN","RORERR20",119,0)
 ;; -70 ^ 6 ^ Duplicate names of the data element
"RTN","RORERR20",120,0)
 ;; -71 ^ 1 ^ User entered the "^"
"RTN","RORERR20",121,0)
 ;; -72 ^ 6 ^ Timeout
"RTN","RORERR20",122,0)
 ;; -73 ^ 4 ^ Invalid or expired applic. acknowledgement was received
"RTN","RORERR20",123,0)
 ;; -74 ^ 6 ^ Number of messages in the batch does not match the BTS
"RTN","RORERR20",124,0)
 ;; -75 ^ 6 ^ Not all four HL7 encoding characters are defined
"RTN","RORERR20",125,0)
 ;; -76 ^ 6 ^ The [|2|] option must not be running during installation
"RTN","RORERR20",126,0)
 ;; -77 ^ 6 ^ Cannot create MailMan message stub
"RTN","RORERR20",127,0)
 ;; -78 ^ 6 ^ Scheduled subtasks have not been started by TaskMan
"RTN","RORERR20",128,0)
 ;; -79 ^ 6 ^ Missing or dangling pointer
"RTN","RORERR20",129,0)
 ;; -80 ^ 6 ^ Cannot find a list item (file #799.1)
"RTN","RORERR20",130,0)
 ;; -81 ^ 6 ^ Duplicate item codes (file #799.1)
"RTN","RORERR20",131,0)
 ;; -82 ^ 6 ^ The task '|2|' cannot be scheduled at '|3|'
"RTN","RORERR20",132,0)
 ;; -83 ^ 6 ^ Cannot find the task #|2| in the ROR TASK file
"RTN","RORERR20",133,0)
 ;; -84 ^ 6 ^ The task #|2| has not responded on the stop request yet
"RTN","RORERR20",134,0)
 ;; -85 ^ 6 ^ Invalid task number: '|2|'
"RTN","RORERR20",135,0)
 ;; -86 ^ 6 ^ Cannot find report parameters (file #799.12)
"RTN","RORERR20",136,0)
 ;; -87 ^ 6 ^ Duplicate report parameters (file #799.12)
"RTN","RORERR20",137,0)
 ;; -88 ^ 6 ^ Parameter |2| has an invalid value: '|3|'
"RTN","RORERR20",138,0)
 ;; -89 ^ 2 ^ No output file has been created
"RTN","RORERR20",139,0)
 ;; -90 ^ 6 ^ Application acknowledgement with |2| processing ID
"RTN","ROREXPR")
0^26^B9225176
"RTN","ROREXPR",1,0)
ROREXPR ;HCIOFO/SG - PREPARATION FOR DATA EXTRACTION  ; 11/1/02 10:34am
"RTN","ROREXPR",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3**;May 14, 2002
"RTN","ROREXPR",3,0)
 ;
"RTN","ROREXPR",4,0)
 Q
"RTN","ROREXPR",5,0)
 ;
"RTN","ROREXPR",6,0)
 ;***** PREPARES VARIABLES FOR DATA EXTRACTION
"RTN","ROREXPR",7,0)
 ;
"RTN","ROREXPR",8,0)
 ; REGNAME       Registry name
"RTN","ROREXPR",9,0)
 ;
"RTN","ROREXPR",10,0)
 ; [DXBEG]       Data extraction start date (individual start
"RTN","ROREXPR",11,0)
 ;               date for each patient by default).
"RTN","ROREXPR",12,0)
 ;               Time part of the parameter value is ignored.
"RTN","ROREXPR",13,0)
 ;
"RTN","ROREXPR",14,0)
 ; [DXEND]       Data extraction end date (TODAY by default)
"RTN","ROREXPR",15,0)
 ;               Time part of the parameter value is ignored.
"RTN","ROREXPR",16,0)
 ;
"RTN","ROREXPR",17,0)
 ; DXBEG and DXEND parameters may be used only for historical data
"RTN","ROREXPR",18,0)
 ; extraction. Use of these parameters for regular data extraction
"RTN","ROREXPR",19,0)
 ; process will negatively affect the package!
"RTN","ROREXPR",20,0)
 ;
"RTN","ROREXPR",21,0)
 ; Return Values:
"RTN","ROREXPR",22,0)
 ;        0  Ok
"RTN","ROREXPR",23,0)
 ;       <0  Error code
"RTN","ROREXPR",24,0)
 ;
"RTN","ROREXPR",25,0)
PREPARE(REGNAME,DXBEG,DXEND) ;
"RTN","ROREXPR",26,0)
 N RORERRDL      ; Default error location
"RTN","ROREXPR",27,0)
 ;
"RTN","ROREXPR",28,0)
 N DTAREA,IL,IR,RC,REGIEN,RORMSG,SEGNAME,TMP
"RTN","ROREXPR",29,0)
 D DFLTLOC^RORERR("PREPARE^ROREXPR")
"RTN","ROREXPR",30,0)
 K RORLRC  F TMP="DXBEG","HL7","LD","MAXHL7SIZE"  K ROREXT(TMP)
"RTN","ROREXPR",31,0)
 S DXBEG=$G(DXBEG)\1,DXEND=$G(DXEND)\1
"RTN","ROREXPR",32,0)
 ;--- Data extraction period
"RTN","ROREXPR",33,0)
 S ROREXT("DXEND")=$S(DXEND>0:DXEND,1:$$DT^XLFDT)
"RTN","ROREXPR",34,0)
 I DXBEG>0  S RC=0  D  Q:RC<0 RC
"RTN","ROREXPR",35,0)
 . S ROREXT("DXBEG")=DXBEG  Q:DXBEG'>ROREXT("DXEND")
"RTN","ROREXPR",36,0)
 . S RC=$$ERROR^RORERR(-32,"PREPARE^ROREXPR",,,DXBEG,ROREXT("DXEND"))
"RTN","ROREXPR",37,0)
 ;--- Get the registry IEN and some parameters
"RTN","ROREXPR",38,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME,"7;10;13E;13.1;15.1",.RORBUF)
"RTN","ROREXPR",39,0)
 Q:REGIEN<0 REGIEN
"RTN","ROREXPR",40,0)
 S ROREXT("EXTRDAYS")=$G(RORBUF("DILIST","ID",1,7))
"RTN","ROREXPR",41,0)
 S ROREXT("HL7PROT")=$G(RORBUF("DILIST","ID",1,13))
"RTN","ROREXPR",42,0)
 ;--- Check the HL7 parameters
"RTN","ROREXPR",43,0)
 S RC=$$INIT^RORHL7()  Q:RC<0 RC
"RTN","ROREXPR",44,0)
 ;--- Load maximum message size and convert it into bytes
"RTN","ROREXPR",45,0)
 ;--- (1 Megabyte = 1024 Kb = 1024 * 1024 = 1048576 bytes)
"RTN","ROREXPR",46,0)
 S TMP=+$G(RORBUF("DILIST","ID",1,13.1))
"RTN","ROREXPR",47,0)
 S:TMP>0 ROREXT("MAXHL7SIZE")=(TMP*1048576)\1
"RTN","ROREXPR",48,0)
 ;--- Setup the lag interval (for regular data extraction only)
"RTN","ROREXPR",49,0)
 D:'$G(ROREXT("DXBEG"))
"RTN","ROREXPR",50,0)
 . S TMP=$G(RORBUF("DILIST","ID",1,15.1))
"RTN","ROREXPR",51,0)
 . S ROREXT("LD",1)=$S(TMP>0:TMP,1:1)
"RTN","ROREXPR",52,0)
 ;--- Setup the message builder call-back entry point
"RTN","ROREXPR",53,0)
 S TMP=$$TRIM^XLFSTR($G(RORBUF("DILIST","ID",1,10)))
"RTN","ROREXPR",54,0)
 I TMP'=""  D  Q:RC<0 $$ERROR^RORERR(-44,,REGNAME,,TMP)
"RTN","ROREXPR",55,0)
 . S RC=$$VERIFYEP^RORUTL01(TMP)
"RTN","ROREXPR",56,0)
 . S:RC'<0 ROREXT("MSGBLD")=TMP
"RTN","ROREXPR",57,0)
 ;--- Load and prepare segment descriptors
"RTN","ROREXPR",58,0)
 S TMP=","_REGIEN_","
"RTN","ROREXPR",59,0)
 D LIST^DIC(798.19,TMP,"@;.01;.02I;1","U",,,,"B",,,,"RORMSG")
"RTN","ROREXPR",60,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.19,TMP)
"RTN","ROREXPR",61,0)
 S IR=""
"RTN","ROREXPR",62,0)
 F  S IR=$O(^TMP("DILIST",$J,"ID",IR))  Q:IR=""  D
"RTN","ROREXPR",63,0)
 . S SEGNAME=^TMP("DILIST",$J,"ID",IR,.01)
"RTN","ROREXPR",64,0)
 . S DTAREA=+$G(^TMP("DILIST",$J,"ID",IR,.02))
"RTN","ROREXPR",65,0)
 . S TMP=$G(^TMP("DILIST",$J,"ID",IR,1))
"RTN","ROREXPR",66,0)
 . S $P(ROREXT("HL7",DTAREA,SEGNAME),U,2)=TMP
"RTN","ROREXPR",67,0)
 ;--- Load list of codes of extracted Lab results
"RTN","ROREXPR",68,0)
 S TMP=","_REGIEN_","
"RTN","ROREXPR",69,0)
 D LIST^DIC(798.112,TMP,"@;.01;.02","U",,,,"B",,,,"RORMSG")
"RTN","ROREXPR",70,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"PREPARE^ROREXPR",,798.112,TMP)
"RTN","ROREXPR",71,0)
 Q:'$G(^TMP("DILIST",$J,0)) 0
"RTN","ROREXPR",72,0)
 S (IL,IR,RC)=0
"RTN","ROREXPR",73,0)
 F  S IR=$O(^TMP("DILIST",$J,"ID",IR))  Q:IR=""  D  Q:RC
"RTN","ROREXPR",74,0)
 . S TMP=$G(^TMP("DILIST",$J,"ID",IR,.01))
"RTN","ROREXPR",75,0)
 . I TMP="*"  K RORLRC  S RORLRC="*",RC=1  Q
"RTN","ROREXPR",76,0)
 . I TMP>0  D  Q:RC<0  S IL=IL+1,RORLRC(IL)=TMP_"^LN"
"RTN","ROREXPR",77,0)
 . . S TMP=$$LNCODE^RORUTL02(TMP)  S:TMP<0 RC=TMP
"RTN","ROREXPR",78,0)
 . S TMP=$G(^TMP("DILIST",$J,"ID",IR,.02))
"RTN","ROREXPR",79,0)
 . S:TMP>0 IL=IL+1,RORLRC(IL)=TMP_"^NLT"
"RTN","ROREXPR",80,0)
 D CLEAN^DILF
"RTN","ROREXPR",81,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORHDT04")
0^3^B37538188
"RTN","RORHDT04",1,0)
RORHDT04 ;HCIOFO/SG - HISTORICAL DATA EXTRACTION PROCESS ; 12/12/02 2:35pm
"RTN","RORHDT04",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3**;May 14, 2002
"RTN","RORHDT04",3,0)
 ;
"RTN","RORHDT04",4,0)
 Q
"RTN","RORHDT04",5,0)
 ;
"RTN","RORHDT04",6,0)
 ;***** DATA EXTRACTION PROCESS
"RTN","RORHDT04",7,0)
 ;
"RTN","RORHDT04",8,0)
 ; REGISTRY      Registry to process
"RTN","RORHDT04",9,0)
 ;                 ^1: Registry IEN
"RTN","RORHDT04",10,0)
 ;                 ^2: Registry Name
"RTN","RORHDT04",11,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT04",12,0)
 ; FAM           File Access Mode
"RTN","RORHDT04",13,0)
 ;
"RTN","RORHDT04",14,0)
 ; Return Values:
"RTN","RORHDT04",15,0)
 ;       <0  Error code
"RTN","RORHDT04",16,0)
 ;      >=0  Statistics
"RTN","RORHDT04",17,0)
 ;             ^1: Total number of processed patients
"RTN","RORHDT04",18,0)
 ;             ^2: Number of patients processed with errors
"RTN","RORHDT04",19,0)
 ;
"RTN","RORHDT04",20,0)
EXTRACT(REGISTRY,TASKIEN,FAM) ;
"RTN","RORHDT04",21,0)
 N RORDATE       ; Date/time when the first registry update finished
"RTN","RORHDT04",22,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT04",23,0)
 N ROREXT        ; Data extraction descriptor
"RTN","RORHDT04",24,0)
 N RORHL         ; HL7 variables
"RTN","RORHDT04",25,0)
 N RORLRC        ; List of codes of Lab results to be extracted
"RTN","RORHDT04",26,0)
 ;
"RTN","RORHDT04",27,0)
 N CNT           ; Number of processed registry records
"RTN","RORHDT04",28,0)
 N ECNT          ; Number of records processed with errors
"RTN","RORHDT04",29,0)
 N FILE          ; Name of the output file
"RTN","RORHDT04",30,0)
 N OUTDIR        ; Name of the output directory
"RTN","RORHDT04",31,0)
 ;
"RTN","RORHDT04",32,0)
 N BDT,EDT,NEXT,POP,RC,REGIEN,REGLST,REGNAME,RRBIEN,RREIEN,STOP,TMP
"RTN","RORHDT04",33,0)
 D DFLTLOC^RORERR("EXTRACT^RORHDT04")
"RTN","RORHDT04",34,0)
 K ^TMP("RORHDT",$J,"PR"),^TMP("HLS",$J)
"RTN","RORHDT04",35,0)
 S REGNAME=$P(REGISTRY,U,2),(REGLST(REGNAME),REGIEN)=+REGISTRY
"RTN","RORHDT04",36,0)
 S (CNT,ECNT,STOP)=0,RORHDT("BHS")=1
"RTN","RORHDT04",37,0)
 ;--- Load parameters
"RTN","RORHDT04",38,0)
 S RC=$$REGPARM^RORHDT05(REGIEN,.BDT,.EDT,.OUTDIR,.RORDATE)
"RTN","RORHDT04",39,0)
 Q:RC<0 RC
"RTN","RORHDT04",40,0)
 S RC=$$TASKPARM^RORHDT05(REGIEN,TASKIEN,.RRBIEN,.RREIEN,.FILE)
"RTN","RORHDT04",41,0)
 Q:RC<0 RC
"RTN","RORHDT04",42,0)
 ;--- Prepare data extraction rules
"RTN","RORHDT04",43,0)
 S RC=$$PREPARE^ROREXPR(REGNAME,BDT,EDT)
"RTN","RORHDT04",44,0)
 Q:RC<0 $$ERROR^RORERR(-22)
"RTN","RORHDT04",45,0)
 K ROREXT("LD")          ; Do not use lag intervals
"RTN","RORHDT04",46,0)
 K ROREXT("MAXHL7SIZE")  ; Do not limit the size
"RTN","RORHDT04",47,0)
 S RC=$$INIT^RORHL7()  Q:RC<0 RC
"RTN","RORHDT04",48,0)
 ;--- Delete the old output host file(s)
"RTN","RORHDT04",49,0)
 S TMP=$$DELFILES^RORHDT05(OUTDIR,FILE)
"RTN","RORHDT04",50,0)
 ;--- The output file is created by the $$COMMIT^RORHDT05 function
"RTN","RORHDT04",51,0)
 D
"RTN","RORHDT04",52,0)
 . N COMMIT,IEN,NODE,NRTC,PATIEN
"RTN","RORHDT04",53,0)
 . S NRTC=100 ; Number of records to commit
"RTN","RORHDT04",54,0)
 . ;--- Try to re-extract the erroneous records
"RTN","RORHDT04",55,0)
 . S NODE=$$ROOT^DILFD(798.53,","_TASKIEN_",",1)
"RTN","RORHDT04",56,0)
 . S NODE=$NA(@NODE@("B"))
"RTN","RORHDT04",57,0)
 . S IEN=0,RC=0
"RTN","RORHDT04",58,0)
 . F  D  Q:RC!STOP!(IEN="")
"RTN","RORHDT04",59,0)
 . . K ^TMP("HLS",$J)
"RTN","RORHDT04",60,0)
 . . F  S IEN=$O(@NODE@(IEN))  Q:IEN=""  D  Q:RC!'((CNT-ECNT)#NRTC)
"RTN","RORHDT04",61,0)
 . . . S RC=$$CHKSTOP^RORHDT03(REGIEN,TASKIEN)
"RTN","RORHDT04",62,0)
 . . . I RC  S STOP=1  Q
"RTN","RORHDT04",63,0)
 . . . S RC=$$PROCREC(REGIEN,IEN,.PATIEN),CNT=CNT+1
"RTN","RORHDT04",64,0)
 . . . S ^TMP("RORHDT",$J,"PR",IEN)=RC
"RTN","RORHDT04",65,0)
 . . . I RC'<0  S RC=0  Q
"RTN","RORHDT04",66,0)
 . . . ;--- Proccess the error
"RTN","RORHDT04",67,0)
 . . . S RC=$$ERROR^RORERR(-15,,,$G(PATIEN)),ECNT=ECNT+1
"RTN","RORHDT04",68,0)
 . . . S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORHDT04",69,0)
 . . Q:RC<0
"RTN","RORHDT04",70,0)
 . . ;--- Commit the data
"RTN","RORHDT04",71,0)
 . . S TMP=$$COMMIT^RORHDT05(OUTDIR,FILE)
"RTN","RORHDT04",72,0)
 . . S:TMP<0 RC=TMP
"RTN","RORHDT04",73,0)
 . Q:STOP
"RTN","RORHDT04",74,0)
 . ;--- Extract the remaining registry data
"RTN","RORHDT04",75,0)
 . S NODE=$$ROOT^DILFD(798,,1)
"RTN","RORHDT04",76,0)
 . S NODE=$NA(@NODE@("AC",REGIEN))
"RTN","RORHDT04",77,0)
 . S IEN=$S(RRBIEN>0:+$O(@NODE@(RRBIEN),-1),1:0)
"RTN","RORHDT04",78,0)
 . S RC=0
"RTN","RORHDT04",79,0)
 . F  D  Q:RC!STOP!(IEN'>0)
"RTN","RORHDT04",80,0)
 . . K ^TMP("HLS",$J)  S COMMIT=0
"RTN","RORHDT04",81,0)
 . . F  S IEN=$O(@NODE@(IEN))  Q:IEN'>0  D  Q:RC!COMMIT
"RTN","RORHDT04",82,0)
 . . . S RC=$$CHKSTOP^RORHDT03(REGIEN,TASKIEN)
"RTN","RORHDT04",83,0)
 . . . I RC  S STOP=1  Q
"RTN","RORHDT04",84,0)
 . . . I RREIEN>0,IEN'<RREIEN  S IEN="",RC=1  Q
"RTN","RORHDT04",85,0)
 . . . Q:$D(^TMP("RORHDT",$J,"PR",IEN))
"RTN","RORHDT04",86,0)
 . . . S RC=$$PROCREC(REGIEN,IEN,.PATIEN),CNT=CNT+1
"RTN","RORHDT04",87,0)
 . . . I RC'<0  S COMMIT='((CNT-ECNT)#NRTC),RC=0  Q
"RTN","RORHDT04",88,0)
 . . . ;--- Proccess the error
"RTN","RORHDT04",89,0)
 . . . S RC=$$ERROR^RORERR(-15,,,,$G(PATIEN)),ECNT=ECNT+1
"RTN","RORHDT04",90,0)
 . . . S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORHDT04",91,0)
 . . . S TMP=$$ADDERR^RORHDT05(REGIEN,TASKIEN,IEN)
"RTN","RORHDT04",92,0)
 . . . S:TMP<0 RC=TMP
"RTN","RORHDT04",93,0)
 . . Q:RC<0
"RTN","RORHDT04",94,0)
 . . ;--- Commit the data
"RTN","RORHDT04",95,0)
 . . S NEXT=$S(COMMIT:$O(@NODE@(IEN)),1:IEN)
"RTN","RORHDT04",96,0)
 . . S TMP=$$COMMIT^RORHDT05(OUTDIR,FILE)
"RTN","RORHDT04",97,0)
 . . S:TMP<0 RC=TMP
"RTN","RORHDT04",98,0)
 ;
"RTN","RORHDT04",99,0)
 ;--- Write the batch trailer segment and close the file if
"RTN","RORHDT04",100,0)
 ;--- the batch is not empty. Otherwise, record a warning.
"RTN","RORHDT04",101,0)
 I '$G(RORHDT("BHS"))  D
"RTN","RORHDT04",102,0)
 . S TMP=$S(ECNT!(RC<0):"Completed with errors",STOP:"Stopped",1:"")
"RTN","RORHDT04",103,0)
 . U IO  W $$BTS^RORHL7($$MSGCNT^RORHL7,TMP),$C(13)
"RTN","RORHDT04",104,0)
 . D CLOSE^%ZISH("HL7FILE")
"RTN","RORHDT04",105,0)
 E  S TMP=$$ERROR^RORERR(-89)
"RTN","RORHDT04",106,0)
 ;--- Update the NEXT RECORD IEN field in the task record
"RTN","RORHDT04",107,0)
 D
"RTN","RORHDT04",108,0)
 . N NODE,RORFDA,RORMSG
"RTN","RORHDT04",109,0)
 . I $D(NEXT)  D:NEXT'>0
"RTN","RORHDT04",110,0)
 . . ;--- If the task completed successfuly, the NEXT RECORD IEN
"RTN","RORHDT04",111,0)
 . . ;    field is set to an empty string. If the task is restarted
"RTN","RORHDT04",112,0)
 . . ;--- afterwards, it will re-extract all data again.
"RTN","RORHDT04",113,0)
 . . I 'ECNT  S NEXT=""  Q
"RTN","RORHDT04",114,0)
 . . ;--- If completed with errors, use IEN of the last record
"RTN","RORHDT04",115,0)
 . . ;--- processed by the task incremented by 1.
"RTN","RORHDT04",116,0)
 . . I RREIEN>0  S NEXT=RREIEN+1  Q
"RTN","RORHDT04",117,0)
 . . ;--- Or the IEN of the last registry record incremented by 1
"RTN","RORHDT04",118,0)
 . . ;--- (in case of the last/single task).
"RTN","RORHDT04",119,0)
 . . S NODE=$$ROOT^DILFD(798,,1)
"RTN","RORHDT04",120,0)
 . . S NEXT=$O(@NODE@("AC",REGIEN,""),-1)+1
"RTN","RORHDT04",121,0)
 . . ;--- When the task is restarted, it will try to re-extract only
"RTN","RORHDT04",122,0)
 . . ;    erroneous records and will not process already extracted
"RTN","RORHDT04",123,0)
 . . ;    data (the IEN will not be less than the RREIEN or the
"RTN","RORHDT04",124,0)
 . . ;--- $ORDER function will not return a value greater than zero).
"RTN","RORHDT04",125,0)
 . E  Q:(RC<0)!ECNT!STOP  S NEXT=""
"RTN","RORHDT04",126,0)
 . ;--- Update the task record
"RTN","RORHDT04",127,0)
 . S RORFDA(798.5,TASKIEN_",",4)=NEXT
"RTN","RORHDT04",128,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORHDT04",129,0)
 . S TMP=$$DBS^RORERR("RORMSG",-9,"EXTRACT^RORHDT04",,798.5,TASKIEN)
"RTN","RORHDT04",130,0)
 ;--- Cleanup
"RTN","RORHDT04",131,0)
 S:RC'<0 RC=$$CLRERRS^RORHDT05(REGIEN,TASKIEN)
"RTN","RORHDT04",132,0)
 Q $S(RC<0:RC,1:CNT_U_ECNT)
"RTN","RORHDT04",133,0)
 ;
"RTN","RORHDT04",134,0)
 ;***** PROCESSES A RECORD IN THE REGISTRY
"RTN","RORHDT04",135,0)
 ;
"RTN","RORHDT04",136,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT04",137,0)
 ; IEN           IEN of a record in the registry
"RTN","RORHDT04",138,0)
 ; [.PATIEN]     Patient IEN is returned by this parameter
"RTN","RORHDT04",139,0)
 ;
"RTN","RORHDT04",140,0)
 ; Return Values:
"RTN","RORHDT04",141,0)
 ;       <0  Error code
"RTN","RORHDT04",142,0)
 ;        0  Ok
"RTN","RORHDT04",143,0)
 ;        1  Nothing has been extracted
"RTN","RORHDT04",144,0)
 ;
"RTN","RORHDT04",145,0)
PROCREC(REGIEN,IEN,PATIEN) ;
"RTN","RORHDT04",146,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT04",147,0)
 ;
"RTN","RORHDT04",148,0)
 N ACTIVE,BDT,EDT,IENS,INCTVDT,MSHPTR,RC,RORFDA,RORMSG
"RTN","RORHDT04",149,0)
 D CLEAR^RORERR("PROCREC^RORHDT04")
"RTN","RORHDT04",150,0)
 S IENS=IEN_",",PATIEN=0
"RTN","RORHDT04",151,0)
 ;--- Get the registry record data
"RTN","RORHDT04",152,0)
 D GETS^DIQ(798,IENS,".01;1;2;8;11","EI","RORFDA","RORMSG")
"RTN","RORHDT04",153,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","RORHDT04",154,0)
 S PATIEN=RORFDA(798,IENS,.01,"I")
"RTN","RORHDT04",155,0)
 S INCTVDT=$G(RORFDA(798,IENS,2,"I"))\1
"RTN","RORHDT04",156,0)
 S ACTIVE=$G(RORFDA(798,IENS,8,"E"))
"RTN","RORHDT04",157,0)
 ;--- Skip a record tagged as "DON'T SEND"
"RTN","RORHDT04",158,0)
 Q:$G(RORFDA(798,IENS,11,"I")) 0
"RTN","RORHDT04",159,0)
 ;--- Skip the record if it was not added by the first update
"RTN","RORHDT04",160,0)
 I RORDATE  Q:$G(RORFDA(798,IENS,1,"I"))>RORDATE 0
"RTN","RORHDT04",161,0)
 ;--- Prepare extract dates
"RTN","RORHDT04",162,0)
 S BDT=$G(ROREXT("DXBEG")),EDT=$G(ROREXT("DXEND"))
"RTN","RORHDT04",163,0)
 I 'ACTIVE  Q:INCTVDT'>BDT 0  S:EDT>INCTVDT EDT=INCTVDT
"RTN","RORHDT04",164,0)
 ;--- Create HL7 message for the patient
"RTN","RORHDT04",165,0)
 S MSHPTR=$$CREATE^RORHL7()  Q:MSHPTR<0 MSHPTR
"RTN","RORHDT04",166,0)
 S RC=$$MESSAGE^ROREXT02(IEN,PATIEN,BDT,EDT,1)
"RTN","RORHDT04",167,0)
 ;--- Rollback incomplete message if necessary
"RTN","RORHDT04",168,0)
 S:RC'<0 RC=($O(^TMP("HLS",$J,""),-1)'>MSHPTR)
"RTN","RORHDT04",169,0)
 D:RC ROLLBACK^RORHL7(MSHPTR)
"RTN","RORHDT04",170,0)
 Q RC
"RTN","RORHDT05")
0^4^B14700625
"RTN","RORHDT05",1,0)
RORHDT05 ;HCIOFO/SG - HISTORICAL DATA EXTRACTION FUNCTIONS ; 12/11/02 11:07am
"RTN","RORHDT05",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORHDT05",3,0)
 ;
"RTN","RORHDT05",4,0)
 Q
"RTN","RORHDT05",5,0)
 ;
"RTN","RORHDT05",6,0)
 ;***** ADDS A RECORD TO THE 'ERROR' MULTIPLE OF THE TASK RECORD
"RTN","RORHDT05",7,0)
 ;
"RTN","RORHDT05",8,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT05",9,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT05",10,0)
 ; IEN           IEN of the erroneous registry record
"RTN","RORHDT05",11,0)
 ;
"RTN","RORHDT05",12,0)
 ; Return Values:
"RTN","RORHDT05",13,0)
 ;       <0  Error code
"RTN","RORHDT05",14,0)
 ;        0  Ok
"RTN","RORHDT05",15,0)
 ;
"RTN","RORHDT05",16,0)
ADDERR(REGIEN,TASKIEN,IEN) ;
"RTN","RORHDT05",17,0)
 N IENS,RC,RORFDA,RORIEN,RORMSG
"RTN","RORHDT05",18,0)
 S IENS="+1,"_TASKIEN_",",RORIEN(1)=IEN
"RTN","RORHDT05",19,0)
 S RORFDA(798.53,IENS,.01)=IEN
"RTN","RORHDT05",20,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORHDT05",21,0)
 Q $$DBS^RORERR("RORMSG",-9,"ADDERR^RORHDT05",,798.53,IENS)
"RTN","RORHDT05",22,0)
 ;
"RTN","RORHDT05",23,0)
 ;***** DELETES RECORDS FROM THE 'ERROR' MULTIPLE OF THE TASK RECORD
"RTN","RORHDT05",24,0)
 ;
"RTN","RORHDT05",25,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT05",26,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT05",27,0)
 ;
"RTN","RORHDT05",28,0)
 ; This functions deletes all erroneous records from the ERROR
"RTN","RORHDT05",29,0)
 ; multiple of the task record that have been re-extracted without
"RTN","RORHDT05",30,0)
 ; errors. So, there is no reason to keep them anymore.
"RTN","RORHDT05",31,0)
 ;
"RTN","RORHDT05",32,0)
 ; Return Values:
"RTN","RORHDT05",33,0)
 ;       <0  Error code
"RTN","RORHDT05",34,0)
 ;        0  Ok
"RTN","RORHDT05",35,0)
 ;
"RTN","RORHDT05",36,0)
CLRERRS(REGIEN,TASKIEN) ;
"RTN","RORHDT05",37,0)
 N I,IEN,RC,RORFDA,RORMSG,SFI
"RTN","RORHDT05",38,0)
 S SFI=","_TASKIEN_",",RC=0
"RTN","RORHDT05",39,0)
 S IEN=""
"RTN","RORHDT05",40,0)
 F  D  Q:(RC<0)!(IEN="")
"RTN","RORHDT05",41,0)
 . F I=1:1:10  S IEN=$O(^TMP("RORHDT",$J,"PR",IEN))  Q:IEN=""  D
"RTN","RORHDT05",42,0)
 . . S:^TMP("RORHDT",$J,"PR",IEN)'<0 RORFDA(798.53,IEN_SFI,.01)="@"
"RTN","RORHDT05",43,0)
 . Q:$D(RORFDA)<10
"RTN","RORHDT05",44,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORHDT05",45,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,"CLRERRS^RORHDT05",,798.53)
"RTN","RORHDT05",46,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORHDT05",47,0)
 ;
"RTN","RORHDT05",48,0)
 ;***** COMMITS HL7 DATA TO THE OUTPUT FILE
"RTN","RORHDT05",49,0)
 ;
"RTN","RORHDT05",50,0)
 ; OUTDIR        Output directory
"RTN","RORHDT05",51,0)
 ; FILE          Output file name
"RTN","RORHDT05",52,0)
 ;
"RTN","RORHDT05",53,0)
 ; Return Values:
"RTN","RORHDT05",54,0)
 ;       <0  Error code
"RTN","RORHDT05",55,0)
 ;        0  Ok
"RTN","RORHDT05",56,0)
 ;
"RTN","RORHDT05",57,0)
COMMIT(OUTDIR,FILE) ;
"RTN","RORHDT05",58,0)
 N CR,I,J,POP,RC
"RTN","RORHDT05",59,0)
 Q:$D(^TMP("HLS",$J))<10 0
"RTN","RORHDT05",60,0)
 S CR=$C(13)  U IO
"RTN","RORHDT05",61,0)
 ;--- Create the file and write the BHS segment (if necessary)
"RTN","RORHDT05",62,0)
 I $G(RORHDT("BHS"))  D  Q:RC<0 RC  K RORHDT("BHS")
"RTN","RORHDT05",63,0)
 . D OPEN^%ZISH("HL7FILE",OUTDIR,FILE,"WB")
"RTN","RORHDT05",64,0)
 . I $G(POP)  S RC=$$ERROR^RORERR(-34,,OUTDIR_FILE)  Q
"RTN","RORHDT05",65,0)
 . S I=$G(ROREXT("HL7DT"))
"RTN","RORHDT05",66,0)
 . W $$BHS^RORHL7($G(ROREXT("HL7MID")),I,"HISTORICAL DATA"),$C(13)
"RTN","RORHDT05",67,0)
 ;--- Write the segments
"RTN","RORHDT05",68,0)
 S I=0
"RTN","RORHDT05",69,0)
 F  S I=$O(^TMP("HLS",$J,I))  Q:I=""  D
"RTN","RORHDT05",70,0)
 . W ^TMP("HLS",$J,I)  S J=""
"RTN","RORHDT05",71,0)
 . F  S J=$O(^TMP("HLS",$J,I,J))  Q:J=""  W ^(J)
"RTN","RORHDT05",72,0)
 . W CR
"RTN","RORHDT05",73,0)
 Q 0
"RTN","RORHDT05",74,0)
 ;
"RTN","RORHDT05",75,0)
 ;***** DELETES THE OLD OUTPUT HOST FILE(S)
"RTN","RORHDT05",76,0)
 ;
"RTN","RORHDT05",77,0)
 ; OUTDIR        Output directory
"RTN","RORHDT05",78,0)
 ; FILE          Output file name
"RTN","RORHDT05",79,0)
 ;
"RTN","RORHDT05",80,0)
 ; Return Values:
"RTN","RORHDT05",81,0)
 ;       <0  Error code
"RTN","RORHDT05",82,0)
 ;        0  Ok
"RTN","RORHDT05",83,0)
 ;
"RTN","RORHDT05",84,0)
DELFILES(OUTDIR,FILE) ;
"RTN","RORHDT05",85,0)
 N RC,RORDST,RORSRC  Q:FILE="" 0
"RTN","RORHDT05",86,0)
 S RORSRC(FILE_"*")=""
"RTN","RORHDT05",87,0)
 I '$$LIST^%ZISH(OUTDIR,"RORSRC","RORDST")  D  Q RC
"RTN","RORHDT05",88,0)
 . S RC=$$ERROR^RORERR(-56,"DELFILES^RORHDT05",,,0,"$$LIST^%ZISH")
"RTN","RORHDT05",89,0)
 I '$$DEL^%ZISH(OUTDIR,"RORDST")  D  Q RC
"RTN","RORHDT05",90,0)
 . S RC=$$ERROR^RORERR(-56,"DELFILES^RORHDT05",,,0,"$$DEL^%ZISH")
"RTN","RORHDT05",91,0)
 Q 0
"RTN","RORHDT05",92,0)
 ;
"RTN","RORHDT05",93,0)
 ;***** LOADS REGISTRY PARAMETERS
"RTN","RORHDT05",94,0)
 ;
"RTN","RORHDT05",95,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT05",96,0)
 ; [.BDT]        Start date of the data extract
"RTN","RORHDT05",97,0)
 ; [.EDT]        End date of the data extract
"RTN","RORHDT05",98,0)
 ; [.OUTDIR]     Output directory
"RTN","RORHDT05",99,0)
 ; [.DATE]       Date/time when first registry update finished
"RTN","RORHDT05",100,0)
 ;
"RTN","RORHDT05",101,0)
 ; Return Values:
"RTN","RORHDT05",102,0)
 ;       <0  Error code
"RTN","RORHDT05",103,0)
 ;        0  Ok
"RTN","RORHDT05",104,0)
 ;
"RTN","RORHDT05",105,0)
REGPARM(REGIEN,BDT,EDT,OUTDIR,DATE) ;
"RTN","RORHDT05",106,0)
 N IENS,RC,RORBUF,RORMSG,TMP
"RTN","RORHDT05",107,0)
 S IENS=REGIEN_","
"RTN","RORHDT05",108,0)
 ;--- Get data from the registry descriptor
"RTN","RORHDT05",109,0)
 D GETS^DIQ(798.1,IENS,"21.01;21.02;21.03;21.05","I","RORBUF","RORMSG")
"RTN","RORHDT05",110,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"REGPARM^RORHDT05",,798.1,IENS)
"RTN","RORHDT05",111,0)
 S BDT=$G(RORBUF(798.1,IENS,21.01,"I"))
"RTN","RORHDT05",112,0)
 S EDT=$G(RORBUF(798.1,IENS,21.02,"I"))
"RTN","RORHDT05",113,0)
 S OUTDIR=$G(RORBUF(798.1,IENS,21.03,"I"))
"RTN","RORHDT05",114,0)
 S DATE=$G(RORBUF(798.1,IENS,21.05,"I"))
"RTN","RORHDT05",115,0)
 I (BDT'>0)!(EDT'>0)!(BDT>EDT)  D  Q RC
"RTN","RORHDT05",116,0)
 . S RC=$$ERROR^RORERR(-32,"REGPARM^RORHDT05",,,BDT,EDT)
"RTN","RORHDT05",117,0)
 Q 0
"RTN","RORHDT05",118,0)
 ;
"RTN","RORHDT05",119,0)
 ;***** LOADS TASK PARAMETERS
"RTN","RORHDT05",120,0)
 ;
"RTN","RORHDT05",121,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT05",122,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT05",123,0)
 ; [.RBIEN]      Start record IEN
"RTN","RORHDT05",124,0)
 ; [.REIEN]      End record IEN
"RTN","RORHDT05",125,0)
 ; [.FILE]       File name
"RTN","RORHDT05",126,0)
 ;
"RTN","RORHDT05",127,0)
 ; Return Values:
"RTN","RORHDT05",128,0)
 ;       <0  Error code
"RTN","RORHDT05",129,0)
 ;        0  Ok
"RTN","RORHDT05",130,0)
 ;
"RTN","RORHDT05",131,0)
TASKPARM(REGIEN,TASKIEN,RBIEN,REIEN,FILE) ;
"RTN","RORHDT05",132,0)
 N IENS,RC,ROOT,RORBUF,RORMSG,TMP
"RTN","RORHDT05",133,0)
 ;--- Load data from the task record
"RTN","RORHDT05",134,0)
 S IENS=TASKIEN_","
"RTN","RORHDT05",135,0)
 D GETS^DIQ(798.5,IENS,".01;1.01;4","I","RORBUF","RORMSG")
"RTN","RORHDT05",136,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"TASKPARM^RORHDT05",,798.5,IENS)
"RTN","RORHDT05",137,0)
 S RBIEN=$G(RORBUF(798.5,IENS,.01,"I"))
"RTN","RORHDT05",138,0)
 S FILE=$G(RORBUF(798.5,IENS,1.01,"I"))
"RTN","RORHDT05",139,0)
 ;--- Get the end record IEN from the next task record
"RTN","RORHDT05",140,0)
 S ROOT=$$ROOT^DILFD(798.5,,1)
"RTN","RORHDT05",141,0)
 S REIEN=$O(@ROOT@("C",REGIEN,RBIEN))
"RTN","RORHDT05",142,0)
 ;--- If an IEN of the record is available from the previous run,
"RTN","RORHDT05",143,0)
 ;    use it as start record IEN
"RTN","RORHDT05",144,0)
 S TMP=$G(RORBUF(798.5,IENS,4,"I"))
"RTN","RORHDT05",145,0)
 S:TMP>0 RBIEN=TMP
"RTN","RORHDT05",146,0)
 Q 0
"RTN","RORHL01")
0^8^B11573225
"RTN","RORHL01",1,0)
RORHL01 ;HOIFO/CRT - Clinical Registries Segment APIs ; 12/5/02 3:39pm
"RTN","RORHL01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3**;May 14, 2002
"RTN","RORHL01",3,0)
 ;
"RTN","RORHL01",4,0)
 Q
"RTN","RORHL01",5,0)
 ;
"RTN","RORHL01",6,0)
PID(RORDFN,RORPTR,HLFS,HLECH) ; PID SEGMENT
"RTN","RORHL01",7,0)
 ;
"RTN","RORHL01",8,0)
 ; INPUT:  RORDFN - DFN of Patient Record in File #2          (Req'd)
"RTN","RORHL01",9,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                  (Opt'l)
"RTN","RORHL01",10,0)
 ;         HLFS   - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL01",11,0)
 ;         HLECH  - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL01",12,0)
 ;
"RTN","RORHL01",13,0)
 N CS,I,RORFLDS,RORMSG,RORRES,RORSEG,RORSITE,SCS,TMP,VAFPID
"RTN","RORHL01",14,0)
 ;
"RTN","RORHL01",15,0)
 S RORRES=0
"RTN","RORHL01",16,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL01",17,0)
 ;
"RTN","RORHL01",18,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL01",19,0)
 S CS=$E(HLECH,1),SCS=$E(HLECH,4)
"RTN","RORHL01",20,0)
 ;
"RTN","RORHL01",21,0)
 S RORDFN=+$G(RORDFN)  I '$D(^DPT(RORDFN))  D  Q RORRES
"RTN","RORHL01",22,0)
 . S RORRES=$$ERROR^RORERR(-36,"PID^RORHL01",,RORDFN,2)
"RTN","RORHL01",23,0)
 ;
"RTN","RORHL01",24,0)
 S RORFLDS="2,3,5,7,8,11,19,22BT,29" ; Default HL7 fields
"RTN","RORHL01",25,0)
 D  ; Either new or old race information
"RTN","RORHL01",26,0)
 . N DFN,VADM  S DFN=RORDFN  D DEM^VADPT
"RTN","RORHL01",27,0)
 . S RORFLDS=RORFLDS_$S($G(VADM(12))>0:",10BT",1:",10")
"RTN","RORHL01",28,0)
 ;
"RTN","RORHL01",29,0)
 ; Call Standard PID Segment builder
"RTN","RORHL01",30,0)
 S RORSEG=$$EN^VAFHLPID(RORDFN,RORFLDS)
"RTN","RORHL01",31,0)
 S:$G(VAFPID(1))'="" RORSEG=RORSEG_VAFPID(1)
"RTN","RORHL01",32,0)
 ;
"RTN","RORHL01",33,0)
 ; PID-2 ICN
"RTN","RORHL01",34,0)
 S TMP=$$ICN^RORUTL02(RORDFN)
"RTN","RORHL01",35,0)
 I TMP>0  S $P(RORSEG,HLFS,3)=$TR(TMP,"V",CS)_CS_"ISO"_CS_"VAMPI"
"RTN","RORHL01",36,0)
 E  S $P(RORSEG,HLFS,3)=""
"RTN","RORHL01",37,0)
 ;
"RTN","RORHL01",38,0)
 ; PID-3 DFN + Old-ICN and Old-SSN if applicable
"RTN","RORHL01",39,0)
 S TMP=""
"RTN","RORHL01",40,0)
 S $P(TMP,CS,1,3)=$$M10^HLFNC(RORDFN,CS)
"RTN","RORHL01",41,0)
 S $P(TMP,CS,5)="PI"
"RTN","RORHL01",42,0)
 S $P(TMP,CS,6)=$$SITE^RORUTL03(SCS)
"RTN","RORHL01",43,0)
 S $P(RORSEG,HLFS,4)=TMP
"RTN","RORHL01",44,0)
 ;
"RTN","RORHL01",45,0)
 ; PID-5 Encrypt Patient Name
"RTN","RORHL01",46,0)
 S $P(RORSEG,HLFS,6)=$$ENCRYPT^RORUTL03($P(RORSEG,HLFS,6))
"RTN","RORHL01",47,0)
 ;
"RTN","RORHL01",48,0)
 ; PID-11 Remove Address (leave ZIP only)
"RTN","RORHL01",49,0)
 S $P(RORSEG,HLFS,12)=CS_CS_CS_CS_$P($P(RORSEG,HLFS,12),CS,5)
"RTN","RORHL01",50,0)
 ;
"RTN","RORHL01",51,0)
 ; PID-19 Encrypt SSN
"RTN","RORHL01",52,0)
 S $P(RORSEG,HLFS,20)=$$ENCRYPT^RORUTL03($P(RORSEG,HLFS,20))
"RTN","RORHL01",53,0)
 ;
"RTN","RORHL01",54,0)
 ; PID-29 Date of Death (not supported by EN^VAFHLPID)
"RTN","RORHL01",55,0)
 S TMP=$$GET1^DIQ(2,RORDFN,.351,"I",,"RORMSG")
"RTN","RORHL01",56,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"PID^RORHL01",,2,RORDFN)
"RTN","RORHL01",57,0)
 S:TMP $P(RORSEG,HLFS,30)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL01",58,0)
 ;
"RTN","RORHL01",59,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL01",60,0)
 D SETSEG^RORHL7(.RORPTR,.RORSEG)
"RTN","RORHL01",61,0)
 ;
"RTN","RORHL01",62,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL01",63,0)
 ;
"RTN","RORHL01",64,0)
ZSP(RORDFN,RORPTR,HLFS,HLECH) ; ZSP SEGMENT
"RTN","RORHL01",65,0)
 ;
"RTN","RORHL01",66,0)
 ; INPUT:  RORDFN - DFN of Patient Record in File #2          (Req'd)
"RTN","RORHL01",67,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                  (Opt'l)
"RTN","RORHL01",68,0)
 ;         HLFS   - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL01",69,0)
 ;         HLECH  - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL01",70,0)
 ;
"RTN","RORHL01",71,0)
 N I,RORFLDS,RORRES,RORSEG
"RTN","RORHL01",72,0)
 ;
"RTN","RORHL01",73,0)
 S RORRES=0
"RTN","RORHL01",74,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL01",75,0)
 ;
"RTN","RORHL01",76,0)
 S RORDFN=+$G(RORDFN)  I '$D(^DPT(RORDFN))  D  Q RORRES
"RTN","RORHL01",77,0)
 . S RORRES=$$ERROR^RORERR(-36,"ZSP^RORHL01",,RORDFN,2)
"RTN","RORHL01",78,0)
 ;
"RTN","RORHL01",79,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL01",80,0)
 ;
"RTN","RORHL01",81,0)
 S RORFLDS="1,2,3,4" ; Default HL7 fields
"RTN","RORHL01",82,0)
 ;
"RTN","RORHL01",83,0)
 ; Call Standard ZSP Segment Builder
"RTN","RORHL01",84,0)
 S RORSEG=$$EN^VAFHLZSP(RORDFN)
"RTN","RORHL01",85,0)
 ;
"RTN","RORHL01",86,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL01",87,0)
 D SETSEG^RORHL7(.RORPTR,.RORSEG)
"RTN","RORHL01",88,0)
 ;
"RTN","RORHL01",89,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL01",90,0)
 ;
"RTN","RORHL01",91,0)
ZRD(RORDFN,RORPTR,HLFS,HLECH) ; ZRD SEGMENT(S)
"RTN","RORHL01",92,0)
 ;
"RTN","RORHL01",93,0)
 ; INPUT:  RORDFN - DFN of Patient Record in File #2          (Req'd)
"RTN","RORHL01",94,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                  (Opt'l)
"RTN","RORHL01",95,0)
 ;         HLFS   - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL01",96,0)
 ;         HLECH  - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL01",97,0)
 ;
"RTN","RORHL01",98,0)
 N I,RORFLDS,RORRES,RORSEG
"RTN","RORHL01",99,0)
 ;
"RTN","RORHL01",100,0)
 S RORRES=0
"RTN","RORHL01",101,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL01",102,0)
 ;
"RTN","RORHL01",103,0)
 S RORDFN=+$G(RORDFN) I '$D(^DPT(RORDFN))  D  Q RORRES
"RTN","RORHL01",104,0)
 . S RORRES=$$ERROR^RORERR(-36,"ZRD^RORHL01",,RORDFN,2)
"RTN","RORHL01",105,0)
 ;
"RTN","RORHL01",106,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL01",107,0)
 ;
"RTN","RORHL01",108,0)
 S RORFLDS="1,2,3,4" ; Default HL7 fields
"RTN","RORHL01",109,0)
 ;
"RTN","RORHL01",110,0)
 ; Call Standard ZRD Segment Builder
"RTN","RORHL01",111,0)
 D EN^VAFHLZRD(RORDFN,RORFLDS,,HLFS,"RORSEG")
"RTN","RORHL01",112,0)
 ;
"RTN","RORHL01",113,0)
 ;--- Store the segment(s) in ^TMP("HLS",$J)
"RTN","RORHL01",114,0)
 S I=""
"RTN","RORHL01",115,0)
 F  S I=$O(RORSEG(I))  Q:I=""  Q:$P($G(RORSEG(I,0)),HLFS,3)=""  D
"RTN","RORHL01",116,0)
 . D SETSEG^RORHL7(.RORPTR,RORSEG(I,0))
"RTN","RORHL01",117,0)
 ;
"RTN","RORHL01",118,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL04")
0^35^B15650069
"RTN","RORHL04",1,0)
RORHL04 ;HOIFO/CRT,SG - HL7 Segment APIs - RADIOLOGY ; 12/26/02 12:33pm
"RTN","RORHL04",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3**;May 14, 2002
"RTN","RORHL04",3,0)
 ;
"RTN","RORHL04",4,0)
 ; External reference to EN1^RAO7PC1 supported by DBIA 2043
"RTN","RORHL04",5,0)
 ;
"RTN","RORHL04",6,0)
 Q
"RTN","RORHL04",7,0)
 ;
"RTN","RORHL04",8,0)
 ;***** SEARCHES RADIOLOGY FOR DATA
"RTN","RORHL04",9,0)
 ;
"RTN","RORHL04",10,0)
 ; RORDFN        IEN of the patient in the PATIENT file (#2)
"RTN","RORHL04",11,0)
 ; RORSTDT       Start date (FileMan)
"RTN","RORHL04",12,0)
 ; RORENDT       End date   (FileMan)
"RTN","RORHL04",13,0)
 ; [RORFILE]     Closed root of the output buffer
"RTN","RORHL04",14,0)
 ;               ($NA(^TMP("HLS",$J)) by default)
"RTN","RORHL04",15,0)
 ; [.RORPTR]
"RTN","RORHL04",16,0)
 ; [HLFS]        Field separator ("|" by default)
"RTN","RORHL04",17,0)
 ; [HLECH]       Encoding characters ("^~\&" by default)
"RTN","RORHL04",18,0)
 ;
"RTN","RORHL04",19,0)
 ; Return Values:
"RTN","RORHL04",20,0)
 ;       <0  Error code
"RTN","RORHL04",21,0)
 ;        0  Ok
"RTN","RORHL04",22,0)
 ;
"RTN","RORHL04",23,0)
 ; The ^TMP($J,"RAE1") global node is used by the function.
"RTN","RORHL04",24,0)
 ;
"RTN","RORHL04",25,0)
EN1(RORDFN,RORSTDT,RORENDT,RORPTR,RORFILE,HLFS,HLECH) ;
"RTN","RORHL04",26,0)
 N EXAMID,RACNI,RADTI,RAIENS,RC
"RTN","RORHL04",27,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL04",28,0)
 ;
"RTN","RORHL04",29,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL04",30,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL04",31,0)
 ;
"RTN","RORHL04",32,0)
 S RORDFN=+$G(RORDFN)
"RTN","RORHL04",33,0)
 Q:'$D(^DPT(RORDFN)) $$ERROR^RORERR(-36,"EN1^RORHL04",,RORDFN,2)
"RTN","RORHL04",34,0)
 Q:'$D(^RADPT(RORDFN)) 0
"RTN","RORHL04",35,0)
 ;
"RTN","RORHL04",36,0)
 K ^TMP($J,"RAE1")
"RTN","RORHL04",37,0)
 D EN1^RAO7PC1(RORDFN,RORSTDT,RORENDT,999999999)
"RTN","RORHL04",38,0)
 ;
"RTN","RORHL04",39,0)
 S EXAMID="",RC=0
"RTN","RORHL04",40,0)
 F  S EXAMID=$O(^TMP($J,"RAE1",RORDFN,EXAMID))  Q:EXAMID=""  D  Q:RC<0
"RTN","RORHL04",41,0)
 . S RADTI=$P(EXAMID,"-"),RACNI=$P(EXAMID,"-",2)
"RTN","RORHL04",42,0)
 . S RAIENS=RACNI_","_RADTI_","_RORDFN_","
"RTN","RORHL04",43,0)
 . S RC=$$OBR(RAIENS,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL04",44,0)
 ;
"RTN","RORHL04",45,0)
 K ^TMP($J,"RAE1")
"RTN","RORHL04",46,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORHL04",47,0)
 ;
"RTN","RORHL04",48,0)
 ;***** GENERATES THE RADIOLOGY OBR SEGMENT
"RTN","RORHL04",49,0)
 ;
"RTN","RORHL04",50,0)
 ; RORIENS       IENS of the radiology record in the file #70.03
"RTN","RORHL04",51,0)
 ; [RORPTR]        
"RTN","RORHL04",52,0)
 ; [RORFILE]     Closed root of the output buffer
"RTN","RORHL04",53,0)
 ;               ($NA(^TMP("HLS",$J)) by default)
"RTN","RORHL04",54,0)
 ; [HLFS]        Field separator ("|" by default)
"RTN","RORHL04",55,0)
 ; [HLECH]       Encoding characters ("^~\&" by default)
"RTN","RORHL04",56,0)
 ;
"RTN","RORHL04",57,0)
 ; Return Values:
"RTN","RORHL04",58,0)
 ;       <0  Error code
"RTN","RORHL04",59,0)
 ;        0  Ok
"RTN","RORHL04",60,0)
 ;
"RTN","RORHL04",61,0)
OBR(RORIENS,RORPTR,RORFILE,HLFS,HLECH) ; OBR SEGMENT (Radiology Data)
"RTN","RORHL04",62,0)
 N BUF,CPTIENS,CS,IEN7002,RACN0,RADTE,RC,RORMSG,ROROUT,RORSEG,TMP
"RTN","RORHL04",63,0)
 S RC=0
"RTN","RORHL04",64,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL04",65,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL04",66,0)
 ;
"RTN","RORHL04",67,0)
 S:$E(RORIENS,$L(RORIENS))'="," RORIENS=RORIENS_","
"RTN","RORHL04",68,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL04",69,0)
 S CS=$E(HLECH,1)
"RTN","RORHL04",70,0)
 ;
"RTN","RORHL04",71,0)
 D GETS^DIQ(70.03,RORIENS,".01;2;14","IE","ROROUT","RORMSG")
"RTN","RORHL04",72,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL04",,70.03,RORIENS)
"RTN","RORHL04",73,0)
 S IEN7002=$P(RORIENS,",",2,3)_","
"RTN","RORHL04",74,0)
 D GETS^DIQ(70.02,IEN7002,".01;3","IE","ROROUT","RORMSG")
"RTN","RORHL04",75,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL04",,70.02,IEN7002)
"RTN","RORHL04",76,0)
 ;
"RTN","RORHL04",77,0)
 S $P(RORSEG,HLFS,1)="OBR"
"RTN","RORHL04",78,0)
 ;
"RTN","RORHL04",79,0)
 ;--- OBR-3 - Unique Accession #
"RTN","RORHL04",80,0)
 S BUF=""
"RTN","RORHL04",81,0)
 S $P(BUF,CS,1)=$P(RORIENS,",",2)_"-"_$P(RORIENS,",",1)
"RTN","RORHL04",82,0)
 S RADTE=$P($G(ROROUT(70.02,IEN7002,.01,"I")),".")
"RTN","RORHL04",83,0)
 S RACN0=$G(ROROUT(70.03,RORIENS,.01,"I"))
"RTN","RORHL04",84,0)
 S $P(BUF,CS,2)=$E(RADTE,4,7)_$E(RADTE,2,3)_"-"_+RACN0
"RTN","RORHL04",85,0)
 S $P(BUF,CS,3)="L"
"RTN","RORHL04",86,0)
 S:$P(BUF,CS)'="" $P(RORSEG,HLFS,4)=BUF
"RTN","RORHL04",87,0)
 ;
"RTN","RORHL04",88,0)
 ;--- OBR-4 - Procedure & CPT Code
"RTN","RORHL04",89,0)
 S BUF=""
"RTN","RORHL04",90,0)
 S $P(BUF,CS,6)="99RAP"
"RTN","RORHL04",91,0)
 S $P(BUF,CS,5)=$$ESCAPE^RORHL7($G(ROROUT(70.03,RORIENS,2,"E")))
"RTN","RORHL04",92,0)
 S $P(BUF,CS,4)=$G(ROROUT(70.03,RORIENS,2,"I"))
"RTN","RORHL04",93,0)
 ;
"RTN","RORHL04",94,0)
 S CPTIENS=$$GET1^DIQ(71,+$P(BUF,CS,4),9,"I",,"RORMSG")_","
"RTN","RORHL04",95,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL04",,71,+$P(BUF,CS,4))
"RTN","RORHL04",96,0)
 ;
"RTN","RORHL04",97,0)
 D GETS^DIQ(81,CPTIENS,".01;2","E","ROROUT","RORMSG")
"RTN","RORHL04",98,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL04",,81,CPTIENS)
"RTN","RORHL04",99,0)
 S $P(BUF,CS,1)=$G(ROROUT(81,CPTIENS,.01,"E"))
"RTN","RORHL04",100,0)
 S $P(BUF,CS,2)=$$ESCAPE^RORHL7($G(ROROUT(81,CPTIENS,2,"E")))
"RTN","RORHL04",101,0)
 S $P(BUF,CS,3)="C4"
"RTN","RORHL04",102,0)
 S $P(RORSEG,HLFS,5)=BUF
"RTN","RORHL04",103,0)
 ;
"RTN","RORHL04",104,0)
 ;--- OBR-7 - Exam Date/Time
"RTN","RORHL04",105,0)
 S TMP=$G(ROROUT(70.02,IEN7002,.01,"I"))
"RTN","RORHL04",106,0)
 S:TMP $P(RORSEG,HLFS,8)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL04",107,0)
 ;
"RTN","RORHL04",108,0)
 ;--- OBR-16 - Requesting Physician
"RTN","RORHL04",109,0)
 S $P(RORSEG,HLFS,17)=$G(ROROUT(70.03,RORIENS,14,"I"))
"RTN","RORHL04",110,0)
 ;
"RTN","RORHL04",111,0)
 ;--- OBR-24 - Service Section ID
"RTN","RORHL04",112,0)
 S $P(RORSEG,HLFS,25)="RAD"
"RTN","RORHL04",113,0)
 ;
"RTN","RORHL04",114,0)
 ;--- OBR-44 - Division
"RTN","RORHL04",115,0)
 S $P(RORSEG,HLFS,45)=$$SITE1^RORUTL03(CS)
"RTN","RORHL04",116,0)
 S TMP=""
"RTN","RORHL04",117,0)
 S $P(TMP,CS,3)=$$GET1^DIQ(4,+$G(ROROUT(70.02,IEN7002,3,"I")),99,"I")
"RTN","RORHL04",118,0)
 S $P(TMP,CS,2)="99VA4"
"RTN","RORHL04",119,0)
 S $P(TMP,CS,1)=$G(ROROUT(70.02,IEN7002,3,"E"))
"RTN","RORHL04",120,0)
 S:$P(TMP,CS,3)]"" $P(RORSEG,HLFS,45)=TMP
"RTN","RORHL04",121,0)
 ;
"RTN","RORHL04",122,0)
 ;--- Store the segment
"RTN","RORHL04",123,0)
 D SETSEG^RORHL7(.RORPTR,.RORSEG,RORFILE)
"RTN","RORHL04",124,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORLOG")
0^24^B38852696
"RTN","RORLOG",1,0)
RORLOG ;HCIOFO/SG - LOG FILE MANAGEMENT ; 11/1/02 9:02am
"RTN","RORLOG",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORLOG",3,0)
 ;
"RTN","RORLOG",4,0)
 ; RORLOG -------------- CONSTANT & VARIABLES OF THE LOG SUSBSYSTEM
"RTN","RORLOG",5,0)
 ;
"RTN","RORLOG",6,0)
 ; RORLOG("IEN")         IEN of the main record in the ROR LOG file
"RTN","RORLOG",7,0)
 ;
"RTN","RORLOG",8,0)
 Q
"RTN","RORLOG",9,0)
 ;
"RTN","RORLOG",10,0)
 ;***** CLOSES THE CURRENT LOG
"RTN","RORLOG",11,0)
 ;
"RTN","RORLOG",12,0)
 ; [MESSAGE]     Text of the final message
"RTN","RORLOG",13,0)
 ; [COUNTERS]    Statistic counters
"RTN","RORLOG",14,0)
 ;                 ^1: Total number of processed patients
"RTN","RORLOG",15,0)
 ;                 ^2: Number of patients processed with errors
"RTN","RORLOG",16,0)
 ;
"RTN","RORLOG",17,0)
CLOSE(MESSAGE,COUNTERS) ;
"RTN","RORLOG",18,0)
 Q:$G(RORLOG("IEN"))'>0
"RTN","RORLOG",19,0)
 N BDT,EDT,IENS,RATE,RORFDA,RORINFO,RORMSG,TMP
"RTN","RORLOG",20,0)
 S EDT=$$NOW^XLFDT
"RTN","RORLOG",21,0)
 S IENS=RORLOG("IEN")_","
"RTN","RORLOG",22,0)
 ;--- Prepare statistic data
"RTN","RORLOG",23,0)
 D:$G(COUNTERS)>0
"RTN","RORLOG",24,0)
 . S RORINFO(1)="Patients:     "_+$P(COUNTERS,U)
"RTN","RORLOG",25,0)
 . S RORINFO(2)="Errors:       "_+$P(COUNTERS,U,2)
"RTN","RORLOG",26,0)
 . S BDT=$$GET1^DIQ(798.7,IENS,.01,"I",,"RORMSG")
"RTN","RORLOG",27,0)
 . Q:$G(BDT)'>0
"RTN","RORLOG",28,0)
 . S TMP=$$FMDIFF^XLFDT(EDT,BDT,2)
"RTN","RORLOG",29,0)
 . S RATE=$S(TMP>0:$J(COUNTERS/TMP,0,3),1:"")
"RTN","RORLOG",30,0)
 . S RORINFO(3)="Time (sec):   "_TMP
"RTN","RORLOG",31,0)
 . S:RATE RORINFO(4)="Patients/sec: "_RATE
"RTN","RORLOG",32,0)
 . ;--- Data for the log header
"RTN","RORLOG",33,0)
 . S RORFDA(798.7,IENS,6.01)=$P(COUNTERS,U,1)
"RTN","RORLOG",34,0)
 . S RORFDA(798.7,IENS,6.02)=$P(COUNTERS,U,2)
"RTN","RORLOG",35,0)
 . S:RATE RORFDA(798.7,IENS,6.03)=RATE
"RTN","RORLOG",36,0)
 ;--- Store data in the header and log the final message (if any)
"RTN","RORLOG",37,0)
 S RORFDA(798.7,IENS,5)=EDT
"RTN","RORLOG",38,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORLOG",39,0)
 D:$G(MESSAGE)'="" LOG^RORLOG(,MESSAGE,,.RORINFO)
"RTN","RORLOG",40,0)
 K RORLOG
"RTN","RORLOG",41,0)
 Q
"RTN","RORLOG",42,0)
 ;
"RTN","RORLOG",43,0)
 ;***** PUTS MESSAGE IN THE LOG
"RTN","RORLOG",44,0)
 ;
"RTN","RORLOG",45,0)
 ; [TYPE]        Type of the event:
"RTN","RORLOG",46,0)
 ;                 1  Debug
"RTN","RORLOG",47,0)
 ;                 2  Information
"RTN","RORLOG",48,0)
 ;                 3  Data quality
"RTN","RORLOG",49,0)
 ;                 4  Warning
"RTN","RORLOG",50,0)
 ;                 5  Database error
"RTN","RORLOG",51,0)
 ;                 6  Error
"RTN","RORLOG",52,0)
 ;
"RTN","RORLOG",53,0)
 ;       If value of the parameter is omitted or equals 0, the message
"RTN","RORLOG",54,0)
 ;       is logged as "information" (if log is enabled). This mode is
"RTN","RORLOG",55,0)
 ;       intended for log headers and separators.
"RTN","RORLOG",56,0)
 ;
"RTN","RORLOG",57,0)
 ; MESSAGE       Message text
"RTN","RORLOG",58,0)
 ; [PATIEN]      Patient IEN
"RTN","RORLOG",59,0)
 ;
"RTN","RORLOG",60,0)
 ; [[.]RORINFO]  Optional additional information (either a string or
"RTN","RORLOG",61,0)
 ;               a reference to a local array that contains strings
"RTN","RORLOG",62,0)
 ;               prepared for storing in a word processing field)
"RTN","RORLOG",63,0)
 ;
"RTN","RORLOG",64,0)
LOG(TYPE,MESSAGE,PATIEN,RORINFO) ;
"RTN","RORLOG",65,0)
 ;--- Do not do anything if log is disabled
"RTN","RORLOG",66,0)
 Q:'$G(RORPARM("LOG"))
"RTN","RORLOG",67,0)
 ;--- Check if collection of this kind of event is enabled.
"RTN","RORLOG",68,0)
 ;    Debug messages could be enabled only explicitly.
"RTN","RORLOG",69,0)
 I '$G(TYPE)  S TYPE=2
"RTN","RORLOG",70,0)
 E  I ($D(RORPARM("LOG"))>1)!(TYPE=1)  Q:'$G(RORPARM("LOG",+TYPE))
"RTN","RORLOG",71,0)
 ;---
"RTN","RORLOG",72,0)
 N CURRIO,DATETIME,I,IENS,RC,RORFDA,RORMSG,TMP
"RTN","RORLOG",73,0)
 I $D(RORINFO)=1  S TMP=RORINFO  K RORINFO  S RORINFO(1)=TMP  K TMP
"RTN","RORLOG",74,0)
 S DATETIME=$$NOW^XLFDT
"RTN","RORLOG",75,0)
 ;--- Add a new record to the log (if it has been open)
"RTN","RORLOG",76,0)
 D:$G(RORLOG("IEN"))>0
"RTN","RORLOG",77,0)
 . S IENS="+1,"_RORLOG("IEN")_","
"RTN","RORLOG",78,0)
 . S RORFDA(798.74,IENS,.01)=DATETIME
"RTN","RORLOG",79,0)
 . S RORFDA(798.74,IENS,1)=+TYPE
"RTN","RORLOG",80,0)
 . S RORFDA(798.74,IENS,2)=$E(MESSAGE,1,70)
"RTN","RORLOG",81,0)
 . S:$G(PATIEN) RORFDA(798.74,IENS,3)=+PATIEN
"RTN","RORLOG",82,0)
 . S:$D(RORINFO)>1 RORFDA(798.74,IENS,4)="RORINFO"
"RTN","RORLOG",83,0)
 . D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORLOG",84,0)
 ;--- Display message (if debug mode 2 is enabled)
"RTN","RORLOG",85,0)
 I $G(RORPARM("DEBUG"))>1  U $G(IO(0))  D  U IO
"RTN","RORLOG",86,0)
 . W !,$P($$FMTE^XLFDT(DATETIME,"2FS"),"@",2)_" "_$E(MESSAGE,1,70),!
"RTN","RORLOG",87,0)
 . S I=""
"RTN","RORLOG",88,0)
 . F  S I=$O(RORINFO(I))  Q:I=""  D  W ?9,TMP,!
"RTN","RORLOG",89,0)
 . . S TMP=$G(RORINFO(I))  S:TMP="" TMP=$G(RORINFO(I,0))
"RTN","RORLOG",90,0)
 . W:$G(PATIEN) ?9,"Patient IEN: "_PATIEN,!
"RTN","RORLOG",91,0)
 Q
"RTN","RORLOG",92,0)
 ;
"RTN","RORLOG",93,0)
 ;***** RETURNS AN IEN OF THE CURRENT LOG
"RTN","RORLOG",94,0)
LOGIEN() ;
"RTN","RORLOG",95,0)
 Q +$G(RORLOG("IEN"))
"RTN","RORLOG",96,0)
 ;
"RTN","RORLOG",97,0)
 ;***** OPENS A NEW LOG
"RTN","RORLOG",98,0)
 ;
"RTN","RORLOG",99,0)
 ; [[.]REGLST]   Either name of the registry or reference to a local
"RTN","RORLOG",100,0)
 ;               array containing registry names as subscripts and
"RTN","RORLOG",101,0)
 ;               optional registry IENs as values
"RTN","RORLOG",102,0)
 ;
"RTN","RORLOG",103,0)
 ; [ACTIVITY]    Type of the activity:
"RTN","RORLOG",104,0)
 ;                 0  Other (default)
"RTN","RORLOG",105,0)
 ;                 1  Registry update
"RTN","RORLOG",106,0)
 ;                 2  Data Extract
"RTN","RORLOG",107,0)
 ;                 3  Acknowledgement
"RTN","RORLOG",108,0)
 ;                 4  Hist. Extraction
"RTN","RORLOG",109,0)
 ;
"RTN","RORLOG",110,0)
 ; [MESSAGE]     Text of the first message
"RTN","RORLOG",111,0)
 ;
"RTN","RORLOG",112,0)
 ; Return Values:
"RTN","RORLOG",113,0)
 ;       <0  Error code
"RTN","RORLOG",114,0)
 ;        0  Ok
"RTN","RORLOG",115,0)
 ;
"RTN","RORLOG",116,0)
OPEN(REGLST,ACTIVITY,MESSAGE) ;
"RTN","RORLOG",117,0)
 Q:'$G(RORPARM("LOG")) 0
"RTN","RORLOG",118,0)
 N I,IENS,RC,REGIEN,REGNAME,RORFDA,RORIEN,RORINFO,RORMSG
"RTN","RORLOG",119,0)
 K RORLOG
"RTN","RORLOG",120,0)
 ;--- Prepare the list of registries
"RTN","RORLOG",121,0)
 S:$D(REGLST)=1 REGLST(REGLST)=""
"RTN","RORLOG",122,0)
 S REGNAME="",(I,RC)=0
"RTN","RORLOG",123,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORLOG",124,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORLOG",125,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=REGIEN  Q
"RTN","RORLOG",126,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORLOG",127,0)
 . S I=I+1,RORINFO(I)=REGNAME
"RTN","RORLOG",128,0)
 . S RORFDA(798.73,"+"_(I+10)_",+1,",.01)=REGIEN
"RTN","RORLOG",129,0)
 Q:RC<0 RC
"RTN","RORLOG",130,0)
 ;--- Add a log header (main record) to the ROR LOG file
"RTN","RORLOG",131,0)
 S IENS="+1,"
"RTN","RORLOG",132,0)
 S RORFDA(798.7,IENS,.01)=$$NOW^XLFDT
"RTN","RORLOG",133,0)
 S:$G(ACTIVITY)>0 RORFDA(798.7,IENS,1)=ACTIVITY
"RTN","RORLOG",134,0)
 S RORFDA(798.7,IENS,2)=$J
"RTN","RORLOG",135,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORLOG",136,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"OPEN^RORLOG")  Q:RC<0 RC
"RTN","RORLOG",137,0)
 ;--- Initialize variables and write a header (if any)
"RTN","RORLOG",138,0)
 S RORLOG("IEN")=RORIEN(1)
"RTN","RORLOG",139,0)
 D:$G(MESSAGE)'="" LOG(,MESSAGE,,.RORINFO)
"RTN","RORLOG",140,0)
 Q 0
"RTN","RORLOG",141,0)
 ;
"RTN","RORLOG",142,0)
 ;***** PURGES THE OLD LOGS
"RTN","RORLOG",143,0)
 ;
"RTN","RORLOG",144,0)
 ; [DKEEP]       Days to keep logs in the file (by default = 31)
"RTN","RORLOG",145,0)
 ;
"RTN","RORLOG",146,0)
 ; Return Values:
"RTN","RORLOG",147,0)
 ;       <0  Error code
"RTN","RORLOG",148,0)
 ;        0  Ok
"RTN","RORLOG",149,0)
 ;
"RTN","RORLOG",150,0)
PURGE(DKEEP) ;
"RTN","RORLOG",151,0)
 N HDR,IENS,IR,RC,RORFDA,RORFROM,RORMSG
"RTN","RORLOG",152,0)
 S RORFROM=$$FMADD^XLFDT($$DT^XLFDT,-$G(DKEEP,31))+1
"RTN","RORLOG",153,0)
 S RC=0
"RTN","RORLOG",154,0)
 F  D  Q:'$P($G(HDR),U,3)!(RC<0)
"RTN","RORLOG",155,0)
 . K RORFDA,RORMSG
"RTN","RORLOG",156,0)
 . ;--- Get the next ten records
"RTN","RORLOG",157,0)
 . D LIST^DIC(798.7,,"@","BU",10,.RORFROM,,"B",,,"RORFDA","RORMSG")
"RTN","RORLOG",158,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"PURGE^RORLOG")  Q:RC<0
"RTN","RORLOG",159,0)
 . ;--- Stop if no records left
"RTN","RORLOG",160,0)
 . S HDR=$G(RORFDA("DILIST",0))  Q:'HDR
"RTN","RORLOG",161,0)
 . ;--- Prepare the data
"RTN","RORLOG",162,0)
 . S IR=""
"RTN","RORLOG",163,0)
 . F  S IR=$O(RORFDA("DILIST",2,IR),-1)  Q:IR=""  D
"RTN","RORLOG",164,0)
 . . S RORFDA(798.7,RORFDA("DILIST",2,IR)_",",.01)="@"
"RTN","RORLOG",165,0)
 . K RORFDA("DILIST")
"RTN","RORLOG",166,0)
 . ;--- Delete the records
"RTN","RORLOG",167,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORLOG",168,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"PURGE^RORLOG")
"RTN","RORLOG",169,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORLOG",170,0)
 ;
"RTN","RORLOG",171,0)
 ;***** REPLACES LIST OF REGISTRIES ASSOCIATED WITH THE CURRENT LOG
"RTN","RORLOG",172,0)
 ;
"RTN","RORLOG",173,0)
 ; [.]REGLST     Either name of the registry or a reference to a local
"RTN","RORLOG",174,0)
 ;               array containing registry names as subscripts and
"RTN","RORLOG",175,0)
 ;               optional registry IENs as values.
"RTN","RORLOG",176,0)
 ;
"RTN","RORLOG",177,0)
 ; [NOLP]        If this parameter is defined and non-zero, the log
"RTN","RORLOG",178,0)
 ;               subsystem parameters will not be updated according
"RTN","RORLOG",179,0)
 ;               to the new list of associated registries.
"RTN","RORLOG",180,0)
 ;
"RTN","RORLOG",181,0)
 ; Return Values:
"RTN","RORLOG",182,0)
 ;       <0  Error code
"RTN","RORLOG",183,0)
 ;        0  Ok
"RTN","RORLOG",184,0)
 ;
"RTN","RORLOG",185,0)
SETRGLST(REGLST,NOLP) ;
"RTN","RORLOG",186,0)
 N I,IENS,RC,REGIEN,RILST,RORBUF,RORFDA,RORMSG
"RTN","RORLOG",187,0)
 S IENS=$$LOGIEN()_","
"RTN","RORLOG",188,0)
 Q:'$G(RORPARM("LOG"))!(IENS'>0) 0
"RTN","RORLOG",189,0)
 ;--- Compile a list of registry IENs (as subscripts)
"RTN","RORLOG",190,0)
 S:$D(REGLST)=1 REGLST(REGLST)=""
"RTN","RORLOG",191,0)
 S I="",RC=0
"RTN","RORLOG",192,0)
 F  S I=$O(REGLST(I))  Q:I=""  D  Q:RC<0
"RTN","RORLOG",193,0)
 . S REGIEN=+$G(REGLST(I))
"RTN","RORLOG",194,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=REGIEN  Q
"RTN","RORLOG",195,0)
 . . S REGIEN=$$REGIEN^RORUTL02(I)
"RTN","RORLOG",196,0)
 . S RILST(REGIEN)=""
"RTN","RORLOG",197,0)
 Q:RC<0 RC
"RTN","RORLOG",198,0)
 ;--- Delete old registries from the multiple of the log record
"RTN","RORLOG",199,0)
 D LIST^DIC(798.73,","_IENS,"@;.01I","U",,,,"B",,,"RORBUF","RORMSG")
"RTN","RORLOG",200,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"SETRGLST^RORLOG")  Q:RC<0 RC
"RTN","RORLOG",201,0)
 S I=""
"RTN","RORLOG",202,0)
 F  S I=$O(RORBUF("DILIST",2,I))  Q:I=""  D
"RTN","RORLOG",203,0)
 . S REGIEN=RORBUF("DILIST","ID",I,.01)
"RTN","RORLOG",204,0)
 . I $D(RILST(REGIEN))  K RILST(REGIEN)  Q
"RTN","RORLOG",205,0)
 . S RORFDA(798.73,RORBUF("DILIST",2,I)_","_IENS,.01)="@"
"RTN","RORLOG",206,0)
 I $D(RORFDA)>1  D  Q:RC<0 RC
"RTN","RORLOG",207,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORLOG",208,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"SETRGLST^RORLOG")
"RTN","RORLOG",209,0)
 ;--- Add new registries to the multiple
"RTN","RORLOG",210,0)
 S REGIEN=""
"RTN","RORLOG",211,0)
 F I=1:1  S REGIEN=$O(RILST(REGIEN))  Q:REGIEN=""  D
"RTN","RORLOG",212,0)
 . S RORFDA(798.73,"+"_I_","_IENS,.01)=REGIEN
"RTN","RORLOG",213,0)
 I $D(RORFDA)>1  D  Q:RC<0 RC
"RTN","RORLOG",214,0)
 . D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORLOG",215,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"SETRGLST^RORLOG")
"RTN","RORLOG",216,0)
 ;--- Reload parameters (if necessary)
"RTN","RORLOG",217,0)
 I '$G(NOLP)  D  Q:RC<0 RC
"RTN","RORLOG",218,0)
 . K RORPARM("LOG")  S RC=$$PARAMS^RORLOG01(.REGLST)
"RTN","RORLOG",219,0)
 Q 0
"RTN","RORLOG",220,0)
 ;
"RTN","RORLOG",221,0)
 ;***** INITIALIZES THE LOG SUBSYSTEM
"RTN","RORLOG",222,0)
 ;
"RTN","RORLOG",223,0)
 ; [[.]REGLST]   Either a reference to a local array containing names
"RTN","RORLOG",224,0)
 ;               of the registries to process (as subscripts) or a
"RTN","RORLOG",225,0)
 ;               string that contains a name of the single registry.
"RTN","RORLOG",226,0)
 ;
"RTN","RORLOG",227,0)
 ; Return Values:
"RTN","RORLOG",228,0)
 ;       <0  Error code
"RTN","RORLOG",229,0)
 ;        0  Ok
"RTN","RORLOG",230,0)
 ;
"RTN","RORLOG",231,0)
SETUP(REGLST) ;
"RTN","RORLOG",232,0)
 K RORPARM("LOG"),RORLOG
"RTN","RORLOG",233,0)
 S:$D(REGLST)=1 REGLST(REGLST)=""
"RTN","RORLOG",234,0)
 Q $$PARAMS^RORLOG01(.REGLST)
"RTN","RORLOG01")
0^27^B3482024
"RTN","RORLOG01",1,0)
RORLOG01 ;HCIOFO/SG - LOG FILE MANAGEMENT (UTILITIES) ; 11/1/02 10:40am
"RTN","RORLOG01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORLOG01",3,0)
 ;
"RTN","RORLOG01",4,0)
 Q
"RTN","RORLOG01",5,0)
 ;
"RTN","RORLOG01",6,0)
 ;***** LOADS THE LOG SUBSYSTEM PARAMETERS
"RTN","RORLOG01",7,0)
 ;
"RTN","RORLOG01",8,0)
 ; .RORLST       Reference to a local array containing names
"RTN","RORLOG01",9,0)
 ;               of the registries to process (as subscripts).
"RTN","RORLOG01",10,0)
 ;
"RTN","RORLOG01",11,0)
 ; Return Values:
"RTN","RORLOG01",12,0)
 ;       <0  Error code
"RTN","RORLOG01",13,0)
 ;        0  Ok
"RTN","RORLOG01",14,0)
 ;
"RTN","RORLOG01",15,0)
PARAMS(RORLST) ;
"RTN","RORLOG01",16,0)
 N ENABLE,IENS,IR,IRS,RC,RORBUF,RORMSG,RORSB,SCR,TYPE
"RTN","RORLOG01",17,0)
 ;--- Load a list of parameters of active registries
"RTN","RORLOG01",18,0)
 S SCR="I '$P(^(0),U,7),$D(RORLST(+$P(^(0),U)))"
"RTN","RORLOG01",19,0)
 D LIST^DIC(798.1,,"@;8I","U","*",,,"B",SCR,,"RORBUF","RORMSG")
"RTN","RORLOG01",20,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"PARAMS^RORLOG01")  Q:RC<0 RC
"RTN","RORLOG01",21,0)
 I '$G(RORBUF("DILIST",0))  S RORPARM("LOG")=1  Q 0
"RTN","RORLOG01",22,0)
 ;--- Process the list of log parameters
"RTN","RORLOG01",23,0)
 S IR="",RC=0
"RTN","RORLOG01",24,0)
 F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D  Q:RC
"RTN","RORLOG01",25,0)
 . ;--- Check if the log is enabled
"RTN","RORLOG01",26,0)
 . Q:'$G(RORBUF("DILIST","ID",IR,8))
"RTN","RORLOG01",27,0)
 . S ENABLE=1
"RTN","RORLOG01",28,0)
 . ;--- Load a list of event types to log
"RTN","RORLOG01",29,0)
 . S IRS=","_RORBUF("DILIST",2,IR)_","  K RORSB
"RTN","RORLOG01",30,0)
 . D LIST^DIC(798.11,IRS,"@;.01I","U","*",,,"B",,,"RORSB","RORMSG")
"RTN","RORLOG01",31,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"PARAMS^RORLOG01")  Q:RC<0
"RTN","RORLOG01",32,0)
 . ;--- If there are no event types, log all events
"RTN","RORLOG01",33,0)
 . I '$G(RORSB("DILIST",0))  D  Q
"RTN","RORLOG01",34,0)
 . . K RORPARM("LOG")  S RC=1
"RTN","RORLOG01",35,0)
 . ;--- Process the list of event types
"RTN","RORLOG01",36,0)
 . S IRS=""
"RTN","RORLOG01",37,0)
 . F  S IRS=$O(RORSB("DILIST","ID",IRS))  Q:IRS=""  D
"RTN","RORLOG01",38,0)
 . . S TYPE=+$G(RORSB("DILIST","ID",IRS,.01))
"RTN","RORLOG01",39,0)
 . . S:TYPE RORPARM("LOG",TYPE)=1
"RTN","RORLOG01",40,0)
 S:$G(ENABLE) RORPARM("LOG")=1
"RTN","RORLOG01",41,0)
 ;--- If not all types of errors are recorded,
"RTN","RORLOG01",42,0)
 ;    enable recording of the type "Error"
"RTN","RORLOG01",43,0)
 S:$D(RORPARM("LOG"))>1 RORPARM("LOG",6)=1
"RTN","RORLOG01",44,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORNTEG")
0^5^B7630417
"RTN","RORNTEG",1,0)
RORNTEG ;ISC/XTSUMBLD KERNEL - Package checksum checker ; 1/21/03 11:43am
"RTN","RORNTEG",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORNTEG",3,0)
 ;;7.3;3021220.14193
"RTN","RORNTEG",4,0)
 S XT4="I 1",X=$T(+3) W !!,"Checksum routine created on ",$P(X,";",4)," by KERNEL V",$P(X,";",3),!
"RTN","RORNTEG",5,0)
CONT F XT1=1:1 S XT2=$T(ROU+XT1) Q:XT2=""  S X=$P(XT2," ",1),XT3=$P(XT2,";",3) X XT4 I $T W !,X X ^%ZOSF("TEST") S:'$T XT3=0 X:XT3 ^%ZOSF("RSUM") W ?10,$S('XT3:"Routine not in UCI",XT3'=Y:"Calculated "_$C(7)_Y_", off by "_(Y-XT3),1:"ok")
"RTN","RORNTEG",6,0)
 ;
"RTN","RORNTEG",7,0)
 K %1,%2,%3,X,Y,XT1,XT2,XT3,XT4 Q
"RTN","RORNTEG",8,0)
ONE S XT4="I $D(^UTILITY($J,X))",X=$T(+3) W !!,"Checksum routine created on ",$P(X,";",4)," by KERNEL V",$P(X,";",3),!
"RTN","RORNTEG",9,0)
 W !,"Check a subset of routines:" K ^UTILITY($J) X ^%ZOSF("RSEL")
"RTN","RORNTEG",10,0)
 W ! G CONT
"RTN","RORNTEG",11,0)
ROU ;;
"RTN","RORNTEG",12,0)
ROR ;;2867817
"RTN","RORNTEG",13,0)
ROR01 ;;1117
"RTN","RORNTEG",14,0)
RORACK ;;3777678
"RTN","RORNTEG",15,0)
RORACK01 ;;6012225
"RTN","RORNTEG",16,0)
RORAPI01 ;;2330240
"RTN","RORNTEG",17,0)
RORDD ;;3338213
"RTN","RORNTEG",18,0)
RORERR ;;3643026
"RTN","RORNTEG",19,0)
RORERR10 ;;17293115
"RTN","RORNTEG",20,0)
RORERR20 ;;11537436
"RTN","RORNTEG",21,0)
ROREVT01 ;;1432188
"RTN","RORNTEG",22,0)
ROREXPR ;;2842752
"RTN","RORNTEG",23,0)
ROREXT ;;3425862
"RTN","RORNTEG",24,0)
ROREXT01 ;;3458673
"RTN","RORNTEG",25,0)
ROREXT02 ;;5473418
"RTN","RORNTEG",26,0)
ROREXTUT ;;4083073
"RTN","RORNTEG",27,0)
RORHDT ;;3515691
"RTN","RORNTEG",28,0)
RORHDT01 ;;2568846
"RTN","RORNTEG",29,0)
RORHDT02 ;;1419145
"RTN","RORNTEG",30,0)
RORHDT03 ;;4467017
"RTN","RORNTEG",31,0)
RORHDT04 ;;8356244
"RTN","RORNTEG",32,0)
RORHDT05 ;;3192213
"RTN","RORNTEG",33,0)
RORHDTAC ;;3457583
"RTN","RORNTEG",34,0)
RORHDTUT ;;5260009
"RTN","RORNTEG",35,0)
RORHL01 ;;3306142
"RTN","RORNTEG",36,0)
RORHL02 ;;7855453
"RTN","RORNTEG",37,0)
RORHL03 ;;9723450
"RTN","RORNTEG",38,0)
RORHL04 ;;3889494
"RTN","RORNTEG",39,0)
RORHL05 ;;2472330
"RTN","RORNTEG",40,0)
RORHL06 ;;5392256
"RTN","RORNTEG",41,0)
RORHL07 ;;3672391
"RTN","RORNTEG",42,0)
RORHL7 ;;4726634
"RTN","RORNTEG",43,0)
RORKIDS ;;4837991
"RTN","RORNTEG",44,0)
RORLOG ;;5650708
"RTN","RORNTEG",45,0)
RORLOG01 ;;1593285
"RTN","RORNTEG",46,0)
RORP003 ;;6424519
"RTN","RORNTEG",47,0)
RORPUT01 ;;5750576
"RTN","RORNTEG",48,0)
RORRP1 ;;2796927
"RTN","RORNTEG",49,0)
RORRP10 ;;476541
"RTN","RORNTEG",50,0)
RORRP2 ;;4565833
"RTN","RORNTEG",51,0)
RORRP3 ;;3482249
"RTN","RORNTEG",52,0)
RORRP4 ;;5197581
"RTN","RORNTEG",53,0)
RORRP5 ;;1933187
"RTN","RORNTEG",54,0)
RORRP6 ;;3979336
"RTN","RORNTEG",55,0)
RORRP7 ;;4925487
"RTN","RORNTEG",56,0)
RORRP8 ;;3614530
"RTN","RORNTEG",57,0)
RORRP9 ;;7962639
"RTN","RORNTEG",58,0)
RORSET01 ;;4114786
"RTN","RORNTEG",59,0)
RORSETU1 ;;4862121
"RTN","RORNTEG",60,0)
RORSETU2 ;;3422125
"RTN","RORNTEG",61,0)
RORTSITE ;;4570058
"RTN","RORNTEG",62,0)
RORTXT ;;141117
"RTN","RORNTEG",63,0)
RORUPD ;;3639699
"RTN","RORNTEG",64,0)
RORUPD01 ;;8330275
"RTN","RORNTEG",65,0)
RORUPD04 ;;4980025
"RTN","RORNTEG",66,0)
RORUPD05 ;;7604750
"RTN","RORNTEG",67,0)
RORUPD06 ;;3026476
"RTN","RORNTEG",68,0)
RORUPD07 ;;2080523
"RTN","RORNTEG",69,0)
RORUPD08 ;;3974187
"RTN","RORNTEG",70,0)
RORUPD09 ;;2605824
"RTN","RORNTEG",71,0)
RORUPD50 ;;3644334
"RTN","RORNTEG",72,0)
RORUPD51 ;;6856241
"RTN","RORNTEG",73,0)
RORUPD52 ;;2548867
"RTN","RORNTEG",74,0)
RORUPDUT ;;7306215
"RTN","RORNTEG",75,0)
RORUPEX ;;3446189
"RTN","RORNTEG",76,0)
RORUPP01 ;;3975391
"RTN","RORNTEG",77,0)
RORUPP02 ;;2478392
"RTN","RORNTEG",78,0)
RORUPR ;;5856761
"RTN","RORNTEG",79,0)
RORUPR1 ;;11409300
"RTN","RORNTEG",80,0)
RORUTL01 ;;6303246
"RTN","RORNTEG",81,0)
RORUTL02 ;;5690818
"RTN","RORNTEG",82,0)
RORUTL03 ;;7598103
"RTN","RORNTEG",83,0)
RORUTL04 ;;2076790
"RTN","RORNTEG",84,0)
RORUTL05 ;;8216179
"RTN","RORNTEG",85,0)
RORUTL06 ;;7468553
"RTN","RORNTEG",86,0)
RORUTL07 ;;2738279
"RTN","RORP003")
0^20^B27841401
"RTN","RORP003",1,0)
RORP003 ;HCIOFO/SG - PATCH INSTALL ROUTINE (ROR*1.0*3) ; 1/15/03 9:27am
"RTN","RORP003",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORP003",3,0)
 ;
"RTN","RORP003",4,0)
 ;***** ENVIRONMENT CHECK
"RTN","RORP003",5,0)
 Q:'$G(XPDENV)
"RTN","RORP003",6,0)
 ;--- Check the scheduled option
"RTN","RORP003",7,0)
 Q:$$CHKOPT^RORKIDS("ROR TASK")<0
"RTN","RORP003",8,0)
 ;--- Do not delete old patch routines in the development account
"RTN","RORP003",9,0)
 I $G(^XMB("NETNAME"))["FO-HINES.MED.VA.GOV"  D
"RTN","RORP003",10,0)
 . N RTN,TMP
"RTN","RORP003",11,0)
 . F RTN="ENV01","ENV02","PRE01","POS01","POS02","POS03"  D
"RTN","RORP003",12,0)
 . . S TMP=$$RTNUP^XPDUTL("ROR"_RTN,2)
"RTN","RORP003",13,0)
 Q
"RTN","RORP003",14,0)
 ;
"RTN","RORP003",15,0)
 ;***** CONVERTS THE 'ROR PATIENT' FILE (#798.4) DATA
"RTN","RORP003",16,0)
 ;
"RTN","RORP003",17,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORP003",18,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORP003",19,0)
 ;
"RTN","RORP003",20,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORP003",21,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORP003",22,0)
 ; sub-nodes of the same name.
"RTN","RORP003",23,0)
 ;
"RTN","RORP003",24,0)
 ; Return Values:
"RTN","RORP003",25,0)
 ;       <0  Error code
"RTN","RORP003",26,0)
 ;        0  Ok
"RTN","RORP003",27,0)
 ;
"RTN","RORP003",28,0)
CNVFILE(RORREG) ;
"RTN","RORP003",29,0)
 N COUNTER,ERRCNT,IENS,PATIEN,RC,RORBUF,RORFDA,RORMSG,TMP,XPDIDTOT
"RTN","RORP003",30,0)
 D BMES^RORKIDS("Converting the ROR PATIENT file (#798.4) data...")
"RTN","RORP003",31,0)
 ;--- Get the registry
"RTN","RORP003",32,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORP003",33,0)
 ;--- Initialize the progress bar
"RTN","RORP003",34,0)
 S XPDIDTOT=$$GET1^DID(798.4,,,"ENTRIES",,"RORMSG")
"RTN","RORP003",35,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"CNVFILE^RORP003",,798.4)
"RTN","RORP003",36,0)
 D UPDATE^XPDID(0)
"RTN","RORP003",37,0)
 ;--- Convert the data
"RTN","RORP003",38,0)
 S (COUNTER,ERRCNT,PATIEN,RC)=0
"RTN","RORP003",39,0)
 F  S PATIEN=$O(^RORDATA(798.4,PATIEN))  Q:PATIEN'>0  D  Q:RC<0
"RTN","RORP003",40,0)
 . S IENS=PATIEN_",",COUNTER=COUNTER+1
"RTN","RORP003",41,0)
 . D:'(COUNTER#10) UPDATE^XPDID(COUNTER)
"RTN","RORP003",42,0)
 . ;--- Quit if the record has been converted already
"RTN","RORP003",43,0)
 . Q:$D(^RORDATA(798.4,PATIEN,1))
"RTN","RORP003",44,0)
 . ;--- Get the old data from the 0-node
"RTN","RORP003",45,0)
 . S RORBUF=$G(^RORDATA(798.4,PATIEN,0))  Q:RORBUF=""
"RTN","RORP003",46,0)
 . ;--- Delete the RATED DISABILITIES multiple (.3721)
"RTN","RORP003",47,0)
 . K ^RORDATA(798.4,PATIEN,.372)
"RTN","RORP003",48,0)
 . ;--- Prepare the new data
"RTN","RORP003",49,0)
 . S RC=$$PATDATA^RORUPD52(IENS,.RORFDA,IENS)  Q:RC<0
"RTN","RORP003",50,0)
 . ;--- Ensure that all "^" separators will be in place
"RTN","RORP003",51,0)
 . S:'$D(RORFDA(798.4,IENS,991)) RORFDA(798.4,IENS,991)="@"
"RTN","RORP003",52,0)
 . ;--- Restore the old SSN and ICN values
"RTN","RORP003",53,0)
 . S RORFDA(798.4,IENS,10.1)=$P(RORBUF,U,12)
"RTN","RORP003",54,0)
 . S RORFDA(798.4,IENS,10.2)=$P(RORBUF,U,13)
"RTN","RORP003",55,0)
 . ;--- Update the record
"RTN","RORP003",56,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORP003",57,0)
 . I $G(DIERR)  D  S ERRCNT=ERRCNT+1  Q
"RTN","RORP003",58,0)
 . . S TMP=$$DBS^RORERR("RORMSG",-9,"CNVFILE^RORP003",IEN,798.4,IENS)
"RTN","RORP003",59,0)
 . ;--- Delete all fields from the 0-node except the .01
"RTN","RORP003",60,0)
 . S ^RORDATA(798.4,PATIEN,0)=$P(RORBUF,U)
"RTN","RORP003",61,0)
 ;--- Reset the progress bar and check for errors
"RTN","RORP003",62,0)
 S XPDIDTOT=0  D UPDATE^XPDID(0)
"RTN","RORP003",63,0)
 Q:RC<0 RC  Q:ERRCNT -43
"RTN","RORP003",64,0)
 ;--- Success
"RTN","RORP003",65,0)
 D MES^RORKIDS("The data has been converted successfully.")
"RTN","RORP003",66,0)
 Q 0
"RTN","RORP003",67,0)
 ;
"RTN","RORP003",68,0)
 ;***** DELETES THE DD OF THE 'ROR PATIENT' FILE (#798.4)
"RTN","RORP003",69,0)
 ;
"RTN","RORP003",70,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORP003",71,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORP003",72,0)
 ;
"RTN","RORP003",73,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORP003",74,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORP003",75,0)
 ; sub-nodes of the same name.
"RTN","RORP003",76,0)
 ;
"RTN","RORP003",77,0)
 ; Return Values:
"RTN","RORP003",78,0)
 ;       <0  Error code
"RTN","RORP003",79,0)
 ;        0  Ok
"RTN","RORP003",80,0)
 ;
"RTN","RORP003",81,0)
DELDD(RORREG) ;
"RTN","RORP003",82,0)
 N TMP
"RTN","RORP003",83,0)
 D BMES^RORKIDS("Deleting the DD of the ROR PATIENT file (#798.4)...")
"RTN","RORP003",84,0)
 ;--- Get the registry
"RTN","RORP003",85,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORP003",86,0)
 ;--- Delete the data dictionary
"RTN","RORP003",87,0)
 S TMP=$$DELFILE^RORKIDS(798.4,"",1)
"RTN","RORP003",88,0)
 ;--- Success
"RTN","RORP003",89,0)
 D MES^RORKIDS("The data dictionary has been deleted successfully.")
"RTN","RORP003",90,0)
 Q 0
"RTN","RORP003",91,0)
 ;
"RTN","RORP003",92,0)
 ;***** ERROR PROCESSING
"RTN","RORP003",93,0)
ERROR ;
"RTN","RORP003",94,0)
 N TMP  S XPDABORT=1
"RTN","RORP003",95,0)
 I $D(ZTQUEUED)  D  D ALERT^RORKIDS(DUZ,-43,REGNAME,,TMP)
"RTN","RORP003",96,0)
 . S TMP=+$G(RORPARM("KIDS"))
"RTN","RORP003",97,0)
 . S TMP=$S(TMP=1:"pre-",TMP=2:"post-",1:"")_"install"
"RTN","RORP003",98,0)
 D DSPSTK^RORERR(),ABTMSG^RORKIDS()
"RTN","RORP003",99,0)
 Q
"RTN","RORP003",100,0)
 ;
"RTN","RORP003",101,0)
 ;***** POST-INSTALL
"RTN","RORP003",102,0)
POS ;
"RTN","RORP003",103,0)
 N RORERROR      ; Error processing data
"RTN","RORP003",104,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORP003",105,0)
 N RORPARM       ; Application parameters
"RTN","RORP003",106,0)
 ;
"RTN","RORP003",107,0)
 N RC,REGIEN,REGNAME,TMP
"RTN","RORP003",108,0)
 S RORPARM("DEVELOPER")=1   ; Enable modifications
"RTN","RORP003",109,0)
 S RORPARM("ERR")=1         ; Enable error processing
"RTN","RORP003",110,0)
 S RORPARM("KIDS")=2        ; Post-install indicator
"RTN","RORP003",111,0)
 S RORPARM("LOG")=1         ; Enable error recording
"RTN","RORP003",112,0)
 ;
"RTN","RORP003",113,0)
 ;--- IEN and name of the registry
"RTN","RORP003",114,0)
 S REGNAME="VA HEPC"
"RTN","RORP003",115,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)  G:REGIEN<0 ERROR
"RTN","RORP003",116,0)
 S RORPARM("KIDS","RORREG")=REGIEN_U_REGNAME
"RTN","RORP003",117,0)
 ;
"RTN","RORP003",118,0)
 ;--- National Drug Codes to add
"RTN","RORP003",119,0)
 S RORPARM("KIDS","RORDRGAD")="000004008694,000004035009,000004035039"
"RTN","RORP003",120,0)
 ;
"RTN","RORP003",121,0)
 ;--- Create a fake entry in the access control x-ref to guarantee
"RTN","RORP003",122,0)
 ;--- access to the files (user does not have the ROR IRM key yet).
"RTN","RORP003",123,0)
 S ^ROR(798.1,"ACL",DUZ,REGIEN,999)=""
"RTN","RORP003",124,0)
 ;
"RTN","RORP003",125,0)
 ;--- Open a new log
"RTN","RORP003",126,0)
 S TMP=$$OPEN^RORLOG(REGNAME,0,XPDNM_" POST-INSTALL STARTED")
"RTN","RORP003",127,0)
 ;
"RTN","RORP003",128,0)
 ;--- Update the DRUG THERAPY LIST multiple
"RTN","RORP003",129,0)
 G:$$CP^RORKIDS("POS05","$$DRUGADD^RORPUT01")<0 ERROR
"RTN","RORP003",130,0)
 ;
"RTN","RORP003",131,0)
 ;--- Convert the ROR PATIENT file (#798.4) data
"RTN","RORP003",132,0)
 G:$$CP^RORKIDS("POS10","$$CNVFILE^RORP003")<0 ERROR
"RTN","RORP003",133,0)
 ;
"RTN","RORP003",134,0)
 ;--- Close the log
"RTN","RORP003",135,0)
 D CLOSE^RORLOG(XPDNM_" POST-INSTALL COMPLETED")
"RTN","RORP003",136,0)
 ;
"RTN","RORP003",137,0)
 ;--- Remove the fake entry from the access control x-ref
"RTN","RORP003",138,0)
 K ^ROR(798.1,"ACL",DUZ,REGIEN,999)
"RTN","RORP003",139,0)
 Q
"RTN","RORP003",140,0)
 ;
"RTN","RORP003",141,0)
 ;***** PRE-INSTALL
"RTN","RORP003",142,0)
PRE ;
"RTN","RORP003",143,0)
 N RORERROR      ; Error processing data
"RTN","RORP003",144,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORP003",145,0)
 N RORPARM       ; Application parameters
"RTN","RORP003",146,0)
 ;
"RTN","RORP003",147,0)
 N RC,REGIEN,REGNAME,TMP
"RTN","RORP003",148,0)
 S RORPARM("DEVELOPER")=1   ; Enable modifications
"RTN","RORP003",149,0)
 S RORPARM("ERR")=1         ; Enable error processing
"RTN","RORP003",150,0)
 S RORPARM("KIDS")=1        ; Pre-install indicator
"RTN","RORP003",151,0)
 S RORPARM("LOG")=1         ; Enable error recording
"RTN","RORP003",152,0)
 ;
"RTN","RORP003",153,0)
 ;--- IEN and name of the registry
"RTN","RORP003",154,0)
 S REGNAME="VA HEPC"
"RTN","RORP003",155,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)  G:REGIEN<0 ERROR
"RTN","RORP003",156,0)
 S RORPARM("KIDS","RORREG")=REGIEN_U_REGNAME
"RTN","RORP003",157,0)
 ;
"RTN","RORP003",158,0)
 ;--- Open a new log
"RTN","RORP003",159,0)
 S TMP=$$OPEN^RORLOG(REGNAME,0,XPDNM_" PRE-INSTALL STARTED")
"RTN","RORP003",160,0)
 ;
"RTN","RORP003",161,0)
 ;--- Delete the DD of the ROR PATIENT file (#798.4)
"RTN","RORP003",162,0)
 G:$$CP^RORKIDS("PRE05","$$DELDD^RORP003")<0 ERROR
"RTN","RORP003",163,0)
 ;
"RTN","RORP003",164,0)
 ;--- Close the log
"RTN","RORP003",165,0)
 D CLOSE^RORLOG(XPDNM_" PRE-INSTALL COMPLETED")
"RTN","RORP003",166,0)
 Q
"RTN","RORPOS01")
1^17
"RTN","RORPOS02")
1^18
"RTN","RORPOS03")
1^19
"RTN","RORPOSU1")
1^33
"RTN","RORPRE01")
1^16
"RTN","RORPUT01")
0^32^B39223972
"RTN","RORPUT01",1,0)
RORPUT01 ;HCIOFO/SG - EDIT LOINC AND DRUG CODE MULTIPLES ; 12/11/02 8:35am
"RTN","RORPUT01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORPUT01",3,0)
 ;
"RTN","RORPUT01",4,0)
 Q
"RTN","RORPUT01",5,0)
 ;
"RTN","RORPUT01",6,0)
 ;***** ADDS THE RECORDS TO THE MULTIPLE
"RTN","RORPUT01",7,0)
 ;
"RTN","RORPUT01",8,0)
 ; REGIEN        Registry IEN
"RTN","RORPUT01",9,0)
 ; SUBFILE       Subfile number
"RTN","RORPUT01",10,0)
 ; LSTREF        Reference to a list or the list itself (see the
"RTN","RORPUT01",11,0)
 ;               $$COMPNEXT^RORPUT01 function for more details).
"RTN","RORPUT01",12,0)
 ;
"RTN","RORPUT01",13,0)
 ; Return Values:
"RTN","RORPUT01",14,0)
 ;       <0  Error code
"RTN","RORPUT01",15,0)
 ;        0  Ok
"RTN","RORPUT01",16,0)
 ;
"RTN","RORPUT01",17,0)
ADD(REGIEN,SUBFILE,LSTREF) ;
"RTN","RORPUT01",18,0)
 N BUF,IENS,ITEM,LI,NEXT,RC,RORFDA,RORMSG,TLI
"RTN","RORPUT01",19,0)
 S NEXT=$$COMPNEXT(LSTREF)  Q:NEXT<0 NEXT
"RTN","RORPUT01",20,0)
 S IENS="?+1,"_(+REGIEN)_",",RC=0
"RTN","RORPUT01",21,0)
 F TLI=1:1  X NEXT  Q:$G(BUF)'[";;"  D  Q:RC<0
"RTN","RORPUT01",22,0)
 . S BUF=$P(BUF,";;",2)
"RTN","RORPUT01",23,0)
 . D MES^RORKIDS(BUF)
"RTN","RORPUT01",24,0)
 . S BUF=$TR(BUF," ")
"RTN","RORPUT01",25,0)
 . F LI=1:1  S ITEM=$P(BUF,",",LI)  Q:ITEM=""  D  Q:RC<0
"RTN","RORPUT01",26,0)
 . . S RORFDA(SUBFILE,IENS,.01)=ITEM
"RTN","RORPUT01",27,0)
 . . D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORPUT01",28,0)
 . . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,SUBFILE,IENS)
"RTN","RORPUT01",29,0)
 Q RC
"RTN","RORPUT01",30,0)
 ;
"RTN","RORPUT01",31,0)
 ;***** COMPILES THE 'NEXT' LOGIC
"RTN","RORPUT01",32,0)
 ;
"RTN","RORPUT01",33,0)
 ; PARAM         Parameter defining the list of codes. It should be
"RTN","RORPUT01",34,0)
 ;               either a list of codes separated by commas or a full
"RTN","RORPUT01",35,0)
 ;               reference (TAG^ROUTINE) to a routine label after
"RTN","RORPUT01",36,0)
 ;               which the list is located. In the latter case, the
"RTN","RORPUT01",37,0)
 ;               list itself should look like this:
"RTN","RORPUT01",38,0)
 ;
"RTN","RORPUT01",39,0)
 ;                         ;
"RTN","RORPUT01",40,0)
 ;                         ;***** SHORT DESCRIPTION OF THE LIST
"RTN","RORPUT01",41,0)
 ;                 LABEL   ;
"RTN","RORPUT01",42,0)
 ;                         ;;  Code1, Code2, ...
"RTN","RORPUT01",43,0)
 ;                         ;;  CodeN, ...
"RTN","RORPUT01",44,0)
 ;                         ;
"RTN","RORPUT01",45,0)
 ;
"RTN","RORPUT01",46,0)
 ;               There should be at least one line that does not
"RTN","RORPUT01",47,0)
 ;               contain ";;" after the list (or no lines at all).
"RTN","RORPUT01",48,0)
 ;
"RTN","RORPUT01",49,0)
 ; Return Values:
"RTN","RORPUT01",50,0)
 ;       <0  Error code
"RTN","RORPUT01",51,0)
 ;       ""  The list is empty
"RTN","RORPUT01",52,0)
 ;     '=""  A string that should be XECUTE'd to get the next
"RTN","RORPUT01",53,0)
 ;           buffer with the list data
"RTN","RORPUT01",54,0)
 ;
"RTN","RORPUT01",55,0)
COMPNEXT(PARAM) ;
"RTN","RORPUT01",56,0)
 N I,N,NEXT,RC  Q:PARAM?." " ""
"RTN","RORPUT01",57,0)
 ;--- Reference to a routine label
"RTN","RORPUT01",58,0)
 I PARAM?1.8UN1"^"1.8UN  D  Q NEXT
"RTN","RORPUT01",59,0)
 . S NEXT="S BUF=$T("_$P(PARAM,U)_"+TLI"_U_$P(PARAM,U,2)_")"
"RTN","RORPUT01",60,0)
 ;--- List of codes separated by commas
"RTN","RORPUT01",61,0)
 S N=$L(PARAM,","),RC=0
"RTN","RORPUT01",62,0)
 F I=1:1:N  I '($P(PARAM,",",I)?." "1.N." ")  S RC=-88  Q
"RTN","RORPUT01",63,0)
 I RC<0,I=N  S:$P(PARAM,",",N)?." " RC=0,N=N-1
"RTN","RORPUT01",64,0)
 I N>0,RC'<0  D  Q NEXT
"RTN","RORPUT01",65,0)
 . S NEXT="S BUF=$P("""_";;"_$P(PARAM,",",1,N)_""",U,TLI)"
"RTN","RORPUT01",66,0)
 ;--- Invalid parameter
"RTN","RORPUT01",67,0)
 Q $$ERROR^RORERR(-88,,,,"List of Codes",PARAM)
"RTN","RORPUT01",68,0)
 ;
"RTN","RORPUT01",69,0)
 ;***** ADDS ITEMS TO 'DRUG THERAPY LIST' MULTIPLE OF FILE #798.1
"RTN","RORPUT01",70,0)
 ;
"RTN","RORPUT01",71,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPUT01",72,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPUT01",73,0)
 ;
"RTN","RORPUT01",74,0)
 ; [RORDRGAD]    Either a list of National Drug Codes separated by
"RTN","RORPUT01",75,0)
 ;               commas or a full reference (TAG^ROUTINE) to a
"RTN","RORPUT01",76,0)
 ;               routine label after which the list is located.
"RTN","RORPUT01",77,0)
 ;
"RTN","RORPUT01",78,0)
 ;               All spaces are removed from the lines of the list.
"RTN","RORPUT01",79,0)
 ;               See the $$COMPNEXT^RORPUT01 function for more
"RTN","RORPUT01",80,0)
 ;               details.
"RTN","RORPUT01",81,0)
 ;
"RTN","RORPUT01",82,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPUT01",83,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPUT01",84,0)
 ; sub-nodes of the same name.
"RTN","RORPUT01",85,0)
 ;
"RTN","RORPUT01",86,0)
 ; Return Values:
"RTN","RORPUT01",87,0)
 ;       <0  Error code
"RTN","RORPUT01",88,0)
 ;        0  Ok
"RTN","RORPUT01",89,0)
 ;
"RTN","RORPUT01",90,0)
DRUGADD(RORREG,RORDRGAD) ;
"RTN","RORPUT01",91,0)
 N RC,RORERRDL
"RTN","RORPUT01",92,0)
 D BMES^RORKIDS("Adding new items to the drug list...")
"RTN","RORPUT01",93,0)
 D DFLTLOC^RORERR("DRUGADD^RORPUT01")
"RTN","RORPUT01",94,0)
 ;--- Get the parameters
"RTN","RORPUT01",95,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPUT01",96,0)
 S:$G(RORDRGAD)="" RORDRGAD=$$PARAM^RORKIDS("RORDRGAD")
"RTN","RORPUT01",97,0)
 ;--- Update the multiple
"RTN","RORPUT01",98,0)
 S RC=$$ADD(+RORREG,798.117,RORDRGAD)  Q:RC<0 RC
"RTN","RORPUT01",99,0)
 ;--- Success
"RTN","RORPUT01",100,0)
 D MES^RORKIDS("The drug list has been updated successfully.")
"RTN","RORPUT01",101,0)
 Q 0
"RTN","RORPUT01",102,0)
 ;
"RTN","RORPUT01",103,0)
 ;***** REMOVES ITEMS FROM 'DRUG THERAPY LIST' MULTIPLE OF FILE #798.1
"RTN","RORPUT01",104,0)
 ;
"RTN","RORPUT01",105,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPUT01",106,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPUT01",107,0)
 ;
"RTN","RORPUT01",108,0)
 ; [RORDRGAD]    Either a list of National Drug Codes separated by
"RTN","RORPUT01",109,0)
 ;               commas or a full reference (TAG^ROUTINE) to a
"RTN","RORPUT01",110,0)
 ;               routine label after which the list is located.
"RTN","RORPUT01",111,0)
 ;
"RTN","RORPUT01",112,0)
 ;               All spaces are removed from the lines of the list.
"RTN","RORPUT01",113,0)
 ;               See the $$COMPNEXT^RORPUT01 function for more
"RTN","RORPUT01",114,0)
 ;               details.
"RTN","RORPUT01",115,0)
 ;
"RTN","RORPUT01",116,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPUT01",117,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPUT01",118,0)
 ; sub-nodes of the same name.
"RTN","RORPUT01",119,0)
 ;
"RTN","RORPUT01",120,0)
 ; Return Values:
"RTN","RORPUT01",121,0)
 ;       <0  Error code
"RTN","RORPUT01",122,0)
 ;        0  Ok
"RTN","RORPUT01",123,0)
 ;
"RTN","RORPUT01",124,0)
DRUGREM(RORREG,RORDRGRM) ;
"RTN","RORPUT01",125,0)
 N RC,RORERRDL
"RTN","RORPUT01",126,0)
 D BMES^RORKIDS("Removing obsolete items from the drug list...")
"RTN","RORPUT01",127,0)
 D DFLTLOC^RORERR("DRUGADD^RORPUT01")
"RTN","RORPUT01",128,0)
 ;--- Get the parameters
"RTN","RORPUT01",129,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPUT01",130,0)
 S:$G(RORDRGRM)="" RORDRGRM=$$PARAM^RORKIDS("RORDRGRM")
"RTN","RORPUT01",131,0)
 ;--- Update the multiple
"RTN","RORPUT01",132,0)
 S RC=$$REMOVE(+RORREG,798.117,RORDRGRM)  Q:RC<0 RC
"RTN","RORPUT01",133,0)
 ;--- Success
"RTN","RORPUT01",134,0)
 D MES^RORKIDS("The drug list has been updated successfully.")
"RTN","RORPUT01",135,0)
 Q 0
"RTN","RORPUT01",136,0)
 ;
"RTN","RORPUT01",137,0)
 ;***** ADDS ITEMS TO 'EXTRACTED RESULT' MULTIPLE OF FILE #798.1
"RTN","RORPUT01",138,0)
 ;
"RTN","RORPUT01",139,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPUT01",140,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPUT01",141,0)
 ;
"RTN","RORPUT01",142,0)
 ; [RORLNCAD]    Either a list of LOINC codes (without check digits)
"RTN","RORPUT01",143,0)
 ;               separated by commas or a full reference (TAG^ROUTINE)
"RTN","RORPUT01",144,0)
 ;               to a routine label after which the list is located.
"RTN","RORPUT01",145,0)
 ;
"RTN","RORPUT01",146,0)
 ;               All spaces are removed from the lines of the list.
"RTN","RORPUT01",147,0)
 ;               See the $$COMPNEXT^RORPUT01 function for more
"RTN","RORPUT01",148,0)
 ;               details.
"RTN","RORPUT01",149,0)
 ;
"RTN","RORPUT01",150,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPUT01",151,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPUT01",152,0)
 ; sub-nodes of the same name.
"RTN","RORPUT01",153,0)
 ;
"RTN","RORPUT01",154,0)
 ; Return Values:
"RTN","RORPUT01",155,0)
 ;       <0  Error code
"RTN","RORPUT01",156,0)
 ;        0  Ok
"RTN","RORPUT01",157,0)
 ;
"RTN","RORPUT01",158,0)
LOINCADD(RORREG,RORLNCAD) ;
"RTN","RORPUT01",159,0)
 N RC,RORERRDL
"RTN","RORPUT01",160,0)
 D BMES^RORKIDS("Adding new LOINC codes to the EXTRACTED RESULT multiple...")
"RTN","RORPUT01",161,0)
 D DFLTLOC^RORERR("LOINCADD^RORPUT01")
"RTN","RORPUT01",162,0)
 ;--- Get the parameters
"RTN","RORPUT01",163,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPUT01",164,0)
 S:$G(RORLNCAD)="" RORLNCAD=$$PARAM^RORKIDS("RORLNCAD")
"RTN","RORPUT01",165,0)
 ;--- Add new LOINC codes
"RTN","RORPUT01",166,0)
 S RC=$$ADD(+RORREG,798.112,RORLNCAD)  Q:RC<0 RC
"RTN","RORPUT01",167,0)
 ;--- Success
"RTN","RORPUT01",168,0)
 D MES^RORKIDS("The LOINC list has been updated successfully.")
"RTN","RORPUT01",169,0)
 Q 0
"RTN","RORPUT01",170,0)
 ;
"RTN","RORPUT01",171,0)
 ;***** REMOVES ITEMS FROM 'EXTRACTED RESULT' MULTIPLE OF FILE #798.1
"RTN","RORPUT01",172,0)
 ;
"RTN","RORPUT01",173,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPUT01",174,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPUT01",175,0)
 ;
"RTN","RORPUT01",176,0)
 ; [RORLNCRM]    Either a list of LOINC codes (without check digits)
"RTN","RORPUT01",177,0)
 ;               separated by commas or a full reference (TAG^ROUTINE)
"RTN","RORPUT01",178,0)
 ;               to a routine label after which the list is located.
"RTN","RORPUT01",179,0)
 ;
"RTN","RORPUT01",180,0)
 ;               All spaces are removed from the lines of the list.
"RTN","RORPUT01",181,0)
 ;               See the $$COMPNEXT^RORPUT01 function for more
"RTN","RORPUT01",182,0)
 ;               details.
"RTN","RORPUT01",183,0)
 ;
"RTN","RORPUT01",184,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPUT01",185,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPUT01",186,0)
 ; sub-nodes of the same name.
"RTN","RORPUT01",187,0)
 ;
"RTN","RORPUT01",188,0)
 ; Return Values:
"RTN","RORPUT01",189,0)
 ;       <0  Error code
"RTN","RORPUT01",190,0)
 ;        0  Ok
"RTN","RORPUT01",191,0)
 ;
"RTN","RORPUT01",192,0)
LOINCREM(RORREG,RORLNCRM) ;
"RTN","RORPUT01",193,0)
 N BUF,DA,DIK,IENS,IR,LCI,LOINC,NEXT,RC,RORBUF,RORERRDL,RORMSG,TLI
"RTN","RORPUT01",194,0)
 D BMES^RORKIDS("Removing obsolete codes from the EXTRACTED RESULT multiple...")
"RTN","RORPUT01",195,0)
 D DFLTLOC^RORERR("LOINCREM^RORPUT01")
"RTN","RORPUT01",196,0)
 ;--- Get the parameters
"RTN","RORPUT01",197,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPUT01",198,0)
 S:$G(RORLNCRM)="" RORLNCRM=$$PARAM^RORKIDS("RORLNCRM")
"RTN","RORPUT01",199,0)
 ;--- Delete unnecessary LOINC codes
"RTN","RORPUT01",200,0)
 S RC=$$REMOVE(+RORREG,798.112,RORLNCRM)  Q:RC<0 RC
"RTN","RORPUT01",201,0)
 ;--- Success
"RTN","RORPUT01",202,0)
 D MES^RORKIDS("The LOINC list has been updated successfully.")
"RTN","RORPUT01",203,0)
 Q 0
"RTN","RORPUT01",204,0)
 ;
"RTN","RORPUT01",205,0)
 ;***** REMOVES THE RECORDS FROM THE MULTIPLE
"RTN","RORPUT01",206,0)
 ;
"RTN","RORPUT01",207,0)
 ; REGIEN        Registry IEN
"RTN","RORPUT01",208,0)
 ; SUBFILE       Subfile number
"RTN","RORPUT01",209,0)
 ; LSTREF        Reference to a list or the list itself (see the
"RTN","RORPUT01",210,0)
 ;               $$COMPNEXT^RORPUT01 function for more details).
"RTN","RORPUT01",211,0)
 ;
"RTN","RORPUT01",212,0)
 ; Return Values:
"RTN","RORPUT01",213,0)
 ;       <0  Error code
"RTN","RORPUT01",214,0)
 ;        0  Ok
"RTN","RORPUT01",215,0)
 ;
"RTN","RORPUT01",216,0)
REMOVE(REGIEN,SUBFILE,LSTREF) ;
"RTN","RORPUT01",217,0)
 N BUF,DA,DIK,IENS,IR,ITEM,LI,NEXT,RC,RORBUF,RORMSG,TLI
"RTN","RORPUT01",218,0)
 S NEXT=$$COMPNEXT(LSTREF)  Q:NEXT<0 NEXT
"RTN","RORPUT01",219,0)
 S IENS=","_(+REGIEN)_",",RC=0
"RTN","RORPUT01",220,0)
 F TLI=1:1  X NEXT  Q:$G(BUF)'[";;"  D  Q:RC<0
"RTN","RORPUT01",221,0)
 . S BUF=$P(BUF,";;",2)
"RTN","RORPUT01",222,0)
 . D MES^RORKIDS(BUF)
"RTN","RORPUT01",223,0)
 . S BUF=$TR(BUF," ")
"RTN","RORPUT01",224,0)
 . F LI=1:1  S ITEM=$P(BUF,",",LI)  Q:ITEM=""  D  Q:RC<0
"RTN","RORPUT01",225,0)
 . . D FIND^DIC(SUBFILE,IENS,"@","QX",ITEM,,"B",,,"RORBUF","RORMSG")
"RTN","RORPUT01",226,0)
 . . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,SUBFILE,IENS)  Q
"RTN","RORPUT01",227,0)
 . . S IR="",DIK=$$ROOT^DILFD(SUBFILE,IENS),DA(1)=+REGIEN
"RTN","RORPUT01",228,0)
 . . F  S IR=$O(RORBUF("DILIST",2,IR))  Q:IR=""  D
"RTN","RORPUT01",229,0)
 . . . S DA=RORBUF("DILIST",2,IR)  D ^DIK
"RTN","RORPUT01",230,0)
 Q RC
"RTN","RORPUT01",231,0)
 ;
"RTN","RORPUT01",232,0)
 ;***** UPDATES (POPULATES) THE LOCAL REGISTRY
"RTN","RORPUT01",233,0)
 ;
"RTN","RORPUT01",234,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPUT01",235,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPUT01",236,0)
 ; [MAXNTSK]     Maximum number of registry update subtasks
"RTN","RORPUT01",237,0)
 ; [SUSPEND]     Suspend update (sub)tasks during the peak hours
"RTN","RORPUT01",238,0)
 ;               (StartTime^EndTime)
"RTN","RORPUT01",239,0)
 ;
"RTN","RORPUT01",240,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPUT01",241,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPUT01",242,0)
 ; sub-nodes of the same name.
"RTN","RORPUT01",243,0)
 ;
"RTN","RORPUT01",244,0)
 ; Return Values:
"RTN","RORPUT01",245,0)
 ;       <0  Error code
"RTN","RORPUT01",246,0)
 ;        0  Ok
"RTN","RORPUT01",247,0)
 ;
"RTN","RORPUT01",248,0)
UPDATE(RORREG,MAXNTSK,SUSPEND) ;
"RTN","RORPUT01",249,0)
 N EC,REGLST
"RTN","RORPUT01",250,0)
 D BMES^RORKIDS("Updating the local registry...")
"RTN","RORPUT01",251,0)
 ;--- Get the parameters
"RTN","RORPUT01",252,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPUT01",253,0)
 S:RORREG REGLST($P(RORREG,U,2))=+RORREG
"RTN","RORPUT01",254,0)
 S:$G(MAXNTSK)="" MAXNTSK=$$PARAM^RORKIDS("MAXNTSK")
"RTN","RORPUT01",255,0)
 S:$G(SUSPEND)="" SUSPEND=$$PARAM^RORKIDS("SUSPEND")
"RTN","RORPUT01",256,0)
 ;--- Update the registry
"RTN","RORPUT01",257,0)
 S RC=$$UPDATE^RORUPD(.REGLST,,MAXNTSK,SUSPEND)  Q:RC<0 RC
"RTN","RORPUT01",258,0)
 ;--- Success
"RTN","RORPUT01",259,0)
 D MES^RORKIDS("Registry update completed.")
"RTN","RORPUT01",260,0)
 Q 0
"RTN","RORRP4")
0^31^B20576033
"RTN","RORRP4",1,0)
RORRP4 ;HOIFO/BH - CLINICAL REGISTRIES - Remote Procedures - Report ; 11/1/02 12:45pm
"RTN","RORRP4",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORRP4",3,0)
 ;
"RTN","RORRP4",4,0)
GETDATA(RESULT,REGISTRY,START,END,MODE,SORTBY,FIELDS) ;
"RTN","RORRP4",5,0)
 ;
"RTN","RORRP4",6,0)
 ; Input: Registry - i.e. "VA HEPC"
"RTN","RORRP4",7,0)
 ;        Start    - Start date for report
"RTN","RORRP4",8,0)
 ;        End      - End date for report
"RTN","RORRP4",9,0)
 ;        Mode     - Either "I","A" or "B" (inactive, active or both)
"RTN","RORRP4",10,0)
 ;        Sortby   - Integer 0-7
"RTN","RORRP4",11,0)
 ;                   0-Name  1-DFN 2-ICN  
"RTN","RORRP4",12,0)
 ;                   3-DOB   4-Date Entered
"RTN","RORRP4",13,0)
 ;                   5-Date Inactivated  6-Date Re-Activated
"RTN","RORRP4",14,0)
 ;                   7-Investigational Drugs
"RTN","RORRP4",15,0)
 ;        Fields   - Delimited string conatining 9 pieces of boolean 
"RTN","RORRP4",16,0)
 ;                   data, these values indicate what fields are wanted
"RTN","RORRP4",17,0)
 ;                   on the user interface.
"RTN","RORRP4",18,0)
 ;                   P1=DFN  P2=ICN
"RTN","RORRP4",19,0)
 ;                   P3=DOB  P4=Date entered into registry 
"RTN","RORRP4",20,0)
 ;                   P5=Date Inactivated  P6=Reason Inactivated  
"RTN","RORRP4",21,0)
 ;                   P7=Date Reactivated  P8=Investigational Drugs
"RTN","RORRP4",22,0)
 ;                   P9=Reason Addes to Reg. 
"RTN","RORRP4",23,0)
 ;
"RTN","RORRP4",24,0)
 N LEN,DOB,DTE,STATUS,RULE,REG,SORT,RSNINACT
"RTN","RORRP4",25,0)
 S STR=".01;",DTE="",RULE=""
"RTN","RORRP4",26,0)
 ;
"RTN","RORRP4",27,0)
 S SORT=$S(SORTBY=1:"DFN",SORTBY=2:"ICN",SORTBY=3:"DOB",SORTBY=4:"ENTERED",SORTBY=5:"DATEIN",SORTBY=6:"DATERE",SORTBY=7:"DRUGS",1:"NAME")
"RTN","RORRP4",28,0)
 S RESULT=$NA(^TMP("ROR REPORT",$J))
"RTN","RORRP4",29,0)
 S REG=$$REG^RORRP1(REGISTRY)
"RTN","RORRP4",30,0)
 ; Make up string for GETS FM call.
"RTN","RORRP4",31,0)
 I $P(FIELDS,"^",4) S STR=STR_"1;"
"RTN","RORRP4",32,0)
 I $P(FIELDS,"^",5) S STR=STR_"2;"
"RTN","RORRP4",33,0)
 I $P(FIELDS,"^",6) S STR=STR_"2.2;"
"RTN","RORRP4",34,0)
 I $P(FIELDS,"^",7) S STR=STR_"7;"
"RTN","RORRP4",35,0)
 I $P(FIELDS,"^",8) S STR=STR_"6;"
"RTN","RORRP4",36,0)
 I $P(FIELDS,"^",9) S RULE=1
"RTN","RORRP4",37,0)
 S LEN=$L(STR) I $E(STR,LEN,LEN)=";" S STR=$E(STR,1,LEN-1)
"RTN","RORRP4",38,0)
 ;
"RTN","RORRP4",39,0)
 ; If start date specified -1 off to allow for $O.
"RTN","RORRP4",40,0)
 I START'="" S X1=START,X2="-1" D C^%DTC S DTE=X_".235959"
"RTN","RORRP4",41,0)
 ; If no End value set false 9999999 for Quit logic.
"RTN","RORRP4",42,0)
 I END="" S END=9999999
"RTN","RORRP4",43,0)
 S:$P(END,".",2)="" $P(END,".",2)=235959
"RTN","RORRP4",44,0)
 S CNT=0
"RTN","RORRP4",45,0)
 F  S DTE=$O(^RORDATA(798,"AD",DTE)) Q:DTE>END!('DTE)  D
"RTN","RORRP4",46,0)
 . S IEN=""
"RTN","RORRP4",47,0)
 . F  S IEN=$O(^RORDATA(798,"AD",DTE,IEN)) Q:'IEN  D
"RTN","RORRP4",48,0)
 . . S ACTIVE=$$GET1^DIQ(798,IEN,8)
"RTN","RORRP4",49,0)
 . . ; If called for Active patients and patient is inactive Quit.
"RTN","RORRP4",50,0)
 . . I MODE="A",'ACTIVE Q
"RTN","RORRP4",51,0)
 . . ; If called for Inactive patients and patient is Active Quit.
"RTN","RORRP4",52,0)
 . . I MODE="I",ACTIVE Q
"RTN","RORRP4",53,0)
 . . ;
"RTN","RORRP4",54,0)
 . . ; If entry is not for Hep Registry Quit.
"RTN","RORRP4",55,0)
 . . I $$GET1^DIQ(798,IEN,.02,"I")'=REG Q
"RTN","RORRP4",56,0)
 . . ;
"RTN","RORRP4",57,0)
 . . S DFN=$P(^RORDATA(798,IEN,0),U)
"RTN","RORRP4",58,0)
 . . S DOB=$P($G(^RORDATA(798.4,DFN,1)),U,2)
"RTN","RORRP4",59,0)
 . . S DOB=$$FORMAT(DOB)
"RTN","RORRP4",60,0)
 . . S SSN=$P($G(^RORDATA(798.4,DFN,1)),U),SSN=$E(SSN,6,9)
"RTN","RORRP4",61,0)
 . . S ICN=$$ICN^RORUTL02(DFN)
"RTN","RORRP4",62,0)
 . . S ICN=$P(ICN,"V",1)
"RTN","RORRP4",63,0)
 . . S:ICN<0 ICN=""
"RTN","RORRP4",64,0)
 . . ;
"RTN","RORRP4",65,0)
 . . N RORDATA
"RTN","RORRP4",66,0)
 . . D GETS^DIQ(798,IEN_",",STR,"IE","RORDATA")
"RTN","RORRP4",67,0)
 . . ;
"RTN","RORRP4",68,0)
 . . S NAME=RORDATA(798,IEN_",",.01,"E")
"RTN","RORRP4",69,0)
 . . S ENTERED=$P($G(RORDATA(798,IEN_",",1,"I")),".",1)
"RTN","RORRP4",70,0)
 . . I ENTERED'="" S ENTERED=$$FORMAT(ENTERED)
"RTN","RORRP4",71,0)
 . . S DATEIN=$P($G(RORDATA(798,IEN_",",2,"I")),".",1)
"RTN","RORRP4",72,0)
 . . I DATEIN'="" S DATEIN=$$FORMAT(DATEIN)
"RTN","RORRP4",73,0)
 . . S RSNINACT=$G(RORDATA(798,IEN_",",2.2,"E"))
"RTN","RORRP4",74,0)
 . . S DATERE=$P($G(RORDATA(798,IEN_",",7,"I")),".",1)
"RTN","RORRP4",75,0)
 . . I DATERE'="" S DATERE=$$FORMAT(DATERE)
"RTN","RORRP4",76,0)
 . . S DRUGS=$G(RORDATA(798,IEN_",",6,"E")) I DRUGS="" S DRUGS="NO"
"RTN","RORRP4",77,0)
 . . ;
"RTN","RORRP4",78,0)
 . . ; If sort value is undefined quit. 
"RTN","RORRP4",79,0)
 . . S CNT=CNT+1,K4=@SORT I K4="" Q
"RTN","RORRP4",80,0)
 . . S K4=$P(K4,"~",1)
"RTN","RORRP4",81,0)
 . . I SORTBY=3!(SORTBY=4) S K4=9999999-K4
"RTN","RORRP4",82,0)
 . . ;
"RTN","RORRP4",83,0)
 . . N REASON
"RTN","RORRP4",84,0)
 . . S REASON(1)=""
"RTN","RORRP4",85,0)
 . . I RULE D REASON(IEN)
"RTN","RORRP4",86,0)
 . . ;
"RTN","RORRP4",87,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",1)=NAME
"RTN","RORRP4",88,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",2)=SSN
"RTN","RORRP4",89,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",3)=DFN
"RTN","RORRP4",90,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",4)=ICN
"RTN","RORRP4",91,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",5)=$P(DOB,"~",2)
"RTN","RORRP4",92,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",6)=$P(ENTERED,"~",2)
"RTN","RORRP4",93,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",7)=$P(DATEIN,"~",2)
"RTN","RORRP4",94,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",8)=RSNINACT
"RTN","RORRP4",95,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",9)=$P(DATERE,"~",2)
"RTN","RORRP4",96,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",10)=DRUGS
"RTN","RORRP4",97,0)
 . . S $P(@RESULT@(K4,NAME,CNT),"^",11)=REASON(1) I 'RULE Q
"RTN","RORRP4",98,0)
 . . ;  If no more selection rules for patient Quit
"RTN","RORRP4",99,0)
 . . I $G(REASON(2))="" Q
"RTN","RORRP4",100,0)
 . . ;  Loop through all remaining rules and write to global
"RTN","RORRP4",101,0)
 . . N I S I=1
"RTN","RORRP4",102,0)
 . . F  S I=$O(REASON(I)) Q:'I  D
"RTN","RORRP4",103,0)
 . . . S CNT=CNT+1
"RTN","RORRP4",104,0)
 . . . S $P(@RESULT@(K4,NAME,CNT),"^",11)=REASON(I)
"RTN","RORRP4",105,0)
 . . Q
"RTN","RORRP4",106,0)
 K CNT
"RTN","RORRP4",107,0)
 Q
"RTN","RORRP4",108,0)
 ;
"RTN","RORRP4",109,0)
FORMAT(FDATE) ;  Concatinates passed in FM date with a formatted version of
"RTN","RORRP4",110,0)
 ;          itself.
"RTN","RORRP4",111,0)
 N M,D,Y,C,TC
"RTN","RORRP4",112,0)
 S C=""
"RTN","RORRP4",113,0)
 S M=$E(FDATE,4,5),Y=$E(FDATE,2,3),D=$E(FDATE,6,7)
"RTN","RORRP4",114,0)
 S TC=$E(FDATE,1,1)
"RTN","RORRP4",115,0)
 I TC=1 S C=18
"RTN","RORRP4",116,0)
 I TC=2 S C=19
"RTN","RORRP4",117,0)
 I TC=3 S C=20
"RTN","RORRP4",118,0)
 S FDATE=FDATE_"~"_M_"/"_D_"/"_C_Y
"RTN","RORRP4",119,0)
 Q FDATE
"RTN","RORRP4",120,0)
 ;
"RTN","RORRP4",121,0)
REASON(IEN) ;  Get short description of selection rules passed if none 
"RTN","RORRP4",122,0)
 ;          exist pass back 'Manual entry'.
"RTN","RORRP4",123,0)
 ;
"RTN","RORRP4",124,0)
 N DESC,K4,STR,POINTER,COUNT
"RTN","RORRP4",125,0)
 S K4="0",STR="",COUNT=0,DESC=""
"RTN","RORRP4",126,0)
 S REASON(1)="Manual Entry"
"RTN","RORRP4",127,0)
 F  S K4=$O(^RORDATA(798,IEN,1,K4)) Q:'K4  D
"RTN","RORRP4",128,0)
 . S STR=$G(^RORDATA(798,IEN,1,K4,0)) Q:STR=""
"RTN","RORRP4",129,0)
 . S POINTER=$P(STR,"^",1)
"RTN","RORRP4",130,0)
 . S DESC=$P(^ROR(798.2,POINTER,0),"^",3) Q:DESC=""
"RTN","RORRP4",131,0)
 . S COUNT=COUNT+1
"RTN","RORRP4",132,0)
 . S REASON(COUNT)=DESC
"RTN","RORRP4",133,0)
 . Q
"RTN","RORRP4",134,0)
 Q
"RTN","RORRP4",135,0)
 ;          
"RTN","RORRP4",136,0)
 ;
"RTN","RORRP7")
0^23^B17493831
"RTN","RORRP7",1,0)
RORRP7 ; HOIFO/CRT - Activity Log RPC ; 11/1/02 10:17am
"RTN","RORRP7",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORRP7",3,0)
 ;
"RTN","RORRP7",4,0)
EN1(RES,RORREG,RORSTDT,RORENDT) ; ROR ACTIVITY LOG
"RTN","RORRP7",5,0)
 ;
"RTN","RORRP7",6,0)
 ; INPUT:  RORREG  - Registry Name   (Req'd)
"RTN","RORRP7",7,0)
 ;         RORSTDT - Start Date/Time (Optional)
"RTN","RORRP7",8,0)
 ;         RORENDT - End Date/Time   (Optional)
"RTN","RORRP7",9,0)
 ; OUTPUT: RES     - ^TMP($J,"ROR RPC LOG",n)
"RTN","RORRP7",10,0)
 ;
"RTN","RORRP7",11,0)
 N CNT,IEN,I,J,K,L,M
"RTN","RORRP7",12,0)
 ;
"RTN","RORRP7",13,0)
 S RES=$NA(^TMP($J,"ROR RPC LOG"))
"RTN","RORRP7",14,0)
 K @RES
"RTN","RORRP7",15,0)
 ;
"RTN","RORRP7",16,0)
 S RORREG=$G(RORREG) Q:RORREG=""
"RTN","RORRP7",17,0)
 S RORREG=$O(^ROR(798.1,"B",RORREG,0))
"RTN","RORRP7",18,0)
 ;
"RTN","RORRP7",19,0)
 S RORSTDT=$P($G(RORSTDT),".")
"RTN","RORRP7",20,0)
 ;
"RTN","RORRP7",21,0)
 S RORENDT=$P($G(RORENDT),".")
"RTN","RORRP7",22,0)
 I RORENDT]"" S RORENDT=+RORENDT_".235959"
"RTN","RORRP7",23,0)
 I RORENDT="" S RORENDT=9999999.999999
"RTN","RORRP7",24,0)
 ;
"RTN","RORRP7",25,0)
 S I=RORSTDT F  S I=$O(^RORDATA(798.7,"ARD",RORREG,I)) Q:I=""  Q:I>RORENDT  D
"RTN","RORRP7",26,0)
 .S J=0 F  S J=$O(^RORDATA(798.7,"ARD",RORREG,I,J)) Q:'+J  D
"RTN","RORRP7",27,0)
 ..S IEN=J_","
"RTN","RORRP7",28,0)
 ..S CNT=$G(CNT)+1
"RTN","RORRP7",29,0)
 ..S $P(@RES@(CNT),"^",1)="A"
"RTN","RORRP7",30,0)
 ..S $P(@RES@(CNT),"^",2)=$$GET1^DIQ(798.7,IEN,.01)
"RTN","RORRP7",31,0)
 ..S $P(@RES@(CNT),"^",3)=$$GET1^DIQ(798.7,IEN,1)
"RTN","RORRP7",32,0)
 ..S $P(@RES@(CNT),"^",4)=J
"RTN","RORRP7",33,0)
 ..S L=0 F  S L=$O(^RORDATA(798.7,J,2,L)) Q:'+L  D
"RTN","RORRP7",34,0)
 ...N IEN3
"RTN","RORRP7",35,0)
 ...S IEN3=L_","_J_","
"RTN","RORRP7",36,0)
 ...S CNT=$G(CNT)+1
"RTN","RORRP7",37,0)
 ...S $P(@RES@(CNT),"^",1)="M"
"RTN","RORRP7",38,0)
 ...S $P(@RES@(CNT),"^",2)=$$GET1^DIQ(798.74,IEN3,1,"I")
"RTN","RORRP7",39,0)
 ...S $P(@RES@(CNT),"^",3)=$$GET1^DIQ(798.74,IEN3,2)
"RTN","RORRP7",40,0)
 ...S $P(@RES@(CNT),"^",4)=L_","_J
"RTN","RORRP7",41,0)
 ..S CNT=$G(CNT)+1
"RTN","RORRP7",42,0)
 ..S @RES@(CNT)="$$ENDOFACTIVITY"
"RTN","RORRP7",43,0)
 Q
"RTN","RORRP7",44,0)
 ;
"RTN","RORRP7",45,0)
EN2(RES,RORIEN) ; ROR ACTIVITY DETAILS
"RTN","RORRP7",46,0)
 ;
"RTN","RORRP7",47,0)
 ; INPUT:  RORIEN  - Activity Log IEN (File #798.7)  (Req'd)
"RTN","RORRP7",48,0)
 ; OUTPUT: RES(1-n)  - Activity Details Display
"RTN","RORRP7",49,0)
 ;
"RTN","RORRP7",50,0)
 N CNT,I,ROROUT,ROROUT2,ROROUT3,RORMSG
"RTN","RORRP7",51,0)
 ;
"RTN","RORRP7",52,0)
 S CNT=1
"RTN","RORRP7",53,0)
 S RES(1)="-1^Failed to retrieve activity details"
"RTN","RORRP7",54,0)
 ;
"RTN","RORRP7",55,0)
 S RORIEN=$G(RORIEN)  Q:RORIEN=""
"RTN","RORRP7",56,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORRP7",57,0)
 ;
"RTN","RORRP7",58,0)
 D GETS^DIQ(798.7,RORIEN,"*",,"ROROUT","RORMSG")
"RTN","RORRP7",59,0)
 Q:$G(DIERR)
"RTN","RORRP7",60,0)
 ;
"RTN","RORRP7",61,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.7,RORIEN,1) ; Activity
"RTN","RORRP7",62,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.7,RORIEN,2) ; Job#
"RTN","RORRP7",63,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.7,RORIEN,.01) ; StartDateTime
"RTN","RORRP7",64,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.7,RORIEN,5) ; EndDateTime
"RTN","RORRP7",65,0)
 ;
"RTN","RORRP7",66,0)
 D LIST^DIC(798.73,","_RORIEN,"@;.01","U",,,,"B",,,"ROROUT2","RORMSG")
"RTN","RORRP7",67,0)
 I '$G(DIERR),$G(ROROUT2("DILIST",0))>0  D
"RTN","RORRP7",68,0)
 . S CNT=CNT+1,RES(CNT)="$$STARTREGISTRYLIST"
"RTN","RORRP7",69,0)
 . S I=0  F  S I=$O(ROROUT2("DILIST","ID",I))  Q:'I  D
"RTN","RORRP7",70,0)
 . . S CNT=CNT+1,RES(CNT)=ROROUT2("DILIST","ID",I,.01) ; Registry
"RTN","RORRP7",71,0)
 . S CNT=CNT+1,RES(CNT)="$$ENDREGISTRYLIST"
"RTN","RORRP7",72,0)
 ;
"RTN","RORRP7",73,0)
 D LIST^DIC(798.74,","_RORIEN,"@;2.1","U",,,,"B",,,"ROROUT3","RORMSG")
"RTN","RORRP7",74,0)
 I '$G(DIERR),$G(ROROUT3("DILIST",0))>0  D
"RTN","RORRP7",75,0)
 . S CNT=CNT+1,RES(CNT)="$$STARTMESSAGELIST"
"RTN","RORRP7",76,0)
 . S I=0  F  S I=$O(ROROUT3("DILIST","ID",I))  Q:'I  D
"RTN","RORRP7",77,0)
 . . S CNT=CNT+1,RES(CNT)=ROROUT3("DILIST","ID",I,2.1) ; Message Text
"RTN","RORRP7",78,0)
 . S CNT=CNT+1,RES(CNT)="$$ENDMESSAGELIST"
"RTN","RORRP7",79,0)
 ;
"RTN","RORRP7",80,0)
 I ROROUT(798.7,RORIEN,6.01)'=""  D
"RTN","RORRP7",81,0)
 . S CNT=CNT+1,RES(CNT)="$$STARTADDINFO"
"RTN","RORRP7",82,0)
 . S CNT=CNT+1,RES(CNT)=ROROUT(798.7,RORIEN,6.01) ; Patients Processed
"RTN","RORRP7",83,0)
 . S CNT=CNT+1,RES(CNT)=ROROUT(798.7,RORIEN,6.02) ; Patients with Errors
"RTN","RORRP7",84,0)
 . S CNT=CNT+1,RES(CNT)=ROROUT(798.7,RORIEN,6.03) ; Rate
"RTN","RORRP7",85,0)
  .S CNT=CNT+1,RES(CNT)="$$ENDADDINFO"
"RTN","RORRP7",86,0)
 ;
"RTN","RORRP7",87,0)
 S RES(1)="1^Success"
"RTN","RORRP7",88,0)
 Q
"RTN","RORRP7",89,0)
EN3(RES,RORIEN) ; ROR LOG MESSAGE DETAILS
"RTN","RORRP7",90,0)
 ;
"RTN","RORRP7",91,0)
 ; INPUT:  RORIEN  -  Message IEN in Log File (File #798.74)  (Req'd)
"RTN","RORRP7",92,0)
 ; OUTPUT: RES(1-n)  - Activity Details Display
"RTN","RORRP7",93,0)
 ;
"RTN","RORRP7",94,0)
 N CNT,I,RORMSG,ROROUT
"RTN","RORRP7",95,0)
 ;
"RTN","RORRP7",96,0)
 S CNT=1
"RTN","RORRP7",97,0)
 S RES(1)="-1^Failed to retrieve message details"
"RTN","RORRP7",98,0)
 ;
"RTN","RORRP7",99,0)
 S RORIEN=$G(RORIEN)  Q:RORIEN=""
"RTN","RORRP7",100,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORRP7",101,0)
 ;
"RTN","RORRP7",102,0)
 D GETS^DIQ(798.74,RORIEN,"*",,"ROROUT","RORMSG")
"RTN","RORRP7",103,0)
 Q:$G(DIERR)
"RTN","RORRP7",104,0)
 ;
"RTN","RORRP7",105,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.74,RORIEN,1) ; Type
"RTN","RORRP7",106,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.74,RORIEN,2) ; Message
"RTN","RORRP7",107,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.74,RORIEN,.01) ; DateTime
"RTN","RORRP7",108,0)
 S CNT=CNT+1,RES(CNT)=ROROUT(798.74,RORIEN,3) ; Patient
"RTN","RORRP7",109,0)
 ;
"RTN","RORRP7",110,0)
 I $D(ROROUT(798.74,RORIEN,4,1))  D
"RTN","RORRP7",111,0)
 . S I=0  F  S I=$O(ROROUT(798.74,RORIEN,4,I))  Q:'I  D
"RTN","RORRP7",112,0)
 . . S CNT=CNT+1,RES(CNT)=ROROUT(798.74,RORIEN,4,I) ; Additional Info
"RTN","RORRP7",113,0)
 ;
"RTN","RORRP7",114,0)
 S RES(1)="1^Success"
"RTN","RORRP7",115,0)
 Q
"RTN","RORSET01")
0^28^B13775834
"RTN","RORSET01",1,0)
RORSET01 ;HCIOFO/SG - REGISTRY SETUP ROUTINE (VA HEPC) ; 11/1/02 10:45am
"RTN","RORSET01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORSET01",3,0)
 ;
"RTN","RORSET01",4,0)
 ;***** HEPC REGISTRY SETUP
"RTN","RORSET01",5,0)
 ;
"RTN","RORSET01",6,0)
 N RORERROR      ; Error processing data
"RTN","RORSET01",7,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORSET01",8,0)
 N RORPARM       ; Application parameters
"RTN","RORSET01",9,0)
 ;
"RTN","RORSET01",10,0)
 N LSNAME,RC,RORMNTSK,RORREG,RORSUSP,TMP
"RTN","RORSET01",11,0)
 N ZTCPU,ZTDESC,ZTIO,ZTKIL,ZTPRI,ZTRTN,ZTSAVE,ZTSK,ZTSYNC,ZTUCI
"RTN","RORSET01",12,0)
 S RORPARM("ERR")=1         ; Enable error processing
"RTN","RORSET01",13,0)
 S RORPARM("SETUP")=1       ; Registry setup indicator
"RTN","RORSET01",14,0)
 ;
"RTN","RORSET01",15,0)
 S LSNAME="VA HEPC"
"RTN","RORSET01",16,0)
 ;--- IEN and name of the registry
"RTN","RORSET01",17,0)
 S $P(RORREG,U,2)="VA HEPC"
"RTN","RORSET01",18,0)
 S TMP=$$REGIEN^RORUTL02($P(RORREG,U,2))  G:TMP<0 ERROR
"RTN","RORSET01",19,0)
 S $P(RORREG,U,1)=TMP
"RTN","RORSET01",20,0)
 ;
"RTN","RORSET01",21,0)
 ;--- Check the Lab Search
"RTN","RORSET01",22,0)
 S RC=$$LABSRCH^RORSETU2(LSNAME)
"RTN","RORSET01",23,0)
 I RC<0  G:RC'=-55 ERROR  D  Q:RC<1  ;----------> ERROR
"RTN","RORSET01",24,0)
 . S RC=$$LSCONF^RORSETU1(LSNAME)
"RTN","RORSET01",25,0)
 ;
"RTN","RORSET01",26,0)
 ;--- Request setup parameters
"RTN","RORSET01",27,0)
 S RC=$$ASKPARMS^RORSETU1(.RORMNTSK,.RORSUSP)
"RTN","RORSET01",28,0)
 I RC<0  Q:(RC=-71)!(RC=-72)                    G ERROR
"RTN","RORSET01",29,0)
 ;
"RTN","RORSET01",30,0)
 ;--- Schedule the setup task
"RTN","RORSET01",31,0)
 S ZTRTN="TASK^RORSET01",ZTIO=""
"RTN","RORSET01",32,0)
 S ZTDESC="Registry Setup ("_$P(RORREG,U,2)_")"
"RTN","RORSET01",33,0)
 F TMP="RORMNTSK","RORREG","RORSUSP"  S ZTSAVE(TMP)=""
"RTN","RORSET01",34,0)
 D ^%ZTLOAD
"RTN","RORSET01",35,0)
 Q
"RTN","RORSET01",36,0)
ERROR ;--- Display the errors
"RTN","RORSET01",37,0)
 D DSPSTK^RORERR()
"RTN","RORSET01",38,0)
 Q
"RTN","RORSET01",39,0)
 ;
"RTN","RORSET01",40,0)
 ;***** REPLACES THE SELECTION RULES
"RTN","RORSET01",41,0)
 ;
"RTN","RORSET01",42,0)
 ; RORREG        Registry IEN and registry name separated by the '^'
"RTN","RORSET01",43,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORSET01",44,0)
 ; FROM,TO       Codes of the rule groups (1-regular, 2-historical)
"RTN","RORSET01",45,0)
 ;
"RTN","RORSET01",46,0)
 ; Return Values:
"RTN","RORSET01",47,0)
 ;       <0  Error code
"RTN","RORSET01",48,0)
 ;        0  Ok
"RTN","RORSET01",49,0)
 ;
"RTN","RORSET01",50,0)
RULES(RORREG,FROM,TO) ;
"RTN","RORSET01",51,0)
 ;;VA HEPC PTF^VA HEPC PTF HIST
"RTN","RORSET01",52,0)
 ;;VA HEPC VPOV^VA HEPC VISIT HIST
"RTN","RORSET01",53,0)
 ;
"RTN","RORSET01",54,0)
 N I,IEN,IENS,NAMES,RC,RORFDA,RORMSG
"RTN","RORSET01",55,0)
 S IENS=","_(+RORREG)_",",RC=0
"RTN","RORSET01",56,0)
 ;--- Replace the selection rules
"RTN","RORSET01",57,0)
 F I=1,2  D  Q:RC<0
"RTN","RORSET01",58,0)
 . S NAMES=$P($T(RULES+I),";;",2)  Q:NAMES?."^"
"RTN","RORSET01",59,0)
 . S IEN=$$FIND1^DIC(798.13,IENS,"UX",$P(NAMES,U,FROM),"B",,"RORMSG")
"RTN","RORSET01",60,0)
 . Q:IEN=0
"RTN","RORSET01",61,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"RULES^RORPOSO1",,798.13)
"RTN","RORSET01",62,0)
 . Q:RC<0
"RTN","RORSET01",63,0)
 . S RORFDA(798.13,IEN_IENS,.01)=$P(NAMES,U,TO)
"RTN","RORSET01",64,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORSET01",65,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"RULES^RORPOSO1",,798.13,IEN_IENS)
"RTN","RORSET01",66,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORSET01",67,0)
 ;
"RTN","RORSET01",68,0)
 ;***** ENTRY POINT OF THE REGISTRY SETUP TASK
"RTN","RORSET01",69,0)
 ;
"RTN","RORSET01",70,0)
 ; RORMNTSK      Maximum number of the registry update subtasks
"RTN","RORSET01",71,0)
 ; RORREG        RegistryIEN^RegistryName
"RTN","RORSET01",72,0)
 ; RORSUSP       Task suspension time frame (StartTime^EndTime)
"RTN","RORSET01",73,0)
 ;
"RTN","RORSET01",74,0)
TASK ;
"RTN","RORSET01",75,0)
 N RORERROR      ; Error processing data
"RTN","RORSET01",76,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORSET01",77,0)
 N RORPARM       ; Application parameters
"RTN","RORSET01",78,0)
 ;
"RTN","RORSET01",79,0)
 N RC,REGLST,TMP
"RTN","RORSET01",80,0)
 S RORPARM("DEVELOPER")=1   ; Enable modifications
"RTN","RORSET01",81,0)
 S RORPARM("ERR")=1         ; Enable error processing
"RTN","RORSET01",82,0)
 S RORPARM("LOG")=1         ; Enable event recording
"RTN","RORSET01",83,0)
 S RORPARM("SETUP")=1       ; Registry setup indicator
"RTN","RORSET01",84,0)
 ;
"RTN","RORSET01",85,0)
 S REGLST($P(RORREG,U,2))=+RORREG
"RTN","RORSET01",86,0)
 ;--- Open a new log
"RTN","RORSET01",87,0)
 S RC=$$OPEN^RORLOG(.REGLST,0,"REGISTRY SETUP STARTED")
"RTN","RORSET01",88,0)
 D
"RTN","RORSET01",89,0)
 . ;--- Replace the selection rules with historical ones
"RTN","RORSET01",90,0)
 . S RC=$$RULES(RORREG,1,2)                             Q:RC<0
"RTN","RORSET01",91,0)
 . ;--- Populate the registry
"RTN","RORSET01",92,0)
 . S RC=$$UPDATE^RORUPD(.REGLST,,RORMNTSK,RORSUSP,"E")  Q:RC<0
"RTN","RORSET01",93,0)
 . D LOG^RORLOG(2,"The registry has been populated.")
"RTN","RORSET01",94,0)
 . ;--- Setup the registry
"RTN","RORSET01",95,0)
 . S RC=$$PREPARE^RORSETU2(RORREG)
"RTN","RORSET01",96,0)
 ;
"RTN","RORSET01",97,0)
 ;--- Restore the regular selection rules
"RTN","RORSET01",98,0)
 S TMP=$$RULES(RORREG,2,1)  I TMP<0  S:RC'<0 RC=TMP
"RTN","RORSET01",99,0)
 ;--- Close the log
"RTN","RORSET01",100,0)
 S TMP="REGISTRY SETUP "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","RORSET01",101,0)
 D CLOSE^RORLOG(TMP)
"RTN","RORSET01",102,0)
 ;--- Send an alert to the originator of the task
"RTN","RORSET01",103,0)
 S TMP=$S(RC<0:-43,1:-41)
"RTN","RORSET01",104,0)
 D ALERT^RORKIDS(DUZ,TMP,$P(RORREG,U,2),,"registry setup")
"RTN","RORSET01",105,0)
 I RC'<0  D  S ZTREQ="@"
"RTN","RORSET01",106,0)
 . K ^XTMP("RORUPDR"_+RORREG)
"RTN","RORSET01",107,0)
 Q
"RTN","RORTXT")
0^34^B339606
"RTN","RORTXT",1,0)
RORTXT ;HCIOFO/SG - TEXT RESOURCE UTILITIES ; 12/13/02 11:15am
"RTN","RORTXT",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORTXT",3,0)
 ;
"RTN","RORTXT",4,0)
 ;***** RETURNS THE TEXT RESOURCE
"RTN","RORTXT",5,0)
 ;
"RTN","RORTXT",6,0)
 ; DIALOG        Dialog number (in the DIALOG file)
"RTN","RORTXT",7,0)
 ;
"RTN","RORTXT",8,0)
 ; .RORDST       Reference to a local variable where the text
"RTN","RORTXT",9,0)
 ;               will be stored.
"RTN","RORTXT",10,0)
 ;
"RTN","RORTXT",11,0)
 ; [FLAGS]       Flags that define the mode of execution
"RTN","RORTXT",12,0)
 ;
"RTN","RORTXT",13,0)
 ;                 A  Append the text to the content of RORDST.
"RTN","RORTXT",14,0)
 ;
"RTN","RORTXT",15,0)
 ;                 S  Suppress the blank line that is normally
"RTN","RORTXT",16,0)
 ;                    inserted between discrete blocks of text
"RTN","RORTXT",17,0)
 ;                    (in Append mode).
"RTN","RORTXT",18,0)
 ;
"RTN","RORTXT",19,0)
 ;                 F  Format the local array similar to the default
"RTN","RORTXT",20,0)
 ;                    output format of the ^TMP global (see the
"RTN","RORTXT",21,0)
 ;                    BLD^DIALOG documentation for more detailes).
"RTN","RORTXT",22,0)
 ;
"RTN","RORTXT",23,0)
TEXT(DIALOG,RORDST,FLAGS) ;
"RTN","RORTXT",24,0)
 N DIERR,DIHELP,DIMSG
"RTN","RORTXT",25,0)
 K:'($G(FLAGS)["A") RORDST
"RTN","RORTXT",26,0)
 D BLD^DIALOG(DIALOG,,,"RORDST",$TR($G(FLAGS),"A"))
"RTN","RORTXT",27,0)
 Q
"RTN","RORUPD01")
0^6^B66304446
"RTN","RORUPD01",1,0)
RORUPD01 ;HCIOFO/SG - PROCESSING OF THE FILES  ; 10/24/02 2:33pm
"RTN","RORUPD01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3**;May 14, 2002
"RTN","RORUPD01",3,0)
 ;
"RTN","RORUPD01",4,0)
 ; This routine uses the following IA's:
"RTN","RORUPD01",5,0)
 ;
"RTN","RORUPD01",6,0)
 ; #3646         $$EMPL^DGSEC4
"RTN","RORUPD01",7,0)
 ; #10035        Browse through IENs of the file #2
"RTN","RORUPD01",8,0)
 ;
"RTN","RORUPD01",9,0)
 Q
"RTN","RORUPD01",10,0)
 ;
"RTN","RORUPD01",11,0)
 ;***** CHECKS FOR A STOP REQUESTS (TASKMAN & PROPRIETARY)
"RTN","RORUPD01",12,0)
 ;
"RTN","RORUPD01",13,0)
 ; Return Values:
"RTN","RORUPD01",14,0)
 ;        0  Continue running
"RTN","RORUPD01",15,0)
 ;        1  Stop the subtask
"RTN","RORUPD01",16,0)
 ;
"RTN","RORUPD01",17,0)
CHKSTOP() ;
"RTN","RORUPD01",18,0)
 Q:'$G(RORUPD("JOB")) $$S^%ZTLOAD
"RTN","RORUPD01",19,0)
 L +@RORUPDPI@("T",0):0
"RTN","RORUPD01",20,0)
 I  L -@RORUPDPI@("T",0)  Q 1
"RTN","RORUPD01",21,0)
 Q $$S^%ZTLOAD
"RTN","RORUPD01",22,0)
 ;
"RTN","RORUPD01",23,0)
 ;***** LOAD DATA ELEMENTS
"RTN","RORUPD01",24,0)
 ;
"RTN","RORUPD01",25,0)
 ; IENS          IENS of the current record
"RTN","RORUPD01",26,0)
 ;
"RTN","RORUPD01",27,0)
 ; Return values:
"RTN","RORUPD01",28,0)
 ;       <0  Error code
"RTN","RORUPD01",29,0)
 ;        0  Ok
"RTN","RORUPD01",30,0)
 ;
"RTN","RORUPD01",31,0)
LOAD(IENS) ;
"RTN","RORUPD01",32,0)
 N RC  S RC=0
"RTN","RORUPD01",33,0)
 ;--- API #1
"RTN","RORUPD01",34,0)
 I $D(RORUPD("SR",2,"F",1))  D  Q:RC<0 RC
"RTN","RORUPD01",35,0)
 . S RC=$$LOADFLDS^RORUPDUT(2,IENS)
"RTN","RORUPD01",36,0)
 ;--- API #2
"RTN","RORUPD01",37,0)
 Q 0
"RTN","RORUPD01",38,0)
 ;
"RTN","RORUPD01",39,0)
 ;***** INITIALIZES LOOP CONTROL LISTS
"RTN","RORUPD01",40,0)
 ;
"RTN","RORUPD01",41,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD01",42,0)
 ;
"RTN","RORUPD01",43,0)
 ; Return Values:
"RTN","RORUPD01",44,0)
 ;       <0  Error code
"RTN","RORUPD01",45,0)
 ;        0  Ok
"RTN","RORUPD01",46,0)
 ;
"RTN","RORUPD01",47,0)
 ; The RORUPD("LM",1,Rule Name) list contains names of the top level
"RTN","RORUPD01",48,0)
 ; rules that have not been triggered by now.
"RTN","RORUPD01",49,0)
 ;
"RTN","RORUPD01",50,0)
 ; The RORUPD("LM",2,Registry#) list contains IENs of the registries
"RTN","RORUPD01",51,0)
 ; that do not contain the patient by now.
"RTN","RORUPD01",52,0)
 ;
"RTN","RORUPD01",53,0)
 ; If the patient is an employee and the registry must not include
"RTN","RORUPD01",54,0)
 ; employees (see the EXCLUDE EMPLOYEES field of the ROR REGISTRY
"RTN","RORUPD01",55,0)
 ; PARAMETERS file), the function initializes the corresponding items
"RTN","RORUPD01",56,0)
 ; of control lists as if the patient were already in the registry.
"RTN","RORUPD01",57,0)
 ; Therefore, the patient will not be added to this registry.
"RTN","RORUPD01",58,0)
 ;
"RTN","RORUPD01",59,0)
LOOPINIT(PATIEN) ;
"RTN","RORUPD01",60,0)
 N I,EMPL,REGIEN
"RTN","RORUPD01",61,0)
 K RORUPD("LM",1),RORUPD("LM",2)
"RTN","RORUPD01",62,0)
 S EMPL=$$EMPL^DGSEC4(PATIEN,"P")
"RTN","RORUPD01",63,0)
 M RORUPD("LM",1)=RORUPD("LM1")
"RTN","RORUPD01",64,0)
 S REGIEN=""
"RTN","RORUPD01",65,0)
 F  S REGIEN=$O(RORUPD("LM2",REGIEN))  Q:REGIEN=""  D
"RTN","RORUPD01",66,0)
 . S $P(RORUPD("LM2",REGIEN),U)=0
"RTN","RORUPD01",67,0)
 . ;--- Check if the patient is already in the registry
"RTN","RORUPD01",68,0)
 . Q:$D(^RORDATA(798,"KEY",PATIEN,REGIEN))
"RTN","RORUPD01",69,0)
 . ;--- Check if the patient is an employee and the
"RTN","RORUPD01",70,0)
 . ;--- employees must not be added to the registry
"RTN","RORUPD01",71,0)
 . I EMPL  Q:$P(RORUPD("LM2",REGIEN),U,2)
"RTN","RORUPD01",72,0)
 . ;--- Initialize the items of control lists
"RTN","RORUPD01",73,0)
 . S $P(RORUPD("LM2",REGIEN),U)=1,RORUPD("LM",2,REGIEN)=""
"RTN","RORUPD01",74,0)
 Q 0
"RTN","RORUPD01",75,0)
 ;
"RTN","RORUPD01",76,0)
 ;***** PROCESS EVERY PATIENT IN THE 'PATIENT' FILE
"RTN","RORUPD01",77,0)
 ;
"RTN","RORUPD01",78,0)
 ; BEGIEN        Start IEN in the PATIENT file
"RTN","RORUPD01",79,0)
 ; ENDIEN        End IEN in the PATIENT file
"RTN","RORUPD01",80,0)
 ;
"RTN","RORUPD01",81,0)
 ; Return Values:
"RTN","RORUPD01",82,0)
 ;       <0  Error code
"RTN","RORUPD01",83,0)
 ;      >=0  Statistics
"RTN","RORUPD01",84,0)
 ;             ^1: Total number of processed patients
"RTN","RORUPD01",85,0)
 ;             ^2: Number of patients processed with errors
"RTN","RORUPD01",86,0)
 ;
"RTN","RORUPD01",87,0)
 ; If there is an error in processing of a patient, routine behavior
"RTN","RORUPD01",88,0)
 ; depends on the mode of execution:
"RTN","RORUPD01",89,0)
 ;
"RTN","RORUPD01",90,0)
 ; In the normal mode program logs the errors, adds a record to the
"RTN","RORUPD01",91,0)
 ; ROR PENDING PATIENT file (#798.3), and continues processing of
"RTN","RORUPD01",92,0)
 ; the remaining patients. Next registry update wil start data scan
"RTN","RORUPD01",93,0)
 ; for this patient from the date stored in the file #798.3.
"RTN","RORUPD01",94,0)
 ;
"RTN","RORUPD01",95,0)
 ; In the debug mode 3 program is aborted if there is an error
"RTN","RORUPD01",96,0)
 ; during processing of a patient.
"RTN","RORUPD01",97,0)
 ;
"RTN","RORUPD01",98,0)
PROCESS(BEGIEN,ENDIEN) ;
"RTN","RORUPD01",99,0)
 N CNT,DTNEXT,ECNT,EXIT,PATIEN,RC,TH,TMP
"RTN","RORUPD01",100,0)
 ;--- Loop through the patients
"RTN","RORUPD01",101,0)
 S:$G(ENDIEN)'>0 ENDIEN=0
"RTN","RORUPD01",102,0)
 S PATIEN=$S($G(BEGIEN)>0:$O(^DPT(BEGIEN),-1),1:0)
"RTN","RORUPD01",103,0)
 S (CNT,ECNT,EXIT,RC)=0
"RTN","RORUPD01",104,0)
 F  S PATIEN=$O(^DPT(PATIEN))  Q:PATIEN'>0  D  Q:EXIT!(RC<0)
"RTN","RORUPD01",105,0)
 . I ENDIEN,PATIEN'<ENDIEN  S EXIT=1  Q
"RTN","RORUPD01",106,0)
 . ;--- For a queued task only
"RTN","RORUPD01",107,0)
 . I $D(ZTQUEUED)  S RC=0  D  Q:RC<0
"RTN","RORUPD01",108,0)
 . . ;--- Check if task stop has been requested
"RTN","RORUPD01",109,0)
 . . I $$CHKSTOP()  S RC=$$ERROR^RORERR(-42,"PROCESS^RORUPD01")  Q
"RTN","RORUPD01",110,0)
 . . ;--- Check if the task should be suspended
"RTN","RORUPD01",111,0)
 . . Q:'$G(RORUPD("SUSPEND"))
"RTN","RORUPD01",112,0)
 . . Q:$$NOW^XLFDT<$G(DTNEXT)
"RTN","RORUPD01",113,0)
 . . Q:'$$SUSPEND(.DTNEXT)
"RTN","RORUPD01",114,0)
 . . ;--- Suspend the task during the peak hours
"RTN","RORUPD01",115,0)
 . . F  D  Q:'TH!(RC<0)
"RTN","RORUPD01",116,0)
 . . . S TH=$$FMDIFF^XLFDT(DTNEXT,$$NOW^XLFDT,2)
"RTN","RORUPD01",117,0)
 . . . I TH<60  S TH=0  Q       ; Do not HANG for less than a
"RTN","RORUPD01",118,0)
 . . . H $S(TH>3600:3600,1:TH)  ; minute and more than an hour
"RTN","RORUPD01",119,0)
 . . . ;--- Check if task stop has been requested
"RTN","RORUPD01",120,0)
 . . . S:$$CHKSTOP() RC=$$ERROR^RORERR(-42,"PROCESS^RORUPD01")
"RTN","RORUPD01",121,0)
 . ;--- Update the progress indicator
"RTN","RORUPD01",122,0)
 . S CNT=CNT+1
"RTN","RORUPD01",123,0)
 . I $G(RORPARM("DEBUG"))>1  W:$E($G(IOST),1,2)="C-" *13,CNT
"RTN","RORUPD01",124,0)
 . ;--- Process the patient
"RTN","RORUPD01",125,0)
 . S RC=$$PROCPAT(PATIEN)
"RTN","RORUPD01",126,0)
 . I $G(RORPARM("SETUP"))  D:'(CNT#1000)
"RTN","RORUPD01",127,0)
 . . D LOG^RORLOG(2,"Number of patients processed by now: "_CNT)
"RTN","RORUPD01",128,0)
 . ;--- Process the error (if any)
"RTN","RORUPD01",129,0)
 . I RC<0  D  S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORUPD01",130,0)
 . . I RC=-66  S RC=0  Q        ; Counter in the file #798.3
"RTN","RORUPD01",131,0)
 . . S ECNT=ECNT+1
"RTN","RORUPD01",132,0)
 . . S RC=$$ERROR^RORERR(-15,"PROCESS^RORUPD01",,PATIEN)
"RTN","RORUPD01",133,0)
 . . ;--- Create a record in the file #798.3
"RTN","RORUPD01",134,0)
 . . S TMP=$$ADD^RORUPP01(PATIEN,RORUPD("DSBEG"))
"RTN","RORUPD01",135,0)
 . . S:TMP<0 RC=TMP
"RTN","RORUPD01",136,0)
 Q $S(RC<0:RC,1:CNT_"^"_ECNT)
"RTN","RORUPD01",137,0)
 ;
"RTN","RORUPD01",138,0)
 ;***** PROCESSES PATIENT'S DATA (EXCEPT DEMOGRAPHIC DATA)
"RTN","RORUPD01",139,0)
 ;
"RTN","RORUPD01",140,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD01",141,0)
 ; [NOUPD]       Disable registry update (0 by default)
"RTN","RORUPD01",142,0)
 ;
"RTN","RORUPD01",143,0)
 ; Return Values:
"RTN","RORUPD01",144,0)
 ;       <0  Error code
"RTN","RORUPD01",145,0)
 ;        0  Ok
"RTN","RORUPD01",146,0)
 ;
"RTN","RORUPD01",147,0)
 ; If there is a record for the patient in the ROR PENDING PATIENT
"RTN","RORUPD01",148,0)
 ; file (#798.3) and date in that record is less than a value of the
"RTN","RORUPD01",149,0)
 ; RORUPD("DSBEG") then it is used as a start date of the data scan
"RTN","RORUPD01",150,0)
 ; for the patient. Otherwise, the RORUPD("DSBEG") is used.
"RTN","RORUPD01",151,0)
 ;
"RTN","RORUPD01",152,0)
PROCPAT(PATIEN,NOUPD) ;
"RTN","RORUPD01",153,0)
 ;--- Quit if the patient has already been processed
"RTN","RORUPD01",154,0)
 Q:$D(@RORUPDPI@("U",PATIEN)) 0
"RTN","RORUPD01",155,0)
 ;--- Quit if the patient's record has been merged
"RTN","RORUPD01",156,0)
 Q:$G(^DPT(PATIEN,-9)) 0
"RTN","RORUPD01",157,0)
 ;--- Do not update the registries with a "test patient"
"RTN","RORUPD01",158,0)
 I '$G(NOUPD),$$TESTPAT^RORUTL01(PATIEN)  D  Q 0
"RTN","RORUPD01",159,0)
 . S @RORUPDPI@("U",PATIEN)=""
"RTN","RORUPD01",160,0)
 ;
"RTN","RORUPD01",161,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD01",162,0)
 ;
"RTN","RORUPD01",163,0)
 N PATIENS,RC,RLST,RORMSG,SDSDT,TMP,UPDREG,UPDSTART
"RTN","RORUPD01",164,0)
 S PATIENS=PATIEN_","
"RTN","RORUPD01",165,0)
 ;--- Initialize the variables
"RTN","RORUPD01",166,0)
 D CLEAR^RORERR("PROCPAT^RORUPD01"),CLREC^RORUPDUT
"RTN","RORUPD01",167,0)
 K RORVALS ; Clear all calculated values
"RTN","RORUPD01",168,0)
 S RC=$$LOOPINIT(PATIEN)  Q:RC<0 RC
"RTN","RORUPD01",169,0)
 ;
"RTN","RORUPD01",170,0)
 ;--- If the loop control list of registries is empty, the patient
"RTN","RORUPD01",171,0)
 ;    is already in all the registries that we are going to process.
"RTN","RORUPD01",172,0)
 S UPDREG=0
"RTN","RORUPD01",173,0)
 I $D(RORUPD("LM",2))>1  S RC=0  D  G:RC<0 PPEX  S UPDREG='$G(NOUPD)
"RTN","RORUPD01",174,0)
 . ;--- Determine start date of the data scan
"RTN","RORUPD01",175,0)
 . S UPDSTART=RORUPD("DSBEG")
"RTN","RORUPD01",176,0)
 . S SDSDT=$$SDSDATE^RORUPP01(PATIEN)
"RTN","RORUPD01",177,0)
 . I SDSDT<0  S RC=SDSDT  Q
"RTN","RORUPD01",178,0)
 . I SDSDT  S:SDSDT<UPDSTART UPDSTART=SDSDT
"RTN","RORUPD01",179,0)
 . S UPDSTART=$$FMADD^XLFDT(UPDSTART\1,-RORUPD("LD",1))
"RTN","RORUPD01",180,0)
 . ;--- Load necessary data elements
"RTN","RORUPD01",181,0)
 . I $D(RORUPD("SR",2,"F"))>1  D  Q:RC<0
"RTN","RORUPD01",182,0)
 . . S RC=$$LOAD(PATIENS)
"RTN","RORUPD01",183,0)
 . D SETVAL^RORUPDUT("ROR DFN",PATIEN)
"RTN","RORUPD01",184,0)
 . ;--- Apply "before" rules
"RTN","RORUPD01",185,0)
 . S RC=$$APLRULES^RORUPDUT(2,PATIENS,"B")  Q:RC
"RTN","RORUPD01",186,0)
 . ;
"RTN","RORUPD01",187,0)
 . ;--- Process patient data from other VistA files
"RTN","RORUPD01",188,0)
 . I $D(RORUPD("SR",9000010))  D  Q:RC
"RTN","RORUPD01",189,0)
 . . S RC=$$VISIT^RORUPD08(UPDSTART,PATIEN)
"RTN","RORUPD01",190,0)
 . I $D(RORUPD("SR",9000011))  D  Q:RC
"RTN","RORUPD01",191,0)
 . . S RC=$$PROBLEM^RORUPD07(UPDSTART,PATIEN)
"RTN","RORUPD01",192,0)
 . I $D(RORUPD("SR",45))  D       Q:RC
"RTN","RORUPD01",193,0)
 . . S RC=$$PTF^RORUPD09(UPDSTART,PATIEN)
"RTN","RORUPD01",194,0)
 . I $D(RORUPD("SR",63))  D       Q:RC
"RTN","RORUPD01",195,0)
 . . S RC=$$LAB^RORUPD04(UPDSTART,PATIEN)
"RTN","RORUPD01",196,0)
 . ; <--- Insert processing of other files here. Do not forget to add
"RTN","RORUPD01",197,0)
 . ;      definitions of these files into the 'ROR METADATA' file.
"RTN","RORUPD01",198,0)
 . ;
"RTN","RORUPD01",199,0)
 . ;--- Apply "after" rules
"RTN","RORUPD01",200,0)
 . S RC=$$APLRULES^RORUPDUT(2,PATIENS,"A")  Q:RC
"RTN","RORUPD01",201,0)
 ;
"RTN","RORUPD01",202,0)
 ;--- Update the registries if necessary
"RTN","RORUPD01",203,0)
 I UPDREG  S RC=$$UPDREG^RORUPD50(PATIEN)  G:RC<0 PPEX
"RTN","RORUPD01",204,0)
 ;--- Error processing
"RTN","RORUPD01",205,0)
 I $$GETEC^RORUPDUT  D  S RC=-15
"RTN","RORUPD01",206,0)
 . S RLST=$NA(@RORUPDPI@("U",PATIEN,2))
"RTN","RORUPD01",207,0)
 E  S RLST="",RC=0
"RTN","RORUPD01",208,0)
 ;--- If there are records in the file #798.3 for the patient,
"RTN","RORUPD01",209,0)
 ;    remove them (log a warning if cannot remove). If the patient
"RTN","RORUPD01",210,0)
 ;    has been processed with errors, remove only records associated
"RTN","RORUPD01",211,0)
 ;--- with the registries that the patient has been added to.
"RTN","RORUPD01",212,0)
 D:$G(SDSDT)
"RTN","RORUPD01",213,0)
 . S TMP=$$REMOVE^RORUPP01(PATIEN,RLST)
"RTN","RORUPD01",214,0)
 . S:TMP<0 TMP=$$ERROR^RORERR(-31,,,PATIEN)
"RTN","RORUPD01",215,0)
 ;--- Mark the patient as processed
"RTN","RORUPD01",216,0)
 S @RORUPDPI@("U",PATIEN)=""
"RTN","RORUPD01",217,0)
PPEX ;--- Cleanup
"RTN","RORUPD01",218,0)
 D CLRDES^RORUPDUT(2)
"RTN","RORUPD01",219,0)
 Q RC
"RTN","RORUPD01",220,0)
 ;
"RTN","RORUPD01",221,0)
 ;***** CHECKS IF THE TASK SHOULD BE SUSPENDED
"RTN","RORUPD01",222,0)
 ;
"RTN","RORUPD01",223,0)
 ; .DTNEXT       Date/Time of the next event (suspend/resume)
"RTN","RORUPD01",224,0)
 ;               is returned via this parameter
"RTN","RORUPD01",225,0)
 ;
"RTN","RORUPD01",226,0)
 ; Return Values:
"RTN","RORUPD01",227,0)
 ;        0  Continue/Resume
"RTN","RORUPD01",228,0)
 ;        1  Suspend
"RTN","RORUPD01",229,0)
 ;
"RTN","RORUPD01",230,0)
SUSPEND(DTNEXT) ;
"RTN","RORUPD01",231,0)
 N DATE,NOW,SUSPEND,TIME,TS,TR
"RTN","RORUPD01",232,0)
 S TS=$P(RORUPD("SUSPEND"),U,1)
"RTN","RORUPD01",233,0)
 S TR=$P(RORUPD("SUSPEND"),U,2)
"RTN","RORUPD01",234,0)
 S NOW=$$NOW^XLFDT,DATE=NOW\1
"RTN","RORUPD01",235,0)
 ;--- A working day
"RTN","RORUPD01",236,0)
 I $$WDCHK^RORUTL01(DATE)  D  Q SUSPEND
"RTN","RORUPD01",237,0)
 . S TIME=NOW-DATE,SUSPEND=0
"RTN","RORUPD01",238,0)
 . I TIME<TS   S DTNEXT=DATE+TS  Q
"RTN","RORUPD01",239,0)
 . I TIME'<TR  S DTNEXT=$$WDNEXT^RORUTL01(DATE)+TS  Q
"RTN","RORUPD01",240,0)
 . S DTNEXT=DATE+TR,SUSPEND=1
"RTN","RORUPD01",241,0)
 ;--- Saturday, Sunday or Holiday
"RTN","RORUPD01",242,0)
 S DTNEXT=$$WDNEXT^RORUTL01(DATE)+TS
"RTN","RORUPD01",243,0)
 Q 0
"RTN","RORUPD01",244,0)
 ;
"RTN","RORUPD01",245,0)
 ;***** UPDATES REGISTRY UPDATE PARAMETERS
"RTN","RORUPD01",246,0)
 ;
"RTN","RORUPD01",247,0)
 ; .REGLST       Reference to a local array containing registry names
"RTN","RORUPD01",248,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUPD01",249,0)
 ;
"RTN","RORUPD01",250,0)
 ; Return values:
"RTN","RORUPD01",251,0)
 ;       <0  Error code
"RTN","RORUPD01",252,0)
 ;        0  Ok
"RTN","RORUPD01",253,0)
 ;
"RTN","RORUPD01",254,0)
TMSTMP(REGLST) ;
"RTN","RORUPD01",255,0)
 N DATE,RC,REGIEN,REGIENS,REGNAME,RORFDA,RORMSG,TMP
"RTN","RORUPD01",256,0)
 S REGNAME="",RC=0
"RTN","RORUPD01",257,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPD01",258,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUPD01",259,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=+REGIEN  Q
"RTN","RORUPD01",260,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUPD01",261,0)
 . S REGIENS=REGIEN_","
"RTN","RORUPD01",262,0)
 . ;--- Check if the new date until that registry is updated is
"RTN","RORUPD01",263,0)
 . ;    greater than that stored in the registry parameters
"RTN","RORUPD01",264,0)
 . S TMP=$$GET1^DIQ(798.1,REGIENS,1,"I",,"RORMSG")
"RTN","RORUPD01",265,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD01",266,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"TMSTMP^RORUPD01",,798.1,REGIENS)
"RTN","RORUPD01",267,0)
 . S DATE=RORUPD("DSEND")\1
"RTN","RORUPD01",268,0)
 . S:DATE>TMP RORFDA(798.1,REGIENS,1)=DATE
"RTN","RORUPD01",269,0)
 . ;--- Update registry parameters (if necessary)
"RTN","RORUPD01",270,0)
 . Q:$D(RORFDA)<10
"RTN","RORUPD01",271,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUPD01",272,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD01",273,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"TMSTMP^RORUPD01",,798.1,REGIENS)
"RTN","RORUPD01",274,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPD06")
0^9^B11277011
"RTN","RORUPD06",1,0)
RORUPD06 ;HCIOFO/SG - REGISTRY UPDATE (MISCELLANEOUS) ; 11/4/02 10:46am
"RTN","RORUPD06",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORUPD06",3,0)
 ;
"RTN","RORUPD06",4,0)
 Q
"RTN","RORUPD06",5,0)
 ;
"RTN","RORUPD06",6,0)
 ;***** ADDS THE PATIENT TO THE REGISTRY (UNCONDITIONALLY)
"RTN","RORUPD06",7,0)
 ;
"RTN","RORUPD06",8,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD06",9,0)
 ; REGNAME       Registry name
"RTN","RORUPD06",10,0)
 ; .RULES        Reference to a local array containing list of
"RTN","RORUPD06",11,0)
 ;               triggered selection rules: RULES(n)=RuleIEN^Date
"RTN","RORUPD06",12,0)
 ;
"RTN","RORUPD06",13,0)
 ; Return Values:
"RTN","RORUPD06",14,0)
 ;       <0  Error code (see MSGLIST^RORERR20)
"RTN","RORUPD06",15,0)
 ;        0  Ok
"RTN","RORUPD06",16,0)
 ;
"RTN","RORUPD06",17,0)
ADDPAT(PATIEN,REGNAME,RULES) ;
"RTN","RORUPD06",18,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD06",19,0)
 N RORUPD        ; Update descriptor
"RTN","RORUPD06",20,0)
 N RORUPDPI      ; Closed root of the temporary storage
"RTN","RORUPD06",21,0)
 ;
"RTN","RORUPD06",22,0)
 N I,RC,REGIEN,REGLST,RORLRC,RORSRLST,RULEIEN,VSRLST
"RTN","RORUPD06",23,0)
 D INIT^RORUTL01("RORUPD")
"RTN","RORUPD06",24,0)
 D CLEAR^RORERR("ADDPAT^RORUPD06")
"RTN","RORUPD06",25,0)
 S RORUPDPI=$NA(^TMP("RORUPD",$J))
"RTN","RORUPD06",26,0)
 ;--- Check the registry name
"RTN","RORUPD06",27,0)
 Q:REGNAME?." " $$ERROR^RORERR(-10,,,PATIEN,REGNAME)
"RTN","RORUPD06",28,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)  Q:REGIEN<0 REGIEN
"RTN","RORUPD06",29,0)
 S REGLST(REGNAME)=REGIEN
"RTN","RORUPD06",30,0)
 ;--- Compile a list of IENs of valid selection rules
"RTN","RORUPD06",31,0)
 S I=""
"RTN","RORUPD06",32,0)
 F  S I=$O(^ROR(798.1,REGIEN,1,"B",I))  Q:I=""  D
"RTN","RORUPD06",33,0)
 . S RULEIEN=$$SRLIEN^RORUTL02(I)  S:RULEIEN>0 VSRLST(RULEIEN)=""
"RTN","RORUPD06",34,0)
 ;--- Prepare list of triggered selection rules
"RTN","RORUPD06",35,0)
 S I="",RC=0
"RTN","RORUPD06",36,0)
 F  S I=$O(RULES(I))  Q:I=""  D  Q:RC<0
"RTN","RORUPD06",37,0)
 . S RULEIEN=$P(RULES(I),U)
"RTN","RORUPD06",38,0)
 . I RULEIEN'>0            S RC=$$ERROR^RORERR(-45)  Q
"RTN","RORUPD06",39,0)
 . I '$D(VSRLST(RULEIEN))  S RC=$$ERROR^RORERR(-45)  Q
"RTN","RORUPD06",40,0)
 . S RORSRLST(RULEIEN)=$P(RULES(I),U,2)
"RTN","RORUPD06",41,0)
 Q:RC<0 RC
"RTN","RORUPD06",42,0)
 ;--- Prepare update descriptor
"RTN","RORUPD06",43,0)
 S RC=$$PREPARE1^RORUPR(.REGLST)
"RTN","RORUPD06",44,0)
 Q:RC<0 $$ERROR^RORERR(-14,,,PATIEN)
"RTN","RORUPD06",45,0)
 ;--- Add the patient to the registry
"RTN","RORUPD06",46,0)
 S RC=$$ADDPDATA^RORUPD50(PATIEN)  Q:RC<0 RC
"RTN","RORUPD06",47,0)
 S RC=$$ADD^RORUPD50(PATIEN,REGIEN,"RORSRLST")
"RTN","RORUPD06",48,0)
 ;--- Update patient demographic data
"RTN","RORUPD06",49,0)
 S RC=$$UPDPTDEM^RORUPD51(PATIEN)
"RTN","RORUPD06",50,0)
 Q:RC<0 $$ERROR^RORERR(-16,,,PATIEN)
"RTN","RORUPD06",51,0)
 ;--- Cleanup
"RTN","RORUPD06",52,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("RORUPD")
"RTN","RORUPD06",53,0)
 Q 0
"RTN","RORUPD06",54,0)
 ;
"RTN","RORUPD06",55,0)
 ;***** CHECKS/UPDATES THE SINGLE PATIENT IN THE REGISTRY
"RTN","RORUPD06",56,0)
 ;
"RTN","RORUPD06",57,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD06",58,0)
 ; REGNAME       Registry name
"RTN","RORUPD06",59,0)
 ;
"RTN","RORUPD06",60,0)
 ; .UPDBYRUL     Reference to a local array for the list of rules that
"RTN","RORUPD06",61,0)
 ;               the patient is selected by (output). The list has
"RTN","RORUPD06",62,0)
 ;               the following structure: UPDBYRUL(Rule#)=Date, where
"RTN","RORUPD06",63,0)
 ;               "Rule#" is an IEN of the selection rule in the file
"RTN","RORUPD06",64,0)
 ;               #798.2 and "Date" is the date when the patient has
"RTN","RORUPD06",65,0)
 ;               passed the selection rule for the first time.
"RTN","RORUPD06",66,0)
 ;
"RTN","RORUPD06",67,0)
 ; [CHKONLY]     If this optional parameter is undefined (default)
"RTN","RORUPD06",68,0)
 ;               or equals to zero then the function checks a patient
"RTN","RORUPD06",69,0)
 ;               against selection rules and adds him to the registry 
"RTN","RORUPD06",70,0)
 ;               if he passes at least one of the rules.
"RTN","RORUPD06",71,0)
 ;               Otherwise, the patient is only checked against the
"RTN","RORUPD06",72,0)
 ;               rules but registry is not updated.
"RTN","RORUPD06",73,0)
 ;
"RTN","RORUPD06",74,0)
 ; Return Values:
"RTN","RORUPD06",75,0)
 ;       <0  Error code (see MSGLIST^RORERR20)
"RTN","RORUPD06",76,0)
 ;        0  Ok
"RTN","RORUPD06",77,0)
 ;
"RTN","RORUPD06",78,0)
 ; If a local array passed as the UPDBYRUL parameter is undefined
"RTN","RORUPD06",79,0)
 ; after return from the function then the patient has not pass any
"RTN","RORUPD06",80,0)
 ; selection rule.
"RTN","RORUPD06",81,0)
 ;
"RTN","RORUPD06",82,0)
UPDPAT(PATIEN,REGNAME,UPDBYRUL,CHKONLY) ;
"RTN","RORUPD06",83,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD06",84,0)
 N RORLRC        ; List of Lab result codes to check
"RTN","RORUPD06",85,0)
 N RORUPD        ; Update descriptor
"RTN","RORUPD06",86,0)
 N RORUPDPI      ; Closed root of the temporary storage
"RTN","RORUPD06",87,0)
 N RORVALS       ; Calculated values
"RTN","RORUPD06",88,0)
 ;
"RTN","RORUPD06",89,0)
 N RC,REGIEN,REGLST
"RTN","RORUPD06",90,0)
 D INIT^RORUTL01("RORUPD")
"RTN","RORUPD06",91,0)
 D CLEAR^RORERR("UPDPAT^RORUPD06")
"RTN","RORUPD06",92,0)
 S RORUPDPI=$NA(^TMP("RORUPD",$J))
"RTN","RORUPD06",93,0)
 ;--- Check the registry name
"RTN","RORUPD06",94,0)
 Q:REGNAME?." " $$ERROR^RORERR(-10,,,PATIEN,REGNAME)
"RTN","RORUPD06",95,0)
 S REGLST(REGNAME)=""  K UPDBYRUL
"RTN","RORUPD06",96,0)
 ;--- Prepare selection rules
"RTN","RORUPD06",97,0)
 S RC=$$PREPARE^RORUPR(.REGLST)
"RTN","RORUPD06",98,0)
 Q:RC<0 $$ERROR^RORERR(-14,,,PATIEN)
"RTN","RORUPD06",99,0)
 D:$G(RORPARM("DEBUG"))>1 DEBUG^RORUPDUT
"RTN","RORUPD06",100,0)
 ;--- Check the patient and update the registry
"RTN","RORUPD06",101,0)
 S RC=$$PROCPAT^RORUPD01(PATIEN,$G(CHKONLY))
"RTN","RORUPD06",102,0)
 Q:RC<0 $$ERROR^RORERR(-15,,,PATIEN)
"RTN","RORUPD06",103,0)
 ;--- Update patient demographic data
"RTN","RORUPD06",104,0)
 I '$G(CHKONLY)  D  Q:RC<0 $$ERROR^RORERR(-16,,,PATIEN)
"RTN","RORUPD06",105,0)
 . S RC=$$UPDPTDEM^RORUPD51(PATIEN)
"RTN","RORUPD06",106,0)
 ;--- Load the list of triggered rules
"RTN","RORUPD06",107,0)
 S REGIEN=""
"RTN","RORUPD06",108,0)
 F  S REGIEN=$O(@RORUPDPI@("U",PATIEN,2,REGIEN))  Q:REGIEN=""  D
"RTN","RORUPD06",109,0)
 . M UPDBYRUL=@RORUPDPI@("U",PATIEN,2,REGIEN)
"RTN","RORUPD06",110,0)
 ;--- Cleanup
"RTN","RORUPD06",111,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("RORUPD")
"RTN","RORUPD06",112,0)
 Q 0
"RTN","RORUPD50")
0^7^B12438529
"RTN","RORUPD50",1,0)
RORUPD50 ;HCIOFO/SG - UPDATE THE PATIENT IN THE REGISTRIES  ; 11/4/02 8:02am
"RTN","RORUPD50",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3**;May 14, 2002
"RTN","RORUPD50",3,0)
 ;
"RTN","RORUPD50",4,0)
 Q
"RTN","RORUPD50",5,0)
 ;
"RTN","RORUPD50",6,0)
 ;***** ADDS THE PATIENT TO THE REGISTRY
"RTN","RORUPD50",7,0)
 ;
"RTN","RORUPD50",8,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD50",9,0)
 ; REGIEN        Registry IEN
"RTN","RORUPD50",10,0)
 ;
"RTN","RORUPD50",11,0)
 ; [ROR8RULS]    Closed root of a local array containing list of
"RTN","RORUPD50",12,0)
 ;               triggered selection rules:
"RTN","RORUPD50",13,0)
 ;                 @ROR8RULS@(RuleIEN)=Date
"RTN","RORUPD50",14,0)
 ;               If this parameter is not defined or equals to
"RTN","RORUPD50",15,0)
 ;               an empty string, selection rules are loaded from
"RTN","RORUPD50",16,0)
 ;               corresponding sub-node of the ^TMP("RORUPD",$J,"U").
"RTN","RORUPD50",17,0)
 ;
"RTN","RORUPD50",18,0)
 ; [[.]DOD]      Date of death. If this parameter is undefined,
"RTN","RORUPD50",19,0)
 ;               its value will be taken from the ROR PATIENT file.
"RTN","RORUPD50",20,0)
 ;               If you are going to call this function several times
"RTN","RORUPD50",21,0)
 ;               for the same patient (for different registries),
"RTN","RORUPD50",22,0)
 ;               pass a reference to undefined local variable (the
"RTN","RORUPD50",23,0)
 ;               DOD will be read from the file only once).
"RTN","RORUPD50",24,0)
 ;
"RTN","RORUPD50",25,0)
 ; Return values:
"RTN","RORUPD50",26,0)
 ;       <0  Error code
"RTN","RORUPD50",27,0)
 ;        0  Ok
"RTN","RORUPD50",28,0)
 ;        1  Patient has already existed in the registry
"RTN","RORUPD50",29,0)
 ;
"RTN","RORUPD50",30,0)
ADD(PATIEN,REGIEN,ROR8RULS,DOD) ;
"RTN","RORUPD50",31,0)
 N FINDVAL,I,IENS,IENS01,RC,RORFDA,RORIEN,RORMSG,RULEIEN,TMP
"RTN","RORUPD50",32,0)
 ;--- Try to find the patient in the registry
"RTN","RORUPD50",33,0)
 S FINDVAL(1)=PATIEN,FINDVAL(2)=REGIEN
"RTN","RORUPD50",34,0)
 D FIND^DIC(798,,"@","QUX",.FINDVAL,1,"KEY",,,"RORFDA","RORMSG")
"RTN","RORUPD50",35,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ADD^RORUPD50",,798)
"RTN","RORUPD50",36,0)
 ;--- Patient already in the registry
"RTN","RORUPD50",37,0)
 Q:$G(RORFDA("DILIST",0)) 1
"RTN","RORUPD50",38,0)
 ;--- Prepare registry data
"RTN","RORUPD50",39,0)
 K RORFDA  S IENS="+1,"
"RTN","RORUPD50",40,0)
 S RORFDA(798,IENS,.01)=PATIEN           ; Patient Name
"RTN","RORUPD50",41,0)
 S RORFDA(798,IENS,.02)=REGIEN           ; Registry
"RTN","RORUPD50",42,0)
 S RORFDA(798,IENS,1)=$$NOW^XLFDT        ; Date/time entered
"RTN","RORUPD50",43,0)
 S RORFDA(798,IENS,3)=1                  ; Status (AUTO)
"RTN","RORUPD50",44,0)
 S RORFDA(798,IENS,4)=1                  ; Update Demographics
"RTN","RORUPD50",45,0)
 S RORFDA(798,IENS,5)=1                  ; Update local data
"RTN","RORUPD50",46,0)
 ;--- Populate the inactivation date field if necessary
"RTN","RORUPD50",47,0)
 S:'($D(DOD)#10) DOD=$$GET1^DIQ(798.4,PATIEN_",",.351,"I",,"RORMSG")
"RTN","RORUPD50",48,0)
 S RORFDA(798,IENS,2)=$$INACTDOD^RORUPDUT(DOD)
"RTN","RORUPD50",49,0)
 ;--- Set the DON'T SEND flag for a "test patient"
"RTN","RORUPD50",50,0)
 S:$$TESTPAT^RORUTL01(PATIEN) RORFDA(798,IENS,11)=1
"RTN","RORUPD50",51,0)
 ;--- Load list of triggered rules
"RTN","RORUPD50",52,0)
 S:$G(ROR8RULS)="" ROR8RULS=$NA(@RORUPDPI@("U",PATIEN,2,REGIEN))
"RTN","RORUPD50",53,0)
 S RULEIEN=""
"RTN","RORUPD50",54,0)
 F I=1:1  S RULEIEN=$O(@ROR8RULS@(RULEIEN))  Q:RULEIEN=""  D
"RTN","RORUPD50",55,0)
 . S IENS01="+"_(1000+I)_","_IENS
"RTN","RORUPD50",56,0)
 . S RORFDA(798.01,IENS01,.01)=RULEIEN
"RTN","RORUPD50",57,0)
 . S RORFDA(798.01,IENS01,1)=$P(@ROR8RULS@(RULEIEN),U)\1
"RTN","RORUPD50",58,0)
 ;--- Call "before update" entry point
"RTN","RORUPD50",59,0)
 S ENTRY=$G(RORUPD("UPD",REGIEN,1))
"RTN","RORUPD50",60,0)
 I ENTRY'=""  X "S RC="_ENTRY_"(.RORFDA,PATIEN,REGIEN)"  Q:RC<0 RC
"RTN","RORUPD50",61,0)
 ;--- Update the registry
"RTN","RORUPD50",62,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORUPD50",63,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ADD^RORUPD50")
"RTN","RORUPD50",64,0)
 ;--- Call "after update" entry point
"RTN","RORUPD50",65,0)
 S ENTRY=$G(RORUPD("UPD",REGIEN,2))
"RTN","RORUPD50",66,0)
 I ENTRY'=""  X "S RC="_ENTRY_"(RORIEN(1),PATIEN,REGIEN)"  Q:RC<0 RC
"RTN","RORUPD50",67,0)
 Q 0
"RTN","RORUPD50",68,0)
 ;
"RTN","RORUPD50",69,0)
 ;***** ADDS PATIENT DATA TO THE 'ROR PATIENT' FILE
"RTN","RORUPD50",70,0)
 ;
"RTN","RORUPD50",71,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD50",72,0)
 ;
"RTN","RORUPD50",73,0)
 ; Return values:
"RTN","RORUPD50",74,0)
 ;       <0  Error code
"RTN","RORUPD50",75,0)
 ;        0  Ok
"RTN","RORUPD50",76,0)
 ;        1  Patient data have already existed
"RTN","RORUPD50",77,0)
 ;
"RTN","RORUPD50",78,0)
ADDPDATA(PATIEN) ;
"RTN","RORUPD50",79,0)
 N IENS,RC,RORBUF,RORPAT,RORIEN,RORMSG
"RTN","RORUPD50",80,0)
 ;--- Try to find patient data
"RTN","RORUPD50",81,0)
 D FIND^DIC(798.4,,"@","QUX",PATIEN,1,"B",,,"RORBUF","RORMSG")
"RTN","RORUPD50",82,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ADDPDATA^RORUPD50",,798.4)
"RTN","RORUPD50",83,0)
 ;--- Patient data already exists in the file
"RTN","RORUPD50",84,0)
 Q:$G(RORBUF("DILIST",0)) 1
"RTN","RORUPD50",85,0)
 ;--- Prepare patient data
"RTN","RORUPD50",86,0)
 S IENS="+1,"
"RTN","RORUPD50",87,0)
 S RC=$$PATDATA^RORUPD52(PATIEN_",",.RORPAT,IENS)  Q:RC<0 RC
"RTN","RORUPD50",88,0)
 S RORIEN(1)=PATIEN                      ; IEN of the new record
"RTN","RORUPD50",89,0)
 S RORPAT(798.4,IENS,.01)=PATIEN         ; Patient Name
"RTN","RORUPD50",90,0)
 ;--- Add the patient record to the file
"RTN","RORUPD50",91,0)
 D UPDATE^DIE(,"RORPAT","RORIEN","RORMSG")
"RTN","RORUPD50",92,0)
 I $G(DIERR)  D  Q:RC
"RTN","RORUPD50",93,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"ADDPDATA^RORUPD50",PATIEN,798.4)
"RTN","RORUPD50",94,0)
 Q 0
"RTN","RORUPD50",95,0)
 ;
"RTN","RORUPD50",96,0)
 ;***** ADDS THE PATIENT TO MARKED REGISTRIES
"RTN","RORUPD50",97,0)
 ;
"RTN","RORUPD50",98,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD50",99,0)
 ;
"RTN","RORUPD50",100,0)
 ; Return values:
"RTN","RORUPD50",101,0)
 ;       <0  Error code
"RTN","RORUPD50",102,0)
 ;        0  Patient should not be added to the registry
"RTN","RORUPD50",103,0)
 ;       >0  Patient has been added to the registry
"RTN","RORUPD50",104,0)
 ;
"RTN","RORUPD50",105,0)
UPDREG(PATIEN) ;
"RTN","RORUPD50",106,0)
 N DOD,ENTRY,INCTVDT,RC,REGIEN
"RTN","RORUPD50",107,0)
 ;--- Check if patient should be added to any registry
"RTN","RORUPD50",108,0)
 Q:$D(@RORUPDPI@("U",PATIEN,2))<10 0
"RTN","RORUPD50",109,0)
 ;--- Add patient data
"RTN","RORUPD50",110,0)
 S RC=$$ADDPDATA(PATIEN)  Q:RC<0 RC
"RTN","RORUPD50",111,0)
 ;--- Update all marked registries
"RTN","RORUPD50",112,0)
 S REGIEN="",RC=0
"RTN","RORUPD50",113,0)
 F  D  Q:REGIEN=""  S RC=$$ADD(PATIEN,REGIEN,,.DOD)  Q:RC<0
"RTN","RORUPD50",114,0)
 . S REGIEN=$O(@RORUPDPI@("U",PATIEN,2,REGIEN))
"RTN","RORUPD50",115,0)
 Q $S(RC<0:RC,1:1)
"RTN","RORUPD51")
0^22^B27725577
"RTN","RORUPD51",1,0)
RORUPD51 ;HCIOFO/SG - UPDATE PATIENT'S DEMOGRAPHIC DATA (1) ; 12/12/02 2:38pm
"RTN","RORUPD51",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3**;May 14, 2002
"RTN","RORUPD51",3,0)
 ;
"RTN","RORUPD51",4,0)
 Q
"RTN","RORUPD51",5,0)
 ;
"RTN","RORUPD51",6,0)
 ;***** MARKS REGISTRIES (UPDATE DEMOGRAPHICS AND INACTIVE DATE)
"RTN","RORUPD51",7,0)
 ;
"RTN","RORUPD51",8,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD51",9,0)
 ; [DOD]         Date of death
"RTN","RORUPD51",10,0)
 ;
"RTN","RORUPD51",11,0)
 ; Return Values:
"RTN","RORUPD51",12,0)
 ;       <0  Error code
"RTN","RORUPD51",13,0)
 ;        0  Ok
"RTN","RORUPD51",14,0)
 ;
"RTN","RORUPD51",15,0)
MARKREGS(PATIEN,DOD) ;
"RTN","RORUPD51",16,0)
 N ACTIVE,ECNT,I,IENS,INACTDT,RC,REACTDT,RI
"RTN","RORUPD51",17,0)
 N RORBUF,RORFDA,RORMSG,RORSRC
"RTN","RORUPD51",18,0)
 D DFLTLOC^RORERR("MARKREGS^RORUPD51")
"RTN","RORUPD51",19,0)
 ;--- Compile a list of associated registries
"RTN","RORUPD51",20,0)
 D FIND^DIC(798,,"@","QUX",PATIEN,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPD51",21,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,PATIEN,798)
"RTN","RORUPD51",22,0)
 ;--- Mark patient records of the registries
"RTN","RORUPD51",23,0)
 S RI="",ECNT=0
"RTN","RORUPD51",24,0)
 F  S RI=$O(RORBUF("DILIST",2,RI))  Q:RI=""  D  L -^RORDATA(798,+IENS)
"RTN","RORUPD51",25,0)
 . S IENS=RORBUF("DILIST",2,RI)_","
"RTN","RORUPD51",26,0)
 . K RORFDA,RORSRC
"RTN","RORUPD51",27,0)
 . ;--- Try to lock the record; if this fails, continue anyway
"RTN","RORUPD51",28,0)
 . L +^RORDATA(798,+IENS):1
"RTN","RORUPD51",29,0)
 . ;--- Load the field values
"RTN","RORUPD51",30,0)
 . D GETS^DIQ(798,IENS,"2;2.2;4;7;8","EI","RORSRC","RORMSG")
"RTN","RORUPD51",31,0)
 . I $G(DIERR)  D  S ECNT=ECNT+1  Q
"RTN","RORUPD51",32,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,798,IENS)
"RTN","RORUPD51",33,0)
 . S ACTIVE=+$G(RORSRC(798,IENS,8,"E"))
"RTN","RORUPD51",34,0)
 . S INACTDT=$G(RORSRC(798,IENS,2,"I"))
"RTN","RORUPD51",35,0)
 . S REACTDT=$G(RORSRC(798,IENS,7,"I"))
"RTN","RORUPD51",36,0)
 . ;--- Update inactivation date only if the DOD parameter
"RTN","RORUPD51",37,0)
 . ;    is defined and the patient has not been inactivated
"RTN","RORUPD51",38,0)
 . ;--- by a reason other than death
"RTN","RORUPD51",39,0)
 . I $D(DOD),'$G(RORSRC(798,IENS,2.2,"I"))  D
"RTN","RORUPD51",40,0)
 . . ;--- Do nothing if the patient is alive and there is no
"RTN","RORUPD51",41,0)
 . . ;--- inactivation date in his record
"RTN","RORUPD51",42,0)
 . . I 'DOD  Q:'INACTDT
"RTN","RORUPD51",43,0)
 . . S (RORFDA(798,IENS,2),INACTDT)=$$INACTDOD^RORUPDUT(DOD)
"RTN","RORUPD51",44,0)
 . . S RORFDA(798,IENS,2.1)="@"
"RTN","RORUPD51",45,0)
 . ;--- Do not mark again if already marked
"RTN","RORUPD51",46,0)
 . I '$G(RORSRC(798,IENS,4,"I"))  S RC=0  D  Q:RC<0
"RTN","RORUPD51",47,0)
 . . ;--- Check the new status of the record if it was
"RTN","RORUPD51",48,0)
 . . ;--- not active before
"RTN","RORUPD51",49,0)
 . . S:'ACTIVE ACTIVE=$$ACTIVE^RORDD(INACTDT,REACTDT)
"RTN","RORUPD51",50,0)
 . . ;--- Mark only active (now or before) records
"RTN","RORUPD51",51,0)
 . . S:ACTIVE RORFDA(798,IENS,4)=1
"RTN","RORUPD51",52,0)
 . ;--- Update registry data record
"RTN","RORUPD51",53,0)
 . I $D(RORFDA)>1  S RC=0  D  Q:RC<0
"RTN","RORUPD51",54,0)
 . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUPD51",55,0)
 . . I $G(DIERR)  D  S ECNT=ECNT+1
"RTN","RORUPD51",56,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,798,IENS)
"RTN","RORUPD51",57,0)
 Q $S(ECNT>0:-9,1:0)
"RTN","RORUPD51",58,0)
 ;
"RTN","RORUPD51",59,0)
 ;***** SCANS PATIENTS AND UPDATES DEMOGRAPHIC DATA (IF NECESSARY)
"RTN","RORUPD51",60,0)
 ;
"RTN","RORUPD51",61,0)
 ; .REGLST       Reference to a local array containing
"RTN","RORUPD51",62,0)
 ;               registry names as subscripts
"RTN","RORUPD51",63,0)
 ;
"RTN","RORUPD51",64,0)
 ; Return Values:
"RTN","RORUPD51",65,0)
 ;       <0  Error code
"RTN","RORUPD51",66,0)
 ;        0  Ok
"RTN","RORUPD51",67,0)
 ;
"RTN","RORUPD51",68,0)
UPDDEM(REGLST) ;
"RTN","RORUPD51",69,0)
 N CNT,IR,PATIEN,RC,REGIEN,REGNAME,ROOT,SCR,UPD,UPDCNT
"RTN","RORUPD51",70,0)
 N RORLOR,RORLST,RORMSG
"RTN","RORUPD51",71,0)
 S ROOT=$$ROOT^DILFD(798,,1)
"RTN","RORUPD51",72,0)
 ;--- Compile a list of registry internal entry numbers
"RTN","RORUPD51",73,0)
 S REGNAME="",RC=0
"RTN","RORUPD51",74,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPD51",75,0)
 . S RC=+$G(REGLST(REGNAME))
"RTN","RORUPD51",76,0)
 . S:RC'>0 RC=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUPD51",77,0)
 . S:RC>0 RORLOR(+RC)=""
"RTN","RORUPD51",78,0)
 Q:RC<0 RC
"RTN","RORUPD51",79,0)
 ;--- Loop through the patients of the registries
"RTN","RORUPD51",80,0)
 S PATIEN="",(CNT,RC)=0
"RTN","RORUPD51",81,0)
 F  S PATIEN=$O(@ROOT@("B",PATIEN))  Q:PATIEN=""  D  Q:RC<0
"RTN","RORUPD51",82,0)
 . ;--- Check if task stop has been requested
"RTN","RORUPD51",83,0)
 . I $D(ZTQUEUED),$$S^%ZTLOAD  D  Q
"RTN","RORUPD51",84,0)
 . . S RC=$$ERROR^RORERR(-42,"UPDDEM^RORUPD51")
"RTN","RORUPD51",85,0)
 . S CNT=CNT+1
"RTN","RORUPD51",86,0)
 . I $G(RORPARM("DEBUG"))>1  W:$E($G(IOST),1,2)="C-" *13,CNT
"RTN","RORUPD51",87,0)
 . ;--- Load a list of patient's registry records
"RTN","RORUPD51",88,0)
 . S SCR="S Y=+$P($G(^(0)),U,2) I Y,$D(RORLOR(Y))"
"RTN","RORUPD51",89,0)
 . D FIND^DIC(798,,"@;.02I;2.2I;8E","QUX",PATIEN,,"B",SCR,,"RORLST","RORMSG")
"RTN","RORUPD51",90,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD51",91,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"UPDDEM^RORUPD51",PATIEN,798)
"RTN","RORUPD51",92,0)
 . ;--- Demographic data should be checked only if at least one of
"RTN","RORUPD51",93,0)
 . ;    the registry records of the patient is either active or the
"RTN","RORUPD51",94,0)
 . ;    REASON FOR INACTIVATION field (798,2.2) has no value (this
"RTN","RORUPD51",95,0)
 . ;    means that the patient has been inactivated because of death).
"RTN","RORUPD51",96,0)
 . S IR="",UPDCNT=0
"RTN","RORUPD51",97,0)
 . F  S IR=$O(RORLST("DILIST","ID",IR))  Q:IR=""  D
"RTN","RORUPD51",98,0)
 . . S UPD=+$G(RORLST("DILIST","ID",IR,8))
"RTN","RORUPD51",99,0)
 . . S REGIEN=+$G(RORLST("DILIST","ID",IR,.02))
"RTN","RORUPD51",100,0)
 . . S CNT(REGIEN,UPD)=$G(CNT(REGIEN,UPD))+1
"RTN","RORUPD51",101,0)
 . . ;---
"RTN","RORUPD51",102,0)
 . . S:'UPD UPD='$G(RORLST("DILIST","ID",IR,2.2))
"RTN","RORUPD51",103,0)
 . . S:UPD UPDCNT=UPDCNT+1
"RTN","RORUPD51",104,0)
 . S:UPDCNT RC=$$UPDPTDEM(PATIEN)
"RTN","RORUPD51",105,0)
 D:RC'<0 UPDRCNT(.CNT)
"RTN","RORUPD51",106,0)
 Q RC
"RTN","RORUPD51",107,0)
 ;
"RTN","RORUPD51",108,0)
 ;***** UPDATES DEMOGRAPHIC DATA OF THE PATIENT (IF NECESSARY)
"RTN","RORUPD51",109,0)
 ;
"RTN","RORUPD51",110,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD51",111,0)
 ;
"RTN","RORUPD51",112,0)
 ; Return Values:
"RTN","RORUPD51",113,0)
 ;       <0  Error code
"RTN","RORUPD51",114,0)
 ;        0  Ok
"RTN","RORUPD51",115,0)
 ;
"RTN","RORUPD51",116,0)
UPDPTDEM(PATIEN) ;
"RTN","RORUPD51",117,0)
 N CF,DOD,IENS,RC,RORMSG,RORPAT
"RTN","RORUPD51",118,0)
 S IENS=PATIEN_",",CF=0
"RTN","RORUPD51",119,0)
 ;--- Try to lock the record of the ROR PATIENT file
"RTN","RORUPD51",120,0)
 L +^RORDATA(798.4,PATIEN):1
"RTN","RORUPD51",121,0)
 E  Q $$ERROR^RORERR(-11,"UPDPTDEM^RORUPD51",,PATIEN,"file #798.4")
"RTN","RORUPD51",122,0)
 D
"RTN","RORUPD51",123,0)
 . ;--- Compare demographic data
"RTN","RORUPD51",124,0)
 . S RC=$$PATDATA^RORUPD52(IENS,.RORPAT,IENS,.DOD)  Q:RC<0
"RTN","RORUPD51",125,0)
 . S:RC CF=1
"RTN","RORUPD51",126,0)
 . ;--- Mark registry records of the patient
"RTN","RORUPD51",127,0)
 . I CF  S RC=$$MARKREGS(PATIEN,$G(DOD))  Q:RC<0
"RTN","RORUPD51",128,0)
 . ;--- Update demographic data
"RTN","RORUPD51",129,0)
 . I CF,$D(RORPAT)>1  S RC=0  D  Q:RC<0
"RTN","RORUPD51",130,0)
 . . D FILE^DIE(,"RORPAT","RORMSG")  Q:'$G(DIERR)
"RTN","RORUPD51",131,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"UPDPTDEM^RORUPD51",PATIEN,798.4)
"RTN","RORUPD51",132,0)
 ;
"RTN","RORUPD51",133,0)
 L -^RORDATA(798.4,PATIEN)
"RTN","RORUPD51",134,0)
 Q 0
"RTN","RORUPD51",135,0)
 ;
"RTN","RORUPD51",136,0)
 ;***** UPDATES RECORD COUNTERS IN THE 'ROR REGISTRY PARAMETERS' FILE
"RTN","RORUPD51",137,0)
 ;
"RTN","RORUPD51",138,0)
 ; .CNT(         Reference to a local array containg registry
"RTN","RORUPD51",139,0)
 ;               record counters
"RTN","RORUPD51",140,0)
 ;   Registry#,
"RTN","RORUPD51",141,0)
 ;     0)        Number of inactive records
"RTN","RORUPD51",142,0)
 ;     1)        Number of active records
"RTN","RORUPD51",143,0)
 ;
"RTN","RORUPD51",144,0)
UPDRCNT(CNT) ;
"RTN","RORUPD51",145,0)
 N IENS,RC,REGIEN,RORFDA,RORMSG
"RTN","RORUPD51",146,0)
 S REGIEN=0
"RTN","RORUPD51",147,0)
 F  S REGIEN=$O(CNT(REGIEN))  Q:REGIEN=""  D
"RTN","RORUPD51",148,0)
 . S IENS=REGIEN_","
"RTN","RORUPD51",149,0)
 . S RORFDA(798.1,IENS,19.1)=$G(CNT(REGIEN,0))+$G(CNT(REGIEN,1))
"RTN","RORUPD51",150,0)
 . S RORFDA(798.1,IENS,19.2)=$G(CNT(REGIEN,1))
"RTN","RORUPD51",151,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUPD51",152,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD51",153,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"UPDRCNT^RORUPD51",798.1,IENS)
"RTN","RORUPD51",154,0)
 Q
"RTN","RORUPD52")
0^21^B11989001
"RTN","RORUPD52",1,0)
RORUPD52 ;HCIOFO/SG - UPDATE PATIENT'S DEMOGRAPHIC DATA (2) ; 11/4/02 10:25am
"RTN","RORUPD52",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORUPD52",3,0)
 ;
"RTN","RORUPD52",4,0)
 ; This routine uses the following IAs:
"RTN","RORUPD52",5,0)
 ;
"RTN","RORUPD52",6,0)
 ; #2701         $$GETICN^MPIF001  Gets ICN
"RTN","RORUPD52",7,0)
 ; #10061        6^VADPT
"RTN","RORUPD52",8,0)
 ;
"RTN","RORUPD52",9,0)
 Q
"RTN","RORUPD52",10,0)
 ;
"RTN","RORUPD52",11,0)
 ;***** LOAD DEMOGRAPHIC DATA FROM THE 'PATIENT' FILE
"RTN","RORUPD52",12,0)
 ;
"RTN","RORUPD52",13,0)
 ; DFN           Internal Entry Number in the PATIENT file
"RTN","RORUPD52",14,0)
 ;
"RTN","RORUPD52",15,0)
 ; .RES          Reference to a buffer for the data
"RTN","RORUPD52",16,0)
 ;
"RTN","RORUPD52",17,0)
 ;   RES(1,      Demographic and elegibility data
"RTN","RORUPD52",18,0)
 ;                 ^1: SSN                           .09
"RTN","RORUPD52",19,0)
 ;                 ^2: Date of Birth                 .03
"RTN","RORUPD52",20,0)
 ;                 ^3: Sex                           .02
"RTN","RORUPD52",21,0)
 ;                 ^4: Date of Death                 .351
"RTN","RORUPD52",22,0)
 ;                 ^5: Period of Service             .323
"RTN","RORUPD52",23,0)
 ;                 ^6: Service Connected?            .301
"RTN","RORUPD52",24,0)
 ;                 ^7: Service Connected Percentage  .302
"RTN","RORUPD52",25,0)
 ;                 ^8: ZIP+4                         .1112
"RTN","RORUPD52",26,0)
 ;                 ^9: ICN (with the checksum)       991.*
"RTN","RORUPD52",27,0)
 ;     "FL")     List of field numbers separated by the ";"
"RTN","RORUPD52",28,0)
 ;
"RTN","RORUPD52",29,0)
 ;   RES(2)      Race and ethnicity data
"RTN","RORUPD52",30,0)
 ;                 Race^Method^...^Ethnicity^Method^...
"RTN","RORUPD52",31,0)
 ;
"RTN","RORUPD52",32,0)
 ; Return Values:
"RTN","RORUPD52",33,0)
 ;       <0  Error code
"RTN","RORUPD52",34,0)
 ;        0  Ok
"RTN","RORUPD52",35,0)
 ;
"RTN","RORUPD52",36,0)
LOADDM(DFN,RES) ;
"RTN","RORUPD52",37,0)
 N I,J,VADM,VAEL,VAPA
"RTN","RORUPD52",38,0)
 S RES(1,"FL")=".09;.03;.02;.351;.323;.301;.302;.1112;991"
"RTN","RORUPD52",39,0)
 D 6^VADPT  F I=1,2  S RES(I)=""
"RTN","RORUPD52",40,0)
 ;--- Demographic and eligibility fields
"RTN","RORUPD52",41,0)
 F I=2,3,5,6  S RES(1)=RES(1)_U_$P($G(VADM(I)),U)
"RTN","RORUPD52",42,0)
 S $E(RES(1),1)=""  ; Remove the first "^"
"RTN","RORUPD52",43,0)
 S I=$G(VAEL(3))
"RTN","RORUPD52",44,0)
 S RES(1)=RES(1)_U_$P($G(VAEL(2)),U)_U_$S(I:"Y",1:"N")_U_$P(I,U,2)
"RTN","RORUPD52",45,0)
 S I=$$GETICN^MPIF001(DFN)
"RTN","RORUPD52",46,0)
 S RES(1)=RES(1)_U_$P($G(VAPA(6)),U,2)_U_$S(I'<0:I,1:"")
"RTN","RORUPD52",47,0)
 ;--- Race & Ethnicity
"RTN","RORUPD52",48,0)
 F I=11,12  S J=""  D
"RTN","RORUPD52",49,0)
 . F  S J=$O(VADM(I,J))  Q:J=""  D
"RTN","RORUPD52",50,0)
 . . S RES(2)=RES(2)_U_$P(VADM(I,J),U)_U_$P($G(VADM(I,J,1)),U)
"RTN","RORUPD52",51,0)
 S $E(RES(2),1)=""  ; Remove the first "^"
"RTN","RORUPD52",52,0)
 Q 0
"RTN","RORUPD52",53,0)
 ;
"RTN","RORUPD52",54,0)
 ;***** LOAD RATED DISABILITIES FROM THE 'PATIENT' FILE
"RTN","RORUPD52",55,0)
 ;
"RTN","RORUPD52",56,0)
 ; DFN           Internal Entry Number in the PATIENT file
"RTN","RORUPD52",57,0)
 ;
"RTN","RORUPD52",58,0)
 ; .RES          Reference to a buffer for the data
"RTN","RORUPD52",59,0)
 ;
"RTN","RORUPD52",60,0)
 ;   RES(3)      Rated disabilities data
"RTN","RORUPD52",61,0)
 ;                 Rated Disability^Disability %^Service Connected^...
"RTN","RORUPD52",62,0)
 ;
"RTN","RORUPD52",63,0)
 ; Return Values:
"RTN","RORUPD52",64,0)
 ;       <0  Error code
"RTN","RORUPD52",65,0)
 ;        0  Ok
"RTN","RORUPD52",66,0)
 ;
"RTN","RORUPD52",67,0)
LOADRD(DFN,RES) ;
"RTN","RORUPD52",68,0)
 N I  S RES(3)="",I=0
"RTN","RORUPD52",69,0)
 F  S I=$O(^DPT(DFN,.372,I))  Q:I'>0  D
"RTN","RORUPD52",70,0)
 . S RES(3)=RES(3)_U_$G(^DPT(DFN,.372,I,0))
"RTN","RORUPD52",71,0)
 S $E(RES(3),1)=""  ; Remove the first "^"
"RTN","RORUPD52",72,0)
 Q 0
"RTN","RORUPD52",73,0)
 ;
"RTN","RORUPD52",74,0)
 ;***** GETS AND PREPARES PATIENT'S DATA
"RTN","RORUPD52",75,0)
 ;
"RTN","RORUPD52",76,0)
 ; PATIENS       Patient IENS in the PATIENT file
"RTN","RORUPD52",77,0)
 ; .RORPAT       Reference to the FDA for field values
"RTN","RORUPD52",78,0)
 ; RORIENS       IENS of the record in the ROR PATIENT file
"RTN","RORUPD52",79,0)
 ; [.DOD]        Date of death is returned via this parameter
"RTN","RORUPD52",80,0)
 ;
"RTN","RORUPD52",81,0)
 ; Return Values:
"RTN","RORUPD52",82,0)
 ;       <0  Error code
"RTN","RORUPD52",83,0)
 ;        0  Patient data has not been changed
"RTN","RORUPD52",84,0)
 ;       >0  Data has been changed
"RTN","RORUPD52",85,0)
 ;
"RTN","RORUPD52",86,0)
PATDATA(PATIENS,RORPAT,RORIENS,DOD) ;
"RTN","RORUPD52",87,0)
 N BUF,DIFCNT,N1,NODE,RC,RORDFN
"RTN","RORUPD52",88,0)
 S:PATIENS'["," PATIENS=PATIENS_","
"RTN","RORUPD52",89,0)
 S:RORIENS'["," RORIENS=RORIENS_","
"RTN","RORUPD52",90,0)
 S RORDFN=$S(RORIENS?1.N1",":+RORIENS,1:-1)
"RTN","RORUPD52",91,0)
 S DOD="",(DIFCNT,RC)=0
"RTN","RORUPD52",92,0)
 ;--- Load demographic data from the PATIENT file
"RTN","RORUPD52",93,0)
 S RC=$$LOADDM(+PATIENS,.NODE)  Q:RC<0 RC
"RTN","RORUPD52",94,0)
 S DOD=$P(NODE(1),U,4),N1=$L(NODE(1,"FL"),";")
"RTN","RORUPD52",95,0)
 ;--- Demographic and eligibility fields
"RTN","RORUPD52",96,0)
 S BUF=$P($G(^RORDATA(798.4,RORDFN,1)),U,1,N1)
"RTN","RORUPD52",97,0)
 I NODE(1)'=BUF  D
"RTN","RORUPD52",98,0)
 . N CF,FLD,I
"RTN","RORUPD52",99,0)
 . F I=1:1:N1  S FLD=+$P(NODE(1,"FL"),";",I)  D:FLD>0
"RTN","RORUPD52",100,0)
 . . K RORPAT(798.4,RORIENS,FLD)
"RTN","RORUPD52",101,0)
 . . ;--- Update the field if necessary
"RTN","RORUPD52",102,0)
 . . S OLDVAL=$P(BUF,U,I)  Q:$P(NODE(1),U,I)=OLDVAL
"RTN","RORUPD52",103,0)
 . . S RORPAT(798.4,RORIENS,FLD)=$P(NODE(1),U,I),CF=1
"RTN","RORUPD52",104,0)
 . . ;--- Save previous values of the special fields
"RTN","RORUPD52",105,0)
 . . I FLD=.09  D  Q
"RTN","RORUPD52",106,0)
 . . . S RORPAT(798.4,RORIENS,10.1)=OLDVAL  ; Old SSN
"RTN","RORUPD52",107,0)
 . . I FLD=991.01  D  Q
"RTN","RORUPD52",108,0)
 . . . S RORPAT(798.4,RORIENS,10.2)=OLDVAL  ; Old ICN
"RTN","RORUPD52",109,0)
 . I $G(CF)  S DIFCNT=DIFCNT+1  Q
"RTN","RORUPD52",110,0)
 . S $P(^RORDATA(798.4,RORDFN,1),U,N1)=$P(BUF,U,N1)
"RTN","RORUPD52",111,0)
 ;--- Race & Ethnicity
"RTN","RORUPD52",112,0)
 I NODE(2)'=$G(^RORDATA(798.4,RORDFN,2))  D
"RTN","RORUPD52",113,0)
 . S DIFCNT=DIFCNT+1,RORPAT(798.4,RORIENS,2)=NODE(2)
"RTN","RORUPD52",114,0)
 K NODE
"RTN","RORUPD52",115,0)
 ;--- Rated disabilities
"RTN","RORUPD52",116,0)
 S RC=$$LOADRD(+PATIENS,.NODE)  Q:RC<0 RC
"RTN","RORUPD52",117,0)
 I NODE(3)'=$G(^RORDATA(798.4,RORDFN,3))  D
"RTN","RORUPD52",118,0)
 . S DIFCNT=DIFCNT+1,RORPAT(798.4,RORIENS,.3721)=NODE(3)
"RTN","RORUPD52",119,0)
 Q $S(RC<0:RC,1:DIFCNT)
"RTN","RORUPR1")
0^29^B71855148
"RTN","RORUPR1",1,0)
RORUPR1 ;HCIOFO/SG - SELECTION RULES PREPARATION  ; 11/1/02 10:49am
"RTN","RORUPR1",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3**;May 14, 2002
"RTN","RORUPR1",3,0)
 ;
"RTN","RORUPR1",4,0)
 Q
"RTN","RORUPR1",5,0)
 ;
"RTN","RORUPR1",6,0)
 ;***** MARKS PARENT FILES TO PROCESS
"RTN","RORUPR1",7,0)
 ;
"RTN","RORUPR1",8,0)
 ; This function analyzes file dependencies defined by the 'ROR
"RTN","RORUPR1",9,0)
 ; METADATA' file and guaranties that all necessary files will be
"RTN","RORUPR1",10,0)
 ; processed during the registry update.
"RTN","RORUPR1",11,0)
 ;
"RTN","RORUPR1",12,0)
FILETREE() ;
"RTN","RORUPR1",13,0)
 N FILE,PF,RC
"RTN","RORUPR1",14,0)
 S FILE="",RC=0
"RTN","RORUPR1",15,0)
 F  S FILE=$O(RORUPD("SR",FILE))  Q:FILE=""  D  Q:RC<0
"RTN","RORUPR1",16,0)
 . S PF=+FILE,RC=0
"RTN","RORUPR1",17,0)
 . ;--- Follow a path that leads from this file to
"RTN","RORUPR1",18,0)
 . ;    the root of the "file-processing tree".
"RTN","RORUPR1",19,0)
 . F  D  Q:RC
"RTN","RORUPR1",20,0)
 . . ;--- Check if metadata for the file is defined
"RTN","RORUPR1",21,0)
 . . I '$D(^ROR(799.2,PF))  D  Q
"RTN","RORUPR1",22,0)
 . . . S RC=$$ERROR^RORERR(-63,"METADATA^RORUPR1",,,PF)
"RTN","RORUPR1",23,0)
 . . ;--- Get the number of the parent file
"RTN","RORUPR1",24,0)
 . . S PF=+$$GET1^DIQ(799.2,PF_",",1,"I",,"RORMSG")
"RTN","RORUPR1",25,0)
 . . I $G(DIERR)  D  Q
"RTN","RORUPR1",26,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,"METADATA^RORUPR1")
"RTN","RORUPR1",27,0)
 . . ;--- Stop if the root of the "file-processing tree" has been
"RTN","RORUPR1",28,0)
 . . ;    reached or the file is already marked for processing.
"RTN","RORUPR1",29,0)
 . . ;    Otherwise, mark the file and continue moving up.
"RTN","RORUPR1",30,0)
 . . I 'PF!$D(RORUPD("SR",PF))  S RC=1  Q
"RTN","RORUPR1",31,0)
 . . S RORUPD("SR",PF)=""
"RTN","RORUPR1",32,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1",33,0)
 ;
"RTN","RORUPR1",34,0)
 ;***** RETURNS LEVEL OF THE FILE IN 'THE FILE PROCESSING' TREE
"RTN","RORUPR1",35,0)
 ;
"RTN","RORUPR1",36,0)
 ; FILE          File number
"RTN","RORUPR1",37,0)
 ;
"RTN","RORUPR1",38,0)
FLEVEL(FILE) ;
"RTN","RORUPR1",39,0)
 N LEVEL
"RTN","RORUPR1",40,0)
 S LEVEL=1
"RTN","RORUPR1",41,0)
 F  S FILE=+$P($G(^ROR(799.2,FILE,0)),U,2)  Q:'FILE  S LEVEL=LEVEL+1
"RTN","RORUPR1",42,0)
 Q LEVEL
"RTN","RORUPR1",43,0)
 ;
"RTN","RORUPR1",44,0)
 ;***** LOADS AND PREPARES LAB SEARCH INDICATORS
"RTN","RORUPR1",45,0)
 ;
"RTN","RORUPR1",46,0)
 ; Return Values:
"RTN","RORUPR1",47,0)
 ;        0  Ok
"RTN","RORUPR1",48,0)
 ;       <0  Error code
"RTN","RORUPR1",49,0)
 ;
"RTN","RORUPR1",50,0)
LABSRCH() ;
"RTN","RORUPR1",51,0)
 N I,IND,IR,LRCODE,LSICNT,LSIEN,RC,RORBUF,RORMSG,TMP,VAL
"RTN","RORUPR1",52,0)
 K RORLRC
"RTN","RORUPR1",53,0)
 ;--- Browse through the list of Lab searches
"RTN","RORUPR1",54,0)
 S LSIEN="",RC=0
"RTN","RORUPR1",55,0)
 F  S LSIEN=$O(@RORUPDPI@(4,LSIEN))  Q:LSIEN=""  D  Q:RC<0
"RTN","RORUPR1",56,0)
 . S TMP=","_LSIEN_","
"RTN","RORUPR1",57,0)
 . D LIST^DIC(798.92,TMP,"@;.01;.02;1I;2",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",58,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"LABSRCH^RORUPR1")  Q:RC<0
"RTN","RORUPR1",59,0)
 . ;--- Browse through the list of search indicators
"RTN","RORUPR1",60,0)
 . S IR="",LSICNT=0
"RTN","RORUPR1",61,0)
 . F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D  Q:RC<0
"RTN","RORUPR1",62,0)
 . . K LRCODE
"RTN","RORUPR1",63,0)
 . . S LRCODE=$G(RORBUF("DILIST","ID",IR,.01))
"RTN","RORUPR1",64,0)
 . . I LRCODE>0  D  Q:RC<0  S LRCODE(LRCODE_"^LN")=""
"RTN","RORUPR1",65,0)
 . . . S LRCODE=$$LNCODE^RORUTL02(LRCODE)
"RTN","RORUPR1",66,0)
 . . . S:LRCODE<0 RC=LRCODE
"RTN","RORUPR1",67,0)
 . . S LRCODE=$G(RORBUF("DILIST","ID",IR,.02))
"RTN","RORUPR1",68,0)
 . . S:LRCODE>0 LRCODE(LRCODE_"^NLT")=""
"RTN","RORUPR1",69,0)
 . . M RORLRC("B")=LRCODE
"RTN","RORUPR1",70,0)
 . . ;--- Load a search indicator
"RTN","RORUPR1",71,0)
 . . S IND=$G(RORBUF("DILIST","ID",IR,1))  Q:IND'>0
"RTN","RORUPR1",72,0)
 . . S VAL=$G(RORBUF("DILIST","ID",IR,2))  Q:(IND>1)&(VAL="")
"RTN","RORUPR1",73,0)
 . . S LSICNT=LSICNT+1
"RTN","RORUPR1",74,0)
 . . S LRCODE=""
"RTN","RORUPR1",75,0)
 . . F  S LRCODE=$O(LRCODE(LRCODE))  Q:LRCODE=""  D
"RTN","RORUPR1",76,0)
 . . . S I=$O(@RORUPDPI@("LS",LRCODE,LSIEN,""),-1)+1
"RTN","RORUPR1",77,0)
 . . . S @RORUPDPI@("LS",LRCODE,LSIEN,I)=IND_U_VAL
"RTN","RORUPR1",78,0)
 . Q:(RC<0)!(LSICNT>0)
"RTN","RORUPR1",79,0)
 . ;--- Record a warning if no indicators are defined
"RTN","RORUPR1",80,0)
 . S TMP=$$GET1^DIQ(798.9,LSIEN_",",.01,,,"RORMSG")
"RTN","RORUPR1",81,0)
 . S TMP=$$ERROR^RORERR(-55,"LABSRCH^RORUPR1",,,TMP)
"RTN","RORUPR1",82,0)
 Q:RC<0 RC
"RTN","RORUPR1",83,0)
 ;--- Prepare a list of Lab result codes for GCPR^LA7QRY
"RTN","RORUPR1",84,0)
 S LRCODE=""
"RTN","RORUPR1",85,0)
 F IR=1:1  S LRCODE=$O(RORLRC("B",LRCODE))  Q:LRCODE=""  D
"RTN","RORUPR1",86,0)
 . S RORLRC(IR)=LRCODE
"RTN","RORUPR1",87,0)
 K RORLRC("B")
"RTN","RORUPR1",88,0)
 Q 0
"RTN","RORUPR1",89,0)
 ;
"RTN","RORUPR1",90,0)
 ;***** LOADS SELECTION RULES DATA
"RTN","RORUPR1",91,0)
 ;
"RTN","RORUPR1",92,0)
 ; .REGLST       Reference to a local array containing registry names
"RTN","RORUPR1",93,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUPR1",94,0)
 ;
"RTN","RORUPR1",95,0)
 ; Return Values:
"RTN","RORUPR1",96,0)
 ;        0  Ok
"RTN","RORUPR1",97,0)
 ;       <0  Error code
"RTN","RORUPR1",98,0)
 ;
"RTN","RORUPR1",99,0)
LOAD(REGLST) ;
"RTN","RORUPR1",100,0)
 N RORERRDL      ; Default error location
"RTN","RORUPR1",101,0)
 ;
"RTN","RORUPR1",102,0)
 N I,IENS,RC,REGIEN,REGNAME,RORBUF,RORMSG,RULENAME
"RTN","RORUPR1",103,0)
 D DFLTLOC^RORERR("LOAD^RORUPR1")  K RORUPD("LM1")
"RTN","RORUPR1",104,0)
 S REGNAME="",RC=0
"RTN","RORUPR1",105,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPR1",106,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUPR1",107,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=REGIEN  Q
"RTN","RORUPR1",108,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUPR1",109,0)
 . S @RORUPDPI@(2,REGIEN)=REGNAME
"RTN","RORUPR1",110,0)
 . ;--- Load selection rules
"RTN","RORUPR1",111,0)
 . K RORBUF  S IENS=","_REGIEN_","
"RTN","RORUPR1",112,0)
 . D LIST^DIC(798.13,IENS,"@;.01E","U",,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",113,0)
 . S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0
"RTN","RORUPR1",114,0)
 . S I=""
"RTN","RORUPR1",115,0)
 . F  S I=$O(RORBUF("DILIST","ID",I))  Q:I=""  D  Q:RC<0
"RTN","RORUPR1",116,0)
 . . S RULENAME=RORBUF("DILIST","ID",I,.01)
"RTN","RORUPR1",117,0)
 . . S RC=$$LOADRULE(RULENAME,REGIEN)
"RTN","RORUPR1",118,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1",119,0)
 ;
"RTN","RORUPR1",120,0)
 ;***** LOADS THE SELECTION RULE
"RTN","RORUPR1",121,0)
 ;
"RTN","RORUPR1",122,0)
 ; RULENAME      Name of the rule
"RTN","RORUPR1",123,0)
 ; REGIEN        Registry IEN
"RTN","RORUPR1",124,0)
 ; [LEVEL]       Level of the rule (O for top level rules)
"RTN","RORUPR1",125,0)
 ;
"RTN","RORUPR1",126,0)
 ; Return Values:
"RTN","RORUPR1",127,0)
 ;        0  Ok
"RTN","RORUPR1",128,0)
 ;       <0  Error code
"RTN","RORUPR1",129,0)
 ;
"RTN","RORUPR1",130,0)
LOADRULE(RULENAME,REGIEN,LEVEL) ;
"RTN","RORUPR1",131,0)
 N RORERRDL      ; Default error location
"RTN","RORUPR1",132,0)
 ;
"RTN","RORUPR1",133,0)
 ;--- Quit if the rule has already been loaded
"RTN","RORUPR1",134,0)
 I $D(@RORUPDPI@(3,RULENAME))  D  Q 0
"RTN","RORUPR1",135,0)
 . S @RORUPDPI@(3,RULENAME,2,REGIEN)=""
"RTN","RORUPR1",136,0)
 ;---
"RTN","RORUPR1",137,0)
 N DATELMT,DEPRLC,EXPR,FILE,I,IENS,RORBUF,RORMSG,RULIEN,TMP
"RTN","RORUPR1",138,0)
 D DFLTLOC^RORERR("LOADRULE^RORUPR1")
"RTN","RORUPR1",139,0)
 ;--- Load the rule data
"RTN","RORUPR1",140,0)
 D FIND^DIC(798.2,,"@;1;2I","X",RULENAME,2,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",141,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORUPR1",142,0)
 Q:$G(RORBUF("DILIST",0))<1 $$ERROR^RORERR(-3,,RULENAME)
"RTN","RORUPR1",143,0)
 Q:$G(RORBUF("DILIST",0))>1 $$ERROR^RORERR(-4,,RULENAME)
"RTN","RORUPR1",144,0)
 S RULIEN=+RORBUF("DILIST",2,1),IENS=","_RULIEN_","
"RTN","RORUPR1",145,0)
 S FILE=+RORBUF("DILIST","ID",1,2)
"RTN","RORUPR1",146,0)
 ;--- Put the rule data into the temporary global
"RTN","RORUPR1",147,0)
 S @RORUPDPI@(1,FILE,"S",RULENAME)=""
"RTN","RORUPR1",148,0)
 S @RORUPDPI@(3,RULENAME)=RULIEN_U_FILE_"^^"_'$G(LEVEL)
"RTN","RORUPR1",149,0)
 S RC=$$PARSER^RORUPEX(FILE,RORBUF("DILIST","ID",1,1),.EXPR)
"RTN","RORUPR1",150,0)
 Q:RC<0 RC
"RTN","RORUPR1",151,0)
 S @RORUPDPI@(3,RULENAME,1)=EXPR
"RTN","RORUPR1",152,0)
 S @RORUPDPI@(3,RULENAME,2,REGIEN)=""
"RTN","RORUPR1",153,0)
 M @RORUPDPI@(1,FILE,"F")=EXPR("F")
"RTN","RORUPR1",154,0)
 S:'$G(LEVEL) RORUPD("LM1",RULENAME)=""
"RTN","RORUPR1",155,0)
 M @RORUPDPI@(4)=EXPR("L")
"RTN","RORUPR1",156,0)
 ;--- Load the rules that this rule depends on
"RTN","RORUPR1",157,0)
 S DEPRLC=""
"RTN","RORUPR1",158,0)
 F  S DEPRLC=$O(EXPR("R",DEPRLC))  Q:DEPRLC=""  D  Q:RC<0
"RTN","RORUPR1",159,0)
 . S RC=$$LOADRULE(DEPRLC,REGIEN,$G(LEVEL)+1)
"RTN","RORUPR1",160,0)
 . S:RC'<0 @RORUPDPI@(3,RULENAME,3,DEPRLC)=""
"RTN","RORUPR1",161,0)
 Q:RC<0 RC
"RTN","RORUPR1",162,0)
 ;--- Load a list of additional data elements
"RTN","RORUPR1",163,0)
 K EXPR,RORBUF,RORMSG
"RTN","RORUPR1",164,0)
 D LIST^DIC(798.26,IENS,"@;.01I;1I",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",165,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORUPR1",166,0)
 S I=""
"RTN","RORUPR1",167,0)
 F  S I=$O(RORBUF("DILIST","ID",I))  Q:I=""  D
"RTN","RORUPR1",168,0)
 . S DATELMT=RORBUF("DILIST","ID",I,.01)
"RTN","RORUPR1",169,0)
 . S TMP=$G(RORBUF("DILIST","ID",I,1))  S:TMP="" TMP="EI"
"RTN","RORUPR1",170,0)
 . S:TMP["E" @RORUPDPI@(1,FILE,"F",DATELMT,"E")=""
"RTN","RORUPR1",171,0)
 . S:TMP["I" @RORUPDPI@(1,FILE,"F",DATELMT,"I")=""
"RTN","RORUPR1",172,0)
 Q 0
"RTN","RORUPR1",173,0)
 ;
"RTN","RORUPR1",174,0)
 ;***** LOADS AND PREPARES THE METADATA
"RTN","RORUPR1",175,0)
METADATA() ;
"RTN","RORUPR1",176,0)
 N API,DATELMT,DEFL,FILE,I,IENS,IS,PIF,RC,ROOT,RORBUF,RORMSG,TMP,VT
"RTN","RORUPR1",177,0)
 S RC=$$FILETREE()  Q:RC<0 RC
"RTN","RORUPR1",178,0)
 S DEFL="@;.02I;1I;4I;4.1;4.2;6I"
"RTN","RORUPR1",179,0)
 ;--- Load and process the metadata
"RTN","RORUPR1",180,0)
 S FILE="",RC=0
"RTN","RORUPR1",181,0)
 F  S FILE=$O(RORUPD("SR",FILE))  Q:FILE=""  D  Q:RC<0
"RTN","RORUPR1",182,0)
 . S IENS=","_FILE_",",PIF=$NA(@RORUPDPI@(1,FILE))
"RTN","RORUPR1",183,0)
 . ;--- Global root of the file
"RTN","RORUPR1",184,0)
 . S RORUPD("ROOT",FILE)=$$ROOT^DILFD(FILE,,1)
"RTN","RORUPR1",185,0)
 . ;--- Associate data elements with APIs
"RTN","RORUPR1",186,0)
 . S DATELMT=""
"RTN","RORUPR1",187,0)
 . F  S DATELMT=$O(@PIF@("F",DATELMT))  Q:DATELMT=""  D  Q:RC<0
"RTN","RORUPR1",188,0)
 . . ;--- Find and load defintion of the data element
"RTN","RORUPR1",189,0)
 . . K RORBUF,RORMSG
"RTN","RORUPR1",190,0)
 . . D FIND^DIC(799.22,IENS,DEFL,"X",DATELMT,,"C",,,"RORBUF","RORMSG")
"RTN","RORUPR1",191,0)
 . . I $G(DIERR)  D  Q
"RTN","RORUPR1",192,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,"METADATA^RORUPR1",,799.22,IENS)
"RTN","RORUPR1",193,0)
 . . ;--- Check if search on this element is supported
"RTN","RORUPR1",194,0)
 . . S API=+$G(RORBUF("DILIST","ID",1,1))
"RTN","RORUPR1",195,0)
 . . I 'API  D  Q
"RTN","RORUPR1",196,0)
 . . . S RC=$$ERROR^RORERR(-64,"METADATA^RORUPR1",,,FILE,DATELMT)
"RTN","RORUPR1",197,0)
 . . ;--- Store the field number (if necessary)
"RTN","RORUPR1",198,0)
 . . I API=1  D  S RORUPD("SR",FILE,"F",API,DATELMT)=TMP
"RTN","RORUPR1",199,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",1,6))
"RTN","RORUPR1",200,0)
 . . ;--- Associate the data element with the API
"RTN","RORUPR1",201,0)
 . . S VT=$G(RORBUF("DILIST","ID",1,4)),RC=0
"RTN","RORUPR1",202,0)
 . . F I="E","I"  I $D(@PIF@("F",DATELMT,I))  D  Q:RC<0
"RTN","RORUPR1",203,0)
 . . . ;--- Check if type of the requested value is supported
"RTN","RORUPR1",204,0)
 . . . I VT'[I  D  Q
"RTN","RORUPR1",205,0)
 . . . . S TMP=$$EXTERNAL^DILFD(799.22,4,,I,"RORMSG")
"RTN","RORUPR1",206,0)
 . . . . S RC=$$ERROR^RORERR(-65,"METADATA^RORUPR1",,,FILE,DATELMT,TMP)
"RTN","RORUPR1",207,0)
 . . . ;--- Add the API-Element pair to the list
"RTN","RORUPR1",208,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",1,$$VTFN(I)))
"RTN","RORUPR1",209,0)
 . . . S RORUPD("SR",FILE,"F",API,DATELMT,I)=TMP
"RTN","RORUPR1",210,0)
 . Q:RC<0
"RTN","RORUPR1",211,0)
 . ;--- Add required elements (if any) to the list
"RTN","RORUPR1",212,0)
 . K RORBUF,RORMSG
"RTN","RORUPR1",213,0)
 . D FIND^DIC(799.22,IENS,DEFL,"X",1,,"AR",,,"RORBUF","RORMSG")
"RTN","RORUPR1",214,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPR1",215,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"METADATA^RORUPR1",,799.22,IENS)
"RTN","RORUPR1",216,0)
 . S IS=""
"RTN","RORUPR1",217,0)
 . F  S IS=$O(RORBUF("DILIST","ID",IS))  Q:IS=""  D
"RTN","RORUPR1",218,0)
 . . S DATELMT=+$G(RORBUF("DILIST","ID",IS,.02))  Q:'DATELMT
"RTN","RORUPR1",219,0)
 . . S API=+$G(RORBUF("DILIST","ID",IS,1))        Q:'API
"RTN","RORUPR1",220,0)
 . . S VT=$G(RORBUF("DILIST","ID",IS,4))
"RTN","RORUPR1",221,0)
 . . F I="E","I"  D:VT[I
"RTN","RORUPR1",222,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",IS,$$VTFN(I)))
"RTN","RORUPR1",223,0)
 . . . S RORUPD("SR",FILE,"F",API,DATELMT,I)=TMP
"RTN","RORUPR1",224,0)
 . . ;--- Store the field number (if necessary)
"RTN","RORUPR1",225,0)
 . . I API=1  D  S RORUPD("SR",FILE,"F",API,DATELMT)=TMP
"RTN","RORUPR1",226,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",IS,6))
"RTN","RORUPR1",227,0)
 . ;--- Compile a list of fields (separated by ';') for the GETS^DIQ
"RTN","RORUPR1",228,0)
 . Q:$D(RORUPD("SR",FILE,"F",1))<10
"RTN","RORUPR1",229,0)
 . S (DATELMT,RORBUF)=""
"RTN","RORUPR1",230,0)
 . F  S DATELMT=$O(RORUPD("SR",FILE,"F",1,DATELMT))  Q:DATELMT=""  D
"RTN","RORUPR1",231,0)
 . . S TMP=+$G(RORUPD("SR",FILE,"F",1,DATELMT))
"RTN","RORUPR1",232,0)
 . . S:TMP>0 RORBUF=RORBUF_";"_TMP
"RTN","RORUPR1",233,0)
 . S RORUPD("SR",FILE,"F",1)=$S(RORBUF'="":$P(RORBUF,";",2,999),1:"")
"RTN","RORUPR1",234,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1",235,0)
 ;
"RTN","RORUPR1",236,0)
 ;***** RETURNS FIELD NUMBER OF ADDITIONAL DATA
"RTN","RORUPR1",237,0)
VTFN(VT) ;
"RTN","RORUPR1",238,0)
 Q $S(VT="E":4.1,1:4.2)
"RTN","RORUTL01")
0^1^B45944047
"RTN","RORUTL01",1,0)
RORUTL01 ;HCIOFO/SG - UTILITIES  ; 11/26/02 3:23pm
"RTN","RORUTL01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**3**;May 14, 2002
"RTN","RORUTL01",3,0)
 ;
"RTN","RORUTL01",4,0)
 ; This routine uses the following IAs:
"RTN","RORUTL01",5,0)
 ;
"RTN","RORUTL01",6,0)
 ; #3301         Access to the .6 field of the file #2
"RTN","RORUTL01",7,0)
 ; #3744         $$TESTPAT^VADPT
"RTN","RORUTL01",8,0)
 ; #10035        Access to the .01 and .09 fields of the file #2
"RTN","RORUTL01",9,0)
 ; #10038        Access to the HOLIDAY file (supported)
"RTN","RORUTL01",10,0)
 Q
"RTN","RORUTL01",11,0)
 ;
"RTN","RORUTL01",12,0)
 ;***** SENDS ALERT TO REGISTRY COORDINATORS
"RTN","RORUTL01",13,0)
 ;
"RTN","RORUTL01",14,0)
 ; [.]REGLST     Either name of the registry or reference to a local
"RTN","RORUTL01",15,0)
 ;               array containing registry names as subscripts and
"RTN","RORUTL01",16,0)
 ;               optional registry IENs as values
"RTN","RORUTL01",17,0)
 ;
"RTN","RORUTL01",18,0)
 ; MSG           Text of the message or negative error code. The '^'
"RTN","RORUTL01",19,0)
 ;               characters are replaced with spaces in the text.
"RTN","RORUTL01",20,0)
 ;
"RTN","RORUTL01",21,0)
 ; [XQAROU]      Indicates a ROUTINE or TAG^ROUTINE to run when
"RTN","RORUTL01",22,0)
 ;               the alert is processed
"RTN","RORUTL01",23,0)
 ;
"RTN","RORUTL01",24,0)
 ; [XQADATA]     Use this to store a package-specific data string,
"RTN","RORUTL01",25,0)
 ;               in any format
"RTN","RORUTL01",26,0)
 ;
"RTN","RORUTL01",27,0)
 ; [PATIEN]      Patient IEN
"RTN","RORUTL01",28,0)
 ;
"RTN","RORUTL01",29,0)
 ; [ARG2-ARG5]   Optional parameters as for the $$ERROR^RORERR
"RTN","RORUTL01",30,0)
 ;
"RTN","RORUTL01",31,0)
ALERT(REGLST,MSG,XQAROU,XQADATA,PATIEN,ARG2,ARG3,ARG4,ARG5) ;
"RTN","RORUTL01",32,0)
 N IR,RC,REGIEN,REGNAME,RORBUF,RORMSG,TMP,XQA,XQAFLG,XQAMSG
"RTN","RORUTL01",33,0)
 ;--- Prepare a list of coordinators
"RTN","RORUTL01",34,0)
 S:$D(REGLST)=1 REGLST(REGLST)=""
"RTN","RORUTL01",35,0)
 S REGNAME="",RC=0
"RTN","RORUTL01",36,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D
"RTN","RORUTL01",37,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUTL01",38,0)
 . I REGIEN'>0  D  Q:REGIEN'>0
"RTN","RORUTL01",39,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUTL01",40,0)
 . ;--- Load a list of coordinators from the registry parameters
"RTN","RORUTL01",41,0)
 . S TMP=","_REGIEN_","
"RTN","RORUTL01",42,0)
 . D LIST^DIC(798.114,TMP,"@;.01I","U",,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL01",43,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"ALERT^RORUTL01")  Q:RC<0
"RTN","RORUTL01",44,0)
 . S IR=""
"RTN","RORUTL01",45,0)
 . F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D
"RTN","RORUTL01",46,0)
 . . S TMP=+$G(RORBUF("DILIST","ID",IR,.01))  S:TMP>0 XQA(TMP)=""
"RTN","RORUTL01",47,0)
 Q:$D(XQA)<10
"RTN","RORUTL01",48,0)
 ;--- Get text of the error message (if necessary)
"RTN","RORUTL01",49,0)
 I +MSG=MSG  Q:MSG'<0  D
"RTN","RORUTL01",50,0)
 . S MSG=$$MSG^RORERR20(+MSG,,.PATIEN,.ARG2,.ARG3,.ARG4,.ARG5)
"RTN","RORUTL01",51,0)
 S MSG=$TR(MSG,"^"," "),XQAMSG="ROR: ",TMP=70-$L(XQAMSG)-3
"RTN","RORUTL01",52,0)
 S XQAMSG=XQAMSG_$S($L(MSG)>TMP:$E(MSG,1,TMP)_"...",1:MSG)
"RTN","RORUTL01",53,0)
 ;--- Setup default alert processing routine
"RTN","RORUTL01",54,0)
 I $G(XQAROU)="",$G(XQADATA)=""  D
"RTN","RORUTL01",55,0)
 . S XQADATA=$E(MSG,1,78)_U_$G(PATIEN)
"RTN","RORUTL01",56,0)
 . S REGNAME=""
"RTN","RORUTL01",57,0)
 . F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D
"RTN","RORUTL01",58,0)
 . . S XQADATA=XQADATA_U_REGNAME
"RTN","RORUTL01",59,0)
 . S XQAROU="ALERTRTN^RORUTL01"
"RTN","RORUTL01",60,0)
 ;--- Send the alert
"RTN","RORUTL01",61,0)
 S XQAFLG="D"  D SETUP^XQALERT
"RTN","RORUTL01",62,0)
 Q
"RTN","RORUTL01",63,0)
 ;
"RTN","RORUTL01",64,0)
 ;***** DEFAULT ALERT PROCESSING ROUTINE
"RTN","RORUTL01",65,0)
 ;
"RTN","RORUTL01",66,0)
 ; XQADATA       Alert data
"RTN","RORUTL01",67,0)
 ;                 ^1: Message
"RTN","RORUTL01",68,0)
 ;                 ^2: Patient DFN
"RTN","RORUTL01",69,0)
 ;                 ^3: Registry name
"RTN","RORUTL01",70,0)
 ;                     ...
"RTN","RORUTL01",71,0)
 ;                 ^N: Registry name
"RTN","RORUTL01",72,0)
 ;
"RTN","RORUTL01",73,0)
ALERTRTN ;
"RTN","RORUTL01",74,0)
 Q:$G(XQADATA)=""
"RTN","RORUTL01",75,0)
 N I,REGNAME
"RTN","RORUTL01",76,0)
 W !!,$P(XQADATA,"^"),!
"RTN","RORUTL01",77,0)
 W:$P(XQADATA,"^",2) "Patient DFN: ",$P(XQADATA,"^",2),!
"RTN","RORUTL01",78,0)
 W "Processed Registries",!
"RTN","RORUTL01",79,0)
 F I=3:1  S REGNAME=$P(XQADATA,"^",I)  Q:REGNAME=""  W ?3,REGNAME,!
"RTN","RORUTL01",80,0)
 Q
"RTN","RORUTL01",81,0)
 ;
"RTN","RORUTL01",82,0)
 ;***** INITIALIZES THE VARIABLES
"RTN","RORUTL01",83,0)
 ;
"RTN","RORUTL01",84,0)
 ; NAMESP        Namespace to kill in the ^TMP global
"RTN","RORUTL01",85,0)
 ;               (must start with "ROR")
"RTN","RORUTL01",86,0)
 ; [XPURGE]      Purge namespaced nodes in the ^XTMP global.
"RTN","RORUTL01",87,0)
 ;               The ^XTMP(NAMESP_$J) node is always killed.
"RTN","RORUTL01",88,0)
 ;
"RTN","RORUTL01",89,0)
INIT(NAMESP,XPURGE) ;
"RTN","RORUTL01",90,0)
 N I,L,NOW  K ^TMP($J)
"RTN","RORUTL01",91,0)
 S:$G(U)="" U="^"  S:'$G(DT) DT=$$DT^XLFDT
"RTN","RORUTL01",92,0)
 Q:$E($G(NAMESP),1,3)'="ROR"
"RTN","RORUTL01",93,0)
 ;--- Kill namespaced nodes in the ^TMP global
"RTN","RORUTL01",94,0)
 S I=NAMESP,L=$L(NAMESP)
"RTN","RORUTL01",95,0)
 F  K ^TMP(I,$J)  S I=$O(^TMP(I))  Q:$E(I,1,L)'=NAMESP
"RTN","RORUTL01",96,0)
 ;--- Purge old namespaced nodes in the ^XTMP global
"RTN","RORUTL01",97,0)
 K ^XTMP(NAMESP_$J)
"RTN","RORUTL01",98,0)
 D:$G(XPURGE)
"RTN","RORUTL01",99,0)
 . S NOW=$$NOW^XLFDT,I=NAMESP,L=$L(NAMESP)
"RTN","RORUTL01",100,0)
 . F  D  S I=$O(^XTMP(I))  Q:$E(I,1,L)'=NAMESP
"RTN","RORUTL01",101,0)
 . . K:$G(^XTMP(I,0))<NOW ^XTMP(I)
"RTN","RORUTL01",102,0)
 Q
"RTN","RORUTL01",103,0)
 ;
"RTN","RORUTL01",104,0)
 ;***** INVERTS THE DATE
"RTN","RORUTL01",105,0)
 ;
"RTN","RORUTL01",106,0)
 ; DATE          Date in FileMan format
"RTN","RORUTL01",107,0)
 ; [MODE]        Mode of inversion
"RTN","RORUTL01",108,0)
 ;                 1  Strip the time BEFORE inversion
"RTN","RORUTL01",109,0)
 ;                 2  Strip the time AFTER inversion
"RTN","RORUTL01",110,0)
 ;                 3  Do not invert the time
"RTN","RORUTL01",111,0)
 ;
"RTN","RORUTL01",112,0)
INVDATE(DATE,MODE) ;
"RTN","RORUTL01",113,0)
 Q:$G(MODE)=1 9999999-$P(DATE,".")
"RTN","RORUTL01",114,0)
 Q:$G(MODE)=2 $P(9999999-DATE,".")
"RTN","RORUTL01",115,0)
 I $G(MODE)=3  Q:$P(DATE,".",2) (9999999-$P(DATE,"."))_"."_+$P(DATE,".",2)
"RTN","RORUTL01",116,0)
 Q 9999999-DATE
"RTN","RORUTL01",117,0)
 ;
"RTN","RORUTL01",118,0)
 ;***** RETURNS CODE AND TEXT OF THE ITEM IN THE FILE #799.1
"RTN","RORUTL01",119,0)
 ;
"RTN","RORUTL01",120,0)
 ; ITEMIEN       IEN of the item
"RTN","RORUTL01",121,0)
 ; [.TEXT]       Text of the item is returned via this parameter
"RTN","RORUTL01",122,0)
 ;
"RTN","RORUTL01",123,0)
 ; Return Values:
"RTN","RORUTL01",124,0)
 ;       <0  Error code
"RTN","RORUTL01",125,0)
 ;       ""  Code is not available
"RTN","RORUTL01",126,0)
 ;       >0  Code of the item
"RTN","RORUTL01",127,0)
 ;
"RTN","RORUTL01",128,0)
ITEMCODE(ITEMIEN,TEXT) ;
"RTN","RORUTL01",129,0)
 S TEXT=""  Q:ITEMIEN'>0 ""
"RTN","RORUTL01",130,0)
 Q:'$D(^ROR(799.1,+ITEMIEN,0)) ""
"RTN","RORUTL01",131,0)
 N IENS,RC,RORBUF,RORMSG
"RTN","RORUTL01",132,0)
 S IENS=(+ITEMIEN)_","
"RTN","RORUTL01",133,0)
 D GETS^DIQ(799.1,IENS,".01;.04",,"RORBUF","RORMSG")
"RTN","RORUTL01",134,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ITEMCODE^RORUTL01",,799.1,IENS)
"RTN","RORUTL01",135,0)
 S TEXT=$G(RORBUF(799.1,IENS,.01))
"RTN","RORUTL01",136,0)
 Q $G(RORBUF(799.1,IENS,.04))
"RTN","RORUTL01",137,0)
 ;
"RTN","RORUTL01",138,0)
 ;***** RETURNS IEN AND TEXT OF THE ITEM IN THE FILE #799.1
"RTN","RORUTL01",139,0)
 ;
"RTN","RORUTL01",140,0)
 ; TYPE          Type of the item
"RTN","RORUTL01",141,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL01",142,0)
 ; CODE          Code of the item
"RTN","RORUTL01",143,0)
 ; [.TEXT]       Text of the item is returned via this parameter
"RTN","RORUTL01",144,0)
 ;
"RTN","RORUTL01",145,0)
 ; Return Values:
"RTN","RORUTL01",146,0)
 ;       <0  Error code
"RTN","RORUTL01",147,0)
 ;       >0  IEN of the item
"RTN","RORUTL01",148,0)
 ;
"RTN","RORUTL01",149,0)
ITEMIEN(TYPE,REGIEN,CODE,TEXT) ;
"RTN","RORUTL01",150,0)
 N RC,RORBUF,RORMSG,SRCHVAL
"RTN","RORUTL01",151,0)
 S TEXT="",SRCHVAL(1)=+TYPE,SRCHVAL(2)=+REGIEN,SRCHVAL(3)=+CODE
"RTN","RORUTL01",152,0)
 D FIND^DIC(799.1,,"@;.01","QX",.SRCHVAL,2,"KEY",,,"RORBUF","RORMSG")
"RTN","RORUTL01",153,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ITEMIEN^RORUTL01",,799.1)
"RTN","RORUTL01",154,0)
 S RC=+$G(RORBUF("DILIST",0))
"RTN","RORUTL01",155,0)
 S:RC=1 TEXT=$G(RORBUF("DILIST","ID",1,.01))
"RTN","RORUTL01",156,0)
 Q $S(RC<1:-80,RC>1:-81,1:+RORBUF("DILIST",2,1))
"RTN","RORUTL01",157,0)
 ;
"RTN","RORUTL01",158,0)
 ;***** RETURNS A LIST OF ITEMS FROM THE FILE #799.1
"RTN","RORUTL01",159,0)
 ;
"RTN","RORUTL01",160,0)
 ; TYPE          Type of the items:
"RTN","RORUTL01",161,0)
 ;                 1  Reason for inactivation
"RTN","RORUTL01",162,0)
 ;                 2  Supporting evidence
"RTN","RORUTL01",163,0)
 ;
"RTN","RORUTL01",164,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL01",165,0)
 ;
"RTN","RORUTL01",166,0)
 ; .ROR8DST      Reference to a destination array.
"RTN","RORUTL01",167,0)
 ;               Items are returned into this array in the following
"RTN","RORUTL01",168,0)
 ;               format: ROR8DST(ItemCode)=ItemIEN^ItemText
"RTN","RORUTL01",169,0)
 ;
"RTN","RORUTL01",170,0)
 ; [CDT]         "Current" Date/Time (NOW by default)
"RTN","RORUTL01",171,0)
 ;
"RTN","RORUTL01",172,0)
 ;               If this date/time is equal or later that the
"RTN","RORUTL01",173,0)
 ;               inactivation date from the item record (only if
"RTN","RORUTL01",174,0)
 ;               there is any) then the item is considered inactive
"RTN","RORUTL01",175,0)
 ;               and will be skipped.
"RTN","RORUTL01",176,0)
 ;
"RTN","RORUTL01",177,0)
 ;               To include both active and inactive items in the
"RTN","RORUTL01",178,0)
 ;               list, pass a negative number as the value of this
"RTN","RORUTL01",179,0)
 ;               parameter.
"RTN","RORUTL01",180,0)
 ;
"RTN","RORUTL01",181,0)
 ; Return Values:
"RTN","RORUTL01",182,0)
 ;       <0  Error code
"RTN","RORUTL01",183,0)
 ;        0  Ok
"RTN","RORUTL01",184,0)
 ;
"RTN","RORUTL01",185,0)
ITEMLIST(TYPE,REGIEN,ROR8DST,CDT) ;
"RTN","RORUTL01",186,0)
 N CODE,IEN,IENS,INCTVDT,NODE,RC,RORBUF,RORMSG
"RTN","RORUTL01",187,0)
 S NODE=$NA(^ROR(799.1,"KEY",TYPE,REGIEN))  K ROR8DST
"RTN","RORUTL01",188,0)
 S:'$G(CDT) CDT=$$NOW^XLFDT
"RTN","RORUTL01",189,0)
 ;--- Load the active list items
"RTN","RORUTL01",190,0)
 S CODE="",RC=0
"RTN","RORUTL01",191,0)
 F  S CODE=$O(@NODE@(CODE))  Q:CODE=""  D  Q:RC<0
"RTN","RORUTL01",192,0)
 . S IEN=$O(@NODE@(CODE,""))  Q:'IEN
"RTN","RORUTL01",193,0)
 . S IENS=IEN_","
"RTN","RORUTL01",194,0)
 . ;--- Load text and inactivation date
"RTN","RORUTL01",195,0)
 . D GETS^DIQ(799.1,IENS,".01;1","IE","RORBUF","RORMSG")
"RTN","RORUTL01",196,0)
 . I $G(DIERR)  D  Q
"RTN","RORUTL01",197,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"ITEMLIST^RORUTL01",,799.1,IENS)
"RTN","RORUTL01",198,0)
 . ;--- Skip inactive items
"RTN","RORUTL01",199,0)
 . S INCTVDT=$G(RORBUF(799.1,IENS,1,"I"))
"RTN","RORUTL01",200,0)
 . I INCTVDT>0  Q:CDT'<INCTVDT
"RTN","RORUTL01",201,0)
 . ;--- Create a record in the destination array
"RTN","RORUTL01",202,0)
 . S ROR8DST(CODE)=IEN_U_$G(RORBUF(799.1,IENS,.01,"E"))
"RTN","RORUTL01",203,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL01",204,0)
 ;
"RTN","RORUTL01",205,0)
 ;***** CHECKS IF THE PATIENT IS A TEST ONE
"RTN","RORUTL01",206,0)
 ;
"RTN","RORUTL01",207,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL01",208,0)
 ;
"RTN","RORUTL01",209,0)
 ; Return Values:
"RTN","RORUTL01",210,0)
 ;        0  The patient is NOT a test patient
"RTN","RORUTL01",211,0)
 ;        1  The patient IS a test patient
"RTN","RORUTL01",212,0)
 ;
"RTN","RORUTL01",213,0)
TESTPAT(PATIEN) ;
"RTN","RORUTL01",214,0)
 Q:$$TESTPAT^VADPT(PATIEN) 1
"RTN","RORUTL01",215,0)
 Q:$E($G(^DPT(PATIEN,0)),1,2)="ZZ" 1  ; NAME starts with "ZZ"
"RTN","RORUTL01",216,0)
 Q 0
"RTN","RORUTL01",217,0)
 ;
"RTN","RORUTL01",218,0)
 ;***** VERIFY THE ENTRY POINT
"RTN","RORUTL01",219,0)
 ;
"RTN","RORUTL01",220,0)
 ; ENTRY         Entry point of the external MUMPS function
"RTN","RORUTL01",221,0)
 ; [RECERR]      Record the errors (do not record by default)
"RTN","RORUTL01",222,0)
 ;
"RTN","RORUTL01",223,0)
 ; Return Values:
"RTN","RORUTL01",224,0)
 ;       -18  Routine does not exist
"RTN","RORUTL01",225,0)
 ;       -17  Invalid entry point
"RTN","RORUTL01",226,0)
 ;         0  Ok
"RTN","RORUTL01",227,0)
 ;
"RTN","RORUTL01",228,0)
VERIFYEP(ENTRY,RECERR) ;
"RTN","RORUTL01",229,0)
 N X
"RTN","RORUTL01",230,0)
 S X="S Y="_ENTRY  D ^DIM
"RTN","RORUTL01",231,0)
 Q:'$D(X) $S($G(RECERR):$$ERROR^RORERR(-17,,,,ENTRY),1:-17)
"RTN","RORUTL01",232,0)
 S X=$P(ENTRY,U,2)
"RTN","RORUTL01",233,0)
 X ^%ZOSF("TEST")  E  Q $S($G(RECERR):$$ERROR^RORERR(-18,,,,X),1:-18)
"RTN","RORUTL01",234,0)
 Q 0
"RTN","RORUTL01",235,0)
 ;
"RTN","RORUTL01",236,0)
 ;***** CHECKS IF THE DATE IS A WORKING DAY
"RTN","RORUTL01",237,0)
 ;
"RTN","RORUTL01",238,0)
 ; DATE          The date to be checked
"RTN","RORUTL01",239,0)
 ;
"RTN","RORUTL01",240,0)
 ; Return Values:
"RTN","RORUTL01",241,0)
 ;        0  Weekend or Holiday
"RTN","RORUTL01",242,0)
 ;        1  Working day
"RTN","RORUTL01",243,0)
 ;
"RTN","RORUTL01",244,0)
WDCHK(DATE) ;
"RTN","RORUTL01",245,0)
 N DOW,RORMSG
"RTN","RORUTL01",246,0)
 ;--- Return zero if Saturday (6) or Sunday (0)
"RTN","RORUTL01",247,0)
 S DOW=$$DOW^XLFDT(DATE,1)  Q:'DOW!(DOW>5) 0
"RTN","RORUTL01",248,0)
 ;--- Return 1 if cannot be found in the HOLIDAY file
"RTN","RORUTL01",249,0)
 Q $$FIND1^DIC(40.5,,"QX",DATE\1,"B",,"RORMSG")'>0
"RTN","RORUTL01",250,0)
 ;
"RTN","RORUTL01",251,0)
 ;***** RETURNS THE NEXT WORKING DAY DATE
"RTN","RORUTL01",252,0)
 ;
"RTN","RORUTL01",253,0)
 ; DATE          The source date
"RTN","RORUTL01",254,0)
 ;
"RTN","RORUTL01",255,0)
 ; The function returns a date of the next working day.
"RTN","RORUTL01",256,0)
 ;
"RTN","RORUTL01",257,0)
WDNEXT(DATE) ;
"RTN","RORUTL01",258,0)
 N DOW,RORMSG
"RTN","RORUTL01",259,0)
 F  D  Q:$$FIND1^DIC(40.5,,"QX",DATE,"B",,"RORMSG")'>0
"RTN","RORUTL01",260,0)
 . S DOW=$$DOW^XLFDT(DATE,1)  S:'DOW DOW=7
"RTN","RORUTL01",261,0)
 . ;--- Get the next day and skip a weekend if necessary
"RTN","RORUTL01",262,0)
 . S DATE=$$FMADD^XLFDT(DATE,$S(DOW<5:1,1:8-DOW))
"RTN","RORUTL01",263,0)
 Q DATE
"RTN","RORUTL01",264,0)
 ;
"RTN","RORUTL01",265,0)
 ;***** CREATES A HEADER OF THE NODE IN THE ^XTMP GLOBAL
"RTN","RORUTL01",266,0)
 ;
"RTN","RORUTL01",267,0)
 ; SUBSCR        Subscript of the node in the ^XTMP global
"RTN","RORUTL01",268,0)
 ; [DKEEP]       Number of days to keep the node (1 by default)
"RTN","RORUTL01",269,0)
 ; [DESCR]       Description of the node
"RTN","RORUTL01",270,0)
 ;
"RTN","RORUTL01",271,0)
XTMPHDR(SUBSCR,DKEEP,DESCR) ;
"RTN","RORUTL01",272,0)
 N DATE  S DATE=$$DT^XLFDT  S:$G(DKEEP)'>0 DKEEP=1
"RTN","RORUTL01",273,0)
 S ^XTMP(SUBSCR,0)=$$FMADD^XLFDT(DATE,DKEEP)_U_DATE_U_$G(DESCR)
"RTN","RORUTL01",274,0)
 Q
"RTN","RORUTL01",275,0)
 ;
"RTN","RORUTL01",276,0)
 ;***** EMULATES AND EXTENDS THE ZWRITE COMMAND :-)
"RTN","RORUTL01",277,0)
 ;
"RTN","RORUTL01",278,0)
 ; ROR8NODE      Closed root of the sub-tree to display
"RTN","RORUTL01",279,0)
 ;               (either local array or global variable)
"RTN","RORUTL01",280,0)
 ; [TITLE]       Title of the output
"RTN","RORUTL01",281,0)
 ;
"RTN","RORUTL01",282,0)
ZW(ROR8NODE,TITLE) ;
"RTN","RORUTL01",283,0)
 Q:ROR8NODE=""  Q:'$D(@ROR8NODE)
"RTN","RORUTL01",284,0)
 N FLT,L,PI  W !
"RTN","RORUTL01",285,0)
 W:$G(TITLE)'="" TITLE,!!
"RTN","RORUTL01",286,0)
 W:$D(@ROR8NODE)#10 ROR8NODE_"="_@ROR8NODE,!
"RTN","RORUTL01",287,0)
 S L=$L(ROR8NODE)  S:$E(ROR8NODE,L)=")" L=L-1
"RTN","RORUTL01",288,0)
 S FLT=$E(ROR8NODE,1,L),PI=ROR8NODE
"RTN","RORUTL01",289,0)
 F  S PI=$Q(@PI)  Q:$E(PI,1,L)'=FLT  W PI_"="_@PI,!
"RTN","RORUTL01",290,0)
 Q
"RTN","RORUTL02")
0^10^B36984726
"RTN","RORUTL02",1,0)
RORUTL02 ;HCIOFO/SG - UTILITIES  ; 12/13/02 11:21am
"RTN","RORUTL02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3**;May 14, 2002
"RTN","RORUTL02",3,0)
 ;
"RTN","RORUTL02",4,0)
 ; This routine uses the following IAs:
"RTN","RORUTL02",5,0)
 ;
"RTN","RORUTL02",6,0)
 ; #2701         $$GETICN^MPIF001 Gets ICN (supported)
"RTN","RORUTL02",7,0)
 ; #3556         $$GCPR^LA7QRY
"RTN","RORUTL02",8,0)
 ; #3557         Access to the field .01 and x-ref "B"
"RTN","RORUTL02",9,0)
 ;               of the file 95.3
"RTN","RORUTL02",10,0)
 ; #3646         $$EMPL^DGSEC4
"RTN","RORUTL02",11,0)
 ; #10035        Access to the field #.09 of the file #2
"RTN","RORUTL02",12,0)
 ;
"RTN","RORUTL02",13,0)
 Q
"RTN","RORUTL02",14,0)
 ;
"RTN","RORUTL02",15,0)
 ;***** CREATES A LIST OF ACTIVE REGISTRIES
"RTN","RORUTL02",16,0)
 ;
"RTN","RORUTL02",17,0)
 ; .SRCLST       A source list of registry names (as subscripts)
"RTN","RORUTL02",18,0)
 ; .DSTLST(      A list of names and IENs of active registries
"RTN","RORUTL02",19,0)
 ;   RegName)    Registry IEN
"RTN","RORUTL02",20,0)
 ;
"RTN","RORUTL02",21,0)
 ; Return values:
"RTN","RORUTL02",22,0)
 ;       <0  Error code
"RTN","RORUTL02",23,0)
 ;        0  Ok
"RTN","RORUTL02",24,0)
 ;
"RTN","RORUTL02",25,0)
 ; The function stores names and IENs of those registries from the
"RTN","RORUTL02",26,0)
 ; source list which are active and not awaiting acknowledgements
"RTN","RORUTL02",27,0)
 ; into a local variable passed as the second parameter.
"RTN","RORUTL02",28,0)
 ;
"RTN","RORUTL02",29,0)
 ; Moreover, it records corresponding messages about skipped
"RTN","RORUTL02",30,0)
 ; registries to the current open log.
"RTN","RORUTL02",31,0)
 ;
"RTN","RORUTL02",32,0)
ARLST(SRCLST,DSTLST) ;
"RTN","RORUTL02",33,0)
 N INFO,RC,REGIEN,REGNAME,RORBUF,TMP  K DSTLST
"RTN","RORUTL02",34,0)
 S REGNAME="",RC=0
"RTN","RORUTL02",35,0)
 F  S REGNAME=$O(SRCLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUTL02",36,0)
 . S REGIEN=$$REGIEN(REGNAME,"@;2.2I;11I",.RORBUF)
"RTN","RORUTL02",37,0)
 . I REGIEN'>0  D  Q                        ; Error
"RTN","RORUTL02",38,0)
 . . S RC=$$ERROR^RORERR(REGIEN,"ARLST^RORUTL02",REGNAME)
"RTN","RORUTL02",39,0)
 . I $G(RORBUF("DILIST","ID",1,11))  D  Q   ; Inactive
"RTN","RORUTL02",40,0)
 . . S TMP=$$ERROR^RORERR(-48,"ARLST^RORUTL02",,,REGNAME)
"RTN","RORUTL02",41,0)
 . I $G(RORBUF("DILIST","ID",1,2.2))  D  Q  ; Awaiting ACK
"RTN","RORUTL02",42,0)
 . . D TEXT^RORTXT(7980000.002,.INFO)
"RTN","RORUTL02",43,0)
 . . S TMP=$$ERROR^RORERR(-49,"ARLST^RORUTL02",.INFO,,REGNAME)
"RTN","RORUTL02",44,0)
 . . K INFO
"RTN","RORUTL02",45,0)
 . S DSTLST(REGNAME)=REGIEN
"RTN","RORUTL02",46,0)
 Q RC
"RTN","RORUTL02",47,0)
 ;
"RTN","RORUTL02",48,0)
 ;***** RETURNS A FULL ICN OF THE PATIENT
"RTN","RORUTL02",49,0)
 ;
"RTN","RORUTL02",50,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",51,0)
 ;
"RTN","RORUTL02",52,0)
 ; Return Values:
"RTN","RORUTL02",53,0)
 ;       <0  Error code
"RTN","RORUTL02",54,0)
 ;       ""  ICN has not been assigned
"RTN","RORUTL02",55,0)
 ;       >0  Patient ICN
"RTN","RORUTL02",56,0)
 ;
"RTN","RORUTL02",57,0)
ICN(PATIEN) ;
"RTN","RORUTL02",58,0)
 N ICN,L,TMP
"RTN","RORUTL02",59,0)
 S ICN=$$GETICN^MPIF001(PATIEN)
"RTN","RORUTL02",60,0)
 I ICN'>0  D  Q ""
"RTN","RORUTL02",61,0)
 . S TMP=$$ERROR^RORERR(-57,"ICN^RORUTL02",$P(ICN,U,2),PATIEN,+ICN,"$$GETICN^MPIF001")
"RTN","RORUTL02",62,0)
 ;--- Validate the checksum (just in case ;-)
"RTN","RORUTL02",63,0)
 S L=$L($P(ICN,"V",2))
"RTN","RORUTL02",64,0)
 Q $S(L<6:$P(ICN,"V")_"V"_$E("000000",1,6-L)_$P(ICN,"V",2),1:ICN)
"RTN","RORUTL02",65,0)
 ;
"RTN","RORUTL02",66,0)
 ;I L<6  D  Q $P(ICN,"V")_"V"_$E("000000",1,6-L)_$P(ICN,"V",2)
"RTN","RORUTL02",67,0)
 ;. S TMP=$$ERROR^RORERR(-59,"ICN^RORUTL02",,PATIEN)
"RTN","RORUTL02",68,0)
 ;Q ICN
"RTN","RORUTL02",69,0)
 ;
"RTN","RORUTL02",70,0)
 ;***** LOADS THE LAB RESULTS
"RTN","RORUTL02",71,0)
 ;
"RTN","RORUTL02",72,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",73,0)
 ; SDT           Start date of the results
"RTN","RORUTL02",74,0)
 ; EDT           End date of the results
"RTN","RORUTL02",75,0)
 ;
"RTN","RORUTL02",76,0)
 ; Return values:
"RTN","RORUTL02",77,0)
 ;       <0  Error code
"RTN","RORUTL02",78,0)
 ;        0  Ok
"RTN","RORUTL02",79,0)
 ;
"RTN","RORUTL02",80,0)
 ; The function loads Lab results into the ^TMP("RORTMP",$J).
"RTN","RORUTL02",81,0)
 ;
"RTN","RORUTL02",82,0)
LABRSLTS(PATIEN,SDT,EDT) ;
"RTN","RORUTL02",83,0)
 N DST,H7CH,RC,RORMSG,TMP
"RTN","RORUTL02",84,0)
 S DST=$NA(^TMP("RORTMP",$J))  K @DST
"RTN","RORUTL02",85,0)
 Q:$D(RORLRC)<10 0
"RTN","RORUTL02",86,0)
 ;--- Get the Patient ID (ICN or SSN)
"RTN","RORUTL02",87,0)
 S PTID=$$PTID(PATIEN)  Q:PTID<0 PTID
"RTN","RORUTL02",88,0)
 ;--- Get the Lab data
"RTN","RORUTL02",89,0)
 S H7CH=$G(RORHL("FS"))_$G(RORHL("ECH"))
"RTN","RORUTL02",90,0)
 S RC=$$GCPR^LA7QRY(PTID,SDT,EDT,.RORLRC,"*",.RORMSG,DST,H7CH)
"RTN","RORUTL02",91,0)
 I $D(RORMSG)>1  D
"RTN","RORUTL02",92,0)
 . N ERR,I,LST
"RTN","RORUTL02",93,0)
 . S (ERR,LST)=""
"RTN","RORUTL02",94,0)
 . F I=1:1  S ERR=$O(RORMSG(ERR))  Q:ERR=""  D
"RTN","RORUTL02",95,0)
 . . S LST=LST_","_ERR,TMP=RORMSG(ERR)
"RTN","RORUTL02",96,0)
 . . K RORMSG(ERR)  S RORMSG(I)=TMP
"RTN","RORUTL02",97,0)
 . S LST=$P(LST,",",2,999)  Q:(LST=3)!(LST=99)
"RTN","RORUTL02",98,0)
 . S RC=$$ERROR^RORERR(-27,"LABRSLTS^RORUTL02",.RORMSG,PATIEN)
"RTN","RORUTL02",99,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL02",100,0)
 ;
"RTN","RORUTL02",101,0)
 ;***** RETURNS THE LOINC CODE WITH THE CONTROL DIGIT
"RTN","RORUTL02",102,0)
 ;
"RTN","RORUTL02",103,0)
 ; LNCODE        LOINC code
"RTN","RORUTL02",104,0)
 ;
"RTN","RORUTL02",105,0)
 ; Besides adding a control digit to the LOINC code, the function
"RTN","RORUTL02",106,0)
 ; checks the code against the LAB LOINC file (#95.3).
"RTN","RORUTL02",107,0)
 ;
"RTN","RORUTL02",108,0)
 ; Return values:
"RTN","RORUTL02",109,0)
 ;       <0  Error code
"RTN","RORUTL02",110,0)
 ;       >0  LOINC code with the control digit
"RTN","RORUTL02",111,0)
 ;
"RTN","RORUTL02",112,0)
LNCODE(LNCODE) ;
"RTN","RORUTL02",113,0)
 N RC,RORBUF,RORMSG
"RTN","RORUTL02",114,0)
 D FIND^DIC(95.3,,"@;.01E","X",$P(LNCODE,"-"),2,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL02",115,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"LNCODE^RORUTL02",,95.3)
"RTN","RORUTL02",116,0)
 I $G(RORBUF("DILIST",0))<1  D  Q RC ; Non-existent code
"RTN","RORUTL02",117,0)
 . S RC=$$ERROR^RORERR(-29,"LNCODE^RORUTL02",,,LNCODE)
"RTN","RORUTL02",118,0)
 I $G(RORBUF("DILIST",0))>1  D  Q RC ; Duplicate records
"RTN","RORUTL02",119,0)
 . S RC=$$ERROR^RORERR(-30,"LNCODE^RORUTL02",,,LNCODE)
"RTN","RORUTL02",120,0)
 Q RORBUF("DILIST","ID",1,.01)
"RTN","RORUTL02",121,0)
 ;
"RTN","RORUTL02",122,0)
 ;***** LOCK/UNLOCK REGISTRIES BEING PROCESSED
"RTN","RORUTL02",123,0)
 ;
"RTN","RORUTL02",124,0)
 ; .REGLST       Reference to a local array containing registry names 
"RTN","RORUTL02",125,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUTL02",126,0)
 ; [MODE]        0 - Unlock (default), 1 - Lock
"RTN","RORUTL02",127,0)
 ; [TO]          LOCK timeout (3 sec by defualt)
"RTN","RORUTL02",128,0)
 ;
"RTN","RORUTL02",129,0)
 ; Return Values:
"RTN","RORUTL02",130,0)
 ;       <0  Error code
"RTN","RORUTL02",131,0)
 ;        0  Some of the registries has been locked by another job
"RTN","RORUTL02",132,0)
 ;        1  Ok
"RTN","RORUTL02",133,0)
 ;
"RTN","RORUTL02",134,0)
LOCKREG(REGLST,MODE,TO) ;
"RTN","RORUTL02",135,0)
 Q:$D(REGLST)<10 1
"RTN","RORUTL02",136,0)
 N ARG,LOCKLST,LT,REGIEN,REGNAME
"RTN","RORUTL02",137,0)
 S (REGNAME,LOCKLST)=""
"RTN","RORUTL02",138,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:REGIEN<0
"RTN","RORUTL02",139,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUTL02",140,0)
 . I REGIEN'>0  S REGIEN=$$REGIEN^RORUTL02(REGNAME)  Q:REGIEN'>0
"RTN","RORUTL02",141,0)
 . S LOCKLST=LOCKLST_","_$NA(^ROR(798.1,REGIEN))
"RTN","RORUTL02",142,0)
 Q:$G(REGIEN)<0 REGIEN
"RTN","RORUTL02",143,0)
 Q:LOCKLST="" 1
"RTN","RORUTL02",144,0)
 S ARG=$S($G(MODE):"+",1:"-")_"("_$P(LOCKLST,",",2,999)_")"
"RTN","RORUTL02",145,0)
 X "L "_ARG_":"_+$G(TO,3)_"  S LT=$T"
"RTN","RORUTL02",146,0)
 Q LT
"RTN","RORUTL02",147,0)
 ;
"RTN","RORUTL02",148,0)
 ;***** RETURNS A PATIENT ID (ICN OR SSN)
"RTN","RORUTL02",149,0)
 ;
"RTN","RORUTL02",150,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",151,0)
 ;
"RTN","RORUTL02",152,0)
 ; Return Values:
"RTN","RORUTL02",153,0)
 ;       <0  Error code
"RTN","RORUTL02",154,0)
 ;       ""  Neither ICN nor SSN has been assigned
"RTN","RORUTL02",155,0)
 ;       >0  Patient ICN (or SSN if ICN is not available)
"RTN","RORUTL02",156,0)
 ;
"RTN","RORUTL02",157,0)
PTID(PATIEN) ;
"RTN","RORUTL02",158,0)
 N L,PTID,RC,RORMSG
"RTN","RORUTL02",159,0)
 S PTID=$$GETICN^MPIF001(PATIEN)
"RTN","RORUTL02",160,0)
 I PTID>0  D  Q PTID
"RTN","RORUTL02",161,0)
 . ;--- Validate the checksum (just in case ;-)
"RTN","RORUTL02",162,0)
 . S L=$L($P(PTID,"V",2))  Q:L'<6
"RTN","RORUTL02",163,0)
 . ;S RC=$$ERROR^RORERR(-59,"PTID^RORUTL02",,PATIEN)
"RTN","RORUTL02",164,0)
 . S $P(PTID,"V",2)=$E("000000",1,6-L)_$P(PTID,"V",2)
"RTN","RORUTL02",165,0)
 ;--- Get SSN if ICN is not available
"RTN","RORUTL02",166,0)
 S PTID=$$GET1^DIQ(2,PATIEN_",",.09,,,"RORMSG")
"RTN","RORUTL02",167,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"PTID^RORUTL02",PATIEN,2)
"RTN","RORUTL02",168,0)
 Q PTID
"RTN","RORUTL02",169,0)
 ;
"RTN","RORUTL02",170,0)
 ;***** RETURNS IEN OF THE REGISTRY PARAMETERS
"RTN","RORUTL02",171,0)
 ;
"RTN","RORUTL02",172,0)
 ; REGNAME       Name of the registry
"RTN","RORUTL02",173,0)
 ; [FIELDS]      List of fields (separated by semicolons) to load
"RTN","RORUTL02",174,0)
 ; [.RORTRGT]    Reference to a local variable where field values will
"RTN","RORUTL02",175,0)
 ;               be stored by the FIND^DIC call
"RTN","RORUTL02",176,0)
 ;
"RTN","RORUTL02",177,0)
 ; Return Values:
"RTN","RORUTL02",178,0)
 ;       <0  Error code
"RTN","RORUTL02",179,0)
 ;       >0  Registry parameters IEN
"RTN","RORUTL02",180,0)
 ;
"RTN","RORUTL02",181,0)
REGIEN(REGNAME,FIELDS,RORTRGT) ;
"RTN","RORUTL02",182,0)
 N RC,REGIEN,RORMSG  K RORTRGT
"RTN","RORUTL02",183,0)
 D FIND^DIC(798.1,,"@;"_$G(FIELDS),"UX",REGNAME,2,"B",,,"RORTRGT","RORMSG")
"RTN","RORUTL02",184,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"REGIEN^RORUTL02",,798.1)
"RTN","RORUTL02",185,0)
 S RC=+$G(RORTRGT("DILIST",0))
"RTN","RORUTL02",186,0)
 Q $S(RC<1:-1,RC>1:-2,1:+RORTRGT("DILIST",2,1))
"RTN","RORUTL02",187,0)
 ;
"RTN","RORUTL02",188,0)
 ;***** RETURNS NUMBER OF RECORDS IN THE REGISTRY
"RTN","RORUTL02",189,0)
 ;
"RTN","RORUTL02",190,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL02",191,0)
 ; [.LOWIEN]     The smallest IEN will be returned via this parameter
"RTN","RORUTL02",192,0)
 ; [.HIGHIEN]    The biggest IEN will be returned via this parameter
"RTN","RORUTL02",193,0)
 ;
"RTN","RORUTL02",194,0)
 ; Return Values:
"RTN","RORUTL02",195,0)
 ;       <0  Error code
"RTN","RORUTL02",196,0)
 ;        0  The registry is empty
"RTN","RORUTL02",197,0)
 ;       >0  Number of records in the registry
"RTN","RORUTL02",198,0)
 ;
"RTN","RORUTL02",199,0)
REGSIZE(REGIEN,LOWIEN,HIGHIEN) ;
"RTN","RORUTL02",200,0)
 N I,NODE,NRE,RC,RORFDA,RORMSG
"RTN","RORUTL02",201,0)
 S NODE=$NA(^RORDATA(798,"AC",REGIEN))
"RTN","RORUTL02",202,0)
 S LOWIEN=$O(@NODE@(""))
"RTN","RORUTL02",203,0)
 S HIGHIEN=$O(@NODE@(""),-1)
"RTN","RORUTL02",204,0)
 ;--- Get number of records from the parameters
"RTN","RORUTL02",205,0)
 S NRE=$$GET1^DIQ(798.1,REGIEN_",",19.1,,,"RORMSG")
"RTN","RORUTL02",206,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"REGSIZE^RORUTL02",,798.1,REGIEN)
"RTN","RORUTL02",207,0)
 Q:NRE>0 NRE
"RTN","RORUTL02",208,0)
 ;--- Count the records of the registry
"RTN","RORUTL02",209,0)
 S I="",NRE=0
"RTN","RORUTL02",210,0)
 F  S I=$O(@NODE@(I))  Q:I=""  S NRE=NRE+1
"RTN","RORUTL02",211,0)
 ;--- Store the value in the parameters
"RTN","RORUTL02",212,0)
 S RORFDA(798.1,REGIEN_",",19.1)=NRE
"RTN","RORUTL02",213,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUTL02",214,0)
 Q NRE
"RTN","RORUTL02",215,0)
 ;
"RTN","RORUTL02",216,0)
 ;***** CHECKS IF AN EMPLOYEE SHOULD BE SKIPPED
"RTN","RORUTL02",217,0)
 ;
"RTN","RORUTL02",218,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",219,0)
 ;
"RTN","RORUTL02",220,0)
 ; [.]REGIEN     Registry IEN
"RTN","RORUTL02",221,0)
 ;
"RTN","RORUTL02",222,0)
 ;               If you are going to call this function for several
"RTN","RORUTL02",223,0)
 ;               patients in a row (in a cycle), you can pass the
"RTN","RORUTL02",224,0)
 ;               second parameter by reference. This will eliminate
"RTN","RORUTL02",225,0)
 ;               repetitive access to the registry parameters (the
"RTN","RORUTL02",226,0)
 ;               REGIEN("SE") node will be used as a "cache" for the
"RTN","RORUTL02",227,0)
 ;               value of the EXCLUDE EMPLOYEES field).
"RTN","RORUTL02",228,0)
 ;
"RTN","RORUTL02",229,0)
 ; Return Values:
"RTN","RORUTL02",230,0)
 ;        0  Patient can be added to the registry
"RTN","RORUTL02",231,0)
 ;        1  Patient should be skipped
"RTN","RORUTL02",232,0)
 ;
"RTN","RORUTL02",233,0)
 ; The function checks if the patient is an employee and if he/she
"RTN","RORUTL02",234,0)
 ; can be added to the registry (according to the value of the
"RTN","RORUTL02",235,0)
 ; EXCLUDE EMPLOYEES field of the ROR REGISTRY PARAMETERS file).
"RTN","RORUTL02",236,0)
 ;
"RTN","RORUTL02",237,0)
SKIPEMPL(PATIEN,REGIEN) ;
"RTN","RORUTL02",238,0)
 Q:'$$EMPL^DGSEC4(PATIEN,"P") 0
"RTN","RORUTL02",239,0)
 S:'$D(REGIEN("SE")) REGIEN("SE")=+$P($G(^ROR(798.1,+REGIEN,0)),U,10)
"RTN","RORUTL02",240,0)
 Q +REGIEN("SE")
"RTN","RORUTL02",241,0)
 ;
"RTN","RORUTL02",242,0)
 ;***** RETURNS IEN OF THE SELECTION RULE
"RTN","RORUTL02",243,0)
 ;
"RTN","RORUTL02",244,0)
 ; RULENAME      Name of the selection rule
"RTN","RORUTL02",245,0)
 ; [FIELDS]      List of fields (separated by semicolons) to load
"RTN","RORUTL02",246,0)
 ; [.RORTRGT]    Reference to a local variable where field values will
"RTN","RORUTL02",247,0)
 ;               be stored by the FIND^DIC call.
"RTN","RORUTL02",248,0)
 ;
"RTN","RORUTL02",249,0)
 ; Return Values:
"RTN","RORUTL02",250,0)
 ;       <0  Error code
"RTN","RORUTL02",251,0)
 ;       >0  Selection rule IEN
"RTN","RORUTL02",252,0)
 ;
"RTN","RORUTL02",253,0)
SRLIEN(RULENAME,FIELDS,RORTRGT) ;
"RTN","RORUTL02",254,0)
 N RC,RULEIEN,RORMSG  K RORTRGT
"RTN","RORUTL02",255,0)
 D FIND^DIC(798.2,,"@;"_$G(FIELDS),"X",RULENAME,2,"B",,,"RORTRGT","RORMSG")
"RTN","RORUTL02",256,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"SRLIEN^RORUTL02",,798.2)
"RTN","RORUTL02",257,0)
 S RC=+$G(RORTRGT("DILIST",0))
"RTN","RORUTL02",258,0)
 Q $S(RC<1:-3,RC>1:-4,1:+RORTRGT("DILIST",2,1))
"RTN","RORUTL05")
0^30^B44301079
"RTN","RORUTL05",1,0)
RORUTL05 ;HCIOFO/SG - MISCELLANEOUS UTILITIES ; 11/1/02 10:57am
"RTN","RORUTL05",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2,3**;May 14, 2002
"RTN","RORUTL05",3,0)
 ;
"RTN","RORUTL05",4,0)
 Q
"RTN","RORUTL05",5,0)
 ;
"RTN","RORUTL05",6,0)
 ;***** DELETES ALL RECORDS FROM THE (SUB)FILE
"RTN","RORUTL05",7,0)
 ;
"RTN","RORUTL05",8,0)
 ; FILE          File/Subfile number
"RTN","RORUTL05",9,0)
 ; [IENS]        IENS of the subfile
"RTN","RORUTL05",10,0)
 ;
"RTN","RORUTL05",11,0)
 ; Return Values:
"RTN","RORUTL05",12,0)
 ;       <0  Error code
"RTN","RORUTL05",13,0)
 ;        0  Ok
"RTN","RORUTL05",14,0)
 ;
"RTN","RORUTL05",15,0)
CLEAR(FILE,IENS) ;
"RTN","RORUTL05",16,0)
 N IEN,RC,ROOT,RORFDA,RORMSG
"RTN","RORUTL05",17,0)
 S ROOT=$$ROOT^DILFD(FILE,$G(IENS),1)
"RTN","RORUTL05",18,0)
 S:$G(IENS)="" IENS=","
"RTN","RORUTL05",19,0)
 ;--- Delete the records
"RTN","RORUTL05",20,0)
 S (IEN,RC)=0
"RTN","RORUTL05",21,0)
 F  S IEN=$O(@ROOT@(IEN))  Q:'IEN  D  Q:RC<0
"RTN","RORUTL05",22,0)
 . S RORFDA(FILE,IEN_IENS,.01)="@"
"RTN","RORUTL05",23,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL05",24,0)
 . I $G(DIERR)  D  Q
"RTN","RORUTL05",25,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"CLEAR^RORUTL05",,FILE,IEN_IENS)
"RTN","RORUTL05",26,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL05",27,0)
 ;
"RTN","RORUTL05",28,0)
 ;***** CLEARS EXPIRED 'AWAITING ACKNOWLEDGEMENT' FLAGS
"RTN","RORUTL05",29,0)
 ;
"RTN","RORUTL05",30,0)
 ; .REGLST       Reference to a local array containing
"RTN","RORUTL05",31,0)
 ;               registry names as subscripts
"RTN","RORUTL05",32,0)
 ;
"RTN","RORUTL05",33,0)
CLRACK(REGLST) ;
"RTN","RORUTL05",34,0)
 N AWD,EXPDT,IENS,MSGID,NOW,RC,REGIEN,REGNAME
"RTN","RORUTL05",35,0)
 N RORBUF,RORFDA,RORINFO,RORMSG,TMP
"RTN","RORUTL05",36,0)
 S NOW=$$NOW^XLFDT
"RTN","RORUTL05",37,0)
 ;---
"RTN","RORUTL05",38,0)
 S REGNAME="",RORINFO=0
"RTN","RORUTL05",39,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D
"RTN","RORUTL05",40,0)
 . K RORBUF,RORFDA,RORMSG
"RTN","RORUTL05",41,0)
 . ;--- Get the registry IEN and parameters
"RTN","RORUTL05",42,0)
 . S REGIEN=$$REGIEN^RORUTL02(REGNAME,"2.2I;2.3I;15.9I",.RORBUF)
"RTN","RORUTL05",43,0)
 . Q:REGIEN'>0  Q:'$G(RORBUF("DILIST","ID",1,2.2))
"RTN","RORUTL05",44,0)
 . ;--- Check the expiration date/time
"RTN","RORUTL05",45,0)
 . S AWD=$G(RORBUF("DILIST","ID",1,15.9))
"RTN","RORUTL05",46,0)
 . S:(AWD="")!(AWD<0) AWD=3
"RTN","RORUTL05",47,0)
 . S EXPDT=$$FMADD^XLFDT(RORBUF("DILIST","ID",1,2.2),AWD)
"RTN","RORUTL05",48,0)
 . Q:EXPDT>NOW
"RTN","RORUTL05",49,0)
 . ;--- Clear the flag
"RTN","RORUTL05",50,0)
 . S IENS=REGIEN_","
"RTN","RORUTL05",51,0)
 . S RORFDA(798.1,IENS,2.2)="@" ; AWAITING ACKNOWLEDGEMENT
"RTN","RORUTL05",52,0)
 . S RORFDA(798.1,IENS,2.3)="@" ; LAST MESSAGE ID
"RTN","RORUTL05",53,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL05",54,0)
 . I $G(DIERR)  D  Q
"RTN","RORUTL05",55,0)
 . . S TMP=$$DBS^RORERR("RORMSG",-9,"CLRACK^RORUTL05",,798.1,IENS)
"RTN","RORUTL05",56,0)
 . S RORINFO=RORINFO+1,RORINFO(RORINFO)=REGNAME
"RTN","RORUTL05",57,0)
 . ;--- Record message status and cancel the message
"RTN","RORUTL05",58,0)
 . S MSGID=$G(RORBUF("DILIST","ID",1,2.3))
"RTN","RORUTL05",59,0)
 . I MSGID'=""  D  S TMP=$$MSGACT^HLUTIL(MSGID,1)
"RTN","RORUTL05",60,0)
 . . N STAT  S STAT=$$MSGSTAT^HLUTIL(MSGID)
"RTN","RORUTL05",61,0)
 . . S RORINFO=RORINFO+1
"RTN","RORUTL05",62,0)
 . . S RORINFO(RORINFO)="  Message ID:     "_MSGID
"RTN","RORUTL05",63,0)
 . . S RORINFO=RORINFO+1
"RTN","RORUTL05",64,0)
 . . S RORINFO(RORINFO)="  Message status: "_$$MSGSTXT^RORHL7(STAT)
"RTN","RORUTL05",65,0)
 . . S TMP=$P(STAT,U,2)  D:TMP
"RTN","RORUTL05",66,0)
 . . . S RORINFO=RORINFO+1
"RTN","RORUTL05",67,0)
 . . . S RORINFO(RORINFO)="  Status updated: "_$$FMTE^XLFDT(TMP)
"RTN","RORUTL05",68,0)
 . . S TMP=$P(STAT,U,3)  D:TMP'=""
"RTN","RORUTL05",69,0)
 . . . S RORINFO=RORINFO+1
"RTN","RORUTL05",70,0)
 . . . S RORINFO(RORINFO)="  Error message:  "_TMP
"RTN","RORUTL05",71,0)
 . . S TMP=$P(STAT,U,5)  D:TMP
"RTN","RORUTL05",72,0)
 . . . S RORINFO=RORINFO+1
"RTN","RORUTL05",73,0)
 . . . S TMP=$S(+STAT=1.7:"# of retries:   ",1:"Queue position: ")_TMP
"RTN","RORUTL05",74,0)
 . . . S RORINFO(RORINFO)="  "_TMP
"RTN","RORUTL05",75,0)
 . . S TMP=$P(STAT,U,6)  D:TMP'=""
"RTN","RORUTL05",76,0)
 . . . S RORINFO=RORINFO+1
"RTN","RORUTL05",77,0)
 . . . S RORINFO(RORINFO)="  Open failed:    "_TMP
"RTN","RORUTL05",78,0)
 . . S TMP=$P(STAT,U,7)  D:TMP'=""
"RTN","RORUTL05",79,0)
 . . . S RORINFO=RORINFO+1
"RTN","RORUTL05",80,0)
 . . . S RORINFO(RORINFO)="  ACK timeout:    "_TMP
"RTN","RORUTL05",81,0)
 . ;--- Send an alert to the coordinators
"RTN","RORUTL05",82,0)
 . D ALERT^RORUTL01(REGNAME,-67,,,,$S(AWD:"more than "_AWD,1:1))
"RTN","RORUTL05",83,0)
 ;---
"RTN","RORUTL05",84,0)
 I $D(RORINFO)>1  D  D LOG^RORLOG(4,TMP,,.RORINFO)
"RTN","RORUTL05",85,0)
 . S TMP="Expired 'Awaiting Acknowledgement' flag has been cleared."
"RTN","RORUTL05",86,0)
 Q 0
"RTN","RORUTL05",87,0)
 ;
"RTN","RORUTL05",88,0)
 ;***** CLEARS THE FIELDS OF THE RECORDS FOUND BY NAME
"RTN","RORUTL05",89,0)
 ;
"RTN","RORUTL05",90,0)
 ; FILE          File number
"RTN","RORUTL05",91,0)
 ; [IENS]        IENS of the subfile
"RTN","RORUTL05",92,0)
 ; NAME          Name of the record (value of the .01 field)
"RTN","RORUTL05",93,0)
 ; FIELDS        List of field numbers separated by semicolons
"RTN","RORUTL05",94,0)
 ;
"RTN","RORUTL05",95,0)
 ; Return Values:
"RTN","RORUTL05",96,0)
 ;       <0  Error code
"RTN","RORUTL05",97,0)
 ;        0  Ok
"RTN","RORUTL05",98,0)
 ;
"RTN","RORUTL05",99,0)
CLRFLDS(FILE,IENS,NAME,FIELDS) ;
"RTN","RORUTL05",100,0)
 N FLD,I,IEN,IENS1,IS,RC,RORBUF,RORFDA,RORMSG
"RTN","RORUTL05",101,0)
 ;--- Find the record(s)
"RTN","RORUTL05",102,0)
 D FIND^DIC(FILE,$G(IENS),"@","X",NAME,,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL05",103,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"CLRFLDS^RORUTL05",,FILE)  Q:RC<0 RC
"RTN","RORUTL05",104,0)
 S:$G(IENS)="" IENS=","  S FIELDS=$TR(FIELDS," ")
"RTN","RORUTL05",105,0)
 ;--- Delete the record(s)
"RTN","RORUTL05",106,0)
 S IS="",RC=0
"RTN","RORUTL05",107,0)
 F  S IS=$O(RORBUF("DILIST",2,IS))  Q:IS=""  D  Q:RC<0
"RTN","RORUTL05",108,0)
 . S IEN=RORBUF("DILIST",2,IS)  Q:IEN'>0
"RTN","RORUTL05",109,0)
 . S IENS1=IEN_IENS
"RTN","RORUTL05",110,0)
 . F I=1:1  S FLD=$P(FIELDS,";",I)  Q:FLD'>0  D
"RTN","RORUTL05",111,0)
 . . S RORFDA(FILE,IENS1,+FLD)="@"
"RTN","RORUTL05",112,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL05",113,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"CLRFLDS^RORUTL05",,FILE,IENS1)
"RTN","RORUTL05",114,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL05",115,0)
 ;
"RTN","RORUTL05",116,0)
 ;***** RETURNS THE END DATE FOR THE EVENT PURGE
"RTN","RORUTL05",117,0)
EPDATE() ;
"RTN","RORUTL05",118,0)
 N DATE,IR,RC,RORBUF,RORMSG,TMP
"RTN","RORUTL05",119,0)
 D LIST^DIC(798.1,,"@;1I;2I","U",,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL05",120,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"EPDATE^RORUTL05",,798.1)
"RTN","RORUTL05",121,0)
 ;--- Get the oldest date of registry updates
"RTN","RORUTL05",122,0)
 S IR="",DATE=$$DT^XLFDT
"RTN","RORUTL05",123,0)
 F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D
"RTN","RORUTL05",124,0)
 . S TMP=$G(RORBUF("DILIST","ID",IR,1)) ; REGISTRY UPDATED UNTIL
"RTN","RORUTL05",125,0)
 . I TMP>0  S:TMP<DATE DATE=TMP
"RTN","RORUTL05",126,0)
 . ;S TMP=$G(RORBUF("DILIST","ID",IR,2)) ; DATA EXTRACTED UNTIL
"RTN","RORUTL05",127,0)
 . ;I TMP>0  S:TMP<DATE DATE=TMP
"RTN","RORUTL05",128,0)
 ;--- Subtract additional 14 days (just in case)
"RTN","RORUTL05",129,0)
 S DATE=$$FMADD^XLFDT(DATE\1,-14)
"RTN","RORUTL05",130,0)
 ;--- No more than 60 days in the past
"RTN","RORUTL05",131,0)
 S TMP=$$FMADD^XLFDT($$DT^XLFDT,-60)
"RTN","RORUTL05",132,0)
 Q $S(DATE>TMP:DATE,1:TMP)
"RTN","RORUTL05",133,0)
 ;
"RTN","RORUTL05",134,0)
 ;***** MARKS THE REGISTRY RECORDS FOR RESENDING THE LOCAL DATA
"RTN","RORUTL05",135,0)
 ;
"RTN","RORUTL05",136,0)
 ; .REGLST       Reference to a local array containing registry names 
"RTN","RORUTL05",137,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUTL05",138,0)
 ; WD            Number of days to wait before marking the records
"RTN","RORUTL05",139,0)
 ;               for resending the local registry data
"RTN","RORUTL05",140,0)
 ;
"RTN","RORUTL05",141,0)
 ; Return Values:
"RTN","RORUTL05",142,0)
 ;       <0  Error code
"RTN","RORUTL05",143,0)
 ;        0  Ok
"RTN","RORUTL05",144,0)
 ;
"RTN","RORUTL05",145,0)
REMARK(REGLST,WD) ;
"RTN","RORUTL05",146,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL05",147,0)
 ;
"RTN","RORUTL05",148,0)
 N DATE,IEN,IENS,REGIEN,REGNAME,ROOT,RORFDA,RORMSG,TMP
"RTN","RORUTL05",149,0)
 D DFLTLOC^RORERR("REMARK^RORUTL05")
"RTN","RORUTL05",150,0)
 S ROOT=$$ROOT^DILFD(798,,1)
"RTN","RORUTL05",151,0)
 S DATE=$$FMADD^XLFDT($$DT^XLFDT,-WD)
"RTN","RORUTL05",152,0)
 ;--- Process the registries from the list
"RTN","RORUTL05",153,0)
 S REGNAME=""
"RTN","RORUTL05",154,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D
"RTN","RORUTL05",155,0)
 . S REGIEN=+REGLST(REGNAME)
"RTN","RORUTL05",156,0)
 . I REGIEN'>0  S REGIEN=$$REGIEN^RORUTL02(REGNAME)  Q:REGIEN'>0
"RTN","RORUTL05",157,0)
 . S IENS=REGIEN_","
"RTN","RORUTL05",158,0)
 . ;--- Get the registry parameters
"RTN","RORUTL05",159,0)
 . D GETS^DIQ(798.1,IENS,"21.04;21.05","I","RORFDA","RORMSG")
"RTN","RORUTL05",160,0)
 . I $G(DIERR)  S TMP=$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)  Q
"RTN","RORUTL05",161,0)
 . ;--- Local data has been resent already
"RTN","RORUTL05",162,0)
 . Q:$G(RORFDA(798.1,IENS,21.04,"I"))
"RTN","RORUTL05",163,0)
 . ;--- The registry has not been populated yet
"RTN","RORUTL05",164,0)
 . Q:'$G(RORFDA(798.1,IENS,21.05,"I"))
"RTN","RORUTL05",165,0)
 . ;--- It is too early for resending the local data
"RTN","RORUTL05",166,0)
 . Q:RORFDA(798.1,IENS,21.05,"I")>DATE
"RTN","RORUTL05",167,0)
 . K RORFDA,RORMSG
"RTN","RORUTL05",168,0)
 . ;--- Mark registry records as modified
"RTN","RORUTL05",169,0)
 . S (IEN,RC)=0
"RTN","RORUTL05",170,0)
 . F  S IEN=$O(@ROOT@("AC",REGIEN,IEN))  Q:'IEN  D  Q:RC<0
"RTN","RORUTL05",171,0)
 . . S IENS=IEN_","
"RTN","RORUTL05",172,0)
 . . S RORFDA(798,IENS,4)=1  ; UPDATE DEMOGRAPHICS
"RTN","RORUTL05",173,0)
 . . S RORFDA(798,IENS,5)=1  ; UPDATE LOCAL REGISTRY DATA
"RTN","RORUTL05",174,0)
 . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL05",175,0)
 . . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,798,IENS)  Q
"RTN","RORUTL05",176,0)
 . Q:RC<0
"RTN","RORUTL05",177,0)
 . ;--- Update registry parameters
"RTN","RORUTL05",178,0)
 . S IENS=REGIEN_","
"RTN","RORUTL05",179,0)
 . S RORFDA(798.1,IENS,21.04)=$$NOW^XLFDT
"RTN","RORUTL05",180,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUTL05",181,0)
 . I $G(DIERR)  S TMP=$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)  Q
"RTN","RORUTL05",182,0)
 . ;--- Record the message
"RTN","RORUTL05",183,0)
 . S TMP="Local registry and demographic data will be resent to AAC"
"RTN","RORUTL05",184,0)
 . D LOG^RORLOG(2,TMP,,"Registry Name: "_REGNAME)
"RTN","RORUTL05",185,0)
 Q 0
"RTN","RORUTL05",186,0)
 ;
"RTN","RORUTL05",187,0)
 ;***** REBUILDS THE "ACL" CROSS-REFERENCE (USER ACCESS)
"RTN","RORUTL05",188,0)
 ;
"RTN","RORUTL05",189,0)
 ; Return Values:
"RTN","RORUTL05",190,0)
 ;       <0  Error code
"RTN","RORUTL05",191,0)
 ;        0  Ok
"RTN","RORUTL05",192,0)
 ;
"RTN","RORUTL05",193,0)
RNDXACL() ;
"RTN","RORUTL05",194,0)
 N DA,DIK,REGIEN,ROOT
"RTN","RORUTL05",195,0)
 S ROOT=$$ROOT^DILFD(798.1,,1)  K @ROOT@("ACL")
"RTN","RORUTL05",196,0)
 S REGIEN=0
"RTN","RORUTL05",197,0)
 F  S REGIEN=$O(@ROOT@(REGIEN))  Q:'REGIEN  D
"RTN","RORUTL05",198,0)
 . S DIK=$$ROOT^DILFD(798.118,","_REGIEN_","),DIK(1)=".01^ACL"
"RTN","RORUTL05",199,0)
 . S DA(1)=REGIEN  D ENALL^DIK
"RTN","RORUTL05",200,0)
 Q 0
"SEC","^DD",798.1,798.1,9,9)
 
"SEC","^DD",798.1,798.1,21.03,9)
 
"SEC","^DD",798.1,798.1,21.04,8)
 
"SEC","^DD",798.1,798.19,.01,8.5)
 
"SEC","^DD",798.1,798.19,.01,9)
 
"SEC","^DD",798.1,798.19,.02,8.5)
 
"SEC","^DD",798.1,798.19,.02,9)
 
"SEC","^DD",798.7,798.74,2,9)
 
"SEC","^DIC",798,798,0,"AUDIT")
 
"SEC","^DIC",798,798,0,"DD")
@
"SEC","^DIC",798,798,0,"DEL")
@
"SEC","^DIC",798,798,0,"LAYGO")
@
"SEC","^DIC",798,798,0,"RD")
 
"SEC","^DIC",798,798,0,"WR")
@
"SEC","^DIC",798.1,798.1,0,"AUDIT")
 
"SEC","^DIC",798.1,798.1,0,"DD")
 
"SEC","^DIC",798.1,798.1,0,"DEL")
 
"SEC","^DIC",798.1,798.1,0,"LAYGO")
 
"SEC","^DIC",798.1,798.1,0,"RD")
 
"SEC","^DIC",798.1,798.1,0,"WR")
 
"SEC","^DIC",798.4,798.4,0,"AUDIT")
 
"SEC","^DIC",798.4,798.4,0,"DD")
@
"SEC","^DIC",798.4,798.4,0,"DEL")
@
"SEC","^DIC",798.4,798.4,0,"LAYGO")
@
"SEC","^DIC",798.4,798.4,0,"RD")
 
"SEC","^DIC",798.4,798.4,0,"WR")
@
"SEC","^DIC",798.7,798.7,0,"AUDIT")
 
"SEC","^DIC",798.7,798.7,0,"DD")
@
"SEC","^DIC",798.7,798.7,0,"DEL")
@
"SEC","^DIC",798.7,798.7,0,"LAYGO")
@
"SEC","^DIC",798.7,798.7,0,"RD")
 
"SEC","^DIC",798.7,798.7,0,"WR")
@
"VER")
8.0^22
"^DD",798,798,0)
FIELD^^11^20
"^DD",798,798,0,"DDA")
N
"^DD",798,798,0,"DT")
3011120
"^DD",798,798,0,"IX","AC",798,.02)
 
"^DD",798,798,0,"IX","AD",798,1)
 
"^DD",798,798,0,"IX","AM",798,10)
 
"^DD",798,798,0,"IX","B",798,.01)
 
"^DD",798,798,0,"NM","ROR LOCAL REGISTRY")
 
"^DD",798,798,0,"PT",798.53,.01)
 
"^DD",798,798,0,"SCR")
I $G(DUZ),$S($D(^ROR(798.1,"ACL",DUZ,+$P($G(^(0)),U,2)))>1:1,1:$D(^XUSEC("ROR VA IRM",DUZ)))
"^DD",798,798,0,"VRPK")
ROR
"^DD",798,798,.01,0)
PATIENT NAME^RP798.4^RORDATA(798.4,^0;1^Q
"^DD",798,798,.01,1,0)
^.1
"^DD",798,798,.01,1,1,0)
798^B
"^DD",798,798,.01,1,1,1)
S ^RORDATA(798,"B",$E(X,1,30),DA)=""
"^DD",798,798,.01,1,1,2)
K ^RORDATA(798,"B",$E(X,1,30),DA)
"^DD",798,798,.01,1,1,3)
Do not delete!
"^DD",798,798,.01,1,1,"%D",0)
^^2^2^3011005^
"^DD",798,798,.01,1,1,"%D",1,0)
Patient records in all defined registries can be
"^DD",798,798,.01,1,1,"%D",2,0)
found using this cross-reference.
"^DD",798,798,.01,3)
 
"^DD",798,798,.01,8.5)
@
"^DD",798,798,.01,9)
@
"^DD",798,798,.01,20,0)
^.3LA^1^1
"^DD",798,798,.01,20,1,0)
ENTRY
"^DD",798,798,.01,21,0)
^.001^7^7^3020816^^
"^DD",798,798,.01,21,1,0)
The PATIENT NAME field identifies a patient in the
"^DD",798,798,.01,21,2,0)
registry. You can select a patient either from the
"^DD",798,798,.01,21,3,0)
local registry or the ROR PATIENT file, or you can
"^DD",798,798,.01,21,4,0)
add a new patient from the PATIENT file.
"^DD",798,798,.01,21,5,0)
 
"^DD",798,798,.01,21,6,0)
You can select records only of those registries
"^DD",798,798,.01,21,7,0)
that you have appropriate security key(s) for.
"^DD",798,798,.01,23,0)
^.001^6^6^3020816^^^^
"^DD",798,798,.01,23,1,0)
An internal value of this field is the patient IEN in
"^DD",798,798,.01,23,2,0)
the PATIENT file (#2) because records in the ROR
"^DD",798,798,.01,23,3,0)
PATIENT file (#798.4) have the same internal entry
"^DD",798,798,.01,23,4,0)
numbers as corresponding records in the PATIENT file.
"^DD",798,798,.01,23,5,0)
Patient records in all registries can be found by
"^DD",798,798,.01,23,6,0)
traditional "B" cross-reference.
"^DD",798,798,.01,"DT")
3010612
"^DD",798,798,.02,0)
REGISTRY^RP798.1'I^ROR(798.1,^0;2^Q
"^DD",798,798,.02,1,0)
^.1
"^DD",798,798,.02,1,1,0)
798^AC
"^DD",798,798,.02,1,1,1)
S ^RORDATA(798,"AC",$E(X,1,30),DA)=""
"^DD",798,798,.02,1,1,2)
K ^RORDATA(798,"AC",$E(X,1,30),DA)
"^DD",798,798,.02,1,1,3)
Do not delete!
"^DD",798,798,.02,1,1,"%D",0)
^^2^2^3011005^
"^DD",798,798,.02,1,1,"%D",1,0)
This cross-reference is used to link all records
"^DD",798,798,.02,1,1,"%D",2,0)
of the registry together.
"^DD",798,798,.02,1,1,"DT")
3000406
"^DD",798,798,.02,1,2,0)
^^TRIGGER^798^1
"^DD",798,798,.02,1,2,1)
X ^DD(798,.02,1,2,1.3) I X S X=DIV S Y(1)=$S($D(^RORDATA(798,D0,0)):^(0),1:"") S X=$P(Y(1),U,3),X=X S DIU=X K Y S X=DIV S %=$P($H,",",2),X=DT_(%\60#60/100+(%\3600)+(%#60/10000)/100) X ^DD(798,.02,1,2,1.4)
"^DD",798,798,.02,1,2,1.3)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(0)=X S Y(1)=$S($D(^RORDATA(798,D0,0)):^(0),1:"") S X='$P(Y(1),U,3)
"^DD",798,798,.02,1,2,1.4)
S DIH=$G(^RORDATA(798,DIV(0),0)),DIV=X S $P(^(0),U,3)=DIV,DIH=798,DIG=1 D ^DICR
"^DD",798,798,.02,1,2,2)
Q
"^DD",798,798,.02,1,2,3)
Do not delete!
"^DD",798,798,.02,1,2,"%D",0)
^^2^2^3020402^
"^DD",798,798,.02,1,2,"%D",1,0)
This trigger populates the DATE ENTERED field 
"^DD",798,798,.02,1,2,"%D",2,0)
when the patient is added to the registry.
"^DD",798,798,.02,1,2,"CREATE CONDITION")
'DATE ENTERED
"^DD",798,798,.02,1,2,"CREATE VALUE")
NOW
"^DD",798,798,.02,1,2,"DELETE VALUE")
NO EFFECT
"^DD",798,798,.02,1,2,"DT")
3011119
"^DD",798,798,.02,1,2,"FIELD")
DATE
"^DD",798,798,.02,8.5)
@
"^DD",798,798,.02,9)
@
"^DD",798,798,.02,20,0)
^.3LA^1^1
"^DD",798,798,.02,20,1,0)
ENTRY
"^DD",798,798,.02,21,0)
^.001^2^2^3020816^^
"^DD",798,798,.02,21,1,0)
The REGISTRY field identifies the registry that 
"^DD",798,798,.02,21,2,0)
the record belongs to.
"^DD",798,798,.02,23,0)
^.001^2^2^3020816^^
"^DD",798,798,.02,23,1,0)
Traditional cross-reference "AC" is used to link all 
"^DD",798,798,.02,23,2,0)
records of the registry together.
"^DD",798,798,.02,"DT")
3011119
"^DD",798,798,1,0)
DATE ENTERED^DI^^0;3^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798,1,1,0)
^.1
"^DD",798,798,1,1,1,0)
798^AD
"^DD",798,798,1,1,1,1)
S ^RORDATA(798,"AD",$E(X,1,30),DA)=""
"^DD",798,798,1,1,1,2)
K ^RORDATA(798,"AD",$E(X,1,30),DA)
"^DD",798,798,1,1,1,3)
Do not delete!
"^DD",798,798,1,1,1,"%D",0)
^^2^2^3011005^
"^DD",798,798,1,1,1,"%D",1,0)
This cross-reference can be used to search for
"^DD",798,798,1,1,1,"%D",2,0)
recently added patients.  
"^DD",798,798,1,1,1,"DT")
3010709
"^DD",798,798,1,5,1,0)
798^.02^2
"^DD",798,798,1,8.5)
@
"^DD",798,798,1,9)
@
"^DD",798,798,1,20,0)
^.3LA^1^1
"^DD",798,798,1,20,1,0)
ENTRY
"^DD",798,798,1,21,0)
^.001^3^3^3020816^^
"^DD",798,798,1,21,1,0)
The DATE ENTERED field is automatically populated
"^DD",798,798,1,21,2,0)
by the trigger associated with the REGISTRY field
"^DD",798,798,1,21,3,0)
when the patient is added to the registry.
"^DD",798,798,1,"DT")
3011115
"^DD",798,798,2,0)
INACTIVATION DATE^DX^^0;4^S %DT="ESTX" K Y S:$G(DIUTIL)'="VERIFY FIELDS" Y(9.2)=$P($G(^RORDATA(798,DA,2)),U,2),Y(7)=$P($G(^(0)),U,11),Y=$S(Y(9.2)>Y(7):Y(9.2),1:Y(7)) S:$G(Y)>0 %DT(0)=Y D ^%DT S X=Y K:Y<1 X K %DT,Y
"^DD",798,798,2,1,0)
^.1^^0
"^DD",798,798,2,3)
Enter the inactivation date for the patient.
"^DD",798,798,2,4)
 
"^DD",798,798,2,20,0)
^.3LA^1^1
"^DD",798,798,2,20,1,0)
STATE
"^DD",798,798,2,21,0)
^.001^8^8^3020816^^
"^DD",798,798,2,21,1,0)
When present the INACTIVATION DATE field contains
"^DD",798,798,2,21,2,0)
the latest inactivation date/time of the patient
"^DD",798,798,2,21,3,0)
in the registry.
"^DD",798,798,2,21,4,0)
 
"^DD",798,798,2,21,5,0)
The new inactivation date could be in the future
"^DD",798,798,2,21,6,0)
or in the past but it should be not earlier than
"^DD",798,798,2,21,7,0)
the date of the last data extraction or the date
"^DD",798,798,2,21,8,0)
of re-activation (if present).
"^DD",798,798,2,23,0)
^.001^5^5^3020816^^
"^DD",798,798,2,23,1,0)
Patient's record is active if there is no inactivation 
"^DD",798,798,2,23,2,0)
date. Otherwise, values of both the INACTIVATION DATE
"^DD",798,798,2,23,3,0)
and REACTIVATION DATE fields should be analyzed along
"^DD",798,798,2,23,4,0)
with the current date/time. See description of the 
"^DD",798,798,2,23,5,0)
ACTIVE computed field (#798, 8) for further details.
"^DD",798,798,2,"DT")
3011120
"^DD",798,798,2.1,0)
INACTIVATED BY^P200'^VA(200,^0;10^Q
"^DD",798,798,2.1,21,0)
^^3^3^3020402^
"^DD",798,798,2.1,21,1,0)
The INACTIVATED BY field identifies a person who
"^DD",798,798,2.1,21,2,0)
has inactivated a patient record in the registry
"^DD",798,798,2.1,21,3,0)
for the last time.
"^DD",798,798,2.1,23,0)
^^4^4^3020402^
"^DD",798,798,2.1,23,1,0)
This field is automatically populated by the
"^DD",798,798,2.1,23,2,0)
inactivation remote procedure. If the patient record
"^DD",798,798,2.1,23,3,0)
has been automatically inactivated because of patient
"^DD",798,798,2.1,23,4,0)
death, this field will have no value.
"^DD",798,798,2.1,"DT")
3000504
"^DD",798,798,2.2,0)
REASON FOR INACTIVATION^*P799.1'X^ROR(799.1,^0;13^S Y=$P($G(^RORDATA(798,DA,0)),U,2),DIC("S")="S D=$G(^(0)) I $P(D,U,2)=1"_$S(Y>0:",$P(D,U,3)="_Y,1:"") D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",798,798,2.2,3)
 
"^DD",798,798,2.2,12)
Only reasons for inactivation can be selected.
"^DD",798,798,2.2,12.1)
S DIC("S")="I $P(^(0),U,2)=1"
"^DD",798,798,2.2,21,0)
^.001^3^3^3011120^^^^
"^DD",798,798,2.2,21,1,0)
Value of this field indicates a reason for the 
"^DD",798,798,2.2,21,2,0)
latest manual inactivation of the patient record
"^DD",798,798,2.2,21,3,0)
in the registry.
"^DD",798,798,2.2,23,0)
^.001^5^5^3011120^^^^
"^DD",798,798,2.2,23,1,0)
This field is only ever populated via the GUI manual
"^DD",798,798,2.2,23,2,0)
entry option.
"^DD",798,798,2.2,23,3,0)
 
"^DD",798,798,2.2,23,4,0)
If a patient was inactivated because of death, this 
"^DD",798,798,2.2,23,5,0)
field MUST be empty!
"^DD",798,798,2.2,"DT")
3011120
"^DD",798,798,3,0)
NEW PATIENT^S^0:NO;1:AUTO;2:MANUAL;3:REACTIVATED;^0;5^Q
"^DD",798,798,3,20,0)
^.3LA^1^1
"^DD",798,798,3,20,1,0)
STATE
"^DD",798,798,3,21,0)
^.001^2^2^3020816^^
"^DD",798,798,3,21,1,0)
The NEW PATIENT field describes how the patient 
"^DD",798,798,3,21,2,0)
has been added/updated in the registry.
"^DD",798,798,3,23,0)
^.001^7^7^3020816^^
"^DD",798,798,3,23,1,0)
Usually, this field contains 0 or no value at all. The
"^DD",798,798,3,23,2,0)
field is automatically populated by the registry
"^DD",798,798,3,23,3,0)
update, patient reactivation and GUI manual entry
"^DD",798,798,3,23,4,0)
processing.
"^DD",798,798,3,23,5,0)
 
"^DD",798,798,3,23,6,0)
After acknowledgement of the successful processing of
"^DD",798,798,3,23,7,0)
transmitted data the value of this field is deleted.
"^DD",798,798,3,"DT")
3000426
"^DD",798,798,3.1,0)
SELECTION RULE^798.01P^^1;0
"^DD",798,798,3.1,20,0)
^.3LA^1^1
"^DD",798,798,3.1,20,1,0)
ENTRY
"^DD",798,798,3.1,21,0)
^.001^3^3^3020816^^
"^DD",798,798,3.1,21,1,0)
The SELECTION RULE multiple contains a list of
"^DD",798,798,3.1,21,2,0)
selection rules that the patient passed when added
"^DD",798,798,3.1,21,3,0)
to the registry.
"^DD",798,798,3.1,23,0)
^.001^2^2^3020816^^
"^DD",798,798,3.1,23,1,0)
The list is automatically populated by the registry
"^DD",798,798,3.1,23,2,0)
update and the GUI manual patient entry processing.
"^DD",798,798,3.2,0)
SUPPORTING EVIDENCE^*P799.1'X^ROR(799.1,^0;14^S Y=$P($G(^RORDATA(798,DA,0)),U,2),DIC("S")="S D=$G(^(0)) I $P(D,U,2)=2"_$S(Y>0:",$P(D,U,3)="_Y,1:"") D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",798,798,3.2,3)
 
"^DD",798,798,3.2,12)
Only supporting evidences can be selected.
"^DD",798,798,3.2,12.1)
S DIC("S")="I $P(^(0),U,2)=2"
"^DD",798,798,3.2,20,0)
^.3LA^1^1
"^DD",798,798,3.2,20,1,0)
ENTRY
"^DD",798,798,3.2,21,0)
^.001^2^2^3020816^^^^
"^DD",798,798,3.2,21,1,0)
This field indicates a reason for manual addition
"^DD",798,798,3.2,21,2,0)
of the patient to the registry.
"^DD",798,798,3.2,23,0)
^.001^2^2^3020816^^
"^DD",798,798,3.2,23,1,0)
The HEPC SUPPORT EVIDENCE field is only ever populated
"^DD",798,798,3.2,23,2,0)
via the GUI manual entry option.
"^DD",798,798,3.2,"DT")
3011009
"^DD",798,798,4,0)
UPDATE DEMOGRAPHICS^S^0:NO;1:YES;^0;6^Q
"^DD",798,798,4,20,0)
^.3LA^1^1
"^DD",798,798,4,20,1,0)
STATE
"^DD",798,798,4,21,0)
^.001^3^3^3020816^^
"^DD",798,798,4,21,1,0)
Usually, you should not edit this field. Set a 
"^DD",798,798,4,21,2,0)
value of this field to "Yes" if you want the
"^DD",798,798,4,21,3,0)
patient demographic data to be sent to AAC.
"^DD",798,798,4,23,0)
^.001^12^12^3020816^^
"^DD",798,798,4,23,1,0)
During the registry update, demographic fields of each
"^DD",798,798,4,23,2,0)
record of the ROR PATIENT file are compared with
"^DD",798,798,4,23,3,0)
corresponding fields of the PATIENT file.
"^DD",798,798,4,23,4,0)
 
"^DD",798,798,4,23,5,0)
If some of the fields have different values, an 
"^DD",798,798,4,23,6,0)
internal value of 1 is assigned to the UPDATE
"^DD",798,798,4,23,7,0)
DEMOGRAPHICS field of all active patient records in 
"^DD",798,798,4,23,8,0)
local registries. As a result, demographic data is
"^DD",798,798,4,23,9,0)
transmitted to the national registries.
"^DD",798,798,4,23,10,0)
 
"^DD",798,798,4,23,11,0)
After acknowledgement of the successful processing of
"^DD",798,798,4,23,12,0)
transmitted data the value of this field is deleted.
"^DD",798,798,4,"DT")
3000323
"^DD",798,798,5,0)
UPDATE LOCAL REGISTRY DATA^S^0:NO;1:YES;^0;7^Q
"^DD",798,798,5,20,0)
^.3LA^1^1
"^DD",798,798,5,20,1,0)
STATE
"^DD",798,798,5,21,0)
^.001^4^4^3020816^^^
"^DD",798,798,5,21,1,0)
Usually, you should not edit this field. Set a 
"^DD",798,798,5,21,2,0)
value of this field to "Yes" if you have changed
"^DD",798,798,5,21,3,0)
any local registry data of the patient and want 
"^DD",798,798,5,21,4,0)
this data to be sent to AAC.
"^DD",798,798,5,23,0)
^.001^8^8^3020816^^^
"^DD",798,798,5,23,1,0)
Any changes of local registry data result in assignment
"^DD",798,798,5,23,2,0)
of 1 as an internal value of the UPDATE LOCAL REGISTRY
"^DD",798,798,5,23,3,0)
DATA field (by registry update process or remote
"^DD",798,798,5,23,4,0)
procedures). This is an indication to transmit local
"^DD",798,798,5,23,5,0)
data to the national registry.
"^DD",798,798,5,23,6,0)
 
"^DD",798,798,5,23,7,0)
After acknowledgement of the successful processing of
"^DD",798,798,5,23,8,0)
transmitted data the value of this field is deleted.
"^DD",798,798,5,"DT")
3000327
"^DD",798,798,6,0)
INVESTIGATIONAL DRUGS^S^0:NO;1:YES;^0;8^Q
"^DD",798,798,6,21,0)
^^3^3^3020402^
"^DD",798,798,6,21,1,0)
Set this field to "Yes" if any investigational 
"^DD",798,798,6,21,2,0)
drugs related to the registry are/were used in
"^DD",798,798,6,21,3,0)
the treatment of the patient.
"^DD",798,798,6,23,0)
^^6^6^3020402^
"^DD",798,798,6,23,1,0)
The internal value of 1 in the INVESTIGATIONAL DRUGS
"^DD",798,798,6,23,2,0)
field indicates that these drugs are used in the
"^DD",798,798,6,23,3,0)
treatment of the patient.
"^DD",798,798,6,23,4,0)
 
"^DD",798,798,6,23,5,0)
Value of this field is controlled by a user (via
"^DD",798,798,6,23,6,0)
the corresponding check-box in the GUI).
"^DD",798,798,6,"DT")
3000327
"^DD",798,798,6.1,0)
MEDICATION IN PROFILE^S^0:NO;1:YES;^0;9^Q
"^DD",798,798,6.1,21,0)
^^3^3^3020402^
"^DD",798,798,6.1,21,1,0)
Enter "Yes" if the drugs that the patient is
"^DD",798,798,6.1,21,2,0)
currently taking are in the medication profile
"^DD",798,798,6.1,21,3,0)
that exists within VistA or CPRS.
"^DD",798,798,6.1,23,0)
^.001^2^2^3020402^^^
"^DD",798,798,6.1,23,1,0)
Value of this field is controlled by a user (via
"^DD",798,798,6.1,23,2,0)
the corresponding check-box in the GUI).
"^DD",798,798,6.1,"DT")
3000327
"^DD",798,798,7,0)
REACTIVATION DATE^DX^^0;11^S %DT="ESTX" K Y S:$G(DIUTIL)'="VERIFY FIELDS" Y(9.2)=$P($G(^RORDATA(798,DA,2)),U,2),Y(2)=$P($G(^(0)),U,4),Y=$S(Y(9.2)>Y(2):Y(9.2),1:Y(2)) S:$G(Y)>0 %DT(0)=Y D ^%DT S X=Y K:(Y<1)!(Y>$$NOW^XLFDT) X K %DT,Y
"^DD",798,798,7,3)
Enter the reactivation date for the patient.
"^DD",798,798,7,4)
 
"^DD",798,798,7,20,0)
^.3LA^1^1
"^DD",798,798,7,20,1,0)
STATE
"^DD",798,798,7,21,0)
^.001^7^7^3020816^^
"^DD",798,798,7,21,1,0)
The REACTIVATION DATE field contains a date/time
"^DD",798,798,7,21,2,0)
of the latest reactivation of the patient in the
"^DD",798,798,7,21,3,0)
registry.
"^DD",798,798,7,21,4,0)
 
"^DD",798,798,7,21,5,0)
The new reactivation date cannot be earlier than 
"^DD",798,798,7,21,6,0)
the date of the latest data extract or the date of
"^DD",798,798,7,21,7,0)
inactivation. You cannot enter a future date.
"^DD",798,798,7,23,0)
^.001^5^5^3020816^^
"^DD",798,798,7,23,1,0)
You must evaluate both REACTIVATION DATE and 
"^DD",798,798,7,23,2,0)
INACTIVATION DATE fields along with the current 
"^DD",798,798,7,23,3,0)
date/time to determine whether the patient record is
"^DD",798,798,7,23,4,0)
active or not. See the description of the ACTIVE
"^DD",798,798,7,23,5,0)
computed field (#798, 8) for further details.
"^DD",798,798,7,"DT")
3011011
"^DD",798,798,7.1,0)
REACTIVATED BY^P200'^VA(200,^0;12^Q
"^DD",798,798,7.1,21,0)
^^2^2^3020402^
"^DD",798,798,7.1,21,1,0)
The REACTIVATED BY field identifies a person who
"^DD",798,798,7.1,21,2,0)
last re-activated the patient.
"^DD",798,798,7.1,23,0)
^.001^2^2^3020402^^
"^DD",798,798,7.1,23,1,0)
This field is automatically populated by the 
"^DD",798,798,7.1,23,2,0)
re-activation processing within the GUI.
"^DD",798,798,7.1,"DT")
3000504
"^DD",798,798,8,0)
ACTIVE^CJ1,0^^ ; ^S Y(0)=$G(^RORDATA(798,D0,0)),X=$$ACTIVE^RORDD($P(Y(0),U,4),$P(Y(0),U,11))
"^DD",798,798,8,9)
^
"^DD",798,798,8,9.01)
 
"^DD",798,798,8,9.1)
S Y(0)=$G(^RORDATA(798,D0,0)),X=$$ACTIVE^RORDD($P(Y(0),U,4),$P(Y(0),U,11))
"^DD",798,798,8,20,0)
^.3LA^1^1
"^DD",798,798,8,20,1,0)
STATE
"^DD",798,798,8,21,0)
^.001^3^3^3020816^^^^
"^DD",798,798,8,21,1,0)
This is a computed field that indicates the 
"^DD",798,798,8,21,2,0)
current status of the patient in the local
"^DD",798,798,8,21,3,0)
registry.
"^DD",798,798,8,23,0)
^.001^8^8^3020816^^^
"^DD",798,798,8,23,1,0)
Patient is active if there is no inactivation date. 
"^DD",798,798,8,23,2,0)
Otherwise, the patient is active only if:
"^DD",798,798,8,23,3,0)
 
"^DD",798,798,8,23,4,0)
 (INACTIVATION DATE > NOW) or 
"^DD",798,798,8,23,5,0)
 (INACTIVATION DATE < REACTIVATION DATE)
"^DD",798,798,8,23,6,0)
 
"^DD",798,798,8,23,7,0)
Please, remember that REACTIVATION DATE cannot be in 
"^DD",798,798,8,23,8,0)
the future.
"^DD",798,798,8,"DT")
3011011
"^DD",798,798,9.1,0)
DATA ACKNOWLEDGED UNTIL^D^^2;1^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798,9.1,20,0)
^.3LA^1^1
"^DD",798,798,9.1,20,1,0)
STATE
"^DD",798,798,9.1,21,0)
^.001^3^3^3020816^^
"^DD",798,798,9.1,21,1,0)
The DATA ACKNOWLEDGED UNTIL field contains a date
"^DD",798,798,9.1,21,2,0)
that the patient data has been extracted until,
"^DD",798,798,9.1,21,3,0)
successfully transmitted and acknowledged.
"^DD",798,798,9.1,23,0)
^.001^7^7^3020816^^
"^DD",798,798,9.1,23,1,0)
A regular data extraction for the patient in the 
"^DD",798,798,9.1,23,2,0)
registry starts from this date.
"^DD",798,798,9.1,23,3,0)
 
"^DD",798,798,9.1,23,4,0)
Acknowledgement processing copies the value of the
"^DD",798,798,9.1,23,5,0)
DATA EXTRACTED UNTIL field into this field upon
"^DD",798,798,9.1,23,6,0)
receiving and processing the HL7 acknowledgement from 
"^DD",798,798,9.1,23,7,0)
the AAC.
"^DD",798,798,9.1,"DT")
3010830
"^DD",798,798,9.2,0)
DATA EXTRACTED UNTIL^D^^2;2^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798,9.2,20,0)
^.3LA^1^1
"^DD",798,798,9.2,20,1,0)
STATE
"^DD",798,798,9.2,21,0)
^.001^3^3^3020816^^^
"^DD",798,798,9.2,21,1,0)
This field contains a date that registry data of 
"^DD",798,798,9.2,21,2,0)
the patient has been extracted until, transmitted
"^DD",798,798,9.2,21,3,0)
but not acknowledged yet.
"^DD",798,798,9.2,23,0)
^.001^8^8^3020816^^
"^DD",798,798,9.2,23,1,0)
The field is automatically populated by the regular
"^DD",798,798,9.2,23,2,0)
data extraction process if the data is extracted
"^DD",798,798,9.2,23,3,0)
successfully.
"^DD",798,798,9.2,23,4,0)
 
"^DD",798,798,9.2,23,5,0)
Acknowledgement processing routine copies value of this
"^DD",798,798,9.2,23,6,0)
field into the DATA ACKNOWLEDGED UNTIL field upon
"^DD",798,798,9.2,23,7,0)
receiving and processing HL7 acknowledgement from the
"^DD",798,798,9.2,23,8,0)
AAC.
"^DD",798,798,9.2,"DT")
3010830
"^DD",798,798,10,0)
MESSAGE ID^FX^^2;3^K:X[""""!($A(X)=45) X I $D(X) K:$L(X)>20!(X'?1.E1"-"1.N) X
"^DD",798,798,10,1,0)
^.1
"^DD",798,798,10,1,1,0)
798^AM
"^DD",798,798,10,1,1,1)
S ^RORDATA(798,"AM",$E(X,1,30),DA)=""
"^DD",798,798,10,1,1,2)
K ^RORDATA(798,"AM",$E(X,1,30),DA)
"^DD",798,798,10,1,1,3)
Do not delete!
"^DD",798,798,10,1,1,"%D",0)
^^3^3^3011005^
"^DD",798,798,10,1,1,"%D",1,0)
The cross-reference allows to find a patient 
"^DD",798,798,10,1,1,"%D",2,0)
record in the registry using an ID of an HL7
"^DD",798,798,10,1,1,"%D",3,0)
message sent to the national registry.
"^DD",798,798,10,1,1,"DT")
3010824
"^DD",798,798,10,3)
The unique ID of the latest HL7 message (1-20 characters).
"^DD",798,798,10,21,0)
^^8^8^3020402^
"^DD",798,798,10,21,1,0)
The MESSAGE ID field contains an identifier of 
"^DD",798,798,10,21,2,0)
the latest individual HL7 message created for this
"^DD",798,798,10,21,3,0)
registry record.
"^DD",798,798,10,21,4,0)
 
"^DD",798,798,10,21,5,0)
Value of this field should have the following
"^DD",798,798,10,21,6,0)
format: BatchID-N, where BatchID is an ID of an
"^DD",798,798,10,21,7,0)
HL7 batch message, and N is a sequential number of
"^DD",798,798,10,21,8,0)
the message in the batch.
"^DD",798,798,10,23,0)
^.001^3^3^3020402^^^
"^DD",798,798,10,23,1,0)
This field is automatically populated by the regular
"^DD",798,798,10,23,2,0)
data extraction process every time an HL7 message is
"^DD",798,798,10,23,3,0)
generated.
"^DD",798,798,10,"DT")
3011005
"^DD",798,798,11,0)
DON'T SEND^S^0:NO;1:YES;^2;4^Q
"^DD",798,798,11,21,0)
^^3^3^3020402^
"^DD",798,798,11,21,1,0)
Set this field to "Yes" if you do not want any 
"^DD",798,798,11,21,2,0)
data to be sent to the national registry for this
"^DD",798,798,11,21,3,0)
record.
"^DD",798,798,11,23,0)
^^4^4^3020402^
"^DD",798,798,11,23,1,0)
Usually, this field is populated only automatically by
"^DD",798,798,11,23,2,0)
the registry update processing if a patient is defined
"^DD",798,798,11,23,3,0)
in the PATIENT file as a "test patient" (internal value
"^DD",798,798,11,23,4,0)
of the TEST PATIENT INDICATOR field equals to 1).
"^DD",798,798,11,"DT")
3010919
"^DD",798,798.01,0)
SELECTION RULE SUB-FIELD^^1^2
"^DD",798,798.01,0,"DT")
3011009
"^DD",798,798.01,0,"IX","AD",798.01,1)
 
"^DD",798,798.01,0,"IX","B",798.01,.01)
 
"^DD",798,798.01,0,"NM","SELECTION RULE")
 
"^DD",798,798.01,0,"UP")
798
"^DD",798,798.01,.01,0)
SELECTION RULE^MP798.2'^ROR(798.2,^0;1^Q
"^DD",798,798.01,.01,1,0)
^.1
"^DD",798,798.01,.01,1,1,0)
798.01^B
"^DD",798,798.01,.01,1,1,1)
S ^RORDATA(798,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",798,798.01,.01,1,1,2)
K ^RORDATA(798,DA(1),1,"B",$E(X,1,30),DA)
"^DD",798,798.01,.01,1,1,3)
Do not delete!
"^DD",798,798.01,.01,21,0)
^.001^2^2^3011009^^
"^DD",798,798.01,.01,21,1,0)
This field identifies the selection rule that has 
"^DD",798,798.01,.01,21,2,0)
caused addition of the patient to the registry.
"^DD",798,798.01,.01,"DT")
3011009
"^DD",798,798.01,1,0)
DATE^D^^0;2^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798.01,1,1,0)
^.1
"^DD",798,798.01,1,1,1,0)
798.01^AD
"^DD",798,798.01,1,1,1,1)
S ^RORDATA(798,DA(1),1,"AD",$E(X,1,30),DA)=""
"^DD",798,798.01,1,1,1,2)
K ^RORDATA(798,DA(1),1,"AD",$E(X,1,30),DA)
"^DD",798,798.01,1,1,1,3)
Do not delete!
"^DD",798,798.01,1,1,1,"DT")
3000426
"^DD",798,798.01,1,21,0)
^^2^2^3020402^
"^DD",798,798.01,1,21,1,0)
The DATE field contains the date when the patient
"^DD",798,798.01,1,21,2,0)
passed the rule for the first time.
"^DD",798,798.01,1,"DT")
3000426
"^DD",798.1,798.1,0)
FIELD^^26^37
"^DD",798.1,798.1,0,"DDA")
N
"^DD",798.1,798.1,0,"DT")
3020802
"^DD",798.1,798.1,0,"ID","WRITE")
D EN^DDIOL("  "_$P($G(^(0)),U,4),,"?30")
"^DD",798.1,798.1,0,"IX","ACL",798.118,.01)
 
"^DD",798.1,798.1,0,"IX","AEP",798.1,25)
 
"^DD",798.1,798.1,0,"IX","AM",798.1,2.3)
 
"^DD",798.1,798.1,0,"IX","ARULES",798.13,.01)
 
"^DD",798.1,798.1,0,"NM","ROR REGISTRY PARAMETERS")
 
"^DD",798.1,798.1,0,"PT",798,.02)
 
"^DD",798.1,798.1,0,"PT",798.31,.01)
 
"^DD",798.1,798.1,0,"PT",798.5,.02)
 
"^DD",798.1,798.1,0,"PT",798.6,.02)
 
"^DD",798.1,798.1,0,"PT",798.73,.01)
 
"^DD",798.1,798.1,0,"PT",798.8,.03)
 
"^DD",798.1,798.1,0,"PT",799.1,.03)
 
"^DD",798.1,798.1,0,"PT",799.12,.03)
 
"^DD",798.1,798.1,0,"SCR")
I $G(DUZ),$S($D(^XUSEC("ROR VA IRM",DUZ)):1,1:$D(^ROR(798.1,"ACL",DUZ,Y))>1)
"^DD",798.1,798.1,0,"VRPK")
ROR
"^DD",798.1,798.1,.01,0)
REGISTRY NAME^RFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA))  K:$L(X)>30!($L(X)<3)!'(X?1.UNP) X
"^DD",798.1,798.1,.01,1,0)
^.1^^0
"^DD",798.1,798.1,.01,3)
Enter the unique registry name (3-30 characters).
"^DD",798.1,798.1,.01,8.5)
@
"^DD",798.1,798.1,.01,9)
@
"^DD",798.1,798.1,.01,20,0)
^.3LA^1^1
"^DD",798.1,798.1,.01,20,1,0)
DEFINITION
"^DD",798.1,798.1,.01,21,0)
^^9^9^3021101^
"^DD",798.1,798.1,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,.01,21,3,0)
 
"^DD",798.1,798.1,.01,21,4,0)
You can either select an existing registry or add 
"^DD",798.1,798.1,.01,21,5,0)
a new one. Registry names must be unique. Names of
"^DD",798.1,798.1,.01,21,6,0)
the National registries must start with "VA".
"^DD",798.1,798.1,.01,21,7,0)
 
"^DD",798.1,798.1,.01,21,8,0)
You can select records only of those registries
"^DD",798.1,798.1,.01,21,9,0)
that you have appropriate security key(s) for.
"^DD",798.1,798.1,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,.01,"DT")
3011112
"^DD",798.1,798.1,.09,0)
NATIONAL^SX^0:NO;1:YES;^0;11^Q:$$VAEDT^RORDD(798.1,,-1)
"^DD",798.1,798.1,.09,8.5)
@
"^DD",798.1,798.1,.09,9)
@
"^DD",798.1,798.1,.09,20,0)
^.3LA^1^1
"^DD",798.1,798.1,.09,20,1,0)
DEFINITION
"^DD",798.1,798.1,.09,21,0)
^.001^6^6^3020816^^^^
"^DD",798.1,798.1,.09,21,1,0)
ONLY AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN
"^DD",798.1,798.1,.09,21,2,0)
EDIT THIS FIELD!
"^DD",798.1,798.1,.09,21,3,0)
 
"^DD",798.1,798.1,.09,21,4,0)
The national registries must have this field set
"^DD",798.1,798.1,.09,21,5,0)
to "Yes". This prevents local editing of other 
"^DD",798.1,798.1,.09,21,6,0)
fields of national registry definitions.
"^DD",798.1,798.1,.09,"DEL",1,0)
I $$VADEL^RORDD(798.1,,-1)
"^DD",798.1,798.1,.09,"DT")
3011120
"^DD",798.1,798.1,1,0)
REGISTRY UPDATED UNTIL^D^^0;2^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,1,20,0)
^.3LA^1^1
"^DD",798.1,798.1,1,20,1,0)
STATE
"^DD",798.1,798.1,1,21,0)
^.001^9^9^3020816^^
"^DD",798.1,798.1,1,21,1,0)
This field indicates the date of the last 
"^DD",798.1,798.1,1,21,2,0)
successful run of the regular registry update
"^DD",798.1,798.1,1,21,3,0)
process. The search engine looks for new patients
"^DD",798.1,798.1,1,21,4,0)
starting from this date.
"^DD",798.1,798.1,1,21,5,0)
 
"^DD",798.1,798.1,1,21,6,0)
Usually, this field should not be manually edited;
"^DD",798.1,798.1,1,21,7,0)
it is updated automatically. Before initial
"^DD",798.1,798.1,1,21,8,0)
population of the registry enter the date that the
"^DD",798.1,798.1,1,21,9,0)
data search should start from.
"^DD",798.1,798.1,1,23,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,1,23,1,0)
This field is updated automatically by the registry 
"^DD",798.1,798.1,1,23,2,0)
update process after successful completion (see the 
"^DD",798.1,798.1,1,23,3,0)
$$TMSTMP^RORUPD01 function for details).
"^DD",798.1,798.1,1,"DT")
3010928
"^DD",798.1,798.1,2,0)
DATA EXTRACTED UNTIL^D^^0;3^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,2,20,0)
^.3LA^1^1
"^DD",798.1,798.1,2,20,1,0)
STATE
"^DD",798.1,798.1,2,21,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,2,21,1,0)
This field indicates the date of the last 
"^DD",798.1,798.1,2,21,2,0)
successful run of the regular data extraction
"^DD",798.1,798.1,2,21,3,0)
process. Do not edit this field.
"^DD",798.1,798.1,2,23,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,2,23,1,0)
This field is updated automatically by the regular data
"^DD",798.1,798.1,2,23,2,0)
extraction process after its successful completion (see
"^DD",798.1,798.1,2,23,3,0)
the $$TMSTMP^ROREXTUT function for details).
"^DD",798.1,798.1,2,"DT")
3010928
"^DD",798.1,798.1,2.1,0)
LAST BATCH ID^FXI^^0;8^K:X[""""!($A(X)=45) X I $D(X) K:$L(X)>20!($L(X)<1) X
"^DD",798.1,798.1,2.1,3)
The unique ID of the latest batch HL7 message (1-20 characters).
"^DD",798.1,798.1,2.1,8.5)
@
"^DD",798.1,798.1,2.1,9)
@
"^DD",798.1,798.1,2.1,20,0)
^.3LA^1^1
"^DD",798.1,798.1,2.1,20,1,0)
HL7
"^DD",798.1,798.1,2.1,21,0)
^.001^7^7^3020816^^^^
"^DD",798.1,798.1,2.1,21,1,0)
This field contains an identifier of the latest
"^DD",798.1,798.1,2.1,21,2,0)
batch HL7 message created for the registry.
"^DD",798.1,798.1,2.1,21,3,0)
 
"^DD",798.1,798.1,2.1,21,4,0)
Control ID of each individual messages of the
"^DD",798.1,798.1,2.1,21,5,0)
batch is constructed from the value of this field
"^DD",798.1,798.1,2.1,21,6,0)
and a sequential number separated by the '-' 
"^DD",798.1,798.1,2.1,21,7,0)
character.
"^DD",798.1,798.1,2.1,23,0)
^.001^8^8^3020816^^^
"^DD",798.1,798.1,2.1,23,1,0)
The LAST BATCH ID field is automatically populated by
"^DD",798.1,798.1,2.1,23,2,0)
the regular data extraction process every time a batch
"^DD",798.1,798.1,2.1,23,3,0)
HL7 message is successfully generated for the registry.
"^DD",798.1,798.1,2.1,23,4,0)
 
"^DD",798.1,798.1,2.1,23,5,0)
This field is populated with the message control ID
"^DD",798.1,798.1,2.1,23,6,0)
returned by the CREATE^HLTF procedure (see the 
"^DD",798.1,798.1,2.1,23,7,0)
$$CREATE^RORHL7 and $$TMSTMP^ROREXTUT functions for 
"^DD",798.1,798.1,2.1,23,8,0)
details).
"^DD",798.1,798.1,2.1,"DT")
3011121
"^DD",798.1,798.1,2.2,0)
AWAITING ACKNOWLEDGEMENT^D^^0;9^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,2.2,1,0)
^.1
"^DD",798.1,798.1,2.2,1,1,0)
^^TRIGGER^798.1^2.3
"^DD",798.1,798.1,2.2,1,1,1)
Q
"^DD",798.1,798.1,2.2,1,1,2)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(0)=X S Y(1)=$S($D(^ROR(798.1,D0,0)):^(0),1:"") S X=$P(Y(1),U,9)="" I X S X=DIV S Y(1)=$S($D(^ROR(798.1,D0,0)):^(0),1:"") S X=$P(Y(1),U,13),X=X S DIU=X K Y S X="" X ^DD(798.1,2.2,1,1,2.4)
"^DD",798.1,798.1,2.2,1,1,2.4)
S DIH=$G(^ROR(798.1,DIV(0),0)),DIV=X S $P(^(0),U,13)=DIV,DIH=798.1,DIG=2.3 D ^DICR
"^DD",798.1,798.1,2.2,1,1,3)
Do not delete!
"^DD",798.1,798.1,2.2,1,1,"%D",0)
^^4^4^3020403^
"^DD",798.1,798.1,2.2,1,1,"%D",1,0)
This trigger cleares the LAST MESSAGE ID field
"^DD",798.1,798.1,2.2,1,1,"%D",2,0)
when the AWAITING ACKNOWLEDGEMENT field is
"^DD",798.1,798.1,2.2,1,1,"%D",3,0)
cleared. This guaranties that if the expired 
"^DD",798.1,798.1,2.2,1,1,"%D",4,0)
acknowledgement arrives later, it will be ignored.
"^DD",798.1,798.1,2.2,1,1,"CREATE VALUE")
NO EFFECT
"^DD",798.1,798.1,2.2,1,1,"DELETE CONDITION")
AWAITING ACKNOWLEDGEMENT=""
"^DD",798.1,798.1,2.2,1,1,"DELETE VALUE")
""
"^DD",798.1,798.1,2.2,1,1,"FIELD")
LAST MESSAGE ID
"^DD",798.1,798.1,2.2,3)
 
"^DD",798.1,798.1,2.2,20,0)
^.3LA^2^2
"^DD",798.1,798.1,2.2,20,1,0)
HL7
"^DD",798.1,798.1,2.2,20,2,0)
STATE
"^DD",798.1,798.1,2.2,21,0)
^.001^14^14^3020816^^^
"^DD",798.1,798.1,2.2,21,1,0)
This field is set to current date/time after the
"^DD",798.1,798.1,2.2,21,2,0)
data has been successfully sent to the national
"^DD",798.1,798.1,2.2,21,3,0)
registry. Upon successful receiving and processing
"^DD",798.1,798.1,2.2,21,4,0)
of the acknowledgement the value of this field is
"^DD",798.1,798.1,2.2,21,5,0)
deleted.
"^DD",798.1,798.1,2.2,21,6,0)
 
"^DD",798.1,798.1,2.2,21,7,0)
Usually, you should not edit this field. However, 
"^DD",798.1,798.1,2.2,21,8,0)
if some data is sent but the acknowledgement is
"^DD",798.1,798.1,2.2,21,9,0)
not received, no further data transmissions will
"^DD",798.1,798.1,2.2,21,10,0)
take place. If you are absolutely sure that there
"^DD",798.1,798.1,2.2,21,11,0)
will be no acknowledgement from the AAC (for
"^DD",798.1,798.1,2.2,21,12,0)
example, due to a past malfunction), you can
"^DD",798.1,798.1,2.2,21,13,0)
delete the value of this field to resume regular
"^DD",798.1,798.1,2.2,21,14,0)
registry updates and data transmissions.
"^DD",798.1,798.1,2.2,23,0)
^.001^12^12^3020816^^^
"^DD",798.1,798.1,2.2,23,1,0)
This field is populated by the regular data extraction
"^DD",798.1,798.1,2.2,23,2,0)
process (see the $$TMSTMP^ROREXTUT function) and
"^DD",798.1,798.1,2.2,23,3,0)
cleared by the acknowledgement processing (see the
"^DD",798.1,798.1,2.2,23,4,0)
$$UPDPARMS^RORACK function) after its successful
"^DD",798.1,798.1,2.2,23,5,0)
completion.
"^DD",798.1,798.1,2.2,23,6,0)
 
"^DD",798.1,798.1,2.2,23,7,0)
Moreover, if the application acknowledgement is not 
"^DD",798.1,798.1,2.2,23,8,0)
received from AAC during the time frame defined by the
"^DD",798.1,798.1,2.2,23,9,0)
value of the DAYS TO WAIT FOR ACK field, the AWAITING 
"^DD",798.1,798.1,2.2,23,10,0)
ACKNOWLEDGEMENT field will be cleared by the regular 
"^DD",798.1,798.1,2.2,23,11,0)
registry update and data extraction task (see the 
"^DD",798.1,798.1,2.2,23,12,0)
$$CLRACK^RORUTL05 function for details).
"^DD",798.1,798.1,2.2,"DT")
3020401
"^DD",798.1,798.1,2.3,0)
LAST MESSAGE ID^FI^^0;13^K:$L(X)>20!($L(X)<1) X
"^DD",798.1,798.1,2.3,1,0)
^.1
"^DD",798.1,798.1,2.3,1,1,0)
798.1^AM
"^DD",798.1,798.1,2.3,1,1,1)
S ^ROR(798.1,"AM",$E(X,1,30),DA)=""
"^DD",798.1,798.1,2.3,1,1,2)
K ^ROR(798.1,"AM",$E(X,1,30),DA)
"^DD",798.1,798.1,2.3,1,1,3)
Do not delete!
"^DD",798.1,798.1,2.3,1,1,"%D",0)
^^6^6^3020403^
"^DD",798.1,798.1,2.3,1,1,"%D",1,0)
The application acknowledgement handler searches
"^DD",798.1,798.1,2.3,1,1,"%D",2,0)
this cross-reference for the reference message ID
"^DD",798.1,798.1,2.3,1,1,"%D",3,0)
(extracted from the header of the application
"^DD",798.1,798.1,2.3,1,1,"%D",4,0)
acknowledgement) to find the parameters of the
"^DD",798.1,798.1,2.3,1,1,"%D",5,0)
registry that generated the original batch HL7
"^DD",798.1,798.1,2.3,1,1,"%D",6,0)
message.
"^DD",798.1,798.1,2.3,1,1,"DT")
3020325
"^DD",798.1,798.1,2.3,3)
The unique ID of the latest batch HL7 message (1-20 characters).
"^DD",798.1,798.1,2.3,5,1,0)
798.1^2.2^1
"^DD",798.1,798.1,2.3,8.5)
@
"^DD",798.1,798.1,2.3,9)
@
"^DD",798.1,798.1,2.3,20,0)
^.3LA^1^1
"^DD",798.1,798.1,2.3,20,1,0)
HL7
"^DD",798.1,798.1,2.3,21,0)
^.001^5^5^3020816^^
"^DD",798.1,798.1,2.3,21,1,0)
This field contains a message control ID of the
"^DD",798.1,798.1,2.3,21,2,0)
latest batch HL7 message sent to AAC.
"^DD",798.1,798.1,2.3,21,3,0)
 
"^DD",798.1,798.1,2.3,21,4,0)
The application acknowledgement from the AAC will
"^DD",798.1,798.1,2.3,21,5,0)
reference this ID.
"^DD",798.1,798.1,2.3,23,0)
^.001^11^11^3020816^^
"^DD",798.1,798.1,2.3,23,1,0)
This field is automatically populated by the regular
"^DD",798.1,798.1,2.3,23,2,0)
data extraction process every time a batch HL7 message
"^DD",798.1,798.1,2.3,23,3,0)
is sent to AAC. 
"^DD",798.1,798.1,2.3,23,4,0)
 
"^DD",798.1,798.1,2.3,23,5,0)
The control message ID returned by the GENERATE^HLMA
"^DD",798.1,798.1,2.3,23,6,0)
procedure is used to poulate this field. This value may
"^DD",798.1,798.1,2.3,23,7,0)
be different from the value of the LAST BATCH ID field.
"^DD",798.1,798.1,2.3,23,8,0)
 
"^DD",798.1,798.1,2.3,23,9,0)
The field is cleared by the application acknowledgement
"^DD",798.1,798.1,2.3,23,10,0)
handler after successful processing of received batch
"^DD",798.1,798.1,2.3,23,11,0)
acknowledgement (see the $$UPDPARMS^RORACK function).
"^DD",798.1,798.1,2.3,"DT")
3020401
"^DD",798.1,798.1,2.4,0)
LAST IEN EXTRACTED^NJ12,0^^14;1^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,2.4,3)
Enter IEN of the registry record (between 0 and 999999999999).
"^DD",798.1,798.1,2.4,8.5)
@
"^DD",798.1,798.1,2.4,9)
@
"^DD",798.1,798.1,2.4,20,0)
^.3LA^^0
"^DD",798.1,798.1,2.4,21,0)
^.001^12^12^3020816^^^^
"^DD",798.1,798.1,2.4,21,1,0)
This field stores the IEN of the last record
"^DD",798.1,798.1,2.4,21,2,0)
processed by the last registry data extraction
"^DD",798.1,798.1,2.4,21,3,0)
when the size of the HL7 message had reached its
"^DD",798.1,798.1,2.4,21,4,0)
upper limit.
"^DD",798.1,798.1,2.4,21,5,0)
 
"^DD",798.1,798.1,2.4,21,6,0)
The next registry data extraction will start from
"^DD",798.1,798.1,2.4,21,7,0)
the registry record that has an IEN greater than
"^DD",798.1,798.1,2.4,21,8,0)
value of this field.
"^DD",798.1,798.1,2.4,21,9,0)
 
"^DD",798.1,798.1,2.4,21,10,0)
Usually, you should not edit this field. It is 
"^DD",798.1,798.1,2.4,21,11,0)
updated automatically by the registry data 
"^DD",798.1,798.1,2.4,21,12,0)
extraction task.
"^DD",798.1,798.1,2.4,23,0)
^.001^20^20^3020816^^^^
"^DD",798.1,798.1,2.4,23,1,0)
Usually, all new data is sent to the AAC in a single 
"^DD",798.1,798.1,2.4,23,2,0)
message and this field is empty or 0.
"^DD",798.1,798.1,2.4,23,3,0)
 
"^DD",798.1,798.1,2.4,23,4,0)
However, when big amounts of data should be sent, the
"^DD",798.1,798.1,2.4,23,5,0)
ROR software tries to throttle the data flow and even
"^DD",798.1,798.1,2.4,23,6,0)
the spike over the following days.
"^DD",798.1,798.1,2.4,23,7,0)
 
"^DD",798.1,798.1,2.4,23,8,0)
In this case, each data extraction starts from the
"^DD",798.1,798.1,2.4,23,9,0)
registry record that follows the last one processed by
"^DD",798.1,798.1,2.4,23,10,0)
the previous extraction (this field) and continues
"^DD",798.1,798.1,2.4,23,11,0)
until size of the messages reaches its maximum value
"^DD",798.1,798.1,2.4,23,12,0)
(the MAXIMUM MESSAGE SIZE field).
"^DD",798.1,798.1,2.4,23,13,0)
 
"^DD",798.1,798.1,2.4,23,14,0)
The field has the NUMERIC type instead of the POINTER
"^DD",798.1,798.1,2.4,23,15,0)
(to the ROR LOCAL REGISTRY file) to prevent possible
"^DD",798.1,798.1,2.4,23,16,0)
FileMan errors caused by records deleted from the
"^DD",798.1,798.1,2.4,23,17,0)
registry.
"^DD",798.1,798.1,2.4,23,18,0)
 
"^DD",798.1,798.1,2.4,23,19,0)
The field is used and updated by the PROCESS^ROREXT01
"^DD",798.1,798.1,2.4,23,20,0)
function.
"^DD",798.1,798.1,2.4,"DT")
3020801
"^DD",798.1,798.1,3,0)
SELECTION RULE^798.13^^1;0
"^DD",798.1,798.1,3,9)
@
"^DD",798.1,798.1,3,20,0)
^.3LA^1^1
"^DD",798.1,798.1,3,20,1,0)
DEFINITION
"^DD",798.1,798.1,3,21,0)
^.001^8^8^3020816^^
"^DD",798.1,798.1,3,21,1,0)
The SELECTION RULE field contains a list of the 
"^DD",798.1,798.1,3,21,2,0)
top-level selection rules that are used to screen
"^DD",798.1,798.1,3,21,3,0)
the patients to be added to the registry.
"^DD",798.1,798.1,3,21,4,0)
 
"^DD",798.1,798.1,3,21,5,0)
The records of the multiple are uniquely 
"^DD",798.1,798.1,3,21,6,0)
identified by the selection rule names. The "A"
"^DD",798.1,798.1,3,21,7,0)
primary key and the uniqueness index "B" are used
"^DD",798.1,798.1,3,21,8,0)
for this purpose.
"^DD",798.1,798.1,4,0)
SHORT DESCRIPTION^RFX^^0;4^Q:$$VAEDT^RORDD(798.1,$G(DA))  K:$L(X)>40!($L(X)<3) X
"^DD",798.1,798.1,4,3)
Enter a short description of the registry (3-40 characters).
"^DD",798.1,798.1,4,8.5)
@
"^DD",798.1,798.1,4,9)
@
"^DD",798.1,798.1,4,21,0)
^.001^2^2^3020403^^
"^DD",798.1,798.1,4,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,4,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,4,"DT")
3011109
"^DD",798.1,798.1,5,0)
DESCRIPTION^798.15^^2;0
"^DD",798.1,798.1,5,21,0)
^.001^2^2^3011009^^^
"^DD",798.1,798.1,5,21,1,0)
Any additional reference information related to
"^DD",798.1,798.1,5,21,2,0)
the registry may be stored in this field.
"^DD",798.1,798.1,5,23,0)
^.001^1^1^3011009^^
"^DD",798.1,798.1,5,23,1,0)
Content of this field is not used by the application.
"^DD",798.1,798.1,6.1,0)
BEFORE UPDATE^FX^^4;E1,245^Q:$$VAEDT^RORDD(798.1,$G(DA))  Q:$$EP^RORDD(3)
"^DD",798.1,798.1,6.1,3)
Answer must be $$TAG^ROUTINE (5-19 characters in length).
"^DD",798.1,798.1,6.1,8.5)
@
"^DD",798.1,798.1,6.1,9)
@
"^DD",798.1,798.1,6.1,20,0)
^.3LA^1^1
"^DD",798.1,798.1,6.1,20,1,0)
DEFINITION
"^DD",798.1,798.1,6.1,21,0)
^.001^7^7^3020816^^^
"^DD",798.1,798.1,6.1,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,6.1,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,6.1,21,3,0)
 
"^DD",798.1,798.1,6.1,21,4,0)
Enter a full name ($$TAG^ROUTINE) of the external
"^DD",798.1,798.1,6.1,21,5,0)
MUMPS function that will be called before adding a
"^DD",798.1,798.1,6.1,21,6,0)
new record to the registry. This entry point can
"^DD",798.1,798.1,6.1,21,7,0)
be used to prepare any additional data.
"^DD",798.1,798.1,6.1,23,0)
^.001^20^20^3020816^^^
"^DD",798.1,798.1,6.1,23,1,0)
The call-back entry point must accept three parameters:
"^DD",798.1,798.1,6.1,23,2,0)
 
"^DD",798.1,798.1,6.1,23,3,0)
FDA - A reference to a local array that contains 
"^DD",798.1,798.1,6.1,23,4,0)
prepared data (for the UPDATE^DIE FileMan DSB call)
"^DD",798.1,798.1,6.1,23,5,0)
that should be stored as a new record in the ROR LOCAL
"^DD",798.1,798.1,6.1,23,6,0)
REGISTRY (#798) file.
"^DD",798.1,798.1,6.1,23,7,0)
 
"^DD",798.1,798.1,6.1,23,8,0)
The main record uses "+1," placeholder and records of
"^DD",798.1,798.1,6.1,23,9,0)
the SELECTION RULE multiple use placeholders with
"^DD",798.1,798.1,6.1,23,10,0)
numbers starting from 1001.
"^DD",798.1,798.1,6.1,23,11,0)
 
"^DD",798.1,798.1,6.1,23,12,0)
See the source code of the $$ADD^RORUPD50 function and
"^DD",798.1,798.1,6.1,23,13,0)
the FileMan Programmer Manual for further details.
"^DD",798.1,798.1,6.1,23,14,0)
 
"^DD",798.1,798.1,6.1,23,15,0)
PATIEN - Patient IEN (in the file #2)
"^DD",798.1,798.1,6.1,23,16,0)
 
"^DD",798.1,798.1,6.1,23,17,0)
REGIEN - Registry IEN (in the file #798.1)
"^DD",798.1,798.1,6.1,23,18,0)
 
"^DD",798.1,798.1,6.1,23,19,0)
The function should return a negative number in case of
"^DD",798.1,798.1,6.1,23,20,0)
errors. Otherwise, zero should be returned.
"^DD",798.1,798.1,6.1,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,6.1,"DT")
3011120
"^DD",798.1,798.1,6.2,0)
AFTER UPDATE^FX^^5;E1,245^Q:$$VAEDT^RORDD(798.1,$G(DA))  Q:$$EP^RORDD(3)
"^DD",798.1,798.1,6.2,3)
Answer must be $$TAG^ROUTINE (5-19 characters in length).
"^DD",798.1,798.1,6.2,8.5)
@
"^DD",798.1,798.1,6.2,9)
@
"^DD",798.1,798.1,6.2,20,0)
^.3LA^1^1
"^DD",798.1,798.1,6.2,20,1,0)
DEFINITION
"^DD",798.1,798.1,6.2,21,0)
^.001^8^8^3020816^^
"^DD",798.1,798.1,6.2,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,6.2,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,6.2,21,3,0)
 
"^DD",798.1,798.1,6.2,21,4,0)
Enter a full name ($$TAG^ROUTINE) of the external
"^DD",798.1,798.1,6.2,21,5,0)
MUMPS function that will be called after adding a
"^DD",798.1,798.1,6.2,21,6,0)
new record to the registry. This entry point can
"^DD",798.1,798.1,6.2,21,7,0)
be used to create record(s) in additional linked
"^DD",798.1,798.1,6.2,21,8,0)
file(s) of the local registry.
"^DD",798.1,798.1,6.2,23,0)
^.001^11^11^3020816^^
"^DD",798.1,798.1,6.2,23,1,0)
The call-back function must accept three parameters:
"^DD",798.1,798.1,6.2,23,2,0)
 
"^DD",798.1,798.1,6.2,23,3,0)
IEN - An IEN of the newly added record of the ROR LOCAL
"^DD",798.1,798.1,6.2,23,4,0)
REGISTRY file
"^DD",798.1,798.1,6.2,23,5,0)
 
"^DD",798.1,798.1,6.2,23,6,0)
PATIEN - Patient IEN (in file #2)
"^DD",798.1,798.1,6.2,23,7,0)
 
"^DD",798.1,798.1,6.2,23,8,0)
REGIEN - Registry IEN (in file #798.1)
"^DD",798.1,798.1,6.2,23,9,0)
 
"^DD",798.1,798.1,6.2,23,10,0)
The function should return a negative number in case of
"^DD",798.1,798.1,6.2,23,11,0)
errors. Otherwise, zero should be returned.
"^DD",798.1,798.1,6.2,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,6.2,"DT")
3011120
"^DD",798.1,798.1,7,0)
EXTRACT PERIOD FOR NEW PATIENT^NJ4,0X^^0;5^Q:$$VAEDT^RORDD(798.1,$G(DA))  K:+X'=X!(X>3650)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,7,3)
Enter number of days between 1 and 3650.
"^DD",798.1,798.1,7,8.5)
@
"^DD",798.1,798.1,7,9)
@
"^DD",798.1,798.1,7,20,0)
^.3LA^1^1
"^DD",798.1,798.1,7,20,1,0)
DEFINITION
"^DD",798.1,798.1,7,21,0)
^.001^11^11^3020816^^
"^DD",798.1,798.1,7,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,7,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,7,21,3,0)
 
"^DD",798.1,798.1,7,21,4,0)
Enter the number of days that should be subtracted
"^DD",798.1,798.1,7,21,5,0)
from the earliest date when the patient passed one
"^DD",798.1,798.1,7,21,6,0)
of the selection rules. The result will be used as
"^DD",798.1,798.1,7,21,7,0)
the start date of the data extraction for this new
"^DD",798.1,798.1,7,21,8,0)
patient.
"^DD",798.1,798.1,7,21,9,0)
 
"^DD",798.1,798.1,7,21,10,0)
If this field is empty, the default value of 3650
"^DD",798.1,798.1,7,21,11,0)
is used.
"^DD",798.1,798.1,7,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,7,"DT")
3011109
"^DD",798.1,798.1,7,"V",0)
^.12P
"^DD",798.1,798.1,8,0)
ENABLE LOG^S^0:NO;1:YES;^0;6^Q
"^DD",798.1,798.1,8,20,0)
^.3LA^1^1
"^DD",798.1,798.1,8,20,1,0)
PARAMETERS
"^DD",798.1,798.1,8,21,0)
^.001^3^3^3020816^^^^
"^DD",798.1,798.1,8,21,1,0)
Select "Yes" to enable recording of different 
"^DD",798.1,798.1,8,21,2,0)
kinds of events (debug messages, errors, etc.)
"^DD",798.1,798.1,8,21,3,0)
generated by registry processes.
"^DD",798.1,798.1,8,23,0)
^.001^10^10^3020816^^^^
"^DD",798.1,798.1,8,23,1,0)
The ENABLE LOG field controls recording of the errors
"^DD",798.1,798.1,8,23,2,0)
and other events in the log file.
"^DD",798.1,798.1,8,23,3,0)
 
"^DD",798.1,798.1,8,23,4,0)
If internal value of the field is 0 or the field is 
"^DD",798.1,798.1,8,23,5,0)
empty, the recording of all events associated with the
"^DD",798.1,798.1,8,23,6,0)
registry is disabled.
"^DD",798.1,798.1,8,23,7,0)
 
"^DD",798.1,798.1,8,23,8,0)
If internal value of the field is 1, content of the
"^DD",798.1,798.1,8,23,9,0)
LOG EVENTS multiple is analyzed to determine which
"^DD",798.1,798.1,8,23,10,0)
events (errors, warnings, etc.) should be recorded.
"^DD",798.1,798.1,8,"DT")
3000503
"^DD",798.1,798.1,8.1,0)
LOG EVENTS^798.11S^^3;0
"^DD",798.1,798.1,8.1,20,0)
^.3LA^^0
"^DD",798.1,798.1,8.1,21,0)
^.001^8^8^3020816^^^^
"^DD",798.1,798.1,8.1,21,1,0)
The LOG EVENTS multiple contain a list of event 
"^DD",798.1,798.1,8.1,21,2,0)
types that are enabled to record. 
"^DD",798.1,798.1,8.1,21,3,0)
 
"^DD",798.1,798.1,8.1,21,4,0)
If the list is empty and recording is enabled, 
"^DD",798.1,798.1,8.1,21,5,0)
all events except debug messages will be recorded.
"^DD",798.1,798.1,8.1,21,6,0)
 
"^DD",798.1,798.1,8.1,21,7,0)
Otherwise, only recording of the events from the
"^DD",798.1,798.1,8.1,21,8,0)
list and error messages will be enabled.
"^DD",798.1,798.1,9,0)
HL7 SEGMENT^798.19I^^6;0
"^DD",798.1,798.1,9,20,0)
^.3LA^2^2
"^DD",798.1,798.1,9,20,1,0)
HL7
"^DD",798.1,798.1,9,20,2,0)
DEFINITION
"^DD",798.1,798.1,9,21,0)
^.001^16^16^3021227^^^^
"^DD",798.1,798.1,9,21,1,0)
This multiple contains a list of segments that the
"^DD",798.1,798.1,9,21,2,0)
registry HL7 message is composed from. 
"^DD",798.1,798.1,9,21,3,0)
 
"^DD",798.1,798.1,9,21,4,0)
Records of the multiple are uniquely identified by
"^DD",798.1,798.1,9,21,5,0)
the data area code and segment name. The "A" 
"^DD",798.1,798.1,9,21,6,0)
primary key and uniqueness index "KEY" are used
"^DD",798.1,798.1,9,21,7,0)
for this purpose.
"^DD",798.1,798.1,9,21,8,0)
 
"^DD",798.1,798.1,9,21,9,0)
The general structure of the message is hard-coded
"^DD",798.1,798.1,9,21,10,0)
in the message builder (either default or defined
"^DD",798.1,798.1,9,21,11,0)
by the MESSAGE BUILDER field) but you can exclude
"^DD",798.1,798.1,9,21,12,0)
some segments (or fields) from the message by
"^DD",798.1,798.1,9,21,13,0)
deleting them from this list.
"^DD",798.1,798.1,9,21,14,0)
 
"^DD",798.1,798.1,9,21,15,0)
See the source code of the $$MESSAGE^ROREXT02
"^DD",798.1,798.1,9,21,16,0)
function for the further details.
"^DD",798.1,798.1,10,0)
MESSAGE BUILDER^FX^^7;E1,245^Q:$$VAEDT^RORDD(798.1,$G(DA))  Q:$$EP^RORDD(4)
"^DD",798.1,798.1,10,3)
Answer must be $$TAG^ROUTINE (5-19 characters in length).
"^DD",798.1,798.1,10,8.5)
@
"^DD",798.1,798.1,10,9)
@
"^DD",798.1,798.1,10,20,0)
^.3LA^1^1
"^DD",798.1,798.1,10,20,1,0)
DEFINITION
"^DD",798.1,798.1,10,21,0)
^.001^9^9^3020816^^^
"^DD",798.1,798.1,10,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,10,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,10,21,3,0)
 
"^DD",798.1,798.1,10,21,4,0)
Enter a full name ($$TAG^ROUTINE) of the external 
"^DD",798.1,798.1,10,21,5,0)
MUMPS function that will be called to generate the
"^DD",798.1,798.1,10,21,6,0)
HL7 message for each record of the registry.
"^DD",798.1,798.1,10,21,7,0)
 
"^DD",798.1,798.1,10,21,8,0)
If this field has no value, the default entry 
"^DD",798.1,798.1,10,21,9,0)
point ($$MESSAGE^ROREXT02) will be used.
"^DD",798.1,798.1,10,23,0)
^.001^23^23^3020816^^^
"^DD",798.1,798.1,10,23,1,0)
The call-back function must accept four parameters:
"^DD",798.1,798.1,10,23,2,0)
 
"^DD",798.1,798.1,10,23,3,0)
IEN - IEN of the registry record
"^DD",798.1,798.1,10,23,4,0)
 
"^DD",798.1,798.1,10,23,5,0)
PATIEN - Patient IEN (in the file #2)
"^DD",798.1,798.1,10,23,6,0)
 
"^DD",798.1,798.1,10,23,7,0)
STDT - Extract the data from this date
"^DD",798.1,798.1,10,23,8,0)
 
"^DD",798.1,798.1,10,23,9,0)
ENDT - Extract the data until this date
"^DD",798.1,798.1,10,23,10,0)
 
"^DD",798.1,798.1,10,23,11,0)
The function should add the text of the HL7 message 
"^DD",798.1,798.1,10,23,12,0)
after already existing nodes in the standard location:
"^DD",798.1,798.1,10,23,13,0)
^TMP("HLS",$J). DO NOT KILL THIS NODE! It contains the
"^DD",798.1,798.1,10,23,14,0)
previous messages of the batch.
"^DD",798.1,798.1,10,23,15,0)
 
"^DD",798.1,798.1,10,23,16,0)
If the message was generated successfully, the function
"^DD",798.1,798.1,10,23,17,0)
should return zero. Otherwise, either a negative error
"^DD",798.1,798.1,10,23,18,0)
code (in case of an error) or a positive value (if the
"^DD",798.1,798.1,10,23,19,0)
message should be discarded for some reason) must be
"^DD",798.1,798.1,10,23,20,0)
returned. 
"^DD",798.1,798.1,10,23,21,0)
                                                                    
"^DD",798.1,798.1,10,23,22,0)
See the source code of the $$MESSAGE^ROREXT02 function 
"^DD",798.1,798.1,10,23,23,0)
for further details.
"^DD",798.1,798.1,10,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,10,"DT")
3011120
"^DD",798.1,798.1,11,0)
REGISTRY STATUS^S^0:ACTIVE;1:INACTIVE;^0;7^Q
"^DD",798.1,798.1,11,1,0)
^.1^^0
"^DD",798.1,798.1,11,20,0)
^.3LA^1^1
"^DD",798.1,798.1,11,20,1,0)
PARAMETERS
"^DD",798.1,798.1,11,21,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,11,21,1,0)
Select the "INACTIVE" code if you want to exclude
"^DD",798.1,798.1,11,21,2,0)
the registry from the regular registry updates and
"^DD",798.1,798.1,11,21,3,0)
data transmissions.
"^DD",798.1,798.1,11,"DT")
3020424
"^DD",798.1,798.1,12,0)
EXTRACTED RESULT^798.112I^^8;0
"^DD",798.1,798.1,12,9)
@
"^DD",798.1,798.1,12,20,0)
^.3LA^1^1
"^DD",798.1,798.1,12,20,1,0)
DEFINITION
"^DD",798.1,798.1,12,21,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,12,21,1,0)
This multiple contains a list of Lab result codes.
"^DD",798.1,798.1,12,21,2,0)
These results will be extracted and transmitted to
"^DD",798.1,798.1,12,21,3,0)
AAC.
"^DD",798.1,798.1,12,"DT")
3010629
"^DD",798.1,798.1,13,0)
PROTOCOL^*P101'X^ORD(101,^9;1^Q:$$VAEDT^RORDD(798.1,$G(DA))  S DIC("S")="S D=$G(^(0)) I $E($P(D,U),1,3)=""ROR"",$P(D,U,4)=""E""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",798.1,798.1,13,3)
 
"^DD",798.1,798.1,13,8.5)
@
"^DD",798.1,798.1,13,9)
@
"^DD",798.1,798.1,13,12)
Only Event Drivers from the "ROR" namespace can be selected!
"^DD",798.1,798.1,13,12.1)
S DIC("S")="S D=$G(^(0)) I $E($P(D,U),1,3)=""ROR"",$P(D,U,4)=""E"""
"^DD",798.1,798.1,13,20,0)
^.3LA^2^2
"^DD",798.1,798.1,13,20,1,0)
HL7
"^DD",798.1,798.1,13,20,2,0)
DEFINITION
"^DD",798.1,798.1,13,21,0)
^.001^6^6^3020816^^^
"^DD",798.1,798.1,13,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF
"^DD",798.1,798.1,13,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,13,21,3,0)
 
"^DD",798.1,798.1,13,21,4,0)
This field contains a pointer to the protocol in 
"^DD",798.1,798.1,13,21,5,0)
the PROTOCOL file that is used as the event driver
"^DD",798.1,798.1,13,21,6,0)
for sending HL7 messages.
"^DD",798.1,798.1,13,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,13,"DT")
3011112
"^DD",798.1,798.1,13.1,0)
MAXIMUM MESSAGE SIZE^NJ4,1^^9;2^K:+X'=X!(X>99)!(X<0)!(X?.E1"."2N.N) X
"^DD",798.1,798.1,13.1,3)
Enter maximum size (in megabytes) between 0 and 99, 1 decimal digit.
"^DD",798.1,798.1,13.1,8.5)
@
"^DD",798.1,798.1,13.1,9)
@
"^DD",798.1,798.1,13.1,20,0)
^.3LA^2^2
"^DD",798.1,798.1,13.1,20,1,0)
HL7
"^DD",798.1,798.1,13.1,20,2,0)
PARAMETERS
"^DD",798.1,798.1,13.1,21,0)
^.001^8^8^3020816^^^
"^DD",798.1,798.1,13.1,21,1,0)
This field stores the maximum size (in megabytes)
"^DD",798.1,798.1,13.1,21,2,0)
of a batch HL7 message that can be sent to Austin
"^DD",798.1,798.1,13.1,21,3,0)
Automation Center (AAC). If this field is empty or
"^DD",798.1,798.1,13.1,21,4,0)
contains 0, the size is not limited.
"^DD",798.1,798.1,13.1,21,5,0)
 
"^DD",798.1,798.1,13.1,21,6,0)
You must co-ordinate your intentions with AAC
"^DD",798.1,798.1,13.1,21,7,0)
support personnel if you are going to edit this
"^DD",798.1,798.1,13.1,21,8,0)
field.
"^DD",798.1,798.1,13.1,23,0)
^.001^8^8^3020816^^^
"^DD",798.1,798.1,13.1,23,1,0)
Actual size of an HL7 batch can be greater than the
"^DD",798.1,798.1,13.1,23,2,0)
value of this field because the software does not break
"^DD",798.1,798.1,13.1,23,3,0)
in the middle of an individual HL7 message.
"^DD",798.1,798.1,13.1,23,4,0)
 
"^DD",798.1,798.1,13.1,23,5,0)
For example, if the maximum size is 10Mb, the current
"^DD",798.1,798.1,13.1,23,6,0)
size is 9Mb and 3Mb should be sent for the patient
"^DD",798.1,798.1,13.1,23,7,0)
being processed then the actual size of the batch will
"^DD",798.1,798.1,13.1,23,8,0)
be 12Mb.
"^DD",798.1,798.1,13.1,"DT")
3020730
"^DD",798.1,798.1,14,0)
COORDINATOR^798.114P^^10;0
"^DD",798.1,798.1,14,21,0)
^^2^2^3011012^
"^DD",798.1,798.1,14,21,1,0)
This multiple contains a list of the registry 
"^DD",798.1,798.1,14,21,2,0)
coordinators.
"^DD",798.1,798.1,15.1,0)
LAG DAYS^NJ1,0^^11;1^K:+X'=X!(X>7)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,15.1,3)
Enter number of days between 1 and 7.
"^DD",798.1,798.1,15.1,20,0)
^.3LA^1^1
"^DD",798.1,798.1,15.1,20,1,0)
PARAMETERS
"^DD",798.1,798.1,15.1,21,0)
^.001^12^12^3020816^^^
"^DD",798.1,798.1,15.1,21,1,0)
Number of days that defines an overlap of the data
"^DD",798.1,798.1,15.1,21,2,0)
searches during the registry updates and a data
"^DD",798.1,798.1,15.1,21,3,0)
extraction delay during the regular data
"^DD",798.1,798.1,15.1,21,4,0)
extractions.
"^DD",798.1,798.1,15.1,21,5,0)
 
"^DD",798.1,798.1,15.1,21,6,0)
If this field is empty, the default value of 1 is 
"^DD",798.1,798.1,15.1,21,7,0)
used by the registry update and data extraction
"^DD",798.1,798.1,15.1,21,8,0)
processes.
"^DD",798.1,798.1,15.1,21,9,0)
 
"^DD",798.1,798.1,15.1,21,10,0)
See the package documentation or Technical
"^DD",798.1,798.1,15.1,21,11,0)
Description of the field in the data dictionary
"^DD",798.1,798.1,15.1,21,12,0)
for more information.
"^DD",798.1,798.1,15.1,23,0)
^.001^37^37^3020816^^^
"^DD",798.1,798.1,15.1,23,1,0)
Clinical data may be entered to the VistA system later
"^DD",798.1,798.1,15.1,23,2,0)
than they are available. For example, an encounter that
"^DD",798.1,798.1,15.1,23,3,0)
occurred today may not get entered into the system
"^DD",798.1,798.1,15.1,23,4,0)
until tomorrow.
"^DD",798.1,798.1,15.1,23,5,0)
 
"^DD",798.1,798.1,15.1,23,6,0)
Because of this data may be missed by the registry
"^DD",798.1,798.1,15.1,23,7,0)
update and data extraction processes if they look for
"^DD",798.1,798.1,15.1,23,8,0)
the data until the current date and then continue from
"^DD",798.1,798.1,15.1,23,9,0)
that point next time.
"^DD",798.1,798.1,15.1,23,10,0)
 
"^DD",798.1,798.1,15.1,23,11,0)
To avoid this problem data search intervals are 
"^DD",798.1,798.1,15.1,23,12,0)
overlapped by the number of days indicated by this 
"^DD",798.1,798.1,15.1,23,13,0)
field. The registry update process looks for new data 
"^DD",798.1,798.1,15.1,23,14,0)
not from the end date of its previous run but from the 
"^DD",798.1,798.1,15.1,23,15,0)
date that is earlier by the number of days from this 
"^DD",798.1,798.1,15.1,23,16,0)
field. This overlap increases chances of the data
"^DD",798.1,798.1,15.1,23,17,0)
entered retrospectively to be found by the next run of
"^DD",798.1,798.1,15.1,23,18,0)
the registry update process.
"^DD",798.1,798.1,15.1,23,19,0)
 
"^DD",798.1,798.1,15.1,23,20,0)
Moreover, the regular data extraction process extracts
"^DD",798.1,798.1,15.1,23,21,0)
data not until the date when the process is run but
"^DD",798.1,798.1,15.1,23,22,0)
until the date that is earlier by the number of days
"^DD",798.1,798.1,15.1,23,23,0)
from this field. So, this is a delay that increases
"^DD",798.1,798.1,15.1,23,24,0)
chances of the data to be entered retrospectively
"^DD",798.1,798.1,15.1,23,25,0)
before the next data extraction.
"^DD",798.1,798.1,15.1,23,26,0)
 
"^DD",798.1,798.1,15.1,23,27,0)
If the value of this field is too small, you may miss 
"^DD",798.1,798.1,15.1,23,28,0)
some data entered retrospectively. If it is too big,
"^DD",798.1,798.1,15.1,23,29,0)
the national registry will not contain the up to date
"^DD",798.1,798.1,15.1,23,30,0)
information (data will be delayed by the number of days
"^DD",798.1,798.1,15.1,23,31,0)
indicated by this field) and the registry update
"^DD",798.1,798.1,15.1,23,32,0)
process will take more time to complete (this time will
"^DD",798.1,798.1,15.1,23,33,0)
be spent processing the data from the overlap
"^DD",798.1,798.1,15.1,23,34,0)
interval).
"^DD",798.1,798.1,15.1,23,35,0)
 
"^DD",798.1,798.1,15.1,23,36,0)
When several registries are processed at the same time,
"^DD",798.1,798.1,15.1,23,37,0)
the maximum value of the LAG DAYS field is used.
"^DD",798.1,798.1,15.1,"DT")
3020426
"^DD",798.1,798.1,15.9,0)
DAYS TO WAIT FOR ACK^NJ1,0^^11;2^K:+X'=X!(X>7)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,15.9,3)
Type a number of days between 0 and 7.
"^DD",798.1,798.1,15.9,20,0)
^.3LA^2^2
"^DD",798.1,798.1,15.9,20,1,0)
HL7
"^DD",798.1,798.1,15.9,20,2,0)
PARAMETERS
"^DD",798.1,798.1,15.9,21,0)
^.001^4^4^3020816^^^^
"^DD",798.1,798.1,15.9,21,1,0)
The value of this field determines how many days
"^DD",798.1,798.1,15.9,21,2,0)
the package waits for an application
"^DD",798.1,798.1,15.9,21,3,0)
acknowledgement from the AAC. The default waiting
"^DD",798.1,798.1,15.9,21,4,0)
time is 3 days.
"^DD",798.1,798.1,15.9,23,0)
^.001^12^12^3020816^^^^
"^DD",798.1,798.1,15.9,23,1,0)
If the acknowledgement is not received in the time
"^DD",798.1,798.1,15.9,23,2,0)
frame defined by the value of this field, the fields
"^DD",798.1,798.1,15.9,23,3,0)
related to the most recent data transmission (AWAITING
"^DD",798.1,798.1,15.9,23,4,0)
ACKNOWLEDGEMENT, LAST MESSAGE ID, etc) will be cleared
"^DD",798.1,798.1,15.9,23,5,0)
automatically. This will resume the regular registry
"^DD",798.1,798.1,15.9,23,6,0)
updates and data transmissions.
"^DD",798.1,798.1,15.9,23,7,0)
 
"^DD",798.1,798.1,15.9,23,8,0)
If this particular acknowledgement arrives later, it
"^DD",798.1,798.1,15.9,23,9,0)
will be ignored because a new data transmission will
"^DD",798.1,798.1,15.9,23,10,0)
probably have taken place already (it will include data
"^DD",798.1,798.1,15.9,23,11,0)
that has not been delivered by the previous
"^DD",798.1,798.1,15.9,23,12,0)
transmission along with the new data).
"^DD",798.1,798.1,15.9,"DT")
3020425
"^DD",798.1,798.1,16,0)
USER^798.116A^^13;0
"^DD",798.1,798.1,16,20,0)
^.3LA^^0
"^DD",798.1,798.1,17,0)
DRUG THERAPY LIST^798.117^^12;0
"^DD",798.1,798.1,17,9)
@
"^DD",798.1,798.1,17,20,0)
^.3LA^1^1
"^DD",798.1,798.1,17,20,1,0)
DEFINITION
"^DD",798.1,798.1,17,21,0)
^.001^3^3^3020816^^^^
"^DD",798.1,798.1,17,21,1,0)
A list of National Drug Codes to use in the Drug 
"^DD",798.1,798.1,17,21,2,0)
Therapy report. Use of the drugs listed here will
"^DD",798.1,798.1,17,21,3,0)
be reported in the Drug Therapy report.
"^DD",798.1,798.1,18,0)
SECURITY KEY^798.118^^18;0
"^DD",798.1,798.1,18,9)
@
"^DD",798.1,798.1,18,20,0)
^.3LA^1^1
"^DD",798.1,798.1,18,20,1,0)
DEFINITION
"^DD",798.1,798.1,18,21,0)
^.001^2^2^3020816^^^^
"^DD",798.1,798.1,18,21,1,0)
This multiple stores a list of security keys 
"^DD",798.1,798.1,18,21,2,0)
associated with the registry.
"^DD",798.1,798.1,19.1,0)
NUMBER OF PATIENTS^NJ9,0I^^19;1^K:+X'=X!(X>999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,19.1,3)
Type a Number between 0 and 999999999, 0 Decimal Digits
"^DD",798.1,798.1,19.1,8.5)
@
"^DD",798.1,798.1,19.1,9)
@
"^DD",798.1,798.1,19.1,20,0)
^.3LA^1^1
"^DD",798.1,798.1,19.1,20,1,0)
STATE
"^DD",798.1,798.1,19.1,21,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,19.1,21,1,0)
The NUMBER OF PATIENTS field contains total number
"^DD",798.1,798.1,19.1,21,2,0)
of patients in the registry right after the last
"^DD",798.1,798.1,19.1,21,3,0)
registry update.
"^DD",798.1,798.1,19.1,23,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,19.1,23,1,0)
The field cannot be edited. It is updated automatically
"^DD",798.1,798.1,19.1,23,2,0)
by the $$UPDDEM^RORUPD51 function during the registry
"^DD",798.1,798.1,19.1,23,3,0)
update.
"^DD",798.1,798.1,19.1,"DT")
3020131
"^DD",798.1,798.1,19.2,0)
NUMBER OF ACTIVE PATIENTS^NJ9,0I^^19;2^K:+X'=X!(X>999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,19.2,3)
Type a Number between 0 and 999999999, 0 Decimal Digits
"^DD",798.1,798.1,19.2,8.5)
@
"^DD",798.1,798.1,19.2,9)
@
"^DD",798.1,798.1,19.2,20,0)
^.3LA^1^1
"^DD",798.1,798.1,19.2,20,1,0)
STATE
"^DD",798.1,798.1,19.2,21,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,19.2,21,1,0)
The NUMBER OF ACTIVE PATIENTS field contains 
"^DD",798.1,798.1,19.2,21,2,0)
number of active patients in the registry right
"^DD",798.1,798.1,19.2,21,3,0)
after the last registry update.
"^DD",798.1,798.1,19.2,23,0)
^.001^3^3^3020816^^
"^DD",798.1,798.1,19.2,23,1,0)
The field cannot be edited. It is updated automatically
"^DD",798.1,798.1,19.2,23,2,0)
by the $$UPDDEM^RORUPD51 function during the registry
"^DD",798.1,798.1,19.2,23,3,0)
update.
"^DD",798.1,798.1,19.2,"DT")
3020131
"^DD",798.1,798.1,21.01,0)
HDT START DATE^RD^^21;1^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,21.01,21,0)
^.001^6^6^3011109^^
"^DD",798.1,798.1,21.01,21,1,0)
This field indicates the start date for the 
"^DD",798.1,798.1,21.01,21,2,0)
historical data extraction.  
"^DD",798.1,798.1,21.01,21,3,0)
                                 
"^DD",798.1,798.1,21.01,21,4,0)
Usually, this field should not be edited. Its
"^DD",798.1,798.1,21.01,21,5,0)
predefined value is distributed within the package
"^DD",798.1,798.1,21.01,21,6,0)
KIDS build.
"^DD",798.1,798.1,21.01,"DT")
3011109
"^DD",798.1,798.1,21.02,0)
HDT END DATE^D^^21;2^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,21.02,21,0)
^^6^6^3020508^
"^DD",798.1,798.1,21.02,21,1,0)
This field indicates the end date for the 
"^DD",798.1,798.1,21.02,21,2,0)
historical data extraction.
"^DD",798.1,798.1,21.02,21,3,0)
 
"^DD",798.1,798.1,21.02,21,4,0)
Usually, this field should not be edited. It is 
"^DD",798.1,798.1,21.02,21,5,0)
populated automatically by the registry setup 
"^DD",798.1,798.1,21.02,21,6,0)
task.
"^DD",798.1,798.1,21.02,23,0)
^^1^1^3020508^
"^DD",798.1,798.1,21.02,23,1,0)
See the $$UPDHDTRP^RORSETU2 function for details.
"^DD",798.1,798.1,21.02,"DT")
3011107
"^DD",798.1,798.1,21.03,0)
HDT OUTPUT DIRECTORY^F^^21.03;E1,245^K:$L(X)>245!($L(X)<1) X
"^DD",798.1,798.1,21.03,3)
Enter a valid name of the output directory (1-245 characters).
"^DD",798.1,798.1,21.03,21,0)
^^19^19^3011107^
"^DD",798.1,798.1,21.03,21,1,0)
A directory must be created within the file system
"^DD",798.1,798.1,21.03,21,2,0)
of the host operating system (VMS, Windows,
"^DD",798.1,798.1,21.03,21,3,0)
etc).  Text files containing historical data in
"^DD",798.1,798.1,21.03,21,4,0)
the HL7 format will be created in this directory
"^DD",798.1,798.1,21.03,21,5,0)
by the data extraction tasks.
"^DD",798.1,798.1,21.03,21,6,0)
                                 
"^DD",798.1,798.1,21.03,21,7,0)
The full name of the directory must be entered as
"^DD",798.1,798.1,21.03,21,8,0)
a value of this field. For example, the value can
"^DD",798.1,798.1,21.03,21,9,0)
look something like this: 
"^DD",798.1,798.1,21.03,21,10,0)
                                 
"^DD",798.1,798.1,21.03,21,11,0)
 VA2$:[OUTPUT] - VAX VMS 
"^DD",798.1,798.1,21.03,21,12,0)
 D:\Output\    - Windows, MS-DOS 
"^DD",798.1,798.1,21.03,21,13,0)
                                 
"^DD",798.1,798.1,21.03,21,14,0)
Because a file name will be concatenated to the
"^DD",798.1,798.1,21.03,21,15,0)
directory name, the trailing slash in the Windows
"^DD",798.1,798.1,21.03,21,16,0)
directory name is required.  
"^DD",798.1,798.1,21.03,21,17,0)
                                 
"^DD",798.1,798.1,21.03,21,18,0)
Do not forget to enable read/write access to this
"^DD",798.1,798.1,21.03,21,19,0)
directory for M processes!
"^DD",798.1,798.1,21.03,"DT")
3011108
"^DD",798.1,798.1,21.04,0)
LOCAL DATA RESENT^D^^21;3^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,21.04,8.5)
@
"^DD",798.1,798.1,21.04,9)
@
"^DD",798.1,798.1,21.04,20,0)
^.3LA^1^1
"^DD",798.1,798.1,21.04,20,1,0)
STATE
"^DD",798.1,798.1,21.04,21,0)
^.001^10^10^3020816^^^^
"^DD",798.1,798.1,21.04,21,1,0)
This field holds the date when all local registry 
"^DD",798.1,798.1,21.04,21,2,0)
data was resent to AAC after the installation (to 
"^DD",798.1,798.1,21.04,21,3,0)
fix the data incorrectly overwritten with the 
"^DD",798.1,798.1,21.04,21,4,0)
historical data).
"^DD",798.1,798.1,21.04,21,5,0)
 
"^DD",798.1,798.1,21.04,21,6,0)
Usually, you should not modify this field. If, by
"^DD",798.1,798.1,21.04,21,7,0)
some reason, you need to resend all local registry
"^DD",798.1,798.1,21.04,21,8,0)
and demographic data to AAC, you should clear this
"^DD",798.1,798.1,21.04,21,9,0)
field. The data will be resent automatically 
"^DD",798.1,798.1,21.04,21,10,0)
during the next nightly transmission.
"^DD",798.1,798.1,21.04,23,0)
^.001^4^4^3020816^^^^
"^DD",798.1,798.1,21.04,23,1,0)
The value of this field is analyzed and modified by the
"^DD",798.1,798.1,21.04,23,2,0)
$$REMARK^RORUTL05 function. The function is called by
"^DD",798.1,798.1,21.04,23,3,0)
the nightly registry update and data transmission task
"^DD",798.1,798.1,21.04,23,4,0)
(TASK^ROR).
"^DD",798.1,798.1,21.04,"DT")
3020508
"^DD",798.1,798.1,21.05,0)
HDT DATE/TIME^DI^^21;4^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798.1,798.1,21.05,8.5)
@
"^DD",798.1,798.1,21.05,9)
@
"^DD",798.1,798.1,21.05,21,0)
^^4^4^3020508^
"^DD",798.1,798.1,21.05,21,1,0)
This field is initialized with the current 
"^DD",798.1,798.1,21.05,21,2,0)
date/time by the registry setup task upon
"^DD",798.1,798.1,21.05,21,3,0)
successful completion of the initial registry
"^DD",798.1,798.1,21.05,21,4,0)
population.
"^DD",798.1,798.1,21.05,23,0)
^^10^10^3020508^
"^DD",798.1,798.1,21.05,23,1,0)
The field is populated by the $$UPDHDTRP^RORSETU2 
"^DD",798.1,798.1,21.05,23,2,0)
function during the registry setup.
"^DD",798.1,798.1,21.05,23,3,0)
 
"^DD",798.1,798.1,21.05,23,4,0)
The historical data extraction tasks do not process the
"^DD",798.1,798.1,21.05,23,5,0)
registry records that were added after this date. This
"^DD",798.1,798.1,21.05,23,6,0)
prevents sending the same data twice (by the regular
"^DD",798.1,798.1,21.05,23,7,0)
data extraction process and the historical data
"^DD",798.1,798.1,21.05,23,8,0)
extraction task).
"^DD",798.1,798.1,21.05,23,9,0)
 
"^DD",798.1,798.1,21.05,23,10,0)
Do not delete value of this field!
"^DD",798.1,798.1,21.05,"DT")
3020401
"^DD",798.1,798.1,25,0)
ENABLE PROTOCOLS^S^0:NO;1:YES;^0;14^Q
"^DD",798.1,798.1,25,1,0)
^.1
"^DD",798.1,798.1,25,1,1,0)
798.1^AEP^MUMPS
"^DD",798.1,798.1,25,1,1,1)
S:X ^ROR(798.1,"AEP",DA)=""
"^DD",798.1,798.1,25,1,1,2)
K ^ROR(798.1,"AEP",DA)
"^DD",798.1,798.1,25,1,1,3)
Do not delete!
"^DD",798.1,798.1,25,1,1,"%D",0)
^^10^10^3020418^
"^DD",798.1,798.1,25,1,1,"%D",1,0)
This cross-reference controls the package event 
"^DD",798.1,798.1,25,1,1,"%D",2,0)
protocols.
"^DD",798.1,798.1,25,1,1,"%D",3,0)
 
"^DD",798.1,798.1,25,1,1,"%D",4,0)
If at least one registry has the ENABLE PROTOCOLS
"^DD",798.1,798.1,25,1,1,"%D",5,0)
field set to "YES", the ^ROR(798.1,"AEP") node
"^DD",798.1,798.1,25,1,1,"%D",6,0)
will be defined and the protocols will call the
"^DD",798.1,798.1,25,1,1,"%D",7,0)
processing routines.
"^DD",798.1,798.1,25,1,1,"%D",8,0)
 
"^DD",798.1,798.1,25,1,1,"%D",9,0)
Otherwise, they will run idle (unless they are 
"^DD",798.1,798.1,25,1,1,"%D",10,0)
disabled or unsubscribed manually).
"^DD",798.1,798.1,25,1,1,"DT")
3020418
"^DD",798.1,798.1,25,20,0)
^.3LA^1^1
"^DD",798.1,798.1,25,20,1,0)
PARAMETERS
"^DD",798.1,798.1,25,21,0)
^.001^13^13^3020816^^
"^DD",798.1,798.1,25,21,1,0)
If this field is set to "Yes", event protocols
"^DD",798.1,798.1,25,21,2,0)
will be used by the package to speed up the 
"^DD",798.1,798.1,25,21,3,0)
registry processing.
"^DD",798.1,798.1,25,21,4,0)
 
"^DD",798.1,798.1,25,21,5,0)
The protocols create references to patient events
"^DD",798.1,798.1,25,21,6,0)
in the ROR PENDING PATIENT file. Only those 
"^DD",798.1,798.1,25,21,7,0)
patients that have new references will be 
"^DD",798.1,798.1,25,21,8,0)
processed by the next registry update.
"^DD",798.1,798.1,25,21,9,0)
 
"^DD",798.1,798.1,25,21,10,0)
If several registries are updated at the same 
"^DD",798.1,798.1,25,21,11,0)
time and at least one of them has this field set 
"^DD",798.1,798.1,25,21,12,0)
to "Yes", all these registries will be processed 
"^DD",798.1,798.1,25,21,13,0)
using event references.
"^DD",798.1,798.1,25,23,0)
^.001^11^11^3020816^^
"^DD",798.1,798.1,25,23,1,0)
This field controls both the registry update engine 
"^DD",798.1,798.1,25,23,2,0)
and the event protocols.
"^DD",798.1,798.1,25,23,3,0)
 
"^DD",798.1,798.1,25,23,4,0)
If at least one of the defined registries enables the
"^DD",798.1,798.1,25,23,5,0)
protocols, they will process the events and create
"^DD",798.1,798.1,25,23,6,0)
references in the ROR PENDING PATIENT file (#798.3).
"^DD",798.1,798.1,25,23,7,0)
 
"^DD",798.1,798.1,25,23,8,0)
Otherwise, the protocols will be executed (if they are
"^DD",798.1,798.1,25,23,9,0)
not disabled or unsubscribed manually) but will not
"^DD",798.1,798.1,25,23,10,0)
call processing routines and will not create references
"^DD",798.1,798.1,25,23,11,0)
in the file #798.3.
"^DD",798.1,798.1,25,"DT")
3020418
"^DD",798.1,798.1,26,0)
EXCLUDE EMPLOYEES^SX^0:NO;1:YES;^0;10^Q:$$VAEDT^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,26,8.5)
@
"^DD",798.1,798.1,26,9)
@
"^DD",798.1,798.1,26,20,0)
^.3LA^1^1
"^DD",798.1,798.1,26,20,1,0)
DEFINITION
"^DD",798.1,798.1,26,21,0)
^.001^6^6^3020816^^^^
"^DD",798.1,798.1,26,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,26,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,26,21,3,0)
 
"^DD",798.1,798.1,26,21,4,0)
If this field is set to "Yes", patients who are
"^DD",798.1,798.1,26,21,5,0)
employees will not get processed by the registry
"^DD",798.1,798.1,26,21,6,0)
update or data extraction functions.
"^DD",798.1,798.1,26,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,26,"DT")
3020802
"^DD",798.1,798.11,0)
LOG EVENTS SUB-FIELD^^.01^1
"^DD",798.1,798.11,0,"DT")
3010712
"^DD",798.1,798.11,0,"IX","B",798.11,.01)
 
"^DD",798.1,798.11,0,"NM","LOG EVENTS")
 
"^DD",798.1,798.11,0,"UP")
798.1
"^DD",798.1,798.11,.01,0)
LOG EVENT TYPE^MS^1:Debug;2:Information;3:Data Quality;4:Warning;5:Database Error;6:Error;^0;1^Q
"^DD",798.1,798.11,.01,1,0)
^.1
"^DD",798.1,798.11,.01,1,1,0)
798.11^B
"^DD",798.1,798.11,.01,1,1,1)
S ^ROR(798.1,DA(1),3,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.11,.01,1,1,2)
K ^ROR(798.1,DA(1),3,"B",$E(X,1,30),DA)
"^DD",798.1,798.11,.01,1,1,3)
Do not delete!
"^DD",798.1,798.11,.01,21,0)
^^10^10^3020403^
"^DD",798.1,798.11,.01,21,1,0)
Select the type of the event if you want to enable
"^DD",798.1,798.11,.01,21,2,0)
recording of these events. If the list is empty,
"^DD",798.1,798.11,.01,21,3,0)
recording of all events is enabled. Otherwise,
"^DD",798.1,798.11,.01,21,4,0)
only events from the list and error messages will 
"^DD",798.1,798.11,.01,21,5,0)
be recorded.
"^DD",798.1,798.11,.01,21,6,0)
 
"^DD",798.1,798.11,.01,21,7,0)
Debug messages are exclusions from this rule (they
"^DD",798.1,798.11,.01,21,8,0)
are not logged if the ENABLE LOG field is set to
"^DD",798.1,798.11,.01,21,9,0)
"Yes" and this multiple is empty). Their recording
"^DD",798.1,798.11,.01,21,10,0)
can be enabled only explicitly.
"^DD",798.1,798.11,.01,23,0)
^^9^9^3020403^
"^DD",798.1,798.11,.01,23,1,0)
If several registries are processed at the same time,
"^DD",798.1,798.11,.01,23,2,0)
the recording parameters are combined.
"^DD",798.1,798.11,.01,23,3,0)
 
"^DD",798.1,798.11,.01,23,4,0)
If one of the registries requests recording of all 
"^DD",798.1,798.11,.01,23,5,0)
events, all events except the debug messages (type 1)
"^DD",798.1,798.11,.01,23,6,0)
will be recorded for all registries.
"^DD",798.1,798.11,.01,23,7,0)
 
"^DD",798.1,798.11,.01,23,8,0)
Otherwise, merged content of the LOG EVENT TYPE
"^DD",798.1,798.11,.01,23,9,0)
multiples will determine the events to be recorded.
"^DD",798.1,798.11,.01,"DT")
3010712
"^DD",798.1,798.112,0)
EXTRACTED RESULT SUB-FIELD^^.02^2
"^DD",798.1,798.112,0,"DT")
3010629
"^DD",798.1,798.112,0,"ID","WRITE")
D EN^DDIOL($P(^(0),U,2),"","?20")
"^DD",798.1,798.112,0,"IX","B",798.112,.01)
 
"^DD",798.1,798.112,0,"IX","C",798.112,.02)
 
"^DD",798.1,798.112,0,"NM","EXTRACTED RESULT")
 
"^DD",798.1,798.112,0,"UP")
798.1
"^DD",798.1,798.112,.01,0)
LOINC CODE^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:X'?1(1.7N,1"*") X
"^DD",798.1,798.112,.01,1,0)
^.1
"^DD",798.1,798.112,.01,1,1,0)
798.112^B
"^DD",798.1,798.112,.01,1,1,1)
S ^ROR(798.1,DA(1),8,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.112,.01,1,1,2)
K ^ROR(798.1,DA(1),8,"B",$E(X,1,30),DA)
"^DD",798.1,798.112,.01,1,1,3)
Do not delete!
"^DD",798.1,798.112,.01,1,1,"DT")
3010716
"^DD",798.1,798.112,.01,3)
Answer must be 1-7 characters in length.
"^DD",798.1,798.112,.01,8.5)
@
"^DD",798.1,798.112,.01,9)
@
"^DD",798.1,798.112,.01,21,0)
^^11^11^3011015^
"^DD",798.1,798.112,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.112,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.112,.01,21,3,0)
 
"^DD",798.1,798.112,.01,21,4,0)
Enter the unique numeric LOINC code (without the
"^DD",798.1,798.112,.01,21,5,0)
check digit) of the Lab result to be extracted. If
"^DD",798.1,798.112,.01,21,6,0)
you want to use only NLT code, enter zero as the
"^DD",798.1,798.112,.01,21,7,0)
value of this field.
"^DD",798.1,798.112,.01,21,8,0)
 
"^DD",798.1,798.112,.01,21,9,0)
If you want to extract all results, create a
"^DD",798.1,798.112,.01,21,10,0)
record in this multiple containing the "*" 
"^DD",798.1,798.112,.01,21,11,0)
character in this field.
"^DD",798.1,798.112,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.112,.01,"DT")
3010716
"^DD",798.1,798.112,.02,0)
NLT CODE^FX^^0;2^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:'(X?5N1"."4.5N) X
"^DD",798.1,798.112,.02,1,0)
^.1
"^DD",798.1,798.112,.02,1,1,0)
798.112^C
"^DD",798.1,798.112,.02,1,1,1)
S ^ROR(798.1,DA(1),8,"C",$E(X,1,30),DA)=""
"^DD",798.1,798.112,.02,1,1,2)
K ^ROR(798.1,DA(1),8,"C",$E(X,1,30),DA)
"^DD",798.1,798.112,.02,1,1,3)
Do not delete!
"^DD",798.1,798.112,.02,1,1,"DT")
3010716
"^DD",798.1,798.112,.02,3)
Answer must be 10-11 characters in length.
"^DD",798.1,798.112,.02,8.5)
@
"^DD",798.1,798.112,.02,9)
@
"^DD",798.1,798.112,.02,21,0)
^^8^8^3011015^
"^DD",798.1,798.112,.02,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.112,.02,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.112,.02,21,3,0)
 
"^DD",798.1,798.112,.02,21,4,0)
Enter the unique NLT code of the Lab result to be
"^DD",798.1,798.112,.02,21,5,0)
extracted. Both LOINC and NLT codes (if available)
"^DD",798.1,798.112,.02,21,6,0)
are used for searching the Lab results. If you 
"^DD",798.1,798.112,.02,21,7,0)
want to use only the LOINC code, leave this field 
"^DD",798.1,798.112,.02,21,8,0)
empty.
"^DD",798.1,798.112,.02,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.112,.02,"DT")
3010716
"^DD",798.1,798.114,0)
COORDINATOR SUB-FIELD^^.01^1
"^DD",798.1,798.114,0,"DT")
3010907
"^DD",798.1,798.114,0,"IX","B",798.114,.01)
 
"^DD",798.1,798.114,0,"NM","COORDINATOR")
 
"^DD",798.1,798.114,0,"UP")
798.1
"^DD",798.1,798.114,.01,0)
COORDINATOR^MP200'X^VA(200,^0;1^S:$D(X) DINUM=X
"^DD",798.1,798.114,.01,1,0)
^.1
"^DD",798.1,798.114,.01,1,1,0)
798.114^B
"^DD",798.1,798.114,.01,1,1,1)
S ^ROR(798.1,DA(1),10,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.114,.01,1,1,2)
K ^ROR(798.1,DA(1),10,"B",$E(X,1,30),DA)
"^DD",798.1,798.114,.01,1,1,3)
Do not delete!
"^DD",798.1,798.114,.01,21,0)
^^4^4^3020403^
"^DD",798.1,798.114,.01,21,1,0)
Select the registry coordinator or add a new one
"^DD",798.1,798.114,.01,21,2,0)
from the NEW PERSON file. People defined as 
"^DD",798.1,798.114,.01,21,3,0)
registry coordinators will be receiving alerts 
"^DD",798.1,798.114,.01,21,4,0)
regarding problems with the registry processes.
"^DD",798.1,798.114,.01,"DT")
3010907
"^DD",798.1,798.116,0)
USER SUB-FIELD^^2^3
"^DD",798.1,798.116,0,"DT")
3020426
"^DD",798.1,798.116,0,"IX","B",798.116,.01)
 
"^DD",798.1,798.116,0,"NM","USER")
 
"^DD",798.1,798.116,0,"UP")
798.1
"^DD",798.1,798.116,.01,0)
USER^NJ10,0X^^0;1^S X=X
"^DD",798.1,798.116,.01,1,0)
^.1
"^DD",798.1,798.116,.01,1,1,0)
798.116^B
"^DD",798.1,798.116,.01,1,1,1)
S ^ROR(798.1,DA(1),13,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.116,.01,1,1,2)
K ^ROR(798.1,DA(1),13,"B",$E(X,1,30),DA)
"^DD",798.1,798.116,.01,3)
Type a Number between 1 and 9999999999, 0 Decimal Digits
"^DD",798.1,798.116,.01,"DT")
3020426
"^DD",798.1,798.116,1,0)
RPC HANDLE^F^^0;2^K:$L(X)>30!($L(X)<1) X
"^DD",798.1,798.116,1,3)
Answer must be 1-30 characters in length.
"^DD",798.1,798.116,1,21,0)
^.001^2^2^3020426^^^
"^DD",798.1,798.116,1,21,1,0)
This field holds a reference to the last deferred remote procedure that
"^DD",798.1,798.116,1,21,2,0)
created a drug report.
"^DD",798.1,798.116,1,23,0)
^.001^4^4^3020426^^
"^DD",798.1,798.116,1,23,1,0)
This field should not be set manually. It holds a free-text handle to
"^DD",798.1,798.116,1,23,2,0)
identify the last deferred remote procedure that was scheduled.  It is 
"^DD",798.1,798.116,1,23,3,0)
used by the GUI to fetch the drug report created by the deferred remote 
"^DD",798.1,798.116,1,23,4,0)
procedure.  See the EN2^RORRP9 procedure for details.
"^DD",798.1,798.116,1,"DT")
3020426
"^DD",798.1,798.116,2,0)
RPC HANDLE 2^F^^0;3^K:$L(X)>30!($L(X)<1) X
"^DD",798.1,798.116,2,3)
Answer must be 1-30 characters in length.
"^DD",798.1,798.116,2,21,0)
^^2^2^3020426^
"^DD",798.1,798.116,2,21,1,0)
This field holds a reference to the last deferred remote procedure that
"^DD",798.1,798.116,2,21,2,0)
created a Hepatitis C Local Registry report.
"^DD",798.1,798.116,2,23,0)
^^1^1^3020426^
"^DD",798.1,798.116,2,23,1,0)
See the EN2^RORRP9 procedure for details.
"^DD",798.1,798.116,2,"DT")
3020426
"^DD",798.1,798.117,0)
DRUG THERAPY LIST SUB-FIELD^^.01^1
"^DD",798.1,798.117,0,"DT")
3011112
"^DD",798.1,798.117,0,"IX","B",798.117,.01)
 
"^DD",798.1,798.117,0,"NM","DRUG THERAPY LIST")
 
"^DD",798.1,798.117,0,"UP")
798.1
"^DD",798.1,798.117,.01,0)
NDC^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:'(X?12N) X
"^DD",798.1,798.117,.01,1,0)
^.1
"^DD",798.1,798.117,.01,1,1,0)
798.117^B
"^DD",798.1,798.117,.01,1,1,1)
S ^ROR(798.1,DA(1),12,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.117,.01,1,1,2)
K ^ROR(798.1,DA(1),12,"B",$E(X,1,30),DA)
"^DD",798.1,798.117,.01,1,1,3)
Do not delete!
"^DD",798.1,798.117,.01,3)
Answer must be 12 characters in length.
"^DD",798.1,798.117,.01,21,0)
^.001^2^2^3020122^^^
"^DD",798.1,798.117,.01,21,1,0)
National Drug Code to include in Drug Therapy 
"^DD",798.1,798.117,.01,21,2,0)
Report.
"^DD",798.1,798.117,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.117,.01,"DT")
3011112
"^DD",798.1,798.118,0)
SECURITY KEY SUB-FIELD^^.01^1
"^DD",798.1,798.118,0,"DT")
3020801
"^DD",798.1,798.118,0,"IX","B",798.118,.01)
 
"^DD",798.1,798.118,0,"NM","SECURITY KEY")
 
"^DD",798.1,798.118,0,"UP")
798.1
"^DD",798.1,798.118,.01,0)
SECURITY KEY^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:$L(X)>27!($L(X)<3) X
"^DD",798.1,798.118,.01,1,0)
^.1
"^DD",798.1,798.118,.01,1,1,0)
798.118^B
"^DD",798.1,798.118,.01,1,1,1)
S ^ROR(798.1,DA(1),18,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.118,.01,1,1,2)
K ^ROR(798.1,DA(1),18,"B",$E(X,1,30),DA)
"^DD",798.1,798.118,.01,1,1,3)
Do not delete!
"^DD",798.1,798.118,.01,1,2,0)
798.1^ACL^MUMPS
"^DD",798.1,798.118,.01,1,2,1)
D ACLSET^RORDD
"^DD",798.1,798.118,.01,1,2,2)
D ACLKILL^RORDD
"^DD",798.1,798.118,.01,1,2,3)
Do not delete!
"^DD",798.1,798.118,.01,1,2,"%D",0)
^^23^23^3020806^
"^DD",798.1,798.118,.01,1,2,"%D",1,0)
This cross-reference is used by the screening 
"^DD",798.1,798.118,.01,1,2,"%D",2,0)
logic (the "SCR" node) of the ROR LOCAL REGISTRY 
"^DD",798.1,798.118,.01,1,2,"%D",3,0)
(#798) and ROR PATIENT (#798.4) files to check 
"^DD",798.1,798.118,.01,1,2,"%D",4,0)
whether a user is allowed to access the patient
"^DD",798.1,798.118,.01,1,2,"%D",5,0)
records or no.
"^DD",798.1,798.118,.01,1,2,"%D",6,0)
 
"^DD",798.1,798.118,.01,1,2,"%D",7,0)
The cross-reference has the following structure:
"^DD",798.1,798.118,.01,1,2,"%D",8,0)
 
"^DD",798.1,798.118,.01,1,2,"%D",9,0)
  ^ROR(798.1,"ACL",RORDUZ,RegistryIEN,IEN) = ""
"^DD",798.1,798.118,.01,1,2,"%D",10,0)
 
"^DD",798.1,798.118,.01,1,2,"%D",11,0)
where RORDUZ is the value of the DUZ variable for
"^DD",798.1,798.118,.01,1,2,"%D",12,0)
the user that has access to one or more registries
"^DD",798.1,798.118,.01,1,2,"%D",13,0)
(according to the allocated security keys). IEN is
"^DD",798.1,798.118,.01,1,2,"%D",14,0)
the internal entry number of the referenced record
"^DD",798.1,798.118,.01,1,2,"%D",15,0)
of the SECURITY KEY multiple.
"^DD",798.1,798.118,.01,1,2,"%D",16,0)
 
"^DD",798.1,798.118,.01,1,2,"%D",17,0)
The cross-reference should be rebuilt after
"^DD",798.1,798.118,.01,1,2,"%D",18,0)
changes in the allocation of the security keys
"^DD",798.1,798.118,.01,1,2,"%D",19,0)
associated with any registry. Usually, this is
"^DD",798.1,798.118,.01,1,2,"%D",20,0)
done by the nightly task (the [ROR TASK] option).
"^DD",798.1,798.118,.01,1,2,"%D",21,0)
However, if you want the changes to be in effect
"^DD",798.1,798.118,.01,1,2,"%D",22,0)
immediately, you should rebuild this
"^DD",798.1,798.118,.01,1,2,"%D",23,0)
cross-reference manually.
"^DD",798.1,798.118,.01,1,2,"DT")
3020805
"^DD",798.1,798.118,.01,3)
Enter a name of security key (3-27 characters in length).
"^DD",798.1,798.118,.01,8.5)
@
"^DD",798.1,798.118,.01,9)
@
"^DD",798.1,798.118,.01,20,0)
^.3LA^^0
"^DD",798.1,798.118,.01,21,0)
^.001^5^5^3020816^^^
"^DD",798.1,798.118,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.118,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.118,.01,21,3,0)
 
"^DD",798.1,798.118,.01,21,4,0)
The SECURITY KEY field contains the name of the 
"^DD",798.1,798.118,.01,21,5,0)
security key associated with the registry.
"^DD",798.1,798.118,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.118,.01,"DT")
3020805
"^DD",798.1,798.13,0)
SELECTION RULE SUB-FIELD^^.01^1
"^DD",798.1,798.13,0,"DT")
3000410
"^DD",798.1,798.13,0,"NM","SELECTION RULE")
 
"^DD",798.1,798.13,0,"UP")
798.1
"^DD",798.1,798.13,.01,0)
SELECTION RULE^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:$L(X)>30!($L(X)<3)!'(X?3.UNP) X I $D(X) K:'$D(^ROR(798.2,"B",$E(X,1,30))) X
"^DD",798.1,798.13,.01,1,0)
^.1^^-1
"^DD",798.1,798.13,.01,1,2,0)
798.1^ARULES
"^DD",798.1,798.13,.01,1,2,1)
S ^ROR(798.1,"ARULES",$E(X,1,30),DA(1),DA)=""
"^DD",798.1,798.13,.01,1,2,2)
K ^ROR(798.1,"ARULES",$E(X,1,30),DA(1),DA)
"^DD",798.1,798.13,.01,1,2,3)
Do not delete!
"^DD",798.1,798.13,.01,1,2,"%D",0)
^^2^2^3011015^
"^DD",798.1,798.13,.01,1,2,"%D",1,0)
This cross-reference can be used to find all 
"^DD",798.1,798.13,.01,1,2,"%D",2,0)
registries that use the selection rule.
"^DD",798.1,798.13,.01,1,2,"DT")
3000406
"^DD",798.1,798.13,.01,3)
Enter a name of the selection rule (3-30 characters).
"^DD",798.1,798.13,.01,4)
I $G(X)="?" N D,DIC,DZ S DIC="^ROR(798.2,",DIC(0)="",D="B",DZ="??" D DQ^DICQ,EN^DDIOL("",,"!")
"^DD",798.1,798.13,.01,8.5)
@
"^DD",798.1,798.13,.01,9)
@
"^DD",798.1,798.13,.01,21,0)
^.001^8^8^3020403^^^
"^DD",798.1,798.13,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.13,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.13,.01,21,3,0)
 
"^DD",798.1,798.13,.01,21,4,0)
Enter a name of the selection rule that will be 
"^DD",798.1,798.13,.01,21,5,0)
used to select patients for addition to the
"^DD",798.1,798.13,.01,21,6,0)
registry. The name should be entered exactly as it
"^DD",798.1,798.13,.01,21,7,0)
appears in the list of selection rules (file 
"^DD",798.1,798.13,.01,21,8,0)
#798.2).
"^DD",798.1,798.13,.01,23,0)
^.001^3^3^3020403^^^
"^DD",798.1,798.13,.01,23,1,0)
Names of the selection rules are used here instead of 
"^DD",798.1,798.13,.01,23,2,0)
pointers because the KIDS pointer resolving feature 
"^DD",798.1,798.13,.01,23,3,0)
does not work for .01 fields.
"^DD",798.1,798.13,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.13,.01,"DT")
3011109
"^DD",798.1,798.15,0)
DESCRIPTION SUB-FIELD^^.01^1
"^DD",798.1,798.15,0,"NM","DESCRIPTION")
 
"^DD",798.1,798.15,0,"UP")
798.1
"^DD",798.1,798.15,.01,0)
DESCRIPTION^W^^0;1^Q
"^DD",798.1,798.15,.01,"DT")
3000313
"^DD",798.1,798.19,0)
HL7 SEGMENT SUB-FIELD^^1^3
"^DD",798.1,798.19,0,"DT")
3010913
"^DD",798.1,798.19,0,"IX","B",798.19,.01)
 
"^DD",798.1,798.19,0,"NM","HL7 SEGMENT")
 
"^DD",798.1,798.19,0,"UP")
798.1
"^DD",798.1,798.19,.01,0)
HL7 SEGMENT^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:'(X?3UN) X
"^DD",798.1,798.19,.01,1,0)
^.1
"^DD",798.1,798.19,.01,1,1,0)
798.19^B
"^DD",798.1,798.19,.01,1,1,1)
S ^ROR(798.1,DA(1),6,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.19,.01,1,1,2)
K ^ROR(798.1,DA(1),6,"B",$E(X,1,30),DA)
"^DD",798.1,798.19,.01,1,1,3)
Do not delete!
"^DD",798.1,798.19,.01,3)
Enter a name of the HL7 segment (3 characters).
"^DD",798.1,798.19,.01,21,0)
^.001^9^9^3021113^^^^
"^DD",798.1,798.19,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.19,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.19,.01,21,3,0)
 
"^DD",798.1,798.19,.01,21,4,0)
Enter a name of the HL7 segment that should be 
"^DD",798.1,798.19,.01,21,5,0)
included in the message sent to AAC. The general 
"^DD",798.1,798.19,.01,21,6,0)
structure of the registry HL7 message is hard 
"^DD",798.1,798.19,.01,21,7,0)
coded in the message builder routine. Therefore, 
"^DD",798.1,798.19,.01,21,8,0)
the segments that are not generated by the builder
"^DD",798.1,798.19,.01,21,9,0)
will be ignored if added to this multiple.
"^DD",798.1,798.19,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.19,.01,"DT")
3011015
"^DD",798.1,798.19,.02,0)
DATA AREA^RSX^1:Patient;2:Laboratory;3:Pharmacy;4:Radiology;5:Inpatient;6:Outpatient;7:Pathology-Autopsy;8:Pathology-Liver Biopsy;9:Pathology-Surgical;10:Pathology-Cyto;11:Microbiology;12:EKG;13:Allergy;14:IV;^0;3^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.19,.02,21,0)
^.001^6^6^3021113^^^^
"^DD",798.1,798.19,.02,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.19,.02,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.19,.02,21,3,0)
 
"^DD",798.1,798.19,.02,21,4,0)
The same HL7 segments can be used in different 
"^DD",798.1,798.19,.02,21,5,0)
contexts to store different data. The data area
"^DD",798.1,798.19,.02,21,6,0)
code is used to distinguish between them.
"^DD",798.1,798.19,.02,"DT")
3011109
"^DD",798.1,798.19,1,0)
FIELDS^FX^^1;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:$L(X)>200!($L(X)<1) X
"^DD",798.1,798.19,1,3)
Enter a list of HL7 field numbers separated by commas (1-200 characters).
"^DD",798.1,798.19,1,8.5)
@
"^DD",798.1,798.19,1,9)
@
"^DD",798.1,798.19,1,21,0)
^.001^11^11^3011121^^^
"^DD",798.1,798.19,1,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.19,1,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.19,1,21,3,0)
 
"^DD",798.1,798.19,1,21,4,0)
The values of the segment fields listed here 
"^DD",798.1,798.19,1,21,5,0)
(field numbers should be separated by commas) will
"^DD",798.1,798.19,1,21,6,0)
be extracted and sent to AAC. If this field is 
"^DD",798.1,798.19,1,21,7,0)
empty, the values of all fields will be sent.
"^DD",798.1,798.19,1,21,8,0)
 
"^DD",798.1,798.19,1,21,9,0)
Some existing VistA APIs do not support this 
"^DD",798.1,798.19,1,21,10,0)
feature. So, sometimes the value of this field may
"^DD",798.1,798.19,1,21,11,0)
be ignored and all values will be sent instead.
"^DD",798.1,798.19,1,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.19,1,"DT")
3010622
"^DD",798.4,798.4,0)
FIELD^^991^14
"^DD",798.4,798.4,0,"DDA")
N
"^DD",798.4,798.4,0,"DT")
3021101
"^DD",798.4,798.4,0,"IX","B",798.4,.01)
 
"^DD",798.4,798.4,0,"IX","BS",798.4,.09)
 
"^DD",798.4,798.4,0,"IX","BS5",798.4,.09)
 
"^DD",798.4,798.4,0,"IX","SSN",798.4,.09)
 
"^DD",798.4,798.4,0,"NM","ROR PATIENT")
 
"^DD",798.4,798.4,0,"PT",798,.01)
 
"^DD",798.4,798.4,0,"SCR")
I $G(DUZ),$S($D(^ROR(798.1,"ACL",DUZ))>1:1,1:$D(^XUSEC("ROR VA IRM",DUZ)))
"^DD",798.4,798.4,0,"VRPK")
ROR
"^DD",798.4,798.4,.01,0)
PATIENT NAME^RP2'X^DPT(^0;1^S:$D(X) DINUM=X
"^DD",798.4,798.4,.01,1,0)
^.1
"^DD",798.4,798.4,.01,1,1,0)
798.4^B
"^DD",798.4,798.4,.01,1,1,1)
S ^RORDATA(798.4,"B",$E(X,1,30),DA)=""
"^DD",798.4,798.4,.01,1,1,2)
K ^RORDATA(798.4,"B",$E(X,1,30),DA)
"^DD",798.4,798.4,.01,1,1,3)
Do not delete!
"^DD",798.4,798.4,.01,1,1,"DT")
3000523
"^DD",798.4,798.4,.01,3)
 
"^DD",798.4,798.4,.01,8.5)
@
"^DD",798.4,798.4,.01,9)
@
"^DD",798.4,798.4,.01,21,0)
^^5^5^3020802^
"^DD",798.4,798.4,.01,21,1,0)
You can select an existing patient or add a new 
"^DD",798.4,798.4,.01,21,2,0)
one from the PATIENT file (#2).
"^DD",798.4,798.4,.01,21,3,0)
 
"^DD",798.4,798.4,.01,21,4,0)
You can access records of this file only if you
"^DD",798.4,798.4,.01,21,5,0)
have appropriate security key(s) for any registry.
"^DD",798.4,798.4,.01,23,0)
^.001^4^4^3020802^^^
"^DD",798.4,798.4,.01,23,1,0)
The PATIENT NAME field points to the patient record in 
"^DD",798.4,798.4,.01,23,2,0)
the PATIENT file (#2). Internal value of this field is
"^DD",798.4,798.4,.01,23,3,0)
used as internal entry number of the record ("DINUM"
"^DD",798.4,798.4,.01,23,4,0)
feature).
"^DD",798.4,798.4,.01,"DEL",1,0)
I $D(^RORDATA(798,"B",+$G(DA)))
"^DD",798.4,798.4,.01,"DT")
3000523
"^DD",798.4,798.4,.02,0)
SEX^SI^M:MALE;F:FEMALE;^1;3^Q
"^DD",798.4,798.4,.02,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.02,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.02,21,0)
^.001^1^1^3021106^^^^
"^DD",798.4,798.4,.02,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.02,23,0)
^.001^1^1^3021106^^^
"^DD",798.4,798.4,.02,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.02,"DT")
3011120
"^DD",798.4,798.4,.03,0)
DATE OF BIRTH^RDOI^^1;2^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.4,798.4,.03,2)
S Y(0)=Y S Y(0)=Y S X=Y(0) S:X X=$E(X,4,5)_"/"_$E(X,6,7)_"/"_(1700+$E(X,1,3)) S Y=X
"^DD",798.4,798.4,.03,2.1)
S Y(0)=Y S X=Y(0) S:X X=$E(X,4,5)_"/"_$E(X,6,7)_"/"_(1700+$E(X,1,3)) S Y=X
"^DD",798.4,798.4,.03,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.03,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.03,21,0)
^.001^1^1^3021106^^^^
"^DD",798.4,798.4,.03,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.03,23,0)
^.001^1^1^3021106^^^^
"^DD",798.4,798.4,.03,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.03,"DT")
3011120
"^DD",798.4,798.4,.09,0)
SOCIAL SECURITY NUMBER^RFOI^^1;1^K:$L(X)>11!($L(X)<9) X
"^DD",798.4,798.4,.09,1,0)
^.1
"^DD",798.4,798.4,.09,1,1,0)
798.4^BS^MUMPS
"^DD",798.4,798.4,.09,1,1,1)
S ^RORDATA(798.4,"BS",$E(X,6,9),DA)=""
"^DD",798.4,798.4,.09,1,1,2)
K ^RORDATA(798.4,"BS",$E(X,6,9),DA)
"^DD",798.4,798.4,.09,1,1,3)
Do not delete!
"^DD",798.4,798.4,.09,1,1,"%D",0)
^.101^1^1^3011220^^
"^DD",798.4,798.4,.09,1,1,"%D",1,0)
The cross-reference on the last four digits of the SSN.
"^DD",798.4,798.4,.09,1,1,"DT")
3000426
"^DD",798.4,798.4,.09,1,2,0)
798.4^BS5^MUMPS
"^DD",798.4,798.4,.09,1,2,1)
S ^RORDATA(798.4,"BS5",$E(^DPT(DA,0),1)_$E(X,6,9),DA)=""
"^DD",798.4,798.4,.09,1,2,2)
K ^RORDATA(798.4,"BS5",$E(^DPT(DA,0),1)_$E(X,6,9),DA)
"^DD",798.4,798.4,.09,1,2,3)
Do not delete!
"^DD",798.4,798.4,.09,1,2,"%D",0)
^^3^3^3020403^
"^DD",798.4,798.4,.09,1,2,"%D",1,0)
This cross-reference contains values combined from
"^DD",798.4,798.4,.09,1,2,"%D",2,0)
the first letter of the last name and last four
"^DD",798.4,798.4,.09,1,2,"%D",3,0)
digits of the SSN.
"^DD",798.4,798.4,.09,1,2,"DT")
3011220
"^DD",798.4,798.4,.09,1,3,0)
798.4^SSN
"^DD",798.4,798.4,.09,1,3,1)
S ^RORDATA(798.4,"SSN",$E(X,1,30),DA)=""
"^DD",798.4,798.4,.09,1,3,2)
K ^RORDATA(798.4,"SSN",$E(X,1,30),DA)
"^DD",798.4,798.4,.09,1,3,3)
Do not delete!
"^DD",798.4,798.4,.09,1,3,"DT")
3011221
"^DD",798.4,798.4,.09,2)
S Y(0)=Y S:$L(Y)=11 Y=$E(Y,10,11)_$E(Y,1,9)
"^DD",798.4,798.4,.09,2.1)
S:$L(Y)=11 Y=$E(Y,10,11)_$E(Y,1,9)
"^DD",798.4,798.4,.09,3)
Answer must be 9-11 characters in length.
"^DD",798.4,798.4,.09,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.09,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.09,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.09,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.09,23,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.09,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.09,"DT")
3020403
"^DD",798.4,798.4,.1112,0)
ZIP+4^FI^^1;8^K:$L(X)>9!($L(X)<5) X
"^DD",798.4,798.4,.1112,3)
Answer must be 5-9 characters in length.
"^DD",798.4,798.4,.1112,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.1112,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.1112,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.1112,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.1112,23,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.1112,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.1112,"DT")
3011120
"^DD",798.4,798.4,.301,0)
SERVICE CONNECTED?^RSI^Y:YES;N:NO;^1;6^Q
"^DD",798.4,798.4,.301,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.301,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.301,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.301,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.301,23,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.301,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.301,"DT")
3011120
"^DD",798.4,798.4,.302,0)
SERVICE CONNECTED PERCENTAGE^NJ3,0I^^1;7^K:+X'=X!(X>100)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.4,798.4,.302,3)
Type a Number between 0 and 100, 0 Decimal Digits
"^DD",798.4,798.4,.302,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.302,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.302,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.302,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.302,23,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.302,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.302,"DT")
3011120
"^DD",798.4,798.4,.323,0)
PERIOD OF SERVICE^P21'I^DIC(21,^1;5^Q
"^DD",798.4,798.4,.323,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.323,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.323,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.323,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.323,23,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.323,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.323,"DT")
3011120
"^DD",798.4,798.4,.351,0)
DATE OF DEATH^DI^^1;4^S %DT="ET" D ^%DT S X=Y K:Y<1 X
"^DD",798.4,798.4,.351,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.351,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.351,21,0)
^.001^1^1^3021106^^^^
"^DD",798.4,798.4,.351,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.351,23,0)
^.001^1^1^3021106^^^^
"^DD",798.4,798.4,.351,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.351,"DT")
3020502
"^DD",798.4,798.4,.3721,0)
RATED DISABILITIES DATA^FI^^3;E1,245^K:$L(X)>245!($L(X)<1) X
"^DD",798.4,798.4,.3721,3)
Answer must be 1-245 characters in length.
"^DD",798.4,798.4,.3721,20,0)
^.3LA^1^1
"^DD",798.4,798.4,.3721,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,.3721,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,.3721,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.3721,23,0)
^.001^5^5^3021106^^
"^DD",798.4,798.4,.3721,23,1,0)
This field stores the combined data from the RATED
"^DD",798.4,798.4,.3721,23,2,0)
DISABILITIES (VA) multiple (.3721) of the PATIENT file
"^DD",798.4,798.4,.3721,23,3,0)
(#2). This data can be used only for comparison (by the
"^DD",798.4,798.4,.3721,23,4,0)
RORUPD52 routine) to the data in the PATIENT file (do
"^DD",798.4,798.4,.3721,23,5,0)
not try to parse values of this field in any way)!
"^DD",798.4,798.4,.3721,"DT")
3021106
"^DD",798.4,798.4,2,0)
RACE AND ETHNICITY DATA^FI^^2;E1,245^K:$L(X)>245!($L(X)<1) X
"^DD",798.4,798.4,2,3)
Answer must be 1-245 characters in length.
"^DD",798.4,798.4,2,20,0)
^.3LA^1^1
"^DD",798.4,798.4,2,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,2,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,2,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,2,23,0)
^.001^6^6^3021106^^
"^DD",798.4,798.4,2,23,1,0)
This field stores the combined data from the RACE
"^DD",798.4,798.4,2,23,2,0)
INFORMATION (2) and ETHNICITY INFORMATION (6) multiples
"^DD",798.4,798.4,2,23,3,0)
of the PATIENT file (#2). This data can be used only
"^DD",798.4,798.4,2,23,4,0)
for comparison (by the RORUPD52 routine) to the data in
"^DD",798.4,798.4,2,23,5,0)
the PATIENT file (do not try to parse values of this
"^DD",798.4,798.4,2,23,6,0)
field in any way)!
"^DD",798.4,798.4,2,"DT")
3021106
"^DD",798.4,798.4,10.1,0)
OLD SSN^FI^^10;1^K:$L(X)>11!($L(X)<9) X
"^DD",798.4,798.4,10.1,3)
Answer must be 9-11 characters in length.
"^DD",798.4,798.4,10.1,20,0)
^.3LA^1^1
"^DD",798.4,798.4,10.1,20,1,0)
OLD DEMOGRAPHICS
"^DD",798.4,798.4,10.1,21,0)
^.001^1^1^3021106^^
"^DD",798.4,798.4,10.1,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,10.1,23,0)
^.001^3^3^3021106^^
"^DD",798.4,798.4,10.1,23,1,0)
This field contains the previous value of the patient 
"^DD",798.4,798.4,10.1,23,2,0)
SSN. The registry extraction process transmits both new
"^DD",798.4,798.4,10.1,23,3,0)
and old values of the SSN to the national registries.
"^DD",798.4,798.4,10.1,"DT")
3011120
"^DD",798.4,798.4,10.2,0)
OLD ICN^FI^^10;2^K:$L(X)>19!($L(X)<1) X
"^DD",798.4,798.4,10.2,3)
Answer must be 1-19 characters in length.
"^DD",798.4,798.4,10.2,20,0)
^.3LA^1^1
"^DD",798.4,798.4,10.2,20,1,0)
OLD DEMOGRAPHICS
"^DD",798.4,798.4,10.2,21,0)
^.001^1^1^3021106^^^
"^DD",798.4,798.4,10.2,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,10.2,23,0)
^.001^4^4^3021106^^
"^DD",798.4,798.4,10.2,23,1,0)
This field contains the previous value of the patient 
"^DD",798.4,798.4,10.2,23,2,0)
ICN (with the checksum). The registry extraction
"^DD",798.4,798.4,10.2,23,3,0)
process transmits both new and old values of the ICN to
"^DD",798.4,798.4,10.2,23,4,0)
the national registries.
"^DD",798.4,798.4,10.2,"DT")
3021101
"^DD",798.4,798.4,991,0)
INTEGRATION CONTROL NUMBER^FI^^1;9^K:$L(X)>19!($L(X)<1) X
"^DD",798.4,798.4,991,3)
Answer must be 1-19 characters in length.
"^DD",798.4,798.4,991,20,0)
^.3LA^1^1
"^DD",798.4,798.4,991,20,1,0)
DEMOGRAPHIC DATA
"^DD",798.4,798.4,991,21,0)
^.001^1^1^3021106^^^
"^DD",798.4,798.4,991,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,991,23,0)
^.001^4^4^3021106^^
"^DD",798.4,798.4,991,23,1,0)
This field stores the patient's full Integration
"^DD",798.4,798.4,991,23,2,0)
Control Number (the ICN and checksum separated by the
"^DD",798.4,798.4,991,23,3,0)
"V"). See the fields 991.01 and 991.02 of the PATIENT
"^DD",798.4,798.4,991,23,4,0)
file (#2).
"^DD",798.4,798.4,991,"DT")
3021101
"^DD",798.7,798.7,0)
FIELD^^6.03^9
"^DD",798.7,798.7,0,"DDA")
N
"^DD",798.7,798.7,0,"DT")
3021122
"^DD",798.7,798.7,0,"IX","B",798.7,.01)
 
"^DD",798.7,798.7,0,"IX","C",798.7,2)
 
"^DD",798.7,798.7,0,"NM","ROR LOG")
 
"^DD",798.7,798.7,0,"PT",798.5,2.04)
 
"^DD",798.7,798.7,0,"PT",798.8,2.03)
 
"^DD",798.7,798.7,0,"SCR")
I $G(DUZ),$S($D(^XUSEC("ROR VA IRM",DUZ)):1,1:$D(^ROR(798.1,"ACL",DUZ))>1)
"^DD",798.7,798.7,0,"VRPK")
ROR
"^DD",798.7,798.7,.01,0)
START DATE/TIME^RDI^^0;1^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798.7,798.7,.01,1,0)
^.1
"^DD",798.7,798.7,.01,1,1,0)
798.7^B
"^DD",798.7,798.7,.01,1,1,1)
S ^RORDATA(798.7,"B",$E(X,1,30),DA)=""
"^DD",798.7,798.7,.01,1,1,2)
K ^RORDATA(798.7,"B",$E(X,1,30),DA)
"^DD",798.7,798.7,.01,1,1,3)
Do not delete!
"^DD",798.7,798.7,.01,3)
 
"^DD",798.7,798.7,.01,21,0)
^^5^5^3021101^
"^DD",798.7,798.7,.01,21,1,0)
This field contains the date/time when this log 
"^DD",798.7,798.7,.01,21,2,0)
was created.
"^DD",798.7,798.7,.01,21,3,0)
 
"^DD",798.7,798.7,.01,21,4,0)
You can access records of this file only if you
"^DD",798.7,798.7,.01,21,5,0)
have appropriate security key(s) for any registry.
"^DD",798.7,798.7,.01,23,0)
^.001^2^2^3021101^^
"^DD",798.7,798.7,.01,23,1,0)
The $$OPEN^RORLOG function populates this field
"^DD",798.7,798.7,.01,23,2,0)
automatically when a new log is created.
"^DD",798.7,798.7,.01,"DT")
3010807
"^DD",798.7,798.7,1,0)
ACTIVITY^S^0:Other;1:Registry Update;2:Data Extraction;3:Acknowledgement;4:Hist. Extraction;5:Report;^0;3^Q
"^DD",798.7,798.7,1,21,0)
^^2^2^3011011^
"^DD",798.7,798.7,1,21,1,0)
The value of this field indicates the activity
"^DD",798.7,798.7,1,21,2,0)
performed by the process that created the log.
"^DD",798.7,798.7,1,23,0)
^^2^2^3020403^
"^DD",798.7,798.7,1,23,1,0)
This field is populated by the $$OPEN^RORLOG function 
"^DD",798.7,798.7,1,23,2,0)
with the value passed as one of the parameters.
"^DD",798.7,798.7,1,"DT")
3021122
"^DD",798.7,798.7,2,0)
JOB NUMBER^NJ12,0^^0;4^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",798.7,798.7,2,1,0)
^.1
"^DD",798.7,798.7,2,1,1,0)
798.7^C
"^DD",798.7,798.7,2,1,1,1)
S ^RORDATA(798.7,"C",$E(X,1,30),DA)=""
"^DD",798.7,798.7,2,1,1,2)
K ^RORDATA(798.7,"C",$E(X,1,30),DA)
"^DD",798.7,798.7,2,1,1,3)
Do not delete!
"^DD",798.7,798.7,2,1,1,"%D",0)
^^3^3^3011011^
"^DD",798.7,798.7,2,1,1,"%D",1,0)
This cross-reference can be used in the 
"^DD",798.7,798.7,2,1,1,"%D",2,0)
troubleshooting process to find the log by the job
"^DD",798.7,798.7,2,1,1,"%D",3,0)
number.
"^DD",798.7,798.7,2,1,1,"DT")
3010813
"^DD",798.7,798.7,2,3)
Enter a job number between 1 and 999999999999, 0 Decimal Digits.
"^DD",798.7,798.7,2,21,0)
^^2^2^3020403^
"^DD",798.7,798.7,2,21,1,0)
Value of the JOB NUMBER field is the job number 
"^DD",798.7,798.7,2,21,2,0)
($JOB) of the process that has created this log.
"^DD",798.7,798.7,2,23,0)
^^2^2^3020403^
"^DD",798.7,798.7,2,23,1,0)
This field is populated automatically by the 
"^DD",798.7,798.7,2,23,2,0)
$$OPEN^RORLOG function.
"^DD",798.7,798.7,2,"DT")
3010813
"^DD",798.7,798.7,3,0)
REGISTRY^798.73P^^1;0
"^DD",798.7,798.7,3,21,0)
^^8^8^3020403^
"^DD",798.7,798.7,3,21,1,0)
This multiple contains a list of the registries 
"^DD",798.7,798.7,3,21,2,0)
that were processed. Events recorded in the log
"^DD",798.7,798.7,3,21,3,0)
are associated with these registries.
"^DD",798.7,798.7,3,21,4,0)
 
"^DD",798.7,798.7,3,21,5,0)
Records of this multiple are indexed by the "ARD"
"^DD",798.7,798.7,3,21,6,0)
index (whole file). So, it is possible to get a
"^DD",798.7,798.7,3,21,7,0)
list of log files associated with the particular
"^DD",798.7,798.7,3,21,8,0)
registry.
"^DD",798.7,798.7,4,0)
MESSAGE^798.74D^^2;0
"^DD",798.7,798.7,4,21,0)
^^2^2^3020403^
"^DD",798.7,798.7,4,21,1,0)
This multiple contains all messages recorded in 
"^DD",798.7,798.7,4,21,2,0)
the log.
"^DD",798.7,798.7,4,23,0)
^^4^4^3020403^
"^DD",798.7,798.7,4,23,1,0)
Every call of the LOG^RORLOG procedure adds a new 
"^DD",798.7,798.7,4,23,2,0)
record to this multiple. The $$OPEN^RORLOG and 
"^DD",798.7,798.7,4,23,3,0)
CLOSE^RORLOG entry points can also call the LOG^RORLOG
"^DD",798.7,798.7,4,23,4,0)
automatically to add header and footer to the log.
"^DD",798.7,798.7,5,0)
END DATE/TIME^D^^0;2^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798.7,798.7,5,21,0)
^^2^2^3020403^
"^DD",798.7,798.7,5,21,1,0)
This field contains the date/time when the 
"^DD",798.7,798.7,5,21,2,0)
log was closed.
"^DD",798.7,798.7,5,23,0)
^^2^2^3020403^
"^DD",798.7,798.7,5,23,1,0)
The CLOSE^RORLOG procedure populates this field
"^DD",798.7,798.7,5,23,2,0)
automatically when the log is closed.
"^DD",798.7,798.7,5,"DT")
3010807
"^DD",798.7,798.7,6.01,0)
PROCESSED PATIENTS^NJ12,0^^0;5^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.7,798.7,6.01,3)
Type a Number between 0 and 999999999999, 0 Decimal Digits.
"^DD",798.7,798.7,6.01,21,0)
^.001^2^2^3011011^^
"^DD",798.7,798.7,6.01,21,1,0)
The value of this field indicates the number of 
"^DD",798.7,798.7,6.01,21,2,0)
processed patients.
"^DD",798.7,798.7,6.01,23,0)
^.001^2^2^3020403^^
"^DD",798.7,798.7,6.01,23,1,0)
The value of this field is also duplicated in the last
"^DD",798.7,798.7,6.01,23,2,0)
message of the log (footer).
"^DD",798.7,798.7,6.01,"DT")
3010807
"^DD",798.7,798.7,6.02,0)
PATIENTS WITH ERRORS^NJ12,0^^0;6^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.7,798.7,6.02,3)
Type a Number between 0 and 999999999999, 0 Decimal Digits.
"^DD",798.7,798.7,6.02,21,0)
^^2^2^3011011^
"^DD",798.7,798.7,6.02,21,1,0)
The value of this field indicates the number of 
"^DD",798.7,798.7,6.02,21,2,0)
patients processed with errors.
"^DD",798.7,798.7,6.02,23,0)
^.001^2^2^3020403^^
"^DD",798.7,798.7,6.02,23,1,0)
The value of this field is also duplicated in the last
"^DD",798.7,798.7,6.02,23,2,0)
message of the log (footer).
"^DD",798.7,798.7,6.02,"DT")
3010807
"^DD",798.7,798.7,6.03,0)
RATE^NJ16,3^^0;7^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."4N.N) X
"^DD",798.7,798.7,6.03,3)
Type a Number between 0 and 999999999999, 3 Decimal Digits.
"^DD",798.7,798.7,6.03,21,0)
^^2^2^3011011^
"^DD",798.7,798.7,6.03,21,1,0)
The value of this field indicates the rate of 
"^DD",798.7,798.7,6.03,21,2,0)
patient processing (patients per second).
"^DD",798.7,798.7,6.03,23,0)
^.001^2^2^3020403^^
"^DD",798.7,798.7,6.03,23,1,0)
The value of this field is also duplicated in the last
"^DD",798.7,798.7,6.03,23,2,0)
message of the log (footer).
"^DD",798.7,798.7,6.03,"DT")
3010807
"^DD",798.7,798.73,0)
REGISTRY SUB-FIELD^^.01^1
"^DD",798.7,798.73,0,"DT")
3010807
"^DD",798.7,798.73,0,"IX","B",798.73,.01)
 
"^DD",798.7,798.73,0,"NM","REGISTRY")
 
"^DD",798.7,798.73,0,"UP")
798.7
"^DD",798.7,798.73,.01,0)
REGISTRY^MP798.1'X^ROR(798.1,^0;1^S:$D(X) DINUM=X
"^DD",798.7,798.73,.01,1,0)
^.1^^-1
"^DD",798.7,798.73,.01,1,1,0)
798.73^B
"^DD",798.7,798.73,.01,1,1,1)
S ^RORDATA(798.7,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",798.7,798.73,.01,1,1,2)
K ^RORDATA(798.7,DA(1),1,"B",$E(X,1,30),DA)
"^DD",798.7,798.73,.01,1,1,3)
Do not delete!
"^DD",798.7,798.73,.01,21,0)
^^4^4^3020403^
"^DD",798.7,798.73,.01,21,1,0)
The value of this field is a pointer to a record 
"^DD",798.7,798.73,.01,21,2,0)
of the ROR REGISTRY PARAMETERS file. The registry
"^DD",798.7,798.73,.01,21,3,0)
represented by that record was processed by the
"^DD",798.7,798.73,.01,21,4,0)
job that created this log.
"^DD",798.7,798.73,.01,"DT")
3010906
"^DD",798.7,798.74,0)
MESSAGE SUB-FIELD^^4^5
"^DD",798.7,798.74,0,"DT")
3011109
"^DD",798.7,798.74,0,"IX","B",798.74,.01)
 
"^DD",798.7,798.74,0,"NM","MESSAGE")
 
"^DD",798.7,798.74,0,"UP")
798.7
"^DD",798.7,798.74,.01,0)
DATE/TIME^MD^^0;1^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798.7,798.74,.01,1,0)
^.1
"^DD",798.7,798.74,.01,1,1,0)
798.74^B
"^DD",798.7,798.74,.01,1,1,1)
S ^RORDATA(798.7,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",798.7,798.74,.01,1,1,2)
K ^RORDATA(798.7,DA(1),2,"B",$E(X,1,30),DA)
"^DD",798.7,798.74,.01,1,1,3)
Do not delete!
"^DD",798.7,798.74,.01,21,0)
^^2^2^3011011^
"^DD",798.7,798.74,.01,21,1,0)
This field contains the date/time of the recorded
"^DD",798.7,798.74,.01,21,2,0)
event.
"^DD",798.7,798.74,.01,23,0)
^^2^2^3020403^
"^DD",798.7,798.74,.01,23,1,0)
The field is populated automatically by the LOG^RORLOG 
"^DD",798.7,798.74,.01,23,2,0)
procedure with the current date and time.
"^DD",798.7,798.74,.01,"DT")
3010807
"^DD",798.7,798.74,1,0)
TYPE^RS^1:Debug;2:Information;3:Data Quality;4:Warning;5:Database Error;6:Error;^0;2^Q
"^DD",798.7,798.74,1,21,0)
^^6^6^3020403^
"^DD",798.7,798.74,1,21,1,0)
The value of this field indicates the type of the
"^DD",798.7,798.74,1,21,2,0)
recorded event.
"^DD",798.7,798.74,1,21,3,0)
 
"^DD",798.7,798.74,1,21,4,0)
You can control which events are recorded and 
"^DD",798.7,798.74,1,21,5,0)
which are not via the LOG EVENTS multiple of the
"^DD",798.7,798.74,1,21,6,0)
ROR REGISTRY PARAMETERS file.
"^DD",798.7,798.74,1,"DT")
3010807
"^DD",798.7,798.74,2,0)
MESSAGE^RF^^2;E1,245^K:$L(X)>70!($L(X)<1) X
"^DD",798.7,798.74,2,3)
Answer must be 1-70 characters in length.
"^DD",798.7,798.74,2,21,0)
^^2^2^3011109^
"^DD",798.7,798.74,2,21,1,0)
This field contains a text message describing the 
"^DD",798.7,798.74,2,21,2,0)
recorded event.
"^DD",798.7,798.74,2,"DT")
3011109
"^DD",798.7,798.74,3,0)
PATIENT^P2'^DPT(^0;4^Q
"^DD",798.7,798.74,3,21,0)
^^3^3^3020403^
"^DD",798.7,798.74,3,21,1,0)
If the recorded event can be associated with a 
"^DD",798.7,798.74,3,21,2,0)
particular patient, this field contains a pointer 
"^DD",798.7,798.74,3,21,3,0)
to the patient record in the PATIENT file (DFN).
"^DD",798.7,798.74,3,"DT")
3010807
"^DD",798.7,798.74,4,0)
ADDITIONAL INFO^798.744^^1;0
"^DD",798.7,798.74,4,21,0)
^.001^2^2^3011011^^^
"^DD",798.7,798.74,4,21,1,0)
This field contains any additional information 
"^DD",798.7,798.74,4,21,2,0)
describing the event.
"^DD",798.7,798.744,0)
ADDITIONAL INFO SUB-FIELD^^.01^1
"^DD",798.7,798.744,0,"DT")
3010807
"^DD",798.7,798.744,0,"NM","ADDITIONAL INFO")
 
"^DD",798.7,798.744,0,"UP")
798.74
"^DD",798.7,798.744,.01,0)
ADDITIONAL INFO^WL^^0;1^Q
"^DD",798.7,798.744,.01,21,0)
^^2^2^3011011^
"^DD",798.7,798.744,.01,21,1,0)
This field contains any additional information 
"^DD",798.7,798.744,.01,21,2,0)
describing the event.
"^DD",798.7,798.744,.01,"DT")
3010807
"^DIC",798,798,0)
ROR LOCAL REGISTRY^798
"^DIC",798,798,0,"GL")
^RORDATA(798,
"^DIC",798,798,"%",0)
^1.005^^0
"^DIC",798,798,"%D",0)
^^26^26^3021223^
"^DIC",798,798,"%D",1,0)
The ROR LOCAL REGISTRY file contains records of
"^DIC",798,798,"%D",2,0)
local registries. Each record associates a patient
"^DIC",798,798,"%D",3,0)
with a registry and contains registry specific and
"^DIC",798,798,"%D",4,0)
additional service information (when the patient 
"^DIC",798,798,"%D",5,0)
has been added to the registry, if the patient
"^DIC",798,798,"%D",6,0)
record is active or not, etc).
"^DIC",798,798,"%D",7,0)
 
"^DIC",798,798,"%D",8,0)
Records of the file are uniquely identified by 
"^DIC",798,798,"%D",9,0)
the patient and the registry (the "A" primary key
"^DIC",798,798,"%D",10,0)
and the uniqueness index "KEY" are used for that
"^DIC",798,798,"%D",11,0)
purpose).
"^DIC",798,798,"%D",12,0)
 
"^DIC",798,798,"%D",13,0)
A permanent screen (the ^DD(798,0,"SCR") node) 
"^DIC",798,798,"%D",14,0)
restricts access to records of this file. Users
"^DIC",798,798,"%D",15,0)
can access records of only those registries that
"^DIC",798,798,"%D",16,0)
they have the security key(s) for. Users with the
"^DIC",798,798,"%D",17,0)
ROR VA IRM security key can access all records of
"^DIC",798,798,"%D",18,0)
the file.
"^DIC",798,798,"%D",19,0)
 
"^DIC",798,798,"%D",20,0)
If you want the changes in the security keys
"^DIC",798,798,"%D",21,0)
allocation to have an effect immediately, you 
"^DIC",798,798,"%D",22,0)
should rebuild the "ACL" cross-reference of the
"^DIC",798,798,"%D",23,0)
.01 field of the SECURITY KEY multiple of the ROR
"^DIC",798,798,"%D",24,0)
REGISTRY PARAMETERS file (#798.1). See the
"^DIC",798,798,"%D",25,0)
description of the cross-reference for more
"^DIC",798,798,"%D",26,0)
details.
"^DIC",798,"B","ROR LOCAL REGISTRY",798)
 
"^DIC",798.1,798.1,0)
ROR REGISTRY PARAMETERS^798.1
"^DIC",798.1,798.1,0,"GL")
^ROR(798.1,
"^DIC",798.1,798.1,"%",0)
^1.005^^0
"^DIC",798.1,798.1,"%D",0)
^^22^22^3021223^
"^DIC",798.1,798.1,"%D",1,0)
Records of the ROR REGISTRY PARAMETERS file 
"^DIC",798.1,798.1,"%D",2,0)
contain various registry parameters and the data
"^DIC",798.1,798.1,"%D",3,0)
that indicates current registry state. Every 
"^DIC",798.1,798.1,"%D",4,0)
registry must have a record in this file.
"^DIC",798.1,798.1,"%D",5,0)
 
"^DIC",798.1,798.1,"%D",6,0)
Records of the file are uniquely identified by the
"^DIC",798.1,798.1,"%D",7,0)
registry name (the "A" primary key and the
"^DIC",798.1,798.1,"%D",8,0)
uniqueness index "B" are used for that purpose).
"^DIC",798.1,798.1,"%D",9,0)
 
"^DIC",798.1,798.1,"%D",10,0)
A permanent screen (the ^DD(798.1,0,"SCR") node) 
"^DIC",798.1,798.1,"%D",11,0)
restricts access to records of this file. Users
"^DIC",798.1,798.1,"%D",12,0)
can access records of only those registries that
"^DIC",798.1,798.1,"%D",13,0)
they have the security key(s) for. Users with the
"^DIC",798.1,798.1,"%D",14,0)
ROR VA IRM security key can access all records of
"^DIC",798.1,798.1,"%D",15,0)
the file.
"^DIC",798.1,798.1,"%D",16,0)
 
"^DIC",798.1,798.1,"%D",17,0)
If you want the changes in the security keys 
"^DIC",798.1,798.1,"%D",18,0)
allocation to have an effect immediately, you
"^DIC",798.1,798.1,"%D",19,0)
should rebuild the "ACL" cross-reference of the
"^DIC",798.1,798.1,"%D",20,0)
.01 field of the SECURITY KEY multiple of this
"^DIC",798.1,798.1,"%D",21,0)
file. See the description of the cross-reference
"^DIC",798.1,798.1,"%D",22,0)
for more details.
"^DIC",798.1,"B","ROR REGISTRY PARAMETERS",798.1)
 
"^DIC",798.4,798.4,0)
ROR PATIENT^798.4
"^DIC",798.4,798.4,0,"GL")
^RORDATA(798.4,
"^DIC",798.4,798.4,"%",0)
^1.005^^0
"^DIC",798.4,798.4,"%D",0)
^^34^34^3021223^
"^DIC",798.4,798.4,"%D",1,0)
The ROR PATIENT file contains patient information
"^DIC",798.4,798.4,"%D",2,0)
that is common for all local registries (mostly,
"^DIC",798.4,798.4,"%D",3,0)
demographic information).
"^DIC",798.4,798.4,"%D",4,0)
 
"^DIC",798.4,798.4,"%D",5,0)
Most of the fields in the file have the same 
"^DIC",798.4,798.4,"%D",6,0)
numbers and names as the corresponding fields in
"^DIC",798.4,798.4,"%D",7,0)
the PATIENT file.
"^DIC",798.4,798.4,"%D",8,0)
 
"^DIC",798.4,798.4,"%D",9,0)
Demographic data from this file is compared to
"^DIC",798.4,798.4,"%D",10,0)
that from the PATIENT file (#2) to determine if it
"^DIC",798.4,798.4,"%D",11,0)
has been changed since the last registry data
"^DIC",798.4,798.4,"%D",12,0)
extraction. These fields are updated with the
"^DIC",798.4,798.4,"%D",13,0)
values from the PATIENT file and the UPDATE
"^DIC",798.4,798.4,"%D",14,0)
DEMOGRAPHICS flag is set to "Yes" in all active
"^DIC",798.4,798.4,"%D",15,0)
registry records of the patient.
"^DIC",798.4,798.4,"%D",16,0)
 
"^DIC",798.4,798.4,"%D",17,0)
Records in the file have the same internal entry 
"^DIC",798.4,798.4,"%D",18,0)
numbers as the patients' records in the PATIENT
"^DIC",798.4,798.4,"%D",19,0)
file. The records are uniquely identified by
"^DIC",798.4,798.4,"%D",20,0)
internal value of the PATIENT NAME field.
"^DIC",798.4,798.4,"%D",21,0)
 
"^DIC",798.4,798.4,"%D",22,0)
A permanent screen (the ^DD(798.4,0,"SCR") node) 
"^DIC",798.4,798.4,"%D",23,0)
restricts access to the records of this file. Only
"^DIC",798.4,798.4,"%D",24,0)
users with the security key(s) for any defined
"^DIC",798.4,798.4,"%D",25,0)
registry (or those with the ROR VA IRM security
"^DIC",798.4,798.4,"%D",26,0)
key) can access records of the file.
"^DIC",798.4,798.4,"%D",27,0)
 
"^DIC",798.4,798.4,"%D",28,0)
If you want the changes in the security keys
"^DIC",798.4,798.4,"%D",29,0)
allocation to have an effect immediately, you 
"^DIC",798.4,798.4,"%D",30,0)
should rebuild the "ACL" cross-reference of the
"^DIC",798.4,798.4,"%D",31,0)
.01 field of the SECURITY KEY multiple of the ROR
"^DIC",798.4,798.4,"%D",32,0)
REGISTRY PARAMETERS file (#798.1). See the
"^DIC",798.4,798.4,"%D",33,0)
description of the cross-reference for more
"^DIC",798.4,798.4,"%D",34,0)
details.
"^DIC",798.4,"B","ROR PATIENT",798.4)
 
"^DIC",798.7,798.7,0)
ROR LOG^798.7
"^DIC",798.7,798.7,0,"GL")
^RORDATA(798.7,
"^DIC",798.7,798.7,"%",0)
^1.005^^0
"^DIC",798.7,798.7,"%D",0)
^^22^22^3021223^
"^DIC",798.7,798.7,"%D",1,0)
The ROR LOG file is used for recording different
"^DIC",798.7,798.7,"%D",2,0)
kinds of events (errors, debug messages, etc.)
"^DIC",798.7,798.7,"%D",3,0)
that are generated by registry processes.
"^DIC",798.7,798.7,"%D",4,0)
 
"^DIC",798.7,798.7,"%D",5,0)
You may control event recording via parameters in
"^DIC",798.7,798.7,"%D",6,0)
the ROR REGISTRY PARAMETERS file. Look for
"^DIC",798.7,798.7,"%D",7,0)
additional information in the RORLOG and RORERR
"^DIC",798.7,798.7,"%D",8,0)
routines.
"^DIC",798.7,798.7,"%D",9,0)
 
"^DIC",798.7,798.7,"%D",10,0)
A permanent screen (the ^DD(798.7,0,"SCR") node) 
"^DIC",798.7,798.7,"%D",11,0)
restricts access to records of this file. Only
"^DIC",798.7,798.7,"%D",12,0)
users with the security key(s) for any defined 
"^DIC",798.7,798.7,"%D",13,0)
registry (or those with the ROR VA IRM security
"^DIC",798.7,798.7,"%D",14,0)
key) can access records of the file.
"^DIC",798.7,798.7,"%D",15,0)
 
"^DIC",798.7,798.7,"%D",16,0)
If you want the changes in the security keys 
"^DIC",798.7,798.7,"%D",17,0)
allocation to have an effect immediately, you
"^DIC",798.7,798.7,"%D",18,0)
should rebuild the "ACL" cross-reference of the
"^DIC",798.7,798.7,"%D",19,0)
.01 field of the SECURITY KEY multiple of the ROR
"^DIC",798.7,798.7,"%D",20,0)
REGISTRY PARAMETERS file (#798.1). See the 
"^DIC",798.7,798.7,"%D",21,0)
description of the cross-reference for more
"^DIC",798.7,798.7,"%D",22,0)
details.
"^DIC",798.7,"B","ROR LOG",798.7)
 
**END**
**END**
