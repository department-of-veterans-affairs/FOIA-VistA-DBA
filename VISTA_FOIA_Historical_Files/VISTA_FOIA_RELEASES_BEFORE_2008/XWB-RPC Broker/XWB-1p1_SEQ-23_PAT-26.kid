Released XWB*1.1*26 SEQ #23
Extracted from mail message
**KIDS**:XWB*1.1*26^

**INSTALL NAME**
XWB*1.1*26
"BLD",407,0)
XWB*1.1*26^RPC BROKER^0^3020508^y
"BLD",407,1,0)
^^2^2^3020508^
"BLD",407,1,1,0)
The description for this patch may be found in the patch message or in 
"BLD",407,1,2,0)
the patch module on Forum.
"BLD",407,4,0)
^9.64PA^^
"BLD",407,"KRN",0)
^9.67PA^8989.52^19
"BLD",407,"KRN",.4,0)
.4
"BLD",407,"KRN",.401,0)
.401
"BLD",407,"KRN",.402,0)
.402
"BLD",407,"KRN",.403,0)
.403
"BLD",407,"KRN",.5,0)
.5
"BLD",407,"KRN",.84,0)
.84
"BLD",407,"KRN",3.6,0)
3.6
"BLD",407,"KRN",3.8,0)
3.8
"BLD",407,"KRN",9.2,0)
9.2
"BLD",407,"KRN",9.8,0)
9.8
"BLD",407,"KRN",9.8,"NM",0)
^9.68A^3^3
"BLD",407,"KRN",9.8,"NM",1,0)
XWBBRK^^0^B34141325
"BLD",407,"KRN",9.8,"NM",2,0)
XWBLIB^^0^B10022824
"BLD",407,"KRN",9.8,"NM",3,0)
XWBTCPC^^0^B37398165
"BLD",407,"KRN",9.8,"NM","B","XWBBRK",1)

"BLD",407,"KRN",9.8,"NM","B","XWBLIB",2)

"BLD",407,"KRN",9.8,"NM","B","XWBTCPC",3)

"BLD",407,"KRN",19,0)
19
"BLD",407,"KRN",19.1,0)
19.1
"BLD",407,"KRN",101,0)
101
"BLD",407,"KRN",409.61,0)
409.61
"BLD",407,"KRN",771,0)
771
"BLD",407,"KRN",870,0)
870
"BLD",407,"KRN",8989.51,0)
8989.51
"BLD",407,"KRN",8989.52,0)
8989.52
"BLD",407,"KRN",8994,0)
8994
"BLD",407,"KRN","B",.4,.4)

"BLD",407,"KRN","B",.401,.401)

"BLD",407,"KRN","B",.402,.402)

"BLD",407,"KRN","B",.403,.403)

"BLD",407,"KRN","B",.5,.5)

"BLD",407,"KRN","B",.84,.84)

"BLD",407,"KRN","B",3.6,3.6)

"BLD",407,"KRN","B",3.8,3.8)

"BLD",407,"KRN","B",9.2,9.2)

"BLD",407,"KRN","B",9.8,9.8)

"BLD",407,"KRN","B",19,19)

"BLD",407,"KRN","B",19.1,19.1)

"BLD",407,"KRN","B",101,101)

"BLD",407,"KRN","B",409.61,409.61)

"BLD",407,"KRN","B",771,771)

"BLD",407,"KRN","B",870,870)

"BLD",407,"KRN","B",8989.51,8989.51)

"BLD",407,"KRN","B",8989.52,8989.52)

"BLD",407,"KRN","B",8994,8994)

"BLD",407,"QUES",0)
^9.62^^
"BLD",407,"REQB",0)
^9.611^^
"MBREQ")
0
"PKG",7,-1)
1^1
"PKG",7,0)
RPC BROKER^XWB^Remote Procedure Call Broker
"PKG",7,20,0)
^9.402P^^
"PKG",7,22,0)
^9.49I^1^1
"PKG",7,22,1,0)
1.1^2970918^2990407^126
"PKG",7,22,1,"PAH",1,0)
26^3020508
"PKG",7,22,1,"PAH",1,1,0)
^^2^2^3020508
"PKG",7,22,1,"PAH",1,1,1,0)
The description for this patch may be found in the patch message or in 
"PKG",7,22,1,"PAH",1,1,2,0)
the patch module on Forum.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
3
"RTN","XWBBRK")
0^1^B34141325
"RTN","XWBBRK",1,0)
XWBBRK ;ISC-SF/EG - DHCP BROKER PROTOYPE ;3/5/02  12:19
"RTN","XWBBRK",2,0)
 ;;1.1;RPC BROKER;**2,4,10,16,26**;Mar 28, 1997
"RTN","XWBBRK",3,0)
PRSP(P) ;Parse Protocol
"RTN","XWBBRK",4,0)
 ;M Extrinsic Function
"RTN","XWBBRK",5,0)
 ;
"RTN","XWBBRK",6,0)
 ;Inputs
"RTN","XWBBRK",7,0)
 ;P        Protocol string with the form
"RTN","XWBBRK",8,0)
 ;         Protocol := Protocol Header^Message where
"RTN","XWBBRK",9,0)
 ;         Protocol Header := LLLWKID;WINH;PRCH;WISH;MESG
"RTN","XWBBRK",10,0)
 ;           LLL  := length of protocol header (3 numeric)
"RTN","XWBBRK",11,0)
 ;           WKID := Workstation ID (ALPHA)
"RTN","XWBBRK",12,0)
 ;           WINH := Window handle (ALPHA)
"RTN","XWBBRK",13,0)
 ;           PRCH := Process handle (ALPHA)
"RTN","XWBBRK",14,0)
 ;           WISH := Window server handle (ALPHA)
"RTN","XWBBRK",15,0)
 ;           MESG := Unparsed message
"RTN","XWBBRK",16,0)
 ;Outputs
"RTN","XWBBRK",17,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",18,0)
 ;
"RTN","XWBBRK",19,0)
 N ERR,C,M,R,X,U
"RTN","XWBBRK",20,0)
 S U="U",R=0,C=";",ERR=0,M=512 ;Maximum buffer input
"RTN","XWBBRK",21,0)
 IF $E(P,1,5)="{XWB}" S P=$E(P,6,$L(P)) ;drop out prefix
"RTN","XWBBRK",22,0)
 IF '+$G(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",23,0)
 IF +ERR=0 D
"RTN","XWBBRK",24,0)
 . S XWB(R,"LENG")=+$E(P,1,3)
"RTN","XWBBRK",25,0)
 . S X=$E(P,4,XWB(R,"LENG")+3)
"RTN","XWBBRK",26,0)
 . S XWB(R,"MESG")=$E(P,XWB(R,"LENG")+4,M)
"RTN","XWBBRK",27,0)
 . S XWB(R,"WKID")=$P(X,C)
"RTN","XWBBRK",28,0)
 . S XWB(R,"WINH")=$P(X,C,2)
"RTN","XWBBRK",29,0)
 . S XWB(R,"PRCH")=$P(X,C,3)
"RTN","XWBBRK",30,0)
 . S XWB(R,"WISH")=$P(X,C,4)
"RTN","XWBBRK",31,0)
 Q ERR
"RTN","XWBBRK",32,0)
 ;
"RTN","XWBBRK",33,0)
PRSM(P) ;Parse message
"RTN","XWBBRK",34,0)
 ;M Extrinsic Function
"RTN","XWBBRK",35,0)
 ;
"RTN","XWBBRK",36,0)
 ;Inputs
"RTN","XWBBRK",37,0)
 ;P        Message string with the form
"RTN","XWBBRK",38,0)
 ;         Message := Header^Content
"RTN","XWBBRK",39,0)
 ;           Header  := LLL;FLAG
"RTN","XWBBRK",40,0)
 ;             LLL     := length of entire message (3 numeric)
"RTN","XWBBRK",41,0)
 ;             FLAG    := 1 indicates variables follow
"RTN","XWBBRK",42,0)
 ;           Content := Contains API call information
"RTN","XWBBRK",43,0)
 ;Outputs
"RTN","XWBBRK",44,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",45,0)
 N C,ERR,M,R,X,U
"RTN","XWBBRK",46,0)
 S U="^",R=1,C=";",ERR=0,M=512 ;Max buffer
"RTN","XWBBRK",47,0)
 IF '+$G(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",48,0)
 IF +ERR=0 D
"RTN","XWBBRK",49,0)
 . S XWB(R,"LENG")=+$E(P,1,5)
"RTN","XWBBRK",50,0)
 . S XWB(R,"FLAG")=$E(P,6,6)
"RTN","XWBBRK",51,0)
 . S XWB(R,"TEXT")=$E(P,7,M)
"RTN","XWBBRK",52,0)
 Q ERR
"RTN","XWBBRK",53,0)
 ;
"RTN","XWBBRK",54,0)
PRSA(P) ;Parse API information, get calling info
"RTN","XWBBRK",55,0)
 ;M Extrinsic Function
"RTN","XWBBRK",56,0)
 ;Inputs
"RTN","XWBBRK",57,0)
 ;P        Content := API Name^Param string
"RTN","XWBBRK",58,0)
 ;           API     := .01 field of API file
"RTN","XWBBRK",59,0)
 ;           Param   := Parameter information
"RTN","XWBBRK",60,0)
 ;Outputs
"RTN","XWBBRK",61,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",62,0)
 ;
"RTN","XWBBRK",63,0)
 N C,DR,ERR,M,R,T,X,U
"RTN","XWBBRK",64,0)
 S U="^",R=2,C=";",ERR=0,M=512 ;Max buffer
"RTN","XWBBRK",65,0)
 IF '+$L(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",66,0)
 IF +ERR=0 D
"RTN","XWBBRK",67,0)
 . S XWB(R,"CAPI")=$P(P,U)
"RTN","XWBBRK",68,0)
 . S XWB(R,"PARM")=$E(P,$F(P,U),M)
"RTN","XWBBRK",69,0)
 . S T=$O(^XWB(8994,"B",XWB(R,"CAPI"),0))
"RTN","XWBBRK",70,0)
 . I '+T S ERR="-1^Remote Procedure '"_XWB(R,"CAPI")_"' doesn't exist on the server." Q  ;P10 - dpc
"RTN","XWBBRK",71,0)
 . S T(0)=$G(^XWB(8994,T,0))
"RTN","XWBBRK",72,0)
 . I $P(T(0),U,6)=1!($P(T(0),U,6)=2) S ERR="-1^Remote Procedure '"_XWB(R,"CAPI")_"' cannot be run at this time." Q  ;P10. Check INACTIVE field. - dpc.
"RTN","XWBBRK",73,0)
 . S XWB(R,"NAME")=$P(T(0),"^")
"RTN","XWBBRK",74,0)
 . S XWB(R,"RTAG")=$P(T(0),"^",2)
"RTN","XWBBRK",75,0)
 . S XWB(R,"RNAM")=$P(T(0),"^",3)
"RTN","XWBBRK",76,0)
 . S XWBPTYPE=$P(T(0),"^",4)
"RTN","XWBBRK",77,0)
 . S XWBWRAP=+$P(T(0),"^",8)
"RTN","XWBBRK",78,0)
 Q ERR
"RTN","XWBBRK",79,0)
 ;
"RTN","XWBBRK",80,0)
PRSB(P) ;Parse Parameter information
"RTN","XWBBRK",81,0)
 ;M Extrinsic Function
"RTN","XWBBRK",82,0)
 ;Inputs
"RTN","XWBBRK",83,0)
 ;P        Param   := M parameter list
"RTN","XWBBRK",84,0)
 ;           Param   := LLL,Name,Value
"RTN","XWBBRK",85,0)
 ;             LLL     := length of variable name and value
"RTN","XWBBRK",86,0)
 ;             Name    := name of M variable
"RTN","XWBBRK",87,0)
 ;             Value   := a string
"RTN","XWBBRK",88,0)
 ;Outputs
"RTN","XWBBRK",89,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBBRK",90,0)
 ;
"RTN","XWBBRK",91,0)
 N A,ERR,F,FL,I,K,L,M,P1,P2,P3,P4,P5,MAXP,R
"RTN","XWBBRK",92,0)
 S R=3,MAXP=+$E(P,1,5)
"RTN","XWBBRK",93,0)
 S P1=$E(P,6,MAXP+5) ;only param string
"RTN","XWBBRK",94,0)
 S ERR=0,F=3,M=512
"RTN","XWBBRK",95,0)
 IF '+$D(P) S ERR="-1^Required input reference is NULL"
"RTN","XWBBRK",96,0)
 S FL=+$G(XWB(1,"FLAG"))
"RTN","XWBBRK",97,0)
 S I=0
"RTN","XWBBRK",98,0)
 IF '+ERR D
"RTN","XWBBRK",99,0)
 . ;IF 'FL S P1=$E(P,F+1,MAXP) Q
"RTN","XWBBRK",100,0)
 . IF 'FL,+MAXP=0 S P1="",ERR=1 Q
"RTN","XWBBRK",101,0)
 . F  D  Q:P1=""
"RTN","XWBBRK",102,0)
 . . Q:P1=""
"RTN","XWBBRK",103,0)
 . . S L=+$E(P1,1,3)-1
"RTN","XWBBRK",104,0)
 . . S P3=+$E(P1,4,4)
"RTN","XWBBRK",105,0)
 . . S P1=$E(P1,5,MAXP)
"RTN","XWBBRK",106,0)
 . . S XWB(R,"P",I)=$S(P3'=1:$E(P1,1,L),1:$$GETV($E(P1,1,L)))
"RTN","XWBBRK",107,0)
 . . IF FL=1,P3=2 D  ;XWB*1.1*2
"RTN","XWBBRK",108,0)
 . . . S A=$$OARY^XWBBRK2,XWBARY=A
"RTN","XWBBRK",109,0)
 . . . S XWB(R,"P",I)=$$CREF^XWBBRK2(A,XWB(R,"P",I))
"RTN","XWBBRK",110,0)
 . . S P1=$E(P1,L+1,MAXP)
"RTN","XWBBRK",111,0)
 . . S K=I,I=I+1
"RTN","XWBBRK",112,0)
 . IF 'FL Q
"RTN","XWBBRK",113,0)
 . S P3=P
"RTN","XWBBRK",114,0)
 . S L=+$E(P3,1,5)
"RTN","XWBBRK",115,0)
 . S P1=$E(P3,F+3,L+F)
"RTN","XWBBRK",116,0)
 . ;IF FL=1 S P1=$$CREF^XWBBRK2(A,P1) ;convert array ref to namespace ref
"RTN","XWBBRK",117,0)
 . S P2=$E(P3,L+F+3,M)
"RTN","XWBBRK",118,0)
 . ;instantiate array
"RTN","XWBBRK",119,0)
 . ;S DM=0
"RTN","XWBBRK",120,0)
 . F  D  Q:+L=0
"RTN","XWBBRK",121,0)
 . . S L=$$BREAD(3) Q:+L=0  S P3=$$BREAD(L)
"RTN","XWBBRK",122,0)
 . . S L=$$BREAD(3) IF +L'=0 S P4=$$BREAD(L)
"RTN","XWBBRK",123,0)
 . . IF +L=0 Q
"RTN","XWBBRK",124,0)
 . . ;E  S L=3,P4=$$BREAD(L) IF P4=0 S P4=""
"RTN","XWBBRK",125,0)
 . . IF P3=0,P4=0 S L=0 Q
"RTN","XWBBRK",126,0)
 . . IF FL=1 D LINST(A,P3,P4)
"RTN","XWBBRK",127,0)
 . . IF FL=2 D GINST
"RTN","XWBBRK",128,0)
 . . ;S DM=DM+1
"RTN","XWBBRK",129,0)
 IF ERR Q P1
"RTN","XWBBRK",130,0)
 S P1=""
"RTN","XWBBRK",131,0)
 D  Q P1
"RTN","XWBBRK",132,0)
 . F I=0:1:K D
"RTN","XWBBRK",133,0)
 . . IF FL,$E(XWB(R,"P",I),1,5)=".XWBS" D  Q  ;XWB*1.1*2
"RTN","XWBBRK",134,0)
 . . . S P1=P1_"."_$E(XWB(R,"P",I),2,$L(XWB(R,"P",I)))
"RTN","XWBBRK",135,0)
 . . . IF I'=K S P1=P1_","
"RTN","XWBBRK",136,0)
 . . S P1=P1_"XWB("_R_",""P"","_I_")"
"RTN","XWBBRK",137,0)
 . . IF I'=K S P1=P1_","
"RTN","XWBBRK",138,0)
 IF '+ERR Q P1
"RTN","XWBBRK",139,0)
 Q ERR
"RTN","XWBBRK",140,0)
 ;
"RTN","XWBBRK",141,0)
BREAD(L) ;read tcp buffer, L is length
"RTN","XWBBRK",142,0)
 N E,X,DONE
"RTN","XWBBRK",143,0)
 S (E,DONE)=0
"RTN","XWBBRK",144,0)
 R X#L:XWBTIME(1)
"RTN","XWBBRK",145,0)
 S E=X
"RTN","XWBBRK",146,0)
 IF $L(E)<L F  D  Q:'DONE
"RTN","XWBBRK",147,0)
 . IF $L(E)=L S DONE=1 Q
"RTN","XWBBRK",148,0)
 . R X#(L-$L(E)):XWBTIME(1)
"RTN","XWBBRK",149,0)
 . S E=E_X
"RTN","XWBBRK",150,0)
 Q E
"RTN","XWBBRK",151,0)
 ;
"RTN","XWBBRK",152,0)
CALLP(XWBP,P,DEBUG) ;make API call using Protocol string
"RTN","XWBBRK",153,0)
 N ERR,S
"RTN","XWBBRK",154,0)
 S ERR=0
"RTN","XWBBRK",155,0)
 IF '$D(DEBUG) S DEBUG=0
"RTN","XWBBRK",156,0)
 ;IF 'DEBUG D:$D(XRTL) T0^%ZOSV ;start RTL
"RTN","XWBBRK",157,0)
 S ERR=$$PRSP(P)
"RTN","XWBBRK",158,0)
 IF '+ERR S ERR=$$PRSM(XWB(0,"MESG"))
"RTN","XWBBRK",159,0)
 IF '+ERR S ERR=$$PRSA(XWB(1,"TEXT")) I $G(XWB(2,"CAPI"))="XUS SET SHARED" S XWBSHARE=1 Q
"RTN","XWBBRK",160,0)
 I +ERR S XWBSEC=$P(ERR,U,2) ;P10 -- dpc
"RTN","XWBBRK",161,0)
 IF '+ERR S S=$$PRSB(XWB(2,"PARM"))
"RTN","XWBBRK",162,0)
 ;IF (+S=0)!(+S>0) D
"RTN","XWBBRK",163,0)
 I '+ERR D CHKPRMIT^XWBSEC(XWB(2,"CAPI")) ;checks if RPC allowed to run
"RTN","XWBBRK",164,0)
 S:$L($G(XWBSEC)) ERR="-1^"_XWBSEC
"RTN","XWBBRK",165,0)
 ;IF 'DEBUG S:$D(XRT0) XRTN="RPC BROKER READ/PARSE" D:$D(XRT0) T1^%ZOSV ;stop RTL
"RTN","XWBBRK",166,0)
 IF '+ERR,(+S=0)!(+S>0) D
"RTN","XWBBRK",167,0)
 . D CAPI^XWBBRK2(.XWBP,XWB(2,"RTAG"),XWB(2,"RNAM"),S)
"RTN","XWBBRK",168,0)
 E  D CLRBUF ;p10
"RTN","XWBBRK",169,0)
 IF 'DEBUG K XWB
"RTN","XWBBRK",170,0)
 IF $D(XWBARY) K @XWBARY,XWBARY
"RTN","XWBBRK",171,0)
 Q
"RTN","XWBBRK",172,0)
 ;
"RTN","XWBBRK",173,0)
LINST(A,X,XWBY) ;instantiate local array
"RTN","XWBBRK",174,0)
 IF XWBY=$C(1) S XWBY=""
"RTN","XWBBRK",175,0)
 S X=A_"("_X_")"
"RTN","XWBBRK",176,0)
 S @X=XWBY
"RTN","XWBBRK",177,0)
 Q
"RTN","XWBBRK",178,0)
GINST ;instantiate global
"RTN","XWBBRK",179,0)
 N DONE,N,T,T1
"RTN","XWBBRK",180,0)
 S (DONE,I)=0
"RTN","XWBBRK",181,0)
 ;find piece with global ref - recover $C(44)
"RTN","XWBBRK",182,0)
 S REF=$TR(REF,$C(23),$C(44))
"RTN","XWBBRK",183,0)
 F  D  Q:DONE
"RTN","XWBBRK",184,0)
 . S N=$NA(^TMP("XWB",$J,$P($H,",",2)))
"RTN","XWBBRK",185,0)
 . S XWB("FRM")=REF
"RTN","XWBBRK",186,0)
 . S XWB("TO")=N
"RTN","XWBBRK",187,0)
 . IF '$D(@N) S DONE=1 Q
"RTN","XWBBRK",188,0)
 ;loop through all and instantiate
"RTN","XWBBRK",189,0)
 S DONE=0
"RTN","XWBBRK",190,0)
 F  D  Q:DONE
"RTN","XWBBRK",191,0)
 . S T=$E(@REF@(I),4,M)
"RTN","XWBBRK",192,0)
 . IF T="" S DONE=1 Q
"RTN","XWBBRK",193,0)
 . S @N@("XWB")="" ;set naked indicator
"RTN","XWBBRK",194,0)
 . S @T
"RTN","XWBBRK",195,0)
 . S I=I+1
"RTN","XWBBRK",196,0)
 K @N@("XWB")
"RTN","XWBBRK",197,0)
 Q
"RTN","XWBBRK",198,0)
 ;
"RTN","XWBBRK",199,0)
GETV(V) ;get value of V - reference parameter
"RTN","XWBBRK",200,0)
 N X
"RTN","XWBBRK",201,0)
 S X=V
"RTN","XWBBRK",202,0)
 IF $E(X,1,2)="$$" Q ""
"RTN","XWBBRK",203,0)
 IF $C(34,36)[$E(V) X "S V="_$$VCHK(V)
"RTN","XWBBRK",204,0)
 E  S V=@V
"RTN","XWBBRK",205,0)
 Q V
"RTN","XWBBRK",206,0)
 ;
"RTN","XWBBRK",207,0)
VCHK(S) ;Parse string for first argument
"RTN","XWBBRK",208,0)
 N C,I,P
"RTN","XWBBRK",209,0)
 F I=1:1 S C=$E(S,I) D VCHKP:C="(",VCHKQ:C=$C(34) Q:" ,"[C
"RTN","XWBBRK",210,0)
 Q $E(S,1,I-1)
"RTN","XWBBRK",211,0)
VCHKP S P=1 ;Find closing paren
"RTN","XWBBRK",212,0)
 F I=I+1:1 S C=$E(S,I) Q:P=0!(C="")  I "()"""[C D VCHKQ:C=$C(34) S P=P+$S("("[C:1,")"[C:-1,1:0)
"RTN","XWBBRK",213,0)
 Q
"RTN","XWBBRK",214,0)
VCHKQ ;Find closing quote
"RTN","XWBBRK",215,0)
 F I=I+1:1 S C=$E(S,I) Q:C=""!(C=$C(34))
"RTN","XWBBRK",216,0)
 Q
"RTN","XWBBRK",217,0)
CLRBUF ;p10  Empties Input buffer
"RTN","XWBBRK",218,0)
 N %
"RTN","XWBBRK",219,0)
 F  R %#1:XWBTIME(1) Q:%=""
"RTN","XWBBRK",220,0)
 Q
"RTN","XWBLIB")
0^2^B10022824
"RTN","XWBLIB",1,0)
XWBLIB ;SFISC/VYD - Various remote procedure library ;4/5/02  15:38
"RTN","XWBLIB",2,0)
 ;;1.1;RPC BROKER;**6,10,26**;Mar 28, 1997
"RTN","XWBLIB",3,0)
 Q
"RTN","XWBLIB",4,0)
 ;
"RTN","XWBLIB",5,0)
BROKER() ;EF. Running under the Broker
"RTN","XWBLIB",6,0)
 Q $D(XWBOS)
"RTN","XWBLIB",7,0)
 ;
"RTN","XWBLIB",8,0)
RTRNFMT(X,WRAP) ;EF. set the RPC return type and wrap flag
"RTN","XWBLIB",9,0)
 N Y
"RTN","XWBLIB",10,0)
 S:$D(WRAP) XWBWRAP=+WRAP
"RTN","XWBLIB",11,0)
 S X=$G(X)
"RTN","XWBLIB",12,0)
 IF X=+X,X>0,X<6 S XWBPTYPE=X Q X
"RTN","XWBLIB",13,0)
 S X=$$UP^XLFSTR(X)
"RTN","XWBLIB",14,0)
 S X=$S(X="SINGLE VALUE":1,X="ARRAY":2,X="WORD PROCESSING":3,X="GLOBAL ARRAY":4,X="GLOBAL INSTANCE":5,1:0)
"RTN","XWBLIB",15,0)
 IF X=0 Q 0
"RTN","XWBLIB",16,0)
 S XWBPTYPE=X
"RTN","XWBLIB",17,0)
 Q X
"RTN","XWBLIB",18,0)
 ;
"RTN","XWBLIB",19,0)
VARVAL(RESULT,VARIABLE) ;returns value of passed in variable
"RTN","XWBLIB",20,0)
 S RESULT=VARIABLE ;can do this with the REFERENCE type parameter
"RTN","XWBLIB",21,0)
 Q
"RTN","XWBLIB",22,0)
 ;See GETV^XWBBRK for how we get the REFERENCE type parameter
"RTN","XWBLIB",23,0)
 ;
"RTN","XWBLIB",24,0)
IMHERE(RESULT) ;P6
"RTN","XWBLIB",25,0)
 ;Entry point for XWB IM HERE remote procedure
"RTN","XWBLIB",26,0)
 S RESULT=1
"RTN","XWBLIB",27,0)
 Q
"RTN","XWBLIB",28,0)
 ;
"RTN","XWBLIB",29,0)
BRKRINFO(RESULT) ;P6
"RTN","XWBLIB",30,0)
 ;Entry point for XWB GET BROKER INFO RPC.
"RTN","XWBLIB",31,0)
 ;R(0) = Length of handler read timeout
"RTN","XWBLIB",32,0)
 S RESULT(0)=$$BAT^XUPARAM
"RTN","XWBLIB",33,0)
 Q
"RTN","XWBLIB",34,0)
 ;
"RTN","XWBLIB",35,0)
CKRPC(RESULT,RPCNAME,RPCUSE,VERNUM) ;P10
"RTN","XWBLIB",36,0)
 ;Entry point for "XWB IS RPC AVIALABLE" RPC.
"RTN","XWBLIB",37,0)
 ;RPCUSE("L" or "R") and VERNUM are optional.
"RTN","XWBLIB",38,0)
 ;Checks if RPC exists and if INACTIVE flag is set for specified use.
"RTN","XWBLIB",39,0)
 ;Also checks version number if passed.
"RTN","XWBLIB",40,0)
 ;Result = 1 for can be run; 0 for can't be run.
"RTN","XWBLIB",41,0)
 N RPCIEN
"RTN","XWBLIB",42,0)
 S RESULT=0
"RTN","XWBLIB",43,0)
 S RPCIEN=$$RPCIEN($G(RPCNAME))
"RTN","XWBLIB",44,0)
 I RPCIEN,$$RPCAVAIL(RPCIEN,$G(RPCUSE),$G(VERNUM)) S RESULT=1
"RTN","XWBLIB",45,0)
 Q
"RTN","XWBLIB",46,0)
 ;
"RTN","XWBLIB",47,0)
CKRPCS(RESULT,RPCUSE,RPC) ;P10
"RTN","XWBLIB",48,0)
 ;Entry point for "XWB ARE RPCS AVIALABLE" RPC.
"RTN","XWBLIB",49,0)
 ;RPCUSE("L" or "R") and VERNUM are optional.
"RTN","XWBLIB",50,0)
 ;RPC() array has format RPCName^RPCVersionNumber.
"RTN","XWBLIB",51,0)
 ;Checks if RPC exists and version number (if not null).
"RTN","XWBLIB",52,0)
 ;Check INACTIVE flag if set for specified use.
"RTN","XWBLIB",53,0)
 ;Result(I) = 1 for can be run; 0 for can't be run.
"RTN","XWBLIB",54,0)
 N I
"RTN","XWBLIB",55,0)
 S I=""
"RTN","XWBLIB",56,0)
 F  S I=$O(RPC(I)) Q:I=""  D
"RTN","XWBLIB",57,0)
 . N RPCNAME,VERNUM,RPCIEN
"RTN","XWBLIB",58,0)
 . S RESULT(I)=0
"RTN","XWBLIB",59,0)
 . S RPCNAME=$P(RPC(I),U)
"RTN","XWBLIB",60,0)
 . S VERNUM=$P(RPC(I),U,2)
"RTN","XWBLIB",61,0)
 . S RPCIEN=$$RPCIEN($G(RPCNAME))
"RTN","XWBLIB",62,0)
 . I RPCIEN,$$RPCAVAIL(RPCIEN,$G(RPCUSE),$G(VERNUM)) S RESULT(I)=1
"RTN","XWBLIB",63,0)
 Q
"RTN","XWBLIB",64,0)
 ;
"RTN","XWBLIB",65,0)
RPCIEN(RPCNAME) ;P10
"RTN","XWBLIB",66,0)
 ;Function that returns IEN of RPC based on name.
"RTN","XWBLIB",67,0)
 ;Returns 0 if RPC does not exist.
"RTN","XWBLIB",68,0)
 I RPCNAME="" Q 0
"RTN","XWBLIB",69,0)
 Q +$O(^XWB(8994,"B",RPCNAME,0))
"RTN","XWBLIB",70,0)
 ;
"RTN","XWBLIB",71,0)
RPCAVAIL(RPCIEN,RPCUSE,VERNUM) ;P10
"RTN","XWBLIB",72,0)
 ;Boolean function, identifies if RPC is active and correct version.
"RTN","XWBLIB",73,0)
 ;RPCUSE (optional) = L check local use; R check remote use.
"RTN","XWBLIB",74,0)
 ;VERNUM (optional) only checked for remote RPCs.
"RTN","XWBLIB",75,0)
 N RPC0,INACT
"RTN","XWBLIB",76,0)
 S RPC0=$G(^XWB(8994,+RPCIEN,0))
"RTN","XWBLIB",77,0)
 Q:RPC0="" 0
"RTN","XWBLIB",78,0)
 S INACT=+$P(RPC0,U,6)
"RTN","XWBLIB",79,0)
 I INACT=1 Q 0 ;RPC marked inactive.
"RTN","XWBLIB",80,0)
 S RPCUSE=$G(RPCUSE)
"RTN","XWBLIB",81,0)
 I RPCUSE="" Q 1 ;Local and remote check not needed.
"RTN","XWBLIB",82,0)
 I RPCUSE="L",INACT=2 Q 0 ;Local use, RPC is remote only.
"RTN","XWBLIB",83,0)
 I RPCUSE="R",INACT=3 Q 0 ;Remote use, RPC is local only.
"RTN","XWBLIB",84,0)
 I RPCUSE="R",+$G(VERNUM),'$$CKVERNUM(VERNUM,+$P(RPC0,U,9)) Q 0 ;Failed version # check.
"RTN","XWBLIB",85,0)
 Q 1 ;Must be ok.
"RTN","XWBLIB",86,0)
 ;
"RTN","XWBLIB",87,0)
CKVERNUM(VERNUM,RPCVER,RPCIEN) ;P10
"RTN","XWBLIB",88,0)
 ;Boolean function. Returns 1 if RPC verion is > or = version number to be checked.
"RTN","XWBLIB",89,0)
 ;VERNUM = version number passed in (i.e., from client ap) to be checked.
"RTN","XWBLIB",90,0)
 ;RPCVER = version number in Remote Procedure file. (optional)
"RTN","XWBLIB",91,0)
 ;RPCIEN of RPC being checked. Needed if RPCVER not sent.
"RTN","XWBLIB",92,0)
 I +$G(RPCIEN),'+$G(RPCVER) S RPCVER=$P($G(^XWB(8994,RPCIEN,0)),U,9)
"RTN","XWBLIB",93,0)
 I +RPCVER<+VERNUM Q 0
"RTN","XWBLIB",94,0)
 Q 1
"RTN","XWBLIB",95,0)
 ;
"RTN","XWBLIB",96,0)
VARLST ;;XWB,XWBAPVER,XWBCLMAN,XWBNULL,XWBODEV,XWBOS,XWBP,XWBPTYPE,XWBR,XWBSEC,XWBSTATE,XWBTBUF,XWBTDEV,XWBTIME,XWBTIP,XWBTOS,XWBTSKT,XWBVER,XWBWRAP,XWBY,DEBUG,XWBSHARE,XUESVISI
"RTN","XWBLIB",97,0)
 ;P10.  Variable for exclusive NEW in KILL^XUSCLEAN
"RTN","XWBLIB",98,0)
 ;P26.  Added XWBSHARE
"RTN","XWBLIB",99,0)
 ;
"RTN","XWBTCPC")
0^3^B37398165
"RTN","XWBTCPC",1,0)
XWBTCPC ;ISC-SF/EG/VYD - TCP/IP PROCESS HANDLER ;3/5/02  16:29
"RTN","XWBTCPC",2,0)
 ;;1.1;RPC BROKER;**2,5,4,6,9,16,26**;Mar 28, 1997
"RTN","XWBTCPC",3,0)
 ;Based on:
"RTN","XWBTCPC",4,0)
 ;XQORTCPH ;SLC/KCM - Service TCP Messages
"RTN","XWBTCPC",5,0)
 ;Modified by ISC-SF/EG
"RTN","XWBTCPC",6,0)
 ; 0. No longer supports old style OERR messages
"RTN","XWBTCPC",7,0)
 ; 1. Makes call to RPC  broker
"RTN","XWBTCPC",8,0)
 ; 2. Handles MSM Server under Windows NT
"RTN","XWBTCPC",9,0)
 ; 3. Handles MSM under Unix - same as DSM
"RTN","XWBTCPC",10,0)
 ; 4. Result of an rpc call can be a closed form of global
"RTN","XWBTCPC",11,0)
 ; 5. Can receive a large local array, within limits of job
"RTN","XWBTCPC",12,0)
 ;    partition size.
"RTN","XWBTCPC",13,0)
 ; 6. Sets default device to NULL device prior to call, restores
"RTN","XWBTCPC",14,0)
 ;    at termination.  Prevents garbage from 'talking' calls.
"RTN","XWBTCPC",15,0)
 ; 7. All reads have a timeout.
"RTN","XWBTCPC",16,0)
 ; 8. Intro message is sent when first connected.
"RTN","XWBTCPC",17,0)
 ; 9. Uses callback model to connect to client
"RTN","XWBTCPC",18,0)
 ;
"RTN","XWBTCPC",19,0)
 ;
"RTN","XWBTCPC",20,0)
EN(XWBTIP,XWBTSKT,DUZ,XWBVER,XWBCLMAN) ; -- Main entry point
"RTN","XWBTCPC",21,0)
 N TYPE,XWBTBUF,XWBTBUF1,XWBTDEV,XWBTLEN,XWBTOS,XWBTRTN,XWBWRAP
"RTN","XWBTCPC",22,0)
 N X,XWBL,XWB1,XWB2,Y,XWBTIME,XWBPTYPE,XWBPLEN,XWBNULL,XWBODEV
"RTN","XWBTCPC",23,0)
 N XWBERROR,XWBSEC ;new error variable available to rpc calls
"RTN","XWBTCPC",24,0)
 N IO,IOP,L,XWBAPVER
"RTN","XWBTCPC",25,0)
 ;
"RTN","XWBTCPC",26,0)
 ;Set up the error trap
"RTN","XWBTCPC",27,0)
 S $ETRAP="D ^%ZTER H"
"RTN","XWBTCPC",28,0)
 ;start RUM for Broker Handler XWB*1.1*5
"RTN","XWBTCPC",29,0)
 D LOGRSRC^%ZOSV("$BROKER HANDLER$",2,1)
"RTN","XWBTCPC",30,0)
 ;
"RTN","XWBTCPC",31,0)
 S XWBCLMAN=$G(XWBCLMAN)
"RTN","XWBTCPC",32,0)
 S XWBOS=$$OS
"RTN","XWBTCPC",33,0)
 D SETTIME(1) ;Setup for sign-on time-out
"RTN","XWBTCPC",34,0)
 ;Use Kernel to open the connection back to the client on new port
"RTN","XWBTCPC",35,0)
 D CALL^%ZISTCP(XWBTIP,XWBTSKT) Q:POP  S XWBTDEV=IO,IO(0)=IO
"RTN","XWBTCPC",36,0)
 ;Attempt to share the license, Must have TCP port open first.
"RTN","XWBTCPC",37,0)
 U XWBTDEV I $T(SHARELIC^%ZOSV)'="" D SHARELIC^%ZOSV(1)
"RTN","XWBTCPC",38,0)
 ;setup null device "NULL"
"RTN","XWBTCPC",39,0)
 S %ZIS="0H",IOP="NULL" D ^%ZIS S XWBNULL=IO I POP S XWBERROR="No NULL device" D ^%ZTER Q
"RTN","XWBTCPC",40,0)
 D SAVDEV^%ZISUTL("XWBNULL")
"RTN","XWBTCPC",41,0)
 ;change process name
"RTN","XWBTCPC",42,0)
 D CHPRN("ip"_$P(XWBTIP,".",3,4)_":"_XWBTSKT)
"RTN","XWBTCPC",43,0)
RESTART N $ESTACK S $ETRAP="D ETRAP^XWBTCPC"
"RTN","XWBTCPC",44,0)
 S DIQUIET=1,U="^" D DT^DICRW
"RTN","XWBTCPC",45,0)
 U XWBTDEV D MAIN
"RTN","XWBTCPC",46,0)
 ;Turn off the error trap for the exit
"RTN","XWBTCPC",47,0)
 S $ETRAP=""
"RTN","XWBTCPC",48,0)
 I $G(DUZ) D LOGOUT^XUSRB
"RTN","XWBTCPC",49,0)
 K XWBR,XWBARY
"RTN","XWBTCPC",50,0)
 ;stop RUM for handler XWB*1.1*5
"RTN","XWBTCPC",51,0)
 D LOGRSRC^%ZOSV("$BROKER HANDLER$",2,2)
"RTN","XWBTCPC",52,0)
 D USE^%ZISUTL("XWBNULL"),CLOSE^%ZISUTL("XWBNULL")
"RTN","XWBTCPC",53,0)
 C XWBTDEV ;Close can get an error
"RTN","XWBTCPC",54,0)
 Q
"RTN","XWBTCPC",55,0)
 ;
"RTN","XWBTCPC",56,0)
MAIN ; -- main message processing loop
"RTN","XWBTCPC",57,0)
 F  D  Q:XWBTBUF="#BYE#"
"RTN","XWBTCPC",58,0)
 . S XWBAPVER=0
"RTN","XWBTCPC",59,0)
 . ;
"RTN","XWBTCPC",60,0)
 . ; -- read client request
"RTN","XWBTCPC",61,0)
 . R XWBTBUF#11:XWBTIME IF '$T D TIMEOUT S XWBTBUF="#BYE#" Q
"RTN","XWBTCPC",62,0)
 . I XWBTBUF="#BYE#" Q
"RTN","XWBTCPC",63,0)
 . S TYPE=$S($E(XWBTBUF,1,5)="{XWB}":1,1:0)  ;check HDR
"RTN","XWBTCPC",64,0)
 . I 'TYPE S XWBTBUF="#BYE#" D SNDERR W XWBTBUF,$C(4),! Q
"RTN","XWBTCPC",65,0)
 . S XWBTLEN=$E(XWBTBUF,6,10),L=$E(XWBTBUF,11,11)
"RTN","XWBTCPC",66,0)
 . I L="|" R L#1:XWBTIME(1) S L=$A(L) R XWBAPVER#L:XWBTIME(1) R XWBTBUF#5:XWBTIME(1)
"RTN","XWBTCPC",67,0)
 . E  R XWBTBUF#4:XWBTIME(1) S XWBTBUF=L_XWBTBUF
"RTN","XWBTCPC",68,0)
 . S XWBPLEN=XWBTBUF
"RTN","XWBTCPC",69,0)
 . R XWBTBUF#XWBPLEN:XWBTIME(1)
"RTN","XWBTCPC",70,0)
 . I $P(XWBTBUF,U)="TCPconnect" D  Q
"RTN","XWBTCPC",71,0)
 . . D SNDERR W "accept",$C(4),!  ;Ack
"RTN","XWBTCPC",72,0)
 . IF TYPE D
"RTN","XWBTCPC",73,0)
 . . K XWBR,XWBARY
"RTN","XWBTCPC",74,0)
 . . IF XWBTBUF="#BYE#" D SNDERR W "#BYE#",$C(4),! Q  ; -- clean disconnect
"RTN","XWBTCPC",75,0)
 . . S XWBTLEN=XWBTLEN-15
"RTN","XWBTCPC",76,0)
 . . D CALLP^XWBBRK(.XWBR,XWBTBUF)
"RTN","XWBTCPC",77,0)
 . . S XWBPTYPE=$S('$D(XWBPTYPE):1,XWBPTYPE<1:1,XWBPTYPE>6:1,1:XWBPTYPE)
"RTN","XWBTCPC",78,0)
 . IF XWBTBUF="#BYE#" Q
"RTN","XWBTCPC",79,0)
 . U XWBTDEV
"RTN","XWBTCPC",80,0)
 . D SNDERR ;Clears SNDERR parameters
"RTN","XWBTCPC",81,0)
 . D SND
"RTN","XWBTCPC",82,0)
 . D WRITE($C(4)) W:$X>0 ! ;send eot and flush buffer
"RTN","XWBTCPC",83,0)
 . I $G(XWBSHARE) D KILL1^XUSCLEAN ; CLEAN OUT PARTITION FOR SHARED BROKER
"RTN","XWBTCPC",84,0)
 Q  ;End Of Main
"RTN","XWBTCPC",85,0)
 ;
"RTN","XWBTCPC",86,0)
SNDERR ;send error information
"RTN","XWBTCPC",87,0)
 ;XWBSEC is the security packet, XWBERROR is application packet
"RTN","XWBTCPC",88,0)
 N X
"RTN","XWBTCPC",89,0)
 S X=$E($G(XWBSEC),1,255)
"RTN","XWBTCPC",90,0)
 W $C($L(X))_X W:($X+$L(X)+1)>512 !
"RTN","XWBTCPC",91,0)
 S X=$E($G(XWBERROR),1,255)
"RTN","XWBTCPC",92,0)
 W $C($L(X))_X W:($X+$L(X)+1)>512 !
"RTN","XWBTCPC",93,0)
 S XWBERROR="",XWBSEC="" ;clears parameters
"RTN","XWBTCPC",94,0)
 Q
"RTN","XWBTCPC",95,0)
 ;
"RTN","XWBTCPC",96,0)
WRITE(STR) ;Write a data string
"RTN","XWBTCPC",97,0)
 I XWBOS="MSM" W STR Q
"RTN","XWBTCPC",98,0)
 ; send data for DSM (requires buffer flush (!) every 511 chars)
"RTN","XWBTCPC",99,0)
 ;IF XWBOS="DSM"!(XWBOS="UNIX")!(XWBOS="OpenM) next line
"RTN","XWBTCPC",100,0)
 I $L(STR)<511 W:($X+$L(STR))>511 ! W STR Q
"RTN","XWBTCPC",101,0)
 ;Handle a long string
"RTN","XWBTCPC",102,0)
 W:$X>0 ! ;Flush what is in the buffer
"RTN","XWBTCPC",103,0)
 F  Q:'$L(STR)  W $E(STR,1,510),! S STR=$E(STR,511,99999)
"RTN","XWBTCPC",104,0)
 Q
"RTN","XWBTCPC",105,0)
SND ; -- send data for all, Let WRITE sort it out
"RTN","XWBTCPC",106,0)
 N I,T
"RTN","XWBTCPC",107,0)
 ;
"RTN","XWBTCPC",108,0)
 ; -- error or abort occurred, send null
"RTN","XWBTCPC",109,0)
 IF $L(XWBSEC)>0 D WRITE("") Q
"RTN","XWBTCPC",110,0)
 ; -- single value
"RTN","XWBTCPC",111,0)
 IF XWBPTYPE=1 S XWBR=$G(XWBR) D WRITE(XWBR) Q
"RTN","XWBTCPC",112,0)
 ; -- table delimited by CR+LF
"RTN","XWBTCPC",113,0)
 IF XWBPTYPE=2 D  Q
"RTN","XWBTCPC",114,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  D WRITE(XWBR(I)),WRITE($C(13,10))
"RTN","XWBTCPC",115,0)
 ; -- word processing
"RTN","XWBTCPC",116,0)
 IF XWBPTYPE=3 D  Q
"RTN","XWBTCPC",117,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  D WRITE(XWBR(I)) D:XWBWRAP WRITE($C(13,10))
"RTN","XWBTCPC",118,0)
 ; -- global array
"RTN","XWBTCPC",119,0)
 IF XWBPTYPE=4 D  Q
"RTN","XWBTCPC",120,0)
 . S I=$G(XWBR) Q:I=""  S T=$E(I,1,$L(I)-1) D:$D(@I)>10 WRITE(@I)
"RTN","XWBTCPC",121,0)
 . F  S I=$Q(@I) Q:I=""!(I'[T)  W:($X+$L(@I))>509 ! W @I W:XWBWRAP&(@I'=$C(13,10)) $C(13,10)
"RTN","XWBTCPC",122,0)
 . IF $D(@XWBR) K @XWBR
"RTN","XWBTCPC",123,0)
 ; -- global instance
"RTN","XWBTCPC",124,0)
 IF XWBPTYPE=5 S XWBR=$G(@XWBR) D WRITE(XWBR) Q
"RTN","XWBTCPC",125,0)
 ; -- variable length records only good upto 255 char)
"RTN","XWBTCPC",126,0)
 IF XWBPTYPE=6 S I="" F  S I=$O(XWBR(I)) Q:I=""  D WRITE($C($L(XWBR(I)))),WRITE(XWBR(I))
"RTN","XWBTCPC",127,0)
 Q
"RTN","XWBTCPC",128,0)
 ;
"RTN","XWBTCPC",129,0)
ETRAP ; -- on trapped error, send error info to client
"RTN","XWBTCPC",130,0)
 N XWBERC,XWBERR
"RTN","XWBTCPC",131,0)
 ;Change trapping during trap.
"RTN","XWBTCPC",132,0)
 S $ETRAP="D ^%ZTER HALT"
"RTN","XWBTCPC",133,0)
 S XWBERC=$$EC^%ZOSV,XWBERR=$C(24)_"M  ERROR="_XWBERC_$C(13,10)_"LAST REF="_$$LGR^%ZOSV_$C(4)
"RTN","XWBTCPC",134,0)
 S XWBOS=$$OS
"RTN","XWBTCPC",135,0)
 D ^%ZTER ;%ZTER clears $ZE and $ECODE
"RTN","XWBTCPC",136,0)
 I (XWBERC["READ")!(XWBERC["WRITE")!(XWBERC["SYSTEM-F") D:$G(DUZ) LOGOUT^XUSRB HALT
"RTN","XWBTCPC",137,0)
 U XWBTDEV
"RTN","XWBTCPC",138,0)
 IF XWBOS="DSM" D
"RTN","XWBTCPC",139,0)
 . I $D(XWBTLEN),XWBTLEN D SNDERR,WRITE(XWBERR) W:$X !
"RTN","XWBTCPC",140,0)
 IF XWBOS'="DSM" D
"RTN","XWBTCPC",141,0)
 . D SNDERR,WRITE(XWBERR) W:$X !
"RTN","XWBTCPC",142,0)
 S $ETRAP="Q:($ESTACK&'$QUIT)  Q:$ESTACK -9 S $ECODE="""" G RESTART^XWBTCPC",$ECODE=",U99,"
"RTN","XWBTCPC",143,0)
 Q
"RTN","XWBTCPC",144,0)
 ;
"RTN","XWBTCPC",145,0)
STYPE(X,WRAP) ;For backward compatability only
"RTN","XWBTCPC",146,0)
 I $D(WRAP) Q $$RTRNFMT^XWBLIB($G(X),WRAP)
"RTN","XWBTCPC",147,0)
 Q $$RTRNFMT^XWBLIB(X)
"RTN","XWBTCPC",148,0)
 ;
"RTN","XWBTCPC",149,0)
BREAD(L) ;read tcp buffer, L is length
"RTN","XWBTCPC",150,0)
 N E,X,DONE
"RTN","XWBTCPC",151,0)
 S (E,DONE)=0
"RTN","XWBTCPC",152,0)
 R X#L:XWBTIME(1)
"RTN","XWBTCPC",153,0)
 S E=X
"RTN","XWBTCPC",154,0)
 IF $L(E)<L F  D  Q:'DONE
"RTN","XWBTCPC",155,0)
 . IF $L(E)=L S DONE=1 Q
"RTN","XWBTCPC",156,0)
 . R X#(L-$L(E)):XWBTIME(1)
"RTN","XWBTCPC",157,0)
 . S E=E_X
"RTN","XWBTCPC",158,0)
 Q E
"RTN","XWBTCPC",159,0)
 ;
"RTN","XWBTCPC",160,0)
CHPRN(N) ;Change process name to N.
"RTN","XWBTCPC",161,0)
 D SETNM^%ZOSV($E(N,1,15))
"RTN","XWBTCPC",162,0)
 Q
"RTN","XWBTCPC",163,0)
 ;
"RTN","XWBTCPC",164,0)
SETTIME(%) ;Set the Read timeout 0=RPC, 1=sign-on
"RTN","XWBTCPC",165,0)
 S XWBTIME=$S($G(%):90,$G(XWBVER)>1.105:$$BAT^XUPARAM,1:36000),XWBTIME(1)=2
"RTN","XWBTCPC",166,0)
 I $G(%) S XWBTIME=$S($G(XWBVER)>1.1:90,1:36000)
"RTN","XWBTCPC",167,0)
 Q
"RTN","XWBTCPC",168,0)
TIMEOUT ;Do this on MAIN  loop timeout
"RTN","XWBTCPC",169,0)
 I $G(DUZ)>0 D SNDERR,WRITE("#BYE#"_$C(4)) Q
"RTN","XWBTCPC",170,0)
 ;Sign-on timeout
"RTN","XWBTCPC",171,0)
 S XWBR(0)=0,XWBR(1)=1,XWBR(2)="",XWBR(3)="TIME-OUT",XWBPTYPE=2
"RTN","XWBTCPC",172,0)
 D SNDERR,SND,WRITE($C(4))
"RTN","XWBTCPC",173,0)
 Q
"RTN","XWBTCPC",174,0)
 ;
"RTN","XWBTCPC",175,0)
MSM ;entry point for MSERVER service - used by MSM
"RTN","XWBTCPC",176,0)
 N XWBVER,LEN,MSG,X
"RTN","XWBTCPC",177,0)
 S XWBVER=0
"RTN","XWBTCPC",178,0)
 R LEN#11:3600 IF $E(LEN,1,5)'="{XWB}" D  Q  ;bad client, abort
"RTN","XWBTCPC",179,0)
 . W "RPC broker disconnect!",!
"RTN","XWBTCPC",180,0)
 . C 56
"RTN","XWBTCPC",181,0)
 . Q
"RTN","XWBTCPC",182,0)
 IF $E(LEN,11,11)="|" D
"RTN","XWBTCPC",183,0)
 . R X#1:60
"RTN","XWBTCPC",184,0)
 . R XWBVER#$A(X):60
"RTN","XWBTCPC",185,0)
 . R LEN#5:60
"RTN","XWBTCPC",186,0)
 . R MSG#LEN:60
"RTN","XWBTCPC",187,0)
 . Q
"RTN","XWBTCPC",188,0)
 ELSE  S X=$E(LEN,11,11),LEN=$E(LEN,6,10)-1 R MSG#LEN:60 S MSG=X_MSG
"RTN","XWBTCPC",189,0)
 IF $P(MSG,"^")="TCPconnect" D
"RTN","XWBTCPC",190,0)
 . D SNDERR W "accept",$C(4),!
"RTN","XWBTCPC",191,0)
 . C 56
"RTN","XWBTCPC",192,0)
 . D EN($P(MSG,"^",2),$P(MSG,"^",3),$P(X,"^"),XWBVER,$P(MSG,"^",4))
"RTN","XWBTCPC",193,0)
 IF $P(MSG,"^")="TCPdebug" D
"RTN","XWBTCPC",194,0)
 . D SNDERR W "accept",$C(4),!
"RTN","XWBTCPC",195,0)
 C 56
"RTN","XWBTCPC",196,0)
 Q
"RTN","XWBTCPC",197,0)
OS() ;Return the OS
"RTN","XWBTCPC",198,0)
 Q $S(^%ZOSF("OS")["DSM":"DSM",^("OS")["UNIX":"UNIX",^("OS")["OpenM":"OpenM",1:"MSM")
"VER")
8.0^22.0
**END**
**END**
