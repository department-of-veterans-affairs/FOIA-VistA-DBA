Released ROR*1*2 SEQ #2
Extracted from mail message
**KIDS**:ROR*1.0*2^

**INSTALL NAME**
ROR*1.0*2
"BLD",3886,0)
ROR*1.0*2^CLINICAL CASE REGISTRIES^0^3020911^y
"BLD",3886,1,0)
^^3^3^3020823^^^
"BLD",3886,1,1,0)
This patch fixes various problems discovered during the installation and
"BLD",3886,1,2,0)
implementation of the Clinical Case Registries v1.0 package. It also
"BLD",3886,1,3,0)
contains some enhancements.
"BLD",3886,4,0)
^9.64PA^798^3
"BLD",3886,4,798,0)
798
"BLD",3886,4,798,222)
y^n^f^^^^n
"BLD",3886,4,798.1,0)
798.1
"BLD",3886,4,798.1,2,0)
^9.641^798.118^2
"BLD",3886,4,798.1,2,798.1,0)
ROR REGISTRY PARAMETERS  (File-top level)
"BLD",3886,4,798.1,2,798.1,1,0)
^9.6411^26^3
"BLD",3886,4,798.1,2,798.1,1,2.4,0)
LAST IEN
"BLD",3886,4,798.1,2,798.1,1,13.1,0)
MAXIMUM MESSAGE SIZE
"BLD",3886,4,798.1,2,798.1,1,26,0)
EXCLUDE EMPLOYEES
"BLD",3886,4,798.1,2,798.118,0)
SECURITY KEY  (sub-file)
"BLD",3886,4,798.1,2,798.118,1,0)
^9.6411^^
"BLD",3886,4,798.1,222)
y^n^p^^^^n
"BLD",3886,4,798.4,0)
798.4
"BLD",3886,4,798.4,222)
y^n^f^^^^n
"BLD",3886,4,"APDD",798.1,798.1)

"BLD",3886,4,"APDD",798.1,798.1,2.4)

"BLD",3886,4,"APDD",798.1,798.1,13.1)

"BLD",3886,4,"APDD",798.1,798.1,26)

"BLD",3886,4,"APDD",798.1,798.118)

"BLD",3886,4,"B",798,798)

"BLD",3886,4,"B",798.1,798.1)

"BLD",3886,4,"B",798.4,798.4)

"BLD",3886,"INIT")
START^RORPOS02
"BLD",3886,"KRN",0)
^9.67PA^8989.52^19
"BLD",3886,"KRN",.4,0)
.4
"BLD",3886,"KRN",.4,"NM",0)
^9.68A^1^1
"BLD",3886,"KRN",.4,"NM",1,0)
ROR PENDING ERRORS    FILE #798.3^798.3^0
"BLD",3886,"KRN",.4,"NM","B","ROR PENDING ERRORS    FILE #798.3",1)

"BLD",3886,"KRN",.401,0)
.401
"BLD",3886,"KRN",.401,"NM",0)
^9.68A^1^1
"BLD",3886,"KRN",.401,"NM",1,0)
ROR PENDING ERRORS    FILE #798.3^798.3^0
"BLD",3886,"KRN",.401,"NM","B","ROR PENDING ERRORS    FILE #798.3",1)

"BLD",3886,"KRN",.402,0)
.402
"BLD",3886,"KRN",.403,0)
.403
"BLD",3886,"KRN",.5,0)
.5
"BLD",3886,"KRN",.84,0)
.84
"BLD",3886,"KRN",3.6,0)
3.6
"BLD",3886,"KRN",3.8,0)
3.8
"BLD",3886,"KRN",3.8,"NM",0)
^9.68A^^
"BLD",3886,"KRN",9.2,0)
9.2
"BLD",3886,"KRN",9.8,0)
9.8
"BLD",3886,"KRN",9.8,"NM",0)
^9.68A^39^39
"BLD",3886,"KRN",9.8,"NM",1,0)
RORHDT03^^0^B23692464
"BLD",3886,"KRN",9.8,"NM",2,0)
RORHDT04^^0^B31949569
"BLD",3886,"KRN",9.8,"NM",3,0)
RORHL7^^0^B34779035
"BLD",3886,"KRN",9.8,"NM",4,0)
RORHL01^^0^B10788865
"BLD",3886,"KRN",9.8,"NM",5,0)
RORHL02^^0^B43166641
"BLD",3886,"KRN",9.8,"NM",6,0)
RORHL03^^0^B65277671
"BLD",3886,"KRN",9.8,"NM",7,0)
RORHL04^^0^B13913817
"BLD",3886,"KRN",9.8,"NM",8,0)
RORHL05^^0^B9095926
"BLD",3886,"KRN",9.8,"NM",9,0)
RORHL06^^0^B26538598
"BLD",3886,"KRN",9.8,"NM",10,0)
RORHL07^^0^B15756858
"BLD",3886,"KRN",9.8,"NM",11,0)
ROREXT01^^0^B13206150
"BLD",3886,"KRN",9.8,"NM",12,0)
ROREXTUT^^0^B17198030
"BLD",3886,"KRN",9.8,"NM",13,0)
RORHDT02^^0^B3597415
"BLD",3886,"KRN",9.8,"NM",14,0)
RORUTL03^^0^B17060217
"BLD",3886,"KRN",9.8,"NM",15,0)
RORPOS02^^0^B46867129
"BLD",3886,"KRN",9.8,"NM",16,0)
RORHDTAC^^0^B12683505
"BLD",3886,"KRN",9.8,"NM",17,0)
RORERR20^^0^B39482993
"BLD",3886,"KRN",9.8,"NM",18,0)
RORENV02^^0^B5715007
"BLD",3886,"KRN",9.8,"NM",19,0)
RORKIDS^^0^B29192479
"BLD",3886,"KRN",9.8,"NM",20,0)
RORUPD05^^0^B46987705
"BLD",3886,"KRN",9.8,"NM",21,0)
RORUPD01^^0^B66620855
"BLD",3886,"KRN",9.8,"NM",22,0)
RORRP5^^0^B3868161
"BLD",3886,"KRN",9.8,"NM",23,0)
RORPOS03^^0^B18615858
"BLD",3886,"KRN",9.8,"NM",24,0)
RORUTL02^^0^B38852738
"BLD",3886,"KRN",9.8,"NM",25,0)
ROREXT^^0^B18842103
"BLD",3886,"KRN",9.8,"NM",26,0)
ROREXPR^^0^B9187244
"BLD",3886,"KRN",9.8,"NM",27,0)
RORDD^^0^B18468932
"BLD",3886,"KRN",9.8,"NM",28,0)
RORACK01^^0^B35964763
"BLD",3886,"KRN",9.8,"NM",29,0)
RORUPD50^^0^B13411223
"BLD",3886,"KRN",9.8,"NM",30,0)
RORUPD51^^0^B53672528
"BLD",3886,"KRN",9.8,"NM",31,0)
RORUPR^^0^B29694244
"BLD",3886,"KRN",9.8,"NM",32,0)
RORUPR1^^0^B71827548
"BLD",3886,"KRN",9.8,"NM",33,0)
RORUPD^^0^B30208257
"BLD",3886,"KRN",9.8,"NM",34,0)
RORUTL05^^0^B44273326
"BLD",3886,"KRN",9.8,"NM",35,0)
ROR^^0^B21003229
"BLD",3886,"KRN",9.8,"NM",36,0)
RORUPP02^^0^B10225211
"BLD",3886,"KRN",9.8,"NM",37,0)
ROREXT02^^0^B24985977
"BLD",3886,"KRN",9.8,"NM",38,0)
RORNTEG^^0^B8064498
"BLD",3886,"KRN",9.8,"NM",39,0)
RORRP9^^0^B45932470
"BLD",3886,"KRN",9.8,"NM","B","ROR",35)

"BLD",3886,"KRN",9.8,"NM","B","RORACK01",28)

"BLD",3886,"KRN",9.8,"NM","B","RORDD",27)

"BLD",3886,"KRN",9.8,"NM","B","RORENV02",18)

"BLD",3886,"KRN",9.8,"NM","B","RORERR20",17)

"BLD",3886,"KRN",9.8,"NM","B","ROREXPR",26)

"BLD",3886,"KRN",9.8,"NM","B","ROREXT",25)

"BLD",3886,"KRN",9.8,"NM","B","ROREXT01",11)

"BLD",3886,"KRN",9.8,"NM","B","ROREXT02",37)

"BLD",3886,"KRN",9.8,"NM","B","ROREXTUT",12)

"BLD",3886,"KRN",9.8,"NM","B","RORHDT02",13)

"BLD",3886,"KRN",9.8,"NM","B","RORHDT03",1)

"BLD",3886,"KRN",9.8,"NM","B","RORHDT04",2)

"BLD",3886,"KRN",9.8,"NM","B","RORHDTAC",16)

"BLD",3886,"KRN",9.8,"NM","B","RORHL01",4)

"BLD",3886,"KRN",9.8,"NM","B","RORHL02",5)

"BLD",3886,"KRN",9.8,"NM","B","RORHL03",6)

"BLD",3886,"KRN",9.8,"NM","B","RORHL04",7)

"BLD",3886,"KRN",9.8,"NM","B","RORHL05",8)

"BLD",3886,"KRN",9.8,"NM","B","RORHL06",9)

"BLD",3886,"KRN",9.8,"NM","B","RORHL07",10)

"BLD",3886,"KRN",9.8,"NM","B","RORHL7",3)

"BLD",3886,"KRN",9.8,"NM","B","RORKIDS",19)

"BLD",3886,"KRN",9.8,"NM","B","RORNTEG",38)

"BLD",3886,"KRN",9.8,"NM","B","RORPOS02",15)

"BLD",3886,"KRN",9.8,"NM","B","RORPOS03",23)

"BLD",3886,"KRN",9.8,"NM","B","RORRP5",22)

"BLD",3886,"KRN",9.8,"NM","B","RORRP9",39)

"BLD",3886,"KRN",9.8,"NM","B","RORUPD",33)

"BLD",3886,"KRN",9.8,"NM","B","RORUPD01",21)

"BLD",3886,"KRN",9.8,"NM","B","RORUPD05",20)

"BLD",3886,"KRN",9.8,"NM","B","RORUPD50",29)

"BLD",3886,"KRN",9.8,"NM","B","RORUPD51",30)

"BLD",3886,"KRN",9.8,"NM","B","RORUPP02",36)

"BLD",3886,"KRN",9.8,"NM","B","RORUPR",31)

"BLD",3886,"KRN",9.8,"NM","B","RORUPR1",32)

"BLD",3886,"KRN",9.8,"NM","B","RORUTL02",24)

"BLD",3886,"KRN",9.8,"NM","B","RORUTL03",14)

"BLD",3886,"KRN",9.8,"NM","B","RORUTL05",34)

"BLD",3886,"KRN",19,0)
19
"BLD",3886,"KRN",19,"NM",0)
^9.68A^3^3
"BLD",3886,"KRN",19,"NM",1,0)
RORMNT MAIN^^2
"BLD",3886,"KRN",19,"NM",2,0)
RORMNT PENDING PATIENTS^^0
"BLD",3886,"KRN",19,"NM",3,0)
RORMNT PENDING ERRORS LIST^^0
"BLD",3886,"KRN",19,"NM","B","RORMNT MAIN",1)

"BLD",3886,"KRN",19,"NM","B","RORMNT PENDING ERRORS LIST",3)

"BLD",3886,"KRN",19,"NM","B","RORMNT PENDING PATIENTS",2)

"BLD",3886,"KRN",19.1,0)
19.1
"BLD",3886,"KRN",101,0)
101
"BLD",3886,"KRN",409.61,0)
409.61
"BLD",3886,"KRN",771,0)
771
"BLD",3886,"KRN",870,0)
870
"BLD",3886,"KRN",8989.51,0)
8989.51
"BLD",3886,"KRN",8989.51,"NM",0)
^9.68A^^
"BLD",3886,"KRN",8989.52,0)
8989.52
"BLD",3886,"KRN",8994,0)
8994
"BLD",3886,"KRN","B",.4,.4)

"BLD",3886,"KRN","B",.401,.401)

"BLD",3886,"KRN","B",.402,.402)

"BLD",3886,"KRN","B",.403,.403)

"BLD",3886,"KRN","B",.5,.5)

"BLD",3886,"KRN","B",.84,.84)

"BLD",3886,"KRN","B",3.6,3.6)

"BLD",3886,"KRN","B",3.8,3.8)

"BLD",3886,"KRN","B",9.2,9.2)

"BLD",3886,"KRN","B",9.8,9.8)

"BLD",3886,"KRN","B",19,19)

"BLD",3886,"KRN","B",19.1,19.1)

"BLD",3886,"KRN","B",101,101)

"BLD",3886,"KRN","B",409.61,409.61)

"BLD",3886,"KRN","B",771,771)

"BLD",3886,"KRN","B",870,870)

"BLD",3886,"KRN","B",8989.51,8989.51)

"BLD",3886,"KRN","B",8989.52,8989.52)

"BLD",3886,"KRN","B",8994,8994)

"BLD",3886,"PRE")
RORENV02
"BLD",3886,"QUES",0)
^9.62^^
"BLD",3886,"REQB",0)
^9.611^2^1
"BLD",3886,"REQB",2,0)
DG*5.3*471^2
"BLD",3886,"REQB","B","DG*5.3*471",2)

"FIA",798)
ROR LOCAL REGISTRY
"FIA",798,0)
^RORDATA(798,
"FIA",798,0,0)
798PAs
"FIA",798,0,1)
y^n^f^^^^n
"FIA",798,0,10)

"FIA",798,0,11)

"FIA",798,0,"RLRO")

"FIA",798,0,"VR")
1.0^ROR
"FIA",798,798)
0
"FIA",798,798.01)
0
"FIA",798.1)
ROR REGISTRY PARAMETERS
"FIA",798.1,0)
^ROR(798.1,
"FIA",798.1,0,0)
798.1I
"FIA",798.1,0,1)
y^n^p^^^^n
"FIA",798.1,0,10)

"FIA",798.1,0,11)

"FIA",798.1,0,"RLRO")

"FIA",798.1,0,"VR")
1.0^ROR
"FIA",798.1,798.1)
1
"FIA",798.1,798.1,2.4)

"FIA",798.1,798.1,13.1)

"FIA",798.1,798.1,18)

"FIA",798.1,798.1,26)

"FIA",798.1,798.118)
0
"FIA",798.4)
ROR PATIENT
"FIA",798.4,0)
^RORDATA(798.4,
"FIA",798.4,0,0)
798.4Ps
"FIA",798.4,0,1)
y^n^f^^^^n
"FIA",798.4,0,10)

"FIA",798.4,0,11)

"FIA",798.4,0,"RLRO")

"FIA",798.4,0,"VR")
1.0^ROR
"FIA",798.4,798.4)
0
"FIA",798.4,798.41)
0
"INIT")
START^RORPOS02
"IX",798,798,"KEY",0)
798^KEY^Uniqueness Index for Key 'A' of File #798^R^^R^IR^I^798^^^^^LS
"IX",798,798,"KEY",.1,0)
^^3^3^3011005^
"IX",798,798,"KEY",.1,1,0)
This index guarantees uniqueness of the patient 
"IX",798,798,"KEY",.1,2,0)
record in the particular registry and allows to 
"IX",798,798,"KEY",.1,3,0)
easily find this record.
"IX",798,798,"KEY",1)
S ^RORDATA(798,"KEY",X(1),X(2),DA)=""
"IX",798,798,"KEY",2)
K ^RORDATA(798,"KEY",X(1),X(2),DA)
"IX",798,798,"KEY",2.5)
K ^RORDATA(798,"KEY")
"IX",798,798,"KEY",11.1,0)
^.114IA^2^2
"IX",798,798,"KEY",11.1,1,0)
1^F^798^.01^^1
"IX",798,798,"KEY",11.1,2,0)
2^F^798^.02^^2
"KEY",798,798,"A",0)
798^A^P^100
"KEY",798,798,"A",2,0)
^.312IA^2^2
"KEY",798,798,"A",2,1,0)
.01^798^1
"KEY",798,798,"A",2,2,0)
.02^798^2
"KEYPTR",798,798,"A")
798^KEY
"KRN",.4,2312,-1)
0^1
"KRN",.4,2312,0)
ROR PENDING ERRORS^3020717.1342^^798.3^^@^3020806
"KRN",.4,2312,"%D",0)
^^4^4^3020801^
"KRN",.4,2312,"%D",1,0)
This template is used by the [RORMNT PENDING 
"KRN",.4,2312,"%D",2,0)
ERRORS LIST] menu option to print a list of 
"KRN",.4,2312,"%D",3,0)
patients with erroneous data (based on content of
"KRN",.4,2312,"%D",4,0)
the ERROR multiples).
"KRN",.4,2312,"F",2)
.01~0;"DFN"~1,.01~
"KRN",.4,2312,"H")
LIST OF PENDING PATIENT ERRORS
"KRN",.401,1520,-1)
0^1
"KRN",.401,1520,0)
ROR PENDING ERRORS^3020717.1339^^798.3^^@^3020806
"KRN",.401,1520,2,0)
^.4014^4^4
"KRN",.401,1520,2,1,0)
798.31^2^COUNTER^-^;S^^^^^2
"KRN",.401,1520,2,1,1,0)
^.40141^1^1
"KRN",.401,1520,2,1,1,1,0)
798.3^1
"KRN",.401,1520,2,1,1,"B",798.3,1)

"KRN",.401,1520,2,1,"GET")
S DISX(1)=$P($G(^RORDATA(798.3,D0,1,D1,0)),U,3) S:DISX(1)]"" DISX(1)=+DISX(1)
"KRN",.401,1520,2,1,"QCON")
I DISX(1)'=""
"KRN",.401,1520,2,1,"TXT")
COUNTER not null
"KRN",.401,1520,2,2,0)
798.3^^""^"^;S^^^^^4
"KRN",.401,1520,2,2,"CM")
S X="" I D0>0 S DISX(2)=X
"KRN",.401,1520,2,2,"F")
?z^@
"KRN",.401,1520,2,2,"GET")
S X="" I D0>0 S DISX(2)=X
"KRN",.401,1520,2,2,"QCON")
I DISX(2)=""
"KRN",.401,1520,2,2,"T")
@^@
"KRN",.401,1520,2,2,"TXT")
"""" is null
"KRN",.401,1520,2,3,0)
798.3^^PATIENT NAME^".01^^^^^^4
"KRN",.401,1520,2,3,"CM")
S Y(1)=$S($D(^RORDATA(798.3,D0,0)):^(0),1:"") S X=$S('$D(^DPT(+$P(Y(1),U,1),0)):"",1:$P(^(0),U,1)) I D0>0 S DISX(3)=X
"KRN",.401,1520,2,3,"GET")
S Y(1)=$S($D(^RORDATA(798.3,D0,0)):^(0),1:"") S X=$S('$D(^DPT(+$P(Y(1),U,1),0)):"",1:$P(^(0),U,1)) I D0>0 S DISX(3)=X
"KRN",.401,1520,2,3,"IX")
^RORDATA(798.3,"B",^RORDATA(798.3,^2
"KRN",.401,1520,2,3,"PTRIX")
^DPT("B",
"KRN",.401,1520,2,3,"QCON")
I DISX(3)'=""
"KRN",.401,1520,2,3,"SER")
0.0000^0.0000
"KRN",.401,1520,2,3,"TXT")
PATIENT NAME not null
"KRN",.401,1520,2,4,0)
798.3^0^NUMBER^^^^^^^2
"KRN",.401,1520,2,4,"IX")
^RORDATA(798.3,^RORDATA(798.3,^1
"KRN",.401,1520,2,4,"QCON")
I D0'=""
"KRN",.401,1520,2,4,"SER")
0^0
"KRN",.401,1520,2,4,"TXT")
NUMBER not null
"KRN",.401,1520,2,"B",798.3,2)

"KRN",.401,1520,2,"B",798.3,3)

"KRN",.401,1520,2,"B",798.3,4)

"KRN",.401,1520,2,"B",798.31,1)

"KRN",.401,1520,"%D",0)
^^5^5^3020801^
"KRN",.401,1520,"%D",1,0)
This template is used by the [RORMNT PENDING 
"KRN",.401,1520,"%D",2,0)
ERRORS LIST] menu option to sort and group a list
"KRN",.401,1520,"%D",3,0)
of patients with erroneous data by error counter 
"KRN",.401,1520,"%D",4,0)
(value of the COUNTER field). Patients with higher
"KRN",.401,1520,"%D",5,0)
counters are printed first.
"KRN",19,11363,-1)
2^1
"KRN",19,11363,0)
RORMNT MAIN^Clinical Case Registries Maintenance^^M^222222227^^^^^^^389
"KRN",19,11363,10,0)
^19.01IP^5^5
"KRN",19,11363,10,5,0)
11556^PP
"KRN",19,11363,10,5,"^")
RORMNT PENDING PATIENTS
"KRN",19,11363,"U")
CLINICAL CASE REGISTRIES MAINT
"KRN",19,11555,-1)
0^3
"KRN",19,11555,0)
RORMNT PENDING ERRORS LIST^List of Pending Errors^^P^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11555,1,0)
^19.06^9^9^3020801^^
"KRN",19,11555,1,1,0)
 
"KRN",19,11555,1,2,0)
The option prints a report containing list of patients (referenced by the
"KRN",19,11555,1,3,0)
ERROR multiples of the ROR PENDING PATIENT file) having erroneous data.
"KRN",19,11555,1,4,0)
The list is sorted by value of the COUNTER field (number of times that an
"KRN",19,11555,1,5,0)
error was recorded for a patient).
"KRN",19,11555,1,6,0)
 
"KRN",19,11555,1,7,0)
This report can be used to find the patients ignored by the registry
"KRN",19,11555,1,8,0)
update (until someone fixes the error(s) and resets value of the COUNTER
"KRN",19,11555,1,9,0)
field to 1).
"KRN",19,11555,60)
RORDATA(798.3,
"KRN",19,11555,62)
0
"KRN",19,11555,63)
[ROR PENDING ERRORS]
"KRN",19,11555,64)
[ROR PENDING ERRORS]
"KRN",19,11555,65)

"KRN",19,11555,66)

"KRN",19,11555,"U")
LIST OF PENDING ERRORS
"KRN",19,11556,-1)
0^2
"KRN",19,11556,0)
RORMNT PENDING PATIENTS^Pending Patients^^M^^^^^^^^CLINICAL CASE REGISTRIES
"KRN",19,11556,1,0)
^^3^3^3020729^
"KRN",19,11556,1,1,0)
 
"KRN",19,11556,1,2,0)
This menu groups the options used for maintenance of the ROR PENDING 
"KRN",19,11556,1,3,0)
PATIENT file containing event and error references.
"KRN",19,11556,10,0)
^19.01IP^1^1
"KRN",19,11556,10,1,0)
11555^LPE
"KRN",19,11556,10,1,"^")
RORMNT PENDING ERRORS LIST
"KRN",19,11556,99)
59002,49824
"KRN",19,11556,"U")
PENDING PATIENTS
"MBREQ")
0
"ORD",5,.4)
.4;5;;;EDEOUT^DIFROMSO(.4,DA,"",XPDA);FPRE^DIFROMSI(.4,"",XPDA);EPRE^DIFROMSI(.4,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.4,DA,"",XPDA);DEL^DIFROMSK(.4,"",%)
"ORD",5,.4,0)
PRINT TEMPLATE
"ORD",6,.401)
.401;6;;;EDEOUT^DIFROMSO(.401,DA,"",XPDA);FPRE^DIFROMSI(.401,"",XPDA);EPRE^DIFROMSI(.401,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.401,DA,"",XPDA);DEL^DIFROMSK(.401,"",%)
"ORD",6,.401,0)
SORT TEMPLATE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",389,-1)
1^1
"PKG",389,0)
CLINICAL CASE REGISTRIES^ROR^CLINICAL CASE REGISTRIES
"PKG",389,20,0)
^9.402P^^
"PKG",389,22,0)
^9.49I^1^1
"PKG",389,22,1,0)
1.0^3020515^3020726^222222227
"PKG",389,22,1,"PAH",1,0)
2^3020911
"PKG",389,22,1,"PAH",1,1,0)
^^3^3^3020911
"PKG",389,22,1,"PAH",1,1,1,0)
This patch fixes various problems discovered during the installation and
"PKG",389,22,1,"PAH",1,1,2,0)
implementation of the Clinical Case Registries v1.0 package. It also
"PKG",389,22,1,"PAH",1,1,3,0)
contains some enhancements.
"PRE")
RORENV02
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
39
"RTN","ROR")
0^35^B21003229
"RTN","ROR",1,0)
ROR ;HCIOFO/SG - CLINICAL REGISTRIES ; 8/7/02 9:41am
"RTN","ROR",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","ROR",3,0)
 ;
"RTN","ROR",4,0)
 ; RORERRDL ------------ DEFAULT ERROR LOCATION
"RTN","ROR",5,0)
 ;
"RTN","ROR",6,0)
 ; RORERROR ------------ ERROR PROCESSING DATA
"RTN","ROR",7,0)
 ;
"RTN","ROR",8,0)
 ; RORERROR("ES",        Index of the top of the stack
"RTN","ROR",9,0)
 ;   Index,                ^1: Error code
"RTN","ROR",10,0)
 ;                         ^2: Message text
"RTN","ROR",11,0)
 ;     1)                Place of the error (LABEL^ROUTINE)
"RTN","ROR",12,0)
 ;     2,Seq#)           Additional information (opt'l)
"RTN","ROR",13,0)
 ;
"RTN","ROR",14,0)
 ; RORPARM ------------- PACKAGE-WIDE CONSTANTS AND VARIABLES
"RTN","ROR",15,0)
 ;
"RTN","ROR",16,0)
 ; RORPARM("DEBUG")      Debug mode (opt'l):
"RTN","ROR",17,0)
 ;                         0  Disabled (default)
"RTN","ROR",18,0)
 ;                         1  Enabled
"RTN","ROR",19,0)
 ;                         2  Enabled; and all messages are not only
"RTN","ROR",20,0)
 ;                            logged but displayed on the screen too
"RTN","ROR",21,0)
 ;                         3  The same as 2 but registry update or
"RTN","ROR",22,0)
 ;                            data extraction is aborted immediately
"RTN","ROR",23,0)
 ;                            after processing a patient with errors
"RTN","ROR",24,0)
 ;
"RTN","ROR",25,0)
 ; RORPARM("DEVELOPER")  If this node is defined and not zero,
"RTN","ROR",26,0)
 ;                       national definitions (registry parameters,
"RTN","ROR",27,0)
 ;                       selection rules, etc) can be edited.
"RTN","ROR",28,0)
 ;                       Otherwise, editing is prohibited.
"RTN","ROR",29,0)
 ;
"RTN","ROR",30,0)
 ; RORPARM("ERR")        Enable/disable extended error processing:
"RTN","ROR",31,0)
 ;                         0  Disabled (default)
"RTN","ROR",32,0)
 ;                         1  Enabled
"RTN","ROR",33,0)
 ;
"RTN","ROR",34,0)
 ; RORPARM("KIDS",       This node is defined and non-zero only during
"RTN","ROR",35,0)
 ;                       the KIDS installation process:
"RTN","ROR",36,0)
 ;                         1  Pre-install
"RTN","ROR",37,0)
 ;                         2  Post-install
"RTN","ROR",38,0)
 ;   ParamName)          Value of an installation parameter
"RTN","ROR",39,0)
 ;
"RTN","ROR",40,0)
 ; RORPARM("LOG",        Enable/disable log collection:
"RTN","ROR",41,0)
 ;                         0  Disabled (default)
"RTN","ROR",42,0)
 ;                         1  Enabled
"RTN","ROR",43,0)
 ;   Type)               Enable (1) collection of only particular
"RTN","ROR",44,0)
 ;                       events (optional, all events by default)
"RTN","ROR",45,0)
 ;                       See the LOG EVENTS field in the ROR REGISTRY
"RTN","ROR",46,0)
 ;                       PARAMETERS file #798.1 for possible values.
"RTN","ROR",47,0)
 ;
"RTN","ROR",48,0)
 ; RORPARM("SETUP")      This node is defined and non-zero only
"RTN","ROR",49,0)
 ;                       during the registry setup.
"RTN","ROR",50,0)
 ;
"RTN","ROR",51,0)
 ; TEMPORARY NODE ------ DESCRIPTION
"RTN","ROR",52,0)
 ;
"RTN","ROR",53,0)
 ; ^TMP("RORACK")        Control data of acknowledgement processing
"RTN","ROR",54,0)
 ; ^TMP("RORHDT")        Control data of historical data extraction
"RTN","ROR",55,0)
 ; ^TMP("RORTMP")        Temporary storage
"RTN","ROR",56,0)
 ; ^TMP("RORUPD")        Registry update temporary data
"RTN","ROR",57,0)
 ;
"RTN","ROR",58,0)
 ; ^XTMP("RORHDT")       Control data of historical data extraction
"RTN","ROR",59,0)
 ; ^XTMP("RORUPDJ")      Registry update temporary data (multitask)
"RTN","ROR",60,0)
 ; ^XTMP("RORUPDR")      Registry update temporary data (installation)
"RTN","ROR",61,0)
 ;
"RTN","ROR",62,0)
 ; See detailed description of the temporary global nodes in
"RTN","ROR",63,0)
 ; the source code of the ^ROR01 routine.
"RTN","ROR",64,0)
 ;
"RTN","ROR",65,0)
 ; NAMESPACE ----------- DESCRIPTION
"RTN","ROR",66,0)
 ;
"RTN","ROR",67,0)
 ; RORACK*               Acknowldgement processing
"RTN","ROR",68,0)
 ; RORAPI*               Supported APIs
"RTN","ROR",69,0)
 ; RORDD*                Routines used by the Data Dictionary
"RTN","ROR",70,0)
 ; RORENV*               Environment check routines (KIDS)
"RTN","ROR",71,0)
 ; RORERR*               Error processing
"RTN","ROR",72,0)
 ; ROREVT*               Event protocols
"RTN","ROR",73,0)
 ; ROREX*                Regular data extraction & transmission
"RTN","ROR",74,0)
 ; RORHDT*               Historical data extraction
"RTN","ROR",75,0)
 ; RORHL*                HL7
"RTN","ROR",76,0)
 ; RORKIDS*              Low-level installation utilities (KIDS)
"RTN","ROR",77,0)
 ; RORLOG*               Error recording
"RTN","ROR",78,0)
 ; RORPOS*               Post-install routines (KIDS)
"RTN","ROR",79,0)
 ; RORPRE*               Pre-install routines (KIDS)
"RTN","ROR",80,0)
 ; RORRP*                Remote procedures
"RTN","ROR",81,0)
 ; RORSET*               Setup routines
"RTN","ROR",82,0)
 ; RORUP*                Registry update
"RTN","ROR",83,0)
 ; RORUTL*               Utilities
"RTN","ROR",84,0)
 ;
"RTN","ROR",85,0)
 ; MENU OPTION --------- DESCRIPTION
"RTN","ROR",86,0)
 ;
"RTN","ROR",87,0)
 ; [ROR TASK]            Registry update and data extraction option
"RTN","ROR",88,0)
 ;                       (must be scheduled; do not run it directly)
"RTN","ROR",89,0)
 ; [ROR SETUP HEPC]      Setup the HepC registry
"RTN","ROR",90,0)
 ; [RORHDT MAIN]         Historical data extraction menu
"RTN","ROR",91,0)
 ; [RORMNT MAIN]         Maintenance menu
"RTN","ROR",92,0)
 ;
"RTN","ROR",93,0)
 ; SPECIAL ENTRY POINT - DESCRIPTION
"RTN","ROR",94,0)
 ;
"RTN","ROR",95,0)
 ;    START^RORTSITE     Prepares test sites for going live
"RTN","ROR",96,0)
 ;         ^RORUTL06     Registry definition validator
"RTN","ROR",97,0)
 ; DISTPREP^RORUTL06     Prepares registry parameters for KIDS distr.
"RTN","ROR",98,0)
 ;   PRTMDE^RORUTL06     Prints the data element metadata
"RTN","ROR",99,0)
 ;
"RTN","ROR",100,0)
 ;  EXTRACT^RORUTL07     Data extraction & transmission in debug mode
"RTN","ROR",101,0)
 ;   UPDATE^RORUTL07     Registry update in debug mode
"RTN","ROR",102,0)
 ;
"RTN","ROR",103,0)
 ; INITIALS ------------ DEVELOPER
"RTN","ROR",104,0)
 ;
"RTN","ROR",105,0)
 ; BH                    Brent Hicks
"RTN","ROR",106,0)
 ; CRT                   Cameron Taylor
"RTN","ROR",107,0)
 ; SG                    Sergey Gavrilov
"RTN","ROR",108,0)
 ;
"RTN","ROR",109,0)
 Q
"RTN","ROR",110,0)
 ;
"RTN","ROR",111,0)
 ;***** REGISTRY UPDATE AND DATA EXTRACTION TASK
"RTN","ROR",112,0)
 ;
"RTN","ROR",113,0)
 ; ZTQPARAM      String that contains a list of registry names
"RTN","ROR",114,0)
 ;               separated by commas. You must define the list as
"RTN","ROR",115,0)
 ;               a value of the TASK PARAMETERS field during
"RTN","ROR",116,0)
 ;               scheduling of the [ROR TASK] option that uses
"RTN","ROR",117,0)
 ;               this entry point.
"RTN","ROR",118,0)
 ;
"RTN","ROR",119,0)
 ; The following task parameters are optional. They can be defined
"RTN","ROR",120,0)
 ; on the second page of the option scheduling form as the pairs of
"RTN","ROR",121,0)
 ; variable names and values. See description of the ROR TASK option
"RTN","ROR",122,0)
 ; for more details regarding these parameters.
"RTN","ROR",123,0)
 ;
"RTN","ROR",124,0)
 ; [RORFLCLR]    Clear flags to control processing.
"RTN","ROR",125,0)
 ; [RORFLSET]    Set flags to control processing.
"RTN","ROR",126,0)
 ;
"RTN","ROR",127,0)
 ; [RORMNTSK]    Maximum number of the registry update subtasks.
"RTN","ROR",128,0)
 ;               The default value of the parameter is "2-3-AUTO".
"RTN","ROR",129,0)
 ;
"RTN","ROR",130,0)
 ; [RORSUSP]     Suspension parameters of the registry update sub-
"RTN","ROR",131,0)
 ;               tasks. The subtasks are not suspended by default.
"RTN","ROR",132,0)
 ;
"RTN","ROR",133,0)
TASK ;
"RTN","ROR",134,0)
 N RORERROR      ; Error processing data
"RTN","ROR",135,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","ROR",136,0)
 N RORPARM       ; Application parameters
"RTN","ROR",137,0)
 ;
"RTN","ROR",138,0)
 N CNT,I,RC,REGLST,REGNAME,RGEXLST
"RTN","ROR",139,0)
 ;--- Check the task parameters
"RTN","ROR",140,0)
 I $G(ZTQPARAM)?." "  K ZTQPARAM  S RC=ZTQPARAM
"RTN","ROR",141,0)
 S RORFLCLR=$G(RORFLCLR)
"RTN","ROR",142,0)
 S RORFLSET=$G(RORFLSET)
"RTN","ROR",143,0)
 S RORMNTSK=$S($G(RORMNTSK)'="":$TR(RORMNTSK,"-","^"),1:"2^3^AUTO")
"RTN","ROR",144,0)
 I $G(RORSUSP)'=""  D
"RTN","ROR",145,0)
 . N %DT,DTOUT,TMP,X,Y
"RTN","ROR",146,0)
 . S TMP=RORSUSP,RORSUSP=""
"RTN","ROR",147,0)
 . F I=1,2  D  S:$G(Y)>0 $P(RORSUSP,"^",I)=Y#1
"RTN","ROR",148,0)
 . . S X=$P(TMP,"-",I),%DT="R"  D ^%DT
"RTN","ROR",149,0)
 E  S RORSUSP=""
"RTN","ROR",150,0)
 ;--- Initialize constants and variables
"RTN","ROR",151,0)
 D INIT^RORUTL01("ROR",1)
"RTN","ROR",152,0)
 ;S RORPARM("DEBUG")=1 ; Remove the first ';' to start in debug mode
"RTN","ROR",153,0)
 S RORPARM("ERR")=1
"RTN","ROR",154,0)
 ;--- Extract registry names from the task parameters
"RTN","ROR",155,0)
 F I=1:1  S REGNAME=$P(ZTQPARAM,",",I)  Q:REGNAME=""  D
"RTN","ROR",156,0)
 . S REGNAME=$$TRIM^XLFSTR(REGNAME)
"RTN","ROR",157,0)
 . S:REGNAME'="" REGLST(REGNAME)=""
"RTN","ROR",158,0)
 ;--- Open a new log
"RTN","ROR",159,0)
 S RC=$$SETUP^RORLOG(.REGLST)
"RTN","ROR",160,0)
 S RC=$$OPEN^RORLOG(.REGLST,,"ROR TASK STARTED")
"RTN","ROR",161,0)
 ;--- Rebuild the "ACL" cross-reference
"RTN","ROR",162,0)
 S RC=$$RNDXACL^RORUTL05()
"RTN","ROR",163,0)
 ;--- Clear expired 'Awaiting Acknowledgement' flags
"RTN","ROR",164,0)
 S RC=$$CLRACK^RORUTL05(.REGLST)
"RTN","ROR",165,0)
 ;--- Update the registries
"RTN","ROR",166,0)
 S RC=$$UPDATE^RORUPD(.REGLST,.RGEXLST,RORMNTSK,RORSUSP,RORFLCLR,RORFLSET)
"RTN","ROR",167,0)
 ;--- Process the errors
"RTN","ROR",168,0)
 I RC<0  D  I RC<0  D CLOSE^RORLOG("ROR TASK ABORTED")  Q
"RTN","ROR",169,0)
 . ;--- Quit if stop is requested (via the TaskMan User option)
"RTN","ROR",170,0)
 . I RC=-42  D ALERT^RORUTL01(.REGLST,-42)  S ZTSTOP=1  Q
"RTN","ROR",171,0)
 . ;--- Do not send the alert for some warnings
"RTN","ROR",172,0)
 . I RC=-28  S RC=0  Q
"RTN","ROR",173,0)
 . ;--- Send the alert in case of other errors/warnings
"RTN","ROR",174,0)
 . D ALERT^RORUTL01(.REGLST,-43,,,,"registry update")
"RTN","ROR",175,0)
 . S RC=0
"RTN","ROR",176,0)
 ;--- Mark registry records 3 weeks after the installation so that
"RTN","ROR",177,0)
 ;    the local registry data and demographic data will be resent
"RTN","ROR",178,0)
 ;--- to restore the data overwritten with the historical data
"RTN","ROR",179,0)
 S RC=$$REMARK^RORUTL05(.RGEXLST,21)
"RTN","ROR",180,0)
 ;--- Schedule the data extraction task(s)
"RTN","ROR",181,0)
 S REGNAME=""  K ZTSAVE
"RTN","ROR",182,0)
 F CNT=1:1  S REGNAME=$O(RGEXLST(REGNAME))  Q:REGNAME=""  D
"RTN","ROR",183,0)
 . S ZTRTN="TASK^ROREXT",ZTIO=""
"RTN","ROR",184,0)
 . S ZTDTH=$$FMADD^XLFDT($$NOW^XLFDT,,,,(CNT-1)*30)
"RTN","ROR",185,0)
 . S ZTDESC="Data Extraction ("_REGNAME_")"
"RTN","ROR",186,0)
 . S ZTSAVE("RORREG")=REGNAME
"RTN","ROR",187,0)
 . D ^%ZTLOAD
"RTN","ROR",188,0)
 ;--- Purge the old logs
"RTN","ROR",189,0)
 S RC=$$PURGE^RORLOG(14)
"RTN","ROR",190,0)
 ;--- Purge the old event references
"RTN","ROR",191,0)
 S RC=$$EPDATE^RORUTL05()
"RTN","ROR",192,0)
 S:RC>0 RC=$$PURGE^RORUPP02(RC)
"RTN","ROR",193,0)
 ;---
"RTN","ROR",194,0)
 D CLOSE^RORLOG("ROR TASK COMPLETED")
"RTN","ROR",195,0)
 S ZTREQ="@"
"RTN","ROR",196,0)
 Q
"RTN","RORACK01")
0^28^B35964763
"RTN","RORACK01",1,0)
RORACK01 ;HCIOFO/SG - ACKNOWLEDGEMENT PROCESSING ; 8/1/02 3:22pm
"RTN","RORACK01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORACK01",3,0)
 ;
"RTN","RORACK01",4,0)
 Q
"RTN","RORACK01",5,0)
 ;
"RTN","RORACK01",6,0)
 ;***** RECORDS ERROR CODE AND LOCATION
"RTN","RORACK01",7,0)
 ;
"RTN","RORACK01",8,0)
 ; ERRLOC        Error code and location from the ERR segment
"RTN","RORACK01",9,0)
 ; PATIEN        Patient IEN
"RTN","RORACK01",10,0)
 ;
"RTN","RORACK01",11,0)
 ; Return Values:
"RTN","RORACK01",12,0)
 ;        <0  Error Code
"RTN","RORACK01",13,0)
 ;        >0  IEN of the registry record
"RTN","RORACK01",14,0)
 ;
"RTN","RORACK01",15,0)
ERR(ERRLOC,PATIEN) ;
"RTN","RORACK01",16,0)
 N CS,ERR,FLD,II,INFO,MSG,SCS,SEG,SQN,TMP,TYPE
"RTN","RORACK01",17,0)
 S CS=$E($G(HL("ECH")),1),SCS=$E($G(HL("ECH")),4)
"RTN","RORACK01",18,0)
 Q:(CS="")!(SCS="") $$ERROR^RORERR(-40,"ERR^RORACK01",,,"HL")
"RTN","RORACK01",19,0)
 S II=0,TYPE=6
"RTN","RORACK01",20,0)
 ;--- Extracts the information
"RTN","RORACK01",21,0)
 S SEG=$P(ERRLOC,CS,1)
"RTN","RORACK01",22,0)
 S SQN=$P(ERRLOC,CS,2)
"RTN","RORACK01",23,0)
 S FLD=$P(ERRLOC,CS,3)
"RTN","RORACK01",24,0)
 S ERR=$P(ERRLOC,CS,4)
"RTN","RORACK01",25,0)
 ;--- Prepare HL7 information
"RTN","RORACK01",26,0)
 S TMP=""
"RTN","RORACK01",27,0)
 S:SEG'="" TMP=TMP_", Segment: '"_SEG_"'"
"RTN","RORACK01",28,0)
 S:SQN TMP=TMP_", Sequence#: "_+SQN
"RTN","RORACK01",29,0)
 S:FLD TMP=TMP_", Field#: "_+FLD
"RTN","RORACK01",30,0)
 S:TMP'="" II=II+1,INFO(II)="HL7 INFO: "_$P(TMP,", ",2,999)
"RTN","RORACK01",31,0)
 ;--- Prepare the message and error location data
"RTN","RORACK01",32,0)
 I ERR?1.8UN.(1":".E)  D
"RTN","RORACK01",33,0)
 . S MSG=$$MSG^RORERR10($P(ERR,":"),.TYPE)
"RTN","RORACK01",34,0)
 . ;
"RTN","RORACK01",35,0)
 . I "OBR,OBX,NTE"[SEG  D  Q
"RTN","RORACK01",36,0)
 . . S TMP=$P(ERR,":",2)  D:TMP'=""
"RTN","RORACK01",37,0)
 . . . S II=II+1,INFO(II)="Placer Order Number: '"_TMP_"'"
"RTN","RORACK01",38,0)
 . . S TMP=$P(ERR,":",3)  D:TMP'=""
"RTN","RORACK01",39,0)
 . . . S TMP=$$FMTE^XLFDT($$HL7TFM^XLFDT(TMP))
"RTN","RORACK01",40,0)
 . . . S II=II+1,INFO(II)="Date/Time of Transaction: "_TMP
"RTN","RORACK01",41,0)
 . ;
"RTN","RORACK01",42,0)
 . I "ORC,RXE"[SEG  D  Q
"RTN","RORACK01",43,0)
 . . S TMP=$P(ERR,":",2)  D:TMP'=""
"RTN","RORACK01",44,0)
 . . . S II=II+1,INFO(II)="Filler Order Number: '"_TMP_"'"
"RTN","RORACK01",45,0)
 . . S TMP=$P(ERR,":",3)  D:TMP'=""
"RTN","RORACK01",46,0)
 . . . S TMP=$$FMTE^XLFDT($$HL7TFM^XLFDT(TMP))
"RTN","RORACK01",47,0)
 . . . S II=II+1,INFO(II)="Observation Date/Time: "_TMP
"RTN","RORACK01",48,0)
 . ;
"RTN","RORACK01",49,0)
 E  S MSG=ERR
"RTN","RORACK01",50,0)
 ;--- Record the error
"RTN","RORACK01",51,0)
 S:$G(MSG)="" MSG="Unknown error"
"RTN","RORACK01",52,0)
 D LOG^RORLOG(TYPE,MSG,$G(PATIEN),.INFO)
"RTN","RORACK01",53,0)
 Q 0
"RTN","RORACK01",54,0)
 ;
"RTN","RORACK01",55,0)
 ;***** ANALYZES THE ERROR CODE
"RTN","RORACK01",56,0)
 ;
"RTN","RORACK01",57,0)
 ; .RC           Error code (it can be modified inside the function)
"RTN","RORACK01",58,0)
 ;
"RTN","RORACK01",59,0)
 ; Return Values:
"RTN","RORACK01",60,0)
 ;         0  Continue
"RTN","RORACK01",61,0)
 ;         1  Stop and exit
"RTN","RORACK01",62,0)
 ;
"RTN","RORACK01",63,0)
EXIT(RC) ;
"RTN","RORACK01",64,0)
 Q:RC'<0 0
"RTN","RORACK01",65,0)
 S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORACK01",66,0)
 Q RC<0
"RTN","RORACK01",67,0)
 ;
"RTN","RORACK01",68,0)
 ;***** FINDS THE REGISTRY RECORD BY THE HL7 MESSAGE ID
"RTN","RORACK01",69,0)
 ;
"RTN","RORACK01",70,0)
 ; MSGID         HL7 message ID
"RTN","RORACK01",71,0)
 ; .PATIEN       Patient IEN is returned via this parameter
"RTN","RORACK01",72,0)
 ; .REGIEN       Registry IEN is returned via this parameter
"RTN","RORACK01",73,0)
 ;
"RTN","RORACK01",74,0)
 ; Return Values:
"RTN","RORACK01",75,0)
 ;        <0  Error Code
"RTN","RORACK01",76,0)
 ;        >0  IEN of the registry record
"RTN","RORACK01",77,0)
 ;
"RTN","RORACK01",78,0)
FINDREC(MSGID,PATIEN,REGIEN) ;
"RTN","RORACK01",79,0)
 N IEN,RC,RORBUF,RORMSG,TMP
"RTN","RORACK01",80,0)
 ;--- Find the registry record
"RTN","RORACK01",81,0)
 D FIND^DIC(798,,".01I;.02I","QUX",MSGID,2,"AM",,,"RORBUF","RORMSG")
"RTN","RORACK01",82,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"PROCESS^RORACK01",,798)
"RTN","RORACK01",83,0)
 S TMP=+$G(RORBUF("DILIST",0))
"RTN","RORACK01",84,0)
 Q:TMP<1 $$ERROR^RORERR(-52,"FINDREC^RORACK01",,,MSGID)
"RTN","RORACK01",85,0)
 Q:TMP>1 $$ERROR^RORERR(-39,"FINDREC^RORACK01",,,MSGID)
"RTN","RORACK01",86,0)
 ;--- Get the data
"RTN","RORACK01",87,0)
 S IEN=RORBUF("DILIST",2,1)
"RTN","RORACK01",88,0)
 S PATIEN=$G(RORBUF("DILIST","ID",1,.01))
"RTN","RORACK01",89,0)
 S REGIEN=$G(RORBUF("DILIST","ID",1,.02))
"RTN","RORACK01",90,0)
 Q IEN
"RTN","RORACK01",91,0)
 ;
"RTN","RORACK01",92,0)
 ;***** PROCESSES HL7 BATCH OF ACKNOWLEDGEMENTS
"RTN","RORACK01",93,0)
 ;
"RTN","RORACK01",94,0)
 ; .REGLST       Reference to a local variable containing the list
"RTN","RORACK01",95,0)
 ;               of registries associated with the original batch
"RTN","RORACK01",96,0)
 ;               message. The list must have the following structure:
"RTN","RORACK01",97,0)
 ;
"RTN","RORACK01",98,0)
 ;                 REGLST(RegistryName)=RegistryIEN^BatchID
"RTN","RORACK01",99,0)
 ;
"RTN","RORACK01",100,0)
 ; This function should be called only from the acknowledgement
"RTN","RORACK01",101,0)
 ; processing routine.
"RTN","RORACK01",102,0)
 ;
"RTN","RORACK01",103,0)
 ; Global node ^TMP("DILIST",$J) is used by this function.
"RTN","RORACK01",104,0)
 ;
"RTN","RORACK01",105,0)
 ; Return Values:
"RTN","RORACK01",106,0)
 ;        <0  Error Code
"RTN","RORACK01",107,0)
 ;         0  Ok
"RTN","RORACK01",108,0)
 ;
"RTN","RORACK01",109,0)
PROCMSG(REGLST) ;
"RTN","RORACK01",110,0)
 N ACKCODE,BTS,CS,FS,IEN,MSACNT,MSGID,NEXT,PATIEN,RC,REGIEN,RILST,TMP
"RTN","RORACK01",111,0)
 S FS=$G(HL("FS")),CS=$E($G(HL("ECH")),1)
"RTN","RORACK01",112,0)
 Q:(FS="")!(CS="") $$ERROR^RORERR(-40,"PROCESS^RORACK01",,,"HL")
"RTN","RORACK01",113,0)
 K ^TMP("RORACK",$J,"PR")
"RTN","RORACK01",114,0)
 ;--- Compile a list of registry IENs
"RTN","RORACK01",115,0)
 S TMP=""
"RTN","RORACK01",116,0)
 F  S TMP=$O(REGLST(TMP))  Q:TMP=""  D
"RTN","RORACK01",117,0)
 . S IEN=+REGLST(TMP)  S:IEN RILST(IEN)=""
"RTN","RORACK01",118,0)
 ;--- Process acknowledgement messages
"RTN","RORACK01",119,0)
 S RC=0,NEXT=1,(BTS,MSACNT)=0
"RTN","RORACK01",120,0)
 F  X:NEXT HLNEXT  Q:HLQUIT'>0  D  Q:BTS!$$EXIT(.RC)
"RTN","RORACK01",121,0)
 . S NEXT=1
"RTN","RORACK01",122,0)
 . I $P(HLNODE,FS)="BTS"  S BTS=+$P(HLNODE,FS,2)  Q
"RTN","RORACK01",123,0)
 . Q:$P(HLNODE,FS)'="MSA"
"RTN","RORACK01",124,0)
 . S MSACNT=MSACNT+1
"RTN","RORACK01",125,0)
 . S ACKCODE=$P(HLNODE,FS,2),MSGID=$P(HLNODE,FS,3)
"RTN","RORACK01",126,0)
 . Q:$P(MSGID,"-")=""
"RTN","RORACK01",127,0)
 . ;--- Find the registry record
"RTN","RORACK01",128,0)
 . S IEN=$$FINDREC(MSGID,.PATIEN,.REGIEN)
"RTN","RORACK01",129,0)
 . I IEN<0  S RC=IEN  Q
"RTN","RORACK01",130,0)
 . S ^TMP("RORACK",$J,"PR",IEN)=""
"RTN","RORACK01",131,0)
 . Q:'$D(RILST(+REGIEN))
"RTN","RORACK01",132,0)
 . ;--- Analyze the MSA segment and record the message
"RTN","RORACK01",133,0)
 . I ACKCODE="AA"  S RC=$$UPDRREC(IEN)    Q
"RTN","RORACK01",134,0)
 . I ACKCODE="AR"  S RC=$$UPDRREC(IEN,1)  Q
"RTN","RORACK01",135,0)
 . S TMP=$P(HLNODE,FS,4)
"RTN","RORACK01",136,0)
 . D:'(TMP?." ") LOG^RORLOG(6,TMP,PATIEN)
"RTN","RORACK01",137,0)
 . ;--- Record content of the ERR segments
"RTN","RORACK01",138,0)
 . S NEXT=0
"RTN","RORACK01",139,0)
 . F  X HLNEXT  Q:HLQUIT'>0  Q:$P(HLNODE,FS)'="ERR"  D
"RTN","RORACK01",140,0)
 . . S TMP=$$ERR($P(HLNODE,FS,2),PATIEN)
"RTN","RORACK01",141,0)
 ;--- Check if the actual number of messages in the batch is
"RTN","RORACK01",142,0)
 ;--- the same as that from the BTS-2 field
"RTN","RORACK01",143,0)
 I RC'<0  D:BTS'=MSACNT
"RTN","RORACK01",144,0)
 . S TMP="HL7 Batch Message ID: "_$G(HL("MID"))
"RTN","RORACK01",145,0)
 . S RC=$$ERROR^RORERR(-74,"PROCESS^RORACK01",TMP)
"RTN","RORACK01",146,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORACK01",147,0)
 ;
"RTN","RORACK01",148,0)
 ;***** PROCESSES REMAINING REGISTRY RECORDS
"RTN","RORACK01",149,0)
 ;
"RTN","RORACK01",150,0)
 ; .REGLST       Reference to a local variable containing the list
"RTN","RORACK01",151,0)
 ;               of registries associated with the original batch
"RTN","RORACK01",152,0)
 ;               message. The list must have the following structure:
"RTN","RORACK01",153,0)
 ;
"RTN","RORACK01",154,0)
 ;                 REGLST(RegistryName)=RegistryIEN^BatchID
"RTN","RORACK01",155,0)
 ;
"RTN","RORACK01",156,0)
 ; Return Values:
"RTN","RORACK01",157,0)
 ;        <0  Error Code
"RTN","RORACK01",158,0)
 ;         0  Ok
"RTN","RORACK01",159,0)
 ;
"RTN","RORACK01",160,0)
PROCREM(REGLST) ;
"RTN","RORACK01",161,0)
 N BATCHID,BIDLST,IEN,IR,RC,RORMSG,TMP
"RTN","RORACK01",162,0)
 ;--- Compile a list of batch message IDs
"RTN","RORACK01",163,0)
 S IR=""
"RTN","RORACK01",164,0)
 F  S IR=$O(REGLST(IR))  Q:IR=""  D
"RTN","RORACK01",165,0)
 . S TMP=$P(REGLST(IR),U,2)  S:TMP'="" BIDLST(TMP)=""
"RTN","RORACK01",166,0)
 ;--- Acnowledge all remaining messages of the batches
"RTN","RORACK01",167,0)
 S BATCHID="",RC=0
"RTN","RORACK01",168,0)
 F  S BATCHID=$O(BIDLST(BATCHID))  Q:BATCHID=""  D  Q:RC<0
"RTN","RORACK01",169,0)
 . S TMP=BATCHID_"-"
"RTN","RORACK01",170,0)
 . D LIST^DIC(798,,"@","U",,TMP,TMP,"AM",,,,"RORMSG")
"RTN","RORACK01",171,0)
 . I $G(DIERR)  D  Q
"RTN","RORACK01",172,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"PROCREM^RORACK01",,798)
"RTN","RORACK01",173,0)
 . S IR=""
"RTN","RORACK01",174,0)
 . F  S IR=$O(^TMP("DILIST",$J,2,IR))  Q:IR=""  D  Q:$$EXIT(.RC)
"RTN","RORACK01",175,0)
 . . S IEN=^TMP("DILIST",$J,2,IR)
"RTN","RORACK01",176,0)
 . . S:'$D(^TMP("RORACK",$J,"PR",IEN)) RC=$$UPDRREC(IEN)
"RTN","RORACK01",177,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORACK01",178,0)
 ;
"RTN","RORACK01",179,0)
 ;***** UPDATES REGISTRY RECORD
"RTN","RORACK01",180,0)
 ;
"RTN","RORACK01",181,0)
 ; IEN           IEN of the local registry record
"RTN","RORACK01",182,0)
 ; [REJECT]      Non-zero value indicates that the message was
"RTN","RORACK01",183,0)
 ;               rejected for reasons unrelated to the content or
"RTN","RORACK01",184,0)
 ;               format (0 by default)
"RTN","RORACK01",185,0)
 ;
"RTN","RORACK01",186,0)
 ; Return Values:
"RTN","RORACK01",187,0)
 ;        <0  Error Code
"RTN","RORACK01",188,0)
 ;         0  Ok
"RTN","RORACK01",189,0)
 ;
"RTN","RORACK01",190,0)
UPDRREC(IEN,REJECT) ;
"RTN","RORACK01",191,0)
 N IENS,RC,RORBUF,RORFDA,RORMSG,TMP
"RTN","RORACK01",192,0)
 S IENS=IEN_","
"RTN","RORACK01",193,0)
 I '$G(REJECT)  S RC=0  D  Q:RC<0 RC
"RTN","RORACK01",194,0)
 . ;--- Load data from the registry record
"RTN","RORACK01",195,0)
 . D GETS^DIQ(798,IENS,"9.1;9.2","I","RORBUF","RORMSG")
"RTN","RORACK01",196,0)
 . I $G(DIERR)  D  Q
"RTN","RORACK01",197,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"UPDRREC^RORACK01",,798,IENS)
"RTN","RORACK01",198,0)
 . ;--- Reset flags and update dates
"RTN","RORACK01",199,0)
 . S RORFDA(798,IENS,3)="@"   ; New patient
"RTN","RORACK01",200,0)
 . S RORFDA(798,IENS,4)="@"   ; Update demographics
"RTN","RORACK01",201,0)
 . S RORFDA(798,IENS,5)="@"   ; Update local registry data
"RTN","RORACK01",202,0)
 . S TMP=$G(RORBUF(798,IENS,9.2,"I"))
"RTN","RORACK01",203,0)
 . S:TMP>$G(RORBUF(798,IENS,9.1,"I")) RORFDA(798,IENS,9.1)=TMP
"RTN","RORACK01",204,0)
 S RORFDA(798,IENS,10)="@"    ; Last message ID
"RTN","RORACK01",205,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORACK01",206,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"UPDRREC^RORACK01",,798,IENS)
"RTN","RORACK01",207,0)
 Q 0
"RTN","RORDD")
0^27^B18468932
"RTN","RORDD",1,0)
RORDD ;HCIOFO/SG - DATA DICTIONARY UTILITIES ; 8/6/02 8:36am
"RTN","RORDD",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORDD",3,0)
 ;
"RTN","RORDD",4,0)
 Q
"RTN","RORDD",5,0)
 ;
"RTN","RORDD",6,0)
 ;***** "ACL" CROSS-REFERENCE UTILITIES
"RTN","RORDD",7,0)
 ;
"RTN","RORDD",8,0)
 ; These two procedures are used by the kill and set logic of the
"RTN","RORDD",9,0)
 ; "ACL" cross-reference (MUMPS type) of the .01 field of the SECURITY
"RTN","RORDD",10,0)
 ; KEY multiple of the ROR REGISTRY PARAMETERS file (#798.1).
"RTN","RORDD",11,0)
 ;
"RTN","RORDD",12,0)
 ; FileMan initializes the X variable (name of the security key) and
"RTN","RORDD",13,0)
 ; the DA array before calling these procedures.
"RTN","RORDD",14,0)
 ;
"RTN","RORDD",15,0)
ACLKILL ;
"RTN","RORDD",16,0)
 N RORDUZ  S RORDUZ=""
"RTN","RORDD",17,0)
 F  S RORDUZ=$O(^XUSEC(X,RORDUZ))  Q:RORDUZ=""  D
"RTN","RORDD",18,0)
 . K ^ROR(798.1,"ACL",RORDUZ,DA(1),DA)
"RTN","RORDD",19,0)
 Q
"RTN","RORDD",20,0)
 ;
"RTN","RORDD",21,0)
ACLSET ;
"RTN","RORDD",22,0)
 N RORDUZ  S RORDUZ=""
"RTN","RORDD",23,0)
 F  S RORDUZ=$O(^XUSEC(X,RORDUZ))  Q:RORDUZ=""  D
"RTN","RORDD",24,0)
 . S ^ROR(798.1,"ACL",RORDUZ,DA(1),DA)=""
"RTN","RORDD",25,0)
 Q
"RTN","RORDD",26,0)
 ;
"RTN","RORDD",27,0)
 ;***** CHECKS IF THE REGISTRY RECORD IS ACTIVE
"RTN","RORDD",28,0)
 ;
"RTN","RORDD",29,0)
 ; INACTDT       Inactivation date
"RTN","RORDD",30,0)
 ; REACTDT       Reactivation date
"RTN","RORDD",31,0)
 ;
"RTN","RORDD",32,0)
 ; Return Values:
"RTN","RORDD",33,0)
 ;        0  The record is inactive
"RTN","RORDD",34,0)
 ;        1  The record is active
"RTN","RORDD",35,0)
 ;
"RTN","RORDD",36,0)
ACTIVE(INACTDT,REACTDT) ;
"RTN","RORDD",37,0)
 Q $S('INACTDT:1,INACTDT>$$NOW^XLFDT:1,INACTDT<REACTDT:1,1:0)
"RTN","RORDD",38,0)
 ;
"RTN","RORDD",39,0)
 ;***** DISPLAYS A LIST OF APIs DEFINED IN THE SUBFILE #799.23
"RTN","RORDD",40,0)
 ;
"RTN","RORDD",41,0)
 ; IEN           IEN of the current record of the file #799.2
"RTN","RORDD",42,0)
 ;
"RTN","RORDD",43,0)
APILST(IEN) ;
"RTN","RORDD",44,0)
 N D,DIC,DLAYGO,DZ,RORMSG
"RTN","RORDD",45,0)
 S DIC=$$ROOT^DILFD(799.23,","_(+IEN)_",")  Q:DIC=""
"RTN","RORDD",46,0)
 S D=$$GET1^DID(799.23,.01,,"FIELD LENGTH",,"RORMSG")
"RTN","RORDD",47,0)
 D EN^DDIOL($J(1,D),,"?2"),EN^DDIOL("GETS^DIQ",,"?10")
"RTN","RORDD",48,0)
 S DIC(0)="",D="B",DZ="??"
"RTN","RORDD",49,0)
 S DIC("W")="D EN^DDIOL($P(^(0),U,3)_""^""_$P(^(0),U,2),,""?10"")"
"RTN","RORDD",50,0)
 D DQ^DICQ
"RTN","RORDD",51,0)
 Q
"RTN","RORDD",52,0)
 ;
"RTN","RORDD",53,0)
 ;***** VALIDATES A NAME OF THE CALLBACK FUNCTION
"RTN","RORDD",54,0)
 ;
"RTN","RORDD",55,0)
 ; MNFP          Minimal number of formal parameters (opt'l).
"RTN","RORDD",56,0)
 ;               If this parameter has a value greater than 1, the
"RTN","RORDD",57,0)
 ;               function makes very simple check of the number of
"RTN","RORDD",58,0)
 ;               formal parameters in the source code.
"RTN","RORDD",59,0)
 ;
"RTN","RORDD",60,0)
 ; This function is intended for use in the input transforms
"RTN","RORDD",61,0)
 ; of registry definition fields. It kills the X variable if it
"RTN","RORDD",62,0)
 ; contains illegal value.
"RTN","RORDD",63,0)
 ;
"RTN","RORDD",64,0)
 ; The function does not allow to use '%' in the routine and
"RTN","RORDD",65,0)
 ; tag names (this is prohibited by VistA SAC).
"RTN","RORDD",66,0)
 ;
"RTN","RORDD",67,0)
 ; If the function cannot obtain the source code of the callback
"RTN","RORDD",68,0)
 ; function (because the code does not exist yet or has been stripped)
"RTN","RORDD",69,0)
 ; or there are not enough formal parameters in the definition of the
"RTN","RORDD",70,0)
 ; function, it issues a warning but does not reject the value.
"RTN","RORDD",71,0)
 ;
"RTN","RORDD",72,0)
 ; Return Values:
"RTN","RORDD",73,0)
 ;        0  Ok
"RTN","RORDD",74,0)
 ;        1  Illegal name (X is killed)
"RTN","RORDD",75,0)
 ;
"RTN","RORDD",76,0)
EP(MNFP) ;
"RTN","RORDD",77,0)
 Q:$G(X)="" 0
"RTN","RORDD",78,0)
 N ENTPNT,TMP
"RTN","RORDD",79,0)
 ;--- Check if the value has the "$$TAG^ROUTINE" format
"RTN","RORDD",80,0)
 I '(X?2"$"1.8UN1"^"1.8UN)  K X  Q 1
"RTN","RORDD",81,0)
 ;--- Check if the routine exists
"RTN","RORDD",82,0)
 S ENTPNT=X,X=$P(X,U,2)
"RTN","RORDD",83,0)
 X ^%ZOSF("TEST")  E  D  K X  Q 1
"RTN","RORDD",84,0)
 . D EN^DDIOL("The '"_X_"' routine does not exist!")
"RTN","RORDD",85,0)
 S X=ENTPNT
"RTN","RORDD",86,0)
 ;--- Skip the enhanced checks when verifying fields
"RTN","RORDD",87,0)
 Q:$G(DIUTIL)="VERIFY FIELDS" 0
"RTN","RORDD",88,0)
 ;--- Get the line of source code
"RTN","RORDD",89,0)
 S ENTPNT=$P(X,"$$",2),TMP=$TR($P($T(@ENTPNT),";")," ")
"RTN","RORDD",90,0)
 ;--- Display a warning if there is no source line
"RTN","RORDD",91,0)
 I TMP=""  D  Q 0
"RTN","RORDD",92,0)
 . S TMP="Make sure that the '"_$P(ENTPNT,U)_"' tag"
"RTN","RORDD",93,0)
 . D EN^DDIOL(TMP_" exists in the '"_$P(ENTPNT,U,2)_"' routine.")
"RTN","RORDD",94,0)
 ;--- Display a warning if there are not enough formal parameters
"RTN","RORDD",95,0)
 I $G(MNFP)>1,$L(TMP,",")<MNFP  D  Q 0
"RTN","RORDD",96,0)
 . S TMP="Make sure that the entry point has at least "_MNFP
"RTN","RORDD",97,0)
 . D EN^DDIOL(TMP_" formal parameter(s).")
"RTN","RORDD",98,0)
 Q 0
"RTN","RORDD",99,0)
 ;
"RTN","RORDD",100,0)
 ;***** VALIDATES A SELECTION RULE EXPRESSION
"RTN","RORDD",101,0)
 ;
"RTN","RORDD",102,0)
 ; FILE          File number that the expression is associated with
"RTN","RORDD",103,0)
 ;
"RTN","RORDD",104,0)
 ; This function is intended for use in the input transforms
"RTN","RORDD",105,0)
 ; of registry definition fields. It kills the X variable if
"RTN","RORDD",106,0)
 ; it contains an illegal value.
"RTN","RORDD",107,0)
 ;
"RTN","RORDD",108,0)
 ; Return Values:
"RTN","RORDD",109,0)
 ;        0  Ok
"RTN","RORDD",110,0)
 ;        1  Illegal expression (X is killed)
"RTN","RORDD",111,0)
 ;
"RTN","RORDD",112,0)
EXPR(FILE) ;
"RTN","RORDD",113,0)
 Q:($G(FILE)'>0)!($G(X)="") 0
"RTN","RORDD",114,0)
 N EXPR,RC,RESULT,RORERROR,RORLOG,RORPARM,TMP
"RTN","RORDD",115,0)
 ;--- Check if the parser routine exists in the UCI
"RTN","RORDD",116,0)
 S EXPR=X,X="RORUPEX"  X ^%ZOSF("TEST")  S X=EXPR  E  Q 0
"RTN","RORDD",117,0)
 ;--- Parse and validate the expression
"RTN","RORDD",118,0)
 S RC=$$PARSER^RORUPEX(FILE,X,.RESULT)
"RTN","RORDD",119,0)
 Q:RC'<0 0  K X
"RTN","RORDD",120,0)
 ;--- Field does not exist
"RTN","RORDD",121,0)
 I RC=-7   D  Q 1
"RTN","RORDD",122,0)
 . S TMP="One of the referenced fields"
"RTN","RORDD",123,0)
 . D EN^DDIOL(TMP_" does not exist in the file #"_FILE_"!")
"RTN","RORDD",124,0)
 ;--- Syntax error in the expression
"RTN","RORDD",125,0)
 I RC=-21  D  Q 1
"RTN","RORDD",126,0)
 . D EN^DDIOL("Invalid expression: '"_EXPR_"'")
"RTN","RORDD",127,0)
 . D EN^DDIOL("Parsed to: '"_$G(RESULT)_"' ")
"RTN","RORDD",128,0)
 ;--- File does not exist
"RTN","RORDD",129,0)
 I RC=-58  D  Q 1
"RTN","RORDD",130,0)
 . D EN^DDIOL("Referenced file #"_FILE_" does not exist!")
"RTN","RORDD",131,0)
 Q 1
"RTN","RORDD",132,0)
 ;
"RTN","RORDD",133,0)
 ;***** CHECKS IF A FIELD OF A NATIONAL DEFINITION CAN BE DELETED
"RTN","RORDD",134,0)
 ;
"RTN","RORDD",135,0)
 ; FILE          Top-level file number
"RTN","RORDD",136,0)
 ; [IEN]         IEN of the current record of the top-level file
"RTN","RORDD",137,0)
 ; [FIELD]       Number of the NATIONAL field.
"RTN","RORDD",138,0)
 ;               If value of this parameter less than zero, local
"RTN","RORDD",139,0)
 ;               modifications of all records will be prohibited.
"RTN","RORDD",140,0)
 ;               By default, the .09 field is used.
"RTN","RORDD",141,0)
 ;
"RTN","RORDD",142,0)
 ; This function is intended for use in the "DEL" node logic
"RTN","RORDD",143,0)
 ; of registry definition fields.
"RTN","RORDD",144,0)
 ;
"RTN","RORDD",145,0)
 ; Return Values:
"RTN","RORDD",146,0)
 ;        0  The value of the field can be deleted
"RTN","RORDD",147,0)
 ;        1  Deletion is prohibited
"RTN","RORDD",148,0)
 ;
"RTN","RORDD",149,0)
VADEL(FILE,IEN,FIELD) ;
"RTN","RORDD",150,0)
 Q:$G(XPDNM)'="" 0
"RTN","RORDD",151,0)
 ;--- An authorized developer can delete anything
"RTN","RORDD",152,0)
 Q:$G(RORPARM("DEVELOPER")) 0
"RTN","RORDD",153,0)
 ;--- Check if the registry definition is a national one
"RTN","RORDD",154,0)
 N RC,RORMSG
"RTN","RORDD",155,0)
 I $G(FIELD)'<0  S RC=0  D:$G(IEN)>0  Q:'RC 0
"RTN","RORDD",156,0)
 . S:'$G(FIELD) FIELD=.09
"RTN","RORDD",157,0)
 . S RC=$$GET1^DIQ(FILE,IEN_",",FIELD,"I",,"RORMSG")
"RTN","RORDD",158,0)
 D EN^DDIOL("You cannot edit a national registry definition!")
"RTN","RORDD",159,0)
 Q 1
"RTN","RORDD",160,0)
 ;
"RTN","RORDD",161,0)
 ;***** CHECKS IF A FIELD OF A NATIONAL DEFINITION CAN BE EDITED
"RTN","RORDD",162,0)
 ;
"RTN","RORDD",163,0)
 ; FILE          Top-level file number
"RTN","RORDD",164,0)
 ; [IEN]         IEN of the current record of the top-level file
"RTN","RORDD",165,0)
 ; [FIELD]       Number of the NATIONAL field.
"RTN","RORDD",166,0)
 ;               If value of this parameter less than zero, local
"RTN","RORDD",167,0)
 ;               modifications of all records will be prohibited.
"RTN","RORDD",168,0)
 ;               By default, the .09 field is used.
"RTN","RORDD",169,0)
 ;
"RTN","RORDD",170,0)
 ; This function is intended for use in the input transforms
"RTN","RORDD",171,0)
 ; of registry definition fields. It kills the X variable if
"RTN","RORDD",172,0)
 ; it contains illegal value.
"RTN","RORDD",173,0)
 ;
"RTN","RORDD",174,0)
 ; Return Values:
"RTN","RORDD",175,0)
 ;        0  The field can be edited
"RTN","RORDD",176,0)
 ;        1  Editing is prohibited (X is killed)
"RTN","RORDD",177,0)
 ;
"RTN","RORDD",178,0)
VAEDT(FILE,IEN,FIELD) ;
"RTN","RORDD",179,0)
 Q:($G(DIUTIL)="VERIFY FIELDS")!($G(XPDNM)'="") 0
"RTN","RORDD",180,0)
 ;--- An authorized developer can edit anything
"RTN","RORDD",181,0)
 Q:$G(RORPARM("DEVELOPER")) 0
"RTN","RORDD",182,0)
 ;--- Check if the registry definition is a national one
"RTN","RORDD",183,0)
 N RC,RORMSG
"RTN","RORDD",184,0)
 I $G(FIELD)'<0  S RC=0  D:$G(IEN)>0  Q:'RC 0
"RTN","RORDD",185,0)
 . S:'$G(FIELD) FIELD=.09
"RTN","RORDD",186,0)
 . S RC=$$GET1^DIQ(FILE,IEN_",",FIELD,"I",,"RORMSG")
"RTN","RORDD",187,0)
 K X
"RTN","RORDD",188,0)
 D EN^DDIOL("You cannot edit a national registry definition!")
"RTN","RORDD",189,0)
 Q 1
"RTN","RORENV02")
0^18^B5715007
"RTN","RORENV02",1,0)
RORENV02 ;HCIOFO/SG - ENVIRONMENT CHECK ROUTINE (ROR*1.0*2) ; 7/24/02 11:54am
"RTN","RORENV02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORENV02",3,0)
 ;
"RTN","RORENV02",4,0)
 ;***** CHECKS THE ENVIRONMENT BEFORE THE INSTALLATION
"RTN","RORENV02",5,0)
START ;
"RTN","RORENV02",6,0)
 Q:'$G(XPDENV)
"RTN","RORENV02",7,0)
 ;--- Check the scheduled option
"RTN","RORENV02",8,0)
 Q:$$CHKOPT("ROR TASK")<0
"RTN","RORENV02",9,0)
 Q
"RTN","RORENV02",10,0)
 ;
"RTN","RORENV02",11,0)
 ;***** CHECKS THE SCHEDULED OPTION
"RTN","RORENV02",12,0)
 ;
"RTN","RORENV02",13,0)
 ; OPTION        Option name
"RTN","RORENV02",14,0)
 ;
"RTN","RORENV02",15,0)
 ; Return Values:
"RTN","RORENV02",16,0)
 ;       <0  Error code
"RTN","RORENV02",17,0)
 ;        0  Ok
"RTN","RORENV02",18,0)
 ;
"RTN","RORENV02",19,0)
 ; This function can be used in the environment check routines to
"RTN","RORENV02",20,0)
 ; check if the option is running and/or scheduled to run.
"RTN","RORENV02",21,0)
 ;
"RTN","RORENV02",22,0)
 ; The function displays appropriate error messages and warnings
"RTN","RORENV02",23,0)
 ; using the WRITE command. So, it MUST NOT be called from the
"RTN","RORENV02",24,0)
 ; pre-install or post-install routines.
"RTN","RORENV02",25,0)
 ;
"RTN","RORENV02",26,0)
 ; The function uses the ^UTILITY($J,"W") node (^DIWP and ^DIWW).
"RTN","RORENV02",27,0)
 ;
"RTN","RORENV02",28,0)
CHKOPT(OPTION) ;
"RTN","RORENV02",29,0)
 N DIWF,DIWL,DIWR,RC,RORBUF,RORI,RORSDT,TMP,X,ZTSK
"RTN","RORENV02",30,0)
 ;--- Check status of the option
"RTN","RORENV02",31,0)
 D OPTSTAT^XUTMOPT(OPTION,.RORBUF)
"RTN","RORENV02",32,0)
 S (RC,RORSDT)=0
"RTN","RORENV02",33,0)
 F RORI=1:1:$G(RORBUF)  K ZTSK  D  I $G(ZTSK(1))=2  S RC=-76  Q
"RTN","RORENV02",34,0)
 . S ZTSK=$P(RORBUF(RORI),"^")  Q:'ZTSK
"RTN","RORENV02",35,0)
 . D STAT^%ZTLOAD
"RTN","RORENV02",36,0)
 . S TMP=$P(RORBUF(RORI),"^",2)
"RTN","RORENV02",37,0)
 . I TMP>0  S:'RORSDT!(TMP<RORSDT) RORSDT=TMP
"RTN","RORENV02",38,0)
 ;--- Display an error message if the option is running
"RTN","RORENV02",39,0)
 I RC  D  Q RC
"RTN","RORENV02",40,0)
 . W !,$$MSG^RORERR20(RC,,,OPTION),!
"RTN","RORENV02",41,0)
 ;--- Display an apropriate warning
"RTN","RORENV02",42,0)
 S DIWL=5,DIWR=$G(IOM,80)-DIWL
"RTN","RORENV02",43,0)
 K ^UTILITY($J,"W")
"RTN","RORENV02",44,0)
CM1 I RORSDT>0  D
"RTN","RORENV02",45,0)
 . ;;"The ["_OPTION_"] option is scheduled to run "_RORSDT_"."
"RTN","RORENV02",46,0)
 . ;;"If you are going to schedule the installation, please, choose"
"RTN","RORENV02",47,0)
 . ;;"an appropriate time so that the post-install will either"
"RTN","RORENV02",48,0)
 . ;;"finish well before the ["_OPTION_"] scheduled time or start"
"RTN","RORENV02",49,0)
 . ;;"after the option completion."
"RTN","RORENV02",50,0)
 . ;---
"RTN","RORENV02",51,0)
 . S RORSDT=$$FMTE^XLFDT(RORSDT)
"RTN","RORENV02",52,0)
 . S RORSDT="on "_$P(RORSDT,"@")_" at "_$P(RORSDT,"@",2)
"RTN","RORENV02",53,0)
 . F RORI=1:1  S X=$T(CM1+RORI)  Q:X'[";;"  D
"RTN","RORENV02",54,0)
 . . X "S X="_$P(X,";;",2)  D ^DIWP
"RTN","RORENV02",55,0)
CM2 E  D
"RTN","RORENV02",56,0)
 . ;;"The ["_OPTION_"] option is not scheduled. Do not forget"
"RTN","RORENV02",57,0)
 . ;;"to schedule it after completion of the installation."
"RTN","RORENV02",58,0)
 . ;---
"RTN","RORENV02",59,0)
 . F RORI=1:1  S X=$T(CM2+RORI)  Q:X'[";;"  D
"RTN","RORENV02",60,0)
 . . X "S X="_$P(X,";;",2)  D ^DIWP
"RTN","RORENV02",61,0)
 W !  D ^DIWW
"RTN","RORENV02",62,0)
 Q 0
"RTN","RORERR20")
0^17^B39482993
"RTN","RORERR20",1,0)
RORERR20 ;HCIOFO/SG - LIST OF ERROR MESSAGES  ; 8/19/02 10:51am
"RTN","RORERR20",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORERR20",3,0)
 ;
"RTN","RORERR20",4,0)
 ;***** RETURNS TEXT OF THE MESSAGE
"RTN","RORERR20",5,0)
 ;
"RTN","RORERR20",6,0)
 ; ERRCODE       Error code
"RTN","RORERR20",7,0)
 ; [.TYPE]       Type of the error
"RTN","RORERR20",8,0)
 ; [ARG1-ARG5]   Optional parameters that substitute the |n| "windows"
"RTN","RORERR20",9,0)
 ;               in the text of the message (for example, the |2| will
"RTN","RORERR20",10,0)
 ;               be substituted by the value of the ARG2).
"RTN","RORERR20",11,0)
 ;
"RTN","RORERR20",12,0)
MSG(ERRCODE,TYPE,ARG1,ARG2,ARG3,ARG4,ARG5) ;
"RTN","RORERR20",13,0)
 S TYPE=6  Q:ERRCODE'<0 ""
"RTN","RORERR20",14,0)
 N ARG,I1,I2,MSG
"RTN","RORERR20",15,0)
 ;--- Get a descriptor of the message
"RTN","RORERR20",16,0)
 S I1=-ERRCODE,MSG=$P($T(MSGLIST+I1),";;",2)
"RTN","RORERR20",17,0)
 S I1=+$TR($P(MSG,U,2)," "),MSG=$P(MSG,U,3,999)
"RTN","RORERR20",18,0)
 S:I1>0 TYPE=I1
"RTN","RORERR20",19,0)
 Q:MSG?." " "Unknown error ("_ERRCODE_")"
"RTN","RORERR20",20,0)
 ;--- Substitute parameters
"RTN","RORERR20",21,0)
 S I1=2
"RTN","RORERR20",22,0)
 F  S I1=$F(MSG,"|",I1-1)  Q:'I1  D
"RTN","RORERR20",23,0)
 . S I2=$F(MSG,"|",I1)  Q:'I2
"RTN","RORERR20",24,0)
 . X "S ARG=$G(ARG"_+$TR($E(MSG,I1,I2-2)," ")_")"
"RTN","RORERR20",25,0)
 . S $E(MSG,I1-1,I2-1)=ARG
"RTN","RORERR20",26,0)
 Q $$TRIM^XLFSTR(MSG)
"RTN","RORERR20",27,0)
 ;
"RTN","RORERR20",28,0)
 ;***** RETURNS TYPE OF THE MESSAGE
"RTN","RORERR20",29,0)
 ;
"RTN","RORERR20",30,0)
 ; ERRCODE       Error code
"RTN","RORERR20",31,0)
 ;
"RTN","RORERR20",32,0)
TYPE(ERRCODE) ;
"RTN","RORERR20",33,0)
 Q:ERRCODE'<0 0
"RTN","RORERR20",34,0)
 N I,TYPE  S I=-ERRCODE
"RTN","RORERR20",35,0)
 S I=$P($T(MSGLIST+I),";;",2),TYPE=+$TR($P(I,U,2)," ")
"RTN","RORERR20",36,0)
 Q $S(TYPE>0:TYPE,1:6)
"RTN","RORERR20",37,0)
 ;
"RTN","RORERR20",38,0)
 ;***** LIST OF THE MESSAGES (THERE SHOULD BE NOTHING AFTER THE LIST!)
"RTN","RORERR20",39,0)
 ;
"RTN","RORERR20",40,0)
 ; The error codes are provided in the table only for clarity.
"RTN","RORERR20",41,0)
 ; Text of the messages are extracted using the $TEXT function and
"RTN","RORERR20",42,0)
 ; absolute values of the ERRCODE parameter.
"RTN","RORERR20",43,0)
 ;
"RTN","RORERR20",44,0)
 ; Message Type:
"RTN","RORERR20",45,0)
 ;               1  Debug          4  Warning
"RTN","RORERR20",46,0)
 ;               2  Information    5  Database Error
"RTN","RORERR20",47,0)
 ;               3  Data Quality   6  Error
"RTN","RORERR20",48,0)
 ;
"RTN","RORERR20",49,0)
MSGLIST ; Code Type  Message Text
"RTN","RORERR20",50,0)
 ;;  -1 ^ 6 ^ Cannot find a descriptor of the registry
"RTN","RORERR20",51,0)
 ;;  -2 ^ 6 ^ Duplicate registry names
"RTN","RORERR20",52,0)
 ;;  -3 ^ 6 ^ Cannot find a descriptor of the rule
"RTN","RORERR20",53,0)
 ;;  -4 ^ 6 ^ Duplicate rule names
"RTN","RORERR20",54,0)
 ;;  -5 ^ 6 ^ Circle rule references
"RTN","RORERR20",55,0)
 ;;  -6 ^ 6 ^ Illegal update entry point: |2|
"RTN","RORERR20",56,0)
 ;;  -7 ^ 6 ^ Field '|2|' not found
"RTN","RORERR20",57,0)
 ;;  -8 ^ 6 ^ Duplicate patients in the registry
"RTN","RORERR20",58,0)
 ;;  -9 ^ 5 ^ FileMan DBS call error(s)|2|
"RTN","RORERR20",59,0)
 ;; -10 ^ 6 ^ Bad registry name: '|2|'
"RTN","RORERR20",60,0)
 ;; -11 ^ 6 ^ Cannot lock the record(s) of |2|
"RTN","RORERR20",61,0)
 ;; -12 ^ 6 ^ Cannot load and prepare lab search data
"RTN","RORERR20",62,0)
 ;; -13 ^ 6 ^ Cannot lock the registries
"RTN","RORERR20",63,0)
 ;; -14 ^ 6 ^ Cannot prepare selection rules
"RTN","RORERR20",64,0)
 ;; -15 ^ 6 ^ Error(s) during processing of the patient data
"RTN","RORERR20",65,0)
 ;; -16 ^ 6 ^ Cannot update demographic data
"RTN","RORERR20",66,0)
 ;; -17 ^ 6 ^ Illegal entry point: '|2|'
"RTN","RORERR20",67,0)
 ;; -18 ^ 6 ^ Routine '|2|' does not exist
"RTN","RORERR20",68,0)
 ;; -19 ^ 6 ^ Cannot load the selection rules
"RTN","RORERR20",69,0)
 ;; -20 ^ 6 ^ Cannot sort the selection rules
"RTN","RORERR20",70,0)
 ;; -21 ^ 6 ^ Syntax error in the expression
"RTN","RORERR20",71,0)
 ;; -22 ^ 6 ^ Cannot prepare data extraction definitions
"RTN","RORERR20",72,0)
 ;; -23 ^ 6 ^ Cannot set up HL7 environment variables
"RTN","RORERR20",73,0)
 ;; -24 ^ 6 ^ Cannot send the batch HL7 message
"RTN","RORERR20",74,0)
 ;; -25 ^ 6 ^ No event driver protocol
"RTN","RORERR20",75,0)
 ;; -26 ^ 3 ^ Neither ICN nor SSN is available
"RTN","RORERR20",76,0)
 ;; -27 ^ 5 ^ Cannot obtain results of the Lab tests
"RTN","RORERR20",77,0)
 ;; -28 ^ 4 ^ No active registries to |2|!
"RTN","RORERR20",78,0)
 ;; -29 ^ 6 ^ Non-existent LOINC code |2| in the registry parameters
"RTN","RORERR20",79,0)
 ;; -30 ^ 5 ^ Duplicate records in the file #95.3 for LOINC code |2|
"RTN","RORERR20",80,0)
 ;; -31 ^ 4 ^ Cannot remove the patient #|1| from the pending list
"RTN","RORERR20",81,0)
 ;; -32 ^ 6 ^ Incorrect data extraction period: '|2|-|3|'
"RTN","RORERR20",82,0)
 ;; -33 ^ 6 ^ Cannot de-queue data extraction task
"RTN","RORERR20",83,0)
 ;; -34 ^ 6 ^ Cannot open an output file
"RTN","RORERR20",84,0)
 ;; -35 ^ 6 ^ Device Handler error
"RTN","RORERR20",85,0)
 ;; -36 ^ 6 ^ Cannot retrieve Patient details (DFN:|1|) from File #|2|
"RTN","RORERR20",86,0)
 ;; -37 ^ 6 ^ Cannot retrieve details of medication
"RTN","RORERR20",87,0)
 ;; -38 ^ 6 ^ Cannot retrieve CPT code
"RTN","RORERR20",88,0)
 ;; -39 ^ 6 ^ Duplicate HL7 message ID in the file #798: '|2|'
"RTN","RORERR20",89,0)
 ;; -40 ^ 6 ^ Undefined variable: '|2|'
"RTN","RORERR20",90,0)
 ;; -41 ^ 2 ^ Registry setup has been completed
"RTN","RORERR20",91,0)
 ;; -42 ^ 4 ^ Task has been interrupted by user or by parent task
"RTN","RORERR20",92,0)
 ;; -43 ^ 6 ^ Error during the |2|. See log files.
"RTN","RORERR20",93,0)
 ;; -44 ^ 6 ^ Illegal extraction entry point: |2|
"RTN","RORERR20",94,0)
 ;; -45 ^ 6 ^ Illegal or missing IEN of selection rule
"RTN","RORERR20",95,0)
 ;; -46 ^ 5 ^ Cannot load registry parameters
"RTN","RORERR20",96,0)
 ;; -47 ^ 5 ^ Cannot find the '|2|' drug class
"RTN","RORERR20",97,0)
 ;; -48 ^ 2 ^ Registry '|2|' is inactive
"RTN","RORERR20",98,0)
 ;; -49 ^ 4 ^ Registry '|2|' is awaiting ACK
"RTN","RORERR20",99,0)
 ;; -50 ^ 6 ^ Cannot create the '|2|' checkpoint!
"RTN","RORERR20",100,0)
 ;; -51 ^ 6 ^ Cannot complete the '|2|' checkpoint!
"RTN","RORERR20",101,0)
 ;; -52 ^ 6 ^ Cannot find HL7 message ID in the file #798: '|2|'
"RTN","RORERR20",102,0)
 ;; -53 ^ 6 ^ Cannot enable the '|2|' protocol
"RTN","RORERR20",103,0)
 ;; -54 ^ 6 ^ The '|2|' Lab Search is not defined
"RTN","RORERR20",104,0)
 ;; -55 ^ 4 ^ No indicators are defined for the '|2|' Lab Search
"RTN","RORERR20",105,0)
 ;; -56 ^ 6 ^ Error code '|2|' is returned by the '|3|'
"RTN","RORERR20",106,0)
 ;; -57 ^ 4 ^ Error code '|2|' is returned by the '|3|'
"RTN","RORERR20",107,0)
 ;; -58 ^ 6 ^ File '|2|' not found
"RTN","RORERR20",108,0)
 ;; -59 ^ 3 ^ ICN checksum is shorter than 6 digits
"RTN","RORERR20",109,0)
 ;; -60 ^ 6 ^ Subtask #|2| crashed (see TaskMan logs)
"RTN","RORERR20",110,0)
 ;; -61 ^ 6 ^ Cannot start the registry update in multitask mode
"RTN","RORERR20",111,0)
 ;; -62 ^ 2 ^ Registry Update subtask #|2| has been scheduled
"RTN","RORERR20",112,0)
 ;; -63 ^ 6 ^ Data search in file #|2| is not supported
"RTN","RORERR20",113,0)
 ;; -64 ^ 6 ^ Data element #|3| (file #|2|) is not supported
"RTN","RORERR20",114,0)
 ;; -65 ^ 6 ^ |4| value of element #|3| (file #|2|) is not supported
"RTN","RORERR20",115,0)
 ;; -66 ^ 1 ^ Patient was skipped due to counter in the file #798.3
"RTN","RORERR20",116,0)
 ;; -67 ^ 6 ^ No application acknowledgement for |2| day(s)
"RTN","RORERR20",117,0)
 ;; -68 ^ 6 ^ Illegal header of the HL7 message (or no header at all)
"RTN","RORERR20",118,0)
 ;; -69 ^ 6 ^ Cannot find the data element
"RTN","RORERR20",119,0)
 ;; -70 ^ 6 ^ Duplicate names of the data element
"RTN","RORERR20",120,0)
 ;; -71 ^ 1 ^ User entered the "^"
"RTN","RORERR20",121,0)
 ;; -72 ^ 6 ^ Timeout
"RTN","RORERR20",122,0)
 ;; -73 ^ 4 ^ Invalid or expired applic. acknowledgement was received
"RTN","RORERR20",123,0)
 ;; -74 ^ 6 ^ Number of messages in the batch does not match the BTS
"RTN","RORERR20",124,0)
 ;; -75 ^ 6 ^ Not all four HL7 encoding characters are defined
"RTN","RORERR20",125,0)
 ;; -76 ^ 6 ^ The [|2|] option must not be running during installation
"RTN","RORERR20",126,0)
 ;; -77 ^ 6 ^ Cannot create MailMan message stub
"RTN","RORERR20",127,0)
 ;; -78 ^ 6 ^ Scheduled subtasks have not been started by TaskMan
"RTN","ROREXPR")
0^26^B9187244
"RTN","ROREXPR",1,0)
ROREXPR ;HCIOFO/SG - PREPARATION FOR DATA EXTRACTION  ; 8/16/02 2:32pm
"RTN","ROREXPR",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","ROREXPR",3,0)
 ;
"RTN","ROREXPR",4,0)
 Q
"RTN","ROREXPR",5,0)
 ;
"RTN","ROREXPR",6,0)
 ;***** PREPARES VARIABLES FOR DATA EXTRACTION
"RTN","ROREXPR",7,0)
 ;
"RTN","ROREXPR",8,0)
 ; REGNAME       Registry name
"RTN","ROREXPR",9,0)
 ;
"RTN","ROREXPR",10,0)
 ; [DXBEG]       Data extraction start date (individual start
"RTN","ROREXPR",11,0)
 ;               date for each patient by default).
"RTN","ROREXPR",12,0)
 ;               Time part of the parameter value is ignored.
"RTN","ROREXPR",13,0)
 ;
"RTN","ROREXPR",14,0)
 ; [DXEND]       Data extraction end date (TODAY by default)
"RTN","ROREXPR",15,0)
 ;               Time part of the parameter value is ignored.
"RTN","ROREXPR",16,0)
 ;
"RTN","ROREXPR",17,0)
 ; DXBEG and DXEND parameters may be used only for historical data
"RTN","ROREXPR",18,0)
 ; extraction. Use of these parameters for regular data extraction
"RTN","ROREXPR",19,0)
 ; process will negatively affect the package!
"RTN","ROREXPR",20,0)
 ;
"RTN","ROREXPR",21,0)
 ; Return Values:
"RTN","ROREXPR",22,0)
 ;        0  Ok
"RTN","ROREXPR",23,0)
 ;       <0  Error code
"RTN","ROREXPR",24,0)
 ;
"RTN","ROREXPR",25,0)
PREPARE(REGNAME,DXBEG,DXEND) ;
"RTN","ROREXPR",26,0)
 N RORERRDL      ; Default error location
"RTN","ROREXPR",27,0)
 ;
"RTN","ROREXPR",28,0)
 N DTAREA,IL,IR,RC,REGIEN,RORMSG,SEGNAME,TMP
"RTN","ROREXPR",29,0)
 D DFLTLOC^RORERR("PREPARE^ROREXPR")
"RTN","ROREXPR",30,0)
 K RORLRC  F TMP="DXBEG","HL7","LD","MAXHL7SIZE"  K ROREXT(TMP)
"RTN","ROREXPR",31,0)
 S DXBEG=$G(DXBEG)\1,DXEND=$G(DXEND)\1
"RTN","ROREXPR",32,0)
 ;--- Data extraction period
"RTN","ROREXPR",33,0)
 S ROREXT("DXEND")=$S(DXEND>0:DXEND,1:$$DT^XLFDT)
"RTN","ROREXPR",34,0)
 I DXBEG>0  S RC=0  D  Q:RC<0 RC
"RTN","ROREXPR",35,0)
 . S ROREXT("DXBEG")=DXBEG  Q:DXBEG'>ROREXT("DXEND")
"RTN","ROREXPR",36,0)
 . S RC=$$ERROR^RORERR(-32,"PREPARE^ROREXPR",,,DXBEG,ROREXT("DXEND"))
"RTN","ROREXPR",37,0)
 ;--- Get the registry IEN and some parameters
"RTN","ROREXPR",38,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME,"7;10;13E;13.1;15.1",.RORBUF)
"RTN","ROREXPR",39,0)
 Q:REGIEN<0 REGIEN
"RTN","ROREXPR",40,0)
 S ROREXT("EXTRDAYS")=$G(RORBUF("DILIST","ID",1,7))
"RTN","ROREXPR",41,0)
 S ROREXT("HL7PROT")=$G(RORBUF("DILIST","ID",1,13))
"RTN","ROREXPR",42,0)
 ;--- Check the HL7 parameters
"RTN","ROREXPR",43,0)
 S RC=$$INIT^RORHL7()  Q:RC<0 RC
"RTN","ROREXPR",44,0)
 ;--- Load maximum message size and convert it into bytes
"RTN","ROREXPR",45,0)
 ;--- (1 Megabyte = 1024 Kb = 1024 * 1024 = 1048576 bytes)
"RTN","ROREXPR",46,0)
 S TMP=+$G(RORBUF("DILIST","ID",1,13.1))
"RTN","ROREXPR",47,0)
 S:TMP>0 ROREXT("MAXHL7SIZE")=(TMP*1048576)\1
"RTN","ROREXPR",48,0)
 ;--- Setup the lag interval (for regular data extraction only)
"RTN","ROREXPR",49,0)
 D:'$G(ROREXT("DXBEG"))
"RTN","ROREXPR",50,0)
 . S TMP=$G(RORBUF("DILIST","ID",1,15.1))
"RTN","ROREXPR",51,0)
 . S ROREXT("LD",1)=$S(TMP>0:TMP,1:1)
"RTN","ROREXPR",52,0)
 ;--- Setup the message builder call-back entry point
"RTN","ROREXPR",53,0)
 S TMP=$$TRIM^XLFSTR($G(RORBUF("DILIST","ID",1,10)))
"RTN","ROREXPR",54,0)
 I TMP'=""  D  Q:RC<0 $$ERROR^RORERR(-44,,REGNAME,,TMP)
"RTN","ROREXPR",55,0)
 . S RC=$$VERIFYEP^RORUTL01(TMP)
"RTN","ROREXPR",56,0)
 . S:RC'<0 ROREXT("MSGBLD")=TMP
"RTN","ROREXPR",57,0)
 ;--- Load and prepare segment descriptors
"RTN","ROREXPR",58,0)
 S TMP=","_REGIEN_","
"RTN","ROREXPR",59,0)
 D LIST^DIC(798.19,TMP,"@;.01;.02I;1",,,,,"B",,,,"RORMSG")
"RTN","ROREXPR",60,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.19,TMP)
"RTN","ROREXPR",61,0)
 S IR=""
"RTN","ROREXPR",62,0)
 F  S IR=$O(^TMP("DILIST",$J,"ID",IR))  Q:IR=""  D
"RTN","ROREXPR",63,0)
 . S SEGNAME=^TMP("DILIST",$J,"ID",IR,.01)
"RTN","ROREXPR",64,0)
 . S DTAREA=+$G(^TMP("DILIST",$J,"ID",IR,.02))
"RTN","ROREXPR",65,0)
 . S TMP=$G(^TMP("DILIST",$J,"ID",IR,1))
"RTN","ROREXPR",66,0)
 . S $P(ROREXT("HL7",DTAREA,SEGNAME),U,2)=TMP
"RTN","ROREXPR",67,0)
 ;--- Load list of codes of extracted Lab results
"RTN","ROREXPR",68,0)
 S TMP=","_REGIEN_","
"RTN","ROREXPR",69,0)
 D LIST^DIC(798.112,TMP,"@;.01;.02",,,,,"B",,,,"RORMSG")
"RTN","ROREXPR",70,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"PREPARE^ROREXPR",,798.112,TMP)
"RTN","ROREXPR",71,0)
 Q:'$G(^TMP("DILIST",$J,0)) 0
"RTN","ROREXPR",72,0)
 S (IL,IR,RC)=0
"RTN","ROREXPR",73,0)
 F  S IR=$O(^TMP("DILIST",$J,"ID",IR))  Q:IR=""  D  Q:RC
"RTN","ROREXPR",74,0)
 . S TMP=$G(^TMP("DILIST",$J,"ID",IR,.01))
"RTN","ROREXPR",75,0)
 . I TMP="*"  K RORLRC  S RORLRC="*",RC=1  Q
"RTN","ROREXPR",76,0)
 . I TMP>0  D  Q:RC<0  S IL=IL+1,RORLRC(IL)=TMP_"^LN"
"RTN","ROREXPR",77,0)
 . . S TMP=$$LNCODE^RORUTL02(TMP)  S:TMP<0 RC=TMP
"RTN","ROREXPR",78,0)
 . S TMP=$G(^TMP("DILIST",$J,"ID",IR,.02))
"RTN","ROREXPR",79,0)
 . S:TMP>0 IL=IL+1,RORLRC(IL)=TMP_"^NLT"
"RTN","ROREXPR",80,0)
 D CLEAN^DILF
"RTN","ROREXPR",81,0)
 Q $S(RC<0:RC,1:0)
"RTN","ROREXT")
0^25^B18842103
"RTN","ROREXT",1,0)
ROREXT ;HCIOFO/SG - DATA EXTRACT & TRANSMISSION ; 7/29/02 2:46pm
"RTN","ROREXT",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","ROREXT",3,0)
 ;
"RTN","ROREXT",4,0)
 ; ROREXT -------------- DATA EXTRACTION DESCRIPTOR
"RTN","ROREXT",5,0)
 ;
"RTN","ROREXT",6,0)
 ; ROREXT("DXBEG")       Start date of the data extraction (opt'l)
"RTN","ROREXT",7,0)
 ;                       If this node is defined and greater than
"RTN","ROREXT",8,0)
 ;                       zero, data extraction starts from this date
"RTN","ROREXT",9,0)
 ;                       (instead of individual start date for each
"RTN","ROREXT",10,0)
 ;                       patient in the registry).
"RTN","ROREXT",11,0)
 ; ROREXT("DXEND")       End date of the data extraction
"RTN","ROREXT",12,0)
 ;                       (these nodes are set by $$PREPARE^ROREXPR).
"RTN","ROREXT",13,0)
 ;
"RTN","ROREXT",14,0)
 ; ROREXT("EXTRDAYS")    Extraction period for a new patient
"RTN","ROREXT",15,0)
 ;
"RTN","ROREXT",16,0)
 ; ROREXT("HL7",
"RTN","ROREXT",17,0)
 ;   Data Area,          Data area where the segments are used
"RTN","ROREXT",18,0)
 ;                       (see the field .02 of the multiple 9 in the
"RTN","ROREXT",19,0)
 ;                       file #798.1)
"RTN","ROREXT",20,0)
 ;                          1  Patient
"RTN","ROREXT",21,0)
 ;                          2  Laboratory
"RTN","ROREXT",22,0)
 ;                          3  Pharmacy
"RTN","ROREXT",23,0)
 ;                          4  Radiology
"RTN","ROREXT",24,0)
 ;                          5  Inpatient
"RTN","ROREXT",25,0)
 ;                          6  Outpatient
"RTN","ROREXT",26,0)
 ;                          7  Pathology-Autopsy
"RTN","ROREXT",27,0)
 ;                          8  Pathology-Liver Biopsy
"RTN","ROREXT",28,0)
 ;     Segment Name)     HL7 segment descriptor
"RTN","ROREXT",29,0)
 ;                         ^1: reserved
"RTN","ROREXT",30,0)
 ;                         ^2: List of fields (separated by commas)
"RTN","ROREXT",31,0)
 ;                             that should be created in the segment.
"RTN","ROREXT",32,0)
 ;
"RTN","ROREXT",33,0)
 ; ROREXT("HL7CNT")      Counter of the messages in the batch
"RTN","ROREXT",34,0)
 ; ROREXT("HL7DT")       Date of the batch message creation (FileMan)
"RTN","ROREXT",35,0)
 ; ROREXT("HL7MID")      Message ID of the "stub" message
"RTN","ROREXT",36,0)
 ; ROREXT("HL7MTIEN")    IEN in the File #772 for the "stub" message
"RTN","ROREXT",37,0)
 ; ROREXT("HL7PROT")     Name of the event driver protocol
"RTN","ROREXT",38,0)
 ;
"RTN","ROREXT",39,0)
 ; ROREXT("HL7SIZE")     Current size of the HL7 batch
"RTN","ROREXT",40,0)
 ;                         ^1: Current size (in bytes)
"RTN","ROREXT",41,0)
 ;                         ^2: 1 if maximum size has been reached
"RTN","ROREXT",42,0)
 ;
"RTN","ROREXT",43,0)
 ; ROREXT("LD",
"RTN","ROREXT",44,0)
 ;   1)                  Number of lag days for the data extraction
"RTN","ROREXT",45,0)
 ;
"RTN","ROREXT",46,0)
 ; ROREXT("MAXHL7SIZE")  Maximum size (in bytes) of an HL7 message
"RTN","ROREXT",47,0)
 ;
"RTN","ROREXT",48,0)
 ; ROREXT("MSGBLD")      Message builder call-back entry point (opt'l)
"RTN","ROREXT",49,0)
 ;
"RTN","ROREXT",50,0)
 ; RORHL --------------- HL7 ENVIRONMENT VARIABLES
"RTN","ROREXT",51,0)
 ;
"RTN","ROREXT",52,0)
 ;                       This local array contains HL7 environment
"RTN","ROREXT",53,0)
 ;                       variables initialized by INIT^HLFNC2 ("FS",
"RTN","ROREXT",54,0)
 ;                       "ECH" and others).
"RTN","ROREXT",55,0)
 ;
"RTN","ROREXT",56,0)
 ; RORLRC -------------- LIST OF EXTRACTED LAB RESULTS
"RTN","ROREXT",57,0)
 ;
"RTN","ROREXT",58,0)
 ; RORLRC(               Either a list of codes of a Lab results to
"RTN","ROREXT",59,0)
 ;                       extract or "*" for all results (see the LA7SC
"RTN","ROREXT",60,0)
 ;                       parameter of the GCPR^LA7QRY entry point)
"RTN","ROREXT",61,0)
 ;   Seq#)               Lab result code
"RTN","ROREXT",62,0)
 ;                         ^1: Result code
"RTN","ROREXT",63,0)
 ;                         ^2: Coding system ("LN" or "NLT")
"RTN","ROREXT",64,0)
 ;
"RTN","ROREXT",65,0)
 Q
"RTN","ROREXT",66,0)
 ;
"RTN","ROREXT",67,0)
 ;***** PRINT SOME DEBUG INFORMATION
"RTN","ROREXT",68,0)
DEBUG1 ;
"RTN","ROREXT",69,0)
 D ZW^RORUTL01("ROREXT","Control Data")
"RTN","ROREXT",70,0)
 D ZW^RORUTL01("RORLRC","Lab Results to extract")
"RTN","ROREXT",71,0)
 W !,"Job number: ",$J,!
"RTN","ROREXT",72,0)
 Q
"RTN","ROREXT",73,0)
 ;
"RTN","ROREXT",74,0)
 ;***** EXTRACTS AND SENDS REGISTRY DATA
"RTN","ROREXT",75,0)
 ;
"RTN","ROREXT",76,0)
 ; REGNAME       Registry name
"RTN","ROREXT",77,0)
 ;
"RTN","ROREXT",78,0)
 ; [DXBEG]       Data extraction start date (individual start
"RTN","ROREXT",79,0)
 ;               date for each patient by default).
"RTN","ROREXT",80,0)
 ;               Time part of the parameter value is ignored.
"RTN","ROREXT",81,0)
 ;
"RTN","ROREXT",82,0)
 ; Return Values:
"RTN","ROREXT",83,0)
 ;       <0  Error Code (see MSGLIST^RORERR20)
"RTN","ROREXT",84,0)
 ;        0  Ok
"RTN","ROREXT",85,0)
 ;
"RTN","ROREXT",86,0)
EXTRACT(REGNAME,DXBEG) ;
"RTN","ROREXT",87,0)
 N RORERRDL      ; Default error location
"RTN","ROREXT",88,0)
 N ROREXT        ; Data extraction descriptor
"RTN","ROREXT",89,0)
 N RORHL         ; HL7 variables
"RTN","ROREXT",90,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","ROREXT",91,0)
 N RORLRC        ; List of codes of Lab results to be extracted
"RTN","ROREXT",92,0)
 ;
"RTN","ROREXT",93,0)
 N COUNTERS,MID,RC,REGLST,RGLIST,TMP
"RTN","ROREXT",94,0)
 D INIT^RORUTL01("ROREXT"),CLEAR^RORERR("EXTRACT^ROREXT")
"RTN","ROREXT",95,0)
 S RGLIST(REGNAME)=""
"RTN","ROREXT",96,0)
 ;--- Open a new log
"RTN","ROREXT",97,0)
 S TMP=$$SETUP^RORLOG(.RGLIST)
"RTN","ROREXT",98,0)
 S TMP=$$OPEN^RORLOG(.RGLIST,2,"DATA EXTRACTION STARTED")
"RTN","ROREXT",99,0)
 D
"RTN","ROREXT",100,0)
 . ;--- Create a list of active registries
"RTN","ROREXT",101,0)
 . S RC=$$ARLST^RORUTL02(.RGLIST,.REGLST)  Q:RC<0
"RTN","ROREXT",102,0)
 . I $D(REGLST)<10  D  Q
"RTN","ROREXT",103,0)
 . . S RC=$$ERROR^RORERR(-28,"EXTRACT^ROREXT",,,"extract data")
"RTN","ROREXT",104,0)
 . ;--- Lock parameters of the registries being processed
"RTN","ROREXT",105,0)
 . S RC=$$LOCKREG^RORUTL02(.REGLST,1)  Q:RC<0
"RTN","ROREXT",106,0)
 . I 'RC  D  Q
"RTN","ROREXT",107,0)
 . . S RC=$$ERROR^RORERR(-11,,,,"registries being processed")
"RTN","ROREXT",108,0)
 . ;--- Prepare data extraction rules
"RTN","ROREXT",109,0)
 . S RC=$$PREPARE^ROREXPR(REGNAME,$G(DXBEG))
"RTN","ROREXT",110,0)
 . I RC<0  S RC=$$ERROR^RORERR(-22)  Q
"RTN","ROREXT",111,0)
 . D:$G(RORPARM("DEBUG"))>1 DEBUG1
"RTN","ROREXT",112,0)
 . ;--- Extract registry data
"RTN","ROREXT",113,0)
 . S RC=$$PROCESS^ROREXT01(REGNAME)  Q:RC<0
"RTN","ROREXT",114,0)
 . S COUNTERS=RC,RC=0
"RTN","ROREXT",115,0)
 . ;--- Send the batch HL7 message
"RTN","ROREXT",116,0)
 . W:$G(RORPARM("DEBUG"))>1 !,"HL7 Batch ID:   ",$G(ROREXT("HL7MID"))
"RTN","ROREXT",117,0)
 . S RC=$$SEND^RORHL7(.MID)  Q:RC<0
"RTN","ROREXT",118,0)
 . I $G(MID)'=""  D  D LOG^RORLOG(2,TMP)
"RTN","ROREXT",119,0)
 . . S TMP="HL7 batch message "_MID_" has been generated"
"RTN","ROREXT",120,0)
 . ;--- Update registry parameters
"RTN","ROREXT",121,0)
 . S TMP=$$TMSTMP^ROREXTUT(.REGLST,$S('RC:$G(MID),1:""))
"RTN","ROREXT",122,0)
 ;
"RTN","ROREXT",123,0)
 ;--- Unlock parameters of processed registries
"RTN","ROREXT",124,0)
 S TMP=$$LOCKREG^RORUTL02(.REGLST,0)
"RTN","ROREXT",125,0)
 ;--- Statistics & Cleanup
"RTN","ROREXT",126,0)
 S TMP="DATA EXTRACTION "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","ROREXT",127,0)
 D CLOSE^RORLOG(TMP,$G(COUNTERS))
"RTN","ROREXT",128,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("ROREXT")
"RTN","ROREXT",129,0)
 Q $S(RC<0:RC,1:0)
"RTN","ROREXT",130,0)
 ;
"RTN","ROREXT",131,0)
 ;***** ENTRY POINT OF DATA EXTRACTION TASK
"RTN","ROREXT",132,0)
 ;
"RTN","ROREXT",133,0)
 ; RORREG        Registry name
"RTN","ROREXT",134,0)
 ;
"RTN","ROREXT",135,0)
TASK ;
"RTN","ROREXT",136,0)
 N RORERROR      ; Error processing data
"RTN","ROREXT",137,0)
 N RORPARM       ; Application parameters
"RTN","ROREXT",138,0)
 ;
"RTN","ROREXT",139,0)
 N RC
"RTN","ROREXT",140,0)
 ;--- Force "UNDEF" error if registry name is not defined
"RTN","ROREXT",141,0)
 I $G(RORREG)?." "  K RORREG  S RC=RORREG
"RTN","ROREXT",142,0)
 ;--- Initialize parameters
"RTN","ROREXT",143,0)
 ;S RORPARM("DEBUG")=1 ; Remove the first ';' to start in debug mode
"RTN","ROREXT",144,0)
 S RORPARM("ERR")=1
"RTN","ROREXT",145,0)
 ;--- Run the data extraction
"RTN","ROREXT",146,0)
 S RC=$$EXTRACT(RORREG)  S:RC<0 ZTSTOP=1
"RTN","ROREXT",147,0)
 I RC=-42  D ALERT^RORUTL01(RORREG,-42)  Q
"RTN","ROREXT",148,0)
 D:RC<0 ALERT^RORUTL01(RORREG,-43,,,,"data extraction")
"RTN","ROREXT",149,0)
 S ZTREQ="@"
"RTN","ROREXT",150,0)
 Q
"RTN","ROREXT01")
0^11^B13206150
"RTN","ROREXT01",1,0)
ROREXT01 ;HCIOFO/SG - EXTRACTION & TRANSMISSION PROCESS ; 8/14/02 7:46am
"RTN","ROREXT01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","ROREXT01",3,0)
 ;
"RTN","ROREXT01",4,0)
 Q
"RTN","ROREXT01",5,0)
 ;
"RTN","ROREXT01",6,0)
 ;***** SCANS THE REGISTRY AND EXTRACTS THE DATA
"RTN","ROREXT01",7,0)
 ;
"RTN","ROREXT01",8,0)
 ; REGNAME       Registry name
"RTN","ROREXT01",9,0)
 ;
"RTN","ROREXT01",10,0)
 ; Return Values:
"RTN","ROREXT01",11,0)
 ;       <0  Error Code
"RTN","ROREXT01",12,0)
 ;      >=0  Statistics
"RTN","ROREXT01",13,0)
 ;             ^1: Total number of processed patients
"RTN","ROREXT01",14,0)
 ;             ^2: Number of patients processed with errors
"RTN","ROREXT01",15,0)
 ;
"RTN","ROREXT01",16,0)
 ; In normal mode this function processes all patients and returns
"RTN","ROREXT01",17,0)
 ; total number of patients and number of patients processed with
"RTN","ROREXT01",18,0)
 ; errors.
"RTN","ROREXT01",19,0)
 ;
"RTN","ROREXT01",20,0)
 ; However, in debug mode 3 the function stops after the first
"RTN","ROREXT01",21,0)
 ; patient processed with error and returns an error code.
"RTN","ROREXT01",22,0)
 ;
"RTN","ROREXT01",23,0)
PROCESS(REGNAME) ;
"RTN","ROREXT01",24,0)
 N CNT,ECNT,IENS,IIEN,PATIEN,RC,REGIEN,ROOT,RORBUF,RORMSG
"RTN","ROREXT01",25,0)
 S ROOT=$$ROOT^DILFD(798,,1)
"RTN","ROREXT01",26,0)
 ;--- Get the registry IEN
"RTN","ROREXT01",27,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME,"2.4I",.RORBUF)
"RTN","ROREXT01",28,0)
 Q:REGIEN<0 REGIEN
"RTN","ROREXT01",29,0)
 ;--- Continue from the registry record that follows the last
"RTN","ROREXT01",30,0)
 ;    one processed by the previous data extraction if it hit
"RTN","ROREXT01",31,0)
 ;--- the maximum HL7 message size.
"RTN","ROREXT01",32,0)
 S IIEN=$G(RORBUF("DILIST","ID",1,2.4))
"RTN","ROREXT01",33,0)
 ;--- Loop through the patients of the registry
"RTN","ROREXT01",34,0)
 S (CNT,ECNT,RC)=0
"RTN","ROREXT01",35,0)
 F  S IIEN=$O(@ROOT@("AC",REGIEN,IIEN))  Q:IIEN=""  D  Q:RC
"RTN","ROREXT01",36,0)
 . ;--- Check if task stop has been requested
"RTN","ROREXT01",37,0)
 . I $D(ZTQUEUED),$$S^%ZTLOAD  D  Q
"RTN","ROREXT01",38,0)
 . . S RC=$$ERROR^RORERR(-42,"PROCESS^ROREXT01")
"RTN","ROREXT01",39,0)
 . ;--- Process the registry record
"RTN","ROREXT01",40,0)
 . S CNT=CNT+1
"RTN","ROREXT01",41,0)
 . I $G(RORPARM("DEBUG"))>1  W:$E($G(IOST),1,2)="C-" *13,CNT
"RTN","ROREXT01",42,0)
 . S RC=$$PROCREC(REGIEN,IIEN,.PATIEN)
"RTN","ROREXT01",43,0)
 . ;--- Process the error (if any)
"RTN","ROREXT01",44,0)
 . I RC<0  D  S:$G(RORPARM("DEBUG"))<3 RC=0  Q
"RTN","ROREXT01",45,0)
 . . S ECNT=ECNT+1
"RTN","ROREXT01",46,0)
 . . S RC=$$ERROR^RORERR(-15,"PROCESS^ROREXT01",,$G(PATIEN))
"RTN","ROREXT01",47,0)
 . ;--- Check size of the HL7 batch message
"RTN","ROREXT01",48,0)
 . S RC=$$ISMAXSZ^RORHL7()
"RTN","ROREXT01",49,0)
 Q:RC<0 RC
"RTN","ROREXT01",50,0)
 ;--- Record a message to the log if the data extraction has
"RTN","ROREXT01",51,0)
 ;--- hit the maximum HL7 message size.
"RTN","ROREXT01",52,0)
 I IIEN  K RORBUF  D  D LOG^RORLOG(2,RORBUF,,.RORBUF)
"RTN","ROREXT01",53,0)
 . S RORBUF="Size of the HL7 message has reached its upper limit"
"RTN","ROREXT01",54,0)
 . S RORBUF(1)="Remaining data will be sent next time."
"RTN","ROREXT01",55,0)
 ;--- Remember IEN of the last processed registry record if
"RTN","ROREXT01",56,0)
 ;    the data extraction has hit the maximum HL7 message size.
"RTN","ROREXT01",57,0)
 ;--- Otherwise, clear the LAST IEN EXTRACTED field.
"RTN","ROREXT01",58,0)
 K RORBUF  S IENS=REGIEN_","
"RTN","ROREXT01",59,0)
 S RORBUF(798.1,IENS,2.4)=$S(IIEN:IIEN,1:"@")
"RTN","ROREXT01",60,0)
 D FILE^DIE(,"RORBUF","RORMSG")
"RTN","ROREXT01",61,0)
 I $G(DIERR)  D  Q RC
"RTN","ROREXT01",62,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"PROCESS^ROREXT01",,798.1,IENS)
"RTN","ROREXT01",63,0)
 ;--- Return number of processed records and number of errors
"RTN","ROREXT01",64,0)
 Q CNT_U_ECNT
"RTN","ROREXT01",65,0)
 ;
"RTN","ROREXT01",66,0)
 ;***** PROCESS THE PATIENT'S RECORD IN THE REGISTRY
"RTN","ROREXT01",67,0)
 ;
"RTN","ROREXT01",68,0)
 ; REGIEN        Registry IEN
"RTN","ROREXT01",69,0)
 ; IIEN          IEN of the patient record in the registry
"RTN","ROREXT01",70,0)
 ; [.PATIEN]     Patient IEN is returned by this parameter
"RTN","ROREXT01",71,0)
 ;
"RTN","ROREXT01",72,0)
 ; Return Values:
"RTN","ROREXT01",73,0)
 ;       <0  Error Code
"RTN","ROREXT01",74,0)
 ;        0  Ok
"RTN","ROREXT01",75,0)
 ;
"RTN","ROREXT01",76,0)
PROCREC(REGIEN,IIEN,PATIEN) ;
"RTN","ROREXT01",77,0)
 N RORERRDL      ; Default error location
"RTN","ROREXT01",78,0)
 ;
"RTN","ROREXT01",79,0)
 N ENDT,IENS,MSHPTR,RC,RORFDA,RORMSG,RORMSH,SDT,TMP
"RTN","ROREXT01",80,0)
 D CLEAR^RORERR("PROCREC^ROREXT01")
"RTN","ROREXT01",81,0)
 S IENS=IIEN_",",PATIEN=0
"RTN","ROREXT01",82,0)
 ;--- Get the registry record data
"RTN","ROREXT01",83,0)
 D GETS^DIQ(798,IENS,".01;11","EI","RORFDA","RORMSG")
"RTN","ROREXT01",84,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","ROREXT01",85,0)
 S PATIEN=RORFDA(798,IENS,.01,"I")
"RTN","ROREXT01",86,0)
 ;--- Skip a record tagged as "DON'T SEND"
"RTN","ROREXT01",87,0)
 Q:$G(RORFDA(798,IENS,11,"I")) 0
"RTN","ROREXT01",88,0)
 ;--- Prepare extract dates
"RTN","ROREXT01",89,0)
 S RC=$$DXPERIOD^ROREXTUT(IIEN,.SDT,.ENDT)
"RTN","ROREXT01",90,0)
 I RC  Q:RC<0 RC  D:$G(RORPARM("DEBUG"))  Q 0
"RTN","ROREXT01",91,0)
 . S TMP="Data extraction period: '"_$G(SDT)_"-"_$G(ENDT)_"'"
"RTN","ROREXT01",92,0)
 . D LOG^RORLOG(4,"Nothing has been extracted",PATIEN,TMP)
"RTN","ROREXT01",93,0)
 ;--- Create HL7 message for the patient (if necessary)
"RTN","ROREXT01",94,0)
 S MSHPTR=$$CREATE^RORHL7(.RORMSH)  Q:MSHPTR<0 MSHPTR
"RTN","ROREXT01",95,0)
 I $G(ROREXT("MSGBLD"))'=""  D
"RTN","ROREXT01",96,0)
 . X "S RC="_ROREXT("MSGBLD")_"(IIEN,PATIEN,SDT,ENDT)"
"RTN","ROREXT01",97,0)
 E  S RC=$$MESSAGE^ROREXT02(IIEN,PATIEN,SDT,ENDT)
"RTN","ROREXT01",98,0)
 ;--- Store Message ID in the registry record if everything is Ok.
"RTN","ROREXT01",99,0)
 ;    Otherwise, delete an unfinished message from ^TMP("HLS",$J).
"RTN","ROREXT01",100,0)
 I 'RC,$O(^TMP("HLS",$J,""),-1)'=MSHPTR  D
"RTN","ROREXT01",101,0)
 . N FS  K RORFDA,RORMSG
"RTN","ROREXT01",102,0)
 . S FS=$E(RORMSH,4),IENS=IIEN_","
"RTN","ROREXT01",103,0)
 . S RORFDA(798,IENS,9.2)=ENDT
"RTN","ROREXT01",104,0)
 . S RORFDA(798,IENS,10)=$P(RORMSH,FS,10)
"RTN","ROREXT01",105,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","ROREXT01",106,0)
 . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,PATIEN,798,IENS)
"RTN","ROREXT01",107,0)
 E  D ROLLBACK^RORHL7(MSHPTR)
"RTN","ROREXT01",108,0)
 Q $S(RC<0:RC,1:0)
"RTN","ROREXT02")
0^37^B24985977
"RTN","ROREXT02",1,0)
ROREXT02 ;HCIOFO/SG - BODY OF A HL7 MESSAGE ; 8/21/02 1:37pm
"RTN","ROREXT02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","ROREXT02",3,0)
 ;
"RTN","ROREXT02",4,0)
 ; This routine uses the following IA's:
"RTN","ROREXT02",5,0)
 ;
"RTN","ROREXT02",6,0)
 ; #2171         The F4^XUFA4 procedure (supported)
"RTN","ROREXT02",7,0)
 Q
"RTN","ROREXT02",8,0)
 ;
"RTN","ROREXT02",9,0)
 ;***** EXTRACTS AND PREPARES LABORATORY DATA
"RTN","ROREXT02",10,0)
 ;
"RTN","ROREXT02",11,0)
 ; PATIEN        Patient IEN
"RTN","ROREXT02",12,0)
 ;
"RTN","ROREXT02",13,0)
 ; STDT          Extract from this date
"RTN","ROREXT02",14,0)
 ; ENDT          Extract until this date
"RTN","ROREXT02",15,0)
 ;
"RTN","ROREXT02",16,0)
 ; .PTR          Refefrence  to a local variable containing subscript
"RTN","ROREXT02",17,0)
 ;               of the last sub-node in the ^TMP("HLS",$J). Value of
"RTN","ROREXT02",18,0)
 ;               this parameter is updated by the function.
"RTN","ROREXT02",19,0)
 ;
"RTN","ROREXT02",20,0)
 ; [HDTMODE]     If this parameter is defined and non-zero, start and
"RTN","ROREXT02",21,0)
 ;               end dates are specimen collection dates. Otherwise,
"RTN","ROREXT02",22,0)
 ;               they are dates of the results.
"RTN","ROREXT02",23,0)
 ;
"RTN","ROREXT02",24,0)
 ; The function uses node ^TMP("RORTMP",$J) as a temporary storage.
"RTN","ROREXT02",25,0)
 ;
"RTN","ROREXT02",26,0)
 ; Return Values:
"RTN","ROREXT02",27,0)
 ;       <0  Error Code
"RTN","ROREXT02",28,0)
 ;        0  Ok
"RTN","ROREXT02",29,0)
 ;
"RTN","ROREXT02",30,0)
LABDATA(PATIEN,STDT,ENDT,PTR,HDTMODE) ;
"RTN","ROREXT02",31,0)
 N BUF,CS,FS,I,J,RC,RORTMP,SEG,SITE,TMP
"RTN","ROREXT02",32,0)
 S RORTMP=$NA(^TMP("RORTMP",$J))
"RTN","ROREXT02",33,0)
 ;--- Get the Lab results
"RTN","ROREXT02",34,0)
 S TMP=$S($G(HDTMODE):"^CD",1:"^RAD")
"RTN","ROREXT02",35,0)
 S RC=$$LABRSLTS^RORUTL02(PATIEN,STDT_TMP,ENDT_TMP)
"RTN","ROREXT02",36,0)
 Q:RC<0 RC
"RTN","ROREXT02",37,0)
 ;--- Extract separators from the MSH segment
"RTN","ROREXT02",38,0)
 S BUF=$G(@RORTMP@(1))
"RTN","ROREXT02",39,0)
 S:$E(BUF,1,3)="MSH" FS=$E(BUF,4),CS=$E(BUF,5)
"RTN","ROREXT02",40,0)
 S:$G(FS)="" FS="|"  S:$G(CS)="" CS="^"
"RTN","ROREXT02",41,0)
 ;--- Get the default station number and name
"RTN","ROREXT02",42,0)
 S SITE=$$SITE^RORUTL03(CS)
"RTN","ROREXT02",43,0)
 ;--- Add the results to the message
"RTN","ROREXT02",44,0)
 S I=0
"RTN","ROREXT02",45,0)
 F  S I=$O(@RORTMP@(I))  Q:I=""  D
"RTN","ROREXT02",46,0)
 . S BUF=@RORTMP@(I)
"RTN","ROREXT02",47,0)
 . ;--- Ignore unnecessary segments
"RTN","ROREXT02",48,0)
 . S SEG=$P(BUF,FS)  Q:'$D(ROREXT("HL7",2,SEG))
"RTN","ROREXT02",49,0)
 . ;--- Assemble the full segment
"RTN","ROREXT02",50,0)
 . S J=""
"RTN","ROREXT02",51,0)
 . F  S J=$O(@RORTMP@(I,J))  Q:J=""  S BUF=BUF_@RORTMP@(I,J)
"RTN","ROREXT02",52,0)
 . ;--- Replace the local station with the default one
"RTN","ROREXT02",53,0)
 . I SEG="OBX"  S:$P($P(BUF,FS,16),CS)="" $P(BUF,FS,16)=SITE
"RTN","ROREXT02",54,0)
 . ;--- Store the segment
"RTN","ROREXT02",55,0)
 . D SETSEG^RORHL7(.PTR,.BUF)
"RTN","ROREXT02",56,0)
 K @RORTMP
"RTN","ROREXT02",57,0)
 Q 0
"RTN","ROREXT02",58,0)
 ;
"RTN","ROREXT02",59,0)
 ;***** EXTRACTS PATIENT DATA AND CREATES A MESSAGE BODY
"RTN","ROREXT02",60,0)
 ;
"RTN","ROREXT02",61,0)
 ; RORIEN        IEN of the patient record in the registry
"RTN","ROREXT02",62,0)
 ; PATIEN        Patient IEN
"RTN","ROREXT02",63,0)
 ; STDT          Extract from this date (include)
"RTN","ROREXT02",64,0)
 ; ENDT          Extract until this date (do not include)
"RTN","ROREXT02",65,0)
 ; [HDTMODE]     This parameter is defined and non-zero during the
"RTN","ROREXT02",66,0)
 ;               historical data extraction.
"RTN","ROREXT02",67,0)
 ;
"RTN","ROREXT02",68,0)
 ; Return Values:
"RTN","ROREXT02",69,0)
 ;       <0  Error Code
"RTN","ROREXT02",70,0)
 ;        0  Ok
"RTN","ROREXT02",71,0)
 ;       >0  Nothing to send
"RTN","ROREXT02",72,0)
 ;
"RTN","ROREXT02",73,0)
MESSAGE(RORIEN,PATIEN,STDT,ENDT,HDTMODE) ;
"RTN","ROREXT02",74,0)
 N RORDEM        ; Update demographics
"RTN","ROREXT02",75,0)
 N RORFDA        ; Array containing values from the registry record
"RTN","ROREXT02",76,0)
 N RORLOC        ; Update local registry data
"RTN","ROREXT02",77,0)
 N RORPTR        ; Current subnode of the ^TMP("HLS",$J)
"RTN","ROREXT02",78,0)
 ;
"RTN","ROREXT02",79,0)
 N DATAPTR,DEMPTR,FIELDS,IENS,LOCPTR,RBPTR,RC,RORBUF,RORMSG
"RTN","ROREXT02",80,0)
 S IENS=RORIEN_","
"RTN","ROREXT02",81,0)
 ;--- Get the registry record data
"RTN","ROREXT02",82,0)
 D GETS^DIQ(798,IENS,"4;5","EI","RORFDA","RORMSG")
"RTN","ROREXT02",83,0)
 I $G(DIERR)  D  Q RC
"RTN","ROREXT02",84,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"MESSAGE^ROREXT02",PATIEN,798,IENS)
"RTN","ROREXT02",85,0)
 S RORDEM=+$G(RORFDA(798,IENS,4,"I"))
"RTN","ROREXT02",86,0)
 S RORLOC=+$G(RORFDA(798,IENS,5,"I"))
"RTN","ROREXT02",87,0)
 ;--- Initialize environment variables
"RTN","ROREXT02",88,0)
 S RC=$$INIT^RORHL7()  Q:RC<0 RC
"RTN","ROREXT02",89,0)
 S RORPTR=$O(^TMP("HLS",$J,""),-1)
"RTN","ROREXT02",90,0)
 ;--- Add patient data segments
"RTN","ROREXT02",91,0)
 S DEMPTR=RORPTR
"RTN","ROREXT02",92,0)
 S RC=$$PID^RORHL01(PATIEN,.RORPTR,HLFS,HLECH)  Q:RC<0 RC
"RTN","ROREXT02",93,0)
 I RORDEM  D  Q:RC<0 RC
"RTN","ROREXT02",94,0)
 . I $D(ROREXT("HL7",1,"ZSP"))  D  Q:RC<0      ; Period of Servise
"RTN","ROREXT02",95,0)
 . . S RC=$$ZSP^RORHL01(PATIEN,.RORPTR,HLFS,HLECH)
"RTN","ROREXT02",96,0)
 . I $D(ROREXT("HL7",1,"ZRD"))  D  Q:RC<0      ; Rated Disabilities
"RTN","ROREXT02",97,0)
 . . S RC=$$ZRD^RORHL01(PATIEN,.RORPTR,HLFS,HLECH)
"RTN","ROREXT02",98,0)
 ;--- Add local registry data segments
"RTN","ROREXT02",99,0)
 S LOCPTR=RORPTR
"RTN","ROREXT02",100,0)
 I $D(ROREXT("HL7",1,"CSR"))  D  Q:RC<0 RC
"RTN","ROREXT02",101,0)
 . S FIELDS=$P(ROREXT("HL7",1,"CSR"),U,2)
"RTN","ROREXT02",102,0)
 . S RC=$$CSR^RORHL02(IENS,FIELDS,.RORPTR,HLFS,HLECH)
"RTN","ROREXT02",103,0)
 I $D(ROREXT("HL7",1,"CSP"))  D  Q:RC<0 RC
"RTN","ROREXT02",104,0)
 . S FIELDS=$P(ROREXT("HL7",1,"CSP"),U,2)
"RTN","ROREXT02",105,0)
 . S RC=$$CSP^RORHL02(IENS,FIELDS,.RORPTR,HLFS,HLECH)
"RTN","ROREXT02",106,0)
 I $D(ROREXT("HL7",1,"CSS"))  D  Q:RC<0 RC
"RTN","ROREXT02",107,0)
 . S FIELDS=$P(ROREXT("HL7",1,"CSS"),U,2)
"RTN","ROREXT02",108,0)
 . S RC=$$CSS^RORHL02(IENS,FIELDS,.RORPTR,HLFS,HLECH)
"RTN","ROREXT02",109,0)
 ;--- Add encounter data segments
"RTN","ROREXT02",110,0)
 S DATAPTR=RORPTR
"RTN","ROREXT02",111,0)
 I $D(ROREXT("HL7",3))>1  D  Q:RC<0 RC        ; Pharmacy
"RTN","ROREXT02",112,0)
 . S RC=$$EN1^RORHL03(PATIEN,STDT,ENDT,.RORPTR,,HLFS,HLECH)
"RTN","ROREXT02",113,0)
 I $D(ROREXT("HL7",4))>1  D  Q:RC<0 RC        ; Radiology
"RTN","ROREXT02",114,0)
 . S RC=$$EN1^RORHL04(PATIEN,STDT,ENDT,.RORPTR,,HLFS,HLECH)
"RTN","ROREXT02",115,0)
 I $D(ROREXT("HL7",7))>1  D  Q:RC<0 RC        ; Autopsy
"RTN","ROREXT02",116,0)
 . S RC=$$EN1^RORHL05(PATIEN,.RORPTR,,HLFS,HLECH)
"RTN","ROREXT02",117,0)
 I $D(ROREXT("HL7",8))>1  D  Q:RC<0 RC        ; Liver Biopsy
"RTN","ROREXT02",118,0)
 . S RC=$$EN1^RORHL06(PATIEN,STDT,ENDT,.RORPTR,,HLFS,HLECH)
"RTN","ROREXT02",119,0)
 ;--- Add Lab data
"RTN","ROREXT02",120,0)
 I $D(ROREXT("HL7",2))>1  D  Q:RC<0 RC
"RTN","ROREXT02",121,0)
 . S RC=$$LABDATA(PATIEN,STDT,ENDT,.RORPTR,+$G(HDTMODE))
"RTN","ROREXT02",122,0)
 ;--- Analyze structure of the message
"RTN","ROREXT02",123,0)
 S RC=0
"RTN","ROREXT02",124,0)
 I RORPTR'>DATAPTR  D
"RTN","ROREXT02",125,0)
 . S RBPTR=RORPTR
"RTN","ROREXT02",126,0)
 . ;--- Do not send local registry data segments if the UPDATE LOCAL
"RTN","ROREXT02",127,0)
 . ;    REGISTRY DATA flag is not set and there is no other
"RTN","ROREXT02",128,0)
 . ;    VistA data to be sent
"RTN","ROREXT02",129,0)
 . I 'RORLOC!(RORPTR'>LOCPTR)  S RBPTR=LOCPTR  D
"RTN","ROREXT02",130,0)
 . . ;--- Do not send a message containing only the PID segment
"RTN","ROREXT02",131,0)
 . . ;    if the UPDATE DEMOGRAPHICS flag is not set
"RTN","ROREXT02",132,0)
 . . S:'RORDEM RBPTR=DEMPTR
"RTN","ROREXT02",133,0)
 . ;--- Delete unnecessary segments
"RTN","ROREXT02",134,0)
 . F  Q:RORPTR'>RBPTR  D  S RORPTR=$O(^TMP("HLS",$J,RORPTR),-1)
"RTN","ROREXT02",135,0)
 . . K ^TMP("HLS",$J,RORPTR)
"RTN","ROREXT02",136,0)
 . S RC=RORPTR'>DEMPTR
"RTN","ROREXT02",137,0)
 Q RC
"RTN","ROREXTUT")
0^12^B17198030
"RTN","ROREXTUT",1,0)
ROREXTUT ;HCIOFO/SG - DATA EXTRACT UTILITIES  ; 7/11/02 8:03am
"RTN","ROREXTUT",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","ROREXTUT",3,0)
 ;
"RTN","ROREXTUT",4,0)
 Q
"RTN","ROREXTUT",5,0)
 ;
"RTN","ROREXTUT",6,0)
 ;***** CHECKS ACKNOWLEDGEMENT FLAG OF THE REGISTRY
"RTN","ROREXTUT",7,0)
 ;
"RTN","ROREXTUT",8,0)
 ; REGNAME       Registry name
"RTN","ROREXTUT",9,0)
 ;
"RTN","ROREXTUT",10,0)
 ; Return Values:
"RTN","ROREXTUT",11,0)
 ;       <0  Error Code
"RTN","ROREXTUT",12,0)
 ;        0  Ok
"RTN","ROREXTUT",13,0)
 ;        1  The acknowledgement flag is set
"RTN","ROREXTUT",14,0)
 ;
"RTN","ROREXTUT",15,0)
ACKWAIT(REGNAME) ;
"RTN","ROREXTUT",16,0)
 N REGIEN,RC,TMP
"RTN","ROREXTUT",17,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)  Q:REGIEN<0 REGIEN
"RTN","ROREXTUT",18,0)
 S TMP=+$$GET1^DIQ(798.1,REGIEN_",",2.2,"I",,"RORMSG")
"RTN","ROREXTUT",19,0)
 I $G(DIERR)  D  Q RC
"RTN","ROREXTUT",20,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"ACKWAIT^ROREXTUT",,798.1,REGIEN)
"RTN","ROREXTUT",21,0)
 Q TMP
"RTN","ROREXTUT",22,0)
 ;
"RTN","ROREXTUT",23,0)
 ;***** RETURNS A DATA EXTRACTION PERIOD FOR THE PATIENT
"RTN","ROREXTUT",24,0)
 ;
"RTN","ROREXTUT",25,0)
 ; IEN           IEN of the patient record in the registry
"RTN","ROREXTUT",26,0)
 ; .SDT          Start date of the data extraction (output)
"RTN","ROREXTUT",27,0)
 ; .EDT          End date of the data extraction (output)
"RTN","ROREXTUT",28,0)
 ;
"RTN","ROREXTUT",29,0)
 ; Return Values:
"RTN","ROREXTUT",30,0)
 ;        <0  Error Code
"RTN","ROREXTUT",31,0)
 ;         0  Ok
"RTN","ROREXTUT",32,0)
 ;        >0  Skip the patient
"RTN","ROREXTUT",33,0)
 ;
"RTN","ROREXTUT",34,0)
 ; If the special extraction start date for all patients is defined
"RTN","ROREXTUT",35,0)
 ; then it is returned as a value of the SDT parameter. Usually,
"RTN","ROREXTUT",36,0)
 ; this mode is not used. ;-)
"RTN","ROREXTUT",37,0)
 ;
"RTN","ROREXTUT",38,0)
 ; If the field #9.1 of the patient record in the registry (#798)
"RTN","ROREXTUT",39,0)
 ; has a value then this value is returned (data have already been
"RTN","ROREXTUT",40,0)
 ; extracted until that date). Usually, this field should be empty
"RTN","ROREXTUT",41,0)
 ; for new patients.
"RTN","ROREXTUT",42,0)
 ;
"RTN","ROREXTUT",43,0)
 ; The function tries to get the earliest date when a selection rule
"RTN","ROREXTUT",44,0)
 ; has been triggered for the newly added patient. If the patient has
"RTN","ROREXTUT",45,0)
 ; been added manually and there are no selection rules in the
"RTN","ROREXTUT",46,0)
 ; SELECTION RULE multiple of the registry record then a date when
"RTN","ROREXTUT",47,0)
 ; the patient was added to the registry is used.
"RTN","ROREXTUT",48,0)
 ;
"RTN","ROREXTUT",49,0)
 ; After that, extract period for new patients (value of the field
"RTN","ROREXTUT",50,0)
 ; #7 of the file #798.1) is subtracted from the date and the result
"RTN","ROREXTUT",51,0)
 ; is returned. If the extract period is not set for the registry,
"RTN","ROREXTUT",52,0)
 ; a default value (365) is used.
"RTN","ROREXTUT",53,0)
 ;
"RTN","ROREXTUT",54,0)
DXPERIOD(IEN,SDT,EDT) ;
"RTN","ROREXTUT",55,0)
 N DTENT,IENS,INCTVDT,LCH,NEWPAT,RC,RORBUF,RORMSG,TMP
"RTN","ROREXTUT",56,0)
 S (EDT,SDT)="",IENS=IEN_",",LCH=0
"RTN","ROREXTUT",57,0)
 ;--- Get the registry record data
"RTN","ROREXTUT",58,0)
 D GETS^DIQ(798,IENS,"1;2;3;4;5;8;9.1","EI","RORBUF","RORMSG")
"RTN","ROREXTUT",59,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"DXPERIOD^ROREXTUT",,798,IENS)
"RTN","ROREXTUT",60,0)
 S EDT=$$FMADD^XLFDT(ROREXT("DXEND"),-$G(ROREXT("LD",1)))
"RTN","ROREXTUT",61,0)
 F TMP=3,4,5  S:$G(RORBUF(798,IENS,TMP,"I")) LCH=1
"RTN","ROREXTUT",62,0)
 ;--- Data is not extracted after the inactivation date
"RTN","ROREXTUT",63,0)
 I '$G(RORBUF(798,IENS,8,"E"))  D  S:EDT>INCTVDT EDT=INCTVDT
"RTN","ROREXTUT",64,0)
 . S INCTVDT=$G(RORBUF(798,IENS,2,"I"))\1
"RTN","ROREXTUT",65,0)
 ;--- Special start date for ALL patients (if defined)
"RTN","ROREXTUT",66,0)
 S SDT=$G(ROREXT("DXBEG"))
"RTN","ROREXTUT",67,0)
 I SDT'>0  D
"RTN","ROREXTUT",68,0)
 . ;--- Start date from the patient's record in the registry
"RTN","ROREXTUT",69,0)
 . S SDT=$G(RORBUF(798,IENS,9.1,"I"))\1  Q:SDT>0
"RTN","ROREXTUT",70,0)
 . ;--- Determine the start date for a newly added patient
"RTN","ROREXTUT",71,0)
 . S DTENT=$G(RORBUF(798,IENS,1,"I"))
"RTN","ROREXTUT",72,0)
 . S NEWPAT=+$G(RORBUF(798,IENS,3,"I"))
"RTN","ROREXTUT",73,0)
 . I (NEWPAT=1)!(NEWPAT=2)  D
"RTN","ROREXTUT",74,0)
 . . S TMP=$$ROOT^DILFD(798.01,","_IENS,1)  Q:TMP=""
"RTN","ROREXTUT",75,0)
 . . S SDT=$O(@TMP@("AD","")) ; The earliest selection rule
"RTN","ROREXTUT",76,0)
 . . I SDT'>0  S SDT=DTENT  Q:SDT'>0
"RTN","ROREXTUT",77,0)
 . . S TMP=+$G(ROREXT("EXTRDAYS"))
"RTN","ROREXTUT",78,0)
 . . S SDT=$$FMADD^XLFDT(SDT,-$S(TMP>0:TMP,1:365))\1
"RTN","ROREXTUT",79,0)
 . S:SDT'>0 SDT=DTENT\1
"RTN","ROREXTUT",80,0)
 ;--- Check the dates
"RTN","ROREXTUT",81,0)
 I (SDT'>0)!(EDT'>0)  D  Q RC
"RTN","ROREXTUT",82,0)
 . S TMP=$$GET1^DIQ(798,IENS,.01,"I",,"RORMSG")
"RTN","ROREXTUT",83,0)
 . S RC=$$ERROR^RORERR(-32,"DXPERIOD^ROREXTUT",,TMP,SDT,EDT)
"RTN","ROREXTUT",84,0)
 Q:SDT<EDT 0
"RTN","ROREXTUT",85,0)
 I LCH  S SDT=EDT  Q 0
"RTN","ROREXTUT",86,0)
 Q 1
"RTN","ROREXTUT",87,0)
 ;
"RTN","ROREXTUT",88,0)
 ;***** UPDATES DATA EXTRACTION PARAMETERS OF THE REGISTRY
"RTN","ROREXTUT",89,0)
 ;
"RTN","ROREXTUT",90,0)
 ; .REGLST       Reference to a local array containing registry names
"RTN","ROREXTUT",91,0)
 ;               as subscripts and optional registry IENs as values
"RTN","ROREXTUT",92,0)
 ; MID           Batch message ID returned by the GENERATE^HLMA
"RTN","ROREXTUT",93,0)
 ;
"RTN","ROREXTUT",94,0)
 ; Return values:
"RTN","ROREXTUT",95,0)
 ;       <0  Error code
"RTN","ROREXTUT",96,0)
 ;        0  Ok
"RTN","ROREXTUT",97,0)
 ;
"RTN","ROREXTUT",98,0)
TMSTMP(REGLST,MID) ;
"RTN","ROREXTUT",99,0)
 N DATE,RC,REGIEN,REGIENS,REGNAME,RORFDA,RORMSG
"RTN","ROREXTUT",100,0)
 S DATE=ROREXT("DXEND")\1
"RTN","ROREXTUT",101,0)
 S REGNAME="",RC=0
"RTN","ROREXTUT",102,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","ROREXTUT",103,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","ROREXTUT",104,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=+REGIEN  Q
"RTN","ROREXTUT",105,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","ROREXTUT",106,0)
 . S REGIENS=REGIEN_","
"RTN","ROREXTUT",107,0)
 . ;--- Check if the new date until that data are extracted is
"RTN","ROREXTUT",108,0)
 . ;    greater than that stored in the registry parameters
"RTN","ROREXTUT",109,0)
 . S TMP=$$GET1^DIQ(798.1,REGIENS,2,"I",,"RORMSG")
"RTN","ROREXTUT",110,0)
 . I $G(DIERR)  D  Q
"RTN","ROREXTUT",111,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"TMSTMP^ROREXTUT",,798.1,REGIENS)
"RTN","ROREXTUT",112,0)
 . S:DATE>TMP RORFDA(798.1,REGIENS,2)=DATE
"RTN","ROREXTUT",113,0)
 . ;--- Update the Last Batch info only if something has been sent
"RTN","ROREXTUT",114,0)
 . D:$G(MID)'=""
"RTN","ROREXTUT",115,0)
 . . S RORFDA(798.1,REGIENS,2.1)=$G(ROREXT("HL7MID"))
"RTN","ROREXTUT",116,0)
 . . S RORFDA(798.1,REGIENS,2.2)=$$NOW^XLFDT
"RTN","ROREXTUT",117,0)
 . . S RORFDA(798.1,REGIENS,2.3)=MID
"RTN","ROREXTUT",118,0)
 . ;--- Update registry parameters
"RTN","ROREXTUT",119,0)
 . Q:$D(RORFDA)<10
"RTN","ROREXTUT",120,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","ROREXTUT",121,0)
 . I $G(DIERR)  D  Q
"RTN","ROREXTUT",122,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"TMSTMP^ROREXTUT",,798.1,REGIENS)
"RTN","ROREXTUT",123,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORHDT02")
0^13^B3597415
"RTN","RORHDT02",1,0)
RORHDT02 ;HCIOFO/SG - CREATE EXTRACTION TASK RECORDS ; 7/12/02 9:04am
"RTN","RORHDT02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORHDT02",3,0)
 ;
"RTN","RORHDT02",4,0)
 Q
"RTN","RORHDT02",5,0)
 ;
"RTN","RORHDT02",6,0)
 ;***** (RE)CREATES THE TASK TABLE
"RTN","RORHDT02",7,0)
 ;
"RTN","RORHDT02",8,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT02",9,0)
 ; [NTSK]        Number of tasks to create
"RTN","RORHDT02",10,0)
 ;
"RTN","RORHDT02",11,0)
 ; Return Values:
"RTN","RORHDT02",12,0)
 ;       <0  Error code
"RTN","RORHDT02",13,0)
 ;        0  Ok
"RTN","RORHDT02",14,0)
 ;        1  Timeout or "^"
"RTN","RORHDT02",15,0)
 ;
"RTN","RORHDT02",16,0)
CREATE(REGIEN,NTSK) ;
"RTN","RORHDT02",17,0)
 N FNAME,HIGHIEN,I,IDL,IENS,LOWIEN,NRE,RORFDA,RORMSG,RRIEN,UI
"RTN","RORHDT02",18,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,X,Y
"RTN","RORHDT02",19,0)
 S X=$P($$SITE^VASITE(),U,3),FNAME="S"_$E(X,1,3)_"T"
"RTN","RORHDT02",20,0)
 S UI='$G(NTSK)
"RTN","RORHDT02",21,0)
 ;--- Count number of records in the registry
"RTN","RORHDT02",22,0)
 W:UI !,"Calculating size of the registry ..."
"RTN","RORHDT02",23,0)
 S NRE=$$REGSIZE^RORUTL02(REGIEN,.LOWIEN,.HIGHIEN)
"RTN","RORHDT02",24,0)
 W:UI *13,"Number of patients in the registry: ",NRE,!
"RTN","RORHDT02",25,0)
 ;--- Ask for a number of data extraction tasks if the registry con-
"RTN","RORHDT02",26,0)
 ;    tains more than 1000 patients. Otherwise, create a single task.
"RTN","RORHDT02",27,0)
 S DIR("A")="Number of data extraction tasks"
"RTN","RORHDT02",28,0)
 I UI,NRE>1000  D  Q:$D(DIRUT) 1  S NTSK=+Y
"RTN","RORHDT02",29,0)
 . S DIR(0)="N^1:12:0"
"RTN","RORHDT02",30,0)
 . S DIR("B")="1"
"RTN","RORHDT02",31,0)
 . D ^DIR  W !
"RTN","RORHDT02",32,0)
 E  S:'$G(NTSK) NTSK=1  W:UI DIR("A")_": ",NTSK,!
"RTN","RORHDT02",33,0)
 ;--- Prepare records in the FDA.
"RTN","RORHDT02",34,0)
 ;    Use 1 instead of LOWIEN as a start value of the RRIEN so that
"RTN","RORHDT02",35,0)
 ;    no records will be missed (just in case)
"RTN","RORHDT02",36,0)
 S RRIEN=1,IDL=(HIGHIEN-LOWIEN)\NTSK,RC=0
"RTN","RORHDT02",37,0)
 S:IDL'>0 NTSK=1
"RTN","RORHDT02",38,0)
 F I=1:1:NTSK  D
"RTN","RORHDT02",39,0)
 . S IENS="+"_I_","
"RTN","RORHDT02",40,0)
 . S RORFDA(798.5,IENS,.01)=RRIEN
"RTN","RORHDT02",41,0)
 . S RORFDA(798.5,IENS,.02)=REGIEN
"RTN","RORHDT02",42,0)
 . S RORFDA(798.5,IENS,1.01)=FNAME_$TR($J(I,2)," ","0")_".HDT"
"RTN","RORHDT02",43,0)
 . S RRIEN=LOWIEN+(I*IDL)
"RTN","RORHDT02",44,0)
 ;--- Ask for the final confirmation
"RTN","RORHDT02",45,0)
 I UI  D  Q:$D(DIRUT)!'$G(Y) 1
"RTN","RORHDT02",46,0)
 . S DIR(0)="Y"
"RTN","RORHDT02",47,0)
 . S DIR("A")="Create the new task table"
"RTN","RORHDT02",48,0)
 . S DIR("B")="NO"
"RTN","RORHDT02",49,0)
 . D ^DIR  W !
"RTN","RORHDT02",50,0)
 ;--- Create the new task table
"RTN","RORHDT02",51,0)
 S RC=$$CLRTTBL^RORHDTUT(REGIEN)  Q:RC<0 RC
"RTN","RORHDT02",52,0)
 D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORHDT02",53,0)
 Q $$DBS^RORERR("RORMSG",-9,"CREATE^RORHDT02")
"RTN","RORHDT03")
0^1^B23692464
"RTN","RORHDT03",1,0)
RORHDT03 ;HCIOFO/SG - MANIPULATIONS WITH EXTRACTION TASKS ; 7/10/02 9:05am
"RTN","RORHDT03",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORHDT03",3,0)
 ;
"RTN","RORHDT03",4,0)
 Q
"RTN","RORHDT03",5,0)
 ;
"RTN","RORHDT03",6,0)
 ;***** CHECKS FOR A STOP REQUESTS (TASKMAN & PROPRIETARY)
"RTN","RORHDT03",7,0)
 ;
"RTN","RORHDT03",8,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT03",9,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT03",10,0)
 ;
"RTN","RORHDT03",11,0)
 ; Return Values:
"RTN","RORHDT03",12,0)
 ;        0  Continue running
"RTN","RORHDT03",13,0)
 ;        1  Stop the task
"RTN","RORHDT03",14,0)
 ;
"RTN","RORHDT03",15,0)
CHKSTOP(REGIEN,TASKIEN) ;
"RTN","RORHDT03",16,0)
 S ZTSTOP=$G(^XTMP("RORHDT"_REGIEN,"T",TASKIEN))!$$S^%ZTLOAD
"RTN","RORHDT03",17,0)
 Q ZTSTOP
"RTN","RORHDT03",18,0)
 ;
"RTN","RORHDT03",19,0)
 ;***** STARTS THE DATA EXTRACTION TASK
"RTN","RORHDT03",20,0)
 ;
"RTN","RORHDT03",21,0)
 ; RORREG        Registry IEN
"RTN","RORHDT03",22,0)
 ; RORTASK       Task IEN
"RTN","RORHDT03",23,0)
 ; RORFAM        File Access Mode:
"RTN","RORHDT03",24,0)
 ;                 "A"  Append new messages to the file
"RTN","RORHDT03",25,0)
 ;                 "O"  Overwrite the file
"RTN","RORHDT03",26,0)
 ;                 "N"  Modify file name and create a new file
"RTN","RORHDT03",27,0)
 ; [ZTDTH]       Start date/time
"RTN","RORHDT03",28,0)
 ;
"RTN","RORHDT03",29,0)
 ; Return Values:
"RTN","RORHDT03",30,0)
 ;       <0  Error code
"RTN","RORHDT03",31,0)
 ;        0  Ok
"RTN","RORHDT03",32,0)
 ;        1  Start time has not been entered
"RTN","RORHDT03",33,0)
 ;        2  Already running or pending
"RTN","RORHDT03",34,0)
 ;
"RTN","RORHDT03",35,0)
START(RORREG,RORTASK,RORFAM,ZTDTH) ;
"RTN","RORHDT03",36,0)
 N I,RC,RORDUZ,RORMSG,STATUS,TASKNUM
"RTN","RORHDT03",37,0)
 N ZTCPU,ZTDESC,ZTIO,ZTKIL,ZTPRI,ZTRTN,ZTSAVE,ZTSK,ZTSYNC,ZTUCI
"RTN","RORHDT03",38,0)
 ;--- Uncomment the next line of code if you want that an alert
"RTN","RORHDT03",39,0)
 ;    to be sent to initiator of a task upon its completion
"RTN","RORHDT03",40,0)
 S RORDUZ=$G(DUZ)
"RTN","RORHDT03",41,0)
 ;--- Get a name of the registry
"RTN","RORHDT03",42,0)
 S $P(RORREG,U,2)=$$GET1^DIQ(798.1,RORREG_",",.01,,,"RORMSG")
"RTN","RORHDT03",43,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"START^RORHDT03",,798.1,RORREG)
"RTN","RORHDT03",44,0)
 ;--- Check status of the task
"RTN","RORHDT03",45,0)
 S STATUS=+$$STATUS^RORHDTUT(+RORREG,RORTASK,3)
"RTN","RORHDT03",46,0)
 Q:(STATUS=1)!(STATUS=2) 2
"RTN","RORHDT03",47,0)
 ;--- Start/schedule the task
"RTN","RORHDT03",48,0)
 S ZTRTN="TASK^RORHDT03",ZTIO=""
"RTN","RORHDT03",49,0)
 S ZTDESC="Historical data extraction"
"RTN","RORHDT03",50,0)
 F I="RORDUZ","RORFAM","RORREG","RORTASK"  S ZTSAVE(I)=""
"RTN","RORHDT03",51,0)
 D ^%ZTLOAD  S TASKNUM=$G(ZTSK)
"RTN","RORHDT03",52,0)
 ;--- Update task number
"RTN","RORHDT03",53,0)
 S RC=$$UPDTASK(+RORREG,RORTASK,TASKNUM,"","")
"RTN","RORHDT03",54,0)
 Q $S(TASKNUM:RC,1:1)
"RTN","RORHDT03",55,0)
 ;
"RTN","RORHDT03",56,0)
 ;***** STOPS THE DATA EXTRACTION TASK
"RTN","RORHDT03",57,0)
 ;
"RTN","RORHDT03",58,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT03",59,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT03",60,0)
 ;
"RTN","RORHDT03",61,0)
 ; Return Values:
"RTN","RORHDT03",62,0)
 ;       <0  Error code
"RTN","RORHDT03",63,0)
 ;        0  Ok
"RTN","RORHDT03",64,0)
 ;
"RTN","RORHDT03",65,0)
STOP(REGIEN,TASKIEN) ;
"RTN","RORHDT03",66,0)
 N IENS,RC,STATUS,ZTSK
"RTN","RORHDT03",67,0)
 ;--- Get status of the task
"RTN","RORHDT03",68,0)
 S STATUS=+$$STATUS^RORHDTUT(REGIEN,TASKIEN)
"RTN","RORHDT03",69,0)
 ;--- If task is pending, deque it
"RTN","RORHDT03",70,0)
 I STATUS=1  D  Q RC
"RTN","RORHDT03",71,0)
 . S IENS=TASKIEN_","
"RTN","RORHDT03",72,0)
 . S ZTSK=$$GET1^DIQ(798.5,IENS,2.01,,,"RORMSG")
"RTN","RORHDT03",73,0)
 . I $G(DIERR)  D  Q
"RTN","RORHDT03",74,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"STOP^RORHDT03",,798.5,IENS)
"RTN","RORHDT03",75,0)
 . D DQ^%ZTLOAD
"RTN","RORHDT03",76,0)
 . S RC=$S('$G(ZTSK(0)):$$ERROR^RORERR(-33,"STOP^RORHDT03"),1:0)
"RTN","RORHDT03",77,0)
 ;--- If task is running, stop it
"RTN","RORHDT03",78,0)
 I STATUS=2  S ^XTMP("RORHDT"_REGIEN,"T",TASKIEN)=1  Q 0
"RTN","RORHDT03",79,0)
 Q 0
"RTN","RORHDT03",80,0)
 ;
"RTN","RORHDT03",81,0)
 ;***** HISTORICAL DATA EXTRACTION TASK
"RTN","RORHDT03",82,0)
 ;
"RTN","RORHDT03",83,0)
 ; [RORDUZ]      DUZ of a task initiator.
"RTN","RORHDT03",84,0)
 ;               If this variable is defined and greater than zero,
"RTN","RORHDT03",85,0)
 ;               an alert is sent to initiator of a task upon the
"RTN","RORHDT03",86,0)
 ;               task completion.
"RTN","RORHDT03",87,0)
 ;
"RTN","RORHDT03",88,0)
 ; RORFAM        File Access Mode:
"RTN","RORHDT03",89,0)
 ;                 "A"  Append new messages to the file
"RTN","RORHDT03",90,0)
 ;                 "O"  Overwrite the file
"RTN","RORHDT03",91,0)
 ;                 "N"  Modify file name and create a new file
"RTN","RORHDT03",92,0)
 ;
"RTN","RORHDT03",93,0)
 ; RORREG        Registry to process
"RTN","RORHDT03",94,0)
 ;                 ^1: Registry IEN
"RTN","RORHDT03",95,0)
 ;                 ^2: Registry Name
"RTN","RORHDT03",96,0)
 ;
"RTN","RORHDT03",97,0)
 ; RORTASK       IEN of the data extraction task in the ROR HDT
"RTN","RORHDT03",98,0)
 ;               TASK file
"RTN","RORHDT03",99,0)
 ;
"RTN","RORHDT03",100,0)
TASK ;
"RTN","RORHDT03",101,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT03",102,0)
 N RORERROR      ; Error processing data
"RTN","RORHDT03",103,0)
 N RORLOG        ; Log susbsystem data
"RTN","RORHDT03",104,0)
 N RORPARM       ; Application parameters
"RTN","RORHDT03",105,0)
 ;
"RTN","RORHDT03",106,0)
 N COUNTERS,HDTNODE,RC,REGLST,TMP,XQA,XQAFLG,XQAMSG
"RTN","RORHDT03",107,0)
 ;--- Force "UNDEF" error if task parameters are not defined
"RTN","RORHDT03",108,0)
 I '("ANO"[$G(RORFAM))  K RORFAM   S RC=RORFAM
"RTN","RORHDT03",109,0)
 I $G(RORREG)'>0        K RORREG   S RC=RORREG
"RTN","RORHDT03",110,0)
 I $G(RORTASK)'>0       K RORTASK  S RC=RORTASK
"RTN","RORHDT03",111,0)
 ;--- Initialize constants and variables
"RTN","RORHDT03",112,0)
 D INIT^RORUTL01("RORHDT"),CLEAR^RORERR("TASK^RORHDT03")
"RTN","RORHDT03",113,0)
 S HDTNODE=$NA(^XTMP("RORHDT"_+RORREG))
"RTN","RORHDT03",114,0)
 ;S RORPARM("DEBUG")=1 ; Remove the first ';' to start in debug mode
"RTN","RORHDT03",115,0)
 S RORPARM("ERR")=1
"RTN","RORHDT03",116,0)
 S RORPARM("LOG")=1
"RTN","RORHDT03",117,0)
 ;--- Check if the task is running
"RTN","RORHDT03",118,0)
 L +@HDTNODE@("T",RORTASK):3
"RTN","RORHDT03",119,0)
 E  S ZTSTOP=1  Q
"RTN","RORHDT03",120,0)
 K @HDTNODE@("T",RORTASK)
"RTN","RORHDT03",121,0)
 ;--- Update node descriptor in the ^XTMP global
"RTN","RORHDT03",122,0)
 D XTMPHDR^RORUTL01("RORHDT"_+RORREG,30,"TASK-RORHDT03")
"RTN","RORHDT03",123,0)
 ;--- Open a new log
"RTN","RORHDT03",124,0)
 S REGLST($P(RORREG,U,2))=+RORREG
"RTN","RORHDT03",125,0)
 S TMP=$$OPEN^RORLOG(.REGLST,4,"HISTORICAL DATA EXTRACTION STARTED")
"RTN","RORHDT03",126,0)
 K REGLST
"RTN","RORHDT03",127,0)
 ;--- Historical data extraction
"RTN","RORHDT03",128,0)
 D
"RTN","RORHDT03",129,0)
 . S RC=$$UPDTASK(+RORREG,RORTASK,ZTSK,$J,"",$$LOGIEN^RORLOG)  Q:RC<0
"RTN","RORHDT03",130,0)
 . S RC=$$EXTRACT^RORHDT04(RORREG,RORTASK,RORFAM)              Q:RC<0
"RTN","RORHDT03",131,0)
 . S COUNTERS=RC,TMP='$G(ZTSTOP)&'$P(RC,U,2),RC=0
"RTN","RORHDT03",132,0)
 . S TMP=$$UPDTASK(+RORREG,RORTASK,,"",TMP)
"RTN","RORHDT03",133,0)
 ;
"RTN","RORHDT03",134,0)
 ;--- Statistics & Cleanup
"RTN","RORHDT03",135,0)
 S TMP=$S($G(ZTSTOP):"WAS STOPPED",RC<0:"ABORTED",1:"FINISHED")
"RTN","RORHDT03",136,0)
 D CLOSE^RORLOG("HISTORICAL DATA EXTRACTION "_TMP,$G(COUNTERS))
"RTN","RORHDT03",137,0)
 D:'$G(RORPARM("DEBUG")) INIT^RORUTL01("RORHDT")
"RTN","RORHDT03",138,0)
 ;--- Reset "Running" flag
"RTN","RORHDT03",139,0)
 K @HDTNODE@("T",RORTASK)
"RTN","RORHDT03",140,0)
 L -@HDTNODE@("T",RORTASK)
"RTN","RORHDT03",141,0)
 ;--- Send an alert to the user
"RTN","RORHDT03",142,0)
 I $G(RORDUZ)>0  D  D SETUP^XQALERT
"RTN","RORHDT03",143,0)
 . S XQA(RORDUZ)="",XQAFLG="D"
"RTN","RORHDT03",144,0)
 . S XQAMSG="Historical data extraction task has finished (RC="_RC_")"
"RTN","RORHDT03",145,0)
 S ZTREQ="@"
"RTN","RORHDT03",146,0)
 Q
"RTN","RORHDT03",147,0)
 ;
"RTN","RORHDT03",148,0)
 ;***** UPDATES TASK RECORD
"RTN","RORHDT03",149,0)
 ;
"RTN","RORHDT03",150,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT03",151,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT03",152,0)
 ; [TASKNUM]     Task number
"RTN","RORHDT03",153,0)
 ; [JOBNUM]      Job number
"RTN","RORHDT03",154,0)
 ; [LOGIEN]      IEN of the latest task log
"RTN","RORHDT03",155,0)
 ;
"RTN","RORHDT03",156,0)
 ; The function updates task record fields with values of the
"RTN","RORHDT03",157,0)
 ; parameters. If a parameter is omitted, corresponding field retain
"RTN","RORHDT03",158,0)
 ; its current value.
"RTN","RORHDT03",159,0)
 ;
"RTN","RORHDT03",160,0)
 ; If the JOBNUM parameter is defined and not zero (it means that a
"RTN","RORHDT03",161,0)
 ; new job is being started), the COMPLETED field is always cleared.
"RTN","RORHDT03",162,0)
 ;
"RTN","RORHDT03",163,0)
 ; If the CMPLTD parameter is defined and not zero (the task has been
"RTN","RORHDT03",164,0)
 ; completed successfully), the TASKNUM field is always cleared.
"RTN","RORHDT03",165,0)
 ;
"RTN","RORHDT03",166,0)
 ; Return Values:
"RTN","RORHDT03",167,0)
 ;       <0  Error code
"RTN","RORHDT03",168,0)
 ;        0  Ok
"RTN","RORHDT03",169,0)
 ;
"RTN","RORHDT03",170,0)
UPDTASK(REGIEN,TASKIEN,TASKNUM,JOBNUM,CMPLTD,LOGIEN) ;
"RTN","RORHDT03",171,0)
 N IENS,RORFDA,RORMSG
"RTN","RORHDT03",172,0)
 S IENS=TASKIEN_","
"RTN","RORHDT03",173,0)
 I $D(JOBNUM)#2  D  S:JOBNUM CMPLTD=""
"RTN","RORHDT03",174,0)
 . S RORFDA(798.5,IENS,2.02)=JOBNUM
"RTN","RORHDT03",175,0)
 I $D(CMPLTD)#2  D  S:CMPLTD TASKNUM=""
"RTN","RORHDT03",176,0)
 . S RORFDA(798.5,IENS,2.03)=CMPLTD
"RTN","RORHDT03",177,0)
 S:$D(TASKNUM)#2 RORFDA(798.5,IENS,2.01)=TASKNUM
"RTN","RORHDT03",178,0)
 S:$D(LOGIEN)#2 RORFDA(798.5,IENS,2.04)=LOGIEN
"RTN","RORHDT03",179,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORHDT03",180,0)
 Q $$DBS^RORERR("RORMSG",-9,"UPDTASK^RORHDT03")
"RTN","RORHDT04")
0^2^B31949569
"RTN","RORHDT04",1,0)
RORHDT04 ;HCIOFO/SG - HISTORICAL DATA EXTRACTION PROCESS ; 8/20/02 8:40am
"RTN","RORHDT04",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORHDT04",3,0)
 ;
"RTN","RORHDT04",4,0)
 Q
"RTN","RORHDT04",5,0)
 ;
"RTN","RORHDT04",6,0)
 ;***** DATA EXTRACTION PROCESS
"RTN","RORHDT04",7,0)
 ;
"RTN","RORHDT04",8,0)
 ; REGISTRY      Registry to process
"RTN","RORHDT04",9,0)
 ;                 ^1: Registry IEN
"RTN","RORHDT04",10,0)
 ;                 ^2: Registry Name
"RTN","RORHDT04",11,0)
 ; TASKIEN       Task IEN
"RTN","RORHDT04",12,0)
 ; FAM           File Access Mode
"RTN","RORHDT04",13,0)
 ;
"RTN","RORHDT04",14,0)
 ; Return Values:
"RTN","RORHDT04",15,0)
 ;       <0  Error code
"RTN","RORHDT04",16,0)
 ;      >=0  Statistics
"RTN","RORHDT04",17,0)
 ;             ^1: Total number of processed patients
"RTN","RORHDT04",18,0)
 ;             ^2: Number of patients processed with errors
"RTN","RORHDT04",19,0)
 ;
"RTN","RORHDT04",20,0)
EXTRACT(REGISTRY,TASKIEN,FAM) ;
"RTN","RORHDT04",21,0)
 N RORDATE       ; Date/time when the first registry update finished
"RTN","RORHDT04",22,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT04",23,0)
 N ROREXT        ; Data extraction descriptor
"RTN","RORHDT04",24,0)
 N RORHL         ; HL7 variables
"RTN","RORHDT04",25,0)
 N RORLRC        ; List of codes of Lab results to be extracted
"RTN","RORHDT04",26,0)
 ;
"RTN","RORHDT04",27,0)
 N CNT           ; Number of processed registry records
"RTN","RORHDT04",28,0)
 N ECNT          ; Number of records processed with errors
"RTN","RORHDT04",29,0)
 N FILE          ; Name of the output file
"RTN","RORHDT04",30,0)
 N OUTDIR        ; Name of the output directory
"RTN","RORHDT04",31,0)
 ;
"RTN","RORHDT04",32,0)
 N BDT,EDT,POP,RC,REGIEN,REGLST,REGNAME,RRBIEN,RREIEN,STOP,TMP
"RTN","RORHDT04",33,0)
 D DFLTLOC^RORERR("EXTRACT^RORHDT04")
"RTN","RORHDT04",34,0)
 K ^TMP("RORHDT",$J,"PR")
"RTN","RORHDT04",35,0)
 S REGNAME=$P(REGISTRY,U,2),(REGLST(REGNAME),REGIEN)=+REGISTRY
"RTN","RORHDT04",36,0)
 S (CNT,ECNT,STOP)=0
"RTN","RORHDT04",37,0)
 S RORHDT("BHS")=(FAM'="A")
"RTN","RORHDT04",38,0)
 ;--- Load parameters
"RTN","RORHDT04",39,0)
 S RC=$$REGPARM^RORHDT05(REGIEN,.BDT,.EDT,.OUTDIR,.RORDATE)
"RTN","RORHDT04",40,0)
 Q:RC<0 RC
"RTN","RORHDT04",41,0)
 S RC=$$TASKPARM^RORHDT05(REGIEN,TASKIEN,.RRBIEN,.RREIEN,.FILE)
"RTN","RORHDT04",42,0)
 Q:RC<0 RC
"RTN","RORHDT04",43,0)
 ;--- Prepare data extraction rules
"RTN","RORHDT04",44,0)
 S RC=$$PREPARE^ROREXPR(REGNAME,BDT,EDT)
"RTN","RORHDT04",45,0)
 Q:RC<0 $$ERROR^RORERR(-22)
"RTN","RORHDT04",46,0)
 K ROREXT("LD")          ; Do not use lag intervals
"RTN","RORHDT04",47,0)
 K ROREXT("MAXHL7SIZE")  ; Do not limit the size
"RTN","RORHDT04",48,0)
 S RC=$$INIT^RORHL7()  Q:RC<0 RC
"RTN","RORHDT04",49,0)
 ;--- Create/Verify the output file
"RTN","RORHDT04",50,0)
 D OPEN^%ZISH("HL7FILE",OUTDIR,FILE,$S(FAM="A":"A",1:"W"))
"RTN","RORHDT04",51,0)
 Q:$G(POP) $$ERROR^RORERR(-34,,OUTDIR_FILE)
"RTN","RORHDT04",52,0)
 U IO  W ""  D CLOSE^%ZISH("HL7FILE")
"RTN","RORHDT04",53,0)
 ;---
"RTN","RORHDT04",54,0)
 D
"RTN","RORHDT04",55,0)
 . N IEN,LAST,NODE,NRTC,PATIEN
"RTN","RORHDT04",56,0)
 . S NRTC=100 ; Number of records to commit
"RTN","RORHDT04",57,0)
 . ;--- Try to re-extract erroneous records
"RTN","RORHDT04",58,0)
 . S NODE=$$ROOT^DILFD(798.53,","_TASKIEN_",",1)
"RTN","RORHDT04",59,0)
 . S NODE=$NA(@NODE@("B"))
"RTN","RORHDT04",60,0)
 . S IEN=0,RC=0
"RTN","RORHDT04",61,0)
 . F  D  Q:RC!STOP!(IEN="")
"RTN","RORHDT04",62,0)
 . . K ^TMP("HLS",$J)
"RTN","RORHDT04",63,0)
 . . F  S IEN=$O(@NODE@(IEN))  Q:IEN=""  D  Q:RC!'((CNT-ECNT)#NRTC)
"RTN","RORHDT04",64,0)
 . . . S RC=$$CHKSTOP^RORHDT03(REGIEN,TASKIEN)
"RTN","RORHDT04",65,0)
 . . . I RC  S STOP=1  Q
"RTN","RORHDT04",66,0)
 . . . S RC=$$PROCREC(REGIEN,IEN,.PATIEN),CNT=CNT+1
"RTN","RORHDT04",67,0)
 . . . S ^TMP("RORHDT",$J,"PR",IEN)=RC
"RTN","RORHDT04",68,0)
 . . . I RC'<0  S RC=0  Q
"RTN","RORHDT04",69,0)
 . . . ;--- Proccess the error
"RTN","RORHDT04",70,0)
 . . . S RC=$$ERROR^RORERR(-15,,,$G(PATIEN)),ECNT=ECNT+1
"RTN","RORHDT04",71,0)
 . . . S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORHDT04",72,0)
 . . Q:RC<0
"RTN","RORHDT04",73,0)
 . . ;--- Commit the data
"RTN","RORHDT04",74,0)
 . . S TMP=$$COMMIT^RORHDT05(OUTDIR,FILE)
"RTN","RORHDT04",75,0)
 . . S:TMP<0 RC=TMP
"RTN","RORHDT04",76,0)
 . Q:STOP
"RTN","RORHDT04",77,0)
 . ;--- Extract the remaining registry data
"RTN","RORHDT04",78,0)
 . S NODE=$$ROOT^DILFD(798,,1)
"RTN","RORHDT04",79,0)
 . S NODE=$NA(@NODE@("AC",REGIEN))
"RTN","RORHDT04",80,0)
 . S IEN=$S(RRBIEN>0:+$O(@NODE@(RRBIEN),-1),1:0)
"RTN","RORHDT04",81,0)
 . S RC=0
"RTN","RORHDT04",82,0)
 . F  D  Q:RC!STOP!(IEN'>0)
"RTN","RORHDT04",83,0)
 . . K ^TMP("HLS",$J)
"RTN","RORHDT04",84,0)
 . . F  S IEN=$O(@NODE@(IEN))  Q:IEN'>0  D  Q:RC!'((CNT-ECNT)#NRTC)
"RTN","RORHDT04",85,0)
 . . . S RC=$$CHKSTOP^RORHDT03(REGIEN,TASKIEN)
"RTN","RORHDT04",86,0)
 . . . I RC  S STOP=1  Q
"RTN","RORHDT04",87,0)
 . . . I RREIEN>0,IEN'<RREIEN  S IEN="",RC=1  Q
"RTN","RORHDT04",88,0)
 . . . Q:$D(^TMP("RORHDT",$J,"PR",IEN))
"RTN","RORHDT04",89,0)
 . . . S RC=$$PROCREC(REGIEN,IEN,.PATIEN),CNT=CNT+1
"RTN","RORHDT04",90,0)
 . . . I RC'<0  S RC=0  Q
"RTN","RORHDT04",91,0)
 . . . ;--- Proccess the error
"RTN","RORHDT04",92,0)
 . . . S RC=$$ERROR^RORERR(-15,,,,$G(PATIEN)),ECNT=ECNT+1
"RTN","RORHDT04",93,0)
 . . . S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORHDT04",94,0)
 . . . S TMP=$$ADDERR^RORHDT05(REGIEN,TASKIEN,IEN)
"RTN","RORHDT04",95,0)
 . . . S:TMP<0 RC=TMP
"RTN","RORHDT04",96,0)
 . . Q:RC<0
"RTN","RORHDT04",97,0)
 . . ;--- If completed with errors, use IEN of the last processed
"RTN","RORHDT04",98,0)
 . . ;    registry record instead of an empty string. When the task
"RTN","RORHDT04",99,0)
 . . ;    is restarted, it will try to re-extract only erroneous
"RTN","RORHDT04",100,0)
 . . ;    records and will not process already extracted data (RRBIEN
"RTN","RORHDT04",101,0)
 . . ;    will not be less than RREIEN).
"RTN","RORHDT04",102,0)
 . . ;--- If the task completed successfuly, the NEXT RECORD IEN
"RTN","RORHDT04",103,0)
 . . ;    field is set to an empty string. If the task is restarted
"RTN","RORHDT04",104,0)
 . . ;--- afterwards, it will re-extract all data again.
"RTN","RORHDT04",105,0)
 . . I IEN>0  S LAST=IEN
"RTN","RORHDT04",106,0)
 . . E  S LAST=$S('ECNT:"",RREIEN>0:RREIEN,1:$O(@NODE@(""),-1)+1)
"RTN","RORHDT04",107,0)
 . . ;--- Commit the data
"RTN","RORHDT04",108,0)
 . . S TMP=$$COMMIT^RORHDT05(OUTDIR,FILE,LAST,REGIEN,TASKIEN)
"RTN","RORHDT04",109,0)
 . . S:TMP<0 RC=TMP
"RTN","RORHDT04",110,0)
 ;
"RTN","RORHDT04",111,0)
 ;--- Write the batch trailer segment (if the batch is not empty)
"RTN","RORHDT04",112,0)
 D:'$G(RORHDT("BHS"))
"RTN","RORHDT04",113,0)
 . D OPEN^%ZISH("HL7FILE",OUTDIR,FILE,"A")
"RTN","RORHDT04",114,0)
 . Q:$G(POP)  U IO
"RTN","RORHDT04",115,0)
 . S TMP=$S(ECNT!(RC<0):"Completed with errors",STOP:"Stopped",1:"")
"RTN","RORHDT04",116,0)
 . W $$BTS^RORHL7($$MSGCNT^RORHL7,TMP),$C(13)
"RTN","RORHDT04",117,0)
 . D CLOSE^%ZISH("HL7FILE")
"RTN","RORHDT04",118,0)
 ;--- Cleanup
"RTN","RORHDT04",119,0)
 S:RC'<0 RC=$$CLRERRS^RORHDT05(REGIEN,TASKIEN)
"RTN","RORHDT04",120,0)
 Q $S(RC<0:RC,1:CNT_U_ECNT)
"RTN","RORHDT04",121,0)
 ;
"RTN","RORHDT04",122,0)
 ;***** PROCESSES A RECORD IN THE REGISTRY
"RTN","RORHDT04",123,0)
 ;
"RTN","RORHDT04",124,0)
 ; REGIEN        Registry IEN
"RTN","RORHDT04",125,0)
 ; IEN           IEN of a record in the registry
"RTN","RORHDT04",126,0)
 ; [.PATIEN]     Patient IEN is returned by this parameter
"RTN","RORHDT04",127,0)
 ;
"RTN","RORHDT04",128,0)
 ; Return Values:
"RTN","RORHDT04",129,0)
 ;       <0  Error code
"RTN","RORHDT04",130,0)
 ;        0  Ok
"RTN","RORHDT04",131,0)
 ;        1  Nothing has been extracted
"RTN","RORHDT04",132,0)
 ;
"RTN","RORHDT04",133,0)
PROCREC(REGIEN,IEN,PATIEN) ;
"RTN","RORHDT04",134,0)
 N RORERRDL      ; Default error location
"RTN","RORHDT04",135,0)
 ;
"RTN","RORHDT04",136,0)
 N ACTIVE,BDT,EDT,IENS,INCTVDT,MSHPTR,RC,RORFDA,RORMSG
"RTN","RORHDT04",137,0)
 D CLEAR^RORERR("PROCREC^RORHDT04")
"RTN","RORHDT04",138,0)
 S IENS=IEN_",",PATIEN=0
"RTN","RORHDT04",139,0)
 ;--- Get the registry record data
"RTN","RORHDT04",140,0)
 D GETS^DIQ(798,IENS,".01;1;2;8;11","EI","RORFDA","RORMSG")
"RTN","RORHDT04",141,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","RORHDT04",142,0)
 S PATIEN=RORFDA(798,IENS,.01,"I")
"RTN","RORHDT04",143,0)
 S INCTVDT=$G(RORFDA(798,IENS,2,"I"))\1
"RTN","RORHDT04",144,0)
 S ACTIVE=$G(RORFDA(798,IENS,8,"E"))
"RTN","RORHDT04",145,0)
 ;--- Skip a record tagged as "DON'T SEND"
"RTN","RORHDT04",146,0)
 Q:$G(RORFDA(798,IENS,11,"I")) 0
"RTN","RORHDT04",147,0)
 ;--- Skip the record if it was not added by the first update
"RTN","RORHDT04",148,0)
 I RORDATE  Q:$G(RORFDA(798,IENS,1,"I"))>RORDATE 0
"RTN","RORHDT04",149,0)
 ;--- Prepare extract dates
"RTN","RORHDT04",150,0)
 S BDT=$G(ROREXT("DXBEG")),EDT=$G(ROREXT("DXEND"))
"RTN","RORHDT04",151,0)
 I 'ACTIVE  Q:INCTVDT'>BDT 0  S:EDT>INCTVDT EDT=INCTVDT
"RTN","RORHDT04",152,0)
 ;--- Create HL7 message for the patient
"RTN","RORHDT04",153,0)
 S MSHPTR=$$CREATE^RORHL7()  Q:MSHPTR<0 MSHPTR
"RTN","RORHDT04",154,0)
 S RC=$$MESSAGE^ROREXT02(IEN,PATIEN,BDT,EDT,1)
"RTN","RORHDT04",155,0)
 ;--- Rollback incomplete message if necessary
"RTN","RORHDT04",156,0)
 S:RC'<0 RC=($O(^TMP("HLS",$J,""),-1)'>MSHPTR)
"RTN","RORHDT04",157,0)
 D:RC ROLLBACK^RORHL7(MSHPTR)
"RTN","RORHDT04",158,0)
 Q RC
"RTN","RORHDTAC")
0^16^B12683505
"RTN","RORHDTAC",1,0)
RORHDTAC ;HCIOFO/SG - DATA EXTRACTION ACTION CONFIRMATIONS ; 7/16/02 9:30am
"RTN","RORHDTAC",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORHDTAC",3,0)
 ;
"RTN","RORHDTAC",4,0)
 Q
"RTN","RORHDTAC",5,0)
 ;
"RTN","RORHDTAC",6,0)
 ;***** CONFIRMATION TO CREATE A NEW TASK TABLE
"RTN","RORHDTAC",7,0)
 ;
"RTN","RORHDTAC",8,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTAC",9,0)
 ;
"RTN","RORHDTAC",10,0)
 ; Return Values:
"RTN","RORHDTAC",11,0)
 ;       <0  Error code
"RTN","RORHDTAC",12,0)
 ;        0  Cancel
"RTN","RORHDTAC",13,0)
 ;        1  Create a table
"RTN","RORHDTAC",14,0)
 ;
"RTN","RORHDTAC",15,0)
CREATE(REGIEN) ;
"RTN","RORHDTAC",16,0)
 N IENS,RC,RORBUF,RORMSG
"RTN","RORHDTAC",17,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,X,Y
"RTN","RORHDTAC",18,0)
 ;--- Display status of the registry
"RTN","RORHDTAC",19,0)
 S RC=$$STATUS^RORHDT01(REGIEN)  Q:RC<0 RC
"RTN","RORHDTAC",20,0)
 ;--- Check if registry task table is not empty
"RTN","RORHDTAC",21,0)
 D FIND^DIC(798.5,,"@","QX",REGIEN,1,"AR",,,"RORBUF","RORMSG")
"RTN","RORHDTAC",22,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"CREATE^RORHDTAC",,798.5)
"RTN","RORHDTAC",23,0)
 ;--- Ask for a confirmation to overwrite
"RTN","RORHDTAC",24,0)
 I $G(RORBUF("DILIST",0))>0  D  Q:RC 0
"RTN","RORHDTAC",25,0)
 . K DIR  S DIR(0)="Y"
"RTN","RORHDTAC",26,0)
 . S DIR("A")="Overwrite the existing task table"
"RTN","RORHDTAC",27,0)
 . S DIR("B")="NO"
"RTN","RORHDTAC",28,0)
 . D ^DIR  W !  S RC=$D(DIRUT)!'$G(Y)
"RTN","RORHDTAC",29,0)
 Q 1
"RTN","RORHDTAC",30,0)
 ;
"RTN","RORHDTAC",31,0)
 ;***** CONFIRMATIONS TO START THE TASK
"RTN","RORHDTAC",32,0)
 ;
"RTN","RORHDTAC",33,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTAC",34,0)
 ; TASKIEN       Task IEN
"RTN","RORHDTAC",35,0)
 ; .FAM          File Access Mode is returned via this parameter
"RTN","RORHDTAC",36,0)
 ;
"RTN","RORHDTAC",37,0)
 ; Return Values:
"RTN","RORHDTAC",38,0)
 ;       <0  Error code
"RTN","RORHDTAC",39,0)
 ;        0  Cancel
"RTN","RORHDTAC",40,0)
 ;        1  Start the task
"RTN","RORHDTAC",41,0)
 ;
"RTN","RORHDTAC",42,0)
START(REGIEN,TASKIEN,FAM) ;
"RTN","RORHDTAC",43,0)
 N FILE,OUTDIR,RC,RORDST,RORSRC,STATUS
"RTN","RORHDTAC",44,0)
 N DA,DIDEL,DIE,DIR,DIROUT,DIRUT,DR,DTOUT,DUOUT,X,Y
"RTN","RORHDTAC",45,0)
 S FAM=""
"RTN","RORHDTAC",46,0)
 ;--- Check status of the task
"RTN","RORHDTAC",47,0)
 S STATUS=+$$STATUS^RORHDTUT(REGIEN,TASKIEN)
"RTN","RORHDTAC",48,0)
 I STATUS=1  D  Q:RC $S(RC<0:RC,1:0)
"RTN","RORHDTAC",49,0)
 . K DIR  S DIR(0)="Y"
"RTN","RORHDTAC",50,0)
 . S DIR("A")="The task is pending. Do you want to rescheduled it"
"RTN","RORHDTAC",51,0)
 . S DIR("B")="NO"
"RTN","RORHDTAC",52,0)
 . D ^DIR  W !  S RC=$D(DIRUT)!'$G(Y)
"RTN","RORHDTAC",53,0)
 . S:'RC RC=$$STOP^RORHDT03(REGIEN,TASKIEN)
"RTN","RORHDTAC",54,0)
 I STATUS=2  D  Q 0
"RTN","RORHDTAC",55,0)
 . W !,"The task is running already",!
"RTN","RORHDTAC",56,0)
 I STATUS=100  D  Q:RC 0
"RTN","RORHDTAC",57,0)
 . K DIR  S DIR(0)="Y"
"RTN","RORHDTAC",58,0)
 . S DIR("A")="The task is completed. Do you want to rerun it"
"RTN","RORHDTAC",59,0)
 . S DIR("B")="NO"
"RTN","RORHDTAC",60,0)
 . D ^DIR  W !  S RC=$D(DIRUT)!'$G(Y)
"RTN","RORHDTAC",61,0)
 ;--- Check if the output file exists already
"RTN","RORHDTAC",62,0)
 S RC=$$TASKFILE^RORHDTUT(REGIEN,TASKIEN,.OUTDIR,.FILE)  Q:RC<0 RC
"RTN","RORHDTAC",63,0)
 S RORSRC(FILE)=""
"RTN","RORHDTAC",64,0)
 S RC=$$LIST^%ZISH(OUTDIR,"RORSRC","RORDST")
"RTN","RORHDTAC",65,0)
 I RC,$D(RORDST)>1  D  Q:RC 0
"RTN","RORHDTAC",66,0)
 . K DIR  S DIR(0)="SAB^N:New file;O:Overwrite"
"RTN","RORHDTAC",67,0)
 . S DIR("A",1)="Output file "_FILE_" exists already."
"RTN","RORHDTAC",68,0)
 . S DIR("A")="Overwrite or create a New file? "
"RTN","RORHDTAC",69,0)
 . S DIR("B")=$S(STATUS=101:"Overwrite",1:"New file")
"RTN","RORHDTAC",70,0)
 . D ^DIR  W !  S RC=$D(DIRUT)
"RTN","RORHDTAC",71,0)
 . S:'RC FAM=Y
"RTN","RORHDTAC",72,0)
 ;--- Confirm/modify the new file name
"RTN","RORHDTAC",73,0)
 I FAM["N"  D  Q:RC $S(RC<0:RC,1:0)
"RTN","RORHDTAC",74,0)
 . N RORFDA,RORMSG
"RTN","RORHDTAC",75,0)
 . S RC=$$NEWFILE^RORHDTUT(REGIEN,TASKIEN,.FILE,1)  Q:RC<0
"RTN","RORHDTAC",76,0)
 . K DIR  S DIR(0)="798.5,1.01"
"RTN","RORHDTAC",77,0)
 . S DIR("A")="File Name"
"RTN","RORHDTAC",78,0)
 . S DIR("B")=FILE
"RTN","RORHDTAC",79,0)
 . D ^DIR  W !  I $D(DIRUT)  S RC=1  Q
"RTN","RORHDTAC",80,0)
 . ;--- Store the new file name
"RTN","RORHDTAC",81,0)
 . S RORFDA(798.5,TASKIEN_",",1.01)=Y
"RTN","RORHDTAC",82,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORHDTAC",83,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"START^RORHDTAC")
"RTN","RORHDTAC",84,0)
 Q 1
"RTN","RORHDTAC",85,0)
 ;
"RTN","RORHDTAC",86,0)
 ;***** CONFIRMATION TO STOP THE TASK
"RTN","RORHDTAC",87,0)
 ;
"RTN","RORHDTAC",88,0)
 ; REGIEN        Registry IEN
"RTN","RORHDTAC",89,0)
 ; TASKIEN       Task IEN
"RTN","RORHDTAC",90,0)
 ;
"RTN","RORHDTAC",91,0)
 ; Return Values:
"RTN","RORHDTAC",92,0)
 ;       <0  Error code
"RTN","RORHDTAC",93,0)
 ;        0  Cancel
"RTN","RORHDTAC",94,0)
 ;        1  Stop the task
"RTN","RORHDTAC",95,0)
 ;
"RTN","RORHDTAC",96,0)
STOP(REGIEN,TASKIEN) ;
"RTN","RORHDTAC",97,0)
 N DA,DIR,DIROUT,DIRUT,DTOUT,DUOUT,STATUS,X,Y,ZTSK
"RTN","RORHDTAC",98,0)
 ;--- Check status of the task
"RTN","RORHDTAC",99,0)
 S STATUS=+$$STATUS^RORHDTUT(REGIEN,TASKIEN)
"RTN","RORHDTAC",100,0)
 Q:(STATUS'=1)&(STATUS'=2) 0 ; Neither running nor pending
"RTN","RORHDTAC",101,0)
 ;--- Get the task number
"RTN","RORHDTAC",102,0)
 S ZTSK=$$GET1^DIQ(798.5,TASKIEN_",",2.01,,,"RORMSG")
"RTN","RORHDTAC",103,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"STOP^RORHDTAC",,798.5,TASKIEN)
"RTN","RORHDTAC",104,0)
 ;--- Ask for the final confirmation
"RTN","RORHDTAC",105,0)
 K DIR  S DIR(0)="Y"
"RTN","RORHDTAC",106,0)
 S DIR("A")=$S(STATUS=2:"Stop",1:"Dequeue")_" the task #"_ZTSK
"RTN","RORHDTAC",107,0)
 S DIR("B")="NO"
"RTN","RORHDTAC",108,0)
 D ^DIR  W !
"RTN","RORHDTAC",109,0)
 Q '$D(DIRUT)&$G(Y)
"RTN","RORHL01")
0^4^B10788865
"RTN","RORHL01",1,0)
RORHL01 ;HOIFO/CRT - Clinical Registries Segment APIs ; 8/16/02 12:52pm
"RTN","RORHL01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORHL01",3,0)
 ;
"RTN","RORHL01",4,0)
 Q
"RTN","RORHL01",5,0)
 ;
"RTN","RORHL01",6,0)
PID(RORDFN,RORPTR,HLFS,HLECH) ; PID SEGMENT
"RTN","RORHL01",7,0)
 ;
"RTN","RORHL01",8,0)
 ; INPUT:  RORDFN - DFN of Patient Record in File #2          (Req'd)
"RTN","RORHL01",9,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                  (Opt'l)
"RTN","RORHL01",10,0)
 ;         HLFS   - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL01",11,0)
 ;         HLECH  - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL01",12,0)
 ;
"RTN","RORHL01",13,0)
 N CS,I,RORFLDS,RORMSG,RORRES,RORSEG,RORSITE,SCS,TMP,VAFPID
"RTN","RORHL01",14,0)
 ;
"RTN","RORHL01",15,0)
 S RORRES=0
"RTN","RORHL01",16,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL01",17,0)
 ;
"RTN","RORHL01",18,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL01",19,0)
 S CS=$E(HLECH,1),SCS=$E(HLECH,4)
"RTN","RORHL01",20,0)
 ;
"RTN","RORHL01",21,0)
 S RORDFN=+$G(RORDFN)  I '$D(^DPT(RORDFN))  D  Q RORRES
"RTN","RORHL01",22,0)
 . S RORRES=$$ERROR^RORERR(-36,"PID^RORHL01",,RORDFN,2)
"RTN","RORHL01",23,0)
 ;
"RTN","RORHL01",24,0)
 S RORFLDS="2,3,5,7,8,10,11,19,29" ; Default HL7 fields
"RTN","RORHL01",25,0)
 ;
"RTN","RORHL01",26,0)
 ; Call Standard PID Segment builder
"RTN","RORHL01",27,0)
 S RORSEG=$$EN^VAFHLPID(RORDFN,RORFLDS)
"RTN","RORHL01",28,0)
 S:$G(VAFPID(1))'="" RORSEG=RORSEG_VAFPID(1)
"RTN","RORHL01",29,0)
 ;
"RTN","RORHL01",30,0)
 ; PID-2 ICN
"RTN","RORHL01",31,0)
 S TMP=$$ICN^RORUTL02(RORDFN)
"RTN","RORHL01",32,0)
 I TMP>0  S $P(RORSEG,HLFS,3)=$TR(TMP,"V",CS)_CS_"ISO"_CS_"VAMPI"
"RTN","RORHL01",33,0)
 E  S $P(RORSEG,HLFS,3)=""
"RTN","RORHL01",34,0)
 ;
"RTN","RORHL01",35,0)
 ; PID-3 DFN + Old-ICN and Old-SSN if applicable
"RTN","RORHL01",36,0)
 S TMP=""
"RTN","RORHL01",37,0)
 S $P(TMP,CS,1,3)=$$M10^HLFNC(RORDFN,CS)
"RTN","RORHL01",38,0)
 S $P(TMP,CS,5)="PI"
"RTN","RORHL01",39,0)
 S $P(TMP,CS,6)=$$SITE^RORUTL03(SCS)
"RTN","RORHL01",40,0)
 S $P(RORSEG,HLFS,4)=TMP
"RTN","RORHL01",41,0)
 ;
"RTN","RORHL01",42,0)
 ; PID-5 Encrypt Patient Name
"RTN","RORHL01",43,0)
 S $P(RORSEG,HLFS,6)=$$ENCRYPT^RORUTL03($P(RORSEG,HLFS,6))
"RTN","RORHL01",44,0)
 ;
"RTN","RORHL01",45,0)
 ; PID-11 Remove Address (leave ZIP only)
"RTN","RORHL01",46,0)
 S $P(RORSEG,HLFS,12)=CS_CS_CS_CS_$P($P(RORSEG,HLFS,12),CS,5)
"RTN","RORHL01",47,0)
 ;
"RTN","RORHL01",48,0)
 ; PID-19 Encrypt SSN
"RTN","RORHL01",49,0)
 S $P(RORSEG,HLFS,20)=$$ENCRYPT^RORUTL03($P(RORSEG,HLFS,20))
"RTN","RORHL01",50,0)
 ;
"RTN","RORHL01",51,0)
 ; PID-29 Date of Death (not supported by EN^VAFHLPID)
"RTN","RORHL01",52,0)
 S TMP=$$GET1^DIQ(2,RORDFN,.351,"I",,"RORMSG")
"RTN","RORHL01",53,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"PID^RORHL01",,2,RORDFN)
"RTN","RORHL01",54,0)
 S:TMP $P(RORSEG,HLFS,30)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL01",55,0)
 ;
"RTN","RORHL01",56,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL01",57,0)
 D SETSEG^RORHL7(.RORPTR,.RORSEG)
"RTN","RORHL01",58,0)
 ;
"RTN","RORHL01",59,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL01",60,0)
 ;
"RTN","RORHL01",61,0)
ZSP(RORDFN,RORPTR,HLFS,HLECH) ; ZSP SEGMENT
"RTN","RORHL01",62,0)
 ;
"RTN","RORHL01",63,0)
 ; INPUT:  RORDFN - DFN of Patient Record in File #2          (Req'd)
"RTN","RORHL01",64,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                  (Opt'l)
"RTN","RORHL01",65,0)
 ;         HLFS   - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL01",66,0)
 ;         HLECH  - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL01",67,0)
 ;
"RTN","RORHL01",68,0)
 N I,RORFLDS,RORRES,RORSEG
"RTN","RORHL01",69,0)
 ;
"RTN","RORHL01",70,0)
 S RORRES=0
"RTN","RORHL01",71,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL01",72,0)
 ;
"RTN","RORHL01",73,0)
 S RORDFN=+$G(RORDFN)  I '$D(^DPT(RORDFN))  D  Q RORRES
"RTN","RORHL01",74,0)
 . S RORRES=$$ERROR^RORERR(-36,"ZSP^RORHL01",,RORDFN,2)
"RTN","RORHL01",75,0)
 ;
"RTN","RORHL01",76,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL01",77,0)
 ;
"RTN","RORHL01",78,0)
 S RORFLDS="1,2,3,4" ; Default HL7 fields
"RTN","RORHL01",79,0)
 ;
"RTN","RORHL01",80,0)
 ; Call Standard ZSP Segment Builder
"RTN","RORHL01",81,0)
 S RORSEG=$$EN^VAFHLZSP(RORDFN)
"RTN","RORHL01",82,0)
 ;
"RTN","RORHL01",83,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL01",84,0)
 D SETSEG^RORHL7(.RORPTR,.RORSEG)
"RTN","RORHL01",85,0)
 ;
"RTN","RORHL01",86,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL01",87,0)
 ;
"RTN","RORHL01",88,0)
ZRD(RORDFN,RORPTR,HLFS,HLECH) ; ZRD SEGMENT(S)
"RTN","RORHL01",89,0)
 ;
"RTN","RORHL01",90,0)
 ; INPUT:  RORDFN - DFN of Patient Record in File #2          (Req'd)
"RTN","RORHL01",91,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                  (Opt'l)
"RTN","RORHL01",92,0)
 ;         HLFS   - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL01",93,0)
 ;         HLECH  - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL01",94,0)
 ;
"RTN","RORHL01",95,0)
 N I,RORFLDS,RORRES,RORSEG
"RTN","RORHL01",96,0)
 ;
"RTN","RORHL01",97,0)
 S RORRES=0
"RTN","RORHL01",98,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL01",99,0)
 ;
"RTN","RORHL01",100,0)
 S RORDFN=+$G(RORDFN) I '$D(^DPT(RORDFN))  D  Q RORRES
"RTN","RORHL01",101,0)
 . S RORRES=$$ERROR^RORERR(-36,"ZRD^RORHL01",,RORDFN,2)
"RTN","RORHL01",102,0)
 ;
"RTN","RORHL01",103,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL01",104,0)
 ;
"RTN","RORHL01",105,0)
 S RORFLDS="1,2,3,4" ; Default HL7 fields
"RTN","RORHL01",106,0)
 ;
"RTN","RORHL01",107,0)
 ; Call Standard ZRD Segment Builder
"RTN","RORHL01",108,0)
 D EN^VAFHLZRD(RORDFN,RORFLDS,,HLFS,"RORSEG")
"RTN","RORHL01",109,0)
 ;
"RTN","RORHL01",110,0)
 ;--- Store the segment(s) in ^TMP("HLS",$J)
"RTN","RORHL01",111,0)
 S I=""
"RTN","RORHL01",112,0)
 F  S I=$O(RORSEG(I))  Q:I=""  Q:$P($G(RORSEG(I,0)),HLFS,3)=""  D
"RTN","RORHL01",113,0)
 . D SETSEG^RORHL7(.RORPTR,RORSEG(I,0))
"RTN","RORHL01",114,0)
 ;
"RTN","RORHL01",115,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL02")
0^5^B43166641
"RTN","RORHL02",1,0)
RORHL02 ;HOIFO/CRT - Clinical Registries Segment APIs - REGISTRY DATA ; 8/14/02 10:32am
"RTN","RORHL02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORHL02",3,0)
 ;
"RTN","RORHL02",4,0)
 Q
"RTN","RORHL02",5,0)
 ;
"RTN","RORHL02",6,0)
CSR(RORIEN,RORFLDS,RORPTR,HLFS,HLECH) ; CSR SEGMENT
"RTN","RORHL02",7,0)
 ;
"RTN","RORHL02",8,0)
 ; INPUT:  RORIEN - IEN of Patient Record in Registry File 798 (Req'd)
"RTN","RORHL02",9,0)
 ;         RORFLDS - Segment Fields to populate                (Opt'l)
"RTN","RORHL02",10,0)
 ;                   (1,3,4,6,10,14,15,16 available)
"RTN","RORHL02",11,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                   (Opt'l)
"RTN","RORHL02",12,0)
 ;         HLFS   - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL02",13,0)
 ;         HLECH  - Encoding Characters. Deafults to ^~\&      (Opt'l)
"RTN","RORHL02",14,0)
 ;
"RTN","RORHL02",15,0)
 N CS,FLDS,RORMSG,ROROUT,RORRES,RORSEG,RORTXT,SCS,TMP
"RTN","RORHL02",16,0)
 ;
"RTN","RORHL02",17,0)
 S RORRES=0
"RTN","RORHL02",18,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL02",19,0)
 ;
"RTN","RORHL02",20,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORHL02",21,0)
 ;
"RTN","RORHL02",22,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL02",23,0)
 S CS=$E(HLECH,1),SCS=$E(HLECH,4)
"RTN","RORHL02",24,0)
 ;
"RTN","RORHL02",25,0)
 S FLDS=".01;.02;1;2;2.2;3.2;6;6.1"
"RTN","RORHL02",26,0)
 D GETS^DIQ(798,RORIEN,FLDS,"IE","ROROUT","RORMSG")
"RTN","RORHL02",27,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"CSR^RORHL02",,798,RORIEN)
"RTN","RORHL02",28,0)
 ;
"RTN","RORHL02",29,0)
 I $G(RORFLDS)'=""  D
"RTN","RORHL02",30,0)
 . S:$E(RORFLDS)'="," RORFLDS=","_RORFLDS
"RTN","RORHL02",31,0)
 . S:$E(RORFLDS,$L(RORFLDS))'="," RORFLDS=RORFLDS_","
"RTN","RORHL02",32,0)
 E  S RORFLDS=",1,3,4,6,8,10,14,15,16," ; Default HL7 fields
"RTN","RORHL02",33,0)
 ;
"RTN","RORHL02",34,0)
 S $P(RORSEG,HLFS,1)="CSR"
"RTN","RORHL02",35,0)
 ;
"RTN","RORHL02",36,0)
 ; CSR-1 - Name of the registry
"RTN","RORHL02",37,0)
 I RORFLDS[",1," D
"RTN","RORHL02",38,0)
 .S $P(RORSEG,HLFS,2)=$G(ROROUT(798,RORIEN,.02,"E"))_CS_"VA"
"RTN","RORHL02",39,0)
 ;
"RTN","RORHL02",40,0)
 ; CSR-3 - Inpatient Division or User Division if fails
"RTN","RORHL02",41,0)
 I RORFLDS[",3," D
"RTN","RORHL02",42,0)
 .S $P(RORSEG,HLFS,4)=$$SITE^RORUTL03(CS)
"RTN","RORHL02",43,0)
 ;
"RTN","RORHL02",44,0)
 ; CSR-4 - Patient ID
"RTN","RORHL02",45,0)
 I RORFLDS[",4," D
"RTN","RORHL02",46,0)
 .S TMP=$$M10^HLFNC(ROROUT(798,RORIEN,.01,"I"),CS)
"RTN","RORHL02",47,0)
 .S:+TMP $P(RORSEG,HLFS,5)=TMP_CS_CS_"PI"_CS_$TR($P(RORSEG,HLFS,4),CS,SCS)
"RTN","RORHL02",48,0)
 ;
"RTN","RORHL02",49,0)
 ; CSR-6 - Date when entered to the registry
"RTN","RORHL02",50,0)
 I RORFLDS[",6," D
"RTN","RORHL02",51,0)
 .S TMP=$G(ROROUT(798,RORIEN,1,"I"))
"RTN","RORHL02",52,0)
 .S:TMP $P(RORSEG,HLFS,7)=$$FMTHL7^XLFDT($P(TMP,"."))
"RTN","RORHL02",53,0)
 ;
"RTN","RORHL02",54,0)
 ; CSR-10 - Supporting evidence AND  Reasons added
"RTN","RORHL02",55,0)
 ;
"RTN","RORHL02",56,0)
 I RORFLDS[",10," D
"RTN","RORHL02",57,0)
 . S TMP=$$GETAUTO(RORIEN,CS)
"RTN","RORHL02",58,0)
 . I TMP>0  S $P(RORSEG,HLFS,11)=TMP  Q
"RTN","RORHL02",59,0)
 . S TMP=$$ITEMCODE^RORUTL01($G(ROROUT(798,RORIEN,3.2,"I")),.RORTXT)
"RTN","RORHL02",60,0)
 . S:TMP>0 $P(RORSEG,HLFS,11)=TMP_CS_RORTXT_CS_"99VA79832"
"RTN","RORHL02",61,0)
 ;
"RTN","RORHL02",62,0)
 ; CSR-14 - Investigational drugs + Medication in Profile
"RTN","RORHL02",63,0)
 I RORFLDS[",14," D
"RTN","RORHL02",64,0)
 .S TMP=""
"RTN","RORHL02",65,0)
 .S $P(TMP,CS,1)=+$G(ROROUT(798,RORIEN,6,"I"))_+$G(ROROUT(798,RORIEN,6.1,"I"))
"RTN","RORHL02",66,0)
 .S $P(TMP,CS,2)="Investigational Drugs "_$S($G(ROROUT(798,RORIEN,6,"I")):"",1:"Not ")_"Used."
"RTN","RORHL02",67,0)
 .I +$G(ROROUT(798,RORIEN,6,"I")) D
"RTN","RORHL02",68,0)
 ..S $P(TMP,CS,2)=$P(TMP,CS,2)_" Medication "_$S($G(ROROUT(798,RORIEN,6.1,"I")):"",1:"not ")_"in Profile."
"RTN","RORHL02",69,0)
 .S $P(RORSEG,HLFS,15)=TMP_CS_"99VA7986"
"RTN","RORHL02",70,0)
 ;
"RTN","RORHL02",71,0)
 ; CSR-15 - Inactivation date
"RTN","RORHL02",72,0)
 I RORFLDS[",15," D
"RTN","RORHL02",73,0)
 .S TMP=$G(ROROUT(798,RORIEN,2,"I"))
"RTN","RORHL02",74,0)
 .S:TMP $P(RORSEG,HLFS,16)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL02",75,0)
 ;
"RTN","RORHL02",76,0)
 ; CSR-16 - Inactivation Reason
"RTN","RORHL02",77,0)
 I RORFLDS[",16," D
"RTN","RORHL02",78,0)
 .Q:'$G(ROROUT(798,RORIEN,2.2,"I"))
"RTN","RORHL02",79,0)
 .S TMP=""
"RTN","RORHL02",80,0)
 .S TMP=$$ITEMCODE^RORUTL01($G(ROROUT(798,RORIEN,2.2,"I")),.RORTXT)
"RTN","RORHL02",81,0)
 .S $P(TMP,CS,2)=RORTXT
"RTN","RORHL02",82,0)
 .S $P(TMP,CS,3)="99VA79822"
"RTN","RORHL02",83,0)
 .S:+TMP $P(RORSEG,HLFS,17)=TMP
"RTN","RORHL02",84,0)
 ;
"RTN","RORHL02",85,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL02",86,0)
 D SETSEG^RORHL7(.RORPTR,.RORSEG)
"RTN","RORHL02",87,0)
 ;
"RTN","RORHL02",88,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL02",89,0)
 ;
"RTN","RORHL02",90,0)
CSP(RORIEN,RORFLDS,RORPTR,HLFS,HLECH) ; CSP SEGMENT
"RTN","RORHL02",91,0)
 ;
"RTN","RORHL02",92,0)
 ; INPUT:  RORIEN - IEN of Patient Record in Registry File     (Req'd)
"RTN","RORHL02",93,0)
 ;         RORFLDS - Segment Fields to populate                (Opt'l)
"RTN","RORHL02",94,0)
 ;                   (1,2,3 available)
"RTN","RORHL02",95,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                   (Opt'l)
"RTN","RORHL02",96,0)
 ;         HLFS - Field Separator. Defaults to |               (Opt'l)
"RTN","RORHL02",97,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&       (Opt'l)
"RTN","RORHL02",98,0)
 ;
"RTN","RORHL02",99,0)
 N CS,FLDS,RORMSG,ROROUT,RORRES,RORSEG,TMP
"RTN","RORHL02",100,0)
 ;
"RTN","RORHL02",101,0)
 S RORRES=0
"RTN","RORHL02",102,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL02",103,0)
 ;
"RTN","RORHL02",104,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORHL02",105,0)
 ;
"RTN","RORHL02",106,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL02",107,0)
 S CS=$E(HLECH,1)
"RTN","RORHL02",108,0)
 ;
"RTN","RORHL02",109,0)
 I $G(RORFLDS)'=""  D
"RTN","RORHL02",110,0)
 . S:$E(RORFLDS)'="," RORFLDS=","_RORFLDS
"RTN","RORHL02",111,0)
 . S:$E(RORFLDS,$L(RORFLDS))'="" RORFLDS=RORFLDS_","
"RTN","RORHL02",112,0)
 E  S RORFLDS=",1,2,3," ; Default HL7 fields
"RTN","RORHL02",113,0)
 ;
"RTN","RORHL02",114,0)
 S FLDS="1;2;3;7"
"RTN","RORHL02",115,0)
 ;
"RTN","RORHL02",116,0)
 D GETS^DIQ(798,RORIEN,FLDS,"IE","ROROUT","RORMSG")
"RTN","RORHL02",117,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"CSP^RORHL02",,798,RORIEN)
"RTN","RORHL02",118,0)
 ;
"RTN","RORHL02",119,0)
 S $P(RORSEG,HLFS,1)="CSP"
"RTN","RORHL02",120,0)
 ;
"RTN","RORHL02",121,0)
 ; CSP-1 - New Patient?
"RTN","RORHL02",122,0)
 I RORFLDS[",1," D
"RTN","RORHL02",123,0)
 . S TMP=$G(ROROUT(798,RORIEN,3,"I"))_CS_$G(ROROUT(798,RORIEN,3,"E"))
"RTN","RORHL02",124,0)
 . S $P(RORSEG,HLFS,2)=$S(TMP>0:TMP,1:"0"_CS_"Edit")_CS_"99VA7983"
"RTN","RORHL02",125,0)
 ;
"RTN","RORHL02",126,0)
 ; CSP-2 - Registration Date or Reactivation Date
"RTN","RORHL02",127,0)
 I RORFLDS[",2," D
"RTN","RORHL02",128,0)
 .S TMP=$G(ROROUT(798,RORIEN,7,"I"))
"RTN","RORHL02",129,0)
 .S:TMP="" TMP=$G(ROROUT(798,RORIEN,1,"I"))
"RTN","RORHL02",130,0)
 .S:TMP $P(RORSEG,HLFS,3)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL02",131,0)
 ;
"RTN","RORHL02",132,0)
 ; CSP-3 - Inactivation Date or null
"RTN","RORHL02",133,0)
 I RORFLDS[",3," D
"RTN","RORHL02",134,0)
 .I $G(ROROUT(798,RORIEN,2,"I"))>$G(ROROUT(798,RORIEN,7,"I")) D
"RTN","RORHL02",135,0)
 ..S TMP=$G(ROROUT(798,RORIEN,2,"I"))
"RTN","RORHL02",136,0)
 ..S:TMP $P(RORSEG,HLFS,4)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL02",137,0)
 ;
"RTN","RORHL02",138,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL02",139,0)
 D SETSEG^RORHL7(.RORPTR,.RORSEG)
"RTN","RORHL02",140,0)
 ;
"RTN","RORHL02",141,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL02",142,0)
 ;
"RTN","RORHL02",143,0)
CSS(RORIEN,RORFLDS,RORPTR,HLFS,HLECH) ; CSS SEGMENT
"RTN","RORHL02",144,0)
 ;
"RTN","RORHL02",145,0)
 ; INPUT:  RORIEN - IEN of Patient Record in Registry File     (Req'd)
"RTN","RORHL02",146,0)
 ;         RORFLDS - Segment Fields to populate                (Opt'l)
"RTN","RORHL02",147,0)
 ;                   (1,2 available)
"RTN","RORHL02",148,0)
 ;         RORPTR - Last ^TMP("HLS",$J) node                   (Opt'l)
"RTN","RORHL02",149,0)
 ;         HLFS - Field Separator. Defaults to |               (Opt'l)
"RTN","RORHL02",150,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&       (Opt'l)
"RTN","RORHL02",151,0)
 ;
"RTN","RORHL02",152,0)
 N CS,FLDS,IEN7981,RORMSG,RORRES,RORSEG,TMP
"RTN","RORHL02",153,0)
 ;
"RTN","RORHL02",154,0)
 S RORRES=0
"RTN","RORHL02",155,0)
 I $G(RORPTR)'>0  K ^TMP("HLS",$J)  S RORPTR=0
"RTN","RORHL02",156,0)
 ;
"RTN","RORHL02",157,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORHL02",158,0)
 ;
"RTN","RORHL02",159,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL02",160,0)
 S CS=$E(HLECH,1)
"RTN","RORHL02",161,0)
 ;
"RTN","RORHL02",162,0)
 I RORFLDS'=""  D
"RTN","RORHL02",163,0)
 . S:$E(RORFLDS)'="," RORFLDS=","_RORFLDS
"RTN","RORHL02",164,0)
 . S:$E(RORFLDS,$L(RORFLDS))'="" RORFLDS=RORFLDS_","
"RTN","RORHL02",165,0)
 E  S RORFLDS=",1,2," ; Default HL7 fields
"RTN","RORHL02",166,0)
 ;
"RTN","RORHL02",167,0)
 S $P(RORSEG,HLFS,1)="CSS"
"RTN","RORHL02",168,0)
 ;
"RTN","RORHL02",169,0)
 ; CSS-1 Required Field. Set to "O"
"RTN","RORHL02",170,0)
 I RORFLDS[",1," D
"RTN","RORHL02",171,0)
 .S $P(RORSEG,HLFS,2)="O"_CS_"ONE TIME ONLY"_CS_"L"
"RTN","RORHL02",172,0)
 ;
"RTN","RORHL02",173,0)
 ; CSS-2 Last Extract Date
"RTN","RORHL02",174,0)
 I RORFLDS[",2," D  Q:RORRES<0 RORRES
"RTN","RORHL02",175,0)
 .S IEN7981=$$GET1^DIQ(798,RORIEN,.02,"I",,"RORMSG")
"RTN","RORHL02",176,0)
 .I $G(DIERR)  D  Q
"RTN","RORHL02",177,0)
 ..S RORRES=$$DBS^RORERR("RORMSG",-9,"CSS^RORHL02",,798,RORIEN)
"RTN","RORHL02",178,0)
 .I IEN7981 D  Q:RORRES<0
"RTN","RORHL02",179,0)
 ..S TMP=$$GET1^DIQ(798.1,IEN7981,"2","I",,"RORMSG")
"RTN","RORHL02",180,0)
 ..I $G(DIERR)  D  Q
"RTN","RORHL02",181,0)
 ...S RORRES=$$DBS^RORERR("RORMSG",-9,"CSS^RORHL02",,798.1,IEN7981)
"RTN","RORHL02",182,0)
 ..S:TMP $P(RORSEG,HLFS,3)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL02",183,0)
 ;
"RTN","RORHL02",184,0)
 ;--- Store the segment in ^TMP("HLS",$J)
"RTN","RORHL02",185,0)
 D SETSEG^RORHL7(.RORPTR,.RORSEG)
"RTN","RORHL02",186,0)
 ;
"RTN","RORHL02",187,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL02",188,0)
 ;
"RTN","RORHL02",189,0)
GETAUTO(RORIEN,CS) ;
"RTN","RORHL02",190,0)
 ;  Patient added automatically so get automatic reason(s)
"RTN","RORHL02",191,0)
 ;  fopr addition into registry.
"RTN","RORHL02",192,0)
 ; Any Reasons ?
"RTN","RORHL02",193,0)
 ;
"RTN","RORHL02",194,0)
 N K4,RARRAY,RPNTR,VALUE,TMPIEN
"RTN","RORHL02",195,0)
 ;
"RTN","RORHL02",196,0)
 ; Remove "," from RORIEN.
"RTN","RORHL02",197,0)
 S TMPIEN=$TR(RORIEN,",")
"RTN","RORHL02",198,0)
 ;
"RTN","RORHL02",199,0)
 Q:$D(^RORDATA(798,TMPIEN,1,"B"))<10 ""
"RTN","RORHL02",200,0)
 ;
"RTN","RORHL02",201,0)
 S K4=0
"RTN","RORHL02",202,0)
 F  S K4=$O(^RORDATA(798,TMPIEN,1,K4))  Q:'K4  D
"RTN","RORHL02",203,0)
 . S RPNTR=$P(^RORDATA(798,TMPIEN,1,K4,0),"^")
"RTN","RORHL02",204,0)
 . S VALUE=$P($G(^ROR(798.2,RPNTR,0)),"^")
"RTN","RORHL02",205,0)
 . Q:VALUE=""
"RTN","RORHL02",206,0)
 . I VALUE="VA HEPC LAB"         S RARRAY("LAB")=""   Q
"RTN","RORHL02",207,0)
 . I VALUE="VA HEPC PROBLEM"     S RARRAY("ICD9")=""  Q
"RTN","RORHL02",208,0)
 . I VALUE="VA HEPC PTF"         S RARRAY("ICD9")=""  Q
"RTN","RORHL02",209,0)
 . I VALUE="VA HEPC PTF HIST"    S RARRAY("ICD9")=""  Q
"RTN","RORHL02",210,0)
 . I VALUE="VA HEPC VISIT HIST"  S RARRAY("ICD9")=""  Q
"RTN","RORHL02",211,0)
 . I VALUE="VA HEPC VPOV"        S RARRAY("ICD9")=""  Q
"RTN","RORHL02",212,0)
 ;
"RTN","RORHL02",213,0)
 I $D(RARRAY("ICD9")),$D(RARRAY("LAB")) Q "9"_CS_"Automatically Added - ICD9 and Lab"_CS_"99VA79832"
"RTN","RORHL02",214,0)
 Q:$D(RARRAY("LAB")) "8"_CS_"Automatically Added - Lab"_CS_"99VA79832"
"RTN","RORHL02",215,0)
 Q:$D(RARRAY("ICD9")) "7"_CS_"Automatically Added - ICD9"_CS_"99VA79832"
"RTN","RORHL02",216,0)
 ;
"RTN","RORHL02",217,0)
 Q ""
"RTN","RORHL03")
0^6^B65277671
"RTN","RORHL03",1,0)
RORHL03 ;HOIFO/CRT - Clinical Registries Segment APIs - OP PHARMACY ; 9/10/02 10:30am
"RTN","RORHL03",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORHL03",3,0)
 ;
"RTN","RORHL03",4,0)
 ; External reference to OCL^PSOORRL supported by DBIA 3142
"RTN","RORHL03",5,0)
 ; External reference to OEL^PSOORRL supported by DBIA 3143
"RTN","RORHL03",6,0)
 Q
"RTN","RORHL03",7,0)
 ;
"RTN","RORHL03",8,0)
EN1(RORDFN,RORSTDT,RORENDT,RORPTR,RORFILE,HLFS,HLECH) ;
"RTN","RORHL03",9,0)
 ; Search OP Pharmacy Data
"RTN","RORHL03",10,0)
 ;
"RTN","RORHL03",11,0)
 ; INPUT:  RORDFN - DFN on Patient File #2                     (Req'd)
"RTN","RORHL03",12,0)
 ;         RORSTDT - Start Date/Time          (Fileman format) (Req'd)
"RTN","RORHL03",13,0)
 ;         RORENDT - End Date/Time            (Fileman format) (Req'd)
"RTN","RORHL03",14,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)      (Opt'l)
"RTN","RORHL03",15,0)
 ;         HLFS - Field Separator. Defaults to |               (Opt'l)
"RTN","RORHL03",16,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&       (Opt'l)
"RTN","RORHL03",17,0)
 ;
"RTN","RORHL03",18,0)
 N II,RORRES,RORIEN,RORIENS,RORINC,RORMSG
"RTN","RORHL03",19,0)
 ;
"RTN","RORHL03",20,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL03",21,0)
 ;
"RTN","RORHL03",22,0)
 S RORRES=0
"RTN","RORHL03",23,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL03",24,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL03",25,0)
 ;
"RTN","RORHL03",26,0)
 S RORDFN=+$G(RORDFN)
"RTN","RORHL03",27,0)
 I '$D(^DPT(RORDFN)) D  Q RORRES
"RTN","RORHL03",28,0)
 .S RORRES=$$ERROR^RORERR(-36,"EN1^RORHL03",,RORDFN,2)
"RTN","RORHL03",29,0)
 ;
"RTN","RORHL03",30,0)
 K ^TMP("PS",$J)
"RTN","RORHL03",31,0)
 D OCL^PSOORRL(RORDFN,RORSTDT,RORENDT)                   ; DBIA #3142
"RTN","RORHL03",32,0)
 I '$D(^TMP("PS",$J)) Q RORRES
"RTN","RORHL03",33,0)
 M ^TMP($J,"ROR-PS")=^TMP("PS",$J)
"RTN","RORHL03",34,0)
 K ^TMP("PS",$J)
"RTN","RORHL03",35,0)
 ;
"RTN","RORHL03",36,0)
 S II=0 F  S II=$O(^TMP($J,"ROR-PS",II)) Q:'II  D  Q:RORRES<0
"RTN","RORHL03",37,0)
 .N RORRXE,RORIDATE
"RTN","RORHL03",38,0)
 .S RORIEN=$P(^TMP($J,"ROR-PS",II,0),"^",1)
"RTN","RORHL03",39,0)
 .Q:"R,U"'[$E($P(RORIEN,";"),$L($P(RORIEN,";")))
"RTN","RORHL03",40,0)
 .;
"RTN","RORHL03",41,0)
 .I $E($P(RORIEN,";"),$L($P(RORIEN,";")))="U" D  I ((RORIDATE<RORSTDT)!(RORIDATE'<RORENDT)) Q
"RTN","RORHL03",42,0)
 ..S RORIDATE=$P($G(^TMP($J,"ROR-PS",II,0)),"^",15)
"RTN","RORHL03",43,0)
 .I $E($P(RORIEN,";"),$L($P(RORIEN,";")))="R" D  Q:RORIDATE<RORSTDT
"RTN","RORHL03",44,0)
 ..S RORIDATE=$P($G(^TMP($J,"ROR-PS",II,0)),"^",10)
"RTN","RORHL03",45,0)
 .;
"RTN","RORHL03",46,0)
 .K ^TMP("PS",$J)
"RTN","RORHL03",47,0)
 .D OEL^PSOORRL(RORDFN,RORIEN)                            ; DBIA #3143
"RTN","RORHL03",48,0)
 .Q:'$D(^TMP("PS",$J))
"RTN","RORHL03",49,0)
 .M RORRXE=^TMP("PS",$J)
"RTN","RORHL03",50,0)
 .K ^TMP("PS",$J)
"RTN","RORHL03",51,0)
 .;
"RTN","RORHL03",52,0)
 .I $P(RORIEN,";",2)="O" D  Q:'RORINC
"RTN","RORHL03",53,0)
 ..N RORII,RORDATE
"RTN","RORHL03",54,0)
 ..D REFILL
"RTN","RORHL03",55,0)
 ..; Check if orginal presc or one of the refills falls within date range
"RTN","RORHL03",56,0)
 ..S RORINC=0
"RTN","RORHL03",57,0)
 ..S RORII="" F  S RORII=$O(RORRXE("REF",RORII)) Q:RORII=""  D
"RTN","RORHL03",58,0)
 ...S RORDATE=$P($G(RORRXE("REF",RORII,0)),"^",1)
"RTN","RORHL03",59,0)
 ...I ((RORDATE<RORSTDT)!(RORDATE'<RORENDT)) D  Q
"RTN","RORHL03",60,0)
 ....K RORRXE("REF",RORII,0)
"RTN","RORHL03",61,0)
 ...S RORINC=1
"RTN","RORHL03",62,0)
 .;
"RTN","RORHL03",63,0)
 .I $P(RORIEN,";",2)="O" D
"RTN","RORHL03",64,0)
 ..S RORIENS=+$P(RORIEN,";")
"RTN","RORHL03",65,0)
 ..S RORRES=$$ORC(RORIENS,.RORRXE,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL03",66,0)
 ..Q:RORRES<0
"RTN","RORHL03",67,0)
 ..S RORRES=$$RXE(RORIENS,.RORRXE,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL03",68,0)
 .E  D
"RTN","RORHL03",69,0)
 ..S RORIENS=+$P(RORIEN,";")_","_RORDFN_","
"RTN","RORHL03",70,0)
 ..S RORRES=$$ORC^RORHL07(RORIENS,.RORRXE,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL03",71,0)
 ..Q:RORRES<0
"RTN","RORHL03",72,0)
 ..S RORRES=$$RXE^RORHL07(RORIENS,.RORRXE,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL03",73,0)
 ;
"RTN","RORHL03",74,0)
 K ^TMP($J,"ROR-PS")
"RTN","RORHL03",75,0)
 ;
"RTN","RORHL03",76,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL03",77,0)
 ;
"RTN","RORHL03",78,0)
ORC(RORIEN,RORORC,RORPTR,RORFILE,HLFS,HLECH) ; ORC SEGMENT (OP Pharmacy Data)
"RTN","RORHL03",79,0)
 ;
"RTN","RORHL03",80,0)
 ; INPUT:  RORIEN - IEN of Record in Prescription File #52     (Req'd)
"RTN","RORHL03",81,0)
 ;         RORORC - Array containing info (from OEL^PSOORRL)   (Req'd)
"RTN","RORHL03",82,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)      (Opt'l)
"RTN","RORHL03",83,0)
 ;         HLFS - Field Separator. Defaults to |               (Opt'l)
"RTN","RORHL03",84,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&       (Opt'l)
"RTN","RORHL03",85,0)
 ;
"RTN","RORHL03",86,0)
 N CS,FLDS,IEN59,RORMSG,ROROUT,RORRES,RORSEG,TMP
"RTN","RORHL03",87,0)
 ;
"RTN","RORHL03",88,0)
 S RORRES=0
"RTN","RORHL03",89,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL03",90,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL03",91,0)
 ;
"RTN","RORHL03",92,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL03",93,0)
 S CS=$E(HLECH,1)
"RTN","RORHL03",94,0)
 ;
"RTN","RORHL03",95,0)
 S $P(RORSEG,HLFS,1)="ORC"
"RTN","RORHL03",96,0)
 ;
"RTN","RORHL03",97,0)
 ; ORC-1 - Order Control 
"RTN","RORHL03",98,0)
 S $P(RORSEG,HLFS,2)="NW"
"RTN","RORHL03",99,0)
 ;
"RTN","RORHL03",100,0)
 ; ORC-2 - Placer Order Number
"RTN","RORHL03",101,0)
 S $P(RORSEG,HLFS,3)=+RORIEN_CS_"OP"
"RTN","RORHL03",102,0)
 ;
"RTN","RORHL03",103,0)
 ; ORC-9 - Release Date/Time
"RTN","RORHL03",104,0)
 S TMP=$P($G(RORORC("RXN",0)),"^",2)
"RTN","RORHL03",105,0)
 S:TMP $P(RORSEG,HLFS,10)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL03",106,0)
 ;
"RTN","RORHL03",107,0)
 ; ORC-12 - Provider
"RTN","RORHL03",108,0)
 S $P(RORSEG,HLFS,13)=$P($G(RORORC("P",0)),"^")
"RTN","RORHL03",109,0)
 ;
"RTN","RORHL03",110,0)
 ; ORC-15 - Order Date/Time
"RTN","RORHL03",111,0)
 S TMP=$P($G(RORORC(0)),"^",5)
"RTN","RORHL03",112,0)
 S:TMP $P(RORSEG,HLFS,16)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL03",113,0)
 ;
"RTN","RORHL03",114,0)
 ; ORC-16 - Control Code Reason
"RTN","RORHL03",115,0)
 S $P(RORSEG,HLFS,17)=CS_CS_CS_CS_"NEW"
"RTN","RORHL03",116,0)
 ;
"RTN","RORHL03",117,0)
 ; ORC-17 - Division
"RTN","RORHL03",118,0)
 S $P(RORSEG,HLFS,18)=$$SITE^RORUTL03(CS)
"RTN","RORHL03",119,0)
 S TMP=""
"RTN","RORHL03",120,0)
 S IEN59=+$$GET1^DIQ(52,+RORIEN,20,"I",,"RORMSG")_","
"RTN","RORHL03",121,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ORC^RORHL03",,52,+RORIEN)
"RTN","RORHL03",122,0)
 D GETS^DIQ(59,IEN59,100,"IE","ROROUT","RORMSG")
"RTN","RORHL03",123,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ORC^RORHL03",,59,IEN59)
"RTN","RORHL03",124,0)
 S $P(TMP,CS,1)=$$GET1^DIQ(4,+$G(ROROUT(59,IEN59,100,"I")),99,"I")
"RTN","RORHL03",125,0)
 S $P(TMP,CS,2)=$G(ROROUT(59,IEN59,100,"E"))
"RTN","RORHL03",126,0)
 S $P(TMP,CS,3)="99VA4"
"RTN","RORHL03",127,0)
 S:$P(TMP,CS)]"" $P(RORSEG,HLFS,18)=TMP
"RTN","RORHL03",128,0)
 ;
"RTN","RORHL03",129,0)
 ;--- Store the segment
"RTN","RORHL03",130,0)
 D:$P($G(RORSEG),HLFS,3)]"" SETSEG^RORHL7(.RORPTR,.RORSEG,RORFILE)
"RTN","RORHL03",131,0)
 ;
"RTN","RORHL03",132,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL03",133,0)
 ;
"RTN","RORHL03",134,0)
RXE(RORIEN,RORRXE,RORPTR,RORFILE,HLFS,HLECH) ; RXE SEGMENT (OP Pharmacy Data)
"RTN","RORHL03",135,0)
 ;
"RTN","RORHL03",136,0)
 ; INPUT:  RORIEN - IEN of Record in Prescription File #52     (Req'd)
"RTN","RORHL03",137,0)
 ;         RORRXE - Array containing info (from OEL^PSOORRL)   (Req'd)
"RTN","RORHL03",138,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)      (Opt'l)
"RTN","RORHL03",139,0)
 ;         HLFS - Field Separator. Defaults to |               (Opt'l)
"RTN","RORHL03",140,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&       (Opt'l)
"RTN","RORHL03",141,0)
 ;
"RTN","RORHL03",142,0)
 N CS,II,RORMSG,ROROUT,RORRES,RORTEST
"RTN","RORHL03",143,0)
 ;
"RTN","RORHL03",144,0)
 S RORRES=0
"RTN","RORHL03",145,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL03",146,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL03",147,0)
 ;
"RTN","RORHL03",148,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL03",149,0)
 S CS=$E(HLECH,1)
"RTN","RORHL03",150,0)
 ;
"RTN","RORHL03",151,0)
 Q:$P($G(RORRXE(0)),"^",1)="" RORRES
"RTN","RORHL03",152,0)
 ;
"RTN","RORHL03",153,0)
 S II="" F  S II=$O(RORRXE("REF",II)) Q:II=""  D  Q:RORRES<0
"RTN","RORHL03",154,0)
 .S RORTEST=$G(RORRXE("REF",II,0)) I RORTEST="" Q
"RTN","RORHL03",155,0)
 .N CMOP,IDGN,INDF,J,RORLIST,RORSEG,TMP
"RTN","RORHL03",156,0)
 .;
"RTN","RORHL03",157,0)
 .S $P(RORSEG,HLFS,1)="RXE"
"RTN","RORHL03",158,0)
 .;
"RTN","RORHL03",159,0)
 .; RXE-1 - Quantity/Timing
"RTN","RORHL03",160,0)
 .S $P(RORSEG,HLFS,2)=""""""
"RTN","RORHL03",161,0)
 .;
"RTN","RORHL03",162,0)
 .; RXE-2 - Give Code
"RTN","RORHL03",163,0)
 .S TMP=""
"RTN","RORHL03",164,0)
 .S IDGN=+$P($G(RORRXE("DD",1,0)),"^",3)                ; File #50 IEN
"RTN","RORHL03",165,0)
 .S:'IDGN IDGN=+$P($G(RORRXE("DD",1,0)),"^",1)
"RTN","RORHL03",166,0)
 .S RORRES=$$RXE2(IDGN,CS,.TMP) Q:RORRES<0
"RTN","RORHL03",167,0)
 .S $P(RORSEG,HLFS,3)=TMP
"RTN","RORHL03",168,0)
 .;
"RTN","RORHL03",169,0)
 .; RXE-3 - Give Amount (Min)
"RTN","RORHL03",170,0)
 .S $P(RORSEG,HLFS,4)=""""""
"RTN","RORHL03",171,0)
 .;
"RTN","RORHL03",172,0)
 .; RXE-5 - Give Units
"RTN","RORHL03",173,0)
 .S INDF=+$$GET1^DIQ(50,IDGN,22,"I",,"RORMSG")_","  ; File #50.68 IEN
"RTN","RORHL03",174,0)
 .I $G(DIERR)  D  Q
"RTN","RORHL03",175,0)
 ..S RORRES=$$DBS^RORERR("RORMSG",-9,"RXE^RORHL03",,50,IDGN)
"RTN","RORHL03",176,0)
 .I INDF  D  Q:RORRES<0
"RTN","RORHL03",177,0)
 ..S TMP=""
"RTN","RORHL03",178,0)
 ..D GETS^DIQ(50.68,INDF,3,"IE","ROROUT","RORMSG")
"RTN","RORHL03",179,0)
 ..I $G(DIERR)  D  Q
"RTN","RORHL03",180,0)
 ...S RORRES=$$DBS^RORERR("RORMSG",-9,"RXE^RORHL03",,50.68,INDF)
"RTN","RORHL03",181,0)
 ..S $P(TMP,CS,4)=$G(ROROUT(50.68,INDF,3,"I"))
"RTN","RORHL03",182,0)
 ..S $P(TMP,CS,5)=$G(ROROUT(50.68,INDF,3,"E"))
"RTN","RORHL03",183,0)
 ..S $P(TMP,CS,6)="99PSU"
"RTN","RORHL03",184,0)
 ..S $P(RORSEG,HLFS,6)=TMP
"RTN","RORHL03",185,0)
 .;
"RTN","RORHL03",186,0)
 .; RXE-7 - SIG1
"RTN","RORHL03",187,0)
 .S $P(RORSEG,HLFS,8)=CS_$$ESCAPE^RORHL7($G(RORRXE("SIG",1,0)))
"RTN","RORHL03",188,0)
 .;
"RTN","RORHL03",189,0)
 .; RXE-10 - Dispense Amount
"RTN","RORHL03",190,0)
 .S $P(RORSEG,HLFS,11)=$P($G(RORRXE("REF",II,0)),"^",3)
"RTN","RORHL03",191,0)
 .;
"RTN","RORHL03",192,0)
 .; RXE-18 - Fill Date/Time
"RTN","RORHL03",193,0)
 .S TMP=$P($G(RORRXE("REF",II,0)),"^",1)
"RTN","RORHL03",194,0)
 .S:TMP $P(RORSEG,HLFS,19)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL03",195,0)
 .;
"RTN","RORHL03",196,0)
 .; RXE-19 - Daily Dose
"RTN","RORHL03",197,0)
 .S $P(RORSEG,HLFS,20)=$P($G(RORRXE("REF",II,0)),"^",2)
"RTN","RORHL03",198,0)
 .;
"RTN","RORHL03",199,0)
 .; RXE-20 - CMOP?
"RTN","RORHL03",200,0)
 .S TMP=0
"RTN","RORHL03",201,0)
 .D LIST^DIC(52.01,","_RORIEN_",","2;3","I",,,,,,,"RORLIST","RORMSG")
"RTN","RORHL03",202,0)
 .I $G(DIERR)  D  Q
"RTN","RORHL03",203,0)
 ..S RORRES=$$DBS^RORERR("RORMSG",-9,"RXE^RORHL03",,52.01)
"RTN","RORHL03",204,0)
 .S J=0 F  S J=$O(RORLIST("DILIST","ID",J)) Q:J=""  D  Q:TMP
"RTN","RORHL03",205,0)
 ..I $G(RORLIST("DILIST","ID",J,2))=II D
"RTN","RORHL03",206,0)
 ...S:$G(RORLIST("DILIST","ID",J,3))'=3 TMP=1
"RTN","RORHL03",207,0)
 .S $P(RORSEG,HLFS,21)=$S(TMP=1:"Y",1:"N")
"RTN","RORHL03",208,0)
 .;
"RTN","RORHL03",209,0)
 .; RXE-30 Mail/Window
"RTN","RORHL03",210,0)
 .S TMP=$P($G(RORRXE("REF",II,0)),"^",5)
"RTN","RORHL03",211,0)
 .S $P(RORSEG,HLFS,31)=$S(TMP="M":"AD",TMP="W":"TR",1:"")
"RTN","RORHL03",212,0)
 .;
"RTN","RORHL03",213,0)
 .;--- Store the segment
"RTN","RORHL03",214,0)
 .D SETSEG^RORHL7(.RORPTR,.RORSEG,RORFILE)
"RTN","RORHL03",215,0)
 ;
"RTN","RORHL03",216,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL03",217,0)
 ;
"RTN","RORHL03",218,0)
REFILL ; Make orginal fill like refills to reuse code
"RTN","RORHL03",219,0)
 S RORRXE("REF",0,0)=""
"RTN","RORHL03",220,0)
 S $P(RORRXE("REF",0,0),"^",1)=$P(RORRXE("RXN",0),"^",6)
"RTN","RORHL03",221,0)
 S $P(RORRXE("REF",0,0),"^",2)=$P(RORRXE(0),"^",7)
"RTN","RORHL03",222,0)
 S $P(RORRXE("REF",0,0),"^",3)=$P(RORRXE(0),"^",8)
"RTN","RORHL03",223,0)
 S $P(RORRXE("REF",0,0),"^",4)=$P(RORRXE("RXN",0),"^",7)
"RTN","RORHL03",224,0)
 S $P(RORRXE("REF",0,0),"^",5)=$P(RORRXE("RXN",0),"^",3)
"RTN","RORHL03",225,0)
 Q
"RTN","RORHL03",226,0)
 ;
"RTN","RORHL03",227,0)
RXE2(IDGN,CS,RXE2) ; RXE-2 Give Code
"RTN","RORHL03",228,0)
 ;
"RTN","RORHL03",229,0)
 ; INPUT:  IDGN - IEN of Drug File #50                        (Req'd)
"RTN","RORHL03",230,0)
 ;         CS - Component Separator (defaults to "^")         (Opt'l)
"RTN","RORHL03",231,0)
 ;         RXE2 - RXE-2 Field (Call by reference)
"RTN","RORHL03",232,0)
 ;
"RTN","RORHL03",233,0)
 N INDF,RORMSG,ROROUT,RORRES,TMP
"RTN","RORHL03",234,0)
 ;
"RTN","RORHL03",235,0)
 S RORRES=0
"RTN","RORHL03",236,0)
 S RXE2=""
"RTN","RORHL03",237,0)
 ;
"RTN","RORHL03",238,0)
 S CS=$G(CS) S:CS="" CS="^"
"RTN","RORHL03",239,0)
 S IDGN=+$G(IDGN)_","                                    ; File 50 IEN
"RTN","RORHL03",240,0)
 ;
"RTN","RORHL03",241,0)
 D GETS^DIQ(50,IDGN,".01;2;20;22;27;31","IE","ROROUT","RORMSG")
"RTN","RORHL03",242,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"RXE2^RORHL03",,50,IDGN)
"RTN","RORHL03",243,0)
 ;
"RTN","RORHL03",244,0)
 S INDF=+$G(ROROUT(50,IDGN,22,"I"))_","               ; File 50.68 IEN
"RTN","RORHL03",245,0)
 ;
"RTN","RORHL03",246,0)
 I INDF  D  Q:RORRES<0 RORRES
"RTN","RORHL03",247,0)
 . D GETS^DIQ(50.68,INDF,".01;6","E","ROROUT","RORMSG")
"RTN","RORHL03",248,0)
 . Q:'$G(DIERR)
"RTN","RORHL03",249,0)
 . S RORRES=$$DBS^RORERR("RORMSG",-9,"RXE2^RORHL03",,50.68,INDF)
"RTN","RORHL03",250,0)
 ;
"RTN","RORHL03",251,0)
 S $P(RXE2,CS)=$G(ROROUT(50,IDGN,31,"E"))        ; NDC
"RTN","RORHL03",252,0)
 ;
"RTN","RORHL03",253,0)
 S $P(RXE2,CS,2)=$G(ROROUT(50.68,INDF,.01,"E"))  ; VA Product Name
"RTN","RORHL03",254,0)
 ;
"RTN","RORHL03",255,0)
 S $P(RXE2,CS,3)="PSNDF"
"RTN","RORHL03",256,0)
 ;
"RTN","RORHL03",257,0)
 S TMP=""
"RTN","RORHL03",258,0)
 S $P(TMP,"-",1)=$G(ROROUT(50,IDGN,20,"I"))      ; VA Drug Code
"RTN","RORHL03",259,0)
 S $P(TMP,"-",2)=$G(ROROUT(50,IDGN,2,"E"))       ; VA Drug Class
"RTN","RORHL03",260,0)
 S $P(RXE2,CS,4)=TMP
"RTN","RORHL03",261,0)
 ;
"RTN","RORHL03",262,0)
 S $P(RXE2,CS,5)=$G(ROROUT(50,IDGN,.01,"E"))     ; Drug Name
"RTN","RORHL03",263,0)
 ;
"RTN","RORHL03",264,0)
 S $P(RXE2,CS,6)="99PSD"
"RTN","RORHL03",265,0)
 ;
"RTN","RORHL03",266,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL04")
0^7^B13913817
"RTN","RORHL04",1,0)
RORHL04 ;HOIFO/CRT - Clinical Registries Segment APIs - RADIOLOGY ; 8/16/02 12:52pm
"RTN","RORHL04",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORHL04",3,0)
 ;
"RTN","RORHL04",4,0)
 Q
"RTN","RORHL04",5,0)
 ;
"RTN","RORHL04",6,0)
EN1(RORDFN,RORSTDT,RORENDT,RORPTR,RORFILE,HLFS,HLECH) ;
"RTN","RORHL04",7,0)
 ; Search Radiology for Data
"RTN","RORHL04",8,0)
 ;
"RTN","RORHL04",9,0)
 ; INPUT:  RORDFN - DFN of Patient in File #2                  (Req'd)
"RTN","RORHL04",10,0)
 ;         RORSTDT - Start Date (FileMan Format)               (Req'd)
"RTN","RORHL04",11,0)
 ;         RORENDT - End Date   (FileMan Format)               (Req'd)
"RTN","RORHL04",12,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)      (Opt'l)
"RTN","RORHL04",13,0)
 ;         HLFS - Field Separator. Defaults to |               (Opt'l)
"RTN","RORHL04",14,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&       (Opt'l)
"RTN","RORHL04",15,0)
 ;
"RTN","RORHL04",16,0)
 N DATE,RACNI,RADPT,RADTI,RAIENS,RORRES
"RTN","RORHL04",17,0)
 ;
"RTN","RORHL04",18,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL04",19,0)
 ;
"RTN","RORHL04",20,0)
 S RORRES=0
"RTN","RORHL04",21,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL04",22,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL04",23,0)
 ;
"RTN","RORHL04",24,0)
 S RORDFN=+$G(RORDFN)
"RTN","RORHL04",25,0)
 I '$D(^DPT(RORDFN)) D  Q RORRES
"RTN","RORHL04",26,0)
 .S RORRES=$$ERROR^RORERR(-36,"EN1^RORHL04",,RORDFN,2)
"RTN","RORHL04",27,0)
 ;
"RTN","RORHL04",28,0)
 I '$D(^RADPT(RORDFN)) Q RORRES
"RTN","RORHL04",29,0)
 ;
"RTN","RORHL04",30,0)
 S DATE=$$FMADD^XLFDT(RORSTDT,,,,-1) ; Subtract 1 second
"RTN","RORHL04",31,0)
 F  S DATE=$O(^RADPT(RORDFN,"DT","B",DATE)) Q:DATE=""!(DATE'<RORENDT)  D  Q:RORRES<0
"RTN","RORHL04",32,0)
 .S RADTI=$O(^RADPT(RORDFN,"DT","B",DATE,0))
"RTN","RORHL04",33,0)
 .S RACNI=0
"RTN","RORHL04",34,0)
 .F  S RACNI=$O(^RADPT(RORDFN,"DT",RADTI,"P",RACNI)) Q:'+RACNI  D  Q:RORRES<0
"RTN","RORHL04",35,0)
 ..S RADPT=$G(^RADPT(RORDFN,"DT",RADTI,"P",RACNI,0)) Q:RADPT=""
"RTN","RORHL04",36,0)
 ..S RAIENS=RACNI_","_RADTI_","_RORDFN_","
"RTN","RORHL04",37,0)
 ..S RORRES=$$OBR(RAIENS,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL04",38,0)
 ;
"RTN","RORHL04",39,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL04",40,0)
 ;
"RTN","RORHL04",41,0)
OBR(RORIEN,RORPTR,RORFILE,HLFS,HLECH) ; OBR SEGMENT (Radiology Data)
"RTN","RORHL04",42,0)
 ;
"RTN","RORHL04",43,0)
 ; INPUT:  RORIEN - IENS of Radiology Record in File #70.03   (Req'd)
"RTN","RORHL04",44,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)     (Opt'l)
"RTN","RORHL04",45,0)
 ;         HLFS - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL04",46,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL04",47,0)
 ;
"RTN","RORHL04",48,0)
 N CS,IEN7002,RACN0,RADTE,RORMSG,ROROUT,RORRES,RORSEG,STR,TMP
"RTN","RORHL04",49,0)
 ;
"RTN","RORHL04",50,0)
 S RORRES=0
"RTN","RORHL04",51,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL04",52,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL04",53,0)
 ;
"RTN","RORHL04",54,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORHL04",55,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL04",56,0)
 S CS=$E(HLECH,1)
"RTN","RORHL04",57,0)
 ;
"RTN","RORHL04",58,0)
 D GETS^DIQ(70.03,RORIEN,".01;2;14","IE","ROROUT","RORMSG")
"RTN","RORHL04",59,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL04",,70.03,RORIEN)
"RTN","RORHL04",60,0)
 S IEN7002=$P(RORIEN,",",2,3)_","
"RTN","RORHL04",61,0)
 D GETS^DIQ(70.02,IEN7002,".01;3","IE","ROROUT","RORMSG")
"RTN","RORHL04",62,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL04",,70.02,IEN7002)
"RTN","RORHL04",63,0)
 ;
"RTN","RORHL04",64,0)
 S $P(RORSEG,HLFS,1)="OBR"
"RTN","RORHL04",65,0)
 ;
"RTN","RORHL04",66,0)
 ; OBR-3 - Unique Accession #
"RTN","RORHL04",67,0)
 S TMP=""
"RTN","RORHL04",68,0)
 S $P(TMP,CS,1)=$P(RORIEN,",",2)_"-"_$P(RORIEN,",",1)
"RTN","RORHL04",69,0)
 S RADTE=$P($G(ROROUT(70.02,IEN7002,.01,"I")),".")
"RTN","RORHL04",70,0)
 S RACN0=$G(ROROUT(70.03,RORIEN,.01,"I"))
"RTN","RORHL04",71,0)
 S $P(TMP,CS,2)=$E(RADTE,4,7)_$E(RADTE,2,3)_"-"_+RACN0
"RTN","RORHL04",72,0)
 S $P(TMP,CS,3)="L"
"RTN","RORHL04",73,0)
 S:$P(TMP,CS)'="" $P(RORSEG,HLFS,4)=TMP
"RTN","RORHL04",74,0)
 ;
"RTN","RORHL04",75,0)
 ; OBR-4 - Procedure & CPT Code
"RTN","RORHL04",76,0)
 S TMP=""
"RTN","RORHL04",77,0)
 S $P(TMP,CS,6)="99RAP"
"RTN","RORHL04",78,0)
 S $P(TMP,CS,5)=$$ESCAPE^RORHL7($G(ROROUT(70.03,RORIEN,2,"E")))
"RTN","RORHL04",79,0)
 S $P(TMP,CS,4)=$G(ROROUT(70.03,RORIEN,2,"I"))
"RTN","RORHL04",80,0)
 S $P(TMP,CS,3)="C4"
"RTN","RORHL04",81,0)
 S $P(TMP,CS,1)=$$GET1^DIQ(71,+$P(TMP,CS,4),9,"I",,"RORMSG")
"RTN","RORHL04",82,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL04",,71,+$P(TMP,CS,4))
"RTN","RORHL04",83,0)
 S STR=$$GET1^DIQ(81,+$P(TMP,CS,1),2,"E")
"RTN","RORHL04",84,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL04",,81,+$P(TMP,CS,1))
"RTN","RORHL04",85,0)
 S $P(TMP,CS,2)=$$ESCAPE^RORHL7(STR)
"RTN","RORHL04",86,0)
 S $P(RORSEG,HLFS,5)=TMP
"RTN","RORHL04",87,0)
 ;
"RTN","RORHL04",88,0)
 ; OBR-7 - Exam Date/Time
"RTN","RORHL04",89,0)
 S TMP=$G(ROROUT(70.02,IEN7002,.01,"I"))
"RTN","RORHL04",90,0)
 S:TMP $P(RORSEG,HLFS,8)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL04",91,0)
 ;
"RTN","RORHL04",92,0)
 ; OBR-16 - Requesting Physician
"RTN","RORHL04",93,0)
 S $P(RORSEG,HLFS,17)=$G(ROROUT(70.03,RORIEN,14,"I"))
"RTN","RORHL04",94,0)
 ;
"RTN","RORHL04",95,0)
 ; OBR-24 - Service Section ID
"RTN","RORHL04",96,0)
 S $P(RORSEG,HLFS,25)="RAD"
"RTN","RORHL04",97,0)
 ;
"RTN","RORHL04",98,0)
 ; OBR-44 - Division
"RTN","RORHL04",99,0)
 S $P(RORSEG,HLFS,45)=$$SITE1^RORUTL03(CS)
"RTN","RORHL04",100,0)
 S TMP=""
"RTN","RORHL04",101,0)
 S $P(TMP,CS,3)=$$GET1^DIQ(4,+$G(ROROUT(70.02,IEN7002,3,"I")),99,"I")
"RTN","RORHL04",102,0)
 S $P(TMP,CS,2)="99VA4"
"RTN","RORHL04",103,0)
 S $P(TMP,CS,1)=$G(ROROUT(70.02,IEN7002,3,"E"))
"RTN","RORHL04",104,0)
 S:$P(TMP,CS,3)]"" $P(RORSEG,HLFS,45)=TMP
"RTN","RORHL04",105,0)
 ;
"RTN","RORHL04",106,0)
 ;--- Store the segment
"RTN","RORHL04",107,0)
 D SETSEG^RORHL7(.RORPTR,.RORSEG,RORFILE)
"RTN","RORHL04",108,0)
 ;
"RTN","RORHL04",109,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL05")
0^8^B9095926
"RTN","RORHL05",1,0)
RORHL05 ;HOIFO/CRT - Clinical Registries Segment APIs - AUTOPSY ; 8/16/02 12:53pm
"RTN","RORHL05",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORHL05",3,0)
 ;
"RTN","RORHL05",4,0)
 ; External reference to LRDFN^LR7OR1 supported by DBIA 2503
"RTN","RORHL05",5,0)
 Q
"RTN","RORHL05",6,0)
 ;
"RTN","RORHL05",7,0)
EN1(RORDFN,RORPTR,RORFILE,HLFS,HLECH) ;
"RTN","RORHL05",8,0)
 ; Search Lab Data for Autopsy Info & Create OBR
"RTN","RORHL05",9,0)
 ;
"RTN","RORHL05",10,0)
 ; INPUT:  RORDFN - DFN of Patient in File #2                (Req'd)
"RTN","RORHL05",11,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)    (Opt'l)
"RTN","RORHL05",12,0)
 ;         HLFS - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL05",13,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL05",14,0)
 ;
"RTN","RORHL05",15,0)
 N RORIEN,LRDFN,RORRES
"RTN","RORHL05",16,0)
 ;
"RTN","RORHL05",17,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL05",18,0)
 ;
"RTN","RORHL05",19,0)
 S RORRES=0
"RTN","RORHL05",20,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL05",21,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL05",22,0)
 ;
"RTN","RORHL05",23,0)
 S RORDFN=+$G(RORDFN)
"RTN","RORHL05",24,0)
 I '$D(^DPT(RORDFN)) D  Q RORRES
"RTN","RORHL05",25,0)
 .S RORRES=$$ERROR^RORERR(-36,"EN1^RORHL05",,RORDFN,2)
"RTN","RORHL05",26,0)
 ;
"RTN","RORHL05",27,0)
 S LRDFN=+$$LRDFN^LR7OR1(RORDFN)                          ; DBIA #2503
"RTN","RORHL05",28,0)
 I 'LRDFN Q RORRES
"RTN","RORHL05",29,0)
 ;
"RTN","RORHL05",30,0)
 I $$GET1^DIQ(63,LRDFN,11,"I")'="" D
"RTN","RORHL05",31,0)
 .S RORRES=$$OBR(LRDFN,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL05",32,0)
 ;
"RTN","RORHL05",33,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL05",34,0)
 ;
"RTN","RORHL05",35,0)
OBR(LRDFN,RORPTR,RORFILE,FS,ECH) ; OBR SEGMENT (Autopsy Data)
"RTN","RORHL05",36,0)
 ;
"RTN","RORHL05",37,0)
 ; INPUT:  LRDFN - IEN of Lab Patient Record in File #63     (Req'd)
"RTN","RORHL05",38,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)    (Opt'l)
"RTN","RORHL05",39,0)
 ;         HLFS - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL05",40,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL05",41,0)
 ;
"RTN","RORHL05",42,0)
 N CS,FLDS,RORIEN,RORMSG,ROROUT,RORRES,RORSEG,TMP
"RTN","RORHL05",43,0)
 ;
"RTN","RORHL05",44,0)
 S RORRES=0
"RTN","RORHL05",45,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL05",46,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL05",47,0)
 ;
"RTN","RORHL05",48,0)
 S LRDFN=+$G(LRDFN)_","
"RTN","RORHL05",49,0)
 ;
"RTN","RORHL05",50,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL05",51,0)
 S CS=$E(HLECH,1)
"RTN","RORHL05",52,0)
 ;
"RTN","RORHL05",53,0)
 S FLDS="11;12.1;14;14.1"
"RTN","RORHL05",54,0)
 ;
"RTN","RORHL05",55,0)
 D GETS^DIQ(63,LRDFN,FLDS,"IE","ROROUT","RORMSG")
"RTN","RORHL05",56,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"EN1^RORHL05",,63,LRDFN)
"RTN","RORHL05",57,0)
 ;
"RTN","RORHL05",58,0)
 S $P(RORSEG,HLFS,1)="OBR"
"RTN","RORHL05",59,0)
 ;
"RTN","RORHL05",60,0)
 ; OBR-3 - Order #
"RTN","RORHL05",61,0)
 S $P(RORSEG,HLFS,4)=$G(ROROUT(63,LRDFN,14,"E"))
"RTN","RORHL05",62,0)
 ;
"RTN","RORHL05",63,0)
 ; OBR-4 - CPT Code
"RTN","RORHL05",64,0)
 S TMP=""
"RTN","RORHL05",65,0)
 S $P(TMP,CS,3)="C4"
"RTN","RORHL05",66,0)
 S $P(TMP,CS,1)=88099
"RTN","RORHL05",67,0)
 S $P(TMP,CS,2)=$$ESCAPE^RORHL7($$GET1^DIQ(81,88099,2,"E"))
"RTN","RORHL05",68,0)
 S $P(RORSEG,HLFS,5)=TMP
"RTN","RORHL05",69,0)
 ;
"RTN","RORHL05",70,0)
 ; OBR-7 - Autopsy Date/Time
"RTN","RORHL05",71,0)
 S TMP=$G(ROROUT(63,LRDFN,11,"I"))
"RTN","RORHL05",72,0)
 S:TMP $P(RORSEG,HLFS,8)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL05",73,0)
 ;
"RTN","RORHL05",74,0)
 ; OBR-16 - Ordering Provider
"RTN","RORHL05",75,0)
 S $P(RORSEG,HLFS,17)=$G(ROROUT(63,LRDFN,12.1,"I"))
"RTN","RORHL05",76,0)
 ;
"RTN","RORHL05",77,0)
 ; OBR-24 - Diagnostic Service ID
"RTN","RORHL05",78,0)
 S $P(RORSEG,HLFS,25)="SP"
"RTN","RORHL05",79,0)
 ;
"RTN","RORHL05",80,0)
 ; OBR-44 - Division
"RTN","RORHL05",81,0)
 S $P(RORSEG,HLFS,45)=$$SITE1^RORUTL03(CS)
"RTN","RORHL05",82,0)
 S TMP=""
"RTN","RORHL05",83,0)
 S RORIEN=$G(ROROUT(63,LRDFN,14.1,"I"))
"RTN","RORHL05",84,0)
 I RORIEN]"" D  Q:RORRES<0 RORRES
"RTN","RORHL05",85,0)
 .S RORIEN=+$O(^SC("B",RORIEN,0))
"RTN","RORHL05",86,0)
 .I RORIEN D
"RTN","RORHL05",87,0)
 ..S RORIEN=RORIEN_","
"RTN","RORHL05",88,0)
 ..D GETS^DIQ(44,RORIEN,3,"IE","ROROUT","RORMSG")
"RTN","RORHL05",89,0)
 ..I $G(DIERR)  D  Q
"RTN","RORHL05",90,0)
 ...S RORRES=$$DBS^RORERR("RORMSG",-9,"EN1^RORHL05",,44,RORIEN)
"RTN","RORHL05",91,0)
 ..S $P(TMP,CS,3)=$$GET1^DIQ(4,+$G(ROROUT(44,RORIEN,3,"I")),99,"I")
"RTN","RORHL05",92,0)
 ..S $P(TMP,CS,2)="99VA4"
"RTN","RORHL05",93,0)
 ..S $P(TMP,CS,1)=$G(ROROUT(44,RORIEN,3,"E"))
"RTN","RORHL05",94,0)
 S:$P(TMP,CS,3)]"" $P(RORSEG,HLFS,45)=TMP
"RTN","RORHL05",95,0)
 ;
"RTN","RORHL05",96,0)
 ;--- Store the segment
"RTN","RORHL05",97,0)
 D SETSEG^RORHL7(.RORPTR,.RORSEG,RORFILE)
"RTN","RORHL05",98,0)
 ;
"RTN","RORHL05",99,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL06")
0^9^B26538598
"RTN","RORHL06",1,0)
RORHL06 ;HOIFO/BH,CRT - Clinical Registries Segment APIs - Liver Biopsy ; 8/16/02 12:53pm
"RTN","RORHL06",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORHL06",3,0)
 ;
"RTN","RORHL06",4,0)
 ; External reference to LRDFN^LR7OR1 supported by DBIA 2503
"RTN","RORHL06",5,0)
 Q
"RTN","RORHL06",6,0)
 ;
"RTN","RORHL06",7,0)
EN1(RORDFN,RORSTDT,RORENDT,RORPTR,RORFILE,HLFS,HLECH) ;
"RTN","RORHL06",8,0)
 ; Search Liver Biopsy for Data
"RTN","RORHL06",9,0)
 ;
"RTN","RORHL06",10,0)
 ; INPUT:  RORDFN - DFN of Patient in File #2                 (Req'd)
"RTN","RORHL06",11,0)
 ;         RORSTDT - Start Date (FileMan Format)              (Req'd)
"RTN","RORHL06",12,0)
 ;         RORENDT - End Date   (FileMan Format)              (Req'd)
"RTN","RORHL06",13,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)     (Opt'l)
"RTN","RORHL06",14,0)
 ;         HLFS - Field Separator. Defaults to |              (Opt'l)
"RTN","RORHL06",15,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&      (Opt'l)
"RTN","RORHL06",16,0)
 ;
"RTN","RORHL06",17,0)
 N FLDS,K5,LRDFN,QUIT,RORIEN,RORRES,SPECIMEN
"RTN","RORHL06",18,0)
 ;
"RTN","RORHL06",19,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL06",20,0)
 ;
"RTN","RORHL06",21,0)
 S RORRES=0
"RTN","RORHL06",22,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL06",23,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL06",24,0)
 ;
"RTN","RORHL06",25,0)
 S RORDFN=+$G(RORDFN)
"RTN","RORHL06",26,0)
 I '$D(^DPT(RORDFN)) D  Q RORRES
"RTN","RORHL06",27,0)
 . S RORRES=$$ERROR^RORERR(-36,"EN1^RORHL05",,RORDFN,2)
"RTN","RORHL06",28,0)
 ;
"RTN","RORHL06",29,0)
 S LRDFN=+$$LRDFN^LR7OR1(RORDFN)                          ; DBIA #2503
"RTN","RORHL06",30,0)
 I 'LRDFN Q RORRES
"RTN","RORHL06",31,0)
 ;
"RTN","RORHL06",32,0)
 S FLDS="1.1;1.4"
"RTN","RORHL06",33,0)
 ;
"RTN","RORHL06",34,0)
 S RORENDT=$$INVDATE^RORUTL01(RORENDT)
"RTN","RORHL06",35,0)
 S RORSTDT=$$INVDATE^RORUTL01(RORSTDT)
"RTN","RORHL06",36,0)
 ;
"RTN","RORHL06",37,0)
 F  S RORENDT=$O(^LR(LRDFN,"SP",RORENDT)) Q:'RORENDT!(RORENDT>RORSTDT)  D  Q:RORRES<0
"RTN","RORHL06",38,0)
 .S K5=0,QUIT=0
"RTN","RORHL06",39,0)
 .F  S K5=$O(^LR(LRDFN,"SP",RORENDT,.1,K5)) Q:'K5  D  Q:QUIT  Q:RORRES<0
"RTN","RORHL06",40,0)
 ..S RORIEN=K5_","_RORENDT_","_LRDFN_","
"RTN","RORHL06",41,0)
 ..S SPECIMEN=$$GET1^DIQ(63.812,RORIEN,.01)
"RTN","RORHL06",42,0)
 ..I $$UP^XLFSTR(SPECIMEN)["LIVER" D
"RTN","RORHL06",43,0)
 ...S RORRES=$$OBR(RORENDT_","_LRDFN_",",.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL06",44,0)
 ...Q:RORRES<0
"RTN","RORHL06",45,0)
 ...S RORRES=$$OBX(RORENDT_","_LRDFN_",",FLDS,.RORPTR,RORFILE,HLFS,HLECH)
"RTN","RORHL06",46,0)
 ...Q:RORRES<0
"RTN","RORHL06",47,0)
 ...S QUIT=1
"RTN","RORHL06",48,0)
 ;
"RTN","RORHL06",49,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL06",50,0)
 ;
"RTN","RORHL06",51,0)
OBR(RORIEN,RORPTR,RORFILE,HLFS,HLECH) ; OBR SEGMENT (Liver Biopsy Data)
"RTN","RORHL06",52,0)
 ;
"RTN","RORHL06",53,0)
 ; INPUT:  RORIEN - IENS of Liver Biopsy Record in File #63.08 (Req'd)
"RTN","RORHL06",54,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)      (Opt'l)
"RTN","RORHL06",55,0)
 ;         HLFS - Field Separator. Defaults to |               (Opt'l)
"RTN","RORHL06",56,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&       (Opt'l)
"RTN","RORHL06",57,0)
 ;
"RTN","RORHL06",58,0)
 N CS,FLDS,IEN44,RORMSG,ROROUT,RORRES,RORSEG,TMP
"RTN","RORHL06",59,0)
 ;
"RTN","RORHL06",60,0)
 S RORRES=0
"RTN","RORHL06",61,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL06",62,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL06",63,0)
 ;
"RTN","RORHL06",64,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORHL06",65,0)
 ;
"RTN","RORHL06",66,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL06",67,0)
 S CS=$E(HLECH,1)
"RTN","RORHL06",68,0)
 ;
"RTN","RORHL06",69,0)
 S FLDS=".01;.06;.07;.08"
"RTN","RORHL06",70,0)
 ;
"RTN","RORHL06",71,0)
 D GETS^DIQ(63.08,RORIEN,FLDS,"IE","ROROUT","RORMSG")
"RTN","RORHL06",72,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL06",,63.08,RORIEN)
"RTN","RORHL06",73,0)
 ;
"RTN","RORHL06",74,0)
 S $P(RORSEG,HLFS,1)="OBR"
"RTN","RORHL06",75,0)
 ;
"RTN","RORHL06",76,0)
 ; OBR-3 - Surgical Path Acc #
"RTN","RORHL06",77,0)
 S $P(RORSEG,HLFS,4)=$G(ROROUT(63.08,RORIEN,.06,"E"))
"RTN","RORHL06",78,0)
 ;
"RTN","RORHL06",79,0)
 ; OBR-4 - Liver Biopsy CPT Code
"RTN","RORHL06",80,0)
 S TMP=""
"RTN","RORHL06",81,0)
 S $P(TMP,CS,1)=47000
"RTN","RORHL06",82,0)
 S $P(TMP,CS,2)=$$GET1^DIQ(81,47000,2,"E",,"RORMSG")
"RTN","RORHL06",83,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBR^RORHL06",,81,47000)
"RTN","RORHL06",84,0)
 S $P(TMP,CS,3)="C4"
"RTN","RORHL06",85,0)
 S $P(RORSEG,HLFS,5)=TMP
"RTN","RORHL06",86,0)
 ;
"RTN","RORHL06",87,0)
 ; OBR-7 - Date/Time Specimen Taken
"RTN","RORHL06",88,0)
 S TMP=$G(ROROUT(63.08,RORIEN,.01,"I"))
"RTN","RORHL06",89,0)
 S:TMP $P(RORSEG,HLFS,8)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL06",90,0)
 ;
"RTN","RORHL06",91,0)
 ; OBR-16 - Surgeon/Physican
"RTN","RORHL06",92,0)
 S $P(RORSEG,HLFS,17)=$G(ROROUT(63.08,RORIEN,.07,"I"))
"RTN","RORHL06",93,0)
 ;
"RTN","RORHL06",94,0)
 ; OBR-24 - Service Section ID
"RTN","RORHL06",95,0)
 S $P(RORSEG,HLFS,25)="SP"
"RTN","RORHL06",96,0)
 ;
"RTN","RORHL06",97,0)
 ; OBR-44 - Divsion
"RTN","RORHL06",98,0)
 S $P(RORSEG,HLFS,45)=$$SITE1^RORUTL03(CS)
"RTN","RORHL06",99,0)
 S TMP=""
"RTN","RORHL06",100,0)
 S IEN44=$G(ROROUT(63.08,RORIEN,.08,"E"))
"RTN","RORHL06",101,0)
 I IEN44]"" D  Q:RORRES<0 RORRES
"RTN","RORHL06",102,0)
 .S IEN44=+$O(^SC("B",IEN44,0))
"RTN","RORHL06",103,0)
 .I IEN44 D
"RTN","RORHL06",104,0)
 ..S IEN44=IEN44_","
"RTN","RORHL06",105,0)
 ..D GETS^DIQ(44,IEN44,3,"IE","ROROUT","RORMSG")
"RTN","RORHL06",106,0)
 ..I $G(DIERR)  D  Q
"RTN","RORHL06",107,0)
 ...S RORRES=$$DBS^RORERR("RORMSG",-9,"EN1^RORHL05",,44,IEN44)
"RTN","RORHL06",108,0)
 ..S $P(TMP,CS,3)=$$GET1^DIQ(4,+$G(ROROUT(44,IEN44,3,"I")),99,"I")
"RTN","RORHL06",109,0)
 ..S $P(TMP,CS,2)="99VA4"
"RTN","RORHL06",110,0)
 ..S $P(TMP,CS,1)=$G(ROROUT(44,IEN44,3,"E"))
"RTN","RORHL06",111,0)
 S:$P(TMP,CS,3)]"" $P(RORSEG,HLFS,45)=TMP
"RTN","RORHL06",112,0)
 ;
"RTN","RORHL06",113,0)
 ;--- Store the segment
"RTN","RORHL06",114,0)
 D SETSEG^RORHL7(.RORPTR,.RORSEG,RORFILE)
"RTN","RORHL06",115,0)
 ;
"RTN","RORHL06",116,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL06",117,0)
 ;
"RTN","RORHL06",118,0)
OBX(RORIEN,RORFLDS,RORPTR,RORFILE,HLFS,HLECH) ; OBX SEGMENT(S) (Liver Biopsy)
"RTN","RORHL06",119,0)
 ;
"RTN","RORHL06",120,0)
 ; INPUT:  RORIEN - IENS of Liver Biopsy Record in 63.08       (Req'd)
"RTN","RORHL06",121,0)
 ;         RORFLDS - List of WP fields to return as OBX'es     (Req'd)
"RTN","RORHL06",122,0)
 ;                   Delimited by ';'    eg. "1.1;1.4"
"RTN","RORHL06",123,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)      (Opt'l)
"RTN","RORHL06",124,0)
 ;         HLFS - Field Separator. Defaults to |               (Opt'l)
"RTN","RORHL06",125,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&       (Opt'l)
"RTN","RORHL06",126,0)
 ;
"RTN","RORHL06",127,0)
 N CNT,CS,FLD,I,PZ,RORMSG,ROROUT,RORRES,RORSEG,SCS,TMP
"RTN","RORHL06",128,0)
 ;
"RTN","RORHL06",129,0)
 S RORRES=0
"RTN","RORHL06",130,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL06",131,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL06",132,0)
 ;
"RTN","RORHL06",133,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORHL06",134,0)
 ;
"RTN","RORHL06",135,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL06",136,0)
 S CS=$E(HLECH),SCS=$E(HLECH,4)
"RTN","RORHL06",137,0)
 ;
"RTN","RORHL06",138,0)
 D GETS^DIQ(63.08,RORIEN,RORFLDS,"IE","ROROUT","RORMSG")
"RTN","RORHL06",139,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"OBX^RORHL06",,63.08,RORIEN)
"RTN","RORHL06",140,0)
 ;
"RTN","RORHL06",141,0)
 S $P(RORSEG,HLFS,1)="OBX"
"RTN","RORHL06",142,0)
 ;
"RTN","RORHL06",143,0)
 ; OBX-2
"RTN","RORHL06",144,0)
 S $P(RORSEG,HLFS,3)="FT"
"RTN","RORHL06",145,0)
 ;
"RTN","RORHL06",146,0)
 ; OBX-11
"RTN","RORHL06",147,0)
 S $P(RORSEG,HLFS,12)="F"
"RTN","RORHL06",148,0)
 ;
"RTN","RORHL06",149,0)
 F PZ=1:1 S FLD=$P(RORFLDS,";",PZ) Q:FLD=""  D  Q:RORRES<0
"RTN","RORHL06",150,0)
 .S TMP=""
"RTN","RORHL06",151,0)
 .S $P(TMP,SCS,1)=47000
"RTN","RORHL06",152,0)
 .S $P(TMP,SCS,2)=$P($G(^DD(63.08,FLD,0)),"^")
"RTN","RORHL06",153,0)
 .S $P(TMP,CS,2)=$$GET1^DIQ(81,47000,2,"E",,"RORMSG")
"RTN","RORHL06",154,0)
 .I $G(DIERR)  D  Q
"RTN","RORHL06",155,0)
 ..S RORRES=$$DBS^RORERR("RORMSG",-9,"OBX^RORHL06",,81,47000)
"RTN","RORHL06",156,0)
 .S $P(TMP,CS,3)="C4"
"RTN","RORHL06",157,0)
 .S $P(RORSEG,HLFS,4)=TMP
"RTN","RORHL06",158,0)
 .K ^UTILITY($J,"W")
"RTN","RORHL06",159,0)
 .N DIWL,DIWF,DIWR S DIWL=1,DIWR=72
"RTN","RORHL06",160,0)
 .S I=0 F  S I=$O(ROROUT(63.08,RORIEN,FLD,I)) Q:'I  D
"RTN","RORHL06",161,0)
 ..S X=ROROUT(63.08,RORIEN,FLD,I)
"RTN","RORHL06",162,0)
 ..D ^DIWP
"RTN","RORHL06",163,0)
 .S I=0 F  S I=$O(^UTILITY($J,"W",DIWL,I)) Q:'I  D
"RTN","RORHL06",164,0)
 ..S CNT=$G(CNT)+1
"RTN","RORHL06",165,0)
 ..S $P(RORSEG,HLFS,2)=CNT
"RTN","RORHL06",166,0)
 ..S $P(RORSEG,HLFS,6)=$G(^UTILITY($J,"W",DIWL,I,0))
"RTN","RORHL06",167,0)
 ..;
"RTN","RORHL06",168,0)
 ..;--- Store the segment
"RTN","RORHL06",169,0)
 ..D SETSEG^RORHL7(.RORPTR,.RORSEG,RORFILE)
"RTN","RORHL06",170,0)
 ;
"RTN","RORHL06",171,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL07")
0^10^B15756858
"RTN","RORHL07",1,0)
RORHL07 ;HOIFO/BH - Clinical Registries Segment APIs - IP Pharmacy ; 9/10/02 10:50am
"RTN","RORHL07",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORHL07",3,0)
 ;
"RTN","RORHL07",4,0)
 Q
"RTN","RORHL07",5,0)
 ;
"RTN","RORHL07",6,0)
ORC(RORIEN,RORORC,RORPTR,RORFILE,HLFS,HLECH) ; ORC SEGMENT (IP Pharmacy Data)
"RTN","RORHL07",7,0)
 ;
"RTN","RORHL07",8,0)
 ; INPUT:  RORIEN - IEN of Unit/Dose in subfile #55.06        (Req'd)
"RTN","RORHL07",9,0)
 ;         RORORC - Array containing info (from OEL^PSJORRL)  (Req'd)
"RTN","RORHL07",10,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)     (Opt'l)
"RTN","RORHL07",11,0)
 ;         HLFS - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL07",12,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL07",13,0)
 ;
"RTN","RORHL07",14,0)
 N CS,FLDS,IEN42,IEN44,RORMSG,ROROUT,RORRES,RORSEG,TMP
"RTN","RORHL07",15,0)
 ;
"RTN","RORHL07",16,0)
 S RORRES=0
"RTN","RORHL07",17,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL07",18,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL07",19,0)
 ;
"RTN","RORHL07",20,0)
 S:$E(RORIEN,$L(RORIEN))'="," RORIEN=RORIEN_","
"RTN","RORHL07",21,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL07",22,0)
 S CS=$E(HLECH,1)
"RTN","RORHL07",23,0)
 ;
"RTN","RORHL07",24,0)
 S $P(RORSEG,HLFS,1)="ORC"
"RTN","RORHL07",25,0)
 ;
"RTN","RORHL07",26,0)
 ; ORC-1 - Order Control 
"RTN","RORHL07",27,0)
 S $P(RORSEG,HLFS,2)="NW"
"RTN","RORHL07",28,0)
 ;
"RTN","RORHL07",29,0)
 ; ORC-2 - Placer Order Number
"RTN","RORHL07",30,0)
 S $P(RORSEG,HLFS,3)=$P(RORIEN,",",1)_CS_"IP"
"RTN","RORHL07",31,0)
 ;
"RTN","RORHL07",32,0)
 ; ORC-12 - Provider
"RTN","RORHL07",33,0)
 S $P(RORSEG,HLFS,13)=$P($G(RORORC("P",0)),"^")
"RTN","RORHL07",34,0)
 ;
"RTN","RORHL07",35,0)
 ; ORC-15 - Order Date/Time
"RTN","RORHL07",36,0)
 S TMP=$P($G(RORORC(0)),"^",5)
"RTN","RORHL07",37,0)
 S:TMP $P(RORSEG,HLFS,16)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL07",38,0)
 ;
"RTN","RORHL07",39,0)
 ; ORC-16 - Control Code Reason
"RTN","RORHL07",40,0)
 S $P(RORSEG,HLFS,17)=CS_CS_CS_CS_"NEW"
"RTN","RORHL07",41,0)
 ;
"RTN","RORHL07",42,0)
 ; ORC-17 - Division
"RTN","RORHL07",43,0)
 S $P(RORSEG,HLFS,18)=$$SITE^RORUTL03(CS)
"RTN","RORHL07",44,0)
 S TMP=""
"RTN","RORHL07",45,0)
 S IEN42=+$G(ROROUT(55.06,RORIEN,9,"I"))
"RTN","RORHL07",46,0)
 I IEN42 D  Q:RORRES<0 RORRES
"RTN","RORHL07",47,0)
 .S IEN44=+$$GET1^DIQ(42,IEN42,44,"I",,"RORMSG")
"RTN","RORHL07",48,0)
 .I $G(DIERR)  D  Q
"RTN","RORHL07",49,0)
 ..S RORRES=$$DBS^RORERR("RORMSG",-9,"ORC^RORHL03",,42,IEN42)
"RTN","RORHL07",50,0)
 .I IEN44 D  Q:RORRES<0
"RTN","RORHL07",51,0)
 ..S IEN44=IEN44_","
"RTN","RORHL07",52,0)
 ..D GETS^DIQ(44,IEN44,3,"IE","ROROUT","RORMSG")
"RTN","RORHL07",53,0)
 ..I $G(DIERR)  D  Q
"RTN","RORHL07",54,0)
 ...S RORRES=$$DBS^RORERR("RORMSG",-9,"ORC^RORHL03",,44,IEN44)
"RTN","RORHL07",55,0)
 ..S $P(TMP,CS,1)=$$GET1^DIQ(4,+$G(ROROUT(44,IEN44,3,"I")),99,"I")
"RTN","RORHL07",56,0)
 ..S $P(TMP,CS,2)=$G(ROROUT(44,IEN44,3,"E"))
"RTN","RORHL07",57,0)
 ..S $P(TMP,CS,3)="99VA4"
"RTN","RORHL07",58,0)
 S:$P(TMP,CS,1)]"" $P(RORSEG,HLFS,18)=TMP
"RTN","RORHL07",59,0)
 ;
"RTN","RORHL07",60,0)
 ;--- Store the segment
"RTN","RORHL07",61,0)
 D:$P($G(RORSEG),HLFS,3)]"" SETSEG^RORHL7(.RORPTR,.RORSEG,RORFILE)
"RTN","RORHL07",62,0)
 ;
"RTN","RORHL07",63,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL07",64,0)
 ;
"RTN","RORHL07",65,0)
RXE(RORIEN,RORRXE,RORPTR,RORFILE,HLFS,HLECH) ; RXE SEGMENT (IP Pharmacy Data)
"RTN","RORHL07",66,0)
 ;
"RTN","RORHL07",67,0)
 ; INPUT:  RORIEN - IENS of Pharmacy Record in subfile #55.06 (Req'd)
"RTN","RORHL07",68,0)
 ;         RORRXE - Array containing info (from OEL^PSJORRL)  (Req'd)
"RTN","RORHL07",69,0)
 ;         RORFILE - Output File - Default:^TMP("HLS",$J)     (Opt'l)
"RTN","RORHL07",70,0)
 ;         HLFS - Field Separator. Defaults to |             (Opt'l)
"RTN","RORHL07",71,0)
 ;         HLECH - Encoding Characters. Deafults to ^~\&     (Opt'l)
"RTN","RORHL07",72,0)
 ;
"RTN","RORHL07",73,0)
 N CS,II,RORMSG,ROROUT,RORRES,TMP
"RTN","RORHL07",74,0)
 ;
"RTN","RORHL07",75,0)
 S RORRES=0
"RTN","RORHL07",76,0)
 S:$G(RORFILE)="" RORFILE=$NA(^TMP("HLS",$J))
"RTN","RORHL07",77,0)
 I $G(RORPTR)'>0  K @RORFILE  S RORPTR=0
"RTN","RORHL07",78,0)
 ;
"RTN","RORHL07",79,0)
 S:$G(HLFS)="" HLFS="|"  S:$G(HLECH)="" HLECH="^~\&"
"RTN","RORHL07",80,0)
 S CS=$E(HLECH,1)
"RTN","RORHL07",81,0)
 ;
"RTN","RORHL07",82,0)
 Q:$P($G(RORRXE(0)),"^")="" RES
"RTN","RORHL07",83,0)
 ;
"RTN","RORHL07",84,0)
 S II=0 F  S II=$O(RORRXE("DD",II)) Q:II=""  D  Q:RORRES<0
"RTN","RORHL07",85,0)
 .N RORSEG,IDGN,INDF
"RTN","RORHL07",86,0)
 .;
"RTN","RORHL07",87,0)
 .S $P(RORSEG,HLFS,1)="RXE"
"RTN","RORHL07",88,0)
 .;
"RTN","RORHL07",89,0)
 .; RXE-1 - Quantity/Timing
"RTN","RORHL07",90,0)
 .S $P(RORSEG,HLFS,2)=""""""
"RTN","RORHL07",91,0)
 .;
"RTN","RORHL07",92,0)
 .; RXE-2 - Give Code
"RTN","RORHL07",93,0)
 .S IDGN=+$P($G(RORRXE("DD",II,0)),"^")
"RTN","RORHL07",94,0)
 .S:'IDGN IDGN=+$P($G(RORRXE("DD",II,0)),"^",3)
"RTN","RORHL07",95,0)
 .S RORRES=$$RXE2^RORHL03(IDGN,CS,.TMP) Q:RORRES<0
"RTN","RORHL07",96,0)
 .S $P(RORSEG,HLFS,3)=TMP
"RTN","RORHL07",97,0)
 .;
"RTN","RORHL07",98,0)
 .; RXE-3 - Give Amount (Min)
"RTN","RORHL07",99,0)
 .S $P(RORSEG,HLFS,4)=""""""
"RTN","RORHL07",100,0)
 .;
"RTN","RORHL07",101,0)
 .; RXE-5 - Give Units
"RTN","RORHL07",102,0)
 .S INDF=+$$GET1^DIQ(50,IDGN,22,"I",,"RORMSG")_"," ; File #50.68 IEN
"RTN","RORHL07",103,0)
 .I $G(DIERR)  D  Q
"RTN","RORHL07",104,0)
 ..S RORRES=$$DBS^RORERR("RORMSG",-9,"RXE^RORHL03",,50,IDGN)
"RTN","RORHL07",105,0)
 .I INDF  D  Q:RORRES<0
"RTN","RORHL07",106,0)
 ..S TMP=""
"RTN","RORHL07",107,0)
 ..D GETS^DIQ(50.68,INDF,3,"IE","ROROUT","RORMSG")
"RTN","RORHL07",108,0)
 ..I $G(DIERR)  D  Q
"RTN","RORHL07",109,0)
 ...S RORRES=$$DBS^RORERR("RORMSG",-9,"RXE^RORHL03",,50.68,INDF)
"RTN","RORHL07",110,0)
 ..S $P(TMP,CS,4)=$G(ROROUT(50.68,INDF,3,"I"))
"RTN","RORHL07",111,0)
 ..S $P(TMP,CS,5)=$G(ROROUT(50.68,INDF,3,"E"))
"RTN","RORHL07",112,0)
 ..S $P(TMP,CS,6)="99PSU"
"RTN","RORHL07",113,0)
 ..S $P(RORSEG,HLFS,6)=TMP
"RTN","RORHL07",114,0)
 .;
"RTN","RORHL07",115,0)
 .; RXE-18 - Stop Date/Time
"RTN","RORHL07",116,0)
 .S TMP=$P($G(RORRXE(0)),"^",3)
"RTN","RORHL07",117,0)
 .S:TMP $P(RORSEG,HLFS,19)=$$FMTHL7^XLFDT(TMP)
"RTN","RORHL07",118,0)
 .;
"RTN","RORHL07",119,0)
 .; RXE-24 - Units per dose
"RTN","RORHL07",120,0)
 .S $P(RORSEG,HLFS,25)=$P($G(RORRXE("DD",II,0)),"^",2)
"RTN","RORHL07",121,0)
 .;
"RTN","RORHL07",122,0)
 .;--- Store the segment
"RTN","RORHL07",123,0)
 .D SETSEG^RORHL7(.RORPTR,.RORSEG,RORFILE)
"RTN","RORHL07",124,0)
 ;
"RTN","RORHL07",125,0)
 Q $S(RORRES<0:RORRES,1:0)
"RTN","RORHL7")
0^3^B34779035
"RTN","RORHL7",1,0)
RORHL7 ;HCIOFO/SG - HL7 TRANSMISSION ; 8/28/02 1:51pm
"RTN","RORHL7",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORHL7",3,0)
 ;
"RTN","RORHL7",4,0)
 Q
"RTN","RORHL7",5,0)
 ;
"RTN","RORHL7",6,0)
 ;***** RETURNS THE BHS SEGMENT
"RTN","RORHL7",7,0)
 ;
"RTN","RORHL7",8,0)
 ; BID           Batch message ID
"RTN","RORHL7",9,0)
 ;
"RTN","RORHL7",10,0)
 ; [BDT]         Batch message creation time in internal FileMan
"RTN","RORHL7",11,0)
 ;               format (NOW by default)
"RTN","RORHL7",12,0)
 ;
"RTN","RORHL7",13,0)
 ; [COMMENT]     Optional comment
"RTN","RORHL7",14,0)
 ;
"RTN","RORHL7",15,0)
 ; The RORHL local variable must be initialized by the $$INIT^RORHL7
"RTN","RORHL7",16,0)
 ; function before calling this entry point.
"RTN","RORHL7",17,0)
 ;
"RTN","RORHL7",18,0)
BHS(BID,BDT,COMMENT) ;
"RTN","RORHL7",19,0)
 N SEG
"RTN","RORHL7",20,0)
 D BHS^HLFNC3(.RORHL,BID,.SEG)
"RTN","RORHL7",21,0)
 Q:$G(SEG)="" ""
"RTN","RORHL7",22,0)
 ;---
"RTN","RORHL7",23,0)
 S SEG=SEG_$G(SEG(1))
"RTN","RORHL7",24,0)
 S:$G(BDT)'>0 BDT=$$NOW^XLFDT
"RTN","RORHL7",25,0)
 S $P(SEG,RORHL("FS"),7)=$$FMTHL7^XLFDT(BDT)
"RTN","RORHL7",26,0)
 S $P(SEG,RORHL("FS"),10)=$G(COMMENT)
"RTN","RORHL7",27,0)
 Q SEG
"RTN","RORHL7",28,0)
 ;
"RTN","RORHL7",29,0)
 ;***** RETURNS BTS SEGMENT
"RTN","RORHL7",30,0)
 ;
"RTN","RORHL7",31,0)
 ; MSGCNT        Batch message count
"RTN","RORHL7",32,0)
 ; [COMMENT]     Batch comment
"RTN","RORHL7",33,0)
 ;
"RTN","RORHL7",34,0)
 ; The RORHL variable must be initialized by the INIT^HLFNC2 before
"RTN","RORHL7",35,0)
 ; calling this entry point
"RTN","RORHL7",36,0)
 ;
"RTN","RORHL7",37,0)
BTS(MSGCNT,COMMENT) ;
"RTN","RORHL7",38,0)
 Q "BTS"_RORHL("FS")_MSGCNT_RORHL("FS")_$G(COMMENT)
"RTN","RORHL7",39,0)
 ;
"RTN","RORHL7",40,0)
 ;***** CREATES A NEW MESSAGE IN THE BATCH
"RTN","RORHL7",41,0)
 ;
"RTN","RORHL7",42,0)
 ; The function adds a new message header to the batch. If the batch
"RTN","RORHL7",43,0)
 ; does not exist yet, it is created.
"RTN","RORHL7",44,0)
 ;
"RTN","RORHL7",45,0)
 ; [.RORMSH]     Reference to a variable in what a MSH segment of
"RTN","RORHL7",46,0)
 ;               the message is returned.
"RTN","RORHL7",47,0)
 ;
"RTN","RORHL7",48,0)
 ; Return Values:
"RTN","RORHL7",49,0)
 ;        <0  Error Code
"RTN","RORHL7",50,0)
 ;        >0  Index of a subnode of the ^TMP("HLS",$J) that
"RTN","RORHL7",51,0)
 ;            contains the new MSH segment.
"RTN","RORHL7",52,0)
 ;
"RTN","RORHL7",53,0)
 ; MSH segment is returned as a value of the RORMSH parameter. In case
"RTN","RORHL7",54,0)
 ; of a long segment, continuations are returned as subnodes.
"RTN","RORHL7",55,0)
 ;
"RTN","RORHL7",56,0)
 ; Several nodes (HL7*) in ROREXT are set and the ^TMP("HLS",$J) node
"RTN","RORHL7",57,0)
 ; is deleted by this entry point before it creates a new batch.
"RTN","RORHL7",58,0)
 ;
"RTN","RORHL7",59,0)
CREATE(RORMSH) ;
"RTN","RORHL7",60,0)
 N NDX,RC,TMP  K RORMSH
"RTN","RORHL7",61,0)
 Q:$G(ROREXT("HL7PROT"))="" $$ERROR^RORERR(-25,"CREATE^RORHL7")
"RTN","RORHL7",62,0)
 ;--- Create a message stub for the new batch message
"RTN","RORHL7",63,0)
 ;    (if it has not been created before)
"RTN","RORHL7",64,0)
 I '$G(ROREXT("HL7MTIEN"))  D  Q:$G(RC)<0 RC
"RTN","RORHL7",65,0)
 . N RORMID,RORIEN,RORDT
"RTN","RORHL7",66,0)
 . ;--- Set up HL7 environment variables
"RTN","RORHL7",67,0)
 . S RC=$$INIT()  Q:RC<0
"RTN","RORHL7",68,0)
 . ;--- Create a stub
"RTN","RORHL7",69,0)
 . D CREATE^HLTF(.RORMID,.RORIEN,.RORDT)
"RTN","RORHL7",70,0)
 . ;--- Save parameters of the new batch message
"RTN","RORHL7",71,0)
 . S (ROREXT("HL7CNT"),ROREXT("HL7SIZE"))=0
"RTN","RORHL7",72,0)
 . S ROREXT("HL7DT")=RORDT
"RTN","RORHL7",73,0)
 . S ROREXT("HL7MID")=RORMID
"RTN","RORHL7",74,0)
 . S ROREXT("HL7MTIEN")=RORIEN
"RTN","RORHL7",75,0)
 . ;--- Initialize temporary storage
"RTN","RORHL7",76,0)
 . K ^TMP("HLS",$J)
"RTN","RORHL7",77,0)
 ;--- Initialize the HL7 environment variables
"RTN","RORHL7",78,0)
 S RC=$$INIT()  Q:RC<0 RC
"RTN","RORHL7",79,0)
 ;--- Create and store a MSH segment for individual message
"RTN","RORHL7",80,0)
 S ROREXT("HL7CNT")=ROREXT("HL7CNT")+1
"RTN","RORHL7",81,0)
 S TMP=ROREXT("HL7MID")_"-"_ROREXT("HL7CNT")
"RTN","RORHL7",82,0)
 D MSH^HLFNC2(.RORHL,TMP,.RORMSH)
"RTN","RORHL7",83,0)
 S NDX=$O(^TMP("HLS",$J,""),-1)+1
"RTN","RORHL7",84,0)
 M ^TMP("HLS",$J,NDX)=RORMSH
"RTN","RORHL7",85,0)
 S ROREXT("HL7SIZE")=ROREXT("HL7SIZE")+$L(RORMSH)+$L($G(RORMSH(1)))+1
"RTN","RORHL7",86,0)
 Q NDX
"RTN","RORHL7",87,0)
 ;
"RTN","RORHL7",88,0)
 ;***** REPLACES ENCODING CHARACTERS WITH ESCAPE CODES
"RTN","RORHL7",89,0)
 ;
"RTN","RORHL7",90,0)
 ; STR           Source string
"RTN","RORHL7",91,0)
 ;
"RTN","RORHL7",92,0)
 ; The HLECH variable must be initialized (either by the INIT^HLFNC2
"RTN","RORHL7",93,0)
 ; or manually) before calling this function.
"RTN","RORHL7",94,0)
 ;
"RTN","RORHL7",95,0)
 ; The function returns the source string with encoding
"RTN","RORHL7",96,0)
 ; characters replaced with corresponding escape codes.
"RTN","RORHL7",97,0)
 ;
"RTN","RORHL7",98,0)
ESCAPE(STR) ;
"RTN","RORHL7",99,0)
 Q:STR="" STR
"RTN","RORHL7",100,0)
 N BUF,ESC,CH,I1,I2
"RTN","RORHL7",101,0)
 ;--- Find all occurrences of encoding characters and
"RTN","RORHL7",102,0)
 ;    save their positions to a local array
"RTN","RORHL7",103,0)
 F I1=1:1:4  S CH=$E(HLECH,I1),I2=1  Q:CH=""  D
"RTN","RORHL7",104,0)
 . F  S I2=$F(STR,CH,I2)  Q:'I2  S BUF(I2-1)=I1
"RTN","RORHL7",105,0)
 Q:$D(BUF)<10 STR
"RTN","RORHL7",106,0)
 ;--- Replace encoding characters with escape codes
"RTN","RORHL7",107,0)
 S (BUF,I2)="",ESC=$E(HLECH,3)  S:ESC="" ESC="\"
"RTN","RORHL7",108,0)
 F  S I1=I2,I2=$O(BUF(I2))  Q:I2=""  D
"RTN","RORHL7",109,0)
 . S BUF=BUF_$E(STR,I1+1,I2-1)_ESC_$E("SRET",BUF(I2))_ESC
"RTN","RORHL7",110,0)
 Q BUF_$E(STR,I1+1,$L(STR))
"RTN","RORHL7",111,0)
 ;
"RTN","RORHL7",112,0)
 ;***** INITIALIZES RORHL ARRAY WITH HL7 ENVIRONMENT PARAMETERS
"RTN","RORHL7",113,0)
INIT() ;
"RTN","RORHL7",114,0)
 N TMP  K RORHL
"RTN","RORHL7",115,0)
 D INIT^HLFNC2(ROREXT("HL7PROT"),.RORHL)
"RTN","RORHL7",116,0)
 Q:$G(RORHL) $$ERROR^RORERR(-23,"INIT^RORHL7",RORHL)
"RTN","RORHL7",117,0)
 S TMP=$G(RORHL("ECH"))
"RTN","RORHL7",118,0)
 Q:$L(TMP)<4 $$ERROR^RORERR(-75,"INIT^RORHL7")
"RTN","RORHL7",119,0)
 Q 0
"RTN","RORHL7",120,0)
 ;
"RTN","RORHL7",121,0)
 ;***** CHECKS IF MAXIMUM BATCH SIZE IS REACHED
"RTN","RORHL7",122,0)
 ;
"RTN","RORHL7",123,0)
 ; [RESERVE]     Number of bytes reserved in the batch (0 by default)
"RTN","RORHL7",124,0)
 ;
"RTN","RORHL7",125,0)
 ; Return Values:
"RTN","RORHL7",126,0)
 ;         0  Messages can be added to the batch
"RTN","RORHL7",127,0)
 ;         1  Maximum size of the batch has been reached
"RTN","RORHL7",128,0)
 ;
"RTN","RORHL7",129,0)
ISMAXSZ(RESERVE) ;
"RTN","RORHL7",130,0)
 Q:$G(ROREXT("MAXHL7SIZE"))'>0 0
"RTN","RORHL7",131,0)
 Q:($G(ROREXT("HL7SIZE"))+$G(RESERVE))<ROREXT("MAXHL7SIZE") 0
"RTN","RORHL7",132,0)
 S $P(ROREXT("HL7SIZE"),U,2)=1
"RTN","RORHL7",133,0)
 Q 1
"RTN","RORHL7",134,0)
 ;
"RTN","RORHL7",135,0)
 ;***** RETURNS NUMBER OF MESSAGES IN THE CURRENT BATCH
"RTN","RORHL7",136,0)
MSGCNT() ;
"RTN","RORHL7",137,0)
 Q $G(ROREXT("HL7CNT"))
"RTN","RORHL7",138,0)
 ;
"RTN","RORHL7",139,0)
 ;***** RETURNS TEXT EXPLANATIONS OF THE HL7 MESSAGE STATUS
"RTN","RORHL7",140,0)
 ;
"RTN","RORHL7",141,0)
 ; MSGST         Status value returned by the $$MSGSTAT^HLUTIL
"RTN","RORHL7",142,0)
 ;
"RTN","RORHL7",143,0)
MSGSTXT(MSGST) ;
"RTN","RORHL7",144,0)
 N ST  S ST=+MSGST
"RTN","RORHL7",145,0)
 Q:'ST "Message does not exist"
"RTN","RORHL7",146,0)
 Q:ST=1 "Waiting in queue"
"RTN","RORHL7",147,0)
 Q:ST=1.5 "Opening connection"
"RTN","RORHL7",148,0)
 Q:ST=1.7 "Awaiting response"
"RTN","RORHL7",149,0)
 Q:ST=2 "Awaiting application ack"
"RTN","RORHL7",150,0)
 Q:ST=3 "Successfully completed"
"RTN","RORHL7",151,0)
 Q:ST=4 "Error"
"RTN","RORHL7",152,0)
 Q:ST=8 "Being generated"
"RTN","RORHL7",153,0)
 Q:ST=9 "Awaiting processing"
"RTN","RORHL7",154,0)
 Q "Unknown"
"RTN","RORHL7",155,0)
 ;
"RTN","RORHL7",156,0)
 ;***** DELETES AN INCOMPLETE MESSAGE FROM THE ^TMP("HLS",$J)
"RTN","RORHL7",157,0)
 ;
"RTN","RORHL7",158,0)
 ; MSHPTR        An index of the MSH segment in the ^TMP("HLS",$J)
"RTN","RORHL7",159,0)
 ;
"RTN","RORHL7",160,0)
ROLLBACK(MSHPTR) ;
"RTN","RORHL7",161,0)
 N I,I1  S I=+MSHPTR
"RTN","RORHL7",162,0)
 F  Q:I=""  D  S I=$O(^TMP("HLS",$J,I))
"RTN","RORHL7",163,0)
 . ;--- Decrease current size of the batch
"RTN","RORHL7",164,0)
 . S I1=$L($G(^TMP("HLS",$J,I)))
"RTN","RORHL7",165,0)
 . S ROREXT("HL7SIZE")=$G(ROREXT("HL7SIZE"))-I1-1
"RTN","RORHL7",166,0)
 . S I1=""
"RTN","RORHL7",167,0)
 . F  S I1=$O(^TMP("HLS",$J,I,I1))  Q:I1=""  D
"RTN","RORHL7",168,0)
 . . S ROREXT("HL7SIZE")=ROREXT("HL7SIZE")-$L(^TMP("HLS",$J,I,I1))
"RTN","RORHL7",169,0)
 . ;--- Delete the segment
"RTN","RORHL7",170,0)
 . K ^TMP("HLS",$J,I)
"RTN","RORHL7",171,0)
 ;--- Validate current size of the batch
"RTN","RORHL7",172,0)
 S:$G(ROREXT("HL7SIZE"))<0 ROREXT("HL7SIZE")=0
"RTN","RORHL7",173,0)
 ;--- Decrease number of messages in the batch
"RTN","RORHL7",174,0)
 S:$G(ROREXT("HL7CNT"))>0 ROREXT("HL7CNT")=ROREXT("HL7CNT")-1
"RTN","RORHL7",175,0)
 Q
"RTN","RORHL7",176,0)
 ;
"RTN","RORHL7",177,0)
 ;***** SENDS THE BATCH MESSAGE
"RTN","RORHL7",178,0)
 ;
"RTN","RORHL7",179,0)
 ; .MID          Reference to a local variable where the batch
"RTN","RORHL7",180,0)
 ;               message ID (returned by the GENERATE^HLMA) is
"RTN","RORHL7",181,0)
 ;               returned to.
"RTN","RORHL7",182,0)
 ;
"RTN","RORHL7",183,0)
 ; Return Values:
"RTN","RORHL7",184,0)
 ;        <0  Error Code
"RTN","RORHL7",185,0)
 ;         0  Ok
"RTN","RORHL7",186,0)
 ;        >0  There was nothing to send
"RTN","RORHL7",187,0)
 ;
"RTN","RORHL7",188,0)
 ; Several nodes (HL7*) in the ROREXT and the ^TMP("HLS",$J) node
"RTN","RORHL7",189,0)
 ; are deleted by this entry point.
"RTN","RORHL7",190,0)
 ;
"RTN","RORHL7",191,0)
SEND(MID) ;
"RTN","RORHL7",192,0)
 N RC,RORBUF,RORHLP  S MID=""
"RTN","RORHL7",193,0)
 Q:$G(ROREXT("HL7PROT"))="" $$ERROR^RORERR(-25,"SEND^RORHL7")
"RTN","RORHL7",194,0)
 ;--- Quit if there is nothing to send
"RTN","RORHL7",195,0)
 Q:'$G(ROREXT("HL7MTIEN"))!($D(^TMP("HLS",$J))<10) 1
"RTN","RORHL7",196,0)
 ;--- Set up the HL7 environment variables
"RTN","RORHL7",197,0)
 D INIT^HLFNC2(ROREXT("HL7PROT"),.RORHL)
"RTN","RORHL7",198,0)
 Q:$G(RORHL) $$ERROR^RORERR(-23,"SEND^RORHL7",RORHL)
"RTN","RORHL7",199,0)
 ;--- Send the message
"RTN","RORHL7",200,0)
 S RORHLP("NAMESPACE")="ROR"
"RTN","RORHL7",201,0)
 D GENERATE^HLMA(ROREXT("HL7PROT"),"GB",1,.RORBUF,ROREXT("HL7MTIEN"),.RORHLP)
"RTN","RORHL7",202,0)
 ;D DIRECT^HLMA(ROREXT("HL7PROT"),"GB",1,.RORBUF,ROREXT("HL7MTIEN"),.RORHLP)
"RTN","RORHL7",203,0)
 S RC=$S($P(RORBUF,U,2):$$ERROR^RORERR(-24,"SEND^RORHL7",RORBUF),1:0)
"RTN","RORHL7",204,0)
 S MID=$P(RORBUF,U)
"RTN","RORHL7",205,0)
 ;--- Cleanup if there is no error or not in debug mode
"RTN","RORHL7",206,0)
 D:'$G(RORPARM("DEBUG"))!(RC'<0)
"RTN","RORHL7",207,0)
 . F TMP="HL7CNT","HL7DT","HL7MTIEN","HL7SIZE"  K ROREXT(TMP)
"RTN","RORHL7",208,0)
 . K ^TMP("HLS",$J)
"RTN","RORHL7",209,0)
 Q RC
"RTN","RORHL7",210,0)
 ;
"RTN","RORHL7",211,0)
 ;***** STORES THE SEGMENT INTO THE ^TMP("HLS",$J) BUFFER
"RTN","RORHL7",212,0)
 ;
"RTN","RORHL7",213,0)
 ; .PTR          Reference to a local variable that contains a
"RTN","RORHL7",214,0)
 ;               subscript of the last occupied sub-node of the
"RTN","RORHL7",215,0)
 ;               message buffer (see ROR8NODE). Value of the variable
"RTN","RORHL7",216,0)
 ;               is incremented before storing the segment.
"RTN","RORHL7",217,0)
 ;
"RTN","RORHL7",218,0)
 ; SEG           HL7 segment
"RTN","RORHL7",219,0)
 ;
"RTN","RORHL7",220,0)
 ; [ROR8NODE]    Closed root of the buffer where the HL7 message is
"RTN","RORHL7",221,0)
 ;               constructed. By default, the ^TMP("HLS",$J) is used.
"RTN","RORHL7",222,0)
 ;
"RTN","RORHL7",223,0)
 ; The SETSEG^RORHL7 procedure stores the HL7 segment into the
"RTN","RORHL7",224,0)
 ; standard HL7 buffer ^TMP("HLS",$J). The <TAB>, <CR> and <LF>
"RTN","RORHL7",225,0)
 ; characters are replaced with spaces. Long segments are splitted
"RTN","RORHL7",226,0)
 ; among sub-nodes of the main segment node.
"RTN","RORHL7",227,0)
 ;
"RTN","RORHL7",228,0)
SETSEG(PTR,SEG,ROR8NODE) ;
"RTN","RORHL7",229,0)
 N I1,I2,MAXLEN,PTR1,SL
"RTN","RORHL7",230,0)
 S:$G(ROR8NODE)="" ROR8NODE=$NA(^TMP("HLS",$J))
"RTN","RORHL7",231,0)
 S SL=$L(SEG),MAXLEN=245,PTR=PTR+1
"RTN","RORHL7",232,0)
 S @ROR8NODE@(PTR)=$TR($E(SEG,1,MAXLEN),$C(9,10,13),"   ")
"RTN","RORHL7",233,0)
 S ROREXT("HL7SIZE")=$G(ROREXT("HL7SIZE"))+SL+1
"RTN","RORHL7",234,0)
 Q:SL'>MAXLEN
"RTN","RORHL7",235,0)
 ;--- Split the segment into sub-nodes if necessary
"RTN","RORHL7",236,0)
 S I2=MAXLEN
"RTN","RORHL7",237,0)
 F PTR1=1:1  S I1=I2+1,I2=I1+MAXLEN-1  Q:I1>SL  D
"RTN","RORHL7",238,0)
 . S @ROR8NODE@(PTR,PTR1)=$TR($E(SEG,I1,I2),$C(9,10,13),"   ")
"RTN","RORHL7",239,0)
 Q
"RTN","RORKIDS")
0^19^B29192479
"RTN","RORKIDS",1,0)
RORKIDS ;HCIOFO/SG - INSTALL UTILITIES (LOW-LEVEL) ; 8/6/02 11:43am
"RTN","RORKIDS",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORKIDS",3,0)
 ;
"RTN","RORKIDS",4,0)
 Q
"RTN","RORKIDS",5,0)
 ;
"RTN","RORKIDS",6,0)
 ;***** DISPLAYS THE MESSAGE IF THE INSTALLATION ABORTS
"RTN","RORKIDS",7,0)
ABTMSG() ;
"RTN","RORKIDS",8,0)
 N INFO,MODE
"RTN","RORKIDS",9,0)
 S MODE=+$G(RORPARM("KIDS"))
"RTN","RORKIDS",10,0)
 S MODE=$S(MODE=1:"pre-install",MODE=2:"post-install",1:"")
"RTN","RORKIDS",11,0)
 Q:MODE=""
"RTN","RORKIDS",12,0)
 S INFO(1)="Fix the error(s) and restart the installation."
"RTN","RORKIDS",13,0)
 D BMES("Fatal error(s) during the registry "_MODE_"!",.INFO)
"RTN","RORKIDS",14,0)
 Q
"RTN","RORKIDS",15,0)
 ;
"RTN","RORKIDS",16,0)
 ;***** SENDS AN ALERT
"RTN","RORKIDS",17,0)
 ;
"RTN","RORKIDS",18,0)
 ; DUZ           DUZ of the addressee
"RTN","RORKIDS",19,0)
 ;
"RTN","RORKIDS",20,0)
 ; MSG           Text of the message or negative error code. The '^'
"RTN","RORKIDS",21,0)
 ;               characters are replaced with spaces in the text.
"RTN","RORKIDS",22,0)
 ;
"RTN","RORKIDS",23,0)
 ; [REGNAME]     Registry name
"RTN","RORKIDS",24,0)
 ;
"RTN","RORKIDS",25,0)
 ; [PATIEN]      Patient IEN
"RTN","RORKIDS",26,0)
 ;
"RTN","RORKIDS",27,0)
 ; [ARG2-ARG5]   Optional parameters as for $$ERROR^RORERR
"RTN","RORKIDS",28,0)
 ;
"RTN","RORKIDS",29,0)
ALERT(DUZ,MSG,REGNAME,PATIEN,ARG2,ARG3,ARG4,ARG5) ;
"RTN","RORKIDS",30,0)
 Q:'$G(DUZ)
"RTN","RORKIDS",31,0)
 N XQA,XQADATA,XQAFLG,XQAMSG,XQAROU,TMP
"RTN","RORKIDS",32,0)
 S XQA(DUZ)=""
"RTN","RORKIDS",33,0)
 ;--- Get text of the error message
"RTN","RORKIDS",34,0)
 I +MSG=MSG  Q:MSG'<0  D
"RTN","RORKIDS",35,0)
 . S MSG=$$MSG^RORERR20(+MSG,,.PATIEN,.ARG2,.ARG3,.ARG4,.ARG5)
"RTN","RORKIDS",36,0)
 S MSG=$TR(MSG,"^","~"),XQAMSG="ROR: ",TMP=70-$L(XQAMSG)-3
"RTN","RORKIDS",37,0)
 S XQAMSG=XQAMSG_$S($L(MSG)>TMP:$E(MSG,1,TMP)_"...",1:MSG)
"RTN","RORKIDS",38,0)
 ;--- Setup alert processing routine
"RTN","RORKIDS",39,0)
 S $P(XQADATA,U,1)=$E(MSG,1,78)
"RTN","RORKIDS",40,0)
 S $P(XQADATA,U,2)=$G(REGNAME)
"RTN","RORKIDS",41,0)
 S $P(XQADATA,U,3)=$G(PATIEN)
"RTN","RORKIDS",42,0)
 S XQAROU="ALERTRTN^RORKIDS"
"RTN","RORKIDS",43,0)
 ;--- Send the alert
"RTN","RORKIDS",44,0)
 S XQAFLG="D"  D SETUP^XQALERT
"RTN","RORKIDS",45,0)
 Q
"RTN","RORKIDS",46,0)
 ;
"RTN","RORKIDS",47,0)
 ;***** ALERT PROCESSING ROUTINE
"RTN","RORKIDS",48,0)
 ;
"RTN","RORKIDS",49,0)
 ; XQADATA       Alert data
"RTN","RORKIDS",50,0)
 ;                 ^1: Message
"RTN","RORKIDS",51,0)
 ;                 ^2: Registry name
"RTN","RORKIDS",52,0)
 ;                 ^3: Patient DFN
"RTN","RORKIDS",53,0)
 ;
"RTN","RORKIDS",54,0)
ALERTRTN ;
"RTN","RORKIDS",55,0)
 ;;Registry Name:
"RTN","RORKIDS",56,0)
 ;;Patient DFN:
"RTN","RORKIDS",57,0)
 ;
"RTN","RORKIDS",58,0)
 Q:$G(XQADATA)=""
"RTN","RORKIDS",59,0)
 N I,TMP
"RTN","RORKIDS",60,0)
 W !!,$P(XQADATA,"^"),!
"RTN","RORKIDS",61,0)
 F I=1:1:2  S TMP=$P(XQADATA,"^",I+1)  D:TMP'=""
"RTN","RORKIDS",62,0)
 . W $P($T(ALERTRTN+I),";;",2),?15,TMP,!
"RTN","RORKIDS",63,0)
 Q
"RTN","RORKIDS",64,0)
 ;
"RTN","RORKIDS",65,0)
 ;***** OUTPUTS THE MESSAGE AND PUTS IT INTO THE LOG
"RTN","RORKIDS",66,0)
BMES(MSG,INFO) ;
"RTN","RORKIDS",67,0)
 N I
"RTN","RORKIDS",68,0)
 D BMES^XPDUTL("   "_MSG)
"RTN","RORKIDS",69,0)
 S I=""
"RTN","RORKIDS",70,0)
 F  S I=$O(INFO(I))  Q:I=""  D MES^XPDUTL("   "_INFO(I))
"RTN","RORKIDS",71,0)
 D LOG^RORLOG(,MSG,,.INFO)
"RTN","RORKIDS",72,0)
 Q
"RTN","RORKIDS",73,0)
 ;
"RTN","RORKIDS",74,0)
 ;***** CHECKS THE SCHEDULED OPTION
"RTN","RORKIDS",75,0)
 ;
"RTN","RORKIDS",76,0)
 ; OPTION        Option name
"RTN","RORKIDS",77,0)
 ;
"RTN","RORKIDS",78,0)
 ; Return Values:
"RTN","RORKIDS",79,0)
 ;       <0  Error code
"RTN","RORKIDS",80,0)
 ;        0  Ok
"RTN","RORKIDS",81,0)
 ;
"RTN","RORKIDS",82,0)
 ; This function can be used in the environment check routines to
"RTN","RORKIDS",83,0)
 ; check if the option is running and/or scheduled to run.
"RTN","RORKIDS",84,0)
 ;
"RTN","RORKIDS",85,0)
 ; The function displays appropriate error messages and warnings
"RTN","RORKIDS",86,0)
 ; using the WRITE command. So, it MUST NOT be called from the
"RTN","RORKIDS",87,0)
 ; pre-install or post-install routines.
"RTN","RORKIDS",88,0)
 ;
"RTN","RORKIDS",89,0)
 ; The function uses the ^UTILITY($J,"W") node (^DIWP and ^DIWW).
"RTN","RORKIDS",90,0)
 ;
"RTN","RORKIDS",91,0)
CHKOPT(OPTION) ;
"RTN","RORKIDS",92,0)
 N DIWF,DIWL,DIWR,RC,RORBUF,RORI,RORSDT,TMP,X,ZTSK
"RTN","RORKIDS",93,0)
 ;--- Check status of the option
"RTN","RORKIDS",94,0)
 D OPTSTAT^XUTMOPT(OPTION,.RORBUF)
"RTN","RORKIDS",95,0)
 S (RC,RORSDT)=0
"RTN","RORKIDS",96,0)
 F RORI=1:1:$G(RORBUF)  K ZTSK  D  I $G(ZTSK(1))=2  S RC=-76  Q
"RTN","RORKIDS",97,0)
 . S ZTSK=$P(RORBUF(RORI),"^")  Q:'ZTSK
"RTN","RORKIDS",98,0)
 . D STAT^%ZTLOAD
"RTN","RORKIDS",99,0)
 . S TMP=$P(RORBUF(RORI),"^",2)
"RTN","RORKIDS",100,0)
 . I TMP>0  S:'RORSDT!(TMP<RORSDT) RORSDT=TMP
"RTN","RORKIDS",101,0)
 ;--- Display an error message if the option is running
"RTN","RORKIDS",102,0)
 I RC  D  Q RC
"RTN","RORKIDS",103,0)
 . W !,$$MSG^RORERR20(RC,,,OPTION),!
"RTN","RORKIDS",104,0)
 ;--- Display an apropriate warning
"RTN","RORKIDS",105,0)
 S DIWL=5,DIWR=$G(IOM,80)-DIWL
"RTN","RORKIDS",106,0)
 K ^UTILITY($J,"W")
"RTN","RORKIDS",107,0)
CM1 I RORSDT>0  D
"RTN","RORKIDS",108,0)
 . ;;"The ["_OPTION_"] option is scheduled to run "_RORSDT_"."
"RTN","RORKIDS",109,0)
 . ;;"If you are going to schedule the installation, please, choose"
"RTN","RORKIDS",110,0)
 . ;;"an appropriate time so that the post-install will either"
"RTN","RORKIDS",111,0)
 . ;;"finish well before the ["_OPTION_"] scheduled time or start"
"RTN","RORKIDS",112,0)
 . ;;"after the option completion."
"RTN","RORKIDS",113,0)
 . ;---
"RTN","RORKIDS",114,0)
 . S RORSDT=$$FMTE^XLFDT(RORSDT)
"RTN","RORKIDS",115,0)
 . S RORSDT="on "_$P(RORSDT,"@")_" at "_$P(RORSDT,"@",2)
"RTN","RORKIDS",116,0)
 . F RORI=1:1  S X=$T(CM1+RORI)  Q:X'[";;"  D
"RTN","RORKIDS",117,0)
 . . X "S X="_$P(X,";;",2)  D ^DIWP
"RTN","RORKIDS",118,0)
CM2 E  D
"RTN","RORKIDS",119,0)
 . ;;"The ["_OPTION_"] option is not scheduled. Do not forget"
"RTN","RORKIDS",120,0)
 . ;;"to schedule it after completion of the installation."
"RTN","RORKIDS",121,0)
 . ;---
"RTN","RORKIDS",122,0)
 . F RORI=1:1  S X=$T(CM2+RORI)  Q:X'[";;"  D
"RTN","RORKIDS",123,0)
 . . X "S X="_$P(X,";;",2)  D ^DIWP
"RTN","RORKIDS",124,0)
 W !  D ^DIWW
"RTN","RORKIDS",125,0)
 Q 0
"RTN","RORKIDS",126,0)
 ;
"RTN","RORKIDS",127,0)
 ;***** PROCESSES THE INSTALL CHECKPOINT
"RTN","RORKIDS",128,0)
 ;
"RTN","RORKIDS",129,0)
 ; CPNAME        Checkpoint name
"RTN","RORKIDS",130,0)
 ;
"RTN","RORKIDS",131,0)
 ; CALLBACK      Callback entry point ($$TAG^ROUTINE). This function
"RTN","RORKIDS",132,0)
 ;               accepts no parameters and must return either 0 if
"RTN","RORKIDS",133,0)
 ;               everything is Ok or a negative error code.
"RTN","RORKIDS",134,0)
 ;
"RTN","RORKIDS",135,0)
 ; [PARAM]       Value to set checkpoint parameter to.
"RTN","RORKIDS",136,0)
 ;
"RTN","RORKIDS",137,0)
 ; The function checks if the checkpoint is completed. If it is not,
"RTN","RORKIDS",138,0)
 ; the callback entry point is XECUTEd. If everything is Ok, the
"RTN","RORKIDS",139,0)
 ; function will complete the checkpoint.
"RTN","RORKIDS",140,0)
 ;
"RTN","RORKIDS",141,0)
 ; Return Values:
"RTN","RORKIDS",142,0)
 ;       <0  Error code
"RTN","RORKIDS",143,0)
 ;        0  Ok
"RTN","RORKIDS",144,0)
 ;
"RTN","RORKIDS",145,0)
CP(CPNAME,CALLBACK,PARAM) ;
"RTN","RORKIDS",146,0)
 N RC
"RTN","RORKIDS",147,0)
 ;--- Verify the checkpoint and quit if it is completed
"RTN","RORKIDS",148,0)
 S RC=$$VERCP^XPDUTL(CPNAME)  Q:RC>0 0
"RTN","RORKIDS",149,0)
 ;--- Create the new checkpoint
"RTN","RORKIDS",150,0)
 I RC<0  D  Q:'RC $$ERROR^RORERR(-50,"CP^RORKIDS",,,CPNAME)
"RTN","RORKIDS",151,0)
 . S RC=$$NEWCP^XPDUTL(CPNAME,,.PARAM)
"RTN","RORKIDS",152,0)
 ;--- Reset the KIDS progress bar
"RTN","RORKIDS",153,0)
 S XPDIDTOT=0  D UPDATE^XPDID(0)
"RTN","RORKIDS",154,0)
 ;--- Execute the callback entry point
"RTN","RORKIDS",155,0)
 X "S RC="_CALLBACK  Q:RC<0 RC
"RTN","RORKIDS",156,0)
 ;--- Complete the check point
"RTN","RORKIDS",157,0)
 S RC=$$COMCP^XPDUTL(CPNAME)
"RTN","RORKIDS",158,0)
 Q:'RC $$ERROR^RORERR(-51,"CP^RORKIDS",,,CPNAME)
"RTN","RORKIDS",159,0)
 Q 0
"RTN","RORKIDS",160,0)
 ;
"RTN","RORKIDS",161,0)
 ;***** DELETES THE (SUB)FILE DD AND DATA (IF REQUESTED)
"RTN","RORKIDS",162,0)
 ;
"RTN","RORKIDS",163,0)
 ; FILE          File number
"RTN","RORKIDS",164,0)
 ;
"RTN","RORKIDS",165,0)
 ; [FLAGS]       String that contains flags for EN^DIU2:
"RTN","RORKIDS",166,0)
 ;                 "D"  Delete the data as well as the DD
"RTN","RORKIDS",167,0)
 ;                 "E"  Echo back information during deletion
"RTN","RORKIDS",168,0)
 ;                 "S"  Subfile data dictionary is to be deleted
"RTN","RORKIDS",169,0)
 ;                 "T"  Templates are to be deleted
"RTN","RORKIDS",170,0)
 ;
"RTN","RORKIDS",171,0)
 ; [SILENT]      If this parameters is defined and non-zero, the
"RTN","RORKIDS",172,0)
 ;               function will work in "silent" mode.
"RTN","RORKIDS",173,0)
 ;               Nothing (except error messages if debug mode >1 is
"RTN","RORKIDS",174,0)
 ;               enabled) will be displayed on the console or stored
"RTN","RORKIDS",175,0)
 ;               into the INSTALLATION file.
"RTN","RORKIDS",176,0)
 ;
"RTN","RORKIDS",177,0)
 ; Return Values:
"RTN","RORKIDS",178,0)
 ;       <0  Error code
"RTN","RORKIDS",179,0)
 ;        0  Ok
"RTN","RORKIDS",180,0)
 ;
"RTN","RORKIDS",181,0)
DELFILE(FILE,FLAGS,SILENT) ;
"RTN","RORKIDS",182,0)
 Q:'$$VFILE^DILFD(+FILE) 0
"RTN","RORKIDS",183,0)
 N DIU,FT,RC
"RTN","RORKIDS",184,0)
 S DIU=+FILE,DIU(0)=$G(FLAGS)
"RTN","RORKIDS",185,0)
 I '$G(SILENT)  D
"RTN","RORKIDS",186,0)
 . S FT=$S(DIU(0)["S":"subfile",1:"file")
"RTN","RORKIDS",187,0)
 . D BMES("Deleting the "_FT_" #"_(+FILE)_"...")
"RTN","RORKIDS",188,0)
 D EN^DIU2
"RTN","RORKIDS",189,0)
 D:'$G(SILENT) MES("The "_FT_" has been deleted.")
"RTN","RORKIDS",190,0)
 Q 0
"RTN","RORKIDS",191,0)
 ;
"RTN","RORKIDS",192,0)
 ;***** DELETES FIELD DEFENITIONS FROM THE DD
"RTN","RORKIDS",193,0)
 ;
"RTN","RORKIDS",194,0)
 ; FILE          File number
"RTN","RORKIDS",195,0)
 ;
"RTN","RORKIDS",196,0)
 ; FLDLST        String that contains list of field numbers to
"RTN","RORKIDS",197,0)
 ;               delete (separated with the ';').
"RTN","RORKIDS",198,0)
 ;
"RTN","RORKIDS",199,0)
 ; [SILENT]      If this parameters is defined and non-zero, the
"RTN","RORKIDS",200,0)
 ;               function will work in "silent" mode.
"RTN","RORKIDS",201,0)
 ;               Nothing (except error messages if debug mode >1 is
"RTN","RORKIDS",202,0)
 ;               enabled) will be displayed on the console or stored
"RTN","RORKIDS",203,0)
 ;               into the INSTALLATION file.
"RTN","RORKIDS",204,0)
 ;
"RTN","RORKIDS",205,0)
 ; Return Values:
"RTN","RORKIDS",206,0)
 ;       <0  Error code
"RTN","RORKIDS",207,0)
 ;        0  Ok
"RTN","RORKIDS",208,0)
 ;
"RTN","RORKIDS",209,0)
DELFLDS(FILE,FLDLST,SILENT) ;
"RTN","RORKIDS",210,0)
 Q:'$$VFILE^DILFD(+FILE) 0
"RTN","RORKIDS",211,0)
 N DA,DIK,I,RC,ROOT
"RTN","RORKIDS",212,0)
 D:'$G(SILENT)
"RTN","RORKIDS",213,0)
 . D BMES("Deleting the field definitions...")
"RTN","RORKIDS",214,0)
 . D MES("File #"_(+FILE)_", Fields: '"_FLDLST_"'")
"RTN","RORKIDS",215,0)
 S DA(1)=+FILE,DIK="^DD("_DA(1)_","
"RTN","RORKIDS",216,0)
 F I=1:1  S DA=$P(FLDLST,";",I)  Q:'DA  D ^DIK
"RTN","RORKIDS",217,0)
 D:'$G(SILENT) MES("The definitions have been deleted.")
"RTN","RORKIDS",218,0)
 Q 0
"RTN","RORKIDS",219,0)
 ;
"RTN","RORKIDS",220,0)
 ;***** OUTPUTS THE MESSAGE AND PUTS IT INTO THE LOG
"RTN","RORKIDS",221,0)
MES(MSG,INFO) ;
"RTN","RORKIDS",222,0)
 N I
"RTN","RORKIDS",223,0)
 D MES^XPDUTL("   "_MSG)
"RTN","RORKIDS",224,0)
 S I=""
"RTN","RORKIDS",225,0)
 F  S I=$O(INFO(I))  Q:I=""  D MES^XPDUTL("   "_INFO(I))
"RTN","RORKIDS",226,0)
 D LOG^RORLOG(,MSG,,.INFO)
"RTN","RORKIDS",227,0)
 Q
"RTN","RORKIDS",228,0)
 ;
"RTN","RORKIDS",229,0)
 ;***** RETURNS A VALUE OF THE INSTALLATION PARAMETER
"RTN","RORKIDS",230,0)
 ;
"RTN","RORKIDS",231,0)
 ; NAME          Name of the parameter
"RTN","RORKIDS",232,0)
 ;
"RTN","RORKIDS",233,0)
PARAM(NAME) ;
"RTN","RORKIDS",234,0)
 Q $G(RORPARM("KIDS",NAME))
"RTN","RORNTEG")
0^38^B8064498
"RTN","RORNTEG",1,0)
RORNTEG ;ISC/XTSUMBLD KERNEL - Package checksum checker ;3020911.14531
"RTN","RORNTEG",2,0)
 ;;0.0;
"RTN","RORNTEG",3,0)
 ;;7.3;3020911.14531
"RTN","RORNTEG",4,0)
 S XT4="I 1",X=$T(+3) W !!,"Checksum routine created on ",$P(X,";",4)," by KERNEL V",$P(X,";",3),!
"RTN","RORNTEG",5,0)
CONT F XT1=1:1 S XT2=$T(ROU+XT1) Q:XT2=""  S X=$P(XT2," ",1),XT3=$P(XT2,";",3) X XT4 I $T W !,X X ^%ZOSF("TEST") S:'$T XT3=0 X:XT3 ^%ZOSF("RSUM") W ?10,$S('XT3:"Routine not in UCI",XT3'=Y:"Calculated "_$C(7)_Y_", off by "_(Y-XT3),1:"ok")
"RTN","RORNTEG",6,0)
 ;
"RTN","RORNTEG",7,0)
 K %1,%2,%3,X,Y,XT1,XT2,XT3,XT4 Q
"RTN","RORNTEG",8,0)
ONE S XT4="I $D(^UTILITY($J,X))",X=$T(+3) W !!,"Checksum routine created on ",$P(X,";",4)," by KERNEL V",$P(X,";",3),!
"RTN","RORNTEG",9,0)
 W !,"Check a subset of routines:" K ^UTILITY($J) X ^%ZOSF("RSEL")
"RTN","RORNTEG",10,0)
 W ! G CONT
"RTN","RORNTEG",11,0)
ROU ;;
"RTN","RORNTEG",12,0)
ROR ;;2626117
"RTN","RORNTEG",13,0)
ROR01 ;;1117
"RTN","RORNTEG",14,0)
RORACK ;;3432402
"RTN","RORNTEG",15,0)
RORACK01 ;;6012225
"RTN","RORNTEG",16,0)
RORAPI01 ;;2614007
"RTN","RORNTEG",17,0)
RORDD ;;3338213
"RTN","RORNTEG",18,0)
RORENV01 ;;1326700
"RTN","RORNTEG",19,0)
RORENV02 ;;2052764
"RTN","RORNTEG",20,0)
RORERR ;;2587128
"RTN","RORNTEG",21,0)
RORERR10 ;;17181044
"RTN","RORNTEG",22,0)
RORERR20 ;;10009159
"RTN","RORNTEG",23,0)
ROREVT01 ;;1432188
"RTN","RORNTEG",24,0)
ROREXPR ;;2824404
"RTN","RORNTEG",25,0)
ROREXT ;;3425862
"RTN","RORNTEG",26,0)
ROREXT01 ;;3458673
"RTN","RORNTEG",27,0)
ROREXT02 ;;5473418
"RTN","RORNTEG",28,0)
ROREXTUT ;;4083073
"RTN","RORNTEG",29,0)
RORHDT ;;3515691
"RTN","RORNTEG",30,0)
RORHDT01 ;;2568846
"RTN","RORNTEG",31,0)
RORHDT02 ;;1419145
"RTN","RORNTEG",32,0)
RORHDT03 ;;4467017
"RTN","RORNTEG",33,0)
RORHDT04 ;;7554610
"RTN","RORNTEG",34,0)
RORHDT05 ;;3499618
"RTN","RORNTEG",35,0)
RORHDTAC ;;3457583
"RTN","RORNTEG",36,0)
RORHDTUT ;;5260009
"RTN","RORNTEG",37,0)
RORHL01 ;;3080072
"RTN","RORNTEG",38,0)
RORHL02 ;;7855453
"RTN","RORNTEG",39,0)
RORHL03 ;;9723450
"RTN","RORNTEG",40,0)
RORHL04 ;;4151190
"RTN","RORNTEG",41,0)
RORHL05 ;;2472330
"RTN","RORNTEG",42,0)
RORHL06 ;;5392256
"RTN","RORNTEG",43,0)
RORHL07 ;;3672391
"RTN","RORNTEG",44,0)
RORHL7 ;;4726634
"RTN","RORNTEG",45,0)
RORKIDS ;;4837991
"RTN","RORNTEG",46,0)
RORLOG ;;5635247
"RTN","RORNTEG",47,0)
RORLOG01 ;;1572747
"RTN","RORNTEG",48,0)
RORPOS01 ;;4925130
"RTN","RORNTEG",49,0)
RORPOS02 ;;8457305
"RTN","RORNTEG",50,0)
RORPOS03 ;;4325295
"RTN","RORNTEG",51,0)
RORPOSU1 ;;665251
"RTN","RORNTEG",52,0)
RORPRE01 ;;2036630
"RTN","RORNTEG",53,0)
RORRP1 ;;2796927
"RTN","RORNTEG",54,0)
RORRP10 ;;476541
"RTN","RORNTEG",55,0)
RORRP2 ;;4565833
"RTN","RORNTEG",56,0)
RORRP3 ;;3482249
"RTN","RORNTEG",57,0)
RORRP4 ;;5196987
"RTN","RORNTEG",58,0)
RORRP5 ;;1933187
"RTN","RORNTEG",59,0)
RORRP6 ;;3979336
"RTN","RORNTEG",60,0)
RORRP7 ;;4903176
"RTN","RORNTEG",61,0)
RORRP8 ;;3614530
"RTN","RORNTEG",62,0)
RORRP9 ;;7962639
"RTN","RORNTEG",63,0)
RORSET01 ;;4109746
"RTN","RORNTEG",64,0)
RORSETU1 ;;4862121
"RTN","RORNTEG",65,0)
RORSETU2 ;;3422125
"RTN","RORNTEG",66,0)
RORTSITE ;;4570058
"RTN","RORNTEG",67,0)
RORUPD ;;3639699
"RTN","RORNTEG",68,0)
RORUPD01 ;;8324705
"RTN","RORNTEG",69,0)
RORUPD04 ;;4980025
"RTN","RORNTEG",70,0)
RORUPD05 ;;7604750
"RTN","RORNTEG",71,0)
RORUPD06 ;;2672977
"RTN","RORNTEG",72,0)
RORUPD07 ;;2080523
"RTN","RORNTEG",73,0)
RORUPD08 ;;3974187
"RTN","RORNTEG",74,0)
RORUPD09 ;;2605824
"RTN","RORNTEG",75,0)
RORUPD50 ;;3759178
"RTN","RORNTEG",76,0)
RORUPD51 ;;9694351
"RTN","RORNTEG",77,0)
RORUPD52 ;;2507568
"RTN","RORNTEG",78,0)
RORUPDUT ;;7306215
"RTN","RORNTEG",79,0)
RORUPEX ;;3446189
"RTN","RORNTEG",80,0)
RORUPP01 ;;3975391
"RTN","RORNTEG",81,0)
RORUPP02 ;;2478392
"RTN","RORNTEG",82,0)
RORUPR ;;5856761
"RTN","RORNTEG",83,0)
RORUPR1 ;;11398836
"RTN","RORNTEG",84,0)
RORUTL01 ;;5264165
"RTN","RORNTEG",85,0)
RORUTL02 ;;6381475
"RTN","RORNTEG",86,0)
RORUTL03 ;;7598103
"RTN","RORNTEG",87,0)
RORUTL04 ;;2076790
"RTN","RORNTEG",88,0)
RORUTL05 ;;8206633
"RTN","RORNTEG",89,0)
RORUTL06 ;;7468553
"RTN","RORNTEG",90,0)
RORUTL07 ;;2738279
"RTN","RORPOS02")
0^15^B46867129
"RTN","RORPOS02",1,0)
RORPOS02 ;HCIOFO/SG - POST-INSTALL ROUTINE (ROR*1.0*2) ; 9/11/02 2:47pm
"RTN","RORPOS02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORPOS02",3,0)
 ;
"RTN","RORPOS02",4,0)
 Q
"RTN","RORPOS02",5,0)
 ;
"RTN","RORPOS02",6,0)
 ;***** POST-INSTALL ENTRY POINT FOR THE PATCH ROR*1.0*2
"RTN","RORPOS02",7,0)
START ;
"RTN","RORPOS02",8,0)
 N RORERROR      ; Error processing data
"RTN","RORPOS02",9,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORPOS02",10,0)
 N RORPARM       ; Application parameters
"RTN","RORPOS02",11,0)
 ;
"RTN","RORPOS02",12,0)
 N RC,REGIEN,REGNAME,RORMSG,TMP
"RTN","RORPOS02",13,0)
 S RORPARM("DEVELOPER")=1   ; Enable modifications
"RTN","RORPOS02",14,0)
 S RORPARM("ERR")=1         ; Enable error processing
"RTN","RORPOS02",15,0)
 S RORPARM("KIDS")=2        ; Post-install indicator
"RTN","RORPOS02",16,0)
 S RORPARM("LOG")=1         ; Enable error recording
"RTN","RORPOS02",17,0)
 ;
"RTN","RORPOS02",18,0)
 S RORPARM("KIDS","ROREMAIL")="CHANG,SOPHIA@FORUM.VA.GOV"
"RTN","RORPOS02",19,0)
 ;
"RTN","RORPOS02",20,0)
 ;--- IEN and name of the registry
"RTN","RORPOS02",21,0)
 S REGNAME="VA HEPC"
"RTN","RORPOS02",22,0)
 S REGIEN=$$REGIEN^RORUTL02(REGNAME)  G:REGIEN<0 ERROR
"RTN","RORPOS02",23,0)
 S RORPARM("KIDS","RORREG")=REGIEN_U_REGNAME
"RTN","RORPOS02",24,0)
 ;
"RTN","RORPOS02",25,0)
 ;--- Open a new log
"RTN","RORPOS02",26,0)
 S TMP=$$OPEN^RORLOG(REGNAME,0,XPDNM_" POST-INSTALL STARTED")
"RTN","RORPOS02",27,0)
 ;
"RTN","RORPOS02",28,0)
 ;--- Update the DRUG THERAPY LIST multiple
"RTN","RORPOS02",29,0)
 G:$$CP^RORKIDS("POS05","$$UPDRUGS^RORPOS02")<0 ERROR
"RTN","RORPOS02",30,0)
 ;
"RTN","RORPOS02",31,0)
 ;--- Update the EXTRACTED RESULT multiple
"RTN","RORPOS02",32,0)
 G:$$CP^RORKIDS("POS10","$$UPDLOINC^RORPOS02")<0 ERROR
"RTN","RORPOS02",33,0)
 ;
"RTN","RORPOS02",34,0)
 ;--- Update the SECURITY KEY multiple
"RTN","RORPOS02",35,0)
 G:$$CP^RORKIDS("POS15","$$UPDKEYS^RORPOS02")<0 ERROR
"RTN","RORPOS02",36,0)
 ;
"RTN","RORPOS02",37,0)
 ;--- Update the registry parameters
"RTN","RORPOS02",38,0)
 G:$$CP^RORKIDS("POS20","$$UPDPRMS^RORPOS02")<0 ERROR
"RTN","RORPOS02",39,0)
 ;
"RTN","RORPOS02",40,0)
 ;--- Delete employes from the registry
"RTN","RORPOS02",41,0)
 G:$$CP^RORKIDS("POS25","$$DELEMPLS^RORPOS03")<0 ERROR
"RTN","RORPOS02",42,0)
 ;
"RTN","RORPOS02",43,0)
 ;--- Close the log
"RTN","RORPOS02",44,0)
 D CLOSE^RORLOG(XPDNM_" POST-INSTALL COMPLETED")
"RTN","RORPOS02",45,0)
 Q
"RTN","RORPOS02",46,0)
ERROR ;--- Display the errors
"RTN","RORPOS02",47,0)
 S XPDABORT=1
"RTN","RORPOS02",48,0)
 D:$D(ZTQUEUED) ALERT^RORKIDS(DUZ,-43,REGNAME,,"post-install")
"RTN","RORPOS02",49,0)
 D DSPSTK^RORERR(),ABTMSG^RORKIDS()
"RTN","RORPOS02",50,0)
 ;--- Close the log
"RTN","RORPOS02",51,0)
 D CLOSE^RORLOG(XPDNM_" POST-INSTALL ABORTED")
"RTN","RORPOS02",52,0)
 Q
"RTN","RORPOS02",53,0)
 ;
"RTN","RORPOS02",54,0)
 ;***** UPDATES THE 'SECURITY KEY' MULTIPLE OF THE FILE #798.1
"RTN","RORPOS02",55,0)
 ;
"RTN","RORPOS02",56,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPOS02",57,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPOS02",58,0)
 ;
"RTN","RORPOS02",59,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPOS02",60,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPOS02",61,0)
 ; sub-nodes of the same name.
"RTN","RORPOS02",62,0)
 ;
"RTN","RORPOS02",63,0)
 ; Return Values:
"RTN","RORPOS02",64,0)
 ;       <0  Error code
"RTN","RORPOS02",65,0)
 ;        0  Ok
"RTN","RORPOS02",66,0)
 ;
"RTN","RORPOS02",67,0)
UPDKEYS(RORREG) ;
"RTN","RORPOS02",68,0)
 N IENS,RC,RORFDA,RORMSG
"RTN","RORPOS02",69,0)
 D BMES^RORKIDS("Updating the SECURITY KEY multiple...")
"RTN","RORPOS02",70,0)
 ;--- Get the registry
"RTN","RORPOS02",71,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPOS02",72,0)
 ;--- Update the multiple
"RTN","RORPOS02",73,0)
 S IENS=","_(+RORREG)_","
"RTN","RORPOS02",74,0)
 S RORFDA(798.118,"?+1"_IENS,.01)="ROR VA HEPC ADMIN"
"RTN","RORPOS02",75,0)
 S RORFDA(798.118,"?+2"_IENS,.01)="ROR VA HEPC USER"
"RTN","RORPOS02",76,0)
 D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORPOS02",77,0)
 I $G(DIERR)  D  Q RC
"RTN","RORPOS02",78,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"UPDKEYS^RORPOS02",,798.118)
"RTN","RORPOS02",79,0)
 ;--- Success
"RTN","RORPOS02",80,0)
 D MES^RORKIDS("The multiple has been updated successfully.")
"RTN","RORPOS02",81,0)
 Q 0
"RTN","RORPOS02",82,0)
 ;
"RTN","RORPOS02",83,0)
 ;***** UPDATES THE 'EXTRACTED RESULT' MULTIPLE OF THE FILE #798.1
"RTN","RORPOS02",84,0)
 ;
"RTN","RORPOS02",85,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPOS02",86,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPOS02",87,0)
 ;
"RTN","RORPOS02",88,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPOS02",89,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPOS02",90,0)
 ; sub-nodes of the same name.
"RTN","RORPOS02",91,0)
 ;
"RTN","RORPOS02",92,0)
 ; Return Values:
"RTN","RORPOS02",93,0)
 ;       <0  Error code
"RTN","RORPOS02",94,0)
 ;        0  Ok
"RTN","RORPOS02",95,0)
 ;
"RTN","RORPOS02",96,0)
UPDLOINC(RORREG) ;
"RTN","RORPOS02",97,0)
 N BUF,DA,DIK,IENS,IR,LCI,LOINC,RC,RORBUF,RORERRDL,RORFDA,RORMSG,TLI
"RTN","RORPOS02",98,0)
 D BMES^RORKIDS("Updating the EXTRACTED RESULT multiple...")
"RTN","RORPOS02",99,0)
 D DFLTLOC^RORERR("UPDLOINC^RORPOS02")
"RTN","RORPOS02",100,0)
 ;--- Get the registry
"RTN","RORPOS02",101,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPOS02",102,0)
 ;--- Delete unnecessary LOINC codes
"RTN","RORPOS02",103,0)
 S IENS=","_(+RORREG)_",",RC=0
"RTN","RORPOS02",104,0)
 F TLI=1:1  S BUF=$T(LOINCDEL+TLI)  Q:BUF'[";;"  D  Q:RC<0
"RTN","RORPOS02",105,0)
 . S BUF=$TR($P(BUF,";;",2)," ")
"RTN","RORPOS02",106,0)
 . F LCI=1:1  S LOINC=$P(BUF,",",LCI)  Q:LOINC=""  D  Q:RC<0
"RTN","RORPOS02",107,0)
 . . D FIND^DIC(798.112,IENS,"@","QX",LOINC,,"B",,,"RORBUF","RORMSG")
"RTN","RORPOS02",108,0)
 . . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,798.112,IENS)  Q
"RTN","RORPOS02",109,0)
 . . S IR="",DIK=$$ROOT^DILFD(798.112,IENS),DA(1)=+RORREG
"RTN","RORPOS02",110,0)
 . . F  S IR=$O(RORBUF("DILIST",2,IR))  Q:IR=""  D
"RTN","RORPOS02",111,0)
 . . . S DA=RORBUF("DILIST",2,IR)  D ^DIK
"RTN","RORPOS02",112,0)
 Q:RC<0 RC
"RTN","RORPOS02",113,0)
 ;--- Add new LOINC codes
"RTN","RORPOS02",114,0)
 S IENS="?+1,"_(+RORREG)_",",RC=0
"RTN","RORPOS02",115,0)
 F TLI=1:1  S BUF=$T(LOINCADD+TLI)  Q:BUF'[";;"  D  Q:RC<0
"RTN","RORPOS02",116,0)
 . S BUF=$TR($P(BUF,";;",2)," ")
"RTN","RORPOS02",117,0)
 . F LCI=1:1  S LOINC=$P(BUF,",",LCI)  Q:LOINC=""  D  Q:RC<0
"RTN","RORPOS02",118,0)
 . . S RORFDA(798.112,IENS,.01)=LOINC
"RTN","RORPOS02",119,0)
 . . D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORPOS02",120,0)
 . . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,798.112,IENS)  Q
"RTN","RORPOS02",121,0)
 Q:RC<0 RC
"RTN","RORPOS02",122,0)
 ;--- Success
"RTN","RORPOS02",123,0)
 D MES^RORKIDS("The multiple has been updated successfully.")
"RTN","RORPOS02",124,0)
 Q 0
"RTN","RORPOS02",125,0)
 ;
"RTN","RORPOS02",126,0)
 ;***** UPDATES REGISTRY PARAMETERS IN THE FILE #798.1
"RTN","RORPOS02",127,0)
 ;
"RTN","RORPOS02",128,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPOS02",129,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPOS02",130,0)
 ;
"RTN","RORPOS02",131,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPOS02",132,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPOS02",133,0)
 ; sub-nodes of the same name.
"RTN","RORPOS02",134,0)
 ;
"RTN","RORPOS02",135,0)
 ; The start date for the next registry update is set to the date
"RTN","RORPOS02",136,0)
 ; when the first patient was added to the registry. So, the search
"RTN","RORPOS02",137,0)
 ; engine will rescan the data and find the HepC patients missed
"RTN","RORPOS02",138,0)
 ; because of the error in the ADD^RORUPP02 function.
"RTN","RORPOS02",139,0)
 ;
"RTN","RORPOS02",140,0)
 ; The LOCAL DATA RESENT field is cleared. This will result in
"RTN","RORPOS02",141,0)
 ; resending the local and demographic data for all patients.
"RTN","RORPOS02",142,0)
 ;
"RTN","RORPOS02",143,0)
 ; Return Values:
"RTN","RORPOS02",144,0)
 ;       <0  Error code
"RTN","RORPOS02",145,0)
 ;        0  Ok
"RTN","RORPOS02",146,0)
 ;
"RTN","RORPOS02",147,0)
UPDPRMS(RORREG) ;
"RTN","RORPOS02",148,0)
 N IENS,RC,RORERRDL,RORFDA,RORMSG,TMP,UPDSTART
"RTN","RORPOS02",149,0)
 D BMES^RORKIDS("Updating the registry parameters...")
"RTN","RORPOS02",150,0)
 D DFLTLOC^RORERR("UPDPRMS^RORPOS02")
"RTN","RORPOS02",151,0)
 ;--- Get the registry
"RTN","RORPOS02",152,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPOS02",153,0)
 ;--- Get the package implementation date
"RTN","RORPOS02",154,0)
 ;--- (when the first patient was added)
"RTN","RORPOS02",155,0)
 S IENS=$O(^RORDATA(798,"AC",+RORREG,""))_","
"RTN","RORPOS02",156,0)
 I IENS  S RC=0  D  Q:RC<0 RC
"RTN","RORPOS02",157,0)
 . S UPDSTART=$$GET1^DIQ(798,IENS,1,"I",,"RORMSG")\1
"RTN","RORPOS02",158,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,798,IENS)
"RTN","RORPOS02",159,0)
 S:$G(UPDSTART)'>0 UPDSTART=3020501  ; May 1, 2002 (just in case)
"RTN","RORPOS02",160,0)
 ;--- Update the parameters
"RTN","RORPOS02",161,0)
 S IENS=(+RORREG)_","
"RTN","RORPOS02",162,0)
 S RORFDA(798.1,IENS,1)=UPDSTART     ; REGISTRY UPDATED UNTIL
"RTN","RORPOS02",163,0)
 S RORFDA(798.1,IENS,13.1)=5         ; MAXIMUM MESSAGE SIZE (MB)
"RTN","RORPOS02",164,0)
 S RORFDA(798.1,IENS,21.04)="@"      ; LOCAL DATA RESENT
"RTN","RORPOS02",165,0)
 S RORFDA(798.1,IENS,26)=1           ; EXCLUDE EMPLOYEES
"RTN","RORPOS02",166,0)
 D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORPOS02",167,0)
 Q:$G(DIERR)>0 $$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","RORPOS02",168,0)
 ;--- Success
"RTN","RORPOS02",169,0)
 D MES^RORKIDS("Parameters have been updated successfully.")
"RTN","RORPOS02",170,0)
 Q 0
"RTN","RORPOS02",171,0)
 ;
"RTN","RORPOS02",172,0)
 ;***** UPDATES THE 'DRUG THERAPY LIST' MULTIPLE OF THE FILE #798.1
"RTN","RORPOS02",173,0)
 ;
"RTN","RORPOS02",174,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPOS02",175,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPOS02",176,0)
 ;
"RTN","RORPOS02",177,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPOS02",178,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPOS02",179,0)
 ; sub-nodes of the same name.
"RTN","RORPOS02",180,0)
 ;
"RTN","RORPOS02",181,0)
 ; Return Values:
"RTN","RORPOS02",182,0)
 ;       <0  Error code
"RTN","RORPOS02",183,0)
 ;        0  Ok
"RTN","RORPOS02",184,0)
 ;
"RTN","RORPOS02",185,0)
UPDRUGS(RORREG) ;
"RTN","RORPOS02",186,0)
 N BUF,DCI,DRUG,IENS,RC,RORFDA,RORMSG,TLI
"RTN","RORPOS02",187,0)
 D BMES^RORKIDS("Updating the DRUG THERAPY LIST multiple...")
"RTN","RORPOS02",188,0)
 ;--- Get the registry
"RTN","RORPOS02",189,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPOS02",190,0)
 ;--- Update the multiple
"RTN","RORPOS02",191,0)
 S IENS="?+1,"_(+RORREG)_",",RC=0
"RTN","RORPOS02",192,0)
 F TLI=1:1  S BUF=$T(DRUGADD+TLI)  Q:BUF'[";;"  D  Q:RC<0
"RTN","RORPOS02",193,0)
 . S BUF=$TR($P(BUF,";;",2)," ")
"RTN","RORPOS02",194,0)
 . F DCI=1:1  S DRUG=$P(BUF,",",DCI)  Q:DRUG=""  D  Q:RC<0
"RTN","RORPOS02",195,0)
 . . S RORFDA(798.117,IENS,.01)=DRUG
"RTN","RORPOS02",196,0)
 . . D UPDATE^DIE(,"RORFDA",,"RORMSG")
"RTN","RORPOS02",197,0)
 . . I $G(DIERR)  D  Q
"RTN","RORPOS02",198,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,"UPDRUGS^RORPOS02",,798.117,IENS)
"RTN","RORPOS02",199,0)
 Q:RC<0 RC
"RTN","RORPOS02",200,0)
 ;--- Success
"RTN","RORPOS02",201,0)
 D MES^RORKIDS("The multiple has been updated successfully.")
"RTN","RORPOS02",202,0)
 Q 0
"RTN","RORPOS02",203,0)
 ;
"RTN","RORPOS02",204,0)
 ;***** DRUGS THAT SHOULD BE ADDED TO THE 'DRUG THERAPY LIST'
"RTN","RORPOS02",205,0)
DRUGADD ;
"RTN","RORPOS02",206,0)
 ;; 000085132704, 000085135105, 000085119403, 000085124201
"RTN","RORPOS02",207,0)
 ;; 000085123501, 000085125401, 055513092601, 055513092606
"RTN","RORPOS02",208,0)
 ;; 055513092701, 055513092706, 000004201709, 000004201707
"RTN","RORPOS02",209,0)
 ;; 000004201509, 000004201507, 000004201609, 000004201607
"RTN","RORPOS02",210,0)
 ;; 000085136801, 000085129101, 000085130401, 000085127901
"RTN","RORPOS02",211,0)
 ;; 000085124201, 000085123501, 000085125401, 055513092601
"RTN","RORPOS02",212,0)
 ;; 055513092606, 055513092701, 055513092706, 000085118402
"RTN","RORPOS02",213,0)
 ;; 000004199309, 000004201009
"RTN","RORPOS02",214,0)
 ;
"RTN","RORPOS02",215,0)
 ;***** LOINC CODES THAT SHOULD BE ADDED TO THE 'EXTRACTED RESULT'
"RTN","RORPOS02",216,0)
LOINCADD ;
"RTN","RORPOS02",217,0)
 ;;  1743,  1744,  6769, 19176, 19177, 22324, 22325, 22326
"RTN","RORPOS02",218,0)
 ;; 16128, 23870,  9608,  9609, 11076, 20416, 20571, 29609
"RTN","RORPOS02",219,0)
 ;;  5047,  9423, 27200, 14631, 14629, 29760, 14682, 14723
"RTN","RORPOS02",220,0)
 ;; 24360,  5181,  5182, 22315,  5183,  5184, 20575, 22312
"RTN","RORPOS02",221,0)
 ;;  5185, 22319, 13919,  5187,  5188,  5194,  5197,  5221
"RTN","RORPOS02",222,0)
 ;; 22356, 14126,  5223, 22357,  5895,   752,   753, 26499
"RTN","RORPOS02",223,0)
 ;; 23761,   769,  5964,  1547, 14749,  1642, 14297, 14999
"RTN","RORPOS02",224,0)
 ;; 27975,   804,  5907, 13951, 13954, 26505
"RTN","RORPOS02",225,0)
 ;
"RTN","RORPOS02",226,0)
 ;***** LOINC CODES THAT SHOULD BE DELETED FROM THE 'EXTRACTED RESULT'
"RTN","RORPOS02",227,0)
LOINCDEL ;
"RTN","RORPOS02",228,0)
 ;; 26499, 22297, 12190,  1970, 29615, 17009,  5119,  2339
"RTN","RORPOS02",229,0)
 ;; 21009, 28942, 10832,  2349, 12651
"RTN","RORPOS03")
0^23^B18615858
"RTN","RORPOS03",1,0)
RORPOS03 ;HCIOFO/SG - POST-INSTALL UTILITIES (ROR*1.0*2) ; 8/16/02 8:34am
"RTN","RORPOS03",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORPOS03",3,0)
 ;
"RTN","RORPOS03",4,0)
 ; This routine uses the following IA's:
"RTN","RORPOS03",5,0)
 ;
"RTN","RORPOS03",6,0)
 ; #3646         $$EMPL^DGSEC4
"RTN","RORPOS03",7,0)
 ; #10113        MailMan: Message Text - Direct Entry
"RTN","RORPOS03",8,0)
 ;
"RTN","RORPOS03",9,0)
 Q
"RTN","RORPOS03",10,0)
 ;
"RTN","RORPOS03",11,0)
 ;***** DELETES EMPLOYEES FROM THE REGISTRY
"RTN","RORPOS03",12,0)
 ;
"RTN","RORPOS03",13,0)
 ; [RORREG]      Registry IEN and registry name separated by the '^'
"RTN","RORPOS03",14,0)
 ;               (RegistryIEN^RegistryName).
"RTN","RORPOS03",15,0)
 ; [ROREMAIL]    E-mail address where the list of patients that
"RTN","RORPOS03",16,0)
 ;               should be deleted from the national database
"RTN","RORPOS03",17,0)
 ;               will be sent.
"RTN","RORPOS03",18,0)
 ;
"RTN","RORPOS03",19,0)
 ; If some of these parameters are omitted or equal to an empty
"RTN","RORPOS03",20,0)
 ; strings, their values must be defined as the RORPARM("KIDS")
"RTN","RORPOS03",21,0)
 ; sub-nodes of the same name.
"RTN","RORPOS03",22,0)
 ;
"RTN","RORPOS03",23,0)
 ; The ^TMP("ROREMPL",$J) global node is used by this function.
"RTN","RORPOS03",24,0)
 ;
"RTN","RORPOS03",25,0)
DELEMPLS(RORREG,ROREMAIL) ;
"RTN","RORPOS03",26,0)
 N NE,RC,XPDIDTOT
"RTN","RORPOS03",27,0)
 ;--- Get the parameters
"RTN","RORPOS03",28,0)
 S:'$G(RORREG) RORREG=$$PARAM^RORKIDS("RORREG")
"RTN","RORPOS03",29,0)
 S:$G(ROREMAIL)="" ROREMAIL=$$PARAM^RORKIDS("ROREMAIL")
"RTN","RORPOS03",30,0)
 ;--- Perform the search
"RTN","RORPOS03",31,0)
 D BMES^RORKIDS("Searching for employees in the registry...")
"RTN","RORPOS03",32,0)
 S (NE,RC)=$$EMPSRCH(+RORREG)
"RTN","RORPOS03",33,0)
 ;--- Send a report and delete records
"RTN","RORPOS03",34,0)
 D:RC'<0
"RTN","RORPOS03",35,0)
 . S RC=$$EMPMSG(NE,ROREMAIL)  Q:RC<0
"RTN","RORPOS03",36,0)
 . I 'NE  D MES^RORKIDS("No employees have been found.")  Q
"RTN","RORPOS03",37,0)
 . D MES^RORKIDS("Deleting employees from the registry...")
"RTN","RORPOS03",38,0)
 . S RC=$$EMPDEL(NE)
"RTN","RORPOS03",39,0)
 ;--- Cleanup
"RTN","RORPOS03",40,0)
 K ^TMP("ROREMPL",$J)
"RTN","RORPOS03",41,0)
 S XPDIDTOT=0  D UPDATE^XPDID(0)
"RTN","RORPOS03",42,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORPOS03",43,0)
 ;
"RTN","RORPOS03",44,0)
 ;***** DELETES THE EMPLOYEES' RECORDS FROM THE FILES
"RTN","RORPOS03",45,0)
 ;
"RTN","RORPOS03",46,0)
 ; XPDIDTOT      Number of employes in the registry
"RTN","RORPOS03",47,0)
 ;
"RTN","RORPOS03",48,0)
 ; Return Values:
"RTN","RORPOS03",49,0)
 ;       <0  Error code
"RTN","RORPOS03",50,0)
 ;        0  Ok
"RTN","RORPOS03",51,0)
 ;
"RTN","RORPOS03",52,0)
EMPDEL(XPDIDTOT) ;
"RTN","RORPOS03",53,0)
 N COUNTER,DA,DIK,IEN,IENS,PATIEN,RC,RORMSG,TMP
"RTN","RORPOS03",54,0)
 ;--- Delete employees' records
"RTN","RORPOS03",55,0)
 S (COUNTER,IEN,RC)=0
"RTN","RORPOS03",56,0)
 F  S IEN=$O(^TMP("ROREMPL",$J,IEN))  Q:'IEN  D  Q:RC<0
"RTN","RORPOS03",57,0)
 . S COUNTER=COUNTER+1  D UPDATE^XPDID(COUNTER)
"RTN","RORPOS03",58,0)
 . S PATIEN=+$P(^TMP("ROREMPL",$J,IEN),"^")
"RTN","RORPOS03",59,0)
 . ;--- Delete the record from the ROR LOCAL REGISTRY file
"RTN","RORPOS03",60,0)
 . S DIK="^RORDATA(798,",DA=IEN  D ^DIK
"RTN","RORPOS03",61,0)
 . ;--- Record a message
"RTN","RORPOS03",62,0)
 . S TMP="Employe has been deleted from the registry"
"RTN","RORPOS03",63,0)
 . D LOG^RORLOG(2,TMP,PATIEN)
"RTN","RORPOS03",64,0)
 . ;--- Check if the patient is in other registries
"RTN","RORPOS03",65,0)
 . Q:$D(^RORDATA(798,"B",PATIEN))>1
"RTN","RORPOS03",66,0)
 . ;--- Delete the record from the ROR PENDING PATIENT file
"RTN","RORPOS03",67,0)
 . S DIK="^RORDATA(798.3,",DA=PATIEN  D ^DIK
"RTN","RORPOS03",68,0)
 . ;--- Delete the record from the ROR PATIENT file
"RTN","RORPOS03",69,0)
 . S DIK="^RORDATA(798.4,",DA=PATIEN  D ^DIK
"RTN","RORPOS03",70,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORPOS03",71,0)
 ;
"RTN","RORPOS03",72,0)
 ;***** SENDS THE LIST OF PATIENTS TO DELETE AT AAC
"RTN","RORPOS03",73,0)
 ;
"RTN","RORPOS03",74,0)
 ; NE            Number of employees founded in the registry
"RTN","RORPOS03",75,0)
 ; EMAIL         E-mail address for the message
"RTN","RORPOS03",76,0)
 ;
"RTN","RORPOS03",77,0)
 ; Return Values:
"RTN","RORPOS03",78,0)
 ;       <0  Error code
"RTN","RORPOS03",79,0)
 ;        0  Ok
"RTN","RORPOS03",80,0)
 ;
"RTN","RORPOS03",81,0)
EMPMSG(NE,EMAIL) ;
"RTN","RORPOS03",82,0)
 N DIFROM,IEN,IL,PATIEN,RC,STN,XMCHAN,XMDF,XMDUZ,XMY,XMSUB
"RTN","RORPOS03",83,0)
 S STN=$E($P($$SITE^VASITE(),U,3),1,3)
"RTN","RORPOS03",84,0)
 S (XMCHAN,XMDF)=1,XMDUZ=.5,IL=0
"RTN","RORPOS03",85,0)
 ;--- Create a message stub
"RTN","RORPOS03",86,0)
 S XMSUB="PATIENTS TO DELETE FROM ROR AAC (STN: "_STN_")"
"RTN","RORPOS03",87,0)
 D XMZ^XMA2
"RTN","RORPOS03",88,0)
 Q:$G(XMZ)<1 $$ERROR^RORERR(-77,"EMPMSG^RORPOS03")
"RTN","RORPOS03",89,0)
 ;--- Create the message text
"RTN","RORPOS03",90,0)
 I NE>0  D
"RTN","RORPOS03",91,0)
 . ;--- Generate header of the report
"RTN","RORPOS03",92,0)
 . S IL=IL+1,^XMB(3.9,XMZ,2,IL,0)="Patient IEN,Station Number"
"RTN","RORPOS03",93,0)
 . ;--- Generate the report
"RTN","RORPOS03",94,0)
 . S IEN=0
"RTN","RORPOS03",95,0)
 . F  S IEN=$O(^TMP("ROREMPL",$J,IEN))  Q:'IEN  D
"RTN","RORPOS03",96,0)
 . . S PATIEN=$P(^TMP("ROREMPL",$J,IEN),"^")
"RTN","RORPOS03",97,0)
 . . S IL=IL+1,^XMB(3.9,XMZ,2,IL,0)=PATIEN_","_STN
"RTN","RORPOS03",98,0)
 E  S IL=IL+1,^XMB(3.9,XMZ,2,IL,0)="No employees have been found."
"RTN","RORPOS03",99,0)
 S ^XMB(3.9,XMZ,2,0)="^3.92^"_IL_"^"_IL_"^"_$$DT^XLFDT
"RTN","RORPOS03",100,0)
 ;--- Send the report
"RTN","RORPOS03",101,0)
 S:$G(^XMB("NETNAME"))[".VA.GOV" XMY(EMAIL)=""
"RTN","RORPOS03",102,0)
 S XMY(DUZ)=""  D ENT1^XMD
"RTN","RORPOS03",103,0)
 Q 0
"RTN","RORPOS03",104,0)
 ;
"RTN","RORPOS03",105,0)
 ;***** SEARCHES FOR EMPLOYES IN THE REGISTRY
"RTN","RORPOS03",106,0)
 ;
"RTN","RORPOS03",107,0)
 ; REGIEN        Registry IEN
"RTN","RORPOS03",108,0)
 ;
"RTN","RORPOS03",109,0)
 ; Return Values:
"RTN","RORPOS03",110,0)
 ;       <0  Error code
"RTN","RORPOS03",111,0)
 ;        0  No employees in the registry
"RTN","RORPOS03",112,0)
 ;       >0  Number of employees
"RTN","RORPOS03",113,0)
 ;
"RTN","RORPOS03",114,0)
EMPSRCH(REGIEN) ;
"RTN","RORPOS03",115,0)
 N COUNTER,IEN,IENS,PATIEN,RC,RORBUF,RORMSG
"RTN","RORPOS03",116,0)
 K ^TMP("ROREMPL",$J)
"RTN","RORPOS03",117,0)
 ;--- Initialize the progress bar
"RTN","RORPOS03",118,0)
 S IENS=REGIEN_","
"RTN","RORPOS03",119,0)
 S XPDIDTOT=+$$GET1^DIQ(798.1,IENS,19.1,,,"RORMSG")
"RTN","RORPOS03",120,0)
 I $G(DIERR)>0  D  Q RC
"RTN","RORPOS03",121,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"EMPSRCH^RORPOS03",,798.1,IENS)
"RTN","RORPOS03",122,0)
 D UPDATE^XPDID(0)
"RTN","RORPOS03",123,0)
 ;--- Search the registry for employees
"RTN","RORPOS03",124,0)
 S (COUNTER,IEN,RC)=0
"RTN","RORPOS03",125,0)
 F  S IEN=$O(^RORDATA(798,"AC",REGIEN,IEN))  Q:'IEN  D  Q:RC<0
"RTN","RORPOS03",126,0)
 . S COUNTER=COUNTER+1
"RTN","RORPOS03",127,0)
 . D:'(COUNTER#50) UPDATE^XPDID(COUNTER)
"RTN","RORPOS03",128,0)
 . S IENS=IEN_","
"RTN","RORPOS03",129,0)
 . S PATIEN=$$GET1^DIQ(798,IENS,.01,"I",,"RORMSG")
"RTN","RORPOS03",130,0)
 . I $G(DIERR)>0  D  Q
"RTN","RORPOS03",131,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"EMPSRCH^RORPOS03",,798,IENS)
"RTN","RORPOS03",132,0)
 . I PATIEN  D:$$EMPL^DGSEC4(PATIEN,"P")
"RTN","RORPOS03",133,0)
 . . S ^TMP("ROREMPL",$J,IEN)=PATIEN,COUNTER(1)=$G(COUNTER(1))+1
"RTN","RORPOS03",134,0)
 Q $S(RC'<0:+$G(COUNTER(1)),1:RC)
"RTN","RORRP5")
0^22^B3868161
"RTN","RORRP5",1,0)
RORRP5 ;HOIFO/CRT - Clinical Registries Pateint Search RPC ; 8/7/02 10:30am
"RTN","RORRP5",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORRP5",3,0)
 ;
"RTN","RORRP5",4,0)
EN1(RES,RORREG,RORPART,RORDIR,RORFILE,RORSCRN) ; Return (Partial) Patient List
"RTN","RORRP5",5,0)
 ;
"RTN","RORRP5",6,0)
 ; Remote Procedure: ROR PATIENT SEARCH
"RTN","RORRP5",7,0)
 ; Input: RORREG - Registry Name (Req'd)
"RTN","RORRP5",8,0)
 ;        RORPART - Partial Match (Req'd)
"RTN","RORRP5",9,0)
 ;        RORDIR - Direction. 1 = forward, -1 = back. (Req'd)
"RTN","RORRP5",10,0)
 ;        RORFILE - Search File. 2 or 798 (Req'd)
"RTN","RORRP5",11,0)
 ;        RORSCRN - Date to screen file 798 on (opt'l)
"RTN","RORRP5",12,0)
 ; Output: RES - List of Patients (#2). NAME^SSN^DOB^IEN
"RTN","RORRP5",13,0)
 ;
"RTN","RORRP5",14,0)
 N CNT,I,INDEX,LOOP,SCREEN,RORREG1
"RTN","RORRP5",15,0)
 ;
"RTN","RORRP5",16,0)
 S RES=$NA(^TMP($J,"ROR-SEARCH")) K @RES
"RTN","RORRP5",17,0)
 ;
"RTN","RORRP5",18,0)
 S SCREEN=""
"RTN","RORRP5",19,0)
 S RORREG=$G(RORREG) Q:RORREG=""
"RTN","RORRP5",20,0)
 S RORINDX=$S(RORPART?4N:"BS",RORPART?1U4N:"BS5",RORPART?9N.1"P":"SSN",1:"B")
"RTN","RORRP5",21,0)
 S RORFILE=$S($G(RORFILE)=798:798.4,1:2)
"RTN","RORRP5",22,0)
 S RORDIR=$S(RORDIR="-1":"B",1:"")
"RTN","RORRP5",23,0)
 S RORSCRN=$G(RORSCRN)
"RTN","RORRP5",24,0)
 I RORFILE=798.4 D
"RTN","RORRP5",25,0)
 .S SCREEN="I $$IEN798^RORRP2(+Y,RORREG)"
"RTN","RORRP5",26,0)
 .I RORSCRN'="" S SCREEN=SCREEN_",($P(^RORDATA(798,$$IEN798^RORRP2(+Y,RORREG),0),""^"",3)'<RORSCRN)"
"RTN","RORRP5",27,0)
 ;
"RTN","RORRP5",28,0)
 I RORFILE=2 D
"RTN","RORRP5",29,0)
 .S RORREG1=+$$REG^RORRP1(RORREG) S ^ZZBH("TEST")=RORREG_" "_RORREG1
"RTN","RORRP5",30,0)
 .S SCREEN="I '$$SKIPEMPL^RORUTL02(+Y,.RORREG1)"
"RTN","RORRP5",31,0)
 D LIST^DIC(RORFILE,,".01;.03;.09",RORDIR,,,RORPART,RORINDX,SCREEN,,"^TMP($J,""ROROUT"")","RORMSG")
"RTN","RORRP5",32,0)
 ;
"RTN","RORRP5",33,0)
 S I=0 F  S I=$O(^TMP($J,"ROROUT","DILIST","ID",I)) Q:'I  D
"RTN","RORRP5",34,0)
 .S @RES@(I)=$$ADD(I)
"RTN","RORRP5",35,0)
 ;
"RTN","RORRP5",36,0)
 K ^TMP($J,"ROROUT")
"RTN","RORRP5",37,0)
 ;
"RTN","RORRP5",38,0)
 Q
"RTN","RORRP5",39,0)
 ;
"RTN","RORRP5",40,0)
ADD(J) ;
"RTN","RORRP5",41,0)
 N RESULT
"RTN","RORRP5",42,0)
 ;
"RTN","RORRP5",43,0)
 S $P(RESULT,"^",1)=^TMP($J,"ROROUT","DILIST","ID",J,.01)
"RTN","RORRP5",44,0)
 S $P(RESULT,"^",2)=^TMP($J,"ROROUT","DILIST","ID",J,.09)
"RTN","RORRP5",45,0)
 S $P(RESULT,"^",3)=^TMP($J,"ROROUT","DILIST","ID",J,.03)
"RTN","RORRP5",46,0)
 S $P(RESULT,"^",4)=^TMP($J,"ROROUT","DILIST",2,J)
"RTN","RORRP5",47,0)
 ;
"RTN","RORRP5",48,0)
 Q RESULT
"RTN","RORRP9")
0^39^B45932470
"RTN","RORRP9",1,0)
RORRP9 ; HOIFO/CRT - HepC Drug Therapy List RPC ; [06-22-2001 12:25]
"RTN","RORRP9",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORRP9",3,0)
 ;
"RTN","RORRP9",4,0)
 Q
"RTN","RORRP9",5,0)
 ;
"RTN","RORRP9",6,0)
DFN(RORIEN,RORSDT) ; Return Patient DFN, or 0 if excluded
"RTN","RORRP9",7,0)
 ;
"RTN","RORRP9",8,0)
 N RORACT,RORDFN,RORDOD,RORINACT
"RTN","RORRP9",9,0)
 ;
"RTN","RORRP9",10,0)
 S RORDFN=+$$GET1^DIQ(798,+$G(RORIEN),.01,"I")
"RTN","RORRP9",11,0)
 I 'RORDFN Q 0                   ; Exclude (Unknown DFN)
"RTN","RORRP9",12,0)
 ;
"RTN","RORRP9",13,0)
 S RORDOD=+$$GET1^DIQ(798.4,RORDFN,.351,"I")
"RTN","RORRP9",14,0)
 I RORDOD,RORDOD<$G(RORSDT) Q 0  ; Exclude (Deceased before start)
"RTN","RORRP9",15,0)
 ;
"RTN","RORRP9",16,0)
 S RORINACT=+$$GET1^DIQ(798,+$G(RORIEN),2,"I")
"RTN","RORRP9",17,0)
 I 'RORINACT Q RORDFN
"RTN","RORRP9",18,0)
 S RORACT=+$$GET1^DIQ(798,+$G(RORIEN),7,"I")
"RTN","RORRP9",19,0)
 I RORACT>RORINACT Q RORDFN
"RTN","RORRP9",20,0)
 I RORINACT<+$G(RORSDT) Q 0  ; Exclude (Inactivated before start)
"RTN","RORRP9",21,0)
 Q RORDFN
"RTN","RORRP9",22,0)
 ;
"RTN","RORRP9",23,0)
ADD(RORDFN,ROROCL,RORNEW,RORSTDT,RORENDT,RORCNT) ;
"RTN","RORRP9",24,0)
 ;
"RTN","RORRP9",25,0)
 N RORDATE,RORDESC,RORII,RORNAME,RORNDC,ROROEL,RORRXN,RORSSN
"RTN","RORRP9",26,0)
 ;
"RTN","RORRP9",27,0)
 S RORDFN=+$G(RORDFN) Q:'RORDFN
"RTN","RORRP9",28,0)
 S ROROCL=$G(ROROCL) Q:ROROCL=""
"RTN","RORRP9",29,0)
 S RORNEW=+$G(RORNEW)
"RTN","RORRP9",30,0)
 ;
"RTN","RORRP9",31,0)
 S RORNAME=$$GET1^DIQ(798.4,RORDFN,.01)
"RTN","RORRP9",32,0)
 S RORSSN=$E($$GET1^DIQ(798.4,RORDFN,.09),6,9)
"RTN","RORRP9",33,0)
 ;
"RTN","RORRP9",34,0)
 K ^TMP("PS",$J)
"RTN","RORRP9",35,0)
 D OEL^PSOORRL(RORDFN,ROROCL)
"RTN","RORRP9",36,0)
 Q:'$D(^TMP("PS",$J))
"RTN","RORRP9",37,0)
 ;
"RTN","RORRP9",38,0)
 S ROROEL=^TMP("PS",$J,0)
"RTN","RORRP9",39,0)
 S RORRXN=$G(^TMP("PS",$J,"RXN",0))
"RTN","RORRP9",40,0)
 S RORDESC=$P($G(ROROEL),"^",1)
"RTN","RORRP9",41,0)
 ;
"RTN","RORRP9",42,0)
 I ROROCL["R;O" D
"RTN","RORRP9",43,0)
 .S ^TMP("PS",$J,"REF",0,0)=$P(RORRXN,"^",6)_"^"_$P(ROROEL,"^",7)_"^"_$P(ROROEL,"^",8)_"^"_$P(RORRXN,"^",7)_"^"_$P(RORRXN,"^",3)
"RTN","RORRP9",44,0)
 ;
"RTN","RORRP9",45,0)
 S RORNDC=$P($G(^TMP("PS",$J,"DD",1,0)),"^",1)
"RTN","RORRP9",46,0)
 S:RORNDC="" RORNDC=$P($G(^TMP("PS",$J,"DD",1,0)),"^",3)
"RTN","RORRP9",47,0)
 I RORNDC D
"RTN","RORRP9",48,0)
 .S RORDESC=$$GET1^DIQ(50,RORNDC,.01,"E")
"RTN","RORRP9",49,0)
 .S RORNDC=$$GET1^DIQ(50,RORNDC,31)
"RTN","RORRP9",50,0)
 ;
"RTN","RORRP9",51,0)
 I ROROCL["U;I" D
"RTN","RORRP9",52,0)
 .S RORDATE=$$FORMAT^RORRP6($P($G(ROROEL),"^",5))
"RTN","RORRP9",53,0)
 .D ADD1(.RORNEW)
"RTN","RORRP9",54,0)
 ;
"RTN","RORRP9",55,0)
 I ROROCL["R;O" D
"RTN","RORRP9",56,0)
 .S RORII="" F  S RORII=$O(^TMP("PS",$J,"REF",RORII)) Q:RORII=""  D
"RTN","RORRP9",57,0)
 ..S RORDATE=+$P($G(^TMP("PS",$J,"REF",RORII,0)),"^")
"RTN","RORRP9",58,0)
 ..I ((RORDATE<RORSTDT)!(RORDATE>RORENDT)) Q
"RTN","RORRP9",59,0)
 ..S RORDATE=$$FORMAT^RORRP6(RORDATE)
"RTN","RORRP9",60,0)
 ..D ADD1(.RORNEW)
"RTN","RORRP9",61,0)
 ;
"RTN","RORRP9",62,0)
 K ^TMP("PS",$J)
"RTN","RORRP9",63,0)
 ;
"RTN","RORRP9",64,0)
 Q
"RTN","RORRP9",65,0)
 ;
"RTN","RORRP9",66,0)
ADD1(RORNEW) ;
"RTN","RORRP9",67,0)
 S RORCNT=$G(RORCNT)+1
"RTN","RORRP9",68,0)
 S @RES@(RORCNT)="^^"_RORDESC_"^"_RORNDC_"^"_RORDATE
"RTN","RORRP9",69,0)
 S:RORNEW $P(@RES@(RORCNT),"^",1,2)=RORNAME_"^"_RORSSN
"RTN","RORRP9",70,0)
 S RORNEW=0
"RTN","RORRP9",71,0)
 Q
"RTN","RORRP9",72,0)
 ;
"RTN","RORRP9",73,0)
EN1(RES,RORREG,RORSTDT,RORENDT) ;
"RTN","RORRP9",74,0)
 ;
"RTN","RORRP9",75,0)
 ; INPUT: RORREG - Registry Name                           (Required)
"RTN","RORRP9",76,0)
 ;        RORSTDT - Start Date (FileMan Format)            (Optional)
"RTN","RORRP9",77,0)
 ;        RORENDT - End Date (FileMan Format)              (Optional)
"RTN","RORRP9",78,0)
 ;
"RTN","RORRP9",79,0)
 N RORCODE,RORCNT,RORDESC,RORDFN,RORI,RORIDATE,RORINC,RORJ,RORNEW,RORRX
"RTN","RORRP9",80,0)
 N X,X1,X2,Y
"RTN","RORRP9",81,0)
 ;
"RTN","RORRP9",82,0)
 S RES=$NA(^XTMP("ROR DRUG LIST"_$J))
"RTN","RORRP9",83,0)
 K @RES
"RTN","RORRP9",84,0)
 I '$G(DT) D NOW^%DTC S DT=X
"RTN","RORRP9",85,0)
 S X1=DT,X2=30
"RTN","RORRP9",86,0)
 D C^%DTC
"RTN","RORRP9",87,0)
 S @RES@(0)=X_"^"_DT_"^ROR DRUG LIST REPORT"
"RTN","RORRP9",88,0)
 ;
"RTN","RORRP9",89,0)
 S RORSTDT=$P($G(RORSTDT),".")
"RTN","RORRP9",90,0)
 S RORENDT=$P($G(RORENDT),".")
"RTN","RORRP9",91,0)
 S @RES@(1)=RORSTDT_"^"_RORENDT
"RTN","RORRP9",92,0)
 S:RORSTDT="" RORSTDT=1
"RTN","RORRP9",93,0)
 S:RORENDT="" RORENDT=9999999
"RTN","RORRP9",94,0)
 ;
"RTN","RORRP9",95,0)
 S RORREG=$$REG^RORRP1($G(RORREG)) Q:'RORREG
"RTN","RORRP9",96,0)
 ;
"RTN","RORRP9",97,0)
 D RORLIST(.RORRX,RORREG)
"RTN","RORRP9",98,0)
 ;
"RTN","RORRP9",99,0)
 D CODEROR^RORRP6(.RORCODE,RORREG)
"RTN","RORRP9",100,0)
 ;
"RTN","RORRP9",101,0)
 D CODEPS^RORRP6(.RORRX,.RORCODE)
"RTN","RORRP9",102,0)
 ;
"RTN","RORRP9",103,0)
 I '$D(RORRX) Q
"RTN","RORRP9",104,0)
 ;
"RTN","RORRP9",105,0)
 S RORCNT=1
"RTN","RORRP9",106,0)
 S RORIEN=0 F  S RORIEN=$O(^RORDATA(798,"AC",RORREG,RORIEN)) Q:'RORIEN  D
"RTN","RORRP9",107,0)
 . S RORNEW=1
"RTN","RORRP9",108,0)
 . S RORDFN=$$DFN(RORIEN,RORSTDT) Q:'RORDFN
"RTN","RORRP9",109,0)
 . K ^TMP("PS",$J),^TMP("ROR-PS-LIST",$J)
"RTN","RORRP9",110,0)
 . D OCL^PSOORRL(RORDFN,RORSTDT,RORENDT)
"RTN","RORRP9",111,0)
 . Q:'$D(^TMP("PS",$J))
"RTN","RORRP9",112,0)
 . M ^TMP("ROR-PS-LIST",$J)=^TMP("PS",$J)
"RTN","RORRP9",113,0)
 . K ^TMP("PS",$J)
"RTN","RORRP9",114,0)
 . S RORI=0 F  S RORI=$O(^TMP("ROR-PS-LIST",$J,RORI)) Q:'RORI  D
"RTN","RORRP9",115,0)
 . . N RORTYP
"RTN","RORRP9",116,0)
 . . S RORTYP=$P($G(^TMP("ROR-PS-LIST",$J,RORI,0)),"^",1)
"RTN","RORRP9",117,0)
 . . I ((RORTYP'["R;O")&(RORTYP'["U;I")) Q
"RTN","RORRP9",118,0)
 . . I RORTYP["U;I" D  I ((RORIDATE<RORSTDT)!(RORIDATE>RORENDT)) Q
"RTN","RORRP9",119,0)
 . . . S RORIDATE=+$P($G(^TMP("ROR-PS-LIST",$J,RORI,0)),"^",15)
"RTN","RORRP9",120,0)
 . . I RORTYP["R;O" D  Q:RORIDATE<RORSTDT
"RTN","RORRP9",121,0)
 . . . S RORIDATE=+$P($G(^TMP("ROR-PS-LIST",$J,RORI,0)),"^",10)
"RTN","RORRP9",122,0)
 . . S RORDESC=$P($G(^TMP("ROR-PS-LIST",$J,RORI,0)),"^",2)
"RTN","RORRP9",123,0)
 . . S RORINC=0
"RTN","RORRP9",124,0)
 . . S RORJ="" F  S RORJ=$O(RORRX(RORJ)) Q:RORJ=""  D  Q:RORINC
"RTN","RORRP9",125,0)
 . . . I RORJ=RORDESC S RORINC=1 Q
"RTN","RORRP9",126,0)
 . . I RORINC D ADD(RORDFN,$P(^TMP("ROR-PS-LIST",$J,RORI,0),"^"),.RORNEW,RORSTDT,RORENDT,.RORCNT)
"RTN","RORRP9",127,0)
 K ^TMP("ROR-PS-LIST",$J)
"RTN","RORRP9",128,0)
 ;
"RTN","RORRP9",129,0)
 Q
"RTN","RORRP9",130,0)
 ;
"RTN","RORRP9",131,0)
EN2(RES,RORREG,RORHNDL,RORFLD) ; ROR STORE RPC HANDLE
"RTN","RORRP9",132,0)
 ;
"RTN","RORRP9",133,0)
 ; INPUT: RORREG - Registry Name                           (Required)
"RTN","RORRP9",134,0)
 ;        RORHNDL - Deferred RPC Handle                    (Required)
"RTN","RORRP9",135,0)
 ;        RORFLD - 16 for Drug Rep Handle, 18 for Loc Reg Rep Handle
"RTN","RORRP9",136,0)
 ;                 (16 and 18 used to refer to the field numbers,
"RTN","RORRP9",137,0)
 ;                  but these have changed in the data dictionary,
"RTN","RORRP9",138,0)
 ;                  which is why they appear a bit random!!!!!!)
"RTN","RORRP9",139,0)
 ;
"RTN","RORRP9",140,0)
 N RORNODE,RORPREV,RORRES,RORRES
"RTN","RORRP9",141,0)
 ;
"RTN","RORRP9",142,0)
 S RORREG=+$$REG^RORRP1($G(RORREG)) I RORREG<0 D  Q
"RTN","RORRP9",143,0)
 .S RES(0)="-1^Invalid Registry"
"RTN","RORRP9",144,0)
 ;
"RTN","RORRP9",145,0)
 S RORHNDL=$G(RORHNDL) I RORHNDL="" D  Q
"RTN","RORRP9",146,0)
 .S RES(0)="-1^Unknown Handle"
"RTN","RORRP9",147,0)
 ;
"RTN","RORRP9",148,0)
 S RORFLD=$S($G(RORFLD)="18":"3",1:"2")
"RTN","RORRP9",149,0)
 ;
"RTN","RORRP9",150,0)
 S RORNODE=+$O(^ROR(798.1,RORREG,13,"B",DUZ,0))
"RTN","RORRP9",151,0)
 I RORNODE D
"RTN","RORRP9",152,0)
 .S RORPREV=$P($G(^ROR(798.1,RORREG,13,RORNODE,0)),"^",RORFLD)
"RTN","RORRP9",153,0)
 .D:RORPREV]"" CLEAR^XWBDRPC(.RORRES,RORPREV)
"RTN","RORRP9",154,0)
 .S $P(^ROR(798.1,RORREG,13,RORNODE,0),"^",RORFLD)=RORHNDL
"RTN","RORRP9",155,0)
 E  D
"RTN","RORRP9",156,0)
 .N ROR1,NIEN,ERR
"RTN","RORRP9",157,0)
 .S ROR1(798.116,"+1,"_RORREG_",",.01)=DUZ
"RTN","RORRP9",158,0)
 .S ROR1(798.116,"+1,"_RORREG_",",RORFLD-1)=RORHNDL
"RTN","RORRP9",159,0)
 .D UPDATE^DIE("","ROR1","NIEN","ERR")
"RTN","RORRP9",160,0)
 ;
"RTN","RORRP9",161,0)
 S RES(0)=RORHNDL
"RTN","RORRP9",162,0)
 ;
"RTN","RORRP9",163,0)
 Q
"RTN","RORRP9",164,0)
 ;
"RTN","RORRP9",165,0)
EN3(RES,RORREG,RORFLD) ; ROR GET RPC HANDLE
"RTN","RORRP9",166,0)
 ;
"RTN","RORRP9",167,0)
 ; INPUT: RORREG - Registry Name                           (Required)
"RTN","RORRP9",168,0)
 ;        RORFLD - 16 for Drug Rep Handle, 18 for Loc Reg Rep Handle
"RTN","RORRP9",169,0)
 ;                 (16 and 18 used to refer to the field numbers,
"RTN","RORRP9",170,0)
 ;                  but these have changed in the data dictionary,
"RTN","RORRP9",171,0)
 ;                  which is why they appear a bit random!!!!!!)
"RTN","RORRP9",172,0)
 ;
"RTN","RORRP9",173,0)
 N RORNODE,RORRES
"RTN","RORRP9",174,0)
 ;
"RTN","RORRP9",175,0)
 S RORREG=+$$REG^RORRP1($G(RORREG)) I RORREG<0 D  Q
"RTN","RORRP9",176,0)
 .S RES(0)="-1^Invalid Registry"
"RTN","RORRP9",177,0)
 ;
"RTN","RORRP9",178,0)
 S RORFLD=$S($G(RORFLD)="18":"3",1:"2")
"RTN","RORRP9",179,0)
 ;
"RTN","RORRP9",180,0)
 S RORNODE=+$O(^ROR(798.1,RORREG,13,"B",DUZ,0))
"RTN","RORRP9",181,0)
 S RES(0)=$P($G(^ROR(798.1,RORREG,13,RORNODE,0)),"^",RORFLD)
"RTN","RORRP9",182,0)
 ;
"RTN","RORRP9",183,0)
 I RES(0)="" D  Q
"RTN","RORRP9",184,0)
 .S RES(0)=""
"RTN","RORRP9",185,0)
 .S RES(1)="Never Run"
"RTN","RORRP9",186,0)
 .S RES(2)=""
"RTN","RORRP9",187,0)
 ;
"RTN","RORRP9",188,0)
 D RPCCHK^XWBDRPC(.RORRES,RES(0))
"RTN","RORRP9",189,0)
 S RES(1)=$P(RORRES(0),"^",2)
"RTN","RORRP9",190,0)
 S RES(2)=$G(^XTMP(RES(0),"TASKID"))
"RTN","RORRP9",191,0)
 ; 
"RTN","RORRP9",192,0)
 Q
"RTN","RORRP9",193,0)
 ;
"RTN","RORRP9",194,0)
EN4(RES,RORREG,RORFLD) ; ROR CLEAR RPC HANDLE
"RTN","RORRP9",195,0)
 ;
"RTN","RORRP9",196,0)
 ; INPUT: RORREG - Registry Name                           (Required)
"RTN","RORRP9",197,0)
 ;        RORFLD - 16 for Drug Rep Handle, 18 for Loc Reg Rep Handle
"RTN","RORRP9",198,0)
 ;                 (16 and 18 used to refer to the field numbers,
"RTN","RORRP9",199,0)
 ;                  but these have changed in the data dictionary,
"RTN","RORRP9",200,0)
 ;                  which is why they appear a bit random!!!!!!)
"RTN","RORRP9",201,0)
 ;
"RTN","RORRP9",202,0)
 N RORNODE,RORPREV,RORRES
"RTN","RORRP9",203,0)
 ;
"RTN","RORRP9",204,0)
 S RORREG=+$$REG^RORRP1($G(RORREG)) I RORREG<0 D  Q
"RTN","RORRP9",205,0)
 .S RES="-1^Invalid Registry"
"RTN","RORRP9",206,0)
 ;
"RTN","RORRP9",207,0)
 S RORFLD=$S($G(RORFLD)="18":"3",1:"2")
"RTN","RORRP9",208,0)
 ;
"RTN","RORRP9",209,0)
 S RORNODE=+$O(^ROR(798.1,RORREG,13,"B",DUZ,0))
"RTN","RORRP9",210,0)
 ;
"RTN","RORRP9",211,0)
 S RORPREV=$P($G(^ROR(798.1,RORREG,13,RORNODE,0)),"^",RORFLD)
"RTN","RORRP9",212,0)
 ;
"RTN","RORRP9",213,0)
 I RORPREV]"" D
"RTN","RORRP9",214,0)
 .H 3                      ; Added in ROR*1.0*2 - NOIS SBY-0702-30545
"RTN","RORRP9",215,0)
 .D CLEAR^XWBDRPC(.RORRES,RORPREV)
"RTN","RORRP9",216,0)
 .S $P(^ROR(798.1,RORREG,13,RORNODE,0),"^",RORFLD)=""
"RTN","RORRP9",217,0)
 ;
"RTN","RORRP9",218,0)
 S RES="1^Success"
"RTN","RORRP9",219,0)
 ;
"RTN","RORRP9",220,0)
 Q
"RTN","RORRP9",221,0)
 ;
"RTN","RORRP9",222,0)
RORLIST(RORCODE,RORREG) ;
"RTN","RORRP9",223,0)
 ;
"RTN","RORRP9",224,0)
 N RORDRG,RORIEN,RORNDC
"RTN","RORRP9",225,0)
 ;
"RTN","RORRP9",226,0)
 Q:'$G(RORREG)
"RTN","RORRP9",227,0)
 ;
"RTN","RORRP9",228,0)
 S RORNDC=0
"RTN","RORRP9",229,0)
 F  S RORNDC=$O(^ROR(798.1,RORREG,12,"B",RORNDC)) Q:'RORNDC  D
"RTN","RORRP9",230,0)
 .I '$D(^PSDRUG("NDC",RORNDC)) Q
"RTN","RORRP9",231,0)
 .S RORIEN=""
"RTN","RORRP9",232,0)
 .F  S RORIEN=$O(^PSDRUG("NDC",RORNDC,RORIEN)) Q:'RORIEN  D
"RTN","RORRP9",233,0)
 ..S RORDRG=$$GET1^DIQ(50,+RORIEN,.01,"E")
"RTN","RORRP9",234,0)
 ..S:RORDRG]"" RORCODE(RORDRG)=""
"RTN","RORRP9",235,0)
 ..S RORDRG=$$GET1^DIQ(50.68,+$$GET1^DIQ(50,+RORIEN,22,"I"),4)
"RTN","RORRP9",236,0)
 ..S:RORDRG]"" RORCODE(RORDRG)=""
"RTN","RORRP9",237,0)
 Q
"RTN","RORUPD")
0^33^B30208257
"RTN","RORUPD",1,0)
RORUPD ;HCIOFO/SG - REGISTRY UPDATE ; 8/5/02 11:18am
"RTN","RORUPD",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORUPD",3,0)
 ;
"RTN","RORUPD",4,0)
 ; RORLRC -------------- LIST OF LAB RESULT CODES TO CHECK
"RTN","RORUPD",5,0)
 ;
"RTN","RORUPD",6,0)
 ; RORLRC(Seq#)          Lab result code (see the LA7SC parameter of
"RTN","RORUPD",7,0)
 ;                       the GCPR^LA7QRY entry point)
"RTN","RORUPD",8,0)
 ;                         ^1: Result code
"RTN","RORUPD",9,0)
 ;                         ^2: Coding system ("LN" or "NLT")
"RTN","RORUPD",10,0)
 ;
"RTN","RORUPD",11,0)
 ; RORUPD -------------- REGISTRY UPDATE DESCRIPTOR
"RTN","RORUPD",12,0)
 ;
"RTN","RORUPD",13,0)
 ; RORUPD("DT")          Date/time when update process started
"RTN","RORUPD",14,0)
 ;
"RTN","RORUPD",15,0)
 ; RORUPD("DSBEG")       Start date of the data scan
"RTN","RORUPD",16,0)
 ; RORUPD("DSEND")       End date of the data scan
"RTN","RORUPD",17,0)
 ;                       (these nodes are set by $$PREPARE1^RORUPR)
"RTN","RORUPD",18,0)
 ;
"RTN","RORUPD",19,0)
 ; RORUPD("EETS")        Timestamp of the earliest event reference
"RTN","RORUPD",20,0)
 ;
"RTN","RORUPD",21,0)
 ; RORUPD("ERRCNT")      Counter of errors during processing of the
"RTN","RORUPD",22,0)
 ;                       current patient
"RTN","RORUPD",23,0)
 ;
"RTN","RORUPD",24,0)
 ; RORUPD("FLAGS")       Flags to control processing. The possible
"RTN","RORUPD",25,0)
 ;                       values (can be combined) are:
"RTN","RORUPD",26,0)
 ;                         "E" Use event references (file #798.3)
"RTN","RORUPD",27,0)
 ;
"RTN","RORUPD",28,0)
 ; RORUPD("JOB")         Job number of the main task. This node is
"RTN","RORUPD",29,0)
 ;                       defined only if the registry update is
"RTN","RORUPD",30,0)
 ;                       running in the multitask mode.
"RTN","RORUPD",31,0)
 ;
"RTN","RORUPD",32,0)
 ; RORUPD("LD",          Instead of checking data in the interval
"RTN","RORUPD",33,0)
 ;                       from start date till end date, update process
"RTN","RORUPD",34,0)
 ;                       starts checks from the start date minus
"RTN","RORUPD",35,0)
 ;                       appropriate number of lag days. Thus, data
"RTN","RORUPD",36,0)
 ;                       entered retrospectively will not be missed.
"RTN","RORUPD",37,0)
 ;   1)                  Lag days for data examination
"RTN","RORUPD",38,0)
 ;
"RTN","RORUPD",39,0)
 ; RORUPD("LM",          Loop control mode. It defines when to stop
"RTN","RORUPD",40,0)
 ;                       looping through records of the patient:
"RTN","RORUPD",41,0)
 ;                         0  always loop through all records
"RTN","RORUPD",42,0)
 ;                         1  all top level rules have been triggered
"RTN","RORUPD",43,0)
 ;                            for the patient (default)
"RTN","RORUPD",44,0)
 ;                         2  patient has been marked for addition to
"RTN","RORUPD",45,0)
 ;                            all registries being processed
"RTN","RORUPD",46,0)
 ;   1,Rule Name)        Current list of names of top level rules
"RTN","RORUPD",47,0)
 ;   2,Registry#)        Current list of registry IENs
"RTN","RORUPD",48,0)
 ;
"RTN","RORUPD",49,0)
 ; RORUPD("LM1",         STATIC LIST OF TOP LEVEL RULES
"RTN","RORUPD",50,0)
 ;   Rule Name)
"RTN","RORUPD",51,0)
 ;
"RTN","RORUPD",52,0)
 ; RORUPD("LM2",         STATIC LIST OF REGISTRIES
"RTN","RORUPD",53,0)
 ;   Registry#)            ^1: 1 - if the current patient can be added
"RTN","RORUPD",54,0)
 ;                             to the registry; 0 - if the patient is
"RTN","RORUPD",55,0)
 ;                             already in the registry or he/she is
"RTN","RORUPD",56,0)
 ;                             an employee and should be skipped.
"RTN","RORUPD",57,0)
 ;                         ^2: 1 if the employees must not be added
"RTN","RORUPD",58,0)
 ;                             to the registry.
"RTN","RORUPD",59,0)
 ;
"RTN","RORUPD",60,0)
 ; RORUPD("MAXPPCNT")    When counters in the ROR PENDING PATIENT
"RTN","RORUPD",61,0)
 ;                       file reach a value stored in this node, the
"RTN","RORUPD",62,0)
 ;                       corresponding patient will be skipped until
"RTN","RORUPD",63,0)
 ;                       someone fixes the error(s) and resets the
"RTN","RORUPD",64,0)
 ;                       counters to 1.
"RTN","RORUPD",65,0)
 ;
"RTN","RORUPD",66,0)
 ; RORUPD("ROOT",File#)  Closed root of the file
"RTN","RORUPD",67,0)
 ;
"RTN","RORUPD",68,0)
 ; RORUPD("SR",          PREPARED SELECTION RULES
"RTN","RORUPD",69,0)
 ;   File#,              This node is defined if the file should be
"RTN","RORUPD",70,0)
 ;                       processed
"RTN","RORUPD",71,0)
 ;
"RTN","RORUPD",72,0)
 ;     "A",              List of rules that should be applied after
"RTN","RORUPD",73,0)
 ;                       processing sub-files and linked files.
"RTN","RORUPD",74,0)
 ;     "B",              List of rules that should be applied before
"RTN","RORUPD",75,0)
 ;                       processing sub-files and linked files.
"RTN","RORUPD",76,0)
 ;       Seq#,             ^1: Selection Rule Name
"RTN","RORUPD",77,0)
 ;                         ^2: Rule# (Selection Rule IEN)
"RTN","RORUPD",78,0)
 ;                         ^3: 1 if registry should be updated if
"RTN","RORUPD",79,0)
 ;                             the expression evaluated as True
"RTN","RORUPD",80,0)
 ;                             (top-level seelction rule)
"RTN","RORUPD",81,0)
 ;         1)            MUMPS expression that implements the rule
"RTN","RORUPD",82,0)
 ;         2,Registry#)  List of IENs of affected registries
"RTN","RORUPD",83,0)
 ;
"RTN","RORUPD",84,0)
 ;     "F",              A list of data elements that should be loaded
"RTN","RORUPD",85,0)
 ;                       before applying selection rules is created
"RTN","RORUPD",86,0)
 ;                       under this node. The elements are grouped by
"RTN","RORUPD",87,0)
 ;                       the APIs used to load the values.
"RTN","RORUPD",88,0)
 ;       API#,           For API #1 (FileMan GETS^DIQ) this node
"RTN","RORUPD",89,0)
 ;                       contains a list of fields separated by ';'.
"RTN","RORUPD",90,0)
 ;         DataCode,     For data elements associated with the API #1
"RTN","RORUPD",91,0)
 ;                       this node stores the field number.
"RTN","RORUPD",92,0)
 ;           "E")        If an external value of the field should be
"RTN","RORUPD",93,0)
 ;                       loaded, a value of the field 4.1 of the
"RTN","RORUPD",94,0)
 ;                       subfile #799.22 is assigned to this node.
"RTN","RORUPD",95,0)
 ;           "I")        If an internal value of the field should be
"RTN","RORUPD",96,0)
 ;                       loaded, a value of the field 4.2 of the
"RTN","RORUPD",97,0)
 ;                       subfile #799.22 is assigned to this node.
"RTN","RORUPD",98,0)
 ;
"RTN","RORUPD",99,0)
 ; RORUPD("SUSPEND")     SUBTASKS SUSPENSION PARAMETERS
"RTN","RORUPD",100,0)
 ;                         ^1: Suspension start time (FileMan)
"RTN","RORUPD",101,0)
 ;                         ^2: Suspension end time (FileMan)
"RTN","RORUPD",102,0)
 ;
"RTN","RORUPD",103,0)
 ;                       For example, to suspend subtasks from
"RTN","RORUPD",104,0)
 ;                       7:00 until 18:00 this node should have
"RTN","RORUPD",105,0)
 ;                       the following value: ".07^.18".
"RTN","RORUPD",106,0)
 ;
"RTN","RORUPD",107,0)
 ; RORUPD("UPD",         CALL-BACK ENTRY POINTS
"RTN","RORUPD",108,0)
 ;   Registry#,1)        Entry point of a MUMPS external function
"RTN","RORUPD",109,0)
 ;                       that assign values of additional fields to
"RTN","RORUPD",110,0)
 ;                       the registry FDA before registry update
"RTN","RORUPD",111,0)
 ;                       (opt'l).
"RTN","RORUPD",112,0)
 ;   Registry#,2)        Entry point of a MUMPS external function
"RTN","RORUPD",113,0)
 ;                       that is called right after registry update
"RTN","RORUPD",114,0)
 ;                       (opt'l).
"RTN","RORUPD",115,0)
 ;
"RTN","RORUPD",116,0)
 ; RORUPDPI ------------ CLOSED ROOT OF THE TEMPORARY STORAGE
"RTN","RORUPD",117,0)
 ;                       (the ^TMP("RORUPD",$J), ^XTMP("RORUPDJ"_$J)
"RTN","RORUPD",118,0)
 ;                       or ^XTMP("RORUPDR"_Registry#) node)
"RTN","RORUPD",119,0)
 ;
"RTN","RORUPD",120,0)
 ; See also a description of ^XTMP("RORUPD"_) in the ^ROR01 routine.
"RTN","RORUPD",121,0)
 ;
"RTN","RORUPD",122,0)
 Q
"RTN","RORUPD",123,0)
 ;
"RTN","RORUPD",124,0)
 ;***** UPDATES THE REGISTRIES
"RTN","RORUPD",125,0)
 ;
"RTN","RORUPD",126,0)
 ; .RGLIST       Reference to a local array containing
"RTN","RORUPD",127,0)
 ;               registry names as subscripts
"RTN","RORUPD",128,0)
 ;
"RTN","RORUPD",129,0)
 ; [.REGLST]     Reference to a local variable where list of actually
"RTN","RORUPD",130,0)
 ;               processed registries is returned to (registries from
"RTN","RORUPD",131,0)
 ;               the source list except inactive and awaiting
"RTN","RORUPD",132,0)
 ;               acknowledgements). It contains registry names as
"RTN","RORUPD",133,0)
 ;               subscripts and registry IENs as values.
"RTN","RORUPD",134,0)
 ;
"RTN","RORUPD",135,0)
 ; [MAXNTSK]     Maximum number of the data processing subtasks.
"RTN","RORUPD",136,0)
 ;               See description of the $$PROCESS^RORUPD05 function
"RTN","RORUPD",137,0)
 ;               for details.
"RTN","RORUPD",138,0)
 ;
"RTN","RORUPD",139,0)
 ; [SUSPEND]     Subtask suspension parameters:
"RTN","RORUPD",140,0)
 ;               See description of the RORUPD("SUSPEND") node
"RTN","RORUPD",141,0)
 ;               for details.
"RTN","RORUPD",142,0)
 ;
"RTN","RORUPD",143,0)
 ; [CLRFLG]      Clear flags to control processing.
"RTN","RORUPD",144,0)
 ; [SETFLG]      Set flags to control processing.
"RTN","RORUPD",145,0)
 ;               See description of the RORUPD("FLAGS") node for
"RTN","RORUPD",146,0)
 ;               the possible values of the parameters.
"RTN","RORUPD",147,0)
 ;
"RTN","RORUPD",148,0)
 ; Return Values:
"RTN","RORUPD",149,0)
 ;       <0  Error code (see MSGLIST^RORERR20)
"RTN","RORUPD",150,0)
 ;        0  Ok
"RTN","RORUPD",151,0)
 ;
"RTN","RORUPD",152,0)
UPDATE(RGLIST,REGLST,MAXNTSK,SUSPEND,CLRFLG,SETFLG) ;
"RTN","RORUPD",153,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD",154,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORUPD",155,0)
 N RORLRC        ; List of Lab result codes to check
"RTN","RORUPD",156,0)
 N RORUPD        ; Update descriptor
"RTN","RORUPD",157,0)
 N RORUPDPI      ; Closed root of the temporary storage
"RTN","RORUPD",158,0)
 N RORVALS       ; Calculated values
"RTN","RORUPD",159,0)
 ;
"RTN","RORUPD",160,0)
 N COUNTERS,RC,REGNAME,REGIEN,TMP
"RTN","RORUPD",161,0)
 D INIT^RORUTL01("RORUPD")  K REGLST
"RTN","RORUPD",162,0)
 D CLEAR^RORERR("UPDATE^RORUPD")
"RTN","RORUPD",163,0)
 ;--- Value of the RORUPDPI variable is modified by the
"RTN","RORUPD",164,0)
 ;    $$PROCESS^RORUPD05 function if the registry update
"RTN","RORUPD",165,0)
 ;--- process runs in the multi-task mode.
"RTN","RORUPD",166,0)
 S RORUPDPI=$NA(^TMP("RORUPD",$J))
"RTN","RORUPD",167,0)
 ;--- Open a new log
"RTN","RORUPD",168,0)
 S TMP=$$SETUP^RORLOG(.RGLIST)
"RTN","RORUPD",169,0)
 S TMP=$$OPEN^RORLOG(.RGLIST,1,"REGISTRY UPDATE STARTED")
"RTN","RORUPD",170,0)
 D
"RTN","RORUPD",171,0)
 . ;--- Create a list of active registries
"RTN","RORUPD",172,0)
 . S RC=$$ARLST^RORUTL02(.RGLIST,.REGLST)  Q:RC<0
"RTN","RORUPD",173,0)
 . I $D(REGLST)<10  D  Q
"RTN","RORUPD",174,0)
 . . S RC=$$ERROR^RORERR(-28,"UPDATE^RORUPD",,,"update")
"RTN","RORUPD",175,0)
 . ;--- Lock parameters of the registries being processed
"RTN","RORUPD",176,0)
 . S RC=$$LOCKREG^RORUTL02(.REGLST,1)  Q:RC<0
"RTN","RORUPD",177,0)
 . I 'RC  D  K REGLST  Q
"RTN","RORUPD",178,0)
 . . S RC=$$ERROR^RORERR(-11,,,,"registries being processed")
"RTN","RORUPD",179,0)
 . ;--- Prepare selection rules
"RTN","RORUPD",180,0)
 . S:$G(SUSPEND) RORUPD("SUSPEND")=SUSPEND
"RTN","RORUPD",181,0)
 . S RC=$$PREPARE^RORUPR(.REGLST)
"RTN","RORUPD",182,0)
 . I RC<0  S RC=$$ERROR^RORERR(-14)  Q
"RTN","RORUPD",183,0)
 . ;--- Clear/Set the flags (override the default value)
"RTN","RORUPD",184,0)
 . S CLRFLG=$$UP^XLFSTR($G(CLRFLG))
"RTN","RORUPD",185,0)
 . S SETFLG=$$UP^XLFSTR($G(SETFLG))
"RTN","RORUPD",186,0)
 . S RORUPD("FLAGS")=$TR($G(RORUPD("FLAGS")),CLRFLG_SETFLG)_SETFLG
"RTN","RORUPD",187,0)
 . ;--- Display the debug information
"RTN","RORUPD",188,0)
 . D:$G(RORPARM("DEBUG"))>1 DEBUG^RORUPDUT
"RTN","RORUPD",189,0)
 . ;--- Look for new patients and update the registries
"RTN","RORUPD",190,0)
 . S RC=$$PROCESS^RORUPD05($G(MAXNTSK))  Q:RC<0
"RTN","RORUPD",191,0)
 . S COUNTERS=RC
"RTN","RORUPD",192,0)
 . ;--- Update registry parameters
"RTN","RORUPD",193,0)
 . S TMP=$$TMSTMP^RORUPD01(.REGLST)
"RTN","RORUPD",194,0)
 . ;--- Update demographic data
"RTN","RORUPD",195,0)
 . D LOG^RORLOG(,"DEMOGRAPHIC UPDATE STARTED")
"RTN","RORUPD",196,0)
 . S RC=$$UPDDEM^RORUPD51(.REGLST)
"RTN","RORUPD",197,0)
 ;
"RTN","RORUPD",198,0)
 ;--- Unlock parameters of processed registries
"RTN","RORUPD",199,0)
 S TMP=$$LOCKREG^RORUTL02(.REGLST,0)
"RTN","RORUPD",200,0)
 ;--- Statistics & Cleanup
"RTN","RORUPD",201,0)
 S TMP="REGISTRY UPDATE "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","RORUPD",202,0)
 D CLOSE^RORLOG(TMP,$G(COUNTERS))
"RTN","RORUPD",203,0)
 D:'$G(RORPARM("DEBUG"))
"RTN","RORUPD",204,0)
 . D INIT^RORUTL01("RORUPD")
"RTN","RORUPD",205,0)
 . ;--- Do not kill the list of processed patients ("U" subnode)
"RTN","RORUPD",206,0)
 . ;    in case of an error or crash during the initial registry
"RTN","RORUPD",207,0)
 . ;--- population (registry setup).
"RTN","RORUPD",208,0)
 . K:'$G(RORPARM("SETUP"))!(RC'<0) @RORUPDPI
"RTN","RORUPD",209,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPD01")
0^21^B66620855
"RTN","RORUPD01",1,0)
RORUPD01 ;HCIOFO/SG - PROCESSING OF THE FILES  ; 8/16/02 8:34am
"RTN","RORUPD01",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORUPD01",3,0)
 ;
"RTN","RORUPD01",4,0)
 ; This routine uses the following IA's:
"RTN","RORUPD01",5,0)
 ;
"RTN","RORUPD01",6,0)
 ; #3301         Access to the field #.6 of the file #2
"RTN","RORUPD01",7,0)
 ; #3646         $$EMPL^DGSEC4
"RTN","RORUPD01",8,0)
 ; #10035        Browse through IENs of the file #2
"RTN","RORUPD01",9,0)
 ;
"RTN","RORUPD01",10,0)
 Q
"RTN","RORUPD01",11,0)
 ;
"RTN","RORUPD01",12,0)
 ;***** CHECKS FOR A STOP REQUESTS (TASKMAN & PROPRIETARY)
"RTN","RORUPD01",13,0)
 ;
"RTN","RORUPD01",14,0)
 ; Return Values:
"RTN","RORUPD01",15,0)
 ;        0  Continue running
"RTN","RORUPD01",16,0)
 ;        1  Stop the subtask
"RTN","RORUPD01",17,0)
 ;
"RTN","RORUPD01",18,0)
CHKSTOP() ;
"RTN","RORUPD01",19,0)
 Q:'$G(RORUPD("JOB")) $$S^%ZTLOAD
"RTN","RORUPD01",20,0)
 L +@RORUPDPI@("T",0):0
"RTN","RORUPD01",21,0)
 I  L -@RORUPDPI@("T",0)  Q 1
"RTN","RORUPD01",22,0)
 Q $$S^%ZTLOAD
"RTN","RORUPD01",23,0)
 ;
"RTN","RORUPD01",24,0)
 ;***** LOAD DATA ELEMENTS
"RTN","RORUPD01",25,0)
 ;
"RTN","RORUPD01",26,0)
 ; IENS          IENS of the current record
"RTN","RORUPD01",27,0)
 ;
"RTN","RORUPD01",28,0)
 ; Return values:
"RTN","RORUPD01",29,0)
 ;       <0  Error code
"RTN","RORUPD01",30,0)
 ;        0  Ok
"RTN","RORUPD01",31,0)
 ;
"RTN","RORUPD01",32,0)
LOAD(IENS) ;
"RTN","RORUPD01",33,0)
 N RC  S RC=0
"RTN","RORUPD01",34,0)
 ;--- API #1
"RTN","RORUPD01",35,0)
 I $D(RORUPD("SR",2,"F",1))  D  Q:RC<0 RC
"RTN","RORUPD01",36,0)
 . S RC=$$LOADFLDS^RORUPDUT(2,IENS)
"RTN","RORUPD01",37,0)
 ;--- API #2
"RTN","RORUPD01",38,0)
 Q 0
"RTN","RORUPD01",39,0)
 ;
"RTN","RORUPD01",40,0)
 ;***** INITIALIZES LOOP CONTROL LISTS
"RTN","RORUPD01",41,0)
 ;
"RTN","RORUPD01",42,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD01",43,0)
 ;
"RTN","RORUPD01",44,0)
 ; Return Values:
"RTN","RORUPD01",45,0)
 ;       <0  Error code
"RTN","RORUPD01",46,0)
 ;        0  Ok
"RTN","RORUPD01",47,0)
 ;
"RTN","RORUPD01",48,0)
 ; The RORUPD("LM",1,Rule Name) list contains names of the top level
"RTN","RORUPD01",49,0)
 ; rules that have not been triggered by now.
"RTN","RORUPD01",50,0)
 ;
"RTN","RORUPD01",51,0)
 ; The RORUPD("LM",2,Registry#) list contains IENs of the registries
"RTN","RORUPD01",52,0)
 ; that do not contain the patient by now.
"RTN","RORUPD01",53,0)
 ;
"RTN","RORUPD01",54,0)
 ; If the patient is an employee and the registry must not include
"RTN","RORUPD01",55,0)
 ; employees (see the EXCLUDE EMPLOYEES field of the ROR REGISTRY
"RTN","RORUPD01",56,0)
 ; PARAMETERS file), the function initializes the corresponding items
"RTN","RORUPD01",57,0)
 ; of control lists as if the patient were already in the registry.
"RTN","RORUPD01",58,0)
 ; Therefore, the patient will not be added to this registry.
"RTN","RORUPD01",59,0)
 ;
"RTN","RORUPD01",60,0)
LOOPINIT(PATIEN) ;
"RTN","RORUPD01",61,0)
 N I,EMPL,REGIEN
"RTN","RORUPD01",62,0)
 K RORUPD("LM",1),RORUPD("LM",2)
"RTN","RORUPD01",63,0)
 S EMPL=$$EMPL^DGSEC4(PATIEN,"P")
"RTN","RORUPD01",64,0)
 M RORUPD("LM",1)=RORUPD("LM1")
"RTN","RORUPD01",65,0)
 S REGIEN=""
"RTN","RORUPD01",66,0)
 F  S REGIEN=$O(RORUPD("LM2",REGIEN))  Q:REGIEN=""  D
"RTN","RORUPD01",67,0)
 . S $P(RORUPD("LM2",REGIEN),U)=0
"RTN","RORUPD01",68,0)
 . ;--- Check if the patient is already in the registry
"RTN","RORUPD01",69,0)
 . Q:$D(^RORDATA(798,"KEY",PATIEN,REGIEN))
"RTN","RORUPD01",70,0)
 . ;--- Check if the patient is an employee and the
"RTN","RORUPD01",71,0)
 . ;--- employees must not be added to the registry
"RTN","RORUPD01",72,0)
 . I EMPL  Q:$P(RORUPD("LM2",REGIEN),U,2)
"RTN","RORUPD01",73,0)
 . ;--- Initialize the items of control lists
"RTN","RORUPD01",74,0)
 . S $P(RORUPD("LM2",REGIEN),U)=1,RORUPD("LM",2,REGIEN)=""
"RTN","RORUPD01",75,0)
 Q 0
"RTN","RORUPD01",76,0)
 ;
"RTN","RORUPD01",77,0)
 ;***** PROCESS EVERY PATIENT IN THE 'PATIENT' FILE
"RTN","RORUPD01",78,0)
 ;
"RTN","RORUPD01",79,0)
 ; BEGIEN        Start IEN in the PATIENT file
"RTN","RORUPD01",80,0)
 ; ENDIEN        End IEN in the PATIENT file
"RTN","RORUPD01",81,0)
 ;
"RTN","RORUPD01",82,0)
 ; Return Values:
"RTN","RORUPD01",83,0)
 ;       <0  Error code
"RTN","RORUPD01",84,0)
 ;      >=0  Statistics
"RTN","RORUPD01",85,0)
 ;             ^1: Total number of processed patients
"RTN","RORUPD01",86,0)
 ;             ^2: Number of patients processed with errors
"RTN","RORUPD01",87,0)
 ;
"RTN","RORUPD01",88,0)
 ; If there is an error in processing of a patient, routine behavior
"RTN","RORUPD01",89,0)
 ; depends on the mode of execution:
"RTN","RORUPD01",90,0)
 ;
"RTN","RORUPD01",91,0)
 ; In the normal mode program logs the errors, adds a record to the
"RTN","RORUPD01",92,0)
 ; ROR PENDING PATIENT file (#798.3), and continues processing of
"RTN","RORUPD01",93,0)
 ; the remaining patients. Next registry update wil start data scan
"RTN","RORUPD01",94,0)
 ; for this patient from the date stored in the file #798.3.
"RTN","RORUPD01",95,0)
 ;
"RTN","RORUPD01",96,0)
 ; In the debug mode 3 program is aborted if there is an error
"RTN","RORUPD01",97,0)
 ; during processing of a patient.
"RTN","RORUPD01",98,0)
 ;
"RTN","RORUPD01",99,0)
PROCESS(BEGIEN,ENDIEN) ;
"RTN","RORUPD01",100,0)
 N CNT,DTNEXT,ECNT,EXIT,PATIEN,RC,TH,TMP
"RTN","RORUPD01",101,0)
 ;--- Loop through the patients
"RTN","RORUPD01",102,0)
 S:$G(ENDIEN)'>0 ENDIEN=0
"RTN","RORUPD01",103,0)
 S PATIEN=$S($G(BEGIEN)>0:$O(^DPT(BEGIEN),-1),1:0)
"RTN","RORUPD01",104,0)
 S (CNT,ECNT,EXIT,RC)=0
"RTN","RORUPD01",105,0)
 F  S PATIEN=$O(^DPT(PATIEN))  Q:PATIEN'>0  D  Q:EXIT!(RC<0)
"RTN","RORUPD01",106,0)
 . I ENDIEN,PATIEN'<ENDIEN  S EXIT=1  Q
"RTN","RORUPD01",107,0)
 . ;--- For a queued task only
"RTN","RORUPD01",108,0)
 . I $D(ZTQUEUED)  S RC=0  D  Q:RC<0
"RTN","RORUPD01",109,0)
 . . ;--- Check if task stop has been requested
"RTN","RORUPD01",110,0)
 . . I $$CHKSTOP()  S RC=$$ERROR^RORERR(-42,"PROCESS^RORUPD01")  Q
"RTN","RORUPD01",111,0)
 . . ;--- Check if the task should be suspended
"RTN","RORUPD01",112,0)
 . . Q:'$G(RORUPD("SUSPEND"))
"RTN","RORUPD01",113,0)
 . . Q:$$NOW^XLFDT<$G(DTNEXT)
"RTN","RORUPD01",114,0)
 . . Q:'$$SUSPEND(.DTNEXT)
"RTN","RORUPD01",115,0)
 . . ;--- Suspend the task during the peak hours
"RTN","RORUPD01",116,0)
 . . F  D  Q:'TH!(RC<0)
"RTN","RORUPD01",117,0)
 . . . S TH=$$FMDIFF^XLFDT(DTNEXT,$$NOW^XLFDT,2)
"RTN","RORUPD01",118,0)
 . . . I TH<60  S TH=0  Q       ; Do not HANG for less than a
"RTN","RORUPD01",119,0)
 . . . H $S(TH>3600:3600,1:TH)  ; minute and more than an hour
"RTN","RORUPD01",120,0)
 . . . ;--- Check if task stop has been requested
"RTN","RORUPD01",121,0)
 . . . S:$$CHKSTOP() RC=$$ERROR^RORERR(-42,"PROCESS^RORUPD01")
"RTN","RORUPD01",122,0)
 . ;--- Update the progress indicator
"RTN","RORUPD01",123,0)
 . S CNT=CNT+1
"RTN","RORUPD01",124,0)
 . I $G(RORPARM("DEBUG"))>1  W:$E($G(IOST),1,2)="C-" *13,CNT
"RTN","RORUPD01",125,0)
 . ;--- Process the patient
"RTN","RORUPD01",126,0)
 . S RC=$$PROCPAT(PATIEN)
"RTN","RORUPD01",127,0)
 . I $G(RORPARM("SETUP"))  D:'(CNT#1000)
"RTN","RORUPD01",128,0)
 . . D LOG^RORLOG(2,"Number of patients processed by now: "_CNT)
"RTN","RORUPD01",129,0)
 . ;--- Process the error (if any)
"RTN","RORUPD01",130,0)
 . I RC<0  D  S:$G(RORPARM("DEBUG"))<3 RC=0
"RTN","RORUPD01",131,0)
 . . I RC=-66  S RC=0  Q        ; Counter in the file #798.3
"RTN","RORUPD01",132,0)
 . . S ECNT=ECNT+1
"RTN","RORUPD01",133,0)
 . . S RC=$$ERROR^RORERR(-15,"PROCESS^RORUPD01",,PATIEN)
"RTN","RORUPD01",134,0)
 . . ;--- Create a record in the file #798.3
"RTN","RORUPD01",135,0)
 . . S TMP=$$ADD^RORUPP01(PATIEN,RORUPD("DSBEG"))
"RTN","RORUPD01",136,0)
 . . S:TMP<0 RC=TMP
"RTN","RORUPD01",137,0)
 Q $S(RC<0:RC,1:CNT_"^"_ECNT)
"RTN","RORUPD01",138,0)
 ;
"RTN","RORUPD01",139,0)
 ;***** PROCESSES PATIENT'S DATA (EXCEPT DEMOGRAPHIC DATA)
"RTN","RORUPD01",140,0)
 ;
"RTN","RORUPD01",141,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD01",142,0)
 ; [NOUPD]       Disable registry update (0 by default)
"RTN","RORUPD01",143,0)
 ;
"RTN","RORUPD01",144,0)
 ; Return Values:
"RTN","RORUPD01",145,0)
 ;       <0  Error code
"RTN","RORUPD01",146,0)
 ;        0  Ok
"RTN","RORUPD01",147,0)
 ;
"RTN","RORUPD01",148,0)
 ; If there is a record for the patient in the ROR PENDING PATIENT
"RTN","RORUPD01",149,0)
 ; file (#798.3) and date in that record is less than a value of the
"RTN","RORUPD01",150,0)
 ; RORUPD("DSBEG") then it is used as a start date of the data scan
"RTN","RORUPD01",151,0)
 ; for the patient. Otherwise, the RORUPD("DSBEG") is used.
"RTN","RORUPD01",152,0)
 ;
"RTN","RORUPD01",153,0)
PROCPAT(PATIEN,NOUPD) ;
"RTN","RORUPD01",154,0)
 ;--- Quit if the patient has already been processed
"RTN","RORUPD01",155,0)
 Q:$D(@RORUPDPI@("U",PATIEN)) 0
"RTN","RORUPD01",156,0)
 ;--- Quit if the patient's record has been merged
"RTN","RORUPD01",157,0)
 Q:$G(^DPT(PATIEN,-9)) 0
"RTN","RORUPD01",158,0)
 ;--- Do not update the registries with a "test patient"
"RTN","RORUPD01",159,0)
 I '$G(NOUPD),$P($G(^DPT(PATIEN,0)),U,21)  D  Q 0
"RTN","RORUPD01",160,0)
 . S @RORUPDPI@("U",PATIEN)=""
"RTN","RORUPD01",161,0)
 ;
"RTN","RORUPD01",162,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD01",163,0)
 ;
"RTN","RORUPD01",164,0)
 N PATIENS,RC,RLST,RORMSG,SDSDT,TMP,UPDREG,UPDSTART
"RTN","RORUPD01",165,0)
 S PATIENS=PATIEN_","
"RTN","RORUPD01",166,0)
 ;--- Initialize the variables
"RTN","RORUPD01",167,0)
 D CLEAR^RORERR("PROCPAT^RORUPD01"),CLREC^RORUPDUT
"RTN","RORUPD01",168,0)
 K RORVALS ; Clear all calculated values
"RTN","RORUPD01",169,0)
 S RC=$$LOOPINIT(PATIEN)  Q:RC<0 RC
"RTN","RORUPD01",170,0)
 ;
"RTN","RORUPD01",171,0)
 ;--- If the loop control list of registries is empty, the patient
"RTN","RORUPD01",172,0)
 ;    is already in all the registries that we are going to process.
"RTN","RORUPD01",173,0)
 S UPDREG=0
"RTN","RORUPD01",174,0)
 I $D(RORUPD("LM",2))>1  S RC=0  D  G:RC<0 PPEX  S UPDREG='$G(NOUPD)
"RTN","RORUPD01",175,0)
 . ;--- Determine start date of the data scan
"RTN","RORUPD01",176,0)
 . S UPDSTART=RORUPD("DSBEG")
"RTN","RORUPD01",177,0)
 . S SDSDT=$$SDSDATE^RORUPP01(PATIEN)
"RTN","RORUPD01",178,0)
 . I SDSDT<0  S RC=SDSDT  Q
"RTN","RORUPD01",179,0)
 . I SDSDT  S:SDSDT<UPDSTART UPDSTART=SDSDT
"RTN","RORUPD01",180,0)
 . S UPDSTART=$$FMADD^XLFDT(UPDSTART\1,-RORUPD("LD",1))
"RTN","RORUPD01",181,0)
 . ;--- Load necessary data elements
"RTN","RORUPD01",182,0)
 . I $D(RORUPD("SR",2,"F"))>1  D  Q:RC<0
"RTN","RORUPD01",183,0)
 . . S RC=$$LOAD(PATIENS)
"RTN","RORUPD01",184,0)
 . D SETVAL^RORUPDUT("ROR DFN",PATIEN)
"RTN","RORUPD01",185,0)
 . ;--- Apply "before" rules
"RTN","RORUPD01",186,0)
 . S RC=$$APLRULES^RORUPDUT(2,PATIENS,"B")  Q:RC
"RTN","RORUPD01",187,0)
 . ;
"RTN","RORUPD01",188,0)
 . ;--- Process patient data from other VistA files
"RTN","RORUPD01",189,0)
 . I $D(RORUPD("SR",9000010))  D  Q:RC
"RTN","RORUPD01",190,0)
 . . S RC=$$VISIT^RORUPD08(UPDSTART,PATIEN)
"RTN","RORUPD01",191,0)
 . I $D(RORUPD("SR",9000011))  D  Q:RC
"RTN","RORUPD01",192,0)
 . . S RC=$$PROBLEM^RORUPD07(UPDSTART,PATIEN)
"RTN","RORUPD01",193,0)
 . I $D(RORUPD("SR",45))  D       Q:RC
"RTN","RORUPD01",194,0)
 . . S RC=$$PTF^RORUPD09(UPDSTART,PATIEN)
"RTN","RORUPD01",195,0)
 . I $D(RORUPD("SR",63))  D       Q:RC
"RTN","RORUPD01",196,0)
 . . S RC=$$LAB^RORUPD04(UPDSTART,PATIEN)
"RTN","RORUPD01",197,0)
 . ; <--- Insert processing of other files here. Do not forget to add
"RTN","RORUPD01",198,0)
 . ;      definitions of these files into the 'ROR METADATA' file.
"RTN","RORUPD01",199,0)
 . ;
"RTN","RORUPD01",200,0)
 . ;--- Apply "after" rules
"RTN","RORUPD01",201,0)
 . S RC=$$APLRULES^RORUPDUT(2,PATIENS,"A")  Q:RC
"RTN","RORUPD01",202,0)
 ;
"RTN","RORUPD01",203,0)
 ;--- Update the registries if necessary
"RTN","RORUPD01",204,0)
 I UPDREG  S RC=$$UPDREG^RORUPD50(PATIEN)  G:RC<0 PPEX
"RTN","RORUPD01",205,0)
 ;--- Error processing
"RTN","RORUPD01",206,0)
 I $$GETEC^RORUPDUT  D  S RC=-15
"RTN","RORUPD01",207,0)
 . S RLST=$NA(@RORUPDPI@("U",PATIEN,2))
"RTN","RORUPD01",208,0)
 E  S RLST="",RC=0
"RTN","RORUPD01",209,0)
 ;--- If there are records in the file #798.3 for the patient,
"RTN","RORUPD01",210,0)
 ;    remove them (log a warning if cannot remove). If the patient
"RTN","RORUPD01",211,0)
 ;    has been processed with errors, remove only records associated
"RTN","RORUPD01",212,0)
 ;--- with the registries that the patient has been added to.
"RTN","RORUPD01",213,0)
 D:$G(SDSDT)
"RTN","RORUPD01",214,0)
 . S TMP=$$REMOVE^RORUPP01(PATIEN,RLST)
"RTN","RORUPD01",215,0)
 . S:TMP<0 TMP=$$ERROR^RORERR(-31,,,PATIEN)
"RTN","RORUPD01",216,0)
 ;--- Mark the patient as processed
"RTN","RORUPD01",217,0)
 S @RORUPDPI@("U",PATIEN)=""
"RTN","RORUPD01",218,0)
PPEX ;--- Cleanup
"RTN","RORUPD01",219,0)
 D CLRDES^RORUPDUT(2)
"RTN","RORUPD01",220,0)
 Q RC
"RTN","RORUPD01",221,0)
 ;
"RTN","RORUPD01",222,0)
 ;***** CHECKS IF THE TASK SHOULD BE SUSPENDED
"RTN","RORUPD01",223,0)
 ;
"RTN","RORUPD01",224,0)
 ; .DTNEXT       Date/Time of the next event (suspend/resume)
"RTN","RORUPD01",225,0)
 ;               is returned via this parameter
"RTN","RORUPD01",226,0)
 ;
"RTN","RORUPD01",227,0)
 ; Return Values:
"RTN","RORUPD01",228,0)
 ;        0  Continue/Resume
"RTN","RORUPD01",229,0)
 ;        1  Suspend
"RTN","RORUPD01",230,0)
 ;
"RTN","RORUPD01",231,0)
SUSPEND(DTNEXT) ;
"RTN","RORUPD01",232,0)
 N DATE,NOW,SUSPEND,TIME,TS,TR
"RTN","RORUPD01",233,0)
 S TS=$P(RORUPD("SUSPEND"),U,1)
"RTN","RORUPD01",234,0)
 S TR=$P(RORUPD("SUSPEND"),U,2)
"RTN","RORUPD01",235,0)
 S NOW=$$NOW^XLFDT,DATE=NOW\1
"RTN","RORUPD01",236,0)
 ;--- A working day
"RTN","RORUPD01",237,0)
 I $$WDCHK^RORUTL01(DATE)  D  Q SUSPEND
"RTN","RORUPD01",238,0)
 . S TIME=NOW-DATE,SUSPEND=0
"RTN","RORUPD01",239,0)
 . I TIME<TS   S DTNEXT=DATE+TS  Q
"RTN","RORUPD01",240,0)
 . I TIME'<TR  S DTNEXT=$$WDNEXT^RORUTL01(DATE)+TS  Q
"RTN","RORUPD01",241,0)
 . S DTNEXT=DATE+TR,SUSPEND=1
"RTN","RORUPD01",242,0)
 ;--- Saturday, Sunday or Holiday
"RTN","RORUPD01",243,0)
 S DTNEXT=$$WDNEXT^RORUTL01(DATE)+TS
"RTN","RORUPD01",244,0)
 Q 0
"RTN","RORUPD01",245,0)
 ;
"RTN","RORUPD01",246,0)
 ;***** UPDATES REGISTRY UPDATE PARAMETERS
"RTN","RORUPD01",247,0)
 ;
"RTN","RORUPD01",248,0)
 ; .REGLST       Reference to a local array containing registry names
"RTN","RORUPD01",249,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUPD01",250,0)
 ;
"RTN","RORUPD01",251,0)
 ; Return values:
"RTN","RORUPD01",252,0)
 ;       <0  Error code
"RTN","RORUPD01",253,0)
 ;        0  Ok
"RTN","RORUPD01",254,0)
 ;
"RTN","RORUPD01",255,0)
TMSTMP(REGLST) ;
"RTN","RORUPD01",256,0)
 N DATE,RC,REGIEN,REGIENS,REGNAME,RORFDA,RORMSG,TMP
"RTN","RORUPD01",257,0)
 S REGNAME="",RC=0
"RTN","RORUPD01",258,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPD01",259,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUPD01",260,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=+REGIEN  Q
"RTN","RORUPD01",261,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUPD01",262,0)
 . S REGIENS=REGIEN_","
"RTN","RORUPD01",263,0)
 . ;--- Check if the new date until that registry is updated is
"RTN","RORUPD01",264,0)
 . ;    greater than that stored in the registry parameters
"RTN","RORUPD01",265,0)
 . S TMP=$$GET1^DIQ(798.1,REGIENS,1,"I",,"RORMSG")
"RTN","RORUPD01",266,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD01",267,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"TMSTMP^RORUPD01",,798.1,REGIENS)
"RTN","RORUPD01",268,0)
 . S DATE=RORUPD("DSEND")\1
"RTN","RORUPD01",269,0)
 . S:DATE>TMP RORFDA(798.1,REGIENS,1)=DATE
"RTN","RORUPD01",270,0)
 . ;--- Update registry parameters (if necessary)
"RTN","RORUPD01",271,0)
 . Q:$D(RORFDA)<10
"RTN","RORUPD01",272,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUPD01",273,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD01",274,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"TMSTMP^RORUPD01",,798.1,REGIENS)
"RTN","RORUPD01",275,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPD05")
0^20^B46987705
"RTN","RORUPD05",1,0)
RORUPD05 ;HCIOFO/SG - REGISTRY UPDATE (MULTITASK) ; 8/16/02 1:55pm
"RTN","RORUPD05",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORUPD05",3,0)
 ;
"RTN","RORUPD05",4,0)
 Q
"RTN","RORUPD05",5,0)
 ;
"RTN","RORUPD05",6,0)
 ;***** MONITORS THE SUBTASKS
"RTN","RORUPD05",7,0)
 ;
"RTN","RORUPD05",8,0)
 ; Return Values:
"RTN","RORUPD05",9,0)
 ;       <0  Error code
"RTN","RORUPD05",10,0)
 ;      >=0  Combined statistics returned by the $$PROCESS^RORUPD01
"RTN","RORUPD05",11,0)
 ;           function of each subtask
"RTN","RORUPD05",12,0)
 ;
"RTN","RORUPD05",13,0)
MONITOR() ;
"RTN","RORUPD05",14,0)
 N CNT,ECNT,EXIT,RC,RORERRDL,TASK,TIMEOUT,TSKCNT
"RTN","RORUPD05",15,0)
 D DFLTLOC^RORERR("MONITOR^RORUPD05")
"RTN","RORUPD05",16,0)
 S (CNT,ECNT,EXIT)=0,TIMEOUT=600 ; 10hrs = 600*60
"RTN","RORUPD05",17,0)
 F  H 60  D  Q:EXIT
"RTN","RORUPD05",18,0)
 . ;--- Exit if all subtasks finished
"RTN","RORUPD05",19,0)
 . I $D(@RORUPDPI@("T"))<10  S EXIT=1  Q
"RTN","RORUPD05",20,0)
 . ;--- Abort if some of the subtasks have not started during
"RTN","RORUPD05",21,0)
 . ;--- the predefined time frame.
"RTN","RORUPD05",22,0)
 . I TIMEOUT'>0  S EXIT=$$ERROR^RORERR(-78)  Q
"RTN","RORUPD05",23,0)
 . ;--- Check for a request to stop
"RTN","RORUPD05",24,0)
 . I $D(ZTQUEUED),$$S^%ZTLOAD  S EXIT=$$ERROR^RORERR(-42)  Q
"RTN","RORUPD05",25,0)
 . ;--- Browse through the list of subtasks
"RTN","RORUPD05",26,0)
 . S (TASK,TSKCNT)=0
"RTN","RORUPD05",27,0)
 . F  S TASK=$O(@RORUPDPI@("T",TASK))  Q:TASK=""  D
"RTN","RORUPD05",28,0)
 . . S RC=@RORUPDPI@("T",TASK),TSKCNT=TSKCNT+1
"RTN","RORUPD05",29,0)
 . . ;--- Skip a subtask that was scheduled but has not started yet
"RTN","RORUPD05",30,0)
 . . I RC="S"  S TSKCNT=TSKCNT-1  Q
"RTN","RORUPD05",31,0)
 . . ;--- Skip a running subtask
"RTN","RORUPD05",32,0)
 . . L +@RORUPDPI@("T",TASK):0  E  Q
"RTN","RORUPD05",33,0)
 . . L -@RORUPDPI@("T",TASK)
"RTN","RORUPD05",34,0)
 . . ;--- The subtask has crashed
"RTN","RORUPD05",35,0)
 . . I RC=-60  S EXIT=$$ERROR^RORERR(-60,,,,TASK)  Q
"RTN","RORUPD05",36,0)
 . . ;--- Fatal error in the subtask
"RTN","RORUPD05",37,0)
 . . I RC<0  S EXIT=+RC  D  Q
"RTN","RORUPD05",38,0)
 . . . S RC=$$ERROR^RORERR(-56,,,,+RC,"subtask #"_TASK)
"RTN","RORUPD05",39,0)
 . . ;--- The subtask is completed (accumulate the statistics)
"RTN","RORUPD05",40,0)
 . . S CNT=CNT+$P(RC,U),ECNT=ECNT+$P(RC,U,2)
"RTN","RORUPD05",41,0)
 . . K @RORUPDPI@("T",TASK)
"RTN","RORUPD05",42,0)
 . ;--- Timeout timer is ticking only if no subtasks are running
"RTN","RORUPD05",43,0)
 . S:TSKCNT'>0 TIMEOUT=TIMEOUT-1
"RTN","RORUPD05",44,0)
 Q $S(EXIT<0:EXIT,1:CNT_U_ECNT)
"RTN","RORUPD05",45,0)
 ;
"RTN","RORUPD05",46,0)
 ;***** PROCESSES THE DATA (SINGLE TASK OR MULTITASK MODE)
"RTN","RORUPD05",47,0)
 ;
"RTN","RORUPD05",48,0)
 ; [MAXNTSK]     Maximum number of data processing subtasks.
"RTN","RORUPD05",49,0)
 ;               If this parameter is less than 2, all patients
"RTN","RORUPD05",50,0)
 ;               will be processed by the single main task.
"RTN","RORUPD05",51,0)
 ;               Otherwise, all patients can be distributed among
"RTN","RORUPD05",52,0)
 ;               several subtasks.
"RTN","RORUPD05",53,0)
 ;
"RTN","RORUPD05",54,0)
 ;               If "N^M^AUTO" is passed as a value of this parameter
"RTN","RORUPD05",55,0)
 ;               and difference between the end and start dates is
"RTN","RORUPD05",56,0)
 ;               more than M days then N subtasks will be created.
"RTN","RORUPD05",57,0)
 ;
"RTN","RORUPD05",58,0)
 ; Return Values:
"RTN","RORUPD05",59,0)
 ;       <0  Error code
"RTN","RORUPD05",60,0)
 ;      >=0  Statistics returned by the $$MONITOR function
"RTN","RORUPD05",61,0)
 ;
"RTN","RORUPD05",62,0)
 ; The main task will wait for completion of the subtasks. If one
"RTN","RORUPD05",63,0)
 ; of them fails, all other (including the main one) will fail too.
"RTN","RORUPD05",64,0)
 ;
"RTN","RORUPD05",65,0)
PROCESS(MAXNTSK) ;
"RTN","RORUPD05",66,0)
 N COUNTERS,NTSK,OLDPI,RC,SUBSCR,TASKTBL,TMP
"RTN","RORUPD05",67,0)
 ;--- Calculate number of tasks and create the task table
"RTN","RORUPD05",68,0)
 D:$G(MAXNTSK)["AUTO"
"RTN","RORUPD05",69,0)
 . S TMP=$$FMDIFF^XLFDT(RORUPD("DSEND"),RORUPD("DSBEG"),1)
"RTN","RORUPD05",70,0)
 . S MAXNTSK=$S(TMP>$P(MAXNTSK,U,2):+MAXNTSK,1:0)
"RTN","RORUPD05",71,0)
 I $G(MAXNTSK)>1  D  Q:NTSK<0 NTSK
"RTN","RORUPD05",72,0)
 . S NTSK=$$TASKTBL(MAXNTSK,.TASKTBL)
"RTN","RORUPD05",73,0)
 ;--- Process all patients by the main task
"RTN","RORUPD05",74,0)
 I $G(NTSK)<2  D  Q $$PROCESS^RORUPD01()
"RTN","RORUPD05",75,0)
 . K RORUPD("SUSPEND")  ; Never suspend the single task
"RTN","RORUPD05",76,0)
 ;
"RTN","RORUPD05",77,0)
 S RORUPD("JOB")=$J,OLDPI=RORUPDPI
"RTN","RORUPD05",78,0)
 ;--- Initialize the node in the ^XTMP global
"RTN","RORUPD05",79,0)
 I $G(RORPARM("SETUP"))  D
"RTN","RORUPD05",80,0)
 . S SUBSCR="RORUPDR"_+$O(RORUPD("LM2",""))
"RTN","RORUPD05",81,0)
 . S RORUPDPI=$NA(^XTMP(SUBSCR)),I=0
"RTN","RORUPD05",82,0)
 . F  S I=$O(@RORUPDPI@(I))  Q:I=""  K:I'="U" @RORUPDPI@(I)
"RTN","RORUPD05",83,0)
 E  D
"RTN","RORUPD05",84,0)
 . S SUBSCR="RORUPDJ"_$J
"RTN","RORUPD05",85,0)
 . S RORUPDPI=$NA(^XTMP(SUBSCR))
"RTN","RORUPD05",86,0)
 . K @RORUPDPI
"RTN","RORUPD05",87,0)
 D XTMPHDR^RORUTL01(SUBSCR,30,"PROCESS-RORUPD05")
"RTN","RORUPD05",88,0)
 M @RORUPDPI=@OLDPI
"RTN","RORUPD05",89,0)
 ;--- Indicate that the main task is running
"RTN","RORUPD05",90,0)
 L +@RORUPDPI@("T",0):5
"RTN","RORUPD05",91,0)
 E  Q $$ERROR^RORERR(-61,"PROCESS^RORUPD05")
"RTN","RORUPD05",92,0)
 ;
"RTN","RORUPD05",93,0)
 ;--- Start the subtasks
"RTN","RORUPD05",94,0)
 S RC=$$START(.TASKTBL)
"RTN","RORUPD05",95,0)
 ;--- Monitor the subtasks
"RTN","RORUPD05",96,0)
 S COUNTERS=$S(RC'<0:$$MONITOR(),1:RC)
"RTN","RORUPD05",97,0)
 ;
"RTN","RORUPD05",98,0)
 ;--- Clear "running" flag of the main task
"RTN","RORUPD05",99,0)
 ;    (request all unfinished subtasks to stop)
"RTN","RORUPD05",100,0)
 L -@RORUPDPI@("T",0)
"RTN","RORUPD05",101,0)
 ;--- Cleanup
"RTN","RORUPD05",102,0)
 I COUNTERS<0  D
"RTN","RORUPD05",103,0)
 . N TASK,ZTSK
"RTN","RORUPD05",104,0)
 . ;--- Dequeue subtasks that have not started yet
"RTN","RORUPD05",105,0)
 . S TASK=0
"RTN","RORUPD05",106,0)
 . F  S TASK=$O(@RORUPDPI@("T",TASK))  Q:TASK=""  D
"RTN","RORUPD05",107,0)
 . . S ZTSK=TASK  D DQ^%ZTLOAD
"RTN","RORUPD05",108,0)
 . ;--- Wait for all unfinished subtasks to stop
"RTN","RORUPD05",109,0)
 . L +@RORUPDPI@("T"):300  L -@RORUPDPI@("T")
"RTN","RORUPD05",110,0)
 K @RORUPDPI@("T")
"RTN","RORUPD05",111,0)
 Q COUNTERS
"RTN","RORUPD05",112,0)
 ;
"RTN","RORUPD05",113,0)
 ;***** STARTS THE SUBTASKS
"RTN","RORUPD05",114,0)
 ;
"RTN","RORUPD05",115,0)
 ; .TASKTBL      Reference to a local variable containing the table
"RTN","RORUPD05",116,0)
 ;               of subtask parameters. See the TASKSPLT and TASKTBL
"RTN","RORUPD05",117,0)
 ;               entry points for details.
"RTN","RORUPD05",118,0)
 ;
"RTN","RORUPD05",119,0)
 ; Return Values:
"RTN","RORUPD05",120,0)
 ;       <0  Error code
"RTN","RORUPD05",121,0)
 ;        0  Ok
"RTN","RORUPD05",122,0)
 ;
"RTN","RORUPD05",123,0)
START(TASKTBL) ;
"RTN","RORUPD05",124,0)
 N CNT,I,TYPE,ZTDESC,ZTDTH,ZTIO,ZTPRI,ZTRTN,ZTSAVE,ZTSK
"RTN","RORUPD05",125,0)
 K @RORUPDPI@("T")
"RTN","RORUPD05",126,0)
 ;--- Do not allow subtasks to proceed before everything is ready
"RTN","RORUPD05",127,0)
 L +@RORUPDPI@("T"):5
"RTN","RORUPD05",128,0)
 E  Q $$ERROR^RORERR(-61,"START^RORUPD05")
"RTN","RORUPD05",129,0)
 ;--- Start the subtasks
"RTN","RORUPD05",130,0)
 S I=""
"RTN","RORUPD05",131,0)
 F CNT=1:1  S I=$O(TASKTBL(I))  Q:I=""  D
"RTN","RORUPD05",132,0)
 . S ZTRTN="SUBTASK^RORUPD05",ZTIO=""
"RTN","RORUPD05",133,0)
 . S ZTDTH=$$FMADD^XLFDT($$NOW^XLFDT,,,,CNT*30)
"RTN","RORUPD05",134,0)
 . S ZTDESC="Registry Update Subtask ("_$TR(TASKTBL(I),U,"-")_")"
"RTN","RORUPD05",135,0)
 . S ZTSAVE("RORIENS")=TASKTBL(I)
"RTN","RORUPD05",136,0)
 . S ZTSAVE("RORLRC(")=""
"RTN","RORUPD05",137,0)
 . S ZTSAVE("RORPARM(")=""
"RTN","RORUPD05",138,0)
 . S ZTSAVE("RORUPD(")=""
"RTN","RORUPD05",139,0)
 . S ZTSAVE("RORUPDPI")=""
"RTN","RORUPD05",140,0)
 . D ^%ZTLOAD
"RTN","RORUPD05",141,0)
 . ;--- Indicate that the subtask has been scheduled
"RTN","RORUPD05",142,0)
 . S @RORUPDPI@("T",ZTSK)="S"
"RTN","RORUPD05",143,0)
 . S TMP=$$MSG^RORERR20(-62,.TYPE,,ZTSK)
"RTN","RORUPD05",144,0)
 . D LOG^RORLOG(TYPE,TMP)
"RTN","RORUPD05",145,0)
 ;--- The subtasks may proceed now
"RTN","RORUPD05",146,0)
 L -@RORUPDPI@("T")
"RTN","RORUPD05",147,0)
 Q 0
"RTN","RORUPD05",148,0)
 ;
"RTN","RORUPD05",149,0)
 ;***** DATA PROCESSING SUBTASK
"RTN","RORUPD05",150,0)
 ;
"RTN","RORUPD05",151,0)
 ; RORIENS       Diapason of IENs in the 'PATIENT' file
"RTN","RORUPD05",152,0)
 ;                 ^1: Start IEN
"RTN","RORUPD05",153,0)
 ;                 ^2: End IEN
"RTN","RORUPD05",154,0)
 ; RORLRC        List of Lab result codes to check
"RTN","RORUPD05",155,0)
 ; RORPARM       Application parameters
"RTN","RORUPD05",156,0)
 ; RORUPD        Registry update descriptor
"RTN","RORUPD05",157,0)
 ; RORUPDPI      Closed root of the temporary storage
"RTN","RORUPD05",158,0)
 ;
"RTN","RORUPD05",159,0)
SUBTASK ;
"RTN","RORUPD05",160,0)
 N RORERROR      ; Error processing data
"RTN","RORUPD05",161,0)
 N RORLOG        ; Log subsystem constants & variables
"RTN","RORUPD05",162,0)
 ;
"RTN","RORUPD05",163,0)
 N RC,TASK,TMP,TYPE
"RTN","RORUPD05",164,0)
 S TASK=ZTSK
"RTN","RORUPD05",165,0)
 ;--- We are not in the KIDS environment anymore
"RTN","RORUPD05",166,0)
 K RORPARM("KIDS")
"RTN","RORUPD05",167,0)
 ;--- Disable debug output (subtask has no device)
"RTN","RORUPD05",168,0)
 S:$G(RORPARM("DEBUG"))>1 RORPARM("DEBUG")=1
"RTN","RORUPD05",169,0)
 ;--- Indicate that the subtask is running
"RTN","RORUPD05",170,0)
 L +@RORUPDPI@("T",TASK):180
"RTN","RORUPD05",171,0)
 E  S RC=$$ERROR^RORERR(-61,"SUBTASK^RORUPD05")  Q
"RTN","RORUPD05",172,0)
 ;--- Check if the main task is running
"RTN","RORUPD05",173,0)
 L +@RORUPDPI@("T",0):0
"RTN","RORUPD05",174,0)
 I  D
"RTN","RORUPD05",175,0)
 . ;--- Cleanup if the main task is not running
"RTN","RORUPD05",176,0)
 . L -@RORUPDPI@("T",0)
"RTN","RORUPD05",177,0)
 . K @RORUPDPI@("T",TASK)
"RTN","RORUPD05",178,0)
 E  D
"RTN","RORUPD05",179,0)
 . N REGIEN,REGLST
"RTN","RORUPD05",180,0)
 . ;--- Error code that will be in effect if the subtask crashes
"RTN","RORUPD05",181,0)
 . S @RORUPDPI@("T",TASK)=-60
"RTN","RORUPD05",182,0)
 . ;--- Initialize the variables
"RTN","RORUPD05",183,0)
 . D INIT^RORUTL01(),CLEAR^RORERR("SUBTASK^RORUPD05")
"RTN","RORUPD05",184,0)
 . S REGIEN=""
"RTN","RORUPD05",185,0)
 . F  S REGIEN=$O(@RORUPDPI@(2,REGIEN))  Q:REGIEN=""  D
"RTN","RORUPD05",186,0)
 . . S TMP=$P(@RORUPDPI@(2,REGIEN),U)  S:TMP'="" REGLST(TMP)=REGIEN
"RTN","RORUPD05",187,0)
 . S TMP="REGISTRY UPDATE SUBTASK #"_TASK_" STARTED"
"RTN","RORUPD05",188,0)
 . S TMP=$$OPEN^RORLOG(.REGLST,1,TMP)
"RTN","RORUPD05",189,0)
 . ;--- Process the patients from 'Start IEN' to 'End IEN'
"RTN","RORUPD05",190,0)
 . S RC=$$PROCESS^RORUPD01($P(RORIENS,U),$P(RORIENS,U,2))
"RTN","RORUPD05",191,0)
 . ;--- Set the error code returned by the registry update process
"RTN","RORUPD05",192,0)
 . S @RORUPDPI@("T",TASK)=RC
"RTN","RORUPD05",193,0)
 . ;--- Cleanup and error processing
"RTN","RORUPD05",194,0)
 . S:RC=-42 ZTSTOP=1
"RTN","RORUPD05",195,0)
 . S TMP="REGISTRY UPDATE SUBTASK "_$S(RC<0:"ABORTED",1:"COMPLETED")
"RTN","RORUPD05",196,0)
 . D CLOSE^RORLOG(TMP,$S(RC'<0:RC,1:""))
"RTN","RORUPD05",197,0)
 ;--- Clear "running" flag of the subtask
"RTN","RORUPD05",198,0)
 L -@RORUPDPI@("T",TASK)
"RTN","RORUPD05",199,0)
 S ZTREQ="@"
"RTN","RORUPD05",200,0)
 Q
"RTN","RORUPD05",201,0)
 ;
"RTN","RORUPD05",202,0)
 ;***** CALCULATES TABLE OF SUBTASKS
"RTN","RORUPD05",203,0)
 ;
"RTN","RORUPD05",204,0)
 ; MAXNTSK       Maximum number of data processing subtasks
"RTN","RORUPD05",205,0)
 ;
"RTN","RORUPD05",206,0)
 ; .TASKTBL      Reference to a local variable where table of
"RTN","RORUPD05",207,0)
 ;               subtask parameters is returned:
"RTN","RORUPD05",208,0)
 ;
"RTN","RORUPD05",209,0)
 ;               TASKTBL       Number of subtasks
"RTN","RORUPD05",210,0)
 ;               TASKTBL(I)    Subtask parameters
"RTN","RORUPD05",211,0)
 ;                               ^1: Start IEN
"RTN","RORUPD05",212,0)
 ;                               ^2: End IEN
"RTN","RORUPD05",213,0)
 ;
"RTN","RORUPD05",214,0)
 ; Return Values:
"RTN","RORUPD05",215,0)
 ;       <0  Error code
"RTN","RORUPD05",216,0)
 ;        0  Process all data by the main task
"RTN","RORUPD05",217,0)
 ;       >1  Number of subtasks
"RTN","RORUPD05",218,0)
 ;
"RTN","RORUPD05",219,0)
 ; If the PATIENT file contains more than 100,000 records, up to
"RTN","RORUPD05",220,0)
 ; MAXNTSK data processing subtasks may be defined. Otherwise, the
"RTN","RORUPD05",221,0)
 ; data should be processed by the main task.
"RTN","RORUPD05",222,0)
 ;
"RTN","RORUPD05",223,0)
 ; The function uses the ^TMP("RORTMP",$J) global node.
"RTN","RORUPD05",224,0)
 ;
"RTN","RORUPD05",225,0)
TASKTBL(MAXNTSK,RORTBL) ;
"RTN","RORUPD05",226,0)
 N I,IEN,INC,LST,NR
"RTN","RORUPD05",227,0)
 K RORTBL,^TMP("RORTMP",$J)
"RTN","RORUPD05",228,0)
 ;--- Get number of records in the PATIENT file
"RTN","RORUPD05",229,0)
 S NR=$$GET1^DID(2,,,"ENTRIES",,"RORMSG")
"RTN","RORUPD05",230,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"TASKTBL^RORUPD05")
"RTN","RORUPD05",231,0)
 Q:NR'>100000 0
"RTN","RORUPD05",232,0)
 ;--- Generate IEN intervals (no more than 300)
"RTN","RORUPD05",233,0)
 S INC=NR\300,NR=0  S:INC<1 INC=1
"RTN","RORUPD05",234,0)
 F IEN=0:INC  S IEN=$O(^DPT(IEN))  Q:IEN'>0  D
"RTN","RORUPD05",235,0)
 . S NR=NR+1,^TMP("RORTMP",$J,NR)=IEN
"RTN","RORUPD05",236,0)
 ;--- Generate the task table
"RTN","RORUPD05",237,0)
 S IEN=1,INC=NR/MAXNTSK
"RTN","RORUPD05",238,0)
 F RORTBL=1:1  D  Q:(RORTBL'<MAXNTSK)!(IEN'>0)
"RTN","RORUPD05",239,0)
 . S RORTBL(RORTBL)=IEN
"RTN","RORUPD05",240,0)
 . S I=$J(RORTBL*INC,0,0),IEN=$G(^TMP("RORTMP",$J,I))
"RTN","RORUPD05",241,0)
 . S $P(RORTBL(RORTBL),U,2)=IEN
"RTN","RORUPD05",242,0)
 K ^TMP("RORTMP",$J)
"RTN","RORUPD05",243,0)
 ;--- Analize the result
"RTN","RORUPD05",244,0)
 I $G(RORTBL)<2  K RORTBL
"RTN","RORUPD05",245,0)
 E  S $P(RORTBL(RORTBL),U,2)=$O(^DPT(" "),-1)
"RTN","RORUPD05",246,0)
 Q +$G(RORTBL)
"RTN","RORUPD50")
0^29^B13411223
"RTN","RORUPD50",1,0)
RORUPD50 ;HCIOFO/SG - UPDATE THE PATIENT IN THE REGISTRIES  ; 8/1/02 3:24pm
"RTN","RORUPD50",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORUPD50",3,0)
 ;
"RTN","RORUPD50",4,0)
 ; This routine uses the following IAs:
"RTN","RORUPD50",5,0)
 ;
"RTN","RORUPD50",6,0)
 ; #3301         Access to the field #.6 of the file #2
"RTN","RORUPD50",7,0)
 ;
"RTN","RORUPD50",8,0)
 Q
"RTN","RORUPD50",9,0)
 ;
"RTN","RORUPD50",10,0)
 ;***** ADDS THE PATIENT TO THE REGISTRY
"RTN","RORUPD50",11,0)
 ;
"RTN","RORUPD50",12,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD50",13,0)
 ; REGIEN        Registry IEN
"RTN","RORUPD50",14,0)
 ;
"RTN","RORUPD50",15,0)
 ; [ROR8RULS]    Closed root of a local array containing list of
"RTN","RORUPD50",16,0)
 ;               triggered selection rules:
"RTN","RORUPD50",17,0)
 ;                 @ROR8RULS@(RuleIEN)=Date
"RTN","RORUPD50",18,0)
 ;               If this parameter is not defined or equals to
"RTN","RORUPD50",19,0)
 ;               an empty string, selection rules are loaded from
"RTN","RORUPD50",20,0)
 ;               corresponding sub-node of the ^TMP("RORUPD",$J,"U").
"RTN","RORUPD50",21,0)
 ;
"RTN","RORUPD50",22,0)
 ; [[.]DOD]      Date of death. If this parameter is undefined,
"RTN","RORUPD50",23,0)
 ;               its value will be taken from the ROR PATIENT file.
"RTN","RORUPD50",24,0)
 ;               If you are going to call this function several times
"RTN","RORUPD50",25,0)
 ;               for the same patient (for different registries),
"RTN","RORUPD50",26,0)
 ;               pass a reference to undefined local variable (the
"RTN","RORUPD50",27,0)
 ;               DOD will be read from the file only once).
"RTN","RORUPD50",28,0)
 ;
"RTN","RORUPD50",29,0)
 ; Return values:
"RTN","RORUPD50",30,0)
 ;       <0  Error code
"RTN","RORUPD50",31,0)
 ;        0  Ok
"RTN","RORUPD50",32,0)
 ;        1  Patient has already existed in the registry
"RTN","RORUPD50",33,0)
 ;
"RTN","RORUPD50",34,0)
ADD(PATIEN,REGIEN,ROR8RULS,DOD) ;
"RTN","RORUPD50",35,0)
 N FINDVAL,I,IENS,IENS01,RC,RORFDA,RORIEN,RORMSG,RULEIEN,TMP
"RTN","RORUPD50",36,0)
 ;--- Try to find the patient in the registry
"RTN","RORUPD50",37,0)
 S FINDVAL(1)=PATIEN,FINDVAL(2)=REGIEN
"RTN","RORUPD50",38,0)
 D FIND^DIC(798,,"@","QUX",.FINDVAL,1,"KEY",,,"RORFDA","RORMSG")
"RTN","RORUPD50",39,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ADD^RORUPD50",,798)
"RTN","RORUPD50",40,0)
 ;--- Patient already in the registry
"RTN","RORUPD50",41,0)
 Q:$G(RORFDA("DILIST",0)) 1
"RTN","RORUPD50",42,0)
 ;--- Prepare registry data
"RTN","RORUPD50",43,0)
 K RORFDA  S IENS="+1,"
"RTN","RORUPD50",44,0)
 S RORFDA(798,IENS,.01)=PATIEN           ; Patient Name
"RTN","RORUPD50",45,0)
 S RORFDA(798,IENS,.02)=REGIEN           ; Registry
"RTN","RORUPD50",46,0)
 S RORFDA(798,IENS,1)=$$NOW^XLFDT        ; Date/time entered
"RTN","RORUPD50",47,0)
 S RORFDA(798,IENS,3)=1                  ; Status (AUTO)
"RTN","RORUPD50",48,0)
 S RORFDA(798,IENS,4)=1                  ; Update Demographics
"RTN","RORUPD50",49,0)
 S RORFDA(798,IENS,5)=1                  ; Update local data
"RTN","RORUPD50",50,0)
 ;--- Populate the inactivation date field if necessary
"RTN","RORUPD50",51,0)
 S:'($D(DOD)#10) DOD=$$GET1^DIQ(798.4,PATIEN_",",.351,"I",,"RORMSG")
"RTN","RORUPD50",52,0)
 S RORFDA(798,IENS,2)=$$INACTDOD^RORUPDUT(DOD)
"RTN","RORUPD50",53,0)
 ;--- Set the DON'T SEND flag for a "test patient"
"RTN","RORUPD50",54,0)
 S TMP=$$GET1^DIQ(2,PATIEN_",",.6,"I",,"RORMSG")
"RTN","RORUPD50",55,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ADD^RORUPD50",PATIEN,2)
"RTN","RORUPD50",56,0)
 S:TMP RORFDA(798,IENS,11)=1
"RTN","RORUPD50",57,0)
 ;--- Load list of triggered rules
"RTN","RORUPD50",58,0)
 S:$G(ROR8RULS)="" ROR8RULS=$NA(@RORUPDPI@("U",PATIEN,2,REGIEN))
"RTN","RORUPD50",59,0)
 S RULEIEN=""
"RTN","RORUPD50",60,0)
 F I=1:1  S RULEIEN=$O(@ROR8RULS@(RULEIEN))  Q:RULEIEN=""  D
"RTN","RORUPD50",61,0)
 . S IENS01="+"_(1000+I)_","_IENS
"RTN","RORUPD50",62,0)
 . S RORFDA(798.01,IENS01,.01)=RULEIEN
"RTN","RORUPD50",63,0)
 . S RORFDA(798.01,IENS01,1)=$P(@ROR8RULS@(RULEIEN),U)\1
"RTN","RORUPD50",64,0)
 ;--- Call "before update" entry point
"RTN","RORUPD50",65,0)
 S ENTRY=$G(RORUPD("UPD",REGIEN,1))
"RTN","RORUPD50",66,0)
 I ENTRY'=""  X "S RC="_ENTRY_"(.RORFDA,PATIEN,REGIEN)"  Q:RC<0 RC
"RTN","RORUPD50",67,0)
 ;--- Update the registry
"RTN","RORUPD50",68,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORUPD50",69,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ADD^RORUPD50")
"RTN","RORUPD50",70,0)
 ;--- Call "after update" entry point
"RTN","RORUPD50",71,0)
 S ENTRY=$G(RORUPD("UPD",REGIEN,2))
"RTN","RORUPD50",72,0)
 I ENTRY'=""  X "S RC="_ENTRY_"(RORIEN(1),PATIEN,REGIEN)"  Q:RC<0 RC
"RTN","RORUPD50",73,0)
 Q 0
"RTN","RORUPD50",74,0)
 ;
"RTN","RORUPD50",75,0)
 ;***** ADDS PATIENT DATA TO THE 'ROR PATIENT' FILE
"RTN","RORUPD50",76,0)
 ;
"RTN","RORUPD50",77,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD50",78,0)
 ;
"RTN","RORUPD50",79,0)
 ; Return values:
"RTN","RORUPD50",80,0)
 ;       <0  Error code
"RTN","RORUPD50",81,0)
 ;        0  Ok
"RTN","RORUPD50",82,0)
 ;        1  Patient data have already existed
"RTN","RORUPD50",83,0)
 ;
"RTN","RORUPD50",84,0)
ADDPDATA(PATIEN) ;
"RTN","RORUPD50",85,0)
 N IENS,RC,RORBUF,RORPAT,RORIEN,RORMSG
"RTN","RORUPD50",86,0)
 ;--- Try to find patient data
"RTN","RORUPD50",87,0)
 D FIND^DIC(798.4,,"@","QUX",PATIEN,1,"B",,,"RORBUF","RORMSG")
"RTN","RORUPD50",88,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ADDPDATA^RORUPD50",,798.4)
"RTN","RORUPD50",89,0)
 ;--- Patient data already exist in the file
"RTN","RORUPD50",90,0)
 Q:$G(RORBUF("DILIST",0)) 1
"RTN","RORUPD50",91,0)
 ;--- Prepare patient data
"RTN","RORUPD50",92,0)
 S IENS="+1,"
"RTN","RORUPD50",93,0)
 S RC=$$PATDATA^RORUPD52(PATIEN_",",.RORPAT,IENS)  Q:RC<0 RC
"RTN","RORUPD50",94,0)
 S RORIEN(1)=PATIEN                      ; IEN of the new record
"RTN","RORUPD50",95,0)
 S RORPAT(798.4,IENS,.01)=PATIEN         ; Patient Name
"RTN","RORUPD50",96,0)
 ;--- Add the patient record to the file
"RTN","RORUPD50",97,0)
 D UPDATE^DIE(,"RORPAT","RORIEN","RORMSG")
"RTN","RORUPD50",98,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"ADDPDATA^RORUPD50",,798.4)
"RTN","RORUPD50",99,0)
 Q 0
"RTN","RORUPD50",100,0)
 ;
"RTN","RORUPD50",101,0)
 ;***** ADDS THE PATIENT TO MARKED REGISTRIES
"RTN","RORUPD50",102,0)
 ;
"RTN","RORUPD50",103,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD50",104,0)
 ;
"RTN","RORUPD50",105,0)
 ; Return values:
"RTN","RORUPD50",106,0)
 ;       <0  Error code
"RTN","RORUPD50",107,0)
 ;        0  Patient should not be added to the registry
"RTN","RORUPD50",108,0)
 ;       >0  Patient has been added to the registry
"RTN","RORUPD50",109,0)
 ;
"RTN","RORUPD50",110,0)
UPDREG(PATIEN) ;
"RTN","RORUPD50",111,0)
 N DOD,ENTRY,INCTVDT,RC,REGIEN
"RTN","RORUPD50",112,0)
 ;--- Check if patient should be added to any registry
"RTN","RORUPD50",113,0)
 Q:$D(@RORUPDPI@("U",PATIEN,2))<10 0
"RTN","RORUPD50",114,0)
 ;--- Add patient data
"RTN","RORUPD50",115,0)
 S RC=$$ADDPDATA(PATIEN)  Q:RC<0 RC
"RTN","RORUPD50",116,0)
 ;--- Update all marked registries
"RTN","RORUPD50",117,0)
 S REGIEN="",RC=0
"RTN","RORUPD50",118,0)
 F  D  Q:REGIEN=""  S RC=$$ADD(PATIEN,REGIEN,,.DOD)  Q:RC<0
"RTN","RORUPD50",119,0)
 . S REGIEN=$O(@RORUPDPI@("U",PATIEN,2,REGIEN))
"RTN","RORUPD50",120,0)
 Q $S(RC<0:RC,1:1)
"RTN","RORUPD51")
0^30^B53672528
"RTN","RORUPD51",1,0)
RORUPD51 ;HCIOFO/SG - UPDATE PATIENT'S DEMOGRAPHIC DATA (1) ; 8/1/02 3:25pm
"RTN","RORUPD51",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORUPD51",3,0)
 ;
"RTN","RORUPD51",4,0)
 ; This routine uses the following IAs:
"RTN","RORUPD51",5,0)
 ;
"RTN","RORUPD51",6,0)
 ; #174          Access to the multiple #.3721 of the file #2
"RTN","RORUPD51",7,0)
 ;
"RTN","RORUPD51",8,0)
 Q
"RTN","RORUPD51",9,0)
 ;
"RTN","RORUPD51",10,0)
 ;***** MARKS REGISTRIES (UPDATE DEMOGRAPHICS AND INACTIVE DATE)
"RTN","RORUPD51",11,0)
 ;
"RTN","RORUPD51",12,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD51",13,0)
 ; [DOD]         Date of death
"RTN","RORUPD51",14,0)
 ;
"RTN","RORUPD51",15,0)
 ; Return Values:
"RTN","RORUPD51",16,0)
 ;       <0  Error code
"RTN","RORUPD51",17,0)
 ;        0  Ok
"RTN","RORUPD51",18,0)
 ;
"RTN","RORUPD51",19,0)
MARKREGS(PATIEN,DOD) ;
"RTN","RORUPD51",20,0)
 N ACTIVE,ECNT,I,IENS,INACTDT,RC,REACTDT,RI
"RTN","RORUPD51",21,0)
 N RORBUF,RORFDA,RORMSG,RORSRC
"RTN","RORUPD51",22,0)
 ;--- Compile a list of associated registries
"RTN","RORUPD51",23,0)
 D FIND^DIC(798,,"@","QUX",PATIEN,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPD51",24,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"MARKREGS^RORUPD51",,798)
"RTN","RORUPD51",25,0)
 ;--- Mark patient records of the registries
"RTN","RORUPD51",26,0)
 S RI="",ECNT=0
"RTN","RORUPD51",27,0)
 F  S RI=$O(RORBUF("DILIST",2,RI))  Q:RI=""  D  L -^RORDATA(798,+IENS)
"RTN","RORUPD51",28,0)
 . S IENS=RORBUF("DILIST",2,RI)_","
"RTN","RORUPD51",29,0)
 . K RORFDA,RORSRC
"RTN","RORUPD51",30,0)
 . ;--- Try to lock the record; if this fails, continue anyway
"RTN","RORUPD51",31,0)
 . L +^RORDATA(798,+IENS):1
"RTN","RORUPD51",32,0)
 . ;--- Load the field values
"RTN","RORUPD51",33,0)
 . D GETS^DIQ(798,IENS,"2;2.2;4;7;8","EI","RORSRC","RORMSG")
"RTN","RORUPD51",34,0)
 . I $G(DIERR)  D  S ECNT=ECNT+1  Q
"RTN","RORUPD51",35,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"MARKREGS^RORUPD51",,798,IENS)
"RTN","RORUPD51",36,0)
 . S ACTIVE=+$G(RORSRC(798,IENS,8,"E"))
"RTN","RORUPD51",37,0)
 . S INACTDT=$G(RORSRC(798,IENS,2,"I"))
"RTN","RORUPD51",38,0)
 . S REACTDT=$G(RORSRC(798,IENS,7,"I"))
"RTN","RORUPD51",39,0)
 . ;--- Update inactivation date only if the DOD parameter
"RTN","RORUPD51",40,0)
 . ;    is defined and the patient has not been inactivated
"RTN","RORUPD51",41,0)
 . ;    by a reason other than death
"RTN","RORUPD51",42,0)
 . I $D(DOD),'$G(RORSRC(798,IENS,2.2,"I"))  D
"RTN","RORUPD51",43,0)
 . . ;--- Do nothing if the patient is alive and there is no
"RTN","RORUPD51",44,0)
 . . ;    inactivation date in his record
"RTN","RORUPD51",45,0)
 . . I 'DOD  Q:'INACTDT
"RTN","RORUPD51",46,0)
 . . S (RORFDA(798,IENS,2),INACTDT)=$$INACTDOD^RORUPDUT(DOD)
"RTN","RORUPD51",47,0)
 . . S RORFDA(798,IENS,2.1)="@"
"RTN","RORUPD51",48,0)
 . ;--- Do not mark again if already marked
"RTN","RORUPD51",49,0)
 . I '$G(RORSRC(798,IENS,4,"I"))  S RC=0  D  Q:RC<0
"RTN","RORUPD51",50,0)
 . . ;--- Check the new status of the record if it was
"RTN","RORUPD51",51,0)
 . . ;    not active before
"RTN","RORUPD51",52,0)
 . . S:'ACTIVE ACTIVE=$$ACTIVE^RORDD(INACTDT,REACTDT)
"RTN","RORUPD51",53,0)
 . . ;--- Mark only active (now or before) records
"RTN","RORUPD51",54,0)
 . . S:ACTIVE RORFDA(798,IENS,4)=1
"RTN","RORUPD51",55,0)
 . ;--- Update registry data record
"RTN","RORUPD51",56,0)
 . I $D(RORFDA)>1  S RC=0  D  Q:RC<0
"RTN","RORUPD51",57,0)
 . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUPD51",58,0)
 . . I $G(DIERR)  D  S ECNT=ECNT+1
"RTN","RORUPD51",59,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,"MARKREGS^RORUPD51",,798,IENS)
"RTN","RORUPD51",60,0)
 Q $S(ECNT>0:-9,1:0)
"RTN","RORUPD51",61,0)
 ;
"RTN","RORUPD51",62,0)
 ;***** COMPARES/UPDATES CONTENT OF A MULTIPLE FIELD
"RTN","RORUPD51",63,0)
 ;
"RTN","RORUPD51",64,0)
 ; SFN2          Sub-file number in the PATIENT file
"RTN","RORUPD51",65,0)
 ; IENS2         IENS of the main record
"RTN","RORUPD51",66,0)
 ; SFN798        Sub-file number in the ROR PATIENT file
"RTN","RORUPD51",67,0)
 ; IENS798       IENS of the main record
"RTN","RORUPD51",68,0)
 ; FLDLST        List of fields separated by semicolon
"RTN","RORUPD51",69,0)
 ;
"RTN","RORUPD51",70,0)
 ; Return Values:
"RTN","RORUPD51",71,0)
 ;       <0  Error code
"RTN","RORUPD51",72,0)
 ;        0  Data in the multiple have not been changed
"RTN","RORUPD51",73,0)
 ;       >0  Data have been changed
"RTN","RORUPD51",74,0)
 ;
"RTN","RORUPD51",75,0)
PATMULT(SFN2,IENS2,SFN798,IENS798,FLDLST) ;
"RTN","RORUPD51",76,0)
 N RORERRDL      ; Default error location
"RTN","RORUPD51",77,0)
 ;
"RTN","RORUPD51",78,0)
 N COUNT,FLD,I,IEN,IENS,IENSD,IR,RC,ROOT2,ROOT798
"RTN","RORUPD51",79,0)
 N RORB2,RORB798,RORFDA,RORIEN,RORMSG,VAL,TMP
"RTN","RORUPD51",80,0)
 D DFLTLOC^RORERR("PATMULT^RORUPD51")
"RTN","RORUPD51",81,0)
 S ROOT2=$$ROOT^DILFD(SFN2,","_IENS2,1),COUNT=0
"RTN","RORUPD51",82,0)
 ;--- Delete unnecesary sub-file records from the destination file
"RTN","RORUPD51",83,0)
 I IENS798?1.N.1","  S RC=0  D  Q:RC<0 RC
"RTN","RORUPD51",84,0)
 . S ROOT798=$$ROOT^DILFD(SFN798,","_IENS798,1)
"RTN","RORUPD51",85,0)
 . S IEN=0
"RTN","RORUPD51",86,0)
 . F  S IEN=$O(@ROOT798@(IEN))  Q:'IEN  D:'$D(@ROOT2@(IEN))  Q:RC<0
"RTN","RORUPD51",87,0)
 . . S IENS=IEN_","_IENS798
"RTN","RORUPD51",88,0)
 . . S RORFDA(SFN798,IENS,.01)="@",COUNT=COUNT+1
"RTN","RORUPD51",89,0)
 . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUPD51",90,0)
 . . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,,,SFN798,IENS)
"RTN","RORUPD51",91,0)
 E  S ROOT798=""
"RTN","RORUPD51",92,0)
 ;--- Add/Update records of the sub-file in the destination file
"RTN","RORUPD51",93,0)
 S (IEN,IR,RC)=0
"RTN","RORUPD51",94,0)
 F  S IEN=$O(@ROOT2@(IEN))  Q:'IEN  D  Q:RC<0
"RTN","RORUPD51",95,0)
 . K RORB2,RORB798
"RTN","RORUPD51",96,0)
 . S IENS=IEN_","_IENS2
"RTN","RORUPD51",97,0)
 . D GETS^DIQ(SFN2,IENS,FLDLST,"I","RORB2","RORMSG")
"RTN","RORUPD51",98,0)
 . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,SFN2,IENS)  Q
"RTN","RORUPD51",99,0)
 . ;--- Update the existing record
"RTN","RORUPD51",100,0)
 . I ROOT798'="",$D(@ROOT798@(IEN))  D  Q
"RTN","RORUPD51",101,0)
 . . S IENSD=IEN_","_IENS798
"RTN","RORUPD51",102,0)
 . . D GETS^DIQ(SFN798,IENSD,FLDLST,"I","RORB798","RORMSG")
"RTN","RORUPD51",103,0)
 . . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,SFN798,IENSD)  Q
"RTN","RORUPD51",104,0)
 . . F I=1:1  S FLD=$P(FLDLST,";",I)  Q:FLD=""  D
"RTN","RORUPD51",105,0)
 . . . S VAL=$G(RORB2(SFN2,IENS,FLD,"I"))
"RTN","RORUPD51",106,0)
 . . . S TMP=$G(RORB798(SFN798,IENSD,FLD,"I"))
"RTN","RORUPD51",107,0)
 . . . S:TMP'=VAL RORFDA(SFN798,IENSD,FLD)=VAL
"RTN","RORUPD51",108,0)
 . . Q:$D(RORFDA)<10
"RTN","RORUPD51",109,0)
 . . ;--- Update the record
"RTN","RORUPD51",110,0)
 . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUPD51",111,0)
 . . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,SFN798,IENS798)  Q
"RTN","RORUPD51",112,0)
 . . S COUNT=COUNT+1
"RTN","RORUPD51",113,0)
 . ;--- Add a new record
"RTN","RORUPD51",114,0)
 . S IR=IR+1,IENSD="+"_(IR+100)_","_IENS798
"RTN","RORUPD51",115,0)
 . F I=1:1  S FLD=$P(FLDLST,";",I)  Q:FLD=""  D
"RTN","RORUPD51",116,0)
 . . S RORFDA(SFN798,IENSD,FLD)=$G(RORB2(SFN2,IENS,FLD,"I"))
"RTN","RORUPD51",117,0)
 . S RORIEN(IR+100)=IEN
"RTN","RORUPD51",118,0)
 . Q:$D(RORFDA)<10
"RTN","RORUPD51",119,0)
 . ;--- Add the record
"RTN","RORUPD51",120,0)
 . D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORUPD51",121,0)
 . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,SFN798,IENS798)  Q
"RTN","RORUPD51",122,0)
 . S COUNT=COUNT+1
"RTN","RORUPD51",123,0)
 Q $S(RC<0:RC,1:COUNT)
"RTN","RORUPD51",124,0)
 ;
"RTN","RORUPD51",125,0)
 ;***** SCANS PATIENTS AND UPDATES DEMOGRAPHIC DATA (IF NECESSARY)
"RTN","RORUPD51",126,0)
 ;
"RTN","RORUPD51",127,0)
 ; .REGLST       Reference to a local array containing
"RTN","RORUPD51",128,0)
 ;               registry names as subscripts
"RTN","RORUPD51",129,0)
 ;
"RTN","RORUPD51",130,0)
 ; Return Values:
"RTN","RORUPD51",131,0)
 ;       <0  Error code
"RTN","RORUPD51",132,0)
 ;        0  Ok
"RTN","RORUPD51",133,0)
 ;
"RTN","RORUPD51",134,0)
UPDDEM(REGLST) ;
"RTN","RORUPD51",135,0)
 N CNT,IR,PATIEN,RC,REGIEN,REGNAME,ROOT,SCR,UPD,UPDCNT
"RTN","RORUPD51",136,0)
 N RORLOR,RORLST,RORMSG
"RTN","RORUPD51",137,0)
 S ROOT=$$ROOT^DILFD(798,,1)
"RTN","RORUPD51",138,0)
 ;--- Compile a list of registry internal entry numbers
"RTN","RORUPD51",139,0)
 S REGNAME="",RC=0
"RTN","RORUPD51",140,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPD51",141,0)
 . S RC=+$G(REGLST(REGNAME))
"RTN","RORUPD51",142,0)
 . S:RC'>0 RC=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUPD51",143,0)
 . S:RC>0 RORLOR(+RC)=""
"RTN","RORUPD51",144,0)
 Q:RC<0 RC
"RTN","RORUPD51",145,0)
 ;--- Loop through the patients of the registries
"RTN","RORUPD51",146,0)
 S PATIEN="",(CNT,RC)=0
"RTN","RORUPD51",147,0)
 F  S PATIEN=$O(@ROOT@("B",PATIEN))  Q:PATIEN=""  D  Q:RC<0
"RTN","RORUPD51",148,0)
 . ;--- Check if task stop has been requested
"RTN","RORUPD51",149,0)
 . I $D(ZTQUEUED),$$S^%ZTLOAD  D  Q
"RTN","RORUPD51",150,0)
 . . S RC=$$ERROR^RORERR(-42,"UPDDEM^RORUPD51")
"RTN","RORUPD51",151,0)
 . S CNT=CNT+1
"RTN","RORUPD51",152,0)
 . I $G(RORPARM("DEBUG"))>1  W:$E($G(IOST),1,2)="C-" *13,CNT
"RTN","RORUPD51",153,0)
 . ;--- Load a list of patient's registry records
"RTN","RORUPD51",154,0)
 . S SCR="S Y=+$P($G(^(0)),U,2) I Y,$D(RORLOR(Y))"
"RTN","RORUPD51",155,0)
 . D FIND^DIC(798,,"@;.02I;2.2I;8E","QUX",PATIEN,,"B",SCR,,"RORLST","RORMSG")
"RTN","RORUPD51",156,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD51",157,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"UPDDEM^RORUPD51")
"RTN","RORUPD51",158,0)
 . ;--- Demographic data should be checked only if at least one of
"RTN","RORUPD51",159,0)
 . ;    the registry records of the patient is either active or the
"RTN","RORUPD51",160,0)
 . ;    REASON FOR INACTIVATION field (798,2.2) has no value (this
"RTN","RORUPD51",161,0)
 . ;    means that the patient has been inactivated because of death).
"RTN","RORUPD51",162,0)
 . S IR="",UPDCNT=0
"RTN","RORUPD51",163,0)
 . F  S IR=$O(RORLST("DILIST","ID",IR))  Q:IR=""  D
"RTN","RORUPD51",164,0)
 . . S UPD=+$G(RORLST("DILIST","ID",IR,8))
"RTN","RORUPD51",165,0)
 . . S REGIEN=+$G(RORLST("DILIST","ID",IR,.02))
"RTN","RORUPD51",166,0)
 . . S CNT(REGIEN,UPD)=$G(CNT(REGIEN,UPD))+1
"RTN","RORUPD51",167,0)
 . . ;---
"RTN","RORUPD51",168,0)
 . . S:'UPD UPD='$G(RORLST("DILIST","ID",IR,2.2))
"RTN","RORUPD51",169,0)
 . . S:UPD UPDCNT=UPDCNT+1
"RTN","RORUPD51",170,0)
 . S:UPDCNT RC=$$UPDPTDEM(PATIEN)
"RTN","RORUPD51",171,0)
 D:RC'<0 UPDRCNT(.CNT)
"RTN","RORUPD51",172,0)
 Q RC
"RTN","RORUPD51",173,0)
 ;
"RTN","RORUPD51",174,0)
 ;***** UPDATES DEMOGRAPHIC DATA OF THE PATIENT (IF NECESSARY)
"RTN","RORUPD51",175,0)
 ;
"RTN","RORUPD51",176,0)
 ; PATIEN        Patient IEN
"RTN","RORUPD51",177,0)
 ;
"RTN","RORUPD51",178,0)
 ; Return Values:
"RTN","RORUPD51",179,0)
 ;       <0  Error code
"RTN","RORUPD51",180,0)
 ;        0  Ok
"RTN","RORUPD51",181,0)
 ;
"RTN","RORUPD51",182,0)
UPDPTDEM(PATIEN) ;
"RTN","RORUPD51",183,0)
 N CF,DOD,IENS,RC,RORMSG,RORPAT
"RTN","RORUPD51",184,0)
 S IENS=PATIEN_",",CF=0
"RTN","RORUPD51",185,0)
 ;--- Try to lock the record of the ROR PATIENT file
"RTN","RORUPD51",186,0)
 L +^RORDATA(798.4,PATIEN):1
"RTN","RORUPD51",187,0)
 E  Q $$ERROR^RORERR(-11,"UPDPTDEM^RORUPD51",,PATIEN,"file #798.4")
"RTN","RORUPD51",188,0)
 D
"RTN","RORUPD51",189,0)
 . ;--- Compare demographic data
"RTN","RORUPD51",190,0)
 . S RC=$$PATDATA^RORUPD52(IENS,.RORPAT,IENS,.DOD)  Q:RC<0
"RTN","RORUPD51",191,0)
 . S:RC CF=1
"RTN","RORUPD51",192,0)
 . ;--- Compare/update list of disabilities
"RTN","RORUPD51",193,0)
 . S RC=$$PATMULT(2.04,IENS,798.41,IENS,".01;2;3")  Q:RC<0
"RTN","RORUPD51",194,0)
 . S:RC CF=1
"RTN","RORUPD51",195,0)
 . ;--- Mark registry records of the patient
"RTN","RORUPD51",196,0)
 . I CF  S RC=$$MARKREGS(PATIEN,$G(DOD))  Q:RC<0
"RTN","RORUPD51",197,0)
 . ;--- Update demographic data
"RTN","RORUPD51",198,0)
 . I CF,$D(RORPAT)  S RC=0  D  Q:RC<0
"RTN","RORUPD51",199,0)
 . . D FILE^DIE(,"RORPAT","RORMSG")
"RTN","RORUPD51",200,0)
 . . S:$G(DIERR) RC=$$DBS^RORERR("RORMSG",-9,"UPDPTDEM^RORUPD51")
"RTN","RORUPD51",201,0)
 ;
"RTN","RORUPD51",202,0)
 L -^RORDATA(798.4,PATIEN)
"RTN","RORUPD51",203,0)
 Q 0
"RTN","RORUPD51",204,0)
 ;
"RTN","RORUPD51",205,0)
 ;***** UPDATES RECORD COUNTERS IN THE 'ROR REGISTRY PARAMETERS' FILE
"RTN","RORUPD51",206,0)
 ;
"RTN","RORUPD51",207,0)
 ; .CNT(         Reference to a local array containg registry
"RTN","RORUPD51",208,0)
 ;               record counters
"RTN","RORUPD51",209,0)
 ;   Registry#,
"RTN","RORUPD51",210,0)
 ;     0)        Number of inactive records
"RTN","RORUPD51",211,0)
 ;     1)        Number of active records
"RTN","RORUPD51",212,0)
 ;
"RTN","RORUPD51",213,0)
UPDRCNT(CNT) ;
"RTN","RORUPD51",214,0)
 N IENS,RC,REGIEN,RORFDA,RORMSG
"RTN","RORUPD51",215,0)
 S REGIEN=0
"RTN","RORUPD51",216,0)
 F  S REGIEN=$O(CNT(REGIEN))  Q:REGIEN=""  D
"RTN","RORUPD51",217,0)
 . S IENS=REGIEN_","
"RTN","RORUPD51",218,0)
 . S RORFDA(798.1,IENS,19.1)=$G(CNT(REGIEN,0))+$G(CNT(REGIEN,1))
"RTN","RORUPD51",219,0)
 . S RORFDA(798.1,IENS,19.2)=$G(CNT(REGIEN,1))
"RTN","RORUPD51",220,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUPD51",221,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPD51",222,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"UPDRCNT^RORUPD51",798.1,IENS)
"RTN","RORUPD51",223,0)
 Q
"RTN","RORUPP02")
0^36^B10225211
"RTN","RORUPP02",1,0)
RORUPP02 ;HCIOFO/SG - PENDING PATIENTS (EVENTS)  ; 7/19/02 10:58am
"RTN","RORUPP02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORUPP02",3,0)
 ;
"RTN","RORUPP02",4,0)
 Q
"RTN","RORUPP02",5,0)
 ;
"RTN","RORUPP02",6,0)
 ;***** ADDS THE EVENT REFERENCE
"RTN","RORUPP02",7,0)
 ;
"RTN","RORUPP02",8,0)
 ; PATIEN        Patient IEN
"RTN","RORUPP02",9,0)
 ;
"RTN","RORUPP02",10,0)
 ; AREA          Data area of the event (see the DATA AREA field
"RTN","RORUPP02",11,0)
 ;               of the file #798.3 for details)
"RTN","RORUPP02",12,0)
 ;
"RTN","RORUPP02",13,0)
 ; [DATE]        Date/Time associated with the event (the current
"RTN","RORUPP02",14,0)
 ;               date/time is used by default).
"RTN","RORUPP02",15,0)
 ;
"RTN","RORUPP02",16,0)
 ; Return Values:
"RTN","RORUPP02",17,0)
 ;       <0  Error code
"RTN","RORUPP02",18,0)
 ;        0  Ok
"RTN","RORUPP02",19,0)
 ;
"RTN","RORUPP02",20,0)
ADD(PATIEN,AREA,DATE) ;
"RTN","RORUPP02",21,0)
 N IEN,IENS,RORFDA,RORIEN,RORMSG
"RTN","RORUPP02",22,0)
 S:$G(DATE)'>0 DATE=$$NOW^XLFDT
"RTN","RORUPP02",23,0)
 ;--- Do not record more than one reference per associated date.
"RTN","RORUPP02",24,0)
 ;    Maybe in the future all references will be recorded but we
"RTN","RORUPP02",25,0)
 ;    need only daily precision at the moment. If the reference
"RTN","RORUPP02",26,0)
 ;    exists already, update it with the earlier associated date
"RTN","RORUPP02",27,0)
 ;--- and the latter timestamp if necessary.
"RTN","RORUPP02",28,0)
 S IEN=$O(^RORDATA(798.3,+PATIEN,2,"AD",AREA,DATE\1,""))
"RTN","RORUPP02",29,0)
 I IEN  K DIERR  D  Q $S('$G(DIERR):0,1:-9)
"RTN","RORUPP02",30,0)
 . N BUF,NOW
"RTN","RORUPP02",31,0)
 . S IENS=IEN_","_(+PATIEN)_",",NOW=$$NOW^XLFDT
"RTN","RORUPP02",32,0)
 . S BUF=$G(^RORDATA(798.3,+PATIEN,2,IEN,0))
"RTN","RORUPP02",33,0)
 . S:NOW>$P(BUF,"^") RORFDA(798.32,IENS,.01)=NOW
"RTN","RORUPP02",34,0)
 . S:DATE<$P(BUF,"^",3) RORFDA(798.32,IENS,2)=DATE
"RTN","RORUPP02",35,0)
 . D:$D(RORFDA)>1 FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUPP02",36,0)
 ;--- Create the new event reference
"RTN","RORUPP02",37,0)
 S (RORFDA(798.3,"?+1,",.01),RORIEN(1))=+PATIEN
"RTN","RORUPP02",38,0)
 S IENS="+2,?+1,"
"RTN","RORUPP02",39,0)
 S RORFDA(798.32,IENS,.01)=$$NOW^XLFDT
"RTN","RORUPP02",40,0)
 S RORFDA(798.32,IENS,1)=AREA
"RTN","RORUPP02",41,0)
 S RORFDA(798.32,IENS,2)=DATE
"RTN","RORUPP02",42,0)
 D UPDATE^DIE(,"RORFDA","RORIEN","RORMSG")
"RTN","RORUPP02",43,0)
 Q $S('$G(DIERR):0,1:-9)
"RTN","RORUPP02",44,0)
 ;
"RTN","RORUPP02",45,0)
 ;***** CHECKS THE EVENTS
"RTN","RORUPP02",46,0)
 ;
"RTN","RORUPP02",47,0)
 ; PATIEN        Patient IEN
"RTN","RORUPP02",48,0)
 ;
"RTN","RORUPP02",49,0)
 ; AREA          Data area of the event (see the DATA AREA field
"RTN","RORUPP02",50,0)
 ;               of the file #798.3 for details)
"RTN","RORUPP02",51,0)
 ;
"RTN","RORUPP02",52,0)
 ; .SDT          Reference to a local variable containing the start
"RTN","RORUPP02",53,0)
 ;               date. The date can be modified by the function and
"RTN","RORUPP02",54,0)
 ;               returned via this parameter.
"RTN","RORUPP02",55,0)
 ;
"RTN","RORUPP02",56,0)
 ; .EDT          Reference to a local variable containing the end
"RTN","RORUPP02",57,0)
 ;               date. The date can be modified by the function and
"RTN","RORUPP02",58,0)
 ;               returned via this parameter.
"RTN","RORUPP02",59,0)
 ;
"RTN","RORUPP02",60,0)
 ; Return Values:
"RTN","RORUPP02",61,0)
 ;       <0  Error code
"RTN","RORUPP02",62,0)
 ;        0  No events (skip)
"RTN","RORUPP02",63,0)
 ;        1  Events have been found (proceed)
"RTN","RORUPP02",64,0)
 ;        2  The same as 1 + dates (SDT & EDT) have been modified
"RTN","RORUPP02",65,0)
 ;
"RTN","RORUPP02",66,0)
GET(PATIEN,AREA,SDT,EDT) ;
"RTN","RORUPP02",67,0)
 N ED,FDTC,FEVT,IEN,NEWEDT,NEWSDT,ROOT,TMP
"RTN","RORUPP02",68,0)
 S ROOT=$NA(^RORDATA(798.3,+PATIEN,2))
"RTN","RORUPP02",69,0)
 S NEWSDT=999999999,NEWEDT=0,(FDTC,FEVT)=0
"RTN","RORUPP02",70,0)
 ;--- If the data search time frame is too wide and some of the
"RTN","RORUPP02",71,0)
 ;    event references have been purged already then the time
"RTN","RORUPP02",72,0)
 ;    frame cannot be shrinked according to the references and the
"RTN","RORUPP02",73,0)
 ;--- patient cannot be skipped if there are no references at all.
"RTN","RORUPP02",74,0)
 S:SDT<$G(RORUPD("EETS")) NEWSDT=SDT,NEWEDT=EDT,FEVT=1
"RTN","RORUPP02",75,0)
 ;--- Browse through the event references
"RTN","RORUPP02",76,0)
 S ED=$O(@ROOT@("AT",AREA,SDT),-1)
"RTN","RORUPP02",77,0)
 F  S ED=$O(@ROOT@("AT",AREA,ED))  Q:(ED="")!(ED'<EDT)  D
"RTN","RORUPP02",78,0)
 . S IEN=""
"RTN","RORUPP02",79,0)
 . F  S IEN=$O(@ROOT@("AT",AREA,ED,IEN))  Q:IEN=""  D
"RTN","RORUPP02",80,0)
 . . S TMP=$P($G(@ROOT@(IEN,0)),"^",3),FEVT=1
"RTN","RORUPP02",81,0)
 . . Q:TMP'>0
"RTN","RORUPP02",82,0)
 . . S:TMP<NEWSDT NEWSDT=TMP,FDTC=1
"RTN","RORUPP02",83,0)
 . . S:TMP>NEWEDT NEWEDT=TMP,FDTC=1
"RTN","RORUPP02",84,0)
 Q:'FEVT 0
"RTN","RORUPP02",85,0)
 I FDTC  S SDT=NEWSDT,EDT=NEWEDT  Q 2
"RTN","RORUPP02",86,0)
 Q 1
"RTN","RORUPP02",87,0)
 ;
"RTN","RORUPP02",88,0)
 ;***** PURGES THE OLD EVENT REFERENCES
"RTN","RORUPP02",89,0)
 ;
"RTN","RORUPP02",90,0)
 ; DATE          Keep the references starting from this date
"RTN","RORUPP02",91,0)
 ;
"RTN","RORUPP02",92,0)
 ; Return Values:
"RTN","RORUPP02",93,0)
 ;       <0  Error code
"RTN","RORUPP02",94,0)
 ;        0  Ok
"RTN","RORUPP02",95,0)
 ;
"RTN","RORUPP02",96,0)
PURGE(DATE) ;
"RTN","RORUPP02",97,0)
 N CNT,IEN,IEN1,IENS,RC,ROOT,RORFDA,RORMSG
"RTN","RORUPP02",98,0)
 S ROOT=$$ROOT^DILFD(798.3,,1)
"RTN","RORUPP02",99,0)
 S DATE=DATE\1,(CNT,RC)=0
"RTN","RORUPP02",100,0)
 F  S DATE=$O(@ROOT@("AT",DATE),-1)  Q:DATE=""  D  Q:RC<0
"RTN","RORUPP02",101,0)
 . S IEN=""
"RTN","RORUPP02",102,0)
 . F  S IEN=$O(@ROOT@("AT",DATE,IEN))  Q:IEN=""  D  Q:RC<0
"RTN","RORUPP02",103,0)
 . . S IEN1=""
"RTN","RORUPP02",104,0)
 . . F  S IEN1=$O(@ROOT@("AT",DATE,IEN,IEN1))  Q:IEN1=""  D  Q:RC<0
"RTN","RORUPP02",105,0)
 . . . S IENS=IEN1_","_IEN_","
"RTN","RORUPP02",106,0)
 . . . S RORFDA(798.32,IENS,.01)="@"
"RTN","RORUPP02",107,0)
 . . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUPP02",108,0)
 . . . I $G(DIERR)  D  Q
"RTN","RORUPP02",109,0)
 . . . . S RC=$$DBS^RORERR("RORMSG",-9,"PURGE^RORUPP02",,798.32,IENS)
"RTN","RORUPP02",110,0)
 . . . S CNT=CNT+1
"RTN","RORUPP02",111,0)
 D:CNT>0 LOG^RORLOG(2,CNT_" events were purged from the file #798.3")
"RTN","RORUPP02",112,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR")
0^31^B29694244
"RTN","RORUPR",1,0)
RORUPR ;HCIOFO/SG - SELECTION RULES PREPARATION  ; 8/5/02 9:25am
"RTN","RORUPR",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORUPR",3,0)
 ;
"RTN","RORUPR",4,0)
 Q
"RTN","RORUPR",5,0)
 ;
"RTN","RORUPR",6,0)
 ;***** PREPARES SELECTION RULES AND OTHER DATA
"RTN","RORUPR",7,0)
 ;
"RTN","RORUPR",8,0)
 ; .REGLST       Reference to a local array containing registry names
"RTN","RORUPR",9,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUPR",10,0)
 ; [LMODE]       When stop looping through records of the patient:
"RTN","RORUPR",11,0)
 ;                 0  always loop through all records
"RTN","RORUPR",12,0)
 ;                 1  all top level rules have been triggered (deflt)
"RTN","RORUPR",13,0)
 ;                 2  patient has been marked for addition to all
"RTN","RORUPR",14,0)
 ;                    registries being processed
"RTN","RORUPR",15,0)
 ; [DSBEG]       Start date/time of the data scan (the earliest
"RTN","RORUPR",16,0)
 ;               registry update date by default)
"RTN","RORUPR",17,0)
 ; [DSEND]       End date/time of the data scan (NOW by default)
"RTN","RORUPR",18,0)
 ;
"RTN","RORUPR",19,0)
 ; Return Values:
"RTN","RORUPR",20,0)
 ;        0  Ok
"RTN","RORUPR",21,0)
 ;       <0  Error code
"RTN","RORUPR",22,0)
 ;
"RTN","RORUPR",23,0)
PREPARE(REGLST,LMODE,DSBEG,DSEND) ;
"RTN","RORUPR",24,0)
 N RORERRDL      ; Default error location
"RTN","RORUPR",25,0)
 ;
"RTN","RORUPR",26,0)
 N FILE,I,RC
"RTN","RORUPR",27,0)
 D DFLTLOC^RORERR("PREPARE^RORUPR")
"RTN","RORUPR",28,0)
 ;--- Clear loop control lists
"RTN","RORUPR",29,0)
 K RORUPD("LM")  S RORUPD("LM")=+$G(LMODE,1)
"RTN","RORUPR",30,0)
 ;--- Load registry parameters
"RTN","RORUPR",31,0)
 S RC=$$PREPARE1(.REGLST,$G(DSBEG),$G(DSEND))  Q:RC<0 RC
"RTN","RORUPR",32,0)
 ;--- Load selection rules
"RTN","RORUPR",33,0)
 S RC=$$LOAD^RORUPR1(.REGLST)        Q:RC<0 $$ERROR^RORERR(-19)
"RTN","RORUPR",34,0)
 ;--- Load and prepare Lab search data
"RTN","RORUPR",35,0)
 S RC=$$LABSRCH^RORUPR1()            Q:RC<0 $$ERROR^RORERR(-12)
"RTN","RORUPR",36,0)
 ;--- Sort loaded rules
"RTN","RORUPR",37,0)
 S RC=$$SORT()                       Q:RC<0 $$ERROR^RORERR(-20)
"RTN","RORUPR",38,0)
 ;--- Load and prepare metadata
"RTN","RORUPR",39,0)
 S RC=$$METADATA^RORUPR1()           Q:RC<0 RC
"RTN","RORUPR",40,0)
 Q 0
"RTN","RORUPR",41,0)
 ;
"RTN","RORUPR",42,0)
 ;***** LOADS REGISTRY PARAMETERS
"RTN","RORUPR",43,0)
 ;
"RTN","RORUPR",44,0)
 ; .REGLST       Reference to a local array containing
"RTN","RORUPR",45,0)
 ;               registry names as subscripts
"RTN","RORUPR",46,0)
 ;
"RTN","RORUPR",47,0)
 ; [DSBEG]       Start date of the data scan (the earliest registry
"RTN","RORUPR",48,0)
 ;               update date by default). Time part of the parameter
"RTN","RORUPR",49,0)
 ;               value is ignored.
"RTN","RORUPR",50,0)
 ;
"RTN","RORUPR",51,0)
 ; [DSEND]       End date/time of the data scan (NOW by default).
"RTN","RORUPR",52,0)
 ;
"RTN","RORUPR",53,0)
 ; Return Values:
"RTN","RORUPR",54,0)
 ;        0  Ok
"RTN","RORUPR",55,0)
 ;       <0  Error code
"RTN","RORUPR",56,0)
 ;
"RTN","RORUPR",57,0)
PREPARE1(REGLST,DSBEG,DSEND) ;
"RTN","RORUPR",58,0)
 N DATE,EVTPROT,I,RC,REGIEN,REGNAME,RORBUF,TMP,UPDSTART
"RTN","RORUPR",59,0)
 K RORUPD("LD"),RORUPD("LM2"),RORUPD("UPD")
"RTN","RORUPR",60,0)
 S DSBEG=$G(DSBEG)\1,DSEND=+$G(DSEND)
"RTN","RORUPR",61,0)
 S UPDSTART=$$DT^XLFDT,EVTPROT=0
"RTN","RORUPR",62,0)
 ;---
"RTN","RORUPR",63,0)
 S REGNAME="",RC=0
"RTN","RORUPR",64,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPR",65,0)
 . S TMP="1I;6.1;6.2;15.1;25I;26I"
"RTN","RORUPR",66,0)
 . S REGIEN=$$REGIEN^RORUTL02(REGNAME,TMP,.RORBUF)
"RTN","RORUPR",67,0)
 . I REGIEN'>0  S RC=$$ERROR^RORERR(-46,"PREPARE1^RORUPR",REGNAME)  Q
"RTN","RORUPR",68,0)
 . ;--- Add an item to the static list of registries
"RTN","RORUPR",69,0)
 . S RORUPD("LM2",REGIEN)=U_$G(RORBUF("DILIST","ID",1,26))
"RTN","RORUPR",70,0)
 . ;--- Load and verify update entry points
"RTN","RORUPR",71,0)
 . S RC=0
"RTN","RORUPR",72,0)
 . F I=1,2  D  Q:RC<0
"RTN","RORUPR",73,0)
 . . S TMP=$G(RORBUF("DILIST","ID",1,+("6."_I)))
"RTN","RORUPR",74,0)
 . . S TMP=$$TRIM^XLFSTR(TMP)  Q:TMP=""
"RTN","RORUPR",75,0)
 . . S RC=$$VERIFYEP^RORUTL01(TMP)
"RTN","RORUPR",76,0)
 . . S:RC'<0 RORUPD("UPD",REGIEN,I)=TMP
"RTN","RORUPR",77,0)
 . I RC<0  S RC=$$ERROR^RORERR(-6,"PREPARE1^RORUPR",REGNAME,,TMP)  Q
"RTN","RORUPR",78,0)
 . ;--- Calculate the earliest update date for the registries
"RTN","RORUPR",79,0)
 . ;    being processed
"RTN","RORUPR",80,0)
 . S DATE=$G(RORBUF("DILIST","ID",1,1))\1
"RTN","RORUPR",81,0)
 . I DATE  S:DATE<UPDSTART UPDSTART=DATE
"RTN","RORUPR",82,0)
 . ;--- Calculate the longest lag interval
"RTN","RORUPR",83,0)
 . S TMP=$G(RORBUF("DILIST","ID",1,15.1))
"RTN","RORUPR",84,0)
 . S:TMP>$G(RORUPD("LD",1)) RORUPD("LD",1)=TMP
"RTN","RORUPR",85,0)
 . ;--- Check if event references should be used
"RTN","RORUPR",86,0)
 . S:$G(RORBUF("DILIST","ID",1,25)) EVTPROT=1
"RTN","RORUPR",87,0)
 Q:RC<0 RC
"RTN","RORUPR",88,0)
 ;--- Check the lag interval
"RTN","RORUPR",89,0)
 S:$G(RORUPD("LD",1))'>0 RORUPD("LD",1)=1
"RTN","RORUPR",90,0)
 ;--- Define data scan period
"RTN","RORUPR",91,0)
 S RORUPD("DT")=$$NOW^XLFDT
"RTN","RORUPR",92,0)
 S RORUPD("DSBEG")=$S(DSBEG:DSBEG,1:UPDSTART)
"RTN","RORUPR",93,0)
 S RORUPD("DSEND")=$S(DSEND:DSEND,1:RORUPD("DT"))
"RTN","RORUPR",94,0)
 ;--- Check if we have event references in the file #798.3
"RTN","RORUPR",95,0)
 S RORUPD("EETS")=$O(^RORDATA(798.3,"AT",""))
"RTN","RORUPR",96,0)
 S:'RORUPD("EETS") EVTPROT=0
"RTN","RORUPR",97,0)
 ;--- Add all necessary flags
"RTN","RORUPR",98,0)
 S RORUPD("FLAGS")=$TR($G(RORUPD("FLAGS")),"E")
"RTN","RORUPR",99,0)
 S:EVTPROT RORUPD("FLAGS")=RORUPD("FLAGS")_"E"
"RTN","RORUPR",100,0)
 Q 0
"RTN","RORUPR",101,0)
 ;
"RTN","RORUPR",102,0)
 ;***** PUTS THE RULE INTO THE LIST
"RTN","RORUPR",103,0)
 ;
"RTN","RORUPR",104,0)
 ; RULENAME      Name of the rule
"RTN","RORUPR",105,0)
 ; MODE          "A" (process after subfiles) or
"RTN","RORUPR",106,0)
 ;               "B" (process before subfiles)
"RTN","RORUPR",107,0)
 ; PARENT        Name of the parent rule
"RTN","RORUPR",108,0)
 ; 
"RTN","RORUPR",109,0)
 ; Return Values:
"RTN","RORUPR",110,0)
 ;        0  Ok
"RTN","RORUPR",111,0)
 ;       <0  Error code
"RTN","RORUPR",112,0)
 ;
"RTN","RORUPR",113,0)
PUTRULE(RULENAME,MODE,PARENT) ;
"RTN","RORUPR",114,0)
 N CODE,DSTNODE,DEPNAME,HDR,FILE,IR,IC
"RTN","RORUPR",115,0)
 S HDR=$G(@RORUPDPI@(3,RULENAME)),FILE=+$P(HDR,U,2)
"RTN","RORUPR",116,0)
 ;--- If the rule has already been processed, try to remove it from
"RTN","RORUPR",117,0)
 ;    the dependency list of the parent rule
"RTN","RORUPR",118,0)
 I $P(HDR,U,3)  D REMOVE(RULENAME,FILE,MODE,$G(PARENT))  Q 0
"RTN","RORUPR",119,0)
 ;--- If the rule is in the list of parent rules already, it has been
"RTN","RORUPR",120,0)
 ;    mentioned ; somewhere above in the current processing path.
"RTN","RORUPR",121,0)
 ;    So, we have "cirle refrenece" (the rule directly or inderectly
"RTN","RORUPR",122,0)
 ;    depends on itself)
"RTN","RORUPR",123,0)
 Q:$D(LSTRUL(RULENAME)) $$ERROR^RORERR(-5,"PUTRULE^RORUPR",RULENAME)
"RTN","RORUPR",124,0)
 ;--- Put the rule into the list of parent rules
"RTN","RORUPR",125,0)
 S LSTRUL(RULENAME)=""
"RTN","RORUPR",126,0)
 ;--- Process the rules that this one depends on
"RTN","RORUPR",127,0)
 S DEPNAME=""
"RTN","RORUPR",128,0)
 F  S DEPNAME=$O(@RORUPDPI@(3,RULENAME,3,DEPNAME))  Q:DEPNAME=""  D  Q:RC<0
"RTN","RORUPR",129,0)
 . S RC=$$PUTRULE(DEPNAME,MODE,RULENAME)
"RTN","RORUPR",130,0)
 ;--- Remove the rule from the list of parent rules
"RTN","RORUPR",131,0)
 K LSTRUL(RULENAME)  Q:RC<0 RC
"RTN","RORUPR",132,0)
 ;--- Process the rule (put it in the sorted list of rules) if there
"RTN","RORUPR",133,0)
 ;    are no rules left in its dependency list
"RTN","RORUPR",134,0)
 D:$D(@RORUPDPI@(3,RULENAME,3))<10
"RTN","RORUPR",135,0)
 . S IR=$O(RORUPD("SR",FILE,MODE,""),-1)+1
"RTN","RORUPR",136,0)
 . S DSTNODE=$NA(RORUPD("SR",FILE,MODE,IR))
"RTN","RORUPR",137,0)
 . S @DSTNODE=RULENAME_U_+HDR_U_$P(HDR,U,4)
"RTN","RORUPR",138,0)
 . S @DSTNODE@(1)=@RORUPDPI@(3,RULENAME,1)
"RTN","RORUPR",139,0)
 . M @DSTNODE@(2)=@RORUPDPI@(3,RULENAME,2)
"RTN","RORUPR",140,0)
 . S $P(@RORUPDPI@(3,RULENAME),U,3)=1
"RTN","RORUPR",141,0)
 . ;--- Try to remove the rule from the dependency list of
"RTN","RORUPR",142,0)
 . ;    the parent rule
"RTN","RORUPR",143,0)
 . D REMOVE(RULENAME,FILE,MODE,$G(PARENT))
"RTN","RORUPR",144,0)
 Q 0
"RTN","RORUPR",145,0)
 ;
"RTN","RORUPR",146,0)
 ;***** REMOVES THE RULE FROM THE DEPENDENCY LIST OF THE PARENT RULE
"RTN","RORUPR",147,0)
 ;
"RTN","RORUPR",148,0)
 ; RULENAME      Name of the rule
"RTN","RORUPR",149,0)
 ; FILE          File number
"RTN","RORUPR",150,0)
 ; MODE          "A" (process after subfiles) or
"RTN","RORUPR",151,0)
 ;               "B" (process before subfiles)
"RTN","RORUPR",152,0)
 ; PARENT        Name of the parent rule
"RTN","RORUPR",153,0)
 ;
"RTN","RORUPR",154,0)
 ; During the first pass of the sort ("before" rules) a rule is
"RTN","RORUPR",155,0)
 ; removed from the parent's dependency list only if the rule is
"RTN","RORUPR",156,0)
 ; associated with the same file as its parent.
"RTN","RORUPR",157,0)
 ;
"RTN","RORUPR",158,0)
 ; Rules are always removed from the dependency list during
"RTN","RORUPR",159,0)
 ; the second sort pass ("after" rules").
"RTN","RORUPR",160,0)
 ;
"RTN","RORUPR",161,0)
REMOVE(RULENAME,FILE,MODE,PARENT) ;
"RTN","RORUPR",162,0)
 Q:$G(PARENT)=""
"RTN","RORUPR",163,0)
 K:(+$P($G(@RORUPDPI@(3,PARENT)),U,2)=FILE)!(MODE="A") @RORUPDPI@(3,PARENT,3,RULENAME)
"RTN","RORUPR",164,0)
 Q
"RTN","RORUPR",165,0)
 ;
"RTN","RORUPR",166,0)
 ;***** SORTS SELECTION RULES
"RTN","RORUPR",167,0)
 ;
"RTN","RORUPR",168,0)
 ; Return Values:
"RTN","RORUPR",169,0)
 ;        0  Ok
"RTN","RORUPR",170,0)
 ;       <0  Error code
"RTN","RORUPR",171,0)
 ;
"RTN","RORUPR",172,0)
SORT() ;
"RTN","RORUPR",173,0)
 N LSTRUL        ; List of names of the parent rules above in the path
"RTN","RORUPR",174,0)
 N RORERRDL      ; Default error location
"RTN","RORUPR",175,0)
 ;
"RTN","RORUPR",176,0)
 N FILE,MODE,RC,RULENAME
"RTN","RORUPR",177,0)
 D DFLTLOC^RORERR("SORT^RORUPR")
"RTN","RORUPR",178,0)
 S RC=0  K RORUPD("SR")
"RTN","RORUPR",179,0)
 ;--- Process "before" selection rules first and then process
"RTN","RORUPR",180,0)
 ;  "after" rules
"RTN","RORUPR",181,0)
 F MODE="B","A"  D  Q:RC
"RTN","RORUPR",182,0)
 . S FILE=""             ; Loop through affected files
"RTN","RORUPR",183,0)
 . F  S FILE=$O(@RORUPDPI@(1,FILE))  Q:FILE=""  D  Q:RC
"RTN","RORUPR",184,0)
 . . S RULENAME=""       ; Loop through top level rules
"RTN","RORUPR",185,0)
 . . F  S RULENAME=$O(@RORUPDPI@(1,FILE,"S",RULENAME))  Q:RULENAME=""  D  Q:RC<0
"RTN","RORUPR",186,0)
 . . . S RC=$$PUTRULE(RULENAME,MODE)
"RTN","RORUPR",187,0)
 ;---
"RTN","RORUPR",188,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1")
0^32^B71827548
"RTN","RORUPR1",1,0)
RORUPR1 ;HCIOFO/SG - SELECTION RULES PREPARATION  ; 8/5/02 9:04am
"RTN","RORUPR1",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORUPR1",3,0)
 ;
"RTN","RORUPR1",4,0)
 Q
"RTN","RORUPR1",5,0)
 ;
"RTN","RORUPR1",6,0)
 ;***** MARKS PARENT FILES TO PROCESS
"RTN","RORUPR1",7,0)
 ;
"RTN","RORUPR1",8,0)
 ; This function analyzes file dependencies defined by the 'ROR
"RTN","RORUPR1",9,0)
 ; METADATA' file and guaranties that all necessary files will be
"RTN","RORUPR1",10,0)
 ; processed during the registry update.
"RTN","RORUPR1",11,0)
 ;
"RTN","RORUPR1",12,0)
FILETREE() ;
"RTN","RORUPR1",13,0)
 N FILE,PF,RC
"RTN","RORUPR1",14,0)
 S FILE="",RC=0
"RTN","RORUPR1",15,0)
 F  S FILE=$O(RORUPD("SR",FILE))  Q:FILE=""  D  Q:RC<0
"RTN","RORUPR1",16,0)
 . S PF=+FILE,RC=0
"RTN","RORUPR1",17,0)
 . ;--- Follow a path that leads from this file to
"RTN","RORUPR1",18,0)
 . ;    the root of the "file-processing tree".
"RTN","RORUPR1",19,0)
 . F  D  Q:RC
"RTN","RORUPR1",20,0)
 . . ;--- Check if metadata for the file is defined
"RTN","RORUPR1",21,0)
 . . I '$D(^ROR(799.2,PF))  D  Q
"RTN","RORUPR1",22,0)
 . . . S RC=$$ERROR^RORERR(-63,"METADATA^RORUPR1",,,PF)
"RTN","RORUPR1",23,0)
 . . ;--- Get the number of the parent file
"RTN","RORUPR1",24,0)
 . . S PF=+$$GET1^DIQ(799.2,PF_",",1,"I",,"RORMSG")
"RTN","RORUPR1",25,0)
 . . I $G(DIERR)  D  Q
"RTN","RORUPR1",26,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,"METADATA^RORUPR1")
"RTN","RORUPR1",27,0)
 . . ;--- Stop if the root of the "file-processing tree" has been
"RTN","RORUPR1",28,0)
 . . ;    reached or the file is already marked for processing.
"RTN","RORUPR1",29,0)
 . . ;    Otherwise, mark the file and continue moving up.
"RTN","RORUPR1",30,0)
 . . I 'PF!$D(RORUPD("SR",PF))  S RC=1  Q
"RTN","RORUPR1",31,0)
 . . S RORUPD("SR",PF)=""
"RTN","RORUPR1",32,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1",33,0)
 ;
"RTN","RORUPR1",34,0)
 ;***** RETURNS LEVEL OF THE FILE IN 'THE FILE PROCESSING' TREE
"RTN","RORUPR1",35,0)
 ;
"RTN","RORUPR1",36,0)
 ; FILE          File number
"RTN","RORUPR1",37,0)
 ;
"RTN","RORUPR1",38,0)
FLEVEL(FILE) ;
"RTN","RORUPR1",39,0)
 N LEVEL
"RTN","RORUPR1",40,0)
 S LEVEL=1
"RTN","RORUPR1",41,0)
 F  S FILE=+$P($G(^ROR(799.2,FILE,0)),U,2)  Q:'FILE  S LEVEL=LEVEL+1
"RTN","RORUPR1",42,0)
 Q LEVEL
"RTN","RORUPR1",43,0)
 ;
"RTN","RORUPR1",44,0)
 ;***** LOADS AND PREPARES LAB SEARCH INDICATORS
"RTN","RORUPR1",45,0)
 ;
"RTN","RORUPR1",46,0)
 ; Return Values:
"RTN","RORUPR1",47,0)
 ;        0  Ok
"RTN","RORUPR1",48,0)
 ;       <0  Error code
"RTN","RORUPR1",49,0)
 ;
"RTN","RORUPR1",50,0)
LABSRCH() ;
"RTN","RORUPR1",51,0)
 N I,IND,IR,LRCODE,LSICNT,LSIEN,RC,RORBUF,RORMSG,TMP,VAL
"RTN","RORUPR1",52,0)
 K RORLRC
"RTN","RORUPR1",53,0)
 ;--- Browse through the list of Lab searches
"RTN","RORUPR1",54,0)
 S LSIEN="",RC=0
"RTN","RORUPR1",55,0)
 F  S LSIEN=$O(@RORUPDPI@(4,LSIEN))  Q:LSIEN=""  D  Q:RC<0
"RTN","RORUPR1",56,0)
 . S TMP=","_LSIEN_","
"RTN","RORUPR1",57,0)
 . D LIST^DIC(798.92,TMP,"@;.01;.02;1I;2",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",58,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"LABSRCH^RORUPR1")  Q:RC<0
"RTN","RORUPR1",59,0)
 . ;--- Browse through the list of search indicators
"RTN","RORUPR1",60,0)
 . S IR="",LSICNT=0
"RTN","RORUPR1",61,0)
 . F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D  Q:RC<0
"RTN","RORUPR1",62,0)
 . . K LRCODE
"RTN","RORUPR1",63,0)
 . . S LRCODE=$G(RORBUF("DILIST","ID",IR,.01))
"RTN","RORUPR1",64,0)
 . . I LRCODE>0  D  Q:RC<0  S LRCODE(LRCODE_"^LN")=""
"RTN","RORUPR1",65,0)
 . . . S LRCODE=$$LNCODE^RORUTL02(LRCODE)
"RTN","RORUPR1",66,0)
 . . . S:LRCODE<0 RC=LRCODE
"RTN","RORUPR1",67,0)
 . . S LRCODE=$G(RORBUF("DILIST","ID",IR,.02))
"RTN","RORUPR1",68,0)
 . . S:LRCODE>0 LRCODE(LRCODE_"^NLT")=""
"RTN","RORUPR1",69,0)
 . . M RORLRC("B")=LRCODE
"RTN","RORUPR1",70,0)
 . . ;--- Load a search indicator
"RTN","RORUPR1",71,0)
 . . S IND=$G(RORBUF("DILIST","ID",IR,1))  Q:IND'>0
"RTN","RORUPR1",72,0)
 . . S VAL=$G(RORBUF("DILIST","ID",IR,2))  Q:(IND>1)&(VAL="")
"RTN","RORUPR1",73,0)
 . . S LSICNT=LSICNT+1
"RTN","RORUPR1",74,0)
 . . S LRCODE=""
"RTN","RORUPR1",75,0)
 . . F  S LRCODE=$O(LRCODE(LRCODE))  Q:LRCODE=""  D
"RTN","RORUPR1",76,0)
 . . . S I=$O(@RORUPDPI@("LS",LRCODE,LSIEN,""),-1)+1
"RTN","RORUPR1",77,0)
 . . . S @RORUPDPI@("LS",LRCODE,LSIEN,I)=IND_U_VAL
"RTN","RORUPR1",78,0)
 . Q:(RC<0)!(LSICNT>0)
"RTN","RORUPR1",79,0)
 . ;--- Record a warning if no indicators are defined
"RTN","RORUPR1",80,0)
 . S TMP=$$GET1^DIQ(798.9,LSIEN_",",.01,,,"RORMSG")
"RTN","RORUPR1",81,0)
 . S TMP=$$ERROR^RORERR(-55,"LABSRCH^RORUPR1",,,TMP)
"RTN","RORUPR1",82,0)
 Q:RC<0 RC
"RTN","RORUPR1",83,0)
 ;--- Prepare a list of Lab result codes for GCPR^LA7QRY
"RTN","RORUPR1",84,0)
 S LRCODE=""
"RTN","RORUPR1",85,0)
 F IR=1:1  S LRCODE=$O(RORLRC("B",LRCODE))  Q:LRCODE=""  D
"RTN","RORUPR1",86,0)
 . S RORLRC(IR)=LRCODE
"RTN","RORUPR1",87,0)
 K RORLRC("B")
"RTN","RORUPR1",88,0)
 Q 0
"RTN","RORUPR1",89,0)
 ;
"RTN","RORUPR1",90,0)
 ;***** LOADS SELECTION RULES DATA
"RTN","RORUPR1",91,0)
 ;
"RTN","RORUPR1",92,0)
 ; .REGLST       Reference to a local array containing registry names
"RTN","RORUPR1",93,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUPR1",94,0)
 ;
"RTN","RORUPR1",95,0)
 ; Return Values:
"RTN","RORUPR1",96,0)
 ;        0  Ok
"RTN","RORUPR1",97,0)
 ;       <0  Error code
"RTN","RORUPR1",98,0)
 ;
"RTN","RORUPR1",99,0)
LOAD(REGLST) ;
"RTN","RORUPR1",100,0)
 N RORERRDL      ; Default error location
"RTN","RORUPR1",101,0)
 ;
"RTN","RORUPR1",102,0)
 N I,IENS,RC,REGIEN,REGNAME,RORBUF,RORMSG,RULENAME
"RTN","RORUPR1",103,0)
 D DFLTLOC^RORERR("LOAD^RORUPR1")  K RORUPD("LM1")
"RTN","RORUPR1",104,0)
 S REGNAME="",RC=0
"RTN","RORUPR1",105,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUPR1",106,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUPR1",107,0)
 . I REGIEN'>0  D  I REGIEN'>0  S RC=REGIEN  Q
"RTN","RORUPR1",108,0)
 . . S REGIEN=$$REGIEN^RORUTL02(REGNAME)
"RTN","RORUPR1",109,0)
 . S @RORUPDPI@(2,REGIEN)=REGNAME
"RTN","RORUPR1",110,0)
 . ;--- Load selection rules
"RTN","RORUPR1",111,0)
 . K RORBUF  S IENS=","_REGIEN_","
"RTN","RORUPR1",112,0)
 . D LIST^DIC(798.13,IENS,"@;.01E",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",113,0)
 . S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0
"RTN","RORUPR1",114,0)
 . S I=""
"RTN","RORUPR1",115,0)
 . F  S I=$O(RORBUF("DILIST","ID",I))  Q:I=""  D  Q:RC<0
"RTN","RORUPR1",116,0)
 . . S RULENAME=RORBUF("DILIST","ID",I,.01)
"RTN","RORUPR1",117,0)
 . . S RC=$$LOADRULE(RULENAME,REGIEN)
"RTN","RORUPR1",118,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1",119,0)
 ;
"RTN","RORUPR1",120,0)
 ;***** LOADS THE SELECTION RULE
"RTN","RORUPR1",121,0)
 ;
"RTN","RORUPR1",122,0)
 ; RULENAME      Name of the rule
"RTN","RORUPR1",123,0)
 ; REGIEN        Registry IEN
"RTN","RORUPR1",124,0)
 ; [LEVEL]       Level of the rule (O for top level rules)
"RTN","RORUPR1",125,0)
 ;
"RTN","RORUPR1",126,0)
 ; Return Values:
"RTN","RORUPR1",127,0)
 ;        0  Ok
"RTN","RORUPR1",128,0)
 ;       <0  Error code
"RTN","RORUPR1",129,0)
 ;
"RTN","RORUPR1",130,0)
LOADRULE(RULENAME,REGIEN,LEVEL) ;
"RTN","RORUPR1",131,0)
 N RORERRDL      ; Default error location
"RTN","RORUPR1",132,0)
 ;
"RTN","RORUPR1",133,0)
 ;--- Quit if the rule has already been loaded
"RTN","RORUPR1",134,0)
 I $D(@RORUPDPI@(3,RULENAME))  D  Q 0
"RTN","RORUPR1",135,0)
 . S @RORUPDPI@(3,RULENAME,2,REGIEN)=""
"RTN","RORUPR1",136,0)
 ;---
"RTN","RORUPR1",137,0)
 N DATELMT,DEPRLC,EXPR,FILE,I,IENS,RORBUF,RORMSG,RULIEN,TMP
"RTN","RORUPR1",138,0)
 D DFLTLOC^RORERR("LOADRULE^RORUPR1")
"RTN","RORUPR1",139,0)
 ;--- Load the rule data
"RTN","RORUPR1",140,0)
 D FIND^DIC(798.2,,"@;1;2I","X",RULENAME,2,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",141,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORUPR1",142,0)
 Q:$G(RORBUF("DILIST",0))<1 $$ERROR^RORERR(-3,,RULENAME)
"RTN","RORUPR1",143,0)
 Q:$G(RORBUF("DILIST",0))>1 $$ERROR^RORERR(-4,,RULENAME)
"RTN","RORUPR1",144,0)
 S RULIEN=+RORBUF("DILIST",2,1),IENS=","_RULIEN_","
"RTN","RORUPR1",145,0)
 S FILE=+RORBUF("DILIST","ID",1,2)
"RTN","RORUPR1",146,0)
 ;--- Put the rule data into the temporary global
"RTN","RORUPR1",147,0)
 S @RORUPDPI@(1,FILE,"S",RULENAME)=""
"RTN","RORUPR1",148,0)
 S @RORUPDPI@(3,RULENAME)=RULIEN_U_FILE_"^^"_'$G(LEVEL)
"RTN","RORUPR1",149,0)
 S RC=$$PARSER^RORUPEX(FILE,RORBUF("DILIST","ID",1,1),.EXPR)
"RTN","RORUPR1",150,0)
 Q:RC<0 RC
"RTN","RORUPR1",151,0)
 S @RORUPDPI@(3,RULENAME,1)=EXPR
"RTN","RORUPR1",152,0)
 S @RORUPDPI@(3,RULENAME,2,REGIEN)=""
"RTN","RORUPR1",153,0)
 M @RORUPDPI@(1,FILE,"F")=EXPR("F")
"RTN","RORUPR1",154,0)
 S:'$G(LEVEL) RORUPD("LM1",RULENAME)=""
"RTN","RORUPR1",155,0)
 M @RORUPDPI@(4)=EXPR("L")
"RTN","RORUPR1",156,0)
 ;--- Load the rules that this rule depends on
"RTN","RORUPR1",157,0)
 S DEPRLC=""
"RTN","RORUPR1",158,0)
 F  S DEPRLC=$O(EXPR("R",DEPRLC))  Q:DEPRLC=""  D  Q:RC<0
"RTN","RORUPR1",159,0)
 . S RC=$$LOADRULE(DEPRLC,REGIEN,$G(LEVEL)+1)
"RTN","RORUPR1",160,0)
 . S:RC'<0 @RORUPDPI@(3,RULENAME,3,DEPRLC)=""
"RTN","RORUPR1",161,0)
 Q:RC<0 RC
"RTN","RORUPR1",162,0)
 ;--- Load a list of additional data elements
"RTN","RORUPR1",163,0)
 K EXPR,RORBUF,RORMSG
"RTN","RORUPR1",164,0)
 D LIST^DIC(798.26,IENS,"@;.01I;1I",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUPR1",165,0)
 S RC=$$DBS^RORERR("RORMSG",-9)  Q:RC<0 RC
"RTN","RORUPR1",166,0)
 S I=""
"RTN","RORUPR1",167,0)
 F  S I=$O(RORBUF("DILIST","ID",I))  Q:I=""  D
"RTN","RORUPR1",168,0)
 . S DATELMT=RORBUF("DILIST","ID",I,.01)
"RTN","RORUPR1",169,0)
 . S TMP=$G(RORBUF("DILIST","ID",I,1))  S:TMP="" TMP="EI"
"RTN","RORUPR1",170,0)
 . S:TMP["E" @RORUPDPI@(1,FILE,"F",DATELMT,"E")=""
"RTN","RORUPR1",171,0)
 . S:TMP["I" @RORUPDPI@(1,FILE,"F",DATELMT,"I")=""
"RTN","RORUPR1",172,0)
 Q 0
"RTN","RORUPR1",173,0)
 ;
"RTN","RORUPR1",174,0)
 ;***** LOADS AND PREPARES THE METADATA
"RTN","RORUPR1",175,0)
METADATA() ;
"RTN","RORUPR1",176,0)
 N API,DATELMT,DEFL,FILE,I,IENS,IS,PIF,RC,ROOT,RORBUF,RORMSG,TMP,VT
"RTN","RORUPR1",177,0)
 S RC=$$FILETREE()  Q:RC<0 RC
"RTN","RORUPR1",178,0)
 S DEFL="@;.02I;1I;4I;4.1;4.2;6I"
"RTN","RORUPR1",179,0)
 ;--- Load and process the metadata
"RTN","RORUPR1",180,0)
 S FILE="",RC=0
"RTN","RORUPR1",181,0)
 F  S FILE=$O(RORUPD("SR",FILE))  Q:FILE=""  D  Q:RC<0
"RTN","RORUPR1",182,0)
 . S IENS=","_FILE_",",PIF=$NA(@RORUPDPI@(1,FILE))
"RTN","RORUPR1",183,0)
 . ;--- Global root of the file
"RTN","RORUPR1",184,0)
 . S RORUPD("ROOT",FILE)=$$ROOT^DILFD(FILE,,1)
"RTN","RORUPR1",185,0)
 . ;--- Associate data elements with APIs
"RTN","RORUPR1",186,0)
 . S DATELMT=""
"RTN","RORUPR1",187,0)
 . F  S DATELMT=$O(@PIF@("F",DATELMT))  Q:DATELMT=""  D  Q:RC<0
"RTN","RORUPR1",188,0)
 . . ;--- Find and load defintion of the data element
"RTN","RORUPR1",189,0)
 . . K RORBUF,RORMSG
"RTN","RORUPR1",190,0)
 . . D FIND^DIC(799.22,IENS,DEFL,"X",DATELMT,,"C",,,"RORBUF","RORMSG")
"RTN","RORUPR1",191,0)
 . . I $G(DIERR)  D  Q
"RTN","RORUPR1",192,0)
 . . . S RC=$$DBS^RORERR("RORMSG",-9,"METADATA^RORUPR1",,799.22,IENS)
"RTN","RORUPR1",193,0)
 . . ;--- Check if search on this element is supported
"RTN","RORUPR1",194,0)
 . . S API=+$G(RORBUF("DILIST","ID",1,1))
"RTN","RORUPR1",195,0)
 . . I 'API  D  Q
"RTN","RORUPR1",196,0)
 . . . S RC=$$ERROR^RORERR(-64,"METADATA^RORUPR1",,,FILE,DATELMT)
"RTN","RORUPR1",197,0)
 . . ;--- Store the field number (if necessary)
"RTN","RORUPR1",198,0)
 . . I API=1  D  S RORUPD("SR",FILE,"F",API,DATELMT)=TMP
"RTN","RORUPR1",199,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",1,6))
"RTN","RORUPR1",200,0)
 . . ;--- Associate the data element with the API
"RTN","RORUPR1",201,0)
 . . S VT=$G(RORBUF("DILIST","ID",1,4)),RC=0
"RTN","RORUPR1",202,0)
 . . F I="E","I"  I $D(@PIF@("F",DATELMT,I))  D  Q:RC<0
"RTN","RORUPR1",203,0)
 . . . ;--- Check if type of the requested value is supported
"RTN","RORUPR1",204,0)
 . . . I VT'[I  D  Q
"RTN","RORUPR1",205,0)
 . . . . S TMP=$$EXTERNAL^DILFD(799.22,4,,I,"RORMSG")
"RTN","RORUPR1",206,0)
 . . . . S RC=$$ERROR^RORERR(-65,"METADATA^RORUPR1",,,FILE,DATELMT,TMP)
"RTN","RORUPR1",207,0)
 . . . ;--- Add the API-Element pair to the list
"RTN","RORUPR1",208,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",1,$$VTFN(I)))
"RTN","RORUPR1",209,0)
 . . . S RORUPD("SR",FILE,"F",API,DATELMT,I)=TMP
"RTN","RORUPR1",210,0)
 . Q:RC<0
"RTN","RORUPR1",211,0)
 . ;--- Add required elements (if any) to the list
"RTN","RORUPR1",212,0)
 . K RORBUF,RORMSG
"RTN","RORUPR1",213,0)
 . D FIND^DIC(799.22,IENS,DEFL,"X",1,,"AR",,,"RORBUF","RORMSG")
"RTN","RORUPR1",214,0)
 . I $G(DIERR)  D  Q
"RTN","RORUPR1",215,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"METADATA^RORUPR1",,799.22,IENS)
"RTN","RORUPR1",216,0)
 . S IS=""
"RTN","RORUPR1",217,0)
 . F  S IS=$O(RORBUF("DILIST","ID",IS))  Q:IS=""  D
"RTN","RORUPR1",218,0)
 . . S DATELMT=+$G(RORBUF("DILIST","ID",IS,.02))  Q:'DATELMT
"RTN","RORUPR1",219,0)
 . . S API=+$G(RORBUF("DILIST","ID",IS,1))        Q:'API
"RTN","RORUPR1",220,0)
 . . S VT=$G(RORBUF("DILIST","ID",IS,4))
"RTN","RORUPR1",221,0)
 . . F I="E","I"  D:VT[I
"RTN","RORUPR1",222,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",IS,$$VTFN(I)))
"RTN","RORUPR1",223,0)
 . . . S RORUPD("SR",FILE,"F",API,DATELMT,I)=TMP
"RTN","RORUPR1",224,0)
 . . ;--- Store the field number (if necessary)
"RTN","RORUPR1",225,0)
 . . I API=1  D  S RORUPD("SR",FILE,"F",API,DATELMT)=TMP
"RTN","RORUPR1",226,0)
 . . . S TMP=$G(RORBUF("DILIST","ID",IS,6))
"RTN","RORUPR1",227,0)
 . ;--- Compile a list of fields (separated by ';') for the GETS^DIQ
"RTN","RORUPR1",228,0)
 . Q:$D(RORUPD("SR",FILE,"F",1))<10
"RTN","RORUPR1",229,0)
 . S (DATELMT,RORBUF)=""
"RTN","RORUPR1",230,0)
 . F  S DATELMT=$O(RORUPD("SR",FILE,"F",1,DATELMT))  Q:DATELMT=""  D
"RTN","RORUPR1",231,0)
 . . S TMP=+$G(RORUPD("SR",FILE,"F",1,DATELMT))
"RTN","RORUPR1",232,0)
 . . S:TMP>0 RORBUF=RORBUF_";"_TMP
"RTN","RORUPR1",233,0)
 . S RORUPD("SR",FILE,"F",1)=$S(RORBUF'="":$P(RORBUF,";",2,999),1:"")
"RTN","RORUPR1",234,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUPR1",235,0)
 ;
"RTN","RORUPR1",236,0)
 ;***** RETURNS FIELD NUMBER OF ADDITIONAL DATA
"RTN","RORUPR1",237,0)
VTFN(VT) ;
"RTN","RORUPR1",238,0)
 Q $S(VT="E":4.1,1:4.2)
"RTN","RORUTL02")
0^24^B38852738
"RTN","RORUTL02",1,0)
RORUTL02 ;HCIOFO/SG - UTILITIES  ; 8/16/02 8:35am
"RTN","RORUTL02",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORUTL02",3,0)
 ;
"RTN","RORUTL02",4,0)
 ; This routine uses the following IAs:
"RTN","RORUTL02",5,0)
 ;
"RTN","RORUTL02",6,0)
 ; #2701         $$GETICN^MPIF001 Gets ICN (supported)
"RTN","RORUTL02",7,0)
 ; #3556         $$GCPR^LA7QRY
"RTN","RORUTL02",8,0)
 ; #3557         Access to the field .01 and x-ref "B"
"RTN","RORUTL02",9,0)
 ;               of the file 95.3
"RTN","RORUTL02",10,0)
 ; #3646         $$EMPL^DGSEC4
"RTN","RORUTL02",11,0)
 ; #10035        Access to the field #.09 of the file #2
"RTN","RORUTL02",12,0)
 ;
"RTN","RORUTL02",13,0)
 Q
"RTN","RORUTL02",14,0)
 ;
"RTN","RORUTL02",15,0)
 ;***** CREATES A LIST OF ACTIVE REGISTRIES
"RTN","RORUTL02",16,0)
 ;
"RTN","RORUTL02",17,0)
 ; .SRCLST       A source list of registry names (as subscripts)
"RTN","RORUTL02",18,0)
 ; .DSTLST(      A list of names and IENs of active registries
"RTN","RORUTL02",19,0)
 ;   RegName)    Registry IEN
"RTN","RORUTL02",20,0)
 ;
"RTN","RORUTL02",21,0)
 ; Return values:
"RTN","RORUTL02",22,0)
 ;       <0  Error code
"RTN","RORUTL02",23,0)
 ;        0  Ok
"RTN","RORUTL02",24,0)
 ;
"RTN","RORUTL02",25,0)
 ; The function stores names and IENs of those registries from the
"RTN","RORUTL02",26,0)
 ; source list which are active and not awaiting acknowledgements
"RTN","RORUTL02",27,0)
 ; into a local variable passed as the second parameter.
"RTN","RORUTL02",28,0)
 ;
"RTN","RORUTL02",29,0)
 ; Moreover, it records corresponding messages about skipped
"RTN","RORUTL02",30,0)
 ; registries to the current open log.
"RTN","RORUTL02",31,0)
 ;
"RTN","RORUTL02",32,0)
ARLST(SRCLST,DSTLST) ;
"RTN","RORUTL02",33,0)
 N INFO,RC,REGIEN,REGNAME,RORBUF,TMP  K DSTLST
"RTN","RORUTL02",34,0)
 S REGNAME="",RC=0
"RTN","RORUTL02",35,0)
 F  S REGNAME=$O(SRCLST(REGNAME))  Q:REGNAME=""  D  Q:RC<0
"RTN","RORUTL02",36,0)
 . S REGIEN=$$REGIEN(REGNAME,"@;2.2I;11I",.RORBUF)
"RTN","RORUTL02",37,0)
 . I REGIEN'>0  D  Q                        ; Error
"RTN","RORUTL02",38,0)
 . . S RC=$$ERROR^RORERR(REGIEN,"ARLST^RORUTL02",REGNAME)
"RTN","RORUTL02",39,0)
 . I $G(RORBUF("DILIST","ID",1,11))  D  Q   ; Inactive
"RTN","RORUTL02",40,0)
 . . S TMP=$$ERROR^RORERR(-48,"ARLST^RORUTL02",,,REGNAME)
"RTN","RORUTL02",41,0)
 . I $G(RORBUF("DILIST","ID",1,2.2))  D  Q  ; Awaiting ACK
"RTN","RORUTL02",42,0)
 . . S INFO(1)="If you see this error several times in a row, first"
"RTN","RORUTL02",43,0)
 . . S INFO(2)="of all check if the ROR SEND HL7 link is started and"
"RTN","RORUTL02",44,0)
 . . S INFO(3)="messages are actually sent to AAC. Then contact AAC"
"RTN","RORUTL02",45,0)
 . . S INFO(4)="to resolve the transmission problem(s)."
"RTN","RORUTL02",46,0)
 . . S TMP=$$ERROR^RORERR(-49,"ARLST^RORUTL02",.INFO,,REGNAME)
"RTN","RORUTL02",47,0)
 . S DSTLST(REGNAME)=REGIEN
"RTN","RORUTL02",48,0)
 Q RC
"RTN","RORUTL02",49,0)
 ;
"RTN","RORUTL02",50,0)
 ;***** RETURNS A FULL ICN OF THE PATIENT
"RTN","RORUTL02",51,0)
 ;
"RTN","RORUTL02",52,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",53,0)
 ;
"RTN","RORUTL02",54,0)
 ; Return Values:
"RTN","RORUTL02",55,0)
 ;       <0  Error code
"RTN","RORUTL02",56,0)
 ;       ""  ICN has not been assigned
"RTN","RORUTL02",57,0)
 ;       >0  Patient ICN
"RTN","RORUTL02",58,0)
 ;
"RTN","RORUTL02",59,0)
ICN(PATIEN) ;
"RTN","RORUTL02",60,0)
 N ICN,L,TMP
"RTN","RORUTL02",61,0)
 S ICN=$$GETICN^MPIF001(PATIEN)
"RTN","RORUTL02",62,0)
 I ICN'>0  D  Q ""
"RTN","RORUTL02",63,0)
 . S TMP=$$ERROR^RORERR(-57,"ICN^RORUTL02",$P(ICN,U,2),PATIEN,+ICN,"$$GETICN^MPIF001")
"RTN","RORUTL02",64,0)
 ;--- Validate the checksum (just in case ;-)
"RTN","RORUTL02",65,0)
 S L=$L($P(ICN,"V",2))
"RTN","RORUTL02",66,0)
 Q $S(L<6:$P(ICN,"V")_"V"_$E("000000",1,6-L)_$P(ICN,"V",2),1:ICN)
"RTN","RORUTL02",67,0)
 ;
"RTN","RORUTL02",68,0)
 ;I L<6  D  Q $P(ICN,"V")_"V"_$E("000000",1,6-L)_$P(ICN,"V",2)
"RTN","RORUTL02",69,0)
 ;. S TMP=$$ERROR^RORERR(-59,"ICN^RORUTL02",,PATIEN)
"RTN","RORUTL02",70,0)
 ;Q ICN
"RTN","RORUTL02",71,0)
 ;
"RTN","RORUTL02",72,0)
 ;***** LOADS THE LAB RESULTS
"RTN","RORUTL02",73,0)
 ;
"RTN","RORUTL02",74,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",75,0)
 ; SDT           Start date of the results
"RTN","RORUTL02",76,0)
 ; EDT           End date of the results
"RTN","RORUTL02",77,0)
 ;
"RTN","RORUTL02",78,0)
 ; Return values:
"RTN","RORUTL02",79,0)
 ;       <0  Error code
"RTN","RORUTL02",80,0)
 ;        0  Ok
"RTN","RORUTL02",81,0)
 ;
"RTN","RORUTL02",82,0)
 ; The function loads Lab results into the ^TMP("RORTMP",$J).
"RTN","RORUTL02",83,0)
 ;
"RTN","RORUTL02",84,0)
LABRSLTS(PATIEN,SDT,EDT) ;
"RTN","RORUTL02",85,0)
 N DST,H7CH,RC,RORMSG,TMP
"RTN","RORUTL02",86,0)
 S DST=$NA(^TMP("RORTMP",$J))  K @DST
"RTN","RORUTL02",87,0)
 Q:$D(RORLRC)<10 0
"RTN","RORUTL02",88,0)
 ;--- Get the Patient ID (ICN or SSN)
"RTN","RORUTL02",89,0)
 S PTID=$$PTID(PATIEN)  Q:PTID<0 PTID
"RTN","RORUTL02",90,0)
 ;--- Get the Lab data
"RTN","RORUTL02",91,0)
 S H7CH=$G(RORHL("FS"))_$G(RORHL("ECH"))
"RTN","RORUTL02",92,0)
 S RC=$$GCPR^LA7QRY(PTID,SDT,EDT,.RORLRC,"*",.RORMSG,DST,H7CH)
"RTN","RORUTL02",93,0)
 I $D(RORMSG)>1  D
"RTN","RORUTL02",94,0)
 . N ERR,I,LST
"RTN","RORUTL02",95,0)
 . S (ERR,LST)=""
"RTN","RORUTL02",96,0)
 . F I=1:1  S ERR=$O(RORMSG(ERR))  Q:ERR=""  D
"RTN","RORUTL02",97,0)
 . . S LST=LST_","_ERR,TMP=RORMSG(ERR)
"RTN","RORUTL02",98,0)
 . . K RORMSG(ERR)  S RORMSG(I)=TMP
"RTN","RORUTL02",99,0)
 . S LST=$P(LST,",",2,999)  Q:(LST=3)!(LST=99)
"RTN","RORUTL02",100,0)
 . S RC=$$ERROR^RORERR(-27,"LABRSLTS^RORUTL02",.RORMSG,PATIEN)
"RTN","RORUTL02",101,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL02",102,0)
 ;
"RTN","RORUTL02",103,0)
 ;***** RETURNS THE LOINC CODE WITH THE CONTROL DIGIT
"RTN","RORUTL02",104,0)
 ;
"RTN","RORUTL02",105,0)
 ; LNCODE        LOINC code
"RTN","RORUTL02",106,0)
 ;
"RTN","RORUTL02",107,0)
 ; Besides adding a control digit to the LOINC code, the function
"RTN","RORUTL02",108,0)
 ; checks the code against the LAB LOINC file (#95.3).
"RTN","RORUTL02",109,0)
 ;
"RTN","RORUTL02",110,0)
 ; Return values:
"RTN","RORUTL02",111,0)
 ;       <0  Error code
"RTN","RORUTL02",112,0)
 ;       >0  LOINC code with the control digit
"RTN","RORUTL02",113,0)
 ;
"RTN","RORUTL02",114,0)
LNCODE(LNCODE) ;
"RTN","RORUTL02",115,0)
 N RC,RORBUF,RORMSG
"RTN","RORUTL02",116,0)
 D FIND^DIC(95.3,,"@;.01E","X",$P(LNCODE,"-"),2,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL02",117,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"LNCODE^RORUTL02",,95.3)
"RTN","RORUTL02",118,0)
 I $G(RORBUF("DILIST",0))<1  D  Q RC ; Non-existent code
"RTN","RORUTL02",119,0)
 . S RC=$$ERROR^RORERR(-29,"LNCODE^RORUTL02",,,LNCODE)
"RTN","RORUTL02",120,0)
 I $G(RORBUF("DILIST",0))>1  D  Q RC ; Duplicate records
"RTN","RORUTL02",121,0)
 . S RC=$$ERROR^RORERR(-30,"LNCODE^RORUTL02",,,LNCODE)
"RTN","RORUTL02",122,0)
 Q RORBUF("DILIST","ID",1,.01)
"RTN","RORUTL02",123,0)
 ;
"RTN","RORUTL02",124,0)
 ;***** LOCK/UNLOCK REGISTRIES BEING PROCESSED
"RTN","RORUTL02",125,0)
 ;
"RTN","RORUTL02",126,0)
 ; .REGLST       Reference to a local array containing registry names 
"RTN","RORUTL02",127,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUTL02",128,0)
 ; [MODE]        0 - Unlock (default), 1 - Lock
"RTN","RORUTL02",129,0)
 ; [TO]          LOCK timeout (3 sec by defualt)
"RTN","RORUTL02",130,0)
 ;
"RTN","RORUTL02",131,0)
 ; Return Values:
"RTN","RORUTL02",132,0)
 ;       <0  Error code
"RTN","RORUTL02",133,0)
 ;        0  Some of the registries has been locked by another job
"RTN","RORUTL02",134,0)
 ;        1  Ok
"RTN","RORUTL02",135,0)
 ;
"RTN","RORUTL02",136,0)
LOCKREG(REGLST,MODE,TO) ;
"RTN","RORUTL02",137,0)
 Q:$D(REGLST)<10 1
"RTN","RORUTL02",138,0)
 N ARG,LOCKLST,LT,REGIEN,REGNAME
"RTN","RORUTL02",139,0)
 S (REGNAME,LOCKLST)=""
"RTN","RORUTL02",140,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D  Q:REGIEN<0
"RTN","RORUTL02",141,0)
 . S REGIEN=+$G(REGLST(REGNAME))
"RTN","RORUTL02",142,0)
 . I REGIEN'>0  S REGIEN=$$REGIEN^RORUTL02(REGNAME)  Q:REGIEN'>0
"RTN","RORUTL02",143,0)
 . S LOCKLST=LOCKLST_","_$NA(^ROR(798.1,REGIEN))
"RTN","RORUTL02",144,0)
 Q:$G(REGIEN)<0 REGIEN
"RTN","RORUTL02",145,0)
 Q:LOCKLST="" 1
"RTN","RORUTL02",146,0)
 S ARG=$S($G(MODE):"+",1:"-")_"("_$P(LOCKLST,",",2,999)_")"
"RTN","RORUTL02",147,0)
 X "L "_ARG_":"_+$G(TO,3)_"  S LT=$T"
"RTN","RORUTL02",148,0)
 Q LT
"RTN","RORUTL02",149,0)
 ;
"RTN","RORUTL02",150,0)
 ;***** RETURNS A PATIENT ID (ICN OR SSN)
"RTN","RORUTL02",151,0)
 ;
"RTN","RORUTL02",152,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",153,0)
 ;
"RTN","RORUTL02",154,0)
 ; Return Values:
"RTN","RORUTL02",155,0)
 ;       <0  Error code
"RTN","RORUTL02",156,0)
 ;       ""  Neither ICN nor SSN has been assigned
"RTN","RORUTL02",157,0)
 ;       >0  Patient ICN (or SSN if ICN is not available)
"RTN","RORUTL02",158,0)
 ;
"RTN","RORUTL02",159,0)
PTID(PATIEN) ;
"RTN","RORUTL02",160,0)
 N L,PTID,RC,RORMSG
"RTN","RORUTL02",161,0)
 S PTID=$$GETICN^MPIF001(PATIEN)
"RTN","RORUTL02",162,0)
 I PTID>0  D  Q PTID
"RTN","RORUTL02",163,0)
 . ;--- Validate the checksum (just in case ;-)
"RTN","RORUTL02",164,0)
 . S L=$L($P(PTID,"V",2))  Q:L'<6
"RTN","RORUTL02",165,0)
 . ;S RC=$$ERROR^RORERR(-59,"PTID^RORUTL02",,PATIEN)
"RTN","RORUTL02",166,0)
 . S $P(PTID,"V",2)=$E("000000",1,6-L)_$P(PTID,"V",2)
"RTN","RORUTL02",167,0)
 ;--- Get SSN if ICN is not available
"RTN","RORUTL02",168,0)
 S PTID=$$GET1^DIQ(2,PATIEN_",",.09,,,"RORMSG")
"RTN","RORUTL02",169,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"PTID^RORUTL02",PATIEN,2)
"RTN","RORUTL02",170,0)
 Q PTID
"RTN","RORUTL02",171,0)
 ;
"RTN","RORUTL02",172,0)
 ;***** RETURNS IEN OF THE REGISTRY PARAMETERS
"RTN","RORUTL02",173,0)
 ;
"RTN","RORUTL02",174,0)
 ; REGNAME       Name of the registry
"RTN","RORUTL02",175,0)
 ; [FIELDS]      List of fields (separated by semicolons) to load
"RTN","RORUTL02",176,0)
 ; [.RORTRGT]    Reference to a local variable where field values will
"RTN","RORUTL02",177,0)
 ;               be stored by the FIND^DIC call
"RTN","RORUTL02",178,0)
 ;
"RTN","RORUTL02",179,0)
 ; Return Values:
"RTN","RORUTL02",180,0)
 ;       <0  Error code
"RTN","RORUTL02",181,0)
 ;       >0  Registry parameters IEN
"RTN","RORUTL02",182,0)
 ;
"RTN","RORUTL02",183,0)
REGIEN(REGNAME,FIELDS,RORTRGT) ;
"RTN","RORUTL02",184,0)
 N RC,REGIEN,RORMSG  K RORTRGT
"RTN","RORUTL02",185,0)
 D FIND^DIC(798.1,,"@;"_$G(FIELDS),"X",REGNAME,2,"B",,,"RORTRGT","RORMSG")
"RTN","RORUTL02",186,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"REGIEN^RORUTL02",,798.1)
"RTN","RORUTL02",187,0)
 S RC=+$G(RORTRGT("DILIST",0))
"RTN","RORUTL02",188,0)
 Q $S(RC<1:-1,RC>1:-2,1:+RORTRGT("DILIST",2,1))
"RTN","RORUTL02",189,0)
 ;
"RTN","RORUTL02",190,0)
 ;***** RETURNS NUMBER OF RECORDS IN THE REGISTRY
"RTN","RORUTL02",191,0)
 ;
"RTN","RORUTL02",192,0)
 ; REGIEN        Registry IEN
"RTN","RORUTL02",193,0)
 ; [.LOWIEN]     The smallest IEN will be returned via this parameter
"RTN","RORUTL02",194,0)
 ; [.HIGHIEN]    The biggest IEN will be returned via this parameter
"RTN","RORUTL02",195,0)
 ;
"RTN","RORUTL02",196,0)
 ; Return Values:
"RTN","RORUTL02",197,0)
 ;       <0  Error code
"RTN","RORUTL02",198,0)
 ;        0  The registry is empty
"RTN","RORUTL02",199,0)
 ;       >0  Number of records in the registry
"RTN","RORUTL02",200,0)
 ;
"RTN","RORUTL02",201,0)
REGSIZE(REGIEN,LOWIEN,HIGHIEN) ;
"RTN","RORUTL02",202,0)
 N I,NODE,NRE,RC,RORFDA,RORMSG
"RTN","RORUTL02",203,0)
 S NODE=$NA(^RORDATA(798,"AC",REGIEN))
"RTN","RORUTL02",204,0)
 S LOWIEN=$O(@NODE@(""))
"RTN","RORUTL02",205,0)
 S HIGHIEN=$O(@NODE@(""),-1)
"RTN","RORUTL02",206,0)
 ;--- Get number of records from the parameters
"RTN","RORUTL02",207,0)
 S NRE=$$GET1^DIQ(798.1,REGIEN_",",19.1,,,"RORMSG")
"RTN","RORUTL02",208,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"REGSIZE^RORUTL02",,798.1,REGIEN)
"RTN","RORUTL02",209,0)
 Q:NRE>0 NRE
"RTN","RORUTL02",210,0)
 ;--- Count the records of the registry
"RTN","RORUTL02",211,0)
 S I="",NRE=0
"RTN","RORUTL02",212,0)
 F  S I=$O(@NODE@(I))  Q:I=""  S NRE=NRE+1
"RTN","RORUTL02",213,0)
 ;--- Store the value in the parameters
"RTN","RORUTL02",214,0)
 S RORFDA(798.1,REGIEN_",",19.1)=NRE
"RTN","RORUTL02",215,0)
 D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUTL02",216,0)
 Q NRE
"RTN","RORUTL02",217,0)
 ;
"RTN","RORUTL02",218,0)
 ;***** CHECKS IF AN EMPLOYEE SHOULD BE SKIPPED
"RTN","RORUTL02",219,0)
 ;
"RTN","RORUTL02",220,0)
 ; PATIEN        Patient IEN
"RTN","RORUTL02",221,0)
 ;
"RTN","RORUTL02",222,0)
 ; [.]REGIEN     Registry IEN
"RTN","RORUTL02",223,0)
 ;
"RTN","RORUTL02",224,0)
 ;               If you are going to call this function for several
"RTN","RORUTL02",225,0)
 ;               patients in a row (in a cycle), you can pass the
"RTN","RORUTL02",226,0)
 ;               second parameter by reference. This will eliminate
"RTN","RORUTL02",227,0)
 ;               repetitive access to the registry parameters (the
"RTN","RORUTL02",228,0)
 ;               REGIEN("SE") node will be used as a "cache" for the
"RTN","RORUTL02",229,0)
 ;               value of the EXCLUDE EMPLOYEES field).
"RTN","RORUTL02",230,0)
 ;
"RTN","RORUTL02",231,0)
 ; Return Values:
"RTN","RORUTL02",232,0)
 ;        0  Patient can be added to the registry
"RTN","RORUTL02",233,0)
 ;        1  Patient should be skipped
"RTN","RORUTL02",234,0)
 ;
"RTN","RORUTL02",235,0)
 ; The function checks if the patient is an employee and if he/she
"RTN","RORUTL02",236,0)
 ; can be added to the registry (according to the value of the
"RTN","RORUTL02",237,0)
 ; EXCLUDE EMPLOYEES field of the ROR REGISTRY PARAMETERS file).
"RTN","RORUTL02",238,0)
 ;
"RTN","RORUTL02",239,0)
SKIPEMPL(PATIEN,REGIEN) ;
"RTN","RORUTL02",240,0)
 Q:'$$EMPL^DGSEC4(PATIEN,"P") 0
"RTN","RORUTL02",241,0)
 S:'$D(REGIEN("SE")) REGIEN("SE")=+$P($G(^ROR(798.1,+REGIEN,0)),U,10)
"RTN","RORUTL02",242,0)
 Q +REGIEN("SE")
"RTN","RORUTL02",243,0)
 ;
"RTN","RORUTL02",244,0)
 ;***** RETURNS IEN OF THE SELECTION RULE
"RTN","RORUTL02",245,0)
 ;
"RTN","RORUTL02",246,0)
 ; RULENAME      Name of the selection rule
"RTN","RORUTL02",247,0)
 ; [FIELDS]      List of fields (separated by semicolons) to load
"RTN","RORUTL02",248,0)
 ; [.RORTRGT]    Reference to a local variable where field values will
"RTN","RORUTL02",249,0)
 ;               be stored by the FIND^DIC call.
"RTN","RORUTL02",250,0)
 ;
"RTN","RORUTL02",251,0)
 ; Return Values:
"RTN","RORUTL02",252,0)
 ;       <0  Error code
"RTN","RORUTL02",253,0)
 ;       >0  Selection rule IEN
"RTN","RORUTL02",254,0)
 ;
"RTN","RORUTL02",255,0)
SRLIEN(RULENAME,FIELDS,RORTRGT) ;
"RTN","RORUTL02",256,0)
 N RC,RULEIEN,RORMSG  K RORTRGT
"RTN","RORUTL02",257,0)
 D FIND^DIC(798.2,,"@;"_$G(FIELDS),"X",RULENAME,2,"B",,,"RORTRGT","RORMSG")
"RTN","RORUTL02",258,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"SRLIEN^RORUTL02",,798.2)
"RTN","RORUTL02",259,0)
 S RC=+$G(RORTRGT("DILIST",0))
"RTN","RORUTL02",260,0)
 Q $S(RC<1:-3,RC>1:-4,1:+RORTRGT("DILIST",2,1))
"RTN","RORUTL03")
0^14^B17060217
"RTN","RORUTL03",1,0)
RORUTL03 ;HOIFO/CRT - Encryption/Decryption ;09/21/99  11:35
"RTN","RORUTL03",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORUTL03",3,0)
 ;
"RTN","RORUTL03",4,0)
 Q
"RTN","RORUTL03",5,0)
 ;
"RTN","RORUTL03",6,0)
SITE1(CS) ; Return Default Site, for HL7 messages
"RTN","RORUTL03",7,0)
 ;
"RTN","RORUTL03",8,0)
 N RORSITE
"RTN","RORUTL03",9,0)
 ;
"RTN","RORUTL03",10,0)
 S CS=$S($G(CS)="":"^",1:CS)
"RTN","RORUTL03",11,0)
 ;
"RTN","RORUTL03",12,0)
 S RORSITE=$$SITE^VASITE
"RTN","RORUTL03",13,0)
 Q $P(RORSITE,"^",2)_CS_"99VA4"_CS_$P(RORSITE,"^",3)
"RTN","RORUTL03",14,0)
 ;
"RTN","RORUTL03",15,0)
SITE(CS) ;
"RTN","RORUTL03",16,0)
 ;
"RTN","RORUTL03",17,0)
 N RORSTN
"RTN","RORUTL03",18,0)
 S CS=$S($G(CS)="":"^",1:CS)
"RTN","RORUTL03",19,0)
 S RORSITE=$$SITE^VASITE
"RTN","RORUTL03",20,0)
 S RORSTN=$P(RORSITE,"^",3),RORSTN=$E(RORSTN,1,3)
"RTN","RORUTL03",21,0)
 Q RORSTN_CS_$P(RORSITE,"^",2)_CS_"99VA4"
"RTN","RORUTL03",22,0)
 ;
"RTN","RORUTL03",23,0)
DECRYPT(S) ;decrypt passed string
"RTN","RORUTL03",24,0)
 ;
"RTN","RORUTL03",25,0)
 N ASSOCIX,IDIX,ASSOCSTR,IDSTR
"RTN","RORUTL03",26,0)
 ;
"RTN","RORUTL03",27,0)
 S ASSOCIX=$A($E(S,$L(S)))-31
"RTN","RORUTL03",28,0)
 S IDIX=$A($E(S))-31
"RTN","RORUTL03",29,0)
 ;
"RTN","RORUTL03",30,0)
 S ASSOCSTR=$P($T(Z+ASSOCIX),";",3,9)
"RTN","RORUTL03",31,0)
 S IDSTR=$P($T(Z+IDIX),";",3,9)
"RTN","RORUTL03",32,0)
 ;
"RTN","RORUTL03",33,0)
 Q $TR($E(S,2,$L(S)-1),ASSOCSTR,IDSTR)
"RTN","RORUTL03",34,0)
 ;
"RTN","RORUTL03",35,0)
ENCRYPT(S) ;encrypt passed string
"RTN","RORUTL03",36,0)
 ;
"RTN","RORUTL03",37,0)
 N %,ASSOCIX,IDIX,ASSOCSTR,IDSTR
"RTN","RORUTL03",38,0)
 ;
"RTN","RORUTL03",39,0)
 S ASSOCIX=$R(20)+1
"RTN","RORUTL03",40,0)
 F  S IDIX=$R(20)+1 Q:ASSOCIX'=IDIX
"RTN","RORUTL03",41,0)
 ;
"RTN","RORUTL03",42,0)
 S ASSOCSTR=$P($T(Z+ASSOCIX),";",3,9)
"RTN","RORUTL03",43,0)
 S IDSTR=$P($T(Z+IDIX),";",3,9)
"RTN","RORUTL03",44,0)
 ;
"RTN","RORUTL03",45,0)
 Q $C(IDIX+31)_$TR(S,IDSTR,ASSOCSTR)_$C(ASSOCIX+31)
"RTN","RORUTL03",46,0)
 ;
"RTN","RORUTL03",47,0)
Z ;;
"RTN","RORUTL03",48,0)
 ;;ko-ZJtdG)49K{nX1BS$vH<:Myf*>Ae0!jQW=;#PwsO`E'%+rmb[gpqN,l6/hFC@DcUa ]zR}"ViIxu?872.(TYL5_3
"RTN","RORUTL03",49,0)
 ;;`R;M/9BqAF%tSs#Vh)dO1DZP>r *fX'u[.4KlY=-mg_ci802N7LTG<]!CWo:3?{v+,5Q}(@jaExn$pIyHwzU"k6Jeb
"RTN","RORUTL03",50,0)
 ;;ZJk"WQmCn!Y,y@1d+8s?[lNMxgHE(t=uwX:qSLjAI*}6zoF{T3#;cap)/h5%`P4$r]G'9e2if_>UDKb7V<v0- RBO.
"RTN","RORUTL03",51,0)
 ;;dpjt3g4W)qD0VNJarseB "?OYhcu[<M%Z`RIL_6:]AX-zG.#}$@vk7/5x*m;(yb2Fn+l'PwUof1K{9,EQi>H=CT8S!
"RTN","RORUTL03",52,0)
 ;;:1}K$byP;jk)7'`x90Bcq@iSsEnu,(Nl-hf.Y_?J#R]+voQXZU8mrV[!p4tgOWMez CAaGFD6H53%L/dT2<*>"{wI=
"RTN","RORUTL03",53,0)
 ;;J<oZ9phXVNn)m K`t/SI%]A5qOWe?;jTM!fz1l>[D_0xR32ic*4.P"G{r7}E8wvUgyudF+6-:B=$(sCY,LkbHa#'@Q
"RTN","RORUTL03",54,0)
 ;;X,'4Ty;[a8/{6lF_V"}qLI!@x(D7bRmUHh]W15J%N0BYPkrs9:$)Zj>uvzwQ=ieC-oGA.#?tfdcOM3gp`S+En K2*<
"RTN","RORUTL03",55,0)
 ;;W5[];4'<C$/xrZ(k{>?ghBzIFN}fAK"#`p_T!qtD*1E37XGVs@0nmdjSe+Y6Qyo-aUu%i8c=H2vJ) R:MLb.9,wlOP
"RTN","RORUTL03",56,0)
 ;;tjEM+!=xXb)7,ZV{*ci3"8@_l-HS69L>2]AUF/Q%:qD?1m(yvO0e'hT<#o$p4dnIzKP`NrkaGg.ufCRB[; sJYwW}5
"RTN","RORUTL03",57,0)
 ;;/zl-9y:Pj=(R'7QJI *CTX"p0]_3.idcuOBefVU#omwNZ`$vFs?L+1Sk<5,b)hM4A6[Y%aDrg@KqEW8t>H};n!2xG{
"RTN","RORUTL03",58,0)
 ;;0Bo@_HfnK>LR}qWXV+D6`Y28=4CmsG/7-5Ab9!a#rPF.lM$hc3ijQk;),TvzUd<[:I"u1'NZSOw]*gxtE{eJpy (?%
"RTN","RORUTL03",59,0)
 ;;D}LJyGO8`$*ZqH .j>cMh<d=fimszv[#-53F!+a;NC'6T91IV?(0@x/{B)w"]QY,UWprk4:ol%g2nE7teRKbAPuS_X
"RTN","RORUTL03",60,0)
 ;;Y#_0*H<B=Q+FML6]s;r2:e8R}[icKA 1w{)vV5d,.$u"xD/Pg?IyfthO@CzjWp%!`N4Z'3-(oJ9XUE7kTlqSb>anGm
"RTN","RORUTL03",61,0)
 ;;1']_GU<X`NgM?LS9{"jT%s$}y[nvtlefB2RKJW(/cIxDCPow4,>#zm+:5b@06O3Ap8=V*7ZFY!H-uEQk;a .q)irhd
"RTN","RORUTL03",62,0)
 ;;z7AG@QX."%3Lq>METUo{Pp_ a6<0dYVSv8:bI)W9NK`(r'4fswimkRe]C2hg=HOj$1B*/nxt,;cJ#y+![?lFuZ-5D}
"RTN","RORUTL03",63,0)
 ;;Ge6F Hx>q$mC%MTn,:"o'tX/*yP.{lZ!YkiVhuw_<KE5aR[;}W0gjsz3]@7cI2QN?f#4pvbr1OUBD9)=-L(JA+d`S8
"RTN","RORUTL03",64,0)
 ;;>ym};d)-7DZ"Fe/Y<B:xwojR,Vh]O0Sc[`$sg8GXE!I1Qrzp._W%TNKk(=J 3i*2abuHA4C'?MvPq{n#56LftUl@9+
"RTN","RORUTL03",65,0)
 ;;)9 WidFN,1KsmwQ>GJM{I4:C%}#Ep(?HB/r;t.U8ol['Lg"2hRDyZ5`nbf]qjc0!zS-TkYO<_=76a*X@$Pe3+AxVvu
"RTN","RORUTL03",66,0)
 ;;jf"5VdHc#uA,W1i+v'6@pr{n;DJ!8(btPGaQM.LT3oeg?NB/9>Z`-}02*%x<7Ylsqz4OS E$R]KI[:UwC_=h)kXmyF
"RTN","RORUTL03",67,0)
 ;;ar.{YU7mBZR@-K2 "+`M%8sq4JhPo<_XSg3WC;Tuxz,fvEiQ1p9=w}FAIj/keD0c?)LN6OHV]lG:5y'$*>nd[(tb!#
"RTN","RORUTL05")
0^34^B44273326
"RTN","RORUTL05",1,0)
RORUTL05 ;HCIOFO/SG - MISCELLANEOUS UTILITIES ; 8/28/02 1:53pm
"RTN","RORUTL05",2,0)
 ;;1.0;CLINICAL CASE REGISTRIES;**2**;May 14, 2002
"RTN","RORUTL05",3,0)
 ;
"RTN","RORUTL05",4,0)
 Q
"RTN","RORUTL05",5,0)
 ;
"RTN","RORUTL05",6,0)
 ;***** DELETES ALL RECORDS FROM THE (SUB)FILE
"RTN","RORUTL05",7,0)
 ;
"RTN","RORUTL05",8,0)
 ; FILE          File/Subfile number
"RTN","RORUTL05",9,0)
 ; [IENS]        IENS of the subfile
"RTN","RORUTL05",10,0)
 ;
"RTN","RORUTL05",11,0)
 ; Return Values:
"RTN","RORUTL05",12,0)
 ;       <0  Error code
"RTN","RORUTL05",13,0)
 ;        0  Ok
"RTN","RORUTL05",14,0)
 ;
"RTN","RORUTL05",15,0)
CLEAR(FILE,IENS) ;
"RTN","RORUTL05",16,0)
 N IEN,RC,ROOT,RORFDA,RORMSG
"RTN","RORUTL05",17,0)
 S ROOT=$$ROOT^DILFD(FILE,$G(IENS),1)
"RTN","RORUTL05",18,0)
 S:$G(IENS)="" IENS=","
"RTN","RORUTL05",19,0)
 ;--- Delete the records
"RTN","RORUTL05",20,0)
 S (IEN,RC)=0
"RTN","RORUTL05",21,0)
 F  S IEN=$O(@ROOT@(IEN))  Q:'IEN  D  Q:RC<0
"RTN","RORUTL05",22,0)
 . S RORFDA(FILE,IEN_IENS,.01)="@"
"RTN","RORUTL05",23,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL05",24,0)
 . I $G(DIERR)  D  Q
"RTN","RORUTL05",25,0)
 . . S RC=$$DBS^RORERR("RORMSG",-9,"CLEAR^RORUTL05",,FILE,IEN_IENS)
"RTN","RORUTL05",26,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL05",27,0)
 ;
"RTN","RORUTL05",28,0)
 ;***** CLEARS EXPIRED 'AWAITING ACKNOWLEDGEMENT' FLAGS
"RTN","RORUTL05",29,0)
 ;
"RTN","RORUTL05",30,0)
 ; .REGLST       Reference to a local array containing
"RTN","RORUTL05",31,0)
 ;               registry names as subscripts
"RTN","RORUTL05",32,0)
 ;
"RTN","RORUTL05",33,0)
CLRACK(REGLST) ;
"RTN","RORUTL05",34,0)
 N AWD,EXPDT,IENS,MSGID,NOW,RC,REGIEN,REGNAME
"RTN","RORUTL05",35,0)
 N RORBUF,RORFDA,RORINFO,RORMSG,TMP
"RTN","RORUTL05",36,0)
 S NOW=$$NOW^XLFDT
"RTN","RORUTL05",37,0)
 ;---
"RTN","RORUTL05",38,0)
 S REGNAME="",RORINFO=0
"RTN","RORUTL05",39,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D
"RTN","RORUTL05",40,0)
 . K RORBUF,RORFDA,RORMSG
"RTN","RORUTL05",41,0)
 . ;--- Get the registry IEN and parameters
"RTN","RORUTL05",42,0)
 . S REGIEN=$$REGIEN^RORUTL02(REGNAME,"2.2I;2.3I;15.9I",.RORBUF)
"RTN","RORUTL05",43,0)
 . Q:REGIEN'>0  Q:'$G(RORBUF("DILIST","ID",1,2.2))
"RTN","RORUTL05",44,0)
 . ;--- Check the expiration date/time
"RTN","RORUTL05",45,0)
 . S AWD=$G(RORBUF("DILIST","ID",1,15.9))
"RTN","RORUTL05",46,0)
 . S:(AWD="")!(AWD<0) AWD=3
"RTN","RORUTL05",47,0)
 . S EXPDT=$$FMADD^XLFDT(RORBUF("DILIST","ID",1,2.2),AWD)
"RTN","RORUTL05",48,0)
 . Q:EXPDT>NOW
"RTN","RORUTL05",49,0)
 . ;--- Clear the flag
"RTN","RORUTL05",50,0)
 . S IENS=REGIEN_","
"RTN","RORUTL05",51,0)
 . S RORFDA(798.1,IENS,2.2)="@" ; AWAITING ACKNOWLEDGEMENT
"RTN","RORUTL05",52,0)
 . S RORFDA(798.1,IENS,2.3)="@" ; LAST MESSAGE ID
"RTN","RORUTL05",53,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL05",54,0)
 . I $G(DIERR)  D  Q
"RTN","RORUTL05",55,0)
 . . S TMP=$$DBS^RORERR("RORMSG",-9,"CLRACK^RORUTL05",,798.1,IENS)
"RTN","RORUTL05",56,0)
 . S RORINFO=RORINFO+1,RORINFO(RORINFO)=REGNAME
"RTN","RORUTL05",57,0)
 . ;--- Record message status and cancel the message
"RTN","RORUTL05",58,0)
 . S MSGID=$G(RORBUF("DILIST","ID",1,2.3))
"RTN","RORUTL05",59,0)
 . I MSGID'=""  D  S TMP=$$MSGACT^HLUTIL(MSGID,1)
"RTN","RORUTL05",60,0)
 . . N STAT  S STAT=$$MSGSTAT^HLUTIL(MSGID)
"RTN","RORUTL05",61,0)
 . . S RORINFO=RORINFO+1
"RTN","RORUTL05",62,0)
 . . S RORINFO(RORINFO)="  Message ID:     "_MSGID
"RTN","RORUTL05",63,0)
 . . S RORINFO=RORINFO+1
"RTN","RORUTL05",64,0)
 . . S RORINFO(RORINFO)="  Message status: "_$$MSGSTXT^RORHL7(STAT)
"RTN","RORUTL05",65,0)
 . . S TMP=$P(STAT,U,2)  D:TMP
"RTN","RORUTL05",66,0)
 . . . S RORINFO=RORINFO+1
"RTN","RORUTL05",67,0)
 . . . S RORINFO(RORINFO)="  Status updated: "_$$FMTE^XLFDT(TMP)
"RTN","RORUTL05",68,0)
 . . S TMP=$P(STAT,U,3)  D:TMP'=""
"RTN","RORUTL05",69,0)
 . . . S RORINFO=RORINFO+1
"RTN","RORUTL05",70,0)
 . . . S RORINFO(RORINFO)="  Error message:  "_TMP
"RTN","RORUTL05",71,0)
 . . S TMP=$P(STAT,U,5)  D:TMP
"RTN","RORUTL05",72,0)
 . . . S RORINFO=RORINFO+1
"RTN","RORUTL05",73,0)
 . . . S TMP=$S(+STAT=1.7:"# of retries:   ",1:"Queue position: ")_TMP
"RTN","RORUTL05",74,0)
 . . . S RORINFO(RORINFO)="  "_TMP
"RTN","RORUTL05",75,0)
 . . S TMP=$P(STAT,U,6)  D:TMP'=""
"RTN","RORUTL05",76,0)
 . . . S RORINFO=RORINFO+1
"RTN","RORUTL05",77,0)
 . . . S RORINFO(RORINFO)="  Open failed:    "_TMP
"RTN","RORUTL05",78,0)
 . . S TMP=$P(STAT,U,7)  D:TMP'=""
"RTN","RORUTL05",79,0)
 . . . S RORINFO=RORINFO+1
"RTN","RORUTL05",80,0)
 . . . S RORINFO(RORINFO)="  ACK timeout:    "_TMP
"RTN","RORUTL05",81,0)
 . ;--- Send an alert to the coordinators
"RTN","RORUTL05",82,0)
 . D ALERT^RORUTL01(REGNAME,-67,,,,$S(AWD:"more than "_AWD,1:1))
"RTN","RORUTL05",83,0)
 ;---
"RTN","RORUTL05",84,0)
 I $D(RORINFO)>1  D  D LOG^RORLOG(4,TMP,,.RORINFO)
"RTN","RORUTL05",85,0)
 . S TMP="Expired 'Awaiting Acknowledgement' flag has been cleared."
"RTN","RORUTL05",86,0)
 Q 0
"RTN","RORUTL05",87,0)
 ;
"RTN","RORUTL05",88,0)
 ;***** CLEARS THE FIELDS OF THE RECORDS FOUND BY NAME
"RTN","RORUTL05",89,0)
 ;
"RTN","RORUTL05",90,0)
 ; FILE          File number
"RTN","RORUTL05",91,0)
 ; [IENS]        IENS of the subfile
"RTN","RORUTL05",92,0)
 ; NAME          Name of the record (value of the .01 field)
"RTN","RORUTL05",93,0)
 ; FIELDS        List of field numbers separated by semicolons
"RTN","RORUTL05",94,0)
 ;
"RTN","RORUTL05",95,0)
 ; Return Values:
"RTN","RORUTL05",96,0)
 ;       <0  Error code
"RTN","RORUTL05",97,0)
 ;        0  Ok
"RTN","RORUTL05",98,0)
 ;
"RTN","RORUTL05",99,0)
CLRFLDS(FILE,IENS,NAME,FIELDS) ;
"RTN","RORUTL05",100,0)
 N FLD,I,IEN,IENS1,IS,RC,RORBUF,RORFDA,RORMSG
"RTN","RORUTL05",101,0)
 ;--- Find the record(s)
"RTN","RORUTL05",102,0)
 D FIND^DIC(FILE,$G(IENS),"@","X",NAME,,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL05",103,0)
 S RC=$$DBS^RORERR("RORMSG",-9,"CLRFLDS^RORUTL05",,FILE)  Q:RC<0 RC
"RTN","RORUTL05",104,0)
 S:$G(IENS)="" IENS=","  S FIELDS=$TR(FIELDS," ")
"RTN","RORUTL05",105,0)
 ;--- Delete the record(s)
"RTN","RORUTL05",106,0)
 S IS="",RC=0
"RTN","RORUTL05",107,0)
 F  S IS=$O(RORBUF("DILIST",2,IS))  Q:IS=""  D  Q:RC<0
"RTN","RORUTL05",108,0)
 . S IEN=RORBUF("DILIST",2,IS)  Q:IEN'>0
"RTN","RORUTL05",109,0)
 . S IENS1=IEN_IENS
"RTN","RORUTL05",110,0)
 . F I=1:1  S FLD=$P(FIELDS,";",I)  Q:FLD'>0  D
"RTN","RORUTL05",111,0)
 . . S RORFDA(FILE,IENS1,+FLD)="@"
"RTN","RORUTL05",112,0)
 . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL05",113,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,"CLRFLDS^RORUTL05",,FILE,IENS1)
"RTN","RORUTL05",114,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORUTL05",115,0)
 ;
"RTN","RORUTL05",116,0)
 ;***** RETURNS THE END DATE FOR THE EVENT PURGE
"RTN","RORUTL05",117,0)
EPDATE() ;
"RTN","RORUTL05",118,0)
 N DATE,IR,RC,RORBUF,RORMSG,TMP
"RTN","RORUTL05",119,0)
 D LIST^DIC(798.1,,"@;1I;2I",,,,,"B",,,"RORBUF","RORMSG")
"RTN","RORUTL05",120,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,"EPDATE^RORUTL05",,798.1)
"RTN","RORUTL05",121,0)
 ;--- Get the oldest date of registry updates
"RTN","RORUTL05",122,0)
 S IR="",DATE=$$DT^XLFDT
"RTN","RORUTL05",123,0)
 F  S IR=$O(RORBUF("DILIST","ID",IR))  Q:IR=""  D
"RTN","RORUTL05",124,0)
 . S TMP=$G(RORBUF("DILIST","ID",IR,1)) ; REGISTRY UPDATED UNTIL
"RTN","RORUTL05",125,0)
 . I TMP>0  S:TMP<DATE DATE=TMP
"RTN","RORUTL05",126,0)
 . ;S TMP=$G(RORBUF("DILIST","ID",IR,2)) ; DATA EXTRACTED UNTIL
"RTN","RORUTL05",127,0)
 . ;I TMP>0  S:TMP<DATE DATE=TMP
"RTN","RORUTL05",128,0)
 ;--- Subtract additional 14 days (just in case)
"RTN","RORUTL05",129,0)
 S DATE=$$FMADD^XLFDT(DATE\1,-14)
"RTN","RORUTL05",130,0)
 ;--- No more than 60 days in the past
"RTN","RORUTL05",131,0)
 S TMP=$$FMADD^XLFDT($$DT^XLFDT,-60)
"RTN","RORUTL05",132,0)
 Q $S(DATE>TMP:DATE,1:TMP)
"RTN","RORUTL05",133,0)
 ;
"RTN","RORUTL05",134,0)
 ;***** MARKS THE REGISTRY RECORDS FOR RESENDING THE LOCAL DATA
"RTN","RORUTL05",135,0)
 ;
"RTN","RORUTL05",136,0)
 ; .REGLST       Reference to a local array containing registry names 
"RTN","RORUTL05",137,0)
 ;               as subscripts and optional registry IENs as values
"RTN","RORUTL05",138,0)
 ; WD            Number of days to wait before marking the records
"RTN","RORUTL05",139,0)
 ;               for resending the local registry data
"RTN","RORUTL05",140,0)
 ;
"RTN","RORUTL05",141,0)
 ; Return Values:
"RTN","RORUTL05",142,0)
 ;       <0  Error code
"RTN","RORUTL05",143,0)
 ;        0  Ok
"RTN","RORUTL05",144,0)
 ;
"RTN","RORUTL05",145,0)
REMARK(REGLST,WD) ;
"RTN","RORUTL05",146,0)
 N RORERRDL      ; Default error location
"RTN","RORUTL05",147,0)
 ;
"RTN","RORUTL05",148,0)
 N DATE,IEN,IENS,REGIEN,REGNAME,ROOT,RORFDA,RORMSG,TMP
"RTN","RORUTL05",149,0)
 D DFLTLOC^RORERR("REMARK^RORUTL05")
"RTN","RORUTL05",150,0)
 S ROOT=$$ROOT^DILFD(798,,1)
"RTN","RORUTL05",151,0)
 S DATE=$$FMADD^XLFDT($$DT^XLFDT,-WD)
"RTN","RORUTL05",152,0)
 ;--- Process the registries from the list
"RTN","RORUTL05",153,0)
 S REGNAME=""
"RTN","RORUTL05",154,0)
 F  S REGNAME=$O(REGLST(REGNAME))  Q:REGNAME=""  D
"RTN","RORUTL05",155,0)
 . S REGIEN=+REGLST(REGNAME)
"RTN","RORUTL05",156,0)
 . I REGIEN'>0  S REGIEN=$$REGIEN^RORUTL02(REGNAME)  Q:REGIEN'>0
"RTN","RORUTL05",157,0)
 . S IENS=REGIEN_","
"RTN","RORUTL05",158,0)
 . ;--- Get the registry parameters
"RTN","RORUTL05",159,0)
 . D GETS^DIQ(798.1,IENS,"21.04;21.05","I","RORFDA","RORMSG")
"RTN","RORUTL05",160,0)
 . I $G(DIERR)  S TMP=$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)  Q
"RTN","RORUTL05",161,0)
 . ;--- Local data has been resent already
"RTN","RORUTL05",162,0)
 . Q:$G(RORFDA(798.1,IENS,21.04,"I"))
"RTN","RORUTL05",163,0)
 . ;--- The registry has not been populated yet
"RTN","RORUTL05",164,0)
 . Q:'$G(RORFDA(798.1,IENS,21.05,"I"))
"RTN","RORUTL05",165,0)
 . ;--- It is too early for resending the local data
"RTN","RORUTL05",166,0)
 . Q:RORFDA(798.1,IENS,21.05,"I")>DATE
"RTN","RORUTL05",167,0)
 . K RORFDA,RORMSG
"RTN","RORUTL05",168,0)
 . ;--- Mark registry records as modified
"RTN","RORUTL05",169,0)
 . S (IEN,RC)=0
"RTN","RORUTL05",170,0)
 . F  S IEN=$O(@ROOT@("AC",REGIEN,IEN))  Q:'IEN  D  Q:RC<0
"RTN","RORUTL05",171,0)
 . . S IENS=IEN_","
"RTN","RORUTL05",172,0)
 . . S RORFDA(798,IENS,4)=1  ; UPDATE DEMOGRAPHICS
"RTN","RORUTL05",173,0)
 . . S RORFDA(798,IENS,5)=1  ; UPDATE LOCAL REGISTRY DATA
"RTN","RORUTL05",174,0)
 . . D FILE^DIE(,"RORFDA","RORMSG")
"RTN","RORUTL05",175,0)
 . . I $G(DIERR)  S RC=$$DBS^RORERR("RORMSG",-9,,,798,IENS)  Q
"RTN","RORUTL05",176,0)
 . Q:RC<0
"RTN","RORUTL05",177,0)
 . ;--- Update registry parameters
"RTN","RORUTL05",178,0)
 . S IENS=REGIEN_","
"RTN","RORUTL05",179,0)
 . S RORFDA(798.1,IENS,21.04)=$$NOW^XLFDT
"RTN","RORUTL05",180,0)
 . D FILE^DIE("K","RORFDA","RORMSG")
"RTN","RORUTL05",181,0)
 . I $G(DIERR)  S TMP=$$DBS^RORERR("RORMSG",-9,,,798.1,IENS)  Q
"RTN","RORUTL05",182,0)
 . ;--- Record the message
"RTN","RORUTL05",183,0)
 . S TMP="Local registry and demographic data will be resent to AAC"
"RTN","RORUTL05",184,0)
 . D LOG^RORLOG(2,TMP,,"Registry Name: "_REGNAME)
"RTN","RORUTL05",185,0)
 Q 0
"RTN","RORUTL05",186,0)
 ;
"RTN","RORUTL05",187,0)
 ;***** REBUILDS THE "ACL" CROSS-REFERENCE (USER ACCESS)
"RTN","RORUTL05",188,0)
 ;
"RTN","RORUTL05",189,0)
 ; Return Values:
"RTN","RORUTL05",190,0)
 ;       <0  Error code
"RTN","RORUTL05",191,0)
 ;        0  Ok
"RTN","RORUTL05",192,0)
 ;
"RTN","RORUTL05",193,0)
RNDXACL() ;
"RTN","RORUTL05",194,0)
 N DA,DIK,REGIEN,ROOT
"RTN","RORUTL05",195,0)
 S ROOT=$$ROOT^DILFD(798.1,,1)  K @ROOT@("ACL")
"RTN","RORUTL05",196,0)
 S REGIEN=0
"RTN","RORUTL05",197,0)
 F  S REGIEN=$O(@ROOT@(REGIEN))  Q:'REGIEN  D
"RTN","RORUTL05",198,0)
 . S DIK=$$ROOT^DILFD(798.118,","_REGIEN_","),DIK(1)=".01^ACL"
"RTN","RORUTL05",199,0)
 . S DA(1)=REGIEN  D ENALL^DIK
"RTN","RORUTL05",200,0)
 Q 0
"UP",798.1,798.118,-1)
798.1^18
"UP",798.1,798.118,0)
798.118
"VER")
8.0^22
"^DD",798,798,0)
FIELD^^11^20
"^DD",798,798,0,"DDA")
N
"^DD",798,798,0,"DT")
3011120
"^DD",798,798,0,"IX","AC",798,.02)

"^DD",798,798,0,"IX","AD",798,1)

"^DD",798,798,0,"IX","AM",798,10)

"^DD",798,798,0,"IX","B",798,.01)

"^DD",798,798,0,"NM","ROR LOCAL REGISTRY")

"^DD",798,798,0,"PT",798.53,.01)

"^DD",798,798,0,"SCR")
I $G(DUZ),$S($G(DUZ(0))["@":1,1:$D(^ROR(798.1,"ACL",DUZ,+$P($G(^(0)),U,2)))>1)
"^DD",798,798,0,"VRPK")
ROR
"^DD",798,798,.01,0)
PATIENT NAME^RP798.4^RORDATA(798.4,^0;1^Q
"^DD",798,798,.01,1,0)
^.1
"^DD",798,798,.01,1,1,0)
798^B
"^DD",798,798,.01,1,1,1)
S ^RORDATA(798,"B",$E(X,1,30),DA)=""
"^DD",798,798,.01,1,1,2)
K ^RORDATA(798,"B",$E(X,1,30),DA)
"^DD",798,798,.01,1,1,3)
Do not delete!
"^DD",798,798,.01,1,1,"%D",0)
^^2^2^3011005^
"^DD",798,798,.01,1,1,"%D",1,0)
Patient records in all defined registries can be
"^DD",798,798,.01,1,1,"%D",2,0)
found using this cross-reference.
"^DD",798,798,.01,3)

"^DD",798,798,.01,8.5)
@
"^DD",798,798,.01,9)
@
"^DD",798,798,.01,20,0)
^.3LA^1^1
"^DD",798,798,.01,20,1,0)
ENTRY
"^DD",798,798,.01,21,0)
^.001^7^7^3020816^^
"^DD",798,798,.01,21,1,0)
The PATIENT NAME field identifies a patient in the
"^DD",798,798,.01,21,2,0)
registry. You can select a patient either from the
"^DD",798,798,.01,21,3,0)
local registry or the ROR PATIENT file, or you can
"^DD",798,798,.01,21,4,0)
add a new patient from the PATIENT file.
"^DD",798,798,.01,21,5,0)
 
"^DD",798,798,.01,21,6,0)
You can select records only of those registries
"^DD",798,798,.01,21,7,0)
that you have appropriate security key(s) for.
"^DD",798,798,.01,23,0)
^.001^6^6^3020816^^^^
"^DD",798,798,.01,23,1,0)
An internal value of this field is the patient IEN in
"^DD",798,798,.01,23,2,0)
the PATIENT file (#2) because records in the ROR
"^DD",798,798,.01,23,3,0)
PATIENT file (#798.4) have the same internal entry
"^DD",798,798,.01,23,4,0)
numbers as corresponding records in the PATIENT file.
"^DD",798,798,.01,23,5,0)
Patient records in all registries can be found by
"^DD",798,798,.01,23,6,0)
traditional "B" cross-reference.
"^DD",798,798,.01,"DT")
3010612
"^DD",798,798,.02,0)
REGISTRY^RP798.1'I^ROR(798.1,^0;2^Q
"^DD",798,798,.02,1,0)
^.1
"^DD",798,798,.02,1,1,0)
798^AC
"^DD",798,798,.02,1,1,1)
S ^RORDATA(798,"AC",$E(X,1,30),DA)=""
"^DD",798,798,.02,1,1,2)
K ^RORDATA(798,"AC",$E(X,1,30),DA)
"^DD",798,798,.02,1,1,3)
Do not delete!
"^DD",798,798,.02,1,1,"%D",0)
^^2^2^3011005^
"^DD",798,798,.02,1,1,"%D",1,0)
This cross-reference is used to link all records
"^DD",798,798,.02,1,1,"%D",2,0)
of the registry together.
"^DD",798,798,.02,1,1,"DT")
3000406
"^DD",798,798,.02,1,2,0)
^^TRIGGER^798^1
"^DD",798,798,.02,1,2,1)
X ^DD(798,.02,1,2,1.3) I X S X=DIV S Y(1)=$S($D(^RORDATA(798,D0,0)):^(0),1:"") S X=$P(Y(1),U,3),X=X S DIU=X K Y S X=DIV S %=$P($H,",",2),X=DT_(%\60#60/100+(%\3600)+(%#60/10000)/100) X ^DD(798,.02,1,2,1.4)
"^DD",798,798,.02,1,2,1.3)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(0)=X S Y(1)=$S($D(^RORDATA(798,D0,0)):^(0),1:"") S X='$P(Y(1),U,3)
"^DD",798,798,.02,1,2,1.4)
S DIH=$G(^RORDATA(798,DIV(0),0)),DIV=X S $P(^(0),U,3)=DIV,DIH=798,DIG=1 D ^DICR
"^DD",798,798,.02,1,2,2)
Q
"^DD",798,798,.02,1,2,3)
Do not delete!
"^DD",798,798,.02,1,2,"%D",0)
^^2^2^3020402^
"^DD",798,798,.02,1,2,"%D",1,0)
This trigger populates the DATE ENTERED field 
"^DD",798,798,.02,1,2,"%D",2,0)
when the patient is added to the registry.
"^DD",798,798,.02,1,2,"CREATE CONDITION")
'DATE ENTERED
"^DD",798,798,.02,1,2,"CREATE VALUE")
NOW
"^DD",798,798,.02,1,2,"DELETE VALUE")
NO EFFECT
"^DD",798,798,.02,1,2,"DT")
3011119
"^DD",798,798,.02,1,2,"FIELD")
DATE
"^DD",798,798,.02,8.5)
@
"^DD",798,798,.02,9)
@
"^DD",798,798,.02,20,0)
^.3LA^1^1
"^DD",798,798,.02,20,1,0)
ENTRY
"^DD",798,798,.02,21,0)
^.001^2^2^3020816^^
"^DD",798,798,.02,21,1,0)
The REGISTRY field identifies the registry that 
"^DD",798,798,.02,21,2,0)
the record belongs to.
"^DD",798,798,.02,23,0)
^.001^2^2^3020816^^
"^DD",798,798,.02,23,1,0)
Traditional cross-reference "AC" is used to link all 
"^DD",798,798,.02,23,2,0)
records of the registry together.
"^DD",798,798,.02,"DT")
3011119
"^DD",798,798,1,0)
DATE ENTERED^DI^^0;3^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798,1,1,0)
^.1
"^DD",798,798,1,1,1,0)
798^AD
"^DD",798,798,1,1,1,1)
S ^RORDATA(798,"AD",$E(X,1,30),DA)=""
"^DD",798,798,1,1,1,2)
K ^RORDATA(798,"AD",$E(X,1,30),DA)
"^DD",798,798,1,1,1,3)
Do not delete!
"^DD",798,798,1,1,1,"%D",0)
^^2^2^3011005^
"^DD",798,798,1,1,1,"%D",1,0)
This cross-reference can be used to search for
"^DD",798,798,1,1,1,"%D",2,0)
recently added patients.  
"^DD",798,798,1,1,1,"DT")
3010709
"^DD",798,798,1,5,1,0)
798^.02^2
"^DD",798,798,1,8.5)
@
"^DD",798,798,1,9)
@
"^DD",798,798,1,20,0)
^.3LA^1^1
"^DD",798,798,1,20,1,0)
ENTRY
"^DD",798,798,1,21,0)
^.001^3^3^3020816^^
"^DD",798,798,1,21,1,0)
The DATE ENTERED field is automatically populated
"^DD",798,798,1,21,2,0)
by the trigger associated with the REGISTRY field
"^DD",798,798,1,21,3,0)
when the patient is added to the registry.
"^DD",798,798,1,"DT")
3011115
"^DD",798,798,2,0)
INACTIVATION DATE^DX^^0;4^S %DT="ESTX" K Y S:$G(DIUTIL)'="VERIFY FIELDS" Y(9.2)=$P($G(^RORDATA(798,DA,2)),U,2),Y(7)=$P($G(^(0)),U,11),Y=$S(Y(9.2)>Y(7):Y(9.2),1:Y(7)) S:$G(Y)>0 %DT(0)=Y D ^%DT S X=Y K:Y<1 X K %DT,Y
"^DD",798,798,2,1,0)
^.1^^0
"^DD",798,798,2,3)
Enter the inactivation date for the patient.
"^DD",798,798,2,4)

"^DD",798,798,2,20,0)
^.3LA^1^1
"^DD",798,798,2,20,1,0)
STATE
"^DD",798,798,2,21,0)
^.001^8^8^3020816^^
"^DD",798,798,2,21,1,0)
When present the INACTIVATION DATE field contains
"^DD",798,798,2,21,2,0)
the latest inactivation date/time of the patient
"^DD",798,798,2,21,3,0)
in the registry.
"^DD",798,798,2,21,4,0)
 
"^DD",798,798,2,21,5,0)
The new inactivation date could be in the future
"^DD",798,798,2,21,6,0)
or in the past but it should be not earlier than
"^DD",798,798,2,21,7,0)
the date of the last data extraction or the date
"^DD",798,798,2,21,8,0)
of re-activation (if present).
"^DD",798,798,2,23,0)
^.001^5^5^3020816^^
"^DD",798,798,2,23,1,0)
Patient's record is active if there is no inactivation 
"^DD",798,798,2,23,2,0)
date. Otherwise, values of both the INACTIVATION DATE
"^DD",798,798,2,23,3,0)
and REACTIVATION DATE fields should be analyzed along
"^DD",798,798,2,23,4,0)
with the current date/time. See description of the 
"^DD",798,798,2,23,5,0)
ACTIVE computed field (#798, 8) for further details.
"^DD",798,798,2,"DT")
3011120
"^DD",798,798,2.1,0)
INACTIVATED BY^P200'^VA(200,^0;10^Q
"^DD",798,798,2.1,21,0)
^^3^3^3020402^
"^DD",798,798,2.1,21,1,0)
The INACTIVATED BY field identifies a person who
"^DD",798,798,2.1,21,2,0)
has inactivated a patient record in the registry
"^DD",798,798,2.1,21,3,0)
for the last time.
"^DD",798,798,2.1,23,0)
^^4^4^3020402^
"^DD",798,798,2.1,23,1,0)
This field is automatically populated by the
"^DD",798,798,2.1,23,2,0)
inactivation remote procedure. If the patient record
"^DD",798,798,2.1,23,3,0)
has been automatically inactivated because of patient
"^DD",798,798,2.1,23,4,0)
death, this field will have no value.
"^DD",798,798,2.1,"DT")
3000504
"^DD",798,798,2.2,0)
REASON FOR INACTIVATION^*P799.1'X^ROR(799.1,^0;13^S Y=$P($G(^RORDATA(798,DA,0)),U,2),DIC("S")="S D=$G(^(0)) I $P(D,U,2)=1"_$S(Y>0:",$P(D,U,3)="_Y,1:"") D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",798,798,2.2,3)

"^DD",798,798,2.2,12)
Only reasons for inactivation can be selected.
"^DD",798,798,2.2,12.1)
S DIC("S")="I $P(^(0),U,2)=1"
"^DD",798,798,2.2,21,0)
^.001^3^3^3011120^^^^
"^DD",798,798,2.2,21,1,0)
Value of this field indicates a reason for the 
"^DD",798,798,2.2,21,2,0)
latest manual inactivation of the patient record
"^DD",798,798,2.2,21,3,0)
in the registry.
"^DD",798,798,2.2,23,0)
^.001^5^5^3011120^^^^
"^DD",798,798,2.2,23,1,0)
This field is only ever populated via the GUI manual
"^DD",798,798,2.2,23,2,0)
entry option.
"^DD",798,798,2.2,23,3,0)
 
"^DD",798,798,2.2,23,4,0)
If a patient was inactivated because of death, this 
"^DD",798,798,2.2,23,5,0)
field MUST be empty!
"^DD",798,798,2.2,"DT")
3011120
"^DD",798,798,3,0)
NEW PATIENT^S^0:NO;1:AUTO;2:MANUAL;3:REACTIVATED;^0;5^Q
"^DD",798,798,3,20,0)
^.3LA^1^1
"^DD",798,798,3,20,1,0)
STATE
"^DD",798,798,3,21,0)
^.001^2^2^3020816^^
"^DD",798,798,3,21,1,0)
The NEW PATIENT field describes how the patient 
"^DD",798,798,3,21,2,0)
has been added/updated in the registry.
"^DD",798,798,3,23,0)
^.001^7^7^3020816^^
"^DD",798,798,3,23,1,0)
Usually, this field contains 0 or no value at all. The
"^DD",798,798,3,23,2,0)
field is automatically populated by the registry
"^DD",798,798,3,23,3,0)
update, patient reactivation and GUI manual entry
"^DD",798,798,3,23,4,0)
processing.
"^DD",798,798,3,23,5,0)
 
"^DD",798,798,3,23,6,0)
After acknowledgement of the successful processing of
"^DD",798,798,3,23,7,0)
transmitted data the value of this field is deleted.
"^DD",798,798,3,"DT")
3000426
"^DD",798,798,3.1,0)
SELECTION RULE^798.01P^^1;0
"^DD",798,798,3.1,20,0)
^.3LA^1^1
"^DD",798,798,3.1,20,1,0)
ENTRY
"^DD",798,798,3.1,21,0)
^.001^3^3^3020816^^
"^DD",798,798,3.1,21,1,0)
The SELECTION RULE multiple contains a list of
"^DD",798,798,3.1,21,2,0)
selection rules that the patient passed when added
"^DD",798,798,3.1,21,3,0)
to the registry.
"^DD",798,798,3.1,23,0)
^.001^2^2^3020816^^
"^DD",798,798,3.1,23,1,0)
The list is automatically populated by the registry
"^DD",798,798,3.1,23,2,0)
update and the GUI manual patient entry processing.
"^DD",798,798,3.2,0)
SUPPORTING EVIDENCE^*P799.1'X^ROR(799.1,^0;14^S Y=$P($G(^RORDATA(798,DA,0)),U,2),DIC("S")="S D=$G(^(0)) I $P(D,U,2)=2"_$S(Y>0:",$P(D,U,3)="_Y,1:"") D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",798,798,3.2,3)

"^DD",798,798,3.2,12)
Only supporting evidences can be selected.
"^DD",798,798,3.2,12.1)
S DIC("S")="I $P(^(0),U,2)=2"
"^DD",798,798,3.2,20,0)
^.3LA^1^1
"^DD",798,798,3.2,20,1,0)
ENTRY
"^DD",798,798,3.2,21,0)
^.001^2^2^3020816^^^^
"^DD",798,798,3.2,21,1,0)
This field indicates a reason for manual addition
"^DD",798,798,3.2,21,2,0)
of the patient to the registry.
"^DD",798,798,3.2,23,0)
^.001^2^2^3020816^^
"^DD",798,798,3.2,23,1,0)
The HEPC SUPPORT EVIDENCE field is only ever populated
"^DD",798,798,3.2,23,2,0)
via the GUI manual entry option.
"^DD",798,798,3.2,"DT")
3011009
"^DD",798,798,4,0)
UPDATE DEMOGRAPHICS^S^0:NO;1:YES;^0;6^Q
"^DD",798,798,4,20,0)
^.3LA^1^1
"^DD",798,798,4,20,1,0)
STATE
"^DD",798,798,4,21,0)
^.001^3^3^3020816^^
"^DD",798,798,4,21,1,0)
Usually, you should not edit this field. Set a 
"^DD",798,798,4,21,2,0)
value of this field to "Yes" if you want the
"^DD",798,798,4,21,3,0)
patient demographic data to be sent to AAC.
"^DD",798,798,4,23,0)
^.001^12^12^3020816^^
"^DD",798,798,4,23,1,0)
During the registry update, demographic fields of each
"^DD",798,798,4,23,2,0)
record of the ROR PATIENT file are compared with
"^DD",798,798,4,23,3,0)
corresponding fields of the PATIENT file.
"^DD",798,798,4,23,4,0)
 
"^DD",798,798,4,23,5,0)
If some of the fields have different values, an 
"^DD",798,798,4,23,6,0)
internal value of 1 is assigned to the UPDATE
"^DD",798,798,4,23,7,0)
DEMOGRAPHICS field of all active patient records in 
"^DD",798,798,4,23,8,0)
local registries. As a result, demographic data is
"^DD",798,798,4,23,9,0)
transmitted to the national registries.
"^DD",798,798,4,23,10,0)
 
"^DD",798,798,4,23,11,0)
After acknowledgement of the successful processing of
"^DD",798,798,4,23,12,0)
transmitted data the value of this field is deleted.
"^DD",798,798,4,"DT")
3000323
"^DD",798,798,5,0)
UPDATE LOCAL REGISTRY DATA^S^0:NO;1:YES;^0;7^Q
"^DD",798,798,5,20,0)
^.3LA^1^1
"^DD",798,798,5,20,1,0)
STATE
"^DD",798,798,5,21,0)
^.001^4^4^3020816^^^
"^DD",798,798,5,21,1,0)
Usually, you should not edit this field. Set a 
"^DD",798,798,5,21,2,0)
value of this field to "Yes" if you have changed
"^DD",798,798,5,21,3,0)
any local registry data of the patient and want 
"^DD",798,798,5,21,4,0)
this data to be sent to AAC.
"^DD",798,798,5,23,0)
^.001^8^8^3020816^^^
"^DD",798,798,5,23,1,0)
Any changes of local registry data result in assignment
"^DD",798,798,5,23,2,0)
of 1 as an internal value of the UPDATE LOCAL REGISTRY
"^DD",798,798,5,23,3,0)
DATA field (by registry update process or remote
"^DD",798,798,5,23,4,0)
procedures). This is an indication to transmit local
"^DD",798,798,5,23,5,0)
data to the national registry.
"^DD",798,798,5,23,6,0)
 
"^DD",798,798,5,23,7,0)
After acknowledgement of the successful processing of
"^DD",798,798,5,23,8,0)
transmitted data the value of this field is deleted.
"^DD",798,798,5,"DT")
3000327
"^DD",798,798,6,0)
INVESTIGATIONAL DRUGS^S^0:NO;1:YES;^0;8^Q
"^DD",798,798,6,21,0)
^^3^3^3020402^
"^DD",798,798,6,21,1,0)
Set this field to "Yes" if any investigational 
"^DD",798,798,6,21,2,0)
drugs related to the registry are/were used in
"^DD",798,798,6,21,3,0)
the treatment of the patient.
"^DD",798,798,6,23,0)
^^6^6^3020402^
"^DD",798,798,6,23,1,0)
The internal value of 1 in the INVESTIGATIONAL DRUGS
"^DD",798,798,6,23,2,0)
field indicates that these drugs are used in the
"^DD",798,798,6,23,3,0)
treatment of the patient.
"^DD",798,798,6,23,4,0)
 
"^DD",798,798,6,23,5,0)
Value of this field is controlled by a user (via
"^DD",798,798,6,23,6,0)
the corresponding check-box in the GUI).
"^DD",798,798,6,"DT")
3000327
"^DD",798,798,6.1,0)
MEDICATION IN PROFILE^S^0:NO;1:YES;^0;9^Q
"^DD",798,798,6.1,21,0)
^^3^3^3020402^
"^DD",798,798,6.1,21,1,0)
Enter "Yes" if the drugs that the patient is
"^DD",798,798,6.1,21,2,0)
currently taking are in the medication profile
"^DD",798,798,6.1,21,3,0)
that exists within VistA or CPRS.
"^DD",798,798,6.1,23,0)
^.001^2^2^3020402^^^
"^DD",798,798,6.1,23,1,0)
Value of this field is controlled by a user (via
"^DD",798,798,6.1,23,2,0)
the corresponding check-box in the GUI).
"^DD",798,798,6.1,"DT")
3000327
"^DD",798,798,7,0)
REACTIVATION DATE^DX^^0;11^S %DT="ESTX" K Y S:$G(DIUTIL)'="VERIFY FIELDS" Y(9.2)=$P($G(^RORDATA(798,DA,2)),U,2),Y(2)=$P($G(^(0)),U,4),Y=$S(Y(9.2)>Y(2):Y(9.2),1:Y(2)) S:$G(Y)>0 %DT(0)=Y D ^%DT S X=Y K:(Y<1)!(Y>$$NOW^XLFDT) X K %DT,Y
"^DD",798,798,7,3)
Enter the reactivation date for the patient.
"^DD",798,798,7,4)

"^DD",798,798,7,20,0)
^.3LA^1^1
"^DD",798,798,7,20,1,0)
STATE
"^DD",798,798,7,21,0)
^.001^7^7^3020816^^
"^DD",798,798,7,21,1,0)
The REACTIVATION DATE field contains a date/time
"^DD",798,798,7,21,2,0)
of the latest reactivation of the patient in the
"^DD",798,798,7,21,3,0)
registry.
"^DD",798,798,7,21,4,0)
 
"^DD",798,798,7,21,5,0)
The new reactivation date cannot be earlier than 
"^DD",798,798,7,21,6,0)
the date of the latest data extract or the date of
"^DD",798,798,7,21,7,0)
inactivation. You cannot enter a future date.
"^DD",798,798,7,23,0)
^.001^5^5^3020816^^
"^DD",798,798,7,23,1,0)
You must evaluate both REACTIVATION DATE and 
"^DD",798,798,7,23,2,0)
INACTIVATION DATE fields along with the current 
"^DD",798,798,7,23,3,0)
date/time to determine whether the patient record is
"^DD",798,798,7,23,4,0)
active or not. See the description of the ACTIVE
"^DD",798,798,7,23,5,0)
computed field (#798, 8) for further details.
"^DD",798,798,7,"DT")
3011011
"^DD",798,798,7.1,0)
REACTIVATED BY^P200'^VA(200,^0;12^Q
"^DD",798,798,7.1,21,0)
^^2^2^3020402^
"^DD",798,798,7.1,21,1,0)
The REACTIVATED BY field identifies a person who
"^DD",798,798,7.1,21,2,0)
last re-activated the patient.
"^DD",798,798,7.1,23,0)
^.001^2^2^3020402^^
"^DD",798,798,7.1,23,1,0)
This field is automatically populated by the 
"^DD",798,798,7.1,23,2,0)
re-activation processing within the GUI.
"^DD",798,798,7.1,"DT")
3000504
"^DD",798,798,8,0)
ACTIVE^CJ1,0^^ ; ^S Y(0)=$G(^RORDATA(798,D0,0)),X=$$ACTIVE^RORDD($P(Y(0),U,4),$P(Y(0),U,11))
"^DD",798,798,8,9)
^
"^DD",798,798,8,9.01)

"^DD",798,798,8,9.1)
S Y(0)=$G(^RORDATA(798,D0,0)),X=$$ACTIVE^RORDD($P(Y(0),U,4),$P(Y(0),U,11))
"^DD",798,798,8,20,0)
^.3LA^1^1
"^DD",798,798,8,20,1,0)
STATE
"^DD",798,798,8,21,0)
^.001^3^3^3020816^^^^
"^DD",798,798,8,21,1,0)
This is a computed field that indicates the 
"^DD",798,798,8,21,2,0)
current status of the patient in the local
"^DD",798,798,8,21,3,0)
registry.
"^DD",798,798,8,23,0)
^.001^8^8^3020816^^^
"^DD",798,798,8,23,1,0)
Patient is active if there is no inactivation date. 
"^DD",798,798,8,23,2,0)
Otherwise, the patient is active only if:
"^DD",798,798,8,23,3,0)
 
"^DD",798,798,8,23,4,0)
 (INACTIVATION DATE > NOW) or 
"^DD",798,798,8,23,5,0)
 (INACTIVATION DATE < REACTIVATION DATE)
"^DD",798,798,8,23,6,0)
 
"^DD",798,798,8,23,7,0)
Please, remember that REACTIVATION DATE cannot be in 
"^DD",798,798,8,23,8,0)
the future.
"^DD",798,798,8,"DT")
3011011
"^DD",798,798,9.1,0)
DATA ACKNOWLEDGED UNTIL^D^^2;1^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798,9.1,20,0)
^.3LA^1^1
"^DD",798,798,9.1,20,1,0)
STATE
"^DD",798,798,9.1,21,0)
^.001^3^3^3020816^^
"^DD",798,798,9.1,21,1,0)
The DATA ACKNOWLEDGED UNTIL field contains a date
"^DD",798,798,9.1,21,2,0)
that the patient data has been extracted until,
"^DD",798,798,9.1,21,3,0)
successfully transmitted and acknowledged.
"^DD",798,798,9.1,23,0)
^.001^7^7^3020816^^
"^DD",798,798,9.1,23,1,0)
A regular data extraction for the patient in the 
"^DD",798,798,9.1,23,2,0)
registry starts from this date.
"^DD",798,798,9.1,23,3,0)
 
"^DD",798,798,9.1,23,4,0)
Acknowledgement processing copies the value of the
"^DD",798,798,9.1,23,5,0)
DATA EXTRACTED UNTIL field into this field upon
"^DD",798,798,9.1,23,6,0)
receiving and processing the HL7 acknowledgement from 
"^DD",798,798,9.1,23,7,0)
the AAC.
"^DD",798,798,9.1,"DT")
3010830
"^DD",798,798,9.2,0)
DATA EXTRACTED UNTIL^D^^2;2^S %DT="ETX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798,9.2,20,0)
^.3LA^1^1
"^DD",798,798,9.2,20,1,0)
STATE
"^DD",798,798,9.2,21,0)
^.001^3^3^3020816^^^
"^DD",798,798,9.2,21,1,0)
This field contains a date that registry data of 
"^DD",798,798,9.2,21,2,0)
the patient has been extracted until, transmitted
"^DD",798,798,9.2,21,3,0)
but not acknowledged yet.
"^DD",798,798,9.2,23,0)
^.001^8^8^3020816^^
"^DD",798,798,9.2,23,1,0)
The field is automatically populated by the regular
"^DD",798,798,9.2,23,2,0)
data extraction process if the data is extracted
"^DD",798,798,9.2,23,3,0)
successfully.
"^DD",798,798,9.2,23,4,0)
 
"^DD",798,798,9.2,23,5,0)
Acknowledgement processing routine copies value of this
"^DD",798,798,9.2,23,6,0)
field into the DATA ACKNOWLEDGED UNTIL field upon
"^DD",798,798,9.2,23,7,0)
receiving and processing HL7 acknowledgement from the
"^DD",798,798,9.2,23,8,0)
AAC.
"^DD",798,798,9.2,"DT")
3010830
"^DD",798,798,10,0)
MESSAGE ID^FX^^2;3^K:X[""""!($A(X)=45) X I $D(X) K:$L(X)>20!(X'?1.E1"-"1.N) X
"^DD",798,798,10,1,0)
^.1
"^DD",798,798,10,1,1,0)
798^AM
"^DD",798,798,10,1,1,1)
S ^RORDATA(798,"AM",$E(X,1,30),DA)=""
"^DD",798,798,10,1,1,2)
K ^RORDATA(798,"AM",$E(X,1,30),DA)
"^DD",798,798,10,1,1,3)
Do not delete!
"^DD",798,798,10,1,1,"%D",0)
^^3^3^3011005^
"^DD",798,798,10,1,1,"%D",1,0)
The cross-reference allows to find a patient 
"^DD",798,798,10,1,1,"%D",2,0)
record in the registry using an ID of an HL7
"^DD",798,798,10,1,1,"%D",3,0)
message sent to the national registry.
"^DD",798,798,10,1,1,"DT")
3010824
"^DD",798,798,10,3)
The unique ID of the latest HL7 message (1-20 characters).
"^DD",798,798,10,21,0)
^^8^8^3020402^
"^DD",798,798,10,21,1,0)
The MESSAGE ID field contains an identifier of 
"^DD",798,798,10,21,2,0)
the latest individual HL7 message created for this
"^DD",798,798,10,21,3,0)
registry record.
"^DD",798,798,10,21,4,0)
 
"^DD",798,798,10,21,5,0)
Value of this field should have the following
"^DD",798,798,10,21,6,0)
format: BatchID-N, where BatchID is an ID of an
"^DD",798,798,10,21,7,0)
HL7 batch message, and N is a sequential number of
"^DD",798,798,10,21,8,0)
the message in the batch.
"^DD",798,798,10,23,0)
^.001^3^3^3020402^^^
"^DD",798,798,10,23,1,0)
This field is automatically populated by the regular
"^DD",798,798,10,23,2,0)
data extraction process every time an HL7 message is
"^DD",798,798,10,23,3,0)
generated.
"^DD",798,798,10,"DT")
3011005
"^DD",798,798,11,0)
DON'T SEND^S^0:NO;1:YES;^2;4^Q
"^DD",798,798,11,21,0)
^^3^3^3020402^
"^DD",798,798,11,21,1,0)
Set this field to "Yes" if you do not want any 
"^DD",798,798,11,21,2,0)
data to be sent to the national registry for this
"^DD",798,798,11,21,3,0)
record.
"^DD",798,798,11,23,0)
^^4^4^3020402^
"^DD",798,798,11,23,1,0)
Usually, this field is populated only automatically by
"^DD",798,798,11,23,2,0)
the registry update processing if a patient is defined
"^DD",798,798,11,23,3,0)
in the PATIENT file as a "test patient" (internal value
"^DD",798,798,11,23,4,0)
of the TEST PATIENT INDICATOR field equals to 1).
"^DD",798,798,11,"DT")
3010919
"^DD",798,798.01,0)
SELECTION RULE SUB-FIELD^^1^2
"^DD",798,798.01,0,"DT")
3011009
"^DD",798,798.01,0,"IX","AD",798.01,1)

"^DD",798,798.01,0,"IX","B",798.01,.01)

"^DD",798,798.01,0,"NM","SELECTION RULE")

"^DD",798,798.01,0,"UP")
798
"^DD",798,798.01,.01,0)
SELECTION RULE^MP798.2'^ROR(798.2,^0;1^Q
"^DD",798,798.01,.01,1,0)
^.1
"^DD",798,798.01,.01,1,1,0)
798.01^B
"^DD",798,798.01,.01,1,1,1)
S ^RORDATA(798,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",798,798.01,.01,1,1,2)
K ^RORDATA(798,DA(1),1,"B",$E(X,1,30),DA)
"^DD",798,798.01,.01,1,1,3)
Do not delete!
"^DD",798,798.01,.01,21,0)
^.001^2^2^3011009^^
"^DD",798,798.01,.01,21,1,0)
This field identifies the selection rule that has 
"^DD",798,798.01,.01,21,2,0)
caused addition of the patient to the registry.
"^DD",798,798.01,.01,"DT")
3011009
"^DD",798,798.01,1,0)
DATE^D^^0;2^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798,798.01,1,1,0)
^.1
"^DD",798,798.01,1,1,1,0)
798.01^AD
"^DD",798,798.01,1,1,1,1)
S ^RORDATA(798,DA(1),1,"AD",$E(X,1,30),DA)=""
"^DD",798,798.01,1,1,1,2)
K ^RORDATA(798,DA(1),1,"AD",$E(X,1,30),DA)
"^DD",798,798.01,1,1,1,3)
Do not delete!
"^DD",798,798.01,1,1,1,"DT")
3000426
"^DD",798,798.01,1,21,0)
^^2^2^3020402^
"^DD",798,798.01,1,21,1,0)
The DATE field contains the date when the patient
"^DD",798,798.01,1,21,2,0)
passed the rule for the first time.
"^DD",798,798.01,1,"DT")
3000426
"^DD",798.1,798.1,2.4,0)
LAST IEN EXTRACTED^NJ12,0^^14;1^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.1,798.1,2.4,3)
Enter IEN of the registry record (between 0 and 999999999999).
"^DD",798.1,798.1,2.4,8.5)
@
"^DD",798.1,798.1,2.4,9)
@
"^DD",798.1,798.1,2.4,20,0)
^.3LA^^0
"^DD",798.1,798.1,2.4,21,0)
^.001^12^12^3020816^^^^
"^DD",798.1,798.1,2.4,21,1,0)
This field stores the IEN of the last record
"^DD",798.1,798.1,2.4,21,2,0)
processed by the last registry data extraction
"^DD",798.1,798.1,2.4,21,3,0)
when the size of the HL7 message had reached its
"^DD",798.1,798.1,2.4,21,4,0)
upper limit.
"^DD",798.1,798.1,2.4,21,5,0)
 
"^DD",798.1,798.1,2.4,21,6,0)
The next registry data extraction will start from
"^DD",798.1,798.1,2.4,21,7,0)
the registry record that has an IEN greater than
"^DD",798.1,798.1,2.4,21,8,0)
value of this field.
"^DD",798.1,798.1,2.4,21,9,0)
 
"^DD",798.1,798.1,2.4,21,10,0)
Usually, you should not edit this field. It is 
"^DD",798.1,798.1,2.4,21,11,0)
updated automatically by the registry data 
"^DD",798.1,798.1,2.4,21,12,0)
extraction task.
"^DD",798.1,798.1,2.4,23,0)
^.001^20^20^3020816^^^^
"^DD",798.1,798.1,2.4,23,1,0)
Usually, all new data is sent to the AAC in a single 
"^DD",798.1,798.1,2.4,23,2,0)
message and this field is empty or 0.
"^DD",798.1,798.1,2.4,23,3,0)
 
"^DD",798.1,798.1,2.4,23,4,0)
However, when big amounts of data should be sent, the
"^DD",798.1,798.1,2.4,23,5,0)
ROR software tries to throttle the data flow and even
"^DD",798.1,798.1,2.4,23,6,0)
the spike over the following days.
"^DD",798.1,798.1,2.4,23,7,0)
 
"^DD",798.1,798.1,2.4,23,8,0)
In this case, each data extraction starts from the
"^DD",798.1,798.1,2.4,23,9,0)
registry record that follows the last one processed by
"^DD",798.1,798.1,2.4,23,10,0)
the previous extraction (this field) and continues
"^DD",798.1,798.1,2.4,23,11,0)
until size of the messages reaches its maximum value
"^DD",798.1,798.1,2.4,23,12,0)
(the MAXIMUM MESSAGE SIZE field).
"^DD",798.1,798.1,2.4,23,13,0)
 
"^DD",798.1,798.1,2.4,23,14,0)
The field has the NUMERIC type instead of the POINTER
"^DD",798.1,798.1,2.4,23,15,0)
(to the ROR LOCAL REGISTRY file) to prevent possible
"^DD",798.1,798.1,2.4,23,16,0)
FileMan errors caused by records deleted from the
"^DD",798.1,798.1,2.4,23,17,0)
registry.
"^DD",798.1,798.1,2.4,23,18,0)
 
"^DD",798.1,798.1,2.4,23,19,0)
The field is used and updated by the PROCESS^ROREXT01
"^DD",798.1,798.1,2.4,23,20,0)
function.
"^DD",798.1,798.1,2.4,"DT")
3020801
"^DD",798.1,798.1,13.1,0)
MAXIMUM MESSAGE SIZE^NJ4,1^^9;2^K:+X'=X!(X>99)!(X<0)!(X?.E1"."2N.N) X
"^DD",798.1,798.1,13.1,3)
Enter maximum size (in megabytes) between 0 and 99, 1 decimal digit.
"^DD",798.1,798.1,13.1,8.5)
@
"^DD",798.1,798.1,13.1,9)
@
"^DD",798.1,798.1,13.1,20,0)
^.3LA^2^2
"^DD",798.1,798.1,13.1,20,1,0)
HL7
"^DD",798.1,798.1,13.1,20,2,0)
PARAMETERS
"^DD",798.1,798.1,13.1,21,0)
^.001^8^8^3020816^^^
"^DD",798.1,798.1,13.1,21,1,0)
This field stores the maximum size (in megabytes)
"^DD",798.1,798.1,13.1,21,2,0)
of a batch HL7 message that can be sent to Austin
"^DD",798.1,798.1,13.1,21,3,0)
Automation Center (AAC). If this field is empty or
"^DD",798.1,798.1,13.1,21,4,0)
contains 0, the size is not limited.
"^DD",798.1,798.1,13.1,21,5,0)
 
"^DD",798.1,798.1,13.1,21,6,0)
You must co-ordinate your intentions with AAC
"^DD",798.1,798.1,13.1,21,7,0)
support personnel if you are going to edit this
"^DD",798.1,798.1,13.1,21,8,0)
field.
"^DD",798.1,798.1,13.1,23,0)
^.001^8^8^3020816^^^
"^DD",798.1,798.1,13.1,23,1,0)
Actual size of an HL7 batch can be greater than the
"^DD",798.1,798.1,13.1,23,2,0)
value of this field because the software does not break
"^DD",798.1,798.1,13.1,23,3,0)
in the middle of an individual HL7 message.
"^DD",798.1,798.1,13.1,23,4,0)
 
"^DD",798.1,798.1,13.1,23,5,0)
For example, if the maximum size is 10Mb, the current
"^DD",798.1,798.1,13.1,23,6,0)
size is 9Mb and 3Mb should be sent for the patient
"^DD",798.1,798.1,13.1,23,7,0)
being processed then the actual size of the batch will
"^DD",798.1,798.1,13.1,23,8,0)
be 12Mb.
"^DD",798.1,798.1,13.1,"DT")
3020730
"^DD",798.1,798.1,18,0)
SECURITY KEY^798.118^^18;0
"^DD",798.1,798.1,18,9)
@
"^DD",798.1,798.1,18,20,0)
^.3LA^1^1
"^DD",798.1,798.1,18,20,1,0)
DEFINITION
"^DD",798.1,798.1,18,21,0)
^.001^2^2^3020816^^^^
"^DD",798.1,798.1,18,21,1,0)
This multiple stores a list of security keys 
"^DD",798.1,798.1,18,21,2,0)
associated with the registry.
"^DD",798.1,798.1,26,0)
EXCLUDE EMPLOYEES^SX^0:NO;1:YES;^0;10^Q:$$VAEDT^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,26,8.5)
@
"^DD",798.1,798.1,26,9)
@
"^DD",798.1,798.1,26,20,0)
^.3LA^1^1
"^DD",798.1,798.1,26,20,1,0)
DEFINITION
"^DD",798.1,798.1,26,21,0)
^.001^6^6^3020816^^^^
"^DD",798.1,798.1,26,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.1,26,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.1,26,21,3,0)
 
"^DD",798.1,798.1,26,21,4,0)
If this field is set to "Yes", patients who are
"^DD",798.1,798.1,26,21,5,0)
employees will not get processed by the registry
"^DD",798.1,798.1,26,21,6,0)
update or data extraction functions.
"^DD",798.1,798.1,26,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA))
"^DD",798.1,798.1,26,"DT")
3020802
"^DD",798.1,798.118,0)
SECURITY KEY SUB-FIELD^^.01^1
"^DD",798.1,798.118,0,"DT")
3020801
"^DD",798.1,798.118,0,"IX","B",798.118,.01)

"^DD",798.1,798.118,0,"NM","SECURITY KEY")

"^DD",798.1,798.118,0,"UP")
798.1
"^DD",798.1,798.118,.01,0)
SECURITY KEY^MFX^^0;1^Q:$$VAEDT^RORDD(798.1,$G(DA(1)))  K:$L(X)>27!($L(X)<3) X
"^DD",798.1,798.118,.01,1,0)
^.1
"^DD",798.1,798.118,.01,1,1,0)
798.118^B
"^DD",798.1,798.118,.01,1,1,1)
S ^ROR(798.1,DA(1),18,"B",$E(X,1,30),DA)=""
"^DD",798.1,798.118,.01,1,1,2)
K ^ROR(798.1,DA(1),18,"B",$E(X,1,30),DA)
"^DD",798.1,798.118,.01,1,1,3)
Do not delete!
"^DD",798.1,798.118,.01,1,2,0)
798.1^ACL^MUMPS
"^DD",798.1,798.118,.01,1,2,1)
D ACLSET^RORDD
"^DD",798.1,798.118,.01,1,2,2)
D ACLKILL^RORDD
"^DD",798.1,798.118,.01,1,2,3)
Do not delete!
"^DD",798.1,798.118,.01,1,2,"%D",0)
^^23^23^3020806^
"^DD",798.1,798.118,.01,1,2,"%D",1,0)
This cross-reference is used by the screening 
"^DD",798.1,798.118,.01,1,2,"%D",2,0)
logic (the "SCR" node) of the ROR LOCAL REGISTRY 
"^DD",798.1,798.118,.01,1,2,"%D",3,0)
(#798) and ROR PATIENT (#798.4) files to check 
"^DD",798.1,798.118,.01,1,2,"%D",4,0)
whether a user is allowed to access the patient
"^DD",798.1,798.118,.01,1,2,"%D",5,0)
records or no.
"^DD",798.1,798.118,.01,1,2,"%D",6,0)
 
"^DD",798.1,798.118,.01,1,2,"%D",7,0)
The cross-reference has the following structure:
"^DD",798.1,798.118,.01,1,2,"%D",8,0)
 
"^DD",798.1,798.118,.01,1,2,"%D",9,0)
  ^ROR(798.1,"ACL",RORDUZ,RegistryIEN,IEN) = ""
"^DD",798.1,798.118,.01,1,2,"%D",10,0)
 
"^DD",798.1,798.118,.01,1,2,"%D",11,0)
where RORDUZ is the value of the DUZ variable for
"^DD",798.1,798.118,.01,1,2,"%D",12,0)
the user that has access to one or more registries
"^DD",798.1,798.118,.01,1,2,"%D",13,0)
(according to the allocated security keys). IEN is
"^DD",798.1,798.118,.01,1,2,"%D",14,0)
the internal entry number of the referenced record
"^DD",798.1,798.118,.01,1,2,"%D",15,0)
of the SECURITY KEY multiple.
"^DD",798.1,798.118,.01,1,2,"%D",16,0)
 
"^DD",798.1,798.118,.01,1,2,"%D",17,0)
The cross-reference should be rebuilt after
"^DD",798.1,798.118,.01,1,2,"%D",18,0)
changes in the allocation of the security keys
"^DD",798.1,798.118,.01,1,2,"%D",19,0)
associated with any registry. Usually, this is
"^DD",798.1,798.118,.01,1,2,"%D",20,0)
done by the nightly task (the [ROR TASK] option).
"^DD",798.1,798.118,.01,1,2,"%D",21,0)
However, if you want the changes to be in effect
"^DD",798.1,798.118,.01,1,2,"%D",22,0)
immediately, you should rebuild this
"^DD",798.1,798.118,.01,1,2,"%D",23,0)
cross-reference manually.
"^DD",798.1,798.118,.01,1,2,"DT")
3020805
"^DD",798.1,798.118,.01,3)
Enter a name of security key (3-27 characters in length).
"^DD",798.1,798.118,.01,8.5)
@
"^DD",798.1,798.118,.01,9)
@
"^DD",798.1,798.118,.01,20,0)
^.3LA^^0
"^DD",798.1,798.118,.01,21,0)
^.001^5^5^3020816^^^
"^DD",798.1,798.118,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",798.1,798.118,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",798.1,798.118,.01,21,3,0)
 
"^DD",798.1,798.118,.01,21,4,0)
The SECURITY KEY field contains the name of the 
"^DD",798.1,798.118,.01,21,5,0)
security key associated with the registry.
"^DD",798.1,798.118,.01,"DEL",1,0)
I $$VADEL^RORDD(798.1,$G(DA(1)))
"^DD",798.1,798.118,.01,"DT")
3020805
"^DD",798.4,798.4,0)
FIELD^^991.01^14
"^DD",798.4,798.4,0,"DDA")
N
"^DD",798.4,798.4,0,"DT")
3020502
"^DD",798.4,798.4,0,"IX","B",798.4,.01)

"^DD",798.4,798.4,0,"IX","BS",798.4,.09)

"^DD",798.4,798.4,0,"IX","BS5",798.4,.09)

"^DD",798.4,798.4,0,"IX","SSN",798.4,.09)

"^DD",798.4,798.4,0,"NM","ROR PATIENT")

"^DD",798.4,798.4,0,"PT",798,.01)

"^DD",798.4,798.4,0,"SCR")
I $G(DUZ),$S($G(DUZ(0))["@":1,1:$D(^ROR(798.1,"ACL",DUZ))>1)
"^DD",798.4,798.4,0,"VRPK")
ROR
"^DD",798.4,798.4,.01,0)
PATIENT NAME^RP2'X^DPT(^0;1^S:$D(X) DINUM=X
"^DD",798.4,798.4,.01,1,0)
^.1
"^DD",798.4,798.4,.01,1,1,0)
798.4^B
"^DD",798.4,798.4,.01,1,1,1)
S ^RORDATA(798.4,"B",$E(X,1,30),DA)=""
"^DD",798.4,798.4,.01,1,1,2)
K ^RORDATA(798.4,"B",$E(X,1,30),DA)
"^DD",798.4,798.4,.01,1,1,3)
Do not delete!
"^DD",798.4,798.4,.01,1,1,"DT")
3000523
"^DD",798.4,798.4,.01,3)

"^DD",798.4,798.4,.01,21,0)
^^5^5^3020802^
"^DD",798.4,798.4,.01,21,1,0)
You can select an existing patient or add a new 
"^DD",798.4,798.4,.01,21,2,0)
one from the PATIENT file (#2).
"^DD",798.4,798.4,.01,21,3,0)
 
"^DD",798.4,798.4,.01,21,4,0)
You can access records of this file only if you
"^DD",798.4,798.4,.01,21,5,0)
have appropriate security key(s) for any registry.
"^DD",798.4,798.4,.01,23,0)
^.001^4^4^3020802^^^
"^DD",798.4,798.4,.01,23,1,0)
The PATIENT NAME field points to the patient record in 
"^DD",798.4,798.4,.01,23,2,0)
the PATIENT file (#2). Internal value of this field is
"^DD",798.4,798.4,.01,23,3,0)
used as internal entry number of the record ("DINUM"
"^DD",798.4,798.4,.01,23,4,0)
feature).
"^DD",798.4,798.4,.01,"DEL",1,0)
I $D(^RORDATA(798,"B",+$G(DA)))
"^DD",798.4,798.4,.01,"DT")
3000523
"^DD",798.4,798.4,.02,0)
SEX^SI^M:MALE;F:FEMALE;^0;2^Q
"^DD",798.4,798.4,.02,21,0)
^.001^1^1^3020403^^
"^DD",798.4,798.4,.02,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.02,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.02,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.02,"DT")
3011120
"^DD",798.4,798.4,.03,0)
DATE OF BIRTH^RDOI^^0;3^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",798.4,798.4,.03,2)
S Y(0)=Y S Y(0)=Y S X=Y(0) S:X X=$E(X,4,5)_"/"_$E(X,6,7)_"/"_(1700+$E(X,1,3)) S Y=X
"^DD",798.4,798.4,.03,2.1)
S Y(0)=Y S X=Y(0) S:X X=$E(X,4,5)_"/"_$E(X,6,7)_"/"_(1700+$E(X,1,3)) S Y=X
"^DD",798.4,798.4,.03,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,.03,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.03,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.03,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.03,"DT")
3011120
"^DD",798.4,798.4,.06,0)
RACE^P10'I^DIC(10,^0;4^Q
"^DD",798.4,798.4,.06,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,.06,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.06,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.06,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.06,"DT")
3011120
"^DD",798.4,798.4,.09,0)
SOCIAL SECURITY NUMBER^RFOI^^0;5^K:$L(X)>11!($L(X)<9) X
"^DD",798.4,798.4,.09,1,0)
^.1
"^DD",798.4,798.4,.09,1,1,0)
798.4^BS^MUMPS
"^DD",798.4,798.4,.09,1,1,1)
S ^RORDATA(798.4,"BS",$E(X,6,9),DA)=""
"^DD",798.4,798.4,.09,1,1,2)
K ^RORDATA(798.4,"BS",$E(X,6,9),DA)
"^DD",798.4,798.4,.09,1,1,3)
Do not delete!
"^DD",798.4,798.4,.09,1,1,"%D",0)
^.101^1^1^3011220^^
"^DD",798.4,798.4,.09,1,1,"%D",1,0)
The cross-reference on the last four digits of the SSN.
"^DD",798.4,798.4,.09,1,1,"DT")
3000426
"^DD",798.4,798.4,.09,1,2,0)
798.4^BS5^MUMPS
"^DD",798.4,798.4,.09,1,2,1)
S ^RORDATA(798.4,"BS5",$E(^DPT(DA,0),1)_$E(X,6,9),DA)=""
"^DD",798.4,798.4,.09,1,2,2)
K ^RORDATA(798.4,"BS5",$E(^DPT(DA,0),1)_$E(X,6,9),DA)
"^DD",798.4,798.4,.09,1,2,3)
Do not delete!
"^DD",798.4,798.4,.09,1,2,"%D",0)
^^3^3^3020403^
"^DD",798.4,798.4,.09,1,2,"%D",1,0)
This cross-reference contains values combined from
"^DD",798.4,798.4,.09,1,2,"%D",2,0)
the first letter of the last name and last four
"^DD",798.4,798.4,.09,1,2,"%D",3,0)
digits of the SSN.
"^DD",798.4,798.4,.09,1,2,"DT")
3011220
"^DD",798.4,798.4,.09,1,3,0)
798.4^SSN
"^DD",798.4,798.4,.09,1,3,1)
S ^RORDATA(798.4,"SSN",$E(X,1,30),DA)=""
"^DD",798.4,798.4,.09,1,3,2)
K ^RORDATA(798.4,"SSN",$E(X,1,30),DA)
"^DD",798.4,798.4,.09,1,3,3)
Do not delete!
"^DD",798.4,798.4,.09,1,3,"DT")
3011221
"^DD",798.4,798.4,.09,2)
S Y(0)=Y S:$L(Y)=11 Y=$E(Y,10,11)_$E(Y,1,9)
"^DD",798.4,798.4,.09,2.1)
S:$L(Y)=11 Y=$E(Y,10,11)_$E(Y,1,9)
"^DD",798.4,798.4,.09,3)
Answer must be 9-11 characters in length.
"^DD",798.4,798.4,.09,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,.09,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.09,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.09,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.09,"DT")
3020403
"^DD",798.4,798.4,.1112,0)
ZIP+4^FI^^0;6^K:$L(X)>9!($L(X)<5) X
"^DD",798.4,798.4,.1112,3)
Answer must be 5-9 characters in length.
"^DD",798.4,798.4,.1112,21,0)
^^1^1^3011101^
"^DD",798.4,798.4,.1112,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.1112,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.1112,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.1112,"DT")
3011120
"^DD",798.4,798.4,.301,0)
SERVICE CONNECTED?^RSI^Y:YES;N:NO;^0;7^Q
"^DD",798.4,798.4,.301,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,.301,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.301,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.301,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.301,"DT")
3011120
"^DD",798.4,798.4,.302,0)
SERVICE CONNECTED PERCENTAGE^NJ3,0I^^0;9^K:+X'=X!(X>100)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.4,798.4,.302,3)
Type a Number between 0 and 100, 0 Decimal Digits
"^DD",798.4,798.4,.302,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,.302,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.302,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.302,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.302,"DT")
3011120
"^DD",798.4,798.4,.323,0)
PERIOD OF SERVICE^P21'I^DIC(21,^0;11^Q
"^DD",798.4,798.4,.323,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,.323,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.323,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.323,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.323,"DT")
3011120
"^DD",798.4,798.4,.351,0)
DATE OF DEATH^DI^^0;8^S %DT="ET" D ^%DT S X=Y K:Y<1 X
"^DD",798.4,798.4,.351,21,0)
^.001^1^1^3020502^^^^
"^DD",798.4,798.4,.351,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.351,23,0)
^.001^1^1^3020502^^^^
"^DD",798.4,798.4,.351,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,.351,"DT")
3020502
"^DD",798.4,798.4,.3721,0)
RATED DISABILITIES (VA)^798.41P^^.372;0
"^DD",798.4,798.4,.3721,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,.3721,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,.3721,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,.3721,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,10.1,0)
OLD SSN^FI^^0;12^K:$L(X)>11!($L(X)<9) X
"^DD",798.4,798.4,10.1,3)
Answer must be 9-11 characters in length.
"^DD",798.4,798.4,10.1,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,10.1,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,10.1,23,0)
^^3^3^3011011^
"^DD",798.4,798.4,10.1,23,1,0)
This field contains the previous value of the patient 
"^DD",798.4,798.4,10.1,23,2,0)
SSN. The registry extraction process transmits both new
"^DD",798.4,798.4,10.1,23,3,0)
and old values of the SSN to the national registries.
"^DD",798.4,798.4,10.1,"DT")
3011120
"^DD",798.4,798.4,10.2,0)
OLD ICN^NJ12,0I^^0;13^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.4,798.4,10.2,3)
Type a Number between 0 and 999999999999, 0 Decimal Digits
"^DD",798.4,798.4,10.2,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,10.2,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,10.2,23,0)
^^4^4^3011011^
"^DD",798.4,798.4,10.2,23,1,0)
This field contains the previous value of the patient 
"^DD",798.4,798.4,10.2,23,2,0)
INTEGRATION CONTROL NUMBER. The registry extraction
"^DD",798.4,798.4,10.2,23,3,0)
process transmits both new and old values of the ICN to
"^DD",798.4,798.4,10.2,23,4,0)
the national registries.
"^DD",798.4,798.4,10.2,"DT")
3011120
"^DD",798.4,798.4,991.01,0)
INTEGRATION CONTROL NUMBER^NJ12,0I^^0;10^K:+X'=X!(X>999999999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.4,798.4,991.01,3)
Type a Number between 0 and 999999999999, 0 Decimal Digits
"^DD",798.4,798.4,991.01,21,0)
^^1^1^3011011^
"^DD",798.4,798.4,991.01,21,1,0)
Do not edit this field!
"^DD",798.4,798.4,991.01,23,0)
^^1^1^3020403^
"^DD",798.4,798.4,991.01,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.4,991.01,"DT")
3011120
"^DD",798.4,798.41,0)
RATED DISABILITIES (VA) SUB-FIELD^^3^3
"^DD",798.4,798.41,0,"DT")
3000426
"^DD",798.4,798.41,0,"IX","B",798.41,.01)

"^DD",798.4,798.41,0,"NM","RATED DISABILITIES (VA)")

"^DD",798.4,798.41,0,"UP")
798.4
"^DD",798.4,798.41,.01,0)
RATED DISABILITIES (VA)^MP31'I^DIC(31,^0;1^Q
"^DD",798.4,798.41,.01,1,0)
^.1
"^DD",798.4,798.41,.01,1,1,0)
798.41^B
"^DD",798.4,798.41,.01,1,1,1)
S ^RORDATA(798.4,DA(1),.372,"B",$E(X,1,30),DA)=""
"^DD",798.4,798.41,.01,1,1,2)
K ^RORDATA(798.4,DA(1),.372,"B",$E(X,1,30),DA)
"^DD",798.4,798.41,.01,1,1,3)
Do not delete!
"^DD",798.4,798.41,.01,21,0)
^^1^1^3011011^
"^DD",798.4,798.41,.01,21,1,0)
Do not edit this field!
"^DD",798.4,798.41,.01,23,0)
^^1^1^3020403^
"^DD",798.4,798.41,.01,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.41,.01,"DT")
3011120
"^DD",798.4,798.41,2,0)
DISABILITY %^RNJ3,0I^^0;2^K:+X'=X!(X>100)!(X<0)!(X?.E1"."1N.N) X
"^DD",798.4,798.41,2,3)
Type a Number between 0 and 100, 0 Decimal Digits
"^DD",798.4,798.41,2,21,0)
^^1^1^3011011^
"^DD",798.4,798.41,2,21,1,0)
Do not edit this field!
"^DD",798.4,798.41,2,23,0)
^^1^1^3020403^
"^DD",798.4,798.41,2,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.41,2,"DT")
3011120
"^DD",798.4,798.41,3,0)
SERVICE CONNECTED^SI^0:NO;1:YES;^0;3^Q
"^DD",798.4,798.41,3,21,0)
^^1^1^3011011^
"^DD",798.4,798.41,3,21,1,0)
Do not edit this field!
"^DD",798.4,798.41,3,23,0)
^^1^1^3020403^
"^DD",798.4,798.41,3,23,1,0)
See the corresponding field in the PATIENT file (#2).
"^DD",798.4,798.41,3,"DT")
3011120
"^DIC",798,798,0)
ROR LOCAL REGISTRY^798
"^DIC",798,798,0,"GL")
^RORDATA(798,
"^DIC",798,798,"%",0)
^1.005^^0
"^DIC",798,798,"%D",0)
^^26^26^3020806^
"^DIC",798,798,"%D",1,0)
The ROR LOCAL REGISTRY file contains records of
"^DIC",798,798,"%D",2,0)
local registries. Each record associates a patient
"^DIC",798,798,"%D",3,0)
with a registry and contains registry specific and
"^DIC",798,798,"%D",4,0)
additional service information (when the patient 
"^DIC",798,798,"%D",5,0)
has been added to the registry, if the patient
"^DIC",798,798,"%D",6,0)
record is active or not, etc).
"^DIC",798,798,"%D",7,0)
 
"^DIC",798,798,"%D",8,0)
Records of the file are uniquely identified by 
"^DIC",798,798,"%D",9,0)
the patient and the registry (the "A" primary key
"^DIC",798,798,"%D",10,0)
and the uniqueness index "KEY" are used for that
"^DIC",798,798,"%D",11,0)
purpose).
"^DIC",798,798,"%D",12,0)
 
"^DIC",798,798,"%D",13,0)
A permanent screen (the ^DD(798,0,"SCR") node) 
"^DIC",798,798,"%D",14,0)
restricts access to records of this file. Users
"^DIC",798,798,"%D",15,0)
can access records of only those registries that
"^DIC",798,798,"%D",16,0)
they have the security key(s) for. Users with the
"^DIC",798,798,"%D",17,0)
FileMan programmer access code can access all
"^DIC",798,798,"%D",18,0)
records of the file.
"^DIC",798,798,"%D",19,0)
 
"^DIC",798,798,"%D",20,0)
If you want the changes in the security keys
"^DIC",798,798,"%D",21,0)
allocation to have an effect immediately, you 
"^DIC",798,798,"%D",22,0)
should rebuild the "ACL" cross-reference of the
"^DIC",798,798,"%D",23,0)
.01 field of the SECURITY KEY multiple of the ROR
"^DIC",798,798,"%D",24,0)
REGISTRY PARAMETERS file (#798.1). See the
"^DIC",798,798,"%D",25,0)
description of the cross-reference for more
"^DIC",798,798,"%D",26,0)
details.
"^DIC",798,"B","ROR LOCAL REGISTRY",798)

"^DIC",798.4,798.4,0)
ROR PATIENT^798.4
"^DIC",798.4,798.4,0,"GL")
^RORDATA(798.4,
"^DIC",798.4,798.4,"%",0)
^1.005^^0
"^DIC",798.4,798.4,"%D",0)
^^34^34^3020806^
"^DIC",798.4,798.4,"%D",1,0)
The ROR PATIENT file contains patient information
"^DIC",798.4,798.4,"%D",2,0)
that is common for all local registries (mostly,
"^DIC",798.4,798.4,"%D",3,0)
demographic information).
"^DIC",798.4,798.4,"%D",4,0)
 
"^DIC",798.4,798.4,"%D",5,0)
Most of the fields in the file have the same 
"^DIC",798.4,798.4,"%D",6,0)
numbers and names as the corresponding fields in
"^DIC",798.4,798.4,"%D",7,0)
the PATIENT file.
"^DIC",798.4,798.4,"%D",8,0)
 
"^DIC",798.4,798.4,"%D",9,0)
Demographic data from this file is compared to
"^DIC",798.4,798.4,"%D",10,0)
that from the PATIENT file (#2) to determine if it
"^DIC",798.4,798.4,"%D",11,0)
has been changed since the last registry data
"^DIC",798.4,798.4,"%D",12,0)
extraction. These fields are updated with the
"^DIC",798.4,798.4,"%D",13,0)
values from the PATIENT file and the UPDATE
"^DIC",798.4,798.4,"%D",14,0)
DEMOGRAPHICS flag is set to "Yes" in all active
"^DIC",798.4,798.4,"%D",15,0)
registry records of the patient.
"^DIC",798.4,798.4,"%D",16,0)
 
"^DIC",798.4,798.4,"%D",17,0)
Records in the file have the same internal entry 
"^DIC",798.4,798.4,"%D",18,0)
numbers as the patients' records in the PATIENT
"^DIC",798.4,798.4,"%D",19,0)
file. The records are uniquely identified by
"^DIC",798.4,798.4,"%D",20,0)
internal value of the PATIENT NAME field.
"^DIC",798.4,798.4,"%D",21,0)
 
"^DIC",798.4,798.4,"%D",22,0)
A permanent screen (the ^DD(798.4,0,"SCR") node) 
"^DIC",798.4,798.4,"%D",23,0)
restricts access to the records of this file. Only
"^DIC",798.4,798.4,"%D",24,0)
users with the security key(s) for any defined
"^DIC",798.4,798.4,"%D",25,0)
registry (or those with the FileMan programmer
"^DIC",798.4,798.4,"%D",26,0)
access code) can access records of the file.
"^DIC",798.4,798.4,"%D",27,0)
 
"^DIC",798.4,798.4,"%D",28,0)
If you want the changes in the security keys
"^DIC",798.4,798.4,"%D",29,0)
allocation to have an effect immediately, you 
"^DIC",798.4,798.4,"%D",30,0)
should rebuild the "ACL" cross-reference of the
"^DIC",798.4,798.4,"%D",31,0)
.01 field of the SECURITY KEY multiple of the ROR
"^DIC",798.4,798.4,"%D",32,0)
REGISTRY PARAMETERS file (#798.1). See the
"^DIC",798.4,798.4,"%D",33,0)
description of the cross-reference for more
"^DIC",798.4,798.4,"%D",34,0)
details.
"^DIC",798.4,"B","ROR PATIENT",798.4)

**END**
**END**
