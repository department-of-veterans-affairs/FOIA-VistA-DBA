Released HL*1.6*88 SEQ #84
Extracted from mail message
**KIDS**:HL*1.6*88^

**INSTALL NAME**
HL*1.6*88
"BLD",467,0)
HL*1.6*88^HEALTH LEVEL SEVEN^0^3021203^y
"BLD",467,1,0)
^^2^2^3021119^
"BLD",467,1,1,0)
See patch HL*1.6*88 in the National Patch Module for complete information
"BLD",467,1,2,0)
on this patch.
"BLD",467,4,0)
^9.64PA^^
"BLD",467,"ABPKG")
n
"BLD",467,"KRN",0)
^9.67PA^8989.52^20
"BLD",467,"KRN",.4,0)
.4
"BLD",467,"KRN",.401,0)
.401
"BLD",467,"KRN",.402,0)
.402
"BLD",467,"KRN",.403,0)
.403
"BLD",467,"KRN",.5,0)
.5
"BLD",467,"KRN",.84,0)
.84
"BLD",467,"KRN",3.6,0)
3.6
"BLD",467,"KRN",3.8,0)
3.8
"BLD",467,"KRN",9.2,0)
9.2
"BLD",467,"KRN",9.8,0)
9.8
"BLD",467,"KRN",9.8,"NM",0)
^9.68A^11^9
"BLD",467,"KRN",9.8,"NM",2,0)
HLUCM001^^0^B78465998
"BLD",467,"KRN",9.8,"NM",4,0)
HLUCM003^^0^B51187698
"BLD",467,"KRN",9.8,"NM",5,0)
HLUCM^^0^B63314249
"BLD",467,"KRN",9.8,"NM",6,0)
HLUCM002^^0^B50250557
"BLD",467,"KRN",9.8,"NM",7,0)
HLUCM004^^0^B66226353
"BLD",467,"KRN",9.8,"NM",8,0)
HLUCM005^^0^B71964861
"BLD",467,"KRN",9.8,"NM",9,0)
HLUCM006^^0^B67137843
"BLD",467,"KRN",9.8,"NM",10,0)
HLUCM007^^0^B33989947
"BLD",467,"KRN",9.8,"NM",11,0)
HLUCM008^^0^B42740230
"BLD",467,"KRN",9.8,"NM","B","HLUCM",5)

"BLD",467,"KRN",9.8,"NM","B","HLUCM001",2)

"BLD",467,"KRN",9.8,"NM","B","HLUCM002",6)

"BLD",467,"KRN",9.8,"NM","B","HLUCM003",4)

"BLD",467,"KRN",9.8,"NM","B","HLUCM004",7)

"BLD",467,"KRN",9.8,"NM","B","HLUCM005",8)

"BLD",467,"KRN",9.8,"NM","B","HLUCM006",9)

"BLD",467,"KRN",9.8,"NM","B","HLUCM007",10)

"BLD",467,"KRN",9.8,"NM","B","HLUCM008",11)

"BLD",467,"KRN",19,0)
19
"BLD",467,"KRN",19.1,0)
19.1
"BLD",467,"KRN",101,0)
101
"BLD",467,"KRN",409.61,0)
409.61
"BLD",467,"KRN",771,0)
771
"BLD",467,"KRN",870,0)
870
"BLD",467,"KRN",8989.51,0)
8989.51
"BLD",467,"KRN",8989.52,0)
8989.52
"BLD",467,"KRN",8994,0)
8994
"BLD",467,"KRN","B",.4,.4)

"BLD",467,"KRN","B",.401,.401)

"BLD",467,"KRN","B",.402,.402)

"BLD",467,"KRN","B",.403,.403)

"BLD",467,"KRN","B",.5,.5)

"BLD",467,"KRN","B",.84,.84)

"BLD",467,"KRN","B",3.6,3.6)

"BLD",467,"KRN","B",3.8,3.8)

"BLD",467,"KRN","B",9.2,9.2)

"BLD",467,"KRN","B",9.8,9.8)

"BLD",467,"KRN","B",19,19)

"BLD",467,"KRN","B",19.1,19.1)

"BLD",467,"KRN","B",101,101)

"BLD",467,"KRN","B",409.61,409.61)

"BLD",467,"KRN","B",771,771)

"BLD",467,"KRN","B",870,870)

"BLD",467,"KRN","B",8989.51,8989.51)

"BLD",467,"KRN","B",8989.52,8989.52)

"BLD",467,"KRN","B",8994,8994)

"BLD",467,"QUES",0)
^9.62^^
"BLD",467,"REQB",0)
^9.611^^0
"MBREQ")
0
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
88^3021203^73
"PKG",9,22,1,"PAH",1,1,0)
^^2^2^3021203
"PKG",9,22,1,"PAH",1,1,1,0)
See patch HL*1.6*88 in the National Patch Module for complete information
"PKG",9,22,1,"PAH",1,1,2,0)
on this patch.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
9
"RTN","HLUCM")
0^5^B63314249
"RTN","HLUCM",1,0)
HLUCM ;CIOFO-O/LJA - HL7/Capacity Mgt API ;2/27/01 10:15
"RTN","HLUCM",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**79,88**;Oct 13, 1995
"RTN","HLUCM",3,0)
 ;
"RTN","HLUCM",4,0)
 QUIT
"RTN","HLUCM",5,0)
 ;
"RTN","HLUCM",6,0)
CM(START,END,PNMSP,IEN101,TOTALS,COND,ERRINFO) ; Capacity management totals
"RTN","HLUCM",7,0)
 N CTPCKG,ERR,DATA,IEN772,IEN773,LOOPDT,ORIGETM,ORIGSTM,NMSPTYPE
"RTN","HLUCM",8,0)
 N PCKG,PROT,PROTOCOL,PROTYPE,RESULTS,V1,V2,X,Y
"RTN","HLUCM",9,0)
 ; NEWs above for $$SETUP and subcalls, and for $$LOOP and subcalls
"RTN","HLUCM",10,0)
 ;
"RTN","HLUCM",11,0)
 S ORIGSTM=$G(START),ORIGETM=$G(END)
"RTN","HLUCM",12,0)
 ;
"RTN","HLUCM",13,0)
 ; Summarize by DAY instead of hour?
"RTN","HLUCM",14,0)
 I ORIGSTM?7N,ORIGETM']"" D
"RTN","HLUCM",15,0)
 .  S ^TMP($J,"HLUCMDT")=""
"RTN","HLUCM",16,0)
 .  S ORIGETM=ORIGSTM_".24"
"RTN","HLUCM",17,0)
 ;
"RTN","HLUCM",18,0)
 ; If didn't add 0^...
"RTN","HLUCM",19,0)
 I $G(IEN101)]"",IEN101'?1N,IEN101'?1"0^".E S IEN101="0^"_IEN101
"RTN","HLUCM",20,0)
 I $G(PNMSP)]"",PNMSP'?1N,PNMSP'?1"0^".E S PNMSP="0^"_PNMSP
"RTN","HLUCM",21,0)
 ;
"RTN","HLUCM",22,0)
 ; Miscellaneous KILLs...
"RTN","HLUCM",23,0)
 D KILLS("START")
"RTN","HLUCM",24,0)
 ;
"RTN","HLUCM",25,0)
 ; This is where results are returned to caller...
"RTN","HLUCM",26,0)
 KILL ERRINFO
"RTN","HLUCM",27,0)
 ;
"RTN","HLUCM",28,0)
 ; Perform all setup chores.  If errors found, they will be placed
"RTN","HLUCM",29,0)
 ; in ERRINFO(ERROR-REASON)="" array
"RTN","HLUCM",30,0)
 QUIT:$$SETUP "" ;-> Some errors occurred...
"RTN","HLUCM",31,0)
 ;
"RTN","HLUCM",32,0)
 ; Loop and count here...  (MAIN WORK LOOP)
"RTN","HLUCM",33,0)
 S RESULTS=$P($$LOOP,U,1,3)
"RTN","HLUCM",34,0)
 I $D(^TMP(TOTALS,$J)) S ^TMP(TOTALS,$J)=$P($G(^TMP(TOTALS,$J)),U,1,3)
"RTN","HLUCM",35,0)
 ;
"RTN","HLUCM",36,0)
 ; If debugging, add REMOTE...
"RTN","HLUCM",37,0)
 D REMOTE^HLUCM006
"RTN","HLUCM",38,0)
 ;
"RTN","HLUCM",39,0)
 D KILLS("END")
"RTN","HLUCM",40,0)
 ;
"RTN","HLUCM",41,0)
 QUIT RESULTS
"RTN","HLUCM",42,0)
 ;
"RTN","HLUCM",43,0)
CM2(START,END,PNMSP,IEN101,TOTALS,COND,ERRINFO) ; Capacity management totals
"RTN","HLUCM",44,0)
 ;
"RTN","HLUCM",45,0)
 ; PHASE II - Counts are by "units", not individual entries in file.
"RTN","HLUCM",46,0)
 ;            A unit equals the msg and all related CAs and AAs.
"RTN","HLUCM",47,0)
 ;
"RTN","HLUCM",48,0)
 N COUNTED,CTPCKG,ERR,DATA,HLUCMADD,IEN772,IEN773,LOOP772
"RTN","HLUCM",49,0)
 N LOOPDT,NMSPTYPE,ORIGETM,ORIGSTM,PCKG,PROT,PROTOCOL
"RTN","HLUCM",50,0)
 N PROTYPE,RESULTS,V1,V2,VALUE,X
"RTN","HLUCM",51,0)
 ; NEWs above for $$SETUP and subcalls, and for $$LOOP and subcalls
"RTN","HLUCM",52,0)
 ;
"RTN","HLUCM",53,0)
 S ORIGSTM=$G(START),ORIGETM=$G(END)
"RTN","HLUCM",54,0)
 ;
"RTN","HLUCM",55,0)
 D KILLS("START")
"RTN","HLUCM",56,0)
 ;
"RTN","HLUCM",57,0)
 ; This is where results are returned to caller...
"RTN","HLUCM",58,0)
 KILL ERRINFO
"RTN","HLUCM",59,0)
 ;
"RTN","HLUCM",60,0)
 ; Perform all setup chores.  If errors found, they will be placed
"RTN","HLUCM",61,0)
 ; in ERRINFO(ERROR-REASON)="" array
"RTN","HLUCM",62,0)
 QUIT:$$SETUP "" ;-> Some errors occurred...
"RTN","HLUCM",63,0)
 ;
"RTN","HLUCM",64,0)
 ; Loop and count here...  (MAIN WORK LOOP)
"RTN","HLUCM",65,0)
 S RESULTS=$P($$LOOP^HLUCM003,U,1,3) ; Counts are aggregate
"RTN","HLUCM",66,0)
 I $D(^TMP(TOTALS,$J)) S ^TMP(TOTALS,$J)=$P($G(^TMP(TOTALS,$J)),U,1,3)
"RTN","HLUCM",67,0)
 ;
"RTN","HLUCM",68,0)
 ; If debugging, add REMOTE...
"RTN","HLUCM",69,0)
 D REMOTE^HLUCM006
"RTN","HLUCM",70,0)
 ;
"RTN","HLUCM",71,0)
 D KILLS("END")
"RTN","HLUCM",72,0)
 ;
"RTN","HLUCM",73,0)
 QUIT RESULTS
"RTN","HLUCM",74,0)
 ;
"RTN","HLUCM",75,0)
SETUP() ; Perform checks, which can return error conditions, and
"RTN","HLUCM",76,0)
 ; set up variables for $$LOOP.  This extrinsic function returns
"RTN","HLUCM",77,0)
 ; "" if no errors, or the # errors found.  (Note that error
"RTN","HLUCM",78,0)
 ; details placed in ERRINFO(ERROR-REASON)="")
"RTN","HLUCM",79,0)
 N NOERR
"RTN","HLUCM",80,0)
 S NOERR=""
"RTN","HLUCM",81,0)
 D SETDEF ; Set defaults for parameters, if not passed
"RTN","HLUCM",82,0)
 D FINDWAY ; Find way NMSP and PROT parameters passed
"RTN","HLUCM",83,0)
 D SETMORE^HLUCM007 ; Additional var sets based on parameters & "way"...
"RTN","HLUCM",84,0)
 D ERRCHK^HLUCM007 ; Check for errors...
"RTN","HLUCM",85,0)
 KILL ^TMP(TOTALS,$J) ; Clear out storage location...
"RTN","HLUCM",86,0)
 QUIT NOERR
"RTN","HLUCM",87,0)
 ;
"RTN","HLUCM",88,0)
SETDEF ; Set various defaults...
"RTN","HLUCM",89,0)
 I '$D(PNMSP) S PNMSP=1
"RTN","HLUCM",90,0)
 I '$D(IEN101) S IEN101=1
"RTN","HLUCM",91,0)
 I $G(TOTALS)']"" S TOTALS="HLTOTALS"
"RTN","HLUCM",92,0)
 S COND=$$UP^XLFSTR(COND)
"RTN","HLUCM",93,0)
 S COND=$S($G(COND)="BOTH":COND,1:"EITHER") ; Default to EITHER matches, count it...
"RTN","HLUCM",94,0)
 QUIT
"RTN","HLUCM",95,0)
 ;
"RTN","HLUCM",96,0)
FINDWAY ; How were NMSP and PROT passed?  By reference?  (If so, return 1)
"RTN","HLUCM",97,0)
 ; Passed by reference?
"RTN","HLUCM",98,0)
 S NMSPTYPE=$S($G(PNMSP)']""&($O(PNMSP(""))]""):1,1:0) ; 1=YES
"RTN","HLUCM",99,0)
 S PROTYPE=$S($G(IEN101)']""&($O(IEN101(""))]""):1,1:0) ; 1=YES
"RTN","HLUCM",100,0)
 QUIT
"RTN","HLUCM",101,0)
 ;
"RTN","HLUCM",102,0)
LOOP() ; Loop thru 772's .01... (Called from LOOP^HLUCM)
"RTN","HLUCM",103,0)
 N CTDBG,IEN772,LOOPDT,RESULTS,TM772,X
"RTN","HLUCM",104,0)
 ;
"RTN","HLUCM",105,0)
 S LOOPDT=START-.000001
"RTN","HLUCM",106,0)
 F  S LOOPDT=$O(^HL(772,"B",LOOPDT)) Q:LOOPDT'>0!(LOOPDT>END)  D
"RTN","HLUCM",107,0)
 .  S IEN772=0
"RTN","HLUCM",108,0)
 .  F  S IEN772=$O(^HL(772,"B",LOOPDT,IEN772)) Q:IEN772'>0  D
"RTN","HLUCM",109,0)
 .  .  QUIT:$P($G(^HL(772,+IEN772,0)),U)'?7N.E  ;->
"RTN","HLUCM",110,0)
 .  .  D COLLECT(IEN772) ; All 772 & 773 actions performed in COLLECT
"RTN","HLUCM",111,0)
 .  .
"RTN","HLUCM",112,0)
 .  .  ; trap debug data?
"RTN","HLUCM",113,0)
 .  .  D HLUCMSTR^HLUCM003
"RTN","HLUCM",114,0)
 ;
"RTN","HLUCM",115,0)
 S RESULTS=$G(^TMP(TOTALS,$J))
"RTN","HLUCM",116,0)
 ;
"RTN","HLUCM",117,0)
 ; Not debugging...
"RTN","HLUCM",118,0)
 I $G(^TMP($J,"HLUCM"))'="DEBUG GLOBAL" D  QUIT RESULTS ;->
"RTN","HLUCM",119,0)
 .  KILL ^TMP($J,"HLUCM")
"RTN","HLUCM",120,0)
 ;
"RTN","HLUCM",121,0)
 ; Debugging...
"RTN","HLUCM",122,0)
 D PACKDGBL^HLUCM005(1)
"RTN","HLUCM",123,0)
 KILL ^TMP($J,"HLUCM"),^TMP($J,"RECNM")
"RTN","HLUCM",124,0)
 D HLUCMSHW^HLUCM003
"RTN","HLUCM",125,0)
 ;
"RTN","HLUCM",126,0)
 QUIT RESULTS
"RTN","HLUCM",127,0)
 ;
"RTN","HLUCM",128,0)
COLLECT(IEN772) ; Collect 772 data and associated 773 data...
"RTN","HLUCM",129,0)
 N CT,CTPCKG,DBGBL,IEN773,PP,TOT772,TOT772T,TYPEHR,TYPEIO,TYPELR
"RTN","HLUCM",130,0)
 ;
"RTN","HLUCM",131,0)
 KILL DATA
"RTN","HLUCM",132,0)
 KILL ^TMP("HLUCMSTORE",$J)
"RTN","HLUCM",133,0)
 ;
"RTN","HLUCM",134,0)
 ; Get protocol and package namespace for storing in ^TMP()
"RTN","HLUCM",135,0)
 S PP=$$PROTNMSP^HLUCM002(+IEN772)
"RTN","HLUCM",136,0)
 I $P(PP,U)']""!($P(PP,U,2)']"") QUIT  ;->
"RTN","HLUCM",137,0)
 S (DATA("PROT"),PROT)=$P(PP,U),PROT=$S(PROT]"":PROT,1:"ZZZ")
"RTN","HLUCM",138,0)
 S (DATA("PCKG"),PCKG)=$P(PP,U,2),PCKG=$S(PCKG]"":PCKG,1:"ZZZ")
"RTN","HLUCM",139,0)
 ;
"RTN","HLUCM",140,0)
 ; Get variable used as sorting value in ^TMP(..."HR"...) global...
"RTN","HLUCM",141,0)
 S TYPEHR=$$TYPETMO^HLUCM002(IEN772)
"RTN","HLUCM",142,0)
 ;
"RTN","HLUCM",143,0)
 ; Get variable used as I/O sorting value in ^TMP("..."NMSP"...) global...
"RTN","HLUCM",144,0)
 S TYPEIO=$$TYPEIO^HLUCM002(IEN772)
"RTN","HLUCM",145,0)
 ;
"RTN","HLUCM",146,0)
 ; Get variable used as L/R sorting value in ^TMP("..."NMSP"...) global...
"RTN","HLUCM",147,0)
 S TYPELR=$$TYPELR^HLUCM001(IEN772)
"RTN","HLUCM",148,0)
 ;
"RTN","HLUCM",149,0)
 ; Place 772 numbers in DATA(...)
"RTN","HLUCM",150,0)
 S DBGBL=1
"RTN","HLUCM",151,0)
 D TOT772(IEN772)
"RTN","HLUCM",152,0)
 ;
"RTN","HLUCM",153,0)
 ; Loop thru all associated 773s and put #s in DATA(...) also...
"RTN","HLUCM",154,0)
 S DBGBL=1
"RTN","HLUCM",155,0)
 S IEN773=0,CT=0
"RTN","HLUCM",156,0)
 F  S IEN773=$O(^HLMA("B",IEN772,IEN773)) Q:IEN773'>0  D
"RTN","HLUCM",157,0)
 .  S CT=CT+1
"RTN","HLUCM",158,0)
 .  D TOT773(IEN773)
"RTN","HLUCM",159,0)
 .  I CT>1 S DATA("CHAR")=DATA("CHAR")+DATA("CHAR",772)
"RTN","HLUCM",160,0)
 ;
"RTN","HLUCM",161,0)
 ; Data OK?
"RTN","HLUCM",162,0)
 S DATA("CHAR")=$G(DATA("CHAR"))
"RTN","HLUCM",163,0)
 D TMDIFF
"RTN","HLUCM",164,0)
 ;
"RTN","HLUCM",165,0)
 ; Store ^TMP($J,"HLUCMSTORE") data...
"RTN","HLUCM",166,0)
 I $G(^TMP($J,"HLUCM"))="DEBUG GLOBAL" D
"RTN","HLUCM",167,0)
 .  MERGE ^TMP($J,"HLUCMSTORE","E")=^TMP("HLUCMSTORE",$J,"E")
"RTN","HLUCM",168,0)
 ;
"RTN","HLUCM",169,0)
 KILL ^TMP("HLUCMSTORE",$J)
"RTN","HLUCM",170,0)
 ;
"RTN","HLUCM",171,0)
 ; Store DATA() info in ^TMP(TOTALS,$J,...)
"RTN","HLUCM",172,0)
 D ADDTMP^HLUCM001
"RTN","HLUCM",173,0)
 ;
"RTN","HLUCM",174,0)
 QUIT
"RTN","HLUCM",175,0)
 ;
"RTN","HLUCM",176,0)
TOT772(IEN772) ; Total 772 message size and process time...
"RTN","HLUCM",177,0)
 ; DATA() -- passed in (see COLLECT)
"RTN","HLUCM",178,0)
 N TOT772,TOT773
"RTN","HLUCM",179,0)
 ;
"RTN","HLUCM",180,0)
 D TOT772C(IEN772) ; total # characters...
"RTN","HLUCM",181,0)
 D TOT772T(IEN772) ; total processing time...
"RTN","HLUCM",182,0)
 ;
"RTN","HLUCM",183,0)
 S TOT772=$G(DATA("CHAR"))
"RTN","HLUCM",184,0)
 ;
"RTN","HLUCM",185,0)
 QUIT:$G(^TMP($J,"HLUCM"))'="DEBUG GLOBAL"  ;->
"RTN","HLUCM",186,0)
 QUIT:$G(DBGBL)'=1  ;-> Create global entries?
"RTN","HLUCM",187,0)
 ;
"RTN","HLUCM",188,0)
 S ^TMP("HLUCMSTORE",$J,"E",IEN772,772,"TM",TYPEHR)=$G(DATA("CHAR"))
"RTN","HLUCM",189,0)
 S ^TMP("HLUCMSTORE",$J,"E",IEN772,772,"IO",TYPEIO)=$G(DATA("CHAR"))_U_$G(DATA("PCKG"))
"RTN","HLUCM",190,0)
 S ^TMP("HLUCMSTORE",$J,"E",IEN772,772,"LR",TYPELR)=$G(DATA("CHAR"))_U_$G(DATA("PCKG"))
"RTN","HLUCM",191,0)
 S ^TMP("HLUCMSTORE",$J,"E",IEN772,772,"PR","PR")=$G(DATA("CHAR"))_U_$G(DATA("PROT"))
"RTN","HLUCM",192,0)
 ;
"RTN","HLUCM",193,0)
 QUIT
"RTN","HLUCM",194,0)
 ;
"RTN","HLUCM",195,0)
TOT772C(IEN772) ; Total number of characters in message...
"RTN","HLUCM",196,0)
 N LEN,LNO,TXT
"RTN","HLUCM",197,0)
 ;
"RTN","HLUCM",198,0)
 ; Use field if present.  (Not present about 25% of time)
"RTN","HLUCM",199,0)
 S LEN=$P($G(^HL(772,IEN772,"S")),U)
"RTN","HLUCM",200,0)
 I LEN D  QUIT  ;->
"RTN","HLUCM",201,0)
 .  S DATA("CHAR",772)=$G(DATA("CHAR",772))+LEN
"RTN","HLUCM",202,0)
 .  S DATA("CHAR")=$G(DATA("CHAR"))+LEN
"RTN","HLUCM",203,0)
 ;
"RTN","HLUCM",204,0)
 ; Total manually...
"RTN","HLUCM",205,0)
 S LNO=0
"RTN","HLUCM",206,0)
 F  S LNO=$O(^HL(772,IEN772,"IN",LNO)) Q:LNO'>0  D
"RTN","HLUCM",207,0)
 .  S TXT=$G(^HL(772,IEN772,"IN",+LNO,0)) QUIT:TXT']""  ;->
"RTN","HLUCM",208,0)
 .  S DATA("CHAR",772)=$G(DATA("CHAR",772))+$L(TXT)
"RTN","HLUCM",209,0)
 .  S DATA("CHAR")=$G(DATA("CHAR"))+$L(TXT)
"RTN","HLUCM",210,0)
 ;
"RTN","HLUCM",211,0)
 QUIT
"RTN","HLUCM",212,0)
 ;
"RTN","HLUCM",213,0)
TOT772T(IEN772) ; Processing time...
"RTN","HLUCM",214,0)
 ; No totals here.  Just set times in DATA() array for later use...
"RTN","HLUCM",215,0)
 N TIME
"RTN","HLUCM",216,0)
 ;
"RTN","HLUCM",217,0)
 ; Time of entry...
"RTN","HLUCM",218,0)
 S TIME=+$G(^HL(772,+IEN772,0))
"RTN","HLUCM",219,0)
 I TIME?7N.E S DATA("TIME",TIME,772,.01)=""
"RTN","HLUCM",220,0)
 ;
"RTN","HLUCM",221,0)
 ; Time processed...
"RTN","HLUCM",222,0)
 S TIME=$P($G(^HL(772,+IEN772,"P")),U,2)
"RTN","HLUCM",223,0)
 I TIME?7N.E S DATA("TIME",TIME,772,21)=""
"RTN","HLUCM",224,0)
 ;
"RTN","HLUCM",225,0)
 QUIT
"RTN","HLUCM",226,0)
 ;
"RTN","HLUCM",227,0)
TOT773(IEN773) ; Total # charactes and times...
"RTN","HLUCM",228,0)
 ; DATA() -- passed in  (See COLLECT)
"RTN","HLUCM",229,0)
 N TOT773
"RTN","HLUCM",230,0)
 ;
"RTN","HLUCM",231,0)
 D TOT773C(IEN773) ; Total characters...
"RTN","HLUCM",232,0)
 D TOT773T(IEN773) ; Set times...
"RTN","HLUCM",233,0)
 ;
"RTN","HLUCM",234,0)
 QUIT:$G(^TMP($J,"HLUCM"))'="DEBUG GLOBAL"  ;->
"RTN","HLUCM",235,0)
 QUIT:$G(DBGBL)'=1  ;-> Create global entries?
"RTN","HLUCM",236,0)
 S ^TMP("HLUCMSTORE",$J,"E",IEN772,773,IEN773)=$G(TOT773(+IEN773))
"RTN","HLUCM",237,0)
 ;
"RTN","HLUCM",238,0)
 QUIT
"RTN","HLUCM",239,0)
 ;
"RTN","HLUCM",240,0)
TOT773C(IEN773) ; Total number of characters...
"RTN","HLUCM",241,0)
 ; DATA() -- passed in  (See COLLECT)
"RTN","HLUCM",242,0)
 N CHAR
"RTN","HLUCM",243,0)
 S CHAR=$$MSGSIZE(+IEN773) QUIT:CHAR'>0  ;->
"RTN","HLUCM",244,0)
 S DATA("CHAR",773,IEN773)=CHAR
"RTN","HLUCM",245,0)
 S DATA("CHAR")=$G(DATA("CHAR"))+CHAR
"RTN","HLUCM",246,0)
 S TOT773(IEN773)=CHAR
"RTN","HLUCM",247,0)
 QUIT
"RTN","HLUCM",248,0)
 ;
"RTN","HLUCM",249,0)
MSGSIZE(IEN773) ; Number characters in 773 entry...
"RTN","HLUCM",250,0)
 N NCH,NO
"RTN","HLUCM",251,0)
 S NCH=0,NO=0
"RTN","HLUCM",252,0)
 F  S NO=$O(^HLMA(+IEN773,"MSH",NO)) Q:NO'>0  D
"RTN","HLUCM",253,0)
 .  S NCH=NCH+$L(^HLMA(+IEN773,"MSH",+NO,0))
"RTN","HLUCM",254,0)
 QUIT NCH
"RTN","HLUCM",255,0)
 ;
"RTN","HLUCM",256,0)
TOT773T(IEN773) ; Set TIMEs...
"RTN","HLUCM",257,0)
 ; DATA() -- passed in  (See COLLECT)
"RTN","HLUCM",258,0)
 N TIME
"RTN","HLUCM",259,0)
 ;
"RTN","HLUCM",260,0)
 ; Creation time already taken from 772...
"RTN","HLUCM",261,0)
 ;
"RTN","HLUCM",262,0)
 ; Processed time...
"RTN","HLUCM",263,0)
 S TIME=+$G(^HLMA(+IEN773,"S")) QUIT:TIME'>0  ;->
"RTN","HLUCM",264,0)
 S DATA("TIME",TIME,773,100)=""
"RTN","HLUCM",265,0)
 ;
"RTN","HLUCM",266,0)
 QUIT
"RTN","HLUCM",267,0)
 ;
"RTN","HLUCM",268,0)
ERR(REA) ; Record error...
"RTN","HLUCM",269,0)
 S NOERR=NOERR+1
"RTN","HLUCM",270,0)
 S REA=$S($G(REA)]"":REA,1:"?")
"RTN","HLUCM",271,0)
 S ERRINFO(REA)=""
"RTN","HLUCM",272,0)
 QUIT
"RTN","HLUCM",273,0)
 ;
"RTN","HLUCM",274,0)
SEC(FMDT) ;
"RTN","HLUCM",275,0)
 S FMDT=$$FMTH^XLFDT(FMDT)
"RTN","HLUCM",276,0)
 QUIT $$SEC^XLFDT(FMDT)
"RTN","HLUCM",277,0)
 ;
"RTN","HLUCM",278,0)
KILLS(WHEN) ; Kills of ^TMP data WHEN (START or END or ALL)
"RTN","HLUCM",279,0)
 N DATA
"RTN","HLUCM",280,0)
 ;
"RTN","HLUCM",281,0)
 ; If ALL, set WHEN to include START and END...
"RTN","HLUCM",282,0)
 S:WHEN="ALL" WHEN="STARTandEND"
"RTN","HLUCM",283,0)
 ;
"RTN","HLUCM",284,0)
 ; Always KILLs...
"RTN","HLUCM",285,0)
 F DATA="ACTUAL",$G(TOTALS)_"ERRTIME","N","RECNM","U","X" D
"RTN","HLUCM",286,0)
 .  KILL ^TMP(DATA,$J),^TMP($J,DATA)
"RTN","HLUCM",287,0)
 ;
"RTN","HLUCM",288,0)
 ; START-only KILLs...
"RTN","HLUCM",289,0)
 I WHEN["START" D
"RTN","HLUCM",290,0)
 .  F DATA="HLUCMSTORE",$G(TOTALS) D
"RTN","HLUCM",291,0)
 .  .  QUIT:DATA']""  ;-> Sometimes TOTALS might not be defined
"RTN","HLUCM",292,0)
 .  .  KILL ^TMP(DATA,$J),^TMP($J,DATA)
"RTN","HLUCM",293,0)
 ;
"RTN","HLUCM",294,0)
 ; END-only KILLs...
"RTN","HLUCM",295,0)
 I WHEN["END" D
"RTN","HLUCM",296,0)
 .  F DATA="HLUCM","HLUCMDT" D
"RTN","HLUCM",297,0)
 .  .  KILL ^TMP($J,DATA),^TMP(DATA,$J)
"RTN","HLUCM",298,0)
 ;
"RTN","HLUCM",299,0)
 ;
"RTN","HLUCM",300,0)
 QUIT
"RTN","HLUCM",301,0)
 ;
"RTN","HLUCM",302,0)
TMDIFF ; DATA("TIME",...) -- req --> DATA("DIFF")
"RTN","HLUCM",303,0)
 S DATA("START")=$O(DATA("TIME",0)) QUIT:DATA("START")'>0  ;->
"RTN","HLUCM",304,0)
 S DATA("END")=$O(DATA("TIME",":"),-1)
"RTN","HLUCM",305,0)
 S DATA("DIFF")=$$SEC(DATA("END"))-$$SEC(DATA("START"))
"RTN","HLUCM",306,0)
 QUIT
"RTN","HLUCM",307,0)
 ;
"RTN","HLUCM",308,0)
EOR ; HLUCM - HL7/Capacity Mgt API ;2/27/01 10:15
"RTN","HLUCM001")
0^2^B78465998
"RTN","HLUCM001",1,0)
HLUCM001 ;CIOFO-O/LJA - HL7/Capacity Mgt API (continued) ;2/27/01 10:15
"RTN","HLUCM001",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**79,88**;Oct 13, 1995
"RTN","HLUCM001",3,0)
 ;
"RTN","HLUCM001",4,0)
ADDTMP ; Accumulate totals into ^TMP(TOTALS,$J,...)
"RTN","HLUCM001",5,0)
 ; ORIGETM,ORIGSTM,TYPEHR,TYPEIO,TYPELR -- req
"RTN","HLUCM001",6,0)
 ;
"RTN","HLUCM001",7,0)
 N CHAR,ERRFLAG,SEC,START,TOTCURR
"RTN","HLUCM001",8,0)
 ;
"RTN","HLUCM001",9,0)
 S CHAR=$G(DATA("CHAR"))
"RTN","HLUCM001",10,0)
 S SEC=$G(DATA("DIFF"))
"RTN","HLUCM001",11,0)
 ;
"RTN","HLUCM001",12,0)
 S START=$$HR($G(DATA("START")))
"RTN","HLUCM001",13,0)
 I START<ORIGSTM S START=ORIGSTM
"RTN","HLUCM001",14,0)
 I START>ORIGETM S START=ORIGETM
"RTN","HLUCM001",15,0)
 ;
"RTN","HLUCM001",16,0)
 ; Back door way to total by day only. (Dropping HR).
"RTN","HLUCM001",17,0)
 I $D(^TMP($J,"HLUCMDT")) S START=START\1
"RTN","HLUCM001",18,0)
 ;
"RTN","HLUCM001",19,0)
 ; Is delta time greater than 30 minutes?
"RTN","HLUCM001",20,0)
 S ERRFLAG=0
"RTN","HLUCM001",21,0)
 I SEC>1799 S X=TOTALS N TOTALS S TOTALS=X_"ERRTIME",ERRFLAG=1
"RTN","HLUCM001",22,0)
 ; Store under TOTALS_ERRTIME
"RTN","HLUCM001",23,0)
 ;
"RTN","HLUCM001",24,0)
 D ACCUMHR
"RTN","HLUCM001",25,0)
 D ACCUMSP
"RTN","HLUCM001",26,0)
 D ACCUMPR
"RTN","HLUCM001",27,0)
 ;
"RTN","HLUCM001",28,0)
 ; Grand totals...
"RTN","HLUCM001",29,0)
 S TOTCURR=$G(^TMP(TOTALS,$J))
"RTN","HLUCM001",30,0)
 S $P(TOTCURR,U)=$P(TOTCURR,U)+DATA("CHAR")
"RTN","HLUCM001",31,0)
 I $G(HLUCMADD)'="DON'T ADD.  COLLECT3~HLUCM003" D
"RTN","HLUCM001",32,0)
 .  S $P(TOTCURR,U,2)=$P(TOTCURR,U,2)+1
"RTN","HLUCM001",33,0)
 S $P(TOTCURR,U,3)=$P(TOTCURR,U,3)+DATA("DIFF")
"RTN","HLUCM001",34,0)
 S $P(TOTCURR,U,4)=$P(TOTCURR,U,4)+1
"RTN","HLUCM001",35,0)
 S ^TMP(TOTALS,$J)=TOTCURR
"RTN","HLUCM001",36,0)
 ;
"RTN","HLUCM001",37,0)
 QUIT:$G(^TMP($J,"HLUCM"))'="DEBUG GLOBAL"  ;->
"RTN","HLUCM001",38,0)
 QUIT:$G(IEN772)'>0  ;->
"RTN","HLUCM001",39,0)
 ;
"RTN","HLUCM001",40,0)
 S $P(^TMP($J,"HLUCMSTORE","E",IEN772),U,1,5)=DATA("CHAR")_U_1_U_DATA("DIFF")_U_DATA("START")_U_DATA("END")
"RTN","HLUCM001",41,0)
 I ERRFLAG S ^TMP($J,"HLUCMSTORE","E",IEN772,"ERR")=TOTALS
"RTN","HLUCM001",42,0)
 ;
"RTN","HLUCM001",43,0)
 QUIT
"RTN","HLUCM001",44,0)
 ;
"RTN","HLUCM001",45,0)
ACCUMHR ; Hour totaling
"RTN","HLUCM001",46,0)
 ; DATA(),START,TYPEHR -- req
"RTN","HLUCM001",47,0)
 ;
"RTN","HLUCM001",48,0)
 D ACCUMLAT("HR","TM",TYPEHR,START,DATA("PCKG"),DATA("PROT"))
"RTN","HLUCM001",49,0)
 ;
"RTN","HLUCM001",50,0)
 ; Total level CATEGORY
"RTN","HLUCM001",51,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,"HR"))
"RTN","HLUCM001",52,0)
 D INCR
"RTN","HLUCM001",53,0)
 S ^TMP(TOTALS,$J,"HR")=TOTCURR
"RTN","HLUCM001",54,0)
 ;
"RTN","HLUCM001",55,0)
 QUIT
"RTN","HLUCM001",56,0)
 ;
"RTN","HLUCM001",57,0)
ACCUMSP ; Namespace totaling
"RTN","HLUCM001",58,0)
 ; DATA(),TYPEIO,TYPELR -- req
"RTN","HLUCM001",59,0)
 ;
"RTN","HLUCM001",60,0)
 D ACCUMLAT("NMSP","IO",TYPEIO,DATA("PCKG"),START,DATA("PROT"))
"RTN","HLUCM001",61,0)
 D ACCUMLAT("NMSP","LR",TYPELR,DATA("PCKG"),START,DATA("PROT"))
"RTN","HLUCM001",62,0)
 ;
"RTN","HLUCM001",63,0)
 ; Total level CATEGORY
"RTN","HLUCM001",64,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,"NMSP"))
"RTN","HLUCM001",65,0)
 D INCR
"RTN","HLUCM001",66,0)
 S ^TMP(TOTALS,$J,"NMSP")=TOTCURR
"RTN","HLUCM001",67,0)
 ;
"RTN","HLUCM001",68,0)
 QUIT
"RTN","HLUCM001",69,0)
 ;
"RTN","HLUCM001",70,0)
ACCUMPR ; Protocol totaling...
"RTN","HLUCM001",71,0)
 ; DATA(),START -- req
"RTN","HLUCM001",72,0)
 ;
"RTN","HLUCM001",73,0)
 D ACCUMLAT("PROT","PR","P",DATA("PROT"),DATA("PCKG"),START)
"RTN","HLUCM001",74,0)
 ;
"RTN","HLUCM001",75,0)
 ; Total level CATEGORY
"RTN","HLUCM001",76,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,"PROT"))
"RTN","HLUCM001",77,0)
 D INCR
"RTN","HLUCM001",78,0)
 S ^TMP(TOTALS,$J,"PROT")=TOTCURR
"RTN","HLUCM001",79,0)
 ;
"RTN","HLUCM001",80,0)
 QUIT
"RTN","HLUCM001",81,0)
 ;
"RTN","HLUCM001",82,0)
ACCUMLAT(CATEGORY,TYPE,SORT,SUB1,SUB2,SUB3) ; Generic accumulator
"RTN","HLUCM001",83,0)
 ; Totals level 3 for SUB...
"RTN","HLUCM001",84,0)
 ;
"RTN","HLUCM001",85,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,CATEGORY,TYPE,SORT,SUB1,SUB2,SUB3))
"RTN","HLUCM001",86,0)
 D INCR
"RTN","HLUCM001",87,0)
 S ^TMP(TOTALS,$J,CATEGORY,TYPE,SORT,SUB1,SUB2,SUB3)=TOTCURR
"RTN","HLUCM001",88,0)
 ;
"RTN","HLUCM001",89,0)
 ; Totals level 2 for SUB...
"RTN","HLUCM001",90,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,CATEGORY,TYPE,SORT,SUB1,SUB2))
"RTN","HLUCM001",91,0)
 D INCR
"RTN","HLUCM001",92,0)
 S ^TMP(TOTALS,$J,CATEGORY,TYPE,SORT,SUB1,SUB2)=TOTCURR
"RTN","HLUCM001",93,0)
 ;
"RTN","HLUCM001",94,0)
 ; Totals level 1 for SUB...
"RTN","HLUCM001",95,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,CATEGORY,TYPE,SORT,SUB1))
"RTN","HLUCM001",96,0)
 D INCR
"RTN","HLUCM001",97,0)
 S ^TMP(TOTALS,$J,CATEGORY,TYPE,SORT,SUB1)=TOTCURR
"RTN","HLUCM001",98,0)
 ;
"RTN","HLUCM001",99,0)
 ; Total level TYPE/SORT...
"RTN","HLUCM001",100,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,CATEGORY,TYPE,SORT))
"RTN","HLUCM001",101,0)
 D INCR
"RTN","HLUCM001",102,0)
 S ^TMP(TOTALS,$J,CATEGORY,TYPE,SORT)=TOTCURR
"RTN","HLUCM001",103,0)
 ;
"RTN","HLUCM001",104,0)
 ; Total level TYPE
"RTN","HLUCM001",105,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,CATEGORY,TYPE))
"RTN","HLUCM001",106,0)
 D INCR
"RTN","HLUCM001",107,0)
 S ^TMP(TOTALS,$J,CATEGORY,TYPE)=TOTCURR
"RTN","HLUCM001",108,0)
 ;
"RTN","HLUCM001",109,0)
 ; Total level CATEGORY
"RTN","HLUCM001",110,0)
 ; [Don't subtotal here, for NMSP holds two different TYPEs, and
"RTN","HLUCM001",111,0)
 ; if totalled here, it would double count.]
"RTN","HLUCM001",112,0)
 ;
"RTN","HLUCM001",113,0)
 QUIT
"RTN","HLUCM001",114,0)
 ;
"RTN","HLUCM001",115,0)
PAR(PAR) ;
"RTN","HLUCM001",116,0)
 I PAR="START" QUIT $$HR(+DATA("START")) ;->
"RTN","HLUCM001",117,0)
 I PAR="PROT" QUIT $S($G(IEN101)="ZZZ":"ZZZ",1:DATA("PROT")) ;->
"RTN","HLUCM001",118,0)
 I PAR="PCKG" QUIT $S($G(PNMSP)="ZZZ":"ZZZ",1:DATA("PCKG")) ;->
"RTN","HLUCM001",119,0)
 QUIT "ZZZ"
"RTN","HLUCM001",120,0)
 ;
"RTN","HLUCM001",121,0)
INCR ; Increment totals in TOTCURR...
"RTN","HLUCM001",122,0)
 ; CHAR,SEC -- req
"RTN","HLUCM001",123,0)
 S $P(TOTCURR,U)=$P(TOTCURR,U)+CHAR ; Number characters
"RTN","HLUCM001",124,0)
 S $P(TOTCURR,U,2)=$P(TOTCURR,U,2)+1 ; Number messages
"RTN","HLUCM001",125,0)
 S $P(TOTCURR,U,3)=$P(TOTCURR,U,3)+SEC ; Processing seconds
"RTN","HLUCM001",126,0)
 QUIT
"RTN","HLUCM001",127,0)
 ;
"RTN","HLUCM001",128,0)
HR(FMDT) ; Return FM DATE and HOUR only...
"RTN","HLUCM001",129,0)
 N HR
"RTN","HLUCM001",130,0)
 S FMDT=$G(FMDT)
"RTN","HLUCM001",131,0)
 I FMDT'?7N&(FMDT'?7N1"."1.N) QUIT "" ;->
"RTN","HLUCM001",132,0)
 S:FMDT'["." FMDT=FMDT_"."
"RTN","HLUCM001",133,0)
 S FMDT=$E(FMDT_"00",1,10) ; .00 thru .23 now...
"RTN","HLUCM001",134,0)
 S HR=+$P(FMDT,".",2)+1
"RTN","HLUCM001",135,0)
 S:HR<10 HR=0_HR S:HR>24 HR=24
"RTN","HLUCM001",136,0)
 QUIT (FMDT\1)_"."_HR
"RTN","HLUCM001",137,0)
 ;
"RTN","HLUCM001",138,0)
OKPAR101(PAR) ; PAR=IEN101...
"RTN","HLUCM001",139,0)
 N RET,VAL
"RTN","HLUCM001",140,0)
 ;
"RTN","HLUCM001",141,0)
 I PAR=1!(PAR=2) QUIT PAR ;->
"RTN","HLUCM001",142,0)
 I PAR="0^9999999" QUIT PAR ;->
"RTN","HLUCM001",143,0)
 ;
"RTN","HLUCM001",144,0)
 ; Passed as 0^IEN or 0^PROTOCOL NAME...
"RTN","HLUCM001",145,0)
 S VAL=$P(PAR,U,2)
"RTN","HLUCM001",146,0)
 ;
"RTN","HLUCM001",147,0)
 ; Was IEN passed?
"RTN","HLUCM001",148,0)
 I VAL=+VAL D  QUIT RET ;->
"RTN","HLUCM001",149,0)
 .  S RET=""
"RTN","HLUCM001",150,0)
 .  I $D(^ORD(101,+VAL,0)) S RET=PAR
"RTN","HLUCM001",151,0)
 .  I '$D(^ORD(101,+VAL,0)) QUIT  ;-> Leaving RET=""
"RTN","HLUCM001",152,0)
 ;
"RTN","HLUCM001",153,0)
 ; Name was passed... (Can be up to 63 characters long...)
"RTN","HLUCM001",154,0)
 ; Find IEN for name...
"RTN","HLUCM001",155,0)
 S VAL=$$FIND101(PAR)
"RTN","HLUCM001",156,0)
 ;
"RTN","HLUCM001",157,0)
 ; If VAL=IEN, reset IEN101 to 0^IEN format...
"RTN","HLUCM001",158,0)
 I VAL>0 QUIT "0^"_+VAL  ;->
"RTN","HLUCM001",159,0)
 ;
"RTN","HLUCM001",160,0)
 QUIT ""
"RTN","HLUCM001",161,0)
 ;
"RTN","HLUCM001",162,0)
FIND101(VAL) ; No checking for upp/lowercase.  Must be passed right!
"RTN","HLUCM001",163,0)
 ; VAL = Protocol name...
"RTN","HLUCM001",164,0)
 N FIEN,IEN,LNM,PNM
"RTN","HLUCM001",165,0)
 ;
"RTN","HLUCM001",166,0)
 S VAL=$P(VAL,"0^",2)
"RTN","HLUCM001",167,0)
 ;
"RTN","HLUCM001",168,0)
 ; Passed as IEN?
"RTN","HLUCM001",169,0)
 I VAL=+VAL,$D(^ORD(101,+VAL,0)) QUIT +VAL ;->
"RTN","HLUCM001",170,0)
 ;
"RTN","HLUCM001",171,0)
 ; Passed as NAME?
"RTN","HLUCM001",172,0)
 S FIEN=0
"RTN","HLUCM001",173,0)
 S LNM=$E(VAL,1,$S($L(VAL)>30:29,1:$L(VAL)-1))
"RTN","HLUCM001",174,0)
 F  S LNM=$O(^ORD(101,"B",LNM)) Q:LNM]VAL!(LNM']"")!(FIEN)  D
"RTN","HLUCM001",175,0)
 .  S IEN=0
"RTN","HLUCM001",176,0)
 .  F  S IEN=$O(^ORD(101,"B",LNM,IEN)) Q:IEN'>0!(FIEN)  D
"RTN","HLUCM001",177,0)
 .  .  QUIT:$P($G(^ORD(101,+IEN,0)),U)'=VAL  ;->
"RTN","HLUCM001",178,0)
 .  .  S FIEN=+IEN
"RTN","HLUCM001",179,0)
 QUIT $S(FIEN:FIEN,1:"")
"RTN","HLUCM001",180,0)
 ;
"RTN","HLUCM001",181,0)
PCKG(IEN772) ; Return package namespace, or ZZZ if supposed to lump totals...
"RTN","HLUCM001",182,0)
 ; NMSPTYPE,PNMSP -- req
"RTN","HLUCM001",183,0)
 ;
"RTN","HLUCM001",184,0)
 N IEN101,IEN94,NMSP
"RTN","HLUCM001",185,0)
 ;
"RTN","HLUCM001",186,0)
 ; Include ALL, but lump every namespace into ZZZ...
"RTN","HLUCM001",187,0)
 I $G(PNMSP)=2 QUIT "ZZZ" ;->
"RTN","HLUCM001",188,0)
 ;
"RTN","HLUCM001",189,0)
 ; Best way (Get NMSP from stored namespace)
"RTN","HLUCM001",190,0)
 S NMSP=$P($G(^HL(772,+IEN772,0)),U,13)
"RTN","HLUCM001",191,0)
 ;
"RTN","HLUCM001",192,0)
 ; Get actual namespace.  Determine below what to return...
"RTN","HLUCM001",193,0)
 I NMSP']"" S NMSP=$$NMSP101(IEN772)
"RTN","HLUCM001",194,0)
 ;
"RTN","HLUCM001",195,0)
 ; Maybe a Mail only message?
"RTN","HLUCM001",196,0)
 I NMSP']"",$P($G(^HL(772,+IEN772,0)),U,5)>0 S NMSP="XWB"
"RTN","HLUCM001",197,0)
 ;
"RTN","HLUCM001",198,0)
 ; Include ALL, subdivide by individual namespaces...
"RTN","HLUCM001",199,0)
 I $G(PNMSP)=1 QUIT $S(NMSP]"":NMSP,1:"ZZZ") ;-> Want ALL, so default to ZZZ if null...
"RTN","HLUCM001",200,0)
 ;
"RTN","HLUCM001",201,0)
 ; Must be a specific namespace...
"RTN","HLUCM001",202,0)
 I $G(PNMSP)?1"0^".E D  QUIT PROT(1) ;->
"RTN","HLUCM001",203,0)
 .  S PROT(1)="" ; Set up default in case of failure...
"RTN","HLUCM001",204,0)
 .  I $P(PNMSP,U,2)=NMSP S PROT(1)=NMSP
"RTN","HLUCM001",205,0)
 ;
"RTN","HLUCM001",206,0)
 ; Passed namespaces by array, so anything here is OK.  Checks later...
"RTN","HLUCM001",207,0)
 I NMSPTYPE=1 QUIT NMSP ;->
"RTN","HLUCM001",208,0)
 ;
"RTN","HLUCM001",209,0)
 QUIT ""
"RTN","HLUCM001",210,0)
 ;
"RTN","HLUCM001",211,0)
NMSP101(IEN772) ;From 772->101->9.4, find 9.4's namespace...
"RTN","HLUCM001",212,0)
 N IEN101,IEN94
"RTN","HLUCM001",213,0)
 S IEN101=+$P($G(^HL(772,+IEN772,0)),U,10) QUIT:IEN101'>0 "" ;->
"RTN","HLUCM001",214,0)
 S IEN94=$P($G(^ORD(101,+IEN101,0)),U,12) QUIT:IEN94'>0 "" ;->
"RTN","HLUCM001",215,0)
 QUIT $P($$NMSP94(IEN94),U,2)
"RTN","HLUCM001",216,0)
 ;
"RTN","HLUCM001",217,0)
NMSP94(IEN94) ; From 9.4 find it's namespace...
"RTN","HLUCM001",218,0)
 N D0,DA,DIC,DIQ,DR,NMSP
"RTN","HLUCM001",219,0)
 S DIC=9.4,DR=".01;1",DA=IEN94,DIQ="NMSP(",DIQ(0)="E"
"RTN","HLUCM001",220,0)
 D EN^DIQ1
"RTN","HLUCM001",221,0)
 QUIT $G(NMSP(9.4,+IEN94,.01,"E"))_U_$G(NMSP(9.4,+IEN94,1,"E"))
"RTN","HLUCM001",222,0)
 ;
"RTN","HLUCM001",223,0)
TYPELR(IEN772) ; Is this Local or Remote or Unknown?
"RTN","HLUCM001",224,0)
 N D772,I773,IEN,IEN870,IO,MIEN,NM,TXT,TYPE,X
"RTN","HLUCM001",225,0)
 S D772=$G(^HL(772,+IEN772,0))
"RTN","HLUCM001",226,0)
 ;
"RTN","HLUCM001",227,0)
 ; Mailman check...
"RTN","HLUCM001",228,0)
 S MIEN=$P(D772,U,5) ; get Mailman IEN...
"RTN","HLUCM001",229,0)
 I MIEN S X=$$MAILTYPE(MIEN) QUIT:X="R" "R" ;-> Mailman, and remote...
"RTN","HLUCM001",230,0)
 ;
"RTN","HLUCM001",231,0)
 ; Additional mail check...
"RTN","HLUCM001",232,0)
 I $$MAIL870(IEN772)="R" QUIT "R" ;->
"RTN","HLUCM001",233,0)
 ;
"RTN","HLUCM001",234,0)
 ; Institution check...
"RTN","HLUCM001",235,0)
 I $$INST870(+IEN772,+$P($$SITE^VASITE,U,3))="R" QUIT "R" ;->
"RTN","HLUCM001",236,0)
 ;
"RTN","HLUCM001",237,0)
 ; MSH segment in 773 check...
"RTN","HLUCM001",238,0)
 S TYPE="L",I773=0
"RTN","HLUCM001",239,0)
 F  S I773=$O(^HLMA("B",IEN772,I773)) Q:'I773!(TYPE'="L")  D
"RTN","HLUCM001",240,0)
 .  N DIV,P4,P6
"RTN","HLUCM001",241,0)
 .  S TXT="",MIEN=0
"RTN","HLUCM001",242,0)
 .  F  S MIEN=$O(^HLMA(+I773,"MSH",MIEN)) Q:MIEN'>0  D
"RTN","HLUCM001",243,0)
 .  .  S TXT=TXT_$G(^HLMA(+I773,"MSH",+MIEN,0))
"RTN","HLUCM001",244,0)
 .  QUIT:TXT']""  ;->
"RTN","HLUCM001",245,0)
 .  S X=$$SITESMSH(TXT),P4=$P(X,U),P6=$P(X,U,2)
"RTN","HLUCM001",246,0)
 .  S:P4'=P6 TYPE="R"
"RTN","HLUCM001",247,0)
 ;
"RTN","HLUCM001",248,0)
 ; Was anything found?
"RTN","HLUCM001",249,0)
 QUIT:TYPE'="L" TYPE ;->
"RTN","HLUCM001",250,0)
 ;
"RTN","HLUCM001",251,0)
 ; Logical links check...
"RTN","HLUCM001",252,0)
 S IEN870=$$IEN870(+IEN772) I IEN870 D
"RTN","HLUCM001",253,0)
 .  N DATA,MGIEN
"RTN","HLUCM001",254,0)
 .  S DATA=$G(^HLCS(870,+IEN870,0))
"RTN","HLUCM001",255,0)
 .  QUIT:$P(DATA,U,3)'=1  ;-> Not MAIL...
"RTN","HLUCM001",256,0)
 .  S MGIEN=$P($G(^HLCS(870,+IEN870,100)),U) QUIT:MGIEN'>0  ;->
"RTN","HLUCM001",257,0)
 .  ; If a MAIL type link and there is an associated mail group,
"RTN","HLUCM001",258,0)
 ;  ; it is almost always REMOTE.  Enough so, that "R" will be assumed.
"RTN","HLUCM001",259,0)
 .  ; QUIT:$O(^XMB(3.8,+MGIEN,6,0))'>0  ;-> No remote groups
"RTN","HLUCM001",260,0)
 .  S TYPE="R"
"RTN","HLUCM001",261,0)
 .  ; Rare to hit this point.
"RTN","HLUCM001",262,0)
 ;
"RTN","HLUCM001",263,0)
 QUIT TYPE
"RTN","HLUCM001",264,0)
 ;
"RTN","HLUCM001",265,0)
SITESMSH(TXT) ; Return location pieces, slightly modified...
"RTN","HLUCM001",266,0)
 N DIV,P4,P6
"RTN","HLUCM001",267,0)
 S DIV=$E(TXT,4),P4=$P(TXT,DIV,4),P6=$P(TXT,DIV,6)
"RTN","HLUCM001",268,0)
 S P4=$S(P4?1.N1"~"!(P4?1.N):+P4,1:"")
"RTN","HLUCM001",269,0)
 S P6=$S(P6?1.N1"~"!(P6?1.N):+P6,1:"")
"RTN","HLUCM001",270,0)
 QUIT P4_U_P6
"RTN","HLUCM001",271,0)
 ;
"RTN","HLUCM001",272,0)
MAILTYPE(MIEN) ; Is MSH in Mailman message local or remote...
"RTN","HLUCM001",273,0)
 N IEN,RECNO,TO,TOID,TYPE
"RTN","HLUCM001",274,0)
 S TYPE="L"
"RTN","HLUCM001",275,0)
 KILL ^TMP($J,"HLMAILTYPE")
"RTN","HLUCM001",276,0)
 D QD^XMXUTIL3(+MIEN,,,,,"^TMP($J,""HLMAILTYPE"")")
"RTN","HLUCM001",277,0)
 S RECNO=0
"RTN","HLUCM001",278,0)
 F  S RECNO=$O(^TMP($J,"HLMAILTYPE","XMLIST",RECNO)) Q:RECNO'>0!(TYPE'="L")  D
"RTN","HLUCM001",279,0)
 .  S TO=$G(^TMP($J,"HLMAILTYPE","XMLIST",+RECNO,"TO"))
"RTN","HLUCM001",280,0)
 .  S TOID=$G(^TMP($J,"HLMAILTYPE","XMLIST",+RECNO,"TO ID"))
"RTN","HLUCM001",281,0)
 .  I TO["@"!(TOID="R") S TYPE="R"
"RTN","HLUCM001",282,0)
 KILL ^TMP($J,"HLMAILTYPE")
"RTN","HLUCM001",283,0)
 QUIT TYPE
"RTN","HLUCM001",284,0)
 ;
"RTN","HLUCM001",285,0)
IEN870(IEN772) ; Given 772 find 870...
"RTN","HLUCM001",286,0)
 N DATA,I773,I870,IEN
"RTN","HLUCM001",287,0)
 S DATA=$G(^HL(772,+IEN772,0))
"RTN","HLUCM001",288,0)
 ;
"RTN","HLUCM001",289,0)
 ; Logical Link field...
"RTN","HLUCM001",290,0)
 S IEN=$P(DATA,U,11) I IEN QUIT IEN ;->
"RTN","HLUCM001",291,0)
 ;
"RTN","HLUCM001",292,0)
 ; Related Event Protocol...
"RTN","HLUCM001",293,0)
 S IEN=$P(DATA,U,10),IEN=$P($G(^ORD(101,+IEN,770)),U,7) I IEN QUIT IEN ;->
"RTN","HLUCM001",294,0)
 ;
"RTN","HLUCM001",295,0)
 S I773=0
"RTN","HLUCM001",296,0)
 F  S I773=$O(^HLMA("B",IEN772,I773)) Q:I773'>0  D  QUIT:I870
"RTN","HLUCM001",297,0)
 .  S I870=$P($G(^HLMA(+I773,0)),U,7)
"RTN","HLUCM001",298,0)
 I $G(I870) QUIT +I870 ;->
"RTN","HLUCM001",299,0)
 ;
"RTN","HLUCM001",300,0)
 QUIT ""
"RTN","HLUCM001",301,0)
 ;
"RTN","HLUCM001",302,0)
TYPEMSH(TXT) ; From MSH segment, is it local or remote?
"RTN","HLUCM001",303,0)
 N VAL
"RTN","HLUCM001",304,0)
 S VAL=$$SITESMSH(TXT)
"RTN","HLUCM001",305,0)
 QUIT $S(+VAL=$P(VAL,U,2):"R",1:"L")
"RTN","HLUCM001",306,0)
 ;
"RTN","HLUCM001",307,0)
MAIL870(IEN772) ;
"RTN","HLUCM001",308,0)
 N LINK,MAIL
"RTN","HLUCM001",309,0)
 S LINK=$$LINK(IEN772) QUIT:LINK'>0 "" ;->
"RTN","HLUCM001",310,0)
 S MAIL=$P($G(^HLCS(870,+LINK,0)),U,3)
"RTN","HLUCM001",311,0)
 QUIT $S(MAIL=1:"R",1:"L")
"RTN","HLUCM001",312,0)
 ;
"RTN","HLUCM001",313,0)
INST870(IEN772,INST) ;
"RTN","HLUCM001",314,0)
 N INST870,LINK
"RTN","HLUCM001",315,0)
 S LINK=$$LINK(IEN772) QUIT:LINK'>0 "" ;->
"RTN","HLUCM001",316,0)
 S INST870=+$P($G(^HLCS(870,+LINK,0)),U,2)
"RTN","HLUCM001",317,0)
 QUIT $S(INST870>0&(INST870'=INST):"R",1:"L")
"RTN","HLUCM001",318,0)
 ;
"RTN","HLUCM001",319,0)
LINK(IEN772) ;
"RTN","HLUCM001",320,0)
 N IEN773,LINK
"RTN","HLUCM001",321,0)
 S LINK=$P($G(^HL(772,IEN772,0)),U,11)
"RTN","HLUCM001",322,0)
 I LINK'>0 D
"RTN","HLUCM001",323,0)
 .  S IEN773=$O(^HLMA("B",IEN772,0)) QUIT:IEN773'>0  ;->
"RTN","HLUCM001",324,0)
 .  S LINK=$P($G(^HLMA(+IEN773,0)),U,7)
"RTN","HLUCM001",325,0)
 QUIT LINK
"RTN","HLUCM001",326,0)
 ;
"RTN","HLUCM001",327,0)
EOR ; HLUCM001 - HL7/Capacity Mgt API (continued) ;2/27/01 10:15
"RTN","HLUCM002")
0^6^B50250557
"RTN","HLUCM002",1,0)
HLUCM002 ;CIOFO-O/LJA - HL7/Capacity Mgt API ;2/27/01 10:15
"RTN","HLUCM002",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**79,88**;Oct 13, 1995
"RTN","HLUCM002",3,0)
 ;
"RTN","HLUCM002",4,0)
PRINTREG ; Print data in ^TMP(SUB,...) to screen
"RTN","HLUCM002",5,0)
 ; SUB,JOBN -- req
"RTN","HLUCM002",6,0)
 I $G(SUB)']"" N SUB S SUB="TOT"
"RTN","HLUCM002",7,0)
 I $G(JOBN)'>0 N JOBN S JOBN=$J
"RTN","HLUCM002",8,0)
 D PRINT1
"RTN","HLUCM002",9,0)
 QUIT
"RTN","HLUCM002",10,0)
 ;
"RTN","HLUCM002",11,0)
PRINT(SUB,JOBN) ; Print data in ^TMP(SUB,...) to screen
"RTN","HLUCM002",12,0)
 S:$G(JOBN)'>0 JOBN=$J
"RTN","HLUCM002",13,0)
 I $G(SUB)']"" D  QUIT  ;->
"RTN","HLUCM002",14,0)
 .  W !!,"You must pass in the initial subscript and $JOB number..."
"RTN","HLUCM002",15,0)
 .  W !
"RTN","HLUCM002",16,0)
PRINT1 ;
"RTN","HLUCM002",17,0)
 N GBL,L1,L2,L3,L4,TOT
"RTN","HLUCM002",18,0)
 S GBL="^TMP("""_SUB_""","_JOBN_")"
"RTN","HLUCM002",19,0)
 I '$O(@GBL@(""))']"" D  QUIT  ;->
"RTN","HLUCM002",20,0)
 .  W !!,"No data found..."
"RTN","HLUCM002",21,0)
 .  W !
"RTN","HLUCM002",22,0)
 W !!," Total   Total   Total  Main"
"RTN","HLUCM002",23,0)
 W !,"#Chars   #Msgs    #Sec  Sort Sub1 Sub2 Sub3"
"RTN","HLUCM002",24,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLUCM002",25,0)
 S L1=""
"RTN","HLUCM002",26,0)
 F  S L1=$O(@GBL@(L1)) Q:L1']""  D
"RTN","HLUCM002",27,0)
 .  S L2=""
"RTN","HLUCM002",28,0)
 .  F  S L2=$O(@GBL@(L1,L2)) Q:L2']""  D
"RTN","HLUCM002",29,0)
 .  .  S L3=""
"RTN","HLUCM002",30,0)
 .  .  F  S L3=$O(@GBL@(L1,L2,L3)) Q:L3']""  D
"RTN","HLUCM002",31,0)
 .  .  .  S L4=""
"RTN","HLUCM002",32,0)
 .  .  .  F  S L4=$O(@GBL@(L1,L2,L3,L4)) Q:L4']""  D
"RTN","HLUCM002",33,0)
 .  .  .  .  S TOT=$G(@GBL@(L1,L2,L3,L4))
"RTN","HLUCM002",34,0)
 .  .  .  .  W !,$J(+TOT,6),?8,$J($P(TOT,U,2),6),?16,$J($P(TOT,U,3),6)
"RTN","HLUCM002",35,0)
 .  .  .  .  W ?24,L1,?29,L2,?34,L3,?39,$S($L(L4)<42:L4,1:$E(L4,1,40)_"~")
"RTN","HLUCM002",36,0)
 QUIT
"RTN","HLUCM002",37,0)
 ;
"RTN","HLUCM002",38,0)
PRINTDBG(JOBN) ; Print data in ^TMP($J,"DEBUG")
"RTN","HLUCM002",39,0)
 N CHAR,IEN772,IEN773,S1,S2,VAL
"RTN","HLUCM002",40,0)
 S IEN772=0
"RTN","HLUCM002",41,0)
 F  S IEN772=$O(^TMP($J,"HLUCMSTORE","E",IEN772)) Q:'IEN772  D
"RTN","HLUCM002",42,0)
 .  W !,IEN772
"RTN","HLUCM002",43,0)
 .  S CHAR=$G(^TMP($J,"HLUCMSTORE","E",IEN772))
"RTN","HLUCM002",44,0)
 .  W ?15,$J(CHAR,4),?21
"RTN","HLUCM002",45,0)
 .  S IEN773=$O(^TMP($J,"HLUCMSTORE","E",IEN772,773,0))
"RTN","HLUCM002",46,0)
 .  W:IEN773 "773s..."
"RTN","HLUCM002",47,0)
 .  W ?28
"RTN","HLUCM002",48,0)
 .  S S1=""
"RTN","HLUCM002",49,0)
 .  F  S S1=$O(^TMP($J,"HLUCMSTORE","E",IEN772,772,S1)) Q:S1']""  D
"RTN","HLUCM002",50,0)
 .  .  QUIT:S1="PR"  ;->
"RTN","HLUCM002",51,0)
 .  .  S S2=""
"RTN","HLUCM002",52,0)
 .  .  S S2=$O(^TMP($J,"HLUCMSTORE","E",IEN772,772,S1,S2)) Q:S2']""  D
"RTN","HLUCM002",53,0)
 .  .  .  S VAL=$$LOW^XLFSTR(S1)_"-"_S2
"RTN","HLUCM002",54,0)
 .  .  .  W $J(VAL,6)
"RTN","HLUCM002",55,0)
 QUIT
"RTN","HLUCM002",56,0)
 ;
"RTN","HLUCM002",57,0)
OKPAR(PAR) ; Is namespace or protocol OK?
"RTN","HLUCM002",58,0)
 S PAR=$G(PAR)
"RTN","HLUCM002",59,0)
 I PAR=1!(PAR=2) QUIT 1 ;->
"RTN","HLUCM002",60,0)
 I $$OK0CALL(PAR) QUIT 1 ;->
"RTN","HLUCM002",61,0)
 QUIT ""
"RTN","HLUCM002",62,0)
 ;
"RTN","HLUCM002",63,0)
OK0CALL(PAR) ; Correct 0^IEN or 0^NAME call format?
"RTN","HLUCM002",64,0)
 I $E(PAR,1,2)="0^"&($E(PAR,3)]"") QUIT 1 ;->
"RTN","HLUCM002",65,0)
 QUIT ""
"RTN","HLUCM002",66,0)
 ;
"RTN","HLUCM002",67,0)
TYPETMO(IEN772) ; Is this TCP, Mail (via TCP), or Other?
"RTN","HLUCM002",68,0)
 N D772,I773,MIEN
"RTN","HLUCM002",69,0)
 ;
"RTN","HLUCM002",70,0)
 ; RELATED MAILMAN MESSAGE field (0;5) in 772...
"RTN","HLUCM002",71,0)
 S D772=$G(^HL(772,+IEN772,0)) ; Get node
"RTN","HLUCM002",72,0)
 S MIEN=$P(D772,U,5) ; get Mailman IEN from field...
"RTN","HLUCM002",73,0)
 I MIEN QUIT "M" ;-> Mailman via TCP
"RTN","HLUCM002",74,0)
 ;
"RTN","HLUCM002",75,0)
 ; There are rare instances when RELATED MAILMAN MESSAGE field is
"RTN","HLUCM002",76,0)
 ; not filled in, but the LLP TYPE in 870 is Mailman.  So, the next
"RTN","HLUCM002",77,0)
 ; check is needed...
"RTN","HLUCM002",78,0)
 ;
"RTN","HLUCM002",79,0)
 ; Get related 870 and check it's LLP TYPE...
"RTN","HLUCM002",80,0)
 I $P($G(^HLCS(870,+$$IEN870^HLUCM001(+IEN772),0)),U,3)=1 QUIT "M" ;->
"RTN","HLUCM002",81,0)
 ;
"RTN","HLUCM002",82,0)
 ; OK.  Let's give up on proving this 772 entry a Mailman entry.
"RTN","HLUCM002",83,0)
 ; But, is it TCP?
"RTN","HLUCM002",84,0)
 ;
"RTN","HLUCM002",85,0)
 ; Check if TCP by 773 link...
"RTN","HLUCM002",86,0)
 S I773=$O(^HLMA("B",+IEN772,0))
"RTN","HLUCM002",87,0)
 I I773>0 QUIT "T" ;->
"RTN","HLUCM002",88,0)
 ;
"RTN","HLUCM002",89,0)
 QUIT "U" ; Other...
"RTN","HLUCM002",90,0)
 ;
"RTN","HLUCM002",91,0)
TYPEIO(IEN772) ; Is this Input or Output or Unknown?
"RTN","HLUCM002",92,0)
 N D772,HLIO
"RTN","HLUCM002",93,0)
 S D772=$G(^HL(772,+IEN772,0))
"RTN","HLUCM002",94,0)
 S HLIO=$E($P(D772,U,4)_" ")
"RTN","HLUCM002",95,0)
 QUIT $S("IO"[HLIO:HLIO,1:"U")
"RTN","HLUCM002",96,0)
 ;
"RTN","HLUCM002",97,0)
PROTNMSP(IEN772) ; Return PROT~NMSP value to store in ^TMP.  
"RTN","HLUCM002",98,0)
 ; COND,IEN101,PNMSP -- req
"RTN","HLUCM002",99,0)
 N CT,FAIL,PCKG,CTPROT,PCKG,PROT
"RTN","HLUCM002",100,0)
 ;
"RTN","HLUCM002",101,0)
 S IEN101=$G(IEN101),PNMSP=$G(PNMSP)
"RTN","HLUCM002",102,0)
 ;
"RTN","HLUCM002",103,0)
 ; ======================== PROTOCOL ============================
"RTN","HLUCM002",104,0)
 ; Get actual protocol in IEN772 if not supposed to "lump"...
"RTN","HLUCM002",105,0)
 S PROT=$S(IEN101'=2:$$PROT101(+IEN772),1:"ZZZ")
"RTN","HLUCM002",106,0)
 D ACTUAL(IEN772,1,PROT)
"RTN","HLUCM002",107,0)
 ;
"RTN","HLUCM002",108,0)
 ; If not lumping (PROT=2), and no valid protocol so far, infer!
"RTN","HLUCM002",109,0)
 I PROT=""!(PROT="ZZZ"),PROT'=2 D
"RTN","HLUCM002",110,0)
 .  S PROT=$$INFERPR^HLUCM004(+IEN772,PROT)
"RTN","HLUCM002",111,0)
 .  D ACTUAL(IEN772,2,PROT)
"RTN","HLUCM002",112,0)
 ;
"RTN","HLUCM002",113,0)
 ; Don't lose count if supposed to check everything...
"RTN","HLUCM002",114,0)
 I IEN101=1!(IEN101=2) D
"RTN","HLUCM002",115,0)
 .  I PROT']"" S PROT="ZZZ" QUIT  ;->
"RTN","HLUCM002",116,0)
 .  I IEN101=2 S PROT="ZZZ"
"RTN","HLUCM002",117,0)
 ;
"RTN","HLUCM002",118,0)
 ; Is the protocol countable?  (Must also check namespace)
"RTN","HLUCM002",119,0)
 S CTPROT=$$CTPROT(PROT)
"RTN","HLUCM002",120,0)
 ;
"RTN","HLUCM002",121,0)
 ; ======================== NAMESPACE ============================
"RTN","HLUCM002",122,0)
 ; Set package here and now...
"RTN","HLUCM002",123,0)
 S PCKG=$S(PNMSP'=2:$$PCKG^HLUCM001(+IEN772),1:"ZZZ")
"RTN","HLUCM002",124,0)
 D ACTUAL(IEN772,3,PCKG)
"RTN","HLUCM002",125,0)
 ;
"RTN","HLUCM002",126,0)
 ; Don't reset a ZZZ if supposed to lump (PNMSP=2)...
"RTN","HLUCM002",127,0)
 I PCKG="ZZZ",$G(PNMSP)'=2 D
"RTN","HLUCM002",128,0)
 .  S PCKG=$$INFERNM^HLUCM004(+IEN772,PCKG)
"RTN","HLUCM002",129,0)
 .  I PCKG["ZZZ",PROT[9999999 S PCKG="XMB"
"RTN","HLUCM002",130,0)
 .  D ACTUAL(IEN772,4,PCKG)
"RTN","HLUCM002",131,0)
 ;
"RTN","HLUCM002",132,0)
 I PNMSP=1!(PNMSP=2) D
"RTN","HLUCM002",133,0)
 .  I PCKG']"" S PCKG="ZZZ" QUIT  ;->
"RTN","HLUCM002",134,0)
 .  I PNMSP=2 S PCKG="ZZZ"
"RTN","HLUCM002",135,0)
 ;
"RTN","HLUCM002",136,0)
 S CTPCKG=$$CTPCKG(PCKG)
"RTN","HLUCM002",137,0)
 ;
"RTN","HLUCM002",138,0)
 ;
"RTN","HLUCM002",139,0)
 ; Set up what should be returned...  
"RTN","HLUCM002",140,0)
 S PROT=$S(PROT=2:"ZZZ",1:PROT),PCKG=$S(PCKG=2:"ZZZ",1:PCKG)
"RTN","HLUCM002",141,0)
 ; If MIXED make sure the ALL side of things is set to something
"RTN","HLUCM002",142,0)
 ; so the ALL side doesn't squelch a SPECIFIC match...
"RTN","HLUCM002",143,0)
 I $$MIXED D
"RTN","HLUCM002",144,0)
 .  I $G(PNMSP)=1!($G(PNMSP)=2) D
"RTN","HLUCM002",145,0)
 .  .  QUIT:PROT]""  ;->
"RTN","HLUCM002",146,0)
 .  .  QUIT:'CTPROT  ;-> Not to be counted anyway...
"RTN","HLUCM002",147,0)
 .  .  S PROT="ZZZ~0"
"RTN","HLUCM002",148,0)
 .  I $G(IEN101)=1!($G(IEN101)=2) D
"RTN","HLUCM002",149,0)
 .  .  QUIT:PCKG]""  ;->
"RTN","HLUCM002",150,0)
 .  .  QUIT:'CTPCKG  ;-> Not to be counted anyway...
"RTN","HLUCM002",151,0)
 .  .  S PCKG="ZZZ"
"RTN","HLUCM002",152,0)
 I '$$MIXED,COND="EITHER" D
"RTN","HLUCM002",153,0)
 .  QUIT:$$ALL($G(PNMSP),$G(IEN101))  ;-> All 1s or 2s...
"RTN","HLUCM002",154,0)
 .  I NMSPTYPE'=1 D  ; Asked specifically...
"RTN","HLUCM002",155,0)
 .  .  QUIT:PROT]""  ;->
"RTN","HLUCM002",156,0)
 .  .  S PROT="ZZZ~0"
"RTN","HLUCM002",157,0)
 .  I PROTYPE'=1 D  ; Asked specifically...
"RTN","HLUCM002",158,0)
 .  .  QUIT:PCKG]""  ;->
"RTN","HLUCM002",159,0)
 .  .  S PCKG="ZZZ"
"RTN","HLUCM002",160,0)
 ;
"RTN","HLUCM002",161,0)
 ; If neither should be counted, don't...
"RTN","HLUCM002",162,0)
 I 'CTPROT&('CTPCKG) QUIT U ;->
"RTN","HLUCM002",163,0)
 ;
"RTN","HLUCM002",164,0)
 ; Either namespace or protocol matches, or both match...
"RTN","HLUCM002",165,0)
 ;
"RTN","HLUCM002",166,0)
 ; If BOTH namespace and protocol are required to match, don't count if one isn't a match...
"RTN","HLUCM002",167,0)
 I COND="BOTH" I 'CTPROT!('CTPCKG) QUIT U ;->
"RTN","HLUCM002",168,0)
 ;
"RTN","HLUCM002",169,0)
 ; If 1/2 & SPECIFIC (i.e., MIXED), then SPECIFIC trumps 1/2...
"RTN","HLUCM002",170,0)
 ; (If SPECIFIC not matched, it is not counted)
"RTN","HLUCM002",171,0)
 I $$MIXED D  QUIT:FAIL U ;->
"RTN","HLUCM002",172,0)
 .  S FAIL=1
"RTN","HLUCM002",173,0)
 .  ; If ALL NMSPs to be counted, but specific PROT fails... BAD!
"RTN","HLUCM002",174,0)
 .  I $G(PNMSP)=1!($G(PNMSP)=2) QUIT:'CTPROT  ;->
"RTN","HLUCM002",175,0)
 .  ; If ALL PROTs to be counted, but specific PCKG fails... BAD!
"RTN","HLUCM002",176,0)
 .  I $G(IEN101)=1!($G(IEN101)=2) QUIT:'CTPCKG  ;->
"RTN","HLUCM002",177,0)
 .  S FAIL=0
"RTN","HLUCM002",178,0)
 ;
"RTN","HLUCM002",179,0)
 D ACTUAL(IEN772,5,PROT),ACTUAL(IEN772,6,PCKG)
"RTN","HLUCM002",180,0)
 ;
"RTN","HLUCM002",181,0)
 QUIT PROT_U_PCKG
"RTN","HLUCM002",182,0)
 ;
"RTN","HLUCM002",183,0)
ALL(V1,V2) ; Are both 1 or 2?
"RTN","HLUCM002",184,0)
 S V1=$G(V1),V2=$G(V2)
"RTN","HLUCM002",185,0)
 QUIT:V1'=1&(V1'=2) "" ;->
"RTN","HLUCM002",186,0)
 QUIT:V2'=1&(V2'=2) "" ;->
"RTN","HLUCM002",187,0)
 QUIT 1
"RTN","HLUCM002",188,0)
 ;
"RTN","HLUCM002",189,0)
MIXED() ; Is one 1/2 and the other SPECIFIC?
"RTN","HLUCM002",190,0)
 N V3
"RTN","HLUCM002",191,0)
 S V1=$G(PNMSP),V1=$S(V1]"":$S(V1=1!(V1=2):1,1:0),1:0)
"RTN","HLUCM002",192,0)
 S V2=$G(IEN101),V2=$S(V2]"":$S(V2=1!(V2=2):1,1:0),1:0)
"RTN","HLUCM002",193,0)
 S V1=$S(V1=1!(V1=2):1,1:0)
"RTN","HLUCM002",194,0)
 S V2=$S(V2=1!(V2=2):1,1:0)
"RTN","HLUCM002",195,0)
 S V3=V1+V2
"RTN","HLUCM002",196,0)
 QUIT $S(V3=1:1,1:"")
"RTN","HLUCM002",197,0)
 ;
"RTN","HLUCM002",198,0)
CTPCKG(PCKG) ; Should entry be counted on basis of package?
"RTN","HLUCM002",199,0)
 ; (Might be countable if protocol matches remember.)
"RTN","HLUCM002",200,0)
 ; If list of packages passed by reference, is PCKG in array?
"RTN","HLUCM002",201,0)
 ; IEN101,NMSPTYPE,PNMSP -- req
"RTN","HLUCM002",202,0)
 N CTPCKG
"RTN","HLUCM002",203,0)
 ;
"RTN","HLUCM002",204,0)
 ; Must count everything...
"RTN","HLUCM002",205,0)
 I $G(PNMSP)=1!($G(PNMSP)=2) QUIT 1 ;->
"RTN","HLUCM002",206,0)
 ;
"RTN","HLUCM002",207,0)
 ; If passed namspace by array, is PCKG in array?
"RTN","HLUCM002",208,0)
 I NMSPTYPE=1 QUIT $S($$REFPCKG(PCKG):1,1:"") ;->
"RTN","HLUCM002",209,0)
 ;
"RTN","HLUCM002",210,0)
 ; If passed in "0^NAMESPACE" format...
"RTN","HLUCM002",211,0)
 I $$OK0CALL(PNMSP) D  QUIT $S(PCKG]"":1,1:"") ;->
"RTN","HLUCM002",212,0)
 .  I $P(PNMSP,U,2)'=PCKG S PCKG=""
"RTN","HLUCM002",213,0)
 ;
"RTN","HLUCM002",214,0)
 QUIT ""
"RTN","HLUCM002",215,0)
 ;
"RTN","HLUCM002",216,0)
CTPROT(PROT) ; Should entry be counted on basis of protocol?
"RTN","HLUCM002",217,0)
 ; (Might be countable if package matches remember.)
"RTN","HLUCM002",218,0)
 ; IEN,PROTYPE -- req
"RTN","HLUCM002",219,0)
 ;
"RTN","HLUCM002",220,0)
 N CTPROT
"RTN","HLUCM002",221,0)
 ;
"RTN","HLUCM002",222,0)
 ; Must count everything...
"RTN","HLUCM002",223,0)
 I $G(IEN101)=1!($G(IEN101)=2) QUIT 1 ;->
"RTN","HLUCM002",224,0)
 ;
"RTN","HLUCM002",225,0)
 ; If passed protocols by array, is PROT in array?
"RTN","HLUCM002",226,0)
 I PROTYPE=1 QUIT $S($$REFPROT(PROT):1,1:"") ;->
"RTN","HLUCM002",227,0)
 ;
"RTN","HLUCM002",228,0)
 ; If PROT not found, and passed 0^PROTNM or 0^PROTIEN, 
"RTN","HLUCM002",229,0)
 ; can't do anything more...
"RTN","HLUCM002",230,0)
 I $$OK0CALL(IEN101) D  QUIT $S(PROT]"":1,1:"") ;->
"RTN","HLUCM002",231,0)
 .  N VAL
"RTN","HLUCM002",232,0)
 .  QUIT:PROT']""  ;->
"RTN","HLUCM002",233,0)
 .  S VAL=$P(IEN101,U,2)
"RTN","HLUCM002",234,0)
 .  I $P(PROT,"~")'=VAL&($P(PROT,"~",2)'=VAL) S PROT=""
"RTN","HLUCM002",235,0)
 ;
"RTN","HLUCM002",236,0)
 QUIT ""
"RTN","HLUCM002",237,0)
 ;
"RTN","HLUCM002",238,0)
PP() QUIT $G(PROT)_U_$G(PCKG)
"RTN","HLUCM002",239,0)
 ;
"RTN","HLUCM002",240,0)
PROT101(IEN772) ; Return 101 information...
"RTN","HLUCM002",241,0)
 N IEN,MIEN,NM
"RTN","HLUCM002",242,0)
 ;
"RTN","HLUCM002",243,0)
 ; Get normal protocol information
"RTN","HLUCM002",244,0)
 S IEN=$P($G(^HL(772,IEN772,0)),U,10)
"RTN","HLUCM002",245,0)
 S NM=$P($G(^ORD(101,+IEN,0)),U)
"RTN","HLUCM002",246,0)
 ;
"RTN","HLUCM002",247,0)
 ; Maybe this is a Mailman ptr only...
"RTN","HLUCM002",248,0)
 I NM']"",IEN'>0 D
"RTN","HLUCM002",249,0)
 .  S MIEN=$P($G(^HL(772,+IEN772,0)),U,5) QUIT:MIEN'>0  ;->
"RTN","HLUCM002",250,0)
 .  S NM="XMB",IEN=9999999
"RTN","HLUCM002",251,0)
 ;
"RTN","HLUCM002",252,0)
 QUIT $S(NM]""!(IEN>0):NM_"~"_IEN,1:"")
"RTN","HLUCM002",253,0)
 ;
"RTN","HLUCM002",254,0)
REFPROT(PROT) ; If passed by reference, is PROT in array? 0=Don't count, 2=Count
"RTN","HLUCM002",255,0)
 ; PROTYPE -- req
"RTN","HLUCM002",256,0)
 N X
"RTN","HLUCM002",257,0)
 I PROTYPE'=1 QUIT 1 ;-> Not passed by reference...
"RTN","HLUCM002",258,0)
 S X=$P(PROT,"~") I X]"" I $D(IEN101(X)) QUIT 1 ;-> found by name in array
"RTN","HLUCM002",259,0)
 S X=$P(PROT,"~",2) I X]"" I $D(IEN101(+X)) QUIT 1 ;-> found by IEN in array
"RTN","HLUCM002",260,0)
 QUIT ""
"RTN","HLUCM002",261,0)
 ;
"RTN","HLUCM002",262,0)
REFPCKG(PCKG) ; If passed by reference, is PCKG in array? 0=Don't count,1=OK to count
"RTN","HLUCM002",263,0)
 ; NMSPTYPE -- req
"RTN","HLUCM002",264,0)
 I NMSPTYPE'=1 QUIT 1 ;-> Not passed by reference...
"RTN","HLUCM002",265,0)
 I PCKG]"" I $D(PNMSP(PCKG)) QUIT 1 ;-> found in array
"RTN","HLUCM002",266,0)
 QUIT ""
"RTN","HLUCM002",267,0)
 ;
"RTN","HLUCM002",268,0)
ACTUAL(IEN772,PCE,DATA) ; Store data in ^TMP($J,"ACTUAL")
"RTN","HLUCM002",269,0)
 N NEW,NODE,VAL
"RTN","HLUCM002",270,0)
 S (NEW,NODE)=$G(^TMP($J,"ACTUAL",IEN772))
"RTN","HLUCM002",271,0)
 S VAL=$P(NODE,U,PCE) QUIT:DATA=VAL  ;->
"RTN","HLUCM002",272,0)
 S $P(NEW,U,PCE)=DATA
"RTN","HLUCM002",273,0)
 S ^TMP($J,"ACTUAL",IEN772)=NEW
"RTN","HLUCM002",274,0)
 QUIT
"RTN","HLUCM002",275,0)
 ;
"RTN","HLUCM002",276,0)
EOR ; HLUCM002 - HL7/Capacity Mgt API ;2/27/01 10:15
"RTN","HLUCM003")
0^4^B51187698
"RTN","HLUCM003",1,0)
HLUCM003 ;CIOFO-O/LJA - HL7/Capacity Mgt API-II ;10/23/01 12:01
"RTN","HLUCM003",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**88**;Oct 13, 1995
"RTN","HLUCM003",3,0)
 ;
"RTN","HLUCM003",4,0)
LOOP() ; Loop thru 772's .01... (Called from LOOP^HLUCM)
"RTN","HLUCM003",5,0)
 N CTDBG,HLWHERE
"RTN","HLUCM003",6,0)
 ;
"RTN","HLUCM003",7,0)
 S HLWHERE="HLUCM003",CTDBG=0
"RTN","HLUCM003",8,0)
 ;
"RTN","HLUCM003",9,0)
 ; Collect related messages...
"RTN","HLUCM003",10,0)
 D FINDCMII^HLUCM007(START,END) QUIT:'$D(^TMP($J,"CMII")) "" ;->
"RTN","HLUCM003",11,0)
 ; ^TMP($J,"CMII") killed in FINDCMII
"RTN","HLUCM003",12,0)
 ;
"RTN","HLUCM003",13,0)
 ; Find namespace,numberspace for ^TMP($J,"CMII") entries...
"RTN","HLUCM003",14,0)
 D CMIINMNO
"RTN","HLUCM003",15,0)
 ;
"RTN","HLUCM003",16,0)
 ;Lump on basis of MSGID...
"RTN","HLUCM003",17,0)
 D CMIIMORE
"RTN","HLUCM003",18,0)
 ;
"RTN","HLUCM003",19,0)
 ; If debugging, create ^TMP($J,"HLUCMSTORE","E",..) entries, etc
"RTN","HLUCM003",20,0)
 ;D MAKEE
"RTN","HLUCM003",21,0)
 ;
"RTN","HLUCM003",22,0)
 ; Final totalling...
"RTN","HLUCM003",23,0)
 D TOTAL^HLUCM008
"RTN","HLUCM003",24,0)
 ;
"RTN","HLUCM003",25,0)
 ; Debugging actions...
"RTN","HLUCM003",26,0)
 I $G(^TMP($J,"HLUCM"))="DEBUG GLOBAL" D
"RTN","HLUCM003",27,0)
 .  MERGE ^TMP($J,"HLUCMSTORE","U")=^TMP($J,"CMII","N")
"RTN","HLUCM003",28,0)
 .  MERGE ^TMP($J,"HLUCMSTORE","X")=^TMP($J,"CMII","X")
"RTN","HLUCM003",29,0)
 .  MERGE ^TMP($J,"HLUCMSTORE","N")=^TMP($J,"RECNM")
"RTN","HLUCM003",30,0)
 .  D PACKDGBL^HLUCM005(2) ; Pack global...
"RTN","HLUCM003",31,0)
 .  D ADJTIME^HLUCM008 ; Adjust times in units...
"RTN","HLUCM003",32,0)
 .  D OUTLYER^HLUCM007 ; Entries outside STARTtoEND range
"RTN","HLUCM003",33,0)
 ;
"RTN","HLUCM003",34,0)
 I $G(^TMP($J,"HLUCM"))="DEBUG GLOBAL" D HLUCMSHW
"RTN","HLUCM003",35,0)
 ;
"RTN","HLUCM003",36,0)
 KILL ^TMP($J,"CMII")
"RTN","HLUCM003",37,0)
 KILL ^TMP($J,"HLUCM")
"RTN","HLUCM003",38,0)
 KILL ^TMP($J,"RECNM")
"RTN","HLUCM003",39,0)
 ;
"RTN","HLUCM003",40,0)
 QUIT $G(^TMP(TOTALS,$J))
"RTN","HLUCM003",41,0)
 ;
"RTN","HLUCM003",42,0)
OKVAR(I772) ; Set up variables for later.  Leave "hanging around"...
"RTN","HLUCM003",43,0)
 S PP=$$PROTNMSP^HLUCM002(+I772)
"RTN","HLUCM003",44,0)
 I $P(PP,U)']""!($P(PP,U,2)']"") QUIT "" ;->
"RTN","HLUCM003",45,0)
 S TYPEHR=$$TYPETMO^HLUCM002(+I772)
"RTN","HLUCM003",46,0)
 S TYPEIO=$$TYPEIO^HLUCM002(+I772)
"RTN","HLUCM003",47,0)
 S TYPELR=$$TYPELR^HLUCM001(+I772)
"RTN","HLUCM003",48,0)
 QUIT 1
"RTN","HLUCM003",49,0)
 ;
"RTN","HLUCM003",50,0)
MSGIDADD(MSGID) ; Add entries from MSGID to LOAD772...
"RTN","HLUCM003",51,0)
 N CT,HOLD,IEN
"RTN","HLUCM003",52,0)
 QUIT:MSGID']""  ;->
"RTN","HLUCM003",53,0)
 S IEN=0,CT=0
"RTN","HLUCM003",54,0)
 F  S IEN=$O(^HL(772,"C",MSGID,IEN)) Q:IEN'>0!(CT>30)  D
"RTN","HLUCM003",55,0)
 .  QUIT:$P($G(^HL(772,+IEN,0)),U)'?7N.E  ;->
"RTN","HLUCM003",56,0)
 .  S CT=CT+1
"RTN","HLUCM003",57,0)
 .  S HOLD(IEN)=""
"RTN","HLUCM003",58,0)
 QUIT:CT>30  ;->
"RTN","HLUCM003",59,0)
 MERGE ^TMP($J,"LOAD772")=HOLD
"RTN","HLUCM003",60,0)
 QUIT
"RTN","HLUCM003",61,0)
 ;
"RTN","HLUCM003",62,0)
CMIIMORE ;
"RTN","HLUCM003",63,0)
 N IEN772C,IEN772P,IEN772PS,VAL
"RTN","HLUCM003",64,0)
 S IEN772PS=0
"RTN","HLUCM003",65,0)
 F  S IEN772PS=$O(^TMP($J,"C",IEN772PS)) Q:IEN772PS'>0  D
"RTN","HLUCM003",66,0)
 .  S IEN772C=0
"RTN","HLUCM003",67,0)
 .  F  S IEN772C=$O(^TMP($J,"C",IEN772PS,IEN772C)) Q:IEN772C'>0  D
"RTN","HLUCM003",68,0)
 .  .  S IEN772P=0
"RTN","HLUCM003",69,0)
 .  .  F  S IEN772P=$O(^TMP($J,"C",IEN772PS,IEN772C,IEN772P)) Q:IEN772P'>0  D
"RTN","HLUCM003",70,0)
 .  .  .  QUIT:IEN772PS=IEN772P  ;-> Actual = Current
"RTN","HLUCM003",71,0)
 .  .  .  S VAL=$G(^TMP($J,"CMII","N",+IEN772P))
"RTN","HLUCM003",72,0)
 .  .  .  MERGE ^TMP($J,"CMII","N",+IEN772PS,+IEN772C)=^TMP($J,"CMII","N",+IEN772P,+IEN772C)
"RTN","HLUCM003",73,0)
 .  .  .  S ^TMP($J,"CMII","N",+IEN772PS,+IEN772C)=VAL
"RTN","HLUCM003",74,0)
 .  .  .  KILL ^TMP($J,"CMII","N",+IEN772P,+IEN772C)
"RTN","HLUCM003",75,0)
 .  .  .  KILL ^TMP($J,"CMII","N",+IEN772P,+IEN772P)
"RTN","HLUCM003",76,0)
 .  .  .  QUIT:$O(^TMP($J,"CMII","N",+IEN772P,0))>0  ;->
"RTN","HLUCM003",77,0)
 .  .  .  KILL ^TMP($J,"CMII","N",+IEN772P)
"RTN","HLUCM003",78,0)
 ;
"RTN","HLUCM003",79,0)
 KILL ^TMP($J,"C")
"RTN","HLUCM003",80,0)
 ;
"RTN","HLUCM003",81,0)
 ;
"RTN","HLUCM003",82,0)
 QUIT
"RTN","HLUCM003",83,0)
 ;
"RTN","HLUCM003",84,0)
CMIINMNO ; Find namespace and protocol for each "unit"...
"RTN","HLUCM003",85,0)
 N IEN772
"RTN","HLUCM003",86,0)
 S IEN772=0
"RTN","HLUCM003",87,0)
 F  S IEN772=$O(^TMP($J,"CMII","N",IEN772)) Q:IEN772'>0  D
"RTN","HLUCM003",88,0)
 .  S ^TMP($J,"CMII","N",IEN772)=$$UNITS(+IEN772)
"RTN","HLUCM003",89,0)
 QUIT
"RTN","HLUCM003",90,0)
 ;
"RTN","HLUCM003",91,0)
MAKEE ; Loop thru entries, creating ^TMP($J,"HLUCMSTORE","E") data...
"RTN","HLUCM003",92,0)
 N DATA,DBGBL,IEN772,IEN773,LOOP772,PP,TYPEHR,TYPEIO,TYPELR
"RTN","HLUCM003",93,0)
 ;
"RTN","HLUCM003",94,0)
 QUIT:$G(^TMP($J,"HLUCM"))'="DEBUG GLOBAL"  ;->
"RTN","HLUCM003",95,0)
 ;
"RTN","HLUCM003",96,0)
 ; Loop, make E entries...
"RTN","HLUCM003",97,0)
 S LOOP772=0
"RTN","HLUCM003",98,0)
 F  S LOOP772=$O(^TMP($J,"CMII","N",LOOP772)) Q:LOOP772'>0  D
"RTN","HLUCM003",99,0)
 .  S IEN772=0
"RTN","HLUCM003",100,0)
 .  F  S IEN772=$O(^TMP($J,"CMII","N",LOOP772,IEN772)) Q:IEN772'>0  D
"RTN","HLUCM003",101,0)
 .  .  KILL DATA
"RTN","HLUCM003",102,0)
 .  .  QUIT:'$$OKVAR(+LOOP772)  ;-> Creates PP,TYPEHR,TYPEIO,TYPELR
"RTN","HLUCM003",103,0)
 .  .  S DBGBL=1
"RTN","HLUCM003",104,0)
 .  .  D TOT772^HLUCM(+IEN772)
"RTN","HLUCM003",105,0)
 .  .  ; Loop thru all associated 773s and put #s in DATA(...) also...
"RTN","HLUCM003",106,0)
 .  .  S IEN773=0
"RTN","HLUCM003",107,0)
 .  .  F  S IEN773=$O(^TMP($J,"CMII","N",LOOP772,IEN772,IEN773)) Q:IEN773'>0  D
"RTN","HLUCM003",108,0)
 .  .  .  S DBGBL=1 ; Allow E creation...
"RTN","HLUCM003",109,0)
 .  .  .  D TOT773^HLUCM(IEN773)
"RTN","HLUCM003",110,0)
 .  .  MERGE ^TMP($J,"HLUCMSTORE","E")=^TMP("HLUCMSTORE",$J,"E")
"RTN","HLUCM003",111,0)
 .  .  D TMDIFF^HLUCM
"RTN","HLUCM003",112,0)
 .  .  S $P(^TMP($J,"HLUCMSTORE","E",IEN772),U,5)=$G(DATA("CHAR"))_U_1_U_$G(DATA("DIFF"))_U_$G(DATA("START"))_U_$G(DATA("END"))
"RTN","HLUCM003",113,0)
 .  KILL ^TMP("HLUCMSTORE",$J)
"RTN","HLUCM003",114,0)
 ;
"RTN","HLUCM003",115,0)
 KILL ^TMP("HLUCMSTORE",$J)
"RTN","HLUCM003",116,0)
 ;
"RTN","HLUCM003",117,0)
 QUIT
"RTN","HLUCM003",118,0)
 ;
"RTN","HLUCM003",119,0)
DATATM(IEN772) ;
"RTN","HLUCM003",120,0)
 N DBGBL,IEN773
"RTN","HLUCM003",121,0)
 KILL DATA
"RTN","HLUCM003",122,0)
 S DBGBL=0 ; Disallow E entry creation...
"RTN","HLUCM003",123,0)
 D TOT772T^HLUCM(IEN772)
"RTN","HLUCM003",124,0)
 S IEN773=0
"RTN","HLUCM003",125,0)
 F  S IEN773=$O(^HLMA("B",IEN772,IEN773)) Q:IEN773'>0  D
"RTN","HLUCM003",126,0)
 .  D TOT773T^HLUCM(IEN773)
"RTN","HLUCM003",127,0)
 S DATA("START")=$O(DATA("TIME",0))
"RTN","HLUCM003",128,0)
 S DATA("END")=$O(DATA("TIME",":"),-1)
"RTN","HLUCM003",129,0)
 KILL DATA("TIME")
"RTN","HLUCM003",130,0)
 QUIT
"RTN","HLUCM003",131,0)
 ;
"RTN","HLUCM003",132,0)
COLLECT3(LOOP772,IEN772) ; Collect 772 data and associated 773 data...
"RTN","HLUCM003",133,0)
 ; PP,TYPEHR,TYPEIO,TYPELR -- req
"RTN","HLUCM003",134,0)
 N DATA,DBGBL,IEN773,TOT772,TOT772T,TOT773,X
"RTN","HLUCM003",135,0)
 ;
"RTN","HLUCM003",136,0)
 ;S (DATA("PROT"),PROT)=$P(PP,U),PROT=$S(PROT]"":PROT,1:"ZZZ")
"RTN","HLUCM003",137,0)
 ;S (DATA("PCKG"),PCKG)=$P(PP,U,2),PCKG=$S(PCKG]"":PCKG,1:"ZZZ")
"RTN","HLUCM003",138,0)
 ;
"RTN","HLUCM003",139,0)
 ; Place 772 numbers in DATA(...)
"RTN","HLUCM003",140,0)
 ;S DBGBL=0
"RTN","HLUCM003",141,0)
 ;D TOT772^HLUCM(IEN772)
"RTN","HLUCM003",142,0)
 ;
"RTN","HLUCM003",143,0)
 ; Loop thru all associated 773s and put #s in DATA(...) also...
"RTN","HLUCM003",144,0)
 ;S IEN773=0
"RTN","HLUCM003",145,0)
 ;F  S IEN773=$O(^TMP($J,"CMII","N",LOOP772,IEN772,IEN773)) Q:IEN773'>0  D
"RTN","HLUCM003",146,0)
 ;.  D TOT773^HLUCM(IEN773)
"RTN","HLUCM003",147,0)
 ;
"RTN","HLUCM003",148,0)
 ; Data OK?
"RTN","HLUCM003",149,0)
 ;QUIT:$G(DATA("CHAR"))'>0  ;->
"RTN","HLUCM003",150,0)
 ;S DATA("START")=$O(DATA("TIME",0)) QUIT:DATA("START")'>0  ;->
"RTN","HLUCM003",151,0)
 ;
"RTN","HLUCM003",152,0)
 ; A few % of entries have .01 times way out of "kilter"... (?)
"RTN","HLUCM003",153,0)
 ;S X=+$G(^HL(772,+LOOP772,0)) I X>DATA("START") S DATA("START")=X
"RTN","HLUCM003",154,0)
 ;
"RTN","HLUCM003",155,0)
 ;S DATA("END")=$O(DATA("TIME",":"),-1)
"RTN","HLUCM003",156,0)
 ;S DATA("DIFF")=$$SEC^HLUCM(DATA("END"))-$$SEC^HLUCM(DATA("START"))
"RTN","HLUCM003",157,0)
 ;
"RTN","HLUCM003",158,0)
 ; Store DATA() info in ^TMP(TOTALS,$J,...)
"RTN","HLUCM003",159,0)
 ;D ADDTMP^HLUCM001
"RTN","HLUCM003",160,0)
 ;
"RTN","HLUCM003",161,0)
 D COLLECT^HLUCM(IEN772)
"RTN","HLUCM003",162,0)
 ;
"RTN","HLUCM003",163,0)
 ; Store for future corrections...
"RTN","HLUCM003",164,0)
 S DTBEG=DATA("START"),DTEND=DATA("END")
"RTN","HLUCM003",165,0)
 ;
"RTN","HLUCM003",166,0)
 QUIT
"RTN","HLUCM003",167,0)
 ;
"RTN","HLUCM003",168,0)
UNITS(IEN772) ;
"RTN","HLUCM003",169,0)
 N HOLD,IEN,NMSP,PROT,VALUE
"RTN","HLUCM003",170,0)
 ;
"RTN","HLUCM003",171,0)
 ; Ensure IEN772 is evaluated...
"RTN","HLUCM003",172,0)
 D:'$D(^TMP($J,"CMII","N",IEN772,IEN772))
"RTN","HLUCM003",173,0)
 .  S ^TMP($J,"CMII","N",IEN772,IEN772)=""
"RTN","HLUCM003",174,0)
 ;
"RTN","HLUCM003",175,0)
 ; Loop thru IEN772 subentries...
"RTN","HLUCM003",176,0)
 S (HOLD("NMSP"),HOLD("PROT"))=""
"RTN","HLUCM003",177,0)
 S IEN=0
"RTN","HLUCM003",178,0)
 F  S IEN=$O(^TMP($J,"CMII","N",IEN772,IEN)) Q:'IEN  D
"RTN","HLUCM003",179,0)
 .
"RTN","HLUCM003",180,0)
 .  S VALUE=$$PROTNMSP^HLUCM002(IEN772)
"RTN","HLUCM003",181,0)
 .  S PROT=$P(VALUE,U)
"RTN","HLUCM003",182,0)
 .  S:HOLD("PROT")']""&(PROT]"") HOLD("PROT")=PROT
"RTN","HLUCM003",183,0)
 .
"RTN","HLUCM003",184,0)
 .  S NMSP=$P(VALUE,U,2)
"RTN","HLUCM003",185,0)
 .  S:HOLD("NMSP")']""&(NMSP]"") HOLD("NMSP")=NMSP
"RTN","HLUCM003",186,0)
 ;
"RTN","HLUCM003",187,0)
 S HOLD=HOLD("PROT")_U_HOLD("NMSP")
"RTN","HLUCM003",188,0)
 ;
"RTN","HLUCM003",189,0)
 QUIT HOLD
"RTN","HLUCM003",190,0)
 ;
"RTN","HLUCM003",191,0)
LOAD772(IEN772) ;
"RTN","HLUCM003",192,0)
 N N0,PARENT
"RTN","HLUCM003",193,0)
 ;
"RTN","HLUCM003",194,0)
 S N0=$G(^HL(772,+IEN772,0)) Q:N0']""  ;->
"RTN","HLUCM003",195,0)
 S PARENT=$P(N0,U,8),PARENT=$S(PARENT:PARENT,1:IEN772)
"RTN","HLUCM003",196,0)
 QUIT:$P($G(^HL(772,+PARENT,0)),U)'?7N1"."1.N  ;->
"RTN","HLUCM003",197,0)
 ;
"RTN","HLUCM003",198,0)
 ; If there's no 773...
"RTN","HLUCM003",199,0)
 I $O(^HLMA("B",IEN772,0))'>0 D  QUIT  ;->
"RTN","HLUCM003",200,0)
 .  S ^TMP($J,"CMII","N",PARENT,IEN772)=""
"RTN","HLUCM003",201,0)
 ;
"RTN","HLUCM003",202,0)
 S IEN773=0
"RTN","HLUCM003",203,0)
 F  S IEN773=$O(^HLMA("B",IEN772,IEN773)) Q:'IEN773  D
"RTN","HLUCM003",204,0)
 .  D LOAD773C(PARENT,IEN773)
"RTN","HLUCM003",205,0)
 ;
"RTN","HLUCM003",206,0)
 QUIT
"RTN","HLUCM003",207,0)
 ;
"RTN","HLUCM003",208,0)
LOAD773C(IEN772,IEN773) ;
"RTN","HLUCM003",209,0)
 N N0,INITIAL,MSGID
"RTN","HLUCM003",210,0)
 ;
"RTN","HLUCM003",211,0)
 S N0=$G(^HLMA(+IEN773,0)) Q:N0']""  ;->
"RTN","HLUCM003",212,0)
 ;
"RTN","HLUCM003",213,0)
 ; Get 773 IEN for parent of parent and get 772 from it...
"RTN","HLUCM003",214,0)
 S INITIAL=$O(^HLMA("B",IEN772,0))
"RTN","HLUCM003",215,0)
 S X=$P($G(^HLMA(+INITIAL,0)),U,10),INITIAL=$S(X:X,INITIAL:INITIAL,1:IEN773)
"RTN","HLUCM003",216,0)
 S INITIAL(1)=+$G(^HLMA(+INITIAL,0))
"RTN","HLUCM003",217,0)
 S X=$O(^TMP($J,"CMII","X",INITIAL(1),0)),INITIAL=$S(X:+X,1:INITIAL(1))
"RTN","HLUCM003",218,0)
 ;
"RTN","HLUCM003",219,0)
 S MSGID=$P(N0,U,2)
"RTN","HLUCM003",220,0)
 ;
"RTN","HLUCM003",221,0)
 S ^TMP($J,"CMII","N",INITIAL,IEN772,IEN773)=MSGID_U_INITIAL(1)
"RTN","HLUCM003",222,0)
 S ^TMP($J,"CMII","X",IEN772,INITIAL,+$O(^HLMA("B",INITIAL,0)))=""
"RTN","HLUCM003",223,0)
 ;
"RTN","HLUCM003",224,0)
 QUIT
"RTN","HLUCM003",225,0)
 ;
"RTN","HLUCM003",226,0)
HLUCMSTR ; Store debug information...
"RTN","HLUCM003",227,0)
 N TM772
"RTN","HLUCM003",228,0)
 ;
"RTN","HLUCM003",229,0)
 QUIT:$G(^TMP($J,"HLUCM"))'="DEBUG GLOBAL"  ;->
"RTN","HLUCM003",230,0)
 ; (Remember!  this data is killed, including the ^TMP($J,"HLUCM")
"RTN","HLUCM003",231,0)
 ; global which causes the debug data collect at the end of
"RTN","HLUCM003",232,0)
 ; execution of the $$CM call.)
"RTN","HLUCM003",233,0)
 ;
"RTN","HLUCM003",234,0)
 ; store debug info...
"RTN","HLUCM003",235,0)
 S TM772=+$G(^HL(772,+IEN772,0)) Q:TM772'?7N.E  ;->
"RTN","HLUCM003",236,0)
 S:$G(^TMP($J,"HLUCM","FIRST"))']"" ^TMP($J,"HLUCM","FIRST")=TM772
"RTN","HLUCM003",237,0)
 S:$G(^TMP($J,"HLUCM","LAST"))']"" ^TMP($J,"HLUCM","LAST")=TM772
"RTN","HLUCM003",238,0)
 S X=$G(^TMP($J,"HLUCM","FIRST")) I +X>TM772 S ^TMP($J,"HLUCM","FIRST")=TM772
"RTN","HLUCM003",239,0)
 S X=$G(^TMP($J,"HLUCM","LAST")) I +X<TM772 S ^TMP($J,"HLUCM","LAST")=TM772
"RTN","HLUCM003",240,0)
 S ^TMP($J,"HLUCM","TOTAL")=$G(^TMP($J,"HLUCM","TOTAL"))+1
"RTN","HLUCM003",241,0)
 QUIT
"RTN","HLUCM003",242,0)
 ;
"RTN","HLUCM003",243,0)
HLUCMSHW ; Show debug information
"RTN","HLUCM003",244,0)
 QUIT:'$D(^TMP($J,"HLUCM"))  ;->
"RTN","HLUCM003",245,0)
 W !!,"First: ",?20
"RTN","HLUCM003",246,0)
 S X=$G(^TMP($J,"HLUCM","FIRST"))
"RTN","HLUCM003",247,0)
 F  Q:X']""  W $E(X,1,60) S X=$E(X,61,999) W:X]"" !,?20
"RTN","HLUCM003",248,0)
 W !,"Last: ",?20
"RTN","HLUCM003",249,0)
 S X=$G(^TMP($J,"HLUCM","LAST"))
"RTN","HLUCM003",250,0)
 F  Q:X']""  W $E(X,1,60) S X=$E(X,61,999) W:X]"" !,?20
"RTN","HLUCM003",251,0)
 W !,"Number units:",?20,$J($P(^TMP(TOTALS,$J),U,2),7)
"RTN","HLUCM003",252,0)
 W !,"Number entries:",?20,$J($P(^TMP(TOTALS,$J),U,4),7)
"RTN","HLUCM003",253,0)
 W !!
"RTN","HLUCM003",254,0)
 QUIT
"RTN","HLUCM003",255,0)
 ;
"RTN","HLUCM003",256,0)
EOR ; HLUCM003 - HL7/Capacity Mgt API-II ;10/23/01 12:01
"RTN","HLUCM004")
0^7^B66226353
"RTN","HLUCM004",1,0)
HLUCM004 ;CIOFO-O/LJA - HL7/Capacity Mgt API-II ;10/23/01 12:01
"RTN","HLUCM004",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**88**;Oct 13, 1995
"RTN","HLUCM004",3,0)
 ;
"RTN","HLUCM004",4,0)
INFERPR(IEN772,DEFAULT) ; Infer protocol...
"RTN","HLUCM004",5,0)
 N HL772,NUM772,PROTW,RECNM,X
"RTN","HLUCM004",6,0)
 ;
"RTN","HLUCM004",7,0)
 ; This IEN772 already inferred
"RTN","HLUCM004",8,0)
 S X=$P($G(^TMP($J,"ACTUAL",IEN772)),U,2) I X]"" QUIT X ;->
"RTN","HLUCM004",9,0)
 ;
"RTN","HLUCM004",10,0)
 S RECNM=$G(DEFAULT)
"RTN","HLUCM004",11,0)
 ;
"RTN","HLUCM004",12,0)
 S X=$$LOAD772S^HLUCM005(IEN772,.HL772) QUIT:X'>0 $G(DEFAULT) ;->
"RTN","HLUCM004",13,0)
 ;
"RTN","HLUCM004",14,0)
 S NUM772=0,PROTW=""
"RTN","HLUCM004",15,0)
 F  S NUM772=$O(HL772(NUM772)) Q:NUM772'>0!(PROTW]"")  D
"RTN","HLUCM004",16,0)
 .  S PROTW=$P(HL772(NUM772),U,2)
"RTN","HLUCM004",17,0)
 ;
"RTN","HLUCM004",18,0)
 I PROTW]"" D RECNM("[p]",IEN772,RECNM,PROTW,"PROT")
"RTN","HLUCM004",19,0)
 ;
"RTN","HLUCM004",20,0)
 QUIT $S(PROTW]"":PROTW,1:$G(DEFAULT))
"RTN","HLUCM004",21,0)
 ;
"RTN","HLUCM004",22,0)
INFERNM(IEN772,DEFAULT) ; Call here ONLY if can't get PCKG from 101->9.4 linkage
"RTN","HLUCM004",23,0)
 ; PCKG -- req
"RTN","HLUCM004",24,0)
 N HL772,NUM772,PCKGW,PROTW,X
"RTN","HLUCM004",25,0)
 ;
"RTN","HLUCM004",26,0)
 ; This IEN772 already inferred
"RTN","HLUCM004",27,0)
 S X=$P($G(^TMP($J,"ACTUAL",IEN772)),U,4) I X]"" QUIT X ;->
"RTN","HLUCM004",28,0)
 ;
"RTN","HLUCM004",29,0)
 S DEFAULT=$G(DEFAULT),DEFAULT=$S(DEFAULT]"":DEFAULT,1:"ZZZ")
"RTN","HLUCM004",30,0)
 S X=$$LOAD772S^HLUCM005(IEN772,.HL772) QUIT:X'>0 $G(DEFAULT) ;->
"RTN","HLUCM004",31,0)
 ;
"RTN","HLUCM004",32,0)
 S NUM772=0,PCKGW=""
"RTN","HLUCM004",33,0)
 F  S NUM772=$O(HL772(NUM772)) Q:NUM772'>0!(PCKGW]"")  D
"RTN","HLUCM004",34,0)
 .  S PCKGW=$$INFERW(NUM772,$G(DEFAULT)) QUIT:PCKGW]""&(PCKGW'=DEFAULT)  ;->
"RTN","HLUCM004",35,0)
 .
"RTN","HLUCM004",36,0)
 .  ; Final MAIL inferral after all else fails...
"RTN","HLUCM004",37,0)
 .  QUIT:$P($G(^HL(772,+NUM772,0)),U,5)'>0  ;->
"RTN","HLUCM004",38,0)
 .  S PCKGW="XWB"
"RTN","HLUCM004",39,0)
 ;
"RTN","HLUCM004",40,0)
 QUIT $S(PCKGW]"":PCKGW,1:DEFAULT)
"RTN","HLUCM004",41,0)
 ;
"RTN","HLUCM004",42,0)
INFERW(IEN772,DEFAULT) ; Called from $$INFER...
"RTN","HLUCM004",43,0)
 N NAME,PACK,PCKG,PIEN,PROT,RECNM,VALUES
"RTN","HLUCM004",44,0)
 ;
"RTN","HLUCM004",45,0)
 ; See "Final Mail inferral" in above FOR loop...
"RTN","HLUCM004",46,0)
 ;
"RTN","HLUCM004",47,0)
 S VALUES=$$NMSP772(+IEN772)
"RTN","HLUCM004",48,0)
 S NAME=$P(VALUES,U,5)
"RTN","HLUCM004",49,0)
 I NAME]"" QUIT $$FIXNMSP^HLUCM008(NAME,IEN772) ;->
"RTN","HLUCM004",50,0)
 ;
"RTN","HLUCM004",51,0)
 ; Is this an SPR message?  Then, get PCKG by extracting...
"RTN","HLUCM004",52,0)
 ; (Do this BEFORE any other attemps made on MSH, etc)
"RTN","HLUCM004",53,0)
 S PCKG(1)=$$SPR(IEN772)
"RTN","HLUCM004",54,0)
 I PCKG(1)]"" D  QUIT PCKG ;->
"RTN","HLUCM004",55,0)
 .  S PCKG=PCKG(1)
"RTN","HLUCM004",56,0)
 .  S PCKG=$$ADJUST(IEN772,$$FIXNMSP^HLUCM008(PCKG,IEN772))
"RTN","HLUCM004",57,0)
 .  D RECNM("[n]",IEN772,DEFAULT,PCKG,"SPR")
"RTN","HLUCM004",58,0)
 ;
"RTN","HLUCM004",59,0)
 ; Try to get namespace from 773's MSH first...
"RTN","HLUCM004",60,0)
 S PCKG=$$MSH773(IEN772)
"RTN","HLUCM004",61,0)
 I PCKG]"" D  QUIT PCKG ;->
"RTN","HLUCM004",62,0)
 .  S PCKG=$$ADJUST(IEN772,$$FIXNMSP^HLUCM008(PCKG,IEN772))
"RTN","HLUCM004",63,0)
 .  D RECNM("[n]",IEN772,DEFAULT,PCKG,"MSH773")
"RTN","HLUCM004",64,0)
 ;
"RTN","HLUCM004",65,0)
 ; Try to get namespace from 772'S MSH next...
"RTN","HLUCM004",66,0)
 S PCKG=$$MSH772(IEN772)
"RTN","HLUCM004",67,0)
 I PCKG]"" D  QUIT PCKG ;->
"RTN","HLUCM004",68,0)
 .  S PCKG=$$ADJUST(IEN772,$$FIXNMSP^HLUCM008(PCKG,IEN772))
"RTN","HLUCM004",69,0)
 .  D RECNM("[n]",IEN772,DEFAULT,PCKG,"MSH772")
"RTN","HLUCM004",70,0)
 ;
"RTN","HLUCM004",71,0)
 ; Is there a Mail message ptr with a MSH?
"RTN","HLUCM004",72,0)
 S PCKG=$$MSHMAIL(IEN772)
"RTN","HLUCM004",73,0)
 I PCKG]"" D  QUIT PCKG ;->
"RTN","HLUCM004",74,0)
 .  S PCKG=$$ADJUST(IEN772,$$FIXNMSP^HLUCM008(PCKG,IEN772))
"RTN","HLUCM004",75,0)
 .  D RECNM("[n]",IEN772,DEFAULT,PCKG,"MSHMAIL")
"RTN","HLUCM004",76,0)
 ;
"RTN","HLUCM004",77,0)
 ; Maybe, it can be found from the protocol name?
"RTN","HLUCM004",78,0)
 S PCKG=$P(VALUES,U,2)
"RTN","HLUCM004",79,0)
 I PCKG]"" D  QUIT PCKG ;->
"RTN","HLUCM004",80,0)
 .  S RECNM=PCKG
"RTN","HLUCM004",81,0)
 .  S PCKG=$$ADJUST(IEN772,$$FIXNMSP^HLUCM008(PCKG,IEN772))
"RTN","HLUCM004",82,0)
 .  D RECNM("[n]",IEN772,RECNM,PCKG,101)
"RTN","HLUCM004",83,0)
 ;
"RTN","HLUCM004",84,0)
 ; Oh, well!
"RTN","HLUCM004",85,0)
 ;
"RTN","HLUCM004",86,0)
 QUIT $G(DEFAULT)
"RTN","HLUCM004",87,0)
 ;
"RTN","HLUCM004",88,0)
SPR(IEN772) ; Evaluate SPR segment for RPC for package, possible
"RTN","HLUCM004",89,0)
 ; resetting the PCKG variable...
"RTN","HLUCM004",90,0)
 ; PCKG -- req
"RTN","HLUCM004",91,0)
 N CHAR,DEL,IN
"RTN","HLUCM004",92,0)
 S IN=$G(^HL(772,+IEN772,"IN",1,0))
"RTN","HLUCM004",93,0)
 QUIT:$E(IN,1,4)'="SPR^" "" ;->
"RTN","HLUCM004",94,0)
 QUIT:IN'["REMOTE RPC^" "" ;->
"RTN","HLUCM004",95,0)
 S DEL=$E(IN,4)
"RTN","HLUCM004",96,0)
 S IN=$P(IN,DEL,5) QUIT:IN']"" "" ;->
"RTN","HLUCM004",97,0)
 S IN=$P(IN,"003RPC",2) QUIT:IN']"" "" ;->
"RTN","HLUCM004",98,0)
 S CHAR=+IN,IN=$TR($E(IN,4,CHAR+4),"&","") QUIT:IN']"" "" ;->
"RTN","HLUCM004",99,0)
 I $E(IN,1,2)="IB" D  QUIT "IB" ;->
"RTN","HLUCM004",100,0)
 .  D RECNM("[n]",IEN772,IN,"IB","SPR")
"RTN","HLUCM004",101,0)
 I $E(IN,1,2)="OR" D  QUIT "OR" ;->
"RTN","HLUCM004",102,0)
 .  D RECNM("[n]",IEN772,IN,"OR","SPR")
"RTN","HLUCM004",103,0)
 QUIT ""
"RTN","HLUCM004",104,0)
 ;
"RTN","HLUCM004",105,0)
RECNM(PFX,IEN772,FULLNM,REPNM,SRCE) ; Record where name found...
"RTN","HLUCM004",106,0)
 ; PFX - [n] for namespace, and [p] for protocol
"RTN","HLUCM004",107,0)
 ; IEN772 - IEN of 772
"RTN","HLUCM004",108,0)
 ; FULLNM - What is in entry itself, uninferred...
"RTN","HLUCM004",109,0)
 ; REPNM - What is to be reported
"RTN","HLUCM004",110,0)
 ; SRCE - Where it was inferred from
"RTN","HLUCM004",111,0)
 ;
"RTN","HLUCM004",112,0)
 QUIT:$G(^TMP($J,"HLUCM"))'="DEBUG GLOBAL"  ;->
"RTN","HLUCM004",113,0)
 ;
"RTN","HLUCM004",114,0)
 S REPNM=$G(PFX)_REPNM
"RTN","HLUCM004",115,0)
 ;
"RTN","HLUCM004",116,0)
 S ^TMP($J,"RECNM")=$G(^TMP($J,"RECNM"))+1
"RTN","HLUCM004",117,0)
 S ^TMP($J,"RECNM",REPNM)=$G(^TMP($J,"RECNM",REPNM))+1
"RTN","HLUCM004",118,0)
 S ^TMP($J,"RECNM",REPNM,SRCE)=$G(^TMP($J,"RECNM",REPNM,SRCE))+1
"RTN","HLUCM004",119,0)
 S ^TMP($J,"RECNM",REPNM,SRCE,IEN772)=FULLNM
"RTN","HLUCM004",120,0)
 ;
"RTN","HLUCM004",121,0)
 QUIT
"RTN","HLUCM004",122,0)
 ;
"RTN","HLUCM004",123,0)
MSHMAIL(IEN772) ;
"RTN","HLUCM004",124,0)
 N CT,INOUT,MIEN,NIEN,PCKG,RECNM,TXT,X,XMER,XMPOS,XMRG,XMZ
"RTN","HLUCM004",125,0)
 S MIEN=$P($G(^HL(772,+IEN772,0)),U,5) QUIT:MIEN'>0 "" ;->
"RTN","HLUCM004",126,0)
 S INOUT=$P(^HL(772,+IEN772,0),U,4)
"RTN","HLUCM004",127,0)
 S INOUT=$S(INOUT="I":5,1:3)
"RTN","HLUCM004",128,0)
 S CT=0,PCKG="",XMZ=+MIEN,XMER=0
"RTN","HLUCM004",129,0)
 F  D  QUIT:CT>10!(PCKG]"")!($E(TXT,1,3)="MSH")!(XMER'=0)
"RTN","HLUCM004",130,0)
 .  S CT=CT+1
"RTN","HLUCM004",131,0)
 .  D REC^XMS3
"RTN","HLUCM004",132,0)
 .  S TXT=$G(XMRG) QUIT:$E(TXT,1,3)'="MSH"  ;->
"RTN","HLUCM004",133,0)
 .  S X=$E(TXT,4),RECNM=$P(TXT,X,INOUT)
"RTN","HLUCM004",134,0)
 .  S PCKG=$$PCKGMSH(TXT,INOUT)
"RTN","HLUCM004",135,0)
 .  D RECNM("[n]",IEN772,RECNM,PCKG,"MAIL")
"RTN","HLUCM004",136,0)
 QUIT PCKG
"RTN","HLUCM004",137,0)
 ;
"RTN","HLUCM004",138,0)
MSH772(IEN772) ; Get PCKG from MSH segment in 772...
"RTN","HLUCM004",139,0)
 ; Call here ONLY if can't get MSH segment from 773...
"RTN","HLUCM004",140,0)
 N CT,IN,INOUT,PCKG,RECNM,TXT,X
"RTN","HLUCM004",141,0)
 S IN=0,CT=0,PCKG=""
"RTN","HLUCM004",142,0)
 S INOUT=$$INOUT(+IEN772)
"RTN","HLUCM004",143,0)
 F  S IN=$O(^HL(772,+IEN772,"IN",IN)) Q:IN'>0!(CT>10)!(PCKG]"")  D
"RTN","HLUCM004",144,0)
 .  S CT=CT+1
"RTN","HLUCM004",145,0)
 .  S TXT=$G(^HL(772,+IEN772,"IN",+IN,0)) QUIT:TXT']""  ;->
"RTN","HLUCM004",146,0)
 .  QUIT:$E(TXT,1,3)'="MSH"  ;->
"RTN","HLUCM004",147,0)
 .  S X=$E(TXT,4),RECNM=$P(TXT,X,INOUT)
"RTN","HLUCM004",148,0)
 .  S PCKG=$$PCKGMSH(TXT,INOUT)
"RTN","HLUCM004",149,0)
 .  D RECNM("[n]",IEN772,RECNM,PCKG,772)
"RTN","HLUCM004",150,0)
 QUIT PCKG
"RTN","HLUCM004",151,0)
 ;
"RTN","HLUCM004",152,0)
MSH773(IEN772) ; Get PCKG from MSH segment in 773...
"RTN","HLUCM004",153,0)
 N IEN773,INOUT,MSH,PCKG,RECNM,X
"RTN","HLUCM004",154,0)
 S IEN773=$O(^HLMA("B",IEN772,0)) QUIT:IEN773'>0 "" ;->
"RTN","HLUCM004",155,0)
 S INOUT=$$INOUT(IEN772)
"RTN","HLUCM004",156,0)
 S MSH=$G(^HLMA(+IEN773,"MSH",1,0)) QUIT:MSH']"" "" ;->
"RTN","HLUCM004",157,0)
 S X=$E(MSH,4),RECNM=$P(MSH,X,INOUT)
"RTN","HLUCM004",158,0)
 S PCKG=$$PCKGMSH(MSH,INOUT)
"RTN","HLUCM004",159,0)
 D RECNM("[n]",IEN772,RECNM,PCKG,773)
"RTN","HLUCM004",160,0)
 QUIT PCKG
"RTN","HLUCM004",161,0)
 ;
"RTN","HLUCM004",162,0)
INOUT(IEN772) ;
"RTN","HLUCM004",163,0)
 N INOUT
"RTN","HLUCM004",164,0)
 S INOUT=$P($G(^HL(772,+IEN772,0)),U,4)
"RTN","HLUCM004",165,0)
 S INOUT=$S(INOUT="I":5,1:3) ; Default to O, which is case in HEC error
"RTN","HLUCM004",166,0)
 QUIT INOUT
"RTN","HLUCM004",167,0)
 ;
"RTN","HLUCM004",168,0)
PCKGMSH(MSH,INOUT) ; Extract PCKG namespace from MSH segment
"RTN","HLUCM004",169,0)
 N DEL,PFROM
"RTN","HLUCM004",170,0)
 S DEL=$E(MSH,4),INOUT=$S($G(INOUT):INOUT,1:3)
"RTN","HLUCM004",171,0)
 S PFROM=$P(MSH,DEL,INOUT) QUIT:PFROM']"" "" ;->
"RTN","HLUCM004",172,0)
 QUIT $$FIXNMSP^HLUCM008(PFROM)
"RTN","HLUCM004",173,0)
 ;
"RTN","HLUCM004",174,0)
ADJUST(IEN772,PCKG) ; Miscellaneous final adjustments and fixes...
"RTN","HLUCM004",175,0)
 ;
"RTN","HLUCM004",176,0)
 ; None, now...
"RTN","HLUCM004",177,0)
 ;
"RTN","HLUCM004",178,0)
 QUIT PCKG
"RTN","HLUCM004",179,0)
 ;
"RTN","HLUCM004",180,0)
DEBUGP ; Display debug data...
"RTN","HLUCM004",181,0)
 N COL,SUB
"RTN","HLUCM004",182,0)
 S SUB=$$SUBDBG QUIT:SUB']""  ;->
"RTN","HLUCM004",183,0)
 D DEBUGC(SUB,15)
"RTN","HLUCM004",184,0)
 QUIT
"RTN","HLUCM004",185,0)
 ;
"RTN","HLUCM004",186,0)
SUBDBG() ;
"RTN","HLUCM004",187,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLUCM004",188,0)
 S DIR(0)="S^1:Print TMP($J,""HLUCMSTORE"",""E"") data;2:Print TMP($J,""HLUCMSTORE"",""U"") data;3:Print TMP($J,""HLUCMSTORE"",""X"") data;4:Quit"
"RTN","HLUCM004",189,0)
 D ^DIR
"RTN","HLUCM004",190,0)
 QUIT:$D(DIRUT)!($D(DTOUT))!($D(DUOUT)) "" ;->
"RTN","HLUCM004",191,0)
 QUIT:+Y=4 "" ;->
"RTN","HLUCM004",192,0)
 QUIT:+Y<1 "" ;->
"RTN","HLUCM004",193,0)
 QUIT $P("E^U^X",U,+Y)
"RTN","HLUCM004",194,0)
 ;
"RTN","HLUCM004",195,0)
DEBUGC(SUB,COL) ; Display debug data
"RTN","HLUCM004",196,0)
 S SUB=$E($G(SUB)_" ") QUIT:"EUX"'[SUB  ;->
"RTN","HLUCM004",197,0)
 S COL=$S($G(COL):+COL,1:15)
"RTN","HLUCM004",198,0)
 I SUB="E" D DEBUGE^HLUCM008(COL)
"RTN","HLUCM004",199,0)
 I SUB="U" D DEBUGU(COL)
"RTN","HLUCM004",200,0)
 I SUB="X" D DEBUGX(COL)
"RTN","HLUCM004",201,0)
 QUIT
"RTN","HLUCM004",202,0)
 ;
"RTN","HLUCM004",203,0)
DEBUGU(COL) ; Print ^TMP($J,"HLUCMSTORE","U") data...
"RTN","HLUCM004",204,0)
 N CT,DATA,GBL,IEN772,IEN773,LP772,POSX
"RTN","HLUCM004",205,0)
 S GBL="^TMP("_$J_",""HLUCMSTORE"",""U"")"
"RTN","HLUCM004",206,0)
 S IEN772=0
"RTN","HLUCM004",207,0)
 F  S IEN772=$O(@GBL@(IEN772)) Q:IEN772'>0  D
"RTN","HLUCM004",208,0)
 .  W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLUCM004",209,0)
 .  W !,IEN772," "
"RTN","HLUCM004",210,0)
 .  S POSX=$X
"RTN","HLUCM004",211,0)
 .  D PRT(POSX,$G(@GBL@(IEN772)))
"RTN","HLUCM004",212,0)
 .  S LP772=0
"RTN","HLUCM004",213,0)
 .  F  S LP772=$O(@GBL@(IEN772,LP772)) Q:LP772'>0  D
"RTN","HLUCM004",214,0)
 .  .  D PRT(POSX,LP772_": "_$G(@GBL@(IEN772,LP772))_$$CHAR773(IEN772,LP772))
"RTN","HLUCM004",215,0)
 QUIT
"RTN","HLUCM004",216,0)
 ;
"RTN","HLUCM004",217,0)
CHAR773(IEN772,LP772) ; Number characters in associated 773s...
"RTN","HLUCM004",218,0)
 N CHAR,IEN773
"RTN","HLUCM004",219,0)
 S IEN773=0,CHAR=0
"RTN","HLUCM004",220,0)
 F  S IEN773=$O(^TMP($J,"HLUCMSTORE","U",IEN772,LP772,IEN773)) Q:IEN773'>0  D
"RTN","HLUCM004",221,0)
 .  S CHAR=CHAR+$G(^TMP($J,"HLUCMSTORE","U",IEN772,LP772,IEN773))
"RTN","HLUCM004",222,0)
 QUIT $S(CHAR:" ["_CHAR_"]",1:"")
"RTN","HLUCM004",223,0)
 ;
"RTN","HLUCM004",224,0)
DEBUGX(COL) ; Print ^TMP($J,"HLUCMSTORE","X") data...
"RTN","HLUCM004",225,0)
 N CHILD,GBL,I773,PARENT
"RTN","HLUCM004",226,0)
 W !!,"Child 772",?16,"Parent 772",?32,"Child 772s Associated 773s"
"RTN","HLUCM004",227,0)
 W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLUCM004",228,0)
 S GBL="^TMP("_$J_",""HLUCMSTORE"",""X"")"
"RTN","HLUCM004",229,0)
 S CHILD=0
"RTN","HLUCM004",230,0)
 F  S CHILD=$O(@GBL@(CHILD)) Q:CHILD'>0  D
"RTN","HLUCM004",231,0)
 .  W !,CHILD
"RTN","HLUCM004",232,0)
 .  S PARENT=0
"RTN","HLUCM004",233,0)
 .  F  S PARENT=$O(@GBL@(CHILD,PARENT)) Q:PARENT'>0  D
"RTN","HLUCM004",234,0)
 .  .  W:$X>16 ! W:$X<16 ?16
"RTN","HLUCM004",235,0)
 .  .  W "-> ",PARENT
"RTN","HLUCM004",236,0)
 .  .  QUIT:$O(@GBL@(CHILD,PARENT,0))'>0  ;->
"RTN","HLUCM004",237,0)
 .  .  W:$X>32 ! W:$X<32 ?32
"RTN","HLUCM004",238,0)
 .  .  S I773=0
"RTN","HLUCM004",239,0)
 .  .  F  S I773=$O(@GBL@(CHILD,PARENT,I773)) Q:I773'>0  D
"RTN","HLUCM004",240,0)
 .  .  .  I ($X+$L(I773)+2)>IOM W !,?32
"RTN","HLUCM004",241,0)
 .  .  .  W:$X>32 ", "
"RTN","HLUCM004",242,0)
 .  .  .  W I773
"RTN","HLUCM004",243,0)
 QUIT
"RTN","HLUCM004",244,0)
 ;
"RTN","HLUCM004",245,0)
PRT(COL,DATA) ; Print data...
"RTN","HLUCM004",246,0)
 W:$X>COL ! W:$X<COL ?COL
"RTN","HLUCM004",247,0)
 F  Q:DATA']""  D
"RTN","HLUCM004",248,0)
 .  W:$X>COL ! W:$X<COL ?COL
"RTN","HLUCM004",249,0)
 .  S DATA(1)=$E(DATA,IOM-$X+1,999)
"RTN","HLUCM004",250,0)
 .  W $E(DATA,1,IOM-$X)
"RTN","HLUCM004",251,0)
 .  S DATA=DATA(1),DATA=$S(DATA]"":"  "_DATA,1:"")
"RTN","HLUCM004",252,0)
 QUIT
"RTN","HLUCM004",253,0)
 ;
"RTN","HLUCM004",254,0)
NMSP772(IEN772) ; Return 101-IEN ^ 101-NAME ^ PCKG-IEN ^ PCKG-NMSP
"RTN","HLUCM004",255,0)
 N MIEN,NAME,PACK,PROT
"RTN","HLUCM004",256,0)
 ;
"RTN","HLUCM004",257,0)
 S MIEN=$P($G(^HL(772,+IEN772,0)),U,5)
"RTN","HLUCM004",258,0)
 ;
"RTN","HLUCM004",259,0)
 S PROT=$P($G(^HL(772,+IEN772,0)),U,10) QUIT:'MIEN&(PROT'>0) "" ;->
"RTN","HLUCM004",260,0)
 S PROT(1)=$P($G(^ORD(101,+PROT,0)),U) QUIT:'MIEN&(PROT(1)']"") "" ;->
"RTN","HLUCM004",261,0)
 S PACK=$P($G(^ORD(101,+PROT,0)),U,12) QUIT:'MIEN&(PACK'>0) PROT_U_PROT(1) ;->
"RTN","HLUCM004",262,0)
 S PACK(1)=$$NMSP94^HLUCM001(+PACK),NAME=$P(PACK(1),U,2),PACK(1)=$P(PACK(1),U)
"RTN","HLUCM004",263,0)
 QUIT:'MIEN&(PACK(1)']"") PROT_U_PROT(1) ;->
"RTN","HLUCM004",264,0)
 ;
"RTN","HLUCM004",265,0)
 ; Give it a pseudo mail protocol
"RTN","HLUCM004",266,0)
 I 'PROT,MIEN S PROT=9999999,PROT(1)="XWB"
"RTN","HLUCM004",267,0)
 ;
"RTN","HLUCM004",268,0)
 QUIT $G(PROT)_U_$G(PROT(1))_U_$G(PACK)_U_$G(PACK(1))_U_$G(NAME)
"RTN","HLUCM004",269,0)
 ;
"RTN","HLUCM004",270,0)
EOR ; HLUCM004 - HL7/Capacity Mgt API-II ;10/23/01 12:01
"RTN","HLUCM005")
0^8^B71964861
"RTN","HLUCM005",1,0)
HLUCM005 ;CIOFO-O/LJA - HL7/Capacity Mgt API-II ;10/23/01 12:01
"RTN","HLUCM005",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**88**;Oct 13, 1995
"RTN","HLUCM005",3,0)
 ;
"RTN","HLUCM005",4,0)
LOAD772S(IEN772,HLNMSP) ; Load list of related 772s... [HL*1.6*91]
"RTN","HLUCM005",5,0)
 ;
"RTN","HLUCM005",6,0)
 ; Warning!!!  This call point will never load more than 20 entries...
"RTN","HLUCM005",7,0)
 ;             Any more than that, and probably an error condition
"RTN","HLUCM005",8,0)
 ;             exists.
"RTN","HLUCM005",9,0)
 ;
"RTN","HLUCM005",10,0)
 N ACKTO,DATA,HL772,HLI,HLJ,HLK,HLN,HLPCKG,HLZZI,HOLDNMSP,I,I772,I773
"RTN","HLUCM005",11,0)
 N MSGID,NUM,PCKG,PIEN,PROT,TOTNUM,X
"RTN","HLUCM005",12,0)
 ;
"RTN","HLUCM005",13,0)
 KILL HLNMSP
"RTN","HLUCM005",14,0)
 QUIT:$G(^HL(772,+$G(IEN772),0))']"" "" ;->
"RTN","HLUCM005",15,0)
 S HLNMSP="",HLNMSP(IEN772)="",NUM=1
"RTN","HLUCM005",16,0)
 ;
"RTN","HLUCM005",17,0)
 S DATA=$G(^HL(772,+$G(IEN772),0)) QUIT:DATA']"" "" ;->
"RTN","HLUCM005",18,0)
 ;
"RTN","HLUCM005",19,0)
 ; Loop until no new entries found or more than 20 entries...
"RTN","HLUCM005",20,0)
 S TOTNUM=0
"RTN","HLUCM005",21,0)
 F  D  QUIT:NUM'>NUM(1)!(TOTNUM>19)
"RTN","HLUCM005",22,0)
 .  S NUM(1)=NUM ; Set NUM(1) = # entries found "now"...
"RTN","HLUCM005",23,0)
 .  KILL HOLDNMSP
"RTN","HLUCM005",24,0)
 .  S I772=0
"RTN","HLUCM005",25,0)
 .  F  S I772=$O(HLNMSP(I772)) Q:I772'>0!(TOTNUM>19)  D
"RTN","HLUCM005",26,0)
 .  .  S DATA=$G(^HL(772,+$G(I772),0)) QUIT:DATA']""  ;->
"RTN","HLUCM005",27,0)
 .  .
"RTN","HLUCM005",28,0)
 .  .  ; MSG ID search...
"RTN","HLUCM005",29,0)
 .  .  S MSGID=$P(DATA,U,6)
"RTN","HLUCM005",30,0)
 .  .  I MSGID]"" D
"RTN","HLUCM005",31,0)
 .  .  .  S HLZZI=0 F  S HLZZI=$O(^HL(772,"C",MSGID,HLZZI)) Q:'HLZZI!(TOTNUM>19)  I HLZZI'=IEN772 D HOLDTOT(HLZZI)
"RTN","HLUCM005",32,0)
 .  .  .  D MSGID(MSGID)
"RTN","HLUCM005",33,0)
 .  .  ; 773 MSG ID search...
"RTN","HLUCM005",34,0)
 .  .  S I773=+$O(^HLMA("B",I772,0)) I I773 D
"RTN","HLUCM005",35,0)
 .  .  .  S MSGID=$P($G(^HLMA(+I773,0)),U,2) QUIT:MSGID']""  ;->
"RTN","HLUCM005",36,0)
 .  .  .  S I773(1)=0
"RTN","HLUCM005",37,0)
 .  .  .  F  S I773(1)=$O(^HLMA("C",MSGID,I773(1))) Q:I773(1)'>0!(TOTNUM>19)  D
"RTN","HLUCM005",38,0)
 .  .  .  .  S X=+$G(^HLMA(+I773(1),0)) I X D HOLDTOT(+X)
"RTN","HLUCM005",39,0)
 .  .  .  KILL I773(1)
"RTN","HLUCM005",40,0)
 .  .  .  D MSGID(MSGID)
"RTN","HLUCM005",41,0)
 .  .
"RTN","HLUCM005",42,0)
 .  .  ;
"RTN","HLUCM005",43,0)
 .  .  ; ACK TO search...
"RTN","HLUCM005",44,0)
 .  .  I $P(DATA,U,7)>0,$P(DATA,U,7)'=IEN772 D
"RTN","HLUCM005",45,0)
 .  .  .  D HOLDTOT(+$P(DATA,U,7))
"RTN","HLUCM005",46,0)
 .  .  I I773 D
"RTN","HLUCM005",47,0)
 .  .  .  S ACKTO=$P($G(^HLMA(+I773,0)),U,10) QUIT:ACKTO'>0  ;->
"RTN","HLUCM005",48,0)
 .  .  .  S X=+$G(^HLMA(+ACKTO,0)) I X D HOLDTOT(+X)
"RTN","HLUCM005",49,0)
 .  .  ;
"RTN","HLUCM005",50,0)
 .  .  ; PARENT search...
"RTN","HLUCM005",51,0)
 .  .  I $P(DATA,U,8)>0,$P(DATA,U,8)'=IEN772 D
"RTN","HLUCM005",52,0)
 .  .  .  D HOLDTOT(+$P(DATA,U,8))
"RTN","HLUCM005",53,0)
 .  .  I I773 D
"RTN","HLUCM005",54,0)
 .  .  .  S PIEN=$P($G(^HLMA(+I773,0)),U,6) QUIT:PIEN'>0  ;->
"RTN","HLUCM005",55,0)
 .  .  .  S X=+$G(^HLMA(+PIEN,0)) I X D HOLDTOT(+X)
"RTN","HLUCM005",56,0)
 .  .
"RTN","HLUCM005",57,0)
 .  .  MERGE HLNMSP=HOLDNMSP
"RTN","HLUCM005",58,0)
 .  .  KILL HOLDNMSP
"RTN","HLUCM005",59,0)
 .
"RTN","HLUCM005",60,0)
 .  S I=0,NUM=0 F  S I=$O(HLNMSP(I)) Q:'I  S NUM=NUM+1
"RTN","HLUCM005",61,0)
 ;
"RTN","HLUCM005",62,0)
 ; Loop/set NMSP
"RTN","HLUCM005",63,0)
 S HLI=0,HLN=""
"RTN","HLUCM005",64,0)
 F  S HLI=$O(HLNMSP(HLI)) Q:HLI'>0  D
"RTN","HLUCM005",65,0)
 .  N PCKG,PROT,VALUES
"RTN","HLUCM005",66,0)
 .
"RTN","HLUCM005",67,0)
 .  S VALUES=$$NMSP772^HLUCM004(+HLI)
"RTN","HLUCM005",68,0)
 .
"RTN","HLUCM005",69,0)
 .  ;What is namespace of entry?
"RTN","HLUCM005",70,0)
 .  S HLJ=$P($G(^HL(772,+HLI,0)),U,13)
"RTN","HLUCM005",71,0)
 .  I HLJ']"" S HLJ=$P(VALUES,U,5)
"RTN","HLUCM005",72,0)
 .
"RTN","HLUCM005",73,0)
 .
"RTN","HLUCM005",74,0)
 .  ; What is protocol of entry?
"RTN","HLUCM005",75,0)
 .  S HLK=""
"RTN","HLUCM005",76,0)
 .  S PROT=+VALUES
"RTN","HLUCM005",77,0)
 .  I PROT>0 S HLK=$P(VALUES,U,2)_"~"_PROT
"RTN","HLUCM005",78,0)
 .
"RTN","HLUCM005",79,0)
 .  ;Make HLNMSP(HLI) reflect actual data
"RTN","HLUCM005",80,0)
 .  S HLNMSP(HLI)=HLJ_U_HLK
"RTN","HLUCM005",81,0)
 .
"RTN","HLUCM005",82,0)
 .  ; Set HLN (default namespace) 1st time a namespace found...
"RTN","HLUCM005",83,0)
 .  I HLJ]"",$P(HLNMSP,U)']"" S $P(HLNMSP,U)=HLJ
"RTN","HLUCM005",84,0)
 .
"RTN","HLUCM005",85,0)
 .  ; Set HLP (default protocol) 1st time a protocol found...
"RTN","HLUCM005",86,0)
 .  I HLK]"",$P(HLNMSP,U,2)']"" S $P(HLNMSP,U,2)=HLK
"RTN","HLUCM005",87,0)
 ;
"RTN","HLUCM005",88,0)
 QUIT NUM
"RTN","HLUCM005",89,0)
 ;
"RTN","HLUCM005",90,0)
HOLDTOT(IEN) ; Accumulate...
"RTN","HLUCM005",91,0)
 QUIT:$D(HOLDNMSP(IEN))!(TOTNUM>19)  ;->
"RTN","HLUCM005",92,0)
 S HOLDNMSP(IEN)="",TOTNUM=TOTNUM+1
"RTN","HLUCM005",93,0)
 QUIT
"RTN","HLUCM005",94,0)
 ;
"RTN","HLUCM005",95,0)
MSGID(MSGID) ; Search forward for MSA's to this MSGID...
"RTN","HLUCM005",96,0)
 N BIEN,CT,D,HOLD,I772,I773,MSA,X
"RTN","HLUCM005",97,0)
 ;
"RTN","HLUCM005",98,0)
 S X=$O(^HL(772,"C",MSGID,0)) I X S HOLD(X)=""
"RTN","HLUCM005",99,0)
 S X=$O(^HLMA("C",MSGID,0)) I X S X=+$G(^HLMA(+X,0)) I X S HOLD(X)=""
"RTN","HLUCM005",100,0)
 ;
"RTN","HLUCM005",101,0)
 S CT=0
"RTN","HLUCM005",102,0)
 S BIEN=$O(HOLD(0)) Q:BIEN'>0  ;->
"RTN","HLUCM005",103,0)
 F  S BIEN=$O(^HL(772,BIEN)) Q:BIEN'>0!(CT>10)  D
"RTN","HLUCM005",104,0)
 .  S CT=CT+1
"RTN","HLUCM005",105,0)
 .  S MSA=$G(^HL(772,BIEN,"IN",1,0)) QUIT:$E(MSA,1,4)'="MSA^"  ;->
"RTN","HLUCM005",106,0)
 .  S D=$E(MSA,4),MSGID(1)=$P(MSA,D,3)
"RTN","HLUCM005",107,0)
 .  QUIT:MSGID(1)']""!(MSGID(1)'=MSGID)  ;->
"RTN","HLUCM005",108,0)
 .  S HLNMSP(BIEN)=""
"RTN","HLUCM005",109,0)
 ;
"RTN","HLUCM005",110,0)
 KILL MSGID(1)
"RTN","HLUCM005",111,0)
 ;
"RTN","HLUCM005",112,0)
 QUIT
"RTN","HLUCM005",113,0)
 ;
"RTN","HLUCM005",114,0)
PACKDGBL(API) ; Pack ^TMP($J,"HLUCMSTORE") data
"RTN","HLUCM005",115,0)
 ; API=1 if $$CM, 2 if $$CM2
"RTN","HLUCM005",116,0)
 ;
"RTN","HLUCM005",117,0)
 D PACKN ;^TMP($J,"HLUCMSTORE","N")
"RTN","HLUCM005",118,0)
 D RETOTE^HLUCM006
"RTN","HLUCM005",119,0)
 D PACKE ;^TMP($J,"HLUCMSTORE","E")
"RTN","HLUCM005",120,0)
 I API=2 D
"RTN","HLUCM005",121,0)
 .  D PACKU ;^TMP($J,"HLUCMSTORE","U")
"RTN","HLUCM005",122,0)
 .  D RETOTU^HLUCM006
"RTN","HLUCM005",123,0)
 D ACTUAL^HLUCM007 ; Move protocol and namespace data into piece 7-10
"RTN","HLUCM005",124,0)
 ;
"RTN","HLUCM005",125,0)
 QUIT
"RTN","HLUCM005",126,0)
 ;
"RTN","HLUCM005",127,0)
PACKN ; Pack ^TMP($J,"RECNM") data...
"RTN","HLUCM005",128,0)
 N FULLNM,GBL,IEN772,SOURCE,SUB,TYPE,USED
"RTN","HLUCM005",129,0)
 ;
"RTN","HLUCM005",130,0)
 S GBL="^TMP("_$J_",""HLUCMSTORE"",""N"")"
"RTN","HLUCM005",131,0)
 ;
"RTN","HLUCM005",132,0)
 S TYPE=""
"RTN","HLUCM005",133,0)
 F  S TYPE=$O(@GBL@(TYPE)) Q:TYPE']""  D
"RTN","HLUCM005",134,0)
 .  S SUB=$$UP^XLFSTR($P($P(TYPE,"[",2),"]")) QUIT:SUB']""!("NP"'[SUB)  ;->
"RTN","HLUCM005",135,0)
 .  S USED=$P(TYPE,"]",2) QUIT:USED']""  ;->
"RTN","HLUCM005",136,0)
 .  S SOURCE=""
"RTN","HLUCM005",137,0)
 .  F  S SOURCE=$O(@GBL@(TYPE,SOURCE)) Q:SOURCE']""  D
"RTN","HLUCM005",138,0)
 .  .  S IEN772=0
"RTN","HLUCM005",139,0)
 .  .  F  S IEN772=$O(@GBL@(TYPE,SOURCE,IEN772)) Q:IEN772'>0  D
"RTN","HLUCM005",140,0)
 .  .  .  S FULLNM=$G(@GBL@(TYPE,SOURCE,IEN772))
"RTN","HLUCM005",141,0)
 .  .  .  D MOVENP
"RTN","HLUCM005",142,0)
 ;
"RTN","HLUCM005",143,0)
 KILL @GBL
"RTN","HLUCM005",144,0)
 ;
"RTN","HLUCM005",145,0)
 QUIT
"RTN","HLUCM005",146,0)
 ;
"RTN","HLUCM005",147,0)
MOVENP ; Called from PACKN...
"RTN","HLUCM005",148,0)
 ; FULLNM,GBL,IEN772,SOURCE,SUB,TYPE,USED -- req
"RTN","HLUCM005",149,0)
 N NODE
"RTN","HLUCM005",150,0)
 ;
"RTN","HLUCM005",151,0)
 S NODE=$G(^TMP($J,"HLUCMSTORE","E",+IEN772)) QUIT:NODE']""  ;->
"RTN","HLUCM005",152,0)
 ;
"RTN","HLUCM005",153,0)
 ; Add info to NODE
"RTN","HLUCM005",154,0)
 I SUB="N" D
"RTN","HLUCM005",155,0)
 .  D ADD(9,USED)
"RTN","HLUCM005",156,0)
 .  D ADD(10,SOURCE_"~"_FULLNM)
"RTN","HLUCM005",157,0)
 I SUB="P" D
"RTN","HLUCM005",158,0)
 .  D ADD(7,USED)
"RTN","HLUCM005",159,0)
 .  D ADD(8,SOURCE)
"RTN","HLUCM005",160,0)
 ;
"RTN","HLUCM005",161,0)
 ; Store NODE in global...
"RTN","HLUCM005",162,0)
 S ^TMP($J,"HLUCMSTORE","E",+IEN772)=NODE
"RTN","HLUCM005",163,0)
 ;
"RTN","HLUCM005",164,0)
 QUIT
"RTN","HLUCM005",165,0)
 ;
"RTN","HLUCM005",166,0)
PACKE ; Pack ^TMP($J,"HLUCMSTORE","E") data...
"RTN","HLUCM005",167,0)
 N IEN772
"RTN","HLUCM005",168,0)
 S IEN772=0
"RTN","HLUCM005",169,0)
 F  S IEN772=$O(^TMP($J,"HLUCMSTORE","E",IEN772)) Q:IEN772'>0  D
"RTN","HLUCM005",170,0)
 .  D PACKE1^HLUCM008(+IEN772)
"RTN","HLUCM005",171,0)
 QUIT
"RTN","HLUCM005",172,0)
 ;
"RTN","HLUCM005",173,0)
PACKU ; Pack ^TMP($J,"HLUCMSTORE","U") data...
"RTN","HLUCM005",174,0)
 N BEG,CT,DATA,DATAE,DATAN,DIFF,END,IEN772
"RTN","HLUCM005",175,0)
 N LP772,LP773,PCE,TIME,TOT,X
"RTN","HLUCM005",176,0)
 ;
"RTN","HLUCM005",177,0)
 S IEN772=0
"RTN","HLUCM005",178,0)
 F  S IEN772=$O(^TMP($J,"HLUCMSTORE","U",IEN772)) Q:IEN772'>0  D
"RTN","HLUCM005",179,0)
 .  S DATAE=$G(^TMP($J,"HLUCMSTORE","E",+IEN772)) QUIT:DATAE']""  ;->
"RTN","HLUCM005",180,0)
 .  S DATAN="" ; Root U node...
"RTN","HLUCM005",181,0)
 .  S $P(DATAN,U,6)=$$PACKMSG(IEN772)
"RTN","HLUCM005",182,0)
 .  F PCE=7:1:10 S $P(DATAN,U,PCE)=$P(DATAE,U,PCE)
"RTN","HLUCM005",183,0)
 .
"RTN","HLUCM005",184,0)
 .  ; build rest of pieces by calculating/finding/totalling
"RTN","HLUCM005",185,0)
 .
"RTN","HLUCM005",186,0)
 .  KILL TIME
"RTN","HLUCM005",187,0)
 .  S LP772=0,TOT=0,CT=0
"RTN","HLUCM005",188,0)
 .  F  S LP772=$O(^TMP($J,"HLUCMSTORE","U",IEN772,LP772)) Q:'LP772  D
"RTN","HLUCM005",189,0)
 .  .  ; 1st LP772 will be root (same as IEN772)...
"RTN","HLUCM005",190,0)
 .  .  S CT=CT+1
"RTN","HLUCM005",191,0)
 .  .
"RTN","HLUCM005",192,0)
 .  .  ; Make sure U node exists...
"RTN","HLUCM005",193,0)
 .  .  S DATA=$G(^TMP($J,"HLUCMSTORE","E",+LP772))
"RTN","HLUCM005",194,0)
 .  .  S $P(DATA,U)=$P($G(^TMP($J,"HLUCMSTORE","E",+LP772,772)),U)
"RTN","HLUCM005",195,0)
 .  .  ;I '($D(^TMP($J,"HLUCMSTORE","U",+IEN772,+LP772))#2) D
"RTN","HLUCM005",196,0)
 .  .  S ^TMP($J,"HLUCMSTORE","U",+IEN772,+LP772)=DATA
"RTN","HLUCM005",197,0)
 .  .
"RTN","HLUCM005",198,0)
 .  .  ; If this 772 has characters, add to TOT for root U...
"RTN","HLUCM005",199,0)
 .  .  S:$P(DATA,U) TOT=TOT+$P(DATA,U)
"RTN","HLUCM005",200,0)
 .  .
"RTN","HLUCM005",201,0)
 .  .  ; Get TIMEs for use on root U...
"RTN","HLUCM005",202,0)
 .  .  S X=$P(DATA,U,4) I X S TIME(X)=""
"RTN","HLUCM005",203,0)
 .  .  S X=$P(DATA,U,5) I X S TIME(X)=""
"RTN","HLUCM005",204,0)
 .  .
"RTN","HLUCM005",205,0)
 .  .  ; Loop thru 773s... Incr TOT, get TIMEs, set 773 node...
"RTN","HLUCM005",206,0)
 .  .  S LP773=0
"RTN","HLUCM005",207,0)
 .  .  F  S LP773=$O(^TMP($J,"HLUCMSTORE","U",IEN772,LP772,LP773)) Q:'LP773  D
"RTN","HLUCM005",208,0)
 .  .  .  S TOT(1)=^TMP($J,"HLUCMSTORE","E",LP772,773,LP773)
"RTN","HLUCM005",209,0)
 .  .  .  S TOT=TOT+TOT(1)
"RTN","HLUCM005",210,0)
 .  .  .  S ^TMP($J,"HLUCMSTORE","U",IEN772,LP772,LP773)=TOT(1)
"RTN","HLUCM005",211,0)
 .  .  .  S X=$P($G(^HLMA(+LP773,"S")),U) I X?7N.E S TIME(X)=""
"RTN","HLUCM005",212,0)
 .  .
"RTN","HLUCM005",213,0)
 .  .  ; All subnodes set.  Update TOT & TIME-like pieces of root U...
"RTN","HLUCM005",214,0)
 .  I TOT>0 S $P(DATAN,U)=TOT ; Total #2 characters for all 772s, 773s
"RTN","HLUCM005",215,0)
 .  I CT>0 S $P(DATAN,U,2)=CT ; # 772s (including children)
"RTN","HLUCM005",216,0)
 .  S BEG=$O(TIME(0)),END=$O(TIME(":"),-1)
"RTN","HLUCM005",217,0)
 .
"RTN","HLUCM005",218,0)
 .  ; Sometimes times are out of "kilter"... (?)
"RTN","HLUCM005",219,0)
 .  ;S X=+$G(^HL(772,+IEN772,0)) I BEG<X S BEG=X
"RTN","HLUCM005",220,0)
 .  ;S X=$O(^TMP($J,"HLUCMSTORE","U",+IEN772,":"),-1),Y=$P($G(^TMP($J,"HLUCMSTORE","U",+IEN772,+X)),U,5) I END<Y S END=Y
"RTN","HLUCM005",221,0)
 .
"RTN","HLUCM005",222,0)
 .  S DIFF=$$SEC^HLUCM(END)-$$SEC^HLUCM(BEG),DIFF=$S(DIFF>0:+DIFF,1:0)
"RTN","HLUCM005",223,0)
 .  S $P(DATAN,U,3)=DIFF
"RTN","HLUCM005",224,0)
 .  S $P(DATAN,U,4)=BEG,$P(DATAN,U,5)=END
"RTN","HLUCM005",225,0)
 .  S ^TMP($J,"HLUCMSTORE","U",IEN772)=DATAN
"RTN","HLUCM005",226,0)
 ;
"RTN","HLUCM005",227,0)
 QUIT
"RTN","HLUCM005",228,0)
 ;
"RTN","HLUCM005",229,0)
PACKMSG(IEN772) ;
"RTN","HLUCM005",230,0)
 N CT,GRP,LP772,TYPE
"RTN","HLUCM005",231,0)
 S GRP="",LP772=0,CT=0
"RTN","HLUCM005",232,0)
 F  S LP772=$O(^TMP($J,"HLUCMSTORE","U",IEN772,LP772)) Q:LP772'>0  D
"RTN","HLUCM005",233,0)
 .  ;I '$D(^TMP($J,"HLUCMSTORE","E",+LP772)) W LP772," " QUIT
"RTN","HLUCM005",234,0)
 .  S TYPE=$P(^TMP($J,"HLUCMSTORE","E",+LP772),U,6)
"RTN","HLUCM005",235,0)
 .  S GRP=GRP_TYPE_"~"
"RTN","HLUCM005",236,0)
 .  S CT=CT+1 S:CT>6 GRP=CT
"RTN","HLUCM005",237,0)
 I $E(GRP,$L(GRP))="~" S GRP=$E(GRP,1,$L(GRP)-1)
"RTN","HLUCM005",238,0)
 QUIT GRP
"RTN","HLUCM005",239,0)
 ;
"RTN","HLUCM005",240,0)
ADD(PCE,DATA) ; Store DATA in piece PCE of NODE...
"RTN","HLUCM005",241,0)
 ; NODE -- req
"RTN","HLUCM005",242,0)
 S $P(NODE,U,+PCE)=$G(DATA)
"RTN","HLUCM005",243,0)
 QUIT
"RTN","HLUCM005",244,0)
 ;
"RTN","HLUCM005",245,0)
TMDIFF(IEN772) ; Seconds difference?
"RTN","HLUCM005",246,0)
 N DIFF,END,I773,START,TIME,X
"RTN","HLUCM005",247,0)
 S X=$P($G(^HL(772,+IEN772,0)),U) I X?7N.E S TIME(X)=""
"RTN","HLUCM005",248,0)
 S X=$P($G(^HL(772,+IEN772,"P")),U,2) I X?7N.E S TIME(X)=""
"RTN","HLUCM005",249,0)
 S I773=0
"RTN","HLUCM005",250,0)
 F  S I773=$O(^HLMA("B",IEN772,I773)) Q:I773'>0  D
"RTN","HLUCM005",251,0)
 .  S X=$P($G(^HLMA(+I773,"S")),U) I X?7N.E S TIME(X)=""
"RTN","HLUCM005",252,0)
 S START=$O(TIME(0)),END=$O(TIME(":"),-1)
"RTN","HLUCM005",253,0)
 I START D ADD(4,START) ; Start time
"RTN","HLUCM005",254,0)
 I END D ADD(5,END) ; End time
"RTN","HLUCM005",255,0)
 S DIFF=$$SEC^HLUCM(END)-$$SEC^HLUCM(START)
"RTN","HLUCM005",256,0)
 QUIT $S(DIFF<0:0,1:+DIFF)
"RTN","HLUCM005",257,0)
 ;
"RTN","HLUCM005",258,0)
MSGTYPE(IEN772) ; MSG or MSA's type...
"RTN","HLUCM005",259,0)
 N DEL,IN
"RTN","HLUCM005",260,0)
 S IN=$G(^HL(772,+IEN772,"IN",1,0)) QUIT:IN']"" "" ;->
"RTN","HLUCM005",261,0)
 S DEL=$E(IN,4) QUIT:DEL']"" "" ;->
"RTN","HLUCM005",262,0)
 S IN=$P(IN,DEL,2) QUIT:IN']"" "" ;->
"RTN","HLUCM005",263,0)
 I $L(IN)=2,$E(IN)="C"!($E(IN)="A") QUIT IN ;->
"RTN","HLUCM005",264,0)
 QUIT "MSG"
"RTN","HLUCM005",265,0)
 ;
"RTN","HLUCM005",266,0)
EOR ; HLUCM005 - HL7/Capacity Mgt API-II ;10/23/01 12:01
"RTN","HLUCM006")
0^9^B67137843
"RTN","HLUCM006",1,0)
HLUCM006 ;CIOFO-O/LJA - HL7/Capacity Mgt API-II ;6/9/02 18:37
"RTN","HLUCM006",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**88**;Oct 13, 1995
"RTN","HLUCM006",3,0)
 ;
"RTN","HLUCM006",4,0)
REMOTE ; Call here to add 'REMOTE' to ^TMP($J,"HLUCMSTORE")
"RTN","HLUCM006",5,0)
 ;
"RTN","HLUCM006",6,0)
 ; Please refer to the CORR (corrections) and EXCL (exclusions)
"RTN","HLUCM006",7,0)
 ; subroutines below.  These subroutines adds data to 
"RTN","HLUCM006",8,0)
 ; ^XTMP("HLUCMSTORE").  If you add entries in the same format to
"RTN","HLUCM006",9,0)
 ; ^XTMP("HLUCMSTORE") prior to running $$CM or $$CM2, the corrections
"RTN","HLUCM006",10,0)
 ; or exclusions you add will be used by this subroutine in determining
"RTN","HLUCM006",11,0)
 ; the 'REMOTE' value to use.
"RTN","HLUCM006",12,0)
 ;
"RTN","HLUCM006",13,0)
 ; All data placed in the ^XTMP("HLUCMSTORE") global will be vaporized
"RTN","HLUCM006",14,0)
 ; in T+2 days.
"RTN","HLUCM006",15,0)
 ;
"RTN","HLUCM006",16,0)
 N HLAPI,I772,LOCAL,LOCALDNS,STANOL
"RTN","HLUCM006",17,0)
 QUIT:'$D(^TMP($J,"HLUCMSTORE"))  ;->
"RTN","HLUCM006",18,0)
 S HLAPI=$S($D(^TMP($J,"HLUCMSTORE","U")):2,1:1)
"RTN","HLUCM006",19,0)
 I HLAPI=1 D  ; Set up U global required for processing
"RTN","HLUCM006",20,0)
 .  S I772=0
"RTN","HLUCM006",21,0)
 .  F  S I772=$O(^TMP($J,"HLUCMSTORE","E",I772)) Q:'I772  D
"RTN","HLUCM006",22,0)
 .  .  S ^TMP($J,"HLUCMSTORE","U",I772,I772)=""
"RTN","HLUCM006",23,0)
 D XTMP
"RTN","HLUCM006",24,0)
 D CORR,EXCL ; Corrections and Exclusions
"RTN","HLUCM006",25,0)
 D LOCVAR
"RTN","HLUCM006",26,0)
 D READY
"RTN","HLUCM006",27,0)
 D CREDIT^HLUCM008
"RTN","HLUCM006",28,0)
 D BEST
"RTN","HLUCM006",29,0)
 D FINAL
"RTN","HLUCM006",30,0)
 I HLAPI=1 KILL ^TMP($J,"HLUCMSTORE","U")
"RTN","HLUCM006",31,0)
 KILL ^TMP($J,"REMOTE"),^TMP($J,"STORE")
"RTN","HLUCM006",32,0)
 QUIT
"RTN","HLUCM006",33,0)
 ;
"RTN","HLUCM006",34,0)
LOCVAR ; Set up LOCAL variables...
"RTN","HLUCM006",35,0)
 N DOMAINL,DOMIENL,STAIENL,STANML,VAL
"RTN","HLUCM006",36,0)
 S VAL=$$VAL($P($$SITE^VASITE,U,3))
"RTN","HLUCM006",37,0)
 S STANOL=+VAL,STAIENL=$P(VAL,U,2),STANML=$P(VAL,U,3)
"RTN","HLUCM006",38,0)
 S DOMIENL=$P(VAL,U,4),DOMAINL=$P(VAL,U,5)
"RTN","HLUCM006",39,0)
 S (LOCAL,LOCALDNS)=$P($$RETURN(DOMAINL,STANOL,STANML),"~DNS")
"RTN","HLUCM006",40,0)
 S $P(LOCALDNS,"~",3)="LOCAL"
"RTN","HLUCM006",41,0)
 S LOCAL=LOCALDNS ; No difference now!
"RTN","HLUCM006",42,0)
 QUIT
"RTN","HLUCM006",43,0)
 ;
"RTN","HLUCM006",44,0)
XTMP ; Set up XTMP global
"RTN","HLUCM006",45,0)
 ; Up vaporization date 2 days every time call here...
"RTN","HLUCM006",46,0)
 ; Set zero node first, if never set...
"RTN","HLUCM006",47,0)
 D:$G(^XTMP("HLUCMSTORE",0))']""
"RTN","HLUCM006",48,0)
 .  S ^XTMP("HLUCMSTORE",0)=$$FMADD^XLFDT(DT,2)_U_$$NOW^XLFDT_U_"HL7/Capacity Mgt API"_U_DUZ
"RTN","HLUCM006",49,0)
 S $P(^XTMP("HLUCMSTORE",0),U)=$$FMADD^XLFDT(DT,2)
"RTN","HLUCM006",50,0)
 QUIT
"RTN","HLUCM006",51,0)
 ;
"RTN","HLUCM006",52,0)
BEST ; Find the best STORE form to use...
"RTN","HLUCM006",53,0)
 N FIND,STANO,STORE,X
"RTN","HLUCM006",54,0)
 S STANO=0
"RTN","HLUCM006",55,0)
 F  S STANO=$O(^TMP($J,"STORE",STANO)) Q:STANO'>0  D
"RTN","HLUCM006",56,0)
 .  S STORE="",FIND=""
"RTN","HLUCM006",57,0)
 .  F  S STORE=$O(^TMP($J,"STORE",STANO,STORE)) Q:STORE']""!(FIND]"")  D
"RTN","HLUCM006",58,0)
 .  .  QUIT:STORE'?1.E1"."1.E1"."1.E1"~DNS"&(STORE'=LOCALDNS)  ;->
"RTN","HLUCM006",59,0)
 .  .  S FIND=STORE
"RTN","HLUCM006",60,0)
 .  QUIT:FIND']""  ;->
"RTN","HLUCM006",61,0)
 .  S STORE=""
"RTN","HLUCM006",62,0)
 .  F  S STORE=$O(^TMP($J,"STORE",STANO,STORE)) Q:STORE']""  D
"RTN","HLUCM006",63,0)
 .  .  S ^TMP($J,"STORE",+STANO,STORE)=FIND
"RTN","HLUCM006",64,0)
 QUIT
"RTN","HLUCM006",65,0)
 ;
"RTN","HLUCM006",66,0)
READY ; Get globals ready...
"RTN","HLUCM006",67,0)
 KILL ^TMP($J,"REMOTE"),^TMP($J,"STORE"),^TMP($J,"TOT")
"RTN","HLUCM006",68,0)
 KILL ^XTMP("HLUCMSTORE","TOT")
"RTN","HLUCM006",69,0)
 QUIT
"RTN","HLUCM006",70,0)
 ;
"RTN","HLUCM006",71,0)
FINAL ;
"RTN","HLUCM006",72,0)
 N I772,IEN772,STORE
"RTN","HLUCM006",73,0)
 S I772=0
"RTN","HLUCM006",74,0)
 F  S I772=$O(^TMP($J,"HLUCMSTORE","U",I772)) Q:I772'>0  D
"RTN","HLUCM006",75,0)
 .  S STORE=$G(^TMP($J,"REMOTE",I772)) QUIT:STORE']""  ;->
"RTN","HLUCM006",76,0)
 .  S STORE(1)=$G(^TMP($J,"STORE",+STORE,STORE))
"RTN","HLUCM006",77,0)
 .  I STORE(1)]"",STORE(1)'=STORE S STORE=STORE(1)
"RTN","HLUCM006",78,0)
 .  S $P(^TMP($J,"HLUCMSTORE","E",I772),U,11)=STORE
"RTN","HLUCM006",79,0)
 .  S $P(^TMP($J,"HLUCMSTORE","U",I772),U,11)=STORE
"RTN","HLUCM006",80,0)
 .  S IEN772=0
"RTN","HLUCM006",81,0)
 .  F  S IEN772=$O(^TMP($J,"HLUCMSTORE","U",I772,IEN772)) Q:IEN772'>0  D
"RTN","HLUCM006",82,0)
 .  .  QUIT:+I772=+IEN772  ;->
"RTN","HLUCM006",83,0)
 .  .  QUIT:'$D(^TMP($J,"HLUCMSTORE","E",IEN772))  ;->
"RTN","HLUCM006",84,0)
 .  .  S $P(^TMP($J,"HLUCMSTORE","E",IEN772),U,11)=STORE
"RTN","HLUCM006",85,0)
 QUIT
"RTN","HLUCM006",86,0)
 ;
"RTN","HLUCM006",87,0)
CONVERT(VAL) ; Remove ~DNS for local and add ~DNS if not.
"RTN","HLUCM006",88,0)
 ; LOCAL,STORE -- req
"RTN","HLUCM006",89,0)
 N HLX
"RTN","HLUCM006",90,0)
 I VAL]"" S HLX=$G(^XTMP("HLUCMSTORE","CHG",VAL)) I HLX]"" S VAL=HLX
"RTN","HLUCM006",91,0)
 I VAL[LOCAL QUIT LOCAL ;-> Strip off any ~DNS entries
"RTN","HLUCM006",92,0)
 I VAL'?1.3N1"~"1.E D  QUIT VAL  ;->
"RTN","HLUCM006",93,0)
 .  QUIT:+VAL'=+LOCAL  ;->
"RTN","HLUCM006",94,0)
 .  S HLX=$E(VAL,4,99) QUIT:$L(HLX)>2  ;->
"RTN","HLUCM006",95,0)
 .  QUIT:HLX'?1U.1N  ;->
"RTN","HLUCM006",96,0)
 .  S VAL=LOCALDNS
"RTN","HLUCM006",97,0)
 I VAL["~DNS" QUIT VAL ;->
"RTN","HLUCM006",98,0)
 I VAL?1.E1"."1.E1"."1.E S $P(VAL,"~",3)="DNS"
"RTN","HLUCM006",99,0)
 QUIT VAL
"RTN","HLUCM006",100,0)
 ;
"RTN","HLUCM006",101,0)
EXTRACT(TYPE,MSH) ; Return what should be used for remote site
"RTN","HLUCM006",102,0)
 N DEL
"RTN","HLUCM006",103,0)
 S DEL=$E(MSH,4)
"RTN","HLUCM006",104,0)
 QUIT $P(MSH,DEL,$S(TYPE="I":4,1:6))
"RTN","HLUCM006",105,0)
 ;
"RTN","HLUCM006",106,0)
MSHFIND(IEN772,LOCAL) ;
"RTN","HLUCM006",107,0)
 N FIND,I772,MSH,REMOTE
"RTN","HLUCM006",108,0)
 S I772=0,FIND=""
"RTN","HLUCM006",109,0)
 F  S I772=$O(^TMP($J,"HLUCMSTORE","U",IEN772,I772)) Q:'I772!(FIND]"")  D
"RTN","HLUCM006",110,0)
 .  S FIND=$$MSH(+I772) QUIT:FIND']""  ;->
"RTN","HLUCM006",111,0)
 .  S FIND=$P($G(^HL(772,+I772,0)),U,4)_"~~"_FIND
"RTN","HLUCM006",112,0)
 QUIT $S(FIND]"":FIND,1:LOCAL)
"RTN","HLUCM006",113,0)
 ;
"RTN","HLUCM006",114,0)
MSH(IEN772) ;
"RTN","HLUCM006",115,0)
 N IEN773,MIEN
"RTN","HLUCM006",116,0)
 ;
"RTN","HLUCM006",117,0)
 ; Try Mailman message...
"RTN","HLUCM006",118,0)
 S MIEN=$P($G(^HL(772,+IEN772,0)),U,5)
"RTN","HLUCM006",119,0)
 I MIEN>0 QUIT $$MSHMAIL(+MIEN) ;->
"RTN","HLUCM006",120,0)
 ;
"RTN","HLUCM006",121,0)
 ; Try 773...
"RTN","HLUCM006",122,0)
 S IEN773=$O(^HLMA("B",+IEN772,0))
"RTN","HLUCM006",123,0)
 I IEN773>0 QUIT $G(^HLMA(+IEN773,"MSH",1,0)) ;->
"RTN","HLUCM006",124,0)
 ;
"RTN","HLUCM006",125,0)
 QUIT $$MSH772(IEN772)
"RTN","HLUCM006",126,0)
 ;
"RTN","HLUCM006",127,0)
MSH772(IEN772) ;
"RTN","HLUCM006",128,0)
 N TXT
"RTN","HLUCM006",129,0)
 S TXT=$G(^HL(772,+IEN772,"IN",1,0))
"RTN","HLUCM006",130,0)
 QUIT:$E(TXT,1,3)'="MSH" "" ;->
"RTN","HLUCM006",131,0)
 QUIT TXT
"RTN","HLUCM006",132,0)
 ;
"RTN","HLUCM006",133,0)
MSHMAIL(MIEN) ;
"RTN","HLUCM006",134,0)
 N XMER,XMPOS,XMRG,XMZ
"RTN","HLUCM006",135,0)
 S XMZ=MIEN
"RTN","HLUCM006",136,0)
 D REC^XMS3
"RTN","HLUCM006",137,0)
 S XMRG=$G(XMRG)
"RTN","HLUCM006",138,0)
 QUIT $S($E(XMRG,1,3)="MSH":XMRG,1:"")
"RTN","HLUCM006",139,0)
 ;
"RTN","HLUCM006",140,0)
VAL(STANO) ;
"RTN","HLUCM006",141,0)
 N DO,DA,DATA,DIC,DIQ,DOMAIN,DOMIEN,DR,HLX,STAIEN,STANM,VAL
"RTN","HLUCM006",142,0)
 S STAIEN=$$STAIEN(STANO) QUIT:STAIEN'>0 "" ;->
"RTN","HLUCM006",143,0)
 S DA=+STAIEN,DIC=4,DR=".01;60",DIQ="DATA(",DIQ(0)="IE"
"RTN","HLUCM006",144,0)
 D EN^DIQ1
"RTN","HLUCM006",145,0)
 S STANM=$G(DATA(4,+STAIEN,.01,"E"))
"RTN","HLUCM006",146,0)
 S DOMIEN=$G(DATA(4,+STAIEN,60,"I"))
"RTN","HLUCM006",147,0)
 KILL DA,DIC,DIQ,DR
"RTN","HLUCM006",148,0)
 S DA=+DOMIEN,DIC=4.2,DR=".01",DIQ="DATA(",DIQ(0)="E"
"RTN","HLUCM006",149,0)
 D EN^DIQ1
"RTN","HLUCM006",150,0)
 S DOMAIN=$G(DATA(4.2,+DOMIEN,.01,"E"))
"RTN","HLUCM006",151,0)
 S VAL=STANO_U_STAIEN_U_STANM_U_DOMIEN_U_DOMAIN
"RTN","HLUCM006",152,0)
 QUIT VAL
"RTN","HLUCM006",153,0)
 ;
"RTN","HLUCM006",154,0)
STAIEN(STANO) ; From station number, find file 4 IEN...
"RTN","HLUCM006",155,0)
 N D,DIC,X,Y
"RTN","HLUCM006",156,0)
 QUIT:STANO']"" "" ;->
"RTN","HLUCM006",157,0)
 S DIC="^DIC(4,",DIC(0)="M",X=STANO,D="D"
"RTN","HLUCM006",158,0)
 D MIX^DIC1
"RTN","HLUCM006",159,0)
 QUIT $S(+Y>0:+Y,1:"")
"RTN","HLUCM006",160,0)
 ;
"RTN","HLUCM006",161,0)
RECORD(BEFORE,AFTER) ;
"RTN","HLUCM006",162,0)
 N PREVAFTR
"RTN","HLUCM006",163,0)
 QUIT:BEFORE=AFTER  ;->
"RTN","HLUCM006",164,0)
 S:BEFORE']"" BEFORE=" "
"RTN","HLUCM006",165,0)
 S ^XTMP("HLUCMSTORE","TOT",BEFORE)=$G(^XTMP("HLUCMSTORE","TOT",BEFORE))+1
"RTN","HLUCM006",166,0)
 S PREVAFTR=$P(^XTMP("HLUCMSTORE","TOT",BEFORE),U,2)
"RTN","HLUCM006",167,0)
 S $P(^XTMP("HLUCMSTORE","TOT",BEFORE),U,2)=$S($L(PREVAFTR)>$L(AFTER):PREVAFTR,1:AFTER)
"RTN","HLUCM006",168,0)
 QUIT
"RTN","HLUCM006",169,0)
 ;
"RTN","HLUCM006",170,0)
CORR ; Always used corrections.  Add more to ^XTMP("HLUCMSTORE","CHG") as needed
"RTN","HLUCM006",171,0)
 N A,B,I,T F I=2:1 S T=$T(CORR+I) QUIT:T'[";;"  S T=$P(T,";;",2,99),A=$P(T,U),B=$P(T,U,2),^XTMP("HLUCMSTORE","CHG",A)=B
"RTN","HLUCM006",172,0)
 ;;528~V02.MED.VA.GOV~DNS^528~UPSTATE NEW YORK HCS
"RTN","HLUCM006",173,0)
 ;;200~FHIE.MED.VA.GOV~DNS^AUSTIN
"RTN","HLUCM006",174,0)
 QUIT
"RTN","HLUCM006",175,0)
 ;
"RTN","HLUCM006",176,0)
EXCL ; Always used exclusions from correction.
"RTN","HLUCM006",177,0)
 N A,I,T F I=2:1 S T=$T(EXCL+I) QUIT:T'[";;"  S T=$P(T,";;",2,99),A=$P(T,U),^XTMP("HLUCMSTORE","EXCL",A)=""
"RTN","HLUCM006",178,0)
 ;;MPI
"RTN","HLUCM006",179,0)
 QUIT
"RTN","HLUCM006",180,0)
 ;
"RTN","HLUCM006",181,0)
RETURN(DOMAIN,STANO,STANM) ;
"RTN","HLUCM006",182,0)
 QUIT $S(DOMAIN]"":STANO_"~"_DOMAIN_"~DNS",STANM]"":STANO_"~"_STANM_"~DNS",1:STANO)
"RTN","HLUCM006",183,0)
 ;
"RTN","HLUCM006",184,0)
RETOTE ; Retotal ^TMP($J,"HLUCMSTORE","E") data...
"RTN","HLUCM006",185,0)
 N CT,I772,I773,SUB,T772,T773,TOT,TOTAL
"RTN","HLUCM006",186,0)
 S I772=0
"RTN","HLUCM006",187,0)
 F  S I772=$O(^TMP($J,"HLUCMSTORE","E",I772)) Q:'I772  D
"RTN","HLUCM006",188,0)
 .  S SUB=$O(^TMP($J,"HLUCMSTORE","E",I772,772,"TM",""))
"RTN","HLUCM006",189,0)
 .  S (T772,TOTAL)=$S(SUB]"":+$G(^TMP($J,"HLUCMSTORE","E",I772,772,"TM",SUB)),1:0)
"RTN","HLUCM006",190,0)
 .  S I773=0,CT=0
"RTN","HLUCM006",191,0)
 .  F  S I773=$O(^TMP($J,"HLUCMSTORE","E",I772,773,I773)) Q:I773'>0  D
"RTN","HLUCM006",192,0)
 .  .  S CT=CT+1
"RTN","HLUCM006",193,0)
 .  .  S T773=+$G(^TMP($J,"HLUCMSTORE","E",I772,773,I773))
"RTN","HLUCM006",194,0)
 .  .  S TOTAL=TOTAL+T773+$S(CT>1:T772,1:0)
"RTN","HLUCM006",195,0)
 .  S $P(^TMP($J,"HLUCMSTORE","E",I772),U)=TOTAL
"RTN","HLUCM006",196,0)
 QUIT
"RTN","HLUCM006",197,0)
 ;
"RTN","HLUCM006",198,0)
RETOTU ; Retotal ^TMP($J,"HLUCMSTORE","U") data...
"RTN","HLUCM006",199,0)
 N CHAR,I772,IEN772,SEC,TOTAL,TOTC,TOTS,TOTU
"RTN","HLUCM006",200,0)
 ;
"RTN","HLUCM006",201,0)
 S I772=0
"RTN","HLUCM006",202,0)
 F  S I772=$O(^TMP($J,"HLUCMSTORE","U",I772)) Q:I772'>0  D
"RTN","HLUCM006",203,0)
 .  S IEN772=0,TOTC=0,TOTS=0
"RTN","HLUCM006",204,0)
 .  F  S IEN772=$O(^TMP($J,"HLUCMSTORE","U",I772,IEN772)) Q:IEN772'>0  D
"RTN","HLUCM006",205,0)
 .  .
"RTN","HLUCM006",206,0)
 .  .  S TOTAL=$G(^TMP($J,"HLUCMSTORE","E",+IEN772)) QUIT:TOTAL']""  ;->
"RTN","HLUCM006",207,0)
 .  .  S CHAR=$P(TOTAL,U),SEC=$P(TOTAL,U,3)
"RTN","HLUCM006",208,0)
 .  .  S TOTC=TOTC+CHAR,TOTS=TOTS+SEC
"RTN","HLUCM006",209,0)
 .  .
"RTN","HLUCM006",210,0)
 .  .  S TOTU=$G(^TMP($J,"HLUCMSTORE","U",I772,IEN772)) QUIT:TOTU']""  ;->
"RTN","HLUCM006",211,0)
 .  .  S $P(TOTU,U)=CHAR,$P(TOTU,U,2)=1,$P(TOTU,U,3)=SEC
"RTN","HLUCM006",212,0)
 .  .  S ^TMP($J,"HLUCMSTORE","U",I772,IEN772)=TOTU
"RTN","HLUCM006",213,0)
 .
"RTN","HLUCM006",214,0)
 .  S TOTU=$G(^TMP($J,"HLUCMSTORE","U",I772)) QUIT:TOTU']""  ;->
"RTN","HLUCM006",215,0)
 .  S $P(TOTU,U)=TOTC,$P(TOTU,U,2)=1,$P(TOTU,U,3)=TOTS
"RTN","HLUCM006",216,0)
 .  S ^TMP($J,"HLUCMSTORE","U",I772)=TOTU
"RTN","HLUCM006",217,0)
 ;
"RTN","HLUCM006",218,0)
 QUIT
"RTN","HLUCM006",219,0)
 ;
"RTN","HLUCM006",220,0)
CORRECTN(SUB,IEN,PCE,DATEN) ; Correct node in ^TMP($J,"HLUCMSTORE","E",IEN) or
"RTN","HLUCM006",221,0)
 ; ^TMP($J,"HLUCMSTORE","U",IEN) format.Will change a beginning or
"RTN","HLUCM006",222,0)
 ; ending date and correct the time on the node...
"RTN","HLUCM006",223,0)
 ;
"RTN","HLUCM006",224,0)
 ; Warning!!  Won't allow a start date that follows an end date.
"RTN","HLUCM006",225,0)
 ;            (So, be careful what order to change dates when both
"RTN","HLUCM006",226,0)
 ;            start and end times must be changed.)
"RTN","HLUCM006",227,0)
 N IENU,NODE,NODEN
"RTN","HLUCM006",228,0)
 ;
"RTN","HLUCM006",229,0)
 ; Fix E...
"RTN","HLUCM006",230,0)
 S NODE=$G(^TMP($J,"HLUCMSTORE",SUB,IEN)) QUIT:NODE']""  ;->
"RTN","HLUCM006",231,0)
 S NODEN=$$CORRN(NODE,PCE,DATEN) QUIT:NODE=NODEN  ;->
"RTN","HLUCM006",232,0)
 S ^TMP($J,"HLUCMSTORE",SUB,IEN)=NODEN
"RTN","HLUCM006",233,0)
 ;
"RTN","HLUCM006",234,0)
 ; Fix U...
"RTN","HLUCM006",235,0)
 S IENU=$O(^TMP($J,"HLUCMSTORE","X",IEN,0)) QUIT:IENU'>0  ;-> Find IEN
"RTN","HLUCM006",236,0)
 S NODE=$G(^TMP($J,"HLUCMSTORE","U",IENU,IEN)) QUIT:NODE']""  ;->
"RTN","HLUCM006",237,0)
 S NODEN=$$CORRN(NODE,PCE,DATEN) QUIT:NODE=NODEN  ;->
"RTN","HLUCM006",238,0)
 S ^TMP($J,"HLUCMSTORE","U",IENU,IEN)=NODEN
"RTN","HLUCM006",239,0)
 ;
"RTN","HLUCM006",240,0)
 QUIT
"RTN","HLUCM006",241,0)
 ;
"RTN","HLUCM006",242,0)
CORRN(NODE,PCE,DATEN) ; See CORRECTN
"RTN","HLUCM006",243,0)
 N NODEO,SECBEG,SECDIFF,SECEND
"RTN","HLUCM006",244,0)
 ; 
"RTN","HLUCM006",245,0)
 ; Pre-tests...
"RTN","HLUCM006",246,0)
 QUIT:$P(NODE,U,PCE)=DATEN NODE ;-> Why called here?  Nothing to change?
"RTN","HLUCM006",247,0)
 QUIT:$G(DATEN)'?7N.E NODE ;-> Invalid date...
"RTN","HLUCM006",248,0)
 ;
"RTN","HLUCM006",249,0)
 S NODEO=NODE ; Backup...
"RTN","HLUCM006",250,0)
 ;
"RTN","HLUCM006",251,0)
 ; Now, do the work...
"RTN","HLUCM006",252,0)
 S $P(NODE,U,PCE)=DATEN
"RTN","HLUCM006",253,0)
 S SECBEG=$P(NODE,U,4) QUIT:SECBEG'?7N.E NODE ;->
"RTN","HLUCM006",254,0)
 S SECBEG=$$SEC^HLUCM(SECBEG)
"RTN","HLUCM006",255,0)
 S SECEND=$P(NODE,U,5) QUIT:SECEND'?7N.E NODE ;->
"RTN","HLUCM006",256,0)
 S SECEND=$$SEC^HLUCM(SECEND)
"RTN","HLUCM006",257,0)
 S SECDIFF=SECEND-SECBEG
"RTN","HLUCM006",258,0)
 S $P(NODE,U,3)=SECDIFF
"RTN","HLUCM006",259,0)
 ;
"RTN","HLUCM006",260,0)
 ; Is everything OK?
"RTN","HLUCM006",261,0)
 I $P(NODE,U,4)>$P(NODE,U,5) QUIT NODEO ;->
"RTN","HLUCM006",262,0)
 ;
"RTN","HLUCM006",263,0)
 QUIT NODE
"RTN","HLUCM006",264,0)
 ;
"RTN","HLUCM006",265,0)
EOR ;HLUCM006 - HL7/Capacity Mgt API-II ;6/9/02 18:37
"RTN","HLUCM007")
0^10^B33989947
"RTN","HLUCM007",1,0)
HLUCM007 ;CIOFO-O/LJA - HL7/Capacity Mgt API-II ;10/23/01 12:01
"RTN","HLUCM007",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**88**;Oct 13, 1995
"RTN","HLUCM007",3,0)
 ;
"RTN","HLUCM007",4,0)
ACTUAL ; Populate pieces 7-10 of ^TMP($J,"HLUCMSTORE","E") and ^("U")
"RTN","HLUCM007",5,0)
 ;
"RTN","HLUCM007",6,0)
 QUIT:$G(^TMP($J,"HLUCM"))'="DEBUG GLOBAL"  ;->
"RTN","HLUCM007",7,0)
 ;
"RTN","HLUCM007",8,0)
 S IEN772=0
"RTN","HLUCM007",9,0)
 F  S IEN772=$O(^TMP($J,"ACTUAL",IEN772)) Q:'IEN772  D
"RTN","HLUCM007",10,0)
 .  S DATA=$G(^TMP($J,"ACTUAL",IEN772))
"RTN","HLUCM007",11,0)
 .  I DATA']"" D  QUIT  ;->
"RTN","HLUCM007",12,0)
 .  .  S I772=$O(^TMP($J,"HLUCMSTORE","X",IEN772,0)) QUIT:I772'>0  ;->
"RTN","HLUCM007",13,0)
 .  .  S DATA=$G(^TMP($J,"ACTUAL",I772)) QUIT:DATA']""  ;->
"RTN","HLUCM007",14,0)
 .  .  D MOVE(I772,DATA)
"RTN","HLUCM007",15,0)
 .  D MOVE(IEN772,DATA)
"RTN","HLUCM007",16,0)
 ;
"RTN","HLUCM007",17,0)
 QUIT
"RTN","HLUCM007",18,0)
 ;
"RTN","HLUCM007",19,0)
MOVE(IEN772,DATA) ; See ACTUAL above...
"RTN","HLUCM007",20,0)
 N I772,NODE,PCE
"RTN","HLUCM007",21,0)
 ;
"RTN","HLUCM007",22,0)
 S NODE=$G(^TMP($J,"HLUCMSTORE","E",IEN772))
"RTN","HLUCM007",23,0)
 I NODE]"" D
"RTN","HLUCM007",24,0)
 .  F PCE=1,2,3,4 S $P(NODE,U,PCE+6)=$P(DATA,U,PCE)
"RTN","HLUCM007",25,0)
 .  S ^TMP($J,"HLUCMSTORE","E",IEN772)=NODE
"RTN","HLUCM007",26,0)
 ;
"RTN","HLUCM007",27,0)
 S NODE=$G(^TMP($J,"HLUCMSTORE","U",IEN772))
"RTN","HLUCM007",28,0)
 I NODE]"" D
"RTN","HLUCM007",29,0)
 .  F PCE=1,2,3,4 S $P(NODE,U,PCE+6)=$P(DATA,U,PCE)
"RTN","HLUCM007",30,0)
 .  S ^TMP($J,"HLUCMSTORE","U",IEN772)=NODE
"RTN","HLUCM007",31,0)
 ;
"RTN","HLUCM007",32,0)
 S I772=0
"RTN","HLUCM007",33,0)
 F  S I772=$O(^TMP($J,"HLUCMSTORE","U",IEN772,I772)) Q:I772'>0  D
"RTN","HLUCM007",34,0)
 .  QUIT:I772=IEN772  ;->
"RTN","HLUCM007",35,0)
 .  S NODE=$G(^TMP($J,"HLUCMSTORE","E",I772)) QUIT:NODE']""  ;->
"RTN","HLUCM007",36,0)
 .  F PCE=1,2,3,4 S $P(NODE,U,PCE+6)=$P(DATA,U,PCE)
"RTN","HLUCM007",37,0)
 .  S ^TMP($J,"HLUCMSTORE","E",I772)=NODE
"RTN","HLUCM007",38,0)
 ;
"RTN","HLUCM007",39,0)
 QUIT
"RTN","HLUCM007",40,0)
 ;
"RTN","HLUCM007",41,0)
FINDCMII(BTM,ETM) ; Find related messages & put in ^TMP($J,"CMII")...
"RTN","HLUCM007",42,0)
 N BEG,CT,IEN772,IEN772C,IEN772P,IEN772PS,IEN773,MSGID
"RTN","HLUCM007",43,0)
 ;
"RTN","HLUCM007",44,0)
 KILL ^TMP($J,"CMII"),^TMP($J,"LOAD772")
"RTN","HLUCM007",45,0)
 ;
"RTN","HLUCM007",46,0)
 ; Loop...
"RTN","HLUCM007",47,0)
 S BEG=BTM-.000001,CT=0
"RTN","HLUCM007",48,0)
 F  S BEG=$O(^HL(772,"B",BEG)) Q:BEG'>0!(BEG>ETM)  D
"RTN","HLUCM007",49,0)
 .  QUIT:BEG<BTM  ;-> Might get an entry or two before BTM...
"RTN","HLUCM007",50,0)
 .  S IEN772=0
"RTN","HLUCM007",51,0)
 .  F  S IEN772=$O(^HL(772,"B",BEG,IEN772)) Q:IEN772'>0  D
"RTN","HLUCM007",52,0)
 .  .  S ^TMP($J,"LOAD772",IEN772)=""
"RTN","HLUCM007",53,0)
 .  .  S MSGID=$P($G(^HL(772,+IEN772,0)),U,6) QUIT:MSGID']""  ;->
"RTN","HLUCM007",54,0)
 .  .  D MSGIDADD^HLUCM003(MSGID)
"RTN","HLUCM007",55,0)
 ;
"RTN","HLUCM007",56,0)
 S IEN772=0
"RTN","HLUCM007",57,0)
 F  S IEN772=$O(^TMP($J,"LOAD772",IEN772)) Q:IEN772'>0  D
"RTN","HLUCM007",58,0)
 .  D LOAD772^HLUCM003(IEN772)
"RTN","HLUCM007",59,0)
 ;
"RTN","HLUCM007",60,0)
 KILL ^TMP($J,"CMII","X"),^TMP($J,"LOAD772")
"RTN","HLUCM007",61,0)
 ;
"RTN","HLUCM007",62,0)
 S IEN772P=0
"RTN","HLUCM007",63,0)
 F  S IEN772P=$O(^TMP($J,"CMII","N",IEN772P)) Q:IEN772P'>0  D
"RTN","HLUCM007",64,0)
 .  QUIT:'$$OK772(IEN772P)  ;->
"RTN","HLUCM007",65,0)
 .  S IEN772C=0
"RTN","HLUCM007",66,0)
 .  F  S IEN772C=$O(^TMP($J,"CMII","N",IEN772P,IEN772C)) QUIT:IEN772C'>0  D
"RTN","HLUCM007",67,0)
 .  .  QUIT:'$$OK772(IEN772C)  ;->
"RTN","HLUCM007",68,0)
 .  .  I $O(^TMP($J,"CMII","N",IEN772P,IEN772C,0))'>0 D  QUIT  ;->
"RTN","HLUCM007",69,0)
 .  .  .  S ^TMP($J,"CMII","X",IEN772C,IEN772P)=""
"RTN","HLUCM007",70,0)
 .  .  S IEN773=0
"RTN","HLUCM007",71,0)
 .  .  F  S IEN773=$O(^TMP($J,"CMII","N",IEN772P,IEN772C,IEN773)) Q:IEN773'>0  D
"RTN","HLUCM007",72,0)
 .  .  .  S ^TMP($J,"CMII","X",IEN772C,IEN772P,IEN773)=""
"RTN","HLUCM007",73,0)
 ;
"RTN","HLUCM007",74,0)
 KILL ^TMP($J,"C")
"RTN","HLUCM007",75,0)
 ;
"RTN","HLUCM007",76,0)
 S IEN772C=0
"RTN","HLUCM007",77,0)
 F  S IEN772C=$O(^TMP($J,"CMII","X",IEN772C)) Q:IEN772C'>0  D
"RTN","HLUCM007",78,0)
 .  S IEN772P=0
"RTN","HLUCM007",79,0)
 .  F  S IEN772P=$O(^TMP($J,"CMII","X",IEN772C,IEN772P)) Q:IEN772P'>0  D
"RTN","HLUCM007",80,0)
 .  .  I IEN772C=IEN772P D  QUIT  ;->
"RTN","HLUCM007",81,0)
 .  .  .  S ^TMP($J,"C",IEN772P,IEN772C,IEN772C)=""
"RTN","HLUCM007",82,0)
 .  .  I '$D(^TMP($J,"CMII","X",IEN772P)) D  QUIT  ;->
"RTN","HLUCM007",83,0)
 .  .  .  S ^TMP($J,"C",IEN772P,IEN772C,IEN772C)=""
"RTN","HLUCM007",84,0)
 .  .  S IEN772P(1)=IEN772P ; Bad IEN772P
"RTN","HLUCM007",85,0)
 .  .  S IEN772PS=IEN772P
"RTN","HLUCM007",86,0)
 .  .  F I=1:1:6 QUIT:$O(^TMP($J,"CMII","X",IEN772PS,0))'>0  D
"RTN","HLUCM007",87,0)
 .  .  .  S IEN772PS=$O(^TMP($J,"CMII","X",IEN772PS,0))
"RTN","HLUCM007",88,0)
 .  .  KILL ^TMP($J,"CMII","X",IEN772C,IEN772P(1))
"RTN","HLUCM007",89,0)
 .  .  S ^TMP($J,"CMII","X",IEN772C,IEN772PS)=""
"RTN","HLUCM007",90,0)
 .  .  S ^TMP($J,"C",IEN772PS,IEN772C,IEN772P(1))=""
"RTN","HLUCM007",91,0)
 ;
"RTN","HLUCM007",92,0)
 QUIT
"RTN","HLUCM007",93,0)
 ;
"RTN","HLUCM007",94,0)
ERRCHK ; Error checks...
"RTN","HLUCM007",95,0)
 ;
"RTN","HLUCM007",96,0)
 ; DATE checks...
"RTN","HLUCM007",97,0)
 S START=+$G(START),END=+$G(END)
"RTN","HLUCM007",98,0)
 I START'?7N&(START'?7N1"."1.N) D ERR^HLUCM("INVALID START TIME")
"RTN","HLUCM007",99,0)
 I END'?7N&(END'?7N1"."1.N) D ERR^HLUCM("INVALID END TIME")
"RTN","HLUCM007",100,0)
 I '$D(ERRINFO("INVALID START TIME")) D
"RTN","HLUCM007",101,0)
 .  I '$D(ERRINFO("INVALID END TIME")) D
"RTN","HLUCM007",102,0)
 .  .  I START=END!(START<END) QUIT  ;->
"RTN","HLUCM007",103,0)
 .  .  D ERR^HLUCM("END TIME PRECEDES START TIME")
"RTN","HLUCM007",104,0)
 ;
"RTN","HLUCM007",105,0)
 ; If condition=BOTH, can't be ALL(1/2) and ALL(1/2) or
"RTN","HLUCM007",106,0)
 ; ALL(1/2) and SPECIFIC. BOTH can only be SPECIFIC and SPECIFIC.
"RTN","HLUCM007",107,0)
 I COND="BOTH" D
"RTN","HLUCM007",108,0)
 .  N P1,P2,P3
"RTN","HLUCM007",109,0)
 .  S P1=$S($G(PNMSP)>0:1,1:0) ; namespace 0/1
"RTN","HLUCM007",110,0)
 .  S P2=$S($G(IEN101)>0:1,1:0) ; protocol 0/1
"RTN","HLUCM007",111,0)
 .  S P3=P1+P2 QUIT:P3'>0  ;->
"RTN","HLUCM007",112,0)
 .  D ERR^HLUCM("BOTH NAMESPACES(S) AND PROTOCOL(S) MUST BE PASSED SPECIFICALLY")
"RTN","HLUCM007",113,0)
 QUIT
"RTN","HLUCM007",114,0)
 ;
"RTN","HLUCM007",115,0)
SETMORE ; More defaults...
"RTN","HLUCM007",116,0)
 ; 
"RTN","HLUCM007",117,0)
 ; Check format of PNMSP...
"RTN","HLUCM007",118,0)
 ; If not passed by reference...
"RTN","HLUCM007",119,0)
 I 'NMSPTYPE D  ; Namespace(s) not passed as an array
"RTN","HLUCM007",120,0)
 .  ; Passed as 1 or 2 or O^NMSP, but is it valid?
"RTN","HLUCM007",121,0)
 .  I '$$OKPAR^HLUCM002(PNMSP) D
"RTN","HLUCM007",122,0)
 .  .  D ERR^HLUCM("INVALID NAMESPACE PARAMETER")
"RTN","HLUCM007",123,0)
 ;
"RTN","HLUCM007",124,0)
 ; Check format of IEN101...
"RTN","HLUCM007",125,0)
 ; If not passed by reference...
"RTN","HLUCM007",126,0)
 I 'PROTYPE D  ; Protocol(s) not passed as an array
"RTN","HLUCM007",127,0)
 .  ; Passed as 1 or 2 or 0^PROT or 0^IEN, but is it valid?
"RTN","HLUCM007",128,0)
 .  I '$$OKPAR^HLUCM002(IEN101) D  ; Check format...
"RTN","HLUCM007",129,0)
 .  .  D ERR^HLUCM("INVALID PROTOCOL PARAMETER")
"RTN","HLUCM007",130,0)
 .  S IEN101=$$OKPAR101^HLUCM001($G(IEN101)) I IEN101']"" D
"RTN","HLUCM007",131,0)
 .  .  I $D(ERRINFO("INVALID PROTOCOL PARAMETER")) QUIT  ;->
"RTN","HLUCM007",132,0)
 .  .  QUIT:IEN101["0^9999999"  ;->
"RTN","HLUCM007",133,0)
 .  .  D ERR^HLUCM("CAN'T FIND PROTOCOL")
"RTN","HLUCM007",134,0)
 QUIT
"RTN","HLUCM007",135,0)
 ;
"RTN","HLUCM007",136,0)
OUTLYER ; Find those entries which were found because they are part of
"RTN","HLUCM007",137,0)
 ; a "unit", but whose individual times are before START or after END
"RTN","HLUCM007",138,0)
 ; START,END -- req
"RTN","HLUCM007",139,0)
 N DATA,IEN772,TM1,TM2
"RTN","HLUCM007",140,0)
 ;
"RTN","HLUCM007",141,0)
 KILL ^TMP($J,"HLUCMSTORE","O")
"RTN","HLUCM007",142,0)
 ;
"RTN","HLUCM007",143,0)
 S IEN772=0
"RTN","HLUCM007",144,0)
 F  S IEN772=$O(^TMP($J,"HLUCMSTORE","E",IEN772)) Q:IEN772'>0  D
"RTN","HLUCM007",145,0)
 .
"RTN","HLUCM007",146,0)
 .  S FAIL=0
"RTN","HLUCM007",147,0)
 .
"RTN","HLUCM007",148,0)
 .  S DATA=$G(^TMP($J,"HLUCMSTORE","E",IEN772)) QUIT:DATA']""  ;->
"RTN","HLUCM007",149,0)
 .  S TM1=$P(DATA,U,4),TM2=$P(DATA,U,5)
"RTN","HLUCM007",150,0)
 .  I TM1,TM1<START S FAIL=1 ; Start time before START
"RTN","HLUCM007",151,0)
 .  I TM2,TM2>END S FAIL=FAIL+2 ; End time is after END
"RTN","HLUCM007",152,0)
 .
"RTN","HLUCM007",153,0)
 .  QUIT:'FAIL  ;->
"RTN","HLUCM007",154,0)
 .
"RTN","HLUCM007",155,0)
 .  S CHAR=+DATA,SEC=$P(DATA,U,3)
"RTN","HLUCM007",156,0)
 .
"RTN","HLUCM007",157,0)
 .  S TOT=$G(^TMP($J,"HLUCMSTORE","O"))
"RTN","HLUCM007",158,0)
 .  D INCRO
"RTN","HLUCM007",159,0)
 .  S ^TMP($J,"HLUCMSTORE","O")=TOT
"RTN","HLUCM007",160,0)
 .
"RTN","HLUCM007",161,0)
 .  S ^TMP($J,"HLUCMSTORE","O",IEN772)=CHAR_U_1_U_SEC_U_TM1_U_TM2
"RTN","HLUCM007",162,0)
 ;
"RTN","HLUCM007",163,0)
 QUIT
"RTN","HLUCM007",164,0)
 ;
"RTN","HLUCM007",165,0)
INCRO ; TOT & CHAR,SEC & FAIL -- req
"RTN","HLUCM007",166,0)
 S $P(TOT,U)=$P(TOT,U)+CHAR
"RTN","HLUCM007",167,0)
 S $P(TOT,U,2)=$P(TOT,U,2)+1
"RTN","HLUCM007",168,0)
 S $P(TOT,U,3)=$P(TOT,U,3)+SEC
"RTN","HLUCM007",169,0)
 S:FAIL=1 $P(TOT,U,4)=$P(TOT,U,4)+1 ; Begin before START
"RTN","HLUCM007",170,0)
 S:FAIL=2 $P(TOT,U,5)=$P(TOT,U,5)+1 ; End before END
"RTN","HLUCM007",171,0)
 S:FAIL=3 $P(TOT,U,6)=$P(TOT,U,6)+1 ; Both START and END violated
"RTN","HLUCM007",172,0)
 QUIT
"RTN","HLUCM007",173,0)
 ;
"RTN","HLUCM007",174,0)
OK772(IEN772) ; Is this valid?
"RTN","HLUCM007",175,0)
 N DATE
"RTN","HLUCM007",176,0)
 S DATE=$P($G(^HL(772,+$G(IEN772),0)),U)
"RTN","HLUCM007",177,0)
 QUIT $S(DATE?7N1"."1.N:1,1:"")
"RTN","HLUCM007",178,0)
 ;
"RTN","HLUCM007",179,0)
EOR ; HLUCM007 - HL7/Capacity Mgt API-II ;10/23/01 12:01
"RTN","HLUCM008")
0^11^B42740230
"RTN","HLUCM008",1,0)
HLUCM008 ;CIOFO-O/LJA - HL7/Capacity Mgt API-II ;7/31/01 15:54
"RTN","HLUCM008",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**88**;Oct 13, 1995
"RTN","HLUCM008",3,0)
 ;
"RTN","HLUCM008",4,0)
TOTAL ; Final totalling... (Called from HLUCM003)
"RTN","HLUCM008",5,0)
 N COUNTED,DTBEG,DTEND,HLUCMADD,IEN772,IENPREV
"RTN","HLUCM008",6,0)
 N LOOP772,PP,TYPEHR,TYPEIO,TYPELR
"RTN","HLUCM008",7,0)
 S LOOP772=0 ; This is the PARENT 772 level...
"RTN","HLUCM008",8,0)
 F  S LOOP772=$O(^TMP($J,"CMII","N",LOOP772)) Q:LOOP772'>0  D
"RTN","HLUCM008",9,0)
 .  S COUNTED=0 ;Make sure only counted once...
"RTN","HLUCM008",10,0)
 .  S (DTBEG,DTEND,IENPREV)=""
"RTN","HLUCM008",11,0)
 .  QUIT:'$$OKVAR^HLUCM003(+LOOP772)  ;-> Creates PP,TYPEHR,TYPEIO,TYPELR
"RTN","HLUCM008",12,0)
 .  S IEN772=0,HLUCMADD="ADD.  COLLECT~HLUCM003"
"RTN","HLUCM008",13,0)
 .  F  S IEN772=$O(^TMP($J,"CMII","N",LOOP772,IEN772)) Q:IEN772'>0  D
"RTN","HLUCM008",14,0)
 .  .  S CTDBG=CTDBG+1
"RTN","HLUCM008",15,0)
 .  .  D COLLECT3^HLUCM003(LOOP772,IEN772) QUIT:COUNTED  ;->
"RTN","HLUCM008",16,0)
 .  .  S COUNTED=1 ; Make sure not counted again...
"RTN","HLUCM008",17,0)
 .  .  S HLUCMADD="DON'T ADD.  COLLECT3~HLUCM003"
"RTN","HLUCM008",18,0)
 .  .
"RTN","HLUCM008",19,0)
 .  .  ; trap debug data?
"RTN","HLUCM008",20,0)
 .  .  D HLUCMSTR^HLUCM003
"RTN","HLUCM008",21,0)
 QUIT
"RTN","HLUCM008",22,0)
 ;
"RTN","HLUCM008",23,0)
ADJTIME ; Loop thru entries, correcting E times on basis of U units..
"RTN","HLUCM008",24,0)
 ;  (Called from HLUCM003)
"RTN","HLUCM008",25,0)
 N DATA,DBGBL,DTBEG,DTEND,IEN772,IENPREV,LOOP772,PP,TYPEHR,TYPEIO,TYPELR
"RTN","HLUCM008",26,0)
 S LOOP772=0
"RTN","HLUCM008",27,0)
 F  S LOOP772=$O(^TMP($J,"CMII","N",LOOP772)) Q:LOOP772'>0  D
"RTN","HLUCM008",28,0)
 .  S (DTBEG,DTEND,IENPREV)=""
"RTN","HLUCM008",29,0)
 .  S IEN772=0
"RTN","HLUCM008",30,0)
 .  F  S IEN772=$O(^TMP($J,"CMII","N",LOOP772,IEN772)) Q:IEN772'>0  D
"RTN","HLUCM008",31,0)
 .  .  KILL DATA
"RTN","HLUCM008",32,0)
 .  .  QUIT:'$$OKVAR^HLUCM003(+LOOP772)  ;-> Creates PP,TYPEHR,TYPEIO,TYPELR
"RTN","HLUCM008",33,0)
 .  .  S DBGBL=0
"RTN","HLUCM008",34,0)
 .  .  D TOT772^HLUCM(+IEN772)
"RTN","HLUCM008",35,0)
 .  .  D DATATM^HLUCM003(IEN772) ; Creates DATA("START") and DATA("END")...
"RTN","HLUCM008",36,0)
 .  .  I IENPREV']""  D  ;1st message being processed...
"RTN","HLUCM008",37,0)
 .  .  .  ; If no following messages to worry about, quit.  No adjustment...
"RTN","HLUCM008",38,0)
 .  .  .  QUIT:$O(^TMP($J,"CMII","N",LOOP772,IEN772))'>0  ;->
"RTN","HLUCM008",39,0)
 .  .  .  QUIT:DATA("END")=DATA("START")  ;->
"RTN","HLUCM008",40,0)
 .  .  .  I $G(^TMP($J,"HLUCM"))="DEBUG GLOBAL" D
"RTN","HLUCM008",41,0)
 .  .  .  .  S ^TMP($J,"HLUCMSTORE","C",+LOOP772,+IEN772)=DATA("START")_U_DATA("END")
"RTN","HLUCM008",42,0)
 .  .  .  S DATA("END")=DATA("START")
"RTN","HLUCM008",43,0)
 .  .  .
"RTN","HLUCM008",44,0)
 .  .  .  D CORRECTN^HLUCM006("E",IEN772,5,DATA("END"))
"RTN","HLUCM008",45,0)
 .  .  ;
"RTN","HLUCM008",46,0)
 .  .  ; What if start < previous event's end?
"RTN","HLUCM008",47,0)
 .  .  I DTEND,DATA("START"),DTEND>DATA("START") D
"RTN","HLUCM008",48,0)
 .  .  .  I $G(^TMP($J,"HLUCM"))="DEBUG GLOBAL" D
"RTN","HLUCM008",49,0)
 .  .  .  .  S ^TMP($J,"HLUCMSTORE","C",+LOOP772,+IEN772,"E")=DATA("START")_U_DATA("END")_"~"_DTEND
"RTN","HLUCM008",50,0)
 .  .  .  S DATA("START")=DTEND
"RTN","HLUCM008",51,0)
 .  .  .
"RTN","HLUCM008",52,0)
 .  .  .  D CORRECTN^HLUCM006("E",IEN772,4,DATA("START"))
"RTN","HLUCM008",53,0)
 .  .  .
"RTN","HLUCM008",54,0)
 .  .  S DTBEG=DATA("START"),DTEND=DATA("END")
"RTN","HLUCM008",55,0)
 QUIT
"RTN","HLUCM008",56,0)
 ;
"RTN","HLUCM008",57,0)
FIXNMSP(PCKG,I772) ; First space piece, strip _
"RTN","HLUCM008",58,0)
 N APPR,APPS,FACR,FACS,I773,MSH
"RTN","HLUCM008",59,0)
 ;
"RTN","HLUCM008",60,0)
 S I772=+$G(I772)
"RTN","HLUCM008",61,0)
 ;
"RTN","HLUCM008",62,0)
 ; Get 773 (or 772)-related information...
"RTN","HLUCM008",63,0)
 S I773=$O(^HLMA("B",+I772,0))
"RTN","HLUCM008",64,0)
 S MSH=$G(^HLMA(+I773,"MSH",1,0))
"RTN","HLUCM008",65,0)
 I MSH']"" S X=$G(^HL(772,+I772,"IN",1,0)) S:$E(X,1,3)=MSH MSH=X
"RTN","HLUCM008",66,0)
 S X=$E(MSH,4),APPS=$P(MSH,X,3),FACS=$P(MSH,X,4),APPR=$P(MSH,X,5),FACR=$P(MSH,X,6)
"RTN","HLUCM008",67,0)
 ;
"RTN","HLUCM008",68,0)
 ; Some miscellaneous special actions first...
"RTN","HLUCM008",69,0)
 I $E(PCKG,1,2)="DG",PCKG'="DG" S PCKG="DG"
"RTN","HLUCM008",70,0)
 I $E(PCKG,1,3)="VEI",PCKG'="VEIB" S PCKG="VEIB"
"RTN","HLUCM008",71,0)
 I $E(PCKG,1,2)="VA" D
"RTN","HLUCM008",72,0)
 .  I PCKG["PIMS" S PCKG="DG" QUIT  ;->
"RTN","HLUCM008",73,0)
 .  I APPR["HEC " S PCKG="HEC" QUIT  ;->
"RTN","HLUCM008",74,0)
 .  I FACR["HEC " S PCKG="HEC" QUIT  ;->
"RTN","HLUCM008",75,0)
 I $E(PCKG,1,2)="LA" S PCKG="LA"
"RTN","HLUCM008",76,0)
 I $E(PCKG,1,2)="VA",PCKG[" PIMS" S PCKG="DG"
"RTN","HLUCM008",77,0)
 I $E(PCKG,1,10)="VAFC ADMIT" S PCKG="DG"
"RTN","HLUCM008",78,0)
 I $E(PCKG,1,8)="VAFC ADT" S PCKG="DG"
"RTN","HLUCM008",79,0)
 I $E(PCKG,1,8)?1"VAFH A"2N S PCKG="DG"
"RTN","HLUCM008",80,0)
 I $E(PCKG,1,15)?1"VAFH CLIENT A"2N S PCKG="DG"
"RTN","HLUCM008",81,0)
 I $E(PCKG,1,2)="XM" S PCKG="XM"
"RTN","HLUCM008",82,0)
 I $E(PCKG,1,2)="XU" S PCKG="XU"
"RTN","HLUCM008",83,0)
 ;
"RTN","HLUCM008",84,0)
 QUIT $TR($E($P($P(PCKG," "),"-"),1,4),"_ ","") ;->
"RTN","HLUCM008",85,0)
 ;
"RTN","HLUCM008",86,0)
DEBUGE(COL) ; Print ^TMP($J,"HLUCMSTORE","E") data...
"RTN","HLUCM008",87,0)
 N CT,DATA,GBL,IEN772,IEN773,POSX
"RTN","HLUCM008",88,0)
 S GBL="^TMP("_$J_",""HLUCMSTORE"",""E"")"
"RTN","HLUCM008",89,0)
 S IEN772=0
"RTN","HLUCM008",90,0)
 F  S IEN772=$O(@GBL@(IEN772)) Q:IEN772'>0  D
"RTN","HLUCM008",91,0)
 .  W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLUCM008",92,0)
 .  W !,IEN772
"RTN","HLUCM008",93,0)
 .  D PRT^HLUCM004(COL,$G(@GBL@(IEN772)))
"RTN","HLUCM008",94,0)
 .  D PRT^HLUCM004(COL,$G(@GBL@(IEN772,772)))
"RTN","HLUCM008",95,0)
 .  W:$X>30 ! W:$X<30 ?30
"RTN","HLUCM008",96,0)
 .  S IEN773=0,CT=0
"RTN","HLUCM008",97,0)
 .  F  S IEN773=$O(@GBL@(IEN772,773,IEN773)) Q:IEN773'>0  D
"RTN","HLUCM008",98,0)
 .  .  S CT=CT+1
"RTN","HLUCM008",99,0)
 .  .  I CT=1 W "773s: " S POSX=$X
"RTN","HLUCM008",100,0)
 .  .  W:$X>POSX ! W:$X<POSX ?POSX
"RTN","HLUCM008",101,0)
 .  .  S DATA=IEN773_"("_$G(@GBL@(IEN772,773,IEN773))_")  "
"RTN","HLUCM008",102,0)
 .  .  W:($X+$L(DATA))>IOM !,?POSX
"RTN","HLUCM008",103,0)
 .  .  W DATA
"RTN","HLUCM008",104,0)
 QUIT
"RTN","HLUCM008",105,0)
 ;
"RTN","HLUCM008",106,0)
PACKE1(IEN772) ;
"RTN","HLUCM008",107,0)
 N CHAR,GBL,NODE,NMSP,TYPE
"RTN","HLUCM008",108,0)
 ;
"RTN","HLUCM008",109,0)
 S GBL="^TMP("_$J_",""HLUCMSTORE"",""E"","_IEN772_")"
"RTN","HLUCM008",110,0)
 ;
"RTN","HLUCM008",111,0)
 ; Pull off Protocol first for root node...
"RTN","HLUCM008",112,0)
 S NODE=$G(@GBL)
"RTN","HLUCM008",113,0)
 S TYPE=$P($G(@GBL@(772,"PR","PR")),U,2) I TYPE]"" D ADD^HLUCM005(7,TYPE)
"RTN","HLUCM008",114,0)
 ; D ADD^HLUCM005(2,1) ; Might as well "state" now that 1 msg included...
"RTN","HLUCM008",115,0)
 ; D ADD^HLUCM005(3,$$TMDIFF(IEN772)) ; Transmit time
"RTN","HLUCM008",116,0)
 ; p(4) & p(5) set in $$TMDIFFF
"RTN","HLUCM008",117,0)
 S X=$$MSGTYPE^HLUCM005(IEN772) I X]"" D ADD^HLUCM005(6,X)
"RTN","HLUCM008",118,0)
 S @GBL=NODE
"RTN","HLUCM008",119,0)
 ;
"RTN","HLUCM008",120,0)
 ; Now, pack the sub nodes...
"RTN","HLUCM008",121,0)
 S NODE="",NMSP=""
"RTN","HLUCM008",122,0)
 ;
"RTN","HLUCM008",123,0)
 S TYPE=$O(@GBL@(772,"TM","")) I TYPE]"" D
"RTN","HLUCM008",124,0)
 .  S CHAR=$P($G(@GBL@(772,"TM",TYPE)),U)
"RTN","HLUCM008",125,0)
 .  S NMSP=$P($G(@GBL@(772,"TM",TYPE)),U,2)
"RTN","HLUCM008",126,0)
 .  I CHAR>0 D ADD^HLUCM005(1,CHAR)
"RTN","HLUCM008",127,0)
 .  D ADD^HLUCM005(2,TYPE)
"RTN","HLUCM008",128,0)
 ;
"RTN","HLUCM008",129,0)
 S TYPE=$O(@GBL@(772,"IO","")) I TYPE]"" D
"RTN","HLUCM008",130,0)
 .  D ADD^HLUCM005(3,TYPE)
"RTN","HLUCM008",131,0)
 .  I NMSP']"" S NMSP=$P($G(@GBL@(772,"IO",TYPE)),U,2)
"RTN","HLUCM008",132,0)
 ;
"RTN","HLUCM008",133,0)
 S TYPE=$O(@GBL@(772,"LR","")) I TYPE]"" D
"RTN","HLUCM008",134,0)
 .  D ADD^HLUCM005(4,TYPE)
"RTN","HLUCM008",135,0)
 .  I NMSP']"" S NMSP=$P($G(@GBL@(772,"LR",TYPE)),U,2)
"RTN","HLUCM008",136,0)
 ;
"RTN","HLUCM008",137,0)
 S @GBL@(772)=NODE
"RTN","HLUCM008",138,0)
 ;
"RTN","HLUCM008",139,0)
 ; Set NMSP into root node...
"RTN","HLUCM008",140,0)
 I NMSP]"" D
"RTN","HLUCM008",141,0)
 .  S NODE=$G(@GBL)
"RTN","HLUCM008",142,0)
 .  D ADD^HLUCM005(9,NMSP)
"RTN","HLUCM008",143,0)
 .  S @GBL=NODE
"RTN","HLUCM008",144,0)
 ;
"RTN","HLUCM008",145,0)
 ; Remove nodes that were packed...
"RTN","HLUCM008",146,0)
 F TYPE="IO","LR","PR","TM" KILL @GBL@(772,TYPE)
"RTN","HLUCM008",147,0)
 ;
"RTN","HLUCM008",148,0)
 QUIT
"RTN","HLUCM008",149,0)
 ;
"RTN","HLUCM008",150,0)
CREDIT ; Find "credit" remote...
"RTN","HLUCM008",151,0)
 N BEFORE,DOMAINR,I772,MSH,STANMR,STANOR,STORE,TOTAL,VAL
"RTN","HLUCM008",152,0)
 S I772=0
"RTN","HLUCM008",153,0)
 F  S I772=$O(^TMP($J,"HLUCMSTORE","U",I772)) Q:I772'>0  D
"RTN","HLUCM008",154,0)
 .  S TOTAL=1
"RTN","HLUCM008",155,0)
 .  ; Return I~~MSH Segment or O~~MSH Segment
"RTN","HLUCM008",156,0)
 .  S MSH=$$MSHFIND^HLUCM006(I772,LOCAL) QUIT:MSH']""  ;->
"RTN","HLUCM008",157,0)
 .  ; Extract from the MSH Segment the RECEIVING FACILITY based on I or O
"RTN","HLUCM008",158,0)
 .  S (BEFORE,STORE)=$$EXTRACT^HLUCM006($P(MSH,"~~"),$P(MSH,"~~",2,99))
"RTN","HLUCM008",159,0)
 .  ; If STORE is the local Station# by itself, set to LOCAL...
"RTN","HLUCM008",160,0)
 .  S STORE=$S(STORE=+STANOL:LOCAL,1:STORE)
"RTN","HLUCM008",161,0)
 .  ; If STORE is a Station# by itself, DO...
"RTN","HLUCM008",162,0)
 .  I STORE=+STORE,STORE'=+STANOL D
"RTN","HLUCM008",163,0)
 .  .  ; Get DOMAIN, etc from station number
"RTN","HLUCM008",164,0)
 .  .  S VAL=$$VAL^HLUCM006(STORE)
"RTN","HLUCM008",165,0)
 .  .  S DOMAINR=$P(VAL,U,5),STANOR=$P(VAL,U),STANMR=$P(VAL,U,3)
"RTN","HLUCM008",166,0)
 .  .  ; Return information in 512~BALTIMORE.MED.VA.GOV~DNS format, if
"RTN","HLUCM008",167,0)
 .  .  ; Institution file entry has a Domain pointer.  If not, return
"RTN","HLUCM008",168,0)
 .  .  ; in 512~BALTIMORE format.
"RTN","HLUCM008",169,0)
 .  .  S STORE=$$RETURN^HLUCM006(DOMAINR,STANOR,STANMR)
"RTN","HLUCM008",170,0)
 .  I +STORE'>0 D  ; If doesn't start with NUMERIC (Station#)...
"RTN","HLUCM008",171,0)
 .  .  I STORE']"" S STORE=LOCALDNS QUIT  ;->
"RTN","HLUCM008",172,0)
 .  .  QUIT:$D(^XTMP("HLUCMSTORE","EXCL",STORE))  ;->
"RTN","HLUCM008",173,0)
 .  .  QUIT:$D(^XTMP("HLUCMSTORE","EXCL","*"))  ;-> Exclude everything!
"RTN","HLUCM008",174,0)
 .  .  S STORE=LOCALDNS
"RTN","HLUCM008",175,0)
 .  ; Don't store ~DNS for local entries...
"RTN","HLUCM008",176,0)
 .  S BEFORE=$$CONVERT^HLUCM006(BEFORE)
"RTN","HLUCM008",177,0)
 .  S STORE=$$CONVERT^HLUCM006(STORE)
"RTN","HLUCM008",178,0)
 .  D RECORD^HLUCM006(BEFORE,STORE)
"RTN","HLUCM008",179,0)
 .  S ^TMP($J,"STORE",+STORE,STORE)=""
"RTN","HLUCM008",180,0)
 .  S ^TMP($J,"REMOTE",I772)=STORE
"RTN","HLUCM008",181,0)
 QUIT
"RTN","HLUCM008",182,0)
 ;
"RTN","HLUCM008",183,0)
EOR ;HLUCM008 - HL7/Capacity Mgt API-II ;7/31/01 15:54
"VER")
8.0^22.0
**END**
**END**
