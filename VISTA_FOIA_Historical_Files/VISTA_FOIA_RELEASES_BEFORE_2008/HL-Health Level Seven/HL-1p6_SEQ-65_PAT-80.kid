Released HL*1.6*80 SEQ #65
Extracted from mail message
**KIDS**:HL*1.6*80^

**INSTALL NAME**
HL*1.6*80
"BLD",422,0)
HL*1.6*80^HEALTH LEVEL SEVEN^0^3010611^y
"BLD",422,4,0)
^9.64PA^^
"BLD",422,"ABPKG")
n
"BLD",422,"KRN",0)
^9.67PA^8994.2^18
"BLD",422,"KRN",.4,0)
.4
"BLD",422,"KRN",.401,0)
.401
"BLD",422,"KRN",.402,0)
.402
"BLD",422,"KRN",.403,0)
.403
"BLD",422,"KRN",.5,0)
.5
"BLD",422,"KRN",.84,0)
.84
"BLD",422,"KRN",3.6,0)
3.6
"BLD",422,"KRN",3.8,0)
3.8
"BLD",422,"KRN",9.2,0)
9.2
"BLD",422,"KRN",9.8,0)
9.8
"BLD",422,"KRN",9.8,"NM",0)
^9.68A^2^2
"BLD",422,"KRN",9.8,"NM",1,0)
HLCSHDR1^^0^B23515201
"BLD",422,"KRN",9.8,"NM",2,0)
HLCSHDR^^0^B44427133
"BLD",422,"KRN",9.8,"NM","B","HLCSHDR",2)

"BLD",422,"KRN",9.8,"NM","B","HLCSHDR1",1)

"BLD",422,"KRN",19,0)
19
"BLD",422,"KRN",19.1,0)
19.1
"BLD",422,"KRN",101,0)
101
"BLD",422,"KRN",409.61,0)
409.61
"BLD",422,"KRN",771,0)
771
"BLD",422,"KRN",870,0)
870
"BLD",422,"KRN",8994,0)
8994
"BLD",422,"KRN",8994.2,0)
8994.2
"BLD",422,"KRN","B",.4,.4)

"BLD",422,"KRN","B",.401,.401)

"BLD",422,"KRN","B",.402,.402)

"BLD",422,"KRN","B",.403,.403)

"BLD",422,"KRN","B",.5,.5)

"BLD",422,"KRN","B",.84,.84)

"BLD",422,"KRN","B",3.6,3.6)

"BLD",422,"KRN","B",3.8,3.8)

"BLD",422,"KRN","B",9.2,9.2)

"BLD",422,"KRN","B",9.8,9.8)

"BLD",422,"KRN","B",19,19)

"BLD",422,"KRN","B",19.1,19.1)

"BLD",422,"KRN","B",101,101)

"BLD",422,"KRN","B",409.61,409.61)

"BLD",422,"KRN","B",771,771)

"BLD",422,"KRN","B",870,870)

"BLD",422,"KRN","B",8994,8994)

"BLD",422,"KRN","B",8994.2,8994.2)

"BLD",422,"QUES",0)
^9.62^^
"BLD",422,"REQB",0)
^9.611^2^2
"BLD",422,"REQB",1,0)
HL*1.6*72^2
"BLD",422,"REQB",2,0)
HL*1.6*65^2
"BLD",422,"REQB","B","HL*1.6*65",2)

"BLD",422,"REQB","B","HL*1.6*72",1)

"MBREQ")
0
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
80^3010611^73
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
2
"RTN","HLCSHDR")
0^2^B44427133
"RTN","HLCSHDR",1,0)
HLCSHDR ;  ALB/MFK,JRP - Make HL7 header from a #772 IEN ;05/31/2000  08:59
"RTN","HLCSHDR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**37,19,57,59,65,80**;Oct 13, 1995
"RTN","HLCSHDR",3,0)
HEADER(IEN,HLERROR) ; Create an HL7 MSH segment
"RTN","HLCSHDR",4,0)
 ;
"RTN","HLCSHDR",5,0)
 ;Input  : IEN - Pointer to entry in Message Text file (#772) that
"RTN","HLCSHDR",6,0)
 ;               HL7 MSH segment is being built for
"RTN","HLCSHDR",7,0)
 ;         HLERROR - Variable to return possible error text in
"RTN","HLCSHDR",8,0)
 ;                   (pass by reference - only used when needed)
"RTN","HLCSHDR",9,0)
 ;
"RTN","HLCSHDR",10,0)
 ;Output : HLHDR(1) - HL7 MSH segment
"RTN","HLCSHDR",11,0)
 ;         HLHDR(2) - Continuation of HL7 MSH segment (if needed)
"RTN","HLCSHDR",12,0)
 ;         HLHDR(3) - Continuation of HL7 MSH segment (if needed)
"RTN","HLCSHDR",13,0)
 ;
"RTN","HLCSHDR",14,0)
 ;Notes  : HLERROR will only be defined [on output] if an error occurs
"RTN","HLCSHDR",15,0)
 ;       : HLHDR() will not be defined [on output] if an error occurs
"RTN","HLCSHDR",16,0)
 ;       : HLHDR(2) & HLHDR(3) are continuation [or roll-over] nodes
"RTN","HLCSHDR",17,0)
 ;         and will only be used/defined when needed
"RTN","HLCSHDR",18,0)
 ;
"RTN","HLCSHDR",19,0)
 ;Check input
"RTN","HLCSHDR",20,0)
 S IEN=+$G(IEN)
"RTN","HLCSHDR",21,0)
 I ('$D(^HL(772,IEN,0))) S HLERROR="Valid pointer to Message Text file (#772) not passed" Q
"RTN","HLCSHDR",22,0)
 ;Declare variables
"RTN","HLCSHDR",23,0)
 N PROTOCOL,PARENTP,PARENT,SERVERP,CLIENTP,FS,PROT,MSGTYPE,APPPRM
"RTN","HLCSHDR",24,0)
 N HLDTID,HLID,HLDATE,SECURITY,ID,SERAPP,SERFAC,EC,ACCACK,APPACK
"RTN","HLCSHDR",25,0)
 N CHILD,CLNTAPP,CLNTFAC,ACKTO,CNTRY,HLPROT,HLPROTS,HLPARAM
"RTN","HLCSHDR",26,0)
 ;Get Site Parameters
"RTN","HLCSHDR",27,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLCSHDR",28,0)
 ;Get parent message (NOTE: Original message is it's own parent)
"RTN","HLCSHDR",29,0)
 S CHILD=$G(^HL(772,IEN,0))
"RTN","HLCSHDR",30,0)
 I CHILD="" S HLERROR="Valid pointer to Message Text file (#772) not passed" Q
"RTN","HLCSHDR",31,0)
 S PARENTP=+$P(CHILD,"^",8)
"RTN","HLCSHDR",32,0)
 I ('PARENTP) S HLERROR="Could not determine parent message" Q
"RTN","HLCSHDR",33,0)
 S PARENT=$G(^HL(772,PARENTP,0))
"RTN","HLCSHDR",34,0)
 ;Get server [sending] & client [receiving] applications
"RTN","HLCSHDR",35,0)
 S SERVERP=+$P(PARENT,"^",2)
"RTN","HLCSHDR",36,0)
 I ('SERVERP) S HLERROR="Could not determine sending application" Q
"RTN","HLCSHDR",37,0)
 S CLIENTP=+$P(CHILD,"^",3)
"RTN","HLCSHDR",38,0)
 I ('CLIENTP) S HLERROR="Could not determine receiving application" Q
"RTN","HLCSHDR",39,0)
 ;Get info for sending & receiving applications
"RTN","HLCSHDR",40,0)
 D APPPRM^HLUTIL2(CLIENTP)
"RTN","HLCSHDR",41,0)
 D APPPRM^HLUTIL2(SERVERP)
"RTN","HLCSHDR",42,0)
 ;Get name of sending application and facility
"RTN","HLCSHDR",43,0)
 S SERAPP=$P(APPPRM(SERVERP,0),"^",1)
"RTN","HLCSHDR",44,0)
 S SERFAC=$P(APPPRM(SERVERP,0),"^",2)
"RTN","HLCSHDR",45,0)
 ;Get name of receiving application and facility
"RTN","HLCSHDR",46,0)
 S CLNTAPP=$P(APPPRM(CLIENTP,0),"^",1)
"RTN","HLCSHDR",47,0)
 S CLNTFAC=$P(APPPRM(CLIENTP,0),"^",2)
"RTN","HLCSHDR",48,0)
 ;Get country
"RTN","HLCSHDR",49,0)
 S CNTRY=$P(APPPRM(SERVERP,0),"^",3)
"RTN","HLCSHDR",50,0)
 ;Get field seperator & encoding characters
"RTN","HLCSHDR",51,0)
 S FS=APPPRM(SERVERP,"FS")
"RTN","HLCSHDR",52,0)
 S EC=APPPRM(SERVERP,"EC")
"RTN","HLCSHDR",53,0)
 S:(EC="") EC="~|\&"
"RTN","HLCSHDR",54,0)
 S:(FS="") FS="^"
"RTN","HLCSHDR",55,0)
 ;
"RTN","HLCSHDR",56,0)
 ;Determine if it's a response/ACK to another message
"RTN","HLCSHDR",57,0)
 ;
"RTN","HLCSHDR",58,0)
 S ACKTO=+$P(PARENT,"^",7)
"RTN","HLCSHDR",59,0)
 ;
"RTN","HLCSHDR",60,0)
 ;Get message type
"RTN","HLCSHDR",61,0)
 ;Message type/Event Type of Initiator found on Event Driver
"RTN","HLCSHDR",62,0)
 ;Message type/Event Type of Responder found on Subscriber
"RTN","HLCSHDR",63,0)
 ;
"RTN","HLCSHDR",64,0)
 S PROT=+$P(PARENT,"^",10),HLPROT=PROT
"RTN","HLCSHDR",65,0)
 ;commented the next line to get ack message to have the correct header
"RTN","HLCSHDR",66,0)
 ;S:ACKTO&($G(HLOGLINK)) PROT=+$P(CHILD,"^",10)
"RTN","HLCSHDR",67,0)
 S PROTOCOL=$$TYPE^HLUTIL2(PROT)
"RTN","HLCSHDR",68,0)
 ;if initiating a new transaction, get MsgType from Event Driver, field 770.3
"RTN","HLCSHDR",69,0)
 ;if generating a response, get MsgType from subscriber, field 770.11
"RTN","HLCSHDR",70,0)
 S MSGTYPE=$S(ACKTO:$P(PROTOCOL,"^",10),1:$P(PROTOCOL,"^",2))
"RTN","HLCSHDR",71,0)
 ;Append event type
"RTN","HLCSHDR",72,0)
 I MSGTYPE']"" S HLERROR="Message Type Undefined for protocol "_$P(PROTOCOL,"^",1) Q
"RTN","HLCSHDR",73,0)
 I $P(PROTOCOL,"^",3)]"" S MSGTYPE=MSGTYPE_$E(EC,1)_$P(PROTOCOL,"^",3)
"RTN","HLCSHDR",74,0)
 ;Append mesaage structure component
"RTN","HLCSHDR",75,0)
 I $P(PROTOCOL,"^",3)]"",$P(PROTOCOL,"^",4)]"" S MSGTYPE=MSGTYPE_$E(EC,1)_$P(PROTOCOL,"^",4)
"RTN","HLCSHDR",76,0)
 ;Get accept ack & application ack type (based on server protocol)
"RTN","HLCSHDR",77,0)
 ;  Originating messages have it listed in the parent message
"RTN","HLCSHDR",78,0)
 ;  Responses/ACKs have it listed in the child message
"RTN","HLCSHDR",79,0)
 S PROT=+$P(PARENT,"^",10),HLPROT=PROT
"RTN","HLCSHDR",80,0)
 S:(ACKTO) PROT=+$P(CHILD,"^",10)
"RTN","HLCSHDR",81,0)
 S HLPROTS=+$P(CHILD,"^",10)
"RTN","HLCSHDR",82,0)
 S PROTOCOL=$$TYPE^HLUTIL2(PROT)
"RTN","HLCSHDR",83,0)
 S ACCACK=$P(PROTOCOL,"^",7)
"RTN","HLCSHDR",84,0)
 S APPACK=$P(PROTOCOL,"^",8)
"RTN","HLCSHDR",85,0)
 ;Get date/time & message ID
"RTN","HLCSHDR",86,0)
 S HLDATE=+PARENT
"RTN","HLCSHDR",87,0)
 S HLDATE=$$FMTHL7^XLFDT(HLDATE)
"RTN","HLCSHDR",88,0)
MID ;Message ID
"RTN","HLCSHDR",89,0)
 S HLID=$P(PARENT,"^",6)
"RTN","HLCSHDR",90,0)
PID ;Processing ID
"RTN","HLCSHDR",91,0)
 ;If event driver set to 'debug' get from protocol
"RTN","HLCSHDR",92,0)
 ;'production' or 'training' comes from site params
"RTN","HLCSHDR",93,0)
 S HLPID=$P(PROTOCOL,"^",5)
"RTN","HLCSHDR",94,0)
 I $G(HLPID)'="D" S HLPID=$P(HLPARAM,U,3)
"RTN","HLCSHDR",95,0)
 I $G(HLPID)="" S HLERROR="Missing Processing ID Site Parameter."
"RTN","HLCSHDR",96,0)
 ;Get security info
"RTN","HLCSHDR",97,0)
 S SECURITY=$P(PARENT,"^",12)
"RTN","HLCSHDR",98,0)
 D HDR23
"RTN","HLCSHDR",99,0)
 ;Build MSH array
"RTN","HLCSHDR",100,0)
 S HLHDR(1)="MSH"_FS_EC_FS_SERAPP_FS_SERFAC_FS_CLNTAPP_FS_CLNTFAC_FS
"RTN","HLCSHDR",101,0)
 S HLHDR(1)=HLHDR(1)_HLDATE_FS_SECURITY_FS_MSGTYPE_FS_HLID_FS
"RTN","HLCSHDR",102,0)
 S HLHDR(1)=HLHDR(1)_HLPID_FS_$P(PROTOCOL,"^",9)_FS_FS
"RTN","HLCSHDR",103,0)
 S HLHDR(2)=$G(^HL(772,PARENT,1))_FS
"RTN","HLCSHDR",104,0)
 S HLHDR(3)=ACCACK_FS_APPACK_FS_CNTRY
"RTN","HLCSHDR",105,0)
 ;Combine line 1 & 2 (if possible)
"RTN","HLCSHDR",106,0)
 I (($L(HLHDR(1))+$L(HLHDR(2)))'>245) D
"RTN","HLCSHDR",107,0)
 .S HLHDR(1)=HLHDR(1)_HLHDR(2)
"RTN","HLCSHDR",108,0)
 .S HLHDR(2)=HLHDR(3)
"RTN","HLCSHDR",109,0)
 .S HLHDR(3)=""
"RTN","HLCSHDR",110,0)
 .;Add original line 3 (if possible)
"RTN","HLCSHDR",111,0)
 .I (($L(HLHDR(1))+$L(HLHDR(2)))'>245) D
"RTN","HLCSHDR",112,0)
 ..S HLHDR(1)=HLHDR(1)_HLHDR(2)
"RTN","HLCSHDR",113,0)
 ..S HLHDR(2)=""
"RTN","HLCSHDR",114,0)
 ;Combine line 2 & 3 (if possible)
"RTN","HLCSHDR",115,0)
 I (($L(HLHDR(2))+$L(HLHDR(3)))'>245) D
"RTN","HLCSHDR",116,0)
 .S HLHDR(2)=HLHDR(2)_HLHDR(3)
"RTN","HLCSHDR",117,0)
 .S HLHDR(3)=""
"RTN","HLCSHDR",118,0)
 ;Delete unused lines
"RTN","HLCSHDR",119,0)
 K:(HLHDR(2)="") HLHDR(2)
"RTN","HLCSHDR",120,0)
 K:(HLHDR(3)="") HLHDR(3)
"RTN","HLCSHDR",121,0)
 Q
"RTN","HLCSHDR",122,0)
BHSHDR(IEN) ; Create Batch Header Segment
"RTN","HLCSHDR",123,0)
 ; The BHS has 12 segments, of which 4 are blank.
"RTN","HLCSHDR",124,0)
 ; INPUT: IEN - IEN of entry in file #772
"RTN","HLCSHDR",125,0)
 ; OUTPUT: HLHDR(1) and HLHDR(2) - the two lines with the 12 segs.
"RTN","HLCSHDR",126,0)
 ;   ready for adding to a message directly.
"RTN","HLCSHDR",127,0)
 N ACKMID,ACKTO,APPPRM,BC,BCD,BCI,BEC,BFS,BN,BRA,BRF,BS,BSA,BSF ;HL*1.6*80
"RTN","HLCSHDR",128,0)
 N BSTATUS,BTACK,CHILD,CLIENTP,HLDATE,HLDTID,HLPID,ID,PARENT,PARENTP ;HL*1.6*80
"RTN","HLCSHDR",129,0)
 N RBCI,SERVERP ;HL*1.6*80
"RTN","HLCSHDR",130,0)
 S CHILD=$G(^HL(772,IEN,0))
"RTN","HLCSHDR",131,0)
 S PARENTP=$P(CHILD,"^",8)
"RTN","HLCSHDR",132,0)
 I (PARENTP="") S HLHDR(1)="-1^No parent" Q
"RTN","HLCSHDR",133,0)
 S PARENT=$G(^HL(772,PARENTP,0))
"RTN","HLCSHDR",134,0)
 S SERVERP=$P(PARENT,"^",2)
"RTN","HLCSHDR",135,0)
 I (SERVERP="") S HLHDR(1)="-1^No server for this node" Q
"RTN","HLCSHDR",136,0)
 S CLIENTP=$P(CHILD,"^",3)
"RTN","HLCSHDR",137,0)
 I (CLIENTP="") S HLHDR(1)="-1^No client for this node" Q
"RTN","HLCSHDR",138,0)
 ;--  get server and application parameters
"RTN","HLCSHDR",139,0)
 D APPPRM^HLUTIL2(SERVERP)
"RTN","HLCSHDR",140,0)
 D APPPRM^HLUTIL2(CLIENTP)
"RTN","HLCSHDR",141,0)
 S BFS=APPPRM(SERVERP,"FS")
"RTN","HLCSHDR",142,0)
 S BEC=APPPRM(SERVERP,"EC")
"RTN","HLCSHDR",143,0)
 ;-- sending application
"RTN","HLCSHDR",144,0)
 S BSA=$P(APPPRM(SERVERP,0),"^",1)
"RTN","HLCSHDR",145,0)
 ;-- sending facility
"RTN","HLCSHDR",146,0)
 S BSF=$P(APPPRM(SERVERP,0),"^",2)
"RTN","HLCSHDR",147,0)
 ;-- receiving application
"RTN","HLCSHDR",148,0)
 S BRA=$P(APPPRM(CLIENTP,0),"^",1)
"RTN","HLCSHDR",149,0)
 ;-- receiving facility
"RTN","HLCSHDR",150,0)
 S BRF=$P(APPPRM(CLIENTP,0),"^",2)
"RTN","HLCSHDR",151,0)
 S HLDATE=+PARENT
"RTN","HLCSHDR",152,0)
 S HLID=$P(PARENT,"^",6)
"RTN","HLCSHDR",153,0)
 S BCD=$$HLDATE^HLFNC(HLDATE,"TS")
"RTN","HLCSHDR",154,0)
 ;-- batch security
"RTN","HLCSHDR",155,0)
 S BS=$P(PARENT,"^",12)
"RTN","HLCSHDR",156,0)
 ;-- build batch field #9  NULL~Process ID~Message Type|Event Type~version
"RTN","HLCSHDR",157,0)
 S ACKTO=$P(PARENT,"^",7)
"RTN","HLCSHDR",158,0)
 S PROT=$S((ACKTO&$G(HLOGLINK)):$P(CHILD,"^",10),1:$P(PARENT,"^",10))
"RTN","HLCSHDR",159,0)
 ;S X=$$TYPE^HLUTIL2($P(CHILD,U,10))
"RTN","HLCSHDR",160,0)
 ; for batch ACK message, client protocol pointer is stored in parent message
"RTN","HLCSHDR",161,0)
 ;I ACKTO S X=$$TYPE^HLUTIL2($P(PARENT,U,10))
"RTN","HLCSHDR",162,0)
 S X=$$TYPE^HLUTIL2(PROT)
"RTN","HLCSHDR",163,0)
 S MSGTYPE=$S(ACKTO:$P(X,"^",10),1:$P(X,"^",2))
"RTN","HLCSHDR",164,0)
 I MSGTYPE']"" S HLERROR="MType undefined for protocol "_$P(X,U) Q
"RTN","HLCSHDR",165,0)
 I $P(X,U,3)]"" S MSGTYPE=MSGTYPE_$E(BEC,2)_$P(X,U,3)
"RTN","HLCSHDR",166,0)
 ;S BN=$E(BEC,1)_$P(X,U,5)_$E(BEC,1)_$S('$P(CHILD,"^",11)&('ACKTO):$P(X,U,2),1:$P(X,U,10))_$E(BEC,2)_$P(X,U,3)_$E(BEC,1)_$P(X,U,9)
"RTN","HLCSHDR",167,0)
 S HLPID=$$PIDCK($P($G(^HL(772,+PROT,0)),U,10)) QUIT:$G(HLERROR)]""  ;HL*1.6*80
"RTN","HLCSHDR",168,0)
 S BN=$E(BEC,1)_HLPID_$E(BEC,1)_MSGTYPE_$E(BEC,1)_$P(X,U,9) ;HL*1.6*80
"RTN","HLCSHDR",169,0)
 ;
"RTN","HLCSHDR",170,0)
 ; for batch ACK message
"RTN","HLCSHDR",171,0)
 S ACKMID="",BTACK=""
"RTN","HLCSHDR",172,0)
 I ACKTO D
"RTN","HLCSHDR",173,0)
 . S ACKMID=$P($G(^HL(772,ACKTO,0)),"^",6)
"RTN","HLCSHDR",174,0)
 . S BSTATUS=$P($G(^HL(772,ACKTO,"P")),"^")
"RTN","HLCSHDR",175,0)
 . S BTACK="AR"
"RTN","HLCSHDR",176,0)
 . I ACKMID]"" D
"RTN","HLCSHDR",177,0)
 .. S BTACK="AA"
"RTN","HLCSHDR",178,0)
 .. I (BSTATUS>3)&(BSTATUS<8) S BTACK="AE"_$E(BEC,1)_$P($G(^HL(772,ACKTO,"P")),"^",3)
"RTN","HLCSHDR",179,0)
 ;
"RTN","HLCSHDR",180,0)
 S HLHDR(1)="BHS"_BFS_BEC_BFS_BSA_BFS_BSF_BFS_BRA_BFS_BRF_BFS_BCD_BFS_BS_BFS_BN_BFS_BTACK_BFS_HLID_BFS_ACKMID
"RTN","HLCSHDR",181,0)
 Q
"RTN","HLCSHDR",182,0)
HDR23 ;generate extended facility field info based on 'facility required'
"RTN","HLCSHDR",183,0)
 ;default format is INSTITUTION_HLCS_DOMAIN_HLCS_'DNS'
"RTN","HLCSHDR",184,0)
 ;application parameter entry overrides default
"RTN","HLCSHDR",185,0)
 N HLEP773,HLS773
"RTN","HLCSHDR",186,0)
 S SERFAC=$G(SERFAC),CLNTFAC=$G(CLNTFAC)
"RTN","HLCSHDR",187,0)
 S HLEP773=+$G(^ORD(101,HLPROTS,773))
"RTN","HLCSHDR",188,0)
 S HLS773=+$P($G(^ORD(101,HLPROTS,773)),U,2)
"RTN","HLCSHDR",189,0)
 Q:'HLEP773&('HLS773)
"RTN","HLCSHDR",190,0)
 D GEN^HLCSHDR2
"RTN","HLCSHDR",191,0)
 I ACKTO D  Q
"RTN","HLCSHDR",192,0)
 .;Find original message
"RTN","HLCSHDR",193,0)
 .S X=$G(^HL(772,ACKTO,"IN",1,0))
"RTN","HLCSHDR",194,0)
 .I X["MSH" D
"RTN","HLCSHDR",195,0)
 ..S HLFS=$E(X,4)
"RTN","HLCSHDR",196,0)
 ..S SENDFAC=$P(X,HLFS,4),RECFAC=$P(X,HLFS,6) ;from original msg
"RTN","HLCSHDR",197,0)
 ..S CLNTFAC=SENDFAC,SERFAC=RECFAC ;reverse facility info
"RTN","HLCSHDR",198,0)
 I HLEP773,SERFAC="" D EP^HLCSHDR2
"RTN","HLCSHDR",199,0)
 I HLS773,CLNTFAC="" D S^HLCSHDR2
"RTN","HLCSHDR",200,0)
 Q
"RTN","HLCSHDR",201,0)
 ;
"RTN","HLCSHDR",202,0)
PIDCK(IEN101) ; This subroutine added by HL*1.6*80
"RTN","HLCSHDR",203,0)
 ; Given 101's IEN, return the PROCESSING ID.  (See PID^HLCSHDR
"RTN","HLCSHDR",204,0)
 ; and PID^HLCSHDR1 for other locations where HLPID is set.)
"RTN","HLCSHDR",205,0)
 ; HLPARAM -- req
"RTN","HLCSHDR",206,0)
 S HLPID=$P($G(^ORD(101,+IEN101,0)),U,6)
"RTN","HLCSHDR",207,0)
 I HLPID'="D" D
"RTN","HLCSHDR",208,0)
 .  I $G(HLPARAM)']"" N HLPARAM S HLPARAM=$$PARAM^HLCS2
"RTN","HLCSHDR",209,0)
 .  S HLPID=$P($G(HLPARAM),U,3)
"RTN","HLCSHDR",210,0)
 I HLPID="" S HLERROR="Missing Processing ID Site Parameter."
"RTN","HLCSHDR",211,0)
 QUIT HLPID
"RTN","HLCSHDR1")
0^1^B23515201
"RTN","HLCSHDR1",1,0)
HLCSHDR1 ;SFIRMFO/RSD - Make HL7 header for TCP ;07/12/2000  14:55
"RTN","HLCSHDR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,57,59,72,80**;Oct 13, 1995
"RTN","HLCSHDR1",3,0)
HEADER(IEN,CLIENT,HLERROR) ; Create an HL7 MSH segment
"RTN","HLCSHDR1",4,0)
 ;
"RTN","HLCSHDR1",5,0)
 ;Input  : IEN - Pointer to entry in Message Administration file (#773)
"RTN","HLCSHDR1",6,0)
 ;               that HL7 MSH segment is being built for
"RTN","HLCSHDR1",7,0)
 ;         CLIENT - IEN of the receiving application
"RTN","HLCSHDR1",8,0)
 ;         HLERROR - Variable to return possible error text in
"RTN","HLCSHDR1",9,0)
 ;                   (pass by reference - only used when needed)
"RTN","HLCSHDR1",10,0)
 ;
"RTN","HLCSHDR1",11,0)
 ;Output : HLHDR(1) - HL7 MSH segment
"RTN","HLCSHDR1",12,0)
 ;         HLHDR(2) - Continuation of HL7 MSH segment (if needed)
"RTN","HLCSHDR1",13,0)
 ;         HLHDR(3) - Continuation of HL7 MSH segment (if needed)
"RTN","HLCSHDR1",14,0)
 ;
"RTN","HLCSHDR1",15,0)
 ;Notes  : HLERROR will only be defined [on output] if an error occurs
"RTN","HLCSHDR1",16,0)
 ;       : HLHDR() will not be defined [on output] if an error occurs
"RTN","HLCSHDR1",17,0)
 ;       : HLHDR(2) & HLHDR(3) are continuation [or roll-over] nodes
"RTN","HLCSHDR1",18,0)
 ;         and will only be used/defined when needed
"RTN","HLCSHDR1",19,0)
 ;
"RTN","HLCSHDR1",20,0)
 N ACKTO,ACCACK,APPACK,CHILD,CLNTAPP,CLNTFAC,CNTRY,EC,EVNTYPE,FS,HLDATE,HLHDRI,HLHDRL,HLID,HLPID,MSGTYPE,PROT,PROTS,SECURITY,SEND,SERAPP,SERFAC,TXTP,TXTP0,X,MSGEVN
"RTN","HLCSHDR1",21,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLCSHDR1",22,0)
 D VAR Q:$G(HLERROR)]""
"RTN","HLCSHDR1",23,0)
 ; The following line commented by HL*1.6*72
"RTN","HLCSHDR1",24,0)
 ;I $D(^HLMA(IEN)) S $P(^HLMA(IEN,0),U,13)=MSGTYPE,$P(^HLMA(IEN,0),U,14)=$G(EVNTYPE)
"RTN","HLCSHDR1",25,0)
 ;Append event type
"RTN","HLCSHDR1",26,0)
 I $G(EVNTYPE)]"" S MSGTYPE=MSGTYPE_$E(EC,1)_EVNTYPE
"RTN","HLCSHDR1",27,0)
 ;Append message structure component
"RTN","HLCSHDR1",28,0)
 I $G(EVNTYPE)]"",$G(MSGEVN)]"" S MSGTYPE=MSGTYPE_$E(EC,1)_MSGEVN
"RTN","HLCSHDR1",29,0)
 ;Build MSH array
"RTN","HLCSHDR1",30,0)
 S HLHDRI=1,HLHDR(1)="MSH"_FS_EC_FS_SERAPP,HLHDRL=$L(HLHDR(1))
"RTN","HLCSHDR1",31,0)
 F X=SERFAC,CLNTAPP,CLNTFAC,HLDATE,SECURITY,MSGTYPE,HLID,HLPID,$P(PROT,U,9),"",$G(^HL(772,TXTP,1)),ACCACK,APPACK,CNTRY D MSH(X)
"RTN","HLCSHDR1",32,0)
 ;in preceeding line, "" is for sequence number - not supported
"RTN","HLCSHDR1",33,0)
 Q
"RTN","HLCSHDR1",34,0)
 ;
"RTN","HLCSHDR1",35,0)
MSH(X) ;add X to HLHDR
"RTN","HLCSHDR1",36,0)
 S:HLHDRL+$L(X)>245 HLHDRI=HLHDRI+1,HLHDR(HLHDRI)=""
"RTN","HLCSHDR1",37,0)
 S HLHDR(HLHDRI)=HLHDR(HLHDRI)_FS_X,HLHDRL=$L(HLHDR(HLHDRI))
"RTN","HLCSHDR1",38,0)
 Q
"RTN","HLCSHDR1",39,0)
BHSHDR(IEN,CLIENT,HLERROR) ; Create Batch Header Segment
"RTN","HLCSHDR1",40,0)
 ; The BHS has 12 segments, of which 4 are blank.
"RTN","HLCSHDR1",41,0)
 ; INPUT: IEN - IEN of entry in file #772
"RTN","HLCSHDR1",42,0)
 ; OUTPUT: HLHDR(1) and HLHDR(2) - the two lines with the 12 segs.
"RTN","HLCSHDR1",43,0)
 ;   ready for adding to a message directly.
"RTN","HLCSHDR1",44,0)
 N ACKTO,ACCACK,ACKMID,APPACK,BNAME,BSTATUS,BTACK,CHILD,CLNTAPP ;HL*1.6*80
"RTN","HLCSHDR1",45,0)
 N CLNTFAC,CNTRY,EC,EVNTYPE,FS,HLDATE,HLHDRI,HLHDRL,HLID,HLPID ;HL*1.6*80 - added HLPID
"RTN","HLCSHDR1",46,0)
 N PROT,PROTS,SECURITY,SEND,SERAPP,SERFAC,TXTP,TXTP0,X ;HL*1.6*80
"RTN","HLCSHDR1",47,0)
 ;
"RTN","HLCSHDR1",48,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLCSHDR1",49,0)
 D VAR Q:$G(HLERROR)]""
"RTN","HLCSHDR1",50,0)
 ; The following line commented by HL*1.6*72
"RTN","HLCSHDR1",51,0)
 ;I $D(^HLMA(IEN)) S $P(^HLMA(IEN,0),U,13)=MSGTYPE,$P(^HLMA(IEN,0),U,14)=$G(EVNTYPE)
"RTN","HLCSHDR1",52,0)
 ;
"RTN","HLCSHDR1",53,0)
 ;Append event type
"RTN","HLCSHDR1",54,0)
 I $G(EVNTYPE)]"" S MSGTYPE=MSGTYPE_$E(EC,2)_EVNTYPE,(ACKMID,BTACK)=""
"RTN","HLCSHDR1",55,0)
 ;batch/name/id/type(#9)=null~process ID~msg type|evnt type~version~CA~AA
"RTN","HLCSHDR1",56,0)
 S BNAME=$E(EC,1)_HLPID_$E(EC,1)_MSGTYPE_$E(EC,1)_$P(PROT,U,9)_$E(EC,1)_ACCACK_$E(EC,1)_APPACK ;HL*1.6*80
"RTN","HLCSHDR1",57,0)
 ;for batch ACK
"RTN","HLCSHDR1",58,0)
 I ACKTO D  S BTACK=X_$E(EC,1)_$P(BSTATUS,U,3)
"RTN","HLCSHDR1",59,0)
 . ;get msg id and status of message that is being ACKed
"RTN","HLCSHDR1",60,0)
 . S ACKMID=$P($G(^HLMA(ACKTO,0)),U,2),BSTATUS=$G(^HLMA(ACKTO,"P")) ;HL*1.6*80
"RTN","HLCSHDR1",61,0)
 . ;set type of ACK based on status
"RTN","HLCSHDR1",62,0)
 . S X=$S(ACKMID="":"AR",(BSTATUS>3)&(BSTATUS<8):"AE",1:"AA")
"RTN","HLCSHDR1",63,0)
 ;
"RTN","HLCSHDR1",64,0)
 S HLHDRI=1,HLHDR(1)="BHS"_FS_EC_FS_SERAPP,HLHDRL=$L(HLHDR(1))
"RTN","HLCSHDR1",65,0)
 F X=SERFAC,CLNTAPP,CLNTFAC,HLDATE,SECURITY,BNAME,BTACK,HLID,ACKMID D MSH(X)
"RTN","HLCSHDR1",66,0)
 Q
"RTN","HLCSHDR1",67,0)
VAR ;Check input
"RTN","HLCSHDR1",68,0)
 N APPPRM,HLPROTS,HLPROT
"RTN","HLCSHDR1",69,0)
 S IEN=+$G(IEN)
"RTN","HLCSHDR1",70,0)
 I '$G(^HLMA(IEN,0)) S HLERROR="Valid pointer to Message Administration file (#772) not passed" Q
"RTN","HLCSHDR1",71,0)
 I '$G(CLIENT) S HLERROR="Could not determine receiving application" Q
"RTN","HLCSHDR1",72,0)
 ;Get child, text pointer,text entry, and sending app.
"RTN","HLCSHDR1",73,0)
 S CHILD=$G(^HLMA(IEN,0)),SEND=+$P($G(^(0)),U,11),TXTP=+CHILD,TXTP0=$G(^HL(772,TXTP,0))
"RTN","HLCSHDR1",74,0)
 I ('SEND) S HLERROR="Could not determine sending application" Q
"RTN","HLCSHDR1",75,0)
 ;Get info for sending & receiving applications
"RTN","HLCSHDR1",76,0)
 D APPPRM^HLUTIL2(CLIENT),APPPRM^HLUTIL2(SEND)
"RTN","HLCSHDR1",77,0)
 ;Get name of sending application, facility, and country
"RTN","HLCSHDR1",78,0)
 S SERAPP=$P(APPPRM(SEND,0),U),SERFAC=$P(APPPRM(SEND,0),U,2),CNTRY=$P(APPPRM(SEND,0),U,3)
"RTN","HLCSHDR1",79,0)
 ;Get name of receiving application and facility
"RTN","HLCSHDR1",80,0)
 S CLNTAPP=$P(APPPRM(CLIENT,0),U),CLNTFAC=$P(APPPRM(CLIENT,0),U,2)
"RTN","HLCSHDR1",81,0)
 ;Get field separator & encoding characters
"RTN","HLCSHDR1",82,0)
 S FS=APPPRM(SEND,"FS"),EC=APPPRM(SEND,"EC")
"RTN","HLCSHDR1",83,0)
 S:(EC="") EC="~|\&" S:(FS="") FS="^"
"RTN","HLCSHDR1",84,0)
 ;Determine if it's a response/ACK to another message
"RTN","HLCSHDR1",85,0)
 S ACKTO=+$P(CHILD,U,10)
"RTN","HLCSHDR1",86,0)
 ;subscriber protocol is from child (file 773)
"RTN","HLCSHDR1",87,0)
 ;If response, get MType from subscriber
"RTN","HLCSHDR1",88,0)
 S HLPROTS=+$P(CHILD,U,8)
"RTN","HLCSHDR1",89,0)
 S PROTS=$$TYPE^HLUTIL2(HLPROTS)
"RTN","HLCSHDR1",90,0)
 I ACKTO S MSGTYPE=$P(PROTS,U,10),EVNTYPE=$P(PROTS,U,3),MSGEVN=$P(PROTS,U,4)
"RTN","HLCSHDR1",91,0)
 ;Get accept ack & application ack type (based on server protocol) it
"RTN","HLCSHDR1",92,0)
 ; is always in file 772, TXPT0
"RTN","HLCSHDR1",93,0)
 ;If original message, get MT from Event Driver Protocol
"RTN","HLCSHDR1",94,0)
 S HLPROT=+$P(TXTP0,U,10)
"RTN","HLCSHDR1",95,0)
 S PROT=$$TYPE^HLUTIL2(HLPROT)
"RTN","HLCSHDR1",96,0)
 S:'ACKTO MSGTYPE=$P(PROT,U,2),EVNTYPE=$P(PROT,U,3),MSGEVN=$P(PROT,U,4)
"RTN","HLCSHDR1",97,0)
 S ACCACK=$P(PROT,U,7),APPACK=$P(PROT,U,8)
"RTN","HLCSHDR1",98,0)
PID ;Processing ID
"RTN","HLCSHDR1",99,0)
 ;I PID not 'debug' get from site params
"RTN","HLCSHDR1",100,0)
 ;If event driver set to 'debug' get from protocol
"RTN","HLCSHDR1",101,0)
 ;'production' or 'training' comes from site params
"RTN","HLCSHDR1",102,0)
 S HLPID=$P(PROT,U,5)
"RTN","HLCSHDR1",103,0)
 I $G(HLPID)'="D" S HLPID=$P(HLPARAM,U,3)
"RTN","HLCSHDR1",104,0)
 I $G(HLPID)="" S HLERROR="Missing processing ID Site parameter."
"RTN","HLCSHDR1",105,0)
 ;acknowledgements have no application ack, link open no commit ack
"RTN","HLCSHDR1",106,0)
 I ACKTO S:APPACK]"" APPACK="NE" S:ACCACK]""&$G(HLTCPO) ACCACK="NE"
"RTN","HLCSHDR1",107,0)
 ;Get date/time, Message ID, and security
"RTN","HLCSHDR1",108,0)
 S HLDATE=+TXTP0,HLDATE=$$FMTHL7^XLFDT(HLDATE),HLID=$P(CHILD,U,2),SECURITY=$P(CHILD,U,9)
"RTN","HLCSHDR1",109,0)
HDR23 ;generate extended facility field info based on 'facility required'
"RTN","HLCSHDR1",110,0)
 ;default format is INSTITUTION_HLCS_DOMAIN_HLCS_'DNS'
"RTN","HLCSHDR1",111,0)
 ;application parameter entry overrides default
"RTN","HLCSHDR1",112,0)
 N HLEP773,HLS773
"RTN","HLCSHDR1",113,0)
 S SERFAC=$G(SERFAC),CLNTFAC=$G(CLNTFAC)
"RTN","HLCSHDR1",114,0)
 S HLEP773=+$G(^ORD(101,HLPROTS,773))
"RTN","HLCSHDR1",115,0)
 S HLS773=+$P($G(^ORD(101,HLPROTS,773)),U,2)
"RTN","HLCSHDR1",116,0)
 Q:'HLEP773&('HLS773)
"RTN","HLCSHDR1",117,0)
 D GEN^HLCSHDR2
"RTN","HLCSHDR1",118,0)
 I ACKTO D  Q
"RTN","HLCSHDR1",119,0)
 .;Find original message
"RTN","HLCSHDR1",120,0)
 .S X=$G(^HLMA(ACKTO,"MSH",1,0)) ;Find header in TCP nodes
"RTN","HLCSHDR1",121,0)
 .I X["MSH" D
"RTN","HLCSHDR1",122,0)
 ..S HLFS=$E(X,4)
"RTN","HLCSHDR1",123,0)
 ..S SENDFAC=$P(X,HLFS,4),RECFAC=$P(X,HLFS,6) ;from original msg
"RTN","HLCSHDR1",124,0)
 ..S CLNTFAC=SENDFAC,SERFAC=RECFAC ;reverse facility info
"RTN","HLCSHDR1",125,0)
 I HLEP773,SERFAC="" D EP^HLCSHDR2
"RTN","HLCSHDR1",126,0)
 I HLS773,CLNTFAC="" D S^HLCSHDR2
"RTN","HLCSHDR1",127,0)
 Q
"VER")
8.0^22.0
**END**
**END**
