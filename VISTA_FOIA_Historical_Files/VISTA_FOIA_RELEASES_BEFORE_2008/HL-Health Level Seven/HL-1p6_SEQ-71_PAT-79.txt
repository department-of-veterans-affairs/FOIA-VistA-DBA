$TXT Created by ANDREASSEN,LARRY J at NXT.KERNEL.ISC-SF.VA.GOV  (KIDS) on MONDAY, 11/26/01 at 10:56
=============================================================================
Run Date: NOV 30, 2001                     Designation: HL*1.6*79
Package : HL - HEALTH LEVEL SEVEN            Priority: Mandatory
Version : 1.6        SEQ #71                    Status: Released
=============================================================================


Subject: New HL7/Capacity Management API

Category: 
  - Routine

Description: 
============

 Test sites:   North Florida/South Georgia HCS (Gainesville/Lake City),
               MPI, White River, VA Connecticut HCS (West Haven/Newington)
  
 NOIS:         None
  
 Builds:       This is new software, and no previous KIDS
               builds are required prior to loading and
               installing this patch.
  
 OVERVIEW
 --------
  
 A new application programming interface (API) has been created for
 calculating the volume of HL7 activity at a site over a user-defined
 period of time.  It has been created for the Capacity Management (CM)
 team; however, it can be used by sites as well.  This new API is
 $$CM^HLUCM.
  
 The $$CM^HLUCM API calculates the volume of HL7 activity over a
 period of time.  The information collected includes the following:
  
     1. Total number characters in the messages.
     2. Total Number of messages.
     3. Total time elapsed for transmission of messages.
  
 The $$CM^HLUCM entry point calculates HL7 activity totals as mentioned
 above.  These totals are further subtotaled by:
  
     1. Message Time of Transmission or Receipt. (Time entries are
        rounded to the hour.)
        - Time data is subtotaled by namespace, and within namespace
          by protocol.
  
     2. Message Namespace.
        - Namespace data is subtotaled by whether the message is 
          incoming or outgoing, and further subtotaled by namespace 
          and numberspace.
        - Namespace data is also subtotaled by whether the message 
          originated locally or remotely, and further subtotaled by 
          namespace and numberspace.
  
     3. Message Protocol.
        - Protocol data is subtotaled by namespace and protocol.
  
  
          ==================================================
  
  
 SYNTAX
 ------
  
 The syntax for the Capacity Management HL7 API is:
  
     $$CM^HLUCM(START,END,NAMESPACE,PROTOCOL,SAVE,CONDITION,ERRORS)
  
 When the $$CM^HLUCM entry point is invoked, it returns a three-piece
 string of data containing totals from all messages found matching the
 parameter-defined criteria.  The information returned is "Total number of
 characters ^ Total number of messages ^ Total seconds to transmit and
 receive messages." When the $$CM^HLUCM API is invoked it also stores these
 totals in the ^TMP global.  In addition to the totals stored in ^TMP,
 additional subdivisions of the totals (mentioned in the OVERVIEW section),
 are stored.
  
          ==================================================
  
  
 INPUT PARAMETERS
 ----------------
  
 The input parameters used by the $$CM^HLUCM entry point are listed and
 explained below.
  
 PARAMETER  EXPLANATION
 -------------------------------------------------------------------------
 START       This is a FileMan date.  It sets the beginning point for the
             time range for the calculation of the HL7 activity totals.
 END         This is also a FileMan date.  It sets the ending point for the
             time range for the calculation of HL7 activity totals.
 NAMESPACE   This refers to the namespace of a message.  The namespace of
             a message is determined by the following steps:
             - Finding the PROTOCOL file (#101) entry associated with a
               message.
             - Finding the PACKAGE file (#9.4) entry associated with the
               PROTOCOL file entry.
             - Finding the namespace in the PACKAGE file entry.
             The NAMESPACE parameter can be passed in several different
             ways as explained in the "INPUT PARAMETERS: ADDITIONAL
             DISCUSSION - NAMESPACE" section of this patch description.
 PROTOCOL    This is the protocol of a message.  The PROTOCOL parameter
             can be passed in several different ways as explained in the
             "INPUT PARAMETERS: ADDITIONAL DISCUSSION - PROTOCOL" section.
 SAVE        This parameter is free-text data, and specifies the initial
             subscript to be used when storing ^TMP data.  If $$CM^HLUCM
             is invoked, and "TYPE" is passed as the value of the SAVE
             parameter, data will be stored in the ^TMP("TYPE",$J,...)
             global.
 CONDITION  This parameter can be "EITHER" or "BOTH".  CONDITION refers to
            the namespace and the protocol of a message.  If the "EITHER"
            condition is specified, a message will be counted if "either"
            of the following conditions is met:
            - NAMESPACE parameter is satisfied (this is discussed in
              length later in this patch description), or the
            - PROTOCOL parameter is satisfied.
              If the BOTH condition is specified, a message will be counted
              only if "both" the NAMESPACE and PROTOCOL parameters are
              satisfied.
 ERRORS    This parameter must be passed by reference.  It specifies the
           array name location for error information to be stored.
  
  
          ==================================================
  
  
 OUTPUT
 ------
  
 When $$CM^HLUCM is invoked, it returns a three-piece string of data.  In
 addition, all the messages found in the specified date range matching the
 NAMESPACE and PROTOCOL parameter specifications are used to calculate
 subtotals that are stored in the ^TMP global.
  
 The following example shows the syntax of this call and the resulting
 output:
  
    >W $$CM^HLUCM(3010416,3010416.0005,1,1,"TOTALS","EITHER",.ERR)
    290060^805^792
  
 NOTE: Additional information regarding the input parameters - in particular,
  
       the "1" found in the NAMESPACE and PROTOCOL parameter positions - is
       provided later in this patch description.
  
 Notice in the previous example, the API returned the value
 "290060^805^792". This refers to the number characters in all matching
 messages, the number of messages, and the total processing time for
 these messages. To better explain this:
  
   - 805 matching messages were found between 4/16/2001 and
     4/16/2001@00:05. (The value 805 is the second piece of data.)
   - These 805 messages held 290,060 total characters. (The value 290,060
     is the first piece of data.)
   - It took a total of 792 seconds to transmit or receive the
      805 messages. (The value 792 is the third piece of data.)
  
 In addition to these three pieces of data, this call created other data,
 stored in the ^TMP global, in which subtotals by various criteria can be
 found.  This data is shown in the following example:
  
     1 ^TMP("TOTALS",$J) = 290060^805^792
    --------------------------------------------------------------
     2 ^TMP("TOTALS",$J,"HR") = 290060^805^792
     3 ^TMP("TOTALS",$J,"HR","TM") = 290060^805^792
     4 ^TMP("TOTALS",$J,"HR","TM","U") = 290060^805^792
     5 ^TMP("TOTALS",$J,"HR","TM","U","3010416.00") = 290060^805^792
     6 ^TMP("TOTALS",$J,"HR","TM","U","3010416.00","DG") = 289677^804^214
     7 ^TMP("TOTALS",$J,"HR","TM","U","3010416.00","DG","VAFH A08~4620") =
        289677^804^214
     8 ^TMP("TOTALS",$J,"HR","TM","U","3010416.00","SD") = 383^1^578
     9 ^TMP("TOTALS",$J,"HR","TM","U","3010416.00","SD","VAFC ADT-A08-SC
        HED SERVER~4654") = 383^1^578
    --------------------------------------------------------------
    10 ^TMP("TOTALS",$J,"NMSP") = 290060^805^792
    11 ^TMP("TOTALS",$J,"NMSP","IO") = 290060^805^792
    12 ^TMP("TOTALS",$J,"NMSP","IO","O") = 290060^805^792
    13 ^TMP("TOTALS",$J,"NMSP","IO","O","DG") = 289677^804^214
    14 ^TMP("TOTALS",$J,"NMSP","IO","O","DG","3010416.00") = 289677^804^
        214
    15 ^TMP("TOTALS",$J,"NMSP","IO","O","DG","3010416.00","VAFH A08~
        4620") = 289677^804^214
    16 ^TMP("TOTALS",$J,"NMSP","IO","O","SD") = 383^1^578
    17 ^TMP("TOTALS",$J,"NMSP","IO","O","SD","3010416.00") = 383^1^578
    18 ^TMP("TOTALS",$J,"NMSP","IO","O","SD","3010416.00","VAFC ADT-A08-
        SCHED SERVER~4654") = 383^1^578
                               -----------------------------------
    19 ^TMP("TOTALS",$J,"NMSP","LR") = 290060^805^792
    20 ^TMP("TOTALS",$J,"NMSP","LR","L") = 290060^805^792
    21 ^TMP("TOTALS",$J,"NMSP","LR","L","DG") = 289677^804^214
    22 ^TMP("TOTALS",$J,"NMSP","LR","L","DG","3010416.00") = 289677^804^
        214
    23 ^TMP("TOTALS",$J,"NMSP","LR","L","DG","3010416.00","VAFH A08~
        4620") = 289677^804^214
    24 ^TMP("TOTALS",$J,"NMSP","LR","L","SD") = 383^1^578
    25 ^TMP("TOTALS",$J,"NMSP","LR","L","SD","3010416.00") = 383^1^578
    26 ^TMP("TOTALS",$J,"NMSP","LR","L","SD","3010416.00","VAFC ADT-A08-
        SCHED SERVER~4654") = 383^1^578
    --------------------------------------------------------------
    27 ^TMP("TOTALS",$J,"PROT") = 290060^805^792
    28 ^TMP("TOTALS",$J,"PROT","PR") = 290060^805^792
    29 ^TMP("TOTALS",$J,"PROT","PR","P") = 290060^805^792
    30 ^TMP("TOTALS",$J,"PROT","PR","P","VAFC ADT-A08-SCHED SERVER~4654")
        = 383^1^578
    31 ^TMP("TOTALS",$J,"PROT","PR","P","VAFC ADT-A08-SCHED SERVER~4654"
        ,"SD") = 383^1^578
    32 ^TMP("TOTALS",$J,"PROT","PR","P","VAFC ADT-A08-SCHED SERVER~4654"
        ,"SD","3010416.00") = 383^1^578
    33 ^TMP("TOTALS",$J,"PROT","PR","P","VAFH A08~4620") = 289677
        ^804^214
    34 ^TMP("TOTALS",$J,"PROT","PR","P","VAFH A08~4620","DG") = 289677^
        804^214
    35 ^TMP("TOTALS",$J,"PROT","PR","P","VAFH A08~4620","DG",
        "3010416.00") = 289677^804^214
  
    Note: Row numbers have been artificially placed in front of each
          global node to facilitate the discussion of the ^TMP global
          output.  Separator lines have also been added to the global
          data shown above for the same reason.
  
  
 OUTPUT: HR SUBSCRIPT
 --------------------
  
 ROW #1 in the global data above holds the grand totals for the call to
 $$CM^HLUCM.  The data in this row, ^TMP("TOTALS",$J), is the same as the
 value returned by the call to the $$CM^HLUCM API.
  
 ROWS #2-9 hold the totals for all messages divided  by the time of
 transmission.  The subscripts found in these rows are explained as
 follows:
  
    HR - Initial subscript for time-sorted data.  (This is a constant
         value; it will always be "HR".)
  
    TM - Second subscript for time-sorted data.  (This is also a
         constant value subscript.  It was added to keep the structure
         of this global the same as the other global sections mentioned
         below.)
  
    U -  This subscript specifies whether the message totals are from
         TCP (T), Mailman (M), or Unknown (U) activity.  In this example,
         the data is from "Unknown" activity.
  
    3010416.00 - Specifies the time of message transmission rounded to
         the hour.
  
    DG,SD - Namespaces of message totals in the above example.
  
    VAFH A08~4620 & VAFC ADT-A080SCHED SERVER~4654 - PROTOCOL file
         entries. ("VAFH A08" is the name of entry "4620" in the
         PROTOCOL file.)
  
 The following is a detailed explanation of ROWS 2# through #9.  The
 structure of this global is identical to that found in the "OUTPUT: NMSP
 SUBSCRIPT" and "OUTPUT: PROT SUBSCRIPT" sections of this patch
 description. (These sections can be found later in this document.)  So,
 the comments about structure made next are applicable to all sections
 of the ^TMP("TOTALS",$J) global.
  
 ROW #2 holds the grand total for all entries in the
 ^TMP("TOTALS",$J,"HR") section.  The totals of this node will always
 equal the grand total in the ^TMP("TOTALS",$J) node (i.e., ROW #1).
  
 ROW #4 holds the subtotals for all messages transmitted or received
 during the first hour of 4/1/2001 with a designation of "U" meaning
 "UNKNOWN."
  
 ROW #5 holds the subtotals for all messages transmitted during the
 first hour of 4/1/2001 (i.e., 3010416.00).  For the sake of brevity
 in this documentation, the total of this row equals the total of ROW #2,
 because only one hour was included in this example.  If instead of one
 hour, multiple hours had been included, there would be multiple subtotal
 nodes for each hour, and the sum of these subtotals would equal ROW #2.
 This can be seen more clearly in the next section of this patch
 description "OUTPUT: NMSP SUBSCRIPT".
  
 ROW #6 holds the subtotals for all messages with the "DG" namespace:
 289677 characters in 804 messages that were transmitted or received
 in 214 total seconds.
  
 ROW #7 holds the subtotals for all messages with the "DG" namespace,
 for protocol "VAFH A08~4620".
  
 ROW #8 holds the subtotals for all messages with the "SD" namespace.
  
 ROW #9 holds the subtotals for all messages with the "SD" namespace,
 for protocol "VAFC ADT-A08-SCHED SERVER~4654".
  
 Note that the totals of ROW #6 (289,677 characters, 804 messages, 214
 seconds) and ROW #8 (383 characters, 1 message, 578 seconds) equal the
 grand totals (290,060 characters, 805 messages, 792 seconds) returned
 for this section.
  
  
 OUTPUT: NMSP SUBSCRIPT
 ----------------------
  
 Refer to ROWS 10-26, the "NMSP", or namespace, section in the
 ^TMP("TOTALS",$J) global. The subscripts in this section are explained
 as follows:
  
  NMSP - Initial subscript for namespace data.
  
    IO - There are two subdivisions within this section:
            1. Incoming (I)/Outgoing (O)/Unknown (U).
            2. Local (L)/Remote (R)/Unknown (U).
         This IO subscript holds the Incoming/Outgoing subtotals.
  
    LR - The LR subscript holds the Local/Remote subtotals.
  
 The other subscripts in this section that are not mentioned are
 individual namespaces and protocols.
  
  
 OUTPUT: PROT SUBSCRIPT
 ----------------------
  
 Refer to ROWS 27-35, the subscripts in the protocol-related section of the ^
 "TOTALS",$J) global are explained as follows:
  
    PR - There are no variable subsections in this sections ( similar to
         the Local/Remote and the Incoming/Outgoing subtotals found in the
         previous section "OUTPUT: NMSP SUBSCRIPT.")  This means that the
         PR subscript will never change. (It was added to keep the data
         structure compatible with all other sections.)
  
    P -  This variable also is a placeholder like PR, and will not change.
  
 The other subscripts in this section that are not specifically mentioned
 are individual namespaces and protocols.
  
  
          ==================================================
  
  
 INPUT PARAMETERS: ADDITIONAL DISCUSSION
 ---------------------------------------
  
 The input parameters of the $$CM^HLUCM API were listed in detail in
 the "INPUT PARAMETERS" section of this patch description.  Discussion
 of these parameters, using the information just provided regarding
 entry point output as necessary background, will now be resumed.
  
  
 INPUT PARAMETERS: ADDITIONAL DISCUSSION - NAMESPACE
 ---------------------------------------------------
  
 There are four different ways to specify namespaces to be included when
 creating totals.  These are:
  
     1. Pass in "1" to specify that all namespaces are to be included, and
        that subtotals should be created by individual namespace(s).  (If
        you'll refer back to the sample data in "OUTPUT: HR SUBSCRIPT" of
        this patch description, you can see that each namespace was
        placed in the ^TMP("TOTALS",$J,"HR",...) global data because a "1"
        was passed in the namespace parameter.)
  
     2. Pass in "2" to specify that all namespaces are to be included, but
        no subtotaling by namespaces should be done.  Totals should be
        lumped together.  To further explain the results of passing a "2"
        in the namespace parameter position consider the following example.
  
 When $$CM^HLUCM(3010416,3010416.0005,2,1,"TOTALS","EITHER",.ERR) is
 called the following data in the NMSP subscript of the ^TMP global was
 created:
  
    ^TMP("TOTALS",549492684,"NMSP") = 290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","IO") = 290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","IO","O") = 290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","IO","O","ZZZ") = 290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","IO","O","ZZZ","3010416.00") = 290060
     ^805^792
    ^TMP("TOTALS",549492684,"NMSP","IO","O","ZZZ","3010416.00","VAFC ADT
     -A08-SCHED SERVER~4654") = 383^1^578
    ^TMP("TOTALS",549492684,"NMSP","IO","O","ZZZ","3010416.00","VAFH A08
     ~4620") = 289677^804^214
    ^TMP("TOTALS",549492684,"NMSP","LR") = 290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","LR","L") = 290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","LR","L","ZZZ") = 290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","LR","L","ZZZ","3010416.00") = 290060
     ^805^792
    ^TMP("TOTALS",549492684,"NMSP","LR","L","ZZZ","3010416.00","VAFC ADT
     -A08-SCHED SERVER~4654") = 383^1^578
    ^TMP("TOTALS",549492684,"NMSP","LR","L","ZZZ","3010416.00","VAFH A08
     ~4620") = 289677^804^214
  
 Note in the preceding example, no namespaces are specified and that all
 individual namespaces have been lumped together in the ZZZ "namespace."
  
 To further illustrate the effect when either the namespace or the
 protocol parameter value of "2" is passed into the API, notice the results
 below when the protocol value is passed as a "2".  (This is getting a
 little ahead of ourselves, because we are discussing the namespace
 parameter.  However, when a "2" is passed into the API in the protocol
 parameter position, it has the same effect as when a "2" is passed into
 the namespace position: data is "lumped" together under "ZZZ" rather than
 individual namespaces or protocols.).
  
 When $$CM^HLUCM(3010416,3010416.0005,2,2,"TOTALS","EITHER",.ERR) is
 called the following data in the NMSP subscript was created.
  
    ^TMP("TOTALS",549492684,"NMSP") = 290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","IO") = 290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","IO","O") = 290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","IO","O","ZZZ") = 290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","IO","O","ZZZ","3010416.00") = 290060
     ^805^792
    ^TMP("TOTALS",549492684,"NMSP","IO","O","ZZZ","3010416.00","ZZZ") =
     290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","LR") = 290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","LR","L") = 290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","LR","L","ZZZ") = 290060^805^792
    ^TMP("TOTALS",549492684,"NMSP","LR","L","ZZZ","3010416.00") = 290060
     ^805^792
    ^TMP("TOTALS",549492684,"NMSP","LR","L","ZZZ","3010416.00","ZZZ") =
     290060^805^792
  
 The listing of data in the preceding section, where namespace was passed
 as "2" and protocol was passed as "1", contains multiple protocols.
 This data does not.  As an example, refer to the "LR","L" subscript
 section of the data from both examples.  The first example "itemizes"
 the "VAFC ADT-A08-SCHED SERVER~4654" (383 characters, 1 message, 578
 seconds) AND "VAFH A08~4620" (289,677 characters, 804 messages, 214
 seconds) protocols.  In this last example, these protocols have been
 lumped together in the ZZZ "protocol" (290,060 characters, 805 messages,
 792 seconds.)
  
 There are four different ways to specify namespaces to be included when
 $$CM^HLUCM.  The first two - passing a "1" or "2" - have already been
 discussed.  The additional ways of specifying namespaces are explained
 next.
  
    3. Pass in "0^namespace" in order to search for one specific
       namespace.  An example call would be:
  
       $$CM^HLUCM(3010416,3010416.0005,"0^DG",2,"TOTALS","EITHER",.ERR).
  
    4. Specify namespaces by creating a local variable array and passing
 in the array by reference.  An example call, using this technique, is
 shown below.  The call is functionally identical to passing in "0^DG",
 but this method allows the inclusion of multiple namespaces.
  
    >K NAMESPACE
    >S NAMESPACE("DG")=""
    >W $$CM^HLUCM(3010416,3010416.0005,.NAMESPACE,2,"TOTALS","EITHER",.ERR)
  
  
 INPUT PARAMETERS: ADDITIONAL DISCUSSION - PROTOCOL
 --------------------------------------------------
  
 There are four different ways to specify protocols to be included when
 calling $$CM^HLUCM.  These are:
  
     1. Pass in "1" to specify that all protocols are to be included.
        (See the preceding "INPUT PARAMETERS: ADDITIONAL DISCUSSION -
        NAMESPACE" section for additional explanation.)
  
     2. Pass in "2" to specify that all namespaces are to be included, but
        no subtotaling by namespaces should be done.  (See the preceding
        "INPUT PARAMETERS: ADDITIONAL DISCUSSION - NAMESPACE" section for
        additional explanation.)
  
     3. Pass in "0^protocol name" or "0^protocol IEN" (i.e., the internal
        entry number (IEN) of the PROTOCOL file entry) in order to search 
        for one specific protocol.  (See the preceding "INPUT PARAMETERS: 
        ADDITIONAL DISCUSSION - NAMESPACE" section for additional 
        explanation.)
  
     4. Specify protocols by creating a local variable array and passing
        in the array by reference. The local array subscripts can be 
        either the protocol name or the protocol IEN. (See the preceding
        "INPUT PARAMETERS: ADDITIONAL DISCUSSION - NAMESPACE" section for
        additional explanation.)
  
  
          ==================================================
  
  
 API RULES OF OPERATION
 ----------------------
  
 There are several rules that are followed by the software when collecting
 data. These rules are explained in detail on the following pages of this
 patch description.
  
  
 API RULES OF OPERATION: EITHER CONDITION
 ----------------------------------------
 These rules are followed by the software when the "EITHER" CONDITION
 input parameter is specified:
  
     1. If an explicit namespace(s) and a protocol(s) is specified, all
        entries will be counted where the namespace or the protocol
        matches. Both namespace(s) and protocol(s) do not need to match.
        (For example, if the "0^DG" namespace and the "0^4625" protocol are
        passed, all entries for the "DG" namespace will be counted no
        matter what the associated protocol is.  And, all messages
        associated with the PROTOCOL file entry 4625 will be counted no
        matter what the associated namespace.)
  
     2. If an explicit namespace(s) is specified, and if the protocol is
        "all" - specified by passing "1" or "2" - all "DG" entries, but
        only "DG" entries will be counted no matter what the associated
        protocol.  (This is a slightly different than rule #1 above, and
        will usually return smaller totals.  Rule #2 is a way to ask for
        "all DGs, but DGs only", where rule #1 is a way to ask for "all
        DGs AND all 4625s".)
  
        Note: If all namespaces are specified, and a specific protocol(s)
              specified, (which is the opposite of the rule #2 example),
              the same logic is used.  (If all namespaces are requested
              by passing a "1" or a "2", and the protocol specified is
              "0^4625", only PROTOCOL file entry 4625 will be included.)
  
     3. If all namespaces and all protocols are specified, every message
        found will be included.  If the namespace of an entry cannot be
        determined it will be arbitrarily counted under the ZZZ
        "namespace."  If the associated protocol of a message cannot be
        determined, it will be similarly counted under the ZZZ
        "protocol."  This ensures that all entries, even those with
        missing namespaces and protocols are counted.
  
  
 API RULES OF OPERATION: BOTH CONDITION
 --------------------------------------
  
 These rules are followed when the "BOTH" CONDITION parameter is
 specified:
  
     1. If an explicit namespace(s) and protocol(s) is specified, entries
        will be counted only when the entry's namespace and protocol both
        match.  (For example, if the "0^DG" namespace and the "0^4625"
        protocol are passed, entries will be counted when the message is
        associated with the "DG" namespace, and the message's associated
        protocol is PROTOCOL file entry 4625.)
  
     2. The BOTH condition requires that the namespace(s) and
        the protocol(s) be specified.  Under no circumstances can either
        namespace or protocol be specified "all."
  
  
           ==================================================
  
  
 API RULES OF OPERATION: DEFAULTS
  
 --------------------------------
  
 Some input parameters are required, while others are not.  Default
 values are usually assigned to those parameters that are not required
 if they are not explicitly passed into the entry point.  This is
 explained in the table below.
  
  
 PARAMETER     REQUIRED     DEFAULT      COMMENTS
 -----------------------------------------------------------------------
 START         YES
 END           YES
 NAMESPACE     NO           1            "All", with subtotals
 PROTOCOL      NO           1            "All", with subtotals
 SAVE          NO           "TOTALS"     If not passed data will be
                                         stored in ^TMP("TOTALS",$J,...)
 CONDITION     NO           "EITHER"
 ERRORS        NO                        If "ERRORS" is not passed by
                                         reference, no error information
                                         will be returned
  
  
          ==================================================
  
  
 ERROR MESSAGES
 --------------
  
 Checks are made of the validity of the parameters passed into the
 $$CM^HLUCM entry point before any processing occurs.  If the
 parameters are not correct, processing aborts immediately, and the
 reasons for failure are returned in the ERRORS("failure reason")
 local array.
  
 All possible failure reasons are listed below:
  
    BOTH NAMESPACES(S) AND PROTOCOL(S) MUST BE PASSED SPECIFICALLY
    CAN'T FIND PROTOCOL
    INVALID END TIME
    INVALID NAMESPACE PARAMETER
    INVALID PROTOCOL PARAMETER
    INVALID START TIME
  
  
            ==================================================
  
  
 HELPFUL TIPS
 ------------
  
 It is recommended that users of the $$CM^HLUCM entry point experiment
 on a small time period until they are comfortable with the entry point,
 and understand how to pass parameter values properly.  After every call
 to $$CM^HLUCM, examine the resulting ^TMP global data.  Compare the
 ^TMP global data created by calls with differing parameters.
  
 The $$CM^HLUCM entry point does not record the internal entry numbers
 (IENs) of the messages found in the HL7 MESSAGE TEXT file (#772) and
 the HL7 MESSAGE ADMINISTRATION file (#773).  However, users of this
 entry point may make use of a developer debugging "backdoor" to
 capture these internal entry numbers for examination.  To do so, follow
 these steps:
  
     1. Set ^TMP($J,"HLUCM")="DEBUG GLOBAL".
     2. Call $$CM^HLUCM in the normal manner to find all matching messages.
  
 When this is done, the following occurs:
  
     1. File #772 and #773 entries, including internal entry numbers, are
        stored in ^TMP($J,"HLUCMSTORE","E").
     2. ^TMP($J,"HLUCM") is killed after $$CM^HLUCM execution is complete.
        (It must be reset each time before calling $$CM^HLUCM.)
  
 Debugging data is stored in ^TMP($J,"HLUCMSTORE","E") after $$CM^HLUCM
 processing completes, as shown below:
  
    ^TMP($J,"HLUCMSTORE","E",27244211,772,"IO","O")=""
    ^TMP($J,"HLUCMSTORE","E",27244211,772,"LR","L")=""
    ^TMP($J,"HLUCMSTORE","E",27244211,772,"TM","U")=""
    ^TMP($J,"HLUCMSTORE","E",27244211,773,2483957)=""
  
 In the preceding example, 27244211 is File #772's IEN.  2483957 is file
 #773's IEN.  File #773's entry 2483957 is linked with File #772 entry
 27244211.  The "IO", "LR", etc., subscripts are identical to the
 subscripts used in ^TMP(SAVE,$J) data.
  
 WARNING!  Use of this developer "backdoor" creates a large amount of
 information.  Use this technique only for small periods of time.
  
          ==================================================
  
 The VA Kernel checksums for the routines included in this patch
 (calculated using CHECK^XTSUMBLD) are listed below.
  
                Checksum           Checksum
 Routine Name   Before Patch       After Patch      Patch List
 -------------  -----------------  ---------------  ----------
 HLUCM               ----              8711789          79
 HLUCM001            ----              6749680          79
 HLUCM002            ----              4284229          79
  
 Sites should use CHECK^XTSUMBLD to verify checksums after patch
 installation.
  
  Installation Instructions:
  ==========================
 Step 1.  Users are allowed to be on the system during the installation.
          No actions need to be taken relative to links and filers.
  
 Step 2.  Use the INSTALL/CHECK MESSAGE option on the PackMan menu to
          load the HL*1.6*79 KIDS package onto your system.  This loads
          the patch into a transport global on your system.
  
 Step 3.  Use KIDS to install the Transport global. To do this, use 
          the 'Installation [XPD INSTALLATION MENU]' menu.  You should
          use each of the following 'Installation' menu options in the
          order shown below. Options 2-5 perform necessary preparatory
          work prior to the actual installation of the software on
          your system.  Using the 'Install Package(s)' menu option is the
          final step, and installs the software.
  
              2  Verify Checksums in Transport Global
              3  Print Transport Global
              4  Compare Transport Global to Current System
              5  Backup a Transport Global
              6  Install Package(s)
  
          When using the 'Install Package(s)' menu option to install 
          the patch build, you will be asked several questions.  The 
          questions asked, and the answers you should supply, are 
          shown below.
  
          INSTALL NAME: <HL*1.6*79>
            Want KIDS to INHIBIT LOGONS during the install?  <NO>
            Want to DISABLE Scheduled Options, Menu Options,
            and Protocols?  <NO>
  
 After completion of the steps listed above the routines HLUCM, HLUCM001, 
 and HLUCM002 will have been installed as working routines on your system.
  

Routine Information:
====================

=============================================================================
User Information:                               
Entered By  : ANDREASSEN,LARRY               Date Entered : MAR 08, 2001
Completed By: SINGH,GURBIR                  Date Completed: NOV 29, 2001
Released By : APOLONIO,AUGUSTO              Date Released : NOV 30, 2001
=============================================================================


Packman Mail Message:
=====================

$END TXT
