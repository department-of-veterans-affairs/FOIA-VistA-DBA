Released HL*1.6*79 SEQ #71
Extracted from mail message
**KIDS**:HL*1.6*79^

**INSTALL NAME**
HL*1.6*79
"BLD",444,0)
HL*1.6*79^HEALTH LEVEL SEVEN^0^3011126^y
"BLD",444,1,0)
^^1^1^3011126^
"BLD",444,1,1,0)
HL7 Capacity Mgt Phase I API
"BLD",444,4,0)
^9.64PA^^
"BLD",444,"ABPKG")
n
"BLD",444,"KRN",0)
^9.67PA^8989.52^20
"BLD",444,"KRN",.4,0)
.4
"BLD",444,"KRN",.401,0)
.401
"BLD",444,"KRN",.402,0)
.402
"BLD",444,"KRN",.403,0)
.403
"BLD",444,"KRN",.5,0)
.5
"BLD",444,"KRN",.84,0)
.84
"BLD",444,"KRN",3.6,0)
3.6
"BLD",444,"KRN",3.8,0)
3.8
"BLD",444,"KRN",9.2,0)
9.2
"BLD",444,"KRN",9.8,0)
9.8
"BLD",444,"KRN",9.8,"NM",0)
^9.68A^3^3
"BLD",444,"KRN",9.8,"NM",1,0)
HLUCM^^0^B51535925
"BLD",444,"KRN",9.8,"NM",2,0)
HLUCM001^^0^B47937329
"BLD",444,"KRN",9.8,"NM",3,0)
HLUCM002^^0^B24374559
"BLD",444,"KRN",9.8,"NM","B","HLUCM",1)

"BLD",444,"KRN",9.8,"NM","B","HLUCM001",2)

"BLD",444,"KRN",9.8,"NM","B","HLUCM002",3)

"BLD",444,"KRN",19,0)
19
"BLD",444,"KRN",19.1,0)
19.1
"BLD",444,"KRN",101,0)
101
"BLD",444,"KRN",409.61,0)
409.61
"BLD",444,"KRN",771,0)
771
"BLD",444,"KRN",870,0)
870
"BLD",444,"KRN",8989.51,0)
8989.51
"BLD",444,"KRN",8989.52,0)
8989.52
"BLD",444,"KRN",8994,0)
8994
"BLD",444,"KRN",8994.2,0)
8994.2
"BLD",444,"KRN","B",.4,.4)

"BLD",444,"KRN","B",.401,.401)

"BLD",444,"KRN","B",.402,.402)

"BLD",444,"KRN","B",.403,.403)

"BLD",444,"KRN","B",.5,.5)

"BLD",444,"KRN","B",.84,.84)

"BLD",444,"KRN","B",3.6,3.6)

"BLD",444,"KRN","B",3.8,3.8)

"BLD",444,"KRN","B",9.2,9.2)

"BLD",444,"KRN","B",9.8,9.8)

"BLD",444,"KRN","B",19,19)

"BLD",444,"KRN","B",19.1,19.1)

"BLD",444,"KRN","B",101,101)

"BLD",444,"KRN","B",409.61,409.61)

"BLD",444,"KRN","B",771,771)

"BLD",444,"KRN","B",870,870)

"BLD",444,"KRN","B",8989.51,8989.51)

"BLD",444,"KRN","B",8989.52,8989.52)

"BLD",444,"KRN","B",8994,8994)

"BLD",444,"KRN","B",8994.2,8994.2)

"BLD",444,"QUES",0)
^9.62^^
"BLD",444,"REQB",0)
^9.611^^
"MBREQ")
0
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
79^3011126
"PKG",9,22,1,"PAH",1,1,0)
^^1^1^3011126
"PKG",9,22,1,"PAH",1,1,1,0)
HL7 Capacity Mgt Phase I API
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
3
"RTN","HLUCM")
0^1^B51535925
"RTN","HLUCM",1,0)
HLUCM ;CIOFO-O/LJA - HL7/Capacity Mgt API ;2/27/01 10:15
"RTN","HLUCM",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**79**;Oct 13, 1995
"RTN","HLUCM",3,0)
 ;
"RTN","HLUCM",4,0)
 QUIT
"RTN","HLUCM",5,0)
 ;
"RTN","HLUCM",6,0)
CM(START,END,PNMSP,IEN101,TOTALS,COND,ERRINFO) ; Capacity management totals
"RTN","HLUCM",7,0)
 N ERR,DATA,IEN772,IEN773,LOOPDT,NMSPTYPE,PROTOCOL,PROTYPE,RESULTS,X
"RTN","HLUCM",8,0)
 ; NEWs above for $$SETUP and subcalls, and for $$LOOP and subcalls
"RTN","HLUCM",9,0)
 ;
"RTN","HLUCM",10,0)
 ; In case developer is debugging, kill storage location...
"RTN","HLUCM",11,0)
 KILL ^TMP($J,"HLUCMSTORE")
"RTN","HLUCM",12,0)
 ;
"RTN","HLUCM",13,0)
 ; This is where results are returned to caller...
"RTN","HLUCM",14,0)
 KILL ERRINFO
"RTN","HLUCM",15,0)
 ;
"RTN","HLUCM",16,0)
 ; Perform all setup chores.  If errors found, they will be placed
"RTN","HLUCM",17,0)
 ; in ERRINFO(ERROR-REASON)="" array
"RTN","HLUCM",18,0)
 QUIT:$$SETUP "" ;-> Some errors occurred...
"RTN","HLUCM",19,0)
 ;
"RTN","HLUCM",20,0)
 ; Loop and count here...  (MAIN WORK LOOP)
"RTN","HLUCM",21,0)
 S RESULTS=$$LOOP
"RTN","HLUCM",22,0)
 ;
"RTN","HLUCM",23,0)
 ; If developer has set ^TMP($J,"HLUCM")="DEBUG GLOBAL" to capture
"RTN","HLUCM",24,0)
 ; specific entries counted, kill it on exit...
"RTN","HLUCM",25,0)
 KILL ^TMP($J,"HLUCM")
"RTN","HLUCM",26,0)
 ;
"RTN","HLUCM",27,0)
 QUIT RESULTS
"RTN","HLUCM",28,0)
 ;
"RTN","HLUCM",29,0)
SETUP() ; Perform checks, which can return error conditions, and
"RTN","HLUCM",30,0)
 ; set up variables for $$LOOP.  This extrinsic function returns
"RTN","HLUCM",31,0)
 ; "" if no errors, or the # errors found.  (Note that error
"RTN","HLUCM",32,0)
 ; details placed in ERRINFO(ERROR-REASON)="")
"RTN","HLUCM",33,0)
 N NOERR
"RTN","HLUCM",34,0)
 S NOERR=""
"RTN","HLUCM",35,0)
 D SETDEF ; Set defaults for parameters, if not passed
"RTN","HLUCM",36,0)
 D FINDWAY ; Find way NMSP and PROT parameters passed
"RTN","HLUCM",37,0)
 D SETMORE ; Additional var sets based on parameters & "way"...
"RTN","HLUCM",38,0)
 D ERRCHK ; Check for errors...
"RTN","HLUCM",39,0)
 KILL ^TMP(TOTALS,$J) ; Clear out storage location...
"RTN","HLUCM",40,0)
 QUIT NOERR
"RTN","HLUCM",41,0)
 ;
"RTN","HLUCM",42,0)
SETDEF ; Set various defaults...
"RTN","HLUCM",43,0)
 I '$D(PNMSP) S PNMSP=1
"RTN","HLUCM",44,0)
 I '$D(IEN101) S IEN101=1
"RTN","HLUCM",45,0)
 I $G(TOTALS)']"" S TOTALS="TOTALS"
"RTN","HLUCM",46,0)
 S COND=$$UP^XLFSTR(COND)
"RTN","HLUCM",47,0)
 S COND=$S($G(COND)="BOTH":COND,1:"EITHER") ; Default to EITHER matches, count it...
"RTN","HLUCM",48,0)
 QUIT
"RTN","HLUCM",49,0)
 ;
"RTN","HLUCM",50,0)
FINDWAY ; How were NMSP and PROT passed?  By reference?  (If so, return 1)
"RTN","HLUCM",51,0)
 ; Passed by reference?
"RTN","HLUCM",52,0)
 S NMSPTYPE=$S($G(PNMSP)']""&($O(PNMSP(""))]""):1,1:0) ; 1=YES
"RTN","HLUCM",53,0)
 S PROTYPE=$S($G(IEN101)']""&($O(IEN101(""))]""):1,1:0) ; 1=YES
"RTN","HLUCM",54,0)
 QUIT
"RTN","HLUCM",55,0)
 ;
"RTN","HLUCM",56,0)
ERRCHK ; Error checks...
"RTN","HLUCM",57,0)
 ;
"RTN","HLUCM",58,0)
 ; DATE checks...
"RTN","HLUCM",59,0)
 S START=+$G(START),END=+$G(END)
"RTN","HLUCM",60,0)
 I START'?7N&(START'?7N1"."1.N) D ERR("INVALID START TIME")
"RTN","HLUCM",61,0)
 I END'?7N&(END'?7N1"."1.N) D ERR("INVALID END TIME")
"RTN","HLUCM",62,0)
 I '$D(ERRINFO("INVALID START TIME")) D
"RTN","HLUCM",63,0)
 .  I '$D(ERRINFO("INVALID END TIME")) D
"RTN","HLUCM",64,0)
 .  .  I START=END!(START<END) QUIT  ;->
"RTN","HLUCM",65,0)
 .  .  D ERR("END TIME PRECEDES START TIME")
"RTN","HLUCM",66,0)
 ;
"RTN","HLUCM",67,0)
 ; If condition=BOTH, can't be ALL(1/2) and ALL(1/2) or
"RTN","HLUCM",68,0)
 ; ALL(1/2) and SPECIFIC. BOTH can only be SPECIFIC and SPECIFIC.
"RTN","HLUCM",69,0)
 I COND="BOTH" D
"RTN","HLUCM",70,0)
 .  N P1,P2
"RTN","HLUCM",71,0)
 .  S P1=$S($G(PNMSP)>0:1,1:0) ; namespace 0/1
"RTN","HLUCM",72,0)
 .  S P2=$S($G(IEN101)>0:1,1:0) ; protocol 0/1
"RTN","HLUCM",73,0)
 .  S P3=P1+P2 QUIT:P3'>0  ;->
"RTN","HLUCM",74,0)
 .  D ERR("BOTH NAMESPACES(S) AND PROTOCOL(S) MUST BE PASSED SPECIFICALLY")
"RTN","HLUCM",75,0)
 QUIT
"RTN","HLUCM",76,0)
 ;
"RTN","HLUCM",77,0)
SETMORE ; More defaults...
"RTN","HLUCM",78,0)
 ; 
"RTN","HLUCM",79,0)
 ; Check format of PNMSP...
"RTN","HLUCM",80,0)
 ; If not passed by reference...
"RTN","HLUCM",81,0)
 I 'NMSPTYPE D  ; Namespace(s) not passed as an array
"RTN","HLUCM",82,0)
 .  ; Passed as 1 or 2 or O^NMSP, but is it valid?
"RTN","HLUCM",83,0)
 .  I '$$OKPAR^HLUCM002(PNMSP) D
"RTN","HLUCM",84,0)
 .  .  D ERR("INVALID NAMESPACE PARAMETER")
"RTN","HLUCM",85,0)
 ;
"RTN","HLUCM",86,0)
 ; Check format of IEN101...
"RTN","HLUCM",87,0)
 ; If not passed by reference...
"RTN","HLUCM",88,0)
 I 'PROTYPE D  ; Protocol(s) not passed as an array
"RTN","HLUCM",89,0)
 .  ; Passed as 1 or 2 or 0^PROT or 0^IEN, but is it valid?
"RTN","HLUCM",90,0)
 .  I '$$OKPAR^HLUCM002(IEN101) D  ; Check format...
"RTN","HLUCM",91,0)
 .  .  D ERR("INVALID PROTOCOL PARAMETER")
"RTN","HLUCM",92,0)
 .  S IEN101=$$OKPAR101^HLUCM001($G(IEN101)) I IEN101']"" D
"RTN","HLUCM",93,0)
 .  .  I $D(ERRINFO("INVALID PROTOCOL PARAMETER")) QUIT  ;->
"RTN","HLUCM",94,0)
 .  .  D ERR("CAN'T FIND PROTOCOL")
"RTN","HLUCM",95,0)
 QUIT
"RTN","HLUCM",96,0)
 ;
"RTN","HLUCM",97,0)
LOOP() ; Loop thru 772's .01... (Called from LOOP^HLUCM)
"RTN","HLUCM",98,0)
 N IEN772,LOOPDT,RESULTS,TM772,X
"RTN","HLUCM",99,0)
 ;
"RTN","HLUCM",100,0)
 S LOOPDT=START-.000001
"RTN","HLUCM",101,0)
 F  S LOOPDT=$O(^HL(772,"B",LOOPDT)) Q:LOOPDT'>0!(LOOPDT>END)  D
"RTN","HLUCM",102,0)
 .  S IEN772=0
"RTN","HLUCM",103,0)
 .  F  S IEN772=$O(^HL(772,"B",LOOPDT,IEN772)) Q:IEN772'>0  D
"RTN","HLUCM",104,0)
 .  .  D COLLECT(IEN772) ; All 772 & 773 actions performed in COLLECT
"RTN","HLUCM",105,0)
 .  .
"RTN","HLUCM",106,0)
 .  .  ; trap debug data?
"RTN","HLUCM",107,0)
 .  .  QUIT:$G(^TMP($J,"HLUCM"))'="DEBUG GLOBAL"  ;->
"RTN","HLUCM",108,0)
 .  .  ; (Remember!  this data is killed, including the ^TMP($J,"HLUCM")
"RTN","HLUCM",109,0)
 .  .  ; global which causes the debug data collect at the end of
"RTN","HLUCM",110,0)
 .  .  ; execution of the $$CM call.)
"RTN","HLUCM",111,0)
 .  .
"RTN","HLUCM",112,0)
 .  .  ; store debug info...
"RTN","HLUCM",113,0)
 .  .  S TM772=+$G(^HL(772,+IEN772,0)) Q:TM772'?7N.E  ;->
"RTN","HLUCM",114,0)
 .  .  S:$G(^TMP($J,"HLUCM","FIRST"))']"" ^TMP($J,"HLUCM","FIRST")=TM772
"RTN","HLUCM",115,0)
 .  .  S:$G(^TMP($J,"HLUCM","LAST"))']"" ^TMP($J,"HLUCM","LAST")=TM772
"RTN","HLUCM",116,0)
 .  .  S X=$G(^TMP($J,"HLUCM","FIRST")) I +X>TM772 S ^TMP($J,"HLUCM","FIRST")=TM772
"RTN","HLUCM",117,0)
 .  .  S X=$G(^TMP($J,"HLUCM","LAST")) I +X<TM772 S ^TMP($J,"HLUCM","LAST")=TM772
"RTN","HLUCM",118,0)
 .  .  S ^TMP($J,"HLUCM","TOTAL")=$G(^TMP($J,"HLUCM","TOTAL"))+1
"RTN","HLUCM",119,0)
 ;
"RTN","HLUCM",120,0)
 I $D(^TMP($J,"HLUCM")) D
"RTN","HLUCM",121,0)
 .  W !!,"First: ",?20
"RTN","HLUCM",122,0)
 .  S X=$G(^TMP($J,"HLUCM","FIRST"))
"RTN","HLUCM",123,0)
 .  F  Q:X']""  W $E(X,1,60) S X=$E(X,61,999) W:X]"" !,?20
"RTN","HLUCM",124,0)
 .  W !,"Last: ",?20
"RTN","HLUCM",125,0)
 .  S X=$G(^TMP($J,"HLUCM","LAST"))
"RTN","HLUCM",126,0)
 .  F  Q:X']""  W $E(X,1,60) S X=$E(X,61,999) W:X]"" !,?20
"RTN","HLUCM",127,0)
 .  W !,"Number: ",?20,$G(^TMP($J,"HLUCM","TOTAL"))
"RTN","HLUCM",128,0)
 .  KILL ^TMP($J,"HLUCM")
"RTN","HLUCM",129,0)
 .  W !!,"Each entry counted is stored in ^TMP($J,""HLUCMSTORE"")..."
"RTN","HLUCM",130,0)
 .  W !
"RTN","HLUCM",131,0)
 ;
"RTN","HLUCM",132,0)
 S RESULTS=$G(^TMP(TOTALS,$J))
"RTN","HLUCM",133,0)
 ;
"RTN","HLUCM",134,0)
 QUIT RESULTS
"RTN","HLUCM",135,0)
 ;
"RTN","HLUCM",136,0)
COLLECT(IEN772) ; Collect 772 data and associated 773 data...
"RTN","HLUCM",137,0)
 N DATA,IEN773,PP,TYPEHR,TYPEIO,TYPELR
"RTN","HLUCM",138,0)
 ;
"RTN","HLUCM",139,0)
 ; Get protocol and package namespace for storing in ^TMP()
"RTN","HLUCM",140,0)
 S PP=$$PROTNMSP^HLUCM002(+IEN772)
"RTN","HLUCM",141,0)
 I $P(PP,U)']""!($P(PP,U,2)']"") QUIT  ;->
"RTN","HLUCM",142,0)
 S (DATA("PROT"),PROT)=$P(PP,U),PROT=$S(PROT]"":PROT,1:"ZZZ")
"RTN","HLUCM",143,0)
 S (DATA("PCKG"),PCKG)=$P(PP,U,2),PCKG=$S(PCKG]"":PCKG,1:"ZZZ")
"RTN","HLUCM",144,0)
 ;
"RTN","HLUCM",145,0)
 ; Get variable used as sorting value in ^TMP(..."HR"...) global...
"RTN","HLUCM",146,0)
 S TYPEHR=$$TYPETMO^HLUCM002(IEN772)
"RTN","HLUCM",147,0)
 ;
"RTN","HLUCM",148,0)
 ; Get variable used as I/O sorting value in ^TMP("..."NMSP"...) global...
"RTN","HLUCM",149,0)
 S TYPEIO=$$TYPEIO^HLUCM002(IEN772)
"RTN","HLUCM",150,0)
 ;
"RTN","HLUCM",151,0)
 ; Get variable used as L/R sorting value in ^TMP("..."NMSP"...) global...
"RTN","HLUCM",152,0)
 S TYPELR=$$TYPELR^HLUCM001(IEN772)
"RTN","HLUCM",153,0)
 ;
"RTN","HLUCM",154,0)
 ; Place 772 numbers in DATA(...)
"RTN","HLUCM",155,0)
 D TOT772(IEN772)
"RTN","HLUCM",156,0)
 ;
"RTN","HLUCM",157,0)
 ; Loop thru all associated 773s and put #s in DATA(...) also...
"RTN","HLUCM",158,0)
 S IEN773=0
"RTN","HLUCM",159,0)
 F  S IEN773=$O(^HLMA("B",IEN772,IEN773)) Q:IEN773'>0  D
"RTN","HLUCM",160,0)
 .  D TOT773(IEN773)
"RTN","HLUCM",161,0)
 ;
"RTN","HLUCM",162,0)
 ; Data OK?
"RTN","HLUCM",163,0)
 QUIT:$G(DATA("CHAR"))'>0  ;->
"RTN","HLUCM",164,0)
 S DATA("START")=$O(DATA("TIME",0)) QUIT:DATA("START")'>0  ;->
"RTN","HLUCM",165,0)
 S DATA("END")=$O(DATA("TIME",":"),-1)
"RTN","HLUCM",166,0)
 S DATA("DIFF")=$$SEC(DATA("END"))-$$SEC(DATA("START"))
"RTN","HLUCM",167,0)
 ;
"RTN","HLUCM",168,0)
 ; Store DATA() info in ^TMP(TOTALS,$J,...)
"RTN","HLUCM",169,0)
 D ADDTMP^HLUCM001
"RTN","HLUCM",170,0)
 ;
"RTN","HLUCM",171,0)
 QUIT
"RTN","HLUCM",172,0)
 ;
"RTN","HLUCM",173,0)
TOT772(IEN772) ; Total 772 message size and process time...
"RTN","HLUCM",174,0)
 ; DATA() -- passed in (see COLLECT)
"RTN","HLUCM",175,0)
 ;
"RTN","HLUCM",176,0)
 D TOT772C(IEN772) ; total # characters...
"RTN","HLUCM",177,0)
 D TOT772T(IEN772) ; total processing time...
"RTN","HLUCM",178,0)
 ;
"RTN","HLUCM",179,0)
 QUIT:$G(^TMP($J,"HLUCM"))'="DEBUG GLOBAL"  ;->
"RTN","HLUCM",180,0)
 S ^TMP($J,"HLUCMSTORE",IEN772,772,"TM",TYPEHR)=""
"RTN","HLUCM",181,0)
 S ^TMP($J,"HLUCMSTORE",IEN772,772,"IO",TYPEIO)=""
"RTN","HLUCM",182,0)
 S ^TMP($J,"HLUCMSTORE",IEN772,772,"LR",TYPELR)=""
"RTN","HLUCM",183,0)
 ;
"RTN","HLUCM",184,0)
 QUIT
"RTN","HLUCM",185,0)
 ;
"RTN","HLUCM",186,0)
TOT772C(IEN772) ; Total number of characters in message...
"RTN","HLUCM",187,0)
 N LEN,LNO,TXT
"RTN","HLUCM",188,0)
 ;
"RTN","HLUCM",189,0)
 ; Use field if present.  (Not present about 25% of time)
"RTN","HLUCM",190,0)
 S LEN=$P($G(^HL(772,IEN772,"S")),U)
"RTN","HLUCM",191,0)
 I LEN D  QUIT  ;->
"RTN","HLUCM",192,0)
 .  S DATA("CHAR",772)=$G(DATA("CHAR",772))+LEN
"RTN","HLUCM",193,0)
 .  S DATA("CHAR")=$G(DATA("CHAR"))+LEN
"RTN","HLUCM",194,0)
 ;
"RTN","HLUCM",195,0)
 ; Total manually...
"RTN","HLUCM",196,0)
 S LNO=0
"RTN","HLUCM",197,0)
 F  S LNO=$O(^HL(772,IEN772,"IN",LNO)) Q:LNO'>0  D
"RTN","HLUCM",198,0)
 .  S TXT=$G(^HL(772,IEN772,"IN",+LNO,0)) QUIT:TXT']""  ;->
"RTN","HLUCM",199,0)
 .  S DATA("CHAR",772)=$G(DATA("CHAR",772))+$L(TXT)
"RTN","HLUCM",200,0)
 .  S DATA("CHAR")=$G(DATA("CHAR"))+$L(TXT)
"RTN","HLUCM",201,0)
 ;
"RTN","HLUCM",202,0)
 QUIT
"RTN","HLUCM",203,0)
 ;
"RTN","HLUCM",204,0)
TOT772T(IEN772) ; Processing time...
"RTN","HLUCM",205,0)
 ; No totals here.  Just set times in DATA() array for later use...
"RTN","HLUCM",206,0)
 N TIME
"RTN","HLUCM",207,0)
 ;
"RTN","HLUCM",208,0)
 ; Time of entry...
"RTN","HLUCM",209,0)
 S TIME=+$G(^HL(772,+IEN772,0))
"RTN","HLUCM",210,0)
 I TIME?7N.E S DATA("TIME",TIME,772,.01)=""
"RTN","HLUCM",211,0)
 ;
"RTN","HLUCM",212,0)
 ; Time processed...
"RTN","HLUCM",213,0)
 S TIME=$P($G(^HL(772,+IEN772,"P")),U,2)
"RTN","HLUCM",214,0)
 I TIME?7N.E S DATA("TIME",TIME,772,21)=""
"RTN","HLUCM",215,0)
 ;
"RTN","HLUCM",216,0)
 QUIT
"RTN","HLUCM",217,0)
 ;
"RTN","HLUCM",218,0)
TOT773(IEN773) ; Total # charactes and times...
"RTN","HLUCM",219,0)
 ; DATA() -- passed in  (See COLLECT)
"RTN","HLUCM",220,0)
 ;
"RTN","HLUCM",221,0)
 D TOT773C(IEN773) ; Total characters...
"RTN","HLUCM",222,0)
 D TOT773T(IEN773) ; Set times...
"RTN","HLUCM",223,0)
 ;
"RTN","HLUCM",224,0)
 QUIT:$G(^TMP($J,"HLUCM"))'="DEBUG GLOBAL"  ;->
"RTN","HLUCM",225,0)
 S ^TMP($J,"HLUCMSTORE",IEN772,773,IEN773)=""
"RTN","HLUCM",226,0)
 ;
"RTN","HLUCM",227,0)
 QUIT
"RTN","HLUCM",228,0)
 ;
"RTN","HLUCM",229,0)
TOT773C(IEN773) ; Total number of characters...
"RTN","HLUCM",230,0)
 ; DATA() -- passed in  (See COLLECT)
"RTN","HLUCM",231,0)
 N CHAR
"RTN","HLUCM",232,0)
 S CHAR=$$MSGSIZE^HLCSUTL(+IEN773) QUIT:CHAR'>0  ;->
"RTN","HLUCM",233,0)
 S DATA("CHAR",773,IEN773)=CHAR
"RTN","HLUCM",234,0)
 S DATA("CHAR")=$G(DATA("CHAR"))+CHAR
"RTN","HLUCM",235,0)
 QUIT
"RTN","HLUCM",236,0)
 ;
"RTN","HLUCM",237,0)
TOT773T(IEN773) ; Set TIMEs...
"RTN","HLUCM",238,0)
 ; DATA() -- passed in  (See COLLECT)
"RTN","HLUCM",239,0)
 N TIME
"RTN","HLUCM",240,0)
 ;
"RTN","HLUCM",241,0)
 ; Creation time already taken from 772...
"RTN","HLUCM",242,0)
 ;
"RTN","HLUCM",243,0)
 ; Processed time...
"RTN","HLUCM",244,0)
 S TIME=+$G(^HLMA(+IEN773,"S")) QUIT:TIME'>0  ;->
"RTN","HLUCM",245,0)
 S DATA("TIME",TIME,773,100)=""
"RTN","HLUCM",246,0)
 ;
"RTN","HLUCM",247,0)
 QUIT
"RTN","HLUCM",248,0)
 ;
"RTN","HLUCM",249,0)
ERR(REA) ; Record error...
"RTN","HLUCM",250,0)
 S NOERR=NOERR+1
"RTN","HLUCM",251,0)
 S REA=$S($G(REA)]"":REA,1:"?")
"RTN","HLUCM",252,0)
 S ERRINFO(REA)=""
"RTN","HLUCM",253,0)
 QUIT
"RTN","HLUCM",254,0)
 ;
"RTN","HLUCM",255,0)
SEC(FMDT) ;
"RTN","HLUCM",256,0)
 S FMDT=$$FMTH^XLFDT(FMDT)
"RTN","HLUCM",257,0)
 QUIT $$SEC^XLFDT(FMDT)
"RTN","HLUCM",258,0)
 ;
"RTN","HLUCM",259,0)
EOR ; HLUCM - HL7/Capacity Mgt API ;2/27/01 10:15
"RTN","HLUCM001")
0^2^B47937329
"RTN","HLUCM001",1,0)
HLUCM001 ;CIOFO-O/LJA - HL7/Capacity Mgt API (continued) ;2/27/01 10:15
"RTN","HLUCM001",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**79**;Oct 13, 1995
"RTN","HLUCM001",3,0)
 ;
"RTN","HLUCM001",4,0)
ADDTMP ; Accumulate totals into ^TMP(TOTALS,$J,...)
"RTN","HLUCM001",5,0)
 ; TYPEHR,TYPEIO,TYPELR -- req
"RTN","HLUCM001",6,0)
 ;
"RTN","HLUCM001",7,0)
 N CHAR,SEC,START,TOTCURR
"RTN","HLUCM001",8,0)
 ;
"RTN","HLUCM001",9,0)
 S CHAR=DATA("CHAR")
"RTN","HLUCM001",10,0)
 S SEC=DATA("DIFF")
"RTN","HLUCM001",11,0)
 S START=$$HR(DATA("START"))
"RTN","HLUCM001",12,0)
 ;
"RTN","HLUCM001",13,0)
 D ACCUMHR
"RTN","HLUCM001",14,0)
 D ACCUMSP
"RTN","HLUCM001",15,0)
 D ACCUMPR
"RTN","HLUCM001",16,0)
 ;
"RTN","HLUCM001",17,0)
 ; Grand totals...
"RTN","HLUCM001",18,0)
 S TOTCURR=$G(^TMP(TOTALS,$J))
"RTN","HLUCM001",19,0)
 S $P(TOTCURR,U)=$P(TOTCURR,U)+DATA("CHAR")
"RTN","HLUCM001",20,0)
 S $P(TOTCURR,U,2)=$P(TOTCURR,U,2)+1
"RTN","HLUCM001",21,0)
 S $P(TOTCURR,U,3)=$P(TOTCURR,U,3)+DATA("DIFF")
"RTN","HLUCM001",22,0)
 S ^TMP(TOTALS,$J)=TOTCURR
"RTN","HLUCM001",23,0)
 ;
"RTN","HLUCM001",24,0)
 QUIT
"RTN","HLUCM001",25,0)
 ;
"RTN","HLUCM001",26,0)
ACCUMHR ; Hour totaling
"RTN","HLUCM001",27,0)
 ; DATA(),START,TYPEHR -- req
"RTN","HLUCM001",28,0)
 ;
"RTN","HLUCM001",29,0)
 D ACCUMLAT("HR","TM",TYPEHR,START,DATA("PCKG"),DATA("PROT"))
"RTN","HLUCM001",30,0)
 ;
"RTN","HLUCM001",31,0)
 ; Total level CATEGORY
"RTN","HLUCM001",32,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,"HR"))
"RTN","HLUCM001",33,0)
 D INCR
"RTN","HLUCM001",34,0)
 S ^TMP(TOTALS,$J,"HR")=TOTCURR
"RTN","HLUCM001",35,0)
 ;
"RTN","HLUCM001",36,0)
 QUIT
"RTN","HLUCM001",37,0)
 ;
"RTN","HLUCM001",38,0)
ACCUMSP ; Namespace totaling
"RTN","HLUCM001",39,0)
 ; DATA(),TYPEIO,TYPELR -- req
"RTN","HLUCM001",40,0)
 ;
"RTN","HLUCM001",41,0)
 D ACCUMLAT("NMSP","IO",TYPEIO,DATA("PCKG"),START,DATA("PROT"))
"RTN","HLUCM001",42,0)
 D ACCUMLAT("NMSP","LR",TYPELR,DATA("PCKG"),START,DATA("PROT"))
"RTN","HLUCM001",43,0)
 ;
"RTN","HLUCM001",44,0)
 ; Total level CATEGORY
"RTN","HLUCM001",45,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,"NMSP"))
"RTN","HLUCM001",46,0)
 D INCR
"RTN","HLUCM001",47,0)
 S ^TMP(TOTALS,$J,"NMSP")=TOTCURR
"RTN","HLUCM001",48,0)
 ;
"RTN","HLUCM001",49,0)
 QUIT
"RTN","HLUCM001",50,0)
 ;
"RTN","HLUCM001",51,0)
ACCUMPR ; Protocol totaling...
"RTN","HLUCM001",52,0)
 ; DATA(),START -- req
"RTN","HLUCM001",53,0)
 ;
"RTN","HLUCM001",54,0)
 D ACCUMLAT("PROT","PR","P",DATA("PROT"),DATA("PCKG"),START)
"RTN","HLUCM001",55,0)
 ;
"RTN","HLUCM001",56,0)
 ; Total level CATEGORY
"RTN","HLUCM001",57,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,"PROT"))
"RTN","HLUCM001",58,0)
 D INCR
"RTN","HLUCM001",59,0)
 S ^TMP(TOTALS,$J,"PROT")=TOTCURR
"RTN","HLUCM001",60,0)
 ;
"RTN","HLUCM001",61,0)
 QUIT
"RTN","HLUCM001",62,0)
 ;
"RTN","HLUCM001",63,0)
ACCUMLAT(CATEGORY,TYPE,SORT,SUB1,SUB2,SUB3) ; Generic accumulator
"RTN","HLUCM001",64,0)
 ; Totals level 3 for SUB...
"RTN","HLUCM001",65,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,CATEGORY,TYPE,SORT,SUB1,SUB2,SUB3))
"RTN","HLUCM001",66,0)
 D INCR
"RTN","HLUCM001",67,0)
 S ^TMP(TOTALS,$J,CATEGORY,TYPE,SORT,SUB1,SUB2,SUB3)=TOTCURR
"RTN","HLUCM001",68,0)
 ;
"RTN","HLUCM001",69,0)
 ; Totals level 2 for SUB...
"RTN","HLUCM001",70,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,CATEGORY,TYPE,SORT,SUB1,SUB2))
"RTN","HLUCM001",71,0)
 D INCR
"RTN","HLUCM001",72,0)
 S ^TMP(TOTALS,$J,CATEGORY,TYPE,SORT,SUB1,SUB2)=TOTCURR
"RTN","HLUCM001",73,0)
 ;
"RTN","HLUCM001",74,0)
 ; Totals level 1 for SUB...
"RTN","HLUCM001",75,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,CATEGORY,TYPE,SORT,SUB1))
"RTN","HLUCM001",76,0)
 D INCR
"RTN","HLUCM001",77,0)
 S ^TMP(TOTALS,$J,CATEGORY,TYPE,SORT,SUB1)=TOTCURR
"RTN","HLUCM001",78,0)
 ;
"RTN","HLUCM001",79,0)
 ; Total level TYPE/SORT...
"RTN","HLUCM001",80,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,CATEGORY,TYPE,SORT))
"RTN","HLUCM001",81,0)
 D INCR
"RTN","HLUCM001",82,0)
 S ^TMP(TOTALS,$J,CATEGORY,TYPE,SORT)=TOTCURR
"RTN","HLUCM001",83,0)
 ;
"RTN","HLUCM001",84,0)
 ; Total level TYPE
"RTN","HLUCM001",85,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,CATEGORY,TYPE))
"RTN","HLUCM001",86,0)
 D INCR
"RTN","HLUCM001",87,0)
 S ^TMP(TOTALS,$J,CATEGORY,TYPE)=TOTCURR
"RTN","HLUCM001",88,0)
 ;
"RTN","HLUCM001",89,0)
 ; Total level CATEGORY
"RTN","HLUCM001",90,0)
 ; [Don't subtotal here, for NMSP holds two different TYPEs, and
"RTN","HLUCM001",91,0)
 ; if totalled here, it would double count.]
"RTN","HLUCM001",92,0)
 ;
"RTN","HLUCM001",93,0)
 QUIT
"RTN","HLUCM001",94,0)
 ;
"RTN","HLUCM001",95,0)
PAR(PAR) ;
"RTN","HLUCM001",96,0)
 I PAR="START" QUIT $$HR(+DATA("START")) ;->
"RTN","HLUCM001",97,0)
 I PAR="PROT" QUIT $S($G(IEN101)="ZZZ":"ZZZ",1:DATA("PROT")) ;->
"RTN","HLUCM001",98,0)
 I PAR="PCKG" QUIT $S($G(PNMSP)="ZZZ":"ZZZ",1:DATA("PCKG")) ;->
"RTN","HLUCM001",99,0)
 QUIT "ZZZ"
"RTN","HLUCM001",100,0)
 ;
"RTN","HLUCM001",101,0)
INCR ; Increment totals in TOTCURR...
"RTN","HLUCM001",102,0)
 ; CHAR,SEC -- req
"RTN","HLUCM001",103,0)
 S $P(TOTCURR,U)=$P(TOTCURR,U)+CHAR ; Number characters
"RTN","HLUCM001",104,0)
 S $P(TOTCURR,U,2)=$P(TOTCURR,U,2)+1 ; Number messages
"RTN","HLUCM001",105,0)
 S $P(TOTCURR,U,3)=$P(TOTCURR,U,3)+SEC ; Processing seconds
"RTN","HLUCM001",106,0)
 QUIT
"RTN","HLUCM001",107,0)
 ;
"RTN","HLUCM001",108,0)
HR(FMDT) ; Return FM DATE and HOUR only...
"RTN","HLUCM001",109,0)
 N HR
"RTN","HLUCM001",110,0)
 S FMDT=$G(FMDT)
"RTN","HLUCM001",111,0)
 I FMDT'?7N&(FMDT'?7N1"."1.N) QUIT "" ;->
"RTN","HLUCM001",112,0)
 S:FMDT'["." FMDT=FMDT_"."
"RTN","HLUCM001",113,0)
 S FMDT=$E(FMDT_"00",1,10) ; .00 thru .23 now...
"RTN","HLUCM001",114,0)
 S HR=+$P(FMDT,".",2)+1
"RTN","HLUCM001",115,0)
 S:HR<10 HR=0_HR S:HR>24 HR=24
"RTN","HLUCM001",116,0)
 QUIT (FMDT\1)_"."_HR
"RTN","HLUCM001",117,0)
 ;
"RTN","HLUCM001",118,0)
OKPAR101(PAR) ; PAR=IEN101...
"RTN","HLUCM001",119,0)
 N RET,VAL
"RTN","HLUCM001",120,0)
 ;
"RTN","HLUCM001",121,0)
 I PAR=1!(PAR=2) QUIT PAR ;->
"RTN","HLUCM001",122,0)
 ;
"RTN","HLUCM001",123,0)
 ; Passed as 0^IEN or 0^PROTOCOL NAME...
"RTN","HLUCM001",124,0)
 S VAL=$P(PAR,U,2)
"RTN","HLUCM001",125,0)
 ;
"RTN","HLUCM001",126,0)
 ; Was IEN passed?
"RTN","HLUCM001",127,0)
 I VAL=+VAL D  QUIT RET ;->
"RTN","HLUCM001",128,0)
 .  S RET=""
"RTN","HLUCM001",129,0)
 .  I $D(^ORD(101,+VAL,0)) S RET=PAR
"RTN","HLUCM001",130,0)
 .  I '$D(^ORD(101,+VAL,0)) QUIT  ;-> Leaving RET=""
"RTN","HLUCM001",131,0)
 ;
"RTN","HLUCM001",132,0)
 ; Name was passed... (Can be up to 63 characters long...)
"RTN","HLUCM001",133,0)
 ; Find IEN for name...
"RTN","HLUCM001",134,0)
 S VAL=$$FIND101(PAR)
"RTN","HLUCM001",135,0)
 ;
"RTN","HLUCM001",136,0)
 ; If VAL=IEN, reset IEN101 to 0^IEN format...
"RTN","HLUCM001",137,0)
 I VAL>0 QUIT "0^"_+VAL  ;->
"RTN","HLUCM001",138,0)
 ;
"RTN","HLUCM001",139,0)
 QUIT ""
"RTN","HLUCM001",140,0)
 ;
"RTN","HLUCM001",141,0)
FIND101(VAL) ; No checking for upp/lowercase.  Must be passed right!
"RTN","HLUCM001",142,0)
 ; VAL = Protocol name...
"RTN","HLUCM001",143,0)
 N FIEN,IEN,LNM,PNM
"RTN","HLUCM001",144,0)
 ;
"RTN","HLUCM001",145,0)
 S VAL=$P(VAL,"0^",2)
"RTN","HLUCM001",146,0)
 ;
"RTN","HLUCM001",147,0)
 ; Passed as IEN?
"RTN","HLUCM001",148,0)
 I VAL=+VAL,$D(^ORD(101,+VAL,0)) QUIT +VAL ;->
"RTN","HLUCM001",149,0)
 ;
"RTN","HLUCM001",150,0)
 ; Passed as NAME?
"RTN","HLUCM001",151,0)
 S FIEN=0
"RTN","HLUCM001",152,0)
 S LNM=$E(VAL,1,$S($L(VAL)>30:29,1:$L(VAL)-1))
"RTN","HLUCM001",153,0)
 F  S LNM=$O(^ORD(101,"B",LNM)) Q:LNM]VAL!(LNM']"")!(FIEN)  D
"RTN","HLUCM001",154,0)
 .  S IEN=0
"RTN","HLUCM001",155,0)
 .  F  S IEN=$O(^ORD(101,"B",LNM,IEN)) Q:IEN'>0!(FIEN)  D
"RTN","HLUCM001",156,0)
 .  .  QUIT:$P($G(^ORD(101,+IEN,0)),U)'=VAL  ;->
"RTN","HLUCM001",157,0)
 .  .  S FIEN=+IEN
"RTN","HLUCM001",158,0)
 QUIT $S(FIEN:FIEN,1:"")
"RTN","HLUCM001",159,0)
 ;
"RTN","HLUCM001",160,0)
PCKG(IEN101) ; Return package namespace, or ZZZ if supposed to lump totals...
"RTN","HLUCM001",161,0)
 ; NMSPTYPE,PNMSP -- req
"RTN","HLUCM001",162,0)
 ;
"RTN","HLUCM001",163,0)
 N IEN94,NMSP
"RTN","HLUCM001",164,0)
 ;
"RTN","HLUCM001",165,0)
 ; Get actual namespace.  Determine below what to return...
"RTN","HLUCM001",166,0)
 S IEN94=$P($G(^ORD(101,+IEN101,0)),U,12)
"RTN","HLUCM001",167,0)
 S NMSP=$P($G(^DIC(9.4,+IEN94,0)),U,2)
"RTN","HLUCM001",168,0)
 ;
"RTN","HLUCM001",169,0)
 ; Include ALL, subdivide by individual namespaces...
"RTN","HLUCM001",170,0)
 I $G(PNMSP)=1 QUIT $S(NMSP]"":NMSP,1:"ZZZ") ;-> Want ALL, so default to ZZZ if null...
"RTN","HLUCM001",171,0)
 ;
"RTN","HLUCM001",172,0)
 ; Include ALL, but lump every namespace into ZZZ...
"RTN","HLUCM001",173,0)
 I $G(PNMSP)=2 QUIT "ZZZ" ;->
"RTN","HLUCM001",174,0)
 ;
"RTN","HLUCM001",175,0)
 ; Must be a specific namespace...
"RTN","HLUCM001",176,0)
 I $G(PNMSP)?1"0^".E D  QUIT PROT(1) ;->
"RTN","HLUCM001",177,0)
 .  S PROT(1)="" ; Set up default in case of failure...
"RTN","HLUCM001",178,0)
 .  I $P(PNMSP,U,2)=NMSP S PROT(1)=NMSP
"RTN","HLUCM001",179,0)
 ;
"RTN","HLUCM001",180,0)
 ; Passed namespaces by array, so anything here is OK.  Checks later...
"RTN","HLUCM001",181,0)
 I NMSPTYPE=1 QUIT NMSP ;->
"RTN","HLUCM001",182,0)
 ;
"RTN","HLUCM001",183,0)
 QUIT ""
"RTN","HLUCM001",184,0)
 ;
"RTN","HLUCM001",185,0)
TYPELR(IEN772) ; Is this Local or Remote or Unknown?
"RTN","HLUCM001",186,0)
 N D772,I773,IEN,IEN870,IO,MIEN,NM,TXT,TYPE,X
"RTN","HLUCM001",187,0)
 S D772=$G(^HL(772,+IEN772,0))
"RTN","HLUCM001",188,0)
 ;
"RTN","HLUCM001",189,0)
 ; Mailman check...
"RTN","HLUCM001",190,0)
 S MIEN=$P(D772,U,5) ; get Mailman IEN...
"RTN","HLUCM001",191,0)
 I MIEN S X=$$MAILTYPE(MIEN) QUIT:X="R" "R" ;-> Mailman, and remote...
"RTN","HLUCM001",192,0)
 ;
"RTN","HLUCM001",193,0)
 ; MSH segment in 773 check...
"RTN","HLUCM001",194,0)
 S TYPE="L",I773=0
"RTN","HLUCM001",195,0)
 F  S I773=$O(^HLMA("B",IEN772,I773)) Q:'I773!(TYPE'="L")  D
"RTN","HLUCM001",196,0)
 .  N DIV,P4,P6
"RTN","HLUCM001",197,0)
 .  S TXT="",MIEN=0
"RTN","HLUCM001",198,0)
 .  F  S MIEN=$O(^HLMA(+I773,"MSH",MIEN)) Q:MIEN'>0  D
"RTN","HLUCM001",199,0)
 .  .  S TXT=TXT_$G(^HLMA(+I773,"MSH",+MIEN,0))
"RTN","HLUCM001",200,0)
 .  QUIT:TXT']""  ;->
"RTN","HLUCM001",201,0)
 .  S X=$$SITESMSH(TXT),P4=$P(X,U),P6=$P(X,U,2)
"RTN","HLUCM001",202,0)
 .  S:P4'=P6 TYPE="R"
"RTN","HLUCM001",203,0)
 ;
"RTN","HLUCM001",204,0)
 ; Was anything found?
"RTN","HLUCM001",205,0)
 QUIT:TYPE'="L" TYPE ;->
"RTN","HLUCM001",206,0)
 ;
"RTN","HLUCM001",207,0)
 ; Logical links check...
"RTN","HLUCM001",208,0)
 S IEN870=$$IEN870(+IEN772) I IEN870 D
"RTN","HLUCM001",209,0)
 .  N DATA,MGIEN
"RTN","HLUCM001",210,0)
 .  S DATA=$G(^HLCS(870,+IEN870,0))
"RTN","HLUCM001",211,0)
 .  QUIT:$P(DATA,U,3)'=1  ;-> Not MAIL...
"RTN","HLUCM001",212,0)
 .  S MGIEN=$P($G(^HLCS(870,+IEN870,100)),U) QUIT:MGIEN'>0  ;->
"RTN","HLUCM001",213,0)
 .  QUIT:$O(^XMB(3.8,+MGIEN,6,0))'>0  ;-> No remote groups
"RTN","HLUCM001",214,0)
 .  S TYPE="R"
"RTN","HLUCM001",215,0)
 .  ; Rare to hit this point.  Much rarer, when this point is
"RTN","HLUCM001",216,0)
 .  ; reached, for the TYPE note to be set to "R"
"RTN","HLUCM001",217,0)
 ;
"RTN","HLUCM001",218,0)
 QUIT TYPE
"RTN","HLUCM001",219,0)
 ;
"RTN","HLUCM001",220,0)
SITESMSH(TXT) ; Return location pieces, slightly modified...
"RTN","HLUCM001",221,0)
 N DIV,P4,P6
"RTN","HLUCM001",222,0)
 S DIV=$E(TXT,4),P4=$P(TXT,DIV,4),P6=$P(TXT,DIV,6)
"RTN","HLUCM001",223,0)
 S P4=$S(P4?1.N1"~"!(P4?1.N):+P4,1:"")
"RTN","HLUCM001",224,0)
 S P6=$S(P6?1.N1"~"!(P6?1.N):+P6,1:"")
"RTN","HLUCM001",225,0)
 QUIT P4_U_P6
"RTN","HLUCM001",226,0)
 ;
"RTN","HLUCM001",227,0)
MAILTYPE(MIEN) ; Is MSH in Mailman message local or remote...
"RTN","HLUCM001",228,0)
 N IEN,TYPE
"RTN","HLUCM001",229,0)
 S TYPE="L"
"RTN","HLUCM001",230,0)
 I $P($G(^XMB(3.9,+MIEN,0)),U,2)["@" QUIT "R" ;->
"RTN","HLUCM001",231,0)
 S IEN=0
"RTN","HLUCM001",232,0)
 F  S IEN=$O(^XMB(3.9,+MIEN,1,IEN)) Q:'IEN  D  QUIT:TYPE'="L"
"RTN","HLUCM001",233,0)
 .  QUIT:$P($G(^XMB(3.9,+MIEN,1,+IEN,0)),U)'["@"  ;->
"RTN","HLUCM001",234,0)
 .  S TYPE="R"
"RTN","HLUCM001",235,0)
 QUIT TYPE
"RTN","HLUCM001",236,0)
 ;
"RTN","HLUCM001",237,0)
IEN870(IEN772) ; Given 772 find 870...
"RTN","HLUCM001",238,0)
 N DATA,I773,I870,IEN
"RTN","HLUCM001",239,0)
 S DATA=$G(^HL(772,+IEN772,0))
"RTN","HLUCM001",240,0)
 ;
"RTN","HLUCM001",241,0)
 ; Logical Link field...
"RTN","HLUCM001",242,0)
 S IEN=$P(DATA,U,11) I IEN QUIT IEN ;->
"RTN","HLUCM001",243,0)
 ;
"RTN","HLUCM001",244,0)
 ; Related Event Protocol...
"RTN","HLUCM001",245,0)
 S IEN=$P(DATA,U,10),IEN=$P($G(^ORD(101,+IEN,770)),U,7) I IEN QUIT IEN ;->
"RTN","HLUCM001",246,0)
 ;
"RTN","HLUCM001",247,0)
 S I773=0
"RTN","HLUCM001",248,0)
 F  S I773=$O(^HLMA("B",IEN772,I773)) Q:I773'>0  D  QUIT:I870
"RTN","HLUCM001",249,0)
 .  S I870=$P($G(^HLMA(+I773,0)),U,7)
"RTN","HLUCM001",250,0)
 I $G(I870) QUIT +I870 ;->
"RTN","HLUCM001",251,0)
 ;
"RTN","HLUCM001",252,0)
 QUIT ""
"RTN","HLUCM001",253,0)
 ;
"RTN","HLUCM001",254,0)
TYPEMSH(TXT) ; From MSH segment, is it local or remote?
"RTN","HLUCM001",255,0)
 N VAL
"RTN","HLUCM001",256,0)
 S VAL=$$SITESMSH(TXT)
"RTN","HLUCM001",257,0)
 QUIT $S(+VAL=$P(VAL,U,2):"R",1:"L")
"RTN","HLUCM001",258,0)
 ;
"RTN","HLUCM001",259,0)
EOR ; HLUCM001 - HL7/Capacity Mgt API (continued) ;2/27/01 10:15
"RTN","HLUCM002")
0^3^B24374559
"RTN","HLUCM002",1,0)
HLUCM002 ;CIOFO-O/LJA - HL7/Capacity Mgt API ;2/27/01 10:15
"RTN","HLUCM002",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**79**;Oct 13, 1995
"RTN","HLUCM002",3,0)
 ;
"RTN","HLUCM002",4,0)
OKPAR(PAR) ; Is namespace or protocol OK?
"RTN","HLUCM002",5,0)
 S PAR=$G(PAR)
"RTN","HLUCM002",6,0)
 I PAR=1!(PAR=2) QUIT 1 ;->
"RTN","HLUCM002",7,0)
 I $$OK0CALL(PAR) QUIT 1 ;->
"RTN","HLUCM002",8,0)
 QUIT ""
"RTN","HLUCM002",9,0)
 ;
"RTN","HLUCM002",10,0)
OK0CALL(PAR) ; Correct 0^IEN or 0^NAME call format?
"RTN","HLUCM002",11,0)
 I $E(PAR,1,2)="0^"&($E(PAR,3)]"") QUIT 1 ;->
"RTN","HLUCM002",12,0)
 QUIT ""
"RTN","HLUCM002",13,0)
 ;
"RTN","HLUCM002",14,0)
TYPETMO(IEN772) ; Is this TCP, Mail (via TCP), or Other?
"RTN","HLUCM002",15,0)
 N D772,I773,MIEN
"RTN","HLUCM002",16,0)
 ;
"RTN","HLUCM002",17,0)
 ; RELATED MAILMAN MESSAGE field (0;5) in 772...
"RTN","HLUCM002",18,0)
 S D772=$G(^HL(772,+IEN772,0)) ; Get node
"RTN","HLUCM002",19,0)
 S MIEN=$P(D772,U,5) ; get Mailman IEN from field...
"RTN","HLUCM002",20,0)
 I MIEN QUIT "M" ;-> Mailman via TCP
"RTN","HLUCM002",21,0)
 ;
"RTN","HLUCM002",22,0)
 ; There are rare instances when RELATED MAILMAN MESSAGE field is
"RTN","HLUCM002",23,0)
 ; not filled in, but the LLP TYPE in 870 is Mailman.  So, the next
"RTN","HLUCM002",24,0)
 ; check is needed...
"RTN","HLUCM002",25,0)
 ;
"RTN","HLUCM002",26,0)
 ; Get related 870 and check it's LLP TYPE...
"RTN","HLUCM002",27,0)
 I $P($G(^HLCS(870,+$$IEN870^HLUCM001(+IEN772),0)),U,3)=1 QUIT "M" ;->
"RTN","HLUCM002",28,0)
 ;
"RTN","HLUCM002",29,0)
 ; OK.  Let's give up on proving this 772 entry a Mailman entry.
"RTN","HLUCM002",30,0)
 ; But, is it TCP?
"RTN","HLUCM002",31,0)
 ;
"RTN","HLUCM002",32,0)
 ; Check if TCP by 773 link...
"RTN","HLUCM002",33,0)
 S I773=$O(^HLMA("B",+IEN772,0))
"RTN","HLUCM002",34,0)
 I I773>0 QUIT "T" ;->
"RTN","HLUCM002",35,0)
 ;
"RTN","HLUCM002",36,0)
 QUIT "U" ; Other...
"RTN","HLUCM002",37,0)
 ;
"RTN","HLUCM002",38,0)
TYPEIO(IEN772) ; Is this Input or Output or Unknown?
"RTN","HLUCM002",39,0)
 N D772,HLIO
"RTN","HLUCM002",40,0)
 S D772=$G(^HL(772,+IEN772,0))
"RTN","HLUCM002",41,0)
 S HLIO=$E($P(D772,U,4)_" ")
"RTN","HLUCM002",42,0)
 QUIT $S("IO"[HLIO:HLIO,1:"U")
"RTN","HLUCM002",43,0)
 ;
"RTN","HLUCM002",44,0)
PROTNMSP(IEN772) ; Return PROT~NMSP value to store in ^TMP.  
"RTN","HLUCM002",45,0)
 ; COND,IEN101,PNMSP -- req
"RTN","HLUCM002",46,0)
 N CT,FAIL,PCKG,CTPROT,PCKG,PROT
"RTN","HLUCM002",47,0)
 ;
"RTN","HLUCM002",48,0)
 ; Get actual protocol in IEN772...
"RTN","HLUCM002",49,0)
 S PROT=$$PROT101(+IEN772)
"RTN","HLUCM002",50,0)
 ;
"RTN","HLUCM002",51,0)
 ; Don't lose count if supposed to check everything...
"RTN","HLUCM002",52,0)
 I $G(IEN101)=1!($G(IEN101)=2) D
"RTN","HLUCM002",53,0)
 .  I PROT']"" S PROT="ZZZ" QUIT  ;->
"RTN","HLUCM002",54,0)
 .  I IEN101=2 S PROT="ZZZ"
"RTN","HLUCM002",55,0)
 ;
"RTN","HLUCM002",56,0)
 ; Is the protocol countable?  (Must also check namespace)
"RTN","HLUCM002",57,0)
 S CTPROT=$$CTPROT(PROT)
"RTN","HLUCM002",58,0)
 ;
"RTN","HLUCM002",59,0)
 ; Set package here and now...
"RTN","HLUCM002",60,0)
 S PCKG=+$P($G(^HL(772,+IEN772,0)),U,10) ; 101 IEN
"RTN","HLUCM002",61,0)
 S PCKG=$$PCKG^HLUCM001(+PCKG)
"RTN","HLUCM002",62,0)
 I $G(PNMSP)=1!($G(PNMSP)=2) D
"RTN","HLUCM002",63,0)
 .  I PCKG']"" S PCKG="ZZZ" QUIT  ;->
"RTN","HLUCM002",64,0)
 .  I PNMSP=2 S PCKG="ZZZ"
"RTN","HLUCM002",65,0)
 ;
"RTN","HLUCM002",66,0)
 S CTPCKG=$$CTPCKG(PCKG)
"RTN","HLUCM002",67,0)
 ;
"RTN","HLUCM002",68,0)
 ; Set up what should be returned...  
"RTN","HLUCM002",69,0)
 S PROT=$S(PROT=2:"ZZZ",1:PROT),PCKG=$S(PCKG=2:"ZZZ",1:PCKG)
"RTN","HLUCM002",70,0)
 ; If MIXED make sure the ALL side of things is set to something
"RTN","HLUCM002",71,0)
 ; so the ALL side doesn't squelch a SPECIFIC match...
"RTN","HLUCM002",72,0)
 I $$MIXED D
"RTN","HLUCM002",73,0)
 .  I $G(PNMSP)=1!($G(PNMSP)=2) D
"RTN","HLUCM002",74,0)
 .  .  QUIT:PROT]""  ;->
"RTN","HLUCM002",75,0)
 .  .  QUIT:'CTPROT  ;-> Not to be counted anyway...
"RTN","HLUCM002",76,0)
 .  .  S PROT="ZZZ~0"
"RTN","HLUCM002",77,0)
 .  I $G(IEN101)=1!($G(IEN101)=2) D
"RTN","HLUCM002",78,0)
 .  .  QUIT:PCKG]""  ;->
"RTN","HLUCM002",79,0)
 .  .  QUIT:'CTPCKG  ;-> Not to be counted anyway...
"RTN","HLUCM002",80,0)
 .  .  S PCKG="ZZZ"
"RTN","HLUCM002",81,0)
 I '$$MIXED,COND="EITHER" D
"RTN","HLUCM002",82,0)
 .  QUIT:$$ALL($G(PNMSP),$G(IEN101))  ;-> All 1s or 2s...
"RTN","HLUCM002",83,0)
 .  I NMSPTYPE'=1 D  ; Asked specifically...
"RTN","HLUCM002",84,0)
 .  .  QUIT:PROT]""  ;->
"RTN","HLUCM002",85,0)
 .  .  S PROT="ZZZ~0"
"RTN","HLUCM002",86,0)
 .  I PROTYPE'=1 D  ; Asked specifically...
"RTN","HLUCM002",87,0)
 .  .  QUIT:PCKG]""  ;->
"RTN","HLUCM002",88,0)
 .  .  S PCKG="ZZZ"
"RTN","HLUCM002",89,0)
 ;
"RTN","HLUCM002",90,0)
 ;
"RTN","HLUCM002",91,0)
 ;
"RTN","HLUCM002",92,0)
 ; If neither should be counted, don't...
"RTN","HLUCM002",93,0)
 I 'CTPROT&('CTPCKG) QUIT U ;->
"RTN","HLUCM002",94,0)
 ;
"RTN","HLUCM002",95,0)
 ; Either namespace or protocol matches, or both match...
"RTN","HLUCM002",96,0)
 ;
"RTN","HLUCM002",97,0)
 ; If BOTH namespace and protocol are required to match, don't count if one isn't a match...
"RTN","HLUCM002",98,0)
 I COND="BOTH" I 'CTPROT!('CTPCKG) QUIT U ;->
"RTN","HLUCM002",99,0)
 ;
"RTN","HLUCM002",100,0)
 ; If 1/2 & SPECIFIC (i.e., MIXED), then SPECIFIC trumps 1/2...
"RTN","HLUCM002",101,0)
 ; (If SPECIFIC not matched, it is not counted)
"RTN","HLUCM002",102,0)
 I $$MIXED D  QUIT:FAIL U ;->
"RTN","HLUCM002",103,0)
 .  S FAIL=1
"RTN","HLUCM002",104,0)
 .  ; If ALL NMSPs to be counted, but specific PROT fails... BAD!
"RTN","HLUCM002",105,0)
 .  I $G(PNMSP)=1!($G(PNMSP)=2) QUIT:'CTPROT  ;->
"RTN","HLUCM002",106,0)
 .  ; If ALL PROTs to be counted, but specific PCKG fails... BAD!
"RTN","HLUCM002",107,0)
 .  I $G(IEN101)=1!($G(IEN101)=2) QUIT:'CTPCKG  ;->
"RTN","HLUCM002",108,0)
 .  S FAIL=0
"RTN","HLUCM002",109,0)
 ;
"RTN","HLUCM002",110,0)
 QUIT PROT_U_PCKG
"RTN","HLUCM002",111,0)
 ;
"RTN","HLUCM002",112,0)
ALL(V1,V2) ; Are both 1 or 2?
"RTN","HLUCM002",113,0)
 S V1=$G(V1),V2=$G(V2)
"RTN","HLUCM002",114,0)
 QUIT:V1'=1&(V1'=2) "" ;->
"RTN","HLUCM002",115,0)
 QUIT:V2'=1&(V2'=2) "" ;->
"RTN","HLUCM002",116,0)
 QUIT 1
"RTN","HLUCM002",117,0)
 ;
"RTN","HLUCM002",118,0)
MIXED() ; Is one 1/2 and the other SPECIFIC?
"RTN","HLUCM002",119,0)
 N V3
"RTN","HLUCM002",120,0)
 S V1=$G(PNMSP),V1=$S(V1]"":$S(V1=1!(V1=2):1,1:0),1:0)
"RTN","HLUCM002",121,0)
 S V2=$G(IEN101),V2=$S(V2]"":$S(V2=1!(V2=2):1,1:0),1:0)
"RTN","HLUCM002",122,0)
 S V1=$S(V1=1!(V1=2):1,1:0)
"RTN","HLUCM002",123,0)
 S V2=$S(V2=1!(V2=2):1,1:0)
"RTN","HLUCM002",124,0)
 S V3=V1+V2
"RTN","HLUCM002",125,0)
 QUIT $S(V3=1:1,1:"")
"RTN","HLUCM002",126,0)
 ;
"RTN","HLUCM002",127,0)
CTPCKG(PCKG) ; Should entry be counted on basis of package?
"RTN","HLUCM002",128,0)
 ; (Might be countable if protocol matches remember.)
"RTN","HLUCM002",129,0)
 ; If list of packages passed by reference, is PCKG in array?
"RTN","HLUCM002",130,0)
 ; IEN101,NMSPTYPE,PNMSP -- req
"RTN","HLUCM002",131,0)
 N CTPCKG
"RTN","HLUCM002",132,0)
 ;
"RTN","HLUCM002",133,0)
 ; Must count everything...
"RTN","HLUCM002",134,0)
 I $G(PNMSP)=1!($G(PNMSP)=2) QUIT 1 ;->
"RTN","HLUCM002",135,0)
 ;
"RTN","HLUCM002",136,0)
 ; If passed namspace by array, is PCKG in array?
"RTN","HLUCM002",137,0)
 I NMSPTYPE=1 QUIT $S($$REFPCKG(PCKG):1,1:"") ;->
"RTN","HLUCM002",138,0)
 ;
"RTN","HLUCM002",139,0)
 ; If passed in "0^NAMESPACE" format...
"RTN","HLUCM002",140,0)
 I $$OK0CALL(PNMSP) D  QUIT $S(PCKG]"":1,1:"") ;->
"RTN","HLUCM002",141,0)
 .  I $P(PNMSP,U,2)'=PCKG S PCKG=""
"RTN","HLUCM002",142,0)
 ;
"RTN","HLUCM002",143,0)
 QUIT ""
"RTN","HLUCM002",144,0)
 ;
"RTN","HLUCM002",145,0)
CTPROT(PROT) ; Should entry be counted on basis of protocol?
"RTN","HLUCM002",146,0)
 ; (Might be countable if package matches remember.)
"RTN","HLUCM002",147,0)
 ; IEN,PROTYPE -- req
"RTN","HLUCM002",148,0)
 ;
"RTN","HLUCM002",149,0)
 N CTPROT
"RTN","HLUCM002",150,0)
 ;
"RTN","HLUCM002",151,0)
 ; Must count everything...
"RTN","HLUCM002",152,0)
 I $G(IEN101)=1!($G(IEN101)=2) QUIT 1 ;->
"RTN","HLUCM002",153,0)
 ;
"RTN","HLUCM002",154,0)
 ; If passed protocols by array, is PROT in array?
"RTN","HLUCM002",155,0)
 I PROTYPE=1 QUIT $S($$REFPROT(PROT):1,1:"") ;->
"RTN","HLUCM002",156,0)
 ;
"RTN","HLUCM002",157,0)
 ; If PROT not found, and passed 0^PROTNM or 0^PROTIEN, 
"RTN","HLUCM002",158,0)
 ; can't do anything more...
"RTN","HLUCM002",159,0)
 I $$OK0CALL(IEN101) D  QUIT $S(PROT]"":1,1:"") ;->
"RTN","HLUCM002",160,0)
 .  N VAL
"RTN","HLUCM002",161,0)
 .  QUIT:PROT']""  ;->
"RTN","HLUCM002",162,0)
 .  S VAL=$P(IEN101,U,2)
"RTN","HLUCM002",163,0)
 .  I $P(PROT,"~")'=VAL&($P(PROT,"~",2)'=VAL) S PROT=""
"RTN","HLUCM002",164,0)
 ;
"RTN","HLUCM002",165,0)
 QUIT ""
"RTN","HLUCM002",166,0)
 ;
"RTN","HLUCM002",167,0)
PP() QUIT $G(PROT)_U_$G(PCKG)
"RTN","HLUCM002",168,0)
 ;
"RTN","HLUCM002",169,0)
PROT101(IEN772) ; Return 101 information...
"RTN","HLUCM002",170,0)
 N IEN,NM
"RTN","HLUCM002",171,0)
 S IEN=$P($G(^HL(772,IEN772,0)),U,10) QUIT:'IEN "" ;->
"RTN","HLUCM002",172,0)
 S NM=$P($G(^ORD(101,+IEN,0)),U) QUIT:NM']"" "" ;->
"RTN","HLUCM002",173,0)
 QUIT NM_"~"_IEN
"RTN","HLUCM002",174,0)
 ;
"RTN","HLUCM002",175,0)
REFPROT(PROT) ; If passed by reference, is PROT in array? 0=Don't count, 2=Count
"RTN","HLUCM002",176,0)
 ; PROTYPE -- req
"RTN","HLUCM002",177,0)
 N X
"RTN","HLUCM002",178,0)
 I PROTYPE'=1 QUIT 1 ;-> Not passed by reference...
"RTN","HLUCM002",179,0)
 S X=$P(PROT,"~") I X]"" I $D(IEN101(X)) QUIT 1 ;-> found by name in array
"RTN","HLUCM002",180,0)
 S X=$P(PROT,"~",2) I X]"" I $D(IEN101(+X)) QUIT 1 ;-> found by IEN in array
"RTN","HLUCM002",181,0)
 QUIT ""
"RTN","HLUCM002",182,0)
 ;
"RTN","HLUCM002",183,0)
REFPCKG(PCKG) ; If passed by reference, is PCKG in array? 0=Don't count,1=OK to count
"RTN","HLUCM002",184,0)
 ; NMSPTYPE -- req
"RTN","HLUCM002",185,0)
 I NMSPTYPE'=1 QUIT 1 ;-> Not passed by reference...
"RTN","HLUCM002",186,0)
 I PCKG]"" I $D(PNMSP(PCKG)) QUIT 1 ;-> found in array
"RTN","HLUCM002",187,0)
 QUIT ""
"RTN","HLUCM002",188,0)
 ;
"RTN","HLUCM002",189,0)
EOR ; HLUCM002 - HL7/Capacity Mgt API ;2/27/01 10:15
"VER")
8.0^22.0
**END**
**END**
