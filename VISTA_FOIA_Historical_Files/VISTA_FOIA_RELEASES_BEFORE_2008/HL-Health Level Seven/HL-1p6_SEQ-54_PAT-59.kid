Released HL*1.6*59 SEQ #54
Extracted from mail message
**KIDS**:HL*1.6*59^

**INSTALL NAME**
HL*1.6*59
"BLD",284,0)
HL*1.6*59^HEALTH LEVEL SEVEN^0^3000523^y
"BLD",284,1,0)
^^125^125^3000523^
"BLD",284,1,1,0)
1. Introduces HL7 version 2.3.1 MESSAGE STRUCTURE components:
"BLD",284,1,2,0)
        -Introduces a new file (#779.005) to hold the new HL7 MESSAGE
"BLD",284,1,3,0)
         STRUCTURE CODES.
"BLD",284,1,4,0)
        -Adds a new field, MESSAGE STRUCTURE (#770.5), to the Protocol
"BLD",284,1,5,0)
         file. When defined, the MESSAGE STRUCTURE will be added to the
"BLD",284,1,6,0)
         version 2.3.1 message header.
"BLD",284,1,7,0)
 
"BLD",284,1,8,0)
2. The message type of outbound messages was incorrectly stored in file
"BLD",284,1,9,0)
   773. This has been fixed.
"BLD",284,1,10,0)
 
"BLD",284,1,11,0)
3. In file 771, HL APPLICATION PARAMETER, the input transforms for FIELD
"BLD",284,1,12,0)
   SEPARATOR and ENCODING CHARACTERS have been modified to prevent reuse
"BLD",284,1,13,0)
   of the field separator in the encoding characters. Each of the
"BLD",284,1,14,0)
   characters defined must be unique.
"BLD",284,1,15,0)
 
"BLD",284,1,16,0)
4. HL*1.6*57 introduced a new menu structure. However, the old, obsolete
"BLD",284,1,17,0)
   menus were not removed. This patch will remove them.
"BLD",284,1,18,0)
 
"BLD",284,1,19,0)
5. Fixes a problem with STUB records left behind in file 870 (Logical
"BLD",284,1,20,0)
   Link) resulting in freezing of links and the System Link Monitor as
"BLD",284,1,21,0)
   well as causing queues to grow until disk space is used up.
"BLD",284,1,22,0)
 
"BLD",284,1,23,0)
NOTE: Some sites may have a considerable number of messages needing to be
"BLD",284,1,24,0)
purged from file 870. Please consider disabling journalling of ^HLCS() for
"BLD",284,1,25,0)
about a week after installing this patch.
"BLD",284,1,26,0)
 
"BLD",284,1,27,0)
6.  Changes the PROCESSING ID field of file 101 to be no longer required.
"BLD",284,1,28,0)
Note that HL7 message headers are populated with information for
"BLD",284,1,29,0)
'TRAINING' or 'PRODUCTION' taken from the HL7 site parameters. Use the
"BLD",284,1,30,0)
option, SITE PARAMETER EDIT, to verify that your production account is
"BLD",284,1,31,0)
identified as such and your test/training account is identified as
"BLD",284,1,32,0)
'TRAINING.' The event driver protocol PROCESSING ID field is now used only
"BLD",284,1,33,0)
for DEBUG mode. Debug mode will override your site parameter setting. Make
"BLD",284,1,34,0)
sure the protocol is set to 'debug' on both the sending and receiving
"BLD",284,1,35,0)
system.
"BLD",284,1,36,0)
 
"BLD",284,1,37,0)
7. Corrects a problem with creating new subscriptions when a user edits
"BLD",284,1,38,0)
the zero node of file 774.
"BLD",284,1,39,0)
 
"BLD",284,1,40,0)
This patch resolves the following NOIS calls:
"BLD",284,1,41,0)
 
"BLD",284,1,42,0)
        AMA-0300-70683
"BLD",284,1,43,0)
        ISD-0300-71919
"BLD",284,1,44,0)
        HOU-0400-71933
"BLD",284,1,45,0)
 
"BLD",284,1,46,0)
The following routines are included in this patch.  The second line of
"BLD",284,1,47,0)
each of these routines now looks like:
"BLD",284,1,48,0)
  
"BLD",284,1,49,0)
   ;;1.6;HEALTH LEVEL SEVEN;<patchlist>;Oct 13, 1995
"BLD",284,1,50,0)
  
"BLD",284,1,51,0)
  CHECK^XTSUMBLD results: 
"BLD",284,1,52,0)
    
"BLD",284,1,53,0)
  Routine Name  Before Patch    After Patch     Patch List 
"BLD",284,1,54,0)
  ============  ============    ===========     ========== 
"BLD",284,1,55,0)
  HLCSHDR       7364841         7637619         **37,19,57,59**
"BLD",284,1,56,0)
  HLCSHDR1      7750238         8586633         **19,57,59**
"BLD",284,1,57,0)
  HLCSQUE       4338251         4440270         **14,61,59**
"BLD",284,1,58,0)
  HLCSQUE1      1150239         1371156         **14,59**
"BLD",284,1,59,0)
  HLFNC2        5397412         5365297         **2,26,57,59**
"BLD",284,1,60,0)
  HLTP4         7805100         7964901         **19,57,59**
"BLD",284,1,61,0)
  HLTPCK1A      14402537        14751742        **2,25,34,57,59**
"BLD",284,1,62,0)
  HLTPCK2A      15262342        15611547        **19,57,59**
"BLD",284,1,63,0)
  HLUTIL2       5387464         5486507         **19,43,57,59**
"BLD",284,1,64,0)
  HLTPCK1       4288888         4452787         **8,36,59**
"BLD",284,1,65,0)
  HLTPCK2       3804314         3962788         **19,59**
"BLD",284,1,66,0)
  HLTP3         14451393        14649677        **19,43,57,58,59**
"BLD",284,1,67,0)
  HLSUB         5501510         5552075         **14,57,58,59**
"BLD",284,1,68,0)
 
"BLD",284,1,69,0)
 List of preceding patches: 14, 36, 57, 58, 61
"BLD",284,1,70,0)
 Sites should use CHECK^XTSUMBLD to verify checksums.
"BLD",284,1,71,0)
  
"BLD",284,1,72,0)
 Installation Instructions: 
"BLD",284,1,73,0)
 ==========================
"BLD",284,1,74,0)
   1.  Users are allowed to be on the system during the installation.  
"BLD",284,1,75,0)
  
"BLD",284,1,76,0)
   2.  DSM SITES: Review your mapped set.  If any of the routines listed
"BLD",284,1,77,0)
       in the Routine Summary section are mapped, they should be removed
"BLD",284,1,78,0)
       from the mapped set at this time.
"BLD",284,1,79,0)
  
"BLD",284,1,80,0)
   3.  Shutdown all Logical Links and incoming and outgoing filers, and
"BLD",284,1,81,0)
       the Link Manager. Use the options:
"BLD",284,1,82,0)
  
"BLD",284,1,83,0)
         Filer and Link Management Options -> 
"BLD",284,1,84,0)
             SA     Stop All Messaging Background Processes
"BLD",284,1,85,0)
             LM     TCP/IP Link Manager Start/Stop
"BLD",284,1,86,0)
  
"BLD",284,1,87,0)
   4.  Use the 'INSTALL/CHECK MESSAGE' option on the PackMan menu. This 
"BLD",284,1,88,0)
       option will load the KIDS package onto your system.  
"BLD",284,1,89,0)
  
"BLD",284,1,90,0)
   5.  The patch has now been loaded into a Transport global on your 
"BLD",284,1,91,0)
       system. You now need to use KIDS to install the Transport global.  
"BLD",284,1,92,0)
       On the KIDS menu, under the 'Installation' menu, use the following 
"BLD",284,1,93,0)
       options: 
"BLD",284,1,94,0)
  
"BLD",284,1,95,0)
          2 Verify Checksums in Transport Global 
"BLD",284,1,96,0)
          3 Print Transport Global 
"BLD",284,1,97,0)
          4 Compare Transport Global to Current System 
"BLD",284,1,98,0)
          5 Backup a Transport Global 
"BLD",284,1,99,0)
          6 Install Package(s) 
"BLD",284,1,100,0)
              INSTALL NAME: HL*1.6*59
"BLD",284,1,101,0)
                            =========
"BLD",284,1,102,0)
  
"BLD",284,1,103,0)
         Answer 'NO' to 'Want KIDS to Rebuild Menu Trees upon Completion
"BLD",284,1,104,0)
         of Install?'.
"BLD",284,1,105,0)
  
"BLD",284,1,106,0)
         Answer 'NO' to 'Want KIDS to INHIBIT LOGONS during the install?'.
"BLD",284,1,107,0)
   
"BLD",284,1,108,0)
         Answer 'NO' to 'Want to DISABLE Scheduled Options, Menu Options, 
"BLD",284,1,109,0)
         and Protocols?'.  
"BLD",284,1,110,0)
  
"BLD",284,1,111,0)
   6.  Startup all Logical Links and incoming and outgoing filers. Use the
"BLD",284,1,112,0)
 
"BLD",284,1,113,0)
  
"BLD",284,1,114,0)
         Filer and Link Management Options ->
"BLD",284,1,115,0)
             RA     Restart/Start All Links and Filers
"BLD",284,1,116,0)
         (Note that links that do not have "autostart" enabled will need
"BLD",284,1,117,0)
          to be restarted manually)
"BLD",284,1,118,0)
    
"BLD",284,1,119,0)
       For DSM sites ONLY, if you previously disabled an HL7 UCX Service
"BLD",284,1,120,0)
       for this installation, you may now enable it.
"BLD",284,1,121,0)
  
"BLD",284,1,122,0)
   7.  DSM Sites: Rebuild your mapped set if necessary.
"BLD",284,1,123,0)
  
"BLD",284,1,124,0)
   8.  Start Link Manager using the option: "TCP/IP
"BLD",284,1,125,0)
         Link Manager Start/Stop."
"BLD",284,4,0)
^9.64PA^771^3
"BLD",284,4,101,0)
101
"BLD",284,4,101,2,0)
^9.641^101^1
"BLD",284,4,101,2,101,0)
PROTOCOL  (File-top level)
"BLD",284,4,101,2,101,1,0)
^9.6411^770.6^2
"BLD",284,4,101,2,101,1,770.5,0)
MESSAGE STRUCTURE
"BLD",284,4,101,2,101,1,770.6,0)
PROCESSING ID
"BLD",284,4,101,222)
y^y^p^^^^n
"BLD",284,4,771,0)
771
"BLD",284,4,771,2,0)
^9.641^771^1
"BLD",284,4,771,2,771,0)
HL7 APPLICATION PARAMETER  (File-top level)
"BLD",284,4,771,2,771,1,0)
^9.6411^101^2
"BLD",284,4,771,2,771,1,100,0)
HL7 FIELD SEPARATOR
"BLD",284,4,771,2,771,1,101,0)
HL7 ENCODING CHARACTERS
"BLD",284,4,771,222)
y^y^p^^^^n
"BLD",284,4,779.005,0)
779.005
"BLD",284,4,779.005,222)
y^y^f^^n^^y^o^n
"BLD",284,4,"APDD",101,101)

"BLD",284,4,"APDD",101,101,770.5)

"BLD",284,4,"APDD",101,101,770.6)

"BLD",284,4,"APDD",771,771)

"BLD",284,4,"APDD",771,771,100)

"BLD",284,4,"APDD",771,771,101)

"BLD",284,4,"B",101,101)

"BLD",284,4,"B",771,771)

"BLD",284,4,"B",779.005,779.005)

"BLD",284,"KRN",0)
^9.67PA^19^17
"BLD",284,"KRN",.4,0)
.4
"BLD",284,"KRN",.401,0)
.401
"BLD",284,"KRN",.402,0)
.402
"BLD",284,"KRN",.403,0)
.403
"BLD",284,"KRN",.403,"NM",0)
^9.68A^1^1
"BLD",284,"KRN",.403,"NM",1,0)
HL7 INTERFACE    FILE #101^101^0
"BLD",284,"KRN",.403,"NM","B","HL7 INTERFACE    FILE #101",1)

"BLD",284,"KRN",.5,0)
.5
"BLD",284,"KRN",.84,0)
.84
"BLD",284,"KRN",3.6,0)
3.6
"BLD",284,"KRN",3.8,0)
3.8
"BLD",284,"KRN",9.2,0)
9.2
"BLD",284,"KRN",9.8,0)
9.8
"BLD",284,"KRN",9.8,"NM",0)
^9.68A^14^13
"BLD",284,"KRN",9.8,"NM",1,0)
HLCSHDR^^0^B39476177
"BLD",284,"KRN",9.8,"NM",2,0)
HLCSHDR1^^0^B23649112
"BLD",284,"KRN",9.8,"NM",3,0)
HLFNC2^^0^B11462998
"BLD",284,"KRN",9.8,"NM",4,0)
HLTP4^^0^B21895753
"BLD",284,"KRN",9.8,"NM",5,0)
HLTPCK1A^^0^B55955952
"BLD",284,"KRN",9.8,"NM",6,0)
HLTPCK2A^^0^B55504021
"BLD",284,"KRN",9.8,"NM",7,0)
HLUTIL2^^0^B29017820
"BLD",284,"KRN",9.8,"NM",8,0)
HLTPCK1^^0^B7916664
"BLD",284,"KRN",9.8,"NM",9,0)
HLTPCK2^^0^B8648558
"BLD",284,"KRN",9.8,"NM",11,0)
HLTP3^^0^B55897763
"BLD",284,"KRN",9.8,"NM",12,0)
HLCSQUE^^0^B14643380
"BLD",284,"KRN",9.8,"NM",13,0)
HLCSQUE1^^0^B3409605
"BLD",284,"KRN",9.8,"NM",14,0)
HLSUB^^0^B18399859
"BLD",284,"KRN",9.8,"NM","B","HLCSHDR",1)

"BLD",284,"KRN",9.8,"NM","B","HLCSHDR1",2)

"BLD",284,"KRN",9.8,"NM","B","HLCSQUE",12)

"BLD",284,"KRN",9.8,"NM","B","HLCSQUE1",13)

"BLD",284,"KRN",9.8,"NM","B","HLFNC2",3)

"BLD",284,"KRN",9.8,"NM","B","HLSUB",14)

"BLD",284,"KRN",9.8,"NM","B","HLTP3",11)

"BLD",284,"KRN",9.8,"NM","B","HLTP4",4)

"BLD",284,"KRN",9.8,"NM","B","HLTPCK1",8)

"BLD",284,"KRN",9.8,"NM","B","HLTPCK1A",5)

"BLD",284,"KRN",9.8,"NM","B","HLTPCK2",9)

"BLD",284,"KRN",9.8,"NM","B","HLTPCK2A",6)

"BLD",284,"KRN",9.8,"NM","B","HLUTIL2",7)

"BLD",284,"KRN",19,0)
19
"BLD",284,"KRN",19,"NM",0)
^9.68A^18^18
"BLD",284,"KRN",19,"NM",1,0)
HL COMMUNICATIONS SERVER^^1^
"BLD",284,"KRN",19,"NM",2,0)
HL COPY QUEUE ENTRY^^1^
"BLD",284,"KRN",19,"NM",3,0)
HL CRE/ED QUEUE TEST ENTRY^^1^
"BLD",284,"KRN",19,"NM",4,0)
HL CUSTOM REPORT^^1^
"BLD",284,"KRN",19,"NM",5,0)
HL INTERFACE WORKBENCH^^1^
"BLD",284,"KRN",19,"NM",6,0)
HL MANAGE FILERS^^1^
"BLD",284,"KRN",19,"NM",7,0)
HL MENU 1.6^^1^
"BLD",284,"KRN",19,"NM",8,0)
HL MENU TK TESTING^^1^
"BLD",284,"KRN",19,"NM",9,0)
HL PRINT MENU^^1^
"BLD",284,"KRN",19,"NM",10,0)
HL QUEUE MANAGEMENT^^1^
"BLD",284,"KRN",19,"NM",11,0)
HL START ONE INCOMING FILER^^1^
"BLD",284,"KRN",19,"NM",12,0)
HL START ONE OUTGOING FILER^^1^
"BLD",284,"KRN",19,"NM",13,0)
HL STOP^^1^
"BLD",284,"KRN",19,"NM",14,0)
HL STOP ALL LINKS^^1^
"BLD",284,"KRN",19,"NM",15,0)
HL STOP ALL OUTGOING FILERS^^1^
"BLD",284,"KRN",19,"NM",16,0)
HL STOP LINK MANAGER^^1^
"BLD",284,"KRN",19,"NM",17,0)
HL STOP ONE INCOMING FILER^^1^
"BLD",284,"KRN",19,"NM",18,0)
HL STOP ONE OUTGOING FILER^^1^
"BLD",284,"KRN",19,"NM","B","HL COMMUNICATIONS SERVER",1)

"BLD",284,"KRN",19,"NM","B","HL COPY QUEUE ENTRY",2)

"BLD",284,"KRN",19,"NM","B","HL CRE/ED QUEUE TEST ENTRY",3)

"BLD",284,"KRN",19,"NM","B","HL CUSTOM REPORT",4)

"BLD",284,"KRN",19,"NM","B","HL INTERFACE WORKBENCH",5)

"BLD",284,"KRN",19,"NM","B","HL MANAGE FILERS",6)

"BLD",284,"KRN",19,"NM","B","HL MENU 1.6",7)

"BLD",284,"KRN",19,"NM","B","HL MENU TK TESTING",8)

"BLD",284,"KRN",19,"NM","B","HL PRINT MENU",9)

"BLD",284,"KRN",19,"NM","B","HL QUEUE MANAGEMENT",10)

"BLD",284,"KRN",19,"NM","B","HL START ONE INCOMING FILER",11)

"BLD",284,"KRN",19,"NM","B","HL START ONE OUTGOING FILER",12)

"BLD",284,"KRN",19,"NM","B","HL STOP",13)

"BLD",284,"KRN",19,"NM","B","HL STOP ALL LINKS",14)

"BLD",284,"KRN",19,"NM","B","HL STOP ALL OUTGOING FILERS",15)

"BLD",284,"KRN",19,"NM","B","HL STOP LINK MANAGER",16)

"BLD",284,"KRN",19,"NM","B","HL STOP ONE INCOMING FILER",17)

"BLD",284,"KRN",19,"NM","B","HL STOP ONE OUTGOING FILER",18)

"BLD",284,"KRN",19.1,0)
19.1
"BLD",284,"KRN",101,0)
101
"BLD",284,"KRN",409.61,0)
409.61
"BLD",284,"KRN",771,0)
771
"BLD",284,"KRN",870,0)
870
"BLD",284,"KRN",8994,0)
8994
"BLD",284,"KRN","B",.4,.4)

"BLD",284,"KRN","B",.401,.401)

"BLD",284,"KRN","B",.402,.402)

"BLD",284,"KRN","B",.403,.403)

"BLD",284,"KRN","B",.5,.5)

"BLD",284,"KRN","B",.84,.84)

"BLD",284,"KRN","B",3.6,3.6)

"BLD",284,"KRN","B",3.8,3.8)

"BLD",284,"KRN","B",9.2,9.2)

"BLD",284,"KRN","B",9.8,9.8)

"BLD",284,"KRN","B",19,19)

"BLD",284,"KRN","B",19.1,19.1)

"BLD",284,"KRN","B",101,101)

"BLD",284,"KRN","B",409.61,409.61)

"BLD",284,"KRN","B",771,771)

"BLD",284,"KRN","B",870,870)

"BLD",284,"KRN","B",8994,8994)

"BLD",284,"QUES",0)
^9.62^^
"BLD",284,"REQB",0)
^9.611^5^5
"BLD",284,"REQB",1,0)
HL*1.6*36^2
"BLD",284,"REQB",2,0)
HL*1.6*57^2
"BLD",284,"REQB",3,0)
HL*1.6*58^2
"BLD",284,"REQB",4,0)
HL*1.6*14^2
"BLD",284,"REQB",5,0)
HL*1.6*61^2
"BLD",284,"REQB","B","HL*1.6*14",4)

"BLD",284,"REQB","B","HL*1.6*36",1)

"BLD",284,"REQB","B","HL*1.6*57",2)

"BLD",284,"REQB","B","HL*1.6*58",3)

"BLD",284,"REQB","B","HL*1.6*61",5)

"DATA",779.005,1,0)
ADT_A01^A01,A04,A05,A08,A13,A14,A28,A31
"DATA",779.005,1,1,0)
^779.0053P^1^1
"DATA",779.005,1,1,1,0)
4
"DATA",779.005,2,0)
ADT_A02^A02,A21,A22,A23,A25,A26,A27,A29,A32,A33
"DATA",779.005,2,1,0)
^779.0053P^1^1
"DATA",779.005,2,1,1,0)
4
"DATA",779.005,3,0)
ADT_A03^A03
"DATA",779.005,3,1,0)
^779.0053P^1^1
"DATA",779.005,3,1,1,0)
4
"DATA",779.005,4,0)
ADT_A06^A06,A07
"DATA",779.005,4,1,0)
^779.0053P^1^1
"DATA",779.005,4,1,1,0)
4
"DATA",779.005,5,0)
ADT_A09^A09,A10,A11,A15
"DATA",779.005,5,1,0)
^779.0053P^1^1
"DATA",779.005,5,1,1,0)
4
"DATA",779.005,6,0)
ADT_A12^A12
"DATA",779.005,6,1,0)
^779.0053P^1^1
"DATA",779.005,6,1,1,0)
4
"DATA",779.005,7,0)
ADT_A16^A16
"DATA",779.005,7,1,0)
^779.0053P^1^1
"DATA",779.005,7,1,1,0)
4
"DATA",779.005,8,0)
ADT_A17^A17
"DATA",779.005,8,1,0)
^779.0053P^1^1
"DATA",779.005,8,1,1,0)
4
"DATA",779.005,9,0)
ADT_A18^A18
"DATA",779.005,9,1,0)
^779.0053P^1^1
"DATA",779.005,9,1,1,0)
4
"DATA",779.005,10,0)
ADT_A20^A20
"DATA",779.005,10,1,0)
^779.0053P^1^1
"DATA",779.005,10,1,1,0)
4
"DATA",779.005,11,0)
ADT_A24^A24
"DATA",779.005,11,1,0)
^779.0053P^1^1
"DATA",779.005,11,1,1,0)
4
"DATA",779.005,12,0)
ADT_A28^A28,A31
"DATA",779.005,12,1,0)
^779.0053P^1^1
"DATA",779.005,12,1,1,0)
4
"DATA",779.005,13,0)
ADT_A30^A30,A34,A35,A36,A46,A47,A48,A49
"DATA",779.005,13,1,0)
^779.0053P^1^1
"DATA",779.005,13,1,1,0)
4
"DATA",779.005,14,0)
ADT_A37^A37
"DATA",779.005,14,1,0)
^779.0053P^1^1
"DATA",779.005,14,1,1,0)
4
"DATA",779.005,15,0)
ADT_A38^A38
"DATA",779.005,15,1,0)
^779.0053P^1^1
"DATA",779.005,15,1,1,0)
4
"DATA",779.005,16,0)
ADT_A39^A39,A40,A41,A42
"DATA",779.005,16,1,0)
^779.0053P^1^1
"DATA",779.005,16,1,1,0)
4
"DATA",779.005,17,0)
ADT_A43^A43,A44
"DATA",779.005,17,1,0)
^779.0053P^1^1
"DATA",779.005,17,1,1,0)
4
"DATA",779.005,18,0)
ADT_A45^A45
"DATA",779.005,18,1,0)
^779.0053P^1^1
"DATA",779.005,18,1,1,0)
4
"DATA",779.005,19,0)
ADT_A50^A50,A51
"DATA",779.005,19,1,0)
^779.0053P^1^1
"DATA",779.005,19,1,1,0)
4
"DATA",779.005,20,0)
ARD_A19^A19
"DATA",779.005,20,1,0)
^779.0053P^1^1
"DATA",779.005,20,1,1,0)
4
"DATA",779.005,21,0)
BAR_P01^P01,P05
"DATA",779.005,21,1,0)
^779.0053P^1^1
"DATA",779.005,21,1,1,0)
4
"DATA",779.005,22,0)
BAR_P02^P02
"DATA",779.005,22,1,0)
^779.0053P^1^1
"DATA",779.005,22,1,1,0)
4
"DATA",779.005,23,0)
BAR_P06^P06
"DATA",779.005,23,1,0)
^779.0053P^1^1
"DATA",779.005,23,1,1,0)
4
"DATA",779.005,24,0)
CRM_C01^C01,C02,C03,C04,C05,C06,C07,C08
"DATA",779.005,24,1,0)
^779.0053P^1^1
"DATA",779.005,24,1,1,0)
4
"DATA",779.005,25,0)
CSU_C09^C09,C10,C11,C12
"DATA",779.005,25,1,0)
^779.0053P^1^1
"DATA",779.005,25,1,1,0)
4
"DATA",779.005,26,0)
DFT_P03^P03
"DATA",779.005,26,1,0)
^779.0053P^1^1
"DATA",779.005,26,1,1,0)
4
"DATA",779.005,27,0)
DOC_T12^T12
"DATA",779.005,27,1,0)
^779.0053P^1^1
"DATA",779.005,27,1,1,0)
4
"DATA",779.005,28,0)
DSR_Q01^Q01
"DATA",779.005,28,1,0)
^779.0053P^1^1
"DATA",779.005,28,1,1,0)
4
"DATA",779.005,29,0)
DSR_Q03^Q03
"DATA",779.005,29,1,0)
^779.0053P^1^1
"DATA",779.005,29,1,1,0)
4
"DATA",779.005,30,0)
EDR_R07^R07
"DATA",779.005,30,1,0)
^779.0053P^1^1
"DATA",779.005,30,1,1,0)
4
"DATA",779.005,31,0)
EQQ_Q04^Q04
"DATA",779.005,31,1,0)
^779.0053P^1^1
"DATA",779.005,31,1,1,0)
4
"DATA",779.005,32,0)
ERP_R09^R09
"DATA",779.005,32,1,0)
^779.0053P^1^1
"DATA",779.005,32,1,1,0)
4
"DATA",779.005,33,0)
MDM_T01^T01,T03,T05,T07,T09,T11
"DATA",779.005,33,1,0)
^779.0053P^1^1
"DATA",779.005,33,1,1,0)
4
"DATA",779.005,34,0)
MDM_T02^T02,T04,T06,T08,T10
"DATA",779.005,34,1,0)
^779.0053P^1^1
"DATA",779.005,34,1,1,0)
4
"DATA",779.005,35,0)
MFD_P09^P09
"DATA",779.005,35,1,0)
^779.0053P^1^1
"DATA",779.005,35,1,1,0)
4
"DATA",779.005,36,0)
MFK_M01^M01,M03,M05,M06,M07,M08,M09,M10,M11
"DATA",779.005,36,1,0)
^779.0053P^1^1
"DATA",779.005,36,1,1,0)
4
"DATA",779.005,37,0)
MFN_M01^M01
"DATA",779.005,37,1,0)
^779.0053P^1^1
"DATA",779.005,37,1,1,0)
4
"DATA",779.005,38,0)
MFN_M02^M02
"DATA",779.005,38,1,0)
^779.0053P^1^1
"DATA",779.005,38,1,1,0)
4
"DATA",779.005,39,0)
MFN_M03^M03
"DATA",779.005,39,1,0)
^779.0053P^1^1
"DATA",779.005,39,1,1,0)
4
"DATA",779.005,40,0)
MFN_M05^M05
"DATA",779.005,40,1,0)
^779.0053P^1^1
"DATA",779.005,40,1,1,0)
4
"DATA",779.005,41,0)
MFN_M06^M06
"DATA",779.005,41,1,0)
^779.0053P^1^1
"DATA",779.005,41,1,1,0)
4
"DATA",779.005,42,0)
MFN_M07^M07
"DATA",779.005,42,1,0)
^779.0053P^1^1
"DATA",779.005,42,1,1,0)
4
"DATA",779.005,43,0)
MFN_M08^M08
"DATA",779.005,43,1,0)
^779.0053P^1^1
"DATA",779.005,43,1,1,0)
4
"DATA",779.005,44,0)
MFN_M09^M09
"DATA",779.005,44,1,0)
^779.0053P^1^1
"DATA",779.005,44,1,1,0)
4
"DATA",779.005,45,0)
MFN_M10^M10
"DATA",779.005,45,1,0)
^779.0053P^1^1
"DATA",779.005,45,1,1,0)
4
"DATA",779.005,46,0)
MFN_M11^M11
"DATA",779.005,46,1,0)
^779.0053P^1^1
"DATA",779.005,46,1,1,0)
4
"DATA",779.005,47,0)
NUL^Null
"DATA",779.005,47,1,0)
^779.0053P^1^1
"DATA",779.005,47,1,1,0)
4
"DATA",779.005,48,0)
ORF_R02^R02,R04
"DATA",779.005,48,1,0)
^779.0053P^1^1
"DATA",779.005,48,1,1,0)
4
"DATA",779.005,49,0)
ORM_O01^O01
"DATA",779.005,49,1,0)
^779.0053P^1^1
"DATA",779.005,49,1,1,0)
4
"DATA",779.005,50,0)
ORM_Q06^Q06
"DATA",779.005,50,1,0)
^779.0053P^1^1
"DATA",779.005,50,1,1,0)
4
"DATA",779.005,51,0)
ORR_O02^O02
"DATA",779.005,51,1,0)
^779.0053P^1^1
"DATA",779.005,51,1,1,0)
4
"DATA",779.005,52,0)
ORR_Q06^Q06
"DATA",779.005,52,1,0)
^779.0053P^1^1
"DATA",779.005,52,1,1,0)
4
"DATA",779.005,53,0)
ORU_R01^R01
"DATA",779.005,53,1,0)
^779.0053P^1^1
"DATA",779.005,53,1,1,0)
4
"DATA",779.005,54,0)
ORU_W01^W01
"DATA",779.005,54,1,0)
^779.0053P^1^1
"DATA",779.005,54,1,1,0)
4
"DATA",779.005,55,0)
OSQ_Q06^Q06
"DATA",779.005,55,1,0)
^779.0053P^1^1
"DATA",779.005,55,1,1,0)
4
"DATA",779.005,56,0)
OSR_Q06^Q06
"DATA",779.005,56,1,0)
^779.0053P^1^1
"DATA",779.005,56,1,1,0)
4
"DATA",779.005,57,0)
PEX_P07^P07,P08
"DATA",779.005,57,1,0)
^779.0053P^1^1
"DATA",779.005,57,1,1,0)
4
"DATA",779.005,58,0)
PGL_PC6^PC6,PC7,PC8
"DATA",779.005,58,1,0)
^779.0053P^1^1
"DATA",779.005,58,1,1,0)
4
"DATA",779.005,59,0)
PIN_I07^I07
"DATA",779.005,59,1,0)
^779.0053P^1^1
"DATA",779.005,59,1,1,0)
4
"DATA",779.005,60,0)
PPG_PCG^PCC,PCH,PCJ
"DATA",779.005,60,1,0)
^779.0053P^1^1
"DATA",779.005,60,1,1,0)
4
"DATA",779.005,61,0)
PPP_PCB^PCB,PCD
"DATA",779.005,61,1,0)
^779.0053P^1^1
"DATA",779.005,61,1,1,0)
4
"DATA",779.005,62,0)
PPR_PC1^PC1,PC2,PC3
"DATA",779.005,62,1,0)
^779.0053P^1^1
"DATA",779.005,62,1,1,0)
4
"DATA",779.005,63,0)
PPT_PCL^PCL
"DATA",779.005,63,1,0)
^779.0053P^1^1
"DATA",779.005,63,1,1,0)
4
"DATA",779.005,64,0)
PPV_PCA^PCA
"DATA",779.005,64,1,0)
^779.0053P^1^1
"DATA",779.005,64,1,1,0)
4
"DATA",779.005,65,0)
PRR_PC5^PC5
"DATA",779.005,65,1,0)
^779.0053P^1^1
"DATA",779.005,65,1,1,0)
4
"DATA",779.005,66,0)
PTR_PCF^PCF
"DATA",779.005,66,1,0)
^779.0053P^1^1
"DATA",779.005,66,1,1,0)
4
"DATA",779.005,67,0)
QCK_Q02^Q02
"DATA",779.005,67,1,0)
^779.0053P^1^1
"DATA",779.005,67,1,1,0)
4
"DATA",779.005,68,0)
QRY_A19^A19
"DATA",779.005,68,1,0)
^779.0053P^1^1
"DATA",779.005,68,1,1,0)
4
"DATA",779.005,69,0)
QRY_PC4^PC4,PC9,PCE,PCK
"DATA",779.005,69,1,0)
^779.0053P^1^1
"DATA",779.005,69,1,1,0)
4
"DATA",779.005,70,0)
QRY_Q01^Q01
"DATA",779.005,70,1,0)
^779.0053P^1^1
"DATA",779.005,70,1,1,0)
4
"DATA",779.005,71,0)
QRY_Q02^Q02
"DATA",779.005,71,1,0)
^779.0053P^1^1
"DATA",779.005,71,1,1,0)
4
"DATA",779.005,72,0)
QRY_R02^R02,R04
"DATA",779.005,72,1,0)
^779.0053P^1^1
"DATA",779.005,72,1,1,0)
4
"DATA",779.005,73,0)
QRY_T12^T12
"DATA",779.005,73,1,0)
^779.0053P^1^1
"DATA",779.005,73,1,1,0)
4
"DATA",779.005,74,0)
RAR_RAR^RAR
"DATA",779.005,74,1,0)
^779.0053P^1^1
"DATA",779.005,74,1,1,0)
4
"DATA",779.005,75,0)
RAS_O01^O01
"DATA",779.005,75,1,0)
^779.0053P^1^1
"DATA",779.005,75,1,1,0)
4
"DATA",779.005,76,0)
RAS_O02^O02
"DATA",779.005,76,1,0)
^779.0053P^1^1
"DATA",779.005,76,1,1,0)
4
"DATA",779.005,77,0)
RCI_I05^I05
"DATA",779.005,77,1,0)
^779.0053P^1^1
"DATA",779.005,77,1,1,0)
4
"DATA",779.005,78,0)
RCL_I06^I06
"DATA",779.005,78,1,0)
^779.0053P^1^1
"DATA",779.005,78,1,1,0)
4
"DATA",779.005,79,0)
RDE_O01^O01
"DATA",779.005,79,1,0)
^779.0053P^1^1
"DATA",779.005,79,1,1,0)
4
"DATA",779.005,80,0)
RDR_RDR^RDR
"DATA",779.005,80,1,0)
^779.0053P^1^1
"DATA",779.005,80,1,1,0)
4
"DATA",779.005,81,0)
RDS_O01^O01
"DATA",779.005,81,1,0)
^779.0053P^1^1
"DATA",779.005,81,1,1,0)
4
"DATA",779.005,82,0)
REF_I12^I12,I13,I14,I15
"DATA",779.005,82,1,0)
^779.0053P^1^1
"DATA",779.005,82,1,1,0)
4
"DATA",779.005,83,0)
RER_RER^RER
"DATA",779.005,83,1,0)
^779.0053P^1^1
"DATA",779.005,83,1,1,0)
4
"DATA",779.005,84,0)
RGR_RGR^RGR
"DATA",779.005,84,1,0)
^779.0053P^1^1
"DATA",779.005,84,1,1,0)
4
"DATA",779.005,85,0)
RGV_O01^O01
"DATA",779.005,85,1,0)
^779.0053P^1^1
"DATA",779.005,85,1,1,0)
4
"DATA",779.005,86,0)
ROR_ROR^ROR
"DATA",779.005,86,1,0)
^779.0053P^1^1
"DATA",779.005,86,1,1,0)
4
"DATA",779.005,87,0)
RPA_I08^I08,I09,I10,I11
"DATA",779.005,87,1,0)
^779.0053P^1^1
"DATA",779.005,87,1,1,0)
4
"DATA",779.005,88,0)
RPI_I01^I01,I04
"DATA",779.005,88,1,0)
^779.0053P^1^1
"DATA",779.005,88,1,1,0)
4
"DATA",779.005,89,0)
RPL_I02^I02
"DATA",779.005,89,1,0)
^779.0053P^1^1
"DATA",779.005,89,1,1,0)
4
"DATA",779.005,90,0)
RPR_I03^I03
"DATA",779.005,90,1,0)
^779.0053P^1^1
"DATA",779.005,90,1,1,0)
4
"DATA",779.005,91,0)
RQA_I08^I08,I09,I10,I11
"DATA",779.005,91,1,0)
^779.0053P^1^1
"DATA",779.005,91,1,1,0)
4
"DATA",779.005,92,0)
RQC_I05^I05
"DATA",779.005,92,1,0)
^779.0053P^1^1
"DATA",779.005,92,1,1,0)
4
"DATA",779.005,93,0)
RQC_I06^I06
"DATA",779.005,93,1,0)
^779.0053P^1^1
"DATA",779.005,93,1,1,0)
4
"DATA",779.005,94,0)
RQI_I01^I01,I02,I03
"DATA",779.005,94,1,0)
^779.0053P^1^1
"DATA",779.005,94,1,1,0)
4
"DATA",779.005,95,0)
RQP_I04^I04
"DATA",779.005,95,1,0)
^779.0053P^1^1
"DATA",779.005,95,1,1,0)
4
"DATA",779.005,96,0)
RQQ_Q09^Q09
"DATA",779.005,96,1,0)
^779.0053P^1^1
"DATA",779.005,96,1,1,0)
4
"DATA",779.005,97,0)
RRA_O02^O02
"DATA",779.005,97,1,0)
^779.0053P^1^1
"DATA",779.005,97,1,1,0)
4
"DATA",779.005,98,0)
RRD_O02^O02
"DATA",779.005,98,1,0)
^779.0053P^1^1
"DATA",779.005,98,1,1,0)
4
"DATA",779.005,99,0)
RRE_O01^O01
"DATA",779.005,99,1,0)
^779.0053P^1^1
"DATA",779.005,99,1,1,0)
4
"DATA",779.005,100,0)
RRG_O02^O02
"DATA",779.005,100,1,0)
^779.0053P^1^1
"DATA",779.005,100,1,1,0)
4
"DATA",779.005,101,0)
SIU_S12^S12,S13,S14,S15,S16,S17,S18,S19,S20,S21,S22,S23,S24,S26
"DATA",779.005,101,1,0)
^779.0053P^1^1
"DATA",779.005,101,1,1,0)
4
"DATA",779.005,102,0)
SPQ_Q08^Q08
"DATA",779.005,102,1,0)
^779.0053P^1^1
"DATA",779.005,102,1,1,0)
4
"DATA",779.005,103,0)
SQM_S25^S25
"DATA",779.005,103,1,0)
^779.0053P^1^1
"DATA",779.005,103,1,1,0)
4
"DATA",779.005,104,0)
SQR_S25^S25
"DATA",779.005,104,1,0)
^779.0053P^1^1
"DATA",779.005,104,1,1,0)
4
"DATA",779.005,105,0)
SRM_S01^S01,S02,S03,S04,S05,S06,S07,S08,S09,S10,S11
"DATA",779.005,105,1,0)
^779.0053P^1^1
"DATA",779.005,105,1,1,0)
4
"DATA",779.005,106,0)
SRM_T12^T12
"DATA",779.005,106,1,0)
^779.0053P^1^1
"DATA",779.005,106,1,1,0)
4
"DATA",779.005,107,0)
SRR_S01^S01,S02,S03,S04,S05,S06,S07,S08,S09,S10,S11
"DATA",779.005,107,1,0)
^779.0053P^1^1
"DATA",779.005,107,1,1,0)
4
"DATA",779.005,108,0)
SRR_T12^T12
"DATA",779.005,108,1,0)
^779.0053P^1^1
"DATA",779.005,108,1,1,0)
4
"DATA",779.005,109,0)
SUR_P09^P09
"DATA",779.005,109,1,0)
^779.0053P^1^1
"DATA",779.005,109,1,1,0)
4
"DATA",779.005,110,0)
TBR_R09^R09
"DATA",779.005,110,1,0)
^779.0053P^1^1
"DATA",779.005,110,1,1,0)
4
"DATA",779.005,111,0)
UDM_Q05^Q05
"DATA",779.005,111,1,0)
^779.0053P^1^1
"DATA",779.005,111,1,1,0)
4
"DATA",779.005,112,0)
VQQ_Q07^Q07
"DATA",779.005,112,1,0)
^779.0053P^1^1
"DATA",779.005,112,1,1,0)
4
"DATA",779.005,113,0)
VXQ_V01^V01
"DATA",779.005,113,1,0)
^779.0053P^1^1
"DATA",779.005,113,1,1,0)
4
"DATA",779.005,114,0)
VXR_V03^V03
"DATA",779.005,114,1,0)
^779.0053P^1^1
"DATA",779.005,114,1,1,0)
4
"DATA",779.005,115,0)
VXU_V04^V04
"DATA",779.005,115,1,0)
^779.0053P^1^1
"DATA",779.005,115,1,1,0)
4
"DATA",779.005,116,0)
VXX_V02^V02
"DATA",779.005,116,1,0)
^779.0053P^1^1
"DATA",779.005,116,1,1,0)
4
"DATA",779.005,117,0)
RRI-I12^I12,I13,I14,I15
"DATA",779.005,117,1,0)
^779.0053P^1^1
"DATA",779.005,117,1,1,0)
4
"FIA",101)
PROTOCOL
"FIA",101,0)
^ORD(101,
"FIA",101,0,0)
101I
"FIA",101,0,1)
y^y^p^^^^n
"FIA",101,0,10)

"FIA",101,0,11)

"FIA",101,0,"RLRO")

"FIA",101,0,"VR")
1.6^HL
"FIA",101,101)
1
"FIA",101,101,770.5)

"FIA",101,101,770.6)

"FIA",771)
HL7 APPLICATION PARAMETER
"FIA",771,0)
^HL(771,
"FIA",771,0,0)
771I
"FIA",771,0,1)
y^y^p^^^^n
"FIA",771,0,10)

"FIA",771,0,11)

"FIA",771,0,"RLRO")

"FIA",771,0,"VR")
1.6^HL
"FIA",771,771)
1
"FIA",771,771,100)

"FIA",771,771,101)

"FIA",779.005)
HL7 MESSAGE STRUCTURE CODE
"FIA",779.005,0)
^HL(779.005,
"FIA",779.005,0,0)
779.005
"FIA",779.005,0,1)
y^y^f^^n^^y^o^n
"FIA",779.005,0,10)

"FIA",779.005,0,11)

"FIA",779.005,0,"RLRO")

"FIA",779.005,0,"VR")
1.6^HL
"FIA",779.005,779.005)
0
"FIA",779.005,779.0053)
0
"KRN",.403,31,-1)
0^1
"KRN",.403,31,0)
HL7 INTERFACE^@^@^^2990709.0839^^^101^0^0^1
"KRN",.403,31,11)

"KRN",.403,31,14)

"KRN",.403,31,40,0)
^.4031I^6^6
"KRN",.403,31,40,1,0)
1^^1,1
"KRN",.403,31,40,1,1)
Page 1
"KRN",.403,31,40,1,40,0)
^.4032IP^150^2
"KRN",.403,31,40,1,40,149,0)
HL7 INTERFACE HDR1^1^1,1^d
"KRN",.403,31,40,1,40,150,0)
HL7 INTERFACE BLK1^2^3,1^e
"KRN",.403,31,40,2,0)
2^^1,1^^1
"KRN",.403,31,40,2,1)
Page 2
"KRN",.403,31,40,2,40,0)
^.4032IP^153^2
"KRN",.403,31,40,2,40,151,0)
HL7 EVENT DRV^1^1,2^e
"KRN",.403,31,40,2,40,153,0)
HL7 EVENT DRV ITEM^2^12,2^e
"KRN",.403,31,40,2,40,153,2)
5^^^0
"KRN",.403,31,40,2,40,153,11)

"KRN",.403,31,40,3,0)
3^^1,1^^1
"KRN",.403,31,40,3,1)
Page 3
"KRN",.403,31,40,3,40,0)
^.4032IP^152^1
"KRN",.403,31,40,3,40,152,0)
HL7 SUBSCRIBER^1^1,2^e
"KRN",.403,31,40,4,0)
4^^2,4^^^1^17,77
"KRN",.403,31,40,4,1)
Page 4^
"KRN",.403,31,40,4,40,0)
^.4032IP^154^1
"KRN",.403,31,40,4,40,154,0)
HL SUBSCRIBER2^1^1,1^e
"KRN",.403,31,40,4,40,154,1)
775:.01
"KRN",.403,31,40,4,40,154,11)
D PUT^DDSVAL("^ORD(101,",.DA,4,"S","","I")
"KRN",.403,31,40,5,0)
5^^4,3^^^1^15,77
"KRN",.403,31,40,5,1)
Page 5
"KRN",.403,31,40,5,40,0)
^.4032IP^155^1
"KRN",.403,31,40,5,40,155,0)
HL7 APP BLK2^1^1,1^e
"KRN",.403,31,40,5,40,155,1)
770.1:
"KRN",.403,31,40,6,0)
6^^3,3^^^1^10,77
"KRN",.403,31,40,6,1)
Page 6
"KRN",.403,31,40,6,40,0)
^.4032IP^156^1
"KRN",.403,31,40,6,40,156,0)
HL7 APP BLK3^1^1,1^e
"KRN",.403,31,40,6,40,156,1)
770.2:
"KRN",.404,149,0)
HL7 INTERFACE HDR1^101^
"KRN",.404,149,40,0)
^.4044I^4^3
"KRN",.404,149,40,1,0)
1^HL7 INTERFACE SETUP^1
"KRN",.404,149,40,1,2)
^^1,24
"KRN",.404,149,40,3,0)
3^--------------------------------------------------------------------------------^1
"KRN",.404,149,40,3,2)
^^2,1
"KRN",.404,149,40,4,0)
2^PAGE 1 OF 2^1
"KRN",.404,149,40,4,2)
^^1,68
"KRN",.404,150,0)
HL7 INTERFACE BLK1^101
"KRN",.404,150,40,0)
^.4044I^7^6
"KRN",.404,150,40,1,0)
1^NAME^3
"KRN",.404,150,40,1,1)
.01
"KRN",.404,150,40,1,2)
2,19^55^2,13
"KRN",.404,150,40,2,0)
2^DESCRIPTION (wp)^3
"KRN",.404,150,40,2,1)
3.5
"KRN",.404,150,40,2,2)
4,19^1^4,1
"KRN",.404,150,40,3,0)
4^ENTRY ACTION^3
"KRN",.404,150,40,3,1)
20
"KRN",.404,150,40,3,2)
7,15^64^7,1
"KRN",.404,150,40,4,0)
5^EXIT ACTION^3
"KRN",.404,150,40,4,1)
15
"KRN",.404,150,40,4,2)
9,15^64^9,2
"KRN",.404,150,40,6,0)
6^TYPE^2^^TYPE
"KRN",.404,150,40,6,2)
12,15^15^12,9
"KRN",.404,150,40,6,3)
!M
"KRN",.404,150,40,6,3.1)
S Y=$$GET^DDSVAL("^ORD(101,",.DA,4)
"KRN",.404,150,40,6,4)
1
"KRN",.404,150,40,6,10)
S DDSBR="^^"_$S(X="E":"PAGE 2",1:"PAGE 3")
"KRN",.404,150,40,6,20)
S^M^E:event driver;S:subscriber
"KRN",.404,150,40,6,23)
D PUT^DDSVAL("^ORD(101,",.DA,4,X,"","I")
"KRN",.404,150,40,7,0)
3^!M^1
"KRN",.404,150,40,7,.1)
N WP S WP=$$GET^DDSVAL(DIE,.DA,3.5),Y=$S(WP]"":$G(@WP@(1,0)),1:""),Y=$S(Y]"":"["_$E(Y,1,47)_"]",1:"(empty)")
"KRN",.404,150,40,7,2)
^^4,21
"KRN",.404,151,0)
HL7 EVENT DRV^101
"KRN",.404,151,40,0)
^.4044I^15^14
"KRN",.404,151,40,1,0)
5^SENDING APPLICATION^3
"KRN",.404,151,40,1,1)
770.1
"KRN",.404,151,40,1,2)
4,27^15^4,6
"KRN",.404,151,40,1,4)
1
"KRN",.404,151,40,1,10)
S DDSSTACK="PAGE 5"
"KRN",.404,151,40,2,0)
6^TRANSACTION MESSAGE TYPE^3
"KRN",.404,151,40,2,1)
770.3
"KRN",.404,151,40,2,2)
5,27^3^5,1
"KRN",.404,151,40,2,4)
1
"KRN",.404,151,40,3,0)
7^EVENT TYPE^3
"KRN",.404,151,40,3,1)
770.4
"KRN",.404,151,40,3,2)
5,66^3^5,54
"KRN",.404,151,40,4,0)
9^PROCESSING ID^3
"KRN",.404,151,40,4,1)
770.6
"KRN",.404,151,40,4,2)
7,27^10^7,12
"KRN",.404,151,40,4,3)

"KRN",.404,151,40,4,4)
0
"KRN",.404,151,40,5,0)
11^ACCEPT ACK CODE^3
"KRN",.404,151,40,5,1)
770.8
"KRN",.404,151,40,5,2)
8,27^2^8,10
"KRN",.404,151,40,6,0)
12^APPLICATION ACK TYPE^3
"KRN",.404,151,40,6,1)
770.9
"KRN",.404,151,40,6,2)
8,66^2^8,44
"KRN",.404,151,40,7,0)
10^VERSION ID^3
"KRN",.404,151,40,7,1)
770.95
"KRN",.404,151,40,7,2)
7,66^8^7,54
"KRN",.404,151,40,7,4)
1
"KRN",.404,151,40,7,11)
D UNED^DDSUTL("ACCEPT ACK CODE","","",(DDSEXT<2.2),""),UNED^DDSUTL("APPLICATION ACK TYPE","","",(DDSEXT<2.2))
"KRN",.404,151,40,7,13)
D UNED^DDSUTL("ACCEPT ACK CODE","","",(DDSEXT<2.2),""),UNED^DDSUTL("APPLICATION ACK TYPE","","",(DDSEXT<2.2),"")
"KRN",.404,151,40,8,0)
13^RESPONSE PROCESSING RTN^3
"KRN",.404,151,40,8,1)
772
"KRN",.404,151,40,8,2)
10,26^53^10,1
"KRN",.404,151,40,10,0)
1^HL7 EVENT DRIVER^1
"KRN",.404,151,40,10,2)
^^1,26
"KRN",.404,151,40,11,0)
14^SUBSCRIBERS^1
"KRN",.404,151,40,11,2)
^^11,27
"KRN",.404,151,40,12,0)
2^PAGE 2 OF 2^1
"KRN",.404,151,40,12,2)
^^1,67
"KRN",.404,151,40,13,0)
4^--------------------------------------------------------------------------------^1
"KRN",.404,151,40,13,2)
^^3,0
"KRN",.404,151,40,14,0)
3^^3
"KRN",.404,151,40,14,1)
.01
"KRN",.404,151,40,14,2)
2,25^30
"KRN",.404,151,40,14,4)
0^^^1
"KRN",.404,151,40,15,0)
8^MESSAGE STRUCTURE^3
"KRN",.404,151,40,15,1)
770.5
"KRN",.404,151,40,15,2)
6,27^10^6,8
"KRN",.404,152,0)
HL7 SUBSCRIBER^101
"KRN",.404,152,40,0)
^.4044I^14^13
"KRN",.404,152,40,1,0)
6^RESPONSE MESSAGE TYPE^3
"KRN",.404,152,40,1,1)
770.11
"KRN",.404,152,40,1,2)
7,29^3^7,6
"KRN",.404,152,40,1,4)
1
"KRN",.404,152,40,2,0)
5^RECEIVING APPLICATION^3
"KRN",.404,152,40,2,1)
770.2
"KRN",.404,152,40,2,2)
5,29^15^5,6
"KRN",.404,152,40,2,4)
1
"KRN",.404,152,40,2,10)
S DDSSTACK="PAGE 6"
"KRN",.404,152,40,3,0)
7^EVENT TYPE^3
"KRN",.404,152,40,3,1)
770.4
"KRN",.404,152,40,3,2)
7,72^3^7,60
"KRN",.404,152,40,4,0)
12^LOGICAL LINK^3
"KRN",.404,152,40,4,1)
770.7
"KRN",.404,152,40,4,2)
13,29^10^13,15
"KRN",.404,152,40,5,0)
13^PROCESSING RTN^3
"KRN",.404,152,40,5,1)
771
"KRN",.404,152,40,5,2)
15,17^61^15,1
"KRN",.404,152,40,6,0)
1^HL7 SUBSCRIBER^1
"KRN",.404,152,40,6,2)
^^1,28
"KRN",.404,152,40,7,0)
2^PAGE 2 OF 2^1
"KRN",.404,152,40,7,2)
^^1,67
"KRN",.404,152,40,8,0)
4^--------------------------------------------------------------------------------^1
"KRN",.404,152,40,8,2)
^^3,0
"KRN",.404,152,40,9,0)
3^^3
"KRN",.404,152,40,9,1)
.01
"KRN",.404,152,40,9,2)
2,27^30
"KRN",.404,152,40,9,4)
0^^^1
"KRN",.404,152,40,10,0)
14^ROUTING LOGIC^3
"KRN",.404,152,40,10,1)
774
"KRN",.404,152,40,10,2)
17,17^61^17,2
"KRN",.404,152,40,11,0)
8^SENDING FACILITY REQUIRED?^3
"KRN",.404,152,40,11,1)
773.1
"KRN",.404,152,40,11,2)
9,29^3^9,1
"KRN",.404,152,40,12,0)
9^RECEIVING FACILITY REQUIRED?^3
"KRN",.404,152,40,12,1)
773.2
"KRN",.404,152,40,12,2)
9,72^3^9,42
"KRN",.404,152,40,14,0)
10^SECURITY REQUIRED?^3
"KRN",.404,152,40,14,1)
773.3
"KRN",.404,152,40,14,2)
11,29^3^11,9
"KRN",.404,153,0)
HL7 EVENT DRV ITEM^101.0775
"KRN",.404,153,40,0)
^.4044I^1^1
"KRN",.404,153,40,1,0)
1^^3
"KRN",.404,153,40,1,1)
.01
"KRN",.404,153,40,1,2)
1,2^63
"KRN",.404,153,40,1,4)
0
"KRN",.404,153,40,1,10)
S DDSSTACK="PAGE 4"
"KRN",.404,154,0)
HL SUBSCRIBER2^101
"KRN",.404,154,40,0)
^.4044I^12^12
"KRN",.404,154,40,1,0)
1^HL7 SUBSCRIBER^1
"KRN",.404,154,40,1,2)
^^1,28
"KRN",.404,154,40,2,0)
4^RECEIVING APPLICATION^3
"KRN",.404,154,40,2,1)
770.2
"KRN",.404,154,40,2,2)
4,30^15^4,7
"KRN",.404,154,40,2,10)
S DDSSTACK="PAGE 6"
"KRN",.404,154,40,3,0)
5^RESPONSE MESSAGE TYPE^3
"KRN",.404,154,40,3,1)
770.11
"KRN",.404,154,40,3,2)
6,30^3^6,7
"KRN",.404,154,40,4,0)
6^EVENT TYPE^3
"KRN",.404,154,40,4,1)
770.4
"KRN",.404,154,40,4,2)
6,70^3^6,58
"KRN",.404,154,40,5,0)
11^LOGICAL LINK^3
"KRN",.404,154,40,5,1)
770.7
"KRN",.404,154,40,5,2)
12,30^10^12,16
"KRN",.404,154,40,6,0)
12^PROCESSING RTN^3
"KRN",.404,154,40,6,1)
771
"KRN",.404,154,40,6,2)
14,19^54^14,3
"KRN",.404,154,40,7,0)
2^^3
"KRN",.404,154,40,7,1)
.01
"KRN",.404,154,40,7,2)
2,25^30
"KRN",.404,154,40,7,4)
0^^^1
"KRN",.404,154,40,8,0)
3^------------------------------------------------------------------------^1
"KRN",.404,154,40,8,2)
^^3,2
"KRN",.404,154,40,9,0)
13^ROUTING LOGIC^3
"KRN",.404,154,40,9,1)
774
"KRN",.404,154,40,9,2)
15,19^54^15,4
"KRN",.404,154,40,10,0)
7^SENDING FACILITY REQUIRED?^3
"KRN",.404,154,40,10,1)
773.1
"KRN",.404,154,40,10,2)
8,30^3^8,2
"KRN",.404,154,40,11,0)
8^RECEIVING FACILITY REQUIRED?^3
"KRN",.404,154,40,11,1)
773.2
"KRN",.404,154,40,11,2)
8,70^3^8,40
"KRN",.404,154,40,12,0)
9^SECURITY REQUIRED?^3
"KRN",.404,154,40,12,1)
773.3
"KRN",.404,154,40,12,2)
10,30^3^10,10
"KRN",.404,155,0)
HL7 APP BLK2^771
"KRN",.404,155,40,0)
^.4044I^8^8
"KRN",.404,155,40,1,0)
1^Sending Application Edit^1
"KRN",.404,155,40,1,2)
^^1,24
"KRN",.404,155,40,2,0)
2^NAME^3
"KRN",.404,155,40,2,1)
.01
"KRN",.404,155,40,2,2)
3,23^15^3,17
"KRN",.404,155,40,3,0)
3^ACTIVE/INACTIVE^3
"KRN",.404,155,40,3,1)
2
"KRN",.404,155,40,3,2)
3,67^8^3,50
"KRN",.404,155,40,4,0)
4^FACILITY NAME^3
"KRN",.404,155,40,4,1)
3
"KRN",.404,155,40,4,2)
5,23^20^5,8
"KRN",.404,155,40,5,0)
5^COUNTRY CODE^3
"KRN",.404,155,40,5,1)
7
"KRN",.404,155,40,5,2)
5,67^3^5,53
"KRN",.404,155,40,6,0)
6^HL7 FIELD SEPARATOR^3
"KRN",.404,155,40,6,1)
100
"KRN",.404,155,40,6,2)
7,23^1^7,2
"KRN",.404,155,40,7,0)
7^HL7 ENCODING CHARACTERS^3
"KRN",.404,155,40,7,1)
101
"KRN",.404,155,40,7,2)
7,67^4^7,42
"KRN",.404,155,40,8,0)
8^MAIL GROUP^3
"KRN",.404,155,40,8,1)
4
"KRN",.404,155,40,8,2)
10,23^30^10,11
"KRN",.404,156,0)
HL7 APP BLK3^771
"KRN",.404,156,40,0)
^.4044I^8^6
"KRN",.404,156,40,1,0)
1^Receiving Application Edit^1
"KRN",.404,156,40,1,2)
^^1,22
"KRN",.404,156,40,2,0)
2^NAME^3
"KRN",.404,156,40,2,1)
.01
"KRN",.404,156,40,2,2)
3,17^15^3,11
"KRN",.404,156,40,3,0)
3^ACTIVE/INACTIVE^3
"KRN",.404,156,40,3,1)
2
"KRN",.404,156,40,3,2)
3,66^8^3,49
"KRN",.404,156,40,4,0)
4^FACILITY NAME^3
"KRN",.404,156,40,4,1)
3
"KRN",.404,156,40,4,2)
5,17^20^5,2
"KRN",.404,156,40,5,0)
5^COUNTRY CODE^3
"KRN",.404,156,40,5,1)
7
"KRN",.404,156,40,5,2)
5,66^3^5,52
"KRN",.404,156,40,8,0)
8^MAIL GROUP^3
"KRN",.404,156,40,8,1)
4
"KRN",.404,156,40,8,2)
7,17^30^7,5
"KRN",19,817,-1)
1^1
"KRN",19,817,0)
HL COMMUNICATIONS SERVER
"KRN",19,818,-1)
1^2
"KRN",19,818,0)
HL COPY QUEUE ENTRY
"KRN",19,819,-1)
1^3
"KRN",19,819,0)
HL CRE/ED QUEUE TEST ENTRY
"KRN",19,820,-1)
1^4
"KRN",19,820,0)
HL CUSTOM REPORT
"KRN",19,821,-1)
1^5
"KRN",19,821,0)
HL INTERFACE WORKBENCH
"KRN",19,822,-1)
1^6
"KRN",19,822,0)
HL MANAGE FILERS
"KRN",19,823,-1)
1^7
"KRN",19,823,0)
HL MENU 1.6
"KRN",19,824,-1)
1^8
"KRN",19,824,0)
HL MENU TK TESTING
"KRN",19,825,-1)
1^9
"KRN",19,825,0)
HL PRINT MENU
"KRN",19,826,-1)
1^10
"KRN",19,826,0)
HL QUEUE MANAGEMENT
"KRN",19,827,-1)
1^11
"KRN",19,827,0)
HL START ONE INCOMING FILER
"KRN",19,828,-1)
1^12
"KRN",19,828,0)
HL START ONE OUTGOING FILER
"KRN",19,829,-1)
1^13
"KRN",19,829,0)
HL STOP
"KRN",19,830,-1)
1^14
"KRN",19,830,0)
HL STOP ALL LINKS
"KRN",19,831,-1)
1^15
"KRN",19,831,0)
HL STOP ALL OUTGOING FILERS
"KRN",19,832,-1)
1^16
"KRN",19,832,0)
HL STOP LINK MANAGER
"KRN",19,833,-1)
1^17
"KRN",19,833,0)
HL STOP ONE INCOMING FILER
"KRN",19,834,-1)
1^18
"KRN",19,834,0)
HL STOP ONE OUTGOING FILER
"MBREQ")
0
"ORD",8,.403)
.403;8;;;EDEOUT^DIFROMSO(.403,DA,"",XPDA);FPRE^DIFROMSI(.403,"",XPDA);EPRE^DIFROMSI(.403,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.403,DA,"",XPDA);DEL^DIFROMSK(.403,"",%)
"ORD",8,.403,0)
FORM
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
59^3000523
"PKG",9,22,1,"PAH",1,1,0)
^^125^125^3000523
"PKG",9,22,1,"PAH",1,1,1,0)
1. Introduces HL7 version 2.3.1 MESSAGE STRUCTURE components:
"PKG",9,22,1,"PAH",1,1,2,0)
        -Introduces a new file (#779.005) to hold the new HL7 MESSAGE
"PKG",9,22,1,"PAH",1,1,3,0)
         STRUCTURE CODES.
"PKG",9,22,1,"PAH",1,1,4,0)
        -Adds a new field, MESSAGE STRUCTURE (#770.5), to the Protocol
"PKG",9,22,1,"PAH",1,1,5,0)
         file. When defined, the MESSAGE STRUCTURE will be added to the
"PKG",9,22,1,"PAH",1,1,6,0)
         version 2.3.1 message header.
"PKG",9,22,1,"PAH",1,1,7,0)
 
"PKG",9,22,1,"PAH",1,1,8,0)
2. The message type of outbound messages was incorrectly stored in file
"PKG",9,22,1,"PAH",1,1,9,0)
   773. This has been fixed.
"PKG",9,22,1,"PAH",1,1,10,0)
 
"PKG",9,22,1,"PAH",1,1,11,0)
3. In file 771, HL APPLICATION PARAMETER, the input transforms for FIELD
"PKG",9,22,1,"PAH",1,1,12,0)
   SEPARATOR and ENCODING CHARACTERS have been modified to prevent reuse
"PKG",9,22,1,"PAH",1,1,13,0)
   of the field separator in the encoding characters. Each of the
"PKG",9,22,1,"PAH",1,1,14,0)
   characters defined must be unique.
"PKG",9,22,1,"PAH",1,1,15,0)
 
"PKG",9,22,1,"PAH",1,1,16,0)
4. HL*1.6*57 introduced a new menu structure. However, the old, obsolete
"PKG",9,22,1,"PAH",1,1,17,0)
   menus were not removed. This patch will remove them.
"PKG",9,22,1,"PAH",1,1,18,0)
 
"PKG",9,22,1,"PAH",1,1,19,0)
5. Fixes a problem with STUB records left behind in file 870 (Logical
"PKG",9,22,1,"PAH",1,1,20,0)
   Link) resulting in freezing of links and the System Link Monitor as
"PKG",9,22,1,"PAH",1,1,21,0)
   well as causing queues to grow until disk space is used up.
"PKG",9,22,1,"PAH",1,1,22,0)
 
"PKG",9,22,1,"PAH",1,1,23,0)
NOTE: Some sites may have a considerable number of messages needing to be
"PKG",9,22,1,"PAH",1,1,24,0)
purged from file 870. Please consider disabling journalling of ^HLCS() for
"PKG",9,22,1,"PAH",1,1,25,0)
about a week after installing this patch.
"PKG",9,22,1,"PAH",1,1,26,0)
 
"PKG",9,22,1,"PAH",1,1,27,0)
6.  Changes the PROCESSING ID field of file 101 to be no longer required.
"PKG",9,22,1,"PAH",1,1,28,0)
Note that HL7 message headers are populated with information for
"PKG",9,22,1,"PAH",1,1,29,0)
'TRAINING' or 'PRODUCTION' taken from the HL7 site parameters. Use the
"PKG",9,22,1,"PAH",1,1,30,0)
option, SITE PARAMETER EDIT, to verify that your production account is
"PKG",9,22,1,"PAH",1,1,31,0)
identified as such and your test/training account is identified as
"PKG",9,22,1,"PAH",1,1,32,0)
'TRAINING.' The event driver protocol PROCESSING ID field is now used only
"PKG",9,22,1,"PAH",1,1,33,0)
for DEBUG mode. Debug mode will override your site parameter setting. Make
"PKG",9,22,1,"PAH",1,1,34,0)
sure the protocol is set to 'debug' on both the sending and receiving
"PKG",9,22,1,"PAH",1,1,35,0)
system.
"PKG",9,22,1,"PAH",1,1,36,0)
 
"PKG",9,22,1,"PAH",1,1,37,0)
7. Corrects a problem with creating new subscriptions when a user edits
"PKG",9,22,1,"PAH",1,1,38,0)
the zero node of file 774.
"PKG",9,22,1,"PAH",1,1,39,0)
 
"PKG",9,22,1,"PAH",1,1,40,0)
This patch resolves the following NOIS calls:
"PKG",9,22,1,"PAH",1,1,41,0)
 
"PKG",9,22,1,"PAH",1,1,42,0)
        AMA-0300-70683
"PKG",9,22,1,"PAH",1,1,43,0)
        ISD-0300-71919
"PKG",9,22,1,"PAH",1,1,44,0)
        HOU-0400-71933
"PKG",9,22,1,"PAH",1,1,45,0)
 
"PKG",9,22,1,"PAH",1,1,46,0)
The following routines are included in this patch.  The second line of
"PKG",9,22,1,"PAH",1,1,47,0)
each of these routines now looks like:
"PKG",9,22,1,"PAH",1,1,48,0)
  
"PKG",9,22,1,"PAH",1,1,49,0)
   ;;1.6;HEALTH LEVEL SEVEN;<patchlist>;Oct 13, 1995
"PKG",9,22,1,"PAH",1,1,50,0)
  
"PKG",9,22,1,"PAH",1,1,51,0)
  CHECK^XTSUMBLD results: 
"PKG",9,22,1,"PAH",1,1,52,0)
    
"PKG",9,22,1,"PAH",1,1,53,0)
  Routine Name  Before Patch    After Patch     Patch List 
"PKG",9,22,1,"PAH",1,1,54,0)
  ============  ============    ===========     ========== 
"PKG",9,22,1,"PAH",1,1,55,0)
  HLCSHDR       7364841         7637619         **37,19,57,59**
"PKG",9,22,1,"PAH",1,1,56,0)
  HLCSHDR1      7750238         8586633         **19,57,59**
"PKG",9,22,1,"PAH",1,1,57,0)
  HLCSQUE       4338251         4440270         **14,61,59**
"PKG",9,22,1,"PAH",1,1,58,0)
  HLCSQUE1      1150239         1371156         **14,59**
"PKG",9,22,1,"PAH",1,1,59,0)
  HLFNC2        5397412         5365297         **2,26,57,59**
"PKG",9,22,1,"PAH",1,1,60,0)
  HLTP4         7805100         7964901         **19,57,59**
"PKG",9,22,1,"PAH",1,1,61,0)
  HLTPCK1A      14402537        14751742        **2,25,34,57,59**
"PKG",9,22,1,"PAH",1,1,62,0)
  HLTPCK2A      15262342        15611547        **19,57,59**
"PKG",9,22,1,"PAH",1,1,63,0)
  HLUTIL2       5387464         5486507         **19,43,57,59**
"PKG",9,22,1,"PAH",1,1,64,0)
  HLTPCK1       4288888         4452787         **8,36,59**
"PKG",9,22,1,"PAH",1,1,65,0)
  HLTPCK2       3804314         3962788         **19,59**
"PKG",9,22,1,"PAH",1,1,66,0)
  HLTP3         14451393        14649677        **19,43,57,58,59**
"PKG",9,22,1,"PAH",1,1,67,0)
  HLSUB         5501510         5552075         **14,57,58,59**
"PKG",9,22,1,"PAH",1,1,68,0)
 
"PKG",9,22,1,"PAH",1,1,69,0)
 List of preceding patches: 14, 36, 57, 58, 61
"PKG",9,22,1,"PAH",1,1,70,0)
 Sites should use CHECK^XTSUMBLD to verify checksums.
"PKG",9,22,1,"PAH",1,1,71,0)
  
"PKG",9,22,1,"PAH",1,1,72,0)
 Installation Instructions: 
"PKG",9,22,1,"PAH",1,1,73,0)
 ==========================
"PKG",9,22,1,"PAH",1,1,74,0)
   1.  Users are allowed to be on the system during the installation.  
"PKG",9,22,1,"PAH",1,1,75,0)
  
"PKG",9,22,1,"PAH",1,1,76,0)
   2.  DSM SITES: Review your mapped set.  If any of the routines listed
"PKG",9,22,1,"PAH",1,1,77,0)
       in the Routine Summary section are mapped, they should be removed
"PKG",9,22,1,"PAH",1,1,78,0)
       from the mapped set at this time.
"PKG",9,22,1,"PAH",1,1,79,0)
  
"PKG",9,22,1,"PAH",1,1,80,0)
   3.  Shutdown all Logical Links and incoming and outgoing filers, and
"PKG",9,22,1,"PAH",1,1,81,0)
       the Link Manager. Use the options:
"PKG",9,22,1,"PAH",1,1,82,0)
  
"PKG",9,22,1,"PAH",1,1,83,0)
         Filer and Link Management Options -> 
"PKG",9,22,1,"PAH",1,1,84,0)
             SA     Stop All Messaging Background Processes
"PKG",9,22,1,"PAH",1,1,85,0)
             LM     TCP/IP Link Manager Start/Stop
"PKG",9,22,1,"PAH",1,1,86,0)
  
"PKG",9,22,1,"PAH",1,1,87,0)
   4.  Use the 'INSTALL/CHECK MESSAGE' option on the PackMan menu. This 
"PKG",9,22,1,"PAH",1,1,88,0)
       option will load the KIDS package onto your system.  
"PKG",9,22,1,"PAH",1,1,89,0)
  
"PKG",9,22,1,"PAH",1,1,90,0)
   5.  The patch has now been loaded into a Transport global on your 
"PKG",9,22,1,"PAH",1,1,91,0)
       system. You now need to use KIDS to install the Transport global.  
"PKG",9,22,1,"PAH",1,1,92,0)
       On the KIDS menu, under the 'Installation' menu, use the following 
"PKG",9,22,1,"PAH",1,1,93,0)
       options: 
"PKG",9,22,1,"PAH",1,1,94,0)
  
"PKG",9,22,1,"PAH",1,1,95,0)
          2 Verify Checksums in Transport Global 
"PKG",9,22,1,"PAH",1,1,96,0)
          3 Print Transport Global 
"PKG",9,22,1,"PAH",1,1,97,0)
          4 Compare Transport Global to Current System 
"PKG",9,22,1,"PAH",1,1,98,0)
          5 Backup a Transport Global 
"PKG",9,22,1,"PAH",1,1,99,0)
          6 Install Package(s) 
"PKG",9,22,1,"PAH",1,1,100,0)
              INSTALL NAME: HL*1.6*59
"PKG",9,22,1,"PAH",1,1,101,0)
                            =========
"PKG",9,22,1,"PAH",1,1,102,0)
  
"PKG",9,22,1,"PAH",1,1,103,0)
         Answer 'NO' to 'Want KIDS to Rebuild Menu Trees upon Completion
"PKG",9,22,1,"PAH",1,1,104,0)
         of Install?'.
"PKG",9,22,1,"PAH",1,1,105,0)
  
"PKG",9,22,1,"PAH",1,1,106,0)
         Answer 'NO' to 'Want KIDS to INHIBIT LOGONS during the install?'.
"PKG",9,22,1,"PAH",1,1,107,0)
   
"PKG",9,22,1,"PAH",1,1,108,0)
         Answer 'NO' to 'Want to DISABLE Scheduled Options, Menu Options, 
"PKG",9,22,1,"PAH",1,1,109,0)
         and Protocols?'.  
"PKG",9,22,1,"PAH",1,1,110,0)
  
"PKG",9,22,1,"PAH",1,1,111,0)
   6.  Startup all Logical Links and incoming and outgoing filers. Use the
"PKG",9,22,1,"PAH",1,1,112,0)
 
"PKG",9,22,1,"PAH",1,1,113,0)
  
"PKG",9,22,1,"PAH",1,1,114,0)
         Filer and Link Management Options ->
"PKG",9,22,1,"PAH",1,1,115,0)
             RA     Restart/Start All Links and Filers
"PKG",9,22,1,"PAH",1,1,116,0)
         (Note that links that do not have "autostart" enabled will need
"PKG",9,22,1,"PAH",1,1,117,0)
          to be restarted manually)
"PKG",9,22,1,"PAH",1,1,118,0)
    
"PKG",9,22,1,"PAH",1,1,119,0)
       For DSM sites ONLY, if you previously disabled an HL7 UCX Service
"PKG",9,22,1,"PAH",1,1,120,0)
       for this installation, you may now enable it.
"PKG",9,22,1,"PAH",1,1,121,0)
  
"PKG",9,22,1,"PAH",1,1,122,0)
   7.  DSM Sites: Rebuild your mapped set if necessary.
"PKG",9,22,1,"PAH",1,1,123,0)
  
"PKG",9,22,1,"PAH",1,1,124,0)
   8.  Start Link Manager using the option: "TCP/IP
"PKG",9,22,1,"PAH",1,1,125,0)
         Link Manager Start/Stop."
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
13
"RTN","HLCSHDR")
0^1^B39476177
"RTN","HLCSHDR",1,0)
HLCSHDR ;  ALB/MFK,JRP - Make HL7 header from a #772 IEN ;02/02/2000  12:44
"RTN","HLCSHDR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**37,19,57,59**;Oct 13, 1995
"RTN","HLCSHDR",3,0)
HEADER(IEN,HLERROR) ; Create an HL7 MSH segment
"RTN","HLCSHDR",4,0)
 ;
"RTN","HLCSHDR",5,0)
 ;Input  : IEN - Pointer to entry in Message Text file (#772) that
"RTN","HLCSHDR",6,0)
 ;               HL7 MSH segment is being built for
"RTN","HLCSHDR",7,0)
 ;         HLERROR - Variable to return possible error text in
"RTN","HLCSHDR",8,0)
 ;                   (pass by reference - only used when needed)
"RTN","HLCSHDR",9,0)
 ;
"RTN","HLCSHDR",10,0)
 ;Output : HLHDR(1) - HL7 MSH segment
"RTN","HLCSHDR",11,0)
 ;         HLHDR(2) - Continuation of HL7 MSH segment (if needed)
"RTN","HLCSHDR",12,0)
 ;         HLHDR(3) - Continuation of HL7 MSH segment (if needed)
"RTN","HLCSHDR",13,0)
 ;
"RTN","HLCSHDR",14,0)
 ;Notes  : HLERROR will only be defined [on output] if an error occurs
"RTN","HLCSHDR",15,0)
 ;       : HLHDR() will not be defined [on output] if an error occurs
"RTN","HLCSHDR",16,0)
 ;       : HLHDR(2) & HLHDR(3) are continuation [or roll-over] nodes
"RTN","HLCSHDR",17,0)
 ;         and will only be used/defined when needed
"RTN","HLCSHDR",18,0)
 ;
"RTN","HLCSHDR",19,0)
 ;Check input
"RTN","HLCSHDR",20,0)
 S IEN=+$G(IEN)
"RTN","HLCSHDR",21,0)
 I ('$D(^HL(772,IEN,0))) S HLERROR="Valid pointer to Message Text file (#772) not passed" Q
"RTN","HLCSHDR",22,0)
 ;Declare variables
"RTN","HLCSHDR",23,0)
 N PROTOCOL,PARENTP,PARENT,SERVERP,CLIENTP,FS,PROT,MSGTYPE,APPPRM
"RTN","HLCSHDR",24,0)
 N HLDTID,HLID,HLDATE,SECURITY,ID,SERAPP,SERFAC,EC,ACCACK,APPACK
"RTN","HLCSHDR",25,0)
 N CHILD,CLNTAPP,CLNTFAC,ACKTO,CNTRY,HLPROT,HLPROTS,HLPARAM
"RTN","HLCSHDR",26,0)
 ;Get Site Parameters
"RTN","HLCSHDR",27,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLCSHDR",28,0)
 ;Get parent message (NOTE: Original message is it's own parent)
"RTN","HLCSHDR",29,0)
 S CHILD=$G(^HL(772,IEN,0))
"RTN","HLCSHDR",30,0)
 I CHILD="" S HLERROR="Valid pointer to Message Text file (#772) not passed" Q
"RTN","HLCSHDR",31,0)
 S PARENTP=+$P(CHILD,"^",8)
"RTN","HLCSHDR",32,0)
 I ('PARENTP) S HLERROR="Could not determine parent message" Q
"RTN","HLCSHDR",33,0)
 S PARENT=$G(^HL(772,PARENTP,0))
"RTN","HLCSHDR",34,0)
 ;Get server [sending] & client [receiving] applications
"RTN","HLCSHDR",35,0)
 S SERVERP=+$P(PARENT,"^",2)
"RTN","HLCSHDR",36,0)
 I ('SERVERP) S HLERROR="Could not determine sending application" Q
"RTN","HLCSHDR",37,0)
 S CLIENTP=+$P(CHILD,"^",3)
"RTN","HLCSHDR",38,0)
 I ('CLIENTP) S HLERROR="Could not determine receiving application" Q
"RTN","HLCSHDR",39,0)
 ;Get info for sending & receiving applications
"RTN","HLCSHDR",40,0)
 D APPPRM^HLUTIL2(CLIENTP)
"RTN","HLCSHDR",41,0)
 D APPPRM^HLUTIL2(SERVERP)
"RTN","HLCSHDR",42,0)
 ;Get name of sending application and facility
"RTN","HLCSHDR",43,0)
 S SERAPP=$P(APPPRM(SERVERP,0),"^",1)
"RTN","HLCSHDR",44,0)
 S SERFAC=$P(APPPRM(SERVERP,0),"^",2)
"RTN","HLCSHDR",45,0)
 ;Get name of receiving application and facility
"RTN","HLCSHDR",46,0)
 S CLNTAPP=$P(APPPRM(CLIENTP,0),"^",1)
"RTN","HLCSHDR",47,0)
 S CLNTFAC=$P(APPPRM(CLIENTP,0),"^",2)
"RTN","HLCSHDR",48,0)
 ;Get country
"RTN","HLCSHDR",49,0)
 S CNTRY=$P(APPPRM(SERVERP,0),"^",3)
"RTN","HLCSHDR",50,0)
 ;Get field seperator & encoding characters
"RTN","HLCSHDR",51,0)
 S FS=APPPRM(SERVERP,"FS")
"RTN","HLCSHDR",52,0)
 S EC=APPPRM(SERVERP,"EC")
"RTN","HLCSHDR",53,0)
 S:(EC="") EC="~|\&"
"RTN","HLCSHDR",54,0)
 S:(FS="") FS="^"
"RTN","HLCSHDR",55,0)
 ;
"RTN","HLCSHDR",56,0)
 ;Determine if it's a response/ACK to another message
"RTN","HLCSHDR",57,0)
 ;
"RTN","HLCSHDR",58,0)
 S ACKTO=+$P(PARENT,"^",7)
"RTN","HLCSHDR",59,0)
 ;
"RTN","HLCSHDR",60,0)
 ;Get message type
"RTN","HLCSHDR",61,0)
 ;Message type/Event Type of Initiator found on Event Driver
"RTN","HLCSHDR",62,0)
 ;Message type/Event Type of Responder found on Subscriber
"RTN","HLCSHDR",63,0)
 ;
"RTN","HLCSHDR",64,0)
 S PROT=+$P(PARENT,"^",10),HLPROT=PROT
"RTN","HLCSHDR",65,0)
 S:ACKTO&($G(HLOGLINK)) PROT=+$P(CHILD,"^",10)
"RTN","HLCSHDR",66,0)
 S PROTOCOL=$$TYPE^HLUTIL2(PROT)
"RTN","HLCSHDR",67,0)
 ;if initiating a new transaction, get MsgType from Event Driver, field 770.3
"RTN","HLCSHDR",68,0)
 ;if generating a response, get MsgType from subscriber, field 770.11
"RTN","HLCSHDR",69,0)
 S MSGTYPE=$S(ACKTO:$P(PROTOCOL,"^",10),1:$P(PROTOCOL,"^",2))
"RTN","HLCSHDR",70,0)
 ;Append event type
"RTN","HLCSHDR",71,0)
 I MSGTYPE']"" S HLERROR="Message Type Undefined for protocol "_$P(PROTOCOL,"^",1) Q
"RTN","HLCSHDR",72,0)
 I $P(PROTOCOL,"^",3)]"" S MSGTYPE=MSGTYPE_$E(EC,1)_$P(PROTOCOL,"^",3)
"RTN","HLCSHDR",73,0)
 ;Append mesaage structure component
"RTN","HLCSHDR",74,0)
 I $P(PROTOCOL,"^",3)]"",$P(PROTOCOL,"^",4)]"" S MSGTYPE=MSGTYPE_$E(EC,1)_$P(PROTOCOL,"^",4)
"RTN","HLCSHDR",75,0)
 ;Get accept ack & application ack type (based on server protocol)
"RTN","HLCSHDR",76,0)
 ;  Originating messages have it listed in the parent message
"RTN","HLCSHDR",77,0)
 ;  Responses/ACKs have it listed in the child message
"RTN","HLCSHDR",78,0)
 S PROT=+$P(PARENT,"^",10),HLPROT=PROT
"RTN","HLCSHDR",79,0)
 S:(ACKTO) PROT=+$P(CHILD,"^",10)
"RTN","HLCSHDR",80,0)
 S HLPROTS=+$P(CHILD,"^",10)
"RTN","HLCSHDR",81,0)
 S PROTOCOL=$$TYPE^HLUTIL2(PROT)
"RTN","HLCSHDR",82,0)
 S ACCACK=$P(PROTOCOL,"^",7)
"RTN","HLCSHDR",83,0)
 S APPACK=$P(PROTOCOL,"^",8)
"RTN","HLCSHDR",84,0)
 ;Get date/time & message ID
"RTN","HLCSHDR",85,0)
 S HLDATE=+PARENT
"RTN","HLCSHDR",86,0)
 S HLDATE=$$FMTHL7^XLFDT(HLDATE)
"RTN","HLCSHDR",87,0)
MID ;Message ID
"RTN","HLCSHDR",88,0)
 S HLID=$P(PARENT,"^",6)
"RTN","HLCSHDR",89,0)
PID ;Processing ID
"RTN","HLCSHDR",90,0)
 ;If event driver set to 'debug' get from protocol
"RTN","HLCSHDR",91,0)
 ;'production' or 'training' comes from site params
"RTN","HLCSHDR",92,0)
 S HLPID=$P(PROTOCOL,"^",5)
"RTN","HLCSHDR",93,0)
 I $G(HLPID)'="D" S HLPID=$P(HLPARAM,U,3)
"RTN","HLCSHDR",94,0)
 I $G(HLPID)="" S HLERROR="Missing Processing ID Site Parameter."
"RTN","HLCSHDR",95,0)
 ;Get security info
"RTN","HLCSHDR",96,0)
 S SECURITY=$P(PARENT,"^",12)
"RTN","HLCSHDR",97,0)
 D HDR23
"RTN","HLCSHDR",98,0)
 ;Build MSH array
"RTN","HLCSHDR",99,0)
 S HLHDR(1)="MSH"_FS_EC_FS_SERAPP_FS_SERFAC_FS_CLNTAPP_FS_CLNTFAC_FS
"RTN","HLCSHDR",100,0)
 S HLHDR(1)=HLHDR(1)_HLDATE_FS_SECURITY_FS_MSGTYPE_FS_HLID_FS
"RTN","HLCSHDR",101,0)
 S HLHDR(1)=HLHDR(1)_HLPID_FS_$P(PROTOCOL,"^",9)_FS_FS
"RTN","HLCSHDR",102,0)
 S HLHDR(2)=$G(^HL(772,PARENT,1))_FS
"RTN","HLCSHDR",103,0)
 S HLHDR(3)=ACCACK_FS_APPACK_FS_CNTRY
"RTN","HLCSHDR",104,0)
 ;Combine line 1 & 2 (if possible)
"RTN","HLCSHDR",105,0)
 I (($L(HLHDR(1))+$L(HLHDR(2)))'>245) D
"RTN","HLCSHDR",106,0)
 .S HLHDR(1)=HLHDR(1)_HLHDR(2)
"RTN","HLCSHDR",107,0)
 .S HLHDR(2)=HLHDR(3)
"RTN","HLCSHDR",108,0)
 .S HLHDR(3)=""
"RTN","HLCSHDR",109,0)
 .;Add original line 3 (if possible)
"RTN","HLCSHDR",110,0)
 .I (($L(HLHDR(1))+$L(HLHDR(2)))'>245) D
"RTN","HLCSHDR",111,0)
 ..S HLHDR(1)=HLHDR(1)_HLHDR(2)
"RTN","HLCSHDR",112,0)
 ..S HLHDR(2)=""
"RTN","HLCSHDR",113,0)
 ;Combine line 2 & 3 (if possible)
"RTN","HLCSHDR",114,0)
 I (($L(HLHDR(2))+$L(HLHDR(3)))'>245) D
"RTN","HLCSHDR",115,0)
 .S HLHDR(2)=HLHDR(2)_HLHDR(3)
"RTN","HLCSHDR",116,0)
 .S HLHDR(3)=""
"RTN","HLCSHDR",117,0)
 ;Delete unused lines
"RTN","HLCSHDR",118,0)
 K:(HLHDR(2)="") HLHDR(2)
"RTN","HLCSHDR",119,0)
 K:(HLHDR(3)="") HLHDR(3)
"RTN","HLCSHDR",120,0)
 Q
"RTN","HLCSHDR",121,0)
BHSHDR(IEN) ; Create Batch Header Segment
"RTN","HLCSHDR",122,0)
 ; The BHS has 12 segments, of which 4 are blank.
"RTN","HLCSHDR",123,0)
 ; INPUT: IEN - IEN of entry in file #772
"RTN","HLCSHDR",124,0)
 ; OUTPUT: HLHDR(1) and HLHDR(2) - the two lines with the 12 segs.
"RTN","HLCSHDR",125,0)
 ;   ready for adding to a message directly.
"RTN","HLCSHDR",126,0)
 N BFS,BEC,BSA,BSF,BRA,BRF,BCD,BS,BN,BC,BCI,RBCI,PARENT,PARENTP
"RTN","HLCSHDR",127,0)
 N ID,CLIENTP,SERVERP,HLDTID,HLDATE,APPPRM
"RTN","HLCSHDR",128,0)
 N CHILD,ACKTO,ACKMID,BTACK,BSTATUS
"RTN","HLCSHDR",129,0)
 S CHILD=$G(^HL(772,IEN,0))
"RTN","HLCSHDR",130,0)
 S PARENTP=$P(CHILD,"^",8)
"RTN","HLCSHDR",131,0)
 I (PARENTP="") S HLHDR(1)="-1^No parent" Q
"RTN","HLCSHDR",132,0)
 S PARENT=$G(^HL(772,PARENTP,0))
"RTN","HLCSHDR",133,0)
 S SERVERP=$P(PARENT,"^",2)
"RTN","HLCSHDR",134,0)
 I (SERVERP="") S HLHDR(1)="-1^No server for this node" Q
"RTN","HLCSHDR",135,0)
 S CLIENTP=$P(CHILD,"^",3)
"RTN","HLCSHDR",136,0)
 I (CLIENTP="") S HLHDR(1)="-1^No client for this node" Q
"RTN","HLCSHDR",137,0)
 ;--  get server and application parameters
"RTN","HLCSHDR",138,0)
 D APPPRM^HLUTIL2(SERVERP)
"RTN","HLCSHDR",139,0)
 D APPPRM^HLUTIL2(CLIENTP)
"RTN","HLCSHDR",140,0)
 S BFS=APPPRM(SERVERP,"FS")
"RTN","HLCSHDR",141,0)
 S BEC=APPPRM(SERVERP,"EC")
"RTN","HLCSHDR",142,0)
 ;-- sending application
"RTN","HLCSHDR",143,0)
 S BSA=$P(APPPRM(SERVERP,0),"^",1)
"RTN","HLCSHDR",144,0)
 ;-- sending facility
"RTN","HLCSHDR",145,0)
 S BSF=$P(APPPRM(SERVERP,0),"^",2)
"RTN","HLCSHDR",146,0)
 ;-- receiving application
"RTN","HLCSHDR",147,0)
 S BRA=$P(APPPRM(CLIENTP,0),"^",1)
"RTN","HLCSHDR",148,0)
 ;-- receiving facility
"RTN","HLCSHDR",149,0)
 S BRF=$P(APPPRM(CLIENTP,0),"^",2)
"RTN","HLCSHDR",150,0)
 S HLDATE=+PARENT
"RTN","HLCSHDR",151,0)
 S HLID=$P(PARENT,"^",6)
"RTN","HLCSHDR",152,0)
 S BCD=$$HLDATE^HLFNC(HLDATE,"TS")
"RTN","HLCSHDR",153,0)
 ;-- batch security
"RTN","HLCSHDR",154,0)
 S BS=$P(PARENT,"^",12)
"RTN","HLCSHDR",155,0)
 ;-- build batch field #9  NULL~Process ID~Message Type|Event Type~version
"RTN","HLCSHDR",156,0)
 S ACKTO=$P(PARENT,"^",7)
"RTN","HLCSHDR",157,0)
 S PROT=$S((ACKTO&$G(HLOGLINK)):$P(CHILD,"^",10),1:$P(PARENT,"^",10))
"RTN","HLCSHDR",158,0)
 ;S X=$$TYPE^HLUTIL2($P(CHILD,U,10))
"RTN","HLCSHDR",159,0)
 ; for batch ACK message, client protocol pointer is stored in parent message
"RTN","HLCSHDR",160,0)
 ;I ACKTO S X=$$TYPE^HLUTIL2($P(PARENT,U,10))
"RTN","HLCSHDR",161,0)
 S X=$$TYPE^HLUTIL2(PROT)
"RTN","HLCSHDR",162,0)
 S MSGTYPE=$S(ACKTO:$P(X,"^",10),1:$P(X,"^",2))
"RTN","HLCSHDR",163,0)
 I MSGTYPE']"" S HLERROR="MType undefined for protocol "_$P(X,U) Q
"RTN","HLCSHDR",164,0)
 I $P(X,U,3)]"" S MSGTYPE=MSGTYPE_$E(BEC,2)_$P(X,U,3)
"RTN","HLCSHDR",165,0)
 ;S BN=$E(BEC,1)_$P(X,U,5)_$E(BEC,1)_$S('$P(CHILD,"^",11)&('ACKTO):$P(X,U,2),1:$P(X,U,10))_$E(BEC,2)_$P(X,U,3)_$E(BEC,1)_$P(X,U,9)
"RTN","HLCSHDR",166,0)
 S BN=$E(BEC,1)_$P(X,U,5)_$E(BEC,1)_MSGTYPE_$E(BEC,1)_$P(X,U,9)
"RTN","HLCSHDR",167,0)
 ;
"RTN","HLCSHDR",168,0)
 ; for batch ACK message
"RTN","HLCSHDR",169,0)
 S ACKMID="",BTACK=""
"RTN","HLCSHDR",170,0)
 I ACKTO D
"RTN","HLCSHDR",171,0)
 . S ACKMID=$P($G(^HL(772,ACKTO,0)),"^",6)
"RTN","HLCSHDR",172,0)
 . S BSTATUS=$P($G(^HL(772,ACKTO,"P")),"^")
"RTN","HLCSHDR",173,0)
 . S BTACK="AR"
"RTN","HLCSHDR",174,0)
 . I ACKMID]"" D
"RTN","HLCSHDR",175,0)
 .. S BTACK="AA"
"RTN","HLCSHDR",176,0)
 .. I (BSTATUS>3)&(BSTATUS<8) S BTACK="AE"_$E(BEC,1)_$P($G(^HL(772,ACKTO,"P")),"^",3)
"RTN","HLCSHDR",177,0)
 ;
"RTN","HLCSHDR",178,0)
 S HLHDR(1)="BHS"_BFS_BEC_BFS_BSA_BFS_BSF_BFS_BRA_BFS_BRF_BFS_BCD_BFS_BS_BFS_BN_BFS_BTACK_BFS_HLID_BFS_ACKMID
"RTN","HLCSHDR",179,0)
 Q
"RTN","HLCSHDR",180,0)
HDR23 ;generate extended facility field info based on 'facility required'
"RTN","HLCSHDR",181,0)
 ;default format is INSTITUTION_HLCS_DOMAIN_HLCS_'DNS'
"RTN","HLCSHDR",182,0)
 ;application parameter entry overrides default
"RTN","HLCSHDR",183,0)
 N HLEP773,HLS773
"RTN","HLCSHDR",184,0)
 S SERFAC=$G(SERFAC),CLNTFAC=$G(CLNTFAC)
"RTN","HLCSHDR",185,0)
 S HLEP773=+$G(^ORD(101,HLPROTS,773))
"RTN","HLCSHDR",186,0)
 S HLS773=+$P($G(^ORD(101,HLPROTS,773)),U,2)
"RTN","HLCSHDR",187,0)
 Q:'HLEP773&('HLS773)
"RTN","HLCSHDR",188,0)
 D GEN^HLCSHDR2
"RTN","HLCSHDR",189,0)
 I ACKTO D  Q
"RTN","HLCSHDR",190,0)
 .;Find original message
"RTN","HLCSHDR",191,0)
 .S X=$G(^HL(772,ACKTO,"IN",1,0))
"RTN","HLCSHDR",192,0)
 .I X["MSH" D
"RTN","HLCSHDR",193,0)
 ..S HLFS=$E(X,4)
"RTN","HLCSHDR",194,0)
 ..S SENDFAC=$P(X,HLFS,4),RECFAC=$P(X,HLFS,6) ;from original msg
"RTN","HLCSHDR",195,0)
 ..S CLNTFAC=SENDFAC,SERFAC=RECFAC ;reverse facility info
"RTN","HLCSHDR",196,0)
 I HLEP773,SERFAC="" D EP^HLCSHDR2
"RTN","HLCSHDR",197,0)
 I HLS773,CLNTFAC="" D S^HLCSHDR2
"RTN","HLCSHDR",198,0)
 Q
"RTN","HLCSHDR1")
0^2^B23649112
"RTN","HLCSHDR1",1,0)
HLCSHDR1 ;SFIRMFO/RSD - Make HL7 header for TCP ;05/09/2000  11:24
"RTN","HLCSHDR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,57,59**;Oct 13, 1995
"RTN","HLCSHDR1",3,0)
HEADER(IEN,CLIENT,HLERROR) ; Create an HL7 MSH segment
"RTN","HLCSHDR1",4,0)
 ;
"RTN","HLCSHDR1",5,0)
 ;Input  : IEN - Pointer to entry in Message Administration file (#773)
"RTN","HLCSHDR1",6,0)
 ;               that HL7 MSH segment is being built for
"RTN","HLCSHDR1",7,0)
 ;         CLIENT - IEN of the receiving application
"RTN","HLCSHDR1",8,0)
 ;         HLERROR - Variable to return possible error text in
"RTN","HLCSHDR1",9,0)
 ;                   (pass by reference - only used when needed)
"RTN","HLCSHDR1",10,0)
 ;
"RTN","HLCSHDR1",11,0)
 ;Output : HLHDR(1) - HL7 MSH segment
"RTN","HLCSHDR1",12,0)
 ;         HLHDR(2) - Continuation of HL7 MSH segment (if needed)
"RTN","HLCSHDR1",13,0)
 ;         HLHDR(3) - Continuation of HL7 MSH segment (if needed)
"RTN","HLCSHDR1",14,0)
 ;
"RTN","HLCSHDR1",15,0)
 ;Notes  : HLERROR will only be defined [on output] if an error occurs
"RTN","HLCSHDR1",16,0)
 ;       : HLHDR() will not be defined [on output] if an error occurs
"RTN","HLCSHDR1",17,0)
 ;       : HLHDR(2) & HLHDR(3) are continuation [or roll-over] nodes
"RTN","HLCSHDR1",18,0)
 ;         and will only be used/defined when needed
"RTN","HLCSHDR1",19,0)
 ;
"RTN","HLCSHDR1",20,0)
 N ACKTO,ACCACK,APPACK,CHILD,CLNTAPP,CLNTFAC,CNTRY,EC,EVNTYPE,FS,HLDATE,HLHDRI,HLHDRL,HLID,HLPID,MSGTYPE,PROT,PROTS,SECURITY,SEND,SERAPP,SERFAC,TXTP,TXTP0,X,MSGEVN
"RTN","HLCSHDR1",21,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLCSHDR1",22,0)
 D VAR Q:$G(HLERROR)]""
"RTN","HLCSHDR1",23,0)
 I $D(^HLMA(IEN)) S $P(^HLMA(IEN,0),U,13)=MSGTYPE,$P(^HLMA(IEN,0),U,14)=$G(EVNTYPE)
"RTN","HLCSHDR1",24,0)
 ;Append event type
"RTN","HLCSHDR1",25,0)
 I $G(EVNTYPE)]"" S MSGTYPE=MSGTYPE_$E(EC,1)_EVNTYPE
"RTN","HLCSHDR1",26,0)
 ;Append message structure component
"RTN","HLCSHDR1",27,0)
 I $G(EVNTYPE)]"",$G(MSGEVN)]"" S MSGTYPE=MSGTYPE_$E(EC,1)_MSGEVN
"RTN","HLCSHDR1",28,0)
 ;Build MSH array
"RTN","HLCSHDR1",29,0)
 S HLHDRI=1,HLHDR(1)="MSH"_FS_EC_FS_SERAPP,HLHDRL=$L(HLHDR(1))
"RTN","HLCSHDR1",30,0)
 F X=SERFAC,CLNTAPP,CLNTFAC,HLDATE,SECURITY,MSGTYPE,HLID,HLPID,$P(PROT,U,9),"",$G(^HL(772,TXTP,1)),ACCACK,APPACK,CNTRY D MSH(X)
"RTN","HLCSHDR1",31,0)
 ;in preceeding line, "" is for sequence number - not supported
"RTN","HLCSHDR1",32,0)
 Q
"RTN","HLCSHDR1",33,0)
 ;
"RTN","HLCSHDR1",34,0)
MSH(X) ;add X to HLHDR
"RTN","HLCSHDR1",35,0)
 S:HLHDRL+$L(X)>245 HLHDRI=HLHDRI+1,HLHDR(HLHDRI)=""
"RTN","HLCSHDR1",36,0)
 S HLHDR(HLHDRI)=HLHDR(HLHDRI)_FS_X,HLHDRL=$L(HLHDR(HLHDRI))
"RTN","HLCSHDR1",37,0)
 Q
"RTN","HLCSHDR1",38,0)
BHSHDR(IEN,CLIENT,HLERROR) ; Create Batch Header Segment
"RTN","HLCSHDR1",39,0)
 ; The BHS has 12 segments, of which 4 are blank.
"RTN","HLCSHDR1",40,0)
 ; INPUT: IEN - IEN of entry in file #772
"RTN","HLCSHDR1",41,0)
 ; OUTPUT: HLHDR(1) and HLHDR(2) - the two lines with the 12 segs.
"RTN","HLCSHDR1",42,0)
 ;   ready for adding to a message directly.
"RTN","HLCSHDR1",43,0)
 N ACKTO,ACCACK,ACKMID,APPACK,BNAME,BSTATUS,BTACK,CHILD,CLNTAPP,CLNTFAC,CNTRY,EC,EVNTYPE,FS,HLDATE,HLHDRI,HLHDRL,HLID,PROT,PROTS,SECURITY,SEND,SERAPP,SERFAC,TXTP,TXTP0,X
"RTN","HLCSHDR1",44,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLCSHDR1",45,0)
 D VAR Q:$G(HLERROR)]""
"RTN","HLCSHDR1",46,0)
 I $D(^HLMA(IEN)) S $P(^HLMA(IEN,0),U,13)=MSGTYPE,$P(^HLMA(IEN,0),U,14)=$G(EVNTYPE)
"RTN","HLCSHDR1",47,0)
 ;
"RTN","HLCSHDR1",48,0)
 ;Append event type
"RTN","HLCSHDR1",49,0)
 I $G(EVNTYPE)]"" S MSGTYPE=MSGTYPE_$E(EC,2)_EVNTYPE,(ACKMID,BTACK)=""
"RTN","HLCSHDR1",50,0)
 ;batch/name/id/type(#9)=null~process ID~msg type|evnt type~version~CA~AA
"RTN","HLCSHDR1",51,0)
 S BNAME=$E(EC,1)_$P(PROT,U,5)_$E(EC,1)_MSGTYPE_$E(EC,1)_$P(PROT,U,9)_$E(EC,1)_ACCACK_$E(EC,1)_APPACK
"RTN","HLCSHDR1",52,0)
 ;for batch ACK
"RTN","HLCSHDR1",53,0)
 I ACKTO D  S BTACK=X_$E(EC,1)_$P(BSTATUS,U,3)
"RTN","HLCSHDR1",54,0)
 . ;get msg id and status of message that is being ACKed
"RTN","HLCSHDR1",55,0)
 . S ACKMID=$P($G(^HLMA(ACKTO,0)),U,2),BSTATUS=$G(^HL(772,ACKTO,"P"))
"RTN","HLCSHDR1",56,0)
 . ;set type of ACK based on status
"RTN","HLCSHDR1",57,0)
 . S X=$S(ACKMID="":"AR",(BSTATUS>3)&(BSTATUS<8):"AE",1:"AA")
"RTN","HLCSHDR1",58,0)
 ;
"RTN","HLCSHDR1",59,0)
 S HLHDRI=1,HLHDR(1)="BHS"_FS_EC_FS_SERAPP,HLHDRL=$L(HLHDR(1))
"RTN","HLCSHDR1",60,0)
 F X=SERFAC,CLNTAPP,CLNTFAC,HLDATE,SECURITY,BNAME,BTACK,HLID,ACKMID D MSH(X)
"RTN","HLCSHDR1",61,0)
 Q
"RTN","HLCSHDR1",62,0)
VAR ;Check input
"RTN","HLCSHDR1",63,0)
 N APPPRM,HLPROTS,HLPROT
"RTN","HLCSHDR1",64,0)
 S IEN=+$G(IEN)
"RTN","HLCSHDR1",65,0)
 I '$G(^HLMA(IEN,0)) S HLERROR="Valid pointer to Message Administration file (#772) not passed" Q
"RTN","HLCSHDR1",66,0)
 I '$G(CLIENT) S HLERROR="Could not determine receiving application" Q
"RTN","HLCSHDR1",67,0)
 ;Get child, text pointer,text entry, and sending app.
"RTN","HLCSHDR1",68,0)
 S CHILD=$G(^HLMA(IEN,0)),SEND=+$P($G(^(0)),U,11),TXTP=+CHILD,TXTP0=$G(^HL(772,TXTP,0))
"RTN","HLCSHDR1",69,0)
 I ('SEND) S HLERROR="Could not determine sending application" Q
"RTN","HLCSHDR1",70,0)
 ;Get info for sending & receiving applications
"RTN","HLCSHDR1",71,0)
 D APPPRM^HLUTIL2(CLIENT),APPPRM^HLUTIL2(SEND)
"RTN","HLCSHDR1",72,0)
 ;Get name of sending application, facility, and country
"RTN","HLCSHDR1",73,0)
 S SERAPP=$P(APPPRM(SEND,0),U),SERFAC=$P(APPPRM(SEND,0),U,2),CNTRY=$P(APPPRM(SEND,0),U,3)
"RTN","HLCSHDR1",74,0)
 ;Get name of receiving application and facility
"RTN","HLCSHDR1",75,0)
 S CLNTAPP=$P(APPPRM(CLIENT,0),U),CLNTFAC=$P(APPPRM(CLIENT,0),U,2)
"RTN","HLCSHDR1",76,0)
 ;Get field separator & encoding characters
"RTN","HLCSHDR1",77,0)
 S FS=APPPRM(SEND,"FS"),EC=APPPRM(SEND,"EC")
"RTN","HLCSHDR1",78,0)
 S:(EC="") EC="~|\&" S:(FS="") FS="^"
"RTN","HLCSHDR1",79,0)
 ;Determine if it's a response/ACK to another message
"RTN","HLCSHDR1",80,0)
 S ACKTO=+$P(CHILD,U,10)
"RTN","HLCSHDR1",81,0)
 ;subscriber protocol is from child (file 773)
"RTN","HLCSHDR1",82,0)
 ;If response, get MType from subscriber
"RTN","HLCSHDR1",83,0)
 S HLPROTS=+$P(CHILD,U,8)
"RTN","HLCSHDR1",84,0)
 S PROTS=$$TYPE^HLUTIL2(HLPROTS)
"RTN","HLCSHDR1",85,0)
 I ACKTO S MSGTYPE=$P(PROTS,U,10),EVNTYPE=$P(PROTS,U,3),MSGEVN=$P(PROTS,U,4)
"RTN","HLCSHDR1",86,0)
 ;Get accept ack & application ack type (based on server protocol) it
"RTN","HLCSHDR1",87,0)
 ; is always in file 772, TXPT0
"RTN","HLCSHDR1",88,0)
 ;If original message, get MT from Event Driver Protocol
"RTN","HLCSHDR1",89,0)
 S HLPROT=+$P(TXTP0,U,10)
"RTN","HLCSHDR1",90,0)
 S PROT=$$TYPE^HLUTIL2(HLPROT)
"RTN","HLCSHDR1",91,0)
 S:'ACKTO MSGTYPE=$P(PROT,U,2),EVNTYPE=$P(PROT,U,3),MSGEVN=$P(PROT,U,4)
"RTN","HLCSHDR1",92,0)
 S ACCACK=$P(PROT,U,7),APPACK=$P(PROT,U,8)
"RTN","HLCSHDR1",93,0)
PID ;Processing ID
"RTN","HLCSHDR1",94,0)
 ;I PID not 'debug' get from site params
"RTN","HLCSHDR1",95,0)
 ;If event driver set to 'debug' get from protocol
"RTN","HLCSHDR1",96,0)
 ;'production' or 'training' comes from site params
"RTN","HLCSHDR1",97,0)
 S HLPID=$P(PROT,U,5)
"RTN","HLCSHDR1",98,0)
 I $G(HLPID)'="D" S HLPID=$P(HLPARAM,U,3)
"RTN","HLCSHDR1",99,0)
 I $G(HLPID)="" S HLERROR="Missing processing ID Site parameter."
"RTN","HLCSHDR1",100,0)
 ;acknowledgements have no application ack, link open no commit ack
"RTN","HLCSHDR1",101,0)
 I ACKTO S:APPACK]"" APPACK="NE" S:ACCACK]""&$G(HLTCPO) ACCACK="NE"
"RTN","HLCSHDR1",102,0)
 ;Get date/time, Message ID, and security
"RTN","HLCSHDR1",103,0)
 S HLDATE=+TXTP0,HLDATE=$$FMTHL7^XLFDT(HLDATE),HLID=$P(CHILD,U,2),SECURITY=$P(CHILD,U,9)
"RTN","HLCSHDR1",104,0)
HDR23 ;generate extended facility field info based on 'facility required'
"RTN","HLCSHDR1",105,0)
 ;default format is INSTITUTION_HLCS_DOMAIN_HLCS_'DNS'
"RTN","HLCSHDR1",106,0)
 ;application parameter entry overrides default
"RTN","HLCSHDR1",107,0)
 N HLEP773,HLS773
"RTN","HLCSHDR1",108,0)
 S SERFAC=$G(SERFAC),CLNTFAC=$G(CLNTFAC)
"RTN","HLCSHDR1",109,0)
 S HLEP773=+$G(^ORD(101,HLPROTS,773))
"RTN","HLCSHDR1",110,0)
 S HLS773=+$P($G(^ORD(101,HLPROTS,773)),U,2)
"RTN","HLCSHDR1",111,0)
 Q:'HLEP773&('HLS773)
"RTN","HLCSHDR1",112,0)
 D GEN^HLCSHDR2
"RTN","HLCSHDR1",113,0)
 I ACKTO D  Q
"RTN","HLCSHDR1",114,0)
 .;Find original message
"RTN","HLCSHDR1",115,0)
 .S X=$G(^HLMA(ACKTO,"MSH",1,0)) ;Find header in TCP nodes
"RTN","HLCSHDR1",116,0)
 .I X["MSH" D
"RTN","HLCSHDR1",117,0)
 ..S HLFS=$E(X,4)
"RTN","HLCSHDR1",118,0)
 ..S SENDFAC=$P(X,HLFS,4),RECFAC=$P(X,HLFS,6) ;from original msg
"RTN","HLCSHDR1",119,0)
 ..S CLNTFAC=SENDFAC,SERFAC=RECFAC ;reverse facility info
"RTN","HLCSHDR1",120,0)
 I HLEP773,SERFAC="" D EP^HLCSHDR2
"RTN","HLCSHDR1",121,0)
 I HLS773,CLNTFAC="" D S^HLCSHDR2
"RTN","HLCSHDR1",122,0)
 Q
"RTN","HLCSQUE")
0^12^B14643380
"RTN","HLCSQUE",1,0)
HLCSQUE ;ALB/MFK HL7 UTILITY FUNCTIONS - 10/4/94 11AM ;05/08/2000  11:07
"RTN","HLCSQUE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**14,61,59**;Oct 13, 1995
"RTN","HLCSQUE",3,0)
ENQUEUE(IEN,HLDIR) ;Assign a message for queue entry
"RTN","HLCSQUE",4,0)
 ; INPUT: IEN  - Internal Entry Number for file 870 - HL7 QUEUE
"RTN","HLCSQUE",5,0)
 ;        HLDIR  - Direction of queue (IN/OUT)
"RTN","HLCSQUE",6,0)
 ; OUTPUT: BEG - Location in the queue to stuff the message
"RTN","HLCSQUE",7,0)
 ;        -1   - Error
"RTN","HLCSQUE",8,0)
 ; NOTE: All the locks have been commented out.
"RTN","HLCSQUE",9,0)
 N FRONT,BACK,DIC,DA,X,BP,FP,REC,DINUM,ENTRY,Y,RETURN,BPOINTER
"RTN","HLCSQUE",10,0)
 N FPOINTER,HLCNT
"RTN","HLCSQUE",11,0)
 ;  Make sure required variables were given
"RTN","HLCSQUE",12,0)
 S IEN=$G(IEN)
"RTN","HLCSQUE",13,0)
 Q:(IEN="") "-1^Queue not given"
"RTN","HLCSQUE",14,0)
 I +IEN<1 S IEN=$O(^HLCS(870,"B",IEN,""))
"RTN","HLCSQUE",15,0)
 Q:(IEN="") "-1^Invalid queue"
"RTN","HLCSQUE",16,0)
 S HLDIR=$G(HLDIR)
"RTN","HLCSQUE",17,0)
 S HLDIR=$S(HLDIR="1":"IN",HLDIR=2:"OUT",1:HLDIR)
"RTN","HLCSQUE",18,0)
 I HLDIR'="IN",(HLDIR'="OUT") Q "-1^Invalid Direction"
"RTN","HLCSQUE",19,0)
 I HLDIR="IN" S HLDIR=1,BPOINTER="IN QUEUE BACK POINTER",FPOINTER="IN QUEUE FRONT POINTER"
"RTN","HLCSQUE",20,0)
 I HLDIR="OUT" S HLDIR=2,BPOINTER="OUT QUEUE BACK POINTER",FPOINTER="OUT QUEUE FRONT POINTER"
"RTN","HLCSQUE",21,0)
 F  L +^HLCS(870,IEN,FPOINTER):1 Q:$T  H 1
"RTN","HLCSQUE",22,0)
 S FRONT=$G(^HLCS(870,IEN,FPOINTER))
"RTN","HLCSQUE",23,0)
 L -^HLCS(870,IEN,FPOINTER)
"RTN","HLCSQUE",24,0)
 D DELETE^HLCSQUE1(IEN,HLDIR,FRONT)
"RTN","HLCSQUE",25,0)
 F  L +^HLCS(870,IEN,BPOINTER):1 Q:$T  H 1
"RTN","HLCSQUE",26,0)
 S BACK=$G(^HLCS(870,IEN,BPOINTER))
"RTN","HLCSQUE",27,0)
 ; Set up DICN call
"RTN","HLCSQUE",28,0)
 S DIC="^HLCS(870,"_IEN_","_HLDIR_","
"RTN","HLCSQUE",29,0)
 S ENTRY=HLDIR+18
"RTN","HLCSQUE",30,0)
 S DIC(0)="LNX",DA(1)=IEN,DIC("P")=$P(^DD(870,ENTRY,0),"^",2)
"RTN","HLCSQUE",31,0)
 S (DINUM,X)=BACK+1
"RTN","HLCSQUE",32,0)
 ;  Create Record
"RTN","HLCSQUE",33,0)
 K DD,DO
"RTN","HLCSQUE",34,0)
 F  L +^HLCS(870,IEN,HLDIR):1 Q:$T  H 1
"RTN","HLCSQUE",35,0)
 F HLCNT=0:1 D  Q:Y>0  H HLCNT
"RTN","HLCSQUE",36,0)
 . D FILE^DICN
"RTN","HLCSQUE",37,0)
 S REC=$P(Y,"^",1)
"RTN","HLCSQUE",38,0)
 ;  Set the 'status' to 'S' for stub
"RTN","HLCSQUE",39,0)
 S $P(^HLCS(870,IEN,HLDIR,REC,0),"^",2)="S"
"RTN","HLCSQUE",40,0)
 S ^HLCS(870,IEN,BPOINTER)=BACK+1
"RTN","HLCSQUE",41,0)
 ;  Put queue pointers back
"RTN","HLCSQUE",42,0)
 S RETURN=IEN_"^"_REC
"RTN","HLCSQUE",43,0)
EXIT1 ;  Unlock and return results
"RTN","HLCSQUE",44,0)
 L -^HLCS(870,IEN,HLDIR)
"RTN","HLCSQUE",45,0)
 L -^HLCS(870,IEN,BPOINTER)
"RTN","HLCSQUE",46,0)
 K IEN,HLDIR
"RTN","HLCSQUE",47,0)
 Q RETURN
"RTN","HLCSQUE",48,0)
DEQUEUE(IEN,HLDIR) ;Release the next message from the queue
"RTN","HLCSQUE",49,0)
 N MSG,RETURN,FRONT,FP,BACK,POINTER
"RTN","HLCSQUE",50,0)
 S IEN=$G(IEN)
"RTN","HLCSQUE",51,0)
 Q:(IEN="") "-1^Queue not given"
"RTN","HLCSQUE",52,0)
 I +IEN<1 S IEN=$O(^HLCS(870,"B",IEN,""))
"RTN","HLCSQUE",53,0)
 Q:(IEN="") "-1^Invalid queue"
"RTN","HLCSQUE",54,0)
 S HLDIR=$G(HLDIR)
"RTN","HLCSQUE",55,0)
 S HLDIR=$S(HLDIR="1":"IN",HLDIR=2:"OUT",1:HLDIR)
"RTN","HLCSQUE",56,0)
 I HLDIR'="IN",(HLDIR'="OUT") Q "-1^Invalid Direction"
"RTN","HLCSQUE",57,0)
 I HLDIR="IN" S HLDIR=1,POINTER="IN QUEUE FRONT POINTER"
"RTN","HLCSQUE",58,0)
 I HLDIR="OUT" S HLDIR=2,POINTER="OUT QUEUE FRONT POINTER"
"RTN","HLCSQUE",59,0)
 F  L +^HLCS(870,IEN,POINTER):1 Q:$T  H 1
"RTN","HLCSQUE",60,0)
 S FRONT=$G(^HLCS(870,IEN,POINTER))
"RTN","HLCSQUE",61,0)
 L -^HLCS(870,IEN,POINTER)
"RTN","HLCSQUE",62,0)
 D DELETE^HLCSQUE1(IEN,HLDIR,FRONT)
"RTN","HLCSQUE",63,0)
 ;If queue empty or "Stub" record don't dequeue
"RTN","HLCSQUE",64,0)
 F  L +^HLCS(870,IEN,HLDIR,FRONT+1,0):1 Q:$T  H 1
"RTN","HLCSQUE",65,0)
 I '$D(^HLCS(870,IEN,HLDIR,FRONT+1,0)) S RETURN="-1^NO NEXT RECORD" G EXIT2
"RTN","HLCSQUE",66,0)
 I ($P($G(^HLCS(870,IEN,HLDIR,FRONT+1,0)),"^",2)'="P") S RETURN="-1^STUB" G EXIT2
"RTN","HLCSQUE",67,0)
 ; for status "P"
"RTN","HLCSQUE",68,0)
 S ^HLCS(870,IEN,POINTER)=FRONT+1
"RTN","HLCSQUE",69,0)
 S RETURN=IEN_"^"_(FRONT+1)
"RTN","HLCSQUE",70,0)
 ;  Return success
"RTN","HLCSQUE",71,0)
EXIT2 ;
"RTN","HLCSQUE",72,0)
 L -^HLCS(870,IEN,HLDIR,FRONT+1,0)
"RTN","HLCSQUE",73,0)
 L -^HLCS(870,IEN,POINTER)
"RTN","HLCSQUE",74,0)
 Q RETURN
"RTN","HLCSQUE",75,0)
CLEARQUE(IEN,HLDIR) ;Empty an entire queue
"RTN","HLCSQUE",76,0)
 ; IEN - Entry number for queue - can be name from "B" X-ref
"RTN","HLCSQUE",77,0)
 ; HLDIR - Can be "IN", "OUT", 1 or 2.
"RTN","HLCSQUE",78,0)
 ; output: 0 for success
"RTN","HLCSQUE",79,0)
 ;        -1^error for error
"RTN","HLCSQUE",80,0)
 N MSG,X,ERR,FP,BP
"RTN","HLCSQUE",81,0)
 ;NOTE: this is not needed to initialize a queue
"RTN","HLCSQUE",82,0)
 ; enqueue will set up (?) a new queue
"RTN","HLCSQUE",83,0)
 ;  Make sure that required variables exist
"RTN","HLCSQUE",84,0)
 S IEN=$G(IEN)
"RTN","HLCSQUE",85,0)
 Q:(IEN="") "-1^Internal Entry Number missing"
"RTN","HLCSQUE",86,0)
 I +IEN<1 S IEN=$O(^HLCS(870,"B",IEN,""))
"RTN","HLCSQUE",87,0)
 Q:(IEN="") "-1^Invalid IEN"
"RTN","HLCSQUE",88,0)
 ;  Convert direction to a number
"RTN","HLCSQUE",89,0)
 S HLDIR=$G(HLDIR)
"RTN","HLCSQUE",90,0)
 Q:(HLDIR'="IN")&(HLDIR'="OUT")&(HLDIR'=1)&(HLDIR'=2) "-1^Invalid direction"
"RTN","HLCSQUE",91,0)
 S HLDIR=$S(HLDIR="IN":1,HLDIR="OUT":2,HLDIR=2:2,1:1)
"RTN","HLCSQUE",92,0)
 ;  If in queue, set front pointer to 6, out pointer gets set to 8
"RTN","HLCSQUE",93,0)
 I HLDIR=1 S FP="IN QUEUE FRONT POINTER",BP="IN QUEUE BACK POINTER"
"RTN","HLCSQUE",94,0)
 I HLDIR=2 S FP="OUT QUEUE FRONT POINTER",BP="OUT QUEUE BACK POINTER"
"RTN","HLCSQUE",95,0)
 S MSG=0
"RTN","HLCSQUE",96,0)
 W !
"RTN","HLCSQUE",97,0)
 ;  Loop through and delete messages
"RTN","HLCSQUE",98,0)
 F  S MSG=$O(^HLCS(870,IEN,HLDIR,MSG)) Q:(MSG'>0)  D
"RTN","HLCSQUE",99,0)
 .S ERR=$$DELMSG^HLCSQUE1(IEN,HLDIR,MSG) W "."
"RTN","HLCSQUE",100,0)
 .I ERR W ERR,!
"RTN","HLCSQUE",101,0)
 ;  Clear front and back pointers
"RTN","HLCSQUE",102,0)
 S ^HLCS(870,IEN,FP)=0
"RTN","HLCSQUE",103,0)
 S ^HLCS(870,IEN,BP)=0
"RTN","HLCSQUE",104,0)
 ;K IEN,HLDIR
"RTN","HLCSQUE",105,0)
 Q 0
"RTN","HLCSQUE",106,0)
 ;
"RTN","HLCSQUE",107,0)
PUSH(HLDOUT0,HLDOUT1) ;-- Place message back on queue
"RTN","HLCSQUE",108,0)
 ;  INPUT - HLDOUT0 IEN of file 870
"RTN","HLCSQUE",109,0)
 ;          HLDOUT1 IEN of Out Multiple
"RTN","HLCSQUE",110,0)
 ;  OUTPUT- NONE
"RTN","HLCSQUE",111,0)
 ;
"RTN","HLCSQUE",112,0)
 ;-- exit if not vaild variables
"RTN","HLCSQUE",113,0)
 I 'HLDOUT0!'HLDOUT1 G PUSHQ
"RTN","HLCSQUE",114,0)
 ;-- exit if global does not already exist
"RTN","HLCSQUE",115,0)
 I '$D(^HLCS(870,HLDOUT0,"OUT QUEUE FRONT POINTER")) G PUSHQ
"RTN","HLCSQUE",116,0)
 S ^HLCS(870,HLDOUT0,"OUT QUEUE FRONT POINTER")=(HLDOUT1-1)
"RTN","HLCSQUE",117,0)
PUSHQ Q
"RTN","HLCSQUE",118,0)
 ;
"RTN","HLCSQUE1")
0^13^B3409605
"RTN","HLCSQUE1",1,0)
HLCSQUE1 ;ALB/MFK HL7 UTILITY FUNCTIONS - 10/4/94 11AM ;05/08/2000  11:22
"RTN","HLCSQUE1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**14,59**;Oct 13, 1995
"RTN","HLCSQUE1",3,0)
 ;
"RTN","HLCSQUE1",4,0)
 ;Utilities used by HLCSQUE
"RTN","HLCSQUE1",5,0)
 ;
"RTN","HLCSQUE1",6,0)
DELMSG(IEN,HLDIR,MSG) ;DELETE A SINGLE MESSAGE FROM A QUEUE
"RTN","HLCSQUE1",7,0)
 ;INPUT: IEN - Internal Entry Number for queue
"RTN","HLCSQUE1",8,0)
 ;       HLDIR - Direction of queue
"RTN","HLCSQUE1",9,0)
 ;       MSG - Message number to remove
"RTN","HLCSQUE1",10,0)
 ;OUTPUT:  0 - Success
"RTN","HLCSQUE1",11,0)
 ;        -1 - Error
"RTN","HLCSQUE1",12,0)
 N DIK,DA
"RTN","HLCSQUE1",13,0)
 ;  Check for required variables
"RTN","HLCSQUE1",14,0)
 S IEN=$G(IEN)
"RTN","HLCSQUE1",15,0)
 Q:(IEN="") "-1^Internal Entry Number missing"
"RTN","HLCSQUE1",16,0)
 I +IEN<1 S IEN=$O(^HLCS(870,"B",IEN,""))
"RTN","HLCSQUE1",17,0)
 Q:(IEN="") "-1^Invalid IEN"
"RTN","HLCSQUE1",18,0)
 S HLDIR=$G(HLDIR)
"RTN","HLCSQUE1",19,0)
 S HLDIR=$S(HLDIR="IN":1,HLDIR="OUT":2,HLDIR=2:2,HLDIR=1:1,1:"")
"RTN","HLCSQUE1",20,0)
 Q:(HLDIR="") "-1^Invalid direction"
"RTN","HLCSQUE1",21,0)
 S MSG=$G(MSG)
"RTN","HLCSQUE1",22,0)
 Q:(MSG="") "-1^No message number"
"RTN","HLCSQUE1",23,0)
 L +^HLCS(870,IEN,HLDIR,MSG):1
"RTN","HLCSQUE1",24,0)
 ;If lock fails, another process is doing the work.
"RTN","HLCSQUE1",25,0)
 I '$T Q 1
"RTN","HLCSQUE1",26,0)
 S DIK="^HLCS(870,"_IEN_","_HLDIR_",",DA(1)=IEN,DA=MSG
"RTN","HLCSQUE1",27,0)
 D ^DIK
"RTN","HLCSQUE1",28,0)
 L -^HLCS(870,IEN,HLDIR,MSG)
"RTN","HLCSQUE1",29,0)
 K IEN,HLDIR,MSG
"RTN","HLCSQUE1",30,0)
 Q 0
"RTN","HLCSQUE1",31,0)
DELETE(IEN,HLDIR,FRONT) ;  Delete messages outside the 'queue size' window
"RTN","HLCSQUE1",32,0)
 N MSG,TMP,QSIZE,STOP,HLX
"RTN","HLCSQUE1",33,0)
 ;  Make sure required variables exist
"RTN","HLCSQUE1",34,0)
 S IEN=$G(IEN) Q:(IEN="")
"RTN","HLCSQUE1",35,0)
 S HLDIR=$G(HLDIR) Q:(HLDIR="")
"RTN","HLCSQUE1",36,0)
 S FRONT=$G(FRONT) Q:(FRONT="")
"RTN","HLCSQUE1",37,0)
 S TMP=^HLCS(870,IEN,0)
"RTN","HLCSQUE1",38,0)
 S QSIZE=$P(TMP,"^",21)
"RTN","HLCSQUE1",39,0)
 I FRONT'>0 Q
"RTN","HLCSQUE1",40,0)
 I QSIZE'>0 S QSIZE=10
"RTN","HLCSQUE1",41,0)
 S MSG=0,STOP=0
"RTN","HLCSQUE1",42,0)
 ;  For each message from the beginning of the queue to the front
"RTN","HLCSQUE1",43,0)
 ;  of the queue-queue size, delete that message if it's done
"RTN","HLCSQUE1",44,0)
 F  S MSG=$O(^HLCS(870,IEN,HLDIR,MSG)) Q:(MSG>(FRONT-QSIZE))!(STOP'=0)!(MSG'>0)  D
"RTN","HLCSQUE1",45,0)
 .I $P($G(^HLCS(870,IEN,HLDIR,MSG,0)),"^",2)'="D" D  Q:STOP
"RTN","HLCSQUE1",46,0)
 ..I $D(^HLCS(870,IEN,HLDIR,MSG)) S HLX=$O(^HLCS(870,IEN,HLDIR,MSG))
"RTN","HLCSQUE1",47,0)
 ..Q:$P($G(^HLCS(870,IEN,HLDIR,HLX,0)),U,2)="D"
"RTN","HLCSQUE1",48,0)
 ..S STOP=1
"RTN","HLCSQUE1",49,0)
 .S STOP=$$DELMSG(IEN,HLDIR,MSG)
"RTN","HLCSQUE1",50,0)
 K IEN,HLDIR,FRONT
"RTN","HLCSQUE1",51,0)
 Q
"RTN","HLFNC2")
0^3^B11462998
"RTN","HLFNC2",1,0)
HLFNC2 ;AISC/SAW-Continuation of HLFNC, Additional Functions/Calls Used for HL7 Messages ;01/19/2000  16:30
"RTN","HLFNC2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**2,26,57,59**;Oct 13, 1995
"RTN","HLFNC2",3,0)
INIT(EID,HL,INT) ;Initialize Variables in HL array for Building a Message
"RTN","HLFNC2",4,0)
 ;
"RTN","HLFNC2",5,0)
 ;This is a subroutine call with parameter passing that returns an
"RTN","HLFNC2",6,0)
 ;array of values in the variable specified by the parameter HL.  If no
"RTN","HLFNC2",7,0)
 ;error occurs, the array of values is returned.  Otherwise, the single
"RTN","HLFNC2",8,0)
 ;value HL is returned equal to the following:  error code^error message
"RTN","HLFNC2",9,0)
 ;
"RTN","HLFNC2",10,0)
 ;Required Input Parameters
"RTN","HLFNC2",11,0)
 ;    EID = Name or IEN of the event driver or subscriber protocol in
"RTN","HLFNC2",12,0)
 ;            Protocol file for which the initialization variables are
"RTN","HLFNC2",13,0)
 ;            to be returned
"RTN","HLFNC2",14,0)
 ;     HL = The variable in which the array of values will be returned
"RTN","HLFNC2",15,0)
 ;            This parameter must be passed by reference
"RTN","HLFNC2",16,0)
 ;Optional Input Parameter
"RTN","HLFNC2",17,0)
 ;    INT = 1 indicates that only array values for internal DHCP
"RTN","HLFNC2",18,0)
 ;            to DHCP message exchange should be initialized
"RTN","HLFNC2",19,0)
 ;
"RTN","HLFNC2",20,0)
 ;Check for required input parameter
"RTN","HLFNC2",21,0)
 I $G(EID)="" S HL="7^Missing EID Input Parameter" Q
"RTN","HLFNC2",22,0)
 I '$D(INT) S INT=0
"RTN","HLFNC2",23,0)
 ;Convert EID to IEN if necessary
"RTN","HLFNC2",24,0)
 I 'EID S EID=$O(^ORD(101,"B",EID,0)) I 'EID S HL="1^"_$G(^HL(771.7,1,0)) Q
"RTN","HLFNC2",25,0)
 N X0,X,X1,X2
"RTN","HLFNC2",26,0)
 ;Get node 770 from file 101 and node 0 from file 771
"RTN","HLFNC2",27,0)
 S X0=$G(^ORD(101,EID,0))
"RTN","HLFNC2",28,0)
 ;if server application is disabled quit
"RTN","HLFNC2",29,0)
 I $P(X0,U,3)]"" S HL="16^"_$G(^HL(771.7,16,0)) Q
"RTN","HLFNC2",30,0)
 ;if no known clients, set error but allow app to continue
"RTN","HLFNC2",31,0)
 I '$D(^ORD(101,EID,775,"B")) S HL="15^"_$G(^HL(771.7,15,0))
"RTN","HLFNC2",32,0)
 S X=$G(^ORD(101,EID,770)),X1=$G(^HL(771,+X,0))
"RTN","HLFNC2",33,0)
 I X1']"" S HL="14^"_$G(^HL(771.7,14,0)) Q
"RTN","HLFNC2",34,0)
 ;Set HL array variables
"RTN","HLFNC2",35,0)
 S HL("Q")="""""",HL("FS")=$G(^HL(771,+X,"FS")),HL("ECH")=$G(^("EC")) S:HL("FS")']"" HL("FS")="^" S:HL("ECH")']"" HL("ECH")="~|\&"
"RTN","HLFNC2",36,0)
 S HL("SAN")=$P(X1,"^"),HL("SAF")=$P(X1,"^",3) S:$P(X1,"^",7) HL("CC")=$P($G(^HL(779.004,$P(X1,"^",7),0)),"^")
"RTN","HLFNC2",37,0)
 S HL("MTN")=$P($G(^HL(771.2,+$P(X,"^",3),0)),"^"),HL("ETN")=$P($G(^HL(779.001,+$P(X,"^",4),0)),"^")
"RTN","HLFNC2",38,0)
 S:$P(X,"^",5) HL("MTN_ETN")=$P($G(^HL(779.005,+$P(X,"^",5),0)),"^")
"RTN","HLFNC2",39,0)
 S HL("PID")=$TR($P(X,"^",6),"dtp","DTP"),HL("VER")=$P($G(^HL(771.5,+$P(X,"^",10),0)),"^")
"RTN","HLFNC2",40,0)
 S:$P(X,"^",9) HL("APAT")=$P($G(^HL(779.003,$P(X,"^",9),0)),"^")
"RTN","HLFNC2",41,0)
 I 'INT S:$P(X,"^",8) HL("ACAT")=$P($G(^HL(779.003,$P(X,"^",8),0)),"^")
"RTN","HLFNC2",42,0)
 ;-- Set variables for backwards compatablity
"RTN","HLFNC2",43,0)
 S HLQ=HL("Q"),HLFS=HL("FS"),HLECH=HL("ECH")
"RTN","HLFNC2",44,0)
 Q
"RTN","HLFNC2",45,0)
MSH(HL,MID,RESULT,SECURITY) ;Create an MSH Segment for an Outgoing HL7
"RTN","HLFNC2",46,0)
 ;Message
"RTN","HLFNC2",47,0)
 ;
"RTN","HLFNC2",48,0)
 ;This is a subroutine call with parameter passing that returns an HL7
"RTN","HLFNC2",49,0)
 ;Message Header (MSH) segment in the variable RESULT (and possibly
"RTN","HLFNC2",50,0)
 ;RESULT(1) if the MSH segment is longer than 245 characters).  If the
"RTN","HLFNC2",51,0)
 ;required input parameters HL or MID are missing, RESULT is returned
"RTN","HLFNC2",52,0)
 ;equal to null
"RTN","HLFNC2",53,0)
 ;
"RTN","HLFNC2",54,0)
 ;Required Input Parameters
"RTN","HLFNC2",55,0)
 ;      HL = The array of values returned by the call to INIT^HLFNC2
"RTN","HLFNC2",56,0)
 ;     MID = The Message Control ID to be included in the MSH segment.
"RTN","HLFNC2",57,0)
 ;             The Batch Control ID for the batch is returned by the
"RTN","HLFNC2",58,0)
 ;             call to CREATE^HLTF.  The application concatenates a
"RTN","HLFNC2",59,0)
 ;             sequential number to the batch ID to create the MID
"RTN","HLFNC2",60,0)
 ;  RESULT = The variable that will be returned to the calling
"RTN","HLFNC2",61,0)
 ;             application as described above
"RTN","HLFNC2",62,0)
 ;Optional Input Parameter
"RTN","HLFNC2",63,0)
 ;SECURITY = Security to be included in field #8 of the MSH segment
"RTN","HLFNC2",64,0)
 ;
"RTN","HLFNC2",65,0)
 ;Check for required parameters
"RTN","HLFNC2",66,0)
 I '$D(HL)#2!('$D(MID)) Q ""
"RTN","HLFNC2",67,0)
 N X,X1,X2
"RTN","HLFNC2",68,0)
 ;Build MSH segment from HL array variables and other input parameters
"RTN","HLFNC2",69,0)
 S X="MSH"_HL("FS")_HL("ECH")_HL("FS")_HL("SAN")_HL("FS")_HL("SAF")_HL("FS")_$S($D(HL("RAN")):HL("RAN"),1:"")_HL("FS")_$S($D(HL("RAF")):HL("RAF"),1:"")_HL("FS")_$S($D(HL("DTM")):HL("DTM"),1:"")_HL("FS")
"RTN","HLFNC2",70,0)
 S X=X_$S($G(SECURITY)]"":SECURITY,1:"")_HL("FS")_HL("MTN")_$E(HL("ECH"))_HL("ETN")
"RTN","HLFNC2",71,0)
 ;Message structure component for HL7 v 2.3.1 and beyond
"RTN","HLFNC2",72,0)
 S:$D(HL("MTN_ETN")) X=X_$E(HL("ECH"))_HL("MTN_ETN")
"RTN","HLFNC2",73,0)
 S X=X_HL("FS")_MID_HL("FS")_HL("PID")_HL("FS")_HL("VER")
"RTN","HLFNC2",74,0)
 S:$D(HL("SN")) $P(X,HL("FS"),13)=HL("SN") S:$D(HL("ACAT")) $P(X,HL("FS"),15)=HL("ACAT") S:$D(HL("APAT")) $P(X,HL("FS"),16)=HL("APAT") S:$D(HL("CC")) $P(X,HL("FS"),17)=HL("CC")
"RTN","HLFNC2",75,0)
 ;If continuation pointer variable exists, insert it in piece 14 and
"RTN","HLFNC2",76,0)
 ;create new variable X1 if length of X will be greater than 245
"RTN","HLFNC2",77,0)
 I $D(HL("CP")) D
"RTN","HLFNC2",78,0)
 .I $L(X)+$L(HL("CP"))+2'>245 S $P(X,HL("FS"),14)=HL("CP") Q
"RTN","HLFNC2",79,0)
 .S $P(X,HL("FS"),14)="",X1=HL("FS")_$P(X,HL("FS"),15,17),X=$P(X,HL("FS"),1,14)
"RTN","HLFNC2",80,0)
 .S X2=$L(X),X=X_$E(HL("CP"),1,(245-X2)),X1=$E(HL("CP"),(246-X2),245)_X1
"RTN","HLFNC2",81,0)
 .S X2=$L(X) I $L(X2)<245 S X=X_$E(X1,1,(245-X2)),X1=$E(X1,(246-X2),245)
"RTN","HLFNC2",82,0)
 S RESULT=X S:$L($G(X1)) RESULT(1)=X1
"RTN","HLFNC2",83,0)
 Q
"RTN","HLSUB")
0^14^B18399859
"RTN","HLSUB",1,0)
HLSUB ;IRMFO-SF/JC - Subscription Registry ;05/23/2000  10:57
"RTN","HLSUB",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**14,57,58,59**;Jan 29, 1997
"RTN","HLSUB",3,0)
ACT() ;Activate a new subscription
"RTN","HLSUB",4,0)
 ;Returns new file 774 ien (Subscription Control number)
"RTN","HLSUB",5,0)
 ;Returns -1 if error
"RTN","HLSUB",6,0)
 N C,X,DLAYGO,DIC,DA,DR S C=0,X=-1
"RTN","HLSUB",7,0)
LK ;
"RTN","HLSUB",8,0)
 I C>600 Q +X
"RTN","HLSUB",9,0)
 L +^HLS(774,0):1 I '$T S C=C+1 G LK
"RTN","HLSUB",10,0)
 S DLAYGO=774,X=$O(^HLS(774,"B"),-1),X=X+1,DIC=774,DIC(0)="L" D ^DIC
"RTN","HLSUB",11,0)
 L -^HLS(774,0)
"RTN","HLSUB",12,0)
 Q +Y
"RTN","HLSUB",13,0)
UPD(HLSCN,HLNN,HLTP,HLAD,HLTD,HLRAP,HLER,HLAPP,HLDESC) ;Subscription update
"RTN","HLSUB",14,0)
 ;HLSCN - Subscription Control number, required
"RTN","HLSUB",15,0)
 ;HLNN - Network node (HL7 1.6 Logical Link NAME)
"RTN","HLSUB",16,0)
 ;note: HLNN is required if receiving application is not supplied. A
"RTN","HLSUB",17,0)
 ;     logical link without a receiving app assumes the application
"RTN","HLSUB",18,0)
 ;     will submit the client protocol name in the call to GET^HLSUB.
"RTN","HLSUB",19,0)
 ;     The presence of a receiving app assumes patch 45 is installed
"RTN","HLSUB",20,0)
 ;HLTP - Subscription type 
"RTN","HLSUB",21,0)
 ;	0 descriptive updates only
"RTN","HLSUB",22,0)
 ; 	1 activates clinical updates
"RTN","HLSUB",23,0)
 ;	2 other (locally defined)
"RTN","HLSUB",24,0)
 ;HLTD - Termination date/time, optional, 'null'=open-ended
"RTN","HLSUB",25,0)
 ;HLAD - Activation date; optional, default 'now'
"RTN","HLSUB",26,0)
 ;HLRAP - Receiving Application,optional
"RTN","HLSUB",27,0)
 ;HLER - Error message array passed by reference
"RTN","HLSUB",28,0)
 ;patch 57:HLAPP - Optional, application that created the subscription record
"RTN","HLSUB",29,0)
 ;patch 57:HLDESC - Optional, description/documentation, ie, file and record that points to this subscription.
"RTN","HLSUB",30,0)
 ;patch 57:logical link required
"RTN","HLSUB",31,0)
 ;modification of existing entry triggers archive of previous record
"RTN","HLSUB",32,0)
 ;dates must be external DHCP format
"RTN","HLSUB",33,0)
 K HLER
"RTN","HLSUB",34,0)
 I $G(HLSCN)="" S HLER(1)="Missing subscription control number"
"RTN","HLSUB",35,0)
 I $G(HLNN)="" S HLER(2)="Missing logical link."
"RTN","HLSUB",36,0)
 I $G(HLRAP)=""&($G(HLNN)="") S HLER(7)="Missing both Link and Receiving Application-could not add"
"RTN","HLSUB",37,0)
 Q:$D(HLER)
"RTN","HLSUB",38,0)
 S HLTP=+$G(HLTP)
"RTN","HLSUB",39,0)
 S HLCD=$$FMTE^XLFDT($$NOW^XLFDT) ;Creation date
"RTN","HLSUB",40,0)
 I $G(HLAD)="" S HLAD=HLCD ;Activation date
"RTN","HLSUB",41,0)
 I '$D(^HLS(774,HLSCN)) S HLER(4)="Invalid Subscription Control number"
"RTN","HLSUB",42,0)
 Q:$D(HLER)
"RTN","HLSUB",43,0)
 I $G(HLNN)>0 S HLNN=$P($G(^HLCS(870,HLNN,0)),U) D
"RTN","HLSUB",44,0)
 .I $G(HLNN)="" S HLER(5)="Invalid Logical Link"
"RTN","HLSUB",45,0)
 I $G(HLNN)]"" I $O(^HLCS(870,"B",HLNN,0))<1 S HLER(5)="Invalid logical link"
"RTN","HLSUB",46,0)
 I $G(HLRAP)'<1 S HLRAP=$P($G(^HL(771,HLRAP,0)),U) I $G(HLRAP)="" S HLER(6)="Invalid receiving application."
"RTN","HLSUB",47,0)
 I $G(HLAPP)]""!($G(HLDESC))]"" D
"RTN","HLSUB",48,0)
 .I $G(HLAPP)]"" S $P(^HLS(774,HLSCN,0),U,2)=HLAPP
"RTN","HLSUB",49,0)
 .I $G(HLDESC)]"" S ^HLS(774,HLSCN,1)=HLDESC
"RTN","HLSUB",50,0)
 S C=0
"RTN","HLSUB",51,0)
ADD ;Lookup and add subscriber (logical link)
"RTN","HLSUB",52,0)
 L +^HLS(774,HLSCN):1 I '$T S C=C+1 Q:C>600  G ADD
"RTN","HLSUB",53,0)
 K DIC,DA,DR,Y
"RTN","HLSUB",54,0)
 S DLAYGO=774
"RTN","HLSUB",55,0)
 S DA(1)=HLSCN,DIC="^HLS(774,DA(1),"_"""TO"""_",",DIC("P")=$P(^DD(774,1,0),U,2)
"RTN","HLSUB",56,0)
 S X=$G(HLRAP)
"RTN","HLSUB",57,0)
 I $G(HLNN)]"" S X=X_"@"_$G(HLNN)
"RTN","HLSUB",58,0)
 I X="" L -^HLS(774,HLSCN) Q
"RTN","HLSUB",59,0)
 S DIC(0)="LMZ" D ^DIC
"RTN","HLSUB",60,0)
 I Y<1 L -^HLS(774,HLSCN) Q
"RTN","HLSUB",61,0)
 S HLINKIEN=+Y,HLINK0=Y(0)
"RTN","HLSUB",62,0)
 ;If Updating existing record-archive old record
"RTN","HLSUB",63,0)
 I $P(HLINK0,U,2)]"" D
"RTN","HLSUB",64,0)
 .K DIC,DIE,DA,DR,Y
"RTN","HLSUB",65,0)
 .N CD,AD,TD
"RTN","HLSUB",66,0)
 .S CD=$P(HLINK0,U,6),AD=$P(HLINK0,U,7),TD=$P(HLINK0,U,8)
"RTN","HLSUB",67,0)
 .S CD=$$FMTE^XLFDT(CD),AD=$$FMTE^XLFDT(AD) I TD]"" S TD=$$FMTE^XLFDT(TD)
"RTN","HLSUB",68,0)
 .S DA(2)=HLSCN,DA(1)=HLINKIEN,X=$$FMTE^XLFDT($$NOW^XLFDT)
"RTN","HLSUB",69,0)
 .S DIC="^HLS(774,DA(2),"_"""TO"""_",DA(1),"_"""HX"""_","
"RTN","HLSUB",70,0)
 .S DIC("DR")="1///^S X=CD;2///^S X=AD;4///^S X=$P(HLINK0,U,5)"
"RTN","HLSUB",71,0)
 .I TD]"" S DIC("DR")=DIC("DR")_";3///^S X=TD"
"RTN","HLSUB",72,0)
 .S DLAYGO=774,DIC(0)="L",DIC("P")=$P(^DD(774.01,8,0),U,2)
"RTN","HLSUB",73,0)
 .D ^DIC
"RTN","HLSUB",74,0)
 .K DIC,DIE,DA,DR,Y
"RTN","HLSUB",75,0)
A1 ;bring in update
"RTN","HLSUB",76,0)
 K DIC,DIE,DA,DR,Y
"RTN","HLSUB",77,0)
 S DA(1)=HLSCN,DA=HLINKIEN,DIE="^HLS(774,DA(1),"_"""TO"""_","
"RTN","HLSUB",78,0)
 I $G(HLNN)]"" S DR="3///^S X=HLNN"
"RTN","HLSUB",79,0)
 I $G(DR)]"" S DR=DR_";"
"RTN","HLSUB",80,0)
 S DR=$G(DR)_"4///^S X=HLTP;5///^S X=HLCD;6///^S X=HLAD"
"RTN","HLSUB",81,0)
 I $G(HLRAP)]"" S DR=DR_";1///^S X=HLRAP"
"RTN","HLSUB",82,0)
 I $G(HLTD)]"",HLTD'["@" S HLTD=HLTD_"@0001"
"RTN","HLSUB",83,0)
 I $G(HLTD)=$G(HL("Q")),$P(HLINK0,U,8)]"" S HLTD="@" ;remove termination date
"RTN","HLSUB",84,0)
 I $G(HLTD)]"" S DR=DR_";7///^S X=HLTD"
"RTN","HLSUB",85,0)
 D ^DIE
"RTN","HLSUB",86,0)
 K DIE,DA,DR,Y
"RTN","HLSUB",87,0)
 L -^HLS(774,HLSCN)
"RTN","HLSUB",88,0)
 Q
"RTN","HLSUB",89,0)
GET(HLSCN,HLTP,HLCL,HLL) ;Return active subscribers
"RTN","HLSUB",90,0)
 ;Called by a HL7 ROUTING protocol to return array of subscribers
"RTN","HLSUB",91,0)
 ;Make separate call for each 'type' specified EXCEPT TYPE 0
"RTN","HLSUB",92,0)
 ;type 0 returns both '0' and '1' subscribers 
"RTN","HLSUB",93,0)
 ;HLSCN=SUBSCRIPTION CONTROL NUMBER
"RTN","HLSUB",94,0)
 ;HLTP=SUBSCRIBER TYPE (0,1,2)/Null=all
"RTN","HLSUB",95,0)
 ;HLCL=HL7 CLIENT PROTOCOL
"RTN","HLSUB",96,0)
 ;HLL=HLL("LINKS",x)=CLIENT PROTOCOL^LOGICAL LINK (passed by reference)
"RTN","HLSUB",97,0)
 ;If the client protocol is not passed in, piece three will be checked
"RTN","HLSUB",98,0)
 ;for a complete destination reference. The destination is of the format
"RTN","HLSUB",99,0)
 ;RECEIVING APPLICATION@LOGICAL LINK. When a valid destination is present
"RTN","HLSUB",100,0)
 ;it will be used for populating the message header and routing.
"RTN","HLSUB",101,0)
 ;The HLL("LINKS") array is required by the HL7 package for routing
"RTN","HLSUB",102,0)
 N X,I,J,HLINK,HLND Q:'$D(^HLS(774,HLSCN))
"RTN","HLSUB",103,0)
 Q:$G(^HLS(774,HLSCN,0))<1
"RTN","HLSUB",104,0)
 S HLCL=$G(HLCL)
"RTN","HLSUB",105,0)
 I HLCL]"" S DIC=101,DIC(0)="X",X=HLCL D ^DIC Q:+Y<1  K DIC
"RTN","HLSUB",106,0)
 S X="",HLTP=$G(HLTP)
"RTN","HLSUB",107,0)
 I $D(HLL("LINKS")) S X=$O(HLL("LINKS",X),-1)
"RTN","HLSUB",108,0)
 S HLDT=$$NOW^XLFDT
"RTN","HLSUB",109,0)
 Q:'$D(^HLS(774,HLSCN,"TO"))
"RTN","HLSUB",110,0)
 S HLND=$NA(^HLS(774,HLSCN,"TO")),I=0 F  S I=$O(@HLND@(I)) Q:I<1  S J=$G(^(I,0)) D
"RTN","HLSUB",111,0)
 .I HLTP'=""&(HLTP'=0) Q:$P(J,U,5)'=HLTP  ;type specified
"RTN","HLSUB",112,0)
 .I HLTP=0 Q:$P(J,U,5)>1  ;return clinical and descriptive
"RTN","HLSUB",113,0)
 .Q:$P(J,U,7)>HLDT  ;Activation date is later
"RTN","HLSUB",114,0)
 .I $P(J,U,8)]"" Q:$P(J,U,8)<HLDT  ;Subscription terminated
"RTN","HLSUB",115,0)
 .S (HLINKX,HLINKP)=$P(J,U,4)
"RTN","HLSUB",116,0)
 .I HLINKP S HLINKX=$P(^HLCS(870,HLINKP,0),U)
"RTN","HLSUB",117,0)
 .S X=X+1,HLL("LINKS",X)=HLCL_U_HLINKX_U_$P(J,U,1,99)
"RTN","HLSUB",118,0)
 Q
"RTN","HLTP3")
0^11^B55897763
"RTN","HLTP3",1,0)
HLTP3 ;SFIRMFO/RSD - Transaction Processor for TCP ;03/07/2000  18:26
"RTN","HLTP3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,58,59**;Oct 13, 1995
"RTN","HLTP3",3,0)
 ;
"RTN","HLTP3",4,0)
 Q
"RTN","HLTP3",5,0)
NEW(X) ;process new msg. ien in 773^msg. ien in 772
"RTN","HLTP3",6,0)
 ;HLMTIENS=ien in #773, msg header; HLMTIEN=ien in #772, msg text
"RTN","HLTP3",7,0)
 ;HLHDRO=original header;  HLHDR=response header
"RTN","HLTP3",8,0)
 ;set error trap
"RTN","HLTP3",9,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP3",10,0)
 N HL,HLERR,HLHDR,HLHDRO,HLMTIEN,HLMTIENS,HLJ,HLMSA,HLQUIT,HLNODE,HLNEXT,HLRESLTA,HLDONE1,HLASTRSP
"RTN","HLTP3",11,0)
 D INIT
"RTN","HLTP3",12,0)
 ;error with header, return commit/app reject
"RTN","HLTP3",13,0)
 I $G(HLRESLT) D  Q
"RTN","HLTP3",14,0)
 . ;set status & unlock record
"RTN","HLTP3",15,0)
 . D STATUS^HLTF0(HLMTIENS,4,,,1),EXIT
"RTN","HLTP3",16,0)
 . ;quit if no commit or app ack
"RTN","HLTP3",17,0)
 . I $G(HL("ACAT"))="NE",$G(HL("APAT"))="NE" Q
"RTN","HLTP3",18,0)
 . S X=$S($G(HL("ACAT"))="AL":"CR",1:"AR")
"RTN","HLTP3",19,0)
 . ;HLTCP=ien of acknowledgment msg. from ACK^HLTP4
"RTN","HLTP3",20,0)
 . D ACK^HLTP4(X,$P(HLRESLT,U,2)) Q:'$G(HLTCP)
"RTN","HLTP3",21,0)
 . ;update counter, msg. to send
"RTN","HLTP3",22,0)
 . D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",23,0)
 . ;write ack back over connection
"RTN","HLTP3",24,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",25,0)
 . ;update counter to sent
"RTN","HLTP3",26,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",27,0)
 . ;update status of ack to complete
"RTN","HLTP3",28,0)
 . D STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",29,0)
 ;
"RTN","HLTP3",30,0)
 ;check for duplicate msg., use rec. app and msg. id x-ref
"RTN","HLTP3",31,0)
 I $G(HL("MID")),$G(HL("RAP")) S X=$O(^HLMA("AH",HL("RAP"),HL("MID"),0)) D  Q:'$D(HLMTIENS)
"RTN","HLTP3",32,0)
 . ;HLASTMSG=last ien received during this connection
"RTN","HLTP3",33,0)
 . ;if no duplicate, save msg. ien and quit
"RTN","HLTP3",34,0)
 . I X=HLMTIENS!'X S HLASTMSG=HLMTIENS Q
"RTN","HLTP3",35,0)
 . N MSH,OIENS
"RTN","HLTP3",36,0)
 . S (OIENS,Y)=X D  S Y=HLMTIENS D
"RTN","HLTP3",37,0)
 .. ;combine MSH into single string
"RTN","HLTP3",38,0)
 .. S MSH(Y)="",I=0 F  S I=$O(^HLMA(Y,"MSH",I)) Q:'I  S MSH(Y)=MSH(Y)_$G(^(I,0))
"RTN","HLTP3",39,0)
 . ;if MSH is not identical, then msg. are different, quit
"RTN","HLTP3",40,0)
 . I MSH(HLMTIENS)'=MSH(OIENS) S HLASTMSG=HLMTIENS Q
"RTN","HLTP3",41,0)
 . ;msg is duplicate, set status as duplicate
"RTN","HLTP3",42,0)
 . D STATUS^HLTF0(HLMTIENS,4,109,"Duplicate with ien "_OIENS,1),EXIT
"RTN","HLTP3",43,0)
 . ;msg was resent during this connection, ignore it.
"RTN","HLTP3",44,0)
 . I HLASTMSG=HLMTIENS K HLMTIENS Q
"RTN","HLTP3",45,0)
 . ;msg was resent during another connection
"RTN","HLTP3",46,0)
 . ;if status of original msg wasn't success then process msg, quit
"RTN","HLTP3",47,0)
 . Q:+$G(^HLMA(OIENS,"P"))'=3
"RTN","HLTP3",48,0)
 . ;find original response and send back
"RTN","HLTP3",49,0)
 . S HLASTRSP=$O(^HLMA("AF",OIENS,OIENS))
"RTN","HLTP3",50,0)
 ;
"RTN","HLTP3",51,0)
 ;Quit if this is acknowledgment to acknowledgement message
"RTN","HLTP3",52,0)
 I $G(HL("ACK")) D  Q
"RTN","HLTP3",53,0)
 . ;Update status of original acknowledgment message to successfully
"RTN","HLTP3",54,0)
 . D STATUS^HLTF0(HL("MTIENS"),3,,,1),STATUS^HLTF0(HLMTIENS,3,,,1)
"RTN","HLTP3",55,0)
 . ;unlock record
"RTN","HLTP3",56,0)
 . D EXIT
"RTN","HLTP3",57,0)
 ;
"RTN","HLTP3",58,0)
 ;enhance ack., send commit, quit if not an ack, msg will be processed by filer
"RTN","HLTP3",59,0)
 I $G(HL("ACAT"))="AL" D  Q:'$G(HL("MTIENS"))
"RTN","HLTP3",60,0)
 . ;msg is a resend, HLASTRSP=ien of original response
"RTN","HLTP3",61,0)
 . I $G(HLASTRSP) S HLTCP=HLASTRSP
"RTN","HLTP3",62,0)
 . E  D ACK^HLTP4("CA") Q:'$G(HLTCP)
"RTN","HLTP3",63,0)
 . D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",64,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",65,0)
 . D LLCNT^HLCSTCP(HLDP,4),STATUS^HLTF0(HLTCP,3,,,1):'$G(HLASTRSP)
"RTN","HLTP3",66,0)
 . S HLTCP=""
"RTN","HLTP3",67,0)
 . ;if not an ack, set status to awaiting processing & unlock
"RTN","HLTP3",68,0)
 . I '$G(HL("MTIENS")) D STATUS^HLTF0(HLMTIENS,9),EXIT
"RTN","HLTP3",69,0)
 ;
"RTN","HLTP3",70,0)
 ;enhance ack., no commit & no app ack
"RTN","HLTP3",71,0)
 I $G(HL("ACAT"))="NE",$G(HL("APAT"))="NE" D  Q
"RTN","HLTP3",72,0)
 . ;set status to awaiting processing & unlock
"RTN","HLTP3",73,0)
 . I '$G(HLASTRSP) D STATUS^HLTF0(HLMTIENS,9),EXIT
"RTN","HLTP3",74,0)
 ;resending old response, msg is a resend
"RTN","HLTP3",75,0)
 I $G(HLASTRSP) S HLTCP=HLASTRSP G ACK
"RTN","HLTP3",76,0)
CONT ;continue processing an enhance ack msg. called from DEFACK
"RTN","HLTP3",77,0)
 ;Set special HL variables for processing rtn
"RTN","HLTP3",78,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLTP3",79,0)
 ;
"RTN","HLTP3",80,0)
 ; message is an acknowledgement, HLMSA=ack code^id^text
"RTN","HLTP3",81,0)
 I ($G(HLMSA)]"") D  Q
"RTN","HLTP3",82,0)
 . ;X=1 if ack ok, 0=reject of error
"RTN","HLTP3",83,0)
 . S X=$E(HLMSA,2)="A"
"RTN","HLTP3",84,0)
 . ;Update status of original subscriber message
"RTN","HLTP3",85,0)
 . D STATUS^HLTF0(HL("MTIENS"),$S(X:3,1:4),"",$S(X:"",1:$P(HLMSA,HL("FS"),3)),1)
"RTN","HLTP3",86,0)
 . D PROCACK^HLTP2(HLMTIEN,HL("EID"),.HLRESLT,.HL)
"RTN","HLTP3",87,0)
 . ;update status of incoming to complete & unlock
"RTN","HLTP3",88,0)
 . D STATUS^HLTF0(HLMTIENS,$S($G(HLRESLT):4,1:3),$S($G(HLRESLT):+$G(HLRESLT),1:""),$S($G(HLRESLT):$P(HLRESLT,U,2),1:""),1),EXIT
"RTN","HLTP3",89,0)
 ;
"RTN","HLTP3",90,0)
 ;get entry action, exit action and processing routine
"RTN","HLTP3",91,0)
 K HLHDR,HLLD0,HLLD1,HLMSA
"RTN","HLTP3",92,0)
 I HL("EIDS")="",$G(HLEIDS)]"" S HL("EIDS")=HLEIDS ;**CIRN**
"RTN","HLTP3",93,0)
 D EVENT^HLUTIL1(HL("EIDS"),"15,20,771",.HLN)
"RTN","HLTP3",94,0)
 S HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15)),HLPROU=$G(HLN(771))
"RTN","HLTP3",95,0)
 ;quit if no processing routine,update status and quit
"RTN","HLTP3",96,0)
 I HLPROU']"" S HLRESLT="10^"_$G(^HL(771.7,10,0)) D STATUS^HLTF0(HLMTIENS,3,,,1),EXIT Q
"RTN","HLTP3",97,0)
 ;HLORNOD=subscriber protocol for Fileman auditing, ien;global ref
"RTN","HLTP3",98,0)
 N HLORNODD S HLORNOD=HL("EIDS")_";ORD(101,"
"RTN","HLTP3",99,0)
 ;Execute entry action of client protocol
"RTN","HLTP3",100,0)
 X:HLENROU]"" HLENROU K HLENROU,HLDONE1
"RTN","HLTP3",101,0)
 ;
"RTN","HLTP3",102,0)
 ;Execute processing routine
"RTN","HLTP3",103,0)
 X HLPROU S HLRESLT=0 S:($D(HLERR)) HLRESLT="9^"_HLERR
"RTN","HLTP3",104,0)
 ;update status of incoming to complete & unlock
"RTN","HLTP3",105,0)
 D STATUS^HLTF0(HLMTIENS,$S(HLRESLT:4,1:3),$S(HLRESLT:+HLRESLT,1:""),$S(HLRESLT:$P(HLRESLT,U,2),1:""),1),EXIT
"RTN","HLTP3",106,0)
 ;HLTCPO=link open, HLTCP=ien of acknowledgment msg. from GENACK
"RTN","HLTP3",107,0)
ACK I $G(HLTCPO),$G(HLTCP) D  Q
"RTN","HLTP3",108,0)
 . D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",109,0)
 . ;write ack back over open tcp link
"RTN","HLTP3",110,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",111,0)
 . ;update status of ack to complete
"RTN","HLTP3",112,0)
 . D:'$G(HLASTRSP) STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",113,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",114,0)
 Q
"RTN","HLTP3",115,0)
 ;
"RTN","HLTP3",116,0)
DEFACK(HLDP,X) ;process the deferred application ack, called from HLCSIN
"RTN","HLTP3",117,0)
 ;HLDP=logical link, X=ien in file 773
"RTN","HLTP3",118,0)
 ;set error trap
"RTN","HLTP3",119,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP3",120,0)
 Q:'$G(HLDP)!'$G(X)  Q:'$G(^HLMA(X,0))
"RTN","HLTP3",121,0)
 ;try lock, quit if can't lock or x-ref is gone
"RTN","HLTP3",122,0)
 L +^HLMA(X):1 Q:'$T  I '$D(^HLMA("AC","I",HLDP,X)) L -^HLMA(X) Q
"RTN","HLTP3",123,0)
 N HL,HLA,HLD0,HLHDR,HLHDRO,HLMTIEN,HLMTIENS,HLJ,HLMSA,HLN,HLQUIT,HLNODE,HLNEXT,HLRESLT,HLRESLTA,HLTCP,HLXX,Z,HLDONE1
"RTN","HLTP3",124,0)
 ;setup variables
"RTN","HLTP3",125,0)
 S HLMTIENS=X,X=^HLMA(HLMTIENS,0),HLMTIEN=+$P(X,U),HL("MID")=$P(X,U,2),HL("MTIENS")=$P(X,U,10),HL("LL")=$P(X,U,7),HLTCP="",HL("Q")=""""""
"RTN","HLTP3",126,0)
 S HL("EIDS")=$P(X,U,8),HL("SAP")=$P(X,U,11),HL("RAP")=$P(X,U,12),HL("MTP")=$P(X,U,13),HL("ETP")=$P(X,U,14)
"RTN","HLTP3",127,0)
 S:$P(X,U,15) HL("MTP_ETP")=$P(X,U,15)
"RTN","HLTP3",128,0)
 S:HL("SAP") HL("SAN")=$P($G(^HL(771,HL("SAP"),0)),U) S:HL("RAP") HL("RAN")=$P($G(^HL(771,HL("RAP"),0)),U)
"RTN","HLTP3",129,0)
 S:HL("MTP") HL("MTN")=$P($G(^HL(771.2,HL("MTP"),0)),U) S:HL("ETP") HL("ETN")=$P($G(^HL(779.001,HL("ETP"),0)),U)
"RTN","HLTP3",130,0)
 S:$G(HL("MTP_ETP")) HL("MTN_ETN")=$P($G(^HL(779.005,HL("MTP_ETP"),0)),U)
"RTN","HLTP3",131,0)
 S HL("EID")=$P($G(^HL(772,HLMTIEN,0)),U,10)
"RTN","HLTP3",132,0)
 M HLHDRO=^HLMA(HLMTIENS,"MSH")
"RTN","HLTP3",133,0)
 ;if no header kill x-ref and quit
"RTN","HLTP3",134,0)
 I '$O(HLHDRO(0)) K ^HLMA("AC","I",HLDP,HLMTIENS) L -^HLMA(HLMTIENS) Q
"RTN","HLTP3",135,0)
 S HL("FS")=$E(HLHDRO(1,0),4),HL("ECH")=$$P^HLTPCK2(.HLHDRO,2),HL("SFN")=$$P^HLTPCK2(.HLHDRO,4),HL("RFN")=$$P^HLTPCK2(.HLHDRO,6),HL("DTM")=$$P^HLTPCK2(.HLHDRO,7)
"RTN","HLTP3",136,0)
 S X=$$P^HLTPCK2(.HLHDRO,1)
"RTN","HLTP3",137,0)
 I X="MSH" S HL("PID")=$$P^HLTPCK2(.HLHDRO,11),HL("VER")=$$P^HLTPCK2(.HLHDRO,12),HL("APAT")=$$P^HLTPCK2(.HLHDRO,16),HL("CC")=$$P^HLTPCK2(.HLHDRO,17)
"RTN","HLTP3",138,0)
 I X'="MSH" D
"RTN","HLTP3",139,0)
 . S X=$$P^HLTPCK2(.HLHDRO,9),Z=$E(HL("ECH")),HL("PID")=$P(X,Z,2),HL("VER")=$P(X,Z,4)
"RTN","HLTP3",140,0)
 . Q:$$P^HLTPCK2(.HLHDRO,10)=""
"RTN","HLTP3",141,0)
 . ;HLMSA=ack code^id^text
"RTN","HLTP3",142,0)
 . S HLMSA=$P($$P^HLTPCK2(.HLHDRO,10),$E(HL("ECH")),1),$P(HLMSA,HL("FS"),2)=$$P^HLTPCK2(.HLHDRO,12),$P(HLMSA,HL("FS"),3)=$P($$P^HLTPCK2(.HLHDRO,10),$E(HL("ECH")),2),HL("MSAID")=$P(HLMSA,HL("FS"),2)
"RTN","HLTP3",143,0)
 ;Set up destination for 2-phase commit
"RTN","HLTP3",144,0)
 ;If facility data didn't come from 771
"RTN","HLTP3",145,0)
 I $G(HL("SAP")) D
"RTN","HLTP3",146,0)
 .N HLSF,HLINST,HLLINK
"RTN","HLTP3",147,0)
 .S HLSF=$P(^HL(771,HL("SAP"),0),U,3)
"RTN","HLTP3",148,0)
 .Q:HLSF]""  ;application-defined facility
"RTN","HLTP3",149,0)
 .S HLINST=+HL("SFN") Q:'HLINST
"RTN","HLTP3",150,0)
 .D LINK^HLUTIL3(HLINST,.HLI,"I") S HLLINK=$O(HLI(0)) Q:'HLLINK
"RTN","HLTP3",151,0)
 .S HLL("LINKS",1)="^"_HLLINK
"RTN","HLTP3",152,0)
 D CONT
"RTN","HLTP3",153,0)
 Q
"RTN","HLTP3",154,0)
 ;
"RTN","HLTP3",155,0)
MSA(Y) ;Y=ien in 772, returns MSA segment
"RTN","HLTP3",156,0)
 ;ack code^msg being ack id^text
"RTN","HLTP3",157,0)
 N X
"RTN","HLTP3",158,0)
 S X=$G(^HL(772,Y,"IN",1,0)),X=$S($E(X,1,3)="MSA":$E(X,5,999),1:"")
"RTN","HLTP3",159,0)
 Q X
"RTN","HLTP3",160,0)
 ;
"RTN","HLTP3",161,0)
INIT ;initialize variables, get MSA & header, returns HLRESLT if error
"RTN","HLTP3",162,0)
 N HLJ
"RTN","HLTP3",163,0)
 K HLRESLT,HL
"RTN","HLTP3",164,0)
 S HLMTIENS=+X,HLMTIEN=+$P(X,U,2),HLMSA=$$MSA(HLMTIEN)
"RTN","HLTP3",165,0)
 F  L +^HLMA(HLMTIENS):1 Q:$T  H 1
"RTN","HLTP3",166,0)
 ;get header and validate
"RTN","HLTP3",167,0)
 M HLHDRO=^HLMA(HLMTIENS,"MSH")
"RTN","HLTP3",168,0)
 ;HLMSA is by ref., for a batch msg HLMSA will be setup in HLTPCK2
"RTN","HLTP3",169,0)
 D CHK^HLTPCK2(.HLHDRO,.HL,.HLMSA)
"RTN","HLTP3",170,0)
 ;Update Message Administration file #773, for incoming message
"RTN","HLTP3",171,0)
 ;3=trans type, 20=status
"RTN","HLTP3",172,0)
 S X="HLJ(773,"""_HLMTIENS_","")",@X@(3)="I",@X@(20)=9
"RTN","HLTP3",173,0)
 ;HL=error #^error text, 21=date process, 22=error msg, 23=error type
"RTN","HLTP3",174,0)
 S:$G(HL) @X@(20)=4,@X@(21)=$$NOW^XLFDT,@X@(22)=$P(HL,U,2),@X@(23)=+HL
"RTN","HLTP3",175,0)
 ;8=protocol, 13=sending app
"RTN","HLTP3",176,0)
 S:$G(HL("EIDS")) @X@(8)=HL("EIDS") S:$G(HL("SAP")) @X@(13)=HL("SAP")
"RTN","HLTP3",177,0)
 ;14=receiving app, 12=acknowledgement to
"RTN","HLTP3",178,0)
 S:$G(HL("RAP")) @X@(14)=HL("RAP") S:$G(HL("MTIENS")) @X@(12)=HL("MTIENS")
"RTN","HLTP3",179,0)
 ;6=initial message, 7=logical link
"RTN","HLTP3",180,0)
 S:$G(HLTCPI) @X@(6)=HLTCPI S @X@(7)=HLDP
"RTN","HLTP3",181,0)
 ;15=message type, 16=event type
"RTN","HLTP3",182,0)
 S:$G(HL("MTP")) @X@(15)=HL("MTP") S:$G(HL("ETP")) @X@(16)=HL("ETP")
"RTN","HLTP3",183,0)
 S:$G(HL("MTP_ETP")) @X@(17)=HL("MTP_ETP")
"RTN","HLTP3",184,0)
 D FILE^DIE("","HLJ")
"RTN","HLTP3",185,0)
 ;Update Message Text file #772
"RTN","HLTP3",186,0)
 ;4=trans type
"RTN","HLTP3",187,0)
 K HLJ S X="HLJ(772,"""_HLMTIEN_","")",@X@(4)="I"
"RTN","HLTP3",188,0)
 ;10=event protocol
"RTN","HLTP3",189,0)
 S:$G(HL("EID")) @X@(10)=HL("EID")
"RTN","HLTP3",190,0)
 D FILE^DIE("","HLJ")
"RTN","HLTP3",191,0)
 ;set HLRESLT to error
"RTN","HLTP3",192,0)
 S:HL'="" HLRESLT=HL
"RTN","HLTP3",193,0)
 Q
"RTN","HLTP3",194,0)
ERROR ;error trap
"RTN","HLTP3",195,0)
 D ^%ZTER
"RTN","HLTP3",196,0)
 I $G(HLMTIENS),$D(^HLMA(HLMTIENS,0)) D STATUS^HLTF0(HLMTIENS,4,,,1),EXIT
"RTN","HLTP3",197,0)
 G UNWIND^%ZTER
"RTN","HLTP3",198,0)
 ;
"RTN","HLTP3",199,0)
EXIT ;unlock
"RTN","HLTP3",200,0)
 I $G(HLMTIENS) L -^HLMA(HLMTIENS)
"RTN","HLTP3",201,0)
 Q
"RTN","HLTP4")
0^4^B21895753
"RTN","HLTP4",1,0)
HLTP4 ;SFIRMFO/RSD - Transaction Processor for TCP ;03/07/2000  17:41
"RTN","HLTP4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,57,59**;Oct 13, 1995
"RTN","HLTP4",3,0)
GENACK ;called from HLMA1
"RTN","HLTP4",4,0)
 ;Entry point to generate an acknowledgement message
"RTN","HLTP4",5,0)
 ;for TCP
"RTN","HLTP4",6,0)
 ;INPUT:
"RTN","HLTP4",7,0)
 ;   HLMTIENS=original msg. ien #773
"RTN","HLTP4",8,0)
 ;   HLEID=original msg. event protocol
"RTN","HLTP4",9,0)
 ;   HLEIDS=original msg. subscriber protocol
"RTN","HLTP4",10,0)
 ;   HLMTIENA=ien of ack in 772, for batch only
"RTN","HLTP4",11,0)
 ;OUTPUT: HLTCP=ien of response
"RTN","HLTP4",12,0)
 N HLDT,HLDT1,HLQ,HLOGLINK,HLMIDA,HLMTIEN,HLREC,HLSAN,HLTYPE,X
"RTN","HLTP4",13,0)
 ;Extract data from original message and store in separate variables
"RTN","HLTP4",14,0)
 ;reverse sending and receiving application from original msg.
"RTN","HLTP4",15,0)
 S X=$G(^HLMA(HLMTIENS,0)),HLREC=$P(X,U,11),HLSAN=$P(X,U,12),HLOGLINK=$G(HLTCPO)
"RTN","HLTP4",16,0)
 ;HLMTIENA defined, create msg in 773
"RTN","HLTP4",17,0)
 I $G(HLMTIENA) S HLDT=+$G(^HL(772,HLMTIENA,0)),HLMTIENA=$$MA^HLTF(HLMTIENA,.HLMIDA)
"RTN","HLTP4",18,0)
 ;create message in 772 & 773, HLMTIENA=new msg ien #773
"RTN","HLTP4",19,0)
 I '$G(HLMTIENA) D TCP^HLTF(.HLMIDA,.HLMTIENA,.HLDT)
"RTN","HLTP4",20,0)
 ;lock new record
"RTN","HLTP4",21,0)
 F  L +^HLMA(HLMTIENA):1 Q:$T  H 1
"RTN","HLTP4",22,0)
 ;HLMTIEN=ien in 772
"RTN","HLTP4",23,0)
 S HLTCP=HLMTIENA,HLMTIEN=+^HLMA(HLMTIENA,0),HLDT1=$$HLDATE^HLFNC(HLDT),(HLTYPE,HLP("MSGTYPE"))=$E(HLARYTYP,2)
"RTN","HLTP4",24,0)
 ;no open link, check dynamic routing of ack
"RTN","HLTP4",25,0)
 I 'HLOGLINK,$D(HLL("LINKS")) D  Q:'HLOGLINK
"RTN","HLTP4",26,0)
 . S HLOGLINK=$P(HLL("LINKS",1),"^",2) Q:HLOGLINK=""
"RTN","HLTP4",27,0)
 . I +HLOGLINK'=HLOGLINK S HLOGLINK=$O(^HLCS(870,"B",HLOGLINK,0))
"RTN","HLTP4",28,0)
 . K HLL("LINKS")
"RTN","HLTP4",29,0)
 ;get message type and event type from protocol
"RTN","HLTP4",30,0)
 S X=$G(^ORD(101,HLEIDS,770)),HLP("MTYPE")=$P(X,U,11),HLP("EVENT")=$P(X,U,4) S:'HLOGLINK HLOGLINK=$P(X,U,7)
"RTN","HLTP4",31,0)
 S:$P(X,U,5) HLP("MTYPE_EVENT")=$P(X,U,5)
"RTN","HLTP4",32,0)
 ;HLTCPI=initial message
"RTN","HLTP4",33,0)
 S:$G(HLTCPI) HLP("HLTCPI")=HLTCPI
"RTN","HLTP4",34,0)
 ;Update zero node of Message Admin file #773
"RTN","HLTP4",35,0)
 D UPDATE^HLTF0(HLTCP,,"O",HLEIDS,HLREC,HLSAN,"I",HLMTIENS,HLOGLINK,.HLP)
"RTN","HLTP4",36,0)
 ;tcp link is open, don't need x-ref, msg will be sent over link
"RTN","HLTP4",37,0)
 I $G(HLTCPO) K ^HLMA("AC","O",HLOGLINK,HLTCP)
"RTN","HLTP4",38,0)
 ;Update status to Being Generated
"RTN","HLTP4",39,0)
 D STATUS^HLTF0(HLTCP,8)
"RTN","HLTP4",40,0)
 ;update zero node of Message Text file #772
"RTN","HLTP4",41,0)
 D
"RTN","HLTP4",42,0)
 . N HLTCP D UPDATE^HLTF0(HLMTIEN,,"O",HLEID)
"RTN","HLTP4",43,0)
 ;
"RTN","HLTP4",44,0)
 ;Execute entry action for subscriber protocol
"RTN","HLTP4",45,0)
 I HLENROU]"" X HLENROU
"RTN","HLTP4",46,0)
 S HLQ=""""
"RTN","HLTP4",47,0)
 ;Check that local/global array exists and store in Message Text file
"RTN","HLTP4",48,0)
 ; if pre-compiled
"RTN","HLTP4",49,0)
 I HLFORMAT D  I (+$G(HLRESLTA)) D STATUS^HLTF0(HLMTIENA,4,+HLRESLTA) G ERR
"RTN","HLTP4",50,0)
 . I $E(HLARYTYP)="G" D
"RTN","HLTP4",51,0)
 .. I $O(^TMP("HLA",$J,0))']"" S HLRESLTA="8^"_$G(^HL(771.7,8,0)) Q
"RTN","HLTP4",52,0)
 .. D MERGE^HLTF1("G",HLMTIEN,"HLA")
"RTN","HLTP4",53,0)
 . I $E(HLARYTYP)="L" D
"RTN","HLTP4",54,0)
 .. I $O(HLA("HLA",0))']"" S HLRESLTA="8^"_$G(^HL(771.7,8,0)) Q
"RTN","HLTP4",55,0)
 .. D MERGE^HLTF1("L",HLMTIEN,"HLA")
"RTN","HLTP4",56,0)
 ;If array is not pre-compiled, call message generation routine
"RTN","HLTP4",57,0)
 I 'HLFORMAT N HLERR D  I $D(HLERR) S HLRESLTA="9^"_HLERR D STATUS^HLTF0(HLMTIENA,4,9,HLERR) G ERR
"RTN","HLTP4",58,0)
 .S HLP("GROUTINE")=HLP("GROUTINE")_"("_HLMIDA_","_HLMTIENA_","_HLQ_HLARYTYP_HLQ_","_HLSAN_","_$P($G(^HL(771.2,$P(HLN(770),"^",3),0)),"^")_","_$P($G(^HL(779.001,$P(HLN(770),"^",4),0)),"^")_","_HLQ_$TR($P(HLN(770),"^",6),"id","ID")_HLQ_")"
"RTN","HLTP4",59,0)
 .X HLP("GROUTINE")
"RTN","HLTP4",60,0)
 ;
"RTN","HLTP4",61,0)
 ;create header for message in 773
"RTN","HLTP4",62,0)
 I (HLTYPE="M") D HEADER^HLCSHDR1(HLTCP,HLREC,.HLRESLT)
"RTN","HLTP4",63,0)
 I (HLTYPE'="M") D BHSHDR^HLCSHDR1(HLTCP,HLREC,.HLRESLT)
"RTN","HLTP4",64,0)
 ;if error set status to ERROR DURING TRANSMISSION
"RTN","HLTP4",65,0)
 I ($G(HLRESLT)'="") D STATUS^HLTF0(HLTCP,4,12,HLRESLT) G ERR
"RTN","HLTP4",66,0)
 ;set header, HLHDR in 773
"RTN","HLTP4",67,0)
 K HLQ S X=HLTCP_",",HLQ(773,X,200)="HLHDR"
"RTN","HLTP4",68,0)
 D FILE^DIE("","HLQ")
"RTN","HLTP4",69,0)
 ;update status of 773 to PENDING TRANSMISSION
"RTN","HLTP4",70,0)
 D STATUS^HLTF0(HLTCP,1)
"RTN","HLTP4",71,0)
 ;Execute exit action for subscriber protocol
"RTN","HLTP4",72,0)
 X:HLEXROU]"" HLEXROU
"RTN","HLTP4",73,0)
EXIT L -^HLMA(HLMTIENA)
"RTN","HLTP4",74,0)
 Q
"RTN","HLTP4",75,0)
ERR D EXIT S HLTCP=""
"RTN","HLTP4",76,0)
 S:$G(HLRESLT) HLRESLTA=$G(HLRESLTA)_"^"_HLRESLT
"RTN","HLTP4",77,0)
 Q
"RTN","HLTP4",78,0)
ACK(HLTACK,HLMG) ;build response based on original msg header
"RTN","HLTP4",79,0)
 ;for Bi-directional TCP
"RTN","HLTP4",80,0)
 ;INPUT:
"RTN","HLTP4",81,0)
 ;   HLTACK=type of ack. CA,CR, or AR
"RTN","HLTP4",82,0)
 ;   HLMG=text for MSA segment
"RTN","HLTP4",83,0)
 ;   HLMTIENS=original msg. ien #773
"RTN","HLTP4",84,0)
 ;   HL(array) from original header
"RTN","HLTP4",85,0)
 ;RETURNS:  HLTCP=ien of response msg. in 773
"RTN","HLTP4",86,0)
 N HLDT,HLDT1,HLQ,HLFS,HLHDR,HLMIDA,HLMTIEN,HLMTIENA,HLP,HLREC,HLSAN,X
"RTN","HLTP4",87,0)
 ;quit if we don't have enough to make a msg.
"RTN","HLTP4",88,0)
 I $G(HL("ECH"))=""!($G(HL("FS"))="")!($G(HL("TYPE"))="") Q
"RTN","HLTP4",89,0)
 ;Extract data from original message and store in separate variables
"RTN","HLTP4",90,0)
 ;reverse sending and receiving application from original msg.
"RTN","HLTP4",91,0)
 S HLFS=HL("FS"),HLREC=$G(HL("SAN")),HLSAN=$G(HL("RAN"))
"RTN","HLTP4",92,0)
 ;create message in 772 & 773, HLMTIENA=new msg ien #773
"RTN","HLTP4",93,0)
 D TCP^HLTF(.HLMIDA,.HLMTIENA,.HLDT)
"RTN","HLTP4",94,0)
 ;lock new record
"RTN","HLTP4",95,0)
 F  L +^HLMA(HLMTIENA):1 Q:$T  H 1
"RTN","HLTP4",96,0)
 ;HLMTIEN=ien in 772
"RTN","HLTP4",97,0)
 S HLTCP=HLMTIENA,HLMTIEN=+^HLMA(HLMTIENA,0),HLDT1=$$FMTHL7^XLFDT(HLDT)
"RTN","HLTP4",98,0)
 ;get 'msgtype'=B or M, message type and event type
"RTN","HLTP4",99,0)
 S HLP("MSGTYPE")=$E(HL("TYPE")),HLP("MTYPE")=$G(HL("MTP")),HLP("EVENT")=$G(HL("ETP")),HLP("HLTCPI")=HLMTIENS
"RTN","HLTP4",100,0)
 S:$G(HL("MTP_ETP")) HLP("MTYPE_EVENT")=$G(HL("MTP_ETP"))
"RTN","HLTP4",101,0)
 ;Update zero node of Message Admin file #773
"RTN","HLTP4",102,0)
 D UPDATE^HLTF0(HLTCP,,"O",,HLREC,HLSAN,"I",HLMTIENS,HLDP,.HLP)
"RTN","HLTP4",103,0)
 ;don't need x-ref, msg will be sent back over open tcp link
"RTN","HLTP4",104,0)
 K ^HLMA("AC","O",HLDP,HLTCP)
"RTN","HLTP4",105,0)
 ;Update status to Being Generated
"RTN","HLTP4",106,0)
 D STATUS^HLTF0(HLTCP,8)
"RTN","HLTP4",107,0)
 ;update zero node of Message Text file #772
"RTN","HLTP4",108,0)
 D
"RTN","HLTP4",109,0)
 . N HLTCP D UPDATE^HLTF0(HLMTIEN,,"O")
"RTN","HLTP4",110,0)
 ;
"RTN","HLTP4",111,0)
 ;build MSA segment
"RTN","HLTP4",112,0)
 K HLA
"RTN","HLTP4",113,0)
 S HLA("HLS",1)="MSA"_HLFS_HLTACK_HLFS_$G(HL("MID"))
"RTN","HLTP4",114,0)
 S:$G(HLMG)]"" HLA("HLS",1)=HLA("HLS",1)_HLFS_HLMG
"RTN","HLTP4",115,0)
 ;update file 772 with msg text
"RTN","HLTP4",116,0)
 D MERGE^HLTF1("L",HLMTIEN,"HLS")
"RTN","HLTP4",117,0)
 D HDR
"RTN","HLTP4",118,0)
 ;update file 773 with msg header
"RTN","HLTP4",119,0)
 K HLQ S HLQ(773,HLTCP_",",200)="HLHDR"
"RTN","HLTP4",120,0)
 D FILE^DIE("","HLQ")
"RTN","HLTP4",121,0)
 G EXIT
"RTN","HLTP4",122,0)
 ;
"RTN","HLTP4",123,0)
HDR ; build header for commit ack
"RTN","HLTP4",124,0)
 K HLHDR
"RTN","HLTP4",125,0)
 S HLHDR(1)=HL("TYPE")_HLFS_HL("ECH")_HLFS_HLSAN_HLFS_$G(HL("RFN"))_HLFS_HLREC_HLFS_$G(HL("SFN"))_HLFS_HLDT1_HLFS_HLFS
"RTN","HLTP4",126,0)
 I HLP("MSGTYPE")="M" S HLHDR(1)=HLHDR(1)_"ACK"_HLFS_HLMIDA_HLFS_$G(HL("PID"))_HLFS_$G(HL("VER")) Q
"RTN","HLTP4",127,0)
 ;batch
"RTN","HLTP4",128,0)
 S X=$E(HL("ECH"))
"RTN","HLTP4",129,0)
 S HLHDR(1)=HLHDR(1)_X_$G(HL("PID"))_X_"ACK"_HLFS_HLTACK_HLFS_HLMIDA_HLFS_$G(HL("MID"))
"RTN","HLTP4",130,0)
 Q
"RTN","HLTPCK1")
0^8^B7916664
"RTN","HLTPCK1",1,0)
HLTPCK1 ;AISC/SAW-Message Header Validation Routine for HL7 ;03/08/2000  09:09
"RTN","HLTPCK1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**8,36,59**;Oct 13, 1995
"RTN","HLTPCK1",3,0)
CHK(HDR,ARY,MSA) ;Validate Data in Header Segment (MSH, BHS or FHS) of
"RTN","HLTPCK1",4,0)
 ;an HL7 Message
"RTN","HLTPCK1",5,0)
 ;
"RTN","HLTPCK1",6,0)
 ;This entry point is a subroutine call with parameter passing that
"RTN","HLTPCK1",7,0)
 ;will return an array (ARY()) consisting of values extracted from
"RTN","HLTPCK1",8,0)
 ;the message header segment subscripted by the mnemonics for each of
"RTN","HLTPCK1",9,0)
 ;the message header fields and components
"RTN","HLTPCK1",10,0)
 ;If an error is encountered during validation, the array parameter
"RTN","HLTPCK1",11,0)
 ;(ARY) will be set equal to two pieces, error #^error text and the
"RTN","HLTPCK1",12,0)
 ;rest of the array will not be returned
"RTN","HLTPCK1",13,0)
 ;
"RTN","HLTPCK1",14,0)
 ;Required input parameters
"RTN","HLTPCK1",15,0)
 ;  HDR = Message header segment
"RTN","HLTPCK1",16,0)
 ;Note:  The ARY parameter must be passed by reference
"RTN","HLTPCK1",17,0)
 ;  ARY = The array in which the message header values will be
"RTN","HLTPCK1",18,0)
 ;          returned
"RTN","HLTPCK1",19,0)
 ;Optional input parameter
"RTN","HLTPCK1",20,0)
 ;  MSA = A variable which contains the message acknowledgement values:
"RTN","HLTPCK1",21,0)
 ;          acknowledgement code^message control ID^text message
"RTN","HLTPCK1",22,0)
 ;
"RTN","HLTPCK1",23,0)
 ;Check for required parameters
"RTN","HLTPCK1",24,0)
 N ERR S ERR=""
"RTN","HLTPCK1",25,0)
 I $G(HDR)']"" S ERR="7^"_$G(^HL(771.7,7,0))_" at CHK^HLTPCK1 entry point" G EXIT
"RTN","HLTPCK1",26,0)
 N ECH,HLN,FS,X,X1,X2
"RTN","HLTPCK1",27,0)
 S ARY="",ARY("Q")=""""""
"RTN","HLTPCK1",28,0)
 ;
"RTN","HLTPCK1",29,0)
 ;Validate field separator and encoding characters
"RTN","HLTPCK1",30,0)
 S (ARY("FS"),FS)=$E(HDR,4)
"RTN","HLTPCK1",31,0)
 I FS']"" S ERR="Field Separator Missing" G EXIT
"RTN","HLTPCK1",32,0)
 I FS?.C S ERR="Invalid Field Separator" G EXIT
"RTN","HLTPCK1",33,0)
 S (ARY("ECH"),ECH)=$P(HDR,FS,2)
"RTN","HLTPCK1",34,0)
 I ECH']"" S ERR="Encoding Characters Missing" G EXIT
"RTN","HLTPCK1",35,0)
 I ECH?.C S ERR="Invalid Encoding Characters" G EXIT
"RTN","HLTPCK1",36,0)
 ;
"RTN","HLTPCK1",37,0)
 ;Validate Message Header Type
"RTN","HLTPCK1",38,0)
 I "FHS,BHS,MSH"'[$E(HDR,1,3) S ERR="Invalid Message Header Segment" G EXIT
"RTN","HLTPCK1",39,0)
 ;
"RTN","HLTPCK1",40,0)
 ;Extract data from message header segment
"RTN","HLTPCK1",41,0)
 I $E(HDR,1,3)="BHS"!($E(HDR,1,3)="FHS") D
"RTN","HLTPCK1",42,0)
 .S ARY("DTM")=$P(HDR,FS,7),ARY("MID")=$P(HDR,FS,11),X=$P(HDR,FS,9),ARY("PID")=$P(X,$E(ECH),2),ARY("MTN")=$P($P(X,$E(ECH),3),$E(ECH,2)),ARY("ETN")=$P($P(X,$E(ECH),3),$E(ECH,2),2),ARY("VER")=$P(X,$E(ECH),4)
"RTN","HLTPCK1",43,0)
 .;S:$P(HDR,FS,10)]"" MSA=$P(HDR,FS,10),$P(MSA,$E(ECH),2)=$P(HDR,FS,12)
"RTN","HLTPCK1",44,0)
 .S:$P(HDR,FS,10)]"" MSA=$P($P(HDR,FS,10),$E(ECH),1),$P(MSA,FS,2)=$P(HDR,FS,12),$P(MSA,FS,3)=$P($P(HDR,FS,10),$E(ECH),2)
"RTN","HLTPCK1",45,0)
 I $E(HDR,1,3)="MSH" D
"RTN","HLTPCK1",46,0)
 .S ARY("DTM")=$P(HDR,FS,7),ARY("MID")=$P(HDR,FS,10),ARY("PID")=$P(HDR,FS,11),ARY("MTN")=$P($P(HDR,FS,9),$E(ECH)),ARY("ETN")=$P($P(HDR,FS,9),$E(ECH),2),ARY("VER")=$P(HDR,FS,12)
"RTN","HLTPCK1",47,0)
 .S:$P($P(HDR,FS,9),$E(ECH),3)]"" ARY("MTN_ETN")=$P($P(HDR,FS,9),$E(ECH),3)
"RTN","HLTPCK1",48,0)
 .S:$P(HDR,FS,15)]"" ARY("ACAT")=$P(HDR,FS,15) S:$P(HDR,FS,16)]"" ARY("APAT")=$P(HDR,FS,16) S:$P(HDR,FS,17)]"" ARY("CC")=$P(HDR,FS,17)
"RTN","HLTPCK1",49,0)
 K:$G(MSA)']"" MSA
"RTN","HLTPCK1",50,0)
 ;
"RTN","HLTPCK1",51,0)
 ;Invoke continuation routine to perform remaining validation checks
"RTN","HLTPCK1",52,0)
 D ^HLTPCK1A
"RTN","HLTPCK1",53,0)
 ;
"RTN","HLTPCK1",54,0)
EXIT I ERR]"" S ARY=$S('ERR:"13^"_ERR,1:ERR)
"RTN","HLTPCK1",55,0)
 Q
"RTN","HLTPCK1A")
0^5^B55955952
"RTN","HLTPCK1A",1,0)
HLTPCK1A ;SAW/AISC-Message Header Validation Routine for HL7 (Con't) ;03/08/2000  09:53
"RTN","HLTPCK1A",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**2,25,34,57,59**;Oct 13, 1995
"RTN","HLTPCK1A",3,0)
 S ERR=""
"RTN","HLTPCK1A",4,0)
SP ;Get local site parameters
"RTN","HLTPCK1A",5,0)
 S HLPARAM=$$PARAM^HLCS2,HLDOM=$P(HLPARAM,U,2),HLINSTN=$P(HLPARAM,U,6)
"RTN","HLTPCK1A",6,0)
MT ;Validate message type
"RTN","HLTPCK1A",7,0)
 I (ARY("MTN")="") S:(ERR="") ERR="Invalid Message Type" Q
"RTN","HLTPCK1A",8,0)
 S ARY("MTP")=0
"RTN","HLTPCK1A",9,0)
 S:(ARY("MTN")'="") ARY("MTP")=+$O(^HL(771.2,"B",ARY("MTN"),0))
"RTN","HLTPCK1A",10,0)
 I ('ARY("MTP")) S:(ERR="") ERR="Invalid Message Type" Q
"RTN","HLTPCK1A",11,0)
 ;
"RTN","HLTPCK1A",12,0)
AT ;Determine if message is an acknowledgement type
"RTN","HLTPCK1A",13,0)
 I (("ACK,ADR,MCF,MFK,MFR,ORF,ORR,RRA,RRD,RRE,RRG,TBR"[ARY("MTN"))&($G(MSA)="")) S:(ERR="") ERR="MSA Segment Missing" Q
"RTN","HLTPCK1A",14,0)
 ;
"RTN","HLTPCK1A",15,0)
AAT ;Validate accept ack type and application ack type
"RTN","HLTPCK1A",16,0)
 I ($G(ARY("ACAT"))'="") I ("AL,NE,ER,SU"'[ARY("ACAT")) S:(ERR="") ERR="Invalid accept ack type" Q
"RTN","HLTPCK1A",17,0)
 I ($G(ARY("APAT"))'="") I ("AL,NE,ER,SU"'[ARY("APAT")) S:(ERR="") ERR="Invalid application ack type" Q
"RTN","HLTPCK1A",18,0)
 ;
"RTN","HLTPCK1A",19,0)
RA ;Validate receiving application
"RTN","HLTPCK1A",20,0)
 S ARY("RAN")=$P(HDR,FS,5)
"RTN","HLTPCK1A",21,0)
 I (ARY("RAN")="") S:(ERR="") ERR="Invalid Receiving Application" Q
"RTN","HLTPCK1A",22,0)
 S ARY("RAP")=0
"RTN","HLTPCK1A",23,0)
 S:(ARY("RAN")'="") ARY("RAP")=+$O(^HL(771,"B",ARY("RAN"),0))
"RTN","HLTPCK1A",24,0)
 I (('ARY("RAP"))&(ARY("RAN")'="")) D
"RTN","HLTPCK1A",25,0)
 .S X=$$UPPER^HLFNC(ARY("RAN"))
"RTN","HLTPCK1A",26,0)
 .S ARY("RAP")=+$O(^HL(771,"B",ARY("RAN"),0))
"RTN","HLTPCK1A",27,0)
 I ('ARY("RAP")) S:(ERR="") ERR="Invalid Receiving Application" Q
"RTN","HLTPCK1A",28,0)
 S X2=$G(^HL(771,ARY("RAP"),0))
"RTN","HLTPCK1A",29,0)
 I (X2="") S:(ERR="") ERR="Invalid Receiving Application" Q
"RTN","HLTPCK1A",30,0)
 I ($P(X2,"^",2)'="a") S:(ERR="") ERR="Receiving Application is Inactive" Q
"RTN","HLTPCK1A",31,0)
 ;
"RTN","HLTPCK1A",32,0)
SA ;Validate sending application
"RTN","HLTPCK1A",33,0)
 S ARY("SAN")=$P(HDR,FS,3)
"RTN","HLTPCK1A",34,0)
 I (ARY("SAN")="") S:(ERR="") ERR="Invalid Sending Application" Q
"RTN","HLTPCK1A",35,0)
 S ARY("SAP")=0
"RTN","HLTPCK1A",36,0)
 S:(ARY("SAN")'="") ARY("SAP")=+$O(^HL(771,"B",ARY("SAN"),0))
"RTN","HLTPCK1A",37,0)
 I (('ARY("SAP"))&(ARY("SAN")'="")) D
"RTN","HLTPCK1A",38,0)
 .S X=$$UPPER^HLFNC(ARY("SAN"))
"RTN","HLTPCK1A",39,0)
 .S ARY("SAP")=+$O(^HL(771,"B",ARY("SAN"),0))
"RTN","HLTPCK1A",40,0)
 I ('ARY("SAP")) S:(ERR="") ERR="Invalid Sending Application" Q
"RTN","HLTPCK1A",41,0)
 ;
"RTN","HLTPCK1A",42,0)
VN ;Validate version number
"RTN","HLTPCK1A",43,0)
 I (ARY("VER")="") S:(ERR="") ERR="Missing HL7 Version" Q
"RTN","HLTPCK1A",44,0)
 S X=0
"RTN","HLTPCK1A",45,0)
 S:(ARY("VER")'="") X=+$O(^HL(771.5,"B",ARY("VER"),0))
"RTN","HLTPCK1A",46,0)
 S ARY("VEP")=X
"RTN","HLTPCK1A",47,0)
 I ('X) S:(ERR="") ERR="Invalid HL7 Version" Q
"RTN","HLTPCK1A",48,0)
 ;
"RTN","HLTPCK1A",49,0)
ET ; Check for Event Type if version 2.2 or above
"RTN","HLTPCK1A",50,0)
 ; if response use message id/original message to resolve event type
"RTN","HLTPCK1A",51,0)
 ;I ARY("ETN")="",ARY("VER")>2.1,$G(MSA)'="" D  Q:ERR]""
"RTN","HLTPCK1A",52,0)
 . ;N HLZMID,HLZEP,HLZ770
"RTN","HLTPCK1A",53,0)
 . ;S HLZMID=$O(^HL(772,"C",+$P(MSA,FS,2),0))
"RTN","HLTPCK1A",54,0)
 . ;I HLZMID D
"RTN","HLTPCK1A",55,0)
 ..  ;I '$G(^HL(772,HLZMID,0)) S:(ERR="") ERR="Original Outgoing Message not found" Q
"RTN","HLTPCK1A",56,0)
 ..  ;S HLZEP=$P($G(^HL(772,HLZMID,0)),U,10)
"RTN","HLTPCK1A",57,0)
 ..  ;I HLZEP'>0 S:(ERR="") ERR="Event Protocol pointer (field #772,10) missing" Q
"RTN","HLTPCK1A",58,0)
 ..  ;S HLZ770=$G(^ORD(101,HLZEP,770))
"RTN","HLTPCK1A",59,0)
 ..  ;S ARY("ETN")=$P($G(^HL(779.001,+$P(HLZ770,U,4),0)),U)
"RTN","HLTPCK1A",60,0)
 . ;K HLZMID,HLZEP,HLZ770
"RTN","HLTPCK1A",61,0)
 ;
"RTN","HLTPCK1A",62,0)
 I (ARY("ETN")=""),ARY("VER")>2.1,$G(MSA)="" S:(ERR="") ERR="Event Type REQUIRED" Q
"RTN","HLTPCK1A",63,0)
 S ARY("ETP")=0
"RTN","HLTPCK1A",64,0)
 I $G(MSA)="",(ARY("ETN")'="") S ARY("ETP")=+$O(^HL(779.001,"B",ARY("ETN"),0)) I ('ARY("ETP")) S:(ERR="") ERR="Invalid Event Type" Q
"RTN","HLTPCK1A",65,0)
 ;
"RTN","HLTPCK1A",66,0)
MS ;Check for Message Structure Code
"RTN","HLTPCK1A",67,0)
 I $G(ARY("MTN_ETN"))'="" D
"RTN","HLTPCK1A",68,0)
 . S ARY("MTP_ETP")=0
"RTN","HLTPCK1A",69,0)
 . S ARY("MTP_ETP")=+$O(^HL(779.005,"B",ARY("MTN_ETN"),0))
"RTN","HLTPCK1A",70,0)
 . I ('ARY("MTP_ETP")) S:(ERR="") ERR="Invalid Message Structure Code" Q
"RTN","HLTPCK1A",71,0)
 ;
"RTN","HLTPCK1A",72,0)
MSA ;Get receiving application data from Protocol file
"RTN","HLTPCK1A",73,0)
 ;I (ARY("SAP")) D  Q:ERR]""
"RTN","HLTPCK1A",74,0)
 I $D(MSA) D  Q
"RTN","HLTPCK1A",75,0)
 .;Message is an acknowledgement - deliver to Server Protocol that
"RTN","HLTPCK1A",76,0)
 .;  message came from
"RTN","HLTPCK1A",77,0)
 .I '$G(ARY("SAP")) S ERR="Missing Sending Application" Q
"RTN","HLTPCK1A",78,0)
 .S ARY("MTIENS")=0
"RTN","HLTPCK1A",79,0)
 .F  S ARY("MTIENS")=+$O(^HL(772,"AH",ARY("SAP"),$P(MSA,FS,2),ARY("MTIENS"))) Q:'ARY("MTIENS")!($P($G(^HL(772,+ARY("MTIENS"),0)),U,4)="O")
"RTN","HLTPCK1A",80,0)
 .S X=$G(^HL(772,+ARY("MTIENS"),0))
"RTN","HLTPCK1A",81,0)
 .S ARY("EIDS")=$P(X,"^",10)
"RTN","HLTPCK1A",82,0)
 .I ('ARY("EIDS")) S:(ERR="") ERR="Invalid Message Control ID in MSA Segment" Q
"RTN","HLTPCK1A",83,0)
 .S ARY("MTIEN")=+$P(X,"^",8)
"RTN","HLTPCK1A",84,0)
 .S ARY("ACK")=$P(X,"^",7)
"RTN","HLTPCK1A",85,0)
 .S X=$G(^HL(772,+$P(X,"^",8),0))
"RTN","HLTPCK1A",86,0)
 .S ARY("EID")=$P(X,"^",10)
"RTN","HLTPCK1A",87,0)
 .I ('ARY("EID")) S:(ERR="") ERR="Event Protocol not found" Q
"RTN","HLTPCK1A",88,0)
 .D EVENT^HLUTIL1(ARY("EIDS"),"770,773",.HLN)
"RTN","HLTPCK1A",89,0)
 .;Get Logical Link info if defined on subscriber
"RTN","HLTPCK1A",90,0)
 .S ARY("LL")=$P($G(HLN(770)),"^",7)
"RTN","HLTPCK1A",91,0)
 ;
"RTN","HLTPCK1A",92,0)
 I ARY("MTP") D
"RTN","HLTPCK1A",93,0)
 .;Find Server Protocol - based on sending application, message type,
"RTN","HLTPCK1A",94,0)
 .;event type and version ID
"RTN","HLTPCK1A",95,0)
 .I ARY("ETP") S ARY("EID")=+$O(^ORD(101,"AHL1",ARY("SAP"),ARY("MTP"),ARY("ETP"),ARY("VEP"),0))
"RTN","HLTPCK1A",96,0)
 .;
"RTN","HLTPCK1A",97,0)
 .;Find Server Protocol - based on sending application, message type,
"RTN","HLTPCK1A",98,0)
 .;and version ID
"RTN","HLTPCK1A",99,0)
 .I 'ARY("ETP") S ARY("EID")=+$O(^ORD(101,"AHL21",ARY("SAP"),ARY("MTP"),ARY("VEP"),0))
"RTN","HLTPCK1A",100,0)
 .;
"RTN","HLTPCK1A",101,0)
 .I ('ARY("EID")) S:(ERR="") ERR="Event Protocol not found" Q
"RTN","HLTPCK1A",102,0)
 .;Find Client Protocol - in ITEM multiple of Server Protocol
"RTN","HLTPCK1A",103,0)
 .S ARY("EIDS")=0
"RTN","HLTPCK1A",104,0)
 .F  S ARY("EIDS")=+$O(^ORD(101,ARY("EID"),775,"B",ARY("EIDS"))) Q:('ARY("EIDS"))  D  Q:$G(X1)
"RTN","HLTPCK1A",105,0)
 ..S (X,X1)=0
"RTN","HLTPCK1A",106,0)
 ..S X=$G(^ORD(101,ARY("EIDS"),770))
"RTN","HLTPCK1A",107,0)
 ..I $P(X,U,2)=ARY("RAP") S X1=1
"RTN","HLTPCK1A",108,0)
 .I 'ARY("EIDS") S:(ERR="") ERR="Invalid Receiving Application for this Event" Q
"RTN","HLTPCK1A",109,0)
 .D EVENT^HLUTIL1(ARY("EIDS"),"770,773",.HLN)
"RTN","HLTPCK1A",110,0)
 ;
"RTN","HLTPCK1A",111,0)
LLP ;Get logical link pointer
"RTN","HLTPCK1A",112,0)
 S ARY("LL")=$P($G(HLN(770)),"^",7)
"RTN","HLTPCK1A",113,0)
 ;
"RTN","HLTPCK1A",114,0)
FAC ;Get sending/rec facility, validate if necessary
"RTN","HLTPCK1A",115,0)
 ;
"RTN","HLTPCK1A",116,0)
 S HLCS=$E(ECH,1) ;Get component separator
"RTN","HLTPCK1A",117,0)
 S ARY("RAF")=$P(HDR,FS,6) ;Receiving Facility
"RTN","HLTPCK1A",118,0)
 S ARY("SAF")=$P(HDR,FS,4) ;Sending Facility
"RTN","HLTPCK1A",119,0)
 ;Get sending/receiving facility from Application Parameter file(771)
"RTN","HLTPCK1A",120,0)
 S HL771SF=$P($G(^HL(771,ARY("SAP"),0)),U,3)
"RTN","HLTPCK1A",121,0)
 S HL771RF=$P($G(^HL(771,ARY("RAP"),0)),U,3)
"RTN","HLTPCK1A",122,0)
 ;Sending/Receiving facility required?
"RTN","HLTPCK1A",123,0)
 S X=$G(^ORD(101,ARY("EIDS"),773))
"RTN","HLTPCK1A",124,0)
 S HLSFREQ=+X,HLRFREQ=+$P(X,U,2)
"RTN","HLTPCK1A",125,0)
RF ;Validate Receiving Facility
"RTN","HLTPCK1A",126,0)
 I HLRFREQ D
"RTN","HLTPCK1A",127,0)
 .I ARY("RAF")="" S:ERR="" ERR="Missing required receiving facility" Q
"RTN","HLTPCK1A",128,0)
 .I HL771RF]"" D  Q
"RTN","HLTPCK1A",129,0)
 ..;Facility data in 771 overrides data in site paramter file
"RTN","HLTPCK1A",130,0)
 ..;For backward compatibility, don't validate
"RTN","HLTPCK1A",131,0)
 ..Q
"RTN","HLTPCK1A",132,0)
 ..Q:HL771RF=ARY("RAF")
"RTN","HLTPCK1A",133,0)
 ..S:ERR="" ERR="Receiving Facility/App Parameter mismatch."
"RTN","HLTPCK1A",134,0)
 .;Check against local default value (site parameters)
"RTN","HLTPCK1A",135,0)
 .Q:ARY("RAF")=(HLINSTN_HLCS_HLDOM_HLCS_"DNS")
"RTN","HLTPCK1A",136,0)
 .S:ERR="" ERR="Receiving Facility mismatch."
"RTN","HLTPCK1A",137,0)
SF ;Validate Sending Facility
"RTN","HLTPCK1A",138,0)
 I HLSFREQ D
"RTN","HLTPCK1A",139,0)
 .I ARY("SAF")="" S:ERR="" ERR="Missing required sending facility" Q
"RTN","HLTPCK1A",140,0)
 .I HL771SF]"" D  Q
"RTN","HLTPCK1A",141,0)
 ..;Check for facility data in 771
"RTN","HLTPCK1A",142,0)
 ..Q
"RTN","HLTPCK1A",143,0)
 ..Q:HL771SF=ARY("SAF")
"RTN","HLTPCK1A",144,0)
 ..S:ERR="" ERR="Sending Facility/App Parameter mismatch."
"RTN","HLTPCK1A",145,0)
 .;If default value was sent, validate that DOMAIN RESOLVES TO LOGICAL LINK
"RTN","HLTPCK1A",146,0)
 .;If so, use this instead of Protocol definition for return path
"RTN","HLTPCK1A",147,0)
 .S HLDOMP=$P(ARY("SAF"),HLCS,2),HLDOMP=$O(^DIC(4.2,"B",HLDOMP,0))
"RTN","HLTPCK1A",148,0)
 .I 'HLDOMP S:ERR="" ERR="Unrecognized domain in sending facility"
"RTN","HLTPCK1A",149,0)
 .Q:HLDOMP=$P(HLPARAM,U)  ;This is local app to app
"RTN","HLTPCK1A",150,0)
 .I HLDOMP N HLNK S HLNK=+$O(^HLCS(870,"D",HLDOMP,0))
"RTN","HLTPCK1A",151,0)
 .I HLNK S ARY("LL")=HLNK
"RTN","HLTPCK1A",152,0)
 ;
"RTN","HLTPCK1A",153,0)
PID ;Validate processing ID
"RTN","HLTPCK1A",154,0)
 I ("DTP"'[ARY("PID")) S:(ERR="") ERR="Invalid HL7 Processing ID" Q
"RTN","HLTPCK1A",155,0)
 S HLPID=$P(HLPARAM,U,3) ;site param
"RTN","HLTPCK1A",156,0)
 S X=$G(^ORD(101,ARY("EID"),770)),X=$P(X,U,6) ;event driver
"RTN","HLTPCK1A",157,0)
 ;I X=""&($G(HLPID))="" S:ERR="" ERR="Cannot validate PROCESSING ID"
"RTN","HLTPCK1A",158,0)
 ;If message is 'debug' then event driver must be 'debug.'
"RTN","HLTPCK1A",159,0)
 ;If message is 'test' or 'production', then site param must match
"RTN","HLTPCK1A",160,0)
 I ARY("PID")="D"&(X'="D") S:ERR="" ERR="Processing ID Mismatch with Event Driver"
"RTN","HLTPCK1A",161,0)
 I ARY("PID")'="D"&(HLPID'=ARY("PID")) S:ERR="" ERR="Processing ID Mismatch with Site Parameters"
"RTN","HLTPCK1A",162,0)
 ;
"RTN","HLTPCK1A",163,0)
SEC ;Validate security field - access code and electronic signature
"RTN","HLTPCK1A",164,0)
 I ($P($G(HLN(773)),"^",3)) D
"RTN","HLTPCK1A",165,0)
 .S X=$P($P(HDR,FS,8),$E(ECH))
"RTN","HLTPCK1A",166,0)
 .S X=$$UPPER^HLFNC(X)
"RTN","HLTPCK1A",167,0)
 .D ^XUSHSH
"RTN","HLTPCK1A",168,0)
 .I ((X="")&('$D(MSA))) S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK1A",169,0)
 .S ARY("DUZ")=0
"RTN","HLTPCK1A",170,0)
 .S:(X'="") ARY("DUZ")=+$O(^VA(200,"A",X,0))
"RTN","HLTPCK1A",171,0)
 .I ('ARY("DUZ")) S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK1A",172,0)
 .I (($P($G(^VA(200,ARY("DUZ"),.1)),"^")="")&('$D(MSA))) S ARY("DUZ")=0 S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK1A",173,0)
 .S X=$P($P(HDR,FS,8),$E(ECH),3) I (X'="") D
"RTN","HLTPCK1A",174,0)
 ..S X1=$G(^VA(200,ARY("DUZ"),20))
"RTN","HLTPCK1A",175,0)
 ..I (X1="") S:(ERR="") ERR="No Signature Code on File" Q
"RTN","HLTPCK1A",176,0)
 ..S X=$$UPPER^HLFNC(X)
"RTN","HLTPCK1A",177,0)
 ..D HASH^XUSHSHP
"RTN","HLTPCK1A",178,0)
 ..I ((X'=$P(X1,"^",4))!($P(X1,"^",2)="")) S:(ERR="") ERR="Invalid Electronic Signature Code" Q
"RTN","HLTPCK1A",179,0)
 ..S ARY("ESIG")=$P(X1,"^",2)
"RTN","HLTPCK1A",180,0)
 I $D(ARY) M HLREC=ARY
"RTN","HLTPCK1A",181,0)
 Q
"RTN","HLTPCK2")
0^9^B8648558
"RTN","HLTPCK2",1,0)
HLTPCK2 ;SF/RSD - Message Header Validation (Con't) ;03/08/2000  10:09
"RTN","HLTPCK2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,59**;Oct 13, 1995
"RTN","HLTPCK2",3,0)
CHK(HDR,ARY,MSA) ;
"RTN","HLTPCK2",4,0)
 ;Validate Data in Header Segment (MSH, BHS or FHS) of an HL7 Message
"RTN","HLTPCK2",5,0)
 ;
"RTN","HLTPCK2",6,0)
 ;This entry point is a subroutine call with parameter passing that
"RTN","HLTPCK2",7,0)
 ;will return an array (ARY()) consisting of values extracted from
"RTN","HLTPCK2",8,0)
 ;the message header segment subscripted by the mnemonics for each of
"RTN","HLTPCK2",9,0)
 ;the message header fields and components
"RTN","HLTPCK2",10,0)
 ;The message header can be multiple line longer than 255 characters.
"RTN","HLTPCK2",11,0)
 ;HDR is an array that is passed by reference.
"RTN","HLTPCK2",12,0)
 ;If an error is encountered during validation, the array parameter
"RTN","HLTPCK2",13,0)
 ;(ARY) will be set equal to two pieces, error #^error text and the
"RTN","HLTPCK2",14,0)
 ;rest of the array will not be returned
"RTN","HLTPCK2",15,0)
 ;
"RTN","HLTPCK2",16,0)
 ;Required input parameters
"RTN","HLTPCK2",17,0)
 ;  HDR = Message header array, HDR(1,0)=segment (passed by reference)
"RTN","HLTPCK2",18,0)
 ;
"RTN","HLTPCK2",19,0)
 ;  ARY = The array in which the message header values will be
"RTN","HLTPCK2",20,0)
 ;          returned (passed by reference)
"RTN","HLTPCK2",21,0)
 ;Optional input parameter
"RTN","HLTPCK2",22,0)
 ;  MSA = A variable which contains the message acknowledgement values:
"RTN","HLTPCK2",23,0)
 ;          acknowledgement code^message control ID^text message. Passed
"RTN","HLTPCK2",24,0)
 ;          by reference so that Batch msg. can set this here.
"RTN","HLTPCK2",25,0)
 ;
"RTN","HLTPCK2",26,0)
 ;Check for required parameters
"RTN","HLTPCK2",27,0)
 N ERR S ERR=""
"RTN","HLTPCK2",28,0)
 I $D(HDR)<10 S ERR="7^"_$G(^HL(771.7,7,0))_" at CHK^HLTPCK1 entry point" G EXIT
"RTN","HLTPCK2",29,0)
 N ECH,HLN,FS,X,X1,X2
"RTN","HLTPCK2",30,0)
 S ARY="",ARY("Q")=""""""
"RTN","HLTPCK2",31,0)
 ;
"RTN","HLTPCK2",32,0)
 ;Validate field separator and encoding characters
"RTN","HLTPCK2",33,0)
 S (ARY("FS"),FS)=$E(HDR(1,0),4)
"RTN","HLTPCK2",34,0)
 I FS']"" S ERR="Field Separator Missing" G EXIT
"RTN","HLTPCK2",35,0)
 I FS?.C S ERR="Invalid Field Separator" G EXIT
"RTN","HLTPCK2",36,0)
 S (ARY("ECH"),ECH)=$$P(.HDR,2)
"RTN","HLTPCK2",37,0)
 I ECH']"" S ERR="Encoding Characters Missing" G EXIT
"RTN","HLTPCK2",38,0)
 I ECH?.C S ERR="Invalid Encoding Characters" G EXIT
"RTN","HLTPCK2",39,0)
 ;
"RTN","HLTPCK2",40,0)
 ;Validate Message Header Type
"RTN","HLTPCK2",41,0)
 S (ARY("TYPE"),X)=$$P(.HDR,1)
"RTN","HLTPCK2",42,0)
 I X=""!("FHS,BHS,MSH"'[X) S ERR="Invalid Message Header Segment" G EXIT
"RTN","HLTPCK2",43,0)
 ;
"RTN","HLTPCK2",44,0)
 ;Extract data from message header segment
"RTN","HLTPCK2",45,0)
 S ARY("SAN")=$$P(.HDR,3),ARY("SFN")=$$P(.HDR,4),ARY("RAN")=$$P(.HDR,5),ARY("RFN")=$$P(.HDR,6),ARY("DTM")=$$P(.HDR,7)
"RTN","HLTPCK2",46,0)
 I X="BHS"!(X="FHS") D
"RTN","HLTPCK2",47,0)
 . S ARY("MID")=$$P(.HDR,11),X=$$P(.HDR,9),ARY("PID")=$P(X,$E(ECH),2)
"RTN","HLTPCK2",48,0)
 . S ARY("MTN")=$P($P(X,$E(ECH),3),$E(ECH,2)),ARY("ETN")=$P($P(X,$E(ECH),3),$E(ECH,2),2)
"RTN","HLTPCK2",49,0)
 . S ARY("VER")=$P(X,$E(ECH),4),ARY("ACAT")=$P(X,$E(ECH),5),ARY("APAT")=$P(X,$E(ECH),6)
"RTN","HLTPCK2",50,0)
 . S:$$P(.HDR,10)]"" MSA=$P($$P(.HDR,10),$E(ECH),1),$P(MSA,FS,2)=$$P(.HDR,12),$P(MSA,FS,3)=$P($$P(.HDR,10),$E(ECH),2)
"RTN","HLTPCK2",51,0)
 I $$P(.HDR,1)="MSH" D
"RTN","HLTPCK2",52,0)
 . S ARY("MID")=$$P(.HDR,10),ARY("PID")=$$P(.HDR,11),ARY("MTN")=$P($$P(.HDR,9),$E(ECH)),ARY("ETN")=$P($$P(.HDR,9),$E(ECH),2),ARY("VER")=$$P(.HDR,12)
"RTN","HLTPCK2",53,0)
 . S:$P($$P(.HDR,9),$E(ECH),3)'="" ARY("MTN_ETN")=$P($$P(.HDR,9),$E(ECH),3)
"RTN","HLTPCK2",54,0)
 . S:$$P(.HDR,15)]"" ARY("ACAT")=$$P(.HDR,15) S:$$P(.HDR,16)]"" ARY("APAT")=$$P(.HDR,16) S:$$P(.HDR,17)]"" ARY("CC")=$$P(.HDR,17)
"RTN","HLTPCK2",55,0)
 ;
"RTN","HLTPCK2",56,0)
 ;Invoke continuation routine to perform remaining validation checks
"RTN","HLTPCK2",57,0)
 D ^HLTPCK2A
"RTN","HLTPCK2",58,0)
EXIT I ERR]"" S ARY=$S('ERR:"13^"_ERR,1:ERR)
"RTN","HLTPCK2",59,0)
 Q
"RTN","HLTPCK2",60,0)
 ;
"RTN","HLTPCK2",61,0)
P(MSH,P) ;get piece P from MSH array (passed by ref.)
"RTN","HLTPCK2",62,0)
 N FS,I,L,L1,L2,X,Y
"RTN","HLTPCK2",63,0)
 S FS=$E(MSH(1,0),4),(L2,Y)=0,X=""
"RTN","HLTPCK2",64,0)
 F I=1:1 S L1=$L($G(MSH(I,0)),FS),L=L1+Y-1 D  Q:$L(X)!'$D(MSH(I,0))
"RTN","HLTPCK2",65,0)
 . S:L1=1 L=L+1
"RTN","HLTPCK2",66,0)
 . S:P'>L X=$P($G(MSH(I-1,0)),FS,P-L2)_$P($G(MSH(I,0)),FS,(P-Y))
"RTN","HLTPCK2",67,0)
 . S L2=Y,Y=L
"RTN","HLTPCK2",68,0)
 Q X
"RTN","HLTPCK2",69,0)
 ;
"RTN","HLTPCK2",70,0)
 Q
"RTN","HLTPCK2A")
0^6^B55504021
"RTN","HLTPCK2A",1,0)
HLTPCK2A ;SF/RSD - Message Header Validation (Con't) ;03/08/2000  10:37
"RTN","HLTPCK2A",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,57,59**;Oct 13, 1995
"RTN","HLTPCK2A",3,0)
 S ERR=""
"RTN","HLTPCK2A",4,0)
 S HLPARAM=$$PARAM^HLCS2,HLDOM=$P(HLPARAM,U,2),HLINSTN=$P(HLPARAM,U,6)
"RTN","HLTPCK2A",5,0)
MT ;Validate message type
"RTN","HLTPCK2A",6,0)
 I (ARY("MTN")="") S:(ERR="") ERR="Invalid Message Type" Q
"RTN","HLTPCK2A",7,0)
 S ARY("MTP")=0
"RTN","HLTPCK2A",8,0)
 S:(ARY("MTN")'="") ARY("MTP")=+$O(^HL(771.2,"B",ARY("MTN"),0))
"RTN","HLTPCK2A",9,0)
 I ('ARY("MTP")) S:(ERR="") ERR="Invalid Message Type" Q
"RTN","HLTPCK2A",10,0)
 ;
"RTN","HLTPCK2A",11,0)
AT ;Determine if message is an acknowledgement type
"RTN","HLTPCK2A",12,0)
 I (("ACK,ADR,MCF,MFK,MFR,ORF,ORR,RRA,RRD,RRE,RRG,TBR"[ARY("MTN"))&($G(MSA)="")) S:(ERR="") ERR="MSA Segment Missing" Q
"RTN","HLTPCK2A",13,0)
 ;commit ack, quit
"RTN","HLTPCK2A",14,0)
 I $E($G(MSA))="C" D  Q
"RTN","HLTPCK2A",15,0)
 . ;find original msg.
"RTN","HLTPCK2A",16,0)
 . S ARY("MSAID")=$P(MSA,FS,2),ARY("MTIENS")=0
"RTN","HLTPCK2A",17,0)
 . I ARY("MSAID")="" S:(ERR="") ERR="Invalid Message Control ID in MSA Segment" Q
"RTN","HLTPCK2A",18,0)
 . F  S ARY("MTIENS")=+$O(^HLMA("C",ARY("MSAID"),ARY("MTIENS"))) Q:'ARY("MTIENS")!($P($G(^HLMA(ARY("MTIENS"),0)),U,3)="O")
"RTN","HLTPCK2A",19,0)
 . I 'ARY("MTIENS") S:(ERR="") ERR="Invalid Message Control ID in MSA Segment" Q
"RTN","HLTPCK2A",20,0)
 . Q
"RTN","HLTPCK2A",21,0)
AAT ;Validate accept ack type and application ack type
"RTN","HLTPCK2A",22,0)
 I ($G(ARY("ACAT"))'="") I ("AL,NE,ER,SU"'[ARY("ACAT")) S:(ERR="") ERR="Invalid accept ack type" Q
"RTN","HLTPCK2A",23,0)
 I ($G(ARY("APAT"))'="") I ("AL,NE,ER,SU"'[ARY("APAT")) S:(ERR="") ERR="Invalid application ack type" Q
"RTN","HLTPCK2A",24,0)
 ;
"RTN","HLTPCK2A",25,0)
 ;
"RTN","HLTPCK2A",26,0)
RA ;Validate receiving application
"RTN","HLTPCK2A",27,0)
 I (ARY("RAN")="") S:(ERR="") ERR="Invalid Receiving Application" Q
"RTN","HLTPCK2A",28,0)
 S ARY("RAP")=0
"RTN","HLTPCK2A",29,0)
 S:ARY("RAN")'="" ARY("RAP")=+$O(^HL(771,"B",ARY("RAN"),0))
"RTN","HLTPCK2A",30,0)
 I 'ARY("RAP"),ARY("RAN")'="" D
"RTN","HLTPCK2A",31,0)
 .S X=$$UPPER^HLFNC(ARY("RAN"))
"RTN","HLTPCK2A",32,0)
 .S ARY("RAP")=+$O(^HL(771,"B",ARY("RAN"),0))
"RTN","HLTPCK2A",33,0)
 I ('ARY("RAP")) S:(ERR="") ERR="Invalid Receiving Application" Q
"RTN","HLTPCK2A",34,0)
 S X2=$G(^HL(771,ARY("RAP"),0))
"RTN","HLTPCK2A",35,0)
 I (X2="") S:(ERR="") ERR="Invalid Receiving Application" Q
"RTN","HLTPCK2A",36,0)
 I ($P(X2,"^",2)'="a") S:(ERR="") ERR="Receiving Application is Inactive" Q
"RTN","HLTPCK2A",37,0)
 ;
"RTN","HLTPCK2A",38,0)
SA ;Validate sending application
"RTN","HLTPCK2A",39,0)
 I (ARY("SAN")="") S:(ERR="") ERR="Invalid Sending Application" Q
"RTN","HLTPCK2A",40,0)
 S ARY("SAP")=0
"RTN","HLTPCK2A",41,0)
 S:(ARY("SAN")'="") ARY("SAP")=+$O(^HL(771,"B",ARY("SAN"),0))
"RTN","HLTPCK2A",42,0)
 I (('ARY("SAP"))&(ARY("SAN")'="")) D
"RTN","HLTPCK2A",43,0)
 .S X=$$UPPER^HLFNC(ARY("SAN"))
"RTN","HLTPCK2A",44,0)
 .S ARY("SAP")=+$O(^HL(771,"B",ARY("SAN"),0))
"RTN","HLTPCK2A",45,0)
 I ('ARY("SAP")) S:(ERR="") ERR="Invalid Sending Application" Q
"RTN","HLTPCK2A",46,0)
 ;
"RTN","HLTPCK2A",47,0)
VN ;Validate version number
"RTN","HLTPCK2A",48,0)
 I (ARY("VER")="") S:(ERR="") ERR="Missing HL7 Version" Q
"RTN","HLTPCK2A",49,0)
 S X=0
"RTN","HLTPCK2A",50,0)
 S:(ARY("VER")'="") X=+$O(^HL(771.5,"B",ARY("VER"),0))
"RTN","HLTPCK2A",51,0)
 S ARY("VEP")=X
"RTN","HLTPCK2A",52,0)
 I ('X) S:(ERR="") ERR="Invalid HL7 Version" Q
"RTN","HLTPCK2A",53,0)
 ;I (X'=$P($G(HLN(770)),"^",10)) S:(ERR="") ERR="Invalid HL7 Version for Receiving Application" Q
"RTN","HLTPCK2A",54,0)
 ;
"RTN","HLTPCK2A",55,0)
ET ;Event Type Checks
"RTN","HLTPCK2A",56,0)
 ;
"RTN","HLTPCK2A",57,0)
 ;I ARY("ETN")="",ARY("VER")>2.1,$G(MSA)'="" D
"RTN","HLTPCK2A",58,0)
 . ;N Z,ZEP,ZP
"RTN","HLTPCK2A",59,0)
 . ;S Z=0 I $P(MSA,FS,2)]"" S Z=+$O(^HLMA("C",$P(MSA,FS,2),0))
"RTN","HLTPCK2A",60,0)
 . ;I '$G(^HLMA(Z,0)) S:(ERR="") ERR="Original Outgoing Message not found" Q
"RTN","HLTPCK2A",61,0)
 . ;S ZEP=$P(^HLMA(Z,0),U,8)
"RTN","HLTPCK2A",62,0)
 . ;I 'ZEP S:(ERR="") ERR="Event Protocol pointer (field #773,8) missing" Q
"RTN","HLTPCK2A",63,0)
 . ;S ZP=$G(^ORD(101,ZEP,770)),ARY("ETN")=$P($G(^HL(779.001,+$P(ZP,U,4),0)),U)
"RTN","HLTPCK2A",64,0)
 ;
"RTN","HLTPCK2A",65,0)
 ;Validate event type
"RTN","HLTPCK2A",66,0)
 I (ARY("ETN")=""),ARY("VER")>2.1,$G(MSA)="" S ERR="Event Type Required" Q
"RTN","HLTPCK2A",67,0)
 S ARY("ETP")=0
"RTN","HLTPCK2A",68,0)
 S:(ARY("ETN")'="") ARY("ETP")=+$O(^HL(779.001,"B",ARY("ETN"),0))
"RTN","HLTPCK2A",69,0)
 I $G(MSA)="",ARY("VER")>2.1,('ARY("ETP")) S ERR="Invalid Event Type" Q
"RTN","HLTPCK2A",70,0)
 ;
"RTN","HLTPCK2A",71,0)
MS ;Check for Message Structure Code
"RTN","HLTPCK2A",72,0)
 I $G(ARY("MTN_ETN"))'="" D
"RTN","HLTPCK2A",73,0)
 . S ARY("MTP_ETP")=0
"RTN","HLTPCK2A",74,0)
 . S ARY("MTP_ETP")=+$O(^HL(779.005,"B",ARY("MTN_ETN"),0))
"RTN","HLTPCK2A",75,0)
 . I ('ARY("MTP_ETP")) S:(ERR="") ERR="Invalid Message Structure Code" Q
"RTN","HLTPCK2A",76,0)
 ;
"RTN","HLTPCK2A",77,0)
 ;Get server and client Protocols
"RTN","HLTPCK2A",78,0)
MSA ;if ack, then get information and quit, we don't need to respond
"RTN","HLTPCK2A",79,0)
 I $G(MSA)]"" D  Q
"RTN","HLTPCK2A",80,0)
 . ;Message is an acknowledgement, find original message
"RTN","HLTPCK2A",81,0)
 . S ARY("MSAID")=$P(MSA,FS,2),ARY("MTIENS")=0
"RTN","HLTPCK2A",82,0)
 . I ARY("MSAID")="" S:(ERR="") ERR="Invalid Message Control ID in MSA Segment" Q
"RTN","HLTPCK2A",83,0)
 . F  S ARY("MTIENS")=+$O(^HLMA("AH",ARY("SAP"),ARY("MSAID"),ARY("MTIENS"))) Q:'ARY("MTIENS")!($P($G(^HLMA(ARY("MTIENS"),0)),U,3)="O")
"RTN","HLTPCK2A",84,0)
 . I 'ARY("MTIENS") S:(ERR="") ERR="Invalid Message Control ID in MSA Segment" Q
"RTN","HLTPCK2A",85,0)
 . ;get subscriber protocol and ack. to (show if this is an ack to an ack)
"RTN","HLTPCK2A",86,0)
 . S X=$G(^HLMA(ARY("MTIENS"),0)),ARY("EIDS")=$P(X,U,8),ARY("ACK")=$P(X,U,10)
"RTN","HLTPCK2A",87,0)
 . ;if no subscriber protocol then response msg. is invalid
"RTN","HLTPCK2A",88,0)
 . I ('ARY("EIDS")) S:(ERR="") ERR="Invalid Message Control ID in MSA Segment" Q
"RTN","HLTPCK2A",89,0)
 . ;get message text ien in file 772 and server protocol, 'EID'
"RTN","HLTPCK2A",90,0)
 . S ARY("MTIEN")=+X,X=$G(^HL(772,+X,0)),ARY("EID")=$P(X,U,10)
"RTN","HLTPCK2A",91,0)
 . I ('ARY("EID")) S:(ERR="") ERR="Event Protocol not found" Q
"RTN","HLTPCK2A",92,0)
 . D EVENT^HLUTIL1(ARY("EIDS"),"770,773",.HLN)
"RTN","HLTPCK2A",93,0)
 ;
"RTN","HLTPCK2A",94,0)
 ;Find Server Protocol - based on sending application, message type,
"RTN","HLTPCK2A",95,0)
 ;event type and version ID
"RTN","HLTPCK2A",96,0)
 I ARY("ETP") S ARY("EID")=+$O(^ORD(101,"AHL1",ARY("SAP"),ARY("MTP"),ARY("ETP"),ARY("VEP"),0))
"RTN","HLTPCK2A",97,0)
 ;
"RTN","HLTPCK2A",98,0)
 ;Find Server Protocol - based on sending application, message type,
"RTN","HLTPCK2A",99,0)
 ;and version ID
"RTN","HLTPCK2A",100,0)
 I 'ARY("ETP") S ARY("EID")=+$O(^ORD(101,"AHL21",ARY("SAP"),ARY("MTP"),ARY("VEP"),0))
"RTN","HLTPCK2A",101,0)
 ;
"RTN","HLTPCK2A",102,0)
 I ('ARY("EID")) S:(ERR="") ERR="Event Protocol not found" Q
"RTN","HLTPCK2A",103,0)
 ;Find Client Protocol - in ITEM multiple of Server Protocol
"RTN","HLTPCK2A",104,0)
 S ARY("EIDS")=0
"RTN","HLTPCK2A",105,0)
 F  S ARY("EIDS")=+$O(^ORD(101,ARY("EID"),775,"B",ARY("EIDS"))) Q:'ARY("EIDS")!($P($G(^ORD(101,ARY("EIDS"),770)),U,2)=ARY("RAP"))
"RTN","HLTPCK2A",106,0)
 I 'ARY("EIDS") S ERR="Invalid Receiving Application for this Event" Q
"RTN","HLTPCK2A",107,0)
 D EVENT^HLUTIL1(ARY("EIDS"),"770,773",.HLN)
"RTN","HLTPCK2A",108,0)
 ;
"RTN","HLTPCK2A",109,0)
LLP ;Get logical link pointer
"RTN","HLTPCK2A",110,0)
 S ARY("LL")=$P($G(HLN(770)),"^",7)
"RTN","HLTPCK2A",111,0)
 ;
"RTN","HLTPCK2A",112,0)
FAC ;Get sending/rec facility, validate if necessary
"RTN","HLTPCK2A",113,0)
 ;
"RTN","HLTPCK2A",114,0)
 S HLCS=$E(ECH,1) ;Get component separator
"RTN","HLTPCK2A",115,0)
 S ARY("RAF")=$$P^HLTPCK2(.HDR,6) ;Receiving Facility
"RTN","HLTPCK2A",116,0)
 S ARY("SAF")=$$P^HLTPCK2(.HDR,4) ;Sending Facility
"RTN","HLTPCK2A",117,0)
 ;Get sending/receiving facility from Application Parameter file(771)
"RTN","HLTPCK2A",118,0)
 S HL771SF=$P($G(^HL(771,ARY("SAP"),0)),U,3)
"RTN","HLTPCK2A",119,0)
 S HL771RF=$P($G(^HL(771,ARY("RAP"),0)),U,3)
"RTN","HLTPCK2A",120,0)
 ;Sending/Receiving facility required?
"RTN","HLTPCK2A",121,0)
 S X=$G(^ORD(101,ARY("EIDS"),773))
"RTN","HLTPCK2A",122,0)
 S HLSFREQ=+X,HLRFREQ=+$P(X,U,2)
"RTN","HLTPCK2A",123,0)
RF ;Validate Receiving Facility
"RTN","HLTPCK2A",124,0)
 I HLRFREQ D
"RTN","HLTPCK2A",125,0)
 .I ARY("RAF")="" S:ERR="" ERR="Missing required receiving facility"
"RTN","HLTPCK2A",126,0)
 .I HL771RF]"" D  Q
"RTN","HLTPCK2A",127,0)
 ..;Facility data in 771 overrides data in site paramter file
"RTN","HLTPCK2A",128,0)
 ..Q
"RTN","HLTPCK2A",129,0)
 ..Q:HL771RF=ARY("RAF")
"RTN","HLTPCK2A",130,0)
 ..S:ERR="" ERR="Receiving Facility/App Parameter mismatch."
"RTN","HLTPCK2A",131,0)
 .;Check against local default value (site parameters)
"RTN","HLTPCK2A",132,0)
 .Q:ARY("RAF")=(HLINSTN_HLCS_HLDOM_HLCS_"DNS")
"RTN","HLTPCK2A",133,0)
 .S:ERR="" ERR="Receiving Facility mismatch."
"RTN","HLTPCK2A",134,0)
SF ;Validate Sending Facility
"RTN","HLTPCK2A",135,0)
 I HLSFREQ D
"RTN","HLTPCK2A",136,0)
 .I ARY("SAF")="" S:ERR="" ERR="Missing required sending facility"
"RTN","HLTPCK2A",137,0)
 .I HL771SF]"" D  Q
"RTN","HLTPCK2A",138,0)
 ..;Check for facility data in 771
"RTN","HLTPCK2A",139,0)
 ..Q
"RTN","HLTPCK2A",140,0)
 ..Q:HL771SF=ARY("SAF")
"RTN","HLTPCK2A",141,0)
 ..S:ERR="" ERR="Sending Facility/App Parameter mismatch."
"RTN","HLTPCK2A",142,0)
 .;If default value was sent, validate that DOMAIN RESOLVES TO LOGICAL LINK
"RTN","HLTPCK2A",143,0)
 .;If so, use this instead of Protocol definition for return path
"RTN","HLTPCK2A",144,0)
 .S HLDOMP=$P(ARY("SAF"),HLCS,2),HLDOMP=$O(^DIC(4.2,"B",HLDOMP,0))
"RTN","HLTPCK2A",145,0)
 .I 'HLDOMP S:ERR="" ERR="Unrecognized domain in sending facility"
"RTN","HLTPCK2A",146,0)
 .Q:HLDOMP=$P(HLPARAM,U)  ;This is local app to app
"RTN","HLTPCK2A",147,0)
 .I HLDOMP N HLNK S HLNK=+$O(^HLCS(870,"D",HLDOMP,0))
"RTN","HLTPCK2A",148,0)
 .I HLNK S ARY("LL")=HLNK
"RTN","HLTPCK2A",149,0)
PID ;Validate processing ID
"RTN","HLTPCK2A",150,0)
 I ("DTP"'[ARY("PID")) S:(ERR="") ERR="Invalid HL7 Processing ID"
"RTN","HLTPCK2A",151,0)
 S HLPID=$P(HLPARAM,U,3) ;site param
"RTN","HLTPCK2A",152,0)
 S X=$G(^ORD(101,ARY("EID"),770)),X=$P(X,U,6) ;event driver
"RTN","HLTPCK2A",153,0)
 ;If message is 'debug' then event driver must be 'debug.'
"RTN","HLTPCK2A",154,0)
 ;If message is 'test' or 'production', then site param must match
"RTN","HLTPCK2A",155,0)
 I ARY("PID")="D"&(X'="D") S:ERR="" ERR="Processing ID Mismatch with Event Driver"
"RTN","HLTPCK2A",156,0)
 I ARY("PID")'="D"&(HLPID'=ARY("PID")) S:ERR="" ERR="Processing ID Mismatch with Site Parameters"
"RTN","HLTPCK2A",157,0)
 ;
"RTN","HLTPCK2A",158,0)
SEC ;Validate security field - access code and electronic signature
"RTN","HLTPCK2A",159,0)
 I ($P($G(HLN(773)),"^",3)) D
"RTN","HLTPCK2A",160,0)
 .S X=$P($$P^HLTPCK2(.HDR,8),$E(ECH))
"RTN","HLTPCK2A",161,0)
 .S X=$$UPPER^HLFNC(X)
"RTN","HLTPCK2A",162,0)
 .D ^XUSHSH
"RTN","HLTPCK2A",163,0)
 .I X="",(MSA="") S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK2A",164,0)
 .S ARY("DUZ")=0
"RTN","HLTPCK2A",165,0)
 .S:(X'="") ARY("DUZ")=+$O(^VA(200,"A",X,0))
"RTN","HLTPCK2A",166,0)
 .I ('ARY("DUZ")) S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK2A",167,0)
 .I (($P($G(^VA(200,ARY("DUZ"),.1)),"^")="")&('$D(MSA))) S ARY("DUZ")=0 S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK2A",168,0)
 .S X=$P($$P^HLTPCK2(.HDR,8),$E(ECH),3) I (X'="") D
"RTN","HLTPCK2A",169,0)
 ..S X1=$G(^VA(200,ARY("DUZ"),20))
"RTN","HLTPCK2A",170,0)
 ..I (X1="") S:(ERR="") ERR="No Signature Code on File" Q
"RTN","HLTPCK2A",171,0)
 ..S X=$$UPPER^HLFNC(X)
"RTN","HLTPCK2A",172,0)
 ..D HASH^XUSHSHP
"RTN","HLTPCK2A",173,0)
 ..I ((X'=$P(X1,"^",4))!($P(X1,"^",2)="")) S:(ERR="") ERR="Invalid Electronic Signature Code" Q
"RTN","HLTPCK2A",174,0)
 ..S ARY("ESIG")=$P(X1,"^",2)
"RTN","HLTPCK2A",175,0)
 I $D(ARY) M HLREC=ARY
"RTN","HLTPCK2A",176,0)
 Q
"RTN","HLUTIL2")
0^7^B29017820
"RTN","HLUTIL2",1,0)
HLUTIL2 ;ALB/MFK/MTC/JC - VARIOUS HL7 UTILITIES ;01/20/2000  17:39
"RTN","HLUTIL2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,59**;;Oct 13, 1995
"RTN","HLUTIL2",3,0)
ITEM(IEN,ROUTINE) ; Return data from ITEM multiple in protocol file
"RTN","HLUTIL2",4,0)
 ; INPUT : IEN - Internal Entry Number for 101 (Protocol) file.
"RTN","HLUTIL2",5,0)
 ;         ROUTINE - name of a routine to run (either PTR or TYPE)
"RTN","HLUTIL2",6,0)
 ;OUTPUT : HLARY - Array of IENs from ITEM multiple
"RTN","HLUTIL2",7,0)
 ;  HLARY is of the form:
"RTN","HLUTIL2",8,0)
 ; HLARY(0)=Total number of items found
"RTN","HLUTIL2",9,0)
 ; HLARY(IEN)=Results from function
"RTN","HLUTIL2",10,0)
 N ITEM,LINE,MSG,PTR
"RTN","HLUTIL2",11,0)
 S IEN=$G(IEN)
"RTN","HLUTIL2",12,0)
 Q:(IEN="")
"RTN","HLUTIL2",13,0)
 S ROUTINE=$G(ROUTINE)
"RTN","HLUTIL2",14,0)
 S ROUTINE=$S(ROUTINE="PTR":1,ROUTINE="TYPE":2,ROUTINE=1:1,ROUTINE=2:2,1:"")
"RTN","HLUTIL2",15,0)
 Q:(ROUTINE="")
"RTN","HLUTIL2",16,0)
 S ITEM="",MSG=0
"RTN","HLUTIL2",17,0)
 ;  Loop through IENs within Subscriber multiple
"RTN","HLUTIL2",18,0)
 F  S ITEM=$O(^ORD(101,IEN,775,ITEM)) Q:(ITEM="")  D
"RTN","HLUTIL2",19,0)
 .S PTR=$P($G(^ORD(101,IEN,775,ITEM,0)),"^",1)
"RTN","HLUTIL2",20,0)
 .;  Call type to get info on that item
"RTN","HLUTIL2",21,0)
 .S:(ROUTINE=1) LINE=$$PTR(PTR)
"RTN","HLUTIL2",22,0)
 .S:(ROUTINE=2) LINE=$$TYPE(PTR)
"RTN","HLUTIL2",23,0)
 .;  Make sure LINE isn't error code
"RTN","HLUTIL2",24,0)
 .I ((+LINE)>(-1)) S MSG=MSG+1 S HLARY(PTR)=LINE
"RTN","HLUTIL2",25,0)
 S HLARY(0)=MSG
"RTN","HLUTIL2",26,0)
 K ROUTINE
"RTN","HLUTIL2",27,0)
 Q
"RTN","HLUTIL2",28,0)
PTR(IEN) ;  Return pointer information if subscriber
"RTN","HLUTIL2",29,0)
 ; INPUT - IEN: IEN of protocol file
"RTN","HLUTIL2",30,0)
 ;OUTPUT - Line from ^ORD(101,IEN,770):
"RTN","HLUTIL2",31,0)
 ; CLIENT^LOGICAL_LINK (both pointers)
"RTN","HLUTIL2",32,0)
 N RETURN,LINE,TYPE
"RTN","HLUTIL2",33,0)
 S IEN=$G(IEN)
"RTN","HLUTIL2",34,0)
 Q:(IEN="") "-1"
"RTN","HLUTIL2",35,0)
 ;  Make sure this is a subscriber type
"RTN","HLUTIL2",36,0)
 S TYPE=$P($G(^ORD(101,IEN,0)),"^",4)
"RTN","HLUTIL2",37,0)
 Q:(TYPE'="S") "-2"
"RTN","HLUTIL2",38,0)
 S LINE=$G(^ORD(101,IEN,770))
"RTN","HLUTIL2",39,0)
 S RETURN=$P(LINE,"^",2)_"^"_$P(LINE,"^",7)
"RTN","HLUTIL2",40,0)
 Q RETURN
"RTN","HLUTIL2",41,0)
TYPE(IEN) ;  Return portions of protocol file
"RTN","HLUTIL2",42,0)
 ; INPUT - IEN: IEN of protocol file
"RTN","HLUTIL2",43,0)
 ;OUTPUT - Line containing the following information from the protocol
"RTN","HLUTIL2",44,0)
 ;         file (#101)
"RTN","HLUTIL2",45,0)
 ;
"RTN","HLUTIL2",46,0)
 ; Client ^ Message Type Received ^ Event Type ^ Message Structure ^
"RTN","HLUTIL2",47,0)
 ;  Processing ID ^ Logical Link Pointer ^ Accept Ack ^
"RTN","HLUTIL2",48,0)
 ;  Application Ack ^ Version ^ Message Type Generated
"RTN","HLUTIL2",49,0)
 ;
"RTN","HLUTIL2",50,0)
 N RETURN,CLP,MTPR,ETP,LINE,TYPE,CLIENT,EVENT,MTPEVP
"RTN","HLUTIL2",51,0)
 N ACCACK,APPACK,VERID,VERIDP,ACKP,ACKTYP,MTPG,MTNEVN
"RTN","HLUTIL2",52,0)
 ;-- check if ien was passed in
"RTN","HLUTIL2",53,0)
 S IEN=$G(IEN)
"RTN","HLUTIL2",54,0)
 Q:(IEN="") "-1"
"RTN","HLUTIL2",55,0)
 ;
"RTN","HLUTIL2",56,0)
 ;  Null any variables in case they don't exist
"RTN","HLUTIL2",57,0)
 S (CLIENT,TYPE,EVENT,ACCACK,APPACK,VERID,MTPG,MTNEVN)=""
"RTN","HLUTIL2",58,0)
 ;  Get line from protocol file
"RTN","HLUTIL2",59,0)
 S LINE=$G(^ORD(101,IEN,770))
"RTN","HLUTIL2",60,0)
 ;
"RTN","HLUTIL2",61,0)
 ;-- get client (application that will receive the message
"RTN","HLUTIL2",62,0)
 S CLP=$P(LINE,U,2)
"RTN","HLUTIL2",63,0)
 S:(CLP) CLIENT=$P($G(^HL(771,CLP,0)),U,1)
"RTN","HLUTIL2",64,0)
 ;
"RTN","HLUTIL2",65,0)
 ;-- get message type received & generated
"RTN","HLUTIL2",66,0)
 S MTPR=$P(LINE,U,3)
"RTN","HLUTIL2",67,0)
 S MTPG=$P(LINE,U,11)
"RTN","HLUTIL2",68,0)
 S:(MTPR) MTPR=$P($G(^HL(771.2,MTPR,0)),U,1)
"RTN","HLUTIL2",69,0)
 S:(MTPG) MTPG=$P($G(^HL(771.2,MTPG,0)),U,1)
"RTN","HLUTIL2",70,0)
 ;
"RTN","HLUTIL2",71,0)
 ;-- get event type
"RTN","HLUTIL2",72,0)
 S ETP=$P(LINE,U,4)
"RTN","HLUTIL2",73,0)
 S:(ETP) EVENT=$P($G(^HL(779.001,ETP,0)),U,1)
"RTN","HLUTIL2",74,0)
 ;
"RTN","HLUTIL2",75,0)
 ;-- get message structure code
"RTN","HLUTIL2",76,0)
 S MTPEVP=$P(LINE,U,5)
"RTN","HLUTIL2",77,0)
 S:(MTPEVP) MTNEVN=$P($G(^HL(779.005,MTPEVP,0)),U,1)
"RTN","HLUTIL2",78,0)
 ;
"RTN","HLUTIL2",79,0)
 ;-- accept acknowledgement
"RTN","HLUTIL2",80,0)
 S ACKP=$P(LINE,U,8)
"RTN","HLUTIL2",81,0)
 S:(ACKP) ACCACK=$P($G(^HL(779.003,ACKP,0)),U,1)
"RTN","HLUTIL2",82,0)
 ;
"RTN","HLUTIL2",83,0)
 ;-- application acknowledgement
"RTN","HLUTIL2",84,0)
 S ACKTYP=$P(LINE,U,9)
"RTN","HLUTIL2",85,0)
 S:(ACKTYP) APPACK=$P($G(^HL(779.003,ACKTYP,0)),U,1)
"RTN","HLUTIL2",86,0)
 ;
"RTN","HLUTIL2",87,0)
 ;-- version of HL7
"RTN","HLUTIL2",88,0)
 S VERIDP=$P(LINE,U,10)
"RTN","HLUTIL2",89,0)
 S:(VERIDP) VERID=$P($G(^HL(771.5,VERIDP,0)),U,1)
"RTN","HLUTIL2",90,0)
 ;
"RTN","HLUTIL2",91,0)
 ;-- build return string
"RTN","HLUTIL2",92,0)
 S RETURN=CLIENT_U_MTPR_U_EVENT
"RTN","HLUTIL2",93,0)
 ;-- 6 processing id, 7 logical link pointer
"RTN","HLUTIL2",94,0)
 S RETURN=RETURN_U_MTNEVN_U_$P(LINE,U,6)_U_$P(LINE,U,7)
"RTN","HLUTIL2",95,0)
 S RETURN=RETURN_U_ACCACK_U_APPACK_U_VERID_U_MTPG
"RTN","HLUTIL2",96,0)
 Q RETURN
"RTN","HLUTIL2",97,0)
 ;
"RTN","HLUTIL2",98,0)
MSGADM(IEN) ; RETURN DATE/TIME ENTERED AND MSGID FROM FILE 773
"RTN","HLUTIL2",99,0)
 N X
"RTN","HLUTIL2",100,0)
 Q:'$G(^HLMA(+$G(IEN),0)) "-1"  S X=^(0)
"RTN","HLUTIL2",101,0)
 Q $P($G(^HL(772,+X,0)),"^")_"^"_$P(X,"^",2)
"RTN","HLUTIL2",102,0)
 ;
"RTN","HLUTIL2",103,0)
APPPRM(IEN) ; RETURN DATA FROM THE APPLICATION PARAMETER FILE
"RTN","HLUTIL2",104,0)
 N LINE,COUNTRYP,COUNTRY
"RTN","HLUTIL2",105,0)
 S IEN=$G(IEN)
"RTN","HLUTIL2",106,0)
 Q:(IEN="")
"RTN","HLUTIL2",107,0)
 S LINE=$G(^HL(771,IEN,0))
"RTN","HLUTIL2",108,0)
 S COUNTRYP=$P(LINE,"^",7),COUNTRY=""
"RTN","HLUTIL2",109,0)
 I COUNTRYP]"" S COUNTRY=$P(^HL(779.004,COUNTRYP,0),"^",1)
"RTN","HLUTIL2",110,0)
 S APPPRM(IEN,0)=$P(LINE,"^",1)_"^"_$P(LINE,"^",3)_"^"_COUNTRY
"RTN","HLUTIL2",111,0)
 S APPPRM(IEN,"EC")=$G(^HL(771,IEN,"EC"))
"RTN","HLUTIL2",112,0)
 S:(APPPRM(IEN,"EC")="") APPPRM(IEN,"EC")="~|\&"
"RTN","HLUTIL2",113,0)
 S APPPRM(IEN,"FS")=$G(^HL(771,IEN,"FS"))
"RTN","HLUTIL2",114,0)
 S:(APPPRM(IEN,"FS")="") APPPRM(IEN,"FS")="^"
"RTN","HLUTIL2",115,0)
 Q
"RTN","HLUTIL2",116,0)
CLRQUE ; Clear a queue by menu option
"RTN","HLUTIL2",117,0)
 N DIC,DIR,DIRUT,HLDIR,HLERR,HLIEN,HLL,HLLTC,X,Y
"RTN","HLUTIL2",118,0)
 S DIC="^HLCS(870,",DIC(0)="AEQMZ"
"RTN","HLUTIL2",119,0)
 D ^DIC Q:Y<0
"RTN","HLUTIL2",120,0)
 K DIC S HLIEN=+Y,HLL=$P(Y(0),U,3)
"RTN","HLUTIL2",121,0)
 L +^HLCS(870,HLIEN):1 E  W !!,"Couldn't Lock Record, Try later.",! Q
"RTN","HLUTIL2",122,0)
 S DIR(0)="S^B:BOTH QUEUES;I:IN QUEUE;O:OUT QUEUE",DIR("?")="Select the queue (in, out, or both) you would like cleared"
"RTN","HLUTIL2",123,0)
 S DIR("A")="Enter which queue to clear",DIR("B")="B"
"RTN","HLUTIL2",124,0)
 D ^DIR K DIR
"RTN","HLUTIL2",125,0)
 S HLDIR=$S(Y="I":"IN",Y="O":"OUT",Y="B":"BOTH",1:1)
"RTN","HLUTIL2",126,0)
 I HLDIR=1!$D(DIRUT) L -^HLCS(870,HLIEN) Q
"RTN","HLUTIL2",127,0)
 ;HLLTC= TCP service type
"RTN","HLUTIL2",128,0)
 S:HLL HLLTC=$P($G(^HLCS(870,HLIEN,400)),U,3)
"RTN","HLUTIL2",129,0)
 ;TCP link
"RTN","HLUTIL2",130,0)
 I $G(HLLTC)]"" D  L -^HLCS(870,HLIEN) Q
"RTN","HLUTIL2",131,0)
 . ;multiple server, set STATE and SHUTDOWN LLP?
"RTN","HLUTIL2",132,0)
 . S:HLLTC="M" X=^HLCS(870,HLIEN,0),$P(X,U,5)="0 server",$P(X,U,15)=0,^(0)=X
"RTN","HLUTIL2",133,0)
 . I HLDIR="BOTH" D  Q
"RTN","HLUTIL2",134,0)
 .. F X="IN","OUT" D CLRQUET(X)
"RTN","HLUTIL2",135,0)
 . ;do one que
"RTN","HLUTIL2",136,0)
 . D CLRQUET(HLDIR)
"RTN","HLUTIL2",137,0)
 ;
"RTN","HLUTIL2",138,0)
 I HLDIR="BOTH" D
"RTN","HLUTIL2",139,0)
 . S HLERR=$$CLEARQUE^HLCSQUE(HLIEN,"OUT")
"RTN","HLUTIL2",140,0)
 . I HLERR W !,"Error in clearing out queue:",$P(HLERR,"^",2)
"RTN","HLUTIL2",141,0)
 . S HLERR=$$CLEARQUE^HLCSQUE(HLIEN,"IN")
"RTN","HLUTIL2",142,0)
 . I HLERR W !,"Error in clearing in queue:",$P(HLERR,"^",2)
"RTN","HLUTIL2",143,0)
 I HLDIR'="BOTH" S HLERR=$$CLEARQUE^HLCSQUE(HLIEN,HLDIR)
"RTN","HLUTIL2",144,0)
 L -^HLCS(870,HLIEN)
"RTN","HLUTIL2",145,0)
 Q
"RTN","HLUTIL2",146,0)
CLRQUET(Y) ;subroutine for TCP links, Y=IN or OUT
"RTN","HLUTIL2",147,0)
 Q:Y'="IN"&(Y'="OUT")
"RTN","HLUTIL2",148,0)
 N C,N,X
"RTN","HLUTIL2",149,0)
 S N=$E(Y),X=0
"RTN","HLUTIL2",150,0)
 ;get count of what is pending
"RTN","HLUTIL2",151,0)
 F C=0:1 S X=$O(^HLMA("AC",N,HLIEN,X)) Q:'X
"RTN","HLUTIL2",152,0)
 ;reset counters for messages
"RTN","HLUTIL2",153,0)
 S ^HLCS(870,HLIEN,Y_" QUEUE BACK POINTER")=C,^(Y_" QUEUE FRONT POINTER")=0
"RTN","HLUTIL2",154,0)
 Q
"RTN","HLUTIL2",155,0)
 ;
"RTN","HLUTIL2",156,0)
SHGLLP ; Show Gross LLP Error
"RTN","HLUTIL2",157,0)
 N DIC,IEN,ERR
"RTN","HLUTIL2",158,0)
 S DIC="^HLCS(870,"
"RTN","HLUTIL2",159,0)
 S DIC(0)="AEQM"
"RTN","HLUTIL2",160,0)
 D ^DIC K DIC
"RTN","HLUTIL2",161,0)
 S IEN=$P(Y,"^",1)
"RTN","HLUTIL2",162,0)
 S ERR=$P($G(^HLCS(870,IEN,0)),"^",19)
"RTN","HLUTIL2",163,0)
 W:(ERR'="") !,"Error: "_$P($G(^HL(771.7,ERR,0)),"^",1),!
"RTN","HLUTIL2",164,0)
 W:(ERR="") !,"No Gross LLP error found",!
"RTN","HLUTIL2",165,0)
 Q
"RTN","HLUTIL2",166,0)
CLGLLP ; Clear Gross LLP error
"RTN","HLUTIL2",167,0)
 N DIC,IEN,ERR,DA,DR
"RTN","HLUTIL2",168,0)
 S DIC="^HLCS(870,"
"RTN","HLUTIL2",169,0)
 S DIC(0)="AEQM"
"RTN","HLUTIL2",170,0)
 D ^DIC K DIC
"RTN","HLUTIL2",171,0)
 S IEN=$P(Y,"^",1)
"RTN","HLUTIL2",172,0)
 Q:(IEN<0)
"RTN","HLUTIL2",173,0)
 S DIE="^HLCS(870,"
"RTN","HLUTIL2",174,0)
 S DA=IEN
"RTN","HLUTIL2",175,0)
 S DR="18///@"
"RTN","HLUTIL2",176,0)
 D ^DIE K DIE
"RTN","HLUTIL2",177,0)
 Q
"SEC","^DIC",779.005,779.005,0,"AUDIT")

"SEC","^DIC",779.005,779.005,0,"DD")

"SEC","^DIC",779.005,779.005,0,"DEL")

"SEC","^DIC",779.005,779.005,0,"LAYGO")

"SEC","^DIC",779.005,779.005,0,"RD")

"SEC","^DIC",779.005,779.005,0,"WR")

"VER")
8.0^22.0
"^DD",101,101,770.5,0)
MESSAGE STRUCTURE^P779.005'^HL(779.005,^770;5^Q
"^DD",101,101,770.5,3)
Enter the HL7 message structure code.
"^DD",101,101,770.5,21,0)
^^1^1^3000119^
"^DD",101,101,770.5,21,1,0)
The message structure is associated with the message type and event type defined by HL7 v2.3.1 and beyond.
"^DD",101,101,770.5,"DT")
3000119
"^DD",101,101,770.6,0)
PROCESSING ID^S^D:debug;^770;6^Q
"^DD",101,101,770.6,3)
Set this only for DEBUG MODE. Use HL7 site params for Test or Production
"^DD",101,101,770.6,21,0)
^^13^13^3000509^
"^DD",101,101,770.6,21,1,0)
This field describes how a message should be processed once it is handed
"^DD",101,101,770.6,21,2,0)
off to the receiving application. 
"^DD",101,101,770.6,21,3,0)
 
"^DD",101,101,770.6,21,4,0)
PROCESSING ID is a required field in the HL7 message header. However, the
"^DD",101,101,770.6,21,5,0)
Event Driver protocol entry is only used whenset to DEBUG. Data for the
"^DD",101,101,770.6,21,6,0)
header is normally derived from the HL COMMUNICATION SERVER FILE. If
"^DD",101,101,770.6,21,7,0)
testing a transaction in Debug mode, make sure it is changed on both the
"^DD",101,101,770.6,21,8,0)
sending and receiving system.
"^DD",101,101,770.6,21,9,0)
 
"^DD",101,101,770.6,21,10,0)
 
"^DD",101,101,770.6,21,11,0)
The receiving application developer should consider checking this portion
"^DD",101,101,770.6,21,12,0)
of the header before filing data on a production system. Training and
"^DD",101,101,770.6,21,13,0)
Debug messages may not be suitable for filing.
"^DD",101,101,770.6,"DT")
3000509
"^DD",771,771,100,0)
HL7 FIELD SEPARATOR^FX^^FS;E1,2^K:$L(X)>1!($L(X)<1)!'(X?1P) X S HLEC=$G(^HL(771,DA,"EC")) I HLEC]"",HLEC[X K X
"^DD",771,771,100,3)
The HL7 field separator used by the DHCP application.  If this field is not filled in, the uparrow (^) character is defaulted to as the field separator.  Answer must be 1 character in length.
"^DD",771,771,100,21,0)
^^16^16^3000418^
"^DD",771,771,100,21,1,0)
The field separator separates two adjacent fields within a segment.  It
"^DD",771,771,100,21,2,0)
also separates the segment ID from the first data field in the segment.
"^DD",771,771,100,21,3,0)
The field separator can be defined differently for each HL7 message.  The
"^DD",771,771,100,21,4,0)
fourth character in the MSH segment serves as the field separator for
"^DD",771,771,100,21,5,0)
all segments in the HL7 message.
"^DD",771,771,100,21,6,0)
 
"^DD",771,771,100,21,7,0)
If this field is left blank, the default will be the '^' character.
"^DD",771,771,100,21,8,0)
However, most messaging applications use the '|' as a field separator.
"^DD",771,771,100,21,9,0)
 
"^DD",771,771,100,21,10,0)
Note that the character used as a field separator CANNOT be reused as one
"^DD",771,771,100,21,11,0)
of the HL7 ENCODING CHARACTERS. If you choose the default '^' as a
"^DD",771,771,100,21,12,0)
field separator then choose the default encoding characters as well
"^DD",771,771,100,21,13,0)
(~|\&). If you choose the vertical bar as a field separator, then simply
"^DD",771,771,100,21,14,0)
replace the vertical bar in the encoding characters with the '^', i.e.,
"^DD",771,771,100,21,15,0)
~^\&. Due to Fileman limitations, the '^' cannot be the first character in
"^DD",771,771,100,21,16,0)
the encoding character string.
"^DD",771,771,100,"DT")
3000418
"^DD",771,771,101,0)
HL7 ENCODING CHARACTERS^FX^^EC;E1,4^K:$L(X)>4!($L(X)<1)!'(X?1.4P) X S HLFS=$G(^HL(771,DA,"FS")) S:HLFS="" HLFS="^" I X[HLFS K X
"^DD",771,771,101,3)
The HL7 encoding characters used by the DHCP application.  If this field is not filled in, the characters ~|\& are used as the default encoding characters.  Answer must be 1-4 characters in length.
"^DD",771,771,101,21,0)
^^36^36^3000418^
"^DD",771,771,101,21,1,0)
If this field is left blank, the default encoding characters will be set
"^DD",771,771,101,21,2,0)
to, "~|\&". Note that if you choose this default, the FIELD SEPARATOR must
"^DD",771,771,101,21,3,0)
be set to "^". If you choose the vertical bar ("|") as a field separator,
"^DD",771,771,101,21,4,0)
enter "~^\&" as your encoding characters. This will avoid a potential
"^DD",771,771,101,21,5,0)
conflict with VA Fileman.
"^DD",771,771,101,21,6,0)
 
"^DD",771,771,101,21,7,0)
Up to four encoding characters may be defined. Each encoding character
"^DD",771,771,101,21,8,0)
must be unique and none of the encoding characters may be the same as the
"^DD",771,771,101,21,9,0)
field separator character. Each encoding character serves a specific
"^DD",771,771,101,21,10,0)
purpose.
"^DD",771,771,101,21,11,0)
 
"^DD",771,771,101,21,12,0)
The first encoding character is the component separator.  Some data
"^DD",771,771,101,21,13,0)
fields may be divided into multiple components.  The component separator
"^DD",771,771,101,21,14,0)
is used to separate adjacent components within a data field.
"^DD",771,771,101,21,15,0)
 
"^DD",771,771,101,21,16,0)
The second encoding character is the repetition separator.  Some data
"^DD",771,771,101,21,17,0)
fields may be repeated multiple times in a segment.  The repetition
"^DD",771,771,101,21,18,0)
separator character is used to separate multiple occurrences of a field.
"^DD",771,771,101,21,19,0)
 
"^DD",771,771,101,21,20,0)
The third encoding character is the escape character.  Data fields
"^DD",771,771,101,21,21,0)
defined as text or formatted text may include escape sequences.  The
"^DD",771,771,101,21,22,0)
escape character is used to separate escape sequences from the actual
"^DD",771,771,101,21,23,0)
text.
"^DD",771,771,101,21,24,0)
 
"^DD",771,771,101,21,25,0)
The fourth encoding character is the sub-component separator.  Some data
"^DD",771,771,101,21,26,0)
fields may be divided into components, and each component may be further
"^DD",771,771,101,21,27,0)
divided into sub-components. The sub-component separator is used to
"^DD",771,771,101,21,28,0)
separate adjacent sub-components within a component of a field.
"^DD",771,771,101,21,29,0)
 
"^DD",771,771,101,21,30,0)
Note that the character used as a field separator CANNOT be reused as one
"^DD",771,771,101,21,31,0)
of the HL7 ENCODING CHARACTERS. If you choose the default '^' as a
"^DD",771,771,101,21,32,0)
field separator then choose the default encoding characters as well
"^DD",771,771,101,21,33,0)
(~|\&). If you choose the vertical bar as a field separator, then simply
"^DD",771,771,101,21,34,0)
replace the vertical bar in the encoding characters with the '^', i.e.,
"^DD",771,771,101,21,35,0)
~^\&. Due to Fileman limitations, the '^' cannot be the first character in
"^DD",771,771,101,21,36,0)
the encoding character string.
"^DD",771,771,101,"DT")
3000418
"^DD",779.005,779.005,0)
FIELD^^3^3
"^DD",779.005,779.005,0,"DDA")
N
"^DD",779.005,779.005,0,"DT")
3000113
"^DD",779.005,779.005,0,"IX","B",779.005,.01)

"^DD",779.005,779.005,0,"NM","HL7 MESSAGE STRUCTURE CODE")

"^DD",779.005,779.005,0,"PT",101,770.5)

"^DD",779.005,779.005,.01,0)
CODE^RF^^0;1^K:$L(X)>10!($L(X)<3)!'(X'?1P.E) X
"^DD",779.005,779.005,.01,1,0)
^.1
"^DD",779.005,779.005,.01,1,1,0)
779.005^B
"^DD",779.005,779.005,.01,1,1,1)
S ^HL(779.005,"B",$E(X,1,30),DA)=""
"^DD",779.005,779.005,.01,1,1,2)
K ^HL(779.005,"B",$E(X,1,30),DA)
"^DD",779.005,779.005,.01,3)
Enter the message structure code.  Answer must be 3-10 characters in length.
"^DD",779.005,779.005,.01,21,0)
^^2^2^3000113^^^
"^DD",779.005,779.005,.01,21,1,0)
This is the abstract message structure code defined by HL7 Table 0354 -
"^DD",779.005,779.005,.01,21,2,0)
Message Structure, which is the third component in MSH-9-message type.
"^DD",779.005,779.005,.01,"DT")
3000113
"^DD",779.005,779.005,2,0)
DESCRIPTION^RF^^0;2^K:$L(X)>200!($L(X)<3) X
"^DD",779.005,779.005,2,3)
Answer must be 3-200 characters in length.
"^DD",779.005,779.005,2,21,0)
^^2^2^3000113^
"^DD",779.005,779.005,2,21,1,0)
List the various HL7 trigger events that use the particular abstract
"^DD",779.005,779.005,2,21,2,0)
message structure definition.
"^DD",779.005,779.005,2,"DT")
3000113
"^DD",779.005,779.005,3,0)
VERSION^779.0053P^^1;0
"^DD",779.005,779.0053,0)
VERSION SUB-FIELD^^.01^1
"^DD",779.005,779.0053,0,"DT")
3000113
"^DD",779.005,779.0053,0,"IX","B",779.0053,.01)

"^DD",779.005,779.0053,0,"NM","VERSION")

"^DD",779.005,779.0053,0,"UP")
779.005
"^DD",779.005,779.0053,.01,0)
VERSION^RP771.5'^HL(771.5,^0;1^Q
"^DD",779.005,779.0053,.01,1,0)
^.1
"^DD",779.005,779.0053,.01,1,1,0)
779.0053^B
"^DD",779.005,779.0053,.01,1,1,1)
S ^HL(779.005,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",779.005,779.0053,.01,1,1,2)
K ^HL(779.005,DA(1),1,"B",$E(X,1,30),DA)
"^DD",779.005,779.0053,.01,3)
The version(s) of the standard in which this message structure code is used.
"^DD",779.005,779.0053,.01,"DT")
3000113
"^DIC",779.005,779.005,0)
HL7 MESSAGE STRUCTURE CODE^779.005
"^DIC",779.005,779.005,0,"GL")
^HL(779.005,
"^DIC",779.005,779.005,"%",0)
^1.005^^
"^DIC",779.005,779.005,"%D",0)
^^3^3^3000113^
"^DIC",779.005,779.005,"%D",1,0)
This file is a table of message structure codes that are defined by HL7
"^DIC",779.005,779.005,"%D",2,0)
table 0354.
"^DIC",779.005,779.005,"%D",3,0)
This file should not be modified locally.
"^DIC",779.005,"B","HL7 MESSAGE STRUCTURE CODE",779.005)

**END**
**END**
