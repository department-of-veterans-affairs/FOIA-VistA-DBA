Released HL*1.6*118 SEQ #100
Extracted from mail message
**KIDS**:HL*1.6*118^

**INSTALL NAME**
HL*1.6*118
"BLD",828,0)
HL*1.6*118^HEALTH LEVEL SEVEN^0^3050805^y
"BLD",828,1,0)
^^1^1^3040701^
"BLD",828,1,1,0)
HL7 parsing utilities.
"BLD",828,4,0)
^9.64PA^^
"BLD",828,"KRN",0)
^9.67PA^8989.52^19
"BLD",828,"KRN",.4,0)
.4
"BLD",828,"KRN",.401,0)
.401
"BLD",828,"KRN",.402,0)
.402
"BLD",828,"KRN",.403,0)
.403
"BLD",828,"KRN",.5,0)
.5
"BLD",828,"KRN",.84,0)
.84
"BLD",828,"KRN",3.6,0)
3.6
"BLD",828,"KRN",3.8,0)
3.8
"BLD",828,"KRN",9.2,0)
9.2
"BLD",828,"KRN",9.8,0)
9.8
"BLD",828,"KRN",9.8,"NM",0)
^9.68A^4^4
"BLD",828,"KRN",9.8,"NM",1,0)
HLPRS^^0^18693372
"BLD",828,"KRN",9.8,"NM",2,0)
HLMSG^^0^9665720
"BLD",828,"KRN",9.8,"NM",3,0)
HLOPRS^^0^30015761
"BLD",828,"KRN",9.8,"NM",4,0)
HLOPRS1^^0^13347617
"BLD",828,"KRN",9.8,"NM","B","HLMSG",2)

"BLD",828,"KRN",9.8,"NM","B","HLOPRS",3)

"BLD",828,"KRN",9.8,"NM","B","HLOPRS1",4)

"BLD",828,"KRN",9.8,"NM","B","HLPRS",1)

"BLD",828,"KRN",19,0)
19
"BLD",828,"KRN",19.1,0)
19.1
"BLD",828,"KRN",101,0)
101
"BLD",828,"KRN",409.61,0)
409.61
"BLD",828,"KRN",771,0)
771
"BLD",828,"KRN",870,0)
870
"BLD",828,"KRN",8989.51,0)
8989.51
"BLD",828,"KRN",8989.52,0)
8989.52
"BLD",828,"KRN",8994,0)
8994
"BLD",828,"KRN","B",.4,.4)

"BLD",828,"KRN","B",.401,.401)

"BLD",828,"KRN","B",.402,.402)

"BLD",828,"KRN","B",.403,.403)

"BLD",828,"KRN","B",.5,.5)

"BLD",828,"KRN","B",.84,.84)

"BLD",828,"KRN","B",3.6,3.6)

"BLD",828,"KRN","B",3.8,3.8)

"BLD",828,"KRN","B",9.2,9.2)

"BLD",828,"KRN","B",9.8,9.8)

"BLD",828,"KRN","B",19,19)

"BLD",828,"KRN","B",19.1,19.1)

"BLD",828,"KRN","B",101,101)

"BLD",828,"KRN","B",409.61,409.61)

"BLD",828,"KRN","B",771,771)

"BLD",828,"KRN","B",870,870)

"BLD",828,"KRN","B",8989.51,8989.51)

"BLD",828,"KRN","B",8989.52,8989.52)

"BLD",828,"KRN","B",8994,8994)

"MBREQ")
0
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
118^3050805
"PKG",9,22,1,"PAH",1,1,0)
^^1^1^3050805
"PKG",9,22,1,"PAH",1,1,1,0)
HL7 parsing utilities.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
4
"RTN","HLMSG")
0^2^B9665720
"RTN","HLMSG",1,0)
HLMSG ;ALB/CJM-HL7 - APIs for files 772/773 ;02/04/2004
"RTN","HLMSG",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**118**;Oct 13, 1995
"RTN","HLMSG",3,0)
 ;
"RTN","HLMSG",4,0)
GETMSG(IEN,MSG) ;
"RTN","HLMSG",5,0)
 ;Description: given the message ien=MSGIEN (required), it returns the MSG array containing information about the message, defined below.
"RTN","HLMSG",6,0)
 ;Input:
"RTN","HLMSG",7,0)
 ;  IEN - the ien of the message in file 773
"RTN","HLMSG",8,0)
 ;Output:
"RTN","HLMSG",9,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLMSG",10,0)
 ;  MSG (pass by reference, required) These are the subscripts returned:
"RTN","HLMSG",11,0)
 ;    "BATCH"  = 1 if this is a batch message, 0  if not
"RTN","HLMSG",12,0)
 ;       "CURRENT MESSAGE" - defined only for batch messages -  a counter used during building and parsing messages to indicate the current message.  It will be set to 0 initially.
"RTN","HLMSG",13,0)
 ;  "BODY" - ptr to file 772 which contains the body of the message.
"RTN","HLMSG",14,0)
 ;  "CURRENT LINE" -  a counter used during building and parsing of
"RTN","HLMSG",15,0)
 ;     messages to indicate the current line within the message. For
"RTN","HLMSG",16,0)
 ;     batch messages where each message within the batch is stored
"RTN","HLMSG",17,0)
 ;     separately, this field indicates the position within the current
"RTN","HLMSG",18,0)
 ;     individual message
"RTN","HLMSG",19,0)
 ;  "HDR" - the header segment, NOT parsed, as a sequence of lines HDR(i)
"RTN","HLMSG",20,0)
 ;  "IEN" - ien, file 773
"RTN","HLMSG",21,0)
 ;
"RTN","HLMSG",22,0)
 K MSG
"RTN","HLMSG",23,0)
 Q:'$G(IEN) 0
"RTN","HLMSG",24,0)
 N I
"RTN","HLMSG",25,0)
 S MSG("IEN")=IEN
"RTN","HLMSG",26,0)
 S MSG("BODY")=$P($G(^HLMA(IEN,0)),"^")
"RTN","HLMSG",27,0)
 Q:'MSG("BODY") 0
"RTN","HLMSG",28,0)
 ;
"RTN","HLMSG",29,0)
 S MSG("BATCH")=$S($P(^HL(772,MSG("BODY"),0),"^",14)="B":1,1:0)
"RTN","HLMSG",30,0)
 I MSG("BATCH") S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLMSG",31,0)
 S MSG("CURRENT LINE")=0
"RTN","HLMSG",32,0)
 S I=0
"RTN","HLMSG",33,0)
 F  S I=$O(^HLMA(IEN,"MSH",I)) Q:'I  S MSG("HDR",I)=$G(^HLMA(IEN,"MSH",I,0))
"RTN","HLMSG",34,0)
 Q 1
"RTN","HLMSG",35,0)
 ;
"RTN","HLMSG",36,0)
NEXTSEG(MSG,SEG) ;
"RTN","HLMSG",37,0)
 ;Description:  Returns the next segment as a set of lines stored in SEG.
"RTN","HLMSG",38,0)
 ;Input:
"RTN","HLMSG",39,0)
 ;  MSG (pass by reference, required)
"RTN","HLMSG",40,0)
 ;Output:
"RTN","HLMSG",41,0)
 ;  Function returns 1 on success, 0 on failure (no more segments)
"RTN","HLMSG",42,0)
 ;  SEG (pass by reference, required)
"RTN","HLMSG",43,0)
 ;
"RTN","HLMSG",44,0)
 K SEG
"RTN","HLMSG",45,0)
 Q:MSG("CURRENT LINE")=-1 0
"RTN","HLMSG",46,0)
 I 'MSG("BATCH") D
"RTN","HLMSG",47,0)
 .N I,J
"RTN","HLMSG",48,0)
 .S J=1,I=MSG("CURRENT LINE")
"RTN","HLMSG",49,0)
 .F  S I=$O(^HL(772,MSG("BODY"),"IN",I)) Q:'I  Q:$G(^HL(772,MSG("BODY"),"IN",I,0))=""  S SEG(J)=^HL(772,MSG("BODY"),"IN",I,0),J=J+1
"RTN","HLMSG",50,0)
 .I 'I S MSG("CURRENT LINE")=-1
"RTN","HLMSG",51,0)
 .I I S MSG("CURRENT LINE")=I
"RTN","HLMSG",52,0)
 I MSG("BATCH") D
"RTN","HLMSG",53,0)
 .N I,J
"RTN","HLMSG",54,0)
 .S I=MSG("CURRENT LINE")
"RTN","HLMSG",55,0)
 .F  S I=$O(^HL(772,MSG("BODY"),"IN",I)) Q:'I  I $G(^HL(772,MSG("BODY"),"IN",I,0))'="" D  Q
"RTN","HLMSG",56,0)
 ..Q:$E($G(^HL(772,MSG("BODY"),"IN",I,0)),1,3)="MSH"
"RTN","HLMSG",57,0)
 ..I $E($G(^HL(772,MSG("BODY"),"IN",I,0)),1,3)="BTS" S MSG("CURRENT LINE")=-1,MSG("BATCH","CURRENT MESSAGE")=-1 Q
"RTN","HLMSG",58,0)
 ..S SEG(1)=$G(^HL(772,MSG("BODY"),"IN",I,0))
"RTN","HLMSG",59,0)
 ..S J=2
"RTN","HLMSG",60,0)
 ..F  S I=$O(^HL(772,MSG("BODY"),"IN",I)) Q:'I  Q:$G(^HL(772,MSG("BODY"),"IN",I,0))=""  S SEG(J)=^HL(772,MSG("BODY"),"IN",I,0),J=J+1
"RTN","HLMSG",61,0)
 .I 'I S MSG("CURRENT LINE")=-1
"RTN","HLMSG",62,0)
 .I I S MSG("CURRENT LINE")=I-1
"RTN","HLMSG",63,0)
 Q $S($D(SEG):1,1:0)
"RTN","HLMSG",64,0)
 ;
"RTN","HLMSG",65,0)
NEXTMSG(MSG,HDR) ;
"RTN","HLMSG",66,0)
 ;Advances to the next message in the batch
"RTN","HLMSG",67,0)
 ;Input:
"RTN","HLMSG",68,0)
 ;  MSG (pass by reference, required) - defined by $$GETMSG()
"RTN","HLMSG",69,0)
 ;Output:
"RTN","HLMSG",70,0)
 ;  Function returns 1 on success, 0 if no more messages
"RTN","HLMSG",71,0)
 ;  MSH - updated with current position in the message
"RTN","HLMSG",72,0)
 ;  HDR (pass by reference, required) returns the header as an array of 2lines HDR(1),HDR(2)
"RTN","HLMSG",73,0)
 ;
"RTN","HLMSG",74,0)
 K HDR
"RTN","HLMSG",75,0)
 N ARY,I,J
"RTN","HLMSG",76,0)
 S ARY="^HL(772,"_MSG("BODY")_",""IN"")"
"RTN","HLMSG",77,0)
 S I=MSG("CURRENT LINE")
"RTN","HLMSG",78,0)
 F  S I=$O(@ARY@(I)) Q:'I  D:$G(@ARY@(I,0))'=""  Q:$D(HDR)  Q:MSG("CURRENT LINE")=-1
"RTN","HLMSG",79,0)
 .I $E($G(@ARY@(I,0)),1,3)="BTS" S MSG("CURRENT LINE")=-1,MSG("BATCH","CURRENT MESSAGE")=-1 Q
"RTN","HLMSG",80,0)
 .I $E($G(@ARY@(I,0)),1,3)="MSH" D
"RTN","HLMSG",81,0)
 ..S J=1
"RTN","HLMSG",82,0)
 ..S HDR(J)=$G(@ARY@(I,0)),MSG("CURRENT LINE")=I,MSG("BATCH","CURRENT MESSAGE")=$G(MSG("BATCH","CURRENT MESSAGE"))+1
"RTN","HLMSG",83,0)
 ..F  S I=$O(@ARY@(I)) Q:'I  Q:$G(@ARY@(I,0))=""  S J=J+1,HDR(J)=$G(@ARY@(I,0))
"RTN","HLMSG",84,0)
 .E  D
"RTN","HLMSG",85,0)
 ..F  S I=$O(@ARY@(I)) Q:'I  Q:$G(@ARY@(I,0))=""
"RTN","HLMSG",86,0)
 Q $S($D(HDR):1,1:0)
"RTN","HLOPRS")
0^3^B30015761
"RTN","HLOPRS",1,0)
HLOPRS ;IRMFO-ALB/CJM -RTNs for parsing messages;03/24/2004  14:43
"RTN","HLOPRS",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**118**;Oct 13, 1995
"RTN","HLOPRS",3,0)
 ;
"RTN","HLOPRS",4,0)
STARTMSG(MSG,IEN,HDR) ;
"RTN","HLOPRS",5,0)
 ;Description:  This function begins the parsing of the message, parsing
"RTN","HLOPRS",6,0)
 ;the header and returning the individual values in the array HDR().
"RTN","HLOPRS",7,0)
 ;Input: 
"RTN","HLOPRS",8,0)
 ;  IEN - The internal entry number of the message in file 778.
"RTN","HLOPRS",9,0)
 ;Output:
"RTN","HLOPRS",10,0)
 ;  Function returns 1 on success, 0 on failure.  Failure would indicate that the message was not found.
"RTN","HLOPRS",11,0)
 ;  MSG - (pass by reference, required) This array is used by the HL7 package to track the progress of parsing the message.  The application MUST NOT touch it!
"RTN","HLOPRS",12,0)
 ;  HDR (pass by reference, optional)   This array contains the results of parsing the message header.
"RTN","HLOPRS",13,0)
 K MSG,HDR
"RTN","HLOPRS",14,0)
 Q:'$G(IEN) 0
"RTN","HLOPRS",15,0)
 Q:'$$GETMSG^HLOMSG(IEN,.MSG) 0
"RTN","HLOPRS",16,0)
 M HDR=MSG("HDR")
"RTN","HLOPRS",17,0)
 Q:'$$PARSEHDR(.HDR) 0
"RTN","HLOPRS",18,0)
 M MSG("HDR")=HDR
"RTN","HLOPRS",19,0)
 Q 1
"RTN","HLOPRS",20,0)
 ;
"RTN","HLOPRS",21,0)
NEXTSEG(MSG,SEG) ;
"RTN","HLOPRS",22,0)
 ;Description:  Advances parsing to the next segment and returns the parsed values from that segment.
"RTN","HLOPRS",23,0)
 ;Input:
"RTN","HLOPRS",24,0)
 ;  MSG - (pass by reference, required) This array is used by the HL7 package to track the current position in the message.  The application MUST NOT touch it!
"RTN","HLOPRS",25,0)
 ;Output:
"RTN","HLOPRS",26,0)
 ;  Function  returns 1 on success, 0 if there are no more segments in this message.  For batch messages, a return value of 0 does not preclude the possibility that there are additional individual messages within the batch.
"RTN","HLOPRS",27,0)
 ;  MSG - (pass by reference, required)
"RTN","HLOPRS",28,0)
 ;  SEG - (pass by reference, required)  The segment is returned in this array.
"RTN","HLOPRS",29,0)
 ;
"RTN","HLOPRS",30,0)
 N TEMP,CODES
"RTN","HLOPRS",31,0)
 K SEG
"RTN","HLOPRS",32,0)
 I '$$HLNEXT^HLOMSG(.MSG,.TEMP) Q 0
"RTN","HLOPRS",33,0)
 S CODES=MSG("HDR","ENCODING CHARACTERS")
"RTN","HLOPRS",34,0)
 Q $$PARSE^HLOPRS1(MSG("HDR","FIELD SEPARATOR"),$E(CODES,2),$E(CODES,1),$E(CODES,4),$E(CODES,3),.TEMP,.SEG)
"RTN","HLOPRS",35,0)
 ;
"RTN","HLOPRS",36,0)
NEXTMSG(MSG,MSH) ;
"RTN","HLOPRS",37,0)
 ;Description:  Advances to the next message within the batch, with the MSH segment returned.
"RTN","HLOPRS",38,0)
 ;Input:
"RTN","HLOPRS",39,0)
 ; MSG (pass by reference, required) This array is used by the HL7 package to track the current position in the message.  The application MUST NOT touch it!
"RTN","HLOPRS",40,0)
 ;OUTPUT:
"RTN","HLOPRS",41,0)
 ;  Function returns 1 on success, 0 if there are no more messages
"RTN","HLOPRS",42,0)
 ;  MSG - (pass by reference)
"RTN","HLOPRS",43,0)
 ;  MSH - (pass by reference, required) Returns the parsed message header
"RTN","HLOPRS",44,0)
 ;
"RTN","HLOPRS",45,0)
 K MSH
"RTN","HLOPRS",46,0)
 N NODE
"RTN","HLOPRS",47,0)
 Q:'$$NEXTMSG^HLOMSG(.MSG,.MSH) 0
"RTN","HLOPRS",48,0)
 Q:'$$PARSEHDR(.MSH) 0
"RTN","HLOPRS",49,0)
 S MSG("BATCH","CURRENT MESSAGE","EVENT")=MSH("EVENT")
"RTN","HLOPRS",50,0)
 S MSG("BATCH","CURRENT MESSAGE","MESSAGE CONTROL ID")=MSH("MESSAGE CONTROL ID")
"RTN","HLOPRS",51,0)
 S NODE=$G(^HLB(MSG("IEN"),3,MSG("BATCH","CURRENT MESSAGE"),0))
"RTN","HLOPRS",52,0)
 S MSG("BATCH","CURRENT MESSAGE","ACK TO")=$P(NODE,"^",3)
"RTN","HLOPRS",53,0)
 S MSG("BATCH","CURRENT MESSAGE","ACK BY")=$P(NODE,"^",4)
"RTN","HLOPRS",54,0)
 ;
"RTN","HLOPRS",55,0)
 I MSG("BATCH","CURRENT MESSAGE","ACK TO")]"" S MSG("BATCH","CURRENT MESSAGE","ACK TO IEN")=$$ACKTOIEN^HLOMSG1(MSG("MESSAGE CONTROL ID"),MSG("BATCH","CURRENT MESSAGE","ACK TO"))
"RTN","HLOPRS",56,0)
 I MSG("BATCH","CURRENT MESSAGE","ACK BY")]"" S MSG("BATCH","CURRENT MESSAGE","ACK BY IEN")=$$ACKBYIEN^HLOMSG1(MSG("MESSAGE CONTROL ID"),MSG("BATCH","CURRENT MESSAGE","ACK BY"))
"RTN","HLOPRS",57,0)
 ;
"RTN","HLOPRS",58,0)
 Q 1
"RTN","HLOPRS",59,0)
 ;
"RTN","HLOPRS",60,0)
PARSEHDR(HDR) ;
"RTN","HLOPRS",61,0)
 ;Parses the segment (HDR, pass by reference) into the HDR() array using meaningful subscripts.
"RTN","HLOPRS",62,0)
 ;Input:
"RTN","HLOPRS",63,0)
 ;  HDR (pass by reference, required) contains the segment in the format HDR(1),HDR(2), etc..
"RTN","HLOPRS",64,0)
 ;Output:
"RTN","HLOPRS",65,0)
 ;  HDR (pass by reference, required) This array will contain all the individual values.  Also will contain HDR(1) with components 1-6 and HDR(2) with components 1-end
"RTN","HLOPRS",66,0)
 ;  Function - returns 1 if the segment is indeed an MSH or BHS segment, 0 otherwise
"RTN","HLOPRS",67,0)
 ;
"RTN","HLOPRS",68,0)
 N VALUE,FS,CS,REP,SUBCOMP,ESCAPE
"RTN","HLOPRS",69,0)
 S VALUE=$E(HDR(1),1,3)
"RTN","HLOPRS",70,0)
 I VALUE'="MSH",VALUE'="BHS" Q 0
"RTN","HLOPRS",71,0)
 S HDR("SEGMENT TYPE")=VALUE
"RTN","HLOPRS",72,0)
 S FS=$E(HDR(1),4)
"RTN","HLOPRS",73,0)
 S CS=$E(HDR(1),5)
"RTN","HLOPRS",74,0)
 S REP=$E(HDR(1),6)
"RTN","HLOPRS",75,0)
 S ESCAPE=$E(HDR(1),7)
"RTN","HLOPRS",76,0)
 S SUBCOMP=$E(HDR(1),8)
"RTN","HLOPRS",77,0)
 Q:$L(FS)'=1 0
"RTN","HLOPRS",78,0)
 Q:$L(CS)'=1 0
"RTN","HLOPRS",79,0)
 S HDR("FIELD SEPARATOR")=FS
"RTN","HLOPRS",80,0)
 S HDR("ENCODING CHARACTERS")=$E(HDR(1),5,8)
"RTN","HLOPRS",81,0)
 S HDR("COMPONENT SEPARATOR")=CS
"RTN","HLOPRS",82,0)
 S HDR("REPETITION SEPARATOR")=$E(HDR(1),6)
"RTN","HLOPRS",83,0)
 S HDR("ESCAPE CHARACTER")=$E(HDR(1),7)
"RTN","HLOPRS",84,0)
 S HDR("SUBCOMPONENT SEPARATOR")=$E(HDR(1),8)
"RTN","HLOPRS",85,0)
 S HDR("SENDING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(HDR(1),FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",86,0)
 S VALUE=$P(HDR(1),FS,4)
"RTN","HLOPRS",87,0)
 S HDR("SENDING FACILITY",1)=$P(VALUE,CS)
"RTN","HLOPRS",88,0)
 S HDR("SENDING FACILITY",2)=$$DESCAPE^HLOPRS1($P(VALUE,CS,2),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",89,0)
 S HDR("SENDING FACILITY",3)=$P(VALUE,CS,3)
"RTN","HLOPRS",90,0)
 S HDR("RECEIVING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(HDR(1),FS,5),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",91,0)
 S VALUE=$P(HDR(1),FS,6)
"RTN","HLOPRS",92,0)
 S HDR("RECEIVING FACILITY",1)=$P(VALUE,CS)
"RTN","HLOPRS",93,0)
 S HDR("RECEIVING FACILITY",2)=$$DESCAPE^HLOPRS1($P(VALUE,CS,2),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",94,0)
 S HDR("RECEIVING FACILITY",3)=$P(VALUE,CS,3)
"RTN","HLOPRS",95,0)
 S HDR("DT/TM OF MESSAGE")=$$FMDATE^HLFNC($P($P(HDR(2),FS,2),CS))
"RTN","HLOPRS",96,0)
 S HDR("SECURITY")=$$DESCAPE^HLOPRS1($P($P(HDR(2),FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",97,0)
 ;
"RTN","HLOPRS",98,0)
 I HDR("SEGMENT TYPE")="MSH" D
"RTN","HLOPRS",99,0)
 .S VALUE=$P(HDR(2),FS,4)
"RTN","HLOPRS",100,0)
 .S HDR("MESSAGE TYPE")=$P(VALUE,CS)
"RTN","HLOPRS",101,0)
 .S HDR("EVENT")=$P(VALUE,CS,2)
"RTN","HLOPRS",102,0)
 .S HDR("MESSAGE STRUCTURE")=$P(VALUE,CS,3)
"RTN","HLOPRS",103,0)
 .S HDR("MESSAGE CONTROL ID")=$P($P(HDR(2),FS,5),CS)
"RTN","HLOPRS",104,0)
 .S VALUE=$P(HDR(2),FS,6)
"RTN","HLOPRS",105,0)
 .S HDR("PROCESSING ID")=$P(VALUE,CS)
"RTN","HLOPRS",106,0)
 .S HDR("PROCESSING MODE")=$P(VALUE,CS,2)
"RTN","HLOPRS",107,0)
 .S HDR("VERSION")=$$DESCAPE^HLOPRS1($P($P(HDR(2),FS,7),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",108,0)
 .S HDR("CONTINUATION POINTER")=$P($P(HDR(2),FS,9),CS)
"RTN","HLOPRS",109,0)
 .S HDR("ACCEPT ACK TYPE")=$P($P(HDR(2),FS,10),CS)
"RTN","HLOPRS",110,0)
 .S HDR("APP ACK TYPE")=$P($P(HDR(2),FS,11),CS)
"RTN","HLOPRS",111,0)
 .S HDR("COUNTRY")=$P($P(HDR(2),FS,12),CS)
"RTN","HLOPRS",112,0)
 ;
"RTN","HLOPRS",113,0)
 I HDR("SEGMENT TYPE")="BHS" D
"RTN","HLOPRS",114,0)
 .S VALUE=$P(HDR(2),FS,4)
"RTN","HLOPRS",115,0)
 .S HDR("BATCH NAME/ID/TYPE")=$$DESCAPE^HLOPRS1(VALUE,FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",116,0)
 .S HDR("PROCESSING ID")=$E($P(VALUE,"PROCESSING ID=",2),1)
"RTN","HLOPRS",117,0)
 .S HDR("ACCEPT ACK TYPE")=$E($P(VALUE,"ACCEPT ACK TYPE=",2),1,2)
"RTN","HLOPRS",118,0)
 .S HDR("APP ACK TYPE")=$E($P(VALUE,"APP ACK TYPE=",2),1,2)
"RTN","HLOPRS",119,0)
 .S HDR("BATCH COMMENT")=$$DESCAPE^HLOPRS1($P(HDR(2),FS,5),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOPRS",120,0)
 .S HDR("BATCH CONTROL ID")=$P($P(HDR(2),FS,6),CS)
"RTN","HLOPRS",121,0)
 .S HDR("REFERENCE BATCH CONTROL ID")=$P($P(HDR(2),FS,7),CS)
"RTN","HLOPRS",122,0)
 .;
"RTN","HLOPRS",123,0)
 Q 1
"RTN","HLOPRS",124,0)
 ;
"RTN","HLOPRS",125,0)
GET(SEG,FIELD,COMP,SUBCOMP,REP) ;
"RTN","HLOPRS",126,0)
 ;This function gets a specified value from a segment that was parsed by
"RTN","HLOPRS",127,0)
 ;$$NEXTSEG. The FIELD,COMP,SUBCOMP,REP parameters are optional - if not
"RTN","HLOPRS",128,0)
 ;specified, they default to 1.
"RTN","HLOPRS",129,0)
 ;  Example:
"RTN","HLOPRS",130,0)
 ;    $$GET^HLOPRS(.SEG,1) will return the value of the first field, first
"RTN","HLOPRS",131,0)
 ;  component, first subcomponent, in the first occurrence of field #1.  
"RTN","HLOPRS",132,0)
 ;Input:
"RTN","HLOPRS",133,0)
 ;SEG - (required, pass by reference) - this is the array where the parsed segment was placed by $$NEXTSEG
"RTN","HLOPRS",134,0)
 ;FIELD - the sequence # of the field (optional, defaults to 1)
"RTN","HLOPRS",135,0)
 ;COMP - the # of the component (optional, defaults to 1)
"RTN","HLOPRS",136,0)
 ;SUBCOMP - the # of the subcomponent (optional, defaults to 1)
"RTN","HLOPRS",137,0)
 ;REP - the occurrence# (optional, defaults to 1)  For a non-repeating field, the occurrence # need not be provided, because it would be 1.
"RTN","HLOPRS",138,0)
 ;Output:
"RTN","HLOPRS",139,0)
 ;  Function returns the requested value on success, "" if not valued.
"RTN","HLOPRS",140,0)
 ;
"RTN","HLOPRS",141,0)
 ;allow the segment type to be obtained via field #0 (shorthand)
"RTN","HLOPRS",142,0)
 I $D(FIELD),$G(FIELD)=0 Q $G(SEG("SEGMENT TYPE"))
"RTN","HLOPRS",143,0)
 S:'$G(FIELD) FIELD=1
"RTN","HLOPRS",144,0)
 ;
"RTN","HLOPRS",145,0)
 ;for MSH or BHS, SEQ#1 is the  field separator
"RTN","HLOPRS",146,0)
 I FIELD=1,$G(SEG("SEGMENT TYPE"))="MSH"!$G(SEG("SEGMENT TYPE"))="BHS",$G(REP)<2,$G(COMP)<2,$G(SUBCOMP)<2 Q SEG("FIELD SEPARATOR")
"RTN","HLOPRS",147,0)
 I FIELD=1,$G(SEG("SEGMENT TYPE"))="MSH"!$G(SEG("SEGMENT TYPE"))="BHS" Q ""
"RTN","HLOPRS",148,0)
 ;
"RTN","HLOPRS",149,0)
 ;For segments other than MSH or BHS, the first subscript in the SEG array needs to be incremented by 1, because SEG(1,1,1,1) is taken by the segment type, which technically isn't a field. (for convenience,we call it SEQ=0).  
"RTN","HLOPRS",150,0)
 I $G(SEG("SEGMENT TYPE"))'="BHS",$G(SEG("SEGMENT TYPE"))'="MSH" S FIELD=FIELD+1
"RTN","HLOPRS",151,0)
 S:'$G(COMP) COMP=1
"RTN","HLOPRS",152,0)
 S:'$G(SUBCOMP) SUBCOMP=1
"RTN","HLOPRS",153,0)
 S:'$G(REP) REP=1
"RTN","HLOPRS",154,0)
 Q $G(SEG(FIELD,REP,COMP,SUBCOMP))
"RTN","HLOPRS",155,0)
 ;
"RTN","HLOPRS1")
0^4^B13347617
"RTN","HLOPRS1",1,0)
HLOPRS1 ;IRMFO-ALB/CJM -RTNs for parsing messages (continued);03/24/2004  14:43
"RTN","HLOPRS1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**118**;Oct 13, 1995
"RTN","HLOPRS1",3,0)
 ;
"RTN","HLOPRS1",4,0)
PARSE(FIELD,REP,COMP,SUBCOMP,ESCAPE,SEG,TO) ;
"RTN","HLOPRS1",5,0)
 ;Parses the segment stored in SEG(1),SEG(2),... into TO()
"RTN","HLOPRS1",6,0)
 ;Input:
"RTN","HLOPRS1",7,0)
 ;  FIELD - field separator
"RTN","HLOPRS1",8,0)
 ;  REP - field repetition separator
"RTN","HLOPRS1",9,0)
 ;  COMP - component separator
"RTN","HLOPRS1",10,0)
 ;  SUBCOMP - subcomponent separator
"RTN","HLOPRS1",11,0)
 ;  ESCAPE - escape character
"RTN","HLOPRS1",12,0)
 ;  SEG - (pass by reference) the array holding the unparsed segment.
"RTN","HLOPRS1",13,0)
 ;Output:
"RTN","HLOPRS1",14,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOPRS1",15,0)
 ;  TO - (pass by reference) - the parsed values
"RTN","HLOPRS1",16,0)
 ;  SEG- This input variable is deleted during the processing.  If it is needs to be retained, pass in a copy!
"RTN","HLOPRS1",17,0)
 ;
"RTN","HLOPRS1",18,0)
 N VALUE,CHAR,COUNTS
"RTN","HLOPRS1",19,0)
 K TO
"RTN","HLOPRS1",20,0)
 Q:$L($G(FIELD))'=1 0
"RTN","HLOPRS1",21,0)
 Q:$L($G(REP))'=1 0
"RTN","HLOPRS1",22,0)
 Q:$L($G(COMP))'=1 0
"RTN","HLOPRS1",23,0)
 Q:$L($G(SUBCOMP))'=1 0
"RTN","HLOPRS1",24,0)
 Q:'$D(SEG) 0
"RTN","HLOPRS1",25,0)
 S COUNTS("FIELD")=1
"RTN","HLOPRS1",26,0)
 S COUNTS("REP")=1
"RTN","HLOPRS1",27,0)
 S COUNTS("COMP")=1
"RTN","HLOPRS1",28,0)
 S COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",29,0)
 S VALUE=""
"RTN","HLOPRS1",30,0)
 S SEG("LINE")=$O(SEG(0)),SEG("CHAR")=0
"RTN","HLOPRS1",31,0)
 F  S CHAR=$$NEXTCHAR(.SEG) D  Q:'$L(CHAR)
"RTN","HLOPRS1",32,0)
 .I '$L(CHAR) D  Q
"RTN","HLOPRS1",33,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=VALUE
"RTN","HLOPRS1",34,0)
 .E  I CHAR=FIELD D  Q
"RTN","HLOPRS1",35,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",36,0)
 ..S COUNTS("FIELD")=COUNTS("FIELD")+1,COUNTS("REP")=1,COUNTS("COMP")=1,COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",37,0)
 .E  I CHAR=REP D  Q
"RTN","HLOPRS1",38,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",39,0)
 ..S COUNTS("REP")=COUNTS("REP")+1,COUNTS("COMP")=1,COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",40,0)
 .E  I CHAR=COMP D  Q
"RTN","HLOPRS1",41,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",42,0)
 ..S COUNTS("COMP")=COUNTS("COMP")+1,COUNTS("SUBCOMP")=1
"RTN","HLOPRS1",43,0)
 .E  I CHAR=SUBCOMP D  Q
"RTN","HLOPRS1",44,0)
 ..I $L(VALUE) S TO(COUNTS("FIELD"),COUNTS("REP"),COUNTS("COMP"),COUNTS("SUBCOMP"))=$$DESCAPE(VALUE,.FIELD,.COMP,.SUBCOMP,.REP,.ESCAPE),VALUE=""
"RTN","HLOPRS1",45,0)
 ..S COUNTS("SUBCOMP")=COUNTS("SUBCOMP")+1
"RTN","HLOPRS1",46,0)
 .E  S VALUE=VALUE_CHAR
"RTN","HLOPRS1",47,0)
 S TO("SEGMENT TYPE")=$G(TO(1,1,1,1))
"RTN","HLOPRS1",48,0)
 I (TO("SEGMENT TYPE")="BHS")!(TO("SEGMENT TYPE")="MSH") S TO("FIELD SEPARATOR")=FIELD
"RTN","HLOPRS1",49,0)
 Q 1
"RTN","HLOPRS1",50,0)
 ;
"RTN","HLOPRS1",51,0)
NEXTCHAR(SEG) ;
"RTN","HLOPRS1",52,0)
 ;returns the next character in the segment array
"RTN","HLOPRS1",53,0)
 ;
"RTN","HLOPRS1",54,0)
 Q:'SEG("LINE") ""
"RTN","HLOPRS1",55,0)
 N RET
"RTN","HLOPRS1",56,0)
 S SEG("CHAR")=SEG("CHAR")+1
"RTN","HLOPRS1",57,0)
 S RET=$E(SEG(SEG("LINE")),SEG("CHAR"))
"RTN","HLOPRS1",58,0)
 Q:RET]"" RET
"RTN","HLOPRS1",59,0)
 S SEG("LINE")=$O(SEG(SEG("LINE")))
"RTN","HLOPRS1",60,0)
 I SEG("LINE") S SEG("CHAR")=1 Q $E(SEG(SEG("LINE")))
"RTN","HLOPRS1",61,0)
 Q ""
"RTN","HLOPRS1",62,0)
 ;
"RTN","HLOPRS1",63,0)
DESCAPE(VALUE,FIELD,COMP,SUBCOMP,REP,ESCAPE) ;
"RTN","HLOPRS1",64,0)
 ;Replaces the escape sequences with the corresponding encoding character and returns the result as the function value
"RTN","HLOPRS1",65,0)
 ;
"RTN","HLOPRS1",66,0)
 N NEWSTRNG,SUBSTRNG,SET,LEN,I,SUBLEN,CHAR
"RTN","HLOPRS1",67,0)
 S (NEWSTRNG,SUBSTRNG,SUBLEN)=""
"RTN","HLOPRS1",68,0)
 S SET="FSTRE"
"RTN","HLOPRS1",69,0)
 S LEN=$L(VALUE)
"RTN","HLOPRS1",70,0)
 F I=1:1:LEN S SUBSTRNG=SUBSTRNG_$E(VALUE,I),SUBLEN=SUBLEN+1 D:SUBLEN=3
"RTN","HLOPRS1",71,0)
 .S CHAR=$E(SUBSTRNG,2)
"RTN","HLOPRS1",72,0)
 .I $E(SUBSTRNG,1)=ESCAPE,$E(SUBSTRNG,3)=ESCAPE,SET[CHAR D
"RTN","HLOPRS1",73,0)
 ..I CHAR="F" S NEWSTRNG=NEWSTRNG_FIELD,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",74,0)
 ..I CHAR="S" S NEWSTRNG=NEWSTRNG_COMP,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",75,0)
 ..I CHAR="T" S NEWSTRNG=NEWSTRNG_SUBCOMP,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",76,0)
 ..I CHAR="R" S NEWSTRNG=NEWSTRNG_REP,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",77,0)
 ..I CHAR="E" S NEWSTRNG=NEWSTRNG_ESCAPE,SUBSTRNG="",SUBLEN=0 Q
"RTN","HLOPRS1",78,0)
 .E  S NEWSTRNG=NEWSTRNG_$E(SUBSTRNG),SUBSTRNG=$E(SUBSTRNG,2,3),SUBLEN=2
"RTN","HLOPRS1",79,0)
 Q NEWSTRNG_SUBSTRNG
"RTN","HLPRS")
0^1^B18693372
"RTN","HLPRS",1,0)
HLPRS ;IRMFO-ALB/CJM -RTNs for parsing messages;03/24/2004  14:43
"RTN","HLPRS",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**118**;Oct 13, 1995
"RTN","HLPRS",3,0)
 ;
"RTN","HLPRS",4,0)
STARTMSG(MSG,IEN,HDR) ;
"RTN","HLPRS",5,0)
 ;Description:  This function begins the parsing of the message, parsing
"RTN","HLPRS",6,0)
 ;the header and returning the individual values in the array HDR().
"RTN","HLPRS",7,0)
 ;Input: 
"RTN","HLPRS",8,0)
 ;  IEN - The internal entry number of the message in file 773.
"RTN","HLPRS",9,0)
 ;Output:
"RTN","HLPRS",10,0)
 ;  Function returns 1 on success, 0 on failure.  Failure would indicate that the message was not found.
"RTN","HLPRS",11,0)
 ;  MSG - (pass by reference, required) This array is used by the HL7 package to track the progress of parsing the message.  The application MUST NOT touch it!
"RTN","HLPRS",12,0)
 ;  HDR (pass by reference, optional)   This array contains the results of parsing the message header.
"RTN","HLPRS",13,0)
 K MSG,HDR
"RTN","HLPRS",14,0)
 Q:'$G(IEN) 0
"RTN","HLPRS",15,0)
 Q:'$$GETMSG^HLMSG(IEN,.MSG) 0
"RTN","HLPRS",16,0)
 N SEG
"RTN","HLPRS",17,0)
 M SEG=MSG("HDR")
"RTN","HLPRS",18,0)
 Q:'$$PARSEHDR(.SEG,.HDR) 0
"RTN","HLPRS",19,0)
 ;after parsing the header, reset these subscripts:
"RTN","HLPRS",20,0)
 I HDR("SEGMENT TYPE")="BHS" D
"RTN","HLPRS",21,0)
 .S MSG("BATCH")=1
"RTN","HLPRS",22,0)
 .S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLPRS",23,0)
 E  D
"RTN","HLPRS",24,0)
 .S MSG("BATCH")=0
"RTN","HLPRS",25,0)
 ;
"RTN","HLPRS",26,0)
 K MSG("HDR")
"RTN","HLPRS",27,0)
 M MSG("HDR")=HDR
"RTN","HLPRS",28,0)
 Q 1
"RTN","HLPRS",29,0)
 ;
"RTN","HLPRS",30,0)
NEXTSEG(MSG,SEG) ;
"RTN","HLPRS",31,0)
 ;Description:  Advances parsing to the next segment and returns the parsed values from that segment.
"RTN","HLPRS",32,0)
 ;Input:
"RTN","HLPRS",33,0)
 ;  MSG - (pass by reference, required) This array is used by the HL7 package to track the current position in the message.  The application MUST NOT touch it!
"RTN","HLPRS",34,0)
 ;Output:
"RTN","HLPRS",35,0)
 ;  Function  returns 1 on success, 0 if there are no more segments in this message.  For batch messages, a return value of 0 does not preclude the possibility that there are additional individual messages within the batch.
"RTN","HLPRS",36,0)
 ;  MSG - (pass by reference, required)
"RTN","HLPRS",37,0)
 ;  SEG - (pass by reference, required)  The segment is returned in this array.
"RTN","HLPRS",38,0)
 ;
"RTN","HLPRS",39,0)
 N TEMP,CODES
"RTN","HLPRS",40,0)
 K SEG
"RTN","HLPRS",41,0)
 I '$$NEXTSEG^HLMSG(.MSG,.TEMP) Q 0
"RTN","HLPRS",42,0)
 S CODES=MSG("HDR","ENCODING CHARACTERS")
"RTN","HLPRS",43,0)
 Q $$PARSE^HLOPRS1(MSG("HDR","FIELD SEPARATOR"),$E(CODES,2),$E(CODES,1),$E(CODES,4),$E(CODES,3),.TEMP,.SEG)
"RTN","HLPRS",44,0)
 ;
"RTN","HLPRS",45,0)
NEXTMSG(MSG,MSH) ;
"RTN","HLPRS",46,0)
 ;Description:  Advances to the next message within the batch, with the MSH segment returned.
"RTN","HLPRS",47,0)
 ;Input:
"RTN","HLPRS",48,0)
 ; MSG (pass by reference, required) This array is used by the HL7 package to track the current position in the message.  The application MUST NOT touch it!
"RTN","HLPRS",49,0)
 ;OUTPUT:
"RTN","HLPRS",50,0)
 ;  Function returns 1 on success, 0 if there are no more messages
"RTN","HLPRS",51,0)
 ;  MSG - (pass by reference) (remember, off limits to the application developer!)
"RTN","HLPRS",52,0)
 ;  MSH - (pass by reference, required) Returns the parsed message header
"RTN","HLPRS",53,0)
 ;
"RTN","HLPRS",54,0)
 K MSH
"RTN","HLPRS",55,0)
 N HDR
"RTN","HLPRS",56,0)
 Q:'$$NEXTMSG^HLMSG(.MSG,.HDR) 0
"RTN","HLPRS",57,0)
 Q:'$$PARSEHDR(.HDR,.MSH) 0
"RTN","HLPRS",58,0)
 Q 1
"RTN","HLPRS",59,0)
 ;
"RTN","HLPRS",60,0)
PARSEHDR(SEG,HDR) ;
"RTN","HLPRS",61,0)
 ;Parses the segment (SEG, pass by reference) into the HDR() array using meaningful subscripts.
"RTN","HLPRS",62,0)
 ;Input:
"RTN","HLPRS",63,0)
 ;  SEG (pass by reference, required) contains the segment in the format SEG(1), SEG(2),...
"RTN","HLPRS",64,0)
 ;Output:
"RTN","HLPRS",65,0)
 ;  HDR (pass by reference, required) This array will contain all the individual values.
"RTN","HLPRS",66,0)
 ;  Function - returns 1 if the segment is indeed an MSH or BHS segment, 0 otherwise
"RTN","HLPRS",67,0)
 ;
"RTN","HLPRS",68,0)
 N VALUE,TO
"RTN","HLPRS",69,0)
 K HDR
"RTN","HLPRS",70,0)
 S VALUE=$E($G(SEG(1)),1,3)
"RTN","HLPRS",71,0)
 I VALUE'="MSH",VALUE'="BHS" Q 0
"RTN","HLPRS",72,0)
 S HDR("SEGMENT TYPE")=VALUE
"RTN","HLPRS",73,0)
 S HDR("FIELD SEPARATOR")=$E(SEG(1),4)
"RTN","HLPRS",74,0)
 Q:$L(HDR("FIELD SEPARATOR"))'=1 0
"RTN","HLPRS",75,0)
 S VALUE=$E(SEG(1),5,8)
"RTN","HLPRS",76,0)
 S HDR("ENCODING CHARACTERS")=VALUE
"RTN","HLPRS",77,0)
 S HDR("COMPONENT SEPARATOR")=$E(VALUE,1)
"RTN","HLPRS",78,0)
 S HDR("REPETITION SEPARATOR")=$E(VALUE,2)
"RTN","HLPRS",79,0)
 S HDR("ESCAPE CHARACTER")=$E(VALUE,3)
"RTN","HLPRS",80,0)
 S HDR("SUBCOMPONENT SEPARATOR")=$E(VALUE,4)
"RTN","HLPRS",81,0)
 I $$PARSE^HLOPRS1(HDR("FIELD SEPARATOR"),$E(VALUE,2),$E(VALUE,1),$E(VALUE,4),$E(VALUE,3),.SEG,.TO) D
"RTN","HLPRS",82,0)
 .S HDR("SENDING APPLICATION")=$$GET^HLOPRS(.TO,3)
"RTN","HLPRS",83,0)
 .S HDR("SENDING FACILITY",1)=$$GET^HLOPRS(.TO,4,1)
"RTN","HLPRS",84,0)
 .S HDR("SENDING FACILITY",2)=$$GET^HLOPRS(.TO,4,2)
"RTN","HLPRS",85,0)
 .S HDR("SENDING FACILTY",3)=$$GET^HLOPRS(.TO,4,3)
"RTN","HLPRS",86,0)
 .S HDR("RECEIVING APPLICATION")=$$GET^HLOPRS(.TO,5)
"RTN","HLPRS",87,0)
 .S HDR("RECEIVING FACILITY",1)=$$GET^HLOPRS(.TO,6,1)
"RTN","HLPRS",88,0)
 .S HDR("RECEIVING FACILITY",2)=$$GET^HLOPRS(.TO,6,2)
"RTN","HLPRS",89,0)
 .S HDR("RECEIVING FACILITY",3)=$$GET^HLOPRS(.TO,6,3)
"RTN","HLPRS",90,0)
 .S HDR("DT/TM OF MESSAGE")=$$FMDATE^HLFNC($$GET^HLOPRS(.TO,7))
"RTN","HLPRS",91,0)
 .S HDR("SECURITY")=$$GET^HLOPRS(.TO,8)
"RTN","HLPRS",92,0)
 .I HDR("SEGMENT TYPE")="MSH" D
"RTN","HLPRS",93,0)
 ..S HDR("MESSAGE TYPE")=$$GET^HLOPRS(.TO,9,1)
"RTN","HLPRS",94,0)
 ..S HDR("EVENT")=$$GET^HLOPRS(.TO,9,2)
"RTN","HLPRS",95,0)
 ..S HDR("MESSAGE STRUCTURE")=$$GET^HLOPRS(.TO,9,3)
"RTN","HLPRS",96,0)
 ..S HDR("MESSAGE CONTROL ID")=$$GET^HLOPRS(.TO,10)
"RTN","HLPRS",97,0)
 ..S HDR("PROCESSING ID")=$$GET^HLOPRS(.TO,11)
"RTN","HLPRS",98,0)
 ..S HDR("PROCESSING MODE")=$$GET^HLOPRS(.TO,11,2)
"RTN","HLPRS",99,0)
 ..S HDR("VERSION")=$$GET^HLOPRS(.TO,12)
"RTN","HLPRS",100,0)
 ..S HDR("CONTINUATION POINTER")=$$GET^HLOPRS(.TO,14)
"RTN","HLPRS",101,0)
 ..S HDR("ACCEPT ACK TYPE")=$$GET^HLOPRS(.TO,15)
"RTN","HLPRS",102,0)
 ..S HDR("APP ACK TYPE")=$$GET^HLOPRS(.TO,16)
"RTN","HLPRS",103,0)
 ..S HDR("COUNTRY")=$$GET^HLOPRS(.TO,17)
"RTN","HLPRS",104,0)
 .I HDR("SEGMENT TYPE")="BHS" D
"RTN","HLPRS",105,0)
 ..S VALUE=$$GET^HLOPRS(.TO,9)
"RTN","HLPRS",106,0)
 ..S HDR("BATCH NAME/ID/TYPE")=VALUE
"RTN","HLPRS",107,0)
 ..S HDR("PROCESSING ID")=$S((VALUE["PROCESSING ID="):$E($P(VALUE,"PROCESSING ID=",2),1),1:$$GET^HLOPRS(.TO,9,2))
"RTN","HLPRS",108,0)
 ..S HDR("ACCEPT ACK TYPE")=$S((VALUE["ACCEPT ACK TYPE="):$E($P(VALUE,"ACCEPT ACK TYPE=",2),1,2),1:$$GET^HLOPRS(.TO,9,3,1,2))
"RTN","HLPRS",109,0)
 ..S HDR("APP ACK TYPE")=$S((VALUE["APP ACK TYPE="):$E($P(VALUE,"APP ACK TYPE=",2),1,2),1:$$GET^HLOPRS(.TO,9,4,1,2))
"RTN","HLPRS",110,0)
 ..S HDR("BATCH COMMENT")=$$GET^HLOPRS(.TO,10)
"RTN","HLPRS",111,0)
 ..S HDR("BATCH CONTROL ID")=$$GET^HLOPRS(.TO,11)
"RTN","HLPRS",112,0)
 ..S HDR("REFERENCE BATCH CONTROL ID")=$$GET^HLOPRS(.TO,12)
"RTN","HLPRS",113,0)
 ..;
"RTN","HLPRS",114,0)
 Q 1
"VER")
8.0^22.0
"BLD",828,6)
^SEQ #100
**END**
**END**
