Released HL*1.6*93 SEQ #86
Extracted from mail message
**KIDS**:HL*1.6*93^

**INSTALL NAME**
HL*1.6*93
"BLD",591,0)
HL*1.6*93^HEALTH LEVEL SEVEN^0^3030508^y
"BLD",591,1,0)
^^2^2^3021022^
"BLD",591,1,1,0)
See patch HL*1.6*93 description on Forum for full instructions and 
"BLD",591,1,2,0)
information.
"BLD",591,4,0)
^9.64PA^773^1
"BLD",591,4,773,0)
773
"BLD",591,4,773,2,0)
^9.641^773^1
"BLD",591,4,773,2,773,0)
HL7 MESSAGE ADMINISTRATION  (File-top level)
"BLD",591,4,773,2,773,1,0)
^9.6411^91.08^16
"BLD",591,4,773,2,773,1,90.01,0)
HLP-SUBSCRIBER PROTOCOL
"BLD",591,4,773,2,773,1,90.02,0)
HLP-SENDING APPLICATION
"BLD",591,4,773,2,773,1,90.03,0)
HLP-SENDING FACILITY
"BLD",591,4,773,2,773,1,90.04,0)
HLP-RECEIVING APPLICATION
"BLD",591,4,773,2,773,1,90.05,0)
HLP-RECEIVING FACILITY
"BLD",591,4,773,2,773,1,90.06,0)
HLP-SUBROUTINE
"BLD",591,4,773,2,773,1,90.07,0)
HLP-ROUTINE
"BLD",591,4,773,2,773,1,90.08,0)
HLP-DEBUG
"BLD",591,4,773,2,773,1,91.01,0)
HLP-ORIGINAL SND APP
"BLD",591,4,773,2,773,1,91.02,0)
HLP-ORIGINAL SND APP-SOURCE
"BLD",591,4,773,2,773,1,91.03,0)
HLP-ORIGINAL SND FAC
"BLD",591,4,773,2,773,1,91.04,0)
HLP-ORIGINAL SND FAC-SOURCE
"BLD",591,4,773,2,773,1,91.05,0)
HLP-ORIGINAL REC APP
"BLD",591,4,773,2,773,1,91.06,0)
HLP-ORIGINAL REC APP-SOURCE
"BLD",591,4,773,2,773,1,91.07,0)
HLP-ORIGINAL SND FAC
"BLD",591,4,773,2,773,1,91.08,0)
HLP-ORIGINAL SND FAC-SOURCE
"BLD",591,4,773,222)
y^y^p^^^^n^^n
"BLD",591,4,773,224)

"BLD",591,4,"APDD",773,773)

"BLD",591,4,"APDD",773,773,90.01)

"BLD",591,4,"APDD",773,773,90.02)

"BLD",591,4,"APDD",773,773,90.03)

"BLD",591,4,"APDD",773,773,90.04)

"BLD",591,4,"APDD",773,773,90.05)

"BLD",591,4,"APDD",773,773,90.06)

"BLD",591,4,"APDD",773,773,90.07)

"BLD",591,4,"APDD",773,773,90.08)

"BLD",591,4,"APDD",773,773,91.01)

"BLD",591,4,"APDD",773,773,91.02)

"BLD",591,4,"APDD",773,773,91.03)

"BLD",591,4,"APDD",773,773,91.04)

"BLD",591,4,"APDD",773,773,91.05)

"BLD",591,4,"APDD",773,773,91.06)

"BLD",591,4,"APDD",773,773,91.07)

"BLD",591,4,"APDD",773,773,91.08)

"BLD",591,4,"B",773,773)

"BLD",591,"ABPKG")
n
"BLD",591,"KRN",0)
^9.67PA^8989.52^20
"BLD",591,"KRN",.4,0)
.4
"BLD",591,"KRN",.4,"NM",0)
^9.68A^1^1
"BLD",591,"KRN",.4,"NM",1,0)
HL PROTOCOL MESSAGING FIELDS    FILE #101^101^0
"BLD",591,"KRN",.4,"NM","B","HL PROTOCOL MESSAGING FIELDS    FILE #101",1)

"BLD",591,"KRN",.401,0)
.401
"BLD",591,"KRN",.401,"NM",0)
^9.68A^1^1
"BLD",591,"KRN",.401,"NM",1,0)
HL PROTOCOL MESSAGING FIELDS    FILE #101^101^0
"BLD",591,"KRN",.401,"NM","B","HL PROTOCOL MESSAGING FIELDS    FILE #101",1)

"BLD",591,"KRN",.402,0)
.402
"BLD",591,"KRN",.403,0)
.403
"BLD",591,"KRN",.5,0)
.5
"BLD",591,"KRN",.84,0)
.84
"BLD",591,"KRN",3.6,0)
3.6
"BLD",591,"KRN",3.8,0)
3.8
"BLD",591,"KRN",9.2,0)
9.2
"BLD",591,"KRN",9.8,0)
9.8
"BLD",591,"KRN",9.8,"NM",0)
^9.68A^5^5
"BLD",591,"KRN",9.8,"NM",1,0)
HLCSHDR1^^0^B24058167
"BLD",591,"KRN",9.8,"NM",2,0)
HLCSHDR3^^0^B33464514
"BLD",591,"KRN",9.8,"NM",3,0)
HLCSHDR4^^0^B74613551
"BLD",591,"KRN",9.8,"NM",4,0)
HLCSHDR5^^0^B40317270
"BLD",591,"KRN",9.8,"NM",5,0)
HLCSHDR6^^0^B11316553
"BLD",591,"KRN",9.8,"NM","B","HLCSHDR1",1)

"BLD",591,"KRN",9.8,"NM","B","HLCSHDR3",2)

"BLD",591,"KRN",9.8,"NM","B","HLCSHDR4",3)

"BLD",591,"KRN",9.8,"NM","B","HLCSHDR5",4)

"BLD",591,"KRN",9.8,"NM","B","HLCSHDR6",5)

"BLD",591,"KRN",19,0)
19
"BLD",591,"KRN",19,"NM",0)
^9.68A^2^2
"BLD",591,"KRN",19,"NM",1,0)
HL MENU TK REPORTS^^2
"BLD",591,"KRN",19,"NM",2,0)
HL PROTOCOL MSG FIELDS REPORT^^0
"BLD",591,"KRN",19,"NM","B","HL MENU TK REPORTS",1)

"BLD",591,"KRN",19,"NM","B","HL PROTOCOL MSG FIELDS REPORT",2)

"BLD",591,"KRN",19.1,0)
19.1
"BLD",591,"KRN",101,0)
101
"BLD",591,"KRN",409.61,0)
409.61
"BLD",591,"KRN",771,0)
771
"BLD",591,"KRN",870,0)
870
"BLD",591,"KRN",8989.51,0)
8989.51
"BLD",591,"KRN",8989.52,0)
8989.52
"BLD",591,"KRN",8994,0)
8994
"BLD",591,"KRN","B",.4,.4)

"BLD",591,"KRN","B",.401,.401)

"BLD",591,"KRN","B",.402,.402)

"BLD",591,"KRN","B",.403,.403)

"BLD",591,"KRN","B",.5,.5)

"BLD",591,"KRN","B",.84,.84)

"BLD",591,"KRN","B",3.6,3.6)

"BLD",591,"KRN","B",3.8,3.8)

"BLD",591,"KRN","B",9.2,9.2)

"BLD",591,"KRN","B",9.8,9.8)

"BLD",591,"KRN","B",19,19)

"BLD",591,"KRN","B",19.1,19.1)

"BLD",591,"KRN","B",101,101)

"BLD",591,"KRN","B",409.61,409.61)

"BLD",591,"KRN","B",771,771)

"BLD",591,"KRN","B",870,870)

"BLD",591,"KRN","B",8989.51,8989.51)

"BLD",591,"KRN","B",8989.52,8989.52)

"BLD",591,"KRN","B",8994,8994)

"BLD",591,"QUES",0)
^9.62^^
"BLD",591,"REQB",0)
^9.611^2^1
"BLD",591,"REQB",2,0)
HL*1.6*94^0
"BLD",591,"REQB","B","HL*1.6*94",2)

"FIA",773)
HL7 MESSAGE ADMINISTRATION
"FIA",773,0)
^HLMA(
"FIA",773,0,0)
773PI
"FIA",773,0,1)
y^y^p^^^^n^^n
"FIA",773,0,10)

"FIA",773,0,11)

"FIA",773,0,"RLRO")

"FIA",773,0,"VR")
1.6^HL
"FIA",773,773)
1
"FIA",773,773,90.01)

"FIA",773,773,90.02)

"FIA",773,773,90.03)

"FIA",773,773,90.04)

"FIA",773,773,90.05)

"FIA",773,773,90.06)

"FIA",773,773,90.07)

"FIA",773,773,90.08)

"FIA",773,773,91.01)

"FIA",773,773,91.02)

"FIA",773,773,91.03)

"FIA",773,773,91.04)

"FIA",773,773,91.05)

"FIA",773,773,91.06)

"FIA",773,773,91.07)

"FIA",773,773,91.08)

"KRN",.4,89,-1)
0^1
"KRN",.4,89,0)
HL PROTOCOL MESSAGING FIELDS^3030116.0737^@^101^^@^3030328
"KRN",.4,89,"DXS",1,9)
X DXS(1,9.4) S X=$S(DIP(202):DIP(203),DIP(205):DIP(206),DIP(208):DIP(209),DIP(211):DIP(212),DIP(213):X)
"KRN",.4,89,"DXS",1,9.2)
S DIP(201)=$S($D(^HLCS(870,D0,0)):^(0),1:"") S X=$P(DIP(201),U,3),X=X S X=X=1,DIP(202)=X S X="MAIL",DIP(203)=X,DIP(204)=X S X=$P(DIP(201),U,3),X=X S X=X
"KRN",.4,89,"DXS",1,9.3)
X DXS(1,9.2) S X=X=2,DIP(205)=X S X="HLLP",DIP(206)=X,DIP(207)=X S X=$P(DIP(201),U,3),X=X S X=X=3,DIP(208)=X S X="X3.28",DIP(209)=X,DIP(210)=X S X=$P(DIP(201),U,3)
"KRN",.4,89,"DXS",1,9.4)
X DXS(1,9.3) S X=X S X=X=4,DIP(211)=X S X="TCP",DIP(212)=X S X=1,DIP(213)=X S X=""
"KRN",.4,89,"F",1)
770.1;"Snd/Rec App's";L15~770.3;"mTYP";L5~770.4;"eTYP";L5~770.95;"Ver";L5~"| "~.01;L27;"Protocol"~"";"Link";l4~
"KRN",.4,89,"F",2)
775,-101,^ORD(101,^^S I(1,0)=D1 S I(0,0)=D0 S DIP(1)=$S($D(^ORD(101,D0,775,D1,0)):^(0),1:"") S X=$P(DIP(1),U,1),X=X S D(0)=+X;Z;"SUBSCRIBERS:"~
"KRN",.4,89,"F",3)
775,-101,S DIP(101)=$S($D(^ORD(101,D0,770)):^(770),1:"") S X="-"_$S('$D(^HL(771,+$P(DIP(101),U,2),0)):"",1:$P(^(0),U,1)) W X K DIP;"";C1;Z;""-"_RECEIVING APPLICATION"~
"KRN",.4,89,"F",4)
775,-101,770.3;"";L5;C18~775,-101,770.4;"";L5~775,-101,770.95;"";L5~775,-101,"| "~775,-101,.01;"";L27~
"KRN",.4,89,"F",5)
775,-101,-870,^HLCS(870,^^S I(100,0)=D0 S DIP(101)=$S($D(^ORD(101,D0,770)):^(770),1:"") S X=$P(DIP(101),U,7),X=X S D(0)=+X;Z;"LOGICAL LINK:"~
"KRN",.4,89,"F",6)
775,-101,-870,S DIP(201)=$S($D(^HLCS(870,D0,0)):^(0),1:"") S X=$P(DIP(201),U,4),X=X W X K DIP;"";L2;Z;"INTERNAL(#3)"~
"KRN",.4,89,"F",7)
775,-101,-870,X DXS(1,9) W X K DIP;L5;"";Z;"$S(INTERNAL(#2)=1:"MAIL",INTERNAL(#2)=2:"HLLP",INTERNAL(#2)=3:"X3.28",INTERNAL(#2)=4:"TCP",1:"")"~
"KRN",.4,89,"F",8)
"------------------------------------------------------------------------------";C1~
"KRN",.4,89,"H")
Protocol Fields Used in Messaging
"KRN",.401,52,-1)
0^1
"KRN",.401,52,0)
HL PROTOCOL MESSAGING FIELDS^3030123.0539^@^101^^@^3030328
"KRN",.401,52,2,0)
^.4014^6^6
"KRN",.401,52,2,1,0)
101^^SENDING APPLICATION^@"770.1^^^^^^4
"KRN",.401,52,2,1,"ASK")
1
"KRN",.401,52,2,1,"CM")
S Y(1)=$S($D(^ORD(101,D0,770)):^(770),1:"") S X=$S('$D(^HL(771,+$P(Y(1),U,1),0)):"",1:$P(^(0),U,1)) I D0>0 S DISX(1)=X
"KRN",.401,52,2,1,"GET")
S Y(1)=$S($D(^ORD(101,D0,770)):^(770),1:"") S X=$S('$D(^HL(771,+$P(Y(1),U,1),0)):"",1:$P(^(0),U,1)) I D0>0 S DISX(1)=X
"KRN",.401,52,2,1,"QCON")
I DISX(1)'=""
"KRN",.401,52,2,1,"TXT")
SENDING APPLICATION not null
"KRN",.401,52,2,2,0)
101^^TRANSACTION MESSAGE TYPE^@"770.3^^^^^^4
"KRN",.401,52,2,2,"ASK")
1
"KRN",.401,52,2,2,"CM")
S Y(1)=$S($D(^ORD(101,D0,770)):^(770),1:"") S X=$S('$D(^HL(771.2,+$P(Y(1),U,3),0)):"",1:$P(^(0),U,1)) I D0>0 S DISX(2)=X
"KRN",.401,52,2,2,"GET")
S Y(1)=$S($D(^ORD(101,D0,770)):^(770),1:"") S X=$S('$D(^HL(771.2,+$P(Y(1),U,3),0)):"",1:$P(^(0),U,1)) I D0>0 S DISX(2)=X
"KRN",.401,52,2,2,"QCON")
I DISX(2)'=""
"KRN",.401,52,2,2,"TXT")
TRANSACTION MESSAGE TYPE not null
"KRN",.401,52,2,3,0)
101^^EVENT TYPE^@"770.4^^^^^^4
"KRN",.401,52,2,3,"CM")
S Y(1)=$S($D(^ORD(101,D0,770)):^(770),1:"") S X=$S('$D(^HL(779.001,+$P(Y(1),U,4),0)):"",1:$P(^(0),U,1)) I D0>0 S DISX(3)=X
"KRN",.401,52,2,3,"F")
?z^@
"KRN",.401,52,2,3,"GET")
S Y(1)=$S($D(^ORD(101,D0,770)):^(770),1:"") S X=$S('$D(^HL(779.001,+$P(Y(1),U,4),0)):"",1:$P(^(0),U,1)) I D0>0 S DISX(3)=X
"KRN",.401,52,2,3,"QCON")
I 1
"KRN",.401,52,2,3,"T")
z^
"KRN",.401,52,2,3,"TXT")
All EVENT TYPE (includes nulls)
"KRN",.401,52,2,4,0)
101^^VERSION ID^@"770.95^^^^^^4
"KRN",.401,52,2,4,"CM")
S Y(1)=$S($D(^ORD(101,D0,770)):^(770),1:"") S X=$S('$D(^HL(771.5,+$P(Y(1),U,10),0)):"",1:$P(^(0),U,1)) I D0>0 S DISX(4)=X
"KRN",.401,52,2,4,"F")
?z^@
"KRN",.401,52,2,4,"GET")
S Y(1)=$S($D(^ORD(101,D0,770)):^(770),1:"") S X=$S('$D(^HL(771.5,+$P(Y(1),U,10),0)):"",1:$P(^(0),U,1)) I D0>0 S DISX(4)=X
"KRN",.401,52,2,4,"QCON")
I 1
"KRN",.401,52,2,4,"T")
z^
"KRN",.401,52,2,4,"TXT")
All VERSION ID (includes nulls)
"KRN",.401,52,2,5,0)
101^^INTERNAL(TYPE)="E"^"@B^;L1^^^^^4
"KRN",.401,52,2,5,"CM")
S Y(1)=$S($D(^ORD(101,D0,0)):^(0),1:"") S X=$P(Y(1),U,4),X=X S X=X="E" I D0>0 S DISX(5)=X
"KRN",.401,52,2,5,"F")
0
"KRN",.401,52,2,5,"GET")
S Y(1)=$S($D(^ORD(101,D0,0)):^(0),1:"") S X=$P(Y(1),U,4),X=X S X=X="E" I D0>0 S DISX(5)=X
"KRN",.401,52,2,5,"QCON")
I DISX(5)
"KRN",.401,52,2,5,"T")
1
"KRN",.401,52,2,5,"TXT")
INTERNAL(TYPE)=""E""
"KRN",.401,52,2,6,0)
101^^COUNT(SUBSCRIBER)>0^"@B^;L1^^^^^4
"KRN",.401,52,2,6,3,0)
^.401419^1^1
"KRN",.401,52,2,6,3,1,0)
OVF0^9.2
"KRN",.401,52,2,6,3,1,"OVF0")
S I(0,0)=$G(D0),I(1,0)=$G(D1),Y(102)="" X "F D1=0:0 S D1=$O(^ORD(101,D0,775,D1)) Q:D1'>0  S:$S($D(^(D1,0)):$P(^(0),U,1),1:"""")'?."" "" Y(102)=Y(102)+1" S D(1)=D1
"KRN",.401,52,2,6,3,"B","OVF0",1)

"KRN",.401,52,2,6,"CM")
X DPP(6,"OVF0",9.2) S X=+Y(102)>0 S D0=I(0,0) S D1=I(1,0) I D0>0 S DISX(6)=X
"KRN",.401,52,2,6,"F")
0
"KRN",.401,52,2,6,"GET")
X DPP(6,"OVF0",9.2) S X=+Y(102)>0 S D0=I(0,0) S D1=I(1,0) I D0>0 S DISX(6)=X
"KRN",.401,52,2,6,"QCON")
I DISX(6)
"KRN",.401,52,2,6,"T")
1
"KRN",.401,52,2,6,"TXT")
COUNT(SUBSCRIBER)>0
"KRN",.401,52,2,"B",101,1)

"KRN",.401,52,2,"B",101,2)

"KRN",.401,52,2,"B",101,3)

"KRN",.401,52,2,"B",101,4)

"KRN",.401,52,2,"B",101,5)

"KRN",.401,52,2,"B",101,6)

"KRN",.401,52,"DIPT")
HL PROTOCOL MESSAGING FIELDS
"KRN",19,763,-1)
2^1
"KRN",19,763,0)
HL MENU TK REPORTS^Reports^^M^6^^^^^^^9^y
"KRN",19,763,10,0)
^19.01IP^7^7
"KRN",19,763,10,7,0)
895^^99
"KRN",19,763,10,7,"^")
HL PROTOCOL MSG FIELDS REPORT
"KRN",19,763,"U")
REPORTS
"KRN",19,895,-1)
0^2
"KRN",19,895,0)
HL PROTOCOL MSG FIELDS REPORT^Protocol Messaging Fields Report^^R^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,895,25)
FIELDS^HLCSHDR4
"KRN",19,895,"U")
PROTOCOL MESSAGING FIELDS REPO
"MBREQ")
0
"ORD",5,.4)
.4;5;;;EDEOUT^DIFROMSO(.4,DA,"",XPDA);FPRE^DIFROMSI(.4,"",XPDA);EPRE^DIFROMSI(.4,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.4,DA,"",XPDA);DEL^DIFROMSK(.4,"",%)
"ORD",5,.4,0)
PRINT TEMPLATE
"ORD",6,.401)
.401;6;;;EDEOUT^DIFROMSO(.401,DA,"",XPDA);FPRE^DIFROMSI(.401,"",XPDA);EPRE^DIFROMSI(.401,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.401,DA,"",XPDA);DEL^DIFROMSK(.401,"",%)
"ORD",6,.401,0)
SORT TEMPLATE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
93^3030508^73
"PKG",9,22,1,"PAH",1,1,0)
^^2^2^3030508
"PKG",9,22,1,"PAH",1,1,1,0)
See patch HL*1.6*93 description on Forum for full instructions and 
"PKG",9,22,1,"PAH",1,1,2,0)
information.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
5
"RTN","HLCSHDR1")
0^1^B24058167
"RTN","HLCSHDR1",1,0)
HLCSHDR1 ;SFIRMFO/RSD - Make HL7 header for TCP ;07/12/2000  14:55
"RTN","HLCSHDR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,57,59,72,80,93**;Oct 13, 1995
"RTN","HLCSHDR1",3,0)
HEADER(IEN,CLIENT,HLERROR) ; Create an HL7 MSH segment
"RTN","HLCSHDR1",4,0)
 ;
"RTN","HLCSHDR1",5,0)
 ;Input  : IEN - Pointer to entry in Message Administration file (#773)
"RTN","HLCSHDR1",6,0)
 ;               that HL7 MSH segment is being built for
"RTN","HLCSHDR1",7,0)
 ;         CLIENT - IEN of the receiving application
"RTN","HLCSHDR1",8,0)
 ;         HLERROR - Variable to return possible error text in
"RTN","HLCSHDR1",9,0)
 ;                   (pass by reference - only used when needed)
"RTN","HLCSHDR1",10,0)
 ;
"RTN","HLCSHDR1",11,0)
 ;Output : HLHDR(1) - HL7 MSH segment
"RTN","HLCSHDR1",12,0)
 ;         HLHDR(2) - Continuation of HL7 MSH segment (if needed)
"RTN","HLCSHDR1",13,0)
 ;         HLHDR(3) - Continuation of HL7 MSH segment (if needed)
"RTN","HLCSHDR1",14,0)
 ;
"RTN","HLCSHDR1",15,0)
 ;Notes  : HLERROR will only be defined [on output] if an error occurs
"RTN","HLCSHDR1",16,0)
 ;       : HLHDR() will not be defined [on output] if an error occurs
"RTN","HLCSHDR1",17,0)
 ;       : HLHDR(2) & HLHDR(3) are continuation [or roll-over] nodes
"RTN","HLCSHDR1",18,0)
 ;         and will only be used/defined when needed
"RTN","HLCSHDR1",19,0)
 ;
"RTN","HLCSHDR1",20,0)
 N ACKTO,ACCACK,APPACK,CHILD,CLNTAPP,CLNTFAC,CNTRY,EC,EVNTYPE,FS,HLDATE,HLHDRI,HLHDRL,HLID,HLPID,MSGTYPE,PROT,PROTS,SECURITY,SEND,SERAPP,SERFAC,TXTP,TXTP0,X,MSGEVN
"RTN","HLCSHDR1",21,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLCSHDR1",22,0)
 D VAR Q:$G(HLERROR)]""
"RTN","HLCSHDR1",23,0)
 ; The following line commented by HL*1.6*72
"RTN","HLCSHDR1",24,0)
 ;I $D(^HLMA(IEN)) S $P(^HLMA(IEN,0),U,13)=MSGTYPE,$P(^HLMA(IEN,0),U,14)=$G(EVNTYPE)
"RTN","HLCSHDR1",25,0)
 ;Append event type
"RTN","HLCSHDR1",26,0)
 I $G(EVNTYPE)]"" S MSGTYPE=MSGTYPE_$E(EC,1)_EVNTYPE
"RTN","HLCSHDR1",27,0)
 ;Append message structure component
"RTN","HLCSHDR1",28,0)
 I $G(EVNTYPE)]"",$G(MSGEVN)]"" S MSGTYPE=MSGTYPE_$E(EC,1)_MSGEVN
"RTN","HLCSHDR1",29,0)
 ;Build MSH array
"RTN","HLCSHDR1",30,0)
 D RESET^HLCSHDR3 ;HL*1.6*93
"RTN","HLCSHDR1",31,0)
 S HLHDRI=1,HLHDR(1)="MSH"_FS_EC_FS_SERAPP,HLHDRL=$L(HLHDR(1))
"RTN","HLCSHDR1",32,0)
 F X=SERFAC,CLNTAPP,CLNTFAC,HLDATE,SECURITY,MSGTYPE,HLID,HLPID,$P(PROT,U,9),"",$G(^HL(772,TXTP,1)),ACCACK,APPACK,CNTRY D MSH(X)
"RTN","HLCSHDR1",33,0)
 ;in preceeding line, "" is for sequence number - not supported
"RTN","HLCSHDR1",34,0)
 Q
"RTN","HLCSHDR1",35,0)
 ;
"RTN","HLCSHDR1",36,0)
MSH(X) ;add X to HLHDR
"RTN","HLCSHDR1",37,0)
 S:HLHDRL+$L(X)>245 HLHDRI=HLHDRI+1,HLHDR(HLHDRI)=""
"RTN","HLCSHDR1",38,0)
 S HLHDR(HLHDRI)=HLHDR(HLHDRI)_FS_X,HLHDRL=$L(HLHDR(HLHDRI))
"RTN","HLCSHDR1",39,0)
 Q
"RTN","HLCSHDR1",40,0)
BHSHDR(IEN,CLIENT,HLERROR) ; Create Batch Header Segment
"RTN","HLCSHDR1",41,0)
 ; The BHS has 12 segments, of which 4 are blank.
"RTN","HLCSHDR1",42,0)
 ; INPUT: IEN - IEN of entry in file #772
"RTN","HLCSHDR1",43,0)
 ; OUTPUT: HLHDR(1) and HLHDR(2) - the two lines with the 12 segs.
"RTN","HLCSHDR1",44,0)
 ;   ready for adding to a message directly.
"RTN","HLCSHDR1",45,0)
 N ACKTO,ACCACK,ACKMID,APPACK,BNAME,BSTATUS,BTACK,CHILD,CLNTAPP ;HL*1.6*80
"RTN","HLCSHDR1",46,0)
 N CLNTFAC,CNTRY,EC,EVNTYPE,FS,HLDATE,HLHDRI,HLHDRL,HLID,HLPID ;HL*1.6*80 - added HLPID
"RTN","HLCSHDR1",47,0)
 N PROT,PROTS,SECURITY,SEND,SERAPP,SERFAC,TXTP,TXTP0,X ;HL*1.6*80
"RTN","HLCSHDR1",48,0)
 ;
"RTN","HLCSHDR1",49,0)
 S HLPARAM=$$PARAM^HLCS2
"RTN","HLCSHDR1",50,0)
 D VAR Q:$G(HLERROR)]""
"RTN","HLCSHDR1",51,0)
 ; The following line commented by HL*1.6*72
"RTN","HLCSHDR1",52,0)
 ;I $D(^HLMA(IEN)) S $P(^HLMA(IEN,0),U,13)=MSGTYPE,$P(^HLMA(IEN,0),U,14)=$G(EVNTYPE)
"RTN","HLCSHDR1",53,0)
 ;
"RTN","HLCSHDR1",54,0)
 ;Append event type
"RTN","HLCSHDR1",55,0)
 I $G(EVNTYPE)]"" S MSGTYPE=MSGTYPE_$E(EC,2)_EVNTYPE,(ACKMID,BTACK)=""
"RTN","HLCSHDR1",56,0)
 ;batch/name/id/type(#9)=null~process ID~msg type|evnt type~version~CA~AA
"RTN","HLCSHDR1",57,0)
 S BNAME=$E(EC,1)_HLPID_$E(EC,1)_MSGTYPE_$E(EC,1)_$P(PROT,U,9)_$E(EC,1)_ACCACK_$E(EC,1)_APPACK ;HL*1.6*80
"RTN","HLCSHDR1",58,0)
 ;for batch ACK
"RTN","HLCSHDR1",59,0)
 I ACKTO D  S BTACK=X_$E(EC,1)_$P(BSTATUS,U,3)
"RTN","HLCSHDR1",60,0)
 . ;get msg id and status of message that is being ACKed
"RTN","HLCSHDR1",61,0)
 . S ACKMID=$P($G(^HLMA(ACKTO,0)),U,2),BSTATUS=$G(^HLMA(ACKTO,"P")) ;HL*1.6*80
"RTN","HLCSHDR1",62,0)
 . ;set type of ACK based on status
"RTN","HLCSHDR1",63,0)
 . S X=$S(ACKMID="":"AR",(BSTATUS>3)&(BSTATUS<8):"AE",1:"AA")
"RTN","HLCSHDR1",64,0)
 ;
"RTN","HLCSHDR1",65,0)
 D RESET^HLCSHDR3 ;HL*1.6*93
"RTN","HLCSHDR1",66,0)
 S HLHDRI=1,HLHDR(1)="BHS"_FS_EC_FS_SERAPP,HLHDRL=$L(HLHDR(1))
"RTN","HLCSHDR1",67,0)
 F X=SERFAC,CLNTAPP,CLNTFAC,HLDATE,SECURITY,BNAME,BTACK,HLID,ACKMID D MSH(X)
"RTN","HLCSHDR1",68,0)
 Q
"RTN","HLCSHDR1",69,0)
VAR ;Check input
"RTN","HLCSHDR1",70,0)
 N APPPRM,HLPROTS,HLPROT
"RTN","HLCSHDR1",71,0)
 S IEN=+$G(IEN)
"RTN","HLCSHDR1",72,0)
 I '$G(^HLMA(IEN,0)) S HLERROR="Valid pointer to Message Administration file (#772) not passed" Q
"RTN","HLCSHDR1",73,0)
 I '$G(CLIENT) S HLERROR="Could not determine receiving application" Q
"RTN","HLCSHDR1",74,0)
 ;Get child, text pointer,text entry, and sending app.
"RTN","HLCSHDR1",75,0)
 S CHILD=$G(^HLMA(IEN,0)),SEND=+$P($G(^(0)),U,11),TXTP=+CHILD,TXTP0=$G(^HL(772,TXTP,0))
"RTN","HLCSHDR1",76,0)
 I ('SEND) S HLERROR="Could not determine sending application" Q
"RTN","HLCSHDR1",77,0)
 ;Get info for sending & receiving applications
"RTN","HLCSHDR1",78,0)
 D APPPRM^HLUTIL2(CLIENT),APPPRM^HLUTIL2(SEND)
"RTN","HLCSHDR1",79,0)
 ;Get name of sending application, facility, and country
"RTN","HLCSHDR1",80,0)
 S SERAPP=$P(APPPRM(SEND,0),U),SERFAC=$P(APPPRM(SEND,0),U,2),CNTRY=$P(APPPRM(SEND,0),U,3)
"RTN","HLCSHDR1",81,0)
 ;Get name of receiving application and facility
"RTN","HLCSHDR1",82,0)
 S CLNTAPP=$P(APPPRM(CLIENT,0),U),CLNTFAC=$P(APPPRM(CLIENT,0),U,2)
"RTN","HLCSHDR1",83,0)
 ;Get field separator & encoding characters
"RTN","HLCSHDR1",84,0)
 S FS=APPPRM(SEND,"FS"),EC=APPPRM(SEND,"EC")
"RTN","HLCSHDR1",85,0)
 S:(EC="") EC="~|\&" S:(FS="") FS="^"
"RTN","HLCSHDR1",86,0)
 ;Determine if it's a response/ACK to another message
"RTN","HLCSHDR1",87,0)
 S ACKTO=+$P(CHILD,U,10)
"RTN","HLCSHDR1",88,0)
 ;subscriber protocol is from child (file 773)
"RTN","HLCSHDR1",89,0)
 ;If response, get MType from subscriber
"RTN","HLCSHDR1",90,0)
 S HLPROTS=+$P(CHILD,U,8)
"RTN","HLCSHDR1",91,0)
 S PROTS=$$TYPE^HLUTIL2(HLPROTS)
"RTN","HLCSHDR1",92,0)
 I ACKTO S MSGTYPE=$P(PROTS,U,10),EVNTYPE=$P(PROTS,U,3),MSGEVN=$P(PROTS,U,4)
"RTN","HLCSHDR1",93,0)
 ;Get accept ack & application ack type (based on server protocol) it
"RTN","HLCSHDR1",94,0)
 ; is always in file 772, TXPT0
"RTN","HLCSHDR1",95,0)
 ;If original message, get MT from Event Driver Protocol
"RTN","HLCSHDR1",96,0)
 S HLPROT=+$P(TXTP0,U,10)
"RTN","HLCSHDR1",97,0)
 S PROT=$$TYPE^HLUTIL2(HLPROT)
"RTN","HLCSHDR1",98,0)
 S:'ACKTO MSGTYPE=$P(PROT,U,2),EVNTYPE=$P(PROT,U,3),MSGEVN=$P(PROT,U,4)
"RTN","HLCSHDR1",99,0)
 S ACCACK=$P(PROT,U,7),APPACK=$P(PROT,U,8)
"RTN","HLCSHDR1",100,0)
PID ;Processing ID
"RTN","HLCSHDR1",101,0)
 ;I PID not 'debug' get from site params
"RTN","HLCSHDR1",102,0)
 ;If event driver set to 'debug' get from protocol
"RTN","HLCSHDR1",103,0)
 ;'production' or 'training' comes from site params
"RTN","HLCSHDR1",104,0)
 S HLPID=$P(PROT,U,5)
"RTN","HLCSHDR1",105,0)
 I $G(HLPID)'="D" S HLPID=$P(HLPARAM,U,3)
"RTN","HLCSHDR1",106,0)
 I $G(HLPID)="" S HLERROR="Missing processing ID Site parameter."
"RTN","HLCSHDR1",107,0)
 ;acknowledgements have no application ack, link open no commit ack
"RTN","HLCSHDR1",108,0)
 I ACKTO S:APPACK]"" APPACK="NE" S:ACCACK]""&$G(HLTCPO) ACCACK="NE"
"RTN","HLCSHDR1",109,0)
 ;Get date/time, Message ID, and security
"RTN","HLCSHDR1",110,0)
 S HLDATE=+TXTP0,HLDATE=$$FMTHL7^XLFDT(HLDATE),HLID=$P(CHILD,U,2),SECURITY=$P(CHILD,U,9)
"RTN","HLCSHDR1",111,0)
HDR23 ;generate extended facility field info based on 'facility required'
"RTN","HLCSHDR1",112,0)
 ;default format is INSTITUTION_HLCS_DOMAIN_HLCS_'DNS'
"RTN","HLCSHDR1",113,0)
 ;application parameter entry overrides default
"RTN","HLCSHDR1",114,0)
 N HLEP773,HLS773
"RTN","HLCSHDR1",115,0)
 S SERFAC=$G(SERFAC),CLNTFAC=$G(CLNTFAC)
"RTN","HLCSHDR1",116,0)
 S HLEP773=+$G(^ORD(101,HLPROTS,773))
"RTN","HLCSHDR1",117,0)
 S HLS773=+$P($G(^ORD(101,HLPROTS,773)),U,2)
"RTN","HLCSHDR1",118,0)
 Q:'HLEP773&('HLS773)
"RTN","HLCSHDR1",119,0)
 D GEN^HLCSHDR2
"RTN","HLCSHDR1",120,0)
 I ACKTO D  Q
"RTN","HLCSHDR1",121,0)
 .;Find original message
"RTN","HLCSHDR1",122,0)
 .S X=$G(^HLMA(ACKTO,"MSH",1,0)) ;Find header in TCP nodes
"RTN","HLCSHDR1",123,0)
 .I X["MSH" D
"RTN","HLCSHDR1",124,0)
 ..S HLFS=$E(X,4)
"RTN","HLCSHDR1",125,0)
 ..S SENDFAC=$P(X,HLFS,4),RECFAC=$P(X,HLFS,6) ;from original msg
"RTN","HLCSHDR1",126,0)
 ..S CLNTFAC=SENDFAC,SERFAC=RECFAC ;reverse facility info
"RTN","HLCSHDR1",127,0)
 I HLEP773,SERFAC="" D EP^HLCSHDR2
"RTN","HLCSHDR1",128,0)
 I HLS773,CLNTFAC="" D S^HLCSHDR2
"RTN","HLCSHDR1",129,0)
 Q
"RTN","HLCSHDR1",130,0)
 ;
"RTN","HLCSHDR3")
0^2^B33464514
"RTN","HLCSHDR3",1,0)
HLCSHDR3 ;SFIRMFO/LJA - Reset MSH Segment Fields ;9/12/02 11:50
"RTN","HLCSHDR3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**93**;Oct 13, 1995
"RTN","HLCSHDR3",3,0)
 ;
"RTN","HLCSHDR3",4,0)
 ; Reset RECEIVING APPLICATION and RECEIVING SITE of MSH segment - HL*1.6*93
"RTN","HLCSHDR3",5,0)
 ;
"RTN","HLCSHDR3",6,0)
RESET ; Called from HEADER^HLCSHDR1 & BHSHDR^HLCSHDR1, which is called by
"RTN","HLCSHDR3",7,0)
 ; GENERATE^HLMA & GENACK^HLMA1.
"RTN","HLCSHDR3",8,0)
 N MTIEN
"RTN","HLCSHDR3",9,0)
 ;
"RTN","HLCSHDR3",10,0)
 ; Even if set already, set 772 IEN again...
"RTN","HLCSHDR3",11,0)
 S MTIEN=+$G(^HLMA(+$G(IEN),0)) QUIT:$G(^HL(772,+MTIEN,0))']""  ;->
"RTN","HLCSHDR3",12,0)
 ;
"RTN","HLCSHDR3",13,0)
 ; Different variables used for Event Protocol
"RTN","HLCSHDR3",14,0)
 D MSHCHG($G(HLEID),$S($G(EIDS)>0:+EIDS,1:+$G(HLEIDS)),$G(MTIEN),$G(IEN),.SERAPP,.SERFAC,.CLNTAPP,.CLNTFAC,.HLP)
"RTN","HLCSHDR3",15,0)
 ;
"RTN","HLCSHDR3",16,0)
 QUIT
"RTN","HLCSHDR3",17,0)
 ;
"RTN","HLCSHDR3",18,0)
MSHCHG(HLEID,EIDS,MTIEN,IEN,SERAPP,SERFAC,CLNTAPP,CLNTFAC,HLPARR) ; The parameters
"RTN","HLCSHDR3",19,0)
 ; are the required input variables.  Call here "by reference".  
"RTN","HLCSHDR3",20,0)
 ;
"RTN","HLCSHDR3",21,0)
 ;  HLEID=Event driver protocol IEN
"RTN","HLCSHDR3",22,0)
 ;   EIDS=Subscriber protocol IEN
"RTN","HLCSHDR3",23,0)
 ;  MTIEN=772 IEN
"RTN","HLCSHDR3",24,0)
 ;    IEN=773 IEN
"RTN","HLCSHDR3",25,0)
 ; SERAPP=Sending App text
"RTN","HLCSHDR3",26,0)
 ; SERFAC=Sending Fac text
"RTN","HLCSHDR3",27,0)
 ;CLNTAPP=Rec (client) app text
"RTN","HLCSHDR3",28,0)
 ;CLNTFAC=Rec (client) fac text
"RTN","HLCSHDR3",29,0)
 ;   HLP()=HLP("SUBSCRIBER") array
"RTN","HLCSHDR3",30,0)
 ;
"RTN","HLCSHDR3",31,0)
 ; The MSH segment is built (usually) in HLCSHDR1.  Immediately before
"RTN","HLCSHDR3",32,0)
 ; using the existing local variables to concatenate them together into
"RTN","HLCSHDR3",33,0)
 ; the MSH segment, HLCSHDR1 calls here to see if some of the local
"RTN","HLCSHDR3",34,0)
 ; variables should be reset.
"RTN","HLCSHDR3",35,0)
 ;
"RTN","HLCSHDR3",36,0)
 ; Resetting the local variables used in creating the MSH segment
"RTN","HLCSHDR3",37,0)
 ; gives those creating HL7 messages control over the local variables
"RTN","HLCSHDR3",38,0)
 ; that can be changed below.
"RTN","HLCSHDR3",39,0)
 ;
"RTN","HLCSHDR3",40,0)
 ; There are rules that govern what the creator of the MSH segment
"RTN","HLCSHDR3",41,0)
 ; can change:
"RTN","HLCSHDR3",42,0)
 ;
"RTN","HLCSHDR3",43,0)
 ; Rule #1: The SENDING APPLICATION can be changed.   Var=HLMSHSAN
"RTN","HLCSHDR3",44,0)
 ; Rule #2: The SENDING FACILITY can be changed.      Var=HLMSHSFN
"RTN","HLCSHDR3",45,0)
 ; Rule #3: The RECEIVING APPLICATION can be changed. Var=HLMSHRAN
"RTN","HLCSHDR3",46,0)
 ; Rule #4: The RECEIVING FACILITY can be changed.    Var=HLMSHRFN
"RTN","HLCSHDR3",47,0)
 ; Rule #5: No other fields in the MSH segment can be changed.
"RTN","HLCSHDR3",48,0)
 ;
"RTN","HLCSHDR3",49,0)
 ; If the passed in HLP() array entry used to reset the above four
"RTN","HLCSHDR3",50,0)
 ; fields holds the text used, the variables above will be reset.
"RTN","HLCSHDR3",51,0)
 ; If M code is used, the M code itself is responsible for setting
"RTN","HLCSHDR3",52,0)
 ; these specific local variables.
"RTN","HLCSHDR3",53,0)
 ;
"RTN","HLCSHDR3",54,0)
 ; The following local variables are created and made available for
"RTN","HLCSHDR3",55,0)
 ; use by M code:
"RTN","HLCSHDR3",56,0)
 ;
"RTN","HLCSHDR3",57,0)
 ; Protocol, Event:                  HLMSHPRE  (IEN^NAME)
"RTN","HLCSHDR3",58,0)
 ; Protocol, Subscriber:             HLMSHPRS  (IEN^NAME)
"RTN","HLCSHDR3",59,0)
 ;
"RTN","HLCSHDR3",60,0)
 ; HL Message Text file (#772) IEN:  HLMSH772  (IEN)
"RTN","HLCSHDR3",61,0)
 ; HL Message Admin file (#773) IEN: HLMSH773  (IEN)
"RTN","HLCSHDR3",62,0)
 ; 
"RTN","HLCSHDR3",63,0)
 ; Sending Application, Original:    HLMSHSAO  (SERAPP)
"RTN","HLCSHDR3",64,0)
 ; Sending Application, New:         HLMSHSAN
"RTN","HLCSHDR3",65,0)
 ; Sending Facility, Original:       HLMSHSFO  (SERFAC)
"RTN","HLCSHDR3",66,0)
 ; Sending Facility, New:            HLMSHSFN
"RTN","HLCSHDR3",67,0)
 ; Receiving Application, Original:  HLMSHRAO  (CLNTAPP)
"RTN","HLCSHDR3",68,0)
 ; Receiving Application, New:       HLMSHRAN
"RTN","HLCSHDR3",69,0)
 ; Receiving Facility, Original:     HLMSHRFO  (CLNTFAC)
"RTN","HLCSHDR3",70,0)
 ; Receiving Facility, New:          HLMSHRFN
"RTN","HLCSHDR3",71,0)
 ;
"RTN","HLCSHDR3",72,0)
 ; M Code SUBROUTINE:                HLMSHTAG
"RTN","HLCSHDR3",73,0)
 ; M Code ROUTINE:                   HLMSHRTN
"RTN","HLCSHDR3",74,0)
 ;
"RTN","HLCSHDR3",75,0)
 ; See the documentation in patch HL*1.6*93 in the Forum patch module
"RTN","HLCSHDR3",76,0)
 ; for additional information.
"RTN","HLCSHDR3",77,0)
 ;
"RTN","HLCSHDR3",78,0)
 ; CLIENT -- req
"RTN","HLCSHDR3",79,0)
 ;
"RTN","HLCSHDR3",80,0)
 ; HLMSH-namespaced variables created below
"RTN","HLCSHDR3",81,0)
 N HLDEBUG,HLMSH101,HLMSH31,HLMSH31C,HLMSH32,HLMSH32C
"RTN","HLCSHDR3",82,0)
 N HLMSH33,HLMSH33C,HLMSH34,HLMSH34C,HLMSH772,HLMSH773,HLMSH91
"RTN","HLCSHDR3",83,0)
 N HLMSHAN,HLMSHFN,HLMSHPRE,HLMSHPRS
"RTN","HLCSHDR3",84,0)
 N HLMSHRTN,HLMSHRAN,HLMSHRAO,HLMSHRFN
"RTN","HLCSHDR3",85,0)
 N HLMSHRFO,HLMSHSAN,HLMSHSAO,HLMSHSFN,HLMSHSFO
"RTN","HLCSHDR3",86,0)
 N HLMSHPRO,HLMSHREF,HLMSHSUB,HLMSHTAG
"RTN","HLCSHDR3",87,0)
 ;
"RTN","HLCSHDR3",88,0)
 ; Non-HLMSH-namespaced variables created below
"RTN","HLCSHDR3",89,0)
 N HLPWAY,HLRAN,HLRFN,HLSAN,HLSFN,HLTYPE
"RTN","HLCSHDR3",90,0)
 ;
"RTN","HLCSHDR3",91,0)
 ;
"RTN","HLCSHDR3",92,0)
 ; Set up variables pass #1...
"RTN","HLCSHDR3",93,0)
 S (HLMSH31,HLMSH32,HLMSH33,HLMSH34)=""
"RTN","HLCSHDR3",94,0)
 S (HLMSH31C,HLMSH32C,HLMSH33C,HLMSH34C)=""
"RTN","HLCSHDR3",95,0)
 S HLMSHPRE=$G(HLEID)_U_$P($G(^ORD(101,+$G(HLEID),0)),U) ; Event 101
"RTN","HLCSHDR3",96,0)
 S HLMSHPRS=$G(EIDS)_U_$P($G(^ORD(101,+$G(EIDS),0)),U) ; Sub 101
"RTN","HLCSHDR3",97,0)
 S HLMSH772=$G(MTIEN)
"RTN","HLCSHDR3",98,0)
 S HLMSH773=$G(IEN) QUIT:'$D(^HLMA(+HLMSH773,0))  ;->
"RTN","HLCSHDR3",99,0)
 ;
"RTN","HLCSHDR3",100,0)
 ; Get passed-in-by-reference HLP("SUBSCRIBER") data into variable...
"RTN","HLCSHDR3",101,0)
 S HLMSHPRO=$$HLMSHPRO QUIT:HLMSHPRO']""  ;->
"RTN","HLCSHDR3",102,0)
 ;
"RTN","HLCSHDR3",103,0)
 ; Should DEBUG data be stored? (This can be overwritten in $$HLMSHPRO)
"RTN","HLCSHDR3",104,0)
 I $G(HLDEBUG)']"" S HLDEBUG=$P($P(HLMSHPRO,"~",2),U,8)
"RTN","HLCSHDR3",105,0)
 ;                   HLDEBUG might be already set in $$HLMSHPRO
"RTN","HLCSHDR3",106,0)
 S HLDEBUG=$TR(HLDEBUG,"- /",U) ; Change delimiters to ^
"RTN","HLCSHDR3",107,0)
 ;
"RTN","HLCSHDR3",108,0)
 ; HLDEBUG (#1-#2-#3) Explanation...
"RTN","HLCSHDR3",109,0)
 ; -- #1 can be 0 (NO) or 1 (YES) for whether ^HLMA(#,90) data stored
"RTN","HLCSHDR3",110,0)
 ; -- #2 can be 0 or 1 for whether ^HLMA(#,91) data should be stored
"RTN","HLCSHDR3",111,0)
 ; -- #3 can be 0 or 1 or 2 for what type of ^XTMP data should be stored
"RTN","HLCSHDR3",112,0)
 ;    -- Data is stored in ^XTMP("HLCSHDR3 "_IEN773)
"RTN","HLCSHDR3",113,0)
 ;    -- 0 = No XTMP data should be stored
"RTN","HLCSHDR3",114,0)
 ;    -- 1 = Store only SOME of the data
"RTN","HLCSHDR3",115,0)
 ;    -- 2 = Store ALL variable data
"RTN","HLCSHDR3",116,0)
 ;       
"RTN","HLCSHDR3",117,0)
 ; Store HLP("SUBSCRIBER"[,#]) in ^HLMA(#,90)
"RTN","HLCSHDR3",118,0)
 I $P(HLDEBUG,U)=1 D
"RTN","HLCSHDR3",119,0)
 .  S X=$P(HLMSHPRO,"~",2) I X]"" S ^HLMA(+HLMSH773,90)=X
"RTN","HLCSHDR3",120,0)
 ;
"RTN","HLCSHDR3",121,0)
 ; Found by general HLP("SUBSCRIBER") or specific HLP("SUBSCRIBER",#) entry?
"RTN","HLCSHDR3",122,0)
 S HLPWAY=$P(HLMSHPRO,"~"),HLMSHREF=$P(HLMSHPRO,"~",3),HLMSHPRO=$P(HLMSHPRO,"~",2)
"RTN","HLCSHDR3",123,0)
 ;
"RTN","HLCSHDR3",124,0)
 ; Set up variables pass #2...
"RTN","HLCSHDR3",125,0)
 S HLMSHSAO=$G(SERAPP),(HLSAN,HLMSHSAN)=$P(HLMSHPRO,U,2) ;  Send App
"RTN","HLCSHDR3",126,0)
 S HLMSHSFO=$G(SERFAC),(HLSFN,HLMSHSFN)=$P(HLMSHPRO,U,3) ;  Send Fac
"RTN","HLCSHDR3",127,0)
 S HLMSHRAO=$G(CLNTAPP),(HLRAN,HLMSHRAN)=$P(HLMSHPRO,U,4) ; Rec App
"RTN","HLCSHDR3",128,0)
 S HLMSHRFO=$G(CLNTFAC),(HLRFN,HLMSHRFN)=$P(HLMSHPRO,U,5) ; Rec Fac
"RTN","HLCSHDR3",129,0)
 ;
"RTN","HLCSHDR3",130,0)
 ; If there's an Xecution routine, do now...
"RTN","HLCSHDR3",131,0)
 S HLMSHTAG=$P(HLMSHPRO,U,6),HLMSHRTN=$P(HLMSHPRO,U,7)
"RTN","HLCSHDR3",132,0)
 I HLMSHTAG]"",HLMSHRTN]"" D @HLMSHTAG^@HLMSHRTN
"RTN","HLCSHDR3",133,0)
 I HLMSHTAG']"",HLMSHRTN]"" D ^@HLMSHRTN
"RTN","HLCSHDR3",134,0)
 ;
"RTN","HLCSHDR3",135,0)
 ; Start work for ^HLMA(#,91) node...
"RTN","HLCSHDR3",136,0)
 S HLMSH91="" ; HLMSH91 is the data that will be stored in ^(91)
"RTN","HLCSHDR3",137,0)
 I SERAPP'=HLMSHSAN D SET91M(1,SERAPP,HLSAN,HLMSHSAN) ; Reset by M code?
"RTN","HLCSHDR3",138,0)
 I SERFAC'=HLMSHSFN D SET91M(3,SERFAC,HLSFN,HLMSHSFN)
"RTN","HLCSHDR3",139,0)
 I CLNTAPP'=HLMSHRAN D SET91M(5,CLNTAPP,HLRAN,HLMSHRAN)
"RTN","HLCSHDR3",140,0)
 I CLNTFAC'=HLMSHRFN D SET91M(7,CLNTFAC,HLRFN,HLMSHRFN)
"RTN","HLCSHDR3",141,0)
 ;
"RTN","HLCSHDR3",142,0)
 ; The real resetting of MSH segment variables work is done here...
"RTN","HLCSHDR3",143,0)
 D SET^HLCSHDR4(HLMSHSAN,"SERAPP",1) ; Update SERAPP if different, and DATA too...
"RTN","HLCSHDR3",144,0)
 D SET^HLCSHDR4(HLMSHSFN,"SERFAC",3) ; Etc
"RTN","HLCSHDR3",145,0)
 D SET^HLCSHDR4(HLMSHRAN,"CLNTAPP",5) ; Etc
"RTN","HLCSHDR3",146,0)
 D SET^HLCSHDR4(HLMSHRFN,"CLNTFAC",7) ; Etc
"RTN","HLCSHDR3",147,0)
 ;
"RTN","HLCSHDR3",148,0)
 ; Set ^HLMA(#,91) node if overwrites occurred...
"RTN","HLCSHDR3",149,0)
 I HLMSH91]"" S ^HLMA(+HLMSH773,91)=HLMSH91
"RTN","HLCSHDR3",150,0)
 ;
"RTN","HLCSHDR3",151,0)
 ; If debugging, record pre variable view...
"RTN","HLCSHDR3",152,0)
 D DEBUG^HLCSHDR4($P(HLDEBUG,U,3))
"RTN","HLCSHDR3",153,0)
 ;
"RTN","HLCSHDR3",154,0)
 QUIT
"RTN","HLCSHDR3",155,0)
 ;
"RTN","HLCSHDR3",156,0)
SET91M(PCE,MSH,PREM,POSTM) ; If M code re/set the MSH field, record...
"RTN","HLCSHDR3",157,0)
 QUIT:PREM=POSTM  ;-> M code did not change anything...
"RTN","HLCSHDR3",158,0)
 S $P(HLMSH91,U,PCE)=MSH ;  original (pre-overwrite) value
"RTN","HLCSHDR3",159,0)
 S $P(HLMSH91,U,PCE+1)="M" ; Overwrite source (A/M)
"RTN","HLCSHDR3",160,0)
 QUIT
"RTN","HLCSHDR3",161,0)
 ;
"RTN","HLCSHDR3",162,0)
HLMSHPRO() ; Determines whether to use the generic HLP("SUBSCRIBER") data,
"RTN","HLCSHDR3",163,0)
 ; or instead - if existent - the HLP("SUBSCRIBER",#)=SUB PROTOCOL^... data
"RTN","HLCSHDR3",164,0)
 ;CLIENT -- req
"RTN","HLCSHDR3",165,0)
 N HLD,HLFIND,HLI,HLMSHREF,HLMSHSUB,HLX
"RTN","HLCSHDR3",166,0)
 ;
"RTN","HLCSHDR3",167,0)
 ; Get the default information...
"RTN","HLCSHDR3",168,0)
 S HLMSHSUB=$G(HLP("SUBSCRIBER")),HLMSHREF=999
"RTN","HLCSHDR3",169,0)
 ;
"RTN","HLCSHDR3",170,0)
 ; Overwrite HLMSHSUB if found...
"RTN","HLCSHDR3",171,0)
 S HLI=0,HLFIND=""
"RTN","HLCSHDR3",172,0)
 F  S HLI=$O(HLP("SUBSCRIBER",HLI)) Q:HLI'>0!(HLFIND]"")  D
"RTN","HLCSHDR3",173,0)
 .  S HLD=$G(HLP("SUBSCRIBER",+HLI)) QUIT:HLD']""  ;->
"RTN","HLCSHDR3",174,0)
 .  S HLD=$P(HLD,U) QUIT:HLD']""  ;->
"RTN","HLCSHDR3",175,0)
 .  ; If passed name..
"RTN","HLCSHDR3",176,0)
 .  I HLD'=+HLD S HLD=$$FIND101(HLD)
"RTN","HLCSHDR3",177,0)
 .  ; Must have IEN by now...
"RTN","HLCSHDR3",178,0)
 .  QUIT:+HLD'=+HLMSHPRS  ;-> Not for right subscriber protocol
"RTN","HLCSHDR3",179,0)
 .  S HLFIND=HLP("SUBSCRIBER",+HLI),HLMSHREF=+HLI
"RTN","HLCSHDR3",180,0)
 ;
"RTN","HLCSHDR3",181,0)
 ; Backdoor overwrite of HLDEBUG value...
"RTN","HLCSHDR3",182,0)
 ; - This is a very important back door!!  Even if applications
"RTN","HLCSHDR3",183,0)
 ; - aren't logging debug data, it can be turned on by setting
"RTN","HLCSHDR3",184,0)
 ; - ^XTMP("HLCSHDR3 DEBUG","DEBUG") or ^XTMP("HLCSHDR3 DEBUG","DEBUG",SUB-101)
"RTN","HLCSHDR3",185,0)
 ; If the GENERAL entry exists, set HLDEBUG.  Might be written next line though
"RTN","HLCSHDR3",186,0)
 S HLX=$G(^XTMP("HLCSHDR3 DEBUG","DEBUG")) I HLX]"" S HLDEBUG=HLX
"RTN","HLCSHDR3",187,0)
 ; If a SPECIFIC entry found, reset HLDEBUG to it...
"RTN","HLCSHDR3",188,0)
 S HLX=$G(^XTMP("HLCSHDR3 DEBUG","DEBUG",+HLFIND)) I HLX]"" S HLDEBUG=HLX
"RTN","HLCSHDR3",189,0)
 ;
"RTN","HLCSHDR3",190,0)
 QUIT $S(HLFIND]"":"S~"_HLFIND_"~"_HLMSHREF,HLMSHSUB]"":"G~"_HLMSHSUB_"~"_HLMSHREF,1:"")
"RTN","HLCSHDR3",191,0)
 ;
"RTN","HLCSHDR3",192,0)
FIND101(PROTNM) ; Find 101 entry...
"RTN","HLCSHDR3",193,0)
 N D,DIC,X,Y
"RTN","HLCSHDR3",194,0)
 S DIC="^ORD(101,",DIC(0)="MQ",D="B",X=PROTNM
"RTN","HLCSHDR3",195,0)
 D MIX^DIC1
"RTN","HLCSHDR3",196,0)
 QUIT $S(Y>0:+Y,1:"")
"RTN","HLCSHDR3",197,0)
 ;
"RTN","HLCSHDR3",198,0)
SHOW773(IEN773) ; Show reset info from 773 entry...
"RTN","HLCSHDR3",199,0)
 QUIT
"RTN","HLCSHDR3",200,0)
 ;
"RTN","HLCSHDR3",201,0)
EOR ;HLCSHDR3 - Reset MSH Segment Fields ;9/12/02 11:50
"RTN","HLCSHDR4")
0^3^B74613551
"RTN","HLCSHDR4",1,0)
HLCSHDR4 ;SFIRMFO/LJA - Reset MSH Segment Fields ;9/12/02 11:50
"RTN","HLCSHDR4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**93**;Oct 13, 1995
"RTN","HLCSHDR4",3,0)
 ;
"RTN","HLCSHDR4",4,0)
DEBUG(STORE) ; If HLP set up for debugging, capture VIEW...
"RTN","HLCSHDR4",5,0)
 ; HLMSH773 -- req
"RTN","HLCSHDR4",6,0)
 ;
"RTN","HLCSHDR4",7,0)
 N NOW,NUM,VAR,VARS,X,XTMP
"RTN","HLCSHDR4",8,0)
 ;
"RTN","HLCSHDR4",9,0)
 ; 1=some, 2=all
"RTN","HLCSHDR4",10,0)
 S STORE=$S(STORE=1:1,STORE=2:2,1:0) QUIT:'STORE  ;->
"RTN","HLCSHDR4",11,0)
 ;
"RTN","HLCSHDR4",12,0)
 S NOW=$$NOW^XLFDT
"RTN","HLCSHDR4",13,0)
 ;
"RTN","HLCSHDR4",14,0)
 S XTMP="HLCSHDR3 "_HLMSH773
"RTN","HLCSHDR4",15,0)
 S:'$D(^XTMP(XTMP,0)) ^XTMP(XTMP,0)=$$FMADD^XLFDT(NOW,0,4)_U_NOW_U_"Debug data created by DEBUG~HLCSHDR4"
"RTN","HLCSHDR4",16,0)
 ;
"RTN","HLCSHDR4",17,0)
 S NUM=$O(^XTMP(XTMP,":"),-1)+1
"RTN","HLCSHDR4",18,0)
 ;
"RTN","HLCSHDR4",19,0)
 ; Grab only critical (some) variables?
"RTN","HLCSHDR4",20,0)
 I STORE=1 D
"RTN","HLCSHDR4",21,0)
 .
"RTN","HLCSHDR4",22,0)
 .  ; Sending information...
"RTN","HLCSHDR4",23,0)
 .  S ^XTMP(XTMP,NUM,"SA")=HLMSHSAO_U_HLSAN_U_HLMSHSAN
"RTN","HLCSHDR4",24,0)
 .  S ^XTMP(XTMP,NUM,"SF")=HLMSHSFO_U_HLSFN_U_HLMSHSFN
"RTN","HLCSHDR4",25,0)
 .
"RTN","HLCSHDR4",26,0)
 .  ; Receiving information...
"RTN","HLCSHDR4",27,0)
 .  S ^XTMP(XTMP,NUM,"RA")=HLMSHRAO_U_HLRAN_U_HLMSHRAN
"RTN","HLCSHDR4",28,0)
 .  S ^XTMP(XTMP,NUM,"RF")=HLMSHRFO_U_HLRFN_U_HLMSHRFN
"RTN","HLCSHDR4",29,0)
 .
"RTN","HLCSHDR4",30,0)
 .  ; Other information...    (HLMSHPRE and HLMSHPRS hold 2 pieces!)
"RTN","HLCSHDR4",31,0)
 .  S ^XTMP(XTMP,NUM,0)=NOW_U_HLMSH772_U_HLMSHPRE_U_HLMSHPRS
"RTN","HLCSHDR4",32,0)
 .  S ^XTMP(XTMP,NUM,1)=HLMSHPRO
"RTN","HLCSHDR4",33,0)
 ;
"RTN","HLCSHDR4",34,0)
 ; Grab all variables?
"RTN","HLCSHDR4",35,0)
 I STORE=2 D
"RTN","HLCSHDR4",36,0)
 .  S X="^XTMP("""_XTMP_""","_NUM_","
"RTN","HLCSHDR4",37,0)
 .  D DOLRO^%ZOSV
"RTN","HLCSHDR4",38,0)
 ;
"RTN","HLCSHDR4",39,0)
 QUIT
"RTN","HLCSHDR4",40,0)
 ;
"RTN","HLCSHDR4",41,0)
SHOW N I773
"RTN","HLCSHDR4",42,0)
 F  R !!,"Enter 773 IEN: ",I773:60 Q:I773'>0  D
"RTN","HLCSHDR4",43,0)
 .  D SHOW773(I773)
"RTN","HLCSHDR4",44,0)
 QUIT
"RTN","HLCSHDR4",45,0)
 ;
"RTN","HLCSHDR4",46,0)
SHOW773(I773) ; Show Dynamic Routing MSH Field Reset Details
"RTN","HLCSHDR4",47,0)
 N DIV,MSH,N90,N91
"RTN","HLCSHDR4",48,0)
 ;
"RTN","HLCSHDR4",49,0)
 S N90=$G(^HLMA(+I773,90)),N91=$G(^HLMA(+I773,91))
"RTN","HLCSHDR4",50,0)
 I (N90_N91)']"" D  QUIT  ;->
"RTN","HLCSHDR4",51,0)
 .  W "  no debug data found..."
"RTN","HLCSHDR4",52,0)
 ;
"RTN","HLCSHDR4",53,0)
 S MSH=$G(^HLMA(+I773,"MSH",1,0)) QUIT:MSH']""  ;->
"RTN","HLCSHDR4",54,0)
 S DIV=$E(MSH,4)
"RTN","HLCSHDR4",55,0)
 ;
"RTN","HLCSHDR4",56,0)
 W !!,$$CJ^XLFSTR(" 773 # "_I773_" ",IOM,"=")
"RTN","HLCSHDR4",57,0)
 ;
"RTN","HLCSHDR4",58,0)
 D HDR(90,N90)
"RTN","HLCSHDR4",59,0)
 ;
"RTN","HLCSHDR4",60,0)
 W !
"RTN","HLCSHDR4",61,0)
 D HDR(91,N91)
"RTN","HLCSHDR4",62,0)
 ;
"RTN","HLCSHDR4",63,0)
 W !!,$E(MSH,1,IOM)
"RTN","HLCSHDR4",64,0)
 ;
"RTN","HLCSHDR4",65,0)
 S C1=10,C2=30,C3=50
"RTN","HLCSHDR4",66,0)
 W !!,?C1,"Original (91)",?2,"Array (90)",?3,"MSH-Segment"
"RTN","HLCSHDR4",67,0)
 W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLCSHDR4",68,0)
 D LINE("snd app",1,2,3)
"RTN","HLCSHDR4",69,0)
 D LINE("snd fac",3,3,4)
"RTN","HLCSHDR4",70,0)
 D LINE("rec app",5,4,5)
"RTN","HLCSHDR4",71,0)
 D LINE("rec fac",7,5,6)
"RTN","HLCSHDR4",72,0)
 ;
"RTN","HLCSHDR4",73,0)
 QUIT
"RTN","HLCSHDR4",74,0)
 ;
"RTN","HLCSHDR4",75,0)
LINE(HDR,PCE1,PCE2,PCE3) ; Print one comparison line...
"RTN","HLCSHDR4",76,0)
 N P1,P2,P3,P4
"RTN","HLCSHDR4",77,0)
 S P1=$P(N91,U,PCE1),P2=$P(N90,U,PCE2),P3=$P(MSH,DIV,PCE3),P4=$P(N91,U,PCE1+1)
"RTN","HLCSHDR4",78,0)
 W !,HDR,":",?C1,P1,?2,P2,?3,P3,$S(P4]"":" ["_P4_"]",1:"")
"RTN","HLCSHDR4",79,0)
 QUIT
"RTN","HLCSHDR4",80,0)
 ;
"RTN","HLCSHDR4",81,0)
HDR(NUM,DATA) N TXT
"RTN","HLCSHDR4",82,0)
 S TXT=$S(NUM=90:"Array (90)",NUM=91:"Original (91)",1:"")
"RTN","HLCSHDR4",83,0)
 W !,$$CJ^XLFSTR("---------- "_TXT_" ----------",IOM)
"RTN","HLCSHDR4",84,0)
 W $$CJ^XLFSTR(DATA,IOM)
"RTN","HLCSHDR4",85,0)
 QUIT
"RTN","HLCSHDR4",86,0)
 ;
"RTN","HLCSHDR4",87,0)
SET(NEW,VAR,PCE) ; This subroutine performs these actions:
"RTN","HLCSHDR4",88,0)
 ; (1) Resets variables used in MSH segment
"RTN","HLCSHDR4",89,0)
 ; (2) Resets SERAPP and CLNTAPP in ^HLMA(#,0)
"RTN","HLCSHDR4",90,0)
 ; (3) Sets HLMSH91 nodes if overwrite occurs by ARRAY value.
"RTN","HLCSHDR4",91,0)
 ;     If overwrite occurs by M code, the overwrite has already
"RTN","HLCSHDR4",92,0)
 ;     been recorded in HLMSH91.  (An overwrite produced by M code
"RTN","HLCSHDR4",93,0)
 ;     is never overwritten by ARRAY data.)
"RTN","HLCSHDR4",94,0)
 ;
"RTN","HLCSHDR4",95,0)
 N IEN771N,IEN771O,HLTCP
"RTN","HLCSHDR4",96,0)
 ;
"RTN","HLCSHDR4",97,0)
 ; VAR is the name of the variable, and not it's value...
"RTN","HLCSHDR4",98,0)
 S PRE=@VAR ; PRE is now the value of the VAR (pre-overwrite) variable...
"RTN","HLCSHDR4",99,0)
 ;
"RTN","HLCSHDR4",100,0)
 ; Tests whether anything was changed...
"RTN","HLCSHDR4",101,0)
 QUIT:NEW']""  ;-> No new value exists to change to...
"RTN","HLCSHDR4",102,0)
 QUIT:NEW=PRE  ;-> New value = Original value.  Nothing changed...
"RTN","HLCSHDR4",103,0)
 ;
"RTN","HLCSHDR4",104,0)
 ; THIS IS THE EPICENTER!!  This is where the variables used in
"RTN","HLCSHDR4",105,0)
 ; the MSH segment is overwritten.
"RTN","HLCSHDR4",106,0)
 S @VAR=NEW
"RTN","HLCSHDR4",107,0)
 ;
"RTN","HLCSHDR4",108,0)
 ; If PRE exists at this point, it was done by M code...
"RTN","HLCSHDR4",109,0)
 QUIT:$P(HLMSH91,U,PCE)]""  ;->
"RTN","HLCSHDR4",110,0)
 ;
"RTN","HLCSHDR4",111,0)
 ; Change was made, but not by M code.  Must be by array...
"RTN","HLCSHDR4",112,0)
 S $P(HLMSH91,U,PCE)=PRE,$P(HLMSH91,U,PCE+1)="A"
"RTN","HLCSHDR4",113,0)
 ;
"RTN","HLCSHDR4",114,0)
 ; Upgrade ^HLMA(#,0)...
"RTN","HLCSHDR4",115,0)
 QUIT:PCE'=1&(PCE'=5)  ;->
"RTN","HLCSHDR4",116,0)
 S IEN771O=$O(^HL(771,"B",PRE,0)) QUIT:IEN771O'>0  ;-> Orig IEN
"RTN","HLCSHDR4",117,0)
 S IEN771N=$O(^HL(771,"B",NEW,0)) QUIT:IEN771N'>0  ;-> New IEN
"RTN","HLCSHDR4",118,0)
 QUIT:'IEN771O!('IEN771N)!(IEN771O=IEN771N)  ;->
"RTN","HLCSHDR4",119,0)
 S HLTCP=1 ; So 773 is updated...
"RTN","HLCSHDR4",120,0)
 I PCE=1 D UPDATE^HLTF0(MTIENS,"","O","","",IEN771N)
"RTN","HLCSHDR4",121,0)
 I PCE=5 D UPDATE^HLTF0(MTIENS,"","O","",IEN771N)
"RTN","HLCSHDR4",122,0)
 ;
"RTN","HLCSHDR4",123,0)
 QUIT
"RTN","HLCSHDR4",124,0)
 ;
"RTN","HLCSHDR4",125,0)
FIELDS ; Display the Protocol file fields used by the VistA HL7 package,
"RTN","HLCSHDR4",126,0)
 ; when messages are received, to find the event and subscriber
"RTN","HLCSHDR4",127,0)
 ; protocols.
"RTN","HLCSHDR4",128,0)
 N BY,DIC,DIOEND,L
"RTN","HLCSHDR4",129,0)
 ;
"RTN","HLCSHDR4",130,0)
 D HD
"RTN","HLCSHDR4",131,0)
 ;
"RTN","HLCSHDR4",132,0)
 W !
"RTN","HLCSHDR4",133,0)
 ;
"RTN","HLCSHDR4",134,0)
 S L="",DIC="^ORD(101,",BY="[HL PROTOCOL MESSAGING FIELDS]"
"RTN","HLCSHDR4",135,0)
 S DIOEND="D EXPL^HLCSHDR4"
"RTN","HLCSHDR4",136,0)
 D EN1^DIP
"RTN","HLCSHDR4",137,0)
 ;
"RTN","HLCSHDR4",138,0)
 Q
"RTN","HLCSHDR4",139,0)
 ;
"RTN","HLCSHDR4",140,0)
HD W @IOF,$$CJ^XLFSTR("HL7 Protocol Messaging Fields",IOM)
"RTN","HLCSHDR4",141,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLCSHDR4",142,0)
 W !,"This 'HL7 Protocol Messaging Fields' report holds information that will help"
"RTN","HLCSHDR4",143,0)
 W !,"you determine the effects from changes to routing-related fields in the MSH"
"RTN","HLCSHDR4",144,0)
 W !,"segment when messages are sent between or within VistA HL7 systems."
"RTN","HLCSHDR4",145,0)
 W !,"Additional explanation is included at the bottom of the report."
"RTN","HLCSHDR4",146,0)
 Q
"RTN","HLCSHDR4",147,0)
 ;
"RTN","HLCSHDR4",148,0)
EXPL N I,T QUIT:'$$EXPL1("Press RETURN for 'printout help', or '^' to exit... ")  X "F I=1:1 S T=$T(EXPL+I) QUIT:T'["";;""  W !,$P(T,"";;"",2,99)" S I=$$EXPL1("Press RETURN to exit... ",1)
"RTN","HLCSHDR4",149,0)
 ;;
"RTN","HLCSHDR4",150,0)
 ;;When messages are received, their SENDING APPLICATION (MSH-3), MESSAGE
"RTN","HLCSHDR4",151,0)
 ;;TYPE (MSH-9), EVENT TYPE (MSH-9), and HL7 VERSION (MSH-12) fields are used to
"RTN","HLCSHDR4",152,0)
 ;;find the event driver protocol to be used in processing the just-received
"RTN","HLCSHDR4",153,0)
 ;;message. After the event protocol is found, that protocol's subscriber
"RTN","HLCSHDR4",154,0)
 ;;protocols are evaluated.  The subscriber protocol with a RECEIVING 
"RTN","HLCSHDR4",155,0)
 ;;APPLICATION value that matches the RECEIVING APPLICATION field in the MSH
"RTN","HLCSHDR4",156,0)
 ;;segment (MSH-5) is used.
"RTN","HLCSHDR4",157,0)
 ;;
"RTN","HLCSHDR4",158,0)
 ;;The first line for every "section" in the printout is the event driver
"RTN","HLCSHDR4",159,0)
 ;;protocol. Lines preceded by dashes, are related subscriber protocols.  An
"RTN","HLCSHDR4",160,0)
 ;;example is shown below.
"RTN","HLCSHDR4",161,0)
 ;;
"RTN","HLCSHDR4",162,0)
 ;;Snd/Rec App's    mTYP   eTYP   Ver        Protocol                     Link
"RTN","HLCSHDR4",163,0)
 ;;------------------------------------------------------------------------------
"RTN","HLCSHDR4",164,0)
 ;;AC-VOICERAD      ORU    R01    2.3    |   AC ORU SERVER
"RTN","HLCSHDR4",165,0)
 ;;-AC-RADIOLOGY    ORU    R01    2.3    |   AC ORU CLIENT                NC  TCP
"RTN","HLCSHDR4",166,0)
 ;;
"RTN","HLCSHDR4",167,0)
 ;;In this example, the 'AC-VOICERAD' line holds information for the 'AC ORU
"RTN","HLCSHDR4",168,0)
 ;;SERVER' event protocol.  And, the '-AC-RADIOLOGY' line holds information for
"RTN","HLCSHDR4",169,0)
 ;;the 'AC ORU CLIENT' subscriber protocol.
"RTN","HLCSHDR4",170,0)
 Q
"RTN","HLCSHDR4",171,0)
 ;
"RTN","HLCSHDR4",172,0)
EXPL1(PMT,FF) ;
"RTN","HLCSHDR4",173,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLCSHDR4",174,0)
 QUIT:$E($G(IOST),1,2)'="C-" 1 ;->
"RTN","HLCSHDR4",175,0)
 F X=1:1:$G(FF) W !
"RTN","HLCSHDR4",176,0)
 S DIR(0)="EA",DIR("A")=PMT
"RTN","HLCSHDR4",177,0)
 D ^DIR
"RTN","HLCSHDR4",178,0)
 QUIT $S(Y=1:1,1:"")
"RTN","HLCSHDR4",179,0)
 ;
"RTN","HLCSHDR4",180,0)
M ; Covered by Integration Agreement #3988
"RTN","HLCSHDR4",181,0)
 ; Application developers may call here when creating new messages,
"RTN","HLCSHDR4",182,0)
 ; when experimenting with M code to evaluate and conditionally change
"RTN","HLCSHDR4",183,0)
 ; routing-related fields. 
"RTN","HLCSHDR4",184,0)
 ;
"RTN","HLCSHDR4",185,0)
 ; This API is called immediately before the MSH segment is created.
"RTN","HLCSHDR4",186,0)
 N IOINHI,IOINORM,MSHOLD,MSHNEW,MSHPRE,X
"RTN","HLCSHDR4",187,0)
 ;
"RTN","HLCSHDR4",188,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLCSHDR4",189,0)
 ;
"RTN","HLCSHDR4",190,0)
 S MSHOLD=$$MSHBUILD(0),MSHPRE=$$MSHBUILD(1)
"RTN","HLCSHDR4",191,0)
 W !!,"The original MSH segment is...",!!,IOINHI,MSHOLD,IOINORM
"RTN","HLCSHDR4",192,0)
 I MSHPRE'=MSHOLD D
"RTN","HLCSHDR4",193,0)
 .  W !!,"The MSH segment, after modification by passed-in data, is..."
"RTN","HLCSHDR4",194,0)
 .  W !!,IOINHI,MSHPRE,IOINORM
"RTN","HLCSHDR4",195,0)
 ;
"RTN","HLCSHDR4",196,0)
 D MVAR("SENDING APPLICATION","HLMSHSAN","SERAPP")
"RTN","HLCSHDR4",197,0)
 D MVAR("SENDING FACILITY","HLMSHSFN","SERFAC")
"RTN","HLCSHDR4",198,0)
 D MVAR("RECEIVING APPLICATION","HLMSHRAN","CLNTAPP")
"RTN","HLCSHDR4",199,0)
 D MVAR("RECEIVING FACILITY","HLMSHRFN","CLNTFAC")
"RTN","HLCSHDR4",200,0)
 ;
"RTN","HLCSHDR4",201,0)
 S MSHNEW=$$MSHBUILD
"RTN","HLCSHDR4",202,0)
 I MSHNEW'=MSHPRE D
"RTN","HLCSHDR4",203,0)
 .  W !!,"Before your changes above, the modified MSH segment was..."
"RTN","HLCSHDR4",204,0)
 .  W !!,IOINHI,MSHPRE,IOINORM
"RTN","HLCSHDR4",205,0)
 .  W !!,"After your changes, the MSH segment is..."
"RTN","HLCSHDR4",206,0)
 .  W !!,IOINHI,MSHNEW,IOINORM
"RTN","HLCSHDR4",207,0)
 W !!,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLCSHDR4",208,0)
 W !!,"Message being sent..."
"RTN","HLCSHDR4",209,0)
 W !
"RTN","HLCSHDR4",210,0)
 ;
"RTN","HLCSHDR4",211,0)
 Q
"RTN","HLCSHDR4",212,0)
 ;
"RTN","HLCSHDR4",213,0)
MVAR(FLD,VAR,VARO) ; Generic resetting of variable...
"RTN","HLCSHDR4",214,0)
 ;IOINHI,IOINORM -- req
"RTN","HLCSHDR4",215,0)
 N ANS
"RTN","HLCSHDR4",216,0)
 W !!,?4,"Protocol-derived value of ",FLD,": "
"RTN","HLCSHDR4",217,0)
 W IOINHI,@VARO,IOINORM
"RTN","HLCSHDR4",218,0)
 W !,"Passed-in value of ",FLD," (",VAR,"): "
"RTN","HLCSHDR4",219,0)
 W IOINHI,@VAR,IOINORM
"RTN","HLCSHDR4",220,0)
 W !,?10,"Enter new value for ",FLD,": "
"RTN","HLCSHDR4",221,0)
 R ANS:60 Q:'$T  ;->
"RTN","HLCSHDR4",222,0)
 I ANS[U!(ANS']"") D
"RTN","HLCSHDR4",223,0)
 .  W !!,?10,"No changes will be made..."
"RTN","HLCSHDR4",224,0)
 I ANS'[U&(ANS]"") D
"RTN","HLCSHDR4",225,0)
 .  S @VAR=ANS
"RTN","HLCSHDR4",226,0)
 .  W !!,?10,"The variable ",IOINHI,VAR,IOINORM
"RTN","HLCSHDR4",227,0)
 .  W " will be changed to '",IOINHI,ANS,IOINORM,"'."
"RTN","HLCSHDR4",228,0)
 .  W !,?10,"This value will be stored in the ",FLD
"RTN","HLCSHDR4",229,0)
 .  W !,?10,"field in the MSH segment..."
"RTN","HLCSHDR4",230,0)
 .  W !!,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLCSHDR4",231,0)
 Q
"RTN","HLCSHDR4",232,0)
 ;
"RTN","HLCSHDR4",233,0)
MSHBUILD(TYPE) ; Build MSH using current variables...
"RTN","HLCSHDR4",234,0)
 N MSH,PCE,RAN,RFN,SAN,SFN
"RTN","HLCSHDR4",235,0)
 S MSH="MSH"_FS_EC
"RTN","HLCSHDR4",236,0)
 I $G(TYPE)=0 F PCE=SERAPP,SERFAC,CLNTAPP,CLNTFAC,HLDATE,SECURITY,MSGTYPE,HLID,HLPID,$P(PROT,U,9),"",$G(^HL(772,TXTP,1)),ACCACK,APPACK,CNTRY D
"RTN","HLCSHDR4",237,0)
 .  S MSH=MSH_FS_PCE
"RTN","HLCSHDR4",238,0)
 I $G(TYPE)'=0 D
"RTN","HLCSHDR4",239,0)
 .  S SAN=HLMSHSAN,SAN=$S(SAN]"":SAN,1:SERAPP)
"RTN","HLCSHDR4",240,0)
 .  S SFN=HLMSHSFN,SFN=$S(SFN]"":SFN,1:SERFAC)
"RTN","HLCSHDR4",241,0)
 .  S RAN=HLMSHRAN,RAN=$S(RAN]"":RAN,1:CLNTAPP)
"RTN","HLCSHDR4",242,0)
 .  S RFN=HLMSHRFN,RFN=$S(RFN]"":RFN,1:CLNTFAC)
"RTN","HLCSHDR4",243,0)
 .  F PCE=SAN,SFN,RAN,RFN,HLDATE,SECURITY,MSGTYPE,HLID,HLPID,$P(PROT,U,9),"",$G(^HL(772,TXTP,1)),ACCACK,APPACK,CNTRY D
"RTN","HLCSHDR4",244,0)
 .  .  S MSH=MSH_FS_PCE
"RTN","HLCSHDR4",245,0)
 QUIT MSH
"RTN","HLCSHDR4",246,0)
 ;
"RTN","HLCSHDR4",247,0)
EOR ;HLCSHDR4 - Reset MSH Segment Fields ;9/12/02 11:50
"RTN","HLCSHDR5")
0^4^B40317270
"RTN","HLCSHDR5",1,0)
HLCSHDR5 ;OIRMFO/LJA - Make HL7 header for TCP ;1/27/03 15:30
"RTN","HLCSHDR5",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**93**;Oct 13, 1995
"RTN","HLCSHDR5",3,0)
 ;
"RTN","HLCSHDR5",4,0)
 ; The MSHALL API is not supported!
"RTN","HLCSHDR5",5,0)
 ;
"RTN","HLCSHDR5",6,0)
MSHALL ; Allows application developer, in test and development environments,
"RTN","HLCSHDR5",7,0)
 ; to change almost every field in the MSH segment.  This feature 
"RTN","HLCSHDR5",8,0)
 ; allows the testing of the ramifications of MSH field changes, avoiding
"RTN","HLCSHDR5",9,0)
 ; the need to edit protocol file (and other file) entries from which
"RTN","HLCSHDR5",10,0)
 ; the MSH segment fields are derived.
"RTN","HLCSHDR5",11,0)
 ;
"RTN","HLCSHDR5",12,0)
 ; Call here ONLY if the full suite of variables used in MSH segment
"RTN","HLCSHDR5",13,0)
 ; creation are available!
"RTN","HLCSHDR5",14,0)
 ;
"RTN","HLCSHDR5",15,0)
 ; Call method:   S HLP("SUBSCRIBER"[,n])="^^^^^MSHALL^HLCSHDR5"
"RTN","HLCSHDR5",16,0)
 ;                D GENERATE^HLMA(.....,.HLP)
"RTN","HLCSHDR5",17,0)
 ;
"RTN","HLCSHDR5",18,0)
 ;                When the above HLP array is passed into the
"RTN","HLCSHDR5",19,0)
 ;                GENERATE^HLMA API, the MSHALL subroutine is
"RTN","HLCSHDR5",20,0)
 ;                invoked, giving the developer full control over
"RTN","HLCSHDR5",21,0)
 ;                most MSH segment fields; even those fields not
"RTN","HLCSHDR5",22,0)
 ;                changeable by HL*1.6*93.
"RTN","HLCSHDR5",23,0)
 ;
"RTN","HLCSHDR5",24,0)
 ;                See HL*1.6*93 for information about the passing
"RTN","HLCSHDR5",25,0)
 ;                of HLP("SUBSCRIBER"[,n]) information, and the
"RTN","HLCSHDR5",26,0)
 ;                calling of the GENERATE^HLMA API.
"RTN","HLCSHDR5",27,0)
 ;
"RTN","HLCSHDR5",28,0)
 ; Warning!       No audit trail (in ^HLMA or ^XTMP) is maintained.
"RTN","HLCSHDR5",29,0)
 ;                Full responsibility rests with the application
"RTN","HLCSHDR5",30,0)
 ;                developer.
"RTN","HLCSHDR5",31,0)
 ;                
"RTN","HLCSHDR5",32,0)
 ; EC,FS -- req
"RTN","HLCSHDR5",33,0)
 ;
"RTN","HLCSHDR5",34,0)
 N ACTION,CHANGE,IOINHI,IOINORM,MSHFINAL,MSHLAST,MSHORIG
"RTN","HLCSHDR5",35,0)
 N SAVE,PCE,VAL1,VAL2,X
"RTN","HLCSHDR5",36,0)
 ;
"RTN","HLCSHDR5",37,0)
 D SAVEORIG
"RTN","HLCSHDR5",38,0)
 S (MSHFINAL,MSHLAST)=MSHORIG
"RTN","HLCSHDR5",39,0)
 ;
"RTN","HLCSHDR5",40,0)
MSHCONT ;
"RTN","HLCSHDR5",41,0)
 F  D  Q:'CHANGE
"RTN","HLCSHDR5",42,0)
 .  S CHANGE=0
"RTN","HLCSHDR5",43,0)
 .  D SHOWMSH
"RTN","HLCSHDR5",44,0)
 .  D ASKMSH
"RTN","HLCSHDR5",45,0)
 .  S MSHFINAL=$$MSH
"RTN","HLCSHDR5",46,0)
 .  QUIT:MSHFINAL=MSHLAST  ;->
"RTN","HLCSHDR5",47,0)
 .  S CHANGE=1
"RTN","HLCSHDR5",48,0)
 .  S MSHLAST=$$MSH
"RTN","HLCSHDR5",49,0)
 ;
"RTN","HLCSHDR5",50,0)
 I MSHFINAL=MSHORIG W !!,"The MSH segment was not changed..."
"RTN","HLCSHDR5",51,0)
 I MSHFINAL'=MSHORIG D
"RTN","HLCSHDR5",52,0)
 .  S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLCSHDR5",53,0)
 .  W !!,MSHORIG,!!,"   changed to...",!!
"RTN","HLCSHDR5",54,0)
 .  F PCE=1:1:$L(MSHFINAL,FS) D
"RTN","HLCSHDR5",55,0)
 .  .  W:PCE'=1 FS
"RTN","HLCSHDR5",56,0)
 .  .  S VAL1=$P(MSHORIG,FS,PCE),VAL2=$P(MSHFINAL,FS,PCE)
"RTN","HLCSHDR5",57,0)
 .  .  W:VAL1'=VAL2 IOINHI
"RTN","HLCSHDR5",58,0)
 .  .  W VAL2
"RTN","HLCSHDR5",59,0)
 .  .  W IOINORM
"RTN","HLCSHDR5",60,0)
 ;
"RTN","HLCSHDR5",61,0)
 S ACTION=$$DOWHAT
"RTN","HLCSHDR5",62,0)
 I ACTION="B" D  G MSHCONT ;->
"RTN","HLCSHDR5",63,0)
 .  QUIT:MSHFINAL=MSHORIG  ;->
"RTN","HLCSHDR5",64,0)
 .  W !!,"You have made some changes to the original MSH segment.  Do you want to"
"RTN","HLCSHDR5",65,0)
 .  W !,"""forget"" these changes, and reset the MSH segment to it's original state?"
"RTN","HLCSHDR5",66,0)
 .  QUIT:'$$YN("Reset MSH segment","No",1)  ;->
"RTN","HLCSHDR5",67,0)
 .  D RESTORE
"RTN","HLCSHDR5",68,0)
 .  S (MSHFINAL,MSHLAST)=MSHORIG
"RTN","HLCSHDR5",69,0)
 ;
"RTN","HLCSHDR5",70,0)
 Q
"RTN","HLCSHDR5",71,0)
 ;
"RTN","HLCSHDR5",72,0)
YN(PMT,DEF,FF) ;
"RTN","HLCSHDR5",73,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLCSHDR5",74,0)
 F I=1:1:$G(FF) W !
"RTN","HLCSHDR5",75,0)
 S DIR(0)="Y",DIR("A")=PMT
"RTN","HLCSHDR5",76,0)
 S:$G(DEF)]"" DIR("B")=DEF
"RTN","HLCSHDR5",77,0)
 D ^DIR
"RTN","HLCSHDR5",78,0)
 Q $S(+Y=1:1,1:"")
"RTN","HLCSHDR5",79,0)
 ;
"RTN","HLCSHDR5",80,0)
DOWHAT() ; Reenter MSH or send message...
"RTN","HLCSHDR5",81,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLCSHDR5",82,0)
 S DIR(0)="S^B:Back up and change MSH segment;C:Continue on (and send message)"
"RTN","HLCSHDR5",83,0)
 S DIR("A")="Enter ACTION",DIR("B")="Continue"
"RTN","HLCSHDR5",84,0)
 D ^DIR
"RTN","HLCSHDR5",85,0)
 QUIT $S(Y="B":"B",1:"C")
"RTN","HLCSHDR5",86,0)
 ;
"RTN","HLCSHDR5",87,0)
SHOWMSH ;
"RTN","HLCSHDR5",88,0)
 ; MSHORIG -- req
"RTN","HLCSHDR5",89,0)
 N C2,C3,C4,DATA,IOINHI,IOINORM,MSH,PCE,REF,TAG,VAL,X,XEC
"RTN","HLCSHDR5",90,0)
 ;
"RTN","HLCSHDR5",91,0)
 S X=MSHORIG N MSHORIG S MSHORIG=X
"RTN","HLCSHDR5",92,0)
 S C2=4,C3=18,C4=40
"RTN","HLCSHDR5",93,0)
 I $G(FS)']""!($G(EC)']"") N EC,FS S FS=U,EC="~|\&"
"RTN","HLCSHDR5",94,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLCSHDR5",95,0)
 ;
"RTN","HLCSHDR5",96,0)
 W @IOF,!,$$CJ^XLFSTR("MSH Segment Values",IOM)
"RTN","HLCSHDR5",97,0)
 W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLCSHDR5",98,0)
 W !,"#",?C2,"Field",?C3,"Variable",?C4,"Value"
"RTN","HLCSHDR5",99,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLCSHDR5",100,0)
 ;
"RTN","HLCSHDR5",101,0)
 F PCE=1:1 S DATA=$T(FLDS+PCE) Q:$E(DATA,1,3)'=" ;;"!(DATA']"")  S DATA=$P(DATA,";;",2,99) D
"RTN","HLCSHDR5",102,0)
 .  S REF=$P(DATA,U),XEC=$P(DATA,U,2),TAG=$P(DATA,U,3)
"RTN","HLCSHDR5",103,0)
 .  S VAL=REF
"RTN","HLCSHDR5",104,0)
 .  I PCE=11 S REF=$TR(REF,"~",U)
"RTN","HLCSHDR5",105,0)
 .  I XEC=1,PCE'=12 S VAL=@REF
"RTN","HLCSHDR5",106,0)
 .  I XEC=2!(PCE=12) S X="S VAL="_REF X X KILL X
"RTN","HLCSHDR5",107,0)
 .  W !,$J(PCE,2),?C2,$$S(TAG,12),?C3,$$S(REF,18)
"RTN","HLCSHDR5",108,0)
 .  W ?C4
"RTN","HLCSHDR5",109,0)
 .  I XEC=1 W IOINHI
"RTN","HLCSHDR5",110,0)
 .  W VAL,IOINORM
"RTN","HLCSHDR5",111,0)
 .  W $S(XEC=1:$$CHG(VAL,PCE),1:"")
"RTN","HLCSHDR5",112,0)
 ;
"RTN","HLCSHDR5",113,0)
 Q
"RTN","HLCSHDR5",114,0)
 ;
"RTN","HLCSHDR5",115,0)
S(T,C) QUIT:$L(T)<(C+1) T ;->
"RTN","HLCSHDR5",116,0)
 QUIT $E(T,1,C-1)_"~"
"RTN","HLCSHDR5",117,0)
 ;
"RTN","HLCSHDR5",118,0)
CHG(VAL,PCE) ; Has data been changed?
"RTN","HLCSHDR5",119,0)
 ; MSHORIG -- req
"RTN","HLCSHDR5",120,0)
 N VALORIG
"RTN","HLCSHDR5",121,0)
 S VALORIG=$P(MSHORIG,FS,+PCE)
"RTN","HLCSHDR5",122,0)
 QUIT:VALORIG=VAL "" ;->
"RTN","HLCSHDR5",123,0)
 Q " *"
"RTN","HLCSHDR5",124,0)
 ;
"RTN","HLCSHDR5",125,0)
ASKMSH ; Ask user to input different field values
"RTN","HLCSHDR5",126,0)
 N DATA,DIR,DIRUT,DTOUT,DUOUT,FIELD,PCE,TITLE,VAL,VAR,X,Y
"RTN","HLCSHDR5",127,0)
 ;
"RTN","HLCSHDR5",128,0)
 W !
"RTN","HLCSHDR5",129,0)
 ;
"RTN","HLCSHDR5",130,0)
 S DIR="SOA^"
"RTN","HLCSHDR5",131,0)
 F PCE=3:1:12,15:1:17 D
"RTN","HLCSHDR5",132,0)
 .  S DATA=$P($T(FLDS+PCE),";;",2,999),VAR=$P(DATA,U),TITLE=$P(DATA,U,3)
"RTN","HLCSHDR5",133,0)
 .  S DIR=DIR_$S(PCE>3:";",1:"")_PCE_":"_TITLE_" ("_VAR_")"
"RTN","HLCSHDR5",134,0)
 S DIR(0)=DIR
"RTN","HLCSHDR5",135,0)
 S DIR("A")="Enter FIELD #: "
"RTN","HLCSHDR5",136,0)
 D ^DIR
"RTN","HLCSHDR5",137,0)
 QUIT:+Y'>0  ;->
"RTN","HLCSHDR5",138,0)
 ;
"RTN","HLCSHDR5",139,0)
 S FIELD=+Y,VAR=$P($P($T(FLDS+FIELD),";;",2,99),U)
"RTN","HLCSHDR5",140,0)
 I FIELD'=12 S VAL=@VAR
"RTN","HLCSHDR5",141,0)
 I FIELD=12 S X="S VAL="_VAR X X KILL X
"RTN","HLCSHDR5",142,0)
 ;
"RTN","HLCSHDR5",143,0)
 W !!,"Current '",VAR,"' value = ",VAL
"RTN","HLCSHDR5",144,0)
 W !
"RTN","HLCSHDR5",145,0)
 ;
"RTN","HLCSHDR5",146,0)
 KILL DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLCSHDR5",147,0)
 S DIR(0)="F",DIR("A")="Field value"
"RTN","HLCSHDR5",148,0)
 D ^DIR
"RTN","HLCSHDR5",149,0)
 QUIT:$D(DIRUT)!($D(DTOUT))!($D(DUOUT))  ;->
"RTN","HLCSHDR5",150,0)
 ;
"RTN","HLCSHDR5",151,0)
 S ANS=Y
"RTN","HLCSHDR5",152,0)
 ;
"RTN","HLCSHDR5",153,0)
 I ANS=VAL W "  nothing changed..." QUIT  ;->
"RTN","HLCSHDR5",154,0)
 ;
"RTN","HLCSHDR5",155,0)
 ; Make the change...
"RTN","HLCSHDR5",156,0)
 I FIELD'=12 S @VAR=ANS
"RTN","HLCSHDR5",157,0)
 I FIELD=12 S $P(PROT,U,9)=ANS
"RTN","HLCSHDR5",158,0)
 W "   changed..."
"RTN","HLCSHDR5",159,0)
 ;
"RTN","HLCSHDR5",160,0)
 Q
"RTN","HLCSHDR5",161,0)
 ;
"RTN","HLCSHDR5",162,0)
MSH() ;Build MSH array
"RTN","HLCSHDR5",163,0)
 N DATA,MSH,PCE,REF,TAG,XEC
"RTN","HLCSHDR5",164,0)
 ;
"RTN","HLCSHDR5",165,0)
 S MSH=""
"RTN","HLCSHDR5",166,0)
 ;
"RTN","HLCSHDR5",167,0)
 F PCE=1:1 S DATA=$T(FLDS+PCE) Q:$E(DATA,1,3)'=" ;;"!(DATA']"")  S DATA=$P(DATA,";;",2,99) D
"RTN","HLCSHDR5",168,0)
 .  S REF=$P(DATA,U),XEC=$P(DATA,U,2)
"RTN","HLCSHDR5",169,0)
 .  I PCE=11 S REF=$TR(REF,"~",U)
"RTN","HLCSHDR5",170,0)
 .  I XEC=0 S VAL=REF
"RTN","HLCSHDR5",171,0)
 .  I XEC=1,PCE'=12 S VAL=@REF
"RTN","HLCSHDR5",172,0)
 .  I XEC=2!(PCE=12) S X="S VAL="_REF X X KILL X
"RTN","HLCSHDR5",173,0)
 .  S MSH=MSH_$S(MSH]"":FS,1:"")_VAL
"RTN","HLCSHDR5",174,0)
 ;
"RTN","HLCSHDR5",175,0)
 Q MSH
"RTN","HLCSHDR5",176,0)
 ;
"RTN","HLCSHDR5",177,0)
SAVEORIG ; Save value of original variables...
"RTN","HLCSHDR5",178,0)
 KILL SAVE
"RTN","HLCSHDR5",179,0)
 ;
"RTN","HLCSHDR5",180,0)
 S SAVE("SERAPP")=SERAPP,SAVE("SERFAC")=SERFAC
"RTN","HLCSHDR5",181,0)
 S SAVE("CLNTAPP")=CLNTAPP,SAVE("CLNTFAC")=CLNTFAC
"RTN","HLCSHDR5",182,0)
 S SAVE("HLDATE")=HLDATE,SAVE("SECURITY")=SECURITY
"RTN","HLCSHDR5",183,0)
 S SAVE("MSGTYPE")=MSGTYPE,SAVE("HLID")=HLID
"RTN","HLCSHDR5",184,0)
 S SAVE("HLPID")=HLPID,SAVE("ACCACK")=ACCACK
"RTN","HLCSHDR5",185,0)
 S SAVE("APPACK")=APPACK,SAVE("CNTRY")=CNTRY
"RTN","HLCSHDR5",186,0)
 S SAVE("$P(PROT,U,9)")=$P(PROT,U,9)
"RTN","HLCSHDR5",187,0)
 ;
"RTN","HLCSHDR5",188,0)
 S MSHORIG=$$MSH
"RTN","HLCSHDR5",189,0)
 ;
"RTN","HLCSHDR5",190,0)
 Q
"RTN","HLCSHDR5",191,0)
 ;
"RTN","HLCSHDR5",192,0)
RESTORE ;
"RTN","HLCSHDR5",193,0)
 N VAL,VAR
"RTN","HLCSHDR5",194,0)
 ;
"RTN","HLCSHDR5",195,0)
 ; restore variables...
"RTN","HLCSHDR5",196,0)
 S VAR=""
"RTN","HLCSHDR5",197,0)
 F  S VAR=$O(SAVE(VAR)) Q:VAR']""  D
"RTN","HLCSHDR5",198,0)
 .  QUIT:VAR["$P(PROT,U,9)"  ;->
"RTN","HLCSHDR5",199,0)
 .  S @VAR=SAVE(VAR)
"RTN","HLCSHDR5",200,0)
 S $P(PROT,U,9)=SAVE("$P(PROT,U,9)")
"RTN","HLCSHDR5",201,0)
 ;
"RTN","HLCSHDR5",202,0)
 ; Restore beginning MSH...
"RTN","HLCSHDR5",203,0)
 S (MSHFINAL,MSHLAST)=MSHORIG
"RTN","HLCSHDR5",204,0)
 ;
"RTN","HLCSHDR5",205,0)
 Q
"RTN","HLCSHDR5",206,0)
 ;
"RTN","HLCSHDR5",207,0)
FLDS ; List of fields and their variables in MSH segment...
"RTN","HLCSHDR5",208,0)
 ;;MSH^0
"RTN","HLCSHDR5",209,0)
 ;;EC^2
"RTN","HLCSHDR5",210,0)
 ;;SERAPP^1^SND-APP
"RTN","HLCSHDR5",211,0)
 ;;SERFAC^1^SND-FAC
"RTN","HLCSHDR5",212,0)
 ;;CLNTAPP^1^REC-APP
"RTN","HLCSHDR5",213,0)
 ;;CLNTFAC^1^REC-FAC
"RTN","HLCSHDR5",214,0)
 ;;HLDATE^1^D/T
"RTN","HLCSHDR5",215,0)
 ;;SECURITY^1^SECURE
"RTN","HLCSHDR5",216,0)
 ;;MSGTYPE^1^MSGTYPE
"RTN","HLCSHDR5",217,0)
 ;;HLID^1^MSG-ID
"RTN","HLCSHDR5",218,0)
 ;;HLPID^1^PID
"RTN","HLCSHDR5",219,0)
 ;;$P(PROT,U,9)^1^VERSION
"RTN","HLCSHDR5",220,0)
 ;;^0
"RTN","HLCSHDR5",221,0)
 ;;^0^CONTINUATION
"RTN","HLCSHDR5",222,0)
 ;;ACCACK^1^COMACK
"RTN","HLCSHDR5",223,0)
 ;;APPACK^1^APPACK
"RTN","HLCSHDR5",224,0)
 ;;CNTRY^1^COUNTRY
"RTN","HLCSHDR5",225,0)
 Q
"RTN","HLCSHDR5",226,0)
 ;
"RTN","HLCSHDR5",227,0)
PRACTICE ; Practice MSH variables...
"RTN","HLCSHDR5",228,0)
 S EC="~|\&",FS=U
"RTN","HLCSHDR5",229,0)
 S SERAPP="SND-APP",SERFAC=512,CLNTAPP="REC-APP",CLNTFAC=661
"RTN","HLCSHDR5",230,0)
 S HLDATE=200301020135,SECURITY="SEC",MSGTYPE="ORU~R01"
"RTN","HLCSHDR5",231,0)
 S HLID="543010101",HLPID="P"
"RTN","HLCSHDR5",232,0)
 S $P(PROT,U,9)="2.3",TXTP=999
"RTN","HLCSHDR5",233,0)
 S ACCACK="AL",APPACK="AL",CNTRY="US"
"RTN","HLCSHDR5",234,0)
 Q
"RTN","HLCSHDR5",235,0)
 ;
"RTN","HLCSHDR5",236,0)
 ;
"RTN","HLCSHDR5",237,0)
EOR ;HLCSHDR5 - Make HL7 header for TCP ;1/27/03 15:30
"RTN","HLCSHDR6")
0^5^B11316553
"RTN","HLCSHDR6",1,0)
HLCSHDR6 ;OIRMFO/LJA - Make HL7 header for TCP ;1/27/03 15:30
"RTN","HLCSHDR6",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**93**;Oct 13, 1995
"RTN","HLCSHDR6",3,0)
 ;
"RTN","HLCSHDR6",4,0)
MARKERRA ; Mark 772 & 773 entries in error (to stop messaging)...
"RTN","HLCSHDR6",5,0)
 N %ZHO,ERR,ERREA,HLD,HLTCP,IEN772,IEN773,MSH,N02,POSX,X
"RTN","HLCSHDR6",6,0)
 D HDERR
"RTN","HLCSHDR6",7,0)
 R !!,"Enter ERROR REASON: ",ERREA:999 Q:'$T!(ERREA']"")!(ERREA[U)  ;->
"RTN","HLCSHDR6",8,0)
 F  D  Q:'IEN772  W !!,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLCSHDR6",9,0)
 .  R !!," 772:  ",IEN772:9999 Q:IEN772'>0!('$T)  ;->
"RTN","HLCSHDR6",10,0)
 .  S N02=$G(^HL(772,+IEN772,0))
"RTN","HLCSHDR6",11,0)
 .  W !!,"772-0: "
"RTN","HLCSHDR6",12,0)
 .  S POSX=$X
"RTN","HLCSHDR6",13,0)
 .  W $E(N02,1,IOM-POSX)
"RTN","HLCSHDR6",14,0)
 .  S X=$G(^HL(772,+IEN772,"P")) I X]"" W !,?(POSX-3),"P: ",$E(X,1,IOM-POSX)
"RTN","HLCSHDR6",15,0)
 .  KILL HLD
"RTN","HLCSHDR6",16,0)
 .  W:$D(^HLMA("B",+IEN772)) !!,"773s:",?POSX
"RTN","HLCSHDR6",17,0)
 .  S IEN773=0
"RTN","HLCSHDR6",18,0)
 .  F  S IEN773=$O(^HLMA("B",+IEN772,IEN773)) Q:IEN773'>0  D
"RTN","HLCSHDR6",19,0)
 .  .  W:$X>POSX ! W:$X<POSX ?POSX
"RTN","HLCSHDR6",20,0)
 .  .  S HLD(IEN773)=""
"RTN","HLCSHDR6",21,0)
 .  .  S X=$G(^HLMA(+IEN773,"P")) I X]"" W "  P: ",$E(X,1,IOM-$X)
"RTN","HLCSHDR6",22,0)
 .  .  W:$X>POSX ! W:$X<POSX ?POSX
"RTN","HLCSHDR6",23,0)
 .  .  W "MSH: "
"RTN","HLCSHDR6",24,0)
 .  .  S POSX=$X
"RTN","HLCSHDR6",25,0)
 .  .  S MSH=$G(^HLMA(+IEN773,"MSH",1,0))
"RTN","HLCSHDR6",26,0)
 .  .  F  D  Q:MSH']""
"RTN","HLCSHDR6",27,0)
 .  .  .  W:$X>POSX ! W:$X<POSX ?POSX
"RTN","HLCSHDR6",28,0)
 .  .  .  W $E(MSH,1,IOM-POSX)
"RTN","HLCSHDR6",29,0)
 .  .  .  S MSH=$E(MSH,IOM-POSX+1,999)
"RTN","HLCSHDR6",30,0)
 .  R !!,"Press RETURN to mark errored, or enter '^' to abort... ",X:999 I '$T!(X]"") D  QUIT  ;->
"RTN","HLCSHDR6",31,0)
 .  .  W "  no action taken..."
"RTN","HLCSHDR6",32,0)
 .  W !!,?10,"Marking 772's #",IEN772," errored... "
"RTN","HLCSHDR6",33,0)
 .  S ERR=$$ERR(772,IEN772,ERREA)
"RTN","HLCSHDR6",34,0)
 .  W $S(ERR:"  done...",1:"Aborted!! "_$P(ERR,U,2)_"...")
"RTN","HLCSHDR6",35,0)
 .  I '$D(HLD) QUIT  ;->
"RTN","HLCSHDR6",36,0)
 .  S IEN773=0
"RTN","HLCSHDR6",37,0)
 .  F  S IEN773=$O(HLD(IEN773)) Q:IEN773'>0  D
"RTN","HLCSHDR6",38,0)
 .  .  W !,?10,"Marking 773's #",IEN773," errored... "
"RTN","HLCSHDR6",39,0)
 .  .  S ERR=$$ERR(773,IEN773,ERREA)
"RTN","HLCSHDR6",40,0)
 .  .  W $S(ERR:"  done...",1:"Aborted!! "_$P(ERR,U,2)_"...")
"RTN","HLCSHDR6",41,0)
 ;
"RTN","HLCSHDR6",42,0)
 Q
"RTN","HLCSHDR6",43,0)
 ;
"RTN","HLCSHDR6",44,0)
MARKERRG ; Global-based error marking of 772, 773...
"RTN","HLCSHDR6",45,0)
 N %ZHO,ERR,ERREA,HLD,HLTCP,IEN772,IEN773,MSH,N02,POSX,X
"RTN","HLCSHDR6",46,0)
 D HDERR
"RTN","HLCSHDR6",47,0)
 R !!,"Enter ERROR REASON: ",ERREA:999 Q:'$T!(ERREA']"")!(ERREA[U)  ;->
"RTN","HLCSHDR6",48,0)
 I '$D(^TMP("HLCSHDR5 ERR",$J)) D  QUIT  ;->
"RTN","HLCSHDR6",49,0)
 .  W !!,"No ^TMP(""HLCSHDR5 ERR"",$J) data exists..."
"RTN","HLCSHDR6",50,0)
 .  W !
"RTN","HLCSHDR6",51,0)
 W !!,"The entries in ^TMP(""HLCSHDR5 ERR"",$J) will be marked in error now."
"RTN","HLCSHDR6",52,0)
 R !!,"Press RETURN to start error marking... ",X:999 Q:'$T!(X]"")  ;->
"RTN","HLCSHDR6",53,0)
 ;
"RTN","HLCSHDR6",54,0)
ERRQ S IEN772=0
"RTN","HLCSHDR6",55,0)
 F  S IEN772=$O(^TMP("HLCSHDR5 ERR",$J,IEN772)) Q:IEN772'>0  D
"RTN","HLCSHDR6",56,0)
 .  W !,"Marking 772's #",IEN772,"... "
"RTN","HLCSHDR6",57,0)
 .  S ERR=$$ERR(772,IEN772,ERREA)
"RTN","HLCSHDR6",58,0)
 .  W $S(ERR:"  done...",1:"Aborted!! "_$P(ERR,U,2)_"...")
"RTN","HLCSHDR6",59,0)
 .  S IEN773=0
"RTN","HLCSHDR6",60,0)
 .  F  S IEN773=$O(^HLMA("B",IEN772,IEN773)) Q:IEN773'>0  D
"RTN","HLCSHDR6",61,0)
 .  .  S ERR=$$ERR(773,IEN773,ERREA)
"RTN","HLCSHDR6",62,0)
 .  .  W !,"   - 773# ",IEN773," checked..."
"RTN","HLCSHDR6",63,0)
 Q
"RTN","HLCSHDR6",64,0)
 ;
"RTN","HLCSHDR6",65,0)
HDERR W @IOF,$$CJ^XLFSTR("Error Marking Utility",IOM)
"RTN","HLCSHDR6",66,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLCSHDR6",67,0)
 Q
"RTN","HLCSHDR6",68,0)
 ;
"RTN","HLCSHDR6",69,0)
ERR(FILE,IEN,ERREA) ; Change status to ERROR for 772 or 773 (if the P
"RTN","HLCSHDR6",70,0)
 ; node status exists.)
"RTN","HLCSHDR6",71,0)
 ;
"RTN","HLCSHDR6",72,0)
 N DATA,ERR,HLTCP
"RTN","HLCSHDR6",73,0)
 ;
"RTN","HLCSHDR6",74,0)
 I FILE=772 D  QUIT:ERR U_$P(ERR,U,2,99) ;->
"RTN","HLCSHDR6",75,0)
 .  S ERR=""
"RTN","HLCSHDR6",76,0)
 .  I $G(^HL(772,+$G(IEN),0))']"" S ERR="1^NO 772 0 NODE" QUIT  ;->
"RTN","HLCSHDR6",77,0)
 ;
"RTN","HLCSHDR6",78,0)
 I FILE=773 D  QUIT:ERR U_$P(ERR,U,2,99) ;->
"RTN","HLCSHDR6",79,0)
 .  S HLTCP=1 ; Used by STATUS^HLTF0
"RTN","HLCSHDR6",80,0)
 .  S ERR=""
"RTN","HLCSHDR6",81,0)
 .  I $G(^HLMA(+$G(IEN),0))']"" S ERR="1^NO 773 0 NODE" ;->
"RTN","HLCSHDR6",82,0)
 ;
"RTN","HLCSHDR6",83,0)
 QUIT:$G(ERREA)']"" "^NO REASON" ;->
"RTN","HLCSHDR6",84,0)
 ;
"RTN","HLCSHDR6",85,0)
 ; Does entry need to be marked in error.  (Only mark if status
"RTN","HLCSHDR6",86,0)
 ; already exists)
"RTN","HLCSHDR6",87,0)
 S DATA=$S(FILE=772:$G(^HL(772,+IEN,"P")),1:$G(^HLMA(+IEN,"P")))
"RTN","HLCSHDR6",88,0)
 QUIT:$P(DATA,U)']"" 1 ;->
"RTN","HLCSHDR6",89,0)
 ;
"RTN","HLCSHDR6",90,0)
 D STATUS^HLTF0(IEN,4,"",ERREA,1)
"RTN","HLCSHDR6",91,0)
 ;
"RTN","HLCSHDR6",92,0)
 Q 1
"RTN","HLCSHDR6",93,0)
 ;
"RTN","HLCSHDR6",94,0)
EOR ;HLCSHDR6 - Make HL7 header for TCP ;1/27/03 15:30
"VER")
8.0^22.0
"^DD",773,773,90.01,0)
HLP-SUBSCRIBER PROTOCOL^F^^90;1^K:$L(X)>45!($L(X)<1) X
"^DD",773,773,90.01,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-45 characters)
"^DD",773,773,90.01,21,0)
^^22^22^3021210^
"^DD",773,773,90.01,21,1,0)
This field holds the SUBSCRIBER PROTOCOL that was on the 1st piece of the
"^DD",773,773,90.01,21,2,0)
HLP("SUBSCRIBER"[,#]) subscriber entry.  (If the HLP("SUBSCRIBER") entry
"^DD",773,773,90.01,21,3,0)
was used to reset the MSH segment fields, this field will be null.)
"^DD",773,773,90.01,21,4,0)
 
"^DD",773,773,90.01,21,5,0)
 
"^DD",773,773,90.01,21,6,0)
Additional Comments on ^HLMA(ien,90) Node
"^DD",773,773,90.01,21,7,0)
-----------------------------------------
"^DD",773,773,90.01,21,8,0)
When the MSH segment fields are successfully reset using either 
"^DD",773,773,90.01,21,9,0)
HLP("SUBSCRIBER") or HLP("SUBSCRIBER",#), the entire HLP("SUBSCRIBER") or
"^DD",773,773,90.01,21,10,0)
HLP("SUBSCRIBER",#) array entry is stored on the ^HLMA(#,90) node.  There
"^DD",773,773,90.01,21,11,0)
are eight pieces in the HLP("SUBSCRIBER"[,#]) array, and there are eight
"^DD",773,773,90.01,21,12,0)
fields on the ^HLMA(ien,90) node.  The eight pieces of
"^DD",773,773,90.01,21,13,0)
HLP("SUBSCRIBER"[,#]) and the eight ^HLMA(ien,90) fields exactly
"^DD",773,773,90.01,21,14,0)
correspond to each other.
"^DD",773,773,90.01,21,15,0)
 
"^DD",773,773,90.01,21,16,0)
Note:  When ^HLMA(ien,90) is created, it is set equal to the entire
"^DD",773,773,90.01,21,17,0)
       value of the HLP("SUBSCRIBER"[,#]) array entry.  The fields on
"^DD",773,773,90.01,21,18,0)
       the ^HLMA(ien,90) node are not set separately!  (So, if the
"^DD",773,773,90.01,21,19,0)
       application developer creates an invalid HLP("SUBSCRIBER"[,#])
"^DD",773,773,90.01,21,20,0)
       array, with invalid data stored in one or more of the eight
"^DD",773,773,90.01,21,21,0)
       pieces, the ^HLMA(ien,90) node will similarly hold invalid
"^DD",773,773,90.01,21,22,0)
       data.)
"^DD",773,773,90.01,"DT")
3021022
"^DD",773,773,90.02,0)
HLP-SENDING APPLICATION^F^^90;2^K:$L(X)>45!($L(X)<1) X
"^DD",773,773,90.02,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-45 characters)
"^DD",773,773,90.02,21,0)
^.001^5^5^3021210^^
"^DD",773,773,90.02,21,1,0)
This field holds the SENDING APPLICATION that was on the 2nd piece of the 
"^DD",773,773,90.02,21,2,0)
HLP("SUBSCRIBER"[,#]) subscriber entry.  
"^DD",773,773,90.02,21,3,0)
 
"^DD",773,773,90.02,21,4,0)
(See the 'Additional Comments on ^HLMA(ien,90) Node' section in the 
"^DD",773,773,90.02,21,5,0)
description for field # 90.01.)
"^DD",773,773,90.02,"DT")
3021022
"^DD",773,773,90.03,0)
HLP-SENDING FACILITY^F^^90;3^K:$L(X)>30!($L(X)<1) X
"^DD",773,773,90.03,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-30 characters)
"^DD",773,773,90.03,21,0)
^^5^5^3021210^
"^DD",773,773,90.03,21,1,0)
This field holds the SENDING FACILITY that was on the 3rd piece of the
"^DD",773,773,90.03,21,2,0)
HLP("SUBSCRIBER"[,#]) subscriber entry.  
"^DD",773,773,90.03,21,3,0)
 
"^DD",773,773,90.03,21,4,0)
(See the 'Additional Comments on ^HLMA(ien,90) Node' section in the 
"^DD",773,773,90.03,21,5,0)
description for field # 90.01.)
"^DD",773,773,90.03,"DT")
3021022
"^DD",773,773,90.04,0)
HLP-RECEIVING APPLICATION^F^^90;4^K:$L(X)>45!($L(X)<1) X
"^DD",773,773,90.04,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-45 characters)
"^DD",773,773,90.04,21,0)
^^5^5^3021210^
"^DD",773,773,90.04,21,1,0)
This field holds the RECEIVING APPLICATION that was on the 4th piece of
"^DD",773,773,90.04,21,2,0)
the HLP("SUBSCRIBER"[,#]) subscriber entry.
"^DD",773,773,90.04,21,3,0)
 
"^DD",773,773,90.04,21,4,0)
(See the 'Additional Comments on ^HLMA(ien,90) Node' section in the 
"^DD",773,773,90.04,21,5,0)
description for field # 90.01.)
"^DD",773,773,90.04,"DT")
3021022
"^DD",773,773,90.05,0)
HLP-RECEIVING FACILITY^F^^90;5^K:$L(X)>30!($L(X)<1) X
"^DD",773,773,90.05,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-30 characters)
"^DD",773,773,90.05,21,0)
^^5^5^3021210^
"^DD",773,773,90.05,21,1,0)
This field holds the RECEIVING FACILITY that was on the 5th piece of the
"^DD",773,773,90.05,21,2,0)
HLP("SUBSCRIBER"[,#]) subscriber entry.
"^DD",773,773,90.05,21,3,0)
 
"^DD",773,773,90.05,21,4,0)
(See the 'Additional Comments on ^HLMA(ien,90) Node' section in the 
"^DD",773,773,90.05,21,5,0)
description for field # 90.01.)
"^DD",773,773,90.05,"DT")
3021022
"^DD",773,773,90.06,0)
HLP-SUBROUTINE^F^^90;6^K:$L(X)>8!($L(X)<1) X
"^DD",773,773,90.06,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-8 characters)
"^DD",773,773,90.06,21,0)
^^1^1^3021210^
"^DD",773,773,90.06,21,1,0)
See the description for the HLP-ROUTINE field (#90.07).
"^DD",773,773,90.06,"DT")
3021022
"^DD",773,773,90.07,0)
HLP-ROUTINE^F^^90;7^K:$L(X)>8!($L(X)<1) X
"^DD",773,773,90.07,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-8 characters)
"^DD",773,773,90.07,21,0)
^^4^4^3021210^
"^DD",773,773,90.07,21,1,0)
Application developers may pass a reference to M code in the 
"^DD",773,773,90.07,21,2,0)
HLP("SUBSCRIBER"[,#]) subscriber entry.  When this is done, the 
"^DD",773,773,90.07,21,3,0)
subroutine being referenced is stored in the HLP-SUBROUTINE field 
"^DD",773,773,90.07,21,4,0)
(#90.06), and the routine is stored in this field.
"^DD",773,773,90.07,"DT")
3021022
"^DD",773,773,90.08,0)
HLP-DEBUG^F^^90;8^K:$L(X)>12!($L(X)<1) X
"^DD",773,773,90.08,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-12 characters)
"^DD",773,773,90.08,21,0)
^^28^28^3021210^
"^DD",773,773,90.08,21,1,0)
The application developer can control what type of debugging data is 
"^DD",773,773,90.08,21,2,0)
stored when MSH segment fields are reset by the HLP("SUBSCRIBER"[,#]) 
"^DD",773,773,90.08,21,3,0)
entry.  This field holds the data on the eighth piece of the 
"^DD",773,773,90.08,21,4,0)
HLP("SUBSCRIBER"[,#]) entry, which also specifies which debugging data 
"^DD",773,773,90.08,21,5,0)
should be stored.
"^DD",773,773,90.08,21,6,0)
 
"^DD",773,773,90.08,21,7,0)
Types Debug Data:
"^DD",773,773,90.08,21,8,0)
-----------------
"^DD",773,773,90.08,21,9,0)
There are three types of debug data:
"^DD",773,773,90.08,21,10,0)
 
"^DD",773,773,90.08,21,11,0)
  - Node ^HLMA(ien,90) data.  (See global map of this file for fields.)
"^DD",773,773,90.08,21,12,0)
  - Node ^HLMA(ien,91) data.  (See global map of this file for fields.)
"^DD",773,773,90.08,21,13,0)
  - ^XTMP("HLCSHDR3 ien") data.  (See patch documentation for 
"^DD",773,773,90.08,21,14,0)
    explanation.)
"^DD",773,773,90.08,21,15,0)
 
"^DD",773,773,90.08,21,16,0)
Syntax:  
"^DD",773,773,90.08,21,17,0)
-------
"^DD",773,773,90.08,21,18,0)
The syntax for the eight piece of the HLP("SUBSCRIBER"[,#]) array entry, 
"^DD",773,773,90.08,21,19,0)
(which is also the value for this field), is:
"^DD",773,773,90.08,21,20,0)
 
"^DD",773,773,90.08,21,21,0)
   [1]-[1]-[1]      
"^DD",773,773,90.08,21,22,0)
 
"^DD",773,773,90.08,21,23,0)
The [brackets] above indicate optionality; any of the three 
"^DD",773,773,90.08,21,24,0)
dash-delimited pieces may be null.
"^DD",773,773,90.08,21,25,0)
 
"^DD",773,773,90.08,21,26,0)
Examples:  1-1-1 -> ^HLMA(ien,90), ^HLMA(ien,91) and ^XTMP data captured.
"^DD",773,773,90.08,21,27,0)
           1--1 -> ^HLMA(ien,90 and ^XTMP data captured.
"^DD",773,773,90.08,21,28,0)
           --1 -> Only ^XTMP data captured.
"^DD",773,773,90.08,"DT")
3021022
"^DD",773,773,91.01,0)
ORIGINAL SND APP^F^^91;1^K:$L(X)>45!($L(X)<1) X
"^DD",773,773,91.01,3)
This field contains the value of the SENDING APPLICATION before overwrite.
"^DD",773,773,91.01,21,0)
^^6^6^3021210^
"^DD",773,773,91.01,21,1,0)
The value of the SENDING APPLICATION is calculated from the event driver
"^DD",773,773,91.01,21,2,0)
protocol.  If this value is overwritten by a HLP("SUBSCRIBER"[,#]) entry,
"^DD",773,773,91.01,21,3,0)
the value before overwrite is stored in this field.
"^DD",773,773,91.01,21,4,0)
 
"^DD",773,773,91.01,21,5,0)
Note:  Fields 91.03, 91.05, and 91.07 similarly hold the pre-overwrite
"^DD",773,773,91.01,21,6,0)
       values for their respective fields.
"^DD",773,773,91.01,"DT")
3030123
"^DD",773,773,91.02,0)
ORIGINAL SND APP-SOURCE^S^A:ARRAY;M:M CODE;^91;2^Q
"^DD",773,773,91.02,3)
This field records whether the overwrite was created by the HLP("SUBSCRIBER"[,#]) array, or by M code.
"^DD",773,773,91.02,21,0)
^^5^5^3021210^
"^DD",773,773,91.02,21,1,0)
MSH segment fields can be overwritten by free-text values on pieces 2 
"^DD",773,773,91.02,21,2,0)
through 5 of the HLP("SUBSCRIBER"[,#]) node, or by M code referenced in 
"^DD",773,773,91.02,21,3,0)
this node.  If the HLP-ORIGINAL SND APP field (#91.01) is overwritten by 
"^DD",773,773,91.02,21,4,0)
free-text data, this field will hold an "A" (for array.)  If overwritten 
"^DD",773,773,91.02,21,5,0)
by M code this field will hold "M".
"^DD",773,773,91.02,"DT")
3030123
"^DD",773,773,91.03,0)
ORIGINAL SND FAC^F^^91;3^K:$L(X)>30!($L(X)<1) X
"^DD",773,773,91.03,3)
This field contains the value of the SENDING FACILITY before overwrite.
"^DD",773,773,91.03,21,0)
^.001^3^3^3021210^^
"^DD",773,773,91.03,21,1,0)
The value of the SENDING FACILITY is calculated from the event driver
"^DD",773,773,91.03,21,2,0)
protocol.  If this value is overwritten by a HLP("SUBSCRIBER"[,#]) entry,
"^DD",773,773,91.03,21,3,0)
the value before overwrite is stored in this field.
"^DD",773,773,91.03,"DT")
3030123
"^DD",773,773,91.04,0)
ORIGINAL SND FAC-SOURCE^S^A:ARRAY;M:M CODE;^91;4^Q
"^DD",773,773,91.04,3)
This field records whether the overwrite was created by the HLP("SUBSCRIBER"[,#]) array, or by M code.
"^DD",773,773,91.04,21,0)
^^5^5^3021210^
"^DD",773,773,91.04,21,1,0)
MSH segment fields can be overwritten by free-text values on pieces 2 
"^DD",773,773,91.04,21,2,0)
through 5 of the HLP("SUBSCRIBER"[,#]) node, or by M code referenced in 
"^DD",773,773,91.04,21,3,0)
this node.  If the HLP-ORIGINAL SND FAC field (#91.03) is overwritten by 
"^DD",773,773,91.04,21,4,0)
free-text data, this field will hold an "A" (for array.)  If overwritten 
"^DD",773,773,91.04,21,5,0)
by M code this field will hold "M".
"^DD",773,773,91.04,"DT")
3030123
"^DD",773,773,91.05,0)
ORIGINAL REC APP^F^^91;5^K:$L(X)>45!($L(X)<1) X
"^DD",773,773,91.05,3)
This field contains the value of the RECEIVING APPLICATION before overwrite.
"^DD",773,773,91.05,21,0)
^^3^3^3021210^
"^DD",773,773,91.05,21,1,0)
The value of the RECEIVING APPLICATION is calculated from the subscriber
"^DD",773,773,91.05,21,2,0)
protocol.  If this value is overwritten by a HLP("SUBSCRIBER"[,#]) entry,
"^DD",773,773,91.05,21,3,0)
the value before overwrite is stored in this field.
"^DD",773,773,91.05,"DT")
3030123
"^DD",773,773,91.06,0)
ORIGINAL REC APP-SOURCE^S^A:ARRAY;M:M CODE;^91;6^Q
"^DD",773,773,91.06,3)
This field records whether the overwrite was created by the HLP("SUBSCRIBER"[,#]) array, or by M code.
"^DD",773,773,91.06,21,0)
^^5^5^3021210^
"^DD",773,773,91.06,21,1,0)
MSH segment fields can be overwritten by free-text values on pieces 2 
"^DD",773,773,91.06,21,2,0)
through 5 of the HLP("SUBSCRIBER"[,#]) node, or by M code referenced in 
"^DD",773,773,91.06,21,3,0)
this node.  If the HLP-ORIGINAL REC APP field (#91.05) is overwritten by 
"^DD",773,773,91.06,21,4,0)
free-text data, this field will hold an "A" (for array.)  If overwritten 
"^DD",773,773,91.06,21,5,0)
by M code this field will hold "M".
"^DD",773,773,91.06,"DT")
3030123
"^DD",773,773,91.07,0)
ORIGINAL REC FAC^F^^91;7^K:$L(X)>30!($L(X)<1) X
"^DD",773,773,91.07,3)
This field contains the value of the SENDING FACILITY before overwrite.
"^DD",773,773,91.07,21,0)
^^3^3^3021210^
"^DD",773,773,91.07,21,1,0)
The value of the RECEIVING FACILITY is calculated from the subscriber
"^DD",773,773,91.07,21,2,0)
protocol. If this value is overwritten by a HLP("SUBSCRIBER"[,#]) entry,
"^DD",773,773,91.07,21,3,0)
the value before overwrite is stored in this field.
"^DD",773,773,91.07,"DT")
3030321
"^DD",773,773,91.08,0)
ORIGINAL REC FAC-SOURCE^S^A:ARRAY;M:M CODE;^91;8^Q
"^DD",773,773,91.08,3)
This field records whether the overwrite was created by the HLP("SUBSCRIBER"[,#]) array, or by M code.
"^DD",773,773,91.08,21,0)
^^5^5^3021210^
"^DD",773,773,91.08,21,1,0)
MSH segment fields can be overwritten by free-text values on pieces 2 
"^DD",773,773,91.08,21,2,0)
through 5 of the HLP("SUBSCRIBER"[,#]) node, or by M code referenced in 
"^DD",773,773,91.08,21,3,0)
this node.  If the HLP-ORIGINAL REC FAC field (#91.07) is overwritten by 
"^DD",773,773,91.08,21,4,0)
free-text data, this field will hold an "A" (for array.)  If overwritten 
"^DD",773,773,91.08,21,5,0)
by M code this field will hold "M".
"^DD",773,773,91.08,"DT")
3030321
**END**
**END**
