KIDS Distribution saved on Jul 18, 2006@08:26:28
PATCHES DG*5.3*673 and IVM*2.0*114 FOR OEF/OIF PHASE I
**KIDS**:DG*5.3*673^IVM*2.0*114^

**INSTALL NAME**
DG*5.3*673
"BLD",6297,0)
DG*5.3*673^REGISTRATION^0^3060718^y
"BLD",6297,1,0)
^^2^2^3051123^
"BLD",6297,1,1,0)
Please refer to patch DG*5.3*673 in the National Patch Module for a 
"BLD",6297,1,2,0)
complete description of this patch.
"BLD",6297,4,0)
^9.64PA^2^1
"BLD",6297,4,2,0)
2
"BLD",6297,4,2,2,0)
^9.641^2^2
"BLD",6297,4,2,2,2,0)
PATIENT  (File-top level)
"BLD",6297,4,2,2,2,1,0)
^9.6411^.3296^6
"BLD",6297,4,2,2,2,1,.325,0)
SERVICE BRANCH [LAST]
"BLD",6297,4,2,2,2,1,.3291,0)
SERVICE BRANCH [NTL]
"BLD",6297,4,2,2,2,1,.32911,0)
SERVICE COMPONENT [LAST]
"BLD",6297,4,2,2,2,1,.32912,0)
SERVICE COMPONENT [NTL]
"BLD",6297,4,2,2,2,1,.32913,0)
SERVICE COMPONENT [NNTL]
"BLD",6297,4,2,2,2,1,.3296,0)
SERVICE BRANCH [NNTL]
"BLD",6297,4,2,2,2.3215,0)
SERVICE [OEF OR OIF]  (sub-file)
"BLD",6297,4,2,2,2.3215,1,0)
^9.6411^^
"BLD",6297,4,2,222)
y^n^p^^^^n^^n
"BLD",6297,4,2,224)

"BLD",6297,4,"APDD",2,2)

"BLD",6297,4,"APDD",2,2,.325)

"BLD",6297,4,"APDD",2,2,.3291)

"BLD",6297,4,"APDD",2,2,.32911)

"BLD",6297,4,"APDD",2,2,.32912)

"BLD",6297,4,"APDD",2,2,.32913)

"BLD",6297,4,"APDD",2,2,.3296)

"BLD",6297,4,"APDD",2,2.3215)

"BLD",6297,4,"B",2,2)

"BLD",6297,"KRN",0)
^9.67PA^8989.52^19
"BLD",6297,"KRN",.4,0)
.4
"BLD",6297,"KRN",.4,"NM",0)
^9.68A^^
"BLD",6297,"KRN",.401,0)
.401
"BLD",6297,"KRN",.402,0)
.402
"BLD",6297,"KRN",.403,0)
.403
"BLD",6297,"KRN",.5,0)
.5
"BLD",6297,"KRN",.84,0)
.84
"BLD",6297,"KRN",3.6,0)
3.6
"BLD",6297,"KRN",3.8,0)
3.8
"BLD",6297,"KRN",9.2,0)
9.2
"BLD",6297,"KRN",9.8,0)
9.8
"BLD",6297,"KRN",9.8,"NM",0)
^9.68A^30^15
"BLD",6297,"KRN",9.8,"NM",1,0)
DGRPMS^^0^B48037248
"BLD",6297,"KRN",9.8,"NM",10,0)
DGLOCK^^0^B28314268
"BLD",6297,"KRN",9.8,"NM",15,0)
DGENUPL2^^0^B66821493
"BLD",6297,"KRN",9.8,"NM",16,0)
DGENUPL4^^0^B66292292
"BLD",6297,"KRN",9.8,"NM",17,0)
DGENUPL7^^0^B29468363
"BLD",6297,"KRN",9.8,"NM",18,0)
DGRPDT^^0^B69102930
"BLD",6297,"KRN",9.8,"NM",19,0)
DGCV^^0^B35316058
"BLD",6297,"KRN",9.8,"NM",21,0)
DGCLAPI1^^0^B7444234
"BLD",6297,"KRN",9.8,"NM",22,0)
DGENUPL1^^0^B32216917
"BLD",6297,"KRN",9.8,"NM",24,0)
DGRPC3^^0^B18322459
"BLD",6297,"KRN",9.8,"NM",26,0)
VAFHLZMH^^0^B17707490
"BLD",6297,"KRN",9.8,"NM",27,0)
VAFHLZM1^^0^B66971868
"BLD",6297,"KRN",9.8,"NM",28,0)
DGENOEIF^^0^B14972188
"BLD",6297,"KRN",9.8,"NM",29,0)
DGDDC^^0^B8871543
"BLD",6297,"KRN",9.8,"NM",30,0)
VAFHLZM2^^0^B3676248
"BLD",6297,"KRN",9.8,"NM","B","DGCLAPI1",21)

"BLD",6297,"KRN",9.8,"NM","B","DGCV",19)

"BLD",6297,"KRN",9.8,"NM","B","DGDDC",29)

"BLD",6297,"KRN",9.8,"NM","B","DGENOEIF",28)

"BLD",6297,"KRN",9.8,"NM","B","DGENUPL1",22)

"BLD",6297,"KRN",9.8,"NM","B","DGENUPL2",15)

"BLD",6297,"KRN",9.8,"NM","B","DGENUPL4",16)

"BLD",6297,"KRN",9.8,"NM","B","DGENUPL7",17)

"BLD",6297,"KRN",9.8,"NM","B","DGLOCK",10)

"BLD",6297,"KRN",9.8,"NM","B","DGRPC3",24)

"BLD",6297,"KRN",9.8,"NM","B","DGRPDT",18)

"BLD",6297,"KRN",9.8,"NM","B","DGRPMS",1)

"BLD",6297,"KRN",9.8,"NM","B","VAFHLZM1",27)

"BLD",6297,"KRN",9.8,"NM","B","VAFHLZM2",30)

"BLD",6297,"KRN",9.8,"NM","B","VAFHLZMH",26)

"BLD",6297,"KRN",19,0)
19
"BLD",6297,"KRN",19.1,0)
19.1
"BLD",6297,"KRN",101,0)
101
"BLD",6297,"KRN",409.61,0)
409.61
"BLD",6297,"KRN",771,0)
771
"BLD",6297,"KRN",870,0)
870
"BLD",6297,"KRN",8989.51,0)
8989.51
"BLD",6297,"KRN",8989.52,0)
8989.52
"BLD",6297,"KRN",8994,0)
8994
"BLD",6297,"KRN","B",.4,.4)

"BLD",6297,"KRN","B",.401,.401)

"BLD",6297,"KRN","B",.402,.402)

"BLD",6297,"KRN","B",.403,.403)

"BLD",6297,"KRN","B",.5,.5)

"BLD",6297,"KRN","B",.84,.84)

"BLD",6297,"KRN","B",3.6,3.6)

"BLD",6297,"KRN","B",3.8,3.8)

"BLD",6297,"KRN","B",9.2,9.2)

"BLD",6297,"KRN","B",9.8,9.8)

"BLD",6297,"KRN","B",19,19)

"BLD",6297,"KRN","B",19.1,19.1)

"BLD",6297,"KRN","B",101,101)

"BLD",6297,"KRN","B",409.61,409.61)

"BLD",6297,"KRN","B",771,771)

"BLD",6297,"KRN","B",870,870)

"BLD",6297,"KRN","B",8989.51,8989.51)

"BLD",6297,"KRN","B",8989.52,8989.52)

"BLD",6297,"KRN","B",8994,8994)

"BLD",6297,"QUES",0)
^9.62^^
"BLD",6297,"REQB",0)
^9.611^9^7
"BLD",6297,"REQB",1,0)
DG*5.3*363^2
"BLD",6297,"REQB",2,0)
DG*5.3*625^2
"BLD",6297,"REQB",3,0)
DG*5.3*628^2
"BLD",6297,"REQB",4,0)
DG*5.3*632^2
"BLD",6297,"REQB",7,0)
DG*5.3*626^2
"BLD",6297,"REQB",8,0)
DG*5.3*672^2
"BLD",6297,"REQB",9,0)
DG*5.3*700^2
"BLD",6297,"REQB","B","DG*5.3*363",1)

"BLD",6297,"REQB","B","DG*5.3*625",2)

"BLD",6297,"REQB","B","DG*5.3*626",7)

"BLD",6297,"REQB","B","DG*5.3*628",3)

"BLD",6297,"REQB","B","DG*5.3*632",4)

"BLD",6297,"REQB","B","DG*5.3*672",8)

"BLD",6297,"REQB","B","DG*5.3*700",9)

"FIA",2)
PATIENT
"FIA",2,0)
^DPT(
"FIA",2,0,0)
2I
"FIA",2,0,1)
y^n^p^^^^n^^n
"FIA",2,0,10)

"FIA",2,0,11)

"FIA",2,0,"RLRO")

"FIA",2,0,"VR")
5.3^DG
"FIA",2,2)
1
"FIA",2,2,.3215)

"FIA",2,2,.325)

"FIA",2,2,.3291)

"FIA",2,2,.32911)

"FIA",2,2,.32912)

"FIA",2,2,.32913)

"FIA",2,2,.3296)

"FIA",2,2.3215)
0
"IX",2,2,"AMSEL",0)
2^AMSEL^DELETE MSE (LAST) FIELDS^MU^^F^^I^2^^^^^A
"IX",2,2,"AMSEL",1)
Q
"IX",2,2,"AMSEL",2)
D DELMSE^DGRPMS(DA,1)
"IX",2,2,"AMSEL",2.4)
S X=X2(1)=""
"IX",2,2,"AMSEL",11.1,0)
^.114IA^1^1
"IX",2,2,"AMSEL",11.1,1,0)
1^F^2^.325^^^F
"IX",2,2,"AMSEL",11.1,1,3)

"IX",2,2,"AMSENL",0)
2^AMSENL^DELETE MSE (NEXT TO LAST) FIELDS^MU^^F^^I^2^^^^^A
"IX",2,2,"AMSENL",1)
Q
"IX",2,2,"AMSENL",2)
D DELMSE^DGRPMS(DA,2)
"IX",2,2,"AMSENL",2.4)
S X=X2(1)=""
"IX",2,2,"AMSENL",11.1,0)
^.114IA^1^1
"IX",2,2,"AMSENL",11.1,1,0)
1^F^2^.3291^^^F
"IX",2,2,"AMSENNL",0)
2^AMSENNL^DELETE MSE (NEXT TO NEXT TO LAST) FIELDS^MU^^F^^I^2^^^^^A
"IX",2,2,"AMSENNL",1)
Q
"IX",2,2,"AMSENNL",2)
D DELMSE^DGRPMS(DA,3)
"IX",2,2,"AMSENNL",2.4)
S X=X2(1)=""
"IX",2,2,"AMSENNL",11.1,0)
^.114IA^1^1
"IX",2,2,"AMSENNL",11.1,1,0)
1^F^2^.3296^^^F
"IX",2,2,"AMSENNL",11.1,1,3)

"IX",2,2.3215,"ALOEIF",0)
2.3215^ALOEIF^Sets the latest OIF/ OEF/ UNKNOWN OEF/OIF episode in a cross reference^MU^^R^IR^I^2.3215^^^^^A
"IX",2,2.3215,"ALOEIF",.1,0)
^^10^10^3060105^^^^
"IX",2,2.3215,"ALOEIF",.1,1,0)
Cross reference is:
"IX",2,2.3215,"ALOEIF",.1,2,0)
  ^DPT("ALOEIF",TO DATE,FROM DATE,OIF/ OEF/ UNKNOWN OEF/OIF indicator,
"IX",2,2.3215,"ALOEIF",.1,3,0)
                DA(1),DA)=""
"IX",2,2.3215,"ALOEIF",.1,4,0)
 
"IX",2,2.3215,"ALOEIF",.1,5,0)
Subscripts are:
"IX",2,2.3215,"ALOEIF",.1,6,0)
  TO DATE = latest conflict to date for OIF/ OEF/ UNKNOWN OEF/OIF
"IX",2,2.3215,"ALOEIF",.1,7,0)
  FROM DATE = corresponding from date for TO DATE value
"IX",2,2.3215,"ALOEIF",.1,8,0)
  OIF/ OEF/ UNKNOWN OEF/OIF indicator = "OIF" "OEF" "UNK"
"IX",2,2.3215,"ALOEIF",.1,9,0)
 
"IX",2,2.3215,"ALOEIF",.1,10,0)
 DA(1) = entry in patient file      DA = entry in OEF/OIF subfile
"IX",2,2.3215,"ALOEIF",1)
D UPDLAST^DGENOEIF(.DA,.X2,1)
"IX",2,2.3215,"ALOEIF",2)
D UPDLAST^DGENOEIF(.DA,.X1,0)
"IX",2,2.3215,"ALOEIF",2.5)

"IX",2,2.3215,"ALOEIF",11.1,0)
^.114IA^4^3
"IX",2,2.3215,"ALOEIF",11.1,2,0)
1^F^2.3215^.03^^^F
"IX",2,2.3215,"ALOEIF",11.1,2,3)

"IX",2,2.3215,"ALOEIF",11.1,3,0)
3^F^2.3215^.02^^^F
"IX",2,2.3215,"ALOEIF",11.1,4,0)
2^F^2.3215^.01^^^F
"IX",2,2.3215,"ALSTUP",0)
2.3215^ALSTUP^TRIGGER THE DATE/TIME OF LAST CHANGE WHEN ANY PERTINENT FIELDS CHANGE^MU^^R^IR^I^2.3215^^^^^A
"IX",2,2.3215,"ALSTUP",1)
N DATA,DGENDA S DATA(.05)=$$NOW^XLFDT,DGENDA=DA,DGENDA(1)=DA(1) I $$UPD^DGENDBS(2.3215,.DGENDA,.DATA)
"IX",2,2.3215,"ALSTUP",1.4)
S X=$S($G(X2(1))'=""&($G(X1(1))'=$G(X2(1))):1,$G(X1(2))'=$G(X2(2)):1,$G(X1(3))'=$G(X2(3)):1,1:0)
"IX",2,2.3215,"ALSTUP",2)
N DATA,DGENDA S DATA(.05)=$$NOW^XLFDT,DGENDA=DA,DGENDA(1)=DA(1) I $$UPD^DGENDBS(2.3215,.DGENDA,.DATA)
"IX",2,2.3215,"ALSTUP",11.1,0)
^.114IA^3^3
"IX",2,2.3215,"ALSTUP",11.1,1,0)
1^F^2.3215^.01^^^F
"IX",2,2.3215,"ALSTUP",11.1,2,0)
2^F^2.3215^.02^^^F
"IX",2,2.3215,"ALSTUP",11.1,3,0)
3^F^2.3215^.03^^^F
"MBREQ")
0
"PKG",5,-1)
1^1
"PKG",5,0)
REGISTRATION^DG^PATIENT REGISTRATION, ADMISSION, DISCHARGE, EMBOSSER 
"PKG",5,20,0)
^9.402P^^
"PKG",5,22,0)
^9.49I^1^1
"PKG",5,22,1,0)
5.3^2930813
"PKG",5,22,1,"PAH",1,0)
673^3060718^539
"PKG",5,22,1,"PAH",1,1,0)
^^2^2^3060718
"PKG",5,22,1,"PAH",1,1,1,0)
Please refer to patch DG*5.3*673 in the National Patch Module for a 
"PKG",5,22,1,"PAH",1,1,2,0)
complete description of this patch.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
15
"RTN","DGCLAPI1")
0^21^B7444234
"RTN","DGCLAPI1",1,0)
DGCLAPI1 ;ALB/TMK - Utilities for OEF/OIF/UNKNOWN OEF/OIF conflict loc; 10/20/05
"RTN","DGCLAPI1",2,0)
 ;;5.3;Registration;**673**;Aug 13, 1993
"RTN","DGCLAPI1",3,0)
 Q
"RTN","DGCLAPI1",4,0)
 ;
"RTN","DGCLAPI1",5,0)
OEIFUPD(DGDFN,DGOEIF) ;
"RTN","DGCLAPI1",6,0)
 ;Entry point for OEF, OIF, UNKNOWN OEF/OIF conflict data
"RTN","DGCLAPI1",7,0)
 ; updates via the ZMH HL7 message upload.
"RTN","DGCLAPI1",8,0)
 ;
"RTN","DGCLAPI1",9,0)
 ;  Input:
"RTN","DGCLAPI1",10,0)
 ;    DGDFN  - PATIENT file (#2) IEN
"RTN","DGCLAPI1",11,0)
 ;    DGOEIF  - update values array passed by reference
"RTN","DGCLAPI1",12,0)
 ;      DGOEIF("COUNT") - count of the # of entries
"RTN","DGCLAPI1",13,0)
 ;      DGOEIF("LOC") - Conflict Location Indicator
"RTN","DGCLAPI1",14,0)
 ;      DGOEIF("FR") - OEF/OIF/UNKNOWN OEF/OIF Date From
"RTN","DGCLAPI1",15,0)
 ;      DGOEIF("TO") - OEF/OIF/UNKNOWN OEF/OIF Date To
"RTN","DGCLAPI1",16,0)
 ;      DGOEIF("SITE") - Source of data (ptr to file 4 or null for CEV)
"RTN","DGCLAPI1",17,0)
 ;
"RTN","DGCLAPI1",18,0)
 ;  Output:
"RTN","DGCLAPI1",19,0)
 ;    Function result 1-success, 0-failure
"RTN","DGCLAPI1",20,0)
 ;
"RTN","DGCLAPI1",21,0)
 N DA,DIC,DIK,DGRSLT,DGX,DGX1,DGARY,DGCHG,X,Y,DO,DD
"RTN","DGCLAPI1",22,0)
 ;
"RTN","DGCLAPI1",23,0)
 S DGCHG=0,DGRSLT=1,DGDFN=+$G(DGDFN)
"RTN","DGCLAPI1",24,0)
 I DGDFN>0,$D(^DPT(DGDFN)),$$CHANGE(DGDFN,.DGOEIF) S DGCHG=1
"RTN","DGCLAPI1",25,0)
 ; If changes found, delete the existing data, add new records
"RTN","DGCLAPI1",26,0)
 I DGCHG D
"RTN","DGCLAPI1",27,0)
 . S DGRSLT=0
"RTN","DGCLAPI1",28,0)
 . S DA=0 F  S DA=$O(^DPT(DGDFN,.3215,DA)) Q:'DA  S DA(1)=DGDFN,DIK="^DPT("_DA(1)_",.3215," D ^DIK
"RTN","DGCLAPI1",29,0)
 . F DGX="LOC","FR","TO","LOCK","SITE" S DGX1=0 F  S DGX1=$O(DGOEIF(DGX,DGX1)) Q:'DGX1  S DGARY(DGX1,DGX)=DGOEIF(DGX,DGX1)
"RTN","DGCLAPI1",30,0)
 . S DGX=0 F  S DGX=$O(DGARY(DGX)) Q:'DGX  D  Q:'DGRSLT
"RTN","DGCLAPI1",31,0)
 .. ; Add a new entry
"RTN","DGCLAPI1",32,0)
 .. S DIC(0)="L",DIC("DR")=".02////"_$G(DGARY(DGX,"FR"))_";.03////"_$G(DGARY(DGX,"TO"))_";.04////1"_$S($G(DGARY(DGX,"SITE"))'="":";.06////"_DGARY(DGX,"SITE"),1:"")
"RTN","DGCLAPI1",33,0)
 .. S DA(1)=DGDFN,DIC="^DPT("_DA(1)_",.3215,"
"RTN","DGCLAPI1",34,0)
 .. S X=$G(DGARY(DGX,"LOC")),X=$S(X="OIF":1,X="OEF":2,X="UNK":3,1:"") I X D FILE^DICN K DIC S DGRSLT=(Y>0)
"RTN","DGCLAPI1",35,0)
 Q DGRSLT
"RTN","DGCLAPI1",36,0)
 ;
"RTN","DGCLAPI1",37,0)
CHANGE(DGDFN,DGOEIF) ;Did the data change?
"RTN","DGCLAPI1",38,0)
 ;  Input
"RTN","DGCLAPI1",39,0)
 ;      DGDFN    - Patients DFN
"RTN","DGCLAPI1",40,0)
 ;      DGOEIF("COUNT") - the count of the # of entries in the multiple
"RTN","DGCLAPI1",41,0)
 ;      DGOEIF("LOC",n)=Conflict Location Indicator
"RTN","DGCLAPI1",42,0)
 ;      DGOEIF("FR",n)=OEF/OIF/UNKNOWN OEF/OIF Date From
"RTN","DGCLAPI1",43,0)
 ;      DGOEIF("TO",n)=OEF/OIF/UNKNOWN OEF/OIF Date To
"RTN","DGCLAPI1",44,0)
 ;      DGOEIF("LOCK")=Lock flag for HEC data
"RTN","DGCLAPI1",45,0)
 ;      DGOEIF("site",n)=Source of data if a site or null if CEV
"RTN","DGCLAPI1",46,0)
 ;
"RTN","DGCLAPI1",47,0)
 ;  Output
"RTN","DGCLAPI1",48,0)
 ;      Returns 0 if no status change
"RTN","DGCLAPI1",49,0)
 ;              1 if status changed
"RTN","DGCLAPI1",50,0)
 ;
"RTN","DGCLAPI1",51,0)
 N DGCHG,DGOEIFO,DGX,DGX1,Z
"RTN","DGCLAPI1",52,0)
 ;
"RTN","DGCLAPI1",53,0)
 I +$G(DGDFN)'>0 Q 0
"RTN","DGCLAPI1",54,0)
 S DGOEIF("COUNT")=$G(DGOEIF("COUNT"))
"RTN","DGCLAPI1",55,0)
 S DGCHG=0
"RTN","DGCLAPI1",56,0)
 I 'DGOEIF("COUNT"),'$O(^DPT(DGDFN,.3215,0)) S DGCHG=0 G CHNGQ
"RTN","DGCLAPI1",57,0)
 S Z=+$$GET^DGENOEIF(DGDFN,.DGOEIFO,0)
"RTN","DGCLAPI1",58,0)
 I DGOEIF("COUNT")'=Z S DGCHG=1 G CHNGQ
"RTN","DGCLAPI1",59,0)
 S Z=0 F  S Z=$O(DGOEIFO("LOC",Z)) Q:'Z  S DGOEIFO("LOC",Z)=$E($$EXTERNAL^DILFD(2.3215,.01,,+DGOEIFO("LOC",Z)),1,3)
"RTN","DGCLAPI1",60,0)
 S DGX="" F  S DGX=$O(DGOEIF(DGX)) Q:DGX=""!DGCHG  D  Q:DGCHG
"RTN","DGCLAPI1",61,0)
 . S DGX1=0 F  S DGX1=$O(DGOEIF(DGX,DGX1)) Q:'DGX1  D  Q:DGCHG
"RTN","DGCLAPI1",62,0)
 .. I DGX="SITE",$S($G(DGOEIF("SITE",DGX1))="":$G(DGOEIFO("SITE",DGX1))="CEV",1:0) Q
"RTN","DGCLAPI1",63,0)
 .. I DGX="LOCK",$G(DGOEIFO("LOCK",DGX1))=1 Q
"RTN","DGCLAPI1",64,0)
 .. I $G(DGOEIFO(DGX,DGX1))'=$G(DGOEIF(DGX,DGX1)) S DGCHG=1 Q
"RTN","DGCLAPI1",65,0)
CHNGQ Q DGCHG
"RTN","DGCLAPI1",66,0)
 ;
"RTN","DGCV")
0^19^B35316058
"RTN","DGCV",1,0)
DGCV ;ALB/DW,ERC,BRM,TMK - COMBAT VET ELIGIBILTY; 10/15/05
"RTN","DGCV",2,0)
 ;;5.3;Registration;**528,576,564,673**; Aug 13, 1993
"RTN","DGCV",3,0)
 ;
"RTN","DGCV",4,0)
CVELIG(DFN) ;
"RTN","DGCV",5,0)
 ;API will determine whether or not this vetearn needs to have CV End
"RTN","DGCV",6,0)
 ;Date set.  If this determination cannot be done due to imprecise
"RTN","DGCV",7,0)
 ;or missing dates, it returns which dates need editing.
"RTN","DGCV",8,0)
 ;Input:
"RTN","DGCV",9,0)
 ;  DFN - Patient file IEN
"RTN","DGCV",10,0)
 ;Output
"RTN","DGCV",11,0)
 ;  RESULT
"RTN","DGCV",12,0)
 ;    0 - CV End Date should not be updated
"RTN","DGCV",13,0)
 ;    1 - CV End Date should be updated
"RTN","DGCV",14,0)
 ;  If critical dates are imprecise return the following
"RTN","DGCV",15,0)
 ;    A - CV End Date should not be updated, imprecise Service Sep date
"RTN","DGCV",16,0)
 ;    B - CV End Date should not be updated, imprecise Combat To date
"RTN","DGCV",17,0)
 ;    C - CV End Date should not be updated, imprecise Yugoslavia To date
"RTN","DGCV",18,0)
 ;    D - CV End Date should not be updated, imprecise Somalia To date
"RTN","DGCV",19,0)
 ;    E - CV End Date should not be updated, imprecise Pers Gulf To date
"RTN","DGCV",20,0)
 ;  If the Service Sep Date is missing, and there are no OEF/OIF/UNKNOWN
"RTN","DGCV",21,0)
 ;    OEF/OIF records on file, return the following so that it  will
"RTN","DGCV",22,0)
 ;    appear on the Imprecise/Missing Date Report
"RTN","DGCV",23,0)
 ;    F - missing Service Sep Date & no OEF OIF or OEF/OIF Unknown dates
"RTN","DGCV",24,0)
 ;  If critical dates are missing but the corresponding indicator fields
"RTN","DGCV",25,0)
 ;    are set to 'YES' return the following
"RTN","DGCV",26,0)
 ;    G - missing Combat To Date, but Combat Indicated? = 'Yes'
"RTN","DGCV",27,0)
 ;    H - missing PG To Date, but PG Indicated? = 'Yes'
"RTN","DGCV",28,0)
 ;    I - missing Somalia To Date, but Somalia Indicator = 'Yes'
"RTN","DGCV",29,0)
 ;    J - missing Yugoslavia To Date, but Yugoslavia Indicator = 'Yes'
"RTN","DGCV",30,0)
 ;
"RTN","DGCV",31,0)
 N DG1,DG2,I,RESULT
"RTN","DGCV",32,0)
 N DGCOM,DGCVDT,DGCVFLG,DGGULF,DGSOM,DGSRV,DGYUG,DGOEIF
"RTN","DGCV",33,0)
 S (DG1,DG2,RESULT)=0
"RTN","DGCV",34,0)
 I $G(DFN)']"" Q RESULT
"RTN","DGCV",35,0)
 I '$D(^DPT(DFN)) Q RESULT
"RTN","DGCV",36,0)
 ;
"RTN","DGCV",37,0)
 ;get combat related data from top-level VistA fields
"RTN","DGCV",38,0)
 N DGARR,DGERR
"RTN","DGCV",39,0)
 D GETS^DIQ(2,DFN_",",".327;.322012;.322018;.322021;.5294;.5295","I","DGARR","DGERR")
"RTN","DGCV",40,0)
 D PARSE
"RTN","DGCV",41,0)
 ;
"RTN","DGCV",42,0)
 S DG1=$$CHKSSD(DFN) ;check SSD for imprecise or missing
"RTN","DGCV",43,0)
 S DGDATE=$G(DGCOM)_"^"_$G(DGYUG)_"^"_$G(DGSOM)_"^"_$G(DGGULF)_"^"_$G(DGOEIF)
"RTN","DGCV",44,0)
 ;
"RTN","DGCV",45,0)
 I $S(DG1="F":1,1:$P(DGDATE,U,5)>$G(DGSRV)) D
"RTN","DGCV",46,0)
 . ; Use OIF/OEF/UNKNOWN OEF/OIF to dt only when SSD missing or SSD less
"RTN","DGCV",47,0)
 . ; than OIF/OEF/UNKNOWN OEF/OIF to dt
"RTN","DGCV",48,0)
 . N DGSRV,Z
"RTN","DGCV",49,0)
 . S DGSRV=$P(DGDATE,U,5),Z=$$CHKSSD(DFN)
"RTN","DGCV",50,0)
 . I Z=1 S DG1=Z
"RTN","DGCV",51,0)
 ;
"RTN","DGCV",52,0)
 S DG2=$$CHKREST(DGDATE,$G(DGSRV)) ;check other "TO" dates for imprecise, missing or invalid
"RTN","DGCV",53,0)
 S RESULT=$$RES(DG1,$G(DG2))
"RTN","DGCV",54,0)
 Q RESULT
"RTN","DGCV",55,0)
 ;
"RTN","DGCV",56,0)
RES(DG1,DG2) ;determine the final RESULT code from DG1 & DG2
"RTN","DGCV",57,0)
 ;if SSD evaluates to earlier than 11/11/98, can't set CV End Date
"RTN","DGCV",58,0)
 I DG1=0!($G(DG2)=0) Q 0
"RTN","DGCV",59,0)
 ;if SSD is 1
"RTN","DGCV",60,0)
 I DG1=1,($G(DG2)=1!($G(DG2)']"")) Q 1
"RTN","DGCV",61,0)
 I DG1=1,($G(DG2)=0) Q 0
"RTN","DGCV",62,0)
 I DG1=1 Q DG2
"RTN","DGCV",63,0)
 ;if SSD is imprecise or missing
"RTN","DGCV",64,0)
 I DG1'=1,($G(DG2)=1) S DG2=""
"RTN","DGCV",65,0)
 Q DG1_DG2
"RTN","DGCV",66,0)
 ;
"RTN","DGCV",67,0)
CHKDATE(DGDATE,I,SSD) ;check to see if date is imprecise or missing
"RTN","DGCV",68,0)
 ;if imprecise check to see if the imprecision prevents CV evaluation
"RTN","DGCV",69,0)
 ;if not imprecise check to see if after 11/11/98
"RTN","DGCV",70,0)
 ; Note that SSD doesn't appear to ever be used here (TMK)
"RTN","DGCV",71,0)
 N RES
"RTN","DGCV",72,0)
 S RES=0
"RTN","DGCV",73,0)
 I $G(DGDATE)']"",I'=5 D  Q RES
"RTN","DGCV",74,0)
 . S RES=$S(I=0:"F",I=1:"G",I=2:"H",I=3:"I",I=4:"J",1:"")
"RTN","DGCV",75,0)
 I $E(DGDATE,6,7)="00" D
"RTN","DGCV",76,0)
 . I I=0 I DGDATE>2981111 S RES="A" Q
"RTN","DGCV",77,0)
 . I DGDATE=2980000!(DGDATE=2981100) D  Q
"RTN","DGCV",78,0)
 .. ; Note OIF/OEF/UNKNOWN OEF/OIF will not get here as these dates by
"RTN","DGCV",79,0)
 .. ; definition are after 11/11/98
"RTN","DGCV",80,0)
 . . S RES=$S(I=0:"A",I=1:"B",I=2:"C",I=3:"D",I=4:"E",1:"")
"RTN","DGCV",81,0)
 Q:RES="A" RES
"RTN","DGCV",82,0)
 I DGDATE>2981111 S RES=1
"RTN","DGCV",83,0)
 Q RES
"RTN","DGCV",84,0)
 ;
"RTN","DGCV",85,0)
SETCV(DFN,DGSRV) ;calculate CV end date
"RTN","DGCV",86,0)
 K DGCVEDT
"RTN","DGCV",87,0)
 N DGFDA
"RTN","DGCV",88,0)
 I $G(DFN)']""!($G(DGSRV)']"") Q
"RTN","DGCV",89,0)
 I '$D(^DPT(DFN)) Q
"RTN","DGCV",90,0)
 S DGCVEDT=$P($$SCH^XLFDT("24M",DGSRV),".")
"RTN","DGCV",91,0)
 I DGCVEDT=$G(DGCVDT) Q
"RTN","DGCV",92,0)
 I $$GET1^DIQ(2,DFN_",",.5295,"I") Q
"RTN","DGCV",93,0)
 S DGFDA(2,DFN_",",.5295)=DGCVEDT
"RTN","DGCV",94,0)
 D FILE^DIE(,"DGFDA")
"RTN","DGCV",95,0)
 Q
"RTN","DGCV",96,0)
 ;
"RTN","DGCV",97,0)
CVEDT(DFN,DGDT) ;Provide Combat Vet Eligibility End Date, if eligible
"RTN","DGCV",98,0)
 ;Supported DBIA #4156
"RTN","DGCV",99,0)
 ;Input:  DFN - Patient file IEN
"RTN","DGCV",100,0)
 ;        DGDT - Treatment date (optional), 
"RTN","DGCV",101,0)
 ;               DT is default
"RTN","DGCV",102,0)
 ;Output :RESULT=(1,0,-1)^End Date (if populated, otherwise null)^CV
"RTN","DGCV",103,0)
 ;               Eligible on DGDT(1,0)^is patient eligible on input date?
"RTN","DGCV",104,0)
 ;      (piece 1)  1 - qualifies as a CV
"RTN","DGCV",105,0)
 ;                 0 - does not qualify as a CV
"RTN","DGCV",106,0)
 ;                -1 - bad DFN or date
"RTN","DGCV",107,0)
 ;      (piece 3)  1 - vet was eligible on date specified (or DT)      
"RTN","DGCV",108,0)
 ;                 0 - vet was not eligible on date specified (or DT)
"RTN","DGCV",109,0)
 ;
"RTN","DGCV",110,0)
 N RESULT
"RTN","DGCV",111,0)
 S RESULT=""
"RTN","DGCV",112,0)
 I $G(DFN)="" Q -1
"RTN","DGCV",113,0)
 I '$D(^DPT(DFN)) Q -1
"RTN","DGCV",114,0)
 ;if time sent in, drop time
"RTN","DGCV",115,0)
 I $G(DGDT)']"" S DGDT=DT
"RTN","DGCV",116,0)
 I DGDT?7N1"."1.6N S DGDT=$E(DGDT,1,7)
"RTN","DGCV",117,0)
 I DGDT'?7N Q -1
"RTN","DGCV",118,0)
 S RESULT=$$GET1^DIQ(2,DFN_",",.5295,"I")
"RTN","DGCV",119,0)
 I $G(RESULT)']"" Q 0
"RTN","DGCV",120,0)
 S RESULT=$S(DGDT'>RESULT:RESULT_"^1",1:RESULT_"^0") ; if treatment date is earlier or equal to end date, veteran is eligible
"RTN","DGCV",121,0)
 S RESULT=$S($G(RESULT):1_"^"_RESULT,1:0)
"RTN","DGCV",122,0)
 Q RESULT
"RTN","DGCV",123,0)
 ;
"RTN","DGCV",124,0)
PARSE ;GETS^DIQ called in CVELIG - in this subroutine stuff results into array
"RTN","DGCV",125,0)
 S DGSRV=$G(DGARR(2,DFN_",",.327,"I"))
"RTN","DGCV",126,0)
 S DGCOM=$G(DGARR(2,DFN_",",.5294,"I")) ;Combat To Date
"RTN","DGCV",127,0)
 S DGGULF=$G(DGARR(2,DFN_",",.322012,"I")) ;Persian Gulf To Date
"RTN","DGCV",128,0)
 S DGSOM=$G(DGARR(2,DFN_",",.322018,"I")) ;Somalia To Date
"RTN","DGCV",129,0)
 S DGYUG=$G(DGARR(2,DFN_",",.322021,"I")) ;Yugoslavia To Date
"RTN","DGCV",130,0)
 S DGCVDT=$G(DGARR(2,DFN_",",.5295,"I")) ;CV End Date
"RTN","DGCV",131,0)
 ; get last OIF/OEF/UNKNOWN OEF/OIF episode from multiple
"RTN","DGCV",132,0)
 S DGOEIF=$P($$LAST^DGENOEIF(DFN),U)
"RTN","DGCV",133,0)
 Q
"RTN","DGCV",134,0)
 ;
"RTN","DGCV",135,0)
CHKSSD(DFN) ;check the Serv Sep Date [Last]
"RTN","DGCV",136,0)
 ; DGSRV=last SSD
"RTN","DGCV",137,0)
 ;  Output - RESULT
"RTN","DGCV",138,0)
 ;    1 - Date is present and after 11/11/1998
"RTN","DGCV",139,0)
 ;    0 - Date is present but before 11/11/1998
"RTN","DGCV",140,0)
 ;    A - Date is imprecise & either is or potentially is after 11/11/98
"RTN","DGCV",141,0)
 ;    F - Date is missing
"RTN","DGCV",142,0)
 N DG1
"RTN","DGCV",143,0)
 I $G(DGSRV)']"" Q "F"
"RTN","DGCV",144,0)
 S DG1=$$CHKDATE(DGSRV,0)
"RTN","DGCV",145,0)
 I $G(DG1)']"" S DG1=0
"RTN","DGCV",146,0)
 Q DG1
"RTN","DGCV",147,0)
 ;
"RTN","DGCV",148,0)
CHKREST(DGDATE,SSD) ;
"RTN","DGCV",149,0)
 ; SSD = optional, = to the last serv sep date
"RTN","DGCV",150,0)
 N DG3,DG4,DGDT,DGFLG,DGLEN,DGQ,DGR,DGRES,DGX
"RTN","DGCV",151,0)
 S (DG3,DG4,DGR,DGRES)=""
"RTN","DGCV",152,0)
 S DGQ=0 ;loop terminator
"RTN","DGCV",153,0)
 S DGFLG=0 ;flag to indicate that one of the dates is missing (no 
"RTN","DGCV",154,0)
 ;          need to check this for OIF/OEF/UNKNOWN OEF/OIF since
"RTN","DGCV",155,0)
 ;          by definition, these must always be post 11/11/98)
"RTN","DGCV",156,0)
 F DGX=1:1:5 D
"RTN","DGCV",157,0)
 . S DGDT=$P(DGDATE,U,DGX) D
"RTN","DGCV",158,0)
 . . I DGX'=5,$G(DGDT)']"" S DGFLG=1
"RTN","DGCV",159,0)
 . . S DG4=$$CHKDATE(DGDT,DGX,$G(SSD))
"RTN","DGCV",160,0)
 . . I $G(DG4)'=0 S DG3=$G(DG3)_$G(DG4)
"RTN","DGCV",161,0)
 S DGLEN=$L(DG3)
"RTN","DGCV",162,0)
 S DGQ=0
"RTN","DGCV",163,0)
 F DGX=1:1:DGLEN S DGCHAR=$E(DG3,DGX) D  Q:DGQ=1
"RTN","DGCV",164,0)
 . I DGCHAR=1 S DG3=DGCHAR,DGQ=1 Q
"RTN","DGCV",165,0)
 . I "BCDE"[DGCHAR S DGR=DGR_DGCHAR,DGQ=2
"RTN","DGCV",166,0)
 I DGQ=1 Q 1
"RTN","DGCV",167,0)
 I DGQ=2 Q $E(DGR)
"RTN","DGCV",168,0)
 I DGFLG=1 S DGRES=$$MISS(DFN,DGLEN,DG3)
"RTN","DGCV",169,0)
 Q DGRES
"RTN","DGCV",170,0)
 ;
"RTN","DGCV",171,0)
MISS(DFN,DGLEN,DGRES) ;there is at least one missing date, and in order to 
"RTN","DGCV",172,0)
 ;return a RESULT of a missing date, need to check to see if the 
"RTN","DGCV",173,0)
 ;corresponding indicator field is set to 'YES'
"RTN","DGCV",174,0)
 N DGARR,DGCHAR,DGERR,DGQ,DGR,DGX
"RTN","DGCV",175,0)
 N DGCIND,DGPGIND,DGSIND,DGYIND
"RTN","DGCV",176,0)
 S (DGCHAR,DGQ,DGR)=0
"RTN","DGCV",177,0)
 D GETS^DIQ(2,DFN_",",".32201;.322019;.322016;.5291","I","DGARR","DGERR")
"RTN","DGCV",178,0)
 S DGCIND=$G(DGARR(2,DFN_",",.5291,"I")) ;Combat Service Indicated
"RTN","DGCV",179,0)
 S DGYIND=$G(DGARR(2,DFN_",",.322019,"I")) ;Yugo service indicated
"RTN","DGCV",180,0)
 S DGSIND=$G(DGARR(2,DFN_",",.322016,"I")) ;Somalia service indicated
"RTN","DGCV",181,0)
 S DGPGIND=$G(DGARR(2,DFN_",",.32201,"I")) ;Pers Gulf service indicated
"RTN","DGCV",182,0)
 F DGX=1:1:DGLEN S DGCHAR=$E(DGRES,DGX) D  Q:DGQ=1
"RTN","DGCV",183,0)
 . I DGCHAR="G",($G(DGCIND)="Y") S DGR="G",DGQ=1 Q
"RTN","DGCV",184,0)
 . I DGCHAR="H",($G(DGYIND)="Y") S DGR="H",DGQ=1 Q
"RTN","DGCV",185,0)
 . I DGCHAR="I",($G(DGSIND)="Y") S DGR="I",DGQ=1 Q
"RTN","DGCV",186,0)
 . I DGCHAR="J",($G(DGPGIND)="Y") S DGR="J"
"RTN","DGCV",187,0)
 Q DGR
"RTN","DGCV",188,0)
DELCV(DFN) ;called by the Kill logic of the ACVCOM cross reference
"RTN","DGCV",189,0)
 ;if $$CVELIG^DGCV returns a 0 the CV End Date should be deleted
"RTN","DGCV",190,0)
 ;because this would indicate that fields have been changed and
"RTN","DGCV",191,0)
 ;CV eligibility is no longer appropriate
"RTN","DGCV",192,0)
 ;
"RTN","DGCV",193,0)
 N DGCV,DGFDA
"RTN","DGCV",194,0)
 K DGCVFLG
"RTN","DGCV",195,0)
 S DGCVFLG=0
"RTN","DGCV",196,0)
 I $G(DFN)']"" Q
"RTN","DGCV",197,0)
 I '$D(^DPT(DFN)) Q
"RTN","DGCV",198,0)
 S DGCV=$$GET1^DIQ(2,DFN_",",.5295,"I")
"RTN","DGCV",199,0)
 I $G(DGCV)']"" Q
"RTN","DGCV",200,0)
 S DGCVFLG=1
"RTN","DGCV",201,0)
 S DGFDA(2,DFN_",",.5295)="@"
"RTN","DGCV",202,0)
 D FILE^DIE(,"DGFDA")
"RTN","DGCV",203,0)
 Q
"RTN","DGDDC")
0^29^B8871543
"RTN","DGDDC",1,0)
DGDDC ;ALB/MRL - X-ECUTE KILL X-REFERENCES [PATIENT] ;25 JUL 88@1337
"RTN","DGDDC",2,0)
 ;;5.3;Registration;**489,244,527,700,673**;Aug 13, 1993
"RTN","DGDDC",3,0)
 ;
"RTN","DGDDC",4,0)
 Q:$D(DGNOFDEL)  ;Flag variable to prevent deletion cascade
"RTN","DGDDC",5,0)
 ;
"RTN","DGDDC",6,0)
 Q:'$D(DGXRF)  N DGXRFX,DGXRF1,DGXRF2,DGXRF3,DGXRF3,DGXRF4,DGXRF5,DGXRF6,DGXRF7,DGXRF8,DGXRFP,DGXRFX
"RTN","DGDDC",7,0)
 S DGXRFX=X,DGXRF1=+$P(DGXRF,".",2),DGXRF2=$P($T(@DGXRF1),";;",2) G Q:DGXRF2=""
"RTN","DGDDC",8,0)
 I $D(^DD(2,DGXRF,0)) S DGXRFP=$P(^(0),"^",4),DGXRF6=$P(DGXRFP,";",2),DGXRF5=$P(DGXRFP,";",1) I $D(^DPT(DA,DGXRF5)),($P(^(DGXRF5),"^",DGXRF6)=DGXRFX) G Q
"RTN","DGDDC",9,0)
 I DGXRF=".1212",($D(^DPT(DA,DGXRF5))),($P(^(DGXRF5),"^",DGXRF6)="") S DGFDA(2,DA_",",.1213)="" D FILE^DIE("","DGFDA","DGERR") K DGFDA,DGERR G Q
"RTN","DGDDC",10,0)
 N DGFDA,DGERR
"RTN","DGDDC",11,0)
 ;F DGXRF3=1:1 S DGXRF4=$P(DGXRF2,"^",DGXRF3) Q:DGXRF4=""  I $D(^DD(2,DGXRF4,0)) S DGXRF5=$P(^(0),"^",4),DGXRF6=$P(DGXRF5,";",2),DGXRF5=$P(DGXRF5,";",1) I $D(^DPT(DA,DGXRF5)),$P(^(DGXRF5),"^",DGXRF6)'="" D KILL
"RTN","DGDDC",12,0)
 F DGXRF3=1:1 S DGXRF4=$P(DGXRF2,"^",DGXRF3) Q:DGXRF4=""  I $D(^DD(2,DGXRF4,0)) S DGXRF5=$P(^(0),"^",4),DGXRF6=$P(DGXRF5,";",2),DGXRF5=$P(DGXRF5,";",1) I $D(^DPT(DA,DGXRF5)),$P(^(DGXRF5),"^",DGXRF6)'="",DGXRF4'=".1212" D
"RTN","DGDDC",13,0)
 .I DGXRF4'=".1213" S DGFDA(2,DA_",",DGXRF4)=""
"RTN","DGDDC",14,0)
 I $D(DGFDA) D FILE^DIE("","DGFDA","DGERR")
"RTN","DGDDC",15,0)
Q S X=DGXRFX K DGXRF Q  ;,DGXRFX,DGXRF1,DGXRF2,DGXRF3,DGXRF3,DGXRF4,DGXRF5,DGXRF6,DGXRF7,DGXRF8,DGXRFP,DGXRFX Q
"RTN","DGDDC",16,0)
KILL S DGXRF7=$P(^DPT(DA,DGXRF5),"^",DGXRF6),$P(^DPT(DA,DGXRF5),"^",DGXRF6)=""
"RTN","DGDDC",17,0)
 F DGXRF8=0:0 S DGXRF8=$O(^DD(2,DGXRF4,1,DGXRF8)) Q:'DGXRF8  I $D(^DD(2,DGXRF4,1,DGXRF8,2)) S X=DGXRF7 X:^(2)'["DGXRF" ^(2) D SET I $D(^DD(2,DGXRF4,1,DGXRF8,1)) D SET
"RTN","DGDDC",18,0)
 Q
"RTN","DGDDC",19,0)
SET Q:^DD(2,DGXRF4,1,DGXRF8,1)'["DGXRF"  S X="" X ^(1) Q
"RTN","DGDDC",20,0)
 ;
"RTN","DGDDC",21,0)
152 ;;.1651^.1653^.1654^.1656^.307^
"RTN","DGDDC",22,0)
153 ;;.1657^.1658^.1659^
"RTN","DGDDC",23,0)
211 ;;.212^.2125^.213^.214^.215^.216^.217^.218^.219^.21011^.2207^
"RTN","DGDDC",24,0)
2191 ;;.2192^.21925^.2193^.2194^.2195^.2196^.2197^.2198^.2199^.211011^.2203^
"RTN","DGDDC",25,0)
251 ;;.252^.253^.254^.255^.256^.257^.258^.2206^
"RTN","DGDDC",26,0)
3111 ;;.3113^.3114^.3115^.3116^.3117^.3118^.3119^.2205^
"RTN","DGDDC",27,0)
331 ;;.332^.3305^.333^.334^.335^.336^.337^.338^.339^.33011^.2201^
"RTN","DGDDC",28,0)
3311 ;;.3312^.3313^.3314^.3315^.3316^.3317^.3318^.3319^.331011^.2204^
"RTN","DGDDC",29,0)
341 ;;.342^.3405^.343^.344^.345^.346^.347^.348^.349^.34011^.2202^
"RTN","DGDDC",30,0)
3285 ;;.329^.3291^.3292^.3293^.3294^.32912^
"RTN","DGDDC",31,0)
32945 ;;.3295^.3296^.3297^.3298^.3299^.32913^
"RTN","DGDDC",32,0)
3291 ;;.32912
"RTN","DGDDC",33,0)
3296 ;;.32913
"RTN","DGDDC",34,0)
325 ;;.32911
"RTN","DGDDC",35,0)
111 ;;.112^.113
"RTN","DGDDC",36,0)
112 ;;.113
"RTN","DGDDC",37,0)
12105 ;;.1217^.1218
"RTN","DGDDC",38,0)
1211 ;;.1212^.1213
"RTN","DGDDC",39,0)
1212 ;;.1213
"RTN","DGDDC",40,0)
14105 ;;.1417^.1418
"RTN","DGDDC",41,0)
1411 ;;.1412^.1413
"RTN","DGDDC",42,0)
1412 ;;.1413
"RTN","DGDDC",43,0)
213 ;;.214^.215
"RTN","DGDDC",44,0)
214 ;;.215
"RTN","DGDDC",45,0)
2193 ;;.2194^.2195
"RTN","DGDDC",46,0)
2194 ;;.2195
"RTN","DGDDC",47,0)
252 ;;.253^.254
"RTN","DGDDC",48,0)
253 ;;.254
"RTN","DGDDC",49,0)
3113 ;;.3114^.3115
"RTN","DGDDC",50,0)
3114 ;;.3115
"RTN","DGDDC",51,0)
3313 ;;.3314^.3315
"RTN","DGDDC",52,0)
3314 ;;.3315
"RTN","DGDDC",53,0)
333 ;;.334^.335
"RTN","DGDDC",54,0)
334 ;;.335
"RTN","DGDDC",55,0)
343 ;;.344^.345
"RTN","DGDDC",56,0)
344 ;;.345
"RTN","DGDDC",57,0)
361 ;;.3611
"RTN","DGENOEIF")
0^28^B14972188
"RTN","DGENOEIF",1,0)
DGENOEIF ;ALB/TMK - OEF/OIF Conflict - Retrieve Data; OCT-17-2005
"RTN","DGENOEIF",2,0)
 ;;5.3;Registration;**673**;Aug 13,1993
"RTN","DGENOEIF",3,0)
 ;
"RTN","DGENOEIF",4,0)
GET(DFN,DGOEIF,SORT,IGNORE,LOCK) ;
"RTN","DGENOEIF",5,0)
 ;Description: Get OEF/OIF conflict information for a patient
"RTN","DGENOEIF",6,0)
 ;Input:
"RTN","DGENOEIF",7,0)
 ;  DFN - Patient IEN
"RTN","DGENOEIF",8,0)
 ;  SORT - 1 to return array by location, 0 to return array by item
"RTN","DGENOEIF",9,0)
 ;       - 2 to return array by location and date
"RTN","DGENOEIF",10,0)
 ;  IGNORE - ien of 2.3215 sub-node ien to ignore
"RTN","DGENOEIF",11,0)
 ;  LOCK = 1 to ignore 'locked' entries
"RTN","DGENOEIF",12,0)
 ;Output:     
"RTN","DGENOEIF",13,0)
 ;  DGOEIF - the OEF/OIF conflict array, passed by reference
"RTN","DGENOEIF",14,0)
 ;   subscripts:
"RTN","DGENOEIF",15,0)
 ;   "COUNT"    Total # of entries in the multiple
"RTN","DGENOEIF",16,0)
 ;   "LAST"     The latest episode 'TO' date ^ related OEF/OIF/ UNKNOWN
"RTN","DGENOEIF",17,0)
 ;                 OEF/OIF code (1,2,3,4)^ien of multiple entry ^
"RTN","DGENOEIF",18,0)
 ;                 'FROM' date
"RTN","DGENOEIF",19,0)
 ;
"RTN","DGENOEIF",20,0)
 ;  For each entry in the multiple if SORT=0 (n is sequence of the item)
"RTN","DGENOEIF",21,0)
 ;   "LOC",n      Conflict Location
"RTN","DGENOEIF",22,0)
 ;   "FR",n       From Date
"RTN","DGENOEIF",23,0)
 ;   "TO",n       To Date
"RTN","DGENOEIF",24,0)
 ;   "LOCK",n     Locked Flag
"RTN","DGENOEIF",25,0)
 ;   "SITE",n     Data Source if from site
"RTN","DGENOEIF",26,0)
 ;   "IEN",n      IEN of the multiple entry
"RTN","DGENOEIF",27,0)
 ;
"RTN","DGENOEIF",28,0)
 ;  For each entry in the multiple if SORT=1 (n is the instance of the
"RTN","DGENOEIF",29,0)
 ;    item within the conflict)
"RTN","DGENOEIF",30,0)
 ;  For each entry in the multiple if SORT=2 (n is the from date of the
"RTN","DGENOEIF",31,0)
 ;    item)
"RTN","DGENOEIF",32,0)
 ;  "OEF",n,"LOC"   "OIF",n,"LOC"    "UNK",n,"LOC"   Conflict Location
"RTN","DGENOEIF",33,0)
 ;  "OEF",n,"FR"    "OIF",n,"FR"     "UNK",n,"FR"    From Date
"RTN","DGENOEIF",34,0)
 ;  "OEF",n,"TO"    "OIF",n,"TO"     "UNK",n,"TO"    To Date
"RTN","DGENOEIF",35,0)
 ;  "OEF",n,"LOCK"  "OIF",n,"LOCK"   "UNK",n,"LOCK"  Locked Flag
"RTN","DGENOEIF",36,0)
 ;  "OEF",n,"SITE"  "OIF",n,"SITE"   "UNK",n,"SITE"  Site source of data
"RTN","DGENOEIF",37,0)
 ;  "OEF",n,"IEN"   "OIF",n,"IEN"    "UNK",n,"IEN"   ien of entry
"RTN","DGENOEIF",38,0)
 ;  "OEF","COUNT"   "OIF","COUNT"    "UNK","COUNT"   # of episodes found
"RTN","DGENOEIF",39,0)
 ;
"RTN","DGENOEIF",40,0)
 N DGLOC,ITEM,SIEN,SIEN0,LAST,CT,X,I
"RTN","DGENOEIF",41,0)
 K DGOEIF S DGOEIF("COUNT")=0,SORT=+$G(SORT)
"RTN","DGENOEIF",42,0)
 I '$G(DFN) Q "0^0"
"RTN","DGENOEIF",43,0)
 S SIEN=0,(LAST,LAST(0),LAST(1),LAST(2))=""
"RTN","DGENOEIF",44,0)
 F ITEM=1:1 S SIEN=$O(^DPT(DFN,.3215,SIEN)) Q:'SIEN  S SIEN0=$G(^(SIEN,0)) I SIEN0'="" D
"RTN","DGENOEIF",45,0)
 . N X1
"RTN","DGENOEIF",46,0)
 . I SIEN=$G(IGNORE)!$S($G(LOCK):$P(SIEN0,U,4),1:0) S ITEM=ITEM-1 Q
"RTN","DGENOEIF",47,0)
 . ; .01 LOCATION OF SERVICE field.
"RTN","DGENOEIF",48,0)
 . S X=$P(SIEN0,U,1),DGLOC=$E($$EXTERNAL^DILFD(2.3215,.01,"",X),1,3)
"RTN","DGENOEIF",49,0)
 . Q:DGLOC=""
"RTN","DGENOEIF",50,0)
 . S CT(DGLOC)=$G(CT(DGLOC))+1
"RTN","DGENOEIF",51,0)
 . S X1=$S(SORT=1:CT(DGLOC),SORT=2:+$P(SIEN0,U,2),1:0)
"RTN","DGENOEIF",52,0)
 . I 'SORT S DGOEIF("LOC",ITEM)=X,DGOEIF("IEN",ITEM)=SIEN
"RTN","DGENOEIF",53,0)
 . I SORT S DGOEIF(DGLOC,X1,"LOC")=X,DGOEIF(DGLOC,X1,"IEN")=SIEN
"RTN","DGENOEIF",54,0)
 . ; .02 FROM DATE field.
"RTN","DGENOEIF",55,0)
 . S X=$P(SIEN0,"^",2)
"RTN","DGENOEIF",56,0)
 . I 'SORT S DGOEIF("FR",ITEM)=X
"RTN","DGENOEIF",57,0)
 . I SORT S DGOEIF(DGLOC,X1,"FR")=X
"RTN","DGENOEIF",58,0)
 . ; .03 TO DATE field.
"RTN","DGENOEIF",59,0)
 . S X=$P(SIEN0,"^",3)
"RTN","DGENOEIF",60,0)
 . I 'SORT S DGOEIF("TO",ITEM)=X
"RTN","DGENOEIF",61,0)
 . I SORT S DGOEIF(DGLOC,X1,"TO")=X
"RTN","DGENOEIF",62,0)
 . I X>LAST S LAST=X,LAST(0)=DGLOC,LAST(1)=SIEN,LAST(2)=$P(SIEN0,U,2)
"RTN","DGENOEIF",63,0)
 . ; .04 DATA LOCKED field.
"RTN","DGENOEIF",64,0)
 . S X=$P(SIEN0,"^",4)
"RTN","DGENOEIF",65,0)
 . I 'SORT S DGOEIF("LOCK",ITEM)=X
"RTN","DGENOEIF",66,0)
 . I SORT S DGOEIF(DGLOC,X1,"LOCK")=X
"RTN","DGENOEIF",67,0)
 . S X=$P(SIEN0,"^",6),X=$S(X="":"CEV",1:X)
"RTN","DGENOEIF",68,0)
 . I 'SORT S DGOEIF("SITE",ITEM)=X
"RTN","DGENOEIF",69,0)
 . I SORT S DGOEIF(DGLOC,X1,"SITE")=X
"RTN","DGENOEIF",70,0)
 S DGOEIF("COUNT")=ITEM-1,DGOEIF("LAST")=LAST_U_LAST(0)_U_LAST(1)_U_LAST(2)
"RTN","DGENOEIF",71,0)
 I SORT F I="OEF","OIF","UNK" S DGOEIF(I,"COUNT")=+$G(CT(I))
"RTN","DGENOEIF",72,0)
 Q (+$G(DGOEIF("COUNT"))_"^1")
"RTN","DGENOEIF",73,0)
 ;
"RTN","DGENOEIF",74,0)
UPDLAST(DA,DGX,FUNC) ; Xref code for the last OEF/OIF/ UNKNOWN OEF/OIF
"RTN","DGENOEIF",75,0)
 ;  location from index xref on subfile 2.3215; fields .01,.02,.03
"RTN","DGENOEIF",76,0)
 ; DA = array for iens of file 2.3215 (DA(1)=DFN, DA=ien of 2.3215)
"RTN","DGENOEIF",77,0)
 ; FUNC = 1 for set logic   0 for kill logic  2 for 'reset' logic
"RTN","DGENOEIF",78,0)
 ; DGX  = X1 array (old values) for kill logic
"RTN","DGENOEIF",79,0)
 ;      = X2 array (new values) for set logic
"RTN","DGENOEIF",80,0)
 ;   subscrpts: (1)=to date  (2)=internal conflict code  (3)=from date
"RTN","DGENOEIF",81,0)
 N Z1,Z1O
"RTN","DGENOEIF",82,0)
 Q:'$G(DA)!'$G(DA(1))
"RTN","DGENOEIF",83,0)
 ;
"RTN","DGENOEIF",84,0)
 I FUNC D  ; Set logic
"RTN","DGENOEIF",85,0)
 . Q:'$G(DGX(1))!'$G(DGX(2))!'$G(DGX(3))
"RTN","DGENOEIF",86,0)
 . S Z1O=$$LAST(DA(1),DA) ; Latest one before the new one
"RTN","DGENOEIF",87,0)
 . I Z1O,$P(Z1O,U,2)'="",$P(Z1O,U,3),$P(Z1O,U,4),Z1O<$G(DGX(1)) K ^DPT("ALOEIF",+Z1O,$P(Z1O,U,4),$P(Z1O,U,2),DA(1),$P(Z1O,U,3))
"RTN","DGENOEIF",88,0)
 . Q:DGX(1)<Z1O  ; New one not the latest
"RTN","DGENOEIF",89,0)
 . S DGX("2E")=$E($$EXTERNAL^DILFD(2.3215,.01,"",DGX(2)),1,3)
"RTN","DGENOEIF",90,0)
 . I '$D(^DPT("ALOEIF",DGX(1),DGX(3),DGX("2E"),DA(1),DA)) S ^DPT("ALOEIF",DGX(1),DGX(3),DGX("2E"),DA(1),DA)="" K DGX("2E")
"RTN","DGENOEIF",91,0)
 ;
"RTN","DGENOEIF",92,0)
 I FUNC=0 D  ; Kill logic
"RTN","DGENOEIF",93,0)
 . Q:'$G(DGX(1))!'$G(DGX(2))!'$G(DGX(3))
"RTN","DGENOEIF",94,0)
 . S DGX("2E")=$E($$EXTERNAL^DILFD(2.3215,.01,"",DGX(2)),1,3)
"RTN","DGENOEIF",95,0)
 . K ^DPT("ALOEIF",DGX(1),DGX(3),DGX("2E"),DA(1),DA) K DGX("2E")
"RTN","DGENOEIF",96,0)
 . ;Reset xref to next latest for pt, if any
"RTN","DGENOEIF",97,0)
 . S Z1=$$LAST(DA(1),DA)
"RTN","DGENOEIF",98,0)
 . Q:'Z1!($P(Z1,U,2)="")!'$P(Z1,U,3)!'$P(Z1,U,4)  ; No latest entry
"RTN","DGENOEIF",99,0)
 . I Z1,'$D(^DPT("ALOEIF",$P(Z1,U),$P(Z1,U,4),$P(Z1,U,2),DA(1),$P(Z1,U,3))) S ^DPT("ALOEIF",$P(Z1,U),$P(Z1,U,4),$P(Z1,U,2),DA(1),$P(Z1,U,3))=""
"RTN","DGENOEIF",100,0)
 ;
"RTN","DGENOEIF",101,0)
 Q
"RTN","DGENOEIF",102,0)
 ;
"RTN","DGENOEIF",103,0)
LAST(DFN,IGNORE) ; Returns latest 'to' date ^ code for location ^
"RTN","DGENOEIF",104,0)
 ;              ien for OEF/OIF/ UNKNOWN OEF/OIF ^ 'from' date
"RTN","DGENOEIF",105,0)
 ; entries in subfile 2.3215
"RTN","DGENOEIF",106,0)
 ; DFN = ien file 2
"RTN","DGENOEIF",107,0)
 ; IGNORE = ien of 2.3215 subfile ien to ignore (used for trigger xref)
"RTN","DGENOEIF",108,0)
 N Z,DGZ
"RTN","DGENOEIF",109,0)
 S Z=$$GET(DFN,.DGZ,0,$G(IGNORE))
"RTN","DGENOEIF",110,0)
 Q $G(DGZ("LAST"))
"RTN","DGENOEIF",111,0)
 ;
"RTN","DGENUPL1")
0^22^B32216917
"RTN","DGENUPL1",1,0)
DGENUPL1 ;ALB/CJM,ISA/KWP - PROCESS INCOMING (Z11 EVENT TYPE) HL7 MESSAGES ; 2/25/02 1:39pm
"RTN","DGENUPL1",2,0)
 ;;5.3;REGISTRATION;**147,222,232,314,397,379,407,363,673**;Aug 13,1993
"RTN","DGENUPL1",3,0)
 ;
"RTN","DGENUPL1",4,0)
 ;
"RTN","DGENUPL1",5,0)
PARSE(MSGIEN,MSGID,CURLINE,ERRCOUNT,DGPAT,DGELG,DGENR,DGCDIS,DGOEIF,DGSEC,DGNTR,DGMST) ;
"RTN","DGENUPL1",6,0)
 ;Description:  This function parses the HL7 segments.  It creates arrays
"RTN","DGENUPL1",7,0)
 ;defined by the PATIENT, ENROLLMENT, ELIGIBILY, CATASTROPHIC DISABILITY,
"RTN","DGENUPL1",8,0)
 ;OEF/OIF CONFLICT objects.
"RTN","DGENUPL1",9,0)
 ;Field values are put in DHCP format and the validity at the
"RTN","DGENUPL1",10,0)
 ;field level is tested.  Fields to be deleted are set to "@".
"RTN","DGENUPL1",11,0)
 ;
"RTN","DGENUPL1",12,0)
 ;Input:
"RTN","DGENUPL1",13,0)
 ;  MSGIEN - the ien of the HL7 message in the HL7 MESSAGE TEXT file (772)
"RTN","DGENUPL1",14,0)
 ;  MSGID -message control id of HL7 msg in the MSH segment
"RTN","DGENUPL1",15,0)
 ;  CURLINE - the subscript of the PID segment of the current message (pass by reference)
"RTN","DGENUPL1",16,0)
 ;  ERRCOUNT - is a count of the number of messages in the batch that can not be processed (pass by ref)
"RTN","DGENUPL1",17,0)
 ;
"RTN","DGENUPL1",18,0)
 ;Output:
"RTN","DGENUPL1",19,0)
 ;  Function Value: Returns 1 on success, 0 on failure.
"RTN","DGENUPL1",20,0)
 ;  CURLINE - upon leaving the procedure this parameter should be set to the end of the current message.
"RTN","DGENUPL1",21,0)
 ;  ERRCOUNT - set to count of messages that were not processed due to errors encountered. (pass by ref)
"RTN","DGENUPL1",22,0)
 ;  DGPAT - array defined by the PATIENT object. (pass by ref)
"RTN","DGENUPL1",23,0)
 ;  DGENR - array defined by the PATIENT ENROLLMENT object. (pass by ref)
"RTN","DGENUPL1",24,0)
 ;  DGELG - array defined by the PATIENT ELIGIBILITY object. (pass by ref)
"RTN","DGENUPL1",25,0)
 ;  DGCDIS - array defined by the CATASTROPHIC DISABILITY object. (pass by ref)
"RTN","DGENUPL1",26,0)
 ;  DGSEC - array defined by the PATIENT SECURITY object. (pass by ref)
"RTN","DGENUPL1",27,0)
 ;  DGOEIF - array defined by the OEF/OIF CONFLICT object.  (pass by ref)
"RTN","DGENUPL1",28,0)
 ;  DGNTR - array defined for NTR data.
"RTN","DGENUPL1",29,0)
 ;  DGMST - array defined for MST data.
"RTN","DGENUPL1",30,0)
 N SEG,ERROR,COUNT
"RTN","DGENUPL1",31,0)
 ;
"RTN","DGENUPL1",32,0)
 K DGEN,DGPAT,DGELG,DGCDIS,DGNTR,DGMST
"RTN","DGENUPL1",33,0)
 ;
"RTN","DGENUPL1",34,0)
 S ERROR=0
"RTN","DGENUPL1",35,0)
 F SEG="PID","ZPD","ZIE","ZEL" D  Q:ERROR
"RTN","DGENUPL1",36,0)
 .D NXTSEG^DGENUPL(MSGIEN,.CURLINE,.SEG)
"RTN","DGENUPL1",37,0)
 .I SEG("TYPE")=SEG D
"RTN","DGENUPL1",38,0)
 ..D:(SEG'="ZEL") @SEG^DGENUPL2
"RTN","DGENUPL1",39,0)
 ..D:(SEG="ZEL") ZEL^DGENUPL2(1)
"RTN","DGENUPL1",40,0)
 .E  D
"RTN","DGENUPL1",41,0)
 ..D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),SEG_" SEGMENT MISSING OR OUT OF ORDER",.ERRCOUNT)
"RTN","DGENUPL1",42,0)
 ..S ERROR=1
"RTN","DGENUPL1",43,0)
 ..;
"RTN","DGENUPL1",44,0)
 ..;possible that in a bad message we are now past the end
"RTN","DGENUPL1",45,0)
 ..S CURLINE=CURLINE-1
"RTN","DGENUPL1",46,0)
 ;
"RTN","DGENUPL1",47,0)
 I 'ERROR F COUNT=2:1 D NXTSEG^DGENUPL(MSGIEN,CURLINE,.SEG) Q:(SEG("TYPE")'="ZEL")  D  Q:ERROR
"RTN","DGENUPL1",48,0)
 .S CURLINE=CURLINE+1
"RTN","DGENUPL1",49,0)
 .D ZEL^DGENUPL2(COUNT)
"RTN","DGENUPL1",50,0)
 ;Phase II Add the capability to accept more than 1 ZCD
"RTN","DGENUPL1",51,0)
 I 'ERROR F SEG="ZEN","ZMT","ZCD" D  Q:ERROR
"RTN","DGENUPL1",52,0)
 .D NXTSEG^DGENUPL(MSGIEN,.CURLINE,.SEG)
"RTN","DGENUPL1",53,0)
 .I SEG("TYPE")=SEG D
"RTN","DGENUPL1",54,0)
 ..D @SEG^DGENUPL2
"RTN","DGENUPL1",55,0)
 .E  D
"RTN","DGENUPL1",56,0)
 ..D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),SEG_" SEGMENT MISSING OR OUTOF ORDER",.ERRCOUNT)
"RTN","DGENUPL1",57,0)
 ..S ERROR=1
"RTN","DGENUPL1",58,0)
 ..;
"RTN","DGENUPL1",59,0)
 ..;possible that in a bad message we are now past the end
"RTN","DGENUPL1",60,0)
 ..S CURLINE=CURLINE-1
"RTN","DGENUPL1",61,0)
 ;
"RTN","DGENUPL1",62,0)
 I 'ERROR F COUNT=2:1 D NXTSEG^DGENUPL(MSGIEN,CURLINE,.SEG) Q:(SEG("TYPE")'="ZCD")  D  Q:ERROR
"RTN","DGENUPL1",63,0)
 .S CURLINE=CURLINE+1
"RTN","DGENUPL1",64,0)
 .D ZCD^DGENUPL2
"RTN","DGENUPL1",65,0)
 ;
"RTN","DGENUPL1",66,0)
 ; Purple Heart/OEF-OIF  Addition of optional ZMH segment
"RTN","DGENUPL1",67,0)
 ;              Modified handling of ZSP and ZRD to accomodate ZMH
"RTN","DGENUPL1",68,0)
 ;
"RTN","DGENUPL1",69,0)
 I 'ERROR D  Q:ERROR $S(ERROR:0,1:1)
"RTN","DGENUPL1",70,0)
 .D NXTSEG^DGENUPL(MSGIEN,.CURLINE,.SEG)
"RTN","DGENUPL1",71,0)
 .I SEG("TYPE")="ZSP" D ZSP^DGENUPL2 Q
"RTN","DGENUPL1",72,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),SEG_" SEGMENT MISSING OR OUT OF ORDER",.ERRCOUNT)
"RTN","DGENUPL1",73,0)
 .S ERROR=1
"RTN","DGENUPL1",74,0)
 .;possible that in a bad message we are now past the end
"RTN","DGENUPL1",75,0)
 .S CURLINE=CURLINE-1
"RTN","DGENUPL1",76,0)
 ;
"RTN","DGENUPL1",77,0)
 I 'ERROR D  Q:ERROR $S(ERROR:0,1:1)
"RTN","DGENUPL1",78,0)
 .D NXTSEG^DGENUPL(MSGIEN,.CURLINE,.SEG)
"RTN","DGENUPL1",79,0)
 .I SEG("TYPE")="ZMH" D
"RTN","DGENUPL1",80,0)
 .. F  D ZMH^DGENUPL2,NXTSEG^DGENUPL(MSGIEN,.CURLINE,.SEG) Q:SEG("TYPE")'="ZMH"
"RTN","DGENUPL1",81,0)
 .I SEG("TYPE")="ZRD" D ZRD^DGENUPL2 Q 
"RTN","DGENUPL1",82,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),SEG_" SEGMENT MISSING OR OUT OF ORDER",.ERRCOUNT)
"RTN","DGENUPL1",83,0)
 .S ERROR=1
"RTN","DGENUPL1",84,0)
 .;possible that in a bad message we are now past the end
"RTN","DGENUPL1",85,0)
 .S CURLINE=CURLINE-1
"RTN","DGENUPL1",86,0)
 ;
"RTN","DGENUPL1",87,0)
 I 'ERROR F COUNT=2:1 D NXTSEG^DGENUPL(MSGIEN,CURLINE,.SEG) Q:(SEG("TYPE")'="ZRD")  D  Q:ERROR
"RTN","DGENUPL1",88,0)
 .S CURLINE=CURLINE+1
"RTN","DGENUPL1",89,0)
 .D ZRD^DGENUPL2
"RTN","DGENUPL1",90,0)
 ;
"RTN","DGENUPL1",91,0)
 I 'ERROR F  D  Q:(ERROR!(SEG("TYPE")'="OBX"))
"RTN","DGENUPL1",92,0)
 .;possible if OBX segment not present that we are now past the end
"RTN","DGENUPL1",93,0)
 .I SEG("TYPE")'="OBX" S CURLINE=CURLINE-1 Q
"RTN","DGENUPL1",94,0)
 .D OBX^DGENUPL2
"RTN","DGENUPL1",95,0)
 .S CURLINE=CURLINE+1
"RTN","DGENUPL1",96,0)
 .D NXTSEG^DGENUPL(MSGIEN,CURLINE,.SEG)
"RTN","DGENUPL1",97,0)
 ;
"RTN","DGENUPL1",98,0)
 Q $S(ERROR:0,1:1)
"RTN","DGENUPL1",99,0)
 ;
"RTN","DGENUPL1",100,0)
CONVERT(VAL,DATATYPE,ERROR) ;
"RTN","DGENUPL1",101,0)
 ;Description: Converts the value found in the HL7 segment to DHCP format
"RTN","DGENUPL1",102,0)
 ;
"RTN","DGENUPL1",103,0)
 ;Input:
"RTN","DGENUPL1",104,0)
 ;  VAL - value parsed from the HL7 segment
"RTN","DGENUPL1",105,0)
 ;  DATATYPE: indicates the type of conversion necessary
"RTN","DGENUPL1",106,0)
 ;      "DATE" - needs to be converted to FM format
"RTN","DGENUPL1",107,0)
 ;      "TS" - time stamp, needs to be converted to FM format
"RTN","DGENUPL1",108,0)
 ;      "Y/N" - 0->"N",1->"Y"
"RTN","DGENUPL1",109,0)
 ;      "1/0" - "Y"->1,"N"->0
"RTN","DGENUPL1",110,0)
 ;      "INSTITUTION" - needs to convert the station number with suffix to a point to the INSTITUTION file
"RTN","DGENUPL1",111,0)
 ;      "ELIGIBILITY" - VAL is a pointer to the national eligibility code file (#8.1), needs to be converted to a local eligibility code (file #8)
"RTN","DGENUPL1",112,0)
 ;
"RTN","DGENUPL1",113,0)
 ;      "MT" - VAL  is a Means Test Status code, it needs to be converted
"RTN","DGENUPL1",114,0)
 ;             to a pointer to the Means Test Status file
"RTN","DGENUPL1",115,0)
 ;       Phase II convert code to RSN IEN for DGCDIS object
"RTN","DGENUPL1",116,0)
 ;       "CDRSN" data type converts the codes diagnosis,procedure,condition to RSN IEN. (HL7TORSN^DGENA5)
"RTN","DGENUPL1",117,0)
 ;       "EXT" convert from code to abbreviation
"RTN","DGENUPL1",118,0)
 ;OUTPUT:
"RTN","DGENUPL1",119,0)
 ;  Function Value - the result of the conversion
"RTN","DGENUPL1",120,0)
 ;  ERROR - set to 1 if an error is detected, 0 otherwise (optional,pass by ref)
"RTN","DGENUPL1",121,0)
 ;
"RTN","DGENUPL1",122,0)
 S ERROR=0
"RTN","DGENUPL1",123,0)
 D
"RTN","DGENUPL1",124,0)
 .I VAL="" Q
"RTN","DGENUPL1",125,0)
 .I VAL="""""" S VAL="@" Q
"RTN","DGENUPL1",126,0)
 .I $G(DATATYPE)="EXT" D  Q
"RTN","DGENUPL1",127,0)
 ..S VAL=$$HLTOLIMB^DGENA5(VAL)
"RTN","DGENUPL1",128,0)
 .I $G(DATATYPE)="CDRSN" D  Q
"RTN","DGENUPL1",129,0)
 ..S VAL=$$HL7TORSN^DGENA5(VAL)
"RTN","DGENUPL1",130,0)
 .I ($G(DATATYPE)="MT") D  Q
"RTN","DGENUPL1",131,0)
 ..S VAL=$O(^DG(408.32,"AC",1,VAL,0))
"RTN","DGENUPL1",132,0)
 ..I 'VAL S ERROR=1
"RTN","DGENUPL1",133,0)
 .I ($G(DATATYPE)="DATE") D  Q
"RTN","DGENUPL1",134,0)
 ..I $L(VAL)'=8 S ERROR=1 Q
"RTN","DGENUPL1",135,0)
 ..S VAL=$$FMDATE^HLFNC(VAL)
"RTN","DGENUPL1",136,0)
 ..I ((VAL'=+VAL)!($L($P(VAL,"."))<7)) S ERROR=1
"RTN","DGENUPL1",137,0)
 .I ($G(DATATYPE)="TS") D  Q
"RTN","DGENUPL1",138,0)
 ..I $L(VAL)<8 S ERROR=1 Q
"RTN","DGENUPL1",139,0)
 ..S VAL=$$FMDATE^HLFNC(VAL)
"RTN","DGENUPL1",140,0)
 ..I ((VAL'=+VAL)!($L($P(VAL,"."))<7)) S ERROR=1
"RTN","DGENUPL1",141,0)
 .I ($G(DATATYPE)="Y/N") D  Q
"RTN","DGENUPL1",142,0)
 ..I VAL=0 S VAL="N" Q
"RTN","DGENUPL1",143,0)
 ..I VAL=1 S VAL="Y" Q
"RTN","DGENUPL1",144,0)
 ..S ERROR=1
"RTN","DGENUPL1",145,0)
 .I ($G(DATATYPE)="1/0") D  Q
"RTN","DGENUPL1",146,0)
 ..I VAL="N" S VAL=0 Q
"RTN","DGENUPL1",147,0)
 ..I VAL="Y" S VAL=1 Q
"RTN","DGENUPL1",148,0)
 ..S ERROR=1
"RTN","DGENUPL1",149,0)
 .I ($G(DATATYPE)="ELIGIBILITY") D  Q
"RTN","DGENUPL1",150,0)
 ..S VAL=$$MAP(VAL)
"RTN","DGENUPL1",151,0)
 ..I 'VAL S ERROR=1
"RTN","DGENUPL1",152,0)
 .I ($G(DATATYPE)="INSTITUTION") D  Q
"RTN","DGENUPL1",153,0)
 ..N OLDVAL
"RTN","DGENUPL1",154,0)
 ..S OLDVAL=VAL
"RTN","DGENUPL1",155,0)
 ..S VAL=$O(^DIC(4,"D",OLDVAL,0))
"RTN","DGENUPL1",156,0)
 ..I 'VAL S VAL=$O(^DIC(4,"D",(+OLDVAL),0))
"RTN","DGENUPL1",157,0)
 ..I 'VAL S ERROR=1
"RTN","DGENUPL1",158,0)
 Q VAL
"RTN","DGENUPL1",159,0)
 ;
"RTN","DGENUPL1",160,0)
MAP(VALUE) ;
"RTN","DGENUPL1",161,0)
 ;Description: Tries to map an eligibility code from file #8.1 (the national MAS ELIGIBILITY CODE file) to file #8 (the local ELIGIBILITY CODE file)
"RTN","DGENUPL1",162,0)
 ;
"RTN","DGENUPL1",163,0)
 ;Input: VALUE - ien of an entry in file #8.1
"RTN","DGENUPL1",164,0)
 ;
"RTN","DGENUPL1",165,0)
 ;Output: Function value - NULL if mapping is not found, otherwise returns an ien of entry in file #8
"RTN","DGENUPL1",166,0)
 ;
"RTN","DGENUPL1",167,0)
 N ECODE,NODE,COUNT,NAME
"RTN","DGENUPL1",168,0)
 ;try to choose a code from file 8 to use that is appropriate
"RTN","DGENUPL1",169,0)
 S (COUNT,ECODE)=0
"RTN","DGENUPL1",170,0)
 ;
"RTN","DGENUPL1",171,0)
 F  S ECODE=$O(^DIC(8,"D",VALUE,ECODE)) Q:'ECODE  D
"RTN","DGENUPL1",172,0)
 .S NODE=$G(^DIC(8,ECODE,0))
"RTN","DGENUPL1",173,0)
 .;put code on list if active
"RTN","DGENUPL1",174,0)
 .I (NODE'=""),'$P(NODE,"^",7) S ECODE(ECODE)=$P(NODE,"^"),COUNT=COUNT+1
"RTN","DGENUPL1",175,0)
 ;
"RTN","DGENUPL1",176,0)
 ;only one match found, so use it
"RTN","DGENUPL1",177,0)
 Q:COUNT=1 $O(ECODE(0))
"RTN","DGENUPL1",178,0)
 ;
"RTN","DGENUPL1",179,0)
 ;no match found
"RTN","DGENUPL1",180,0)
 Q:'COUNT ""
"RTN","DGENUPL1",181,0)
 ;
"RTN","DGENUPL1",182,0)
 ;multiple matches found, try to match by name
"RTN","DGENUPL1",183,0)
 I COUNT>1 D
"RTN","DGENUPL1",184,0)
 .S ECODE=0
"RTN","DGENUPL1",185,0)
 .S NAME=$P($G(^DIC(8.1,VALUE,0)),"^")
"RTN","DGENUPL1",186,0)
 .F  S ECODE=$O(ECODE(ECODE)) Q:'ECODE  Q:ECODE(ECODE)=NAME
"RTN","DGENUPL1",187,0)
 Q ECODE
"RTN","DGENUPL1",188,0)
 ;
"RTN","DGENUPL1",189,0)
ACCEPT(MSGID) ;
"RTN","DGENUPL1",190,0)
 ;Description: Writes an ack (AA) to a global to be transmitted later.
"RTN","DGENUPL1",191,0)
 ;
"RTN","DGENUPL1",192,0)
 ;Inputs:
"RTN","DGENUPL1",193,0)
 ;  MSGID -message control id of HL7 msg in the MSH segment
"RTN","DGENUPL1",194,0)
 ;
"RTN","DGENUPL1",195,0)
 ;Outputs: none
"RTN","DGENUPL1",196,0)
 ;
"RTN","DGENUPL1",197,0)
 K HL,HLMID,HLMTIEN,HLDT,HLDT1
"RTN","DGENUPL1",198,0)
 D INIT^HLFNC2(HLEID,.HL)
"RTN","DGENUPL1",199,0)
 D CREATE^HLTF(.HLMID,.HLMTIEN,.HLDT,.HLDT1)
"RTN","DGENUPL1",200,0)
 S HLEVN=1
"RTN","DGENUPL1",201,0)
 S MID=HLMID_"-"_HLEVN
"RTN","DGENUPL1",202,0)
 D MSH^HLFNC2(.HL,MID,.HLRES)
"RTN","DGENUPL1",203,0)
 S ^TMP("HLS",$J,1)=HLRES
"RTN","DGENUPL1",204,0)
 ;
"RTN","DGENUPL1",205,0)
 ;it seems HLFS sometimes disappears upon reaching this point
"RTN","DGENUPL1",206,0)
 I $G(HLFS)="" S HLFS="^"
"RTN","DGENUPL1",207,0)
 ;
"RTN","DGENUPL1",208,0)
 S ^TMP("HLS",$J,2)="MSA"_HLFS_"AA"_HLFS_MSGID
"RTN","DGENUPL1",209,0)
 Q
"RTN","DGENUPL1",210,0)
 ;
"RTN","DGENUPL1",211,0)
MVERRORS ;
"RTN","DGENUPL1",212,0)
 ;Error messages were being deleted from ^TMP("HLS",$J by another package
"RTN","DGENUPL1",213,0)
 ;during the upload.  To fix this, errors are written to another
"RTN","DGENUPL1",214,0)
 ;subscript, then moved when the error list is complete.
"RTN","DGENUPL1",215,0)
 ;
"RTN","DGENUPL1",216,0)
 M ^TMP("HLS",$J)=^TMP("IVM","HLS",$J)
"RTN","DGENUPL1",217,0)
 K ^TMP("IVM","HLS",$J)
"RTN","DGENUPL1",218,0)
 Q
"RTN","DGENUPL2")
0^15^B66821493
"RTN","DGENUPL2",1,0)
DGENUPL2 ;ALB/CJM,RTK,TMK,ISA/KWP/RMM/CKN,EG - PROCESS INCOMING (Z11 EVENT TYPE) HL7 MESSAGES ; 10/19/05
"RTN","DGENUPL2",2,0)
 ;;5.3;REGISTRATION;**147,222,232,310,314,367,397,677,631,675,672,673**;Aug 13,1993
"RTN","DGENUPL2",3,0)
 ;
"RTN","DGENUPL2",4,0)
 ;**************************************************************
"RTN","DGENUPL2",5,0)
 ;The following procedures parse particular segment types.
"RTN","DGENUPL2",6,0)
 ;Input:SEG(),MSGID
"RTN","DGENUPL2",7,0)
 ;Output:DGPAT(),DGELG(),DGENR(),DGCDIS(),DGNTR(),DGOEIF(),ERROR
"RTN","DGENUPL2",8,0)
 ;**************************************************************
"RTN","DGENUPL2",9,0)
 ;
"RTN","DGENUPL2",10,0)
PID ;
"RTN","DGENUPL2",11,0)
 S DGPAT("SSN")=SEG(19)
"RTN","DGENUPL2",12,0)
 Q
"RTN","DGENUPL2",13,0)
 ;
"RTN","DGENUPL2",14,0)
ZPD ;
"RTN","DGENUPL2",15,0)
 S DGELG("RATEINC")=$$CONVERT^DGENUPL1(SEG(8))
"RTN","DGENUPL2",16,0)
 S DGPAT("DEATH")=$$CONVERT^DGENUPL1(SEG(9),"TS",.ERROR)
"RTN","DGENUPL2",17,0)
 I ERROR D  Q
"RTN","DGENUPL2",18,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZPD SEGMENT, SEQ 9",.ERRCOUNT)
"RTN","DGENUPL2",19,0)
 S DGELG("MEDICAID")=$$CONVERT^DGENUPL1(SEG(12))
"RTN","DGENUPL2",20,0)
 S DGELG("POW")=$$CONVERT^DGENUPL1(SEG(17))
"RTN","DGENUPL2",21,0)
 S DGPAT("EMGRES")=$$CONVERT^DGENUPL1(SEG(40)) ;DG*5.3*677
"RTN","DGENUPL2",22,0)
 Q
"RTN","DGENUPL2",23,0)
 ;
"RTN","DGENUPL2",24,0)
ZIE ;
"RTN","DGENUPL2",25,0)
 S DGPAT("INELDATE")=$$CONVERT^DGENUPL1(SEG(2),"DATE",.ERROR)
"RTN","DGENUPL2",26,0)
 I ERROR D  Q
"RTN","DGENUPL2",27,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZIE SEGMENT, SEQ 2",.ERRCOUNT)
"RTN","DGENUPL2",28,0)
 S DGPAT("INELREA")=$$CONVERT^DGENUPL1(SEG(3))
"RTN","DGENUPL2",29,0)
 S DGPAT("INELDEC")=$$CONVERT^DGENUPL1(SEG(4))
"RTN","DGENUPL2",30,0)
 Q
"RTN","DGENUPL2",31,0)
 ;
"RTN","DGENUPL2",32,0)
ZEL(COUNT) ;
"RTN","DGENUPL2",33,0)
 D ZEL^DGENUPLA(COUNT)  ;code for ZEL segment has moved to DGENUPLA
"RTN","DGENUPL2",34,0)
 Q
"RTN","DGENUPL2",35,0)
 ;
"RTN","DGENUPL2",36,0)
ZEN ;
"RTN","DGENUPL2",37,0)
 N SUB
"RTN","DGENUPL2",38,0)
 S DGENR("DATE")=$$CONVERT^DGENUPL1(SEG(2),"DATE",.ERROR)
"RTN","DGENUPL2",39,0)
 I ERROR D  Q
"RTN","DGENUPL2",40,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZEN SEGMENT, SEQ 2",.ERRCOUNT)
"RTN","DGENUPL2",41,0)
 S DGENR("SOURCE")=$$CONVERT^DGENUPL1(SEG(3))
"RTN","DGENUPL2",42,0)
 S DGENR("STATUS")=$$CONVERT^DGENUPL1(SEG(4))
"RTN","DGENUPL2",43,0)
 S ERROR=$$PEND(DFN,DGENR("STATUS"))
"RTN","DGENUPL2",44,0)
 I ERROR D  Q
"RTN","DGENUPL2",45,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"ENROLLMENT STATUS PENDING-ELIGIBILITY IS VERIFIED",.ERRCOUNT)
"RTN","DGENUPL2",46,0)
 S DGENR("REASON")=$$CONVERT^DGENUPL1(SEG(5))
"RTN","DGENUPL2",47,0)
 S DGENR("REMARKS")=$$CONVERT^DGENUPL1(SEG(6))
"RTN","DGENUPL2",48,0)
 S DGENR("FACREC")=$$CONVERT^DGENUPL1(SEG(7),"INSTITUTION",.ERROR)
"RTN","DGENUPL2",49,0)
 I ERROR D  Q
"RTN","DGENUPL2",50,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"FACILITY RECEIVED "_SEG(7)_" NOT FOUND IN THE INSTITUTION FILE",.ERRCOUNT)
"RTN","DGENUPL2",51,0)
 S DGPAT("PREFAC")=$$CONVERT^DGENUPL1(SEG(8),"INSTITUTION",.ERROR)
"RTN","DGENUPL2",52,0)
 I ERROR D  Q
"RTN","DGENUPL2",53,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"PREFERRED FACILITY "_SEG(8)_" NOT FOUND IN THE INSTITUTION FILE",.ERRCOUNT)
"RTN","DGENUPL2",54,0)
 ;
"RTN","DGENUPL2",55,0)
 S DGENR("PRIORITY")=$$CONVERT^DGENUPL1(SEG(9))
"RTN","DGENUPL2",56,0)
 S DGENR("EFFDATE")=$$CONVERT^DGENUPL1(SEG(10),"DATE",.ERROR)
"RTN","DGENUPL2",57,0)
 I ERROR D  Q
"RTN","DGENUPL2",58,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZEN SEGMENT, SEQ 10",.ERRCOUNT)
"RTN","DGENUPL2",59,0)
 S DGENR("APP")=$$CONVERT^DGENUPL1(SEG(11),"DATE",.ERROR)
"RTN","DGENUPL2",60,0)
 I ERROR D  Q
"RTN","DGENUPL2",61,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZEN SEGMENT, SEQ 11",.ERRCOUNT)
"RTN","DGENUPL2",62,0)
 ;
"RTN","DGENUPL2",63,0)
 ;!!!!!! take next line out when HEC begins transmitting application dt
"RTN","DGENUPL2",64,0)
 I DGENR("APP")="" S DGENR("APP")=DGENR("DATE")
"RTN","DGENUPL2",65,0)
 I DGENR("APP")="" S DGENR("APP")=DGENR("EFFDATE")
"RTN","DGENUPL2",66,0)
 ;
"RTN","DGENUPL2",67,0)
 S DGENR("END")=$$CONVERT^DGENUPL1(SEG(12),"DATE",.ERROR)
"RTN","DGENUPL2",68,0)
 I ERROR D  Q
"RTN","DGENUPL2",69,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZEN SEGMENT, SEQ 12",.ERRCOUNT)
"RTN","DGENUPL2",70,0)
 ;Phase II Parse out Sub-Group (SRS 6.4)
"RTN","DGENUPL2",71,0)
 S DGENR("SUBGRP")=$$CONVERT^DGENUPL1(SEG(13))
"RTN","DGENUPL2",72,0)
 ;
"RTN","DGENUPL2",73,0)
 ;want to ignore double quotes sent for enrollment fields
"RTN","DGENUPL2",74,0)
 S SUB=""
"RTN","DGENUPL2",75,0)
 F  S SUB=$O(DGENR(SUB)) Q:SUB=""  I DGENR(SUB)="@" S DGENR(SUB)=""
"RTN","DGENUPL2",76,0)
 ;
"RTN","DGENUPL2",77,0)
 Q
"RTN","DGENUPL2",78,0)
 ;
"RTN","DGENUPL2",79,0)
ZMT ;
"RTN","DGENUPL2",80,0)
 I SEG(1)>1 D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"ZMT SEGMENT, SEQ 1, SHOULD SPECIFY MEANS TEST",.ERRCOUNT) S ERROR=1 Q
"RTN","DGENUPL2",81,0)
 S DGELG("MTSTA")=$$CONVERT^DGENUPL1(SEG(3),"MT",.ERROR)
"RTN","DGENUPL2",82,0)
 I ERROR D  Q
"RTN","DGENUPL2",83,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZMT SEGMENT, SEQ 3",.ERRCOUNT)
"RTN","DGENUPL2",84,0)
 Q
"RTN","DGENUPL2",85,0)
 ;
"RTN","DGENUPL2",86,0)
ZCD ;
"RTN","DGENUPL2",87,0)
 ;Phase II for multiple ZCD's
"RTN","DGENUPL2",88,0)
 I SEG(1)>1 G SKIP
"RTN","DGENUPL2",89,0)
 S DGCDIS("BY")=$$CONVERT^DGENUPL1(SEG(3))
"RTN","DGENUPL2",90,0)
 S DGCDIS("DATE")=$$CONVERT^DGENUPL1(SEG(5),"DATE",.ERROR)
"RTN","DGENUPL2",91,0)
 I ERROR D  Q
"RTN","DGENUPL2",92,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZCD SEGMENT, SEQ 5",.ERRCOUNT)
"RTN","DGENUPL2",93,0)
 S DGCDIS("FACDET")=$$CONVERT^DGENUPL1(SEG(4),"INSTITUTION",.ERROR)
"RTN","DGENUPL2",94,0)
 I ERROR D  Q
"RTN","DGENUPL2",95,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"FACILITY "_SEG(4)_" MAKING CATASTROPHIC DISABILITY DETERMINATION NOT FOUND IN THE INSTITUTION FILE",.ERRCOUNT)
"RTN","DGENUPL2",96,0)
 S DGCDIS("REVDTE")=$$CONVERT^DGENUPL1(SEG(2),"DATE",.ERROR)
"RTN","DGENUPL2",97,0)
 I ERROR D  Q
"RTN","DGENUPL2",98,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZCD SEGMENT, SEQ 2",.ERRCOUNT)
"RTN","DGENUPL2",99,0)
 S DGCDIS("METDET")=$$CONVERT^DGENUPL1($P(SEG(6),$E(HLECH)))
"RTN","DGENUPL2",100,0)
 S DGCDIS("VCD")=$$CONVERT^DGENUPL1(SEG(12))
"RTN","DGENUPL2",101,0)
SKIP ;
"RTN","DGENUPL2",102,0)
 ;Phase II Parse out additional fields.  CONVERT type of RSN converts the code to IEN for diagnosis,procedure and condition (HL7TORSN^DGENA5).
"RTN","DGENUPL2",103,0)
 S DGCDIS("DIAG",SEG(1))=$$CONVERT^DGENUPL1(SEG(7),"CDRSN")
"RTN","DGENUPL2",104,0)
 S DGCDIS("PROC",SEG(1))=$$CONVERT^DGENUPL1(SEG(8),"CDRSN")
"RTN","DGENUPL2",105,0)
 S DGCDIS("EXT",SEG(1),1)=$$CONVERT^DGENUPL1($P(SEG(9),$E(HLECH)),"EXT")
"RTN","DGENUPL2",106,0)
 S DGCDIS("COND",SEG(1))=$$CONVERT^DGENUPL1(SEG(10),"CDRSN")
"RTN","DGENUPL2",107,0)
 S DGCDIS("SCORE",SEG(1))=$$CONVERT^DGENUPL1($P(SEG(11),$E(HLECH)))
"RTN","DGENUPL2",108,0)
 S DGCDIS("PERM",SEG(1))=$$CONVERT^DGENUPL1($P(SEG(13),$E(HLECH)))
"RTN","DGENUPL2",109,0)
 I DGCDIS("VCD")="Y",'DGCDIS("DIAG",SEG(1)),'DGCDIS("PROC",SEG(1)),'DGCDIS("COND",SEG(1)) D  Q
"RTN","DGENUPL2",110,0)
 .S ERROR=1 D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"NO VALID DIAGNOSIS,PROCEDURE, OR CONDITION IN THE ZCD SEGMENT",.ERRCOUNT)
"RTN","DGENUPL2",111,0)
 Q
"RTN","DGENUPL2",112,0)
 ;
"RTN","DGENUPL2",113,0)
ZSP ;
"RTN","DGENUPL2",114,0)
 S DGELG("SC")=$$CONVERT^DGENUPL1(SEG(2),"Y/N",.ERROR)
"RTN","DGENUPL2",115,0)
 I ERROR D  Q
"RTN","DGENUPL2",116,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZSP SEGMENT, SEQ 2",.ERRCOUNT)
"RTN","DGENUPL2",117,0)
 S DGELG("SCPER")=$$CONVERT^DGENUPL1(SEG(3))
"RTN","DGENUPL2",118,0)
 S DGELG("EFFDT")=$$CONVERT^DGENUPL1(SEG(11),"DATE",.ERROR)
"RTN","DGENUPL2",119,0)
 I ERROR D  Q
"RTN","DGENUPL2",120,0)
 . D ADDERROR^DGENUPL(MSGID,$G(DGELG("EFFDT")),"BAD VALUE, ZSP SEGMENT, SEQ 11",.ERRCOUNT)
"RTN","DGENUPL2",121,0)
 ;if effective date is null, set update value to "@" (delete)
"RTN","DGENUPL2",122,0)
 I DGELG("EFFDT")="" S DGELG("EFFDT")="@"
"RTN","DGENUPL2",123,0)
 ;
"RTN","DGENUPL2",124,0)
 ;added 8/3/98 to reduce #rejects
"RTN","DGENUPL2",125,0)
 ;if HEC sends SC=NO, SC% not sent, and site has value for SC% then delete it
"RTN","DGENUPL2",126,0)
 I DGELG("SC")="N",DGELG("SCPER")="" S DGELG("SCPER")="@"
"RTN","DGENUPL2",127,0)
 ;
"RTN","DGENUPL2",128,0)
 S DGELG("P&T")=$$CONVERT^DGENUPL1(SEG(6),"Y/N",.ERROR)
"RTN","DGENUPL2",129,0)
 I ERROR D  Q
"RTN","DGENUPL2",130,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZSP SEGMENT, SEQ 6",.ERRCOUNT)
"RTN","DGENUPL2",131,0)
 S DGELG("UNEMPLOY")=$$CONVERT^DGENUPL1(SEG(7),"Y/N",.ERROR)
"RTN","DGENUPL2",132,0)
 I ERROR D  Q
"RTN","DGENUPL2",133,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZSP SEGMENT, SEQ 7",.ERRCOUNT)
"RTN","DGENUPL2",134,0)
 S DGELG("SCAWDATE")=$$CONVERT^DGENUPL1(SEG(8),"DATE",.ERROR)
"RTN","DGENUPL2",135,0)
 I ERROR D  Q
"RTN","DGENUPL2",136,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZSP SEGMENT, SEQ 8",.ERRCOUNT)
"RTN","DGENUPL2",137,0)
 Q
"RTN","DGENUPL2",138,0)
 ;
"RTN","DGENUPL2",139,0)
ZMH ; Purple Heart, OEF/OIF Conflict Loc
"RTN","DGENUPL2",140,0)
 ;ONLY PROCESS PH & OEF/OIF FROM ZMH
"RTN","DGENUPL2",141,0)
 Q:$S(SEG(2)="PH":0,SEG(2)="OEIF":0,1:1)
"RTN","DGENUPL2",142,0)
 I SEG(2)="PH" D  Q
"RTN","DGENUPL2",143,0)
 . S DGPAT("PHI")=$P(SEG(3),$E(HLECH))
"RTN","DGENUPL2",144,0)
 . S DGELG("PH")=$$CONVERT^DGENUPL1($P(SEG(3),$E(HLECH)))
"RTN","DGENUPL2",145,0)
 . S DGPAT("PHST")=$P(SEG(3),$E(HLECH),2)
"RTN","DGENUPL2",146,0)
 . S DGPAT("PHRR")=$P(SEG(3),$E(HLECH),3)
"RTN","DGENUPL2",147,0)
 ;
"RTN","DGENUPL2",148,0)
 I SEG(2)="OEIF" D  Q
"RTN","DGENUPL2",149,0)
 . S DGOEIF("COUNT")=$G(DGOEIF("COUNT"))+1
"RTN","DGENUPL2",150,0)
 . S DGOEIF("LOC",DGOEIF("COUNT"))=$E($P(SEG(3),$E(HLECH)),1,3)
"RTN","DGENUPL2",151,0)
 . S DGOEIF("SITE",DGOEIF("COUNT"))=$$CONVERT^DGENUPL1($P(SEG(3),$E(HLECH),2),"INSTITUTION")
"RTN","DGENUPL2",152,0)
 . S DGOEIF("FR",DGOEIF("COUNT"))=$$CONVERT^DGENUPL1($P(SEG(4),$E(HLECH)),"DATE")
"RTN","DGENUPL2",153,0)
 . S DGOEIF("TO",DGOEIF("COUNT"))=$$CONVERT^DGENUPL1($P(SEG(4),$E(HLECH),2),"DATE")
"RTN","DGENUPL2",154,0)
 . S DGOEIF("LOCK")=1
"RTN","DGENUPL2",155,0)
 Q
"RTN","DGENUPL2",156,0)
 ;
"RTN","DGENUPL2",157,0)
ZRD ;
"RTN","DGENUPL2",158,0)
 N COUNT,DXCODE,NAME,COND
"RTN","DGENUPL2",159,0)
 S DXCODE=$P(SEG(2),$E(HLECH))
"RTN","DGENUPL2",160,0)
 I DXCODE="""""" S DXCODE=""
"RTN","DGENUPL2",161,0)
 S NAME=$P(SEG(2),$E(HLECH),2)
"RTN","DGENUPL2",162,0)
 Q:DXCODE=""  ;segment does not contain a disability condition
"RTN","DGENUPL2",163,0)
 ;
"RTN","DGENUPL2",164,0)
 S COUNT=1+(+$G(DGELG("RATEDIS")))
"RTN","DGENUPL2",165,0)
 S (COND,DGELG("RATEDIS",COUNT,"RD"))=$$DCLOOKUP(DXCODE,NAME)
"RTN","DGENUPL2",166,0)
 S DGELG("RATEDIS",COUNT,"PER")=SEG(3),DGELG("RATEDIS")=COUNT
"RTN","DGENUPL2",167,0)
 S DGELG("RATEDIS",COUNT,"RDEXT")=SEG(12)
"RTN","DGENUPL2",168,0)
 S DGELG("RATEDIS",COUNT,"RDORIG")=$$CONVERT^DGENUPL1(SEG(13),"DATE",.ERROR)
"RTN","DGENUPL2",169,0)
 I ERROR D  Q
"RTN","DGENUPL2",170,0)
 . D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZRD SEGMENT, S 13",.ERRCOUNT)
"RTN","DGENUPL2",171,0)
 S DGELG("RATEDIS",COUNT,"RDCURR")=$$CONVERT^DGENUPL1(SEG(14),"DATE",.ERROR)
"RTN","DGENUPL2",172,0)
 I ERROR D  Q
"RTN","DGENUPL2",173,0)
 . D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZRD SEGMENT, S 14",.ERRCOUNT)
"RTN","DGENUPL2",174,0)
 I 'COND D  Q
"RTN","DGENUPL2",175,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),"BAD VALUE, ZRD SEGMENT, SEQ 2 - DISABILTY CONDITION LOOKUP FAILED",.ERRCOUNT)
"RTN","DGENUPL2",176,0)
 .S ERROR=1
"RTN","DGENUPL2",177,0)
 Q
"RTN","DGENUPL2",178,0)
OBX ;
"RTN","DGENUPL2",179,0)
 D OBX^DGENUPLA  ;code for OBX segment moved to DGENUPLA
"RTN","DGENUPL2",180,0)
 Q
"RTN","DGENUPL2",181,0)
 ;
"RTN","DGENUPL2",182,0)
 ;*********** end of segment parsers ****
"RTN","DGENUPL2",183,0)
 ;
"RTN","DGENUPL2",184,0)
DCLOOKUP(DGCODE,DGNAME) ;
"RTN","DGENUPL2",185,0)
 ;Returns: ien of a Disability Condition (file #31) based on the DGCODE and DGNAME
"RTN","DGENUPL2",186,0)
 ;
"RTN","DGENUPL2",187,0)
 ;Input:
"RTN","DGENUPL2",188,0)
 ;  DGCODE - DX Code of the Disability Condition
"RTN","DGENUPL2",189,0)
 ;  DGNAME - name of the Disability Condition
"RTN","DGENUPL2",190,0)
 ;Output:
"RTN","DGENUPL2",191,0)
 ;  Function Value: ien of the entry found, or 0 otherwise
"RTN","DGENUPL2",192,0)
 ;
"RTN","DGENUPL2",193,0)
 Q:(DGCODE="") 0
"RTN","DGENUPL2",194,0)
 N NODE,IEN,FOUND
"RTN","DGENUPL2",195,0)
 S (FOUND,IEN)=0
"RTN","DGENUPL2",196,0)
 F  S IEN=$O(^DIC(31,"C",DGCODE,IEN)) Q:'IEN  D  Q:FOUND
"RTN","DGENUPL2",197,0)
 .S NODE=$G(^DIC(31,IEN,0))
"RTN","DGENUPL2",198,0)
 .I DGNAME=$P(NODE,"^"),DGCODE=$P(NODE,"^",3) S FOUND=1
"RTN","DGENUPL2",199,0)
 I 'FOUND S IEN=$O(^DIC(31,"C",DGCODE,0))
"RTN","DGENUPL2",200,0)
 Q +IEN
"RTN","DGENUPL2",201,0)
 ;
"RTN","DGENUPL2",202,0)
REGCHECK(DFN) ;
"RTN","DGENUPL2",203,0)
 ;Passes patient through the registration consistency checker
"RTN","DGENUPL2",204,0)
 ;Input -
"RTN","DGENUPL2",205,0)
 ;  DFN - pointer to the Patient File
"RTN","DGENUPL2",206,0)
 ;
"RTN","DGENUPL2",207,0)
 N DGCD,DGCHK,DGDAY,DGEDCN,DGER,DGLST,DGNCK,DGRPCOLD,DGSC,DGTYPE,DGVT,VA,X
"RTN","DGENUPL2",208,0)
 ;
"RTN","DGENUPL2",209,0)
 S DGEDCN=0
"RTN","DGENUPL2",210,0)
 D ^DGRPC
"RTN","DGENUPL2",211,0)
 Q
"RTN","DGENUPL2",212,0)
PEND(DFN,DGSTAT) ;
"RTN","DGENUPL2",213,0)
 N DGARR,DGEC,DGERR,DGX
"RTN","DGENUPL2",214,0)
 I $P($G(^DPT(DFN,.361)),U)'="V" Q 0
"RTN","DGENUPL2",215,0)
 I $G(DGSTAT)']"" Q 0
"RTN","DGENUPL2",216,0)
 S DGSTAT="^"_DGSTAT_"^"
"RTN","DGENUPL2",217,0)
 Q:"^15^17^"'[DGSTAT 0
"RTN","DGENUPL2",218,0)
 D GETS^DIQ(2,DFN_",",".301;.302;.361;.36295","IE","DGARR","DGERR")
"RTN","DGENUPL2",219,0)
 I $D(DGERR) Q 0
"RTN","DGENUPL2",220,0)
 S DGEC=$G(DGARR(2,DFN_",",.361,"E"))
"RTN","DGENUPL2",221,0)
 I $G(DGEC)']"" Q 0
"RTN","DGENUPL2",222,0)
 I DGEC="NSC" Q 1
"RTN","DGENUPL2",223,0)
 I DGEC="SC LESS THAN 50%" D  Q DGX
"RTN","DGENUPL2",224,0)
 . S DGX=1
"RTN","DGENUPL2",225,0)
 . I $G(DGARR(2,DFN_",",.301,"I"))'="Y" S DGX=0 Q
"RTN","DGENUPL2",226,0)
 . I +$G(DGARR(2,DFN_",",.302,"I"))>0 S DGX=0 Q
"RTN","DGENUPL2",227,0)
 . I +$G(DGARR(2,DFN_",",.36295,"I"))>0 S DGX=0 Q
"RTN","DGENUPL2",228,0)
 Q 0
"RTN","DGENUPL4")
0^16^B66292292
"RTN","DGENUPL4",1,0)
DGENUPL4 ;ALB/CJM,RTK,ISA/KWP,ISD/GSN,PHH,RGL,PJR,BRM,TDM,TMK - PROCESS INCOMING (Z11 EVENT TYPE) HL7 MESSAGES ; 10/19/05
"RTN","DGENUPL4",2,0)
 ;;5.3;REGISTRATION;**147,177,232,253,327,367,377,514,451,625,673**;Aug 13,1993
"RTN","DGENUPL4",3,0)
 ;
"RTN","DGENUPL4",4,0)
UOBJECTS(DFN,DGPAT,DGELG,DGCDIS,DGOEIF,MSGID,ERRCOUNT,MSGS,OLDPAT,OLDELG,OLDCDIS,OLDOEIF) ;
"RTN","DGENUPL4",5,0)
 ;Used to update PATIENT, ELIGIBILITY, CATASTROPHIC
"RTN","DGENUPL4",6,0)
 ;DISABILITY, and OEF/OIF CONFLICT objects 'in memory'.
"RTN","DGENUPL4",7,0)
 ;
"RTN","DGENUPL4",8,0)
 ;Input:
"RTN","DGENUPL4",9,0)
 ;  DFN - ien of record in the PATIENT file
"RTN","DGENUPL4",10,0)
 ;  DGPAT - PATIENT object array (pass by reference)
"RTN","DGENUPL4",11,0)
 ;  DGELG - ELIGIBILITY object array (pass by ref)
"RTN","DGENUPL4",12,0)
 ;  DGCDIS - CATASTROPHIC DISABILITY object array (pass by ref)
"RTN","DGENUPL4",13,0)
 ;  DGOEIF - OEF/OIF conflict object array (pass by ref)
"RTN","DGENUPL4",14,0)
 ;  MSGID - message control id of the HL7 message being processed
"RTN","DGENUPL4",15,0)
 ;  ERRCOUNT - count of errors (pass by ref)
"RTN","DGENUPL4",16,0)
 ;  MSGS - array of messages for the site (pass by ref)
"RTN","DGENUPL4",17,0)
 ;
"RTN","DGENUPL4",18,0)
 ;Output:
"RTN","DGENUPL4",19,0)
 ;  Function Value: 1 if update was successful 'in memory',
"RTN","DGENUPL4",20,0)
 ;           consistency checks pass and the objects can be stored in
"RTN","DGENUPL4",21,0)
 ;           the local database, 0 otherwise.
"RTN","DGENUPL4",22,0)
 ;  DGPAT - PATIENT object array (pass by reference)
"RTN","DGENUPL4",23,0)
 ;  DGELG - ELIGIBILITY object array (pass by ref)
"RTN","DGENUPL4",24,0)
 ;  DGCDIS - CATASTROPHIC DISABILITY object array (pass by ref)
"RTN","DGENUPL4",25,0)
 ;  ERRCOUNT - count of errors (pass by ref)
"RTN","DGENUPL4",26,0)
 ;  MSGS - array of messages for the site (pass by ref)
"RTN","DGENUPL4",27,0)
 ;  OLDPAT - patient object array as it currently exists in database before the update (pass by ref)
"RTN","DGENUPL4",28,0)
 ;  OLDELG - eligibility object array as it currently exists in database before the update (pass by ref)
"RTN","DGENUPL4",29,0)
 ;  OLDCDIS - catastrophically disability object array as it currently exists in database before the update (pass by ref)
"RTN","DGENUPL4",30,0)
 ;  OLDOEIF - OEF/OIF conflict data as it currently exists in database before the update (pass by ref)
"RTN","DGENUPL4",31,0)
 ;
"RTN","DGENUPL4",32,0)
 N DGPAT3,DGELG3,DGCDIS3,SUCCESS
"RTN","DGENUPL4",33,0)
 S SUCCESS=1
"RTN","DGENUPL4",34,0)
 D
"RTN","DGENUPL4",35,0)
 .;first get local site's current data
"RTN","DGENUPL4",36,0)
 .I ('$$GET^DGENPTA(DFN,.OLDPAT))!('$$GET^DGENELA(DFN,.OLDELG))!('$$GET^DGENCDA(DFN,.OLDCDIS))!('$P($$GET^DGENOEIF(DFN,.OLDOEIF,0),U,2)) D  Q
"RTN","DGENUPL4",37,0)
 ..D ADDERROR^DGENUPL(MSGID,DGPAT("SSN"),"UNABLE TO ACCESS PATIENT RECORD",.ERRCOUNT)
"RTN","DGENUPL4",38,0)
 ..S SUCCESS=0
"RTN","DGENUPL4",39,0)
 .;
"RTN","DGENUPL4",40,0)
 .;Phase II CD Consistency Checks (SRS 6.5.1.4) check VISTA against HEC
"RTN","DGENUPL4",41,0)
 .S SUCCESS=$$CDCHECK^DGENUPL9()
"RTN","DGENUPL4",42,0)
 .Q:'SUCCESS
"RTN","DGENUPL4",43,0)
 .;
"RTN","DGENUPL4",44,0)
 .;now merge with the update
"RTN","DGENUPL4",45,0)
 .D MERGE
"RTN","DGENUPL4",46,0)
 .;
"RTN","DGENUPL4",47,0)
 .;add the assumed values
"RTN","DGENUPL4",48,0)
 .D ADD
"RTN","DGENUPL4",49,0)
 .;
"RTN","DGENUPL4",50,0)
 .;now do the consistency checks
"RTN","DGENUPL4",51,0)
 .S SUCCESS=$$CHECK()
"RTN","DGENUPL4",52,0)
 .Q:'SUCCESS
"RTN","DGENUPL4",53,0)
 .;
"RTN","DGENUPL4",54,0)
 .;replace input arrays with fully updated versions
"RTN","DGENUPL4",55,0)
 .K DGPAT M DGPAT=DGPAT3
"RTN","DGENUPL4",56,0)
 .K DGELG M DGELG=DGELG3
"RTN","DGENUPL4",57,0)
 .K DGCDIS M DGCDIS=DGCDIS3
"RTN","DGENUPL4",58,0)
 ;
"RTN","DGENUPL4",59,0)
 I SUCCESS D
"RTN","DGENUPL4",60,0)
 .;
"RTN","DGENUPL4",61,0)
 .;list of required notifications
"RTN","DGENUPL4",62,0)
 .;
"RTN","DGENUPL4",63,0)
 .;change in date of death
"RTN","DGENUPL4",64,0)
 .I DGPAT("DEATH"),$P(OLDPAT("DEATH"),".")'=$P(DGPAT("DEATH"),".") D
"RTN","DGENUPL4",65,0)
 ..D ADDMSG^DGENUPL3(.MSGS,"HEC SHOWS DATE OF DEATH = "_$$FMTE^XLFDT(DGPAT("DEATH"),"1"),1)
"RTN","DGENUPL4",66,0)
 ..D ADDMSG^DGENUPL3(.MSGS,$S('OLDPAT("DEATH"):"SITE DOES NOT HAVE DATE OF DEATH",1:"SITE HAS DATE OF DEATH = "_$$FMTE^XLFDT(OLDPAT("DEATH"),"1")),1)
"RTN","DGENUPL4",67,0)
 .;
"RTN","DGENUPL4",68,0)
 .I OLDPAT("DEATH"),'DGPAT("DEATH") D
"RTN","DGENUPL4",69,0)
 ..D ADDMSG^DGENUPL3(.MSGS,"HEC SHOWS NO DATE OF DEATH",1)
"RTN","DGENUPL4",70,0)
 ..D ADDMSG^DGENUPL3(.MSGS,"SITE HAS DATE OF DEATH = "_$$FMTE^XLFDT(OLDPAT("DEATH"),"1"),1)
"RTN","DGENUPL4",71,0)
 .;
"RTN","DGENUPL4",72,0)
 .;change in POW
"RTN","DGENUPL4",73,0)
 .I OLDELG("POW")="N",DGELG("POW")="Y" D ADDMSG^DGENUPL3(.MSGS,"POW STATUS CHANGED TO YES")
"RTN","DGENUPL4",74,0)
 .I OLDELG("POW")="Y",DGELG("POW")="N" D ADDMSG^DGENUPL3(.MSGS,"POW STATUS CHANGED TO NO")
"RTN","DGENUPL4",75,0)
 .;
"RTN","DGENUPL4",76,0)
 .;SC to NSC
"RTN","DGENUPL4",77,0)
 .I OLDELG("SC")="Y",DGELG("SC")="N" D ADDMSG^DGENUPL3(.MSGS,"VETERAN CHANGED TO NON-SERVICE CONNECTED",1)
"RTN","DGENUPL4",78,0)
 .;
"RTN","DGENUPL4",79,0)
 .; Change from Eligible to Ineligible
"RTN","DGENUPL4",80,0)
 .I 'OLDPAT("INELDATE"),DGPAT("INELDATE") D ADDMSG^DGENUPL3(.MSGS,"VETERAN PREVIOUSLY ELIGIBLE FOR VA HEALTH CARE, NOW INELIGIBLE.",1)
"RTN","DGENUPL4",81,0)
 .;
"RTN","DGENUPL4",82,0)
 .; Check for erroneous CD deletion
"RTN","DGENUPL4",83,0)
 .I OLDCDIS("VCD")="","@"[DGCDIS("VCD") Q  ;no notification is needed
"RTN","DGENUPL4",84,0)
 .;
"RTN","DGENUPL4",85,0)
 .; CD Determination Changed
"RTN","DGENUPL4",86,0)
 .I OLDCDIS("VCD")'=DGCDIS("VCD") D ADDMSG^DGENUPL3(.MSGS,"VETERANS CD EVALUATION HAS CHANGED.")
"RTN","DGENUPL4",87,0)
 D EP^DGENUPLB
"RTN","DGENUPL4",88,0)
 Q SUCCESS
"RTN","DGENUPL4",89,0)
 ;
"RTN","DGENUPL4",90,0)
ADD ;
"RTN","DGENUPL4",91,0)
 ;Description: adds computed and assumed values to the updated objects
"RTN","DGENUPL4",92,0)
 ;
"RTN","DGENUPL4",93,0)
 ;Input: DGELG3(),DGPAT3() created in the UOBJECTS procedure.
"RTN","DGENUPL4",94,0)
 ;
"RTN","DGENUPL4",95,0)
 N SUB,TYPE,DATA
"RTN","DGENUPL4",96,0)
 S DGELG3("ELIGENTBY")=.5
"RTN","DGENUPL4",97,0)
 S SUB=0 F  S SUB=$O(DGELG3("RATEDIS",SUB)) Q:'SUB  S DGELG3("RATEDIS",SUB,"RDSC")=1
"RTN","DGENUPL4",98,0)
 ;
"RTN","DGENUPL4",99,0)
 ; Default Patient Types
"RTN","DGENUPL4",100,0)
 I DGELG3("SC")="N" S DGPAT3("VETERAN")="Y",DGPAT3("PATYPE")=$O(^DG(391,"B","NSC VETERAN",0))
"RTN","DGENUPL4",101,0)
 I DGELG3("SC")="Y" S DGPAT3("VETERAN")="Y",DGPAT3("PATYPE")=$O(^DG(391,"B","SC VETERAN",0))
"RTN","DGENUPL4",102,0)
 ;
"RTN","DGENUPL4",103,0)
 ; If Ineldate apply business rules
"RTN","DGENUPL4",104,0)
 I DGPAT3("INELDATE"),DGELG3("SC")'="Y" D
"RTN","DGENUPL4",105,0)
 .S DGPAT3("VETERAN")="N",DGPAT3("PATYPE")=$O(^DG(391,"B","NON-VETERAN (OTHER)",0))
"RTN","DGENUPL4",106,0)
 .S DGELG3("POS")=$O(^DIC(21,"B","OTHER NON-VETERANS",0))
"RTN","DGENUPL4",107,0)
 ;
"RTN","DGENUPL4",108,0)
 ;update/set ELIGIBILITY VERIF. SOURCE field (Ineligible Project):
"RTN","DGENUPL4",109,0)
 I DGELG3("ELIGVERIF")["VIVA" S DATA(.3613)="H"
"RTN","DGENUPL4",110,0)
 E  S DATA(.3613)="V"
"RTN","DGENUPL4",111,0)
 ;
"RTN","DGENUPL4",112,0)
 ; File data fields modified by Ineligible Business Rules
"RTN","DGENUPL4",113,0)
 I $$UPD^DGENDBS(2,DFN,.DATA,.ERROR)
"RTN","DGENUPL4",114,0)
 Q
"RTN","DGENUPL4",115,0)
 ;
"RTN","DGENUPL4",116,0)
MERGE ;
"RTN","DGENUPL4",117,0)
 ;Description: merges arrays with current patient data with the updates
"RTN","DGENUPL4",118,0)
 ; Merges DGPAT() + OLDPAT() -> DGPAT3()
"RTN","DGENUPL4",119,0)
 ;        DGELG() + OLDELG() -> DGELG3()
"RTN","DGENUPL4",120,0)
 ;        DGCDIS() + OLDCDIS() -> DGCDIS3()
"RTN","DGENUPL4",121,0)
 ;
"RTN","DGENUPL4",122,0)
 ;Input:
"RTN","DGENUPL4",123,0)
 ;  DGPAT,DGELG,DGCDIS,OLDPAT,OLDELG,OLDCDIS arrays
"RTN","DGENUPL4",124,0)
 ;
"RTN","DGENUPL4",125,0)
 ;Output:
"RTN","DGENUPL4",126,0)
 ;  DGPAT3,DGELG3,DGCDIS3 arrays
"RTN","DGENUPL4",127,0)
 ;
"RTN","DGENUPL4",128,0)
 N SUB,SUB2,LOC,HEC,NATCODE
"RTN","DGENUPL4",129,0)
 M DGPAT3=OLDPAT,DGELG3=OLDELG,DGCDIS3=OLDCDIS
"RTN","DGENUPL4",130,0)
 ;
"RTN","DGENUPL4",131,0)
 ;discard MT status from local database - don't ever want to use it during upload
"RTN","DGENUPL4",132,0)
 S DGELG3("MTSTA")=DGELG("MTSTA")
"RTN","DGENUPL4",133,0)
 ;
"RTN","DGENUPL4",134,0)
 ;patient array
"RTN","DGENUPL4",135,0)
 S SUB=""
"RTN","DGENUPL4",136,0)
 F  S SUB=$O(DGPAT(SUB)) Q:(SUB="")  I (DGPAT(SUB)'="") S DGPAT3(SUB)=$S((DGPAT(SUB)="@"):"",1:DGPAT(SUB))
"RTN","DGENUPL4",137,0)
 ;
"RTN","DGENUPL4",138,0)
 ;Allow Ineligible info deletion (Ineligible Project):
"RTN","DGENUPL4",139,0)
 I $D(DGPAT("INELDEC")),DGPAT("INELDEC")="" S DGPAT("INELDEC")="@"
"RTN","DGENUPL4",140,0)
 I $D(DGPAT("INELREA")),DGPAT("INELREA")="" S DGPAT("INELREA")="@"
"RTN","DGENUPL4",141,0)
 I $D(DGPAT("INELDATE")),DGPAT("INELDATE")="" S DGPAT("INELDATE")="@"
"RTN","DGENUPL4",142,0)
 ;
"RTN","DGENUPL4",143,0)
 ;catastrophic disability array
"RTN","DGENUPL4",144,0)
 S SUB=""
"RTN","DGENUPL4",145,0)
 F  S SUB=$O(DGCDIS(SUB)) Q:(SUB="")  D
"RTN","DGENUPL4",146,0)
 .I $D(DGCDIS(SUB))=1 I ($G(DGCDIS(SUB))'="") S DGCDIS3(SUB)=DGCDIS(SUB)
"RTN","DGENUPL4",147,0)
 .I $D(DGCDIS(SUB))=10 D
"RTN","DGENUPL4",148,0)
 ..S SUB2=""
"RTN","DGENUPL4",149,0)
 ..F  S SUB2=$O(DGCDIS(SUB,SUB2)) Q:SUB2=""  D
"RTN","DGENUPL4",150,0)
 ...I ($G(DGCDIS(SUB,SUB2))'="") S DGCDIS3(SUB,SUB2)=DGCDIS(SUB,SUB2)
"RTN","DGENUPL4",151,0)
 ...I SUB="PROC" D
"RTN","DGENUPL4",152,0)
 ....N CDPROC,CDEXT,LIEN
"RTN","DGENUPL4",153,0)
 ....S CDPROC=$G(DGCDIS3("PROC",SUB2))
"RTN","DGENUPL4",154,0)
 ....Q:CDPROC=""
"RTN","DGENUPL4",155,0)
 ....S CDEXT=DGCDIS3("EXT",SUB2)
"RTN","DGENUPL4",156,0)
 ....Q:CDEXT=""
"RTN","DGENUPL4",157,0)
 ....S LIEN=$O(^DGEN(27.17,CDPROC,1,"B",CDEXT,0))
"RTN","DGENUPL4",158,0)
 ....Q:LIEN=""
"RTN","DGENUPL4",159,0)
 ....K DGCDIS3("EXT",SUB2)
"RTN","DGENUPL4",160,0)
 ....S DGCDIS3("EXT",SUB2,LIEN)=CDEXT
"RTN","DGENUPL4",161,0)
 ;
"RTN","DGENUPL4",162,0)
 ;eligibility array
"RTN","DGENUPL4",163,0)
 F  S SUB=$O(DGELG(SUB)) Q:(SUB="")  I ($G(DGELG(SUB))'="") S DGELG3(SUB)=$S((DGELG(SUB)="@"):"",1:DGELG(SUB))
"RTN","DGENUPL4",164,0)
 ;
"RTN","DGENUPL4",165,0)
 ;rated disabilities from HEC should replace local sites
"RTN","DGENUPL4",166,0)
 D
"RTN","DGENUPL4",167,0)
 .K DGELG3("RATEDIS")
"RTN","DGENUPL4",168,0)
 .M DGELG3("RATEDIS")=DGELG("RATEDIS")
"RTN","DGENUPL4",169,0)
 ;
"RTN","DGENUPL4",170,0)
 ;primary eligibility
"RTN","DGENUPL4",171,0)
 I (DGELG("ELIG","CODE")'="") S DGELG3("ELIG","CODE")=$S((DGELG("ELIG","CODE")="@"):"",($$NATCODE^DGENELA(DGELG("ELIG","CODE"))=$$NATCODE^DGENELA(DGELG3("ELIG","CODE"))):DGELG3("ELIG","CODE"),1:DGELG("ELIG","CODE"))
"RTN","DGENUPL4",172,0)
 ;
"RTN","DGENUPL4",173,0)
 ;patient eligibilities multiple
"RTN","DGENUPL4",174,0)
 ;delete veteran type codes not mapped to national codes sent by HEC, but leave non-veteran types and the codes where there is a match
"RTN","DGENUPL4",175,0)
 ;first find all local codes already in the patient file and the ones sent from HEC, keep in arrays LOC and HEC
"RTN","DGENUPL4",176,0)
 S NATCODE=$$NATCODE^DGENELA(DGELG("ELIG","CODE")) I NATCODE S HEC(NATCODE)=""
"RTN","DGENUPL4",177,0)
 S SUB=0 F  S SUB=$O(DGELG("ELIG","CODE",SUB)) Q:'SUB  S NATCODE=$$NATCODE^DGENELA(SUB) I NATCODE S HEC(NATCODE)=""
"RTN","DGENUPL4",178,0)
 S SUB=0 F  S SUB=$O(DGELG3("ELIG","CODE",SUB)) Q:'SUB  S NATCODE=$$NATCODE^DGENELA(SUB) I NATCODE S LOC(NATCODE)=""
"RTN","DGENUPL4",179,0)
 ;Now discard the codes in the local patient database that don't map to a national code sent by HEC, as well as HUMANIARIAN EMERGENCY code if not sent by HEC: 
"RTN","DGENUPL4",180,0)
 S SUB=0
"RTN","DGENUPL4",181,0)
 F  S SUB=$O(DGELG3("ELIG","CODE",SUB)) Q:'SUB  D
"RTN","DGENUPL4",182,0)
 .I $P($G(^DIC(8,SUB,0)),"^",5)="Y"!($P($G(^DIC(8,SUB,0)),"^")["HUMANITARIAN EMERGENCY"),'$D(HEC($$NATCODE^DGENELA(SUB))) K DGELG3("ELIG","CODE",SUB)
"RTN","DGENUPL4",183,0)
 ;now add codes included in the update that the local database does not already contain
"RTN","DGENUPL4",184,0)
 S SUB=0
"RTN","DGENUPL4",185,0)
 F  S SUB=$O(DGELG("ELIG","CODE",SUB)) Q:'SUB  D
"RTN","DGENUPL4",186,0)
 .I '$D(LOC($$NATCODE^DGENELA(SUB))) S DGELG3("ELIG","CODE",SUB)=SUB
"RTN","DGENUPL4",187,0)
 ;Agent Orange Exp. Location, use local database when upload is NULL
"RTN","DGENUPL4",188,0)
 D AO^DGENUPL9
"RTN","DGENUPL4",189,0)
 Q
"RTN","DGENUPL4",190,0)
 ;
"RTN","DGENUPL4",191,0)
CHECK() ;
"RTN","DGENUPL4",192,0)
 ;Description: Does consistency checks on PATIENT, ELIGIBILITY, and CATASTROPHIC DISABILITY objects.
"RTN","DGENUPL4",193,0)
 ;
"RTN","DGENUPL4",194,0)
 ;Input:
"RTN","DGENUPL4",195,0)
 ;  OLDPAT,DGPAT3,DGELG3,DGCDIS3,ERRCOUNT,MSGID
"RTN","DGENUPL4",196,0)
 ;  DGENR -Enrollment Array
"RTN","DGENUPL4",197,0)
 ;  DGPAT -Patient Array
"RTN","DGENUPL4",198,0)
 ;  MSGS  -Warning and Error Message array   
"RTN","DGENUPL4",199,0)
 ;
"RTN","DGENUPL4",200,0)
 ;Output:
"RTN","DGENUPL4",201,0)
 ;  Function Value - 1 if consistency checks passed, 0 otherwise
"RTN","DGENUPL4",202,0)
 ;
"RTN","DGENUPL4",203,0)
 N SUCCESS,ALIVE,ERRMSG,DGENR
"RTN","DGENUPL4",204,0)
 S SUCCESS=1
"RTN","DGENUPL4",205,0)
 S ERRMSG=""
"RTN","DGENUPL4",206,0)
 ;
"RTN","DGENUPL4",207,0)
 ;if upload includes date of death, check for indications that patient is alive
"RTN","DGENUPL4",208,0)
 I DGPAT3("DEATH"),'OLDPAT("DEATH") D  S:ALIVE SUCCESS=0
"RTN","DGENUPL4",209,0)
 .;
"RTN","DGENUPL4",210,0)
 .;determine if patient is at the moment being registered
"RTN","DGENUPL4",211,0)
 .S ALIVE=$$IFREG^DGREG(DFN)
"RTN","DGENUPL4",212,0)
 .;
"RTN","DGENUPL4",213,0)
 .;check if an inpatient
"RTN","DGENUPL4",214,0)
 .I 'ALIVE,$$INPAT^DGENPTA(DFN,DT,DT) S ALIVE=1
"RTN","DGENUPL4",215,0)
 .;
"RTN","DGENUPL4",216,0)
 .;Phase II locally enrolled with enrollment date after death date and status of unverified and rejected-initial application by vamc (SRS 6.5.1.2 e)
"RTN","DGENUPL4",217,0)
 .N CURIEN,CURENR
"RTN","DGENUPL4",218,0)
 .S CURIEN=$$FINDCUR^DGENA(DFN)
"RTN","DGENUPL4",219,0)
 .I CURIEN,$$GET^DGENA(CURIEN,.CURENR),CURENR("DATE")>DGPAT3("DEATH"),CURENR("STATUS")=1!(CURENR("STATUS")=14) S ALIVE=1
"RTN","DGENUPL4",220,0)
 .;there is an indication that he patient may not be dead
"RTN","DGENUPL4",221,0)
 .D:ALIVE ADDERROR^DGENUPL(MSGID,DGPAT("SSN"),"LOCAL SITE VERIFY PATIENT DEATH",.ERRCOUNT),ADDMSG^DGENUPL3(.MSGS,"ELIBILITY UPLOAD CONTAINED DATE OF DEATH AND WAS REJECTED, PLEASE VERIFY PATIENT DEATH",1),NOTIFY^DGENUPL3(.DGPAT,.MSGS)
"RTN","DGENUPL4",222,0)
 ;
"RTN","DGENUPL4",223,0)
 ;only do consistency checks on this data if it is verified
"RTN","DGENUPL4",224,0)
 I SUCCESS,(DGELG3("ELIGSTA")="V") D
"RTN","DGENUPL4",225,0)
 .I $$CHECK^DGENPTA1(.DGPAT3,.ERRMSG),$$CHECK^DGENELA1(.DGELG3,.DGPAT3,.DGCDIS3,.ERRMSG),$$CHECK^DGENCDA1(.DGCDIS3,.ERRMSG)
"RTN","DGENUPL4",226,0)
 .E  D
"RTN","DGENUPL4",227,0)
 ..S SUCCESS=0
"RTN","DGENUPL4",228,0)
 ..D ADDERROR^DGENUPL(MSGID,DGPAT("SSN"),ERRMSG,.ERRCOUNT)
"RTN","DGENUPL4",229,0)
 Q SUCCESS
"RTN","DGENUPL7")
0^17^B29468363
"RTN","DGENUPL7",1,0)
DGENUPL7 ;ISA/KWP/CKN/TMK - PROCESS INCOMING (Z11 EVENT TYPE) HL7 MESSAGES ; 10/19/05
"RTN","DGENUPL7",2,0)
 ;;5.3;REGISTRATION;**232,367,397,417,379,431,513,628,673**;Aug 13,1993
"RTN","DGENUPL7",3,0)
 ;Phase II split from DGENUPL
"RTN","DGENUPL7",4,0)
Z11(MSGIEN,MSGID,CURLINE,DFN,ERRCOUNT) ;
"RTN","DGENUPL7",5,0)
 ;Description:  This is used to process a single ORU~Z11 or ORF~Z11 msg. 
"RTN","DGENUPL7",6,0)
 ;Input:
"RTN","DGENUPL7",7,0)
 ;  MSGIEN - the internal entry number of the HL7 message in the
"RTN","DGENUPL7",8,0)
 ;      HL7 MESSAGE TEXT file (772)
"RTN","DGENUPL7",9,0)
 ;  MSGID -message control id of HL7 msg in the MSH segment
"RTN","DGENUPL7",10,0)
 ;  CURLINE - the subscript of the MSH segment of the current message (pass by reference)
"RTN","DGENUPL7",11,0)
 ;  DFN - identifies the patient, is the ien of a record in the PATIENT file.
"RTN","DGENUPL7",12,0)
 ;  ERRCOUNT - is a count of the number of messages in the batch that can not be processed (pass by reference)
"RTN","DGENUPL7",13,0)
 ;
"RTN","DGENUPL7",14,0)
 ;Output:
"RTN","DGENUPL7",15,0)
 ;  CURLINE - upon leaving the procedure this parameter should be set to the end of the current message. (pass by reference)
"RTN","DGENUPL7",16,0)
 ;  ERRCOUNT - set to count of messages that were not processed due to errors encountered  (pass by reference)
"RTN","DGENUPL7",17,0)
 ;
"RTN","DGENUPL7",18,0)
 N DGELG,DGENR,DGPAT,DGCDIS,DGOEIF,ERROR,ERRMSG,MSGS,DGELGSUB,DGENUPLD,DGCON
"RTN","DGENUPL7",19,0)
 N DGNEWVAL,DIV,SUB,OLDELG,OLDPAT,OLDDCDIS,OLDEIF,DGSEC,OLDSEC,DGNTR,DGMST,DGPHINC
"RTN","DGENUPL7",20,0)
 ;
"RTN","DGENUPL7",21,0)
 ;some process is killing these HL7 variables, so need to protect them
"RTN","DGENUPL7",22,0)
 S SUB=HLFS
"RTN","DGENUPL7",23,0)
 S DIV=HLECH
"RTN","DGENUPL7",24,0)
 N HLDA,HLDAN,HLDAP,HLDT,HLDT1,HLECH,HLFS,HLNDAP,HLNDAP0,HLPID,HLQ,HLVER,HLERR,HLMTN,HLSDT
"RTN","DGENUPL7",25,0)
 S HLFS=SUB
"RTN","DGENUPL7",26,0)
 S HLECH=DIV
"RTN","DGENUPL7",27,0)
 K DIV,SUB
"RTN","DGENUPL7",28,0)
 ;
"RTN","DGENUPL7",29,0)
 ;drops out of block on error
"RTN","DGENUPL7",30,0)
 D
"RTN","DGENUPL7",31,0)
 .Q:'$$PARSE^DGENUPL1(MSGIEN,MSGID,.CURLINE,.ERRCOUNT,.DGPAT,.DGELG,.DGENR,.DGCDIS,.DGOEIF,.DGSEC,.DGNTR,.DGMST)
"RTN","DGENUPL7",32,0)
 .D GETLOCKS^DGENUPL5(DFN)
"RTN","DGENUPL7",33,0)
 .;
"RTN","DGENUPL7",34,0)
 .;Used by cross-references to determine if an upload is in progress.
"RTN","DGENUPL7",35,0)
 .S DGENUPLD="ENROLLMENT/ELIGIBILITY UPLOAD IN PROGRESS"
"RTN","DGENUPL7",36,0)
 .;
"RTN","DGENUPL7",37,0)
 .;Update the PATIENT, ELIGIBILITY, CATASTROPHIC DISABILITY objects in memory
"RTN","DGENUPL7",38,0)
 .Q:'$$UOBJECTS^DGENUPL4(DFN,.DGPAT,.DGELG,.DGCDIS,.DGOEIF,MSGID,.ERRCOUNT,.MSGS,.OLDPAT,.OLDELG,.OLDCDIS,.OLDEIF)
"RTN","DGENUPL7",39,0)
 .S ERROR=0
"RTN","DGENUPL7",40,0)
 .;if the msg contains patient security, process it
"RTN","DGENUPL7",41,0)
 .I $D(DGSEC) D  Q:ERROR
"RTN","DGENUPL7",42,0)
 ..S DGSEC("DFN")=DFN
"RTN","DGENUPL7",43,0)
 ..S DGSEC("USER")=.5
"RTN","DGENUPL7",44,0)
 ..S DGSEC("DATETIME")=$$NOW^XLFDT
"RTN","DGENUPL7",45,0)
 ..;
"RTN","DGENUPL7",46,0)
 ..; check consistency of patient security record
"RTN","DGENUPL7",47,0)
 ..I '$$CHECK^DGENSEC(.DGSEC,.ERRMSG) D  Q
"RTN","DGENUPL7",48,0)
 ...S ERROR=1
"RTN","DGENUPL7",49,0)
 ...D ADDERROR^DGENUPL(MSGID,DGPAT("SSN"),ERRMSG,.ERRCOUNT)
"RTN","DGENUPL7",50,0)
 ..;
"RTN","DGENUPL7",51,0)
 ..; upload patient security, consistency checks passed
"RTN","DGENUPL7",52,0)
 ..D SECUPLD^DGENUPL5(DFN,.DGSEC,.OLDSEC)
"RTN","DGENUPL7",53,0)
 .;
"RTN","DGENUPL7",54,0)
 .;if the msg has an enrollment process it
"RTN","DGENUPL7",55,0)
 .I DGENR("STATUS")!DGENR("APP") D  Q:ERROR
"RTN","DGENUPL7",56,0)
 ..;use $$PRIORITY to get the eligibility data used to compute priority
"RTN","DGENUPL7",57,0)
 ..I $$PRIORITY^DGENELA4(DFN,.DGELG,.DGELGSUB,DGENR("DATE"),DGENR("APP"))
"RTN","DGENUPL7",58,0)
 ..;
"RTN","DGENUPL7",59,0)
 ..;store the eligibility data in the enrollment record and other missing fields
"RTN","DGENUPL7",60,0)
 ..M DGENR("ELIG")=DGELGSUB
"RTN","DGENUPL7",61,0)
 ..S DGENR("DFN")=DFN
"RTN","DGENUPL7",62,0)
 ..S DGENR("PRIORREC")=""
"RTN","DGENUPL7",63,0)
 ..S DGENR("USER")=.5
"RTN","DGENUPL7",64,0)
 ..S DGENR("DATETIME")=$$NOW^XLFDT
"RTN","DGENUPL7",65,0)
 ..;
"RTN","DGENUPL7",66,0)
 ..;Allow null overwrites of Ineligible data (Ineligible Project):
"RTN","DGENUPL7",67,0)
 ..I $D(DGENR("DATE")),DGENR("DATE")="" S DGENR("DATE")="@"
"RTN","DGENUPL7",68,0)
 ..I $D(DGENR("FACREC")),DGENR("FACREC")="" S DGENR("FACREC")="@"
"RTN","DGENUPL7",69,0)
 ..;
"RTN","DGENUPL7",70,0)
 ..;check the consistency of the enrollment record
"RTN","DGENUPL7",71,0)
 ..I '$$CHECK^DGENA3(.DGENR,.DGPAT,.ERRMSG) D  Q
"RTN","DGENUPL7",72,0)
 ...S ERROR=1
"RTN","DGENUPL7",73,0)
 ...D ADDERROR^DGENUPL(MSGID,DGPAT("SSN"),ERRMSG,.ERRCOUNT)
"RTN","DGENUPL7",74,0)
 ..;
"RTN","DGENUPL7",75,0)
 ..; removed EGT consistency check with DG*5.3*628
"RTN","DGENUPL7",76,0)
 ..;Phase II EGT consistency checks (SRS 6.5.1.3)
"RTN","DGENUPL7",77,0)
 ..;Only do the EGT consistency checks for Rejected-Fiscal Year (11),Rejected-Mid Cycle (12),Rejected-Stop enrolling new apps (13),Rejected-Initil App by VAMC (14),Rejected below EGT threshold (22)
"RTN","DGENUPL7",78,0)
 ..;I "^11^12^13^14^22^"[("^"_DGENR("STATUS")_"^"),$$ABOVE^DGENEGT1(DGENR("DFN"),DGENR("PRIORITY"),DGENR("SUBGRP"),"","",1) D  Q
"RTN","DGENUPL7",79,0)
 ..;.S ERROR=1
"RTN","DGENUPL7",80,0)
 ..;.S ERRMSG="THE ENROLLMENT RECORD DID NOT PASS THE EGT CONSISTENCY CHECKS."
"RTN","DGENUPL7",81,0)
 ..;.D ADDERROR^DGENUPL(MSGID,DGPAT("SSN"),ERRMSG,.ERRCOUNT)
"RTN","DGENUPL7",82,0)
 ..;
"RTN","DGENUPL7",83,0)
 ..;Allow null overwrites for Ineligible vets (Ineligible Project):
"RTN","DGENUPL7",84,0)
 ..I $G(DGPAT("INELDATE"))'="" S (DGENR("PRIORITY"),DGENR("SUBGRP"))=""
"RTN","DGENUPL7",85,0)
 ..I DGENR("DATE")="@" S DGENR("DATE")=""
"RTN","DGENUPL7",86,0)
 ..I DGENR("FACREC")="@" S DGENR("FACREC")=""
"RTN","DGENUPL7",87,0)
 ..;
"RTN","DGENUPL7",88,0)
 ..D ENRUPLD^DGENUPL8(.DGENR,.DGPAT)
"RTN","DGENUPL7",89,0)
 .;
"RTN","DGENUPL7",90,0)
 .;Store the PATIENT, ELIGIBILITY, & CAT. DISB. objects
"RTN","DGENUPL7",91,0)
 .I $$STORE^DGENPTA1(.DGPAT,,1)
"RTN","DGENUPL7",92,0)
 .I $$STORE^DGENELA1(.DGELG,.DGPAT,.DGCDIS,,1)
"RTN","DGENUPL7",93,0)
 .I $G(DGCDIS("VCD"))'="",$$STORE^DGENCDA2(DFN,.DGCDIS) ;checks first if there is catastrophic disability information
"RTN","DGENUPL7",94,0)
 .;
"RTN","DGENUPL7",95,0)
 .;Call PIMS api to file NTR data.
"RTN","DGENUPL7",96,0)
 .I $D(DGNTR),$$ENRUPD^DGNTAPI1(DFN,.DGNTR)
"RTN","DGENUPL7",97,0)
 .;
"RTN","DGENUPL7",98,0)
 .;Call PIMS api to file MST data.
"RTN","DGENUPL7",99,0)
 .I DGMST("MSTSTAT")'="",DGMST("MSTDT")'="",DGMST("MSTST")'="" D
"RTN","DGENUPL7",100,0)
 ..I $$NEWSTAT^DGMSTAPI(DFN,DGMST("MSTSTAT"),DGMST("MSTDT"),".5",DGMST("MSTST"),0)
"RTN","DGENUPL7",101,0)
 .;
"RTN","DGENUPL7",102,0)
 .;Call PIMS api to file OEF/OIF data.
"RTN","DGENUPL7",103,0)
 .I $D(DGOEIF) D OEIFUPD^DGCLAPI1(DFN,.DGOEIF)
"RTN","DGENUPL7",104,0)
 .;
"RTN","DGENUPL7",105,0)
 .;if the current enrollment is a local then log patient for transmission
"RTN","DGENUPL7",106,0)
 .I $$SOURCE^DGENA(DFN)=1!$G(DGPHINC) K DGENUPLD,DGPHINC D EVENT^IVMPLOG(DFN)
"RTN","DGENUPL7",107,0)
 .;
"RTN","DGENUPL7",108,0)
 .;create the audit trail
"RTN","DGENUPL7",109,0)
 .I $$AUDIT^DGENUPA1(,MSGID,.OLDPAT,.DGPAT,.OLDELG,.DGELG,.OLDCDIS,.DGCDIS,.DGSEC,.OLDSEC)
"RTN","DGENUPL7",110,0)
 .;send notifications
"RTN","DGENUPL7",111,0)
 .D NOTIFY^DGENUPL3(.DGPAT,.MSGS)
"RTN","DGENUPL7",112,0)
 .;
"RTN","DGENUPL7",113,0)
 .;invoke registration consistency checker
"RTN","DGENUPL7",114,0)
 .D REGCHECK^DGENUPL2(DFN)
"RTN","DGENUPL7",115,0)
 ;
"RTN","DGENUPL7",116,0)
 D UNLOCK^DGENUPL5(DFN)
"RTN","DGENUPL7",117,0)
 Q
"RTN","DGLOCK")
0^10^B28314268
"RTN","DGLOCK",1,0)
DGLOCK ;ALB/MRL - PATIENT FILE DATA EDIT CHECKS ; 28-SEP-05
"RTN","DGLOCK",2,0)
 ;;5.3;Registration;**108,161,247,485,672,673**;Aug 13, 1993
"RTN","DGLOCK",3,0)
FFP ; DGFFP Access key required
"RTN","DGLOCK",4,0)
 I '$D(^XUSEC("DGFFP ACCESS",DUZ)) D EN^DDIOL("Fugitive Felon Key required to edit this field.","","!!?4") K X
"RTN","DGLOCK",5,0)
 Q
"RTN","DGLOCK",6,0)
EK ;EKey Rqrd
"RTN","DGLOCK",7,0)
 I '$D(^XUSEC("DG ELIGIBILITY",DUZ)) W !?4,$C(7),"Eligibility Key required to edit this field." K X
"RTN","DGLOCK",8,0)
 Q
"RTN","DGLOCK",9,0)
EV ;EK rqrd if Elig Ver
"RTN","DGLOCK",10,0)
 I '$D(^XUSEC("DG ELIGIBILITY",DUZ)),$D(^DPT(DFN,.361)) I $P(^(.361),U,1)="V" D EN^DDIOL("Eligibility verified...Eligibility Key required to edit this field.","","!?4") K X
"RTN","DGLOCK",11,0)
 Q
"RTN","DGLOCK",12,0)
EV2 ;if elig is ver Discharged Due to Disability can't be edited - DG 672
"RTN","DGLOCK",13,0)
 I $D(^DPT(DFN,.361)) I $P(^(.361),U,1)="V" D
"RTN","DGLOCK",14,0)
 . I $P(^DPT(DFN,.361),U,3)'="H" Q
"RTN","DGLOCK",15,0)
 . D EN^DDIOL("Eligibility verified at the HEC...NO EDITING!","","!?4") K X
"RTN","DGLOCK",16,0)
 Q
"RTN","DGLOCK",17,0)
SV ;EK Rqrd if Svc Rcrd Ver
"RTN","DGLOCK",18,0)
 I "NU"'[$E(X) D VET Q:'$D(X)
"RTN","DGLOCK",19,0)
SV1 I '$D(^XUSEC("DG ELIGIBILITY",DUZ)),$D(^DPT(DFN,.32)) I $P(^(.32),U,2)]"" D EN^DDIOL("Service Record verfied...Eligibility Key required to edit this field.","","!?4") K X
"RTN","DGLOCK",20,0)
 Q
"RTN","DGLOCK",21,0)
MV ;EK Rqrd if Money Ver
"RTN","DGLOCK",22,0)
 I "NU"'[$E(X) D VET Q:'$D(X)
"RTN","DGLOCK",23,0)
 I '$D(^XUSEC("DG ELIGIBILITY",DUZ)),$D(^DPT(DFN,.3)) I $P(^(.3),U,6)]"" W !?4,$C(7),"Monetary Benefits verified...Eligibility Key required to edit this field." K X
"RTN","DGLOCK",24,0)
 Q
"RTN","DGLOCK",25,0)
VET ;Veteran
"RTN","DGLOCK",26,0)
 S DGVV=$S($D(^DPT(DFN,"TYPE")):^("TYPE"),1:""),DGVV=$S($D(^DG(391,+DGVV,0)):$P(^(0),"^",2),1:"")
"RTN","DGLOCK",27,0)
 I $D(^DPT(DFN,"VET")),^("VET")'="Y",'DGVV D EN^DDIOL("Applicant is NOT a veteran!!","","!?4") K X
"RTN","DGLOCK",28,0)
 K DGVV Q
"RTN","DGLOCK",29,0)
VAGE ;Vet Age
"RTN","DGLOCK",30,0)
 S DGDATA=X,X1=DT,X2=$S($D(DFN):$P(^DPT(DFN,0),U,3),1:DPTIDS(.03)) S X=$E(X1,1,3)-$E(X2,1,3)-($E(X1,4,7)<$E(X2,4,7))
"RTN","DGLOCK",31,0)
 I X<17 W !?4,$C(7),"Applicant is TOO YOUNG to be a veteran...ONLY ",X," YEARS OLD!!",!?4,"See your supervisor if you require assistance." K X,X1,X2,DGDATA Q
"RTN","DGLOCK",32,0)
 S X=DGDATA K X1,X2,DGDATA Q
"RTN","DGLOCK",33,0)
AO ;Agent Orange
"RTN","DGLOCK",34,0)
 D SV I $D(X),$S('$D(^DPT(DFN,.321)):1,$P(^(.321),U,2)'="Y":1,1:0) W !?4,$C(7),"Exposure to Agent Orange not indicated...NO EDITING!" K X
"RTN","DGLOCK",35,0)
 Q
"RTN","DGLOCK",36,0)
EC ;Environmental Contaminants
"RTN","DGLOCK",37,0)
 D SV I $D(X),$S('$D(^DPT(DFN,.322)):1,$P(^(.322),U,13)'="Y":1,1:0) W !?4,$C(7),"Exposure to Environmental Contaminants not indicated...NO EDITING!" K X
"RTN","DGLOCK",38,0)
 I $D(X) I X<2900802 K X W !?4,$C(7),"Date must be on or after 8/2/1992!"
"RTN","DGLOCK",39,0)
 Q
"RTN","DGLOCK",40,0)
COM ;Combat
"RTN","DGLOCK",41,0)
 D SV I $D(X),$S('$D(^DPT(DFN,.52)):1,$P(^(.52),U,11)'="Y":1,1:0) W !?4,$C(7),"Service in Combat Zone not indicated...NO EDITING!" K X
"RTN","DGLOCK",42,0)
 Q
"RTN","DGLOCK",43,0)
INE ;Ineligible
"RTN","DGLOCK",44,0)
 D EK I $D(X),$S('$D(^DPT(DFN,.15)):1,$P(^(.15),U,2)']"":1,1:0) W !?4,$C(7),"Requirement for 'Ineligible patient' data not indicated...NO EDITING!" K X
"RTN","DGLOCK",45,0)
 Q
"RTN","DGLOCK",46,0)
IR ;ION Rad
"RTN","DGLOCK",47,0)
 D SV I $D(X),$S('$D(^DPT(DFN,.321)):1,$P(^(.321),U,3)'="Y":1,1:0) W !?4,$C(7),"Exposure to Ionizing Radiation is not indicated...NO EDITING!" K X
"RTN","DGLOCK",48,0)
 Q
"RTN","DGLOCK",49,0)
POW ;Prisoner of War
"RTN","DGLOCK",50,0)
 D SV I $D(X),$S('$D(^DPT(DFN,.52)):1,$P(^(.52),U,5)'="Y":1,1:0) W !?5,$C(7),"Not identified as a former Prisoner of War...NO EDITING!" K X
"RTN","DGLOCK",51,0)
 Q
"RTN","DGLOCK",52,0)
SER1 ;NTL Svc
"RTN","DGLOCK",53,0)
 D SV I $D(X),$S('$D(^DPT(DFN,.32)):1,$P(^(.32),U,19)'="Y":1,X="N":0,1:0) W !?4,$C(7),"Other Periods of Service are not indicated...NO EDITING!" K X
"RTN","DGLOCK",54,0)
 Q
"RTN","DGLOCK",55,0)
SER2 ;NNTL
"RTN","DGLOCK",56,0)
 D SV I $D(X),$S('$D(^DPT(DFN,.32)):1,$P(^(.32),U,20)'="Y":1,X="N":0,1:0) W !?4,$C(7),"Third Period of Service is not indicated...NO EDITING!" K X
"RTN","DGLOCK",57,0)
 Q
"RTN","DGLOCK",58,0)
TAD ;Temp Add Edit
"RTN","DGLOCK",59,0)
 I $S('$D(^DPT(DFN,.121)):1,$P(^(.121),U,9)'="Y":1,1:0) W !?4,$C(7),"Requirement for Temporary Address data not indicated...NO EDITING!" K X
"RTN","DGLOCK",60,0)
 Q
"RTN","DGLOCK",61,0)
TADD ;Temp Address Delete?
"RTN","DGLOCK",62,0)
 Q:'$D(^DPT(DFN,.121))  I $P(^(.121),"^",9)="N"!($P(^(.121),"^",1,6)="^^^^^") Q
"RTN","DGLOCK",63,0)
ASK W !,"Do you want to delete all temporary address data" S %=2 D YN^DICN I %Y["?" W !,"Answer 'Y'es to remove temporary address information, 'N'o to leave data in file" G ASK
"RTN","DGLOCK",64,0)
 Q:%'=1  S DGTEMPH=$P(^DPT(DFN,.121),"^",7,8),^(.121)="^^^^^^"_DGTEMPH_"^N^^" K DGTEMPH Q
"RTN","DGLOCK",65,0)
VN ;Viet Svc
"RTN","DGLOCK",66,0)
 D SV I $D(X),$S('$D(^DPT(DFN,.321)):1,$P(^(.321),U,1)'="Y":1,1:0) I "UN"'[$E(X) W !?4,$C(7),"Service in Republic of Vietnam not indicated...NO EDITING!" K X
"RTN","DGLOCK",67,0)
 Q
"RTN","DGLOCK",68,0)
 ;
"RTN","DGLOCK",69,0)
OEIF ;OIF/ OEF/ UNKNOWN OEF/OIF Svc
"RTN","DGLOCK",70,0)
 D SV
"RTN","DGLOCK",71,0)
 Q
"RTN","DGLOCK",72,0)
SVED ;Lebanon, Grenada, Panama, Persian Gulf & Yugoslavia svc edit
"RTN","DGLOCK",73,0)
 ;      (from and to dates)
"RTN","DGLOCK",74,0)
 ;DGX = piece position of corresponding service indicated? field
"RTN","DGLOCK",75,0)
 ;      for multiple serv indicated dgx=sv1^sv2^...
"RTN","DGLOCK",76,0)
 ;DGSV= service (sv1, sv2 from above)
"RTN","DGLOCK",77,0)
 ;DGOK= 1=YES,at least one of the required sv indicated is yes,0=NO
"RTN","DGLOCK",78,0)
 D SV I '$D(X) K DGX Q
"RTN","DGLOCK",79,0)
 N DGSV,DGOK,DGPC,PC
"RTN","DGLOCK",80,0)
 S DGOK=0
"RTN","DGLOCK",81,0)
 F PC=1:1 S DGSV=$P(DGX,U,PC) Q:DGSV']""  S:$P($G(^DPT(DFN,.322)),U,DGSV)="Y" DGOK=1
"RTN","DGLOCK",82,0)
 S PC=PC-1
"RTN","DGLOCK",83,0)
 I DGOK=0 D
"RTN","DGLOCK",84,0)
 .I "UN"'[$E(X) D
"RTN","DGLOCK",85,0)
 ..W !?4,$C(7),"Service in "
"RTN","DGLOCK",86,0)
 ..F DGPC=1:1:PC D
"RTN","DGLOCK",87,0)
 ...S DGSV=$P(DGX,U,DGPC) W $S(DGSV=1:"Lebanon",DGSV=4:"Grenada",DGSV=7:"Panama",DGSV=10:"Persian Gulf",DGSV=16:"Somalia",DGSV=19:"Yugoslavia",1:"")
"RTN","DGLOCK",88,0)
 ...W:(DGPC<PC) " or "
"RTN","DGLOCK",89,0)
 ..W " not indicated...NO EDITING!" K X
"RTN","DGLOCK",90,0)
 K DGX
"RTN","DGLOCK",91,0)
 Q
"RTN","DGRPC3")
0^24^B18322459
"RTN","DGRPC3",1,0)
DGRPC3 ;ALB/PJR,LBD - CHECK CONSISTENCY OF PATIENT DATA (CONT) ; 5/17/04 9:00am
"RTN","DGRPC3",2,0)
 ;;5.3;Registration;**451,632,673**;Aug 13, 1993
"RTN","DGRPC3",3,0)
 ;
"RTN","DGRPC3",4,0)
79 ;; MSE Dates overlap
"RTN","DGRPC3",5,0)
 ;; Don't check if MSE Dates Incomplete or if MSE TO precedes FROM
"RTN","DGRPC3",6,0)
 ;; or unless at least 2 ranges
"RTN","DGRPC3",7,0)
 S:'$G(MSECHK) MSECHK=$$MSCK^DGMSCK I MSDATERR!($L(ANYMSE)<2) D NEXT G @DGLST
"RTN","DGRPC3",8,0)
 I ANYMSE[1,'$$OVRLPCHK^DGRPDT(DFN,$P(DGP(.32),"^",6),$P(DGP(.32),"^",7),1,".326^.327") S X=79 D COMB S MSERR=1 D NEXT G @DGLST
"RTN","DGRPC3",9,0)
 I ANYMSE'[1,'$$OVRLPCHK^DGRPDT(DFN,$P(DGP(.32),"^",11),$P(DGP(.32),"^",12),1,".3292^.3293") S X=79 D COMB S MSERR=1 D NEXT G @DGLST
"RTN","DGRPC3",10,0)
 D NEXT G @DGLST
"RTN","DGRPC3",11,0)
80 ;; POW Dates not within MSE
"RTN","DGRPC3",12,0)
 I '$P(DGP(.52),"^",6) D NEXT G @DGLST ;; Don't check if no POW Data
"RTN","DGRPC3",13,0)
 ;; Don't check if POW Data Incomplete or if POW TO precedes FROM
"RTN","DGRPC3",14,0)
 I ((","_DGER_",")[(",37,"))!((","_DGER_",")[(",38,")) D NEXT G @DGLST
"RTN","DGRPC3",15,0)
 S:'$G(MSECHK) MSECHK=$$MSCK^DGMSCK S:'$G(MSESET) MSESET=$$MSFROMTO^DGMSCK
"RTN","DGRPC3",16,0)
 ;; If POW, but no MSE, then Range is NOT within MSE
"RTN","DGRPC3",17,0)
 I 'ANYMSE S X=80 D COMB D NEXT G @DGLST
"RTN","DGRPC3",18,0)
 I '$$RWITHIN^DGRPDT($P(MSESET,"^",1),$P(MSESET,"^",2),$P(DGP(.52),"^",7),$P(DGP(.52),"^",8)) S X=80 D COMB
"RTN","DGRPC3",19,0)
 D NEXT G @DGLST
"RTN","DGRPC3",20,0)
81 ;; Combat Dates not within MSE
"RTN","DGRPC3",21,0)
 I '$P(DGP(.52),"^",12) D NEXT G @DGLST ;; Don't check if no COMBAT Data
"RTN","DGRPC3",22,0)
 ;; Don't check if COMBAT Data Incomplete or if COMBAT TO precedes FROM
"RTN","DGRPC3",23,0)
 I ((","_DGER_",")[(",39,"))!((","_DGER_",")[(",40,")) D NEXT G @DGLST
"RTN","DGRPC3",24,0)
 S:'$G(MSECHK) MSECHK=$$MSCK^DGMSCK S:'$G(MSESET) MSESET=$$MSFROMTO^DGMSCK
"RTN","DGRPC3",25,0)
 ;; If COMBAT, but no MSE, then Range is NOT within MSE
"RTN","DGRPC3",26,0)
 I 'ANYMSE S X=81 D COMB D NEXT G @DGLST
"RTN","DGRPC3",27,0)
 I '$$RWITHIN^DGRPDT($P(MSESET,"^",1),$P(MSESET,"^",2),$P(DGP(.52),"^",13),$P(DGP(.52),"^",14)) S X=81 D COMB
"RTN","DGRPC3",28,0)
 D NEXT G @DGLST
"RTN","DGRPC3",29,0)
82 ;; Conflict Dates not within MSE
"RTN","DGRPC3",30,0)
 S:'$G(CONCHK) CONCHK=$$CNCK^DGMSCK
"RTN","DGRPC3",31,0)
 S:'$G(MSECHK) MSECHK=$$MSCK^DGMSCK S:'$G(MSESET) MSESET=$$MSFROMTO^DGMSCK
"RTN","DGRPC3",32,0)
 S LOC="",I2=0 F I1=1:1 S LOC=$O(CONSPEC(LOC)) Q:LOC=""  I CONARR(LOC)=1 D
"RTN","DGRPC3",33,0)
 .N FROMDAT,FROMPC,TODAT,TOPC,NODE,DATA
"RTN","DGRPC3",34,0)
 .S DATA=CONSPEC(LOC)
"RTN","DGRPC3",35,0)
 .S NODE=$P(DATA,",",1),FROMPC=$P(DATA,",",3),TOPC=$P(DATA,",",4)
"RTN","DGRPC3",36,0)
 .S FROMDAT=$P(DGP(NODE),"^",FROMPC),TODAT=$P(DGP(NODE),"^",TOPC)
"RTN","DGRPC3",37,0)
 .I '$$RWITHIN^DGRPDT($P(MSESET,"^",1),$P(MSESET,"^",2),FROMDAT,TODAT) S X=82 D COMB:'I2 S CONARR(LOC)=2,I2=1
"RTN","DGRPC3",38,0)
 .Q
"RTN","DGRPC3",39,0)
 ; Check OIF/OEF conflict dates
"RTN","DGRPC3",40,0)
 N DGOEIF D GET^DGENOEIF(DFN,.DGOEIF,0,"",0)
"RTN","DGRPC3",41,0)
 I $G(DGOEIF("COUNT")),DGER'[",82," D
"RTN","DGRPC3",42,0)
 . N Z
"RTN","DGRPC3",43,0)
 . S Z=0 F  S Z=$O(DGOEIF("IEN",Z)) Q:'Z  D  Q:DGER[",82,"
"RTN","DGRPC3",44,0)
 .. S FROMDAT=$G(DGOEIF("FR",Z)),TODAT=$G(DGOEIF("TO",Z)),LOC=$G(DGOEIF("LOC",Z))
"RTN","DGRPC3",45,0)
 .. I '$$RWITHIN^DGRPDT($P(MSESET,"^",1),$P(MSESET,"^",2),FROMDAT,TODAT) S X=82 D COMB S I2=1
"RTN","DGRPC3",46,0)
 D NEXT G @DGLST
"RTN","DGRPC3",47,0)
83 ;Merchant Seaman or Filipino Vet BOS requires service dates during WWII
"RTN","DGRPC3",48,0)
 N BOS,BOSN,MS,MSE,OUT
"RTN","DGRPC3",49,0)
 F MS=1:1:3 D  Q:$G(OUT)
"RTN","DGRPC3",50,0)
 .I MS=2,$P(DGP(.32),U,19)'="Y" S OUT=1 Q
"RTN","DGRPC3",51,0)
 .I MS=3,$P(DGP(.32),U,20)'="Y" S OUT=1 Q
"RTN","DGRPC3",52,0)
 .S BOS=$P(DGP(.32),U,(5*MS)) Q:'BOS  S BOSN=$P($G(^DIC(23,BOS,0)),U)
"RTN","DGRPC3",53,0)
 .S MSE=$S(MS=1:"MSL",MS=2:"MSNTL",1:"MSNNTL")
"RTN","DGRPC3",54,0)
 .I $$BRANCH^DGRPMS(BOS_U_BOSN),'$$WWII^DGRPMS(DFN,"",MSE) S X=83 D COMB S OUT=1 Q
"RTN","DGRPC3",55,0)
 D NEXT G @DGLST
"RTN","DGRPC3",56,0)
84 ;Filipino Vet BOS requires Filipino Vet Proof
"RTN","DGRPC3",57,0)
 N MS,BOS,OUT
"RTN","DGRPC3",58,0)
 F MS=1:1:3 D  Q:$G(OUT)
"RTN","DGRPC3",59,0)
 .I MS=2,$P(DGP(.32),U,19)'="Y" S OUT=1 Q
"RTN","DGRPC3",60,0)
 .I MS=3,$P(DGP(.32),U,20)'="Y" S OUT=1 Q
"RTN","DGRPC3",61,0)
 .S BOS=$P(DGP(.32),U,(5*MS))
"RTN","DGRPC3",62,0)
 .I $$FV^DGRPMS(BOS)=1,$P(DGP(.321),U,14)="" S X=84 D COMB S OUT=1 Q
"RTN","DGRPC3",63,0)
 D NEXT G @DGLST
"RTN","DGRPC3",64,0)
85 ;Eligible Filipino Vet should have Veteran status = 'YES'
"RTN","DGRPC3",65,0)
86 ;Ineligible Filipino Vet should have Veteran status = 'NO'
"RTN","DGRPC3",66,0)
 N MS,BOS,FV,FILV,NOTFV,MSE,OUT
"RTN","DGRPC3",67,0)
 F MS=1:1:3 D  Q:$G(OUT)
"RTN","DGRPC3",68,0)
 .I MS=2,$P(DGP(.32),U,19)'="Y" S OUT=1 Q
"RTN","DGRPC3",69,0)
 .I MS=3,$P(DGP(.32),U,20)'="Y" S OUT=1 Q
"RTN","DGRPC3",70,0)
 .S BOS=$P(DGP(.32),U,(5*MS)),FV=$$FV^DGRPMS(BOS) I 'FV S NOTFV="" Q
"RTN","DGRPC3",71,0)
 .S MSE=$S(MS=1:"MSL",MS=2:"MSNTL",1:"MSNNTL")
"RTN","DGRPC3",72,0)
 .I '$$WWII^DGRPMS(DFN,"",MSE) S FILV("I")="" Q
"RTN","DGRPC3",73,0)
 .I FV=2 S FILV("E")="" Q
"RTN","DGRPC3",74,0)
 .I $P(DGP(.321),U,14)=""!($P(DGP(.321),U,14)="NO") S FILV("I")="" Q
"RTN","DGRPC3",75,0)
 .S FILV("E")=""
"RTN","DGRPC3",76,0)
 I $D(FILV) D
"RTN","DGRPC3",77,0)
 .I DGVT'=1,$D(FILV("E")) S X=85 D COMB Q
"RTN","DGRPC3",78,0)
 .I DGCHK'[(",86,") Q
"RTN","DGRPC3",79,0)
 .I DGVT=1,'$D(NOTFV),'$D(FILV("E")),$D(FILV("I")) S X=86 D COMB
"RTN","DGRPC3",80,0)
 S DGLST=86
"RTN","DGRPC3",81,0)
 D NEXT G @DGLST
"RTN","DGRPC3",82,0)
99 ; synonymous with END
"RTN","DGRPC3",83,0)
END I DGNCK S X=99 D COMB
"RTN","DGRPC3",84,0)
 I DGEDCN S DGCON=0 D TIME^DGRPC
"RTN","DGRPC3",85,0)
 K C,C1,C2,DGCD,DGD,DGD1,DGD2,DGDATE,DGDEP,DGCHK,DGFL,DGINC,DGISYR,DGLST,DGMS,DGNCK,DGP,DGPTYP,DGREL,DGSCT,DGT,DGTIME,DGTOT,DGVT,I,I2,I2,J,VAIN,X,X1
"RTN","DGRPC3",86,0)
 G ^DGRPCF
"RTN","DGRPC3",87,0)
 ;
"RTN","DGRPC3",88,0)
COMB S DGCT=DGCT+1,DGER=DGER_X_",",DGLST=X Q
"RTN","DGRPC3",89,0)
 ;;
"RTN","DGRPC3",90,0)
NEXT S I=$F(DGCHK,(","_+DGLST_",")),DGLST=+$E(DGCHK,I,999) S:'DGLST DGLST="END"
"RTN","DGRPC3",91,0)
 Q
"RTN","DGRPDT")
0^18^B69102930
"RTN","DGRPDT",1,0)
DGRPDT ;ALB/BRM - MILITARY SERVICE DATE UTILITIES ; 1/18/05 4:27pm
"RTN","DGRPDT",2,0)
 ;;5.3;Registration;**562,603,626,673**;Aug 13, 1993
"RTN","DGRPDT",3,0)
 ;
"RTN","DGRPDT",4,0)
DTUTIL(DGNEWDT,DGOLDDT,MYFLG) ; Date precision comparision API
"RTN","DGRPDT",5,0)
 S:$G(DGOLDDT)="" DGOLDDT="0000000"
"RTN","DGRPDT",6,0)
 Q:'$$VALID(.DGNEWDT) "0^INVALID DATE PARAMETER"
"RTN","DGRPDT",7,0)
 I $L(DGOLDDT)<7 S DGOLDDT=DGOLDDT_$E("0000000",$L(DGOLDDT)+1,7)
"RTN","DGRPDT",8,0)
 N X,Y,EXACTO,EXACTN,I,RTN,MSDATE,MSG
"RTN","DGRPDT",9,0)
 S RTN="",EXACTO=$$CHKEXC(DGOLDDT),EXACTN=$$CHKEXC(DGNEWDT)
"RTN","DGRPDT",10,0)
 I $G(MYFLG) Q:'$$MNTHYR(DGNEWDT) "0^Date must contain month and year"
"RTN","DGRPDT",11,0)
 Q:EXACTO=EXACTN "1^Same Precision"
"RTN","DGRPDT",12,0)
 F I=1:1:3  Q:RTN'=""  D
"RTN","DGRPDT",13,0)
 .S:$E(EXACTN,I)<$E(EXACTO,I) RTN="0^ is Less Precise Than Previously Entered "
"RTN","DGRPDT",14,0)
 .S:$E(EXACTN,I)>$E(EXACTO,I) RTN="1^ is More Precise Than Previously Entered "
"RTN","DGRPDT",15,0)
 .S MSG=$S(I=1:"Year",I=2:"Month",I=3:"Day",1:"")
"RTN","DGRPDT",16,0)
 .S:RTN'="" $P(RTN,"^",2)=MSG_$P(RTN,"^",2)_MSG
"RTN","DGRPDT",17,0)
 Q $S($G(RTN)'="":RTN,1:"0^Unknown Precision")
"RTN","DGRPDT",18,0)
CHKEXC(MSDATE) ; construct precision string (3 digit return value - YMD)
"RTN","DGRPDT",19,0)
 Q ($E(MSDATE,1,3)'="000")_($E(MSDATE,4,5)'="00")_($E(MSDATE,6,7)'="00")
"RTN","DGRPDT",20,0)
MNTHYR(MSDATE) ; ensure month and year are not imprecise (binary return value)
"RTN","DGRPDT",21,0)
 Q ($E(MSDATE,1,3)'="000")&($E(MSDATE,4,5)'="00")
"RTN","DGRPDT",22,0)
WITHIN(FRDT,TODT,CHKDT) ; is CHKDT within FRDT and TODT?
"RTN","DGRPDT",23,0)
 N DGRPB41,DGRPB42
"RTN","DGRPDT",24,0)
 Q:'$$VALID($G(CHKDT)) "0^Invalid Date"
"RTN","DGRPDT",25,0)
 Q:('$G(FRDT))!('$G(TODT)) "0^Missing Required Date Range"
"RTN","DGRPDT",26,0)
 Q:('$$VALID(FRDT)!'$$VALID(TODT)!'$$B4(FRDT,TODT,1)) "0^Invalid Date Range"
"RTN","DGRPDT",27,0)
 S DGRPB41=$$B4(FRDT,CHKDT,1),DGRPB42=$$B4(CHKDT,TODT,1)
"RTN","DGRPDT",28,0)
 I 'DGRPB41!'DGRPB42 Q "0^Not Within Valid Date Range"
"RTN","DGRPDT",29,0)
 Q "1^Date is Within Date Range"_$S($P(DGRPB41,"^",2):"^1",$P(DGRPB42,"^",2):"^1",1:"")  ;add same flag if they are the same
"RTN","DGRPDT",30,0)
VALID(DATE) ; is this a valid Fileman date? (limits are from FR^XLFDT)
"RTN","DGRPDT",31,0)
 Q:'$D(DATE) 0
"RTN","DGRPDT",32,0)
 Q (1410102'>DATE)&(DATE'>4141015.235959)
"RTN","DGRPDT",33,0)
B4(DATE1,DATE2,SAME) ;is DATE1 before DATE2?
"RTN","DGRPDT",34,0)
 N IMPRDT,IDT,IRTN,CDATE1,CDATE2
"RTN","DGRPDT",35,0)
 S DATE1=$P($G(DATE1),"."),DATE2=$P($G(DATE2),".")
"RTN","DGRPDT",36,0)
 Q:DATE1=""!DATE2="" 1
"RTN","DGRPDT",37,0)
 I $G(SAME),DATE1=DATE2 Q "1^1"
"RTN","DGRPDT",38,0)
 I $$CHKEXC(DATE1)'=111!$$CHKEXC(DATE2)'=111 D  Q:$G(IRTN) IRTN
"RTN","DGRPDT",39,0)
 .S (CDATE1,CDATE2)="0000000"
"RTN","DGRPDT",40,0)
 .I $E(DATE1,1,3),$E(DATE2,1,3) F I=1:1:2 S $E(@("CDATE"_I),1,3)=$E(@("DATE"_I),1,3)
"RTN","DGRPDT",41,0)
 .I $E(DATE1,4,5),$E(DATE2,4,5) F I=1:1:2 S $E(@("CDATE"_I),4,5)=$E(@("DATE"_I),4,5)
"RTN","DGRPDT",42,0)
 .I $E(DATE1,6,7),$E(DATE2,6,7) F I=1:1:2 S $E(@("CDATE"_I),6,7)=$E(@("DATE"_I),6,7)
"RTN","DGRPDT",43,0)
 .I CDATE1<CDATE2 S IRTN=1 Q
"RTN","DGRPDT",44,0)
 .I CDATE1=CDATE2 S IRTN="1^1" Q
"RTN","DGRPDT",45,0)
 Q DATE1<DATE2
"RTN","DGRPDT",46,0)
RWITHIN(FRDT,TODT,CHKDT1,CHKDT2) ;are CHKDT1 and CHKDT2 within FRDT and TODT?
"RTN","DGRPDT",47,0)
 N CHK1,CHK2
"RTN","DGRPDT",48,0)
 S CHK1=$$WITHIN(.FRDT,.TODT,.CHKDT1) Q:'CHK1 CHK1
"RTN","DGRPDT",49,0)
 S CHK2=$$WITHIN(.FRDT,.TODT,.CHKDT2) Q:'CHK2 CHK2
"RTN","DGRPDT",50,0)
 Q "1^Both Date are Within Date Range"_$S(($P(CHK1,"^",3)!$P(CHK2,"^",3)):"^1",1:"")
"RTN","DGRPDT",51,0)
COVRLP2(DFN,FRDT,TODT,IGNORE,OEFOIF) ; check conflict with type 0 and 2 (see below)
"RTN","DGRPDT",52,0)
 Q:('$G(DFN))!('$D(^DPT(DFN))) "0^INVALID DFN"
"RTN","DGRPDT",53,0)
 S RTN=$$OVRLPCHK(DFN,.FRDT,.TODT,-1,$G(IGNORE),.OEFOIF)
"RTN","DGRPDT",54,0)
 Q:$P(RTN,"^")=0 RTN
"RTN","DGRPDT",55,0)
 S RTN=$$OVRLPCHK(DFN,.FRDT,.TODT,2,$G(IGNORE),.OEFOIF)
"RTN","DGRPDT",56,0)
 Q RTN
"RTN","DGRPDT",57,0)
OVRLPCHK(DFN,FRDT,TODT,TYPE,IGNORE,OEFOIF) ;check for overlapping date ranges
"RTN","DGRPDT",58,0)
 ; pass OEFOIF by ref - return OEFOIF(1)=1: OEF/OIF "cnflct not within MSE
"RTN","DGRPDT",59,0)
 N RTN1,DATA,NODE,RTN,FRDT1,MSG,SUBRNG,TODT1,DGW1,DGW2,DGRW1,DGRW2,DGZ
"RTN","DGRPDT",60,0)
 Q:('$G(DFN))!('$D(^DPT(DFN))) "0^INVALID DFN"
"RTN","DGRPDT",61,0)
 I TYPE<2 D
"RTN","DGRPDT",62,0)
 . S NODE(.32)=".326,.327,.3285,.3292,.3293,.32945,.3297,.3298"
"RTN","DGRPDT",63,0)
 E  D
"RTN","DGRPDT",64,0)
 . ; If checking an OEF/OIF period, only check against OEF/OIF
"RTN","DGRPDT",65,0)
 . I $G(OEFOIF) S NODE(2.3215)=".02,.03" K IGNORE Q
"RTN","DGRPDT",66,0)
 . S NODE(.321)=".32104,.32105",NODE(.322)=".3222,.3223,.3225,.3226,.3228,.3229,.322011,.322012,.322017,.322018,.32202,.322021",NODE(.52)=".5293,.5294"
"RTN","DGRPDT",67,0)
 D:$G(IGNORE)]"" IGNORE(.NODE,.IGNORE)
"RTN","DGRPDT",68,0)
 D GETDAT(DFN,.NODE,.DATA) Q:'$D(DATA) "1^CANNOT FIND PATIENT DATA"
"RTN","DGRPDT",69,0)
 I $G(OEFOIF),$P(OEFOIF,U,2)'="" K DATA($P(OEFOIF,U,2)) ; OEF/OIF entry to exclude (used instead of IGNORE)
"RTN","DGRPDT",70,0)
 I TYPE<0 S DGZ=$$MSEONLY(.DATA,FRDT,TODT) S:'DGZ&$G(OEFOIF) OEFOIF(1)=1 Q DGZ
"RTN","DGRPDT",71,0)
 S SUBRNG="" F  S SUBRNG=$O(DATA(SUBRNG)) Q:SUBRNG=""!($D(RTN))  D
"RTN","DGRPDT",72,0)
 .S FRDT1=$P(DATA(SUBRNG),"^"),TODT1=$P(DATA(SUBRNG),"^",2)
"RTN","DGRPDT",73,0)
 .I FRDT1="",TODT1="" Q
"RTN","DGRPDT",74,0)
 .I 'TYPE S:$$RWITHIN(FRDT1,TODT1,.FRDT,.TODT) RTN1=$G(RTN1)+1 Q
"RTN","DGRPDT",75,0)
 .S MSG=$S(TYPE=1:"Military Service Episode",1:"Conflict")
"RTN","DGRPDT",76,0)
 . ; For OEF/OIF only - dates must be totally non-overlapping
"RTN","DGRPDT",77,0)
 .S DGW1=$$WITHIN(FRDT1,TODT1,.FRDT),DGW2=$$WITHIN(FRDT1,TODT1,.TODT)
"RTN","DGRPDT",78,0)
 .I DGW1,$S('$G(OEFOIF):'$P(DGW1,"^",3),1:1) S RTN="0^This "_MSG_" overlaps with another "_MSG
"RTN","DGRPDT",79,0)
 .I DGW2,$S('$G(OEFOIF):'$P(DGW2,"^",3),1:1) S RTN="0^This "_MSG_" overlaps with another "_MSG
"RTN","DGRPDT",80,0)
 .S DGRW1=$$RWITHIN(FRDT1,TODT1,.FRDT,.TODT),DGRW2=$$RWITHIN(.FRDT,.TODT,FRDT1,TODT1)
"RTN","DGRPDT",81,0)
 .I '$G(OEFOIF),DGRW1,'$$SAME(FRDT1,TODT1,FRDT,TODT) S RTN="0^This "_MSG_" is within another "_MSG
"RTN","DGRPDT",82,0)
 .I '$G(OEFOIF),DGRW2,'$$SAME(FRDT1,TODT1,FRDT,TODT) S RTN="0^Another "_MSG_" is within another "_MSG
"RTN","DGRPDT",83,0)
 .I $E($P($G(OEFOIF),U,2),1,3)="UNK"!($E(SUBRNG,1,3)="UNK") D
"RTN","DGRPDT",84,0)
 .. I FRDT,TODT,'(DGRW1!DGRW2),DGW1!DGW2 S RTN="0^This "_MSG_" is within another "_MSG
"RTN","DGRPDT",85,0)
 .I (DGRW1!(DGRW2)),$S($E($P($G(OEFOIF),U,2),1,3)'="UNK"&($E(SUBRNG,1,3)'="UNK"):'$$SAME(FRDT1,TODT1,FRDT,TODT),1:$E(SUBRNG,1,3)="UNK"&(FRDT'=FRDT1!(TODT'=TODT1))) S RTN="0^This "_MSG_" is within another "_MSG
"RTN","DGRPDT",86,0)
 I ('TYPE),'$D(RTN1) S:$G(OEFOIF) OEFOIF(1)=1 Q "0^This conflict is not within a Military Service Episode"
"RTN","DGRPDT",87,0)
 Q:$D(RTN) RTN
"RTN","DGRPDT",88,0)
 Q "1^OK"
"RTN","DGRPDT",89,0)
SAME(FRDT1,TODT1,FRDT,TODT) ;
"RTN","DGRPDT",90,0)
 N DGS1,DGS2,DGS3,DGS4
"RTN","DGRPDT",91,0)
 S DGS1=$$B4(FRDT,TODT1,1),DGS2=$$B4(FRDT1,TODT,1)
"RTN","DGRPDT",92,0)
 S DGS3=$$B4(TODT,FRDT1,1),DGS4=$$B4(TODT1,FRDT,1)
"RTN","DGRPDT",93,0)
 Q:$P(DGS1,"^",3) 1
"RTN","DGRPDT",94,0)
 Q:$P(DGS2,"^",3) 1
"RTN","DGRPDT",95,0)
 Q:$P(DGS3,"^",3) 1
"RTN","DGRPDT",96,0)
 Q:$P(DGS4,"^",3) 1
"RTN","DGRPDT",97,0)
 Q 0
"RTN","DGRPDT",98,0)
GETDAT(DFN,NODE,DATA) ;get data from the Patient (#2) file
"RTN","DGRPDT",99,0)
 N LOOP,SUB,SUB1,Z,Z0,TMPDAT,DATA1,ERR,DR,SUBND,X,X1
"RTN","DGRPDT",100,0)
 Q:('$D(NODE))!('$D(DFN))
"RTN","DGRPDT",101,0)
 S SUB="",Z=1
"RTN","DGRPDT",102,0)
 F  S SUB=$O(NODE(SUB)) Q:SUB=""  D
"RTN","DGRPDT",103,0)
 .S SUBND=$P(SUB,".")
"RTN","DGRPDT",104,0)
 .S DR=$TR(NODE(SUB),",",";") Q:DR=""
"RTN","DGRPDT",105,0)
 .I 'SUBND D  Q
"RTN","DGRPDT",106,0)
 ..D GETS^DIQ(2,DFN_",",DR,"I","TMPDAT","ERR")
"RTN","DGRPDT",107,0)
 ..S LOOP="F X="_$G(NODE(SUB))_" S DATA1(X)=$G(TMPDAT(2,DFN_"","",X,""I"")),Z=Z+1"
"RTN","DGRPDT",108,0)
 ..X LOOP
"RTN","DGRPDT",109,0)
 . ; Extract dates from OIF OEF multiple too
"RTN","DGRPDT",110,0)
 . S Z0=0 F  S Z0=$O(^DPT(DFN,SUB-2,Z0)) Q:'Z0  S SUB1(Z0)=+$G(^(Z0,0)) D GETS^DIQ(SUB,Z0_","_DFN_",",DR,"I","TMPDAT","ERR")
"RTN","DGRPDT",111,0)
 .S LOOP="F X="_$G(NODE(SUB))_" F X1=0:0 S X1=$O(SUB1(X1)) Q:'X1  S DATA1($S(SUB1(X1)=3:""UNK"",1:$$EXTERNAL^DILFD(SUB,.01,,SUB1(X1)))_""-""_X1,X)=$G(TMPDAT(SUB,X1_"",""_DFN_"","",X,""I"")),Z=Z+1" X LOOP
"RTN","DGRPDT",112,0)
 S DATA("MSL")=$G(DATA1(.326))_"^"_$G(DATA1(.327))
"RTN","DGRPDT",113,0)
 S DATA("MSNTL")=$S($G(DATA1(.3285))="Y":$G(DATA1(.3292))_"^"_$G(DATA1(.3293)),1:"^")
"RTN","DGRPDT",114,0)
 S DATA("MSNNTL")=$S($G(DATA1(.32945))="Y":$G(DATA1(.3297))_"^"_$G(DATA1(.3298)),1:"^")
"RTN","DGRPDT",115,0)
 S DATA("VIET")=$G(DATA1(.32104))_"^"_$G(DATA1(.32105))
"RTN","DGRPDT",116,0)
 S DATA("LEB")=$G(DATA1(.3222))_"^"_$G(DATA1(.3223))
"RTN","DGRPDT",117,0)
 S DATA("GREN")=$G(DATA1(.3225))_"^"_$G(DATA1(.3226))
"RTN","DGRPDT",118,0)
 S DATA("PAN")=$G(DATA1(.3228))_"^"_$G(DATA1(.3229))
"RTN","DGRPDT",119,0)
 S DATA("GULF")=$G(DATA1(.322011))_"^"_$G(DATA1(.322012))
"RTN","DGRPDT",120,0)
 S DATA("SOM")=$G(DATA1(.322017))_"^"_$G(DATA1(.322018))
"RTN","DGRPDT",121,0)
 S DATA("YUG")=$G(DATA1(.32202))_"^"_$G(DATA1(.322021))
"RTN","DGRPDT",122,0)
 S DATA("COMBAT")=$G(DATA1(.5293))_"^"_$G(DATA1(.5294))
"RTN","DGRPDT",123,0)
 ; Pick up the OEF/OIF nodes here - subscript is not numeric
"RTN","DGRPDT",124,0)
 S Z=" " F  S Z=$O(DATA1(Z)) Q:Z=""  S DATA(Z)=$G(DATA1(Z,.02))_"^"_$G(DATA1(Z,.03))
"RTN","DGRPDT",125,0)
 Q
"RTN","DGRPDT",126,0)
MSEONLY(DATA,FRDT,TODT) ; are these dates within the whole MSE period?
"RTN","DGRPDT",127,0)
 N TO,FROM,SUBRNG,FRDT1,TODT1,MSEFR,MSETO
"RTN","DGRPDT",128,0)
 S SUBRNG="" F  S SUBRNG=$O(DATA(SUBRNG)) Q:SUBRNG=""  D
"RTN","DGRPDT",129,0)
 .S FRDT1=$P(DATA(SUBRNG),"^"),TODT1=$P(DATA(SUBRNG),"^",2)
"RTN","DGRPDT",130,0)
 .S:FRDT1 FROM(FRDT1)="" S:TODT1 TO(TODT1)=""
"RTN","DGRPDT",131,0)
 S MSEFR=$O(FROM("")),MSETO=$O(TO(""),-1)
"RTN","DGRPDT",132,0)
 I FRDT,(('$$B4(MSEFR,FRDT,1))!'$$B4(FRDT,MSETO,1)) Q "0^Conflict From Date is Not Within Military Service Episode Dates"
"RTN","DGRPDT",133,0)
 I TODT,(('$$B4(TODT,MSETO,1))!'$$B4(MSEFR,TODT,1)) Q "0^Conflict End Date is Not Within Military Service Episode Dates"
"RTN","DGRPDT",134,0)
 Q "1^OK"
"RTN","DGRPDT",135,0)
CNFLCTDT(FRDT,TODT,CNFLCT) ;are these dates valid for this conflict?
"RTN","DGRPDT",136,0)
 Q:'$D(CNFLCT) "0^INVALID CONFLICT"
"RTN","DGRPDT",137,0)
 N CRNG
"RTN","DGRPDT",138,0)
 S CRNG=$$GETCNFDT($P(CNFLCT,"-")) Q:$TR(CRNG,"^")="" "0^INVALID CONFLICT"
"RTN","DGRPDT",139,0)
 Q:$P(CRNG,"^")=0 CRNG
"RTN","DGRPDT",140,0)
 I $G(TODT)'="",TODT<$P(CRNG,U,3) Q "0^Not Within Valid Date Range"
"RTN","DGRPDT",141,0)
 I $G(FRDT)="" Q $$WITHIN($P(CRNG,"^"),$P(CRNG,"^",2),.TODT)_" for Conflict - "_$$FMTE^XLFDT($P(CRNG,"^"))_" through "_$$FMTE^XLFDT($P(CRNG,"^",2))
"RTN","DGRPDT",142,0)
 I $G(TODT)="" Q $$WITHIN($P(CRNG,"^"),$P(CRNG,"^",2),.FRDT)_" for Conflict - "_$$FMTE^XLFDT($P(CRNG,"^"))_" through "_$$FMTE^XLFDT($P(CRNG,"^",2))
"RTN","DGRPDT",143,0)
 Q $$RWITHIN($P(CRNG,"^"),$P(CRNG,"^",2),.FRDT,.TODT)_" for Conflict - "_$$FMTE^XLFDT($P(CRNG,"^"))_" through "_$$FMTE^XLFDT($P(CRNG,"^",2))
"RTN","DGRPDT",144,0)
GETCNFDT(CNFLCT) ; get the date range for input conflict
"RTN","DGRPDT",145,0)
 Q:'$D(CNFLCT) "0^INVALID CONFLICT"
"RTN","DGRPDT",146,0)
 N CRNG,CNFLCT1
"RTN","DGRPDT",147,0)
 S CNFLCT1=$P(CNFLCT,"-")
"RTN","DGRPDT",148,0)
 S CRNG=$T(@(CNFLCT1)) Q:CRNG']"" "0^INVALID CONFLICT"
"RTN","DGRPDT",149,0)
 S CRNG=$P(CRNG,";;",2) S:$P(CRNG,"^",2)="" $P(CRNG,"^",2)=$$DT^XLFDT
"RTN","DGRPDT",150,0)
 S:$P(CRNG,"^")="" $P(CRNG,"^")=1410102
"RTN","DGRPDT",151,0)
 S:$P(CRNG,U,3)="" $P(CRNG,U,3)=$P(CRNG,U)
"RTN","DGRPDT",152,0)
 Q CRNG
"RTN","DGRPDT",153,0)
IGNORE(NODE,IFLD) ; extract top-level field to ignore when comparing
"RTN","DGRPDT",154,0)
 N LOOP,QLOOP,RVAL,LSTPC,PC
"RTN","DGRPDT",155,0)
 S LOOP="",IFLD="^"_IFLD_"^"
"RTN","DGRPDT",156,0)
 F  S LOOP=$O(NODE(LOOP)) Q:LOOP=""  D
"RTN","DGRPDT",157,0)
 .I IFLD[("^"_$P(NODE(LOOP),",")_"^") S NODE(LOOP)=$P(NODE(LOOP),",",2,99),LOOP="" Q
"RTN","DGRPDT",158,0)
 .S LSTPC=$L($TR(NODE(LOOP),".0123456789"))+1
"RTN","DGRPDT",159,0)
 .I IFLD[("^"_$P(NODE(LOOP),",",LSTPC)_"^") S NODE(LOOP)=$P(NODE(LOOP),",",1,LSTPC-1),LOOP="" Q
"RTN","DGRPDT",160,0)
 .F PC=1:1:LSTPC Q:$G(QLOOP)  I IFLD[("^"_$P(NODE(LOOP),",",PC)_"^") S NODE(LOOP)=$P(NODE(LOOP),",",1,PC-1)_","_$P(NODE(LOOP),",",PC+1,99),LOOP="" Q
"RTN","DGRPDT",161,0)
 Q
"RTN","DGRPDT",162,0)
CNFLCT ;; ***  DO NOT REMOVE OR CHANGE BELOW CONFLICT VALUES  ***
"RTN","DGRPDT",163,0)
 ;;
"RTN","DGRPDT",164,0)
 ;'fr dt'^'to dt'^minimum 'to dt'
"RTN","DGRPDT",165,0)
WWI ;;2170406^2181111
"RTN","DGRPDT",166,0)
WWIIE ;;2411207^2461231
"RTN","DGRPDT",167,0)
WWIIP ;;2411207^2461231
"RTN","DGRPDT",168,0)
KOR ;;2500627^2550131
"RTN","DGRPDT",169,0)
VIET ;;2610228^2750507
"RTN","DGRPDT",170,0)
LEB ;;2831001^
"RTN","DGRPDT",171,0)
GREN ;;2831023^2831121
"RTN","DGRPDT",172,0)
PAN ;;2891220^2900131
"RTN","DGRPDT",173,0)
GULF ;;2900802^
"RTN","DGRPDT",174,0)
SOM ;;2920928^
"RTN","DGRPDT",175,0)
YUG ;;2920622^
"RTN","DGRPDT",176,0)
OTHER ;;^
"RTN","DGRPDT",177,0)
OIF ;;3030301^^3030319
"RTN","DGRPDT",178,0)
OEF ;;3010901^^3010911
"RTN","DGRPDT",179,0)
UNK ;;3010901^^3010911
"RTN","DGRPMS")
0^1^B48037248
"RTN","DGRPMS",1,0)
DGRPMS ;ALB/BRM,LBD - MILITARY SERVICE APIS ; 1/24/05 8:44am
"RTN","DGRPMS",2,0)
 ;;5.3;Registration;**451,626,646,673,689**;Aug 13, 1993
"RTN","DGRPMS",3,0)
 ;
"RTN","DGRPMS",4,0)
VALCON1(DFN,IEN,CDATE,FRTO) ; Valid conflict input for OIF/OEF/UNKNOWN OEF/OIF?
"RTN","DGRPMS",5,0)
 ; Need to send the ien of the multiple as well as the DFN and
"RTN","DGRPMS",6,0)
 ; determine the specific conflict area
"RTN","DGRPMS",7,0)
 N Z
"RTN","DGRPMS",8,0)
 S Z=$P("OIF^OEF^UNK",U,+$G(^DPT(DFN,.3215,+IEN,0)))
"RTN","DGRPMS",9,0)
 ;Q:Z="UNK" 1  ; Never need to check this - only entered through HEC
"RTN","DGRPMS",10,0)
 Q $$VALCON(DFN,Z_"-"_IEN,CDATE,FRTO)
"RTN","DGRPMS",11,0)
 ;
"RTN","DGRPMS",12,0)
VALCON(DFN,CNFLCT,CDATE,FRTO) ;is this a valid conflict input?
"RTN","DGRPMS",13,0)
 ;
"RTN","DGRPMS",14,0)
 ;INPUT:
"RTN","DGRPMS",15,0)
 ;      FRTO - 0=FRDT 1=TODT  (defaults to FRDT if FRTO="")
"RTN","DGRPMS",16,0)
 ;
"RTN","DGRPMS",17,0)
 N RTN,X,Y,FRDT,TODT,CNFLCTV,IGNORE,COMPOW,MSG,DTCHK,CNFLCT2,OEFOIF
"RTN","DGRPMS",18,0)
 Q:'$D(DFN) "0^INVALID PATIENT"
"RTN","DGRPMS",19,0)
 Q:'$D(^DPT(DFN)) "0^INVALID PATIENT"
"RTN","DGRPMS",20,0)
 Q:'$$VALID^DGRPDT(.CDATE) "0^INVALID DATE"
"RTN","DGRPMS",21,0)
 S FRTO=+$G(FRTO)
"RTN","DGRPMS",22,0)
 I 'FRTO S TODT=$$GETDT(DFN,.CNFLCT),FRDT=CDATE K DGFRDT
"RTN","DGRPMS",23,0)
 E  S FRDT=$$GETDT(DFN,.CNFLCT,FRTO) S:$G(DGFRDT) FRDT=$G(DGFRDT) S TODT=CDATE K DGFRDT
"RTN","DGRPMS",24,0)
 S DTCHK=$$DTUTIL^DGRPDT(CDATE,$$GETDT(DFN,.CNFLCT,'FRTO),1)
"RTN","DGRPMS",25,0)
 I 'DTCHK D MSG($P(DTCHK,"^",2),2,2) Q DTCHK
"RTN","DGRPMS",26,0)
 I CNFLCT="COMB"!(CNFLCT="POW") D
"RTN","DGRPMS",27,0)
 .S COMPOW=$S(CNFLCT="COMB":1,1:2)
"RTN","DGRPMS",28,0)
 .S CNFLCT2=CNFLCT
"RTN","DGRPMS",29,0)
 .S CNFLCT=$$COMPOW($S($G(DGCOMLOC):$P(DGCOMLOC,"^"),1:$$GETDT(DFN,CNFLCT,3)))
"RTN","DGRPMS",30,0)
 S CNFLCTV=""
"RTN","DGRPMS",31,0)
 I CNFLCT]"" S CNFLCTV=$$CNFLCTDT^DGRPDT(FRDT,$S(FRTO:TODT,1:""),.CNFLCT)
"RTN","DGRPMS",32,0)
 I ('CNFLCTV) D MSG($P(CNFLCTV,"^",2),2,1) Q CNFLCTV  ;dates are not within conflict
"RTN","DGRPMS",33,0)
 ;
"RTN","DGRPMS",34,0)
 S MSG=$S('$G(COMPOW):"Conflict",$G(COMPOW)=2:"POW",1:"Combat")
"RTN","DGRPMS",35,0)
 I FRDT,TODT,'$$B4^DGRPDT(FRDT,TODT,0) D MSG((MSG_" From Date is not Before "_MSG_" To Date"),2,1) Q "0^"_MSG_" From Date is not Before "_MSG_" To Date"
"RTN","DGRPMS",36,0)
 S IGNORE=$S('$P(CNFLCT,"-",2):$P($P($T(@($P(CNFLCT,"-"))),";;",2),"^",FRTO+1),1:"")
"RTN","DGRPMS",37,0)
 S:$G(COMPOW) IGNORE=$P($P($T(@(CNFLCT2)),";;",2),"^",FRTO+1)
"RTN","DGRPMS",38,0)
 I $G(COMPOW)=2 D
"RTN","DGRPMS",39,0)
 . S RTN=$$OVRLPCHK^DGRPDT(DFN,FRDT,TODT,-1,IGNORE)
"RTN","DGRPMS",40,0)
 E  D
"RTN","DGRPMS",41,0)
 . S OEFOIF=$S($P(CNFLCT,"-",2):$P(CNFLCT,"-",2)_U_CNFLCT,1:""),RTN=$$COVRLP2^DGRPDT(DFN,FRDT,TODT,IGNORE,.OEFOIF)
"RTN","DGRPMS",42,0)
 Q:RTN RTN
"RTN","DGRPMS",43,0)
 D MSG($P(RTN,"^",2),2,1)
"RTN","DGRPMS",44,0)
 Q RTN
"RTN","DGRPMS",45,0)
 ;
"RTN","DGRPMS",46,0)
VALMSE(DFN,MDATE,FRTO,FLD) ;is this a valid Military Service Episode date?
"RTN","DGRPMS",47,0)
 ;
"RTN","DGRPMS",48,0)
 ;INPUT:
"RTN","DGRPMS",49,0)
 ;      FRTO - 0=FRDT 1=TODT  (defaults to FRDT if FRTO="")
"RTN","DGRPMS",50,0)
 ;       FLD - MSE field being edited/added (MSL,MSNTL,MSNNTL)
"RTN","DGRPMS",51,0)
 ;
"RTN","DGRPMS",52,0)
 N RTN,X,Y,FRDT,TODT,IGNORE,DTCHK
"RTN","DGRPMS",53,0)
 Q:'$D(DFN) "0^INVALID PATIENT"
"RTN","DGRPMS",54,0)
 Q:'$D(^DPT(DFN)) "0^INVALID PATIENT"
"RTN","DGRPMS",55,0)
 Q:'$$VALID^DGRPDT(.MDATE) "0^INVALID DATE"
"RTN","DGRPMS",56,0)
 S FRTO=+$G(FRTO)
"RTN","DGRPMS",57,0)
 I 'FRTO S FRDT=MDATE,TODT=$$GETDT(DFN,.FLD,FRTO) K DGFRDT
"RTN","DGRPMS",58,0)
 E  S FRDT=$$GETDT(DFN,.FLD,FRTO) S:$G(DGFRDT) FRDT=$G(DGFRDT) S TODT=MDATE K DGFRDT
"RTN","DGRPMS",59,0)
 S DTCHK=$$DTUTIL^DGRPDT(MDATE,$$GETDT(DFN,.FLD,'FRTO),1)
"RTN","DGRPMS",60,0)
 I 'DTCHK D MSG($P(DTCHK,"^",2),2,2) K DGCOMBR Q DTCHK
"RTN","DGRPMS",61,0)
 I FRTO,FRDT,TODT,'$$B4^DGRPDT(.FRDT,.TODT,0) D MSG("Service Entry Date is not before Service Separation Date",2,1) K DGCOMBR Q "0^Service Entry Date is not before Service Separation Date"
"RTN","DGRPMS",62,0)
 S IGNORE=$P($P($T(@(FLD)),";;",2),"^",FRTO+1)
"RTN","DGRPMS",63,0)
 S RTN=$$OVRLPCHK^DGRPDT(.DFN,.FRDT,.TODT,1,.IGNORE)
"RTN","DGRPMS",64,0)
 I $G(DGCOMBR)']"" S DGCOMBR=$$GETDT(DFN,.FLD,4)
"RTN","DGRPMS",65,0)
 I RTN,FRTO,$$BRANCH(.DGCOMBR),('$$WWII(DFN,TODT,.FLD)) D MSG("Branch of Service Requires WWII Dates of Service",2,1) K DGCOMBR Q "0^BOS Requires WWII Dates"
"RTN","DGRPMS",66,0)
 K DGCOMBR
"RTN","DGRPMS",67,0)
 Q:RTN RTN
"RTN","DGRPMS",68,0)
 D MSG($P(RTN,"^",2),2,1)
"RTN","DGRPMS",69,0)
 Q RTN
"RTN","DGRPMS",70,0)
 ;
"RTN","DGRPMS",71,0)
BRANCH(DGCOMBR) ;branches of service that require WWII service dates
"RTN","DGRPMS",72,0)
 N BRANCH
"RTN","DGRPMS",73,0)
 Q:'$G(DGCOMBR) 0
"RTN","DGRPMS",74,0)
 S BRANCH=$P(DGCOMBR,"^",2)
"RTN","DGRPMS",75,0)
 Q:BRANCH="MERCHANT SEAMAN" 1
"RTN","DGRPMS",76,0)
 Q:BRANCH="F.COMMONWEALTH" 1
"RTN","DGRPMS",77,0)
 Q:BRANCH="F.GUERILLA" 1
"RTN","DGRPMS",78,0)
 Q:BRANCH="F.SCOUTS NEW" 1
"RTN","DGRPMS",79,0)
 Q:BRANCH="F.SCOUTS OLD" 1
"RTN","DGRPMS",80,0)
 Q 0
"RTN","DGRPMS",81,0)
 ;
"RTN","DGRPMS",82,0)
VALCOMP(DFN,CODE,DGEPI) ; Verify component is consistent with the corresponding
"RTN","DGRPMS",83,0)
 ;  branch of service  Also, branch of service must be entered before
"RTN","DGRPMS",84,0)
 ;  component.
"RTN","DGRPMS",85,0)
 ;  ACTIVATED NATIONAL GUARD (G) only valid for ARMY or AIR FORCE branch
"RTN","DGRPMS",86,0)
 ;  ACTIVATED RESERVE (V) only valid for ARMY, AIR FORCE, MARINES, NAVY
"RTN","DGRPMS",87,0)
 ;                    or COAST GUARD branch
"RTN","DGRPMS",88,0)
 ; DFN = ien of patient in file 2
"RTN","DGRPMS",89,0)
 ; DGEPI = episode # to check (1=LAST, 2=NTL, 3=NNTL)
"RTN","DGRPMS",90,0)
 ; CODE = the component code
"RTN","DGRPMS",91,0)
 ; OUTPUT: 1 if valid component
"RTN","DGRPMS",92,0)
 ;         0 if invalid component or branch of serv missing
"RTN","DGRPMS",93,0)
 N Z
"RTN","DGRPMS",94,0)
 S Z=+$P($G(^DPT(DFN,.32)),U,DGEPI*5)
"RTN","DGRPMS",95,0)
 I 'Z Q 0  ; Require bos
"RTN","DGRPMS",96,0)
 I CODE="R" Q 1  ; Regular is valid for all
"RTN","DGRPMS",97,0)
 Q:Z=1!(Z=2) 1  ; Army (1)/air force (2) valid for guard and reserves
"RTN","DGRPMS",98,0)
 ; reserves also include navy (3), marines (4), coast guard (5)
"RTN","DGRPMS",99,0)
 I CODE="V" Q $S(Z>2&(Z<6):1,1:0)
"RTN","DGRPMS",100,0)
 ;
"RTN","DGRPMS",101,0)
 Q 0
"RTN","DGRPMS",102,0)
 ;
"RTN","DGRPMS",103,0)
GETDT(DFN,CNFLCT,FRTO) ; get from date, to date, or location from patient file
"RTN","DGRPMS",104,0)
 ;
"RTN","DGRPMS",105,0)
 N CFLDS,CFLD,CNF1,CNF2,RTN1,IENS,FILE
"RTN","DGRPMS",106,0)
 Q:'$D(DFN) ""
"RTN","DGRPMS",107,0)
 Q:'$D(^DPT(DFN)) ""
"RTN","DGRPMS",108,0)
 Q:$G(CNFLCT)="" ""
"RTN","DGRPMS",109,0)
 S:$G(FRTO)="" FRTO=0
"RTN","DGRPMS",110,0)
 S CNF1=$P(CNFLCT,"-"),CNF2=+$P(CNFLCT,"-",2)
"RTN","DGRPMS",111,0)
 ; OEF/OIF/ UNKNOWN OEF/OIF data without a supplied entry in the
"RTN","DGRPMS",112,0)
 ;   multiple cannot be retrieved  OEF-1 indicates an OEF location
"RTN","DGRPMS",113,0)
 ;   stored at the '1' subscript of the .3215 multiple
"RTN","DGRPMS",114,0)
 I "^OEF^OIF^UNK^"[(U_CNF1_U),'CNF2 Q ""
"RTN","DGRPMS",115,0)
 S CFLDS=$P($T(@(CNF1)),";;",2) Q:CFLDS']"" ""
"RTN","DGRPMS",116,0)
 S CFLD=$S('FRTO:$P(CFLDS,"^",2),FRTO=1:$P(CFLDS,"^"),1:$P(CFLDS,"^",3))
"RTN","DGRPMS",117,0)
 Q:'CFLD ""
"RTN","DGRPMS",118,0)
 S IENS=DFN_",",FILE=2
"RTN","DGRPMS",119,0)
 S:CNF2 IENS=CNF2_","_IENS,FILE=2.3215 ; For OIF/OEF, must set ref to multiple
"RTN","DGRPMS",120,0)
 S RTN1=$$GET1^DIQ(FILE,IENS,CFLD,"I")
"RTN","DGRPMS",121,0)
 I FRTO=4 S RTN1=RTN1_"^"_$$EXTERNAL^DILFD(FILE,CFLD,"",RTN1)
"RTN","DGRPMS",122,0)
 Q RTN1
"RTN","DGRPMS",123,0)
 ;
"RTN","DGRPMS",124,0)
WWII(DFN,TODT,FLD) ; was this patient in WWII?
"RTN","DGRPMS",125,0)
 ;  this API assumes the WWII period to be from 12/07/41-12/31/46
"RTN","DGRPMS",126,0)
 ;
"RTN","DGRPMS",127,0)
 N OK,NODE,DATA,WWIIS,WWIIE,PATDT,PATE,PATS
"RTN","DGRPMS",128,0)
 Q:'$G(DFN) "-1^UNKNOWN"
"RTN","DGRPMS",129,0)
 S NODE(.32)=".326,.327,.3285,.3292,.3293,.32945,.3297,.3298"
"RTN","DGRPMS",130,0)
 S WWIIS=2411207,WWIIE=2461231
"RTN","DGRPMS",131,0)
 D GETDAT^DGRPDT(DFN,.NODE,.DATA)
"RTN","DGRPMS",132,0)
 S PATDT=$G(FLD) Q:PATDT']"" 0
"RTN","DGRPMS",133,0)
 S PATS=$P($G(DATA(PATDT)),"^"),PATE=$P($G(DATA(PATDT)),"^",2)
"RTN","DGRPMS",134,0)
 S:'$G(TODT) TODT=PATE
"RTN","DGRPMS",135,0)
 S OK=0
"RTN","DGRPMS",136,0)
 S OK=$$WITHIN^DGRPDT(WWIIS,WWIIE,PATS)
"RTN","DGRPMS",137,0)
 S:'OK OK=$$WITHIN^DGRPDT(WWIIS,WWIIE,TODT)
"RTN","DGRPMS",138,0)
 S:'OK OK=$$RWITHIN^DGRPDT(PATS,TODT,WWIIS,WWIIE)
"RTN","DGRPMS",139,0)
 Q $G(OK)
"RTN","DGRPMS",140,0)
DELMSE(DFN,TYPE) ; delete MSE from patient
"RTN","DGRPMS",141,0)
 ;
"RTN","DGRPMS",142,0)
 ; Input: DFN - Internal entry number for the Patient File (#2)
"RTN","DGRPMS",143,0)
 ;       TYPE - 1=Last MSE  2=Next to Last MSE  3=Next to Next to Last
"RTN","DGRPMS",144,0)
 ;
"RTN","DGRPMS",145,0)
 Q:'$G(TYPE)
"RTN","DGRPMS",146,0)
 Q:(('$G(DFN))!'$D(^DPT(DFN)))
"RTN","DGRPMS",147,0)
 N IENS,FDA,X,X1,X2,Y,ZZ,ROOT
"RTN","DGRPMS",148,0)
 S IENS=DFN_",",ROOT="FDA(2,IENS)",X=""
"RTN","DGRPMS",149,0)
 I TYPE=1 F ZZ=.324,.326,.327,.328 S @ROOT@(ZZ)=X
"RTN","DGRPMS",150,0)
 I TYPE=2 F ZZ=.329,.3292,.3293,.3294 S @ROOT@(ZZ)=X
"RTN","DGRPMS",151,0)
 I TYPE=3 F ZZ=.3295,.3297,.3298,.3299 S @ROOT@(ZZ)=X
"RTN","DGRPMS",152,0)
 D FILE^DIE("K","FDA","ERR")
"RTN","DGRPMS",153,0)
 Q
"RTN","DGRPMS",154,0)
 ;
"RTN","DGRPMS",155,0)
COMPOW(VAL) ;convert POW and Combat Location fields
"RTN","DGRPMS",156,0)
 ;
"RTN","DGRPMS",157,0)
 N ABRV
"RTN","DGRPMS",158,0)
 Q:'$G(VAL) ""
"RTN","DGRPMS",159,0)
 S ABRV=$$GET1^DIQ(22,VAL_",",1,"I")
"RTN","DGRPMS",160,0)
 Q:ABRV="WWI" "WWI"
"RTN","DGRPMS",161,0)
 Q:ABRV="WWII-EUROPE" "WWIIE"
"RTN","DGRPMS",162,0)
 Q:ABRV="WWII-PACIFIC" "WWIIP"
"RTN","DGRPMS",163,0)
 Q:ABRV="KOREAN" "KOR"
"RTN","DGRPMS",164,0)
 Q:ABRV="VIETNAM" "VIET"
"RTN","DGRPMS",165,0)
 Q:ABRV="OTHER" "OTHER"
"RTN","DGRPMS",166,0)
 Q:ABRV="PERSIAN GULF" "GULF"
"RTN","DGRPMS",167,0)
 Q:ABRV="YUGOSLAVIA" "YUG"
"RTN","DGRPMS",168,0)
 Q:ABRV="SOMALIA" "SOM"
"RTN","DGRPMS",169,0)
 Q ""
"RTN","DGRPMS",170,0)
 ;
"RTN","DGRPMS",171,0)
FV(X) ;Is this a Filipino Vet branch of service?
"RTN","DGRPMS",172,0)
 ;Added for HVE II (DG*5.3*451)
"RTN","DGRPMS",173,0)
 ;INPUT:  X = IEN Branch of Service file #23
"RTN","DGRPMS",174,0)
 ;OUTPUT: 1 = Filipino Vet BOS (F.COMMONWEALTH, F.GUERILLA, F.SCOUTS NEW)
"RTN","DGRPMS",175,0)
 ;        2 = Filipino Vet BOS (F.SCOUTS OLD)
"RTN","DGRPMS",176,0)
 ;        0 = Not Filipino Vet BOS
"RTN","DGRPMS",177,0)
 N FV
"RTN","DGRPMS",178,0)
 I '$G(X) Q 0
"RTN","DGRPMS",179,0)
 S FV=$P($G(^DIC(23,X,0)),U,1)
"RTN","DGRPMS",180,0)
 Q $S(FV="F.SCOUTS OLD":2,$E(FV,1,2)="F.":1,1:0)
"RTN","DGRPMS",181,0)
 ;
"RTN","DGRPMS",182,0)
FVP ;MUMPS cross-reference "AFV1" on Service Branch [Last] (#.325), "AFV2"
"RTN","DGRPMS",183,0)
 ;on Service Branch [NTL] (#.3291), and "AFV3" on Service Branch [NNTL]
"RTN","DGRPMS",184,0)
 ;(#.3296) in the Patient file #2.  If the Service Branch fields do not
"RTN","DGRPMS",185,0)
 ;contain a Filipino Veteran branch of service, the Filipino Vet Proof
"RTN","DGRPMS",186,0)
 ;field (#.3214) will be deleted.
"RTN","DGRPMS",187,0)
 Q:'$G(DA)
"RTN","DGRPMS",188,0)
 N BOS,MS,FV,IENS,FDA
"RTN","DGRPMS",189,0)
 S MS=$G(^DPT(DA,.32))
"RTN","DGRPMS",190,0)
 F BOS=5,10,15 S FV=$$FV($P(MS,U,BOS)) Q:FV=1
"RTN","DGRPMS",191,0)
 I FV=1 Q  ;Filipino Vet BOS found, quit
"RTN","DGRPMS",192,0)
 ;Delete Filipino Vet Proof
"RTN","DGRPMS",193,0)
 S IENS=DA_",",FDA(2,IENS,.3214)="@"
"RTN","DGRPMS",194,0)
 D FILE^DIE("","FDA")
"RTN","DGRPMS",195,0)
 Q
"RTN","DGRPMS",196,0)
 ;
"RTN","DGRPMS",197,0)
MSG(MSGTXT,LF1,LF2) ; This api will format the output text in order to utilize
"RTN","DGRPMS",198,0)
 ; the EN^DDIOL utility.
"RTN","DGRPMS",199,0)
 ;INPUT:  MSGTXT = Message text to display
"RTN","DGRPMS",200,0)
 ;           LF1 = Number of line feeds to preceed the message
"RTN","DGRPMS",201,0)
 ;           L2F = Number of line feeds to follow the message
"RTN","DGRPMS",202,0)
 ;        
"RTN","DGRPMS",203,0)
 N MSGARY,LFSTR
"RTN","DGRPMS",204,0)
 S $P(LFSTR,"!",50)="!"
"RTN","DGRPMS",205,0)
 S:$G(LF1)'="" MSGARY(.5,"F")=$E(LFSTR,1,(LF1-1))
"RTN","DGRPMS",206,0)
 S MSGARY(1)=MSGTXT
"RTN","DGRPMS",207,0)
 S:$G(LF2)'="" MSGARY(2,"F")=$E(LFSTR,1,LF2)
"RTN","DGRPMS",208,0)
 D EN^DDIOL(.MSGARY)
"RTN","DGRPMS",209,0)
 Q
"RTN","DGRPMS",210,0)
 ;
"RTN","DGRPMS",211,0)
CNFLCT ;; ***  DO NOT REMOVE BELOW CONFLICT FIELD LOCATIONS  ***
"RTN","DGRPMS",212,0)
 ;; FROM DATE^TO DATE
"RTN","DGRPMS",213,0)
WWI ;;
"RTN","DGRPMS",214,0)
WWIIE ;;
"RTN","DGRPMS",215,0)
WWIIP ;;
"RTN","DGRPMS",216,0)
KOR ;;
"RTN","DGRPMS",217,0)
VIET ;;.32104^.32105
"RTN","DGRPMS",218,0)
LEB ;;.3222^.3223
"RTN","DGRPMS",219,0)
GREN ;;.3225^.3226
"RTN","DGRPMS",220,0)
PAN ;;.3228^.3229
"RTN","DGRPMS",221,0)
GULF ;;.322011^.322012
"RTN","DGRPMS",222,0)
SOM ;;.322017^.322018
"RTN","DGRPMS",223,0)
YUG ;;.32202^.322021
"RTN","DGRPMS",224,0)
OEF ;;.02^.03
"RTN","DGRPMS",225,0)
OIF ;;.02^.03
"RTN","DGRPMS",226,0)
UNK ;;.02^.03
"RTN","DGRPMS",227,0)
 ;;
"RTN","DGRPMS",228,0)
 ;;  **BELOW VALUES ARE USED FOR MSE CHECKS - DO NOT REMOVE ***
"RTN","DGRPMS",229,0)
 ;; ENTRY DATE^SEPERATION DATE
"RTN","DGRPMS",230,0)
MSL ;;.326^.327^.325
"RTN","DGRPMS",231,0)
MSNTL ;;.3292^.3293^.3291
"RTN","DGRPMS",232,0)
MSNNTL ;;.3297^.3298^.3296
"RTN","DGRPMS",233,0)
 ;;
"RTN","DGRPMS",234,0)
 ;;  **BELOW VALUES ARE USED FOR POW AND COMBAT CHECKS - DO NOT REMOVE
"RTN","DGRPMS",235,0)
 ;; FROM DATE^TO DATE^LOCATION
"RTN","DGRPMS",236,0)
COMB ;;.5293^.5294^.5292
"RTN","DGRPMS",237,0)
POW ;;.527^.528^.526
"RTN","DGRPMS",238,0)
 ;;
"RTN","VAFHLZM1")
0^27^B66971868
"RTN","VAFHLZM1",1,0)
VAFHLZM1 ;BAY/JAT - Create HL7 Military History segment (ZMH) Cont ; 9/20/00 11:51am
"RTN","VAFHLZM1",2,0)
 ;;5.3;Registration;**314,673**;Aug 13, 1993
"RTN","VAFHLZM1",3,0)
 ;
"RTN","VAFHLZM1",4,0)
 ; This routine creates HL7 VA-specific Military History ("ZMH") segments
"RTN","VAFHLZM1",5,0)
 ; It is a continuation of VAFHLZMH and uses those variables.
"RTN","VAFHLZM1",6,0)
 ;
"RTN","VAFHLZM1",7,0)
 Q
"RTN","VAFHLZM1",8,0)
ENTER ;
"RTN","VAFHLZM1",9,0)
 N VAFSETID  ;seg setid
"RTN","VAFHLZM1",10,0)
 S VAFSETID=0
"RTN","VAFHLZM1",11,0)
 N VAFNUM
"RTN","VAFHLZM1",12,0)
 ;build segments as requested in VAFTYPE         
"RTN","VAFHLZM1",13,0)
 F VAFX=1:1 S VAFZ=$P(VAFTYPE,",",VAFX) Q:VAFZ=""  D
"RTN","VAFHLZM1",14,0)
 .S VAFY=""
"RTN","VAFHLZM1",15,0)
 .S VAFINDX=(VAFINDX\1)+1
"RTN","VAFHLZM1",16,0)
 .S VAFSETID=VAFSETID+1
"RTN","VAFHLZM1",17,0)
 .S $P(VAFY,VAFHLS,1)=VAFSETID
"RTN","VAFHLZM1",18,0)
 .S VAFTAG=$S(VAFZ=1:"SL",VAFZ=2:"SNL",VAFZ=3:"SNNL",VAFZ=4:"POW",VAFZ=5:"COMB",VAFZ=6:"VIET",VAFZ=7:"LEBA",VAFZ=8:"GREN",VAFZ=9:"PANA",VAFZ=10:"GULF",VAFZ=11:"SOMA",VAFZ=12:"YUGO",VAFZ=13:"PH",VAFZ=14:"OEIF",1:"NOSEG")
"RTN","VAFHLZM1",19,0)
 .D @VAFTAG
"RTN","VAFHLZM1",20,0)
 .;if mult episodes, add decimal to output array subscript (Ex: 14.001)
"RTN","VAFHLZM1",21,0)
 .I $D(VAFY(2)) D
"RTN","VAFHLZM1",22,0)
 ..S VAFNUM=0
"RTN","VAFHLZM1",23,0)
 ..F  S VAFNUM=$O(VAFY(VAFNUM)) Q:'$G(VAFNUM)  D
"RTN","VAFHLZM1",24,0)
 ...S VAFINDX=VAFINDX+.001
"RTN","VAFHLZM1",25,0)
 ...;if >1 conflict then increment seg setid
"RTN","VAFHLZM1",26,0)
 ...I VAFNUM>1 S VAFSETID=VAFSETID+1 S $P(VAFY(VAFNUM),VAFHLS,1)=VAFSETID
"RTN","VAFHLZM1",27,0)
 ...S @VAFARRAY@(VAFINDX,0)="ZMH"_VAFHLS_$G(VAFY(VAFNUM))
"RTN","VAFHLZM1",28,0)
 .;if not mult episodes
"RTN","VAFHLZM1",29,0)
 .I '$D(VAFY(2)) S @VAFARRAY@(VAFINDX,0)="ZMH"_VAFHLS_$G(VAFY)
"RTN","VAFHLZM1",30,0)
 .K VAFY
"RTN","VAFHLZM1",31,0)
 Q
"RTN","VAFHLZM1",32,0)
SL ; last Service branch
"RTN","VAFHLZM1",33,0)
 S $P(VAFY,VAFHLS,2)="SL"
"RTN","VAFHLZM1",34,0)
 N VAF325,VAF328,VAF324,VAF326,VAF327,VAFSCL
"RTN","VAFHLZM1",35,0)
 I VAFSTR[",3," D
"RTN","VAFHLZM1",36,0)
 .S VAF325=$P(VAF32N,U,5) S VAF325=$S(VAF325:$P($G(^DIC(23,VAF325,0)),U),1:VAFHLQ)
"RTN","VAFHLZM1",37,0)
 .S VAF328=$P(VAF32N,U,8) I VAF328="" S VAF328=VAFHLQ
"RTN","VAFHLZM1",38,0)
 .S VAF324=$P(VAF32N,U,4) S VAF324=$S(VAF324:$P($G(^DIC(25,VAF324,0)),U),1:VAFHLQ)
"RTN","VAFHLZM1",39,0)
 .; Service branch~Service number~Service discharge type
"RTN","VAFHLZM1",40,0)
 .S $P(VAFY,VAFHLS,3)=VAF325_$E(VAFHLC)_VAF328_$E(VAFHLC)_VAF324
"RTN","VAFHLZM1",41,0)
 I VAFSTR[",4," D
"RTN","VAFHLZM1",42,0)
 .S VAF326=$P(VAF32N,U,6) S VAF326=$S(VAF326:$$HLDATE^HLFNC(VAF326),1:VAFHLQ)
"RTN","VAFHLZM1",43,0)
 .S VAF327=$P(VAF32N,U,7) S VAF327=$S(VAF327:$$HLDATE^HLFNC(VAF327),1:VAFHLQ)
"RTN","VAFHLZM1",44,0)
 .; Service entry date~Service separation date
"RTN","VAFHLZM1",45,0)
 .S $P(VAFY,VAFHLS,4)=VAF326_$E(VAFHLC)_VAF327
"RTN","VAFHLZM1",46,0)
 I VAFSTR[",5," D
"RTN","VAFHLZM1",47,0)
 .; Service Component [L]
"RTN","VAFHLZM1",48,0)
 .S VAFSCL=$P(VAF3291N,U,1) I VAFSCL="" S VAFSCL=VAFHLQ
"RTN","VAFHLZM1",49,0)
 .S $P(VAFY,VAFHLS,5)=VAFSCL
"RTN","VAFHLZM1",50,0)
 Q
"RTN","VAFHLZM1",51,0)
SNL ; next to last Service branch
"RTN","VAFHLZM1",52,0)
 S $P(VAFY,VAFHLS,2)="SNL"
"RTN","VAFHLZM1",53,0)
 N VAF3291,VAF3294,VAF329,VAF3292,VAF3293,VAFSCNL
"RTN","VAFHLZM1",54,0)
 I VAFSTR[",3," D
"RTN","VAFHLZM1",55,0)
 .S VAF3291=$P(VAF32N,U,10) S VAF3291=$S(VAF3291:$P($G(^DIC(23,VAF3291,0)),U),1:VAFHLQ)
"RTN","VAFHLZM1",56,0)
 .S VAF3294=$P(VAF32N,U,13) I VAF3294="" S VAF3294=VAFHLQ
"RTN","VAFHLZM1",57,0)
 .S VAF329=$P(VAF32N,U,9) S VAF329=$S(VAF329:$P($G(^DIC(25,VAF329,0)),U),1:VAFHLQ)
"RTN","VAFHLZM1",58,0)
 .S $P(VAFY,VAFHLS,3)=VAF3291_$E(VAFHLC)_VAF3294_$E(VAFHLC)_VAF329
"RTN","VAFHLZM1",59,0)
 I VAFSTR[",4," D
"RTN","VAFHLZM1",60,0)
 .S VAF3292=$P(VAF32N,U,11) S VAF3292=$S(VAF3292:$$HLDATE^HLFNC(VAF3292),1:VAFHLQ)
"RTN","VAFHLZM1",61,0)
 .S VAF3293=$P(VAF32N,U,12) S VAF3293=$S(VAF3293:$$HLDATE^HLFNC(VAF3293),1:VAFHLQ)
"RTN","VAFHLZM1",62,0)
 .S $P(VAFY,VAFHLS,4)=VAF3292_$E(VAFHLC)_VAF3293
"RTN","VAFHLZM1",63,0)
 I VAFSTR[",5," D
"RTN","VAFHLZM1",64,0)
 .; Service Component [NL]
"RTN","VAFHLZM1",65,0)
 .S VAFSCNL=$P(VAF3291N,U,2) I VAFSCNL="" S VAFSCNL=VAFHLQ
"RTN","VAFHLZM1",66,0)
 .S $P(VAFY,VAFHLS,5)=VAFSCNL
"RTN","VAFHLZM1",67,0)
 Q
"RTN","VAFHLZM1",68,0)
SNNL ; next to next to last Service branch
"RTN","VAFHLZM1",69,0)
 S $P(VAFY,VAFHLS,2)="SNNL"
"RTN","VAFHLZM1",70,0)
 N VAF3296,VAF3299,VAF3295,VAF3297,VAF3298,VAFSCNNL
"RTN","VAFHLZM1",71,0)
 I VAFSTR[",3," D
"RTN","VAFHLZM1",72,0)
 .S VAF3296=$P(VAF32N,U,15) S VAF3296=$S(VAF3296:$P($G(^DIC(23,VAF3296,0)),U),1:VAFHLQ)
"RTN","VAFHLZM1",73,0)
 .S VAF3299=$P(VAF32N,U,18) I VAF3299="" S VAF3299=VAFHLQ
"RTN","VAFHLZM1",74,0)
 .S VAF3295=$P(VAF32N,U,14) S VAF3295=$S(VAF3295:$P($G(^DIC(25,VAF3295,0)),U),1:VAFHLQ)
"RTN","VAFHLZM1",75,0)
 .S $P(VAFY,VAFHLS,3)=VAF3296_$E(VAFHLC)_VAF3299_$E(VAFHLC)_VAF3295
"RTN","VAFHLZM1",76,0)
 I VAFSTR[",4," D
"RTN","VAFHLZM1",77,0)
 .S VAF3297=$P(VAF32N,U,16) S VAF3297=$S(VAF3297:$$HLDATE^HLFNC(VAF3297),1:VAFHLQ)
"RTN","VAFHLZM1",78,0)
 .S VAF3298=$P(VAF32N,U,17) S VAF3298=$S(VAF3298:$$HLDATE^HLFNC(VAF3298),1:VAFHLQ)
"RTN","VAFHLZM1",79,0)
 .S $P(VAFY,VAFHLS,4)=VAF3297_$E(VAFHLC)_VAF3298
"RTN","VAFHLZM1",80,0)
 I VAFSTR[",5," D
"RTN","VAFHLZM1",81,0)
 .; Service Component [NNL]
"RTN","VAFHLZM1",82,0)
 .S VAFSCNNL=$P(VAF3291N,U,3) I VAFSCNNL="" S VAFSCNNL=VAFHLQ
"RTN","VAFHLZM1",83,0)
 .S $P(VAFY,VAFHLS,5)=VAFSCNNL
"RTN","VAFHLZM1",84,0)
 Q
"RTN","VAFHLZM1",85,0)
POW ; Prisoner of War
"RTN","VAFHLZM1",86,0)
 S $P(VAFY,VAFHLS,2)="POW"
"RTN","VAFHLZM1",87,0)
 N VAF525,VAF526,VAF527,VAF528
"RTN","VAFHLZM1",88,0)
 I VAFSTR[",3," D
"RTN","VAFHLZM1",89,0)
 .S VAF525=$P(VAF52N,U,5) I VAF525="" S VAF525=VAFHLQ
"RTN","VAFHLZM1",90,0)
 .;S VAF526=$P(VAF52N,U,6) S VAF526=$S(VAF526:$P($G(^DIC(22,VAF526,0)),U),1:VAFHLQ)
"RTN","VAFHLZM1",91,0)
 .; translate pointer to coded value for VA0023 table
"RTN","VAFHLZM1",92,0)
 .S VAF526=$P(VAF52N,U,6) S VAF526=$S(VAF526>0&(VAF526<7):VAF526+3,VAF526>6&(VAF526<9):$C(VAF526+58),1:VAFHLQ)
"RTN","VAFHLZM1",93,0)
 .S $P(VAFY,VAFHLS,3)=VAF525_$E(VAFHLC)_VAF526
"RTN","VAFHLZM1",94,0)
 I VAFSTR[",4," D
"RTN","VAFHLZM1",95,0)
 .S VAF527=$P(VAF52N,U,7) S VAF527=$S(VAF527:$$HLDATE^HLFNC(VAF527),1:VAFHLQ)
"RTN","VAFHLZM1",96,0)
 .S VAF528=$P(VAF52N,U,8) S VAF528=$S(VAF528:$$HLDATE^HLFNC(VAF528),1:VAFHLQ)
"RTN","VAFHLZM1",97,0)
 .S $P(VAFY,VAFHLS,4)=VAF527_$E(VAFHLC)_VAF528
"RTN","VAFHLZM1",98,0)
 I VAFSTR[",5," S $P(VAFY,VAFHLS,5)=VAFHLQ
"RTN","VAFHLZM1",99,0)
 Q
"RTN","VAFHLZM1",100,0)
COMB ; Combat
"RTN","VAFHLZM1",101,0)
 S $P(VAFY,VAFHLS,2)="COMB"
"RTN","VAFHLZM1",102,0)
 N VAF5291,VAF5292,VAF5293,VAF5294
"RTN","VAFHLZM1",103,0)
 I VAFSTR[",3," D
"RTN","VAFHLZM1",104,0)
 .S VAF5291=$P(VAF52N,U,11) I VAF5291="" S VAF5291=VAFHLQ
"RTN","VAFHLZM1",105,0)
 .S VAF5292=$P(VAF52N,U,12) S VAF5292=$S(VAF5292:$P($G(^DIC(22,VAF5292,0)),U),1:VAFHLQ)
"RTN","VAFHLZM1",106,0)
 .S $P(VAFY,VAFHLS,3)=VAF5291_$E(VAFHLC)_VAF5292
"RTN","VAFHLZM1",107,0)
 I VAFSTR[",4," D
"RTN","VAFHLZM1",108,0)
 .S VAF5293=$P(VAF52N,U,13) S VAF5293=$S(VAF5293:$$HLDATE^HLFNC(VAF5293),1:VAFHLQ)
"RTN","VAFHLZM1",109,0)
 .S VAF5294=$P(VAF52N,U,14) S VAF5294=$S(VAF5294:$$HLDATE^HLFNC(VAF5294),1:VAFHLQ)
"RTN","VAFHLZM1",110,0)
 .S $P(VAFY,VAFHLS,4)=VAF5293_$E(VAFHLC)_VAF5294
"RTN","VAFHLZM1",111,0)
 I VAFSTR[",5," S $P(VAFY,VAFHLS,5)=VAFHLQ
"RTN","VAFHLZM1",112,0)
 Q
"RTN","VAFHLZM1",113,0)
VIET ; Vietnam
"RTN","VAFHLZM1",114,0)
 S $P(VAFY,VAFHLS,2)="VIET"
"RTN","VAFHLZM1",115,0)
 N VAF32101,VAF32104,VAF32105
"RTN","VAFHLZM1",116,0)
 I VAFSTR[",3," D
"RTN","VAFHLZM1",117,0)
 .S VAF32101=$P(VAF321N,U) I VAF32101="" S VAF32101=VAFHLQ
"RTN","VAFHLZM1",118,0)
 .S $P(VAFY,VAFHLS,3)=VAF32101
"RTN","VAFHLZM1",119,0)
 I VAFSTR[",4," D
"RTN","VAFHLZM1",120,0)
 .S VAF32104=$P(VAF321N,U,4) S VAF32104=$S(VAF32104:$$HLDATE^HLFNC(VAF32104),1:VAFHLQ)
"RTN","VAFHLZM1",121,0)
 .S VAF32105=$P(VAF321N,U,5) S VAF32105=$S(VAF32105:$$HLDATE^HLFNC(VAF32105),1:VAFHLQ)
"RTN","VAFHLZM1",122,0)
 .S $P(VAFY,VAFHLS,4)=VAF32104_$E(VAFHLC)_VAF32105
"RTN","VAFHLZM1",123,0)
 I VAFSTR[",5," S $P(VAFY,VAFHLS,5)=VAFHLQ
"RTN","VAFHLZM1",124,0)
 Q
"RTN","VAFHLZM1",125,0)
LEBA ; Lebanon
"RTN","VAFHLZM1",126,0)
 S $P(VAFY,VAFHLS,2)="LEBA"
"RTN","VAFHLZM1",127,0)
 N VAF3221,VAF3222,VAF3223
"RTN","VAFHLZM1",128,0)
 I VAFSTR[",3," D
"RTN","VAFHLZM1",129,0)
 .S VAF3221=$P(VAF322N,U) I VAF3221="" S VAF3221=VAFHLQ
"RTN","VAFHLZM1",130,0)
 .S $P(VAFY,VAFHLS,3)=VAF3221
"RTN","VAFHLZM1",131,0)
 I VAFSTR[",4," D
"RTN","VAFHLZM1",132,0)
 .S VAF3222=$P(VAF322N,U,2) S VAF3222=$S(VAF3222:$$HLDATE^HLFNC(VAF3222),1:VAFHLQ)
"RTN","VAFHLZM1",133,0)
 .S VAF3223=$P(VAF322N,U,3) S VAF3223=$S(VAF3223:$$HLDATE^HLFNC(VAF3223),1:VAFHLQ)
"RTN","VAFHLZM1",134,0)
 .S $P(VAFY,VAFHLS,4)=VAF3222_$E(VAFHLC)_VAF3223
"RTN","VAFHLZM1",135,0)
 I VAFSTR[",5," S $P(VAFY,VAFHLS,5)=VAFHLQ
"RTN","VAFHLZM1",136,0)
 Q
"RTN","VAFHLZM1",137,0)
GREN ; Grenada
"RTN","VAFHLZM1",138,0)
 S $P(VAFY,VAFHLS,2)="GREN"
"RTN","VAFHLZM1",139,0)
 N VAF3224,VAF3225,VAF3226
"RTN","VAFHLZM1",140,0)
 I VAFSTR[",3," D
"RTN","VAFHLZM1",141,0)
 .S VAF3224=$P(VAF322N,U,4) I VAF3224="" S VAF3224=VAFHLQ
"RTN","VAFHLZM1",142,0)
 .S $P(VAFY,VAFHLS,3)=VAF3224
"RTN","VAFHLZM1",143,0)
 I VAFSTR[",4," D
"RTN","VAFHLZM1",144,0)
 .S VAF3225=$P(VAF322N,U,5) S VAF3225=$S(VAF3225:$$HLDATE^HLFNC(VAF3225),1:VAFHLQ)
"RTN","VAFHLZM1",145,0)
 .S VAF3226=$P(VAF322N,U,6) S VAF3226=$S(VAF3226:$$HLDATE^HLFNC(VAF3226),1:VAFHLQ)
"RTN","VAFHLZM1",146,0)
 .S $P(VAFY,VAFHLS,4)=VAF3225_$E(VAFHLC)_VAF3226
"RTN","VAFHLZM1",147,0)
 I VAFSTR[",5," S $P(VAFY,VAFHLS,5)=VAFHLQ
"RTN","VAFHLZM1",148,0)
 Q
"RTN","VAFHLZM1",149,0)
PANA ; Panama
"RTN","VAFHLZM1",150,0)
 S $P(VAFY,VAFHLS,2)="PANA"
"RTN","VAFHLZM1",151,0)
 N VAF3227,VAF3228,VAF3229
"RTN","VAFHLZM1",152,0)
 I VAFSTR[",3," D
"RTN","VAFHLZM1",153,0)
 .S VAF3227=$P(VAF322N,U,7) I VAF3227="" S VAF3227=VAFHLQ
"RTN","VAFHLZM1",154,0)
 .S $P(VAFY,VAFHLS,3)=VAF3227
"RTN","VAFHLZM1",155,0)
 I VAFSTR[",4," D
"RTN","VAFHLZM1",156,0)
 .S VAF3228=$P(VAF322N,U,8) S VAF3228=$S(VAF3228:$$HLDATE^HLFNC(VAF3228),1:VAFHLQ)
"RTN","VAFHLZM1",157,0)
 .S VAF3229=$P(VAF322N,U,9) S VAF3229=$S(VAF3229:$$HLDATE^HLFNC(VAF3229),1:VAFHLQ)
"RTN","VAFHLZM1",158,0)
 .S $P(VAFY,VAFHLS,4)=VAF3228_$E(VAFHLC)_VAF3229
"RTN","VAFHLZM1",159,0)
 I VAFSTR[",5," S $P(VAFY,VAFHLS,5)=VAFHLQ
"RTN","VAFHLZM1",160,0)
 Q
"RTN","VAFHLZM1",161,0)
GULF ; Persian Gulf
"RTN","VAFHLZM1",162,0)
 S $P(VAFY,VAFHLS,2)="GULF"
"RTN","VAFHLZM1",163,0)
 N VAF32201,VA322011,VA322012
"RTN","VAFHLZM1",164,0)
 I VAFSTR[",3," D
"RTN","VAFHLZM1",165,0)
 .S VAF32201=$P(VAF322N,U,10) I VAF32201="" S VAF32201=VAFHLQ
"RTN","VAFHLZM1",166,0)
 .S $P(VAFY,VAFHLS,3)=VAF32201
"RTN","VAFHLZM1",167,0)
 I VAFSTR[",4," D
"RTN","VAFHLZM1",168,0)
 .S VA322011=$P(VAF322N,U,11) S VA322011=$S(VA322011:$$HLDATE^HLFNC(VA322011),1:VAFHLQ)
"RTN","VAFHLZM1",169,0)
 .S VA322012=$P(VAF322N,U,12) S VA322012=$S(VA322012:$$HLDATE^HLFNC(VA322012),1:VAFHLQ)
"RTN","VAFHLZM1",170,0)
 .S $P(VAFY,VAFHLS,4)=VA322011_$E(VAFHLC)_VA322012
"RTN","VAFHLZM1",171,0)
 I VAFSTR[",5," S $P(VAFY,VAFHLS,5)=VAFHLQ
"RTN","VAFHLZM1",172,0)
 Q
"RTN","VAFHLZM1",173,0)
SOMA ; Somalia
"RTN","VAFHLZM1",174,0)
 S $P(VAFY,VAFHLS,2)="SOMA"
"RTN","VAFHLZM1",175,0)
 N VA322016,VA322017,VA322018
"RTN","VAFHLZM1",176,0)
 I VAFSTR[",3," D
"RTN","VAFHLZM1",177,0)
 .S VA322016=$P(VAF322N,U,16) I VA322016="" S VA322016=VAFHLQ
"RTN","VAFHLZM1",178,0)
 .S $P(VAFY,VAFHLS,3)=VA322016
"RTN","VAFHLZM1",179,0)
 I VAFSTR[",4," D
"RTN","VAFHLZM1",180,0)
 .S VA322017=$P(VAF322N,U,17) S VA322017=$S(VA322017:$$HLDATE^HLFNC(VA322017),1:VAFHLQ)
"RTN","VAFHLZM1",181,0)
 .S VA322018=$P(VAF322N,U,18) S VA322018=$S(VA322018:$$HLDATE^HLFNC(VA322018),1:VAFHLQ)
"RTN","VAFHLZM1",182,0)
 .S $P(VAFY,VAFHLS,4)=VA322017_$E(VAFHLC)_VA322018
"RTN","VAFHLZM1",183,0)
 I VAFSTR[",5," S $P(VAFY,VAFHLS,5)=VAFHLQ
"RTN","VAFHLZM1",184,0)
 Q
"RTN","VAFHLZM1",185,0)
YUGO ; Yugoslavia
"RTN","VAFHLZM1",186,0)
 S $P(VAFY,VAFHLS,2)="YUGO"
"RTN","VAFHLZM1",187,0)
 N VA322019,VA32202,VA322021
"RTN","VAFHLZM1",188,0)
 I VAFSTR[",3," D
"RTN","VAFHLZM1",189,0)
 .S VA322019=$P(VAF322N,U,19) I VA322019="" S VA322019=VAFHLQ
"RTN","VAFHLZM1",190,0)
 .S $P(VAFY,VAFHLS,3)=VA322019
"RTN","VAFHLZM1",191,0)
 I VAFSTR[",4," D
"RTN","VAFHLZM1",192,0)
 .S VA32202=$P(VAF322N,U,20) S VA32202=$S(VA32202:$$HLDATE^HLFNC(VA32202),1:VAFHLQ)
"RTN","VAFHLZM1",193,0)
 .S VA322021=$P(VAF322N,U,21) S VA322021=$S(VA322021:$$HLDATE^HLFNC(VA322021),1:VAFHLQ)
"RTN","VAFHLZM1",194,0)
 .S $P(VAFY,VAFHLS,4)=VA32202_$E(VAFHLC)_VA322021
"RTN","VAFHLZM1",195,0)
 I VAFSTR[",5," S $P(VAFY,VAFHLS,5)=VAFHLQ
"RTN","VAFHLZM1",196,0)
 Q
"RTN","VAFHLZM1",197,0)
PH ; Purple Heart Recipent
"RTN","VAFHLZM1",198,0)
 S $P(VAFY,VAFHLS,2)="PH"
"RTN","VAFHLZM1",199,0)
 N VAF531,VAF532,VAF533
"RTN","VAFHLZM1",200,0)
 I VAFSTR[",3," D
"RTN","VAFHLZM1",201,0)
 .S VAF531=$P(VAF53N,U,1) I VAF531="" S VAF531=VAFHLQ
"RTN","VAFHLZM1",202,0)
 .S VAF532=$P(VAF53N,U,2) I VAF532="" S VAF532=VAFHLQ
"RTN","VAFHLZM1",203,0)
 .S VAF533=$P(VAF53N,U,3) I VAF533="" S VAF533=VAFHLQ
"RTN","VAFHLZM1",204,0)
 .S $P(VAFY,VAFHLS,3)=VAF531_$E(VAFHLC)_VAF532_$E(VAFHLC)_VAF533
"RTN","VAFHLZM1",205,0)
 I VAFSTR[",4," D
"RTN","VAFHLZM1",206,0)
 .S $P(VAFY,VAFHLS,4)=VAFHLQ
"RTN","VAFHLZM1",207,0)
 I VAFSTR[",5," S $P(VAFY,VAFHLS,5)=VAFHLQ
"RTN","VAFHLZM1",208,0)
 Q
"RTN","VAFHLZM1",209,0)
OEIF ;build Operation Enduring/Iraqi Freedom segments
"RTN","VAFHLZM1",210,0)
 D OEIF^VAFHLZM2
"RTN","VAFHLZM1",211,0)
 Q
"RTN","VAFHLZM1",212,0)
NOSEG ;
"RTN","VAFHLZM1",213,0)
 D NOSEG^VAFHLZM2
"RTN","VAFHLZM1",214,0)
 Q
"RTN","VAFHLZM2")
0^30^B3676248
"RTN","VAFHLZM2",1,0)
VAFHLZM2 ;ALB/KCL - Create HL7 Military History segment (ZMH) Cont ; 1/26/06
"RTN","VAFHLZM2",2,0)
 ;;5.3;Registration;**673**;Aug 13, 1993
"RTN","VAFHLZM2",3,0)
 ;
"RTN","VAFHLZM2",4,0)
 ;--------------------------------------------------------------------------------
"RTN","VAFHLZM2",5,0)
 ;This routine creates HL7 VA-specific Military History ("ZMH") segments. It is a
"RTN","VAFHLZM2",6,0)
 ;continuation of VAFHLZM1 and uses variables from both VAFHLZMH and VAFHLZM1.
"RTN","VAFHLZM2",7,0)
 ;--------------------------------------------------------------------------------
"RTN","VAFHLZM2",8,0)
 ;
"RTN","VAFHLZM2",9,0)
 ;no direct entry
"RTN","VAFHLZM2",10,0)
 Q
"RTN","VAFHLZM2",11,0)
 ;
"RTN","VAFHLZM2",12,0)
 ;
"RTN","VAFHLZM2",13,0)
OEIF ;Build Operation Enduring/Iraqi Freedom segments
"RTN","VAFHLZM2",14,0)
 ;
"RTN","VAFHLZM2",15,0)
 N VAFDATA,VAFFROM,VAFIDX,VAFNODE,VAFSITE,VAFTO,VAFTYPE
"RTN","VAFHLZM2",16,0)
 ;
"RTN","VAFHLZM2",17,0)
 ;need to build segment even if no data in OEIF array 
"RTN","VAFHLZM2",18,0)
 S $P(VAFY,VAFHLS,2)="OEIF"
"RTN","VAFHLZM2",19,0)
 I VAFSTR[",3," S $P(VAFY,VAFHLS,3)=VAFHLQ_$E(VAFHLC)_VAFHLQ
"RTN","VAFHLZM2",20,0)
 I VAFSTR[",4," S $P(VAFY,VAFHLS,4)=VAFHLQ_$E(VAFHLC)_VAFHLQ
"RTN","VAFHLZM2",21,0)
 I VAFSTR[",5," S $P(VAFY,VAFHLS,5)=VAFHLQ
"RTN","VAFHLZM2",22,0)
 Q:'$D(VAFOPS)
"RTN","VAFHLZM2",23,0)
 ;
"RTN","VAFHLZM2",24,0)
 ;if data in OEIF array, build segment for each episode
"RTN","VAFHLZM2",25,0)
 S (VAFNODE,VAFIDX)=0
"RTN","VAFHLZM2",26,0)
 F  S VAFNODE=$O(VAFOPS(VAFNODE)) Q:'$G(VAFNODE)  D
"RTN","VAFHLZM2",27,0)
 .;
"RTN","VAFHLZM2",28,0)
 .S VAFDATA=$G(VAFOPS(VAFNODE))
"RTN","VAFHLZM2",29,0)
 .;
"RTN","VAFHLZM2",30,0)
 .I VAFSTR[",3," D
"RTN","VAFHLZM2",31,0)
 ..S VAFTYPE=$$EXTERNAL^DILFD(2.3215,.01,"F",$P(VAFDATA,U,1)) I VAFTYPE']"" S VAFTYPE=VAFHLQ
"RTN","VAFHLZM2",32,0)
 ..S VAFSITE=$$STATION^VAFHLFNC($P(VAFDATA,U,6)) I VAFSITE="" S VAFSITE=VAFHLQ
"RTN","VAFHLZM2",33,0)
 ..S $P(VAFY,VAFHLS,3)=VAFTYPE_$E(VAFHLC)_VAFSITE
"RTN","VAFHLZM2",34,0)
 .;
"RTN","VAFHLZM2",35,0)
 .I VAFSTR[",4," D
"RTN","VAFHLZM2",36,0)
 ..S VAFFROM=$P(VAFDATA,U,2) S VAFFROM=$S(VAFFROM:$$HLDATE^HLFNC(VAFFROM),1:VAFHLQ)
"RTN","VAFHLZM2",37,0)
 ..S VAFTO=$P(VAFDATA,U,3) S VAFTO=$S(VAFTO:$$HLDATE^HLFNC(VAFTO),1:VAFHLQ)
"RTN","VAFHLZM2",38,0)
 ..S $P(VAFY,VAFHLS,4)=VAFFROM_$E(VAFHLC)_VAFTO
"RTN","VAFHLZM2",39,0)
 .;
"RTN","VAFHLZM2",40,0)
 .I VAFSTR[",5," D
"RTN","VAFHLZM2",41,0)
 ..S $P(VAFY,VAFHLS,5)=VAFHLQ
"RTN","VAFHLZM2",42,0)
 .;
"RTN","VAFHLZM2",43,0)
 .;put segment into array
"RTN","VAFHLZM2",44,0)
 .S VAFIDX=VAFIDX+1
"RTN","VAFHLZM2",45,0)
 .S VAFY(VAFIDX)=$G(VAFY)
"RTN","VAFHLZM2",46,0)
 ;
"RTN","VAFHLZM2",47,0)
 Q
"RTN","VAFHLZM2",48,0)
 ;
"RTN","VAFHLZM2",49,0)
 ;
"RTN","VAFHLZM2",50,0)
NOSEG ;
"RTN","VAFHLZM2",51,0)
 Q
"RTN","VAFHLZMH")
0^26^B17707490
"RTN","VAFHLZMH",1,0)
VAFHLZMH ;BAY/JAT - Create HL7 Military History segment (ZMH) ; 11/20/00 2:14pm
"RTN","VAFHLZMH",2,0)
 ;;5.3;Registration;**190,314,673**;Aug 13, 1993
"RTN","VAFHLZMH",3,0)
 ;
"RTN","VAFHLZMH",4,0)
 ; This routine creates HL7 VA-specific Military History ("ZMH") segments
"RTN","VAFHLZMH",5,0)
 Q
"RTN","VAFHLZMH",6,0)
 ;
"RTN","VAFHLZMH",7,0)
EN(DFN,VAFHMIEN,VAFSTR) ; RAI/MDS Reserved entry point!!
"RTN","VAFHLZMH",8,0)
 ; !!!!!!!!!! don't enter here !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"RTN","VAFHLZMH",9,0)
 ;DFN - Patient Internal Entry Number
"RTN","VAFHLZMH",10,0)
 ;VAFHMIEN - Patient Movement Internal Entry Number
"RTN","VAFHLZMH",11,0)
 ;VAFSTR - Sequence numbers to be included
"RTN","VAFHLZMH",12,0)
 ;
"RTN","VAFHLZMH",13,0)
 N VAFHLREC,VAFHA,VAFHSUB,VAFHADD,VAFHLOC S VAFHSUB="" ;Initialize variables
"RTN","VAFHLZMH",14,0)
 S $P(VAFHLREC,HL("FS"))="ZMH" ;Set segment ID to ZMH
"RTN","VAFHLZMH",15,0)
 S $P(VAFHLREC,HL("FS"),2)=1 ;Set Set ID to 1
"RTN","VAFHLZMH",16,0)
 I VAFSTR[",4," S $P(VAFHLREC,HL("FS"),5)=$$HLDATE^HLFNC($$GET1^DIQ(2,DFN,".326","I"))_$E(HL("ECH"))_$$HLDATE^HLFNC($$GET1^DIQ(2,DFN,".327","I")) ;Last Service Entry and Separation dates
"RTN","VAFHLZMH",17,0)
 Q VAFHLREC ;Quit and return formatted segment
"RTN","VAFHLZMH",18,0)
 ; 
"RTN","VAFHLZMH",19,0)
ENTER(DFN,VAFARRAY,VAFTYPE,VAFSTR,VAFHLS,VAFHLC,VAFHLQ)       ;
"RTN","VAFHLZMH",20,0)
 ; DFN is the only required parameter.  Defaults are used if no
"RTN","VAFHLZMH",21,0)
 ; values are passed for the other parameters.
"RTN","VAFHLZMH",22,0)
 ; Output:
"RTN","VAFHLZMH",23,0)
 ; VAFARRAY = array name to hold the "ZMH" segments.
"RTN","VAFHLZMH",24,0)
 ;            Default is ^TMP("VAFHLZMH",$J)
"RTN","VAFHLZMH",25,0)
 ; Input:
"RTN","VAFHLZMH",26,0)
 ; DFN = internal entry number (IEN) of Patient (#2) file
"RTN","VAFHLZMH",27,0)
 ; VAFTYPE = Military History type desired (separated by commas) where
"RTN","VAFHLZMH",28,0)
 ;            1=Last Service branch (SL)
"RTN","VAFHLZMH",29,0)
 ;            2=Next to last Service branch (SNL)
"RTN","VAFHLZMH",30,0)
 ;            3=Next to next to last Service branch (SNNL)
"RTN","VAFHLZMH",31,0)
 ;            4=Prisoner of War Status indicated? (POW)
"RTN","VAFHLZMH",32,0)
 ;            5=Combat Service indicated? (COMB)
"RTN","VAFHLZMH",33,0)
 ;            6=Vietnam Service indicated? (VIET)
"RTN","VAFHLZMH",34,0)
 ;            7=Lebanon Service indicated? (LEBA)
"RTN","VAFHLZMH",35,0)
 ;            8=Grenada Service indicated? (GREN)
"RTN","VAFHLZMH",36,0)
 ;            9=Panama Service indicated? (PANA)
"RTN","VAFHLZMH",37,0)
 ;           10=Persian Gulf Service indicated? (GULF)
"RTN","VAFHLZMH",38,0)
 ;           11=Somalia Service indicated? (SOMA)    
"RTN","VAFHLZMH",39,0)
 ;           12=Yugoslavia Service indicated? (YUGO)
"RTN","VAFHLZMH",40,0)
 ;           13=Purple Heart Receipient? (PH)
"RTN","VAFHLZMH",41,0)
 ;           14=Operation Enduring/Iraqi Freedom (OEIF)
"RTN","VAFHLZMH",42,0)
 ;          A range of numbers separated by colons can be sent 
"RTN","VAFHLZMH",43,0)
 ;                  (e.g. 1:4,8,10:12) 
"RTN","VAFHLZMH",44,0)
 ;          Default is all(1,2,3...)
"RTN","VAFHLZMH",45,0)
 ; VAFSTR = Fields (sequence numbers) desired (separated by comma) where
"RTN","VAFHLZMH",46,0)
 ;          3=qualifier #1 (Service branch if VAFTYPE is 1,2 or 3
"RTN","VAFHLZMH",47,0)
 ;                         or Yes/No response if VAFTYPE is 4 thru 13)
"RTN","VAFHLZMH",48,0)
 ;            qualifier #2 (Service number if VAFTYPE is 1,2 or 3
"RTN","VAFHLZMH",49,0)
 ;                         or Location if VAFTYPE is 4 or 5)
"RTN","VAFHLZMH",50,0)
 ;                         or 
"RTN","VAFHLZMH",51,0)
 ;            qualifier #3 (Service discharge type if VAFTYPE is 1,2
"RTN","VAFHLZMH",52,0)
 ;                          or 3)
"RTN","VAFHLZMH",53,0)
 ;          4=From/To Date range for each VAFTYPE
"RTN","VAFHLZMH",54,0)
 ;          5=Service Component
"RTN","VAFHLZMH",55,0)
 ;          Default is 3,4,5
"RTN","VAFHLZMH",56,0)
 ; VAFHLS = HL7 field separator (1 character)
"RTN","VAFHLZMH",57,0)
 ;          Default is ^ (carrot)
"RTN","VAFHLZMH",58,0)
 ; VAFHLC = HL7 encoding characters (4 characters must be supplied)
"RTN","VAFHLZMH",59,0)
 ;          Default is ~|\& (tilde bar backslash ampersand)
"RTN","VAFHLZMH",60,0)
 ; VAFHLQ = HL7 null designation 
"RTN","VAFHLZMH",61,0)
 ;          Default is "" (quote quote)
"RTN","VAFHLZMH",62,0)
 ; 
"RTN","VAFHLZMH",63,0)
 ; Check input and apply default values as needed
"RTN","VAFHLZMH",64,0)
 S VAFARRAY=$G(VAFARRAY) I VAFARRAY="" S VAFARRAY=$NA(^TMP("VAFHLZMH",$J))
"RTN","VAFHLZMH",65,0)
 K @VAFARRAY
"RTN","VAFHLZMH",66,0)
 S VAFTYPE=$G(VAFTYPE) I VAFTYPE="" S VAFTYPE="1,2,3,4,5,6,7,8,9,10,11,12,13,14"
"RTN","VAFHLZMH",67,0)
 S VAFSTR=$G(VAFSTR) I VAFSTR="" S VAFSTR="3,4,5"
"RTN","VAFHLZMH",68,0)
 S VAFHLS=$G(VAFHLS) I VAFHLS="" S VAFHLS="^"
"RTN","VAFHLZMH",69,0)
 S:($L(VAFHLS)'=1) VAFHLS="^"
"RTN","VAFHLZMH",70,0)
 S VAFHLC=$G(VAFHLC) I VAFHLC="" S VAFHLC="~|\&"
"RTN","VAFHLZMH",71,0)
 S:($L(VAFHLC)'=4) VAFHLC="~|\&"
"RTN","VAFHLZMH",72,0)
 S:('$D(VAFHLQ)) VAFHLQ=$C(34,34)
"RTN","VAFHLZMH",73,0)
 I '$G(DFN) D NOGO Q
"RTN","VAFHLZMH",74,0)
 I '$D(^DPT(DFN,0)) D NOGO Q
"RTN","VAFHLZMH",75,0)
 S VAFSTR=$TR(VAFSTR,":",",")
"RTN","VAFHLZMH",76,0)
 I VAFSTR'=3,VAFSTR'=4,VAFSTR'=5,VAFSTR'="3,4",VAFSTR'="3,5",VAFSTR'="4,5",VAFSTR'="3,4,5" D NOGO Q
"RTN","VAFHLZMH",77,0)
 S VAFSTR=","_VAFSTR_","
"RTN","VAFHLZMH",78,0)
 I '$$EDIT(VAFTYPE) D NOGO Q
"RTN","VAFHLZMH",79,0)
 I VAFTYPE[":" D UNCRUNCH
"RTN","VAFHLZMH",80,0)
 ; it's a Go
"RTN","VAFHLZMH",81,0)
 N VAFY,VAFX,VAFZ,VAFINDX,VAFTAG
"RTN","VAFHLZMH",82,0)
 S VAFINDX=0
"RTN","VAFHLZMH",83,0)
 ; set all the Patient file nodes that may be needed
"RTN","VAFHLZMH",84,0)
 N VAF32N,VAF321N,VAF322N,VAF52N,VAF53N,VAF3291N
"RTN","VAFHLZMH",85,0)
 S VAF32N=$G(^DPT(DFN,.32)) ; used for Service branches
"RTN","VAFHLZMH",86,0)
 S VAF321N=$G(^DPT(DFN,.321)) ; used for Vietnam
"RTN","VAFHLZMH",87,0)
 S VAF322N=$G(^DPT(DFN,.322)) ; used for minor skirmishes
"RTN","VAFHLZMH",88,0)
 S VAF3291N=$G(^DPT(DFN,.3291)) ;used for service component
"RTN","VAFHLZMH",89,0)
 S VAF52N=$G(^DPT(DFN,.52)) ; used for POW and Combat
"RTN","VAFHLZMH",90,0)
 S VAF53N=$G(^DPT(DFN,.53)) ;used for Purple Heart
"RTN","VAFHLZMH",91,0)
 ;used for Operation Enduring/Iraqi Freedom
"RTN","VAFHLZMH",92,0)
 N VAFOPS,VAFREC,VAFSUB
"RTN","VAFHLZMH",93,0)
 S (VAFREC,VAFSUB)=0
"RTN","VAFHLZMH",94,0)
 ;set operations into local array since there may be mult OEIF episodes
"RTN","VAFHLZMH",95,0)
 F  S VAFREC=$O(^DPT(DFN,.3215,VAFREC)) Q:'$G(VAFREC)  D
"RTN","VAFHLZMH",96,0)
 . S VAFSUB=VAFSUB+1
"RTN","VAFHLZMH",97,0)
 . S VAFOPS(VAFSUB)=$G(^DPT(DFN,.3215,VAFREC,0))
"RTN","VAFHLZMH",98,0)
 ;
"RTN","VAFHLZMH",99,0)
 D ENTER^VAFHLZM1
"RTN","VAFHLZMH",100,0)
 ;
"RTN","VAFHLZMH",101,0)
 Q
"RTN","VAFHLZMH",102,0)
 ;
"RTN","VAFHLZMH",103,0)
EDIT(X)  ; function validates VAFTYP (returns 1 if valid)        
"RTN","VAFHLZMH",104,0)
 N P,Q,R,CNT,Z,Z1,Z2,ERR S ERR=0
"RTN","VAFHLZMH",105,0)
 S X=$G(X)
"RTN","VAFHLZMH",106,0)
 I X>0,X<15,X?.N Q 1 ; only 1 number and between 1-14
"RTN","VAFHLZMH",107,0)
 I X'[":",X'["," Q 0 ; comma not used as separator
"RTN","VAFHLZMH",108,0)
 I X'?.NP Q 0 ; contains letters or control characters
"RTN","VAFHLZMH",109,0)
 ; contains punctuation other than comma/colon
"RTN","VAFHLZMH",110,0)
 S P="!#$%&'()*+-./;<=>?@[\]^_`{|]~"
"RTN","VAFHLZMH",111,0)
 F CNT=1:1 S Z=$E(X,CNT) Q:Z=""  I P[Z S ERR=1 Q
"RTN","VAFHLZMH",112,0)
 I ERR=1 Q 0
"RTN","VAFHLZMH",113,0)
 S Q="",R=""""
"RTN","VAFHLZMH",114,0)
 I Q[X!R[X Q 0
"RTN","VAFHLZMH",115,0)
 ; checks that numbers are >0<15
"RTN","VAFHLZMH",116,0)
 F CNT=1:1 S Z=$P(X,",",CNT) Q:Z=""  D
"RTN","VAFHLZMH",117,0)
 .I Z'[":",Z>0,Z<15 Q
"RTN","VAFHLZMH",118,0)
 .S Z1=$P(Z,":",1),Z2=$P(Z,":",2)
"RTN","VAFHLZMH",119,0)
 .I Z1>0,Z1<15,Z2>0,Z2<15 Q
"RTN","VAFHLZMH",120,0)
 .S ERR=1
"RTN","VAFHLZMH",121,0)
 I ERR=1 Q 0
"RTN","VAFHLZMH",122,0)
 Q 1
"RTN","VAFHLZMH",123,0)
 ;
"RTN","VAFHLZMH",124,0)
UNCRUNCH ; reformat VAFTYPE by translating any range of numbers,
"RTN","VAFHLZMH",125,0)
 ; for example replace "1:3,6,9:11" by "1,2,3,6,9,10,11,"
"RTN","VAFHLZMH",126,0)
 N X,Y,Z,A,B S Y=""
"RTN","VAFHLZMH",127,0)
 F X=1:1 S Z=$P(VAFTYPE,",",X) Q:Z=""  D
"RTN","VAFHLZMH",128,0)
 .I Z'[":" S Y=Y_Z_"," Q
"RTN","VAFHLZMH",129,0)
 .S A=$P(Z,":",1),B=$P(Z,":",2)
"RTN","VAFHLZMH",130,0)
 .S Y=Y_A_","
"RTN","VAFHLZMH",131,0)
 .F  S A=A+1 Q:A>B  S Y=Y_A_","
"RTN","VAFHLZMH",132,0)
 S VAFTYPE=Y
"RTN","VAFHLZMH",133,0)
 Q
"RTN","VAFHLZMH",134,0)
NOGO ;
"RTN","VAFHLZMH",135,0)
 S @VAFARRAY@(1,0)="ZMH"_VAFHLS_1
"RTN","VAFHLZMH",136,0)
 Q
"UP",2,2.3215,-1)
2^.3215
"UP",2,2.3215,0)
2.3215
"VER")
8.0^22.0
"^DD",2,2,.3215,0)
SERVICE [OEF OR OIF]^2.3215IS^^.3215;0
"^DD",2,2,.3215,12)
Users cannot enter 3 (UNSPECIFIED)
"^DD",2,2,.3215,12.1)
S DIC("S")="I Y'=3"
"^DD",2,2,.3215,21,0)
^.001^5^5^3060508^^^^
"^DD",2,2,.3215,21,1,0)
This contains the information relating to the deployment of the
"^DD",2,2,.3215,21,2,0)
patient to a conflict location for the operations Iraqi and Enduring
"^DD",2,2,.3215,21,3,0)
Freedom (OIF, OEF respectively).  It also includes records of conflict
"^DD",2,2,.3215,21,4,0)
that can be identified as being EITHER OIF OR OEF, but the specific
"^DD",2,2,.3215,21,5,0)
location cannot be determined.
"^DD",2,2,.3215,"DT")
3060104
"^DD",2,2,.325,0)
SERVICE BRANCH [LAST]^P23'X^DIC(23,^.32;5^S DFN=DA K:X=$O(^DIC(23,"B","B.E.C.","")) X I $D(X) D SV^DGLOCK S DGCOMBR=$G(Y) Q
"^DD",2,2,.325,.1)
BRANCH OF SERVICE, LAST
"^DD",2,2,.325,1,0)
^.1
"^DD",2,2,.325,1,1,0)
2^AODS4^MUMPS
"^DD",2,2,.325,1,1,1)
S A1B2TAG="PAT" D ^A1B2XFR
"^DD",2,2,.325,1,1,2)
S A1B2TAG="PAT" D ^A1B2XFR
"^DD",2,2,.325,1,2,0)
2^AFV1^MUMPS
"^DD",2,2,.325,1,2,1)
Q
"^DD",2,2,.325,1,2,2)
I $P($G(^DPT(DA,.321)),U,14)]"" D FVP^DGRPMS
"^DD",2,2,.325,1,2,"%D",0)
^.101^4^4^3040325^^^^
"^DD",2,2,.325,1,2,"%D",1,0)
This MUMPS cross-reference acts like a trigger cross-reference.
"^DD",2,2,.325,1,2,"%D",2,0)
If the Service Branch [Last], Service Branch [NTL] and Service Branch [NNTL]
"^DD",2,2,.325,1,2,"%D",3,0)
fields do not contain a Filipino Veteran branch of service, the Filipino
"^DD",2,2,.325,1,2,"%D",4,0)
Vet Proof field (#.3214) is deleted.
"^DD",2,2,.325,1,2,"DT")
3040325
"^DD",2,2,.325,1,3,0)
2^AENR325^MUMPS
"^DD",2,2,.325,1,3,1)
D EVENT^IVMPLOG(DA)
"^DD",2,2,.325,1,3,2)
D EVENT^IVMPLOG(DA)
"^DD",2,2,.325,1,3,"%D",0)
^^2^2^3040610^
"^DD",2,2,.325,1,3,"%D",1,0)
This MUMPS cross-reference is used to notify HEC of changes to the
"^DD",2,2,.325,1,3,"%D",2,0)
SERVICE BRANCH [LAST] field.
"^DD",2,2,.325,1,3,"DT")
3040610
"^DD",2,2,.325,1,4,0)
2^AXR34^MUMPS
"^DD",2,2,.325,1,4,1)
Q
"^DD",2,2,.325,1,4,2)
S DGXRF=.325 D ^DGDDC Q
"^DD",2,2,.325,1,4,"DT")
3050912
"^DD",2,2,.325,3)
Select from the listing the branch in which this patient served during his last episode of military service.
"^DD",2,2,.325,20,0)
^.3LA^1^1
"^DD",2,2,.325,20,1,0)
SVC
"^DD",2,2,.325,21,0)
^.001^5^5^3060104^^^
"^DD",2,2,.325,21,1,0)
For this veteran applicant select from the available listing
"^DD",2,2,.325,21,2,0)
the branch of service served in during his/her most recent
"^DD",2,2,.325,21,3,0)
episode of military service.  Once the service record is verified
"^DD",2,2,.325,21,4,0)
only those users who hold the designated security key may
"^DD",2,2,.325,21,5,0)
enter/edit this field.
"^DD",2,2,.325,"DEL",1,0)
S DFN=DA D SV^DGLOCK I '$D(X)
"^DD",2,2,.325,"DT")
3051104
"^DD",2,2,.3291,0)
SERVICE BRANCH [NTL]^P23'X^DIC(23,^.32;10^S DFN=DA K:X=$O(^DIC(23,"B","B.E.C.","")) X I $D(X) D SER1^DGLOCK S DGCOMBR=$G(Y) Q
"^DD",2,2,.3291,.1)
BRANCH OF SERVICE, NTL
"^DD",2,2,.3291,1,0)
^.1
"^DD",2,2,.3291,1,1,0)
2^AFV2^MUMPS
"^DD",2,2,.3291,1,1,1)
Q
"^DD",2,2,.3291,1,1,2)
I $P($G(^DPT(DA,.321)),U,14)]"" D FVP^DGRPMS
"^DD",2,2,.3291,1,1,"%D",0)
^.101^4^4^3040331^^
"^DD",2,2,.3291,1,1,"%D",1,0)
This MUMPS cross-reference acts like a trigger cross-reference.
"^DD",2,2,.3291,1,1,"%D",2,0)
If the Service Branch [Last], Service Branch [NTL] and Service Branch [NNTL]
"^DD",2,2,.3291,1,1,"%D",3,0)
fields do not contain a Filipino Veteran branch of service, the Filipino
"^DD",2,2,.3291,1,1,"%D",4,0)
Vet Proof field (#.3214) is deleted.
"^DD",2,2,.3291,1,1,"DT")
3040325
"^DD",2,2,.3291,1,2,0)
2^AENR3291^MUMPS
"^DD",2,2,.3291,1,2,1)
D EVENT^IVMPLOG(DA)
"^DD",2,2,.3291,1,2,2)
D EVENT^IVMPLOG(DA)
"^DD",2,2,.3291,1,2,"%D",0)
^^2^2^3040610^
"^DD",2,2,.3291,1,2,"%D",1,0)
This MUMPS cross-reference is used to notify HEC of changes to the
"^DD",2,2,.3291,1,2,"%D",2,0)
SERVICE BRANCH [NTL] field.
"^DD",2,2,.3291,1,2,"DT")
3040610
"^DD",2,2,.3291,1,3,0)
2^AXR35^MUMPS
"^DD",2,2,.3291,1,3,1)
Q
"^DD",2,2,.3291,1,3,2)
S DGXRF=.3291 D ^DGDDC Q
"^DD",2,2,.3291,1,3,"%D",0)
^^2^2^3060718^
"^DD",2,2,.3291,1,3,"%D",1,0)
This xref is used to delete the SERVICE COMPONENT [NTL] field if the
"^DD",2,2,.3291,1,3,"%D",2,0)
SERVICE BRANCH [NTL] field is changed or deleted.
"^DD",2,2,.3291,1,3,"DT")
3060718
"^DD",2,2,.3291,3)
Enter the branch of service in which the patient served in his next-to-last episode of military service.
"^DD",2,2,.3291,5,1,0)
2^.3285^3
"^DD",2,2,.3291,20,0)
^.3LA^1^1
"^DD",2,2,.3291,20,1,0)
SVC
"^DD",2,2,.3291,21,0)
^.001^7^7^3050909^^^^
"^DD",2,2,.3291,21,1,0)
For this veteran applicant who has at least two episodes of military
"^DD",2,2,.3291,21,2,0)
service (ANY OTHER PERIODS OF SERVICE prompt must be answered YES)
"^DD",2,2,.3291,21,3,0)
select from the available listing the branch of service s/he served
"^DD",2,2,.3291,21,4,0)
in during his/her next to last episode of military service.  Once the
"^DD",2,2,.3291,21,5,0)
service record is verified only those users who hold the designated
"^DD",2,2,.3291,21,6,0)
security key may enter/edit this field.  This field cannot be deleted
"^DD",2,2,.3291,21,7,0)
as long as more than one episode of military service is indicated.
"^DD",2,2,.3291,"DEL",1,0)
S DFN=DA D SV^DGLOCK I '$D(X)
"^DD",2,2,.3291,"DT")
3060718
"^DD",2,2,.32911,0)
SERVICE COMPONENT [LAST]^*S^R:REGULAR;V:ACTIVATED RESERVE;G:ACTIVATED NG;^.3291;1^Q
"^DD",2,2,.32911,1,0)
^.1
"^DD",2,2,.32911,1,1,0)
2^AENR32911^MUMPS
"^DD",2,2,.32911,1,1,1)
D EVENT^IVMPLOG(DA)
"^DD",2,2,.32911,1,1,2)
D EVENT^IVMPLOG(DA)
"^DD",2,2,.32911,1,1,"%D",0)
^^2^2^3050909^
"^DD",2,2,.32911,1,1,"%D",1,0)
This MUMPS cross-reference is used to notify HEC of changes to the
"^DD",2,2,.32911,1,1,"%D",2,0)
SERVICE COMPONENT [LAST] field.
"^DD",2,2,.32911,1,1,"DT")
3050909
"^DD",2,2,.32911,3)
Enter the military service component of the patient for the most recent military service episode.
"^DD",2,2,.32911,12)
Component must be consistent with branch of service, branch of service is required to enter component
"^DD",2,2,.32911,12.1)
S DIC("S")="I $$VALCOMP^DGRPMS(DA,Y,1)"
"^DD",2,2,.32911,21,0)
^.001^5^5^3050919^^^^
"^DD",2,2,.32911,21,1,0)
For this veteran applicant enter the military service component for
"^DD",2,2,.32911,21,2,0)
his/her most recent episode of military service.  Once the service
"^DD",2,2,.32911,21,3,0)
record has been verified only those users who hold the designated 
"^DD",2,2,.32911,21,4,0)
security key may enter/edit this field.
"^DD",2,2,.32911,21,5,0)
NATIONAL GUARD IS ONLY VALID FOR BRANCH OF SERVICE ARMY AND AIR FORCE.
"^DD",2,2,.32911,"DT")
3050919
"^DD",2,2,.32912,0)
SERVICE COMPONENT [NTL]^*SX^R:REGULAR;V:ACTIVATED RESERVE;G:ACTIVATED NG;^.3291;2^Q
"^DD",2,2,.32912,.1)

"^DD",2,2,.32912,1,0)
^.1
"^DD",2,2,.32912,1,1,0)
2^AENR32912^MUMPS
"^DD",2,2,.32912,1,1,1)
D EVENT^IVMPLOG(DA)
"^DD",2,2,.32912,1,1,2)
D EVENT^IVMPLOG(DA)
"^DD",2,2,.32912,1,1,"%D",0)
^^2^2^3050909^
"^DD",2,2,.32912,1,1,"%D",1,0)
This MUMPS cross-reference is used to notify HEC of changes to the
"^DD",2,2,.32912,1,1,"%D",2,0)
SERVICE COMPONENT [NTL] field.
"^DD",2,2,.32912,1,1,"DT")
3050909
"^DD",2,2,.32912,3)
Enter the military service component of the patient for the next to last military service episode.
"^DD",2,2,.32912,5,1,0)
2^.3291^3
"^DD",2,2,.32912,12)
Component must be consistent with branch of service, branch of service is required to enter component
"^DD",2,2,.32912,12.1)
S DIC("S")="I $$VALCOMP^DGRPMS(DA,Y,2)"
"^DD",2,2,.32912,21,0)
^.001^8^8^3050912^^^^
"^DD",2,2,.32912,21,1,0)
For this veteran applicant who has at least two episodes of military
"^DD",2,2,.32912,21,2,0)
service (ANOTHER PERIOD OF SERVICE prompt must be answered YES) enter
"^DD",2,2,.32912,21,3,0)
the military service component for the next to last episode of
"^DD",2,2,.32912,21,4,0)
service.  Once the service record is verified only those users who
"^DD",2,2,.32912,21,5,0)
hold the designated security key may enter/edit this field.  This field 
"^DD",2,2,.32912,21,6,0)
cannot be deleted as long as more than two episodes of military service
"^DD",2,2,.32912,21,7,0)
are indicated.
"^DD",2,2,.32912,21,8,0)
NATIONAL GUARD IS ONLY VALID FOR BRANCH OF SERVICE ARMY AND AIR FORCE.
"^DD",2,2,.32912,"DT")
3050919
"^DD",2,2,.32913,0)
SERVICE COMPONENT [NNTL]^*SX^R:REGULAR;V:ACTIVATED RESERVE;G:ACTIVATED NG;^.3291;3^Q
"^DD",2,2,.32913,1,0)
^.1
"^DD",2,2,.32913,1,1,0)
2^AENR32913^MUMPS
"^DD",2,2,.32913,1,1,1)
D EVENT^IVMPLOG(DA)
"^DD",2,2,.32913,1,1,2)
D EVENT^IVMPLOG(DA)
"^DD",2,2,.32913,1,1,"%D",0)
^^2^2^3050909^
"^DD",2,2,.32913,1,1,"%D",1,0)
This MUMPS cross-reference is used to notify HEC of changes to the
"^DD",2,2,.32913,1,1,"%D",2,0)
SERVICE COMPONENT [NNTL] field.
"^DD",2,2,.32913,1,1,"DT")
3050909
"^DD",2,2,.32913,3)
Enter the military service component of the patient for the third most recent military service episode.
"^DD",2,2,.32913,5,1,0)
2^.3296^3
"^DD",2,2,.32913,12)
Component must be consistent with branch of service, branch of service is required to enter component
"^DD",2,2,.32913,12.1)
S DIC("S")="I $$VALCOMP^DGRPMS(DA,Y,3)"
"^DD",2,2,.32913,21,0)
^.001^8^8^3050919^^^^
"^DD",2,2,.32913,21,1,0)
For this veteran applicant who has at least three episodes of military
"^DD",2,2,.32913,21,2,0)
service (ANOTHER PERIOD OF SERVICE prompt must be answered YES) enter
"^DD",2,2,.32913,21,3,0)
the military service component for the third most recent episode of
"^DD",2,2,.32913,21,4,0)
service.  Once the service record is verified only those users who hold
"^DD",2,2,.32913,21,5,0)
the designated security key may enter/edit this field.  This field cannot
"^DD",2,2,.32913,21,6,0)
be deleted as long as more than two episodes of military service are
"^DD",2,2,.32913,21,7,0)
indicated.
"^DD",2,2,.32913,21,8,0)
NATIONAL GUARD IS ONLY VALID FOR BRANCH OF SERVICE ARMY AND AIR FORCE.
"^DD",2,2,.32913,"DT")
3050919
"^DD",2,2,.3296,0)
SERVICE BRANCH [NNTL]^P23'X^DIC(23,^.32;15^S DFN=DA K:X=$O(^DIC(23,"B","B.E.C.","")) X I $D(X) D SER2^DGLOCK S DGCOMBR=$G(Y) Q
"^DD",2,2,.3296,.1)
BRANCH OF SERVICE, NNTL
"^DD",2,2,.3296,1,0)
^.1^^-1
"^DD",2,2,.3296,1,1,0)
2^AFV3^MUMPS
"^DD",2,2,.3296,1,1,1)
Q
"^DD",2,2,.3296,1,1,2)
I $P($G(^DPT(DA,.321)),U,14)]"" D FVP^DGRPMS
"^DD",2,2,.3296,1,1,"%D",0)
^^4^4^3040325^
"^DD",2,2,.3296,1,1,"%D",1,0)
This MUMPS cross-reference acts like a trigger cross-reference.
"^DD",2,2,.3296,1,1,"%D",2,0)
If the Service Branch [Last], Service Branch [NTL] and Service Branch [NNTL]
"^DD",2,2,.3296,1,1,"%D",3,0)
fields do not contain a Filipino Veteran branch of service, the Filipino
"^DD",2,2,.3296,1,1,"%D",4,0)
Vet Proof field (#.3214) is deleted.
"^DD",2,2,.3296,1,1,"DT")
3040325
"^DD",2,2,.3296,1,2,0)
2^AENR3296^MUMPS
"^DD",2,2,.3296,1,2,1)
D EVENT^IVMPLOG(DA)
"^DD",2,2,.3296,1,2,2)
D EVENT^IVMPLOG(DA)
"^DD",2,2,.3296,1,2,"%D",0)
^^2^2^3040610^
"^DD",2,2,.3296,1,2,"%D",1,0)
This MUMPS cross-reference is used to notify HEC of changes to the
"^DD",2,2,.3296,1,2,"%D",2,0)
SERVICE BRANCH [NNTL] field.
"^DD",2,2,.3296,1,2,"DT")
3040610
"^DD",2,2,.3296,1,3,0)
^^TRIGGER^2^.32913
"^DD",2,2,.3296,1,3,1)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(1)=$S($D(^DPT(D0,.3291)):^(.3291),1:"") S X=$P(Y(1),U,3),X=X S DIU=X K Y S X="" S DIH=$G(^DPT(DIV(0),.3291)),DIV=X S $P(^(.3291),U,3)=DIV,DIH=2,DIG=.32913 D ^DICR
"^DD",2,2,.3296,1,3,2)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(1)=$S($D(^DPT(D0,.3291)):^(.3291),1:"") S X=$P(Y(1),U,3),X=X S DIU=X K Y S X="" S DIH=$G(^DPT(DIV(0),.3291)),DIV=X S $P(^(.3291),U,3)=DIV,DIH=2,DIG=.32913 D ^DICR
"^DD",2,2,.3296,1,3,"%D",0)
^^1^1^3050912^
"^DD",2,2,.3296,1,3,"%D",1,0)
Deletes the COMPONENT field if the branch of service is changed or deleted.
"^DD",2,2,.3296,1,3,"CREATE VALUE")
@
"^DD",2,2,.3296,1,3,"DELETE VALUE")
@
"^DD",2,2,.3296,1,3,"DT")
3050912
"^DD",2,2,.3296,1,3,"FIELD")
SERVICE COMPONENT [NNTL]
"^DD",2,2,.3296,1,4,0)
2^AXR36^MUMPS
"^DD",2,2,.3296,1,4,1)
Q
"^DD",2,2,.3296,1,4,2)
S DGXRF=.3296 D ^DGDDC Q
"^DD",2,2,.3296,1,4,"DT")
3050912
"^DD",2,2,.3296,3)
For this third episode of military service enter the branch in which this patient served.
"^DD",2,2,.3296,5,1,0)
2^.32945^2
"^DD",2,2,.3296,20,0)
^.3LA^1^1
"^DD",2,2,.3296,20,1,0)
SVC
"^DD",2,2,.3296,21,0)
^.001^7^7^3050909^^^^
"^DD",2,2,.3296,21,1,0)
For this veteran applicant who has at least three episodes of military
"^DD",2,2,.3296,21,2,0)
service (ANOTHER PERIOD OF SERVICE prompt must be answered YES) select
"^DD",2,2,.3296,21,3,0)
from the available listing the service branch served in during his/her
"^DD",2,2,.3296,21,4,0)
third most recent episode of service.  Once the service record is
"^DD",2,2,.3296,21,5,0)
verified only those users who hold the designated security key may
"^DD",2,2,.3296,21,6,0)
enter/edit this field.  This field cannot be deleted as long as more
"^DD",2,2,.3296,21,7,0)
than two episodes of military service are indicated.
"^DD",2,2,.3296,"DEL",1,0)
S DFN=DA D SV^DGLOCK I '$D(X)
"^DD",2,2,.3296,"DT")
3060104
"^DD",2,2.3215,0)
SERVICE [OEF OR OIF] SUB-FIELD^^.06^6
"^DD",2,2.3215,0,"DT")
3060627
"^DD",2,2.3215,0,"ID",.02)
W "   ",$$FMTE^DILIBF($P(^(0),U,2),5)
"^DD",2,2.3215,0,"ID",.03)
W "   ",$$FMTE^DILIBF($P(^(0),U,3),5)
"^DD",2,2.3215,0,"IX","AENR321501",2.3215,.01)

"^DD",2,2.3215,0,"IX","AENR321502",2.3215,.02)

"^DD",2,2.3215,0,"IX","AENR321503",2.3215,.03)

"^DD",2,2.3215,0,"IX","B",2.3215,.01)

"^DD",2,2.3215,0,"NM","SERVICE [OEF OR OIF]")

"^DD",2,2.3215,0,"UP")
2
"^DD",2,2.3215,.01,0)
LOCATION OF SERVICE^*S^1:OIF;2:OEF;3:UNKNOWN OEF/OIF;^0;1^Q
"^DD",2,2.3215,.01,1,0)
^.1
"^DD",2,2.3215,.01,1,1,0)
2.3215^B
"^DD",2,2.3215,.01,1,1,1)
S ^DPT(DA(1),.3215,"B",$E(X,1,30),DA)=""
"^DD",2,2.3215,.01,1,1,2)
K ^DPT(DA(1),.3215,"B",$E(X,1,30),DA)
"^DD",2,2.3215,.01,1,2,0)
2.3215^AENR321501^MUMPS
"^DD",2,2.3215,.01,1,2,1)
D EVENT^IVMPLOG(DA(1))
"^DD",2,2.3215,.01,1,2,2)
D EVENT^IVMPLOG(DA(1))
"^DD",2,2.3215,.01,1,2,"%D",0)
^^2^2^3060123^
"^DD",2,2.3215,.01,1,2,"%D",1,0)
This MUMPS cross-reference is used to notify HEC of changes to the
"^DD",2,2.3215,.01,1,2,"%D",2,0)
LOCATION OF SERVICE field.
"^DD",2,2.3215,.01,1,2,"DT")
3060123
"^DD",2,2.3215,.01,3)
Enter OEF or OIF operation where this patient was in combat.
"^DD",2,2.3215,.01,12)
CANNOT CHANGE THE LOCATION ONCE SET
"^DD",2,2.3215,.01,12.1)
S DIC("S")="I $P($G(^DPT(DA(1),.3215,DA,0)),U),$P(^(0),U)=Y"
"^DD",2,2.3215,.01,21,0)
^.001^2^2^3060627^^^^
"^DD",2,2.3215,.01,21,1,0)
This is the operation in which the patient was in combat during the
"^DD",2,2.3215,.01,21,2,0)
specified time period.
"^DD",2,2.3215,.01,"DT")
3060627
"^DD",2,2.3215,.02,0)
OEF/OIF FROM DATE^DX^^0;2^S %DT="E" D ^%DT S X=Y I $D(X) K:'$$VALCON1^DGRPMS(DA(1),DA,X,0) X I $D(X) S DFN=DA(1) D OEIF^DGLOCK S:$D(X) DGFRDT=X
"^DD",2,2.3215,.02,1,0)
^.1
"^DD",2,2.3215,.02,1,1,0)
2.3215^AENR321502^MUMPS
"^DD",2,2.3215,.02,1,1,1)
D EVENT^IVMPLOG(DA(1))
"^DD",2,2.3215,.02,1,1,2)
D EVENT^IVMPLOG(DA(1))
"^DD",2,2.3215,.02,1,1,"%D",0)
^^2^2^3060123^
"^DD",2,2.3215,.02,1,1,"%D",1,0)
This MUMPS cross-reference is used to notify HEC of changes to the
"^DD",2,2.3215,.02,1,1,"%D",2,0)
OEF/OIF FROM DATE field.
"^DD",2,2.3215,.02,1,1,"DT")
3060123
"^DD",2,2.3215,.02,3)
Enter the date the patient was deployed to the OEF/OIF area, if known.  Otherwise, enter the military pay start date for this OEF/OIF deployment.
"^DD",2,2.3215,.02,21,0)
^.001^10^10^3060508^^^^
"^DD",2,2.3215,.02,21,1,0)
If the service indicated is OEF or UNKNOWN OEF/OIF, this date must be on
"^DD",2,2.3215,.02,21,2,0)
or after 9/01/2001 and the end date must be after 9/11/2001.  If the
"^DD",2,2.3215,.02,21,3,0)
service indicated is OIF, this date must be on or after 3/01/2003 and
"^DD",2,2.3215,.02,21,4,0)
the end date must be after 3/19/2003.
"^DD",2,2.3215,.02,21,5,0)
 
"^DD",2,2.3215,.02,21,6,0)
The meaning of this date depends on where the information was obtained
"^DD",2,2.3215,.02,21,7,0)
from.  If the data came from the VIS, Environmental Medicine or FHIE
"^DD",2,2.3215,.02,21,8,0)
systems, this is the start date of military pay for the assignment to
"^DD",2,2.3215,.02,21,9,0)
the OEF/OIF operation.  If it came from any other source, it is the date
"^DD",2,2.3215,.02,21,10,0)
the patient was actually deployed to the OEF/OIF area.
"^DD",2,2.3215,.02,"DT")
3060313
"^DD",2,2.3215,.03,0)
OEF/OIF TO DATE^DX^^0;3^S %DT="E" D ^%DT S X=Y I $D(X) K:'$$VALCON1^DGRPMS(DA(1),DA,X,1) X I $D(X) S DFN=DA(1) D OEIF^DGLOCK
"^DD",2,2.3215,.03,1,0)
^.1
"^DD",2,2.3215,.03,1,1,0)
2.3215^AENR321503^MUMPS
"^DD",2,2.3215,.03,1,1,1)
D EVENT^IVMPLOG(DA(1))
"^DD",2,2.3215,.03,1,1,2)
D EVENT^IVMPLOG(DA(1))
"^DD",2,2.3215,.03,1,1,"%D",0)
^^2^2^3060123^
"^DD",2,2.3215,.03,1,1,"%D",1,0)
This MUMPS cross-reference is used to notify HEC of changes to the
"^DD",2,2.3215,.03,1,1,"%D",2,0)
OEF/OIF TO DATE field.
"^DD",2,2.3215,.03,1,1,"DT")
3060123
"^DD",2,2.3215,.03,3)
Enter the date the patient left the OEF/OIF area if known.  Otherwise, enter the end date of military pay for this OEF/OIF deployment.
"^DD",2,2.3215,.03,4)

"^DD",2,2.3215,.03,21,0)
^.001^9^9^3060322^^^^
"^DD",2,2.3215,.03,21,1,0)
If the service indicated is OEF or UNKNOWN OEF/OIF, this date must be on
"^DD",2,2.3215,.03,21,2,0)
or after 9/11/2001. If the service indicated is OIF, this date must be on
"^DD",2,2.3215,.03,21,3,0)
or after 3/19/2003.
"^DD",2,2.3215,.03,21,4,0)
 
"^DD",2,2.3215,.03,21,5,0)
The meaning of this date depends on where the information was obtained
"^DD",2,2.3215,.03,21,6,0)
from.  If the data came from the VIS, Environmental Medicine or FHIE
"^DD",2,2.3215,.03,21,7,0)
systems, this is the military pay end date for the assignment to
"^DD",2,2.3215,.03,21,8,0)
the OEF/OIF operation.  If it came from any other source, it is the date
"^DD",2,2.3215,.03,21,9,0)
the patient actually left the OEF/OIF area.
"^DD",2,2.3215,.03,"DT")
3060313
"^DD",2,2.3215,.04,0)
DATA LOCKED^S^0:NO;1:YES;^0;4^Q
"^DD",2,2.3215,.04,3)
Enter YES (1) to lock the data in VistA so no changes or deletions can be made.
"^DD",2,2.3215,.04,21,0)
^.001^3^3^3051017^^
"^DD",2,2.3215,.04,21,1,0)
This is a flag that indicates the data is 'locked' at the site and can't
"^DD",2,2.3215,.04,21,2,0)
be changed or deleted.  This flag is set to 1 if the source of the data
"^DD",2,2.3215,.04,21,3,0)
is the HEC system.
"^DD",2,2.3215,.04,"DT")
3051017
"^DD",2,2.3215,.05,0)
RECORDED DATE/TIME^D^^0;5^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",2,2.3215,.05,3)
Enter the date/time this data was last entered/updated.
"^DD",2,2.3215,.05,21,0)
^.001^1^1^3051025^^
"^DD",2,2.3215,.05,21,1,0)
This is a time stamp for when the data was last added/updated.
"^DD",2,2.3215,.05,"DT")
3050909
"^DD",2,2.3215,.06,0)
ENTERED BY SITE^*P4'^DIC(4,^0;6^S DIC("S")="I $P($G(^(99)),""^"")]""""" D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",2,2.3215,.06,3)
Enter the facility where the data for this episode was entered.
"^DD",2,2.3215,.06,12)
Facility must have a station number assigned.
"^DD",2,2.3215,.06,12.1)
S DIC("S")="I $P($G(^(99)),""^"")]"""""
"^DD",2,2.3215,.06,21,0)
^.001^3^3^3051118^^^^
"^DD",2,2.3215,.06,21,1,0)
This is the facility where the data was originally entered.  If the
"^DD",2,2.3215,.06,21,2,0)
data's source was not from a facility, it will be assumed to be generated
"^DD",2,2.3215,.06,21,3,0)
from HEC (CEV) and this field will be blank.
"^DD",2,2.3215,.06,"DT")
3051116
**INSTALL NAME**
IVM*2.0*114
"BLD",6421,0)
IVM*2.0*114^INCOME VERIFICATION MATCH^0^3060718^y
"BLD",6421,1,0)
^^2^2^3060308^
"BLD",6421,1,1,0)
Please refer to patch IVM*2*114 in the National Patch Module for a 
"BLD",6421,1,2,0)
complete description of this patch.
"BLD",6421,4,0)
^9.64PA^^
"BLD",6421,"KRN",0)
^9.67PA^8989.52^19
"BLD",6421,"KRN",.4,0)
.4
"BLD",6421,"KRN",.401,0)
.401
"BLD",6421,"KRN",.402,0)
.402
"BLD",6421,"KRN",.403,0)
.403
"BLD",6421,"KRN",.5,0)
.5
"BLD",6421,"KRN",.84,0)
.84
"BLD",6421,"KRN",3.6,0)
3.6
"BLD",6421,"KRN",3.8,0)
3.8
"BLD",6421,"KRN",9.2,0)
9.2
"BLD",6421,"KRN",9.8,0)
9.8
"BLD",6421,"KRN",9.8,"NM",0)
^9.68A^1^1
"BLD",6421,"KRN",9.8,"NM",1,0)
IVMPTRN8^^0^B53803799
"BLD",6421,"KRN",9.8,"NM","B","IVMPTRN8",1)

"BLD",6421,"KRN",19,0)
19
"BLD",6421,"KRN",19.1,0)
19.1
"BLD",6421,"KRN",101,0)
101
"BLD",6421,"KRN",409.61,0)
409.61
"BLD",6421,"KRN",771,0)
771
"BLD",6421,"KRN",870,0)
870
"BLD",6421,"KRN",8989.51,0)
8989.51
"BLD",6421,"KRN",8989.52,0)
8989.52
"BLD",6421,"KRN",8994,0)
8994
"BLD",6421,"KRN","B",.4,.4)

"BLD",6421,"KRN","B",.401,.401)

"BLD",6421,"KRN","B",.402,.402)

"BLD",6421,"KRN","B",.403,.403)

"BLD",6421,"KRN","B",.5,.5)

"BLD",6421,"KRN","B",.84,.84)

"BLD",6421,"KRN","B",3.6,3.6)

"BLD",6421,"KRN","B",3.8,3.8)

"BLD",6421,"KRN","B",9.2,9.2)

"BLD",6421,"KRN","B",9.8,9.8)

"BLD",6421,"KRN","B",19,19)

"BLD",6421,"KRN","B",19.1,19.1)

"BLD",6421,"KRN","B",101,101)

"BLD",6421,"KRN","B",409.61,409.61)

"BLD",6421,"KRN","B",771,771)

"BLD",6421,"KRN","B",870,870)

"BLD",6421,"KRN","B",8989.51,8989.51)

"BLD",6421,"KRN","B",8989.52,8989.52)

"BLD",6421,"KRN","B",8994,8994)

"BLD",6421,"QUES",0)
^9.62^^
"BLD",6421,"REQB",0)
^9.611^1^1
"BLD",6421,"REQB",1,0)
IVM*2.0*109^2
"BLD",6421,"REQB","B","IVM*2.0*109",1)

"MBREQ")
0
"PKG",220,-1)
1^1
"PKG",220,0)
INCOME VERIFICATION MATCH^IVM^IVM Software for interface with the IVM Center
"PKG",220,20,0)
^9.402P^^
"PKG",220,22,0)
^9.49I^1^1
"PKG",220,22,1,0)
2.0^2941021
"PKG",220,22,1,"PAH",1,0)
114^3060718^539
"PKG",220,22,1,"PAH",1,1,0)
^^2^2^3060718
"PKG",220,22,1,"PAH",1,1,1,0)
Please refer to patch IVM*2*114 in the National Patch Module for a 
"PKG",220,22,1,"PAH",1,1,2,0)
complete description of this patch.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
1
"RTN","IVMPTRN8")
0^1^B53803799
"RTN","IVMPTRN8",1,0)
IVMPTRN8 ;ALB/RKS/PDJ/BRM/TDM - HL7 FULL DATA TRANSMISSION (Z07) BUILDER ; 8/11/05 9:56am
"RTN","IVMPTRN8",2,0)
 ;;2.0;INCOME VERIFICATION MATCH;**9,11,19,12,21,17,24,36,37,47,48,42,34,77,76,75,79,85,89,98,56,97,104,113,109,114**; 21-OCT-94
"RTN","IVMPTRN8",3,0)
 ;
"RTN","IVMPTRN8",4,0)
 ;
"RTN","IVMPTRN8",5,0)
BUILD(DFN,IVMMTDT,IVMCT,IVMQUERY) ; --
"RTN","IVMPTRN8",6,0)
 ;  Description: This entry point will be used to create an HL7 
"RTN","IVMPTRN8",7,0)
 ;  "Full Data Transmission" message for a patient.
"RTN","IVMPTRN8",8,0)
 ;
"RTN","IVMPTRN8",9,0)
 ;  Input:
"RTN","IVMPTRN8",10,0)
 ;        DFN - Patient IEN
"RTN","IVMPTRN8",11,0)
 ;    IVMMTDT - date of the patient's Means Test or Copay Test
"RTN","IVMPTRN8",12,0)
 ;      IVMCT - count of hl7 segments transmitted, pass by reference
"RTN","IVMPTRN8",13,0)
 ;   IVMQUERY - array passed in by reference where
"RTN","IVMPTRN8",14,0)
 ;    IVMQUERY("LTD") -- # of the QUERY that is currently open or
"RTN","IVMPTRN8",15,0)
 ;                undefined, zero, or null if no QUERY opened for
"RTN","IVMPTRN8",16,0)
 ;                last treatment date
"RTN","IVMPTRN8",17,0)
 ;    IVMQUERY("OVIS") -- # of the QUERY that is currently open or
"RTN","IVMPTRN8",18,0)
 ;                undefined, zero, or null if no QUERY opened for
"RTN","IVMPTRN8",19,0)
 ;                finding outpatient visits
"RTN","IVMPTRN8",20,0)
 ;
"RTN","IVMPTRN8",21,0)
 ;  HL7 variables as defined by call to INIT^IVMUFNC:
"RTN","IVMPTRN8",22,0)
 ;      HLEVN - HL7 message event counter 
"RTN","IVMPTRN8",23,0)
 ;      HLSDT - a flag that indicates that the data to be sent is
"RTN","IVMPTRN8",24,0)
 ;              stored in the ^TMP("HLS") global array.
"RTN","IVMPTRN8",25,0)
 ;
"RTN","IVMPTRN8",26,0)
 ;  The following variables returned by the INIT^HLTRANS entry point:
"RTN","IVMPTRN8",27,0)
 ;    HLNDAP - Non-DHCP Application Pointer from file 770
"RTN","IVMPTRN8",28,0)
 ;   HLNDAP0 - Zero node from file 770 corresponding to HLNDAP
"RTN","IVMPTRN8",29,0)
 ;     HLDAP - DHCP Application Pointer from file 771
"RTN","IVMPTRN8",30,0)
 ;     HLDAN - The DHCP Application Name (.01 field, file 771) for HLDAP
"RTN","IVMPTRN8",31,0)
 ;     HLPID - HL7 processing ID from file 770
"RTN","IVMPTRN8",32,0)
 ;     HLVER - HL7 version number from file 770
"RTN","IVMPTRN8",33,0)
 ;      HLFS - HL7 Field Separator from the 'FS' node of file 771
"RTN","IVMPTRN8",34,0)
 ;     HLECH - HL7 Encoding Characters from the 'EC' node of file 771
"RTN","IVMPTRN8",35,0)
 ;       HLQ - Double quotes ("") for use in building HL7 segments
"RTN","IVMPTRN8",36,0)
 ;     HLERR - if an error is encountered, an error message is returned
"RTN","IVMPTRN8",37,0)
 ;             in the HLERR variable.
"RTN","IVMPTRN8",38,0)
 ;      HLDA - the internal entry number for the entry created in
"RTN","IVMPTRN8",39,0)
 ;             file #772.
"RTN","IVMPTRN8",40,0)
 ;      HLDT - transmission date/time (associated with the entry in file
"RTN","IVMPTRN8",41,0)
 ;             #772 identified by HLDA) in internal VA FileMan format.
"RTN","IVMPTRN8",42,0)
 ;     HLDT1 - the same transmission date/time as the HLDT variable, 
"RTN","IVMPTRN8",43,0)
 ;             only in HL7 format.
"RTN","IVMPTRN8",44,0)
 ;
"RTN","IVMPTRN8",45,0)
 ; Output:
"RTN","IVMPTRN8",46,0)
 ;  ^TMP("HLS",$J,IVMCT) - global array containing all segments of the HL7 message that the VistA application wishes to send.  The HLSDT variable is defined above and the IVMCT variable is a sequential number incremented by 1.
"RTN","IVMPTRN8",47,0)
 ;
"RTN","IVMPTRN8",48,0)
 ;
"RTN","IVMPTRN8",49,0)
 N DGINC,DGIR,DGREL,I,IVMNTE,IVMPID,IVMSUB,IVMZRD,VAFPID,VAFZEL,FBZFE,IVMZCD,DELETE,NODE,IVMPIEN,TEST,IVMPNODE,TESTTYPE,SEQS,TESTCODE,HARDSHIP,ACTVIEN,IVMZMH,IVMSEQ
"RTN","IVMPTRN8",50,0)
 N EDBMTZ06,ZMHSQ,SETID
"RTN","IVMPTRN8",51,0)
 ;
"RTN","IVMPTRN8",52,0)
 ; create (PID) Patient Identification segment
"RTN","IVMPTRN8",53,0)
 S IVMSEQ="3,5,7,8,11,12,13,14,19"
"RTN","IVMPTRN8",54,0)
 ; do not transmit seq 11 and 12 if the Bad Address Indicator is set
"RTN","IVMPTRN8",55,0)
 ; or other address filters do not pass
"RTN","IVMPTRN8",56,0)
 S:$$FILTER^IVMPTRN9(DFN) IVMSEQ="3,5,7,8,13,14,19"
"RTN","IVMPTRN8",57,0)
 S IVMPID=$$EN^VAFHLPID(DFN,"1,"_IVMSEQ)        ;add SEQ 1 for PID
"RTN","IVMPTRN8",58,0)
 ;
"RTN","IVMPTRN8",59,0)
 ; **** Add ICN to 2nd piece PID segment for MPI@HEC.
"RTN","IVMPTRN8",60,0)
 S IVMCMOR="1,2"
"RTN","IVMPTRN8",61,0)
 ; check to see if site is a legacy site.  If not add ICN to PID segment.
"RTN","IVMPTRN8",62,0)
 I '$D(^PPP(1020.128,"AC",$P($$SITE^VASITE,"^",3))) D
"RTN","IVMPTRN8",63,0)
 .I +$$GETICN^MPIF001(DFN)>0,($$IFLOCAL^MPIF001(DFN)=0) S IVMPID=$$EN^VAFCPID(DFN,"1,2,"_IVMSEQ),IVMCMOR="1,2,3"  ;add SEQ 1 and 2 for PID
"RTN","IVMPTRN8",64,0)
 ;
"RTN","IVMPTRN8",65,0)
 I $D(VAFPID(1)) S IVMPID(1)=VAFPID(1)
"RTN","IVMPTRN8",66,0)
 ; send SSN indicating pseudo
"RTN","IVMPTRN8",67,0)
 ; I $P(IVMPID_$G(IVMPID(1)),HLFS,20)["P" D PSEUDO^IVMPTRN1  ; strip 'P' from pseudo SSNs
"RTN","IVMPTRN8",68,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=IVMPID
"RTN","IVMPTRN8",69,0)
 I $D(IVMPID(1)) S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=IVMPID(1)
"RTN","IVMPTRN8",70,0)
 ;
"RTN","IVMPTRN8",71,0)
 ; **** create (PD1) Patient CMOR segment for MPI@HEC.
"RTN","IVMPTRN8",72,0)
 S:'$D(HL("FS")) HL("FS")=HLFS
"RTN","IVMPTRN8",73,0)
 S:'$D(HL("ECH")) HL("ECH")=HLECH
"RTN","IVMPTRN8",74,0)
 S:'$D(HL("Q")) HL("Q")=HLQ
"RTN","IVMPTRN8",75,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLPD1(DFN,IVMCMOR)
"RTN","IVMPTRN8",76,0)
 ;
"RTN","IVMPTRN8",77,0)
 ; create (ZPD) Patient Dependent Info. segment
"RTN","IVMPTRN8",78,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN1^VAFHLZPD(DFN,"1,8,9,11,12,13,17,19,31,32,33,40"),IVMINS=$P(^(IVMCT),HLFS,12)
"RTN","IVMPTRN8",79,0)
 ;
"RTN","IVMPTRN8",80,0)
 ; create (ZTA) Temporary Address segment
"RTN","IVMPTRN8",81,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZTA(DFN,"1,2,3,4,5,6,7")
"RTN","IVMPTRN8",82,0)
 ;
"RTN","IVMPTRN8",83,0)
 ; create (ZIE) Ineligible segment
"RTN","IVMPTRN8",84,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZIE(DFN,"1,2,3",1)
"RTN","IVMPTRN8",85,0)
 ;
"RTN","IVMPTRN8",86,0)
 ; create (ZEL) Eligibility segment(s) 
"RTN","IVMPTRN8",87,0)
 ; **** Add 5th piece to ZEL to correct consistency check
"RTN","IVMPTRN8",88,0)
 D EN1^VAFHLZEL(DFN,"1,2,5,6,7,10,11,13,14,15,16,17,18,19,20,21,22,23,24,25,29,34,35,37,38,39",2,.VAFZEL)
"RTN","IVMPTRN8",89,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$G(VAFZEL(1))  ; Primary Eligibility
"RTN","IVMPTRN8",90,0)
 I $D(VAFZEL(1,1)) S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=VAFZEL(1,1)
"RTN","IVMPTRN8",91,0)
 ; - other entitled eligibilities
"RTN","IVMPTRN8",92,0)
 F IVMSUB=1:0 S IVMSUB=+$O(VAFZEL(IVMSUB)) Q:'IVMSUB  D
"RTN","IVMPTRN8",93,0)
 .S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$G(VAFZEL(+IVMSUB))
"RTN","IVMPTRN8",94,0)
 ;
"RTN","IVMPTRN8",95,0)
 ; create (ZEN) Enrollment segment
"RTN","IVMPTRN8",96,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZEN(DFN)
"RTN","IVMPTRN8",97,0)
 ;
"RTN","IVMPTRN8",98,0)
 ; create (ZCD) Catastrophic Disability segment(s)
"RTN","IVMPTRN8",99,0)
 D BUILD^VAFHLZCD(.IVMZCD,DFN,,HLQ,HLFS)
"RTN","IVMPTRN8",100,0)
 F IVMSUB=0:0 S IVMSUB=+$O(IVMZCD(IVMSUB)) Q:'IVMSUB  D
"RTN","IVMPTRN8",101,0)
 .S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$G(IVMZCD(+IVMSUB))
"RTN","IVMPTRN8",102,0)
 ;
"RTN","IVMPTRN8",103,0)
 ; Optionally create (ZMH) Military History segments
"RTN","IVMPTRN8",104,0)
 D ENTER^VAFHLZMH(DFN,"IVMZMH")
"RTN","IVMPTRN8",105,0)
 S (ZMHSQ,SETID)=0
"RTN","IVMPTRN8",106,0)
 I $D(IVMZMH) F  S ZMHSQ=$O(IVMZMH(ZMHSQ)) Q:ZMHSQ=""  D
"RTN","IVMPTRN8",107,0)
 .Q:$TR($P(IVMZMH(ZMHSQ,0),HLFS,4,5),"""^~")=""
"RTN","IVMPTRN8",108,0)
 .S SETID=SETID+1,IVMCT=IVMCT+1
"RTN","IVMPTRN8",109,0)
 .S ^TMP("HLS",$J,IVMCT)="ZMH"_HLFS_SETID_HLFS_$P(IVMZMH(ZMHSQ,0),HLFS,3,6)
"RTN","IVMPTRN8",110,0)
 ;
"RTN","IVMPTRN8",111,0)
 ; create (ZRD) Rated Disabilities segment(s)
"RTN","IVMPTRN8",112,0)
 D EN^VAFHLZRD(DFN,"1,2,3,4",HLQ,HLFS,"IVMZRD")
"RTN","IVMPTRN8",113,0)
 F IVMSUB=0:0 S IVMSUB=+$O(IVMZRD(IVMSUB)) Q:'IVMSUB  D
"RTN","IVMPTRN8",114,0)
 .S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$G(IVMZRD(+IVMSUB,0))
"RTN","IVMPTRN8",115,0)
 ;
"RTN","IVMPTRN8",116,0)
 ; create (ZCT) Emergency Contact segment
"RTN","IVMPTRN8",117,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZCT(DFN,"1,2,3,4,5,6,7")
"RTN","IVMPTRN8",118,0)
 ;
"RTN","IVMPTRN8",119,0)
 ; create (ZEM) Employment Info. segment for (1) Patient & (2) Spouse
"RTN","IVMPTRN8",120,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZEM(DFN,"1,2,3")
"RTN","IVMPTRN8",121,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZEM(DFN,"1,2,3",2,2)
"RTN","IVMPTRN8",122,0)
 ;
"RTN","IVMPTRN8",123,0)
 ; create (ZGD) Guardian segment for (1) VA & (2) Civil 
"RTN","IVMPTRN8",124,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZGD(DFN,"1,2,3,4,5,6,7,8",1)
"RTN","IVMPTRN8",125,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZGD(DFN,"1,2,3,4,5,6,7,8",2)
"RTN","IVMPTRN8",126,0)
 ;
"RTN","IVMPTRN8",127,0)
 ; Income Year requiring transmission from IVM Patient File (301.5)
"RTN","IVMPTRN8",128,0)
 S IVMIY=$S($D(IVMIY):IVMIY,1:(IVMMTDT-10000))
"RTN","IVMPTRN8",129,0)
 N MTINFO S MTINFO=$$FUT^DGMTU(DFN)
"RTN","IVMPTRN8",130,0)
 I ($E(IVMIY,1,3)+1)=$E($P(MTINFO,U,2),1,3) S IVMMTDT=$P(MTINFO,U,2)
"RTN","IVMPTRN8",131,0)
 ;get the primary test for the income year
"RTN","IVMPTRN8",132,0)
 S TESTTYPE=$$GETTYPE^IVMPTRN9(DFN,IVMMTDT,.TESTCODE,.HARDSHIP,.ACTVIEN)
"RTN","IVMPTRN8",133,0)
 ;
"RTN","IVMPTRN8",134,0)
 ; The following function call returns:
"RTN","IVMPTRN8",135,0)
 ;   - Patient Relation IEN array in DGREL
"RTN","IVMPTRN8",136,0)
 ;   - Individual Annual Income IEN array in DGINC
"RTN","IVMPTRN8",137,0)
 ;   - Income Relation IEN array in DGINR
"RTN","IVMPTRN8",138,0)
 D ALL^DGMTU21(DFN,"VSC",IVMMTDT,"IPR",ACTVIEN)
"RTN","IVMPTRN8",139,0)
 ;
"RTN","IVMPTRN8",140,0)
 S EDBMTZ06=0 I $$VERZ06^EASPTRN1(DFN) S EDBMTZ06=1
"RTN","IVMPTRN8",141,0)
 ; create (ZIC) Income segment for veteran
"RTN","IVMPTRN8",142,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZIC(+$G(DGINC("V")),"1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20")
"RTN","IVMPTRN8",143,0)
 I EDBMTZ06 S ^TMP("HLS",$J,IVMCT)="ZIC^"_$P(^TMP("HLS",$J,IVMCT),"^",2,3)
"RTN","IVMPTRN8",144,0)
 ;use IVMIY not IVMMTDT. For LTC copay exemption, IVMMTDT is not correct
"RTN","IVMPTRN8",145,0)
 S $P(^TMP("HLS",$J,IVMCT),"^",3)=$$HLDATE^HLFNC(IVMIY)
"RTN","IVMPTRN8",146,0)
 ;
"RTN","IVMPTRN8",147,0)
 ; create (ZIR) Income Relation segment for veteran
"RTN","IVMPTRN8",148,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZIR(+$G(DGINR("V")),"1,2,3,4,5,10")
"RTN","IVMPTRN8",149,0)
 I EDBMTZ06 S ^TMP("HLS",$J,IVMCT)="ZIR^1"
"RTN","IVMPTRN8",150,0)
 ;
"RTN","IVMPTRN8",151,0)
 ; create (ZDP) Patient Dependent Info. segment for spouse
"RTN","IVMPTRN8",152,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZDP(+$G(DGREL("S")),"1,2,3,4,5,6,7,8,9")
"RTN","IVMPTRN8",153,0)
 I $P(^TMP("HLS",$J,IVMCT),HLFS,3)'=HLQ,($P($G(^(IVMCT)),HLFS,6)=HLQ) D
"RTN","IVMPTRN8",154,0)
 .; - pass non-existant SSNs as 0s
"RTN","IVMPTRN8",155,0)
 .S $P(X,HLFS,6)="000000000"
"RTN","IVMPTRN8",156,0)
 ;
"RTN","IVMPTRN8",157,0)
 ; create (ZIC) Income segment for spouse
"RTN","IVMPTRN8",158,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZIC(+$G(DGINC("S")),"1,2,3,4,5,6,7,8,9,10,11,12,16,17,18,19,20")
"RTN","IVMPTRN8",159,0)
 I EDBMTZ06 S ^TMP("HLS",$J,IVMCT)="ZIC^"_$P(^TMP("HLS",$J,IVMCT),"^",2,3)
"RTN","IVMPTRN8",160,0)
 ;
"RTN","IVMPTRN8",161,0)
 ; create (ZIR) Income Relation segment for spouse
"RTN","IVMPTRN8",162,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZIR(+$G(DGINR("S")),"1,2,3")
"RTN","IVMPTRN8",163,0)
 I EDBMTZ06 S ^TMP("HLS",$J,IVMCT)="ZIR^"_$P(^TMP("HLS",$J,IVMCT),"^",2)
"RTN","IVMPTRN8",164,0)
 ;
"RTN","IVMPTRN8",165,0)
 ;
"RTN","IVMPTRN8",166,0)
 ; create ZDP, ZIC, and ZIR segments for all Means Test dependents
"RTN","IVMPTRN8",167,0)
 F IVMSUB=0:0 S IVMSUB=$O(DGREL("C",IVMSUB)) Q:'IVMSUB  D
"RTN","IVMPTRN8",168,0)
 .;
"RTN","IVMPTRN8",169,0)
 .; - create (ZDP) Dependent Info. segment for dependent child
"RTN","IVMPTRN8",170,0)
 .S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZDP(+$G(DGREL("C",IVMSUB)),"1,2,3,4,5,6,7,9")
"RTN","IVMPTRN8",171,0)
 .I $P(^TMP("HLS",$J,IVMCT),HLFS,3)'=HLQ,($P($G(^(IVMCT)),HLFS,6)=HLQ) D
"RTN","IVMPTRN8",172,0)
 ..; - pass non-existant SSNs as 0s
"RTN","IVMPTRN8",173,0)
 ..S $P(X,HLFS,6)="000000000"
"RTN","IVMPTRN8",174,0)
 .;
"RTN","IVMPTRN8",175,0)
 .; - create (ZIC) Income segment for dependent child
"RTN","IVMPTRN8",176,0)
 .S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZIC(+$G(DGINC("C",IVMSUB)),"1,2,3,4,5,6,7,8,9,10,11,12,15")
"RTN","IVMPTRN8",177,0)
 .I EDBMTZ06 S ^TMP("HLS",$J,IVMCT)="ZIC^"_$P(^TMP("HLS",$J,IVMCT),"^",2,3)
"RTN","IVMPTRN8",178,0)
 .;
"RTN","IVMPTRN8",179,0)
 .; - create (ZIR) Income Relation segment for dependent child
"RTN","IVMPTRN8",180,0)
 .S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=$$EN^VAFHLZIR(+$G(DGINR("C",IVMSUB)),"1,2,3,6,7,8,9")
"RTN","IVMPTRN8",181,0)
 .I EDBMTZ06 S ^TMP("HLS",$J,IVMCT)="ZIR^"_$P(^TMP("HLS",$J,IVMCT),"^",2)
"RTN","IVMPTRN8",182,0)
 .; 
"RTN","IVMPTRN8",183,0)
 ;
"RTN","IVMPTRN8",184,0)
 ; create (ZIO) Inpatient/Outpatient segment for veteran
"RTN","IVMPTRN8",185,0)
 S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)="ZIO^1^"_$$EN^IVMUFNC1(DFN,IVMMTDT,.IVMQUERY)_"^"_$$LTD^IVMUFNC(DFN,.IVMQUERY)
"RTN","IVMPTRN8",186,0)
 ;
"RTN","IVMPTRN8",187,0)
 ; create (NTE) Notes and Comments segment
"RTN","IVMPTRN8",188,0)
 D NTE^IVMUFNC4(DFN,.IVMNTE,IVMMTDT)
"RTN","IVMPTRN8",189,0)
 I '$D(IVMNTE) D
"RTN","IVMPTRN8",190,0)
 .S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)="NTE^1"
"RTN","IVMPTRN8",191,0)
 I $D(IVMNTE) D
"RTN","IVMPTRN8",192,0)
 .; - get notes and comments
"RTN","IVMPTRN8",193,0)
 .F IVMSUB=0:0 S IVMSUB=$O(IVMNTE(IVMSUB)) Q:'IVMSUB  D
"RTN","IVMPTRN8",194,0)
 ..S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=IVMNTE(IVMSUB)
"RTN","IVMPTRN8",195,0)
 ;
"RTN","IVMPTRN8",196,0)
 ; create (IN1) Insurance segment(s) for all active insurance
"RTN","IVMPTRN8",197,0)
 K ^TMP("VAFIN1",$J)
"RTN","IVMPTRN8",198,0)
 D EN^VAFHLIN1(DFN,"1,4,5,7,8,9,12,13,15,16,17,28,36")
"RTN","IVMPTRN8",199,0)
 F IVMSUB=0:0 S IVMSUB=$O(^TMP("VAFIN1",$J,IVMSUB)) Q:'IVMSUB  D
"RTN","IVMPTRN8",200,0)
 .S IVMCT=IVMCT+1,^TMP("HLS",$J,IVMCT)=^TMP("VAFIN1",$J,+IVMSUB,0)
"RTN","IVMPTRN8",201,0)
 ;
"RTN","IVMPTRN8",202,0)
 D GOTO^IVMPTRN9
"RTN","IVMPTRN8",203,0)
 Q
"VER")
8.0^22.0
**END**
**END**
