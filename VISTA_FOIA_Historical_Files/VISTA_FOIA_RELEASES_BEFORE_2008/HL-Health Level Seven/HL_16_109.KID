KIDS Distribution saved on Feb 12, 2004@13:19:47
HL*1.6*109
**KIDS**:HL*1.6*109^

**INSTALL NAME**
HL*1.6*109
"BLD",805,0)
HL*1.6*109^HEALTH LEVEL SEVEN^0^3040212^y
"BLD",805,1,0)
^^2^2^3040205^^
"BLD",805,1,1,0)
See patch HL*1.6*109 in the National Patch Module for complete information
"BLD",805,1,2,0)
on this patch.
"BLD",805,4,0)
^9.64PA^776.5^10
"BLD",805,4,772,0)
772
"BLD",805,4,772,2,0)
^9.641^772^1
"BLD",805,4,772,2,772,0)
HL7 MESSAGE TEXT  (File-top level)
"BLD",805,4,772,2,772,1,0)
^9.6411^2.02^1
"BLD",805,4,772,2,772,1,2.02,0)
FAST PURGE DT/TM
"BLD",805,4,772,222)
y^n^p^^^^n^^n
"BLD",805,4,773,0)
773
"BLD",805,4,773,222)
y^n^f^^^^n^^n
"BLD",805,4,776,0)
776
"BLD",805,4,776,222)
y^y^f^^^^n
"BLD",805,4,776.1,0)
776.1
"BLD",805,4,776.1,222)
y^y^f^^y^HLEV MONITOR EXPORT LIST^y^m^n
"BLD",805,4,776.1,224)
I $E($G(^HLEV(776.1,+Y,0)))'="Z"
"BLD",805,4,776.2,0)
776.2
"BLD",805,4,776.2,222)
y^y^f^^^^n
"BLD",805,4,776.3,0)
776.3
"BLD",805,4,776.3,222)
y^y^f^^y^^y^o^n
"BLD",805,4,776.3,224)
I $E($G(^HLEV(776.3,+Y,0)))'="Z"
"BLD",805,4,776.4,0)
776.4
"BLD",805,4,776.4,222)
y^y^f^^^^n
"BLD",805,4,776.5,0)
776.5
"BLD",805,4,776.5,222)
y^y^f^^^^n
"BLD",805,4,776.999,0)
776.999
"BLD",805,4,776.999,222)
y^y^f^^^^n
"BLD",805,4,869.3,0)
869.3
"BLD",805,4,869.3,2,0)
^9.641^869.3^1
"BLD",805,4,869.3,2,869.3,0)
HL COMMUNICATION SERVER PARAMETERS  (File-top level)
"BLD",805,4,869.3,2,869.3,1,0)
^9.6411^773^3
"BLD",805,4,869.3,2,869.3,1,44,0)
PURGE ERROR STATUS MESSAGES
"BLD",805,4,869.3,2,869.3,1,772,0)
LAST IEN, FILE 772
"BLD",805,4,869.3,2,869.3,1,773,0)
LAST IEN, FILE 773
"BLD",805,4,869.3,222)
y^n^p^^^^n^^n
"BLD",805,4,869.3,224)

"BLD",805,4,"APDD",772,772)

"BLD",805,4,"APDD",772,772,2.02)

"BLD",805,4,"APDD",869.3,869.3)

"BLD",805,4,"APDD",869.3,869.3,44)

"BLD",805,4,"APDD",869.3,869.3,772)

"BLD",805,4,"APDD",869.3,869.3,773)

"BLD",805,4,"B",772,772)

"BLD",805,4,"B",773,773)

"BLD",805,4,"B",776,776)

"BLD",805,4,"B",776.1,776.1)

"BLD",805,4,"B",776.2,776.2)

"BLD",805,4,"B",776.3,776.3)

"BLD",805,4,"B",776.4,776.4)

"BLD",805,4,"B",776.5,776.5)

"BLD",805,4,"B",776.999,776.999)

"BLD",805,4,"B",869.3,869.3)

"BLD",805,"ABPKG")
n
"BLD",805,"INI")
PRE^HLP109
"BLD",805,"INID")
^n^n
"BLD",805,"INIT")
POST^HLP109
"BLD",805,"KRN",0)
^9.67PA^8989.52^19
"BLD",805,"KRN",.4,0)
.4
"BLD",805,"KRN",.4,"NM",0)
^9.68A^2^2
"BLD",805,"KRN",.4,"NM",1,0)
HLEV REMOTE REQUESTABLE    FILE #776.1^776.1^0
"BLD",805,"KRN",.4,"NM",2,0)
HLEV REPORT MONITOR-ONE LINE    FILE #776.1^776.1^0
"BLD",805,"KRN",.4,"NM","B","HLEV REMOTE REQUESTABLE    FILE #776.1",1)

"BLD",805,"KRN",.4,"NM","B","HLEV REPORT MONITOR-ONE LINE    FILE #776.1",2)

"BLD",805,"KRN",.401,0)
.401
"BLD",805,"KRN",.401,"NM",0)
^9.68A^3^3
"BLD",805,"KRN",.401,"NM",1,0)
HLEV MONITOR EXPORT LIST    FILE #776.1^776.1^0
"BLD",805,"KRN",.401,"NM",2,0)
HLEV REPORT MONITOR    FILE #776.1^776.1^0
"BLD",805,"KRN",.401,"NM",3,0)
HLEV REPORT MONITOR - FF    FILE #776.1^776.1^0
"BLD",805,"KRN",.401,"NM","B","HLEV MONITOR EXPORT LIST    FILE #776.1",1)

"BLD",805,"KRN",.401,"NM","B","HLEV REPORT MONITOR    FILE #776.1",2)

"BLD",805,"KRN",.401,"NM","B","HLEV REPORT MONITOR - FF    FILE #776.1",3)

"BLD",805,"KRN",.402,0)
.402
"BLD",805,"KRN",.402,"NM",0)
^9.68A^2^2
"BLD",805,"KRN",.402,"NM",1,0)
HLEV MASTER JOB ENTER/EDIT    FILE #776.999^776.999^0
"BLD",805,"KRN",.402,"NM",2,0)
HLEV MONITOR ENTER/EDIT    FILE #776.1^776.1^0
"BLD",805,"KRN",.402,"NM","B","HLEV MASTER JOB ENTER/EDIT    FILE #776.999",1)

"BLD",805,"KRN",.402,"NM","B","HLEV MONITOR ENTER/EDIT    FILE #776.1",2)

"BLD",805,"KRN",.403,0)
.403
"BLD",805,"KRN",.403,"NM",0)
^9.68A^1^1
"BLD",805,"KRN",.403,"NM",1,0)
HL SITE PARAMETERS    FILE #869.3^869.3^0
"BLD",805,"KRN",.403,"NM","B","HL SITE PARAMETERS    FILE #869.3",1)

"BLD",805,"KRN",.5,0)
.5
"BLD",805,"KRN",.84,0)
.84
"BLD",805,"KRN",3.6,0)
3.6
"BLD",805,"KRN",3.8,0)
3.8
"BLD",805,"KRN",3.8,"NM",0)
^9.68A^2^2
"BLD",805,"KRN",3.8,"NM",1,0)
HLEV EVENT MONITOR^^0
"BLD",805,"KRN",3.8,"NM",2,0)
HLEV SERVER^^0
"BLD",805,"KRN",3.8,"NM","B","HLEV EVENT MONITOR",1)

"BLD",805,"KRN",3.8,"NM","B","HLEV SERVER",2)

"BLD",805,"KRN",9.2,0)
9.2
"BLD",805,"KRN",9.8,0)
9.8
"BLD",805,"KRN",9.8,"NM",0)
^9.68A^95^93
"BLD",805,"KRN",9.8,"NM",1,0)
HLUOPT1^^0^B57282446
"BLD",805,"KRN",9.8,"NM",2,0)
HLUOPT4^^0^B86903345
"BLD",805,"KRN",9.8,"NM",3,0)
HLUOPT5^^0^B25596832
"BLD",805,"KRN",9.8,"NM",4,0)
HLUOPT3^^0^B5260875
"BLD",805,"KRN",9.8,"NM",5,0)
HLUOPT6^^0^B30116972
"BLD",805,"KRN",9.8,"NM",6,0)
HLEVAPI^^0^B63820662
"BLD",805,"KRN",9.8,"NM",7,0)
HLEVAPI0^^0^B52756139
"BLD",805,"KRN",9.8,"NM",8,0)
HLEVAPI1^^0^B73010717
"BLD",805,"KRN",9.8,"NM",9,0)
HLEVMNU^^0^B4442942
"BLD",805,"KRN",9.8,"NM",10,0)
HLEVMST^^0^B57974007
"BLD",805,"KRN",9.8,"NM",11,0)
HLEVREP^^0^B58965492
"BLD",805,"KRN",9.8,"NM",12,0)
HLEVREP0^^0^B25914126
"BLD",805,"KRN",9.8,"NM",13,0)
HLEVSTUP^^0^B71803231
"BLD",805,"KRN",9.8,"NM",14,0)
HLEVUTIL^^0^B55321603
"BLD",805,"KRN",9.8,"NM",16,0)
HLEVX^^0^B2417562
"BLD",805,"KRN",9.8,"NM",17,0)
HLEVX000^^0^B82658939
"BLD",805,"KRN",9.8,"NM",18,0)
HLEVX001^^0^B35322440
"BLD",805,"KRN",9.8,"NM",19,0)
HLEVMST0^^0^B40889627
"BLD",805,"KRN",9.8,"NM",20,0)
HLEVAPI2^^0^B65545587
"BLD",805,"KRN",9.8,"NM",21,0)
HLEVREP1^^0^B62876882
"BLD",805,"KRN",9.8,"NM",22,0)
HLEVREP2^^0^B63366284
"BLD",805,"KRN",9.8,"NM",23,0)
HLEVREP3^^0^B40672831
"BLD",805,"KRN",9.8,"NM",24,0)
HLEVSRV^^0^B72146579
"BLD",805,"KRN",9.8,"NM",25,0)
HLCSMON1^^0^B8085567
"BLD",805,"KRN",9.8,"NM",26,0)
HLEVSRV0^^0^B78829330
"BLD",805,"KRN",9.8,"NM",27,0)
HLEVSRV1^^0^B90257561
"BLD",805,"KRN",9.8,"NM",28,0)
HLEVSRV2^^0^B50293053
"BLD",805,"KRN",9.8,"NM",29,0)
HLEVX002^^0^B29208264
"BLD",805,"KRN",9.8,"NM",30,0)
HLEVSRV3^^0^B59454255
"BLD",805,"KRN",9.8,"NM",31,0)
HLEVUTI0^^0^B63289609
"BLD",805,"KRN",9.8,"NM",32,0)
HLEVSRV4^^0^B33087391
"BLD",805,"KRN",9.8,"NM",33,0)
HLEVUTI1^^0^B73186022
"BLD",805,"KRN",9.8,"NM",34,0)
HLEME^^0^B44654046
"BLD",805,"KRN",9.8,"NM",35,0)
HLEME1^^0^B12691313
"BLD",805,"KRN",9.8,"NM",36,0)
HLEMDD^^0^B21024093
"BLD",805,"KRN",9.8,"NM",37,0)
HLEMT^^0^B4330888
"BLD",805,"KRN",9.8,"NM",38,0)
HLEMU^^0^B40415242
"BLD",805,"KRN",9.8,"NM",39,0)
HLEVAPI3^^0^B53454303
"BLD",805,"KRN",9.8,"NM",40,0)
HLCSLM^^0^B36276435
"BLD",805,"KRN",9.8,"NM",41,0)
HLEVUTI2^^0^B100658230
"BLD",805,"KRN",9.8,"NM",42,0)
HLEMEP^^0^B6558828
"BLD",805,"KRN",9.8,"NM",43,0)
HLEVUTI3^^0^B20366248
"BLD",805,"KRN",9.8,"NM",44,0)
HLEVX003^^0^B3724887
"BLD",805,"KRN",9.8,"NM",45,0)
HLUOPTF1^^0^B3550031
"BLD",805,"KRN",9.8,"NM",46,0)
HLUOPTF2^^0^B36022035
"BLD",805,"KRN",9.8,"NM",48,0)
HLCS2^^0^B38051566
"BLD",805,"KRN",9.8,"NM",49,0)
HLTP3^^0^B61824583
"BLD",805,"KRN",9.8,"NM",50,0)
HLCS^^0^B29807650
"BLD",805,"KRN",9.8,"NM",51,0)
HLCSAS1^^0^B5752372
"BLD",805,"KRN",9.8,"NM",52,0)
HLCSDR2^^0^B18988323
"BLD",805,"KRN",9.8,"NM",53,0)
HLCSLNCH^^0^B37171475
"BLD",805,"KRN",9.8,"NM",54,0)
HLCSLSM^^0^B399167
"BLD",805,"KRN",9.8,"NM",55,0)
HLCSMON^^0^B52128223
"BLD",805,"KRN",9.8,"NM",56,0)
HLCSREP^^0^B2010073
"BLD",805,"KRN",9.8,"NM",57,0)
HLCSTCP^^0^B32053075
"BLD",805,"KRN",9.8,"NM",58,0)
HLCSTCP2^^0^B55298525
"BLD",805,"KRN",9.8,"NM",59,0)
HLDIE^^0^B42269584
"BLD",805,"KRN",9.8,"NM",60,0)
HLDIE772^^0^B29083135
"BLD",805,"KRN",9.8,"NM",61,0)
HLDIE773^^0^B17013621
"BLD",805,"KRN",9.8,"NM",62,0)
HLEMP^^0^B12525830
"BLD",805,"KRN",9.8,"NM",63,0)
HLEMP1^^0^B15451416
"BLD",805,"KRN",9.8,"NM",64,0)
HLEMRCV^^0^B7228994
"BLD",805,"KRN",9.8,"NM",65,0)
HLEMSA^^0^B1693913
"BLD",805,"KRN",9.8,"NM",66,0)
HLEMSE^^0^B17561652
"BLD",805,"KRN",9.8,"NM",67,0)
HLEMSE1^^0^B261410
"BLD",805,"KRN",9.8,"NM",68,0)
HLEMSH^^0^B691486
"BLD",805,"KRN",9.8,"NM",69,0)
HLEMSL1^^0^B5096862
"BLD",805,"KRN",9.8,"NM",70,0)
HLEMSL^^0^B24311726
"BLD",805,"KRN",9.8,"NM",71,0)
HLEMSND^^0^B14118964
"BLD",805,"KRN",9.8,"NM",72,0)
HLEMST^^0^B66783747
"BLD",805,"KRN",9.8,"NM",73,0)
HLEMSU^^0^B1416722
"BLD",805,"KRN",9.8,"NM",74,0)
HLLOG^^0^B2577409
"BLD",805,"KRN",9.8,"NM",75,0)
HLMA^^0^B36061622
"BLD",805,"KRN",9.8,"NM",76,0)
HLMA0^^0^B1356890
"BLD",805,"KRN",9.8,"NM",77,0)
HLMA1^^0^B8095560
"BLD",805,"KRN",9.8,"NM",78,0)
HLMA2^^0^B37613049
"BLD",805,"KRN",9.8,"NM",79,0)
HLP109^^0^B33762179
"BLD",805,"KRN",9.8,"NM",80,0)
HLTF^^0^B49383239
"BLD",805,"KRN",9.8,"NM",81,0)
HLTF0^^0^B30082735
"BLD",805,"KRN",9.8,"NM",82,0)
HLTP2^^0^B2417166
"BLD",805,"KRN",9.8,"NM",83,0)
HLTP31^^0^B7900636
"BLD",805,"KRN",9.8,"NM",84,0)
HLTP3A^^0^B2301375
"BLD",805,"KRN",9.8,"NM",85,0)
HLUTIL^^0^B15417895
"BLD",805,"KRN",9.8,"NM",86,0)
HLUTIL3^^0^B5619301
"BLD",805,"KRN",9.8,"NM",87,0)
HLCSIN^^0^B23255981
"BLD",805,"KRN",9.8,"NM",88,0)
HLTP4^^0^B24967834
"BLD",805,"KRN",9.8,"NM",89,0)
HLCSTCP4^^0^B2712680
"BLD",805,"KRN",9.8,"NM",90,0)
HLDIEDB0^^0^B72529237
"BLD",805,"KRN",9.8,"NM",91,0)
HLDIEDB1^^0^B106657373
"BLD",805,"KRN",9.8,"NM",92,0)
HLDIEDBG^^0^B48025803
"BLD",805,"KRN",9.8,"NM",93,0)
HLDIEDB2^^0^B312034
"BLD",805,"KRN",9.8,"NM",94,0)
HLDIEDB3^^0^B5978888
"BLD",805,"KRN",9.8,"NM",95,0)
HLP109EN^^0^B6215325
"BLD",805,"KRN",9.8,"NM","B","HLCS",50)

"BLD",805,"KRN",9.8,"NM","B","HLCS2",48)

"BLD",805,"KRN",9.8,"NM","B","HLCSAS1",51)

"BLD",805,"KRN",9.8,"NM","B","HLCSDR2",52)

"BLD",805,"KRN",9.8,"NM","B","HLCSIN",87)

"BLD",805,"KRN",9.8,"NM","B","HLCSLM",40)

"BLD",805,"KRN",9.8,"NM","B","HLCSLNCH",53)

"BLD",805,"KRN",9.8,"NM","B","HLCSLSM",54)

"BLD",805,"KRN",9.8,"NM","B","HLCSMON",55)

"BLD",805,"KRN",9.8,"NM","B","HLCSMON1",25)

"BLD",805,"KRN",9.8,"NM","B","HLCSREP",56)

"BLD",805,"KRN",9.8,"NM","B","HLCSTCP",57)

"BLD",805,"KRN",9.8,"NM","B","HLCSTCP2",58)

"BLD",805,"KRN",9.8,"NM","B","HLCSTCP4",89)

"BLD",805,"KRN",9.8,"NM","B","HLDIE",59)

"BLD",805,"KRN",9.8,"NM","B","HLDIE772",60)

"BLD",805,"KRN",9.8,"NM","B","HLDIE773",61)

"BLD",805,"KRN",9.8,"NM","B","HLDIEDB0",90)

"BLD",805,"KRN",9.8,"NM","B","HLDIEDB1",91)

"BLD",805,"KRN",9.8,"NM","B","HLDIEDB2",93)

"BLD",805,"KRN",9.8,"NM","B","HLDIEDB3",94)

"BLD",805,"KRN",9.8,"NM","B","HLDIEDBG",92)

"BLD",805,"KRN",9.8,"NM","B","HLEMDD",36)

"BLD",805,"KRN",9.8,"NM","B","HLEME",34)

"BLD",805,"KRN",9.8,"NM","B","HLEME1",35)

"BLD",805,"KRN",9.8,"NM","B","HLEMEP",42)

"BLD",805,"KRN",9.8,"NM","B","HLEMP",62)

"BLD",805,"KRN",9.8,"NM","B","HLEMP1",63)

"BLD",805,"KRN",9.8,"NM","B","HLEMRCV",64)

"BLD",805,"KRN",9.8,"NM","B","HLEMSA",65)

"BLD",805,"KRN",9.8,"NM","B","HLEMSE",66)

"BLD",805,"KRN",9.8,"NM","B","HLEMSE1",67)

"BLD",805,"KRN",9.8,"NM","B","HLEMSH",68)

"BLD",805,"KRN",9.8,"NM","B","HLEMSL",70)

"BLD",805,"KRN",9.8,"NM","B","HLEMSL1",69)

"BLD",805,"KRN",9.8,"NM","B","HLEMSND",71)

"BLD",805,"KRN",9.8,"NM","B","HLEMST",72)

"BLD",805,"KRN",9.8,"NM","B","HLEMSU",73)

"BLD",805,"KRN",9.8,"NM","B","HLEMT",37)

"BLD",805,"KRN",9.8,"NM","B","HLEMU",38)

"BLD",805,"KRN",9.8,"NM","B","HLEVAPI",6)

"BLD",805,"KRN",9.8,"NM","B","HLEVAPI0",7)

"BLD",805,"KRN",9.8,"NM","B","HLEVAPI1",8)

"BLD",805,"KRN",9.8,"NM","B","HLEVAPI2",20)

"BLD",805,"KRN",9.8,"NM","B","HLEVAPI3",39)

"BLD",805,"KRN",9.8,"NM","B","HLEVMNU",9)

"BLD",805,"KRN",9.8,"NM","B","HLEVMST",10)

"BLD",805,"KRN",9.8,"NM","B","HLEVMST0",19)

"BLD",805,"KRN",9.8,"NM","B","HLEVREP",11)

"BLD",805,"KRN",9.8,"NM","B","HLEVREP0",12)

"BLD",805,"KRN",9.8,"NM","B","HLEVREP1",21)

"BLD",805,"KRN",9.8,"NM","B","HLEVREP2",22)

"BLD",805,"KRN",9.8,"NM","B","HLEVREP3",23)

"BLD",805,"KRN",9.8,"NM","B","HLEVSRV",24)

"BLD",805,"KRN",9.8,"NM","B","HLEVSRV0",26)

"BLD",805,"KRN",9.8,"NM","B","HLEVSRV1",27)

"BLD",805,"KRN",9.8,"NM","B","HLEVSRV2",28)

"BLD",805,"KRN",9.8,"NM","B","HLEVSRV3",30)

"BLD",805,"KRN",9.8,"NM","B","HLEVSRV4",32)

"BLD",805,"KRN",9.8,"NM","B","HLEVSTUP",13)

"BLD",805,"KRN",9.8,"NM","B","HLEVUTI0",31)

"BLD",805,"KRN",9.8,"NM","B","HLEVUTI1",33)

"BLD",805,"KRN",9.8,"NM","B","HLEVUTI2",41)

"BLD",805,"KRN",9.8,"NM","B","HLEVUTI3",43)

"BLD",805,"KRN",9.8,"NM","B","HLEVUTIL",14)

"BLD",805,"KRN",9.8,"NM","B","HLEVX",16)

"BLD",805,"KRN",9.8,"NM","B","HLEVX000",17)

"BLD",805,"KRN",9.8,"NM","B","HLEVX001",18)

"BLD",805,"KRN",9.8,"NM","B","HLEVX002",29)

"BLD",805,"KRN",9.8,"NM","B","HLEVX003",44)

"BLD",805,"KRN",9.8,"NM","B","HLLOG",74)

"BLD",805,"KRN",9.8,"NM","B","HLMA",75)

"BLD",805,"KRN",9.8,"NM","B","HLMA0",76)

"BLD",805,"KRN",9.8,"NM","B","HLMA1",77)

"BLD",805,"KRN",9.8,"NM","B","HLMA2",78)

"BLD",805,"KRN",9.8,"NM","B","HLP109",79)

"BLD",805,"KRN",9.8,"NM","B","HLP109EN",95)

"BLD",805,"KRN",9.8,"NM","B","HLTF",80)

"BLD",805,"KRN",9.8,"NM","B","HLTF0",81)

"BLD",805,"KRN",9.8,"NM","B","HLTP2",82)

"BLD",805,"KRN",9.8,"NM","B","HLTP3",49)

"BLD",805,"KRN",9.8,"NM","B","HLTP31",83)

"BLD",805,"KRN",9.8,"NM","B","HLTP3A",84)

"BLD",805,"KRN",9.8,"NM","B","HLTP4",88)

"BLD",805,"KRN",9.8,"NM","B","HLUOPT1",1)

"BLD",805,"KRN",9.8,"NM","B","HLUOPT3",4)

"BLD",805,"KRN",9.8,"NM","B","HLUOPT4",2)

"BLD",805,"KRN",9.8,"NM","B","HLUOPT5",3)

"BLD",805,"KRN",9.8,"NM","B","HLUOPT6",5)

"BLD",805,"KRN",9.8,"NM","B","HLUOPTF1",45)

"BLD",805,"KRN",9.8,"NM","B","HLUOPTF2",46)

"BLD",805,"KRN",9.8,"NM","B","HLUTIL",85)

"BLD",805,"KRN",9.8,"NM","B","HLUTIL3",86)

"BLD",805,"KRN",19,0)
19
"BLD",805,"KRN",19,"NM",0)
^9.68A^96^28
"BLD",805,"KRN",19,"NM",1,0)
HL MENU MSG TRANS MGT^^2
"BLD",805,"KRN",19,"NM",2,0)
HL PURGE JOB REVIEW^^0
"BLD",805,"KRN",19,"NM",3,0)
HLEV EDIT MONITOR^^0
"BLD",805,"KRN",19,"NM",4,0)
HLEV EDIT MONITOR ON-OFF^^0
"BLD",805,"KRN",19,"NM",5,0)
HLEV MENU MAIN^^0
"BLD",805,"KRN",19,"NM",6,0)
HLEV MENU RUNTIME^^0
"BLD",805,"KRN",19,"NM",7,0)
HLEV MENU SETUP^^0
"BLD",805,"KRN",19,"NM",8,0)
HLEV MENU SETUP-MASTER^^0
"BLD",805,"KRN",19,"NM",9,0)
HLEV MENU SETUP-MONITOR^^0
"BLD",805,"KRN",19,"NM",11,0)
HLEV ONE-TIME MONITOR RUN^^0
"BLD",805,"KRN",19,"NM",14,0)
HLEV MASTER JOB START^^0
"BLD",805,"KRN",19,"NM",15,0)
HLEV MASTER JOB STOP^^0
"BLD",805,"KRN",19,"NM",16,0)
HLEV MONITOR DETAILS^^0
"BLD",805,"KRN",19,"NM",17,0)
HLEV MONITOR MAP REPORT^^0
"BLD",805,"KRN",19,"NM",19,0)
HLEV PRINT MASTER SETUP^^0
"BLD",805,"KRN",19,"NM",20,0)
HLEV PRINT MONITOR SETUP^^0
"BLD",805,"KRN",19,"NM",21,0)
HLEV-INFORMATION-SERVER^^0
"BLD",805,"KRN",19,"NM",22,0)
HLEV MASTER JOB NOW^^0
"BLD",805,"KRN",19,"NM",23,0)
HLEV MENU REPORTS^^0
"BLD",805,"KRN",19,"NM",24,0)
HLEV REPORT CONDENSED MONITOR^^0
"BLD",805,"KRN",19,"NM",25,0)
HLEV REPORT MONITOR RECIPIENTS^^0
"BLD",805,"KRN",19,"NM",26,0)
HLEV REPORT REMOTE REQUESTABLE^^0
"BLD",805,"KRN",19,"NM",27,0)
HLEV GRANT REMOTE LICENSE^^0
"BLD",805,"KRN",19,"NM",28,0)
HL MAIN MENU^^2
"BLD",805,"KRN",19,"NM",45,0)
HLEV EDIT MASTER^^0
"BLD",805,"KRN",19,"NM",46,0)
HLEV EDIT MASTER ON-OFF^^0
"BLD",805,"KRN",19,"NM",95,0)
HLEM EVENT LOG SERVER^^0
"BLD",805,"KRN",19,"NM",96,0)
HLEM EVENT LOG^^0
"BLD",805,"KRN",19,"NM","B","HL MAIN MENU",28)

"BLD",805,"KRN",19,"NM","B","HL MENU MSG TRANS MGT",1)

"BLD",805,"KRN",19,"NM","B","HL PURGE JOB REVIEW",2)

"BLD",805,"KRN",19,"NM","B","HLEM EVENT LOG",96)

"BLD",805,"KRN",19,"NM","B","HLEM EVENT LOG SERVER",95)

"BLD",805,"KRN",19,"NM","B","HLEV EDIT MASTER",45)

"BLD",805,"KRN",19,"NM","B","HLEV EDIT MASTER ON-OFF",46)

"BLD",805,"KRN",19,"NM","B","HLEV EDIT MONITOR",3)

"BLD",805,"KRN",19,"NM","B","HLEV EDIT MONITOR ON-OFF",4)

"BLD",805,"KRN",19,"NM","B","HLEV GRANT REMOTE LICENSE",27)

"BLD",805,"KRN",19,"NM","B","HLEV MASTER JOB NOW",22)

"BLD",805,"KRN",19,"NM","B","HLEV MASTER JOB START",14)

"BLD",805,"KRN",19,"NM","B","HLEV MASTER JOB STOP",15)

"BLD",805,"KRN",19,"NM","B","HLEV MENU MAIN",5)

"BLD",805,"KRN",19,"NM","B","HLEV MENU REPORTS",23)

"BLD",805,"KRN",19,"NM","B","HLEV MENU RUNTIME",6)

"BLD",805,"KRN",19,"NM","B","HLEV MENU SETUP",7)

"BLD",805,"KRN",19,"NM","B","HLEV MENU SETUP-MASTER",8)

"BLD",805,"KRN",19,"NM","B","HLEV MENU SETUP-MONITOR",9)

"BLD",805,"KRN",19,"NM","B","HLEV MONITOR DETAILS",16)

"BLD",805,"KRN",19,"NM","B","HLEV MONITOR MAP REPORT",17)

"BLD",805,"KRN",19,"NM","B","HLEV ONE-TIME MONITOR RUN",11)

"BLD",805,"KRN",19,"NM","B","HLEV PRINT MASTER SETUP",19)

"BLD",805,"KRN",19,"NM","B","HLEV PRINT MONITOR SETUP",20)

"BLD",805,"KRN",19,"NM","B","HLEV REPORT CONDENSED MONITOR",24)

"BLD",805,"KRN",19,"NM","B","HLEV REPORT MONITOR RECIPIENTS",25)

"BLD",805,"KRN",19,"NM","B","HLEV REPORT REMOTE REQUESTABLE",26)

"BLD",805,"KRN",19,"NM","B","HLEV-INFORMATION-SERVER",21)

"BLD",805,"KRN",19.1,0)
19.1
"BLD",805,"KRN",19.1,"NM",0)
^9.68A^^
"BLD",805,"KRN",101,0)
101
"BLD",805,"KRN",101,"NM",0)
^9.68A^14^14
"BLD",805,"KRN",101,"NM",1,0)
HLEM CHANGE DATE RANGE^^0
"BLD",805,"KRN",101,"NM",2,0)
HLEM DISPLAY APPLICATION DATA^^0
"BLD",805,"KRN",101,"NM",3,0)
HLEM DISPLAY EVENT^^0
"BLD",805,"KRN",101,"NM",4,0)
HLEM EDIT PROFILE^^0
"BLD",805,"KRN",101,"NM",5,0)
HLEM EVENT HELP^^0
"BLD",805,"KRN",101,"NM",6,0)
HLEM EVENT STATISTICS MENU^^0
"BLD",805,"KRN",101,"NM",7,0)
HLEM GOTO SITE^^0
"BLD",805,"KRN",101,"NM",8,0)
HLEM NEW PROFILE^^0
"BLD",805,"KRN",101,"NM",9,0)
HLEM SELECT PROFILE^^0
"BLD",805,"KRN",101,"NM",10,0)
HLEM SELECT PROFILE (STATS)^^0
"BLD",805,"KRN",101,"NM",11,0)
HLEM SINGLE EVENT MENU^^0
"BLD",805,"KRN",101,"NM",12,0)
HLEM STATISTICS^^0
"BLD",805,"KRN",101,"NM",13,0)
HLEM EDIT EVENT^^0
"BLD",805,"KRN",101,"NM",14,0)
HLEM EVENTS MENU^^0
"BLD",805,"KRN",101,"NM","B","HLEM CHANGE DATE RANGE",1)

"BLD",805,"KRN",101,"NM","B","HLEM DISPLAY APPLICATION DATA",2)

"BLD",805,"KRN",101,"NM","B","HLEM DISPLAY EVENT",3)

"BLD",805,"KRN",101,"NM","B","HLEM EDIT EVENT",13)

"BLD",805,"KRN",101,"NM","B","HLEM EDIT PROFILE",4)

"BLD",805,"KRN",101,"NM","B","HLEM EVENT HELP",5)

"BLD",805,"KRN",101,"NM","B","HLEM EVENT STATISTICS MENU",6)

"BLD",805,"KRN",101,"NM","B","HLEM EVENTS MENU",14)

"BLD",805,"KRN",101,"NM","B","HLEM GOTO SITE",7)

"BLD",805,"KRN",101,"NM","B","HLEM NEW PROFILE",8)

"BLD",805,"KRN",101,"NM","B","HLEM SELECT PROFILE",9)

"BLD",805,"KRN",101,"NM","B","HLEM SELECT PROFILE (STATS)",10)

"BLD",805,"KRN",101,"NM","B","HLEM SINGLE EVENT MENU",11)

"BLD",805,"KRN",101,"NM","B","HLEM STATISTICS",12)

"BLD",805,"KRN",409.61,0)
409.61
"BLD",805,"KRN",409.61,"NM",0)
^9.68A^5^5
"BLD",805,"KRN",409.61,"NM",1,0)
HLEM DISPLAY APPLICATION DATA^^0
"BLD",805,"KRN",409.61,"NM",2,0)
HLEM DISPLAY EVENTS^^0
"BLD",805,"KRN",409.61,"NM",3,0)
HLEM DISPLAY ONE EVENT^^0
"BLD",805,"KRN",409.61,"NM",4,0)
HLEM DISPLAY STATISTICS^^0
"BLD",805,"KRN",409.61,"NM",5,0)
HLEM EVENT HELP^^0
"BLD",805,"KRN",409.61,"NM","B","HLEM DISPLAY APPLICATION DATA",1)

"BLD",805,"KRN",409.61,"NM","B","HLEM DISPLAY EVENTS",2)

"BLD",805,"KRN",409.61,"NM","B","HLEM DISPLAY ONE EVENT",3)

"BLD",805,"KRN",409.61,"NM","B","HLEM DISPLAY STATISTICS",4)

"BLD",805,"KRN",409.61,"NM","B","HLEM EVENT HELP",5)

"BLD",805,"KRN",771,0)
771
"BLD",805,"KRN",771,"NM",0)
^9.68A^^
"BLD",805,"KRN",870,0)
870
"BLD",805,"KRN",8989.51,0)
8989.51
"BLD",805,"KRN",8989.52,0)
8989.52
"BLD",805,"KRN",8994,0)
8994
"BLD",805,"KRN","B",.4,.4)

"BLD",805,"KRN","B",.401,.401)

"BLD",805,"KRN","B",.402,.402)

"BLD",805,"KRN","B",.403,.403)

"BLD",805,"KRN","B",.5,.5)

"BLD",805,"KRN","B",.84,.84)

"BLD",805,"KRN","B",3.6,3.6)

"BLD",805,"KRN","B",3.8,3.8)

"BLD",805,"KRN","B",9.2,9.2)

"BLD",805,"KRN","B",9.8,9.8)

"BLD",805,"KRN","B",19,19)

"BLD",805,"KRN","B",19.1,19.1)

"BLD",805,"KRN","B",101,101)

"BLD",805,"KRN","B",409.61,409.61)

"BLD",805,"KRN","B",771,771)

"BLD",805,"KRN","B",870,870)

"BLD",805,"KRN","B",8989.51,8989.51)

"BLD",805,"KRN","B",8989.52,8989.52)

"BLD",805,"KRN","B",8994,8994)

"BLD",805,"PRE")
HLP109EN
"BLD",805,"QUES",0)
^9.62^^
"BLD",805,"REQB",0)
^9.611^5^8
"BLD",805,"REQB",1,0)
HL*1.6*62^0
"BLD",805,"REQB",2,0)
HL*1.6*103^0
"BLD",805,"REQB",3,0)
HL*1.6*57^0
"BLD",805,"REQB",4,0)
HL*1.6*87^2
"BLD",805,"REQB",5,0)
HL*1.6*91^2
"BLD",805,"REQB",47,0)
HL*1.6*65^0
"BLD",805,"REQB",97,0)
HL*1.6*84^2
"BLD",805,"REQB",99,0)
HL*1.6*71^2
"BLD",805,"REQB","B","HL*1.6*103",2)

"BLD",805,"REQB","B","HL*1.6*57",3)

"BLD",805,"REQB","B","HL*1.6*62",1)

"BLD",805,"REQB","B","HL*1.6*65",47)

"BLD",805,"REQB","B","HL*1.6*71",99)

"BLD",805,"REQB","B","HL*1.6*84",97)

"BLD",805,"REQB","B","HL*1.6*87",4)

"BLD",805,"REQB","B","HL*1.6*91",5)

"DATA",776.1,1,0)
EVENT MONITOR^A^Monitors the Event Monitor^480^1^MOTHER~HLEVX001
"DATA",776.1,1,50,0)
^776.101^2^2^3030610^^^^
"DATA",776.1,1,50,1,0)
This monitor monitors the Event Monitor system!  In other words, it
"DATA",776.1,1,50,2,0)
monitors itself.
"DATA",776.1,1,60,0)
^776.106P^^0
"DATA",776.1,1,61,0)
^776.1061P^^0
"DATA",776.1,1,62,0)
^776.1062^^0
"DATA",776.1,4,0)
LINK (870) CHECKS^A^File 870 entry w/stub status search^720^1^CHK870~HLEVX000
"DATA",776.1,4,41,0)
^776.1041^9^9^3030707^^^^
"DATA",776.1,4,41,1,0)
M code logic flow for this routine is:
"DATA",776.1,4,41,2,0)
 
"DATA",776.1,4,41,3,0)
 - Loops through file 870 storing in ^XTMP all stub entries.
"DATA",776.1,4,41,4,0)
 
"DATA",776.1,4,41,5,0)
 - Loops through file 870 again, after requeue-minutes, searching
"DATA",776.1,4,41,6,0)
   for all stub entries.  Compares to previous record of stub
"DATA",776.1,4,41,7,0)
   entries.  If a stub entry still remains from last loop, a
"DATA",776.1,4,41,8,0)
   notification message is sent off-station to the VistA HL7
"DATA",776.1,4,41,9,0)
   team.
"DATA",776.1,4,50,0)
^776.101^2^2^3030707^^^^
"DATA",776.1,4,50,1,0)
This event monitor search the IN QUEUE and the OUT QUEUE of the HL 
"DATA",776.1,4,50,2,0)
Logical Link file (#870) for entries that are stuck in the STUB status.
"DATA",776.1,4,60,0)
^776.106P^^0
"DATA",776.1,4,61,0)
^776.1061P^^0
"DATA",776.1,4,62,0)
^776.1062^2^1
"DATA",776.1,4,62,2,0)
HL7SystemMonitoring@med.va.gov
"DATA",776.1,6,0)
CHECK 773 AC XREF^A^Check file 773 AC xref^1440^1^CHECKAC~HLEVX002
"DATA",776.1,6,60,0)
^776.106P
"DATA",776.1,6,62,0)
^776.1062^1^1
"DATA",776.1,6,62,1,0)
HL7SystemMonitoring@med.va.gov
"DATA",776.1,7,0)
FAST HL7 PURGE #1^A^This is the main Fast Purge Job.^60^0^FAST1~HLUOPTF2^
"DATA",776.1,7,41,0)
^776.1041^11^11^3031114^^^^
"DATA",776.1,7,41,1,0)
This job utilized the AI cross-reference to purge records in file 772 and 773
"DATA",776.1,7,41,2,0)
with maximum efficiency. It is not guaranted to purge all records that need
"DATA",776.1,7,41,3,0)
purging, but should quickly purge the vast majority of such records.  Its
"DATA",776.1,7,41,4,0)
main limitation is that it limits itself to messages that have a status of
"DATA",776.1,7,41,5,0)
Successfully Completed.
"DATA",776.1,7,41,6,0)

"DATA",776.1,7,41,7,0)
There are two Fast Purge jobs. This one is the main job, in that it should be
"DATA",776.1,7,41,8,0)
running nearly continuously.  The second job will be started less frequently,
"DATA",776.1,7,41,9,0)
and if there is no work to do will go back to sleep for several hours.  Its
"DATA",776.1,7,41,10,0)
purpose is to prevent purging from getting backed up when the messaging system
"DATA",776.1,7,41,11,0)
is under very heavy load.
"DATA",776.1,9,0)
FAST HL7 PURGE #2^A^Fast Purge for overload situations.^180^0^FAST2~HLUOPTF2^
"DATA",776.1,9,41,0)
^776.1041^13^13^3031027^^^^
"DATA",776.1,9,41,1,0)
This job utilized the AI cross-reference to purge records in file 772 and 773
"DATA",776.1,9,41,2,0)
with maximum efficiency. It is not guaranted to purge all records that need
"DATA",776.1,9,41,3,0)
purging, but should quickly purge the vast majority of such records.  Its
"DATA",776.1,9,41,4,0)
main limitation is that it limits itself to messages that have a status of
"DATA",776.1,9,41,5,0)
Successfully Completed.
"DATA",776.1,9,41,6,0)

"DATA",776.1,9,41,7,0)
There are two Fast Purge jobs.  This one is the        backup job, in that it
"DATA",776.1,9,41,8,0)
will be started less frequently, and if there is no work to do will go back to
"DATA",776.1,9,41,9,0)
sleep for several hours.  Its purpose is to prevent purging from getting
"DATA",776.1,9,41,10,0)
backed up when the messaging system is under very heavy load.
"DATA",776.1,9,41,11,0)

"DATA",776.1,9,41,12,0)
The other Fast Purge Job will run nearly continuously, and should be able to
"DATA",776.1,9,41,13,0)
keep up with the purging under all but the most severe workloads.
"DATA",776.1,10,0)
PURGE EVENT LOG^A^Purges records from file 776.4^1440^0^PURGE~HLEMEP
"DATA",776.1,11,0)
SEND EVENTS^A^distributes events to remote locations^30^0^SENDALL~HLEMSND
"DATA",776.1,11,41,0)
^776.1041^3^3^3031003^^
"DATA",776.1,11,41,1,0)
This distributes local events to remote locations.  Whether or not an event
"DATA",776.1,11,41,2,0)
is sent is determined by the type of event and a screen the application developer
"DATA",776.1,11,41,3,0)
can set up.
"DATA",776.3,1,0)
1^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,1,2,0)
^776.32P^^0
"DATA",776.3,1,4)
Invalid Event Protocol IEN
"DATA",776.3,2,0)
2^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,2,4)
Event Data Missing
"DATA",776.3,3,0)
3^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,3,4)
Missing Generation Routine
"DATA",776.3,4,0)
4^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,4,4)
Invalid Array Parameter Value
"DATA",776.3,5,0)
5^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,5,4)
Invalid Priority Parameter Value
"DATA",776.3,6,0)
6^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,6,3,0)
^^1^1^2940728^
"DATA",776.3,6,3,1,0)
The security parameter cannot be more than 40 characters in length.
"DATA",776.3,6,4)
Security Parameter too Long
"DATA",776.3,7,0)
7^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,7,3,0)
^^2^2^2941019^^^^
"DATA",776.3,7,3,1,0)
One or more of the input parameters required for this entry point
"DATA",776.3,7,3,2,0)
is missing.
"DATA",776.3,7,4)
Missing Input Parameter(s)
"DATA",776.3,8,0)
8^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,8,3,0)
^^2^2^2940729^
"DATA",776.3,8,3,1,0)
The local array HLS() or global array ^TMP("HLS",$J) is incomplete or
"DATA",776.3,8,3,2,0)
missing.
"DATA",776.3,8,4)
Invalid or Missing Message Array
"DATA",776.3,9,0)
9^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,9,3,0)
^^2^2^2940916^
"DATA",776.3,9,3,1,0)
An error ocurred while the application was processing the message.  The
"DATA",776.3,9,3,2,0)
specific problem encountered is described in the error message field.
"DATA",776.3,9,4)
Application Level Error
"DATA",776.3,10,0)
10^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,10,3,0)
^^2^2^2940916^
"DATA",776.3,10,3,1,0)
A routine to process the incoming message was not entered in the
"DATA",776.3,10,3,2,0)
Generate/Process Routine field in the Protocol file.
"DATA",776.3,10,4)
Missing Processing Routine
"DATA",776.3,11,0)
11^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,11,3,0)
^^1^1^2940928^
"DATA",776.3,11,3,1,0)
The continuation parameter cannot be more than 180 characters in length.
"DATA",776.3,11,4)
Continuation Pointer Parameter too Long
"DATA",776.3,12,0)
12^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,12,3,0)
^^1^1^2941011^
"DATA",776.3,12,3,1,0)
The header segment for the incoming message is missing.
"DATA",776.3,12,4)
Missing Message Header Segment
"DATA",776.3,13,0)
13^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,13,3,0)
^^1^1^2941011^
"DATA",776.3,13,3,1,0)
Information in the message header segment was incorrect or missing.
"DATA",776.3,13,4)
Application Reject Error
"DATA",776.3,14,0)
14^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,14,3,0)
^^3^3^2941125^^^
"DATA",776.3,14,3,1,0)
The Server Application field in the Protocol file (#101) did not have
"DATA",776.3,14,3,2,0)
a value for the event driver protocol identified by the value in the EID
"DATA",776.3,14,3,3,0)
parameter.
"DATA",776.3,14,4)
Server Application Missing in Protocol File
"DATA",776.3,15,0)
15^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,15,3,0)
^^3^3^2990202^
"DATA",776.3,15,3,1,0)
No clients are defined for this server protocol. Unless the application
"DATA",776.3,15,3,2,0)
intends to submit a specific client using the HLL("LINKS") array, this
"DATA",776.3,15,3,3,0)
message should not be sent.
"DATA",776.3,15,4)
No Client
"DATA",776.3,16,0)
16^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,16,3,0)
^^3^3^2990202^
"DATA",776.3,16,3,1,0)
The server protocol has been placed OUT OF SERVICE. The message has been
"DATA",776.3,16,3,2,0)
rejected by the HL7 Message Service. The sending application must retain
"DATA",776.3,16,3,3,0)
the message for later transmission.
"DATA",776.3,16,4)
Server Protocol Disabled
"DATA",776.3,17,0)
17^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,17,3,0)
^771.72^1^1^3020830^^
"DATA",776.3,17,3,1,0)
An error occured during the generation of the message.
"DATA",776.3,17,4)
Error During Generation
"DATA",776.3,18,0)
18^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,18,3,0)
^771.72^1^1^3020830^^
"DATA",776.3,18,3,1,0)
An error occured during the processing of the message.
"DATA",776.3,18,4)
Error During Processing
"DATA",776.3,100,0)
100^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,100,3,0)
^^2^2^2940914^
"DATA",776.3,100,3,1,0)
The lower level protocol could not secure internal entry numbers
"DATA",776.3,100,3,2,0)
to file #870.
"DATA",776.3,100,4)
LLP Could not Enqueue the Message
"DATA",776.3,101,0)
101^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,101,4)
LLP Unable to Dequeue Message
"DATA",776.3,102,0)
102^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,102,3,0)
^^2^2^2980715^^^^
"DATA",776.3,102,3,1,0)
A message was Nak'ed look at the individual message
"DATA",776.3,102,3,2,0)
error field to see why.
"DATA",776.3,102,4)
Message was NAK'ed
"DATA",776.3,103,0)
103^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,103,4)
LLP Exceeded Retry Param
"DATA",776.3,104,0)
104^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,104,3,0)
^^3^3^2950106^^
"DATA",776.3,104,3,1,0)
The message sent by DHCP was low level NAK'd by the other system.
"DATA",776.3,104,3,2,0)
Look at this link's output queue for more information.  This information
"DATA",776.3,104,3,3,0)
will be found in the STATUS field of individual messages.
"DATA",776.3,104,4)
Message Low Level NAK'd by Other System
"DATA",776.3,105,0)
105^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,105,3,0)
^^2^2^2980618^^^
"DATA",776.3,105,3,1,0)
The lower level protocol header "tvv" is malformed. Check message
"DATA",776.3,105,3,2,0)
that was sent to DHCP.
"DATA",776.3,105,4)
Tvv is Malformed
"DATA",776.3,106,0)
106^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,106,3,0)
^^2^2^2950112^
"DATA",776.3,106,3,1,0)
LLP exceeded READ TIMEOUT parameter in file 870 while reading in a
"DATA",776.3,106,3,2,0)
message.
"DATA",776.3,106,4)
LLP Timed Out While Reading in a Message
"DATA",776.3,107,0)
107^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,107,3,0)
^^1^1^2950112^^^
"DATA",776.3,107,3,1,0)
Message has an incorrect or missing checksum
"DATA",776.3,107,4)
Message did not Validate, Look at Checksums
"DATA",776.3,108,0)
108^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,108,3,0)
^^2^2^2980618^^
"DATA",776.3,108,3,1,0)
The response message received was not what was expected. This only happens
"DATA",776.3,108,3,2,0)
with bi-directional messages.  
"DATA",776.3,108,4)
Incorrect Message Received
"DATA",776.3,109,0)
109^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,109,3,0)
^771.72^1^1^3020830^^
"DATA",776.3,109,3,1,0)
Message has already been received and processed.  This is a duplicate.
"DATA",776.3,109,4)
Duplicate Message
"DATA",776.3,200,0)
200^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,200,3,0)
^^2^2^2941004^
"DATA",776.3,200,3,1,0)
The IEN that was passed to the routine does not exist in the
"DATA",776.3,200,3,2,0)
associated file.
"DATA",776.3,200,4)
Invalid Internal Entry Number
"DATA",776.3,201,0)
201^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,201,3,0)
^^2^2^2941004^
"DATA",776.3,201,3,1,0)
The IEN should have been passed to the routine, but it was not.
"DATA",776.3,201,3,2,0)
Please look at the routine to determine which IEN should be used.
"DATA",776.3,201,4)
Missing Internal Entry Number
"DATA",776.3,202,0)
202^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,202,3,0)
^^4^4^2941004^
"DATA",776.3,202,3,1,0)
The direction of the queue is not in the list:
"DATA",776.3,202,3,2,0)
IN, OUT, 1, 2
"DATA",776.3,202,3,3,0)
The number 1 can be used to specify the "IN" queue
"DATA",776.3,202,3,4,0)
The number 2 can be used to specify the "OUT" queue
"DATA",776.3,202,4)
Invalid Direction
"DATA",776.3,203,0)
203^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,203,3,0)
^^2^2^2941004^
"DATA",776.3,203,3,1,0)
A queue direction (IN or OUT) must be passed to tell which
"DATA",776.3,203,3,2,0)
queue you are acting on.
"DATA",776.3,203,4)
Direction not Given
"DATA",776.3,204,0)
204^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,204,3,0)
^^2^2^2941004^
"DATA",776.3,204,3,1,0)
FILE^DICN returned a -1 error code for some reason.  Please record
"DATA",776.3,204,3,2,0)
the conditions used to create the record and inform an HL7 developer.
"DATA",776.3,204,4)
DICN Error
"DATA",776.3,205,0)
AC-NO 870^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,205,4)
AC xref pointing to non-existent link
"DATA",776.3,206,0)
AC-NO 773^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,206,3,0)
^^4^4^3030728^
"DATA",776.3,206,3,1,0)
The CHECK 773 AC XREF monitors calls CHECKAC^HLEVX002.  One of the checks
"DATA",776.3,206,3,2,0)
of this monitor is for ^HLMA("AC",I/O,LINK,IEN773) entries that point to
"DATA",776.3,206,3,3,0)
a non-existent file 773 entry.  When this occurs, an entry is made using
"DATA",776.3,206,3,4,0)
this AC-NO 773 entry.
"DATA",776.3,206,4)
AC xref pointing to non-existent 773
"DATA",776.3,207,0)
AC-HUNG^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,207,4)
AC xref that doesn't process
"DATA",776.3,208,0)
870-DINUM^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,208,3,0)
^^4^4^3030728^
"DATA",776.3,208,3,1,0)
The LINK (870) CHECKS monitor checks the HL Logical Link file (#870) for 
"DATA",776.3,208,3,2,0)
various types of problems in the IN and OUT queues.  If an entry is not 
"DATA",776.3,208,3,3,0)
properly DINUMd, processing problems occur.  This entry records this type
"DATA",776.3,208,3,4,0)
problem.
"DATA",776.3,208,4)
Incorrectly DINUMd 870 queue entry
"DATA",776.3,209,0)
870-SKIP^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,209,3,0)
^^4^4^3030728^
"DATA",776.3,209,3,1,0)
The LINK (870) CHECKS monitor checks the HL Logical Link file (#870) for
"DATA",776.3,209,3,2,0)
various types of problems in the IN and OUT queues.  Each queue 
"DATA",776.3,209,3,3,0)
multiple's IENs must be sequential.  If any IEN is skipped, processing 
"DATA",776.3,209,3,4,0)
problems occur.  This entry records this type problem.
"DATA",776.3,209,4)
Skipped 870 queue entry
"DATA",776.3,210,0)
870-STUB^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,210,4)
Stub 870 queue entry
"DATA",776.3,211,0)
AC-PROC'D^9^1^0^0^^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,211,3,0)
^^4^4^3030728^
"DATA",776.3,211,3,1,0)
The CHECK 773 AC XREF monitor checks the ^HLMA("AC",I/O,LINK,IEN) 
"DATA",776.3,211,3,2,0)
cross-reference.  This xref should exist only for un-processed entries.  
"DATA",776.3,211,3,3,0)
If an entry has been processed, and the AC xref exists, the entry is 
"DATA",776.3,211,3,4,0)
recorded using this entry.
"DATA",776.3,211,4)
AC xref for a processed entry
"DATA",776.3,213,0)
773 PURGE^9^4^0^1^1^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,213,4)
Set of records purged from file 773 durring approx one hour.
"DATA",776.3,214,0)
772 PURGE^9^4^0^1^1^0^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,214,3,0)
^776.33^1^1^3030811^^^^
"DATA",776.3,214,3,1,0)
This is a notification of records purged in file 772 via the Fast Purge.
"DATA",776.3,214,4)
Set of records purged from file 772 durring approx one hour.
"DATA",776.3,215,0)
SRVR ERROR^9^1^0^0^^1^HEALTH LEVEL SEVEN^3^1
"DATA",776.3,215,3,0)
^776.33^3^3^3030925^^
"DATA",776.3,215,3,1,0)
This event signals that an error was encountered while trying to send or receive
"DATA",776.3,215,3,2,0)
and event at a remote location. If encountered locally, the event id and ien
"DATA",776.3,215,3,3,0)
are stored as application data.  If remote, the mailman message id is stored.
"DATA",776.3,215,4)
HL7 EVENT LOG SERVER ENCOUNTERED AN ERROR
"DATA",776.3,216,0)
FILE-HLDIE^9^3^0^0^^1^HEALTH LEVEL SEVEN^7^1
"DATA",776.3,216,3,0)
^^4^4^3031231^
"DATA",776.3,216,3,1,0)
API calls in HLTP4 to FILE^DIE have been changed to FILE^HLDIE, using
"DATA",776.3,216,3,2,0)
direct hard sets of data.  If any call to FILE^HLDIE fails the pre-
"DATA",776.3,216,3,3,0)
execution checks, an event is recorded in the "logger" using this
"DATA",776.3,216,3,4,0)
event type.  (And, FILE^DIE is called instead of FILE^HLDIE.)
"DATA",776.3,216,4)
FILE~HLDIE Error
"FIA",772)
HL7 MESSAGE TEXT
"FIA",772,0)
^HL(772,
"FIA",772,0,0)
772DI
"FIA",772,0,1)
y^n^p^^^^n^^n
"FIA",772,0,10)

"FIA",772,0,11)

"FIA",772,0,"RLRO")

"FIA",772,0,"VR")
1.6^HL
"FIA",772,772)
1
"FIA",772,772,2.02)

"FIA",773)
HL7 MESSAGE ADMINISTRATION
"FIA",773,0)
^HLMA(
"FIA",773,0,0)
773PI
"FIA",773,0,1)
y^n^f^^^^n^^n
"FIA",773,0,10)

"FIA",773,0,11)

"FIA",773,0,"RLRO")

"FIA",773,0,"VR")
1.6^HL
"FIA",773,773)
0
"FIA",773,773.01)
0
"FIA",776)
HL7 MONITOR JOB
"FIA",776,0)
^HLEV(776,
"FIA",776,0,0)
776D
"FIA",776,0,1)
y^y^f^^^^n
"FIA",776,0,10)

"FIA",776,0,11)

"FIA",776,0,"RLRO")

"FIA",776,0,"VR")
1.6^HL
"FIA",776,776)
0
"FIA",776,776.001)
0
"FIA",776,776.002)
0
"FIA",776,776.003)
0
"FIA",776.1)
HL7 MONITOR
"FIA",776.1,0)
^HLEV(776.1,
"FIA",776.1,0,0)
776.1
"FIA",776.1,0,1)
y^y^f^^y^HLEV MONITOR EXPORT LIST^y^m^n
"FIA",776.1,0,10)

"FIA",776.1,0,11)
I $E($G(^HLEV(776.1,+Y,0)))'="Z"
"FIA",776.1,0,"RLRO")

"FIA",776.1,0,"VR")
1.6^HL
"FIA",776.1,776.1)
0
"FIA",776.1,776.101)
0
"FIA",776.1,776.1041)
0
"FIA",776.1,776.106)
0
"FIA",776.1,776.1061)
0
"FIA",776.1,776.1062)
0
"FIA",776.2)
HL7 MONITOR MASTER JOB
"FIA",776.2,0)
^HLEV(776.2,
"FIA",776.2,0,0)
776.2D
"FIA",776.2,0,1)
y^y^f^^^^n
"FIA",776.2,0,10)

"FIA",776.2,0,11)

"FIA",776.2,0,"RLRO")

"FIA",776.2,0,"VR")
1.6^HL
"FIA",776.2,776.2)
0
"FIA",776.2,776.201)
0
"FIA",776.2,776.2051)
0
"FIA",776.3)
HL7 MONITOR EVENT TYPE
"FIA",776.3,0)
^HLEV(776.3,
"FIA",776.3,0,0)
776.3I
"FIA",776.3,0,1)
y^y^f^^y^^y^o^n
"FIA",776.3,0,10)

"FIA",776.3,0,11)
I $E($G(^HLEV(776.3,+Y,0)))'="Z"
"FIA",776.3,0,"RLRO")

"FIA",776.3,0,"VR")
1.6^HL
"FIA",776.3,776.3)
0
"FIA",776.3,776.32)
0
"FIA",776.3,776.33)
0
"FIA",776.4)
HL7 MONITOR EVENT
"FIA",776.4,0)
^HLEV(776.4,
"FIA",776.4,0,0)
776.4ID
"FIA",776.4,0,1)
y^y^f^^^^n
"FIA",776.4,0,10)

"FIA",776.4,0,11)

"FIA",776.4,0,"RLRO")

"FIA",776.4,0,"VR")
1.6^HL
"FIA",776.4,776.4)
0
"FIA",776.4,776.41)
0
"FIA",776.4,776.42)
0
"FIA",776.4,776.43)
0
"FIA",776.5)
HL7 MONITOR EVENTS PROFILE
"FIA",776.5,0)
^HLEV(776.5,
"FIA",776.5,0,0)
776.5P
"FIA",776.5,0,1)
y^y^f^^^^n
"FIA",776.5,0,10)

"FIA",776.5,0,11)

"FIA",776.5,0,"RLRO")

"FIA",776.5,0,"VR")
1.6^HL
"FIA",776.5,776.5)
0
"FIA",776.5,776.51)
0
"FIA",776.5,776.52)
0
"FIA",776.5,776.53)
0
"FIA",776.5,776.54)
0
"FIA",776.999)
HL7 MONITOR PARAMETERS
"FIA",776.999,0)
^HLEV(776.999,
"FIA",776.999,0,0)
776.999
"FIA",776.999,0,1)
y^y^f^^^^n
"FIA",776.999,0,10)

"FIA",776.999,0,11)

"FIA",776.999,0,"RLRO")

"FIA",776.999,0,"VR")
1.6^HL
"FIA",776.999,776.999)
0
"FIA",869.3)
HL COMMUNICATION SERVER PARAMETERS
"FIA",869.3,0)
^HLCS(869.3,
"FIA",869.3,0,0)
869.3
"FIA",869.3,0,1)
y^n^p^^^^n^^n
"FIA",869.3,0,10)

"FIA",869.3,0,11)

"FIA",869.3,0,"RLRO")

"FIA",869.3,0,"VR")
1.6^HL
"FIA",869.3,869.3)
1
"FIA",869.3,869.3,44)

"FIA",869.3,869.3,772)

"FIA",869.3,869.3,773)

"FRV1",776.3,"1,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"1,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"10,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"10,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"100,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"100,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"101,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"101,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"102,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"102,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"103,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"103,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"104,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"104,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"105,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"105,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"106,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"106,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"107,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"107,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"108,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"108,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"109,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"109,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"11,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"11,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"12,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"12,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"13,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"13,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"14,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"14,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"15,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"15,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"16,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"16,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"17,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"17,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"18,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"18,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"2,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"2,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"200,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"200,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"201,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"201,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"202,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"202,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"203,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"203,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"204,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"204,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"205,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"205,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"206,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"206,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"207,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"207,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"208,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"208,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"209,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"209,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"210,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"210,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"211,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"211,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"213,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"213,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"214,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"214,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"215,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"215,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"216,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"216,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"3,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"3,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"4,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"4,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"5,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"5,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"6,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"6,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"7,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"7,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"8,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"8,0",2,"F")
;DIC(9.4,
"FRV1",776.3,"9,0",2)
HEALTH LEVEL SEVEN
"FRV1",776.3,"9,0",2,"F")
;DIC(9.4,
"INI")
PRE^HLP109
"INIT")
POST^HLP109
"IX",772,772,"AJ",0)
772^AJ^Removes the record from the AI x-ref if the Fast Purge Date/Time is edited^MU^^F^^I^772^^^^^A
"IX",772,772,"AJ",1)
Q
"IX",772,772,"AJ",2)
K:$G(X1(1)) ^HLMA("AI",X1(1),772,+$G(DA))
"IX",772,772,"AJ",11.1,0)
^.114IA^1^1
"IX",772,772,"AJ",11.1,1,0)
1^F^772^2.02^^1^F
"IX",773,773,"AI",0)
773^AI^Used by the Fast Purge process.^MU^^F^^I^773^^^^^A
"IX",773,773,"AI",.1,0)
^^9^9^3030804^
"IX",773,773,"AI",.1,1,0)
This cross-reference is used by the fast purge option to purge records in 
"IX",773,773,"AI",.1,2,0)
both file 773 and file 772.  The format is:
"IX",773,773,"AI",.1,3,0)
 
"IX",773,773,"AI",.1,4,0)
"AI",<date/time that the record may be purged>,772,<list of record 
"IX",773,773,"AI",.1,5,0)
numbers in file 772 that may be purged as of this date and time>)=""
"IX",773,773,"AI",.1,6,0)
 
"IX",773,773,"AI",.1,7,0)
 
"IX",773,773,"AI",.1,8,0)
"AI",<date/time that the record may be purged>,773,<list of record 
"IX",773,773,"AI",.1,9,0)
numbers in file 773 that may be purged as of this date and time>)=""
"IX",773,773,"AI",1)
D PXREF^HLUOPTF1($G(DA),$G(X2(1)))
"IX",773,773,"AI",2)
Q
"IX",773,773,"AI",11.1,0)
^.114IA^1^1
"IX",773,773,"AI",11.1,1,0)
1^F^773^20^^1^F
"IX",773,773,"AI",11.1,1,3)

"IX",773,773,"AJ",0)
773^AJ^Removes record from the "AI" x-ref if Fast Purge Date/Time is edited.^MU^^F^^I^773^^^^^A
"IX",773,773,"AJ",1)
Q
"IX",773,773,"AJ",2)
K:$G(X1(1)) ^HLMA("AI",X1(1),773,+$G(DA))
"IX",773,773,"AJ",11.1,0)
^.114IA^1^1
"IX",773,773,"AJ",11.1,1,0)
1^F^773^2.02^^1^F
"IX",776.3,776.3,"AC",0)
776.3^AC^Stuffs the package name into field .08^MU^^F^^I^776.3^^^^^A
"IX",776.3,776.3,"AC",.1,0)
^^2^2^3031027^
"IX",776.3,776.3,"AC",.1,1,0)
This index stuffs the name of the package into the Package Name field, based
"IX",776.3,776.3,"AC",.1,2,0)
on the pointer value of the Package field.
"IX",776.3,776.3,"AC",1)
D SETPKG^HLEMDD($G(DA),$G(X2(1)),$G(X1(2)))
"IX",776.3,776.3,"AC",2)
Q
"IX",776.3,776.3,"AC",11.1,0)
^.114IA^2^2
"IX",776.3,776.3,"AC",11.1,1,0)
1^F^776.3^.02^^1^F
"IX",776.3,776.3,"AC",11.1,2,0)
2^F^776.3^.08^^2^F
"IX",776.3,776.3,"C",0)
776.3^C^Uniqueness Index for Key 'A' of File #776.3^R^^R^IR^I^776.3^^^^^LS
"IX",776.3,776.3,"C",1)
S ^HLEV(776.3,"C",X(1),X(2),DA)=""
"IX",776.3,776.3,"C",2)
K ^HLEV(776.3,"C",X(1),X(2),DA)
"IX",776.3,776.3,"C",2.5)
K ^HLEV(776.3,"C")
"IX",776.3,776.3,"C",11.1,0)
^.114IA^2^2
"IX",776.3,776.3,"C",11.1,1,0)
1^F^776.3^.01^^1
"IX",776.3,776.3,"C",11.1,2,0)
2^F^776.3^.08^^2
"IX",776.4,776.4,"AC",0)
776.4^AC^This trigger sets the ID field.^MU^^F^^I^776.4^^^^^A
"IX",776.4,776.4,"AC",1)
D SETID^HLEMDD(DA)
"IX",776.4,776.4,"AC",2)
Q
"IX",776.4,776.4,"AC",11.1,0)
^.114IA^1^1
"IX",776.4,776.4,"AC",11.1,1,0)
1^F^776.4^.01^^^F
"IX",776.4,776.4,"AC",11.1,1,3)

"IX",776.4,776.4,"AD",0)
776.4^AD^Updates REVIEW STATUS if contingent on ACTION STATUS^MU^^F^^I^776.4^^^^^A
"IX",776.4,776.4,"AD",1)
D STATUS^HLEMDD($G(DA),$G(X2))
"IX",776.4,776.4,"AD",2)
Q
"IX",776.4,776.4,"AD",11.1,0)
^.114IA^1^1
"IX",776.4,776.4,"AD",11.1,1,0)
1^F^776.4^.05^^^F
"IX",776.4,776.4,"AD",11.1,1,3)

"IX",776.4,776.4,"AE",0)
776.4^AE^Used for conglomerating events.^R^^R^^I^776.4^^^^^S
"IX",776.4,776.4,"AE",1)
S ^HLEV(776.4,"AE",X(1),X(2),X(3),DA)=""
"IX",776.4,776.4,"AE",1.4)
I $G(X(2)) S X=$P(^HLEV(776.3,X(2),0),"^",5)
"IX",776.4,776.4,"AE",2)
K ^HLEV(776.4,"AE",X(1),X(2),X(3),DA)
"IX",776.4,776.4,"AE",2.5)
K ^HLEV(776.4,"AE")
"IX",776.4,776.4,"AE",11.1,0)
^.114IA^3^3
"IX",776.4,776.4,"AE",11.1,1,0)
1^F^776.4^.03^^1^F
"IX",776.4,776.4,"AE",11.1,2,0)
2^F^776.4^.02^^2^F
"IX",776.4,776.4,"AE",11.1,3,0)
3^F^776.4^.01^^3^F
"IX",776.4,776.4,"AF",0)
776.4^AF^Collects statistics on events^MU^^R^^I^776.4^^^^^A
"IX",776.4,776.4,"AF",.1,0)
^^15^15^3030716^
"IX",776.4,776.4,"AF",.1,1,0)
This x~ref mantains statistics on HL7 Monitor Events as they are created and
"IX",776.4,776.4,"AF",.1,2,0)
as their review status changes.  Currenly, statistics maintained are as
"IX",776.4,776.4,"AF",.1,3,0)
follows:
"IX",776.4,776.4,"AF",.1,4,0)

"IX",776.4,776.4,"AF",.1,5,0)
Total #of events created,in different time periods by site, event type, and time period in the format:
"IX",776.4,776.4,"AF",.1,6,0)

"IX",776.4,776.4,"AF",.1,7,0)
^HLEV(776.4,"AF",<site>,<type>,"RECEIVED","YEAR",<year>)=count
"IX",776.4,776.4,"AF",.1,8,0)
^HLEV(776.4,"AF",<site>,<type>,"RECEIVED","YEAR",<year>,"MONTH",<month>)=count
"IX",776.4,776.4,"AF",.1,9,0)
^HLEV(776.4,"AF",<site>,<type>,"RECEIVED","YEAR",<year>,"MONTH",<month>,"DAY",<day))=count
"IX",776.4,776.4,"AF",.1,10,0)
^HLEV(776.4,"AF",<site>,<type>,"RECEIVED","YEAR",<year>,"MONTH",<month>,"DAY",<day","HOUR",<hour>)=count
"IX",776.4,776.4,"AF",.1,11,0)

"IX",776.4,776.4,"AF",.1,12,0)
Total # of events exisitng in various Review Status's by site, event type, and
"IX",776.4,776.4,"AF",.1,13,0)
review status in this format:
"IX",776.4,776.4,"AF",.1,14,0)

"IX",776.4,776.4,"AF",.1,15,0)
^HLEV(776.4,"AF",<site>,<type>,<review status>)=count
"IX",776.4,776.4,"AF",1)
D ADDSTAT^HLEMDD(X2(1),X1(3),X2(3),X2(2),X2(4),X2(5))
"IX",776.4,776.4,"AF",2)
D DELSTAT^HLEMDD(X1(3),X1(2),X1(4),X1(5))
"IX",776.4,776.4,"AF",2.5)
K ^HLEV(776.4,"AF")
"IX",776.4,776.4,"AF",11.1,0)
^.114IA^5^5
"IX",776.4,776.4,"AF",11.1,1,0)
1^F^776.4^.01^^^F
"IX",776.4,776.4,"AF",11.1,2,0)
2^F^776.4^.02^^^F
"IX",776.4,776.4,"AF",11.1,3,0)
3^F^776.4^.03^^^F
"IX",776.4,776.4,"AF",11.1,4,0)
4^F^776.4^.06^^^F
"IX",776.4,776.4,"AF",11.1,5,0)
5^F^776.4^.11^^^F
"IX",776.4,776.4,"AG",0)
776.4^AG^Triggers updates in the URGENT field.^MU^^R^^I^776.4^^^^^A
"IX",776.4,776.4,"AG",.1,0)
^^2^2^3030722^
"IX",776.4,776.4,"AG",.1,1,0)
Triggers changes in the URGENT field as changes in the review status and 
"IX",776.4,776.4,"AG",.1,2,0)
action status occur.
"IX",776.4,776.4,"AG",1)
D URGENCY^HLEMDD($G(DA),$G(X2(3)),$G(X2(1)),$G(X2(2)))
"IX",776.4,776.4,"AG",2)
Q
"IX",776.4,776.4,"AG",11.1,0)
^.114IA^3^3
"IX",776.4,776.4,"AG",11.1,1,0)
1^F^776.4^.05^^1^F
"IX",776.4,776.4,"AG",11.1,2,0)
2^F^776.4^.06^^2^F
"IX",776.4,776.4,"AG",11.1,3,0)
3^F^776.4^.12^^3^F
"IX",776.4,776.4,"AH",0)
776.4^AH^Applications own index, option, for private use.^MU^^R^^I^776.4^^^^^A
"IX",776.4,776.4,"AH",.1,0)
^^5^5^3030729^
"IX",776.4,776.4,"AH",.1,1,0)
This cross~reference will be used by applications to determine whether
"IX",776.4,776.4,"AH",.1,2,0)
or not the event has already been logged.  It is optional.  The application
"IX",776.4,776.4,"AH",.1,3,0)
can pass in a list of parameters with which to build an index.  Latter, it
"IX",776.4,776.4,"AH",.1,4,0)
can search that index via an API to determine if the event has already been
"IX",776.4,776.4,"AH",.1,5,0)
logged.
"IX",776.4,776.4,"AH",1)
Q
"IX",776.4,776.4,"AH",2)
D KILLAH^HLEMDD(.DA)
"IX",776.4,776.4,"AH",11.1,0)
^.114IA^^
"IX",776.4,776.4,"AI",0)
776.4^AI^If the review status changes to completed, sets the date and reviewer.^MU^^F^^I^776.4^^^^^A
"IX",776.4,776.4,"AI",1)
D CSTATUS^HLEMDD($G(DA),X2(1))
"IX",776.4,776.4,"AI",2)
Q
"IX",776.4,776.4,"AI",11.1,0)
^.114IA^1^1
"IX",776.4,776.4,"AI",11.1,1,0)
1^F^776.4^.06^^1^F
"IX",776.4,776.4,"AJ",0)
776.4^AJ^Sets the purge date and time^MU^^R^IR^I^776.4^^^^^A
"IX",776.4,776.4,"AJ",.1,0)
^^4^4^3030821^^
"IX",776.4,776.4,"AJ",.1,1,0)
This index triggers the computation of the earliest purge date for this
"IX",776.4,776.4,"AJ",.1,2,0)
event record and sets it into the AJ index.  The format of the index is:
"IX",776.4,776.4,"AJ",.1,3,0)

"IX",776.4,776.4,"AJ",.1,4,0)
^HLEV(776.4,"AJ",<eariest date/time that the record may be purged>,<IEN>)=""
"IX",776.4,776.4,"AJ",1)
D SETPURGE^HLEMDD($G(DA),$G(X2(1)),$G(X2(2)))
"IX",776.4,776.4,"AJ",2)
D DELPURGE^HLEMDD($G(DA),$G(X1(1)),$G(X1(2)))
"IX",776.4,776.4,"AJ",2.5)
K ^HLEV(776.4,"AJ")
"IX",776.4,776.4,"AJ",11.1,0)
^.114IA^2^2
"IX",776.4,776.4,"AJ",11.1,1,0)
1^F^776.4^.01^^1^F
"IX",776.4,776.4,"AJ",11.1,2,0)
2^F^776.4^.02^^2^F
"IX",776.4,776.4,"AK",0)
776.4^AK^Maintains a queue of events that should be sent to remote servers.^MU^^F^^I^776.4^^^^^A
"IX",776.4,776.4,"AK",.1,0)
^^8^8^3030924^
"IX",776.4,776.4,"AK",.1,1,0)
The format of the cross-reference is:
"IX",776.4,776.4,"AK",.1,2,0)

"IX",776.4,776.4,"AK",.1,3,0)
^HLEV(776.4,"AK",<CREATE DT/TM>,<ien>)=""
"IX",776.4,776.4,"AK",.1,4,0)

"IX",776.4,776.4,"AK",.1,5,0)
Only events that need to be sent to remote servers are placed on this
"IX",776.4,776.4,"AK",.1,6,0)
cross-reference.  The cross-reference is created when $$EVENT^HLEM is
"IX",776.4,776.4,"AK",.1,7,0)
called by an application, created within that call.  It is deleted by the
"IX",776.4,776.4,"AK",.1,8,0)
background job that sends the event to the remote location.
"IX",776.4,776.4,"AK",1)
Q
"IX",776.4,776.4,"AK",2)
Q
"IX",776.4,776.4,"AK",11.1,0)
^.114IA^1^1
"IX",776.4,776.4,"AK",11.1,1,0)
1^F^776.4^.17^^1^F
"IX",776.4,776.4,"AK",11.1,1,3)

"IX",776.4,776.4,"C",0)
776.4^C^Uniqueness Index for Key 'A' of File #776.4^R^^F^IR^I^776.4^^^^^LS
"IX",776.4,776.4,"C",1)
S ^HLEV(776.4,"C",X,DA)=""
"IX",776.4,776.4,"C",2)
K ^HLEV(776.4,"C",X,DA)
"IX",776.4,776.4,"C",2.5)
K ^HLEV(776.4,"C")
"IX",776.4,776.4,"C",11.1,0)
^.114IA^1^1
"IX",776.4,776.4,"C",11.1,1,0)
1^F^776.4^.04^^1
"IX",776.4,776.4,"D",0)
776.4^D^Used for sorting events for reports and displays.^R^^R^IR^I^776.4^^^^^LS
"IX",776.4,776.4,"D",.1,0)
^^3^3^3030723^^
"IX",776.4,776.4,"D",.1,1,0)
This index will sort the HL7 Monitor Events as follows:
"IX",776.4,776.4,"D",.1,2,0)

"IX",776.4,776.4,"D",.1,3,0)
"D",<SITE>,<EVENT TYPE>,<DT/TM>,<REVIEW STATUS>,<event ien>)=""
"IX",776.4,776.4,"D",1)
S ^HLEV(776.4,"D",X(1),X(2),X(3),X(4),DA)=""
"IX",776.4,776.4,"D",2)
K ^HLEV(776.4,"D",X(1),X(2),X(3),X(4),DA)
"IX",776.4,776.4,"D",2.5)
K ^HLEV(776.4,"D")
"IX",776.4,776.4,"D",11.1,0)
^.114IA^4^4
"IX",776.4,776.4,"D",11.1,1,0)
1^F^776.4^.03^^1^F
"IX",776.4,776.4,"D",11.1,1,3)

"IX",776.4,776.4,"D",11.1,2,0)
2^F^776.4^.02^^2^F
"IX",776.4,776.4,"D",11.1,2,3)

"IX",776.4,776.4,"D",11.1,3,0)
3^F^776.4^.01^^3^F
"IX",776.4,776.4,"D",11.1,3,3)

"IX",776.4,776.4,"D",11.1,4,0)
4^F^776.4^.06^^4^F
"IX",776.4,776.4,"D",11.1,4,3)

"IX",776.5,776.5,"AC",0)
776.5^AC^Used to insure that each use has only one profile flagged as default^MU^^R^IR^I^776.5^^^^^A
"IX",776.5,776.5,"AC",1)
D DEFAULT^HLEMDD($G(DA),$G(X2(1)),$G(X2(2)))
"IX",776.5,776.5,"AC",2)
K ^HLEV(776.5,"AC",$G(X1(1)),+$G(DA))
"IX",776.5,776.5,"AC",2.5)
K ^HLEV(776.5,"AC")
"IX",776.5,776.5,"AC",11.1,0)
^.114IA^2^2
"IX",776.5,776.5,"AC",11.1,1,0)
1^F^776.5^.01^^1^F
"IX",776.5,776.5,"AC",11.1,2,0)
2^F^776.5^.03^^2^F
"IX",776.5,776.5,"C",0)
776.5^C^Uniqueness Index for Key 'A' of File #776.5^R^^R^IR^I^776.5^^^^^LS
"IX",776.5,776.5,"C",1)
S ^HLEV(776.5,"C",X(1),X(2),DA)=""
"IX",776.5,776.5,"C",2)
K ^HLEV(776.5,"C",X(1),X(2),DA)
"IX",776.5,776.5,"C",2.5)
K ^HLEV(776.5,"C")
"IX",776.5,776.5,"C",11.1,0)
^.114IA^2^2
"IX",776.5,776.5,"C",11.1,1,0)
1^F^776.5^.01^^1^^Whose profiles?
"IX",776.5,776.5,"C",11.1,2,0)
2^F^776.5^.02^^2
"KEY",776.3,776.3,"A",0)
776.3^A^P^63
"KEY",776.3,776.3,"A",2,0)
^.312IA^2^2
"KEY",776.3,776.3,"A",2,1,0)
.01^776.3^1
"KEY",776.3,776.3,"A",2,2,0)
.08^776.3^2
"KEY",776.5,776.5,"A",0)
776.5^A^P^50
"KEY",776.5,776.5,"A",2,0)
^.312IA^2^2
"KEY",776.5,776.5,"A",2,1,0)
.01^776.5^1
"KEY",776.5,776.5,"A",2,2,0)
.02^776.5^2
"KEYPTR",776.3,776.3,"A")
776.3^C
"KEYPTR",776.5,776.5,"A")
776.5^C
"KRN",.4,93,-1)
0^2
"KRN",.4,93,0)
HLEV REPORT MONITOR-ONE LINE^3030620.12^@^776.1^^@^3030624
"KRN",.4,93,"F",2)
.01~2~4;"REQUE MIN"~6~
"KRN",.4,93,"H")
Monitor report
"KRN",.4,94,-1)
0^1
"KRN",.4,94,0)
HLEV REMOTE REQUESTABLE^3030624.1256^@^776.1^^@^3030624
"KRN",.4,94,"F",2)
W $$REMREQ^HLEVREP3;"REMOTE REQUESTS";L9;Z;"W $$REMREQ^HLEVREP3"~2~4;"REQ MIN";R5~.01;"MONITOR"~6;"M API"~
"KRN",.4,94,"H")
Remote Requestable List
"KRN",.401,53,-1)
0^1
"KRN",.401,53,0)
HLEV MONITOR EXPORT LIST^3030529.0413^@^776.1^^@^3030529
"KRN",.401,53,"DC",1)
.01^["M"
"KRN",.401,53,"DIS",0)
I $P($G(^HLEV(776.1,D0,0)),U,1)["M"
"KRN",.401,53,"DL")
1
"KRN",.401,53,"DL",0)
^1^
"KRN",.401,53,"O",0)
^
"KRN",.401,53,"O",1,0)
NAME CONTAINS "M"
"KRN",.401,53,"QR")
3030529.041303^1
"KRN",.401,54,-1)
0^2
"KRN",.401,54,0)
HLEV REPORT MONITOR^3030620.1157^@^776.1^^@^3030624
"KRN",.401,54,2,0)
^.4014^1^1
"KRN",.401,54,2,1,0)
776.1^.01^NAME^@^^^^^^4
"KRN",.401,54,2,1,"ASK")
1
"KRN",.401,54,2,1,"F")
@z^A
"KRN",.401,54,2,1,"GET")
S DISX(1)=$P($G(^HLEV(776.1,D0,0)),U)
"KRN",.401,54,2,1,"IX")
^HLEV(776.1,"B",^HLEV(776.1,^2
"KRN",.401,54,2,1,"QCON")
I (DISX(1)]]"@z")&(DISX(1)']]"ZZZ")
"KRN",.401,54,2,1,"T")
ZZZ^ZZZ
"KRN",.401,54,2,1,"TXT")
NAME from A to ZZZ
"KRN",.401,54,2,"B",776.1,1)

"KRN",.401,55,-1)
0^3
"KRN",.401,55,0)
HLEV REPORT MONITOR - FF^3030620.1219^@^776.1^^@^3030620
"KRN",.401,55,2,0)
^.4014^1^1
"KRN",.401,55,2,1,0)
776.1^.01^NAME^@^;"================================================================================"^^^^^4
"KRN",.401,55,2,1,"ASK")
1
"KRN",.401,55,2,1,"F")
AA@z^AAA
"KRN",.401,55,2,1,"GET")
S DISX(1)=$P($G(^HLEV(776.1,D0,0)),U)
"KRN",.401,55,2,1,"IX")
^HLEV(776.1,"B",^HLEV(776.1,^2
"KRN",.401,55,2,1,"QCON")
I (DISX(1)]]"AA@z")&(DISX(1)']]"ZZZZZ")
"KRN",.401,55,2,1,"T")
ZZZZZ^ZZZZZ
"KRN",.401,55,2,1,"TXT")
NAME from AAA to ZZZZZ
"KRN",.401,55,2,"B",776.1,1)

"KRN",.402,62,-1)
0^2
"KRN",.402,62,0)
HLEV MONITOR ENTER/EDIT^3030807.1039^@^776.1^^@^3040120
"KRN",.402,62,"DIAB",1,1,776.106,0)
ALL
"KRN",.402,62,"DIAB",1,1,776.1061,0)
ALL
"KRN",.402,62,"DIAB",1,1,776.1062,0)
ALL
"KRN",.402,62,"DR",1,776.1)
D HELP^HLEVSTUP(776.1,.01);.01;D HELP^HLEVSTUP(776.1,3);3;D HELP^HLEVSTUP(776.1,2);2;D HELP^HLEVSTUP(776.1,6);6;D HELP^HLEVSTUP(776.1,4);4;D HELP^HLEVSTUP(776.1,7);7;D HELP^HLEVSTUP(776.1,51);51;52;53;D HELP^HLEVSTUP(776.1,41);41;
"KRN",.402,62,"DR",1,776.1,1)
D HELP^HLEVSTUP(776.1,50);50;
"KRN",.402,62,"DR",2,776.106)
.01
"KRN",.402,62,"DR",2,776.1061)
.01
"KRN",.402,62,"DR",2,776.1062)
.01
"KRN",.402,63,-1)
0^1
"KRN",.402,63,0)
HLEV MASTER JOB ENTER/EDIT^3030603.0516^@^776.999^^@^3040210
"KRN",.402,63,"DR",1,776.999)
D HELP^HLEVSTUP(776.999,2);2;D HELP^HLEVSTUP(776.999,3);3;D HELP^HLEVSTUP(776.999,6);6;D HELP^HLEVSTUP(776.999,4);4;
"KRN",.403,26,-1)
0^1
"KRN",.403,26,0)
HL SITE PARAMETERS^@^@^^2980430.1006^^^869.3^0^0^1
"KRN",.403,26,40,0)
^.4031I^3^3
"KRN",.403,26,40,1,0)
1^^1,1^2
"KRN",.403,26,40,1,1)
Page 1
"KRN",.403,26,40,1,40,0)
^.4032IP^160^3
"KRN",.403,26,40,1,40,135,0)
HL SITE PARAM HEAD^1^1,1^e
"KRN",.403,26,40,1,40,136,0)
HL SITE PARAM DATA^2^2,1^e
"KRN",.403,26,40,1,40,160,0)
HL SITE PARAM VIEWS^3^13,1^e
"KRN",.403,26,40,1,40,160,2)
4
"KRN",.403,26,40,2,0)
1.1^^4,5^^^1^14,75
"KRN",.403,26,40,2,1)
Page 1.1^
"KRN",.403,26,40,2,40,0)
^.4032IP^159^2
"KRN",.403,26,40,2,40,158,0)
HL VIEW POPUP^1^1,2^e
"KRN",.403,26,40,2,40,159,0)
HL VIEW MULTIPLE^2^5,2^e
"KRN",.403,26,40,2,40,159,2)
4
"KRN",.403,26,40,3,0)
2^^1,1^1^1
"KRN",.403,26,40,3,1)
Page 2
"KRN",.403,26,40,3,40,0)
^.4032IP^161^1
"KRN",.403,26,40,3,40,161,0)
HL SITE PARAM PAGE 2^1^1,1^e
"KRN",.404,135,0)
HL SITE PARAM HEAD^869.3^
"KRN",.404,135,40,0)
^.4044I^2^2
"KRN",.404,135,40,1,0)
1^Edit HL7 Site Parameters^1
"KRN",.404,135,40,1,2)
^^1,26
"KRN",.404,135,40,2,0)
2^Page 1 of 2^1
"KRN",.404,135,40,2,2)
^^1,68
"KRN",.404,136,0)
HL SITE PARAM DATA^869.3
"KRN",.404,136,40,0)
^.4044I^16^9
"KRN",.404,136,40,1,0)
1^Current Domain^3
"KRN",.404,136,40,1,1)
.02
"KRN",.404,136,40,1,2)
3,39^30^3,23
"KRN",.404,136,40,1,4)
1
"KRN",.404,136,40,2,0)
2^Current Institution^3
"KRN",.404,136,40,2,1)
.04
"KRN",.404,136,40,2,2)
4,39^30^4,18
"KRN",.404,136,40,2,4)
1
"KRN",.404,136,40,3,0)
3^Is this a Production or Test Account?^3
"KRN",.404,136,40,3,1)
.03
"KRN",.404,136,40,3,2)
5,39^10^5,1^1
"KRN",.404,136,40,3,4)
1
"KRN",.404,136,40,6,0)
4^Mail Group for Alerts^3
"KRN",.404,136,40,6,1)
.05
"KRN",.404,136,40,6,2)
7,39^30^7,16
"KRN",.404,136,40,12,0)
12^Page 1 of 2^1
"KRN",.404,136,40,12,2)
^^1,1
"KRN",.404,136,40,13,0)
13^------------------------------------------------------------------------------^1
"KRN",.404,136,40,13,2)
^^1,1
"KRN",.404,136,40,14,0)
14^System Link Monitor VIEWS^1
"KRN",.404,136,40,14,2)
^^10,1
"KRN",.404,136,40,15,0)
15^-------------------------^1
"KRN",.404,136,40,15,2)
^^11,1
"KRN",.404,136,40,16,0)
16^[Goto next page to edit Background Process Parameters]^1
"KRN",.404,136,40,16,2)
^^16,13
"KRN",.404,158,0)
HL VIEW POPUP^869.31
"KRN",.404,158,40,0)
^.4044I^6^6
"KRN",.404,158,40,1,0)
1^System Link Monitor View^1
"KRN",.404,158,40,1,2)
^^1,22
"KRN",.404,158,40,2,0)
2^NAME^3
"KRN",.404,158,40,2,1)
.01
"KRN",.404,158,40,2,2)
2,27^20^2,21
"KRN",.404,158,40,3,0)
3^LOGICAL LINK^1
"KRN",.404,158,40,3,2)
^^4,2
"KRN",.404,158,40,4,0)
4^DISPLAY ORDER^1
"KRN",.404,158,40,4,2)
^^4,23
"KRN",.404,158,40,5,0)
5^------------^1
"KRN",.404,158,40,5,2)
^^5,2
"KRN",.404,158,40,6,0)
6^-------------^1
"KRN",.404,158,40,6,2)
^^5,23
"KRN",.404,159,0)
HL VIEW MULTIPLE^869.311
"KRN",.404,159,40,0)
^.4044I^2^2
"KRN",.404,159,40,1,0)
1^^3
"KRN",.404,159,40,1,1)
.01
"KRN",.404,159,40,1,2)
2,2^10
"KRN",.404,159,40,2,0)
2^^3
"KRN",.404,159,40,2,1)
1
"KRN",.404,159,40,2,2)
2,25^4
"KRN",.404,160,0)
HL SITE PARAM VIEWS^869.31
"KRN",.404,160,40,0)
^.4044I^1^1
"KRN",.404,160,40,1,0)
1^^3
"KRN",.404,160,40,1,1)
.01
"KRN",.404,160,40,1,2)
1,1^20
"KRN",.404,160,40,1,10)
S DDSSTACK=1.1
"KRN",.404,161,0)
HL SITE PARAM PAGE 2^869.3
"KRN",.404,161,40,0)
^.4044I^11^11
"KRN",.404,161,40,1,0)
1^Edit HL7 Site Parameters ^1
"KRN",.404,161,40,1,2)
^^1,26
"KRN",.404,161,40,2,0)
2^Page 2 of 2^1
"KRN",.404,161,40,2,2)
^^1,68
"KRN",.404,161,40,3,0)
4^------------------------------------------------------------------------------^1
"KRN",.404,161,40,3,2)
^^3,1
"KRN",.404,161,40,4,0)
3^Background Processes Parameters^1
"KRN",.404,161,40,4,2)
^^2,23
"KRN",.404,161,40,5,0)
5^Default Number of Incoming Filers^3
"KRN",.404,161,40,5,1)
11
"KRN",.404,161,40,5,2)
5,39^2^5,4
"KRN",.404,161,40,6,0)
6^Default Number of Outgoing Filers^3
"KRN",.404,161,40,6,1)
12
"KRN",.404,161,40,6,2)
6,39^2^6,4
"KRN",.404,161,40,7,0)
7^Days to Keep Completed Messages^3
"KRN",.404,161,40,7,1)
41
"KRN",.404,161,40,7,2)
9,39^3^9,6
"KRN",.404,161,40,8,0)
8^Days Before Purging All Messages^3
"KRN",.404,161,40,8,1)
43
"KRN",.404,161,40,8,2)
10,39^3^10,5
"KRN",.404,161,40,9,0)
9^Days to Keep Awaiting ACK Messages^3
"KRN",.404,161,40,9,1)
42
"KRN",.404,161,40,9,2)
11,39^3^11,3
"KRN",.404,161,40,10,0)
11^Default Retention Time^3
"KRN",.404,161,40,10,1)
51
"KRN",.404,161,40,10,2)
15,39^6^15,15
"KRN",.404,161,40,11,0)
10^Days to Keep Error Status Messages^3^^
"KRN",.404,161,40,11,1)
44
"KRN",.404,161,40,11,2)
12,39^3^12,3
"KRN",3.8,24,-1)
0^1
"KRN",3.8,24,0)
HLEV EVENT MONITOR^PR^^^^^
"KRN",3.8,24,3)

"KRN",3.8,24,6,0)
^3.812^1^1
"KRN",3.8,24,6,1,0)
HL7SystemMonitoring@MED.VA.GOV
"KRN",3.8,24,6,"B","HL7SystemMonitoring@MED.VA.GOV",1)

"KRN",3.8,25,-1)
0^2
"KRN",3.8,25,0)
HLEV SERVER^PR^^^^^
"KRN",3.8,25,3)

"KRN",3.8,25,6,0)
^3.812^1^1
"KRN",3.8,25,6,1,0)
HL7SystemMonitoring@MED.VA.GOV
"KRN",3.8,25,6,"B","HL7SystemMonitoring@MED.VA.GOV",1)

"KRN",19,634,-1)
2^28
"KRN",19,634,0)
HL MAIN MENU^HL7 Main Menu^^M^6^^^^^^y^9^y
"KRN",19,634,10,0)
^19.01IP^14^14
"KRN",19,634,10,10,0)
760^^3
"KRN",19,634,10,10,"^")
HL MENU MSG TRANS MGT
"KRN",19,634,10,14,0)
914^^1
"KRN",19,634,10,14,"^")
HLEV MENU MAIN
"KRN",19,634,"U")
HL7 MAIN MENU
"KRN",19,760,-1)
2^1
"KRN",19,760,0)
HL MENU MSG TRANS MGT^Message Management Options^^M^73^^^^^^^9^y
"KRN",19,760,10,0)
^19.01IP^21^21
"KRN",19,760,10,20,0)
894^PJM^2.5
"KRN",19,760,10,20,"^")
HL PURGE JOB REVIEW
"KRN",19,760,10,21,0)
954^ELOG^7
"KRN",19,760,10,21,"^")
HLEM EVENT LOG
"KRN",19,760,"U")
MESSAGE MANAGEMENT OPTIONS
"KRN",19,894,-1)
0^2
"KRN",19,894,0)
HL PURGE JOB REVIEW^Purge jobs monitoring^^R^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,894,25)
ASKSHOW^HLUOPT4
"KRN",19,894,"U")
PURGE JOBS MONITORING
"KRN",19,914,-1)
0^5
"KRN",19,914,0)
HLEV MENU MAIN^Event monitoring menu^^M^^^^^^^^HEALTH LEVEL SEVEN^^1
"KRN",19,914,10,0)
^19.01IP^2^2
"KRN",19,914,10,1,0)
915^^1
"KRN",19,914,10,1,"^")
HLEV MENU SETUP
"KRN",19,914,10,2,0)
916^^2
"KRN",19,914,10,2,"^")
HLEV MENU RUNTIME
"KRN",19,914,20)
D SYSETUP^HLEVAPI1
"KRN",19,914,99)
59396,38603
"KRN",19,914,"U")
EVENT MONITORING MENU
"KRN",19,915,-1)
0^7
"KRN",19,915,0)
HLEV MENU SETUP^Setup & maintenance options^^M^^^^^^^^HEALTH LEVEL SEVEN^^^1
"KRN",19,915,10,0)
^19.01IP^3^3
"KRN",19,915,10,1,0)
920^^1
"KRN",19,915,10,1,"^")
HLEV MENU SETUP-MONITOR
"KRN",19,915,10,2,0)
921^^2
"KRN",19,915,10,2,"^")
HLEV MENU SETUP-MASTER
"KRN",19,915,10,3,0)
935^^99
"KRN",19,915,10,3,"^")
HLEV MENU REPORTS
"KRN",19,915,15)
D SYSETUP^HLEVAPI1
"KRN",19,915,99)
59396,38605
"KRN",19,915,"U")
SETUP & MAINTENANCE OPTIONS
"KRN",19,916,-1)
0^6
"KRN",19,916,0)
HLEV MENU RUNTIME^Run-time options^^M^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,916,10,0)
^19.01IP^9^9
"KRN",19,916,10,2,0)
918^^4
"KRN",19,916,10,2,"^")
HLEV PRINT MONITOR SETUP
"KRN",19,916,10,3,0)
919^^1
"KRN",19,916,10,3,"^")
HLEV PRINT MASTER SETUP
"KRN",19,916,10,4,0)
927^^6
"KRN",19,916,10,4,"^")
HLEV ONE-TIME MONITOR RUN
"KRN",19,916,10,7,0)
930
"KRN",19,916,10,7,"^")
HLEV MONITOR MAP REPORT
"KRN",19,916,10,8,0)
931
"KRN",19,916,10,8,"^")
HLEV MONITOR DETAILS
"KRN",19,916,10,9,0)
933
"KRN",19,916,10,9,"^")
HLEV MASTER JOB NOW
"KRN",19,916,99)
59457,34828
"KRN",19,916,"U")
RUN-TIME OPTIONS
"KRN",19,918,-1)
0^20
"KRN",19,918,0)
HLEV PRINT MONITOR SETUP^Monitor setup details^^R^^^^^^^^
"KRN",19,918,25)
SHOW7761^HLEVREP
"KRN",19,918,"U")
MONITOR SETUP DETAILS
"KRN",19,919,-1)
0^19
"KRN",19,919,0)
HLEV PRINT MASTER SETUP^Settings of monitoring parameters^^R^^^^^^^^
"KRN",19,919,25)
VIEW7769^HLEVREP(1)
"KRN",19,919,"U")
SETTINGS OF MONITORING PARAMET
"KRN",19,920,-1)
0^9
"KRN",19,920,0)
HLEV MENU SETUP-MONITOR^Monitor setup & maintenance^^M^^^^^^^^HEALTH LEVEL SEVEN^^
"KRN",19,920,10,0)
^19.01IP^3^3
"KRN",19,920,10,1,0)
922
"KRN",19,920,10,1,"^")
HLEV EDIT MONITOR
"KRN",19,920,10,2,0)
918^
"KRN",19,920,10,2,"^")
HLEV PRINT MONITOR SETUP
"KRN",19,920,10,3,0)
923
"KRN",19,920,10,3,"^")
HLEV EDIT MONITOR ON-OFF
"KRN",19,920,20)

"KRN",19,920,99)
59396,38604
"KRN",19,920,"U")
MONITOR SETUP & MAINTENANCE
"KRN",19,921,-1)
0^8
"KRN",19,921,0)
HLEV MENU SETUP-MASTER^System setup & maintenance^^M^^^^^^^^HEALTH LEVEL SEVEN^^1
"KRN",19,921,10,0)
^19.01IP^6^6
"KRN",19,921,10,1,0)
924
"KRN",19,921,10,1,"^")
HLEV EDIT MASTER
"KRN",19,921,10,2,0)
919^
"KRN",19,921,10,2,"^")
HLEV PRINT MASTER SETUP
"KRN",19,921,10,3,0)
925
"KRN",19,921,10,3,"^")
HLEV EDIT MASTER ON-OFF
"KRN",19,921,10,4,0)
928
"KRN",19,921,10,4,"^")
HLEV MASTER JOB START
"KRN",19,921,10,5,0)
929
"KRN",19,921,10,5,"^")
HLEV MASTER JOB STOP
"KRN",19,921,10,6,0)
939
"KRN",19,921,10,6,"^")
HLEV GRANT REMOTE LICENSE
"KRN",19,921,20)
D SYSETUP^HLEVAPI1
"KRN",19,921,99)
59396,38605
"KRN",19,921,"U")
SYSTEM SETUP & MAINTENANCE
"KRN",19,922,-1)
0^3
"KRN",19,922,0)
HLEV EDIT MONITOR^Enter/edit event monitors^^R^^^^^^^^
"KRN",19,922,25)
E7761^HLEVSTUP
"KRN",19,922,"U")
ENTER/EDIT EVENT MONITORS
"KRN",19,923,-1)
0^4
"KRN",19,923,0)
HLEV EDIT MONITOR ON-OFF^Turn on/off event monitor^^R^^^^^^^^
"KRN",19,923,25)
ONOFFEV^HLEVAPI0
"KRN",19,923,"U")
TURN ON/OFF EVENT MONITOR
"KRN",19,924,-1)
0^45
"KRN",19,924,0)
HLEV EDIT MASTER^Edit parameters^^R^^^^^^^^
"KRN",19,924,25)
E7769^HLEVSTUP
"KRN",19,924,"U")
EDIT PARAMETERS
"KRN",19,925,-1)
0^46
"KRN",19,925,0)
HLEV EDIT MASTER ON-OFF^Turn on/off monitoring^^R^^^^^^^^
"KRN",19,925,25)
ONOFFPAR^HLEVAPI0
"KRN",19,925,"U")
TURN ON/OFF MONITORING
"KRN",19,927,-1)
0^11
"KRN",19,927,0)
HLEV ONE-TIME MONITOR RUN^One-time monitor run^^R^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,927,25)
ONETIME^HLEVAPI1
"KRN",19,927,"U")
ONE-TIME MONITOR RUN
"KRN",19,928,-1)
0^14
"KRN",19,928,0)
HLEV MASTER JOB START^Monitoring master job start^^R^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,928,25)
STARTMST^HLEVMST0
"KRN",19,928,"U")
MONITORING MASTER JOB START
"KRN",19,929,-1)
0^15
"KRN",19,929,0)
HLEV MASTER JOB STOP^Stop monitoring master job^^R^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,929,25)
UNQUEUE^HLEVMST0
"KRN",19,929,"U")
STOP MONITORING MASTER JOB
"KRN",19,930,-1)
0^17
"KRN",19,930,0)
HLEV MONITOR MAP REPORT^Map of monitoring activity^^R^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,930,25)
CTRL^HLEVREP1
"KRN",19,930,"U")
MAP OF MONITORING ACTIVITY
"KRN",19,931,-1)
0^16
"KRN",19,931,0)
HLEV MONITOR DETAILS^Results of a monitor run^^R^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,931,25)
CTRL^HLEVREP2
"KRN",19,931,"U")
RESULTS OF A MONITOR RUN
"KRN",19,932,-1)
0^21
"KRN",19,932,0)
HLEV-INFORMATION-SERVER^Event monitoring server^^S^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,932,25)
HLEVSRV
"KRN",19,932,220)
XQSERVER^R^HLEV SERVER^N^Y^E^0
"KRN",19,932,"U")
EVENT MONITORING SERVER
"KRN",19,933,-1)
0^22
"KRN",19,933,0)
HLEV MASTER JOB NOW^Run monitor master job now^^R^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,933,25)
MSTNOW^HLEVMST0
"KRN",19,933,"U")
RUN MONITOR MASTER JOB NOW
"KRN",19,935,-1)
0^23
"KRN",19,935,0)
HLEV MENU REPORTS^Reports^^M^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,935,10,0)
^19.01IP^3^3
"KRN",19,935,10,1,0)
936
"KRN",19,935,10,1,"^")
HLEV REPORT MONITOR RECIPIENTS
"KRN",19,935,10,2,0)
937
"KRN",19,935,10,2,"^")
HLEV REPORT CONDENSED MONITOR
"KRN",19,935,10,3,0)
938
"KRN",19,935,10,3,"^")
HLEV REPORT REMOTE REQUESTABLE
"KRN",19,935,99)
59396,38605
"KRN",19,935,"U")
REPORTS
"KRN",19,936,-1)
0^25
"KRN",19,936,0)
HLEV REPORT MONITOR RECIPIENTS^Message recipients^^R^^^^^^^^
"KRN",19,936,25)
RECIP^HLEVREP0
"KRN",19,936,"U")
MESSAGE RECIPIENTS
"KRN",19,937,-1)
0^24
"KRN",19,937,0)
HLEV REPORT CONDENSED MONITOR^Condensed monitor report^^R^^^^^^^^
"KRN",19,937,25)
CONDMON^HLEVREP0
"KRN",19,937,"U")
CONDENSED MONITOR REPORT
"KRN",19,938,-1)
0^26
"KRN",19,938,0)
HLEV REPORT REMOTE REQUESTABLE^Remote requestable report^^R^^^^^^^^
"KRN",19,938,25)
REMREQO^HLEVREP3
"KRN",19,938,"U")
REMOTE REQUESTABLE REPORT
"KRN",19,939,-1)
0^27
"KRN",19,939,0)
HLEV GRANT REMOTE LICENSE^Grant remote request license^^R^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,939,25)
OPENMAIL^HLEVSRV3
"KRN",19,939,"U")
GRANT REMOTE REQUEST LICENSE
"KRN",19,950,-1)
0^95
"KRN",19,950,0)
HLEM EVENT LOG SERVER^HLEM EVENT LOG SERVER^^S^^^^^^^n^HEALTH LEVEL SEVEN
"KRN",19,950,1,0)
^^1^1^3030924^
"KRN",19,950,1,1,0)
This is a Mailman Server for receiving HL7 Monitor Events from remote locations.
"KRN",19,950,25)
RECEIVE^HLEMRCV
"KRN",19,950,220)
^R^^N^Y^N^1
"KRN",19,950,"U")
HLEM EVENT LOG SERVER
"KRN",19,954,-1)
0^96
"KRN",19,954,0)
HLEM EVENT LOG^Event Log^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,954,1,0)
^19.06^1^1^3031208^^
"KRN",19,954,1,1,0)
Provides the abilty to view the HL7 Event Log and Event Log Statistics.
"KRN",19,954,20)
D EN^HLEMSL
"KRN",19,954,"U")
EVENT LOG
"KRN",101,371,-1)
0^14
"KRN",101,371,0)
HLEM EVENTS MENU^HL7 Monitor Events Log Menu^^M^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,371,1,0)
^101.06^2^2^3031008^^^^
"KRN",101,371,1,1,0)
This protocol menu contains all the activities for acting on lists of
"KRN",101,371,1,2,0)
HL7 Monitor Events.
"KRN",101,371,4)
26^4
"KRN",101,371,10,0)
^101.01PA^6^6
"KRN",101,371,10,1,0)
381^SP^1^^^Select Profile
"KRN",101,371,10,1,"^")
HLEM SELECT PROFILE
"KRN",101,371,10,2,0)
385^DE^2^^^Display Event
"KRN",101,371,10,2,"^")
HLEM DISPLAY EVENT
"KRN",101,371,10,3,0)
393^GO^3^^^Goto Site
"KRN",101,371,10,3,"^")
HLEM GOTO SITE
"KRN",101,371,10,4,0)
398^ST^4^^^Statistics
"KRN",101,371,10,4,"^")
HLEM STATISTICS
"KRN",101,371,10,5,0)
399^NP^5^^^New Profile
"KRN",101,371,10,5,"^")
HLEM NEW PROFILE
"KRN",101,371,10,6,0)
400^EP^6^^^Edit Profile
"KRN",101,371,10,6,"^")
HLEM EDIT PROFILE
"KRN",101,371,24)
I 1 X:$D(^ORD(101,+$P(^ORD(101,DA(1),10,DA,0),"^",1),24)) ^(24)
"KRN",101,371,26)
D SHOW^VALM
"KRN",101,371,28)
Select Action:
"KRN",101,371,99)
59450,37084
"KRN",101,381,-1)
0^9
"KRN",101,381,0)
HLEM SELECT PROFILE^SELECT PROFILE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,381,1,0)
^^2^2^3030730^
"KRN",101,381,1,1,0)
This ListManager protocol allows the user to select the HL7 Monitor Events
"KRN",101,381,1,2,0)
Profile to use while working with HL7 Monitor Events Log.
"KRN",101,381,2,0)
^101.02A^1^1
"KRN",101,381,2,1,0)
SP
"KRN",101,381,2,"B","SP",1)

"KRN",101,381,20)
D SELECT^HLEMSL1
"KRN",101,381,24)
N A I $$FINDALL^HLEMP1($G(DUZ),"A")>1
"KRN",101,381,99)
59380,41447
"KRN",101,384,-1)
0^11
"KRN",101,384,0)
HLEM SINGLE EVENT MENU^HLEM SINGLE EVENT MENU^^M^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,384,1,0)
^101.06^2^2^3030731^^^^
"KRN",101,384,1,1,0)
This protocol menu contains all the activities for acting on a single
"KRN",101,384,1,2,0)
HL7 Monitor Event.
"KRN",101,384,4)
26^4
"KRN",101,384,10,0)
^101.01PA^3^3
"KRN",101,384,10,1,0)
386^E^3^^^Edit Event
"KRN",101,384,10,1,"^")
HLEM EDIT EVENT
"KRN",101,384,10,2,0)
387^H^6^^^Help
"KRN",101,384,10,2,"^")
HLEM EVENT HELP
"KRN",101,384,10,3,0)
388^V^3^^^View App's Data
"KRN",101,384,10,3,"^")
HLEM DISPLAY APPLICATION DATA
"KRN",101,384,24)
I 1 X:$D(^ORD(101,+$P(^ORD(101,DA(1),10,DA,0),"^",1),24)) ^(24)
"KRN",101,384,26)
D SHOW^VALM
"KRN",101,384,28)
Select Action:
"KRN",101,384,99)
59457,33050
"KRN",101,385,-1)
0^3
"KRN",101,385,0)
HLEM DISPLAY EVENT^HLEM DISPLAY EVENT^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,385,1,0)
^101.06^2^2^3030731^^
"KRN",101,385,1,1,0)
This ListManager protocol allows the user to select the a single HL7
"KRN",101,385,1,2,0)
Monitor Event for display and editing.
"KRN",101,385,2,0)
^101.02A^1^1
"KRN",101,385,2,1,0)
DE
"KRN",101,385,2,"B","DE",1)

"KRN",101,385,20)
D SELECTE^HLEMSL1
"KRN",101,385,99)
59381,39399
"KRN",101,385,101.04)
^^^^
"KRN",101,386,-1)
0^13
"KRN",101,386,0)
HLEM EDIT EVENT^EDIT EVENT^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,386,1,0)
^^1^1^3030801^
"KRN",101,386,1,1,0)
Allows an event to be updated with notes and review status.
"KRN",101,386,2,0)
^101.02A^1^1
"KRN",101,386,2,1,0)
EE
"KRN",101,386,2,"B","EE",1)

"KRN",101,386,20)
D EDIT^HLEMSE1($G(EVENT("IEN")))
"KRN",101,386,99)
59382,35739
"KRN",101,387,-1)
0^5
"KRN",101,387,0)
HLEM EVENT HELP^HELP^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,387,1,0)
^^2^2^3030801^
"KRN",101,387,1,1,0)
Provides detailed information and instructions for an event based on the even
"KRN",101,387,1,2,0)
type.
"KRN",101,387,2,0)
^101.02A^1^1
"KRN",101,387,2,1,0)
EH
"KRN",101,387,2,"B","EH",1)

"KRN",101,387,4)
^^^HLEM EVENT HELP
"KRN",101,387,20)
D HELP^HLEMSE1($G(EVENT("TYPE")))
"KRN",101,387,99)
59382,38210
"KRN",101,388,-1)
0^2
"KRN",101,388,0)
HLEM DISPLAY APPLICATION DATA^APPLICATION DATA^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,388,1,0)
^^1^1^3030801^
"KRN",101,388,1,1,0)
Displays application-specfic data that is associated with the event.
"KRN",101,388,2,0)
^101.02A^1^1
"KRN",101,388,2,1,0)
AD
"KRN",101,388,2,"B","AD",1)

"KRN",101,388,20)
D APPDATA^HLEMSE1($G(EVENT("IEN")))
"KRN",101,388,24)
I $G(EVENT("IEN")),$O(^HLEV(776.4,EVENT("IEN"),3,0))
"KRN",101,388,99)
59382,42413
"KRN",101,393,-1)
0^7
"KRN",101,393,0)
HLEM GOTO SITE^GOTO SITE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,393,1,0)
^101.06^1^1^3031008^^^
"KRN",101,393,1,1,0)
Allows a user to select a site and jumps the screen to that site.
"KRN",101,393,2,0)
^101.02A^2^1
"KRN",101,393,2,2,0)
GO
"KRN",101,393,2,"B","GO",2)

"KRN",101,393,20)
D GOSITE^HLEMSL1
"KRN",101,393,24)
I $$CNTSITES^HLEMSL1>1
"KRN",101,393,99)
59388,46059
"KRN",101,396,-1)
0^6
"KRN",101,396,0)
HLEM EVENT STATISTICS MENU^EVENT STATISTICS MENU^^M^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,396,1,0)
^101.06^2^2^3031015^^^^
"KRN",101,396,1,1,0)
This protocol menu contains all the activities for viewing HL7 Event Log
"KRN",101,396,1,2,0)
Statistics.
"KRN",101,396,4)
26^4
"KRN",101,396,10,0)
^101.01PA^5^3
"KRN",101,396,10,3,0)
393^GO^1^^^Goto Site
"KRN",101,396,10,3,"^")
HLEM GOTO SITE
"KRN",101,396,10,4,0)
397^SP^2^^^Select Profile
"KRN",101,396,10,4,"^")
HLEM SELECT PROFILE (STATS)
"KRN",101,396,10,5,0)
401^CD^3^^^Change Date Range
"KRN",101,396,10,5,"^")
HLEM CHANGE DATE RANGE
"KRN",101,396,20)

"KRN",101,396,24)
I 1 X:$D(^ORD(101,+$P(^ORD(101,DA(1),10,DA,0),"^",1),24)) ^(24)
"KRN",101,396,26)
D SHOW^VALM
"KRN",101,396,28)
Select Action:
"KRN",101,396,99)
59457,31958
"KRN",101,397,-1)
0^10
"KRN",101,397,0)
HLEM SELECT PROFILE (STATS)^SELECT PROFILE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,397,1,0)
^101.06^3^3^3031008^^^
"KRN",101,397,1,1,0)
This ListManager protocol allows the user to select the HL7 Monitor Events
"KRN",101,397,1,2,0)
Profile to use while working with HL7 Monitor Events Log. Called from within
"KRN",101,397,1,3,0)
the Statistics screen.
"KRN",101,397,2,0)
^101.02A^1^1
"KRN",101,397,2,1,0)
SP
"KRN",101,397,2,"B","SP",1)

"KRN",101,397,4)
^^^SP
"KRN",101,397,20)
D SELECT^HLEMST
"KRN",101,397,99)
59450,27370
"KRN",101,398,-1)
0^12
"KRN",101,398,0)
HLEM STATISTICS^STATISTICS^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,398,1,0)
^^1^1^3031008^
"KRN",101,398,1,1,0)
This action will display the statistics menu.
"KRN",101,398,2,0)
^101.02A^1^1
"KRN",101,398,2,1,0)
ST
"KRN",101,398,2,"B","ST",1)

"KRN",101,398,4)
^^^ST
"KRN",101,398,20)
D EN^HLEMST
"KRN",101,398,99)
59450,31040
"KRN",101,399,-1)
0^8
"KRN",101,399,0)
HLEM NEW PROFILE^NEW PROFILE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,399,1,0)
^101.06^2^2^3031008^^
"KRN",101,399,1,1,0)
This ListManager protocol allows the user to create a new HL7 Monitor Events
"KRN",101,399,1,2,0)
Profile to use while working with HL7 Monitor Events Log.
"KRN",101,399,2,0)
^101.02A^2^1
"KRN",101,399,2,2,0)
NEW
"KRN",101,399,2,"B","NEW",2)

"KRN",101,399,20)
D NEW^HLEMSL1
"KRN",101,399,99)
59450,34410
"KRN",101,400,-1)
0^4
"KRN",101,400,0)
HLEM EDIT PROFILE^EDIT PROFILE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,400,1,0)
^101.06^2^2^3031008^^
"KRN",101,400,1,1,0)
This ListManager protocol allows the user to select the HL7 Monitor Events
"KRN",101,400,1,2,0)
Profile to edit.
"KRN",101,400,2,0)
^101.02A^2^1
"KRN",101,400,2,2,0)
EP
"KRN",101,400,2,"B","EP",2)

"KRN",101,400,20)
D EDIT^HLEMSL1
"KRN",101,400,24)

"KRN",101,400,99)
59450,35120
"KRN",101,401,-1)
0^1
"KRN",101,401,0)
HLEM CHANGE DATE RANGE^CHANGE DATE RANGE^^A^^^^^^^^HEALTH LEVEL SEVEN
"KRN",101,401,1,0)
^101.06^3^3^3031015^^^^
"KRN",101,401,1,1,0)
This ListManager protocol allows the user to select the starting date to use
"KRN",101,401,1,2,0)
while working with HL7 Monitor Events Log. Called from withinthe Statistics
"KRN",101,401,1,3,0)
screen.
"KRN",101,401,2,0)
^101.02A^1^1
"KRN",101,401,2,1,0)
CD
"KRN",101,401,2,"B","CD",1)

"KRN",101,401,4)
^^^SP
"KRN",101,401,20)
D CHNGDATE^HLEMST
"KRN",101,401,99)
59457,31523
"KRN",409.61,232,-1)
0^2
"KRN",409.61,232,0)
HLEM DISPLAY EVENTS^1^^80^4^18^1^1^HL7 MONITOR EVENT^HLEM EVENTS MENU^HL7 MONITOR EVENTS^1^^1
"KRN",409.61,232,1)
^VALM HIDDEN ACTIONS
"KRN",409.61,232,"ARRAY")
 ^TMP("HLEM",$J,"EVENTS")
"KRN",409.61,232,"FNL")
D EXIT^HLEMSL
"KRN",409.61,232,"HDR")
D HDR^HLEMSL
"KRN",409.61,232,"HLP")
D HELP^HLEMSL
"KRN",409.61,232,"INIT")
D INIT^HLEMSL
"KRN",409.61,234,-1)
0^3
"KRN",409.61,234,0)
HLEM DISPLAY ONE EVENT^1^^80^2^18^1^1^HL7 MONITOR EVENT^HLEM SINGLE EVENT MENU^HL7 MONITOR EVENT^1^^1
"KRN",409.61,234,1)
^VALM HIDDEN ACTIONS
"KRN",409.61,234,"ARRAY")
 ^TMP("HLEM",$J,"EVENT")
"KRN",409.61,234,"FNL")
D EXIT^HLEMSE
"KRN",409.61,234,"HDR")
D HDR^HLEMSE
"KRN",409.61,234,"HLP")
D HELP^HLEMSE
"KRN",409.61,234,"INIT")
D INIT^HLEMSE
"KRN",409.61,235,-1)
0^5
"KRN",409.61,235,0)
HLEM EVENT HELP^1^1^80^2^22^1^1^HL7 MONITOR EVENT HELP^^HL7 MONITOR EVENT HELP^1^^1
"KRN",409.61,235,1)
^VALM HIDDEN ACTIONS
"KRN",409.61,235,"ARRAY")

"KRN",409.61,235,"FNL")
D EXIT^HLEMSH
"KRN",409.61,235,"HDR")
D HDR^HLEMSH
"KRN",409.61,235,"HLP")
D HELP^HLEMSH
"KRN",409.61,235,"INIT")
D INIT^HLEMSH
"KRN",409.61,236,-1)
0^1
"KRN",409.61,236,0)
HLEM DISPLAY APPLICATION DATA^1^1^80^2^22^1^1^APPLICATION-SPECIFIC DATA^^APPLICATION SPECIFIC DATA^1^^1
"KRN",409.61,236,1)
^VALM HIDDEN ACTIONS
"KRN",409.61,236,"ARRAY")
 ^TMP("HLEM APP DATA",$J)
"KRN",409.61,236,"FNL")
D EXIT^HLEMSA
"KRN",409.61,236,"HDR")
D HDR^HLEMSA
"KRN",409.61,236,"HLP")
D HELP^HLEMSA
"KRN",409.61,236,"INIT")
D INIT^HLEMSA
"KRN",409.61,237,-1)
0^4
"KRN",409.61,237,0)
HLEM DISPLAY STATISTICS^1^^80^4^21^1^1^HL7 EVENT STATISTIC^HLEM EVENT STATISTICS MENU^HL7 EVENT STATISTICS^1^^1
"KRN",409.61,237,1)
^VALM HIDDEN ACTIONS
"KRN",409.61,237,"ARRAY")
 ^TMP("HLEM",$J,"STATISTICS")
"KRN",409.61,237,"FNL")
D EXIT^HLEMST
"KRN",409.61,237,"HDR")
D HDR^HLEMST
"KRN",409.61,237,"HLP")
D HELP^HLEMST
"KRN",409.61,237,"INIT")
D INIT^HLEMST
"MBREQ")
0
"ORD",5,.4)
.4;5;;;EDEOUT^DIFROMSO(.4,DA,"",XPDA);FPRE^DIFROMSI(.4,"",XPDA);EPRE^DIFROMSI(.4,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.4,DA,"",XPDA);DEL^DIFROMSK(.4,"",%)
"ORD",5,.4,0)
PRINT TEMPLATE
"ORD",6,.401)
.401;6;;;EDEOUT^DIFROMSO(.401,DA,"",XPDA);FPRE^DIFROMSI(.401,"",XPDA);EPRE^DIFROMSI(.401,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.401,DA,"",XPDA);DEL^DIFROMSK(.401,"",%)
"ORD",6,.401,0)
SORT TEMPLATE
"ORD",7,.402)
.402;7;;;EDEOUT^DIFROMSO(.402,DA,"",XPDA);FPRE^DIFROMSI(.402,"",XPDA);EPRE^DIFROMSI(.402,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.402,DA,"",XPDA);DEL^DIFROMSK(.402,"",%)
"ORD",7,.402,0)
INPUT TEMPLATE
"ORD",8,.403)
.403;8;;;EDEOUT^DIFROMSO(.403,DA,"",XPDA);FPRE^DIFROMSI(.403,"",XPDA);EPRE^DIFROMSI(.403,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.403,DA,"",XPDA);DEL^DIFROMSK(.403,"",%)
"ORD",8,.403,0)
FORM
"ORD",11,3.8)
3.8;11;;;MAILG^XPDTA1;MAILGF1^XPDIA1;MAILGE1^XPDIA1;MAILGF2^XPDIA1;;MAILGDEL^XPDIA1(%)
"ORD",11,3.8,0)
MAIL GROUP
"ORD",15,101)
101;15;;;PRO^XPDTA;PROF1^XPDIA;PROE1^XPDIA;PROF2^XPDIA;;PRODEL^XPDIA
"ORD",15,101,0)
PROTOCOL
"ORD",17,409.61)
409.61;17;1;;;;;;;LMDEL^XPDIA1
"ORD",17,409.61,0)
LIST TEMPLATE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PGL",776.3,0,2,.02)
PACKAGE^RP9.4'^DIC(9.4,^0;2^Q
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
109^3040212
"PKG",9,22,1,"PAH",1,1,0)
^^2^2^3040212
"PKG",9,22,1,"PAH",1,1,1,0)
See patch HL*1.6*109 in the National Patch Module for complete information
"PKG",9,22,1,"PAH",1,1,2,0)
on this patch.
"PRE")
HLP109EN
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
YES
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
YES
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
YES
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
93
"RTN","HLCS")
0^50^B29807650
"RTN","HLCS",1,0)
HLCS ;ALB/RJS,MTC,JRP - COMMUNICATIONS SERVER - ;05/09/2000  11:21
"RTN","HLCS",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**2,9,14,19,43,57,109**;Oct 13, 1995
"RTN","HLCS",3,0)
 ;
"RTN","HLCS",4,0)
 ;The SEND function is invoked by the transaction processor.
"RTN","HLCS",5,0)
 ;It's function is to $O through the ITEM multiple of the Event Driver
"RTN","HLCS",6,0)
 ;Protocol and create child entries in the Message Text file (#772)
"RTN","HLCS",7,0)
 ;for the message at HLMTIEN.  These child messages point back
"RTN","HLCS",8,0)
 ;to the parent message so that message text does not need to
"RTN","HLCS",9,0)
 ;be duplicated when a message is sent to multiple applications.
"RTN","HLCS",10,0)
 ;
"RTN","HLCS",11,0)
 ;The SENDACK function is also invoked by the transaction processor.
"RTN","HLCS",12,0)
 ;It's function is to create a child entry in the Message Text file
"RTN","HLCS",13,0)
 ;for the message at HLMTIENA and deliver the message to the
"RTN","HLCS",14,0)
 ;application the requested/sent information.
"RTN","HLCS",15,0)
 ;
"RTN","HLCS",16,0)
 ;For DHCP to DHCP messaging (i.e. internal to internal), an incoming
"RTN","HLCS",17,0)
 ;message is created in the Message Text file which is a duplication
"RTN","HLCS",18,0)
 ;of the outgoing message.  The incoming message is then processed by
"RTN","HLCS",19,0)
 ;calling the transaction processor.
"RTN","HLCS",20,0)
 ;
"RTN","HLCS",21,0)
 ;For DHCP to COTS messaging (i.e. internal to external), the message
"RTN","HLCS",22,0)
 ;is filed in the Message Text file with the Logical Link defined and
"RTN","HLCS",23,0)
 ;a status of PENDING TRANSMISSION.  These entries are picked up by
"RTN","HLCS",24,0)
 ;the background filer and transmitted to the appropriate COTS system.
"RTN","HLCS",25,0)
 ;
"RTN","HLCS",26,0)
SEND(HLMTIEN,HLEID,HLRESULT) ;Send an HL7 message
"RTN","HLCS",27,0)
 ;HLMTIEN=The IEN of the parent message in file # 772
"RTN","HLCS",28,0)
 ;HLEID=The IEN of the Event Driver protocol in file #101
"RTN","HLCS",29,0)
 ;HLRESULT=Variable for any error text (pass by reference)
"RTN","HLCS",30,0)
 ;
"RTN","HLCS",31,0)
 ;Declare variables
"RTN","HLCS",32,0)
 N HLARY,HLERROR,HLEIDS,HLCLIENT,HLOGLINK,HLMTIENS,HLMSGPTR
"RTN","HLCS",33,0)
 S HLERROR=""
"RTN","HLCS",34,0)
 ;Direct connect
"RTN","HLCS",35,0)
 I HLPRIO="I" D  Q
"RTN","HLCS",36,0)
 . D DC^HLMA2
"RTN","HLCS",37,0)
 . S HLRESULT=HLERROR
"RTN","HLCS",38,0)
 ;Get all subscribers to the message
"RTN","HLCS",39,0)
 D ITEM^HLUTIL2(HLEID,"PTR")
"RTN","HLCS",40,0)
 ;Quit if no subscribers (considered successful delivery)
"RTN","HLCS",41,0)
 G:($G(HLARY(0))'>0) EXIT
"RTN","HLCS",42,0)
 ;Deliver message to each subscriber
"RTN","HLCS",43,0)
 S HLEIDS=0
"RTN","HLCS",44,0)
 F  S HLEIDS=$O(HLARY(HLEIDS)) Q:(HLEIDS'>0)  D
"RTN","HLCS",45,0)
 .;Get pointer to receiving application
"RTN","HLCS",46,0)
 .S HLCLIENT=+HLARY(HLEIDS),HL("EIDS")=HLEIDS,HLERROR=""
"RTN","HLCS",47,0)
 .Q:(HLCLIENT'>0)
"RTN","HLCS",48,0)
 .;Check and execute ROUTING LOGIC **CIRN**
"RTN","HLCS",49,0)
 .S HLX=$G(^ORD(101,HLEIDS,774))
"RTN","HLCS",50,0)
 .I HLX]"" D  Q
"RTN","HLCS",51,0)
 ..N HLQUIT,HLNODE,HLNEXT
"RTN","HLCS",52,0)
 ..S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLCS",53,0)
 ..X HLX I $D(HLL("LINKS")) D FWD^HLCS2 K HLL ;**CIRN**
"RTN","HLCS",54,0)
 .;Get pointer to logical link
"RTN","HLCS",55,0)
 .S HLOGLINK=$P(HLARY(HLEIDS),"^",2)
"RTN","HLCS",56,0)
 .;Determine if receiving application is internal or external
"RTN","HLCS",57,0)
 .;  Logical link has a value for external applications
"RTN","HLCS",58,0)
 .;  Logical link is NULL for internal applications
"RTN","HLCS",59,0)
 .I (HLOGLINK) D COTS Q
"RTN","HLCS",60,0)
 .;Create 'incoming' message based on 'outgoing' message (internal)
"RTN","HLCS",61,0)
 .D DHCP(HLMTIEN,HLEIDS,HLCLIENT)
"RTN","HLCS",62,0)
 .Q:(HLERROR)
"RTN","HLCS",63,0)
 .;Process the 'incoming' message
"RTN","HLCS",64,0)
 .S HLERROR=""
"RTN","HLCS",65,0)
 .D PROCESS^HLTP0(HLMSGPTR,"DHCP","",.HLERROR)
"RTN","HLCS",66,0)
 .;Update Status of 'incoming' message to SUCCESSFULLY COMPLETED
"RTN","HLCS",67,0)
 .; or ERROR DURING TRANSMISSION
"RTN","HLCS",68,0)
 .D STATUS^HLTF0(HLMSGPTR,$S(HLERROR:4,1:3),$S(HLERROR:+HLERROR,1:""),$S(HLERROR:$P(HLERROR,"^",2),1:""),,$S($G(HLERR("SKIP_EVENT"))=1:1,1:0))
"RTN","HLCS",69,0)
 .I $D(HLL("LINKS")) D FWD^HLCS2 K HLL ;**CIRN**
"RTN","HLCS",70,0)
 D ADD^HLCS2 ;**CIRN**
"RTN","HLCS",71,0)
EXIT S HLRESULT=HLERROR
"RTN","HLCS",72,0)
 Q
"RTN","HLCS",73,0)
COTS ;Internal to external communication
"RTN","HLCS",74,0)
 ;Create child entry in Message Text file
"RTN","HLCS",75,0)
 N HLTCP,HLTCPI,HLTCPO
"RTN","HLCS",76,0)
 D SEND^HLMA2(HLEIDS,HLMTIEN,HLCLIENT,"D",.HLMTIENS,HLOGLINK)
"RTN","HLCS",77,0)
 I ((+HLMTIENS)'>0) S HLERROR=HLMTIENS Q
"RTN","HLCS",78,0)
 ;'Pass' message to background filer by setting status of child
"RTN","HLCS",79,0)
 ;  to PENDING TRANSMISSION
"RTN","HLCS",80,0)
 D STATUS^HLTF0(HLMTIENS,1)
"RTN","HLCS",81,0)
 Q
"RTN","HLCS",82,0)
DHCP(HLMTIEN,HLEIDS,HLCLIENT) ;Internal to internal communication
"RTN","HLCS",83,0)
 ;
"RTN","HLCS",84,0)
 ;Input  : HLMTIEN - Pointer to parent outgoing message (file #772)
"RTN","HLCS",85,0)
 ;         HLEIDS - Pointer to subscribing protocol (file #101)
"RTN","HLCS",86,0)
 ;         HLCLIENT - Pointer to receiving application (file # 771)
"RTN","HLCS",87,0)
 ;
"RTN","HLCS",88,0)
 ;Output : HLMTIENS - Pointer to child outgoing message (file #772)
"RTN","HLCS",89,0)
 ;         HLMSGPTR - Pointer to [parent] incoming message (file #772)
"RTN","HLCS",90,0)
 ;         HLERROR - ErrorCode ^ ErrorText
"RTN","HLCS",91,0)
 ;
"RTN","HLCS",92,0)
 ;Notes  : This module only copies the outgoing message into an incoming
"RTN","HLCS",93,0)
 ;         message.  Delivery of the message (i.e. processing of it)
"RTN","HLCS",94,0)
 ;         must be done by the calling application.
"RTN","HLCS",95,0)
 ;       : Message/batch header (MSH/BSH) is built and placed in the
"RTN","HLCS",96,0)
 ;         incoming message
"RTN","HLCS",97,0)
 ;       : HLMTIENS, HLMSGPTR, and HLERROR will be initialized
"RTN","HLCS",98,0)
 ;       : Existance and validity of input is assumed
"RTN","HLCS",99,0)
 ;
"RTN","HLCS",100,0)
 ;Declare variables
"RTN","HLCS",101,0)
 N MSGID,MSGDT,MSGDTH,HDR2BLD,TMP,HLHDR,BHSHDR
"RTN","HLCS",102,0)
 S HLERROR=""
"RTN","HLCS",103,0)
 S HLMTIENS=0
"RTN","HLCS",104,0)
 S HLMSGPTR=0
"RTN","HLCS",105,0)
 ;Create child entry in Message Text file
"RTN","HLCS",106,0)
 D SEND^HLMA2(HLEIDS,HLMTIEN,HLCLIENT,"D",.HLMTIENS)
"RTN","HLCS",107,0)
 I ((+HLMTIENS)'>0) S HLERROR=HLMTIENS Q
"RTN","HLCS",108,0)
 ;'Receive' message by making an incoming message
"RTN","HLCS",109,0)
 ;Determine type of header to build
"RTN","HLCS",110,0)
 S TMP=$G(^HL(772,HLMTIEN,0))
"RTN","HLCS",111,0)
 S HDR2BLD=$P(TMP,"^",14)
"RTN","HLCS",112,0)
 ;Build message header (MSH)
"RTN","HLCS",113,0)
 I (HDR2BLD="M") D  Q:(HLERROR)
"RTN","HLCS",114,0)
 .S TMP=""
"RTN","HLCS",115,0)
 .D HEADER^HLCSHDR(HLMTIENS,.TMP)
"RTN","HLCS",116,0)
 .Q:(TMP="")
"RTN","HLCS",117,0)
 .;Error building header
"RTN","HLCS",118,0)
 .S HLERROR="4^Unable to build message header => "_TMP
"RTN","HLCS",119,0)
 .D STATUS^HLTF0(HLMTIENS,4,0,$P(HLERROR,"^",2))
"RTN","HLCS",120,0)
 ;Build batch header (BHS or FHS)
"RTN","HLCS",121,0)
 I (HDR2BLD'="M") D  Q:(HLERROR)
"RTN","HLCS",122,0)
 .S TMP=""
"RTN","HLCS",123,0)
 .D BHSHDR^HLCSHDR(HLMTIENS)
"RTN","HLCS",124,0)
 .S:($E(HLHDR(1),1)="-") TMP=$P(HLHDR(1),"^",2)
"RTN","HLCS",125,0)
 .Q:(TMP="")
"RTN","HLCS",126,0)
 .;Error building header
"RTN","HLCS",127,0)
 .S HLERROR="4^Unable to build batch header => "_TMP
"RTN","HLCS",128,0)
 .D STATUS^HLTF0(HLMTIENS,4,0,$P(HLERROR,"^",2))
"RTN","HLCS",129,0)
 ;Create entry for 'incoming' message
"RTN","HLCS",130,0)
 D CREATE^HLTF(.MSGID,.HLMSGPTR,.MSGDT,.MSGDTH)
"RTN","HLCS",131,0)
 ;Move header and rest of message into 'incoming' message
"RTN","HLCS",132,0)
 I (HDR2BLD="M") D
"RTN","HLCS",133,0)
 .;Use MSH as header
"RTN","HLCS",134,0)
 .D MRGINT^HLTF1(HLMTIEN,HLMSGPTR,"HLHDR")
"RTN","HLCS",135,0)
 I (HDR2BLD'="M") D
"RTN","HLCS",136,0)
 .;Use BHS or FHS as header
"RTN","HLCS",137,0)
 .D MRGINT^HLTF1(HLMTIEN,HLMSGPTR,"BHSHDR")
"RTN","HLCS",138,0)
 ;Set status of outgoing message to AWAITING ACKNOWLEDGEMENT
"RTN","HLCS",139,0)
 D STATUS^HLTF0(HLMTIENS,$S($P(^HL(772,HLMTIEN,0),U,7):3,1:2))
"RTN","HLCS",140,0)
 ;Set status of 'incoming' message to AWAITING PROCESSING
"RTN","HLCS",141,0)
 D STATUS^HLTF0(HLMSGPTR,9)
"RTN","HLCS",142,0)
 Q
"RTN","HLCS",143,0)
SENDACK(HLMTIENA,HLEID,HLEIDS,HLRESULT) ;Send an HL7 acknowledgement/response
"RTN","HLCS",144,0)
 ;HLMTIENA=The IEN of the parent acknowledgment/response message in
"RTN","HLCS",145,0)
 ;         file # 772
"RTN","HLCS",146,0)
 ;HLEIDS=The IEN of the Subscribing protocol in file # 101
"RTN","HLCS",147,0)
 ;HLEID=The IEN of the Event Driver protocol in file #101
"RTN","HLCS",148,0)
 ;HLRESULT=Variable for any error text (pass by reference)
"RTN","HLCS",149,0)
 ;
"RTN","HLCS",150,0)
 N HLERROR,HLOGLINK,HLCLIENT,HLMTIENS,HLMSGPTR,HLCLNODE
"RTN","HLCS",151,0)
 I $G(HLMTIENA)=""!($G(HLEID)="")!($G(HLEIDS)="") S HLERROR="0^7^"_$G(^HL(771.7,7,0))_"at SENDACK^HLCS entry point" G EXIT2
"RTN","HLCS",152,0)
 S HLCLNODE=$G(^ORD(101,HLEID,770))
"RTN","HLCS",153,0)
 ;Get pointers to Logical Link & receiving application
"RTN","HLCS",154,0)
 S HLOGLINK=$P($G(^ORD(101,HLEIDS,770)),U,7)
"RTN","HLCS",155,0)
 ;Application needed to dynamically address the ACK (tcp/ip)
"RTN","HLCS",156,0)
 ;(set HLL("LINKS") array before calling GENACK)
"RTN","HLCS",157,0)
 I $D(HLL("LINKS")) D  Q:'HLOGLINK
"RTN","HLCS",158,0)
 .S HLOGLINK=$P(HLL("LINKS",1),"^",2) Q:HLOGLINK=""
"RTN","HLCS",159,0)
 .K HLL("LINKS")
"RTN","HLCS",160,0)
 .I +HLOGLINK'=HLOGLINK S HLOGLINK=$O(^HLCS(870,"B",HLOGLINK,0))
"RTN","HLCS",161,0)
 S HLCLIENT=$P(HLCLNODE,U,1)
"RTN","HLCS",162,0)
 Q:('HLCLIENT)
"RTN","HLCS",163,0)
 ;Determine if receiving application is internal or external
"RTN","HLCS",164,0)
 ;  Logical link has a value for external applications
"RTN","HLCS",165,0)
 ;  Logical link is NULL for internal applications
"RTN","HLCS",166,0)
 I (HLOGLINK) D COTSACK Q
"RTN","HLCS",167,0)
 ;Create 'incoming' message based on 'outgoing' message (internal)
"RTN","HLCS",168,0)
 D DHCP(HLMTIENA,HLEID,HLCLIENT)
"RTN","HLCS",169,0)
 ;Process the 'incoming' message
"RTN","HLCS",170,0)
 I (HLMSGPTR) D
"RTN","HLCS",171,0)
 .S HLERROR=""
"RTN","HLCS",172,0)
 .D PROCESS^HLTP0(HLMSGPTR,"DHCP","",.HLERROR)
"RTN","HLCS",173,0)
 ;Update Status of 'incoming' message to SUCCESSFULLY COMPLETED
"RTN","HLCS",174,0)
 ; or ERROR DURING TRANSMISSION
"RTN","HLCS",175,0)
 D STATUS^HLTF0(HLMSGPTR,$S(HLERROR:4,1:3),$S(HLERROR:+HLERROR,1:""),$S(HLERROR:$P(HLERROR,"^",2),1:""))
"RTN","HLCS",176,0)
EXIT2 ;
"RTN","HLCS",177,0)
 S HLRESULT=$G(HLERROR)
"RTN","HLCS",178,0)
 Q
"RTN","HLCS",179,0)
COTSACK ;Internal to external communication of acknowledgements/responses
"RTN","HLCS",180,0)
 ;Create child entry in Message Text file
"RTN","HLCS",181,0)
 D SEND^HLMA2(HLEID,HLMTIENA,HLCLIENT,"D",.HLMTIENS,HLOGLINK)
"RTN","HLCS",182,0)
 ;'Pass' message to background filer by setting status of child
"RTN","HLCS",183,0)
 ;  to PENDING TRANSMISSION
"RTN","HLCS",184,0)
 D STATUS^HLTF0(HLMTIENS,1)
"RTN","HLCS",185,0)
 Q
"RTN","HLCS2")
0^48^B38051566
"RTN","HLCS2",1,0)
HLCS2 ;SF/JC - More Communication Server utilities ; 12/31/2003  17:50
"RTN","HLCS2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**14,40,43,49,57,58,82,84,109**;Oct 13, 1995
"RTN","HLCS2",3,0)
FWD ; Add supplemental clients from HLL("LINKS") to HLSUP array
"RTN","HLCS2",4,0)
 ;This enhancement also supports distribution of a message to
"RTN","HLCS2",5,0)
 ;the same client over multiple logical links.
"RTN","HLCS2",6,0)
 Q:'$D(HLL("LINKS"))
"RTN","HLCS2",7,0)
 N CNT,LNK,CLIAP
"RTN","HLCS2",8,0)
 S CNT=0,ROUTINE=1 F  S CNT=$O(HLL("LINKS",CNT)) Q:CNT<1  D
"RTN","HLCS2",9,0)
 . S PTR=$P(HLL("LINKS",CNT),"^"),LNK=$P(HLL("LINKS",CNT),"^",2)
"RTN","HLCS2",10,0)
 . Q:PTR=""  I +PTR<1 S PTR=$O(^ORD(101,"B",PTR,0)) Q:PTR<1
"RTN","HLCS2",11,0)
 . Q:LNK=""  I +LNK<1 S LNK=$O(^HLCS(870,"B",LNK,0)) Q:LNK<1
"RTN","HLCS2",12,0)
 . Q:'$D(^HLCS(870,LNK))
"RTN","HLCS2",13,0)
 . S CLIAP=$$PTR^HLUTIL2(PTR)
"RTN","HLCS2",14,0)
 . S HLSUP("S",PTR,+LNK)=CLIAP_$S(CLIAP<1:U_HLL("LINKS",CNT),1:"")
"RTN","HLCS2",15,0)
 Q
"RTN","HLCS2",16,0)
ADD ;Deliver message to supplemental client list.
"RTN","HLCS2",17,0)
 ;Invoked by HLTP before and after processing normal clients
"RTN","HLCS2",18,0)
 ;Only processes remote links. Local clients must be subscribing
"RTN","HLCS2",19,0)
 ;protocols.
"RTN","HLCS2",20,0)
 Q:'$D(HLSUP("S"))
"RTN","HLCS2",21,0)
 N HLTCP,HLTCPI,HLTCPO,ZHLEIDS,ZLCLIENT,ZLOGLINK,ZMTIENS
"RTN","HLCS2",22,0)
 S ZHLEIDS=0 F  S ZHLEIDS=$O(HLSUP("S",ZHLEIDS)) Q:ZHLEIDS<1  D
"RTN","HLCS2",23,0)
 .S ZLOGLINK=0 F  S ZLOGLINK=$O(HLSUP("S",ZHLEIDS,ZLOGLINK)) Q:ZLOGLINK<1  D
"RTN","HLCS2",24,0)
 ..S ZLCLIENT=+HLSUP("S",ZHLEIDS,ZLOGLINK)
"RTN","HLCS2",25,0)
 ..I ZLCLIENT<1 S:$G(HLERROR)="" HLERROR="15^Invalid Subscriber Protocol in HLL('LINKS'): "_$P(HLSUP("S",ZHLEIDS,ZLOGLINK),U,2,9) Q
"RTN","HLCS2",26,0)
 ..S HLOGLINK=ZLOGLINK D SEND^HLMA2(ZHLEIDS,HLMTIEN,ZLCLIENT,"D",.ZMTIENS,ZLOGLINK),STATUS^HLTF0(+ZMTIENS,1)
"RTN","HLCS2",27,0)
 K HLL("LINKS"),HLSUP
"RTN","HLCS2",28,0)
 Q
"RTN","HLCS2",29,0)
STALL ;STOP ALL LINKS AND FILERS
"RTN","HLCS2",30,0)
 N DIR,Y
"RTN","HLCS2",31,0)
 W ! S DIR(0)="Y",DIR("A")="Okay to shut down all Links and Filers"
"RTN","HLCS2",32,0)
 D ^DIR
"RTN","HLCS2",33,0)
 I 'Y!($D(DIRUT))!($D(DUOUT)) W !!,"Shutdown Aborted!" Q
"RTN","HLCS2",34,0)
 W !,"Shutting down all Links and Filers..."
"RTN","HLCS2",35,0)
 D CLEAR
"RTN","HLCS2",36,0)
 D LLP(1)
"RTN","HLCS2",37,0)
 Q
"RTN","HLCS2",38,0)
QUE ;Restart Filers and AUTOSTART Logical Links after system re-boot
"RTN","HLCS2",39,0)
 N DIR,Y
"RTN","HLCS2",40,0)
 I '$D(ZTQUEUED) D  Q:'Y!($D(DIRUT))!($D(DUOUT))
"RTN","HLCS2",41,0)
 .W ! S DIR(0)="Y",DIR("A")="Shutdown and restart ALL AUTOSTART links and filers. Okay"
"RTN","HLCS2",42,0)
 .D ^DIR
"RTN","HLCS2",43,0)
 .I 'Y!($D(DIRUT))!($D(DUOUT)) W !!,"RESTART Aborted!" Q
"RTN","HLCS2",44,0)
 .W !,"Restarting all Autostart-Enabled Links and Filers..."
"RTN","HLCS2",45,0)
 D CLEAR
"RTN","HLCS2",46,0)
 D STARTF
"RTN","HLCS2",47,0)
 D LLP(0)
"RTN","HLCS2",48,0)
 D STRT
"RTN","HLCS2",49,0)
 Q
"RTN","HLCS2",50,0)
CLEAR ;Reset state of 869.3
"RTN","HLCS2",51,0)
 S DA(1)=1,DA=0,DIK="^HLCS(869.3,1,2,"
"RTN","HLCS2",52,0)
 F  S DA=$O(^HLCS(869.3,DA(1),2,DA)) Q:DA<1  D ^DIK
"RTN","HLCS2",53,0)
 S DA=0,DIK="^HLCS(869.3,1,3,"
"RTN","HLCS2",54,0)
 F  S DA=$O(^HLCS(869.3,DA(1),3,DA)) Q:DA<1  D ^DIK
"RTN","HLCS2",55,0)
 Q
"RTN","HLCS2",56,0)
STARTF ;Start filers
"RTN","HLCS2",57,0)
 ;Get Defaults
"RTN","HLCS2",58,0)
 N TMP,PTR,DEFCNT,DA,HLCNT,HLNODE1
"RTN","HLCS2",59,0)
 S PTR=+$O(^HLCS(869.3,0)) Q:'PTR
"RTN","HLCS2",60,0)
 ;default # of incoming filers
"RTN","HLCS2",61,0)
 S HLNODE1=$G(^HLCS(869.3,PTR,1)),DEFCNT=+$P(HLNODE1,U) S:'DEFCNT DEFCNT=1
"RTN","HLCS2",62,0)
 F HLCNT=1:1:DEFCNT S TMP=$$TASKFLR^HLCS1("IN")
"RTN","HLCS2",63,0)
 ;default # of outgoing filers
"RTN","HLCS2",64,0)
 S DEFCNT=+$P(HLNODE1,U,2) S:'DEFCNT DEFCNT=1
"RTN","HLCS2",65,0)
 F HLCNT=1:1:DEFCNT S TMP=$$TASKFLR^HLCS1("OUT")
"RTN","HLCS2",66,0)
 Q
"RTN","HLCS2",67,0)
LLP(ALL) ;Stop Logical Links
"RTN","HLCS2",68,0)
 ;ALL=1 OR 0 IF zero, only AUTOSTART LINKS get stopped
"RTN","HLCS2",69,0)
 N HLDP,HLDP0,HLPARM0,HLPARM4,HLJ,X,Y S HLDP=0
"RTN","HLCS2",70,0)
 F  S HLDP=$O(^HLCS(870,HLDP)) Q:'HLDP  S HLDP0=$G(^(HLDP,0)),X=+$P(HLDP0,U,3) D:X
"RTN","HLCS2",71,0)
 .;skip this link if not stopping all and Autostart not enabled
"RTN","HLCS2",72,0)
 . I 'ALL&('$P(HLDP0,U,6)) Q
"RTN","HLCS2",73,0)
 . S HLPARM4=$G(^HLCS(870,HLDP,400))
"RTN","HLCS2",74,0)
 . ;TCP Multi listener for non-Cache uses UCX
"RTN","HLCS2",75,0)
 . I $P(HLPARM4,U,3)="M" Q:^%ZOSF("OS")'["OpenM"  Q:$$OS^%ZOSV["VMS"
"RTN","HLCS2",76,0)
 . ;4=status,10=Time Stopped,9=Time Started,11=Task Number,3=Device Type,14=shutdown?
"RTN","HLCS2",77,0)
 . S X="HLJ(870,"""_HLDP_","")",@X@(4)="Halting",@X@(10)=$$NOW^XLFDT,(@X@(11),@X@(9))="@",@X@(14)=1
"RTN","HLCS2",78,0)
 . I $P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4)),'$P(HLDP0,U,12) S @X@(4)="Shutdown"
"RTN","HLCS2",79,0)
 . D FILE^HLDIE("","HLJ","","LLP","HLCS2") ;HL*1.6*109
"RTN","HLCS2",80,0)
 . ;Cache system, need to open TCP port to release job
"RTN","HLCS2",81,0)
 . I ^%ZOSF("OS")["OpenM",($P(HLPARM4,U,3)="M"!($P(HLPARM4,U,3)="S")) D
"RTN","HLCS2",82,0)
 .. ;pass task number to stop listener
"RTN","HLCS2",83,0)
 .. S:$P(HLDP0,U,12) X=$$ASKSTOP^%ZTLOAD(+$P(HLDP0,U,12))
"RTN","HLCS2",84,0)
 .. D CALL^%ZISTCP($P(HLPARM4,U),$P(HLPARM4,U,2),10)
"RTN","HLCS2",85,0)
 .. I POP D HOME^%ZIS Q
"RTN","HLCS2",86,0)
 .. D CLOSE^%ZISTCP
"RTN","HLCS2",87,0)
 Q
"RTN","HLCS2",88,0)
STRT ;Start Links
"RTN","HLCS2",89,0)
 N HLDP,HLDP0,HLDAPP,HLTYPTR,HLBGR,HLENV,HLPARAM0,HLPARM4,HLQUIT,ZTRTN,ZTDESC,ZTSK,ZTCPU
"RTN","HLCS2",90,0)
 S HLDP=0
"RTN","HLCS2",91,0)
 F  S HLDP=$O(^HLCS(870,HLDP)) Q:HLDP<1  S HLDP0=$G(^(HLDP,0)) D
"RTN","HLCS2",92,0)
 . S HLPARM4=$G(^HLCS(870,HLDP,400))
"RTN","HLCS2",93,0)
 . ;quit if no parameters or AUTOSTART is disabled
"RTN","HLCS2",94,0)
 . Q:'$P(HLDP0,U,6)
"RTN","HLCS2",95,0)
 . ;HLDAPP=LL name, HLTYPTR=LL type, HLBGR=routine, HLENV=environment check
"RTN","HLCS2",96,0)
 . S HLDAPP=$P(HLDP0,U),HLTYPTR=+$P(HLDP0,U,3),HLBGR=$G(^HLCS(869.1,HLTYPTR,100)),HLENV=$G(^(200))
"RTN","HLCS2",97,0)
 . ;quit if no LL type or no routine
"RTN","HLCS2",98,0)
 . Q:'HLTYPTR!(HLBGR="")
"RTN","HLCS2",99,0)
 . I HLENV'="" K HLQUIT X HLENV Q:$D(HLQUIT)
"RTN","HLCS2",100,0)
 . ;TCP Multi listener for non-Cache uses UCX
"RTN","HLCS2",101,0)
 . I $P(HLPARM4,U,3)="M" Q:^%ZOSF("OS")'["OpenM"  Q:$$OS^%ZOSV["VMS"
"RTN","HLCS2",102,0)
 . I $P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4)) D  Q
"RTN","HLCS2",103,0)
 .. ;4=status 9=Time Started, 10=Time Stopped, 11=Task Number 
"RTN","HLCS2",104,0)
 .. ;14=Shutdown LLP, 3=Device Type, 18=Gross Errors
"RTN","HLCS2",105,0)
 .. N HLJ,X
"RTN","HLCS2",106,0)
 .. I $P(HLDP0,U,15)=0 Q
"RTN","HLCS2",107,0)
 .. L +^HLCS(870,HLDP,0):2
"RTN","HLCS2",108,0)
 .. E  Q
"RTN","HLCS2",109,0)
 .. S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCS2",110,0)
 .. S @X@(4)="Enabled",@X@(9)=$$NOW^XLFDT,@X@(14)=0
"RTN","HLCS2",111,0)
 .. D FILE^HLDIE("","HLJ","","STRT","HLCS2") ; HL*1.6*109
"RTN","HLCS2",112,0)
 .. L -^HLCS(870,HLDP,0)
"RTN","HLCS2",113,0)
 .. Q
"RTN","HLCS2",114,0)
 . S ZTRTN=$P(HLBGR," ",2),ZTIO="",ZTDTH=$H,HLTRACE=""
"RTN","HLCS2",115,0)
 . S ZTDESC=HLDAPP_" Low Level Protocol",ZTSAVE("HLDP")=""
"RTN","HLCS2",116,0)
 . ;get startup node
"RTN","HLCS2",117,0)
 . I $P(HLPARM4,U,6),$D(^%ZIS(14.7,+$P(HLPARM4,U,6),0)) S ZTCPU=$P(^(0),U)
"RTN","HLCS2",118,0)
 . D ^%ZTLOAD
"RTN","HLCS2",119,0)
 Q
"RTN","HLCS2",120,0)
SITEP ;Edit Site Parameters
"RTN","HLCS2",121,0)
 S DDSFILE=869.3,DA=1,DR="[HL SITE PARAMETERS]" D ^DDS
"RTN","HLCS2",122,0)
 Q
"RTN","HLCS2",123,0)
PARAM() ;Return HL7 site parameters
"RTN","HLCS2",124,0)
 ;HLPARAM=domain ien^domain name^production or test^institution ien^
"RTN","HLCS2",125,0)
 ;institution name^institution number^mail group ien^mail group name^
"RTN","HLCS2",126,0)
 ;purge completed messages^purge awaiting ack messages^purge all msgs^
"RTN","HLCS2",127,0)
 ;default retention
"RTN","HLCS2",128,0)
 N HLX,HLX4,HLX5,HLDOMP,HLDOMN,HLPROD,HLINSP,HLINSN,HLINSNM,HLMAILP,HLMAILN,HLPARAM,HLPRGAA,HLPRGALL,HLPRGCMP,HLDEFRET
"RTN","HLCS2",129,0)
 S HLX=$G(^HLCS(869.3,1,0))
"RTN","HLCS2",130,0)
 S HLX4=$G(^HLCS(869.3,1,4))
"RTN","HLCS2",131,0)
 S HLX5=$G(^HLCS(869.3,1,5))
"RTN","HLCS2",132,0)
 S HLDOMP=$P(HLX,U,2) I HLDOMP S HLDOMN=$P(^DIC(4.2,HLDOMP,0),U)
"RTN","HLCS2",133,0)
 S HLPROD=$P(HLX,U,3)
"RTN","HLCS2",134,0)
 S HLINSP=$P(HLX,U,4) I HLINSP S HLINSN=$P(^DIC(4,HLINSP,0),U),HLINSNM=$P($G(^DIC(4,HLINSP,99)),U)
"RTN","HLCS2",135,0)
 S HLMAILP=$P(HLX,U,5) I HLMAILP S HLMAILN=$P(^XMB(3.8,HLMAILP,0),U)
"RTN","HLCS2",136,0)
 S HLPRGCMP=$P(HLX4,U),HLPRGAA=$P(HLX4,U,2),HLPRGALL=$P(HLX4,U,3)
"RTN","HLCS2",137,0)
 S HLDEFRET=$P(HLX5,U)
"RTN","HLCS2",138,0)
 S HLPARAM=HLDOMP_U_$G(HLDOMN)_U_$G(HLPROD)_U_HLINSP_U_$G(HLINSN)_U_$G(HLINSNM)_U_HLMAILP_U_$G(HLMAILN)_U_HLPRGCMP_U_HLPRGAA_U_HLPRGALL_U_HLDEFRET
"RTN","HLCS2",139,0)
 Q HLPARAM
"RTN","HLCS2",140,0)
 ;
"RTN","HLCS2",141,0)
GETAPP(HLAPP) ;Function to Retrieve parameters pertaining to a specific sending or receiving application
"RTN","HLCS2",142,0)
 ;HLAPP=APPLICATION NAME OR IEN OF FILE 771
"RTN","HLCS2",143,0)
 ;Returns MAIL GROUP NAME^'a' or 'i' (active or inactive) 
"RTN","HLCS2",144,0)
 S HLAPP=$G(HLAPP)
"RTN","HLCS2",145,0)
 I HLAPP]"",'HLAPP S HLAPP=$O(^HL(771,"B",$E(HLAPP,1,30),0))
"RTN","HLCS2",146,0)
 I 'HLAPP Q ""
"RTN","HLCS2",147,0)
 I HLAPP S HLM=$P(^HL(771,HLAPP,0),U,4)
"RTN","HLCS2",148,0)
 I HLM S HLM=$P($G(^XMB(3.8,HLM,0)),U)
"RTN","HLCS2",149,0)
 Q $G(HLM)_U_$P(^HL(771,HLAPP,0),U,2)
"RTN","HLCSAS1")
0^51^B5752372
"RTN","HLCSAS1",1,0)
HLCSAS1 ;ISCSF/RWF - Read data ;02/05/2004  08:06
"RTN","HLCSAS1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**43,57,91,109**;Oct 13, 1995
"RTN","HLCSAS1",3,0)
 Q
"RTN","HLCSAS1",4,0)
DATA(ROOT,STAT) ;get Data
"RTN","HLCSAS1",5,0)
 N I,M,HLROOT
"RTN","HLCSAS1",6,0)
 D DCODE(HCSDAT),TRACE^HLCSAS("DECODE "_HCSDAT)
"RTN","HLCSAS1",7,0)
 ;Check if data type is OK
"RTN","HLCSAS1",8,0)
 ;I ...
"RTN","HLCSAS1",9,0)
 S HLROOT=$$SAVE("I")
"RTN","HLCSAS1",10,0)
 F I=1:1 S M=$$DREAD() Q:HCSER!M  S (@ROOT@(I),@HLROOT@(I,0))=HCSDAT
"RTN","HLCSAS1",11,0)
 S @HLROOT@(0)="^^"_(I-1)_"^"_(I-1)_"^"_$$DT^XLFDT
"RTN","HLCSAS1",12,0)
 ;If we got it all
"RTN","HLCSAS1",13,0)
 D SEND^HLCSAS($S(HCSER:"500 Data error",1:"220 OK"))
"RTN","HLCSAS1",14,0)
 D LLCNT^HLCSTCP(HLDP,1)
"RTN","HLCSAS1",15,0)
 Q
"RTN","HLCSAS1",16,0)
 ;
"RTN","HLCSAS1",17,0)
SAVE(HLTP) ;save to file 772, HLTP: I=input, O=output
"RTN","HLCSAS1",18,0)
 N HLJ,HLMID,HLTIEN,HLDT,HLX,HLY,X,Y ;HL*1.6*91
"RTN","HLCSAS1",19,0)
 D TCP^HLTF(.HLMID,.HLTIEN,.HLDT) Q:'HLTIEN ""
"RTN","HLCSAS1",20,0)
 S X="HLJ(773,"""_HLTIEN_","")"
"RTN","HLCSAS1",21,0)
 ;3=transmission type, 4=priority, 7=Logical Link, 20=status, 100=processed
"RTN","HLCSAS1",22,0)
 S @X@(3)=HLTP,@X@(4)="I",@X@(7)=HLDP,@X@(20)=3,@X@(100)=$$NOW^XLFDT
"RTN","HLCSAS1",23,0)
 D FILE^HLDIE("K","HLJ","","SAVE","HLCSAS1") ;HL*1.6*109
"RTN","HLCSAS1",24,0)
 S (HLX,X)=+^HLMA(HLTIEN,0),(HLY,Y)=$NA(^HL(772,X,"IN")) ;HL*1.6*91
"RTN","HLCSAS1",25,0)
 D SNMSP(+HLX,$S($G(HLP("NAMESPACE"))]"":HLP("NAMESPACE"),1:"MPI")) ;HL*1.6*91
"RTN","HLCSAS1",26,0)
 Q HLY ;HL*1.6*91
"RTN","HLCSAS1",27,0)
 ;
"RTN","HLCSAS1",28,0)
SNMSP(IEN772,NMSP) ; Store NMSP in IEN772 (Created by HL*1.6*91)
"RTN","HLCSAS1",29,0)
 N HLJ,X,Y
"RTN","HLCSAS1",30,0)
 QUIT:'$D(^HL(772,+$G(IEN772),0))!($G(NMSP)']"")  ;->
"RTN","HLCSAS1",31,0)
 S X="HLJ(772,"""_+IEN772_","")"
"RTN","HLCSAS1",32,0)
 S @X@(16)=NMSP
"RTN","HLCSAS1",33,0)
 D FILE^HLDIE("","HLJ","","SNMSP","HLCSAS1") ; HL*1.6*109
"RTN","HLCSAS1",34,0)
 QUIT
"RTN","HLCSAS1",35,0)
 ;
"RTN","HLCSAS1",36,0)
SDATA(ROOT,TYPE) ;Send data from a source
"RTN","HLCSAS1",37,0)
 N I,X,Y,Z,L,D,HLROOT
"RTN","HLCSAS1",38,0)
 S ROOT=$NA(@ROOT),X=ROOT,Y=$E(ROOT,1,$L(ROOT)-1),HCSER=0
"RTN","HLCSAS1",39,0)
 D SEND^HLCSAS("DATA PARAM="_TYPE)
"RTN","HLCSAS1",40,0)
 S X=ROOT,HLROOT=$$SAVE("O")
"RTN","HLCSAS1",41,0)
 F I=1:1 S X=$Q(@X) Q:$E(X,1,$L(Y))'=Y  S Z=@X,@HLROOT@(I,0)=Z D DSEND(Z)
"RTN","HLCSAS1",42,0)
 S @HLROOT@(0)="^^"_(I-1)_"^"_(I-1)_"^"_$$DT^XLFDT
"RTN","HLCSAS1",43,0)
 D DSEND($C(27,27,27)) ;Tell other end we'r done
"RTN","HLCSAS1",44,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSAS1",45,0)
 Q
"RTN","HLCSAS1",46,0)
DCODE(D) ;Decode a DATA string
"RTN","HLCSAS1",47,0)
 S D=$$UP^XLFSTR(D),D=$P(D,"PARAM=",2,99)
"RTN","HLCSAS1",48,0)
 F I=1:1 S STAT("P"_I)=$P(D,",",I) Q:$P(D,",",I+1)=""
"RTN","HLCSAS1",49,0)
 Q
"RTN","HLCSAS1",50,0)
DREAD() ;Data read
"RTN","HLCSAS1",51,0)
 N L,D,R S (D,HCSDAT)="",HCSER=0
"RTN","HLCSAS1",52,0)
 S L=$$LREAD(3) Q:HCSER 1
"RTN","HLCSAS1",53,0)
 I L'?3N S HCSER="1 Out of sync: "_L Q 1
"RTN","HLCSAS1",54,0)
 I L>0 S HCSDAT=$$LREAD(L)
"RTN","HLCSAS1",55,0)
 Q HCSDAT=$C(27,27,27)
"RTN","HLCSAS1",56,0)
DSEND(D) ;Data send
"RTN","HLCSAS1",57,0)
 N L
"RTN","HLCSAS1",58,0)
 S L=$L(D),L=$E(1000+L,2,4)
"RTN","HLCSAS1",59,0)
 W L,D,! ;Flush buffer
"RTN","HLCSAS1",60,0)
 Q
"RTN","HLCSAS1",61,0)
LREAD(N) ;Read N char
"RTN","HLCSAS1",62,0)
 N D,C,P S D="",C=N,HCSER=0
"RTN","HLCSAS1",63,0)
 F  D  Q:'C!HCSER
"RTN","HLCSAS1",64,0)
 . R P#C:HLDREAD E  S HCSER=1 Q
"RTN","HLCSAS1",65,0)
 . S D=D_P,C=N-$L(D)
"RTN","HLCSAS1",66,0)
 . Q
"RTN","HLCSAS1",67,0)
 Q D
"RTN","HLCSDR2")
0^52^B18988323
"RTN","HLCSDR2",1,0)
HLCSDR2 ;ALB/RJS - HYBRID LOWER LAYER PROTOCOL UTILITIES 2.2 - ;08/22/2001  11:23
"RTN","HLCSDR2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**2,9,62,109**;Oct 13, 1995
"RTN","HLCSDR2",3,0)
 Q
"RTN","HLCSDR2",4,0)
WRITE(HLDOUT0,HLDOUT1) ; This function writes a message from the Logical
"RTN","HLCSDR2",5,0)
 ; Link file (#870) to the specified device in the following format:
"RTN","HLCSDR2",6,0)
 ; <Start Block><Data Block><End Block>
"RTN","HLCSDR2",7,0)
 ; The data block is the complete HL7 message terminated by a <CR>.
"RTN","HLCSDR2",8,0)
 ; INPUT : HLDOUT0 - IFN of file 870
"RTN","HLCSDR2",9,0)
 ;         HLDOUT1 - IFN of Out Queue Multiple
"RTN","HLCSDR2",10,0)
 ; OUTPUT: None
"RTN","HLCSDR2",11,0)
 I HLDOUT0']""!(HLDOUT1']"") Q
"RTN","HLCSDR2",12,0)
 ;-- HLLINE,HLC1,HLC2 are initialized in INITIZE
"RTN","HLCSDR2",13,0)
 N HLCLN,HLCHK,I,X
"RTN","HLCSDR2",14,0)
 D INITIZE
"RTN","HLCSDR2",15,0)
 ;
"RTN","HLCSDR2",16,0)
 ;-- write start block
"RTN","HLCSDR2",17,0)
 S X=$C(HLDSTRT)_"D"_HLDVER_$C(13) D CHKSUM
"RTN","HLCSDR2",18,0)
 U IO W X
"RTN","HLCSDR2",19,0)
 ;
"RTN","HLCSDR2",20,0)
 S HLWFLG=0
"RTN","HLCSDR2",21,0)
 ;-- process and write data block
"RTN","HLCSDR2",22,0)
 F  S HLLINE=$$NEXTLINE^HLCSUTL(HLDOUT0,HLDOUT1,HLLINE,"HLCLN","OUT") Q:'HLLINE  D
"RTN","HLCSDR2",23,0)
 . S HLCHK=$$CHKSUM^HLCSUTL("HLCLN")
"RTN","HLCSDR2",24,0)
 . S HLC2=HLC2_$C($P(HLCHK,U)),HLC1=HLC1+$P(HLCHK,U,2)
"RTN","HLCSDR2",25,0)
 . I $E(HLCLN(1),1,3)="MSA" S HLWFLG=1
"RTN","HLCSDR2",26,0)
 . ;U IO
"RTN","HLCSDR2",27,0)
 . S I=0 F  S I=$O(HLCLN(I)) Q:'I  W $G(HLCLN(I))
"RTN","HLCSDR2",28,0)
 . K HLCLN,HLCHK
"RTN","HLCSDR2",29,0)
 ;
"RTN","HLCSDR2",30,0)
 D CHKSUM1
"RTN","HLCSDR2",31,0)
 ;-- store checksum values
"RTN","HLCSDR2",32,0)
 D MONITOR(HLC1,4,HLDP,HLDOUT1,"OUT"),MONITOR(HLC2,5,HLDP,HLDOUT1,"OUT")
"RTN","HLCSDR2",33,0)
 ;
"RTN","HLCSDR2",34,0)
 S HLC1=$$RJ(HLC1,5)
"RTN","HLCSDR2",35,0)
 S HLC2=$$RJ(HLC2,3)
"RTN","HLCSDR2",36,0)
 ;
"RTN","HLCSDR2",37,0)
 ;-- write end block
"RTN","HLCSDR2",38,0)
 S X=HLC1_HLC2_$C(HLDEND)_$C(13)
"RTN","HLCSDR2",39,0)
 U IO W X
"RTN","HLCSDR2",40,0)
 Q
"RTN","HLCSDR2",41,0)
SETNODE(HLD0,HLD1,CR) ;
"RTN","HLCSDR2",42,0)
 S HLLINE=HLLINE+1,^HLCS(870,HLD0,1,HLD1,1,HLLINE,0)=$G(X)
"RTN","HLCSDR2",43,0)
 I CR="CR" S HLLINE=HLLINE+1,^HLCS(870,HLD0,1,HLD1,1,HLLINE,0)=""
"RTN","HLCSDR2",44,0)
 Q
"RTN","HLCSDR2",45,0)
SETNODE2 ;
"RTN","HLCSDR2",46,0)
 S HLLINE=HLLINE+1,^TMP("HLCSDR1",$J,HLDP,HLLINE)=$G(X)
"RTN","HLCSDR2",47,0)
 Q
"RTN","HLCSDR2",48,0)
TRANS(HLTOUT,HLTRANS) ; This function returns the state of the read operation.
"RTN","HLCSDR2",49,0)
 ;   INPUT : HLTOUT - Data returned from read (Will contain TIMEOUT)
"RTN","HLCSDR2",50,0)
 ;           HLTRANS - Variable passed by reference containing how
"RTN","HLCSDR2",51,0)
 ;                     the read was terminated.
"RTN","HLCSDR2",52,0)
 ;   OUTPUT: HLTRANS - Translation of read termination.
"RTN","HLCSDR2",53,0)
 S HLTRANS=$S($G(HLTOUT)["TIMEOUT":"TIMEOUT",HLTRANS=0:"LONGLINE",HLTRANS=1:"SOH",HLTRANS=4:"EOT",HLTRANS=HLDSTRT:"VT",HLTRANS=13:"CR",HLTRANS=HLDEND:"FS",1:"OTHER")
"RTN","HLCSDR2",54,0)
 I $D(HLTRACE) U IO(0) W !,"HLTRANS=",HLTRANS
"RTN","HLCSDR2",55,0)
 Q
"RTN","HLCSDR2",56,0)
INITIZE ;Initialize Line counter and Checksum variables
"RTN","HLCSDR2",57,0)
 S (HLLINE,HLC1)=0,HLC2=""
"RTN","HLCSDR2",58,0)
 Q
"RTN","HLCSDR2",59,0)
NAK(HLTRANS) ; Send NAK
"RTN","HLCSDR2",60,0)
 N HLDATA
"RTN","HLCSDR2",61,0)
 D INITIZE
"RTN","HLCSDR2",62,0)
 ;-- start block and data
"RTN","HLCSDR2",63,0)
 S (X,HLDATA)=$C(HLDSTRT)_"N"_HLDVER_$C(13)_HLTRANS
"RTN","HLCSDR2",64,0)
 D CHKSUM,CHKSUM1
"RTN","HLCSDR2",65,0)
 S HLC1=$$RJ(HLC1,5)
"RTN","HLCSDR2",66,0)
 S HLC2=$$RJ(HLC2,3)
"RTN","HLCSDR2",67,0)
 ;-- end block
"RTN","HLCSDR2",68,0)
 S X=HLDATA_HLC1_HLC2_$C(HLDEND)_$C(13)
"RTN","HLCSDR2",69,0)
 U IO W X
"RTN","HLCSDR2",70,0)
 Q
"RTN","HLCSDR2",71,0)
ACK ; Send ACK
"RTN","HLCSDR2",72,0)
 N HLDATA
"RTN","HLCSDR2",73,0)
 D INITIZE
"RTN","HLCSDR2",74,0)
 ;-- start block and data
"RTN","HLCSDR2",75,0)
 S (X,HLDATA)=$C(HLDSTRT)_"D"_HLDVER_$C(13)
"RTN","HLCSDR2",76,0)
 D CHKSUM,CHKSUM1
"RTN","HLCSDR2",77,0)
 S HLC1=$$RJ(HLC1,5)
"RTN","HLCSDR2",78,0)
 S HLC2=$$RJ(HLC2,3)
"RTN","HLCSDR2",79,0)
 ;-- end block
"RTN","HLCSDR2",80,0)
 S X=HLDATA_HLC1_HLC2_$C(HLDEND)_$C(13)
"RTN","HLCSDR2",81,0)
 U IO W X
"RTN","HLCSDR2",82,0)
 Q
"RTN","HLCSDR2",83,0)
DUMP ;
"RTN","HLCSDR2",84,0)
 Q:'$D(HLTRACE)
"RTN","HLCSDR2",85,0)
 U IO(0)
"RTN","HLCSDR2",86,0)
 W !,"DUMP"
"RTN","HLCSDR2",87,0)
 I '$D(HLC1) S HLC1=-1
"RTN","HLCSDR2",88,0)
 I '$D(HLC2) S HLC2=-1
"RTN","HLCSDR2",89,0)
 I '$D(HLBLOCK) S HLBLOCK=-1
"RTN","HLCSDR2",90,0)
 I '$D(HLXOR) S HLXOR=-1
"RTN","HLCSDR2",91,0)
 W !,"HLC1=",HLC1," ","HLBLOCK=",HLBLOCK
"RTN","HLCSDR2",92,0)
 W !,"HLC2=",HLC2," ","HLXOR=",HLXOR
"RTN","HLCSDR2",93,0)
 Q
"RTN","HLCSDR2",94,0)
CHKSUM ;
"RTN","HLCSDR2",95,0)
 X ^%ZOSF("LPC") S HLC1=HLC1+$L(X),HLC2=HLC2_$C(Y)
"RTN","HLCSDR2",96,0)
 I $L(HLC2)>240 D CHKSUM1
"RTN","HLCSDR2",97,0)
 Q
"RTN","HLCSDR2",98,0)
CHKSUM1 ;
"RTN","HLCSDR2",99,0)
 S X=HLC2 X ^%ZOSF("LPC") S HLC2=Y
"RTN","HLCSDR2",100,0)
 Q
"RTN","HLCSDR2",101,0)
VALID1(FLAG,CHK,HLIND0,HLIND1) ;
"RTN","HLCSDR2",102,0)
 ;This function extracts the checksum sent with a message and then
"RTN","HLCSDR2",103,0)
 ;compares it to the checksums that have been calculated and stored
"RTN","HLCSDR2",104,0)
 ;in the HLC1 and HLC2 variables. HLC1 and HLC2 are not passed as
"RTN","HLCSDR2",105,0)
 ;parameters, their scope is "communication server-wide"
"RTN","HLCSDR2",106,0)
 ;FLAG tells the function what type of message this is, should the
"RTN","HLCSDR2",107,0)
 ;last block of data be written to an "in queue" ? or a TMP variable ?
"RTN","HLCSDR2",108,0)
 ;this depends on whether the incoming message is a message or just
"RTN","HLCSDR2",109,0)
 ;a lower level acknowledgement "LLP-ACK"
"RTN","HLCSDR2",110,0)
 ;CHK contains the 8 character cheksum that was sent with the message
"RTN","HLCSDR2",111,0)
 ;HLIND0,HLIND1 are just D0 and D1 for the "input queue" in file #870
"RTN","HLCSDR2",112,0)
 N HLBLOCK,HLXOR
"RTN","HLCSDR2",113,0)
 ;WRITE LAST BLOCK 'O DATA TO GLOBAL
"RTN","HLCSDR2",114,0)
 I $G(X)'="",FLAG="INCOMING MESSAGE" D SETNODE(HLIND0,HLIND1,HLTRANS),CHKSUM
"RTN","HLCSDR2",115,0)
 I $G(X)'="",FLAG="LLP-ACK" D SETNODE2,CHKSUM
"RTN","HLCSDR2",116,0)
 ;Extract checksums
"RTN","HLCSDR2",117,0)
 S HLBLOCK=+$E(CHK,1,5),HLXOR=+$E(CHK,6,8)
"RTN","HLCSDR2",118,0)
 D CHKSUM1,DUMP
"RTN","HLCSDR2",119,0)
 S X="$$CHK$$^"_CHK_"^HLCHK^"_$$RJ(HLC1,5)_$$RJ(HLC2,3)
"RTN","HLCSDR2",120,0)
 I FLAG="INCOMING MESSAGE" D MONITOR(HLBLOCK,5,HLDP,HLIND1,"IN"),MONITOR(HLXOR,6,HLDP,HLIND1,"IN"),MONITOR(HLC1,7,HLDP,HLIND1,"IN"),MONITOR(HLC2,8,HLDP,HLIND1,"IN")
"RTN","HLCSDR2",121,0)
 I FLAG="LLP-ACK" D SETNODE2
"RTN","HLCSDR2",122,0)
 I HLXOR="999" Q "VALID"
"RTN","HLCSDR2",123,0)
 I HLBLOCK=HLC1,HLC2=HLXOR Q "VALID"
"RTN","HLCSDR2",124,0)
 I HLBLOCK'=HLC1 Q "C"
"RTN","HLCSDR2",125,0)
 I HLXOR'=HLC2 Q "X"
"RTN","HLCSDR2",126,0)
 Q "G"
"RTN","HLCSDR2",127,0)
TRACE ;When HLTRACE is instantiated this subroutine simply writes out the
"RTN","HLCSDR2",128,0)
 ;states that the finite state machine (Lower Layer Protocol) goes thru
"RTN","HLCSDR2",129,0)
 Q:'$D(HLTRACE)
"RTN","HLCSDR2",130,0)
 U IO(0) W !,"IN STATE ",HLNXST
"RTN","HLCSDR2",131,0)
 Q
"RTN","HLCSDR2",132,0)
MONITOR(VALUE,PIECE,HLD0,HLD1,QUEUE) ;
"RTN","HLCSDR2",133,0)
 ;This subroutine simply updates a particular piece in a global node
"RTN","HLCSDR2",134,0)
 ;in file #870. It can be a zero node, or a node in a queue multiple
"RTN","HLCSDR2",135,0)
 I '$D(^HLCS(870,HLD0,0)) Q
"RTN","HLCSDR2",136,0)
 I $G(HLD1)']"" S $P(^HLCS(870,HLD0,0),U,PIECE)=VALUE Q
"RTN","HLCSDR2",137,0)
 I PIECE=2,$G(QUEUE)="IN" D  Q
"RTN","HLCSDR2",138,0)
 . N HLJ
"RTN","HLCSDR2",139,0)
 . S HLJ(870.019,HLD1_","_HLD0_",",1)=VALUE
"RTN","HLCSDR2",140,0)
 . D FILE^HLDIE("","HLJ","","MONITOR","HLCSDR2") ; HL*1.6*109
"RTN","HLCSDR2",141,0)
 S $P(^HLCS(870,HLD0,$S(QUEUE="IN":1,1:2),HLD1,0),U,PIECE)=VALUE
"RTN","HLCSDR2",142,0)
 Q
"RTN","HLCSDR2",143,0)
FORMAT(HLC,LENGTH) ;Function to stuff leading zeroes for checksums
"RTN","HLCSDR2",144,0)
 ;HLC is the checksum, Length is self-documenting
"RTN","HLCSDR2",145,0)
 Q $E("00000",1,LENGTH-$L(HLC))
"RTN","HLCSDR2",146,0)
RJ(HLC,LENGTH) ;Function to stuff leading zeroes for checksums
"RTN","HLCSDR2",147,0)
 ;HLC is the checksum, Length is self-documenting
"RTN","HLCSDR2",148,0)
 ;Functionally equivalent to $$RJ^XLFSTR(HLC,LENGTH,"0")
"RTN","HLCSDR2",149,0)
 ;Also equivalent to $$FORMAT(HLC,LENGTH)_HLC
"RTN","HLCSDR2",150,0)
 Q $E("00000",1,LENGTH-$L(HLC))_HLC
"RTN","HLCSIN")
0^87^B23255981
"RTN","HLCSIN",1,0)
HLCSIN ;ALB/JRP - INCOMING FILER;01-MAY-95 ;11/15/2000  09:37
"RTN","HLCSIN",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**2,30,14,19,62,109**;Oct 13, 1995
"RTN","HLCSIN",3,0)
STARTIN ;Main entry point for incoming background filer
"RTN","HLCSIN",4,0)
 ;Create/find entry denoting this filer in the INCOMING FILER TASK
"RTN","HLCSIN",5,0)
 ; NUMBER multiple (field #20) of the HL COMMUNICATION SERVER PARAMETER
"RTN","HLCSIN",6,0)
 ; file (#869.3)
"RTN","HLCSIN",7,0)
 ;N HLOGLINK,HLNODE,HLPARENT,HLST1,TMP ; These vbls aren't used!
"RTN","HLCSIN",8,0)
 N HLFLG,HLEXIT,HLPTRFLR
"RTN","HLCSIN",9,0)
 S HLPTRFLR=+$$CRTFLR^HLCSUTL1(ZTSK,"IN")
"RTN","HLCSIN",10,0)
 ;Loop through Logical Links and check for incoming messages
"RTN","HLCSIN",11,0)
 S HLEXIT=0
"RTN","HLCSIN",12,0)
 F  D  Q:HLEXIT
"RTN","HLCSIN",13,0)
 . S HLFLG=0
"RTN","HLCSIN",14,0)
 . D DEFACK(.HLPTRFLR,.HLFLG,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",15,0)
 . D ACKNOW(.HLPTRFLR,.HLFLG,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",16,0)
 . Q:HLFLG
"RTN","HLCSIN",17,0)
 . I $$HDIFF^XLFDT($H,$G(HLPTRFLR("LASTDEL")),2)>3600 D  Q
"RTN","HLCSIN",18,0)
 . . S HLPTRFLR("LASTDEL")=$H    ; maintain queue sizes
"RTN","HLCSIN",19,0)
 . . D DELQUE(.HLPTRFLR,.HLEXIT) ; no more than once an hour.
"RTN","HLCSIN",20,0)
 . H 5
"RTN","HLCSIN",21,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",22,0)
 S ZTSTOP=1 ;Asked to stop
"RTN","HLCSIN",23,0)
 D DELFLR^HLCSUTL1(HLPTRFLR,"IN") ;Delete entry denoting this filer
"RTN","HLCSIN",24,0)
 S ZTREQ="@"
"RTN","HLCSIN",25,0)
 Q
"RTN","HLCSIN",26,0)
DEFACK(HLPTRFLR,HLFLG,HLEXIT) ; Process TCP links with a deferred response
"RTN","HLCSIN",27,0)
 N HLXX,HLD0,HLPCT
"RTN","HLCSIN",28,0)
 S HLXX=0
"RTN","HLCSIN",29,0)
 F  S HLXX=$O(^HLMA("AC","I",HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",30,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",31,0)
 . ; HL*1.6*109
"RTN","HLCSIN",32,0)
 . ;L +^HLCS(870,HLXX,"INFILER"):0 Q:'$T  ;Does another filer have this?
"RTN","HLCSIN",33,0)
 . L +^HLMA("AC","I",HLXX):0 Q:'$T  ;*109*Does another filer have this?
"RTN","HLCSIN",34,0)
 . L +^XTMP("HL7-AC","I",HLXX):0 I '$T L -^HLMA("AC","I",HLXX) Q  ;*109* flush buffer with dt/tm stamp
"RTN","HLCSIN",35,0)
 . S HLD0=0,HLFLG=1
"RTN","HLCSIN",36,0)
 . ; HL*1.6*109 changes in for loop below, and post-quit code placed
"RTN","HLCSIN",37,0)
 . ; on following lines.
"RTN","HLCSIN",38,0)
 . S HLPCT=0 ; Counter whether filer should stop every 100th entry.
"RTN","HLCSIN",39,0)
 .;**109 - insure queue last processed at least 10 seconds ago
"RTN","HLCSIN",40,0)
 . I ($$HDIFF^XLFDT($H,$G(^XTMP("HL7-AC","I",HLXX)),2)<10) L -^XTMP("HL7-AC","I",HLXX) L -^HLMA("AC","I",HLXX) Q
"RTN","HLCSIN",41,0)
 . H 1 ;**109 ** give the system time to get synchronized
"RTN","HLCSIN",42,0)
 . F  S HLD0=$O(^HLMA("AC","I",HLXX,HLD0)) Q:'HLD0!(HLEXIT)  D
"RTN","HLCSIN",43,0)
 . . S HLPCT=HLPCT+1
"RTN","HLCSIN",44,0)
 . . I '(HLPCT#100) D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",45,0)
 . . L +^HLMA(HLD0):0 Q:'$T
"RTN","HLCSIN",46,0)
 . . L +^HLMA("AC","I",HLXX,HLD0):0 I '$T L -^HLMA(HLD0) Q
"RTN","HLCSIN",47,0)
 . . I '$$CHECKAC("I",HLXX,HLD0) L -^HLMA("AC","I",HLXX,HLD0) L -^HLMA(HLD0) Q  ;-> Quit if not a valid AC xref
"RTN","HLCSIN",48,0)
 . . I '$D(^HLMA("AC","I",HLXX,HLD0)) L -^HLMA("AC","I",HLXX,HLD0) L -^HLMA(HLD0) Q
"RTN","HLCSIN",49,0)
 . . D DEFACK^HLTP3(HLXX,HLD0)
"RTN","HLCSIN",50,0)
 . . D DEQUE^HLCSREP(HLXX,"I",HLD0)
"RTN","HLCSIN",51,0)
 . . L -^HLMA("AC","I",HLXX,HLD0)
"RTN","HLCSIN",52,0)
 . . L -^HLMA(HLD0)
"RTN","HLCSIN",53,0)
 . ;L -^HLCS(870,HLXX,"INFILER")
"RTN","HLCSIN",54,0)
 . ;**109 -add dt/tm stamp to time queue last processed
"RTN","HLCSIN",55,0)
 . S ^XTMP("HL7-AC","I",HLXX)=$H
"RTN","HLCSIN",56,0)
 . ;**109 - flush the  buffer and unlock the queue
"RTN","HLCSIN",57,0)
 . L -^XTMP("HL7-AC","I",HLXX)
"RTN","HLCSIN",58,0)
 . L -^HLMA("AC","I",HLXX)
"RTN","HLCSIN",59,0)
 Q
"RTN","HLCSIN",60,0)
 ;
"RTN","HLCSIN",61,0)
CHECKAC(WAY,IEN870,IEN773) ; If AC xref shouldn't exist, kill it...
"RTN","HLCSIN",62,0)
 ;
"RTN","HLCSIN",63,0)
 ; Check status and if 3 (processed) kill XREF...
"RTN","HLCSIN",64,0)
 I $P($G(^HLMA(+IEN773,"P")),U)=3 D  QUIT "" ;->
"RTN","HLCSIN",65,0)
 .  D DEQUE^HLCSREP(IEN870,WAY,IEN773)
"RTN","HLCSIN",66,0)
 ;
"RTN","HLCSIN",67,0)
 ; Add other checks here in the future...
"RTN","HLCSIN",68,0)
 ;
"RTN","HLCSIN",69,0)
 Q 1
"RTN","HLCSIN",70,0)
 ;
"RTN","HLCSIN",71,0)
ACKNOW(HLPTRFLR,HLFLG,HLEXIT) ; Process Logical Link's IN-queue for received message
"RTN","HLCSIN",72,0)
 N HLXX,HLD0,HLD1
"RTN","HLCSIN",73,0)
 S HLXX=0
"RTN","HLCSIN",74,0)
 F  S HLXX=$O(^HLCS(870,"AISTAT","P",HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",75,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",76,0)
 .; HL*1.6*109
"RTN","HLCSIN",77,0)
 . L +^HLCS(870,HLXX,"INFILER"):0 Q:'$T  ;Does another filer have this?
"RTN","HLCSIN",78,0)
 . F  D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT  S HLD0=$$DEQUEUE^HLCSQUE(HLXX,"IN") Q:+HLD0<0  D
"RTN","HLCSIN",79,0)
 . . ;Make sure message is ready to be received
"RTN","HLCSIN",80,0)
 . . S HLFLG=1
"RTN","HLCSIN",81,0)
 . . S HLD1=$P(HLD0,"^",2)
"RTN","HLCSIN",82,0)
 . . S HLD0=+HLD0 ; At this point, HLD0=HLXX
"RTN","HLCSIN",83,0)
 . . I $P($G(^HLCS(870,HLD0,1,HLD1,0)),"^",3)'="A" D  Q
"RTN","HLCSIN",84,0)
 . . . D MONITOR^HLCSDR2("D",2,HLD0,HLD1,"IN") ;Set status to DONE
"RTN","HLCSIN",85,0)
 . . D RECEIVE^HLMA0(HLD0,HLD1) ;Process received message
"RTN","HLCSIN",86,0)
 . . D MONITOR^HLCSDR2("D",2,HLD0,HLD1,"IN") ;Set status to DONE
"RTN","HLCSIN",87,0)
 . I HLD0<0,$D(^HLCS(870,"AISTAT","P",HLXX)) D
"RTN","HLCSIN",88,0)
 . . S HLD1=0 ; Make sure there aren't any loose xrefs hanging around.
"RTN","HLCSIN",89,0)
 . . F  S HLD1=$O(^HLCS(870,"AISTAT","P",HLXX,HLD1)) Q:'HLD1  D
"RTN","HLCSIN",90,0)
 . . . ;I '$D(^HLCS(870,HLXX,1,HLD1,0)) K ^HLCS(870,"AISTAT","P",HLXX,HLD1)
"RTN","HLCSIN",91,0)
 . . . I $P($G(^HLCS(870,HLXX,1,HLD1,0)),U,2)'="P" K ^HLCS(870,"AISTAT","P",HLXX,HLD1)
"RTN","HLCSIN",92,0)
 . L -^HLCS(870,HLXX,"INFILER")
"RTN","HLCSIN",93,0)
 Q
"RTN","HLCSIN",94,0)
DELQUE(HLPTRFLR,HLEXIT) ; Delete messages outside the 'queue size' window.
"RTN","HLCSIN",95,0)
 N HLDIR,HLXX,HLFRONT
"RTN","HLCSIN",96,0)
 S HLDIR=1,HLXX=0
"RTN","HLCSIN",97,0)
 F  S HLXX=$O(^HLCS(870,HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",98,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",99,0)
 . L +^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"):0 Q:'$T
"RTN","HLCSIN",100,0)
 . S HLFRONT=$G(^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"))
"RTN","HLCSIN",101,0)
 . L -^HLCS(870,HLXX,"IN QUEUE FRONT POINTER")
"RTN","HLCSIN",102,0)
 . D DELETE^HLCSQUE1(HLXX,HLDIR,HLFRONT)
"RTN","HLCSIN",103,0)
 Q
"RTN","HLCSIN",104,0)
CHKUPD(HLPTRFLR,HLEXIT) ;
"RTN","HLCSIN",105,0)
 Q:$$HDIFF^XLFDT($H,$G(HLPTRFLR("LASTUP")),2)<15
"RTN","HLCSIN",106,0)
 D SETFLRDH^HLCSUTL1(HLPTRFLR,"IN") ; Update LAST KNOWN $H (field #.03) for filer
"RTN","HLCSIN",107,0)
 S HLPTRFLR("LASTUP")=$H
"RTN","HLCSIN",108,0)
 D CHK4STOP^HLCSUTL2(HLPTRFLR,"IN",.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",109,0)
 Q
"RTN","HLCSLM")
0^40^B36276435
"RTN","HLCSLM",1,0)
HLCSLM ;SFCIOFO/AC - HL7 LINK MANAGER ;02/04/2004  07:57
"RTN","HLCSLM",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**49,57,109**;Oct 13, 1995
"RTN","HLCSLM",3,0)
 ;
"RTN","HLCSLM",4,0)
EN ;Entry point for start up task
"RTN","HLCSLM",5,0)
 N %,HLEVLCHK,HLTSKCNT
"RTN","HLCSLM",6,0)
 F %=1:1:10 L +^HLCS("HLCSLM"):2 Q:$T
"RTN","HLCSLM",7,0)
 E  Q
"RTN","HLCSLM",8,0)
 I $G(ZTQUEUED) S Y=$$PSET^%ZTLOAD(ZTQUEUED)
"RTN","HLCSLM",9,0)
 D INIT,SAVDOLRH
"RTN","HLCSLM",10,0)
 D SETNM^%ZOSV($E("HLmgr:"_$G(ZTQUEUED),1,15))
"RTN","HLCSLM",11,0)
 ;
"RTN","HLCSLM",12,0)
LOOP ;
"RTN","HLCSLM",13,0)
 D CHKQUE
"RTN","HLCSLM",14,0)
 I $$CKLMSTOP G EXIT
"RTN","HLCSLM",15,0)
 D SAVDOLRH
"RTN","HLCSLM",16,0)
 D CHECKMST^HLEVMST ;HL*1.6*109 - Make sure event monitor current
"RTN","HLCSLM",17,0)
 H 10
"RTN","HLCSLM",18,0)
 G LOOP
"RTN","HLCSLM",19,0)
 ;
"RTN","HLCSLM",20,0)
EXIT N HLJ,X
"RTN","HLCSLM",21,0)
 S X=1
"RTN","HLCSLM",22,0)
 F  L +^HLCS(869.3,X,5):2 Q:$T
"RTN","HLCSLM",23,0)
 ;52=Link Manager task number
"RTN","HLCSLM",24,0)
 S HLJ(869.3,X_",",52)="@"
"RTN","HLCSLM",25,0)
 D FILE^HLDIE("","HLJ","","EXIT","HLCSLM") ;HL*1.6*109
"RTN","HLCSLM",26,0)
 L -^HLCS(869.3,X,5)
"RTN","HLCSLM",27,0)
 L -^HLCS("HLCSLM")
"RTN","HLCSLM",28,0)
 Q
"RTN","HLCSLM",29,0)
 ;
"RTN","HLCSLM",30,0)
SAVDOLRH ;Save Last Known $H
"RTN","HLCSLM",31,0)
 N HLJ,X
"RTN","HLCSLM",32,0)
 S X=1
"RTN","HLCSLM",33,0)
 F  L +^HLCS(869.3,X,5):2 Q:$T
"RTN","HLCSLM",34,0)
 ;54=LM LAST KNOWN $H
"RTN","HLCSLM",35,0)
 S HLJ(869.3,X_",",54)=$H
"RTN","HLCSLM",36,0)
 D FILE^HLDIE("","HLJ","","SAVDOLRH","HLCSLM") ;HL*1.6*109
"RTN","HLCSLM",37,0)
 L -^HLCS(869.3,X,5)
"RTN","HLCSLM",38,0)
 Q
"RTN","HLCSLM",39,0)
 ;
"RTN","HLCSLM",40,0)
CHKQUE ;Check queues for messages to send
"RTN","HLCSLM",41,0)
 ;HLTSKCNT(logical link)=task #^$H
"RTN","HLCSLM",42,0)
 N HLDA,HLDP,HLMSG,HLTSK,Y
"RTN","HLCSLM",43,0)
 S (HLDA,HLMSG)=""
"RTN","HLCSLM",44,0)
 F HLDP=0:0 S HLDP=+$O(^HLMA("AC","O",HLDP)) Q:HLDP'>0  S HLMSG=+$O(^(HLDP,0)) I HLMSG D  L -^HLCS("HLCSLSM",HLDP)
"RTN","HLCSLM",45,0)
 .;quit if persistent link
"RTN","HLCSLM",46,0)
 .Q:$P($G(^HLCS(870,HLDP,400)),U,4)="Y"
"RTN","HLCSLM",47,0)
 .L +^HLCS("HLCSLSM",HLDP):0 E  K HLTSKCNT(HLDP) Q
"RTN","HLCSLM",48,0)
 .Q:'$$LLOK(+HLDP)
"RTN","HLCSLM",49,0)
 .;get tasknumber from file 870 and HLTSKCNT array
"RTN","HLCSLM",50,0)
 .S Y=$$TASKNUM(HLDP),HLTSK=$G(HLTSKCNT(HLDP))
"RTN","HLCSLM",51,0)
 .;no tasknumber, link not running nor queued, task it
"RTN","HLCSLM",52,0)
 .I 'HLTSK!'Y D TASKLSUB(HLDP),SAVTSK(HLDP) Q
"RTN","HLCSLM",53,0)
 .;link was tasked, check time
"RTN","HLCSLM",54,0)
 .S Y=$P(HLTSK,U,2)
"RTN","HLCSLM",55,0)
 .;check that time task is less than 30 minutes
"RTN","HLCSLM",56,0)
 .Q:$$HDIFF^XLFDT($H,Y,2)<1800
"RTN","HLCSLM",57,0)
 .;shutdown and send alert
"RTN","HLCSLM",58,0)
 .D SDFLD^HLCSTCP,EXITS^HLCSTCP("Shutdown"),SNDALERT
"RTN","HLCSLM",59,0)
 ;loop through links that have been tasked
"RTN","HLCSLM",60,0)
 F HLDP=0:0 S HLDP=$O(HLTSKCNT(HLDP)) Q:HLDP'>0  K:'$D(^HLMA("AC","O",HLDP)) HLTSKCNT(HLDP)
"RTN","HLCSLM",61,0)
 Q
"RTN","HLCSLM",62,0)
 ;
"RTN","HLCSLM",63,0)
INIT ;Create Task number and clear Stop flag.
"RTN","HLCSLM",64,0)
 N HLJ,X
"RTN","HLCSLM",65,0)
 S X=1
"RTN","HLCSLM",66,0)
 F  L +^HLCS(869.3,X,5):2 Q:$T
"RTN","HLCSLM",67,0)
 ;52=Link Manager task number,53=Stop Link Manager
"RTN","HLCSLM",68,0)
 S HLJ(869.3,X_",",52)=$G(ZTQUEUED)
"RTN","HLCSLM",69,0)
 S HLJ(869.3,X_",",53)="@"
"RTN","HLCSLM",70,0)
 D FILE^HLDIE("","HLJ","","INIT","HLCSLM") ;HL*1.6*109
"RTN","HLCSLM",71,0)
 L -^HLCS(869.3,X,5)
"RTN","HLCSLM",72,0)
 Q
"RTN","HLCSLM",73,0)
TASKNUM(X) ;Look-up task number
"RTN","HLCSLM",74,0)
 N %,DA,Y
"RTN","HLCSLM",75,0)
 S DA=X
"RTN","HLCSLM",76,0)
 ;
"RTN","HLCSLM",77,0)
 ;**109**
"RTN","HLCSLM",78,0)
 ;F  L +^HLCS(870,+DA,0):2 Q:$T
"RTN","HLCSLM",79,0)
 ;
"RTN","HLCSLM",80,0)
 S Y=$$GET1^DIQ(870,DA_",",11)
"RTN","HLCSLM",81,0)
 ;
"RTN","HLCSLM",82,0)
 ;**109
"RTN","HLCSLM",83,0)
 ;L -^HLCS(870,+DA,0)
"RTN","HLCSLM",84,0)
 ;
"RTN","HLCSLM",85,0)
 Q Y
"RTN","HLCSLM",86,0)
STATUS(X) ;Status of task
"RTN","HLCSLM",87,0)
 N Y,ZTSK
"RTN","HLCSLM",88,0)
 S ZTSK=X
"RTN","HLCSLM",89,0)
 D STAT^%ZTLOAD
"RTN","HLCSLM",90,0)
 S Y=ZTSK(1)
"RTN","HLCSLM",91,0)
 Q Y
"RTN","HLCSLM",92,0)
 ;
"RTN","HLCSLM",93,0)
LLOK(X) ;Function to check whether LL ok.
"RTN","HLCSLM",94,0)
 ;return value 1 = ok, 0 = not ok.
"RTN","HLCSLM",95,0)
 Q:'$G(X)
"RTN","HLCSLM",96,0)
 N HLDP,HLDP0,HLPARM4,HLTYPTR
"RTN","HLCSLM",97,0)
 S HLDP=+X,HLDP0=$G(^HLCS(870,HLDP,0)),HLPARM4=$G(^(400)) Q:HLDP0="" 0
"RTN","HLCSLM",98,0)
 ;must be a client
"RTN","HLCSLM",99,0)
 Q:$P(HLPARM4,U,3)'="C" 0
"RTN","HLCSLM",100,0)
 ;shutdown LLP must be 0
"RTN","HLCSLM",101,0)
 Q:$P(HLDP0,U,15)'=0 0
"RTN","HLCSLM",102,0)
 ;must have LLP Type of TCP
"RTN","HLCSLM",103,0)
 S HLTYPTR=+$P(HLDP0,U,3) Q:$P($G(^HLCS(869.1,HLTYPTR,0)),U)'="TCP" 0
"RTN","HLCSLM",104,0)
 Q 1
"RTN","HLCSLM",105,0)
 ;
"RTN","HLCSLM",106,0)
SAVTSK(X) ;
"RTN","HLCSLM",107,0)
 N HLDP,HLJ
"RTN","HLCSLM",108,0)
 S HLDP=X
"RTN","HLCSLM",109,0)
 ;
"RTN","HLCSLM",110,0)
 ;**109**
"RTN","HLCSLM",111,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSLM",112,0)
 ;
"RTN","HLCSLM",113,0)
 ;4=status,10=Time Stopped,9=Time Started,11=Task Number,3=Online ?
"RTN","HLCSLM",114,0)
 S X=$NA(HLJ(870,HLDP_",")),@X@(11)=$G(ZTSK)
"RTN","HLCSLM",115,0)
 ;S HLJ(870,HLDP_",",11)=$G(ZTSK)
"RTN","HLCSLM",116,0)
 D FILE^HLDIE("","HLJ","","SAVTSK","HLCSLM") ; HL*1.6*109
"RTN","HLCSLM",117,0)
 S HLTSKCNT(HLDP)=$G(ZTSK)_"^"_$H
"RTN","HLCSLM",118,0)
 ;
"RTN","HLCSLM",119,0)
 ;**109**
"RTN","HLCSLM",120,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSLM",121,0)
 ;
"RTN","HLCSLM",122,0)
 Q
"RTN","HLCSLM",123,0)
 ;
"RTN","HLCSLM",124,0)
STRTSTOP ;ENTRY POINT TO START/STOP TCP LINK MANAGER
"RTN","HLCSLM",125,0)
 N DIR,DIRUT,Y
"RTN","HLCSLM",126,0)
 L +^HLCS("HLCSLM"):3 E  D  Q
"RTN","HLCSLM",127,0)
 .W !,*7,"Link Manager already running!"
"RTN","HLCSLM",128,0)
 .W ! S DIR(0)="YO",DIR("A")="Would you like to stop the Link Manager now",DIR("B")="NO" D ^DIR K DIR
"RTN","HLCSLM",129,0)
 .I $D(DIRUT)!'Y Q
"RTN","HLCSLM",130,0)
 .D STOPLM
"RTN","HLCSLM",131,0)
 W !,*7,"Link Manager is NOT currently running!"
"RTN","HLCSLM",132,0)
 W ! S DIR(0)="YO",DIR("A")="Would you like to start the Link Manager now",DIR("B")="YES" D ^DIR K DIR
"RTN","HLCSLM",133,0)
 I '$D(DIRUT)&Y D TASKLM
"RTN","HLCSLM",134,0)
 L -^HLCS("HLCSLM")
"RTN","HLCSLM",135,0)
 Q
"RTN","HLCSLM",136,0)
 ;
"RTN","HLCSLM",137,0)
STOPLM ;ENTRY POINT TO STOP LINK MANAGER
"RTN","HLCSLM",138,0)
 N DIC,X,Y,DTOUT,DUOUT,DLAYGO,DIE,DA,DR
"RTN","HLCSLM",139,0)
 S DIC="^HLCS(869.3,"
"RTN","HLCSLM",140,0)
 S X=1
"RTN","HLCSLM",141,0)
 D ^DIC
"RTN","HLCSLM",142,0)
 S DA=+Y,DIE=DIC
"RTN","HLCSLM",143,0)
 S DR="53////1"
"RTN","HLCSLM",144,0)
 D ^DIE
"RTN","HLCSLM",145,0)
 W !,"Link Manager has been asked to stop"
"RTN","HLCSLM",146,0)
 Q
"RTN","HLCSLM",147,0)
STAT() ;Status of LINK MANAGER--up, down or unable to determine.
"RTN","HLCSLM",148,0)
 N %,DA,X,Y
"RTN","HLCSLM",149,0)
 S DA=1
"RTN","HLCSLM",150,0)
 S X=$$GET1^DIQ(869.3,DA_",",52)
"RTN","HLCSLM",151,0)
 Q:X']"" 0
"RTN","HLCSLM",152,0)
 S X=$$GET1^DIQ(869.3,DA_",",54)
"RTN","HLCSLM",153,0)
 Q:X']"" 0
"RTN","HLCSLM",154,0)
 I $$HDIFF^XLFDT($H,X,2)>500 Q 0
"RTN","HLCSLM",155,0)
 Q 1
"RTN","HLCSLM",156,0)
 ;
"RTN","HLCSLM",157,0)
TASKLSUB(X) ;Task LINK SUB-MANAGER.
"RTN","HLCSLM",158,0)
 ;This may be a place to log the time which the LINK SUBMANAGER is tasked.
"RTN","HLCSLM",159,0)
 N HLDP,HLDP0,HLDAPP,HLTYPTR,HLBGR,HLENV,HLPARM,HLPARM4,HLQUIT,ZTRTN,ZTDESC,ZTCPU,ZTSAVE
"RTN","HLCSLM",160,0)
 ;ZTSK is not Newed here because it will be needed by SAVTSK.
"RTN","HLCSLM",161,0)
 S HLDP=X,HLDP0=$G(^HLCS(870,HLDP,0)),HLPARM4=$G(^(400))
"RTN","HLCSLM",162,0)
 Q:"N"'[$P(HLPARM4,U,4)
"RTN","HLCSLM",163,0)
 ;quit if no LLP TYPE
"RTN","HLCSLM",164,0)
 S HLDAPP=$P(HLDP0,U),HLTYPTR=$P(HLDP0,U,3) Q:'HLTYPTR
"RTN","HLCSLM",165,0)
 S HLBGR=$G(^HLCS(869.1,HLTYPTR,100)),HLENV=$G(^(200))
"RTN","HLCSLM",166,0)
 I HLENV'="" K HLQUIT X HLENV Q:$D(HLQUIT)
"RTN","HLCSLM",167,0)
 S ZTRTN="^HLCSLSM",HLBGR=$P(HLBGR," ",2)
"RTN","HLCSLM",168,0)
 S ZTDESC=HLDAPP_" Low Level Protocol",ZTSAVE("HLDP")="",ZTSAVE("HLBGR")=""
"RTN","HLCSLM",169,0)
 S ZTIO="",ZTDTH=$H
"RTN","HLCSLM",170,0)
 ;get startup node
"RTN","HLCSLM",171,0)
 I $P(HLPARM4,U,6),$D(^%ZIS(14.7,+$P(HLPARM4,U,6),0)) S ZTCPU=$P(^(0),U)
"RTN","HLCSLM",172,0)
 D ^%ZTLOAD
"RTN","HLCSLM",173,0)
 Q
"RTN","HLCSLM",174,0)
 ;
"RTN","HLCSLM",175,0)
TASKLM ;Task Link Manager
"RTN","HLCSLM",176,0)
 ;Declare variables
"RTN","HLCSLM",177,0)
 N ZTRTN,ZTDESC,ZTIO,ZTDTH,ZTSK,TMP
"RTN","HLCSLM",178,0)
 S ZTIO=""
"RTN","HLCSLM",179,0)
 S ZTDTH=$H
"RTN","HLCSLM",180,0)
 ;Task Link Manager
"RTN","HLCSLM",181,0)
 S ZTRTN="EN^HLCSLM"
"RTN","HLCSLM",182,0)
 S ZTDESC="HL7 Link Manager"
"RTN","HLCSLM",183,0)
 ;Call TaskMan
"RTN","HLCSLM",184,0)
 D ^%ZTLOAD
"RTN","HLCSLM",185,0)
 I $G(ZTSK) W !,"Link Manager queued as task number ",ZTSK
"RTN","HLCSLM",186,0)
 E  W $C(7),!!,"Unable to start/restart Link Manager"
"RTN","HLCSLM",187,0)
 Q
"RTN","HLCSLM",188,0)
 ;
"RTN","HLCSLM",189,0)
CKLMSTOP() ;Check whether Link Manager should stop
"RTN","HLCSLM",190,0)
 N PTRMAIN,NODE5,STOP
"RTN","HLCSLM",191,0)
 S PTRMAIN=+$O(^HLCS(869.3,0))
"RTN","HLCSLM",192,0)
 L +^HLCS(869.3,PTRMAIN,5):1
"RTN","HLCSLM",193,0)
 I $T L -^HLCS(869.3,PTRMAIN,5)
"RTN","HLCSLM",194,0)
 S NODE5=$G(^HLCS(869.3,PTRMAIN,5))
"RTN","HLCSLM",195,0)
 S STOP=+$P(NODE5,"^",3)
"RTN","HLCSLM",196,0)
 Q:STOP STOP
"RTN","HLCSLM",197,0)
 S STOP=$$S^%ZTLOAD
"RTN","HLCSLM",198,0)
 Q STOP
"RTN","HLCSLM",199,0)
 ;
"RTN","HLCSLM",200,0)
SNDALERT ;Send Alert
"RTN","HLCSLM",201,0)
 N XQA,XQAMSG,XQAOPT,XQAROU,XQAID,Z
"RTN","HLCSLM",202,0)
 S Z=$P($$PARAM^HLCS2,U,8) Q:Z=""
"RTN","HLCSLM",203,0)
 S XQA("G."_Z)="",XQAMSG="HL7 Logical Link "_$P(^HLCS(870,HLDP,0),U)_" shutdown due to TaskMan unable to process task request"
"RTN","HLCSLM",204,0)
 D SETUP^XQALERT
"RTN","HLCSLM",205,0)
 Q
"RTN","HLCSLNCH")
0^53^B37171475
"RTN","HLCSLNCH",1,0)
HLCSLNCH ;ALB/MTC/JC - START AND STOP THE LLP ;12/31/2003  17:37
"RTN","HLCSLNCH",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**6,19,43,49,57,75,84,109**;Oct 13, 1995
"RTN","HLCSLNCH",3,0)
 ;
"RTN","HLCSLNCH",4,0)
 ;This program is callable from a menu
"RTN","HLCSLNCH",5,0)
 ;It allows the user to Start and Stop the Lower Layer
"RTN","HLCSLNCH",6,0)
 ;Protocol in the Background or in the foreground
"RTN","HLCSLNCH",7,0)
 ;
"RTN","HLCSLNCH",8,0)
 ;Required or Optional INPUT PARAMETERS
"RTN","HLCSLNCH",9,0)
 ;             None
"RTN","HLCSLNCH",10,0)
 ;
"RTN","HLCSLNCH",11,0)
 ;
"RTN","HLCSLNCH",12,0)
 ;Output variables
"RTN","HLCSLNCH",13,0)
 ;             HLDP=IEN of Logical Link in file #870
"RTN","HLCSLNCH",14,0)
 ;(optional)HLTRACE=if SET it launches the LLP in the Foreground
"RTN","HLCSLNCH",15,0)
 ;(optional)   ZTSK=if defined LLP was launched in the
"RTN","HLCSLNCH",16,0)
 ;background
"RTN","HLCSLNCH",17,0)
 ;
"RTN","HLCSLNCH",18,0)
 ;
"RTN","HLCSLNCH",19,0)
START ; Start up the lower level protocol
"RTN","HLCSLNCH",20,0)
 N DIC,DIRUT,DTOUT,DUOUT,HLDP,HLDAPP,HLJ,HLQUIT,HLTRACE
"RTN","HLCSLNCH",21,0)
 N HLPARM0,HLPARM4,HLTYPTR,HLBGR,X,Y,ZTCPU,ZTSK,ZTRTN,ZTDESC
"RTN","HLCSLNCH",22,0)
 W !!,"This option is used to launch the lower level protocol for the"
"RTN","HLCSLNCH",23,0)
 W !,"appropriate device.  Please select the node with which you want"
"RTN","HLCSLNCH",24,0)
 W !,"to communicate",!
"RTN","HLCSLNCH",25,0)
 S DIC="^HLCS(870,",DIC(0)="QEAMZ" D ^DIC G:Y<0 STARTQ
"RTN","HLCSLNCH",26,0)
 S HLDP=+Y,HLDAPP=Y(0,0),HLTYPTR=+$P(Y(0),U,3),HLPARM0=Y(0)
"RTN","HLCSLNCH",27,0)
 ;-- check if parameter have been setup
"RTN","HLCSLNCH",28,0)
 ;-- check for LLP type
"RTN","HLCSLNCH",29,0)
 I 'HLTYPTR W !,$C(7),"A Lower Layer Protocol must be selected before start-up can occur." G STARTQ
"RTN","HLCSLNCH",30,0)
 ;-- get TCP information
"RTN","HLCSLNCH",31,0)
 S HLPARM4=$G(^HLCS(870,HLDP,400))
"RTN","HLCSLNCH",32,0)
 ;-- get routine (background job for LLP)
"RTN","HLCSLNCH",33,0)
 S HLBGR=$G(^HLCS(869.1,HLTYPTR,100))
"RTN","HLCSLNCH",34,0)
 ;-- get environment check routine (HLQUIT should be defined in fails)
"RTN","HLCSLNCH",35,0)
 S HLENV=$G(^HLCS(869.1,HLTYPTR,200))
"RTN","HLCSLNCH",36,0)
 ;
"RTN","HLCSLNCH",37,0)
 I HLBGR="" W !,$C(7),"No routine has been specified for this LLP." G STARTQ
"RTN","HLCSLNCH",38,0)
 ;
"RTN","HLCSLNCH",39,0)
 ;-- execute environment check routine if HLQUIT is defined then terminate
"RTN","HLCSLNCH",40,0)
 I HLENV'="" X HLENV G:$D(HLQUIT) STARTQ
"RTN","HLCSLNCH",41,0)
 ;Multi-Servers, only enable the link if not OpenM
"RTN","HLCSLNCH",42,0)
 I $P(HLPARM4,U,3)="M",$S(^%ZOSF("OS")'["OpenM":1,1:$$OS^%ZOSV["VMS") D  G STARTQ
"RTN","HLCSLNCH",43,0)
 . W !,$C(7),"This LLP is a multi-threaded server. It is controlled by external service, i.e. TCPIP/UCX. You must use the external service to start this LLP."
"RTN","HLCSLNCH",44,0)
 . Q
"RTN","HLCSLNCH",45,0)
 ;
"RTN","HLCSLNCH",46,0)
 I $P(HLPARM0,U,10) W !,$C(7),"The LLP was last started on ",$$DAT2^HLUTIL1($P(HLPARM0,U,10)),"." G STP1:$P(HLPARM0,U,5)'="Error"
"RTN","HLCSLNCH",47,0)
 I $P(HLPARM0,U,11) W !,"The LLP was last shutdown on ",$$DAT2^HLUTIL1($P(HLPARM0,U,11)),"."
"RTN","HLCSLNCH",48,0)
 I $P(HLPARM0,U,5)'="Error",'($P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4))),$P(HLPARM0,U,10)]""&($P(HLPARM0,U,11)=""),$P(HLPARM0,U,12) W !,"The LLP appears to be online already !"
"RTN","HLCSLNCH",49,0)
 I $$TASK^HLUTIL1($P(HLPARM0,U,12)) D  G STARTQ
"RTN","HLCSLNCH",50,0)
 . W !,$C(7),"NOTE: The lower level protocol for this application is already running."
"RTN","HLCSLNCH",51,0)
 I $P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4)) D  G STARTQ
"RTN","HLCSLNCH",52,0)
 .;4=status 9=Time Started, 10=Time Stopped, 11=Task Number 
"RTN","HLCSLNCH",53,0)
 .;14=Shutdown LLP, 3=Device Type, 18=Gross Errors
"RTN","HLCSLNCH",54,0)
 .N HLJ,X
"RTN","HLCSLNCH",55,0)
 .I $P(HLPARM0,U,15)=0 W !,"This LLP is already enabled!" Q
"RTN","HLCSLNCH",56,0)
 .L +^HLCS(870,HLDP,0):2
"RTN","HLCSLNCH",57,0)
 .E  W !,$C(7),"Unable to enable this LLP !" Q
"RTN","HLCSLNCH",58,0)
 .S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCSLNCH",59,0)
 .S @X@(4)="Enabled",@X@(9)=$$NOW^XLFDT,@X@(14)=0
"RTN","HLCSLNCH",60,0)
 .D FILE^HLDIE("","HLJ","","START","HLCSLNCH") ;HL*1.6*109
"RTN","HLCSLNCH",61,0)
 .L -^HLCS(870,HLDP,0)
"RTN","HLCSLNCH",62,0)
 .W !,"This LLP has been enabled!"
"RTN","HLCSLNCH",63,0)
 .Q
"RTN","HLCSLNCH",64,0)
 I $P(HLPARM4,U,6),$D(^%ZIS(14.7,+$P(HLPARM4,U,6),0)) S ZTCPU=$P(^(0),U) W !,"This LLP will start on node ",ZTCPU," if it is run in the Background.",!
"RTN","HLCSLNCH",65,0)
 ;
"RTN","HLCSLNCH",66,0)
 W ! S DIR(0)="SM^F:FOREGROUND;B:BACKGROUND;Q:QUIT"
"RTN","HLCSLNCH",67,0)
 S DIR("A")="Method for running the receiver"
"RTN","HLCSLNCH",68,0)
 S DIR("B")="B"
"RTN","HLCSLNCH",69,0)
 S DIR("?",1)="Enter F for Foreground (and trace)"
"RTN","HLCSLNCH",70,0)
 S DIR("?",2)="      B for Background (normal) or"
"RTN","HLCSLNCH",71,0)
 S DIR("?")="      Q to quit without starting the receiver"
"RTN","HLCSLNCH",72,0)
 D ^DIR K DIR
"RTN","HLCSLNCH",73,0)
 Q:(Y=U)!(Y="Q")
"RTN","HLCSLNCH",74,0)
 ;
"RTN","HLCSLNCH",75,0)
 S HLX=$G(^HLCS(870,HLDP,0))
"RTN","HLCSLNCH",76,0)
 ;-- foreground
"RTN","HLCSLNCH",77,0)
 I Y="F" S HLTRACE=1 D  G STARTQ
"RTN","HLCSLNCH",78,0)
 . X HLBGR
"RTN","HLCSLNCH",79,0)
 ;-- background
"RTN","HLCSLNCH",80,0)
 I Y="B" D  G STARTQ
"RTN","HLCSLNCH",81,0)
 . S ZTRTN=$P(HLBGR," ",2),HLTRACE="",ZTIO="",ZTDTH=$H
"RTN","HLCSLNCH",82,0)
 . S ZTDESC=HLDAPP_" Low Level Protocol",ZTSAVE("HLDP")=""
"RTN","HLCSLNCH",83,0)
 . D ^%ZTLOAD
"RTN","HLCSLNCH",84,0)
 . W !,$S($D(ZTSK):"Job was queued as "_ZTSK_".",1:"Unable to queue job.")
"RTN","HLCSLNCH",85,0)
 ;
"RTN","HLCSLNCH",86,0)
 Q
"RTN","HLCSLNCH",87,0)
 ;
"RTN","HLCSLNCH",88,0)
 ;
"RTN","HLCSLNCH",89,0)
STARTQ ;
"RTN","HLCSLNCH",90,0)
 I $G(POP) W !,?5,"-Unable to Open the Device !",!,!,?6,"Check that Port is Logged Out, and that the",!,?6,"Lower Level Protocol is not Already Running."
"RTN","HLCSLNCH",91,0)
 Q
"RTN","HLCSLNCH",92,0)
 ;
"RTN","HLCSLNCH",93,0)
STOP ; Shut down a lower level protocol..
"RTN","HLCSLNCH",94,0)
 N DIC,DIRUT,DTOUT,DUOUT,HLDP,HLDAPP,HLJ,HLPARM0,HLPARM4,X,Y
"RTN","HLCSLNCH",95,0)
 W !!,"This option is used to shut down the lower level protocol for the"
"RTN","HLCSLNCH",96,0)
 W !,"appropriate device.  Please select the link which you would"
"RTN","HLCSLNCH",97,0)
 W !,"like to shutdown.",!
"RTN","HLCSLNCH",98,0)
 S DIC="^HLCS(870,",DIC(0)="QEAMZ" D ^DIC K DIC Q:Y<0
"RTN","HLCSLNCH",99,0)
 S HLDP=+Y,HLDAPP=Y(0,0),HLPARM0=Y(0),HLPARM4=$G(^HLCS(870,HLDP,400))
"RTN","HLCSLNCH",100,0)
 I $P(HLPARM4,U,3)="M",$S(^%ZOSF("OS")'["OpenM":1,1:$$OS^%ZOSV["VMS") D  Q
"RTN","HLCSLNCH",101,0)
 . W !,$C(7),"This LLP is a multi-threaded server. It is controlled by external service, i.e. UCX. You must use the external service to disable this LLP."
"RTN","HLCSLNCH",102,0)
 . Q
"RTN","HLCSLNCH",103,0)
 ;
"RTN","HLCSLNCH",104,0)
 I $P(HLPARM0,U,15) W !,$C(7),"The lower level protocol is already ",$P(HLPARM0,U,5),"." Q
"RTN","HLCSLNCH",105,0)
 I $P(HLPARM0,U,10) W !,$C(7),"The lower level protocol was started on ",$$DAT2^HLUTIL1($P(HLPARM0,U,10)),"."
"RTN","HLCSLNCH",106,0)
STP1 ;
"RTN","HLCSLNCH",107,0)
 W ! S DIR(0)="Y",DIR("A")="Okay to shut down this job" D ^DIR K DIR
"RTN","HLCSLNCH",108,0)
 I 'Y!($D(DIRUT))!($D(DUOUT)) W !!,"The job will not be shut down." Q
"RTN","HLCSLNCH",109,0)
S ;
"RTN","HLCSLNCH",110,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSLNCH",111,0)
 ;4=status,10=Time Stopped,9=Time Started,11=Task Number,3=Device Type,14=shutdown
"RTN","HLCSLNCH",112,0)
 S X="HLJ(870,"""_HLDP_","")",@X@(4)="Halting",@X@(10)=$$NOW^XLFDT,(@X@(11),@X@(9))="@",@X@(14)=1
"RTN","HLCSLNCH",113,0)
 I $P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4)),'$P(HLPARM0,U,12) S @X@(4)="Shutdown"
"RTN","HLCSLNCH",114,0)
 D FILE^HLDIE("","HLJ","","STOP","HLCSLNCH") ; HL*1.6*109
"RTN","HLCSLNCH",115,0)
 I ^%ZOSF("OS")["OpenM",(($P(HLPARM4,U,3)="M"&($$OS^%ZOSV'["VMS"))!($P(HLPARM4,U,3)="S")) D
"RTN","HLCSLNCH",116,0)
 . ;pass task number to stop listener
"RTN","HLCSLNCH",117,0)
 . S:$P(HLPARM0,U,12) X=$$ASKSTOP^%ZTLOAD(+$P(HLPARM0,U,12))
"RTN","HLCSLNCH",118,0)
 . D CALL^%ZISTCP($P(HLPARM4,U),$P(HLPARM4,U,2),10)
"RTN","HLCSLNCH",119,0)
 . I POP D HOME^%ZIS U IO W !,"Unable to shutdown logical link!!!",$C(7),$C(7) Q
"RTN","HLCSLNCH",120,0)
 . U IO W "**STOP**"
"RTN","HLCSLNCH",121,0)
 . W !
"RTN","HLCSLNCH",122,0)
 . D CLOSE^%ZISTCP
"RTN","HLCSLNCH",123,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSLNCH",124,0)
 W !,"The job for the "_HLDAPP_" Lower Level Protocol will be shut down."
"RTN","HLCSLNCH",125,0)
 Q
"RTN","HLCSLNCH",126,0)
 ;
"RTN","HLCSLNCH",127,0)
STOPQ Q
"RTN","HLCSLSM")
0^54^B399167
"RTN","HLCSLSM",1,0)
HLCSLSM ;SFCIOFO/AC - HL7 LINK SUBMANAGER ;02/05/2004  07:42
"RTN","HLCSLSM",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**49,57,109**;Oct 13, 1995
"RTN","HLCSLSM",3,0)
 N % S %=0
"RTN","HLCSLSM",4,0)
EN Q:'$D(HLDP)
"RTN","HLCSLSM",5,0)
 Q:'$D(HLBGR)
"RTN","HLCSLSM",6,0)
 L +^HLCS("HLCSLSM",+HLDP):10 E  H 3 S %=%+1 G EN:%'>2 Q
"RTN","HLCSLSM",7,0)
 D @HLBGR
"RTN","HLCSLSM",8,0)
 N HLJ
"RTN","HLCSLSM",9,0)
 ;delete task number
"RTN","HLCSLSM",10,0)
 S HLJ(870,HLDP_",",11)="@"
"RTN","HLCSLSM",11,0)
 D FILE^HLDIE("","HLJ","","EN","HLCSLSM") ; HL*1.6*109
"RTN","HLCSLSM",12,0)
 L -^HLCM("HLCSLSM",+HLDP)
"RTN","HLCSLSM",13,0)
 K HLBGR,HLDP
"RTN","HLCSLSM",14,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLCSLSM",15,0)
 Q
"RTN","HLCSMON")
0^55^B52128223
"RTN","HLCSMON",1,0)
HLCSMON ;SF-DISPLAY DRIVER PROGRAM  ;07/10/2000  12:18
"RTN","HLCSMON",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**34,40,48,49,65,66,73,109**;Oct 13, 1995
"RTN","HLCSMON",3,0)
 ;
"RTN","HLCSMON",4,0)
 ;This Program drives a real-time display monitor for the HL7
"RTN","HLCSMON",5,0)
 ;Package. All the data used by this display is stored in file
"RTN","HLCSMON",6,0)
 ;# 870. Several callable entry points were broken
"RTN","HLCSMON",7,0)
 ;out of this routine and placed into HLCSMON1
"RTN","HLCSMON",8,0)
 ;
"RTN","HLCSMON",9,0)
 ;This routine has no required input parameters other than require that
"RTN","HLCSMON",10,0)
 ;U be defined, it does not instantiate any parameters either.
"RTN","HLCSMON",11,0)
 ;
"RTN","HLCSMON",12,0)
 ;
"RTN","HLCSMON",13,0)
 ;HLARY=array of all,HLARYD=array of display,HLARYO=array of old values
"RTN","HLCSMON",14,0)
 ;HLPTR1=top of display,HLPTR2=bottom of display,HLPTR3=last in HLVARY
"RTN","HLCSMON",15,0)
INIT N HLARY,HLARYD,HLARYO,HLCOFF,HLCON,HLDISP,HLPTR1,HLPTR2,HLPTR3,HLRESP
"RTN","HLCSMON",16,0)
 N HLDEV,HLERR,HLEVL,HLHDR,HLNODE,HLOCK
"RTN","HLCSMON",17,0)
 N HLPARAM,HLPROC,HLPROD,HLSEND,HLSENT,HLSITE
"RTN","HLCSMON",18,0)
 N HLI,HLREC,HLRUNCNT,HLSTAT,HLTMSTAT,HLLMSTAT,HLVIEW,HLXX,HLYY,X,Y,DX,DY
"RTN","HLCSMON",19,0)
 ;
"RTN","HLCSMON",20,0)
 D ^HLCSTERM ;Sets up variables to control display attributes
"RTN","HLCSMON",21,0)
INIT1 ;
"RTN","HLCSMON",22,0)
 ; Next 4 lines copied here from top of START by patch 73...
"RTN","HLCSMON",23,0)
 ;HLRUNCNT=number of in filers^out filers, HLDISP=display mode
"RTN","HLCSMON",24,0)
 S HLRUNCNT="-1^-1",HLPTR1=1 S:'$D(HLDISP) HLDISP="S"
"RTN","HLCSMON",25,0)
 D BUILDARY ;Build an array for display
"RTN","HLCSMON",26,0)
 QUIT:$$LOCKED(.HLOCK)  ;-> Anything locked?
"RTN","HLCSMON",27,0)
 ;
"RTN","HLCSMON",28,0)
 W HLCOFF ;Shut Cursor off
"RTN","HLCSMON",29,0)
 D HEADER^HLCSTERM ;Write header
"RTN","HLCSMON",30,0)
 D WDATA^HLCSMON1(5,17,"","","Incoming filers running => ")
"RTN","HLCSMON",31,0)
 D WDATA^HLCSMON1(5,18,"","","Outgoing filers running => ")
"RTN","HLCSMON",32,0)
 D WDATA^HLCSMON1(5,20,"","","Select a Command:")
"RTN","HLCSMON",33,0)
 D WDATA^HLCSMON1(1,21,"","","(N)EXT  (B)ACKUP  (A)LL LINKS  (S)CREENED  (V)IEWS  (Q)UIT  (?) HELP: ")
"RTN","HLCSMON",34,0)
 ;HLRUNCNT=number of in filers^out filers, HLDISP=display mode
"RTN","HLCSMON",35,0)
 S HLRUNCNT="-1^-1",HLPTR1=1 S:'$D(HLDISP) HLDISP="S"
"RTN","HLCSMON",36,0)
START ;
"RTN","HLCSMON",37,0)
 D BUILDARY ;Build an array for display
"RTN","HLCSMON",38,0)
 D DISPLAY^HLCSMON1 ;Display the array just built
"RTN","HLCSMON",39,0)
 D READ
"RTN","HLCSMON",40,0)
 ;HLRESP=user response
"RTN","HLCSMON",41,0)
 I '$L(HLRESP) G START
"RTN","HLCSMON",42,0)
 G:HLRESP="Q" EXIT
"RTN","HLCSMON",43,0)
 ;any of following commands, kill old values
"RTN","HLCSMON",44,0)
 K HLARYO,HLTMSTAT,HLLMSTAT
"RTN","HLCSMON",45,0)
 I HLRESP="?" D HELP G INIT1
"RTN","HLCSMON",46,0)
 I HLRESP="V" D VIEW G INIT1
"RTN","HLCSMON",47,0)
 I "AS"[HLRESP K HLARY,HLEVL S HLDISP=HLRESP G INIT1
"RTN","HLCSMON",48,0)
 I "NB"[HLRESP D NEXT
"RTN","HLCSMON",49,0)
 G START
"RTN","HLCSMON",50,0)
 ;
"RTN","HLCSMON",51,0)
READ ;Prompt the user for the next action
"RTN","HLCSMON",52,0)
 D WDATA^HLCSMON1(71,21,"","","",1)
"RTN","HLCSMON",53,0)
 W HLCON
"RTN","HLCSMON",54,0)
 R X#1:3
"RTN","HLCSMON",55,0)
 W HLCOFF
"RTN","HLCSMON",56,0)
 S HLRESP=$S(X="":X,"Qq^"[X:"Q","Bb"[X:"B","Nn"[X:"N","Aa"[X:"A","Vv"[X:"V",X="?":"?","Ss"[X:"S",1:"")
"RTN","HLCSMON",57,0)
 Q
"RTN","HLCSMON",58,0)
 ;
"RTN","HLCSMON",59,0)
VIEW ;select new view
"RTN","HLCSMON",60,0)
 W HLCON,!!
"RTN","HLCSMON",61,0)
 N DIC
"RTN","HLCSMON",62,0)
 S DIC="^HLCS(869.3,1,6,",DIC(0)="QEA"
"RTN","HLCSMON",63,0)
 D ^DIC Q:Y<0
"RTN","HLCSMON",64,0)
 S HLVIEW=+Y,HLDISP="V"
"RTN","HLCSMON",65,0)
 W HLCOFF
"RTN","HLCSMON",66,0)
 Q
"RTN","HLCSMON",67,0)
 ;
"RTN","HLCSMON",68,0)
NEXT ;
"RTN","HLCSMON",69,0)
 ;Next page
"RTN","HLCSMON",70,0)
 I HLRESP="N" D
"RTN","HLCSMON",71,0)
 . ;no more
"RTN","HLCSMON",72,0)
 . I HLPTR2=HLPTR3 D EOB Q
"RTN","HLCSMON",73,0)
 . S Y=HLPTR2+10,HLEVL(HLPTR1)=""
"RTN","HLCSMON",74,0)
 . ;exceed list, get last 10
"RTN","HLCSMON",75,0)
 . I Y>HLPTR3 S HLPTR2=HLPTR3,HLPTR1=HLPTR2-9 Q
"RTN","HLCSMON",76,0)
 . S HLPTR1=HLPTR2,HLPTR2=Y
"RTN","HLCSMON",77,0)
 ;
"RTN","HLCSMON",78,0)
 ;Backup a page
"RTN","HLCSMON",79,0)
 I HLRESP="B" D
"RTN","HLCSMON",80,0)
 . ;top of list
"RTN","HLCSMON",81,0)
 . I HLPTR1=1 D EOB Q
"RTN","HLCSMON",82,0)
 . I HLDISP="S" S HLPTR1=$O(HLEVL(HLPTR1),-1) Q
"RTN","HLCSMON",83,0)
 . S Y=HLPTR1-9
"RTN","HLCSMON",84,0)
 . ;can't go back 10, reset to top
"RTN","HLCSMON",85,0)
 . I Y'>0 S HLPTR1=1,HLPTR2=10 Q
"RTN","HLCSMON",86,0)
 . S HLPTR2=HLPTR1,HLPTR1=Y
"RTN","HLCSMON",87,0)
 ;
"RTN","HLCSMON",88,0)
 ;Erase what might be displayed on line 22
"RTN","HLCSMON",89,0)
 D WDATA^HLCSMON1(1,22,IOELALL,"","")
"RTN","HLCSMON",90,0)
 Q
"RTN","HLCSMON",91,0)
EOB D WDATA^HLCSMON1(5,22,IORVON,IORVOFF,"CANNOT "_$S(HLRESP="N":"ADVANCE",1:"BACKUP")_" BEYOND END OF BUFFER")
"RTN","HLCSMON",92,0)
 W $C(7) H 2
"RTN","HLCSMON",93,0)
 Q
"RTN","HLCSMON",94,0)
 ;
"RTN","HLCSMON",95,0)
BUILDARY ;
"RTN","HLCSMON",96,0)
 K HLARYD
"RTN","HLCSMON",97,0)
 ;
"RTN","HLCSMON",98,0)
 ;if view is defined, get links
"RTN","HLCSMON",99,0)
 I $G(HLVIEW) D  S HLVIEW=0,HLDISP="V"
"RTN","HLCSMON",100,0)
 . N HLTMP
"RTN","HLCSMON",101,0)
 . K HLARY,HLEVL S HLI=0
"RTN","HLCSMON",102,0)
 . F  S HLI=$O(^HLCS(869.3,1,6,HLVIEW,1,HLI)) Q:'HLI  S HLYY=+$P($G(^(HLI,0)),U,2) D
"RTN","HLCSMON",103,0)
 .. S Y=$P($G(^HLCS(870,HLI,0)),U) Q:Y=""
"RTN","HLCSMON",104,0)
 .. ;build array by DISPLAY ORDER and then by NAME
"RTN","HLCSMON",105,0)
 .. I HLYY S HLTMP(HLYY,HLI)="" Q
"RTN","HLCSMON",106,0)
 .. S HLTMP(Y,HLI)=""
"RTN","HLCSMON",107,0)
 . S (HLI,HLYY)=0
"RTN","HLCSMON",108,0)
 . ;rebuild array to put in proper order
"RTN","HLCSMON",109,0)
 . F  S HLI=$O(HLTMP(HLI)),HLXX=0 Q:HLI=""  D
"RTN","HLCSMON",110,0)
 .. F  S HLXX=$O(HLTMP(HLI,HLXX)) Q:'HLXX  S HLYY=HLYY+1,HLARY(HLYY,HLXX)=""
"RTN","HLCSMON",111,0)
 . S HLPTR3=HLYY
"RTN","HLCSMON",112,0)
 ;
"RTN","HLCSMON",113,0)
 I '$D(HLARY)  S HLYY=0,HLXX="" D
"RTN","HLCSMON",114,0)
 . ;build array in alphabetical order
"RTN","HLCSMON",115,0)
 . F  S HLXX=$O(^HLCS(870,"B",HLXX)) Q:HLXX=""  S Y=$O(^(HLXX,0)),HLYY=HLYY+1,HLARY(HLYY,Y)=""
"RTN","HLCSMON",116,0)
 . S HLPTR3=HLYY
"RTN","HLCSMON",117,0)
 ;
"RTN","HLCSMON",118,0)
 S HLI=HLPTR1,HLYY=6 ;HLYY=6TH Line of display
"RTN","HLCSMON",119,0)
 ;HLARYD(6) through HLARYD(15) with 6 through 15 also representing line
"RTN","HLCSMON",120,0)
 ;numbers on the display
"RTN","HLCSMON",121,0)
 F HLI=HLI:1 S HLXX=$O(HLARY(HLI,0)) Q:HLYY=16!'HLXX  D COPY
"RTN","HLCSMON",122,0)
 S HLPTR2=HLI-1
"RTN","HLCSMON",123,0)
 ;Set all HLARY elements not defined on this pass to null
"RTN","HLCSMON",124,0)
 F HLYY=HLYY:1:15 S HLARYD(HLYY)=""
"RTN","HLCSMON",125,0)
 Q
"RTN","HLCSMON",126,0)
COPY ;
"RTN","HLCSMON",127,0)
 Q:'$D(^HLCS(870,HLXX))
"RTN","HLCSMON",128,0)
 ;
"RTN","HLCSMON",129,0)
 ;These lock tags lock nodes in the global so that the screen is
"RTN","HLCSMON",130,0)
 ;refreshed in real-time. The lock forces the buffer to be refreshed,
"RTN","HLCSMON",131,0)
 ;so that the display is up to date.
"RTN","HLCSMON",132,0)
 ;
"RTN","HLCSMON",133,0)
 ;**109**
"RTN","HLCSMON",134,0)
 ;L +^HLCS(870,HLXX,0):0 L -^HLCS(870,HLXX,0) D CHKLOCK
"RTN","HLCSMON",135,0)
 ;
"RTN","HLCSMON",136,0)
 ; Set, even if not able to lock...
"RTN","HLCSMON",137,0)
 S Y=$G(^HLCS(870,HLXX,0))
"RTN","HLCSMON",138,0)
 ;
"RTN","HLCSMON",139,0)
 ;name^rec^proc^send^sent^device^state^error
"RTN","HLCSMON",140,0)
 S HLARYD(HLYY)=$P(Y,U)_"^^^^^"_$P(Y,U,4)_"^"_$P(Y,U,5)_"^"_$P(Y,U,19)
"RTN","HLCSMON",141,0)
 ;
"RTN","HLCSMON",142,0)
 ;**109**
"RTN","HLCSMON",143,0)
 ;L +^HLCS(870,HLXX,"IN QUEUE BACK POINTER"):0 D CHKLOCK
"RTN","HLCSMON",144,0)
 ;L -^HLCS(870,HLXX,"IN QUEUE BACK POINTER")
"RTN","HLCSMON",145,0)
 ;
"RTN","HLCSMON",146,0)
 S $P(HLARYD(HLYY),U,2)=$G(^HLCS(870,HLXX,"IN QUEUE BACK POINTER"))
"RTN","HLCSMON",147,0)
 ;
"RTN","HLCSMON",148,0)
 ;**109**
"RTN","HLCSMON",149,0)
 ;L +^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"):0 D CHKLOCK
"RTN","HLCSMON",150,0)
 ;L -^HLCS(870,HLXX,"IN QUEUE FRONT POINTER")
"RTN","HLCSMON",151,0)
 ;
"RTN","HLCSMON",152,0)
 S $P(HLARYD(HLYY),U,3)=$G(^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"))
"RTN","HLCSMON",153,0)
 ;
"RTN","HLCSMON",154,0)
 ;**109**
"RTN","HLCSMON",155,0)
 ;L +^HLCS(870,HLXX,"OUT QUEUE BACK POINTER"):0 D CHKLOCK
"RTN","HLCSMON",156,0)
 ;L -^HLCS(870,HLXX,"OUT QUEUE BACK POINTER")
"RTN","HLCSMON",157,0)
 ;
"RTN","HLCSMON",158,0)
 S $P(HLARYD(HLYY),U,4)=$G(^HLCS(870,HLXX,"OUT QUEUE BACK POINTER"))
"RTN","HLCSMON",159,0)
 ;
"RTN","HLCSMON",160,0)
 ;**109**
"RTN","HLCSMON",161,0)
 ;L +^HLCS(870,HLXX,"OUT QUEUE FRONT POINTER"):0 D CHKLOCK
"RTN","HLCSMON",162,0)
 ;L -^HLCS(870,HLXX,"OUT QUEUE FRONT POINTER")
"RTN","HLCSMON",163,0)
 ;
"RTN","HLCSMON",164,0)
 S $P(HLARYD(HLYY),U,5)=$G(^HLCS(870,HLXX,"OUT QUEUE FRONT POINTER"))
"RTN","HLCSMON",165,0)
 ;
"RTN","HLCSMON",166,0)
 S X=HLARYD(HLYY),Y=$P(X,U,2)+$P(X,U,3)+$P(X,U,4)+$P(X,U,5)
"RTN","HLCSMON",167,0)
 ;if Select and the Y=0, nothing to report
"RTN","HLCSMON",168,0)
 I 'Y,HLDISP="S" S HLARYD(HLYY)="" Q
"RTN","HLCSMON",169,0)
 S HLYY=HLYY+1
"RTN","HLCSMON",170,0)
 Q
"RTN","HLCSMON",171,0)
 ;
"RTN","HLCSMON",172,0)
CHKLOCK ; Call here immediately after trying to lock.  And, BE SURE that 
"RTN","HLCSMON",173,0)
 ; nothing might occur that would change $T after the lock attempt!!
"RTN","HLCSMON",174,0)
 ; $T,HLXX -- req
"RTN","HLCSMON",175,0)
 N NM870
"RTN","HLCSMON",176,0)
 QUIT:$T  ;-> Lock obtained...
"RTN","HLCSMON",177,0)
 S NM870=$P($G(^HLCS(870,+HLXX,0)),U)
"RTN","HLCSMON",178,0)
 S NM870=$S(NM870]"":NM870_" (IEN #"_HLXX_")",1:"IEN #"_HLXX)
"RTN","HLCSMON",179,0)
 S HLOCK(NM870)=""
"RTN","HLCSMON",180,0)
 QUIT
"RTN","HLCSMON",181,0)
 ;
"RTN","HLCSMON",182,0)
HELP ;
"RTN","HLCSMON",183,0)
 W HLCON,@IOF
"RTN","HLCSMON",184,0)
 W !,"You have the following options when monitoring the Messaging System:"
"RTN","HLCSMON",185,0)
 W !,"Enter the command letter parentheses: N,B,Q,A,S,V or ?"
"RTN","HLCSMON",186,0)
 W !!,"(N) takes you to the next page of the display of Logical Links."
"RTN","HLCSMON",187,0)
 W !!,"(B) takes you back one page."
"RTN","HLCSMON",188,0)
 W !!,"(Q) terminates the monitor."
"RTN","HLCSMON",189,0)
 W !!,"(A) provides a display of all links defined on your system."
"RTN","HLCSMON",190,0)
 W !!,"(S) displays only those links that have had message traffic."
"RTN","HLCSMON",191,0)
 W !!,"(V) prompts for a view name and displays links defined in view."
"RTN","HLCSMON",192,0)
 W !!,"    Note that (S) is the default display at startup."
"RTN","HLCSMON",193,0)
 W !!,"**PRESS <RET> TO CONTINUE**"
"RTN","HLCSMON",194,0)
 R X:DTIME
"RTN","HLCSMON",195,0)
 W @IOF
"RTN","HLCSMON",196,0)
 W !,?25,"Device Types and corresponding prefixes:"
"RTN","HLCSMON",197,0)
 W !!,?30,"PC -- Persistent TCP/IP Client"
"RTN","HLCSMON",198,0)
 W !!,?30,"NC -- Non-Persistent TCP/IP Client"
"RTN","HLCSMON",199,0)
 W !!,?30,"SS -- Single-threaded TCP/IP Server"
"RTN","HLCSMON",200,0)
 W !!,?30,"MS -- Multi-threaded TCP/IP Server"
"RTN","HLCSMON",201,0)
 W !!,?30,"SH -- Serial HLLP"
"RTN","HLCSMON",202,0)
 W !!,?30,"SX -- Serial X3.28"
"RTN","HLCSMON",203,0)
 W !!,?30,"MM -- MailMan"
"RTN","HLCSMON",204,0)
 W !!,"**PRESS <RET> TO CONTINUE**"
"RTN","HLCSMON",205,0)
 R X:DTIME
"RTN","HLCSMON",206,0)
 W HLCOFF
"RTN","HLCSMON",207,0)
 Q
"RTN","HLCSMON",208,0)
EXIT ;
"RTN","HLCSMON",209,0)
 ;Turn Cursor back on
"RTN","HLCSMON",210,0)
 W HLCON
"RTN","HLCSMON",211,0)
 D KVAR^HLCSTERM
"RTN","HLCSMON",212,0)
 Q
"RTN","HLCSMON",213,0)
 ;
"RTN","HLCSMON",214,0)
LOCKED(HLOCK) ; Anything locked?
"RTN","HLCSMON",215,0)
 ;
"RTN","HLCSMON",216,0)
 ;
"RTN","HLCSMON",217,0)
 ; Nothing locked...
"RTN","HLCSMON",218,0)
 I '$D(HLOCK) QUIT "" ;->
"RTN","HLCSMON",219,0)
 ;
"RTN","HLCSMON",220,0)
 W !!,"Editing of logical link data is occurring right now.  For this reason, some of"
"RTN","HLCSMON",221,0)
 W !,"the information on the 'System Link Monitor' report might not be accurate for"
"RTN","HLCSMON",222,0)
 W !,"the following node(s)..."
"RTN","HLCSMON",223,0)
 W !
"RTN","HLCSMON",224,0)
 ;
"RTN","HLCSMON",225,0)
 S HLOCK=""
"RTN","HLCSMON",226,0)
 F  S HLOCK=$O(HLOCK(HLOCK)) Q:HLOCK']""  D
"RTN","HLCSMON",227,0)
 .  W !,?5,HLOCK
"RTN","HLCSMON",228,0)
 ;
"RTN","HLCSMON",229,0)
 S ACTION=$$BTE("Press RETURN to print report or '^' to exit... ",1)
"RTN","HLCSMON",230,0)
 ;
"RTN","HLCSMON",231,0)
 QUIT $S(ACTION=1:1,1:"")
"RTN","HLCSMON",232,0)
 ;
"RTN","HLCSMON",233,0)
BTE(PMT,FF) ; 
"RTN","HLCSMON",234,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLCSMON",235,0)
 F X=1:1:$G(FF) W !
"RTN","HLCSMON",236,0)
 S DIR(0)="EA",DIR("A")=PMT
"RTN","HLCSMON",237,0)
 D ^DIR
"RTN","HLCSMON",238,0)
 QUIT $S(Y=1:"",1:1)
"RTN","HLCSMON",239,0)
 ;
"RTN","HLCSMON1")
0^25^B8085567
"RTN","HLCSMON1",1,0)
HLCSMON1 ;SF-Utilities for Driver Program  ;02/04/2004  10:25
"RTN","HLCSMON1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**15,40,49,65,109**;Oct 13, 1995
"RTN","HLCSMON1",3,0)
 ;
"RTN","HLCSMON1",4,0)
 ;This routine contains several entry points called from HLCSMON
"RTN","HLCSMON1",5,0)
 ;no input parameters are required. All variables used which are
"RTN","HLCSMON1",6,0)
 ;not newed here are newed in HLCSMON
"RTN","HLCSMON1",7,0)
 ;
"RTN","HLCSMON1",8,0)
DISPLAY ;display link info
"RTN","HLCSMON1",9,0)
 ;turn of line wrap
"RTN","HLCSMON1",10,0)
 S HLXX=0,X=0 X ^%ZOSF("RM")
"RTN","HLCSMON1",11,0)
 F  S HLXX=$O(HLARYD(HLXX)) Q:(HLXX'>0)  D WLINE(HLXX)
"RTN","HLCSMON1",12,0)
 ;DISPLAY INCOMING FILER STATUS
"RTN","HLCSMON1",13,0)
 S HLXX=$$CNTFLR^HLCSUTL2("IN")
"RTN","HLCSMON1",14,0)
 ;ONLY UPDATE SCREEN IF COUNT HAS CHANGED
"RTN","HLCSMON1",15,0)
 I (HLXX'=+HLRUNCNT) D
"RTN","HLCSMON1",16,0)
 .D WDATA(5,17,"","",$J(" ",31)),WDATA^HLCSMON1(5,17,"","","Incoming filers running => ",35)
"RTN","HLCSMON1",17,0)
 .I (HLXX) D WDATA(32,17,"","",HLXX)
"RTN","HLCSMON1",18,0)
 .I ('HLXX) D WDATA(32,17,IOINHI,IOINORM,"Zero")
"RTN","HLCSMON1",19,0)
 .S $P(HLRUNCNT,"^",1)=HLXX
"RTN","HLCSMON1",20,0)
 ;DISPLAY OUTGOING FILER STATUS
"RTN","HLCSMON1",21,0)
 S HLXX=$$CNTFLR^HLCSUTL2("OUT")
"RTN","HLCSMON1",22,0)
 ;ONLY UPDATE SCREEN IF COUNT HAS CHANGED
"RTN","HLCSMON1",23,0)
 I (HLXX'=+$P(HLRUNCNT,"^",2)) D
"RTN","HLCSMON1",24,0)
 .D WDATA(5,18,"","",$J(" ",31)),WDATA^HLCSMON1(5,18,"","","Outgoing filers running => ",35)
"RTN","HLCSMON1",25,0)
 .I (HLXX) D WDATA(32,18,"","",HLXX)
"RTN","HLCSMON1",26,0)
 .I ('HLXX) D WDATA(32,18,IOINHI,IOINORM,"Zero")
"RTN","HLCSMON1",27,0)
 .S $P(HLRUNCNT,"^",2)=HLXX
"RTN","HLCSMON1",28,0)
 S X=$$TM^%ZTLOAD
"RTN","HLCSMON1",29,0)
 I X'=$G(HLTMSTAT) D
"RTN","HLCSMON1",30,0)
 .S HLTMSTAT=X
"RTN","HLCSMON1",31,0)
 .S HLXX=$S('HLTMSTAT:"***TASKMAN NOT RUNNING!!!***",1:"")
"RTN","HLCSMON1",32,0)
 .I 'HLTMSTAT D WDATA^HLCSMON1(45,17,IOELEOL_IOBON_IORVON,IOBOFF_IORVOFF,HLXX) I 1
"RTN","HLCSMON1",33,0)
 .E  D WDATA(45,17,IOELEOL,"",$J("TaskMan running ",16)) ;D WDATA(5,19,IOELALL,"","")
"RTN","HLCSMON1",34,0)
 S X=$$STAT^HLCSLM
"RTN","HLCSMON1",35,0)
 I X'=$G(HLLMSTAT) D
"RTN","HLCSMON1",36,0)
 .S HLLMSTAT=X Q:HLLMSTAT=3
"RTN","HLCSMON1",37,0)
 .S HLXX=$S('HLLMSTAT:"***LINK MANAGER NOT RUNNING!!!***",1:"")
"RTN","HLCSMON1",38,0)
 .I 'HLLMSTAT D WDATA^HLCSMON1(45,18,IOELEOL_IOBON_IORVON,IOBOFF_IORVOFF,HLXX) I 1
"RTN","HLCSMON1",39,0)
 .E  D WDATA^HLCSMON1(45,18,IOELEOL,"",$J("Link Manager running",18))
"RTN","HLCSMON1",40,0)
 ;Turn terminal line wrap back on
"RTN","HLCSMON1",41,0)
 D WDATA(45,19,IOELEOL,"",$$SLM^HLEVUTIL) ; HL*1.6*109
"RTN","HLCSMON1",42,0)
 S X=IOM X ^%ZOSF("RM")
"RTN","HLCSMON1",43,0)
 Q
"RTN","HLCSMON1",44,0)
 ;
"RTN","HLCSMON1",45,0)
WLINE(HLXX) ;write line from HLARYD=current values, HLARYO=old values
"RTN","HLCSMON1",46,0)
 ;if values haven't changed, don't do anything
"RTN","HLCSMON1",47,0)
 I HLARYD(HLXX)]"",HLARYD(HLXX)=$G(HLARYO(HLXX)) Q
"RTN","HLCSMON1",48,0)
 S HLARYO(HLXX)=HLARYD(HLXX),HLERR=$P(HLARYD(HLXX),U,8),DX=1
"RTN","HLCSMON1",49,0)
 F X=1:1:7 S @$P("HLNODE^HLREC^HLPROC^HLSEND^HLSENT^HLDEV^HLSTAT",U,X)=$E($P(HLARYD(HLXX),U,X)_"        ",1,8)
"RTN","HLCSMON1",50,0)
 ;if link is in error, write node in rev. video
"RTN","HLCSMON1",51,0)
 I HLERR]"" D WDATA(5,HLXX,IOBON_IORVON,IOBOFF_IORVOFF,HLNODE,8) S DX=14
"RTN","HLCSMON1",52,0)
 ;Turn off terminal line wrap & inform O/S where cursor is located
"RTN","HLCSMON1",53,0)
 S DY=HLXX X IOXY,^%ZOSF("XY")
"RTN","HLCSMON1",54,0)
 W:HLERR="" ?5,HLNODE
"RTN","HLCSMON1",55,0)
 W ?16,HLREC,?26,HLPROC,?37,HLSEND,?47,HLSENT,?58,HLDEV,?64,HLSTAT
"RTN","HLCSMON1",56,0)
 Q
"RTN","HLCSMON1",57,0)
 ;
"RTN","HLCSMON1",58,0)
WDATA(DX,DY,IO1,IO2,HLDATA,HLENGTH) ;
"RTN","HLCSMON1",59,0)
 ;
"RTN","HLCSMON1",60,0)
 ;First erase the data block then write to it. Attributes are 
"RTN","HLCSMON1",61,0)
 ;contained in IO1 & IO2
"RTN","HLCSMON1",62,0)
 ;
"RTN","HLCSMON1",63,0)
 N X S X=0 X ^%ZOSF("RM") X ^%ZOSF("XY")
"RTN","HLCSMON1",64,0)
 ;Turn off terminal line wrap & inform O/S where cursor is located
"RTN","HLCSMON1",65,0)
 I '$D(HLENGTH) S HLENGTH=$L(HLDATA)
"RTN","HLCSMON1",66,0)
 X IOXY W IOSC,$E($J(" ",79),1,HLENGTH),IORC W IO1,$E(HLDATA,1,HLENGTH),IO2
"RTN","HLCSMON1",67,0)
 S X=IOM X ^%ZOSF("RM")
"RTN","HLCSMON1",68,0)
 ;Turn terminal line wrap back on
"RTN","HLCSMON1",69,0)
 Q
"RTN","HLCSREP")
0^56^B2010073
"RTN","HLCSREP",1,0)
HLCSREP ;ALB/MFK - HL7 QUEUE MANAGEMENT - 10/4/94 1pm
"RTN","HLCSREP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLCSREP",3,0)
REPMSG ;Duplicate messages on a queue
"RTN","HLCSREP",4,0)
 ; INPUT:  MSG   - Array which contains the queue and the
"RTN","HLCSREP",5,0)
 ;                 message numbers for msgs to be re-queued
"RTN","HLCSREP",6,0)
 ;                 MSG(QUEUE,NUMBER)
"RTN","HLCSREP",7,0)
 ; OUTPUT: NONE
"RTN","HLCSREP",8,0)
 N DIC,LLE,X,Y,DA,ERROR,FROMID,MSGID
"RTN","HLCSREP",9,0)
 N TOID,ENTRY,LLE
"RTN","HLCSREP",10,0)
 Q:('$D(MSG))
"RTN","HLCSREP",11,0)
 ;  create new entries
"RTN","HLCSREP",12,0)
 S (LLE,ERROR)=""
"RTN","HLCSREP",13,0)
 F  S LLE=$O(MSG(LLE)) Q:(LLE="")!(ERROR)  D
"RTN","HLCSREP",14,0)
 .S ENTRY=""
"RTN","HLCSREP",15,0)
 .F  S ENTRY=$O(MSG(LLE,ENTRY)) Q:(ENTRY="")!(ERROR)  D
"RTN","HLCSREP",16,0)
 ..S MSGID=$$ENQUEUE^HLCSQUE(LLE,"OUT")
"RTN","HLCSREP",17,0)
 ..I +MSGID'>0 S ERROR=1 Q
"RTN","HLCSREP",18,0)
 ..S TOID=$P(MSGID,"^",2)
"RTN","HLCSREP",19,0)
 ..M ^HLCS(870,LLE,2,TOID)=^HLCS(870,LLE,2,ENTRY)
"RTN","HLCSREP",20,0)
 ..;  Change .01 of new record to be IEN
"RTN","HLCSREP",21,0)
 ..S $P(^HLCS(870,LLE,2,TOID,0),"^",1)=TOID
"RTN","HLCSREP",22,0)
 ..S $P(^HLCS(870,LLE,2,TOID,0),"^",2)="P"
"RTN","HLCSREP",23,0)
EXIT ;
"RTN","HLCSREP",24,0)
 Q
"RTN","HLCSREP",25,0)
 ;
"RTN","HLCSREP",26,0)
ENQUE(LINK,DIR,IEN773) ;
"RTN","HLCSREP",27,0)
 ;This routine will place the message=IEN773 on the "AC" xref of file 773.
"RTN","HLCSREP",28,0)
 ;Input:
"RTN","HLCSREP",29,0)
 ;  DIR = "I" or "O", denoting the direction that the message is going in
"RTN","HLCSREP",30,0)
 ;  LINK = the ien of the logical link
"RTN","HLCSREP",31,0)
 ;  IEN773 = ien of the message in file 773
"RTN","HLCSREP",32,0)
 ;
"RTN","HLCSREP",33,0)
 Q:'$G(LINK)
"RTN","HLCSREP",34,0)
 I DIR'="I",DIR'="O" Q
"RTN","HLCSREP",35,0)
 Q:'$G(IEN773)
"RTN","HLCSREP",36,0)
 S ^HLMA("AC",DIR,LINK,IEN773)=""
"RTN","HLCSREP",37,0)
 S $P(^HLMA(+IEN773,0),U,17)=+LINK ; HL*1.6*109 - lja
"RTN","HLCSREP",38,0)
 I DIR="O" D LLCNT^HLCSTCP(LINK,3)
"RTN","HLCSREP",39,0)
 Q
"RTN","HLCSREP",40,0)
 ;
"RTN","HLCSREP",41,0)
DEQUE(LINK,DIR,IEN773) ;
"RTN","HLCSREP",42,0)
 ;This routine will remove the message=IEN773 on the "AC" xref of file 773.
"RTN","HLCSREP",43,0)
 ;Input:
"RTN","HLCSREP",44,0)
 ;  DIR = "I" or "O", denoting the direction that the message is going in
"RTN","HLCSREP",45,0)
 ;  LINK = the ien of the logical link
"RTN","HLCSREP",46,0)
 ;  IEN773 = ien of the message in file 773
"RTN","HLCSREP",47,0)
 ;
"RTN","HLCSREP",48,0)
 Q:'$G(LINK)
"RTN","HLCSREP",49,0)
 I DIR'="I",DIR'="O" Q
"RTN","HLCSREP",50,0)
 Q:'$G(IEN773)
"RTN","HLCSREP",51,0)
 K ^HLMA("AC",DIR,LINK,IEN773)
"RTN","HLCSREP",52,0)
 Q
"RTN","HLCSTCP")
0^57^B32053075
"RTN","HLCSTCP",1,0)
HLCSTCP ;SFIRMFO/TNV-ALB/JFP,PKE - (TCP/IP) MLLP ;12/31/2003  18:03
"RTN","HLCSTCP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,49,57,58,64,84,109**;Oct 13, 1995
"RTN","HLCSTCP",3,0)
 ;
"RTN","HLCSTCP",4,0)
 ; This is an implementation of the HL7 Minimal Lower Layer Protocol
"RTN","HLCSTCP",5,0)
 ;
"RTN","HLCSTCP",6,0)
 ;taskman entry/startup option, HLDP defined in menu entry,
"RTN","HLCSTCP",7,0)
 Q:'$D(HLDP)
"RTN","HLCSTCP",8,0)
 N HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL
"RTN","HLCSTCP",9,0)
 ;HLCSOUT= 1-error
"RTN","HLCSTCP",10,0)
 I '$$INIT D EXITS("Init Error") Q
"RTN","HLCSTCP",11,0)
 ; Start the client
"RTN","HLCSTCP",12,0)
 I $G(HLTCPCS)="C" D  Q
"RTN","HLCSTCP",13,0)
 . ; identify process for ^%SY
"RTN","HLCSTCP",14,0)
 . D SETNM^%ZOSV($E("HLClnt:"_HLDP,1,15))
"RTN","HLCSTCP",15,0)
 . D ST1
"RTN","HLCSTCP",16,0)
 . F  D ^HLCSTCP2 Q:$$STOP!$G(HLCSOUT)
"RTN","HLCSTCP",17,0)
 . I $G(HLCSOUT)=1 D MON("Error") H 1 Q
"RTN","HLCSTCP",18,0)
 . I $G(HLCSOUT)=2 D EXITS("Inactive") Q
"RTN","HLCSTCP",19,0)
 . D EXITS("Shutdown")
"RTN","HLCSTCP",20,0)
 ;
"RTN","HLCSTCP",21,0)
 ; identify process for ^%SY
"RTN","HLCSTCP",22,0)
 D SETNM^%ZOSV($E("HLSrv:"_HLDP,1,15))
"RTN","HLCSTCP",23,0)
 ;HLCSFAIL=1 port failed to open
"RTN","HLCSTCP",24,0)
 S HLCSFAIL=1
"RTN","HLCSTCP",25,0)
 ;single threaded listener
"RTN","HLCSTCP",26,0)
 I $G(HLTCPCS)="S" D  Q
"RTN","HLCSTCP",27,0)
 . D ST1,MON("Listen"),LISTEN^%ZISTCP(HLTCPORT,"SERVER^HLCSTCP("""_HLDP_""")")
"RTN","HLCSTCP",28,0)
 . ;couldn't open listener port
"RTN","HLCSTCP",29,0)
 . I HLCSFAIL D EXITS("Openfail") Q
"RTN","HLCSTCP",30,0)
 ;
"RTN","HLCSTCP",31,0)
 ;multi-threaded listener (OpenM)
"RTN","HLCSTCP",32,0)
 I $G(HLTCPCS)="M",^%ZOSF("OS")["OpenM" D  Q
"RTN","HLCSTCP",33,0)
 . D ST1,MON("Listen"),LISTEN^%ZISTCPS(HLTCPORT,"SERVERS^HLCSTCP("""_HLDP_""")")
"RTN","HLCSTCP",34,0)
 Q
"RTN","HLCSTCP",35,0)
 ;
"RTN","HLCSTCP",36,0)
SERVER(HLDP) ; single server using Taskman
"RTN","HLCSTCP",37,0)
 S HLCSFAIL=0
"RTN","HLCSTCP",38,0)
 I '$$INIT D EXITS("Init error") Q
"RTN","HLCSTCP",39,0)
 D ^HLCSTCP1
"RTN","HLCSTCP",40,0)
 I $$STOP D CLOSE^%ZISTCP,EXITS("Shutdown") S IO("C")="" Q
"RTN","HLCSTCP",41,0)
 Q:$G(HLCSOUT)=1
"RTN","HLCSTCP",42,0)
 D MON("Idle")
"RTN","HLCSTCP",43,0)
 Q
"RTN","HLCSTCP",44,0)
 ;
"RTN","HLCSTCP",45,0)
SERVERS(HLDP) ; Multi-threaded server using Taskman
"RTN","HLCSTCP",46,0)
 I '$$INIT D EXITS("Init error") Q
"RTN","HLCSTCP",47,0)
 G LISTEN
"RTN","HLCSTCP",48,0)
 ;
"RTN","HLCSTCP",49,0)
 ;multiple process servers, called from an external utility
"RTN","HLCSTCP",50,0)
MSM ;MSM entry point, called from User-Defined Services
"RTN","HLCSTCP",51,0)
 ;HLDP=ien in the HL LOWER LEVEL PROTOCOL PARAMETER file for the
"RTN","HLCSTCP",52,0)
 ;HL7 Multi-Threaded SERVER
"RTN","HLCSTCP",53,0)
 S (IO,IO(0))=$P
"RTN","HLCSTCP",54,0)
 G LISTEN
"RTN","HLCSTCP",55,0)
 ;
"RTN","HLCSTCP",56,0)
CACHEVMS(%) ;Cache'/VMS tcpip/ucx entry point, called from HLSEVEN.COM file,
"RTN","HLCSTCP",57,0)
 ;listener,  % = HLDP
"RTN","HLCSTCP",58,0)
 I $G(%)="" D ^%ZTER Q
"RTN","HLCSTCP",59,0)
 S (IO,IO(0))="SYS$NET",HLDP=%
"RTN","HLCSTCP",60,0)
 ; **Cache'/VMS specific code**
"RTN","HLCSTCP",61,0)
 O IO::5 E  D MON("Openfail") Q
"RTN","HLCSTCP",62,0)
 X "U IO:(::""-M"")" ;Packet mode like DSM
"RTN","HLCSTCP",63,0)
 D LISTEN C IO Q
"RTN","HLCSTCP",64,0)
 ;
"RTN","HLCSTCP",65,0)
EN ;vms ucx entry point, called from HLSEVEN.COM file,
"RTN","HLCSTCP",66,0)
 ;listener,  % = device^HLDP
"RTN","HLCSTCP",67,0)
 I $G(%)="" D ^%ZTER Q
"RTN","HLCSTCP",68,0)
 S (IO,IO(0))="SYS$NET",HLDP=$P(%,"^",2)
"RTN","HLCSTCP",69,0)
 ; **VMS specific code, need to share device**
"RTN","HLCSTCP",70,0)
 O IO:(TCPDEV):60 E  D MON("Openfail") Q
"RTN","HLCSTCP",71,0)
LISTEN ;
"RTN","HLCSTCP",72,0)
 N HLLSTN,HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL
"RTN","HLCSTCP",73,0)
 I '$$INIT D ^%ZTER Q
"RTN","HLCSTCP",74,0)
 ; identify process for ^%SY
"RTN","HLCSTCP",75,0)
 D SETNM^%ZOSV($E("HLSrv:"_HLDP,1,15))
"RTN","HLCSTCP",76,0)
 ;HLLSTN used to identify a listener to tag MON
"RTN","HLCSTCP",77,0)
 S HLLSTN=1
"RTN","HLCSTCP",78,0)
 ;increment job count, run server
"RTN","HLCSTCP",79,0)
 D UPDT(1),^HLCSTCP1,EXITM
"RTN","HLCSTCP",80,0)
 Q
"RTN","HLCSTCP",81,0)
 ;
"RTN","HLCSTCP",82,0)
DCOPEN(HLDP) ;open direct connect - called from HLMA2
"RTN","HLCSTCP",83,0)
 Q:'$$INIT 0
"RTN","HLCSTCP",84,0)
 Q:HLTCPADD=""!(HLTCPORT="") 0
"RTN","HLCSTCP",85,0)
 Q:'$$OPEN^HLCSTCP2 0
"RTN","HLCSTCP",86,0)
 Q 1
"RTN","HLCSTCP",87,0)
 ;
"RTN","HLCSTCP",88,0)
INIT() ; Initialize Variables
"RTN","HLCSTCP",89,0)
 ; HLDP should be set to the IEN or name of Logical Link, file 870
"RTN","HLCSTCP",90,0)
 S HLOS=$P($G(^%ZOSF("OS")),"^")
"RTN","HLCSTCP",91,0)
 N DA,DIQUIET,DR,TMP,X,Y
"RTN","HLCSTCP",92,0)
 S DIQUIET=1
"RTN","HLCSTCP",93,0)
 D DT^DICRW
"RTN","HLCSTCP",94,0)
 I 'HLDP S HLDP=$O(^HLCS(870,"B",HLDP,0)) I 'HLDP Q 0
"RTN","HLCSTCP",95,0)
 S DA=HLDP
"RTN","HLCSTCP",96,0)
 S DR="200.02;200.021;200.03;200.04;200.05;200.09;400.01;400.02;400.03;400.04;400.05"
"RTN","HLCSTCP",97,0)
 D GETS^DIQ(870,DA,DR,"IN","TMP","TMP")
"RTN","HLCSTCP",98,0)
 ;
"RTN","HLCSTCP",99,0)
 I $D(TMP("DIERR")) QUIT 0
"RTN","HLCSTCP",100,0)
 ; -- re-transmit attempts
"RTN","HLCSTCP",101,0)
 S HLDRETR=+$G(TMP(870,DA_",",200.02,"I"))
"RTN","HLCSTCP",102,0)
 ; -- exceed re-transmit action
"RTN","HLCSTCP",103,0)
 S HLRETRA=$G(TMP(870,DA_",",200.021,"I"))
"RTN","HLCSTCP",104,0)
 ; -- block size
"RTN","HLCSTCP",105,0)
 S HLDBSIZE=+$G(TMP(870,DA_",",200.03,"I"))
"RTN","HLCSTCP",106,0)
 ; -- read timeout
"RTN","HLCSTCP",107,0)
 S HLDREAD=+$G(TMP(870,DA_",",200.04,"I"))
"RTN","HLCSTCP",108,0)
 ; -- ack timeout
"RTN","HLCSTCP",109,0)
 S HLDBACK=+$G(TMP(870,DA_",",200.05,"I"))
"RTN","HLCSTCP",110,0)
 ; -- uni-directional wait
"RTN","HLCSTCP",111,0)
 S HLDWAIT=$G(TMP(870,DA_",",200.09,"I"))
"RTN","HLCSTCP",112,0)
 ; -- tcp address
"RTN","HLCSTCP",113,0)
 S HLTCPADD=$G(TMP(870,DA_",",400.01,"I"))
"RTN","HLCSTCP",114,0)
 ; -- tcp port
"RTN","HLCSTCP",115,0)
 S HLTCPORT=$G(TMP(870,DA_",",400.02,"I"))
"RTN","HLCSTCP",116,0)
 ; -- tcp/ip service type
"RTN","HLCSTCP",117,0)
 S HLTCPCS=$G(TMP(870,DA_",",400.03,"I"))
"RTN","HLCSTCP",118,0)
 ; -- link persistence
"RTN","HLCSTCP",119,0)
 S HLTCPLNK=$G(TMP(870,DA_",",400.04,"I"))
"RTN","HLCSTCP",120,0)
 ; -- retention
"RTN","HLCSTCP",121,0)
 S HLTCPRET=$G(TMP(870,DA_",",400.05,"I"))
"RTN","HLCSTCP",122,0)
 ;
"RTN","HLCSTCP",123,0)
 ; -- set defaults in case something's not set
"RTN","HLCSTCP",124,0)
 S:HLDREAD=0 HLDREAD=10
"RTN","HLCSTCP",125,0)
 S:HLDBACK=0 HLDBACK=60
"RTN","HLCSTCP",126,0)
 S:HLDBSIZE=0 HLDBSIZE=245
"RTN","HLCSTCP",127,0)
 S:HLDRETR=0 HLDRETR=5
"RTN","HLCSTCP",128,0)
 S:HLTCPRET="" X=$P($$PARAM^HLCS2,U,12),HLTCPRET=$S(X:X,1:15)
"RTN","HLCSTCP",129,0)
 ;
"RTN","HLCSTCP",130,0)
 Q 1
"RTN","HLCSTCP",131,0)
 ;
"RTN","HLCSTCP",132,0)
ST1 ;record startup in 870 for single server
"RTN","HLCSTCP",133,0)
 ;4=status 9=Time Started, 10=Time Stopped, 11=Task Number 
"RTN","HLCSTCP",134,0)
 ;14=Shutdown LLP, 3=LLP Online, 18=Gross Errors
"RTN","HLCSTCP",135,0)
 N HLJ,X
"RTN","HLCSTCP",136,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",137,0)
 S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCSTCP",138,0)
 S @X@(4)="Init",(@X@(10),@X@(18))="@",@X@(14)=0
"RTN","HLCSTCP",139,0)
 I HLTCPCS["C" S @X@(3)=$S(HLTCPLNK["Y":"PC",1:"NC")
"RTN","HLCSTCP",140,0)
 E  S @X@(3)=$S(HLTCPCS["S":"SS",HLTCPCS["M":"MS",1:"")
"RTN","HLCSTCP",141,0)
 I @X@(3)'="NC" S @X@(9)=$$NOW^XLFDT
"RTN","HLCSTCP",142,0)
 S:$G(ZTSK) @X@(11)=ZTSK
"RTN","HLCSTCP",143,0)
 D FILE^HLDIE("","HLJ","","ST1","HLCSTCP") ;HL*1.6*109
"RTN","HLCSTCP",144,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",145,0)
 Q
"RTN","HLCSTCP",146,0)
 ;
"RTN","HLCSTCP",147,0)
MON(Y) ;Display current state & check for shutdown
"RTN","HLCSTCP",148,0)
 ;don't display for multiple server
"RTN","HLCSTCP",149,0)
 Q:$G(HLLSTN)
"RTN","HLCSTCP",150,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",151,0)
 S $P(^HLCS(870,HLDP,0),U,5)=Y
"RTN","HLCSTCP",152,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",153,0)
 Q:'$D(HLTRACE)
"RTN","HLCSTCP",154,0)
 N X U IO(0)
"RTN","HLCSTCP",155,0)
 W !,"IN State: ",Y
"RTN","HLCSTCP",156,0)
 I '$$STOP D
"RTN","HLCSTCP",157,0)
 . R !,"Type Q to Quit: ",X#1:1
"RTN","HLCSTCP",158,0)
 . I $L(X),"Qq"[X S $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP",159,0)
 U IO
"RTN","HLCSTCP",160,0)
 Q
"RTN","HLCSTCP",161,0)
UPDT(Y) ;update job count for multiple servers,X=1 increment
"RTN","HLCSTCP",162,0)
 N HLJ,X
"RTN","HLCSTCP",163,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",164,0)
 S X=+$P(^HLCS(870,HLDP,0),U,5),$P(^(0),U,5)=$S(Y:X+1,1:X-1)_" server"
"RTN","HLCSTCP",165,0)
 ;if incrementing, set the Device Type field to Multi-Server
"RTN","HLCSTCP",166,0)
 I X S HLJ(870,HLDP_",",3)="MS" D FILE^HLDIE("","HLJ","","UPDT","HLCSTCP") ;HL*1.6*109
"RTN","HLCSTCP",167,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",168,0)
 Q
"RTN","HLCSTCP",169,0)
STOP() ;stop flag set
"RTN","HLCSTCP",170,0)
 N X
"RTN","HLCSTCP",171,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",172,0)
 S X=+$P(^HLCS(870,HLDP,0),U,15)
"RTN","HLCSTCP",173,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",174,0)
 Q X
"RTN","HLCSTCP",175,0)
 ;
"RTN","HLCSTCP",176,0)
LLCNT(DP,Y,Z) ;update Logical Link counters
"RTN","HLCSTCP",177,0)
 ;DP=ien of Logical Link in file 870
"RTN","HLCSTCP",178,0)
 ;Y: 1=msg rec, 2=msg proc, 3=msg to send, 4=msg sent
"RTN","HLCSTCP",179,0)
 ;Z: ""=add to counter, 1=subtract from counter
"RTN","HLCSTCP",180,0)
 Q:'$D(^HLCS(870,+$G(DP),0))!('$G(Y))
"RTN","HLCSTCP",181,0)
 N P,X
"RTN","HLCSTCP",182,0)
 S P=$S(Y<3:"IN",1:"OUT")_" QUEUE "_$S(Y#2:"BACK",1:"FRONT")_" POINTER"
"RTN","HLCSTCP",183,0)
 F  L +^HLCS(870,DP,P):2 Q:$T
"RTN","HLCSTCP",184,0)
 S X=+$G(^HLCS(870,DP,P)),^(P)=X+$S($G(Z):-1,1:1)
"RTN","HLCSTCP",185,0)
 L -^HLCS(870,DP,P)
"RTN","HLCSTCP",186,0)
 Q
"RTN","HLCSTCP",187,0)
SDFLD ; set Shutdown? field to yes
"RTN","HLCSTCP",188,0)
 Q:'$G(HLDP)
"RTN","HLCSTCP",189,0)
 N HLJ,X
"RTN","HLCSTCP",190,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",191,0)
 ;14=Shutdown LLP?
"RTN","HLCSTCP",192,0)
 S HLJ(870,HLDP_",",14)=1
"RTN","HLCSTCP",193,0)
 D FILE^HLDIE("","HLJ","","SDFLD","HLCSTCP") ;HL*1.6*109
"RTN","HLCSTCP",194,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",195,0)
 Q
"RTN","HLCSTCP",196,0)
 ;
"RTN","HLCSTCP",197,0)
EXITS(Y) ; Single service shutdown and cleans up
"RTN","HLCSTCP",198,0)
 N HLJ,X
"RTN","HLCSTCP",199,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",200,0)
 ;4=status,10=Time Stopped,9=Time Started,11=Task Number
"RTN","HLCSTCP",201,0)
 S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCSTCP",202,0)
 S @X@(4)=Y,@X@(11)="@"
"RTN","HLCSTCP",203,0)
 S:$G(HLCSOUT)'=2 @X@(10)=$$NOW^XLFDT,@X@(9)="@"
"RTN","HLCSTCP",204,0)
 D FILE^HLDIE("","HLJ","","EXITS","HLCSTCP") ; HL*1.6*109
"RTN","HLCSTCP",205,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",206,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLCSTCP",207,0)
 Q
"RTN","HLCSTCP",208,0)
 ;
"RTN","HLCSTCP",209,0)
EXITM ;Multiple service shutdown and clean up
"RTN","HLCSTCP",210,0)
 D UPDT(0)
"RTN","HLCSTCP",211,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLCSTCP",212,0)
 Q
"RTN","HLCSTCP2")
0^58^B55298525
"RTN","HLCSTCP2",1,0)
HLCSTCP2 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;11/17/2003  09:40
"RTN","HLCSTCP2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,49,57,63,64,66,67,76,77,87,109**;Oct 13,1995
"RTN","HLCSTCP2",3,0)
 ;Sender
"RTN","HLCSTCP2",4,0)
 ;Request connection, send outbound message(s) delimited by MLLP
"RTN","HLCSTCP2",5,0)
 ;Input : HLDP=Logical Link to use
"RTN","HLCSTCP2",6,0)
 ; Set up error trap
"RTN","HLCSTCP2",7,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",8,0)
 N HLMSG,HLPORT,HLRETRY,HLRETMG,HLTCPO,POP
"RTN","HLCSTCP2",9,0)
 ;HLRETRY=number of retranmission for this link,HLRETMG=alert sent
"RTN","HLCSTCP2",10,0)
 S HLTCPO=HLDP,HLMSG="",(HLRETRY,HLRETMG)=0
"RTN","HLCSTCP2",11,0)
 ;persistent conection, open connection first, HLPORT=open port
"RTN","HLCSTCP2",12,0)
 I $G(HLTCPLNK)["Y" F  Q:$$OPEN  G EXIT:$$STOP^HLCSTCP H 1
"RTN","HLCSTCP2",13,0)
 F  D QUE Q:$$STOP^HLCSTCP  D:'HLMSG  Q:$G(HLCSOUT)
"RTN","HLCSTCP2",14,0)
 . ;no messages to send
"RTN","HLCSTCP2",15,0)
 . D MON^HLCSTCP("Idle") H 3
"RTN","HLCSTCP2",16,0)
 . ;persistent connection, no retention
"RTN","HLCSTCP2",17,0)
 . Q:$G(HLTCPLNK)["Y"
"RTN","HLCSTCP2",18,0)
 . D MON^HLCSTCP("Retention")
"RTN","HLCSTCP2",19,0)
 . N % I 0
"RTN","HLCSTCP2",20,0)
 . ;if message comes in or ask to stop
"RTN","HLCSTCP2",21,0)
 . F %=1:1:HLTCPRET H 1 I $$STOP^HLCSTCP!$O(^HLMA("AC","O",HLDP,0)) Q
"RTN","HLCSTCP2",22,0)
 . E  S HLCSOUT=2 Q
"RTN","HLCSTCP2",23,0)
 . Q:$$STOP^HLCSTCP
"RTN","HLCSTCP2",24,0)
 . D MON^HLCSTCP("Idle")
"RTN","HLCSTCP2",25,0)
 ;Close port
"RTN","HLCSTCP2",26,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",27,0)
EXIT Q
"RTN","HLCSTCP2",28,0)
 ;
"RTN","HLCSTCP2",29,0)
QUE ; -- Check "OUT" queue for processing IF there is a message do it
"RTN","HLCSTCP2",30,0)
 ; and then check the link if it open or not
"RTN","HLCSTCP2",31,0)
 N HL,HLN,HLARR,HLHDR,HLI,HLJ,HLMSA,HLRESP,HLRESLT,HLRETRM,HLTCP,HLTCPI,X,Z,HLREREAD
"RTN","HLCSTCP2",32,0)
 D MON^HLCSTCP("Check out")
"RTN","HLCSTCP2",33,0)
 ;HLMSG=next msg, set at tag DONE
"RTN","HLCSTCP2",34,0)
 I 'HLMSG S HLMSG=+$O(^HLMA("AC","O",HLDP,0)),HLRETRY=0 Q:'HLMSG
"RTN","HLCSTCP2",35,0)
 ;
"RTN","HLCSTCP2",36,0)
 ;**109**
"RTN","HLCSTCP2",37,0)
 ;Temporarily lock ^HLMA to flush buffer and ensure edits are complete
"RTN","HLCSTCP2",38,0)
 ;L +^HLMA(HLMSG):1 I '$T S HLMSG=0 Q
"RTN","HLCSTCP2",39,0)
 ;L -^HLMA(HLMSG)
"RTN","HLCSTCP2",40,0)
 ;
"RTN","HLCSTCP2",41,0)
 S HLI=+$G(^HLMA(HLMSG,0)),HLJ=$O(^("MSH",0)),HLTCP=""
"RTN","HLCSTCP2",42,0)
 ;don't have message text or MSH, kill x-ref and decrement 'to send'
"RTN","HLCSTCP2",43,0)
 I 'HLI!'HLJ K ^HLMA("AC","O",HLDP,HLMSG) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",44,0)
 ;update msg status to 'being transmitted'; if cancelled decrement link and quit
"RTN","HLCSTCP2",45,0)
 I '$$CHKMSG(1.5) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",46,0)
 ;number of retransmissions for message
"RTN","HLCSTCP2",47,0)
 S HLRETRM=+$P(^HLMA(HLMSG,"P"),U,5)
"RTN","HLCSTCP2",48,0)
 ;retries exceeded, HLRETRA:action i=ignore, r=restart, s=shutdown
"RTN","HLCSTCP2",49,0)
 ;quit if restart or shutdown, link is going down
"RTN","HLCSTCP2",50,0)
 I HLRETRY>HLDRETR D  Q:"I"'[HLRETRA
"RTN","HLCSTCP2",51,0)
 . D MON^HLCSTCP("Error")
"RTN","HLCSTCP2",52,0)
 . ;only 1 alert per link up time, don't send if restart
"RTN","HLCSTCP2",53,0)
 . D:'HLRETMG&(HLRETRA'="R")
"RTN","HLCSTCP2",54,0)
 .. ;send alert
"RTN","HLCSTCP2",55,0)
 .. N XQA,XQAMSG,XQAOPT,XQAROU,XQAID,Z
"RTN","HLCSTCP2",56,0)
 .. ;get mailgroup from file 869.3
"RTN","HLCSTCP2",57,0)
 .. S HLRETMG=1,Z=$P($$PARAM^HLCS2,U,8) Q:Z=""
"RTN","HLCSTCP2",58,0)
 .. S XQA("G."_Z)="",XQAMSG=$$HTE^XLFDT($H,2)_" HL7 LL "_$P(^HLCS(870,HLDP,0),U)_" exceeded retries. LL will "_$S(HLRETRA="S":"shutdown.",HLRETRA="R":"restart.",1:"keep trying.")
"RTN","HLCSTCP2",59,0)
 .. D SETUP^XQALERT
"RTN","HLCSTCP2",60,0)
 . ;quit if action is ignore
"RTN","HLCSTCP2",61,0)
 . Q:"I"[HLRETRA
"RTN","HLCSTCP2",62,0)
 . ;this will shutdown this link
"RTN","HLCSTCP2",63,0)
 . S HLCSOUT=1
"RTN","HLCSTCP2",64,0)
 . ;action is shutdown, set shutdown flag so LM won't restart
"RTN","HLCSTCP2",65,0)
 . S:HLRETRA="S" $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP2",66,0)
 . D STATUS^HLTF0(HLMSG,4,103,"LLP Exceeded Retry Param")
"RTN","HLCSTCP2",67,0)
 I '$$OPEN Q
"RTN","HLCSTCP2",68,0)
 D MON^HLCSTCP("Send")
"RTN","HLCSTCP2",69,0)
 ; -- data passed in global array, success=1
"RTN","HLCSTCP2",70,0)
 I $$WRITE(HLMSG)<0 Q
"RTN","HLCSTCP2",71,0)
 S (HLTCP,HLTCPI)=HLMSG,HLRETRY=HLRETRY+1,HLRETRM=HLRETRM+1
"RTN","HLCSTCP2",72,0)
 ;update status to awaiting response, decrement link if cancelled
"RTN","HLCSTCP2",73,0)
 I '$$CHKMSG(1.7) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",74,0)
 ;set transmission count, get ACKTIMEOUT override
"RTN","HLCSTCP2",75,0)
 S $P(^HLMA(HLMSG,"P"),U,5)=HLRETRM I $P(^("P"),U,7) S HLN("ACKTIME")=+$P(^("P"),U,7)
"RTN","HLCSTCP2",76,0)
 ;get header of message just sent
"RTN","HLCSTCP2",77,0)
 K HLJ M HLJ=^HLMA(HLMSG,"MSH")
"RTN","HLCSTCP2",78,0)
 ;first component of sending app.
"RTN","HLCSTCP2",79,0)
 S HLN("ECH")=$$P^HLTPCK2(.HLJ,2),HLN("SAN")=$P($$P^HLTPCK2(.HLJ,3),$E(HLN("ECH")))
"RTN","HLCSTCP2",80,0)
 ;msg type, msg. id, commit ack, and app. ack parameter
"RTN","HLCSTCP2",81,0)
 S HLN("TYPE")=$$P^HLTPCK2(.HLJ,1),HLN("MID")=$$P^HLTPCK2(.HLJ,10),HLN("ACAT")=$$P^HLTPCK2(.HLJ,15),HLN("APAT")=$$P^HLTPCK2(.HLJ,16)
"RTN","HLCSTCP2",82,0)
 ;MSA segment, message is a response, can't have an a. ack.
"RTN","HLCSTCP2",83,0)
 S Z=$$MSA^HLTP3(+^HLMA(HLMSG,0)) I Z]"" S:HLN("ACAT")="" HLN("ACAT")="NE" S HLN("APAT")="NE"
"RTN","HLCSTCP2",84,0)
 ;for batch/file with commit ack, reset c. ack and a. ack variables
"RTN","HLCSTCP2",85,0)
 I "BHS,FHS"[HLN("TYPE") S Z=$E(HLJ(1,0),5),X=$$P^HLTPCK2(.HLJ,9),HLN("ACAT")=$P(X,Z,5),HLN("APAT")=$P(X,Z,6),HLN("MID")=$$P^HLTPCK2(.HLJ,11)
"RTN","HLCSTCP2",86,0)
 ;get event protocol
"RTN","HLCSTCP2",87,0)
 S HLN("EID")=+$P(^HLMA(HLMSG,0),U,8),X=$G(^ORD(101,HLN("EID"),770))
"RTN","HLCSTCP2",88,0)
 ;set link counter to msg sent
"RTN","HLCSTCP2",89,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSTCP2",90,0)
 ;commit and app. ack is never, update status to complete and hang UNI-DIRECTIONAL WAIT
"RTN","HLCSTCP2",91,0)
 I HLN("ACAT")="NE",HLN("APAT")="NE" D  Q
"RTN","HLCSTCP2",92,0)
 .D DONE(3)
"RTN","HLCSTCP2",93,0)
 .;
"RTN","HLCSTCP2",94,0)
 .;
"RTN","HLCSTCP2",95,0)
 .H $G(HLDWAIT)
"RTN","HLCSTCP2",96,0)
 ;
"RTN","HLCSTCP2",97,0)
 ;do structure is to stack error
"RTN","HLCSTCP2",98,0)
 D
"RTN","HLCSTCP2",99,0)
 . N $ETRAP,$ESTACK S $ETRAP="D RDERR^HLCSTCP2"
"RTN","HLCSTCP2",100,0)
 . ;HL*1.6*87: Read acknowledgement.  
"RTN","HLCSTCP2",101,0)
 . ;Loop to re-read from buffer when receiving incorrect ack.
"RTN","HLCSTCP2",102,0)
 . F  D  Q:'+$G(HLREREAD)
"RTN","HLCSTCP2",103,0)
 .. S HLREREAD=1
"RTN","HLCSTCP2",104,0)
 .. ;override ack timeout
"RTN","HLCSTCP2",105,0)
 .. I $G(HLN("ACKTIME")) N HLDBACK S HLDBACK=HLN("ACKTIME")
"RTN","HLCSTCP2",106,0)
 .. ;check for response, quit if no-response, msg will be resent
"RTN","HLCSTCP2",107,0)
 .. ;HLRESP=ien 773^ien 772 for response message
"RTN","HLCSTCP2",108,0)
 .. S HLRESP=$$READ^HLCSTCP1()
"RTN","HLCSTCP2",109,0)
 .. ;if no response, decrement counter and quit
"RTN","HLCSTCP2",110,0)
 .. I 'HLRESP D LLCNT^HLCSTCP(HLDP,4,1) S HLREREAD="0^No Response" Q
"RTN","HLCSTCP2",111,0)
 .. ;X 0=re-read msg, 1=commit ack, 3=app ack success, 4=error
"RTN","HLCSTCP2",112,0)
 .. S X=$$RSP^HLTP31(HLRESP,.HLN)
"RTN","HLCSTCP2",113,0)
 .. ;X=0, re-read msg. Incorrect ack (bad MSH,MSA,msg id,or sending app)
"RTN","HLCSTCP2",114,0)
 .. Q:'X 
"RTN","HLCSTCP2",115,0)
 .. ;commit ack - done
"RTN","HLCSTCP2",116,0)
 .. I X=1 D  S HLREREAD="0^Commit Ack" Q
"RTN","HLCSTCP2",117,0)
 ... ;don't need app. ack, set status to complete
"RTN","HLCSTCP2",118,0)
 ... I "NE"[HLN("APAT") D  Q
"RTN","HLCSTCP2",119,0)
 ....D DONE(3)
"RTN","HLCSTCP2",120,0)
 ....;
"RTN","HLCSTCP2",121,0)
 ... ;response is deferred, set status to awaiting ack
"RTN","HLCSTCP2",122,0)
 ... D DONE(2)
"RTN","HLCSTCP2",123,0)
 ...;
"RTN","HLCSTCP2",124,0)
 .. ;Error, HLRESLT=error number^error message from HLTP3
"RTN","HLCSTCP2",125,0)
 .. I X=4 D  Q
"RTN","HLCSTCP2",126,0)
 ... D DONE(4,+$G(HLRESLT),$P($G(HLRESLT),U,2))
"RTN","HLCSTCP2",127,0)
 ...;
"RTN","HLCSTCP2",128,0)
 ... S HLREREAD="0^Error"
"RTN","HLCSTCP2",129,0)
 .. ;app ack was successful
"RTN","HLCSTCP2",130,0)
 .. D DONE(3) S HLREREAD="0^App Ack"
"RTN","HLCSTCP2",131,0)
 ..;
"RTN","HLCSTCP2",132,0)
 Q
"RTN","HLCSTCP2",133,0)
 ;
"RTN","HLCSTCP2",134,0)
DCSEND ;direct connect
"RTN","HLCSTCP2",135,0)
 ; Set up error trap
"RTN","HLCSTCP2",136,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",137,0)
 ;override ack timeout
"RTN","HLCSTCP2",138,0)
 I $G(HLP("ACKTIME")) N HLDBACK S HLDBACK=HLP("ACKTIME")
"RTN","HLCSTCP2",139,0)
 I $$WRITE(HLMSG)<0 D:$G(HLERROR)]""  Q  ;HL*1.6*77
"RTN","HLCSTCP2",140,0)
 .  D STATUS^HLTF0(HLMSG,4,$P(HLERROR,"^"),$P(HLERROR,"^",2),1) ;HL*1.6*77
"RTN","HLCSTCP2",141,0)
 .  D LLCNT^HLCSTCP(HLDP,3,1)
"RTN","HLCSTCP2",142,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSTCP2",143,0)
 ;do structure is to stack error
"RTN","HLCSTCP2",144,0)
 D
"RTN","HLCSTCP2",145,0)
 . N $ETRAP,$ESTACK S $ETRAP="D RDERR^HLCSTCP2"
"RTN","HLCSTCP2",146,0)
 . ;HLRESP=ien 773^ien 772 for response message
"RTN","HLCSTCP2",147,0)
 . S HLRESP=$$READ^HLCSTCP1()
"RTN","HLCSTCP2",148,0)
 ;
"RTN","HLCSTCP2",149,0)
 D DONE(3):$G(HLRESP),DONE(4,108,$S($G(HLERROR)]"":$P(HLERROR,"^",2),1:"No response")):'$G(HLRESP)
"RTN","HLCSTCP2",150,0)
 I $G(HLERROR)']"" D
"RTN","HLCSTCP2",151,0)
 .D MON^HLCSTCP("Idle")
"RTN","HLCSTCP2",152,0)
 .I '$G(HLRESP) S HLERROR="108^No response"
"RTN","HLCSTCP2",153,0)
 ;Close port
"RTN","HLCSTCP2",154,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",155,0)
 Q
"RTN","HLCSTCP2",156,0)
 ;
"RTN","HLCSTCP2",157,0)
DONE(ST,ERR,ERRMSG) ;set status to complete
"RTN","HLCSTCP2",158,0)
 ;ST=status, ERR=error ien, ERRMSG=error msg
"RTN","HLCSTCP2",159,0)
 D STATUS^HLTF0(HLMSG,ST,$G(ERR),$G(ERRMSG),1)
"RTN","HLCSTCP2",160,0)
 ;
"RTN","HLCSTCP2",161,0)
 ;**109**
"RTN","HLCSTCP2",162,0)
 D DEQUE^HLCSREP(HLDP,"O",HLMSG)
"RTN","HLCSTCP2",163,0)
 ;
"RTN","HLCSTCP2",164,0)
 ;check for more msg.
"RTN","HLCSTCP2",165,0)
 I $G(HLPRIO)'="I" S HLMSG=+$O(^HLMA("AC","O",HLDP,0)),HLRETRY=0
"RTN","HLCSTCP2",166,0)
 Q
"RTN","HLCSTCP2",167,0)
 ;
"RTN","HLCSTCP2",168,0)
CHKMSG(HLI) ;check status of message and update if not cancelled
"RTN","HLCSTCP2",169,0)
 ;input: HLI=new status, HLMSG=ien of msg in 773
"RTN","HLCSTCP2",170,0)
 ;returns 1=msg was updated, 0=msg has been canceled
"RTN","HLCSTCP2",171,0)
 N X
"RTN","HLCSTCP2",172,0)
 ;
"RTN","HLCSTCP2",173,0)
 ;**109**
"RTN","HLCSTCP2",174,0)
 ;F  L +^HLMA(HLMSG,"P"):1 Q:$T  H 1
"RTN","HLCSTCP2",175,0)
 ;
"RTN","HLCSTCP2",176,0)
 ;
"RTN","HLCSTCP2",177,0)
 ; New HL*1.6*77 code starting here...
"RTN","HLCSTCP2",178,0)
 I '$D(^HLMA(HLMSG,"P")) D  Q 0
"RTN","HLCSTCP2",179,0)
 .  S HLERROR="2^Missing status field"
"RTN","HLCSTCP2",180,0)
 .  D STATUS^HLTF0(HLMSG,4,$P(HLERROR,U),$P(HLERROR,U,2),1)
"RTN","HLCSTCP2",181,0)
 .;
"RTN","HLCSTCP2",182,0)
 .;**109**
"RTN","HLCSTCP2",183,0)
 . D DEQUE^HLCSREP(HLDP,"O",HLMSG)
"RTN","HLCSTCP2",184,0)
 .;L -^HLMA(HLMSG,"P")
"RTN","HLCSTCP2",185,0)
 ;**end 109**
"RTN","HLCSTCP2",186,0)
 ;
"RTN","HLCSTCP2",187,0)
 ; End of HL*1.6*77 modifications
"RTN","HLCSTCP2",188,0)
 ;
"RTN","HLCSTCP2",189,0)
 ;get status, quit if msg was cancelled
"RTN","HLCSTCP2",190,0)
 ;
"RTN","HLCSTCP2",191,0)
 ;**109**
"RTN","HLCSTCP2",192,0)
 ;S X=+^HLMA(HLMSG,"P") I X=3 L -^HLMA(HLMSG,"P") Q 0
"RTN","HLCSTCP2",193,0)
 S X=+^HLMA(HLMSG,"P") Q:X=3 0
"RTN","HLCSTCP2",194,0)
 ;
"RTN","HLCSTCP2",195,0)
 ;update status if it is different
"RTN","HLCSTCP2",196,0)
 I $G(HLI),HLI'=X D STATUS^HLTF0(HLMSG,HLI)
"RTN","HLCSTCP2",197,0)
 ;
"RTN","HLCSTCP2",198,0)
 ;**109**
"RTN","HLCSTCP2",199,0)
 ;L -^HLMA(HLMSG,"P")
"RTN","HLCSTCP2",200,0)
 ;
"RTN","HLCSTCP2",201,0)
 Q 1
"RTN","HLCSTCP2",202,0)
 ;
"RTN","HLCSTCP2",203,0)
WRITE(HLDA) ; write message in HL7 format
"RTN","HLCSTCP2",204,0)
 ;  HLDA       - ien of message in 773
"RTN","HLCSTCP2",205,0)
 ;             - start block $C(11)
"RTN","HLCSTCP2",206,0)
 ;             - end block $C(28)
"RTN","HLCSTCP2",207,0)
 ;             - record separator $C(13)
"RTN","HLCSTCP2",208,0)
 ;Output(s): 1 - Successful
"RTN","HLCSTCP2",209,0)
 ;           -1 - Unsuccessful
"RTN","HLCSTCP2",210,0)
 ;
"RTN","HLCSTCP2",211,0)
 N HLDA2,HLAR,HLI,LINENO,X
"RTN","HLCSTCP2",212,0)
 ;set error trap, used when called from HLTP3
"RTN","HLCSTCP2",213,0)
 ;
"RTN","HLCSTCP2",214,0)
 ; New HL*1.6*77 code starts here...
"RTN","HLCSTCP2",215,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",216,0)
 I $G(^HLMA(HLDA,0))'>0 D  Q -1
"RTN","HLCSTCP2",217,0)
 .  S HLERROR="2^Message Text pointer missing"
"RTN","HLCSTCP2",218,0)
 S HLDA2=+$G(^HLMA(HLDA,0))
"RTN","HLCSTCP2",219,0)
 ; End of HL*1.6*77 modifications...
"RTN","HLCSTCP2",220,0)
 ;
"RTN","HLCSTCP2",221,0)
 Q:'$G(^HLMA(HLDA,0)) -1 ;HL*1.6*77
"RTN","HLCSTCP2",222,0)
 ; header is in ^HLMA(, message is in ^HL(772,
"RTN","HLCSTCP2",223,0)
 S LINENO=1,HLI=0,HLAR="^HLMA(HLDA,""MSH"")"
"RTN","HLCSTCP2",224,0)
 U IO
"RTN","HLCSTCP2",225,0)
 D  W $C(13) S HLAR="^HL(772,HLDA2,""IN"")",HLI=0 D
"RTN","HLCSTCP2",226,0)
 . F  S HLI=$O(@HLAR@(HLI)) Q:'HLI  S X=$G(^(HLI,0)) D
"RTN","HLCSTCP2",227,0)
 .. ;first line, need start block char.
"RTN","HLCSTCP2",228,0)
 .. S:LINENO=1 X=$C(11)_X
"RTN","HLCSTCP2",229,0)
 .. I X]"" W X,!
"RTN","HLCSTCP2",230,0)
 .. ;send CR for blank lines
"RTN","HLCSTCP2",231,0)
 .. I X="" W $C(13)
"RTN","HLCSTCP2",232,0)
 .. S LINENO=LINENO+1
"RTN","HLCSTCP2",233,0)
 ; Sends end block for this message
"RTN","HLCSTCP2",234,0)
 S X=$C(28)_$C(13)
"RTN","HLCSTCP2",235,0)
 U IO W X,!
"RTN","HLCSTCP2",236,0)
 Q 1
"RTN","HLCSTCP2",237,0)
 ;
"RTN","HLCSTCP2",238,0)
OPEN() ; -- Open TCP/IP device (Client)
"RTN","HLCSTCP2",239,0)
 ;HLPORT=port, defined only if port is open
"RTN","HLCSTCP2",240,0)
 ;HLPORTA=number of attempted opens
"RTN","HLCSTCP2",241,0)
 I $D(HLPORT) S IO=HLPORT D  Q 1
"RTN","HLCSTCP2",242,0)
 . U IO
"RTN","HLCSTCP2",243,0)
 . I HLOS["OpenM" X "U IO:(::""-M"")" ;use packet mode on Cache'
"RTN","HLCSTCP2",244,0)
 N HLDOM,HLI,HLIP,HLPORTA
"RTN","HLCSTCP2",245,0)
 G OPENA^HLCSTCP3
"RTN","HLCSTCP2",246,0)
 ;
"RTN","HLCSTCP2",247,0)
RDERR D RDERR^HLCSTCP4 Q  ; Exceeded 10,000 bytes, so split on 12/2/03-LJA
"RTN","HLCSTCP2",248,0)
ERROR D ERROR^HLCSTCP4 Q  ; Exceeded 10,000 bytes, so split on 12/2/03-LJA
"RTN","HLCSTCP2",249,0)
 ;
"RTN","HLCSTCP2",250,0)
CC(X) ;cleanup and close
"RTN","HLCSTCP2",251,0)
 D MON^HLCSTCP(X)
"RTN","HLCSTCP2",252,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",253,0)
 H 2
"RTN","HLCSTCP2",254,0)
 Q
"RTN","HLCSTCP4")
0^89^B2712680
"RTN","HLCSTCP4",1,0)
HLCSTCP4 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;11/17/2003  09:40
"RTN","HLCSTCP4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLCSTCP4",3,0)
 ;
"RTN","HLCSTCP4",4,0)
 ; RDERR & ERROR moved from HLCSTCP2 on 12/2/2003 - LJA
"RTN","HLCSTCP4",5,0)
 ;
"RTN","HLCSTCP4",6,0)
RDERR ; Error during read process, decrement counter
"RTN","HLCSTCP4",7,0)
 D LLCNT^HLCSTCP(HLDP,4,1)
"RTN","HLCSTCP4",8,0)
ERROR ; Error trap
"RTN","HLCSTCP4",9,0)
 ; OPEN ERROR-retry.
"RTN","HLCSTCP4",10,0)
 ; WRITE ERROR (SERVER DISCONNECT)-close channel, retry
"RTN","HLCSTCP4",11,0)
 ;
"RTN","HLCSTCP4",12,0)
 ;**109**
"RTN","HLCSTCP4",13,0)
 ;I $G(HLMSG) L -^HLMA(HLMSG)
"RTN","HLCSTCP4",14,0)
 ;
"RTN","HLCSTCP4",15,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLCSTCP4",16,0)
 I $$EC^%ZOSV["OPENERR"!($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D CC^HLCSTCP2("Op-err") S:$G(HLPRIO)="I" HLERROR="15^Open Related Error" D UNWIND^%ZTER Q
"RTN","HLCSTCP4",17,0)
 I $$EC^%ZOSV["WRITE" D  Q  ;HL*1.6*77 modifications start here
"RTN","HLCSTCP4",18,0)
 .  D CC^HLCSTCP2("Wr-err")
"RTN","HLCSTCP4",19,0)
 .  S:$G(HLPRIO)="I" HLERROR="108^Write Error"
"RTN","HLCSTCP4",20,0)
 .  D UNWIND^%ZTER ;HL*1.6*77 modifications end here
"RTN","HLCSTCP4",21,0)
 I $$EC^%ZOSV["READ" D CC^HLCSTCP2("Rd-err") S:$G(HLPRIO)="I" HLERROR="108^Read Error" D UNWIND^%ZTER Q
"RTN","HLCSTCP4",22,0)
 S HLCSOUT=1 D ^%ZTER,CC^HLCSTCP2("Error"),SDFLD^HLCSTCP
"RTN","HLCSTCP4",23,0)
 S:$G(HLPRIO)="I" HLERROR="9^Error"
"RTN","HLCSTCP4",24,0)
 D UNWIND^%ZTER
"RTN","HLCSTCP4",25,0)
 Q
"RTN","HLCSTCP4",26,0)
 ;
"RTN","HLDIE")
0^59^B42269584
"RTN","HLDIE",1,0)
HLDIE ;CIOFO-O/LJA - Direct 772 & 773 Sets ; 11/18/2003 11:17
"RTN","HLDIE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLDIE",3,0)
 ;
"RTN","HLDIE",4,0)
 ; Rules: if any of these rules is broken, FILE^DIE is called instead
"RTN","HLDIE",5,0)
 ;
"RTN","HLDIE",6,0)
 ;         * Can't edit files other than 772,773
"RTN","HLDIE",7,0)
 ;         * Don't pass IENS value with multiples IENs.  You can only
"RTN","HLDIE",8,0)
 ;             edit one IEN at a time!
"RTN","HLDIE",9,0)
 ;         * Only flag "S" is honored.  Flag "K" is ignored. Other
"RTN","HLDIE",10,0)
 ;             flags result in FILE^DIE being called.
"RTN","HLDIE",11,0)
 ;         * Can't edit ^HLMA(IEN,90) data.
"RTN","HLDIE",12,0)
 ;         * Can't edit ^HLMA(IEN,91) data.
"RTN","HLDIE",13,0)
 ;         * Can't edit ^HL(772,IEN,"IN") data (field #200, MESSAGE TEXT)
"RTN","HLDIE",14,0)
 ;         * No checking of data performed!  (Data format MUST be OK.)
"RTN","HLDIE",15,0)
 ;         * No locking of records in files 772 or 773. (Locks on queues.)
"RTN","HLDIE",16,0)
 ;
"RTN","HLDIE",17,0)
FILE(FLAGS,ROOT,ERR,SUB,RTN) ; FILE^DIE functional equivalent...
"RTN","HLDIE",18,0)
 ; This call has similar parameters to FILE^DIE, but changes data
"RTN","HLDIE",19,0)
 ; using hard sets.  The first two parameters of this API are the
"RTN","HLDIE",20,0)
 ; same as FILE^DIE.  So, if any file other than 772 or 773 is being
"RTN","HLDIE",21,0)
 ; edited, this API just passes on the FLAGS,ROOT,ERR parameters to
"RTN","HLDIE",22,0)
 ; FILE^DIE and quits.  If file 772 or 773 is being edited, the hard
"RTN","HLDIE",23,0)
 ; set code in HLDIE772 and HLDIE773 is called. 
"RTN","HLDIE",24,0)
 ;
"RTN","HLDIE",25,0)
 N DEBUG,FILE,HLEDITOR,LERR,IEN,X,XECMCODE
"RTN","HLDIE",26,0)
 ;
"RTN","HLDIE",27,0)
 S DT=$$NOW^XLFDT\1
"RTN","HLDIE",28,0)
 ;
"RTN","HLDIE",29,0)
 D BEGIN ; Debug call at beginning or process
"RTN","HLDIE",30,0)
 ;
"RTN","HLDIE",31,0)
 ; Check FILE, IEN, FIELDs passed, etc...
"RTN","HLDIE",32,0)
 I '$$CHECKS D  QUIT  ;->
"RTN","HLDIE",33,0)
 .
"RTN","HLDIE",34,0)
 .  S HLEDITOR="FILE^DIE"
"RTN","HLDIE",35,0)
 .
"RTN","HLDIE",36,0)
 .  ; Call FILEMAN...
"RTN","HLDIE",37,0)
 .  D FILE^DIE($G(FLAGS),$G(ROOT),$G(ERR))
"RTN","HLDIE",38,0)
 .
"RTN","HLDIE",39,0)
 .  ; Debug call made even with Fileman...
"RTN","HLDIE",40,0)
 .  D END
"RTN","HLDIE",41,0)
 ;
"RTN","HLDIE",42,0)
 S HLEDITOR="FILE^HLDIE"
"RTN","HLDIE",43,0)
 ;
"RTN","HLDIE",44,0)
 ; If this point is reached, file 772 or 773 is being edited, data
"RTN","HLDIE",45,0)
 ; in ROOT() has been checked, and data is being hard set...
"RTN","HLDIE",46,0)
 ;
"RTN","HLDIE",47,0)
 ;
"RTN","HLDIE",48,0)
 ; Make sure ERR is defined...
"RTN","HLDIE",49,0)
 I $G(ERR)']"" N HLERR S ERR="HLERR"
"RTN","HLDIE",50,0)
 ;
"RTN","HLDIE",51,0)
 ; All editing occurs in this call...
"RTN","HLDIE",52,0)
 D EDITALL(.ROOT,FILE,IEN)
"RTN","HLDIE",53,0)
 ;
"RTN","HLDIE",54,0)
 ; Store debug data if XTMP debug string set...
"RTN","HLDIE",55,0)
 D END
"RTN","HLDIE",56,0)
 ;
"RTN","HLDIE",57,0)
 ;check if ROOT needs to be retained
"RTN","HLDIE",58,0)
 I FLAGS'["S" K @ROOT,FLAGS
"RTN","HLDIE",59,0)
 ;
"RTN","HLDIE",60,0)
 Q
"RTN","HLDIE",61,0)
 ;
"RTN","HLDIE",62,0)
EDITALL(ROOT,FILE,IEN) ; Edit 772 or 773 by direct sets...
"RTN","HLDIE",63,0)
 ;
"RTN","HLDIE",64,0)
 ; FILE,IEN -- optional (parsed from ROOT())
"RTN","HLDIE",65,0)
 ;
"RTN","HLDIE",66,0)
 N ERRNO,FIELD,GBL,NODE,ROUTINE,TAG,VALUE,XRF
"RTN","HLDIE",67,0)
 ;
"RTN","HLDIE",68,0)
 S GBL=$$GBL(FILE,+IEN)
"RTN","HLDIE",69,0)
 ;
"RTN","HLDIE",70,0)
 ;check if .01="@" for deletion of record...
"RTN","HLDIE",71,0)
 I $G(@ROOT@(FILE,IEN,.01))="@" D  Q
"RTN","HLDIE",72,0)
 .I FILE=773 D DEL773^HLUOPT3(+IEN) Q
"RTN","HLDIE",73,0)
 .I FILE=772 D DEL772^HLUOPT3(+IEN)
"RTN","HLDIE",74,0)
 ;
"RTN","HLDIE",75,0)
 ; If no data in record passed in, log an error and quit...
"RTN","HLDIE",76,0)
 I '$D(@GBL) D  Q  ; Remember.  GBL contains IEN...
"RTN","HLDIE",77,0)
 .  S ERRNO=$$ERRNO(601,"The entry does not exist.",FILE,2)
"RTN","HLDIE",78,0)
 .  S @ERR@("DIERR",+ERRNO,"PARAM","IENS")=IEN_$S(IEN'[",":",",1:"")
"RTN","HLDIE",79,0)
 ;
"RTN","HLDIE",80,0)
 ;
"RTN","HLDIE",81,0)
 ; What routine holds the file-specific field/xref set code?
"RTN","HLDIE",82,0)
 S ROUTINE=$S(FILE=772:"HLDIE772",FILE=773:"HLDIE773",1:"")
"RTN","HLDIE",83,0)
 ;
"RTN","HLDIE",84,0)
 ; Load NODEs...
"RTN","HLDIE",85,0)
 D GETNODES(FILE,+IEN,.NODE)
"RTN","HLDIE",86,0)
 ;
"RTN","HLDIE",87,0)
 ; When a field is edited, the NODE(1) is changed
"RTN","HLDIE",88,0)
 ;
"RTN","HLDIE",89,0)
 ; Edit NODE(1), adding new values, and set XRF(XREF) nodes...
"RTN","HLDIE",90,0)
 S FIELD=0
"RTN","HLDIE",91,0)
 F  S FIELD=$O(@ROOT@(FILE,IEN,FIELD)) Q:FIELD'>0  D
"RTN","HLDIE",92,0)
 .  ; VALUE = value passed in by process that is to be stored in file
"RTN","HLDIE",93,0)
 .  S VALUE=$G(@ROOT@(FILE,IEN,FIELD))
"RTN","HLDIE",94,0)
 .
"RTN","HLDIE",95,0)
 .  ; If field should be deleted, VALUE will equal @...
"RTN","HLDIE",96,0)
 .  I VALUE="@" S VALUE=""
"RTN","HLDIE",97,0)
 .
"RTN","HLDIE",98,0)
 .  ; Get and check tag...
"RTN","HLDIE",99,0)
 .  S TAG="F"_(FILE-770)_$TR(FIELD,".","")_U_ROUTINE
"RTN","HLDIE",100,0)
 .  S TAG(1)=$T(@TAG) I TAG(1)']"" D  QUIT  ;->
"RTN","HLDIE",101,0)
 .  .  S ERRNO=$$ERRNO(501,"No set logic for file #"_FILE_"'s field# "_FIELD,FILE,3)
"RTN","HLDIE",102,0)
 .  .  S @ERR@("DIERR",+ERRNO,"PARAM",1)=FIELD
"RTN","HLDIE",103,0)
 .  .  S @ERR@("DIERR",+ERRNO,"PARAM","FIELD")=FIELD
"RTN","HLDIE",104,0)
 .
"RTN","HLDIE",105,0)
 .  ; Call the subroutine below that is for the specific field...
"RTN","HLDIE",106,0)
 .  ; (No editing of xrefs or global data occurs in these calls.)
"RTN","HLDIE",107,0)
 .  D @("F"_(FILE-770)_$TR(FIELD,".","")_U_ROUTINE)
"RTN","HLDIE",108,0)
 ;
"RTN","HLDIE",109,0)
 ; If no data actually changed, quit...
"RTN","HLDIE",110,0)
 QUIT:'$D(NODE("CHG"))  ;->
"RTN","HLDIE",111,0)
 ;
"RTN","HLDIE",112,0)
 ; Store changes in the global now...
"RTN","HLDIE",113,0)
 D STORE(FILE,IEN,.NODE)
"RTN","HLDIE",114,0)
 ;
"RTN","HLDIE",115,0)
 ; Set xrefs to correspond to the just-stored data...
"RTN","HLDIE",116,0)
 S XRF=""
"RTN","HLDIE",117,0)
 F  S XRF=$O(XRF(XRF)) Q:XRF']""  D
"RTN","HLDIE",118,0)
 .  D @("XRF"_XRF_U_ROUTINE)
"RTN","HLDIE",119,0)
 ;
"RTN","HLDIE",120,0)
 Q
"RTN","HLDIE",121,0)
 ;
"RTN","HLDIE",122,0)
GETNODES(FILE,IEN,NODE) ; Load pre-change data for each node in 
"RTN","HLDIE",123,0)
 ; NODE(node,0), and load node to be changed in NODE(node,1).
"RTN","HLDIE",124,0)
 ; GBL -- req
"RTN","HLDIE",125,0)
 F NODE=0,1,2,"P","S" D
"RTN","HLDIE",126,0)
 .  ; After setting, NODE(NODE,0) will equal each other.
"RTN","HLDIE",127,0)
 .  ; However, after each edited field is processed, the pieces of
"RTN","HLDIE",128,0)
 .  ; data in NODE(NODE,1) will be changed.  The pre and post nodes
"RTN","HLDIE",129,0)
 .  ; then are of comparison value.
"RTN","HLDIE",130,0)
 .  S NODE(NODE,0)=$G(@GBL@(NODE)) ; Pre-change node
"RTN","HLDIE",131,0)
 .  S NODE(NODE,1)=NODE(NODE,0) ; Node that is changed
"RTN","HLDIE",132,0)
 Q
"RTN","HLDIE",133,0)
 ;
"RTN","HLDIE",134,0)
STORE(FILE,IEN,NODE) ; Store changes in file...
"RTN","HLDIE",135,0)
 N DATA,ND
"RTN","HLDIE",136,0)
 ;
"RTN","HLDIE",137,0)
 ; Loop thru change nodes, get changed data, and store it...
"RTN","HLDIE",138,0)
 S ND=""
"RTN","HLDIE",139,0)
 F  S ND=$O(NODE("CHG",ND)) Q:ND']""  D
"RTN","HLDIE",140,0)
 .  S DATA=$G(NODE(ND,1))
"RTN","HLDIE",141,0)
 .  ; Even if no data no node, store it.  (Will be removed by purge.)
"RTN","HLDIE",142,0)
 .  I FILE=772 S ^HL(772,+IEN,ND)=DATA
"RTN","HLDIE",143,0)
 .  I FILE=773 S ^HLMA(+IEN,ND)=DATA
"RTN","HLDIE",144,0)
 ;
"RTN","HLDIE",145,0)
 QUIT
"RTN","HLDIE",146,0)
 ;
"RTN","HLDIE",147,0)
GBL(FILE,IEN) QUIT $S(FILE=772:"^HL(772,"_+IEN_")",1:"^HLMA("_+IEN_")")
"RTN","HLDIE",148,0)
 ;
"RTN","HLDIE",149,0)
CHKFLD(FILE,FIELD) ; Does passed-in field exist?
"RTN","HLDIE",150,0)
 ; Returns -- @ERR@(...) ->
"RTN","HLDIE",151,0)
 ;
"RTN","HLDIE",152,0)
 ; Quit if field exists...
"RTN","HLDIE",153,0)
 QUIT:$D(^DD(+FILE,+FIELD)) 1 ;->
"RTN","HLDIE",154,0)
 ;
"RTN","HLDIE",155,0)
 ; Field doesn't exist.  Log error...
"RTN","HLDIE",156,0)
 S ERRNO=$$ERRNO(501,"File #"_FILE_" does not contain a field "_FIELD_".",FILE,3)
"RTN","HLDIE",157,0)
 S @ERR@("DIERR",+ERRNO,"PARAM",1)=FIELD
"RTN","HLDIE",158,0)
 S @ERR@("DIERR",+ERRNO,"PARAM","FIELD")=FIELD
"RTN","HLDIE",159,0)
 ;
"RTN","HLDIE",160,0)
 Q ""
"RTN","HLDIE",161,0)
 ;
"RTN","HLDIE",162,0)
ERRNO(NUM,TXT,FILE,PNO) ; Return next ERROR number and create general data...
"RTN","HLDIE",163,0)
 N NO
"RTN","HLDIE",164,0)
 S NO=$G(@ERR@("DIERR"))+1,@ERR@("DIERR")=+NO_U_+NO
"RTN","HLDIE",165,0)
 S @ERR@("DIERR",NO)=NUM
"RTN","HLDIE",166,0)
 S @ERR@("DIERR",NO,"PARAM",0)=PNO
"RTN","HLDIE",167,0)
 S @ERR@("DIERR",NO,"PARAM","FILE")=FILE
"RTN","HLDIE",168,0)
 S @ERR@("DIERR",NO,"TEXT",1)=TXT
"RTN","HLDIE",169,0)
 S @ERR@("DIERR","E",NUM,NO)=""
"RTN","HLDIE",170,0)
 Q NO
"RTN","HLDIE",171,0)
 ;
"RTN","HLDIE",172,0)
GENLERR(ETXT) ; Store GENERAL (and fatal) error...
"RTN","HLDIE",173,0)
 ; ERR -- req
"RTN","HLDIE",174,0)
 N NO
"RTN","HLDIE",175,0)
 S NO=$G(@ERR@("DIERR"))+1,@ERR@("DIERR")=+NO_U_+NO
"RTN","HLDIE",176,0)
 S @ERR@("DIERR",NO)=999_U_ETXT ; Made up error number
"RTN","HLDIE",177,0)
 Q
"RTN","HLDIE",178,0)
 ;
"RTN","HLDIE",179,0)
CHECKS() ; Check ROOT() for file and validity of data...
"RTN","HLDIE",180,0)
 ; FLAGS, ROOT() -- req --> FILE,IEN
"RTN","HLDIE",181,0)
 N I,OK,FIELD
"RTN","HLDIE",182,0)
 ;
"RTN","HLDIE",183,0)
 ;check the file & ien
"RTN","HLDIE",184,0)
 S FILE=$O(@ROOT@(0))
"RTN","HLDIE",185,0)
 I FILE'=772,FILE'=773 D  QUIT "" ;->
"RTN","HLDIE",186,0)
 .  S IEN=$S(FILE:$O(@ROOT@(FILE,0)),1:0) ; Set for debugging
"RTN","HLDIE",187,0)
 ;
"RTN","HLDIE",188,0)
 ; ;shouldn't be more than 1 file!
"RTN","HLDIE",189,0)
 QUIT:$O(@ROOT@(FILE)) "" ;->
"RTN","HLDIE",190,0)
 ;
"RTN","HLDIE",191,0)
 ;check the ien structure, and that only ien passed...
"RTN","HLDIE",192,0)
 S IEN=$O(@ROOT@(FILE,0))
"RTN","HLDIE",193,0)
 ; Structure check...
"RTN","HLDIE",194,0)
 QUIT:$P(IEN,",")'=+IEN_"," "" ;->
"RTN","HLDIE",195,0)
 ; Is it numeric?
"RTN","HLDIE",196,0)
 QUIT:'(+IEN) "" ;->
"RTN","HLDIE",197,0)
 ; Has more than one IEN been passed?
"RTN","HLDIE",198,0)
 QUIT:($O(@ROOT@(FILE,IEN))'="") "" ;->
"RTN","HLDIE",199,0)
 ;
"RTN","HLDIE",200,0)
 ;check the flags.  Only K and S flags allowed...
"RTN","HLDIE",201,0)
 I $L(FLAGS) D  QUIT:'OK "" ;->
"RTN","HLDIE",202,0)
 .  S OK=1
"RTN","HLDIE",203,0)
 .  F I=0:1:$L(FLAGS) I $E(FLAGS,I)'="K",$E(FLAGS,I)'="S" S OK=0
"RTN","HLDIE",204,0)
 ;
"RTN","HLDIE",205,0)
 ; Check for existence of FIELD in FILE's DD & if an excluded field.
"RTN","HLDIE",206,0)
 ; (See rules for fields which cannot be updated by FILE^HLDIE.)
"RTN","HLDIE",207,0)
 S FIELD=0,OK=1
"RTN","HLDIE",208,0)
 F  S FIELD=$O(@ROOT@(FILE,IEN,FIELD)) Q:FIELD=""  D  Q:'OK
"RTN","HLDIE",209,0)
 .  I '$$CHKFLD(FILE,FIELD) S OK=0 Q
"RTN","HLDIE",210,0)
 .  I FILE=773,FIELD\1=90 S OK=0 Q
"RTN","HLDIE",211,0)
 .  I FILE=773,FIELD\1=91 S OK=0 Q
"RTN","HLDIE",212,0)
 .  I FILE=772,FIELD=200 S OK=0 Q
"RTN","HLDIE",213,0)
 ;
"RTN","HLDIE",214,0)
 ; If not OK to use FILE^HLDIE, skip any further testing...
"RTN","HLDIE",215,0)
 QUIT:'OK "" ;->
"RTN","HLDIE",216,0)
 ;
"RTN","HLDIE",217,0)
 ;                    *** WARNING ***
"RTN","HLDIE",218,0)
 ; The following check **MUST** be removed after FILE^HLDIE is working.
"RTN","HLDIE",219,0)
 ;
"RTN","HLDIE",220,0)
 ; Final check for whether FILE^HLDIE should be used...
"RTN","HLDIE",221,0)
 I $G(^XTMP("HLDIE-DEBUG","CALL"))]"" QUIT "" ;->
"RTN","HLDIE",222,0)
 ; If this node exists and follows null, FILE^DIE will be used.
"RTN","HLDIE",223,0)
 ; Otherwise, execution defaults to using FILE^HLDIE.
"RTN","HLDIE",224,0)
 ;
"RTN","HLDIE",225,0)
 Q OK
"RTN","HLDIE",226,0)
 ;
"RTN","HLDIE",227,0)
BEGIN ; Always call here before any ^HLDIE or ^DIE calls...
"RTN","HLDIE",228,0)
 D DEBUG(1)
"RTN","HLDIE",229,0)
 Q
"RTN","HLDIE",230,0)
 ;
"RTN","HLDIE",231,0)
END ; Always call here after all ^HLDIE or ^DIE actions...
"RTN","HLDIE",232,0)
 D DEBUG(2)
"RTN","HLDIE",233,0)
 Q
"RTN","HLDIE",234,0)
 ;
"RTN","HLDIE",235,0)
DEBUG(LOC) ; Debug presets and setup...
"RTN","HLDIE",236,0)
 ; Most variables created here should be left around.  These variables
"RTN","HLDIE",237,0)
 ; are newed above.
"RTN","HLDIE",238,0)
 N STORE
"RTN","HLDIE",239,0)
 ;
"RTN","HLDIE",240,0)
 S RTN=$G(RTN),SUB=$G(SUB)
"RTN","HLDIE",241,0)
 ;
"RTN","HLDIE",242,0)
 ; First-time (beginning) call setups...
"RTN","HLDIE",243,0)
 I LOC=1 D
"RTN","HLDIE",244,0)
 .  S RTN=$S(RTN]"":RTN,1:"HLDIE")_"~"_$S(RTN="HLDIE":"FILE",1:SUB)
"RTN","HLDIE",245,0)
 .  S DEBUG=$G(^XTMP("HLDIE-DEBUG","STATUS"))
"RTN","HLDIE",246,0)
 .  S XECMCODE=$P(DEBUG,U,3)
"RTN","HLDIE",247,0)
 ; DEBUG is always called at beginning (LOC=1) and end (LOC=2) or
"RTN","HLDIE",248,0)
 ; FILE^HLDIE.  So, set up variables only once, at beginning...
"RTN","HLDIE",249,0)
 ;
"RTN","HLDIE",250,0)
 ; Setup that is individual to each (1 or 2) call...
"RTN","HLDIE",251,0)
 S STORE=$P(DEBUG,U,LOC),STORE=$S(STORE=1:1,STORE=2:2,1:"")
"RTN","HLDIE",252,0)
 ; Some, All, or no data stored?
"RTN","HLDIE",253,0)
 ;
"RTN","HLDIE",254,0)
 ; If no STORE instructions, and no M code to specify STORE, quit...
"RTN","HLDIE",255,0)
 QUIT:'STORE&($G(XECMCODE)'=1)  ;->
"RTN","HLDIE",256,0)
 ;
"RTN","HLDIE",257,0)
 ; Call DEBUG to STORE data...
"RTN","HLDIE",258,0)
 D DEBUG^HLDIEDBG(RTN,LOC,STORE,XECMCODE)
"RTN","HLDIE",259,0)
 ;
"RTN","HLDIE",260,0)
 Q
"RTN","HLDIE",261,0)
 ;
"RTN","HLDIE",262,0)
EOR ;HLDIE - Direct 772 & 773 Sets ; 11/18/2003 11:17
"RTN","HLDIE772")
0^60^B29083135
"RTN","HLDIE772",1,0)
HLDIE772 ;CIOFO-O/LJA - Direct 772 & 773 Sets ; 11/18/2003 11:17
"RTN","HLDIE772",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLDIE772",3,0)
 ;
"RTN","HLDIE772",4,0)
 ;
"RTN","HLDIE772",5,0)
 ; =================================================================
"RTN","HLDIE772",6,0)
 ;
"RTN","HLDIE772",7,0)
 ; The fields beginning with F2 have a common format...
"RTN","HLDIE772",8,0)
 ;   [F]=Field,    [2]=772,    [01]=field#.01 & [2]=field#2
"RTN","HLDIE772",9,0)
 ;
"RTN","HLDIE772",10,0)
F201 ; 772 - .01 - 0;1   [B] - DATE/TIME ENTERED
"RTN","HLDIE772",11,0)
 D UPD(0,1,VALUE) ; Sets the NODE(node,1) node...
"RTN","HLDIE772",12,0)
 S XRF("B")="" ; Sets the XRF(xrf) node...
"RTN","HLDIE772",13,0)
 Q
"RTN","HLDIE772",14,0)
 ;
"RTN","HLDIE772",15,0)
F22 ; 772 - 2 - 0;2 - SERVER APPLICATION
"RTN","HLDIE772",16,0)
 D UPD(0,2,VALUE)
"RTN","HLDIE772",17,0)
 Q
"RTN","HLDIE772",18,0)
 ;
"RTN","HLDIE772",19,0)
F2202 ; 772 - 2.02 - 2;2 - FAST PURGE DT/TM
"RTN","HLDIE772",20,0)
 ; Only fire the ^HLMA(A)I xref when STATUS in 773 is changed...
"RTN","HLDIE772",21,0)
 D UPD(2,2,VALUE)
"RTN","HLDIE772",22,0)
 Q
"RTN","HLDIE772",23,0)
 ;
"RTN","HLDIE772",24,0)
F23 ; 772 - 3 - 0;3   [ae->AC,AH] - CLIENT APPLICATION
"RTN","HLDIE772",25,0)
 ;
"RTN","HLDIE772",26,0)
 ; ae->AC is in xref logic, but shouldn't be there!  So, not set.
"RTN","HLDIE772",27,0)
 ; AH xref logic is not in DD, but should be!
"RTN","HLDIE772",28,0)
 ;
"RTN","HLDIE772",29,0)
 D UPD(0,3,VALUE)
"RTN","HLDIE772",30,0)
 S XRF("AH")="",XRF("AC")=""
"RTN","HLDIE772",31,0)
 Q
"RTN","HLDIE772",32,0)
 ;
"RTN","HLDIE772",33,0)
F24 ; 772 - 4 - 0;4   [AC] - TRANSMISSION TYPE
"RTN","HLDIE772",34,0)
 ; AC is in xref logic, but shouldn't be there!  So, not set.
"RTN","HLDIE772",35,0)
 D UPD(0,4,VALUE)
"RTN","HLDIE772",36,0)
 S XRF("AC")=""
"RTN","HLDIE772",37,0)
 Q
"RTN","HLDIE772",38,0)
 ;
"RTN","HLDIE772",39,0)
F25 ; 772 - 5 - 0;5 - RELATED MAILMAN MESSAGE
"RTN","HLDIE772",40,0)
 D UPD(0,5,VALUE)
"RTN","HLDIE772",41,0)
 Q
"RTN","HLDIE772",42,0)
 ;
"RTN","HLDIE772",43,0)
F26 ; 772 - 6 - 0;6   [C,AH] - MESSAGE ID
"RTN","HLDIE772",44,0)
 D UPD(0,6,VALUE)
"RTN","HLDIE772",45,0)
 S XRF("AH")="",XRF("C")=""
"RTN","HLDIE772",46,0)
 Q
"RTN","HLDIE772",47,0)
 ;
"RTN","HLDIE772",48,0)
F27 ; 772 - 7 - 0;7 - ACKNOWLEDGMENT TO
"RTN","HLDIE772",49,0)
 D UPD(0,7,VALUE)
"RTN","HLDIE772",50,0)
 Q
"RTN","HLDIE772",51,0)
 ;
"RTN","HLDIE772",52,0)
F28 ; 772 - 8 - 0;8   [AI] - PARENT MESSAGE
"RTN","HLDIE772",53,0)
 D UPD(0,8,VALUE)
"RTN","HLDIE772",54,0)
 S XRF("AI")=""
"RTN","HLDIE772",55,0)
 Q
"RTN","HLDIE772",56,0)
 ;
"RTN","HLDIE772",57,0)
F29 ; 772 - 9 - 0;9 - PRIORITY
"RTN","HLDIE772",58,0)
 D UPD(0,9,VALUE)
"RTN","HLDIE772",59,0)
 Q
"RTN","HLDIE772",60,0)
 ;
"RTN","HLDIE772",61,0)
F210 ; 772 - 10 - 0;10 - RELATED EVENT PROTOCOL
"RTN","HLDIE772",62,0)
 D UPD(0,10,VALUE)
"RTN","HLDIE772",63,0)
 Q
"RTN","HLDIE772",64,0)
 ;
"RTN","HLDIE772",65,0)
F211 ; 772 - 11 - 0;11   [AXMITOUT1] - LOGICAL LINK
"RTN","HLDIE772",66,0)
 D UPD(0,11,VALUE)
"RTN","HLDIE772",67,0)
 S XRF("AXMIT")=""
"RTN","HLDIE772",68,0)
 Q
"RTN","HLDIE772",69,0)
 ;
"RTN","HLDIE772",70,0)
F212 ; 772 - 12 - 0;12 - SECURITY
"RTN","HLDIE772",71,0)
 D UPD(0,12,VALUE)
"RTN","HLDIE772",72,0)
 Q
"RTN","HLDIE772",73,0)
 ;
"RTN","HLDIE772",74,0)
F213 ; 772 - 13 - 1;1 - CONTINUATION POINTER
"RTN","HLDIE772",75,0)
 D UPD(1,1,VALUE)
"RTN","HLDIE772",76,0)
 Q
"RTN","HLDIE772",77,0)
 ;
"RTN","HLDIE772",78,0)
F214 ; 772 - 14 - 0;14 - MESSAGE TYPE
"RTN","HLDIE772",79,0)
 D UPD(0,14,VALUE)
"RTN","HLDIE772",80,0)
 Q
"RTN","HLDIE772",81,0)
 ;
"RTN","HLDIE772",82,0)
F215 ; 772 - 15 - 2;1 - DON'T PURGE
"RTN","HLDIE772",83,0)
 D UPD(2,1,VALUE)
"RTN","HLDIE772",84,0)
 Q
"RTN","HLDIE772",85,0)
 ;
"RTN","HLDIE772",86,0)
F216 ; 772 - 16 - 0;13 - NAMESPACE
"RTN","HLDIE772",87,0)
 D UPD(0,13,VALUE)
"RTN","HLDIE772",88,0)
 Q
"RTN","HLDIE772",89,0)
 ;
"RTN","HLDIE772",90,0)
F220 ; 772 - 20 - P;1   [AF,AXMITOUT2] - STATUS
"RTN","HLDIE772",91,0)
 D UPD("P",1,VALUE)
"RTN","HLDIE772",92,0)
 S XRF("AF")="",XRF("AXMIT")=""
"RTN","HLDIE772",93,0)
 Q
"RTN","HLDIE772",94,0)
 ;
"RTN","HLDIE772",95,0)
F221 ; 772 - 21 - P;2   [ad->AC] - DATE/TIME PROCESSED
"RTN","HLDIE772",96,0)
 ; ad->AC is in xref logic, but shouldn't be there!  So, not set.
"RTN","HLDIE772",97,0)
 D UPD("P",2,VALUE)
"RTN","HLDIE772",98,0)
 S XRF("AC")=""
"RTN","HLDIE772",99,0)
 Q
"RTN","HLDIE772",100,0)
 ;
"RTN","HLDIE772",101,0)
F222 ; 772 - 22 - P;3 - ERROR MESSAGE
"RTN","HLDIE772",102,0)
 D UPD("P",3,VALUE)
"RTN","HLDIE772",103,0)
 Q
"RTN","HLDIE772",104,0)
 ;
"RTN","HLDIE772",105,0)
F223 ; 772 - 23 - P;4 - ERROR TYPE
"RTN","HLDIE772",106,0)
 D UPD("P",4,VALUE)
"RTN","HLDIE772",107,0)
 Q
"RTN","HLDIE772",108,0)
 ;
"RTN","HLDIE772",109,0)
F226 ; 772 - 26 - P;7 - ACK TIMEOUT
"RTN","HLDIE772",110,0)
 D UPD("P",7,VALUE)
"RTN","HLDIE772",111,0)
 Q
"RTN","HLDIE772",112,0)
 ;
"RTN","HLDIE772",113,0)
F2100 ; 772 - 100 - S;1 - NO. OF CHARACTERS IN MESSAGE
"RTN","HLDIE772",114,0)
 D UPD("S",1,VALUE)
"RTN","HLDIE772",115,0)
 Q
"RTN","HLDIE772",116,0)
 ;
"RTN","HLDIE772",117,0)
F2101 ; 772 - 101 - S;2 - NO. OF EVENTS IN MESSAGE
"RTN","HLDIE772",118,0)
 D UPD("S",2,VALUE)
"RTN","HLDIE772",119,0)
 Q
"RTN","HLDIE772",120,0)
 ;
"RTN","HLDIE772",121,0)
F2102 ; 772 - 102 - S;3 - TRANSMISSION TIME
"RTN","HLDIE772",122,0)
 D UPD("S",3,VALUE)
"RTN","HLDIE772",123,0)
 Q
"RTN","HLDIE772",124,0)
 ;
"RTN","HLDIE772",125,0)
 ; =================================================================
"RTN","HLDIE772",126,0)
 ;
"RTN","HLDIE772",127,0)
 ; The XRF fields all have a common format XRF_xrf
"RTN","HLDIE772",128,0)
 ;
"RTN","HLDIE772",129,0)
XRFAC ; AC XREF kills/sets...
"RTN","HLDIE772",130,0)
 N APP2,APP3,DTPROC,SET,TTYPE
"RTN","HLDIE772",131,0)
 ;
"RTN","HLDIE772",132,0)
 ; The xref should be created ONLY if D/T PROCESSED is not present
"RTN","HLDIE772",133,0)
 ; in the new data.  The KILL logic based on the pre-change data
"RTN","HLDIE772",134,0)
 ; is always executed...
"RTN","HLDIE772",135,0)
 ;
"RTN","HLDIE772",136,0)
 ; D/T PROC'D check of new data to determine whether SET should occur...
"RTN","HLDIE772",137,0)
 S X=NODE(0,1),APP2=$P(X,U,2),APP3=$P(X,U,3),TTYPE=$P(X,U,4)
"RTN","HLDIE772",138,0)
 S DTPROC=$P(NODE("P",1),U,2)
"RTN","HLDIE772",139,0)
 S SET=0 ; Default
"RTN","HLDIE772",140,0)
 I APP3,TTYPE="O",'DTPROC S SET=1
"RTN","HLDIE772",141,0)
 ;
"RTN","HLDIE772",142,0)
 ; Do appropriate SETs and KILLs...
"RTN","HLDIE772",143,0)
 D XRFSETC(FILE,+IEN,"AC",0,4,0,3,SET)
"RTN","HLDIE772",144,0)
 ; SET controls whether new xref SET.  KILLs always occur...
"RTN","HLDIE772",145,0)
 ;
"RTN","HLDIE772",146,0)
 Q
"RTN","HLDIE772",147,0)
 ;
"RTN","HLDIE772",148,0)
XRFAF ; AF XREF kills/sets...
"RTN","HLDIE772",149,0)
 D XRFSET(FILE,+IEN,"AF","P",1)
"RTN","HLDIE772",150,0)
 Q
"RTN","HLDIE772",151,0)
 ;
"RTN","HLDIE772",152,0)
XRFAH ; AH XREF kills/sets...
"RTN","HLDIE772",153,0)
 D XRFSETC(FILE,+IEN,"AH",0,3,0,6)
"RTN","HLDIE772",154,0)
 Q
"RTN","HLDIE772",155,0)
 ;
"RTN","HLDIE772",156,0)
XRFAI ; AI XREF kills/sets...
"RTN","HLDIE772",157,0)
 D XRFSET(FILE,+IEN,"AI",0,8)
"RTN","HLDIE772",158,0)
 Q
"RTN","HLDIE772",159,0)
 ;
"RTN","HLDIE772",160,0)
XRFAXMIT ; A-XMIT-OUT XREF kills/sets...
"RTN","HLDIE772",161,0)
 N IEN870,SET,STAT,STATCODE
"RTN","HLDIE772",162,0)
 ;
"RTN","HLDIE772",163,0)
 ;
"RTN","HLDIE772",164,0)
 ; Get status IEN and CODE...
"RTN","HLDIE772",165,0)
 S STAT=+NODE("P",1),STATCODE=$P($G(^HL(771.6,+STAT,0)),U,2)
"RTN","HLDIE772",166,0)
 ;
"RTN","HLDIE772",167,0)
 ; Get logical link IEN...
"RTN","HLDIE772",168,0)
 S IEN870=$P(NODE(0,1),U,11)
"RTN","HLDIE772",169,0)
 ;
"RTN","HLDIE772",170,0)
 ; Now, determine whether SETs should occur...
"RTN","HLDIE772",171,0)
 S SET=$S(STAT>0&(IEN870>0)&(STATCODE="PT"):1,1:0)
"RTN","HLDIE772",172,0)
 ;
"RTN","HLDIE772",173,0)
 D XRFSET(FILE,+IEN,"A-XMIT-OUT",0,11,SET)
"RTN","HLDIE772",174,0)
 ;
"RTN","HLDIE772",175,0)
 Q
"RTN","HLDIE772",176,0)
 ;
"RTN","HLDIE772",177,0)
XRFB ; B XREF kills/sets...
"RTN","HLDIE772",178,0)
 D XRFSET(FILE,+IEN,"B",0,1)
"RTN","HLDIE772",179,0)
 Q
"RTN","HLDIE772",180,0)
 ;
"RTN","HLDIE772",181,0)
XRFC ; C XREF kills/sets...
"RTN","HLDIE772",182,0)
 D XRFSET(FILE,+IEN,"C",0,6)
"RTN","HLDIE772",183,0)
 Q
"RTN","HLDIE772",184,0)
 ;
"RTN","HLDIE772",185,0)
 ;
"RTN","HLDIE772",186,0)
XRFSET(FILE,IEN,XRF,ND,PCE,SET) ; Perform sets and (2 subscript xrf) kills...
"RTN","HLDIE772",187,0)
 ;
"RTN","HLDIE772",188,0)
 ; Note: change stored for evaluation into NODE("XRF")...
"RTN","HLDIE772",189,0)
 ;
"RTN","HLDIE772",190,0)
 N RUN,VAL
"RTN","HLDIE772",191,0)
 ;
"RTN","HLDIE772",192,0)
 ; Should XREF be created based on new data?
"RTN","HLDIE772",193,0)
 ; If SET not defined, it should be SET=1 (to set)...
"RTN","HLDIE772",194,0)
 S SET=$S('$D(SET):1,1:+$G(SET))
"RTN","HLDIE772",195,0)
 ;
"RTN","HLDIE772",196,0)
 ; Set KILL values based on original data before XRF set...
"RTN","HLDIE772",197,0)
 S RUN=0 ; Pre-value...
"RTN","HLDIE772",198,0)
 S VAL=$P(NODE(ND,RUN),U,+PCE) I VAL]"" D
"RTN","HLDIE772",199,0)
 .  S NODE("XRF","KILL",XRF,VAL,+IEN)=""
"RTN","HLDIE772",200,0)
 .  I FILE=772 KILL ^HL(772,XRF,VAL,+IEN)
"RTN","HLDIE772",201,0)
 .  I FILE=773 KILL ^HLMA(XRF,VAL,+IEN)
"RTN","HLDIE772",202,0)
 ;
"RTN","HLDIE772",203,0)
 ; Set SET values based on post-change data...
"RTN","HLDIE772",204,0)
 S RUN=1 ; Post-value...
"RTN","HLDIE772",205,0)
 I SET D  ; Should SETs be executed? (This is the CONDITIONAL)
"RTN","HLDIE772",206,0)
 .  S VAL=$P(NODE(ND,RUN),U,+PCE) I VAL]"" D
"RTN","HLDIE772",207,0)
 .  .  S NODE("XRF","SET",XRF,VAL,+IEN)=""
"RTN","HLDIE772",208,0)
 .  .  I FILE=772 S ^HL(772,XRF,VAL,+IEN)=""
"RTN","HLDIE772",209,0)
 .  .  I FILE=773 S ^HLMA(XRF,VAL,+IEN)=""
"RTN","HLDIE772",210,0)
 ;
"RTN","HLDIE772",211,0)
 Q
"RTN","HLDIE772",212,0)
 ;
"RTN","HLDIE772",213,0)
XRFSETC(FILE,IEN,XRF,ND1,PC1,ND2,PC2,SET) ; [C]omplex (3 subscript) XREF set/kill...
"RTN","HLDIE772",214,0)
 N RUN,VAL1,VAL2
"RTN","HLDIE772",215,0)
 ;
"RTN","HLDIE772",216,0)
 ; Note: change stored for evaluation into NODE("XRF")...
"RTN","HLDIE772",217,0)
 ;
"RTN","HLDIE772",218,0)
 ; Define SET for later...
"RTN","HLDIE772",219,0)
 S SET=$S('$D(SET):1,1:+$G(SET))
"RTN","HLDIE772",220,0)
 ;
"RTN","HLDIE772",221,0)
 ; Set KILL values based on original data before XRF set...
"RTN","HLDIE772",222,0)
 S RUN=0 ; Pre-value...
"RTN","HLDIE772",223,0)
 S VAL1=$P(NODE(ND1,RUN),U,+PC1) I VAL1]"" D
"RTN","HLDIE772",224,0)
 .  S VAL2=$P(NODE(ND2,RUN),U,+PC2) I VAL2]"" D
"RTN","HLDIE772",225,0)
 .  .  S NODE("XRF","KILL",XRF,VAL1,VAL2,+IEN)=""
"RTN","HLDIE772",226,0)
 .  .  I FILE=772 KILL ^HL(772,XRF,VAL1,VAL2,+IEN)
"RTN","HLDIE772",227,0)
 .  .  I FILE=773 KILL ^HLMA(XRF,VAL1,VAL2,+IEN)
"RTN","HLDIE772",228,0)
 ;
"RTN","HLDIE772",229,0)
 ; Set SET values based on post-change data...
"RTN","HLDIE772",230,0)
 S RUN=1 ; Pre-value...
"RTN","HLDIE772",231,0)
 I SET D
"RTN","HLDIE772",232,0)
 .  S VAL1=$P(NODE(ND1,RUN),U,+PC1) I VAL1]"" D
"RTN","HLDIE772",233,0)
 .  .  S VAL2=$P(NODE(ND2,RUN),U,+PC2) I VAL2]"" D
"RTN","HLDIE772",234,0)
 .  .  .  S NODE("XRF","SET",XRF,VAL1,VAL2,+IEN)=""
"RTN","HLDIE772",235,0)
 .  .  .  I FILE=772 S ^HL(772,XRF,VAL1,VAL2,+IEN)=""
"RTN","HLDIE772",236,0)
 .  .  .  I FILE=773 S ^HLMA(XRF,VAL1,VAL2,+IEN)=""
"RTN","HLDIE772",237,0)
 ;
"RTN","HLDIE772",238,0)
 Q
"RTN","HLDIE772",239,0)
 ;
"RTN","HLDIE772",240,0)
 ; =================================================================
"RTN","HLDIE772",241,0)
 ;
"RTN","HLDIE772",242,0)
UPD(ND,PCE,VAL) ; Update NODE(1) piece of data...
"RTN","HLDIE772",243,0)
 ;
"RTN","HLDIE772",244,0)
 ; Is the field being changed?  If not, quit...
"RTN","HLDIE772",245,0)
 QUIT:$P(NODE(ND,0),U,PCE)=VAL  ;->
"RTN","HLDIE772",246,0)
 ;
"RTN","HLDIE772",247,0)
 ; Update node...
"RTN","HLDIE772",248,0)
 S $P(NODE(ND,1),U,PCE)=VAL
"RTN","HLDIE772",249,0)
 ;
"RTN","HLDIE772",250,0)
 ; Count number pieces changed on each node...
"RTN","HLDIE772",251,0)
 S NODE("CHG",ND)=$G(NODE("CHG",ND))+1
"RTN","HLDIE772",252,0)
 S NODE("CHG",ND,PCE)=""
"RTN","HLDIE772",253,0)
 ;
"RTN","HLDIE772",254,0)
 Q
"RTN","HLDIE772",255,0)
 ;
"RTN","HLDIE772",256,0)
EOR ;HLDIE772 - Direct 772 & 773 Sets ; 11/18/2003 11:17
"RTN","HLDIE773")
0^61^B17013621
"RTN","HLDIE773",1,0)
HLDIE773 ;CIOFO-O/LJA - Direct 772 & 773 Sets ; 11/18/2003 11:17
"RTN","HLDIE773",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLDIE773",3,0)
 ;
"RTN","HLDIE773",4,0)
 ;
"RTN","HLDIE773",5,0)
F301 ; 773 - .01 - 0;1   [B] - DATE/TIME ENTERED
"RTN","HLDIE773",6,0)
 D UPD^HLDIE772(0,1,VALUE)
"RTN","HLDIE773",7,0)
 S XRF("B")=""
"RTN","HLDIE773",8,0)
 Q
"RTN","HLDIE773",9,0)
 ;
"RTN","HLDIE773",10,0)
F32 ; 773 - 2 - 0;2   [C,AH] - MESSAGE ID
"RTN","HLDIE773",11,0)
 D UPD^HLDIE772(0,2,VALUE)
"RTN","HLDIE773",12,0)
 S XRF("C")="",XRF("AH")=""
"RTN","HLDIE773",13,0)
 Q
"RTN","HLDIE773",14,0)
 ;
"RTN","HLDIE773",15,0)
F3202 ; 773 - 2.02 - 2;2 - FAST PURGE DT/TM
"RTN","HLDIE773",16,0)
 ; Only fire ^HLMA(AI) xref when STATUS is changed...
"RTN","HLDIE773",17,0)
 D UPD^HLDIE772(2,2,VALUE)
"RTN","HLDIE773",18,0)
 Q
"RTN","HLDIE773",19,0)
 ;
"RTN","HLDIE773",20,0)
F33 ; 773 - 3 - 0;3 - TRANSMISSION TYPE
"RTN","HLDIE773",21,0)
 D UPD^HLDIE772(0,3,VALUE)
"RTN","HLDIE773",22,0)
 Q
"RTN","HLDIE773",23,0)
 ;
"RTN","HLDIE773",24,0)
F34 ; 773 - 4 - 0;4 - PRIORITY
"RTN","HLDIE773",25,0)
 D UPD^HLDIE772(0,4,VALUE)
"RTN","HLDIE773",26,0)
 Q
"RTN","HLDIE773",27,0)
 ;
"RTN","HLDIE773",28,0)
F35 ; 773 - 5 - 0;5 - HEADER TYPE
"RTN","HLDIE773",29,0)
 D UPD^HLDIE772(0,5,VALUE)
"RTN","HLDIE773",30,0)
 Q
"RTN","HLDIE773",31,0)
 ;
"RTN","HLDIE773",32,0)
F36 ; 773 - 6 - 0;6   [AF] - INITIAL MESSAGE
"RTN","HLDIE773",33,0)
 D UPD^HLDIE772(0,6,VALUE)
"RTN","HLDIE773",34,0)
 S XRF("AF")=""
"RTN","HLDIE773",35,0)
 Q
"RTN","HLDIE773",36,0)
 ;
"RTN","HLDIE773",37,0)
F37 ; 773 - 7 - 0;7   [AC] - INITIAL MESSAGE
"RTN","HLDIE773",38,0)
 ; Under no circumstances should DD create AC; only by package!
"RTN","HLDIE773",39,0)
 D UPD^HLDIE772(0,7,VALUE)
"RTN","HLDIE773",40,0)
 Q
"RTN","HLDIE773",41,0)
 ;
"RTN","HLDIE773",42,0)
F38 ; 773 - 8 - 0;8 - SUBSCRIBER PROTOCOL
"RTN","HLDIE773",43,0)
 D UPD^HLDIE772(0,8,VALUE)
"RTN","HLDIE773",44,0)
 Q
"RTN","HLDIE773",45,0)
 ;
"RTN","HLDIE773",46,0)
F39 ; 773 - 9 - 0;9 - SECURITY
"RTN","HLDIE773",47,0)
 D UPD^HLDIE772(0,9,VALUE)
"RTN","HLDIE773",48,0)
 Q
"RTN","HLDIE773",49,0)
 ;
"RTN","HLDIE773",50,0)
F310 ; 773 - 10 - 2;1 - DON'T PURGE
"RTN","HLDIE773",51,0)
 D UPD^HLDIE772(2,1,VALUE)
"RTN","HLDIE773",52,0)
 Q
"RTN","HLDIE773",53,0)
 ;
"RTN","HLDIE773",54,0)
F311 ; 773 - 11 - 1;1 - CONTINUATION POINTER
"RTN","HLDIE773",55,0)
 D UPD^HLDIE772(1,1,VALUE)
"RTN","HLDIE773",56,0)
 Q
"RTN","HLDIE773",57,0)
 ;
"RTN","HLDIE773",58,0)
F312 ; 773 - 12 - 0;10 - ACKNOWLEDGEMENT TO
"RTN","HLDIE773",59,0)
 D UPD^HLDIE772(0,10,VALUE)
"RTN","HLDIE773",60,0)
 Q
"RTN","HLDIE773",61,0)
 ;
"RTN","HLDIE773",62,0)
F313 ; 773 - 13 - 0;11 - SENDING APPLICATION
"RTN","HLDIE773",63,0)
 D UPD^HLDIE772(0,11,VALUE)
"RTN","HLDIE773",64,0)
 Q
"RTN","HLDIE773",65,0)
 ;
"RTN","HLDIE773",66,0)
F314 ; 773 - 14 - 0;12   [ae->AH] - RECEIVING APPLICATION
"RTN","HLDIE773",67,0)
 D UPD^HLDIE772(0,12,VALUE)
"RTN","HLDIE773",68,0)
 S XRF("AH")=""
"RTN","HLDIE773",69,0)
 Q
"RTN","HLDIE773",70,0)
 ;
"RTN","HLDIE773",71,0)
F315 ; 773 - 15 - 0;13 - MESSAGE TYPE
"RTN","HLDIE773",72,0)
 D UPD^HLDIE772(0,13,VALUE)
"RTN","HLDIE773",73,0)
 Q
"RTN","HLDIE773",74,0)
 ;
"RTN","HLDIE773",75,0)
F316 ; 773 - 16 - 0;14 - EVENT TYPE
"RTN","HLDIE773",76,0)
 D UPD^HLDIE772(0,14,VALUE)
"RTN","HLDIE773",77,0)
 Q
"RTN","HLDIE773",78,0)
 ;
"RTN","HLDIE773",79,0)
F320 ; 773 - 20 - P;1   [AG,AI(index)] - STATUS
"RTN","HLDIE773",80,0)
 N LINK,WAY
"RTN","HLDIE773",81,0)
 ;
"RTN","HLDIE773",82,0)
 D UPD^HLDIE772("P",1,VALUE)
"RTN","HLDIE773",83,0)
 S XRF("AG")="",XRF("AI")=""
"RTN","HLDIE773",84,0)
 ;
"RTN","HLDIE773",85,0)
 ; Quit if status isn't being set to SUCCESSFULLY COMPLETED...
"RTN","HLDIE773",86,0)
 QUIT:VALUE'=3  ;->
"RTN","HLDIE773",87,0)
 ;
"RTN","HLDIE773",88,0)
 ; Get AC's logical link IEN from new field...
"RTN","HLDIE773",89,0)
 S WAY=$P($G(NODE(0,0)),U,3) QUIT:WAY']""  ;->
"RTN","HLDIE773",90,0)
 S LINK=$P($G(NODE(0,0)),U,17) QUIT:LINK'>0  ;->
"RTN","HLDIE773",91,0)
 QUIT:$G(IEN)'>0  ;->
"RTN","HLDIE773",92,0)
 ;
"RTN","HLDIE773",93,0)
 KILL ^HLMA("AC",WAY,LINK,IEN)
"RTN","HLDIE773",94,0)
 ;
"RTN","HLDIE773",95,0)
 Q
"RTN","HLDIE773",96,0)
 ;
"RTN","HLDIE773",97,0)
F321 ; 773 - 21 - P;2 - STATUS UPDATE DATE/TIME
"RTN","HLDIE773",98,0)
 D UPD^HLDIE772("P",2,VALUE)
"RTN","HLDIE773",99,0)
 Q
"RTN","HLDIE773",100,0)
 ;
"RTN","HLDIE773",101,0)
F322 ; 773 - 22 - P;3 - ERROR MESSAGE
"RTN","HLDIE773",102,0)
 D UPD^HLDIE772("P",3,VALUE)
"RTN","HLDIE773",103,0)
 Q
"RTN","HLDIE773",104,0)
 ;
"RTN","HLDIE773",105,0)
F323 ; 773 - 23 - P;4 - ERROR TYPE
"RTN","HLDIE773",106,0)
 D UPD^HLDIE772("P",4,VALUE)
"RTN","HLDIE773",107,0)
 Q
"RTN","HLDIE773",108,0)
 ;
"RTN","HLDIE773",109,0)
F324 ; 773 - 24 - P;5 - TRANSMISSION ATTEMPTS
"RTN","HLDIE773",110,0)
 D UPD^HLDIE772("P",5,VALUE)
"RTN","HLDIE773",111,0)
 Q
"RTN","HLDIE773",112,0)
 ;
"RTN","HLDIE773",113,0)
F325 ; 773 - 25 - P;6 - OPEN ATTEMPTS
"RTN","HLDIE773",114,0)
 D UPD^HLDIE772("P",6,VALUE)
"RTN","HLDIE773",115,0)
 Q
"RTN","HLDIE773",116,0)
 ;
"RTN","HLDIE773",117,0)
F326 ; 773 - 26 - P;7 - ACK TIMEOUT
"RTN","HLDIE773",118,0)
 D UPD^HLDIE772("P",7,VALUE)
"RTN","HLDIE773",119,0)
 Q
"RTN","HLDIE773",120,0)
 ;
"RTN","HLDIE773",121,0)
F3100 ; 773 - 100 - S;1   [AD] - DATE/TIME PROCESSED
"RTN","HLDIE773",122,0)
 ; Only fire ^HLMA(AI) xref when STATUS is changed...
"RTN","HLDIE773",123,0)
 D UPD^HLDIE772("S",1,VALUE)
"RTN","HLDIE773",124,0)
 S XRF("AD")=""
"RTN","HLDIE773",125,0)
 Q
"RTN","HLDIE773",126,0)
 ;
"RTN","HLDIE773",127,0)
F3200 ; 773 - 200 - MSH - MSH
"RTN","HLDIE773",128,0)
 ; VALUE is set in EDITALL^HLDIE to the name of the local array
"RTN","HLDIE773",129,0)
 ; holding the MSH segment.  Use it...
"RTN","HLDIE773",130,0)
 N NO,TXT
"RTN","HLDIE773",131,0)
 ;
"RTN","HLDIE773",132,0)
 ; Set MSH itself into global...
"RTN","HLDIE773",133,0)
 S NO=0,NO(1)=""
"RTN","HLDIE773",134,0)
 F  S NO=$O(@VALUE@(NO)) Q:NO'>0  D
"RTN","HLDIE773",135,0)
 .  S TXT=$G(@VALUE@(NO)) QUIT:TXT']""  ;->
"RTN","HLDIE773",136,0)
 .  S ^HLMA(+IEN,"MSH",NO,0)=TXT
"RTN","HLDIE773",137,0)
 .  S NO(1)=NO
"RTN","HLDIE773",138,0)
 ;
"RTN","HLDIE773",139,0)
 ; Add MSH header...
"RTN","HLDIE773",140,0)
 S ^HLMA(+IEN,"MSH",0)="^773.01^"_NO(1)_"^"_NO(1)
"RTN","HLDIE773",141,0)
 ;
"RTN","HLDIE773",142,0)
 Q
"RTN","HLDIE773",143,0)
 ;
"RTN","HLDIE773",144,0)
 ; =================================================================
"RTN","HLDIE773",145,0)
 ;
"RTN","HLDIE773",146,0)
XRFAC ; AC XRF kills/sets...
"RTN","HLDIE773",147,0)
 ; Under no circumstances should DD create AC; only by package!
"RTN","HLDIE773",148,0)
 Q
"RTN","HLDIE773",149,0)
 ;
"RTN","HLDIE773",150,0)
XRFAD ; AD XRF kills/sets...
"RTN","HLDIE773",151,0)
 D XRFSET^HLDIE772(FILE,+IEN,"AD","S",1)
"RTN","HLDIE773",152,0)
 Q
"RTN","HLDIE773",153,0)
 ;
"RTN","HLDIE773",154,0)
XRFAF ; AF XRF kills/sets...
"RTN","HLDIE773",155,0)
 D XRFSET^HLDIE772(FILE,+IEN,"AF",0,6)
"RTN","HLDIE773",156,0)
 Q
"RTN","HLDIE773",157,0)
 ;
"RTN","HLDIE773",158,0)
XRFAG ; AG XRF kills/sets...
"RTN","HLDIE773",159,0)
 D XRFSET^HLDIE772(FILE,+IEN,"AG","P",1)
"RTN","HLDIE773",160,0)
 Q
"RTN","HLDIE773",161,0)
 ;
"RTN","HLDIE773",162,0)
XRFAH ; AH XRF kills/sets...
"RTN","HLDIE773",163,0)
 D XRFSETC^HLDIE772(FILE,+IEN,"AH",0,12,0,2)
"RTN","HLDIE773",164,0)
 Q
"RTN","HLDIE773",165,0)
 ;
"RTN","HLDIE773",166,0)
XRFAI ; AI INDEX code...
"RTN","HLDIE773",167,0)
 S STATUS=$P($G(NODE("P",1)),U)
"RTN","HLDIE773",168,0)
 D PXREF^HLUOPTF1(+$G(IEN),STATUS)
"RTN","HLDIE773",169,0)
 Q
"RTN","HLDIE773",170,0)
 ;
"RTN","HLDIE773",171,0)
XRFB ; B XRF kills/sets...
"RTN","HLDIE773",172,0)
 D XRFSET^HLDIE772(FILE,+IEN,"B",0,1)
"RTN","HLDIE773",173,0)
 Q
"RTN","HLDIE773",174,0)
 ;
"RTN","HLDIE773",175,0)
XRFC ; C XRF kills/sets...
"RTN","HLDIE773",176,0)
 D XRFSET^HLDIE772(FILE,IEN,"C",0,2)
"RTN","HLDIE773",177,0)
 Q
"RTN","HLDIE773",178,0)
 ;
"RTN","HLDIE773",179,0)
XRFFPD(IEN772,FPDOLD,FPDNEW) ; This API is called by XRFFPD^HLDIE772 when 
"RTN","HLDIE773",180,0)
 ; a 772 Fast Purge Date/time has been changed.  
"RTN","HLDIE773",181,0)
 ;
"RTN","HLDIE773",182,0)
 ; ASSUMPTION:  The Fast Purge Date/time should be the same in both
"RTN","HLDIE773",183,0)
 ;              772 and 773 entries.
"RTN","HLDIE773",184,0)
 ;
"RTN","HLDIE773",185,0)
 ; ASSUMPTION:  If the Fast Purge Date/time is changed in 773, the
"RTN","HLDIE773",186,0)
 ;              same value should be "echoed" (set into) file 772.
"RTN","HLDIE773",187,0)
 ;              and vice versa.
"RTN","HLDIE773",188,0)
 ;
"RTN","HLDIE773",189,0)
 ; ASSUMPTION:  The Fast Purge Date/time will NEVER be set unless
"RTN","HLDIE773",190,0)
 ;              the STATUS of both 772 and 773 entries is equal to
"RTN","HLDIE773",191,0)
 ;              SUCCESSFULLY COMPLETED.  (For this reason, the status
"RTN","HLDIE773",192,0)
 ;              will never be checked.
"RTN","HLDIE773",193,0)
 ;
"RTN","HLDIE773",194,0)
 ; The purpose of this call from 772 is to...
"RTN","HLDIE773",195,0)
 ;
"RTN","HLDIE773",196,0)
 ; * Kill all ^HLMA("AI") xrefs using the old Fast Purge Date/time
"RTN","HLDIE773",197,0)
 ;   for both files 772 and 773.
"RTN","HLDIE773",198,0)
 ; * Reset the Fast Purge Date/time in all 773 entries associated with
"RTN","HLDIE773",199,0)
 ;   the 772 entry whose Fast Purge Date/time field was just changed.
"RTN","HLDIE773",200,0)
 ; * Recreate the ^HLMA("AI") xrefs based on the new Fast Purge 
"RTN","HLDIE773",201,0)
 ;   Date/time.
"RTN","HLDIE773",202,0)
 ;
"RTN","HLDIE773",203,0)
 N IEN773
"RTN","HLDIE773",204,0)
 ;
"RTN","HLDIE773",205,0)
 ; Checks of data...  (Code commented per Jim Moore's suggestion. LJA)
"RTN","HLDIE773",206,0)
 ; QUIT:$G(^HL(772,+IEN772,0))']""  ;->
"RTN","HLDIE773",207,0)
 ; QUIT:FPDOLD'?7N1"."1.N  ;-> Check the original Fast Purge Date/time...
"RTN","HLDIE773",208,0)
 ; QUIT:FPDNEW'?7N1"."1.N  ;-> Check the new date...
"RTN","HLDIE773",209,0)
 ; QUIT:FPDOLD=FPDNEW  ;->  No change!
"RTN","HLDIE773",210,0)
 ;
"RTN","HLDIE773",211,0)
 ; Kill old 772 AI entry...
"RTN","HLDIE773",212,0)
 KILL ^HLMA("AI",FPDOLD,772,+IEN772) ; Kill 772 parent AI...
"RTN","HLDIE773",213,0)
 ;
"RTN","HLDIE773",214,0)
 ; Remove old 773 entries...
"RTN","HLDIE773",215,0)
 S IEN773=0
"RTN","HLDIE773",216,0)
 F  S IEN773=$O(^HLMA("B",+IEN772,IEN773)) Q:'IEN773  D
"RTN","HLDIE773",217,0)
 .  KILL ^HLMA("AI",FPDOLD,773,+IEN773) ; Kill 773 child AI...
"RTN","HLDIE773",218,0)
 .  S $P(^HLMA(+IEN773,2),U,2)=FPDNEW ; Set 773 to match 772...
"RTN","HLDIE773",219,0)
 ;
"RTN","HLDIE773",220,0)
 ; Now, all AI xrefs killed, and the Fast Purge Date/time in both 772
"RTN","HLDIE773",221,0)
 ; and 773 are set to the new value, so set the new xrefs...
"RTN","HLDIE773",222,0)
 S IEN773=0
"RTN","HLDIE773",223,0)
 F  S IEN773=$O(^HLMA("B",+IEN772,IEN773)) Q:'IEN773  D
"RTN","HLDIE773",224,0)
 .  D PXREF^HLUOPTF1(+IEN773,3)
"RTN","HLDIE773",225,0)
 ;
"RTN","HLDIE773",226,0)
 Q
"RTN","HLDIE773",227,0)
 ;
"RTN","HLDIE773",228,0)
XRFLLCT ; LLCNT^HLCSTCP(IEN870,3) XRF kills/sets...
"RTN","HLDIE773",229,0)
 ;XXX D LLCNT^HLCSTCP(IEN870,3)
"RTN","HLDIE773",230,0)
 Q
"RTN","HLDIE773",231,0)
 ;
"RTN","HLDIE773",232,0)
EOR ;HLDIE773 - Direct 772 & 773 Sets ; 11/18/2003 11:17
"RTN","HLDIEDB0")
0^90^B72529237
"RTN","HLDIEDB0",1,0)
HLDIEDB0 ;CIOFO-O/LJA - Debug Data Display Code ;12/29/03 10:39
"RTN","HLDIEDB0",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLDIEDB0",3,0)
 ;
"RTN","HLDIEDB0",4,0)
FILEIEN ; Input FILE,IEN to find debug data to display...
"RTN","HLDIEDB0",5,0)
 N ABORT,CT,DATE,FILE,GBL,GCT,IEN,JOB,LOC,RTN,X
"RTN","HLDIEDB0",6,0)
 ;
"RTN","HLDIEDB0",7,0)
 W @IOF,$$CJ^XLFSTR("Debug Data Display by FILE,IEN",IOM)
"RTN","HLDIEDB0",8,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLDIEDB0",9,0)
 ;
"RTN","HLDIEDB0",10,0)
 I '$D(^XTMP("HLDIE-DEBUGX")) D  QUIT  ;->
"RTN","HLDIEDB0",11,0)
 .  W !!,"No debug data exists..."
"RTN","HLDIEDB0",12,0)
 .  H 1
"RTN","HLDIEDB0",13,0)
 ;
"RTN","HLDIEDB0",14,0)
 S GBL="^XTMP(""HLDIE-DEBUGX"")"
"RTN","HLDIEDB0",15,0)
 ;
"RTN","HLDIEDB0",16,0)
 F  D  QUIT:'FILE  ;->
"RTN","HLDIEDB0",17,0)
 .  D SF
"RTN","HLDIEDB0",18,0)
 .  R !!,"Enter FILE#: ",FILE:99 Q:FILE']""!(FILE[U)  ;->
"RTN","HLDIEDB0",19,0)
 .  F  D  QUIT:'IEN  ;->
"RTN","HLDIEDB0",20,0)
 .  .  D SI(FILE)
"RTN","HLDIEDB0",21,0)
 .  .  R !!,"Enter IEN: ",IEN:99 Q:'IEN  ;->
"RTN","HLDIEDB0",22,0)
 .  .  W !!,?2,"#",?5,"File & IEN",?20,"Date",?35,"Job#",?50,"Rtn",?68,"Debug#"
"RTN","HLDIEDB0",23,0)
 .  .  W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLDIEDB0",24,0)
 .  .  KILL ^TMP($J,"H")
"RTN","HLDIEDB0",25,0)
 .  .  S DATE=0,ABORT=0,GCT=0
"RTN","HLDIEDB0",26,0)
 .  .  F  S DATE=$O(@GBL@(FILE,IEN,DATE)) Q:'DATE!(ABORT)  D
"RTN","HLDIEDB0",27,0)
 .  .  .  S JOB=0
"RTN","HLDIEDB0",28,0)
 .  .  .  F  S JOB=$O(@GBL@(FILE,IEN,DATE,JOB)) Q:'JOB!(ABORT)  D
"RTN","HLDIEDB0",29,0)
 .  .  .  .  S RTN=""
"RTN","HLDIEDB0",30,0)
 .  .  .  .  F  S RTN=$O(@GBL@(FILE,IEN,DATE,JOB,RTN)) Q:RTN']""!(ABORT)  D
"RTN","HLDIEDB0",31,0)
 .  .  .  .  .  S LOC=""
"RTN","HLDIEDB0",32,0)
 .  .  .  .  .  F  S LOC=$O(@GBL@(FILE,IEN,DATE,JOB,RTN,LOC)) Q:LOC']""!(ABORT)  D
"RTN","HLDIEDB0",33,0)
 .  .  .  .  .  .  S GCT=GCT+1
"RTN","HLDIEDB0",34,0)
 .  .  .  .  .  .  S ^TMP($J,"H",GCT)=DATE_U_JOB_U_RTN_U_LOC
"RTN","HLDIEDB0",35,0)
 .  .  .  .  .  .  W !,$J(GCT,3),?5,FILE,"[#",IEN,"]",?20,DATE,?35,JOB,?50,RTN,?68,LOC
"RTN","HLDIEDB0",36,0)
 .  .  F  D  QUIT:'GCT
"RTN","HLDIEDB0",37,0)
 .  .  .  R !!,"Enter #: ",GCT:99 Q:'GCT  ;->
"RTN","HLDIEDB0",38,0)
 .  .  .  S X=$G(^TMP($J,"H",+GCT)),DATE=+X,JOB=$P(X,U,2),RTN=$P(X,U,3),LOC=$P(X,U,4) QUIT:LOC']""  ;->
"RTN","HLDIEDB0",39,0)
 .  .  .  D INDIV(DATE\1,JOB,RTN,LOC)
"RTN","HLDIEDB0",40,0)
 .  .  .  W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLDIEDB0",41,0)
 ;
"RTN","HLDIEDB0",42,0)
 KILL ^TMP($J,"H")
"RTN","HLDIEDB0",43,0)
 ;
"RTN","HLDIEDB0",44,0)
 Q
"RTN","HLDIEDB0",45,0)
 ;
"RTN","HLDIEDB0",46,0)
SF ; Show files...
"RTN","HLDIEDB0",47,0)
 ; GBL -- req
"RTN","HLDIEDB0",48,0)
 N CT,FILE
"RTN","HLDIEDB0",49,0)
 W !!,$$CJ^XLFSTR(" Files w/Debug Data ",IOM,"=")
"RTN","HLDIEDB0",50,0)
 S CT=0,FILE=0
"RTN","HLDIEDB0",51,0)
 F  S FILE=$O(@GBL@(FILE)) Q:'FILE  D
"RTN","HLDIEDB0",52,0)
 .  S CT=CT+1 W:CT>1 ", "
"RTN","HLDIEDB0",53,0)
 .  W FILE
"RTN","HLDIEDB0",54,0)
 W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLDIEDB0",55,0)
 Q
"RTN","HLDIEDB0",56,0)
 ;
"RTN","HLDIEDB0",57,0)
SI(FILE) ; Show IENs for file...
"RTN","HLDIEDB0",58,0)
 ; GBL -- req
"RTN","HLDIEDB0",59,0)
 N CT,IEN
"RTN","HLDIEDB0",60,0)
 W !!,$$CJ^XLFSTR(" IENs w/Debug Data for File# "_FILE_" ",IOM,"=")
"RTN","HLDIEDB0",61,0)
 S CT=0,IEN=0
"RTN","HLDIEDB0",62,0)
 F  S IEN=$O(@GBL@(FILE,IEN)) Q:'IEN!(CT>100)  D
"RTN","HLDIEDB0",63,0)
 .  S CT=CT+1
"RTN","HLDIEDB0",64,0)
 .  W:$X>65 ! W:$X<6 ?6 W:$X>6 ","
"RTN","HLDIEDB0",65,0)
 .  W IEN
"RTN","HLDIEDB0",66,0)
 I CT>100 D
"RTN","HLDIEDB0",67,0)
 .  W !!,"Some IENs not displayed (because there were too many)..."
"RTN","HLDIEDB0",68,0)
 .  W !,"(The LAST IEN is ",$O(@GBL@(FILE,":"),-1),".)"
"RTN","HLDIEDB0",69,0)
 W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLDIEDB0",70,0)
 Q
"RTN","HLDIEDB0",71,0)
 ;
"RTN","HLDIEDB0",72,0)
SEARCH ; Search of global data to find & display...
"RTN","HLDIEDB0",73,0)
 N ABORT,CONT,CT,DATA,FIND,LP,ORIG,POSX,SRCH,ST,X
"RTN","HLDIEDB0",74,0)
 ;
"RTN","HLDIEDB0",75,0)
 W @IOF,$$CJ^XLFSTR("Debug Data Display by Global Search",IOM)
"RTN","HLDIEDB0",76,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLDIEDB0",77,0)
 ;
"RTN","HLDIEDB0",78,0)
 I '$D(^XTMP("HLDIE-DEBUGX")) D  QUIT  ;->
"RTN","HLDIEDB0",79,0)
 .  W !!,"No debug data exists..."
"RTN","HLDIEDB0",80,0)
 .  H 1
"RTN","HLDIEDB0",81,0)
 ;
"RTN","HLDIEDB0",82,0)
S1 KILL SRCH
"RTN","HLDIEDB0",83,0)
 ;
"RTN","HLDIEDB0",84,0)
 F  R !!,"Search string: ",SRCH:999 Q:SRCH']""!(SRCH=U)  D
"RTN","HLDIEDB0",85,0)
 .  S SRCH($$UP^XLFSTR(SRCH))=""
"RTN","HLDIEDB0",86,0)
 ;
"RTN","HLDIEDB0",87,0)
 QUIT:$O(SRCH(""))']""  ;->
"RTN","HLDIEDB0",88,0)
 ;
"RTN","HLDIEDB0",89,0)
 W !!,"Searching..."
"RTN","HLDIEDB0",90,0)
 ;
"RTN","HLDIEDB0",91,0)
 S CT=0,ABORT=0,CONT=0
"RTN","HLDIEDB0",92,0)
 ;
"RTN","HLDIEDB0",93,0)
 S LP="^XTMP(""HLDIE-DEBUF""",ST="^XTMP(""HLDIE-DEBUG",LP=LP_")"
"RTN","HLDIEDB0",94,0)
 F  S LP=$Q(@LP) Q:LP'[ST!(ABORT)  D
"RTN","HLDIEDB0",95,0)
 .  S ORIG=@LP,DATA=$$UP^XLFSTR(ORIG),FIND=0,SRCH=""
"RTN","HLDIEDB0",96,0)
 .  F  S SRCH=$O(SRCH(SRCH)) Q:SRCH']""!(FIND)  D
"RTN","HLDIEDB0",97,0)
 .  .  QUIT:DATA'[SRCH&(LP'[SRCH)  ;->
"RTN","HLDIEDB0",98,0)
 .  .  S FIND=1
"RTN","HLDIEDB0",99,0)
 .  QUIT:'FIND  ;->
"RTN","HLDIEDB0",100,0)
 .  W !,LP,"="
"RTN","HLDIEDB0",101,0)
 .  W:$X>55 !,?10,"-> "
"RTN","HLDIEDB0",102,0)
 .  S POSX=$X
"RTN","HLDIEDB0",103,0)
 .  F  D  QUIT:ORIG']""
"RTN","HLDIEDB0",104,0)
 .  .  W:$X>POSX ! W:$X<POSX ?POSX
"RTN","HLDIEDB0",105,0)
 .  .  W $E(ORIG,1,IOM-POSX)
"RTN","HLDIEDB0",106,0)
 .  .  S ORIG=$E(ORIG,IOM-POSX+1,999)
"RTN","HLDIEDB0",107,0)
 .  QUIT:CONT  ;->
"RTN","HLDIEDB0",108,0)
 .  S CT=CT+1 Q:(CT#10)  ;->
"RTN","HLDIEDB0",109,0)
 .  W " <-" R X:99 S:X]""&(X'=" ") ABORT=1 S:X=" " CONT=1
"RTN","HLDIEDB0",110,0)
 ;
"RTN","HLDIEDB0",111,0)
 I ABORT=1 W !!,"... aborting ..."
"RTN","HLDIEDB0",112,0)
 ;
"RTN","HLDIEDB0",113,0)
 G S1 ;->
"RTN","HLDIEDB0",114,0)
 ;
"RTN","HLDIEDB0",115,0)
API ; Select RTN & SUBRTN to find & show debug data...
"RTN","HLDIEDB0",116,0)
 N DATE,FILE,MAX,NUM,RTN,SUB
"RTN","HLDIEDB0",117,0)
 ;
"RTN","HLDIEDB0",118,0)
 W @IOF,$$CJ^XLFSTR("Debug Data Display by API Call",IOM)
"RTN","HLDIEDB0",119,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLDIEDB0",120,0)
 ;
"RTN","HLDIEDB0",121,0)
 I '$D(^XTMP("HLDIE-DEBUGX")) D  QUIT  ;->
"RTN","HLDIEDB0",122,0)
 .  W !!,"No debug data exists..."
"RTN","HLDIEDB0",123,0)
 .  H 1
"RTN","HLDIEDB0",124,0)
 ;
"RTN","HLDIEDB0",125,0)
 W !
"RTN","HLDIEDB0",126,0)
 D COLLECT
"RTN","HLDIEDB0",127,0)
 D SHOW
"RTN","HLDIEDB0",128,0)
 ;
"RTN","HLDIEDB0",129,0)
R1 R !!,"File: ",FILE:99 QUIT:FILE']""  ;->
"RTN","HLDIEDB0",130,0)
 I '$D(^XTMP("HLDIE-DEBUGX",FILE)) D  G R1 ;->
"RTN","HLDIEDB0",131,0)
 .  W "  no data..."
"RTN","HLDIEDB0",132,0)
 ;
"RTN","HLDIEDB0",133,0)
 R !,"Rtn: ",RTN:99 G:RTN']"" R1 ;->
"RTN","HLDIEDB0",134,0)
 R !,"Subrtn: ",SUB:99 G:SUB']"" R1 ;->
"RTN","HLDIEDB0",135,0)
 S RTN=RTN_"~"_SUB
"RTN","HLDIEDB0",136,0)
 ;
"RTN","HLDIEDB0",137,0)
 R !,"Max#: 20// ",MAX:99 S:MAX']"" MAX=20
"RTN","HLDIEDB0",138,0)
 S MAX=$S(MAX:MAX,1:20)
"RTN","HLDIEDB0",139,0)
 ;
"RTN","HLDIEDB0",140,0)
 F  D  QUIT:DATE']""  ;->
"RTN","HLDIEDB0",141,0)
 .  KILL ^TMP($J,"R")
"RTN","HLDIEDB0",142,0)
 .  R !!,"Enter Date/time (FM): ",DATE:99 QUIT:DATE']""  ;->
"RTN","HLDIEDB0",143,0)
 .  I DATE'?7N.E W " invalid format..." QUIT  ;->
"RTN","HLDIEDB0",144,0)
 .  
"RTN","HLDIEDB0",145,0)
 .  W !
"RTN","HLDIEDB0",146,0)
 .  D SHOWDT(FILE,DATE,RTN,MAX)
"RTN","HLDIEDB0",147,0)
 .  QUIT:'$D(^TMP($J,"R"))  ;->
"RTN","HLDIEDB0",148,0)
 .
"RTN","HLDIEDB0",149,0)
 .  F  D  QUIT:NUM']""!(NUM[U)
"RTN","HLDIEDB0",150,0)
 .  .  R !!,"Enter # to display: ",NUM:99 Q:NUM']""!(NUM[U)  ;->
"RTN","HLDIEDB0",151,0)
 .  .  I '$D(^TMP($J,"R",NUM)) D  QUIT  ;->
"RTN","HLDIEDB0",152,0)
 .  .  .  W "  entry not found..."
"RTN","HLDIEDB0",153,0)
 .  .  D SHOWONE(+NUM)
"RTN","HLDIEDB0",154,0)
 ;
"RTN","HLDIEDB0",155,0)
 H 2
"RTN","HLDIEDB0",156,0)
 ;
"RTN","HLDIEDB0",157,0)
 D SHOW
"RTN","HLDIEDB0",158,0)
 ;
"RTN","HLDIEDB0",159,0)
 G R1 ;->
"RTN","HLDIEDB0",160,0)
 ;
"RTN","HLDIEDB0",161,0)
SHOWONE(NUM) ; REquires ^TMP($J,"R",NUM)
"RTN","HLDIEDB0",162,0)
 N DATA,DATE,FILE,IEN,JOB,LOC,RTN
"RTN","HLDIEDB0",163,0)
 ;
"RTN","HLDIEDB0",164,0)
 S DATA=^TMP($J,"R",NUM)
"RTN","HLDIEDB0",165,0)
 ;
"RTN","HLDIEDB0",166,0)
 S FILE=+DATA,IEN=$P(DATA,U,2),DATE=$P(DATA,U,3)\1
"RTN","HLDIEDB0",167,0)
 S JOB=$P(DATA,U,4),RTN=$P(DATA,U,5),LOC=$P(DATA,U,6)
"RTN","HLDIEDB0",168,0)
 ;
"RTN","HLDIEDB0",169,0)
 D INDIV(DATE,JOB,RTN,LOC)
"RTN","HLDIEDB0",170,0)
 ;
"RTN","HLDIEDB0",171,0)
 Q
"RTN","HLDIEDB0",172,0)
 ;
"RTN","HLDIEDB0",173,0)
INDIV(DATE,JOB,RTN,LOC) ; Display entry's data from ^XTMP global...
"RTN","HLDIEDB0",174,0)
 N LP,REF,ST
"RTN","HLDIEDB0",175,0)
 ;
"RTN","HLDIEDB0",176,0)
 S LP="^XTMP(""HLDIE-DEBUG-"_DATE_""","_JOB_","""_RTN_""","_LOC
"RTN","HLDIEDB0",177,0)
 S ST=LP,LP=LP_")"
"RTN","HLDIEDB0",178,0)
 ;
"RTN","HLDIEDB0",179,0)
 W !!,"...",$P(LP,"^XTMP(""HLDIE-DEBUG-"_DATE,2),"="
"RTN","HLDIEDB0",180,0)
 D SDATA($X,$G(@LP))
"RTN","HLDIEDB0",181,0)
 ;
"RTN","HLDIEDB0",182,0)
 F  S LP=$Q(@LP) Q:LP'[ST  D
"RTN","HLDIEDB0",183,0)
 .  S REF=$P(LP,"^XTMP(""HLDIE-DEBUG-"_DATE,2)_"="
"RTN","HLDIEDB0",184,0)
 .  W !,"...",REF
"RTN","HLDIEDB0",185,0)
 .  D SDATA($X,@LP)
"RTN","HLDIEDB0",186,0)
 ;
"RTN","HLDIEDB0",187,0)
 W !
"RTN","HLDIEDB0",188,0)
 ;
"RTN","HLDIEDB0",189,0)
 Q
"RTN","HLDIEDB0",190,0)
 ;
"RTN","HLDIEDB0",191,0)
SDATA(POSX,DATA) ; Show data...
"RTN","HLDIEDB0",192,0)
 ;
"RTN","HLDIEDB0",193,0)
 F  D  Q:DATA']""
"RTN","HLDIEDB0",194,0)
 .  QUIT:DATA']""  ;->
"RTN","HLDIEDB0",195,0)
 .  W:$X>POSX ! W:$X<POSX ?POSX
"RTN","HLDIEDB0",196,0)
 .  W $E(DATA,1,IOM-POSX)
"RTN","HLDIEDB0",197,0)
 .  S DATA=$E(DATA,IOM-POSX+1,999)
"RTN","HLDIEDB0",198,0)
 ;
"RTN","HLDIEDB0",199,0)
 Q
"RTN","HLDIEDB0",200,0)
 ;
"RTN","HLDIEDB0",201,0)
SHOWDT(FILE,DATE,RTN,MAX) ; Show entries and create ^TMP($J,"R")...
"RTN","HLDIEDB0",202,0)
 N ABORT,CT,DATA,GBL,IEN,JOB,JOBLAST,LDT,NO,NUM
"RTN","HLDIEDB0",203,0)
 ;
"RTN","HLDIEDB0",204,0)
 S GBL="^XTMP(""HLDIE-DEBUGX"","_FILE_")"
"RTN","HLDIEDB0",205,0)
 ;
"RTN","HLDIEDB0",206,0)
 D SHOWDTHD
"RTN","HLDIEDB0",207,0)
 ;
"RTN","HLDIEDB0",208,0)
 S IEN=0,CT=0,ABORT=0,JOBLAST=""
"RTN","HLDIEDB0",209,0)
 F  S IEN=$O(@GBL@(IEN)) Q:'IEN!(CT'<MAX)  D
"RTN","HLDIEDB0",210,0)
 .  S LDT=DATE-.0000000001
"RTN","HLDIEDB0",211,0)
 .  F  S LDT=$O(@GBL@(IEN,LDT)) Q:'LDT  D
"RTN","HLDIEDB0",212,0)
 .  .  S JOB=0
"RTN","HLDIEDB0",213,0)
 .  .  F  S JOB=$O(@GBL@(IEN,LDT,JOB)) Q:JOB'>0  D
"RTN","HLDIEDB0",214,0)
 .  .  .  S NO=$O(@GBL@(IEN,LDT,JOB,RTN,":"),-1)/2\1 QUIT:'NO  ;->
"RTN","HLDIEDB0",215,0)
 .  .  .  S NUM=0
"RTN","HLDIEDB0",216,0)
 .  .  .  F  S NUM=$O(@GBL@(IEN,LDT,JOB,RTN,NUM)) Q:'NUM  D
"RTN","HLDIEDB0",217,0)
 .  .  .  .  S CT=CT+1
"RTN","HLDIEDB0",218,0)
 .  .  .  .  S DATA=$G(@GBL@(IEN,LDT,JOB,RTN,NUM))
"RTN","HLDIEDB0",219,0)
 .  .  .  .  S ^TMP($J,"R",CT)=FILE_U_IEN_U_LDT_U_JOB_U_RTN_U_NUM
"RTN","HLDIEDB0",220,0)
 .  .  .  .  I JOBLAST'=""&(JOBLAST) W ! S JOBLAST=0
"RTN","HLDIEDB0",221,0)
 .  .  .  .  D EADTHD(CT,FILE,IEN,LDT,JOB,RTN,NUM,+DATA)
"RTN","HLDIEDB0",222,0)
 .  .  .  S JOBLAST=JOB
"RTN","HLDIEDB0",223,0)
 ;
"RTN","HLDIEDB0",224,0)
 Q
"RTN","HLDIEDB0",225,0)
 ;
"RTN","HLDIEDB0",226,0)
EADTHD(CT,FILE,IEN,LDT,JOB,RTN,NUM,LOC) ;
"RTN","HLDIEDB0",227,0)
 W !,$J(CT,3),?5,FILE,?15,+IEN,?25,"@",$P(LDT,".",2)
"RTN","HLDIEDB0",228,0)
 W ?35,JOB,?50,RTN,?70,LOC,$S(LOC=1:"<-Beg",1:"")
"RTN","HLDIEDB0",229,0)
 Q
"RTN","HLDIEDB0",230,0)
 ;
"RTN","HLDIEDB0",231,0)
SHOWDTHD ;
"RTN","HLDIEDB0",232,0)
 W !!,"#",?5,"File",?15,"IEN",?25,"Time",?35,"Job#",?50,"Location"
"RTN","HLDIEDB0",233,0)
 W ?70,"Call#"
"RTN","HLDIEDB0",234,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLDIEDB0",235,0)
 Q
"RTN","HLDIEDB0",236,0)
 ;
"RTN","HLDIEDB0",237,0)
SHOW ;
"RTN","HLDIEDB0",238,0)
 N CT,DATE,FILE,RTN
"RTN","HLDIEDB0",239,0)
 ;
"RTN","HLDIEDB0",240,0)
 W !!,"File",?17,"Date",?40,"API"
"RTN","HLDIEDB0",241,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLDIEDB0",242,0)
 ;
"RTN","HLDIEDB0",243,0)
 S FILE=0
"RTN","HLDIEDB0",244,0)
 F  S FILE=$O(^TMP($J,"D",FILE)) Q:'FILE  D
"RTN","HLDIEDB0",245,0)
 .  W !,FILE," [#",^TMP($J,"D",FILE),"]"
"RTN","HLDIEDB0",246,0)
 .  S DATE=0
"RTN","HLDIEDB0",247,0)
 .  F  S DATE=$O(^TMP($J,"D",FILE,DATE)) Q:'DATE  D
"RTN","HLDIEDB0",248,0)
 .  .  W:$X>17 ! W:$X<17 ?17
"RTN","HLDIEDB0",249,0)
 .  .  W DATE," [#",^TMP($J,"D",FILE,DATE),"]"
"RTN","HLDIEDB0",250,0)
 .  .  S RTN=""
"RTN","HLDIEDB0",251,0)
 .  .  F  S RTN=$O(^TMP($J,"D",FILE,DATE,RTN)) Q:RTN']""  D
"RTN","HLDIEDB0",252,0)
 .  .  .  W:$X>40 ! W:$X<40 ?40
"RTN","HLDIEDB0",253,0)
 .  .  .  W RTN," [#",^TMP($J,"D",FILE,DATE,RTN),"]"
"RTN","HLDIEDB0",254,0)
 ;
"RTN","HLDIEDB0",255,0)
 Q
"RTN","HLDIEDB0",256,0)
 ;
"RTN","HLDIEDB0",257,0)
COLLECT ; Collect data into ^TMP($J,"D")...
"RTN","HLDIEDB0",258,0)
 N DATE,FILE,IEN,JOB,LOC,RTN
"RTN","HLDIEDB0",259,0)
 ;
"RTN","HLDIEDB0",260,0)
 KILL ^TMP($J)
"RTN","HLDIEDB0",261,0)
 ;
"RTN","HLDIEDB0",262,0)
 S FILE=0
"RTN","HLDIEDB0",263,0)
 F  S FILE=$O(^XTMP("HLDIE-DEBUGX",FILE)) QUIT:'FILE  D
"RTN","HLDIEDB0",264,0)
 .  S IEN=0
"RTN","HLDIEDB0",265,0)
 .  F  S IEN=$O(^XTMP("HLDIE-DEBUGX",FILE,IEN)) Q:'IEN  D
"RTN","HLDIEDB0",266,0)
 .  .  S DATE=0
"RTN","HLDIEDB0",267,0)
 .  .  F  S DATE=$O(^XTMP("HLDIE-DEBUGX",FILE,IEN,DATE)) Q:'DATE  D
"RTN","HLDIEDB0",268,0)
 .  .  .  ; HLDIE-DEBUGX data hangs around longer...
"RTN","HLDIEDB0",269,0)
 .  .  .  QUIT:'$D(^XTMP("HLDIE-DEBUG-"_(DATE\1)))  ;->
"RTN","HLDIEDB0",270,0)
 .  .  .  S JOB=0
"RTN","HLDIEDB0",271,0)
 .  .  .  F  S JOB=$O(^XTMP("HLDIE-DEBUGX",FILE,IEN,DATE,JOB)) Q:'JOB  D
"RTN","HLDIEDB0",272,0)
 .  .  .  .  S RTN=""
"RTN","HLDIEDB0",273,0)
 .  .  .  .  F  S RTN=$O(^XTMP("HLDIE-DEBUGX",FILE,IEN,DATE,JOB,RTN)) Q:RTN']""  D
"RTN","HLDIEDB0",274,0)
 .  .  .  .  .  S LOC=0
"RTN","HLDIEDB0",275,0)
 .  .  .  .  .  F  S LOC=$O(^XTMP("HLDIE-DEBUGX",FILE,IEN,DATE,JOB,RTN,LOC)) Q:'LOC  D
"RTN","HLDIEDB0",276,0)
 .  .  .  .  .  .  D COLL1(FILE,IEN,DATE\1,JOB,RTN,LOC)
"RTN","HLDIEDB0",277,0)
 ;
"RTN","HLDIEDB0",278,0)
 Q
"RTN","HLDIEDB0",279,0)
 ;
"RTN","HLDIEDB0",280,0)
COLL1(FILE,IEN,DATE,JOB,RTN,LOC) ; Called by COLLECT...
"RTN","HLDIEDB0",281,0)
 ;
"RTN","HLDIEDB0",282,0)
 S ^TMP($J,"D",FILE)=$G(^TMP($J,"D",FILE))+1
"RTN","HLDIEDB0",283,0)
 S ^TMP($J,"D",FILE,DATE)=$G(^TMP($J,"D",FILE,DATE))+1
"RTN","HLDIEDB0",284,0)
 S ^TMP($J,"D",FILE,DATE,RTN)=$G(^TMP($J,"D",FILE,DATE,RTN))+1
"RTN","HLDIEDB0",285,0)
 ;
"RTN","HLDIEDB0",286,0)
 Q
"RTN","HLDIEDB0",287,0)
 ;
"RTN","HLDIEDB0",288,0)
ONLYASC(TXT) ; Return ASCII only. No CTRL characters...
"RTN","HLDIEDB0",289,0)
 N ASCII,CHAR,NTXT,POS
"RTN","HLDIEDB0",290,0)
 S NTXT=""
"RTN","HLDIEDB0",291,0)
 F POS=1:1:$L(TXT) D
"RTN","HLDIEDB0",292,0)
 .  S CHAR=$E(TXT,+POS),ASCII=$A(CHAR)
"RTN","HLDIEDB0",293,0)
 .  I ASCII<32 S CHAR="{"_ASCII_"}"
"RTN","HLDIEDB0",294,0)
 .  S NTXT=NTXT_CHAR
"RTN","HLDIEDB0",295,0)
 QUIT NTXT
"RTN","HLDIEDB0",296,0)
 ;
"RTN","HLDIEDB0",297,0)
EOR ;HLDIEDBO - Direct 772 & 773 Sets DEBUG CODE ; 11/18/2003 11:17
"RTN","HLDIEDB1")
0^91^B106657373
"RTN","HLDIEDB1",1,0)
HLDIEDB1 ;CIOFO-O/LJA - DEBUG Menu ;1/8/04 @ 01:28
"RTN","HLDIEDB1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLDIEDB1",3,0)
 ;
"RTN","HLDIEDB1",4,0)
INIT ;
"RTN","HLDIEDB1",5,0)
 N A7UMENU,A7UOK,A7UOPT,NOMENU,I,T,X,Y
"RTN","HLDIEDB1",6,0)
 ;
"RTN","HLDIEDB1",7,0)
CTRL ;
"RTN","HLDIEDB1",8,0)
 D HEADER
"RTN","HLDIEDB1",9,0)
 D M
"RTN","HLDIEDB1",10,0)
 D ASK I 'A7UOK QUIT  ;->
"RTN","HLDIEDB1",11,0)
 D XEC
"RTN","HLDIEDB1",12,0)
 D BT QUIT:'A7UOK  ;->
"RTN","HLDIEDB1",13,0)
 G CTRL ;->
"RTN","HLDIEDB1",14,0)
 ;
"RTN","HLDIEDB1",15,0)
BT ;
"RTN","HLDIEDB1",16,0)
 N DIR,DIROUT,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLDIEDB1",17,0)
 W !
"RTN","HLDIEDB1",18,0)
 S A7UOK=0
"RTN","HLDIEDB1",19,0)
 N DIR
"RTN","HLDIEDB1",20,0)
 S DIR(0)="EA",DIR("A")="Press RETURN to continue, or '^' to exit... "
"RTN","HLDIEDB1",21,0)
 D ^DIR
"RTN","HLDIEDB1",22,0)
 QUIT:+Y'=1  ;->
"RTN","HLDIEDB1",23,0)
 S A7UOK=1
"RTN","HLDIEDB1",24,0)
 QUIT
"RTN","HLDIEDB1",25,0)
 ;
"RTN","HLDIEDB1",26,0)
HEADER ;
"RTN","HLDIEDB1",27,0)
 N DEBUG,IOINHI,IOINORM,X
"RTN","HLDIEDB1",28,0)
 W @IOF,$$CJ^XLFSTR("HLDIE Debug Utility",IOM)
"RTN","HLDIEDB1",29,0)
 S DEBUG=$G(^XTMP("HLDIE-DEBUG","STATUS"))
"RTN","HLDIEDB1",30,0)
 I DEBUG]"" D  ; Show debug string...
"RTN","HLDIEDB1",31,0)
 .  S X="IOINORM;IOINHI" D ENDR^%ZISS
"RTN","HLDIEDB1",32,0)
 .  S DEBUG="Pre-call: "_$$CD($P(DEBUG,U))_"  Post-call: "_$$CD($P(DEBUG,U,2))_"  Screen: "_$$CD($P(DEBUG,U,3))
"RTN","HLDIEDB1",33,0)
 .  W !,?17,DEBUG
"RTN","HLDIEDB1",34,0)
 W !,$$REPEAT^XLFSTR("=",80)
"RTN","HLDIEDB1",35,0)
 QUIT
"RTN","HLDIEDB1",36,0)
 ;
"RTN","HLDIEDB1",37,0)
CD(TXT) ; debug information
"RTN","HLDIEDB1",38,0)
 ; IOINORM,IOINHI -- req
"RTN","HLDIEDB1",39,0)
 QUIT:TXT']"" "OFF" ;->
"RTN","HLDIEDB1",40,0)
 QUIT IOINHI_"ON["_TXT_"]"_IOINORM ;->
"RTN","HLDIEDB1",41,0)
 ;
"RTN","HLDIEDB1",42,0)
M KILL A7UMENU N I,T F I=1:1 S T=$T(M+I) QUIT:T'[";;"  S T=$P(T,";;",2,99),A7UMENU(I)=$P(T,"~",2,99) W !,$J(I,2),". ",$P(T,"~") S NOMENU=I
"RTN","HLDIEDB1",43,0)
 ;;Display debug documentation~D DOC
"RTN","HLDIEDB1",44,0)
 ;;Display debug data - API~D API^HLDIEDB0
"RTN","HLDIEDB1",45,0)
 ;;Display debug data - FILE,IEN~D FILEIEN^HLDIEDB0
"RTN","HLDIEDB1",46,0)
 ;;Display debug data - SEARCH~D SEARCH^HLDIEDB0
"RTN","HLDIEDB1",47,0)
 ;;Display debug data - REALTIME~D REALTIME^HLDIEDB1
"RTN","HLDIEDB1",48,0)
 ;;Display debug data - JOB~D JOB^HLDIEDB3
"RTN","HLDIEDB1",49,0)
 ;;Set debug control string (Turn debugging on/off)~D SETDEBUG^HLDIEDBG
"RTN","HLDIEDB1",50,0)
 ;;Kill debug data~D KILLALL^HLDIEDBG
"RTN","HLDIEDB1",51,0)
 QUIT
"RTN","HLDIEDB1",52,0)
 ;
"RTN","HLDIEDB1",53,0)
ASK ;
"RTN","HLDIEDB1",54,0)
 ; NOMENU -- req
"RTN","HLDIEDB1",55,0)
 N DIR,DIROUT,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLDIEDB1",56,0)
 W !
"RTN","HLDIEDB1",57,0)
 S A7UOK=0
"RTN","HLDIEDB1",58,0)
 N DIR
"RTN","HLDIEDB1",59,0)
 S DIR(0)="NO^1:"_NOMENU,DIR("A")="Select option"
"RTN","HLDIEDB1",60,0)
 D ^DIR
"RTN","HLDIEDB1",61,0)
 QUIT:'$D(A7UMENU(+Y))  ;->
"RTN","HLDIEDB1",62,0)
 S A7UOPT=+Y
"RTN","HLDIEDB1",63,0)
 S A7UOK=1
"RTN","HLDIEDB1",64,0)
 QUIT
"RTN","HLDIEDB1",65,0)
 ;
"RTN","HLDIEDB1",66,0)
XEC ;
"RTN","HLDIEDB1",67,0)
 S X=A7UMENU(+A7UOPT) X X
"RTN","HLDIEDB1",68,0)
 QUIT
"RTN","HLDIEDB1",69,0)
 ;
"RTN","HLDIEDB1",70,0)
REALTIME ; real-time monitoring...
"RTN","HLDIEDB1",71,0)
 N C2,C3,C4,C5,C6,C7,C8,CT,GBL,LAST,STOP,X
"RTN","HLDIEDB1",72,0)
 ;
"RTN","HLDIEDB1",73,0)
 S GBL="^XTMP(""HLDIE-DEBUGN"",""N"")",LAST=$G(@GBL)
"RTN","HLDIEDB1",74,0)
 S C2=7,C3=18,C4=30,C5=40,C6=52,C7=70,C8=75
"RTN","HLDIEDB1",75,0)
 ;
"RTN","HLDIEDB1",76,0)
 S CT=0
"RTN","HLDIEDB1",77,0)
 ;
"RTN","HLDIEDB1",78,0)
 D REALHDR
"RTN","HLDIEDB1",79,0)
 ;
"RTN","HLDIEDB1",80,0)
 F  D  Q:STOP
"RTN","HLDIEDB1",81,0)
 .  S STOP=1,CT=CT+1
"RTN","HLDIEDB1",82,0)
 .  D REALSHOW
"RTN","HLDIEDB1",83,0)
 .  R X:60 QUIT:X]""  ;->
"RTN","HLDIEDB1",84,0)
 .  S STOP=0
"RTN","HLDIEDB1",85,0)
 ;
"RTN","HLDIEDB1",86,0)
 Q
"RTN","HLDIEDB1",87,0)
 ;
"RTN","HLDIEDB1",88,0)
REALHDR ; Header for real-time display...
"RTN","HLDIEDB1",89,0)
 ; Cn -- req
"RTN","HLDIEDB1",90,0)
 W !!,"#",?C2,"NOW",?C3,"File [#IEN]",?C4,"DataTM",?C5,"$J"
"RTN","HLDIEDB1",91,0)
 W ?C6,"Rtn",?C7,"LOC",?C8,"Edtor"
"RTN","HLDIEDB1",92,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLDIEDB1",93,0)
 Q
"RTN","HLDIEDB1",94,0)
 ;
"RTN","HLDIEDB1",95,0)
REALSHOW ; Show information...
"RTN","HLDIEDB1",96,0)
 ;C2,C3,GBL,LAST -- req --> LAST
"RTN","HLDIEDB1",97,0)
 N DNO,NOW,NUM
"RTN","HLDIEDB1",98,0)
 ;
"RTN","HLDIEDB1",99,0)
 S NUM=$G(@GBL),NOW=$$TIME($$NOW^XLFDT)
"RTN","HLDIEDB1",100,0)
 ;
"RTN","HLDIEDB1",101,0)
 I CT=1 D  QUIT  ;->
"RTN","HLDIEDB1",102,0)
 .  W !,?C2,NOW,?C3,"Collecting data..."
"RTN","HLDIEDB1",103,0)
 ;
"RTN","HLDIEDB1",104,0)
 I NUM=LAST D  QUIT  ;->
"RTN","HLDIEDB1",105,0)
 .  W:$X>0 !
"RTN","HLDIEDB1",106,0)
 .  W ?C2,NOW,?C3,"[No change]"
"RTN","HLDIEDB1",107,0)
 ;
"RTN","HLDIEDB1",108,0)
 F DNO=(LAST+1):1:NUM D REALONE(DNO)
"RTN","HLDIEDB1",109,0)
 ;
"RTN","HLDIEDB1",110,0)
 S LAST=NUM
"RTN","HLDIEDB1",111,0)
 ;
"RTN","HLDIEDB1",112,0)
 Q
"RTN","HLDIEDB1",113,0)
 ;
"RTN","HLDIEDB1",114,0)
REALONE(DNO) ; Show one entry...
"RTN","HLDIEDB1",115,0)
 ; Cn -- req
"RTN","HLDIEDB1",116,0)
 N DATA,DATE,EDITOR,FILE,IEN,JOB,LOC,RTN,SNO,TIME
"RTN","HLDIEDB1",117,0)
 ;
"RTN","HLDIEDB1",118,0)
 S DATA=$G(@GBL@(DNO))
"RTN","HLDIEDB1",119,0)
 S FILE=$P(DATA,U),IEN=$P(DATA,U,2),TIME=$P(DATA,U,3),JOB=$P(DATA,U,4)
"RTN","HLDIEDB1",120,0)
 S RTN=$P(DATA,U,5),SNO=$P(DATA,U,6),EDITOR=$P(DATA,U,7)
"RTN","HLDIEDB1",121,0)
 ;
"RTN","HLDIEDB1",122,0)
 S TIME=$$TIME(TIME)
"RTN","HLDIEDB1",123,0)
 ;
"RTN","HLDIEDB1",124,0)
 W !,$J(DNO,5),?C2,NOW,?C3,FILE," [#",IEN,"]",?C4,TIME,?C5,JOB
"RTN","HLDIEDB1",125,0)
 W ?C6,RTN,?C7,SNO,?C8,$S(EDITOR["HLDIE":"HL",1:"FM")
"RTN","HLDIEDB1",126,0)
 ;
"RTN","HLDIEDB1",127,0)
 Q
"RTN","HLDIEDB1",128,0)
 ;
"RTN","HLDIEDB1",129,0)
TIME(FMTIME) ; Return HH:MM:SS
"RTN","HLDIEDB1",130,0)
 S FMTIME=$P(FMTIME_"000000",".",2)
"RTN","HLDIEDB1",131,0)
 QUIT $E(FMTIME,1,2)_":"_$E(FMTIME,3,4)_":"_$E(FMTIME,5,6)
"RTN","HLDIEDB1",132,0)
 ;
"RTN","HLDIEDB1",133,0)
 ;
"RTN","HLDIEDB1",134,0)
 ;
"RTN","HLDIEDB1",135,0)
DOC N C,I,IOINHI,IOINORM,T,X
"RTN","HLDIEDB1",136,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLDIEDB1",137,0)
 F I=4:1 S T=$T(DOC+I) QUIT:T'[";;"!($G(X)[U)  D
"RTN","HLDIEDB1",138,0)
 .  S T=$P(T,";;",2,99) S:$E(T,1,2)="[[" T=IOINHI_$TR(T,"[]","")_IOINORM W !,T
"RTN","HLDIEDB1",139,0)
 ;;[[OVERVIEW]]
"RTN","HLDIEDB1",140,0)
 ;; HLDIE debug data can be captured for evaluation by setting a "debug string."
"RTN","HLDIEDB1",141,0)
 ;; The debug string is stored on the ^XTMP("HLDIE-DEBUG","STATUS") node.
"RTN","HLDIEDB1",142,0)
 ;; This debug string should be set using the 'Set debug control string (Turn
"RTN","HLDIEDB1",143,0)
 ;; debugging on/off)' menu choice.
"RTN","HLDIEDB1",144,0)
 ;;
"RTN","HLDIEDB1",145,0)
 ;;
"RTN","HLDIEDB1",146,0)
 ;;[[DEBUG STRING DETAILS]]
"RTN","HLDIEDB1",147,0)
 ;; The "debug string" had three(3) pieces:
"RTN","HLDIEDB1",148,0)
 ;; 
"RTN","HLDIEDB1",149,0)
 ;;   * Piece 1 controls data capture prior to FILE^DIE or FILE^HLDIE call.
"RTN","HLDIEDB1",150,0)
 ;;     - If set to 1, "select" data (see below) is captures.
"RTN","HLDIEDB1",151,0)
 ;;     - If set to 2, all local variables are captures.
"RTN","HLDIEDB1",152,0)
 ;;     - If set to "", no data is collected.
"RTN","HLDIEDB1",153,0)
 ;;
"RTN","HLDIEDB1",154,0)
 ;;   * Piece 2 controls data capture after FILE^DIE or FILE^HLDIE call.
"RTN","HLDIEDB1",155,0)
 ;;     - See piece 1 above for setting details.
"RTN","HLDIEDB1",156,0)
 ;;
"RTN","HLDIEDB1",157,0)
 ;;   * Piece 3 activates data capture screening.
"RTN","HLDIEDB1",158,0)
 ;;     - Piece 3 can be set to 1 to activate the data screen held in
"RTN","HLDIEDB1",159,0)
 ;;       $$STORESCR^HLDIEDB2.  This API holds no M code, but is a placeholder
"RTN","HLDIEDB1",160,0)
 ;;       for M code that can evaluate the environment and on-the-fly turn on
"RTN","HLDIEDB1",161,0)
 ;;       or off data storage.  (It can also control whethere "select" or all
"RTN","HLDIEDB1",162,0)
 ;;       data is captured.)
"RTN","HLDIEDB1",163,0)
 ;;
"RTN","HLDIEDB1",164,0)
 ;;
"RTN","HLDIEDB1",165,0)
 ;;[[PIECE 3 DATA SCREEN DETAILS]]
"RTN","HLDIEDB1",166,0)
 ;; If piece 3 of the debug control string equals 1, the following 
"RTN","HLDIEDB1",167,0)
 ;; occurs:  
"RTN","HLDIEDB1",168,0)
 ;;
"RTN","HLDIEDB1",169,0)
 ;;  * $$STORESCR^HLDIEDB2 is called by debugging process in FILE^HLDIE.
"RTN","HLDIEDB1",170,0)
 ;;  * The local variable STORE holds the value null, 1 or 2 (see above),
"RTN","HLDIEDB1",171,0)
 ;;    specifying whether data should be captured, and if so, whether "select"
"RTN","HLDIEDB1",172,0)
 ;;    or all local variables should be stored.
"RTN","HLDIEDB1",173,0)
 ;;  * If M code has been added to $$STORESCR^HLDIEDB2, it may evaluate the
"RTN","HLDIEDB1",174,0)
 ;;    environment and optionally reset STORE to null, 1 or 2.
"RTN","HLDIEDB1",175,0)
 ;;  * The value of STORE after M code execution is returned to the debugging 
"RTN","HLDIEDB1",176,0)
 ;;    process.  (And, if set to null, no data is captured.)
"RTN","HLDIEDB1",177,0)
 ;;
"RTN","HLDIEDB1",178,0)
 ;; The following variables are defined for use by the M code added to
"RTN","HLDIEDB1",179,0)
 ;; $$STORESCR^HLDIEDB2:
"RTN","HLDIEDB1",180,0)
 ;;
"RTN","HLDIEDB1",181,0)
 ;;  * CT - The number occurences already stored for TODAY/JOB#/API.
"RTN","HLDIEDB1",182,0)
 ;;         (When a job calls STATUS^HLTF0, a call is made to FILE^HLDIE which
"RTN","HLDIEDB1",183,0)
 ;;         can result in the creation of a debug data capture entry.  Every
"RTN","HLDIEDB1",184,0)
 ;;         such call by the job to STATUS^HLTF0 results in the creation of 
"RTN","HLDIEDB1",185,0)
 ;;         another data capture.  Twenty such calls can be made, after which
"RTN","HLDIEDB1",186,0)
 ;;         the oldest capture is removed by the FIFO method.  The value of CT
"RTN","HLDIEDB1",187,0)
 ;;         holds the total number of data capture occurences.)
"RTN","HLDIEDB1",188,0)
 ;;  * DEBUGNO - The sequential number to be used during data storage.
"RTN","HLDIEDB1",189,0)
 ;;  * DEBUGNOW - The date/time that will be used during data storage.
"RTN","HLDIEDB1",190,0)
 ;;  * HLFILE - The file being edited.
"RTN","HLDIEDB1",191,0)
 ;;  * HLIEN - The file's IEN being edited.
"RTN","HLDIEDB1",192,0)
 ;;  * LOC - 1 (before call) or 2 (after call). 
"RTN","HLDIEDB1",193,0)
 ;;  * RTN - RTN~SUBRTN (from the 4th & 5th FILE^HLDIE parameters.)
"RTN","HLDIEDB1",194,0)
 ;;  * STORE - "" (don't store), 1 (store "select"), or 2 (store all.)
"RTN","HLDIEDB1",195,0)
 ;;
"RTN","HLDIEDB1",196,0)
 ;;
"RTN","HLDIEDB1",197,0)
 ;;[[DEBUGGING - ALL VARIABLE STORAGE]]
"RTN","HLDIEDB1",198,0)
 ;; Unrelated to the above debugging instructions, the 
"RTN","HLDIEDB1",199,0)
 ;; LOG^HLDIEDBG(SUBSV,KEEP,STOP) API can be used by VistA HL7 developers to
"RTN","HLDIEDB1",200,0)
 ;; store all variables.  (The DOLRO^%ZOSV API is used.)  Data created by this
"RTN","HLDIEDB1",201,0)
 ;; call is stored in:
"RTN","HLDIEDB1",202,0)
 ;;
"RTN","HLDIEDB1",203,0)
 ;;   ^XTMP("HLDIE-"_DT,SUBSV,#,VAR)=VALUE
"RTN","HLDIEDB1",204,0)
 ;;
"RTN","HLDIEDB1",205,0)
 ;; Entries in this global are sequential at the '#' subscript level.  When a
"RTN","HLDIEDB1",206,0)
 ;; call is made to this API, all local variables are stored at the VAR
"RTN","HLDIEDB1",207,0)
 ;; subscript level.
"RTN","HLDIEDB1",208,0)
 ;;
"RTN","HLDIEDB1",209,0)
 ;; The LOG API has the following parameters:
"RTN","HLDIEDB1",210,0)
 ;;
"RTN","HLDIEDB1",211,0)
 ;;  * SUBSV - The subscript to be used when storing data.  (The value of this
"RTN","HLDIEDB1",212,0)
 ;;            parameter is usually RTN~SUBRTN.)
"RTN","HLDIEDB1",213,0)
 ;;  * KEEP - The number of entries to store.  (The entry of this parameter is
"RTN","HLDIEDB1",214,0)
 ;;           optional, defaulting to 20.)
"RTN","HLDIEDB1",215,0)
 ;;  * STOP - If set to 1, after KEEP number of entries are stored, no more
"RTN","HLDIEDB1",216,0)
 ;;           data is captured, (and no data is deleted.)  If not set to 1, 
"RTN","HLDIEDB1",217,0)
 ;;           KEEP number of entries are stored, the first entry stored is
"RTN","HLDIEDB1",218,0)
 ;;           deleted in FIFO manner, to ensure that no more than KEEP entries
"RTN","HLDIEDB1",219,0)
 ;;           exist.
"RTN","HLDIEDB1",220,0)
 Q
"RTN","HLDIEDB1",221,0)
 ;
"RTN","HLDIEDB1",222,0)
ERR ; If error occurs during screening...
"RTN","HLDIEDB1",223,0)
 ; The SENDUZ(DUZ)="" array *MUST* already be defined...
"RTN","HLDIEDB1",224,0)
 N C,DATA,ERRTXT,LP,NO,ST,STORERR,TEXT,TIME,X,XMDUZ,XMSUB,XMTEXT,XMZ
"RTN","HLDIEDB1",225,0)
 ;
"RTN","HLDIEDB1",226,0)
 ; Before continuing, specify that NOTHING should be stored...
"RTN","HLDIEDB1",227,0)
 ; This email message is ALL that will be stored or sent.
"RTN","HLDIEDB1",228,0)
 S STORE="" ; This variable is returned to FILE^HLDIE execution
"RTN","HLDIEDB1",229,0)
 ;
"RTN","HLDIEDB1",230,0)
 ; Also, turn off STORE capture!
"RTN","HLDIEDB1",231,0)
 S ^XTMP("HLDIE-DEBUG","STATUS")=""
"RTN","HLDIEDB1",232,0)
 ;
"RTN","HLDIEDB1",233,0)
 ; Record an error in logger...
"RTN","HLDIEDB1",234,0)
 S ERRTXT=$$EC^%ZOSV
"RTN","HLDIEDB1",235,0)
 S X=$$LOG^HLEVAPI2("FILE-HLDIE","ERRTXT")
"RTN","HLDIEDB1",236,0)
 ;
"RTN","HLDIEDB1",237,0)
 ; setup things...
"RTN","HLDIEDB1",238,0)
 S XMDUZ=.5,XMSUB="HLDIE $$STORESCR Error"
"RTN","HLDIEDB1",239,0)
 S XMTEXT="^TMP("_$J_",""HLMSG"","
"RTN","HLDIEDB1",240,0)
 KILL ^TMP($J,"HLMSG"),^TMP($J,"HLVAR")
"RTN","HLDIEDB1",241,0)
 S NO=0
"RTN","HLDIEDB1",242,0)
 ;
"RTN","HLDIEDB1",243,0)
 ; Add text...
"RTN","HLDIEDB1",244,0)
 D MAILADD("An error occurred in $$STORESCR^HLDIEDB2 that must be checked.  The")
"RTN","HLDIEDB1",245,0)
 D MAILADD("variables that existed at the time of the error are listed below.")
"RTN","HLDIEDB1",246,0)
 D MAILADD("")
"RTN","HLDIEDB1",247,0)
 D MAILADD("The error was '"_$$EC^%ZOSV_"'.")
"RTN","HLDIEDB1",248,0)
 D MAILADD("")
"RTN","HLDIEDB1",249,0)
 D MAILADD("IMPORTANT!!  All debugging was turned off.  Please review the problem,")
"RTN","HLDIEDB1",250,0)
 D MAILADD("             then turn debugging back on.")
"RTN","HLDIEDB1",251,0)
 D MAILADD("")
"RTN","HLDIEDB1",252,0)
 D MAILADD("Local Variable List"),MAILADD("--------------------")
"RTN","HLDIEDB1",253,0)
 ;
"RTN","HLDIEDB1",254,0)
 S X="^TMP("_$J_",""HLVAR""," D DOLRO^%ZOSV
"RTN","HLDIEDB1",255,0)
 S LP="^TMP("_$J_",""HLVAR""",ST=LP_",",LP=LP_")",C=","
"RTN","HLDIEDB1",256,0)
 F  S LP=$Q(@LP) Q:LP'[ST  D
"RTN","HLDIEDB1",257,0)
 .  S DATA=$TR($P($P(LP,ST,2),")"),"""","")
"RTN","HLDIEDB1",258,0)
 .  I DATA[C S DATA=$P(DATA,C)_"("_$P(DATA,C,2,99)_")"
"RTN","HLDIEDB1",259,0)
 .  D MAILADD(DATA_"="_@LP)
"RTN","HLDIEDB1",260,0)
 ;
"RTN","HLDIEDB1",261,0)
 MERGE XMY=SENDUZ
"RTN","HLDIEDB1",262,0)
 I $O(XMY(0))'>0 S XMY(+$G(DUZ))=""
"RTN","HLDIEDB1",263,0)
 ;
"RTN","HLDIEDB1",264,0)
 D ^XMD
"RTN","HLDIEDB1",265,0)
 ;
"RTN","HLDIEDB1",266,0)
 KILL ^TMP($J,"HLMSG"),^TMP($J,"HLVAR")
"RTN","HLDIEDB1",267,0)
 ;
"RTN","HLDIEDB1",268,0)
 D UNWIND^%ZTER
"RTN","HLDIEDB1",269,0)
 ;
"RTN","HLDIEDB1",270,0)
 Q
"RTN","HLDIEDB1",271,0)
 ;
"RTN","HLDIEDB1",272,0)
MAILADD(T) S NO=$G(NO)+1,^TMP($J,"HLMSG",NO)=T
"RTN","HLDIEDB1",273,0)
 QUIT
"RTN","HLDIEDB1",274,0)
 ;
"RTN","HLDIEDB1",275,0)
EOR ;HLDIEDB1 - DEBUG Menu ;1/8/04 @ 01:28
"RTN","HLDIEDB2")
0^93^B312034
"RTN","HLDIEDB2",1,0)
HLDIEDB2 ;CIOFO-O/LJA - Debug $$STORESCR Code ;1/9/04 @ 09:01
"RTN","HLDIEDB2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLDIEDB2",3,0)
 ;
"RTN","HLDIEDB2",4,0)
STORESCR(RTN,LOC,STORE) ; Called by Xecutable M code to set or "unset" (don't
"RTN","HLDIEDB2",5,0)
 ; collect) data...
"RTN","HLDIEDB2",6,0)
 ;
"RTN","HLDIEDB2",7,0)
 ; Steps to add SCREEN logic below
"RTN","HLDIEDB2",8,0)
 ; -------------------------------
"RTN","HLDIEDB2",9,0)
 ; (1) Add M code that evaluates environment and optionally sets STORE.
"RTN","HLDIEDB2",10,0)
 ; (2) Update NEWs at top of STORESCR
"RTN","HLDIEDB2",11,0)
 ;
"RTN","HLDIEDB2",12,0)
 ; Error Handling
"RTN","HLDIEDB2",13,0)
 ; --------------
"RTN","HLDIEDB2",14,0)
 ; What if your M code errors out?  You don't want the call to 
"RTN","HLDIEDB2",15,0)
 ; FILE^HLDIE failing.  But, you do want to be notified about the
"RTN","HLDIEDB2",16,0)
 ; error.  For this reason, error trapping has been added to this
"RTN","HLDIEDB2",17,0)
 ; $$STORESCR API.
"RTN","HLDIEDB2",18,0)
 ;
"RTN","HLDIEDB2",19,0)
 ; In order to set up error handling, you must define in your M code
"RTN","HLDIEDB2",20,0)
 ; the users who should receive an "error notification email message."
"RTN","HLDIEDB2",21,0)
 ; Do this by defining the SENDUZ(DUZ)="" array, with one entry for
"RTN","HLDIEDB2",22,0)
 ; each recipient of the message.
"RTN","HLDIEDB2",23,0)
 ;
"RTN","HLDIEDB2",24,0)
 ;
"RTN","HLDIEDB2",25,0)
 ; >>> Step #2 - Update NEWS After M Code Creations <<<
"RTN","HLDIEDB2",26,0)
 N SENDUZ
"RTN","HLDIEDB2",27,0)
 ;
"RTN","HLDIEDB2",28,0)
 I ^%ZOSF("OS")["DSM" N $ETRAP S $ET=""
"RTN","HLDIEDB2",29,0)
 S X="ERR^HLDIEDB1",@^%ZOSF("TRAP")
"RTN","HLDIEDB2",30,0)
 ;
"RTN","HLDIEDB2",31,0)
 ; RTN = RTN~SUBRTN
"RTN","HLDIEDB2",32,0)
 ; LOC = 1 if at top of FILE^HLDIE call
"RTN","HLDIEDB2",33,0)
 ;     = 2 if at bottom of FILE^HLDIE call
"RTN","HLDIEDB2",34,0)
 ; STORE = "",1,2 (see below)
"RTN","HLDIEDB2",35,0)
 ;
"RTN","HLDIEDB2",36,0)
 ; STORE can be set to the following value...
"RTN","HLDIEDB2",37,0)
 ;
"RTN","HLDIEDB2",38,0)
 ; "" - Don't store anything
"RTN","HLDIEDB2",39,0)
 ;  1 - Store "select" data
"RTN","HLDIEDB2",40,0)
 ;  2 - Store all data
"RTN","HLDIEDB2",41,0)
 ;
"RTN","HLDIEDB2",42,0)
 ; Warning!  The only acceptable action by this API is to change the
"RTN","HLDIEDB2",43,0)
 ;           value of STORE.
"RTN","HLDIEDB2",44,0)
 ;
"RTN","HLDIEDB2",45,0)
 ; >>> Step #1 - M Code Starts Here <<<
"RTN","HLDIEDB2",46,0)
 ;
"RTN","HLDIEDB2",47,0)
 ; Create list of recipients of error notification message now!
"RTN","HLDIEDB2",48,0)
 ;
"RTN","HLDIEDB2",49,0)
 ;
"RTN","HLDIEDB2",50,0)
 ;
"RTN","HLDIEDB2",51,0)
 ;
"RTN","HLDIEDB2",52,0)
 ;
"RTN","HLDIEDB2",53,0)
 ;
"RTN","HLDIEDB2",54,0)
 ;
"RTN","HLDIEDB2",55,0)
 ;
"RTN","HLDIEDB2",56,0)
 ; >>> M Code Ends Here <<<
"RTN","HLDIEDB2",57,0)
 ;
"RTN","HLDIEDB2",58,0)
 Q STORE
"RTN","HLDIEDB2",59,0)
 ;
"RTN","HLDIEDB2",60,0)
EOR ;HLDIEDB2 - Debug $$STORESCR Code ;1/9/04 @ 09:01
"RTN","HLDIEDB3")
0^94^B5978888
"RTN","HLDIEDB3",1,0)
HLDIEDB3 ;CIOFO-O/LJA - Debug Data Display Code ;12/29/03 10:39
"RTN","HLDIEDB3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLDIEDB3",3,0)
 ;
"RTN","HLDIEDB3",4,0)
JOB ; Display information by job#...
"RTN","HLDIEDB3",5,0)
 N JOBNO
"RTN","HLDIEDB3",6,0)
 ;
"RTN","HLDIEDB3",7,0)
 KILL ^TMP($J)
"RTN","HLDIEDB3",8,0)
 ;
"RTN","HLDIEDB3",9,0)
J1 D SHOWJOB
"RTN","HLDIEDB3",10,0)
 ;
"RTN","HLDIEDB3",11,0)
J2 R !!,"Enter job#: ",JOBNO:99 Q:JOBNO']""!(JOBNO[U)  ;->
"RTN","HLDIEDB3",12,0)
 I '$D(^TMP($J,"HLJOB",JOBNO)) D  G J2 ;->
"RTN","HLDIEDB3",13,0)
 .  W "  invalid job#..."
"RTN","HLDIEDB3",14,0)
 ;
"RTN","HLDIEDB3",15,0)
 D JOBSHOW(JOBNO)
"RTN","HLDIEDB3",16,0)
 ;
"RTN","HLDIEDB3",17,0)
 G J1 ;->
"RTN","HLDIEDB3",18,0)
 ;
"RTN","HLDIEDB3",19,0)
SHOWJOB ;
"RTN","HLDIEDB3",20,0)
 N C2,CT,CALL,CT,DATA,DATE,JOB,HLDIE,LOOP,NO
"RTN","HLDIEDB3",21,0)
 ;
"RTN","HLDIEDB3",22,0)
 S HLDIE="HLDIE-DEBUG-",LOOP=HLDIE,CT=0
"RTN","HLDIEDB3",23,0)
 F  S LOOP=$O(^XTMP(LOOP)) Q:LOOP'[HLDIE  D
"RTN","HLDIEDB3",24,0)
 .  S JOB=0,DATE=$P(LOOP,"-",3)
"RTN","HLDIEDB3",25,0)
 .  F  S JOB=$O(^XTMP(LOOP,JOB)) Q:'JOB  D
"RTN","HLDIEDB3",26,0)
 .  .  S CALL=""
"RTN","HLDIEDB3",27,0)
 .  .  F  S CALL=$O(^XTMP(LOOP,JOB,CALL)) Q:CALL']""  D
"RTN","HLDIEDB3",28,0)
 .  .  .  S NO=0
"RTN","HLDIEDB3",29,0)
 .  .  .  F  S NO=$O(^XTMP(LOOP,JOB,CALL,NO)) Q:'NO  D
"RTN","HLDIEDB3",30,0)
 .  .  .  .  S DATA=^XTMP(LOOP,JOB,CALL,NO),LOC=+DATA
"RTN","HLDIEDB3",31,0)
 .  .  .  .  S CT=CT+1,^TMP($J,"HLJOB",JOB,CT)=CALL_"~"_DATA
"RTN","HLDIEDB3",32,0)
 .  .  .  .  S ^TMP($J,"HLJOBX",JOB,CALL,NO)=DATA
"RTN","HLDIEDB3",33,0)
 ;
"RTN","HLDIEDB3",34,0)
 S C2=20
"RTN","HLDIEDB3",35,0)
 ;
"RTN","HLDIEDB3",36,0)
 W !!,"Job",?C2,"Calls"
"RTN","HLDIEDB3",37,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLDIEDB3",38,0)
 ;
"RTN","HLDIEDB3",39,0)
 S JOB=0,CT=0
"RTN","HLDIEDB3",40,0)
 F  S JOB=$O(^TMP($J,"HLJOBX",JOB)) Q:'JOB  D
"RTN","HLDIEDB3",41,0)
 .  S CT=CT+1
"RTN","HLDIEDB3",42,0)
 .  W:CT>1 !
"RTN","HLDIEDB3",43,0)
 .  W !,JOB,?C2
"RTN","HLDIEDB3",44,0)
 .  S CALL=""
"RTN","HLDIEDB3",45,0)
 .  F  S CALL=$O(^TMP($J,"HLJOBX",JOB,CALL)) Q:CALL']""  D
"RTN","HLDIEDB3",46,0)
 .  .  W:($X+$L(CALL)+3)>IOM ! W:$X<C2 ?C2
"RTN","HLDIEDB3",47,0)
 .  .  W:$X>C2 ", "
"RTN","HLDIEDB3",48,0)
 .  .  W CALL
"RTN","HLDIEDB3",49,0)
 ;
"RTN","HLDIEDB3",50,0)
 Q
"RTN","HLDIEDB3",51,0)
 ;
"RTN","HLDIEDB3",52,0)
JOBSHOW(JOBNO) ;
"RTN","HLDIEDB3",53,0)
 N ABORT,CONT,CT,GBL,LOC,NO
"RTN","HLDIEDB3",54,0)
 ;
"RTN","HLDIEDB3",55,0)
 S GBL="^TMP("_$J_",""HLJOB"","_JOBNO_")"
"RTN","HLDIEDB3",56,0)
 ;
"RTN","HLDIEDB3",57,0)
 D SHOWDTHD^HLDIEDB0
"RTN","HLDIEDB3",58,0)
 ;
"RTN","HLDIEDB3",59,0)
 S NO=0,ABORT=0,CT=0,CONT=0
"RTN","HLDIEDB3",60,0)
 F  S NO=$O(@GBL@(NO)) Q:'NO!(ABORT)  D
"RTN","HLDIEDB3",61,0)
 .  D LOADIT(NO)
"RTN","HLDIEDB3",62,0)
 .  D EADTHD^HLDIEDB0(NO,FILE,IEN,LDT,JOBNO,RTN,NO,LOC)
"RTN","HLDIEDB3",63,0)
 .  S CT=CT+1
"RTN","HLDIEDB3",64,0)
 .  I 'CONT,'(CT#22) R X:60 S:X=" " CONT=1 S:X[U ABORT=1
"RTN","HLDIEDB3",65,0)
 ;
"RTN","HLDIEDB3",66,0)
 F  D  QUIT:'NO
"RTN","HLDIEDB3",67,0)
 .  R !,"Enter #: ",NO:99 Q:NO']""!(NO[U)  ;->
"RTN","HLDIEDB3",68,0)
 .  D LOADIT(NO)
"RTN","HLDIEDB3",69,0)
 .  D INDIV^HLDIEDB0(LDT\1,JOBNO,RTN,LOC)
"RTN","HLDIEDB3",70,0)
 ;
"RTN","HLDIEDB3",71,0)
 Q
"RTN","HLDIEDB3",72,0)
 ;
"RTN","HLDIEDB3",73,0)
LOADIT(NO) ;
"RTN","HLDIEDB3",74,0)
 ; GBL -- req
"RTN","HLDIEDB3",75,0)
 S DATA=@GBL@(NO),RTN=$P(DATA,"~",1,2),DATA=$P(DATA,"~",3,999)
"RTN","HLDIEDB3",76,0)
 S FILE=$P(DATA,U,3),IEN=$P(DATA,U,4),LDT=$P(DATA,U,2)
"RTN","HLDIEDB3",77,0)
 S LOC=$P(DATA,U)
"RTN","HLDIEDB3",78,0)
 Q
"RTN","HLDIEDB3",79,0)
 ;
"RTN","HLDIEDB3",80,0)
EOR ;HLDIEDB3 - Direct 772 & 773 Sets DEBUG CODE ; 11/18/2003 11:17
"RTN","HLDIEDBG")
0^92^B48025803
"RTN","HLDIEDBG",1,0)
HLDIEDBG ;CIOFO-O/LJA - Direct 772 & 773 Sets DEBUG CODE ;12/29/03 10:39
"RTN","HLDIEDBG",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLDIEDBG",3,0)
 ;
"RTN","HLDIEDBG",4,0)
 ; D MENU^HLDIE to invoke debug menu.  Debugger documentation included.
"RTN","HLDIEDBG",5,0)
 ;
"RTN","HLDIEDBG",6,0)
MENU ; Additional documentation available in INIT^HLDIEDB1...
"RTN","HLDIEDBG",7,0)
 D INIT^HLDIEDB1
"RTN","HLDIEDBG",8,0)
 Q
"RTN","HLDIEDBG",9,0)
 ;
"RTN","HLDIEDBG",10,0)
SETDEBUG ; Set or "unset" the DEBUG string...
"RTN","HLDIEDBG",11,0)
 N IOBOFF,IOBON,IOINHI,IOINORM,NEWSTR,STRING,X
"RTN","HLDIEDBG",12,0)
 W @IOF,$$CJ^XLFSTR("HLDIE Debug String Set/Unset Utility",IOM)
"RTN","HLDIEDBG",13,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLDIEDBG",14,0)
 ;
"RTN","HLDIEDBG",15,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLDIEDBG",16,0)
 ;
"RTN","HLDIEDBG",17,0)
 ; Ask for a new string...
"RTN","HLDIEDBG",18,0)
 W !!,"When asked for a new debug string, you may take one of the following actions:"
"RTN","HLDIEDBG",19,0)
 W !!," * Enter RETURN or '^' to exit."
"RTN","HLDIEDBG",20,0)
 W !," * Enter a debug string.  (E.g., '1' or '1^2' or '1^1^1'.)"
"RTN","HLDIEDBG",21,0)
 W !," * Enter '@' to delete the debug string, (If a debug string exists)."
"RTN","HLDIEDBG",22,0)
 ;
"RTN","HLDIEDBG",23,0)
SET1 ;
"RTN","HLDIEDBG",24,0)
 ; Get current DEBUG value...
"RTN","HLDIEDBG",25,0)
 S STRING=$G(^XTMP("HLDIE-DEBUG","STATUS"))
"RTN","HLDIEDBG",26,0)
 ;
"RTN","HLDIEDBG",27,0)
 ; Show user current value...
"RTN","HLDIEDBG",28,0)
 W !!!!,"Current DEBUG string = ",IOINHI,STRING,IOINORM
"RTN","HLDIEDBG",29,0)
 ;
"RTN","HLDIEDBG",30,0)
 ; Get new debug string...
"RTN","HLDIEDBG",31,0)
 W !!,"Enter DEBUG string, ",$S(STRING]"":"'@', ",1:""),"or RETURN to exit: "
"RTN","HLDIEDBG",32,0)
 R NEWSTR:999 QUIT:'$T  ;->
"RTN","HLDIEDBG",33,0)
 ;
"RTN","HLDIEDBG",34,0)
 ; Exit conditions...
"RTN","HLDIEDBG",35,0)
 I NEWSTR=U!(NEWSTR']"") D  QUIT  ;->
"RTN","HLDIEDBG",36,0)
 .  I STRING']"" D  QUIT  ;->
"RTN","HLDIEDBG",37,0)
 .  .  W "   no changes made.  Exiting... "
"RTN","HLDIEDBG",38,0)
 .  .  H 2
"RTN","HLDIEDBG",39,0)
 .  W !!,"No changes made.  (If you want to stop debugging, enter '"
"RTN","HLDIEDBG",40,0)
 .  W IOINHI,"@",IOINORM,"'.)  Exiting..."
"RTN","HLDIEDBG",41,0)
 ;
"RTN","HLDIEDBG",42,0)
 ; Reset to null if @...
"RTN","HLDIEDBG",43,0)
 I NEWSTR="@" S NEWSTR=""
"RTN","HLDIEDBG",44,0)
 ;
"RTN","HLDIEDBG",45,0)
 ; User didn't change anything!!!
"RTN","HLDIEDBG",46,0)
 I NEWSTR=STRING W "  no changes made... " G SET1 ;->
"RTN","HLDIEDBG",47,0)
 ;
"RTN","HLDIEDBG",48,0)
 ; If debug string to be set to null...
"RTN","HLDIEDBG",49,0)
 I NEWSTR']"" D  G SET1 ;->
"RTN","HLDIEDBG",50,0)
 .  KILL ^XTMP("HLDIE-DEBUG","STATUS")
"RTN","HLDIEDBG",51,0)
 .  W "  stopped all debugging!"
"RTN","HLDIEDBG",52,0)
 ;
"RTN","HLDIEDBG",53,0)
 ; Debug string has text, so just set it...
"RTN","HLDIEDBG",54,0)
 S ^XTMP("HLDIE-DEBUG",0)=$$FMADD^XLFDT(DT,7)_U_$$NOW^XLFDT_U_"Control string for HLDIE debugging"
"RTN","HLDIEDBG",55,0)
 S ^XTMP("HLDIE-DEBUG","STATUS")=NEWSTR
"RTN","HLDIEDBG",56,0)
 W "  debugging set..."
"RTN","HLDIEDBG",57,0)
 ;
"RTN","HLDIEDBG",58,0)
 Q
"RTN","HLDIEDBG",59,0)
 ;
"RTN","HLDIEDBG",60,0)
 ;
"RTN","HLDIEDBG",61,0)
 ; ================================================================
"RTN","HLDIEDBG",62,0)
 ;
"RTN","HLDIEDBG",63,0)
 ;
"RTN","HLDIEDBG",64,0)
DEBUG(RTN,LOC,STORE,XEC) ; Store debug data... (Don't call unless all
"RTN","HLDIEDBG",65,0)
 ; checks have been made and debug data IS to be stored!)
"RTN","HLDIEDBG",66,0)
 ;
"RTN","HLDIEDBG",67,0)
 ; ROOT() -- req
"RTN","HLDIEDBG",68,0)
 ;
"RTN","HLDIEDBG",69,0)
 ; RTN -- Where (subrtn~rtn, usually) call to FILE^HLDIE made from.
"RTN","HLDIEDBG",70,0)
 ;
"RTN","HLDIEDBG",71,0)
 ; LOC -- Location... BEFORE FILE^HLDIE call = 1
"RTN","HLDIEDBG",72,0)
 ;                    AFTER FILE^HLDIE call = 2
"RTN","HLDIEDBG",73,0)
 ;
"RTN","HLDIEDBG",74,0)
 ; STORE -- "" = Don't collect
"RTN","HLDIEDBG",75,0)
 ;           1 = Collect "select" (see above) data.
"RTN","HLDIEDBG",76,0)
 ;           2 = Collect "all" data.
"RTN","HLDIEDBG",77,0)
 ;
"RTN","HLDIEDBG",78,0)
 ; XEC -- If XEC=1 then S STORE=$$STORE^HLDIEDB0(RTN,LOC,STORE) is
"RTN","HLDIEDBG",79,0)
 ;        called to optionally change the value of STORE (and thus
"RTN","HLDIEDBG",80,0)
 ;        control whether data is stored.)
"RTN","HLDIEDBG",81,0)
 ;
"RTN","HLDIEDBG",82,0)
 N CT,DEBUGNO,DEBUGNOW,HLFILE,HLIEN,INCRNO,NO,X,XTMP
"RTN","HLDIEDBG",83,0)
 ;
"RTN","HLDIEDBG",84,0)
 S DEBUGNOW=$$NOW^XLFDT,DT=DEBUGNOW\1
"RTN","HLDIEDBG",85,0)
 ;
"RTN","HLDIEDBG",86,0)
 ; Get file and ien for storing in XTMP...
"RTN","HLDIEDBG",87,0)
 S FILE=$G(FILE),IEN=$G(IEN)
"RTN","HLDIEDBG",88,0)
 I FILE,IEN S HLFILE=FILE,HLIEN=IEN
"RTN","HLDIEDBG",89,0)
 I 'FILE!('IEN) D
"RTN","HLDIEDBG",90,0)
 .  S (HLFILE,HLIEN)=0
"RTN","HLDIEDBG",91,0)
 .  I $G(ROOT)]"" S HLFILE=$O(@ROOT@(0)),HLIEN=+$O(@ROOT@(+HLFILE,""))
"RTN","HLDIEDBG",92,0)
 ;
"RTN","HLDIEDBG",93,0)
 ; Get storage number...
"RTN","HLDIEDBG",94,0)
 S DEBUGNO=$O(^XTMP("HLDIE-DEBUG-"_DT,$J,RTN,":"),-1)+1
"RTN","HLDIEDBG",95,0)
 ;
"RTN","HLDIEDBG",96,0)
 ; How many stored?  Can't store more than 20...
"RTN","HLDIEDBG",97,0)
 S CT=0,NO=0
"RTN","HLDIEDBG",98,0)
 F  S NO=$O(^XTMP("HLDIE-DEBUG-"_DT,$J,RTN,NO)) Q:'NO  D
"RTN","HLDIEDBG",99,0)
 .  S CT=CT+1
"RTN","HLDIEDBG",100,0)
 ;
"RTN","HLDIEDBG",101,0)
 ; If M code passed, check w/^DIM, then execute.
"RTN","HLDIEDBG",102,0)
 I XEC=1 S STORE=$$STORESCR^HLDIEDB2(RTN,LOC,STORE) QUIT:'STORE  ;->
"RTN","HLDIEDBG",103,0)
 ;
"RTN","HLDIEDBG",104,0)
ERRESUME ; If $$STORESCR code errors, there has to be a place for
"RTN","HLDIEDBG",105,0)
 ; error trapping to GOTO.  This is that place...
"RTN","HLDIEDBG",106,0)
 ;
"RTN","HLDIEDBG",107,0)
 ; Quit if 20 occurences stored...
"RTN","HLDIEDBG",108,0)
 QUIT:CT'<20  ;->
"RTN","HLDIEDBG",109,0)
 ;
"RTN","HLDIEDBG",110,0)
 ; Zero node & XTMP...
"RTN","HLDIEDBG",111,0)
 ;
"RTN","HLDIEDBG",112,0)
 ; Debug data retained for 7 days...
"RTN","HLDIEDBG",113,0)
 S XTMP="HLDIE-DEBUG-"_DT
"RTN","HLDIEDBG",114,0)
 S:$G(^XTMP(XTMP,0))']"" ^XTMP(XTMP,0)=$$FMADD^XLFDT(DT,7)_U_DEBUGNOW_U_"Debug data created by HLDIEDBG routine"
"RTN","HLDIEDBG",115,0)
 ;
"RTN","HLDIEDBG",116,0)
 ; Xref data retain for 7 days from last time any DEBUG data created...
"RTN","HLDIEDBG",117,0)
 S XTMP="HLDIE-DEBUGX"
"RTN","HLDIEDBG",118,0)
 S:$G(^XTMP(XTMP,0))']"" ^XTMP(XTMP,0)=$$FMADD^XLFDT(DT,7)_U_$$NOW^XLFDT_U_"Debug data created by HLDIEDBG routine"
"RTN","HLDIEDBG",119,0)
 I $P(^XTMP(XTMP,0),U)'=$$FMADD^XLFDT(DT,7) S $P(^XTMP(XTMP,0),U)=$$FMADD^XLFDT(DT,7)
"RTN","HLDIEDBG",120,0)
 ;
"RTN","HLDIEDBG",121,0)
 ; Get incremental number...
"RTN","HLDIEDBG",122,0)
 S INCRNO=$I(^XTMP("HLDIE-DEBUGN","N"),1)
"RTN","HLDIEDBG",123,0)
 ;
"RTN","HLDIEDBG",124,0)
 ; Do following for STORE=1 and STORE=2...
"RTN","HLDIEDBG",125,0)
 S ^XTMP("HLDIE-DEBUG-"_DT,$J,RTN,+DEBUGNO)=LOC_U_DEBUGNOW_U_$G(HLFILE)_U_$G(HLIEN)_U_$TR($P($G(XQY0),U,1,2),U,"~")_U_$TR($G(HLEDITOR),U,"~")
"RTN","HLDIEDBG",126,0)
 D STOREMSG(+$G(HLFILE),+$G(HLIEN),RTN,DEBUGNO,LOC,INCRNO)
"RTN","HLDIEDBG",127,0)
 ;
"RTN","HLDIEDBG",128,0)
 ; Store "select" data...
"RTN","HLDIEDBG",129,0)
 I STORE=1,LOC'=2,$G(ROOT)]"" D  QUIT  ;->
"RTN","HLDIEDBG",130,0)
 .  MERGE ^XTMP("HLDIE-DEBUG-"_DT,$J,RTN,+DEBUGNO)=@ROOT
"RTN","HLDIEDBG",131,0)
 ;
"RTN","HLDIEDBG",132,0)
 QUIT:STORE'=2  ;->
"RTN","HLDIEDBG",133,0)
 ;
"RTN","HLDIEDBG",134,0)
 ; Store "all" local variable data...
"RTN","HLDIEDBG",135,0)
 S X="^XTMP(""HLDIE-DEBUG-"_DT_""","_$J_","""_RTN_""","_DEBUGNO_","
"RTN","HLDIEDBG",136,0)
 D DOLRO^%ZOSV
"RTN","HLDIEDBG",137,0)
 ;
"RTN","HLDIEDBG",138,0)
 D ONLYASC(X)
"RTN","HLDIEDBG",139,0)
 ;
"RTN","HLDIEDBG",140,0)
 Q
"RTN","HLDIEDBG",141,0)
 ;
"RTN","HLDIEDBG",142,0)
ONLYASC(REF) ; Convert control characters to {ASCII}...
"RTN","HLDIEDBG",143,0)
 N DATA,LP
"RTN","HLDIEDBG",144,0)
 ;
"RTN","HLDIEDBG",145,0)
 S LP=$E(REF,1,$L(REF)-1)_")"
"RTN","HLDIEDBG",146,0)
 F  S LP=$Q(@LP) Q:LP'[REF  D
"RTN","HLDIEDBG",147,0)
 .  S DATA=$$ONLYASC^HLDIEDB0(@LP)
"RTN","HLDIEDBG",148,0)
 .  I $L(DATA),$TR(DATA," ","")']"" S DATA="{#"_$L(DATA)_" spaces}"
"RTN","HLDIEDBG",149,0)
 .  S @LP=DATA
"RTN","HLDIEDBG",150,0)
 ;
"RTN","HLDIEDBG",151,0)
 Q
"RTN","HLDIEDBG",152,0)
 ;
"RTN","HLDIEDBG",153,0)
STOREMSG(FILE,IEN,RTN,DEBUGNO,LOC,INCRNO) ; Store message data in ^XTMP...
"RTN","HLDIEDBG",154,0)
 ; DEBUGNOW -- req
"RTN","HLDIEDBG",155,0)
 N GBL,NODE
"RTN","HLDIEDBG",156,0)
 ;
"RTN","HLDIEDBG",157,0)
 ; Set XREF XTMP...
"RTN","HLDIEDBG",158,0)
 S ^XTMP("HLDIE-DEBUGX",FILE,IEN,DEBUGNOW,$J,RTN,DEBUGNO)=LOC_U_$TR($G(HLEDITOR),U,"~")
"RTN","HLDIEDBG",159,0)
 S ^XTMP("HLDIE-DEBUGN","N",INCRNO)=FILE_U_IEN_U_DEBUGNOW_U_$J_U_RTN_U_DEBUGNO_U_LOC_U_$TR($G(HLEDITOR),U,"~")
"RTN","HLDIEDBG",160,0)
 ;
"RTN","HLDIEDBG",161,0)
 ; Get GBL...
"RTN","HLDIEDBG",162,0)
 S GBL=$S(FILE=772:"^HL(772,"_IEN_")",1:"^HLMA("_IEN_")")
"RTN","HLDIEDBG",163,0)
 ;
"RTN","HLDIEDBG",164,0)
 ; Collect message data...
"RTN","HLDIEDBG",165,0)
 F NODE=0,1,2,"P","S",$S(FILE=772:"IN",1:"MSH") D NODE(GBL,NODE)
"RTN","HLDIEDBG",166,0)
 ;
"RTN","HLDIEDBG",167,0)
 Q
"RTN","HLDIEDBG",168,0)
 ;
"RTN","HLDIEDBG",169,0)
NODE(GBL,NODE) ; Collect message data...
"RTN","HLDIEDBG",170,0)
 ; RTN,DEBUGNO -- req
"RTN","HLDIEDBG",171,0)
 N LAST,LNO,TXT,X
"RTN","HLDIEDBG",172,0)
 ;
"RTN","HLDIEDBG",173,0)
 I NODE="MSH" D  QUIT  ;->
"RTN","HLDIEDBG",174,0)
 .  N LNO,TXT
"RTN","HLDIEDBG",175,0)
 .  S LNO=0
"RTN","HLDIEDBG",176,0)
 .  F  S LNO=$O(@GBL@("MSH",LNO)) Q:'LNO  D
"RTN","HLDIEDBG",177,0)
 .  .  S TXT=$G(@GBL@("MSH",+LNO,0)) QUIT:TXT']""  ;->
"RTN","HLDIEDBG",178,0)
 .  .  S ^XTMP("HLDIE-DEBUG-"_DT,$J,RTN,DEBUGNO,"D","MSH",LNO,0)=TXT
"RTN","HLDIEDBG",179,0)
 ;
"RTN","HLDIEDBG",180,0)
 I NODE="IN" D  QUIT  ;->
"RTN","HLDIEDBG",181,0)
 .  N LAST,TXT
"RTN","HLDIEDBG",182,0)
 .  S LAST=$O(@GBL@("IN",":"),-1)
"RTN","HLDIEDBG",183,0)
 .  S TXT=$G(@GBL@("IN",1,0)) QUIT:TXT']""  ;->
"RTN","HLDIEDBG",184,0)
 .  S ^XTMP("HLDIE-DEBUG-"_DT,$J,RTN,DEBUGNO,"D","IN",1,0)=1_":"_LAST_"~"_TXT
"RTN","HLDIEDBG",185,0)
 ;
"RTN","HLDIEDBG",186,0)
 ; Store node...
"RTN","HLDIEDBG",187,0)
 S X=$G(@GBL@(NODE)) I X]"" S ^XTMP("HLDIE-DEBUG-"_DT,$J,RTN,DEBUGNO,"D",NODE)=X
"RTN","HLDIEDBG",188,0)
 ;
"RTN","HLDIEDBG",189,0)
 Q
"RTN","HLDIEDBG",190,0)
 ;
"RTN","HLDIEDBG",191,0)
KILLALL ; Don't call here unless it's OK to remove ALL-ALL debug data...
"RTN","HLDIEDBG",192,0)
 N KILL,OFF,XTMP
"RTN","HLDIEDBG",193,0)
 ;
"RTN","HLDIEDBG",194,0)
 I $O(^XTMP("HLDIE-DEBUG"))']"HLDIE-DEBUG" D  QUIT  ;->
"RTN","HLDIEDBG",195,0)
 .  W !!,"No debug data exists..."
"RTN","HLDIEDBG",196,0)
 ;
"RTN","HLDIEDBG",197,0)
 W !
"RTN","HLDIEDBG",198,0)
 S KILL=$$YN^HLCSRPT4("Kill **ALL** debug data","No")
"RTN","HLDIEDBG",199,0)
 I 'KILL W "  no data will be killed..." QUIT  ;->
"RTN","HLDIEDBG",200,0)
 ;
"RTN","HLDIEDBG",201,0)
 W !!,"KILLing all debug data..."
"RTN","HLDIEDBG",202,0)
 S XTMP="HLDIE-DEBUG"
"RTN","HLDIEDBG",203,0)
 F  S XTMP=$O(^XTMP(XTMP)) Q:XTMP'["HLDIE-DEBUG"  D
"RTN","HLDIEDBG",204,0)
 .  KILL ^XTMP(XTMP)
"RTN","HLDIEDBG",205,0)
 ;
"RTN","HLDIEDBG",206,0)
 Q
"RTN","HLDIEDBG",207,0)
 ;
"RTN","HLDIEDBG",208,0)
LOG(SUBSV,KEEP,STOP) ; Log local vars into ^XTMP("HLDIE "_DT)...
"RTN","HLDIEDBG",209,0)
 ;
"RTN","HLDIEDBG",210,0)
 ; Documentation in MENU^HLDIE...
"RTN","HLDIEDBG",211,0)
 ;
"RTN","HLDIEDBG",212,0)
 N NO,NOW,NOXTMP,X,XTMP
"RTN","HLDIEDBG",213,0)
 ;
"RTN","HLDIEDBG",214,0)
 ; Presets...
"RTN","HLDIEDBG",215,0)
 S SUBSV=$G(SUBSV),KEEP=$G(KEEP),STOP=$G(STOP),NOXTMP=0,NOW=$$NOW^XLFDT
"RTN","HLDIEDBG",216,0)
 S SUBSV=$TR($S(SUBSV]"":SUBSV,1:"UNKNOWN"),"""","")
"RTN","HLDIEDBG",217,0)
 ;
"RTN","HLDIEDBG",218,0)
 ; # to keep setup...
"RTN","HLDIEDBG",219,0)
 S KEEP=$S(KEEP&(KEEP<100):KEEP,1:20)
"RTN","HLDIEDBG",220,0)
 ;
"RTN","HLDIEDBG",221,0)
 ; XTMP setup...
"RTN","HLDIEDBG",222,0)
 S XTMP="HLDIE-"_DT
"RTN","HLDIEDBG",223,0)
 S:'$D(^XTMP(XTMP,0)) ^XTMP(XTMP,0)=$$FMADD^XLFDT(NOW,7)_U_$$NOW^XLFDT_U_"Data logged by LOG~HLDIE"
"RTN","HLDIEDBG",224,0)
 ;
"RTN","HLDIEDBG",225,0)
 ; Count number entries...
"RTN","HLDIEDBG",226,0)
 I STOP=1 D
"RTN","HLDIEDBG",227,0)
 .  S NOXTMP=0,NO=0
"RTN","HLDIEDBG",228,0)
 .  F  S NO=$O(^XTMP(XTMP,SUBSV,NO)) Q:'NO  D
"RTN","HLDIEDBG",229,0)
 .  .  S NOXTMP=NOXTMP+1
"RTN","HLDIEDBG",230,0)
 ;
"RTN","HLDIEDBG",231,0)
 ; Incremented sequential store #...
"RTN","HLDIEDBG",232,0)
 S NO=$O(^XTMP(XTMP,SUBSV,":"),-1)+1
"RTN","HLDIEDBG",233,0)
 ;
"RTN","HLDIEDBG",234,0)
 ; STOP now?
"RTN","HLDIEDBG",235,0)
 I STOP,NOXTMP'<KEEP QUIT  ;->
"RTN","HLDIEDBG",236,0)
 ;
"RTN","HLDIEDBG",237,0)
 ; Store all local variables...
"RTN","HLDIEDBG",238,0)
 S X="^XTMP("""_XTMP_""","""_SUBSV_""","_NO_"," D DOLRO^%ZOSV
"RTN","HLDIEDBG",239,0)
 S ^XTMP(XTMP,SUBSV,NO)=$$NOW^XLFDT
"RTN","HLDIEDBG",240,0)
 ;
"RTN","HLDIEDBG",241,0)
 I $ZE]"" S ^XTMP(XTMP,SUBSV,NO,"$ZE")=$ZE
"RTN","HLDIEDBG",242,0)
 ;
"RTN","HLDIEDBG",243,0)
 ; Keep only KEEP instances...
"RTN","HLDIEDBG",244,0)
 F NO=NO-KEEP:-1:1 KILL ^XTMP(XTMP,SUBSV,NO)
"RTN","HLDIEDBG",245,0)
 ;
"RTN","HLDIEDBG",246,0)
 Q
"RTN","HLDIEDBG",247,0)
 ;
"RTN","HLDIEDBG",248,0)
EOR ;HLDIEDBG - Direct 772 & 773 Sets DEBUG CODE ; 11/18/2003 11:17
"RTN","HLEMDD")
0^36^B21024093
"RTN","HLEMDD",1,0)
HLEMDD ;ALB/CJM-HL7 - M CODE FOUND IN THE DD'S ;02/04/2004
"RTN","HLEMDD",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEMDD",3,0)
 ;
"RTN","HLEMDD",4,0)
 ;
"RTN","HLEMDD",5,0)
KILLAH(IEN) ;kills the AH x~ref on file 776.4 or a particular event=ien
"RTN","HLEMDD",6,0)
 Q:'$G(IEN)
"RTN","HLEMDD",7,0)
 N NEXT,LOCATION
"RTN","HLEMDD",8,0)
 S NEXT=""
"RTN","HLEMDD",9,0)
 F  S NEXT=$O(^HLEV(776.4,"AH KILL",IEN,NEXT)) Q:'$L(NEXT)  D
"RTN","HLEMDD",10,0)
 .S LOCATION="^HLEV(776.4,""AH"","_NEXT
"RTN","HLEMDD",11,0)
 .K @LOCATION
"RTN","HLEMDD",12,0)
 K ^HLEV(776.4,"AH KILL",IEN)
"RTN","HLEMDD",13,0)
 Q
"RTN","HLEMDD",14,0)
 ;
"RTN","HLEMDD",15,0)
SETID(IEN) ;sets the value of the ID field in the EVENT
"RTN","HLEMDD",16,0)
 ;Input:  IEN is the ien of the Monitor Event
"RTN","HLEMDD",17,0)
 ;Output: none
"RTN","HLEMDD",18,0)
 ;
"RTN","HLEMDD",19,0)
 Q:'$G(IEN)
"RTN","HLEMDD",20,0)
 Q:'$D(^HLEV(776.4,IEN,0))
"RTN","HLEMDD",21,0)
 S $P(^HLEV(776.4,IEN,0),"^",4)=$$STATNUM^HLEMU_"-"_IEN
"RTN","HLEMDD",22,0)
 Q
"RTN","HLEMDD",23,0)
 ;
"RTN","HLEMDD",24,0)
STATUS(IEN,STATUS) ;
"RTN","HLEMDD",25,0)
 ;if the REVIEW STATUS is REQUIRED ONLY IF ACTION FAILS then  when the ACTION STATUS field changes the REVIEW STATUS is updated appropriately
"RTN","HLEMDD",26,0)
 ;
"RTN","HLEMDD",27,0)
 ;
"RTN","HLEMDD",28,0)
 Q:'$G(IEN)
"RTN","HLEMDD",29,0)
 Q:($G(STATUS)<3)
"RTN","HLEMDD",30,0)
 N NODE,REVIEW
"RTN","HLEMDD",31,0)
 S NODE=$G(^HLEV(776.4,IEN,0))
"RTN","HLEMDD",32,0)
 S REVIEW=$P(NODE,"^",6)
"RTN","HLEMDD",33,0)
 I REVIEW=2 D
"RTN","HLEMDD",34,0)
 .I STATUS=3 S $P(^HLEV(776.4,IEN,0),"^",6)=0
"RTN","HLEMDD",35,0)
 .I STATUS=4 S $P(^HLEV(776.4,IEN,0),"^",6)=1
"RTN","HLEMDD",36,0)
 Q
"RTN","HLEMDD",37,0)
 ;
"RTN","HLEMDD",38,0)
ADDSTAT(NEWTIME,OLDSITE,SITE,TYPE,STATUS,COUNT) ;
"RTN","HLEMDD",39,0)
 ;Description - add logic for the AF x~ref on the Monitor Event file.
"RTN","HLEMDD",40,0)
 ;Maintains statistics for events.
"RTN","HLEMDD",41,0)
 ;Input:
"RTN","HLEMDD",42,0)
 ;  NEWTIME - new value of the .01 field (DT/TM)
"RTN","HLEMDD",43,0)
 ;  OLDSITE - old value of the SITE field
"RTN","HLEMDD",44,0)
 ;  SITE - new value of the SITE field
"RTN","HLEMDD",45,0)
 ;  TYPE - new value of the TYPE field
"RTN","HLEMDD",46,0)
 ;  STATUS - new value of the REVIEW STATUS field
"RTN","HLEMDD",47,0)
 ;  COUNT - the new value of the COUNT field
"RTN","HLEMDD",48,0)
 ;Output:  see DD for description of the AF x~ref
"RTN","HLEMDD",49,0)
 ;
"RTN","HLEMDD",50,0)
 Q:'($G(NEWTIME)&$G(SITE)&$G(TYPE)&$L($G(STATUS)))
"RTN","HLEMDD",51,0)
 ;
"RTN","HLEMDD",52,0)
 N INDEX
"RTN","HLEMDD",53,0)
 S INDEX="^HLEV(776.4,""AF"",SITE,TYPE)"
"RTN","HLEMDD",54,0)
 ;
"RTN","HLEMDD",55,0)
 ;COUNT must be ast least 1
"RTN","HLEMDD",56,0)
 S COUNT=$G(COUNT,1)
"RTN","HLEMDD",57,0)
 ;
"RTN","HLEMDD",58,0)
 I '$G(OLDSITE) D
"RTN","HLEMDD",59,0)
 .N YEAR,MONTH,DAY,HOUR
"RTN","HLEMDD",60,0)
 .S YEAR=$$YEAR(NEWTIME),MONTH=$$MONTH(NEWTIME),DAY=$$DAY(NEWTIME),HOUR=$$HOUR(NEWTIME)
"RTN","HLEMDD",61,0)
 .I YEAR,$$I^HLEMU($NA(@INDEX@("RECEIVED","YEAR",YEAR)),COUNT) D
"RTN","HLEMDD",62,0)
 ..I MONTH,$$I^HLEMU($NA(@INDEX@("RECEIVED","YEAR",YEAR,"MONTH",MONTH)),COUNT) D
"RTN","HLEMDD",63,0)
 ...I DAY,$$I^HLEMU($NA(@INDEX@("RECEIVED","YEAR",YEAR,"MONTH",MONTH,"DAY",DAY)),COUNT) D
"RTN","HLEMDD",64,0)
 ....I HOUR,$$I^HLEMU($NA(@INDEX@("RECEIVED","YEAR",YEAR,"MONTH",MONTH,"DAY",DAY,"HOUR",HOUR)),COUNT)
"RTN","HLEMDD",65,0)
 I $$I^HLEMU($NA(@INDEX@(STATUS)),COUNT)
"RTN","HLEMDD",66,0)
 Q
"RTN","HLEMDD",67,0)
 ;
"RTN","HLEMDD",68,0)
DELSTAT(SITE,TYPE,STATUS,COUNT) ;
"RTN","HLEMDD",69,0)
 ;Description - delete logic for the AF x~ref on the Monitor Event file.
"RTN","HLEMDD",70,0)
 ;Maintains statistics for events.
"RTN","HLEMDD",71,0)
 ;Input:
"RTN","HLEMDD",72,0)
 ;  SITE - old value of the SITE field
"RTN","HLEMDD",73,0)
 ;  TYPE - old value of the TYPE field
"RTN","HLEMDD",74,0)
 ;  STATUS - old value of the REVIEW STATUS field
"RTN","HLEMDD",75,0)
 ;  COUNT - old value fo the COUNT field
"RTN","HLEMDD",76,0)
 ;Output:  see DD for description of the AF x~ref
"RTN","HLEMDD",77,0)
 ;
"RTN","HLEMDD",78,0)
 Q:'($G(SITE)&$G(TYPE)&$L($G(STATUS)))
"RTN","HLEMDD",79,0)
 ;
"RTN","HLEMDD",80,0)
 ;COUNT must be at least 1
"RTN","HLEMDD",81,0)
 S COUNT=$G(COUNT,1)
"RTN","HLEMDD",82,0)
 ;
"RTN","HLEMDD",83,0)
 N INDEX
"RTN","HLEMDD",84,0)
 S INDEX="^HLEV(776.4,""AF"",SITE,TYPE,STATUS)"
"RTN","HLEMDD",85,0)
 I $$I^HLEMU($NA(@INDEX),-COUNT)
"RTN","HLEMDD",86,0)
 Q
"RTN","HLEMDD",87,0)
 ;
"RTN","HLEMDD",88,0)
YEAR(FMDATE) ;returns the year (i.e., "2003", not in FM format)
"RTN","HLEMDD",89,0)
 Q $S($G(FMDATE):1700+$E(FMDATE,1,3),1:"")
"RTN","HLEMDD",90,0)
MONTH(FMDATE) ;returns the month (1-12)
"RTN","HLEMDD",91,0)
 Q $S($G(FMDATE):+$E(FMDATE,4,5),1:"")
"RTN","HLEMDD",92,0)
DAY(FMDATE) ;returns the day (1 - 31)
"RTN","HLEMDD",93,0)
 Q $S($G(FMDATE):+$E(FMDATE,6,7),1:"")
"RTN","HLEMDD",94,0)
HOUR(FMDATE) ;returns the hour (1-24
"RTN","HLEMDD",95,0)
 Q $S($G(FMDATE):+$E($P(FMDATE,".",2),1,2),1:"")
"RTN","HLEMDD",96,0)
 ;
"RTN","HLEMDD",97,0)
URGENCY(EVENT,URGENT,ACTION,REVIEW) ;
"RTN","HLEMDD",98,0)
 ;Description- changes the urgency as the action status and review status change.
"RTN","HLEMDD",99,0)
 ;
"RTN","HLEMDD",100,0)
 Q:'$G(EVENT)
"RTN","HLEMDD",101,0)
 I $G(URGENT)=2,$G(ACTION)=4 S $P(^HLEV(776.4,EVENT,0),"^",12)=1
"RTN","HLEMDD",102,0)
 I $G(URGENT)=2,$G(ACTION)=3 S $P(^HLEV(776.4,EVENT,0),"^",12)=0
"RTN","HLEMDD",103,0)
 I $G(REVIEW)=4 S $P(^HLEV(776.4,EVENT,0),"^",12)=0
"RTN","HLEMDD",104,0)
 Q
"RTN","HLEMDD",105,0)
 ;
"RTN","HLEMDD",106,0)
DEFAULT(PROFILE,DUZ,DEFAULT) ;
"RTN","HLEMDD",107,0)
 ;Description - maintains the "AC" x~ref on file 776.5, Event Log Prfofiles, insuring that each use has only one profile marked his default
"RTN","HLEMDD",108,0)
 ;
"RTN","HLEMDD",109,0)
 Q:'$G(PROFILE)
"RTN","HLEMDD",110,0)
 Q:'$G(DUZ)
"RTN","HLEMDD",111,0)
 Q:'$D(DEFAULT)
"RTN","HLEMDD",112,0)
 I $G(DEFAULT) D
"RTN","HLEMDD",113,0)
 .N PROF
"RTN","HLEMDD",114,0)
 .S PROF=""
"RTN","HLEMDD",115,0)
 .F  S PROF=$O(^HLEV(776.5,"AC",DUZ,PROF)) Q:'PROF  D
"RTN","HLEMDD",116,0)
 ..S $P(^HLEV(776.5,PROF,0),"^",3)=0
"RTN","HLEMDD",117,0)
 ..K ^HLEV(776.5,"AC",DUZ,PROF)
"RTN","HLEMDD",118,0)
 .S ^HLEV(776.5,"AC",DUZ,PROFILE)=""
"RTN","HLEMDD",119,0)
 E  D
"RTN","HLEMDD",120,0)
 .K ^HLEV(776.5,"AC",DUZ,PROFILE)
"RTN","HLEMDD",121,0)
 Q
"RTN","HLEMDD",122,0)
 ;
"RTN","HLEMDD",123,0)
CSTATUS(EVENT,STATUS) ;
"RTN","HLEMDD",124,0)
 ;This is the trigger logic of the AI index for file 776.4. If the event
"RTN","HLEMDD",125,0)
 ;status changes to COMPLETED, the DT/TM REVIEWED field is set to NOW
"RTN","HLEMDD",126,0)
 ;and the REVIEWER field is set to DUZ, if defined.
"RTN","HLEMDD",127,0)
 ;
"RTN","HLEMDD",128,0)
 Q:'$G(EVENT)
"RTN","HLEMDD",129,0)
 Q:$G(STATUS)'=4
"RTN","HLEMDD",130,0)
 S $P(^HLEV(776.4,EVENT,0),"^",7)=$$NOW^XLFDT
"RTN","HLEMDD",131,0)
 S $P(^HLEV(776.4,EVENT,0),"^",8)=$G(DUZ)
"RTN","HLEMDD",132,0)
 Q 
"RTN","HLEMDD",133,0)
 ;
"RTN","HLEMDD",134,0)
SETPURGE(EVENT,WHEN,TYPE) ;
"RTN","HLEMDD",135,0)
 ;Sets the earliest purge date into the AJ index on file 776.4
"RTN","HLEMDD",136,0)
 ;Input:
"RTN","HLEMDD",137,0)
 ;  EVENT - IEN of the event
"RTN","HLEMDD",138,0)
 ;  WHEN - .01 FIELD (DT/TM)
"RTN","HLEMDD",139,0)
 ;  TYPE - .02 field - event type
"RTN","HLEMDD",140,0)
 ;
"RTN","HLEMDD",141,0)
 Q:'$G(EVENT)
"RTN","HLEMDD",142,0)
 Q:'$G(WHEN)
"RTN","HLEMDD",143,0)
 Q:'$G(TYPE)
"RTN","HLEMDD",144,0)
 ;
"RTN","HLEMDD",145,0)
 N WAIT,PWHEN
"RTN","HLEMDD",146,0)
 S WAIT=$P($G(^HLEV(776.3,TYPE,0)),"^",9)
"RTN","HLEMDD",147,0)
 Q:'WAIT
"RTN","HLEMDD",148,0)
 S PDATE=$$FMADD^XLFDT(WHEN,WAIT\1)
"RTN","HLEMDD",149,0)
 S ^HLEV(776.4,"AJ",PDATE,EVENT)=""
"RTN","HLEMDD",150,0)
 Q
"RTN","HLEMDD",151,0)
 ;
"RTN","HLEMDD",152,0)
DELPURGE(EVENT,WHEN,TYPE) ;
"RTN","HLEMDD",153,0)
 ;kill logic fo the AJ index of file 776.4
"RTN","HLEMDD",154,0)
 ;Input:
"RTN","HLEMDD",155,0)
 ;  EVENT - IEN of the event
"RTN","HLEMDD",156,0)
 ;  WHEN - .01 FIELD (DT/TM)
"RTN","HLEMDD",157,0)
 ;  TYPE - .02 field - event type
"RTN","HLEMDD",158,0)
 ;
"RTN","HLEMDD",159,0)
 Q:'$G(EVENT)
"RTN","HLEMDD",160,0)
 Q:'$G(WHEN)
"RTN","HLEMDD",161,0)
 Q:'$G(TYPE)
"RTN","HLEMDD",162,0)
 ;
"RTN","HLEMDD",163,0)
 N WAIT,PWHEN
"RTN","HLEMDD",164,0)
 S WAIT=$P($G(^HLEV(776.3,TYPE,0)),"^",9)
"RTN","HLEMDD",165,0)
 Q:'WAIT
"RTN","HLEMDD",166,0)
 S PDATE=$$FMADD^XLFDT(WHEN,WAIT\1)
"RTN","HLEMDD",167,0)
 K ^HLEV(776.4,"AJ",PDATE,EVENT)
"RTN","HLEMDD",168,0)
 Q
"RTN","HLEMDD",169,0)
 ;
"RTN","HLEMDD",170,0)
SETPKG(ETYPE,PACKAGE,OLDNAME) ;
"RTN","HLEMDD",171,0)
 ;Given a ptr to the event type and package, it sets the PACKAGE NAME
"RTN","HLEMDD",172,0)
 ;field to the name of the package.  Also maintains the index that 
"RTN","HLEMDD",173,0)
 ;PACKAGE NAME is part of
"RTN","HLEMDD",174,0)
 ;
"RTN","HLEMDD",175,0)
 Q:'$G(ETYPE)
"RTN","HLEMDD",176,0)
 Q:'$G(PACKAGE)
"RTN","HLEMDD",177,0)
 N NAME,NODE
"RTN","HLEMDD",178,0)
 S NAME=$P($G(^DIC(9.4,PACKAGE,0)),"^")
"RTN","HLEMDD",179,0)
 S $P(^HLEV(776.3,ETYPE,0),"^",8)=NAME
"RTN","HLEMDD",180,0)
 S NODE=$G(^HLEV(776.3,ETYPE,0))
"RTN","HLEMDD",181,0)
 I $L($G(OLDNAME)),$L($P(NODE,"^")) K ^HLEV("AC",$P(NODE,"^"),OLDNAME)
"RTN","HLEMDD",182,0)
 I $L(NAME),$L($P(NODE,"^")) S ^HLEV("AC",$P(NODE,"^"),NAME)=ETYPE
"RTN","HLEMDD",183,0)
 Q
"RTN","HLEME")
0^34^B44654046
"RTN","HLEME",1,0)
HLEME ;ALB/CJM-HL7 - APIs for Monitor Events ;02/04/2004
"RTN","HLEME",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEME",3,0)
 ;
"RTN","HLEME",4,0)
GET(IEN,EVENT) ;
"RTN","HLEME",5,0)
 ;Desc: given the ien, it returns an array containing the event.  Does NOT include the NOTES field or the Application Data
"RTN","HLEME",6,0)
 ;Input:
"RTN","HLEME",7,0)
 ;  IEN - ien of event
"RTN","HLEME",8,0)
 ;Output:
"RTN","HLEME",9,0)
 ;  function returns 0 on failure, 1 on success
"RTN","HLEME",10,0)
 ;  EVENT(   ***pass by reference***
"RTN","HLEME",11,0)
 ;  "ACTION STATUS"
"RTN","HLEME",12,0)
 ;  "APPLICATION" - the sending application, only if the event is related to an HL7 message
"RTN","HLEME",13,0)
 ;  "COUNT" - the number of discrete events included in this event - for conglomerated events
"RTN","HLEME",14,0)
 ;  "DT/TM" - date/time of the event
"RTN","HLEME",15,0)
 ;  "DT/TM ACTION" - for automated action
"RTN","HLEME",16,0)
 ;  "DT/TM CREATED" - time stamp for this event
"RTN","HLEME",17,0)
 ;  "DT/TM REVIEWED" - 
"RTN","HLEME",18,0)
 ;  "ID" - unique identifier
"RTN","HLEME",19,0)
 ;  "IEN" -the ien
"RTN","HLEME",20,0)
 ;  "MAIL",<msg ien>)=<msg ien> - list of Mailman messages
"RTN","HLEME",21,0)
 ;  "MSGID ID" - mssage id of message causing this event (if any)
"RTN","HLEME",22,0)
 ;  "MSG TYPE" - HL7 message type code
"RTN","HLEME",23,0)
 ;  "MSG EVENT" - HL7 event type code
"RTN","HLEME",24,0)
 ;  "MSG LINK" - name of the HL Logical Link (NODE) on which the mssg was sent
"RTN","HLEME",25,0)
 ;  "REVIEWER" - ien in New Person file
"RTN","HLEME",26,0)
 ;  "REVIEW STATUS"
"RTN","HLEME",27,0)
 ;  "SITE" - site of occurence, a pointer to the Institution file
"RTN","HLEME",28,0)
 ;  "TYPE" - the type of event, an ien of a HL7 Monitor Event Type
"RTN","HLEME",29,0)
 ;  "URGENT" - flag for urgency
"RTN","HLEME",30,0)
 ;
"RTN","HLEME",31,0)
 ;
"RTN","HLEME",32,0)
 Q:'$G(IEN) 0
"RTN","HLEME",33,0)
 N NODE,I,LABEL
"RTN","HLEME",34,0)
 K EVENT
"RTN","HLEME",35,0)
 S EVENT("IEN")=IEN
"RTN","HLEME",36,0)
 S NODE=$G(^HLEV(776.4,IEN,0))
"RTN","HLEME",37,0)
 Q:'$L(NODE) 0
"RTN","HLEME",38,0)
 S EVENT("DT/TM")=$P(NODE,"^")
"RTN","HLEME",39,0)
 S EVENT("TYPE")=$P(NODE,"^",2)
"RTN","HLEME",40,0)
 S EVENT("SITE")=$P(NODE,"^",3)
"RTN","HLEME",41,0)
 S EVENT("ID")=$P(NODE,"^",4)
"RTN","HLEME",42,0)
 S EVENT("ACTION STATUS")=$P(NODE,"^",5)
"RTN","HLEME",43,0)
 S EVENT("REVIEW STATUS")=$P(NODE,"^",6)
"RTN","HLEME",44,0)
 S EVENT("DT/TM REVIEWED")=$P(NODE,"^",7)
"RTN","HLEME",45,0)
 S EVENT("REVIEWER")=$P(NODE,"^",8)
"RTN","HLEME",46,0)
 S EVENT("DT/TM ACTION")=$P(NODE,"^",9)
"RTN","HLEME",47,0)
 S EVENT("MSG ID")=$P(NODE,"^",10)
"RTN","HLEME",48,0)
 S EVENT("MSG TYPE")=$P(NODE,"^",13)
"RTN","HLEME",49,0)
 S EVENT("MSG EVENT")=$P(NODE,"^",14)
"RTN","HLEME",50,0)
 S EVENT("MSG LINK")=$P(NODE,"^",15)
"RTN","HLEME",51,0)
 S EVENT("DT/TM CREATED")=$P(NODE,"^",17)
"RTN","HLEME",52,0)
 S EVENT("APPLICATION")=$P(NODE,"^",16)
"RTN","HLEME",53,0)
 S EVENT("COUNT")=$P(NODE,"^",11)
"RTN","HLEME",54,0)
 S EVENT("URGENT")=$P(NODE,"^",12)
"RTN","HLEME",55,0)
 S I=0 F  S I=$O(^HLEV(776.4,IEN,2,I)) Q:'I  S NODE=+$G(^HLEV(776.4,IEN,2,I,0)) I NODE S EVENT("MAIL",NODE)=NODE
"RTN","HLEME",56,0)
 Q 1
"RTN","HLEME",57,0)
 ;
"RTN","HLEME",58,0)
STOREVAR(EVENT,APPDATA,VAR) ;
"RTN","HLEME",59,0)
 ;Desc:  Allows an app. to store its own application-specific data.
"RTN","HLEME",60,0)
 ;Input:
"RTN","HLEME",61,0)
 ;   EVENT - ien of event
"RTN","HLEME",62,0)
 ;   APPDATA - variable or array to store **for arrays, pass by reference**
"RTN","HLEME",63,0)
 ;   VAR - **optional** - variable name, may inlucde subscripts.Required if the application needs to store multiple variables or arrays. VAR="APPDATA"is the default
"RTN","HLEME",64,0)
 ;Output:
"RTN","HLEME",65,0)
 ;  function reuturns 1 on success,0 on failure
"RTN","HLEME",66,0)
 ;Ex 1
"RTN","HLEME",67,0)
 ;  An app. needs to store a single set of data with the
"RTN","HLEME",68,0)
 ;  event.  It could set the data into an array call
"RTN","HLEME",69,0)
 ;  $$STOREVAR(EVENT,.MYARRAY) To get back the
"RTN","HLEME",70,0)
 ;       data it would call $$GETVAR(EVENT,.MYARRAY).  (any variable name could have been used instead of MYARRAY.
"RTN","HLEME",71,0)
 ;Ex 2
"RTN","HLEME",72,0)
 ;  An application needs to store multiple sets of data with the
"RTN","HLEME",73,0)
 ;  the event. It could accomplish that by setting the data into
"RTN","HLEME",74,0)
 ;  multiple arrays, say DATA1,DATA2,DATA3,... and calling
"RTN","HLEME",75,0)
 ;  $$STOREVAR(EVENT,.DATA1,"DATA1"), then $$STOREVAR(EVENT,.DATA2,"DATA2"),etc.
"RTN","HLEME",76,0)
 ;  To get back the named datasets the application would call
"RTN","HLEME",77,0)
 ;  $$GETVAR(EVENT,.DATA1,"DATA1"), $$GETVAR(EVENT,.DATA2,"DATA2"),
"RTN","HLEME",78,0)
 ;  etc.
"RTN","HLEME",79,0)
 ;
"RTN","HLEME",80,0)
 Q:'$G(EVENT) 0
"RTN","HLEME",81,0)
 Q:'$D(^HLEV(776.4,EVENT,0)) 0
"RTN","HLEME",82,0)
 Q:'$D(APPDATA) 0
"RTN","HLEME",83,0)
 ;
"RTN","HLEME",84,0)
 N I,LABEL
"RTN","HLEME",85,0)
 S I=+$O(^HLEV(776.4,EVENT,3,999999999),-1)
"RTN","HLEME",86,0)
 I $L($G(VAR)) N @VAR D
"RTN","HLEME",87,0)
 .S LABEL=VAR
"RTN","HLEME",88,0)
 .M @VAR=APPDATA
"RTN","HLEME",89,0)
 E  D
"RTN","HLEME",90,0)
 .S LABEL="APPDATA"
"RTN","HLEME",91,0)
 ;
"RTN","HLEME",92,0)
 ;check if the root has data, if so, store it
"RTN","HLEME",93,0)
 I $D(@LABEL)'[0 D
"RTN","HLEME",94,0)
 .N OLDIEN
"RTN","HLEME",95,0)
 .S OLDIEN=$O(^HLEV(776.4,EVENT,3,"B",LABEL,0))
"RTN","HLEME",96,0)
 .I OLDIEN D
"RTN","HLEME",97,0)
 ..K ^HLEV(776.4,EVENT,"B",LABEL,OLDIEN),^HLEV(776.4,EVENT,3,OLDIEN)
"RTN","HLEME",98,0)
 .E  D
"RTN","HLEME",99,0)
 ..S I=I+1
"RTN","HLEME",100,0)
 .S ^HLEV(776.4,EVENT,3,I,0)=LABEL,^HLEV(776.4,EVENT,3,I,2)=@LABEL,^HLEV(776.4,EVENT,3,"B",LABEL,I)=0
"RTN","HLEME",101,0)
 ;
"RTN","HLEME",102,0)
 ;now store everything that comes below it
"RTN","HLEME",103,0)
 F  S LABEL=$Q(@LABEL) Q:LABEL=""  D
"RTN","HLEME",104,0)
 .;can't go over a total lenth of 230
"RTN","HLEME",105,0)
 .Q:'$L(LABEL)>230
"RTN","HLEME",106,0)
 .S I=I+1 S ^HLEV(776.4,EVENT,3,I,0)=LABEL,^HLEV(776.4,EVENT,3,I,2)=@LABEL,^HLEV(776.4,EVENT,3,"B",LABEL,I)=0
"RTN","HLEME",107,0)
 ;
"RTN","HLEME",108,0)
 ;write the 0-node
"RTN","HLEME",109,0)
 S ^HLEV(776.4,EVENT,3,0)="^776.43^"_I_"^"_I
"RTN","HLEME",110,0)
 ;
"RTN","HLEME",111,0)
 Q 1
"RTN","HLEME",112,0)
 ;
"RTN","HLEME",113,0)
GETVAR(EVENT,APPDATA,VAR) ;
"RTN","HLEME",114,0)
 ;Desc: Used to retrieve application-specific data that was stored along with the event.
"RTN","HLEME",115,0)
 ;Input:
"RTN","HLEME",116,0)
 ;   EVENT - ien of the event
"RTN","HLEME",117,0)
 ;   VAR - name of the variable or array to fetch.  If not passed, "APPDATA" is assumed, which is also the default when calling $$STOREVAR()
"RTN","HLEME",118,0)
 ;Output
"RTN","HLEME",119,0)
 ;  function value - 1 on success, 0 on failure
"RTN","HLEME",120,0)
 ;  APPDATA() - used to return the requested data **pass by reference**
"RTN","HLEME",121,0)
 ;
"RTN","HLEME",122,0)
 Q:'$G(EVENT) 0
"RTN","HLEME",123,0)
 Q:'$L($G(^HLEV(776.4,EVENT,0))) 0
"RTN","HLEME",124,0)
 ;
"RTN","HLEME",125,0)
 N INDEX,I,LABEL,VAR2
"RTN","HLEME",126,0)
 K APPDATA
"RTN","HLEME",127,0)
 S INDEX="^HLEV(776.4,EVENT,3)"
"RTN","HLEME",128,0)
 S:'$L($G(VAR)) VAR="APPDATA"
"RTN","HLEME",129,0)
 S VAR2=$O(@INDEX@("B",VAR),-1)
"RTN","HLEME",130,0)
 F  S VAR2=$O(@INDEX@("B",VAR2)) Q:'$L(VAR2)  Q:(VAR2'[VAR)  S I=0 F  S I=$O(@INDEX@("B",VAR2,I)) Q:'I  S LABEL=$G(@INDEX@(I,0)) S:LABEL[VAR @LABEL=$G(@INDEX@(I,2))
"RTN","HLEME",131,0)
 ;
"RTN","HLEME",132,0)
 M APPDATA=@VAR
"RTN","HLEME",133,0)
 Q 1
"RTN","HLEME",134,0)
 ;
"RTN","HLEME",135,0)
EVENT(CODE,PACKAGE,HL7MSGID,SITE,WHEN,ERROR) ;
"RTN","HLEME",136,0)
 ;Desc: API for applications to notify HL7 Event Monitor of their events
"RTN","HLEME",137,0)
 ;Input:
"RTN","HLEME",138,0)
 ;  CODE - the code (.01 field) for the HL7 Monitor Event Type
"RTN","HLEME",139,0)
 ;  PACKAGE - the name of the package that created the HL7 Monitor Event Type, used to find the event type ien.
"RTN","HLEME",140,0)
 ;  HL7MSGID - **optional** - if the event pertains to a specific message, this should be passed
"RTN","HLEME",141,0)
 ;  SITE - **optional** - the station number, including any suffix, where the event occured. Will assume the local site if not passed in.
"RTN","HLEME",142,0)
 ;  WHEN - **optional** - FM date/time of when the event occurred. Will assume now if not passed in.
"RTN","HLEME",143,0)
 ;Output:
"RTN","HLEME",144,0)
 ;  function value -  ien of the event (file 776.4) on success, 0 on failure
"RTN","HLEME",145,0)
 ;  ERROR - **optional, pass by reference** - array of error messages
"RTN","HLEME",146,0)
 ;
"RTN","HLEME",147,0)
 N EVENT,TYPE,MSGIEN,NOW
"RTN","HLEME",148,0)
 S EVENT("TYPE")=$$FIND^HLEMT(.CODE,.PACKAGE)
"RTN","HLEME",149,0)
 I 'EVENT("TYPE") S ERROR(1)="UNKNOWN EVENT TYPE" Q 0
"RTN","HLEME",150,0)
 I '$L($G(SITE)) D
"RTN","HLEME",151,0)
 .S EVENT("SITE")=+$P($$SITE^VASITE(),"^")
"RTN","HLEME",152,0)
 E  D
"RTN","HLEME",153,0)
 .S EVENT("SITE")=$$LKUP^XUAF4(SITE)
"RTN","HLEME",154,0)
 I 'EVENT("SITE") S ERROR(1)="UNKNOWN SITE" Q 0
"RTN","HLEME",155,0)
 S NOW=$$NOW^XLFDT
"RTN","HLEME",156,0)
 S EVENT("DT/TM")=$S('$G(WHEN):NOW,1:WHEN)
"RTN","HLEME",157,0)
 S EVENT("DT/TM CREATED")=NOW
"RTN","HLEME",158,0)
 ;
"RTN","HLEME",159,0)
 ;get the event type array
"RTN","HLEME",160,0)
 I '$$GET^HLEMT(EVENT("TYPE"),.TYPE) S ERROR(1)="UNKNOWN EVENT TYPE" Q 0
"RTN","HLEME",161,0)
 ;
"RTN","HLEME",162,0)
 ;is this event type active?
"RTN","HLEME",163,0)
 I 'TYPE("ACTIVE") S ERROR(1)="INACTIVE EVENT TYPE" Q 0
"RTN","HLEME",164,0)
 ;
"RTN","HLEME",165,0)
 ;check if this is a conglomerated event that can be added to an existing event
"RTN","HLEME",166,0)
 I TYPE("CONGLOMERATE") D
"RTN","HLEME",167,0)
 .L +^HLEV(776.4,"AE",EVENT("SITE"),EVENT("TYPE")):2
"RTN","HLEME",168,0)
 .S EVENT("IEN")=$$ADD^HLEME1(EVENT("SITE"),EVENT("TYPE"),EVENT("DT/TM"))
"RTN","HLEME",169,0)
 ;
"RTN","HLEME",170,0)
 I '$G(EVENT("IEN")) D
"RTN","HLEME",171,0)
 .;
"RTN","HLEME",172,0)
 .;otherwise, create and store a new event
"RTN","HLEME",173,0)
 .S EVENT("ACTION STATUS")=$S($L(TYPE("ACTION")):1,1:0)
"RTN","HLEME",174,0)
 .S EVENT("REVIEW STATUS")=TYPE("REVIEW")
"RTN","HLEME",175,0)
 .S EVENT("MSG ID")=$G(HL7MSGID)
"RTN","HLEME",176,0)
 .S MSGIEN=$$MSGIEN^HLEMU($G(HL7MSGID))
"RTN","HLEME",177,0)
 .I MSGIEN D
"RTN","HLEME",178,0)
 ..S EVENT("MSG TYPE")=$$MSGTYPE^HLEMU(MSGIEN)
"RTN","HLEME",179,0)
 ..S EVENT("MSG EVENT")=$$HL7EVENT^HLEMU(MSGIEN)
"RTN","HLEME",180,0)
 ..S EVENT("MSG LINK")=$P($$LINK^HLEMU(MSGIEN),"^",2)
"RTN","HLEME",181,0)
 ..S EVENT("APPLICATION")=$$APP^HLEMU(MSGIEN)
"RTN","HLEME",182,0)
 .E  D
"RTN","HLEME",183,0)
 ..S EVENT("MSG TYPE")=""
"RTN","HLEME",184,0)
 ..S EVENT("MSG EVENT")=""
"RTN","HLEME",185,0)
 ..S EVENT("MSG LINK")=""
"RTN","HLEME",186,0)
 ..S EVENT("APPLICATION")=""
"RTN","HLEME",187,0)
 .S EVENT("COUNT")=1
"RTN","HLEME",188,0)
 .S EVENT("URGENT")=TYPE("URGENT")
"RTN","HLEME",189,0)
 .S EVENT("IEN")=$$STORE^HLEME1(.EVENT,.ERROR)
"RTN","HLEME",190,0)
 .I EVENT("IEN"),$O(TYPE("DOMAIN",0)) S ^HLEV(776.4,"AK",NOW,EVENT("IEN"))=""
"RTN","HLEME",191,0)
 I TYPE("CONGLOMERATE") L -^HLEV(776.4,"AE",EVENT("SITE"),EVENT("TYPE"))
"RTN","HLEME",192,0)
 Q EVENT("IEN")
"RTN","HLEME",193,0)
 ;
"RTN","HLEME",194,0)
COUNT(EVENT) ;
"RTN","HLEME",195,0)
 ;given the event ien, returns the value of the COUNT field
"RTN","HLEME",196,0)
 Q:'$G(EVENT) 0
"RTN","HLEME",197,0)
 Q $P($G(^HLEV(776.4,EVENT,0)),"^",11)
"RTN","HLEME",198,0)
INC(EVENTIEN,NUMBER) ;
"RTN","HLEME",199,0)
 ;Desc: given the ien of a conglomerated event, it will increment the count by the given amount and return the new count.  Returns "" on failure.
"RTN","HLEME",200,0)
 ;
"RTN","HLEME",201,0)
 Q:'$G(EVENTIEN) ""
"RTN","HLEME",202,0)
 Q:'$G(NUMBER) ""
"RTN","HLEME",203,0)
 N COUNT,EVENT
"RTN","HLEME",204,0)
 L +^HLEV(776.4,EVENTIEN,0):1
"RTN","HLEME",205,0)
 Q:'$$GET(EVENTIEN,.EVENT) ""
"RTN","HLEME",206,0)
 S COUNT=EVENT("COUNT")
"RTN","HLEME",207,0)
 S $P(^HLEV(776.4,EVENTIEN,0),"^",11)=COUNT+NUMBER
"RTN","HLEME",208,0)
 D ADDSTAT^HLEMDD(EVENT("DT/TM"),,EVENT("SITE"),EVENT("TYPE"),EVENT("REVIEW STATUS"),NUMBER)
"RTN","HLEME",209,0)
 L -^HLEV(776.4,EVENTIEN,0)
"RTN","HLEME",210,0)
 Q (COUNT+NUMBER)
"RTN","HLEME",211,0)
 ;
"RTN","HLEME",212,0)
RSTATUS(EVENT) ;
"RTN","HLEME",213,0)
 ;given the event ien, returns the value of the REVIEW STATUS field
"RTN","HLEME",214,0)
 Q:'$G(EVENT) ""
"RTN","HLEME",215,0)
 Q $P($G(^HLEV(776.4,EVENT,0)),"^",6)
"RTN","HLEME",216,0)
 ;
"RTN","HLEME",217,0)
ADDNOTE(EVENT,NOTE) ;
"RTN","HLEME",218,0)
 ;Description:  adds a note to the NOTE field of the event
"RTN","HLEME",219,0)
 ;Input:
"RTN","HLEME",220,0)
 ;  EVENT - ien of the event
"RTN","HLEME",221,0)
 ;  NOTE - either:
"RTN","HLEME",222,0)
 ;         1) A single line to add to the NOTES OR
"RTN","HLEME",223,0)
 ;    2) An array of lines to add. All descendant nodes will be added.
"RTN","HLEME",224,0)
 ;Ouput:
"RTN","HLEME",225,0)
 ;   function value - 1 on success, 0 on failure
"RTN","HLEME",226,0)
 ;
"RTN","HLEME",227,0)
 Q:'$G(EVENT) 0
"RTN","HLEME",228,0)
 Q:'$L($G(^HLEV(776.4,EVENT,0))) 0
"RTN","HLEME",229,0)
 Q:'$D(NOTE) 0
"RTN","HLEME",230,0)
 ;
"RTN","HLEME",231,0)
 N LABEL,I
"RTN","HLEME",232,0)
 S I=$O(^HLEV(776.4,EVENT,1,9999999),-1)+1
"RTN","HLEME",233,0)
 I $L($G(NOTE)) S ^HLEV(776.4,EVENT,1,I,0)=NOTE,I=I+1
"RTN","HLEME",234,0)
 S LABEL="NOTE"
"RTN","HLEME",235,0)
 F  S LABEL=$Q(@LABEL) Q:LABEL=""  S ^HLEV(776.4,EVENT,1,I,0)=@LABEL,I=I+1
"RTN","HLEME",236,0)
 S ^HLEV(776.4,EVENT,1,0)="^776.41^"_(I-1)_"^"_(I-1)_"^"_DT
"RTN","HLEME",237,0)
 Q 1
"RTN","HLEME",238,0)
 ;
"RTN","HLEME",239,0)
GETNOTES(EVENT,ARRAY) ;
"RTN","HLEME",240,0)
 ;Description - given an event, returns the note field into an array, local or global
"RTN","HLEME",241,0)
 ;Input: ARRAY - the name of the array to store the notes, referenced by indirection
"RTN","HLEME",242,0)
 ;Output:
"RTN","HLEME",243,0)
 ;  function returns 1 on success, 0 on failure
"RTN","HLEME",244,0)
 ;  @ARRAY will contain the NOTES, wich is a WP field
"RTN","HLEME",245,0)
 ;
"RTN","HLEME",246,0)
 Q:'$L('$G(ARRAY)) 0
"RTN","HLEME",247,0)
 Q:'$G(EVENT) 0
"RTN","HLEME",248,0)
 K @ARRAY
"RTN","HLEME",249,0)
 M @ARRAY=^HLEV(776.4,EVENT,1)
"RTN","HLEME",250,0)
 Q 1
"RTN","HLEME1")
0^35^B12691313
"RTN","HLEME1",1,0)
HLEME1 ;ALB/CJM-HL7 - APIs for Monitor Events (continued) ;02/04/2004
"RTN","HLEME1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEME1",3,0)
 ;
"RTN","HLEME1",4,0)
NEWINDEX(EVENT,APPNAME,PARMARY) ;
"RTN","HLEME1",5,0)
 ;Description: This allows an application to build is own private index on its own events, which it can use to determine whether or not the event has been logged.
"RTN","HLEME1",6,0)
 ;
"RTN","HLEME1",7,0)
 ;Input:
"RTN","HLEME1",8,0)
 ;  EVENT - ien of an event
"RTN","HLEME1",9,0)
 ;  APPNAME - application name, including namespace. This is used as part of the lookup index.  The application is responsible for insuring there will be no coflict with other applications logging its own events.
"RTN","HLEME1",10,0)
 ;  PARMARY - **pass by reference** an array of parameters with which to build the index.  The format is: PARMARY(1)=<first parameter>, PARMARY(2)=<second parameter>  If PARRMARY(i)=null, the parameter will be translated to a single space.
"RTN","HLEME1",11,0)
 ;Output:
"RTN","HLEME1",12,0)
 ;  function returns 1 on success, 0 otherwise
"RTN","HLEME1",13,0)
 ;
"RTN","HLEME1",14,0)
 Q:'$G(EVENT) 0
"RTN","HLEME1",15,0)
 Q:'$D(^HLEV(776.4,EVENT,0)) 0
"RTN","HLEME1",16,0)
 Q:'$D(PARMARY) 0
"RTN","HLEME1",17,0)
 Q:'$L($G(APPNAME)) 0
"RTN","HLEME1",18,0)
 N INDEX,I
"RTN","HLEME1",19,0)
 S INDEX="^HLEV(776.4,""AH"",APPNAME,"
"RTN","HLEME1",20,0)
 S I=0
"RTN","HLEME1",21,0)
 F  S I=$O(PARMARY(I)) Q:'I  S INDEX=INDEX_""""_$S($L(PARMARY(I)):PARMARY(I),1:" ")_""","
"RTN","HLEME1",22,0)
 S INDEX=$E(INDEX,1,$L(INDEX)-1)_")"
"RTN","HLEME1",23,0)
 S @INDEX=EVENT
"RTN","HLEME1",24,0)
 S ^HLEV(776.4,"AH KILL",EVENT,""""_APPNAME_""","_$P(INDEX,"^HLEV(776.4,""AH"",APPNAME,",2))=""
"RTN","HLEME1",25,0)
 Q 1
"RTN","HLEME1",26,0)
 ;
"RTN","HLEME1",27,0)
LOGGED(APPNAME,PARMARY) ;
"RTN","HLEME1",28,0)
 ;Description: This allows an application to determine whether or not an
"RTN","HLEME1",29,0)
 ;event has already been logged, based on a private index the application
"RTN","HLEME1",30,0)
 ;built by calling $$NEWINDEX^HLEME1()
"RTN","HLEME1",31,0)
 ;
"RTN","HLEME1",32,0)
 ;Input:
"RTN","HLEME1",33,0)
 ;  APPNAME - application name, including namespace. This is used as part of the lookup index.  The application is responsible for insuring there will be no coflict with other applications logging its own events.
"RTN","HLEME1",34,0)
 ;  PARMARY  **pass by reference** an array of parameters with which the index was built.  The format is: PARMARY(1)=<first parameter>, PARMARY(2)=<second parameter>  If PARRMARY(i)=null, the parameter will be translated to a single space.
"RTN","HLEME1",35,0)
 ;Output:
"RTN","HLEME1",36,0)
 ;  function returns TWO values in the format <value 1>^<value 2>
"RTN","HLEME1",37,0)
 ;     <value 1> is 1 one if that subscript in the AH index exists, 0 otherwise
"RTN","HLEME1",38,0)
 ;     <value 2> is the event ien if found - which should be the case if all the subscripts are supplied that were passed to $$NEWINDEX
"RTN","HLEME1",39,0)
 ;
"RTN","HLEME1",40,0)
 Q:'$D(PARMARY) "0^"
"RTN","HLEME1",41,0)
 Q:'$L($G(APPNAME)) "0^"
"RTN","HLEME1",42,0)
 N INDEX,I,EVENT,VALUE1,VALUE2
"RTN","HLEME1",43,0)
 S VALUE1=0,VALUE2=""
"RTN","HLEME1",44,0)
 S INDEX="^HLEV(776.4,""AH"",APPNAME,"
"RTN","HLEME1",45,0)
 S I=0
"RTN","HLEME1",46,0)
 F  S I=$O(PARMARY(I)) Q:'I  S INDEX=INDEX_""""_$S($L(PARMARY(I)):PARMARY(I),1:" ")_""","
"RTN","HLEME1",47,0)
 S INDEX=$E(INDEX,1,$L(INDEX)-1)_")"
"RTN","HLEME1",48,0)
 S VALUE1=$S($D(@INDEX):1,1:0)
"RTN","HLEME1",49,0)
 S VALUE2=$G(@INDEX)
"RTN","HLEME1",50,0)
 Q VALUE1_"^"_VALUE2
"RTN","HLEME1",51,0)
 ;
"RTN","HLEME1",52,0)
 ;
"RTN","HLEME1",53,0)
ADD(SITE,TYPE,TIME) ;
"RTN","HLEME1",54,0)
 ;Description - Checks for an existing event and determines if it can be added to, based on whether or not its period is expired.  If it can be added, its count is incremented and its ien returned as the function value, otherwise, 0 is returned
"RTN","HLEME1",55,0)
 ;
"RTN","HLEME1",56,0)
 Q:'$G(SITE) 0
"RTN","HLEME1",57,0)
 Q:'$G(TYPE) 0
"RTN","HLEME1",58,0)
 Q:'$G(TIME) 0
"RTN","HLEME1",59,0)
 N EVENT,LAST,COUNT,HOURS
"RTN","HLEME1",60,0)
 S EVENT=0
"RTN","HLEME1",61,0)
 ;
"RTN","HLEME1",62,0)
 S HOURS=$$HOURS^HLEMT(TYPE)
"RTN","HLEME1",63,0)
 Q:'HOURS 0
"RTN","HLEME1",64,0)
 S LAST=$O(^HLEV(776.4,"AE",SITE,TYPE,TIME+.00000001),-1)
"RTN","HLEME1",65,0)
 I LAST,TIME<$$FMADD^XLFDT(LAST,,HOURS) D
"RTN","HLEME1",66,0)
 .S EVENT=$O(^HLEV(776.4,"AE",SITE,TYPE,LAST,0))
"RTN","HLEME1",67,0)
 .I EVENT,$$INC^HLEME(EVENT,1)
"RTN","HLEME1",68,0)
 Q EVENT
"RTN","HLEME1",69,0)
 ;
"RTN","HLEME1",70,0)
STORE(EVENT,ERROR) ;
"RTN","HLEME1",71,0)
 ;Desc: stores the event.Creates a new record if EVENT("IEN") isn't valued, otherwise overlays the existing record.
"RTN","HLEME1",72,0)
 ;Input:
"RTN","HLEME1",73,0)
 ;  EVENT - an array containing the EVENT **pass by reference**
"RTN","HLEME1",74,0)
 ;Output:
"RTN","HLEME1",75,0)
 ;  function value - 0 on failure, event ien on success
"RTN","HLEME1",76,0)
 ;  EVENT() - if successful, the EVENT array is refreshed
"RTN","HLEME1",77,0)
 ;  ERROR() - an array of error messages **pass by reference,optional**
"RTN","HLEME1",78,0)
 ; 
"RTN","HLEME1",79,0)
 Q:'$D(EVENT) 0
"RTN","HLEME1",80,0)
 ;
"RTN","HLEME1",81,0)
 N DATA,I,SUB,SUCCESS,NODE
"RTN","HLEME1",82,0)
 K ERROR
"RTN","HLEME1",83,0)
 S I=0
"RTN","HLEME1",84,0)
 F SUB="DT/TM","TYPE","SITE","ID","ACTION STATUS","REVIEW STATUS","DT/TM REVIEWED","REVIEWER","DT/TM ACTION","MSG ID","COUNT","URGENT","MSG TYPE","MSG EVENT","MSG LINK","APPLICATION","DT/TM CREATED" D
"RTN","HLEME1",85,0)
 .S I=I+.01 S:$D(EVENT(SUB)) DATA(I)=$G(EVENT(SUB))
"RTN","HLEME1",86,0)
 I $G(EVENT("IEN")) D
"RTN","HLEME1",87,0)
 .;record already exists, overlay it
"RTN","HLEME1",88,0)
 .S SUCCESS=$S($$UPD^HLEMU(776.4,EVENT("IEN"),.DATA,.ERROR):EVENT("IEN"),1:0)
"RTN","HLEME1",89,0)
 .D:SUCCESS
"RTN","HLEME1",90,0)
 ..;Kill the multiples to insure full overlay (re-write later)
"RTN","HLEME1",91,0)
 ..K ^HLEV(776.4,EVENT("IEN"),3)
"RTN","HLEME1",92,0)
 ..K ^HLEV(776.4,EVENT("IEN"),1)
"RTN","HLEME1",93,0)
 E  D
"RTN","HLEME1",94,0)
 .;record needs to be created
"RTN","HLEME1",95,0)
 .S SUCCESS=$$ADD^HLEMU(776.4,,.DATA,.ERROR)
"RTN","HLEME1",96,0)
 .S:SUCCESS EVENT("IEN")=SUCCESS
"RTN","HLEME1",97,0)
 Q:'SUCCESS 0
"RTN","HLEME1",98,0)
 ;
"RTN","HLEME1",99,0)
 ;store the list of mail messages
"RTN","HLEME1",100,0)
 K DATA,DA
"RTN","HLEME1",101,0)
 S DA(1)=EVENT("IEN")
"RTN","HLEME1",102,0)
 S I=0 F  S I=$O(EVENT("MAIL",I)) Q:'I  S DATA(.01)=I I '$$ADD^HLEMU(776.4,.DA,.DATA,.ERROR) Q
"RTN","HLEME1",103,0)
 I SUCCESS,$$GET^HLEME(SUCCESS,.EVENT)
"RTN","HLEME1",104,0)
 Q SUCCESS
"RTN","HLEME1",105,0)
 ;
"RTN","HLEME1",106,0)
LOCK(EVENT) ;
"RTN","HLEME1",107,0)
 ;Locks the event record (EVENT=Event ien), returns 1 on success, 0 on
"RTN","HLEME1",108,0)
 ;failure
"RTN","HLEME1",109,0)
 Q:'$G(EVENT) 0
"RTN","HLEME1",110,0)
 L +^HLEM(776.4,EVENT):3
"RTN","HLEME1",111,0)
 Q $T
"RTN","HLEME1",112,0)
 ;
"RTN","HLEME1",113,0)
UNLOCK(EVENT) ;
"RTN","HLEME1",114,0)
 ;Unlocks the event record (EVENT=Event ien)
"RTN","HLEME1",115,0)
 Q:'$G(EVENT)
"RTN","HLEME1",116,0)
 L -^HLEM(776.4,EVENT)
"RTN","HLEME1",117,0)
 Q
"RTN","HLEMEP")
0^42^B6558828
"RTN","HLEMEP",1,0)
HLEMEP ;ALB/CJM-HL7 - Purge Monitor Events  ;02/04/2004
"RTN","HLEMEP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEMEP",3,0)
 ;
"RTN","HLEMEP",4,0)
PURGE ;
"RTN","HLEMEP",5,0)
 N NOW,WHEN,EVENT,ERROR
"RTN","HLEMEP",6,0)
 S NOW=$$NOW^XLFDT
"RTN","HLEMEP",7,0)
 S WHEN=0
"RTN","HLEMEP",8,0)
 D START^HLEVAPI(.VAR)
"RTN","HLEMEP",9,0)
 ;
"RTN","HLEMEP",10,0)
 ;delete the old events
"RTN","HLEMEP",11,0)
 F  S WHEN=$O(^HLEV(776.4,"AJ",WHEN)) Q:'WHEN  Q:WHEN>NOW  D
"RTN","HLEMEP",12,0)
 .S EVENT=0
"RTN","HLEMEP",13,0)
 .F  S EVENT=$O(^HLEV(776.4,"AJ",WHEN,EVENT)) Q:'EVENT  D
"RTN","HLEMEP",14,0)
 ..I '$$DELETE^HLEMU(776.4,EVENT,.ERROR),'$D(^HLEV(776.4,EVENT,0)) K ^HLEV(776.4,"AJ",WHEN,EVENT)
"RTN","HLEMEP",15,0)
 ;
"RTN","HLEMEP",16,0)
 ;delete the old statistics
"RTN","HLEMEP",17,0)
 N STATS,SITE,TYPE,YEAR,MONTH,DAY,CUTMONTH,CUTDAY,CUTHOUR
"RTN","HLEMEP",18,0)
 S STATS="^HLEV(776.4,""AF"")"
"RTN","HLEMEP",19,0)
 S SITE=0
"RTN","HLEMEP",20,0)
 ;
"RTN","HLEMEP",21,0)
 ;these determine the timeframes within which to delete the old statistics
"RTN","HLEMEP",22,0)
 S CUTMONTH=$E($$FMADD^XLFDT(DT,-65),1,5)
"RTN","HLEMEP",23,0)
 S CUTDAY=$P($$FMADD^XLFDT(DT,-8),".")
"RTN","HLEMEP",24,0)
 S CUTHOUR=$$FMADD^XLFDT(NOW,-2)
"RTN","HLEMEP",25,0)
 ;
"RTN","HLEMEP",26,0)
 F  S SITE=$O(@STATS@(SITE)) Q:'SITE  D
"RTN","HLEMEP",27,0)
 .S TYPE=0
"RTN","HLEMEP",28,0)
 .F  S TYPE=$O(@STATS@(SITE,TYPE)) Q:'TYPE  D
"RTN","HLEMEP",29,0)
 ..S YEAR=""
"RTN","HLEMEP",30,0)
 ..F  S YEAR=$O(@STATS@(SITE,TYPE,"RECEIVED","YEAR",YEAR)) Q:'YEAR  D
"RTN","HLEMEP",31,0)
 ...S MONTH=""
"RTN","HLEMEP",32,0)
 ...F  S MONTH=$O(@STATS@(SITE,TYPE,"RECEIVED","YEAR",YEAR,"MONTH",MONTH)) Q:(MONTH="")  D
"RTN","HLEMEP",33,0)
 ....I ((YEAR-1700)_$$PAD2(MONTH))<CUTMONTH D
"RTN","HLEMEP",34,0)
 .....K @STATS@(SITE,TYPE,"RECEIVED","YEAR",YEAR,"MONTH",MONTH)
"RTN","HLEMEP",35,0)
 ....E  D
"RTN","HLEMEP",36,0)
 .....S DAY=""
"RTN","HLEMEP",37,0)
 .....F  S DAY=$O(@STATS@(SITE,TYPE,"RECEIVED","YEAR",YEAR,"MONTH",MONTH,"DAY",DAY)) Q:(DAY="")  D
"RTN","HLEMEP",38,0)
 ......I ((YEAR-1700)_$$PAD2(MONTH)_$$PAD2(DAY))<CUTDAY D
"RTN","HLEMEP",39,0)
 .......K @STATS@(SITE,TYPE,"RECEIVED","YEAR",YEAR,"MONTH",MONTH,"DAY",DAY)
"RTN","HLEMEP",40,0)
 ......E  D
"RTN","HLEMEP",41,0)
 .......S HOUR=0
"RTN","HLEMEP",42,0)
 .......F  S HOUR=$O(@STATS@(SITE,TYPE,"RECEIVED","YEAR",YEAR,"MONTH",MONTH,"DAY",DAY,"HOUR",HOUR)) Q:(HOUR="")  Q:((YEAR-1700)_$$PAD2(MONTH)_$$PAD2(DAY)_"."_$$PAD2(HOUR))>CUTHOUR  D
"RTN","HLEMEP",43,0)
 ........K @STATS@(SITE,TYPE,"RECEIVED","YEAR",YEAR,"MONTH",MONTH,"DAY",DAY,"HOUR",HOUR)
"RTN","HLEMEP",44,0)
 ;
"RTN","HLEMEP",45,0)
 ;
"RTN","HLEMEP",46,0)
 D CHECKOUT^HLEVAPI
"RTN","HLEMEP",47,0)
 K ^TMP("HLEVFLAG",$J)
"RTN","HLEMEP",48,0)
 Q
"RTN","HLEMEP",49,0)
 ;
"RTN","HLEMEP",50,0)
INPERSON ;entry point for running in the foreground
"RTN","HLEMEP",51,0)
 S ^TMP("HLEVFLAG",$J)="STOP"
"RTN","HLEMEP",52,0)
 D PURGE
"RTN","HLEMEP",53,0)
 Q
"RTN","HLEMEP",54,0)
PAD2(STRING) ;
"RTN","HLEMEP",55,0)
 ; pads a number on the left with '0', to a length of 2
"RTN","HLEMEP",56,0)
 Q $$RJ^XLFSTR(STRING,2,"0")
"RTN","HLEMEP",57,0)
 ;
"RTN","HLEMP")
0^62^B12525830
"RTN","HLEMP",1,0)
HLEMP ;ALB/CJM-HL7 - APIs for Monitor Events Log Profiles  ;07/10/2003
"RTN","HLEMP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLEMP",3,0)
 ;
"RTN","HLEMP",4,0)
FDEFAULT(DUZ) ;
"RTN","HLEMP",5,0)
 ;Description: Given a DUZ, returns the default profile, or "" on failure
"RTN","HLEMP",6,0)
 ;
"RTN","HLEMP",7,0)
 Q:'$G(DUZ) 0
"RTN","HLEMP",8,0)
 Q $O(^HLEV(776.5,"AC",DUZ,0))
"RTN","HLEMP",9,0)
 ;
"RTN","HLEMP",10,0)
 Q $S(Y=-1:0,1:+Y)
"RTN","HLEMP",11,0)
 ;
"RTN","HLEMP",12,0)
GET(IEN,PROFILE) ;
"RTN","HLEMP",13,0)
 ;Description - given the ien, it returns an array containing the profile
"RTN","HLEMP",14,0)
 ;Input:
"RTN","HLEMP",15,0)
 ;  IEN - ien of the profile
"RTN","HLEMP",16,0)
 ;Output:
"RTN","HLEMP",17,0)
 ;  function returns 0 on failure, 1 on success
"RTN","HLEMP",18,0)
 ;  PROFILE(   **pass by reference**
"RTN","HLEMP",19,0)
 ;  "ALL APPS" - 1 if all sending applications should be included, 0 otherwise
"RTN","HLEMP",20,0)
 ;  "ALL SITES" - 1 if all sites should be included, 0 otherwise
"RTN","HLEMP",21,0)
 ;  "ALL STATUSES" 1 if all review statuses should be included, 0 otherwise
"RTN","HLEMP",22,0)
 ;  "ALL TYPES" - 1 if all event types should be included, 0 otherwise
"RTN","HLEMP",23,0)
 ;  "APPS",<HL7 APPLICATION PARAMETER>) -list of sending applications to include - NOT the iens, but the names of the HL7 Application Parameter
"RTN","HLEMP",24,0)
 ;  "DUZ" - the duz of the profile's owner
"RTN","HLEMP",25,0)
 ;  "DEFAULT" - 1 if this is the default profile, 0 if it isn't
"RTN","HLEMP",26,0)
 ;  "IEN" - ien of the profile
"RTN","HLEMP",27,0)
 ;  "NAME" - name of the profile
"RTN","HLEMP",28,0)
 ;  "SITES",<institution ien>) - list of institution numbers to include
"RTN","HLEMP",29,0)
 ;  "START" - starting date/time for selecting events for display, in FM format
"RTN","HLEMP",30,0)
 ;  "STATUSES",<review status code>) - list of review status codes to include
"RTN","HLEMP",31,0)
 ;  "TYPES",<HL7 MONITOR EVENT TYPE>) - list of event type iens
"RTN","HLEMP",32,0)
 ;  "URGENT" - 1 means urgent only, 0 means disregard urgency
"RTN","HLEMP",33,0)
 ;
"RTN","HLEMP",34,0)
 ;
"RTN","HLEMP",35,0)
 Q:'$G(IEN) 0
"RTN","HLEMP",36,0)
 N NODE,SITE,TYPE,APP,STATUS,APPNAME,I
"RTN","HLEMP",37,0)
 K PROFILE S PROFILE=IEN
"RTN","HLEMP",38,0)
 S NODE=$G(^HLEV(776.5,IEN,0))
"RTN","HLEMP",39,0)
 Q:'$L(NODE) 0
"RTN","HLEMP",40,0)
 S PROFILE("IEN")=IEN
"RTN","HLEMP",41,0)
 S PROFILE("DUZ")=+NODE
"RTN","HLEMP",42,0)
 S PROFILE("NAME")=$P(NODE,"^",2)
"RTN","HLEMP",43,0)
 S PROFILE("DEFAULT")=$P(NODE,"^",3)
"RTN","HLEMP",44,0)
 S PROFILE("ALL SITES")=$P(NODE,"^",4)
"RTN","HLEMP",45,0)
 S PROFILE("ALL TYPES")=$P(NODE,"^",5)
"RTN","HLEMP",46,0)
 S PROFILE("ALL APPS")=$P(NODE,"^",6)
"RTN","HLEMP",47,0)
 S PROFILE("ALL STATUSES")=$P(NODE,"^",7)
"RTN","HLEMP",48,0)
 S START=+$P(NODE,"^",8) D
"RTN","HLEMP",49,0)
 .N NOW
"RTN","HLEMP",50,0)
 .S NOW=$$NOW^XLFDT
"RTN","HLEMP",51,0)
 .S PROFILE("START")=0
"RTN","HLEMP",52,0)
 .I START=1 S PROFILE("START")=$$FMADD^XLFDT(NOW,,-1) Q
"RTN","HLEMP",53,0)
 .I START=2 S PROFILE("START")=$$FMADD^XLFDT(NOW,,-2) Q
"RTN","HLEMP",54,0)
 .I START=3 S PROFILE("START")=$$FMADD^XLFDT(NOW,,-6) Q
"RTN","HLEMP",55,0)
 .I START=4 S PROFILE("START")=+NOW Q
"RTN","HLEMP",56,0)
 .I START=5 S PROFILE("START")=$$FMADD^XLFDT(NOW,-1) Q
"RTN","HLEMP",57,0)
 .I START=6 S PROFILE("START")=$$FMADD^XLFDT(+NOW,-1) Q
"RTN","HLEMP",58,0)
 .I START=7 S PROFILE("START")=$$FMADD^XLFDT(NOW,-2) Q
"RTN","HLEMP",59,0)
 .I START=8 S PROFILE("START")=$$FMADD^XLFDT(NOW,-3) Q
"RTN","HLEMP",60,0)
 .I START=9 S PROFILE("START")=$$FMADD^XLFDT(NOW,-7) Q
"RTN","HLEMP",61,0)
 S PROFILE("URGENT")=$P(NODE,"^",9)
"RTN","HLEMP",62,0)
 S SITE=0
"RTN","HLEMP",63,0)
 F I="APPS","SITES","TYPES","STATUSES" S PROFILE(I)=""
"RTN","HLEMP",64,0)
 F  S SITE=$O(^HLEV(776.5,IEN,1,SITE)) Q:'SITE  S PROFILE("SITES",+$G(^HLEV(776.5,IEN,1,SITE,0)))=""
"RTN","HLEMP",65,0)
 S TYPE=0
"RTN","HLEMP",66,0)
 F  S TYPE=$O(^HLEV(776.5,IEN,2,TYPE)) Q:'TYPE  S PROFILE("TYPES",+$G(^HLEV(776.5,IEN,2,TYPE,0)))=""
"RTN","HLEMP",67,0)
 S APP=0
"RTN","HLEMP",68,0)
 F  S APP=$O(^HLEV(776.5,IEN,3,APP)) Q:'APP  S PROFILE("APPS",$$APPNAME^HLEMU(+$G(^HLEV(776.5,IEN,3,APP,0))))=""
"RTN","HLEMP",69,0)
 S STATUS=0
"RTN","HLEMP",70,0)
 F  S STATUS=$O(^HLEV(776.5,IEN,4,STATUS)) Q:'STATUS  S APPNAME=$$APPNAME^HLEMU(+$G(^HLEV(776.5,IEN,4,STATUS,0))) I $L(APPNAME) S PROFILE("APPS",APPNAME)=""
"RTN","HLEMP",71,0)
 Q 1
"RTN","HLEMP",72,0)
 ;
"RTN","HLEMP",73,0)
CREATE(DUZ,NAME,ERROR) ;
"RTN","HLEMP",74,0)
 ;Given the DUZ and a name, creates a new profile of that name.
"RTN","HLEMP",75,0)
 ;Output-
"RTN","HLEMP",76,0)
 ;  function value - returns the new profile ien on success, 0 on failure
"RTN","HLEMP",77,0)
 ;  ERROR **optional, pass by reference** an array of errors
"RTN","HLEMP",78,0)
 ;
"RTN","HLEMP",79,0)
 Q:'$G(DUZ) 0
"RTN","HLEMP",80,0)
 Q:'$L(NAME) 0
"RTN","HLEMP",81,0)
 ;
"RTN","HLEMP",82,0)
 N DATA
"RTN","HLEMP",83,0)
 S DATA(.01)=DUZ
"RTN","HLEMP",84,0)
 S DATA(.02)=NAME
"RTN","HLEMP",85,0)
 Q $$ADD^HLEMU(776.5,,.DATA,.ERROR)
"RTN","HLEMP",86,0)
 ;
"RTN","HLEMP",87,0)
EDIT(PROFILE) ;
"RTN","HLEMP",88,0)
 ;Given the ien of a profile, allows a user to edit it.
"RTN","HLEMP",89,0)
 ;Input:  PROFILE - ien of a profile
"RTN","HLEMP",90,0)
 ;Output:  function returns 1 on success, 0 on failure, or on indication that the user did not complete the edit
"RTN","HLEMP",91,0)
 ;
"RTN","HLEMP",92,0)
 Q:'$G(PROFILE) 0
"RTN","HLEMP",93,0)
 Q:'$G(^HLEV(776.5,PROFILE,0)) 0
"RTN","HLEMP",94,0)
 K DA,DIE,DR
"RTN","HLEMP",95,0)
 S DA=PROFILE
"RTN","HLEMP",96,0)
 S DIE=776.5
"RTN","HLEMP",97,0)
 S DR=".02:.09"
"RTN","HLEMP",98,0)
 S DIE("NO^")="OUTOK"
"RTN","HLEMP",99,0)
 D ^DIE
"RTN","HLEMP",100,0)
 I '$D(Y),'$D(DTOUT),$$GET(PROFILE,.PROFILE) D
"RTN","HLEMP",101,0)
 .S DR=""
"RTN","HLEMP",102,0)
 .S DIE("NO^")="OUTOK"
"RTN","HLEMP",103,0)
 .I 'PROFILE("ALL SITES") S DR="1;"
"RTN","HLEMP",104,0)
 .I 'PROFILE("ALL TYPES") S DR=DR_"2;"
"RTN","HLEMP",105,0)
 .I 'PROFILE("ALL APPS") S DR=DR_"3;"
"RTN","HLEMP",106,0)
 .I 'PROFILE("ALL STATUSES") S DR=DR_4
"RTN","HLEMP",107,0)
 .D ^DIE
"RTN","HLEMP",108,0)
 Q $S($D(Y)!$D(DTOUT):0,1:1)
"RTN","HLEMP",109,0)
 ;
"RTN","HLEMP",110,0)
DELETE(PROFILE) ;
"RTN","HLEMP",111,0)
 ;Given the ien, deletes the profile
"RTN","HLEMP",112,0)
 Q $$DELETE^HLEMU(776.5,.PROFILE)
"RTN","HLEMP1")
0^63^B15451416
"RTN","HLEMP1",1,0)
HLEMP1 ;ALB/CJM-HL7 - Selector for Events Log Profiles  ;07/10/2003
"RTN","HLEMP1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLEMP1",3,0)
 ;
"RTN","HLEMP1",4,0)
SELECT(USER,SCRNSIZE) ;
"RTN","HLEMP1",5,0)
 ;Input:
"RTN","HLEMP1",6,0)
 ;  USER - the owner's DUZ
"RTN","HLEMP1",7,0)
 ;  SCRNSIZE is the number of lines available for scrolling
"RTN","HLEMP1",8,0)
 ;Output;
"RTN","HLEMP1",9,0)
 ;  function returns ien of profile if selection is made, 0 otherwise
"RTN","HLEMP1",10,0)
 ;
"RTN","HLEMP1",11,0)
 Q:'$G(USER) 0
"RTN","HLEMP1",12,0)
 I '$G(SCRNSIZE) S SCRNSIZE=10
"RTN","HLEMP1",13,0)
 S SCRNSIZE=+$G(SCRNSIZE)-1
"RTN","HLEMP1",14,0)
 S:SCRNSIZE<1 SCRNSIZE=1
"RTN","HLEMP1",15,0)
 N COUNT,CNT,PICK,PROFILE,ARY,NAME
"RTN","HLEMP1",16,0)
 S ARY="^TMP($J,""PROFILES"")"
"RTN","HLEMP1",17,0)
 K @ARY
"RTN","HLEMP1",18,0)
 S CNT=$$FINDALL(USER,ARY)
"RTN","HLEMP1",19,0)
 ;
"RTN","HLEMP1",20,0)
 ;return failure if no profiles found
"RTN","HLEMP1",21,0)
 Q:CNT=0 0
"RTN","HLEMP1",22,0)
 ;
"RTN","HLEMP1",23,0)
 ;if CNT=1 return the only profile
"RTN","HLEMP1",24,0)
 I CNT=1 S NAME=$O(@ARY@("NAME","")) Q $S(NAME'="":$O(@ARY@("NAME",NAME,0)),1:"")
"RTN","HLEMP1",25,0)
 ;
"RTN","HLEMP1",26,0)
 ;if CNT>1 loop through the profiles, displaying them to the user and let him choose
"RTN","HLEMP1",27,0)
 W !,"Please select the profile you wish to use"
"RTN","HLEMP1",28,0)
AGAIN ;
"RTN","HLEMP1",29,0)
 S (PICK,NAME)="",COUNT=0
"RTN","HLEMP1",30,0)
 F  S NAME=$O(@ARY@("NAME",NAME)) Q:(PICK'="")!(NAME="")  D
"RTN","HLEMP1",31,0)
 .S PROFILE=0 F  S PROFILE=$O(@ARY@("NAME",NAME,PROFILE)) Q:(PICK'="")!('PROFILE)  D  Q:NAME=""
"RTN","HLEMP1",32,0)
 ..S COUNT=COUNT+1,@ARY@("#",COUNT)=PROFILE W !,COUNT,"   ",NAME
"RTN","HLEMP1",33,0)
 ..I COUNT#SCRNSIZE=0 S PICK=$$CHOOSE(ARY)
"RTN","HLEMP1",34,0)
 I (PICK=""),COUNT,COUNT#SCRNSIZE'=0 S PICK=$$CHOOSE(ARY)
"RTN","HLEMP1",35,0)
 I PICK="" K DIR S DIR(0)="Y",DIR("A")="No profile selected! Try again",DIR("B")="YES" D ^DIR K DIR I '$D(DIRUT),Y=1 G AGAIN
"RTN","HLEMP1",36,0)
 I PICK="?" G AGAIN
"RTN","HLEMP1",37,0)
 K @ARY
"RTN","HLEMP1",38,0)
 Q $S((PICK'>0):"",1:PICK)
"RTN","HLEMP1",39,0)
 ;
"RTN","HLEMP1",40,0)
FINDALL(USER,ARY) ;finds all of the profiles belonging to USER and puts them on @ARY,returns the count
"RTN","HLEMP1",41,0)
 N PROFILE,COUNT,NAME
"RTN","HLEMP1",42,0)
 S NAME="",COUNT=0 F  S NAME=$O(^HLEV(776.5,"C",USER,NAME)) Q:'$L(NAME)  S PROFILE=$O(^HLEV(776.5,"C",USER,NAME,0)) I PROFILE,$D(^HLEV(776.5,PROFILE,0)) S @ARY@("NAME",$$UP^XLFSTR(NAME),PROFILE)="",COUNT=COUNT+1
"RTN","HLEMP1",43,0)
 Q COUNT
"RTN","HLEMP1",44,0)
 ;
"RTN","HLEMP1",45,0)
CHOOSE(ARY) ;asks the user to select a profile - @ARY@("#", is the array of profiles displayed so far(subscripted by the number on the list), @ARY@("NAME", the entire array (subscripted by name,ien)
"RTN","HLEMP1",46,0)
 ;sets NAME to " " and COUNT to 0 if ? is entered - starts display of list over
"RTN","HLEMP1",47,0)
 N ANS,QUIT,PICK,NEXT1,NEXT2
"RTN","HLEMP1",48,0)
 S QUIT=0
"RTN","HLEMP1",49,0)
 F  Q:QUIT  D  D:'QUIT MSG
"RTN","HLEMP1",50,0)
 .S (PICK,ANS)=""
"RTN","HLEMP1",51,0)
 .W !,"Choose 1-",COUNT,$S(COUNT<CNT:" or hit RETURN to see more",1:""),": "
"RTN","HLEMP1",52,0)
 .R ANS:DTIME
"RTN","HLEMP1",53,0)
 .I '$T!($E(ANS,1)="^") S PICK=-1,QUIT=1 Q
"RTN","HLEMP1",54,0)
 .I ANS="" S QUIT=1 Q
"RTN","HLEMP1",55,0)
 .I $E(ANS,1)="?" D HELP Q
"RTN","HLEMP1",56,0)
 .;
"RTN","HLEMP1",57,0)
 .;convert to upper case
"RTN","HLEMP1",58,0)
 .S ANS=$$UP^XLFSTR(ANS)
"RTN","HLEMP1",59,0)
 .
"RTN","HLEMP1",60,0)
 .;if user entered a displayed number then he's made his choice
"RTN","HLEMP1",61,0)
 .I $D(@ARY@("#",ANS)) S PICK=$G(@ARY@("#",ANS)),QUIT=1 Q
"RTN","HLEMP1",62,0)
 .;
"RTN","HLEMP1",63,0)
 .;if the user entered an exact name, and the name is unique then he's made his choice
"RTN","HLEMP1",64,0)
 .S PICK=$O(@ARY@("NAME",ANS,PICK)) I PICK,'$O(@ARY@("NAME",ANS,PICK)) S QUIT=1 Q
"RTN","HLEMP1",65,0)
 .Q:PICK  ;don't set QUIT=1 because name is not unique
"RTN","HLEMP1",66,0)
 .;
"RTN","HLEMP1",67,0)
 .;if the user entered a partial name accept it if there is exactly one match
"RTN","HLEMP1",68,0)
 .S NEXT1=$O(@ARY@("NAME",ANS)) Q:(NEXT1="")!($E(NEXT1,1,$L(ANS))'=ANS)
"RTN","HLEMP1",69,0)
 .S NEXT2=$O(@ARY@("NAME",NEXT1)) Q:($E(NEXT2,1,$L(ANS))=ANS)  ;because user did not type in enough to uniquely identify the profile
"RTN","HLEMP1",70,0)
 .;make sure there are not two profiles with the same name - if ok, accept it
"RTN","HLEMP1",71,0)
 .S PICK=$O(@ARY@("NAME",NEXT1,PICK)) Q:'PICK  I '$O(@ARY@("NAME",NEXT1,PICK)) S QUIT=1 Q
"RTN","HLEMP1",72,0)
 Q PICK
"RTN","HLEMP1",73,0)
 ;
"RTN","HLEMP1",74,0)
HELP ;choosing help restarts the display (by setting NAME="")
"RTN","HLEMP1",75,0)
 W !,"You can choose a profile by the number or by it's name.",!
"RTN","HLEMP1",76,0)
 D PAUSE
"RTN","HLEMP1",77,0)
 S QUIT=1,NAME="",PICK="?",COUNT=0
"RTN","HLEMP1",78,0)
 Q
"RTN","HLEMP1",79,0)
MSG ;
"RTN","HLEMP1",80,0)
 W !,"You must enter the number or name of the profile!"
"RTN","HLEMP1",81,0)
 D PAUSE
"RTN","HLEMP1",82,0)
 Q
"RTN","HLEMP1",83,0)
PAUSE ;
"RTN","HLEMP1",84,0)
 N ANS
"RTN","HLEMP1",85,0)
 W !,$C(7),"Press RETURN to continue..." R ANS:DTIME
"RTN","HLEMP1",86,0)
 Q
"RTN","HLEMRCV")
0^64^B7228994
"RTN","HLEMRCV",1,0)
HLEMRCV ;ALB/CJM - Mailman server for HL7 Monitoring Events;12 JUN 1997 10:00 am
"RTN","HLEMRCV",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLEMRCV",3,0)
 ;
"RTN","HLEMRCV",4,0)
RECEIVE ;Description: Read the exception message and file it.
"RTN","HLEMRCV",5,0)
 ;!!!! for testing interactively !!!!!!!!!!!!
"RTN","HLEMRCV",6,0)
 ;S XMER=0
"RTN","HLEMRCV",7,0)
 ;S XMFROM="HL7 EVENT LOG AT SAN FRANCISCO"
"RTN","HLEMRCV",8,0)
 ;S XMPOS=0
"RTN","HLEMRCV",9,0)
 ;S XMREC="D REC^XMS3"
"RTN","HLEMRCV",10,0)
 ;S XMRG="**APPLICATION DATA**"
"RTN","HLEMRCV",11,0)
 ;S XMXX="S.HLEM EVENT LOG SERVER"
"RTN","HLEMRCV",12,0)
 ;S XMZ=8557
"RTN","HLEMRCV",13,0)
 ;!!!!!!
"RTN","HLEMRCV",14,0)
 ;
"RTN","HLEMRCV",15,0)
 N EVENT,EXIT,TEMP
"RTN","HLEMRCV",16,0)
 S EXIT=0
"RTN","HLEMRCV",17,0)
 F  X XMREC Q:(XMER<0)  D  Q:EXIT
"RTN","HLEMRCV",18,0)
 .I $E(XMRG,1,2)="**" S EXIT=1 Q
"RTN","HLEMRCV",19,0)
 .N LABEL,DATA
"RTN","HLEMRCV",20,0)
 .S LABEL=$P(XMRG,":"),DATA=$P(XMRG,":",2,99)
"RTN","HLEMRCV",21,0)
 .Q:'$L(LABEL)
"RTN","HLEMRCV",22,0)
 .S EVENT(LABEL)=DATA
"RTN","HLEMRCV",23,0)
 ;
"RTN","HLEMRCV",24,0)
 ;don't save IEN from sending site
"RTN","HLEMRCV",25,0)
 K EVENT("IEN")
"RTN","HLEMRCV",26,0)
 ;
"RTN","HLEMRCV",27,0)
 ;need to get local pointers
"RTN","HLEMRCV",28,0)
 ;event type
"RTN","HLEMRCV",29,0)
 S:$D(EVENT("TYPE")) TEMP=$$FIND^HLEMT($P($G(EVENT("TYPE")),"^",2),$P($G(EVENT("TYPE")),"^"))
"RTN","HLEMRCV",30,0)
 I '$G(TEMP) D ERROR("UNKNOWN EVENT TYPE AT REMOTE SITE: "_EVENT("TYPE"),XMZ) Q
"RTN","HLEMRCV",31,0)
 S EVENT("TYPE")=TEMP
"RTN","HLEMRCV",32,0)
 ;get the institution ien
"RTN","HLEMRCV",33,0)
 S:$D(EVENT("SITE")) EVENT("SITE")=$$INSTIEN^HLEMU(EVENT("SITE"))
"RTN","HLEMRCV",34,0)
 ;
"RTN","HLEMRCV",35,0)
 ;don't enter duplicates (no updating at present)
"RTN","HLEMRCV",36,0)
 I $L($G(EVENT("ID"))),$D(^HLEV(776.4,"C",EVENT("ID"))) Q
"RTN","HLEMRCV",37,0)
 ;
"RTN","HLEMRCV",38,0)
 ;establish this event on this system
"RTN","HLEMRCV",39,0)
 S EVENT=$$STORE^HLEME1(.EVENT,.ERROR)
"RTN","HLEMRCV",40,0)
 ;
"RTN","HLEMRCV",41,0)
 ;if successful
"RTN","HLEMRCV",42,0)
 I EVENT D
"RTN","HLEMRCV",43,0)
 .;add a note with the ien of the message for traceability
"RTN","HLEMRCV",44,0)
 .I $$ADDNOTE^HLEME(EVENT,"REMOTE EVENT ADDED BY SERVER AT "_$$NOW^XLFDT_", MAILMAN MESSAGE IEN: "_$G(XMZ))
"RTN","HLEMRCV",45,0)
 ;
"RTN","HLEMRCV",46,0)
 ;if not successful
"RTN","HLEMRCV",47,0)
 I 'EVENT D ERROR("Fileman Failed to store remote event:  "_$G(ERROR),$G(XMZ)) Q
"RTN","HLEMRCV",48,0)
 ;
"RTN","HLEMRCV",49,0)
 ;handle application data
"RTN","HLEMRCV",50,0)
 I $E(XMRG,1,4)="**AP" D
"RTN","HLEMRCV",51,0)
 .S EXIT=0
"RTN","HLEMRCV",52,0)
 .F  X XMREC Q:(XMER<0)  D  Q:EXIT
"RTN","HLEMRCV",53,0)
 ..I $E(XMRG,1,4)="**NO" S EXIT=1 Q
"RTN","HLEMRCV",54,0)
 ..N VAR
"RTN","HLEMRCV",55,0)
 ..I $P(XMRG,":")="VARIABLE" D
"RTN","HLEMRCV",56,0)
 ...S VAR=$P(XMRG,":",2)
"RTN","HLEMRCV",57,0)
 ...X XMREC
"RTN","HLEMRCV",58,0)
 ...I $P(XMRG,":")="VALUE" S @VAR=$P(XMRG,":",2,99) I $$STOREVAR^HLEME(EVENT,.@VAR,VAR)
"RTN","HLEMRCV",59,0)
 ;
"RTN","HLEMRCV",60,0)
 ;handle notes
"RTN","HLEMRCV",61,0)
 I $E(XMRG,1,4)="**NO" D
"RTN","HLEMRCV",62,0)
 .S EXIT=0
"RTN","HLEMRCV",63,0)
 .F  X XMREC Q:(XMER<0)  D  Q:EXIT
"RTN","HLEMRCV",64,0)
 ..N VAR
"RTN","HLEMRCV",65,0)
 ..I $P(XMRG,":")="VAR" D
"RTN","HLEMRCV",66,0)
 ...S VAR=$P(XMRG,":",2)
"RTN","HLEMRCV",67,0)
 ...X XMREC
"RTN","HLEMRCV",68,0)
 ...I $L(XMRG) D
"RTN","HLEMRCV",69,0)
 ..I $$ADDNOTE^HLEME(EVENT,XMRG)
"RTN","HLEMRCV",70,0)
 ;
"RTN","HLEMRCV",71,0)
 S XMSER="S.HLEM EVENT LOG SERVER"
"RTN","HLEMRCV",72,0)
 D REMSBMSG^XMA1C
"RTN","HLEMRCV",73,0)
 Q
"RTN","HLEMRCV",74,0)
 ;
"RTN","HLEMRCV",75,0)
ERROR(COMMENT,MAIL) ;
"RTN","HLEMRCV",76,0)
 ;establishes a new event if this routine encounters an error.
"RTN","HLEMRCV",77,0)
 ;MAIL is the message id of the MailMan mesage
"RTN","HLEMRCV",78,0)
 ;
"RTN","HLEMRCV",79,0)
 N NEWEVENT,VAR
"RTN","HLEMRCV",80,0)
 S NEWEVENT=$$EVENT^HLEME("SRVR ERROR","HEALTH LEVEL SEVEN")
"RTN","HLEMRCV",81,0)
 S VAR("MAIL IEN")=$G(MAIL)
"RTN","HLEMRCV",82,0)
 I $$STOREVAR^HLEME(NEWEVENT,.VAR)
"RTN","HLEMRCV",83,0)
 I $$ADDNOTE^HLEME(NEWEVENT,$G(COMMENT))
"RTN","HLEMRCV",84,0)
 Q
"RTN","HLEMSA")
0^65^B1693913
"RTN","HLEMSA",1,0)
HLEMSA ;ALB/CJM -ListManager Screen for displaying Application-specific data stored with the event;12 JUN 1997 10:00 am
"RTN","HLEMSA",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLEMSA",3,0)
 ;
"RTN","HLEMSA",4,0)
EN(EVENT) ;Entry point to viewing an event's application-specific data
"RTN","HLEMSA",5,0)
 ;Input:  EVENT is the ien of an event
"RTN","HLEMSA",6,0)
 ;Output:  none
"RTN","HLEMSA",7,0)
 ;
"RTN","HLEMSA",8,0)
 N IDX
"RTN","HLEMSA",9,0)
 Q:'$G(EVENT)
"RTN","HLEMSA",10,0)
 ;
"RTN","HLEMSA",11,0)
 S IDX="^TMP(""HLEM APP DATA"",$J)"
"RTN","HLEMSA",12,0)
 D WAIT^DICD
"RTN","HLEMSA",13,0)
 D EN^VALM("HLEM DISPLAY APPLICATION DATA")
"RTN","HLEMSA",14,0)
 Q
"RTN","HLEMSA",15,0)
 ;
"RTN","HLEMSA",16,0)
 ;
"RTN","HLEMSA",17,0)
HDR ;Header code
"RTN","HLEMSA",18,0)
 ;S VALMHDR(1)="#   EVENT       DT/TM           APPLICATION    MSG      REVIEW        CNT"
"RTN","HLEMSA",19,0)
 Q
"RTN","HLEMSA",20,0)
 ;
"RTN","HLEMSA",21,0)
INIT ;Init variables and list array
"RTN","HLEMSA",22,0)
 D BLD
"RTN","HLEMSA",23,0)
 S VALMBCK="R"
"RTN","HLEMSA",24,0)
 Q
"RTN","HLEMSA",25,0)
 ;
"RTN","HLEMSA",26,0)
BLD ;Build array of application data
"RTN","HLEMSA",27,0)
 D CLEAN^VALM10
"RTN","HLEMSA",28,0)
 N I
"RTN","HLEMSA",29,0)
 K @IDX,VALMHDR
"RTN","HLEMSA",30,0)
 S VALMBG=1,(COUNT,VALMCNT)=0
"RTN","HLEMSA",31,0)
 ;
"RTN","HLEMSA",32,0)
 ;Build header
"RTN","HLEMSA",33,0)
 ;D HDR
"RTN","HLEMSA",34,0)
 S I=0 F  S I=$O(^HLEV(776.4,EVENT,3,I)) Q:'I  D
"RTN","HLEMSA",35,0)
 .S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),$G(^HLEV(776.4,EVENT,3,I,0))_"  =",1,"H")
"RTN","HLEMSA",36,0)
 .S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),$P($G(^HLEV(776.4,EVENT,3,I,2)),"^"),5)
"RTN","HLEMSA",37,0)
 Q
"RTN","HLEMSA",38,0)
 ;
"RTN","HLEMSA",39,0)
HELP ;Help code
"RTN","HLEMSA",40,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLEMSA",41,0)
 Q
"RTN","HLEMSA",42,0)
 ;
"RTN","HLEMSA",43,0)
EXIT ;Exit code
"RTN","HLEMSA",44,0)
 D CLEAN^VALM10
"RTN","HLEMSA",45,0)
 D CLEAR^VALM1
"RTN","HLEMSA",46,0)
 K @IDX
"RTN","HLEMSA",47,0)
 Q
"RTN","HLEMSA",48,0)
 ;
"RTN","HLEMSA",49,0)
EXPND ;Expand code
"RTN","HLEMSA",50,0)
 Q
"RTN","HLEMSE")
0^66^B17561652
"RTN","HLEMSE",1,0)
HLEMSE ;ALB/CJM -ListManager Screen for dsiplaying an Event;12 JUN 1997 10:00 am
"RTN","HLEMSE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLEMSE",3,0)
 ;
"RTN","HLEMSE",4,0)
EN(EVENT) ;Entry point to viewing a single HL7 Monitor Event
"RTN","HLEMSE",5,0)
 ;Input:  EVENT is the ien of an event
"RTN","HLEMSE",6,0)
 ;Output:  none
"RTN","HLEMSE",7,0)
 ;
"RTN","HLEMSE",8,0)
 N IDX
"RTN","HLEMSE",9,0)
 Q:'$G(EVENT)
"RTN","HLEMSE",10,0)
 ;
"RTN","HLEMSE",11,0)
 S IDX="^TMP(""HLEM"",$J,""EVENT"")"
"RTN","HLEMSE",12,0)
 D WAIT^DICD
"RTN","HLEMSE",13,0)
 D EN^VALM("HLEM DISPLAY ONE EVENT")
"RTN","HLEMSE",14,0)
 Q
"RTN","HLEMSE",15,0)
 ;
"RTN","HLEMSE",16,0)
 ;
"RTN","HLEMSE",17,0)
HDR ;Header code
"RTN","HLEMSE",18,0)
 Q
"RTN","HLEMSE",19,0)
 ;
"RTN","HLEMSE",20,0)
INIT ;Init variables and list array
"RTN","HLEMSE",21,0)
 Q:'$$GET^HLEME(EVENT,.EVENT)
"RTN","HLEMSE",22,0)
 D DISPLAY
"RTN","HLEMSE",23,0)
 D HDR
"RTN","HLEMSE",24,0)
 S VALMBCK="R"
"RTN","HLEMSE",25,0)
 Q
"RTN","HLEMSE",26,0)
 ;
"RTN","HLEMSE",27,0)
DISPLAY ;Build event screen
"RTN","HLEMSE",28,0)
 D CLEAN^VALM10
"RTN","HLEMSE",29,0)
 N ETYPE,I,STATION
"RTN","HLEMSE",30,0)
 K @IDX,VALMHDR
"RTN","HLEMSE",31,0)
 S VALMBG=1,(COUNT,VALMCNT)=0
"RTN","HLEMSE",32,0)
 ;
"RTN","HLEMSE",33,0)
 ;Build header
"RTN","HLEMSE",34,0)
 ;D HDR
"RTN","HLEMSE",35,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),"Event ID:",1,"H")
"RTN","HLEMSE",36,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,EVENT("ID"),19)
"RTN","HLEMSE",37,0)
 S ETYPE=$$GET^HLEMT(EVENT("TYPE"),.ETYPE)
"RTN","HLEMSE",38,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),"Event Type:",1,"H")
"RTN","HLEMSE",39,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,ETYPE("CODE"),19)
"RTN","HLEMSE",40,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,"Count:",40,"H")
"RTN","HLEMSE",41,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,EVENT("COUNT"),52)
"RTN","HLEMSE",42,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),"Descr:",1,"H")
"RTN","HLEMSE",43,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,ETYPE("BRIEF"),8)
"RTN","HLEMSE",44,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),"Site of Event:",1,"H")
"RTN","HLEMSE",45,0)
 S STATION=$$STATION^HLEMSU(EVENT("SITE"))
"RTN","HLEMSE",46,0)
 S:EVENT("SITE") VALMCNT=$$SET^HLEMSU(VALMCNT,$P(STATION,"^",1)_" #"_$P(STATION,"^",2),19)
"RTN","HLEMSE",47,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),"DT/TM of Event:",1,"H")
"RTN","HLEMSE",48,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,$E($$X(.01,EVENT("DT/TM")),1,18),19)
"RTN","HLEMSE",49,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,"DT/TM Reported:",40,"H")
"RTN","HLEMSE",50,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,$E($$X(.17,EVENT("DT/TM CREATED")),1,18),57)
"RTN","HLEMSE",51,0)
 S VALMCNT=$$INC^HLEMU(.VALMCNT)
"RTN","HLEMSE",52,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),"Status Information:",1,"RH")
"RTN","HLEMSE",53,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),"Urgent:",1,"H")
"RTN","HLEMSE",54,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,$$X(.12,EVENT("URGENT")),19,$S(EVENT("URGENT"):"BH",1:""))
"RTN","HLEMSE",55,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),"Automated Action:",1,"H")
"RTN","HLEMSE",56,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,$$X(.05,EVENT("ACTION STATUS")),19)
"RTN","HLEMSE",57,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,"DT/TM:",45,"H")
"RTN","HLEMSE",58,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,$E($$X(.09,EVENT("DT/TM ACTION")),1,18),52)
"RTN","HLEMSE",59,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),"Review Status:",1,"H")
"RTN","HLEMSE",60,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,$$X(.06,EVENT("REVIEW STATUS")),19)
"RTN","HLEMSE",61,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),"Reviewer:",1,"H")
"RTN","HLEMSE",62,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,$$X(.08,EVENT("REVIEWER")),19)
"RTN","HLEMSE",63,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,"Date:",45,"H")
"RTN","HLEMSE",64,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,$$X(.07,EVENT("DT/TM REVIEWED")),52)
"RTN","HLEMSE",65,0)
 I $L(EVENT("MSG ID")) D
"RTN","HLEMSE",66,0)
 .S VALMCNT=$$INC^HLEMU(.VALMCNT)
"RTN","HLEMSE",67,0)
 .S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),"HL7 Message Information:",1,"RH")
"RTN","HLEMSE",68,0)
 .S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),"Mssg ID:",1,"H")
"RTN","HLEMSE",69,0)
 .S VALMCNT=$$SET^HLEMSU(VALMCNT,EVENT("MSG ID"),19)
"RTN","HLEMSE",70,0)
 .S VALMCNT=$$SET^HLEMSU(VALMCNT,"Type:",40,"H")
"RTN","HLEMSE",71,0)
 .S VALMCNT=$$SET^HLEMSU(VALMCNT,EVENT("MSG TYPE")_"~"_EVENT("MSG EVENT"),54)
"RTN","HLEMSE",72,0)
 .S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),"Sending App:",1,"H")
"RTN","HLEMSE",73,0)
 .S VALMCNT=$$SET^HLEMSU(VALMCNT,EVENT("APPLICATION"),19)
"RTN","HLEMSE",74,0)
 .S VALMCNT=$$SET^HLEMSU(VALMCNT,"Logical Link:",40,"H")
"RTN","HLEMSE",75,0)
 .S VALMCNT=$$SET^HLEMSU(VALMCNT,EVENT("MSG LINK"),54)
"RTN","HLEMSE",76,0)
 S VALMCNT=$$INC^HLEMU(.VALMCNT)
"RTN","HLEMSE",77,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),"Notes:       ",1,"RH")
"RTN","HLEMSE",78,0)
 S I=0 F  S I=$O(^HLEV(776.4,EVENT("IEN"),1,I)) Q:'I  S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),$G(^HLEV(776.4,EVENT("IEN"),1,I,0)),1)
"RTN","HLEMSE",79,0)
 Q
"RTN","HLEMSE",80,0)
 ;
"RTN","HLEMSE",81,0)
HELP ;Help code
"RTN","HLEMSE",82,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLEMSE",83,0)
 Q
"RTN","HLEMSE",84,0)
 ;
"RTN","HLEMSE",85,0)
EXIT ;Exit code
"RTN","HLEMSE",86,0)
 D CLEAN^VALM10
"RTN","HLEMSE",87,0)
 D CLEAR^VALM1
"RTN","HLEMSE",88,0)
 K @IDX
"RTN","HLEMSE",89,0)
 Q
"RTN","HLEMSE",90,0)
 ;
"RTN","HLEMSE",91,0)
EXPND ;Expand code
"RTN","HLEMSE",92,0)
 Q
"RTN","HLEMSE",93,0)
 ;
"RTN","HLEMSE",94,0)
X(FIELD,VALUE) ;
"RTN","HLEMSE",95,0)
 ;changes a field value in file 774.4 to external form
"RTN","HLEMSE",96,0)
 Q $$EXTERNAL^DILFD(776.4,FIELD,"F",VALUE)
"RTN","HLEMSE1")
0^67^B261410
"RTN","HLEMSE1",1,0)
HLEMSE1 ;ALB/CJM,ALB/BRM - Actions for an individual event; 10/23/00 9:49am ; 2/27/01 1:25pm
"RTN","HLEMSE1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLEMSE1",3,0)
 ;
"RTN","HLEMSE1",4,0)
EDIT(EVENT) ;
"RTN","HLEMSE1",5,0)
 ;Allows the user to edit the notes and review status of an event
"RTN","HLEMSE1",6,0)
 I '$G(EVENT) S VALMBCK="" Q
"RTN","HLEMSE1",7,0)
 K DIE,DR,DA
"RTN","HLEMSE1",8,0)
 S DIE=776.4
"RTN","HLEMSE1",9,0)
 S DA=EVENT
"RTN","HLEMSE1",10,0)
 S DR="1;.06"
"RTN","HLEMSE1",11,0)
 D ^DIE
"RTN","HLEMSE1",12,0)
 K DIE,DR
"RTN","HLEMSE1",13,0)
 D INIT^HLEMSE
"RTN","HLEMSE1",14,0)
 Q
"RTN","HLEMSE1",15,0)
HELP(TYPE) ;
"RTN","HLEMSE1",16,0)
 ;Displays the full description of the event type
"RTN","HLEMSE1",17,0)
 D EN^HLEMSH($G(TYPE))
"RTN","HLEMSE1",18,0)
 Q
"RTN","HLEMSE1",19,0)
 ;
"RTN","HLEMSE1",20,0)
APPDATA(EVENT) ;
"RTN","HLEMSE1",21,0)
 ;Displays the application-specific data that was stored with the event
"RTN","HLEMSE1",22,0)
 D EN^HLEMSA($G(EVENT))
"RTN","HLEMSE1",23,0)
 Q
"RTN","HLEMSH")
0^68^B691486
"RTN","HLEMSH",1,0)
HLEMSH ;ALB/CJM -ListManager Screen for displaying an Event;12 JUN 1997 10:00 am
"RTN","HLEMSH",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLEMSH",3,0)
 ;
"RTN","HLEMSH",4,0)
EN(TYPE) ;Entry point to viewing of help for a type of event
"RTN","HLEMSH",5,0)
 ;Input: TYPE is the ien of an HL7 MONITOR EVENT TYPE
"RTN","HLEMSH",6,0)
 ;Output:  none
"RTN","HLEMSH",7,0)
 ;
"RTN","HLEMSH",8,0)
 Q:'$G(TYPE)
"RTN","HLEMSH",9,0)
 ;
"RTN","HLEMSH",10,0)
 D WAIT^DICD
"RTN","HLEMSH",11,0)
 D EN^VALM("HLEM EVENT HELP")
"RTN","HLEMSH",12,0)
 Q
"RTN","HLEMSH",13,0)
 ;
"RTN","HLEMSH",14,0)
INIT ;Init variables and list array
"RTN","HLEMSH",15,0)
 S VALMAR="^HLEV(776.3,TYPE,3)"
"RTN","HLEMSH",16,0)
 S VALMCNT=$P($G(@VALMAR@(0)),"^",3)
"RTN","HLEMSH",17,0)
 I 'VALMCNT S VALMAR="VALMAR",@VALMAR@(1,0)="NO HELP AVAILABLE!",VALMCNT=1
"RTN","HLEMSH",18,0)
 S VALMBG=1
"RTN","HLEMSH",19,0)
 S VALMBCK="R"
"RTN","HLEMSH",20,0)
 Q
"RTN","HLEMSH",21,0)
 ;
"RTN","HLEMSH",22,0)
 ;
"RTN","HLEMSH",23,0)
HELP ;Help code
"RTN","HLEMSH",24,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLEMSH",25,0)
 Q
"RTN","HLEMSH",26,0)
 ;
"RTN","HLEMSH",27,0)
EXIT ;Exit code
"RTN","HLEMSH",28,0)
 D CLEAN^VALM10
"RTN","HLEMSH",29,0)
 D CLEAR^VALM1
"RTN","HLEMSH",30,0)
 ;
"RTN","HLEMSH",31,0)
 Q
"RTN","HLEMSH",32,0)
 ;
"RTN","HLEMSH",33,0)
EXPND ;Expand code
"RTN","HLEMSH",34,0)
 Q
"RTN","HLEMSL")
0^70^B24311726
"RTN","HLEMSL",1,0)
HLEMSL ;ALB/CJM -List Manager Screen for Event List;12 JUN 1997 10:00 am
"RTN","HLEMSL",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLEMSL",3,0)
 ;
"RTN","HLEMSL",4,0)
EN ;Entry point to viewing the HL7 Monitor Event Log
"RTN","HLEMSL",5,0)
 ;
"RTN","HLEMSL",6,0)
 N IDX,SITE,PROFILE
"RTN","HLEMSL",7,0)
 S PROFILE=$$PROFILE
"RTN","HLEMSL",8,0)
 Q:'PROFILE
"RTN","HLEMSL",9,0)
 I PROFILE S PROFILE=$$GET^HLEMP(PROFILE,.PROFILE)
"RTN","HLEMSL",10,0)
 ;
"RTN","HLEMSL",11,0)
 S IDX="^TMP(""HLEM"",$J,""EVENTS"")"
"RTN","HLEMSL",12,0)
 D WAIT^DICD
"RTN","HLEMSL",13,0)
 D EN^VALM("HLEM DISPLAY EVENTS")
"RTN","HLEMSL",14,0)
 Q
"RTN","HLEMSL",15,0)
 ;
"RTN","HLEMSL",16,0)
PROFILE() ;returns the profile to use in building the display.
"RTN","HLEMSL",17,0)
 ;  1)First checks if there is a default profile, if so,returns it
"RTN","HLEMSL",18,0)
 ;  2)If no default profile, but the user has exactly 1 profile, ruturs that
"RTN","HLEMSL",19,0)
 ;  3) If multiple profiles, asks the user to select one.
"RTN","HLEMSL",20,0)
 ;  4) If the user has no profile, he is asked to create one.
"RTN","HLEMSL",21,0)
 ;Input:  DUZ must be defined
"RTN","HLEMSL",22,0)
 ;Output: function returns profile's ien, or "" if not successful
"RTN","HLEMSL",23,0)
 ;
"RTN","HLEMSL",24,0)
 N PROFILE
"RTN","HLEMSL",25,0)
 ;get the user's profile
"RTN","HLEMSL",26,0)
 I '$G(DUZ) W !,"** Your DUZ is not defined, please report this to your IRM!" Q ""
"RTN","HLEMSL",27,0)
 S PROFILE=$$FDEFAULT^HLEMP(DUZ)
"RTN","HLEMSL",28,0)
 I 'PROFILE D
"RTN","HLEMSL",29,0)
 .;there is no default profile, check for others
"RTN","HLEMSL",30,0)
 .S PROFILE=$$SELECT^HLEMP1($G(DUZ),10)
"RTN","HLEMSL",31,0)
 I 'PROFILE,$$ASKYESNO^HLEMU("You need a profile before viewing the HL7 Monitor Event Log,would you like to  create a new profile now","YES") D
"RTN","HLEMSL",32,0)
 .N NAME,I
"RTN","HLEMSL",33,0)
 .F I=1:1:20 I '$D(^HLEV(776.5,"C",DUZ,"NEW PROFILE"_I)) S NAME="NEW PROFILE"_I Q
"RTN","HLEMSL",34,0)
 .S:$D(NAME) PROFILE=$$CREATE^HLEMP(DUZ,NAME)
"RTN","HLEMSL",35,0)
 .I PROFILE,'$$EDIT^HLEMP(PROFILE) D
"RTN","HLEMSL",36,0)
 ..I '$$DELETE^HLEMP(PROFILE) W !,"Incomplete profile couln't be deleted!"
"RTN","HLEMSL",37,0)
 ..S PROFILE=""
"RTN","HLEMSL",38,0)
 Q PROFILE
"RTN","HLEMSL",39,0)
 ;
"RTN","HLEMSL",40,0)
HDR ;Header code
"RTN","HLEMSL",41,0)
 S VALMHDR(1)="#    TYPE        DT/TM         APP             MSG      REVIEW         CNT"
"RTN","HLEMSL",42,0)
 Q
"RTN","HLEMSL",43,0)
 ;
"RTN","HLEMSL",44,0)
INIT ;Init variables and list array
"RTN","HLEMSL",45,0)
 D BLD
"RTN","HLEMSL",46,0)
 S VALMSG="USER PROFILE: "_PROFILE("NAME")
"RTN","HLEMSL",47,0)
 D HDR
"RTN","HLEMSL",48,0)
 S VALMBCK="R"
"RTN","HLEMSL",49,0)
 Q
"RTN","HLEMSL",50,0)
 ;
"RTN","HLEMSL",51,0)
BLD ;Build event log screen
"RTN","HLEMSL",52,0)
 D CLEAN^VALM10
"RTN","HLEMSL",53,0)
 N SITE,TIME,TYPE,STATUS,COUNT
"RTN","HLEMSL",54,0)
 K @IDX,VALMHDR
"RTN","HLEMSL",55,0)
 S VALMBG=1,(COUNT,VALMCNT)=0
"RTN","HLEMSL",56,0)
 ;
"RTN","HLEMSL",57,0)
 ;Build header
"RTN","HLEMSL",58,0)
 D HDR
"RTN","HLEMSL",59,0)
 ;
"RTN","HLEMSL",60,0)
 ;Build list area
"RTN","HLEMSL",61,0)
 ;what sites to include? Put in alphabetical order
"RTN","HLEMSL",62,0)
 S SITE="" F  S SITE=$O(^HLEV(776.4,"D",SITE)) Q:'SITE  D
"RTN","HLEMSL",63,0)
 .I 'PROFILE("ALL SITES"),'$D(PROFILE("SITES",SITE)) Q
"RTN","HLEMSL",64,0)
 .N STATION
"RTN","HLEMSL",65,0)
 .S STATION=$$STATION^HLEMSU(SITE) S:$L($P(STATION,"^")) SITE($P(STATION,"^"))=SITE
"RTN","HLEMSL",66,0)
 ;
"RTN","HLEMSL",67,0)
 S SITE=""
"RTN","HLEMSL",68,0)
 F  S SITE=$O(SITE(SITE)) Q:'$L(SITE)  D
"RTN","HLEMSL",69,0)
 .N FIRST
"RTN","HLEMSL",70,0)
 .S FIRST=1
"RTN","HLEMSL",71,0)
 .S TYPE=0
"RTN","HLEMSL",72,0)
 .F  S TYPE=$O(^HLEV(776.4,"D",SITE(SITE),TYPE)) Q:'TYPE  D:(PROFILE("ALL TYPES"))!($D(PROFILE("TYPES",TYPE)))
"RTN","HLEMSL",73,0)
 ..;maintain an index for the event type
"RTN","HLEMSL",74,0)
 ..S @IDX@("SITE",SITE(SITE),"TYPE",TYPE)=VALMCNT
"RTN","HLEMSL",75,0)
 ..S TIME=PROFILE("START")
"RTN","HLEMSL",76,0)
 ..F  S TIME=$O(^HLEV(776.4,"D",SITE(SITE),TYPE,TIME)) Q:'TIME  D
"RTN","HLEMSL",77,0)
 ...S STATUS=""
"RTN","HLEMSL",78,0)
 ...S STATUS=$O(^HLEV(776.4,"D",SITE(SITE),TYPE,TIME,STATUS)) Q:'$L(STATUS)  D
"RTN","HLEMSL",79,0)
 ....N EVENTIEN
"RTN","HLEMSL",80,0)
 ....S EVENTIEN=0
"RTN","HLEMSL",81,0)
 ....F  S EVENTIEN=$O(^HLEV(776.4,"D",SITE(SITE),TYPE,TIME,STATUS,EVENTIEN)) Q:'EVENTIEN  D
"RTN","HLEMSL",82,0)
 .....N EVENT
"RTN","HLEMSL",83,0)
 .....Q:'$$GET^HLEME(EVENTIEN,.EVENT)
"RTN","HLEMSL",84,0)
 .....I PROFILE("URGENT"),'EVENT("URGENT") Q
"RTN","HLEMSL",85,0)
 .....I 'PROFILE("ALL APPS") Q:'$L(EVENT("APPLICATION"))  Q:'$D(PROFILE(EVENT("APPLICATION")))
"RTN","HLEMSL",86,0)
 .....;
"RTN","HLEMSL",87,0)
 .....;if this is the first event for this site,display a header
"RTN","HLEMSL",88,0)
 .....I FIRST D  S FIRST=0
"RTN","HLEMSL",89,0)
 ......;S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),$$CENTER^HLEMSU("SITE: "_SITE_"   STATION #: "_$P($$STATION^HLEMSU(SITE(SITE)),"^",2)),1,"RUH")
"RTN","HLEMSL",90,0)
 ......I $$SET^HLEMSU(VALMCNT,$$LJ^XLFSTR($E($G(@IDX@(VALMCNT,0)),4,80),77),4,"U")
"RTN","HLEMSL",91,0)
 ......S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),SITE_"   STATION #: "_$P($$STATION^HLEMSU(SITE(SITE)),"^",2),1,"H")
"RTN","HLEMSL",92,0)
 ......;also, maintain an index for searching
"RTN","HLEMSL",93,0)
 ......S @IDX@("SITE",SITE(SITE))=VALMCNT
"RTN","HLEMSL",94,0)
 ......S @IDX@("SITE",SITE)=VALMCNT
"RTN","HLEMSL",95,0)
 .....;
"RTN","HLEMSL",96,0)
 .....;display the event
"RTN","HLEMSL",97,0)
 .....D DISPLAY(.EVENT,.VALMCNT,.COUNT)
"RTN","HLEMSL",98,0)
 Q
"RTN","HLEMSL",99,0)
 ;
"RTN","HLEMSL",100,0)
DISPLAY(EVENT,VALMCNT,COUNT) ;
"RTN","HLEMSL",101,0)
 ;Adds one line for an event to the list, increments the counts of lines and events, and maintains the search index for events on the list
"RTN","HLEMSL",102,0)
 ;
"RTN","HLEMSL",103,0)
 N CODE,TIME
"RTN","HLEMSL",104,0)
 S @IDX@("EVENT",$$INC^HLEMU(.COUNT))=EVENT("IEN")
"RTN","HLEMSL",105,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),COUNT,1,"R")
"RTN","HLEMSL",106,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,$$CODE^HLEMT(EVENT("TYPE")),6)
"RTN","HLEMSL",107,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,$$FMTE^XLFDT($E(EVENT("DT/TM"),1,12),2),17)
"RTN","HLEMSL",108,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,$E(EVENT("APPLICATION"),1,15),32)
"RTN","HLEMSL",109,0)
 I $L(EVENT("MSG TYPE")) S VALMCNT=$$SET^HLEMSU(VALMCNT,EVENT("MSG TYPE")_"~"_EVENT("MSG EVENT"),48)
"RTN","HLEMSL",110,0)
 S VALMCNT=$$SET^HLEMSU(VALMCNT,$E($$EXTERNAL^DILFD(776.4,.06,"F",EVENT("REVIEW STATUS")),1,15),57)
"RTN","HLEMSL",111,0)
 I EVENT("COUNT")>1 S VALNCNT=$$SET^HLEMSU(VALMCNT,EVENT("COUNT"),72)
"RTN","HLEMSL",112,0)
 I EVENT("URGENT") S VALMCNT=$$SET^HLEMSU(VALMCNT,"*",79,"BRH")
"RTN","HLEMSL",113,0)
 Q
"RTN","HLEMSL",114,0)
 ;
"RTN","HLEMSL",115,0)
HELP ;Help code
"RTN","HLEMSL",116,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLEMSL",117,0)
 Q
"RTN","HLEMSL",118,0)
 ;
"RTN","HLEMSL",119,0)
EXIT ;Exit code
"RTN","HLEMSL",120,0)
 D CLEAN^VALM10
"RTN","HLEMSL",121,0)
 D CLEAR^VALM1
"RTN","HLEMSL",122,0)
 K @IDX
"RTN","HLEMSL",123,0)
 Q
"RTN","HLEMSL",124,0)
 ;
"RTN","HLEMSL",125,0)
EXPND ;Expand code
"RTN","HLEMSL",126,0)
 Q
"RTN","HLEMSL1")
0^69^B5096862
"RTN","HLEMSL1",1,0)
HLEMSL1 ;ALB/CJM,ALB/BRM - Actions for the HL7 Monitor Event Log; 2/27/01 1:25pm
"RTN","HLEMSL1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEMSL1",3,0)
 ;
"RTN","HLEMSL1",4,0)
SELECT ;Allows the user to change profiles, then rebuilds the Events Log
"RTN","HLEMSL1",5,0)
 N PROF
"RTN","HLEMSL1",6,0)
 D FULL^VALM1
"RTN","HLEMSL1",7,0)
 S PROF=$$SELECT^HLEMP1($G(DUZ),20)
"RTN","HLEMSL1",8,0)
 I PROF,PROF'=$G(PROFILE) D
"RTN","HLEMSL1",9,0)
 .S PROFILE=$$GET^HLEMP(PROF,.PROFILE)
"RTN","HLEMSL1",10,0)
 .D INIT^HLEMSL
"RTN","HLEMSL1",11,0)
 S VALMBCK="R"
"RTN","HLEMSL1",12,0)
 Q
"RTN","HLEMSL1",13,0)
 ;
"RTN","HLEMSL1",14,0)
EDIT ;Allows the user to select a profile & edit it, then rebuilds the Events Log
"RTN","HLEMSL1",15,0)
 N PROF
"RTN","HLEMSL1",16,0)
 D FULL^VALM1
"RTN","HLEMSL1",17,0)
 S PROF=$$SELECT^HLEMP1($G(DUZ),20)
"RTN","HLEMSL1",18,0)
 I PROF D
"RTN","HLEMSL1",19,0)
 .I $$EDIT^HLEMP(PROF)
"RTN","HLEMSL1",20,0)
 .S PROFILE=$$GET^HLEMP(PROF,.PROFILE)
"RTN","HLEMSL1",21,0)
 .D INIT^HLEMSL
"RTN","HLEMSL1",22,0)
 S VALMBCK="R"
"RTN","HLEMSL1",23,0)
 Q
"RTN","HLEMSL1",24,0)
 ;
"RTN","HLEMSL1",25,0)
NEW ;Allows the user to create a new profile, then rebuilds the Events Log
"RTN","HLEMSL1",26,0)
 N PROF,NAME,I
"RTN","HLEMSL1",27,0)
 D FULL^VALM1
"RTN","HLEMSL1",28,0)
 F I=1:1:20 I '$D(^HLEV(776.5,"C",DUZ,"NEW PROFILE"_I)) S NAME="NEW PROFILE"_I Q
"RTN","HLEMSL1",29,0)
 S:$D(NAME) PROF=$$CREATE^HLEMP(DUZ,NAME)
"RTN","HLEMSL1",30,0)
 I PROF,'$$EDIT^HLEMP(PROF) D
"RTN","HLEMSL1",31,0)
 .I '$$DELETE^HLEMP(PROFILE) W !,"Incomplete profile couln't be deleted!"
"RTN","HLEMSL1",32,0)
 .S PROFILE=""
"RTN","HLEMSL1",33,0)
 I PROF,PROF'=$G(PROFILE) D
"RTN","HLEMSL1",34,0)
 .S PROFILE=$$GET^HLEMP(PROF,.PROFILE)
"RTN","HLEMSL1",35,0)
 .D INIT^HLEMSL
"RTN","HLEMSL1",36,0)
 S VALMBCK="R"
"RTN","HLEMSL1",37,0)
 Q
"RTN","HLEMSL1",38,0)
 ;
"RTN","HLEMSL1",39,0)
GOSITE ;Allows the user to select a site and jump the display to it.
"RTN","HLEMSL1",40,0)
 N SITE,START
"RTN","HLEMSL1",41,0)
 S START=0
"RTN","HLEMSL1",42,0)
 D FULL^VALM1
"RTN","HLEMSL1",43,0)
 I $$PROMPT^HLEMU(776.4,.03,"",.SITE,1) D
"RTN","HLEMSL1",44,0)
 .S START=$G(@IDX@("SITE",SITE)) Q:START
"RTN","HLEMSL1",45,0)
 .S SITE=$P($G(^DIC(4,SITE,0)),"^",1)
"RTN","HLEMSL1",46,0)
 .Q:'$L(SITE)
"RTN","HLEMSL1",47,0)
 .S START=$G(@IDX@("SITE",SITE)) Q:START
"RTN","HLEMSL1",48,0)
 .S SITE=$O(@IDX@("SITE",SITE),-1)
"RTN","HLEMSL1",49,0)
 .I $L(SITE) S START=$G(@IDX@("SITE",SITE))
"RTN","HLEMSL1",50,0)
 I START S VALMBG=START
"RTN","HLEMSL1",51,0)
 S VALMBCK="R"
"RTN","HLEMSL1",52,0)
 Q
"RTN","HLEMSL1",53,0)
 ;
"RTN","HLEMSL1",54,0)
CNTSITES() ;
"RTN","HLEMSL1",55,0)
 N SITE,COUNT
"RTN","HLEMSL1",56,0)
 Q:'$D(IDX) 0
"RTN","HLEMSL1",57,0)
 S (COUNT,SITE)=""
"RTN","HLEMSL1",58,0)
 F  S SITE=$O(@IDX@("SITE",SITE)) Q:SITE=""  S COUNT=COUNT+1
"RTN","HLEMSL1",59,0)
 S COUNT=COUNT\2
"RTN","HLEMSL1",60,0)
 Q COUNT
"RTN","HLEMSL1",61,0)
 ;
"RTN","HLEMSL1",62,0)
SELECTE ;Allows the user to select a single event for display and editing.
"RTN","HLEMSL1",63,0)
 K DIR
"RTN","HLEMSL1",64,0)
 S DIR("A")="Enter the number of the event to display"
"RTN","HLEMSL1",65,0)
 S DIR(0)="N^1:"_$O(@IDX@("EVENT",9999999),-1)_":0"
"RTN","HLEMSL1",66,0)
 D ^DIR K DIR I (Y=-1)!$D(DIRUT) S QUIT=1 Q
"RTN","HLEMSL1",67,0)
 D EN^HLEMSE($G(@IDX@("EVENT",Y)))
"RTN","HLEMSL1",68,0)
 S VALMBCK="R"
"RTN","HLEMSL1",69,0)
 Q
"RTN","HLEMSND")
0^71^B14118964
"RTN","HLEMSND",1,0)
HLEMSND ;ALB/CJM - Sends events to remote event servers;12 JUN 1997 10:00 am
"RTN","HLEMSND",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLEMSND",3,0)
 ;
"RTN","HLEMSND",4,0)
SENDALL ;send all events pending distribution to remote locations
"RTN","HLEMSND",5,0)
 L +^HLEV(776.4,"AK"):0
"RTN","HLEMSND",6,0)
 Q:'$T
"RTN","HLEMSND",7,0)
 D START^HLEVAPI()
"RTN","HLEMSND",8,0)
 N EVENT
"RTN","HLEMSND",9,0)
 S IDX="^HLEV(776.4,""AK"")"
"RTN","HLEMSND",10,0)
 S EVENT=0
"RTN","HLEMSND",11,0)
 F  S EVENT=$O(@IDX@(EVENT)) Q:'EVENT  D
"RTN","HLEMSND",12,0)
 .I $$SEND(EVENT)
"RTN","HLEMSND",13,0)
 .K @IDX@(EVENT)
"RTN","HLEMSND",14,0)
 L -^HLEV(776.4,"AK")
"RTN","HLEMSND",15,0)
 D CHECKOUT^HLEVAPI
"RTN","HLEMSND",16,0)
 Q
"RTN","HLEMSND",17,0)
 ;
"RTN","HLEMSND",18,0)
 ;
"RTN","HLEMSND",19,0)
SEND(IEN) ;
"RTN","HLEMSND",20,0)
 ;Sends the event=IEN to its remote servers
"RTN","HLEMSND",21,0)
 ;
"RTN","HLEMSND",22,0)
 N MSG,EVENT,TYPE,MAILMSG,DOMAIN
"RTN","HLEMSND",23,0)
 ;
"RTN","HLEMSND",24,0)
 ;get the event
"RTN","HLEMSND",25,0)
 Q:'$$GET^HLEME(IEN,.EVENT) 0
"RTN","HLEMSND",26,0)
 ;
"RTN","HLEMSND",27,0)
 ;get the event type
"RTN","HLEMSND",28,0)
 Q:'$$GET^HLEMT(EVENT("TYPE"),.TYPE) 0
"RTN","HLEMSND",29,0)
 ;
"RTN","HLEMSND",30,0)
 ;are there any remote locations to send this event type?
"RTN","HLEMSND",31,0)
 S DOMAIN=0
"RTN","HLEMSND",32,0)
 F  S DOMAIN=$O(TYPE("DOMAIN",DOMAIN)) Q:'DOMAIN  D
"RTN","HLEMSND",33,0)
 .I '$L(TYPE("DOMAIN",DOMAIN)) S DOMAIN(DOMAIN)="" Q
"RTN","HLEMSND",34,0)
 .;
"RTN","HLEMSND",35,0)
 .;there is a screen, execute it
"RTN","HLEMSND",36,0)
 .N HLEVENT
"RTN","HLEMSND",37,0)
 .M HLEVENT=EVENT
"RTN","HLEMSND",38,0)
 .N EVENT
"RTN","HLEMSND",39,0)
 .X TYPE("DOMAIN",DOMAIN)
"RTN","HLEMSND",40,0)
 .I $T S DOMAIN(DOMAIN)=""
"RTN","HLEMSND",41,0)
 Q:'$O(DOMAIN(0)) 0  ;there are no remote locations!
"RTN","HLEMSND",42,0)
 ;
"RTN","HLEMSND",43,0)
 ;location of where the message will be built, referenced by indirection
"RTN","HLEMSND",44,0)
 S MSG="^TMP($J,""HL7 MONITOR EVENT"")"
"RTN","HLEMSND",45,0)
 K @MSG
"RTN","HLEMSND",46,0)
 ;
"RTN","HLEMSND",47,0)
 D BUILD(MSG,.EVENT,.TYPE)
"RTN","HLEMSND",48,0)
 S MAILMSG=$$MAIL(MSG,.DOMAIN)
"RTN","HLEMSND",49,0)
 I MAILMSG'="" D
"RTN","HLEMSND",50,0)
 .N DA,DATA,ERROR
"RTN","HLEMSND",51,0)
 .S DA(1)=IEN
"RTN","HLEMSND",52,0)
 .S DATA(.01)=MAILMSG
"RTN","HLEMSND",53,0)
 .I '$$ADD^HLEMU(776.42,.DA,.DATA,.ERROR) D
"RTN","HLEMSND",54,0)
 ..D ERROR(.EVENT)
"RTN","HLEMSND",55,0)
 ..I '$D(ZTQUEUED) W !,"FAILED TO ADD THE MAILMAN MESSAGE NUMBER TO THE EVENT ",ERROR ;then fileman failed!
"RTN","HLEMSND",56,0)
 E  D
"RTN","HLEMSND",57,0)
 .D ERROR(.EVENT)
"RTN","HLEMSND",58,0)
 .I '$D(ZTQUEUED) W !,"MAILMAN FAILED TO SEND HL7 LOG EVENT TO REMOTE SERVER"
"RTN","HLEMSND",59,0)
 K @MSG
"RTN","HLEMSND",60,0)
 Q 1
"RTN","HLEMSND",61,0)
 ;
"RTN","HLEMSND",62,0)
BUILD(MSG,EVENT,TYPE) ;
"RTN","HLEMSND",63,0)
 ;EVENT - event array, pass by reference
"RTN","HLEMSND",64,0)
 ;TYPE - event type array, pass by reference
"RTN","HLEMSND",65,0)
 ;
"RTN","HLEMSND",66,0)
 N SUB,LINE,TXT
"RTN","HLEMSND",67,0)
 ;
"RTN","HLEMSND",68,0)
 ;can't send local pointers!
"RTN","HLEMSND",69,0)
 S EVENT("SITE")=$$STATNUM^HLEMU(EVENT("SITE"))
"RTN","HLEMSND",70,0)
 S EVENT("TYPE")=$$GETFIELD^HLEMU(9.4,.01,TYPE("PACKAGE"))_"^"_TYPE("CODE")
"RTN","HLEMSND",71,0)
 S EVENT("REVIEWER")=""
"RTN","HLEMSND",72,0)
 ;
"RTN","HLEMSND",73,0)
 S SUB=""
"RTN","HLEMSND",74,0)
 F  S SUB=$O(EVENT(SUB)) Q:(SUB="")  D:$D(EVENT(SUB))'[0
"RTN","HLEMSND",75,0)
 .D ADDDATA(MSG,SUB,EVENT(SUB))
"RTN","HLEMSND",76,0)
 ;
"RTN","HLEMSND",77,0)
 ;add the application data
"RTN","HLEMSND",78,0)
 D ADDLINE(MSG,"**APPLICATION DATA**")
"RTN","HLEMSND",79,0)
 S LINE=0
"RTN","HLEMSND",80,0)
 F  S LINE=$O(^HLEV(776.4,EVENT("IEN"),3,LINE)) Q:'LINE  D
"RTN","HLEMSND",81,0)
 .S TXT=$G(^HLEV(776.4,EVENT("IEN"),3,LINE,0))
"RTN","HLEMSND",82,0)
 .Q:'$L(TXT)
"RTN","HLEMSND",83,0)
 .D ADDDATA(MSG,"VARIABLE",TXT)
"RTN","HLEMSND",84,0)
 .S TXT=$G(^HLEV(776.4,EVENT("IEN"),3,LINE,2))
"RTN","HLEMSND",85,0)
 .D ADDDATA(MSG,"VALUE",TXT)
"RTN","HLEMSND",86,0)
 ;
"RTN","HLEMSND",87,0)
 ;add the notes
"RTN","HLEMSND",88,0)
 D ADDLINE(MSG,"**NOTES**")
"RTN","HLEMSND",89,0)
 S LINE=0
"RTN","HLEMSND",90,0)
 F  S LINE=$O(^HLEV(776.4,EVENT("IEN"),1,LINE)) Q:'LINE  D
"RTN","HLEMSND",91,0)
 .S TXT=$G(^HLEV(776.4,EVENT("IEN"),1,LINE,0))
"RTN","HLEMSND",92,0)
 .D:$L(TXT) ADDLINE(MSG,TXT)
"RTN","HLEMSND",93,0)
 Q
"RTN","HLEMSND",94,0)
 ;
"RTN","HLEMSND",95,0)
MAIL(MSG,DOMAIN) ;
"RTN","HLEMSND",96,0)
 ;Sends the message located at @MSG to the HLEM EVENT SERVER, locations in TYPE("DOMAIN") array
"RTN","HLEMSND",97,0)
 ;Input:
"RTN","HLEMSND",98,0)
 ;    message at @MSG
"RTN","HLEMSND",99,0)
 ;    DOMAIN - array of remote domains, pass by reference
"RTN","HLEMSND",100,0)
 ;Output: If succssful, the function returns the mailman message number, otherwise, "" is returned
"RTN","HLEMSND",101,0)
 ;
"RTN","HLEMSND",102,0)
 N XMY,XMSUB,XMDUZ,XMTEXT,XMZ,XMDUN,DIFROM,SERVER
"RTN","HLEMSND",103,0)
 S SERVER="S.HLEM EVENT LOG SERVER"
"RTN","HLEMSND",104,0)
 S XMDUZ="HL7 EVENT LOG at "_$P($$SITE^VASITE(),"^",2)
"RTN","HLEMSND",105,0)
 S XMY(.5)=""
"RTN","HLEMSND",106,0)
 S DOMAIN=0 F  S DOMAIN=$O(DOMAIN(DOMAIN)) Q:'DOMAIN  D
"RTN","HLEMSND",107,0)
 .S XMY(SERVER_"@"_$P($G(^DIC(4.2,DOMAIN,0)),"^"))=""
"RTN","HLEMSND",108,0)
 ;
"RTN","HLEMSND",109,0)
 ;******REMOVE THIS *****
"RTN","HLEMSND",110,0)
 ;S XMY("MOORE,JIM")=""
"RTN","HLEMSND",111,0)
 ;******
"RTN","HLEMSND",112,0)
 ;
"RTN","HLEMSND",113,0)
 S XMTEXT=$P(MSG,")")_","
"RTN","HLEMSND",114,0)
 S XMSUB="HL7 EVENT LOG"
"RTN","HLEMSND",115,0)
 D ^XMD
"RTN","HLEMSND",116,0)
 Q $G(XMZ)
"RTN","HLEMSND",117,0)
 ;
"RTN","HLEMSND",118,0)
ADDDATA(MSG,LABEL,DATA) ;
"RTN","HLEMSND",119,0)
 ;Description: Adds one formated line to the message text containing the label and data value
"RTN","HLEMSND",120,0)
 ;Input:
"RTN","HLEMSND",121,0)
 ;  MSG - the workspace location
"RTN","HLEMSND",122,0)
 ;  LABEL - text label that identifies the type of data
"RTN","HLEMSND",123,0)
 ;  DATA - data value
"RTN","HLEMSND",124,0)
 ;Output:none
"RTN","HLEMSND",125,0)
 ; 
"RTN","HLEMSND",126,0)
 D ADDLINE(MSG,LABEL_":"_DATA)
"RTN","HLEMSND",127,0)
 Q
"RTN","HLEMSND",128,0)
 ;
"RTN","HLEMSND",129,0)
ADDLINE(MSG,LINE) ;
"RTN","HLEMSND",130,0)
 ;Description: adds one line to the message text
"RTN","HLEMSND",131,0)
 ;Inputs:
"RTN","HLEMSND",132,0)
 ;  LINE - the line of text to be added
"RTN","HLEMSND",133,0)
 ;  MSG - @MSG is the location for the message text
"RTN","HLEMSND",134,0)
 ;Output: none
"RTN","HLEMSND",135,0)
 S @MSG@(($O(@MSG@(9999),-1)+1))=LINE
"RTN","HLEMSND",136,0)
 Q
"RTN","HLEMSND",137,0)
 ;
"RTN","HLEMSND",138,0)
ERROR(EVENT) ;
"RTN","HLEMSND",139,0)
 ;establishes a new event if this routine encounters an error.
"RTN","HLEMSND",140,0)
 ;pass EVENT by reference
"RTN","HLEMSND",141,0)
 ;
"RTN","HLEMSND",142,0)
 N NEWEVENT,VAR
"RTN","HLEMSND",143,0)
 S NEWEVENT=$$EVENT^HLEME("SRVR ERROR","HEALTH LEVEL SEVEN")
"RTN","HLEMSND",144,0)
 S VAR("IEN")=EVENT("IEN")
"RTN","HLEMSND",145,0)
 S VAR("ID")=EVENT("ID")
"RTN","HLEMSND",146,0)
 I $$STOREVAR^HLEME(NEWEVENT,.VAR)
"RTN","HLEMSND",147,0)
 Q
"RTN","HLEMST")
0^72^B66783747
"RTN","HLEMST",1,0)
HLEMST ;ALB/CJM -ListManager Screen for displaying an Event Statistics;12 JUN 1997 10:00 am
"RTN","HLEMST",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLEMST",3,0)
 ;
"RTN","HLEMST",4,0)
EN ;Entry point to viewing a Event Statistics
"RTN","HLEMST",5,0)
 ;Input:  EVENT is the ien of an event
"RTN","HLEMST",6,0)
 ;Output:  none
"RTN","HLEMST",7,0)
 ;
"RTN","HLEMST",8,0)
 N IDX,BEGIN
"RTN","HLEMST",9,0)
 I $G(PROFILE),$D(PROFILE("SITES")),$D(PROFILE("TYPES"))
"RTN","HLEMST",10,0)
 E  N PROFILE S PROFILE=$$PROFILE^HLEMSL() Q:'PROFILE  S PROFILE=$$GET^HLEMP(PROFILE,.PROFILE)
"RTN","HLEMST",11,0)
 S BEGIN=$$ASKBEGIN()
"RTN","HLEMST",12,0)
 Q:'BEGIN
"RTN","HLEMST",13,0)
 ;
"RTN","HLEMST",14,0)
 S IDX="^TMP(""HLEM"",$J,""STATISTICS"")"
"RTN","HLEMST",15,0)
 K @IDX
"RTN","HLEMST",16,0)
 D WAIT^DICD
"RTN","HLEMST",17,0)
 D EN^VALM("HLEM DISPLAY STATISTICS")
"RTN","HLEMST",18,0)
 ;
"RTN","HLEMST",19,0)
 K @IDX
"RTN","HLEMST",20,0)
 Q
"RTN","HLEMST",21,0)
 ;
"RTN","HLEMST",22,0)
 ;
"RTN","HLEMST",23,0)
HDR ;Header code
"RTN","HLEMST",24,0)
 S VALMHDR(1)="Year   Month     Day   Hour    Event                                   Count"
"RTN","HLEMST",25,0)
 Q
"RTN","HLEMST",26,0)
 ;
"RTN","HLEMST",27,0)
INIT ;Init variables and list array
"RTN","HLEMST",28,0)
 N ARY
"RTN","HLEMST",29,0)
 S ARY="^TMP($J,""HLSTATS"")"
"RTN","HLEMST",30,0)
 S VALMSG="USER PROFILE: "_$G(PROFILE("NAME"))_"        STARTING: "_$$FMTE^XLFDT(BEGIN)
"RTN","HLEMST",31,0)
 D SETUP(BEGIN,ARY,.PROFILE)
"RTN","HLEMST",32,0)
 D DISPLAY(ARY,IDX)
"RTN","HLEMST",33,0)
 K @ARY
"RTN","HLEMST",34,0)
 D HDR
"RTN","HLEMST",35,0)
 S VALMBCK="R"
"RTN","HLEMST",36,0)
 Q
"RTN","HLEMST",37,0)
 ;
"RTN","HLEMST",38,0)
SETUP(START,ARY,PROFILE) ;
"RTN","HLEMST",39,0)
 ;sets up a work array with the required statistics
"RTN","HLEMST",40,0)
 ;START is the starting date
"RTN","HLEMST",41,0)
 ;
"RTN","HLEMST",42,0)
 N SITE,TYPE,IDX
"RTN","HLEMST",43,0)
 K @ARY
"RTN","HLEMST",44,0)
 S SITE=0
"RTN","HLEMST",45,0)
 S START("YEAR")=1700+(+$E(START,1,3)),START("MONTH")=+$E(START,4,5),START("DAY")=+$E(START,6,7),START("HOUR")=$E($P(START,".",2),1,2)
"RTN","HLEMST",46,0)
 S IDX="^HLEV(776.4,""AF"")"
"RTN","HLEMST",47,0)
 F  S SITE=$O(@IDX@(SITE)) Q:'SITE  D:$G(PROFILE("ALL SITES"))!$D(PROFILE("SITES",SITE))
"RTN","HLEMST",48,0)
 .S SITE("NAME")=$$STATION^HLEMSU(SITE)
"RTN","HLEMST",49,0)
 .Q:'$L(SITE("NAME"))
"RTN","HLEMST",50,0)
 .S $P(SITE("NAME"),"^",3)=SITE
"RTN","HLEMST",51,0)
 .S TYPE=0
"RTN","HLEMST",52,0)
 .F  S TYPE=$O(@IDX@(SITE,TYPE)) Q:'TYPE  D:PROFILE("ALL TYPES")!$D(PROFILE("TYPES",TYPE))
"RTN","HLEMST",53,0)
 ..S TYPE("NAME")=$$CODE^HLEMT(TYPE)
"RTN","HLEMST",54,0)
 ..S:(+TYPE("NAME")=TYPE("NAME")) TYPE("NAME")=$E($P($G(^HLEV(776.3,TYPE,4)),"^"),1,40)
"RTN","HLEMST",55,0)
 ..Q:'$L(TYPE("NAME"))
"RTN","HLEMST",56,0)
 ..N IDX S IDX="^HLEV(776.4,""AF"",SITE,TYPE,""RECEIVED"")"
"RTN","HLEMST",57,0)
 ..D YEAR(.SITE,.TYPE,.START)
"RTN","HLEMST",58,0)
 Q
"RTN","HLEMST",59,0)
 ;
"RTN","HLEMST",60,0)
YEAR(SITE,TYPE,START) ;
"RTN","HLEMST",61,0)
 N YEAR
"RTN","HLEMST",62,0)
 S YEAR=START("YEAR")-1
"RTN","HLEMST",63,0)
 F  S YEAR=$O(@IDX@("YEAR",YEAR)) Q:'YEAR  D:(YEAR'<START("YEAR"))
"RTN","HLEMST",64,0)
 .D:(YEAR>START("YEAR"))
"RTN","HLEMST",65,0)
 ..S @ARY@(SITE("NAME"),YEAR)=$G(@ARY@(SITE("NAME"),YEAR))+$G(@IDX@("YEAR",YEAR))
"RTN","HLEMST",66,0)
 ..S @ARY@(SITE("NAME"),YEAR,"TYPE",TYPE("NAME"))=$G(@ARY@(SITE("NAME"),YEAR,"TYPE",TYPE("NAME")))+$G(@IDX@("YEAR",YEAR))
"RTN","HLEMST",67,0)
 .D MONTH(.SITE,.TYPE,.START,YEAR)
"RTN","HLEMST",68,0)
 Q
"RTN","HLEMST",69,0)
 ;
"RTN","HLEMST",70,0)
MONTH(SITE,TYPE,START,YEAR) ;
"RTN","HLEMST",71,0)
 N MONTH
"RTN","HLEMST",72,0)
 S MONTH=START("MONTH")-1
"RTN","HLEMST",73,0)
 F  S MONTH=$O(@IDX@("YEAR",YEAR,"MONTH",MONTH)) Q:'MONTH  D:(YEAR>START("YEAR"))!(YEAR=START("YEAR")&(MONTH'<START("MONTH")))
"RTN","HLEMST",74,0)
 .D:(MONTH>START("MONTH"))!(YEAR>START("YEAR"))
"RTN","HLEMST",75,0)
 ..S @ARY@(SITE("NAME"),YEAR,MONTH)=$G(@ARY@(SITE("NAME"),YEAR,MONTH))+$G(@IDX@("YEAR",YEAR,"MONTH",MONTH))
"RTN","HLEMST",76,0)
 ..S @ARY@(SITE("NAME"),YEAR,MONTH,"TYPE",TYPE("NAME"))=$G(@ARY@(SITE("NAME"),YEAR,MONTH,"TYPE",TYPE("NAME")))+$G(@IDX@("YEAR",YEAR,"MONTH",MONTH))
"RTN","HLEMST",77,0)
 .D DAY(.SITE,.TYPE,.START,YEAR,MONTH)
"RTN","HLEMST",78,0)
 Q
"RTN","HLEMST",79,0)
 ;
"RTN","HLEMST",80,0)
DAY(SITE,TYPE,START,YEAR,MONTH) ;
"RTN","HLEMST",81,0)
 N DAY
"RTN","HLEMST",82,0)
 S DAY=0
"RTN","HLEMST",83,0)
 F  S DAY=$O(@IDX@("YEAR",YEAR,"MONTH",MONTH,"DAY",DAY)) Q:'DAY  Q:START>((YEAR-1700)_$$RJ^XLFSTR(MONTH,2,"0")_$$RJ^XLFSTR(DAY,2,"0"))  D
"RTN","HLEMST",84,0)
 .S @ARY@(SITE("NAME"),YEAR,MONTH,DAY)=$G(@ARY@(SITE("NAME"),YEAR,MONTH,DAY))+$G(@IDX@("YEAR",YEAR,"MONTH",MONTH,"DAY",DAY))
"RTN","HLEMST",85,0)
 .S @ARY@(SITE("NAME"),YEAR,MONTH,DAY,"TYPE",TYPE("NAME"))=$G(@ARY@(SITE("NAME"),YEAR,MONTH,DAY,"TYPE",TYPE("NAME")))+$G(@IDX@("YEAR",YEAR,"MONTH",MONTH,"DAY",DAY))
"RTN","HLEMST",86,0)
 .D HOUR(.SITE,.TYPE,.START,YEAR,MONTH,DAY)
"RTN","HLEMST",87,0)
 Q
"RTN","HLEMST",88,0)
 ;
"RTN","HLEMST",89,0)
HOUR(SITE,TYPE,START,YEAR,MONTH,DAY) ;
"RTN","HLEMST",90,0)
 N HOUR
"RTN","HLEMST",91,0)
 S HOUR=""
"RTN","HLEMST",92,0)
 F  S HOUR=$O(@IDX@("YEAR",YEAR,"MONTH",MONTH,"DAY",DAY,"HOUR",HOUR)) Q:(HOUR="")  D:(HOUR'<START("HOUR"))
"RTN","HLEMST",93,0)
 .S @ARY@(SITE("NAME"),YEAR,MONTH,DAY,HOUR)=$G(@ARY@(SITE("NAME"),YEAR,MONTH,DAY,HOUR))+$G(@IDX@("YEAR",YEAR,"MONTH",MONTH,"DAY",DAY,"HOUR",HOUR))
"RTN","HLEMST",94,0)
 .S @ARY@(SITE("NAME"),YEAR,MONTH,DAY,HOUR,"TYPE",TYPE("NAME"))=$G(@ARY@(SITE("NAME"),YEAR,MONTH,DAY,HOUR,"TYPE",TYPE("NAME")))+$G(@IDX@("YEAR",YEAR,"MONTH",MONTH,"DAY",DAY,"HOUR",HOUR))
"RTN","HLEMST",95,0)
 Q
"RTN","HLEMST",96,0)
 ;
"RTN","HLEMST",97,0)
DISPLAY(ARY,IDX) ;Build event statistics screen
"RTN","HLEMST",98,0)
 N YEAR,SITE
"RTN","HLEMST",99,0)
 D CLEAN^VALM10
"RTN","HLEMST",100,0)
 K @IDX,VALMHDR
"RTN","HLEMST",101,0)
 S VALMBG=1,VALMCNT=0
"RTN","HLEMST",102,0)
 ;
"RTN","HLEMST",103,0)
 S SITE=""
"RTN","HLEMST",104,0)
 I '$O(@ARY@(SITE)),$$SET^HLEMSU(1,"There are no statistics for this profile and date range!",10,"H")
"RTN","HLEMST",105,0)
 E  F  S SITE=$O(@ARY@(SITE)) Q:(SITE="")  D
"RTN","HLEMST",106,0)
 .I VALMCNT,$$SET^HLEMSU(VALMCNT,$G(@IDX@(VALMCNT,0)),1,"U")
"RTN","HLEMST",107,0)
 .S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),$$LJ^XLFSTR($P(SITE,"^"),30)_$$LJ^XLFSTR("Station #: "_$P(SITE,"^",2),50),1,"H")
"RTN","HLEMST",108,0)
 .S @IDX@("SITE",$P(SITE,"^"))=VALMCNT
"RTN","HLEMST",109,0)
 .S @IDX@("SITE",$P(SITE,"^",3))=VALMCNT
"RTN","HLEMST",110,0)
 .S YEAR=";"
"RTN","HLEMST",111,0)
 .F  S YEAR=$O(@ARY@(SITE,YEAR),-1) Q:'YEAR  D DYEAR(ARY,IDX,SITE,YEAR)
"RTN","HLEMST",112,0)
 ;Build header
"RTN","HLEMST",113,0)
 D HDR
"RTN","HLEMST",114,0)
 Q
"RTN","HLEMST",115,0)
 ;
"RTN","HLEMST",116,0)
DYEAR(ARY,IDX,SITE,YEAR) ;
"RTN","HLEMST",117,0)
 N EVENT,MONTH
"RTN","HLEMST",118,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),$$LJ^XLFSTR(YEAR,71)_$$LJ^XLFSTR($G(@ARY@(SITE,YEAR)),20),1)
"RTN","HLEMST",119,0)
 S EVENT=""
"RTN","HLEMST",120,0)
 F  S EVENT=$O(@ARY@(SITE,YEAR,"TYPE",EVENT)) Q:EVENT=""  D
"RTN","HLEMST",121,0)
 .S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),$$LJ^XLFSTR(EVENT,40)_$$LJ^XLFSTR($G(@ARY@(SITE,YEAR,"TYPE",EVENT)),20),32)
"RTN","HLEMST",122,0)
 S MONTH=";"
"RTN","HLEMST",123,0)
 F  S MONTH=$O(@ARY@(SITE,YEAR,MONTH),-1) Q:(MONTH="")  D
"RTN","HLEMST",124,0)
 .D DMONTH(ARY,IDX,SITE,YEAR,MONTH)
"RTN","HLEMST",125,0)
 Q
"RTN","HLEMST",126,0)
 ;
"RTN","HLEMST",127,0)
DMONTH(ARY,IDX,SITE,YEAR,MONTH) ;
"RTN","HLEMST",128,0)
 N EVENT,DAY
"RTN","HLEMST",129,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),$$LJ^XLFSTR($$MONTHTXT(MONTH),64)_$$LJ^XLFSTR($G(@ARY@(SITE,YEAR,MONTH)),20),8)
"RTN","HLEMST",130,0)
 S EVENT=""
"RTN","HLEMST",131,0)
 F  S EVENT=$O(@ARY@(SITE,YEAR,MONTH,"TYPE",EVENT)) Q:EVENT=""  D
"RTN","HLEMST",132,0)
 .S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),$$LJ^XLFSTR(EVENT,40)_$$LJ^XLFSTR($G(@ARY@(SITE,YEAR,MONTH,"TYPE",EVENT)),20),32)
"RTN","HLEMST",133,0)
 S DAY=";"
"RTN","HLEMST",134,0)
 F  S DAY=$O(@ARY@(SITE,YEAR,MONTH,DAY),-1) D  Q:'DAY
"RTN","HLEMST",135,0)
 .D:DAY DDAY(ARY,IDX,SITE,YEAR,MONTH,DAY)
"RTN","HLEMST",136,0)
 Q
"RTN","HLEMST",137,0)
 ;
"RTN","HLEMST",138,0)
DDAY(ARY,IDX,SITE,YEAR,MONTH,DAY) ;
"RTN","HLEMST",139,0)
 N EVENT,HOUR
"RTN","HLEMST",140,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),$$LJ^XLFSTR($$DAYTXT(DAY),54)_$$LJ^XLFSTR($G(@ARY@(SITE,YEAR,MONTH,DAY)),20),18)
"RTN","HLEMST",141,0)
 S EVENT=""
"RTN","HLEMST",142,0)
 F  S EVENT=$O(@ARY@(SITE,YEAR,MONTH,DAY,"TYPE",EVENT)) Q:EVENT=""  D
"RTN","HLEMST",143,0)
 .S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),$$LJ^XLFSTR(EVENT,40)_$$LJ^XLFSTR($G(@ARY@(SITE,YEAR,MONTH,DAY,"TYPE",EVENT)),20),32)
"RTN","HLEMST",144,0)
 S HOUR=";"
"RTN","HLEMST",145,0)
 F  S HOUR=$O(@ARY@(SITE,YEAR,MONTH,DAY,HOUR),-1) Q:'HOUR  D DHOUR(ARY,IDX,SITE,YEAR,MONTH,DAY,HOUR)
"RTN","HLEMST",146,0)
 Q
"RTN","HLEMST",147,0)
 ;
"RTN","HLEMST",148,0)
DHOUR(ARY,IDX,SITE,YEAR,MONTH,DAY,HOUR) ;
"RTN","HLEMST",149,0)
 N EVENT
"RTN","HLEMST",150,0)
 S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),$$LJ^XLFSTR($$HOURTXT(HOUR),48)_$$LJ^XLFSTR($G(@ARY@(SITE,YEAR,MONTH,DAY,HOUR)),20),24)
"RTN","HLEMST",151,0)
 S EVENT=""
"RTN","HLEMST",152,0)
 F  S EVENT=$O(@ARY@(SITE,YEAR,MONTH,DAY,HOUR,"TYPE",EVENT)) Q:EVENT=""  D
"RTN","HLEMST",153,0)
 .S VALMCNT=$$SET^HLEMSU($$INC^HLEMU(.VALMCNT),$$LJ^XLFSTR(EVENT,40)_$$LJ^XLFSTR($G(@ARY@(SITE,YEAR,MONTH,DAY,HOUR,"TYPE",EVENT)),20),32)
"RTN","HLEMST",154,0)
 Q
"RTN","HLEMST",155,0)
 ;
"RTN","HLEMST",156,0)
HELP ;Help code
"RTN","HLEMST",157,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLEMST",158,0)
 Q
"RTN","HLEMST",159,0)
 ;
"RTN","HLEMST",160,0)
EXIT ;Exit code
"RTN","HLEMST",161,0)
 D CLEAN^VALM10
"RTN","HLEMST",162,0)
 D CLEAR^VALM1
"RTN","HLEMST",163,0)
 K @IDX
"RTN","HLEMST",164,0)
 Q
"RTN","HLEMST",165,0)
 ;
"RTN","HLEMST",166,0)
EXPND ;Expand code
"RTN","HLEMST",167,0)
 Q
"RTN","HLEMST",168,0)
 ;
"RTN","HLEMST",169,0)
X(FIELD,VALUE) ;
"RTN","HLEMST",170,0)
 ;changes a field value in file 774.4 to external form
"RTN","HLEMST",171,0)
 Q $$EXTERNAL^DILFD(776.4,FIELD,"F",VALUE)
"RTN","HLEMST",172,0)
 ;
"RTN","HLEMST",173,0)
ASKBEGIN(DEFAULT) ;
"RTN","HLEMST",174,0)
 ;Description: Asks the user to enter a beginning date.
"RTN","HLEMST",175,0)
 ;Input: DEFAULT - the suggested default dt/time (optional)
"RTN","HLEMST",176,0)
 ;Output: Returns the date as the function value, or 0 if the user does n to select a date
"RTN","HLEMST",177,0)
 ;
"RTN","HLEMST",178,0)
 N DIR,X,Y
"RTN","HLEMST",179,0)
 S DIR(0)="D^::TX"
"RTN","HLEMST",180,0)
 S DIR("A")="Enter the begining date"
"RTN","HLEMST",181,0)
 S DIR("B")=$$FMTE^XLFDT($S($G(DEFAULT):DEFAULT,1:$$FMADD^XLFDT(DT,-1)))
"RTN","HLEMST",182,0)
 S DIR("?")="Please enter the earliest date for which you would like to see Event Logging Statistics."
"RTN","HLEMST",183,0)
 D ^DIR
"RTN","HLEMST",184,0)
 Q:$D(DIRUT) 0
"RTN","HLEMST",185,0)
 Q Y
"RTN","HLEMST",186,0)
 ;
"RTN","HLEMST",187,0)
MONTHTXT(M) ;
"RTN","HLEMST",188,0)
 ;Given the month as a number 1-12, returns the name
"RTN","HLEMST",189,0)
 Q $S(M=1:"January",M=2:"February",M=3:"March",M=4:"April",M=5:"May",M=6:"June",M=7:"July",M=8:"August",M=9:"September",M=10:"October",M=11:"November",M=12:"December",1:"Unknown")
"RTN","HLEMST",190,0)
 ;
"RTN","HLEMST",191,0)
DAYTXT(D) ;
"RTN","HLEMST",192,0)
 ;Given the day as a number, returns the day also as a number, but with
"RTN","HLEMST",193,0)
 ;a suffix of either "st","nd","rd","th"
"RTN","HLEMST",194,0)
 I D>9,D<20 Q D_"th"
"RTN","HLEMST",195,0)
 N DIGIT
"RTN","HLEMST",196,0)
 S DIGIT=$E(D,$L(D))
"RTN","HLEMST",197,0)
 Q D_$S(DIGIT=1:"st",DIGIT=2:"nd",DIGIT=3:"rd",1:"th")
"RTN","HLEMST",198,0)
 ;
"RTN","HLEMST",199,0)
HOURTXT(H) ;
"RTN","HLEMST",200,0)
 I H<12 Q H_"am"
"RTN","HLEMST",201,0)
 I H=12 Q "12N"
"RTN","HLEMST",202,0)
 I H>12 Q (H-12)_"pm"
"RTN","HLEMST",203,0)
 Q
"RTN","HLEMST",204,0)
 ;
"RTN","HLEMST",205,0)
SELECT ;Allows the user to change profiles, then rebuilds the Event Log Statistics screen
"RTN","HLEMST",206,0)
 N PROF,ASKBEGIN
"RTN","HLEMST",207,0)
 D FULL^VALM1
"RTN","HLEMST",208,0)
 S PROF=$$SELECT^HLEMP1($G(DUZ),20)
"RTN","HLEMST",209,0)
 I PROF,PROF'=$G(PROFILE) D
"RTN","HLEMST",210,0)
 .S ASKBEGIN=$$ASKBEGIN($G(BEGIN))
"RTN","HLEMST",211,0)
 .S:ASKBEGIN BEGIN=ASKBEGIN
"RTN","HLEMST",212,0)
 .S PROFILE=$$GET^HLEMP(PROF,.PROFILE)
"RTN","HLEMST",213,0)
 .D INIT^HLEMST
"RTN","HLEMST",214,0)
 S VALMBCK="R"
"RTN","HLEMST",215,0)
 Q
"RTN","HLEMST",216,0)
 ;
"RTN","HLEMST",217,0)
CHNGDATE ;Allows the user to change the starting date, then rebuilds the Event Log Statistics screen
"RTN","HLEMST",218,0)
 N ASKBEGIN
"RTN","HLEMST",219,0)
 S ASKBEGIN=$$ASKBEGIN($G(BEGIN))
"RTN","HLEMST",220,0)
 I ASKBEGIN D
"RTN","HLEMST",221,0)
 .S BEGIN=ASKBEGIN
"RTN","HLEMST",222,0)
 .D INIT^HLEMST
"RTN","HLEMST",223,0)
 S VALMBCK="R"
"RTN","HLEMST",224,0)
 Q
"RTN","HLEMSU")
0^73^B1416722
"RTN","HLEMSU",1,0)
HLEMSU ;ALB/CJM,ALB/BRM - Utilities for building ListManager screens; 2/27/01 1:25pm
"RTN","HLEMSU",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLEMSU",3,0)
 ;
"RTN","HLEMSU",4,0)
 ;
"RTN","HLEMSU",5,0)
SET(LINE,TEXT,COL,CNTRL) ; -- set display array
"RTN","HLEMSU",6,0)
 ; Input:
"RTN","HLEMSU",7,0)
 ;  LINE - line# to put the TEXT
"RTN","HLEMSU",8,0)
 ;  TEXT - **optional** text to put in the array
"RTN","HLEMSU",9,0)
 ;  COL - **optional** column # to put the TEXT
"RTN","HLEMSU",10,0)
 ;  CNTRL - **optional** video display chracteristic - "H"= high, "B"-blinking
"RTN","HLEMSU",11,0)
 ; Output:
"RTN","HLEMSU",12,0)
 ;  function returns the number of lines in the list
"RTN","HLEMSU",13,0)
 N X,ON,OFF
"RTN","HLEMSU",14,0)
 S:LINE>VALMCNT VALMCNT=LINE
"RTN","HLEMSU",15,0)
 S:'$L(TEXT) TEXT=" "
"RTN","HLEMSU",16,0)
 S X=$G(@IDX@(VALMCNT,0))
"RTN","HLEMSU",17,0)
 S @IDX@(VALMCNT,0)=$$SETSTR^VALM1(TEXT,X,COL,$L(TEXT))
"RTN","HLEMSU",18,0)
 I $G(CNTRL)["R" S ON=IORVON,OFF=IORVOFF
"RTN","HLEMSU",19,0)
 I $G(CNTRL)["B" S ON=$G(ON)_IOBON,OFF=$G(OFF)_IOBOFF
"RTN","HLEMSU",20,0)
 I $G(CNTRL)["H" S ON=$G(ON)_IOINHI,OFF=$G(IOINORM)
"RTN","HLEMSU",21,0)
 I $G(CNTRL)["U" S ON=$G(ON)_IOUON,OFF=$G(IOUOFF)
"RTN","HLEMSU",22,0)
 D:$L($G(ON)) CNTRL^VALM10(LINE,COL,$L(TEXT),ON,OFF)
"RTN","HLEMSU",23,0)
 Q VALMCNT
"RTN","HLEMSU",24,0)
 ;
"RTN","HLEMSU",25,0)
STATION(IEN) ;
"RTN","HLEMSU",26,0)
 ;Description:  Given an ien to the Institution file, returns as the function value the <facility name>^<station number>
"RTN","HLEMSU",27,0)
 ;
"RTN","HLEMSU",28,0)
 N RETURN
"RTN","HLEMSU",29,0)
 Q:'$G(IEN) ""
"RTN","HLEMSU",30,0)
 Q:'$D(^DIC(4,IEN,0)) ""
"RTN","HLEMSU",31,0)
 Q $P($$NNT^XUAF4(IEN),"^",1,2)
"RTN","HLEMSU",32,0)
 ;
"RTN","HLEMSU",33,0)
CENTER(STRING) ;
"RTN","HLEMSU",34,0)
 Q $$CJ^XLFSTR(STRING,80)
"RTN","HLEMT")
0^37^B4330888
"RTN","HLEMT",1,0)
HLEMT ;ALB/CJM-HL7 - APIs for Monitor Event Types ;02/04/2004
"RTN","HLEMT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEMT",3,0)
 ;
"RTN","HLEMT",4,0)
FIND(CODE,PACKAGE) ;
"RTN","HLEMT",5,0)
 ;Description: Finds an event type.
"RTN","HLEMT",6,0)
 ;Input:
"RTN","HLEMT",7,0)
 ;  CODE - the string value of the code
"RTN","HLEMT",8,0)
 ;  PACKAGE - the name (.01 field) of a package in the Package file representing the application that dessigned/created the code.
"RTN","HLEMT",9,0)
 ;Output:
"RTN","HLEMT",10,0)
 ;   Function returns 0 on failue, ien of event type if successful
"RTN","HLEMT",11,0)
 ;
"RTN","HLEMT",12,0)
 Q:('$L($G(CODE))) 0
"RTN","HLEMT",13,0)
 Q:'$L($G(PACKAGE)) 0
"RTN","HLEMT",14,0)
 Q $O(^HLEV(776.3,"C",CODE,PACKAGE,0))
"RTN","HLEMT",15,0)
 ;
"RTN","HLEMT",16,0)
GET(IEN,ETYPE) ;
"RTN","HLEMT",17,0)
 ;Description - given the ien, it returns an array containing the event type
"RTN","HLEMT",18,0)
 ;Input:
"RTN","HLEMT",19,0)
 ;  IEN - ien of event type
"RTN","HLEMT",20,0)
 ;  ETYPE - pass by reference, the return array
"RTN","HLEMT",21,0)
 ;Output:
"RTN","HLEMT",22,0)
 ;  function returns 0 on failure, 1 on success
"RTN","HLEMT",23,0)
 ;  ETYPE(
"RTN","HLEMT",24,0)
 ;   "ACTION" - <tag>^<routine> - the routine that should be executed when events of this type occur
"RTN","HLEMT",25,0)
 ;   "BRIEF" - brief description
"RTN","HLEMT",26,0)
 ;   "CODE" - the event type code
"RTN","HLEMT",27,0)
 ;   "CATEGORY" - category of event type, set of codes
"RTN","HLEMT",28,0)
 ;   "CONGLOMERATE" - 1=events of this type are conglomerated, 0 is no
"RTN","HLEMT",29,0)
 ;   "CONGLOMERATE","HOURS" - #of hours to conglomerate
"RTN","HLEMT",30,0)
 ;   "DAYS" - # of days to keep events of this type before purge
"RTN","HLEMT",31,0)
 ;   "IEN" -the ien
"RTN","HLEMT",32,0)
 ;   "PACKAGE" - ien of the package that assigned the code
"RTN","HLEMT",33,0)
 ;   "REVIEW" - 0=not required, 1=required, 2=only if action fails
"RTN","HLEMT",34,0)
 ;   "SITES",<IEN of DOMAIN>=<screen if defined> - list of domains to send server messages
"RTN","HLEMT",35,0)
 ;   "URGENT" - 0=NO,1=YES,2=IF ACTIONFAILS
"RTN","HLEMT",36,0)
 ;
"RTN","HLEMT",37,0)
 Q:'$G(IEN) 0
"RTN","HLEMT",38,0)
 N NODE,I,DOMAIN
"RTN","HLEMT",39,0)
 K ETYPE
"RTN","HLEMT",40,0)
 S ETYPE("IEN")=IEN
"RTN","HLEMT",41,0)
 S NODE=$G(^HLEV(776.3,IEN,0))
"RTN","HLEMT",42,0)
 Q:'$L(NODE) 0
"RTN","HLEMT",43,0)
 S ETYPE("CODE")=$P(NODE,"^")
"RTN","HLEMT",44,0)
 S ETYPE("PACKAGE")=$P(NODE,"^",2)
"RTN","HLEMT",45,0)
 S ETYPE("CATEGORY")=$P(NODE,"^",3)
"RTN","HLEMT",46,0)
 S ETYPE("URGENT")=$P(NODE,"^",4)
"RTN","HLEMT",47,0)
 S ETYPE("CONGLOMERATE")=$P(NODE,"^",5)
"RTN","HLEMT",48,0)
 S ETYPE("CONGLOMERATE","HOURS")=$P(NODE,"^",6)
"RTN","HLEMT",49,0)
 S ETYPE("REVIEW")=$P(NODE,"^",7)
"RTN","HLEMT",50,0)
 S ETYPE("DAYS")=$P(NODE,"^",9)
"RTN","HLEMT",51,0)
 S ETYPE("ACTIVE")=$P(NODE,"^",10)
"RTN","HLEMT",52,0)
 S ETYPE("ACTION")=$E($G(^HLEV(776.3,IEN,1)),1,20)
"RTN","HLEMT",53,0)
 S I=0 F  S I=$O(^HLEV(776.3,IEN,2,I)) Q:'I  S DOMAIN=+$G(^HLEV(776.3,IEN,2,I,0)) S:DOMAIN ETYPE("DOMAIN",DOMAIN)=$G(^HLEV(776.3,IEN,2,I,1))
"RTN","HLEMT",54,0)
 S ETYPE("BRIEF")=$P($G(^HLEV(776.3,IEN,4)),"^")
"RTN","HLEMT",55,0)
 Q 1
"RTN","HLEMT",56,0)
 ;
"RTN","HLEMT",57,0)
CODE(EVENT) ;
"RTN","HLEMT",58,0)
 ;Given the event type ien, returns the code
"RTN","HLEMT",59,0)
 Q:'$G(EVENT) ""
"RTN","HLEMT",60,0)
 Q $P($G(^HLEV(776.3,EVENT,0)),"^")
"RTN","HLEMT",61,0)
BRIEF(EVENT) ;
"RTN","HLEMT",62,0)
 ;Given the event type ien, returns the brief desciption
"RTN","HLEMT",63,0)
 Q:'$G(EVENT) ""
"RTN","HLEMT",64,0)
 Q $P($G(^HLEV(776.3,EVENT,4)),"^")
"RTN","HLEMT",65,0)
 ;
"RTN","HLEMT",66,0)
CONG(TYPE) ;
"RTN","HLEMT",67,0)
 ;Input:
"RTN","HLEMT",68,0)
 ;  TYPE - ien of event type
"RTN","HLEMT",69,0)
 ;Output:
"RTN","HLEMT",70,0)
 ;  function returns 0 if this is NOT a conglomerated event, 1 if it is
"RTN","HLEMT",71,0)
 ;
"RTN","HLEMT",72,0)
 Q $P($G(^HLEV(776.3,TYPE,0)),"^",5)
"RTN","HLEMT",73,0)
HOURS(TYPE) ;
"RTN","HLEMT",74,0)
 ;Description - returns #of hours overwhich to congregate events of this type
"RTN","HLEMT",75,0)
 ;Input:
"RTN","HLEMT",76,0)
 ;  TYPE - ien of event type
"RTN","HLEMT",77,0)
 ;Output:
"RTN","HLEMT",78,0)
 ;  function returns # of hours, 0 if not to be conglomerated
"RTN","HLEMT",79,0)
 ;
"RTN","HLEMT",80,0)
 Q:'$$CONG(TYPE) 0
"RTN","HLEMT",81,0)
 Q $P($G(^HLEV(776.3,TYPE,0)),"^",6)
"RTN","HLEMU")
0^38^B40415242
"RTN","HLEMU",1,0)
HLEMU ;ALB/CJM  Utility Routines ;02/04/2004 14:42
"RTN","HLEMU",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEMU",3,0)
 ;
"RTN","HLEMU",4,0)
STATNUM(IEN) ;
"RTN","HLEMU",5,0)
 ;Description:  Given an ien to the Institution file, returns as the function value the station number.  If IEN is NOT passed in, it assumes the local site.  Returns "" on failure.
"RTN","HLEMU",6,0)
 ;
"RTN","HLEMU",7,0)
 N STATION,RETURN
"RTN","HLEMU",8,0)
 S RETURN=""
"RTN","HLEMU",9,0)
 I $G(IEN) D
"RTN","HLEMU",10,0)
 .Q:'$D(^DIC(4,IEN,0))
"RTN","HLEMU",11,0)
 .S STATION=$P($$NNT^XUAF4(IEN),"^",2)
"RTN","HLEMU",12,0)
 .S RETURN=$S(+STATION:STATION,1:"")
"RTN","HLEMU",13,0)
 E  D
"RTN","HLEMU",14,0)
 .S RETURN=$P($$SITE^VASITE(),"^",3)
"RTN","HLEMU",15,0)
 Q RETURN
"RTN","HLEMU",16,0)
INSTIEN(STATION) ;
"RTN","HLEMU",17,0)
 ;Given the station number, this returns a pointer to the Institution file
"RTN","HLEMU",18,0)
 Q $$LKUP^XUAF4(STATION)
"RTN","HLEMU",19,0)
 ;
"RTN","HLEMU",20,0)
UPD(FILE,HLDA,DATA,ERROR) ;File data into an existing record.
"RTN","HLEMU",21,0)
 ; Input:
"RTN","HLEMU",22,0)
 ;   FILE - File or sub-file number
"RTN","HLEMU",23,0)
 ;   HLDA - New name for traditional DA array, with same meaning.
"RTN","HLEMU",24,0)
 ;            Pass by reference.
"RTN","HLEMU",25,0)
 ;   DATA - Data array to file (pass by reference)
"RTN","HLEMU",26,0)
 ;          Format: DATA(<field #>)=<value>
"RTN","HLEMU",27,0)
 ;
"RTN","HLEMU",28,0)
 ; Output:
"RTN","HLEMU",29,0)
 ;  Function Value -     0=error and 1=no error
"RTN","HLEMU",30,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","HLEMU",31,0)
 ;
"RTN","HLEMU",32,0)
 ; Example: To update a record in subfile 2.0361 in record with ien=353,
"RTN","HLEMU",33,0)
 ;          subrecord ien=68, with the field .01 value = 21:
"RTN","HLEMU",34,0)
 ;    S DATA(.01)=21,HLDA=68,HLDA(1)=353 I $$UPD^HLEMU(2.0361,.HLDA,.DATA,.ERROR) W !,"DONE"
"RTN","HLEMU",35,0)
 ;
"RTN","HLEMU",36,0)
 N FDA,FIELD,IENS,ERRORS
"RTN","HLEMU",37,0)
 ;
"RTN","HLEMU",38,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","HLEMU",39,0)
 ;FDA - the FDA array as defined by FM
"RTN","HLEMU",40,0)
 ;
"RTN","HLEMU",41,0)
 I '$G(HLDA) S ERROR="IEN OF RECORD TO BE UPDATED NOT SPECIFIED" Q 0
"RTN","HLEMU",42,0)
 S IENS=$$IENS^DILF(.HLDA)
"RTN","HLEMU",43,0)
 S FIELD=0
"RTN","HLEMU",44,0)
 F  S FIELD=$O(DATA(FIELD)) Q:'FIELD  D
"RTN","HLEMU",45,0)
 .S FDA(FILE,IENS,FIELD)=$G(DATA(FIELD))
"RTN","HLEMU",46,0)
 D FILE^HLDIE(,"FDA","ERRORS(1)","UPD","HLEMU")
"RTN","HLEMU",47,0)
 I +$G(DIERR) D
"RTN","HLEMU",48,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","HLEMU",49,0)
 E  D
"RTN","HLEMU",50,0)
 .S ERROR=""
"RTN","HLEMU",51,0)
 ;
"RTN","HLEMU",52,0)
 I $S(+$G(DIERR):0,1:1) D CLEAN^DILF Q 1
"RTN","HLEMU",53,0)
 E  D CLEAN^DILF Q 0
"RTN","HLEMU",54,0)
 ;
"RTN","HLEMU",55,0)
GETFIELD(FILE,FIELD,HLDA,ERROR,EXT) ;Get field value from an existing record.
"RTN","HLEMU",56,0)
 ; Input:
"RTN","HLEMU",57,0)
 ;   FILE - File or sub-file number
"RTN","HLEMU",58,0)
 ;   HLDA - New name for traditional DA array, with same meaning.
"RTN","HLEMU",59,0)
 ;            Pass by reference.
"RTN","HLEMU",60,0)
 ;   FIELD - Field for which value is needed
"RTN","HLEMU",61,0)
 ;   EXT - (optional) If $G(EXT) then returns the external display form of the value
"RTN","HLEMU",62,0)
 ; Output:
"RTN","HLEMU",63,0)
 ;  Function Value -  field value in internal format,"" if an error was encountered
"RTN","HLEMU",64,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","HLEMU",65,0)
 ;
"RTN","HLEMU",66,0)
 N FDA,IENS,ERRORS,VALUE
"RTN","HLEMU",67,0)
 ;
"RTN","HLEMU",68,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","HLEMU",69,0)
 ;FDA - the FDA array as defined by FM
"RTN","HLEMU",70,0)
 ;
"RTN","HLEMU",71,0)
 I '$G(HLDA) S ERROR="IEN OF RECORD TO BE UPDATED NOT SPECIFIED" Q ""
"RTN","HLEMU",72,0)
 S IENS=$$IENS^DILF(.HLDA)
"RTN","HLEMU",73,0)
 S VALUE=$$GET1^DIQ(FILE,IENS,FIELD,$S($G(EXT):"",1:"I"),,"ERRORS(1)")
"RTN","HLEMU",74,0)
 I +$G(DIERR) D
"RTN","HLEMU",75,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","HLEMU",76,0)
 E  D
"RTN","HLEMU",77,0)
 .S ERROR=""
"RTN","HLEMU",78,0)
 ;
"RTN","HLEMU",79,0)
 I $S(+$G(DIERR):0,1:1) D CLEAN^DILF Q VALUE
"RTN","HLEMU",80,0)
 E  D CLEAN^DILF Q ""
"RTN","HLEMU",81,0)
 ;
"RTN","HLEMU",82,0)
DELETE(FILE,DA,ERROR) ;Delete an existing record.
"RTN","HLEMU",83,0)
 ; Input:
"RTN","HLEMU",84,0)
 ;   FILE - File or sub-file number
"RTN","HLEMU",85,0)
 ;   DA - Traditional DA array, with same meaning.
"RTN","HLEMU",86,0)
 ;           ** Pass by reference**
"RTN","HLEMU",87,0)
 ;
"RTN","HLEMU",88,0)
 ; Output:
"RTN","HLEMU",89,0)
 ;  Function Value -     0=error and 1=no error
"RTN","HLEMU",90,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","HLEMU",91,0)
 ;
"RTN","HLEMU",92,0)
 ; Example: To delete a record in subfile 2.0361 in record with ien=353,
"RTN","HLEMU",93,0)
 ;          subrecord ien=68:
"RTN","HLEMU",94,0)
 ;    S DA=68,DA(1)=353 I $$DELETE^HLEMU(2.0361,.DA,.ERROR) W !,"DONE"
"RTN","HLEMU",95,0)
 ;
"RTN","HLEMU",96,0)
 N DATA
"RTN","HLEMU",97,0)
 S DATA(.01)="@"
"RTN","HLEMU",98,0)
 Q $$UPD^HLEMU(FILE,.DA,.DATA,.ERROR)
"RTN","HLEMU",99,0)
 Q
"RTN","HLEMU",100,0)
 ;
"RTN","HLEMU",101,0)
ADD(FILE,HLDA,DATA,ERROR,IEN) ;
"RTN","HLEMU",102,0)
 ;Description: Creates a new record and files the data.
"RTN","HLEMU",103,0)
 ; Input:
"RTN","HLEMU",104,0)
 ;   FILE - File or sub-file number
"RTN","HLEMU",105,0)
 ;   HLDA - New name for traditional FileMan DA array with same
"RTN","HLEMU",106,0)
 ;            meaning. Pass by reference.  Only needed if adding to a
"RTN","HLEMU",107,0)
 ;            subfile.
"RTN","HLEMU",108,0)
 ;   DATA - Data array to file, pass by reference
"RTN","HLEMU",109,0)
 ;          Format: DATA(<field #>)=<value>
"RTN","HLEMU",110,0)
 ;   IEN - internal entry number to use (optional)
"RTN","HLEMU",111,0)
 ;
"RTN","HLEMU",112,0)
 ; Output:
"RTN","HLEMU",113,0)
 ;   Function Value - If no error then it returns the ien of the created record, else returns NULL.
"RTN","HLEMU",114,0)
 ;  HLDA - returns the ien of the new record, NULL if none created.  If needed, pass by reference.
"RTN","HLEMU",115,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","HLEMU",116,0)
 ;
"RTN","HLEMU",117,0)
 ; Example: Adding a record in subfile 2.0361 in the record with ien=353
"RTN","HLEMU",118,0)
 ;          with the field .01 value = 21:
"RTN","HLEMU",119,0)
 ;  S DATA(.01)=21,HLDA(1)=353 I $$ADD^HLEMU(2.0361,.HLDA,.DATA) W !,"DONE"
"RTN","HLEMU",120,0)
 ;
"RTN","HLEMU",121,0)
 ; Example: Creating a record NOT in a subfile:
"RTN","HLEMU",122,0)
 ;          S DATA(.01)=21 I $$ADD^HLEMU(867,,.DATA) W !,"DONE"
"RTN","HLEMU",123,0)
 ;
"RTN","HLEMU",124,0)
 N FDA,FIELD,IENA,IENS,ERRORS
"RTN","HLEMU",125,0)
 ;
"RTN","HLEMU",126,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","HLEMU",127,0)
 ;IENA - the Internal Entry Numebr Array defined by FM
"RTN","HLEMU",128,0)
 ;FDA - the FDA array defined by FM
"RTN","HLEMU",129,0)
 ;IEN - the ien of the new record
"RTN","HLEMU",130,0)
 ;
"RTN","HLEMU",131,0)
 S HLDA="+1"
"RTN","HLEMU",132,0)
 S IENS=$$IENS^DILF(.HLDA)
"RTN","HLEMU",133,0)
 S FIELD=0
"RTN","HLEMU",134,0)
 F  S FIELD=$O(DATA(FIELD)) Q:'FIELD  D
"RTN","HLEMU",135,0)
 .S FDA(FILE,IENS,FIELD)=$G(DATA(FIELD))
"RTN","HLEMU",136,0)
 I $G(IEN) S IENA(1)=IEN
"RTN","HLEMU",137,0)
 D UPDATE^DIE("","FDA","IENA","ERRORS(1)")
"RTN","HLEMU",138,0)
 I +$G(DIERR) D
"RTN","HLEMU",139,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","HLEMU",140,0)
 .S IEN=""
"RTN","HLEMU",141,0)
 E  D
"RTN","HLEMU",142,0)
 .S IEN=IENA(1)
"RTN","HLEMU",143,0)
 .S ERROR=""
"RTN","HLEMU",144,0)
 D CLEAN^DILF
"RTN","HLEMU",145,0)
 S HLDA=IEN
"RTN","HLEMU",146,0)
 Q IEN
"RTN","HLEMU",147,0)
 ;
"RTN","HLEMU",148,0)
TESTVAL(FILE,FIELD,VALUE) ;
"RTN","HLEMU",149,0)
 ;Description: returns 1 if VALUE is a valid value for FIELD in FILE
"RTN","HLEMU",150,0)
 ;
"RTN","HLEMU",151,0)
 Q:(('$G(FILE))!('$G(FIELD))) 0
"RTN","HLEMU",152,0)
 ;
"RTN","HLEMU",153,0)
 N DISPLAY,VALID,RESULT
"RTN","HLEMU",154,0)
 S VALID=1
"RTN","HLEMU",155,0)
 ;
"RTN","HLEMU",156,0)
 ;if there is no external value then it is not valid
"RTN","HLEMU",157,0)
 S DISPLAY=$$EXTERNAL^DILFD(FILE,FIELD,"F",VALUE)
"RTN","HLEMU",158,0)
 I (DISPLAY="") S VALID=0
"RTN","HLEMU",159,0)
 ; 
"RTN","HLEMU",160,0)
 I VALID,$$GET1^DID(FILE,FIELD,"","TYPE")'["POINTER" D
"RTN","HLEMU",161,0)
 .D CHK^DIE(FILE,FIELD,,VALUE,.RESULT) I RESULT="^" S VALID=0 Q
"RTN","HLEMU",162,0)
 Q VALID
"RTN","HLEMU",163,0)
 ;
"RTN","HLEMU",164,0)
GETLINK(INSTIEN) ;
"RTN","HLEMU",165,0)
 ;Description:  Returns name of logical link for institition, given the institution ien.  Returns "" if a logical link name not found.
"RTN","HLEMU",166,0)
 ;
"RTN","HLEMU",167,0)
 Q:'$G(INSTIEN) ""
"RTN","HLEMU",168,0)
 ;
"RTN","HLEMU",169,0)
 N LINK,I,LINKNAME
"RTN","HLEMU",170,0)
 S LINKNAME=""
"RTN","HLEMU",171,0)
 D
"RTN","HLEMU",172,0)
 .D LINK^HLUTIL3(INSTIEN,.LINK)
"RTN","HLEMU",173,0)
 .S I=$O(LINK(0))
"RTN","HLEMU",174,0)
 .I I,$L(LINK(I)) S LINKNAME=LINK(I)
"RTN","HLEMU",175,0)
 Q LINKNAME
"RTN","HLEMU",176,0)
 ;
"RTN","HLEMU",177,0)
ASKYESNO(PROMPT,DEFAULT) ;
"RTN","HLEMU",178,0)
 ;Description: Displays PROMPT, appending '?'.  Expects a YES NO response.
"RTN","HLEMU",179,0)
 ;Input:
"RTN","HLEMU",180,0)
 ;   PROMPT - text to display as prompt.  Appends '?'
"RTN","HLEMU",181,0)
 ;   DEFAULT - (optional) YES or NO.  If not passed, defaults to YES
"RTN","HLEMU",182,0)
 ;Output:
"RTN","HLEMU",183,0)
 ;  Function value: 1 if yes, 0 if no, "" if '^' entered or timeout
"RTN","HLEMU",184,0)
 ;
"RTN","HLEMU",185,0)
 N DIR,Y
"RTN","HLEMU",186,0)
 S DIR(0)="Y"
"RTN","HLEMU",187,0)
 S DIR("A")=PROMPT
"RTN","HLEMU",188,0)
 S DIR("B")=$S($G(DEFAULT)="NO":"NO",1:"YES")
"RTN","HLEMU",189,0)
 D ^DIR
"RTN","HLEMU",190,0)
 Q:$D(DIRUT) ""
"RTN","HLEMU",191,0)
 Q Y
"RTN","HLEMU",192,0)
 ;
"RTN","HLEMU",193,0)
MSGIEN(MSGID) ;
"RTN","HLEMU",194,0)
 ;Given the message id, returns the ien from file 773, or 0 on failure.
"RTN","HLEMU",195,0)
 Q:'$L($G(MSGID)) 0
"RTN","HLEMU",196,0)
 Q $O(^HLMA("C",MSGID,0))
"RTN","HLEMU",197,0)
 ;
"RTN","HLEMU",198,0)
LINK(MSGIEN) ;
"RTN","HLEMU",199,0)
 ;Given the message ien from file 773, returns the HL Logical Link in the format <link ien>^<link name>
"RTN","HLEMU",200,0)
 Q:'$G(MSGIEN) ""
"RTN","HLEMU",201,0)
 N LINKIEN
"RTN","HLEMU",202,0)
 S LINKIEN=$P($G(^HLMA(MSGIEN,0)),"^",7)
"RTN","HLEMU",203,0)
 Q:'LINKIEN 0
"RTN","HLEMU",204,0)
 Q LINKIEN_"^"_$P(^HLCS(870,LINKIEN,0),"^")
"RTN","HLEMU",205,0)
 ;
"RTN","HLEMU",206,0)
HL7EVENT(MSGIEN) ;
"RTN","HLEMU",207,0)
 ;Given the message ien from file 773, returns the 3 character HL7 event type
"RTN","HLEMU",208,0)
 Q:'$G(MSGIEN) ""
"RTN","HLEMU",209,0)
 N EVENT
"RTN","HLEMU",210,0)
 S EVENT=$P($G(^HLMA(MSGIEN,0)),"^",14)
"RTN","HLEMU",211,0)
 Q:'EVENT ""
"RTN","HLEMU",212,0)
 Q $P(^HL(779.001,EVENT,0),"^")
"RTN","HLEMU",213,0)
 ;
"RTN","HLEMU",214,0)
MSGTYPE(MSGIEN) ;
"RTN","HLEMU",215,0)
 ;Given the message ien from file 773, returns the 3 character HL7 message type
"RTN","HLEMU",216,0)
 Q:'$G(MSGIEN) ""
"RTN","HLEMU",217,0)
 N MSG
"RTN","HLEMU",218,0)
 S MSG=$P($G(^HLMA(MSGIEN,0)),"^",13)
"RTN","HLEMU",219,0)
 Q:'MSG ""
"RTN","HLEMU",220,0)
 Q $P(^HL(771.2,MSG,0),"^")
"RTN","HLEMU",221,0)
 ;
"RTN","HLEMU",222,0)
APP(MSGIEN) ;
"RTN","HLEMU",223,0)
 ;Given the message ien from file 773, returns the name of the sending application from file 771
"RTN","HLEMU",224,0)
 ;
"RTN","HLEMU",225,0)
 Q:'$G(MSGIEN)
"RTN","HLEMU",226,0)
 N APPIEN
"RTN","HLEMU",227,0)
 S APPIEN=$P($G(^HLMA(MSGIEN,0)),"^",11)
"RTN","HLEMU",228,0)
 Q $$APPNAME(APPIEN)
"RTN","HLEMU",229,0)
 ;
"RTN","HLEMU",230,0)
APPNAME(APPIEN) ;
"RTN","HLEMU",231,0)
 ;Given an ien to the HL7 Application Parameter file (#771), it returns the NAME (field .01)
"RTN","HLEMU",232,0)
 Q $S('APPIEN:"",1:$P($G(^HL(771,APPIEN,0)),"^"))
"RTN","HLEMU",233,0)
 ;
"RTN","HLEMU",234,0)
PROMPT(FILE,FIELD,DEFAULT,RESPONSE,REQUIRE) ;
"RTN","HLEMU",235,0)
 ;Description: requests user to enter a single field value.
"RTN","HLEMU",236,0)
 ;Input:
"RTN","HLEMU",237,0)
 ;  FILE - the file #
"RTN","HLEMU",238,0)
 ;  FIELD - the field #
"RTN","HLEMU",239,0)
 ;  DEFAULT - default value, internal form
"RTN","HLEMU",240,0)
 ;  REQUIRE - a flag, (+value)'=0 means to require a value to be
"RTN","HLEMU",241,0)
 ;            entered and to return failure otherwise (optional)
"RTN","HLEMU",242,0)
 ;Output:
"RTN","HLEMU",243,0)
 ;  Function Value - 0 on failure, 1 on success
"RTN","HLEMU",244,0)
 ;  RESPONSE - value entered by user, pass by reference
"RTN","HLEMU",245,0)
 ;
"RTN","HLEMU",246,0)
 Q:(('$G(FILE))!('$G(FIELD))) 0
"RTN","HLEMU",247,0)
 S REQUIRE=$G(REQUIRE)
"RTN","HLEMU",248,0)
 N DIR,DA,QUIT,AGAIN
"RTN","HLEMU",249,0)
 ;
"RTN","HLEMU",250,0)
 S DIR(0)=FILE_","_FIELD_$S($G(REQUIRE):"",1:"O")_"AO"
"RTN","HLEMU",251,0)
 S:$G(DEFAULT)'="" DIR("A")=$$GET1^DID(FILE,FIELD,"","LABEL")_": "_$$EXTERNAL^DILFD(FILE,FIELD,"F",DEFAULT)_"// "
"RTN","HLEMU",252,0)
 S QUIT=0
"RTN","HLEMU",253,0)
 F  D  Q:QUIT
"RTN","HLEMU",254,0)
 . D ^DIR
"RTN","HLEMU",255,0)
 . I $D(DTOUT)!$D(DUOUT) S QUIT=1 Q
"RTN","HLEMU",256,0)
 . I X="@" D  Q:AGAIN
"RTN","HLEMU",257,0)
 . . S AGAIN=0
"RTN","HLEMU",258,0)
 . . I 'REQUIRE,"Yy"'[$E($$ASKYESNO("  Are you sure")_"X") S AGAIN=1 Q
"RTN","HLEMU",259,0)
 . . S RESPONSE="" ; This might trigger the "required" message below.
"RTN","HLEMU",260,0)
 . E  I X="" S RESPONSE=$G(DEFAULT)
"RTN","HLEMU",261,0)
 . E  S RESPONSE=$P(Y,"^")
"RTN","HLEMU",262,0)
 . ;
"RTN","HLEMU",263,0)
 . ; quit this loop if the user entered value OR value not required
"RTN","HLEMU",264,0)
 . I RESPONSE'="" S QUIT=1 Q
"RTN","HLEMU",265,0)
 . I 'REQUIRE S QUIT=1 Q
"RTN","HLEMU",266,0)
 . W !,"This is a required response. Enter '^' to exit"
"RTN","HLEMU",267,0)
 I $D(DTOUT)!$D(DUOUT) Q 0
"RTN","HLEMU",268,0)
 Q 1
"RTN","HLEMU",269,0)
I(VAR,N) ;This funtion increments the local or global variable by the amount N
"RTN","HLEMU",270,0)
 ;Input:
"RTN","HLEMU",271,0)
 ;  VAR - a string representing the name of a local or global variable to be referenced by indirection
"RTN","HLEMU",272,0)
 ;  N - a number to increment @VAR by.  If not passed it is set to 1
"RTN","HLEMU",273,0)
 ;OUTPUT
"RTN","HLEMU",274,0)
 ;    @VAR is incremented by the amount N and also returned as the function value
"RTN","HLEMU",275,0)
 ;
"RTN","HLEMU",276,0)
 N X
"RTN","HLEMU",277,0)
 I VAR["^" L +VAR:1
"RTN","HLEMU",278,0)
 I '$G(N) S N=1
"RTN","HLEMU",279,0)
 S X=$G(@VAR)+N
"RTN","HLEMU",280,0)
 S @VAR=X
"RTN","HLEMU",281,0)
 I VAR["^" L -VAR
"RTN","HLEMU",282,0)
 Q X
"RTN","HLEMU",283,0)
 ;
"RTN","HLEMU",284,0)
INC(VAR,N) ;This funtion increments the local variable by the amount N
"RTN","HLEMU",285,0)
 ;Input:
"RTN","HLEMU",286,0)
 ;  VAR - a local or global variable passed by reference
"RTN","HLEMU",287,0)
 ;  N - a number to increment VAR by.  If not passed or =0 it is set to 1
"RTN","HLEMU",288,0)
 ;OUTPUT
"RTN","HLEMU",289,0)
 ;    VAR is incremented by the amount N and also returned as the function value
"RTN","HLEMU",290,0)
 ;
"RTN","HLEMU",291,0)
 I '$G(N) S N=1
"RTN","HLEMU",292,0)
 S VAR=$G(VAR)+N
"RTN","HLEMU",293,0)
 Q VAR
"RTN","HLEVAPI")
0^6^B63820662
"RTN","HLEVAPI",1,0)
HLEVAPI ;O-OIFO/LJA - Event Monitor APIs ;02/04/2004 14:42
"RTN","HLEVAPI",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVAPI",3,0)
 ;
"RTN","HLEVAPI",4,0)
 ; Routine   Supported APIs...
"RTN","HLEVAPI",5,0)
 ; -----------------------------------------------------------------
"RTN","HLEVAPI",6,0)
 ; HLEVAPI   START(VAR)
"RTN","HLEVAPI",7,0)
 ; HLEVAPI   CHECKIN
"RTN","HLEVAPI",8,0)
 ; HLEVAPI   CHECKOUT
"RTN","HLEVAPI",9,0)
 ; HLEVAPI   ABORT(STATUS,APPLSTAT)
"RTN","HLEVAPI",10,0)
 ; HLEVAPI   MAILIT
"RTN","HLEVAPI",11,0)
 ; HLEVAPI   VARIABLE
"RTN","HLEVAPI",12,0)
 ; -----------------------------------------------------------------
"RTN","HLEVAPI",13,0)
 ; HLEVAPI0  ONOFFM(HLEVIENE) 
"RTN","HLEVAPI",14,0)
 ; -----------------------------------------------------------------
"RTN","HLEVAPI",15,0)
 ; HLEVAPI1  APPSTAT(STATUS)
"RTN","HLEVAPI",16,0)
 ; HLEVAPI1  MSGTEXT(GBL)
"RTN","HLEVAPI",17,0)
 ; HLEVAPI1  RUNDIARY(GBL)
"RTN","HLEVAPI",18,0)
 ;
"RTN","HLEVAPI",19,0)
 ;
"RTN","HLEVAPI",20,0)
 ; Test server code with TEST^HLEVSRV1 (Also HLEVMNU)
"RTN","HLEVAPI",21,0)
 ; Test monitor code with TEST^HLEVUTI1 (Also HLEVMNU)
"RTN","HLEVAPI",22,0)
 ;
"RTN","HLEVAPI",23,0)
 ;
"RTN","HLEVAPI",24,0)
 ;                     EVENT CODE 
"RTN","HLEVAPI",25,0)
 ;
"RTN","HLEVAPI",26,0)
VARIABLE(HLEVIENJ,HLVAR) ; Store passed in variables...
"RTN","HLEVAPI",27,0)
 ; HLVAR can be the name of a variable, like "CT", or it can be
"RTN","HLEVAPI",28,0)
 ; a list of variables passed by reference.
"RTN","HLEVAPI",29,0)
 N VAL,VAR
"RTN","HLEVAPI",30,0)
 ;
"RTN","HLEVAPI",31,0)
 D DEBUG^HLEVAPI2("VARIABLE") ; Debug data created conditionally
"RTN","HLEVAPI",32,0)
 ;
"RTN","HLEVAPI",33,0)
 ; Stop all event monitoring to enable on-site debugging...
"RTN","HLEVAPI",34,0)
 QUIT:$G(^TMP("HLEVFLAG",$J))["STOP"  ;->
"RTN","HLEVAPI",35,0)
 ;
"RTN","HLEVAPI",36,0)
 QUIT:$G(^HLEV(776,+$G(HLEVIENJ),0))']""  ;->
"RTN","HLEVAPI",37,0)
 ;
"RTN","HLEVAPI",38,0)
 ; Loop thru array...
"RTN","HLEVAPI",39,0)
 S VAR=""
"RTN","HLEVAPI",40,0)
 F  S VAR=$O(HLVAR(VAR)) Q:VAR']""  D
"RTN","HLEVAPI",41,0)
 .  I $E(VAR,$L(VAR))="*" D  QUIT  ;->
"RTN","HLEVAPI",42,0)
 .  .  QUIT:VAR="*"  ;->
"RTN","HLEVAPI",43,0)
 .  .  D VARSTAR(HLEVIENJ,VAR)
"RTN","HLEVAPI",44,0)
 .  D STOREIT(HLEVIENJ,VAR,$S($D(@VAR):@VAR,1:"---"),$G(HLVAR(VAR)))
"RTN","HLEVAPI",45,0)
 ;
"RTN","HLEVAPI",46,0)
 Q
"RTN","HLEVAPI",47,0)
 ;
"RTN","HLEVAPI",48,0)
VARSTAR(HLEVIENJ,VAR) ; Store VAR* variables...
"RTN","HLEVAPI",49,0)
 N GBL,LP,REF,ROOT,X,X1
"RTN","HLEVAPI",50,0)
 ;
"RTN","HLEVAPI",51,0)
 KILL ^TMP("HLORDER",$J)
"RTN","HLEVAPI",52,0)
 S GBL=$NA(^TMP("HLORDER",$J)),ROOT=$E(GBL,1,$L(GBL)-1)_","
"RTN","HLEVAPI",53,0)
 S X=ROOT,X1(VAR)="" D ORDER^%ZOSV
"RTN","HLEVAPI",54,0)
 QUIT:'$D(GBL)  ;->
"RTN","HLEVAPI",55,0)
 ;
"RTN","HLEVAPI",56,0)
 ; $Q thru global...
"RTN","HLEVAPI",57,0)
 S LP=GBL
"RTN","HLEVAPI",58,0)
 F  S LP=$Q(@LP) Q:LP'[ROOT  D
"RTN","HLEVAPI",59,0)
 .  S REF=$P(LP,ROOT,2) QUIT:REF'[")"  ;->
"RTN","HLEVAPI",60,0)
 .  S REF=$P($TR(REF,"""",""),")") QUIT:REF']""  ;->
"RTN","HLEVAPI",61,0)
 .  I $L(REF)>10 S REF=$E(REF,1,9)_"~"
"RTN","HLEVAPI",62,0)
 .  D STOREIT(+HLEVIENJ,REF,@LP)
"RTN","HLEVAPI",63,0)
 ;
"RTN","HLEVAPI",64,0)
 Q
"RTN","HLEVAPI",65,0)
 ;
"RTN","HLEVAPI",66,0)
STOREIT(HLEVIENJ,VAR,VAL,EXPL) ; Store VAR in 776...
"RTN","HLEVAPI",67,0)
 N MIEN
"RTN","HLEVAPI",68,0)
 S EXPL=$G(EXPL)
"RTN","HLEVAPI",69,0)
 S MIEN=$O(^HLEV(776,+HLEVIENJ,52,"B",VAR,0))
"RTN","HLEVAPI",70,0)
 I MIEN'>0 S MIEN=$O(^HLEV(776,+HLEVIENJ,52,":"),-1)+1
"RTN","HLEVAPI",71,0)
 S ^HLEV(776,+HLEVIENJ,52,+MIEN,0)=VAR_$S(EXPL]"":U_EXPL,1:"")
"RTN","HLEVAPI",72,0)
 S ^HLEV(776,+HLEVIENJ,52,+MIEN,52)=VAL
"RTN","HLEVAPI",73,0)
 S ^HLEV(776,+HLEVIENJ,52,"B",VAR,MIEN)=""
"RTN","HLEVAPI",74,0)
 S MIEN=$O(^HLEV(776,+HLEVIENJ,52,":"),-1)
"RTN","HLEVAPI",75,0)
 I MIEN'>0 KILL ^HLEV(776,+HLEVIENJ,52) QUIT  ;->
"RTN","HLEVAPI",76,0)
 S ^HLEV(776,+HLEVIENJ,52,0)="^776.003A^"_MIEN_U_MIEN
"RTN","HLEVAPI",77,0)
 Q
"RTN","HLEVAPI",78,0)
 ;
"RTN","HLEVAPI",79,0)
STOREVAR ; Update VARIABLE VALUE multiple in 776...
"RTN","HLEVAPI",80,0)
 ; HLEVIENJ -- req
"RTN","HLEVAPI",81,0)
 ;
"RTN","HLEVAPI",82,0)
 ; Stop all event monitoring to enable on-site debugging...
"RTN","HLEVAPI",83,0)
 QUIT:$G(^TMP("HLEVFLAG",$J))["STOP"  ;->
"RTN","HLEVAPI",84,0)
 ;
"RTN","HLEVAPI",85,0)
 N MIEN,VAL,VAR
"RTN","HLEVAPI",86,0)
 ; Store variable values in 776...
"RTN","HLEVAPI",87,0)
 S VAR=""
"RTN","HLEVAPI",88,0)
 F  S VAR=$O(HLEVAR(VAR)) Q:VAR']""  D
"RTN","HLEVAPI",89,0)
 .  S VAL=$S($D(@VAR):@VAR,1:"---")
"RTN","HLEVAPI",90,0)
 .  S MIEN=$O(^HLEV(776,+HLEVIENJ,52,"B",VAR,0))
"RTN","HLEVAPI",91,0)
 .  I MIEN'>0 S MIEN=$O(^HLEV(776,+HLEVIENJ,52,":"),-1)+1
"RTN","HLEVAPI",92,0)
 .  S ^HLEV(776,+HLEVIENJ,52,+MIEN,0)=VAR_U_HLEVAR(VAR)
"RTN","HLEVAPI",93,0)
 .  S ^HLEV(776,+HLEVIENJ,52,+MIEN,52)=VAL
"RTN","HLEVAPI",94,0)
 .  S ^HLEV(776,+HLEVIENJ,52,"B",VAR,MIEN)=""
"RTN","HLEVAPI",95,0)
 S MIEN=$O(^HLEV(776,+HLEVIENJ,52,":"),-1)
"RTN","HLEVAPI",96,0)
 I MIEN'>0 KILL ^HLEV(776,+HLEVIENJ,52) QUIT  ;->
"RTN","HLEVAPI",97,0)
 S ^HLEV(776,+HLEVIENJ,52,0)="^776.003A^"_MIEN_U_MIEN
"RTN","HLEVAPI",98,0)
 Q
"RTN","HLEVAPI",99,0)
 ;
"RTN","HLEVAPI",100,0)
START(VARIABLE) ; Start the whole monitoring process.
"RTN","HLEVAPI",101,0)
 ; HLEVIENE,HLEVIENJ,HLEVIENM -- req --> HLEVAR()
"RTN","HLEVAPI",102,0)
 ;
"RTN","HLEVAPI",103,0)
 ; - Pass in by reference the VARIABLEs being tracked.
"RTN","HLEVAPI",104,0)
 ;
"RTN","HLEVAPI",105,0)
 ;   >S VAR("VARNAME")="REPORT-VARNAME"
"RTN","HLEVAPI",106,0)
 ;   >D DECLARE("MONITOR-NAME",.VAR)
"RTN","HLEVAPI",107,0)
 ;
"RTN","HLEVAPI",108,0)
 N E,EXPL,I,MIEN,NO,NODE,TXT,VAR
"RTN","HLEVAPI",109,0)
 ;
"RTN","HLEVAPI",110,0)
 D DEBUG^HLEVAPI2("START") ; Debug data created conditionally
"RTN","HLEVAPI",111,0)
 ;
"RTN","HLEVAPI",112,0)
 ; Stop all event monitoring to enable on-site debugging...
"RTN","HLEVAPI",113,0)
 QUIT:$G(^TMP("HLEVFLAG",$J))["STOP"  ;->
"RTN","HLEVAPI",114,0)
 ;
"RTN","HLEVAPI",115,0)
 ; Check STATUS-EVENT...
"RTN","HLEVAPI",116,0)
 QUIT:$P($G(^HLEV(776.999,1,0)),U,6)'="A"  ;->
"RTN","HLEVAPI",117,0)
 ;
"RTN","HLEVAPI",118,0)
 ; Presets...
"RTN","HLEVAPI",119,0)
 S NO=0
"RTN","HLEVAPI",120,0)
 KILL HLEVAR
"RTN","HLEVAPI",121,0)
 ;
"RTN","HLEVAPI",122,0)
 ; If passed in a variable name directly in VARIABLE
"RTN","HLEVAPI",123,0)
 I $G(VARIABLE)]"" F PCE=1:1:$L(VARIABLE,U) D
"RTN","HLEVAPI",124,0)
 .  S X=$P(VARIABLE,U,+PCE) I X]"" S NO=NO+1,HLEVAR(X)=X
"RTN","HLEVAPI",125,0)
 ;
"RTN","HLEVAPI",126,0)
 ; Convert passed in variable to format expected by CHECKIN & CHECKOUT
"RTN","HLEVAPI",127,0)
 S VAR=""
"RTN","HLEVAPI",128,0)
 F  S VAR=$O(VARIABLE(VAR)) Q:VAR']""  D
"RTN","HLEVAPI",129,0)
 .  S EXPL=VARIABLE(VAR) S:EXPL']"" EXPL=VAR
"RTN","HLEVAPI",130,0)
 .  S NO=NO+1,HLEVAR(VAR)=EXPL
"RTN","HLEVAPI",131,0)
 ;
"RTN","HLEVAPI",132,0)
 KILL VARIABLE
"RTN","HLEVAPI",133,0)
 ;
"RTN","HLEVAPI",134,0)
 ; Make initial DIARY entry...
"RTN","HLEVAPI",135,0)
 S TXT="DECLARE called - "_$P($G(^HLEV(776.1,+HLEVIENE,0)),U)
"RTN","HLEVAPI",136,0)
 D WPTXT^HLEVUTIL(776,HLEVIENJ,50,776.001,TXT)
"RTN","HLEVAPI",137,0)
 ;
"RTN","HLEVAPI",138,0)
 Q
"RTN","HLEVAPI",139,0)
 ;
"RTN","HLEVAPI",140,0)
CHECKIN ; Call here to update the EVENT using "your" DECLARE variables...
"RTN","HLEVAPI",141,0)
 N D,D0,DA,DI,DIE,DR,NO
"RTN","HLEVAPI",142,0)
 ;
"RTN","HLEVAPI",143,0)
 D DEBUG^HLEVAPI2("CHECKIN") ; Debug data created conditionally
"RTN","HLEVAPI",144,0)
 ;
"RTN","HLEVAPI",145,0)
 ; Stop all event monitoring to enable on-site debugging...
"RTN","HLEVAPI",146,0)
 QUIT:$G(^TMP("HLEVFLAG",$J))["STOP"  ;->
"RTN","HLEVAPI",147,0)
 ;
"RTN","HLEVAPI",148,0)
 ; Does entry exist?
"RTN","HLEVAPI",149,0)
 QUIT:$G(^HLEV(776,+$G(HLEVIENJ),0))']""  ;->
"RTN","HLEVAPI",150,0)
 ;
"RTN","HLEVAPI",151,0)
 D STOREVAR
"RTN","HLEVAPI",152,0)
 ;
"RTN","HLEVAPI",153,0)
 ; Fill in zero node...
"RTN","HLEVAPI",154,0)
 S DA=+HLEVIENJ,DIE=776
"RTN","HLEVAPI",155,0)
 S DR="4///R;6////"_$$NOW^XLFDT
"RTN","HLEVAPI",156,0)
 D ^DIE
"RTN","HLEVAPI",157,0)
 ;
"RTN","HLEVAPI",158,0)
 Q
"RTN","HLEVAPI",159,0)
 ;
"RTN","HLEVAPI",160,0)
ABORT(STATUS,APPLST) ; Call here if job is to be aborted...
"RTN","HLEVAPI",161,0)
 N DA,DIE,DR,NOW
"RTN","HLEVAPI",162,0)
 ;
"RTN","HLEVAPI",163,0)
 D DEBUG^HLEVAPI2("ABORT") ; Debug data created conditionally
"RTN","HLEVAPI",164,0)
 ;
"RTN","HLEVAPI",165,0)
 ; Stop all event monitoring to enable on-site debugging...
"RTN","HLEVAPI",166,0)
 QUIT:$G(^TMP("HLEVFLAG",$J))["STOP"  ;->
"RTN","HLEVAPI",167,0)
 ;
"RTN","HLEVAPI",168,0)
 ; Does entry exist?
"RTN","HLEVAPI",169,0)
 QUIT:$G(^HLEV(776,+$G(HLEVIENJ),0))']""  ;->
"RTN","HLEVAPI",170,0)
 ;
"RTN","HLEVAPI",171,0)
 D CHECKIN
"RTN","HLEVAPI",172,0)
 ;
"RTN","HLEVAPI",173,0)
 S DA=+HLEVIENJ,DIE=776
"RTN","HLEVAPI",174,0)
 S NOW=$$NOW^XLFDT
"RTN","HLEVAPI",175,0)
 S STATUS=$E($$UP^XLFSTR($G(STATUS)_" "))
"RTN","HLEVAPI",176,0)
 S STATUS=$S("EFQR"[STATUS:STATUS,1:"E")
"RTN","HLEVAPI",177,0)
 S DR="2////"_NOW_";4///"_STATUS_";6////"_NOW
"RTN","HLEVAPI",178,0)
 S:$G(APPLST)]"" DR=DR_";5///"_$TR($E(APPLST,1,10),U,"~")
"RTN","HLEVAPI",179,0)
 D ^DIE
"RTN","HLEVAPI",180,0)
 ;
"RTN","HLEVAPI",181,0)
 D EVCHKD^HLEVAPI2($G(HLEVIENM),$G(HLEVIENE),$G(HLEVIENJ),STATUS)
"RTN","HLEVAPI",182,0)
 ;
"RTN","HLEVAPI",183,0)
 KILL HLEVAR ; Passed-in user variables...
"RTN","HLEVAPI",184,0)
 ;
"RTN","HLEVAPI",185,0)
 Q
"RTN","HLEVAPI",186,0)
 ;
"RTN","HLEVAPI",187,0)
CHECKOUT ; Call here to end EVENT using "your" DECLARE variables...
"RTN","HLEVAPI",188,0)
 N DA,DIE,DR,NOW
"RTN","HLEVAPI",189,0)
 ;
"RTN","HLEVAPI",190,0)
 D DEBUG^HLEVAPI2("CHECKOUT") ; Debug data created conditionally
"RTN","HLEVAPI",191,0)
 ;
"RTN","HLEVAPI",192,0)
 ; Stop all event monitoring to enable on-site debugging...
"RTN","HLEVAPI",193,0)
 QUIT:$G(^TMP("HLEVFLAG",$J))["STOP"  ;->
"RTN","HLEVAPI",194,0)
 ;
"RTN","HLEVAPI",195,0)
 ; Does entry exist?
"RTN","HLEVAPI",196,0)
 QUIT:$G(^HLEV(776,+$G(HLEVIENJ),0))']""  ;->
"RTN","HLEVAPI",197,0)
 ;
"RTN","HLEVAPI",198,0)
 D CHECKIN
"RTN","HLEVAPI",199,0)
 ;
"RTN","HLEVAPI",200,0)
 S DA=+HLEVIENJ,DIE=776
"RTN","HLEVAPI",201,0)
 S NOW=$$NOW^XLFDT
"RTN","HLEVAPI",202,0)
 S DR="2////"_NOW_";4///F;6////"_NOW
"RTN","HLEVAPI",203,0)
 D ^DIE
"RTN","HLEVAPI",204,0)
 ;
"RTN","HLEVAPI",205,0)
 D EVCHKD^HLEVAPI2($G(HLEVIENM),$G(HLEVIENE),$G(HLEVIENJ))
"RTN","HLEVAPI",206,0)
 ;
"RTN","HLEVAPI",207,0)
 KILL HLEVAR ; Passed-in user variables...
"RTN","HLEVAPI",208,0)
 ;
"RTN","HLEVAPI",209,0)
 Q
"RTN","HLEVAPI",210,0)
 ;
"RTN","HLEVAPI",211,0)
MAILIT D MAILIT^HLEVAPI3
"RTN","HLEVAPI",212,0)
 Q
"RTN","HLEVAPI",213,0)
 ;
"RTN","HLEVAPI",214,0)
SENDMAIL(HLEVIENE,HLEVIENJ,XMY) ; Mail info in 776 event monitor's ^(51)...
"RTN","HLEVAPI",215,0)
 ;
"RTN","HLEVAPI",216,0)
 ; PARAMETER NOTES
"RTN","HLEVAPI",217,0)
 ; ---------------------------------------------------------------------
"RTN","HLEVAPI",218,0)
 ; XMY     Pass in XMY by reference.
"RTN","HLEVAPI",219,0)
 ; XMSUB   If XMSUB pre-exists, it will be used.
"RTN","HLEVAPI",220,0)
 ; XMTEXT  The text for the mailman message will come from one of 
"RTN","HLEVAPI",221,0)
 ;         three sources:
"RTN","HLEVAPI",222,0)
 ;           (1) If XMTEXT is pre-set, it will be used.
"RTN","HLEVAPI",223,0)
 ;           (2) If XMTEXT is not passed in, then the MAILMAN MESSAGE
"RTN","HLEVAPI",224,0)
 ;               TEXT global ^HLEV(776,IEN,51,#,0) will be used, if it
"RTN","HLEVAPI",225,0)
 ;               exits.
"RTN","HLEVAPI",226,0)
 ;           (3) Otherwise, a generic "message is completed" message
"RTN","HLEVAPI",227,0)
 ;               will be sent.
"RTN","HLEVAPI",228,0)
 ;
"RTN","HLEVAPI",229,0)
 N MGRP,NO,SITE,TEXT,XMDUZ,X,XMZ
"RTN","HLEVAPI",230,0)
 ;
"RTN","HLEVAPI",231,0)
 ; If no recipients passed in and no mail group exists, quit...
"RTN","HLEVAPI",232,0)
 QUIT:$O(XMY(""))']""  ;->
"RTN","HLEVAPI",233,0)
 ;
"RTN","HLEVAPI",234,0)
 QUIT:$P($G(^HLEV(776.1,+$G(HLEVIENE),0)),U)']""  ;->
"RTN","HLEVAPI",235,0)
 QUIT:$P($G(^HLEV(776,+$G(HLEVIENJ),0)),U)']""  ;->
"RTN","HLEVAPI",236,0)
 ;
"RTN","HLEVAPI",237,0)
 ; Set up sending...
"RTN","HLEVAPI",238,0)
 S XMDUZ=.5
"RTN","HLEVAPI",239,0)
 ;
"RTN","HLEVAPI",240,0)
 ; Subject...
"RTN","HLEVAPI",241,0)
 S X=$$SITE^VASITE,SITE="HL7 Monitor - "_$P(X,U,2)_"["_$P(X,U,3)_"]"
"RTN","HLEVAPI",242,0)
 S XMSUB=$S($G(XMSUB)]"":XMSUB,1:SITE_" - "_$P($G(^HLEV(776.1,+HLEVIENE,0)),U))
"RTN","HLEVAPI",243,0)
 ;
"RTN","HLEVAPI",244,0)
 ; Load generic message text...
"RTN","HLEVAPI",245,0)
 I $G(XMTEXT)']"" D
"RTN","HLEVAPI",246,0)
 .  KILL ^TMP($J,"HLMAILMSG")
"RTN","HLEVAPI",247,0)
 .  D LOADALL^HLEVAPI1(+HLEVIENJ,"HLMAILMSG")
"RTN","HLEVAPI",248,0)
 ;
"RTN","HLEVAPI",249,0)
 ; Declare where message is stored...
"RTN","HLEVAPI",250,0)
 S XMTEXT=$S($G(XMTEXT)]"":XMTEXT,1:"^TMP("_$J_",""HLMAILMSG"",")
"RTN","HLEVAPI",251,0)
 ;
"RTN","HLEVAPI",252,0)
 D ^XMD
"RTN","HLEVAPI",253,0)
 ;
"RTN","HLEVAPI",254,0)
 I '$D(ZTQUEUED) W !!,"Mail message #",$G(XMZ),"..."
"RTN","HLEVAPI",255,0)
 ;
"RTN","HLEVAPI",256,0)
 I $G(XMZ)>0 D UPDFLDE(+HLEVIENJ,7,XMZ)
"RTN","HLEVAPI",257,0)
 ;
"RTN","HLEVAPI",258,0)
 Q
"RTN","HLEVAPI",259,0)
 ;
"RTN","HLEVAPI",260,0)
NEWEVENT(HLEVIENE,QTIME) ; Create a new EVENT and pass back IEN...
"RTN","HLEVAPI",261,0)
 N DIC,DD,DO,X,Y
"RTN","HLEVAPI",262,0)
 ;
"RTN","HLEVAPI",263,0)
 ; Check STATUS-EVENT...
"RTN","HLEVAPI",264,0)
 QUIT:$P($G(^HLEV(776.999,1,0)),U,6)'="A"  ;->
"RTN","HLEVAPI",265,0)
 ;
"RTN","HLEVAPI",266,0)
 S X=$$NOW^XLFDT,DIC="^HLEV(776,",DIC(0)="L"
"RTN","HLEVAPI",267,0)
 S DIC("DR")="3////"_HLEVIENE_";4///Q"
"RTN","HLEVAPI",268,0)
 I $G(HLEVIENM)>0 S DIC("DR")=DIC("DR")_";9////"_HLEVIENM
"RTN","HLEVAPI",269,0)
 I $G(QTIME)]"" S DIC("DR")=DIC("DR")_";10////"_QTIME
"RTN","HLEVAPI",270,0)
 D FILE^DICN
"RTN","HLEVAPI",271,0)
 ;
"RTN","HLEVAPI",272,0)
 Q $S(+Y>0:+Y,1:"")
"RTN","HLEVAPI",273,0)
 ;
"RTN","HLEVAPI",274,0)
UPDFLDE(HLEVIENJ,FLD,VAL) ; Update a specific piece in 776...
"RTN","HLEVAPI",275,0)
 N DA,DIE,DR
"RTN","HLEVAPI",276,0)
 ;
"RTN","HLEVAPI",277,0)
 QUIT:$G(^HLEV(776,+$G(HLEVIENJ),0))']""  ;->
"RTN","HLEVAPI",278,0)
 ;
"RTN","HLEVAPI",279,0)
 ; Field 50, RUN DIARY...
"RTN","HLEVAPI",280,0)
 I FLD=50 D  QUIT  ;->
"RTN","HLEVAPI",281,0)
 .  N DIFF,NO,NOW,TIME
"RTN","HLEVAPI",282,0)
 .  S NO=$O(^HLEV(776,+HLEVIENJ,50,":"),-1)+1
"RTN","HLEVAPI",283,0)
 .  S ^HLEV(776,+HLEVIENJ,50,0)="^776.001^"_NO_U_NO
"RTN","HLEVAPI",284,0)
 .  S ^HLEV(776,+HLEVIENJ,50,+NO,0)=$G(VAL)
"RTN","HLEVAPI",285,0)
 .  ; If FLD=50, update timestamp every 30 seconds...
"RTN","HLEVAPI",286,0)
 .  ; (This is because many 50 nodes might be updated, one after the
"RTN","HLEVAPI",287,0)
 .  ; other in a very disk-intensive way.)
"RTN","HLEVAPI",288,0)
 .  S TIME=$P($G(^HLEV(776,+HLEVIENJ,0)),U,6) ; FM format
"RTN","HLEVAPI",289,0)
 .  S NOW=$$NOW^XLFDT
"RTN","HLEVAPI",290,0)
 .  S DIFF=$$FMDIFF^XLFDT(NOW,TIME,2) S:DIFF<0 DIFF=-DIFF
"RTN","HLEVAPI",291,0)
 .  QUIT:DIFF<30  ;->
"RTN","HLEVAPI",292,0)
 .  S DA=+HLEVIENJ,DIE=776,DR="6////"_NOW
"RTN","HLEVAPI",293,0)
 ;
"RTN","HLEVAPI",294,0)
 ; Fields 401-408...
"RTN","HLEVAPI",295,0)
 I FLD?3N&(FLD>400)&(FLD<409) D  QUIT  ;->
"RTN","HLEVAPI",296,0)
 .  S ^HLEV(776,+HLEVIENJ,FLD)=VAL
"RTN","HLEVAPI",297,0)
 ;
"RTN","HLEVAPI",298,0)
 ; Zero node data...
"RTN","HLEVAPI",299,0)
 QUIT:$G(VAL)']""  ;->
"RTN","HLEVAPI",300,0)
 S DA=+HLEVIENJ,DIE=776,DR=FLD_"///"_VAL_";6////"_$$NOW^XLFDT
"RTN","HLEVAPI",301,0)
 D ^DIE
"RTN","HLEVAPI",302,0)
 ;
"RTN","HLEVAPI",303,0)
 I FLD=2 D EVCHKD^HLEVAPI2($G(HLEVIENM),$G(HLEVIENE),$G(HLEVIENJ))
"RTN","HLEVAPI",304,0)
 ;
"RTN","HLEVAPI",305,0)
 Q
"RTN","HLEVAPI",306,0)
 ;
"RTN","HLEVAPI",307,0)
EOR ;HLEVAPI - Event Monitor APIs ;5/16/03 14:42
"RTN","HLEVAPI0")
0^7^B52756139
"RTN","HLEVAPI0",1,0)
HLEVAPI0 ;O-OIFO/LJA - Event Monitor APIs ;02/04/2004 14:42
"RTN","HLEVAPI0",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVAPI0",3,0)
 ;
"RTN","HLEVAPI0",4,0)
ONOFFM(HLEVIENE,STATUS) ;Turn on/off event monitor...
"RTN","HLEVAPI0",5,0)
 D DEBUG^HLEVAPI2("ONOFFM") ; Debug data created conditionally
"RTN","HLEVAPI0",6,0)
 ;
"RTN","HLEVAPI0",7,0)
 ; Stop all event monitoring to enable on-site debugging...
"RTN","HLEVAPI0",8,0)
 QUIT:$G(^TMP("HLEVFLAG",$J))["STOP"  ;->
"RTN","HLEVAPI0",9,0)
 ;
"RTN","HLEVAPI0",10,0)
 QUIT $$ONOFF(776.1,+HLEVIENE,STATUS)
"RTN","HLEVAPI0",11,0)
 ;
"RTN","HLEVAPI0",12,0)
ONOFFS(HLEVIEN,STATUS) ; Turn on/off system...
"RTN","HLEVAPI0",13,0)
 QUIT $$ONOFF(776.999,+HLEVIEN,STATUS)
"RTN","HLEVAPI0",14,0)
 ;
"RTN","HLEVAPI0",15,0)
ONOFF(FILE,HLEVIENE,STATUS) ; Turn on/off event monitor or system...
"RTN","HLEVAPI0",16,0)
 ; FILE can = 776.1 or 776.999
"RTN","HLEVAPI0",17,0)
 ; Actually, HLEVIENE can be the IEN of the monitor, or the system.
"RTN","HLEVAPI0",18,0)
 ; If STATUS="A", sets status to ACTIVE.
"RTN","HLEVAPI0",19,0)
 ; If STATUS="I", sets status to INACTIVE.
"RTN","HLEVAPI0",20,0)
 ; If STATUS=null or undefined (not passed), present status returned...
"RTN","HLEVAPI0",21,0)
 ;
"RTN","HLEVAPI0",22,0)
 N DA,DATA,DIE,DR,STAT,X,Y
"RTN","HLEVAPI0",23,0)
 ;
"RTN","HLEVAPI0",24,0)
 ; Find entry and IEN and zero node data...
"RTN","HLEVAPI0",25,0)
 S FILE=+$G(FILE) I FILE'=776.1&(FILE'=776.999) QUIT "^Invalid file number" ;->
"RTN","HLEVAPI0",26,0)
 S HLEVIENE=$G(HLEVIENE)
"RTN","HLEVAPI0",27,0)
 S:FILE=776.999 HLEVIENE=1 ; Just overwrite anything passed by user...
"RTN","HLEVAPI0",28,0)
 I $L($G(STATUS))>1 QUIT "^Invalid STATUS passed" ;->
"RTN","HLEVAPI0",29,0)
 S STATUS=$$UP^XLFSTR($E($G(STATUS)_" "))
"RTN","HLEVAPI0",30,0)
 I " AI"'[STATUS QUIT "^Invalid STATUS passed" ;->
"RTN","HLEVAPI0",31,0)
 ;
"RTN","HLEVAPI0",32,0)
 ; If they passed the name of the entry...
"RTN","HLEVAPI0",33,0)
 I HLEVIENE'=+HLEVIENE D  QUIT:HLEVIENE'>0 "^Couldn't find entry" ;->
"RTN","HLEVAPI0",34,0)
 .  I $TR(HLEVIENE," ","")']"" QUIT  ;->
"RTN","HLEVAPI0",35,0)
 .  S HLEVIENE(1)=$O(^HLEV(FILE,"B",HLEVIENE,0)) ; Must have passed in name
"RTN","HLEVAPI0",36,0)
 .  I HLEVIENE(1)'>0 D
"RTN","HLEVAPI0",37,0)
 .  .  S HLEVIENE(1)=$O(^HLEV(FILE,"B",$$UP^XLFSTR(HLEVIENE),0))
"RTN","HLEVAPI0",38,0)
 .  S HLEVIENE=HLEVIENE(1)
"RTN","HLEVAPI0",39,0)
 ;
"RTN","HLEVAPI0",40,0)
 ; Get zero node...
"RTN","HLEVAPI0",41,0)
 S DATA=$G(^HLEV(FILE,+HLEVIENE,0)) QUIT:DATA']"" "^Couldn't find entry" ;->
"RTN","HLEVAPI0",42,0)
 ;
"RTN","HLEVAPI0",43,0)
 ; Get current status...
"RTN","HLEVAPI0",44,0)
 S STAT=$E($P(DATA,U,2)_" ")
"RTN","HLEVAPI0",45,0)
 ;
"RTN","HLEVAPI0",46,0)
 ; If current status not yet entered in field...
"RTN","HLEVAPI0",47,0)
 I " AI"'[STAT D  QUIT STAT ;->
"RTN","HLEVAPI0",48,0)
 .  ; Passed-in STATUS not A or I, so just tell them value of status...
"RTN","HLEVAPI0",49,0)
 .  I "AI"'[STATUS S STAT="^Status not entered yet" QUIT  ;->
"RTN","HLEVAPI0",50,0)
 .  ; User passed in a value to set the status to, so set it for them...
"RTN","HLEVAPI0",51,0)
 .  S DA=+HLEVIENE,DIE=FILE,DR="2///"_STATUS
"RTN","HLEVAPI0",52,0)
 .  D ^DIE
"RTN","HLEVAPI0",53,0)
 .  S STAT=STATUS
"RTN","HLEVAPI0",54,0)
 ;
"RTN","HLEVAPI0",55,0)
 ; If all they want is the status...
"RTN","HLEVAPI0",56,0)
 I STATUS=" " QUIT STAT ;->
"RTN","HLEVAPI0",57,0)
 ;
"RTN","HLEVAPI0",58,0)
 ; Status entered in field before call...
"RTN","HLEVAPI0",59,0)
 ;
"RTN","HLEVAPI0",60,0)
 ; If passed-in status is the same as the current status in entry...
"RTN","HLEVAPI0",61,0)
 I STAT=STATUS QUIT STATUS ;-> Already set...
"RTN","HLEVAPI0",62,0)
 ;
"RTN","HLEVAPI0",63,0)
 ; Change status of field to passed-in value...
"RTN","HLEVAPI0",64,0)
 S DA=+HLEVIENE,DIE=FILE,DR="2///"_STATUS
"RTN","HLEVAPI0",65,0)
 D ^DIE
"RTN","HLEVAPI0",66,0)
 ;
"RTN","HLEVAPI0",67,0)
 Q STATUS
"RTN","HLEVAPI0",68,0)
 ;
"RTN","HLEVAPI0",69,0)
ONOFFEV ; Turn on/off event monitor
"RTN","HLEVAPI0",70,0)
 N CHG
"RTN","HLEVAPI0",71,0)
 ;
"RTN","HLEVAPI0",72,0)
 N DATA,DIC,IEN,IENR
"RTN","HLEVAPI0",73,0)
 D HDR^HLEVREP("Turn on/off Event Monitors")
"RTN","HLEVAPI0",74,0)
 ;
"RTN","HLEVAPI0",75,0)
S7761 KILL DATA,DIC,IEN,IENR
"RTN","HLEVAPI0",76,0)
 W !
"RTN","HLEVAPI0",77,0)
 S IEN=$$ASKIEN^HLEVREP(776.1) QUIT:IEN'>0  ;->
"RTN","HLEVAPI0",78,0)
 D HDR^HLEVREP("Turn on/off Event Monitors",IEN)
"RTN","HLEVAPI0",79,0)
 D VIEW7761(+IEN)
"RTN","HLEVAPI0",80,0)
 D RUNS7761^HLEVREP(+IEN)
"RTN","HLEVAPI0",81,0)
 I $D(^TMP($J,"HLRUNS")) D
"RTN","HLEVAPI0",82,0)
 .  W !!,"Recent Checks of the Monitor by Master Job"
"RTN","HLEVAPI0",83,0)
 .  W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLEVAPI0",84,0)
 .  W !,"Check-time",?18,"Results"
"RTN","HLEVAPI0",85,0)
 .  W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLEVAPI0",86,0)
 .  S IENR=0
"RTN","HLEVAPI0",87,0)
 .  F  S IENR=$O(^TMP($J,"HLRUNS",IENR)) Q:IENR'>0  D
"RTN","HLEVAPI0",88,0)
 .  .  S DATA=$G(^TMP($J,"HLRUNS",IENR)) QUIT:DATA']""  ;->
"RTN","HLEVAPI0",89,0)
 .  .  W !,$$SDT^HLEVX001($P(DATA,U,2)),?18,$$STAT2M^HLEVX001($P(DATA,U))
"RTN","HLEVAPI0",90,0)
 W !
"RTN","HLEVAPI0",91,0)
 S CHG=$$ACTINACT(776.1,+IEN,2,"Event monitor status")
"RTN","HLEVAPI0",92,0)
 I CHG D
"RTN","HLEVAPI0",93,0)
 .  D HDR^HLEVREP("Turn on/off Event Monitors",IEN)
"RTN","HLEVAPI0",94,0)
 .  D VIEW7761(+IEN)
"RTN","HLEVAPI0",95,0)
 F  Q:(IOSL-$Y)<4  W !
"RTN","HLEVAPI0",96,0)
 ;S X=$$BTE^HLCSMON("Press RETURN to continue... ")
"RTN","HLEVAPI0",97,0)
 G S7761 ;->
"RTN","HLEVAPI0",98,0)
 ;
"RTN","HLEVAPI0",99,0)
VIEW7761(IEN) ; Actual display code for entry...
"RTN","HLEVAPI0",100,0)
 N NODE,P1,P2,P3,P4,P5,P6,PAR,PCE
"RTN","HLEVAPI0",101,0)
 ;
"RTN","HLEVAPI0",102,0)
 S NODE=$G(^HLEV(776.1,+IEN,0))
"RTN","HLEVAPI0",103,0)
 F PCE=1:1:6 S @("P"_PCE)=$P(NODE,U,PCE)
"RTN","HLEVAPI0",104,0)
 ;
"RTN","HLEVAPI0",105,0)
 ; Store under field number...
"RTN","HLEVAPI0",106,0)
 F PCE=1:1:8 S PAR(PCE)=$P($G(^HLEV(776.1,+IEN,40)),U,PCE)
"RTN","HLEVAPI0",107,0)
 ;
"RTN","HLEVAPI0",108,0)
 D SH7761("Description",$S(P3]"":P3,1:"---"))
"RTN","HLEVAPI0",109,0)
 D SH7761("Status",$S(P2="A":"ACTIVE",1:"INACTIVE"))
"RTN","HLEVAPI0",110,0)
 D SH7761("Requeue minutes",$S(P4:P4_"min",P4=0:"0 [Immediate Run]",1:"---"))
"RTN","HLEVAPI0",111,0)
 D SH7761("Notification mail group",$S(P5:$P($G(^XMB(3.8,+P5,0)),U),1:"---"))
"RTN","HLEVAPI0",112,0)
 D SH7761("M startup",$S(P6]"":P6,1:"---"))
"RTN","HLEVAPI0",113,0)
 W !,$$CJ^XLFSTR(" Parameter ""Variable"" Descriptors ",IOM,"-")
"RTN","HLEVAPI0",114,0)
 F PCE=1:1:8 I PAR(PCE)]"" D
"RTN","HLEVAPI0",115,0)
 .  W !,?25,"Parameter - "_PCE_" = ",PAR(PCE)
"RTN","HLEVAPI0",116,0)
 ;
"RTN","HLEVAPI0",117,0)
 Q
"RTN","HLEVAPI0",118,0)
 ;
"RTN","HLEVAPI0",119,0)
SH7761(TAG,VAL) ;
"RTN","HLEVAPI0",120,0)
 W !,?(35-$L(TAG)-2),TAG,":",?45,VAL
"RTN","HLEVAPI0",121,0)
 Q
"RTN","HLEVAPI0",122,0)
 ;
"RTN","HLEVAPI0",123,0)
ONOFFPAR ; Turn on/off parameters...
"RTN","HLEVAPI0",124,0)
 N CHG
"RTN","HLEVAPI0",125,0)
 ;
"RTN","HLEVAPI0",126,0)
 D VIEW7769^HLEVREP(0)
"RTN","HLEVAPI0",127,0)
 ;
"RTN","HLEVAPI0",128,0)
 W !
"RTN","HLEVAPI0",129,0)
 ;
"RTN","HLEVAPI0",130,0)
 S CHG=0
"RTN","HLEVAPI0",131,0)
 S X=$$ACTINACT(776.999,1,2,"STATUS-MASTER JOB") I X=1 S CHG=1
"RTN","HLEVAPI0",132,0)
 S X=$$ACTINACT(776.999,1,6,"STATUS-EVENT MONITORING") I X=1 S CHG=1
"RTN","HLEVAPI0",133,0)
 ;
"RTN","HLEVAPI0",134,0)
 I CHG D VIEW7769^HLEVREP(0)
"RTN","HLEVAPI0",135,0)
 ;
"RTN","HLEVAPI0",136,0)
 W !
"RTN","HLEVAPI0",137,0)
 F  Q:(IOSL-$Y)<3  W !
"RTN","HLEVAPI0",138,0)
 S X=$$BTE^HLCSMON("Press RETURN to exit... ")
"RTN","HLEVAPI0",139,0)
 ;
"RTN","HLEVAPI0",140,0)
 Q
"RTN","HLEVAPI0",141,0)
 ;
"RTN","HLEVAPI0",142,0)
ACTINACT(FILE,IEN,FLD,TAG) ; Turn on/off status fields...
"RTN","HLEVAPI0",143,0)
 N DA,DIE,DR,STAT,X,Y
"RTN","HLEVAPI0",144,0)
 S STAT=$P($G(^HLEV(FILE,IEN,0)),U,+FLD)
"RTN","HLEVAPI0",145,0)
 S X=$$YN^HLCSRPT4("Change '"_TAG_"' to "_$S(STAT="A":"INACTIVE",1:"ACTIVE"),"No") I X'=1 D  QUIT "" ;->
"RTN","HLEVAPI0",146,0)
 .  W "  ... nothing changed ..."
"RTN","HLEVAPI0",147,0)
 S DA=IEN,DIE=FILE,DR=FLD_"///"_$S(STAT="A":"I",1:"A")
"RTN","HLEVAPI0",148,0)
 D ^DIE
"RTN","HLEVAPI0",149,0)
 W "     changed!"
"RTN","HLEVAPI0",150,0)
 Q 1
"RTN","HLEVAPI0",151,0)
 ;
"RTN","HLEVAPI0",152,0)
EVENTCHK(HLEVIENM) ; Loop thru all MONITORs...
"RTN","HLEVAPI0",153,0)
 ; NOEVCHK,ZTSKMST -- req
"RTN","HLEVAPI0",154,0)
 N HLEVIENE,HLEVNM
"RTN","HLEVAPI0",155,0)
 ;
"RTN","HLEVAPI0",156,0)
 ; Check STATUS-EVENT...
"RTN","HLEVAPI0",157,0)
 S NO=$O(^HLEV(776.999,":"),-1) QUIT:$P($G(^HLEV(776.999,+NO,0)),U,6)'="A"  ;->
"RTN","HLEVAPI0",158,0)
 ;
"RTN","HLEVAPI0",159,0)
 S HLEVNM=0
"RTN","HLEVAPI0",160,0)
 F  S HLEVNM=$O(^HLEV(776.1,"B",HLEVNM)) Q:HLEVNM']""  D
"RTN","HLEVAPI0",161,0)
 .  S HLEVIENE=0
"RTN","HLEVAPI0",162,0)
 .  F  S HLEVIENE=$O(^HLEV(776.1,"B",HLEVNM,HLEVIENE)) Q:'HLEVIENE  D
"RTN","HLEVAPI0",163,0)
 .  .  D EVENTONE^HLEVAPI3(HLEVIENM,HLEVNM,HLEVIENE)
"RTN","HLEVAPI0",164,0)
 .  .  S NOEVCHK=$G(NOEVCHK)+1
"RTN","HLEVAPI0",165,0)
 ;
"RTN","HLEVAPI0",166,0)
 Q
"RTN","HLEVAPI0",167,0)
 ;
"RTN","HLEVAPI0",168,0)
EVRES(HLEVIENM,HLEVIENE,RES,HLEVIENJ) ; Record result of queued task...
"RTN","HLEVAPI0",169,0)
 ; ZTSK -- req
"RTN","HLEVAPI0",170,0)
 N MIEN,NODE,STATUS
"RTN","HLEVAPI0",171,0)
 ;
"RTN","HLEVAPI0",172,0)
 ; Initial sets...
"RTN","HLEVAPI0",173,0)
 S STATUS=$P($G(^HLEV(776,+$G(HLEVIENJ),0)),U,4)
"RTN","HLEVAPI0",174,0)
 S RES=$E($$UP^XLFSTR($G(RES)))
"RTN","HLEVAPI0",175,0)
 ;
"RTN","HLEVAPI0",176,0)
 ; If any call made here, the job is running by definition...
"RTN","HLEVAPI0",177,0)
 I $G(^HLEV(776,+$G(HLEVIENJ),0))]"" D
"RTN","HLEVAPI0",178,0)
 .  ; ABORT^HLEVAPI might have set status to ERROR.  Don't override!
"RTN","HLEVAPI0",179,0)
 .  S $P(^HLEV(776,+$G(HLEVIENJ),0),U,4)=$S(STATUS="E":"E",RES="X":"E",RES="F":"F",1:"R")
"RTN","HLEVAPI0",180,0)
 ;
"RTN","HLEVAPI0",181,0)
 ; If no master job, or RUNNING, quit...
"RTN","HLEVAPI0",182,0)
 I HLEVIENM=9999999!(RES="R") QUIT  ;->
"RTN","HLEVAPI0",183,0)
 ;
"RTN","HLEVAPI0",184,0)
 ; Store results in 776.2...
"RTN","HLEVAPI0",185,0)
 S MIEN=$O(^HLEV(776.2,+HLEVIENM,51,"B",+HLEVIENE,0)) QUIT:MIEN'>0  ;->
"RTN","HLEVAPI0",186,0)
 S NODE=$G(^HLEV(776.2,+HLEVIENM,51,+MIEN,0)) QUIT:NODE']""  ;->
"RTN","HLEVAPI0",187,0)
 ; Various jobs will set... QUIT:$P(NODE,U,4)'=$G(ZTSK)  ;->
"RTN","HLEVAPI0",188,0)
 S $P(NODE,U,5)=$G(RES),$P(NODE,U,6)=$$NOW^XLFDT
"RTN","HLEVAPI0",189,0)
 S ^HLEV(776.2,+HLEVIENM,51,+MIEN,0)=NODE
"RTN","HLEVAPI0",190,0)
 ;
"RTN","HLEVAPI0",191,0)
 Q
"RTN","HLEVAPI0",192,0)
 ;
"RTN","HLEVAPI0",193,0)
RUNEV(LASTRUN,LAPSE) ; Is LASTRUN (FM) LAPSE(min) before NOW?
"RTN","HLEVAPI0",194,0)
 N WHENRUN
"RTN","HLEVAPI0",195,0)
 QUIT:LASTRUN']"" "" ;->
"RTN","HLEVAPI0",196,0)
 S WHENRUN=$$FMADD^XLFDT($$NOW^XLFDT,0,0,-LAPSE)
"RTN","HLEVAPI0",197,0)
 Q $S(WHENRUN>LASTRUN:1,1:"")
"RTN","HLEVAPI0",198,0)
 ;
"RTN","HLEVAPI0",199,0)
OKMCODE(MREF) ; Is this a valid M subrtn^rtn reference?
"RTN","HLEVAPI0",200,0)
 N TXT
"RTN","HLEVAPI0",201,0)
 QUIT:MREF'?1.8E1"^"1.8E "" ;->
"RTN","HLEVAPI0",202,0)
 S TXT=$T(@MREF)
"RTN","HLEVAPI0",203,0)
 Q $S(TXT]"":1,1:"")
"RTN","HLEVAPI0",204,0)
 ;
"RTN","HLEVAPI0",205,0)
Q1TIME(HLEVIENE,OVERRIDE,QTIME,XTMP) ; Start a one-time run of event monitor (w/no master job)
"RTN","HLEVAPI0",206,0)
 N DATA,HLEVIENJ,HLEVNM,ZTDESC,ZTDTH,ZTIO,ZTRTN,ZTSAVE,ZTSK
"RTN","HLEVAPI0",207,0)
 ;
"RTN","HLEVAPI0",208,0)
 ; Override inactive entry?
"RTN","HLEVAPI0",209,0)
 S OVERRIDE=$S($G(OVERRIDE):1,1:0)
"RTN","HLEVAPI0",210,0)
 ;
"RTN","HLEVAPI0",211,0)
 ; Queue to future time?
"RTN","HLEVAPI0",212,0)
 S QTIME=$G(QTIME)
"RTN","HLEVAPI0",213,0)
 ;
"RTN","HLEVAPI0",214,0)
 ; Is event active?
"RTN","HLEVAPI0",215,0)
 S DATA=$G(^HLEV(776.1,+$G(HLEVIENE),0)) QUIT:DATA']"" "^Entry not found" ;->
"RTN","HLEVAPI0",216,0)
 I $P(DATA,U,2)'="A",'OVERRIDE QUIT "^Event not active" ;->
"RTN","HLEVAPI0",217,0)
 ;
"RTN","HLEVAPI0",218,0)
 ; More variable sets...
"RTN","HLEVAPI0",219,0)
 S HLEVNM=$P(DATA,U)
"RTN","HLEVAPI0",220,0)
 S HLEVIENM=9999999 ; A one-time, no master job, run...
"RTN","HLEVAPI0",221,0)
 ;
"RTN","HLEVAPI0",222,0)
 ; Create a monitor stub entry...
"RTN","HLEVAPI0",223,0)
 S HLEVIENJ=$$NEWEVENT^HLEVAPI(HLEVIENE,QTIME)
"RTN","HLEVAPI0",224,0)
 I HLEVIENJ'>0 QUIT "^Entry creation failure" ;->
"RTN","HLEVAPI0",225,0)
 ;
"RTN","HLEVAPI0",226,0)
 ; Queue a new job w/stub entry's IEN...
"RTN","HLEVAPI0",227,0)
 S ZTIO="",ZTDTH=$S(QTIME?7N1"."1.N:$$FMTH^XLFDT(QTIME),1:$H)
"RTN","HLEVAPI0",228,0)
 S ZTDESC="HL Event Monitor - #"_HLEVIENE
"RTN","HLEVAPI0",229,0)
 S ZTRTN="QUEUEV^HLEVAPI3"
"RTN","HLEVAPI0",230,0)
 S ZTSAVE("HLEVIENJ")="",ZTSAVE("HLEVIENE")=""
"RTN","HLEVAPI0",231,0)
 S ZTSAVE("HLEVNM")="",ZTSAVE("HLEVIENM")=""
"RTN","HLEVAPI0",232,0)
 I $G(XTMP)]"" S ZTSAVE("XTMP")=""
"RTN","HLEVAPI0",233,0)
 D ^%ZTLOAD
"RTN","HLEVAPI0",234,0)
 ;
"RTN","HLEVAPI0",235,0)
 I $G(^HLEV(776,+$G(HLEVIENJ),0))]"",$G(ZTSK)>0 D
"RTN","HLEVAPI0",236,0)
 .  N DA,DIE,DR
"RTN","HLEVAPI0",237,0)
 .  S DA=+HLEVIENJ,DIE=776,DR="8///"_ZTSK
"RTN","HLEVAPI0",238,0)
 .  D ^DIE
"RTN","HLEVAPI0",239,0)
 ;
"RTN","HLEVAPI0",240,0)
 Q $G(ZTSK)_U_$G(HLEVIENJ)
"RTN","HLEVAPI0",241,0)
 ;
"RTN","HLEVAPI0",242,0)
EOR ;HLEVAPI0 - Event Monitor APIs ;5/16/03 14:42
"RTN","HLEVAPI1")
0^8^B73010717
"RTN","HLEVAPI1",1,0)
HLEVAPI1 ;O-OIFO/LJA - Event Monitor APIs ;02/04/2004 14:42
"RTN","HLEVAPI1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVAPI1",3,0)
 ;
"RTN","HLEVAPI1",4,0)
SYSETUP ; Called by option's entry action...
"RTN","HLEVAPI1",5,0)
 N DATA,LAST,NEXT,STAT
"RTN","HLEVAPI1",6,0)
 ;
"RTN","HLEVAPI1",7,0)
 ; Make sure master job is current...
"RTN","HLEVAPI1",8,0)
 D CHECKMST^HLEVMST
"RTN","HLEVAPI1",9,0)
 ;
"RTN","HLEVAPI1",10,0)
 S DATA=$G(^HLEV(776.999,1,0)),LAST=$$LAST7762,NEXT=$$NEXT7762
"RTN","HLEVAPI1",11,0)
 ;
"RTN","HLEVAPI1",12,0)
 S STAT=$P(DATA,U,2)
"RTN","HLEVAPI1",13,0)
 S STAT="-------- Master job status is "_$S(STAT="A":"ACTIVE",STAT="I":"INACTIVE",1:"NOT SET YET")_" --------"
"RTN","HLEVAPI1",14,0)
 W !!!,$$CJ^XLFSTR(STAT,IOM)
"RTN","HLEVAPI1",15,0)
 S X=$$LAST7762 I X]"" W !,$$CJ^XLFSTR(X,IOM)
"RTN","HLEVAPI1",16,0)
 S X=$$NEXT7762 I X]"" W !,$$CJ^XLFSTR(X,IOM)
"RTN","HLEVAPI1",17,0)
 ;
"RTN","HLEVAPI1",18,0)
 S STAT=$P(DATA,U,6)
"RTN","HLEVAPI1",19,0)
 W !,$$CJ^XLFSTR("-------- Event monitoring status is "_$S(STAT="A":"ACTIVE",STAT="I":"INACTIVE",1:"NOT SET YET")_" --------",IOM)
"RTN","HLEVAPI1",20,0)
 ;
"RTN","HLEVAPI1",21,0)
 Q
"RTN","HLEVAPI1",22,0)
 ;
"RTN","HLEVAPI1",23,0)
LAST7762() ; Return d/h/m/s since last master job run...
"RTN","HLEVAPI1",24,0)
 N DATA,FIEN,IEN,LASTDT
"RTN","HLEVAPI1",25,0)
 ;
"RTN","HLEVAPI1",26,0)
 S LASTDT=":",FIEN=0
"RTN","HLEVAPI1",27,0)
 F  S LASTDT=$O(^HLEV(776.2,"B",LASTDT),-1) Q:'LASTDT!(FIEN)  D
"RTN","HLEVAPI1",28,0)
 .  S IEN=":"
"RTN","HLEVAPI1",29,0)
 .  F  S IEN=$O(^HLEV(776.2,"B",+LASTDT,IEN),-1) Q:'IEN!(FIEN)  D
"RTN","HLEVAPI1",30,0)
 .  .  S DATA=$G(^HLEV(776.2,+IEN,0)) QUIT:$P(DATA,U,4)'="F"  ;->
"RTN","HLEVAPI1",31,0)
 .  .  S FIEN=IEN
"RTN","HLEVAPI1",32,0)
 ;
"RTN","HLEVAPI1",33,0)
 QUIT:'FIEN "Unknown last master job run time..." ;->
"RTN","HLEVAPI1",34,0)
 ;
"RTN","HLEVAPI1",35,0)
 QUIT $$DT7762(FIEN,0)
"RTN","HLEVAPI1",36,0)
 ;
"RTN","HLEVAPI1",37,0)
NEXT7762() ; Return d/h/m/s till next master job run...
"RTN","HLEVAPI1",38,0)
 N DATA,FIEN,IEN,LASTDT
"RTN","HLEVAPI1",39,0)
 ;
"RTN","HLEVAPI1",40,0)
 S LASTDT=":",FIEN=0
"RTN","HLEVAPI1",41,0)
 F  S LASTDT=$O(^HLEV(776.2,"B",LASTDT),-1) Q:'LASTDT!(FIEN)  D
"RTN","HLEVAPI1",42,0)
 .  S IEN=":"
"RTN","HLEVAPI1",43,0)
 .  F  S IEN=$O(^HLEV(776.2,"B",+LASTDT,IEN),-1) Q:'IEN!(FIEN)  D
"RTN","HLEVAPI1",44,0)
 .  .  S DATA=$G(^HLEV(776.2,+IEN,0)) QUIT:$P(DATA,U,4)'="Q"  ;->
"RTN","HLEVAPI1",45,0)
 .  .  S FIEN=IEN
"RTN","HLEVAPI1",46,0)
 ;
"RTN","HLEVAPI1",47,0)
 QUIT:'FIEN "Unknown next master job run time..." ;->
"RTN","HLEVAPI1",48,0)
 ;
"RTN","HLEVAPI1",49,0)
 Q $$DT7762(+FIEN,1)
"RTN","HLEVAPI1",50,0)
 ;
"RTN","HLEVAPI1",51,0)
DT7762(FIEN,NXT) ; Called by $$LAST7762 & NEXT7762...
"RTN","HLEVAPI1",52,0)
 N DATA,DATE
"RTN","HLEVAPI1",53,0)
 S DATA=$G(^HLEV(776.2,+FIEN,0))
"RTN","HLEVAPI1",54,0)
 S DATE=$P(DATA,U,$S('NXT:2,1:6)) QUIT:DATE'?7N1"."1.N "" ;->
"RTN","HLEVAPI1",55,0)
 S DATE=$$DHMSFM^HLEVUTIL(DATE,$$NOW^XLFDT,1)
"RTN","HLEVAPI1",56,0)
 I 'NXT D  QUIT DATE ;-> Last...
"RTN","HLEVAPI1",57,0)
 .  I DATE["[" S DATE="Unknown last master job run..." QUIT  ;->
"RTN","HLEVAPI1",58,0)
 .  S DATE="Last master job run was "_DATE_" ago..."
"RTN","HLEVAPI1",59,0)
 I NXT D  QUIT DATE ;-> Next...
"RTN","HLEVAPI1",60,0)
 .  I DATE'["[" S DATE="Unknown next master job run..." QUIT  ;->
"RTN","HLEVAPI1",61,0)
 .  S DATE="Next run "_$S($P(DATA,U,5):"[task# "_$P(DATA,U,5)_"] ",1:"")_"is "_$P($P(DATE,"[",2),"]")_" in the future..."
"RTN","HLEVAPI1",62,0)
 Q ""
"RTN","HLEVAPI1",63,0)
 ;
"RTN","HLEVAPI1",64,0)
LOADALL(HLEVIENJ,SVSUB) ; Load all sections into global for mailing...
"RTN","HLEVAPI1",65,0)
 N NO,TXT
"RTN","HLEVAPI1",66,0)
 S SVSUB=$S($G(SVSUB)]"":SVSUB,1:"HLMAILMSG") ; Save Subscript...
"RTN","HLEVAPI1",67,0)
 D LOADDESC(HLEVIENJ,SVSUB) ; Short description of monitor.
"RTN","HLEVAPI1",68,0)
 D LOADCOMP(HLEVIENJ,SVSUB) ; Completed line...
"RTN","HLEVAPI1",69,0)
 D LOADBODY^HLEVAPI2(HLEVIENJ,SVSUB) ; Start/end/Status/Status-Appl...
"RTN","HLEVAPI1",70,0)
 S NO=0
"RTN","HLEVAPI1",71,0)
 F  S NO=$O(HLEVTXT(NO)) Q:NO'>0  D
"RTN","HLEVAPI1",72,0)
 .  S TXT=$G(HLEVTXT(NO)) QUIT:TXT']""  ;->
"RTN","HLEVAPI1",73,0)
 .  S TXT=$$UP^XLFSTR($TR(TXT," ",""))
"RTN","HLEVAPI1",74,0)
 .  I TXT="RUNDIARY" D LOADDGBL^HLEVAPI2(HLEVIENJ,50,SVSUB) QUIT  ;->
"RTN","HLEVAPI1",75,0)
 .  I TXT="MESSAGETEXT" D LOADDGBL^HLEVAPI2(HLEVIENJ,51,SVSUB) QUIT  ;->
"RTN","HLEVAPI1",76,0)
 .  I TXT="VARIABLEVALUE" D LOADVAR(HLEVIENJ,SVSUB) QUIT  ;->
"RTN","HLEVAPI1",77,0)
 .  KILL X S X="W "_TXT D ^DIM Q:'$D(X)  ;->
"RTN","HLEVAPI1",78,0)
 .  D LOADUSER(TXT,SVSUB)
"RTN","HLEVAPI1",79,0)
 Q
"RTN","HLEVAPI1",80,0)
 ;
"RTN","HLEVAPI1",81,0)
LOADUSER(GBL,SVSUB) ; Load user data into Mailman message...
"RTN","HLEVAPI1",82,0)
 N NO,TXT
"RTN","HLEVAPI1",83,0)
 ;
"RTN","HLEVAPI1",84,0)
 QUIT:$O(@GBL@(0))'>0  ;->
"RTN","HLEVAPI1",85,0)
 ;
"RTN","HLEVAPI1",86,0)
 S NO=0
"RTN","HLEVAPI1",87,0)
 F  S NO=$O(@GBL@(NO)) Q:NO'>0  D
"RTN","HLEVAPI1",88,0)
 .  S TXT=$G(@GBL@(NO))
"RTN","HLEVAPI1",89,0)
 .  F  D  Q:TXT']""
"RTN","HLEVAPI1",90,0)
 .  .  D ADD($E(TXT,1,74))
"RTN","HLEVAPI1",91,0)
 .  .  S TXT=$E(TXT,75,999) QUIT:TXT']""  ;->
"RTN","HLEVAPI1",92,0)
 .  .  S TXT="   "_TXT
"RTN","HLEVAPI1",93,0)
 ;
"RTN","HLEVAPI1",94,0)
 Q
"RTN","HLEVAPI1",95,0)
 ;
"RTN","HLEVAPI1",96,0)
LOADDESC(HLEVIENJ,SVSUB) ; Load description if it exists...
"RTN","HLEVAPI1",97,0)
 N DESC,HLEVIENE
"RTN","HLEVAPI1",98,0)
 S SVSUB=$S($G(SVSUB)]"":SVSUB,1:"HLMAILMSG")
"RTN","HLEVAPI1",99,0)
 S HLEVIENE=$P($G(^HLEV(776,+HLEVIENJ,0)),U,3)
"RTN","HLEVAPI1",100,0)
 S DESC=$P($G(^HLEV(776,+$G(HLEVIENE),0)),U,3) QUIT:DESC']""  ;->
"RTN","HLEVAPI1",101,0)
 ; First line...
"RTN","HLEVAPI1",102,0)
 D ADD("Monitor description: "_DESC)
"RTN","HLEVAPI1",103,0)
 D ADD("")
"RTN","HLEVAPI1",104,0)
 Q
"RTN","HLEVAPI1",105,0)
 ;
"RTN","HLEVAPI1",106,0)
LOADCOMP(HLEVIENJ,SVSUB) ; Load generic event monitor info into XMTEXT...
"RTN","HLEVAPI1",107,0)
 N HLEVIENE,HLEVNM
"RTN","HLEVAPI1",108,0)
 S SVSUB=$S($G(SVSUB)]"":SVSUB,1:"HLMAILMSG")
"RTN","HLEVAPI1",109,0)
 S HLEVIENE=$P($G(^HLEV(776,+HLEVIENJ,0)),U,3)
"RTN","HLEVAPI1",110,0)
 S HLEVNM=$P($G(^HLEV(776.1,+HLEVIENE,0)),U)
"RTN","HLEVAPI1",111,0)
 ; First line...
"RTN","HLEVAPI1",112,0)
 D ADD("The '"_HLEVNM_"' event monitor has completed.")
"RTN","HLEVAPI1",113,0)
 D ADD("")
"RTN","HLEVAPI1",114,0)
 Q
"RTN","HLEVAPI1",115,0)
 ;
"RTN","HLEVAPI1",116,0)
LOADVAR(HLEVIENJ,SVSUB) ; Load variable names...
"RTN","HLEVAPI1",117,0)
 N CUT,MIEN,TXT,VAR
"RTN","HLEVAPI1",118,0)
 ;
"RTN","HLEVAPI1",119,0)
 QUIT:$O(^HLEV(776,+HLEVIENJ,52,0))'>0  ;->
"RTN","HLEVAPI1",120,0)
 ;
"RTN","HLEVAPI1",121,0)
 D ADD(""),ADD("Variable List"),ADD("-------------")
"RTN","HLEVAPI1",122,0)
 ;
"RTN","HLEVAPI1",123,0)
 S VAR=""
"RTN","HLEVAPI1",124,0)
 F  S VAR=$O(^HLEV(776,+HLEVIENJ,52,"B",VAR)) Q:VAR']""  D
"RTN","HLEVAPI1",125,0)
 .  S MIEN=0
"RTN","HLEVAPI1",126,0)
 .  F  S MIEN=$O(^HLEV(776,+HLEVIENJ,52,"B",VAR,MIEN)) Q:MIEN'>0  D
"RTN","HLEVAPI1",127,0)
 .  .  S TXT=$G(^HLEV(776,+HLEVIENJ,52,+MIEN,0)) QUIT:TXT']""  ;->
"RTN","HLEVAPI1",128,0)
 .  .  S TXT=$P(TXT,U)_$S($P(TXT,U,2)]"":"["_$P(TXT,U,2)_"]",1:"")_"="
"RTN","HLEVAPI1",129,0)
 .  .  S TXT(1)=$G(^HLEV(776,+HLEVIENJ,52,+MIEN,52))
"RTN","HLEVAPI1",130,0)
 .  .  I ($L(TXT)+$L(TXT(1)))<240 S TXT=TXT_TXT(1),TXT(1)=""
"RTN","HLEVAPI1",131,0)
 .  .  I TXT(1)]"" D
"RTN","HLEVAPI1",132,0)
 .  .  .  S CUT(1)=$L(TXT),CUT(2)=$L(TXT(1)),CUT=240-CUT(1)
"RTN","HLEVAPI1",133,0)
 .  .  .  S TXT=TXT_$E(TXT(1),1,CUT),TXT(1)=$E(TXT(1),CUT+1,999)
"RTN","HLEVAPI1",134,0)
 .  .  F  D  QUIT:TXT']""
"RTN","HLEVAPI1",135,0)
 .  .  .  D ADD($E(TXT,1,74))
"RTN","HLEVAPI1",136,0)
 .  .  .  S TXT=$E(TXT,75,999) QUIT:TXT']""  ;->
"RTN","HLEVAPI1",137,0)
 .  .  .  S TXT="   "_TXT
"RTN","HLEVAPI1",138,0)
 .  .  .  QUIT:TXT(1)']""  ;->
"RTN","HLEVAPI1",139,0)
 .  .  .  
"RTN","HLEVAPI1",140,0)
 ;
"RTN","HLEVAPI1",141,0)
 Q
"RTN","HLEVAPI1",142,0)
 ;
"RTN","HLEVAPI1",143,0)
ADD(TXT) ; Add TXT to global to be mailed out...
"RTN","HLEVAPI1",144,0)
 ; SVSUB -- req
"RTN","HLEVAPI1",145,0)
 N NO
"RTN","HLEVAPI1",146,0)
 S NO=$O(^TMP($J,SVSUB,":"),-1)+1
"RTN","HLEVAPI1",147,0)
 S ^TMP($J,SVSUB,+NO)=TXT
"RTN","HLEVAPI1",148,0)
 Q
"RTN","HLEVAPI1",149,0)
 ;
"RTN","HLEVAPI1",150,0)
CURR(IEN776) ; Is job running and current?
"RTN","HLEVAPI1",151,0)
 N DATA,DIFF,STAT,TSTAMP
"RTN","HLEVAPI1",152,0)
 S DATA=$G(^HLEV(776,+IEN776,0))
"RTN","HLEVAPI1",153,0)
 S STAT=$P(DATA,U,4) QUIT:STAT'="R" "" ;->
"RTN","HLEVAPI1",154,0)
 S TSTAMP=$P(DATA,U,6) QUIT:TSTAMP'?7N1"."1.N "" ;->
"RTN","HLEVAPI1",155,0)
 S TSTAMP=$$FMTH^XLFDT(TSTAMP)
"RTN","HLEVAPI1",156,0)
 S DIFF=$$DIFFDH^HLCSFMN1(TSTAMP,$H) ; Difference...
"RTN","HLEVAPI1",157,0)
 I DIFF'?1.N1"^"2N1":"2N1":"2N QUIT "" ;-> DD^HH:MM:SS
"RTN","HLEVAPI1",158,0)
 I +DIFF>0 QUIT "" ;-> 1 or more days difference!
"RTN","HLEVAPI1",159,0)
 S DIFF=$P(DIFF,U,2) ; HH:MM:SS now...
"RTN","HLEVAPI1",160,0)
 ; If 1 or more hrs, or >15 minutes old...
"RTN","HLEVAPI1",161,0)
 I +DIFF!(+$P(DIFF,":",2)>15) QUIT "" ;->
"RTN","HLEVAPI1",162,0)
 Q 1
"RTN","HLEVAPI1",163,0)
 ;
"RTN","HLEVAPI1",164,0)
APPSTAT(STATUS) ; Fill in application status...
"RTN","HLEVAPI1",165,0)
 ; HLEVIENJ -- req
"RTN","HLEVAPI1",166,0)
 N DA,DIE,DR
"RTN","HLEVAPI1",167,0)
 ;
"RTN","HLEVAPI1",168,0)
 D DEBUG^HLEVAPI2("VARIABLE") ; Debug data created conditionally
"RTN","HLEVAPI1",169,0)
 ;
"RTN","HLEVAPI1",170,0)
 ; Stop all event monitoring to enable on-site debugging...
"RTN","HLEVAPI1",171,0)
 QUIT:$G(^TMP("HLEVFLAG",$J))["STOP"  ;->
"RTN","HLEVAPI1",172,0)
 ;
"RTN","HLEVAPI1",173,0)
 QUIT:$G(STATUS)']""  ;->
"RTN","HLEVAPI1",174,0)
 QUIT:$G(^HLEV(776,+$G(HLEVIENJ),0))']""  ;->
"RTN","HLEVAPI1",175,0)
 S DA=+HLEVIENJ,DIE=776,DR="5///"_$E(STATUS,1,10)
"RTN","HLEVAPI1",176,0)
 D ^DIE
"RTN","HLEVAPI1",177,0)
 Q
"RTN","HLEVAPI1",178,0)
 ;
"RTN","HLEVAPI1",179,0)
RUNDIARY(GBL) ; Move GBL data into RUN DIARY...
"RTN","HLEVAPI1",180,0)
 ; HLEVIENJ -- req
"RTN","HLEVAPI1",181,0)
 ;
"RTN","HLEVAPI1",182,0)
 D DEBUG^HLEVAPI2("VARIABLE") ; Debug data created conditionally
"RTN","HLEVAPI1",183,0)
 ;
"RTN","HLEVAPI1",184,0)
 ; Stop all event monitoring to enable on-site debugging...
"RTN","HLEVAPI1",185,0)
 QUIT:$G(^TMP("HLEVFLAG",$J))["STOP"  ;->
"RTN","HLEVAPI1",186,0)
 ;
"RTN","HLEVAPI1",187,0)
 D GBLMOVE(+$G(HLEVIENJ),50,$G(GBL))
"RTN","HLEVAPI1",188,0)
 Q
"RTN","HLEVAPI1",189,0)
 ;
"RTN","HLEVAPI1",190,0)
MSGTEXT(GBL) ; Mark event job entry to NOTIFY MAIL GROUP...
"RTN","HLEVAPI1",191,0)
 ; HLEVIENJ -- req
"RTN","HLEVAPI1",192,0)
 ;
"RTN","HLEVAPI1",193,0)
 D DEBUG^HLEVAPI2("VARIABLE") ; Debug data created conditionally
"RTN","HLEVAPI1",194,0)
 ;
"RTN","HLEVAPI1",195,0)
 ; Stop all event monitoring to enable on-site debugging...
"RTN","HLEVAPI1",196,0)
 QUIT:$G(^TMP("HLEVFLAG",$J))["STOP"  ;->
"RTN","HLEVAPI1",197,0)
 ;
"RTN","HLEVAPI1",198,0)
 D GBLMOVE(+$G(HLEVIENJ),51,$G(GBL))
"RTN","HLEVAPI1",199,0)
 Q
"RTN","HLEVAPI1",200,0)
 ;
"RTN","HLEVAPI1",201,0)
GBLMOVE(HLEVIENJ,SUB,GBL) ; Move GBL data into entry's WP text...
"RTN","HLEVAPI1",202,0)
 N CT,NO,NODE
"RTN","HLEVAPI1",203,0)
 ;
"RTN","HLEVAPI1",204,0)
 S SUB=$G(SUB) QUIT:SUB'=51&(SUB'=52)  ;->
"RTN","HLEVAPI1",205,0)
 QUIT:$G(^HLEV(776,+HLEVIENJ,0))']""  ;->
"RTN","HLEVAPI1",206,0)
 ;
"RTN","HLEVAPI1",207,0)
 ; Add event text...
"RTN","HLEVAPI1",208,0)
 S NODE="^776.002",NO=0
"RTN","HLEVAPI1",209,0)
 F  S NO=$O(@GBL@(NO)) Q:NO'>0  D
"RTN","HLEVAPI1",210,0)
 .  S CT=$O(^HLEV(776,+HLEVIENJ,SUB,":"),-1)+1
"RTN","HLEVAPI1",211,0)
 .  S ^HLEV(776,+HLEVIENJ,SUB,CT,0)=$G(@GBL@(+NO))
"RTN","HLEVAPI1",212,0)
 S CT=$O(^HLEV(776,+HLEVIENJ,SUB,":"),-1) QUIT:CT'>0  ;->
"RTN","HLEVAPI1",213,0)
 S $P(NODE,U,3)=CT,$P(NODE,U,4)=CT
"RTN","HLEVAPI1",214,0)
 S ^HLEV(776,+HLEVIENJ,SUB,0)=NODE
"RTN","HLEVAPI1",215,0)
 ;
"RTN","HLEVAPI1",216,0)
 Q
"RTN","HLEVAPI1",217,0)
 ;
"RTN","HLEVAPI1",218,0)
ONETIME ;Start a one-time run of event monitor (w/no master job)
"RTN","HLEVAPI1",219,0)
 N HLEVIENE,QTASK
"RTN","HLEVAPI1",220,0)
 W @IOF,$$CJ^XLFSTR("One-time Queueing of Event Monitor",IOM)
"RTN","HLEVAPI1",221,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVAPI1",222,0)
 W !,"Normally, the master job evaluates every event monitor and queues a background"
"RTN","HLEVAPI1",223,0)
 W !,"job for those events ready for a new ""run.""  This option allows the running"
"RTN","HLEVAPI1",224,0)
 W !,"of an event monitor between ""normal"" runs."
"RTN","HLEVAPI1",225,0)
 W !!,"Do you want to start a new ""in-between"" run of a monitor?  If so, select"
"RTN","HLEVAPI1",226,0)
 W !,"it now.  If not, press RETURN to exit..."
"RTN","HLEVAPI1",227,0)
 W !
"RTN","HLEVAPI1",228,0)
 ;
"RTN","HLEVAPI1",229,0)
 S HLEVIENE=$$ASKIEN^HLEVREP(776.1) I HLEVIENE'>0 D  QUIT  ;->
"RTN","HLEVAPI1",230,0)
 .  W "   exiting..."
"RTN","HLEVAPI1",231,0)
 ;
"RTN","HLEVAPI1",232,0)
 W !
"RTN","HLEVAPI1",233,0)
 D ASKRUN(HLEVIENE)
"RTN","HLEVAPI1",234,0)
 ;
"RTN","HLEVAPI1",235,0)
 Q
"RTN","HLEVAPI1",236,0)
 ;
"RTN","HLEVAPI1",237,0)
ASKRUN(HLEVIENE) ; Ask if want to run a one-time...
"RTN","HLEVAPI1",238,0)
 N DATA,QTASK,QTIME
"RTN","HLEVAPI1",239,0)
 ;
"RTN","HLEVAPI1",240,0)
 I $P($G(^HLEV(776.1,+$G(HLEVIENE),0)),U,2)'="A" D  QUIT  ;->
"RTN","HLEVAPI1",241,0)
 .  QUIT:$G(^HLEV(776.1,+$G(HLEVIENE),0))']""  ;->
"RTN","HLEVAPI1",242,0)
 .  D TELL^HLEVMST0("Event monitor is INACTIVE!!","1,2,999")
"RTN","HLEVAPI1",243,0)
 ;
"RTN","HLEVAPI1",244,0)
 I $$YN^HLCSRPT4("Run monitor now","No") D  QUIT  ;->
"RTN","HLEVAPI1",245,0)
 .  D QIT($$NOW^XLFDT) W "   exiting..."
"RTN","HLEVAPI1",246,0)
 ;
"RTN","HLEVAPI1",247,0)
 W !!,"You may queue this monitor to run ""one-time"" in the future.  If so, enter a"
"RTN","HLEVAPI1",248,0)
 W !,"future date/time now..."
"RTN","HLEVAPI1",249,0)
 W !
"RTN","HLEVAPI1",250,0)
 ;
"RTN","HLEVAPI1",251,0)
 F  S QTIME=$$ASKDATE^HLEVAPI2("Enter future run time") D  QUIT:QTIME?7N1"."1.N!(QTIME']"")
"RTN","HLEVAPI1",252,0)
 .  QUIT:QTIME'?7N1"."1.N  ;->
"RTN","HLEVAPI1",253,0)
 .  I QTIME>$$NOW^XLFDT D QIT(QTIME) QUIT  ;->
"RTN","HLEVAPI1",254,0)
 .  S QTIME="REASK"
"RTN","HLEVAPI1",255,0)
 .  W "  enter a future time..."
"RTN","HLEVAPI1",256,0)
 ;
"RTN","HLEVAPI1",257,0)
 Q
"RTN","HLEVAPI1",258,0)
 ;
"RTN","HLEVAPI1",259,0)
QIT(QTIME) ; Queue it...
"RTN","HLEVAPI1",260,0)
 N QTASK
"RTN","HLEVAPI1",261,0)
 S QTASK=$$Q1TIME^HLEVAPI0(+HLEVIENE,0,QTIME)
"RTN","HLEVAPI1",262,0)
 I +QTASK>0 W !!,"   Queued task# ",+QTASK," [#",$P(QTASK,U,2),"]..."
"RTN","HLEVAPI1",263,0)
 I +QTASK'>0 W !!,"   Error occurred.  No monitor ""run"" started..."
"RTN","HLEVAPI1",264,0)
 W !
"RTN","HLEVAPI1",265,0)
 F  Q:($Y+3)>IOSL  W !
"RTN","HLEVAPI1",266,0)
 S X=$$BTE^HLCSMON("Press RETURN to exit... ")
"RTN","HLEVAPI1",267,0)
 Q
"RTN","HLEVAPI1",268,0)
 ;
"RTN","HLEVAPI1",269,0)
EOR ;HLEVAPI1 - Event Monitor APIs ;5/16/03 14:42
"RTN","HLEVAPI2")
0^20^B65545587
"RTN","HLEVAPI2",1,0)
HLEVAPI2 ;O-OIFO/LJA - Event Monitor APIs ;02/04/2004 14:42
"RTN","HLEVAPI2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVAPI2",3,0)
 ;
"RTN","HLEVAPI2",4,0)
VARLIST(HLEVIENJ,SUB) ; Return event variable information in ^TMP($J,SUB)...
"RTN","HLEVAPI2",5,0)
 N CT,DATA,EXP,MIEN,VAL,VAR
"RTN","HLEVAPI2",6,0)
 ;
"RTN","HLEVAPI2",7,0)
 QUIT:$G(^HLEV(776,+$G(HLEVIENJ),0))']"" "" ;->
"RTN","HLEVAPI2",8,0)
 ;
"RTN","HLEVAPI2",9,0)
 S MIEN=0,CT=""
"RTN","HLEVAPI2",10,0)
 F  S MIEN=$O(^HLEV(776,HLEVIENJ,52,MIEN)) Q:MIEN'>0  D
"RTN","HLEVAPI2",11,0)
 .  S CT=CT+1
"RTN","HLEVAPI2",12,0)
 .  S DATA=$G(^HLEV(776,+HLEVIENJ,52,+MIEN,0))
"RTN","HLEVAPI2",13,0)
 .  S VAR=$P(DATA,U),EXP=$P(DATA,U,2)
"RTN","HLEVAPI2",14,0)
 .  S VAL=$G(^HLEV(776,+HLEVIENJ,52,+MIEN,52))
"RTN","HLEVAPI2",15,0)
 .  S ^TMP($J,SUB,VAR,"V")=VAL
"RTN","HLEVAPI2",16,0)
 .  I EXP]"" S ^TMP($J,SUB,VAR,"E")=EXP
"RTN","HLEVAPI2",17,0)
 ;
"RTN","HLEVAPI2",18,0)
 Q CT
"RTN","HLEVAPI2",19,0)
 ;
"RTN","HLEVAPI2",20,0)
PREVENT(HLEVIENE,SUB,STATUS) ; Return <PR>evious <event> runs in ^TMP($J,SUB)
"RTN","HLEVAPI2",21,0)
 N CT,DATA,IEN
"RTN","HLEVAPI2",22,0)
 ;
"RTN","HLEVAPI2",23,0)
 S HLEVIENE=$G(HLEVIENE) QUIT:HLEVIENE']"" "" ;->
"RTN","HLEVAPI2",24,0)
 QUIT:$G(SUB)']"" "" ;->
"RTN","HLEVAPI2",25,0)
 ;
"RTN","HLEVAPI2",26,0)
 S STATUS=$$UP^XLFSTR($E($G(STATUS)))
"RTN","HLEVAPI2",27,0)
 ;
"RTN","HLEVAPI2",28,0)
 ; Maybe passed in the event name...
"RTN","HLEVAPI2",29,0)
 I HLEVIENE'=+HLEVIENE D  QUIT:HLEVIENE'>0 "" ;->
"RTN","HLEVAPI2",30,0)
 .  S HLEVIENE=$O(^HLEV(776.1,"B",HLEVIENE,0))
"RTN","HLEVAPI2",31,0)
 ;
"RTN","HLEVAPI2",32,0)
 ; Loop thru entries...
"RTN","HLEVAPI2",33,0)
 S IEN=0,CT=0
"RTN","HLEVAPI2",34,0)
 F  S IEN=$O(^HLEV(776,"M",+HLEVIENE,IEN)) Q:IEN'>0  D
"RTN","HLEVAPI2",35,0)
 .  S DATA=$G(^HLEV(776,+IEN,0)) QUIT:DATA']""  ;->
"RTN","HLEVAPI2",36,0)
 .  I STATUS]"",$P(DATA,U,4)'=STATUS QUIT  ;->
"RTN","HLEVAPI2",37,0)
 .  S CT=CT+1
"RTN","HLEVAPI2",38,0)
 .  S X=$P(DATA,U,4),STATUS(1)=$S(X]"":X,1:"?")
"RTN","HLEVAPI2",39,0)
 .  S ^TMP($J,SUB,"D",IEN)=DATA
"RTN","HLEVAPI2",40,0)
 .  S ^TMP($J,SUB,"S",STATUS(1),IEN)=""
"RTN","HLEVAPI2",41,0)
 ;
"RTN","HLEVAPI2",42,0)
 Q CT
"RTN","HLEVAPI2",43,0)
 ;
"RTN","HLEVAPI2",44,0)
EVCHKD(HLEVIENM,HLEVIENE,HLEVIENJ,STATUS) ; Event code finished.  Mark event check multiple in 776.2 done...
"RTN","HLEVAPI2",45,0)
 ; ZTSK -- req
"RTN","HLEVAPI2",46,0)
 N DATA,MIEN
"RTN","HLEVAPI2",47,0)
 ;
"RTN","HLEVAPI2",48,0)
 QUIT:HLEVIENM=9999999  ;-> No master job...
"RTN","HLEVAPI2",49,0)
 ; Not usually passed.  But, passed by ABORT^HLEVAPI...
"RTN","HLEVAPI2",50,0)
 S STATUS=$S($G(STATUS)]"":$E(STATUS),1:"F")
"RTN","HLEVAPI2",51,0)
 ;
"RTN","HLEVAPI2",52,0)
 S MIEN=$O(^HLEV(776.2,+$G(HLEVIENM),51,"B",+$G(HLEVIENE),":"),-1) QUIT:MIEN'>0  ;->
"RTN","HLEVAPI2",53,0)
 S DATA=$G(^HLEV(776.2,+HLEVIENM,51,+MIEN,0)) QUIT:$P(DATA,U,4)'=$G(ZTSK)  ;->
"RTN","HLEVAPI2",54,0)
 S $P(DATA,U,5)=STATUS,$P(DATA,U,6)=$$NOW^XLFDT,$P(DATA,U,8)=$G(HLEVIENJ)
"RTN","HLEVAPI2",55,0)
 S ^HLEV(776.2,+HLEVIENM,51,+MIEN,0)=DATA
"RTN","HLEVAPI2",56,0)
 Q
"RTN","HLEVAPI2",57,0)
 ;
"RTN","HLEVAPI2",58,0)
ADDXMYS(HLEVIENE,XTMP) ; Set up XMY()s...
"RTN","HLEVAPI2",59,0)
 N DATA,MIEN,MONM,NODE,RECIP
"RTN","HLEVAPI2",60,0)
 ;
"RTN","HLEVAPI2",61,0)
 ; Any recipients built into monitor?
"RTN","HLEVAPI2",62,0)
 F NODE=60,61,62 D
"RTN","HLEVAPI2",63,0)
 .  S MIEN=0
"RTN","HLEVAPI2",64,0)
 .  F  S MIEN=$O(^HLEV(776.1,+HLEVIENE,+NODE,MIEN)) Q:MIEN'>0  D
"RTN","HLEVAPI2",65,0)
 .  .  S DATA=$P($G(^HLEV(776.1,+HLEVIENE,+NODE,+MIEN,0)),U) QUIT:DATA']""  ;->
"RTN","HLEVAPI2",66,0)
 .  .  I NODE=60 S DATA=$P($G(^XMB(3.8,+DATA,0)),U),DATA=$S(DATA]"":"G."_DATA,1:"") QUIT:DATA']""  ;->
"RTN","HLEVAPI2",67,0)
 .  .  S XMY(DATA)=""
"RTN","HLEVAPI2",68,0)
 ;
"RTN","HLEVAPI2",69,0)
 ; Any recipients passed in in data request?
"RTN","HLEVAPI2",70,0)
 QUIT:$G(XTMP)']""  ;->
"RTN","HLEVAPI2",71,0)
 S MONM=$P($G(^HLEV(776.1,+HLEVIENE,0)),U) QUIT:MONM']""  ;->
"RTN","HLEVAPI2",72,0)
 S RECIP=""
"RTN","HLEVAPI2",73,0)
 F  S RECIP=$O(^XTMP(XTMP,"MONREQ","MON",+HLEVIENE,RECIP)) Q:RECIP']""  D
"RTN","HLEVAPI2",74,0)
 .  S XMY(RECIP)=""
"RTN","HLEVAPI2",75,0)
 ;
"RTN","HLEVAPI2",76,0)
 Q
"RTN","HLEVAPI2",77,0)
 ;
"RTN","HLEVAPI2",78,0)
MGRP(HLEVIENE) ; Return G.MAIL-GROUP...
"RTN","HLEVAPI2",79,0)
 N MGRP
"RTN","HLEVAPI2",80,0)
 S MGRP=$P($G(^HLEV(776.1,+$G(HLEVIENE),0)),U,5)
"RTN","HLEVAPI2",81,0)
 S MGRP=$P($G(^XMB(3.8,+MGRP,0)),U) QUIT:MGRP']"" "" ;->
"RTN","HLEVAPI2",82,0)
 Q "G."_MGRP
"RTN","HLEVAPI2",83,0)
 ;
"RTN","HLEVAPI2",84,0)
LOADBODY(HLEVIENJ,SVSUB) ; Load body into global to mail...
"RTN","HLEVAPI2",85,0)
 N END,NODE,P1,P2,P3,P4,P5,P6,P7,PCE,START,TXT
"RTN","HLEVAPI2",86,0)
 ;
"RTN","HLEVAPI2",87,0)
 S SVSUB=$S($G(SVSUB)]"":SVSUB,1:"HLMAILMSG")
"RTN","HLEVAPI2",88,0)
 ;
"RTN","HLEVAPI2",89,0)
 S NODE=$G(^HLEV(776,+HLEVIENJ,0))
"RTN","HLEVAPI2",90,0)
 F PCE=1:1:7 S @("P"_PCE)=$P(NODE,U,PCE)
"RTN","HLEVAPI2",91,0)
 ;
"RTN","HLEVAPI2",92,0)
 ; START - END
"RTN","HLEVAPI2",93,0)
 S START=$$FMTE^XLFDT(P1),END=$$FMTE^XLFDT(P2)
"RTN","HLEVAPI2",94,0)
 S TXT(1)=$E("Start time: "_START_$$REPEAT^XLFSTR(" ",40),1,34)_"  "
"RTN","HLEVAPI2",95,0)
 S TXT(2)="End time: "_END
"RTN","HLEVAPI2",96,0)
 D ADD^HLEVAPI1(TXT(1)_TXT(2))
"RTN","HLEVAPI2",97,0)
 ;
"RTN","HLEVAPI2",98,0)
 ; STATUS-RUN - STATUS-APPL
"RTN","HLEVAPI2",99,0)
 S P4=$S(P4="E":"ERROR",P4="F":"FINISHED",P4="Q":"QUEUED (NOT RUNNING YE T)",1:"??")
"RTN","HLEVAPI2",100,0)
 S TXT(1)=$E("Status: "_P4_$$REPEAT^XLFSTR(" ",40),1,34)_"  "
"RTN","HLEVAPI2",101,0)
 S TXT(2)=$S(P5]"":"Status-Appl: "_P5,1:"")
"RTN","HLEVAPI2",102,0)
 D ADD^HLEVAPI1(TXT(1)_TXT(2))
"RTN","HLEVAPI2",103,0)
 ;
"RTN","HLEVAPI2",104,0)
 Q
"RTN","HLEVAPI2",105,0)
 ;
"RTN","HLEVAPI2",106,0)
LOADDGBL(HLEVIENJ,SUBDD,SVSUB) ; Load event text into global to mail...
"RTN","HLEVAPI2",107,0)
 N HDR,MIEN
"RTN","HLEVAPI2",108,0)
 S HDR=$S(SUBDD=50:"Run Diary",SUBDD=51:"Additional Text",1:"")
"RTN","HLEVAPI2",109,0)
 S SVSUB=$S($G(SVSUB)]"":SVSUB,1:"HLMAILMSG")
"RTN","HLEVAPI2",110,0)
 I $O(^HLEV(776,+HLEVIENJ,SUBDD,0))>0 D
"RTN","HLEVAPI2",111,0)
 .  D ADD^HLEVAPI1("") ; Always add a blank line...
"RTN","HLEVAPI2",112,0)
 .  I HDR]"" D ADD^HLEVAPI1(HDR),ADD^HLEVAPI1($$REPEAT^XLFSTR("-",$L(HDR)))
"RTN","HLEVAPI2",113,0)
 S MIEN=0
"RTN","HLEVAPI2",114,0)
 F  S MIEN=$O(^HLEV(776,+HLEVIENJ,SUBDD,MIEN)) Q:'MIEN  D
"RTN","HLEVAPI2",115,0)
 .  D ADD^HLEVAPI1($G(^HLEV(776,+HLEVIENJ,SUBDD,+MIEN,0)))
"RTN","HLEVAPI2",116,0)
 Q
"RTN","HLEVAPI2",117,0)
 ;
"RTN","HLEVAPI2",118,0)
DEBUGSET ; Set debugging on/off for a tag...
"RTN","HLEVAPI2",119,0)
 N CUT,TAG
"RTN","HLEVAPI2",120,0)
DSET1 ;
"RTN","HLEVAPI2",121,0)
 I $O(^XTMP("HLEV DEBUG",0))']"" D
"RTN","HLEVAPI2",122,0)
 .  KILL ^XTMP("HLEV DEBUG")
"RTN","HLEVAPI2",123,0)
 ;
"RTN","HLEVAPI2",124,0)
 I $O(^XTMP("HLEV DEBUG",""))]"" D
"RTN","HLEVAPI2",125,0)
 .  W !!,"Current debug sets..."
"RTN","HLEVAPI2",126,0)
 .  W !
"RTN","HLEVAPI2",127,0)
 .  S TAG=0
"RTN","HLEVAPI2",128,0)
 .  F  S TAG=$O(^XTMP("HLEV DEBUG",TAG)) Q:TAG']""  D
"RTN","HLEVAPI2",129,0)
 .  .  S CUT=$G(^XTMP("HLEV DEBUG",TAG)) QUIT:CUT']""  ;->
"RTN","HLEVAPI2",130,0)
 .  .  W !,TAG,?20,CUT,"..."
"RTN","HLEVAPI2",131,0)
 ;
"RTN","HLEVAPI2",132,0)
 R !!,"Tag: ",TAG:99 Q:TAG']""  ;->
"RTN","HLEVAPI2",133,0)
 S CUT=$G(^XTMP("HLEV DEBUG",TAG))
"RTN","HLEVAPI2",134,0)
 I CUT]"" W "    ... set to ",CUT," ..."
"RTN","HLEVAPI2",135,0)
 R !,"Cutoff time (FM): ",CUT:99
"RTN","HLEVAPI2",136,0)
 ;
"RTN","HLEVAPI2",137,0)
 I CUT="@" D
"RTN","HLEVAPI2",138,0)
 .  KILL ^XTMP("HLEV DEBUG",TAG)
"RTN","HLEVAPI2",139,0)
 .  W "  removing data..."
"RTN","HLEVAPI2",140,0)
 .  I $O(^XTMP("HLEV DEBUG",0))']"" KILL ^XTMP("HLEV DEBUG")
"RTN","HLEVAPI2",141,0)
 ;
"RTN","HLEVAPI2",142,0)
 I CUT?7N1"."1.N D DSET2(TAG,CUT) W "  setting cutoff time..."
"RTN","HLEVAPI2",143,0)
 ;
"RTN","HLEVAPI2",144,0)
 G DSET1 ;->
"RTN","HLEVAPI2",145,0)
 ;
"RTN","HLEVAPI2",146,0)
DSET2(TAG,CUT) ;
"RTN","HLEVAPI2",147,0)
 S ^XTMP("HLEV DEBUG",0)=$$FMADD^XLFDT($$NOW^XLFDT,0,1)_U_$$NOW^XLFDT_U_"HL7 event monitor debug data"
"RTN","HLEVAPI2",148,0)
 S ^XTMP("HLEV DEBUG",TAG)=CUT ; Cutoff time after which not to store...
"RTN","HLEVAPI2",149,0)
 Q
"RTN","HLEVAPI2",150,0)
 ;
"RTN","HLEVAPI2",151,0)
DEBUG(TAG,TMPSUB) ; Conditionally store ^XTMP debug data...
"RTN","HLEVAPI2",152,0)
 ; Pass-by-reference references to save by merging...
"RTN","HLEVAPI2",153,0)
 ; TMPSUB(SAVESUB)=REFERENCE 
"RTN","HLEVAPI2",154,0)
 ; (E.g., TMPSUB("HLEVREP")=$NA(^TMP($J,"HLEVREP")))
"RTN","HLEVAPI2",155,0)
 N DATE,NO,SUB,REF,X
"RTN","HLEVAPI2",156,0)
 ;
"RTN","HLEVAPI2",157,0)
 ; Is debugging enabled?
"RTN","HLEVAPI2",158,0)
 S DATE=$G(^XTMP("HLEV DEBUG",TAG)) QUIT:DATE<$$NOW^XLFDT  ;->
"RTN","HLEVAPI2",159,0)
 ;
"RTN","HLEVAPI2",160,0)
 ; There must be a task number...
"RTN","HLEVAPI2",161,0)
 I $G(ZTSK)'>0 N ZTSK S ZTSK=9999999
"RTN","HLEVAPI2",162,0)
 ;
"RTN","HLEVAPI2",163,0)
 ; Save data...
"RTN","HLEVAPI2",164,0)
 S NO=$O(^XTMP("HLEV DEBUG",TAG,ZTSK,":"),-1)+1
"RTN","HLEVAPI2",165,0)
 S ^XTMP("HLEV DEBUG",TAG,ZTSK,+NO)=$$NOW^XLFDT
"RTN","HLEVAPI2",166,0)
 S X="^XTMP(""HLEV DEBUG"","""_TAG_""","_ZTSK_","_NO_"," D DOLRO^%ZOSV
"RTN","HLEVAPI2",167,0)
 ;
"RTN","HLEVAPI2",168,0)
 ; Save reference data by merging...
"RTN","HLEVAPI2",169,0)
 S SUB=""
"RTN","HLEVAPI2",170,0)
 F  S SUB=$O(TMPSUB(SUB)) Q:SUB']""  D
"RTN","HLEVAPI2",171,0)
 .  S REF=TMPSUB(SUB) QUIT:REF']""  ;->
"RTN","HLEVAPI2",172,0)
 .  MERGE ^XTMP("HLEV DEBUG",TAG,ZTSK,NO,SUB)=@REF
"RTN","HLEVAPI2",173,0)
 ;
"RTN","HLEVAPI2",174,0)
 ; Remove all but last 20 entries for TAG...
"RTN","HLEVAPI2",175,0)
 F NO(1)=NO-20:-1:1 KILL ^XTMP("HLEV DEBUG",TAG,ZTSK,NO(1))
"RTN","HLEVAPI2",176,0)
 ;
"RTN","HLEVAPI2",177,0)
 Q
"RTN","HLEVAPI2",178,0)
 ;
"RTN","HLEVAPI2",179,0)
ASKDATE(DATEPMT,PARM,DEFAULT) ; Select date...
"RTN","HLEVAPI2",180,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLEVAPI2",181,0)
 S DIR(0)="DO^::"_$S($G(PARM):PARM,1:"EXT")
"RTN","HLEVAPI2",182,0)
 S DIR("A")=$S($G(DATEPMT)]"":DATEPMT,1:"Select DATE")
"RTN","HLEVAPI2",183,0)
 I $G(DEFAULT)]"" S DIR("B")=DEFAULT
"RTN","HLEVAPI2",184,0)
 D ^DIR
"RTN","HLEVAPI2",185,0)
 I $G(PARM)]"",PARM'["T" QUIT:+Y?7N +Y ;->
"RTN","HLEVAPI2",186,0)
 I +Y?7N1"."1.N Q +Y
"RTN","HLEVAPI2",187,0)
 Q ""
"RTN","HLEVAPI2",188,0)
 ;
"RTN","HLEVAPI2",189,0)
LOG(ETYPE,STORE) ; Log event type, record variables, create index...
"RTN","HLEVAPI2",190,0)
 ;
"RTN","HLEVAPI2",191,0)
 ; STORE = variables to store, separated by up-arrows.  (At the time
"RTN","HLEVAPI2",192,0)
 ;         of call to LOG, the value of the variables must be set to
"RTN","HLEVAPI2",193,0)
 ;         the value to be stored!)
"RTN","HLEVAPI2",194,0)
 ;
"RTN","HLEVAPI2",195,0)
 ; Returns:  Piece 1  --  0 -> No new log entry made
"RTN","HLEVAPI2",196,0)
 ;                        1 -> New log entry made
"RTN","HLEVAPI2",197,0)
 ;           Piece 2  --  776.4 IEN
"RTN","HLEVAPI2",198,0)
 ;
"RTN","HLEVAPI2",199,0)
 N IEN1,IEN2,LIEN,LIST,LOG,PCE,VAR,X,XRF
"RTN","HLEVAPI2",200,0)
 ;
"RTN","HLEVAPI2",201,0)
 ; Quit if no event type passed.  (Event type always used for APPNAME)
"RTN","HLEVAPI2",202,0)
 QUIT:$G(ETYPE)']"" "" ;->
"RTN","HLEVAPI2",203,0)
 ;
"RTN","HLEVAPI2",204,0)
 ; Defaults...
"RTN","HLEVAPI2",205,0)
 S LOG="",STORE=$G(STORE)
"RTN","HLEVAPI2",206,0)
 ;
"RTN","HLEVAPI2",207,0)
 ; Extract out the variables used for index (and stored below)...
"RTN","HLEVAPI2",208,0)
 F PCE=1:1:$L($G(STORE),U) D
"RTN","HLEVAPI2",209,0)
 .  S VAR=$P(STORE,U,+PCE) QUIT:VAR']""!('($D(@VAR)#2))  ;->
"RTN","HLEVAPI2",210,0)
 .  S LIST(PCE)=@VAR
"RTN","HLEVAPI2",211,0)
 ;
"RTN","HLEVAPI2",212,0)
 ; Quit if this problem has already been logged?
"RTN","HLEVAPI2",213,0)
 I STORE]"" D  QUIT:+LOG=1 "^"_$P(LOG,U,2) ;->
"RTN","HLEVAPI2",214,0)
 .  S LOG=$$LOGGED^HLEME1(ETYPE,.LIST)
"RTN","HLEVAPI2",215,0)
 ;
"RTN","HLEVAPI2",216,0)
 ; Make a log entry...
"RTN","HLEVAPI2",217,0)
 S LIEN=$$EVENT^HLEME(ETYPE,"HEALTH LEVEL SEVEN") QUIT:'LIEN "" ;->
"RTN","HLEVAPI2",218,0)
 ;
"RTN","HLEVAPI2",219,0)
 ; Store event in log, log in event, and create xref...
"RTN","HLEVAPI2",220,0)
 I $G(HLEVIENJ) D
"RTN","HLEVAPI2",221,0)
 .
"RTN","HLEVAPI2",222,0)
 .  N LIST
"RTN","HLEVAPI2",223,0)
 .
"RTN","HLEVAPI2",224,0)
 .  ; Store event in log...
"RTN","HLEVAPI2",225,0)
 .  S X=$$ADDNOTE^HLEME(+LIEN,"Event monitor# "_HLEVIENJ_" created this log entry.")
"RTN","HLEVAPI2",226,0)
 .  ; Store log in event...
"RTN","HLEVAPI2",227,0)
 .  KILL ^TMP($J,"HLZZ")
"RTN","HLEVAPI2",228,0)
 .  S ^TMP($J,"HLZZ",1)="Log# "_LIEN_" was created by this event monitor.)"
"RTN","HLEVAPI2",229,0)
 .  D RUNDIARY^HLEVAPI1($NA(^TMP($J,"HLZZ")))
"RTN","HLEVAPI2",230,0)
 .  KILL ^TMP($J,"HLZZ")
"RTN","HLEVAPI2",231,0)
 .
"RTN","HLEVAPI2",232,0)
 .  ; Add Xrefs...
"RTN","HLEVAPI2",233,0)
 .  S LIST(1)="X776",LIST(2)=HLEVIENJ,LIST(3)=LIEN
"RTN","HLEVAPI2",234,0)
 .  S X=$$NEWINDEX^HLEME1(+LIEN,ETYPE,.LIST)
"RTN","HLEVAPI2",235,0)
 .
"RTN","HLEVAPI2",236,0)
 .  S LIST(1)="X7764",LIST(2)=LIEN,LIST(3)=HLEVIENJ
"RTN","HLEVAPI2",237,0)
 .  S X=$$NEWINDEX^HLEME1(+LIEN,ETYPE,.LIST)
"RTN","HLEVAPI2",238,0)
 ;
"RTN","HLEVAPI2",239,0)
 ; If no variables to store, stop now...
"RTN","HLEVAPI2",240,0)
 I STORE']"" QUIT 1_U_LIEN ;->
"RTN","HLEVAPI2",241,0)
 ;
"RTN","HLEVAPI2",242,0)
 ; Re-extract variables, get values, and store in log entry...
"RTN","HLEVAPI2",243,0)
 F PCE=1:1:$L($G(STORE),U) D
"RTN","HLEVAPI2",244,0)
 .  S VAR=$P(STORE,U,+PCE) QUIT:VAR']""!('($D(@VAR)#2))  ;->
"RTN","HLEVAPI2",245,0)
 .  S X=$$STOREVAR^HLEME(+LIEN,@VAR,VAR) ; Store variable
"RTN","HLEVAPI2",246,0)
 .  S LIST(PCE)=@VAR
"RTN","HLEVAPI2",247,0)
 ;
"RTN","HLEVAPI2",248,0)
 ; Make a new index...
"RTN","HLEVAPI2",249,0)
 S X=$$NEWINDEX^HLEME1(+LIEN,ETYPE,.LIST)
"RTN","HLEVAPI2",250,0)
 ;
"RTN","HLEVAPI2",251,0)
 Q 1_U_LIEN
"RTN","HLEVAPI2",252,0)
 ;
"RTN","HLEVAPI2",253,0)
LOGVAR(IEN,VAR) ; Store variable in 776.4...
"RTN","HLEVAPI2",254,0)
 N CT,MIEN,ZERO
"RTN","HLEVAPI2",255,0)
 ;
"RTN","HLEVAPI2",256,0)
 QUIT:$G(^HLEV(776.4,+$G(IEN),0))']""!('$D(@VAR))  ;->
"RTN","HLEVAPI2",257,0)
 S ZERO=$G(^HLEV(776.4,+IEN,3,0)),$P(ZERO,U,2)=776.43
"RTN","HLEVAPI2",258,0)
 ;
"RTN","HLEVAPI2",259,0)
 S CT=0
"RTN","HLEVAPI2",260,0)
 ;
"RTN","HLEVAPI2",261,0)
 ; Individual variable...
"RTN","HLEVAPI2",262,0)
 I $D(VAR)#2 D SV(VAR,@VAR) QUIT:'CT  ;->
"RTN","HLEVAPI2",263,0)
 ;
"RTN","HLEVAPI2",264,0)
 S ^HLEV(776.4,+IEN,3,0)=ZERO
"RTN","HLEVAPI2",265,0)
 ;
"RTN","HLEVAPI2",266,0)
 Q
"RTN","HLEVAPI2",267,0)
 ;
"RTN","HLEVAPI2",268,0)
LOGQUERY(IEN,QUERYBEG,QUERYEND) ; Store ARR() in 776.4...
"RTN","HLEVAPI2",269,0)
 N CT,MIEN,ZERO
"RTN","HLEVAPI2",270,0)
 ;
"RTN","HLEVAPI2",271,0)
 QUIT:$G(^HLEV(776.4,+$G(IEN),0))']""  ;->
"RTN","HLEVAPI2",272,0)
 S ZERO=$G(^HLEV(776.4,+IEN,3,0)),$P(ZERO,U,2)=776.43
"RTN","HLEVAPI2",273,0)
 ;
"RTN","HLEVAPI2",274,0)
 S CT=0
"RTN","HLEVAPI2",275,0)
 F  S QUERYBEG=$Q(@QUERYBEG) Q:QUERYBEG'[QUERYEND  D
"RTN","HLEVAPI2",276,0)
 .  D SV(QUERYBEG,@QUERYBEG)
"RTN","HLEVAPI2",277,0)
 ;
"RTN","HLEVAPI2",278,0)
 QUIT:CT'>0  ;->
"RTN","HLEVAPI2",279,0)
 ;
"RTN","HLEVAPI2",280,0)
 S ^HLEV(776.4,+IEN,3,0)=ZERO
"RTN","HLEVAPI2",281,0)
 ;
"RTN","HLEVAPI2",282,0)
 Q
"RTN","HLEVAPI2",283,0)
 ;
"RTN","HLEVAPI2",284,0)
SV(VAR,VAL) ; Store individual variable... (Increments CT, updates ZERO,
"RTN","HLEVAPI2",285,0)
 ; and creates MIEN.)
"RTN","HLEVAPI2",286,0)
 ; CT,IEN,ZERO -- req --> CT,MIEN,ZERO
"RTN","HLEVAPI2",287,0)
 S CT=CT+1
"RTN","HLEVAPI2",288,0)
 S MIEN=$O(^HLEV(776.4,+IEN,3,":"),-1)+1
"RTN","HLEVAPI2",289,0)
 S ^HLEV(776.4,+IEN,3,+MIEN,0)=VAR_"="_VAL
"RTN","HLEVAPI2",290,0)
 S $P(ZERO,U,3)=MIEN,$P(ZERO,U,4)=MIEN
"RTN","HLEVAPI2",291,0)
 Q
"RTN","HLEVAPI2",292,0)
 ;
"RTN","HLEVAPI2",293,0)
EOR ;HLEVAPI2 - Event Monitor APIs ;5/16/03 14:42
"RTN","HLEVAPI3")
0^39^B53454303
"RTN","HLEVAPI3",1,0)
HLEVAPI3 ;O-OIFO/LJA - Event Monitor APIs ;02/04/2004 14:42
"RTN","HLEVAPI3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVAPI3",3,0)
 ;
"RTN","HLEVAPI3",4,0)
EVENTONE(HLEVIENM,HLEVNM,HLEVIENE) ; Master job check of an event...
"RTN","HLEVAPI3",5,0)
 ; ZTSKMST -- req
"RTN","HLEVAPI3",6,0)
 N CONT,CURR,CURRNOW,IEN,LAPSEMIN,LASTRUN,MAILGRP,MCHECK,MSTART,NO,NODE
"RTN","HLEVAPI3",7,0)
 N NODE0,NODE40,PAR1,PAR2,PAR3,PAR4,PAR5,PAR6,PAR7,PAR8,RUNNOW
"RTN","HLEVAPI3",8,0)
 N START,STAT,ZTDESC,ZTDTH,ZTIO,ZTRTN
"RTN","HLEVAPI3",9,0)
 ;
"RTN","HLEVAPI3",10,0)
 S NODE0=$G(^HLEV(776.1,+$G(HLEVIENE),0))
"RTN","HLEVAPI3",11,0)
 I NODE0']"" D RECEVM(HLEVIENM,HLEVIENE,"X^NO-0-NODE") QUIT  ;->
"RTN","HLEVAPI3",12,0)
 S STAT=$P(NODE0,U,2) I STAT'="A" D RECEVM(HLEVIENM,HLEVIENE,"I") QUIT  ;->
"RTN","HLEVAPI3",13,0)
 ; Requeue minutes for monitor...
"RTN","HLEVAPI3",14,0)
 S LAPSE=$P(NODE0,U,4) I LAPSE'?1.N D RECEVM(HLEVIENM,HLEVIENE,"X^INVALID-LAPSE") QUIT  ;->
"RTN","HLEVAPI3",15,0)
 ;
"RTN","HLEVAPI3",16,0)
 ; Required M TAG^RTN for monitor...
"RTN","HLEVAPI3",17,0)
 S MSTART=$TR($P(NODE0,U,6),"~",U) I '$$OKMCODE^HLEVAPI0(MSTART) D  QUIT  ;->
"RTN","HLEVAPI3",18,0)
 .  D RECEVM(HLEVIENM,HLEVIENE,"X^INVALID-M ["_$TR(MSTART,U,"~")_"]")
"RTN","HLEVAPI3",19,0)
 ;
"RTN","HLEVAPI3",20,0)
 ; Optional M $$EXTFUNCTION^RTN for determining whether new job should start
"RTN","HLEVAPI3",21,0)
 S MCHECK=$TR($P(NODE0,U,7),"~",U)
"RTN","HLEVAPI3",22,0)
 ;
"RTN","HLEVAPI3",23,0)
 ; If M check for start code exists, but is not valid M code, quit...
"RTN","HLEVAPI3",24,0)
 I MCHECK]"",'$$OKMCODE^HLEVAPI0($P(MCHECK,"$$",2,99)) D  QUIT  ;->
"RTN","HLEVAPI3",25,0)
 .  D RECEVM(HLEVIENM,HLEVIENE,"X-INVALID-M-CHK ["_$TR(MCHECK,U,"~")_"]")
"RTN","HLEVAPI3",26,0)
 ;
"RTN","HLEVAPI3",27,0)
 ; When last run (started)?  Return NULL if not completed...
"RTN","HLEVAPI3",28,0)
 S IEN=$O(^HLEV(776,"M",+HLEVIENE,":"),-1)
"RTN","HLEVAPI3",29,0)
 S (NODE,LASTRUN(1))=$G(^HLEV(776,+IEN,0))
"RTN","HLEVAPI3",30,0)
 S LASTRUN=$P(NODE,U),LASTRUN=$S(LASTRUN?7N1"."1.N:LASTRUN,1:"")
"RTN","HLEVAPI3",31,0)
 S X=$P(NODE,U,2) I X?7N1"."1.N S LASTRUN=X
"RTN","HLEVAPI3",32,0)
 ;
"RTN","HLEVAPI3",33,0)
 ; Set start new job default to YES...
"RTN","HLEVAPI3",34,0)
 S CONT=1
"RTN","HLEVAPI3",35,0)
 ;
"RTN","HLEVAPI3",36,0)
 ; If M start check code doesn't exist, check usual fields...
"RTN","HLEVAPI3",37,0)
 I MCHECK']"" D  QUIT:'CONT  ;->
"RTN","HLEVAPI3",38,0)
 .
"RTN","HLEVAPI3",39,0)
 .  ;Start new monitor if last job running and timestamp is current,
"RTN","HLEVAPI3",40,0)
 .  ;or monitor never run...
"RTN","HLEVAPI3",41,0)
 .
"RTN","HLEVAPI3",42,0)
 .  ; Never run, so start new monitor...
"RTN","HLEVAPI3",43,0)
 .  QUIT:LASTRUN']""
"RTN","HLEVAPI3",44,0)
 .
"RTN","HLEVAPI3",45,0)
 .  ; Monitor running now, and is current, so don't do anything...
"RTN","HLEVAPI3",46,0)
 .  S CURRNOW=$$CURR^HLEVAPI1(+IEN) I CURRNOW D  QUIT  ;->
"RTN","HLEVAPI3",47,0)
 .  .  I CURRNOW S CONT=0
"RTN","HLEVAPI3",48,0)
 .  .  D RECEVM(HLEVIENM,HLEVIENE,"R") ; Monitor running already...
"RTN","HLEVAPI3",49,0)
 .
"RTN","HLEVAPI3",50,0)
 .  ; Monitor run, and if time to run new monitor, quit...
"RTN","HLEVAPI3",51,0)
 .  S RUNNOW=$$RUNEV^HLEVAPI0(LASTRUN,LAPSE) QUIT:RUNNOW  ;->
"RTN","HLEVAPI3",52,0)
 .
"RTN","HLEVAPI3",53,0)
 .  S CONT=0 ; Set "no new monitor job needed" variable...
"RTN","HLEVAPI3",54,0)
 .  D RECEVM(HLEVIENM,HLEVIENE,"E") QUIT  ;-> Too early...
"RTN","HLEVAPI3",55,0)
 ;
"RTN","HLEVAPI3",56,0)
 I MCHECK]"" D  QUIT:'CONT  ;->
"RTN","HLEVAPI3",57,0)
 .  N HLEVRUN
"RTN","HLEVAPI3",58,0)
 .  D RUNS(HLEVIENE,.HLEVRUN) ; Define recent monitor runs for API call...
"RTN","HLEVAPI3",59,0)
 .  S CONT="S CONT="_MCHECK X CONT
"RTN","HLEVAPI3",60,0)
 .  S CONT=$S(CONT=1:1,1:0) QUIT:CONT  ;->
"RTN","HLEVAPI3",61,0)
 .  D RECEVM(HLEVIENM,HLEVIENE,"M") ; Package API check failed...
"RTN","HLEVAPI3",62,0)
 ;
"RTN","HLEVAPI3",63,0)
 S HLEVIENJ=$$NEWEVENT^HLEVAPI(HLEVIENE) I HLEVIENJ'>0 D  QUIT  ;->
"RTN","HLEVAPI3",64,0)
 .  KILL HLPAR1D,HLPAR2D,HLPAR3D,HLPAR4D,HLPAR5D,HLPAR6D,HLPAR7D,HLPAR8D
"RTN","HLEVAPI3",65,0)
 ;
"RTN","HLEVAPI3",66,0)
 ; Queue a new job...
"RTN","HLEVAPI3",67,0)
 S ZTIO="",ZTDTH=$H,ZTDESC="HL Event Monitor - #"_HLEVIENE
"RTN","HLEVAPI3",68,0)
 S ZTRTN="QUEUEV^HLEVAPI3"
"RTN","HLEVAPI3",69,0)
 S ZTSAVE("HLEVIENJ")="",ZTSAVE("HLEVIENE")=""
"RTN","HLEVAPI3",70,0)
 S ZTSAVE("HLEVNM")="",ZTSAVE("HLEVIENM")=""
"RTN","HLEVAPI3",71,0)
 D ^%ZTLOAD
"RTN","HLEVAPI3",72,0)
 ;
"RTN","HLEVAPI3",73,0)
 ; Save info in 776.2...
"RTN","HLEVAPI3",74,0)
 D RECEVM(HLEVIENM,HLEVIENE,"Q",ZTSK,+HLEVIENJ)
"RTN","HLEVAPI3",75,0)
 ;
"RTN","HLEVAPI3",76,0)
 ; Save task number in 776...
"RTN","HLEVAPI3",77,0)
 D UPDFLDE^HLEVAPI(+HLEVIENJ,8,ZTSK)
"RTN","HLEVAPI3",78,0)
 ;
"RTN","HLEVAPI3",79,0)
 ; Reset back...
"RTN","HLEVAPI3",80,0)
 S ZTSK=ZTSKMST
"RTN","HLEVAPI3",81,0)
 ;
"RTN","HLEVAPI3",82,0)
 QUIT
"RTN","HLEVAPI3",83,0)
 ;
"RTN","HLEVAPI3",84,0)
RUNS(HLEVIENE,RUN) ; Find latest 10 runs for calling API...
"RTN","HLEVAPI3",85,0)
 N CT,IEN,NODE
"RTN","HLEVAPI3",86,0)
 KILL RUN
"RTN","HLEVAPI3",87,0)
 S CT=0,IEN=":"
"RTN","HLEVAPI3",88,0)
 F  S IEN=$O(^HLEV(776,"M",HLEVIENE,IEN),-1) Q:'IEN  D  QUIT:CT>9
"RTN","HLEVAPI3",89,0)
 .  S NODE=$G(^HLEV(776,+IEN,0)) QUIT:NODE']""  ;->
"RTN","HLEVAPI3",90,0)
 .  S CT=CT+1
"RTN","HLEVAPI3",91,0)
 .  S RUN(CT)=NODE
"RTN","HLEVAPI3",92,0)
 Q
"RTN","HLEVAPI3",93,0)
 ;
"RTN","HLEVAPI3",94,0)
RECEVM(HLEVIENM,HLEVIENE,RES,ZTSK,HLEVIENJ) ;
"RTN","HLEVAPI3",95,0)
 N CT,DATA,REA
"RTN","HLEVAPI3",96,0)
 ;
"RTN","HLEVAPI3",97,0)
 I $E(RES)="X" S REA=$P(RES,U,2),RES="X"
"RTN","HLEVAPI3",98,0)
 ;
"RTN","HLEVAPI3",99,0)
 S RES=$S($G(RES)]"":RES,1:"?")
"RTN","HLEVAPI3",100,0)
 S NOEVCHK(RES)=$G(NOEVCHK(RES))+1
"RTN","HLEVAPI3",101,0)
 ;
"RTN","HLEVAPI3",102,0)
 QUIT:$G(^HLEV(776.2,+$G(HLEVIENM),0))']""  ;->
"RTN","HLEVAPI3",103,0)
 QUIT:$G(^HLEV(776.1,+$G(HLEVIENE),0))']""  ;->
"RTN","HLEVAPI3",104,0)
 ;
"RTN","HLEVAPI3",105,0)
 S CT=$O(^HLEV(776.2,+HLEVIENM,51,":"),-1)+1
"RTN","HLEVAPI3",106,0)
 S ^HLEV(776.2,+HLEVIENM,51,0)="^776.2051PA^"_CT_U_CT
"RTN","HLEVAPI3",107,0)
 S DATA=HLEVIENE_U_$G(RES)_U_$$NOW^XLFDT
"RTN","HLEVAPI3",108,0)
 I $G(ZTSK) S $P(DATA,U,4)=ZTSK
"RTN","HLEVAPI3",109,0)
 I $G(REA)]"" S $P(DATA,U,7)=REA
"RTN","HLEVAPI3",110,0)
 I $G(HLEVIENJ)>0 S $P(DATA,U,8)=HLEVIENJ
"RTN","HLEVAPI3",111,0)
 S ^HLEV(776.2,+HLEVIENM,51,+CT,0)=DATA
"RTN","HLEVAPI3",112,0)
 S ^HLEV(776.2,+HLEVIENM,51,"B",HLEVIENE,CT)=""
"RTN","HLEVAPI3",113,0)
 ;
"RTN","HLEVAPI3",114,0)
 Q
"RTN","HLEVAPI3",115,0)
 ;
"RTN","HLEVAPI3",116,0)
QUEUEV ; Queued event job starts here...
"RTN","HLEVAPI3",117,0)
 ; HLEVIENE,HLEVIENJ,HLEVIENM -- req
"RTN","HLEVAPI3",118,0)
 N EVMCODE,EVMGRP,EVNAME,NODE,EVPAR1,EVPAR2,EVPAR3,EVPAR4,EVPAR5
"RTN","HLEVAPI3",119,0)
 N EVPAR6,DVPAR7,EVPAR8
"RTN","HLEVAPI3",120,0)
 ;
"RTN","HLEVAPI3",121,0)
 S ZTREQ="@"
"RTN","HLEVAPI3",122,0)
 ;
"RTN","HLEVAPI3",123,0)
 ; Mark RUNNING before doing anything else...
"RTN","HLEVAPI3",124,0)
 D EVRES^HLEVAPI0(+HLEVIENM,+HLEVIENE,"R",+HLEVIENJ)
"RTN","HLEVAPI3",125,0)
 ;
"RTN","HLEVAPI3",126,0)
 S NODE=$G(^HLEV(776.1,+$G(HLEVIENE),0)) I NODE']"" D  QUIT  ;->
"RTN","HLEVAPI3",127,0)
 .  D EVRES^HLEVAPI0(+HLEVIENM,+HLEVIENE,"XE",+HLEVIENJ)
"RTN","HLEVAPI3",128,0)
 S EVNAME=$P(NODE,U),EVMGRP=$P(NODE,U,5)
"RTN","HLEVAPI3",129,0)
 S EVMCODE=$TR($P(NODE,U,6),"~",U) I EVMCODE'?1.8E1"^"1.8E D  QUIT  ;->
"RTN","HLEVAPI3",130,0)
 .  D EVRES^HLEVAPI0(+HLEVIENM,+HLEVIENE,"XE",+HLEVIENJ)
"RTN","HLEVAPI3",131,0)
 ;
"RTN","HLEVAPI3",132,0)
 ; Node 40...
"RTN","HLEVAPI3",133,0)
 S NODE40=$G(^HLEV(776.1,+HLEVIENE,40))
"RTN","HLEVAPI3",134,0)
 F NO=1:1:8 S @("EVPAR"_NO)=$P(NODE40,U,NO)
"RTN","HLEVAPI3",135,0)
 ;
"RTN","HLEVAPI3",136,0)
 ; Final M code check...
"RTN","HLEVAPI3",137,0)
 I '$$OKMCODE^HLEVAPI0(EVMCODE) D  QUIT  ;->
"RTN","HLEVAPI3",138,0)
 .  D EVRES^HLEVAPI0(+HLEVIENM,+HLEVIENE,"XM",+HLEVIENJ)
"RTN","HLEVAPI3",139,0)
 ;
"RTN","HLEVAPI3",140,0)
 D @EVMCODE
"RTN","HLEVAPI3",141,0)
 ;
"RTN","HLEVAPI3",142,0)
 D EVRES^HLEVAPI0(+HLEVIENM,+HLEVIENE,"F",+HLEVIENJ)
"RTN","HLEVAPI3",143,0)
 ;
"RTN","HLEVAPI3",144,0)
 Q
"RTN","HLEVAPI3",145,0)
 ;
"RTN","HLEVAPI3",146,0)
MAILIT ; Generic mail out call...
"RTN","HLEVAPI3",147,0)
 ; HLEVIENE,HLEVIENJ -- req
"RTN","HLEVAPI3",148,0)
 ; XMY(...) can be created before this call...
"RTN","HLEVAPI3",149,0)
 N MGRP
"RTN","HLEVAPI3",150,0)
 ;
"RTN","HLEVAPI3",151,0)
 D DEBUG^HLEVAPI2("MAILIT") ; Debug data created conditionally
"RTN","HLEVAPI3",152,0)
 ;
"RTN","HLEVAPI3",153,0)
 ; Stop all event monitoring to enable on-site debugging...
"RTN","HLEVAPI3",154,0)
 QUIT:$G(^TMP("HLEVFLAG",$J))["STOP"  ;->
"RTN","HLEVAPI3",155,0)
 ;
"RTN","HLEVAPI3",156,0)
 D ADDXMYS^HLEVAPI2(HLEVIENE,$G(XTMP))
"RTN","HLEVAPI3",157,0)
 ;
"RTN","HLEVAPI3",158,0)
 ; If no mail group, and no passed in XMY, use DUZ...
"RTN","HLEVAPI3",159,0)
 I '$D(XMY),$G(DUZ)>0 S XMY(DUZ)=""
"RTN","HLEVAPI3",160,0)
 ;
"RTN","HLEVAPI3",161,0)
 QUIT:'$D(XMY)
"RTN","HLEVAPI3",162,0)
 ;
"RTN","HLEVAPI3",163,0)
 D SENDMAIL^HLEVAPI(HLEVIENE,+$G(HLEVIENJ),.XMY) ; Use generic email...
"RTN","HLEVAPI3",164,0)
 ;
"RTN","HLEVAPI3",165,0)
 KILL XMSUB,XMTEXT,XMY
"RTN","HLEVAPI3",166,0)
 ;
"RTN","HLEVAPI3",167,0)
 Q
"RTN","HLEVAPI3",168,0)
 ;
"RTN","HLEVAPI3",169,0)
MONFLAG(VAL) ; Set ^TMP("HLEVFLAG",$J), or return it's value...
"RTN","HLEVAPI3",170,0)
 ; User may pass in the following values for VAL...
"RTN","HLEVAPI3",171,0)
 ;
"RTN","HLEVAPI3",172,0)
 ; * ABORT,STOP   -> Will set ^TMP("HLEVFLAG",$J)="STOP"
"RTN","HLEVAPI3",173,0)
 ; * START,RUN,XEC -> Will kill ^TMP("HLEVFLAG",$J)
"RTN","HLEVAPI3",174,0)
 ; * SHOW,"" -> Will return value of ^TMP("HLEVFLAG",$J)
"RTN","HLEVAPI3",175,0)
 ;
"RTN","HLEVAPI3",176,0)
 ; What did user pass in?  
"RTN","HLEVAPI3",177,0)
 S VAL=$$UP^XLFSTR($G(VAL))
"RTN","HLEVAPI3",178,0)
 S VAL=$S(VAL="STOP":"STOP",VAL="ABORT":"STOP",VAL="SET":"STOP",VAL="KILL":"@",VAL="START":"@",VAL="RUN":"@",VAL="XEC":"@",1:"")
"RTN","HLEVAPI3",179,0)
 ;
"RTN","HLEVAPI3",180,0)
 I VAL']"" QUIT $G(^TMP("HLEVFLAG",$J)) ;-> Just show value...
"RTN","HLEVAPI3",181,0)
 I VAL="@" KILL ^TMP("HLEVFLAG",$J) QUIT "" ;->
"RTN","HLEVAPI3",182,0)
 I VAL="STOP" S ^TMP("HLEVFLAG",$J)="STOP" QUIT "STOP" ;->
"RTN","HLEVAPI3",183,0)
 ;
"RTN","HLEVAPI3",184,0)
 Q $G(^TMP("HLEVFLAG",$J))
"RTN","HLEVAPI3",185,0)
 ;
"RTN","HLEVAPI3",186,0)
COUNT(MON,STATUS,GBL,LIM) ; Number of entries for monitor with STATUS...
"RTN","HLEVAPI3",187,0)
 ;
"RTN","HLEVAPI3",188,0)
 ; Pass in... MON    -> Name or IEN of monitor
"RTN","HLEVAPI3",189,0)
 ;
"RTN","HLEVAPI3",190,0)
 ;            STATUS -> 776's STATUS field code or full expansion
"RTN","HLEVAPI3",191,0)
 ;                      -- Default = RUNNING
"RTN","HLEVAPI3",192,0)
 ;                      -- Pass in ALL for all entries
"RTN","HLEVAPI3",193,0)
 ;
"RTN","HLEVAPI3",194,0)
 ;            [GBL]  -> Global for entry storage. [OPTIONAL]
"RTN","HLEVAPI3",195,0)
 ;                      Creates @GBL@(#)=IEN ~ 776 zero node
"RTN","HLEVAPI3",196,0)
 ;                      (KILL @GBL at beginning!)
"RTN","HLEVAPI3",197,0)
 ;
"RTN","HLEVAPI3",198,0)
 ;            [LIM]  -> Limit to # entries/status to store in GBL.
"RTN","HLEVAPI3",199,0)
 ;                     
"RTN","HLEVAPI3",200,0)
 ;
"RTN","HLEVAPI3",201,0)
 ; Examples:  
"RTN","HLEVAPI3",202,0)
 ; 
"RTN","HLEVAPI3",203,0)
 ; $$COUNT("FAST HL7 PURGE #2") -> # events running (default)
"RTN","HLEVAPI3",204,0)
 ; $$COUNT("FAST HL7 PURGE #2","R") -> # events running
"RTN","HLEVAPI3",205,0)
 ; $$COUNT("FAST HL7 PURGE #2","ALL") -> # events of all statuses
"RTN","HLEVAPI3",206,0)
 ;
"RTN","HLEVAPI3",207,0)
 ; The call...  $$COUNT("FAST HL7 PURGE #2","ALL","HLEV",1)
"RTN","HLEVAPI3",208,0)
 ;
"RTN","HLEVAPI3",209,0)
 ; Returns...   (1) # event entries that exist of all statuses.
"RTN","HLEVAPI3",210,0)
 ;              (2) Stores entries in HLEV(#)=zero node
"RTN","HLEVAPI3",211,0)
 ;              (3) Stores only the most recent entry (LIM=1)
"RTN","HLEVAPI3",212,0)
 ;
"RTN","HLEVAPI3",213,0)
 ;              If LIM>2, for example, the most recent two entries
"RTN","HLEVAPI3",214,0)
 ;              would be returned.  But, note that the subscripting
"RTN","HLEVAPI3",215,0)
 ;              is not oldest to newest, but newest (with subscript 
"RTN","HLEVAPI3",216,0)
 ;              of 1) to oldest (with subscript of 2.)
"RTN","HLEVAPI3",217,0)
 ;
"RTN","HLEVAPI3",218,0)
 N CT,IEN,NO
"RTN","HLEVAPI3",219,0)
 ;
"RTN","HLEVAPI3",220,0)
 QUIT:$G(MON)']"" "" ;->
"RTN","HLEVAPI3",221,0)
 S:$G(STATUS)']"" STATUS="R" ; Default to RUNNING...
"RTN","HLEVAPI3",222,0)
 S:STATUS="ALL" STATUS="EFQR"
"RTN","HLEVAPI3",223,0)
 I STATUS'="EFQR" S STATUS=$$UP^XLFSTR($E($G(STATUS)_" "))
"RTN","HLEVAPI3",224,0)
 QUIT:"EFQR"'[STATUS "" ;->
"RTN","HLEVAPI3",225,0)
 ;
"RTN","HLEVAPI3",226,0)
 ; If passed GBL, check/set limit..
"RTN","HLEVAPI3",227,0)
 S GBL=$G(GBL),LIM=$G(LIM)
"RTN","HLEVAPI3",228,0)
 S LIM=$S(LIM:LIM,1:999999)
"RTN","HLEVAPI3",229,0)
 ;
"RTN","HLEVAPI3",230,0)
 ; It's OK to pass in the IEN...
"RTN","HLEVAPI3",231,0)
 I MON'=+MON S MON=$O(^HLEV(776.1,"B",MON,0)) QUIT:MON'>0 "" ;->
"RTN","HLEVAPI3",232,0)
 ;
"RTN","HLEVAPI3",233,0)
 ; Remove any data hanging around from before call...
"RTN","HLEVAPI3",234,0)
 I GBL]"" KILL @GBL
"RTN","HLEVAPI3",235,0)
 ;
"RTN","HLEVAPI3",236,0)
 S CT=0,IEN=":"
"RTN","HLEVAPI3",237,0)
 F  S IEN=$O(^HLEV(776,"M",+MON,IEN),-1) Q:'IEN  D
"RTN","HLEVAPI3",238,0)
 .  S DATA=$G(^HLEV(776,+IEN,0))
"RTN","HLEVAPI3",239,0)
 .  ; Don't count if doesn't even have a status!
"RTN","HLEVAPI3",240,0)
 .  QUIT:$P(DATA,U,4)']""  ;->
"RTN","HLEVAPI3",241,0)
 .  ; If STATUS="EFQR", every status should be counted...
"RTN","HLEVAPI3",242,0)
 .  I STATUS'="EFQR" QUIT:$P(DATA,U,4)'=STATUS  ;->
"RTN","HLEVAPI3",243,0)
 .  S CT=CT+1
"RTN","HLEVAPI3",244,0)
 .  QUIT:$G(GBL)']""  ;-> Don't store and return...
"RTN","HLEVAPI3",245,0)
 .  S CT(1)=$O(@GBL@($P(DATA,U,4),":"),-1)+1
"RTN","HLEVAPI3",246,0)
 .  QUIT:CT(1)>LIM  ;->
"RTN","HLEVAPI3",247,0)
 .  S @GBL@($P(DATA,U,4),+CT(1))=IEN_"~"_DATA
"RTN","HLEVAPI3",248,0)
 ;
"RTN","HLEVAPI3",249,0)
 Q $S(CT:CT,1:"")
"RTN","HLEVAPI3",250,0)
 ;
"RTN","HLEVAPI3",251,0)
MARKERR ; Mark any RUNNING, but non-current entry's status to ERROR...
"RTN","HLEVAPI3",252,0)
 N DATA,IEN776,HLEVIENE,HLEVIENM,STAT
"RTN","HLEVAPI3",253,0)
 ;
"RTN","HLEVAPI3",254,0)
 S IEN776=0
"RTN","HLEVAPI3",255,0)
 F  S IEN776=$O(^HLEV(776,IEN776)) Q:'IEN776  D
"RTN","HLEVAPI3",256,0)
 .  S DATA=$G(^HLEV(776,+IEN776,0))
"RTN","HLEVAPI3",257,0)
 .  S STAT=$P(DATA,U,4) QUIT:STAT'="R"&(STAT'="Q")  ;->
"RTN","HLEVAPI3",258,0)
 .  QUIT:$$CURR^HLEVAPI1(+IEN776)  ;->
"RTN","HLEVAPI3",259,0)
 .  S HLEVIENE=$P(DATA,U,3) QUIT:$G(^HLEV(776.1,+HLEVIENE,0))']""  ;->
"RTN","HLEVAPI3",260,0)
 .  S HLEVIENM=$P(DATA,U,9) QUIT:$G(^HLEV(776.2,+HLEVIENM,0))']""  ;->
"RTN","HLEVAPI3",261,0)
 .  D EVRES^HLEVAPI0(HLEVIENM,HLEVIENE,"XE",IEN776)
"RTN","HLEVAPI3",262,0)
 ;
"RTN","HLEVAPI3",263,0)
 Q
"RTN","HLEVAPI3",264,0)
 ;
"RTN","HLEVAPI3",265,0)
EOR ;HLEVAPI3 - Event Monitor APIs ;5/16/03 14:42
"RTN","HLEVMNU")
0^9^B4442942
"RTN","HLEVMNU",1,0)
HLEVMNU ;O-OIFO/LJA - Event Monitor VistA HL7 PROGRAMMER Menu ;02/04/2004 14:42
"RTN","HLEVMNU",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVMNU",3,0)
 ;
"RTN","HLEVMNU",4,0)
INIT ;
"RTN","HLEVMNU",5,0)
 ;
"RTN","HLEVMNU",6,0)
CTRL ;
"RTN","HLEVMNU",7,0)
 D HEADER
"RTN","HLEVMNU",8,0)
 D M
"RTN","HLEVMNU",9,0)
 D ASK I 'A7UOK QUIT  ;->
"RTN","HLEVMNU",10,0)
 D XEC
"RTN","HLEVMNU",11,0)
 D BT QUIT:'A7UOK  ;->
"RTN","HLEVMNU",12,0)
 G CTRL ;->
"RTN","HLEVMNU",13,0)
 ;
"RTN","HLEVMNU",14,0)
BT ;
"RTN","HLEVMNU",15,0)
 W !
"RTN","HLEVMNU",16,0)
 S A7UOK=0
"RTN","HLEVMNU",17,0)
 N DIR
"RTN","HLEVMNU",18,0)
 S DIR(0)="EA",DIR("A")="Press RETURN to continue, or '^' to exit... "
"RTN","HLEVMNU",19,0)
 D ^DIR
"RTN","HLEVMNU",20,0)
 QUIT:+Y'=1  ;->
"RTN","HLEVMNU",21,0)
 S A7UOK=1
"RTN","HLEVMNU",22,0)
 QUIT
"RTN","HLEVMNU",23,0)
 ;
"RTN","HLEVMNU",24,0)
HEADER ;
"RTN","HLEVMNU",25,0)
 W @IOF,$$CJ^XLFSTR("HL7 Event Monitor Utilities for Programmer",IOM)
"RTN","HLEVMNU",26,0)
 W !,$$REPEAT^XLFSTR("=",80)
"RTN","HLEVMNU",27,0)
 QUIT
"RTN","HLEVMNU",28,0)
 ;
"RTN","HLEVMNU",29,0)
M KILL A7UMENU F I=1:1 S T=$T(M+I) QUIT:T'[";;"  S T=$P(T,";;",2,99),A7UMENU(I)=$P(T,"~",2,99) W !,$J(I,2),". ",$P(T,"~")
"RTN","HLEVMNU",30,0)
 ;;Kill all *RUNTIME* Event Monitoring data~D REMOVALL^HLEVUTIL
"RTN","HLEVMNU",31,0)
 ;;Start queued master job now~D MSTNOW^HLEVMST0
"RTN","HLEVMNU",32,0)
 ;;Queued master job (if no master job queued)~D STARTJOB^HLEVMST
"RTN","HLEVMNU",33,0)
 ;;Test previously run server request~D TEST^HLEVSRV1
"RTN","HLEVMNU",34,0)
 ;;Create $QUERY search strings~D QUERYSTR^HLEVSRV2
"RTN","HLEVMNU",35,0)
 ;;Set/delete debug tags~D DEBUGSET^HLEVAPI2
"RTN","HLEVMNU",36,0)
 ;;Run M code repetitively~D START^HLEVUTI2
"RTN","HLEVMNU",37,0)
 ;;Show M code repetitive jobs~D SHOW^HLEVUTI2
"RTN","HLEVMNU",38,0)
 ;;Test monitor~D TEST^HLEVUTI1
"RTN","HLEVMNU",39,0)
 QUIT
"RTN","HLEVMNU",40,0)
 ;
"RTN","HLEVMNU",41,0)
ASK ;
"RTN","HLEVMNU",42,0)
 W !
"RTN","HLEVMNU",43,0)
 S A7UOK=0
"RTN","HLEVMNU",44,0)
 N DIR
"RTN","HLEVMNU",45,0)
 S DIR(0)="NO^1:"_(+I-1),DIR("A")="Select option"
"RTN","HLEVMNU",46,0)
 D ^DIR
"RTN","HLEVMNU",47,0)
 QUIT:'$D(A7UMENU(+Y))  ;->
"RTN","HLEVMNU",48,0)
 S A7UOPT=+Y
"RTN","HLEVMNU",49,0)
 S A7UOK=1
"RTN","HLEVMNU",50,0)
 QUIT
"RTN","HLEVMNU",51,0)
 ;
"RTN","HLEVMNU",52,0)
XEC ;
"RTN","HLEVMNU",53,0)
 S X=A7UMENU(+A7UOPT) X X
"RTN","HLEVMNU",54,0)
 QUIT
"RTN","HLEVMNU",55,0)
 ;
"RTN","HLEVMNU",56,0)
EOR ;HLEVMNU - Event Monitor VistA HL7 PROGRAMMER Menu ;5/16/03 14:42
"RTN","HLEVMST")
0^10^B57974007
"RTN","HLEVMST",1,0)
HLEVMST ;O-OIFO/LJA - Event Monitor MASTER JOB ;02/04/2004 14:42
"RTN","HLEVMST",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVMST",3,0)
 ;
"RTN","HLEVMST",4,0)
 ; Calling STARTJOB always queues a new master job NOW...
"RTN","HLEVMST",5,0)
 ;
"RTN","HLEVMST",6,0)
MSTENV ; Display environment to user...
"RTN","HLEVMST",7,0)
 ;
"RTN","HLEVMST",8,0)
 ;
"RTN","HLEVMST",9,0)
 ; Collect Master Job Information
"RTN","HLEVMST",10,0)
 ;
"RTN","HLEVMST",11,0)
 ;
"RTN","HLEVMST",12,0)
 ; Collect Active Event Monitors
"RTN","HLEVMST",13,0)
 ;
"RTN","HLEVMST",14,0)
 ;
"RTN","HLEVMST",15,0)
 Q
"RTN","HLEVMST",16,0)
 ;
"RTN","HLEVMST",17,0)
CHECKMST ; Called from outside Event Monitoring, from the Link Manager,
"RTN","HLEVMST",18,0)
 ; to see if the master job needs to be started.  (See ^HLCSLM.)
"RTN","HLEVMST",19,0)
 ; When the Link Manager calls here, two actions potentially occur:
"RTN","HLEVMST",20,0)
 ;
"RTN","HLEVMST",21,0)
 ; * Check is made whether this CHECKMST code has been run before,
"RTN","HLEVMST",22,0)
 ;   and if so, how long ago.  This check is performed by $$TIMECHK.
"RTN","HLEVMST",23,0)
 ; * If never run, or if run more than four hours ago, CHECKMST is run.
"RTN","HLEVMST",24,0)
 ;
"RTN","HLEVMST",25,0)
 ; CHECKMST checks whether a master job is running, or is properly 
"RTN","HLEVMST",26,0)
 ; queued.  If not, it queues a master job.
"RTN","HLEVMST",27,0)
 ;
"RTN","HLEVMST",28,0)
 N LAPSE,LASTDT,LASTIEN,NODE,PAR0,RUNOW,RUNTIME,X
"RTN","HLEVMST",29,0)
 ;
"RTN","HLEVMST",30,0)
 QUIT:'$$TIMECHK  ;->
"RTN","HLEVMST",31,0)
 ;
"RTN","HLEVMST",32,0)
 ; Set last check time for later use by $$TIMECHK...
"RTN","HLEVMST",33,0)
 S HLEVLCHK(1)=$$SEC^HLEVMST0($H)
"RTN","HLEVMST",34,0)
 ;
"RTN","HLEVMST",35,0)
 ; Parameter status check...
"RTN","HLEVMST",36,0)
 S PAR0=$G(^HLEV(776.999,1,0)) Q:PAR0']""  ;->
"RTN","HLEVMST",37,0)
 I $P(PAR0,U,2)'="A" D  QUIT  ;-> Not ACTIVE...
"RTN","HLEVMST",38,0)
 .  D SHOWQUIT("Master job not started.  Parameter STATUS is INACTIVE...")
"RTN","HLEVMST",39,0)
 ;
"RTN","HLEVMST",40,0)
 ; Lapse (since last run) check...
"RTN","HLEVMST",41,0)
 S LAPSE=$P(PAR0,U,3) I LAPSE'>0 D  QUIT  ;->
"RTN","HLEVMST",42,0)
 .  D SHOWQUIT("Master job not started.  Master Job Interval not set up...")
"RTN","HLEVMST",43,0)
 ; Get IEN for last master job run
"RTN","HLEVMST",44,0)
 S LASTDT=$O(^HLEV(776.2,"B",":"),-1)
"RTN","HLEVMST",45,0)
 S LASTIEN=$O(^HLEV(776.2,"B",+LASTDT,":"),-1)
"RTN","HLEVMST",46,0)
 ;
"RTN","HLEVMST",47,0)
 I LASTIEN'>0 D STARTJOB QUIT  ;->
"RTN","HLEVMST",48,0)
 S NODE=$G(^HLEV(776.2,+LASTIEN,0))
"RTN","HLEVMST",49,0)
 S X=$P(NODE,U,4) I X="E"!(X="P") D STARTJOB QUIT  ;->
"RTN","HLEVMST",50,0)
 S RUNTIME=$P(NODE,U,6) ; Queue time for last run...
"RTN","HLEVMST",51,0)
 S RUNOW=$$RUNEV^HLEVAPI0(RUNTIME,LAPSE+15) ; No start unless 15" overdue
"RTN","HLEVMST",52,0)
 I RUNOW D STARTJOB QUIT  ;-> 15" overdue!!  So, start master job
"RTN","HLEVMST",53,0)
 D SHOWQUIT("Master job not started.  Not time yet...")
"RTN","HLEVMST",54,0)
 ;
"RTN","HLEVMST",55,0)
 Q
"RTN","HLEVMST",56,0)
 ;
"RTN","HLEVMST",57,0)
TIMECHK() ; Every loop in the Link Manager code in HLCSLM results in one
"RTN","HLEVMST",58,0)
 ; call being made to CHECKMST^HLEVMST.  The CHECKMST subroutine in turn
"RTN","HLEVMST",59,0)
 ; calls here to ensure that the Event Monitor's master job is running
"RTN","HLEVMST",60,0)
 ; properly.  However, the CHECKMST subroutine should be run by HLCSLM
"RTN","HLEVMST",61,0)
 ; only once every four hours.  The code in this subroutine uses
"RTN","HLEVMST",62,0)
 ; HLEVLCHK(#) variables to ensure that this every four hour rule is
"RTN","HLEVMST",63,0)
 ; followed.  (HLEVLCHK is newed at the top of HLCSLM.)
"RTN","HLEVMST",64,0)
 ;
"RTN","HLEVMST",65,0)
 ; Set the time NOW in seconds...
"RTN","HLEVMST",66,0)
 S HLEVLCHK(0)=$$SEC^HLEVMST0($H)
"RTN","HLEVMST",67,0)
 ;
"RTN","HLEVMST",68,0)
 ; This is the time of last check.  Make sure it exists...
"RTN","HLEVMST",69,0)
 S HLEVLCHK(1)=$G(HLEVLCHK(1))
"RTN","HLEVMST",70,0)
 ;
"RTN","HLEVMST",71,0)
 ; If no check every made, make a check now...
"RTN","HLEVMST",72,0)
 I HLEVLCHK(1)'>0 QUIT 1 ;->
"RTN","HLEVMST",73,0)
 ;
"RTN","HLEVMST",74,0)
 ; Set the number seconds between NOW and time of last check...
"RTN","HLEVMST",75,0)
 S HLEVLCHK(3)=HLEVLCHK(0)-HLEVLCHK(1) ; DIFF = NOW - LAST CHECK
"RTN","HLEVMST",76,0)
 ;
"RTN","HLEVMST",77,0)
 ; If less than 4 hours since last check, quit w/no check...
"RTN","HLEVMST",78,0)
 QUIT:HLEVLCHK(3)<(60*60*4) "" ;->
"RTN","HLEVMST",79,0)
 ;
"RTN","HLEVMST",80,0)
 Q 1 ; Check should be made...
"RTN","HLEVMST",81,0)
 ;
"RTN","HLEVMST",82,0)
SHOWQUIT(TXT) QUIT:$D(ZTQUEUED)  ;->
"RTN","HLEVMST",83,0)
 W !!,TXT,!
"RTN","HLEVMST",84,0)
 Q
"RTN","HLEVMST",85,0)
 ;
"RTN","HLEVMST",86,0)
STARTJOB ; Start a new job with optional display to screen...
"RTN","HLEVMST",87,0)
 N JOBS
"RTN","HLEVMST",88,0)
 S JOBS=$$NEWMSTR(0,1) QUIT:$D(ZTQUEUED)  ;->
"RTN","HLEVMST",89,0)
 W !!,"New master job queued to task# ",+JOBS,"..."
"RTN","HLEVMST",90,0)
 W !,"Entry #",$P(JOBS,U,2)," created in HL7 Monitor Master Job file..."
"RTN","HLEVMST",91,0)
 Q
"RTN","HLEVMST",92,0)
 ;
"RTN","HLEVMST",93,0)
MASTER ; Whenever a master job starts, here's where it's queued...
"RTN","HLEVMST",94,0)
 ; HLEVIENM - req
"RTN","HLEVMST",95,0)
 ;
"RTN","HLEVMST",96,0)
 N D,D0,DA,DIE,DR,FLD,NOEVCHK,NOPURG,NOW,RES,ZTSKMST
"RTN","HLEVMST",97,0)
 ;
"RTN","HLEVMST",98,0)
 S ZTREQ="@",NOW=$$NOW^XLFDT
"RTN","HLEVMST",99,0)
 ;
"RTN","HLEVMST",100,0)
 S ZTSKMST=$G(ZTSK) QUIT:ZTSKMST'>0  ;->
"RTN","HLEVMST",101,0)
 ;
"RTN","HLEVMST",102,0)
 QUIT:$G(^HLEV(776.2,+$G(HLEVIENM),0))']""  ;->
"RTN","HLEVMST",103,0)
 ;
"RTN","HLEVMST",104,0)
 ; Check parameter...
"RTN","HLEVMST",105,0)
 I $P($G(^HLEV(776.999,1,0)),U,2)'="A" D  QUIT  ;->
"RTN","HLEVMST",106,0)
 .  F FLD=2,3,8 D UPDFLDM(+HLEVIENM,FLD,NOW)
"RTN","HLEVMST",107,0)
 .  D UPDFLDM(+HLEVIENM,4,"A")
"RTN","HLEVMST",108,0)
 ;
"RTN","HLEVMST",109,0)
 ; Give (possibly just executed) $$NEWMSTR(0) DIE call time to execute...
"RTN","HLEVMST",110,0)
 H 2
"RTN","HLEVMST",111,0)
 ;
"RTN","HLEVMST",112,0)
 ; Queue next job...
"RTN","HLEVMST",113,0)
 S NEWJOB=$$NEWMSTR(1)
"RTN","HLEVMST",114,0)
 ;
"RTN","HLEVMST",115,0)
 ; What if job requested to stop?
"RTN","HLEVMST",116,0)
 I $P($G(^HLEV(776.2,+HLEVIENM,0)),U,4)="S" D  QUIT  ;->
"RTN","HLEVMST",117,0)
 .  F FLD=2,3,8 D UPDFLDM(+HLEVIENM,FLD,NOW)
"RTN","HLEVMST",118,0)
 .  D UPDFLDM(+HLEVIENM,4,"A")
"RTN","HLEVMST",119,0)
 ;
"RTN","HLEVMST",120,0)
 ; Mark entry to show it successfully started...
"RTN","HLEVMST",121,0)
 D UPDFLDM(+HLEVIENM,4,"R")
"RTN","HLEVMST",122,0)
 F FLD=3,8 D UPDFLDM(+HLEVIENM,FLD,NOW)
"RTN","HLEVMST",123,0)
 D UPDFLDM(+HLEVIENM,50,"Queued job started at "_$$NOW^XLFDT)
"RTN","HLEVMST",124,0)
 ;
"RTN","HLEVMST",125,0)
 ; Work starts here...
"RTN","HLEVMST",126,0)
 KILL NOEVCHK
"RTN","HLEVMST",127,0)
 S NOEVCHK=0
"RTN","HLEVMST",128,0)
 D EVENTCHK^HLEVAPI0(+HLEVIENM)
"RTN","HLEVMST",129,0)
 ;
"RTN","HLEVMST",130,0)
 ; Purge MONITOR and MASTER entries...
"RTN","HLEVMST",131,0)
 D PURGEALL^HLEVUTIL(+HLEVIENM)
"RTN","HLEVMST",132,0)
 ;
"RTN","HLEVMST",133,0)
 ; Mark ERROR any monitors still RUNNING by not current..
"RTN","HLEVMST",134,0)
 D MARKERR^HLEVAPI3
"RTN","HLEVMST",135,0)
 ;
"RTN","HLEVMST",136,0)
 ; Done...
"RTN","HLEVMST",137,0)
 D UPDFLDM(+HLEVIENM,2,$$NOW^XLFDT)
"RTN","HLEVMST",138,0)
 D UPDFLDM(+HLEVIENM,4,"F")
"RTN","HLEVMST",139,0)
 D UPDFLDM(+HLEVIENM,50,"Queued job finished at "_$$NOW^XLFDT)
"RTN","HLEVMST",140,0)
 D UPDFLDM(+HLEVIENM,50,"# events checked = "_$G(NOEVCHK))
"RTN","HLEVMST",141,0)
 S RES=""
"RTN","HLEVMST",142,0)
 F  S RES=$O(NOEVCHK(RES)) Q:RES']""  D
"RTN","HLEVMST",143,0)
 .  S RES(1)=$S(RES="E":" were not queued (too early.)",RES="I":" were not queued (inactivated.)",RES="Q":" were queued to execute.",RES="R":" Previous job still running.",RES="X":" errored, for some reason.",1:" have unknown disposition.")
"RTN","HLEVMST",144,0)
 .  I RES="M" S RES(1)=" M code check failed."
"RTN","HLEVMST",145,0)
 .  S RES(1)="#"_NOEVCHK(RES)_" Events"_RES(1)
"RTN","HLEVMST",146,0)
 .  D UPDFLDM(+HLEVIENM,50,RES(1))
"RTN","HLEVMST",147,0)
 ;
"RTN","HLEVMST",148,0)
 Q
"RTN","HLEVMST",149,0)
 ;
"RTN","HLEVMST",150,0)
NEWMSTR(FUTURE,SILENT) ; Create a new master job...
"RTN","HLEVMST",151,0)
 ; 
"RTN","HLEVMST",152,0)
 ; If FUTURE=0, then master job will be queued for NOW...
"RTN","HLEVMST",153,0)
 ; If FUTURE=1, then master job will be q'd for CUTMIN in future...
"RTN","HLEVMST",154,0)
 ;
"RTN","HLEVMST",155,0)
 N CUTMIN,DA,DIC,DIE,DD,DO,DR,HLEVIENM,X,Y,ZTDESC,ZTDTH,ZTIO,ZTRTN,ZTSK
"RTN","HLEVMST",156,0)
 ;
"RTN","HLEVMST",157,0)
 ; Should this process be silent?
"RTN","HLEVMST",158,0)
 S SILENT=$S($G(SILENT)>0:1,1:0)
"RTN","HLEVMST",159,0)
 ;
"RTN","HLEVMST",160,0)
 ; Check parameter...
"RTN","HLEVMST",161,0)
 I $P($G(^HLEV(776.999,1,0)),U,2)'="A" D  QUIT "" ;->
"RTN","HLEVMST",162,0)
 .  QUIT:$D(ZTQUEUED)!(SILENT)  ;->
"RTN","HLEVMST",163,0)
 .  W !!,"Exiting!  Master job not started.  Parameter turned off..."
"RTN","HLEVMST",164,0)
 .  H 2
"RTN","HLEVMST",165,0)
 ;
"RTN","HLEVMST",166,0)
 ; Make master stub entry...
"RTN","HLEVMST",167,0)
 S X=$$NOW^XLFDT,DIC="^HLEV(776.2,",DIC(0)="L"
"RTN","HLEVMST",168,0)
 D FILE^DICN
"RTN","HLEVMST",169,0)
 S HLEVIENM=$S(+Y>0:+Y,1:"") I HLEVIENM'>0 D  QUIT "" ;->
"RTN","HLEVMST",170,0)
 .  QUIT:$D(ZTQUEUED)!(SILENT)  ;->
"RTN","HLEVMST",171,0)
 .  W !!,"Exiting!  Master job not started.  Stub record creation failed..."
"RTN","HLEVMST",172,0)
 .  H 2
"RTN","HLEVMST",173,0)
 ;
"RTN","HLEVMST",174,0)
 ; Get CUTMIN and queue new job...
"RTN","HLEVMST",175,0)
 S CUTMIN=$H ; Default to NOW...
"RTN","HLEVMST",176,0)
 I $G(FUTURE) D
"RTN","HLEVMST",177,0)
 .  S CUTMIN=$O(^HLEV(776.999,":"),-1),CUTMIN=$P($G(^HLEV(776.999,+CUTMIN,0)),U,3)
"RTN","HLEVMST",178,0)
 .  S CUTMIN=$S(CUTMIN:CUTMIN,1:60) ; Default to 60 minutes between jobs...
"RTN","HLEVMST",179,0)
 .  S CUTMIN=$$FMTH^XLFDT($$FMADD^XLFDT($$NOW^XLFDT,0,0,CUTMIN))
"RTN","HLEVMST",180,0)
 S ZTIO="",ZTDTH=CUTMIN,ZTDESC="HL Master Job - Event Monitoring"
"RTN","HLEVMST",181,0)
 S ZTRTN="MASTER^HLEVMST"
"RTN","HLEVMST",182,0)
 S ZTSAVE("HLEVIENM")=""
"RTN","HLEVMST",183,0)
 D ^%ZTLOAD
"RTN","HLEVMST",184,0)
 ;
"RTN","HLEVMST",185,0)
 ; Store task #, etc...
"RTN","HLEVMST",186,0)
 KILL DA,DD,DIC,DO,X,Y
"RTN","HLEVMST",187,0)
 S DA=+HLEVIENM,DIE=776.2,DR="4///Q;5///"_ZTSK_";6////"_$$HTFM^XLFDT(CUTMIN)_";7////"_+DUZ
"RTN","HLEVMST",188,0)
 D ^DIE
"RTN","HLEVMST",189,0)
 ;
"RTN","HLEVMST",190,0)
 I '$D(ZTQUEUED)&('SILENT) D
"RTN","HLEVMST",191,0)
 .  W !!,"Master job created.  Task# ",ZTSK,", and Event# ",HLEVIENM,"..."
"RTN","HLEVMST",192,0)
 .  H 2
"RTN","HLEVMST",193,0)
 ;
"RTN","HLEVMST",194,0)
 QUIT $G(ZTSK)_U_HLEVIENM
"RTN","HLEVMST",195,0)
 ;
"RTN","HLEVMST",196,0)
UPDFLDM(HLEVIENM,FLD,VAL) ; Update a specific piece in 776.2...
"RTN","HLEVMST",197,0)
 N D,D0,DA,DI,DIE,DR
"RTN","HLEVMST",198,0)
 ;
"RTN","HLEVMST",199,0)
 QUIT:$G(^HLEV(776.2,+$G(HLEVIENM),0))']""!($G(VAL)']"")  ;->
"RTN","HLEVMST",200,0)
 ;
"RTN","HLEVMST",201,0)
 ; Call call here to store one 50 diary entry.  (Required that
"RTN","HLEVMST",202,0)
 ; FLD=50 and VAL=Text to store on line.  Must call here one time
"RTN","HLEVMST",203,0)
 ; for every line to be stored.)
"RTN","HLEVMST",204,0)
 I FLD=50 D  QUIT  ;->  Call call here to store one 50 diary entry
"RTN","HLEVMST",205,0)
 .  S NODE=$G(^HLEV(776.2,+HLEVIENM,50,0))
"RTN","HLEVMST",206,0)
 .  S:NODE']"" NODE="^776.201^^"
"RTN","HLEVMST",207,0)
 .  S CT=$O(^HLEV(776.2,+HLEVIENM,50,":"),-1)+1
"RTN","HLEVMST",208,0)
 .  S $P(NODE,U,3)=CT,$P(NODE,U,4)=CT
"RTN","HLEVMST",209,0)
 .  S ^HLEV(776.2,+HLEVIENM,50,0)=NODE
"RTN","HLEVMST",210,0)
 .  S ^HLEV(776.2,+HLEVIENM,50,+CT,0)=VAL
"RTN","HLEVMST",211,0)
 ;
"RTN","HLEVMST",212,0)
 I FLD=51 QUIT  ;-> Not allowed!
"RTN","HLEVMST",213,0)
 ;
"RTN","HLEVMST",214,0)
 ; Store zero node information...
"RTN","HLEVMST",215,0)
 S DA=+HLEVIENM,DIE=776.2,DR=FLD_"///"_VAL
"RTN","HLEVMST",216,0)
 D ^DIE
"RTN","HLEVMST",217,0)
 ;
"RTN","HLEVMST",218,0)
 Q
"RTN","HLEVMST",219,0)
 ;
"RTN","HLEVMST",220,0)
STAMPM(HLEVIENM) ; Update TIMESTAMP field in event..
"RTN","HLEVMST",221,0)
 N D,D0,DA,DI,DIE,DR
"RTN","HLEVMST",222,0)
 QUIT:$G(^HLEV(776.2,+$G(HLEVIENM),0))']""  ;->
"RTN","HLEVMST",223,0)
 S DA=+HLEVIENM,DIE=776.2,DR="3////"_$$NOW^XLFDT
"RTN","HLEVMST",224,0)
 D ^DIE
"RTN","HLEVMST",225,0)
 Q
"RTN","HLEVMST",226,0)
 ;
"RTN","HLEVMST",227,0)
PURGEM(HLEVIENM) ; Purge master job entries...
"RTN","HLEVMST",228,0)
 N CUTIME,IENM,LOOPTM,NOPURG,RETHRM
"RTN","HLEVMST",229,0)
 ;
"RTN","HLEVMST",230,0)
 ; Check parameter...
"RTN","HLEVMST",231,0)
 QUIT:$P($G(^HLEV(776.999,1,0)),U,2)'="A" "" ;->
"RTN","HLEVMST",232,0)
 ;
"RTN","HLEVMST",233,0)
 S NOPURG=0
"RTN","HLEVMST",234,0)
 ;
"RTN","HLEVMST",235,0)
 ; Get retention time (HR) for master job data...
"RTN","HLEVMST",236,0)
 S RETHRM=$O(^HLEV(776.999,":"),-1)
"RTN","HLEVMST",237,0)
 S RETHRM=$P($G(^HLEV(776.999,+RETHRM,0)),U,5)
"RTN","HLEVMST",238,0)
 S RETHRM=$S(RETHRM>0:RETHRM,1:96) ; Default to 96 hours
"RTN","HLEVMST",239,0)
 ;
"RTN","HLEVMST",240,0)
 ; Cutoff time...
"RTN","HLEVMST",241,0)
 S CUTIME=$$FMADD^XLFDT($$NOW^XLFDT,0,-RETHRM)
"RTN","HLEVMST",242,0)
 ;
"RTN","HLEVMST",243,0)
 F  S CUTIME=$O(^HLEV(776.2,"B",CUTIME),-1) Q:CUTIME'>0  D
"RTN","HLEVMST",244,0)
 .  S IEN=0
"RTN","HLEVMST",245,0)
 .  F  S IEN=$O(^HLEV(776.2,"B",CUTIME,IEN)) Q:IEN'>0  D
"RTN","HLEVMST",246,0)
 .  .  QUIT:IEN=HLEVIENM  ;-> Don't delete yourself!!
"RTN","HLEVMST",247,0)
 .  .  S NOPURG=NOPURG+1
"RTN","HLEVMST",248,0)
 .  .  D PURGEME^HLEVUTIL(+IEN) ; Delete events in master job...
"RTN","HLEVMST",249,0)
 .  .  D DELETE^HLEVUTIL(776.2,+IEN)
"RTN","HLEVMST",250,0)
 ;
"RTN","HLEVMST",251,0)
 Q NOPURG
"RTN","HLEVMST",252,0)
 ;
"RTN","HLEVMST",253,0)
EOR ;HLEVMST - Event Monitor MASTER JOB ;5/16/03 14:42
"RTN","HLEVMST0")
0^19^B40889627
"RTN","HLEVMST0",1,0)
HLEVMST0 ;O-OIFO/LJA - Event Monitor MASTER JOB ;02/04/2004 14:42
"RTN","HLEVMST0",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVMST0",3,0)
 ;
"RTN","HLEVMST0",4,0)
UNQUEUE ; Unqueue master job...
"RTN","HLEVMST0",5,0)
 N DIFF,IOINHI,IOINORM,LAST0,LASTDT,LASTIEN,NEXTH,SECNEXT
"RTN","HLEVMST0",6,0)
 N SECNOW,TASKNO,ZTDTH,ZTSK
"RTN","HLEVMST0",7,0)
 ;
"RTN","HLEVMST0",8,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLEVMST0",9,0)
 ;
"RTN","HLEVMST0",10,0)
 D HDU
"RTN","HLEVMST0",11,0)
 D EXU
"RTN","HLEVMST0",12,0)
 ;
"RTN","HLEVMST0",13,0)
 W !
"RTN","HLEVMST0",14,0)
 ;
"RTN","HLEVMST0",15,0)
 S LASTDT=$O(^HLEV(776.2,"B",":"),-1)
"RTN","HLEVMST0",16,0)
 S LASTIEN=$O(^HLEV(776.2,"B",+LASTDT,":"),-1)
"RTN","HLEVMST0",17,0)
 S LAST0=$G(^HLEV(776.2,+LASTIEN,0)) I $P(LAST0,U,4)'="Q" D  QUIT  ;->
"RTN","HLEVMST0",18,0)
 .  D TELL("The most recently queued master job is no longer active...","1^2^999")
"RTN","HLEVMST0",19,0)
 ;
"RTN","HLEVMST0",20,0)
 S LASTSK=$P(LAST0,U,5) I LASTSK>0 D
"RTN","HLEVMST0",21,0)
 .  W !,"The current master job is task# ",$P(LAST0,U,5),", queued for "
"RTN","HLEVMST0",22,0)
 .  W $$FMTE^XLFDT(+$P(LAST0,U,6)),"."
"RTN","HLEVMST0",23,0)
 ;
"RTN","HLEVMST0",24,0)
 W !
"RTN","HLEVMST0",25,0)
 I '$$YN^HLCSRPT4("OK to stop master job now","No") D  QUIT  ;->
"RTN","HLEVMST0",26,0)
 .  W "     no action taken..."
"RTN","HLEVMST0",27,0)
 ;
"RTN","HLEVMST0",28,0)
 W "   Master job stopped..."
"RTN","HLEVMST0",29,0)
 W !!,IOINHI,"Important!!",IOINORM,"  You must remember to start a new master job!!"
"RTN","HLEVMST0",30,0)
 ;
"RTN","HLEVMST0",31,0)
 D UNQ^HLEVUTIL(+LASTIEN,+LASTSK,"Master job stopped by "_$P($G(^VA(200,+$G(DUZ),0)),U)_".")
"RTN","HLEVMST0",32,0)
 ;
"RTN","HLEVMST0",33,0)
 D TELL("","0^0^999")
"RTN","HLEVMST0",34,0)
 ;
"RTN","HLEVMST0",35,0)
 Q
"RTN","HLEVMST0",36,0)
 ;
"RTN","HLEVMST0",37,0)
HDU W @IOF,$$CJ^XLFSTR("Unqueue Master Job",IOM)
"RTN","HLEVMST0",38,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVMST0",39,0)
 QUIT
"RTN","HLEVMST0",40,0)
 ;
"RTN","HLEVMST0",41,0)
EXU N I,T F I=1:1 S T=$T(EXU+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVMST0",42,0)
 ;;If a master job has been queued to a future time, it can be unqueued now.
"RTN","HLEVMST0",43,0)
 ;;
"RTN","HLEVMST0",44,0)
 ;;Note:  If you unqueue this task, no future master jobs will run until you
"RTN","HLEVMST0",45,0)
 ;;       manually start a new master job.  (Start new master jobs with the 
"RTN","HLEVMST0",46,0)
 ;;       '' menu option.)
"RTN","HLEVMST0",47,0)
 QUIT
"RTN","HLEVMST0",48,0)
 ;
"RTN","HLEVMST0",49,0)
MSTNOW ; Start queued master job now!
"RTN","HLEVMST0",50,0)
 N DIFF,LAST0,LASTDT,LASTIEN,NEXTH,SECNEXT,SECNOW,TASKNO,ZTDTH,ZTSK
"RTN","HLEVMST0",51,0)
 ;
"RTN","HLEVMST0",52,0)
 W @IOF,$$CJ^XLFSTR("Master Job ""Run Now"" Utility",IOM)
"RTN","HLEVMST0",53,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVMST0",54,0)
 W !
"RTN","HLEVMST0",55,0)
 ;
"RTN","HLEVMST0",56,0)
 S LASTDT=$O(^HLEV(776.2,"B",":"),-1) ; Last (probably queued) job time
"RTN","HLEVMST0",57,0)
 S LASTIEN=$O(^HLEV(776.2,"B",+LASTDT,":"),-1)
"RTN","HLEVMST0",58,0)
 S LAST0=$G(^HLEV(776.2,+LASTIEN,0)) I LAST0']"" D
"RTN","HLEVMST0",59,0)
 .  W !,"Couldn't find last master job entry..."
"RTN","HLEVMST0",60,0)
 ;
"RTN","HLEVMST0",61,0)
 S TASKNO=$P(LAST0,U,5) I '$D(^%ZTSK(+TASKNO)) D
"RTN","HLEVMST0",62,0)
 .  W !,"Couldn't find task",$S(TASKNO:"# "_TASKNO_"...",1:".")
"RTN","HLEVMST0",63,0)
 ;
"RTN","HLEVMST0",64,0)
 S TASK0=$G(^%ZTSK(+TASKNO,0)) I TASK0']""  D
"RTN","HLEVMST0",65,0)
 .  W !,"Couldn't find task# ",TASKNO,"'S zero node..."
"RTN","HLEVMST0",66,0)
 ;
"RTN","HLEVMST0",67,0)
 S NEXTH=$P(TASK0,U,6) I NEXTH'?1.N1","1.N D
"RTN","HLEVMST0",68,0)
 .  W !,"Invalid future queue time ($H)..."
"RTN","HLEVMST0",69,0)
 ;
"RTN","HLEVMST0",70,0)
 S SECNEXT=$$SEC(NEXTH)
"RTN","HLEVMST0",71,0)
 S SECNOW=$$SEC($H)
"RTN","HLEVMST0",72,0)
 ;
"RTN","HLEVMST0",73,0)
 S DIFF=SECNEXT-SECNOW
"RTN","HLEVMST0",74,0)
 I DIFF<60 D  QUIT  ;->
"RTN","HLEVMST0",75,0)
 .  I DIFF<1 W !,"Master job will start any moment!" QUIT  ;->
"RTN","HLEVMST0",76,0)
 .  W !,"Master job will start on its own in ",DIFF," seconds..."
"RTN","HLEVMST0",77,0)
 ;
"RTN","HLEVMST0",78,0)
 I '$D(^%ZTSCH(SECNEXT,TASKNO)) D
"RTN","HLEVMST0",79,0)
 .  W !,"Couldn't find ^%ZTSK(SEC,ZTSK) node..."
"RTN","HLEVMST0",80,0)
 ;
"RTN","HLEVMST0",81,0)
 W !,"This utility allows you to run the master job ahead of it's currently"
"RTN","HLEVMST0",82,0)
 W !,"scheduled time to run."
"RTN","HLEVMST0",83,0)
 ;
"RTN","HLEVMST0",84,0)
 W !!,"Master task# ",TASKNO," is queued to "
"RTN","HLEVMST0",85,0)
 W $$SDT^HLEVX001($$HTFM^XLFDT(NEXTH))
"RTN","HLEVMST0",86,0)
 W " and it will be started now..."
"RTN","HLEVMST0",87,0)
 ;
"RTN","HLEVMST0",88,0)
 W !
"RTN","HLEVMST0",89,0)
 I '$$YN^HLCSRPT4("OK to start now","No") D  QUIT  ;->
"RTN","HLEVMST0",90,0)
 .  W "     no action taken..."
"RTN","HLEVMST0",91,0)
 ;
"RTN","HLEVMST0",92,0)
 S ZTSK=TASKNO,ZTDTH=$H
"RTN","HLEVMST0",93,0)
 D REQ^%ZTLOAD
"RTN","HLEVMST0",94,0)
 ;
"RTN","HLEVMST0",95,0)
 W !!,"Master job requeued to 'now'..."
"RTN","HLEVMST0",96,0)
 ;
"RTN","HLEVMST0",97,0)
 Q
"RTN","HLEVMST0",98,0)
 ;
"RTN","HLEVMST0",99,0)
STARTMST ; Start brand new master job now (interactively)!
"RTN","HLEVMST0",100,0)
 N DIFF,IOINHI,IOINORM,LAST0,LASTDT,LASTIEN,NEXTH,SECNEXT
"RTN","HLEVMST0",101,0)
 N SECNOW,TASKNO,ZTDTH,ZTSK
"RTN","HLEVMST0",102,0)
 ;
"RTN","HLEVMST0",103,0)
 S LASTDT=$O(^HLEV(776.2,"B",":"),-1)
"RTN","HLEVMST0",104,0)
 S LASTIEN=$O(^HLEV(776.2,"B",+LASTDT,":"),-1)
"RTN","HLEVMST0",105,0)
 S LAST0=$G(^HLEV(776.2,+LASTIEN,0))
"RTN","HLEVMST0",106,0)
 S TASKNO=$P(LAST0,U,5)
"RTN","HLEVMST0",107,0)
 ;
"RTN","HLEVMST0",108,0)
 ; If this option is accessed by queued background job, just unqueue
"RTN","HLEVMST0",109,0)
 ; everything to make sure, and start a new master job for NOW...
"RTN","HLEVMST0",110,0)
 I $D(ZTQUEUED) D  QUIT  ;->
"RTN","HLEVMST0",111,0)
 .  D UNQ^HLEVUTIL(+LASTIEN,+TASKNO,"Reboot unqueue/requeue master job.")
"RTN","HLEVMST0",112,0)
 .  D STARTJOB^HLEVMST
"RTN","HLEVMST0",113,0)
 ;
"RTN","HLEVMST0",114,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLEVMST0",115,0)
 ;
"RTN","HLEVMST0",116,0)
 D HD
"RTN","HLEVMST0",117,0)
 D EX
"RTN","HLEVMST0",118,0)
 ;
"RTN","HLEVMST0",119,0)
 W !
"RTN","HLEVMST0",120,0)
 ;
"RTN","HLEVMST0",121,0)
 I $P(LAST0,U,4)="Q" D  QUIT  ;->
"RTN","HLEVMST0",122,0)
 .  D TELL("It appears as if task# "_$P(LAST0,U,5)_" has already been queued.","1^2^999")
"RTN","HLEVMST0",123,0)
 ;
"RTN","HLEVMST0",124,0)
 I $P(LAST0,U,5)>0 D
"RTN","HLEVMST0",125,0)
 .  W !!,"The ",IOINHI,"last",IOINORM
"RTN","HLEVMST0",126,0)
 .  W " master job was task# ",$P(LAST0,U,5),", queued "
"RTN","HLEVMST0",127,0)
 .  W $$FMTE^XLFDT(+LAST0),"."
"RTN","HLEVMST0",128,0)
 ;
"RTN","HLEVMST0",129,0)
 W !
"RTN","HLEVMST0",130,0)
 I '$$YN^HLCSRPT4("OK to start a "_IOINHI_"new"_IOINORM_" master task now","No") D  QUIT  ;->
"RTN","HLEVMST0",131,0)
 .  W "     no action taken..."
"RTN","HLEVMST0",132,0)
 ;
"RTN","HLEVMST0",133,0)
 D STARTJOB^HLEVMST
"RTN","HLEVMST0",134,0)
 ;
"RTN","HLEVMST0",135,0)
 D TELL("Press RETURN to exit... ","0^0^999")
"RTN","HLEVMST0",136,0)
 ;
"RTN","HLEVMST0",137,0)
 Q
"RTN","HLEVMST0",138,0)
 ;
"RTN","HLEVMST0",139,0)
HD W @IOF,$$CJ^XLFSTR("Master Job Start",IOM)
"RTN","HLEVMST0",140,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVMST0",141,0)
 QUIT
"RTN","HLEVMST0",142,0)
 ;
"RTN","HLEVMST0",143,0)
EX N I,T F I=1:1 S T=$T(EX+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVMST0",144,0)
 ;;This option will queue a new master job task if no master job is currently
"RTN","HLEVMST0",145,0)
 ;;running and no master job is queued for the future.
"RTN","HLEVMST0",146,0)
 ;;
"RTN","HLEVMST0",147,0)
 ;;Note:  A master job is queued every time the event monitoring software is
"RTN","HLEVMST0",148,0)
 ;;       installed, and every time the system is rebooted.  So, normally it
"RTN","HLEVMST0",149,0)
 ;;       is not necessary to use this option to create a new master job.  
"RTN","HLEVMST0",150,0)
 ;;       (The most common reason for using this option is if the queued
"RTN","HLEVMST0",151,0)
 ;;       master job was 'dequeued'.)
"RTN","HLEVMST0",152,0)
 QUIT
"RTN","HLEVMST0",153,0)
 ;
"RTN","HLEVMST0",154,0)
SEC(HORO) ; Convert $H to seconds...
"RTN","HLEVMST0",155,0)
 QUIT:HORO'?5.N1","1.N "" ;->
"RTN","HLEVMST0",156,0)
 QUIT ((86400*+HORO)+$P(HORO,",",2))
"RTN","HLEVMST0",157,0)
 ;
"RTN","HLEVMST0",158,0)
SECTHORO(SEC) ; Convert seconds to $H...
"RTN","HLEVMST0",159,0)
 N DAYS,SECH
"RTN","HLEVMST0",160,0)
 QUIT:SEC'?1.N "" ;->
"RTN","HLEVMST0",161,0)
 S DAYS=SEC\86400,SECH=SEC#86400
"RTN","HLEVMST0",162,0)
 QUIT DAYS_","_SECH
"RTN","HLEVMST0",163,0)
 ;
"RTN","HLEVMST0",164,0)
TELL(TXTINFO,ACT,TXTBT) ; Print TXTINFO, FF to bottom, and $$BTE(TXTBT)...
"RTN","HLEVMST0",165,0)
 ;
"RTN","HLEVMST0",166,0)
 ; ACT = #1 ^ #2 ^ #3 ^ #4 -> Controls pre-$$BTE positioning...
"RTN","HLEVMST0",167,0)
 ;
"RTN","HLEVMST0",168,0)
 ;       #1 => 0 = Spaces before printing TXTINFO (See #2). 
"RTN","HLEVMST0",169,0)
 ;             1 = Lines before printing TXTINFO (see #2).  [DEFAULT]
"RTN","HLEVMST0",170,0)
 ;       #2 => # = # Spaces (if #1=0) or lines (if #1=1-DEFAULT)
"RTN","HLEVMST0",171,0)
 ;       #3 => # = # lines before printing TXTBT (see #4).
"RTN","HLEVMST0",172,0)
 ;                 (# lines printed will never exceed IOSL unless
"RTN","HLEVMST0",173,0)
 ;                 overridden by #4.  Entering #3=999 just ensures that
"RTN","HLEVMST0",174,0)
 ;                 line feeds will be issued until cursor is at bottom
"RTN","HLEVMST0",175,0)
 ;                 of screen.
"RTN","HLEVMST0",176,0)
 ;       #4 => # = # lines that **must** be printed before TXTBT.
"RTN","HLEVMST0",177,0)
 ;
"RTN","HLEVMST0",178,0)
 ; Examples...
"RTN","HLEVMST0",179,0)
 ;
"RTN","HLEVMST0",180,0)
 ; 0^3^999^5 - Prints 3 spaces, TXTINFO and FFs to bottom.  If the 
"RTN","HLEVMST0",181,0)
 ;             screen was full when TELL was called, only one FF would
"RTN","HLEVMST0",182,0)
 ;             normally be issued (minimum, for spacing purposes).
"RTN","HLEVMST0",183,0)
 ;             However, the '5' ensures that at least 5 LFs are issued.
"RTN","HLEVMST0",184,0)
 ;             Then, TXTBT printed.
"RTN","HLEVMST0",185,0)
 ;
"RTN","HLEVMST0",186,0)
 ; 1^2^2     - Prints 2 LFs, TXTINFO, and 2 LFs, then TXTBT.  (If the
"RTN","HLEVMST0",187,0)
 ;             screen was full when TELL called, only 1 LF would be
"RTN","HLEVMST0",188,0)
 ;             printed before printing TXTBT.)
"RTN","HLEVMST0",189,0)
 ;
"RTN","HLEVMST0",190,0)
 N I,X
"RTN","HLEVMST0",191,0)
 ;
"RTN","HLEVMST0",192,0)
 S ACT=$G(ACT),TXTINFO=$G(TXTINFO)
"RTN","HLEVMST0",193,0)
 S TXTBT=$S($G(TXTBT)]"":TXTBT,1:"Press RETURN to exit... ")
"RTN","HLEVMST0",194,0)
 ;
"RTN","HLEVMST0",195,0)
 ; Default to line feeds...
"RTN","HLEVMST0",196,0)
 S:$P(ACT,U)'=0&($P(ACT,U)'=1) $P(ACT,U)=1
"RTN","HLEVMST0",197,0)
 ;
"RTN","HLEVMST0",198,0)
 ; Default to 1 line feed or 3 spaces...
"RTN","HLEVMST0",199,0)
 S:$P(ACT,U,2)'?1.N $P(ACT,U,2)=$S(+ACT=0:3,1:1)
"RTN","HLEVMST0",200,0)
 ;
"RTN","HLEVMST0",201,0)
 ; Default to bottom of form trailing lines...
"RTN","HLEVMST0",202,0)
 S:$P(ACT,U,3)'?1.N $P(ACT,U,3)=999
"RTN","HLEVMST0",203,0)
 ;
"RTN","HLEVMST0",204,0)
 ; Default to minimum lines after printing TXTINFO...
"RTN","HLEVMST0",205,0)
 S:$P(ACT,U,4)'?1.N $P(ACT,U,4)=1
"RTN","HLEVMST0",206,0)
 ;
"RTN","HLEVMST0",207,0)
 I +ACT=0 X "F I=1:1:$P(ACT,U,2) W "" """ W TXTINFO
"RTN","HLEVMST0",208,0)
 I +ACT=1 X "F I=1:1:$P(ACT,U,2) W !" W TXTINFO
"RTN","HLEVMST0",209,0)
 ;
"RTN","HLEVMST0",210,0)
 S ACT=$P(ACT,U,3,4)
"RTN","HLEVMST0",211,0)
 ;
"RTN","HLEVMST0",212,0)
 ; If positive, always issue at least one line feed...
"RTN","HLEVMST0",213,0)
 I ACT W ! S $P(ACT,U)=$P(ACT,U)-1
"RTN","HLEVMST0",214,0)
 ;
"RTN","HLEVMST0",215,0)
 F I=1:1:ACT Q:($Y+3)>IOSL&(ACT>$P(ACT,U,2))  W !
"RTN","HLEVMST0",216,0)
 ;
"RTN","HLEVMST0",217,0)
 S X=$$BTE^HLCSMON(TXTBT)
"RTN","HLEVMST0",218,0)
 ;
"RTN","HLEVMST0",219,0)
 Q
"RTN","HLEVMST0",220,0)
 ;
"RTN","HLEVMST0",221,0)
EOR ;HLEVMST0 - Event Monitor MASTER JOB ;5/16/03 14:42
"RTN","HLEVREP")
0^11^B58965492
"RTN","HLEVREP",1,0)
HLEVREP ;O-OIFO/LJA - Event Monitor REPORTS ;02/04/2004 14:42
"RTN","HLEVREP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVREP",3,0)
 ;
"RTN","HLEVREP",4,0)
SHOWONE ; Show entry in any Event Monitoring file...
"RTN","HLEVREP",5,0)
 ;
"RTN","HLEVREP",6,0)
 ;
"RTN","HLEVREP",7,0)
CTRL ;
"RTN","HLEVREP",8,0)
 ;
"RTN","HLEVREP",9,0)
 D HD
"RTN","HLEVREP",10,0)
 D EX
"RTN","HLEVREP",11,0)
 F  Q:(IOSL-$Y)<4  W !
"RTN","HLEVREP",12,0)
 QUIT:$$BTE^HLCSMON("Press RETURN to continue, '^' to exit... ")  ;->
"RTN","HLEVREP",13,0)
CTRL1 D HD
"RTN","HLEVREP",14,0)
 W !!,"You must now select one of the following files..."
"RTN","HLEVREP",15,0)
 S FILE=$$FILE QUIT:FILE'>0  ;->
"RTN","HLEVREP",16,0)
 W !
"RTN","HLEVREP",17,0)
 D @("SHOW"_FILE)
"RTN","HLEVREP",18,0)
 G CTRL1 ;->
"RTN","HLEVREP",19,0)
 ;
"RTN","HLEVREP",20,0)
 ;
"RTN","HLEVREP",21,0)
 ;
"RTN","HLEVREP",22,0)
SHOW7761 ; Show HL7 Monitor (#776.1) entries...
"RTN","HLEVREP",23,0)
 N DIC,IEN
"RTN","HLEVREP",24,0)
 D HDR("View 'HL7 Monitor file (#776.1)' Entries")
"RTN","HLEVREP",25,0)
 ;
"RTN","HLEVREP",26,0)
S7761 KILL DIC,IEN
"RTN","HLEVREP",27,0)
 W !
"RTN","HLEVREP",28,0)
 S IEN=$$ASKIEN(776.1) QUIT:IEN'>0  ;->
"RTN","HLEVREP",29,0)
 W !!,"Loading report..."
"RTN","HLEVREP",30,0)
 D LOAD7761(IEN)
"RTN","HLEVREP",31,0)
 D BROWSE^DDBR($NA(^TMP($J,"HL7761")),"N","View 'HL7 Monitor file (#776.1)' Entries")
"RTN","HLEVREP",32,0)
 KILL ^TMP($J,"HL7761")
"RTN","HLEVREP",33,0)
 G S7761 ;->
"RTN","HLEVREP",34,0)
 ;
"RTN","HLEVREP",35,0)
LOAD7761(IEN) ; Load browswer global...
"RTN","HLEVREP",36,0)
 KILL ^TMP($J,"HL7761")
"RTN","HLEVREP",37,0)
 D BODY7761(IEN)
"RTN","HLEVREP",38,0)
 D RUNS7761(IEN)
"RTN","HLEVREP",39,0)
 Q
"RTN","HLEVREP",40,0)
 ;
"RTN","HLEVREP",41,0)
RUNS7761(EVIEN) ;
"RTN","HLEVREP",42,0)
 N DATA,IEN,LASTDT,RUNS
"RTN","HLEVREP",43,0)
 ;
"RTN","HLEVREP",44,0)
 KILL ^TMP($J,"HLRUNS")
"RTN","HLEVREP",45,0)
 ;
"RTN","HLEVREP",46,0)
 ; Loop thru master job runs looking for event monitor checks...
"RTN","HLEVREP",47,0)
 S LASTDT=":",RUNS=0
"RTN","HLEVREP",48,0)
 F  S LASTDT=$O(^HLEV(776.2,"B",LASTDT),-1) Q:'LASTDT!(RUNS>6)  D
"RTN","HLEVREP",49,0)
 .  S IEN=":"
"RTN","HLEVREP",50,0)
 .  F  S IEN=$O(^HLEV(776.2,"B",+LASTDT,IEN),-1) Q:'IEN!(RUNS>6)  D
"RTN","HLEVREP",51,0)
 .  .  S MIEN=$O(^HLEV(776.2,+IEN,51,"B",EVIEN,0)) QUIT:MIEN'>0  ;->
"RTN","HLEVREP",52,0)
 .  .  S DATA=$G(^HLEV(776.2,+IEN,51,MIEN,0))
"RTN","HLEVREP",53,0)
 .  .  S ^TMP($J,"HLRUNS",IEN)=$P(DATA,U,2)_U_$P(DATA,U,3) ; STATUS^TIME
"RTN","HLEVREP",54,0)
 .  .  S RUNS=RUNS+1
"RTN","HLEVREP",55,0)
 ;
"RTN","HLEVREP",56,0)
 ; If none found...
"RTN","HLEVREP",57,0)
 QUIT:'$D(^TMP($J,"HLRUNS"))  ;->
"RTN","HLEVREP",58,0)
 ;
"RTN","HLEVREP",59,0)
 ; Recent master job checks of monitor...
"RTN","HLEVREP",60,0)
 D ADD7761(""),ADD7761("Recent Master Job Checks of this Monitor")
"RTN","HLEVREP",61,0)
 D ADD7761($$REPEAT^XLFSTR("-",74))
"RTN","HLEVREP",62,0)
 S IEN=0
"RTN","HLEVREP",63,0)
 F  S IEN=$O(^TMP($J,"HLRUNS",IEN)) Q:'IEN  D
"RTN","HLEVREP",64,0)
 .  S DATA=^TMP($J,"HLRUNS",IEN)
"RTN","HLEVREP",65,0)
 .  D ADD7761($E($$SDT^HLEVX001($P(DATA,U,2))_$$REPEAT^XLFSTR(" ",17),1,17)_"  "_$$STAT2M^HLEVX001($P(DATA,U)))
"RTN","HLEVREP",66,0)
 ;
"RTN","HLEVREP",67,0)
 Q
"RTN","HLEVREP",68,0)
 ;
"RTN","HLEVREP",69,0)
BODY7761(IEN) ; Actual display code for entry...
"RTN","HLEVREP",70,0)
 N NODE,P1,P2,P3,P4,P5,P6,PAR,PCE
"RTN","HLEVREP",71,0)
 ;
"RTN","HLEVREP",72,0)
 S NODE=$G(^HLEV(776.1,+IEN,0))
"RTN","HLEVREP",73,0)
 F PCE=1:1:6 S @("P"_PCE)=$P(NODE,U,PCE)
"RTN","HLEVREP",74,0)
 ;
"RTN","HLEVREP",75,0)
 ; Store under field number...
"RTN","HLEVREP",76,0)
 F PCE=1:1:8 S PAR(PCE)=$P($G(^HLEV(776.1,+IEN,40)),U,PCE)
"RTN","HLEVREP",77,0)
 ;
"RTN","HLEVREP",78,0)
 D SH7761("Monitor",$S(P1]"":P1,1:"---"))
"RTN","HLEVREP",79,0)
 D SH7761("Description",$S(P3]"":P3,1:"---"))
"RTN","HLEVREP",80,0)
 D SH7761("Status",$S(P2="A":"ACTIVE",1:"INACTIVE"))
"RTN","HLEVREP",81,0)
 D SH7761("Requeue minutes",$S(P4:P4_"min",P4=0:"0 [Immediate Run]",1:"---"))
"RTN","HLEVREP",82,0)
 D SH7761("M startup",$S(P6]"":P6,1:"---"))
"RTN","HLEVREP",83,0)
 D XMYS(+IEN)
"RTN","HLEVREP",84,0)
 W !,$$CJ^XLFSTR(" Parameter ""Variable"" Descriptors ",IOM,"-")
"RTN","HLEVREP",85,0)
 F PCE=1:1:8 I PAR(PCE)]"" D
"RTN","HLEVREP",86,0)
 .  W !,?25,"Parameter - "_PCE_" = ",PAR(PCE)
"RTN","HLEVREP",87,0)
 ;
"RTN","HLEVREP",88,0)
 D SHWP(776.1,IEN,41,"Parameter Notes")
"RTN","HLEVREP",89,0)
 D SHWP(776.1,IEN,50,"Event Description")
"RTN","HLEVREP",90,0)
 ;
"RTN","HLEVREP",91,0)
 Q
"RTN","HLEVREP",92,0)
 ;
"RTN","HLEVREP",93,0)
XMYS(HLEVIENE) ; Add XMYs from monitor...
"RTN","HLEVREP",94,0)
 N REC,TAG,XMY
"RTN","HLEVREP",95,0)
 D ADDXMYS^HLEVAPI2(+HLEVIENE) QUIT:'$D(XMY)  ;->
"RTN","HLEVREP",96,0)
 S VAL=""
"RTN","HLEVREP",97,0)
 F  S VAL=$O(XMY(VAL)) Q:VAL']""  D
"RTN","HLEVREP",98,0)
 .  I VAL["@" S REC(VAL)="" QUIT  ;->
"RTN","HLEVREP",99,0)
 .  I VAL=+VAL S VAL=$P($G(^VA(200,+VAL,0)),U) S:VAL]"" REC(VAL)="" QUIT  ;->
"RTN","HLEVREP",100,0)
 .  I $E(VAL,1,2)="G." S REC(VAL)=""
"RTN","HLEVREP",101,0)
 KILL XMY
"RTN","HLEVREP",102,0)
 QUIT:'$D(REC)  ;->
"RTN","HLEVREP",103,0)
 S VAL=""
"RTN","HLEVREP",104,0)
 S TAG=$E("                    Recipients:                ",1,35)
"RTN","HLEVREP",105,0)
 F  S VAL=$O(REC(VAL)) Q:VAL']""  D
"RTN","HLEVREP",106,0)
 .  S TAG=TAG_VAL
"RTN","HLEVREP",107,0)
 .  D ADD7761(TAG)
"RTN","HLEVREP",108,0)
 .  S TAG=$$REPEAT^XLFSTR(" ",35)
"RTN","HLEVREP",109,0)
 Q
"RTN","HLEVREP",110,0)
 ;
"RTN","HLEVREP",111,0)
SHWP(FILE,IEN,HLN,TAG) ;
"RTN","HLEVREP",112,0)
 N MIEN,TXT
"RTN","HLEVREP",113,0)
 QUIT:$O(^HLEV(FILE,+IEN,HLN,0))'>0  ;-> No data...
"RTN","HLEVREP",114,0)
 S TXT=$$CJ^XLFSTR(" "_TAG_" ",IOM,"-")
"RTN","HLEVREP",115,0)
 D ADD7761(TXT)
"RTN","HLEVREP",116,0)
 S MIEN=0
"RTN","HLEVREP",117,0)
 F  S MIEN=$O(^HLEV(FILE,+IEN,HLN,MIEN)) Q:MIEN'>0  D
"RTN","HLEVREP",118,0)
 .  D ADD7761(^HLEV(FILE,+IEN,HLN,MIEN,0))
"RTN","HLEVREP",119,0)
 Q
"RTN","HLEVREP",120,0)
 ;
"RTN","HLEVREP",121,0)
SH7761(TAG,VAL) ;
"RTN","HLEVREP",122,0)
 N TXT
"RTN","HLEVREP",123,0)
 S TXT=$E($$REPEAT^XLFSTR(" ",80),1,(32-$L(TAG)-2))_TAG_":"
"RTN","HLEVREP",124,0)
 S TXT=$E(TXT_$$REPEAT^XLFSTR(" ",45),1,35)_VAL
"RTN","HLEVREP",125,0)
 D ADD7761(TXT)
"RTN","HLEVREP",126,0)
 Q
"RTN","HLEVREP",127,0)
 ;
"RTN","HLEVREP",128,0)
ADD7761(TXT) ; Add TXT to browser global...
"RTN","HLEVREP",129,0)
 N NO
"RTN","HLEVREP",130,0)
 S NO=$O(^TMP($J,"HL7761",":"),-1)+1
"RTN","HLEVREP",131,0)
 S ^TMP($J,"HL7761",+NO)=TXT
"RTN","HLEVREP",132,0)
 Q
"RTN","HLEVREP",133,0)
 ;
"RTN","HLEVREP",134,0)
SHOW776 ; Show HL7 Monitor Job (#776) entries...
"RTN","HLEVREP",135,0)
 N DIC,IEN
"RTN","HLEVREP",136,0)
S776 KILL DIC,IEN
"RTN","HLEVREP",137,0)
 S IEN=$$ASKIEN(776) QUIT:IEN'>0  ;->
"RTN","HLEVREP",138,0)
 D VIEW776(+IEN)
"RTN","HLEVREP",139,0)
 W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLEVREP",140,0)
 G S776 ;->
"RTN","HLEVREP",141,0)
 ;
"RTN","HLEVREP",142,0)
VIEW776(IEN) ; Actual display code for entry...
"RTN","HLEVREP",143,0)
 ;
"RTN","HLEVREP",144,0)
 W !!,"View Code to be placed here..."
"RTN","HLEVREP",145,0)
 Q
"RTN","HLEVREP",146,0)
 ;
"RTN","HLEVREP",147,0)
 ;
"RTN","HLEVREP",148,0)
SHOW7762 ; Show HL7 Monitor Master Job (#776.2) entries...
"RTN","HLEVREP",149,0)
 N DIC,IEN
"RTN","HLEVREP",150,0)
S7762 KILL DIC,IEN
"RTN","HLEVREP",151,0)
 S IEN=$$ASKIEN(776.2) QUIT:IEN'>0  ;->
"RTN","HLEVREP",152,0)
 D VIEW7762(+IEN)
"RTN","HLEVREP",153,0)
 W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLEVREP",154,0)
 G S7762 ;->
"RTN","HLEVREP",155,0)
 ;
"RTN","HLEVREP",156,0)
VIEW7762 ; Actual display code for entry...
"RTN","HLEVREP",157,0)
 ;
"RTN","HLEVREP",158,0)
 W !!,"View Code to be placed here..."
"RTN","HLEVREP",159,0)
 Q
"RTN","HLEVREP",160,0)
 ;
"RTN","HLEVREP",161,0)
 ;
"RTN","HLEVREP",162,0)
SHOW7769 ; Show HL7 Monitor Parameters (#776.999) entries...
"RTN","HLEVREP",163,0)
 D VIEW7769(1)
"RTN","HLEVREP",164,0)
 W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLEVREP",165,0)
 Q
"RTN","HLEVREP",166,0)
 ;
"RTN","HLEVREP",167,0)
VIEW7769(BT) ; Actual display code for entry...
"RTN","HLEVREP",168,0)
 N DATA,NODE,P1,P2,P3,P4,P5,P6,PCE,TAG,VAL
"RTN","HLEVREP",169,0)
 ;
"RTN","HLEVREP",170,0)
 S NODE=$G(^HLEV(776.999,1,0)) I NODE']"" D  QUIT  ;->
"RTN","HLEVREP",171,0)
 .  W !,"No system entry exists..."
"RTN","HLEVREP",172,0)
 ;
"RTN","HLEVREP",173,0)
 F PCE=1:1:6 S @("P"_PCE)=$P(NODE,U,PCE)
"RTN","HLEVREP",174,0)
 ;
"RTN","HLEVREP",175,0)
 S NODE(1)=P1_U_"Name"
"RTN","HLEVREP",176,0)
 S NODE(2)=$S(P2="A":"ACTIVE",1:"INACTIVE")_U_"Status - MASTER"
"RTN","HLEVREP",177,0)
 S NODE(3)=P3_"min"_U_"Requeue minutes - MASTER"
"RTN","HLEVREP",178,0)
 S NODE(4)=P4_"hr"_U_"Purge hours - RUNTIME DATA"
"RTN","HLEVREP",179,0)
 S NODE(6)=$S(P6="A":"ACTIVE",1:"INACTIVE")_U_"Status - EVENT"
"RTN","HLEVREP",180,0)
 ;
"RTN","HLEVREP",181,0)
 W @IOF,$$CJ^XLFSTR("System Parameters",IOM)
"RTN","HLEVREP",182,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVREP",183,0)
 ;
"RTN","HLEVREP",184,0)
 F PCE=1,"Status Fields",2,6,"Requeue Frequency for Master Job",3,"Purge Parameters (""Cutoff"" hours)",4 D
"RTN","HLEVREP",185,0)
 .  I PCE'=+PCE D  QUIT  ;->
"RTN","HLEVREP",186,0)
 .  .  W !!,$$CJ^XLFSTR(PCE,IOM)
"RTN","HLEVREP",187,0)
 .  .  W !,$$CJ^XLFSTR($$REPEAT^XLFSTR("-",$L(PCE)+20),IOM)
"RTN","HLEVREP",188,0)
 .  S DATA=NODE(PCE),VAL=$P(DATA,U),TAG=$P(DATA,U,2)
"RTN","HLEVREP",189,0)
 .  S DATA=TAG_":   "_VAL
"RTN","HLEVREP",190,0)
 .  W !,$$CJ^XLFSTR(DATA,IOM)
"RTN","HLEVREP",191,0)
 ;
"RTN","HLEVREP",192,0)
 I $G(BT) D TELL^HLEVMST0("","0^0^999")
"RTN","HLEVREP",193,0)
 ;
"RTN","HLEVREP",194,0)
 Q
"RTN","HLEVREP",195,0)
 ;
"RTN","HLEVREP",196,0)
 ;
"RTN","HLEVREP",197,0)
ASKIEN(FILE,HLAYGO) ; Generic DIC lookup...
"RTN","HLEVREP",198,0)
 N DIC,X,Y
"RTN","HLEVREP",199,0)
 S DIC=FILE,DIC(0)="AEMQN"_$G(HLAYGO)
"RTN","HLEVREP",200,0)
 S DIC("A")="Select "_$S(FILE=776:"EVENT ""RUN"" ENTRY",FILE=776.1:"EVENT MONITOR ENTRY",FILE=776.2:"MASTER JOB ""RUN"" ENTRY",FILE=776.999:"PARAMETER ENTRY",1:"??")_": "
"RTN","HLEVREP",201,0)
 D ^DIC
"RTN","HLEVREP",202,0)
 Q $S(+Y>0:+Y,1:"")
"RTN","HLEVREP",203,0)
 ;
"RTN","HLEVREP",204,0)
FILE() ; Get from user file to display information...
"RTN","HLEVREP",205,0)
 N ANS,DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLEVREP",206,0)
 S DIR(0)="SO^1:HL7 Monitor file (#776.1);2:HL7 Monitor Parameters file (#776.999);3:HL7 Monitor Job file (#776);4:HL7 Monitor Master Job file (#776.2);5:Exit this option"
"RTN","HLEVREP",207,0)
 S DIR("A")="Select OPTION"
"RTN","HLEVREP",208,0)
 D ^DIR
"RTN","HLEVREP",209,0)
 S ANS=+Y\1,ANS=$S(ANS>0&(ANS<5):+ANS,1:"")
"RTN","HLEVREP",210,0)
 S ANS=$S(ANS:$P("7761^7769^776^7762",U,+ANS),1:"")
"RTN","HLEVREP",211,0)
 Q ANS
"RTN","HLEVREP",212,0)
 ;
"RTN","HLEVREP",213,0)
HD W @IOF,$$CJ^XLFSTR("Display Event Monitoring Entries",IOM)
"RTN","HLEVREP",214,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVREP",215,0)
 QUIT
"RTN","HLEVREP",216,0)
 ;
"RTN","HLEVREP",217,0)
EX N I,T F I=1:1 S T=$T(EX+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVREP",218,0)
 ;;           This option displays entries from the following files:
"RTN","HLEVREP",219,0)
 ;;   
"RTN","HLEVREP",220,0)
 ;;                             SETUP-RELATED FILES
"RTN","HLEVREP",221,0)
 ;;             ----------------------------------------------------
"RTN","HLEVREP",222,0)
 ;;                       HL7 Monitor file (#776.1)
"RTN","HLEVREP",223,0)
 ;;                       HL7 Monitor Parameters file (#776.999)
"RTN","HLEVREP",224,0)
 ;;
"RTN","HLEVREP",225,0)
 ;;                            RUNTIME-RELATED FILES
"RTN","HLEVREP",226,0)
 ;;             ----------------------------------------------------
"RTN","HLEVREP",227,0)
 ;;                       HL7 Monitor Job file (#776)
"RTN","HLEVREP",228,0)
 ;;                       HL7 Monitor Master Job file (#776.2)
"RTN","HLEVREP",229,0)
 Q
"RTN","HLEVREP",230,0)
 ;
"RTN","HLEVREP",231,0)
HDR(TXT,IEN) W @IOF,$$CJ^XLFSTR(TXT,IOM)
"RTN","HLEVREP",232,0)
 N IOINHI,IOINORM,NAME,X,Y
"RTN","HLEVREP",233,0)
 I $G(IEN) D
"RTN","HLEVREP",234,0)
 .  S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLEVREP",235,0)
 .  S NAME=$P($G(^HLEV(776.1,+IEN,0)),U)
"RTN","HLEVREP",236,0)
 .  W !,$$CJ^XLFSTR(IOINHI_NAME_" [#"_IEN_"]"_IOINORM,IOM)
"RTN","HLEVREP",237,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVREP",238,0)
 Q
"RTN","HLEVREP",239,0)
 ;
"RTN","HLEVREP",240,0)
EOR ;HLEVREP - Event Monitor REPORTS ;5/16/03 14:42
"RTN","HLEVREP0")
0^12^B25914126
"RTN","HLEVREP0",1,0)
HLEVREP0 ;O-OIFO/LJA - Event Monitor REPORTS ;02/04/2004 14:42
"RTN","HLEVREP0",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVREP0",3,0)
 ;
"RTN","HLEVREP0",4,0)
RECIP ; Called by [HLEV REPORT MONITOR RECIPIENTS]
"RTN","HLEVREP0",5,0)
 N OPTYPE
"RTN","HLEVREP0",6,0)
 S OPTYPE=""
"RTN","HLEVREP0",7,0)
RECIP1 KILL ^TMP($J,"HLMREP")
"RTN","HLEVREP0",8,0)
 D HD("Monitor Recipients Reports")
"RTN","HLEVREP0",9,0)
 D EXRECIP
"RTN","HLEVREP0",10,0)
 S OPTYPE=$$RECIPO(OPTYPE) QUIT:OPTYPE']""  ;->
"RTN","HLEVREP0",11,0)
 D RECIPLD
"RTN","HLEVREP0",12,0)
 D @OPTYPE
"RTN","HLEVREP0",13,0)
 G RECIP1 ;->
"RTN","HLEVREP0",14,0)
 ;
"RTN","HLEVREP0",15,0)
RECIPMR ; List by monitor/recipient...
"RTN","HLEVREP0",16,0)
 D RECIPR("M")
"RTN","HLEVREP0",17,0)
 D BROWSE^DDBR($NA(^TMP($J,"HLMREP","REP")),"N","            Monitor                            Recipient                         ")
"RTN","HLEVREP0",18,0)
 Q
"RTN","HLEVREP0",19,0)
 ;
"RTN","HLEVREP0",20,0)
RECIPRM ; List by recipient/monitor...
"RTN","HLEVREP0",21,0)
 D RECIPR("R")
"RTN","HLEVREP0",22,0)
 D BROWSE^DDBR($NA(^TMP($J,"HLMREP","REP")),"N","            Recipient                          Monitor                           ")
"RTN","HLEVREP0",23,0)
 Q
"RTN","HLEVREP0",24,0)
 ;
"RTN","HLEVREP0",25,0)
RECIPR(SUB) ; Create displayable report...
"RTN","HLEVREP0",26,0)
 N CT,CTIN,SUB1,SUB1L,SUB2,SUB2L,STAT,TXT
"RTN","HLEVREP0",27,0)
 S SUB1="",CT=0,CTIN=0,SUB1L="",SUB2L=""
"RTN","HLEVREP0",28,0)
 F  S SUB1=$O(^TMP($J,"HLMREP",SUB,SUB1)) Q:SUB1']""  D
"RTN","HLEVREP0",29,0)
 .  S SUB2=""
"RTN","HLEVREP0",30,0)
 .  F  S SUB2=$O(^TMP($J,"HLMREP",SUB,SUB1,SUB2)) Q:SUB2']""  D
"RTN","HLEVREP0",31,0)
 .  .  S STAT=$G(^TMP($J,"HLMREP",SUB,SUB1,SUB2))
"RTN","HLEVREP0",32,0)
 .  .  I STAT'="A" S CTIN=CTIN+1 ; Inactive status counter
"RTN","HLEVREP0",33,0)
 .  .  S STAT=$S(STAT'="A":"* ",1:"  ")
"RTN","HLEVREP0",34,0)
 .  .  S TXT=$$PRT(SUB1,SUB1L,STAT)_$$PRT(SUB2,SUB2L)
"RTN","HLEVREP0",35,0)
 .  .  D ADD(TXT)
"RTN","HLEVREP0",36,0)
 .  .  S CT=CT+1
"RTN","HLEVREP0",37,0)
 .  .  S SUB1L=SUB1,SUB2L=SUB2
"RTN","HLEVREP0",38,0)
 Q
"RTN","HLEVREP0",39,0)
 ;
"RTN","HLEVREP0",40,0)
PRT(P1,P1L,ST) ; Format part of display line...
"RTN","HLEVREP0",41,0)
 ; CT -- req
"RTN","HLEVREP0",42,0)
 N TXT
"RTN","HLEVREP0",43,0)
 S TXT=$S($G(ST)]"":"  ",1:"")_$E($S(P1'=P1L:P1,1:"")_$$REPEAT^XLFSTR("-",35),1,33)_"  "
"RTN","HLEVREP0",44,0)
 Q TXT
"RTN","HLEVREP0",45,0)
 ;
"RTN","HLEVREP0",46,0)
ADD(TXT) ;
"RTN","HLEVREP0",47,0)
 N NO
"RTN","HLEVREP0",48,0)
 S NO=$O(^TMP($J,"HLMREP","REP",":"),-1)+1
"RTN","HLEVREP0",49,0)
 S ^TMP($J,"HLMREP","REP",+NO)=TXT
"RTN","HLEVREP0",50,0)
 Q
"RTN","HLEVREP0",51,0)
 ;
"RTN","HLEVREP0",52,0)
RECIPLD ; Load monitor and recipient data...
"RTN","HLEVREP0",53,0)
 N DATA,IEN7761,MONM,STAT
"RTN","HLEVREP0",54,0)
 S IEN7761=0
"RTN","HLEVREP0",55,0)
 F  S IEN7761=$O(^HLEV(776.1,IEN7761)) Q:IEN7761'>0  D
"RTN","HLEVREP0",56,0)
 .  S DATA=$G(^HLEV(776.1,+IEN7761,0)) QUIT:DATA']""  ;->
"RTN","HLEVREP0",57,0)
 .  S MONM=$$UP^XLFSTR($P(DATA,U)) QUIT:DATA']""  ;->
"RTN","HLEVREP0",58,0)
 .  S STAT=$S($P(DATA,U,2)="A":"ACTIVE",1:"INACTIVE")
"RTN","HLEVREP0",59,0)
 .  D RECIPM(MONM,IEN7761,STAT,60) ; Load mail groups...
"RTN","HLEVREP0",60,0)
 .  D RECIPM(MONM,IEN7761,STAT,61) ; Load local recipients...
"RTN","HLEVREP0",61,0)
 .  D RECIPM(MONM,IEN7761,STAT,62) ; Load remotes...
"RTN","HLEVREP0",62,0)
 Q
"RTN","HLEVREP0",63,0)
 ;
"RTN","HLEVREP0",64,0)
RECIPM(MONM,IEN7761,STAT,SUBDD) ; Load two globals...
"RTN","HLEVREP0",65,0)
 N MIEN,RECIP
"RTN","HLEVREP0",66,0)
 S MIEN=0
"RTN","HLEVREP0",67,0)
 F  S MIEN=$O(^HLEV(776.1,+IEN7761,SUBDD,MIEN)) Q:MIEN'>0  D
"RTN","HLEVREP0",68,0)
 .  S RECIP=$$UP^XLFSTR($P($G(^HLEV(776.1,+IEN7761,+SUBDD,MIEN,0)),U))
"RTN","HLEVREP0",69,0)
 .  QUIT:RECIP']""  ;->
"RTN","HLEVREP0",70,0)
 .  I SUBDD=60 D  QUIT:RECIP']""  ;->
"RTN","HLEVREP0",71,0)
 .  .  S RECIP=$P($G(^XMB(3.8,+RECIP,0)),U) QUIT:RECIP']""  ;->
"RTN","HLEVREP0",72,0)
 .  .  S RECIP="G."_RECIP
"RTN","HLEVREP0",73,0)
 .  I SUBDD=61 D  QUIT:RECIP']""  ;->
"RTN","HLEVREP0",74,0)
 .  .  S RECIP=$P($G(^VA(200,+RECIP,0)),U)
"RTN","HLEVREP0",75,0)
 .  S ^TMP($J,"HLMREP","M",MONM_"[#"_IEN7761_"]",RECIP)=STAT
"RTN","HLEVREP0",76,0)
 .  S ^TMP($J,"HLMREP","R",RECIP,MONM_"[#"_IEN7761_"]")=STAT
"RTN","HLEVREP0",77,0)
 Q
"RTN","HLEVREP0",78,0)
 ;
"RTN","HLEVREP0",79,0)
RECIPO(PMT) ; Mon/Recip or Recip/Mon
"RTN","HLEVREP0",80,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLEVREP0",81,0)
 S DIR(0)="S^1:List monitors/recipients;2:List recipients/monitors;3:Exit"
"RTN","HLEVREP0",82,0)
 S DIR("A")="Select REPORT FORMAT"
"RTN","HLEVREP0",83,0)
 S DIR("B")=$S(PMT="RECIPMR":"List recipients/monitors",1:"List monitors/recipients")
"RTN","HLEVREP0",84,0)
 D ^DIR
"RTN","HLEVREP0",85,0)
 QUIT:+Y<1!(+Y>2) "" ;->
"RTN","HLEVREP0",86,0)
 Q $P("RECIPMR^RECIPRM",U,+Y)
"RTN","HLEVREP0",87,0)
 ;
"RTN","HLEVREP0",88,0)
EXRECIP N I,T F I=1:1 S T=$T(EXRECIP+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVREP0",89,0)
 ;;This option lists the monitors and monitor recipients in two formats: sorted
"RTN","HLEVREP0",90,0)
 ;;by monitor and within monitor by recipient.  And, by recipient, and withing
"RTN","HLEVREP0",91,0)
 ;;recipient by monitor.
"RTN","HLEVREP0",92,0)
 QUIT
"RTN","HLEVREP0",93,0)
 ;
"RTN","HLEVREP0",94,0)
CONDMON ; Called by [HLEV REPORT CONDENSED MONITOR]
"RTN","HLEVREP0",95,0)
 N BY,DIC,FLDS,L
"RTN","HLEVREP0",96,0)
 D HD("Short Monitor Report")
"RTN","HLEVREP0",97,0)
 W !
"RTN","HLEVREP0",98,0)
 D EXCMON
"RTN","HLEVREP0",99,0)
 S L="",DIC="^HLEV(776.1,",FLDS="[HLEV REPORT MONITOR-ONE LINE]"
"RTN","HLEVREP0",100,0)
 S BY="[HLEV REPORT MONITOR]"
"RTN","HLEVREP0",101,0)
 D EN1^DIP
"RTN","HLEVREP0",102,0)
 D TELL^HLEVMST0("")
"RTN","HLEVREP0",103,0)
 Q
"RTN","HLEVREP0",104,0)
 ;
"RTN","HLEVREP0",105,0)
EXCMON N I,T F I=1:1 S T=$T(EXCMON+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVREP0",106,0)
 ;;This option displays monitor information in brief format.  If you wish to see
"RTN","HLEVREP0",107,0)
 ;;more of the information for this monitor, please use the 'Expanded monitor
"RTN","HLEVREP0",108,0)
 ;;report' menu option.
"RTN","HLEVREP0",109,0)
 QUIT
"RTN","HLEVREP0",110,0)
 ;
"RTN","HLEVREP0",111,0)
EXPMON ; Called by [HLEV REPORT EXPANDED MONITOR]
"RTN","HLEVREP0",112,0)
 N BY,DIC,FLDS,L
"RTN","HLEVREP0",113,0)
 D HD("Expanded Monitor Report")
"RTN","HLEVREP0",114,0)
 W !
"RTN","HLEVREP0",115,0)
 D EXPCMON
"RTN","HLEVREP0",116,0)
 S L="",DIC="^HLEV(776.1,",FLDS="[CAPTIONED]"
"RTN","HLEVREP0",117,0)
 S BY="[HLEV REPORT MONITOR - FF]"
"RTN","HLEVREP0",118,0)
 D EN1^DIP
"RTN","HLEVREP0",119,0)
 D TELL^HLEVMST0("")
"RTN","HLEVREP0",120,0)
 Q
"RTN","HLEVREP0",121,0)
 ;
"RTN","HLEVREP0",122,0)
EXPCMON N I,T F I=1:1 S T=$T(EXCPMON+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVREP0",123,0)
 ;;This option displays monitor information in expanded format.  If you wish to
"RTN","HLEVREP0",124,0)
 ;;see more of the information for this monitor, please use the 'Condensed 
"RTN","HLEVREP0",125,0)
 ;;monitor report' menu option.
"RTN","HLEVREP0",126,0)
 QUIT
"RTN","HLEVREP0",127,0)
 ;
"RTN","HLEVREP0",128,0)
 ;
"RTN","HLEVREP0",129,0)
HD(TXT) W @IOF,$$CJ^XLFSTR(TXT,IOM)
"RTN","HLEVREP0",130,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVREP0",131,0)
 QUIT
"RTN","HLEVREP0",132,0)
 ;
"RTN","HLEVREP0",133,0)
DETAILS ; Show details of an event monitor occurence...
"RTN","HLEVREP0",134,0)
 ;
"RTN","HLEVREP0",135,0)
 W !!,"Not implemented yet..."
"RTN","HLEVREP0",136,0)
 W !
"RTN","HLEVREP0",137,0)
 S X=$$BTE^HLCSMON("Press RETURN to continue... ")
"RTN","HLEVREP0",138,0)
 ;
"RTN","HLEVREP0",139,0)
 Q
"RTN","HLEVREP0",140,0)
 ;
"RTN","HLEVREP0",141,0)
EOR ;HLEVREP0 - Event Monitor REPORTS ;5/16/03 14:42
"RTN","HLEVREP1")
0^21^B62876882
"RTN","HLEVREP1",1,0)
HLEVREP1 ;O-OIFO/LJA - Event Monitor REPORTS ;02/04/2004 14:42
"RTN","HLEVREP1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVREP1",3,0)
 ;
"RTN","HLEVREP1",4,0)
CTRL ; Menu map display...
"RTN","HLEVREP1",5,0)
 N CT,DATE,DATEFRST,DATELAST,DATENXT,DATESEL,IOINHI,IOINORM
"RTN","HLEVREP1",6,0)
 N LINE,NO,TXT,X,Y
"RTN","HLEVREP1",7,0)
 ;
"RTN","HLEVREP1",8,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLEVREP1",9,0)
 ;
"RTN","HLEVREP1",10,0)
 KILL ^TMP($J,"HLMAP")
"RTN","HLEVREP1",11,0)
 D HD("Event Monitor Display")
"RTN","HLEVREP1",12,0)
 D EX
"RTN","HLEVREP1",13,0)
 D PURGING
"RTN","HLEVREP1",14,0)
 W !
"RTN","HLEVREP1",15,0)
 QUIT:$$BTE^HLCSMON("Press RETURN to collect data, or '^' to exit... ")  ;->
"RTN","HLEVREP1",16,0)
 W !!,"Collecting..."
"RTN","HLEVREP1",17,0)
 D MAPALL
"RTN","HLEVREP1",18,0)
 D MONVALL^HLEVREP2
"RTN","HLEVREP1",19,0)
 ;
"RTN","HLEVREP1",20,0)
 I '$D(^TMP($J,"HLMAP","S","D")) D  QUIT  ;->
"RTN","HLEVREP1",21,0)
 .  D TELL^HLEVMST0("No data exists!","1^2^999")
"RTN","HLEVREP1",22,0)
 ;
"RTN","HLEVREP1",23,0)
 S DATEFRST=$O(^TMP($J,"HLMAP","S","D",0))
"RTN","HLEVREP1",24,0)
 S (DATELAST,DATENXT)=$O(^TMP($J,"HLMAP","S","D",":"),-1)
"RTN","HLEVREP1",25,0)
 ;
"RTN","HLEVREP1",26,0)
 W !!,"Data found for ",$$FMTE^XLFDT(DATEFRST)
"RTN","HLEVREP1",27,0)
 I DATELAST=DATEFRST W "."
"RTN","HLEVREP1",28,0)
 I DATELAST'=DATEFRST W " to ",$$FMTE^XLFDT(DATELAST),"."
"RTN","HLEVREP1",29,0)
 W !!,"Loading most recent date..."
"RTN","HLEVREP1",30,0)
 ;
"RTN","HLEVREP1",31,0)
 H 2
"RTN","HLEVREP1",32,0)
 ;
"RTN","HLEVREP1",33,0)
 S CT=0
"RTN","HLEVREP1",34,0)
 F  D  QUIT:DATE']""  ;->
"RTN","HLEVREP1",35,0)
 .  S CT=CT+1
"RTN","HLEVREP1",36,0)
 .  S (DATE,DATESEL)=$S(CT=1:DATELAST,1:$$MAPDATE(DATENXT)) QUIT:DATE'?7N  ;->
"RTN","HLEVREP1",37,0)
 .  S DATENXT=$$FMADD^XLFDT(DATE,-1) ; Next date to be prompted...
"RTN","HLEVREP1",38,0)
 .  S TXT="Event Monitor Map - "_$$FMTE^XLFDT(DATE)
"RTN","HLEVREP1",39,0)
 .  S LINE=$O(^TMP($J,"HLMAP","S","D",DATE,":"),-1)
"RTN","HLEVREP1",40,0)
 .  I LINE<22 D
"RTN","HLEVREP1",41,0)
 .  .  W @IOF,$$CJ^XLFSTR(TXT,IOM),!,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVREP1",42,0)
 .  .  S NO=0
"RTN","HLEVREP1",43,0)
 .  .  F  S NO=$O(^TMP($J,"HLMAP","S","D",DATE,NO)) Q:'NO  D
"RTN","HLEVREP1",44,0)
 .  .  .  W !,^TMP($J,"HLMAP","S","D",DATE,NO)
"RTN","HLEVREP1",45,0)
 .  I LINE'<22 D
"RTN","HLEVREP1",46,0)
 .  .  D BROWSE^DDBR("^TMP($J,""HLMAP"",""S"",""D"","_DATE_")","N",TXT)
"RTN","HLEVREP1",47,0)
 .  D CTRLMON^HLEVREP3 ; All user to call up individual monitor run info...
"RTN","HLEVREP1",48,0)
 .  I DATENXT<DATEFRST D  QUIT  ;->
"RTN","HLEVREP1",49,0)
 .  .  W !!,"You just viewed the ",IOINHI,"earliest",IOINORM
"RTN","HLEVREP1",50,0)
 .  .  W " day on record.  (You must manually enter the"
"RTN","HLEVREP1",51,0)
 .  .  W !,"next date to view.)"
"RTN","HLEVREP1",52,0)
 .  .  W !
"RTN","HLEVREP1",53,0)
 .  .  S DATENXT=""
"RTN","HLEVREP1",54,0)
 .  I DATENXT=DATEFRST D  QUIT  ;->
"RTN","HLEVREP1",55,0)
 .  .  W !!,$$FMTE^XLFDT(DATENXT)," is the earliest date on record."
"RTN","HLEVREP1",56,0)
 .  .  W !
"RTN","HLEVREP1",57,0)
 .  W !!,"The next earlier date is prompted below."
"RTN","HLEVREP1",58,0)
 .  W !
"RTN","HLEVREP1",59,0)
 ;
"RTN","HLEVREP1",60,0)
 Q
"RTN","HLEVREP1",61,0)
 ;
"RTN","HLEVREP1",62,0)
MAPDEVCE ; Just dump to screen...
"RTN","HLEVREP1",63,0)
 N ABRT,CT,DAY,NO,X
"RTN","HLEVREP1",64,0)
 S DAY=0,ABRT=0,CT=0
"RTN","HLEVREP1",65,0)
 F  S DAY=$O(^TMP($J,"HLMAP","S","D",DAY)) Q:'DAY!(ABRT)  D
"RTN","HLEVREP1",66,0)
 .  W !!,$$CJ^XLFSTR(" Event Monitor Information - "_$$FMTE^XLFDT(DAY)_" ",IOM,"=")
"RTN","HLEVREP1",67,0)
 .  S CT=CT+2
"RTN","HLEVREP1",68,0)
 .  S NO=0
"RTN","HLEVREP1",69,0)
 .  F  S NO=$O(^TMP($J,"HLMAP","S","D",DAY,NO)) Q:NO'>0  D
"RTN","HLEVREP1",70,0)
 .  .  S CT=CT+1
"RTN","HLEVREP1",71,0)
 .  .  W !,^TMP($J,"HLMAP","S","D",DAY,NO)
"RTN","HLEVREP1",72,0)
 .  .  QUIT:CT<22  ;->
"RTN","HLEVREP1",73,0)
 .  .  R X:999 S CT=0
"RTN","HLEVREP1",74,0)
 R:CT X:999
"RTN","HLEVREP1",75,0)
 Q
"RTN","HLEVREP1",76,0)
 ;
"RTN","HLEVREP1",77,0)
MAPDATE(DATEPMT) ; Select date...
"RTN","HLEVREP1",78,0)
 N ANS,DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLEVREP1",79,0)
 S DIR(0)="DO^"_DATEFRST_":"_DATELAST_":EX"
"RTN","HLEVREP1",80,0)
 S DIR("A")="Select DATE",DIR("?")="Enter a report date, (but don't enter time of day.)"
"RTN","HLEVREP1",81,0)
 I $G(DATEPMT)?7N S DIR("B")=$$FMTE^XLFDT(DATEPMT)
"RTN","HLEVREP1",82,0)
 D ^DIR
"RTN","HLEVREP1",83,0)
 QUIT:+Y?7N +Y ;->
"RTN","HLEVREP1",84,0)
 S ANS=Y
"RTN","HLEVREP1",85,0)
 I $$UP^XLFSTR($TR(X," ",""))["DUMP" D MAPDEVCE ;->
"RTN","HLEVREP1",86,0)
 Q ""
"RTN","HLEVREP1",87,0)
 ;
"RTN","HLEVREP1",88,0)
PURGING ; How for back does purging start?
"RTN","HLEVREP1",89,0)
 N DATA,PURGEHR
"RTN","HLEVREP1",90,0)
 S PURGEHR=$P($G(^HLEV(776.999,1,0)),U,4)
"RTN","HLEVREP1",91,0)
 S PURGEHR=$S(PURGEHR:PURGEHR,1:96)
"RTN","HLEVREP1",92,0)
 W !!,$$CJ^XLFSTR("--- Data before NOW-"_PURGEHR_" hours has been deleted ---",IOM)
"RTN","HLEVREP1",93,0)
 Q
"RTN","HLEVREP1",94,0)
 ;
"RTN","HLEVREP1",95,0)
HD(TXT) W @IOF,$$CJ^XLFSTR(TXT,IOM)
"RTN","HLEVREP1",96,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVREP1",97,0)
 QUIT
"RTN","HLEVREP1",98,0)
 ;
"RTN","HLEVREP1",99,0)
EX N I,T F I=1:1 S T=$T(EX+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVREP1",100,0)
 ;;This option collects all existing event monitor information for review.  You
"RTN","HLEVREP1",101,0)
 ;;can view a "map" of each monitor that ran, showing hour-by-hour when the
"RTN","HLEVREP1",102,0)
 ;;"run" occurred.  You may also select individual monitors for a more detailed
"RTN","HLEVREP1",103,0)
 ;;display.
"RTN","HLEVREP1",104,0)
 QUIT
"RTN","HLEVREP1",105,0)
 ;
"RTN","HLEVREP1",106,0)
MAPALL ; Do everything to get ^TMP($J,"HLMAP") data ready for printing...
"RTN","HLEVREP1",107,0)
 KILL ^TMP($J,"HLMAP")
"RTN","HLEVREP1",108,0)
 D MAPCOLLE ; Find events...
"RTN","HLEVREP1",109,0)
 D MAPCOLLM ; Find master job runs
"RTN","HLEVREP1",110,0)
 D MAPBUILD ; Build date array
"RTN","HLEVREP1",111,0)
 D MAPSCRN ;  Build daily screens
"RTN","HLEVREP1",112,0)
 Q
"RTN","HLEVREP1",113,0)
 ;
"RTN","HLEVREP1",114,0)
MAPCOLLM ; Collect map ^TMP data - Master job runs...
"RTN","HLEVREP1",115,0)
 N DATA,IENM,MONM,STAT,TIME
"RTN","HLEVREP1",116,0)
 S IENM=0
"RTN","HLEVREP1",117,0)
 F  S IENM=$O(^HLEV(776.2,IENM)) Q:'IENM  D
"RTN","HLEVREP1",118,0)
 .  S DATA=$G(^HLEV(776.2,IENM,0)) QUIT:$P(DATA,U)']""  ;->
"RTN","HLEVREP1",119,0)
 .  S STAT=$P(DATA,U,4) QUIT:STAT'="F"  ;->
"RTN","HLEVREP1",120,0)
 .  S TIME=$$ROUNDHR(+$P(DATA,U,2)) QUIT:TIME']""  ;->
"RTN","HLEVREP1",121,0)
 .  S ^TMP($J,"HLMAP","T")=$G(^TMP($J,"HLMAP","T"))+1
"RTN","HLEVREP1",122,0)
 .  S ^TMP($J,"HLMAP","T","M")=$G(^TMP($J,"HLMAP","T","M"))+1
"RTN","HLEVREP1",123,0)
 .  S ^TMP($J,"HLMAP","D",TIME,"M")=$G(^TMP($J,"HLMAP","D",TIME,"M"))+1
"RTN","HLEVREP1",124,0)
 .  S ^TMP($J,"HLMAP","D",TIME,"M",IENM)=""
"RTN","HLEVREP1",125,0)
 Q
"RTN","HLEVREP1",126,0)
 ;
"RTN","HLEVREP1",127,0)
MAPCOLLE ; Collect map ^TMP data - Events...
"RTN","HLEVREP1",128,0)
 N DATA,IENM,IENMST,MONIEN,MONM,STAT,TIME
"RTN","HLEVREP1",129,0)
 S IENM=0
"RTN","HLEVREP1",130,0)
 F  S IENM=$O(^HLEV(776,IENM)) Q:'IENM  D
"RTN","HLEVREP1",131,0)
 .  S DATA=$G(^HLEV(776,IENM,0)) QUIT:$P(DATA,U)']""  ;->
"RTN","HLEVREP1",132,0)
 .  S STAT=$P(DATA,U,4) QUIT:STAT'="F"
"RTN","HLEVREP1",133,0)
 .  S TIME=$$ROUNDHR(+DATA) QUIT:TIME']""  ;->
"RTN","HLEVREP1",134,0)
 .  S MONIEN=$P(DATA,U,3) QUIT:MONIEN'>0  ;->
"RTN","HLEVREP1",135,0)
 .  S MONIEN=MONIEN QUIT:MONIEN'>0  ;->
"RTN","HLEVREP1",136,0)
 .  S MONM=$P($G(^HLEV(776.1,+MONIEN,0)),U) QUIT:MONM']""  ;->
"RTN","HLEVREP1",137,0)
 .  S MONM=MONM_"["_MONIEN_"]"
"RTN","HLEVREP1",138,0)
 .  S IENMST=$P(DATA,U,9),IENMST=$S(IENMST>0:IENMST,1:9999999)
"RTN","HLEVREP1",139,0)
 .  S ^TMP($J,"HLMAP","T")=$G(^TMP($J,"HLMAP","T"))+1
"RTN","HLEVREP1",140,0)
 .  S ^TMP($J,"HLMAP","T","E")=$G(^TMP($J,"HLMAP","T","E"))+1
"RTN","HLEVREP1",141,0)
 .  S ^TMP($J,"HLMAP","D",TIME,"E")=$G(^TMP($J,"HLMAP","D",TIME,"E"))+1
"RTN","HLEVREP1",142,0)
 .  S ^TMP($J,"HLMAP","D",TIME,"E",MONM)=$G(^TMP($J,"HLMAP","D",TIME,"E",MONM))+1
"RTN","HLEVREP1",143,0)
 .  S ^TMP($J,"HLMAP","D",TIME,"E",MONM,IENMST,IENM)=""
"RTN","HLEVREP1",144,0)
 .  S MONM=$P(MONM,"[") QUIT:MONM']""  ;->
"RTN","HLEVREP1",145,0)
 .  S ^TMP($J,"HLMAP","E",+MONIEN,+TIME\1,+IENM)=MONM
"RTN","HLEVREP1",146,0)
 Q
"RTN","HLEVREP1",147,0)
 ;
"RTN","HLEVREP1",148,0)
MAPBUILD ; Make lines for browsing report
"RTN","HLEVREP1",149,0)
 N EVNM,GBL,HOUR
"RTN","HLEVREP1",150,0)
 S GBL=$NA(^TMP($J,"HLMAP","D"))
"RTN","HLEVREP1",151,0)
 S HOUR=""
"RTN","HLEVREP1",152,0)
 F  S HOUR=$O(@GBL@(HOUR)) Q:HOUR']""  D
"RTN","HLEVREP1",153,0)
 .  I $O(@GBL@(HOUR,"M",0))>0 D MAPHOUR("MASTER JOB",HOUR)
"RTN","HLEVREP1",154,0)
 .  S EVNM=""
"RTN","HLEVREP1",155,0)
 .  F  S EVNM=$O(@GBL@(HOUR,"E",EVNM)) Q:EVNM']""  D
"RTN","HLEVREP1",156,0)
 .  .  D MAPHOUR(EVNM,HOUR)
"RTN","HLEVREP1",157,0)
 Q
"RTN","HLEVREP1",158,0)
 ;
"RTN","HLEVREP1",159,0)
MAPHOUR(EVNM,HOUR) ; Store in display global...
"RTN","HLEVREP1",160,0)
 S ^TMP($J,"HLMAP","M",EVNM,+$P(HOUR,"."),+$P(HOUR,".",2))=""
"RTN","HLEVREP1",161,0)
 Q
"RTN","HLEVREP1",162,0)
 ;
"RTN","HLEVREP1",163,0)
MAPSCRN ; Build screen for days...
"RTN","HLEVREP1",164,0)
 N DATA,DAY,EVNM,HOUR,HR,TXT,X
"RTN","HLEVREP1",165,0)
 ;
"RTN","HLEVREP1",166,0)
 S EVNM=""
"RTN","HLEVREP1",167,0)
 F  S EVNM=$O(^TMP($J,"HLMAP","M",EVNM)) Q:EVNM']""  D
"RTN","HLEVREP1",168,0)
 .  S DAY=0
"RTN","HLEVREP1",169,0)
 .  F  S DAY=$O(^TMP($J,"HLMAP","M",EVNM,DAY)) Q:DAY'>0  D
"RTN","HLEVREP1",170,0)
 .  .  S TXT=$$EVNM(EVNM,31)
"RTN","HLEVREP1",171,0)
 .  .  F HOUR=1:1:24 D
"RTN","HLEVREP1",172,0)
 .  .  .  S DATA=$S($D(^TMP($J,"HLMAP","M",EVNM,DAY,HOUR_0)):1,1:0)
"RTN","HLEVREP1",173,0)
 .  .  .  S TXT=TXT_$S(DATA:"-X",1:"--")
"RTN","HLEVREP1",174,0)
 .  .  S ^TMP($J,"HLMAP","X",DAY,EVNM)=TXT
"RTN","HLEVREP1",175,0)
 ;
"RTN","HLEVREP1",176,0)
 S DAY=0
"RTN","HLEVREP1",177,0)
 F  S DAY=$O(^TMP($J,"HLMAP","X",DAY)) Q:DAY'>0  D
"RTN","HLEVREP1",178,0)
 .  D ADDHDR(DAY)
"RTN","HLEVREP1",179,0)
 .  I $D(^TMP($J,"HLMAP","X",DAY,"MASTER JOB")) D
"RTN","HLEVREP1",180,0)
 .  .  D ADDLINE(DAY,^TMP($J,"HLMAP","X",DAY,"MASTER JOB"))
"RTN","HLEVREP1",181,0)
 .  S EVNM=""
"RTN","HLEVREP1",182,0)
 .  F  S EVNM=$O(^TMP($J,"HLMAP","X",DAY,EVNM)) Q:EVNM']""  D
"RTN","HLEVREP1",183,0)
 .  .  QUIT:EVNM="MASTER JOB"  ;->
"RTN","HLEVREP1",184,0)
 .  .  D ADDLINE(DAY,^TMP($J,"HLMAP","X",DAY,EVNM))
"RTN","HLEVREP1",185,0)
 ;
"RTN","HLEVREP1",186,0)
 Q
"RTN","HLEVREP1",187,0)
 ;
"RTN","HLEVREP1",188,0)
ADDHDR(DAY) ; Add HDR code...
"RTN","HLEVREP1",189,0)
 D ADDLINE(DAY,$$CJ^XLFSTR(" "_$$FMTE^XLFDT(DAY)_" ",IOM,"="))
"RTN","HLEVREP1",190,0)
 D ADDLINE(DAY,"                   |"_IOINHI_"  Hours "_IOINORM_"| - 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2")
"RTN","HLEVREP1",191,0)
 D ADDLINE(DAY,"Monitor            |"_IOINHI_" in Day "_IOINORM_"| - 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4")
"RTN","HLEVREP1",192,0)
 D ADDLINE(DAY,$$REPEAT^XLFSTR("=",IOM))
"RTN","HLEVREP1",193,0)
 Q
"RTN","HLEVREP1",194,0)
 ;
"RTN","HLEVREP1",195,0)
ADDLINE(DAY,TXT) ; Add one line of text to screen ^TMP global
"RTN","HLEVREP1",196,0)
 N NO
"RTN","HLEVREP1",197,0)
 S ^TMP($J,"HLMAP","S","D",DAY)=$G(^TMP($J,"HLMAP","S","D",DAY))+1
"RTN","HLEVREP1",198,0)
 S NO=$O(^TMP($J,"HLMAP","S","D",DAY,":"),-1)+1
"RTN","HLEVREP1",199,0)
 I '(NO#24) D  ; Mid-screen extra header
"RTN","HLEVREP1",200,0)
 .  S ^TMP($J,"HLMAP","S","D",DAY,NO)=$$REPEAT^XLFSTR("-",IOM)
"RTN","HLEVREP1",201,0)
 .  S NO=NO+1,^TMP($J,"HLMAP","S","D",DAY,NO)="                        Hours - 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2"
"RTN","HLEVREP1",202,0)
 .  S NO=NO+1,^TMP($J,"HLMAP","S","D",DAY,NO)="Monitor                in Day - 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4"
"RTN","HLEVREP1",203,0)
 .  S NO=NO+1,^TMP($J,"HLMAP","S","D",DAY,NO)=$$REPEAT^XLFSTR("-",IOM)
"RTN","HLEVREP1",204,0)
 .  S NO=NO+1
"RTN","HLEVREP1",205,0)
 S ^TMP($J,"HLMAP","S","D",DAY,+NO)=TXT
"RTN","HLEVREP1",206,0)
 Q
"RTN","HLEVREP1",207,0)
 ;
"RTN","HLEVREP1",208,0)
EVNM(EVNM,LEN) ; Convert event name[ien] to LENgth, truncating name part prn
"RTN","HLEVREP1",209,0)
 N IEN,NM,X
"RTN","HLEVREP1",210,0)
 I EVNM="MASTER JOB" QUIT $$REPEAT^XLFSTR("-",LEN-$L("MASTER JOB")-1)_"MASTER JOB-" ;->
"RTN","HLEVREP1",211,0)
 S NM=$P(EVNM,"["),IEN="["_$P(EVNM,"[",2,99)
"RTN","HLEVREP1",212,0)
 S NM(1)=$E(NM,1,LEN-$L(IEN))
"RTN","HLEVREP1",213,0)
 I NM'=NM(1) S NM(1)=$E(NM(1),1,$L(NM(1))-1)_"~"
"RTN","HLEVREP1",214,0)
 S NM=NM(1)_IEN
"RTN","HLEVREP1",215,0)
 S NM=$E(NM_$$REPEAT^XLFSTR("-",LEN),1,LEN)
"RTN","HLEVREP1",216,0)
 Q NM
"RTN","HLEVREP1",217,0)
 ;
"RTN","HLEVREP1",218,0)
ROUNDHR(FM) ;
"RTN","HLEVREP1",219,0)
 N HR
"RTN","HLEVREP1",220,0)
 S FM=$G(FM)
"RTN","HLEVREP1",221,0)
 I FM'?7N&(FM'?7N1"."1.N) QUIT "" ;->
"RTN","HLEVREP1",222,0)
 S:FM?7N FM=FM_"." S FM=$E(FM_"00",1,10)
"RTN","HLEVREP1",223,0)
 S HR=+$P(FM,".",2)+1 S:HR<10 HR=0_HR
"RTN","HLEVREP1",224,0)
 S FM=FM\1_"."_HR_0
"RTN","HLEVREP1",225,0)
 Q FM
"RTN","HLEVREP1",226,0)
 ;
"RTN","HLEVREP1",227,0)
EOR ;HLEVREP1 - Event Monitor REPORTS ;5/16/03 14:42
"RTN","HLEVREP2")
0^22^B63366284
"RTN","HLEVREP2",1,0)
HLEVREP2 ;O-OIFO/LJA - Event Monitor REPORTS ;02/04/2004 14:42
"RTN","HLEVREP2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVREP2",3,0)
 ;
"RTN","HLEVREP2",4,0)
CTRL ; Called by 'Display monitor details [HLEV MONITOR DETAILS]'
"RTN","HLEVREP2",5,0)
 N MONM
"RTN","HLEVREP2",6,0)
 ;
"RTN","HLEVREP2",7,0)
 KILL ^TMP($J)
"RTN","HLEVREP2",8,0)
 ;
"RTN","HLEVREP2",9,0)
 D HD
"RTN","HLEVREP2",10,0)
 D EX
"RTN","HLEVREP2",11,0)
 W !
"RTN","HLEVREP2",12,0)
 QUIT:$$BTE^HLCSMON("Press RETURN to collect data, or enter '^' to exit... ")  ;->
"RTN","HLEVREP2",13,0)
 D MONVALL
"RTN","HLEVREP2",14,0)
 ;
"RTN","HLEVREP2",15,0)
 F  D  QUIT:MONM']""
"RTN","HLEVREP2",16,0)
 .  D MONLIST
"RTN","HLEVREP2",17,0)
 .  W !
"RTN","HLEVREP2",18,0)
 .  S MONM=$$ASKMON QUIT:MONM']""  ;->
"RTN","HLEVREP2",19,0)
 .  S WAY=$$ORDER I WAY'?1N S MONM="" QUIT  ;->
"RTN","HLEVREP2",20,0)
 .  I WAY=1 D SHOWR(MONM)
"RTN","HLEVREP2",21,0)
 .  I WAY=2 D SHOWF(MONM)
"RTN","HLEVREP2",22,0)
 .  D HD
"RTN","HLEVREP2",23,0)
 ;
"RTN","HLEVREP2",24,0)
 KILL ^TMP($J)
"RTN","HLEVREP2",25,0)
 ;
"RTN","HLEVREP2",26,0)
 Q
"RTN","HLEVREP2",27,0)
 ;
"RTN","HLEVREP2",28,0)
SHOWF(MONM) ; Show monitors from oldest to newest
"RTN","HLEVREP2",29,0)
 N ABRT,HLEVIENJ,PMT
"RTN","HLEVREP2",30,0)
 W !
"RTN","HLEVREP2",31,0)
 S ABRT=0,HLEVIENJ=0
"RTN","HLEVREP2",32,0)
 F  S HLEVIENJ=$O(^TMP($J,"HLMONL",MONM,HLEVIENJ)) Q:'HLEVIENJ!(ABRT)  D
"RTN","HLEVREP2",33,0)
 .  S X=$$NEXT,ABRT=$P(X,U,2),PRINT=+X QUIT:ABRT  ;->
"RTN","HLEVREP2",34,0)
 .  I PRINT D SHOW(HLEVIENJ) W !
"RTN","HLEVREP2",35,0)
 Q
"RTN","HLEVREP2",36,0)
 ;
"RTN","HLEVREP2",37,0)
SHOWR(MONM) ; Show monitors from newest to oldest
"RTN","HLEVREP2",38,0)
 N ABRT,HLEVIENJ,PRINT,X
"RTN","HLEVREP2",39,0)
 W !
"RTN","HLEVREP2",40,0)
 S ABRT=0,HLEVIENJ=":"
"RTN","HLEVREP2",41,0)
 F  S HLEVIENJ=$O(^TMP($J,"HLMONL",MONM,HLEVIENJ),-1) Q:'HLEVIENJ!(ABRT)  D
"RTN","HLEVREP2",42,0)
 .  S X=$$NEXT,ABRT=$P(X,U,2),PRINT=+X QUIT:ABRT  ;->
"RTN","HLEVREP2",43,0)
 .  I PRINT D SHOW(HLEVIENJ) W !
"RTN","HLEVREP2",44,0)
 Q
"RTN","HLEVREP2",45,0)
 ;
"RTN","HLEVREP2",46,0)
NEXT() ; Show next entry?
"RTN","HLEVREP2",47,0)
 N ANS
"RTN","HLEVREP2",48,0)
 S ANS=$$YN^HLEVUTIL("Display monitor ""run"" started at "_$P(^TMP($J,"HLMON",+HLEVIENJ,"START"),U,3),"No")
"RTN","HLEVREP2",49,0)
 I ANS=1 QUIT "1^0" ;-> Display^Abort
"RTN","HLEVREP2",50,0)
 I ANS="" QUIT "0^0" ;->
"RTN","HLEVREP2",51,0)
 Q "0^1"
"RTN","HLEVREP2",52,0)
 ;
"RTN","HLEVREP2",53,0)
SHOW(HLEVIENJ) ; Ask if want to view...
"RTN","HLEVREP2",54,0)
 N GBL,LINES,MONM
"RTN","HLEVREP2",55,0)
 ;
"RTN","HLEVREP2",56,0)
 S GBL=$NA(^TMP($J,"HLMON",HLEVIENJ))
"RTN","HLEVREP2",57,0)
 ;
"RTN","HLEVREP2",58,0)
 ;
"RTN","HLEVREP2",59,0)
 S LINES=$O(@GBL@("VIEW",":"),-1)
"RTN","HLEVREP2",60,0)
 S MONM=$P($G(@GBL@("MONM")),U,3) QUIT:MONM']""  ;->
"RTN","HLEVREP2",61,0)
 S MONM=MONM_"[#"_HLEVIENJ_"]"
"RTN","HLEVREP2",62,0)
 ;
"RTN","HLEVREP2",63,0)
 I LINES<22 D  QUIT  ;->
"RTN","HLEVREP2",64,0)
 .  W @IOF,$$CJ^XLFSTR(MONM,IOM),!,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVREP2",65,0)
 .  S NO=0
"RTN","HLEVREP2",66,0)
 .  F  S NO=$O(^TMP($J,"HLMON",+HLEVIENJ,"VIEW",NO)) Q:NO'>0  D
"RTN","HLEVREP2",67,0)
 .  .  W !,^TMP($J,"HLMON",+HLEVIENJ,"VIEW",NO)
"RTN","HLEVREP2",68,0)
 ;
"RTN","HLEVREP2",69,0)
 D BROWSE^DDBR($NA(^TMP($J,"HLMON",+HLEVIENJ,"VIEW")),"N",MONM)
"RTN","HLEVREP2",70,0)
 ;
"RTN","HLEVREP2",71,0)
 Q
"RTN","HLEVREP2",72,0)
 ;
"RTN","HLEVREP2",73,0)
ORDER() ; $ORDER direction...
"RTN","HLEVREP2",74,0)
 N DIR,DIRUT,DTOUT,DUOUT
"RTN","HLEVREP2",75,0)
 S DIR(0)="S^1:Show entries from newest to oldest;2:Show entries from oldest to newest;3:Exit"
"RTN","HLEVREP2",76,0)
 S DIR("A")="Select display direction"
"RTN","HLEVREP2",77,0)
 S DIR("B")=1
"RTN","HLEVREP2",78,0)
 D ^DIR
"RTN","HLEVREP2",79,0)
 Q $S(+Y=1!(+Y=2):+Y,1:"")
"RTN","HLEVREP2",80,0)
 ;
"RTN","HLEVREP2",81,0)
ASKMON() ; Ask user to select a monitor...
"RTN","HLEVREP2",82,0)
 N DIC,X,Y
"RTN","HLEVREP2",83,0)
 S DIC=776.1,DIC(0)="AEMQ",DIC("A")="Select MONITOR: "
"RTN","HLEVREP2",84,0)
 S DIC("S")="S HLEV=$P($G(^HLEV(776.1,+Y,0)),U) I HLEV]"""",$D(^TMP($J,""HLMONL"",HLEV))"
"RTN","HLEVREP2",85,0)
 D ^DIC
"RTN","HLEVREP2",86,0)
 Q $S(+Y>0:$P(Y,U,2),1:"")
"RTN","HLEVREP2",87,0)
 ;
"RTN","HLEVREP2",88,0)
HD W @IOF,$$CJ^XLFSTR("Display Monitor Details",IOM)
"RTN","HLEVREP2",89,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVREP2",90,0)
 QUIT
"RTN","HLEVREP2",91,0)
 ;
"RTN","HLEVREP2",92,0)
EX N I,T F I=1:1 S T=$T(EX+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVREP2",93,0)
 ;;This option displays a detailed view of monitor run-time data.  You can loop
"RTN","HLEVREP2",94,0)
 ;;through all occurrences of a monitor from oldest to most recent, or from most
"RTN","HLEVREP2",95,0)
 ;;recent to oldest.
"RTN","HLEVREP2",96,0)
 QUIT
"RTN","HLEVREP2",97,0)
 ;
"RTN","HLEVREP2",98,0)
MONLIST ; Create and print list of monitors...
"RTN","HLEVREP2",99,0)
 N DATA,HLEVIENJ
"RTN","HLEVREP2",100,0)
 ;
"RTN","HLEVREP2",101,0)
 I '$D(^TMP($J,"HLMONL")) D  QUIT:'$D(^TMP($J,"HLMONL"))  ;->
"RTN","HLEVREP2",102,0)
 .  S HLEVIENJ=0
"RTN","HLEVREP2",103,0)
 .  F  S HLEVIENJ=$O(^TMP($J,"HLMON",HLEVIENJ)) Q:'HLEVIENJ  D
"RTN","HLEVREP2",104,0)
 .  .  S MONM=$P($G(^TMP($J,"HLMON",+HLEVIENJ,"MONM")),U,3) QUIT:MONM']""  ;->
"RTN","HLEVREP2",105,0)
 .  .  S ^TMP($J,"HLMONL",MONM)=$G(^TMP($J,"HLMONL",MONM))+1
"RTN","HLEVREP2",106,0)
 .  .  S ^TMP($J,"HLMONL",MONM,+HLEVIENJ)=""
"RTN","HLEVREP2",107,0)
 ;
"RTN","HLEVREP2",108,0)
 W !!,"""Runs"" for the following monitors have been found..."
"RTN","HLEVREP2",109,0)
 W !!
"RTN","HLEVREP2",110,0)
 ;
"RTN","HLEVREP2",111,0)
 S MONM=""
"RTN","HLEVREP2",112,0)
 F  S MONM=$O(^TMP($J,"HLMONL",MONM)) Q:MONM']""  D
"RTN","HLEVREP2",113,0)
 .  S CT=^TMP($J,"HLMONL",MONM),MONM(1)=MONM_"[#"_CT_"]"
"RTN","HLEVREP2",114,0)
 .  W:$X>40 ! W:$X>1 ?40
"RTN","HLEVREP2",115,0)
 .  W MONM(1)
"RTN","HLEVREP2",116,0)
 ;
"RTN","HLEVREP2",117,0)
 Q
"RTN","HLEVREP2",118,0)
 ;
"RTN","HLEVREP2",119,0)
MONVALL ; Collect and build screens for all HLEVIENJs...
"RTN","HLEVREP2",120,0)
 N CT,HLEVIENJ
"RTN","HLEVREP2",121,0)
 ;
"RTN","HLEVREP2",122,0)
 KILL ^TMP($J,"HLMON")
"RTN","HLEVREP2",123,0)
 ;
"RTN","HLEVREP2",124,0)
 ; Load here...
"RTN","HLEVREP2",125,0)
 S HLEVIENJ=0,CT=0
"RTN","HLEVREP2",126,0)
 F  S HLEVIENJ=$O(^HLEV(776,HLEVIENJ)) Q:HLEVIENJ'>0  D
"RTN","HLEVREP2",127,0)
 .  D MONALL(+HLEVIENJ)
"RTN","HLEVREP2",128,0)
 .  S CT=CT+1 W:'(CT#50) "."
"RTN","HLEVREP2",129,0)
 ;
"RTN","HLEVREP2",130,0)
 Q
"RTN","HLEVREP2",131,0)
 ;
"RTN","HLEVREP2",132,0)
MONALL(HLEVIENJ) ; Build screen for one entry...
"RTN","HLEVREP2",133,0)
 N GBL
"RTN","HLEVREP2",134,0)
 ;
"RTN","HLEVREP2",135,0)
 S GBL=$NA(^TMP($J,"HLMON",+HLEVIENJ))
"RTN","HLEVREP2",136,0)
 KILL @GBL
"RTN","HLEVREP2",137,0)
 ;
"RTN","HLEVREP2",138,0)
 D MONLOAD^HLEVREP3(+HLEVIENJ) QUIT:'$D(^TMP($J,"HLMON",+HLEVIENJ))  ;->
"RTN","HLEVREP2",139,0)
 D MONHHDR(+HLEVIENJ) ; Build HEADER portion of screen
"RTN","HLEVREP2",140,0)
 D MONVVAR(+HLEVIENJ) ; Build VARIABLE portion of screen
"RTN","HLEVREP2",141,0)
 D MONRRD(+HLEVIENJ) ; Build RUN DIARY portion of screen
"RTN","HLEVREP2",142,0)
 D MONMMT(+HLEVIENJ) ; Build MSG TEXT portion of screen
"RTN","HLEVREP2",143,0)
 ;
"RTN","HLEVREP2",144,0)
 Q
"RTN","HLEVREP2",145,0)
 ;
"RTN","HLEVREP2",146,0)
 ;
"RTN","HLEVREP2",147,0)
MONHHDR(HLEVIENJ) ; Build header...
"RTN","HLEVREP2",148,0)
 ; ^TMP($J,"HLMON",+HLEVIENJ) -- req
"RTN","HLEVREP2",149,0)
 N TXT
"RTN","HLEVREP2",150,0)
 ;
"RTN","HLEVREP2",151,0)
 D ADDLINE("Start        Timestamp    Finish       Status   Appl        Mail")
"RTN","HLEVREP2",152,0)
 D ADDLINE($$REPEAT^XLFSTR("=",IOM))
"RTN","HLEVREP2",153,0)
 ;
"RTN","HLEVREP2",154,0)
 S TXT=""
"RTN","HLEVREP2",155,0)
 D ADD("START",11),ADD("TIME",11),ADD("DONE",11),ADD("STATR",7)
"RTN","HLEVREP2",156,0)
 D ADD("MAIL",14)
"RTN","HLEVREP2",157,0)
 D ADDLINE(TXT)
"RTN","HLEVREP2",158,0)
 ;
"RTN","HLEVREP2",159,0)
 Q
"RTN","HLEVREP2",160,0)
 ;
"RTN","HLEVREP2",161,0)
MONVVAR(HLEVIENJ) ; Create screens in ^TMP
"RTN","HLEVREP2",162,0)
 ; GBL,^TMP($J,"HLMON",+HLEVIENJ) -- req
"RTN","HLEVREP2",163,0)
 ;
"RTN","HLEVREP2",164,0)
 ;
"RTN","HLEVREP2",165,0)
 N NOPG,NOVAR
"RTN","HLEVREP2",166,0)
 ;
"RTN","HLEVREP2",167,0)
 S X=$G(@GBL@("VX")),NOVAR=$P(X,U),NOPG=$P(X,U,4)
"RTN","HLEVREP2",168,0)
 ;
"RTN","HLEVREP2",169,0)
 ; Vertical alignment?
"RTN","HLEVREP2",170,0)
 I NOPG>1!(NOVAR<6) D MVSCRNV QUIT  ;->
"RTN","HLEVREP2",171,0)
 ;
"RTN","HLEVREP2",172,0)
 ; Horizontal alignment...
"RTN","HLEVREP2",173,0)
 D MVSCRNH
"RTN","HLEVREP2",174,0)
 ;
"RTN","HLEVREP2",175,0)
 Q
"RTN","HLEVREP2",176,0)
 ;
"RTN","HLEVREP2",177,0)
MVSCRNV ; Create variable screen VERTICALly...
"RTN","HLEVREP2",178,0)
 ; Called by MONVSCRN - GBL,HLEVIENJ -- req
"RTN","HLEVREP2",179,0)
 N COL,DATA,EXPL,LEN,TXT,VAR,VARX
"RTN","HLEVREP2",180,0)
 ;
"RTN","HLEVREP2",181,0)
 ; Get widest variable...
"RTN","HLEVREP2",182,0)
 S COL=$O(@GBL@("VY",":"),-1) QUIT:COL'>0  ;->
"RTN","HLEVREP2",183,0)
 S VAR=$O(@GBL@("VY",+COL,"ZZZZZZZZZ"),-1) QUIT:VAR']""  ;->
"RTN","HLEVREP2",184,0)
 S EXPL=$O(@GBL@("VY",+COL,VAR,"ZZZZZZZZZ"),-1) QUIT:EXPL']""  ;->
"RTN","HLEVREP2",185,0)
 S DATA=@GBL@("VD",VAR,EXPL)
"RTN","HLEVREP2",186,0)
 S VARX=$S(VAR'=EXPL:EXPL,1:VAR)
"RTN","HLEVREP2",187,0)
 ;
"RTN","HLEVREP2",188,0)
 ; Find where 'legend: ' should be...
"RTN","HLEVREP2",189,0)
 S TXT=$$CJ^XLFSTR(VARX_"~^~"_DATA,IOM)
"RTN","HLEVREP2",190,0)
 S LEN=$L($P(TXT,"~^~"))-2 ; this is critical number...
"RTN","HLEVREP2",191,0)
 ;
"RTN","HLEVREP2",192,0)
 D ADDLINE("")
"RTN","HLEVREP2",193,0)
 D ADDLINE($$CJ^XLFSTR("-------------------- Variables ----------------------",IOM))
"RTN","HLEVREP2",194,0)
 ;
"RTN","HLEVREP2",195,0)
 ; Loop thru fields now...
"RTN","HLEVREP2",196,0)
 S VAR=""
"RTN","HLEVREP2",197,0)
 F  S VAR=$O(@GBL@("VD",VAR)) Q:VAR']""  D
"RTN","HLEVREP2",198,0)
 .  S EXPL=""
"RTN","HLEVREP2",199,0)
 .  F  S EXPL=$O(@GBL@("VD",VAR,EXPL)) Q:EXPL']""  D
"RTN","HLEVREP2",200,0)
 .  .  S DATA=@GBL@("VD",VAR,EXPL)
"RTN","HLEVREP2",201,0)
 .  .  S TXT=$$PAD($S(EXPL=VAR:VAR,1:EXPL),LEN)_DATA
"RTN","HLEVREP2",202,0)
 .  .  D ADDLINE(TXT)
"RTN","HLEVREP2",203,0)
 ;
"RTN","HLEVREP2",204,0)
 Q
"RTN","HLEVREP2",205,0)
 ;
"RTN","HLEVREP2",206,0)
MVSCRNH ; Create variable screen HORIZONTALly... (Only called if PAGE=1)
"RTN","HLEVREP2",207,0)
 ; Called by MONVSCRN - GBL,HLEVIENJ -- req
"RTN","HLEVREP2",208,0)
 N DATA,EXPL,HDR,NO,TXTHDR,TXTVAR
"RTN","HLEVREP2",209,0)
 ;
"RTN","HLEVREP2",210,0)
 D ADDLINE("")
"RTN","HLEVREP2",211,0)
 D ADDLINE($$CJ^XLFSTR("-------------------- Variables ----------------------",IOM))
"RTN","HLEVREP2",212,0)
 ;
"RTN","HLEVREP2",213,0)
 ; Header
"RTN","HLEVREP2",214,0)
 S VAR="",TXTHDR="",NO=0
"RTN","HLEVREP2",215,0)
 F  S VAR=$O(@GBL@("VD",VAR)) Q:VAR']""  D
"RTN","HLEVREP2",216,0)
 .  S EXPL=""
"RTN","HLEVREP2",217,0)
 .  F  S EXPL=$O(@GBL@("VD",VAR,EXPL)) Q:EXPL']""  D
"RTN","HLEVREP2",218,0)
 .  .  S HDR=$S(EXPL'=VAR:EXPL,1:VAR)
"RTN","HLEVREP2",219,0)
 .  .  S DATA=@GBL@("VD",VAR,EXPL)
"RTN","HLEVREP2",220,0)
 .  .  S X=$L(HDR),Y=$L(DATA),LEN=$S(X>Y:X,1:Y)
"RTN","HLEVREP2",221,0)
 .  .  S NO=NO+1,NO(NO)=LEN_U_HDR_U_DATA
"RTN","HLEVREP2",222,0)
 ;
"RTN","HLEVREP2",223,0)
 ; Header line...
"RTN","HLEVREP2",224,0)
 S NO=0,TXTHDR=""
"RTN","HLEVREP2",225,0)
 F  S NO=$O(NO(NO)) Q:NO'>0  D
"RTN","HLEVREP2",226,0)
 .  S DATA=NO(+NO)
"RTN","HLEVREP2",227,0)
 .  S LEN=+DATA,DATA=$P(DATA,U,2)
"RTN","HLEVREP2",228,0)
 .  S TXTHDR=TXTHDR_$S(TXTHDR]"":"  ",1:"")
"RTN","HLEVREP2",229,0)
 .  S TXTHDR=TXTHDR_$E(DATA_$$REPEAT^XLFSTR(" ",LEN),1,LEN)
"RTN","HLEVREP2",230,0)
 D ADDLINE(TXTHDR)
"RTN","HLEVREP2",231,0)
 ;
"RTN","HLEVREP2",232,0)
 D ADDLINE($$REPEAT^XLFSTR("=",IOM))
"RTN","HLEVREP2",233,0)
 ;
"RTN","HLEVREP2",234,0)
 ; Variables...
"RTN","HLEVREP2",235,0)
 S NO=0,TXTVAR=""
"RTN","HLEVREP2",236,0)
 F  S NO=$O(NO(NO)) Q:NO'>0  D
"RTN","HLEVREP2",237,0)
 .  S DATA=NO(+NO)
"RTN","HLEVREP2",238,0)
 .  S LEN=+DATA,DATA=$P(DATA,U,3)
"RTN","HLEVREP2",239,0)
 .  S TXTVAR=TXTVAR_$S(TXTVAR]"":"  ",1:"")
"RTN","HLEVREP2",240,0)
 .  S TXTVAR=TXTVAR_$E(DATA_$$REPEAT^XLFSTR(" ",LEN),1,LEN)
"RTN","HLEVREP2",241,0)
 D ADDLINE(TXTVAR)
"RTN","HLEVREP2",242,0)
 ;
"RTN","HLEVREP2",243,0)
 Q
"RTN","HLEVREP2",244,0)
 ;
"RTN","HLEVREP2",245,0)
MONRRD(HLEVIENJ) ; Build RUN DIARY...
"RTN","HLEVREP2",246,0)
 ; GBL,^TMP($J,"HLMON",+HLEVIENJ) -- req
"RTN","HLEVREP2",247,0)
 N NO
"RTN","HLEVREP2",248,0)
 ;
"RTN","HLEVREP2",249,0)
 QUIT:'$D(@GBL@("RUN"))  ;->
"RTN","HLEVREP2",250,0)
 ;
"RTN","HLEVREP2",251,0)
 D ADDLINE("")
"RTN","HLEVREP2",252,0)
 D ADDLINE($$CJ^XLFSTR("---------------------- Run Diary ------------------------",IOM))
"RTN","HLEVREP2",253,0)
 ;
"RTN","HLEVREP2",254,0)
 S NO=0
"RTN","HLEVREP2",255,0)
 S NO=$O(@GBL@("RUN",NO)) Q:NO'>0  D
"RTN","HLEVREP2",256,0)
 .  D ADDLINE(@GBL@("RUN",+NO))
"RTN","HLEVREP2",257,0)
 ;
"RTN","HLEVREP2",258,0)
 Q
"RTN","HLEVREP2",259,0)
 ;
"RTN","HLEVREP2",260,0)
 ;
"RTN","HLEVREP2",261,0)
MONMMT(HLEVIENJ) ; Build MSG TEXT...
"RTN","HLEVREP2",262,0)
 ; ^TMP($J,"HLMON",+HLEVIENJ) -- req
"RTN","HLEVREP2",263,0)
 N NO
"RTN","HLEVREP2",264,0)
 ;
"RTN","HLEVREP2",265,0)
 QUIT:'$D(@GBL@("MSG"))  ;->
"RTN","HLEVREP2",266,0)
 ;
"RTN","HLEVREP2",267,0)
 D ADDLINE("")
"RTN","HLEVREP2",268,0)
 D ADDLINE($$CJ^XLFSTR("-------------------- Message Text ----------------------",IOM))
"RTN","HLEVREP2",269,0)
 ;
"RTN","HLEVREP2",270,0)
 S NO=0
"RTN","HLEVREP2",271,0)
 S NO=$O(@GBL@("MSG",NO)) Q:NO'>0  D
"RTN","HLEVREP2",272,0)
 .  D ADDLINE(@GBL@("MSG",+NO))
"RTN","HLEVREP2",273,0)
 ;
"RTN","HLEVREP2",274,0)
 Q
"RTN","HLEVREP2",275,0)
 ;
"RTN","HLEVREP2",276,0)
 ;
"RTN","HLEVREP2",277,0)
PAD(VAR,COL) ; Make  "    var: "
"RTN","HLEVREP2",278,0)
 QUIT:$L(VAR)>(COL-3) VAR_":  " ;->
"RTN","HLEVREP2",279,0)
 Q $$REPEAT^XLFSTR(" ",COL-$L(VAR))_VAR_":  "
"RTN","HLEVREP2",280,0)
 ;
"RTN","HLEVREP2",281,0)
ADDLINE(TXT) ; Add line of text...
"RTN","HLEVREP2",282,0)
 N NO
"RTN","HLEVREP2",283,0)
 S NO=$O(@GBL@("VIEW",":"),-1)+1
"RTN","HLEVREP2",284,0)
 S @GBL@("VIEW",+NO)=TXT
"RTN","HLEVREP2",285,0)
 Q
"RTN","HLEVREP2",286,0)
 ;
"RTN","HLEVREP2",287,0)
 ;
"RTN","HLEVREP2",288,0)
ADD(VAR,COL) ; Add to TXT...
"RTN","HLEVREP2",289,0)
 N VAL
"RTN","HLEVREP2",290,0)
 S VAL=$P($G(@GBL@(VAR)),U,$S(VAR="STATR":4,1:3))
"RTN","HLEVREP2",291,0)
 S TXT=TXT_$S(TXT]"":"  ",1:"")_$E(VAL_$$REPEAT^XLFSTR(" ",COL),1,COL)
"RTN","HLEVREP2",292,0)
 Q
"RTN","HLEVREP2",293,0)
 ;
"RTN","HLEVREP2",294,0)
EOR ;HLEVREP2 - Event Monitor REPORTS ;5/16/03 14:42
"RTN","HLEVREP3")
0^23^B40672831
"RTN","HLEVREP3",1,0)
HLEVREP3 ;O-OIFO/LJA - Event Monitor REPORTS ;02/04/2004 14:42
"RTN","HLEVREP3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVREP3",3,0)
 ;
"RTN","HLEVREP3",4,0)
REMREQO ; Remote Requestable printout - [HLEV REMOTE REQUESTABLE LIST]
"RTN","HLEVREP3",5,0)
 N BY,DIC,DIOEND,FLDS,HLEVRRQ
"RTN","HLEVREP3",6,0)
 W @IOF,$$CJ^XLFSTR("Remote Requestable Monitors Report",IOM)
"RTN","HLEVREP3",7,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVREP3",8,0)
 W !,"Some monitors may be activated by remote server request.  This option sorts"
"RTN","HLEVREP3",9,0)
 W !,"all monitors by whether they are ""remote requestable""."
"RTN","HLEVREP3",10,0)
 W !
"RTN","HLEVREP3",11,0)
 S L="",DIC=776.1,BY="[HLEV REPORT MONITOR]",DIOEND="D RRQSUMM^HLEVREP3"
"RTN","HLEVREP3",12,0)
 S FLDS="[HLEV REMOTE REQUESTABLE]"
"RTN","HLEVREP3",13,0)
 D EN1^DIP
"RTN","HLEVREP3",14,0)
 Q
"RTN","HLEVREP3",15,0)
 ;
"RTN","HLEVREP3",16,0)
RRQSUMM ; Remote request summary...
"RTN","HLEVREP3",17,0)
 QUIT:'$D(HLEVRRQ("[NO]"))  ;->
"RTN","HLEVREP3",18,0)
 W !,"Fields having [NO] in the remote requestable field are not answered YES or"
"RTN","HLEVREP3",19,0)
 W !,"NO.  But, since the default action is NO, these blank fields are actually"
"RTN","HLEVREP3",20,0)
 W !,"an implied NO (no remote requesting allowed.)"
"RTN","HLEVREP3",21,0)
 I '$D(ZTQUEUED) D TELL^HLEVMST0("","0^0^0")
"RTN","HLEVREP3",22,0)
 Q
"RTN","HLEVREP3",23,0)
 ;
"RTN","HLEVREP3",24,0)
REMREQ() ; Called by [HLEV REMOTE REQUESTABLE] print template
"RTN","HLEVREP3",25,0)
 ; Return whether entry is remote requestable
"RTN","HLEVREP3",26,0)
 ; HLEVRRQ newed at top of print template run...
"RTN","HLEVREP3",27,0)
 S HLEVRRQ=$S(X=1:"YES",X=0:"NO",1:"[NO]")
"RTN","HLEVREP3",28,0)
 S HLEVRRQ(HLEVRRQ)=$G(HLEVRRQ(HLEVRRQ))+1
"RTN","HLEVREP3",29,0)
 Q HLEVRRQ
"RTN","HLEVREP3",30,0)
 ;
"RTN","HLEVREP3",31,0)
MONLOAD(HLEVIENJ) ; Load data into ^TMP...
"RTN","HLEVREP3",32,0)
 N DATA,EXPL,LEN,MIEN,NO,PAGE,REF,SUB,SUM,SUMX,SUMY,TITLE,VAR
"RTN","HLEVREP3",33,0)
 ;
"RTN","HLEVREP3",34,0)
 KILL ^TMP($J,"HLMON",+HLEVIENJ)
"RTN","HLEVREP3",35,0)
 ;
"RTN","HLEVREP3",36,0)
 ; Zero node
"RTN","HLEVREP3",37,0)
 S DATA=$G(^HLEV(776,+$G(HLEVIENJ),0)) QUIT:DATA']""  ;->
"RTN","HLEVREP3",38,0)
 D SET("START","Start",$$SDT^HLEVX001($P(DATA,U)))
"RTN","HLEVREP3",39,0)
 D SET("DONE","Finish",$$SDT^HLEVX001($P(DATA,U,2)))
"RTN","HLEVREP3",40,0)
 D SET("MONM","Monitor",$P($G(^HLEV(776.1,+$P(DATA,U,3),0)),U))
"RTN","HLEVREP3",41,0)
 D SET("STATR","Status",$$STAT776($P(DATA,U,4)))
"RTN","HLEVREP3",42,0)
 D SET("STATA","Appl",$P(DATA,U,5))
"RTN","HLEVREP3",43,0)
 D SET("TIME","T-Stamp",$$SDT^HLEVX001($P(DATA,U,6)))
"RTN","HLEVREP3",44,0)
 D SET("MAIL","Mail",$P(DATA,U,7))
"RTN","HLEVREP3",45,0)
 D SET("ZTSK","Task",$P(DATA,U,8))
"RTN","HLEVREP3",46,0)
 D SET("MST","Master",$P(DATA,U,9))
"RTN","HLEVREP3",47,0)
 ;
"RTN","HLEVREP3",48,0)
 ; Run Diary and Message Text...
"RTN","HLEVREP3",49,0)
 F SUB=50,51 D
"RTN","HLEVREP3",50,0)
 .  S TITLE=$S(SUB=50:"RUN",1:"MSG")
"RTN","HLEVREP3",51,0)
 .  S MIEN=0
"RTN","HLEVREP3",52,0)
 .  F  S MIEN=$O(^HLEV(776,+HLEVIENJ,SUB,MIEN)) Q:MIEN'>0  D
"RTN","HLEVREP3",53,0)
 .  .  S NO=$O(^TMP($J,"HLMON",+HLEVIENJ,TITLE,":"),-1)+1
"RTN","HLEVREP3",54,0)
 .  .  S ^TMP($J,"HLMON",+HLEVIENJ,TITLE,+NO)=^HLEV(776,+HLEVIENJ,SUB,MIEN,0)
"RTN","HLEVREP3",55,0)
 ;
"RTN","HLEVREP3",56,0)
 ; Variables...
"RTN","HLEVREP3",57,0)
 S MIEN=0,SUMX="",SUMY=""
"RTN","HLEVREP3",58,0)
 F  S MIEN=$O(^HLEV(776,+HLEVIENJ,52,MIEN)) Q:MIEN'>0  D
"RTN","HLEVREP3",59,0)
 .  S REF=$G(^HLEV(776,+HLEVIENJ,52,+MIEN,0)) QUIT:$P(REF,U)']""  ;->
"RTN","HLEVREP3",60,0)
 .  S VAR=$P(REF,U),EXPL=$P(REF,U,2),EXPL=$S(EXPL]"":EXPL,1:REF)
"RTN","HLEVREP3",61,0)
 .  S DATA=$G(^HLEV(776,+HLEVIENJ,52,+MIEN,52))
"RTN","HLEVREP3",62,0)
 .  S ^TMP($J,"HLMON",+HLEVIENJ,"VD",VAR,EXPL)=DATA
"RTN","HLEVREP3",63,0)
 .
"RTN","HLEVREP3",64,0)
 .  S LEN=$L(DATA) ; Length of data
"RTN","HLEVREP3",65,0)
 .  S LEN(1)=$L(EXPL) ; Length column header
"RTN","HLEVREP3",66,0)
 .  S LEN(2)=$S(LEN>LEN(1):LEN,1:LEN(1))+2 ; Largest length-data or header
"RTN","HLEVREP3",67,0)
 .  S LEN(3)=LEN+LEN(1)+3 ; Length - data + header
"RTN","HLEVREP3",68,0)
 .
"RTN","HLEVREP3",69,0)
 .  S ^TMP($J,"HLMON",+HLEVIENJ,"VX",LEN(2),VAR,EXPL)=""
"RTN","HLEVREP3",70,0)
 .  S ^TMP($J,"HLMON",+HLEVIENJ,"VY",+LEN(3),VAR,EXPL)=""
"RTN","HLEVREP3",71,0)
 .
"RTN","HLEVREP3",72,0)
 .  S $P(SUMX,U)=$P(SUMX,U)+1 ; # variables...
"RTN","HLEVREP3",73,0)
 .  S $P(SUMX,U,2)=$P(SUMX,U,2)+LEN(2)+2 ; Total columns required...
"RTN","HLEVREP3",74,0)
 .  I $P(SUMX,U,3)<(LEN(2)+1) S $P(SUMX,U,3)=LEN(2) ; Largest column
"RTN","HLEVREP3",75,0)
 .
"RTN","HLEVREP3",76,0)
 .  S $P(SUMY,U)=$P(SUMY,U)+1
"RTN","HLEVREP3",77,0)
 .  S $P(SUMY,U,2)=$P(SUMY,U,2)+1
"RTN","HLEVREP3",78,0)
 .  I $P(SUMY,U,3)<(LEN(3)+1) S $P(SUMY,U,3)=LEN(3)
"RTN","HLEVREP3",79,0)
 ;
"RTN","HLEVREP3",80,0)
 ; # Var header, Line and Var data "pages"...
"RTN","HLEVREP3",81,0)
 S LEN=0,PAGE=0,SUM=0
"RTN","HLEVREP3",82,0)
 F  S LEN=$O(^TMP($J,"HLMON",+HLEVIENJ,"VX",LEN)) Q:LEN'>0  D
"RTN","HLEVREP3",83,0)
 .  S:PAGE=0 PAGE=1
"RTN","HLEVREP3",84,0)
 .  I (SUM+LEN)>80 D
"RTN","HLEVREP3",85,0)
 .  .  S PAGE=PAGE+1,SUM=0
"RTN","HLEVREP3",86,0)
 .  S SUM=SUM+LEN
"RTN","HLEVREP3",87,0)
 S:PAGE $P(SUMX,U,4)=PAGE
"RTN","HLEVREP3",88,0)
 ;
"RTN","HLEVREP3",89,0)
 I SUMX]"" S ^TMP($J,"HLMON",+HLEVIENJ,"VX")=SUMX
"RTN","HLEVREP3",90,0)
 I SUMY]"" S ^TMP($J,"HLMON",+HLEVIENJ,"VY")=SUMY
"RTN","HLEVREP3",91,0)
 ;
"RTN","HLEVREP3",92,0)
 Q
"RTN","HLEVREP3",93,0)
 ;
"RTN","HLEVREP3",94,0)
 ;
"RTN","HLEVREP3",95,0)
SET(STORE,TAG,VAL) ; Store value to be displayed...
"RTN","HLEVREP3",96,0)
 S ^TMP($J,"HLMON",HLEVIENJ,STORE)=$S(VAL]"":1,1:"")_U_TAG_U_VAL
"RTN","HLEVREP3",97,0)
 Q
"RTN","HLEVREP3",98,0)
 ;
"RTN","HLEVREP3",99,0)
STAT776(STAT) ; Return status for use on report...
"RTN","HLEVREP3",100,0)
 QUIT STAT_U_$S(STAT="E":"Error",STAT="F":"Finish",STAT="Q":"Que'd",STAT="R":"Running",1:"")
"RTN","HLEVREP3",101,0)
 ;
"RTN","HLEVREP3",102,0)
CTRLMON ; Re/ask for monitor to display...
"RTN","HLEVREP3",103,0)
 N IEN776,IENDATE,IENONE,IOINHI,IOINORM,LASTONE,WORK,X
"RTN","HLEVREP3",104,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLEVREP3",105,0)
 S WORK=0
"RTN","HLEVREP3",106,0)
 W !
"RTN","HLEVREP3",107,0)
 S IEN776=$$ASKMON QUIT:IEN776'>0  ;->
"RTN","HLEVREP3",108,0)
 S WORK=1
"RTN","HLEVREP3",109,0)
 S IENDATE=$$ASKDATE(IEN776) QUIT:IENDATE'>0  ;->
"RTN","HLEVREP3",110,0)
CTRLMON1 ; Reask entry point...
"RTN","HLEVREP3",111,0)
 S IENONE=$$ASKONE(IEN776,IENDATE) I IENONE'>0 D  QUIT  ;->
"RTN","HLEVREP3",112,0)
 .  W !!!!,IOINHI,"Returning to display of daily map views...",IOINORM
"RTN","HLEVREP3",113,0)
 .  W !!
"RTN","HLEVREP3",114,0)
 D SHOW^HLEVREP2(+IENONE)
"RTN","HLEVREP3",115,0)
 I $P(IENONE,U,2)>1 D  G CTRLMON1 ;->
"RTN","HLEVREP3",116,0)
 .  D TELL^HLEVMST0("","0^0^999","Press RETURN to continue... ")
"RTN","HLEVREP3",117,0)
 G CTRLMON ;->
"RTN","HLEVREP3",118,0)
 ;
"RTN","HLEVREP3",119,0)
ASKMON() ; Ask user for a monitor to show...
"RTN","HLEVREP3",120,0)
 N DIC,X,Y
"RTN","HLEVREP3",121,0)
 S DIC=776.1,DIC(0)="AEMQ",DIC("A")="Select monitor to view, or RETURN to continue: "
"RTN","HLEVREP3",122,0)
 S DIC("S")="I $D(^TMP($J,""HLMAP"",""E"",+Y))"
"RTN","HLEVREP3",123,0)
 D ^DIC
"RTN","HLEVREP3",124,0)
 Q $S(+Y>0:+Y,1:"")
"RTN","HLEVREP3",125,0)
 ;
"RTN","HLEVREP3",126,0)
ASKDATE(IEN776) ;
"RTN","HLEVREP3",127,0)
 ; DATESEL -- req
"RTN","HLEVREP3",128,0)
 N DATE,DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLEVREP3",129,0)
 S DIR(0)="DA",DIR("A")="Select monitor RUN DATE: "
"RTN","HLEVREP3",130,0)
 S X=$$FMTE^XLFDT($O(^TMP($J,"HLMAP","E",+IEN776,DATESEL-.000001))) I X]"" S DIR("B")=X
"RTN","HLEVREP3",131,0)
ASKDATE1 ;
"RTN","HLEVREP3",132,0)
 S DIR("?")="Enter one of the ""run dates"" for this monitor.  (Enter ?? to see list of run dates.)"
"RTN","HLEVREP3",133,0)
 S DIR("??")="^D ASKDHELP^HLEVREP1"
"RTN","HLEVREP3",134,0)
 D ^DIR
"RTN","HLEVREP3",135,0)
 QUIT:$D(DIRUT)!($D(DTOUT))!($D(DUOUT)) "" ;->
"RTN","HLEVREP3",136,0)
 QUIT:$D(^TMP($J,"HLMAP","E",+IEN776,+Y)) +Y ;->
"RTN","HLEVREP3",137,0)
 D ASKDHELP
"RTN","HLEVREP3",138,0)
 G ASKDATE1 ;->
"RTN","HLEVREP3",139,0)
 ;
"RTN","HLEVREP3",140,0)
ASKDHELP ; Help for $$ASKDATE...
"RTN","HLEVREP3",141,0)
 W !!,"You must enter one of the following dates.  Data exists for... "
"RTN","HLEVREP3",142,0)
 W !!
"RTN","HLEVREP3",143,0)
 S DATE=0
"RTN","HLEVREP3",144,0)
 F  S DATE=$O(^TMP($J,"HLMAP","E",IEN776,DATE)) Q:DATE'>0  D
"RTN","HLEVREP3",145,0)
 .  S DATE(1)=$$FMTE^XLFDT(DATE)
"RTN","HLEVREP3",146,0)
 .  W:$X>70 !
"RTN","HLEVREP3",147,0)
 .  W $J(DATE(1),15)
"RTN","HLEVREP3",148,0)
 W !
"RTN","HLEVREP3",149,0)
 Q
"RTN","HLEVREP3",150,0)
 ;
"RTN","HLEVREP3",151,0)
ASKONE(IEN776,IENDATE) ;
"RTN","HLEVREP3",152,0)
 ; Defines and returns LASTONE...
"RTN","HLEVREP3",153,0)
 N DATA,DATE,DIR,DIRUT,DTOUT,DUOUT,HOLD,IEN,LAST,NEXT,NO,STAT,X,Y
"RTN","HLEVREP3",154,0)
 ;
"RTN","HLEVREP3",155,0)
 ; Find entries and build DIR string...
"RTN","HLEVREP3",156,0)
 S NO=0,IEN=0,DIR(0)="SO^"
"RTN","HLEVREP3",157,0)
 F  S IEN=$O(^TMP($J,"HLMAP","E",+IEN776,+IENDATE,IEN)) Q:'IEN  D
"RTN","HLEVREP3",158,0)
 .  S DATA=$G(^HLEV(776,+IEN,0)) QUIT:DATA']""  ;->
"RTN","HLEVREP3",159,0)
 .  S NO=NO+1
"RTN","HLEVREP3",160,0)
 .  S DATE=$P(DATA,U),STAT=$$STAT776^HLEVREP3($P(DATA,U,4))
"RTN","HLEVREP3",161,0)
 .  S HOLD(NO)=IEN_U_DATE
"RTN","HLEVREP3",162,0)
 .  S DATE(DATE)=IEN_U_STAT
"RTN","HLEVREP3",163,0)
 .  S DIR(0)=DIR(0)_$S(DIR(0)'="SO^":";",1:"")_NO_":"_$TR($$FMTE^XLFDT(DATE),":",".")_"  ["_$P(STAT,U,2)_"]"
"RTN","HLEVREP3",164,0)
 QUIT:NO'>0 "" ;->
"RTN","HLEVREP3",165,0)
 QUIT:NO=1 +HOLD(1)_U_1 ;->
"RTN","HLEVREP3",166,0)
 ;
"RTN","HLEVREP3",167,0)
 W !!,"This monitor was run more than once on the date you selected.  Please select"
"RTN","HLEVREP3",168,0)
 W !,"specific run time now..."
"RTN","HLEVREP3",169,0)
 S NEXT=$S($G(LASTONE)'>0:1,1:LASTONE+1),NEXT=$S($D(HOLD(NEXT)):NEXT,1:"")
"RTN","HLEVREP3",170,0)
 S DIR("A")="Select RUN TIME"
"RTN","HLEVREP3",171,0)
 I NEXT S DIR("B")=NEXT
"RTN","HLEVREP3",172,0)
 D ^DIR
"RTN","HLEVREP3",173,0)
 ;
"RTN","HLEVREP3",174,0)
 QUIT:'$D(HOLD(+$G(X))) "" ;-> User answered by entering number...
"RTN","HLEVREP3",175,0)
 ;
"RTN","HLEVREP3",176,0)
 S LASTONE=+X ; Used for DIR("B") later...
"RTN","HLEVREP3",177,0)
 ;
"RTN","HLEVREP3",178,0)
 Q +HOLD(+X)_U_NO
"RTN","HLEVREP3",179,0)
 ;
"RTN","HLEVREP3",180,0)
EOR ;HLEVREP3 - Event Monitor REPORTS ;5/16/03 14:42
"RTN","HLEVSRV")
0^24^B72146579
"RTN","HLEVSRV",1,0)
HLEVSRV ;O-OIFO/LJA - Event Monitor SERVER ;02/04/2004 14:42
"RTN","HLEVSRV",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVSRV",3,0)
 ;
"RTN","HLEVSRV",4,0)
 ; Send email to S.XQSCHK@SITE.VA.GOV to check server status.
"RTN","HLEVSRV",5,0)
 ; (Include the name of server (w/o S.) in body of message.)
"RTN","HLEVSRV",6,0)
 ;
"RTN","HLEVSRV",7,0)
SERVER ; Called to get information about local monitoring system
"RTN","HLEVSRV",8,0)
 N ADDREQHD,MXEC,NOW,XMER,XMPOS,XMRG,XTMP
"RTN","HLEVSRV",9,0)
 ;
"RTN","HLEVSRV",10,0)
 ;[M]S MXEC=$$MST^HLEVSRV1 ; Is M code execution allowed?
"RTN","HLEVSRV",11,0)
 ;
"RTN","HLEVSRV",12,0)
 S NOW=$$NOW^XLFDT,XTMP="HLEV SERVER "_NOW
"RTN","HLEVSRV",13,0)
 S ^XTMP(XTMP,0)=$$FMADD^XLFDT(NOW,2)_U_NOW_"^HLEV SERVER REQUEST^"_$G(XMFROM)
"RTN","HLEVSRV",14,0)
 ;
"RTN","HLEVSRV",15,0)
 I $G(XMZ)'>0!($G(XMREC)']"") D  QUIT  ;->
"RTN","HLEVSRV",16,0)
 .  S ^XTMP(XTMP,"ERR")="No XMZ or XMREC"
"RTN","HLEVSRV",17,0)
 ;
"RTN","HLEVSRV",18,0)
 S ^XTMP(XTMP,"MAIL")=XMZ
"RTN","HLEVSRV",19,0)
 ;
"RTN","HLEVSRV",20,0)
 S XMPOS=""
"RTN","HLEVSRV",21,0)
 ;
"RTN","HLEVSRV",22,0)
READ ; Sequentially read thru message
"RTN","HLEVSRV",23,0)
 X XMREC
"RTN","HLEVSRV",24,0)
 I $D(XMER) G PROCESS:XMER<0 ;->
"RTN","HLEVSRV",25,0)
 D ADDLINE(XMRG)
"RTN","HLEVSRV",26,0)
 G READ ;->
"RTN","HLEVSRV",27,0)
 ;
"RTN","HLEVSRV",28,0)
 ;======================================================================
"RTN","HLEVSRV",29,0)
 ;
"RTN","HLEVSRV",30,0)
PROCESS ; Multiple "data request" formats possible...
"RTN","HLEVSRV",31,0)
 ;[M]; MXEC -- req
"RTN","HLEVSRV",32,0)
 N SUB
"RTN","HLEVSRV",33,0)
 ;
"RTN","HLEVSRV",34,0)
 D EXTRACT
"RTN","HLEVSRV",35,0)
 D REQBACK ; Echo what was requested
"RTN","HLEVSRV",36,0)
 ;
"RTN","HLEVSRV",37,0)
 ;[M]S MXEC=$P(MXEC,U)+$P(MXEC,U,4)
"RTN","HLEVSRV",38,0)
 ;[M]I MXEC=2 D  QUIT:$G(HLEVQUIT)  ;-> Pre-load M code execution
"RTN","HLEVSRV",39,0)
 ;[M].  D MPRE^HLEVSRV0
"RTN","HLEVSRV",40,0)
 D LOADATA
"RTN","HLEVSRV",41,0)
 ;[M]I MXEC=2 D  QUIT:$G(HLEVQUIT)  ;-> Post-load M code execution
"RTN","HLEVSRV",42,0)
 ;[M].  D MPST^HLEVSRV0
"RTN","HLEVSRV",43,0)
 ;[M].  D MCOND^HLEVSRV0
"RTN","HLEVSRV",44,0)
 ;[M].  D MCALLREC^HLEVSRV0
"RTN","HLEVSRV",45,0)
 ;[M].  D MTEXT^HLEVSRV0
"RTN","HLEVSRV",46,0)
 D XTMPMAIL ; Place at bottom of message XTMP value
"RTN","HLEVSRV",47,0)
 D MAILIT
"RTN","HLEVSRV",48,0)
 D KILLS
"RTN","HLEVSRV",49,0)
 ;
"RTN","HLEVSRV",50,0)
 Q
"RTN","HLEVSRV",51,0)
 ;
"RTN","HLEVSRV",52,0)
 ;======================================================================
"RTN","HLEVSRV",53,0)
 ;
"RTN","HLEVSRV",54,0)
EXTRACT ; Extract out the work list...
"RTN","HLEVSRV",55,0)
 ; XTMP -- req
"RTN","HLEVSRV",56,0)
 N CT,FILE,LNO,TXT
"RTN","HLEVSRV",57,0)
 S LNO=0,CT=0
"RTN","HLEVSRV",58,0)
 F  S LNO=$O(^XTMP(XTMP,"RQ",LNO)) Q:LNO'>0  D
"RTN","HLEVSRV",59,0)
 .  S TXT=$$CHKREQ($G(^XTMP(XTMP,"RQ",LNO))) QUIT:TXT']""  ;->
"RTN","HLEVSRV",60,0)
 .  S FILE=$P(TXT,U) ; Type of request in "FILE"...
"RTN","HLEVSRV",61,0)
 .
"RTN","HLEVSRV",62,0)
 .  ; There are 3 types of "data requests"...
"RTN","HLEVSRV",63,0)
 .  I FILE="QUERY" D EXTQUERY($P(TXT,U,2,99)) QUIT  ;-> $QUERY format...
"RTN","HLEVSRV",64,0)
 .  I FILE="UNIT" D UNIT^HLEVSRV0($P(TXT,U,2,99)) QUIT  ;-> Msg ID
"RTN","HLEVSRV",65,0)
 .  I $$OKFILE(+FILE) D EXTFILE(TXT) QUIT  ;->
"RTN","HLEVSRV",66,0)
 .
"RTN","HLEVSRV",67,0)
 .  ; If not a data request, must be a non-VistA HL7 request.  And,
"RTN","HLEVSRV",68,0)
 .  ; if so, they have to pass a license
"RTN","HLEVSRV",69,0)
 .  I FILE="LICENSE" D CHKLIC^HLEVSRV4($P(TXT,U,2,99),$G(XMFROM)) QUIT  ;->
"RTN","HLEVSRV",70,0)
 .
"RTN","HLEVSRV",71,0)
 .  D ADDREQHD,ADDREQ("Error (HEADER)^"_TXT)
"RTN","HLEVSRV",72,0)
 Q
"RTN","HLEVSRV",73,0)
 ;
"RTN","HLEVSRV",74,0)
CHKREQ(TXT) ; Check request, strip comments, etc...
"RTN","HLEVSRV",75,0)
 N I
"RTN","HLEVSRV",76,0)
 ;
"RTN","HLEVSRV",77,0)
 ; Strip comments...
"RTN","HLEVSRV",78,0)
 I $L(TXT,";")>1 S TXT=$P(TXT,";",1,$L(TXT,";")-1)
"RTN","HLEVSRV",79,0)
 ;
"RTN","HLEVSRV",80,0)
 ; Ignore blank lines, and dashed lines...
"RTN","HLEVSRV",81,0)
 QUIT:$TR(TXT," -=;")']"" "" ;->
"RTN","HLEVSRV",82,0)
 ;
"RTN","HLEVSRV",83,0)
 ; Strip leading and trailing spaces...
"RTN","HLEVSRV",84,0)
 X "F I=1:1:$L(TXT) Q:$E(TXT,I)'="" """ S TXT=$E(TXT,I,999) ; Leading
"RTN","HLEVSRV",85,0)
 X "F I=$L(TXT):-1:1 Q:$E(TXT,I)'="" """ S TXT=$E(TXT,1,I) ;  Trailing
"RTN","HLEVSRV",86,0)
 ;
"RTN","HLEVSRV",87,0)
 Q TXT
"RTN","HLEVSRV",88,0)
 ;
"RTN","HLEVSRV",89,0)
LOADATA ; Process the work list...
"RTN","HLEVSRV",90,0)
 D LOADFNO
"RTN","HLEVSRV",91,0)
 D LOADQRY
"RTN","HLEVSRV",92,0)
 D LOADUNIT^HLEVSRV0 ; Msg ID-related data
"RTN","HLEVSRV",93,0)
 D GBLTOXM^HLEVSRV1 ; 776 format data to send back
"RTN","HLEVSRV",94,0)
 Q
"RTN","HLEVSRV",95,0)
 ;
"RTN","HLEVSRV",96,0)
LOADFNO ; Load data from file number...
"RTN","HLEVSRV",97,0)
 N FILE,NODE,WHAT
"RTN","HLEVSRV",98,0)
 D ADDMAIL("")
"RTN","HLEVSRV",99,0)
 S FILE=0
"RTN","HLEVSRV",100,0)
 F  S FILE=$O(^XTMP(XTMP,"HLEV PROC","F",FILE)) Q:FILE'>0  D
"RTN","HLEVSRV",101,0)
 .  S WHAT=""
"RTN","HLEVSRV",102,0)
 .  F  S WHAT=$O(^XTMP(XTMP,"HLEV PROC","F",FILE,WHAT)) Q:WHAT']""  D
"RTN","HLEVSRV",103,0)
 .  .  S NODE=""
"RTN","HLEVSRV",104,0)
 .  .  F  S NODE=$O(^XTMP(XTMP,"HLEV PROC","F",FILE,WHAT,NODE)) Q:NODE']""  D
"RTN","HLEVSRV",105,0)
 .  .  .  S LIMIT=$G(^XTMP(XTMP,"HLEV PROC","F",FILE,WHAT,NODE))
"RTN","HLEVSRV",106,0)
 .  .  .  D LOAD(FILE,WHAT,NODE,LIMIT)
"RTN","HLEVSRV",107,0)
 Q
"RTN","HLEVSRV",108,0)
 ;
"RTN","HLEVSRV",109,0)
LOADQRY ; Load $QUERY data...
"RTN","HLEVSRV",110,0)
 N NO
"RTN","HLEVSRV",111,0)
 ;
"RTN","HLEVSRV",112,0)
 QUIT:'$D(^XTMP(XTMP,"HLQUERY"))  ;->
"RTN","HLEVSRV",113,0)
 D ADDMAIL("")
"RTN","HLEVSRV",114,0)
 D ADDMAIL("$QUERY Data"),ADDMAIL($$REPEAT^XLFSTR("-",74))
"RTN","HLEVSRV",115,0)
 ;
"RTN","HLEVSRV",116,0)
 ; Load $QUERY format data...
"RTN","HLEVSRV",117,0)
 S NO=0
"RTN","HLEVSRV",118,0)
 F  S NO=$O(^XTMP(XTMP,"HLQUERY",NO)) Q:NO'>0  D
"RTN","HLEVSRV",119,0)
 .  D LOADQ(^XTMP(XTMP,"HLQUERY",+NO))
"RTN","HLEVSRV",120,0)
 ;
"RTN","HLEVSRV",121,0)
 Q
"RTN","HLEVSRV",122,0)
 ;
"RTN","HLEVSRV",123,0)
REQBACK ; Send back what was requested...
"RTN","HLEVSRV",124,0)
 N SNO
"RTN","HLEVSRV",125,0)
 ;
"RTN","HLEVSRV",126,0)
 S SNO=0
"RTN","HLEVSRV",127,0)
 F  S SNO=$O(^XTMP(XTMP,"HLREQ",SNO)) Q:SNO'>0  D
"RTN","HLEVSRV",128,0)
 .  D ADDMAIL(^XTMP(XTMP,"HLREQ",SNO))
"RTN","HLEVSRV",129,0)
 ;
"RTN","HLEVSRV",130,0)
 Q
"RTN","HLEVSRV",131,0)
 ;
"RTN","HLEVSRV",132,0)
XTMPMAIL ; Add XTMP reference to bottom of email...
"RTN","HLEVSRV",133,0)
 D ADDMAIL(""),ADDMAIL("")
"RTN","HLEVSRV",134,0)
 D ADDMAIL("Remote request by: "_$G(XMFROM)),ADDMAIL("")
"RTN","HLEVSRV",135,0)
 D ADDMAIL("[Query log stored in ^XTMP("""_XTMP_""") at site.]")
"RTN","HLEVSRV",136,0)
 Q
"RTN","HLEVSRV",137,0)
 ;
"RTN","HLEVSRV",138,0)
MAILIT ; Mail report back to HL7 mail group...
"RTN","HLEVSRV",139,0)
 ; XTMP -- req
"RTN","HLEVSRV",140,0)
 N NO,TEXT,X,XMDUZ,XMSUB,XMTEXT,XMZ
"RTN","HLEVSRV",141,0)
 S XMDUZ=.5,XMTEXT="^XTMP("""_XTMP_""",""HLMAIL"","
"RTN","HLEVSRV",142,0)
 S X=$$SITE^VASITE,XMSUB="HLEV SERVER REQUEST "_$P(X,U,2)_" [#"_$P(X,U,3)_"]"
"RTN","HLEVSRV",143,0)
 ;
"RTN","HLEVSRV",144,0)
 ; Only send to VistA HL7 team members!!!!
"RTN","HLEVSRV",145,0)
 S XMY("HL7SystemMonitoring@med.va.gov")=""
"RTN","HLEVSRV",146,0)
 ;
"RTN","HLEVSRV",147,0)
 D ^XMD
"RTN","HLEVSRV",148,0)
 ;
"RTN","HLEVSRV",149,0)
 S $P(^XTMP(XTMP,"MAIL"),U,2)=$G(XMZ)
"RTN","HLEVSRV",150,0)
 ;
"RTN","HLEVSRV",151,0)
 QUIT
"RTN","HLEVSRV",152,0)
 ;
"RTN","HLEVSRV",153,0)
KILLS ; Remove unwanted ^XTMP subscripts...
"RTN","HLEVSRV",154,0)
 F SUB="DATA","HLEV PROC","HLMAIL","HLUNIT","HLQUERY","HLREQ","M","MTXT" D
"RTN","HLEVSRV",155,0)
 .  KILL ^XTMP(XTMP,SUB)
"RTN","HLEVSRV",156,0)
 ;
"RTN","HLEVSRV",157,0)
 Q
"RTN","HLEVSRV",158,0)
 ;
"RTN","HLEVSRV",159,0)
 ; =====================================================================
"RTN","HLEVSRV",160,0)
 ;
"RTN","HLEVSRV",161,0)
LOAD(FILE,WHAT,NODE,LIMIT) ;
"RTN","HLEVSRV",162,0)
 N CT,DATA,GBL,IEN
"RTN","HLEVSRV",163,0)
 ;
"RTN","HLEVSRV",164,0)
 S LIMIT=$G(LIMIT)
"RTN","HLEVSRV",165,0)
 S GBL=$$GBLFILE(+FILE) QUIT:GBL']""  ;->
"RTN","HLEVSRV",166,0)
 ;
"RTN","HLEVSRV",167,0)
 ; If passed in an IEN...
"RTN","HLEVSRV",168,0)
 I WHAT=+WHAT D LOADONE(FILE,+WHAT,NODE),ADDMAIL("")
"RTN","HLEVSRV",169,0)
 ;
"RTN","HLEVSRV",170,0)
 ; Check to make sure it is ALL...
"RTN","HLEVSRV",171,0)
 QUIT:WHAT'["ALL"  ;->
"RTN","HLEVSRV",172,0)
 ;
"RTN","HLEVSRV",173,0)
 S IEN=0,CT=0,LIMIT=$S(LIMIT:LIMIT,1:99999)
"RTN","HLEVSRV",174,0)
 F  S IEN=$O(@GBL@(IEN)) Q:IEN'>0!(CT>(LIMIT-1))  D
"RTN","HLEVSRV",175,0)
 .  D LOADONE(FILE,+IEN,NODE,LIMIT)
"RTN","HLEVSRV",176,0)
 .  S CT=CT+1
"RTN","HLEVSRV",177,0)
 ;
"RTN","HLEVSRV",178,0)
 I CT D ADDMAIL("")
"RTN","HLEVSRV",179,0)
 ;
"RTN","HLEVSRV",180,0)
 Q
"RTN","HLEVSRV",181,0)
 ;
"RTN","HLEVSRV",182,0)
LOADONE(FILE,IEN,NODE,LIMIT) ; Load one entry...
"RTN","HLEVSRV",183,0)
 N DATA,GBL,MIEN,MONM,ND,TXT
"RTN","HLEVSRV",184,0)
 ;
"RTN","HLEVSRV",185,0)
 S LIMIT=$G(LIMIT)
"RTN","HLEVSRV",186,0)
 S GBL=$$GBLFILE(+FILE) QUIT:GBL']""  ;->
"RTN","HLEVSRV",187,0)
 ;
"RTN","HLEVSRV",188,0)
 ; Node (not multiple or WP) requested...
"RTN","HLEVSRV",189,0)
 I $D(@GBL@(+IEN,NODE))#2 D  QUIT  ;->
"RTN","HLEVSRV",190,0)
 .  S DATA=$G(@GBL@(+IEN,NODE))
"RTN","HLEVSRV",191,0)
 .  S ^XTMP(XTMP,"DATA",FILE,+IEN,NODE)=DATA
"RTN","HLEVSRV",192,0)
 ;
"RTN","HLEVSRV",193,0)
 Q
"RTN","HLEVSRV",194,0)
 ;
"RTN","HLEVSRV",195,0)
 ; =====================================================================
"RTN","HLEVSRV",196,0)
 ;
"RTN","HLEVSRV",197,0)
EXTFILE(TXT) ; Extract 776 data...
"RTN","HLEVSRV",198,0)
 N FILE,GBL,LIMIT,LOOPI,NODES,WHAT
"RTN","HLEVSRV",199,0)
 ;
"RTN","HLEVSRV",200,0)
 ; Sets...
"RTN","HLEVSRV",201,0)
 S FILE=+TXT,GBL=$$GBLFILE(FILE) QUIT:GBL']""  ;->
"RTN","HLEVSRV",202,0)
 S WHAT=$P(TXT,U,2)
"RTN","HLEVSRV",203,0)
 I WHAT']"" S WHAT="ALL"
"RTN","HLEVSRV",204,0)
 I WHAT=+WHAT QUIT:$G(@GBL@(+WHAT,0))']""  ;->
"RTN","HLEVSRV",205,0)
 S NODES=$TR($P(TXT,U,3),"~",U),LIMIT=$P(TXT,U,4)
"RTN","HLEVSRV",206,0)
 ;
"RTN","HLEVSRV",207,0)
 ; Build nodes requested list...
"RTN","HLEVSRV",208,0)
 F LOOPI=1:1:$L(NODES,U) S NODE=$P(NODES,U,LOOPI) I NODE]"" D
"RTN","HLEVSRV",209,0)
 .  S ^XTMP(XTMP,"HLEV PROC","F",FILE,WHAT,NODE)=LIMIT
"RTN","HLEVSRV",210,0)
 .  D ADDREQHD
"RTN","HLEVSRV",211,0)
 .  S TXT=$E("[#1] "_FILE_$S(LIMIT:" #"_LIMIT,1:"")_$$REPEAT^XLFSTR(" ",18),1,18)
"RTN","HLEVSRV",212,0)
 .  I LOOPI>1 S LIMIT=""
"RTN","HLEVSRV",213,0)
 .  S TXT=TXT_$E("[#2] "_$S(WHAT=+WHAT:"#"_WHAT,1:WHAT)_$$REPEAT^XLFSTR(" ",18),1,18)
"RTN","HLEVSRV",214,0)
 .  S TXT=TXT_"[#3] "_NODE
"RTN","HLEVSRV",215,0)
 .  D ADDREQ(TXT)
"RTN","HLEVSRV",216,0)
 ;
"RTN","HLEVSRV",217,0)
 Q
"RTN","HLEVSRV",218,0)
 ;
"RTN","HLEVSRV",219,0)
GBLFILE(FILE) ; Return closed global root...
"RTN","HLEVSRV",220,0)
 N CH,GBL
"RTN","HLEVSRV",221,0)
 S GBL=$G(^DIC(+FILE,0,"GL"))
"RTN","HLEVSRV",222,0)
 S CH=$E(GBL,$L(GBL))
"RTN","HLEVSRV",223,0)
 I CH="," QUIT $E(GBL,1,$L(GBL)-1)_")" ;->
"RTN","HLEVSRV",224,0)
 I CH="(" QUIT $E(GBL,1,$L(GBL)-1)
"RTN","HLEVSRV",225,0)
 Q ""
"RTN","HLEVSRV",226,0)
 ;
"RTN","HLEVSRV",227,0)
EXTQUERY(VAL) ; Extract $QUERY format requests...
"RTN","HLEVSRV",228,0)
 ;
"RTN","HLEVSRV",229,0)
 ; Format:  p(1) = $QUERY reference.  (E.g., "^DPT(25)")
"RTN","HLEVSRV",230,0)
 ;          p(2) = $QUERY stop value. (E.g., "^DPT(25,")
"RTN","HLEVSRV",231,0)
 ;          p(3) = # lines limit
"RTN","HLEVSRV",232,0)
 ;          p(4) = Screen format (E.g., "^DPT(#,0)")
"RTN","HLEVSRV",233,0)
 ;
"RTN","HLEVSRV",234,0)
 N LPVAL,NO,NOLINE,SCREEN,STOP
"RTN","HLEVSRV",235,0)
 ;
"RTN","HLEVSRV",236,0)
 ; Get values...
"RTN","HLEVSRV",237,0)
 QUIT:'$$OKVARSQ(VAL)  ;->
"RTN","HLEVSRV",238,0)
 ;
"RTN","HLEVSRV",239,0)
 ; Loop and collect now...
"RTN","HLEVSRV",240,0)
 S NO=$O(^XTMP(XTMP,"HLQUERY",":"),-1)+1
"RTN","HLEVSRV",241,0)
 S ^XTMP(XTMP,"HLQUERY",+NO)=VAL
"RTN","HLEVSRV",242,0)
 ;
"RTN","HLEVSRV",243,0)
 ; Add to list of items being queried...
"RTN","HLEVSRV",244,0)
 S TXT=""
"RTN","HLEVSRV",245,0)
 F PCE=1:1:$L(VAL,U) D
"RTN","HLEVSRV",246,0)
 .  S DATA=$P(VAL,U,PCE)
"RTN","HLEVSRV",247,0)
 .  I PCE=1!(PCE=2)!(PCE=4) S DATA=U_DATA
"RTN","HLEVSRV",248,0)
 .  I PCE=3 D
"RTN","HLEVSRV",249,0)
 .  .  I DATA']"" S DATA="[1000]"
"RTN","HLEVSRV",250,0)
 .  .  S DATA=" "_DATA
"RTN","HLEVSRV",251,0)
 .  S DATA="[#"_PCE_"]"_DATA
"RTN","HLEVSRV",252,0)
 .  I $L(DATA)>15 S DATA=$P(DATA,"]",2,99)
"RTN","HLEVSRV",253,0)
 .  S DATA=$S($L(DATA)>15:DATA_" ",1:$E(DATA_$$REPEAT^XLFSTR(" ",15),1,15))
"RTN","HLEVSRV",254,0)
 .  S TXT=TXT_$S(TXT]"":"   ",1:"")_DATA
"RTN","HLEVSRV",255,0)
 ;
"RTN","HLEVSRV",256,0)
 I TXT]"" D
"RTN","HLEVSRV",257,0)
 .  D ADDREQHD
"RTN","HLEVSRV",258,0)
 .  D ADDREQ(TXT)
"RTN","HLEVSRV",259,0)
 ;
"RTN","HLEVSRV",260,0)
 Q
"RTN","HLEVSRV",261,0)
 ;
"RTN","HLEVSRV",262,0)
OKVARSQ(VAL)  ; Are variables OK for $QUERY looping?
"RTN","HLEVSRV",263,0)
 ; Defines (and "leaves around") LPVAL,STOP,NOLINE,SCREEN...
"RTN","HLEVSRV",264,0)
 S (LPVAL,NOLINE,SCREEN,STOP)=""
"RTN","HLEVSRV",265,0)
 S LPVAL=U_$P(VAL,U) S X="W "_LPVAL D ^DIM QUIT:'$D(X) "" ;->
"RTN","HLEVSRV",266,0)
 QUIT:$E(LPVAL,1,3)'="^HL"&($E(LPVAL,1,8)'="^ORD(101") "" ;->
"RTN","HLEVSRV",267,0)
 S STOP=U_$P(VAL,U,2) S X="W "_STOP_"25)" D ^DIM QUIT:'$D(X) "" ;->
"RTN","HLEVSRV",268,0)
 S X=$P(VAL,U,3),NOLINE=$S(X>1000:1000,X>0:X,1:1000)
"RTN","HLEVSRV",269,0)
 S SCREEN=$P(VAL,U,4) I SCREEN]"" D  QUIT:'$D(X) "" ;->
"RTN","HLEVSRV",270,0)
 .  S SCREEN=U_SCREEN
"RTN","HLEVSRV",271,0)
 .  S X="W "_$TR(SCREEN,"#",1) D ^DIM
"RTN","HLEVSRV",272,0)
 QUIT 1
"RTN","HLEVSRV",273,0)
 ;
"RTN","HLEVSRV",274,0)
LOADQ(VAL) ; Load $QUERY format data...
"RTN","HLEVSRV",275,0)
 N CT,LPVAL,NO,NOLINE,POSX,REF,SCREEN,STOP,TXT
"RTN","HLEVSRV",276,0)
 ;
"RTN","HLEVSRV",277,0)
 ; Already checked format. But, this call sets up looping variables...
"RTN","HLEVSRV",278,0)
 QUIT:'$$OKVARSQ(VAL)  ;->
"RTN","HLEVSRV",279,0)
 ;
"RTN","HLEVSRV",280,0)
 S CT=0
"RTN","HLEVSRV",281,0)
 F  S LPVAL=$Q(@LPVAL) Q:$$QUITQ^HLEVSRV0(LPVAL,STOP,NOLINE,CT)  D
"RTN","HLEVSRV",282,0)
 .  I SCREEN]"" QUIT:$$QUITS^HLEVSRV0(LPVAL,SCREEN)  ;->
"RTN","HLEVSRV",283,0)
 .  S REF=LPVAL_"=",POSX=$L(REF)
"RTN","HLEVSRV",284,0)
 .  S DATA=@LPVAL,CT=CT+1
"RTN","HLEVSRV",285,0)
 .  F  D  QUIT:$TR(REF," ","")']""&(DATA']"")
"RTN","HLEVSRV",286,0)
 .  .  S TXT=REF_$E(DATA,1,74-$L(REF))
"RTN","HLEVSRV",287,0)
 .  .  D ADDMAIL(TXT)
"RTN","HLEVSRV",288,0)
 .  .  S CT=CT+1
"RTN","HLEVSRV",289,0)
 .  .  S DATA=$E(DATA,74-$L(REF)+1,999)
"RTN","HLEVSRV",290,0)
 .  .  S REF=$$REPEAT^XLFSTR(" ",POSX)
"RTN","HLEVSRV",291,0)
 ;
"RTN","HLEVSRV",292,0)
 I CT D ADDMAIL("")
"RTN","HLEVSRV",293,0)
 ;
"RTN","HLEVSRV",294,0)
 Q
"RTN","HLEVSRV",295,0)
 ;
"RTN","HLEVSRV",296,0)
 ; =====================================================================
"RTN","HLEVSRV",297,0)
 ;
"RTN","HLEVSRV",298,0)
ADDREQHD ; Add Header to request record in email...
"RTN","HLEVSRV",299,0)
 S ADDREQHD=$G(ADDREQHD)+1 QUIT:ADDREQHD>1  ;->
"RTN","HLEVSRV",300,0)
 D ADDREQ(""),ADDREQ("Data Requests")
"RTN","HLEVSRV",301,0)
 D ADDREQ($$REPEAT^XLFSTR("-",74))
"RTN","HLEVSRV",302,0)
 Q
"RTN","HLEVSRV",303,0)
 ;
"RTN","HLEVSRV",304,0)
ADDLINE(XMRG) ; Add read line of text to ^TMP...
"RTN","HLEVSRV",305,0)
 N LNO
"RTN","HLEVSRV",306,0)
 S LNO=$O(^XTMP(XTMP,"RQ",":"),-1)+1
"RTN","HLEVSRV",307,0)
 S ^XTMP(XTMP,"RQ",+LNO)=XMRG
"RTN","HLEVSRV",308,0)
 Q
"RTN","HLEVSRV",309,0)
 ;
"RTN","HLEVSRV",310,0)
ADDREQ(TXT) ; Add data request to be added to ^XTMP(XTMP,"HLMAIL") later
"RTN","HLEVSRV",311,0)
 N SNO
"RTN","HLEVSRV",312,0)
 S SNO=$O(^XTMP(XTMP,"HLREQ",":"),-1)+1
"RTN","HLEVSRV",313,0)
 S ^XTMP(XTMP,"HLREQ",+SNO)=TXT
"RTN","HLEVSRV",314,0)
 Q
"RTN","HLEVSRV",315,0)
 ;
"RTN","HLEVSRV",316,0)
ADDMAIL(TXT) D ADDMAIL^HLEVSRV2(TXT)
"RTN","HLEVSRV",317,0)
 Q
"RTN","HLEVSRV",318,0)
 ;
"RTN","HLEVSRV",319,0)
OKFILE(FILE) QUIT:+FILE=101 1 ;->
"RTN","HLEVSRV",320,0)
 I FILE>769.99999&(FILE<870) QUIT 1 ;->
"RTN","HLEVSRV",321,0)
 Q ""
"RTN","HLEVSRV",322,0)
 ;
"RTN","HLEVSRV",323,0)
EOR ;HLEVSRV - Event Monitor SERVER ;5/16/03 14:42
"RTN","HLEVSRV0")
0^26^B78829330
"RTN","HLEVSRV0",1,0)
HLEVSRV0 ;O-OIFO/LJA - Event Monitor SERVER ;02/04/2004 14:42
"RTN","HLEVSRV0",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVSRV0",3,0)
 ;
"RTN","HLEVSRV0",4,0)
M(TXT) ; Called when M code data requested in...
"RTN","HLEVSRV0",5,0)
 ; MXEC,XTMP -- req
"RTN","HLEVSRV0",6,0)
 N MCODE,NO,MTAG,WHEN
"RTN","HLEVSRV0",7,0)
 ;
"RTN","HLEVSRV0",8,0)
 ; Sets...
"RTN","HLEVSRV0",9,0)
 S WHEN=$P(TXT,U)
"RTN","HLEVSRV0",10,0)
 ;
"RTN","HLEVSRV0",11,0)
 ; Has license been sent?
"RTN","HLEVSRV0",12,0)
 I WHEN="LICENSE" D  QUIT  ;->
"RTN","HLEVSRV0",13,0)
 .  QUIT:$P(MXEC,U,4)]""  ;->
"RTN","HLEVSRV0",14,0)
 .  S MCODE=$P(TXT,U,2)
"RTN","HLEVSRV0",15,0)
 .  I '$$OKCODE^HLEVSRV1(MCODE) S $P(MXEC,U,4)=0 QUIT  ;->
"RTN","HLEVSRV0",16,0)
 .  S $P(MXEC,U,4)=1 ; Force DOWN...
"RTN","HLEVSRV0",17,0)
 ;
"RTN","HLEVSRV0",18,0)
 QUIT:WHEN'="BEFORE"&(WHEN'="AFTER")  ;->
"RTN","HLEVSRV0",19,0)
 S MTAG=$P(TXT,U,2) QUIT:MTAG']""  ;->
"RTN","HLEVSRV0",20,0)
 S MCODE=$P(TXT,U,3,999) Q:MCODE']""  ;->
"RTN","HLEVSRV0",21,0)
 ;
"RTN","HLEVSRV0",22,0)
 ; Is it valid M code?
"RTN","HLEVSRV0",23,0)
 S X=MCODE D ^DIM QUIT:'$D(X)  ;->
"RTN","HLEVSRV0",24,0)
 ;
"RTN","HLEVSRV0",25,0)
 S NO=$O(^XTMP(XTMP,"M",WHEN,MTAG,":"),-1)+1
"RTN","HLEVSRV0",26,0)
 S ^XTMP(XTMP,"M",WHEN,MTAG,+NO)=MCODE
"RTN","HLEVSRV0",27,0)
 ;
"RTN","HLEVSRV0",28,0)
 Q
"RTN","HLEVSRV0",29,0)
 ;
"RTN","HLEVSRV0",30,0)
MPRE ; Run M code before load of data...
"RTN","HLEVSRV0",31,0)
 ; XTMP -- req
"RTN","HLEVSRV0",32,0)
 D MRUN("BEFORE")
"RTN","HLEVSRV0",33,0)
 Q
"RTN","HLEVSRV0",34,0)
 ;
"RTN","HLEVSRV0",35,0)
MPST ; Run M code after load of data...
"RTN","HLEVSRV0",36,0)
 ; XTMP -- req
"RTN","HLEVSRV0",37,0)
 D MRUN("AFTER")
"RTN","HLEVSRV0",38,0)
 Q
"RTN","HLEVSRV0",39,0)
 ;
"RTN","HLEVSRV0",40,0)
MRUN(WHEN) ; Run M code's INIT...
"RTN","HLEVSRV0",41,0)
 ; XTMP -- req
"RTN","HLEVSRV0",42,0)
 N ZZADD,ZZCALL,ZZMCODE,ZZMLNO,ZZMTAG,ZZNEXT,ZZNO,ZZREC
"RTN","HLEVSRV0",43,0)
 ;
"RTN","HLEVSRV0",44,0)
 ; Get starting M code...
"RTN","HLEVSRV0",45,0)
 QUIT:$G(^XTMP(XTMP,"M",WHEN,"INIT",1))']""  ;->
"RTN","HLEVSRV0",46,0)
 ;
"RTN","HLEVSRV0",47,0)
 ; Values set up as a service for the developer sending in M code...
"RTN","HLEVSRV0",48,0)
 ;
"RTN","HLEVSRV0",49,0)
 ; NEXT LINE - Executable code to execute next line in "subroutine"...
"RTN","HLEVSRV0",50,0)
 S ZZNEXT="S ZZMLNO=ZZMLNO+1,ZZMCODE=$G(^XTMP(XTMP,""M"",WHEN,ZZMTAG,ZZMLNO)) QUIT:ZZMCODE']""""  X ZZMCODE,ZZREC"
"RTN","HLEVSRV0",51,0)
 S ZZREC="S ZZCALL=$G(ZZCALL)+1,^XTMP(XTMP,""M"",""REC"",WHEN,ZZCALL)=ZZMLNO_U_ZZMTAG"
"RTN","HLEVSRV0",52,0)
 S ZZADD="D ADDMTXT^HLEVSRV0($G(ZZTXT))"
"RTN","HLEVSRV0",53,0)
 ;
"RTN","HLEVSRV0",54,0)
 ; Set up every "subroutine" in an executable call "tag"
"RTN","HLEVSRV0",55,0)
 S ZZMCODE=""
"RTN","HLEVSRV0",56,0)
 F  S ZZMCODE=$O(^XTMP(XTMP,"M",WHEN,ZZMCODE)) Q:ZZMCODE']""  D
"RTN","HLEVSRV0",57,0)
 .  S @ZZMCODE="S ZZMTAG="""_ZZMCODE_""",ZZMLNO=0 X ZZNEXT"
"RTN","HLEVSRV0",58,0)
 ;
"RTN","HLEVSRV0",59,0)
 S ZZCALL=0
"RTN","HLEVSRV0",60,0)
 ;
"RTN","HLEVSRV0",61,0)
 ; Start...
"RTN","HLEVSRV0",62,0)
 X INIT
"RTN","HLEVSRV0",63,0)
 ;
"RTN","HLEVSRV0",64,0)
 Q
"RTN","HLEVSRV0",65,0)
 ;
"RTN","HLEVSRV0",66,0)
MCOND ; Condense M call data...
"RTN","HLEVSRV0",67,0)
 N DATA,TAG,TAGL,TAGN,TXT,WHEN,ZZCALL
"RTN","HLEVSRV0",68,0)
 ;
"RTN","HLEVSRV0",69,0)
 QUIT:'$D(^XTMP(XTMP,"M","REC"))  ;->
"RTN","HLEVSRV0",70,0)
 ;
"RTN","HLEVSRV0",71,0)
 KILL ^TMP($J,"HLMCOND")
"RTN","HLEVSRV0",72,0)
 ;
"RTN","HLEVSRV0",73,0)
 F WHEN="BEFORE","AFTER" D
"RTN","HLEVSRV0",74,0)
 .  S ZZCALL=0,TXT=WHEN_": ",POSX=$L(TXT),TAGL="",TAGN=0
"RTN","HLEVSRV0",75,0)
 .  F  S ZZCALL=$O(^XTMP(XTMP,"M","REC",WHEN,ZZCALL)) Q:ZZCALL'>0  D
"RTN","HLEVSRV0",76,0)
 .  .  S DATA=^XTMP(XTMP,"M","REC",WHEN,ZZCALL),TAG=$P(DATA,U,2) QUIT:TAG']""  ;->
"RTN","HLEVSRV0",77,0)
 .  .  I $L(TXT)>55 D
"RTN","HLEVSRV0",78,0)
 .  .  .  D ADD(TXT)
"RTN","HLEVSRV0",79,0)
 .  .  .  S TXT=$$REPEAT^XLFSTR(" ",POSX)
"RTN","HLEVSRV0",80,0)
 .  .  I TAGL'=TAG D
"RTN","HLEVSRV0",81,0)
 .  .  .  I TAGL]"",TAGN>0 S TXT=TXT_"(#"_TAGN_")",TAGN=0
"RTN","HLEVSRV0",82,0)
 .  .  .  S TXT=TXT_$S($L(TXT)>POSX:"-",1:"")_TAG,TAGN=1
"RTN","HLEVSRV0",83,0)
 .  .  I TAGL=TAG S TAGN=TAGN+1
"RTN","HLEVSRV0",84,0)
 .  .  S TAGL=TAG
"RTN","HLEVSRV0",85,0)
 .  I TAGN>0,$L(TXT)>POSX S TXT=TXT_"(#"_TAGN_")",TAGN=0
"RTN","HLEVSRV0",86,0)
 .  I $L(TXT)>POSX D ADD(TXT)
"RTN","HLEVSRV0",87,0)
 ;
"RTN","HLEVSRV0",88,0)
 QUIT:'$D(^TMP($J,"HLMCOND"))  ;->
"RTN","HLEVSRV0",89,0)
 ;
"RTN","HLEVSRV0",90,0)
 KILL ^XTMP(XTMP,"M","REC")
"RTN","HLEVSRV0",91,0)
 MERGE ^XTMP(XTMP,"M","REC")=^TMP($J,"HLMCOND")
"RTN","HLEVSRV0",92,0)
 ;
"RTN","HLEVSRV0",93,0)
 Q
"RTN","HLEVSRV0",94,0)
 ;
"RTN","HLEVSRV0",95,0)
MCALLREC ; Store MCOND data in mail message..
"RTN","HLEVSRV0",96,0)
 N NO
"RTN","HLEVSRV0",97,0)
 ;
"RTN","HLEVSRV0",98,0)
 QUIT:'$D(^XTMP(XTMP,"M","REC"))  ;->
"RTN","HLEVSRV0",99,0)
 ;
"RTN","HLEVSRV0",100,0)
 D ADDMAIL^HLEVSRV(""),ADDMAIL^HLEVSRV("M Call Record")
"RTN","HLEVSRV0",101,0)
 D ADDMAIL^HLEVSRV($$REPEAT^XLFSTR("-",74))
"RTN","HLEVSRV0",102,0)
 ;
"RTN","HLEVSRV0",103,0)
 S NO=0
"RTN","HLEVSRV0",104,0)
 F  S NO=$O(^XTMP(XTMP,"M","REC",NO)) Q:NO'>0  D
"RTN","HLEVSRV0",105,0)
 .  D ADDMAIL^HLEVSRV(^XTMP(XTMP,"M","REC",NO))
"RTN","HLEVSRV0",106,0)
 ;
"RTN","HLEVSRV0",107,0)
 Q
"RTN","HLEVSRV0",108,0)
 ;
"RTN","HLEVSRV0",109,0)
ADDMTXT(TXT) ;
"RTN","HLEVSRV0",110,0)
 N NO
"RTN","HLEVSRV0",111,0)
 S NO=$O(^XTMP(XTMP,"MTEXT",":"),-1)+1
"RTN","HLEVSRV0",112,0)
 S ^XTMP(XTMP,"MTEXT",+NO)=TXT
"RTN","HLEVSRV0",113,0)
 Q
"RTN","HLEVSRV0",114,0)
 ;
"RTN","HLEVSRV0",115,0)
MTEXT ; Add text to Mailman message created by M code...
"RTN","HLEVSRV0",116,0)
 N NO
"RTN","HLEVSRV0",117,0)
 ;
"RTN","HLEVSRV0",118,0)
 I $G(^XTMP(XTMP,"MTEXT")) D
"RTN","HLEVSRV0",119,0)
 .  D ADDMAIL("")
"RTN","HLEVSRV0",120,0)
 .  D ADDMAIL($$CJ^XLFSTR(" M-Created Text ",74,"-"))
"RTN","HLEVSRV0",121,0)
 ;
"RTN","HLEVSRV0",122,0)
 S NO=0
"RTN","HLEVSRV0",123,0)
 F  S NO=$O(^XTMP(XTMP,"MTEXT",NO)) Q:NO'>0  D
"RTN","HLEVSRV0",124,0)
 .  D ADDMAIL(^XTMP(XTMP,"MTEXT",NO))
"RTN","HLEVSRV0",125,0)
 ;
"RTN","HLEVSRV0",126,0)
 Q
"RTN","HLEVSRV0",127,0)
 ;
"RTN","HLEVSRV0",128,0)
ADD(TXT) ;
"RTN","HLEVSRV0",129,0)
 N NO
"RTN","HLEVSRV0",130,0)
 S NO=$O(^TMP($J,"HLMCOND",":"),-1)+1
"RTN","HLEVSRV0",131,0)
 S ^TMP($J,"HLMCOND",+NO)=TXT
"RTN","HLEVSRV0",132,0)
 Q
"RTN","HLEVSRV0",133,0)
 ;
"RTN","HLEVSRV0",134,0)
MTEST ; Test M code embedded in a Mailman message...
"RTN","HLEVSRV0",135,0)
 N IOINHI,IOINORM,MIEN,X,XTMP
"RTN","HLEVSRV0",136,0)
 ;
"RTN","HLEVSRV0",137,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLEVSRV0",138,0)
 ;
"RTN","HLEVSRV0",139,0)
 W @IOF,$$CJ^XLFSTR("M Code Test",IOM)
"RTN","HLEVSRV0",140,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVSRV0",141,0)
 W !!,"This utility will execute the code in the BEFORE and AFTER sections of the"
"RTN","HLEVSRV0",142,0)
 W !,"M code embedded in a Mailman message.  The message must be in the format"
"RTN","HLEVSRV0",143,0)
 W !,"used by the [HLEV-INFORMATION-SERVER] menu option."
"RTN","HLEVSRV0",144,0)
 ;
"RTN","HLEVSRV0",145,0)
MT1 W !
"RTN","HLEVSRV0",146,0)
 F  R !,"Message IEN: ",MIEN:60 Q:MIEN'>0  D  QUIT:$G(^XMB(3.9,+MIEN,0))]""
"RTN","HLEVSRV0",147,0)
 .  I $G(^XMB(3.9,+MIEN,0))']"" D  QUIT  ;->
"RTN","HLEVSRV0",148,0)
 .  .  W "   no message found..."
"RTN","HLEVSRV0",149,0)
 .  W "   ",$P(^XMB(3.9,+MIEN,0),U),"..."
"RTN","HLEVSRV0",150,0)
 ;
"RTN","HLEVSRV0",151,0)
 QUIT:$G(^XMB(3.9,+MIEN,0))']""  ;->
"RTN","HLEVSRV0",152,0)
 ;
"RTN","HLEVSRV0",153,0)
 S XTMP="HLEV SERVER 9999999",NOW=$$NOW^XLFDT
"RTN","HLEVSRV0",154,0)
 KILL ^XTMP(XTMP)
"RTN","HLEVSRV0",155,0)
 S ^XTMP(XTMP,0)=$$FMADD^XLFDT(NOW,0,1)_U_NOW_U_"TEST"
"RTN","HLEVSRV0",156,0)
 ;
"RTN","HLEVSRV0",157,0)
 W !!,"Loading M code..."
"RTN","HLEVSRV0",158,0)
 S LNO=0
"RTN","HLEVSRV0",159,0)
 F  S LNO=$O(^XMB(3.9,+MIEN,2,LNO)) Q:LNO'>0  D
"RTN","HLEVSRV0",160,0)
 .  S TXT=$G(^XMB(3.9,+MIEN,2,+LNO,0)) QUIT:$E(TXT,1,2)'="M^"  ;->
"RTN","HLEVSRV0",161,0)
 .  S TXT=$P(TXT,U,2,999) QUIT:TXT']""  ;->
"RTN","HLEVSRV0",162,0)
 .  W "."
"RTN","HLEVSRV0",163,0)
 .  D M(TXT)
"RTN","HLEVSRV0",164,0)
 ;
"RTN","HLEVSRV0",165,0)
 I '$D(^XTMP(XTMP,"M")) D  G MT1 ;->
"RTN","HLEVSRV0",166,0)
 .  W !!,"No M code embedded in this Mailman message..."
"RTN","HLEVSRV0",167,0)
 ;
"RTN","HLEVSRV0",168,0)
 W !
"RTN","HLEVSRV0",169,0)
 S LP=$NA(^XTMP(XTMP,"M")),ST="^XTMP("""_XTMP_""",""M"","
"RTN","HLEVSRV0",170,0)
 F  S LP=$Q(@LP) Q:LP'[ST  D
"RTN","HLEVSRV0",171,0)
 .  W !,IOINHI,"...",$P(LP,",""M"",",2,99),IOINORM," = "
"RTN","HLEVSRV0",172,0)
 .  S POSX=$X,DATA=@LP
"RTN","HLEVSRV0",173,0)
 .  F  QUIT:DATA']""  D
"RTN","HLEVSRV0",174,0)
 .  .  W $E(DATA,1,IOM-POSX)
"RTN","HLEVSRV0",175,0)
 .  .  S DATA=$E(DATA,IOM-POSX+1,999)
"RTN","HLEVSRV0",176,0)
 ;
"RTN","HLEVSRV0",177,0)
 W !!,"You can execute the BEFORE load M code, or the AFTER load M code.  The BEFORE"
"RTN","HLEVSRV0",178,0)
 W !,"load M code requires a BEFORE^INIT... node(s).  The AFTER load M code"
"RTN","HLEVSRV0",179,0)
 W !,"requires an AFTER^INIT... node(s)."
"RTN","HLEVSRV0",180,0)
 ;
"RTN","HLEVSRV0",181,0)
 I '$D(^XTMP(XTMP,"M","BEFORE"))&('$D(^XTMP(XTMP,"M","AFTER"))) D  G MT1 ;->
"RTN","HLEVSRV0",182,0)
 .  W !!,"You must add a BEFORE and/or AFTER section to the M code embedded in the"
"RTN","HLEVSRV0",183,0)
 .  W !,"Mailman message before you can use this utility to test."
"RTN","HLEVSRV0",184,0)
 ;
"RTN","HLEVSRV0",185,0)
 D MEX("BEFORE")
"RTN","HLEVSRV0",186,0)
 D MEX("AFTER")
"RTN","HLEVSRV0",187,0)
 ;
"RTN","HLEVSRV0",188,0)
 KILL ^XTMP(XTMP)
"RTN","HLEVSRV0",189,0)
 ;
"RTN","HLEVSRV0",190,0)
 W !!,"Done..."
"RTN","HLEVSRV0",191,0)
 ;
"RTN","HLEVSRV0",192,0)
 Q
"RTN","HLEVSRV0",193,0)
 ;
"RTN","HLEVSRV0",194,0)
MEX(WHEN) ; Called by MTEST to execute ^XTMP(XTMP,"M") code...
"RTN","HLEVSRV0",195,0)
 N X
"RTN","HLEVSRV0",196,0)
 QUIT:'$D(^XTMP(XTMP,"M",WHEN))  ;->
"RTN","HLEVSRV0",197,0)
 W !!,"Press RETURN to execute the ",IOINHI,WHEN,IOINORM
"RTN","HLEVSRV0",198,0)
 W " code, or '^' to skip... "
"RTN","HLEVSRV0",199,0)
 R X:60 I '$T!(X[U) W "  no action taken..." QUIT  ;->
"RTN","HLEVSRV0",200,0)
 W !,"Executing the ",WHEN," code..."
"RTN","HLEVSRV0",201,0)
 I WHEN="BEFORE" D MPRE
"RTN","HLEVSRV0",202,0)
 I WHEN="AFTER" D MPST
"RTN","HLEVSRV0",203,0)
 W "  M code finished..."
"RTN","HLEVSRV0",204,0)
 Q
"RTN","HLEVSRV0",205,0)
 ;
"RTN","HLEVSRV0",206,0)
UNIT(TXT) ; Load IEN list found by MSG ID... (TXT=MsgID)
"RTN","HLEVSRV0",207,0)
 ; XTMP -- req
"RTN","HLEVSRV0",208,0)
 ;
"RTN","HLEVSRV0",209,0)
 ; Data request line must equal UNIT^#^TYPE  (#^TYPE passed in here)
"RTN","HLEVSRV0",210,0)
 ;
"RTN","HLEVSRV0",211,0)
 ; TYPE = "IEN772", "IEN773", or "MSGID"
"RTN","HLEVSRV0",212,0)
 ;    # = IEN772, IEN773 or MSGID
"RTN","HLEVSRV0",213,0)
 ;
"RTN","HLEVSRV0",214,0)
 ; The # used to find any IEN772 in the unit.
"RTN","HLEVSRV0",215,0)
 ; All messages in unit found using $$LOAD772S^HLUCM009, and
"RTN","HLEVSRV0",216,0)
 ; formatted by LOADUNIT and returned in email to user.
"RTN","HLEVSRV0",217,0)
 ;
"RTN","HLEVSRV0",218,0)
 N CT,HL772,HLID,HLTYPE,IEN772,IEN773,IEN773,NO772S
"RTN","HLEVSRV0",219,0)
 ;
"RTN","HLEVSRV0",220,0)
 ; Initial sets...
"RTN","HLEVSRV0",221,0)
 S HLID=$P($G(TXT),U) QUIT:HLID']""  ;->
"RTN","HLEVSRV0",222,0)
 S HLTYPE=$P(TXT,U,2) ; IEN772, IEN773, or MSGID
"RTN","HLEVSRV0",223,0)
 S IEN772=""
"RTN","HLEVSRV0",224,0)
 ;
"RTN","HLEVSRV0",225,0)
 ; Try to get IEN772 from MSGID...
"RTN","HLEVSRV0",226,0)
 I HLTYPE="MSGID" D  QUIT:'IEN772  ;->
"RTN","HLEVSRV0",227,0)
 .  S IEN772=$O(^HL(772,"C",HLID,":"),-1)
"RTN","HLEVSRV0",228,0)
 .  I IEN772 D  QUIT:IEN772'>0  ;->
"RTN","HLEVSRV0",229,0)
 .  .  S IEN773=$O(^HLMA("C",HLID,0)) QUIT:IEN773'>0  ;->
"RTN","HLEVSRV0",230,0)
 .  .  S IEN772=+$G(^HLMA(+IEN773,0))
"RTN","HLEVSRV0",231,0)
 .  S IEN773=$O(^HLMA("C",HLID,":"),-1) QUIT:'IEN773  ;->
"RTN","HLEVSRV0",232,0)
 .  S IEN772=+$G(^HLMA(+IEN773,0))
"RTN","HLEVSRV0",233,0)
 ;
"RTN","HLEVSRV0",234,0)
 ; If passed IEN772...
"RTN","HLEVSRV0",235,0)
 I HLTYPE="IEN772" D  QUIT:IEN772'>0  ;->
"RTN","HLEVSRV0",236,0)
 .  QUIT:$G(^HL(772,+HLID,0))']""  ;->
"RTN","HLEVSRV0",237,0)
 .  S IEN772=+HLID
"RTN","HLEVSRV0",238,0)
 ;
"RTN","HLEVSRV0",239,0)
 ; If passed IEN773...
"RTN","HLEVSRV0",240,0)
 I HLTYPE="IEN773" D  QUIT:IEN772'>0  ;->
"RTN","HLEVSRV0",241,0)
 .  S IEN772=+$G(^HLMA(+HLID,0))
"RTN","HLEVSRV0",242,0)
 .  QUIT:$G(^HL(772,+IEN772,0))]""  ;-> It's OK
"RTN","HLEVSRV0",243,0)
 .  S IEN772=""
"RTN","HLEVSRV0",244,0)
 ;
"RTN","HLEVSRV0",245,0)
 QUIT:$G(^HL(772,+$G(IEN772),0))']""  ;->
"RTN","HLEVSRV0",246,0)
 ;
"RTN","HLEVSRV0",247,0)
 ; Load associated entries...
"RTN","HLEVSRV0",248,0)
 S NO772S=$$LOAD772S^HLUCM009(+IEN772,.HL772) QUIT:NO772S'>0  ;->
"RTN","HLEVSRV0",249,0)
 ;
"RTN","HLEVSRV0",250,0)
 ; Load data...
"RTN","HLEVSRV0",251,0)
 S IEN772=0
"RTN","HLEVSRV0",252,0)
 F  S IEN772=$O(HL772("HLPARENT",IEN772)) Q:IEN772'>0  D
"RTN","HLEVSRV0",253,0)
 .  S IEN772C=0
"RTN","HLEVSRV0",254,0)
 .  F  S IEN772C=$O(HL772("HLPARENT",IEN772,IEN772C)) Q:IEN772C'>0  D
"RTN","HLEVSRV0",255,0)
 .  .  S ^XTMP(XTMP,"HLUNIT",IEN772,IEN772C)=""
"RTN","HLEVSRV0",256,0)
 ;
"RTN","HLEVSRV0",257,0)
 Q
"RTN","HLEVSRV0",258,0)
 ;
"RTN","HLEVSRV0",259,0)
LOADUNIT ; Load data found by UNIT above...
"RTN","HLEVSRV0",260,0)
 N IEN772C,IEN772P,POSX,TXT
"RTN","HLEVSRV0",261,0)
 ;
"RTN","HLEVSRV0",262,0)
 QUIT:'$D(^XTMP(XTMP,"HLUNIT"))  ;->
"RTN","HLEVSRV0",263,0)
 ;
"RTN","HLEVSRV0",264,0)
 D ADDMAIL(""),ADDMAIL($$CJ^XLFSTR(" Msg ID-requested Message Units ",74,"-"))
"RTN","HLEVSRV0",265,0)
 ;
"RTN","HLEVSRV0",266,0)
 S IEN772P=0
"RTN","HLEVSRV0",267,0)
 F  S IEN772P=$O(^XTMP(XTMP,"HLUNIT",IEN772P)) Q:IEN772P'>0  D
"RTN","HLEVSRV0",268,0)
 .  S TXT=IEN772P_": ",POSX=$L(TXT)
"RTN","HLEVSRV0",269,0)
 .  S IEN772C=0
"RTN","HLEVSRV0",270,0)
 .  F  S IEN772C=$O(^XTMP(XTMP,"HLUNIT",IEN772P,IEN772C)) Q:IEN772C'>0  D
"RTN","HLEVSRV0",271,0)
 .  .  I ($L(TXT)+$L(IEN772C)+2)>74 D
"RTN","HLEVSRV0",272,0)
 .  .  .  D ADDMAIL(TXT)
"RTN","HLEVSRV0",273,0)
 .  .  .  S TXT=$$REPEAT^XLFSTR(" ",POSX)
"RTN","HLEVSRV0",274,0)
 .  .  S TXT=TXT_$S($L(TXT)>POSX:",",1:"")_IEN772C
"RTN","HLEVSRV0",275,0)
 .  I TXT]"" D ADDMAIL(TXT) S TXT=""
"RTN","HLEVSRV0",276,0)
 ;
"RTN","HLEVSRV0",277,0)
 Q
"RTN","HLEVSRV0",278,0)
 ;
"RTN","HLEVSRV0",279,0)
ADDMAIL(TXT) D ADDMAIL^HLEVSRV(TXT)
"RTN","HLEVSRV0",280,0)
 Q
"RTN","HLEVSRV0",281,0)
 ;
"RTN","HLEVSRV0",282,0)
QUITQ(LPVAL,STOP,NOLINE,CT) ; Should looping stop?
"RTN","HLEVSRV0",283,0)
 QUIT:LPVAL']"" 1 ;->
"RTN","HLEVSRV0",284,0)
 QUIT:LPVAL'[STOP 1 ;->
"RTN","HLEVSRV0",285,0)
 QUIT:(CT+1)>NOLINE 1 ;->
"RTN","HLEVSRV0",286,0)
 Q ""
"RTN","HLEVSRV0",287,0)
 ;
"RTN","HLEVSRV0",288,0)
QUITS(LPVAL,SCREEN) ; Should this be included?
"RTN","HLEVSRV0",289,0)
 N DATA,DIV,MAXNO,OK,PCE,VAL,X
"RTN","HLEVSRV0",290,0)
 S DIV=""
"RTN","HLEVSRV0",291,0)
 S MAXNO=$L(LPVAL,",") I $L(SCREEN,",")'=MAXNO QUIT 1 ;->
"RTN","HLEVSRV0",292,0)
 F PCE=1:1:MAXNO D  QUIT:'OK
"RTN","HLEVSRV0",293,0)
 .  S OK=0
"RTN","HLEVSRV0",294,0)
 .  S X=$P(SCREEN,"#",PCE),DIV=$S(DIV]"":",",1:$E(X,$L(X)))
"RTN","HLEVSRV0",295,0)
 .  S DATA(1)=$P(LPVAL,DIV,+PCE) QUIT:DATA(1)']""  ;->
"RTN","HLEVSRV0",296,0)
 .  S DATA(2)=$P(SCREEN,DIV,+PCE) QUIT:DATA(2)']""  ;->
"RTN","HLEVSRV0",297,0)
 .  I DATA(2)="#" QUIT:DATA(1)'?1.N  ;->
"RTN","HLEVSRV0",298,0)
 .  I DATA(2)'="#" QUIT:DATA(1)'=DATA(2)  ;->
"RTN","HLEVSRV0",299,0)
 .  S OK=1
"RTN","HLEVSRV0",300,0)
 S OK='OK ; Because this is a QUIT IF extrinsic function
"RTN","HLEVSRV0",301,0)
 Q OK
"RTN","HLEVSRV0",302,0)
 ;
"RTN","HLEVSRV0",303,0)
ADDLINE(TXT) D ADDLINE^HLEVSRV(TXT)
"RTN","HLEVSRV0",304,0)
 Q
"RTN","HLEVSRV0",305,0)
 ;
"RTN","HLEVSRV0",306,0)
EOR ;HLEVSRV0 - Event Monitor SERVER ;5/16/03 14:42
"RTN","HLEVSRV1")
0^27^B90257561
"RTN","HLEVSRV1",1,0)
HLEVSRV1 ;O-OIFO/LJA - Event Monitor SERVER ;02/04/2004 14:42
"RTN","HLEVSRV1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVSRV1",3,0)
 ;
"RTN","HLEVSRV1",4,0)
OPENM ; Open/close access to M code...
"RTN","HLEVSRV1",5,0)
 D OFFBEF
"RTN","HLEVSRV1",6,0)
 D HDM,EXM,STM,SWM
"RTN","HLEVSRV1",7,0)
 Q
"RTN","HLEVSRV1",8,0)
 ;
"RTN","HLEVSRV1",9,0)
OKCODE(CODE) ; Check if license available and if so, mark used...
"RTN","HLEVSRV1",10,0)
 N XTMP
"RTN","HLEVSRV1",11,0)
 D OFFBEF
"RTN","HLEVSRV1",12,0)
 S XTMP=$O(^XTMP("HLEV SERVER M 9999999"),-1) QUIT:XTMP']"" "" ;->
"RTN","HLEVSRV1",13,0)
 QUIT:'$D(^XTMP(XTMP,"LIC",CODE)) "" ;->
"RTN","HLEVSRV1",14,0)
 QUIT:$G(^XTMP(XTMP,"LIC",CODE))]"" "" ;->
"RTN","HLEVSRV1",15,0)
 S ^XTMP(XTMP,"LIC",CODE)=$$NOW^XLFDT_U_.5_U_$G(XMZ)_U_$G(ZTSK)
"RTN","HLEVSRV1",16,0)
 Q 1
"RTN","HLEVSRV1",17,0)
 ;
"RTN","HLEVSRV1",18,0)
OFFBEF ; Turn off all but last M code entry...
"RTN","HLEVSRV1",19,0)
 N XTMP
"RTN","HLEVSRV1",20,0)
 S XTMP=$O(^XTMP("HLEV SERVER M 9999999"),-1) QUIT:XTMP']""  ;->
"RTN","HLEVSRV1",21,0)
 F  S XTMP=$O(^XTMP(XTMP),-1) Q:XTMP']""  D
"RTN","HLEVSRV1",22,0)
 .  D SETOFF(XTMP)
"RTN","HLEVSRV1",23,0)
 Q
"RTN","HLEVSRV1",24,0)
 ;
"RTN","HLEVSRV1",25,0)
SWM ; Switch state...
"RTN","HLEVSRV1",26,0)
 N STAT
"RTN","HLEVSRV1",27,0)
 S STAT=$$MST
"RTN","HLEVSRV1",28,0)
 I +STAT=0 D UPM
"RTN","HLEVSRV1",29,0)
 I +STAT=1 D DOWNM
"RTN","HLEVSRV1",30,0)
 W !
"RTN","HLEVSRV1",31,0)
 S X=$$BTE^HLCSMON("Press RETURN to exit... ")
"RTN","HLEVSRV1",32,0)
 Q
"RTN","HLEVSRV1",33,0)
 ;
"RTN","HLEVSRV1",34,0)
DOWNM ; Turn off M code execution...
"RTN","HLEVSRV1",35,0)
 ; STAT -- req
"RTN","HLEVSRV1",36,0)
 N END,START,XTMP
"RTN","HLEVSRV1",37,0)
 S XTMP=$O(^XTMP("HLEV SERVER M 9999999"),-1)
"RTN","HLEVSRV1",38,0)
 I XTMP']"" D  QUIT  ;->
"RTN","HLEVSRV1",39,0)
 .  W !!,"M code execution is OFF already..."
"RTN","HLEVSRV1",40,0)
 W !
"RTN","HLEVSRV1",41,0)
 I '$$YN^HLCSRPT4("Turn off M code execution") D  QUIT  ;->
"RTN","HLEVSRV1",42,0)
 .  W "  nothing changed..."
"RTN","HLEVSRV1",43,0)
 D SETOFF(XTMP)
"RTN","HLEVSRV1",44,0)
 W "   M code execution disallowed..."
"RTN","HLEVSRV1",45,0)
 Q
"RTN","HLEVSRV1",46,0)
 ;
"RTN","HLEVSRV1",47,0)
UPM ; Turn on M code execution...
"RTN","HLEVSRV1",48,0)
 ; STAT -- req
"RTN","HLEVSRV1",49,0)
 N CODES,END,IOBOFF,IOBON,NOC,START,X,XTMP
"RTN","HLEVSRV1",50,0)
 ;
"RTN","HLEVSRV1",51,0)
 S X="IOBOFF;IOBON" D ENDR^%ZISS
"RTN","HLEVSRV1",52,0)
 S XTMP="HLEV SERVER M "_$$NOW^XLFDT
"RTN","HLEVSRV1",53,0)
 ;
"RTN","HLEVSRV1",54,0)
 W !
"RTN","HLEVSRV1",55,0)
 I '$$YN^HLCSRPT4("Turn on M code execution","No") D  QUIT  ;->
"RTN","HLEVSRV1",56,0)
 .  W "  nothing changed..."
"RTN","HLEVSRV1",57,0)
 ;
"RTN","HLEVSRV1",58,0)
 W !!,"Before M code execution can be turned on, you must answer a few questions..."
"RTN","HLEVSRV1",59,0)
 W !!,"Please include ",IOBON,"time",IOBOFF
"RTN","HLEVSRV1",60,0)
 W " when entering the start and end date/times..."
"RTN","HLEVSRV1",61,0)
 ;
"RTN","HLEVSRV1",62,0)
 W !
"RTN","HLEVSRV1",63,0)
 S START=$$ASKDATE^HLEVAPI2("Enter START TIME","","NOW")
"RTN","HLEVSRV1",64,0)
 I START'?7N1"."1.N D  QUIT  ;->
"RTN","HLEVSRV1",65,0)
 .  W "  exiting..."
"RTN","HLEVSRV1",66,0)
 ;
"RTN","HLEVSRV1",67,0)
 W !!,"Prompting START+24 hours..."
"RTN","HLEVSRV1",68,0)
 W !
"RTN","HLEVSRV1",69,0)
 S END=$$ASKDATE^HLEVAPI2("Enter END TIME","",$$FMTE^XLFDT($$FMADD^XLFDT(START,1)))
"RTN","HLEVSRV1",70,0)
 I END'?7N1"."1.N D  QUIT  ;->
"RTN","HLEVSRV1",71,0)
 .  W "  exiting..."
"RTN","HLEVSRV1",72,0)
 ;
"RTN","HLEVSRV1",73,0)
 W !
"RTN","HLEVSRV1",74,0)
 S NOC=$$ASKCODES(.CODES) I 'NOC D  QUIT  ;->
"RTN","HLEVSRV1",75,0)
 .  W "   exiting..."
"RTN","HLEVSRV1",76,0)
 W !!,$S(NOC=1:"The '"_$O(CODES(""))_"' license",1:"These licenses")
"RTN","HLEVSRV1",77,0)
 W " will be installed if you turn on M code execution now:"
"RTN","HLEVSRV1",78,0)
 ;
"RTN","HLEVSRV1",79,0)
 I NOC>1 D
"RTN","HLEVSRV1",80,0)
 .  W !!,?5
"RTN","HLEVSRV1",81,0)
 .  S CODES=""
"RTN","HLEVSRV1",82,0)
 .  F  S CODES=$O(CODES(CODES)) Q:CODES']""  D
"RTN","HLEVSRV1",83,0)
 .  .  W:($X+$L(CODES))>IOM !,?5
"RTN","HLEVSRV1",84,0)
 .  .  W $E(CODES_"          ",1,10)
"RTN","HLEVSRV1",85,0)
 ;
"RTN","HLEVSRV1",86,0)
 W !
"RTN","HLEVSRV1",87,0)
 I '$$YN^HLCSRPT4("OK to turn on M code execution") D  QUIT  ;->
"RTN","HLEVSRV1",88,0)
 .  W "  nothing changed..."
"RTN","HLEVSRV1",89,0)
 ;
"RTN","HLEVSRV1",90,0)
 D SETON(XTMP,START,END)
"RTN","HLEVSRV1",91,0)
 W "   M code execution allowed..."
"RTN","HLEVSRV1",92,0)
 ;
"RTN","HLEVSRV1",93,0)
 W !!,"Be sure to pass on ",$S(NOC>1:"these licenses",1:"the license")
"RTN","HLEVSRV1",94,0)
 W " to the VistA HL7 team..."
"RTN","HLEVSRV1",95,0)
 D LICENSE(XTMP,.CODES)
"RTN","HLEVSRV1",96,0)
 ;
"RTN","HLEVSRV1",97,0)
 W !
"RTN","HLEVSRV1",98,0)
 S X=$$BTE^HLCSMON("Press RETURN to exit...")
"RTN","HLEVSRV1",99,0)
 ;
"RTN","HLEVSRV1",100,0)
 Q
"RTN","HLEVSRV1",101,0)
 ;
"RTN","HLEVSRV1",102,0)
LICENSE(XTMP,CODES) ; Install licenses
"RTN","HLEVSRV1",103,0)
 N CODE
"RTN","HLEVSRV1",104,0)
 W !!,"Codes:    "
"RTN","HLEVSRV1",105,0)
 ;
"RTN","HLEVSRV1",106,0)
 S CODE=""
"RTN","HLEVSRV1",107,0)
 F  S CODE=$O(CODES(CODE)) Q:CODE']""  D
"RTN","HLEVSRV1",108,0)
 .  S ^XTMP(XTMP,"LIC",CODE)="" ; Mailman server uses stored on this node
"RTN","HLEVSRV1",109,0)
 .  S X=$E(CODE_"                   ",1,20) W:($X+$L(X))>IOM !,?10 W X
"RTN","HLEVSRV1",110,0)
 ;
"RTN","HLEVSRV1",111,0)
 Q
"RTN","HLEVSRV1",112,0)
 ;
"RTN","HLEVSRV1",113,0)
ASKCODES(CODES) ; Ask user for codes...
"RTN","HLEVSRV1",114,0)
 N CODE,NOC
"RTN","HLEVSRV1",115,0)
 ;
"RTN","HLEVSRV1",116,0)
 W !!,"You must now give the VistA HL7 team ""licences"" for M code execution.  One"
"RTN","HLEVSRV1",117,0)
 W !,"license is used for every Mailman server request containing executable M "
"RTN","HLEVSRV1",118,0)
 W !,"code."
"RTN","HLEVSRV1",119,0)
 W !
"RTN","HLEVSRV1",120,0)
 ;
"RTN","HLEVSRV1",121,0)
 S NOC=0
"RTN","HLEVSRV1",122,0)
 F  D  QUIT:CODE']""
"RTN","HLEVSRV1",123,0)
 .  S CODE=$$CODE QUIT:CODE']""  ;->
"RTN","HLEVSRV1",124,0)
 .  S ANS=$$YN^HLCSRPT4("Install the license# ["_CODE_"]","Yes")
"RTN","HLEVSRV1",125,0)
 .  I ANS'=1 S CODE="" W "   not intalled..." QUIT  ;->
"RTN","HLEVSRV1",126,0)
 .  S NOC=NOC+1,CODES(CODE)=""
"RTN","HLEVSRV1",127,0)
 ;
"RTN","HLEVSRV1",128,0)
 Q NOC
"RTN","HLEVSRV1",129,0)
 ;
"RTN","HLEVSRV1",130,0)
SETON(XTMP,START,END) ; Allow M code execution
"RTN","HLEVSRV1",131,0)
 S ^XTMP(XTMP,0)=$$FMADD^XLFDT($$NOW^XLFDT,7)_U_$$NOW^XLFDT_U_"VistA HL7 Mailman Server M Control"
"RTN","HLEVSRV1",132,0)
 S ^XTMP(XTMP,"STATUS")=START_U_END_U_$G(DUZ)
"RTN","HLEVSRV1",133,0)
 Q
"RTN","HLEVSRV1",134,0)
 ;
"RTN","HLEVSRV1",135,0)
SETOFF(XTMP) ; Disallow M code execution...
"RTN","HLEVSRV1",136,0)
 S $P(^XTMP(XTMP,"STATUS"),U,4,5)=$$NOW^XLFDT_U_$G(DUZ)
"RTN","HLEVSRV1",137,0)
 Q
"RTN","HLEVSRV1",138,0)
 ;
"RTN","HLEVSRV1",139,0)
STM ; What is the status of M code execution?
"RTN","HLEVSRV1",140,0)
 W !!,$$CJ^XLFSTR("------ M Code Execution Status: "_$P($$MST,U,3)_" ------",IOM)
"RTN","HLEVSRV1",141,0)
 Q
"RTN","HLEVSRV1",142,0)
 ;
"RTN","HLEVSRV1",143,0)
MST() ; Status?
"RTN","HLEVSRV1",144,0)
 ; Piece 1 = 0 -> DOWN                        UP OR DOWN
"RTN","HLEVSRV1",145,0)
 ;         = 1 -> UP
"RTN","HLEVSRV1",146,0)
 ; Piece 2 = 1 -> No XTMP data exists...      DOWN REASONS
"RTN","HLEVSRV1",147,0)
 ;         = 2 -> Invalid START/ENDs
"RTN","HLEVSRV1",148,0)
 ;         = 3 -> Before cutoff time
"RTN","HLEVSRV1",149,0)
 ;         = 4 -> After cutoff time
"RTN","HLEVSRV1",150,0)
 ;         = 5 -> Inactive date (p4) found
"RTN","HLEVSRV1",151,0)
 ;         = 0 -> Not DOWN!!!
"RTN","HLEVSRV1",152,0)
 ; Piece 3 = Status text information
"RTN","HLEVSRV1",153,0)
 ;
"RTN","HLEVSRV1",154,0)
 ; NOW -- req
"RTN","HLEVSRV1",155,0)
 N NOW,END,IDATE,START,STAT,XTMP
"RTN","HLEVSRV1",156,0)
 S NOW=$$NOW^XLFDT
"RTN","HLEVSRV1",157,0)
 S XTMP=$O(^XTMP("HLEV SERVER M 9999999"),-1) QUIT:XTMP']"" "0^1^DOWN" ;->
"RTN","HLEVSRV1",158,0)
 S STAT=$G(^XTMP(XTMP,"STATUS")),START=+STAT,END=$P(STAT,U,2),IDATE=$P(STAT,U,4)
"RTN","HLEVSRV1",159,0)
 I IDATE?7N1"."1.N QUIT "0^5^DOWN" ;->
"RTN","HLEVSRV1",160,0)
 I START'?7N1"."1.N!(END'?7N1"."1.N) QUIT "0^2^DOWN" ;->
"RTN","HLEVSRV1",161,0)
 I START>NOW QUIT "0^3^DOWN - (Too early ("_$$SDT^HLEVX001(+START)_")" ;->
"RTN","HLEVSRV1",162,0)
 I END<NOW QUIT "0^4^DOWN - (Too late ("_$$SDT^HLEVX001(+END)_")" ;->
"RTN","HLEVSRV1",163,0)
 ;
"RTN","HLEVSRV1",164,0)
 Q "1^0^UP"
"RTN","HLEVSRV1",165,0)
 ;
"RTN","HLEVSRV1",166,0)
HDM W @IOF,$$CJ^XLFSTR("Open Access to Mailman Server M Code",IOM)
"RTN","HLEVSRV1",167,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVSRV1",168,0)
 QUIT
"RTN","HLEVSRV1",169,0)
 ;
"RTN","HLEVSRV1",170,0)
EXM N I,T F I=1:1 S T=$T(EXM+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVSRV1",171,0)
 ;;Mailman server requests can be sent to your site requesting HL7 data be 
"RTN","HLEVSRV1",172,0)
 ;;returned to the VistA HL7 team.  (These requests are only sent to the VistA
"RTN","HLEVSRV1",173,0)
 ;;HL7 team, and under no circumstances are sent to any other mail groups or
"RTN","HLEVSRV1",174,0)
 ;;individuals.)  Under very rare circumstances, in order to debug problems on 
"RTN","HLEVSRV1",175,0)
 ;;your site, or to collect diagnostic information, it might be desired to run
"RTN","HLEVSRV1",176,0)
 ;;some M code embedded in the Mailman server requests.  
"RTN","HLEVSRV1",177,0)
 ;;
"RTN","HLEVSRV1",178,0)
 ;;In order to provide a high level of security, no M code will ever be run by
"RTN","HLEVSRV1",179,0)
 ;;the Mailman server option unless you explicity allow M code execution.  This
"RTN","HLEVSRV1",180,0)
 ;;option allows you to allow, or disallow, M code execution.
"RTN","HLEVSRV1",181,0)
 QUIT
"RTN","HLEVSRV1",182,0)
 ;
"RTN","HLEVSRV1",183,0)
CODE() ; Return license code...
"RTN","HLEVSRV1",184,0)
 N CODE,EX,NOP,TYPE
"RTN","HLEVSRV1",185,0)
 F EX=39,44,95,96 S EX(EX)=""
"RTN","HLEVSRV1",186,0)
 S CODE="",NOP=0
"RTN","HLEVSRV1",187,0)
 F EX=1:1:6 D
"RTN","HLEVSRV1",188,0)
 .  S TYPE=$P("A^P",U,$R(2)+1)
"RTN","HLEVSRV1",189,0)
 .  I EX=6,NOP=0 S TYPE="P" ; Must be at least one punctuation
"RTN","HLEVSRV1",190,0)
 .  I TYPE="P" S NOP=NOP+1
"RTN","HLEVSRV1",191,0)
 .  S:NOP>1 TYPE="A"
"RTN","HLEVSRV1",192,0)
 .  S CODE=CODE_$$RNO(TYPE)
"RTN","HLEVSRV1",193,0)
 .  I EX=3 S CODE=CODE_"-"
"RTN","HLEVSRV1",194,0)
 Q CODE
"RTN","HLEVSRV1",195,0)
 ;
"RTN","HLEVSRV1",196,0)
RNO(TYPE) ; Return random number between 33 and 122 (w/exceptions)
"RTN","HLEVSRV1",197,0)
 ; NOP -- req
"RTN","HLEVSRV1",198,0)
 N NO,OK
"RTN","HLEVSRV1",199,0)
 F  S NO=$R(89)+33 D  Q:OK
"RTN","HLEVSRV1",200,0)
 .  S OK=0
"RTN","HLEVSRV1",201,0)
 .  I $D(EX(NO)) QUIT  ;-> Is it in exclusion list?
"RTN","HLEVSRV1",202,0)
 .  I TYPE="A" D  QUIT  ;-> Is it an alpha character
"RTN","HLEVSRV1",203,0)
 .  .  I $$ALPHA(NO) S OK=1
"RTN","HLEVSRV1",204,0)
 .  I '$$ALPHA(NO) S OK=1 ; Need punctuation...
"RTN","HLEVSRV1",205,0)
 Q $C(NO)
"RTN","HLEVSRV1",206,0)
 ;
"RTN","HLEVSRV1",207,0)
ALPHA(NO) ; Is it ALPHA character?
"RTN","HLEVSRV1",208,0)
 N X
"RTN","HLEVSRV1",209,0)
 S X=$A($$UP^XLFSTR($C(NO))) QUIT:X>64&(X<91) 1 ;->
"RTN","HLEVSRV1",210,0)
 Q ""
"RTN","HLEVSRV1",211,0)
 ;
"RTN","HLEVSRV1",212,0)
GBLTOXM ; Place global data in Mailman message global...
"RTN","HLEVSRV1",213,0)
 N DATA,FILE,GBL,IEN,LP,REF,ST,TXT
"RTN","HLEVSRV1",214,0)
 ;
"RTN","HLEVSRV1",215,0)
 ; Add data found...
"RTN","HLEVSRV1",216,0)
 S GBL=$NA(^XTMP(XTMP,"DATA"))
"RTN","HLEVSRV1",217,0)
 ;
"RTN","HLEVSRV1",218,0)
 S FILE=0
"RTN","HLEVSRV1",219,0)
 F  S FILE=$O(@GBL@(FILE)) Q:FILE'>0  D
"RTN","HLEVSRV1",220,0)
 .  D ADDMAIL^HLEVSRV("")
"RTN","HLEVSRV1",221,0)
 .  D ADDMAIL^HLEVSRV($$CJ^XLFSTR(" "_$P($G(^HLEV(+FILE,0)),U)_" [#"_FILE_"] ",74,"-"))
"RTN","HLEVSRV1",222,0)
 .  S IEN=0
"RTN","HLEVSRV1",223,0)
 .  F  S IEN=$O(@GBL@(FILE,IEN)) Q:IEN'>0  D
"RTN","HLEVSRV1",224,0)
 .  .  S TXT="#"_IEN
"RTN","HLEVSRV1",225,0)
 .  .  S LP="^XTMP("""_XTMP_""",""DATA"","_FILE_","_IEN,ST=LP_","
"RTN","HLEVSRV1",226,0)
 .  .  S LP=LP_")"
"RTN","HLEVSRV1",227,0)
 .  .  F  S LP=$Q(@LP) Q:LP'[ST  D
"RTN","HLEVSRV1",228,0)
 .  .  .  S REF="#"_IEN_","_$P(LP,ST,2)_"=",POSX=$L(REF)
"RTN","HLEVSRV1",229,0)
 .  .  .  S DATA=@LP
"RTN","HLEVSRV1",230,0)
 .  .  .  F  D  QUIT:$TR(REF," ","")']""&(DATA']"")  ;->
"RTN","HLEVSRV1",231,0)
 .  .  .  .  S TXT=REF_$E(DATA,1,74-$L(REF))
"RTN","HLEVSRV1",232,0)
 .  .  .  .  D ADDMAIL^HLEVSRV(TXT)
"RTN","HLEVSRV1",233,0)
 .  .  .  .  S DATA=$E(DATA,74-$L(REF)+1,999)
"RTN","HLEVSRV1",234,0)
 .  .  .  .  S REF=$$REPEAT^XLFSTR(" ",POSX)
"RTN","HLEVSRV1",235,0)
 ;
"RTN","HLEVSRV1",236,0)
 Q
"RTN","HLEVSRV1",237,0)
 ;
"RTN","HLEVSRV1",238,0)
TEST ; Test server...
"RTN","HLEVSRV1",239,0)
 N CT,HLEVQUIT,LASTXTMP,XTMP,XMREC,XMZ
"RTN","HLEVSRV1",240,0)
 ;
"RTN","HLEVSRV1",241,0)
 W !!,"The current time is ",$$NOW^XLFDT,"..."
"RTN","HLEVSRV1",242,0)
 ;
"RTN","HLEVSRV1",243,0)
 W !!,"Displaying all existing ^XTMP(""HLEV SERVER ..."") entries..."
"RTN","HLEVSRV1",244,0)
 ;
"RTN","HLEVSRV1",245,0)
 ; Find last 6 entries to show...
"RTN","HLEVSRV1",246,0)
 S XTMP="HLEV SERVER 9999999",CT=0
"RTN","HLEVSRV1",247,0)
 F  S XTMP=$O(^XTMP(XTMP),-1) Q:XTMP'?1"HLEV SERVER "7N1"."1.N!(CT>6)  D
"RTN","HLEVSRV1",248,0)
 .  S CT=CT+1
"RTN","HLEVSRV1",249,0)
 ;
"RTN","HLEVSRV1",250,0)
 S CT=0
"RTN","HLEVSRV1",251,0)
 S XTMP=$S(XTMP?1"HLEV SERVER "7N1"."1.N:XTMP,1:"HLEV SERVER 0000000")
"RTN","HLEVSRV1",252,0)
 F  S XTMP=$O(^XTMP(XTMP)) Q:XTMP'?1"HLEV SERVER "7N1"."1.N  D
"RTN","HLEVSRV1",253,0)
 .  W:'CT !!
"RTN","HLEVSRV1",254,0)
 .  W $E("^XTMP("""_XTMP_""""_$$REPEAT^XLFSTR(" ",40),1,40)
"RTN","HLEVSRV1",255,0)
 .  S CT=CT+1
"RTN","HLEVSRV1",256,0)
 ;
"RTN","HLEVSRV1",257,0)
 I 'CT W !!,"No XTMP server data exists..." QUIT  ;->
"RTN","HLEVSRV1",258,0)
 ;
"RTN","HLEVSRV1",259,0)
 S LASTXTMP=$O(^XTMP("HLEV SERVER 9999999"),-1)
"RTN","HLEVSRV1",260,0)
 D SHOWXTMP("Last XTMP entry",LASTXTMP)
"RTN","HLEVSRV1",261,0)
 ;
"RTN","HLEVSRV1",262,0)
T1 W !!,"Enter XTMP to rerun: ",LASTXTMP,"// "
"RTN","HLEVSRV1",263,0)
 R XTMP:999 QUIT:XTMP[U  ;->
"RTN","HLEVSRV1",264,0)
 S:XTMP']"" XTMP=LASTXTMP
"RTN","HLEVSRV1",265,0)
 I '$D(^XTMP(XTMP)) D  G T1 ;->
"RTN","HLEVSRV1",266,0)
 .  W "  entry not found..."
"RTN","HLEVSRV1",267,0)
 ;
"RTN","HLEVSRV1",268,0)
 S XMZ=$P($G(^XTMP(XTMP,"MAIL")),U)
"RTN","HLEVSRV1",269,0)
 I $G(^XMB(3.9,+XMZ,0))']"" D  QUIT  ;->
"RTN","HLEVSRV1",270,0)
 .  W !!,"There is no Mailman message recorded..."
"RTN","HLEVSRV1",271,0)
 ;
"RTN","HLEVSRV1",272,0)
 S XMREC="D REC^XMS3"
"RTN","HLEVSRV1",273,0)
 ;
"RTN","HLEVSRV1",274,0)
 W !!,"Calling SERVER^HLEVSRV with XTMP=",XTMP,"..."
"RTN","HLEVSRV1",275,0)
 ;
"RTN","HLEVSRV1",276,0)
 D SERVER^HLEVSRV
"RTN","HLEVSRV1",277,0)
 ;
"RTN","HLEVSRV1",278,0)
 D SHOWXTMP("Last (and newly created) XTMP entry",$O(^XTMP("HLEV SERVER 9999999"),-1))
"RTN","HLEVSRV1",279,0)
 ;
"RTN","HLEVSRV1",280,0)
 W !!,"The last 776 IEN = ",$O(^HLEV(776,":"),-1),"..."
"RTN","HLEVSRV1",281,0)
 W !
"RTN","HLEVSRV1",282,0)
 ;
"RTN","HLEVSRV1",283,0)
 D ^%G
"RTN","HLEVSRV1",284,0)
 ;
"RTN","HLEVSRV1",285,0)
 Q
"RTN","HLEVSRV1",286,0)
 ;
"RTN","HLEVSRV1",287,0)
SHOWXTMP(TXT,XTMP) ; Show the XTMP data...
"RTN","HLEVSRV1",288,0)
 N DATA,LP,POSX,ST
"RTN","HLEVSRV1",289,0)
 ;
"RTN","HLEVSRV1",290,0)
 I '$D(^XTMP(XTMP)) QUIT  ;->
"RTN","HLEVSRV1",291,0)
 ;
"RTN","HLEVSRV1",292,0)
 W !!,$$CJ^XLFSTR(" "_TXT_" ",IOM,"=")
"RTN","HLEVSRV1",293,0)
 ;
"RTN","HLEVSRV1",294,0)
 S LP=$NA(^XTMP(XTMP)),ST=$E(LP,1,$L(LP)-1)_","
"RTN","HLEVSRV1",295,0)
 F  S LP=$Q(@LP) Q:LP'[ST  D
"RTN","HLEVSRV1",296,0)
 .  W !,LP," = "
"RTN","HLEVSRV1",297,0)
 .  S POSX=$X,DATA=@LP
"RTN","HLEVSRV1",298,0)
 .  F  Q:DATA']""  D
"RTN","HLEVSRV1",299,0)
 .  .  W:$X>POSX ! W:$X<POSX ?POSX
"RTN","HLEVSRV1",300,0)
 .  .  W $E(DATA,1,IOM-POSX-1)
"RTN","HLEVSRV1",301,0)
 .  .  S DATA=$E(DATA,IOM-POSX,999)
"RTN","HLEVSRV1",302,0)
 ;
"RTN","HLEVSRV1",303,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVSRV1",304,0)
 ;
"RTN","HLEVSRV1",305,0)
 Q
"RTN","HLEVSRV1",306,0)
 ;
"RTN","HLEVSRV1",307,0)
EOR ;HLEVSRV1 - Event Monitor SERVER ;5/16/03 14:42
"RTN","HLEVSRV2")
0^28^B50293053
"RTN","HLEVSRV2",1,0)
HLEVSRV2 ;O-OIFO/LJA - Event Monitor SERVER ;02/04/2004 14:42
"RTN","HLEVSRV2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVSRV2",3,0)
 ;
"RTN","HLEVSRV2",4,0)
QUERYSTR ; Generate $QUERY strings...
"RTN","HLEVSRV2",5,0)
 N IOINHI,IOINORM,STRING,X
"RTN","HLEVSRV2",6,0)
 ;
"RTN","HLEVSRV2",7,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLEVSRV2",8,0)
 ;
"RTN","HLEVSRV2",9,0)
 D HD,EX,TELL^HLEVMST0("","0^0^999","Press RETURN to continue... ")
"RTN","HLEVSRV2",10,0)
 ;
"RTN","HLEVSRV2",11,0)
 F  S STRING=$$STRING QUIT:STRING']""  D
"RTN","HLEVSRV2",12,0)
 .  S STRING(STRING)=""
"RTN","HLEVSRV2",13,0)
 .  W !!,"Search string = ",IOINHI,STRING,IOINORM
"RTN","HLEVSRV2",14,0)
 ;
"RTN","HLEVSRV2",15,0)
 QUIT:$O(STRING(""))']""  ;->
"RTN","HLEVSRV2",16,0)
 W !!,IOINHI,"Paste the following ""search strings"" into an email message and send to the"
"RTN","HLEVSRV2",17,0)
 W !,"S.HLEV-INFORMATION-SERVER@REMOTE-SITE.",IOINORM
"RTN","HLEVSRV2",18,0)
 W !!
"RTN","HLEVSRV2",19,0)
 ;
"RTN","HLEVSRV2",20,0)
 S STRING=""
"RTN","HLEVSRV2",21,0)
 F  S STRING=$O(STRING(STRING)) Q:STRING']""  D
"RTN","HLEVSRV2",22,0)
 .  W !,STRING
"RTN","HLEVSRV2",23,0)
 ;
"RTN","HLEVSRV2",24,0)
 Q
"RTN","HLEVSRV2",25,0)
 ;
"RTN","HLEVSRV2",26,0)
STRING() ; Ask user to input values to be built into a search string
"RTN","HLEVSRV2",27,0)
 N FILTER,LIMIT,ROOT,STOP
"RTN","HLEVSRV2",28,0)
 S ROOT=$$QUERYRT QUIT:ROOT']"" "" ;->
"RTN","HLEVSRV2",29,0)
 S STOP=$$QUERYST(ROOT) QUIT:STOP']"" "" ;->
"RTN","HLEVSRV2",30,0)
 S LIMIT=$$QUERYLM
"RTN","HLEVSRV2",31,0)
 S FILTER=$$QUERYFL
"RTN","HLEVSRV2",32,0)
 Q ROOT_U_STOP_U_LIMIT_U_FILTER
"RTN","HLEVSRV2",33,0)
 ;
"RTN","HLEVSRV2",34,0)
QUERYRT() ;
"RTN","HLEVSRV2",35,0)
 N VAL
"RTN","HLEVSRV2",36,0)
 D TAG("$QUERY ROOT")
"RTN","HLEVSRV2",37,0)
 D EXRT
"RTN","HLEVSRV2",38,0)
 W !
"RTN","HLEVSRV2",39,0)
 S VAL=$$FT("Enter $QUERY ROOT") QUIT:VAL']""!(VAL=U) "" ;->
"RTN","HLEVSRV2",40,0)
 Q VAL
"RTN","HLEVSRV2",41,0)
 ;
"RTN","HLEVSRV2",42,0)
EXRT N I,T F I=1:1 S T=$T(EXRT+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVSRV2",43,0)
 ;;Enter the $QUERY root now.  For example...
"RTN","HLEVSRV2",44,0)
 ;;
"RTN","HLEVSRV2",45,0)
 ;; - If you want to see all data for ^HL(772,25132), including the zero node
"RTN","HLEVSRV2",46,0)
 ;;   and all data, enter "HL(772,25132)".
"RTN","HLEVSRV2",47,0)
 ;; - If you want to see all data for HLMA(9132), including the zero node and
"RTN","HLEVSRV2",48,0)
 ;;   all data, enter "^HLMA(9132)".
"RTN","HLEVSRV2",49,0)
 ;;
"RTN","HLEVSRV2",50,0)
 ;;NOTE:  Do not enter the leading up-arrow before a global reference.
"RTN","HLEVSRV2",51,0)
 Q
"RTN","HLEVSRV2",52,0)
 ;
"RTN","HLEVSRV2",53,0)
QUERYST(ROOT) ;
"RTN","HLEVSRV2",54,0)
 N VAL
"RTN","HLEVSRV2",55,0)
 D TAG("$QUERY Stop Value")
"RTN","HLEVSRV2",56,0)
 D EXST
"RTN","HLEVSRV2",57,0)
 S VAL=$E(ROOT,$L(ROOT)),VAL=$S(VAL=")":$E(ROOT,1,$L(ROOT)-1)_",",1:ROOT)
"RTN","HLEVSRV2",58,0)
 W !
"RTN","HLEVSRV2",59,0)
 S VAL=$$FT("Enter $QUERY STOP VALUE",VAL) QUIT:VAL']""!(VAL=U) "" ;->
"RTN","HLEVSRV2",60,0)
 Q VAL
"RTN","HLEVSRV2",61,0)
 ;
"RTN","HLEVSRV2",62,0)
EXST N I,T F I=1:1 S T=$T(EXST+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVSRV2",63,0)
 ;;Enter the $QUERY stop value now.  For example...
"RTN","HLEVSRV2",64,0)
 ;;
"RTN","HLEVSRV2",65,0)
 ;; - Assuming you entered "HL(772,25132)" (see helps under root entry above),
"RTN","HLEVSRV2",66,0)
 ;;   you would enter a stop value of "HL(772,25132,".
"RTN","HLEVSRV2",67,0)
 ;; - Assuming you entered "HLMA(9132)", enter a stop value of "HLMA(9132,".
"RTN","HLEVSRV2",68,0)
 Q
"RTN","HLEVSRV2",69,0)
 ;
"RTN","HLEVSRV2",70,0)
QUERYLM() ;
"RTN","HLEVSRV2",71,0)
 N VAL
"RTN","HLEVSRV2",72,0)
 D TAG("Data Node Limit")
"RTN","HLEVSRV2",73,0)
 D EXLM
"RTN","HLEVSRV2",74,0)
 R !!,"Enter LIMIT: ",VAL:60 Q:VAL'>0 "" ;->
"RTN","HLEVSRV2",75,0)
 QUIT:VAL>1000 1000 ;->
"RTN","HLEVSRV2",76,0)
 Q VAL
"RTN","HLEVSRV2",77,0)
 ;
"RTN","HLEVSRV2",78,0)
EXLM N I,T F I=1:1 S T=$T(EXLM+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVSRV2",79,0)
 ;;You can limit the number of nodes that are returned.  This is especially 
"RTN","HLEVSRV2",80,0)
 ;;helpful when you don't know how many data nodes exist and will be returned by
"RTN","HLEVSRV2",81,0)
 ;;your request.  (You don't want to send a request, thinking you'll get around
"RTN","HLEVSRV2",82,0)
 ;;20 data nodes back, when 20,000 data nodes exist!)
"RTN","HLEVSRV2",83,0)
 ;;
"RTN","HLEVSRV2",84,0)
 ;;Enter the maximum number of nodes you want returned.
"RTN","HLEVSRV2",85,0)
 ;;
"RTN","HLEVSRV2",86,0)
 ;;NOTE:  The maximum number of data nodes returnable by each $QUERY search 
"RTN","HLEVSRV2",87,0)
 ;;       string is 1000.  So, there is no point entering any limit above 1000!
"RTN","HLEVSRV2",88,0)
 Q
"RTN","HLEVSRV2",89,0)
 ;
"RTN","HLEVSRV2",90,0)
QUERYFL() ;
"RTN","HLEVSRV2",91,0)
 N VAL
"RTN","HLEVSRV2",92,0)
 D TAG("Filter Reference")
"RTN","HLEVSRV2",93,0)
 D EXFL
"RTN","HLEVSRV2",94,0)
 W !
"RTN","HLEVSRV2",95,0)
 S VAL=$$FT("Enter FILTER REFERENCE","","O") QUIT:VAL']""!(VAL=U) "" ;->
"RTN","HLEVSRV2",96,0)
 Q VAL
"RTN","HLEVSRV2",97,0)
 ;
"RTN","HLEVSRV2",98,0)
EXFL N I,T F I=1:1 S T=$T(EXFL+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVSRV2",99,0)
 ;;$QUERY returns all data nodes no matter the structure of the subscripts.  At
"RTN","HLEVSRV2",100,0)
 ;;times you might want to filter out the data nodes whose subscripting does not
"RTN","HLEVSRV2",101,0)
 ;;follow a specific format.  You can define such a filter now.  Some filter
"RTN","HLEVSRV2",102,0)
 ;;examples are shown below.
"RTN","HLEVSRV2",103,0)
 ;;
"RTN","HLEVSRV2",104,0)
 ;; - If you only want to see ^HL(772,IEN,"IN",1,0) enter a filter of "HL(772,#,"IN",1,0)".
"RTN","HLEVSRV2",105,0)
 ;; - If you want to see the message text in a file 772 entry, enter a filter of
"RTN","HLEVSRV2",106,0)
 ;;   "HL(772,#,"IN",#,0)".
"RTN","HLEVSRV2",107,0)
 ;;
"RTN","HLEVSRV2",108,0)
 ;;You probably noticed that the "#" symbol must be placed at every subscript
"RTN","HLEVSRV2",109,0)
 ;;location where you want "any IEN" to be included.
"RTN","HLEVSRV2",110,0)
 Q
"RTN","HLEVSRV2",111,0)
 ;
"RTN","HLEVSRV2",112,0)
TAG(TXT) W !!,$$CJ^XLFSTR("----------- "_IOINHI_TXT_IOINORM_"-----------",IOM+$L(IOINHI)+$L(IOINORM))
"RTN","HLEVSRV2",113,0)
 Q
"RTN","HLEVSRV2",114,0)
 ;
"RTN","HLEVSRV2",115,0)
HD W @IOF,$$CJ^XLFSTR("$QUERY String Generator",IOM)
"RTN","HLEVSRV2",116,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVSRV2",117,0)
 QUIT
"RTN","HLEVSRV2",118,0)
 ;
"RTN","HLEVSRV2",119,0)
EX N I,T F I=1:1 S T=$T(EX+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVSRV2",120,0)
 ;;$QUERY-based search strings can be sent to the S.HLEV-INFORMATION-SERVER at
"RTN","HLEVSRV2",121,0)
 ;;remote sites requesting data to be returned to the HL7SystemMonitoring mail
"RTN","HLEVSRV2",122,0)
 ;;group.  Structuring $QUERY search strings can be complicated.  This utility
"RTN","HLEVSRV2",123,0)
 ;;will assist you in creating these search strings.
"RTN","HLEVSRV2",124,0)
 ;;
"RTN","HLEVSRV2",125,0)
 ;;The search string(s) created should be pasted into the mail message sent to
"RTN","HLEVSRV2",126,0)
 ;;the remote site.
"RTN","HLEVSRV2",127,0)
 ;;
"RTN","HLEVSRV2",128,0)
 ;;The parts of the $QUERY search string are listed below.
"RTN","HLEVSRV2",129,0)
 ;;
"RTN","HLEVSRV2",130,0)
 ;;  - $QUERY root
"RTN","HLEVSRV2",131,0)
 ;;  - $QUERY stop value
"RTN","HLEVSRV2",132,0)
 ;;  - # nodes to return
"RTN","HLEVSRV2",133,0)
 ;;  - Node filter format
"RTN","HLEVSRV2",134,0)
 QUIT
"RTN","HLEVSRV2",135,0)
 ;
"RTN","HLEVSRV2",136,0)
MONITOR(TXT) ; User requested that a monitor be run...
"RTN","HLEVSRV2",137,0)
 ; XTMP -- req
"RTN","HLEVSRV2",138,0)
 N HLEVIENE,MONM,PCE,QTIME,RECIP,VAL
"RTN","HLEVSRV2",139,0)
 ;
"RTN","HLEVSRV2",140,0)
 ; Email data request format: MONITOR^monitor-name^queue-time^recip's
"RTN","HLEVSRV2",141,0)
 ;
"RTN","HLEVSRV2",142,0)
 S MONM=$P(TXT,U) QUIT:MONM']""  ;->
"RTN","HLEVSRV2",143,0)
 S HLEVIENE=$O(^HLEV(776.1,"B",MONM,0)) QUIT:HLEVIENE'>0  ;->
"RTN","HLEVSRV2",144,0)
 QUIT:$P($G(^HLEV(776.1,+HLEVIENE,0)),U,5)'=1  ;-> Not remote requestable
"RTN","HLEVSRV2",145,0)
 S QTIME=$P(TXT,U,2) I QTIME'?7N1"."1.N S QTIME=$$NOW^XLFDT
"RTN","HLEVSRV2",146,0)
 ;
"RTN","HLEVSRV2",147,0)
 D ADDREQHD^HLEVSRV ; Initial header
"RTN","HLEVSRV2",148,0)
 D ADDREQ^HLEVSRV("Monitor: "_MONM_" [#"_HLEVIENE_"]")
"RTN","HLEVSRV2",149,0)
 ;
"RTN","HLEVSRV2",150,0)
 S ^XTMP(XTMP,"MONREQ","MON",HLEVIENE)=MONM
"RTN","HLEVSRV2",151,0)
 ;
"RTN","HLEVSRV2",152,0)
 S VAL=$P(TXT,U,2,999) Q:VAL']""  ;->
"RTN","HLEVSRV2",153,0)
 F PCE=1:1:$L(VAL,U) D
"RTN","HLEVSRV2",154,0)
 .  S RECIP=$P(VAL,U,PCE) QUIT:RECIP']""  ;->
"RTN","HLEVSRV2",155,0)
 .  S ^XTMP(XTMP,"MONREQ","MON",+HLEVIENE,RECIP)=""
"RTN","HLEVSRV2",156,0)
 .  D ADDREQ^HLEVSRV("         recipient = "_RECIP)
"RTN","HLEVSRV2",157,0)
 ;
"RTN","HLEVSRV2",158,0)
 S ^XTMP(XTMP,"MONREQ","TASK")=$$Q1TIME^HLEVAPI0(HLEVIENE,1,QTIME,XTMP)
"RTN","HLEVSRV2",159,0)
 ;
"RTN","HLEVSRV2",160,0)
 Q
"RTN","HLEVSRV2",161,0)
 ;
"RTN","HLEVSRV2",162,0)
FT(PMT,DEF,WAY) ; Return user-input text...
"RTN","HLEVSRV2",163,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLEVSRV2",164,0)
 S DIR(0)="F"_$G(WAY)
"RTN","HLEVSRV2",165,0)
 S DIR("A")=PMT
"RTN","HLEVSRV2",166,0)
 I $G(DEF)]"" S DIR("B")=DEF
"RTN","HLEVSRV2",167,0)
 D ^DIR
"RTN","HLEVSRV2",168,0)
 I Y?1"^"1.E&($L(Y,U)=2) QUIT $P(Y,U,2) ;->
"RTN","HLEVSRV2",169,0)
 QUIT:$D(DIRUT)!($D(DTOUT))!($D(DUOUT)) U ;->
"RTN","HLEVSRV2",170,0)
 Q Y
"RTN","HLEVSRV2",171,0)
 ;
"RTN","HLEVSRV2",172,0)
ADDMAIL(TXT) ; Add TXT, but be sure it is on or after NUM
"RTN","HLEVSRV2",173,0)
 N SNO
"RTN","HLEVSRV2",174,0)
 QUIT:$G(HLEVOVER)  ;-> Over 5000 line limit...
"RTN","HLEVSRV2",175,0)
 S SNO=$O(^XTMP(XTMP,"HLMAIL",":"),-1)+1
"RTN","HLEVSRV2",176,0)
 I SNO<100 S SNO=100 ; Leave room at the top for messages
"RTN","HLEVSRV2",177,0)
 I SNO>5100 D  QUIT  ;->
"RTN","HLEVSRV2",178,0)
 .  S HLEVOVER=1
"RTN","HLEVSRV2",179,0)
 .  S TXT="     ***** 5000 Line Limit Reached!  Some text not included. *****"
"RTN","HLEVSRV2",180,0)
 .  S ^XTMP(XTMP,"HLMAIL",+SNO)=""
"RTN","HLEVSRV2",181,0)
 .  S ^XTMP(XTMP,"HLMAIL",+SNO+1)=""
"RTN","HLEVSRV2",182,0)
 .  S ^XTMP(XTMP,"HLMAIL",+SNO+2)=TXT
"RTN","HLEVSRV2",183,0)
 .  S ^XTMP(XTMP,"HLMAIL",1)=""
"RTN","HLEVSRV2",184,0)
 .  S ^XTMP(XTMP,"HLMAIL",2)=TXT
"RTN","HLEVSRV2",185,0)
 .  S ^XTMP(XTMP,"HLMAIL",3)=""
"RTN","HLEVSRV2",186,0)
 S ^XTMP(XTMP,"HLMAIL",+SNO)=TXT
"RTN","HLEVSRV2",187,0)
 Q
"RTN","HLEVSRV2",188,0)
 ;
"RTN","HLEVSRV2",189,0)
EOR ;HLEVSRV2 - Event Monitor SERVER ;5/16/03 14:42
"RTN","HLEVSRV3")
0^30^B59454255
"RTN","HLEVSRV3",1,0)
HLEVSRV3 ;O-OIFO/LJA - Event Monitor SERVER ;02/04/2004 14:42
"RTN","HLEVSRV3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVSRV3",3,0)
 ;
"RTN","HLEVSRV3",4,0)
OPENMAIL ; Grant license to remote requesters...
"RTN","HLEVSRV3",5,0)
 N ANS,CODE,CODEXP,EXPNOW,IOINHI,IOINORM,NOW,X,XTMP
"RTN","HLEVSRV3",6,0)
 ;
"RTN","HLEVSRV3",7,0)
 S XTMP="HLEV REMOTE LICENSE"
"RTN","HLEVSRV3",8,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLEVSRV3",9,0)
 S NOW=$$NOW^XLFDT
"RTN","HLEVSRV3",10,0)
 ;
"RTN","HLEVSRV3",11,0)
 D HDM
"RTN","HLEVSRV3",12,0)
 D EXM
"RTN","HLEVSRV3",13,0)
 F  Q:($Y+3)>IOSL  W !
"RTN","HLEVSRV3",14,0)
 QUIT:$$BTE^HLCSMON("Press RETURN to continue, or '^' to exit... ")
"RTN","HLEVSRV3",15,0)
 ;
"RTN","HLEVSRV3",16,0)
 D HDM
"RTN","HLEVSRV3",17,0)
 ;
"RTN","HLEVSRV3",18,0)
 S (CODE,CODEXP,EXPNOW)="" ; Default to no current license...
"RTN","HLEVSRV3",19,0)
 ;
"RTN","HLEVSRV3",20,0)
 ; Current license?  Show details of current (maybe expired) license.
"RTN","HLEVSRV3",21,0)
 S CODE=$G(^XTMP(XTMP,"CODE")) I CODE]"" D
"RTN","HLEVSRV3",22,0)
 .  S CODEXP=$P(CODE,U),CODE=$P(CODE,U,2)
"RTN","HLEVSRV3",23,0)
 .  S EXPNOW=$S(CODEXP<NOW:1,1:0) ; Is license expired?
"RTN","HLEVSRV3",24,0)
 .  D SHOWLIC
"RTN","HLEVSRV3",25,0)
 ;
"RTN","HLEVSRV3",26,0)
 I CODE']"" W !!,"No current license exists..."
"RTN","HLEVSRV3",27,0)
 ;
"RTN","HLEVSRV3",28,0)
 ; OK.  License and expiration date exist...
"RTN","HLEVSRV3",29,0)
 S EXPNOW=$S(CODEXP<NOW:1,1:0) ; Is license expired?
"RTN","HLEVSRV3",30,0)
 ;
"RTN","HLEVSRV3",31,0)
 F  D  QUIT:ACTION="EXIT"
"RTN","HLEVSRV3",32,0)
 .  N STR
"RTN","HLEVSRV3",33,0)
 .  S STR=$S($D(^XTMP(XTMP)):1,1:0)
"RTN","HLEVSRV3",34,0)
 .  I STR S STR(1)="LICEXT^Change cutoff date/time~LICUSER^Add requesters~LICNEW^Create new license"_$S(CODE]"":" (and cancel old license)",1:"")_"~LICAN^Cancel current license~EXIT^Exit"
"RTN","HLEVSRV3",35,0)
 .  I 'STR S STR(1)="LICNEW^Create new license~EXIT^Exit"
"RTN","HLEVSRV3",36,0)
 .  S ACTION=$$ASKDIR(STR(1),$$DEFAULT)
"RTN","HLEVSRV3",37,0)
 .  S:ACTION']"" ACTION="EXIT"
"RTN","HLEVSRV3",38,0)
 .  QUIT:ACTION="EXIT"  ;->
"RTN","HLEVSRV3",39,0)
 .  S ACTION=ACTION_"^HLEVSRV4"
"RTN","HLEVSRV3",40,0)
 .  D @ACTION
"RTN","HLEVSRV3",41,0)
 .  D SHOWLIC
"RTN","HLEVSRV3",42,0)
 ;
"RTN","HLEVSRV3",43,0)
 I '$D(^XTMP(XTMP)) QUIT  ;->
"RTN","HLEVSRV3",44,0)
 ;
"RTN","HLEVSRV3",45,0)
 I $O(^XTMP(XTMP,"USER",""))']"" D
"RTN","HLEVSRV3",46,0)
 .  W !!,"No requesters have been created under this license.  So, even thought a"
"RTN","HLEVSRV3",47,0)
 .  W !,"license exists, no one can make use of the license.  To enter requesters, you"
"RTN","HLEVSRV3",48,0)
 .  W !,"must reinvoke this option and enter one or more requesters."
"RTN","HLEVSRV3",49,0)
 ;
"RTN","HLEVSRV3",50,0)
 I EXPNOW W !!,"The current license is expired!"
"RTN","HLEVSRV3",51,0)
 ;
"RTN","HLEVSRV3",52,0)
 I $O(^XTMP(XTMP,"USER",""))']""!(EXPNOW) D
"RTN","HLEVSRV3",53,0)
 .  W !
"RTN","HLEVSRV3",54,0)
 .  S X=$$BTE^HLCSMON("Press RETURN to exit...")
"RTN","HLEVSRV3",55,0)
 ;
"RTN","HLEVSRV3",56,0)
 Q
"RTN","HLEVSRV3",57,0)
 ;
"RTN","HLEVSRV3",58,0)
DEFAULT() ; What would most users do under circumstances?
"RTN","HLEVSRV3",59,0)
 ; CODE,CODEXP,EXPNOW,XTMP -- req
"RTN","HLEVSRV3",60,0)
 I CODE']""!('$D(^XTMP(XTMP))) QUIT "Create new license" ;->
"RTN","HLEVSRV3",61,0)
 I EXPNOW QUIT "Change cutoff date/time" ;->
"RTN","HLEVSRV3",62,0)
 I $O(^XTMP(XTMP,"USER",""))']"" QUIT "Add requesters" ;->
"RTN","HLEVSRV3",63,0)
 Q "Exit"
"RTN","HLEVSRV3",64,0)
 ;
"RTN","HLEVSRV3",65,0)
SHOWLIC ; Show license and expiration date...
"RTN","HLEVSRV3",66,0)
 ; CODE,CODEXP,EXPNOW,IOINHI,IOINORM,XTMP -- req
"RTN","HLEVSRV3",67,0)
 N HOLD,NO,USER
"RTN","HLEVSRV3",68,0)
 ;
"RTN","HLEVSRV3",69,0)
 I '$D(^XTMP(XTMP)) D  QUIT  ;->
"RTN","HLEVSRV3",70,0)
 .  W !!,$$CJ^XLFSTR("---------------- No License Exists ----------------",IOM)
"RTN","HLEVSRV3",71,0)
 ;
"RTN","HLEVSRV3",72,0)
 W !!,$$CJ^XLFSTR("---------------- Current License - "_CODE_" ["_$S(EXPNOW:IOINHI,1:"")_$$SDT^HLEVX001(CODEXP)_IOINORM_"] ----------------",IOM)
"RTN","HLEVSRV3",73,0)
 ;
"RTN","HLEVSRV3",74,0)
 S NO=0,USER=""
"RTN","HLEVSRV3",75,0)
 F  S USER=$O(^XTMP(XTMP,"USER",USER)) Q:USER']""  D
"RTN","HLEVSRV3",76,0)
 .  S NO=NO+1,HOLD(USER)=""
"RTN","HLEVSRV3",77,0)
 ;
"RTN","HLEVSRV3",78,0)
 I NO'>0 W !,$$CJ^XLFSTR("No current users exist!",IOM) QUIT  ;->
"RTN","HLEVSRV3",79,0)
 ;
"RTN","HLEVSRV3",80,0)
 W !,$$CJ^XLFSTR("----- Licensed Requesters ------",IOM)
"RTN","HLEVSRV3",81,0)
 S USER=""
"RTN","HLEVSRV3",82,0)
 F  S USER=$O(HOLD(USER)) Q:USER']""  D
"RTN","HLEVSRV3",83,0)
 .  W !,$$CJ^XLFSTR(USER,IOM)
"RTN","HLEVSRV3",84,0)
 ;
"RTN","HLEVSRV3",85,0)
 Q
"RTN","HLEVSRV3",86,0)
 ;
"RTN","HLEVSRV3",87,0)
SETLIC(CODE) ; Set license...
"RTN","HLEVSRV3",88,0)
 ; XTMP -- req
"RTN","HLEVSRV3",89,0)
 N CUT
"RTN","HLEVSRV3",90,0)
 S CUT=+CODE
"RTN","HLEVSRV3",91,0)
 ;
"RTN","HLEVSRV3",92,0)
 KILL ^XTMP(XTMP) ; Remove all old data...
"RTN","HLEVSRV3",93,0)
 ;
"RTN","HLEVSRV3",94,0)
 ; Set vaporization date to 7 days after cutoff time...
"RTN","HLEVSRV3",95,0)
 S ^XTMP(XTMP,0)=$$FMADD^XLFDT(CUT,7)_U_$$NOW^XLFDT_U_"VistA HL7 Remote Request License"
"RTN","HLEVSRV3",96,0)
 ;
"RTN","HLEVSRV3",97,0)
 S ^XTMP(XTMP,"CODE")=CODE ; Cutoff date/time ^ Code
"RTN","HLEVSRV3",98,0)
 S ^XTMP(XTMP,"USER")=$$NOW^XLFDT_U_DUZ
"RTN","HLEVSRV3",99,0)
 ;
"RTN","HLEVSRV3",100,0)
 Q
"RTN","HLEVSRV3",101,0)
 ;
"RTN","HLEVSRV3",102,0)
HDM ; Header for option...
"RTN","HLEVSRV3",103,0)
 ; IOINHI,IOINORM,XTMP -- req
"RTN","HLEVSRV3",104,0)
 N CODE,NOW
"RTN","HLEVSRV3",105,0)
 W @IOF,$$CJ^XLFSTR("Grant License to Remote Requesters",IOM)
"RTN","HLEVSRV3",106,0)
 S CODE=$G(^XTMP(XTMP,"CODE")) I CODE]"" D
"RTN","HLEVSRV3",107,0)
 .  S CUT=+CODE,CODE=$P(CODE,U,2,999)
"RTN","HLEVSRV3",108,0)
 .  I CUT<$$NOW^XLFDT D  QUIT  ;->
"RTN","HLEVSRV3",109,0)
 .  .  W !,$$CJ^XLFSTR("License: "_CODE_"   Cutoff: "_IOINHI_$$FMTE^XLFDT(CUT)_IOINORM,IOM+$L(IOINHI)+$L(IOINORM))
"RTN","HLEVSRV3",110,0)
 .  W !,$$CJ^XLFSTR("License: "_CODE_"   Cutoff: "_$$FMTE^XLFDT(CUT),IOM)
"RTN","HLEVSRV3",111,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVSRV3",112,0)
 QUIT
"RTN","HLEVSRV3",113,0)
 ;
"RTN","HLEVSRV3",114,0)
EXM N I,T F I=1:1 S T=$T(EXM+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVSRV3",115,0)
 ;;Mailman server requests can be sent to your site requesting HL7 data be 
"RTN","HLEVSRV3",116,0)
 ;;returned to the VistA HL7 team.  These requests are normally only sent to
"RTN","HLEVSRV3",117,0)
 ;;the VistA HL7 team.  However, from time to time, support personnel will have
"RTN","HLEVSRV3",118,0)
 ;;legitimate need to retrieve critical VistA HL7 data.  In order to receive
"RTN","HLEVSRV3",119,0)
 ;;return data, anyone not on the VistA HL7 team needs a license.  This option
"RTN","HLEVSRV3",120,0)
 ;;will generate a license that must be communicated to those (not on the VistA
"RTN","HLEVSRV3",121,0)
 ;;HL7 team) requesting remote query rights.
"RTN","HLEVSRV3",122,0)
 ;;
"RTN","HLEVSRV3",123,0)
 ;;Note:  Notification of every remote server request is automatically sent to
"RTN","HLEVSRV3",124,0)
 ;;       the VistA HL7 team.  And, this includes the messages sent remotely
"RTN","HLEVSRV3",125,0)
 ;;       to non-VistA HL7 recipients (using the license you are about to grant.)
"RTN","HLEVSRV3",126,0)
 QUIT
"RTN","HLEVSRV3",127,0)
 ;
"RTN","HLEVSRV3",128,0)
GRANT() ; Get date and license...
"RTN","HLEVSRV3",129,0)
 N CODE,CONT,CUT,FUTURE,LICENSE
"RTN","HLEVSRV3",130,0)
 ;
"RTN","HLEVSRV3",131,0)
 S CODE=$G(^XTMP(XTMP,"CODE")) I CODE]"" D  QUIT:'CONT "" ;->
"RTN","HLEVSRV3",132,0)
 .  S CONT=1
"RTN","HLEVSRV3",133,0)
 .  W !!,"License# ",IOINHI,$P(CODE,U,2),IOINORM," exists and has a cutoff time of ",$$FMTE^XLFDT($P(CODE,U)),"."
"RTN","HLEVSRV3",134,0)
 .  W !
"RTN","HLEVSRV3",135,0)
 .  I $$YN^HLCSRPT4("Terminate license now","No") D  QUIT:'CONT  ;->
"RTN","HLEVSRV3",136,0)
 .  .  KILL ^XTMP(XTMP)
"RTN","HLEVSRV3",137,0)
 .  .  W "  done..."
"RTN","HLEVSRV3",138,0)
 .  .  S CONT=""
"RTN","HLEVSRV3",139,0)
 .  W !
"RTN","HLEVSRV3",140,0)
 .  QUIT:'$$YN^HLCSRPT4("Keep license and extend time","Yes")  ;->
"RTN","HLEVSRV3",141,0)
 .  W !!,"Defaulting 'NOW + 7 days' below..."
"RTN","HLEVSRV3",142,0)
 .  W !
"RTN","HLEVSRV3",143,0)
 .  S CUT=$$ASKDATE^HLEVAPI2("Enter CUTOFF DATE","EXT",$P($$FMTE^XLFDT(+$$FMADD^XLFDT($$NOW^XLFDT,7)),":",1,2)) QUIT:'CUT  ;->
"RTN","HLEVSRV3",144,0)
 .  S $P(^XTMP(XTMP,"CODE"),U)=CUT
"RTN","HLEVSRV3",145,0)
 .  S ^XTMP(XTMP,0)=CUT_U_$$NOW^XLFDT_U_"VistA HL7 Remote Request License"
"RTN","HLEVSRV3",146,0)
 .  S ^XTMP(XTMP,"USER")=$$NOW^XLFDT_U_DUZ
"RTN","HLEVSRV3",147,0)
 .  W "  updated..."
"RTN","HLEVSRV3",148,0)
 .  S CONT=0
"RTN","HLEVSRV3",149,0)
 ;
"RTN","HLEVSRV3",150,0)
 S FUTURE=$$FMADD^XLFDT($$NOW^XLFDT,0,1)
"RTN","HLEVSRV3",151,0)
 W !!,"Enter a future  cutoff date/time now after which no remote requests by"
"RTN","HLEVSRV3",152,0)
 W !,"non-VistA HL7 team message recipients will be honored."
"RTN","HLEVSRV3",153,0)
 W !!,"Defaulting 'NOW + 7 days' below..."
"RTN","HLEVSRV3",154,0)
 W !
"RTN","HLEVSRV3",155,0)
G1 S CUT=$$ASKDATE^HLEVAPI2("Enter CUTOFF DATE","EXT",$P($$FMTE^XLFDT(+$$FMADD^XLFDT($$NOW^XLFDT,7)),":",1,2)) QUIT:'CUT "NO" ;->
"RTN","HLEVSRV3",156,0)
 I CUT<FUTURE D  G G1 ;->
"RTN","HLEVSRV3",157,0)
 .  W "  enter time one hour or more in future..."
"RTN","HLEVSRV3",158,0)
 S LICENSE=$$CODE
"RTN","HLEVSRV3",159,0)
 W !!,"License# ",IOINHI,LICENSE,IOINORM," generated..."
"RTN","HLEVSRV3",160,0)
 Q "SET^"_CUT_U_LICENSE
"RTN","HLEVSRV3",161,0)
 ;
"RTN","HLEVSRV3",162,0)
CODE() ; Return license code...
"RTN","HLEVSRV3",163,0)
 N CODE,EX,NOP,TYPE
"RTN","HLEVSRV3",164,0)
 F EX=39,44,95,96 S EX(EX)=""
"RTN","HLEVSRV3",165,0)
 S CODE="",NOP=0
"RTN","HLEVSRV3",166,0)
 F EX=1:1:6 D
"RTN","HLEVSRV3",167,0)
 .  S TYPE=$P("A^P",U,$R(2)+1)
"RTN","HLEVSRV3",168,0)
 .  I EX=6,NOP=0 S TYPE="P" ; Must be at least one punctuation
"RTN","HLEVSRV3",169,0)
 .  I TYPE="P" S NOP=NOP+1
"RTN","HLEVSRV3",170,0)
 .  S:NOP>1 TYPE="A"
"RTN","HLEVSRV3",171,0)
 .  S CODE=CODE_$$RNO(TYPE)
"RTN","HLEVSRV3",172,0)
 .  I EX=3 S CODE=CODE_"-"
"RTN","HLEVSRV3",173,0)
 Q CODE
"RTN","HLEVSRV3",174,0)
 ;
"RTN","HLEVSRV3",175,0)
RNO(TYPE) ; Return random number between 33 and 122 (w/exceptions)
"RTN","HLEVSRV3",176,0)
 ; NOP -- req
"RTN","HLEVSRV3",177,0)
 N NO,OK
"RTN","HLEVSRV3",178,0)
 F  S NO=$R(89)+33 D  Q:OK
"RTN","HLEVSRV3",179,0)
 .  S OK=0
"RTN","HLEVSRV3",180,0)
 .  I $D(EX(NO)) QUIT  ;-> Is it in exclusion list?
"RTN","HLEVSRV3",181,0)
 .  I TYPE="A" D  QUIT  ;-> Is it an alpha character
"RTN","HLEVSRV3",182,0)
 .  .  I $$ALPHA(NO) S OK=1
"RTN","HLEVSRV3",183,0)
 .  I '$$ALPHA(NO) S OK=1 ; Need punctuation...
"RTN","HLEVSRV3",184,0)
 Q $C(NO)
"RTN","HLEVSRV3",185,0)
 ;
"RTN","HLEVSRV3",186,0)
ALPHA(NO) ; Is it ALPHA character?
"RTN","HLEVSRV3",187,0)
 N X
"RTN","HLEVSRV3",188,0)
 S X=$A($$UP^XLFSTR($C(NO))) QUIT:X>64&(X<91) 1 ;->
"RTN","HLEVSRV3",189,0)
 Q ""
"RTN","HLEVSRV3",190,0)
 ;
"RTN","HLEVSRV3",191,0)
ASKDIR(CHOICES,DEFAULT) ; Ask user what to do...
"RTN","HLEVSRV3",192,0)
 ; CODE,CODEXP,EXPNOW -- req
"RTN","HLEVSRV3",193,0)
 N DIR,DIROUT,DIRUT,DTOUT,DUOUT,HOLD,PCE,TXT,X,Y
"RTN","HLEVSRV3",194,0)
 S DIR(0)="S^",DIR("A")="Select ACTION"
"RTN","HLEVSRV3",195,0)
 F PCE=1:1:$L(CHOICES,"~") D
"RTN","HLEVSRV3",196,0)
 .  S TXT=$P(CHOICES,"~",+PCE) QUIT:TXT']""  ;->
"RTN","HLEVSRV3",197,0)
 .  S TAG=$P(TXT,U),PMT=$P(TXT,U,2)
"RTN","HLEVSRV3",198,0)
 .  S DIR(0)=DIR(0)_$S(DIR(0)'="S^":";",1:"")_PCE_":"_PMT
"RTN","HLEVSRV3",199,0)
 .  S HOLD(PCE)=TAG
"RTN","HLEVSRV3",200,0)
 QUIT:DIR(0)="S^" "" ;->
"RTN","HLEVSRV3",201,0)
 I $G(DEFAULT)]"" S DIR("B")=DEFAULT
"RTN","HLEVSRV3",202,0)
 D ^DIR
"RTN","HLEVSRV3",203,0)
 S X=$G(HOLD(+Y)) QUIT:X]"" X ;->
"RTN","HLEVSRV3",204,0)
 Q ""
"RTN","HLEVSRV3",205,0)
 ;
"RTN","HLEVSRV3",206,0)
EOR ;HLEVSRV3 - Event Monitor SERVER ;5/16/03 14:42
"RTN","HLEVSRV4")
0^32^B33087391
"RTN","HLEVSRV4",1,0)
HLEVSRV4 ;O-OIFO/LJA - Event Monitor SERVER ;02/04/2004 14:42
"RTN","HLEVSRV4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVSRV4",3,0)
 ;
"RTN","HLEVSRV4",4,0)
LICEXT ; Change license date...  (Resets CODEXP,EXPNOW)
"RTN","HLEVSRV4",5,0)
 N CUT
"RTN","HLEVSRV4",6,0)
 W !
"RTN","HLEVSRV4",7,0)
 S CUT=$$ASKDATE^HLEVAPI2("Enter NEW CUTOFF DATE/TIME","EXT")
"RTN","HLEVSRV4",8,0)
 I CUT'?7N1"."1.N W "  no action taken..." QUIT  ;->
"RTN","HLEVSRV4",9,0)
 S $P(^XTMP(XTMP,"CODE"),U)=CUT
"RTN","HLEVSRV4",10,0)
 S ^XTMP(XTMP,0)=$$FMADD^XLFDT(CUT,7)_U_$$NOW^XLFDT_U_"VistA HL7 Remote Request License"
"RTN","HLEVSRV4",11,0)
 S ^XTMP(XTMP,"USER")=$$NOW^XLFDT_U_DUZ
"RTN","HLEVSRV4",12,0)
 W !!,"The current license has been changed to "
"RTN","HLEVSRV4",13,0)
 W $$FMTE^XLFDT(CUT),"..."
"RTN","HLEVSRV4",14,0)
 S CODEXP=CUT,EXPNOW=$S(CUT>NOW:0,1:1)
"RTN","HLEVSRV4",15,0)
 D SETLIC^HLEVSRV3(CODEXP_U_CODE)
"RTN","HLEVSRV4",16,0)
 Q
"RTN","HLEVSRV4",17,0)
 ;
"RTN","HLEVSRV4",18,0)
LICUSER ; Enter new users now...
"RTN","HLEVSRV4",19,0)
 ; IOINHI,IOINORM -- req
"RTN","HLEVSRV4",20,0)
 N POSX,USER
"RTN","HLEVSRV4",21,0)
 ;
"RTN","HLEVSRV4",22,0)
 W !!,"Enter the email address of the recipient(s).  (Enter the address of an"
"RTN","HLEVSRV4",23,0)
 W !,"existing user and they will be removed.)"
"RTN","HLEVSRV4",24,0)
 W !!,IOINHI,"Hint:",IOINORM,"   "
"RTN","HLEVSRV4",25,0)
 S POSX=8
"RTN","HLEVSRV4",26,0)
 W "You may enter ""something"" that is less exact than the complete"
"RTN","HLEVSRV4",27,0)
 W !,?POSX,"email address and not compromise security.  For example, if"
"RTN","HLEVSRV4",28,0)
 W !,?POSX,"the remote requester is named 'John Doe' and will be sending"
"RTN","HLEVSRV4",29,0)
 W !,?POSX,"requests from the Buffalo VAMC, you still might not know"
"RTN","HLEVSRV4",30,0)
 W !,?POSX,"the exact email address to enter.  (E.g., Should you enter"
"RTN","HLEVSRV4",31,0)
 W !,?POSX,"'JOHN.DOE@MED.VA.GOV' or 'DOE.JOHN@BUFFALO.VA.GOV'?)  And, this"
"RTN","HLEVSRV4",32,0)
 W !,?POSX,"is why it is often advantageous to enter something like"
"RTN","HLEVSRV4",33,0)
 W !,?POSX,"'DOE@BUFFALO' and also 'DOE@MED.VA.GOV'.  When a remote "
"RTN","HLEVSRV4",34,0)
 W !,?POSX,"request is received, as long as 'DOE' is in the sender's"
"RTN","HLEVSRV4",35,0)
 W !,?POSX,"name, and either 'BUFFALO' or 'MED.VA.GOV' is in the"
"RTN","HLEVSRV4",36,0)
 W !,?POSX,"address, it will be honored."
"RTN","HLEVSRV4",37,0)
 W !
"RTN","HLEVSRV4",38,0)
 ;
"RTN","HLEVSRV4",39,0)
 F  D  QUIT:USER']""
"RTN","HLEVSRV4",40,0)
 .  S USER=$$FT^HLEVSRV2("Enter REMOTE ADDRESS","","O")
"RTN","HLEVSRV4",41,0)
 .  I USER']""!(USER[U) S USER="" QUIT  ;->
"RTN","HLEVSRV4",42,0)
 .  I USER'?1.E1"@"1.E D  QUIT  ;->
"RTN","HLEVSRV4",43,0)
 .  .  W !!,?5,"No action taken! (Use 'NAME@ADDRESS' format.)"
"RTN","HLEVSRV4",44,0)
 .  .  W !
"RTN","HLEVSRV4",45,0)
 .  S USER=$$UP^XLFSTR(USER)
"RTN","HLEVSRV4",46,0)
 .  I $D(^XTMP(XTMP,"USER",USER)) D  QUIT  ;->
"RTN","HLEVSRV4",47,0)
 .  .  KILL ^XTMP(XTMP,"USER",USER)
"RTN","HLEVSRV4",48,0)
 .  .  W "  removed..."
"RTN","HLEVSRV4",49,0)
 .  S ^XTMP(XTMP,"USER",USER)=$$NOW^XLFDT_U_$G(DUZ)
"RTN","HLEVSRV4",50,0)
 .  W "  added..."
"RTN","HLEVSRV4",51,0)
 Q
"RTN","HLEVSRV4",52,0)
 ;
"RTN","HLEVSRV4",53,0)
LICNEW ; Create new license...  (Creates CODE,CODEXP,EXPNOW)
"RTN","HLEVSRV4",54,0)
 ;
"RTN","HLEVSRV4",55,0)
 I $G(^XTMP(XTMP,"CODE"))]"" D  I '$$YN^HLCSRPT4("Continue","No") W "  no action taken..." QUIT  ;->
"RTN","HLEVSRV4",56,0)
 .  W !!,IOINHI,"Warning!!",IOINORM
"RTN","HLEVSRV4",57,0)
 .  W "  The current license, along with all licensed requesters, will"
"RTN","HLEVSRV4",58,0)
 .  W "                   be deleted if you continue."
"RTN","HLEVSRV4",59,0)
 .  W !
"RTN","HLEVSRV4",60,0)
 ;
"RTN","HLEVSRV4",61,0)
 S (CODEXP,EXPNOW)="",CODE=$$CODE^HLEVSRV3
"RTN","HLEVSRV4",62,0)
 W !!,"License '",IOINHI,CODE,IOINORM,"' will be used after you enter cutoff date..."
"RTN","HLEVSRV4",63,0)
 W !!,"Defaulting 'NOW + 7 days' below..."
"RTN","HLEVSRV4",64,0)
 W !
"RTN","HLEVSRV4",65,0)
 S CODEXP=$$ASKDATE^HLEVAPI2("Enter CUTOFF DATE","EXT",$P($$FMTE^XLFDT(+$$FMADD^XLFDT($$NOW^XLFDT,7)),":",1,2))
"RTN","HLEVSRV4",66,0)
 I CODEXP'?7N1"."1.N S (CODE,CODEXP,EXPNOW)="" QUIT  ;->
"RTN","HLEVSRV4",67,0)
 ; Accept any date.  For user will have opportunity to change later.
"RTN","HLEVSRV4",68,0)
 S EXPNOW=$S(CODEXP<NOW:1,1:0) ; Is license expired?
"RTN","HLEVSRV4",69,0)
 D SETLIC^HLEVSRV3(CODEXP_U_CODE)
"RTN","HLEVSRV4",70,0)
 ;
"RTN","HLEVSRV4",71,0)
 Q
"RTN","HLEVSRV4",72,0)
 ;
"RTN","HLEVSRV4",73,0)
LICAN ; Cancel current license...
"RTN","HLEVSRV4",74,0)
 ; XTMP -- req
"RTN","HLEVSRV4",75,0)
 ;
"RTN","HLEVSRV4",76,0)
 ; If no license exists...
"RTN","HLEVSRV4",77,0)
 I '$D(^XTMP(XTMP)) D  QUIT  ;->
"RTN","HLEVSRV4",78,0)
 .  W !,"No license exists..."
"RTN","HLEVSRV4",79,0)
 ;
"RTN","HLEVSRV4",80,0)
 W !!,"If you cancel license, the code and all requesters will be removed!"
"RTN","HLEVSRV4",81,0)
 W !
"RTN","HLEVSRV4",82,0)
 I '$$YN^HLCSRPT4("OK to cancel license","No") D  QUIT  ;->
"RTN","HLEVSRV4",83,0)
 .  W "  no action taken..."
"RTN","HLEVSRV4",84,0)
 ;
"RTN","HLEVSRV4",85,0)
 KILL ^XTMP(XTMP)
"RTN","HLEVSRV4",86,0)
 W "  license canceled..."
"RTN","HLEVSRV4",87,0)
 S (CODE,CODEXP,EXPNOW)=""
"RTN","HLEVSRV4",88,0)
 ;
"RTN","HLEVSRV4",89,0)
 Q
"RTN","HLEVSRV4",90,0)
 ;
"RTN","HLEVSRV4",91,0)
CHKLIC(CODEXM,FROM) ; Called by server action to see if passed in license
"RTN","HLEVSRV4",92,0)
 ; matches current license.  If so, data will be returned to
"RTN","HLEVSRV4",93,0)
 ; requester.  If not, a refusal email will be returned to XMFROM.
"RTN","HLEVSRV4",94,0)
 N OXMZ,OXTMP
"RTN","HLEVSRV4",95,0)
 ;
"RTN","HLEVSRV4",96,0)
 S OXMZ=$G(XMZ),OXTMP=$G(XTMP)
"RTN","HLEVSRV4",97,0)
 ;
"RTN","HLEVSRV4",98,0)
 N CODE,CUT,NOW,XTMP
"RTN","HLEVSRV4",99,0)
 ;
"RTN","HLEVSRV4",100,0)
 S XTMP="HLEV REMOTE LICENSE",NOW=$$NOW^XLFDT
"RTN","HLEVSRV4",101,0)
 S CODE=$G(^XTMP(XTMP,"CODE")),CUT=+CODE,CODE=$P(CODE,U,2,999)
"RTN","HLEVSRV4",102,0)
 ;
"RTN","HLEVSRV4",103,0)
 ; If no requester known...
"RTN","HLEVSRV4",104,0)
 I $G(XMFROM)']"" D  QUIT  ;->
"RTN","HLEVSRV4",105,0)
 .  D REFUSE("requester unknown.")
"RTN","HLEVSRV4",106,0)
 ;
"RTN","HLEVSRV4",107,0)
 ; If no code exists...
"RTN","HLEVSRV4",108,0)
 I CODE']"" D   QUIT  ;->
"RTN","HLEVSRV4",109,0)
 .  D REFUSE("no license exists.")
"RTN","HLEVSRV4",110,0)
 ;
"RTN","HLEVSRV4",111,0)
 ; License has expired...
"RTN","HLEVSRV4",112,0)
 I CUT<NOW D REFUSE("the current license has expired.") QUIT  ;->
"RTN","HLEVSRV4",113,0)
 ;
"RTN","HLEVSRV4",114,0)
 ; Incorrect code sent by remote requester...
"RTN","HLEVSRV4",115,0)
 I CODEXM'=CODE D REFUSE("incorrect code received.") QUIT  ;->
"RTN","HLEVSRV4",116,0)
 ;
"RTN","HLEVSRV4",117,0)
 ; Is remote requester licensed?
"RTN","HLEVSRV4",118,0)
 I '$$LICENSED($G(XMFROM)) D  QUIT  ;->
"RTN","HLEVSRV4",119,0)
 .  D REFUSE("Requester is not licensed.")
"RTN","HLEVSRV4",120,0)
 ;
"RTN","HLEVSRV4",121,0)
 ; Set XMY so report returned to remote requester...
"RTN","HLEVSRV4",122,0)
 I $G(XMFROM)]"" S XMY(XMFROM)=""
"RTN","HLEVSRV4",123,0)
 ;
"RTN","HLEVSRV4",124,0)
 D RECXTMP("Request# "_XMZ_" from "_$G(XMFROM)_" honored. ["_OXTMP_"]")
"RTN","HLEVSRV4",125,0)
 ;
"RTN","HLEVSRV4",126,0)
 Q
"RTN","HLEVSRV4",127,0)
 ;
"RTN","HLEVSRV4",128,0)
LICENSED(FROM) ; Is requester licensed?
"RTN","HLEVSRV4",129,0)
 N OK,USER
"RTN","HLEVSRV4",130,0)
 S FROM=$$UP^XLFSTR(FROM)
"RTN","HLEVSRV4",131,0)
 S ADDR=$P(FROM,"@",2) QUIT:ADDR']"" "" ;->
"RTN","HLEVSRV4",132,0)
 S FROM=$P(FROM,"@") QUIT:FROM']"" "" ;->
"RTN","HLEVSRV4",133,0)
 S OK=0,USER=""
"RTN","HLEVSRV4",134,0)
 F  S USER=$O(^XTMP(XTMP,"USER",USER)) Q:USER']""!(OK)  D
"RTN","HLEVSRV4",135,0)
 .  S FROM(1)=$P(USER,"@"),ADDR(1)=$P(USER,"@",2)
"RTN","HLEVSRV4",136,0)
 .  QUIT:FROM'[FROM(1)  ;-> License NAME not in XMFROM
"RTN","HLEVSRV4",137,0)
 .  QUIT:ADDR'[ADDR(1)  ;-> License ADDR not in XMFROM
"RTN","HLEVSRV4",138,0)
 .  S OK=1
"RTN","HLEVSRV4",139,0)
 Q $S(OK:1,1:"")
"RTN","HLEVSRV4",140,0)
 ;
"RTN","HLEVSRV4",141,0)
REFUSE(REA) ; Send refusal email back to remote requester...
"RTN","HLEVSRV4",142,0)
 ; XMFROM,XTMP -- req
"RTN","HLEVSRV4",143,0)
 N HOLD,NO,TEXT,XMDUZ,XMSUB,XMTEXT
"RTN","HLEVSRV4",144,0)
 ;
"RTN","HLEVSRV4",145,0)
 D RECXTMP("Refused ("_REA_")  Request# "_$G(XMZ)_"  from "_$G(XMFROM))
"RTN","HLEVSRV4",146,0)
 ;
"RTN","HLEVSRV4",147,0)
 N XMZ
"RTN","HLEVSRV4",148,0)
 S XMDUZ=.5,XMSUB="HL7 Remote Request Refusal: "_$G(XMFROM)
"RTN","HLEVSRV4",149,0)
 S XMTEXT="HOLD("
"RTN","HLEVSRV4",150,0)
 ;
"RTN","HLEVSRV4",151,0)
 D MAILADD("The following remote request for VistA HL7 data has been refused.")
"RTN","HLEVSRV4",152,0)
 D MAILADD("Details are included below."),MAILADD("")
"RTN","HLEVSRV4",153,0)
 D MAILADD("              Requester: "_$G(XMFROM))
"RTN","HLEVSRV4",154,0)
 D MAILADD("               Message#: "_$G(OXMZ))
"RTN","HLEVSRV4",155,0)
 D MAILADD("                 Reason: "_REA)
"RTN","HLEVSRV4",156,0)
 ;
"RTN","HLEVSRV4",157,0)
 S XMY("HL7SystemMonitoring@med.va.gov")=""
"RTN","HLEVSRV4",158,0)
 I $G(XMFROM)]"" S XMY(XMFROM)=""
"RTN","HLEVSRV4",159,0)
 ;
"RTN","HLEVSRV4",160,0)
 D ^XMD
"RTN","HLEVSRV4",161,0)
 ;
"RTN","HLEVSRV4",162,0)
 QUIT
"RTN","HLEVSRV4",163,0)
 ;
"RTN","HLEVSRV4",164,0)
MAILADD(T) S NO=$O(HOLD(":"),-1)+1,HOLD(NO)=T
"RTN","HLEVSRV4",165,0)
 Q
"RTN","HLEVSRV4",166,0)
 ;
"RTN","HLEVSRV4",167,0)
RECXTMP(TXT) ; Record in ^XTMP for remote requests...
"RTN","HLEVSRV4",168,0)
 ; XTMP -- req
"RTN","HLEVSRV4",169,0)
 S NO=$O(^XTMP(XTMP,"REQ",":"),-1)+1
"RTN","HLEVSRV4",170,0)
 S ^XTMP(XTMP,"REQ",+NO)=TXT
"RTN","HLEVSRV4",171,0)
 Q
"RTN","HLEVSRV4",172,0)
 ;
"RTN","HLEVSRV4",173,0)
EOR ;HLEVSRV4 - Event Monitor SERVER ;5/16/03 14:42
"RTN","HLEVSTUP")
0^13^B71803231
"RTN","HLEVSTUP",1,0)
HLEVSTUP ;O-OIFO/LJA - Event Monitor SETUP ;02/04/2004 14:42
"RTN","HLEVSTUP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVSTUP",3,0)
 ;
"RTN","HLEVSTUP",4,0)
E7761 ; Enter/Edit 776.1...
"RTN","HLEVSTUP",5,0)
 N DA,DIC,DIE,DR,IEN,X,Y
"RTN","HLEVSTUP",6,0)
 D HD,EX
"RTN","HLEVSTUP",7,0)
 F  D  QUIT:IEN'>0
"RTN","HLEVSTUP",8,0)
 .  W !
"RTN","HLEVSTUP",9,0)
 .  S IEN=$$ASKIEN^HLEVREP(776.1,"L") QUIT:'IEN  ;->
"RTN","HLEVSTUP",10,0)
 .  W !!,$$CJ^XLFSTR("---------------- editing entry ----------------",IOM)
"RTN","HLEVSTUP",11,0)
 .  W !
"RTN","HLEVSTUP",12,0)
 .  D EDIT(776.1,IEN,"[HLEV MONITOR ENTER/EDIT]")
"RTN","HLEVSTUP",13,0)
 .  W !
"RTN","HLEVSTUP",14,0)
 .  D ASKRUN^HLEVAPI1(+IEN)
"RTN","HLEVSTUP",15,0)
 .  D HD,EX
"RTN","HLEVSTUP",16,0)
 Q
"RTN","HLEVSTUP",17,0)
 ;
"RTN","HLEVSTUP",18,0)
E7769 ; Edit 776.999...
"RTN","HLEVSTUP",19,0)
 N DA,DIC,DIE,DR,IEN,X,Y
"RTN","HLEVSTUP",20,0)
 W @IOF
"RTN","HLEVSTUP",21,0)
 D EDIT(776.999,1,"[HLEV MASTER JOB ENTER/EDIT]")
"RTN","HLEVSTUP",22,0)
 W !
"RTN","HLEVSTUP",23,0)
 S X=$$BTE^HLCSMON("Press RETURN to exit... ")
"RTN","HLEVSTUP",24,0)
 Q
"RTN","HLEVSTUP",25,0)
 ;
"RTN","HLEVSTUP",26,0)
EDIT(FILE,IEN,DR) ; Edit entry...
"RTN","HLEVSTUP",27,0)
 N DA,DIE
"RTN","HLEVSTUP",28,0)
 S DA=+IEN,DIE=FILE
"RTN","HLEVSTUP",29,0)
 D ^DIE
"RTN","HLEVSTUP",30,0)
 Q
"RTN","HLEVSTUP",31,0)
 ;
"RTN","HLEVSTUP",32,0)
HD W @IOF,$$CJ^XLFSTR("Event Monitoring System Enter/Edit",IOM)
"RTN","HLEVSTUP",33,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVSTUP",34,0)
 QUIT
"RTN","HLEVSTUP",35,0)
 ;
"RTN","HLEVSTUP",36,0)
EX N I,T F I=1:1 S T=$T(EX+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVSTUP",37,0)
 ;;You may now enter new entries, and edit existing entries.  Enter a new entry
"RTN","HLEVSTUP",38,0)
 ;;now, or select the existing entry to be edited.
"RTN","HLEVSTUP",39,0)
 QUIT
"RTN","HLEVSTUP",40,0)
 ;
"RTN","HLEVSTUP",41,0)
HELP(FILE,FLD) D HELPM
"RTN","HLEVSTUP",42,0)
 ;;776.1^2^HD^STATUS (#2)
"RTN","HLEVSTUP",43,0)
 ;;776.1^2^TX^Enter ACTIVE to make this event monitor "available" to the master job for
"RTN","HLEVSTUP",44,0)
 ;;776.1^2^TX^queuing.  When set to ACTIVE the master job will run this event monitor
"RTN","HLEVSTUP",45,0)
 ;;776.1^2^TX^according to the REQUEUE FREQUENCY (that you will be asked several prompts
"RTN","HLEVSTUP",46,0)
 ;;776.1^2^TX^from now.)
"RTN","HLEVSTUP",47,0)
 ;;776.1^2^TX^
"RTN","HLEVSTUP",48,0)
 ;;776.1^2^TX^NOTE:  If you're entering this event monitor for the first time, you should
"RTN","HLEVSTUP",49,0)
 ;;776.1^2^TX^       set this field to INACTIVE until all fields have been filled in.  Then,
"RTN","HLEVSTUP",50,0)
 ;;776.1^2^TX^       change this field back to ACTIVE.^1
"RTN","HLEVSTUP",51,0)
 ;;
"RTN","HLEVSTUP",52,0)
 ;;776.1^3^HD^SHORT DESCRIPTION (#3)
"RTN","HLEVSTUP",53,0)
 ;;776.1^3^TX^Enter a short description for this event monitor; something that is more
"RTN","HLEVSTUP",54,0)
 ;;776.1^3^TX^complete and descriptive than the NAME.^1
"RTN","HLEVSTUP",55,0)
 ;;
"RTN","HLEVSTUP",56,0)
 ;;776.1^4^HD^REQUEUE FREQUENCY (#4)
"RTN","HLEVSTUP",57,0)
 ;;776.1^4^TX^The master job will run this event monitor as often as you specify.  And, this
"RTN","HLEVSTUP",58,0)
 ;;776.1^4^TX^field is the way you specify rerun frequency.  Enter the number of minutes
"RTN","HLEVSTUP",59,0)
 ;;776.1^4^TX^that should elapse after this event monitor runs until it is run again.
"RTN","HLEVSTUP",60,0)
 ;;776.1^4^TX
"RTN","HLEVSTUP",61,0)
 ;;776.1^4^TX^NOTE:  Enter '0' if you want this event to run every time the master job
"RTN","HLEVSTUP",62,0)
 ;;776.1^4^TX^       checks this monitor.^1
"RTN","HLEVSTUP",63,0)
 ;;
"RTN","HLEVSTUP",64,0)
 ;;776.1^5^HD^REMOTE REQUESTABLE
"RTN","HLEVSTUP",65,0)
 ;;776.1^5^TX^Some monitors can only be started locally at a site.  Some monitors can be
"RTN","HLEVSTUP",66,0)
 ;;776.1^5^TX^started locally, and also requested remotely.  (A remote request occurs when
"RTN","HLEVSTUP",67,0)
 ;;776.1^5^TX^someone at another site or location sends a Mailman message to your site - to
"RTN","HLEVSTUP",68,0)
 ;;776.1^5^TX^your site's HL7 Event Monitor's server option - requesting that the monitor be
"RTN","HLEVSTUP",69,0)
 ;;776.1^5^TX^run.)^1
"RTN","HLEVSTUP",70,0)
 ;;776.1^5^TX^WARNING!!  Does this monitor return a report to the requester containing
"RTN","HLEVSTUP",71,0)
 ;;776.1^5^TX^           sensitive information?  If so, you should not, under any 
"RTN","HLEVSTUP",72,0)
 ;;776.1^5^TX^           circumstances, set this field to YES.^1
"RTN","HLEVSTUP",73,0)
 ;;776.1^5^TX^Please specify now whether this monitor can be requested remotely.  Enter YES
"RTN","HLEVSTUP",74,0)
 ;;776.1^5^TX^to allow remote users to run this monitor.  Enter NO if remote requests should
"RTN","HLEVSTUP",75,0)
 ;;776.1^5^TX^ignored.^1
"RTN","HLEVSTUP",76,0)
 ;;
"RTN","HLEVSTUP",77,0)
 ;;776.1^6^HD^M STARTUP LOCATION
"RTN","HLEVSTUP",78,0)
 ;;776.1^6^TX^The master job uses this field to determine how to start this event monitor.
"RTN","HLEVSTUP",79,0)
 ;;776.1^6^TX^So, enter the M location (subroutine and routine) where the event
"RTN","HLEVSTUP",80,0)
 ;;776.1^6^TX^should be queued.  Enter it in the SUBROUTINE~ROUTINE format, substituting
"RTN","HLEVSTUP",81,0)
 ;;776.1^6^TX^a tilde (~) for the up-arrow.
"RTN","HLEVSTUP",82,0)
 ;;776.1^6^TX^
"RTN","HLEVSTUP",83,0)
 ;;776.1^6^TX^The M location you enter now is the location where queued jobs start.^1
"RTN","HLEVSTUP",84,0)
 ;;
"RTN","HLEVSTUP",85,0)
 ;;776.1^7^HD^M START CHECK (EXTRINSIC FUNCTION)
"RTN","HLEVSTUP",86,0)
 ;;776.1^7^TX^Normally, the master job uses the monitor's requeue frequency in order to
"RTN","HLEVSTUP",87,0)
 ;;776.1^7^TX^determine whether a new monitor job should be queued.  Alternately, you may
"RTN","HLEVSTUP",88,0)
 ;;776.1^7^TX^call an extrinsic function to determine whether a new monitor job should be
"RTN","HLEVSTUP",89,0)
 ;;776.1^7^TX^started.  Entry of the M check extrinsic function is optional.
"RTN","HLEVSTUP",90,0)
 ;;776.1^7^TX^
"RTN","HLEVSTUP",91,0)
 ;;776.1^7^TX^Extrinsic functions must follow these rules:
"RTN","HLEVSTUP",92,0)
 ;;776.1^7^TX^
"RTN","HLEVSTUP",93,0)
 ;;776.1^7^TX^ * Syntax = $$TAG~ROUTINE (where TAG and ROUTINE do not exceed 8 characters.)
"RTN","HLEVSTUP",94,0)
 ;;776.1^7^TX^ * $$TAG~ROUTINE returns a 1 or 0.  
"RTN","HLEVSTUP",95,0)
 ;;776.1^7^TX^
"RTN","HLEVSTUP",96,0)
 ;;776.1^7^TX^The extrinsic function should return '0' if a new monitor job should not be
"RTN","HLEVSTUP",97,0)
 ;;776.1^7^TX^started, or a '1' to start a new monitor job.^1
"RTN","HLEVSTUP",98,0)
 ;;
"RTN","HLEVSTUP",99,0)
 ;;776.1^41^HD^PARAMETER NOTES
"RTN","HLEVSTUP",100,0)
 ;;776.1^41^TX^Enter description and documentation of the just entered parameters.^1
"RTN","HLEVSTUP",101,0)
 ;;
"RTN","HLEVSTUP",102,0)
 ;;776.1^50^HD^EVENT MONITOR NOTES
"RTN","HLEVSTUP",103,0)
 ;;776.1^50^TX^Enter overall comments about this event monitor.^1
"RTN","HLEVSTUP",104,0)
 ;;
"RTN","HLEVSTUP",105,0)
 ;;776.1^51^HD^MAIL GROUPs, USERs, REMOTE USERs
"RTN","HLEVSTUP",106,0)
 ;;776.1^51^TX^Enter the mail groups and local users and remote users to which notification
"RTN","HLEVSTUP",107,0)
 ;;776.1^51^TX^messages are to be sent.  If no notification message will ever be sent, leave
"RTN","HLEVSTUP",108,0)
 ;;776.1^51^TX^these fields blank.^1
"RTN","HLEVSTUP",109,0)
 ;;
"RTN","HLEVSTUP",110,0)
 ;;=====================================================================
"RTN","HLEVSTUP",111,0)
 ;;776.999^.01^HD^MONITORING SYSTEM NAME
"RTN","HLEVSTUP",112,0)
 ;;776.999^.01^TX^You may change the name of the monitoring system if you like.  (But, it
"RTN","HLEVSTUP",113,0)
 ;;776.999^.01^TX^makes no difference to the monitoring system!)^1
"RTN","HLEVSTUP",114,0)
 ;;
"RTN","HLEVSTUP",115,0)
 ;;776.999^2^HD^MASTER JOB STATUS
"RTN","HLEVSTUP",116,0)
 ;;776.999^2^TX^Set this field to ACTIVE to enable the master job to run and monitor your
"RTN","HLEVSTUP",117,0)
 ;;776.999^2^TX^system.  (The master job is started and stopped using the 'Turn on/off
"RTN","HLEVSTUP",118,0)
 ;;776.999^2^TX^monitoring system [HLEV EDIT MASTER ON-OFF]' menu option.)  Set this field
"RTN","HLEVSTUP",119,0)
 ;;776.999^2^TX^to INACTIVE to stop the master job (if it is running), and to ensure that
"RTN","HLEVSTUP",120,0)
 ;;776.999^2^TX^the master job does not start^1
"RTN","HLEVSTUP",121,0)
 ;;
"RTN","HLEVSTUP",122,0)
 ;;776.999^3^HD^MASTER JOB INTERVAL (MINUTES)
"RTN","HLEVSTUP",123,0)
 ;;776.999^3^TX^The master job is started every MASTER JOB INTERVAL minutes to evaluate your
"RTN","HLEVSTUP",124,0)
 ;;776.999^3^TX^system.  Enter the number of minutes now that should elapse between every
"RTN","HLEVSTUP",125,0)
 ;;776.999^3^TX^"run" of the master job.^1
"RTN","HLEVSTUP",126,0)
 ;;
"RTN","HLEVSTUP",127,0)
 ;;776.999^4^HD^PURGE LIMIT FOR DATA
"RTN","HLEVSTUP",128,0)
 ;;776.999^4^TX^Whenever the master job runs, data is created in the HL7 Monitor Master Job
"RTN","HLEVSTUP",129,0)
 ;;776.999^4^TX^file (#776.2.)  Whenever the master job spawns off a new background job for
"RTN","HLEVSTUP",130,0)
 ;;776.999^4^TX^an event monitor, data is created in the HL7 Monitor Job file (#776.)  Purging
"RTN","HLEVSTUP",131,0)
 ;;776.999^4^TX^of this data occurs automatically.  This parameter controls how much data to
"RTN","HLEVSTUP",132,0)
 ;;776.999^4^TX^retain.  For example, if you enter '96' now, then no data less than 96 hours
"RTN","HLEVSTUP",133,0)
 ;;776.999^4^TX^old will be purged.^1
"RTN","HLEVSTUP",134,0)
 ;;
"RTN","HLEVSTUP",135,0)
 ;;776.999^6^TX^
"RTN","HLEVSTUP",136,0)
 ;;776.999^6^TX^
"RTN","HLEVSTUP",137,0)
 ;;776.999^6^TX^                        --- EVENT MONITORING FIELDS ---
"RTN","HLEVSTUP",138,0)
 ;;776.999^6^TX^
"RTN","HLEVSTUP",139,0)
 ;;776.999^6^HD^STATUS OF EVENT MONITORING
"RTN","HLEVSTUP",140,0)
 ;;776.999^6^TX^The master job periodically "fires off" event monitors.  If you set this field
"RTN","HLEVSTUP",141,0)
 ;;776.999^6^TX^to INACTIVE, the master job will continue to start and run, but no events
"RTN","HLEVSTUP",142,0)
 ;;776.999^6^TX^will be started.  When this field is set to ACTIVE, the master job will be
"RTN","HLEVSTUP",143,0)
 ;;776.999^6^TX^able to run event monitors.^1
"RTN","HLEVSTUP",144,0)
 ;
"RTN","HLEVSTUP",145,0)
 Q
"RTN","HLEVSTUP",146,0)
 ;
"RTN","HLEVSTUP",147,0)
HELPM ; Display of HELP logic...
"RTN","HLEVSTUP",148,0)
 N I,INFO,J,T,TYP
"RTN","HLEVSTUP",149,0)
 F I=1:1 S T=$T(HELP+I) Q:T'[";;"  D
"RTN","HLEVSTUP",150,0)
 .  S T=$P(T,";;",2,999)
"RTN","HLEVSTUP",151,0)
 . I +T=FILE,$P(T,U,2)=FLD D
"RTN","HLEVSTUP",152,0)
 .  .  S TYP=$P(T,U,3),INFO=$P(T,U,4)
"RTN","HLEVSTUP",153,0)
 .  .  W:TYP="HD" !!,$$CJ^XLFSTR(" "_INFO_" ",IOM,"=")
"RTN","HLEVSTUP",154,0)
 .  .  W:TYP="TX" !,INFO
"RTN","HLEVSTUP",155,0)
 .  .  W:TYP="FT" !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVSTUP",156,0)
 .  .  I $P(T,U,5)>0 F J=1:1:$P(T,U,5) W !
"RTN","HLEVSTUP",157,0)
 Q
"RTN","HLEVSTUP",158,0)
 ;
"RTN","HLEVSTUP",159,0)
IMPLEMNT ; Not yet implemented API...
"RTN","HLEVSTUP",160,0)
 N OPT
"RTN","HLEVSTUP",161,0)
 S OPT=$P($G(XQY0),U,2)_" ["_$P($G(XQY0),U)_"]"
"RTN","HLEVSTUP",162,0)
 W !!,$$CJ^XLFSTR("This '"_OPT_"' menu option",IOM)
"RTN","HLEVSTUP",163,0)
 W !,$$CJ^XLFSTR("is not yet implemented.",IOM)
"RTN","HLEVSTUP",164,0)
 W !
"RTN","HLEVSTUP",165,0)
 S X=$$BTE^HLCSMON("Press RETURN to return to menu...")
"RTN","HLEVSTUP",166,0)
 Q
"RTN","HLEVSTUP",167,0)
 ;
"RTN","HLEVSTUP",168,0)
EOR ;HLEVSTUP - Event Monitor SETUP ;5/16/03 14:42
"RTN","HLEVUTI0")
0^31^B63289609
"RTN","HLEVUTI0",1,0)
HLEVUTI0 ;O-OIFO/LJA - Event Monitor UTILITIES ;02/04/2004 14:42
"RTN","HLEVUTI0",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVUTI0",3,0)
 ;
"RTN","HLEVUTI0",4,0)
SENDATA ; Interactively asks for 772 entry and returns Mailman message...
"RTN","HLEVUTI0",5,0)
 ;
"RTN","HLEVUTI0",6,0)
 N CT,IEN,IEN772,RECIP,SCRN,TXT,X,XMDUZ,XMSUB,XMTEXT,XMY,Y
"RTN","HLEVUTI0",7,0)
 ;
"RTN","HLEVUTI0",8,0)
 D HDASK,EXASK
"RTN","HLEVUTI0",9,0)
 ;
"RTN","HLEVUTI0",10,0)
 S SCRN=0
"RTN","HLEVUTI0",11,0)
 ;
"RTN","HLEVUTI0",12,0)
 KILL ^TMP($J,"HLIEN"),^TMP($J,"HLMAIL")
"RTN","HLEVUTI0",13,0)
 ;
"RTN","HLEVUTI0",14,0)
S0 W !!,"The most recent 772 IEN is... ",$O(^HL(772,":"),-1)
"RTN","HLEVUTI0",15,0)
 W !
"RTN","HLEVUTI0",16,0)
 ;
"RTN","HLEVUTI0",17,0)
S1 F  D  I 'IEN772 Q:'$D(^TMP($J,"HLIEN"))  W ! S X=$$YN^HLCSRPT4("Stop entering 772 IENs") W:'X ! Q:X
"RTN","HLEVUTI0",18,0)
 .  S IEN772=$$ASK772 QUIT:IEN772'>0  ;->
"RTN","HLEVUTI0",19,0)
 .  S ^TMP($J,"HLIEN",+IEN772)=""
"RTN","HLEVUTI0",20,0)
 ;
"RTN","HLEVUTI0",21,0)
S2 I '$D(^TMP($J,"HLIEN")) D  QUIT  ;->
"RTN","HLEVUTI0",22,0)
 .  W "  no entries selected..."
"RTN","HLEVUTI0",23,0)
 ;
"RTN","HLEVUTI0",24,0)
S3 W !
"RTN","HLEVUTI0",25,0)
 F  D  I RECIP']"" W ! S X=$$YN^HLCSRPT4("Stop entering recipients") W:'X ! Q:X
"RTN","HLEVUTI0",26,0)
 .  S RECIP=$$FT("Enter RECIPIENT","O") QUIT:RECIP']""  ;->
"RTN","HLEVUTI0",27,0)
 .  S XMY(RECIP)=""
"RTN","HLEVUTI0",28,0)
 .  W "    added..."
"RTN","HLEVUTI0",29,0)
 ;
"RTN","HLEVUTI0",30,0)
S4 I '$D(XMY) D  I 'SCRN KILL ^TMP($J,"HLIEN") QUIT  ;->
"RTN","HLEVUTI0",31,0)
 .  W !!,"No recipients were entered.  You may just display the data on-screen."
"RTN","HLEVUTI0",32,0)
 .  W !
"RTN","HLEVUTI0",33,0)
 .  S SCRN=$$YN^HLCSRPT4("Display to screen","Yes")
"RTN","HLEVUTI0",34,0)
 ;
"RTN","HLEVUTI0",35,0)
S5 W !
"RTN","HLEVUTI0",36,0)
 I 'SCRN QUIT:$$BTE^HLCSMON("Press RETURN to send message, or '^' to exit... ")  ;->
"RTN","HLEVUTI0",37,0)
 ;
"RTN","HLEVUTI0",38,0)
 I SCRN W @IOF
"RTN","HLEVUTI0",39,0)
 ;
"RTN","HLEVUTI0",40,0)
 ; Collect data...
"RTN","HLEVUTI0",41,0)
S6 S IEN=0
"RTN","HLEVUTI0",42,0)
 F  S IEN=$O(^TMP($J,"HLIEN",IEN)) Q:'IEN  D
"RTN","HLEVUTI0",43,0)
 .  S IEN(1)=0,TXT="Requested 772#: "_IEN_"  ",CT=0
"RTN","HLEVUTI0",44,0)
 .  F  S IEN(1)=$O(^HLMA("B",+IEN,IEN(1))) Q:'IEN(1)  D
"RTN","HLEVUTI0",45,0)
 .  .  S ^TMP($J,"HLIEN",IEN,IEN(1))=""
"RTN","HLEVUTI0",46,0)
 .  .  S CT=CT+1
"RTN","HLEVUTI0",47,0)
 .  .  S TXT=TXT_$S(CT=1:"[773 #s: ",1:",")_IEN(1)
"RTN","HLEVUTI0",48,0)
 .  I CT>0 S TXT=TXT_"]"
"RTN","HLEVUTI0",49,0)
 .  D ADD(TXT)
"RTN","HLEVUTI0",50,0)
 ;
"RTN","HLEVUTI0",51,0)
S7 D ADD(""),ADD($$CJ^XLFSTR(" Requested Data ",74,"="))
"RTN","HLEVUTI0",52,0)
 S IEN=0
"RTN","HLEVUTI0",53,0)
 F  S IEN=$O(^TMP($J,"HLIEN",IEN)) Q:'IEN  D
"RTN","HLEVUTI0",54,0)
 .  D COLLECT^HLEVUTI1(IEN)
"RTN","HLEVUTI0",55,0)
 ;
"RTN","HLEVUTI0",56,0)
 I SCRN D  G SENDATA ;->
"RTN","HLEVUTI0",57,0)
 .  W !
"RTN","HLEVUTI0",58,0)
 .  S X=$$BTE^HLCSMON("Press RETURN to continue... ")
"RTN","HLEVUTI0",59,0)
 ;
"RTN","HLEVUTI0",60,0)
 ; Email message...
"RTN","HLEVUTI0",61,0)
 S XMTEXT="^TMP("_$J_",""HLMAIL"",",XMDUZ=DUZ
"RTN","HLEVUTI0",62,0)
 S X=$$SITE^VASITE,XMSUB="HL7 Data - "_$P(X,U,2)_" ["_$P(X,U,3)_"]"
"RTN","HLEVUTI0",63,0)
 ;
"RTN","HLEVUTI0",64,0)
S8 D ^XMD
"RTN","HLEVUTI0",65,0)
 ;
"RTN","HLEVUTI0",66,0)
S9 W "  ",$S($G(XMZ):" msg# "_XMZ_"...",1:"no msg sent...")
"RTN","HLEVUTI0",67,0)
 ;
"RTN","HLEVUTI0",68,0)
 KILL ^TMP($J,"HLIEN"),^TMP($J,"HLMAIL")
"RTN","HLEVUTI0",69,0)
 ;
"RTN","HLEVUTI0",70,0)
 Q
"RTN","HLEVUTI0",71,0)
 ;
"RTN","HLEVUTI0",72,0)
ADD(TXT) D ADD^HLEVUTI1(TXT)
"RTN","HLEVUTI0",73,0)
 Q
"RTN","HLEVUTI0",74,0)
 ;
"RTN","HLEVUTI0",75,0)
ASK772() ; Ask user for IENs...
"RTN","HLEVUTI0",76,0)
 N CT,I773,IEN,POSX
"RTN","HLEVUTI0",77,0)
ASK7721 S IEN=$$ASKNUM("Enter 772 IEN") QUIT:'IEN "" ;->
"RTN","HLEVUTI0",78,0)
 I $D(^HL(772,+IEN,0)),$O(^HLMA("B",IEN,0))>0 D
"RTN","HLEVUTI0",79,0)
 .  W:$X>55 ! W "    Adding 773s... "
"RTN","HLEVUTI0",80,0)
 .  S POSX=$X
"RTN","HLEVUTI0",81,0)
 .  S I773=0,CT=0
"RTN","HLEVUTI0",82,0)
 .  F  S I773=$O(^HLMA("B",+IEN,I773)) Q:'I773  D
"RTN","HLEVUTI0",83,0)
 .  .  S CT=CT+1
"RTN","HLEVUTI0",84,0)
 .  .  I ($X+$L(I773)+3)>IOM S CT=0 W !
"RTN","HLEVUTI0",85,0)
 .  .  W:$X<POSX ?POSX
"RTN","HLEVUTI0",86,0)
 .  .  W $S(CT>1:", ",1:"")
"RTN","HLEVUTI0",87,0)
 .  .  W I773
"RTN","HLEVUTI0",88,0)
 QUIT:$D(^HL(772,+IEN,0)) IEN ;->
"RTN","HLEVUTI0",89,0)
 W "  entry not found..."
"RTN","HLEVUTI0",90,0)
 G ASK7721 ;->
"RTN","HLEVUTI0",91,0)
 ;
"RTN","HLEVUTI0",92,0)
FT(PMT,WAY,DEF,LF) ; Free-text DIR request...
"RTN","HLEVUTI0",93,0)
 N DIR,DIRUT,DTOUT,DUOUT,I,X,Y
"RTN","HLEVUTI0",94,0)
 F I=1:1:$G(LF) Q:($Y+3)>IOSL  W !
"RTN","HLEVUTI0",95,0)
 S DIR(0)="F"_$G(WAY),DIR("A")=PMT
"RTN","HLEVUTI0",96,0)
 D ^DIR
"RTN","HLEVUTI0",97,0)
 QUIT:$D(DIRUT)!($D(DTOUT))!($D(DUOUT)) "" ;->
"RTN","HLEVUTI0",98,0)
 Q Y
"RTN","HLEVUTI0",99,0)
 ;
"RTN","HLEVUTI0",100,0)
ASKNUM(PMT,DEF) ; Ask user for a number via DIR...
"RTN","HLEVUTI0",101,0)
 N DIR,DIRUT,DTOUT,DUOUT,IEN,X,Y
"RTN","HLEVUTI0",102,0)
 S DIR(0)="NOA^1:999999999999999999",DIR("A")=PMT_": "
"RTN","HLEVUTI0",103,0)
 I $G(DEF)]"",DEF=+DEF S DIR("B")=DEF
"RTN","HLEVUTI0",104,0)
 D ^DIR
"RTN","HLEVUTI0",105,0)
 QUIT:$D(DIRUT)!($D(DTOUT))!($D(DUOUT)) "" ;->
"RTN","HLEVUTI0",106,0)
 I $L(Y,773)=3,$P(Y,773,2)>0 D  QUIT Y
"RTN","HLEVUTI0",107,0)
 .  S IEN=$P(Y,773,2) ; 773 ien...
"RTN","HLEVUTI0",108,0)
 .  S IEN=+$G(^HLMA(+IEN,0)) QUIT:'IEN  ;->
"RTN","HLEVUTI0",109,0)
 .  S Y=IEN
"RTN","HLEVUTI0",110,0)
 .  W "  selecting 772# ",IEN,"..."
"RTN","HLEVUTI0",111,0)
 Q +Y
"RTN","HLEVUTI0",112,0)
 ;
"RTN","HLEVUTI0",113,0)
HDASK W @IOF,$$CJ^XLFSTR("Send File 772 & 773 Data to Remote Recipient(s)",IOM)
"RTN","HLEVUTI0",114,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVUTI0",115,0)
 QUIT
"RTN","HLEVUTI0",116,0)
 ;
"RTN","HLEVUTI0",117,0)
EXASK N I,T F I=1:1 S T=$T(EXASK+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVUTI0",118,0)
 ;;This utility collects data from the HL Message Text file (#772) and the 
"RTN","HLEVUTI0",119,0)
 ;;HL Message Administration file (#773) and forwards the data to local and
"RTN","HLEVUTI0",120,0)
 ;;remote recipients.
"RTN","HLEVUTI0",121,0)
 ;;
"RTN","HLEVUTI0",122,0)
 ;;Before starting this utility you must know the file# 772 internal entry 
"RTN","HLEVUTI0",123,0)
 ;;number(s) (IEN).  When data is collected for file# 772 entries you have
"RTN","HLEVUTI0",124,0)
 ;;entered, any file# 773 data linked to the selected 772 entries will also be
"RTN","HLEVUTI0",125,0)
 ;;automatically collected and included in the transmitted message.
"RTN","HLEVUTI0",126,0)
 QUIT
"RTN","HLEVUTI0",127,0)
 ;
"RTN","HLEVUTI0",128,0)
GENREP(GBLS,GBLR,NOSUB,SEQ) ; Generic report generator...
"RTN","HLEVUTI0",129,0)
 ; GBLS = Global source...
"RTN","HLEVUTI0",130,0)
 ; GBLR = Global report location...
"RTN","HLEVUTI0",131,0)
 ; NOSUB = # subscript levels...
"RTN","HLEVUTI0",132,0)
 ; --- Must be 2 to 4
"RTN","HLEVUTI0",133,0)
 ; --- 1st subscript must be descriptive of problem, and <15 characters.
"RTN","HLEVUTI0",134,0)
 ;     It will be placed in a field of 15 characters.
"RTN","HLEVUTI0",135,0)
 ; --- 2nd subscript must be descriptive of entry, and <15 characters.
"RTN","HLEVUTI0",136,0)
 ;     It will be placed in a field of 15 characters.
"RTN","HLEVUTI0",137,0)
 ;     If the 2nd subscript is the last subscript, entries at this level
"RTN","HLEVUTI0",138,0)
 ;     will be concatenated.
"RTN","HLEVUTI0",139,0)
 ; --- Last subscript must identify entry, and will be concatenated.
"RTN","HLEVUTI0",140,0)
 ; (See RECORD^HLEVX000 for example of data creation.)
"RTN","HLEVUTI0",141,0)
 ; SEQ = Sequential & Numeric.  0/1
"RTN","HLEVUTI0",142,0)
 ; --- If the last subscript is required to be numeric and sequential,
"RTN","HLEVUTI0",143,0)
 ;     (like the 870 in and out queues), then combine iens into range
"RTN","HLEVUTI0",144,0)
 ;     statements... eg, 25123-25131(#9)
"RTN","HLEVUTI0",145,0)
 ;
"RTN","HLEVUTI0",146,0)
 ; Stop all event monitoring to enable on-site debugging...
"RTN","HLEVUTI0",147,0)
 QUIT:$G(^TMP("HLEVFLAG",$J))["STOP"  ;->
"RTN","HLEVUTI0",148,0)
 ;
"RTN","HLEVUTI0",149,0)
 S SEQ=+$G(SEQ)
"RTN","HLEVUTI0",150,0)
 ;
"RTN","HLEVUTI0",151,0)
 ; Make sure you don't return "leftovers" from before...
"RTN","HLEVUTI0",152,0)
 KILL @GBLR
"RTN","HLEVUTI0",153,0)
 ;
"RTN","HLEVUTI0",154,0)
 ; Checks...
"RTN","HLEVUTI0",155,0)
 QUIT:'$D(@GBLS)!($G(NOSUB)'>1)  ;->
"RTN","HLEVUTI0",156,0)
 ;
"RTN","HLEVUTI0",157,0)
 ; Create header...
"RTN","HLEVUTI0",158,0)
 S TXT="List of problems" D STORE(0)
"RTN","HLEVUTI0",159,0)
 S TXT=$$REPEAT^XLFSTR("-",74) D STORE(0)
"RTN","HLEVUTI0",160,0)
 S TXT=""
"RTN","HLEVUTI0",161,0)
 ;
"RTN","HLEVUTI0",162,0)
 ; Setup & looping...
"RTN","HLEVUTI0",163,0)
 S PROBL="",TXT="",PNO=0
"RTN","HLEVUTI0",164,0)
 F  S PROBL=$O(@GBLS@(PROBL)) Q:PROBL']""  D
"RTN","HLEVUTI0",165,0)
 .  S PNO=PNO+1
"RTN","HLEVUTI0",166,0)
 .  S TXT=$E(PROBL_$$REPEAT^XLFSTR(" ",15),1,15)
"RTN","HLEVUTI0",167,0)
 .  S SUB2=""
"RTN","HLEVUTI0",168,0)
 .  F  S SUB2=$O(@GBLS@(PROBL,SUB2)) Q:SUB2']""  D
"RTN","HLEVUTI0",169,0)
 .  .  I NOSUB=2 D CONCAT($$SUBSTORE(PROBL,SUB2),15) QUIT  ;->
"RTN","HLEVUTI0",170,0)
 .  .  S TXT=$E($E(TXT,1,15)_$E(SUB2,1,15)_$$REPEAT^XLFSTR(" ",30),1,30)
"RTN","HLEVUTI0",171,0)
 .  .  I SEQ,NOSUB=3 D CONDENSE(PROBL,SUB2)
"RTN","HLEVUTI0",172,0)
 .  .  S SUB3=""
"RTN","HLEVUTI0",173,0)
 .  .  F  S SUB3=$O(@GBLS@(PROBL,SUB2,SUB3)) Q:SUB3']""  D
"RTN","HLEVUTI0",174,0)
 .  .  .  I NOSUB=3 D CONCAT($$SUBSTORE(PROBL,SUB2,SUB3),30) QUIT  ;->
"RTN","HLEVUTI0",175,0)
 .  .  .  S TXT=$E($E(TXT,1,30)_$E(SUB3,1,30)_$$REPEAT^XLFSTR(" ",45),1,45)
"RTN","HLEVUTI0",176,0)
 .  .  .  X "F I=$L(TXT):-1:1 Q:$E(TXT,I)'="" """ S POSX=I+2
"RTN","HLEVUTI0",177,0)
 .  .  .  S TXT=$E(TXT_$$REPEAT^XLFSTR(" ",45),1,POSX)
"RTN","HLEVUTI0",178,0)
 .  .  .  I SEQ,NOSUB=4 D CONDENSE(PROBL,SUB2,SUB3)
"RTN","HLEVUTI0",179,0)
 .  .  .  S SUB4=""
"RTN","HLEVUTI0",180,0)
 .  .  .  F  S SUB4=$O(@GBLS@(PROBL,SUB2,SUB3,SUB4)) Q:SUB4']""  D
"RTN","HLEVUTI0",181,0)
 .  .  .  .  D CONCAT($$SUBSTORE(PROBL,SUB2,SUB3,SUB4),POSX)
"RTN","HLEVUTI0",182,0)
 .  .  .  .  ;Subscript limit!
"RTN","HLEVUTI0",183,0)
 .  .  .  I TXT]"" D STORE(POSX)
"RTN","HLEVUTI0",184,0)
 .  .  I TXT]"" D STORE(30)
"RTN","HLEVUTI0",185,0)
 .  I TXT]"" D STORE(15)
"RTN","HLEVUTI0",186,0)
 I TXT D STORE(0)
"RTN","HLEVUTI0",187,0)
 ;
"RTN","HLEVUTI0",188,0)
 S TXT="" D STORE(0)
"RTN","HLEVUTI0",189,0)
 S TXT="Problem          totals" D STORE(0)
"RTN","HLEVUTI0",190,0)
 S TXT=$$REPEAT^XLFSTR("-",74) D STORE(0)
"RTN","HLEVUTI0",191,0)
 ;
"RTN","HLEVUTI0",192,0)
 S PROBL=""
"RTN","HLEVUTI0",193,0)
 F  S PROBL=$O(@GBLS@(PROBL)) Q:PROBL']""  D
"RTN","HLEVUTI0",194,0)
 .  S NUM=$G(@GBLS@(PROBL)) Q:NUM']""  ;->
"RTN","HLEVUTI0",195,0)
 .  S TXT=$E(PROBL_$$REPEAT^XLFSTR(" ",15),1,15)_"  #"_NUM
"RTN","HLEVUTI0",196,0)
 .  D STORE(30)
"RTN","HLEVUTI0",197,0)
 ;
"RTN","HLEVUTI0",198,0)
 Q
"RTN","HLEVUTI0",199,0)
 ;
"RTN","HLEVUTI0",200,0)
SUBSTORE(S1,S2,S3,S4) ; Should subscript be stored, or condensed value?
"RTN","HLEVUTI0",201,0)
 ; GBLS -- req
"RTN","HLEVUTI0",202,0)
 N VAL
"RTN","HLEVUTI0",203,0)
 ;
"RTN","HLEVUTI0",204,0)
 I $G(S4)]"" D  QUIT S4 ;->
"RTN","HLEVUTI0",205,0)
 .  S VAL=$G(@GBLS@(S1,S2,S3,S4)) QUIT:VAL']""  ;->
"RTN","HLEVUTI0",206,0)
 .  S S4=VAL
"RTN","HLEVUTI0",207,0)
 ;
"RTN","HLEVUTI0",208,0)
 I $G(S3)]"" D  QUIT S3 ;->
"RTN","HLEVUTI0",209,0)
 .  S VAL=$G(@GBLS@(S1,S2,S3)) QUIT:VAL']""  ;->
"RTN","HLEVUTI0",210,0)
 .  S S3=VAL
"RTN","HLEVUTI0",211,0)
 ;
"RTN","HLEVUTI0",212,0)
 I $G(S2)]"" D  QUIT S2 ;->
"RTN","HLEVUTI0",213,0)
 .  S VAL=$G(@GBLS@(S1,S2)) QUIT:VAL']""  ;->
"RTN","HLEVUTI0",214,0)
 .  S S2=VAL
"RTN","HLEVUTI0",215,0)
 ;
"RTN","HLEVUTI0",216,0)
 Q S2
"RTN","HLEVUTI0",217,0)
 ;
"RTN","HLEVUTI0",218,0)
CONDENSE(PROBL,SUB2,SUB3) ; Condense sequential numerics...
"RTN","HLEVUTI0",219,0)
 N DIFF,FIRST,GBL,IEN,LAST,NO
"RTN","HLEVUTI0",220,0)
 ;
"RTN","HLEVUTI0",221,0)
 I $G(SUB3)']"" S GBL=$$COND2GBL(PROBL,SUB2)
"RTN","HLEVUTI0",222,0)
 I $G(SUB3)]"" S GBL=$$COND3GBL(PROBL,SUB2,SUB3)
"RTN","HLEVUTI0",223,0)
 ;
"RTN","HLEVUTI0",224,0)
 S (FIRST,LAST)=$O(@GBL@(0)) Q:LAST'>0  ;->
"RTN","HLEVUTI0",225,0)
 S IEN=0
"RTN","HLEVUTI0",226,0)
 F  S IEN=$O(@GBL@(IEN)) Q:'IEN  D
"RTN","HLEVUTI0",227,0)
 .
"RTN","HLEVUTI0",228,0)
 .  QUIT:IEN=LAST  ;-> Must be first $O...
"RTN","HLEVUTI0",229,0)
 .
"RTN","HLEVUTI0",230,0)
 .  ; If IEN isn't one more than the last IEN, seq string broken
"RTN","HLEVUTI0",231,0)
 .  I IEN'=(LAST+1) D SEQBR
"RTN","HLEVUTI0",232,0)
 .
"RTN","HLEVUTI0",233,0)
 .  ; Record the last IEN found...
"RTN","HLEVUTI0",234,0)
 .  S LAST=IEN
"RTN","HLEVUTI0",235,0)
 ;
"RTN","HLEVUTI0",236,0)
 ; If the last entry is not one more # than the first entry...
"RTN","HLEVUTI0",237,0)
 I LAST'=(FIRST+1) D SEQBR
"RTN","HLEVUTI0",238,0)
 ;
"RTN","HLEVUTI0",239,0)
 Q
"RTN","HLEVUTI0",240,0)
 ;
"RTN","HLEVUTI0",241,0)
SEQBR ; Sequence BRoken actions...
"RTN","HLEVUTI0",242,0)
 ; FIRST,GBL,IEN,LAST -- req --> FIRST,@GBL[S] (reset)
"RTN","HLEVUTI0",243,0)
 N DIFF,VAL
"RTN","HLEVUTI0",244,0)
 S DIFF=LAST-FIRST+1 ; # IENs difference...
"RTN","HLEVUTI0",245,0)
 S VAL=FIRST_":"_LAST_"(#"_DIFF_")"
"RTN","HLEVUTI0",246,0)
 I (($L(LAST)*DIFF)+(DIFF))<$L(VAL) D  QUIT  ;-> No space savings
"RTN","HLEVUTI0",247,0)
 .  S FIRST=IEN
"RTN","HLEVUTI0",248,0)
 S @GBL@(FIRST)=VAL
"RTN","HLEVUTI0",249,0)
 F NO=FIRST+1:1:LAST KILL @GBL@(NO)
"RTN","HLEVUTI0",250,0)
 S FIRST=IEN
"RTN","HLEVUTI0",251,0)
 Q
"RTN","HLEVUTI0",252,0)
 ;
"RTN","HLEVUTI0",253,0)
COND2GBL(PROBL,SUB2) ; Return global for NOSUB=2 looping...
"RTN","HLEVUTI0",254,0)
 ; GBLS -- req
"RTN","HLEVUTI0",255,0)
 N GBL
"RTN","HLEVUTI0",256,0)
 S GBL=$E(GBLS,1,$L(GBLS)-1)_","_$$AQ(PROBL)_","_$$AQ(SUB2)_")"
"RTN","HLEVUTI0",257,0)
 Q GBL
"RTN","HLEVUTI0",258,0)
 ;
"RTN","HLEVUTI0",259,0)
COND3GBL(PROBL,SUB2,SUB3) ; Return global for NOSUM=3 looping...
"RTN","HLEVUTI0",260,0)
 ; GBLS -- req
"RTN","HLEVUTI0",261,0)
 N GBL
"RTN","HLEVUTI0",262,0)
 S GBL=$E(GBLS,1,$L(GBLS)-1)_","_$$AQ(PROBL)_","_$$AQ(SUB2)_","_$$AQ(SUB3)_")"
"RTN","HLEVUTI0",263,0)
 Q GBL
"RTN","HLEVUTI0",264,0)
 ;
"RTN","HLEVUTI0",265,0)
AQ(VAL) ; Add quotes around non-numeric values...
"RTN","HLEVUTI0",266,0)
 QUIT:VAL=+VAL VAL ;-> Numeric...
"RTN","HLEVUTI0",267,0)
 QUIT """"_VAL_""""
"RTN","HLEVUTI0",268,0)
 ;
"RTN","HLEVUTI0",269,0)
CONCAT(VAL,PAD) ; Concatenate, separated w/commas, the VALs
"RTN","HLEVUTI0",270,0)
 ; TXT -- req
"RTN","HLEVUTI0",271,0)
 I ($L(TXT)+$L(VAL)+1)>74 D STORE(PAD)
"RTN","HLEVUTI0",272,0)
 S TXT=TXT_$S($L(TXT)>PAD:",",1:"")_VAL
"RTN","HLEVUTI0",273,0)
 Q
"RTN","HLEVUTI0",274,0)
 ;
"RTN","HLEVUTI0",275,0)
STORE(PAD) ; Store data in @GBLR@ in report-ready format
"RTN","HLEVUTI0",276,0)
 ; GBLR,TXT -- req
"RTN","HLEVUTI0",277,0)
 N NO
"RTN","HLEVUTI0",278,0)
 S NO=$O(@GBLR@(":"),-1)+1
"RTN","HLEVUTI0",279,0)
 S @GBLR@(+NO)=TXT
"RTN","HLEVUTI0",280,0)
 S TXT=$$REPEAT^XLFSTR(" ",PAD)
"RTN","HLEVUTI0",281,0)
 Q
"RTN","HLEVUTI0",282,0)
 ;
"RTN","HLEVUTI0",283,0)
EOR ;HLEVUTI0 - Event Monitor UTILITIES ;5/16/03 14:42
"RTN","HLEVUTI1")
0^33^B73186022
"RTN","HLEVUTI1",1,0)
HLEVUTI1 ;OIFO-O/LJA - Event Monitor UTILITIES ;02/04/2004 14:42
"RTN","HLEVUTI1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVUTI1",3,0)
 ;;
"RTN","HLEVUTI1",4,0)
 ;
"RTN","HLEVUTI1",5,0)
 ; Utility to aid in displaying 870 data...
"RTN","HLEVUTI1",6,0)
 ;
"RTN","HLEVUTI1",7,0)
CTRL ;
"RTN","HLEVUTI1",8,0)
 N ABRT,CT,CONT,DATA,DATE,DIC,GBL,HD,IOINHI,IOINORM,L870,LAST
"RTN","HLEVUTI1",9,0)
 N LNM,LNO,LNS,N,NO,NODE,TOT,TXT,WAY,WHAT,X,Y
"RTN","HLEVUTI1",10,0)
 ;
"RTN","HLEVUTI1",11,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLEVUTI1",12,0)
CTRL0 W @IOF,$$CJ^XLFSTR("Logical Link Display",IOM),!,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVUTI1",13,0)
 D QUEUES
"RTN","HLEVUTI1",14,0)
 W ! S L870=$$LINK Q:'L870
"RTN","HLEVUTI1",15,0)
 S GBL="^HLCS(870,"_L870_")"
"RTN","HLEVUTI1",16,0)
 S LNM=$$LNM(L870)
"RTN","HLEVUTI1",17,0)
 W "       ",LNM
"RTN","HLEVUTI1",18,0)
CTRL1 D SHOWHD(LNM,L870)
"RTN","HLEVUTI1",19,0)
 W !!,"What information for IN and OUT QUEUEs do you want to see?"
"RTN","HLEVUTI1",20,0)
 W !!,"1  Show IENs",!,"2  Show Summary nodes",!,"3  Totals",!,"4  Dots",!,"5  Find skips",!,"6  Message date search"
"RTN","HLEVUTI1",21,0)
 R !!,"Enter #: ",WHAT:99 G:WHAT<1!(WHAT>6) CTRL0 ;->
"RTN","HLEVUTI1",22,0)
 W !!,$$CJ^XLFSTR(" "_IOINHI_LNM_IOINORM_" ",IOM+$L(IOINHI)+$L(IOINORM),"=")
"RTN","HLEVUTI1",23,0)
 S ABRT=0,CONT=0,CT=0
"RTN","HLEVUTI1",24,0)
 S WAY=$$ASKWAY QUIT:WAY[U  ;->
"RTN","HLEVUTI1",25,0)
 S NO=$$ASKNO(LNM,L870,WAY) QUIT:NO[U  ;->
"RTN","HLEVUTI1",26,0)
 I WHAT=6 D SEARCH(L870,WAY,NO) G CTRL1 ;->
"RTN","HLEVUTI1",27,0)
 S TOT(WAY)=0,LAST=""
"RTN","HLEVUTI1",28,0)
 QUIT:$O(@GBL@(WAY,0))'>0  ;->
"RTN","HLEVUTI1",29,0)
 W !,$$CJ^XLFSTR(" "_$S(WAY=1:"IN",1:"OUT")_" QUEUE ",IOM,"-")
"RTN","HLEVUTI1",30,0)
 I WHAT=3 W !,"Totaling..."
"RTN","HLEVUTI1",31,0)
 F  S NO=$O(@GBL@(WAY,NO)) Q:'NO!ABRT  D
"RTN","HLEVUTI1",32,0)
 .  S CT=CT+1
"RTN","HLEVUTI1",33,0)
 .  S NODE=$G(@GBL@(WAY,NO,0)),DATE=$P($G(@GBL@(WAY,NO,1,0)),U,5)
"RTN","HLEVUTI1",34,0)
 .  S TXT=$G(@GBL@(WAY,NO,1,1,0))
"RTN","HLEVUTI1",35,0)
 .  S TXT=$E(DATE_"            ",1,10)_$E(NODE_"            ",1,12)_"  "_$E(TXT,1,56)
"RTN","HLEVUTI1",36,0)
 .  I WHAT=1 W:($X+$L(NO)+1)>IOM ! W:$X>0 "," W NO
"RTN","HLEVUTI1",37,0)
 .  I WHAT=2 D
"RTN","HLEVUTI1",38,0)
 .  .  W !,TXT
"RTN","HLEVUTI1",39,0)
 .  I WHAT=3 W:'(CT#5000) "." S TOT(WAY)=TOT(WAY)+1
"RTN","HLEVUTI1",40,0)
 .  I WHAT=4 Q:$$CT  W "."
"RTN","HLEVUTI1",41,0)
 .  I WHAT=5 D
"RTN","HLEVUTI1",42,0)
 .  .  I LAST,+LAST'=(NO-1) D
"RTN","HLEVUTI1",43,0)
 .  .  .  W !,+LAST,?10," ",$E($P(LAST,"~",2,999),1,IOM-$X)
"RTN","HLEVUTI1",44,0)
 .  .  .  W !,+NO,?10," ",$E(TXT,1,69)
"RTN","HLEVUTI1",45,0)
 .  .  S LAST=NO_"~"_TXT
"RTN","HLEVUTI1",46,0)
 .  I 'CONT,'(CT#20) R X:999 S:X[U ABRT=1 S:X=" " CONT=1
"RTN","HLEVUTI1",47,0)
 I 'ABRT,TOT(WAY) W !,"--- Total = #",TOT(WAY)
"RTN","HLEVUTI1",48,0)
 S ABRT="",CT=0
"RTN","HLEVUTI1",49,0)
 ;
"RTN","HLEVUTI1",50,0)
 R !,"End of output... ",X:999
"RTN","HLEVUTI1",51,0)
 ;
"RTN","HLEVUTI1",52,0)
 W !!,$$CJ^XLFSTR(" "_LNM_" ",IOM,"=")
"RTN","HLEVUTI1",53,0)
 ;
"RTN","HLEVUTI1",54,0)
 G CTRL1 ;->
"RTN","HLEVUTI1",55,0)
 ;
"RTN","HLEVUTI1",56,0)
SHOWHD(LNM,L870) ; Show summary information...
"RTN","HLEVUTI1",57,0)
 N NODE
"RTN","HLEVUTI1",58,0)
 W !!,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVUTI1",59,0)
 F NODE=0,100,200,300,400,"IN QUEUE BACK POINTER","IN QUEUE FRONT POINTER","OUT QUEUE BACK POINTER","OUT QUEUE FRONT POINTER" D
"RTN","HLEVUTI1",60,0)
 .  S DATA=$G(@GBL@(NODE)) Q:DATA']""  ;->
"RTN","HLEVUTI1",61,0)
 .  D PHD(NODE,DATA)
"RTN","HLEVUTI1",62,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVUTI1",63,0)
 Q
"RTN","HLEVUTI1",64,0)
 ;
"RTN","HLEVUTI1",65,0)
CT() QUIT:(CT#500) ""
"RTN","HLEVUTI1",66,0)
 R X:999 Q:X']"" ""
"RTN","HLEVUTI1",67,0)
 S ABRT=1
"RTN","HLEVUTI1",68,0)
 Q 1
"RTN","HLEVUTI1",69,0)
 ;
"RTN","HLEVUTI1",70,0)
PHD(HD,DATA) ;
"RTN","HLEVUTI1",71,0)
 S HD=$$HD(HD)
"RTN","HLEVUTI1",72,0)
 S HD=$E("    ",1,4-$L(HD))_HD
"RTN","HLEVUTI1",73,0)
 W !,HD,"="
"RTN","HLEVUTI1",74,0)
 F  D  QUIT:DATA']""
"RTN","HLEVUTI1",75,0)
 .  QUIT:DATA']""
"RTN","HLEVUTI1",76,0)
 .  W $E(DATA,1,76)
"RTN","HLEVUTI1",77,0)
 .  S DATA=$E(DATA,77,999)
"RTN","HLEVUTI1",78,0)
 .  W:DATA]"" !,?4
"RTN","HLEVUTI1",79,0)
 Q
"RTN","HLEVUTI1",80,0)
 ;
"RTN","HLEVUTI1",81,0)
HD(HD) ;
"RTN","HLEVUTI1",82,0)
 I HD["IN QUEUE F" S HD="IQFP"
"RTN","HLEVUTI1",83,0)
 I HD["IN QUEUE B" S HD="IQBP"
"RTN","HLEVUTI1",84,0)
 I HD["OUT QUEUE F" S HD="OQFP"
"RTN","HLEVUTI1",85,0)
 I HD["OUT QUEUE B" S HD="OQBP"
"RTN","HLEVUTI1",86,0)
 Q HD
"RTN","HLEVUTI1",87,0)
 ;
"RTN","HLEVUTI1",88,0)
LINK() N DIC,X,Y
"RTN","HLEVUTI1",89,0)
 S DIC=870,DIC(0)="AEMQN",DIC("A")="Select LINK: "
"RTN","HLEVUTI1",90,0)
 D ^DIC
"RTN","HLEVUTI1",91,0)
 QUIT $S(+Y:+Y,1:"")
"RTN","HLEVUTI1",92,0)
 ;
"RTN","HLEVUTI1",93,0)
QUEUES N LNM,LNO
"RTN","HLEVUTI1",94,0)
 KILL ^TMP($J,"ZZLJA")
"RTN","HLEVUTI1",95,0)
 S LNM=""
"RTN","HLEVUTI1",96,0)
 F  S LNM=$O(^HLCS(870,"B",LNM)) Q:LNM']""  D
"RTN","HLEVUTI1",97,0)
 .  S LNO=0
"RTN","HLEVUTI1",98,0)
 .  F  S LNO=$O(^HLCS(870,"B",LNM,LNO)) Q:'LNO  D
"RTN","HLEVUTI1",99,0)
 .  .  S LNS=$$LNM(LNO)
"RTN","HLEVUTI1",100,0)
 .  .  I $O(^HLCS(870,+LNO,1,0))>0 D
"RTN","HLEVUTI1",101,0)
 .  .  .  S ^TMP($J,"ZZLJA",LNS,1)=$P($G(^HLCS(870,+LNO,1,0)),U,3)
"RTN","HLEVUTI1",102,0)
 .  .  I $O(^HLCS(870,+LNO,2,0))>0 D
"RTN","HLEVUTI1",103,0)
 .  .  .  S ^TMP($J,"ZZLJA",LNS,2)=$P($G(^HLCS(870,+LNO,2,0)),U,3)
"RTN","HLEVUTI1",104,0)
 ;
"RTN","HLEVUTI1",105,0)
 W !!,"Links with queues"
"RTN","HLEVUTI1",106,0)
 W !,"Link",?30,"IQ Totals",?45,"OQ Totals"
"RTN","HLEVUTI1",107,0)
 W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLEVUTI1",108,0)
 ;
"RTN","HLEVUTI1",109,0)
 S LNS=""
"RTN","HLEVUTI1",110,0)
 F  S LNS=$O(^TMP($J,"ZZLJA",LNS)) Q:LNS']""  D
"RTN","HLEVUTI1",111,0)
 .  W !
"RTN","HLEVUTI1",112,0)
 .  W:LNS["Mail]" IOINHI W $E(LNS_" --------------------",1,20),IOINORM
"RTN","HLEVUTI1",113,0)
 .  F WAY=1,2 D
"RTN","HLEVUTI1",114,0)
 .  .  S TOT=$G(^TMP($J,"ZZLJA",LNS,WAY))
"RTN","HLEVUTI1",115,0)
 .  .  S TOT=$E("---------------",1,15-$L(TOT))_TOT
"RTN","HLEVUTI1",116,0)
 .  .  W TOT
"RTN","HLEVUTI1",117,0)
 ;
"RTN","HLEVUTI1",118,0)
 KILL ^TMP($J,"ZZLJA")
"RTN","HLEVUTI1",119,0)
 ;
"RTN","HLEVUTI1",120,0)
 Q
"RTN","HLEVUTI1",121,0)
 ;
"RTN","HLEVUTI1",122,0)
LNM(L870) N GBL,X
"RTN","HLEVUTI1",123,0)
 S GBL="^HLCS(870,"_L870_")",X=$G(@GBL@(0))
"RTN","HLEVUTI1",124,0)
 Q $P(X,U)_" #"_L870_" ["_$P("Mail^HLLP^X3.28^TCP",U,+$P(X,U,3))_"] "
"RTN","HLEVUTI1",125,0)
 ;
"RTN","HLEVUTI1",126,0)
ASKNO(LNM,L870,WAY) ; Ask for beginning IEN to display...
"RTN","HLEVUTI1",127,0)
 N DIR,DIRUT,DTOUT,DUOUT,FIRST,LAST,X,Y
"RTN","HLEVUTI1",128,0)
 S FIRST=$O(^HLCS(870,+L870,WAY,0))
"RTN","HLEVUTI1",129,0)
 S LAST=$O(^HLCS(870,+L870,WAY,":"),-1)
"RTN","HLEVUTI1",130,0)
 W !!,"First IEN = ",FIRST
"RTN","HLEVUTI1",131,0)
 W !," Last IEN = ",LAST
"RTN","HLEVUTI1",132,0)
 W !
"RTN","HLEVUTI1",133,0)
 S DIR(0)="N^"_FIRST_":"_LAST,DIR("A")="Enter IEN"
"RTN","HLEVUTI1",134,0)
 I FIRST S DIR("B")=FIRST
"RTN","HLEVUTI1",135,0)
 D ^DIR
"RTN","HLEVUTI1",136,0)
 QUIT:$D(DIRUT)!($D(DTOUT))!($D(DUOUT)) U ;->
"RTN","HLEVUTI1",137,0)
 QUIT:+Y>0 (+Y-1) ;->  Will be used for $ORDER
"RTN","HLEVUTI1",138,0)
 Q 0
"RTN","HLEVUTI1",139,0)
 ;
"RTN","HLEVUTI1",140,0)
ASKWAY() ; In or Out...
"RTN","HLEVUTI1",141,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLEVUTI1",142,0)
 S DIR(0)="S^1:Inbound Queue;2:Outbound Queue"
"RTN","HLEVUTI1",143,0)
 S DIR("A")="Select QUEUE"
"RTN","HLEVUTI1",144,0)
 D ^DIR
"RTN","HLEVUTI1",145,0)
 QUIT:+Y>0&(+Y<3) $P("1^2",U,+Y)
"RTN","HLEVUTI1",146,0)
 Q U
"RTN","HLEVUTI1",147,0)
 ;
"RTN","HLEVUTI1",148,0)
SEARCH(L870,WAY,NO,SKIP) ; Search for a date...
"RTN","HLEVUTI1",149,0)
 ; LNM -- req
"RTN","HLEVUTI1",150,0)
 N ABRT,CONT,CT,NUM
"RTN","HLEVUTI1",151,0)
 I '$D(SKIP) N SKIP
"RTN","HLEVUTI1",152,0)
S1 S SKIP=$S($G(SKIP):+SKIP,1:5000),ABRT=0,CT=0,CONT=0
"RTN","HLEVUTI1",153,0)
 S NUM=NO-1,NUM=$O(^HLCS(870,+L870,WAY,NUM))
"RTN","HLEVUTI1",154,0)
 W !!
"RTN","HLEVUTI1",155,0)
 D SRCH1(L870,WAY,+NUM)
"RTN","HLEVUTI1",156,0)
 F  D  QUIT:NUM'>0!(ABRT)
"RTN","HLEVUTI1",157,0)
 .  S NUM=NUM+SKIP
"RTN","HLEVUTI1",158,0)
 .  S NUM=$O(^HLCS(870,+L870,WAY,NUM)) QUIT:NUM'>0  ;->
"RTN","HLEVUTI1",159,0)
 .  D SRCH1(L870,WAY,+NUM)
"RTN","HLEVUTI1",160,0)
 W !,"Just completed a search using a starting point of IEN=",NO,", and an offset"
"RTN","HLEVUTI1",161,0)
 W !,"of #",SKIP,".  You may now enter a new starting IEN and offset."
"RTN","HLEVUTI1",162,0)
 W !
"RTN","HLEVUTI1",163,0)
 S NO=$$ASKNO(LNM,L870,WAY) QUIT:NO[U  ;->
"RTN","HLEVUTI1",164,0)
 R !,"Enter OFFSET: ",OFFSET:90 I OFFSET>0 S SKIP=OFFSET G S1 ;->
"RTN","HLEVUTI1",165,0)
 Q
"RTN","HLEVUTI1",166,0)
 ;
"RTN","HLEVUTI1",167,0)
SRCH1(L870,WAY,IEN) ; Show date of entry...
"RTN","HLEVUTI1",168,0)
 N MSH,DATE,DEL
"RTN","HLEVUTI1",169,0)
 S MSH=$G(^HLCS(870,+L870,WAY,IEN,1,1,0))
"RTN","HLEVUTI1",170,0)
 S DEL=$E(MSH,4),DATE=$P(MSH,DEL,7)
"RTN","HLEVUTI1",171,0)
 S DATE=$S(DATE?14N.1"-".N:$$HTFM^XLFDT(DATE),1:"")
"RTN","HLEVUTI1",172,0)
 S DATE=$S(DATE?7N.E:DATE,1:$P($G(^HLCS(870,+L870,WAY,IEN,1,0)),U,5))
"RTN","HLEVUTI1",173,0)
 QUIT:DATE'?7N.E  ;->
"RTN","HLEVUTI1",174,0)
 W $J($$SDT(DATE)_"(#"_IEN_")",18)_"  "
"RTN","HLEVUTI1",175,0)
 S CT=CT+1
"RTN","HLEVUTI1",176,0)
 I 'CONT,'(CT#80) R X:999 S:X[U ABRT=1 S:X=" " CONT=1
"RTN","HLEVUTI1",177,0)
 Q
"RTN","HLEVUTI1",178,0)
 ;
"RTN","HLEVUTI1",179,0)
SDT(DATE) ; Return shortened form of date...
"RTN","HLEVUTI1",180,0)
 I DATE?7N QUIT $E(DATE,4,5)_"/"_$E(DATE,6,7)_"/"_$E(DATE,2,3) ;->
"RTN","HLEVUTI1",181,0)
 I DATE?7N1"."1.N QUIT $E(DATE,4,5)_"/"_$E(DATE,6,7)_"/"_$E(DATE,2,3)_"@"_$E($P($$FMTE^XLFDT(DATE),"@",2),1,5)
"RTN","HLEVUTI1",182,0)
 QUIT ""
"RTN","HLEVUTI1",183,0)
 ;
"RTN","HLEVUTI1",184,0)
TEST ; Hardwire IENs and test M code in monitor (only)...
"RTN","HLEVUTI1",185,0)
 N IEN,MCODE,STATE,WAY
"RTN","HLEVUTI1",186,0)
 ;
"RTN","HLEVUTI1",187,0)
 W @IOF,$$CJ^XLFSTR("Monitor Test Utility",IOM)
"RTN","HLEVUTI1",188,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVUTI1",189,0)
 W !,"This utility sets the ^TMP(""HLEVFLAG"",$J) node to ""STOP"" to avoid any"
"RTN","HLEVUTI1",190,0)
 W !,"Event Monitor activity.  This enables the debugging of M code."
"RTN","HLEVUTI1",191,0)
 ;
"RTN","HLEVUTI1",192,0)
 S STATE=$G(^TMP("HLEVFLAG",$J))
"RTN","HLEVUTI1",193,0)
 ;
"RTN","HLEVUTI1",194,0)
 F  D  QUIT:'IEN
"RTN","HLEVUTI1",195,0)
 .  W !
"RTN","HLEVUTI1",196,0)
 .  S IEN=$$ASKIEN^HLEVREP(776.1) QUIT:'IEN  ;->
"RTN","HLEVUTI1",197,0)
 .
"RTN","HLEVUTI1",198,0)
 .  S MCODE=$TR($P($G(^HLEV(776.1,+IEN,0)),U,6),"~",U)
"RTN","HLEVUTI1",199,0)
 .  I MCODE']"" W "   no M code found..." QUIT  ;->
"RTN","HLEVUTI1",200,0)
 .  W !!,"M code = ",MCODE
"RTN","HLEVUTI1",201,0)
 .
"RTN","HLEVUTI1",202,0)
 .  W !!,"You may ZG ",MCODE," or D ",MCODE,"..."
"RTN","HLEVUTI1",203,0)
 .  W !
"RTN","HLEVUTI1",204,0)
 .  S WAY=$$YN^HLCSRPT4("DO the MCODE","Yes")
"RTN","HLEVUTI1",205,0)
 .  S WAY=$S(WAY=1:1,1:2) ; 1=DO, 2=ZG
"RTN","HLEVUTI1",206,0)
 .
"RTN","HLEVUTI1",207,0)
 .  W !
"RTN","HLEVUTI1",208,0)
 .  I '$$YN^HLCSRPT4("OK to test now","Yes") D  QUIT  ;->
"RTN","HLEVUTI1",209,0)
 .  .  W "   no action taken..."
"RTN","HLEVUTI1",210,0)
 .
"RTN","HLEVUTI1",211,0)
 .  S ^TMP("HLEVFLAG",$J)="STOP"
"RTN","HLEVUTI1",212,0)
 .
"RTN","HLEVUTI1",213,0)
 .  D TESTRUN
"RTN","HLEVUTI1",214,0)
 .
"RTN","HLEVUTI1",215,0)
 .  KILL ^TMP("HLEVFLAG",$J)
"RTN","HLEVUTI1",216,0)
 .  W !!,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLEVUTI1",217,0)
 ;
"RTN","HLEVUTI1",218,0)
 I STATE]"" S ^TMP("HLEVFLAG",$J)=STATE
"RTN","HLEVUTI1",219,0)
 ;
"RTN","HLEVUTI1",220,0)
 Q
"RTN","HLEVUTI1",221,0)
 ;
"RTN","HLEVUTI1",222,0)
TESTRUN ; Call here from above to avoid LEVEL ERRORs with ZGo...
"RTN","HLEVUTI1",223,0)
 ; MCODE,WAY -- req
"RTN","HLEVUTI1",224,0)
 I WAY=1 D
"RTN","HLEVUTI1",225,0)
 .  W "  DOing ",MCODE,"... "
"RTN","HLEVUTI1",226,0)
 .  D @MCODE
"RTN","HLEVUTI1",227,0)
 I WAY=2 D
"RTN","HLEVUTI1",228,0)
 .  W "  ZGOing ",MCODE,"... "
"RTN","HLEVUTI1",229,0)
 .  X "ZG "_@MCODE
"RTN","HLEVUTI1",230,0)
 Q
"RTN","HLEVUTI1",231,0)
 ;
"RTN","HLEVUTI1",232,0)
COLLECT(I772) ; Collect 772 & 773 data...
"RTN","HLEVUTI1",233,0)
 N CT,I773
"RTN","HLEVUTI1",234,0)
 D ADD(""),ADD($$CJ^XLFSTR(" 772# "_I772_" ",74,"-"))
"RTN","HLEVUTI1",235,0)
 S I773=0,CT=0
"RTN","HLEVUTI1",236,0)
 F  S I773=$O(^TMP($J,"HLIEN",IEN,I773)) Q:'I773  D
"RTN","HLEVUTI1",237,0)
 .  I CT>0 D ADD("")
"RTN","HLEVUTI1",238,0)
 .  D COLL773(+I773)
"RTN","HLEVUTI1",239,0)
 .  S CT=CT+1
"RTN","HLEVUTI1",240,0)
 D ADD($$CJ^XLFSTR("----------------------------------------",74))
"RTN","HLEVUTI1",241,0)
 D COLL772(+I772)
"RTN","HLEVUTI1",242,0)
 Q
"RTN","HLEVUTI1",243,0)
 ;
"RTN","HLEVUTI1",244,0)
COLL773(I773) ;
"RTN","HLEVUTI1",245,0)
 N LP,ST
"RTN","HLEVUTI1",246,0)
 S LP="^HLMA("_I773,ST=LP_",",LP=LP_")"
"RTN","HLEVUTI1",247,0)
 F  S LP=$Q(@LP) Q:LP'[ST  D
"RTN","HLEVUTI1",248,0)
 .  D ADD(LP_"="_@LP)
"RTN","HLEVUTI1",249,0)
 Q
"RTN","HLEVUTI1",250,0)
 ;
"RTN","HLEVUTI1",251,0)
COLL772(I772) ;
"RTN","HLEVUTI1",252,0)
 N CT,LASTIN,LP,ST
"RTN","HLEVUTI1",253,0)
 S LP="^HL(772,"_I772,ST=LP_",",LP=LP_")",CT=0,LASTIN=""
"RTN","HLEVUTI1",254,0)
 F  S LP=$Q(@LP) Q:LP'[ST  D
"RTN","HLEVUTI1",255,0)
 .  I $TR(LP,"""","")?1"^HL(772,"1.N1",IN,"1.N.E D  QUIT:CT>5  ;->
"RTN","HLEVUTI1",256,0)
 .  .  S CT=CT+1
"RTN","HLEVUTI1",257,0)
 .  .  I CT=7 D ADD("... some data not shown ...")
"RTN","HLEVUTI1",258,0)
 .  .  S LASTIN=LP
"RTN","HLEVUTI1",259,0)
 .  D ADD(LP_"="_@LP)
"RTN","HLEVUTI1",260,0)
 I LASTIN]"",CT>6 D ADD(LASTIN_"="_@LASTIN)
"RTN","HLEVUTI1",261,0)
 Q
"RTN","HLEVUTI1",262,0)
 ;
"RTN","HLEVUTI1",263,0)
ADD(TXT) ; Add text for report...
"RTN","HLEVUTI1",264,0)
 ; SCRN -- req
"RTN","HLEVUTI1",265,0)
 N NO,POSX
"RTN","HLEVUTI1",266,0)
 S POSX=$L($P(TXT,"="))+1
"RTN","HLEVUTI1",267,0)
 F  D  QUIT:TXT']""
"RTN","HLEVUTI1",268,0)
 .  I 'SCRN D  ; Store for email message...
"RTN","HLEVUTI1",269,0)
 .  .  S NO=$O(^TMP($J,"HLMAIL",":"),-1)+1
"RTN","HLEVUTI1",270,0)
 .  .  S ^TMP($J,"HLMAIL",+NO)=$E(TXT,1,74)
"RTN","HLEVUTI1",271,0)
 .  I SCRN W !,$E(TXT,1,74) ; Display on-screen
"RTN","HLEVUTI1",272,0)
 .  S TXT=$E(TXT,75,999) QUIT:TXT']""  ;->
"RTN","HLEVUTI1",273,0)
 .  S TXT=$$REPEAT^XLFSTR(" ",$S(POSX:POSX,1:5))_TXT
"RTN","HLEVUTI1",274,0)
 Q
"RTN","HLEVUTI1",275,0)
 ;
"RTN","HLEVUTI1",276,0)
DOLRO(TAG,SNO) ; Store debug data in ^XTMP("HLEVUTI1 "_DT,NO)...
"RTN","HLEVUTI1",277,0)
 N NO,X,XTMP
"RTN","HLEVUTI1",278,0)
 ;
"RTN","HLEVUTI1",279,0)
 S XTMP="HLEVUTI1 "_TAG_"-"_DT
"RTN","HLEVUTI1",280,0)
 S:'$D(^XTMP(XTMP,0)) ^XTMP(XTMP,0)=$$FMADD^XLFDT(DT,1)_U_$$NOW^XLFDT_"^Debug data created by DOLRO~HLEVUTI1"
"RTN","HLEVUTI1",281,0)
 ;
"RTN","HLEVUTI1",282,0)
 S NO=$O(^XTMP(XTMP,":"),-1)+1,NO=$S(NO>($G(SNO)-1):NO,1:SNO)
"RTN","HLEVUTI1",283,0)
 ;
"RTN","HLEVUTI1",284,0)
 S X="^XTMP("""_XTMP_""","_NO_"," D DOLRO^%ZOSV
"RTN","HLEVUTI1",285,0)
 ;
"RTN","HLEVUTI1",286,0)
 Q
"RTN","HLEVUTI1",287,0)
 ;
"RTN","HLEVUTI1",288,0)
EOR ;HLEVUTI1 - Event Monitor UTILITIES ;5/16/03 14:42
"RTN","HLEVUTI2")
0^41^B100658230
"RTN","HLEVUTI2",1,0)
HLEVUTI2 ;O-OIFO/LJA - Event Monitor UTILITIES ;02/04/2004 14:42
"RTN","HLEVUTI2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVUTI2",3,0)
 ;
"RTN","HLEVUTI2",4,0)
 ; This routine is used to queue M code tasks that automatically
"RTN","HLEVUTI2",5,0)
 ; requeue themselves (within limits.)
"RTN","HLEVUTI2",6,0)
 ;
"RTN","HLEVUTI2",7,0)
INIT ;
"RTN","HLEVUTI2",8,0)
 N A7UOK
"RTN","HLEVUTI2",9,0)
 D HEADER,EX
"RTN","HLEVUTI2",10,0)
 F  Q:(+$Y+3)>IOSL  W !
"RTN","HLEVUTI2",11,0)
 QUIT:$$BTE^HLCSMON("Press RETURN to continue, or '^' to exit... ")  ;->
"RTN","HLEVUTI2",12,0)
 ;
"RTN","HLEVUTI2",13,0)
CTRL ;
"RTN","HLEVUTI2",14,0)
 D HEADER
"RTN","HLEVUTI2",15,0)
 W !
"RTN","HLEVUTI2",16,0)
 D M
"RTN","HLEVUTI2",17,0)
 D ASK I 'A7UOK QUIT  ;->
"RTN","HLEVUTI2",18,0)
 D XEC
"RTN","HLEVUTI2",19,0)
 D BT QUIT:'A7UOK  ;->
"RTN","HLEVUTI2",20,0)
 G CTRL ;->
"RTN","HLEVUTI2",21,0)
 ;
"RTN","HLEVUTI2",22,0)
BT ;
"RTN","HLEVUTI2",23,0)
 W !
"RTN","HLEVUTI2",24,0)
 S A7UOK=0
"RTN","HLEVUTI2",25,0)
 N DIR
"RTN","HLEVUTI2",26,0)
 S DIR(0)="EA",DIR("A")="Press RETURN to continue, or '^' to exit... "
"RTN","HLEVUTI2",27,0)
 D ^DIR
"RTN","HLEVUTI2",28,0)
 QUIT:+Y'=1  ;->
"RTN","HLEVUTI2",29,0)
 S A7UOK=1
"RTN","HLEVUTI2",30,0)
 QUIT
"RTN","HLEVUTI2",31,0)
 ;
"RTN","HLEVUTI2",32,0)
HEADER ;
"RTN","HLEVUTI2",33,0)
 W @IOF,$$CJ^XLFSTR("M Code Requeue Utility",IOM)
"RTN","HLEVUTI2",34,0)
 W !,$$REPEAT^XLFSTR("=",80)
"RTN","HLEVUTI2",35,0)
 QUIT
"RTN","HLEVUTI2",36,0)
 ;
"RTN","HLEVUTI2",37,0)
M KILL A7UMENU F I=1:1 S T=$T(M+I) QUIT:T'[";;"  S T=$P(T,";;",2,99),A7UMENU(I)=$P(T,"~",2,99) W !,$J(I,2),". ",$P(T,"~")
"RTN","HLEVUTI2",38,0)
 ;;Start M code jobs~D START
"RTN","HLEVUTI2",39,0)
 ;;Show M code job runs~D SHOW
"RTN","HLEVUTI2",40,0)
 QUIT
"RTN","HLEVUTI2",41,0)
 ;
"RTN","HLEVUTI2",42,0)
ASK ;
"RTN","HLEVUTI2",43,0)
 W !
"RTN","HLEVUTI2",44,0)
 S A7UOK=0
"RTN","HLEVUTI2",45,0)
 N DIR
"RTN","HLEVUTI2",46,0)
 S DIR(0)="NO^1:"_(+I-1),DIR("A")="Select option"
"RTN","HLEVUTI2",47,0)
 D ^DIR
"RTN","HLEVUTI2",48,0)
 QUIT:'$D(A7UMENU(+Y))  ;->
"RTN","HLEVUTI2",49,0)
 S A7UOPT=+Y
"RTN","HLEVUTI2",50,0)
 S A7UOK=1
"RTN","HLEVUTI2",51,0)
 QUIT
"RTN","HLEVUTI2",52,0)
 ;
"RTN","HLEVUTI2",53,0)
XEC ;
"RTN","HLEVUTI2",54,0)
 S X=A7UMENU(+A7UOPT) X X
"RTN","HLEVUTI2",55,0)
 QUIT
"RTN","HLEVUTI2",56,0)
 ;
"RTN","HLEVUTI2",57,0)
 ;==================================================================
"RTN","HLEVUTI2",58,0)
 ;
"RTN","HLEVUTI2",59,0)
SHOW ; Show M code job "runs"...
"RTN","HLEVUTI2",60,0)
 N C2,C3,C4,C5,X,XTMP,Y
"RTN","HLEVUTI2",61,0)
 ;
"RTN","HLEVUTI2",62,0)
 I $O(^XTMP("HLEVREQ"))'["HLEVREQ" D  QUIT  ;->
"RTN","HLEVUTI2",63,0)
 .  W !!,"No M Code API run data exists..."
"RTN","HLEVUTI2",64,0)
 .  W !
"RTN","HLEVUTI2",65,0)
 ;
"RTN","HLEVUTI2",66,0)
 S C2=14,C3=28,C4=41,C5=59
"RTN","HLEVUTI2",67,0)
 W !,"Task#",?C2,"Start",?C3,"Finish",?C4,"|"
"RTN","HLEVUTI2",68,0)
 W ?(C4+2),"Next task#",?C5,"Queue time"
"RTN","HLEVUTI2",69,0)
 W !,$$REPEAT^XLFSTR("=",C4),"|",$$REPEAT^XLFSTR("=",IOM-$X)
"RTN","HLEVUTI2",70,0)
 ;
"RTN","HLEVUTI2",71,0)
 S XTMP="HLEVREQ"
"RTN","HLEVUTI2",72,0)
 F  S XTMP=$O(^XTMP(XTMP)) Q:$E(XTMP,1,7)'="HLEVREQ"  D
"RTN","HLEVUTI2",73,0)
 .  D SXTMPT(XTMP)
"RTN","HLEVUTI2",74,0)
 ;
"RTN","HLEVUTI2",75,0)
 ;
"RTN","HLEVUTI2",76,0)
 S C2=14,C3=28,C4=41,C5=59
"RTN","HLEVUTI2",77,0)
 W !!,"Task#",?C2,"Start",?C3,"Finish",?C4,"M API"
"RTN","HLEVUTI2",78,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVUTI2",79,0)
 ;
"RTN","HLEVUTI2",80,0)
 S XTMP="HLEVREQ"
"RTN","HLEVUTI2",81,0)
 F  S XTMP=$O(^XTMP(XTMP)) Q:$E(XTMP,1,7)'="HLEVREQ"  D
"RTN","HLEVUTI2",82,0)
 .  D SXTMPM(XTMP)
"RTN","HLEVUTI2",83,0)
 ;
"RTN","HLEVUTI2",84,0)
 Q
"RTN","HLEVUTI2",85,0)
 ;
"RTN","HLEVUTI2",86,0)
SXTMPM(XTMP) ; Show individual XTMP entry...
"RTN","HLEVUTI2",87,0)
 ; C2 to C5 -- req
"RTN","HLEVUTI2",88,0)
 N I,XTMP0
"RTN","HLEVUTI2",89,0)
 S XTMP0=$G(^XTMP(XTMP,0)) QUIT:XTMP0']""  ;->
"RTN","HLEVUTI2",90,0)
 W !
"RTN","HLEVUTI2",91,0)
 D P(4,C2),P(2,C3),P(7,C4)
"RTN","HLEVUTI2",92,0)
 W $P(XTMP0,U,8,9),"  "
"RTN","HLEVUTI2",93,0)
 S XTMP0=$P(XTMP0,U,8,9) QUIT:XTMP0']""  ;->
"RTN","HLEVUTI2",94,0)
 S XTMP0=$P($T(@XTMP0)," ",2,999) QUIT:XTMP0']""  ;->
"RTN","HLEVUTI2",95,0)
 I $E(XTMP0)=";",$E(XTMP0,1,2)'=";;" S XTMP0=$E(XTMP0,2,999)
"RTN","HLEVUTI2",96,0)
 X "F I=1:1:$L(XTMP0) Q:$E(XTMP0,I)'="" """ S XTMP0=$E(XTMP0,I,999)
"RTN","HLEVUTI2",97,0)
 W $E(XTMP0,1,IOM-$X)
"RTN","HLEVUTI2",98,0)
 Q
"RTN","HLEVUTI2",99,0)
 ;
"RTN","HLEVUTI2",100,0)
SXTMPT(XTMP) ; Show individual XTMP entry...
"RTN","HLEVUTI2",101,0)
 ; C2 to C5 -- req
"RTN","HLEVUTI2",102,0)
 N XTMP0
"RTN","HLEVUTI2",103,0)
 S XTMP0=$G(^XTMP(XTMP,0)) QUIT:XTMP0']""  ;->
"RTN","HLEVUTI2",104,0)
 W !
"RTN","HLEVUTI2",105,0)
 D P(4,C2),P(2,C3),P(7,C4)
"RTN","HLEVUTI2",106,0)
 W "| "
"RTN","HLEVUTI2",107,0)
 D P(5,C5),P(6,IOM)
"RTN","HLEVUTI2",108,0)
 Q
"RTN","HLEVUTI2",109,0)
 ;
"RTN","HLEVUTI2",110,0)
P(PCE,COL) ; Print value and "tab" over to COL...
"RTN","HLEVUTI2",111,0)
 ; XTMP0 -- req
"RTN","HLEVUTI2",112,0)
 N DATA
"RTN","HLEVUTI2",113,0)
 S DATA=$P(XTMP0,U,PCE)
"RTN","HLEVUTI2",114,0)
 I DATA?7N1"."1.N S DATA=$$SDT^HLEVX001(DATA)
"RTN","HLEVUTI2",115,0)
 W DATA,?COL
"RTN","HLEVUTI2",116,0)
 Q
"RTN","HLEVUTI2",117,0)
 ;
"RTN","HLEVUTI2",118,0)
 ;==================================================================
"RTN","HLEVUTI2",119,0)
 ;
"RTN","HLEVUTI2",120,0)
START ;
"RTN","HLEVUTI2",121,0)
 N MREQ,MRTN,MTIME,ZTSK
"RTN","HLEVUTI2",122,0)
 ;
"RTN","HLEVUTI2",123,0)
 W !
"RTN","HLEVUTI2",124,0)
 S MRTN=$$FTMRTN QUIT:MRTN']""  ;->
"RTN","HLEVUTI2",125,0)
 W !
"RTN","HLEVUTI2",126,0)
 S MTIME=$$TIME QUIT:'MTIME  ;->
"RTN","HLEVUTI2",127,0)
 W !
"RTN","HLEVUTI2",128,0)
 S MREQ=$$REQNO QUIT:MREQ'>0  ;->
"RTN","HLEVUTI2",129,0)
 ;
"RTN","HLEVUTI2",130,0)
 W !
"RTN","HLEVUTI2",131,0)
 I '$$YN^HLCSRPT4("OK to queue job") D  QUIT  ;->
"RTN","HLEVUTI2",132,0)
 .  W "  job not started..."
"RTN","HLEVUTI2",133,0)
 ;
"RTN","HLEVUTI2",134,0)
 S ZTSK=$$NEWJOB($$NOW^XLFDT)
"RTN","HLEVUTI2",135,0)
 W !!,"Queued to task# ",ZTSK,"..."
"RTN","HLEVUTI2",136,0)
 ;
"RTN","HLEVUTI2",137,0)
 QUIT
"RTN","HLEVUTI2",138,0)
 ;
"RTN","HLEVUTI2",139,0)
 ;
"RTN","HLEVUTI2",140,0)
NEWJOB(TIME) ; Start job...
"RTN","HLEVUTI2",141,0)
 ; MREQ,MRTN,MTIME -- req
"RTN","HLEVUTI2",142,0)
 N ZTDESC,ZTDTH,ZTIO,ZTRTN,ZTSK
"RTN","HLEVUTI2",143,0)
 S ZTIO="",ZTDTH=TIME,ZTDESC="HLEVUTI2-Queued Jobs"
"RTN","HLEVUTI2",144,0)
 S ZTRTN="QUEUE^HLEVUTI2"
"RTN","HLEVUTI2",145,0)
 S ZTSAVE("MREQ")="",ZTSAVE("MRTN")="",ZTSAVE("MTIME")=""
"RTN","HLEVUTI2",146,0)
 S ZTSAVE("HLRUNS*")=""
"RTN","HLEVUTI2",147,0)
 D ^%ZTLOAD
"RTN","HLEVUTI2",148,0)
 QUIT ZTSK
"RTN","HLEVUTI2",149,0)
 ;
"RTN","HLEVUTI2",150,0)
QUEUE ; Queue point for the starting of all queued HLEVUTI2 jobs...
"RTN","HLEVUTI2",151,0)
 ; MREQ,MRTN,MTIME -- req
"RTN","HLEVUTI2",152,0)
 N I,NEWJOB,NOW,TASKNO,XTMP
"RTN","HLEVUTI2",153,0)
 ;
"RTN","HLEVUTI2",154,0)
 S ZTREQ="@",NOW=$$NOW^XLFDT,TASKNO=ZTSK
"RTN","HLEVUTI2",155,0)
 ;
"RTN","HLEVUTI2",156,0)
 ; Store run's ZTSK in HLRUNS...
"RTN","HLEVUTI2",157,0)
 S HLRUNS=$G(HLRUNS)+1,HLRUNS(+ZTSK)=NOW
"RTN","HLEVUTI2",158,0)
 I HLRUNS>30 S I=0 F  S I=$O(HLRUNS(I)) KILL HLRUNS(I) ; No STORE errors!
"RTN","HLEVUTI2",159,0)
 ;
"RTN","HLEVUTI2",160,0)
 S XTMP="HLEVREQ-"_ZTSK
"RTN","HLEVUTI2",161,0)
 S ^XTMP(XTMP,0)=$$FMADD^XLFDT(MTIME,1)_U_NOW_U_"Event Monitor HLEVUTI2 Requeue"_U_ZTSK_"^^^^"_MRTN
"RTN","HLEVUTI2",162,0)
 ;
"RTN","HLEVUTI2",163,0)
 ; Piece 1 = Vaporization date/time
"RTN","HLEVUTI2",164,0)
 ; Piece 2 = NOW
"RTN","HLEVUTI2",165,0)
 ; Piece 3 = Description
"RTN","HLEVUTI2",166,0)
 ; Piece 4 = Current task#
"RTN","HLEVUTI2",167,0)
 ; Piece 5 = Next task number or END OF QUEUING
"RTN","HLEVUTI2",168,0)
 ; Piece 6 = Next queue time
"RTN","HLEVUTI2",169,0)
 ; Piece 7 = M code API finish time
"RTN","HLEVUTI2",170,0)
 ; Piece 8 = Tag
"RTN","HLEVUTI2",171,0)
 ; Piece 9 = Routine
"RTN","HLEVUTI2",172,0)
 ;
"RTN","HLEVUTI2",173,0)
 ; Calculate time for next queued job...
"RTN","HLEVUTI2",174,0)
 S NEXTIME=$$FMADD^XLFDT(NOW,"","",MREQ)
"RTN","HLEVUTI2",175,0)
 ;
"RTN","HLEVUTI2",176,0)
 ; If next queue time is not greater, then queue next job...
"RTN","HLEVUTI2",177,0)
 I NEXTIME<MTIME D
"RTN","HLEVUTI2",178,0)
 .  S NEWJOB=$$NEWJOB(NEXTIME)
"RTN","HLEVUTI2",179,0)
 .  S $P(^XTMP(XTMP,0),U,5,6)=NEWJOB_U_NEXTIME
"RTN","HLEVUTI2",180,0)
 ;
"RTN","HLEVUTI2",181,0)
 ; Run the M code...
"RTN","HLEVUTI2",182,0)
 D @MRTN
"RTN","HLEVUTI2",183,0)
 ;
"RTN","HLEVUTI2",184,0)
 ; M code finish time...
"RTN","HLEVUTI2",185,0)
 S NOW=$$NOW^XLFDT,$P(^XTMP(XTMP,0),U,7)=NOW,$P(HLRUNS(ZTSK),U,2)=NOW
"RTN","HLEVUTI2",186,0)
 ;
"RTN","HLEVUTI2",187,0)
 ; If next queue time < then end time quit (for new job already que'd)
"RTN","HLEVUTI2",188,0)
 QUIT:NEXTIME<MTIME  ;->
"RTN","HLEVUTI2",189,0)
 ;
"RTN","HLEVUTI2",190,0)
 S $P(^XTMP(XTMP,0),U,5)="END OF QUEUING"
"RTN","HLEVUTI2",191,0)
 D MAIL
"RTN","HLEVUTI2",192,0)
 ;
"RTN","HLEVUTI2",193,0)
 Q
"RTN","HLEVUTI2",194,0)
 ;
"RTN","HLEVUTI2",195,0)
TEST ; Call here to test M code
"RTN","HLEVUTI2",196,0)
 D SAVE("Line of text saved by SAVE(TXT).")
"RTN","HLEVUTI2",197,0)
 Q
"RTN","HLEVUTI2",198,0)
 ;
"RTN","HLEVUTI2",199,0)
EX N I,T F I=1:1 S T=$T(EX+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVUTI2",200,0)
 ;;This utility runs M code in a background job on a repetitive basis up to the
"RTN","HLEVUTI2",201,0)
 ;;date/time you specify.  To use this utility you must supply the following:
"RTN","HLEVUTI2",202,0)
 ;;
"RTN","HLEVUTI2",203,0)
 ;; * M code API (tag~routine.)
"RTN","HLEVUTI2",204,0)
 ;; * Requeue frequency (in minutes.)
"RTN","HLEVUTI2",205,0)
 ;; * Time to stop all requeues (up to 7 days in future.)
"RTN","HLEVUTI2",206,0)
 ;;
"RTN","HLEVUTI2",207,0)
 ;;As soon as the background job starts, the following actions occur:
"RTN","HLEVUTI2",208,0)
 ;;
"RTN","HLEVUTI2",209,0)
 ;; * The time for the next "run" of the 'M code API' is calculated using the
"RTN","HLEVUTI2",210,0)
 ;;   'requeue frequency.'  
"RTN","HLEVUTI2",211,0)
 ;; * If the new run time is not past the 'time to stop all requeues', a new
"RTN","HLEVUTI2",212,0)
 ;;   future job is queued.
"RTN","HLEVUTI2",213,0)
 ;; * The M code API is called.  (This occurs even when no future jobs are
"RTN","HLEVUTI2",214,0)
 ;;   queued.
"RTN","HLEVUTI2",215,0)
 QUIT
"RTN","HLEVUTI2",216,0)
 ;
"RTN","HLEVUTI2",217,0)
FTMRTN() ;
"RTN","HLEVUTI2",218,0)
 N ANS,DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLEVUTI2",219,0)
 S DIR(0)="F^3:17",DIR("A")="Enter TAG~ROUTINE"
"RTN","HLEVUTI2",220,0)
 W !,"Enter the M code API to be called by background jobs.  Enter it in the format"
"RTN","HLEVUTI2",221,0)
 W !,"'TAG~ROUTINE'.  (Use the tilde (~) character in place of the up-arrow.)"
"RTN","HLEVUTI2",222,0)
 W !
"RTN","HLEVUTI2",223,0)
 D ^DIR
"RTN","HLEVUTI2",224,0)
 QUIT:$D(DIRUT)!($D(DTOUT))!($D(DUOUT)) "" ;->
"RTN","HLEVUTI2",225,0)
 S ANS=$TR(Y,"~",U)
"RTN","HLEVUTI2",226,0)
 S X="D "_ANS D ^DIM QUIT:'$D(X) "" ;->
"RTN","HLEVUTI2",227,0)
 Q ANS
"RTN","HLEVUTI2",228,0)
 ;
"RTN","HLEVUTI2",229,0)
TIME() ;
"RTN","HLEVUTI2",230,0)
 N ANS,DIR,DIRUT,DTOUT,DUOUT,NOW,X,Y
"RTN","HLEVUTI2",231,0)
 S NOW=$$NOW^XLFDT
"RTN","HLEVUTI2",232,0)
 S DIR(0)="DA^"_NOW_":"_$$FMADD^XLFDT(NOW,7)_":AEFRS"
"RTN","HLEVUTI2",233,0)
 S DIR("A")="Enter STOP TIME: "
"RTN","HLEVUTI2",234,0)
 S DIR("?")="Enter a future date/time up to "_$$FMTE^XLFDT($$FMADD^XLFDT(NOW,7))_"..."
"RTN","HLEVUTI2",235,0)
 S DIR("B")=$$FMTE^XLFDT($$FMADD^XLFDT(NOW,1))
"RTN","HLEVUTI2",236,0)
 W !,"New jobs will be requeued until the date/time you enter now.  You cannot queue"
"RTN","HLEVUTI2",237,0)
 W !,"jobs past seven days in the future."
"RTN","HLEVUTI2",238,0)
 W !
"RTN","HLEVUTI2",239,0)
 D ^DIR
"RTN","HLEVUTI2",240,0)
 QUIT:$D(DIRUT)!($D(DTOUT))!($D(DUOUT)) "" ;->
"RTN","HLEVUTI2",241,0)
 S ANS=Y
"RTN","HLEVUTI2",242,0)
 I ANS'>NOW D  QUIT "" ;->
"RTN","HLEVUTI2",243,0)
 .  W !!,"Date/time you enter must not be in the past..."
"RTN","HLEVUTI2",244,0)
 Q ANS
"RTN","HLEVUTI2",245,0)
 ;
"RTN","HLEVUTI2",246,0)
REQNO() ;
"RTN","HLEVUTI2",247,0)
 N ANS,DIR,DIRUT,DTOUT,DUOUT,NOW,X,Y
"RTN","HLEVUTI2",248,0)
 S DIR(0)="N^10:1440",DIR("A")="Enter REQUEUE FREQUENCY (min)"
"RTN","HLEVUTI2",249,0)
 W !,"New jobs will be requeued for the number of 'requeue frequency' minutes"
"RTN","HLEVUTI2",250,0)
 W !,"in the future you specify now."
"RTN","HLEVUTI2",251,0)
 W !
"RTN","HLEVUTI2",252,0)
 D ^DIR
"RTN","HLEVUTI2",253,0)
 QUIT:$D(DIRUT)!($D(DTOUT))!($D(DUOUT)) "" ;->
"RTN","HLEVUTI2",254,0)
 Q Y
"RTN","HLEVUTI2",255,0)
 ;
"RTN","HLEVUTI2",256,0)
MAIL ; All queues are done.  Mail notification to DUZ...
"RTN","HLEVUTI2",257,0)
 N NO,TEXT,XMDUZ,XMSUB,XMTEXT,XMZ
"RTN","HLEVUTI2",258,0)
 S XMDUZ=.5,XMSUB="M Code Requeue Utility"
"RTN","HLEVUTI2",259,0)
 S XMTEXT="^TMP("_$J_",""HLMAILMSG"","
"RTN","HLEVUTI2",260,0)
 KILL ^TMP($J,"HLMAILMSG")
"RTN","HLEVUTI2",261,0)
 S NO=0
"RTN","HLEVUTI2",262,0)
 D MAILADD("The queuing of jobs to "_$TR($G(MRTN),"~",U)_" has finished.  #"_$G(HLRUNS)_" jobs were queued.")
"RTN","HLEVUTI2",263,0)
 ;
"RTN","HLEVUTI2",264,0)
 I HLRUNS<31 D
"RTN","HLEVUTI2",265,0)
 .  N DATA,LN,TASK,TXT
"RTN","HLEVUTI2",266,0)
 .  S LN=$$REPEAT^XLFSTR(" ",74)
"RTN","HLEVUTI2",267,0)
 .  D MAILADD("")
"RTN","HLEVUTI2",268,0)
 .  D MAILADD("Task#         Start        Finish")
"RTN","HLEVUTI2",269,0)
 .  D MAILADD($$REPEAT^XLFSTR("-",74))
"RTN","HLEVUTI2",270,0)
 .  S TASK=0
"RTN","HLEVUTI2",271,0)
 .  F  S TASK=$O(HLRUNS(TASK)) Q:'TASK  D
"RTN","HLEVUTI2",272,0)
 .  .  S DATA=HLRUNS(TASK)
"RTN","HLEVUTI2",273,0)
 .  .  S TXT=$E(TASK_LN,1,14) ; Task#
"RTN","HLEVUTI2",274,0)
 .  .  S TXT=TXT_$E($$SDT^HLEVX001(+DATA)_LN,1,13) ; Start time
"RTN","HLEVUTI2",275,0)
 .  .  S TXT=TXT_$E($$SDT^HLEVX001($P(DATA,U,2))_LN,1,13) ; End time
"RTN","HLEVUTI2",276,0)
 .  .  I $D(^XTMP("HLEVREQ-"_TASK,"T")) D
"RTN","HLEVUTI2",277,0)
 .  .  .  S TXT=TXT_"Data in ^XTMP(""HLEVREQ-"_TASK_""",""T"")"
"RTN","HLEVUTI2",278,0)
 .  .  D MAILADD(TXT)
"RTN","HLEVUTI2",279,0)
 ;
"RTN","HLEVUTI2",280,0)
 S XMY(DUZ)=""
"RTN","HLEVUTI2",281,0)
 D ^XMD
"RTN","HLEVUTI2",282,0)
 I '$D(ZTQUEUED) W !!,"Mail message #",$G(XMZ),"..."
"RTN","HLEVUTI2",283,0)
 KILL ^TMP($J,"HLMAILMSG")
"RTN","HLEVUTI2",284,0)
 ;
"RTN","HLEVUTI2",285,0)
 Q
"RTN","HLEVUTI2",286,0)
 ;
"RTN","HLEVUTI2",287,0)
MAILADD(T) S NO=$G(NO)+1,^TMP($J,"HLMAILMSG",NO)=T
"RTN","HLEVUTI2",288,0)
 Q
"RTN","HLEVUTI2",289,0)
 ;
"RTN","HLEVUTI2",290,0)
 ;==================================================================
"RTN","HLEVUTI2",291,0)
 ;
"RTN","HLEVUTI2",292,0)
SAVE(TXT) ; Save one line of text into ^XTMP
"RTN","HLEVUTI2",293,0)
 ; XTMP -- req
"RTN","HLEVUTI2",294,0)
 N NO
"RTN","HLEVUTI2",295,0)
 QUIT:$G(XTMP)']""  ;->
"RTN","HLEVUTI2",296,0)
 QUIT:$G(^XTMP(XTMP,0))']""  ;->
"RTN","HLEVUTI2",297,0)
 S NO=$O(^XTMP(XTMP,"T",":"),-1)+1
"RTN","HLEVUTI2",298,0)
 S ^XTMP(XTMP,"T",+NO)=$G(TXT)
"RTN","HLEVUTI2",299,0)
 Q
"RTN","HLEVUTI2",300,0)
 ;
"RTN","HLEVUTI2",301,0)
KILLALL ; Kill **ALL** run data for all jobs!!!!  (BE CARFUL)
"RTN","HLEVUTI2",302,0)
 N DATA,XTMP
"RTN","HLEVUTI2",303,0)
 ;
"RTN","HLEVUTI2",304,0)
 I $O(^XTMP("HLEVREQ-"))'["HLEVREQ-" D  QUIT  ;->
"RTN","HLEVUTI2",305,0)
 .  W !!,"No data exists... "
"RTN","HLEVUTI2",306,0)
 .  W !
"RTN","HLEVUTI2",307,0)
 ;
"RTN","HLEVUTI2",308,0)
 W !!,"Existing M code job run data..."
"RTN","HLEVUTI2",309,0)
 ;
"RTN","HLEVUTI2",310,0)
 W !
"RTN","HLEVUTI2",311,0)
 S XTMP="HLEVREQ-"
"RTN","HLEVUTI2",312,0)
 F  S XTMP=$O(^XTMP(XTMP)) Q:$E(XTMP,1,8)'="HLEVREQ-"  D
"RTN","HLEVUTI2",313,0)
 .  S DATA=$G(^XTMP(XTMP,0)) Q:DATA']""  ;->
"RTN","HLEVUTI2",314,0)
 .  W !,"Started: ",$$SDT^HLEVX001($P(DATA,U,2))
"RTN","HLEVUTI2",315,0)
 .  W $S($P(DATA,U,7)']"":"    Job still running!!",1:"   finished: "_$$SDT^HLEVX001(+$P(DATA,U,7)))
"RTN","HLEVUTI2",316,0)
 .  W "     ",$P(DATA,U,8,9),"..."
"RTN","HLEVUTI2",317,0)
 ;
"RTN","HLEVUTI2",318,0)
 W !
"RTN","HLEVUTI2",319,0)
 I '$$YN^HLCSRPT4("OK to delete ALL M Code requeue data","No") D  QUIT  ;->
"RTN","HLEVUTI2",320,0)
 .  W "  nothing deleted..."
"RTN","HLEVUTI2",321,0)
 ;
"RTN","HLEVUTI2",322,0)
 W !
"RTN","HLEVUTI2",323,0)
 S XTMP="HLEVREQ-"
"RTN","HLEVUTI2",324,0)
 F  S XTMP=$O(^XTMP(XTMP)) Q:$E(XTMP,1,8)'="HLEVREQ-"  D
"RTN","HLEVUTI2",325,0)
 .  W !,"Killing ^XTMP(",XTMP,")..."
"RTN","HLEVUTI2",326,0)
 .  D KILLXTMP(XTMP)
"RTN","HLEVUTI2",327,0)
 ;
"RTN","HLEVUTI2",328,0)
 W !
"RTN","HLEVUTI2",329,0)
 S X=$$BTE^HLCSMON("Press RETURN to exit... ")
"RTN","HLEVUTI2",330,0)
 ;
"RTN","HLEVUTI2",331,0)
 Q
"RTN","HLEVUTI2",332,0)
 ;
"RTN","HLEVUTI2",333,0)
KILLXTMP(XTMP) ; Kill one XTMP entry... (Pass TASK or full reference)
"RTN","HLEVUTI2",334,0)
 I XTMP=+XTMP S XTMP="HLEVREQ-"_XTMP
"RTN","HLEVUTI2",335,0)
 KILL ^XTMP(XTMP)
"RTN","HLEVUTI2",336,0)
 Q
"RTN","HLEVUTI2",337,0)
 ;
"RTN","HLEVUTI2",338,0)
EOR ;HLEVUTI2 - Event Monitor UTILITIES ;5/16/03 14:42
"RTN","HLEVUTI3")
0^43^B20366248
"RTN","HLEVUTI3",1,0)
HLEVUTI3 ;O-OIFO/LJA - Event Monitor UTILITIES ;02/04/2004 14:42
"RTN","HLEVUTI3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVUTI3",3,0)
 ;
"RTN","HLEVUTI3",4,0)
MOVETMP(FILE,IEN,GBLSV) ; Move ^UTILITY data into ^TMP and prep it...
"RTN","HLEVUTI3",5,0)
 N DATA,FLD,FLDLEN,FLDNM,GBL,MNO,NO,NUM,STR
"RTN","HLEVUTI3",6,0)
 ;
"RTN","HLEVUTI3",7,0)
 KILL ^TMP($J,"HLTMP")
"RTN","HLEVUTI3",8,0)
 ;
"RTN","HLEVUTI3",9,0)
 S GBL=$NA(^UTILITY("DIQ1",$J))
"RTN","HLEVUTI3",10,0)
 ;
"RTN","HLEVUTI3",11,0)
 D ADDLN(GBLSV,$$CJ^XLFSTR(" "_FILE_"#: "_IEN_" ",74,"="))
"RTN","HLEVUTI3",12,0)
 ;
"RTN","HLEVUTI3",13,0)
 S FLD=0
"RTN","HLEVUTI3",14,0)
 F  S FLD=$O(@GBL@(FILE,IEN,FLD)) Q:FLD'>0  D
"RTN","HLEVUTI3",15,0)
 .  S FLDNM="["_$P($G(^DD(+FILE,+FLD,0)),U)
"RTN","HLEVUTI3",16,0)
 .  S DATA=$G(@GBL@(FILE,IEN,+FLD,"E"))
"RTN","HLEVUTI3",17,0)
 .  I DATA]"" D  QUIT  ;->
"RTN","HLEVUTI3",18,0)
 .  .  S NO=$O(^TMP($J,"HLTMP",":"),-1)+1
"RTN","HLEVUTI3",19,0)
 .  .  S ^TMP($J,"HLTMP",+NO)=FLDNM_U_FLD_U_DATA_"]"
"RTN","HLEVUTI3",20,0)
 .  S MNO=0,FLD(1)=FLD
"RTN","HLEVUTI3",21,0)
 .  F  S MNO=$O(@GBL@(FILE,IEN,FLD,"E",MNO)) Q:MNO'>0  D
"RTN","HLEVUTI3",22,0)
 .  .  S DATA=$G(@GBL@(FILE,IEN,FLD,"E",+MNO))
"RTN","HLEVUTI3",23,0)
 .  .  S NO=$O(^TMP($J,"HLTMP",":"),-1)+1
"RTN","HLEVUTI3",24,0)
 .  .  S ^TMP($J,"HLTMP",+NO)=FLDNM_U_FLD(1)_U_DATA_"]"
"RTN","HLEVUTI3",25,0)
 ;
"RTN","HLEVUTI3",26,0)
 S NO=0,STR=""
"RTN","HLEVUTI3",27,0)
 F  S NO=$O(^TMP($J,"HLTMP",NO)) Q:NO'>0  D
"RTN","HLEVUTI3",28,0)
 .  S DATA=^TMP($J,"HLTMP",NO) QUIT:DATA']""  ;->
"RTN","HLEVUTI3",29,0)
 .  S FLDNM=$P(DATA,U),FLD=$P(DATA,U,2),DATA=$P(DATA,U,3,999)
"RTN","HLEVUTI3",30,0)
 .  I FILE=772,FLD=200 S FLDNM="MSG"
"RTN","HLEVUTI3",31,0)
 .  S FLDNM=$S(FLDNM]"":FLDNM_": ",1:""),FLDLEN=$L(FLDNM)
"RTN","HLEVUTI3",32,0)
 .  S DATA=$$LOW^XLFSTR(FLDNM)_DATA
"RTN","HLEVUTI3",33,0)
 .  I FLD']"" D  QUIT  ;-> standalone line...
"RTN","HLEVUTI3",34,0)
 .  .  I STR]"" D ADDLN(GBLSV,STR)
"RTN","HLEVUTI3",35,0)
 .  .  D ADDLN(GBLSV,"     "_DATA)
"RTN","HLEVUTI3",36,0)
 .  I ($L(STR)+$L(DATA)+3)>74 D
"RTN","HLEVUTI3",37,0)
 .  .  I STR]"" D ADDLN(GBLSV,STR)
"RTN","HLEVUTI3",38,0)
 .  .  S STR=""
"RTN","HLEVUTI3",39,0)
 .  S STR=STR_$$PAD(STR,$L(DATA))_DATA QUIT:$L(STR)<74  ;->
"RTN","HLEVUTI3",40,0)
 .  F  D  QUIT:STR']""
"RTN","HLEVUTI3",41,0)
 .  .  D ADDLN(GBLSV,$E(STR,1,74))
"RTN","HLEVUTI3",42,0)
 .  .  S STR=$E(STR,75,999) QUIT:STR']""  ;->
"RTN","HLEVUTI3",43,0)
 .  .  S STR="     "_STR
"RTN","HLEVUTI3",44,0)
 I STR]"" D ADDLN(GBLSV,STR)
"RTN","HLEVUTI3",45,0)
 ;
"RTN","HLEVUTI3",46,0)
 KILL ^TMP($J,"HLTMP")
"RTN","HLEVUTI3",47,0)
 ;
"RTN","HLEVUTI3",48,0)
 Q
"RTN","HLEVUTI3",49,0)
 ;
"RTN","HLEVUTI3",50,0)
PAD(STR,LEN) ; Add spaces to right justify...
"RTN","HLEVUTI3",51,0)
 QUIT:STR']"" "" ;->
"RTN","HLEVUTI3",52,0)
 I ($L(STR)+LEN)<40 QUIT "   " ;->
"RTN","HLEVUTI3",53,0)
 Q $$REPEAT^XLFSTR(" ",74-$L(STR)-LEN)
"RTN","HLEVUTI3",54,0)
 ;
"RTN","HLEVUTI3",55,0)
ADDLN(GBLSV,DATA) ; Add one line of text...
"RTN","HLEVUTI3",56,0)
 N NUM
"RTN","HLEVUTI3",57,0)
 S NUM=$O(^TMP($J,GBLSV,":"),-1)+1
"RTN","HLEVUTI3",58,0)
 S ^TMP($J,GBLSV,+NUM)=DATA
"RTN","HLEVUTI3",59,0)
 Q
"RTN","HLEVUTI3",60,0)
 ;
"RTN","HLEVUTI3",61,0)
LASTIEN ; Display last IEN of files 772 & 773 every 15 seconds...
"RTN","HLEVUTI3",62,0)
 N B,CT,DIFF,DIR,DIROUT,DIRUT,DTOUT,DUOUT,IEN772,IEN773
"RTN","HLEVUTI3",63,0)
 N LAST772,LAST773,STOP,TIMEOUT,X,Y
"RTN","HLEVUTI3",64,0)
 ;
"RTN","HLEVUTI3",65,0)
 W @IOF,$$CJ^XLFSTR("File 772 & 773 IEN Display",IOM)
"RTN","HLEVUTI3",66,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVUTI3",67,0)
 ;
"RTN","HLEVUTI3",68,0)
 W !!,"This API displays the last internal entry number (IEN) in the following files:"
"RTN","HLEVUTI3",69,0)
 W !!,"  * HL Message Text file (#772)."
"RTN","HLEVUTI3",70,0)
 W !,"  * HL Message Administration file (#773)."
"RTN","HLEVUTI3",71,0)
 W !!,"The last IEN in these files are recollected and redisplayed every 15 seconds."
"RTN","HLEVUTI3",72,0)
 W !,"After every display of these IENs, you may take the following actions:"
"RTN","HLEVUTI3",73,0)
 W !!,"  * Do nothing, & the information will be redisplayed in 15 seconds."
"RTN","HLEVUTI3",74,0)
 W !,"    (You may change the refresh seconds by entering a number of seconds"
"RTN","HLEVUTI3",75,0)
 W !,"    and pressing RETURN.)"
"RTN","HLEVUTI3",76,0)
 W !!,"  * Hit return to force information redisplay."
"RTN","HLEVUTI3",77,0)
 W !!,"  * Enter an uparrow ('^') and press RETURN to exit."
"RTN","HLEVUTI3",78,0)
 ;
"RTN","HLEVUTI3",79,0)
 F  QUIT:($Y+3)>IOSL  W !
"RTN","HLEVUTI3",80,0)
 QUIT:$$BTE^HLCSMON("Press RETURN to start, or '^' to exit... ")  ;->
"RTN","HLEVUTI3",81,0)
 ;
"RTN","HLEVUTI3",82,0)
 W @IOF
"RTN","HLEVUTI3",83,0)
 S X=$$SITE^VASITE W $$CJ^XLFSTR(" "_$P(X,U,2)_" ["_$P(X,U,3)_"] ",IOM,"=")
"RTN","HLEVUTI3",84,0)
 D HDRIEN
"RTN","HLEVUTI3",85,0)
 ;
"RTN","HLEVUTI3",86,0)
 S CT=0,TIMEOUT=15,B="|"
"RTN","HLEVUTI3",87,0)
 S (IEN772,IEN773,LAST772,LAST773)=""
"RTN","HLEVUTI3",88,0)
 ;
"RTN","HLEVUTI3",89,0)
 F  D  QUIT:STOP
"RTN","HLEVUTI3",90,0)
 .  S CT=CT+1
"RTN","HLEVUTI3",91,0)
 .  S IEN772=$O(^HL(772,":"),-1),IEN773=$O(^HLMA(":"),-1)
"RTN","HLEVUTI3",92,0)
 .  I '(CT#22) W !! D HDRIEN
"RTN","HLEVUTI3",93,0)
 .  W !,$$SDT($$NOW^XLFDT),?19,B
"RTN","HLEVUTI3",94,0)
 .  W ?21,IEN772,?36,$$DIFFIEN(IEN772,LAST772),?45,B
"RTN","HLEVUTI3",95,0)
 .  W ?47,IEN773,?61,$$DIFFIEN(IEN773,LAST773),?73,B
"RTN","HLEVUTI3",96,0)
 .  S LAST772=IEN772,LAST773=IEN773
"RTN","HLEVUTI3",97,0)
 .  S STOP=1
"RTN","HLEVUTI3",98,0)
 .  R " ",X:TIMEOUT
"RTN","HLEVUTI3",99,0)
 .  QUIT:X[U  ;->
"RTN","HLEVUTI3",100,0)
 .  S STOP=0
"RTN","HLEVUTI3",101,0)
 .  QUIT:'$T  ;-> Timed out...
"RTN","HLEVUTI3",102,0)
 .  I X=+X,X>0 S TIMEOUT=X D  QUIT  ;->
"RTN","HLEVUTI3",103,0)
 .  .  W """"
"RTN","HLEVUTI3",104,0)
 .  ; User pressed RETURN...
"RTN","HLEVUTI3",105,0)
 .  W "<ret>"
"RTN","HLEVUTI3",106,0)
 ;
"RTN","HLEVUTI3",107,0)
 Q
"RTN","HLEVUTI3",108,0)
 ;
"RTN","HLEVUTI3",109,0)
DIFFIEN(LAST,BEFORE) ; Return number new entries right justified in 3 col's
"RTN","HLEVUTI3",110,0)
 N DIFF
"RTN","HLEVUTI3",111,0)
 QUIT:LAST'>0!(BEFORE'>0) "" ;->
"RTN","HLEVUTI3",112,0)
 S DIFF=LAST-BEFORE QUIT:DIFF'>0 "" ;->
"RTN","HLEVUTI3",113,0)
 QUIT $J(DIFF,3)
"RTN","HLEVUTI3",114,0)
 ;
"RTN","HLEVUTI3",115,0)
HDRIEN ;
"RTN","HLEVUTI3",116,0)
 N B
"RTN","HLEVUTI3",117,0)
 S B="|"
"RTN","HLEVUTI3",118,0)
 W:$X>0 !
"RTN","HLEVUTI3",119,0)
 W "Time",?19,B,?21,"LAST-772-IEN",?36,"#772",?45,B
"RTN","HLEVUTI3",120,0)
 W ?47,"LAST-773-IEN",?61,"#773",?73,B
"RTN","HLEVUTI3",121,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVUTI3",122,0)
 Q
"RTN","HLEVUTI3",123,0)
 ;
"RTN","HLEVUTI3",124,0)
SDT(FMTIME) ; Return DD/MM/YY@HH:MM:SS
"RTN","HLEVUTI3",125,0)
 N DATE,TIME
"RTN","HLEVUTI3",126,0)
 QUIT:$G(FMTIME)'?7N.E "" ;->
"RTN","HLEVUTI3",127,0)
 S TIME=$S(FMTIME?7N1"."1.N:"@"_$E($P($$FMTE^XLFDT(FMTIME),"@",2)_":00:00",1,8),1:"")
"RTN","HLEVUTI3",128,0)
 S DATE=$E(FMTIME,4,5)_"/"_$E(FMTIME,6,7)_"/"_$E(FMTIME,2,3)
"RTN","HLEVUTI3",129,0)
 Q DATE_TIME
"RTN","HLEVUTI3",130,0)
 ;
"RTN","HLEVUTI3",131,0)
EOR ;HLEVUTI3 - Event Monitor UTILITIES ;5/16/03 14:42
"RTN","HLEVUTIL")
0^14^B55321603
"RTN","HLEVUTIL",1,0)
HLEVUTIL ;O-OIFO/LJA - Event Monitor UTILITIES ;02/04/2004 14:42
"RTN","HLEVUTIL",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVUTIL",3,0)
 ;
"RTN","HLEVUTIL",4,0)
SLM() ; Return info to Systems Link Monitor [HLCSMON1]...
"RTN","HLEVUTIL",5,0)
 N BAD,DATA,DATE,DAY,DOWN,FIEN,HR,IEN,IOBON,IOBOFF,LASTDT,MIN,SEC,X
"RTN","HLEVUTIL",6,0)
 ;
"RTN","HLEVUTIL",7,0)
 S X="IOBOFF;IOBON" D ENDR^%ZISS
"RTN","HLEVUTIL",8,0)
 S DOWN="Monitor "_IOBON_"DOWN"_IOBOFF
"RTN","HLEVUTIL",9,0)
 ;
"RTN","HLEVUTIL",10,0)
 I $P($G(^HLEV(776.999,1,0)),U,2)'="A" D  QUIT DOWN ;->
"RTN","HLEVUTIL",11,0)
 .  S DOWN="Monitor "_IOBON_"STOPPED"_IOBOFF
"RTN","HLEVUTIL",12,0)
 ;
"RTN","HLEVUTIL",13,0)
 S LASTDT=":",FIEN=0
"RTN","HLEVUTIL",14,0)
 F  S LASTDT=$O(^HLEV(776.2,"B",LASTDT),-1) Q:'LASTDT!(FIEN)  D
"RTN","HLEVUTIL",15,0)
 .  S IEN=":"
"RTN","HLEVUTIL",16,0)
 .  F  S IEN=$O(^HLEV(776.2,"B",+LASTDT,IEN),-1) Q:'IEN!(FIEN)  D
"RTN","HLEVUTIL",17,0)
 .  .  S DATA=$G(^HLEV(776.2,+IEN,0)) QUIT:$P(DATA,U,4)'="Q"  ;->
"RTN","HLEVUTIL",18,0)
 .  .  S FIEN=IEN
"RTN","HLEVUTIL",19,0)
 I 'FIEN QUIT DOWN ;->
"RTN","HLEVUTIL",20,0)
 S DATA=$G(^HLEV(776.2,+FIEN,0))
"RTN","HLEVUTIL",21,0)
 S DATE=$P(DATA,U,6) QUIT:DATE'?7N1"."1.N DOWN ;->
"RTN","HLEVUTIL",22,0)
 S DATE=$$FMTH^XLFDT(DATE),DATE(1)=$$SEC^HLEVMST0(DATE)
"RTN","HLEVUTIL",23,0)
 S NOW=$H,NOW(1)=$$SEC^HLEVMST0(NOW)
"RTN","HLEVUTIL",24,0)
 I DATE(1)<NOW(1) D  QUIT $S(BAD:DOWN,1:"Monitor current") ;->
"RTN","HLEVUTIL",25,0)
 .  S BAD=0
"RTN","HLEVUTIL",26,0)
 .  QUIT:(NOW(1)-DATE(1))<(5*60)  ;-> OK if less than 5 minutes old
"RTN","HLEVUTIL",27,0)
 .  S BAD=1,DOWN="Monitor "_IOBON_"OVERDUE"_IOBOFF
"RTN","HLEVUTIL",28,0)
 S DIFF=$$DIFFDH^HLCSFMN1(NOW,DATE)
"RTN","HLEVUTIL",29,0)
 S DAY=+DIFF,DIFF=$TR($P(DIFF,U,2),":",U)
"RTN","HLEVUTIL",30,0)
 S HR=+DIFF+(DAY*24),MIN=+$P(DIFF,U,2),SEC=+$P(DIFF,U,3)
"RTN","HLEVUTIL",31,0)
 S:SEC>30 MIN=MIN+1
"RTN","HLEVUTIL",32,0)
 S HR=HR+MIN/60,HR=$J(HR,"",1)
"RTN","HLEVUTIL",33,0)
 Q "Monitor current [next job "_HR_" hr]"
"RTN","HLEVUTIL",34,0)
 ;
"RTN","HLEVUTIL",35,0)
DHMSFM(DTFM,NOW,LONG) ; Convert Fileman d/t to Days-Hr-Min-Sec
"RTN","HLEVUTIL",36,0)
 N HORO
"RTN","HLEVUTIL",37,0)
 QUIT:$G(DTFM)'?7N.1".".10N "" ;->
"RTN","HLEVUTIL",38,0)
 S NOW=$$FMTH^XLFDT($S($G(NOW)?7N.E:NOW,1:$$NOW^XLFDT)) ; Default
"RTN","HLEVUTIL",39,0)
 S HORO=$$FMTH^XLFDT(DTFM)
"RTN","HLEVUTIL",40,0)
 Q $$DHMSH(HORO,NOW,LONG)
"RTN","HLEVUTIL",41,0)
 ;
"RTN","HLEVUTIL",42,0)
DHMSH(DTH,NOW,LONG) ; Convert HORO d/t to Days-Hr-Min-Sec
"RTN","HLEVUTIL",43,0)
 N DIFF,FUTURE,TIME,X
"RTN","HLEVUTIL",44,0)
 S LONG=+$G(LONG)
"RTN","HLEVUTIL",45,0)
 QUIT:$G(DTH)'?5N1","1.N "" ;->
"RTN","HLEVUTIL",46,0)
 S NOW=$S($G(NOW)]"":NOW,1:$H),FUTURE=0
"RTN","HLEVUTIL",47,0)
 I +NOW<DTH!(+NOW=+DTH&($P(NOW,",",2)<$P(DTH,",",2))) D
"RTN","HLEVUTIL",48,0)
 .  S X=DTH,DTH=NOW,NOW=X,FUTURE=1
"RTN","HLEVUTIL",49,0)
 S DIFF=$$DIFFDH^HLCSFMN1(DTH,NOW)
"RTN","HLEVUTIL",50,0)
 S TIME=""
"RTN","HLEVUTIL",51,0)
 D C($P(DIFF,U),$S(LONG:$S(+$P(DIFF,U)>1:" days",1:" day"),1:"d"))
"RTN","HLEVUTIL",52,0)
 D C($P($P(DIFF,U,2),":"),$S(LONG:" hr",1:"h"))
"RTN","HLEVUTIL",53,0)
 D C($P($P(DIFF,U,2),":",2),$S(LONG:" min",1:"m"))
"RTN","HLEVUTIL",54,0)
 D C($P($P(DIFF,U,2),":",3),$S(LONG:" sec",1:"s"))
"RTN","HLEVUTIL",55,0)
 F  Q:$E(TIME)'=" "  S TIME=$E(TIME,2,999)
"RTN","HLEVUTIL",56,0)
 F  Q:$E(TIME,$L(TIME))'=" "  S TIME=$E(TIME,1,$L(TIME)-1)
"RTN","HLEVUTIL",57,0)
 I FUTURE,TIME]"" S TIME="["_TIME_"]"
"RTN","HLEVUTIL",58,0)
 Q TIME
"RTN","HLEVUTIL",59,0)
 ;
"RTN","HLEVUTIL",60,0)
C(NO,UN) ; Convert to #[UN]...
"RTN","HLEVUTIL",61,0)
 I NO'>0 QUIT  ;->
"RTN","HLEVUTIL",62,0)
 S TIME=TIME_$S(TIME]"":" ",1:"")_" "_+NO_UN
"RTN","HLEVUTIL",63,0)
 Q
"RTN","HLEVUTIL",64,0)
 ;
"RTN","HLEVUTIL",65,0)
WPTXT(FILE,IEN,NODE,DDNO,TXT) ; Add text to multiple WP field...
"RTN","HLEVUTIL",66,0)
 N NO
"RTN","HLEVUTIL",67,0)
 QUIT:$G(^HLEV(+FILE,+IEN,0))']""  ;->
"RTN","HLEVUTIL",68,0)
 S NO=$O(^HLEV(+FILE,+IEN,NODE,":"),-1)+1
"RTN","HLEVUTIL",69,0)
 S ^HLEV(+FILE,+IEN,NODE,+NO,0)=$G(TXT)
"RTN","HLEVUTIL",70,0)
 S ^HLEV(+FILE,+IEN,NODE,0)=U_DDNO_U_NO_U_NO
"RTN","HLEVUTIL",71,0)
 Q
"RTN","HLEVUTIL",72,0)
 ;
"RTN","HLEVUTIL",73,0)
DOLRO(SUB,KILL,DAYS) ; Store data in ^XTMP("HLEV-"_SUB)...
"RTN","HLEVUTIL",74,0)
 N NO,NOW,X
"RTN","HLEVUTIL",75,0)
 ;
"RTN","HLEVUTIL",76,0)
 ; Defaults and setup variables...
"RTN","HLEVUTIL",77,0)
 S:$E(SUB,1,5)'="HLEV-" SUB="HLEV-"_SUB
"RTN","HLEVUTIL",78,0)
 S:$G(DAYS)'>0 DAYS=2
"RTN","HLEVUTIL",79,0)
 S NOW=$$NOW^XLFDT
"RTN","HLEVUTIL",80,0)
 ;
"RTN","HLEVUTIL",81,0)
 ; KILL?
"RTN","HLEVUTIL",82,0)
 I $G(KILL)=1 KILL ^XTMP(SUB)
"RTN","HLEVUTIL",83,0)
 ;
"RTN","HLEVUTIL",84,0)
 ; Always reset 0 node...
"RTN","HLEVUTIL",85,0)
 S ^XTMP(SUB,0)=$$FMADD^XLFDT(NOW,DAYS)_U_NOW_"^HL7 Event Monitoring debug code (LJA)"
"RTN","HLEVUTIL",86,0)
 ;
"RTN","HLEVUTIL",87,0)
 ; Store data...
"RTN","HLEVUTIL",88,0)
 S NO=$O(^XTMP(SUB,":"),-1)+1
"RTN","HLEVUTIL",89,0)
 S X=$NA(^XTMP(SUB,NO)),X=$E(X,1,$L(X)-1)_"," D DOLRO^%ZOSV
"RTN","HLEVUTIL",90,0)
 ;
"RTN","HLEVUTIL",91,0)
 Q
"RTN","HLEVUTIL",92,0)
 ;
"RTN","HLEVUTIL",93,0)
UNQUEUE ; Unqueue any future master jobs...
"RTN","HLEVUTIL",94,0)
 N CT,DATA,IEN,LASTDT
"RTN","HLEVUTIL",95,0)
 S LASTDT=":",CT=0
"RTN","HLEVUTIL",96,0)
 F  S LASTDT=$O(^HLEV(776.2,"B",LASTDT),-1) Q:'LASTDT!(CT>4)  D
"RTN","HLEVUTIL",97,0)
 .  S IEN=":"
"RTN","HLEVUTIL",98,0)
 .  F  S IEN=$O(^HLEV(776.2,"B",+LASTDT,IEN),-1) Q:'IEN!(CT>4)  D
"RTN","HLEVUTIL",99,0)
 .  .  S DATA=$G(^HLEV(776.2,+IEN,0)) QUIT:DATA']""  ;->
"RTN","HLEVUTIL",100,0)
 .  .  QUIT:$P(DATA,U,4)'="Q"  ;-> Not queued for future...
"RTN","HLEVUTIL",101,0)
 .  .  S TASKNO=$P(DATA,U,5) QUIT:TASKNO'>0  ;->
"RTN","HLEVUTIL",102,0)
 .  .  D UNQ(+IEN,+TASKNO,"Aborted by installation pre-init.")
"RTN","HLEVUTIL",103,0)
 Q
"RTN","HLEVUTIL",104,0)
 ;
"RTN","HLEVUTIL",105,0)
UNQ(IEN7762,TASKNO,REASON) ; Unqueue Taskman task and mark 776.2 properly...
"RTN","HLEVUTIL",106,0)
 N ZTSK
"RTN","HLEVUTIL",107,0)
 S ZTSK=+TASKNO
"RTN","HLEVUTIL",108,0)
 D DQ^%ZTLOAD
"RTN","HLEVUTIL",109,0)
 D UPDFLDM^HLEVMST(+IEN7762,4,"A")
"RTN","HLEVUTIL",110,0)
 D UPDFLDM^HLEVMST(+IEN7762,50,REASON)
"RTN","HLEVUTIL",111,0)
 Q
"RTN","HLEVUTIL",112,0)
 ;
"RTN","HLEVUTIL",113,0)
PURGEV(HLEVIENM) ; Purge master job entries...
"RTN","HLEVUTIL",114,0)
 N CUTIME,IEN,LOOPTM,NOPURG,RETHRM
"RTN","HLEVUTIL",115,0)
 ;
"RTN","HLEVUTIL",116,0)
 S NOPURG=0
"RTN","HLEVUTIL",117,0)
 ;
"RTN","HLEVUTIL",118,0)
 ; Get retention time (HR) for master job data...
"RTN","HLEVUTIL",119,0)
 S RETHRM=$O(^HLEV(776.999,":"),-1)
"RTN","HLEVUTIL",120,0)
 S RETHRM=$P($G(^HLEV(776.999,+RETHRM,0)),U,4)
"RTN","HLEVUTIL",121,0)
 S RETHRM=$S(RETHRM>0:RETHRM,1:96) ; Default to 96 hours
"RTN","HLEVUTIL",122,0)
 ;
"RTN","HLEVUTIL",123,0)
 ; Cutoff time...
"RTN","HLEVUTIL",124,0)
 S CUTIME=$$FMADD^XLFDT($$NOW^XLFDT,0,-RETHRM)
"RTN","HLEVUTIL",125,0)
 ;
"RTN","HLEVUTIL",126,0)
 F  S CUTIME=$O(^HLEV(776,"B",CUTIME),-1) Q:CUTIME'>0  D
"RTN","HLEVUTIL",127,0)
 .  S IEN=0
"RTN","HLEVUTIL",128,0)
 .  F  S IEN=$O(^HLEV(776,"B",CUTIME,IEN)) Q:IEN'>0  D
"RTN","HLEVUTIL",129,0)
 .  .  S NOPURG=NOPURG+1
"RTN","HLEVUTIL",130,0)
 .  .  D DELETE(776,+IEN)
"RTN","HLEVUTIL",131,0)
 ;
"RTN","HLEVUTIL",132,0)
 Q NOPURG
"RTN","HLEVUTIL",133,0)
 ;
"RTN","HLEVUTIL",134,0)
PURGEME(IEN7762) ; Purge events "pointed to" by 776.2...
"RTN","HLEVUTIL",135,0)
 ; NOPURG -- req
"RTN","HLEVUTIL",136,0)
 N DATA,IEN776,MIEN
"RTN","HLEVUTIL",137,0)
 S MIEN=0
"RTN","HLEVUTIL",138,0)
 F  S MIEN=$O(^HLEV(776.2,+IEN7762,51,MIEN)) Q:'MIEN  D
"RTN","HLEVUTIL",139,0)
 .  S DATA=$G(^HLEV(776.2,+IEN7762,51,MIEN,0)) Q:DATA']""  ;->
"RTN","HLEVUTIL",140,0)
 .  S IEN776=+DATA QUIT:$G(^HLEV(776,+IEN776,0))']""  ;->
"RTN","HLEVUTIL",141,0)
 .  D DELETE(776,+IEN776)
"RTN","HLEVUTIL",142,0)
 .  S NOPURG=$G(NOPURG)+1
"RTN","HLEVUTIL",143,0)
 Q
"RTN","HLEVUTIL",144,0)
 ;
"RTN","HLEVUTIL",145,0)
 ;
"RTN","HLEVUTIL",146,0)
 ;
"RTN","HLEVUTIL",147,0)
 ;
"RTN","HLEVUTIL",148,0)
 ;
"RTN","HLEVUTIL",149,0)
 ;                          GENERAL CODE
"RTN","HLEVUTIL",150,0)
PURGEALL(HLEVIENM) ; Purge all EVENT MONITORing files...
"RTN","HLEVUTIL",151,0)
 N NOPURGE,NOPURGM,TXT
"RTN","HLEVUTIL",152,0)
 ;
"RTN","HLEVUTIL",153,0)
 QUIT:$G(^HLEV(776.2,+$G(HLEVIENM),0))']""  ;->
"RTN","HLEVUTIL",154,0)
 ;
"RTN","HLEVUTIL",155,0)
 ; Check parameter...
"RTN","HLEVUTIL",156,0)
 QUIT:$P($G(^HLEV(776.999,1,0)),U,2)'="A"  ;->
"RTN","HLEVUTIL",157,0)
 ;
"RTN","HLEVUTIL",158,0)
 S NOPURGM=$$PURGEM^HLEVMST(HLEVIENM) ; Master job data...
"RTN","HLEVUTIL",159,0)
 S NOPURGE=$$PURGEV(HLEVIENM) ; Event job data...
"RTN","HLEVUTIL",160,0)
 QUIT:(NOPURGE+NOPURGM)'>0  ;->
"RTN","HLEVUTIL",161,0)
 S TXT="Purges: "_$S(NOPURGE:"#"_NOPURGE_" events.  ",1:"")_$S(NOPURGM:"#"_NOPURGM_" master jobs.  ",1:"")
"RTN","HLEVUTIL",162,0)
 D UPDFLDM^HLEVMST(+HLEVIENM,50,TXT)
"RTN","HLEVUTIL",163,0)
 ;
"RTN","HLEVUTIL",164,0)
 Q
"RTN","HLEVUTIL",165,0)
 ;
"RTN","HLEVUTIL",166,0)
DELETE(FILE,IEN) ; Delete entry...
"RTN","HLEVUTIL",167,0)
 N DA,DIK
"RTN","HLEVUTIL",168,0)
 QUIT:$G(^HLEV(+$G(FILE),+$G(IEN),0))']""  ;->
"RTN","HLEVUTIL",169,0)
 S DA=+IEN,DIK="^HLEV("_$G(FILE)_","
"RTN","HLEVUTIL",170,0)
 D ^DIK
"RTN","HLEVUTIL",171,0)
 Q
"RTN","HLEVUTIL",172,0)
 ;
"RTN","HLEVUTIL",173,0)
REMOVALL ; Remove all Event Monitor Job (#776) and HL7 Monitor Master
"RTN","HLEVUTIL",174,0)
 ; Job (#776.2) data.  Leave only setup file (#776.1 & 776.999)
"RTN","HLEVUTIL",175,0)
 ; data untouched.
"RTN","HLEVUTIL",176,0)
 N FILE,NODE
"RTN","HLEVUTIL",177,0)
 W @IOF,$$CJ^XLFSTR("Purging of 776 and 776.2 (non-setup) Data",IOM)
"RTN","HLEVUTIL",178,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVUTIL",179,0)
 W !
"RTN","HLEVUTIL",180,0)
 I $O(^HLEV(776,0))'>0&($O(^HLEV(776.2,0))'>0) D  QUIT  ;->
"RTN","HLEVUTIL",181,0)
 .  W !,"There is no data to delete..."
"RTN","HLEVUTIL",182,0)
 F FILE=776,776.2 D
"RTN","HLEVUTIL",183,0)
 .  I $O(^HLEV(+FILE,0))'>0 D  QUIT  ;->
"RTN","HLEVUTIL",184,0)
 .  .  W !,"No data to delete for file ",FILE,"..."
"RTN","HLEVUTIL",185,0)
 .  S X=$$YN^HLCSRPT4("OK to delete file "_FILE_" data","No") I 'X D  QUIT  ;->
"RTN","HLEVUTIL",186,0)
 .  .  W " ... not deleted ..."
"RTN","HLEVUTIL",187,0)
 .  W " ... deleting!!"
"RTN","HLEVUTIL",188,0)
 .  S NODE=$P($G(^HLEV(+FILE,0)),U,1,2)
"RTN","HLEVUTIL",189,0)
 .  KILL ^HLEV(+FILE)
"RTN","HLEVUTIL",190,0)
 .  S ^HLEV(+FILE,0)=NODE
"RTN","HLEVUTIL",191,0)
 Q
"RTN","HLEVUTIL",192,0)
 ;
"RTN","HLEVUTIL",193,0)
YN(PMT,DEF,FF) ; Generic YES/NO DIR call... ;HL*1.6*85
"RTN","HLEVUTIL",194,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLEVUTIL",195,0)
 F X=1:1:$G(FF) W !
"RTN","HLEVUTIL",196,0)
 S DIR(0)="Y",DIR("A")=PMT
"RTN","HLEVUTIL",197,0)
 S:$G(DEF)]"" DIR("B")=DEF
"RTN","HLEVUTIL",198,0)
 D ^DIR
"RTN","HLEVUTIL",199,0)
 QUIT:$D(DIRUT)!($D(DTOUT))!($D(DUOUT)) U ;->
"RTN","HLEVUTIL",200,0)
 QUIT $S(Y=1:1,1:"")
"RTN","HLEVUTIL",201,0)
 ;
"RTN","HLEVUTIL",202,0)
ENDIQ1(FILE,IEN,GBLSV) ; Create ^TMP($J,GBLSV,) data...
"RTN","HLEVUTIL",203,0)
 N DA,DIC,DIQ,DR
"RTN","HLEVUTIL",204,0)
 ;
"RTN","HLEVUTIL",205,0)
 KILL ^TMP($J,GBLSV),^UTILITY("DIQ1",$J)
"RTN","HLEVUTIL",206,0)
 ;
"RTN","HLEVUTIL",207,0)
 ; Sets...
"RTN","HLEVUTIL",208,0)
 S DIC=$G(FILE) QUIT:FILE']""  ;->
"RTN","HLEVUTIL",209,0)
 S DR=$$DICDR(FILE) QUIT:DR']""  ;->
"RTN","HLEVUTIL",210,0)
 S DA=+IEN
"RTN","HLEVUTIL",211,0)
 S GBLSV=$S($G(GBLSV)]"":GBLSV,1:"HLEVDIQ")
"RTN","HLEVUTIL",212,0)
 S DIQ(0)="E"
"RTN","HLEVUTIL",213,0)
 ;
"RTN","HLEVUTIL",214,0)
 ; Generate data...
"RTN","HLEVUTIL",215,0)
 D EN^DIQ1
"RTN","HLEVUTIL",216,0)
 ;
"RTN","HLEVUTIL",217,0)
 ; Add more data (usually multiples)...
"RTN","HLEVUTIL",218,0)
 D ADDIQ(FILE,IEN)
"RTN","HLEVUTIL",219,0)
 ;
"RTN","HLEVUTIL",220,0)
 QUIT:'$D(^UTILITY("DIQ1",$J))  ;->
"RTN","HLEVUTIL",221,0)
 ;
"RTN","HLEVUTIL",222,0)
 ; Prep fields and move into ^TMP...
"RTN","HLEVUTIL",223,0)
 D MOVETMP^HLEVUTI3(FILE,IEN,GBLSV)
"RTN","HLEVUTIL",224,0)
 ;
"RTN","HLEVUTIL",225,0)
 KILL ^UTILITY("DIQ1",$J)
"RTN","HLEVUTIL",226,0)
 ;
"RTN","HLEVUTIL",227,0)
 Q
"RTN","HLEVUTIL",228,0)
 ;
"RTN","HLEVUTIL",229,0)
ADDIQ(FILE,IEN,GBLSV) ; Add more data to ^TMP($J,GBLSV)
"RTN","HLEVUTIL",230,0)
 I FILE=772 D ADDMULT(FILE,"^HL(772,"_IEN_",""IN"")",IEN,10,"MESSAGE TEXT",200)
"RTN","HLEVUTIL",231,0)
 I FILE=773 D ADDMULT(FILE,"^HLMA("_IEN_",""MSH"")",IEN,10,"MSH",200)
"RTN","HLEVUTIL",232,0)
 Q
"RTN","HLEVUTIL",233,0)
 ;
"RTN","HLEVUTIL",234,0)
ADDMULT(FILE,GBL,IEN,LIM,FLDNM,FLD) ; Add LIM number of lines of multiple...
"RTN","HLEVUTIL",235,0)
 N MIEN,NO
"RTN","HLEVUTIL",236,0)
 S NO=0,MIEN=0,LIM=$S($G(LIM):LIM,1:10)
"RTN","HLEVUTIL",237,0)
 F  S MIEN=$O(@GBL@(MIEN)) Q:MIEN'>0!(NO>LIM)  D
"RTN","HLEVUTIL",238,0)
 .  S DATA=$G(@GBL@(MIEN,0)) QUIT:$TR(DATA," ","")']""  ;->
"RTN","HLEVUTIL",239,0)
 .  S NO=NO+1
"RTN","HLEVUTIL",240,0)
 .  S ^UTILITY("DIQ1",$J,FILE,IEN,FLD,"E",NO)=DATA
"RTN","HLEVUTIL",241,0)
 Q
"RTN","HLEVUTIL",242,0)
 ;
"RTN","HLEVUTIL",243,0)
DICDR(FILE) ; Return fields for display by EN^DIQ1...
"RTN","HLEVUTIL",244,0)
 I FILE=772 QUIT ".01:199" ;->
"RTN","HLEVUTIL",245,0)
 I FILE=773 QUIT ".01:999" ;->
"RTN","HLEVUTIL",246,0)
 I FILE=776 QUIT ".01:20" ;->
"RTN","HLEVUTIL",247,0)
 I FILE=776.1 QUIT ".01:20" ;->
"RTN","HLEVUTIL",248,0)
 I FILE=776.2 QUIT ".01:20" ;->
"RTN","HLEVUTIL",249,0)
 I FILE=776.3 QUIT ".01:20" ;->
"RTN","HLEVUTIL",250,0)
 I FILE=776.4 QUIT ".01:20" ;->
"RTN","HLEVUTIL",251,0)
 I FILE=776.999 QUIT ".01:20" ;->
"RTN","HLEVUTIL",252,0)
 I FILE=870 QUIT ".01:18;21;100:499" ;->
"RTN","HLEVUTIL",253,0)
 QUIT ""
"RTN","HLEVUTIL",254,0)
 ;
"RTN","HLEVUTIL",255,0)
LAST D LASTIEN^HLEVUTI3 Q
"RTN","HLEVUTIL",256,0)
LASTIEN D LASTIEN^HLEVUTI3 Q
"RTN","HLEVUTIL",257,0)
LAST772 D LASTIEN^HLEVUTI3 Q
"RTN","HLEVUTIL",258,0)
LAST773 D LASTIEN^HLEVUTI3 Q
"RTN","HLEVUTIL",259,0)
 ;
"RTN","HLEVUTIL",260,0)
EOR ;HLEVUTIL - Event Monitor UTILITIES ;5/16/03 14:42
"RTN","HLEVX")
0^16^B2417562
"RTN","HLEVX",1,0)
HLEVX ;O-OIFO/LJA - VistA HL7 Event Monitor Code ;02/04/2004 15:25
"RTN","HLEVX",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVX",3,0)
 ;
"RTN","HLEVX",4,0)
 ; All official event code for the VistA HL7 package will be included
"RTN","HLEVX",5,0)
 ; in the LIST subroutine below (for internal team use.)
"RTN","HLEVX",6,0)
 ;
"RTN","HLEVX",7,0)
CTRL D LIST
"RTN","HLEVX",8,0)
 F  QUIT:($Y+3)>IOSL  W !
"RTN","HLEVX",9,0)
 S X=$$BTE^HLCSMON("Press RETURN to exit... ")
"RTN","HLEVX",10,0)
 Q
"RTN","HLEVX",11,0)
 ;
"RTN","HLEVX",12,0)
LIST N I,T W @IOF,$$CJ^XLFSTR("Official VistA HL7 Event Monitor Code",IOM),!,$$REPEAT^XLFSTR("=",IOM) F I=1:1 S T=$T(LIST+I) Q:T'[";;"  S T=$P(T,";;",2,99)  W !,$P(T,U,1,2),?18,$P(T,U,3)
"RTN","HLEVX",13,0)
 ;;
"RTN","HLEVX",14,0)
 ;;The "monitors" that are officially included in the VistA HL7 package are
"RTN","HLEVX",15,0)
 ;;listed below.
"RTN","HLEVX",16,0)
 ;;
"RTN","HLEVX",17,0)
 ;;Routine           Monitor-Name
"RTN","HLEVX",18,0)
 ;;==============================================================================
"RTN","HLEVX",19,0)
 ;;SYSTEM^HLEVX001^EVENT MONITOR
"RTN","HLEVX",20,0)
 ;;CHK870^HLEVX000^STUB 870 SEARCH & MORE
"RTN","HLEVX",21,0)
 ;;CHKXREF^HLEVX002^XREF CHECK - FILE 772 & 773
"RTN","HLEVX",22,0)
 Q
"RTN","HLEVX",23,0)
 ;
"RTN","HLEVX",24,0)
EOR ;HLEVX - VistA HL7 Event Monitor Code ;5/30/03 15:25
"RTN","HLEVX000")
0^17^B82658939
"RTN","HLEVX000",1,0)
HLEVX000 ;O-OIFO/LJA - VistA HL7 Event Monitor Code ;02/04/2004 15:25
"RTN","HLEVX000",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVX000",3,0)
 ;
"RTN","HLEVX000",4,0)
 ; Event Types - 870-DINUM, 870-SKIP, 870-STUB
"RTN","HLEVX000",5,0)
 ;
"RTN","HLEVX000",6,0)
CHK870 ; Search for various file 870 problems...
"RTN","HLEVX000",7,0)
 ;
"RTN","HLEVX000",8,0)
 ; {01/16/04 - See call to REPDINUM below.}
"RTN","HLEVX000",9,0)
 ;
"RTN","HLEVX000",10,0)
 N CT870,CTERR,CTNO,CTSTUB,DATA,DATABEF,IEN870,LINKNM,MIEN870
"RTN","HLEVX000",11,0)
 N NOW,STATUS,TXT,VAR,WAY,XTMPBEF,XTMPNOW
"RTN","HLEVX000",12,0)
 ;
"RTN","HLEVX000",13,0)
 ; Call event monitor...
"RTN","HLEVX000",14,0)
 KILL VAR
"RTN","HLEVX000",15,0)
 ; Variables can be defined prior to passing into START by reference...
"RTN","HLEVX000",16,0)
 F VAR="CT870","CTDINUM","CTERR" S VAR(VAR)="" ; #1-Indiv array elements
"RTN","HLEVX000",17,0)
 S VAR="CTNO^CTSKIP^CTSTUB" ;                    #2-Parsed from string
"RTN","HLEVX000",18,0)
 D START^HLEVAPI(.VAR)
"RTN","HLEVX000",19,0)
 ; Even D START^HLEVAPI(VAR) would work...
"RTN","HLEVX000",20,0)
 ;
"RTN","HLEVX000",21,0)
 KILL ^TMP($J,"HLREP"),^TMP($J,"HLEV REP"),^TMP($J,"HLMAIL")
"RTN","HLEVX000",22,0)
 ;
"RTN","HLEVX000",23,0)
 ; Set current XTMP subscript and create zero node...
"RTN","HLEVX000",24,0)
 S NOW=$$NOW^XLFDT,XTMPNOW="HLEV STUB "_NOW
"RTN","HLEVX000",25,0)
 S ^XTMP(XTMPNOW,0)=$$FMADD^XLFDT(NOW,2)_U_NOW_U_"HLEV Stub Record Search"
"RTN","HLEVX000",26,0)
 ;
"RTN","HLEVX000",27,0)
 ; Has there been a prior run?  If so, set XTMPBEF.  If not, set to null
"RTN","HLEVX000",28,0)
 S XTMPBEF=$O(^XTMP(XTMPNOW),-1),XTMPBEF=$S(XTMPBEF["HLEV STUB ":XTMPBEF,1:"")
"RTN","HLEVX000",29,0)
 ;
"RTN","HLEVX000",30,0)
 ; Find current stub entries...
"RTN","HLEVX000",31,0)
 S (CT870,CTDINUM,CTERR,CTNO,CTSKIP,CTSTUB)=0,IEN870=0,CTNO=0
"RTN","HLEVX000",32,0)
 F  S IEN870=$O(^HLCS(870,IEN870)) Q:IEN870'>0  D
"RTN","HLEVX000",33,0)
 .  D CHECKIN^HLEVAPI
"RTN","HLEVX000",34,0)
 .  S CT870=CT870+1
"RTN","HLEVX000",35,0)
 .  S LINKNM=$P($G(^HLCS(870,+IEN870,0)),U)
"RTN","HLEVX000",36,0)
 .  S LINKNM=$S(LINKNM]"":LINKNM_"["_IEN870_"]",1:"IEN ["_IEN870_"]")
"RTN","HLEVX000",37,0)
 .  ; 1=IN QUEUE     2=OUT QUEUE
"RTN","HLEVX000",38,0)
 .  F WAY=1,2 D
"RTN","HLEVX000",39,0)
 .  .  S WAY(1)=$S(WAY=1:"I",1:"O")
"RTN","HLEVX000",40,0)
 .  .  D CHECKIN^HLEVAPI
"RTN","HLEVX000",41,0)
 .  .  S MIEN870=$O(^HLCS(870,+IEN870,WAY,0)) ; First entry...
"RTN","HLEVX000",42,0)
 .  .  S MIEN870(1)=$O(^HLCS(870,+IEN870,WAY,":"),-1) ; Last entry...
"RTN","HLEVX000",43,0)
 .  .  Q:MIEN870'>0!(MIEN870(1)'>0)  ;->
"RTN","HLEVX000",44,0)
 .  .  F MIEN870=MIEN870:1:MIEN870(1) D
"RTN","HLEVX000",45,0)
 .  .  .  S CTNO=CTNO+1
"RTN","HLEVX000",46,0)
 .  .  .  I '(CTNO#500) D CHECKIN^HLEVAPI
"RTN","HLEVX000",47,0)
 .  .  .  D CHECKS(IEN870,WAY,MIEN870)
"RTN","HLEVX000",48,0)
 ;
"RTN","HLEVX000",49,0)
 D CHECKIN^HLEVAPI ; To store final values of variables
"RTN","HLEVX000",50,0)
 D CHECKOUT^HLEVAPI ; To finalize fields...
"RTN","HLEVX000",51,0)
 ;
"RTN","HLEVX000",52,0)
 S ^XTMP(XTMPNOW,0,0)=CT870_U_CTNO_"~"_CTERR_"~"_CTDINUM_U_CTSKIP_U_CTSTUB
"RTN","HLEVX000",53,0)
 ;
"RTN","HLEVX000",54,0)
 ; Create report and put in text...
"RTN","HLEVX000",55,0)
 QUIT:'$D(^TMP($J,"HLEV REP"))  ;->
"RTN","HLEVX000",56,0)
 ;
"RTN","HLEVX000",57,0)
 ; Create report text...
"RTN","HLEVX000",58,0)
 D GENREP^HLEVUTI0($NA(^TMP($J,"HLEV REP")),$NA(^TMP($J,"HLEVREP")),4,1)
"RTN","HLEVX000",59,0)
 ;
"RTN","HLEVX000",60,0)
 ; Load report text in 776 message text...
"RTN","HLEVX000",61,0)
 D MSGTEXT^HLEVAPI1($NA(^TMP($J,"HLEVREP")))
"RTN","HLEVX000",62,0)
 ;
"RTN","HLEVX000",63,0)
 ; Mail report...
"RTN","HLEVX000",64,0)
 S HLEVTXT(1)="MESSAGETEXT"
"RTN","HLEVX000",65,0)
 D MAILIT^HLEVAPI
"RTN","HLEVX000",66,0)
 ;
"RTN","HLEVX000",67,0)
 ; Report DINUM problems, using report text...
"RTN","HLEVX000",68,0)
 D REPDINUM^HLEVX003 ; {01/16/04}
"RTN","HLEVX000",69,0)
 ;
"RTN","HLEVX000",70,0)
 ; Clean out ^TMP data...
"RTN","HLEVX000",71,0)
 KILL ^TMP($J,"HLREP"),^TMP($J,"HLEV REP"),^TMP($J,"HLMAIL")
"RTN","HLEVX000",72,0)
 ;
"RTN","HLEVX000",73,0)
 Q
"RTN","HLEVX000",74,0)
 ;
"RTN","HLEVX000",75,0)
SITE S SITE=$$SITE^VASITE,SITE=$P(SITE,U,2)_" ["_$P(SITE,U,3)_"]"
"RTN","HLEVX000",76,0)
 D ADD("Run site:  "_SITE)
"RTN","HLEVX000",77,0)
 D ADD("")
"RTN","HLEVX000",78,0)
 ;
"RTN","HLEVX000",79,0)
EXPL D ADD("Some stub entries exist in the HL Logical Link file (#870) that")
"RTN","HLEVX000",80,0)
 D ADD("appear to be ""stuck"".  Someone at the site needs to check out")
"RTN","HLEVX000",81,0)
 D ADD("and possibly change their status to DONE.")
"RTN","HLEVX000",82,0)
 ;
"RTN","HLEVX000",83,0)
HDR D ADD("")
"RTN","HLEVX000",84,0)
 D ADD("Link          In/Out     IENs")
"RTN","HLEVX000",85,0)
 D ADD($$REPEAT^XLFSTR("-",74))
"RTN","HLEVX000",86,0)
 ;
"RTN","HLEVX000",87,0)
 ; Send report...
"RTN","HLEVX000",88,0)
REP S LINKNM=""
"RTN","HLEVX000",89,0)
 F  S LINKNM=$O(^TMP($J,"HLEV REP",LINKNM)) Q:LINKNM']""  D
"RTN","HLEVX000",90,0)
 .  S TXT=$E(LINKNM_"               ",1,15)
"RTN","HLEVX000",91,0)
 .  S WAY="",CTNO=0
"RTN","HLEVX000",92,0)
 .  F  S WAY=$O(^TMP($J,"HLEV REP",LINKNM,WAY)) Q:WAY']""  D
"RTN","HLEVX000",93,0)
 .  .  S TXT=$E(TXT_" "_$S(WAY="I":"IN",1:"OUT")_$$REPEAT^XLFSTR(" ",80),1,25)
"RTN","HLEVX000",94,0)
 .  .  S MIEN870=0
"RTN","HLEVX000",95,0)
 .  .  F  S MIEN870=$O(^TMP($J,"HLEV REP",LINKNM,WAY,MIEN870)) Q:MIEN870'>0  D
"RTN","HLEVX000",96,0)
 .  .  .  S CTNO=CTNO+1
"RTN","HLEVX000",97,0)
 .  .  .  I ($L(TXT)+$L(MIEN870)+2)>74 D  QUIT  ;->
"RTN","HLEVX000",98,0)
 .  .  .  .  D ADD(TXT)
"RTN","HLEVX000",99,0)
 .  .  .  .  S TXT=$$REPEAT^XLFSTR(" ",25)
"RTN","HLEVX000",100,0)
 .  .  .  S TXT=TXT_$S($L(TXT)>25:",",1:"")_MIEN870
"RTN","HLEVX000",101,0)
 .  .  I $TR(TXT," ","")]"" D ADD(TXT)
"RTN","HLEVX000",102,0)
 .  .  S TXT=$$REPEAT^XLFSTR(" ",15)
"RTN","HLEVX000",103,0)
 .  I TXT]"" D ADD(TXT) S TXT=""
"RTN","HLEVX000",104,0)
 I TXT]"" D ADD(TXT) S TXT=""
"RTN","HLEVX000",105,0)
 ;
"RTN","HLEVX000",106,0)
 D MSGTEXT^HLEVAPI1($NA(^TMP($J,"HLMAIL")))
"RTN","HLEVX000",107,0)
 ;
"RTN","HLEVX000",108,0)
 KILL ^TMP($J,"HLEV REP"),^TMP($J,"HLMAIL")
"RTN","HLEVX000",109,0)
 ;
"RTN","HLEVX000",110,0)
 S HLEVTXT(1)="MESSAGE TEXT"
"RTN","HLEVX000",111,0)
 D MAILIT^HLEVAPI
"RTN","HLEVX000",112,0)
 ;
"RTN","HLEVX000",113,0)
 Q
"RTN","HLEVX000",114,0)
 ;
"RTN","HLEVX000",115,0)
ADD(TXT) ; Add to global for moving into report
"RTN","HLEVX000",116,0)
 N NO
"RTN","HLEVX000",117,0)
 S NO=$O(^TMP($J,"HLMAIL",":"),-1)+1
"RTN","HLEVX000",118,0)
 S ^TMP($J,"HLMAIL",+NO)=TXT
"RTN","HLEVX000",119,0)
 Q
"RTN","HLEVX000",120,0)
 ;
"RTN","HLEVX000",121,0)
MSG(TXT) ; Generic text displayer...
"RTN","HLEVX000",122,0)
 W !!,TXT
"RTN","HLEVX000",123,0)
 W ! ; Always put at least one blank row in place
"RTN","HLEVX000",124,0)
 F  Q:($Y+3)>IOSL  W !
"RTN","HLEVX000",125,0)
 S X=$$BTE^HLCSMON("Press RETURN to exit... ")
"RTN","HLEVX000",126,0)
 Q
"RTN","HLEVX000",127,0)
 ;
"RTN","HLEVX000",128,0)
CHECKS(IEN870,WAY,MIEN870) ; Perform various checks on queue entry...
"RTN","HLEVX000",129,0)
 ; CTDINUM,CTSKIP,CTSTUB -- req
"RTN","HLEVX000",130,0)
 QUIT:'$$DATA870(IEN870,WAY,MIEN870)  ;->
"RTN","HLEVX000",131,0)
 D CHKSTUB(IEN870,WAY,MIEN870)
"RTN","HLEVX000",132,0)
 D CHKDINUM(IEN870,WAY,MIEN870)
"RTN","HLEVX000",133,0)
 Q
"RTN","HLEVX000",134,0)
 ;
"RTN","HLEVX000",135,0)
DATA870(IEN870,WAY,MIEN870) ; Does record exist?
"RTN","HLEVX000",136,0)
 ; CTSKIP,LINKNM -- req
"RTN","HLEVX000",137,0)
 ;
"RTN","HLEVX000",138,0)
 ; Check for existence of data here...
"RTN","HLEVX000",139,0)
 QUIT:$G(^HLCS(870,+IEN870,WAY,+MIEN870,0))]"" 1 ;->
"RTN","HLEVX000",140,0)
 ;
"RTN","HLEVX000",141,0)
 S WAY(1)=$S(WAY=1:"INCOMING",1:"OUTGOING")
"RTN","HLEVX000",142,0)
 ;
"RTN","HLEVX000",143,0)
 ; Has this problem already been logged?
"RTN","HLEVX000",144,0)
 QUIT:'$$LOG^HLEVAPI2("870-SKIP","IEN870^WAY^MIEN870") "" ;->
"RTN","HLEVX000",145,0)
 ;
"RTN","HLEVX000",146,0)
 D RECORD("SKIP",LINKNM,WAY(1),MIEN870)
"RTN","HLEVX000",147,0)
 S CTSKIP=CTSKIP+1,CTERR=CTERR+1
"RTN","HLEVX000",148,0)
 ;
"RTN","HLEVX000",149,0)
 Q ""
"RTN","HLEVX000",150,0)
 ;
"RTN","HLEVX000",151,0)
CHKSTUB(IEN870,WAY,MIEN870) ; Check if a stub record that "hangs around"
"RTN","HLEVX000",152,0)
 ; CTSTUB,LINKNM -- req
"RTN","HLEVX000",153,0)
 N DATABEF,STATUS
"RTN","HLEVX000",154,0)
 S STATUS=$P($G(^HLCS(870,+IEN870,+WAY,+MIEN870,0)),U,2)
"RTN","HLEVX000",155,0)
 QUIT:STATUS'="S"  ;-> Stub record
"RTN","HLEVX000",156,0)
 S WAY(1)=$S(WAY=1:"INCOMING",1:"OUTGOING")
"RTN","HLEVX000",157,0)
 S DATABEF=$S(XTMPBEF']"":"",1:$S($D(^XTMP(XTMPBEF,+IEN870,WAY(1),+MIEN870)):1,1:""))
"RTN","HLEVX000",158,0)
 S ^XTMP(XTMPNOW,+IEN870,WAY(1),+MIEN870)=DATABEF
"RTN","HLEVX000",159,0)
 QUIT:'DATABEF  ;-> Stub entry didn't exist before...
"RTN","HLEVX000",160,0)
 ;
"RTN","HLEVX000",161,0)
 ; Has this problem already been logged?
"RTN","HLEVX000",162,0)
 QUIT:'$$LOG^HLEVAPI2("870-STUB","IEN870^WAY^MIEN870")  ;->
"RTN","HLEVX000",163,0)
 ;
"RTN","HLEVX000",164,0)
 D RECORD("STUB",LINKNM,WAY(1),MIEN870)
"RTN","HLEVX000",165,0)
 S CTSTUB=CTSTUB+1,CTERR=CTERR+1
"RTN","HLEVX000",166,0)
 ;
"RTN","HLEVX000",167,0)
 Q
"RTN","HLEVX000",168,0)
 ;
"RTN","HLEVX000",169,0)
CHKDINUM(IEN870,WAY,MIEN870) ; Check for records not DINUMd for log link
"RTN","HLEVX000",170,0)
 ; CTDINUM,LINKNM -- req
"RTN","HLEVX000",171,0)
 ;
"RTN","HLEVX000",172,0)
 ; {01/16/04 - Call to $$LOG^HLEVAPI2 removed.  See REPDINUM call.}
"RTN","HLEVX000",173,0)
 ;
"RTN","HLEVX000",174,0)
 N IEN
"RTN","HLEVX000",175,0)
 ;
"RTN","HLEVX000",176,0)
 ; DINUM check here...
"RTN","HLEVX000",177,0)
 S IEN=+$G(^HLCS(870,+IEN870,WAY,+MIEN870,0)) QUIT:IEN=MIEN870  ;->
"RTN","HLEVX000",178,0)
 ;
"RTN","HLEVX000",179,0)
 S WAY(1)=$S(WAY=1:"INCOMING",1:"OUTGOING")
"RTN","HLEVX000",180,0)
 ;
"RTN","HLEVX000",181,0)
 ; New occurence, so record error...
"RTN","HLEVX000",182,0)
 D RECORD("DINUM",LINKNM,WAY(1),MIEN870)
"RTN","HLEVX000",183,0)
 S CTDINUM=CTDINUM+1,CTERR=CTERR+1
"RTN","HLEVX000",184,0)
 ;
"RTN","HLEVX000",185,0)
 Q
"RTN","HLEVX000",186,0)
 ;
"RTN","HLEVX000",187,0)
RECORD(PROBL,LINKNM,WAY,MIEN870) ; Record for later inclusion in report
"RTN","HLEVX000",188,0)
 ;
"RTN","HLEVX000",189,0)
 ; Required:  At least two levels passed...
"RTN","HLEVX000",190,0)
 S PROBL=$G(PROBL) QUIT:PROBL']""  ;->
"RTN","HLEVX000",191,0)
 S LINKNM=$G(LINKNM) QUIT:LINKNM']""  ;->
"RTN","HLEVX000",192,0)
 S LEVEL=2
"RTN","HLEVX000",193,0)
 S WAY=$G(WAY) I WAY]"" S LEVEL=3
"RTN","HLEVX000",194,0)
 S MIEN870=$G(MIEN870) I MIEN870]"" S LEVEL=4
"RTN","HLEVX000",195,0)
 ;
"RTN","HLEVX000",196,0)
 ; Data level set...
"RTN","HLEVX000",197,0)
 I LEVEL=4 S ^TMP($J,"HLEV REP",PROBL,LINKNM,WAY,MIEN870)=""
"RTN","HLEVX000",198,0)
 I LEVEL=3 S ^TMP($J,"HLEV REP",PROBL,LINKNM,WAY)=""
"RTN","HLEVX000",199,0)
 I LEVEL=2 S ^TMP($J,"HLEV REP",PROBL,LINKNM)=""
"RTN","HLEVX000",200,0)
 ;
"RTN","HLEVX000",201,0)
 ; Total level sets...
"RTN","HLEVX000",202,0)
 I LEVEL=4 S ^TMP($J,"HLEV REP",PROBL,LINKNM,WAY)=$G(^TMP($J,"HLEV REP",PROBL,LINKNM,WAY))+1
"RTN","HLEVX000",203,0)
 I LEVEL=3 S ^TMP($J,"HLEV REP",PROBL,LINKNM)=$G(^TMP($J,"HLEV REP",PROBL,LINKNM))+1
"RTN","HLEVX000",204,0)
 S ^TMP($J,"HLEV REP",PROBL)=$G(^TMP($J,"HLEV REP",PROBL))+1
"RTN","HLEVX000",205,0)
 S ^TMP($J,"HLEV REP")=$G(^TMP($J,"HLEV REP"))+1
"RTN","HLEVX000",206,0)
 ;
"RTN","HLEVX000",207,0)
 Q
"RTN","HLEVX000",208,0)
 ;
"RTN","HLEVX000",209,0)
 ; ====================================================================
"RTN","HLEVX000",210,0)
 ;
"RTN","HLEVX000",211,0)
CORRECT ; Correct a stub entry in HLCS(870)...
"RTN","HLEVX000",212,0)
 N IEN870,MIEN870,WAY
"RTN","HLEVX000",213,0)
 D HD,EX
"RTN","HLEVX000",214,0)
 S WAY=$$WAY I WAY']"" D  QUIT  ;->
"RTN","HLEVX000",215,0)
 .  D MSG("Exiting... ")
"RTN","HLEVX000",216,0)
 W !
"RTN","HLEVX000",217,0)
 S IEN870=$$LINK I IEN870']"" D  QUIT  ;->
"RTN","HLEVX000",218,0)
 .  D MSG("No link selected.  Start again... ")
"RTN","HLEVX000",219,0)
CONT W !
"RTN","HLEVX000",220,0)
 S MIEN870=$$MIEN870(IEN870,WAY) I MIEN870'>0 D  QUIT  ;->
"RTN","HLEVX000",221,0)
 .  D MSG("No stub entry exists for link.")
"RTN","HLEVX000",222,0)
 W !!,"Stub record# ",MIEN870," found.  It's status is about to be changed to DONE..."
"RTN","HLEVX000",223,0)
 W !
"RTN","HLEVX000",224,0)
 QUIT:'$$YN^HLCSRPT4("OK to correct","Yes")  ;->
"RTN","HLEVX000",225,0)
 D FIX(IEN870,WAY,MIEN870,"D")
"RTN","HLEVX000",226,0)
 W "  fixed... "
"RTN","HLEVX000",227,0)
 W !
"RTN","HLEVX000",228,0)
 QUIT:$$BTE^HLCSMON("Press RETURN to continue searching... ")  ;->
"RTN","HLEVX000",229,0)
 G CONT ;->
"RTN","HLEVX000",230,0)
 ;
"RTN","HLEVX000",231,0)
FIX(IEN870,WAY,MIEN870,STAT) ; Fix stub record...
"RTN","HLEVX000",232,0)
 N DA,DIE,DR,SUBDD
"RTN","HLEVX000",233,0)
 S DIE="^HLCS(870,"_IEN870_","_WAY_","
"RTN","HLEVX000",234,0)
 S DA(1)=IEN870,DA=+MIEN870
"RTN","HLEVX000",235,0)
 S DR=$S($G(STAT)]"":"1///"_STAT,1:1)
"RTN","HLEVX000",236,0)
 D ^DIE
"RTN","HLEVX000",237,0)
 Q
"RTN","HLEVX000",238,0)
 ;
"RTN","HLEVX000",239,0)
WAY() ; In or Out?
"RTN","HLEVX000",240,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLEVX000",241,0)
 S DIR(0)="SO^1:Search the IN QUEUE;2:Search the OUT QUEUE"
"RTN","HLEVX000",242,0)
 S DIR("A")="Select the QUEUE to search"
"RTN","HLEVX000",243,0)
 D ^DIR
"RTN","HLEVX000",244,0)
 QUIT:$D(DIRUT)!($D(DTOUT))!($D(DUOUT)) "" ;->
"RTN","HLEVX000",245,0)
 Q $S(+Y:+Y,1:"")
"RTN","HLEVX000",246,0)
 ;
"RTN","HLEVX000",247,0)
LINK() ; Which 870 entry?
"RTN","HLEVX000",248,0)
 N DIC,X,Y
"RTN","HLEVX000",249,0)
 S DIC=870,DIC(0)="AEMQ",DIC("A")="Select LOGICAL LINK: "
"RTN","HLEVX000",250,0)
 D ^DIC
"RTN","HLEVX000",251,0)
 Q $S(+Y:+Y,1:"")
"RTN","HLEVX000",252,0)
 ;
"RTN","HLEVX000",253,0)
MIEN870(IEN870,WAY) ; Search for stub record...
"RTN","HLEVX000",254,0)
 N CT,IEN,IOINHI,IOINORM,MIEN870,STATUS,X
"RTN","HLEVX000",255,0)
 ;
"RTN","HLEVX000",256,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLEVX000",257,0)
 ;
"RTN","HLEVX000",258,0)
 W !,IOINHI,"Searching for stub records...",IOINORM
"RTN","HLEVX000",259,0)
 S CT=0,IEN=0,MIEN870=0
"RTN","HLEVX000",260,0)
 F  S IEN=$O(^HLCS(870,+IEN870,WAY,IEN)) Q:IEN'>0!(MIEN870)  D
"RTN","HLEVX000",261,0)
 .  S CT=CT+1 W:'(CT#500) "."
"RTN","HLEVX000",262,0)
 .  S DATA=$G(^HLCS(870,+IEN870,WAY,IEN,0)) QUIT:$P(DATA,U,2)'="S"  ;->
"RTN","HLEVX000",263,0)
 .  H 15 ; If not hung, and is a proper stub entry, it will disappear
"RTN","HLEVX000",264,0)
 .  S DATA=$G(^HLCS(870,+IEN870,WAY,IEN,0)) QUIT:$P(DATA,U,2)'="S"  ;->
"RTN","HLEVX000",265,0)
 .  S MIEN870=IEN
"RTN","HLEVX000",266,0)
 ;
"RTN","HLEVX000",267,0)
 Q MIEN870
"RTN","HLEVX000",268,0)
 ;
"RTN","HLEVX000",269,0)
HD W @IOF,$$CJ^XLFSTR("Stub Record Correction",IOM)
"RTN","HLEVX000",270,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLEVX000",271,0)
 QUIT
"RTN","HLEVX000",272,0)
 ;
"RTN","HLEVX000",273,0)
EX N I,T F I=1:1 S T=$T(EX+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLEVX000",274,0)
 ;;Occasionally, entry's in the IN QUEUE and the OUT QUEUE of the HL Logical
"RTN","HLEVX000",275,0)
 ;;Link file (#870) get stuck in the STUB status.  (Stub records have the STATUS
"RTN","HLEVX000",276,0)
 ;;field set to STUB.)  When this occurs, no further processing of the queue
"RTN","HLEVX000",277,0)
 ;;occurs.
"RTN","HLEVX000",278,0)
 ;;
"RTN","HLEVX000",279,0)
 ;;This utility loops through the IN QUEUE or the OUT QUEUE of a logical link
"RTN","HLEVX000",280,0)
 ;;looking for stub records.  (Stub records have the STATUS field set to STUB.)
"RTN","HLEVX000",281,0)
 ;;When it finds a stub record it requests permission to set the STATUS field to
"RTN","HLEVX000",282,0)
 ;;DONE.
"RTN","HLEVX000",283,0)
 QUIT
"RTN","HLEVX000",284,0)
 ;
"RTN","HLEVX000",285,0)
EOR ;HLEVX000 - VistA HL7 Event Monitor Code ;5/30/03 15:25
"RTN","HLEVX001")
0^18^B35322440
"RTN","HLEVX001",1,0)
HLEVX001 ;O-OIFO/LJA - Event Monitor "Mother" ;02/04/2004 14:42
"RTN","HLEVX001",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVX001",3,0)
 ;
"RTN","HLEVX001",4,0)
MOTHER ; The "Mother of All" monitors!  (Monitors the Event Monitor)
"RTN","HLEVX001",5,0)
 ;HLEVIENE,HLEVIENJ,HLEVIENM -- req
"RTN","HLEVX001",6,0)
 D START^HLEVAPI()
"RTN","HLEVX001",7,0)
 D MASTER
"RTN","HLEVX001",8,0)
 D MONITOR
"RTN","HLEVX001",9,0)
 D CHECKOUT^HLEVAPI
"RTN","HLEVX001",10,0)
 Q
"RTN","HLEVX001",11,0)
 ;
"RTN","HLEVX001",12,0)
MASTER ; Collect master job information...
"RTN","HLEVX001",13,0)
 D LASTNEXT
"RTN","HLEVX001",14,0)
 D MSTRUNS
"RTN","HLEVX001",15,0)
 Q
"RTN","HLEVX001",16,0)
 ;
"RTN","HLEVX001",17,0)
MSTRUNS ; Show master runs and status counts...
"RTN","HLEVX001",18,0)
 N CT,CTM,STAT,STATM
"RTN","HLEVX001",19,0)
 KILL ^TMP($J,"SV")
"RTN","HLEVX001",20,0)
 D RUNS("SV")
"RTN","HLEVX001",21,0)
 D ADD50("")
"RTN","HLEVX001",22,0)
 D ADD50("# job runs last 24 hours",$G(^TMP($J,"SV")))
"RTN","HLEVX001",23,0)
 D ADD50("   "_$$REPEAT^XLFSTR("-",40))
"RTN","HLEVX001",24,0)
 S STAT=""
"RTN","HLEVX001",25,0)
 F  S STAT=$O(^TMP($J,"SV",STAT)) Q:STAT']""  D
"RTN","HLEVX001",26,0)
 .  S CT=^TMP($J,"SV",STAT)
"RTN","HLEVX001",27,0)
 .  D ADD50("#"_$$STAT2(STAT),CT)
"RTN","HLEVX001",28,0)
 Q
"RTN","HLEVX001",29,0)
 ;
"RTN","HLEVX001",30,0)
STAT2(STAT) ; Return status for 776.2 0;4...
"RTN","HLEVX001",31,0)
 Q $S(STAT="E":"ERROR",STAT="F":"FINISHED",STAT="Q":"QUEUED",STAT="R":"RUNNING",STAT="P":"PARM STOP",STAT="S":"STOP REQUESTED",STAT="A":"JOB ABORTED",1:STAT)
"RTN","HLEVX001",32,0)
 ;
"RTN","HLEVX001",33,0)
STAT2M(STAT) ; REturn status for 776.2051 0;2 & 0;6...
"RTN","HLEVX001",34,0)
 Q $S(STAT="E":"TOO EARLY",STAT="I":"INACTIVE",STAT="M":"M-CHK-FAIL",STAT="Q":"QUEUED",STAT="R":"RUNNING",STAT="XM":"M CODE",$E(STAT)="X":"ERROR",1:STAT)
"RTN","HLEVX001",35,0)
 ;
"RTN","HLEVX001",36,0)
LASTNEXT ; Show last completed run and next queued run...
"RTN","HLEVX001",37,0)
 N IENLAST,IENNEXT
"RTN","HLEVX001",38,0)
 S IENLAST=+$$IEN7762("F"),NODE(+IENLAST)=$G(^HLEV(776.2,+IENLAST,0))
"RTN","HLEVX001",39,0)
 S IENNEXT=+$$IEN7762("Q"),NODE(+IENNEXT)=$G(^HLEV(776.2,+IENNEXT,0))
"RTN","HLEVX001",40,0)
 D ADD50("Last master job run",$$FMTE^XLFDT(+NODE(+IENLAST)))
"RTN","HLEVX001",41,0)
 D ADD50("Next master job at",$$FMTE^XLFDT(+NODE(+IENNEXT))_"  Task#: "_$P(NODE(+IENNEXT),U,5))
"RTN","HLEVX001",42,0)
 Q
"RTN","HLEVX001",43,0)
 ;
"RTN","HLEVX001",44,0)
RUNS(SUB) ; Find number runs and results...
"RTN","HLEVX001",45,0)
 N ABORT,CUT,DATA,IEN,IENM,LASTDT,RES,STAT,STATM,STATM5
"RTN","HLEVX001",46,0)
 S CUT=$$FMADD^XLFDT($$NOW^XLFDT,-1),ABORT=0
"RTN","HLEVX001",47,0)
 S LASTDT=":"
"RTN","HLEVX001",48,0)
 F  S LASTDT=$O(^HLEV(776.2,"B",LASTDT),-1) Q:'LASTDT!(LASTDT<CUT)!(ABORT)  D
"RTN","HLEVX001",49,0)
 .  S IEN=":"
"RTN","HLEVX001",50,0)
 .  F  S IEN=$O(^HLEV(776.2,"B",LASTDT,IEN),-1) Q:'IEN!(ABORT)  D
"RTN","HLEVX001",51,0)
 .  .  S DATA=$G(^HLEV(776.2,+IEN,0))
"RTN","HLEVX001",52,0)
 .  .  S STAT=$P(DATA,U,4),STAT=$S(STAT]"":STAT,1:"?")
"RTN","HLEVX001",53,0)
 .  .  S ^TMP($J,SUB)=$G(^TMP($J,SUB))+1
"RTN","HLEVX001",54,0)
 .  .  S ^TMP($J,SUB,STAT)=$G(^TMP($J,SUB,STAT))+1
"RTN","HLEVX001",55,0)
 .  .  S IENM=0
"RTN","HLEVX001",56,0)
 .  .  F  S IENM=$O(^HLEV(776.2,+IEN,51,IENM)) Q:IENM'>0  D
"RTN","HLEVX001",57,0)
 .  .  .  S DATA=^HLEV(776.2,+IEN,51,+IENM,0)
"RTN","HLEVX001",58,0)
 .  .  .  S STATM=$P(DATA,U,2),STATM=$S(STATM]"":STATM,1:"?")
"RTN","HLEVX001",59,0)
 .  .  .  S STATM5=$P(DATA,U,5),STATM=$$STATM5(STATM,STATM5)
"RTN","HLEVX001",60,0)
 .  .  .  S ^TMP($J,SUB,STAT,STATM)=$G(^TMP($J,SUB,STAT,STATM))+1
"RTN","HLEVX001",61,0)
 Q
"RTN","HLEVX001",62,0)
 ;
"RTN","HLEVX001",63,0)
STATM5(STATM,STATM5) ; Return sorting subscript RESULTS
"RTN","HLEVX001",64,0)
 QUIT:$E(STATM5)="X" STATM5
"RTN","HLEVX001",65,0)
 Q STATM
"RTN","HLEVX001",66,0)
 ;
"RTN","HLEVX001",67,0)
ADD50(TAG,TXT) ; Add to ^HLEV(776,+HLEVIENJ,50)...
"RTN","HLEVX001",68,0)
 ; HLEVIENJ -- req
"RTN","HLEVX001",69,0)
 N POSX
"RTN","HLEVX001",70,0)
 ;
"RTN","HLEVX001",71,0)
 S TAG=$G(TAG),TXT=$G(TXT)
"RTN","HLEVX001",72,0)
 ;
"RTN","HLEVX001",73,0)
 ; If TXT passed & TAG not passed...
"RTN","HLEVX001",74,0)
 I TXT]"",TAG']"" D  QUIT  ;->
"RTN","HLEVX001",75,0)
 .  D WPTXT^HLEVUTIL(776,+HLEVIENJ,50,776.002,TXT)
"RTN","HLEVX001",76,0)
 ;
"RTN","HLEVX001",77,0)
 ; If TXT not passed...
"RTN","HLEVX001",78,0)
 I TXT']"" D  ;-> Blank line...
"RTN","HLEVX001",79,0)
 .  ; If TAG not passed...
"RTN","HLEVX001",80,0)
 .  I TAG']"" D  QUIT  ;-> Blank line...
"RTN","HLEVX001",81,0)
 .  .  D WPTXT^HLEVUTIL(776,+HLEVIENJ,50,776.002,"")
"RTN","HLEVX001",82,0)
 .  ; If TAG passed...
"RTN","HLEVX001",83,0)
 .  I TAG]"" D  QUIT  ;-> Separator line or something
"RTN","HLEVX001",84,0)
 .  .  D WPTXT^HLEVUTIL(776,+HLEVIENJ,50,776.002,TAG)
"RTN","HLEVX001",85,0)
 ;
"RTN","HLEVX001",86,0)
 S TAG=$E($$REPEAT^XLFSTR(" ",40),1,30-$L(TAG))_TAG_":   "
"RTN","HLEVX001",87,0)
 S POSX=$L(TAG),TXT=TAG_TXT
"RTN","HLEVX001",88,0)
 ;
"RTN","HLEVX001",89,0)
 F  QUIT:TXT']""  D
"RTN","HLEVX001",90,0)
 .  D WPTXT^HLEVUTIL(776,+HLEVIENJ,50,776.002,$E(TXT,1,74))
"RTN","HLEVX001",91,0)
 .  S TXT=$E(TXT,75,999) QUIT:TXT']""  ;->
"RTN","HLEVX001",92,0)
 .  S TXT=$$REPEAT^XLFSTR(" ",POSX)_TXT
"RTN","HLEVX001",93,0)
 ;
"RTN","HLEVX001",94,0)
 Q
"RTN","HLEVX001",95,0)
 ;
"RTN","HLEVX001",96,0)
IEN7762(STAT) ;
"RTN","HLEVX001",97,0)
 N FIEN,IEN,LASTDT
"RTN","HLEVX001",98,0)
 S LASTDT=":",FIEN=""
"RTN","HLEVX001",99,0)
 F  S LASTDT=$O(^HLEV(776.2,"B",LASTDT),-1) Q:'LASTDT!(FIEN)  D
"RTN","HLEVX001",100,0)
 .  S IEN=":"
"RTN","HLEVX001",101,0)
 .  F  S IEN=$O(^HLEV(776.2,"B",+LASTDT,IEN),-1) Q:'IEN!(FIEN)  D
"RTN","HLEVX001",102,0)
 .  .  QUIT:$P($G(^HLEV(776.2,+IEN,0)),U,4)'=STAT  ;->
"RTN","HLEVX001",103,0)
 .  .  S FIEN=IEN
"RTN","HLEVX001",104,0)
 Q FIEN
"RTN","HLEVX001",105,0)
 ;
"RTN","HLEVX001",106,0)
MONITOR ; Collect monitor information...
"RTN","HLEVX001",107,0)
 ; HLEVIENJ -- req
"RTN","HLEVX001",108,0)
 N DATA,DATE,EVIEN,EVNM,IEN,IENJ,IOINHI,IOINORM,LASTDT,MIEN
"RTN","HLEVX001",109,0)
 N NO,RUNNING,STAT,X
"RTN","HLEVX001",110,0)
 ;
"RTN","HLEVX001",111,0)
 KILL ^TMP($J,"HLRUN")
"RTN","HLEVX001",112,0)
 ;
"RTN","HLEVX001",113,0)
 ; Find latest 776.2 master run...
"RTN","HLEVX001",114,0)
 S LASTDT=":",NO=0
"RTN","HLEVX001",115,0)
 F  S LASTDT=$O(^HLEV(776.2,"B",LASTDT),-1) Q:'LASTDT!(NO>3)  D
"RTN","HLEVX001",116,0)
 .  S IEN=""
"RTN","HLEVX001",117,0)
 .  F  S IEN=$O(^HLEV(776.2,"B",+LASTDT,IEN),-1) Q:'IEN!(NO>3)  D
"RTN","HLEVX001",118,0)
 .  .  S DATA(776.2)=$G(^HLEV(776.2,+IEN,0)) QUIT:DATA(776.2)']""  ;->
"RTN","HLEVX001",119,0)
 .  .  S STAT=$P(DATA(776.2),U,4),STAT=$S(STAT]"":STAT,1:" ")
"RTN","HLEVX001",120,0)
 .  .  S NO=NO+1
"RTN","HLEVX001",121,0)
 .  .  ; Add events monitored...
"RTN","HLEVX001",122,0)
 .  .  S MIEN=0
"RTN","HLEVX001",123,0)
 .  .  F  S MIEN=$O(^HLEV(776.2,+IEN,51,MIEN)) Q:MIEN'>0  D
"RTN","HLEVX001",124,0)
 .  .  .  S DATA(51)=$G(^HLEV(776.2,+IEN,51,+MIEN,0)) Q:DATA(51)']""  ;->
"RTN","HLEVX001",125,0)
 .  .  .  S EVIEN=+DATA(51)
"RTN","HLEVX001",126,0)
 .  .  .  S EVNM=$P($G(^HLEV(776.1,+EVIEN,0)),U) QUIT:EVNM']""  ;->
"RTN","HLEVX001",127,0)
 .  .  .  S IENJ=$P(DATA(51),U,8) QUIT:IENJ'>0  ;->
"RTN","HLEVX001",128,0)
 .  .  .  S DATA(776)=$G(^HLEV(776,+IENJ,0)) QUIT:DATA(776)']""  ;->
"RTN","HLEVX001",129,0)
 .  .  .  S ^TMP($J,"HLRUN","NO",IEN)=DATA(776.2)
"RTN","HLEVX001",130,0)
 .  .  .  S ^TMP($J,"HLRUN","NO",IEN,EVNM)=DATA(51)
"RTN","HLEVX001",131,0)
 .  .  .  S ^TMP($J,"HLRUN","NO",IEN,EVNM,IENJ)=DATA(776)
"RTN","HLEVX001",132,0)
 .  .  .  S ^TMP($J,"HLRUN","NM",EVNM,IEN)="" ; xref...
"RTN","HLEVX001",133,0)
 ;
"RTN","HLEVX001",134,0)
 QUIT:'$D(^TMP($J,"HLRUN"))  ;->
"RTN","HLEVX001",135,0)
 ;
"RTN","HLEVX001",136,0)
 D ADD50("","Recent Event Runs")
"RTN","HLEVX001",137,0)
 D ADD50("",$$REPEAT^XLFSTR("-",74))
"RTN","HLEVX001",138,0)
 D ADD50("","Event-Name                      Run#1          Run#2          Run#3")
"RTN","HLEVX001",139,0)
 D ADD50("",$$REPEAT^XLFSTR("-",74))
"RTN","HLEVX001",140,0)
 S EVNM="",RUNNING=0
"RTN","HLEVX001",141,0)
 F  S EVNM=$O(^TMP($J,"HLRUN","NM",EVNM)) Q:EVNM']""  D
"RTN","HLEVX001",142,0)
 .  S TXT=$E(EVNM_$$REPEAT^XLFSTR(" ",30),1,30)_"  "
"RTN","HLEVX001",143,0)
 .  S EVIEN=0
"RTN","HLEVX001",144,0)
 .  F  S EVIEN=$O(^TMP($J,"HLRUN","NM",EVNM,EVIEN)) Q:EVIEN'>0  D
"RTN","HLEVX001",145,0)
 .  .  S IENJ=0
"RTN","HLEVX001",146,0)
 .  .  F  S IENJ=$O(^TMP($J,"HLRUN","NO",+EVIEN,EVNM,IENJ)) Q:'IENJ  D
"RTN","HLEVX001",147,0)
 .  .  .  S DATA=$G(^TMP($J,"HLRUN","NO",+EVIEN,EVNM,+IENJ)) QUIT:DATA']""  ;->
"RTN","HLEVX001",148,0)
 .  .  .  S STAT=$P(DATA,U,5),STAT=$S(STAT="F":1,1:0)
"RTN","HLEVX001",149,0)
 .  .  .  S RUNNING=RUNNING+STAT
"RTN","HLEVX001",150,0)
 .  .  .  S DATE=+DATA QUIT:DATE'?7N1"."1.N  ;->
"RTN","HLEVX001",151,0)
 .  .  .  S DATE=$E("[",STAT)_$$SDT(DATE)_$E("]",STAT)
"RTN","HLEVX001",152,0)
 .  .  .  S TXT=TXT_$E(DATE_"               ",1,15)
"RTN","HLEVX001",153,0)
 .  D ADD50("",TXT)
"RTN","HLEVX001",154,0)
 ;
"RTN","HLEVX001",155,0)
 I RUNNING D ADD50(""),ADD50(" (Dates in [brackets] are still running.)")
"RTN","HLEVX001",156,0)
 ;
"RTN","HLEVX001",157,0)
 KILL ^TMP($J,"HLRUN")
"RTN","HLEVX001",158,0)
 ;
"RTN","HLEVX001",159,0)
 Q
"RTN","HLEVX001",160,0)
 ;
"RTN","HLEVX001",161,0)
SDT(DATE) ; Return shortened form of date...
"RTN","HLEVX001",162,0)
 I DATE?7N QUIT $E(DATE,4,5)_"/"_$E(DATE,6,7) ;->
"RTN","HLEVX001",163,0)
 I DATE?7N1"."1.N QUIT $E(DATE,4,5)_"/"_$E(DATE,6,7)_"@"_$E($P($$FMTE^XLFDT(DATE),"@",2),1,5)
"RTN","HLEVX001",164,0)
 QUIT ""
"RTN","HLEVX001",165,0)
 ;
"RTN","HLEVX001",166,0)
EOR ;HLEVX001 - Event Monitor "Mother" ;5/16/03 14:42
"RTN","HLEVX002")
0^29^B29208264
"RTN","HLEVX002",1,0)
HLEVX002 ;O-OIFO/LJA - HL7 Xref Check ;02/04/2004 15:25
"RTN","HLEVX002",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVX002",3,0)
 ;
"RTN","HLEVX002",4,0)
 ; Event Types... AC-HUNG, AC-PROC'D, AC-NO 773, AC-NO 870
"RTN","HLEVX002",5,0)
 ;
"RTN","HLEVX002",6,0)
CHECKAC ; Check file 773 AC xref...
"RTN","HLEVX002",7,0)
 N ABRT,CTERR,CTXREF,ERRNO,GBL,IEN773,IEN870,NOW,XTMP,WAY,X
"RTN","HLEVX002",8,0)
 ;
"RTN","HLEVX002",9,0)
 D DEBUG^HLEVAPI2("CHECKAC")
"RTN","HLEVX002",10,0)
 D START^HLEVAPI("CTERR^CTXREF")
"RTN","HLEVX002",11,0)
 ;
"RTN","HLEVX002",12,0)
 KILL ^TMP($J,"HLEV REP"),^TMP($J,"HLEVREP"),^TMP($J,"HLMAIL773")
"RTN","HLEVX002",13,0)
 ;
"RTN","HLEVX002",14,0)
 ; Current XMTP
"RTN","HLEVX002",15,0)
 S NOW=$$NOW^XLFDT
"RTN","HLEVX002",16,0)
 S XTMP="HLEV CHK773AC "_NOW
"RTN","HLEVX002",17,0)
 S ^XTMP(XTMP,0)=$$FMADD^XLFDT(NOW,3)_U_NOW_U_"VistA HL7 773 AC Xref Check"_U_"Task# "_$G(ZTSK)
"RTN","HLEVX002",18,0)
 ;
"RTN","HLEVX002",19,0)
 ; Previous XTMP...
"RTN","HLEVX002",20,0)
 S X=$O(^XTMP(XTMP),-1),XTMP(1)=$S(X["HLEV CHK773AC":X,1:"")
"RTN","HLEVX002",21,0)
 ;
"RTN","HLEVX002",22,0)
 S GBL="^HLMA(""AC"")"
"RTN","HLEVX002",23,0)
 ; Check Xref...
"RTN","HLEVX002",24,0)
 S WAY="",(ABRT,CTERR,ERRNO)=0
"RTN","HLEVX002",25,0)
 F  S WAY=$O(@GBL@(WAY)) Q:WAY']""!(ABRT)  D
"RTN","HLEVX002",26,0)
 .  S IEN870=0
"RTN","HLEVX002",27,0)
 .  F  S IEN870=$O(@GBL@(WAY,IEN870)) Q:'IEN870!(ABRT)  D
"RTN","HLEVX002",28,0)
 .  .  S IEN773=0,CTXREF=0
"RTN","HLEVX002",29,0)
 .  .  F  S IEN773=$O(@GBL@(WAY,IEN870,IEN773)) Q:'IEN773!(ABRT)  D
"RTN","HLEVX002",30,0)
 .  .  .  S CTXREF=CTXREF+1
"RTN","HLEVX002",31,0)
 .  .  .  I '(CTXREF#1000) D  I $$S^%ZTLOAD S ABRT=1 QUIT  ;->
"RTN","HLEVX002",32,0)
 .  .  .  .  D CHECKIN^HLEVAPI
"RTN","HLEVX002",33,0)
 .  .  .  .  S $P(^XTMP(XTMP,0),U,5)=$$NOW^XLFDT
"RTN","HLEVX002",34,0)
 .  .  .  S ^XTMP(XTMP,"CURR",WAY,IEN870,IEN773)=NOW ; Next run record
"RTN","HLEVX002",35,0)
 .  .  .  D CHKAC(WAY,IEN870,IEN773)
"RTN","HLEVX002",36,0)
 ;
"RTN","HLEVX002",37,0)
 D CHECKOUT^HLEVAPI
"RTN","HLEVX002",38,0)
 ;
"RTN","HLEVX002",39,0)
 S X("HLEV REP")=$NA(^TMP($J,"HLEV REP")) D DEBUG^HLEVAPI2("CHECKAC-3",.X)
"RTN","HLEVX002",40,0)
 ;
"RTN","HLEVX002",41,0)
 ; Create report global, and move into ^TMP($J,"HLEVREP")...
"RTN","HLEVX002",42,0)
 D GENREP^HLEVUTI0($NA(^TMP($J,"HLEV REP")),$NA(^TMP($J,"HLEVREP")),4,1)
"RTN","HLEVX002",43,0)
 D MAIL773
"RTN","HLEVX002",44,0)
 D MSGTEXT^HLEVAPI1($NA(^TMP($J,"HLEVREP")))
"RTN","HLEVX002",45,0)
 ;
"RTN","HLEVX002",46,0)
 ; Send email if errors exist...
"RTN","HLEVX002",47,0)
 I ERRNO>0 D
"RTN","HLEVX002",48,0)
 .  S HLEVTXT(1)="MESSAGETEXT"
"RTN","HLEVX002",49,0)
 .  D MAILIT^HLEVAPI
"RTN","HLEVX002",50,0)
 ;
"RTN","HLEVX002",51,0)
 S X("HLEV REP")=$NA(^TMP($J,"HLEV REP")) D DEBUG^HLEVAPI2("CHECKAC-3",.X)
"RTN","HLEVX002",52,0)
 ;
"RTN","HLEVX002",53,0)
 KILL ^TMP($J,"HLEV REP"),^TMP($J,"HLEVREP"),^TMP($J,"HLMAIL773")
"RTN","HLEVX002",54,0)
 ;
"RTN","HLEVX002",55,0)
 Q
"RTN","HLEVX002",56,0)
 ;
"RTN","HLEVX002",57,0)
CHKAC(WAY,IEN870,IEN773) ; Check AC xref...
"RTN","HLEVX002",58,0)
 ;
"RTN","HLEVX002",59,0)
 ; Record in ^XTMP... (Next run compared to this for "hangarounds")
"RTN","HLEVX002",60,0)
 S ^XTMP(XTMP,"CURR",WAY,IEN870,IEN773)=NOW
"RTN","HLEVX002",61,0)
 ;
"RTN","HLEVX002",62,0)
 S WAY(1)=$S(WAY="I":"IN",1:"OUT")
"RTN","HLEVX002",63,0)
 ;
"RTN","HLEVX002",64,0)
 ; Does link exist?
"RTN","HLEVX002",65,0)
 I $G(^HLCS(870,+IEN870,0))']"" D  QUIT  ;->
"RTN","HLEVX002",66,0)
 .  D ERR(WAY(1),IEN870,IEN773,"No 870","AC-NO 870")
"RTN","HLEVX002",67,0)
 ;
"RTN","HLEVX002",68,0)
 ; Make sure zero node exists...
"RTN","HLEVX002",69,0)
 I $G(^HLMA(+IEN773,0))']"" D  QUIT  ;->
"RTN","HLEVX002",70,0)
 .  D ERR(WAY(1),IEN870,IEN773,"No 773","AC-NO 773")
"RTN","HLEVX002",71,0)
 ;
"RTN","HLEVX002",72,0)
 ; Make sure AC xref should exist...
"RTN","HLEVX002",73,0)
 I $G(^HLMA(+IEN773,"P"))?7N1"."1.N D  QUIT  ;->
"RTN","HLEVX002",74,0)
 .  D ERR(WAY(1),IEN870,IEN773,"Proc'd","AC-PROC'D")
"RTN","HLEVX002",75,0)
 ;
"RTN","HLEVX002",76,0)
 ; Check only for first entry...
"RTN","HLEVX002",77,0)
 QUIT:CTXREF>1  ;->
"RTN","HLEVX002",78,0)
 ;
"RTN","HLEVX002",79,0)
 ; Check for "hang around" AC xrefs...
"RTN","HLEVX002",80,0)
 I $G(XTMP(1))]"" D
"RTN","HLEVX002",81,0)
 .  ; Quit if didn't exist last run...
"RTN","HLEVX002",82,0)
 .  QUIT:'$D(^XTMP(XTMP(1),"CURR",WAY,IEN870,IEN773))  ;->
"RTN","HLEVX002",83,0)
 .  QUIT:$P($$UP^XLFSTR($G(^HLCS(870,+IEN870,0))),U,5)["SHUTDOWN"  ;->
"RTN","HLEVX002",84,0)
 .  D ERR($S(WAY=1:"IN",1:"OUT"),IEN870,IEN773,"Hung#","AC-HUNG")
"RTN","HLEVX002",85,0)
 ;
"RTN","HLEVX002",86,0)
 Q
"RTN","HLEVX002",87,0)
 ;
"RTN","HLEVX002",88,0)
ERR(WAY,IEN870,IEN773,REA,ETYPE) ;
"RTN","HLEVX002",89,0)
 ; ERRNO -- req
"RTN","HLEVX002",90,0)
 ;
"RTN","HLEVX002",91,0)
 ; Has this problem already been logged?
"RTN","HLEVX002",92,0)
 QUIT:'$$LOG^HLEVAPI2($G(ETYPE),"WAY^IEN870^IEN773")  ;->
"RTN","HLEVX002",93,0)
 ;
"RTN","HLEVX002",94,0)
 ; $$LOG creates (where AC-HUNG = ETYPE)...
"RTN","HLEVX002",95,0)
 ; ^HLEV(776.4,"AH","AC-HUNG","IN",25,15333) = 100
"RTN","HLEVX002",96,0)
 ; ^HLEV(776.4,"AH","AC-HUNG","X776",1183,100) = 100
"RTN","HLEVX002",97,0)
 ; ^HLEV(776.4,"AH","AC-HUNG","X7764",100,1183) = 100
"RTN","HLEVX002",98,0)
 ; 1183 = 776 ien    100 = 776.4 ien
"RTN","HLEVX002",99,0)
 ;
"RTN","HLEVX002",100,0)
 S ERRNO=$G(ERRNO)+1
"RTN","HLEVX002",101,0)
 D RECORD^HLEVX000("773 AC-"_REA,WAY,IEN870,IEN773)
"RTN","HLEVX002",102,0)
 S ^TMP($J,"HLMAIL773",IEN870,WAY,+IEN773)=$$NEXTACS(WAY,IEN870,IEN773)
"RTN","HLEVX002",103,0)
 ;
"RTN","HLEVX002",104,0)
 Q
"RTN","HLEVX002",105,0)
 ;
"RTN","HLEVX002",106,0)
NEXTACS(WAY,IEN870,I773) ; Store the next two entries...
"RTN","HLEVX002",107,0)
 N CT,NEXTIENS
"RTN","HLEVX002",108,0)
 S WAY=$E(WAY),NEXTIENS="",CT=0
"RTN","HLEVX002",109,0)
 F  S I773=$O(^HLMA("AC",WAY,IEN870,I773)) Q:'I773!(CT=2)  D
"RTN","HLEVX002",110,0)
 .  S CT=CT+1
"RTN","HLEVX002",111,0)
 .  S NEXTIENS=NEXTIENS_$S(NEXTIENS]"":U,1:"")_I773
"RTN","HLEVX002",112,0)
 Q NEXTIENS
"RTN","HLEVX002",113,0)
 ;
"RTN","HLEVX002",114,0)
MAIL773 ; Add collected 773 entry data to email message...
"RTN","HLEVX002",115,0)
 N CT,I773,IEN773,IEN870,LINKNM,NEXTACS,WAY
"RTN","HLEVX002",116,0)
 ;
"RTN","HLEVX002",117,0)
 D ADD("")
"RTN","HLEVX002",118,0)
 ;
"RTN","HLEVX002",119,0)
 S IEN870=0
"RTN","HLEVX002",120,0)
 F  S IEN870=$O(^TMP($J,"HLMAIL773",IEN870)) Q:IEN870'>0  D
"RTN","HLEVX002",121,0)
 .  S DATA=$G(^HLCS(870,+IEN870,0))
"RTN","HLEVX002",122,0)
 .  S LINKNM=$P(DATA,U)_" [#"_IEN870_"] "
"RTN","HLEVX002",123,0)
 .  D ADD("")
"RTN","HLEVX002",124,0)
 .  D ADD($$CJ^XLFSTR(LINKNM_" ",74,"="))
"RTN","HLEVX002",125,0)
 .  F NODE=0,100,200,300,400 D ADDNODE(NODE,NODE,IEN870)
"RTN","HLEVX002",126,0)
 .  S WAY=""
"RTN","HLEVX002",127,0)
 .  F  S WAY=$O(^TMP($J,"HLMAIL773",IEN870,WAY)) Q:WAY']""  D
"RTN","HLEVX002",128,0)
 .  .  S IEN773=0,CT=0
"RTN","HLEVX002",129,0)
 .  .  F  S IEN773=$O(^TMP($J,"HLMAIL773",IEN870,WAY,IEN773)) Q:IEN773'>0  D
"RTN","HLEVX002",130,0)
 .  .  .  S CT=CT+1
"RTN","HLEVX002",131,0)
 .  .  .  I CT=1 D ADD($$CJ^XLFSTR(" "_$S($E(WAY)="I":"INCOMING",1:"OUTGOING")_" ",74,"="))
"RTN","HLEVX002",132,0)
 .  .  .  D DATA773(+IEN773," Problem AC Entry ") ; Problem entry...
"RTN","HLEVX002",133,0)
 .  .  .  ; Add next two 773s...
"RTN","HLEVX002",134,0)
 .  .  .  S NEXTACS=$G(^TMP($J,"HLMAIL773",IEN870,WAY,IEN773)) QUIT:NEXTACS']""  ;->
"RTN","HLEVX002",135,0)
 .  .  .  F PCE=1:1:$L(NEXTACS,U) D
"RTN","HLEVX002",136,0)
 .  .  .  .  S I773=+$P(NEXTACS,U,PCE) QUIT:I773'>0  ;->
"RTN","HLEVX002",137,0)
 .  .  .  .  D DATA773(I773," Entry After AC Problem ")
"RTN","HLEVX002",138,0)
 ;
"RTN","HLEVX002",139,0)
 Q
"RTN","HLEVX002",140,0)
 ;
"RTN","HLEVX002",141,0)
ADDNODE(NODE,NAME,IEN870) ; Add node data prefixed by node name...
"RTN","HLEVX002",142,0)
 N DATA,PFX
"RTN","HLEVX002",143,0)
 S PFX=$S(NODE=+NODE:"",1:"""")
"RTN","HLEVX002",144,0)
 S DATA="^HLCS(870,"_IEN870_","_PFX_NAME_PFX_")="_$G(^HLCS(870,+IEN870,NODE))
"RTN","HLEVX002",145,0)
 D ADD(DATA)
"RTN","HLEVX002",146,0)
 Q
"RTN","HLEVX002",147,0)
 ;
"RTN","HLEVX002",148,0)
DATA773(IEN773,PROBL) ; Add critical data to Email message...
"RTN","HLEVX002",149,0)
 N DATA773,NO
"RTN","HLEVX002",150,0)
 ;
"RTN","HLEVX002",151,0)
 D ADD($$CJ^XLFSTR($G(PROBL),74,"="))
"RTN","HLEVX002",152,0)
 ;
"RTN","HLEVX002",153,0)
 KILL ^TMP($J,"HLDATA773")
"RTN","HLEVX002",154,0)
 ;
"RTN","HLEVX002",155,0)
 ; Collect 773 informaiton...
"RTN","HLEVX002",156,0)
 D ENDIQ1^HLEVUTIL(773,+IEN773,"HLDATA773")
"RTN","HLEVX002",157,0)
 ;
"RTN","HLEVX002",158,0)
 S ^TMP($J,"HLDATA773",1)="       "_$$CJ^XLFSTR(" 773# "_IEN773_" ",60,"-")_"       "
"RTN","HLEVX002",159,0)
 S NO=0
"RTN","HLEVX002",160,0)
 F  S NO=$O(^TMP($J,"HLDATA773",NO)) Q:NO'>0  D
"RTN","HLEVX002",161,0)
 .  D ADD(^TMP($J,"HLDATA773",+NO))
"RTN","HLEVX002",162,0)
 ;
"RTN","HLEVX002",163,0)
 KILL ^TMP($J,"HLDATA773")
"RTN","HLEVX002",164,0)
 ;
"RTN","HLEVX002",165,0)
 Q
"RTN","HLEVX002",166,0)
 ;
"RTN","HLEVX002",167,0)
ADD(TXT,TRAIL) ; Add TXT to ^TMP($J,"HLEVREP",#)...
"RTN","HLEVX002",168,0)
 N COL,LEN,NO,TXTOLD
"RTN","HLEVX002",169,0)
 ;
"RTN","HLEVX002",170,0)
 S LEN=$L($P(TXT,"=")),LEN=$S('LEN:3,LEN<55:LEN+1,1:3)
"RTN","HLEVX002",171,0)
 ;
"RTN","HLEVX002",172,0)
 F  D  QUIT:TXT']""
"RTN","HLEVX002",173,0)
 .  S NO=$O(^TMP($J,"HLEVREP",":"),-1)+1
"RTN","HLEVX002",174,0)
 .  S ^TMP($J,"HLEVREP",+NO)=$E(TXT,1,74)
"RTN","HLEVX002",175,0)
 .  S TXT=$E(TXT,75,999) QUIT:TXT']""  ;->
"RTN","HLEVX002",176,0)
 .  S TXT=$$REPEAT^XLFSTR(" ",LEN)_TXT
"RTN","HLEVX002",177,0)
 ;
"RTN","HLEVX002",178,0)
 Q
"RTN","HLEVX002",179,0)
 ;
"RTN","HLEVX002",180,0)
EOR ;HLEVX002 - VistA HL7 Event Monitor Code ;5/30/03 15:25
"RTN","HLEVX003")
0^44^B3724887
"RTN","HLEVX003",1,0)
HLEVX003 ;O-OIFO/LJA - VistA HL7 Event Monitor Code ;02/04/2004 15:25
"RTN","HLEVX003",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLEVX003",3,0)
 ;
"RTN","HLEVX003",4,0)
REPDINUM ; Create event log entry(s) for DINUM problems.  (Use the
"RTN","HLEVX003",5,0)
 ; condensed report text instead of making one event for every DINUM
"RTN","HLEVX003",6,0)
 ; problem.)
"RTN","HLEVX003",7,0)
 ;
"RTN","HLEVX003",8,0)
 ; {01/16/04 - Added so wouldn't create thousands of events.}
"RTN","HLEVX003",9,0)
 ;
"RTN","HLEVX003",10,0)
 N LINK,LN,NO,PROB,QUIT,TAG,TXT,WAY
"RTN","HLEVX003",11,0)
 ;
"RTN","HLEVX003",12,0)
 KILL ^TMP($J,"HLEVDINUM")
"RTN","HLEVX003",13,0)
 ;
"RTN","HLEVX003",14,0)
 S LN=0,PROB="",QUIT=0,WAY="",LINK=""
"RTN","HLEVX003",15,0)
 F  S LN=$O(^TMP($J,"HLEVREP",LN)) Q:'LN!(QUIT)  D
"RTN","HLEVX003",16,0)
 .  S TXT=^TMP($J,"HLEVREP",LN)
"RTN","HLEVX003",17,0)
 .  I $P(TXT," ")="DINUM" S PROB="DINUM",WAY="",LINK=""
"RTN","HLEVX003",18,0)
 .  QUIT:PROB'="DINUM"  ;-> No DINUMs, or not to them yet...
"RTN","HLEVX003",19,0)
 .  ; $$RDT returns LINK and WAY...
"RTN","HLEVX003",20,0)
 .  S TXT=$$RDT(TXT) QUIT:TXT']""!(LINK']"")!(WAY']"")  ;->
"RTN","HLEVX003",21,0)
 .  F NO=1:1:$L(TXT,",") D
"RTN","HLEVX003",22,0)
 .  .  S TXT(1)=$P(TXT,",",NO) QUIT:TXT(1)']""  ;->
"RTN","HLEVX003",23,0)
 .  .  S ^TMP($J,"HLEVDINUM",LINK,WAY,TXT(1))=""
"RTN","HLEVX003",24,0)
 ;
"RTN","HLEVX003",25,0)
 ; No DINUM problems exist...
"RTN","HLEVX003",26,0)
 S LINK=""
"RTN","HLEVX003",27,0)
 F  S LINK=$O(^TMP($J,"HLEVDINUM",LINK)) Q:LINK']""  D
"RTN","HLEVX003",28,0)
 .  S WAY=""
"RTN","HLEVX003",29,0)
 .  F  S WAY=$O(^TMP($J,"HLEVDINUM",LINK,WAY)) Q:WAY']""  D
"RTN","HLEVX003",30,0)
 .  .  S MIENS=""
"RTN","HLEVX003",31,0)
 .  .  F  S MIENS=$O(^TMP($J,"HLEVDINUM",LINK,WAY,MIENS)) Q:MIENS']""  D
"RTN","HLEVX003",32,0)
 .  .  .  S X=$$LOG^HLEVAPI2("870-DINUM","LINK^WAY^MIENS")
"RTN","HLEVX003",33,0)
 ;
"RTN","HLEVX003",34,0)
 KILL ^TMP($J,"HLEVDINUM")
"RTN","HLEVX003",35,0)
 ;
"RTN","HLEVX003",36,0)
 Q
"RTN","HLEVX003",37,0)
 ;
"RTN","HLEVX003",38,0)
RDT(TXT) ; Strip down TXT to include only DINUM report details...
"RTN","HLEVX003",39,0)
 ; Returns LINK & WAY...
"RTN","HLEVX003",40,0)
 ;
"RTN","HLEVX003",41,0)
 ; {01/16/04 - See REPDINUM}
"RTN","HLEVX003",42,0)
 ;
"RTN","HLEVX003",43,0)
 ; First line of DINUM INCOMING or OUTGOING...
"RTN","HLEVX003",44,0)
 I TXT["  INCOMING  " D  QUIT $P(TXT,"COMING  ",2,99)  ;->
"RTN","HLEVX003",45,0)
 .  S LINK=$P($E(TXT,16,99),"]")_"]"
"RTN","HLEVX003",46,0)
 .  S WAY="INCOMING"
"RTN","HLEVX003",47,0)
 .
"RTN","HLEVX003",48,0)
 I TXT["  OUTGOING  " D  QUIT $P(TXT,"GOING  ",2,99)  ;->
"RTN","HLEVX003",49,0)
 .  S LINK=$P($E(TXT,16,99),"]")_"]"
"RTN","HLEVX003",50,0)
 .  S WAY="OUTGOING"
"RTN","HLEVX003",51,0)
 ;
"RTN","HLEVX003",52,0)
 ; Strip spaces and check pattern match...
"RTN","HLEVX003",53,0)
 S TXT=$TR(TXT," ","") QUIT:TXT']"" "" ;->
"RTN","HLEVX003",54,0)
 QUIT:TXT'?1.N1":"1.N1"(#"1.N1")".E "" ;->
"RTN","HLEVX003",55,0)
 ;
"RTN","HLEVX003",56,0)
 Q TXT
"RTN","HLEVX003",57,0)
 ;
"RTN","HLEVX003",58,0)
EOR ;HLEVX003 - VistA HL7 Event Monitor Code ;5/30/03 15:25
"RTN","HLLOG")
0^74^B2577409
"RTN","HLLOG",1,0)
HLLOG ;OIFO-O/JLG - (LOG API) ;11/24/2003  16:48
"RTN","HLLOG",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13,1995
"RTN","HLLOG",3,0)
 Q
"RTN","HLLOG",4,0)
 ;
"RTN","HLLOG",5,0)
ENTERING(RTN,SUB,COOKIE) ;
"RTN","HLLOG",6,0)
 ; RTN -    the routine from which called 
"RTN","HLLOG",7,0)
 ; SUB -    the subroutine from which called 
"RTN","HLLOG",8,0)
 ; COOKIE - current session id as $H; to be used subsequently 
"RTN","HLLOG",9,0)
 ;          in EXITING^HLLOG
"RTN","HLLOG",10,0)
 ;
"RTN","HLLOG",11,0)
 N SITE,XTMP
"RTN","HLLOG",12,0)
 Q:'$$ENABLED
"RTN","HLLOG",13,0)
 Q:$G(RTN)=""  Q:$G(SUB)=""  Q:$G(COOKIE)=""
"RTN","HLLOG",14,0)
 S SITE=+$P($$SITE^VASITE,U,3)
"RTN","HLLOG",15,0)
 S XTMP="HL LOG "_DT
"RTN","HLLOG",16,0)
 S:'$D(^XTMP(XTMP,0)) ^XTMP(XTMP,0)=$$FMADD^XLFDT(DT,30)_U_$$NOW^XLFDT_U_"Log data created by call to HLLOG"
"RTN","HLLOG",17,0)
 S COOKIE=$H
"RTN","HLLOG",18,0)
 S ^XTMP(XTMP,SITE,RTN,SUB,$J,COOKIE,"ENTER")=$$STATS^%ZOSVKR
"RTN","HLLOG",19,0)
 Q
"RTN","HLLOG",20,0)
 ;
"RTN","HLLOG",21,0)
EXITING(RTN,SUB,COOKIE) ;
"RTN","HLLOG",22,0)
 ; RTN -    the routine from which called 
"RTN","HLLOG",23,0)
 ; SUB -    the subroutine from which called 
"RTN","HLLOG",24,0)
 ; COOKIE - current session id as $H; previously used in ENTERING^HLLOG 
"RTN","HLLOG",25,0)
 ;
"RTN","HLLOG",26,0)
 Q:'$$ENABLED
"RTN","HLLOG",27,0)
 Q:$G(RTN)=""  Q:$G(SUB)=""  Q:$G(COOKIE)=""
"RTN","HLLOG",28,0)
 S SITE=+$P($$SITE^VASITE,U,3)
"RTN","HLLOG",29,0)
 S XTMP="HL LOG "_DT
"RTN","HLLOG",30,0)
 S:'$D(^XTMP(XTMP,0)) ^XTMP(XTMP,0)=$$FMADD^XLFDT(DT,30)_U_$$NOW^XLFDT_"U"_"Log data created by call to HLLOG"
"RTN","HLLOG",31,0)
 S ^XTMP(XTMP,SITE,RTN,SUB,$J,COOKIE,"EXIT")=$$STATS^%ZOSVKR_U_$$HDIFF^XLFDT($H,COOKIE,2)
"RTN","HLLOG",32,0)
 Q
"RTN","HLLOG",33,0)
 ;
"RTN","HLLOG",34,0)
ENABLED() ;
"RTN","HLLOG",35,0)
 ; check that this functionality is enabled
"RTN","HLLOG",36,0)
 ;Q $P(^HLCS(869.3,1,0),U,6)
"RTN","HLLOG",37,0)
 Q 1
"RTN","HLLOG",38,0)
 ;
"RTN","HLMA")
0^75^B36061622
"RTN","HLMA",1,0)
HLMA ;AISC/SAW-Message Administration Module ;11/17/2003  12:34
"RTN","HLMA",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,58,63,66,82,91,108,109**;Oct 13, 1995
"RTN","HLMA",3,0)
GENERATE(HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLMTIEN,HLP) ;
"RTN","HLMA",4,0)
 ;Entry point to generate a deferred message
"RTN","HLMA",5,0)
 ;
"RTN","HLMA",6,0)
 ;This is a subroutine call with parameter passing.  It returns a
"RTN","HLMA",7,0)
 ;value in the variable HLRESLT with 1 to 3 pieces separated by uparrows
"RTN","HLMA",8,0)
 ;as follows:  1st message ID^error code^error description
"RTN","HLMA",9,0)
 ;If no error occurs, only the first piece is returned equal to a unique
"RTN","HLMA",10,0)
 ;ID for the 1st message.  If message was sent to more than 1 subscriber
"RTN","HLMA",11,0)
 ;than the other message IDs will be in the array HLRESLT(n)=ID
"RTN","HLMA",12,0)
 ;Otherwise, three pieces are returned with the
"RTN","HLMA",13,0)
 ;first piece equal to the message ID, if one was assigned, otherwise 0
"RTN","HLMA",14,0)
 ;
"RTN","HLMA",15,0)
 ;Required Input Parameters
"RTN","HLMA",16,0)
 ;     HLEID = Name or IEN of event driver protocol in the Protocol file
"RTN","HLMA",17,0)
 ;  HLARYTYP = Array type.  One of the following codes:
"RTN","HLMA",18,0)
 ;               LM = local array containing a single message
"RTN","HLMA",19,0)
 ;               LB = local array containig a batch of messages
"RTN","HLMA",20,0)
 ;               GM = global array containing a single message
"RTN","HLMA",21,0)
 ;               GB = global array containing a batch of messages
"RTN","HLMA",22,0)
 ;  HLFORMAT = Format of array, 1 for pre-formatted in HL7 format,
"RTN","HLMA",23,0)
 ;               otherwise 0
"RTN","HLMA",24,0)
 ;NOTE:  The parameter HLRESLT must be passed by reference
"RTN","HLMA",25,0)
 ;   HLRESLT = The variable that will be returned to the calling
"RTN","HLMA",26,0)
 ;               application as descibed above
"RTN","HLMA",27,0)
 ;Optional Parameters
"RTN","HLMA",28,0)
 ;   HLMTIEN = IEN of entry in Message Text file where the message
"RTN","HLMA",29,0)
 ;               being generated is to be stored.  This parameter is
"RTN","HLMA",30,0)
 ;               only passed for a batch type message
"RTN","HLMA",31,0)
 ;NOTE:  The parameter HLP used for the following parameters must be
"RTN","HLMA",32,0)
 ;       passed by reference
"RTN","HLMA",33,0)
 ;  HLP("SECURITY") = A 1 to 40 character string
"RTN","HLMA",34,0)
 ;   HLP("CONTPTR") = Continuation pointer, a 1 to 180 character string
"RTN","HLMA",35,0)
 ; HLP("NAMESPACE") = Passed in by application namespace - HL*1.6*91
"RTN","HLMA",36,0)
 ;
"RTN","HLMA",37,0)
 ;can't have link open when generating new message
"RTN","HLMA",38,0)
 N HLTCP,HLTCPO,HLPRIO,HLMIDAR
"RTN","HLMA",39,0)
 S HLPRIO="D"
"RTN","HLMA",40,0)
 ;Check for required parameters
"RTN","HLMA",41,0)
CONT I $G(HLEID)']""!($G(HLARYTYP)']"")!($G(HLFORMAT)']"") S HLRESLT="0^7^"_$G(^HL(771.7,7,0))_" at GENERATE^HLMA entry point" G EXIT
"RTN","HLMA",42,0)
 I 'HLEID S HLEID=$O(^ORD(101,"B",HLEID,0)) I 'HLEID S HLRESLT="0^1^"_$G(^HL(771.7,1,0)) G EXIT
"RTN","HLMA",43,0)
 I "GL"'[$E(HLARYTYP) S HLRESLT="0^4^"_$G(^HL(771.7,4,0)) G EXIT
"RTN","HLMA",44,0)
 I $L($G(HLP("SECURITY")))>40 S HLRESLT="0^6^"_$G(^HL(771.7,6,0)) G EXIT
"RTN","HLMA",45,0)
 I $L($G(HLP("CONTPTR")))>180 S HLRESLT="0^11^"_$G(^HL(771.7,11,0)) G EXIT
"RTN","HLMA",46,0)
 I $D(HLL("LINKS")) D  G:$G(HLRESLT)]"" EXIT
"RTN","HLMA",47,0)
 . N I,HLPNAM,HLPIEN,HLLNAM,HLLIEN
"RTN","HLMA",48,0)
 . S I=0
"RTN","HLMA",49,0)
 . F  S I=$O(HLL("LINKS",I)) Q:'I  D  Q:$G(HLRESLT)]""
"RTN","HLMA",50,0)
 . . S HLPNAM=$P(HLL("LINKS",I),U)
"RTN","HLMA",51,0)
 . . S HLPIEN=+$O(^ORD(101,"B",HLPNAM,0))
"RTN","HLMA",52,0)
 . . I $P($G(^ORD(101,HLPIEN,0)),U,4)'="S" S HLRESLT="0^15^Invalid Subscriber Protocol in HLL('LINKS'): "_HLL("LINKS",I) Q
"RTN","HLMA",53,0)
 . . S HLLNAM=$P(HLL("LINKS",I),U,2)
"RTN","HLMA",54,0)
 . . S HLLIEN=+$O(^HLCS(870,"B",HLLNAM,0))
"RTN","HLMA",55,0)
 . . I '$D(^HLCS(870,HLLIEN,0)) S HLRESLT="0^15^Invalid HL Node in HLL('LINKS'): "_HLL("LINKS",I) Q
"RTN","HLMA",56,0)
 ;Extract data from Protocol file
"RTN","HLMA",57,0)
 D EVENT^HLUTIL1(HLEID,"15,20,771",.HLN)
"RTN","HLMA",58,0)
 S HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15))
"RTN","HLMA",59,0)
 S HLP("GROUTINE")=$G(HLN(771)) K HLN I HLP("GROUTINE")']"",'HLFORMAT S HLRESLT="0^3^"_$G(^HL(771.7,3,0)) G EXIT
"RTN","HLMA",60,0)
 ;Create message ID and Message Text IEN if Message Text IEN not
"RTN","HLMA",61,0)
 ;previously created ('$G(HLMTIEN))
"RTN","HLMA",62,0)
 I '$G(HLMTIEN) D CREATE^HLTF(.HLMID,.HLMTIEN,.HLDT,.HLDT1)
"RTN","HLMA",63,0)
 ;Get message ID if Message Text IEN already created
"RTN","HLMA",64,0)
 I '$G(HLMID) D
"RTN","HLMA",65,0)
 .S HLDT=$G(^HL(772,HLMTIEN,0)),HLMID=$P(HLDT,"^",6),HLDT=+HLDT
"RTN","HLMA",66,0)
 .S HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLMA",67,0)
 S HLMIDAR=0,HLRESLT=HLMID,HLP("DT")=HLDT,HLP("DTM")=HLDT1
"RTN","HLMA",68,0)
 ;Execute entry action for event driver protocol
"RTN","HLMA",69,0)
 I HLENROU]"" X HLENROU
"RTN","HLMA",70,0)
 ;Invoke transaction processor
"RTN","HLMA",71,0)
 K HLDT,HLDT1,HLENROU
"RTN","HLMA",72,0)
 D GENERATE^HLTP(HLMID,HLMTIEN,HLEID,HLARYTYP,HLFORMAT,.HLRESLT1,.HLP)
"RTN","HLMA",73,0)
 ;HLMIDAR is array of message IDs, only set for broadcast messages
"RTN","HLMA",74,0)
 I HLMIDAR K HLMIDAR("N") M HLRESLT=HLMIDAR
"RTN","HLMA",75,0)
 S HLRESLT=HLRESLT_"^"_HLRESLT1
"RTN","HLMA",76,0)
 ;Execute exit action for event driver protocol
"RTN","HLMA",77,0)
 I HLEXROU]"" X HLEXROU
"RTN","HLMA",78,0)
EXIT ;Update status if Message Text file entry has been created
"RTN","HLMA",79,0)
 K HLTCP
"RTN","HLMA",80,0)
 I $D(HLMTIEN) D STATUS^HLTF0(HLMTIEN,$S($P(HLRESLT,"^",2):4,1:3),$S($P(HLRESLT,"^",2):$P(HLRESLT,"^",2),1:""),$S($P(HLRESLT,"^",2):$P(HLRESLT,"^",3),1:""))
"RTN","HLMA",81,0)
 K HLDT,HLDT1,HLMID,HLRESLT1,HLENROU,HLEXROU
"RTN","HLMA",82,0)
 Q
"RTN","HLMA",83,0)
DIRECT(HLEID,HLARYTYP,HLFORMAT,HLRESLT,HLMTIENO,HLP) ;
"RTN","HLMA",84,0)
 ;Entry point to generate an immediate message, must be TCP Logical Link
"RTN","HLMA",85,0)
 ;input parameters are the same as GENERATE
"RTN","HLMA",86,0)
 N HLTCP,HLTCPO,HLPRIO,HLSAN,HLN,HLMIDAR,HLMTIENR,ZMID
"RTN","HLMA",87,0)
 ;HLMTIENO=ien passed in, batch message
"RTN","HLMA",88,0)
 S HLMTIEN=$G(HLMTIENO)
"RTN","HLMA",89,0)
 K HL,HLMTIENO
"RTN","HLMA",90,0)
 D INIT^HLFNC2(HLEID,.HL)
"RTN","HLMA",91,0)
 I $G(HL) S HLRESLT="0^"_HL Q
"RTN","HLMA",92,0)
 S HLPRIO="I" D CONT
"RTN","HLMA",93,0)
 ;HLMTIENO=original msg. ien in file 772, HLMTIENR=response ien set in HLMA2
"RTN","HLMA",94,0)
 S HLMTIENO=HLMTIEN,HLMTIEN=$G(HLMTIENR)
"RTN","HLMA",95,0)
 ;Set special HL variables
"RTN","HLMA",96,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLMA",97,0)
 Q
"RTN","HLMA",98,0)
 ;
"RTN","HLMA",99,0)
CLOSE(LOGLINK) ;close connection that was open in tag DIRECT
"RTN","HLMA",100,0)
 Q
"RTN","HLMA",101,0)
PING ;ping another VAMC to test Link
"RTN","HLMA",102,0)
 ;set HLQUIET =1 to skip writes
"RTN","HLMA",103,0)
 ;look for HLTPUT to get turnaround time over network.
"RTN","HLMA",104,0)
 N DA,DIC,HLDP,HLDPNM,HLDPDM,HLCSOUT,HLDBSIZE,HLDREAD,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL,HLPARAM
"RTN","HLMA",105,0)
 N HCS,HCSCMD,HLCS,HCSDAT,HCSER,HCSEXIT,HCSTRACE,HLDT1,HLDRETR,HLRETRA,HLDBACK,HLDWAIT,HLTCPCS,INPUT,OUTPUT,POP,X,Y,HLX1,HLX2
"RTN","HLMA",106,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA",107,0)
 S HLCS="",HCSTRACE="C: ",POP=1,INPUT="INPUT",OUTPUT="OUTPUT"
"RTN","HLMA",108,0)
 S DIC="^HLCS(870,",DIC(0)="QEAMZ"
"RTN","HLMA",109,0)
 D ^DIC Q:Y<0
"RTN","HLMA",110,0)
 S HLDP=+Y,HLDPNM=Y(0,0),HLDPDM=$P($$PARAM^HLCS2,U,2)
"RTN","HLMA",111,0)
 ;I $P($G(^HLCS(870,HLDP,400)),U)="" W !,"Missing IP Address" Q
"RTN","HLMA",112,0)
 D SETUP^HLCSAC G:HLCS PINGQ
"RTN","HLMA",113,0)
 ;PING header=MSH^PING^domain^PING^logical link^datetime
"RTN","HLMA",114,0)
 S INPUT(1)="MSH^PING^"_HLDPDM_"^PING^"_HLDPNM_"^"_$$HTE^XLFDT($H)
"RTN","HLMA",115,0)
 D OPEN^HLCSAC
"RTN","HLMA",116,0)
 I HLCS D DNS G:HLCS PINGQ
"RTN","HLMA",117,0)
 D
"RTN","HLMA",118,0)
 . N $ETRAP,$ESTACK S $ETRAP="D PINGERR^HLMA"
"RTN","HLMA",119,0)
 . ;non-standard HL7 header; start block,header,end block
"RTN","HLMA",120,0)
 . S HLX1=$H
"RTN","HLMA",121,0)
 . W $C(11)_INPUT(1)_$C(28)_$C(13),@IOF ;HL*1.6*108, FLUSH BUFFER
"RTN","HLMA",122,0)
 . ;read response
"RTN","HLMA",123,0)
 . R X:HLDREAD
"RTN","HLMA",124,0)
 . S HLX2=$H
"RTN","HLMA",125,0)
 . S X=$P(X,$C(28)),HLCS=$S(X=INPUT(1):"PING worked",X="":"No response",1:"Incorrect response")
"RTN","HLMA",126,0)
 . ;Get roundtrip time
"RTN","HLMA",127,0)
 . K HLTPUT I X]"" S HLTPUT=$$HDIFF^XLFDT(HLX2,HLX1,2)
"RTN","HLMA",128,0)
 D CLOSE^%ZISTCP
"RTN","HLMA",129,0)
PINGQ ;write back status and quit
"RTN","HLMA",130,0)
 I 'HLQUIET W !,HLCS,!
"RTN","HLMA",131,0)
 Q
"RTN","HLMA",132,0)
PINGERR ;process errors from PING
"RTN","HLMA",133,0)
 S $ETRAP="G UNWIND^%ZTER",HLCS="-1^Error"
"RTN","HLMA",134,0)
 I $ZE["READ" S HLCS="-1^Error during read"
"RTN","HLMA",135,0)
 I $ZE["WRITE" S HLCS="-1^Error during write"
"RTN","HLMA",136,0)
 G UNWIND^%ZTER
"RTN","HLMA",137,0)
DNS ;
"RTN","HLMA",138,0)
 ;openfail-try DNS lookup-Link must contain point to Domain Name
"RTN","HLMA",139,0)
 S POP=$G(POP)
"RTN","HLMA",140,0)
 S HLQUIET=$G(HLQUIET)
"RTN","HLMA",141,0)
 I 'HLQUIET W !,"Calling DNS"
"RTN","HLMA",142,0)
 N HLDOM,HLIP S HLCS=""
"RTN","HLMA",143,0)
 S HLDOM=$P(^HLCS(870,HLDP,0),U,7)
"RTN","HLMA",144,0)
 I 'HLDOM,'HLQUIET W !,"Domain Unknown" Q
"RTN","HLMA",145,0)
 I HLDOM S HLDOM=$P(^DIC(4.2,HLDOM,0),U)
"RTN","HLMA",146,0)
 I HLDOM]"" D  Q:'POP
"RTN","HLMA",147,0)
 . I HLDOM["VA.GOV"&(HLDOM'[".MED.") S HLDOM=$P(HLDOM,".VA.GOV")_".MED.VA.GOV"
"RTN","HLMA",148,0)
 . I HLTCPORT=5000 S HLDOM="HL7."_HLDOM
"RTN","HLMA",149,0)
 . I HLTCPORT=5500 S HLDOM="MPI."_HLDOM
"RTN","HLMA",150,0)
 . I 'HLQUIET W !,"Domain, "_HLDOM
"RTN","HLMA",151,0)
 . I 'HLQUIET W !,"Port: ",HLTCPORT
"RTN","HLMA",152,0)
 . S HLIP=$$ADDRESS^XLFNSLK(HLDOM)
"RTN","HLMA",153,0)
 . I HLIP]"",'HLQUIET W !,"DNS Returned: ",HLIP
"RTN","HLMA",154,0)
 . I HLIP]"" D
"RTN","HLMA",155,0)
 . . ;If more than one IP returned, try each, cache successful open
"RTN","HLMA",156,0)
 . . N HLI,HLJ,HLIP1
"RTN","HLMA",157,0)
 . . F HLJ=1:1:$L(HLIP,",") D  Q:'POP
"RTN","HLMA",158,0)
 . . . S HLIP1=$P(HLIP,",",HLJ)
"RTN","HLMA",159,0)
 . . . F HLI=1:1:HLDRETR W:'HLQUIET !,"Trying ",HLIP1 D CALL^%ZISTCP(HLIP1,HLTCPORT,1) Q:'POP
"RTN","HLMA",160,0)
 . . . I 'POP S $P(^HLCS(870,HLDP,400),U)=HLIP1
"RTN","HLMA",161,0)
 . . . U IO
"RTN","HLMA",162,0)
 I POP S HLCS="-1^DNS Lookup Failed"
"RTN","HLMA0")
0^76^B1356890
"RTN","HLMA0",1,0)
HLMA0 ;AISC/SAW-Message Administration Module (Cont'd) ;7/17/97  17:30
"RTN","HLMA0",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**34,109**;Oct 13, 1995
"RTN","HLMA0",3,0)
RECEIVE(HLLD0,HLLD1) ;Entry point to receive an external message
"RTN","HLMA0",4,0)
 ;
"RTN","HLMA0",5,0)
 ;This is a subroutine call with parameter passing.  There are no
"RTN","HLMA0",6,0)
 ;output parameters returned by this call.
"RTN","HLMA0",7,0)
 ;
"RTN","HLMA0",8,0)
 ;Required Input Parameter
"RTN","HLMA0",9,0)
 ;  HLLD0 = Internal entry number where message is stored in Logical Link
"RTN","HLMA0",10,0)
 ;           file or XM if message is stored in MailMan
"RTN","HLMA0",11,0)
 ;Optional Input Parameter (Required if HLLD0 does not equal XM)
"RTN","HLMA0",12,0)
 ;  HLLD1 = Internal entry number of IN QUEUE multiple entry in Logical
"RTN","HLMA0",13,0)
 ;           Link file
"RTN","HLMA0",14,0)
 ;
"RTN","HLMA0",15,0)
 ;Check for required parameter
"RTN","HLMA0",16,0)
 I $G(HLLD0)']"" Q
"RTN","HLMA0",17,0)
 I HLLD0'="XM",'$G(HLLD1) Q
"RTN","HLMA0",18,0)
 N HLRESLT
"RTN","HLMA0",19,0)
 ;Get message ID and Message Text IEN for message being received
"RTN","HLMA0",20,0)
 D CREATE^HLTF(.HLMID,.HLMTIEN,.HLDT,.HLDT1)
"RTN","HLMA0",21,0)
 K HLDT,HLDT1
"RTN","HLMA0",22,0)
 ;Call Transaction Processor
"RTN","HLMA0",23,0)
 D PROCESS^HLTP0(HLMTIEN,HLLD0,$S($G(HLLD1):HLLD1,1:""),.HLRESLT)
"RTN","HLMA0",24,0)
 ;Update Status to Successfully Completed or Error During Transmission
"RTN","HLMA0",25,0)
 D STATUS^HLTF0(HLMTIEN,$S(HLRESLT:4,1:3),$S(HLRESLT:+HLRESLT,1:""),$S(HLRESLT:$P(HLRESLT,"^",2),1:""),,$S($G(HLERR("SKIP_EVENT"))=1:1,1:0))
"RTN","HLMA0",26,0)
EXIT K HLMTIEN,HLRESLT
"RTN","HLMA0",27,0)
 Q
"RTN","HLMA1")
0^77^B8095560
"RTN","HLMA1",1,0)
HLMA1 ;AISC/SAW-Message Administration Module (Cont'd) ;04/06/99  10:56
"RTN","HLMA1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,91,109**;Oct 13, 1995
"RTN","HLMA1",3,0)
GENACK(HLEID,HLMTIENS,HLEIDS,HLARYTYP,HLFORMAT,HLRESLTA,HLMTIENA,HLP) ;
"RTN","HLMA1",4,0)
 ;Entry point to generate an acknowledgement message
"RTN","HLMA1",5,0)
 ;
"RTN","HLMA1",6,0)
 ;This is a subroutine call with parameter passing.  It returns a value
"RTN","HLMA1",7,0)
 ;in the variable HLRESLTA of null if no error occurs, or the following
"RTN","HLMA1",8,0)
 ;two piece value if an error occurs:  error code^error description
"RTN","HLMA1",9,0)
 ;
"RTN","HLMA1",10,0)
 ;Required Input Parameters
"RTN","HLMA1",11,0)
 ;     HLEID = IEN of event driver protocol from the Protocol file
"RTN","HLMA1",12,0)
 ;  HLMTIENS = IEN of entry in Message Text file for subscriber
"RTN","HLMA1",13,0)
 ;               application
"RTN","HLMA1",14,0)
 ;    HLEIDS = IEN of subscriber event from the Protocol file
"RTN","HLMA1",15,0)
 ;  HLARYTYP = Array type.  One of the following codes:
"RTN","HLMA1",16,0)
 ;               LM = local array containing a single message
"RTN","HLMA1",17,0)
 ;               LB = local array containig a batch of messages
"RTN","HLMA1",18,0)
 ;               GM = global array containing a single message
"RTN","HLMA1",19,0)
 ;               GB = global array containing a batch of messages
"RTN","HLMA1",20,0)
 ;  HLFORMAT = Format of array, 1 for pre-formatted in HL7 format,
"RTN","HLMA1",21,0)
 ;               otherwise 0
"RTN","HLMA1",22,0)
 ;NOTE:  The parameter HLRESLTA must be passed by reference
"RTN","HLMA1",23,0)
 ;  HLRESLTA = The variable that will be returned to the calling
"RTN","HLMA1",24,0)
 ;               application as descibed above
"RTN","HLMA1",25,0)
 ;Optional Parameters
"RTN","HLMA1",26,0)
 ;  HLMTIENA = IEN of entry in Message Text file where the
"RTN","HLMA1",27,0)
 ;               acknowledgement message will be stored.  This
"RTN","HLMA1",28,0)
 ;               parameter is only passed for a batch acknowledgment
"RTN","HLMA1",29,0)
 ;  HLP("SECURITY") = A 1 to 40 character string
"RTN","HLMA1",30,0)
 ; HLP("NAMESPACE") = Passed in by application namespace - HL*1.6*91
"RTN","HLMA1",31,0)
 ;
"RTN","HLMA1",32,0)
 ;Check for required parameters
"RTN","HLMA1",33,0)
 I $G(HLEIDS)']""!('$G(HLMTIENS))!($G(HLARYTYP)']"")!($G(HLFORMAT)']"") S HLRESLTA="0^7^"_$G(^HL(771.7,7,0))_" at GENACK^HLMA1 entry point" G EXIT
"RTN","HLMA1",34,0)
 I 'HLEIDS S HLEIDS=$O(^ORD(101,"B",HLEIDS,0)) I 'HLEIDS S HLRESLTA="0^1^"_$G(^HL(771.7,1,0)) G EXIT
"RTN","HLMA1",35,0)
 ;Extract data from Protocol file
"RTN","HLMA1",36,0)
 D EVENT^HLUTIL1(HLEIDS,"15,20,772",.HLN)
"RTN","HLMA1",37,0)
 N HLEXROU,HLMIDAR
"RTN","HLMA1",38,0)
 S HLMIDAR=0,HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15))
"RTN","HLMA1",39,0)
 S HLP("GROUTINE")=$G(HLN(772)) K HLN I HLP("GROUTINE")']"",'HLFORMAT S HLRESLTA="0^3^"_$G(^HL(771.7,3,0)) G EXIT
"RTN","HLMA1",40,0)
 I "GL"'[$E($G(HLARYTYP)) S HLRESLTA="0^4^"_$G(^HL(771.7,4,0)) G EXIT
"RTN","HLMA1",41,0)
 I '$D(HLP("SECURITY")) S HLP("SECURITY")=""
"RTN","HLMA1",42,0)
 I $L(HLP("SECURITY"))>40 S HLRESLTA="0^6^"_$G(^HL(771.7,6,0)) G EXIT
"RTN","HLMA1",43,0)
 ;$D(HLTCP) tcp connection will be used
"RTN","HLMA1",44,0)
 I $D(HLTCP) D GENACK^HLTP4 G EXIT
"RTN","HLMA1",45,0)
 ;Create message ID and Message Text IEN if Message Text IEN not
"RTN","HLMA1",46,0)
 ;previously created ('$G(HLMTIENA))
"RTN","HLMA1",47,0)
 I '$G(HLMTIENA) D CREATE^HLTF(.HLMIDA,.HLMTIENA,.HLDTA,.HLDT1A)
"RTN","HLMA1",48,0)
 ;Get message ID if Message Text IEN not already created
"RTN","HLMA1",49,0)
 I '$G(HLMIDA) D
"RTN","HLMA1",50,0)
 .S HLDTA=$G(^HL(772,HLMTIENA,0))
"RTN","HLMA1",51,0)
 .S HLDT1A=$$HLDATE^HLFNC(+HLDTA),HLMIDA=$P(HLDTA,"^",6),HLDTA=+HLDTA
"RTN","HLMA1",52,0)
 S HLRESLTA=HLMIDA,HLP("DTM")=HLDT1A,HLP("DT")=HLDTA,HLP("MTIENS")=HLMTIENS,HLP("EID")=HLEID
"RTN","HLMA1",53,0)
 ;Execute entry action for subscriber protocol
"RTN","HLMA1",54,0)
 I HLENROU]"" X HLENROU
"RTN","HLMA1",55,0)
 ;Invoke transaction processor to generate acknowledgement
"RTN","HLMA1",56,0)
 K HLDTA,HLDT1A,HLEID,HLENROU,HLMTIENS
"RTN","HLMA1",57,0)
 S HLRESLT=""
"RTN","HLMA1",58,0)
 D GENACK^HLTP1(HLMIDA,HLMTIENA,HLEIDS,HLARYTYP,HLFORMAT,.HLRESLT,.HLP)
"RTN","HLMA1",59,0)
 ;HLMIDAR is array of message IDs, only set for broadcast messages
"RTN","HLMA1",60,0)
 I HLMIDAR K HLMIDAR("N") M HLRESLTA=HLMIDAR
"RTN","HLMA1",61,0)
 S HLRESLTA=HLRESLTA_"^"_HLRESLT
"RTN","HLMA1",62,0)
 ;Update status to Awaiting Acknowledgement or Error in Transmission
"RTN","HLMA1",63,0)
 D STATUS^HLTF0(HLMTIENA,$S($P(HLRESLTA,"^",2):4,1:3),$S($P(HLRESLTA,"^",2):$P(HLRESLTA,"^",2),1:""),$S($P(HLRESLTA,"^",2):$P(HLRESLTA,"^",3),1:""))
"RTN","HLMA1",64,0)
 ;Execute exit action for subscriber protocol
"RTN","HLMA1",65,0)
 X:HLEXROU]"" HLEXROU
"RTN","HLMA1",66,0)
EXIT K HLDTA,HLDT1A,HLMIDA,HLENROU,HLEXROU,HLRESLT
"RTN","HLMA1",67,0)
 Q
"RTN","HLMA2")
0^78^B37613049
"RTN","HLMA2",1,0)
HLMA2 ;AISC/SAW-Message Administration Module ;10/24/2003  16:57
"RTN","HLMA2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,58,64,65,76,82,91,94,109**;Oct 13, 1995
"RTN","HLMA2",3,0)
 ; References to ^ORD(101) supported by IA# 1373.
"RTN","HLMA2",4,0)
 ;
"RTN","HLMA2",5,0)
SEND(EIDS,MTIEN,CLIENT,PRIORITY,MTIENS,LOGLINK) ;
"RTN","HLMA2",6,0)
 ;Entry point to create
"RTN","HLMA2",7,0)
 ;an entry in the Message Administrator and Message Text
"RTN","HLMA2",8,0)
 ;files for a message that is about to be sent to a recipient
"RTN","HLMA2",9,0)
 ;
"RTN","HLMA2",10,0)
 ;This is a subroutine call with parameter passing.  It returns a value
"RTN","HLMA2",11,0)
 ;in the variable MTIENS with 1 to 3 pieces separated by uparrows
"RTN","HLMA2",12,0)
 ;as follows:  MTIENS^error code^error description
"RTN","HLMA2",13,0)
 ;If no error occurs, only the first piece is returned equal to the IEN
"RTN","HLMA2",14,0)
 ;the entry created in the Message Text or Administration file.
"RTN","HLMA2",15,0)
 ;Otherwise, three pieces are returned with the first piece equal to 0
"RTN","HLMA2",16,0)
 ;
"RTN","HLMA2",17,0)
 ;All the following input parameters are required
"RTN","HLMA2",18,0)
 ;    EIDS = The IEN from the Protocol file of the subscriber event
"RTN","HLMA2",19,0)
 ;   MTIEN = The IEN from the Message Text file created when the
"RTN","HLMA2",20,0)
 ;           GENERATE^HLMA or GENACK^HLMA1 entry points were invoked
"RTN","HLMA2",21,0)
 ;  CLIENT = The IEN of the client (subscriber) application from
"RTN","HLMA2",22,0)
 ;             the Application Parameter file
"RTN","HLMA2",23,0)
 ;PRIORITY = I for immediate or D for deferred
"RTN","HLMA2",24,0)
 ;  MTIENS = The variable that will be returned to the calling
"RTN","HLMA2",25,0)
 ;             application as described above
"RTN","HLMA2",26,0)
 ;Optional parameter
"RTN","HLMA2",27,0)
 ; LOGLINK = The IEN of the logical link from the Logical Link file
"RTN","HLMA2",28,0)
 ;
"RTN","HLMA2",29,0)
 ;     ACK = 1 or 0 to indicate if original message or response-passed
"RTN","HLMA2",30,0)
 ;             by ^HLCS
"RTN","HLMA2",31,0)
 ;
"RTN","HLMA2",32,0)
 ; Save passed parameters for restore... HL*1.6*94
"RTN","HLMA2",33,0)
 N HL94P
"RTN","HLMA2",34,0)
 F HL94P="CONTPTR","NAMESPACE","SECURITY","SUBSCRIBER" D
"RTN","HLMA2",35,0)
 .  QUIT:'$D(HLP(HL94P))  ;->
"RTN","HLMA2",36,0)
 .  MERGE HL94P(HL94P)=HLP(HL94P)
"RTN","HLMA2",37,0)
 ;
"RTN","HLMA2",38,0)
 ;Check for required parameters
"RTN","HLMA2",39,0)
 S MTIENS=""
"RTN","HLMA2",40,0)
 I '$G(EIDS)!('$G(MTIEN))!('$G(CLIENT))!("ID"'[$E($G(PRIORITY))) S MTIENS="0^7^"_$G(^HL(771.7,7,0))_" at SEND^HLMA entry point" G EXIT
"RTN","HLMA2",41,0)
 ;Get message ID and Message Text IEN
"RTN","HLMA2",42,0)
 N HLJ,HLHDRBLD,HLMIDS,HLDTS,HLDT1S,HLP,REPLYTO,SERVER,X
"RTN","HLMA2",43,0)
 ;
"RTN","HLMA2",44,0)
 ; Restore parameters if needed... HL*1.6*94
"RTN","HLMA2",45,0)
 S HL94P=""
"RTN","HLMA2",46,0)
 F  S HL94P=$O(HL94P(HL94P)) Q:HL94P']""  D
"RTN","HLMA2",47,0)
 .  MERGE HLP(HL94P)=HL94P(HL94P)
"RTN","HLMA2",48,0)
 ;
"RTN","HLMA2",49,0)
 ;check if LL is TCP
"RTN","HLMA2",50,0)
 I $G(LOGLINK) D  Q:MTIENS!($G(HLERROR)]"")
"RTN","HLMA2",51,0)
 . ;quit if it is not TCP
"RTN","HLMA2",52,0)
 . Q:$P(^HLCS(870,LOGLINK,0),U,3)'=4
"RTN","HLMA2",53,0)
 . ;create client in 773, MTIENS=ien in 773
"RTN","HLMA2",54,0)
 . S (MTIENS,HLTCP)=$$MA^HLTF(MTIEN,.HLMIDS)
"RTN","HLMA2",55,0)
 .;
"RTN","HLMA2",56,0)
 .;**109
"RTN","HLMA2",57,0)
 .; F  L +^HLMA(MTIENS):1 Q:$T  H 1
"RTN","HLMA2",58,0)
 .;
"RTN","HLMA2",59,0)
 . D MIDAR(HLMIDS)
"RTN","HLMA2",60,0)
 . ;get info from parent (772)
"RTN","HLMA2",61,0)
 . S X=^HL(772,MTIEN,0),HLTYPE=$P(X,U,14),SERVER=$P(X,U,2),REPLYTO=$P(X,U,7)
"RTN","HLMA2",62,0)
 . ;get ack timeout override
"RTN","HLMA2",63,0)
 . S:$P($G(^HL(772,MTIEN,"P")),U,7) HLP("ACKTIME")=+$P(^("P"),U,7)
"RTN","HLMA2",64,0)
 . ;get message type and event type from protocol
"RTN","HLMA2",65,0)
 . S X=$G(^ORD(101,EIDS,770)),HLP("MTYPE")=$P(X,U,11),HLP("EVENT")=$P(X,U,4),HLP("HLTCPI")=MTIENS
"RTN","HLMA2",66,0)
 . S:$P(X,U,5) HLP("MTYPE_EVENT")=$P(X,U,5)
"RTN","HLMA2",67,0)
 . ;update date in client (773)
"RTN","HLMA2",68,0)
 . D UPDATE^HLTF0(MTIENS,"","O",EIDS,CLIENT,SERVER,"D",REPLYTO,"",.HLP)
"RTN","HLMA2",69,0)
 . ;create header for message in 773
"RTN","HLMA2",70,0)
 . I (HLTYPE="M") D HEADER^HLCSHDR1(MTIENS,CLIENT,.HLERROR)
"RTN","HLMA2",71,0)
 . I (HLTYPE'="M") D BHSHDR^HLCSHDR1(MTIENS,CLIENT,.HLERROR)
"RTN","HLMA2",72,0)
 . ;if error set status to ERROR DURING TRANSMISSION
"RTN","HLMA2",73,0)
 . I ($G(HLERROR)'="") D  Q
"RTN","HLMA2",74,0)
 ..;**109**
"RTN","HLMA2",75,0)
 ..; D STATUS^HLTF0(MTIENS,4,12,HLERROR) L -^HLMA(MTIENS)
"RTN","HLMA2",76,0)
 .. D STATUS^HLTF0(MTIENS,4,12,HLERROR)
"RTN","HLMA2",77,0)
 ..;
"RTN","HLMA2",78,0)
 .. S MTIENS="0^12^"_$G(^HL(771.7,12,0))_" in HLCSHDR1"
"RTN","HLMA2",79,0)
 .. Q
"RTN","HLMA2",80,0)
 . ;do we still need MTIEN=ien of file 772
"RTN","HLMA2",81,0)
 . S MTIEN=""
"RTN","HLMA2",82,0)
 . ;update status of 773 to PENDING TRANSMISSION
"RTN","HLMA2",83,0)
 . D STATUS^HLTF0(MTIENS,1)
"RTN","HLMA2",84,0)
 . ;set header, HLHDR and Logical Link in 773
"RTN","HLMA2",85,0)
 . K HLJ
"RTN","HLMA2",86,0)
 . S X=MTIENS_",",HLJ(773,X,7)=LOGLINK,HLJ(773,X,200)="HLHDR"
"RTN","HLMA2",87,0)
 . D FILE^HLDIE("","HLJ","","SEND","HLMA2") ;HL*1.6*109
"RTN","HLMA2",88,0)
 .D ENQUE^HLCSREP(LOGLINK,"O",MTIENS)
"RTN","HLMA2",89,0)
 .;
"RTN","HLMA2",90,0)
 .;**109
"RTN","HLMA2",91,0)
 .; L -^HLMA(MTIENS)
"RTN","HLMA2",92,0)
 ;
"RTN","HLMA2",93,0)
 ;if not TCP get msg. ID
"RTN","HLMA2",94,0)
 S HLMIDS=$P($G(^HL(772,MTIEN,0)),"^",6)
"RTN","HLMA2",95,0)
 ;create child message
"RTN","HLMA2",96,0)
 D CREATE^HLTF(.HLMIDS,.MTIENS,.HLDTS,.HLDT1S),MIDAR(HLMIDS)
"RTN","HLMA2",97,0)
 ;Link new Message Text file entry to MTIENG entry and update fields
"RTN","HLMA2",98,0)
 ;on zero node
"RTN","HLMA2",99,0)
 D UPDATE^HLTF0(MTIENS,MTIEN,"O",EIDS,CLIENT,"",PRIORITY,"",$S($G(LOGLINK):LOGLINK,1:""))
"RTN","HLMA2",100,0)
EXIT Q
"RTN","HLMA2",101,0)
 ;
"RTN","HLMA2",102,0)
MIDAR(X) ;update HLMIDAR array with X=message id
"RTN","HLMA2",103,0)
 Q:$G(X)=""
"RTN","HLMA2",104,0)
 I 'HLMIDAR S HLMIDAR("N")=1,HLMIDAR=X Q
"RTN","HLMA2",105,0)
 S HLMIDAR(HLMIDAR("N"))=X,HLMIDAR("N")=HLMIDAR("N")+1
"RTN","HLMA2",106,0)
 Q
"RTN","HLMA2",107,0)
 ;
"RTN","HLMA2",108,0)
DC ;direct connect
"RTN","HLMA2",109,0)
 N CLIENT,EIDS,HLMIDS,LOGLINK,MTIEN,MTIENS,POP,HLHDR,HLHDRO,HLMSA,REPLYTO,SERVER,X,HLTCPI
"RTN","HLMA2",110,0)
 N HLCSOUT,HLDBACK,HLDBSIZE,HLDP,HLDREAD,HLDRETR,HLDWAIT,HLMSG,HLOS,HLPORT,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPO,HLTCPORT,HLRESP,HLTYPE,HLRETRA,HLRETRY,HLTCPRET
"RTN","HLMA2",111,0)
 S (EIDS,LOGLINK)="",MTIEN=HLMTIEN
"RTN","HLMA2",112,0)
 I $D(HLL("LINKS")) D
"RTN","HLMA2",113,0)
 . S EIDS=$P(HLL("LINKS",1),U),LOGLINK=$P(HLL("LINKS",1),U,2)
"RTN","HLMA2",114,0)
 . K HLL("LINKS")
"RTN","HLMA2",115,0)
 . Q:EIDS=""  I EIDS<1 S EIDS=$O(^ORD(101,"B",EIDS,0))
"RTN","HLMA2",116,0)
 . Q:LOGLINK=""  I LOGLINK<1 S LOGLINK=$O(^HLCS(870,"B",LOGLINK,0))
"RTN","HLMA2",117,0)
 . S CLIENT=+$$PTR^HLUTIL2(EIDS)
"RTN","HLMA2",118,0)
 I 'LOGLINK!'EIDS D
"RTN","HLMA2",119,0)
 . S EIDS=+$O(^ORD(101,HLEID,775,0)) Q:'EIDS  S EIDS=$P($G(^(EIDS,0)),U)
"RTN","HLMA2",120,0)
 . S X=$$PTR^HLUTIL2(EIDS),CLIENT=$P(X,U),LOGLINK=$P(X,U,2)
"RTN","HLMA2",121,0)
 I 'EIDS S HLERROR="15^Invalid Subscriber for Immediate connection" Q
"RTN","HLMA2",122,0)
 I 'LOGLINK S HLERROR="15^Invalid Logical Link for Immediate connection" Q
"RTN","HLMA2",123,0)
 I CLIENT<0 S HLERROR="15^Invalid Subscriber Protocol for Immediate connection" Q
"RTN","HLMA2",124,0)
 ;open connection
"RTN","HLMA2",125,0)
 I '$$DCOPEN^HLCSTCP(LOGLINK) S HLERROR="15^Connection Failed" Q
"RTN","HLMA2",126,0)
 ;create client in 773
"RTN","HLMA2",127,0)
 S HLDP=LOGLINK,(MTIENS,HLTCP,HLTCPI,HLMSG)=$$MA^HLTF(MTIEN,.HLMIDS)
"RTN","HLMA2",128,0)
 ;
"RTN","HLMA2",129,0)
 ;**109**
"RTN","HLMA2",130,0)
 ;F  L +^HLMA(MTIENS):1 Q:$T  H 1
"RTN","HLMA2",131,0)
 ;
"RTN","HLMA2",132,0)
 ;get info from parent (772)
"RTN","HLMA2",133,0)
 S X=^HL(772,MTIEN,0),HLTYPE=$P(X,U,14),SERVER=$P(X,U,2),REPLYTO=$P(X,U,7)
"RTN","HLMA2",134,0)
 ;get ack timeout override
"RTN","HLMA2",135,0)
 S:$P($G(^HL(772,MTIEN,"P")),U,7) HLP("ACKTIME")=+$P(^("P"),U,7)
"RTN","HLMA2",136,0)
 ;get message type and event type from protocol
"RTN","HLMA2",137,0)
 S X=$G(^ORD(101,EIDS,770)),HLP("MTYPE")=$P(X,U,11),HLP("EVENT")=$P(X,U,4),HLP("HLTCPI")=MTIENS
"RTN","HLMA2",138,0)
 S:$P(X,U,5) HLP("MTYPE_EVENT")=$P(X,U,5)
"RTN","HLMA2",139,0)
 ;update date in client (773)
"RTN","HLMA2",140,0)
 D UPDATE^HLTF0(MTIENS,"","O",EIDS,CLIENT,SERVER,"I",REPLYTO,"",.HLP)
"RTN","HLMA2",141,0)
 ;create header for message in 773
"RTN","HLMA2",142,0)
 I (HLTYPE="M") D HEADER^HLCSHDR1(MTIENS,CLIENT,.HLERROR)
"RTN","HLMA2",143,0)
 I (HLTYPE'="M") D BHSHDR^HLCSHDR1(MTIENS,CLIENT,.HLERROR)
"RTN","HLMA2",144,0)
 ;if error set status to ERROR DURING TRANSMISSION
"RTN","HLMA2",145,0)
 I ($G(HLERROR)'="") D  Q
"RTN","HLMA2",146,0)
 .;
"RTN","HLMA2",147,0)
 .;**109**
"RTN","HLMA2",148,0)
 .; D STATUS^HLTF0(MTIENS,4,12,HLERROR) L -^HLMA(MTIENS)
"RTN","HLMA2",149,0)
 . D STATUS^HLTF0(MTIENS,4,12,HLERROR)
"RTN","HLMA2",150,0)
 .;
"RTN","HLMA2",151,0)
 . S MTIENS="0^12^"_$G(^HL(771.7,12,0))_" in HLCSHDR1"
"RTN","HLMA2",152,0)
 .;
"RTN","HLMA2",153,0)
 .;**109**
"RTN","HLMA2",154,0)
 .; L -^HLMA(HLMSG) D MON^HLCSTCP("Idle")
"RTN","HLMA2",155,0)
 . D MON^HLCSTCP("Idle")
"RTN","HLMA2",156,0)
 .;
"RTN","HLMA2",157,0)
 . Q
"RTN","HLMA2",158,0)
 ;set header, HLHDR and Logical Link in 773
"RTN","HLMA2",159,0)
 K HLJ S X=MTIENS_",",HLJ(773,X,7)=LOGLINK,HLJ(773,X,200)="HLHDR"
"RTN","HLMA2",160,0)
 ;
"RTN","HLMA2",161,0)
 D FILE^HLDIE("","HLJ","","DC","HLMA2") ; HL*1.6*109
"RTN","HLMA2",162,0)
 ;
"RTN","HLMA2",163,0)
 ;**109**
"RTN","HLMA2",164,0)
 D LLCNT^HLCSTCP(LOGLINK,3)
"RTN","HLMA2",165,0)
 ;
"RTN","HLMA2",166,0)
 D DCSEND^HLCSTCP2
"RTN","HLMA2",167,0)
 G EXIT2:'$G(HLRESP)
"RTN","HLMA2",168,0)
 ;X=ien in 773^ien in 772 for response
"RTN","HLMA2",169,0)
 S X=HLRESP D INIT^HLTP3A  ;patch HL*1.6*109 - hltp3 routine split
"RTN","HLMA2",170,0)
 D:'$G(HL) STATUS^HLTF0(HLMTIENS,3,,,1)
"RTN","HLMA2",171,0)
 S HLMTIENR=HLMTIEN
"RTN","HLMA2",172,0)
 D EXIT^HLTP3
"RTN","HLMA2",173,0)
EXIT2 ;
"RTN","HLMA2",174,0)
 ;**109**
"RTN","HLMA2",175,0)
 ;L -^HLMA(HLMSG)
"RTN","HLMA2",176,0)
 Q
"RTN","HLP109")
0^79^B33762179
"RTN","HLP109",1,0)
HLP109 ;ALB/CJM - Post-Install for patch 109 ;06/03/99
"RTN","HLP109",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLP109",3,0)
 ;
"RTN","HLP109",4,0)
SETAC ;Used to undo the changes to the "AC" xref, used only if the patch
"RTN","HLP109",5,0)
 ;HL*1.6*109 needs to be backed out.
"RTN","HLP109",6,0)
 S ^DD(773,7,1,1,1)="S %=$P(^HLMA(DA,0),U,3) S:%]"""" ^HLMA(""AC"",%,X,DA)="""" I %=""O"",'$D(HLTCPO) D LLCNT^HLCSTCP(X,3)"
"RTN","HLP109",7,0)
 S ^DD(773,7,1,1,2)="S %=$P(^HLMA(DA,0),U,3) K:%]"""" ^HLMA(""AC"",%,X,DA)"
"RTN","HLP109",8,0)
 ;S ^DD(773,100,1,1,1)="S ^HLMA(""AD"",X,DA)="""" N %,%1 S %=$G(^HLMA(DA,0)),%1=$P(%,U,3),%=$P(%,U,7) K:%1]""""&% ^HLMA(""AC"",%1,%,DA)"
"RTN","HLP109",9,0)
 Q
"RTN","HLP109",10,0)
 ;
"RTN","HLP109",11,0)
PRE ; Called by KIDS pre-init...
"RTN","HLP109",12,0)
 S ^HLCS(869.3,1,772)=($O(^HL(772,":"),-1)\1)
"RTN","HLP109",13,0)
 S ^HLCS(869.3,1,773)=($O(^HLMA(":"),-1)\1)
"RTN","HLP109",14,0)
 D UNQUEUE^HLEVUTIL
"RTN","HLP109",15,0)
 D LOADMON
"RTN","HLP109",16,0)
 D ETHL7 ; Make sure every official HL7 entry has PACKAGE NAME...
"RTN","HLP109",17,0)
 Q
"RTN","HLP109",18,0)
 ;
"RTN","HLP109",19,0)
LOADMON ; Create a list of monitors in ^XTMP(XTMP,"O")...
"RTN","HLP109",20,0)
 N NOW,XTMP
"RTN","HLP109",21,0)
 S NOW=$$NOW^XLFDT
"RTN","HLP109",22,0)
 S XTMP="HLEV INSTALL "_NOW
"RTN","HLP109",23,0)
 S ^XTMP(XTMP,0)=$$FMADD^XLFDT(NOW,2)_U_NOW_U_"HLEV INSTALLATION MONITOR LIST"
"RTN","HLP109",24,0)
 S IEN=0
"RTN","HLP109",25,0)
 F  S IEN=$O(^HLEV(776.1,IEN)) Q:'IEN  D
"RTN","HLP109",26,0)
 .  S ^XTMP(XTMP,"O",IEN)=$P($G(^HLEV(776.1,IEN,0)),U)_U_$$IENSUM(IEN)
"RTN","HLP109",27,0)
 Q
"RTN","HLP109",28,0)
 ;
"RTN","HLP109",29,0)
 ;
"RTN","HLP109",30,0)
 ;
"RTN","HLP109",31,0)
 ;
"RTN","HLP109",32,0)
POST ; Called by KIDS post-init...
"RTN","HLP109",33,0)
 N NO,TEXT,XMDUZ,XMSUB,XMTEXT,XMZ
"RTN","HLP109",34,0)
 N %KMPRJT,%XX,%ZH0,%ZHFN,C,D0,DA,DG,DICR,DIFRFRV1,DIFROM,DIU,I,IEN
"RTN","HLP109",35,0)
 N J,X,XG255,XGATRSET,XGCURATR,XGEMPATR,XGPAD,XGRT,XGSCRN
"RTN","HLP109",36,0)
 N XQCH,ZQJMP,XQSV,XWT,XQUSER,XQZ,Y
"RTN","HLP109",37,0)
 N XPD,XPD0,XPDA,XPDBLD,XPDCHECK,XPDCP,XPDD,XPDGREF,XPDIDCNT
"RTN","HLP109",38,0)
 N XPDIDMOD,XPDIDTOT,XPDIDVT,XPDIT,XPDNM,XPDPKG,XPDRTN,XPDSET
"RTN","HLP109",39,0)
 N XPDSET1,XPDST,XPDT
"RTN","HLP109",40,0)
 ;
"RTN","HLP109",41,0)
 ; Load 776.999 file entry if needed...
"RTN","HLP109",42,0)
 D LOADPAR
"RTN","HLP109",43,0)
 ;
"RTN","HLP109",44,0)
 ; Update list of monitors...
"RTN","HLP109",45,0)
 D COMPMON
"RTN","HLP109",46,0)
 ;
"RTN","HLP109",47,0)
 ; Send email message to DUZ...
"RTN","HLP109",48,0)
 KILL ^TMP($J,"HLMAIL")
"RTN","HLP109",49,0)
 D ADD("The installation of the Event Monitoring software held in patch")
"RTN","HLP109",50,0)
 D ADD("HL*1.6*109 is complete. ")
"RTN","HLP109",51,0)
 S XTMP=$O(^XTMP("HLEV INSTALL 9999999.99999"),-1)
"RTN","HLP109",52,0)
 I XTMP]"",$D(^XTMP(XTMP)) D MAILMON
"RTN","HLP109",53,0)
 ;
"RTN","HLP109",54,0)
 ; Send Mailman message.
"RTN","HLP109",55,0)
 S XMDUZ=.5,XMSUB="HL*1.6*109 Installation - Site# "_$P($$SITE^VASITE,U,3)
"RTN","HLP109",56,0)
 S XMTEXT="^TMP("_$J_",""HLMAIL"","
"RTN","HLP109",57,0)
 S XMY("HL7SystemMonitoring@med.va.gov")=""
"RTN","HLP109",58,0)
 ;
"RTN","HLP109",59,0)
 D ^XMD
"RTN","HLP109",60,0)
 ;
"RTN","HLP109",61,0)
 I '$D(ZTQUEUED) W !!,"Setup instructions message #",$G(XMZ)," sent..."
"RTN","HLP109",62,0)
 KILL ^TMP($J,"HLMAIL")
"RTN","HLP109",63,0)
 ;
"RTN","HLP109",64,0)
 D DELMON ; Delete monitor(2)...
"RTN","HLP109",65,0)
 D DELMGRP ; Delete mail group(s) from monitor(s)...
"RTN","HLP109",66,0)
 ;
"RTN","HLP109",67,0)
 ; Start a new master job...
"RTN","HLP109",68,0)
 D STARTJOB^HLEVMST
"RTN","HLP109",69,0)
 ;
"RTN","HLP109",70,0)
 Q
"RTN","HLP109",71,0)
 ;
"RTN","HLP109",72,0)
DELMON ; Delete renamed, or now unwanted official monitors...
"RTN","HLP109",73,0)
 N DA,DIE,DR
"RTN","HLP109",74,0)
 D DELONE("STUB 870 SEARCH")
"RTN","HLP109",75,0)
 D DELONE("XREF CHECK - FILE 772 & 773")
"RTN","HLP109",76,0)
 Q
"RTN","HLP109",77,0)
 ;
"RTN","HLP109",78,0)
DELONE(NAME) ; Delete a monitor...
"RTN","HLP109",79,0)
 N DA
"RTN","HLP109",80,0)
 QUIT:$G(NAME)']""  ;->
"RTN","HLP109",81,0)
 F  S DA=+$O(^HLEV(776.1,"B",NAME,0)) Q:'DA  D
"RTN","HLP109",82,0)
 .  N DIK,DR
"RTN","HLP109",83,0)
 .  S DIK="^HLEV(776.1,"
"RTN","HLP109",84,0)
 .  D ^DIK
"RTN","HLP109",85,0)
 Q
"RTN","HLP109",86,0)
 ;
"RTN","HLP109",87,0)
LOADPAR ; Load 776.999 file...
"RTN","HLP109",88,0)
 QUIT:$G(^HLEV(776.999,1,0))]""  ;->
"RTN","HLP109",89,0)
 S $P(^HLEV(776.999,0),U,3)=1,$P(^HLEV(776.999,0),U,4)=1
"RTN","HLP109",90,0)
 S ^HLEV(776.999,1,0)="SYSTEM^A^120^96^^A"
"RTN","HLP109",91,0)
 S ^HLEV(776.999,"B","SYSTEM",1)=""
"RTN","HLP109",92,0)
 Q
"RTN","HLP109",93,0)
 ;
"RTN","HLP109",94,0)
COMPMON ; Create list of monitors that have been changed...
"RTN","HLP109",95,0)
 N DATA,IEN,NM,XTMP
"RTN","HLP109",96,0)
 ;
"RTN","HLP109",97,0)
 S XTMP=$O(^XTMP("HLEV INSTALL 9999999.999999999"),-1)
"RTN","HLP109",98,0)
 QUIT:XTMP'["HLEV INSTALL"  ;->
"RTN","HLP109",99,0)
 ;
"RTN","HLP109",100,0)
 S IEN=0
"RTN","HLP109",101,0)
 F  S IEN=$O(^HLEV(776.1,IEN)) Q:IEN'>0  D
"RTN","HLP109",102,0)
 .  S $P(^XTMP(XTMP,"O",IEN),U,3)=$P($G(^HLEV(776.1,+IEN,0)),U)
"RTN","HLP109",103,0)
 .  S $P(^XTMP(XTMP,"O",IEN),U,4)=$$IENSUM(IEN)
"RTN","HLP109",104,0)
 .  S DATA=^XTMP(XTMP,"O",IEN)
"RTN","HLP109",105,0)
 .  QUIT:$P(DATA,U)'=$P(DATA,U,3)  ;-> Names don't match
"RTN","HLP109",106,0)
 .  QUIT:$P(DATA,U,2)'=$P(DATA,U,4)  ;-> Checksums don't match
"RTN","HLP109",107,0)
 .  KILL ^XTMP(XTMP,"O",IEN)
"RTN","HLP109",108,0)
 ;
"RTN","HLP109",109,0)
 ; Rearrange into new and "used" (pre-existing) monitors...
"RTN","HLP109",110,0)
 KILL ^XTMP(XTMP,"NEW"),^XTMP(XTMP,"OLD")
"RTN","HLP109",111,0)
 S IEN=0
"RTN","HLP109",112,0)
 F  S IEN=$O(^XTMP(XTMP,"O",IEN)) Q:'IEN  D
"RTN","HLP109",113,0)
 .  S DATA=^XTMP(XTMP,"O",IEN) QUIT:DATA']""  ;->
"RTN","HLP109",114,0)
 .  S NM=$P(DATA,U,3)
"RTN","HLP109",115,0)
 .  S:$P(DATA,U)']"" ^XTMP(XTMP,"NEW",NM,IEN)=DATA
"RTN","HLP109",116,0)
 .  S:$P(DATA,U)]"" ^XTMP(XTMP,"OLD",NM,IEN)=DATA
"RTN","HLP109",117,0)
 ;
"RTN","HLP109",118,0)
 KILL ^XTMP(XTMP,"O")
"RTN","HLP109",119,0)
 ;
"RTN","HLP109",120,0)
 Q
"RTN","HLP109",121,0)
 ;
"RTN","HLP109",122,0)
ETHL7 ; Check/reset PACKAGE NAME in HL7 Monitor Event Type file (#776.3)...
"RTN","HLP109",123,0)
 N DA,DIE,DR,IEN,IENS,PCE
"RTN","HLP109",124,0)
 ;
"RTN","HLP109",125,0)
 S IENS="1^2^3^4^5^6^7^8^9^10^11^12^13^14^15^16^17^18^100^101^102^103^104^105^106^107^108^109^200^201^202^203^204^205^206^207^208^209^210^211^213^214^215^216"
"RTN","HLP109",126,0)
 ;
"RTN","HLP109",127,0)
 F PCE=1:1:$L(IENS,U) D
"RTN","HLP109",128,0)
 .  S IEN=$P(IENS,U,+PCE) QUIT:$G(^HLEV(776.3,IEN,0))']""  ;->
"RTN","HLP109",129,0)
 .  S DA=IEN,DIE=776.3,DR=".08///HEALTH LEVEL SEVEN"
"RTN","HLP109",130,0)
 .  D ^DIE
"RTN","HLP109",131,0)
 ;
"RTN","HLP109",132,0)
 Q
"RTN","HLP109",133,0)
 ;
"RTN","HLP109",134,0)
MAILMON ; Add to new or changed monitors to mail text...
"RTN","HLP109",135,0)
 N HDR,NM,TXT,TYP
"RTN","HLP109",136,0)
 ;
"RTN","HLP109",137,0)
 D ADD(" - New and changed monitors.")
"RTN","HLP109",138,0)
 ;
"RTN","HLP109",139,0)
 S TYPE=""
"RTN","HLP109",140,0)
 F  S TYPE=$O(^XTMP(XTMP,TYPE)) Q:TYPE']""  D
"RTN","HLP109",141,0)
 .  D ADD("")
"RTN","HLP109",142,0)
 .  S HDR=$S(TYPE="OLD":"Monitors changed during installation",TYPE="NEW":"New monitors",1:"") QUIT:HDR']""  ;->
"RTN","HLP109",143,0)
 .  D ADD(HDR),ADD($$REPEAT^XLFSTR("-",$L(HDR)))
"RTN","HLP109",144,0)
 .  S NM="",TXT=""
"RTN","HLP109",145,0)
 .  F  S NM=$O(^XTMP(XTMP,TYPE,NM)) Q:NM']""  D
"RTN","HLP109",146,0)
 .  .  S TXT(1)=$E(NM_$$REPEAT^XLFSTR(" ",40),1,35)
"RTN","HLP109",147,0)
 .  .  S TXT=TXT_TXT(1)
"RTN","HLP109",148,0)
 .  .  I $L(TXT)>35 D ADD(TXT) S TXT=""
"RTN","HLP109",149,0)
 .  I $L(TXT)>0 D ADD(TXT)
"RTN","HLP109",150,0)
 ;
"RTN","HLP109",151,0)
 Q
"RTN","HLP109",152,0)
 ;
"RTN","HLP109",153,0)
ADD(TXT) ; Add text to ^TMP($J,"HLMAIL")
"RTN","HLP109",154,0)
 N NO
"RTN","HLP109",155,0)
 S NO=$O(^TMP($J,"HLMAIL",":"),-1)+1
"RTN","HLP109",156,0)
 S ^TMP($J,"HLMAIL",+NO)=TXT
"RTN","HLP109",157,0)
 Q
"RTN","HLP109",158,0)
 ;
"RTN","HLP109",159,0)
IENSUM(IEN) ; Checksum of entry...
"RTN","HLP109",160,0)
 N ASC,CHAR,LP,POS,ST,SUM,TXT,VAL
"RTN","HLP109",161,0)
 S SUM=0
"RTN","HLP109",162,0)
 S LP="^HLEV(776.1,"_IEN,ST=LP_",",LP=LP_")"
"RTN","HLP109",163,0)
 F  S LP=$Q(@LP) Q:LP'[ST  D
"RTN","HLP109",164,0)
 .  S TXT=LP_"="_@LP
"RTN","HLP109",165,0)
 .  F POS=1:1:$L(TXT) D
"RTN","HLP109",166,0)
 .  .  S CHAR=$E(TXT,POS),ASC=$A(CHAR)
"RTN","HLP109",167,0)
 .  .  S SUM=SUM+(ASC*POS)
"RTN","HLP109",168,0)
 Q SUM
"RTN","HLP109",169,0)
 ;
"RTN","HLP109",170,0)
DELMGRP ; Delete mailgroup in monitor...
"RTN","HLP109",171,0)
 N IEN,MIEN
"RTN","HLP109",172,0)
 ;
"RTN","HLP109",173,0)
 ; CHECK 773 AC XREF --- @ --- HL7DevelopmentTeam@med.va.gov
"RTN","HLP109",174,0)
 S IEN=$O(^HLEV(776.1,"B","CHECK 773 AC XREF",0))
"RTN","HLP109",175,0)
 S MIEN=$O(^HLEV(776.1,+IEN,62,"B","HL7DevelopmentTeam@med.va.gov",0))
"RTN","HLP109",176,0)
 D DELGRP1(IEN,MIEN)
"RTN","HLP109",177,0)
 ;
"RTN","HLP109",178,0)
 ; LINK (870) CHECKS
"RTN","HLP109",179,0)
 S IEN=$O(^HLEV(776.1,"B","LINK (870) CHECKS",0))
"RTN","HLP109",180,0)
 S MIEN=$O(^HLEV(776.1,+IEN,62,"B","HL7DevelopmentTeam@med.va.gov",0))
"RTN","HLP109",181,0)
 D DELGRP1(IEN,MIEN)
"RTN","HLP109",182,0)
 ;
"RTN","HLP109",183,0)
 Q
"RTN","HLP109",184,0)
 ;
"RTN","HLP109",185,0)
 ;
"RTN","HLP109",186,0)
DELGRP1(IEN,MIEN) ; Delete one remote mail group...
"RTN","HLP109",187,0)
 N DIE,DIE,DR
"RTN","HLP109",188,0)
 QUIT:'$D(^HLEV(776.1,+IEN,62,+MIEN,0))  ;->
"RTN","HLP109",189,0)
 S DIE="^HLEV(776.1,"_IEN_",62,",DA(1)=IEN,DA=MIEN
"RTN","HLP109",190,0)
 S DR=".01///@"
"RTN","HLP109",191,0)
 D ^DIE
"RTN","HLP109",192,0)
 Q
"RTN","HLP109",193,0)
 ;
"RTN","HLP109",194,0)
EOR ;HLEVINIT - Event Monitor PRE&POST-INITS ;5/16/03 14:42
"RTN","HLP109EN")
0^95^B6215325
"RTN","HLP109EN",1,0)
HLP109EN ;OIFO-O/RJH - HL*1.6*109 ENVIRONMENTT CHECK ROUTINE ;12/11/2003
"RTN","HLP109EN",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;OCT 13, 1995
"RTN","HLP109EN",3,0)
 ;
"RTN","HLP109EN",4,0)
EN ; Check environment...
"RTN","HLP109EN",5,0)
 N ACTION
"RTN","HLP109EN",6,0)
 ;
"RTN","HLP109EN",7,0)
 ; If no AC,I xrefs...
"RTN","HLP109EN",8,0)
 I $O(^HLMA("AC","I",0))'>0 D  QUIT  ;->
"RTN","HLP109EN",9,0)
 .  W !!,"Environment check OK..."
"RTN","HLP109EN",10,0)
 .  W !
"RTN","HLP109EN",11,0)
 ;
"RTN","HLP109EN",12,0)
 ; AC,I xrefs exist.  So, if loading, just warn.  Otherwise, stop!
"RTN","HLP109EN",13,0)
 ;
"RTN","HLP109EN",14,0)
 ; Set ACTION=1 if loading, and ACTION=2 if installing...
"RTN","HLP109EN",15,0)
 S ACTION=$$UP^XLFSTR($G(XQY0)),ACTION=$S(ACTION["LOAD":1,1:2)
"RTN","HLP109EN",16,0)
 ;
"RTN","HLP109EN",17,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLP109EN",18,0)
 S X=$$REPEAT^XLFSTR("=",35) W !!,X," ",IOINHI,"Warning",IOINORM," ",X
"RTN","HLP109EN",19,0)
 D @("INFORM"_ACTION)
"RTN","HLP109EN",20,0)
 ;
"RTN","HLP109EN",21,0)
 I ACTION=2 S XPDABORT=2 ; Stop, but don't unload...
"RTN","HLP109EN",22,0)
 ;
"RTN","HLP109EN",23,0)
 W !
"RTN","HLP109EN",24,0)
 S X=$$BTE("Press RETURN to "_$S(ACTION=1:"continue",1:"exit")_"...")
"RTN","HLP109EN",25,0)
 ;
"RTN","HLP109EN",26,0)
 Q
"RTN","HLP109EN",27,0)
 ;
"RTN","HLP109EN",28,0)
BTE(PMT) ; 
"RTN","HLP109EN",29,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLP109EN",30,0)
 S DIR(0)="EA",DIR("A")=PMT
"RTN","HLP109EN",31,0)
 D ^DIR
"RTN","HLP109EN",32,0)
 Q $S(+Y=1:1,1:"")
"RTN","HLP109EN",33,0)
 ;
"RTN","HLP109EN",34,0)
INFORM1 ; General information when AC,Is exist and LOADing...
"RTN","HLP109EN",35,0)
 W !,"There are inbound queues with un-processed messages.  Before patch HL*1.6*109"
"RTN","HLP109EN",36,0)
 W !,"can be installed, the inbound queues must be empty.  You may continue loading"
"RTN","HLP109EN",37,0)
 W !,"these patches.  But, remember to clear the inbound queues before loading."
"RTN","HLP109EN",38,0)
 W !!,"(To clear the queues, start one or more incoming filer(s) to process the"
"RTN","HLP109EN",39,0)
 W !,"messages until there are no messages in the queue.)"
"RTN","HLP109EN",40,0)
 Q
"RTN","HLP109EN",41,0)
 ;
"RTN","HLP109EN",42,0)
INFORM2 ; General information when AC,Is exist and INSTALLing...
"RTN","HLP109EN",43,0)
 W !,"There are inbound queues with un-processed messages.  Before patch HL*1.6*109"
"RTN","HLP109EN",44,0)
 W !,"can be installed, the inbound queues must be empty.  Start one or more"
"RTN","HLP109EN",45,0)
 W !,"incoming filer(s) to process the messages until there are no messages in the"
"RTN","HLP109EN",46,0)
 W !,"queue.  Then, try to install patch HL*1.6*109 again."
"RTN","HLP109EN",47,0)
 Q
"RTN","HLP109EN",48,0)
 ;
"RTN","HLTF")
0^80^B49383239
"RTN","HLTF",1,0)
HLTF ;AISC/SAW,JRP-Create/Process Message Text File Entries ;06/03/99  10:00
"RTN","HLTF",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**1,19,43,55,109**;Oct 13, 1995
"RTN","HLTF",3,0)
FILE ;Create Entries in files 772 and 773 for Version 1.5 Interface Only
"RTN","HLTF",4,0)
 D CREATE(,.HLDA,.HLDT,.HLDT1)
"RTN","HLTF",5,0)
 Q
"RTN","HLTF",6,0)
CREATE(HLMID,MTIEN,HLDT,HLDT1) ;Create entries in Message Text (#772)
"RTN","HLTF",7,0)
 ;
"RTN","HLTF",8,0)
 ;Input  : HLMID = Variable in which value of message ID will be
"RTN","HLTF",9,0)
 ;                 returned (pass by reference)
"RTN","HLTF",10,0)
 ;         MTIEN = Variable in which IEN of Message Text file entry
"RTN","HLTF",11,0)
 ;                 will be returned (pass by reference)
"RTN","HLTF",12,0)
 ;         HLDT = Variable in which current date/time in FM internal
"RTN","HLTF",13,0)
 ;                format will be returned (pass by reference)
"RTN","HLTF",14,0)
 ;         HLDT1 = Variable in which current date/time in HL7 format
"RTN","HLTF",15,0)
 ;                 will be returned (pass by reference)
"RTN","HLTF",16,0)
 ;
"RTN","HLTF",17,0)
 ;Output : See above
"RTN","HLTF",18,0)
 ;
"RTN","HLTF",19,0)
 ;Notes  : If HLDT has a value [upon entry], the created entries will
"RTN","HLTF",20,0)
 ;         be given that value for their date/time (value of .01)
"RTN","HLTF",21,0)
 ;       : Current date/time used if HLDT is not passed or invalid
"RTN","HLTF",22,0)
 ;
"RTN","HLTF",23,0)
 ;Make entry in Message Administration file
"RTN","HLTF",24,0)
 N Y
"RTN","HLTF",25,0)
 S HLDT=$G(HLDT)
"RTN","HLTF",26,0)
 D MT(.HLDT)
"RTN","HLTF",27,0)
 S Y=$$CHNGMID(MTIEN,.HLMID),HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLTF",28,0)
 Q
"RTN","HLTF",29,0)
TCP(HLMID,MTIEN,HLDT) ;create new message in 772 & 773 entries
"RTN","HLTF",30,0)
 ;used for incoming messages and outgoing responses
"RTN","HLTF",31,0)
 ;Input  : HLMID = Variable in which value of message ID will be
"RTN","HLTF",32,0)
 ;                 returned (pass by reference)
"RTN","HLTF",33,0)
 ;         MTIEN = Variable in which IEN of file 773 entry
"RTN","HLTF",34,0)
 ;                 will be returned (pass by reference)
"RTN","HLTF",35,0)
 ;         HLDT = Variable in which current date/time in FM internal
"RTN","HLTF",36,0)
 ;                format will be returned (pass by reference)
"RTN","HLTF",37,0)
 ;
"RTN","HLTF",38,0)
 S HLDT=$G(HLDT),HLMID=$G(HLMID)
"RTN","HLTF",39,0)
 D MT(.HLDT)
"RTN","HLTF",40,0)
 S MTIEN=$$MA(MTIEN,.HLMID)
"RTN","HLTF",41,0)
 Q
"RTN","HLTF",42,0)
 ;
"RTN","HLTF",43,0)
MT(HLX) ;Create entry in Message Text file (#772)
"RTN","HLTF",44,0)
 ;
"RTN","HLTF",45,0)
 ;Input  : HLX = Date/time entry in file should be given (value of .01)
"RTN","HLTF",46,0)
 ;               Defaults to current date/time
"RTN","HLTF",47,0)
 ;
"RTN","HLTF",48,0)
 ;Output : HLDT = Date/time of created entry (value of .01)
"RTN","HLTF",49,0)
 ;       : HLDT1 = HLDT in HL7 format
"RTN","HLTF",50,0)
 ;
"RTN","HLTF",51,0)
 ;Notes  : HLX must be in FileMan format (default value used if not)
"RTN","HLTF",52,0)
 ;       : HLDT will be in FileMan format
"RTN","HLTF",53,0)
 ;       : MTIEN is ien in file 772
"RTN","HLTF",54,0)
 ;
"RTN","HLTF",55,0)
 ;Check for input
"RTN","HLTF",56,0)
 S HLX=$G(HLX)
"RTN","HLTF",57,0)
 ;Declare variables
"RTN","HLTF",58,0)
 N DIC,DD,DO,HLCNT,HLJ,X,Y
"RTN","HLTF",59,0)
 F HLCNT=0:1 D  Q:Y>0  H HLCNT
"RTN","HLTF",60,0)
 . I (HLX'?7N.1".".6N) S HLX=$$NOW^XLFDT
"RTN","HLTF",61,0)
 . S DIC="^HL(772,",DIC(0)="L",(HLDT,X)=HLX
"RTN","HLTF",62,0)
 . S Y=$$STUB772(X) ; This call substituted for D FILE^DICN by HL*1.6*109
"RTN","HLTF",63,0)
 . ;Entry not created - try again
"RTN","HLTF",64,0)
 . I Y<0 S HLX="" Q
"RTN","HLTF",65,0)
 . S MTIEN=+Y
"RTN","HLTF",66,0)
 ;***If we didn't get a record in 772, need to do something
"RTN","HLTF",67,0)
 I Y<0 Q
"RTN","HLTF",68,0)
 S HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLTF",69,0)
 Q
"RTN","HLTF",70,0)
 ;add to Message Admin file #773
"RTN","HLTF",71,0)
MA(X,HLMID) ;X=ien in file 772, HLMID=msg. id (passed by ref.)
"RTN","HLTF",72,0)
 ;return ien in file 773
"RTN","HLTF",73,0)
 Q:'$G(^HL(772,X,0)) 0
"RTN","HLTF",74,0)
 N DA,DD,DO,DIC,DIE,DR,HLDA,HLCNT,HLJ,Y
"RTN","HLTF",75,0)
 S DIC="^HLMA(",DIC(0)="L"
"RTN","HLTF",76,0)
 F HLCNT=0:1 D  Q:Y>0  H HLCNT
"RTN","HLTF",77,0)
 . S Y=$$STUB773(X) ; This call substituted for D FILE^DICN by HL*1.6*109
"RTN","HLTF",78,0)
 ;***If we didn't get a record in 773, need to do something
"RTN","HLTF",79,0)
 I Y<0 Q 0
"RTN","HLTF",80,0)
 S HLDA=+Y,HLMID=$$MAID(HLDA,$G(HLMID))
"RTN","HLTF",81,0)
 Q HLDA
"RTN","HLTF",82,0)
 ;
"RTN","HLTF",83,0)
MAID(Y,HLMID) ;Determine message ID (if needed) & store message ID
"RTN","HLTF",84,0)
 ;Y=ien in 773, HLMID=id,  Output message id
"RTN","HLTF",85,0)
 N HLJ
"RTN","HLTF",86,0)
 ;need to have id contain institution number to make unique
"RTN","HLTF",87,0)
 S:$G(HLMID)="" HLMID=+$P($$PARAM^HLCS2,U,6)_Y
"RTN","HLTF",88,0)
 S HLJ(773,Y_",",2)=HLMID
"RTN","HLTF",89,0)
 D FILE^HLDIE("","HLJ","","MAID","HLTF") ;HL*1.6*109
"RTN","HLTF",90,0)
 Q HLMID
"RTN","HLTF",91,0)
 ;
"RTN","HLTF",92,0)
CHNGMID(PTRMT,NEWID) ;Change message ID for entry in Message Text file
"RTN","HLTF",93,0)
 ;Input  : PTRMT - Pointer to entry in Message Text file (#772)
"RTN","HLTF",94,0)
 ;         NEWID - New message ID
"RTN","HLTF",95,0)
 ;Output : 0 = Success
"RTN","HLTF",96,0)
 ;         -1^ErrorText = Error/Bad input
"RTN","HLTF",97,0)
 ;
"RTN","HLTF",98,0)
 ;Check input
"RTN","HLTF",99,0)
 S PTRMT=+$G(PTRMT)
"RTN","HLTF",100,0)
 S NEWID=$G(NEWID)
"RTN","HLTF",101,0)
 Q:('$D(^HL(772,PTRMT,0))) "-1^Did not pass valid pointer to Message Text file (#772)"
"RTN","HLTF",102,0)
 N HLJ
"RTN","HLTF",103,0)
 I $G(NEWID)="" S NEWID=+$P($$PARAM^HLCS2,U,6)_PTRMT
"RTN","HLTF",104,0)
 S HLJ(772,PTRMT_",",6)=NEWID
"RTN","HLTF",105,0)
 D FILE^HLDIE("","HLJ","","CHNGMID","HLTF") ; HL*1.6*109
"RTN","HLTF",106,0)
 Q 0
"RTN","HLTF",107,0)
 ;
"RTN","HLTF",108,0)
OUT(HLDA,HLMID,HLMTN) ;File Data in Message Text File for Outgoing Message
"RTN","HLTF",109,0)
 ;Version 1.5 Interface Only
"RTN","HLTF",110,0)
 Q:'$D(HLFS)
"RTN","HLTF",111,0)
 ;
"RTN","HLTF",112,0)
 I HLMTN="ACK"!(HLMTN="MCF")!(HLMTN="ORR") Q:'$D(HLMSA)  D ACK(HLMSA,"I") Q
"RTN","HLTF",113,0)
 ;
"RTN","HLTF",114,0)
 ;-- if message contained MSA find inbound message
"RTN","HLTF",115,0)
 I $D(HLMSA),$D(HLNDAP),$P(HLMSA,HLFS,3)]"" D
"RTN","HLTF",116,0)
 . N HLDAI
"RTN","HLTF",117,0)
 . S HLDAI=0
"RTN","HLTF",118,0)
 . F  S HLDAI=$O(^HL(772,"AH",+$P($G(HLNDAP0),U,12),$P(HLMSA,HLFS,3),HLDAI)) Q:'HLDAI!($P($G(^HL(772,+HLDAI,0)),U,4)="I")
"RTN","HLTF",119,0)
 . I 'HLDAI K HLDAI
"RTN","HLTF",120,0)
 ;
"RTN","HLTF",121,0)
 D STUFF^HLTF0("O")
"RTN","HLTF",122,0)
 ;
"RTN","HLTF",123,0)
 N HLAC S HLAC=$S($D(HLERR):4,'$P(HLNDAP0,"^",10):1,1:2) D STATUS^HLTF0(HLDA,HLAC,$G(HLMSG))
"RTN","HLTF",124,0)
 D:$D(HLCHAR) STATS^HLTF0(HLDA,HLCHAR,$G(HLEVN))
"RTN","HLTF",125,0)
 ;
"RTN","HLTF",126,0)
 ;-- update status if MSA and found inbound message
"RTN","HLTF",127,0)
 I $D(HLMSA),$D(HLDAI) D
"RTN","HLTF",128,0)
 .N HLERR,HLMSG I $P(HLMSA,HLFS,4)]"" S HLERR=$P(HLMSA,HLFS,4)
"RTN","HLTF",129,0)
 .S HLAC=$P(HLMSA,HLFS,2)
"RTN","HLTF",130,0)
 .I HLAC'="AA" S HLMSG=$S(HLAC="AR":"Application Reject",HLAC="AE":"Application Error",1:"")_" - "_HLERR
"RTN","HLTF",131,0)
 .S HLAC=$S(HLAC'="AA":4,1:3) D STATUS^HLTF0(HLDAI,HLAC,$G(HLMSG))
"RTN","HLTF",132,0)
 Q
"RTN","HLTF",133,0)
 ;
"RTN","HLTF",134,0)
IN(HLMTN,HLMID,HLTIME) ;File Data in Message Text File for Incoming Message
"RTN","HLTF",135,0)
 ;Version 1.5 Interface Only
"RTN","HLTF",136,0)
 Q:'$D(HLFS)
"RTN","HLTF",137,0)
 I HLMTN="ACK"!(HLMTN="MCF")!(HLMTN="ORR") Q:'$D(HLMSA)  D ACK(HLMSA,"O",$G(HLDA)) Q
"RTN","HLTF",138,0)
 ;
"RTN","HLTF",139,0)
 N HLDAI S HLDA=0
"RTN","HLTF",140,0)
 I $D(HLNDAP),HLMID]"" D
"RTN","HLTF",141,0)
 .F  S HLDA=+$O(^HL(772,"AH",+$P($G(HLNDAP0),U,12),HLMID,HLDA)) Q:'HLDA!($P($G(^HL(772,+HLDA,0)),U,4)="I")
"RTN","HLTF",142,0)
 .I HLDA D
"RTN","HLTF",143,0)
 ..S HLDT=+$P($G(^HL(772,HLDA,0)),"^"),HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLTF",144,0)
 ..K ^HL(772,HLDA,"IN")
"RTN","HLTF",145,0)
 .I $D(HLMSA),$P(HLMSA,HLFS,3)]"" D
"RTN","HLTF",146,0)
 ..S HLDAI=0
"RTN","HLTF",147,0)
 ..F  S HLDAI=$O(^HL(772,"AH",+$P($G(HLNDAP0),U,12),$P(HLMSA,HLFS,3),HLDAI)) Q:'HLDAI!($P($G(^HL(772,+HLDAI,0)),U,4)="O")
"RTN","HLTF",148,0)
 ..I 'HLDAI K HLDAI
"RTN","HLTF",149,0)
 ;
"RTN","HLTF",150,0)
 I 'HLDA D CREATE(.HLMID,.HLDA,.HLDT,.HLDT1) K HLZ
"RTN","HLTF",151,0)
 ;
"RTN","HLTF",152,0)
 D STUFF^HLTF0("I")
"RTN","HLTF",153,0)
 N HLAC S HLAC=$S($D(HLERR):4,1:1) D STATUS^HLTF0(HLDA,HLAC,$G(HLMSG))
"RTN","HLTF",154,0)
 ;
"RTN","HLTF",155,0)
 D MERGE15^HLTF1("G",HLDA,"HLR",HLTIME)
"RTN","HLTF",156,0)
 ;
"RTN","HLTF",157,0)
 I '$D(HLERR),$D(HLMSA),$D(HLDAI) D
"RTN","HLTF",158,0)
 .N HLAC,HLERR,HLMSG I $P(HLMSA,HLFS,4)]"" S HLERR=$P(HLMSA,HLFS,4)
"RTN","HLTF",159,0)
 .S HLAC=$P(HLMSA,HLFS,2) I HLAC'="AA" S HLMSG=$S(HLAC="AR":"Application Reject",1:"Application Error")_" - "_HLERR
"RTN","HLTF",160,0)
 .S HLAC=$S(HLAC'="AA":4,1:3) D STATUS^HLTF0(HLDAI,HLAC,$G(HLMSG))
"RTN","HLTF",161,0)
 Q
"RTN","HLTF",162,0)
 ;
"RTN","HLTF",163,0)
ACK(HLMSA,HLIO,HLDA) ;Process 'ACK' Message Type - Version 1.5 Interface Only
"RTN","HLTF",164,0)
 ; To determine the correct message to link the ACK, HLIO is used.
"RTN","HLTF",165,0)
 ; For an ack from DHCP (original message from remote system) then
"RTN","HLTF",166,0)
 ; HLIO should be "I" so that the correct inbound message is ack-ed. For
"RTN","HLTF",167,0)
 ; an inbound ack (original message outbound from DHCP) HLIO should be
"RTN","HLTF",168,0)
 ; "O". This distinction must be made due to the possible duplicate
"RTN","HLTF",169,0)
 ; message ids from a bi-direction interface.
"RTN","HLTF",170,0)
 ;
"RTN","HLTF",171,0)
 ; Input : MSA - MSA from ACK message.
"RTN","HLTF",172,0)
 ;         HLIO - Either "I" or "O" : See note above.
"RTN","HLTF",173,0)
 ;Output : None
"RTN","HLTF",174,0)
 ;
"RTN","HLTF",175,0)
 N HLAC,HLMIDI
"RTN","HLTF",176,0)
 ;-- set up required vars
"RTN","HLTF",177,0)
 S HLAC=$P(HLMSA,HLFS,2),HLMIDI=$P(HLMSA,HLFS,3)
"RTN","HLTF",178,0)
 ;-- quit
"RTN","HLTF",179,0)
 Q:HLMIDI']""!(HLAC']"")!('$D(HLNDAP))
"RTN","HLTF",180,0)
 ;-- find message to ack
"RTN","HLTF",181,0)
 I '$G(HLDA) S HLDA=0 D
"RTN","HLTF",182,0)
 . F  S HLDA=+$O(^HL(772,"AH",+$P($G(HLNDAP0),U,12),HLMIDI,HLDA)) Q:'HLDA!($P($G(^HL(772,+HLDA,0)),U,4)=HLIO)
"RTN","HLTF",183,0)
 ;-- quit if no message
"RTN","HLTF",184,0)
 Q:'$D(^HL(772,+HLDA,0))
"RTN","HLTF",185,0)
 ;-- check for error
"RTN","HLTF",186,0)
 I $P(HLMSA,HLFS,4)]"" N HLERR S HLERR=$P(HLMSA,HLFS,4)
"RTN","HLTF",187,0)
 I $D(HLERR),'$D(HLMSG) N HLMSG S HLMSG="Error During Receipt of Acknowledgement Message"_$S(HLAC="AR":" - Application Reject",HLAC="AE":" - Application Error",1:"")_" - "_HLERR
"RTN","HLTF",188,0)
 ;-- update status
"RTN","HLTF",189,0)
 S HLAC=$S(HLMTN="MCF":2,HLAC'="AA":4,1:3)
"RTN","HLTF",190,0)
 D STATUS^HLTF0(HLDA,HLAC,$G(HLMSG))
"RTN","HLTF",191,0)
 Q
"RTN","HLTF",192,0)
 ;
"RTN","HLTF",193,0)
STUB772(FLD01,OS) ;
"RTN","HLTF",194,0)
 ;This function creates a new stub record in file 772. The Stub record may consist of only the 0 node with a value of "^". If a value is passed in for the .01 field it will be included in the 0 node and its "B" x-ref set.
"RTN","HLTF",195,0)
 ;Inputs:
"RTN","HLTF",196,0)
 ;  OS (optional), the value of ^%ZOSF("OS")
"RTN","HLTF",197,0)
 ;  FLD01 (optional), the value for the .01 field
"RTN","HLTF",198,0)
 ;Output - the function returns the ien of the newly created record
"RTN","HLTF",199,0)
 ;
"RTN","HLTF",200,0)
 N IEN
"RTN","HLTF",201,0)
 I '$L($G(OS)) N OS S OS=$G(^%ZOSF("OS"))
"RTN","HLTF",202,0)
 I OS'["DSM",OS'["OpenM" D
"RTN","HLTF",203,0)
 .F  L +^HLCS(869.3,1,772):10 S IEN=+$G(^HLCS(869.3,1,772))+1,^HLCS(869.3,1,772)=IEN S:$D(^HL(772,IEN)) IEN=0,^HLCS(869.3,1,772)=($O(^HL(772,":"),-1)\1) L -^HLCS(869.3,1,772) Q:IEN
"RTN","HLTF",204,0)
 E  D
"RTN","HLTF",205,0)
 .F  S IEN=$I(^HLCS(869.3,1,772),1) S:$D(^HL(772,IEN)) IEN=0,^HLCS(869.3,1,772)=($O(^HL(772,":"),-1)\1) Q:IEN
"RTN","HLTF",206,0)
 S ^HL(772,IEN,0)=$G(FLD01)_"^"
"RTN","HLTF",207,0)
 I $L($G(FLD01)) S ^HL(772,"B",FLD01,IEN)=""
"RTN","HLTF",208,0)
 Q IEN
"RTN","HLTF",209,0)
 ;
"RTN","HLTF",210,0)
STUB773(FLD01,OS) ;
"RTN","HLTF",211,0)
 ;This function creates a new stub record in file 772. The Stub record may consist of only the 0 node with a value of "^". If a value is passed in for the .01 field it will be included in the 0 node and its "B" x-ref set.
"RTN","HLTF",212,0)
 ;Inputs:
"RTN","HLTF",213,0)
 ;  OS (optional), the value of ^%ZOSF("OS")
"RTN","HLTF",214,0)
 ;  FLD01 (optional), the value for the .01 field
"RTN","HLTF",215,0)
 ;Output - the function returns the ien of the newly created record
"RTN","HLTF",216,0)
 ;
"RTN","HLTF",217,0)
 N IEN
"RTN","HLTF",218,0)
 I '$L($G(OS)) N OS S OS=$G(^%ZOSF("OS"))
"RTN","HLTF",219,0)
 I OS'["DSM",OS'["OpenM" D
"RTN","HLTF",220,0)
 .F  L +^HLCS(869.3,1,773):10 S IEN=+$G(^HLCS(869.3,1,773))+1,^HLCS(869.3,1,773)=IEN S:$D(^HLMA(IEN)) IEN=0,^HLCS(869.3,1,773)=($O(^HLMA(":"),-1)\1) L -^HLCS(869.3,1,773) Q:IEN
"RTN","HLTF",221,0)
 E  D
"RTN","HLTF",222,0)
 .F  S IEN=$I(^HLCS(869.3,1,773),1) S:$D(^HLMA(IEN)) IEN=0,^HLCS(869.3,1,773)=($O(^HLMA(":"),-1)\1) Q:IEN
"RTN","HLTF",223,0)
 S ^HLMA(IEN,0)=$G(FLD01)_"^"
"RTN","HLTF",224,0)
 I $L($G(FLD01)) S ^HLMA("B",FLD01,IEN)=""
"RTN","HLTF",225,0)
 Q IEN
"RTN","HLTF0")
0^81^B30082735
"RTN","HLTF0",1,0)
HLTF0 ;AISC/SAW,JRP - File Data in Message Text File ;05/05/2000  09:01
"RTN","HLTF0",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**12,19,64,91,109**;Oct 13, 1995
"RTN","HLTF0",3,0)
 ;
"RTN","HLTF0",4,0)
STATUS(MTIEN,STATUS,ERR,ERRTEXT,COMDT,NOEVENT) ;Update Status of Entry in Message Text File and log an event for errors
"RTN","HLTF0",5,0)
 ;
"RTN","HLTF0",6,0)
 ;This is a subroutine call with parameter passing.  No output
"RTN","HLTF0",7,0)
 ;parameters are returned
"RTN","HLTF0",8,0)
 ;
"RTN","HLTF0",9,0)
 ;$D(HLTCP) will determine if you are updating file 773, instead
"RTN","HLTF0",10,0)
 ; of file 772.
"RTN","HLTF0",11,0)
 ;Required Input Parameters
"RTN","HLTF0",12,0)
 ;    MTIEN = IEN of entry in file 772 or 773, to be updated
"RTN","HLTF0",13,0)
 ;   STATUS = IEN of new status (pointer to Message Status file)
"RTN","HLTF0",14,0)
 ;Optional Parameters
"RTN","HLTF0",15,0)
 ;      ERR = IEN of error message (pointer to Error Message file)
"RTN","HLTF0",16,0)
 ;  ERRTEXT = An error message of up to 200 characters
"RTN","HLTF0",17,0)
 ;    COMDT = 0/1 ; 1=update DATE/TIME PROCESSED, field 100
"RTN","HLTF0",18,0)
 ;  NOEVENT = 1 if an event should NOT be logged.  Presumably this signals that the application already logged the event
"RTN","HLTF0",19,0)
 ;
"RTN","HLTF0",20,0)
 ;Check for required parameters
"RTN","HLTF0",21,0)
 I '$G(MTIEN)!('$G(STATUS)) Q
"RTN","HLTF0",22,0)
 ;File new status info
"RTN","HLTF0",23,0)
 N HLJ,HLOCK,X
"RTN","HLTF0",24,0)
 ;if TCP update status in file 773, else status in file 772
"RTN","HLTF0",25,0)
 I $D(HLTCP) S X="HLJ(773,",HLOCK="^HLMA("
"RTN","HLTF0",26,0)
 E  S X="HLJ(772,",HLOCK="^HL(772,"
"RTN","HLTF0",27,0)
 S X=X_""""_MTIEN_","")",HLOCK=HLOCK_MTIEN_")"
"RTN","HLTF0",28,0)
 ;20=status, 21=date process
"RTN","HLTF0",29,0)
 S @X@(20)=STATUS,@X@(21)=$S(STATUS=1:"@",1:$$NOW^XLFDT)
"RTN","HLTF0",30,0)
 ;22=error msg
"RTN","HLTF0",31,0)
 S:$G(ERRTEXT)]"" @X@(22)=$E(ERRTEXT,1,200)
"RTN","HLTF0",32,0)
 ;23=error type
"RTN","HLTF0",33,0)
 S:$G(ERR) @X@(23)=+ERR
"RTN","HLTF0",34,0)
 ;100=date/time processed
"RTN","HLTF0",35,0)
 S:$G(COMDT) @X@(100)=$$NOW^XLFDT
"RTN","HLTF0",36,0)
 ;**109** F  L +@HLOCK:1 Q:$T  H 1
"RTN","HLTF0",37,0)
 D FILE^HLDIE("","HLJ","","STATUS","HLTF0") ;HL*1.6*109
"RTN","HLTF0",38,0)
 ;**109** L -@HLOCK
"RTN","HLTF0",39,0)
 ;
"RTN","HLTF0",40,0)
 ;if the status is error, and the event is not being surpressed by the
"RTN","HLTF0",41,0)
 ;application, log a new event
"RTN","HLTF0",42,0)
 I '$G(NOEVENT),$G(STATUS)=4 D
"RTN","HLTF0",43,0)
 .N CODE,HL7MSGID,ERROR,PARENT,EVENT
"RTN","HLTF0",44,0)
 .S CODE=$G(ERR)
"RTN","HLTF0",45,0)
 .S (HL7MSGID,PARENT)=""
"RTN","HLTF0",46,0)
 .I $G(MTIEN) D
"RTN","HLTF0",47,0)
 ..N NODE
"RTN","HLTF0",48,0)
 ..I $G(HLTCP) D
"RTN","HLTF0",49,0)
 ...S NODE=$G(^HLMA(MTIEN,0))
"RTN","HLTF0",50,0)
 ...S HL7MSGID=$P(NODE,"^",2)
"RTN","HLTF0",51,0)
 ...S PARENT=$P(NODE,"^",6)
"RTN","HLTF0",52,0)
 ..E  D
"RTN","HLTF0",53,0)
 ...S NODE=$G(^HL(772,MTIEN,0))
"RTN","HLTF0",54,0)
 ...S HL7MSGID=$P(NODE,"^",6)
"RTN","HLTF0",55,0)
 ...S PARENT=$P(NODE,"^",8)
"RTN","HLTF0",56,0)
 .;
"RTN","HLTF0",57,0)
 .S EVENT=$$EVENT^HLEME(CODE,"HEALTH LEVEL SEVEN",HL7MSGID,,,.ERROR)
"RTN","HLTF0",58,0)
 .;I 'EVENT,'$D(ZTQUEUED) W !,"Failed to create an Event in STATUS^HLTF0: ",$G(ERROR)_" "_$G(ERROR(1))_" "_$G(ERROR(2))
"RTN","HLTF0",59,0)
 .;
"RTN","HLTF0",60,0)
 .I EVENT D
"RTN","HLTF0",61,0)
 ..I $L($G(ERRTEXT)),$$ADDNOTE^HLEME(EVENT,"Application Error Text: "_ERRTEXT)
"RTN","HLTF0",62,0)
 ..;If this message was not the initial message in a transaction protocol, then provide some information about the initial message
"RTN","HLTF0",63,0)
 ..I PARENT,PARENT'=$G(MTIEN) D
"RTN","HLTF0",64,0)
 ...N PLINK,PMSGID,PMSGTYPE,PNODE,PEVENT,PNOTES
"RTN","HLTF0",65,0)
 ...I $D(HLTCP) D
"RTN","HLTF0",66,0)
 ....S PNODE=$G(^HLMA(PARENT,0))
"RTN","HLTF0",67,0)
 ....S PLINK=$P(PNODE,"^",7)
"RTN","HLTF0",68,0)
 ....S PMSGID=$P(PNODE,"^",2)
"RTN","HLTF0",69,0)
 ....S PMSGTYPE=$P(PNODE,"^",13)
"RTN","HLTF0",70,0)
 ....S PEVENT=$P(PNODE,"^",14)
"RTN","HLTF0",71,0)
 ...E  D
"RTN","HLTF0",72,0)
 ....S PNODE=$G(^HL(772,PARENT,0))
"RTN","HLTF0",73,0)
 ....S PLINK=$P(PNODE,"^",11)
"RTN","HLTF0",74,0)
 ....S PMSGID=$P(PNODE,"^",6)
"RTN","HLTF0",75,0)
 ....S PMSGTYPE=""
"RTN","HLTF0",76,0)
 ....S PEVENT=""
"RTN","HLTF0",77,0)
 ...S PNOTES(1)="Initial Message in this transaction protocol:"
"RTN","HLTF0",78,0)
 ...S PNOTES(2)="  Initial Message ID: "_PMSGID
"RTN","HLTF0",79,0)
 ...S PNOTES(3)="  Logical Link of Initial Message: "
"RTN","HLTF0",80,0)
 ...S:PLINK PNOTES(3)=PNOTES(3)_$P($G(^HLCS(870,PLINK,0)),"^")
"RTN","HLTF0",81,0)
 ...S:PMSGTYPE PNOTES(4)="  Inital Message Type: "_$P($G(^HL(771.2,PMSGTYPE,0)),"^")
"RTN","HLTF0",82,0)
 ...S:PEVENT PNOTES(5)="  Inital Message Event: "_$P($G(^HL(779.001,PEVENT,0)),"^")
"RTN","HLTF0",83,0)
 ...I $$ADDNOTE^HLEME(EVENT,.PNOTES) ;then notes successfully added
"RTN","HLTF0",84,0)
 Q
"RTN","HLTF0",85,0)
 ;
"RTN","HLTF0",86,0)
STATS(MTIEN,HLCHAR,HLEVN) ;Enter Statistics for an Entry in Message
"RTN","HLTF0",87,0)
 ;Text File
"RTN","HLTF0",88,0)
 ;
"RTN","HLTF0",89,0)
 ;This is a subroutine call with parameter passing.  No output
"RTN","HLTF0",90,0)
 ;parameters are returned
"RTN","HLTF0",91,0)
 ;
"RTN","HLTF0",92,0)
 ;Required Input Parameters
"RTN","HLTF0",93,0)
 ;   MTIEN = The IEN from the Message Text file of the entry to be
"RTN","HLTF0",94,0)
 ;             updated
"RTN","HLTF0",95,0)
 ;  HLCHAR = The number of characters in the message
"RTN","HLTF0",96,0)
 ;   HLEVN = The number of HL7 events in the message
"RTN","HLTF0",97,0)
 ;
"RTN","HLTF0",98,0)
 ;Check for required parameters
"RTN","HLTF0",99,0)
 I '$G(MTIEN)!('$D(HLCHAR))!('$D(HLEVN)) Q
"RTN","HLTF0",100,0)
 I '$D(^HL(772,MTIEN,0)) Q
"RTN","HLTF0",101,0)
 ;File statistical info
"RTN","HLTF0",102,0)
 ;**109** F  L +^HL(772,MTIEN):1 H:'$T 1 I $T D  Q
"RTN","HLTF0",103,0)
 D
"RTN","HLTF0",104,0)
 .  S ^HL(772,MTIEN,"S")=HLCHAR_"^"_$G(HLEVN)
"RTN","HLTF0",105,0)
 ;**109** .  L -^HL(772,MTIEN)
"RTN","HLTF0",106,0)
 Q
"RTN","HLTF0",107,0)
STUFF(HLMT) ;Update Fields on Zero Node of the Message Text File for
"RTN","HLTF0",108,0)
 ;Version 1.5 Interface Only
"RTN","HLTF0",109,0)
 ;
"RTN","HLTF0",110,0)
 ;This is a subroutine call with parameter passing.  No output
"RTN","HLTF0",111,0)
 ;parameters are returned
"RTN","HLTF0",112,0)
 ;
"RTN","HLTF0",113,0)
 ;Required Input Parameter
"RTN","HLTF0",114,0)
 ;  HLMT = Message type, O for outgoing or I for incoming
"RTN","HLTF0",115,0)
 ;
"RTN","HLTF0",116,0)
 ;Check for required parameter
"RTN","HLTF0",117,0)
 Q:HLMT']""
"RTN","HLTF0",118,0)
 ;File zero node data
"RTN","HLTF0",119,0)
 N DA,DIC,DIE,DR
"RTN","HLTF0",120,0)
 S (DIC,DIE)="^HL(772,",DA=HLDA
"RTN","HLTF0",121,0)
 S DR="4////"_HLMT_$S('$G(HLDAP):"",1:";2////"_HLDAP)_$S('$G(HLXMZ):"",1:";5////"_HLXMZ)_$S('$G(HLDAI):"",1:";7////"_HLDAI)_";Q"_$S('$P($G(HLNDAP0),U,12):"",1:";3////"_$P($G(HLNDAP0),U,12))
"RTN","HLTF0",122,0)
 F  L +^HL(772,DA):1 H:'$T 1 I $T D  Q
"RTN","HLTF0",123,0)
 .  D ^DIE
"RTN","HLTF0",124,0)
 .  L -^HL(772,DA)
"RTN","HLTF0",125,0)
 Q
"RTN","HLTF0",126,0)
UPDATE(MTIEN,MTIENP,HLMT,EID,CLIENT,SERVER,PRIORITY,REPLYTO,LOGLINK,HLP) ;
"RTN","HLTF0",127,0)
 ;Update Fields of the Message Text File #772 or Message Administration
"RTN","HLTF0",128,0)
 ; File #773 for Bi-directional TCP
"RTN","HLTF0",129,0)
 ;
"RTN","HLTF0",130,0)
 ;$D(HLTCP) will determine if you are updating file 773, instead
"RTN","HLTF0",131,0)
 ; of file 772.
"RTN","HLTF0",132,0)
 ;
"RTN","HLTF0",133,0)
 ;This is a subroutine call with parameter passing.  No output
"RTN","HLTF0",134,0)
 ;parameters are returned
"RTN","HLTF0",135,0)
 ;
"RTN","HLTF0",136,0)
 ;Required Input Parameters
"RTN","HLTF0",137,0)
 ;   MTIEN = The IEN from file 772 or 773 of the entry to be
"RTN","HLTF0",138,0)
 ;             updated
"RTN","HLTF0",139,0)
 ;  MTIENP = The IEN from the Message Text file of the parent entry
"RTN","HLTF0",140,0)
 ;           to which this entry (MTIEN) should be linked. TCP will
"RTN","HLTF0",141,0)
 ;           ignore this parameter.
"RTN","HLTF0",142,0)
 ;    HLMT = The type of message, I for Incoming or O for Outgoing
"RTN","HLTF0",143,0)
 ;NOTE:  Either Client or Server must be passed.  Both parameters may
"RTN","HLTF0",144,0)
 ;         be passed
"RTN","HLTF0",145,0)
 ;  CLIENT = The IEN of the client (subscriber) application from
"RTN","HLTF0",146,0)
 ;             the Application Parameter file
"RTN","HLTF0",147,0)
 ;  SERVER = The IEN of the server (event driver) application from
"RTN","HLTF0",148,0)
 ;             the Application Parameter file
"RTN","HLTF0",149,0)
 ;Optional parameters
"RTN","HLTF0",150,0)
 ;     EID = The IEN from the Protocol file of the event related to this
"RTN","HLTF0",151,0)
 ;             Message Text file entry
"RTN","HLTF0",152,0)
 ;PRIORITY = I for immediate or D for deferred
"RTN","HLTF0",153,0)
 ; REPLYTO = The IEN from the Message Text file of the message being
"RTN","HLTF0",154,0)
 ;             acknowledged.  (Only used for acknowledgement messages.)
"RTN","HLTF0",155,0)
 ; LOGLINK = The IEN of the logical link from the Logical Link file
"RTN","HLTF0",156,0)
 ; HLP("SECURITY")    = A 1 to 40 character string
"RTN","HLTF0",157,0)
 ; HLP("CONTPTR")     = Continuation pointer, a 1 to 180 character string
"RTN","HLTF0",158,0)
 ; HLP("MSGTYPE")     = M for Single Message or B for Batch of Messages
"RTN","HLTF0",159,0)
 ; HLP("EVENT")       = ien of event type
"RTN","HLTF0",160,0)
 ; HLP("MTYPE")       = ien of message type
"RTN","HLTF0",161,0)
 ; HLP("HLTCPI")      = ien of initial message
"RTN","HLTF0",162,0)
 ; HLP("ACKTIME")     = acknowledge timeout override for this message
"RTN","HLTF0",163,0)
 ; HLP("NAMESPACE")   = Passed in by application namespace - HL*1.6*91
"RTN","HLTF0",164,0)
 ;
"RTN","HLTF0",165,0)
 ;Check for required parameters
"RTN","HLTF0",166,0)
 I '$G(MTIEN)!($G(HLMT)']"") Q
"RTN","HLTF0",167,0)
 ;File new status info
"RTN","HLTF0",168,0)
 N HLJ,HLOCK,X,Y
"RTN","HLTF0",169,0)
 ;if TCP update status in file 773, else status in file 772
"RTN","HLTF0",170,0)
 S Y=$D(HLTCP)
"RTN","HLTF0",171,0)
 I Y S X="HLJ(773,",HLOCK="^HLMA("
"RTN","HLTF0",172,0)
 E  S X="HLJ(772,",HLOCK="^HL(772,"
"RTN","HLTF0",173,0)
 ;transmission type
"RTN","HLTF0",174,0)
 S X=X_""""_MTIEN_","")",HLOCK=HLOCK_MTIEN_")",@X@($S(Y:3,1:4))=HLMT
"RTN","HLTF0",175,0)
 ;sending or server application
"RTN","HLTF0",176,0)
 S:$G(SERVER) @X@($S(Y:13,1:2))=SERVER
"RTN","HLTF0",177,0)
 ;receiving or client application
"RTN","HLTF0",178,0)
 S:$G(CLIENT) @X@($S(Y:14,1:3))=CLIENT
"RTN","HLTF0",179,0)
 ;acknowledgement to
"RTN","HLTF0",180,0)
 S:$G(REPLYTO) @X@($S(Y:12,1:7))=REPLYTO
"RTN","HLTF0",181,0)
 ;parent message
"RTN","HLTF0",182,0)
 S:$G(MTIENP) @X@(8)=MTIENP
"RTN","HLTF0",183,0)
 ;priority
"RTN","HLTF0",184,0)
 S:$G(PRIORITY)]"" @X@($S(Y:4,1:9))=PRIORITY
"RTN","HLTF0",185,0)
 ;related event protocol
"RTN","HLTF0",186,0)
 S:$G(EID) @X@($S(Y:8,1:10))=EID
"RTN","HLTF0",187,0)
 ;logical link
"RTN","HLTF0",188,0)
 S:$G(LOGLINK) @X@($S(Y:7,1:11))=LOGLINK
"RTN","HLTF0",189,0)
 ;security
"RTN","HLTF0",190,0)
 S:$G(HLP("SECURITY"))]"" @X@($S(Y:9,1:12))=HLP("SECURITY")
"RTN","HLTF0",191,0)
 ;namespace - HL*1.6*91
"RTN","HLTF0",192,0)
 I HLOCK["HL(772" S:$G(HLP("NAMESPACE"))?1U1.3UN @X@(16)=HLP("NAMESPACE") ;HL*1.6*91
"RTN","HLTF0",193,0)
 ;message type
"RTN","HLTF0",194,0)
 S:$G(HLP("MSGTYPE"))]"" @X@($S(Y:5,1:14))=HLP("MSGTYPE")
"RTN","HLTF0",195,0)
 ;continuation pointer
"RTN","HLTF0",196,0)
 S:$G(HLP("CONTPTR"))]"" @X@($S(Y:11,1:13))=HLP("CONTPTR")
"RTN","HLTF0",197,0)
 ;ack timeout override
"RTN","HLTF0",198,0)
 S:$G(HLP("ACKTIME")) @X@(26)=HLP("ACKTIME")
"RTN","HLTF0",199,0)
 ;only for file 773
"RTN","HLTF0",200,0)
 I Y D
"RTN","HLTF0",201,0)
 . ;initial message
"RTN","HLTF0",202,0)
 . S:$G(HLP("HLTCPI")) @X@(6)=HLP("HLTCPI")
"RTN","HLTF0",203,0)
 . ;message type
"RTN","HLTF0",204,0)
 . S:$G(HLP("MTYPE")) @X@(15)=HLP("MTYPE")
"RTN","HLTF0",205,0)
 . ;event type
"RTN","HLTF0",206,0)
 . S:$G(HLP("EVENT")) @X@(16)=HLP("EVENT")
"RTN","HLTF0",207,0)
 ;**109** F  L +@HLOCK:1 Q:$T  H 1
"RTN","HLTF0",208,0)
 D FILE^HLDIE("","HLJ","","UPDATE","HLTF0") ; HL*1.6*109
"RTN","HLTF0",209,0)
 ;**109** L -@HLOCK
"RTN","HLTF0",210,0)
 Q
"RTN","HLTP2")
0^82^B2417166
"RTN","HLTP2",1,0)
HLTP2 ;AISC/SAW-Transaction Processor Module (Cont'd) ;2/22/95  11:35
"RTN","HLTP2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**34,109**;Oct 13, 1995
"RTN","HLTP2",3,0)
PROCACK(HLMTIEN,HLEID,HLRESLT,HL) ;Process acknowledgement message
"RTN","HLTP2",4,0)
 ;
"RTN","HLTP2",5,0)
 ;This is a subroutine call with parameter passing.  It returns a value
"RTN","HLTP2",6,0)
 ;in the variable HLRESLT of null if no error occurs, or the following
"RTN","HLTP2",7,0)
 ;two piece value if an error occurs:  error code^error description
"RTN","HLTP2",8,0)
 ;
"RTN","HLTP2",9,0)
 ;Required Input Parameters
"RTN","HLTP2",10,0)
 ; HLMTIEN = The IEN from the Message Text file created when the
"RTN","HLTP2",11,0)
 ;             GENERATE^HLMA or SEND^HLMA2 entry points were invoked
"RTN","HLTP2",12,0)
 ;   HLEID = The IEN from the Protocol file of the driver event
"RTN","HLTP2",13,0)
 ;NOTE:  The variable HLRESLT must be passed by reference
"RTN","HLTP2",14,0)
 ; HLRESLT = The variable that will be returned to the calling
"RTN","HLTP2",15,0)
 ;             application as descibed above
"RTN","HLTP2",16,0)
 ;Optional Input Parameter
"RTN","HLTP2",17,0)
 ;      HL = An array of variables to be used in processing the message
"RTN","HLTP2",18,0)
 ;
"RTN","HLTP2",19,0)
 ;Check for required parameters
"RTN","HLTP2",20,0)
 S HLRESLT=""
"RTN","HLTP2",21,0)
 I '$G(HLMTIEN)!('$G(HLEID)) S HLRESLT="7^"_$G(^HL(771.7,7,0))_" at PROCACK^HLTP0 entry point" G EXIT
"RTN","HLTP2",22,0)
 ;Create HL array of variables if it does not exist
"RTN","HLTP2",23,0)
 I '$D(HL) N HL D INIT^HLFNC2(HLEID,.HL)
"RTN","HLTP2",24,0)
 ;Set special HL variables if data is in global array
"RTN","HLTP2",25,0)
 I '$D(HLA("HLA")) S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLTP2",26,0)
 ;Get and execute processing routine
"RTN","HLTP2",27,0)
 D EVENT^HLUTIL1(HLEID,"15,20,772",.HLN) I $G(HLN(772))]"" D
"RTN","HLTP2",28,0)
 .X:$G(HLN(20))]"" $G(HLN(20))
"RTN","HLTP2",29,0)
 .N HLERR X HLN(772) I $D(HLERR) S HLRESLT="9^"_$G(^HL(771.7,9,0))
"RTN","HLTP2",30,0)
 .X:$G(HLN(15))]"" $G(HLN(15))
"RTN","HLTP2",31,0)
 ;Update status of message
"RTN","HLTP2",32,0)
 D STATUS^HLTF0(HLMTIEN,$S($D(HLERR):4,1:3),$S($D(HLERR):+HLRESLT,1:""),$S($D(HLERR):HLERR,1:""),,$S($G(HLERR("SKIP_EVENT"))=1:1,1:0))
"RTN","HLTP2",33,0)
EXIT K HLN,HLNEXT,HLNODE,HLQUIT
"RTN","HLTP2",34,0)
 Q
"RTN","HLTP3")
0^49^B61824583
"RTN","HLTP3",1,0)
HLTP3 ;SFIRMFO/RSD - Transaction Processor for TCP ;01/30/2004  16:15
"RTN","HLTP3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,58,59,66,69,109**;Oct 13, 1995
"RTN","HLTP3",3,0)
 ;
"RTN","HLTP3",4,0)
 Q
"RTN","HLTP3",5,0)
NEW(X) ;process new msg. ien in 773^msg. ien in 772
"RTN","HLTP3",6,0)
 ;HLMTIENS=ien in #773, msg header; HLMTIEN=ien in #772, msg text
"RTN","HLTP3",7,0)
 ;HLHDRO=original header;  HLHDR=response header
"RTN","HLTP3",8,0)
 ;set error trap
"RTN","HLTP3",9,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP3",10,0)
 N HL,HLEID,HLEIDS,HLERR,HLHDR,HLHDRO,HLMTIEN,HLMTIENS,HLJ,HLMSA,HLQUIT,HLNODE,HLNEXT,HLRESLTA,HLDONE1,HLASTRSP
"RTN","HLTP3",11,0)
 D INIT^HLTP3A ;patch HL*1.6*109 - hltp3 routine split
"RTN","HLTP3",12,0)
 ;error with header, return commit/app reject
"RTN","HLTP3",13,0)
 I $G(HLRESLT) D  Q
"RTN","HLTP3",14,0)
 . ;set status & unlock record
"RTN","HLTP3",15,0)
 . D STATUS^HLTF0(HLMTIENS,4,,,1),EXIT
"RTN","HLTP3",16,0)
 . ;quit if no commit or app ack
"RTN","HLTP3",17,0)
 . I $G(HL("ACAT"))="NE",$G(HL("APAT"))="NE" Q
"RTN","HLTP3",18,0)
 . S X=$S($G(HL("ACAT"))="AL":"CR",1:"AR")
"RTN","HLTP3",19,0)
 . ;HLTCP=ien of acknowledgment msg. from ACK^HLTP4
"RTN","HLTP3",20,0)
 . D ACK^HLTP4(X,$P(HLRESLT,U,2)) Q:'$G(HLTCP)
"RTN","HLTP3",21,0)
 . ;update counter, msg. to send
"RTN","HLTP3",22,0)
 .; D LLCNT^HLCSTCP(HLDP,3) ;**109** done in ACK^HLTP4
"RTN","HLTP3",23,0)
 . ;write ack back over connection
"RTN","HLTP3",24,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",25,0)
 . ;update counter to sent
"RTN","HLTP3",26,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",27,0)
 . ;update status of ack to complete
"RTN","HLTP3",28,0)
 . D STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",29,0)
 ;
"RTN","HLTP3",30,0)
 ;check for duplicate msg., use rec. app and msg. id x-ref
"RTN","HLTP3",31,0)
 I $G(HL("MID")),$G(HL("RAP")) S X=$O(^HLMA("AH",HL("RAP"),HL("MID"),0)) D  Q:'$D(HLMTIENS)
"RTN","HLTP3",32,0)
 . ;HLASTMSG=last ien received during this connection
"RTN","HLTP3",33,0)
 . ;if no duplicate, save msg. ien and quit
"RTN","HLTP3",34,0)
 . I X=HLMTIENS!'X S HLASTMSG=HLMTIENS Q
"RTN","HLTP3",35,0)
 . N MSH,OIENS
"RTN","HLTP3",36,0)
 . S (OIENS,Y)=X D  S Y=HLMTIENS D
"RTN","HLTP3",37,0)
 .. ;combine MSH into single string
"RTN","HLTP3",38,0)
 .. S MSH(Y)="",I=0 F  S I=$O(^HLMA(Y,"MSH",I)) Q:'I  S MSH(Y)=MSH(Y)_$G(^(I,0))
"RTN","HLTP3",39,0)
 . ;if MSH is not identical, then msg. are different, quit
"RTN","HLTP3",40,0)
 . I MSH(HLMTIENS)'=MSH(OIENS) S HLASTMSG=HLMTIENS Q
"RTN","HLTP3",41,0)
 . ;msg is duplicate, set status as duplicate
"RTN","HLTP3",42,0)
 . D STATUS^HLTF0(HLMTIENS,4,109,"Duplicate with ien "_OIENS,1),EXIT
"RTN","HLTP3",43,0)
 . ;msg was resent during this connection, ignore it.
"RTN","HLTP3",44,0)
 . I HLASTMSG=HLMTIENS K HLMTIENS Q
"RTN","HLTP3",45,0)
 . ;msg was resent during another connection
"RTN","HLTP3",46,0)
 . ;if status of original msg wasn't success then process msg, quit
"RTN","HLTP3",47,0)
 . ;Q:+$G(^HLMA(OIENS,"P"))'=3
"RTN","HLTP3",48,0)
 . L +^HLMA(OIENS):0
"RTN","HLTP3",49,0)
 . I $T L -^HLMA(OIENS) I +$G(^HLMA(OIENS,"P"))'=3,'$$ONAC(OIENS) Q
"RTN","HLTP3",50,0)
 . ;find original response and send back
"RTN","HLTP3",51,0)
 . S HLASTRSP=$O(^HLMA("AF",OIENS,OIENS))
"RTN","HLTP3",52,0)
 ;
"RTN","HLTP3",53,0)
 ;Quit if this is acknowledgment to acknowledgement message
"RTN","HLTP3",54,0)
 I $G(HL("ACK")) D  Q
"RTN","HLTP3",55,0)
 . ;Update status of original acknowledgment message to successfully
"RTN","HLTP3",56,0)
 . D STATUS^HLTF0(HL("MTIENS"),3,,,1),STATUS^HLTF0(HLMTIENS,3,,,1)
"RTN","HLTP3",57,0)
 . ;unlock record
"RTN","HLTP3",58,0)
 . D EXIT
"RTN","HLTP3",59,0)
 ;
"RTN","HLTP3",60,0)
 ;enhance ack., send commit, quit if not an ack, msg will be processed by filer
"RTN","HLTP3",61,0)
 I $G(HL("ACAT"))="AL" D  Q:'$G(HL("MTIENS"))
"RTN","HLTP3",62,0)
 . ;msg is a resend, HLASTRSP=ien of original response
"RTN","HLTP3",63,0)
 .I $G(HLASTRSP) D
"RTN","HLTP3",64,0)
 ..S HLTCP=HLASTRSP
"RTN","HLTP3",65,0)
 ..D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",66,0)
 . E  D  Q:'$G(HLTCP)
"RTN","HLTP3",67,0)
 ..D ACK^HLTP4("CA") ;**109** LLCNT^HLCSTCP(HLDP,3) called in ACK^HLTP4
"RTN","HLTP3",68,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",69,0)
 . D LLCNT^HLCSTCP(HLDP,4),STATUS^HLTF0(HLTCP,3,,,1):'$G(HLASTRSP)
"RTN","HLTP3",70,0)
 . S HLTCP=""
"RTN","HLTP3",71,0)
 . ;if not an ack, set status to awaiting processing **109** and put on in queue
"RTN","HLTP3",72,0)
 . I '$G(HL("MTIENS")),'$G(HLASTRSP) D STATUS^HLTF0(HLMTIENS,9),EXIT,SETINQUE^HLTP31
"RTN","HLTP3",73,0)
 ;
"RTN","HLTP3",74,0)
 ;enhance ack., no commit & no app ack
"RTN","HLTP3",75,0)
 I $G(HL("ACAT"))="NE",$G(HL("APAT"))="NE" D  Q
"RTN","HLTP3",76,0)
 . ;set status to awaiting processing, **109** and put on in queue
"RTN","HLTP3",77,0)
 . I '$G(HLASTRSP) D STATUS^HLTF0(HLMTIENS,9),EXIT,SETINQUE^HLTP31
"RTN","HLTP3",78,0)
 ;
"RTN","HLTP3",79,0)
 ;resending old response, msg is a resend
"RTN","HLTP3",80,0)
 I $G(HLASTRSP) S HLTCP=HLASTRSP G ACK
"RTN","HLTP3",81,0)
CONT ;continue processing an enhance ack msg. called from DEFACK
"RTN","HLTP3",82,0)
 ;Set special HL variables for processing rtn
"RTN","HLTP3",83,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLTP3",84,0)
 ;
"RTN","HLTP3",85,0)
 ; message is an acknowledgement, HLMSA=ack code^id^text
"RTN","HLTP3",86,0)
 I ($G(HLMSA)]"") D  Q
"RTN","HLTP3",87,0)
 . ;X=1 if ack ok, 0=reject of error
"RTN","HLTP3",88,0)
 . S X=$E(HLMSA,2)="A"
"RTN","HLTP3",89,0)
 . ;Update status of original subscriber message
"RTN","HLTP3",90,0)
 . D STATUS^HLTF0(HL("MTIENS"),$S(X:3,1:4),"",$S(X:"",1:$P(HLMSA,HL("FS"),3)),1)
"RTN","HLTP3",91,0)
 . D
"RTN","HLTP3",92,0)
 .. N HLTCP ;New variable to update status in file #772.
"RTN","HLTP3",93,0)
 .. D PROCACK^HLTP2(HLMTIEN,HL("EID"),.HLRESLT,.HL)
"RTN","HLTP3",94,0)
 . ;update status of incoming to complete & unlock
"RTN","HLTP3",95,0)
 . D STATUS^HLTF0(HLMTIENS,$S($G(HLRESLT):4,1:3),$S($G(HLRESLT):+$G(HLRESLT),1:""),$S($G(HLRESLT):$P(HLRESLT,U,2),1:""),1),EXIT
"RTN","HLTP3",96,0)
 ;
"RTN","HLTP3",97,0)
 ;get entry action, exit action and processing routine
"RTN","HLTP3",98,0)
 K HLHDR,HLLD0,HLLD1,HLMSA
"RTN","HLTP3",99,0)
 I HL("EIDS")="",$G(HLEIDS)]"" S HL("EIDS")=HLEIDS ;**CIRN**
"RTN","HLTP3",100,0)
 D EVENT^HLUTIL1(HL("EIDS"),"15,20,771",.HLN)
"RTN","HLTP3",101,0)
 S HLENROU=$G(HLN(20)),HLEXROU=$G(HLN(15)),HLPROU=$G(HLN(771))
"RTN","HLTP3",102,0)
 ;quit if no processing routine,update status and quit
"RTN","HLTP3",103,0)
 I HLPROU']"" S HLRESLT="10^"_$G(^HL(771.7,10,0)) D STATUS^HLTF0(HLMTIENS,3,,,1),EXIT Q
"RTN","HLTP3",104,0)
 ;HLORNOD=subscriber protocol for Fileman auditing, ien;global ref
"RTN","HLTP3",105,0)
 N HLORNODD S HLORNOD=HL("EIDS")_";ORD(101,"
"RTN","HLTP3",106,0)
 ;Execute entry action of client protocol
"RTN","HLTP3",107,0)
 X:HLENROU]"" HLENROU K HLENROU,HLDONE1
"RTN","HLTP3",108,0)
 ;
"RTN","HLTP3",109,0)
 ;Execute processing routine
"RTN","HLTP3",110,0)
 X HLPROU S HLRESLT=0 S:($D(HLERR)) HLRESLT="9^"_HLERR
"RTN","HLTP3",111,0)
 ;update status of incoming to complete & unlock
"RTN","HLTP3",112,0)
 D STATUS^HLTF0(HLMTIENS,$S(HLRESLT:4,1:3),$S(HLRESLT:+HLRESLT,1:""),$S(HLRESLT:$P(HLRESLT,U,2),1:""),1,$S($G(HLERR("SKIP_EVENT"))=1:1,1:0)),EXIT
"RTN","HLTP3",113,0)
 ;HLTCPO=link open, HLTCP=ien of acknowledgment msg. from GENACK
"RTN","HLTP3",114,0)
ACK I $G(HLTCPO),$G(HLTCP) D  Q
"RTN","HLTP3",115,0)
 . D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP3",116,0)
 . ;write ack back over open tcp link
"RTN","HLTP3",117,0)
 . S X=$$WRITE^HLCSTCP2(HLTCP)
"RTN","HLTP3",118,0)
 . ;update status of ack to complete
"RTN","HLTP3",119,0)
 . D:'$G(HLASTRSP) STATUS^HLTF0(HLTCP,3,,,1)
"RTN","HLTP3",120,0)
 . D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLTP3",121,0)
 Q
"RTN","HLTP3",122,0)
 ;
"RTN","HLTP3",123,0)
DEFACK(HLDP,X) ;process the deferred application ack, called from HLCSIN
"RTN","HLTP3",124,0)
 ;HLDP=logical link, X=ien in file 773
"RTN","HLTP3",125,0)
 ;set error trap
"RTN","HLTP3",126,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP3",127,0)
 N HLERR     ;patch HL*1.6*109
"RTN","HLTP3",128,0)
 Q:'$G(HLDP)!'$G(X)  Q:'$G(^HLMA(X,0))
"RTN","HLTP3",129,0)
 ;**109 START**
"RTN","HLTP3",130,0)
 ;try lock, quit if can't lock or x-ref is gone
"RTN","HLTP3",131,0)
 ;L +^HLMA(X):0 Q:'$T
"RTN","HLTP3",132,0)
 ;L +^HLMA("AC","I",HLDP,X):0 I '$T L -^HLMA(X) Q
"RTN","HLTP3",133,0)
 ;L -^HLMA("AC","I",HLDP,X)
"RTN","HLTP3",134,0)
 ;I '$D(^HLMA("AC","I",HLDP,X)) L -^HLMA(X) Q
"RTN","HLTP3",135,0)
 Q:'$D(^HLMA("AC","I",HLDP,X))
"RTN","HLTP3",136,0)
 ;**109 END**
"RTN","HLTP3",137,0)
 ;
"RTN","HLTP3",138,0)
 N HL,HLA,HLD0,HLEID,HLEIDS,HLHDR,HLHDRO,HLMTIEN,HLMTIENS,HLJ,HLMSA,HLN,HLQUIT,HLNODE,HLNEXT,HLRESLT,HLRESLTA,HLTCP,HLXX,Z,HLDONE1
"RTN","HLTP3",139,0)
 ;setup variables
"RTN","HLTP3",140,0)
 S HLMTIENS=X,X=^HLMA(HLMTIENS,0),HLMTIEN=+$P(X,U),HL("MID")=$P(X,U,2),HL("MTIENS")=$P(X,U,10),HL("LL")=$P(X,U,7),HLTCP="",HL("Q")=""""""
"RTN","HLTP3",141,0)
 S HL("EIDS")=$P(X,U,8),HL("SAP")=$P(X,U,11),HL("RAP")=$P(X,U,12),HL("MTP")=$P(X,U,13),HL("ETP")=$P(X,U,14)
"RTN","HLTP3",142,0)
 S:$P(X,U,15) HL("MTP_ETP")=$P(X,U,15)
"RTN","HLTP3",143,0)
 S:HL("SAP") HL("SAN")=$P($G(^HL(771,HL("SAP"),0)),U) S:HL("RAP") HL("RAN")=$P($G(^HL(771,HL("RAP"),0)),U)
"RTN","HLTP3",144,0)
 S:HL("MTP") HL("MTN")=$P($G(^HL(771.2,HL("MTP"),0)),U) S:HL("ETP") HL("ETN")=$P($G(^HL(779.001,HL("ETP"),0)),U)
"RTN","HLTP3",145,0)
 S:$G(HL("MTP_ETP")) HL("MTN_ETN")=$P($G(^HL(779.005,HL("MTP_ETP"),0)),U)
"RTN","HLTP3",146,0)
 S HL("EID")=$P($G(^HL(772,HLMTIEN,0)),U,10)
"RTN","HLTP3",147,0)
 M HLHDRO=^HLMA(HLMTIENS,"MSH")
"RTN","HLTP3",148,0)
 ; if no header quit
"RTN","HLTP3",149,0)
 ;**109**
"RTN","HLTP3",150,0)
 ;I '$O(HLHDRO(0)) L -^HLMA(HLMTIENS) Q
"RTN","HLTP3",151,0)
 Q:'$O(HLHDRO(0))
"RTN","HLTP3",152,0)
 ;
"RTN","HLTP3",153,0)
 S HL("FS")=$E(HLHDRO(1,0),4),HL("ECH")=$$P^HLTPCK2(.HLHDRO,2),HL("SFN")=$$P^HLTPCK2(.HLHDRO,4),HL("RFN")=$$P^HLTPCK2(.HLHDRO,6),HL("DTM")=$$P^HLTPCK2(.HLHDRO,7)
"RTN","HLTP3",154,0)
 ;
"RTN","HLTP3",155,0)
 ; patch HL*1.6*109 start
"RTN","HLTP3",156,0)
 ; quit if ien of #772 is not defined
"RTN","HLTP3",157,0)
 Q:'HLMTIEN
"RTN","HLTP3",158,0)
 ; quit if field separator is not defined
"RTN","HLTP3",159,0)
 Q:HL("FS")=""
"RTN","HLTP3",160,0)
 ; quit if this is a commit ack
"RTN","HLTP3",161,0)
 Q:$P(^HL(772,HLMTIEN,"IN",1,0),HL("FS"),2)["C"
"RTN","HLTP3",162,0)
 ; patch HL*1.6*109 end
"RTN","HLTP3",163,0)
 ;
"RTN","HLTP3",164,0)
 S X=$$P^HLTPCK2(.HLHDRO,1)
"RTN","HLTP3",165,0)
 I X="MSH" S HL("PID")=$$P^HLTPCK2(.HLHDRO,11),HL("VER")=$$P^HLTPCK2(.HLHDRO,12),HL("APAT")=$$P^HLTPCK2(.HLHDRO,16),HL("CC")=$$P^HLTPCK2(.HLHDRO,17)
"RTN","HLTP3",166,0)
 I X'="MSH" D
"RTN","HLTP3",167,0)
 . S X=$$P^HLTPCK2(.HLHDRO,9),Z=$E(HL("ECH")),HL("PID")=$P(X,Z,2),HL("VER")=$P(X,Z,4)
"RTN","HLTP3",168,0)
 . Q:$$P^HLTPCK2(.HLHDRO,10)=""
"RTN","HLTP3",169,0)
 . ;HLMSA=ack code^id^text
"RTN","HLTP3",170,0)
 . S HLMSA=$P($$P^HLTPCK2(.HLHDRO,10),$E(HL("ECH")),1),$P(HLMSA,HL("FS"),2)=$$P^HLTPCK2(.HLHDRO,12),$P(HLMSA,HL("FS"),3)=$P($$P^HLTPCK2(.HLHDRO,10),$E(HL("ECH")),2),HL("MSAID")=$P(HLMSA,HL("FS"),2)
"RTN","HLTP3",171,0)
 ;Set up destination for 2-phase commit
"RTN","HLTP3",172,0)
 ;If facility data didn't come from 771
"RTN","HLTP3",173,0)
 I $G(HL("SAP")) D
"RTN","HLTP3",174,0)
 .N HLSF,HLINST,HLLINK,HLI
"RTN","HLTP3",175,0)
 .N HLDOMAIN    ; patch HL*1.6*109
"RTN","HLTP3",176,0)
 .S HLSF=$P(^HL(771,HL("SAP"),0),U,3)
"RTN","HLTP3",177,0)
 .Q:HLSF]""  ;application-defined facility
"RTN","HLTP3",178,0)
 . ; patch HL*1.6*109
"RTN","HLTP3",179,0)
 .S HLDOMAIN=$P(HL("SFN"),$E(HL("ECH")),2)
"RTN","HLTP3",180,0)
 .I HLDOMAIN]"" D
"RTN","HLTP3",181,0)
 .. D LINK^HLUTIL3(HLDOMAIN,.HLI,"D")
"RTN","HLTP3",182,0)
 .. S HLLINK=$O(HLI(0))
"RTN","HLTP3",183,0)
 .. I HLLINK S HLL("LINKS",1)="^"_HLLINK
"RTN","HLTP3",184,0)
 .Q:$G(HLLINK)
"RTN","HLTP3",185,0)
 .S HLINST=$P(HL("SFN"),$E(HL("ECH")))
"RTN","HLTP3",186,0)
 .Q:HLINST']""
"RTN","HLTP3",187,0)
 .D LINK^HLUTIL3(HLINST,.HLI,"I")
"RTN","HLTP3",188,0)
 .S HLLINK=$O(HLI(0))
"RTN","HLTP3",189,0)
 .Q:'HLLINK
"RTN","HLTP3",190,0)
 . ; patch HL*1.6*109 end
"RTN","HLTP3",191,0)
 . ;
"RTN","HLTP3",192,0)
 .S HLL("LINKS",1)="^"_HLLINK
"RTN","HLTP3",193,0)
 D CONT
"RTN","HLTP3",194,0)
 Q
"RTN","HLTP3",195,0)
 ;
"RTN","HLTP3",196,0)
MSA(Y) ;Y=ien in 772, returns MSA segment
"RTN","HLTP3",197,0)
 ;ack code^msg being ack id^text
"RTN","HLTP3",198,0)
 N X
"RTN","HLTP3",199,0)
 S X=$G(^HL(772,Y,"IN",1,0)),X=$S($E(X,1,3)="MSA":$E(X,5,999),1:"")
"RTN","HLTP3",200,0)
 Q X
"RTN","HLTP3",201,0)
 ;
"RTN","HLTP3",202,0)
ERROR ;error trap
"RTN","HLTP3",203,0)
 D ^%ZTER
"RTN","HLTP3",204,0)
 I $G(HLMTIENS),$D(^HLMA(HLMTIENS,0)) D STATUS^HLTF0(HLMTIENS,4,,,1),EXIT
"RTN","HLTP3",205,0)
 ;*109* release all locks created by inbound filer
"RTN","HLTP3",206,0)
 L -^HLMA("AC","I",+$G(HLXX),+$G(HLD0))
"RTN","HLTP3",207,0)
 L -^HLMA(+$G(HLMTIENS))
"RTN","HLTP3",208,0)
 L -^XTMP("HL7-AC","I",+$G(HLXX))
"RTN","HLTP3",209,0)
 L -^HLMA("AC","I",+$G(HLXX))
"RTN","HLTP3",210,0)
 G UNWIND^%ZTER
"RTN","HLTP3",211,0)
 ;
"RTN","HLTP3",212,0)
CHECKAC(WAY,IEN870,IEN773) ; If AC xref shouldn't exist, kill it...
"RTN","HLTP3",213,0)
 ;
"RTN","HLTP3",214,0)
 ; Check status and if 3 (processed) kill XREF...
"RTN","HLTP3",215,0)
 I $P($G(^HLMA(+IEN773,"P")),U)=3 D  QUIT "" ;->
"RTN","HLTP3",216,0)
 .  D DEQUE^HLCSREP(IEN870,WAY,IEN773)
"RTN","HLTP3",217,0)
 ;
"RTN","HLTP3",218,0)
 ; Add other checks here in the future...
"RTN","HLTP3",219,0)
 ;
"RTN","HLTP3",220,0)
 Q 1
"RTN","HLTP3",221,0)
 ;
"RTN","HLTP3",222,0)
EXIT ;unlock
"RTN","HLTP3",223,0)
 I $G(HLMTIENS) L -^HLMA(HLMTIENS)
"RTN","HLTP3",224,0)
 Q
"RTN","HLTP3",225,0)
 ;
"RTN","HLTP3",226,0)
ONAC(IEN773) ;
"RTN","HLTP3",227,0)
 ;Returns 1 if the message is on the "AC","I" xref
"RTN","HLTP3",228,0)
 ;Returns 0 otherwise
"RTN","HLTP3",229,0)
 ;
"RTN","HLTP3",230,0)
 N LINK
"RTN","HLTP3",231,0)
 S LINK=$P($G(^HLMA(IEN773,0)),"^",17)
"RTN","HLTP3",232,0)
 Q:'LINK 0
"RTN","HLTP3",233,0)
 Q $D(^HLMA("AC","I",LINK,IEN773))
"RTN","HLTP31")
0^83^B7900636
"RTN","HLTP31",1,0)
HLTP31 ;SFIRMFO/RSD - Cont. Transaction Processor for TCP ;10/24/2003  16:57
"RTN","HLTP31",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**57,58,66,109**;Oct 13, 1995
"RTN","HLTP31",3,0)
 ;
"RTN","HLTP31",4,0)
 Q
"RTN","HLTP31",5,0)
RSP(X,HLN) ;process response msg. X=ien in 773^msg. ien in 772
"RTN","HLTP31",6,0)
 ;HLN=HL array for original message
"RTN","HLTP31",7,0)
 ;HLMTIEN=ien in 772,  HLMTIENS=ien in 773
"RTN","HLTP31",8,0)
 ;returns - 0=resend msg, 1=commit ack, 3=app ack success, 4=error
"RTN","HLTP31",9,0)
 ;set error trap
"RTN","HLTP31",10,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP31",11,0)
 N HLERR,HLHDR,HLMSA,HLMTIEN,HLMTIENS,HLQUIT,HLNODE,HLNEXT,HLRESLTA
"RTN","HLTP31",12,0)
 D INIT^HLTP3A  ;patch HL*1.6*109: hltp3 routine split
"RTN","HLTP31",13,0)
 ;Quit processing if error with header
"RTN","HLTP31",14,0)
 I $G(HLRESLT) D EXIT Q 0
"RTN","HLTP31",15,0)
 ;must have MSA segment
"RTN","HLTP31",16,0)
 I '$L(HLMSA) D RSPER(4,108,"Missing MSA segment") Q 0
"RTN","HLTP31",17,0)
 ;msg. id in MSA must match original msg. id, if not reject
"RTN","HLTP31",18,0)
 I $P(HLMSA,HL("FS"),2)'=HLN("MID") D RSPER(4,108,"Incorrect msg. Id") Q 0
"RTN","HLTP31",19,0)
 ;rec. app. must match sending app. of original message.
"RTN","HLTP31",20,0)
 I HL("RAN")'=HLN("SAN") D RSPER(4,108,"Incorrect sending app.") Q 0
"RTN","HLTP31",21,0)
 ;get ack code
"RTN","HLTP31",22,0)
 S HL("ACKCD")=$P(HLMSA,HL("FS"))
"RTN","HLTP31",23,0)
 ;update LL, rec. 1 msg
"RTN","HLTP31",24,0)
 D LLCNT^HLCSTCP(HLDP,1)
"RTN","HLTP31",25,0)
 ;commit ack
"RTN","HLTP31",26,0)
 I $E(HL("ACKCD"))="C" D  Q X
"RTN","HLTP31",27,0)
 . ;update LL, processed 1 msg
"RTN","HLTP31",28,0)
 . D LLCNT^HLCSTCP(HLDP,2)
"RTN","HLTP31",29,0)
 . ;received an error ack, return NAK
"RTN","HLTP31",30,0)
 . S:$E(HL("ACKCD"),2)'="A" HLRESLT=102_U_$P(HLMSA,HL("FS"),3)
"RTN","HLTP31",31,0)
 . D RSPER(3) S X=$S($E(HL("ACKCD"),2)="A":1,1:4)
"RTN","HLTP31",32,0)
 ;app. ack, received an error ack, NAK
"RTN","HLTP31",33,0)
 S:$E(HL("ACKCD"),2)'="A" HLRESLT=102_U_$P(HLMSA,HL("FS"),3)
"RTN","HLTP31",34,0)
 ;Set special HL variables
"RTN","HLTP31",35,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLTP31",36,0)
 ;HLORNOD=subscriber protocol for Fileman auditing, ien;global ref
"RTN","HLTP31",37,0)
 N HLORNODD S HLORNOD=HL("EIDS")_";ORD(101,"
"RTN","HLTP31",38,0)
 ;process ack
"RTN","HLTP31",39,0)
 D
"RTN","HLTP31",40,0)
 . N HLTCP ;Newed variable to update status in 772.
"RTN","HLTP31",41,0)
 . D PROCACK^HLTP2(HLMTIEN,HL("EID"),.HLRESLT,.HL)
"RTN","HLTP31",42,0)
 ;update LL, processed 1 msg
"RTN","HLTP31",43,0)
 D LLCNT^HLCSTCP(HLDP,2)
"RTN","HLTP31",44,0)
 ;process ack successfully
"RTN","HLTP31",45,0)
 D RSPER(3)
"RTN","HLTP31",46,0)
 ;HLRESELT is defined for errors
"RTN","HLTP31",47,0)
 Q $S($G(HLRESLT):4,1:3)
"RTN","HLTP31",48,0)
 ;
"RTN","HLTP31",49,0)
RSPER(HLST,HLER,HLERM) ;HLST=status, HLER=error type, HLERM=error msg.
"RTN","HLTP31",50,0)
 D STATUS^HLTF0(HLMTIENS,HLST,$G(HLER),$G(HLERM),1)
"RTN","HLTP31",51,0)
 S:$G(HLER) HLRESLT=HLER_U_HLERM
"RTN","HLTP31",52,0)
 D EXIT
"RTN","HLTP31",53,0)
 Q
"RTN","HLTP31",54,0)
EXIT ;unlock
"RTN","HLTP31",55,0)
 ;**109**
"RTN","HLTP31",56,0)
 ;I $G(HLMTIENS) L -^HLMA(HLMTIENS)
"RTN","HLTP31",57,0)
 Q
"RTN","HLTP31",58,0)
 ;
"RTN","HLTP31",59,0)
SETINQUE ;
"RTN","HLTP31",60,0)
 ;**HL*1.6*109***
"RTN","HLTP31",61,0)
 ;Called from HLTP3 for message that utilize enhanced mode - NOT original mode
"RTN","HLTP31",62,0)
 ;Sets the incoming message on the in queue.
"RTN","HLTP31",63,0)
 ;Does not use the listener, instead, arranges multiple in-queues
"RTN","HLTP31",64,0)
 ;by using the sending link.
"RTN","HLTP31",65,0)
 ;
"RTN","HLTP31",66,0)
 N HLI,HLINST,HLDOMAIN,HLLINK
"RTN","HLTP31",67,0)
 ;
"RTN","HLTP31",68,0)
 ;Override value of logical link based on sending facility to create
"RTN","HLTP31",69,0)
 ;a queue (^HLMA("AC","I",llnk ien,msg ien)) different than that of the 
"RTN","HLTP31",70,0)
 ;listener
"RTN","HLTP31",71,0)
 S HLINST=$P(HL("SFN"),$E(HL("ECH")))
"RTN","HLTP31",72,0)
 S HLDOMAIN=$P(HL("SFN"),$E(HL("ECH")),2)
"RTN","HLTP31",73,0)
 I HLDOMAIN]"" D    ;logical link lookup by domain
"RTN","HLTP31",74,0)
 . D LINK^HLUTIL3(HLDOMAIN,.HLI,"D")
"RTN","HLTP31",75,0)
 . S HLLINK=$O(HLI(0)) ;client link for sending facility
"RTN","HLTP31",76,0)
 ;logical link lookup by station number
"RTN","HLTP31",77,0)
 I $G(HLLINK)']"",HLINST]"" D
"RTN","HLTP31",78,0)
 . D LINK^HLUTIL3(HLINST,.HLI,"I")
"RTN","HLTP31",79,0)
 . S HLLINK=$O(HLI(0)) ;client link for sending facility
"RTN","HLTP31",80,0)
 ;
"RTN","HLTP31",81,0)
 ; find the logical link of the subscriber protocol
"RTN","HLTP31",82,0)
 ; then set the link field of this message to the link
"RTN","HLTP31",83,0)
 I $G(HL("EIDS")),$P(^ORD(101,HL("EIDS"),770),"^",7) S HLLINK=$P(^ORD(101,HL("EIDS"),770),"^",7)
"RTN","HLTP31",84,0)
 ;
"RTN","HLTP31",85,0)
 I $L($G(HLLINK)) D
"RTN","HLTP31",86,0)
 .D ENQUE^HLCSREP(HLLINK,"I",HLMTIENS)
"RTN","HLTP31",87,0)
 E  D
"RTN","HLTP31",88,0)
 .D ENQUE^HLCSREP(HLDP,"I",HLMTIENS)
"RTN","HLTP31",89,0)
 Q
"RTN","HLTP3A")
0^84^B2301375
"RTN","HLTP3A",1,0)
HLTP3A ;SFIRMFO/RSD - Transaction Processor for TCP- INIT ;11/19/2003  13:57
"RTN","HLTP3A",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLTP3A",3,0)
 ;
"RTN","HLTP3A",4,0)
 ;split from hltp3
"RTN","HLTP3A",5,0)
 Q
"RTN","HLTP3A",6,0)
INIT ;initialize variables, get MSA & header, returns HLRESLT if error
"RTN","HLTP3A",7,0)
 N HLJ
"RTN","HLTP3A",8,0)
 ;
"RTN","HLTP3A",9,0)
 K HLRESLT,HL
"RTN","HLTP3A",10,0)
 S HLMTIENS=+X,HLMTIEN=+$P(X,U,2),HLMSA=$$MSA^HLTP3(HLMTIEN)
"RTN","HLTP3A",11,0)
 ;
"RTN","HLTP3A",12,0)
 ;get header and validate
"RTN","HLTP3A",13,0)
 M HLHDRO=^HLMA(HLMTIENS,"MSH")
"RTN","HLTP3A",14,0)
 ;HLMSA is by ref., for a batch msg HLMSA will be setup in HLTPCK2
"RTN","HLTP3A",15,0)
 D CHK^HLTPCK2(.HLHDRO,.HL,.HLMSA)
"RTN","HLTP3A",16,0)
 ;Update Message Administration file #773, for incoming message
"RTN","HLTP3A",17,0)
 ;3=trans type, 20=status
"RTN","HLTP3A",18,0)
 K HLJ
"RTN","HLTP3A",19,0)
 S X="HLJ(773,"""_HLMTIENS_","")",@X@(3)="I",@X@(20)=9
"RTN","HLTP3A",20,0)
 ;HL=error #^error text, 21=date process, 22=error msg, 23=error type
"RTN","HLTP3A",21,0)
 S:$G(HL) @X@(20)=4,@X@(21)=$$NOW^XLFDT,@X@(22)=$P(HL,U,2),@X@(23)=+HL
"RTN","HLTP3A",22,0)
 ;8=protocol, 13=sending app
"RTN","HLTP3A",23,0)
 S:$G(HL("EIDS")) @X@(8)=HL("EIDS") S:$G(HL("SAP")) @X@(13)=HL("SAP")
"RTN","HLTP3A",24,0)
 ;14=receiving app, 12=acknowledgement to
"RTN","HLTP3A",25,0)
 S:$G(HL("RAP")) @X@(14)=HL("RAP") S:$G(HL("MTIENS")) @X@(12)=HL("MTIENS")
"RTN","HLTP3A",26,0)
 ;6=initial message, 7=logical link
"RTN","HLTP3A",27,0)
 S:$G(HLTCPI) @X@(6)=HLTCPI S @X@(7)=HLDP
"RTN","HLTP3A",28,0)
 ;
"RTN","HLTP3A",29,0)
 ;15=message type, 16=event type
"RTN","HLTP3A",30,0)
 S:$G(HL("MTP")) @X@(15)=HL("MTP") S:$G(HL("ETP")) @X@(16)=HL("ETP")
"RTN","HLTP3A",31,0)
 ;HL*1.6*109 S:$G(HL("MTP_ETP")) @X@(17)=HL("MTP_ETP")
"RTN","HLTP3A",32,0)
 D FILE^HLDIE("","HLJ","","INIT-1","HLTP3A") ;HL*1.6*109
"RTN","HLTP3A",33,0)
 ;Update Message Text file #772
"RTN","HLTP3A",34,0)
 ;4=trans type
"RTN","HLTP3A",35,0)
 K HLJ S X="HLJ(772,"""_HLMTIEN_","")",@X@(4)="I"
"RTN","HLTP3A",36,0)
 ;10=event protocol
"RTN","HLTP3A",37,0)
 S:$G(HL("EID")) @X@(10)=HL("EID")
"RTN","HLTP3A",38,0)
 D FILE^HLDIE("","HLJ","","INIT-2","HLTP3A") ; HL*1.6*109
"RTN","HLTP3A",39,0)
 ;set HLRESLT to error
"RTN","HLTP3A",40,0)
 S:HL'="" HLRESLT=HL
"RTN","HLTP3A",41,0)
 Q
"RTN","HLTP4")
0^88^B24967834
"RTN","HLTP4",1,0)
HLTP4 ;SFIRMFO/RSD - Transaction Processor for TCP ;03/07/2000  17:41
"RTN","HLTP4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,57,59,91,109**;Oct 13, 1995
"RTN","HLTP4",3,0)
GENACK ;called from HLMA1
"RTN","HLTP4",4,0)
 ;Entry point to generate an acknowledgement message
"RTN","HLTP4",5,0)
 ;for TCP
"RTN","HLTP4",6,0)
 ;INPUT:
"RTN","HLTP4",7,0)
 ;   HLMTIENS=original msg. ien #773
"RTN","HLTP4",8,0)
 ;   HLEID=original msg. event protocol
"RTN","HLTP4",9,0)
 ;   HLEIDS=original msg. subscriber protocol
"RTN","HLTP4",10,0)
 ;   HLMTIENA=ien of ack in 772, for batch only
"RTN","HLTP4",11,0)
 ;   Note:  if the HLP(...) array exists, it will be "honored" by
"RTN","HLTP4",12,0)
 ;          UPDATE^HLTF0 below. This includes the HLP("NAMESPACE")
"RTN","HLTP4",13,0)
 ;          variable. - HL*1.6*91
"RTN","HLTP4",14,0)
 ;
"RTN","HLTP4",15,0)
 ;OUTPUT: HLTCP=ien of response
"RTN","HLTP4",16,0)
 N HLDT,HLDT1,HLQ,HLOGLINK,HLMIDA,HLMTIEN,HLREC,HLSAN,HLTYPE,X
"RTN","HLTP4",17,0)
 ;Extract data from original message and store in separate variables
"RTN","HLTP4",18,0)
 ;reverse sending and receiving application from original msg.
"RTN","HLTP4",19,0)
 S X=$G(^HLMA(HLMTIENS,0)),HLREC=$P(X,U,11),HLSAN=$P(X,U,12),HLOGLINK=$G(HLTCPO)
"RTN","HLTP4",20,0)
 ;HLMTIENA defined, create msg in 773
"RTN","HLTP4",21,0)
 I $G(HLMTIENA) S HLDT=+$G(^HL(772,HLMTIENA,0)),HLMTIENA=$$MA^HLTF(HLMTIENA,.HLMIDA)
"RTN","HLTP4",22,0)
 ;create message in 772 & 773, HLMTIENA=new msg ien #773
"RTN","HLTP4",23,0)
 I '$G(HLMTIENA) D TCP^HLTF(.HLMIDA,.HLMTIENA,.HLDT)
"RTN","HLTP4",24,0)
 ;
"RTN","HLTP4",25,0)
 ;**109**
"RTN","HLTP4",26,0)
 ;lock new record
"RTN","HLTP4",27,0)
 ;F  L +^HLMA(HLMTIENA):1 Q:$T  H 1
"RTN","HLTP4",28,0)
 ;
"RTN","HLTP4",29,0)
 ;HLMTIEN=ien in 772
"RTN","HLTP4",30,0)
 S HLTCP=HLMTIENA,HLMTIEN=+^HLMA(HLMTIENA,0),HLDT1=$$HLDATE^HLFNC(HLDT),(HLTYPE,HLP("MSGTYPE"))=$E(HLARYTYP,2)
"RTN","HLTP4",31,0)
 ;no open link, check dynamic routing of ack
"RTN","HLTP4",32,0)
 I 'HLOGLINK,$D(HLL("LINKS")) D  Q:'HLOGLINK
"RTN","HLTP4",33,0)
 . S HLOGLINK=$P(HLL("LINKS",1),"^",2) Q:HLOGLINK=""
"RTN","HLTP4",34,0)
 . I +HLOGLINK'=HLOGLINK S HLOGLINK=$O(^HLCS(870,"B",HLOGLINK,0))
"RTN","HLTP4",35,0)
 . K HLL("LINKS")
"RTN","HLTP4",36,0)
 ;get message type and event type from protocol
"RTN","HLTP4",37,0)
 S X=$G(^ORD(101,HLEIDS,770)),HLP("MTYPE")=$P(X,U,11),HLP("EVENT")=$P(X,U,4) S:'HLOGLINK HLOGLINK=$P(X,U,7)
"RTN","HLTP4",38,0)
 S:$P(X,U,5) HLP("MTYPE_EVENT")=$P(X,U,5)
"RTN","HLTP4",39,0)
 ;HLTCPI=initial message
"RTN","HLTP4",40,0)
 S:$G(HLTCPI) HLP("HLTCPI")=HLTCPI
"RTN","HLTP4",41,0)
 ;Update zero node of Message Admin file #773
"RTN","HLTP4",42,0)
 D UPDATE^HLTF0(HLTCP,,"O",HLEIDS,HLREC,HLSAN,"I",HLMTIENS,HLOGLINK,.HLP)
"RTN","HLTP4",43,0)
 ;
"RTN","HLTP4",44,0)
 ;Update status to Being Generated
"RTN","HLTP4",45,0)
 D STATUS^HLTF0(HLTCP,8)
"RTN","HLTP4",46,0)
 ;
"RTN","HLTP4",47,0)
 ;**109**
"RTN","HLTP4",48,0)
 ;tcp link is open, don't need x-ref, msg will be sent over link
"RTN","HLTP4",49,0)
 ;I $G(HLTCPO) K ^HLMA("AC","O",HLOGLINK,HLTCP)
"RTN","HLTP4",50,0)
 ;
"RTN","HLTP4",51,0)
 ;update zero node of Message Text file #772
"RTN","HLTP4",52,0)
 D
"RTN","HLTP4",53,0)
 . N HLTCP D UPDATE^HLTF0(HLMTIEN,,"O",HLEID)
"RTN","HLTP4",54,0)
 ;
"RTN","HLTP4",55,0)
 ;Execute entry action for subscriber protocol
"RTN","HLTP4",56,0)
 I HLENROU]"" X HLENROU
"RTN","HLTP4",57,0)
 S HLQ=""""
"RTN","HLTP4",58,0)
 ;Check that local/global array exists and store in Message Text file
"RTN","HLTP4",59,0)
 ; if pre-compiled
"RTN","HLTP4",60,0)
 I HLFORMAT D  I (+$G(HLRESLTA)) D STATUS^HLTF0(HLMTIENA,4,+HLRESLTA) G ERR
"RTN","HLTP4",61,0)
 . I $E(HLARYTYP)="G" D
"RTN","HLTP4",62,0)
 .. I $O(^TMP("HLA",$J,0))']"" S HLRESLTA="8^"_$G(^HL(771.7,8,0)) Q
"RTN","HLTP4",63,0)
 .. D MERGE^HLTF1("G",HLMTIEN,"HLA")
"RTN","HLTP4",64,0)
 . I $E(HLARYTYP)="L" D
"RTN","HLTP4",65,0)
 .. I $O(HLA("HLA",0))']"" S HLRESLTA="8^"_$G(^HL(771.7,8,0)) Q
"RTN","HLTP4",66,0)
 .. D MERGE^HLTF1("L",HLMTIEN,"HLA")
"RTN","HLTP4",67,0)
 ;If array is not pre-compiled, call message generation routine
"RTN","HLTP4",68,0)
 I 'HLFORMAT N HLERR D  I $D(HLERR) S HLRESLTA="9^"_HLERR D STATUS^HLTF0(HLMTIENA,4,9,HLERR) G ERR
"RTN","HLTP4",69,0)
 .S HLP("GROUTINE")=HLP("GROUTINE")_"("_HLMIDA_","_HLMTIENA_","_HLQ_HLARYTYP_HLQ_","_HLSAN_","_$P($G(^HL(771.2,$P(HLN(770),"^",3),0)),"^")_","_$P($G(^HL(779.001,$P(HLN(770),"^",4),0)),"^")_","_HLQ_$TR($P(HLN(770),"^",6),"id","ID")_HLQ_")"
"RTN","HLTP4",70,0)
 .X HLP("GROUTINE")
"RTN","HLTP4",71,0)
 ;
"RTN","HLTP4",72,0)
 ;create header for message in 773
"RTN","HLTP4",73,0)
 I (HLTYPE="M") D HEADER^HLCSHDR1(HLTCP,HLREC,.HLRESLT)
"RTN","HLTP4",74,0)
 I (HLTYPE'="M") D BHSHDR^HLCSHDR1(HLTCP,HLREC,.HLRESLT)
"RTN","HLTP4",75,0)
 ;if error set status to ERROR DURING TRANSMISSION
"RTN","HLTP4",76,0)
 I ($G(HLRESLT)'="") D STATUS^HLTF0(HLTCP,4,12,HLRESLT) G ERR
"RTN","HLTP4",77,0)
 ;set header, HLHDR in 773
"RTN","HLTP4",78,0)
 K HLQ S X=HLTCP_",",HLQ(773,X,200)="HLHDR"
"RTN","HLTP4",79,0)
 D FILE^HLDIE("","HLQ","","GENACK","HLTP4") ;HL*1.6*109
"RTN","HLTP4",80,0)
 ;D FILE^DIE("","HLQ")
"RTN","HLTP4",81,0)
 ;update status of 773 to PENDING TRANSMISSION
"RTN","HLTP4",82,0)
 D STATUS^HLTF0(HLTCP,1)
"RTN","HLTP4",83,0)
 ;Execute exit action for subscriber protocol
"RTN","HLTP4",84,0)
 X:HLEXROU]"" HLEXROU
"RTN","HLTP4",85,0)
 ;
"RTN","HLTP4",86,0)
 ;**109**
"RTN","HLTP4",87,0)
 ;tcp link is NOT open, need x-ref
"RTN","HLTP4",88,0)
 I '$G(HLTCPO) D ENQUE^HLCSREP(HLOGLINK,"O",HLTCP)
"RTN","HLTP4",89,0)
 ;
"RTN","HLTP4",90,0)
EXIT ;**109**
"RTN","HLTP4",91,0)
 ;L -^HLMA(HLMTIENA)
"RTN","HLTP4",92,0)
 Q
"RTN","HLTP4",93,0)
ERR D EXIT S HLTCP=""
"RTN","HLTP4",94,0)
 S:$G(HLRESLT) HLRESLTA=$G(HLRESLTA)_"^"_HLRESLT
"RTN","HLTP4",95,0)
 Q
"RTN","HLTP4",96,0)
ACK(HLTACK,HLMG) ;build response based on original msg header
"RTN","HLTP4",97,0)
 ;for Bi-directional TCP
"RTN","HLTP4",98,0)
 ;INPUT:
"RTN","HLTP4",99,0)
 ;   HLTACK=type of ack. CA,CR, or AR
"RTN","HLTP4",100,0)
 ;   HLMG=text for MSA segment
"RTN","HLTP4",101,0)
 ;   HLMTIENS=original msg. ien #773
"RTN","HLTP4",102,0)
 ;   HL(array) from original header
"RTN","HLTP4",103,0)
 ;RETURNS:  HLTCP=ien of response msg. in 773
"RTN","HLTP4",104,0)
 N HLDT,HLDT1,HLQ,HLFS,HLHDR,HLMIDA,HLMTIEN,HLMTIENA,HLP,HLREC,HLSAN,X
"RTN","HLTP4",105,0)
 ;quit if we don't have enough to make a msg.
"RTN","HLTP4",106,0)
 I $G(HL("ECH"))=""!($G(HL("FS"))="")!($G(HL("TYPE"))="") Q
"RTN","HLTP4",107,0)
 ;Extract data from original message and store in separate variables
"RTN","HLTP4",108,0)
 ;reverse sending and receiving application from original msg.
"RTN","HLTP4",109,0)
 S HLFS=HL("FS"),HLREC=$G(HL("SAN")),HLSAN=$G(HL("RAN"))
"RTN","HLTP4",110,0)
 ;create message in 772 & 773, HLMTIENA=new msg ien #773
"RTN","HLTP4",111,0)
 D TCP^HLTF(.HLMIDA,.HLMTIENA,.HLDT)
"RTN","HLTP4",112,0)
 ;lock new record
"RTN","HLTP4",113,0)
 ;**109**
"RTN","HLTP4",114,0)
 ;F  L +^HLMA(HLMTIENA):1 Q:$T  H 1
"RTN","HLTP4",115,0)
 ;
"RTN","HLTP4",116,0)
 ;HLMTIEN=ien in 772
"RTN","HLTP4",117,0)
 S HLTCP=HLMTIENA,HLMTIEN=+^HLMA(HLMTIENA,0),HLDT1=$$FMTHL7^XLFDT(HLDT)
"RTN","HLTP4",118,0)
 ;get 'msgtype'=B or M, message type and event type
"RTN","HLTP4",119,0)
 S HLP("MSGTYPE")=$E(HL("TYPE")),HLP("MTYPE")=$G(HL("MTP")),HLP("EVENT")=$G(HL("ETP")),HLP("HLTCPI")=HLMTIENS
"RTN","HLTP4",120,0)
 S:$G(HL("MTP_ETP")) HLP("MTYPE_EVENT")=$G(HL("MTP_ETP"))
"RTN","HLTP4",121,0)
 ;Update zero node of Message Admin file #773
"RTN","HLTP4",122,0)
 D UPDATE^HLTF0(HLTCP,,"O",,HLREC,HLSAN,"I",HLMTIENS,HLDP,.HLP)
"RTN","HLTP4",123,0)
 ;
"RTN","HLTP4",124,0)
 ;don't need x-ref, msg will be sent back over open tcp link
"RTN","HLTP4",125,0)
 ;**109**
"RTN","HLTP4",126,0)
 D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP4",127,0)
 ;K ^HLMA("AC","O",HLDP,HLTCP)
"RTN","HLTP4",128,0)
 ;
"RTN","HLTP4",129,0)
 ;Update status to Being Generated
"RTN","HLTP4",130,0)
 D STATUS^HLTF0(HLTCP,8)
"RTN","HLTP4",131,0)
 ;update zero node of Message Text file #772
"RTN","HLTP4",132,0)
 D
"RTN","HLTP4",133,0)
 . N HLTCP D UPDATE^HLTF0(HLMTIEN,,"O")
"RTN","HLTP4",134,0)
 ;
"RTN","HLTP4",135,0)
 ;build MSA segment
"RTN","HLTP4",136,0)
 K HLA
"RTN","HLTP4",137,0)
 S HLA("HLS",1)="MSA"_HLFS_HLTACK_HLFS_$G(HL("MID"))
"RTN","HLTP4",138,0)
 S:$G(HLMG)]"" HLA("HLS",1)=HLA("HLS",1)_HLFS_HLMG
"RTN","HLTP4",139,0)
 ;update file 772 with msg text
"RTN","HLTP4",140,0)
 D MERGE^HLTF1("L",HLMTIEN,"HLS")
"RTN","HLTP4",141,0)
 D HDR
"RTN","HLTP4",142,0)
 ;update file 773 with msg header
"RTN","HLTP4",143,0)
 K HLQ S HLQ(773,HLTCP_",",200)="HLHDR"
"RTN","HLTP4",144,0)
 D FILE^HLDIE("","HLQ","","ACK","HLTP4") ; HL*1.6*109
"RTN","HLTP4",145,0)
 ;D FILE^DIE("","HLQ")
"RTN","HLTP4",146,0)
 G EXIT
"RTN","HLTP4",147,0)
 ;
"RTN","HLTP4",148,0)
HDR ; build header for commit ack
"RTN","HLTP4",149,0)
 K HLHDR
"RTN","HLTP4",150,0)
 S HLHDR(1)=HL("TYPE")_HLFS_HL("ECH")_HLFS_HLSAN_HLFS_$G(HL("RFN"))_HLFS_HLREC_HLFS_$G(HL("SFN"))_HLFS_HLDT1_HLFS_HLFS
"RTN","HLTP4",151,0)
 I HLP("MSGTYPE")="M" S HLHDR(1)=HLHDR(1)_"ACK"_HLFS_HLMIDA_HLFS_$G(HL("PID"))_HLFS_$G(HL("VER")) Q
"RTN","HLTP4",152,0)
 ;batch
"RTN","HLTP4",153,0)
 S X=$E(HL("ECH"))
"RTN","HLTP4",154,0)
 S HLHDR(1)=HLHDR(1)_X_$G(HL("PID"))_X_"ACK"_HLFS_HLTACK_HLFS_HLMIDA_HLFS_$G(HL("MID"))
"RTN","HLTP4",155,0)
 Q
"RTN","HLUOPT1")
0^1^B57282446
"RTN","HLUOPT1",1,0)
HLUOPT1 ;AISC/SAW - Purging Entries in file #772 and #773 ;02/04/2004  09:58
"RTN","HLUOPT1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**10,13,21,36,19,47,62,109**;Oct 13, 1995
"RTN","HLUOPT1",3,0)
 ;
"RTN","HLUOPT1",4,0)
 ; Purge data of the HL7 message in file #772 and #773.
"RTN","HLUOPT1",5,0)
 ;
"RTN","HLUOPT1",6,0)
 ; Patch 47 - For Purging Option scheduled on a recurring basis,
"RTN","HLUOPT1",7,0)
 ; numbers of days kept for various Status of message are stored
"RTN","HLUOPT1",8,0)
 ; in file #869.3, fields 41, 42, and 43.  Default values for these
"RTN","HLUOPT1",9,0)
 ; fields are 7, 30, and 90, respectively.
"RTN","HLUOPT1",10,0)
 ;
"RTN","HLUOPT1",11,0)
 ; Patch 36 - a message will never be purged if the new field, "Don't
"RTN","HLUOPT1",12,0)
 ; Purge" (#772,15), is set to 1.
"RTN","HLUOPT1",13,0)
 ;
"RTN","HLUOPT1",14,0)
PURGE ;
"RTN","HLUOPT1",15,0)
 ; HLPDT("COMP") - 'completed' status cutoff date
"RTN","HLUOPT1",16,0)
 ; HLPDT("WAIT") - 'awaiting ack' status cutoff date
"RTN","HLUOPT1",17,0)
 ; HLPDT("ERR")  - 'error' status cutoff date
"RTN","HLUOPT1",18,0)
 ;                 (=0 means don't delete msgs in 'error' status)
"RTN","HLUOPT1",19,0)
 ; HLPDT("ALL")  - all other status (except 'error') cutoff date
"RTN","HLUOPT1",20,0)
 N HLPDT,HLTASK,HLEXIT
"RTN","HLUOPT1",21,0)
 ;
"RTN","HLUOPT1",22,0)
 S (HLTASK,HLEXIT)=0
"RTN","HLUOPT1",23,0)
 D INIT(.HLPDT,.HLTASK,.HLEXIT) Q:HLEXIT
"RTN","HLUOPT1",24,0)
 ;
"RTN","HLUOPT1",25,0)
 ; HL*1.6*109 lock logic...
"RTN","HLUOPT1",26,0)
 L +^HL("HLUOPT1"):2 I '$T D:'$D(ZTQUEUED) LOCKTELL^HLUOPT4 QUIT  ;->
"RTN","HLUOPT1",27,0)
 L -^HL("HLUOPT1") ; Locked again at the top of DQ
"RTN","HLUOPT1",28,0)
 ;
"RTN","HLUOPT1",29,0)
 ; HL*1.6*109
"RTN","HLUOPT1",30,0)
 I '$D(ZTQUEUED) I $$BTE^HLCSMON("Press RETURN to "_$S(HLTASK:"queue job",1:"start purging")_", or enter '^' to exit... ",1) D  QUIT  ;->
"RTN","HLUOPT1",31,0)
 .  I HLTASK W "  no task started..."
"RTN","HLUOPT1",32,0)
 .  I 'HLTASK W "  exiting..."
"RTN","HLUOPT1",33,0)
 ;
"RTN","HLUOPT1",34,0)
 I HLTASK D TASKIT Q
"RTN","HLUOPT1",35,0)
 K HLTASK,HLEXIT ; not needed
"RTN","HLUOPT1",36,0)
 D DQ
"RTN","HLUOPT1",37,0)
 ;
"RTN","HLUOPT1",38,0)
 Q
"RTN","HLUOPT1",39,0)
 ;
"RTN","HLUOPT1",40,0)
INIT(HLPDT,HLTASK,HLEXIT) ; Get data from file #869.3
"RTN","HLUOPT1",41,0)
 D INIT^HLUOPT4 ; HL*1.6*109
"RTN","HLUOPT1",42,0)
 Q
"RTN","HLUOPT1",43,0)
 ;
"RTN","HLUOPT1",44,0)
TASKIT ; Queue task to run in the background
"RTN","HLUOPT1",45,0)
 N ZTDESC,ZTDTH,ZTIO,ZTRTN,ZTSAVE
"RTN","HLUOPT1",46,0)
 S ZTRTN="DQ^HLUOPT1",ZTIO="",ZTSAVE("HLPDT(")="",ZTDTH=$H
"RTN","HLUOPT1",47,0)
 S ZTDESC="Purge HL7 message text on or before "_$$FMTE^XLFDT(HLPDT("COMP"),"5D")
"RTN","HLUOPT1",48,0)
 D ^%ZTLOAD
"RTN","HLUOPT1",49,0)
 I $D(ZTSK) W !,"  Task #",ZTSK," queued to run now...",! Q  ; HL*1.6*109
"RTN","HLUOPT1",50,0)
 W !,"  Queuing of Purge task failed.",! ; HL*1.6*109
"RTN","HLUOPT1",51,0)
 Q
"RTN","HLUOPT1",52,0)
DQ ; Entry point for running purge of HL7 message text
"RTN","HLUOPT1",53,0)
 N HLDELCNT,HLEXIT,HLOOPCT
"RTN","HLUOPT1",54,0)
 ;
"RTN","HLUOPT1",55,0)
 S HLOOPCT=0
"RTN","HLUOPT1",56,0)
 ;
"RTN","HLUOPT1",57,0)
 ; HL*1.6*109
"RTN","HLUOPT1",58,0)
 N XTMP D XTMPBEGN^HLUOPT4
"RTN","HLUOPT1",59,0)
 ;
"RTN","HLUOPT1",60,0)
 ; Lock to ensures no other purge job can run...
"RTN","HLUOPT1",61,0)
 L +^HL("HLUOPT1"):10 I '$T D  QUIT  ;->
"RTN","HLUOPT1",62,0)
 .  D XTMPUPD^HLUOPT4(.XTMP,"NO-LOCK","DONE")
"RTN","HLUOPT1",63,0)
 .  I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLUOPT1",64,0)
 ;
"RTN","HLUOPT1",65,0)
 ; Purge 773s...
"RTN","HLUOPT1",66,0)
 S (HLDELCNT,HLEXIT)=0
"RTN","HLUOPT1",67,0)
 D CHK773(.HLPDT,.HLDELCNT,.HLEXIT)
"RTN","HLUOPT1",68,0)
 ;
"RTN","HLUOPT1",69,0)
 ; Update piece 4 of file's zero node...
"RTN","HLUOPT1",70,0)
 D UPDP4(773)
"RTN","HLUOPT1",71,0)
 ;
"RTN","HLUOPT1",72,0)
 ; Purge 772s...
"RTN","HLUOPT1",73,0)
 I 'HLEXIT D CHK772(.HLPDT,.HLDELCNT,.HLEXIT)
"RTN","HLUOPT1",74,0)
 ;
"RTN","HLUOPT1",75,0)
 ; Update piece 4 of file's zero node...
"RTN","HLUOPT1",76,0)
 D UPDP4(772)
"RTN","HLUOPT1",77,0)
 ;
"RTN","HLUOPT1",78,0)
 ; HL*1.6*109
"RTN","HLUOPT1",79,0)
 L -^HL("HLUOPT1")
"RTN","HLUOPT1",80,0)
 ;
"RTN","HLUOPT1",81,0)
 D XTMPUPD^HLUOPT4(.XTMP,"FINISHED","DONE")
"RTN","HLUOPT1",82,0)
 I $D(ZTQUEUED) S ZTREQ="@" Q
"RTN","HLUOPT1",83,0)
 ;
"RTN","HLUOPT1",84,0)
 W !!,"  #",HLDELCNT," entries purged...",! ; HL*1.6*109
"RTN","HLUOPT1",85,0)
 ;
"RTN","HLUOPT1",86,0)
 Q
"RTN","HLUOPT1",87,0)
 ;
"RTN","HLUOPT1",88,0)
UPDP4(FNO) ; Update piece 4 of file's zero node...
"RTN","HLUOPT1",89,0)
 N GBL,NODE,NODEL,P4
"RTN","HLUOPT1",90,0)
 S GBL=$S(+FNO=772:"^HL(772,0)",+FNO=773:"^HLMA(0)",1:"") QUIT:GBL']""  ;->
"RTN","HLUOPT1",91,0)
 S NODEL=$G(XTMP(+FNO,"DEL")) QUIT:NODEL'>0  ;->
"RTN","HLUOPT1",92,0)
 L +@GBL:30 ; If don't get lock, update piece 4 anyway...
"RTN","HLUOPT1",93,0)
 S NODE=$G(@GBL) ; Get node...
"RTN","HLUOPT1",94,0)
 S P4=$P(NODE,U,4)-NODEL,P4=$S(P4>0:+P4,1:"") ; Recalc piece 4...
"RTN","HLUOPT1",95,0)
 S $P(NODE,U,4)=P4 ; Reset node's piece 4...
"RTN","HLUOPT1",96,0)
 S @GBL=NODE ; Store in file's zero node...
"RTN","HLUOPT1",97,0)
 L -@GBL
"RTN","HLUOPT1",98,0)
 Q
"RTN","HLUOPT1",99,0)
 ;
"RTN","HLUOPT1",100,0)
CHK773(HLPDT,HLDELCNT,HLEXIT) ; Check file 773
"RTN","HLUOPT1",101,0)
 N FPDATE,HLIEN,HLPTR,HLMADT,HLY,HLMADT1,HLLT773
"RTN","HLUOPT1",102,0)
 ;
"RTN","HLUOPT1",103,0)
 ; HL*1.6*109
"RTN","HLUOPT1",104,0)
 I '$G(HLTASK) W !,"Looping through file 773..."
"RTN","HLUOPT1",105,0)
 D XTMPUPD^HLUOPT4(.XTMP,"RUNNING","START-773")
"RTN","HLUOPT1",106,0)
 ;
"RTN","HLUOPT1",107,0)
 ;calculate cuttoff date for records reserved by Fast Purge - records with a more recent FAST PURGE DT/TM then this should be left to the Fast Purge to delete
"RTN","HLUOPT1",108,0)
 S FPDATE=$$FMADD^XLFDT(DT,-2)
"RTN","HLUOPT1",109,0)
 ;
"RTN","HLUOPT1",110,0)
 S HLLT773=$P(^HLMA(0),U,3) ; last ien for 773
"RTN","HLUOPT1",111,0)
 S HLIEN=0
"RTN","HLUOPT1",112,0)
 F  S HLIEN=$O(^HLMA(HLIEN)) Q:'HLIEN  D  Q:HLEXIT  Q:$$FAIL(773)  ;HL*1.6*109
"RTN","HLUOPT1",113,0)
 . D CHK4STOP(.HLEXIT) Q:HLEXIT
"RTN","HLUOPT1",114,0)
 . S XTMP(773,"REV")=$G(XTMP(773,"REV"))+1,XTMP(773,"LAST")=HLIEN,XTMP(773,"FAIL")=$G(XTMP(773,"FAIL"))+1 ; HL*1.6*109
"RTN","HLUOPT1",115,0)
 . ;
"RTN","HLUOPT1",116,0)
 . ;check if the record is reserved for FAST PURGE
"RTN","HLUOPT1",117,0)
 . I ($P($G(^HLMA(HLIEN,2)),"^",2)\1)>FPDATE Q
"RTN","HLUOPT1",118,0)
 . ;
"RTN","HLUOPT1",119,0)
 . S HLPTR=+$G(^HLMA(HLIEN,0)) Q:'HLPTR
"RTN","HLUOPT1",120,0)
 . S HLMADT=+$G(^HL(772,HLPTR,0))
"RTN","HLUOPT1",121,0)
 . ;HLY=status, HLMADT1=processed date
"RTN","HLUOPT1",122,0)
 . S HLY=+$G(^HLMA(HLIEN,"P")),HLMADT1=+$G(^("S"))
"RTN","HLUOPT1",123,0)
 . ;error status, quit if flag set to no
"RTN","HLUOPT1",124,0)
 . I HLY>3,HLY<8,'HLPDT("ERR") Q
"RTN","HLUOPT1",125,0)
 . ;check if date entered is less than purge all date
"RTN","HLUOPT1",126,0)
 . I HLMADT<HLPDT("ALL") D KILL773(HLIEN,HLLT773,.HLDELCNT) Q
"RTN","HLUOPT1",127,0)
 . ;pending, being generated, awaiting processing, or no processed date
"RTN","HLUOPT1",128,0)
 . I HLY=1!(HLY>7)!('HLMADT1) Q
"RTN","HLUOPT1",129,0)
 . ;awaiting ack, no purge date or date>purge date
"RTN","HLUOPT1",130,0)
 . I HLY=2,HLMADT1>HLPDT("WAIT") Q
"RTN","HLUOPT1",131,0)
 . ;successfully transmitted
"RTN","HLUOPT1",132,0)
 . I HLY=3,HLMADT1>HLPDT("COMP") Q
"RTN","HLUOPT1",133,0)
 . ;error status
"RTN","HLUOPT1",134,0)
 . I HLY>3,HLY<8,HLMADT1>HLPDT("ERR") Q
"RTN","HLUOPT1",135,0)
 . D KILL773(HLIEN,HLLT773,.HLDELCNT)
"RTN","HLUOPT1",136,0)
 D XTMPUPD^HLUOPT4(.XTMP,"RUNNING","END-773") ; HL*1.6*109
"RTN","HLUOPT1",137,0)
 Q
"RTN","HLUOPT1",138,0)
KILL773(HLIEN,HLLT773,HLDELCNT) ; delete in file 773
"RTN","HLUOPT1",139,0)
 ;
"RTN","HLUOPT1",140,0)
 ; quit if don't purge flag is set or the entry is the last one
"RTN","HLUOPT1",141,0)
 Q:$G(^HLMA(HLIEN,2))!(HLIEN=HLLT773)
"RTN","HLUOPT1",142,0)
 ;
"RTN","HLUOPT1",143,0)
 S X=$G(^HLMA(+HLIEN,0)),X=+$G(^HL(772,+X,0)),XTMP(773,"LAST","TIME")=$S(X?7N1"."1.N:+X,1:"")
"RTN","HLUOPT1",144,0)
 ;
"RTN","HLUOPT1",145,0)
 D DEL773^HLUOPT3(HLIEN) ; Purge w/direct kills...
"RTN","HLUOPT1",146,0)
 ;
"RTN","HLUOPT1",147,0)
 S HLDELCNT=HLDELCNT+1
"RTN","HLUOPT1",148,0)
 ;
"RTN","HLUOPT1",149,0)
 S XTMP(773,"DEL")=$G(XTMP(773,"DEL"))+1,XTMP(773,"FAIL")=0
"RTN","HLUOPT1",150,0)
 ;
"RTN","HLUOPT1",151,0)
 Q
"RTN","HLUOPT1",152,0)
 ;
"RTN","HLUOPT1",153,0)
CHK772(HLPDT,HLDELCNT,HLEXIT) ; Check file 772 for parents and children
"RTN","HLUOPT1",154,0)
 N FPDATE,HLOOP2,HLPTR,HLINK,HLIEN,HLMADT,HLY,HLLT772
"RTN","HLUOPT1",155,0)
 ;
"RTN","HLUOPT1",156,0)
 ; HL*1.6*109
"RTN","HLUOPT1",157,0)
 I '$G(HLTASK) W !,"Looping through file 772..."
"RTN","HLUOPT1",158,0)
 D XTMPUPD^HLUOPT4(.XTMP,"RUNNING","START-772")
"RTN","HLUOPT1",159,0)
 ;
"RTN","HLUOPT1",160,0)
 ;calculate cuttoff date for records reserved by Fast Purge - records with a more recent FAST PURGE DT/TM then this should be left to the Fast Purge to delete
"RTN","HLUOPT1",161,0)
 S FPDATE=$$FMADD^XLFDT(DT,-2)
"RTN","HLUOPT1",162,0)
 ;
"RTN","HLUOPT1",163,0)
 S HLLT772=$P(^HL(772,0),U,3) ; last ien for 772
"RTN","HLUOPT1",164,0)
 F HLOOP2=1:1:2 D  Q:HLEXIT  ; Kill children first, then parents
"RTN","HLUOPT1",165,0)
 . S XTMP(772,"FAIL")=0 ; HL*1.6*109
"RTN","HLUOPT1",166,0)
 . S HLPTR=0
"RTN","HLUOPT1",167,0)
 . F  S HLPTR=$O(^HL(772,"B",HLPTR)) Q:HLPTR'>0  D  Q:HLEXIT  Q:$$FAIL(772)  ; HL*1.6*109
"RTN","HLUOPT1",168,0)
 . . D CHK4STOP(.HLEXIT) Q:HLEXIT
"RTN","HLUOPT1",169,0)
 . . S HLIEN=0
"RTN","HLUOPT1",170,0)
 . . F  S HLIEN=$O(^HL(772,"B",HLPTR,HLIEN)) Q:'HLIEN  D
"RTN","HLUOPT1",171,0)
 . . . S XTMP(772,"REV")=$G(XTMP(772,"REV"))+1,XTMP(772,"LAST")=HLIEN,XTMP(772,"FAIL")=$G(XTMP(772,"FAIL"))+1 ; HL*1.6*109
"RTN","HLUOPT1",172,0)
 ... ;
"RTN","HLUOPT1",173,0)
 ... ;check if the record is reserved for FAST PURGE
"RTN","HLUOPT1",174,0)
 ... I ($P($G(^HL(772,+HLIEN,2)),"^",2)\1)>FPDATE Q
"RTN","HLUOPT1",175,0)
 ... ;
"RTN","HLUOPT1",176,0)
 . . . S HLMADT=+$G(^HL(772,+HLIEN,0)) Q:'HLMADT
"RTN","HLUOPT1",177,0)
 . . . I HLMADT>HLPDT("COMP") Q
"RTN","HLUOPT1",178,0)
 . . . S HLY=$P($G(^HL(772,HLIEN,"P")),U)
"RTN","HLUOPT1",179,0)
 . . . I HLY?1U S HLY=$TR(HLY,"PASE",1234)
"RTN","HLUOPT1",180,0)
 . . . I HLY>3,HLY<8,'HLPDT("ERR") Q
"RTN","HLUOPT1",181,0)
 . . . I HLMADT<HLPDT("ALL") D KILL772(HLIEN,HLLT772,.HLDELCNT) Q
"RTN","HLUOPT1",182,0)
 . . . I HLY=3,HLMADT>HLPDT("COMP") Q
"RTN","HLUOPT1",183,0)
 . . . I HLY=2,HLMADT>HLPDT("WAIT") Q
"RTN","HLUOPT1",184,0)
 . . . I HLY>3,HLY<8,HLMADT>HLPDT("ERR") Q
"RTN","HLUOPT1",185,0)
 . . . I HLY=1!(HLY>7) Q
"RTN","HLUOPT1",186,0)
 . . . I $O(^HL(772,"AI",HLIEN,HLIEN)) Q
"RTN","HLUOPT1",187,0)
 . . . D KILL772(HLIEN,HLLT772,.HLDELCNT)
"RTN","HLUOPT1",188,0)
 D XTMPUPD^HLUOPT4(.XTMP,"RUNNING","END-772") ; HL*1.6*109
"RTN","HLUOPT1",189,0)
 S HLINK=0
"RTN","HLUOPT1",190,0)
 F  S HLINK=$O(^HL(772,"A-XMIT-OUT",HLINK)) Q:'HLINK  D
"RTN","HLUOPT1",191,0)
 . S HLIEN=0
"RTN","HLUOPT1",192,0)
 . F  S HLIEN=$O(^HL(772,"A-XMIT-OUT",HLINK,HLIEN)) Q:'HLIEN  D
"RTN","HLUOPT1",193,0)
 . . I '$D(^HL(772,HLIEN)) K ^HL(772,"A-XMIT-OUT",HLINK,HLIEN)
"RTN","HLUOPT1",194,0)
 Q
"RTN","HLUOPT1",195,0)
KILL772(HLIEN,HLLT772,HLDELCNT) ;
"RTN","HLUOPT1",196,0)
 ;
"RTN","HLUOPT1",197,0)
 ; quit if the corresponding entry in #773 exists
"RTN","HLUOPT1",198,0)
 I $O(^HLMA("B",HLIEN,0)) Q
"RTN","HLUOPT1",199,0)
 ;
"RTN","HLUOPT1",200,0)
 ; quit if don't purge flag is set or the entry is the last one
"RTN","HLUOPT1",201,0)
 Q:+$G(^HL(772,HLIEN,2))!(HLIEN=HLLT772)
"RTN","HLUOPT1",202,0)
 ;
"RTN","HLUOPT1",203,0)
 N XMDUZ,XMK,XMZ,DIK,DA,HLX
"RTN","HLUOPT1",204,0)
 ;
"RTN","HLUOPT1",205,0)
 S HLX=$G(^HL(772,HLIEN,0))
"RTN","HLUOPT1",206,0)
 S XMZ=$P(HLX,U,5)
"RTN","HLUOPT1",207,0)
 I XMZ S XMK=1,XMDUZ=.5 D KLQ^XMA1B
"RTN","HLUOPT1",208,0)
 ;
"RTN","HLUOPT1",209,0)
 S XTMP(772,"LAST","TIME")=$S(+HLX?7N1"."1.N:+HLX,1:"")
"RTN","HLUOPT1",210,0)
 ;
"RTN","HLUOPT1",211,0)
 D DEL772^HLUOPT3(+HLIEN)
"RTN","HLUOPT1",212,0)
 ;
"RTN","HLUOPT1",213,0)
 S HLDELCNT=HLDELCNT+1
"RTN","HLUOPT1",214,0)
 S XTMP(772,"DEL")=$G(XTMP(772,"DEL"))+1,XTMP(772,"FAIL")=0 ; HL*1.6*109
"RTN","HLUOPT1",215,0)
 ;
"RTN","HLUOPT1",216,0)
 Q
"RTN","HLUOPT1",217,0)
 ;
"RTN","HLUOPT1",218,0)
CHK4STOP(HLEXIT) ;
"RTN","HLUOPT1",219,0)
 ; HL*1.6*109 modified from 60 to 120...
"RTN","HLUOPT1",220,0)
 ;
"RTN","HLUOPT1",221,0)
 S HLOOPCT=HLOOPCT+1
"RTN","HLUOPT1",222,0)
 I '$D(ZTQUEUED) W:'(HLOOPCT#2000) "."
"RTN","HLUOPT1",223,0)
 ;
"RTN","HLUOPT1",224,0)
 S:$G(HLEXIT("LASTCHK"))']"" HLEXIT("LASTCHK")=$H
"RTN","HLUOPT1",225,0)
 ;
"RTN","HLUOPT1",226,0)
 Q:$$HDIFF^XLFDT($H,$G(HLEXIT("LASTCHK")),2)<120
"RTN","HLUOPT1",227,0)
 ;
"RTN","HLUOPT1",228,0)
 ; HL*1.6*109 modified...
"RTN","HLUOPT1",229,0)
 I $$S^%ZTLOAD D  Q
"RTN","HLUOPT1",230,0)
 .  S HLEXIT=1
"RTN","HLUOPT1",231,0)
 .  D XTMPUPD^HLUOPT4(.XTMP,"ABORTED-TASKMAN","CHK4STOP")
"RTN","HLUOPT1",232,0)
 ;
"RTN","HLUOPT1",233,0)
 S HLEXIT("LASTCHK")=$H
"RTN","HLUOPT1",234,0)
 ;
"RTN","HLUOPT1",235,0)
 D XTMPUPD^HLUOPT4(.XTMP,"RUNNING","CHK4STOP") ; HL*1.6*109
"RTN","HLUOPT1",236,0)
 ;
"RTN","HLUOPT1",237,0)
 Q
"RTN","HLUOPT1",238,0)
 ;
"RTN","HLUOPT1",239,0)
FAIL(FILE) ; Has number entries w/o purging any been exceeded?
"RTN","HLUOPT1",240,0)
 QUIT $S($G(XTMP(FILE,"FAIL"))>200000:1,1:"")
"RTN","HLUOPT1",241,0)
 ;
"RTN","HLUOPT3")
0^4^B5260875
"RTN","HLUOPT3",1,0)
HLUOPT3 ;CIOFO-O/LJA - Delete 772, 773 Entries w/Direct Kills ;02/04/2004 15:15
"RTN","HLUOPT3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLUOPT3",3,0)
 ;
"RTN","HLUOPT3",4,0)
 ;
"RTN","HLUOPT3",5,0)
 ; WARNING!  No locing used in DEL772 and DEL773.  You MUST already
"RTN","HLUOPT3",6,0)
 ;           have the entry lock before calling here, (or be willing to
"RTN","HLUOPT3",7,0)
 ;           accept the consequences.)
"RTN","HLUOPT3",8,0)
 ;
"RTN","HLUOPT3",9,0)
 ; WARNING!  DEL772 and DEL773 does NOT update piece 4 (number entries)
"RTN","HLUOPT3",10,0)
 ;           of the file's zero node.  Be sure to do this elsewhere.
"RTN","HLUOPT3",11,0)
 ;
"RTN","HLUOPT3",12,0)
 ;
"RTN","HLUOPT3",13,0)
DEL772(IEN772) ; Delete 772 entry using kill commands...  (See WARNINGS above)
"RTN","HLUOPT3",14,0)
 N D0,D2,DP,IEN773,P01,P03,P06,P08,P11,PP1,P22
"RTN","HLUOPT3",15,0)
 ;
"RTN","HLUOPT3",16,0)
 ; Does 773 entry exist?
"RTN","HLUOPT3",17,0)
 S IEN773=$O(^HLMA("B",IEN772,0))
"RTN","HLUOPT3",18,0)
 I IEN773,'$D(^HLMA(+IEN773,0)) D
"RTN","HLUOPT3",19,0)
 .  KILL ^HLMA("B",IEN772,IEN773)
"RTN","HLUOPT3",20,0)
 .  S IEN773=""
"RTN","HLUOPT3",21,0)
 QUIT:IEN773  ;->
"RTN","HLUOPT3",22,0)
 ;
"RTN","HLUOPT3",23,0)
 ; Every field value must be set so as not to be null!!!
"RTN","HLUOPT3",24,0)
 ;
"RTN","HLUOPT3",25,0)
 ; Get 0 node data and pieces...
"RTN","HLUOPT3",26,0)
 S D0=$G(^HL(772,+IEN772,0))
"RTN","HLUOPT3",27,0)
 S P01=+$P(D0,U),P03=+$P(D0,U,3)
"RTN","HLUOPT3",28,0)
 S P06=$P(D0,U,6),P06=$S(P06]"":P06,1:" ")
"RTN","HLUOPT3",29,0)
 S P08=+$P(D0,U,8),P011=+$P(D0,U,11)
"RTN","HLUOPT3",30,0)
 ;
"RTN","HLUOPT3",31,0)
 ;Get 2 node data and piece
"RTN","HLUOPT3",32,0)
 S D2=$G(^HL(772,+IEN772,2))
"RTN","HLUOPT3",33,0)
 S P22=+$P(D2,U,2)
"RTN","HLUOPT3",34,0)
 ;
"RTN","HLUOPT3",35,0)
 ; Get P node data and piece...
"RTN","HLUOPT3",36,0)
 S DP=$G(^HL(772,+IEN772,"P"))
"RTN","HLUOPT3",37,0)
 S PP1=+$P(DP,U)
"RTN","HLUOPT3",38,0)
 ;
"RTN","HLUOPT3",39,0)
 ; Kill xrefs...
"RTN","HLUOPT3",40,0)
 KILL ^HL(772,"A-XMIT-OUT",P011,IEN772)
"RTN","HLUOPT3",41,0)
 KILL ^HL(772,"AC","I",P03,IEN772)
"RTN","HLUOPT3",42,0)
 KILL ^HL(772,"AC","O",P03,IEN772)
"RTN","HLUOPT3",43,0)
 KILL ^HL(772,"AF",PP1,IEN772)
"RTN","HLUOPT3",44,0)
 KILL ^HL(772,"AH",P03,P06,IEN772)
"RTN","HLUOPT3",45,0)
 KILL ^HL(772,"AI",P08,IEN772)
"RTN","HLUOPT3",46,0)
 KILL ^HL(772,"B",P01,IEN772)
"RTN","HLUOPT3",47,0)
 KILL ^HL(772,"C",P06,IEN772)
"RTN","HLUOPT3",48,0)
 KILL ^HLMA("AI",P22,772,IEN772)
"RTN","HLUOPT3",49,0)
 ;
"RTN","HLUOPT3",50,0)
 ; Remove data...
"RTN","HLUOPT3",51,0)
 KILL ^HL(772,IEN772)
"RTN","HLUOPT3",52,0)
 ;
"RTN","HLUOPT3",53,0)
 QUIT
"RTN","HLUOPT3",54,0)
 ;
"RTN","HLUOPT3",55,0)
DEL773(IEN773) ; Delete 773 entry using kill commands...  (See WARNINGS above)
"RTN","HLUOPT3",56,0)
 N D0,D2,DP,DS,P01,P02,P07,P06,P012,PP1,PS1,P22
"RTN","HLUOPT3",57,0)
 ;
"RTN","HLUOPT3",58,0)
 ; Every field value must be set so as not to be null!!!
"RTN","HLUOPT3",59,0)
 ;
"RTN","HLUOPT3",60,0)
 ; Get 0 node data and pieces...
"RTN","HLUOPT3",61,0)
 S D0=$G(^HLMA(IEN773,0))
"RTN","HLUOPT3",62,0)
 S P01=+$P(D0,U),P02=$P(D0,U,2),P02=$S(P02]"":P02,1:" ")
"RTN","HLUOPT3",63,0)
 S P07=+$P(D0,U,7),P06=+$P(D0,U,6),P012=+$P(D0,U,12)
"RTN","HLUOPT3",64,0)
 ;
"RTN","HLUOPT3",65,0)
 ;
"RTN","HLUOPT3",66,0)
 ;Get 2 node data and piece
"RTN","HLUOPT3",67,0)
 S D2=$G(^HLMA(IEN773,2))
"RTN","HLUOPT3",68,0)
 S P22=+$P(D2,U,2)
"RTN","HLUOPT3",69,0)
 ;
"RTN","HLUOPT3",70,0)
 ; Get P node data and piece...
"RTN","HLUOPT3",71,0)
 S DP=$G(^HLMA(IEN773,"P"))
"RTN","HLUOPT3",72,0)
 S PP1=+DP
"RTN","HLUOPT3",73,0)
 ;
"RTN","HLUOPT3",74,0)
 ; Get S node data and piece...
"RTN","HLUOPT3",75,0)
 S DS=$G(^HLMA(IEN773,"S"))
"RTN","HLUOPT3",76,0)
 S PS1=+DS
"RTN","HLUOPT3",77,0)
 ;
"RTN","HLUOPT3",78,0)
 ; Kill xrefs...
"RTN","HLUOPT3",79,0)
 KILL ^HLMA("AC","I",P07,IEN773)
"RTN","HLUOPT3",80,0)
 KILL ^HLMA("AC","O",P07,IEN773)
"RTN","HLUOPT3",81,0)
 KILL ^HLMA("AD",PS1,IEN773)
"RTN","HLUOPT3",82,0)
 KILL ^HLMA("AF",P06,IEN773)
"RTN","HLUOPT3",83,0)
 KILL ^HLMA("AG",PP1,IEN773)
"RTN","HLUOPT3",84,0)
 KILL ^HLMA("AH",P012,P02,IEN773)
"RTN","HLUOPT3",85,0)
 KILL ^HLMA("B",P01,IEN773)
"RTN","HLUOPT3",86,0)
 KILL ^HLMA("C",P02,IEN773)
"RTN","HLUOPT3",87,0)
 KILL ^HLMA("AI",P22,773,IEN773)
"RTN","HLUOPT3",88,0)
 ;
"RTN","HLUOPT3",89,0)
 ; Remove data...
"RTN","HLUOPT3",90,0)
 KILL ^HLMA(IEN773)
"RTN","HLUOPT3",91,0)
 ;
"RTN","HLUOPT3",92,0)
 QUIT
"RTN","HLUOPT3",93,0)
 ;
"RTN","HLUOPT3",94,0)
EOR ;HLUOPT3 - Delete 772, 773 Entries w/Direct Kills ;12/30/02 15:15
"RTN","HLUOPT4")
0^2^B86903345
"RTN","HLUOPT4",1,0)
HLUOPT4 ;OIFO-O/LJA - Purging Entries in file #772 and #773 ;02/04/2004 16:37
"RTN","HLUOPT4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLUOPT4",3,0)
 ;
"RTN","HLUOPT4",4,0)
 ; This routine was created by patch HL*1.6*109
"RTN","HLUOPT4",5,0)
 ;
"RTN","HLUOPT4",6,0)
SHOW120 ; Call SHOWXTMP with 30 second redisplay...
"RTN","HLUOPT4",7,0)
 D SHOWXTMP(120)
"RTN","HLUOPT4",8,0)
 QUIT
"RTN","HLUOPT4",9,0)
 ;
"RTN","HLUOPT4",10,0)
ASKSHOW ; Ask whether want to monitor purging job progress...
"RTN","HLUOPT4",11,0)
 N ACTION,XTMP
"RTN","HLUOPT4",12,0)
 S XTMP=$O(^XTMP("HLUOPT1 9999999.999999"),-1) QUIT:XTMP'["HLUOPT1 "  ;->
"RTN","HLUOPT4",13,0)
 W !!,"As purging jobs run, they record critical information in the ^XTMP global for"
"RTN","HLUOPT4",14,0)
 W !,"later review.  (This information is updated every two minutes.) You can view"
"RTN","HLUOPT4",15,0)
 W !,"purge information now..."
"RTN","HLUOPT4",16,0)
 F  S ACTION=$$ACTION QUIT:'ACTION  D
"RTN","HLUOPT4",17,0)
 .  I ACTION=1 D SHOWALL^HLUOPT5(XTMP)
"RTN","HLUOPT4",18,0)
 .  I ACTION=2 D SHOWXTMP(120)
"RTN","HLUOPT4",19,0)
 .  I ACTION=3 D
"RTN","HLUOPT4",20,0)
 .  .  W @IOF
"RTN","HLUOPT4",21,0)
 .  .  D GRAPH^HLUOPT5
"RTN","HLUOPT4",22,0)
 .  .  S X=$$BTE^HLCSMON("Press RETURN to continue... ",1)
"RTN","HLUOPT4",23,0)
 QUIT
"RTN","HLUOPT4",24,0)
 ;
"RTN","HLUOPT4",25,0)
ACTION() ;
"RTN","HLUOPT4",26,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLUOPT4",27,0)
 S DIR(0)="S^1:Display all available purging data (full screen);2:Display purging summary (single line);3:Display purging graph;4:Exit."
"RTN","HLUOPT4",28,0)
 S DIR("?",1)="Option #1 displays all available purging data, for the last job."
"RTN","HLUOPT4",29,0)
 S DIR("?",2)=""
"RTN","HLUOPT4",30,0)
 S DIR("?",3)="Option #2 displays the most valuable purging data, but not all data. This"
"RTN","HLUOPT4",31,0)
 S DIR("?",4)="option includes data for the last purging job, plus previous puring jobs."
"RTN","HLUOPT4",32,0)
 S DIR("?",5)=""
"RTN","HLUOPT4",33,0)
 S DIR("?")="Option #3 displays purging times and totals in a graphic representation."
"RTN","HLUOPT4",34,0)
 D ^DIR
"RTN","HLUOPT4",35,0)
 QUIT $S(+Y=1:1,+Y=2:2,+Y=3:3,1:"")
"RTN","HLUOPT4",36,0)
 ;
"RTN","HLUOPT4",37,0)
SHOWXTMP(SEC) ; Continual redisplay of purging progress ever SEC seconds...
"RTN","HLUOPT4",38,0)
 N ABORT,ACTIVE,HDR,IOINHI,IOINORM,X,XTMP
"RTN","HLUOPT4",39,0)
 ;
"RTN","HLUOPT4",40,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLUOPT4",41,0)
 S HDR=" Task-Number   Start-Time   Timestamp Finish-time     772@     773@     Time-NOW"
"RTN","HLUOPT4",42,0)
 ;
"RTN","HLUOPT4",43,0)
 ; Get last purging process' XTMP...
"RTN","HLUOPT4",44,0)
 S XTMP=$O(^XTMP("HLUOPT1 9999999.999999"),-1)
"RTN","HLUOPT4",45,0)
 S ACTIVE=0 ; Default...
"RTN","HLUOPT4",46,0)
 I XTMP]"" S X=$P($G(^XTMP(XTMP,"RUN")),U,4) I X'?7N.E S ACTIVE=1
"RTN","HLUOPT4",47,0)
 ;
"RTN","HLUOPT4",48,0)
 ; Show last 10 runs...
"RTN","HLUOPT4",49,0)
 D SHOWNUM($S(ACTIVE:9,1:18))
"RTN","HLUOPT4",50,0)
 ;
"RTN","HLUOPT4",51,0)
 ; Redisplay SEC defaults to 30...
"RTN","HLUOPT4",52,0)
 S SEC=$S($G(SEC)>0:+SEC,1:30)
"RTN","HLUOPT4",53,0)
 ;
"RTN","HLUOPT4",54,0)
 ; What if no purging process exists?
"RTN","HLUOPT4",55,0)
 I XTMP']""!('ACTIVE) D  QUIT  ;->
"RTN","HLUOPT4",56,0)
 .  W !!,"There is no currently running purge job..."
"RTN","HLUOPT4",57,0)
 .  S X=$$BTE^HLCSMON("Press RETURN to exit... ",1)
"RTN","HLUOPT4",58,0)
 ;
"RTN","HLUOPT4",59,0)
 W !!,"Any old jobs that exist will be shown above. The current (or last) purge job"
"RTN","HLUOPT4",60,0)
 W !,"is shown below.  The information on each line will automatically refresh"
"RTN","HLUOPT4",61,0)
 W !,"every ",SEC," seconds (or whenever you press RETURN.)"
"RTN","HLUOPT4",62,0)
 W !!,IOINHI,"Note!!",IOINORM," Enter '^' when you are ready to exit."
"RTN","HLUOPT4",63,0)
 W !!,"Current (or last) purge job..."
"RTN","HLUOPT4",64,0)
 W !
"RTN","HLUOPT4",65,0)
 S CT=0
"RTN","HLUOPT4",66,0)
 ;
"RTN","HLUOPT4",67,0)
 F  D  QUIT:ABORT
"RTN","HLUOPT4",68,0)
 .  S ABORT=1,CT=CT+1
"RTN","HLUOPT4",69,0)
 .  D LINERUN(XTMP)
"RTN","HLUOPT4",70,0)
 .  R X:SEC QUIT:X]""  ;-> Quit if they enter anything
"RTN","HLUOPT4",71,0)
 .  I CT>17 W ! S CT=0
"RTN","HLUOPT4",72,0)
 .  S ABORT=0
"RTN","HLUOPT4",73,0)
 ;
"RTN","HLUOPT4",74,0)
 QUIT
"RTN","HLUOPT4",75,0)
 ;
"RTN","HLUOPT4",76,0)
SHOWNUM(NUM) ; Show last NUM entries...
"RTN","HLUOPT4",77,0)
 N CT,HOLD,XTMP
"RTN","HLUOPT4",78,0)
 ; ACTIVE -- req
"RTN","HLUOPT4",79,0)
 S XTMP="HLUOPT1 9999999.99999"
"RTN","HLUOPT4",80,0)
 ; If last job is active, don't include it in array...
"RTN","HLUOPT4",81,0)
 I ACTIVE S XTMP=$O(^XTMP(XTMP),-1) QUIT:XTMP'["HLUOPT1 "  ;->
"RTN","HLUOPT4",82,0)
 S CT=0
"RTN","HLUOPT4",83,0)
 F  S XTMP=$O(^XTMP(XTMP),-1) Q:(CT>(NUM-1))!(XTMP'["HLUOPT1 ")  D
"RTN","HLUOPT4",84,0)
 .  S CT=CT+1
"RTN","HLUOPT4",85,0)
 .  S HOLD(XTMP)=""
"RTN","HLUOPT4",86,0)
 QUIT:'$D(HOLD)  ;->
"RTN","HLUOPT4",87,0)
 W !!,"Recent purge runs..."
"RTN","HLUOPT4",88,0)
 W !!,HDR,!,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLUOPT4",89,0)
 S XTMP=""
"RTN","HLUOPT4",90,0)
 F  S XTMP=$O(HOLD(XTMP)) Q:XTMP']""  D
"RTN","HLUOPT4",91,0)
 .  D LINERUN(XTMP)
"RTN","HLUOPT4",92,0)
 QUIT
"RTN","HLUOPT4",93,0)
 ;
"RTN","HLUOPT4",94,0)
LINERUN(XTMP) ; Display one line...
"RTN","HLUOPT4",95,0)
 N I,PCE1,PCE2,PCE3,PCE4,PCE5,PCE6,PCE7,PCE8,PCE9,PCE10,PCE11
"RTN","HLUOPT4",96,0)
 N PCE12,PCE13,PCE14
"RTN","HLUOPT4",97,0)
 S RUN=$G(^XTMP(XTMP,"RUN"))
"RTN","HLUOPT4",98,0)
 F I=1:1:14 S @("PCE"_I)=$P(RUN,U,I)
"RTN","HLUOPT4",99,0)
 S PCE2=$$SDT(PCE2),PCE3=$$SDT(PCE3),PCE4=$$SDT(PCE4)
"RTN","HLUOPT4",100,0)
 I ($P(PCE2,"@"))=$$SDT(DT) S PCE3="      "_$P(PCE3,"@",2)
"RTN","HLUOPT4",101,0)
 I ($P(PCE2,"@"))=$$SDT(DT) S PCE4="      "_$P(PCE4,"@",2)
"RTN","HLUOPT4",102,0)
 I CT=1 W !,HDR,!,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLUOPT4",103,0)
 W !,$J(PCE1,12),?14,PCE2,?26,PCE3,?38,PCE4,?50,$J(PCE8,8)
"RTN","HLUOPT4",104,0)
 W ?59,$J(PCE10,8)
"RTN","HLUOPT4",105,0)
 W ?69,$$SDT($$NOW^XLFDT)
"RTN","HLUOPT4",106,0)
 QUIT
"RTN","HLUOPT4",107,0)
 ;
"RTN","HLUOPT4",108,0)
SDT(DATE) ; Return shortened form of date...
"RTN","HLUOPT4",109,0)
 I DATE?7N QUIT $E(DATE,4,5)_"/"_$E(DATE,6,7) ;->
"RTN","HLUOPT4",110,0)
 I DATE?7N1"."1.N QUIT $E(DATE,4,5)_"/"_$E(DATE,6,7)_"@"_$E($P($$FMTE^XLFDT(DATE),"@",2),1,5)
"RTN","HLUOPT4",111,0)
 QUIT ""
"RTN","HLUOPT4",112,0)
 ;
"RTN","HLUOPT4",113,0)
XTMPBEGN ; Initialize ^XTMP nodes for use in purging monitoring...
"RTN","HLUOPT4",114,0)
 N NOW
"RTN","HLUOPT4",115,0)
 S NOW=$$NOW^XLFDT,XTMP="HLUOPT1 "_NOW
"RTN","HLUOPT4",116,0)
 S ^XTMP(XTMP,0)=$$FMADD^XLFDT(NOW,14)_U_NOW_U_$G(DUZ)_U_"HLUOPT1 Purging"
"RTN","HLUOPT4",117,0)
 S ^XTMP(XTMP,"RUN")=$G(ZTSK)_U_NOW_U_NOW_U_U_"RUNNING"_U_"XTMPBEGN"
"RTN","HLUOPT4",118,0)
 QUIT
"RTN","HLUOPT4",119,0)
 ;
"RTN","HLUOPT4",120,0)
XTMPUPD(XTMP,STATUS,WHERE) ; Update the data in purging's ^XTMP...
"RTN","HLUOPT4",121,0)
 N NOW,RUN
"RTN","HLUOPT4",122,0)
 ;
"RTN","HLUOPT4",123,0)
 ; Required variables...
"RTN","HLUOPT4",124,0)
 S NOW=$$NOW^XLFDT
"RTN","HLUOPT4",125,0)
 ;
"RTN","HLUOPT4",126,0)
 ; Update node...
"RTN","HLUOPT4",127,0)
 S RUN=$G(^XTMP(XTMP,"RUN"))
"RTN","HLUOPT4",128,0)
 S $P(RUN,U,3)=$$NOW^XLFDT ; Timestamp
"RTN","HLUOPT4",129,0)
 I STATUS="FINISHED"!(STATUS["ABORTED") S $P(RUN,U,4)=NOW ; Finish time
"RTN","HLUOPT4",130,0)
 S $P(RUN,U,5)=STATUS ; Status
"RTN","HLUOPT4",131,0)
 S $P(RUN,U,6)=WHERE ; Whereabouts
"RTN","HLUOPT4",132,0)
 S $P(RUN,U,7)=$G(XTMP(772,"REV")) ; # 772 reviewed
"RTN","HLUOPT4",133,0)
 S $P(RUN,U,8)=$G(XTMP(772,"DEL")) ; # 772 deleted
"RTN","HLUOPT4",134,0)
 S $P(RUN,U,9)=$G(XTMP(773,"REV")) ; # 773 reviewed
"RTN","HLUOPT4",135,0)
 S $P(RUN,U,10)=$G(XTMP(773,"DEL")) ;# 773 deleted
"RTN","HLUOPT4",136,0)
 S $P(RUN,U,11)=$G(XTMP(772,"LAST")) ; Last 772 IEN
"RTN","HLUOPT4",137,0)
 S $P(RUN,U,12)=$G(XTMP(772,"FAIL")) ; # failed purge check (in a row)
"RTN","HLUOPT4",138,0)
 S $P(RUN,U,13)=$G(XTMP(773,"LAST")) ; Last 773 IEN
"RTN","HLUOPT4",139,0)
 S $P(RUN,U,14)=$G(XTMP(773,"FAIL")) ; # failed purge check (in a row)
"RTN","HLUOPT4",140,0)
 S $P(RUN,U,15)=$G(XTMP(772,"LAST","TIME")) ; Last 772s .01 time
"RTN","HLUOPT4",141,0)
 S $P(RUN,U,16)=$G(XTMP(773,"LAST","TIME")) ; Last 773's 772s .01 time
"RTN","HLUOPT4",142,0)
 S ^XTMP(XTMP,"RUN")=RUN
"RTN","HLUOPT4",143,0)
 ;
"RTN","HLUOPT4",144,0)
 QUIT
"RTN","HLUOPT4",145,0)
 ;
"RTN","HLUOPT4",146,0)
LOCKTELL ; Process is locked, so new purge job can't be started...
"RTN","HLUOPT4",147,0)
 N X
"RTN","HLUOPT4",148,0)
 W !!,"The '^HL(""HLUOPT1"")' lock is already owned by another purge job!  So, this"
"RTN","HLUOPT4",149,0)
 W !,"purge job cannot be started."
"RTN","HLUOPT4",150,0)
 S X=$$BTE^HLCSMON("Press RETURN to exit... ",1)
"RTN","HLUOPT4",151,0)
 QUIT
"RTN","HLUOPT4",152,0)
 ;
"RTN","HLUOPT4",153,0)
INIT ; Moved here from HLUOPT1 (ran out of room)
"RTN","HLUOPT4",154,0)
 ; If no data are stored in file 869.3, fields 41, 42, and 43,
"RTN","HLUOPT4",155,0)
 ; the default number for these fields is 7, 30, 90, respectively.
"RTN","HLUOPT4",156,0)
 N I,HLIEN,HLREC,HLDEF
"RTN","HLUOPT4",157,0)
 S HLDEF="7^30^90^90"
"RTN","HLUOPT4",158,0)
 S HLIEN=+$O(^HLCS(869.3,0))
"RTN","HLUOPT4",159,0)
 S HLREC=$S(HLIEN:$G(^HLCS(869.3,HLIEN,4)),1:"")
"RTN","HLUOPT4",160,0)
 F I=1:1:4 I '$P(HLREC,U,I) S $P(HLREC,U,I)=$P(HLDEF,U,I)
"RTN","HLUOPT4",161,0)
 ;
"RTN","HLUOPT4",162,0)
 ; If AWAITING ACK<COMPLETED -- or -- AWAITING ACK > ALL -- or -- PURGE < ALL use the default values (for an invalid date(s) has been entered into the paramters)
"RTN","HLUOPT4",163,0)
 I $P(HLREC,U,2)<$P(HLREC,U,1)!($P(HLREC,U,3)<$P(HLREC,U,2))!($P(HLREC,U,3)>$P(HLREC,U,4)) D
"RTN","HLUOPT4",164,0)
 .  S HLREC=HLDEF
"RTN","HLUOPT4",165,0)
 ;
"RTN","HLUOPT4",166,0)
 I $D(ZTQUEUED) D  Q
"RTN","HLUOPT4",167,0)
 . S HLPDT("COMP")=$$FMADD^XLFDT(DT,-$P(HLREC,U,1))_.9
"RTN","HLUOPT4",168,0)
 . S HLPDT("WAIT")=$$FMADD^XLFDT(DT,-$P(HLREC,U,2))_.9
"RTN","HLUOPT4",169,0)
 . S HLPDT("ALL")=$$FMADD^XLFDT(DT,-$P(HLREC,U,3))_.9
"RTN","HLUOPT4",170,0)
 . S HLPDT("ERR")=$$FMADD^XLFDT(DT,-$P(HLREC,U,4))_.9
"RTN","HLUOPT4",171,0)
 ;
"RTN","HLUOPT4",172,0)
 ; get input data from user
"RTN","HLUOPT4",173,0)
 N DIR,X,Y,DIRUT
"RTN","HLUOPT4",174,0)
 ; input cutoff date for "Successfully Completed" messages
"RTN","HLUOPT4",175,0)
 S DIR(0)="D^:"_$$FMADD^XLFDT(DT,-1)_":EX"
"RTN","HLUOPT4",176,0)
 S DIR("A",1)="  Enter inclusive date up to which to purge SUCCESSFULLY COMPLETED"
"RTN","HLUOPT4",177,0)
 S DIR("A")="  messages"
"RTN","HLUOPT4",178,0)
 S DIR("B")="T"_-$P(HLREC,U,1)
"RTN","HLUOPT4",179,0)
 S DIR("?",1)="  The suggested cutoff date to purge 'Successfully Completed' messages"
"RTN","HLUOPT4",180,0)
 S DIR("?",2)="  is seven days prior to today."
"RTN","HLUOPT4",181,0)
 S DIR("?")="  Must be on or before "_$$FMTE^XLFDT($$FMADD^XLFDT(DT,-1),2)_"."
"RTN","HLUOPT4",182,0)
 W ! D ^DIR I $D(DIRUT) S HLEXIT=1 Q
"RTN","HLUOPT4",183,0)
 S HLPDT("COMP")=Y
"RTN","HLUOPT4",184,0)
 K DIR
"RTN","HLUOPT4",185,0)
 ;
"RTN","HLUOPT4",186,0)
 ; input cutoff date for "Awaiting Acknowledgement" messages
"RTN","HLUOPT4",187,0)
 S DIR(0)="D^:"_HLPDT("COMP")_":EX"
"RTN","HLUOPT4",188,0)
 S DIR("A",1)="  Enter inclusive date up to which to purge AWAITING ACK"
"RTN","HLUOPT4",189,0)
 S DIR("A")="  messages"
"RTN","HLUOPT4",190,0)
 S DIR("B")="T"_-$P(HLREC,U,2)
"RTN","HLUOPT4",191,0)
 S DIR("?",1)="  The suggested cutoff date to purge 'Awaiting Acknowledgment' messages"
"RTN","HLUOPT4",192,0)
 S DIR("?",2)="  is thirty days prior to today."
"RTN","HLUOPT4",193,0)
 S DIR("?")="  Must be on or before "_$$FMTE^XLFDT(HLPDT("COMP"),2)_"."
"RTN","HLUOPT4",194,0)
 W ! D ^DIR I $D(DIRUT) S HLEXIT=1 Q
"RTN","HLUOPT4",195,0)
 S HLPDT("WAIT")=Y
"RTN","HLUOPT4",196,0)
 K DIR
"RTN","HLUOPT4",197,0)
 ;
"RTN","HLUOPT4",198,0)
 ; Input for Vaporization Date
"RTN","HLUOPT4",199,0)
 S DIR(0)="D^:"_HLPDT("WAIT")_":EX"
"RTN","HLUOPT4",200,0)
 S DIR("A",1)="  Enter inclusive date up to which to purge all messages, regardless"
"RTN","HLUOPT4",201,0)
 S DIR("A")="  of status (except ERROR status)"
"RTN","HLUOPT4",202,0)
 S DIR("B")="T"_-$P(HLREC,U,3)
"RTN","HLUOPT4",203,0)
 S DIR("?",1)="  The suggested cutoff date to purge all messages (except for 'Error' messages)"
"RTN","HLUOPT4",204,0)
 S DIR("?",2)="  is 90 days prior to today."
"RTN","HLUOPT4",205,0)
 S DIR("?")="  Must be on or before "_$$FMTE^XLFDT(HLPDT("WAIT"),2)_"."
"RTN","HLUOPT4",206,0)
 W ! D ^DIR I $D(DIRUT) S HLEXIT=1 Q
"RTN","HLUOPT4",207,0)
 S HLPDT("ALL")=Y+.9
"RTN","HLUOPT4",208,0)
 K DIR
"RTN","HLUOPT4",209,0)
 ;
"RTN","HLUOPT4",210,0)
 ; prompt whether to purge "Error" messages
"RTN","HLUOPT4",211,0)
 S DIR(0)="Y"
"RTN","HLUOPT4",212,0)
 S DIR("A")="  Do you also want to purge messages with an ERROR status"
"RTN","HLUOPT4",213,0)
 S DIR("B")="NO"
"RTN","HLUOPT4",214,0)
 S DIR("?",1)="  Enter 'Yes' to purge entries whose status is 'error'."
"RTN","HLUOPT4",215,0)
 S DIR("?",2)="  If you have reviewed/resolved the cause of the problem of those",DIR("?")="  entries with an 'error' status answer 'Yes'.  Otherwise answer 'No'."
"RTN","HLUOPT4",216,0)
 W ! D ^DIR I $D(DIRUT) S HLEXIT=1 Q
"RTN","HLUOPT4",217,0)
 K DIR
"RTN","HLUOPT4",218,0)
 I 'Y S HLPDT("ERR")=0
"RTN","HLUOPT4",219,0)
 E  D  Q:HLEXIT
"RTN","HLUOPT4",220,0)
 . ; input cutoff date for "Error" messages
"RTN","HLUOPT4",221,0)
 . S DIR(0)="D^:"_HLPDT("WAIT")_":EX"
"RTN","HLUOPT4",222,0)
 . S DIR("A",1)="    WARNING: You should have investigated all errors because purging"
"RTN","HLUOPT4",223,0)
 . S DIR("A",2)="             these messages permanently removes them from the system."
"RTN","HLUOPT4",224,0)
 . S DIR("A",3)=" "
"RTN","HLUOPT4",225,0)
 . S DIR("A",4)="    Enter inclusive date up to which to purge ERROR"
"RTN","HLUOPT4",226,0)
 . S DIR("A")="    messages"
"RTN","HLUOPT4",227,0)
 . S DIR("B")="T"_-$P(HLREC,U,4)
"RTN","HLUOPT4",228,0)
 . S DIR("?",1)="  The suggested cutoff date to purge 'Error' messages"
"RTN","HLUOPT4",229,0)
 . S DIR("?",2)="  is 90 days prior to today."
"RTN","HLUOPT4",230,0)
 . S DIR("?")="  Must be on or before "_$$FMTE^XLFDT(HLPDT("WAIT"),2)_"."
"RTN","HLUOPT4",231,0)
 . W ! D ^DIR I $D(DIRUT) S HLEXIT=1 Q
"RTN","HLUOPT4",232,0)
 . S HLPDT("ERR")=Y+.9
"RTN","HLUOPT4",233,0)
 . K DIR
"RTN","HLUOPT4",234,0)
 ;
"RTN","HLUOPT4",235,0)
 ; prompt whether to run this purge in the background
"RTN","HLUOPT4",236,0)
 S DIR(0)="YA"
"RTN","HLUOPT4",237,0)
 S DIR("A")="  Would you like to queue this purge?  "
"RTN","HLUOPT4",238,0)
 S DIR("B")="YES"
"RTN","HLUOPT4",239,0)
 S DIR("?")="  If run in the foreground, you will see dots and a total count."
"RTN","HLUOPT4",240,0)
 W ! D ^DIR I $D(DIRUT) S HLEXIT=1 Q
"RTN","HLUOPT4",241,0)
 S HLTASK=Y
"RTN","HLUOPT4",242,0)
 K DIR
"RTN","HLUOPT4",243,0)
 W !,"  "
"RTN","HLUOPT4",244,0)
 ;
"RTN","HLUOPT4",245,0)
 S HLPDT("COMP")=HLPDT("COMP")+.9,HLPDT("WAIT")=HLPDT("WAIT")+.9
"RTN","HLUOPT4",246,0)
 Q
"RTN","HLUOPT4",247,0)
 ;
"RTN","HLUOPT4",248,0)
EOR ;HLUOPT4 - Purging Entries in file #772 and #773 ;12/10/02 16:37
"RTN","HLUOPT5")
0^3^B25596832
"RTN","HLUOPT5",1,0)
HLUOPT5 ;OIFO-O/LJA - Purging Entries in file #772 and #773 ;02/04/2004 16:37
"RTN","HLUOPT5",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLUOPT5",3,0)
 ;
"RTN","HLUOPT5",4,0)
 ; This routine was created by patch HL*1.6*109
"RTN","HLUOPT5",5,0)
 ;
"RTN","HLUOPT5",6,0)
GRAPH ; Display graph for all entries in ^XTMP
"RTN","HLUOPT5",7,0)
 N DATA,DATE,END,HOLD,MAX,MULT,START,TXT,TYPE,VAL,XTMP
"RTN","HLUOPT5",8,0)
 ;
"RTN","HLUOPT5",9,0)
 ; Create HOLD(...) with entry data, and max values...
"RTN","HLUOPT5",10,0)
 S XTMP="HLUOPT1 "
"RTN","HLUOPT5",11,0)
 F  S XTMP=$O(^XTMP(XTMP)) Q:XTMP'["HLUOPT1 "  D
"RTN","HLUOPT5",12,0)
 .
"RTN","HLUOPT5",13,0)
 .  S DATA=$G(^XTMP(XTMP,"RUN")) Q:$P(DATA,U,5)'["FINISHED"  ;->
"RTN","HLUOPT5",14,0)
 .
"RTN","HLUOPT5",15,0)
 .  S START=$P(DATA,U,2) QUIT:START'?7N.E  ;->
"RTN","HLUOPT5",16,0)
 .  S END=$P(DATA,U,4) QUIT:END'?7N.E  ;->
"RTN","HLUOPT5",17,0)
 .  S DIFF=$$FMDIFF^XLFDT(END,START,2) ; Hours difference
"RTN","HLUOPT5",18,0)
 .  D HOLD(1,DIFF)
"RTN","HLUOPT5",19,0)
 .
"RTN","HLUOPT5",20,0)
 .  S DEL772=$P(DATA,U,8)
"RTN","HLUOPT5",21,0)
 .  D HOLD(2,DEL772)
"RTN","HLUOPT5",22,0)
 .
"RTN","HLUOPT5",23,0)
 .  S DEL773=$P(DATA,U,10)
"RTN","HLUOPT5",24,0)
 .  D HOLD(3,DEL773)
"RTN","HLUOPT5",25,0)
 .
"RTN","HLUOPT5",26,0)
 .  S HOLD($P(XTMP," ",2))=DIFF_U_DEL772_U_DEL773
"RTN","HLUOPT5",27,0)
 ;
"RTN","HLUOPT5",28,0)
 QUIT:'$D(HOLD)  ;->
"RTN","HLUOPT5",29,0)
 ;
"RTN","HLUOPT5",30,0)
 ; Calculate graph multiplier...
"RTN","HLUOPT5",31,0)
 F TYPE=1,2,3 D
"RTN","HLUOPT5",32,0)
 .  S MAX=HOLD(TYPE)
"RTN","HLUOPT5",33,0)
 .  S MULT(TYPE)=MAX/21\1
"RTN","HLUOPT5",34,0)
 ;
"RTN","HLUOPT5",35,0)
 W !,"VistA HL7 Purge Graph"
"RTN","HLUOPT5",36,0)
 W !,"Purge-Date  | Purge-Time           | 772 Deletions        | 773 Deletions"
"RTN","HLUOPT5",37,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLUOPT5",38,0)
 W !,?12,"| Max Hr = ",$J(HOLD(1)/(3600),0,1)
"RTN","HLUOPT5",39,0)
 W ?35,"| Max # = ",$FN(HOLD(2),",")
"RTN","HLUOPT5",40,0)
 W ?58,"| Max # = ",$FN(HOLD(3),",")
"RTN","HLUOPT5",41,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLUOPT5",42,0)
 ;
"RTN","HLUOPT5",43,0)
 S DATE=0
"RTN","HLUOPT5",44,0)
 F  S DATE=$O(HOLD(DATE)) Q:'DATE  D
"RTN","HLUOPT5",45,0)
 .
"RTN","HLUOPT5",46,0)
 .  QUIT:DATE'?7N1"."1.N  ;->
"RTN","HLUOPT5",47,0)
 .  S TXT=$$SDT^HLUOPT4(DATE)_" |"
"RTN","HLUOPT5",48,0)
 .
"RTN","HLUOPT5",49,0)
 .  S DATA=HOLD(DATE) ; Get data...
"RTN","HLUOPT5",50,0)
 .
"RTN","HLUOPT5",51,0)
 .  S VAL=$P(DATA,U) ; Time difference...
"RTN","HLUOPT5",52,0)
 .  D PAD(VAL,21,1)
"RTN","HLUOPT5",53,0)
 .
"RTN","HLUOPT5",54,0)
 .  S VAL=$P(DATA,U,2) ; #772 deleted...
"RTN","HLUOPT5",55,0)
 .  D PAD(VAL,21,2)
"RTN","HLUOPT5",56,0)
 .
"RTN","HLUOPT5",57,0)
 .  S VAL=$P(DATA,U,3) ; #773 deleted...
"RTN","HLUOPT5",58,0)
 .  D PAD(VAL,21,3)
"RTN","HLUOPT5",59,0)
 .
"RTN","HLUOPT5",60,0)
 .  W !,TXT
"RTN","HLUOPT5",61,0)
 ;
"RTN","HLUOPT5",62,0)
 Q
"RTN","HLUOPT5",63,0)
 ;
"RTN","HLUOPT5",64,0)
PAD(NUM,COL,MULTNO) ; Add VAL to TXT...
"RTN","HLUOPT5",65,0)
 ; TXT -- req
"RTN","HLUOPT5",66,0)
 N CHAR
"RTN","HLUOPT5",67,0)
 S MULT=MULT(MULTNO)
"RTN","HLUOPT5",68,0)
 S CHAR=$S(MULT:$E($$REPEAT^XLFSTR("=",NUM\MULT),1,COL),1:"")
"RTN","HLUOPT5",69,0)
 S CHAR=$E(CHAR_$$REPEAT^XLFSTR(" ",COL),1,COL)
"RTN","HLUOPT5",70,0)
 S CHAR=CHAR_$S(MULTNO'=3:" |",1:"")
"RTN","HLUOPT5",71,0)
 S TXT=TXT_CHAR
"RTN","HLUOPT5",72,0)
 Q
"RTN","HLUOPT5",73,0)
 ;
"RTN","HLUOPT5",74,0)
HOLD(NUM,VAL) ; Update HOLD(#)...
"RTN","HLUOPT5",75,0)
 S:'$D(HOLD(NUM)) HOLD(NUM)=VAL
"RTN","HLUOPT5",76,0)
 S:VAL>HOLD(NUM) HOLD(NUM)=VAL ; Largest value...
"RTN","HLUOPT5",77,0)
 Q
"RTN","HLUOPT5",78,0)
 ;
"RTN","HLUOPT5",79,0)
GRAPHONE(XTMP) ; Display graph bar for one XTMP entry...
"RTN","HLUOPT5",80,0)
 ;
"RTN","HLUOPT5",81,0)
 Q
"RTN","HLUOPT5",82,0)
 ;
"RTN","HLUOPT5",83,0)
SHOWALL(XTMP) ; Show all information
"RTN","HLUOPT5",84,0)
 N I,ACTIVE,COLNO,CURR,LAST,PCE1,PCE2,PCE3,PCE4,PCE5,PCE6,PCE7
"RTN","HLUOPT5",85,0)
 N PCE8,PCE9,PCE10,PCE11,PCE12,PCE13,PCE14,PMT
"RTN","HLUOPT5",86,0)
 S COLNO=5
"RTN","HLUOPT5",87,0)
 F  D  Q:'$$BTE(PMT,1,120)  Q:'ACTIVE
"RTN","HLUOPT5",88,0)
 .  S RUN=$G(^XTMP(XTMP,"RUN")) I RUN']"" W "  no data..." QUIT  ;->
"RTN","HLUOPT5",89,0)
 .  F I=1:1:16 S CURR(I)=$P(RUN,U,I)
"RTN","HLUOPT5",90,0)
 .  F I=1:1:16 S @("PCE"_I)=$P(RUN,U,I)
"RTN","HLUOPT5",91,0)
 .  S PCE2=$$FMTE^XLFDT(PCE2),PCE3=$$FMTE^XLFDT(PCE3),PCE4=$$FMTE^XLFDT(PCE4)
"RTN","HLUOPT5",92,0)
 .  W !!,$$CJ^XLFSTR(" "_$$FMTE^XLFDT($$NOW^XLFDT)_"  ["_XTMP_"] ",IOM,"=")
"RTN","HLUOPT5",93,0)
 .  W !,$$D(2),?COLNO,"Start time: ",?(COLNO+25),PCE2,$$S(2)
"RTN","HLUOPT5",94,0)
 .  W !,$$D(3),?COLNO,"Last timestamp: ",?(COLNO+25),PCE3,$$S(3)
"RTN","HLUOPT5",95,0)
 .  W !,$$D(4),?COLNO,"End time: ",?(COLNO+25),PCE4,$$S(4)
"RTN","HLUOPT5",96,0)
 .  S PMT=$S(PCE4]"":"Press RETURN to exit... ",1:"Wait 120 seconds for refresh, or enter '^' to exit... ")
"RTN","HLUOPT5",97,0)
 .  S ACTIVE=$S(PCE4]"":0,1:1) ; Is last job still running?
"RTN","HLUOPT5",98,0)
 .  W !,$$D(5),?COLNO,"Status: ",?(COLNO+25),$J(PCE5,9),$$S(5,9)
"RTN","HLUOPT5",99,0)
 .  W !,$$D(6),?COLNO,"Location: ",?(COLNO+25),$J(PCE6,9),$$S(6,9)
"RTN","HLUOPT5",100,0)
 .  W !,$$D(1),?COLNO,"Task number: ",?(COLNO+25),$J(PCE1,9),$$S(1,9)
"RTN","HLUOPT5",101,0)
 .  W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLUOPT5",102,0)
 .  W !,$$D(7),?COLNO,"#772 reviewed: ",?(COLNO+25),$J(PCE7,9),$$S(7,9)
"RTN","HLUOPT5",103,0)
 .  W !,$$D(12),?COLNO,"#772 revw'd w/o purging: ",?(COLNO+25),$J(PCE12,9),$$S(12,9)
"RTN","HLUOPT5",104,0)
 .  W !,$$D(11),?COLNO,"Last 772 reviewed: ",?(COLNO+25),$J(PCE11,9),$$S(11,9)
"RTN","HLUOPT5",105,0)
 .  S X=$$D(11) I X']"" W $$SDT^HLUOPT4(PCE15)
"RTN","HLUOPT5",106,0)
 .  W !,$$D(8),?COLNO,"#772 purged: ",?(COLNO+25),$J(PCE8,9),$$S(8,9)
"RTN","HLUOPT5",107,0)
 .  W !,$$REPEAT^XLFSTR("-",IOM)
"RTN","HLUOPT5",108,0)
 .  W !,$$D(9),?COLNO,"#773 reviewed: ",?(COLNO+25),$J(PCE9,9),$$S(9,9)
"RTN","HLUOPT5",109,0)
 .  W !,$$D(14),?COLNO,"#773 revw'd w/o purging: ",?(COLNO+25),$J(PCE14,9),$$S(14,9)
"RTN","HLUOPT5",110,0)
 .  W !,$$D(13),?COLNO,"Last 773 reviewed: ",?(COLNO+25),$J(PCE13,9),$$S(13,9)
"RTN","HLUOPT5",111,0)
 .  S X=$$D(13) I X']"" W $$SDT^HLUOPT4(PCE16)
"RTN","HLUOPT5",112,0)
 .  W !,$$D(10),?COLNO,"#773 purged: ",?(COLNO+25),$J(PCE10,9),$$S(10,9)
"RTN","HLUOPT5",113,0)
 .  F I=1:1:14 S LAST(I)=$P(RUN,U,I)
"RTN","HLUOPT5",114,0)
 QUIT
"RTN","HLUOPT5",115,0)
 ;
"RTN","HLUOPT5",116,0)
D(NO) ; Any change since last display?
"RTN","HLUOPT5",117,0)
 QUIT:'$D(LAST) "" ;->
"RTN","HLUOPT5",118,0)
 QUIT:CURR(NO)=LAST(NO) "" ;->
"RTN","HLUOPT5",119,0)
 QUIT "->"
"RTN","HLUOPT5",120,0)
 ;
"RTN","HLUOPT5",121,0)
S(NO,COL) ; Display previous value....
"RTN","HLUOPT5",122,0)
 N TXT
"RTN","HLUOPT5",123,0)
 S TXT="",COL=+$G(COL)
"RTN","HLUOPT5",124,0)
 QUIT:'$D(LAST) $J("",COL) ;->
"RTN","HLUOPT5",125,0)
 QUIT:CURR(NO)=LAST(NO) $J("",COL) ;->
"RTN","HLUOPT5",126,0)
 S TXT=$E($$REPEAT^XLFSTR("_",IOM),1,53-$X)
"RTN","HLUOPT5",127,0)
 I NO>3 S TXT=TXT_LAST(NO) QUIT $J(TXT,COL) ;->
"RTN","HLUOPT5",128,0)
 I LAST(NO)?7N.E W $J(TXT_$$FMTE^XLFDT(LAST(NO)),COL)
"RTN","HLUOPT5",129,0)
 QUIT ""
"RTN","HLUOPT5",130,0)
 ;
"RTN","HLUOPT5",131,0)
BTE(PMT,FF,TIMEOUT) ;
"RTN","HLUOPT5",132,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLUOPT5",133,0)
 F X=1:1:$G(FF) W !
"RTN","HLUOPT5",134,0)
 S DIR(0)="EA",DIR("A")=PMT
"RTN","HLUOPT5",135,0)
 S:$G(TIMEOUT) DIR("T")=TIMEOUT
"RTN","HLUOPT5",136,0)
 D ^DIR
"RTN","HLUOPT5",137,0)
 QUIT:$D(DUOUT) "" ;->
"RTN","HLUOPT5",138,0)
 QUIT $S(Y=1!($D(DIRUT)):1,1:"") ; 1... if RETURN or timeout...
"RTN","HLUOPT5",139,0)
 ;
"RTN","HLUOPT5",140,0)
EOR ;HLUOPT5 - Purging Entries in file #772 and #773 ;12/10/02 16:37
"RTN","HLUOPT6")
0^5^B30116972
"RTN","HLUOPT6",1,0)
HLUOPT6 ;CIOFO-O/LJA - Fix zero node of file 772 or 773 ;02/04/2004 09:02
"RTN","HLUOPT6",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLUOPT6",3,0)
 ;
"RTN","HLUOPT6",4,0)
 QUIT
"RTN","HLUOPT6",5,0)
 ;
"RTN","HLUOPT6",6,0)
 ; This utility queues a background job to recalculate and reset 
"RTN","HLUOPT6",7,0)
 ; pieces 3 (last IEN) and 4 (# entries) in the zero nodes for
"RTN","HLUOPT6",8,0)
 ; the HL Message Text file (#772) and the HL Message Administration
"RTN","HLUOPT6",9,0)
 ; file (#773).
"RTN","HLUOPT6",10,0)
 ;
"RTN","HLUOPT6",11,0)
FIXZERO ; Reset piece 3 & 4 of zero node of file 772 &/or 773...
"RTN","HLUOPT6",12,0)
 N FILE,GBL,IOINHI,IOINORM,LIST,X,Y
"RTN","HLUOPT6",13,0)
 D HD
"RTN","HLUOPT6",14,0)
 D EX
"RTN","HLUOPT6",15,0)
 S X="IOINHI;IOINORM" D ENDR^%ZISS
"RTN","HLUOPT6",16,0)
 W !!,?3,IOINHI,"Note:",IOINORM,"  ",IOINHI
"RTN","HLUOPT6",17,0)
 W "This utility should be run when no purge processes are running.",IOINORM
"RTN","HLUOPT6",18,0)
 ;
"RTN","HLUOPT6",19,0)
 F  Q:($Y+4)>IOSL  W !
"RTN","HLUOPT6",20,0)
 QUIT:'$$BTE("Press RETURN to continue, or '^' to exit... ")  ;->
"RTN","HLUOPT6",21,0)
 ;
"RTN","HLUOPT6",22,0)
 D HD
"RTN","HLUOPT6",23,0)
 ;
"RTN","HLUOPT6",24,0)
 D FILE(.LIST) QUIT:'$D(LIST)  ;->
"RTN","HLUOPT6",25,0)
 W !!,"The process which fixes the zero node will now be queued to a background job."
"RTN","HLUOPT6",26,0)
 W !,"When complete, a verification Mailman message will be sent to you on this"
"RTN","HLUOPT6",27,0)
 W !,"system."
"RTN","HLUOPT6",28,0)
 S X=$$BTE("Press RETURN to queue job, or '^' to exit... ",1) I 'X D  QUIT  ;->
"RTN","HLUOPT6",29,0)
 .  W "   exiting... "
"RTN","HLUOPT6",30,0)
 D ZTSK
"RTN","HLUOPT6",31,0)
 S X=$$BTE("Press RETURN to exit... ",1)
"RTN","HLUOPT6",32,0)
 Q
"RTN","HLUOPT6",33,0)
 ;
"RTN","HLUOPT6",34,0)
ZTSK ;
"RTN","HLUOPT6",35,0)
 N ZTDESC,ZTDTH,ZTIO,ZTRTN,ZTSK
"RTN","HLUOPT6",36,0)
 S ZTIO="",ZTDTH=$H,ZTDESC="HL7 Zero Node Correction"
"RTN","HLUOPT6",37,0)
 S ZTRTN="QUEUE^HLUOPT6"
"RTN","HLUOPT6",38,0)
 S ZTSAVE("LIST(")=""
"RTN","HLUOPT6",39,0)
 D ^%ZTLOAD
"RTN","HLUOPT6",40,0)
 W !!,"Queued to task# ",ZTSK,"..."
"RTN","HLUOPT6",41,0)
 QUIT
"RTN","HLUOPT6",42,0)
 ;
"RTN","HLUOPT6",43,0)
QUEUE ;
"RTN","HLUOPT6",44,0)
 N FILE,ZERO
"RTN","HLUOPT6",45,0)
 S FILE=0
"RTN","HLUOPT6",46,0)
 F  S FILE=$O(LIST(FILE)) Q:FILE'>0  D
"RTN","HLUOPT6",47,0)
 .  D CORR(+FILE,.ZERO)
"RTN","HLUOPT6",48,0)
 D MAIL
"RTN","HLUOPT6",49,0)
 Q
"RTN","HLUOPT6",50,0)
 ;
"RTN","HLUOPT6",51,0)
CORR(FILE,ZERO) ; Correct zero node for file...
"RTN","HLUOPT6",52,0)
 ; NOTE: No purging actions should be occurring now...
"RTN","HLUOPT6",53,0)
 N CT,GBL,GBL0,IEN,LAST,NEW0
"RTN","HLUOPT6",54,0)
 ;
"RTN","HLUOPT6",55,0)
 S GBL=$S(FILE=772:"^HL(772)",1:"^HLMA")
"RTN","HLUOPT6",56,0)
 S GBL0=$S(FILE=772:"^HL(772,0)",1:"^HLMA(0)")
"RTN","HLUOPT6",57,0)
 S ZERO(1,FILE)=@GBL0
"RTN","HLUOPT6",58,0)
 ;
"RTN","HLUOPT6",59,0)
 S CT=0,IEN=0,LAST=""
"RTN","HLUOPT6",60,0)
 F  S IEN=$O(@GBL@(IEN)) Q:'IEN  D
"RTN","HLUOPT6",61,0)
 .  QUIT:$P($G(@GBL@(+IEN,0)),U)']""  ;->
"RTN","HLUOPT6",62,0)
 .  S CT=CT+1,LAST=IEN
"RTN","HLUOPT6",63,0)
 ;
"RTN","HLUOPT6",64,0)
 S (NEW0,ZERO(2,FILE))=$P(ZERO(1,FILE),U,1,2)_U_LAST_U_CT
"RTN","HLUOPT6",65,0)
 ;
"RTN","HLUOPT6",66,0)
 I FILE=772 D
"RTN","HLUOPT6",67,0)
 .  L +^HL(772,0):30  ; Reset zero node even if fail...
"RTN","HLUOPT6",68,0)
 .  S ^HL(772,0)=NEW0
"RTN","HLUOPT6",69,0)
 .  L -^HL(772,0)
"RTN","HLUOPT6",70,0)
 ;
"RTN","HLUOPT6",71,0)
 I FILE=773 D
"RTN","HLUOPT6",72,0)
 .  L +^HLMA(0):30
"RTN","HLUOPT6",73,0)
 .  S ^HLMA(0)=NEW0
"RTN","HLUOPT6",74,0)
 .  L -^HLMA(0)
"RTN","HLUOPT6",75,0)
 ;
"RTN","HLUOPT6",76,0)
 Q
"RTN","HLUOPT6",77,0)
 ;
"RTN","HLUOPT6",78,0)
MAIL ; Send Mailman message.
"RTN","HLUOPT6",79,0)
 N NO,TEXT,XMDUZ,XMSUB,XMTEXT,XMZ
"RTN","HLUOPT6",80,0)
 S XMDUZ=.5,XMSUB="HL7 Zero Node Correction"
"RTN","HLUOPT6",81,0)
 S XMTEXT="^TMP("_$J_",""HLMAILMSG"","
"RTN","HLUOPT6",82,0)
 KILL ^TMP($J,"HLMAILMSG")
"RTN","HLUOPT6",83,0)
 S NO=0
"RTN","HLUOPT6",84,0)
 D MSGBODY
"RTN","HLUOPT6",85,0)
 S XMY(DUZ)=""
"RTN","HLUOPT6",86,0)
 D ^XMD
"RTN","HLUOPT6",87,0)
 KILL ^TMP($J,"HLMAILMSG")
"RTN","HLUOPT6",88,0)
 QUIT
"RTN","HLUOPT6",89,0)
 ;
"RTN","HLUOPT6",90,0)
MSGBODY ; Add message bode...
"RTN","HLUOPT6",91,0)
 ; LIST,ZERO -- req
"RTN","HLUOPT6",92,0)
 N CT,FILE
"RTN","HLUOPT6",93,0)
 S CT=-1,FILE=0 F  S FILE=$O(LIST(FILE)) Q:'FILE  S CT=CT+1
"RTN","HLUOPT6",94,0)
 D MAILADD("The zero node for file"_$S(CT:"s 772 & 773 have",1:" "_$O(LIST(0))_" has")_" now been reset.")
"RTN","HLUOPT6",95,0)
 S FILE=0
"RTN","HLUOPT6",96,0)
 F  S FILE=$O(LIST(FILE)) Q:'FILE  D
"RTN","HLUOPT6",97,0)
 .  D MAILADD("")
"RTN","HLUOPT6",98,0)
 .  D MAILADD("File "_FILE_" zero node reset from... "_$G(ZERO(1,FILE)))
"RTN","HLUOPT6",99,0)
 .  D MAILADD("                           to... "_$G(ZERO(2,FILE)))
"RTN","HLUOPT6",100,0)
 Q
"RTN","HLUOPT6",101,0)
 ;
"RTN","HLUOPT6",102,0)
MAILADD(T) S NO=$G(NO)+1,^TMP($J,"HLMAILMSG",NO)=T
"RTN","HLUOPT6",103,0)
 QUIT
"RTN","HLUOPT6",104,0)
 ;
"RTN","HLUOPT6",105,0)
BTE(PMT,FF) ; 
"RTN","HLUOPT6",106,0)
 N DIR,DIRUT,DTOUT,DUOUT,X,Y
"RTN","HLUOPT6",107,0)
 F X=1:1:$G(FF) W !
"RTN","HLUOPT6",108,0)
 S DIR(0)="EA",DIR("A")=$G(PMT)
"RTN","HLUOPT6",109,0)
 D ^DIR
"RTN","HLUOPT6",110,0)
 QUIT:$D(DIRUT)!($D(DTOUT))!($D(DUOUT)) "" ;->
"RTN","HLUOPT6",111,0)
 Q $S(+Y=1:1,1:"")
"RTN","HLUOPT6",112,0)
 ;
"RTN","HLUOPT6",113,0)
FILE(LIST) ; Ask which files to correct..
"RTN","HLUOPT6",114,0)
 ; IOINHI,IOINORM -- req
"RTN","HLUOPT6",115,0)
 N DIR,DIRUT,DTOUT,DUOUT,TXT,X,Y
"RTN","HLUOPT6",116,0)
 KILL LIST
"RTN","HLUOPT6",117,0)
 W !!,"Select the file(s) now whose zero nodes should be corrected."
"RTN","HLUOPT6",118,0)
 W !!,?10,$$CJ^XLFSTR("Zero Node Current Value",60)
"RTN","HLUOPT6",119,0)
 W !,?10,$$REPEAT^XLFSTR("-",60)
"RTN","HLUOPT6",120,0)
 W !,?13,"^HL(772,0) = "
"RTN","HLUOPT6",121,0)
 D SH0($G(^HL(772,0)))
"RTN","HLUOPT6",122,0)
 W !,?13,"^HLMA(0) = "
"RTN","HLUOPT6",123,0)
 D SH0($G(^HLMA(0)))
"RTN","HLUOPT6",124,0)
 W !
"RTN","HLUOPT6",125,0)
 S DIR(0)="S^1:Correct file 772;2:Correct file 773;3:Correct both file 772 & 773"
"RTN","HLUOPT6",126,0)
 S DIR("A")="Select file(s) to correct"
"RTN","HLUOPT6",127,0)
 D ^DIR
"RTN","HLUOPT6",128,0)
 QUIT:$D(DIRUT)!($D(DTOUT))!($D(DUOUT))!(+Y'>0)  ;->
"RTN","HLUOPT6",129,0)
 S:+Y=1 LIST(772)=""
"RTN","HLUOPT6",130,0)
 S:+Y=2 LIST(773)=""
"RTN","HLUOPT6",131,0)
 I +Y=3 S LIST(772)="",LIST(773)=""
"RTN","HLUOPT6",132,0)
 Q
"RTN","HLUOPT6",133,0)
 ;
"RTN","HLUOPT6",134,0)
SH0(TXT) ; Highlight 3rd and 4th pieces...
"RTN","HLUOPT6",135,0)
 ; IOINHI,IOINORM -- req
"RTN","HLUOPT6",136,0)
 N PCE,VAL
"RTN","HLUOPT6",137,0)
 W $P(TXT,U,1,2),U,IOINHI,$P(TXT,U,3),IOINORM,U,IOINHI,$P(TXT,U,4),IOINORM
"RTN","HLUOPT6",138,0)
 Q
"RTN","HLUOPT6",139,0)
 ;
"RTN","HLUOPT6",140,0)
HD W @IOF,$$CJ^XLFSTR("File 772/773 Header Correction",IOM)
"RTN","HLUOPT6",141,0)
 W !,$$REPEAT^XLFSTR("=",IOM)
"RTN","HLUOPT6",142,0)
 QUIT
"RTN","HLUOPT6",143,0)
 ;
"RTN","HLUOPT6",144,0)
EX N I,T F I=1:1 S T=$T(EX+I) QUIT:T'[";;"  W !,$P(T,";;",2,99)
"RTN","HLUOPT6",145,0)
 ;;This utility corrects the zero node of the HL Message Text file (#772) and the
"RTN","HLUOPT6",146,0)
 ;;HL Message Administration file (#773.)  The following corrections will be made:
"RTN","HLUOPT6",147,0)
 ;;
"RTN","HLUOPT6",148,0)
 ;; - The last internal entry number will be found and set into piece 3 of the 
"RTN","HLUOPT6",149,0)
 ;;   file's zero node.  
"RTN","HLUOPT6",150,0)
 ;;
"RTN","HLUOPT6",151,0)
 ;; - The number of entries in the file being corrected will be recalculated and
"RTN","HLUOPT6",152,0)
 ;;   set into piece 4 of that file's zero node. 
"RTN","HLUOPT6",153,0)
 ;;
"RTN","HLUOPT6",154,0)
 ;;You may specify one or both of these files to be corrected.
"RTN","HLUOPT6",155,0)
 ;;
"RTN","HLUOPT6",156,0)
 ;;These files are corrected by a queued background job.  When the job completes,
"RTN","HLUOPT6",157,0)
 ;;you will be notified by email message.
"RTN","HLUOPT6",158,0)
 QUIT
"RTN","HLUOPT6",159,0)
 ;
"RTN","HLUOPT6",160,0)
EOR ; HLUOPT6 - Fix zero node of file 772 or 773 ;5/12/03 09:02
"RTN","HLUOPTF1")
0^45^B3550031
"RTN","HLUOPTF1",1,0)
HLUOPTF1 ;ALB/CJM-HL7 -Set Logic for the AI x-ref on file 773 ;02/04/2004
"RTN","HLUOPTF1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLUOPTF1",3,0)
 ;
"RTN","HLUOPTF1",4,0)
PXREF(IEN,STATUS) ;sets the AI x-ref on file 773 and the FAST PURGE DT/TM fields in file 772 and 773
"RTN","HLUOPTF1",5,0)
 ;Input:  IEN is the ien of record in file 773
"RTN","HLUOPTF1",6,0)
 ;        STATUS is the new value of the STATUS field
"RTN","HLUOPTF1",7,0)
 ;Output: none
"RTN","HLUOPTF1",8,0)
 ;
"RTN","HLUOPTF1",9,0)
 Q:'$G(IEN)
"RTN","HLUOPTF1",10,0)
 ;
"RTN","HLUOPTF1",11,0)
 ;don't set the x-ref if status is  not Successfully Completed 
"RTN","HLUOPTF1",12,0)
 Q:($G(STATUS)'=3)
"RTN","HLUOPTF1",13,0)
 ;
"RTN","HLUOPTF1",14,0)
 N NODE,WHEN,CHILD
"RTN","HLUOPTF1",15,0)
 ;
"RTN","HLUOPTF1",16,0)
 ;also not if DON'T PURGE field is set
"RTN","HLUOPTF1",17,0)
 Q:$P($G(^HLMA(IEN,2)),"^")=1
"RTN","HLUOPTF1",18,0)
 ;
"RTN","HLUOPTF1",19,0)
 ;also not if this isn't the initial message
"RTN","HLUOPTF1",20,0)
 S NODE=$G(^HLMA(IEN,0))
"RTN","HLUOPTF1",21,0)
 I $P(NODE,"^",6),$P(NODE,"^",6)'=IEN Q
"RTN","HLUOPTF1",22,0)
 ;
"RTN","HLUOPTF1",23,0)
 ;This record can be purged via FAST PURGE
"RTN","HLUOPTF1",24,0)
 ;determine the dt/tm the record can be purged
"RTN","HLUOPTF1",25,0)
 S WHEN=$$NOW^XLFDT
"RTN","HLUOPTF1",26,0)
 S WHEN=$$FMADD^XLFDT(WHEN,$$WAIT)
"RTN","HLUOPTF1",27,0)
 ;
"RTN","HLUOPTF1",28,0)
 ;set the FAST PURGE DT/TM and x-ref, and do the same for file 772 record
"RTN","HLUOPTF1",29,0)
 D SET(IEN,WHEN,+NODE)
"RTN","HLUOPTF1",30,0)
 ;
"RTN","HLUOPTF1",31,0)
 ;All the records in file 773 that point to this record (children) should be purged at the same time
"RTN","HLUOPTF1",32,0)
 S CHILD=0
"RTN","HLUOPTF1",33,0)
 F  S CHILD=$O(^HLMA("AF",IEN,CHILD)) Q:'CHILD  D:(CHILD'=IEN) SET(CHILD,WHEN,+$G(^HLMA(CHILD,0)))
"RTN","HLUOPTF1",34,0)
 Q
"RTN","HLUOPTF1",35,0)
 ;
"RTN","HLUOPTF1",36,0)
SET(IEN773,WHEN,IEN772) ;sets FAST PURGE DT/TM for and the AI x~ref for both file 772 & 773
"RTN","HLUOPTF1",37,0)
 ;Input:
"RTN","HLUOPTF1",38,0)
 ;   IEN773 - ien of record to be purged in file 773
"RTN","HLUOPTF1",39,0)
 ;   WHEN - date/time to purge
"RTN","HLUOPTF1",40,0)
 ;   IEN772 - ien of corresponding record in file 772
"RTN","HLUOPTF1",41,0)
 ;
"RTN","HLUOPTF1",42,0)
 N OLDWHEN
"RTN","HLUOPTF1",43,0)
 ;if the fast purge dt/tm changed, kill the old xref
"RTN","HLUOPTF1",44,0)
 S OLDWHEN=$P($G(^HLMA(IEN773,2)),"^",2)
"RTN","HLUOPTF1",45,0)
 I $L(OLDWHEN) K ^HLMA("AI",OLDWHEN,773,IEN773)
"RTN","HLUOPTF1",46,0)
 ;
"RTN","HLUOPTF1",47,0)
 ;set the FAST PURGE DATE
"RTN","HLUOPTF1",48,0)
 S $P(^HLMA(IEN773,2),"^",2)=WHEN
"RTN","HLUOPTF1",49,0)
 ;
"RTN","HLUOPTF1",50,0)
 ;set the AI x-ref
"RTN","HLUOPTF1",51,0)
 S ^HLMA("AI",WHEN,773,IEN773)=""
"RTN","HLUOPTF1",52,0)
 ;
"RTN","HLUOPTF1",53,0)
 ;do the same for the corresponding entry in file 772
"RTN","HLUOPTF1",54,0)
 I IEN772,$D(^HL(772,IEN772,0)) D
"RTN","HLUOPTF1",55,0)
 .;if the fast purge dt/tm changed, kill the old xref
"RTN","HLUOPTF1",56,0)
 .S OLDWHEN=$P($G(^HL(772,IEN772,2)),"^",2)
"RTN","HLUOPTF1",57,0)
 .I $L(OLDWHEN) K ^HLMA("AI",OLDWHEN,772,IEN772)
"RTN","HLUOPTF1",58,0)
 .;set the FAST PURGE DATE
"RTN","HLUOPTF1",59,0)
 .S $P(^HL(772,IEN772,2),"^",2)=WHEN
"RTN","HLUOPTF1",60,0)
 .;
"RTN","HLUOPTF1",61,0)
 .;set the AI x-ref
"RTN","HLUOPTF1",62,0)
 .S ^HLMA("AI",WHEN,772,IEN772)=""
"RTN","HLUOPTF1",63,0)
 Q
"RTN","HLUOPTF1",64,0)
 ;
"RTN","HLUOPTF1",65,0)
WAIT() ;
"RTN","HLUOPTF1",66,0)
 ;returns the wait time to purge completed messages from file 869.3
"RTN","HLUOPTF1",67,0)
 N IEN
"RTN","HLUOPTF1",68,0)
 S IEN=$O(^HLCS(869.3,0))
"RTN","HLUOPTF1",69,0)
 Q:'IEN 0
"RTN","HLUOPTF1",70,0)
 Q +$G(^HLCS(869.3,IEN,4))
"RTN","HLUOPTF2")
0^46^B36022035
"RTN","HLUOPTF2",1,0)
HLUOPTF2 ;ALB/CJM-HL7 -Fast Purge ;02/04/2004
"RTN","HLUOPTF2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109**;Oct 13, 1995
"RTN","HLUOPTF2",3,0)
 ;
"RTN","HLUOPTF2",4,0)
FAST1 ;entry point for FAST PURGE 1, called by the Event Monitor
"RTN","HLUOPTF2",5,0)
 I '$$COUNT D PURGE
"RTN","HLUOPTF2",6,0)
 Q
"RTN","HLUOPTF2",7,0)
FAST2 ;entry point for FAST PURGE 2, called by the Event Monitor
"RTN","HLUOPTF2",8,0)
 I $$COUNT=1 D PURGE
"RTN","HLUOPTF2",9,0)
 Q
"RTN","HLUOPTF2",10,0)
 ;
"RTN","HLUOPTF2",11,0)
START ;Interactive entry point, asks user whether or not to queue the Fast Purge
"RTN","HLUOPTF2",12,0)
 ;
"RTN","HLUOPTF2",13,0)
 N ASK,STOP
"RTN","HLUOPTF2",14,0)
 S STOP=1
"RTN","HLUOPTF2",15,0)
 S ASK=$$ASKYESNO^HLEMU("Do you want to queue the Fast Purge so that it operates in the background","YES")
"RTN","HLUOPTF2",16,0)
 I ASK D
"RTN","HLUOPTF2",17,0)
 .N ZTRTN,ZTDESC,ZTSAVE,ZTIO,ZTSK
"RTN","HLUOPTF2",18,0)
 .S ZTRTN="PURGE^HLUOPTF2"
"RTN","HLUOPTF2",19,0)
 .S ZTDESC="HL7 FAST PURGE UTILITY"
"RTN","HLUOPTF2",20,0)
 .S ZTIO=""
"RTN","HLUOPTF2",21,0)
 .S ZTSAVE("STOP")=1
"RTN","HLUOPTF2",22,0)
 .D ^%ZTLOAD
"RTN","HLUOPTF2",23,0)
 .W !,$S($D(ZTSK):"HL7 FAST PURGE UTILITY QUEUED, TASK="_ZTSK,1:"REQUEST CANCELLED")
"RTN","HLUOPTF2",24,0)
 E  I ASK=0 D
"RTN","HLUOPTF2",25,0)
 .W !,"Starting Fast Purge....",!
"RTN","HLUOPTF2",26,0)
 .D PURGE
"RTN","HLUOPTF2",27,0)
 K ^TMP("HLEVFLAG",$J)
"RTN","HLUOPTF2",28,0)
 Q
"RTN","HLUOPTF2",29,0)
STOP ;
"RTN","HLUOPTF2",30,0)
 ;entry point to ask the Fast Purge Job to stop
"RTN","HLUOPTF2",31,0)
 I $$COUNT>$G(^XTMP("HL7 FAST PURGE JOBS","STOP")),$$I^HLEMU($NA(^XTMP("HL7 FAST PURGE JOBS","STOP")),1)
"RTN","HLUOPTF2",32,0)
 Q
"RTN","HLUOPTF2",33,0)
COUNT() ;
"RTN","HLUOPTF2",34,0)
 ;returns the number of Fast Purge Jobs that are running
"RTN","HLUOPTF2",35,0)
 N COUNT,I
"RTN","HLUOPTF2",36,0)
 S COUNT=0
"RTN","HLUOPTF2",37,0)
 F I=1:1:20 D
"RTN","HLUOPTF2",38,0)
 .L ^XTMP("HL7 FAST PURGE JOBS",I):0
"RTN","HLUOPTF2",39,0)
 .I '$T D
"RTN","HLUOPTF2",40,0)
 ..S COUNT=COUNT+1
"RTN","HLUOPTF2",41,0)
 .E  D
"RTN","HLUOPTF2",42,0)
 ..L -^XTMP("HL7 FAST PURGE JOBS",I)
"RTN","HLUOPTF2",43,0)
 Q COUNT
"RTN","HLUOPTF2",44,0)
 ;
"RTN","HLUOPTF2",45,0)
PURGE ;entry point for the FAST PURGE
"RTN","HLUOPTF2",46,0)
 ;
"RTN","HLUOPTF2",47,0)
 ;Variables:
"RTN","HLUOPTF2",48,0)
 ;  CHECKAT - next time to check in with TaskMan, Job Monitor, andEvent Logging, set every 10 minutes
"RTN","HLUOPTF2",49,0)
 ;  HOUR - the date and time to 1 hour precision that this process is currently purging, each hour is locked before purging
"RTN","HLUOPTF2",50,0)
 ; IEN772 - entry in file 772 identified for purging
"RTN","HLUOPTF2",51,0)
 ; IEN773 - entry in file 773 identified for purging
"RTN","HLUOPTF2",52,0)
 ; LASTCHK - a simple count, the time is checked everytime this count reaches 500 - for efficiency, do not want to check the time after purging every entry
"RTN","HLUOPTF2",53,0)
 ; CNT773 - count to report for EVENT LOGGING of entries purged (file 773)
"RTN","HLUOPTF2",54,0)
 ; CNT772 - count to report for EVENT LOGGING of entries purged (file 772)
"RTN","HLUOPTF2",55,0)
 ; QUIT - set to 1 when signaled to stop via TaskMan
"RTN","HLUOPTF2",56,0)
 ; TIME - time currently being processed on the AI x-ref, file 773
"RTN","HLUOPTF2",57,0)
 ; 
"RTN","HLUOPTF2",58,0)
 ;
"RTN","HLUOPTF2",59,0)
 I $G(STOP)=1 D
"RTN","HLUOPTF2",60,0)
 .;setting this flag allows the job to run outside of Process Monitorng
"RTN","HLUOPTF2",61,0)
 .S ^TMP("HLEVFLAG",$J)="STOP"
"RTN","HLUOPTF2",62,0)
 ;
"RTN","HLUOPTF2",63,0)
 N LCNT,CNT773,CNT772,HOUR,LASTCHK,TIME,IEN772,IEN773,CHECKAT,QUIT,VAR,I
"RTN","HLUOPTF2",64,0)
 S (TIME,HOUR,CNT773,CNT772,LCOUNT,QUIT)=0
"RTN","HLUOPTF2",65,0)
 ;
"RTN","HLUOPTF2",66,0)
 D START^HLEVAPI(.VAR)
"RTN","HLUOPTF2",67,0)
 ;
"RTN","HLUOPTF2",68,0)
 S CHECKAT=$$FMADD^XLFDT($$NOW^XLFDT,,,10)
"RTN","HLUOPTF2",69,0)
 ; 
"RTN","HLUOPTF2",70,0)
 ;let everyone know that there is 1 more purge job running - maximum of 20 Fast Purges running at once
"RTN","HLUOPTF2",71,0)
 F I=1:1:20 L ^XTMP("HL7 FAST PURGE JOBS",I):0 Q:$T
"RTN","HLUOPTF2",72,0)
 ;
"RTN","HLUOPTF2",73,0)
 ;loop until signaled to stop or there is no work for a while
"RTN","HLUOPTF2",74,0)
 I $T F  D  Q:QUIT
"RTN","HLUOPTF2",75,0)
 .S:'TIME HOUR=$$FINDHOUR(HOUR) S:HOUR TIME=HOUR-.00000001
"RTN","HLUOPTF2",76,0)
 .;
"RTN","HLUOPTF2",77,0)
 .;wasn't able to get an hour to lock
"RTN","HLUOPTF2",78,0)
 .I 'HOUR D  Q
"RTN","HLUOPTF2",79,0)
 ..;
"RTN","HLUOPTF2",80,0)
 ..;if there has been no work for a while then quit
"RTN","HLUOPTF2",81,0)
 ..I $$NOW^XLFDT>CHECKAT,CNT773<2000 D
"RTN","HLUOPTF2",82,0)
 ...S QUIT=$$CHECKIN(.CHECKAT,.CNT773,.CNT772,.LCOUNT)
"RTN","HLUOPTF2",83,0)
 ...S QUIT=1
"RTN","HLUOPTF2",84,0)
 ..E  D
"RTN","HLUOPTF2",85,0)
 ...S QUIT=$$CHECKIN(.CHECKAT,.CNT773,.CNT772,.LCOUNT)
"RTN","HLUOPTF2",86,0)
 ...D EVENT(.CNT773,.CNT772)
"RTN","HLUOPTF2",87,0)
 ...Q:QUIT
"RTN","HLUOPTF2",88,0)
 ...D PAUSE
"RTN","HLUOPTF2",89,0)
 .;
"RTN","HLUOPTF2",90,0)
 .;at this point, an hour has been locked, so delete all the entries for that hour
"RTN","HLUOPTF2",91,0)
 .F  S TIME=$O(^HLMA("AI",TIME)) D  Q:'TIME  Q:QUIT
"RTN","HLUOPTF2",92,0)
 ..I ('TIME)!($E(TIME,1,10)>HOUR) S TIME=0 Q
"RTN","HLUOPTF2",93,0)
 ..S LCOUNT=LCOUNT+1
"RTN","HLUOPTF2",94,0)
 ..I LCOUNT>500 S QUIT=$$CHECKIN(.CHECKAT,.CNT773,.CNT772,.LCOUNT) Q:QUIT
"RTN","HLUOPTF2",95,0)
 ..S (IEN772,IEN773)=0
"RTN","HLUOPTF2",96,0)
 ..F  S IEN773=$O(^HLMA("AI",TIME,773,IEN773)) Q:'IEN773  D
"RTN","HLUOPTF2",97,0)
 ...S CNT773=CNT773+1
"RTN","HLUOPTF2",98,0)
 ...D DEL773^HLUOPT3(IEN773)
"RTN","HLUOPTF2",99,0)
 ...;
"RTN","HLUOPTF2",100,0)
 ..F  S IEN772=$O(^HLMA("AI",TIME,772,IEN772)) Q:'IEN772  D
"RTN","HLUOPTF2",101,0)
 ...S CNT772=CNT772+1
"RTN","HLUOPTF2",102,0)
 ...D DEL772^HLUOPT3(IEN772)
"RTN","HLUOPTF2",103,0)
 ..;
"RTN","HLUOPTF2",104,0)
 ..; make sure that no more records are on this x-ref for that time - could only happen in the case of corruption of some sort
"RTN","HLUOPTF2",105,0)
 ..K ^HLMA("AI",TIME)
"RTN","HLUOPTF2",106,0)
 ;
"RTN","HLUOPTF2",107,0)
 ;unlock the last hour currently being held
"RTN","HLUOPTF2",108,0)
 L:HOUR -^HLMA("AI",HOUR)
"RTN","HLUOPTF2",109,0)
 ;
"RTN","HLUOPTF2",110,0)
 ;let everyone know that there is 1 less purge job running
"RTN","HLUOPTF2",111,0)
 F I=1:1:20 L -^XTMP("HL7 FAST PURGE JOBS",I)
"RTN","HLUOPTF2",112,0)
 D CHECKOUT^HLEVAPI
"RTN","HLUOPTF2",113,0)
 K ^TMP("HLEVFLAG",$J)
"RTN","HLUOPTF2",114,0)
 Q
"RTN","HLUOPTF2",115,0)
 ;
"RTN","HLUOPTF2",116,0)
PAUSE ;sleep for 10 SECONDS
"RTN","HLUOPTF2",117,0)
 H 10
"RTN","HLUOPTF2",118,0)
 Q
"RTN","HLUOPTF2",119,0)
 ;
"RTN","HLUOPTF2",120,0)
CHECKIN(CHECKAT,CNT773,CNT772,LCOUNT) ;
"RTN","HLUOPTF2",121,0)
 ;if NOW>CHECKAT then:
"RTN","HLUOPTF2",122,0)
 ;  1) check in with TaskMan
"RTN","HLUOPTF2",123,0)
 ;  2) send a new event to the event monitor
"RTN","HLUOPTF2",124,0)
 ;  3) reset CHECKAT for 10 minutes in the future
"RTN","HLUOPTF2",125,0)
 ;  4) as an alternative to TaskMan, check if special Stop Fast Purge option has been used
"RTN","HLUOPTF2",126,0)
 ;
"RTN","HLUOPTF2",127,0)
 ;Input:
"RTN","HLUOPTF2",128,0)
 ;  CHECKAT - the end of the current 10 minute time period
"RTN","HLUOPTF2",129,0)
 ;  CNT773 - number of records in file 773 purged since the last time Event Logging was updated
"RTN","HLUOPTF2",130,0)
 ;  CNT772 - number of records in file 772 purged since the last time Event Logging was updated
"RTN","HLUOPTF2",131,0)
 ;Output:
"RTN","HLUOPTF2",132,0)
 ;   Function returns 1 if the Fast Purge should stop, 0 otherwise
"RTN","HLUOPTF2",133,0)
 ;   LCOUNT is reset to 0 **pass by reference**
"RTN","HLUOPTF2",134,0)
 ;   CNT773 and CNT772 are set to 0 if reported to Event Logging **pass by reference**
"RTN","HLUOPTF2",135,0)
 ;   CHECKAT is reset to 10 minute sin the future if the time is up **pass by reference**
"RTN","HLUOPTF2",136,0)
 ;
"RTN","HLUOPTF2",137,0)
 N NOW,QUIT
"RTN","HLUOPTF2",138,0)
 S QUIT=0
"RTN","HLUOPTF2",139,0)
 ;
"RTN","HLUOPTF2",140,0)
 S NOW=$$NOW^XLFDT
"RTN","HLUOPTF2",141,0)
 I NOW>CHECKAT D
"RTN","HLUOPTF2",142,0)
 .D EVENT(.CNT773,.CNT772)
"RTN","HLUOPTF2",143,0)
 .S CHECKAT=$$FMADD^XLFDT(NOW,,,10)
"RTN","HLUOPTF2",144,0)
 .I '$D(ZTQUEUED) D
"RTN","HLUOPTF2",145,0)
 ..W "."
"RTN","HLUOPTF2",146,0)
 .E  D
"RTN","HLUOPTF2",147,0)
 ..;check in with the Job Monitor
"RTN","HLUOPTF2",148,0)
 ..D CHECKIN^HLEVAPI
"RTN","HLUOPTF2",149,0)
 ..S QUIT=$$S^ZTLOAD
"RTN","HLUOPTF2",150,0)
 ..S:QUIT ZTSTOP=1
"RTN","HLUOPTF2",151,0)
 ;
"RTN","HLUOPTF2",152,0)
 ;Check if the special option has been used to stop the purge
"RTN","HLUOPTF2",153,0)
 I $G(^XTMP("HL7 FAST PURGE JOBS","STOP"))>0 D
"RTN","HLUOPTF2",154,0)
 .S QUIT=1
"RTN","HLUOPTF2",155,0)
 .I $$I^HLEMU($NA(^XTMP("HL7 FAST PURGE JOBS","STOP")),-1)
"RTN","HLUOPTF2",156,0)
 ;
"RTN","HLUOPTF2",157,0)
 S LCOUNT=0
"RTN","HLUOPTF2",158,0)
 Q QUIT
"RTN","HLUOPTF2",159,0)
 ;
"RTN","HLUOPTF2",160,0)
FINDHOUR(HOUR) ;
"RTN","HLUOPTF2",161,0)
 ;Finds the next dt/tm to the hour on the AI x-ref of file 773 that can be locked, returns 0 on failure
"RTN","HLUOPTF2",162,0)
 N QUIT,NOW
"RTN","HLUOPTF2",163,0)
 S QUIT=0
"RTN","HLUOPTF2",164,0)
 ;
"RTN","HLUOPTF2",165,0)
 ;unlock the last hour currently being held
"RTN","HLUOPTF2",166,0)
 L:HOUR -^HLMA("AI",HOUR)
"RTN","HLUOPTF2",167,0)
 ;
"RTN","HLUOPTF2",168,0)
 S NOW=$$NOW^XLFDT
"RTN","HLUOPTF2",169,0)
 ;
"RTN","HLUOPTF2",170,0)
 ;if this is the first time through then start with the first entry on the x-ref
"RTN","HLUOPTF2",171,0)
 I 'HOUR D  Q:QUIT HOUR
"RTN","HLUOPTF2",172,0)
 .S HOUR=$O(^HLMA("AI",0))
"RTN","HLUOPTF2",173,0)
 .;
"RTN","HLUOPTF2",174,0)
 .;any records to purge?
"RTN","HLUOPTF2",175,0)
 .I 'HOUR S QUIT=1 Q
"RTN","HLUOPTF2",176,0)
 .;
"RTN","HLUOPTF2",177,0)
 .;if so, quit if the next purgeable record is for the future
"RTN","HLUOPTF2",178,0)
 .I HOUR>NOW S HOUR=0 Q
"RTN","HLUOPTF2",179,0)
 .;
"RTN","HLUOPTF2",180,0)
 .S HOUR=$E(HOUR,1,10)
"RTN","HLUOPTF2",181,0)
 .L +^HLMA("AI",+HOUR):0 S:$T QUIT=1
"RTN","HLUOPTF2",182,0)
 ;
"RTN","HLUOPTF2",183,0)
 S HOUR=$E(HOUR,1,10)
"RTN","HLUOPTF2",184,0)
 F  D  Q:QUIT
"RTN","HLUOPTF2",185,0)
 .;
"RTN","HLUOPTF2",186,0)
 .;look for the next entry at least 1 hour in the future
"RTN","HLUOPTF2",187,0)
 .S HOUR=$$FMADD^XLFDT(HOUR,,1)-.000000001
"RTN","HLUOPTF2",188,0)
 .S HOUR=$E($O(^HLMA("AI",HOUR)),1,10)
"RTN","HLUOPTF2",189,0)
 .I 'HOUR S QUIT=1 Q
"RTN","HLUOPTF2",190,0)
 .;
"RTN","HLUOPTF2",191,0)
 .;I the hour is in the future then the entries can not yet be purged
"RTN","HLUOPTF2",192,0)
 .I (HOUR>NOW) S HOUR=0,QUIT=1 Q
"RTN","HLUOPTF2",193,0)
 .;
"RTN","HLUOPTF2",194,0)
 .;check if this hour can be locked, if so this is the hour to be purged
"RTN","HLUOPTF2",195,0)
 .L +^HLMA("AI",+HOUR):0 I $T S QUIT=1
"RTN","HLUOPTF2",196,0)
 ;
"RTN","HLUOPTF2",197,0)
 Q HOUR
"RTN","HLUOPTF2",198,0)
 ;
"RTN","HLUOPTF2",199,0)
EVENT(CNT773,CNT772) ;
"RTN","HLUOPTF2",200,0)
 ;add the last number of records purged to event logging
"RTN","HLUOPTF2",201,0)
 N EVENT
"RTN","HLUOPTF2",202,0)
 I CNT773 D
"RTN","HLUOPTF2",203,0)
 .S EVENT=$$EVENT^HLEME("773 PURGE","HEALTH LEVEL SEVEN")
"RTN","HLUOPTF2",204,0)
 .I CNT773>1,$$INC^HLEME(EVENT,CNT773-1)
"RTN","HLUOPTF2",205,0)
 .S CNT773=0
"RTN","HLUOPTF2",206,0)
 I CNT772 D
"RTN","HLUOPTF2",207,0)
 .S EVENT=$$EVENT^HLEME("772 PURGE","HEALTH LEVEL SEVEN")
"RTN","HLUOPTF2",208,0)
 .I CNT772>1,$$INC^HLEME(EVENT,CNT772-1)
"RTN","HLUOPTF2",209,0)
 .S CNT772=0
"RTN","HLUOPTF2",210,0)
 Q
"RTN","HLUOPTF2",211,0)
 ;
"RTN","HLUOPTF2",212,0)
CHECK1() ;called by the Master Job to determine whether 
"RTN","HLUOPTF2",213,0)
 ;FAST HL7 PURGE #1 should run.
"RTN","HLUOPTF2",214,0)
 ;Output:
"RTN","HLUOPTF2",215,0)
 ;  function returns 1 if yes, 0 if no
"RTN","HLUOPTF2",216,0)
 ;
"RTN","HLUOPTF2",217,0)
 I $$COUNT^HLEVAPI3("FAST HL7 PURGE #1")
"RTN","HLUOPTF2",218,0)
 Q '$T
"RTN","HLUOPTF2",219,0)
 ;
"RTN","HLUOPTF2",220,0)
CHECK2() ;called by the Master Job to determine whether 
"RTN","HLUOPTF2",221,0)
 ;FAST HL7 PURGE #2 should run.
"RTN","HLUOPTF2",222,0)
 ;Output:
"RTN","HLUOPTF2",223,0)
 ;  function returns 1 if yes, 0 if no
"RTN","HLUOPTF2",224,0)
 ;
"RTN","HLUOPTF2",225,0)
 I $$COUNT^HLEVAPI3("FAST HL7 PURGE #1"),'$$COUNT^HLEVAPI3("FAST HL7 PURGE #2")
"RTN","HLUOPTF2",226,0)
 Q $T
"RTN","HLUTIL")
0^85^B15417895
"RTN","HLUTIL",1,0)
HLUTIL ;SFISC/RJH- Utilities for HL7 TCP    ;08/24/2000  16:55
"RTN","HLUTIL",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**36,19,57,64,66,109**;Oct 13, 1995
"RTN","HLUTIL",3,0)
 Q
"RTN","HLUTIL",4,0)
 ;For TCP only
"RTN","HLUTIL",5,0)
MSGSTAT(X) ;message status
"RTN","HLUTIL",6,0)
 ;input value:   X = message id
"RTN","HLUTIL",7,0)
 ;return value: status^status updated^error msg.^error type pointer^
"RTN","HLUTIL",8,0)
 ;queue position or # of retries^# open failed^ack timeout
"RTN","HLUTIL",9,0)
 ;      status:
"RTN","HLUTIL",10,0)
 ;               0 = message doesn't exist
"RTN","HLUTIL",11,0)
 ;               1 = waiting in queue
"RTN","HLUTIL",12,0)
 ;             1.5 = opening connection
"RTN","HLUTIL",13,0)
 ;             1.7 = awaiting response, # of retries
"RTN","HLUTIL",14,0)
 ;               2 = awaiting application ack
"RTN","HLUTIL",15,0)
 ;               3 = successfully completed
"RTN","HLUTIL",16,0)
 ;               4 = error
"RTN","HLUTIL",17,0)
 ;               8 = being generated
"RTN","HLUTIL",18,0)
 ;               9 = awaiting processing
"RTN","HLUTIL",19,0)
 Q:$G(X)']"" 0
"RTN","HLUTIL",20,0)
 N C,I,L,Y,Z
"RTN","HLUTIL",21,0)
 S Y=$O(^HLMA("C",X,0)) Q:'Y 0
"RTN","HLUTIL",22,0)
 ;lock node to flush disk buffers
"RTN","HLUTIL",23,0)
 L +^HLMA(Y,"P"):3 S Z=$G(^HLMA(Y,"P"))
"RTN","HLUTIL",24,0)
 S:'Z Z=0
"RTN","HLUTIL",25,0)
 ;if pending, get queue position
"RTN","HLUTIL",26,0)
 I +Z=1 D
"RTN","HLUTIL",27,0)
 . ;get Logical Link, if msg. not in x-ref, then it is being sent
"RTN","HLUTIL",28,0)
 . S L=+$P(^HLMA(Y,0),U,7) Q:'$D(^HLMA("AC","O",L,Y))
"RTN","HLUTIL",29,0)
 . ;find position in queue, if greater than 2 - use 2
"RTN","HLUTIL",30,0)
 . S I=Y F C=1:1:2 S I=$O(^HLMA("AC","O",L,I),-1) Q:'I
"RTN","HLUTIL",31,0)
 . S $P(Z,U,5)=C
"RTN","HLUTIL",32,0)
 L -^HLMA(Y,"P")
"RTN","HLUTIL",33,0)
 Q Z
"RTN","HLUTIL",34,0)
 ;
"RTN","HLUTIL",35,0)
MSGACT(X,HLIENACT) ;outgoing message action
"RTN","HLUTIL",36,0)
 ;input value:   X = message id
"RTN","HLUTIL",37,0)
 ;               HLIENACT = 1-cancel; 2-requeue
"RTN","HLUTIL",38,0)
 ;return value:  1 = action sucessful
"RTN","HLUTIL",39,0)
 ;               0 = action failed
"RTN","HLUTIL",40,0)
 Q:$G(X)']"" 0
"RTN","HLUTIL",41,0)
 N HLIEN,HLIEN0,HLSTAT,HLTCP,Y,LINK
"RTN","HLUTIL",42,0)
 S HLIEN=+$O(^HLMA("C",X,0)) Q:'HLIEN 0
"RTN","HLUTIL",43,0)
 S HLIEN0=$G(^HLMA(HLIEN,0)) Q:'HLIEN0 0
"RTN","HLUTIL",44,0)
 ;must be outgoing
"RTN","HLUTIL",45,0)
 Q:$P(HLIEN0,U,3)'="O" 0
"RTN","HLUTIL",46,0)
 F Y=1:1:3 L +^HLMA(HLIEN,"P"):1 Q:$T  H 1
"RTN","HLUTIL",47,0)
 E  Q 0
"RTN","HLUTIL",48,0)
 ;
"RTN","HLUTIL",49,0)
 ;**109**
"RTN","HLUTIL",50,0)
 S LINK=$P($G(^HLMA(HLIEN,0)),"^",7)
"RTN","HLUTIL",51,0)
 ;
"RTN","HLUTIL",52,0)
 S HLSTAT=1
"RTN","HLUTIL",53,0)
 ;cancel
"RTN","HLUTIL",54,0)
 I HLIENACT=1 D
"RTN","HLUTIL",55,0)
 . ;HLTCP is set so that file 773 is updated
"RTN","HLUTIL",56,0)
 . S HLTCP=""
"RTN","HLUTIL",57,0)
 . D STATUS^HLTF0(HLIEN,3,,"Cancelled by application",1)
"RTN","HLUTIL",58,0)
 .;
"RTN","HLUTIL",59,0)
 .;**109**
"RTN","HLUTIL",60,0)
 . D DEQUE^HLCSREP(LINK,"O",HLIEN)
"RTN","HLUTIL",61,0)
 .;
"RTN","HLUTIL",62,0)
 ;requeue
"RTN","HLUTIL",63,0)
 I HLIENACT=2 D
"RTN","HLUTIL",64,0)
 . N DA,DIK,HLJ
"RTN","HLUTIL",65,0)
 . ;check for type=outgoing and logical link, need for "AC" x-ref
"RTN","HLUTIL",66,0)
 . I $P(HLIEN0,U,3)'="O"!('$P(HLIEN0,U,7)) S HLSTAT=0 Q
"RTN","HLUTIL",67,0)
 . ;set status=pend transmission
"RTN","HLUTIL",68,0)
 . S Y=$NA(HLJ(773,HLIEN_",")),@Y@(20)=1
"RTN","HLUTIL",69,0)
 . ;delete status update, error msg, error type, date processed
"RTN","HLUTIL",70,0)
 . S (@Y@(21),@Y@(22),@Y@(23),@Y@(100))="@"
"RTN","HLUTIL",71,0)
 . D FILE^HLDIE("","HLJ","","MSGACT","HLUTIL") ; HL*1.6*109
"RTN","HLUTIL",72,0)
 . ;**109**
"RTN","HLUTIL",73,0)
 . ;need to set "AC" x-ref
"RTN","HLUTIL",74,0)
 .; S DA=HLIEN,DIK="^HLMA(",DIK(1)="7^AC"
"RTN","HLUTIL",75,0)
 .; D EN1^DIK
"RTN","HLUTIL",76,0)
 .;
"RTN","HLUTIL",77,0)
 .;**109**
"RTN","HLUTIL",78,0)
 . D ENQUE^HLCSREP(LINK,"O",HLIEN)
"RTN","HLUTIL",79,0)
 ;
"RTN","HLUTIL",80,0)
 L -^HLMA(HLIEN,"P")
"RTN","HLUTIL",81,0)
 Q HLSTAT
"RTN","HLUTIL",82,0)
 ;
"RTN","HLUTIL",83,0)
CHKLL(X) ;check setup of Logical Link
"RTN","HLUTIL",84,0)
 ;input value:   X = institution number or name
"RTN","HLUTIL",85,0)
 ;return value:  1 = setup OK
"RTN","HLUTIL",86,0)
 ;               0 = LL setup incorrect
"RTN","HLUTIL",87,0)
 N HLF,HLRESLT
"RTN","HLUTIL",88,0)
 S HLF=$S(X:"I",1:"")
"RTN","HLUTIL",89,0)
 D LINK^HLUTIL3(X,.HLRESLT,HLF)
"RTN","HLUTIL",90,0)
 S X=+$O(HLRESLT(0)) Q:'X 0
"RTN","HLUTIL",91,0)
 Q $$LLOK^HLCSLM(X)
"RTN","HLUTIL",92,0)
 ;
"RTN","HLUTIL",93,0)
DONTPURG() ; set the DONT PURGE field to 1 in order to prevent the message
"RTN","HLUTIL",94,0)
 ; from purging.
"RTN","HLUTIL",95,0)
 ; return value :  1 for successfully set the field
"RTN","HLUTIL",96,0)
 ;                -1 for failure
"RTN","HLUTIL",97,0)
 Q $$SETPURG(1)
"RTN","HLUTIL",98,0)
 ;
"RTN","HLUTIL",99,0)
TOPURG() ; clear the DONT PURGE field to allow the message to be purged.
"RTN","HLUTIL",100,0)
 ; return value :  0 for successfully clear the field
"RTN","HLUTIL",101,0)
 ;                -1 for failure
"RTN","HLUTIL",102,0)
 Q $$SETPURG(0)
"RTN","HLUTIL",103,0)
 ;
"RTN","HLUTIL",104,0)
SETPURG(STATUS) ; to set or to clear the DONT PURGE field
"RTN","HLUTIL",105,0)
 ; HLMTIENS = ien in file 773 for this message
"RTN","HLUTIL",106,0)
 ; input: 1 to set the DONT PURGE field
"RTN","HLUTIL",107,0)
 ;        0 to clear the DONT PURGE field.
"RTN","HLUTIL",108,0)
 ; return value: 1 means successfully set the DONT PURGE field
"RTN","HLUTIL",109,0)
 ;               0 means successfully clear the DONT PURGE field
"RTN","HLUTIL",110,0)
 ;              -1 means fail to set or to clear the field
"RTN","HLUTIL",111,0)
 I (STATUS'=1),(STATUS'=0) Q -1
"RTN","HLUTIL",112,0)
 I '$D(^HLMA(+$G(HLMTIENS),0)) Q -1
"RTN","HLUTIL",113,0)
 ;
"RTN","HLUTIL",114,0)
 L +^HLMA(HLMTIENS):30
"RTN","HLUTIL",115,0)
 E  Q -1
"RTN","HLUTIL",116,0)
 S $P(^HLMA(HLMTIENS,2),U)=STATUS
"RTN","HLUTIL",117,0)
 L -^HLMA(HLMTIENS)
"RTN","HLUTIL",118,0)
 Q STATUS
"RTN","HLUTIL",119,0)
 ;
"RTN","HLUTIL",120,0)
REPROC(IEN,RTN) ; reprocessing message
"RTN","HLUTIL",121,0)
 ; IEN- the message IEN in file 773
"RTN","HLUTIL",122,0)
 ; RTN- the routine, to be Xecuted for processing the message
"RTN","HLUTIL",123,0)
 ; return value:  0 for success, -1 for failure
"RTN","HLUTIL",124,0)
 N HLMTIEN,HLMTIENS,HLNEXT,HLNODE,HLQUIT,HLERR,HLRESLT,HLTCP
"RTN","HLUTIL",125,0)
 N HL,HDR,FS,ECH,HLMSA,X,X1,X2
"RTN","HLUTIL",126,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLUTIL",127,0)
 I '$D(^HLMA(+$G(IEN),0)) Q -1
"RTN","HLUTIL",128,0)
 I $G(RTN)'["" Q -1
"RTN","HLUTIL",129,0)
 S (HLMTIENS,HLTCP)=+IEN,HLMTIEN=+^HLMA(HLMTIENS,0),HLMSA=$$MSA^HLTP3(HLMTIEN)
"RTN","HLUTIL",130,0)
 M HDR=^HLMA(HLMTIENS,"MSH")
"RTN","HLUTIL",131,0)
 D CHK^HLTPCK2(.HDR,.HL,.HLMSA)
"RTN","HLUTIL",132,0)
 Q:HL'="" -1
"RTN","HLUTIL",133,0)
 ;
"RTN","HLUTIL",134,0)
 I RTN["D " X RTN
"RTN","HLUTIL",135,0)
 I RTN'["D " D
"RTN","HLUTIL",136,0)
 . I RTN["^" X "D "_RTN
"RTN","HLUTIL",137,0)
 . I RTN'["^" X "D ^"_RTN
"RTN","HLUTIL",138,0)
 S HLRESLT=0 S:($D(HLERR)) HLRESLT="9^"_$G(^HL(771.7,9,0))
"RTN","HLUTIL",139,0)
 ; update the status
"RTN","HLUTIL",140,0)
 D STATUS^HLTF0(HLMTIENS,$S(HLRESLT:4,1:3),$S(HLRESLT:+HLRESLT,1:""),$S($D(HLERR):HLERR,HLRESLT:$P(HLRESLT,"^",2),1:""),1)
"RTN","HLUTIL",141,0)
 Q 0
"RTN","HLUTIL3")
0^86^B5619301
"RTN","HLUTIL3",1,0)
HLUTIL3 ;ALB/MTC - VARIOUS HL7 UTILITIES ;11/19/2003  15:37
"RTN","HLUTIL3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**2,41,109**;Oct 13, 1995
"RTN","HLUTIL3",3,0)
 ;
"RTN","HLUTIL3",4,0)
 Q
"RTN","HLUTIL3",5,0)
 ;
"RTN","HLUTIL3",6,0)
FNDSTAT(IEN) ;- This function will return the appropriate status based
"RTN","HLUTIL3",7,0)
 ; on the Accept Ack, Application Ack and version of the protocol
"RTN","HLUTIL3",8,0)
 ; being utilized.
"RTN","HLUTIL3",9,0)
 ;
"RTN","HLUTIL3",10,0)
 ; INPUT : IEN of the HL7 Message File (#772)
"RTN","HLUTIL3",11,0)
 ; OUTPUT: Pointer to HL7 Message Status File (#771.6) OR NULL if
"RTN","HLUTIL3",12,0)
 ;         Not valid IEN or No parent.
"RTN","HLUTIL3",13,0)
 ;
"RTN","HLUTIL3",14,0)
 N PROTOCOL,PARENTP,PARENT,PROT
"RTN","HLUTIL3",15,0)
 N CHILD,RESULT
"RTN","HLUTIL3",16,0)
 N HLCA,HLAA
"RTN","HLUTIL3",17,0)
 ;
"RTN","HLUTIL3",18,0)
 S RESULT=""
"RTN","HLUTIL3",19,0)
 G:'IEN EXIT
"RTN","HLUTIL3",20,0)
 ;--  Find Parent
"RTN","HLUTIL3",21,0)
 S CHILD=$G(^HL(772,IEN,0))
"RTN","HLUTIL3",22,0)
 I CHILD="" G EXIT
"RTN","HLUTIL3",23,0)
 S PARENTP=$P(CHILD,"^",8)
"RTN","HLUTIL3",24,0)
 I (PARENTP="") G EXIT
"RTN","HLUTIL3",25,0)
 S PARENT=$G(^HL(772,PARENTP,0))
"RTN","HLUTIL3",26,0)
 ;
"RTN","HLUTIL3",27,0)
 S PROT=$P(PARENT,"^",10)
"RTN","HLUTIL3",28,0)
 S PROTOCOL=$$TYPE^HLUTIL2(PROT)
"RTN","HLUTIL3",29,0)
 S HLCA=$P(PROTOCOL,U,7)
"RTN","HLUTIL3",30,0)
 S HLAA=$P(PROTOCOL,U,8)
"RTN","HLUTIL3",31,0)
 ;
"RTN","HLUTIL3",32,0)
 ;-- if this is a responce (ack) message set to "sucessful"
"RTN","HLUTIL3",33,0)
 I $P(PARENT,U,7) S RESULT=3 G EXIT
"RTN","HLUTIL3",34,0)
 ;-- HLCA and HLAA assume original ack rules set to "awaiting ack"
"RTN","HLUTIL3",35,0)
 I HLCA="",HLAA="" S RESULT=2 G EXIT
"RTN","HLUTIL3",36,0)
 ;-- if HLCA=NE and HLAA=NE set to "sucessful"
"RTN","HLUTIL3",37,0)
 I HLCA="NE",HLAA="NE" S RESULT=3 G EXIT
"RTN","HLUTIL3",38,0)
 ;-- else set to "awaiting ack"
"RTN","HLUTIL3",39,0)
 S RESULT=2
"RTN","HLUTIL3",40,0)
 ;
"RTN","HLUTIL3",41,0)
EXIT ;
"RTN","HLUTIL3",42,0)
 Q RESULT
"RTN","HLUTIL3",43,0)
 ;
"RTN","HLUTIL3",44,0)
DOMAIL(HLLINK) ; This function will determine if the MailMan LLP should
"RTN","HLUTIL3",45,0)
 ; be used to x-mit the outgoing message.
"RTN","HLUTIL3",46,0)
 ;  INPUT  - IEN of HL LOGICAL LINK (#870)
"RTN","HLUTIL3",47,0)
 ;  OUTPUT - 1=Yes, 0=N
"RTN","HLUTIL3",48,0)
 ;
"RTN","HLUTIL3",49,0)
 N X
"RTN","HLUTIL3",50,0)
 S X=$P($G(^HLCS(870,+HLLINK,0)),U,22)
"RTN","HLUTIL3",51,0)
 Q $S(X:1,1:0)
"RTN","HLUTIL3",52,0)
 ;
"RTN","HLUTIL3",53,0)
LINK(HLINST,HLI,HLFLG) ;Return Logical Link(s) from Institution or Domain
"RTN","HLUTIL3",54,0)
 ; INPUT - HLINST=Institution name or VISN name or ien
"RTN","HLUTIL3",55,0)
 ;                If HLFLG="I", institution number is passed
"RTN","HLUTIL3",56,0)
 ;                If HLFLG="D", HLINST=DOMAIN name or DOMAIN ien
"RTN","HLUTIL3",57,0)
 ; If HLFLG="", Institution name or ien is assumed
"RTN","HLUTIL3",58,0)
 ; OUTPUT - HLI(LINK IEN)=LINK NAME passed by reference
"RTN","HLUTIL3",59,0)
 S HLFLG=$G(HLFLG)
"RTN","HLUTIL3",60,0)
 Q:$G(HLINST)']""
"RTN","HLUTIL3",61,0)
 N HLP S HLI=0
"RTN","HLUTIL3",62,0)
 ;Domain passed
"RTN","HLUTIL3",63,0)
 I HLFLG="D" D DOM Q
"RTN","HLUTIL3",64,0)
 ;Institution name or number
"RTN","HLUTIL3",65,0)
 I HLFLG="I"!('HLINST) D
"RTN","HLUTIL3",66,0)
 . ;patch HL*1.6*109
"RTN","HLUTIL3",67,0)
 . N X ;to protect the variable from calling routine
"RTN","HLUTIL3",68,0)
 . S DIC=4,DIC(0)="MXZ",X=HLINST D ^DIC S HLINST=+Y
"RTN","HLUTIL3",69,0)
 . ;patch HL*1.6*109 end
"RTN","HLUTIL3",70,0)
 Q:HLINST<1
"RTN","HLUTIL3",71,0)
 ;pass institution ien
"RTN","HLUTIL3",72,0)
 D CHILDREN^XUAF4("HLP","`"_HLINST) I $D(HLP) D  Q
"RTN","HLUTIL3",73,0)
 .S HLINST=0 F  S HLINST=$O(HLP("C",HLINST)) Q:HLINST<1  D L1
"RTN","HLUTIL3",74,0)
L1 F  S HLI=$O(^HLCS(870,"C",HLINST,HLI)) Q:HLI<1  D
"RTN","HLUTIL3",75,0)
 .S HLI(HLI)=$P(^HLCS(870,HLI,0),"^")
"RTN","HLUTIL3",76,0)
 Q
"RTN","HLUTIL3",77,0)
DOM ;Domain
"RTN","HLUTIL3",78,0)
 ;patch HL*1.6*109 start
"RTN","HLUTIL3",79,0)
 ;to protect the variable from calling routine
"RTN","HLUTIL3",80,0)
 N X
"RTN","HLUTIL3",81,0)
 I 'HLINST S DIC=4.2,DIC(0)="MXZ",X=HLINST D ^DIC S HLINST=+Y
"RTN","HLUTIL3",82,0)
 ;patch HL*1.6*109 end
"RTN","HLUTIL3",83,0)
 ;
"RTN","HLUTIL3",84,0)
 Q:HLINST<1
"RTN","HLUTIL3",85,0)
 F  S HLI=$O(^HLCS(870,"D",HLINST,HLI)) Q:HLI<1  D
"RTN","HLUTIL3",86,0)
 .S HLI(HLI)=$P(^HLCS(870,HLI,0),"^")
"RTN","HLUTIL3",87,0)
 Q   ; patch HL*1.6*109: add "Q" to quit DOM
"SEC","^DIC",776,776,0,"AUDIT")
@
"SEC","^DIC",776,776,0,"DD")
@
"SEC","^DIC",776,776,0,"DEL")
@
"SEC","^DIC",776,776,0,"LAYGO")
@
"SEC","^DIC",776,776,0,"RD")
@
"SEC","^DIC",776,776,0,"WR")
@
"SEC","^DIC",776.1,776.1,0,"AUDIT")
@
"SEC","^DIC",776.1,776.1,0,"DD")
@
"SEC","^DIC",776.1,776.1,0,"DEL")
@
"SEC","^DIC",776.1,776.1,0,"LAYGO")
@
"SEC","^DIC",776.1,776.1,0,"RD")
@
"SEC","^DIC",776.1,776.1,0,"WR")
@
"SEC","^DIC",776.2,776.2,0,"AUDIT")
@
"SEC","^DIC",776.2,776.2,0,"DD")
@
"SEC","^DIC",776.2,776.2,0,"DEL")
@
"SEC","^DIC",776.2,776.2,0,"LAYGO")
@
"SEC","^DIC",776.2,776.2,0,"RD")
@
"SEC","^DIC",776.2,776.2,0,"WR")
@
"SEC","^DIC",776.3,776.3,0,"AUDIT")
@
"SEC","^DIC",776.3,776.3,0,"DD")
@
"SEC","^DIC",776.3,776.3,0,"DEL")
@
"SEC","^DIC",776.3,776.3,0,"LAYGO")
@
"SEC","^DIC",776.3,776.3,0,"RD")
@
"SEC","^DIC",776.3,776.3,0,"WR")
@
"SEC","^DIC",776.4,776.4,0,"AUDIT")
@
"SEC","^DIC",776.4,776.4,0,"DD")
@
"SEC","^DIC",776.4,776.4,0,"DEL")
@
"SEC","^DIC",776.4,776.4,0,"LAYGO")
@
"SEC","^DIC",776.4,776.4,0,"RD")
@
"SEC","^DIC",776.4,776.4,0,"WR")
@
"SEC","^DIC",776.5,776.5,0,"AUDIT")
@
"SEC","^DIC",776.5,776.5,0,"DD")
@
"SEC","^DIC",776.5,776.5,0,"DEL")
@
"SEC","^DIC",776.5,776.5,0,"LAYGO")
@
"SEC","^DIC",776.5,776.5,0,"RD")
@
"SEC","^DIC",776.5,776.5,0,"WR")
@
"SEC","^DIC",776.999,776.999,0,"AUDIT")
@
"SEC","^DIC",776.999,776.999,0,"DD")
@
"SEC","^DIC",776.999,776.999,0,"DEL")
@
"SEC","^DIC",776.999,776.999,0,"LAYGO")
@
"SEC","^DIC",776.999,776.999,0,"RD")
@
"SEC","^DIC",776.999,776.999,0,"WR")
@
"VER")
8.0^22.0
"^DD",772,772,2.02,0)
FAST PURGE DT/TM^D^^2;2^S %DT="ESTXR" D ^%DT S X=Y K:X<1 X
"^DD",772,772,2.02,3)
Enter the date and time at which the record may be purged.
"^DD",772,772,2.02,"DT")
3030924
"^DD",773,773,0)
FIELD^^17^45
"^DD",773,773,0,"DDA")
N
"^DD",773,773,0,"DT")
3040128
"^DD",773,773,0,"ID",2)
W "   ",$P(^(0),U,2)
"^DD",773,773,0,"IX","AC",773,7)

"^DD",773,773,0,"IX","AD",773,100)

"^DD",773,773,0,"IX","AE",773,14)

"^DD",773,773,0,"IX","AF",773,6)

"^DD",773,773,0,"IX","AG",773,20)

"^DD",773,773,0,"IX","AH",773,2)

"^DD",773,773,0,"IX","B",773,.01)

"^DD",773,773,0,"IX","C",773,2)

"^DD",773,773,0,"NM","HL7 MESSAGE ADMINISTRATION")

"^DD",773,773,0,"PT",773,6)

"^DD",773,773,0,"PT",773,12)

"^DD",773,773,0,"VRPK")
HL
"^DD",773,773,.001,0)
NUMBER^NJ9,0^^ ^K:+X'=X!(X>999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",773,773,.001,3)
Type a Number between 1 and 999999999, 0 Decimal Digits
"^DD",773,773,.001,"DT")
2981013
"^DD",773,773,.01,0)
DATE/TIME ENTERED^RP772'^HL(772,^0;1^Q
"^DD",773,773,.01,1,0)
^.1
"^DD",773,773,.01,1,1,0)
773^B
"^DD",773,773,.01,1,1,1)
S ^HLMA("B",$E(X,1,30),DA)=""
"^DD",773,773,.01,1,1,2)
K ^HLMA("B",$E(X,1,30),DA)
"^DD",773,773,.01,3)

"^DD",773,773,.01,"DT")
2980416
"^DD",773,773,2,0)
MESSAGE ID^F^^0;2^K:$L(X)>20!($L(X)<1) X
"^DD",773,773,2,1,0)
^.1
"^DD",773,773,2,1,1,0)
773^C
"^DD",773,773,2,1,1,1)
S ^HLMA("C",$E(X,1,30),DA)=""
"^DD",773,773,2,1,1,2)
K ^HLMA("C",$E(X,1,30),DA)
"^DD",773,773,2,1,1,"%D",0)
^^2^2^2980519^
"^DD",773,773,2,1,1,"%D",1,0)
This cross reference allows a user to look up an HL7
"^DD",773,773,2,1,1,"%D",2,0)
message by its unique message ID.
"^DD",773,773,2,1,1,"DT")
2980519
"^DD",773,773,2,1,2,0)
773^AH^MUMPS
"^DD",773,773,2,1,2,1)
S:$P(^HLMA(DA,0),U,12) ^HLMA("AH",+$P(^(0),U,12),X,DA)=""
"^DD",773,773,2,1,2,2)
K:$P(^HLMA(DA,0),U,12) ^HLMA("AH",+$P(^(0),U,12),X,DA)
"^DD",773,773,2,1,2,3)
This x-reference is used in conjunction with the 'AG' x-ref on field 205
"^DD",773,773,2,1,2,"%D",0)
^^2^2^2980811^^^
"^DD",773,773,2,1,2,"%D",1,0)
This x-reference is used to look up the original message when processing
"^DD",773,773,2,1,2,"%D",2,0)
a response.
"^DD",773,773,2,1,2,"DT")
2980811
"^DD",773,773,2,3)
Answer must be 1-20 characters in length.
"^DD",773,773,2,21,0)
^^1^1^2980414^^
"^DD",773,773,2,21,1,0)
This is an unique identifier associated with a message.
"^DD",773,773,2,"DT")
2990217
"^DD",773,773,2.02,0)
FAST PURGE DT/TM^D^^2;2^S %DT="ESTXR" D ^%DT S X=Y K:X<1 X
"^DD",773,773,2.02,3)
This is the date and time that the record may be purged.
"^DD",773,773,2.02,"DT")
3030923
"^DD",773,773,3,0)
TRANSMISSION TYPE^RSI^I:INCOMING;O:OUTGOING;^0;3^Q
"^DD",773,773,3,3)
The type of transmission (incoming or outgoing).
"^DD",773,773,3,21,0)
^^1^1^2980423^
"^DD",773,773,3,21,1,0)
The type of transmission (incoming or outgoing).
"^DD",773,773,3,"DT")
2980513
"^DD",773,773,4,0)
PRIORITY^S^I:IMMEDIATE;D:DEFERRED;^0;4^Q
"^DD",773,773,4,3)
The mode in which this message is delivered
"^DD",773,773,4,21,0)
^^1^1^2980505^
"^DD",773,773,4,21,1,0)
The delivery priority assigned to this outgoing message.
"^DD",773,773,4,"DT")
2980505
"^DD",773,773,5,0)
HEADER TYPE^S^M:SINGLE MESSAGE;B:BATCH OF MESSAGES;F:FILE OF BATCHES;^0;5^Q
"^DD",773,773,5,21,0)
^^8^8^2980505^
"^DD",773,773,5,21,1,0)
There are three types of messages as follows:
"^DD",773,773,5,21,2,0)
 
"^DD",773,773,5,21,3,0)
 M for Single message (contains only one MSH segment)
"^DD",773,773,5,21,4,0)
 B for Batch of messages (contains multiple MSH segments)
"^DD",773,773,5,21,5,0)
 F for File of batches (contains multiple BHS segments)
"^DD",773,773,5,21,6,0)
 
"^DD",773,773,5,21,7,0)
This field is automatically filled in by the Messaging System and is
"^DD",773,773,5,21,8,0)
used to determine the appropriate header segment to build for a message.
"^DD",773,773,5,"DT")
2980811
"^DD",773,773,6,0)
INITIAL MESSAGE^P773'^HLMA(^0;6^Q
"^DD",773,773,6,1,0)
^.1
"^DD",773,773,6,1,1,0)
773^AF
"^DD",773,773,6,1,1,1)
S ^HLMA("AF",$E(X,1,30),DA)=""
"^DD",773,773,6,1,1,2)
K ^HLMA("AF",$E(X,1,30),DA)
"^DD",773,773,6,1,1,"DT")
2981014
"^DD",773,773,6,21,0)
^^2^2^2981208^^
"^DD",773,773,6,21,1,0)
This is the first message of a transaction.  All messages pointing
"^DD",773,773,6,21,2,0)
to the initial message are part of the transaction.
"^DD",773,773,6,"DT")
2981208
"^DD",773,773,7,0)
LOGICAL LINK^P870'^HLCS(870,^0;7^Q
"^DD",773,773,7,1,0)
^.1
"^DD",773,773,7,1,1,0)
773^AC^MUMPS
"^DD",773,773,7,1,1,1)
Q  S %=$P(^HLMA(DA,0),U,3) S:%]"" ^HLMA("AC",%,X,DA)="" I %="O",'$D(HLTCPO) D LLCNT^HLCSTCP(X,3)
"^DD",773,773,7,1,1,2)
Q  S %=$P(^HLMA(DA,0),U,3) K:%]"" ^HLMA("AC",%,X,DA)
"^DD",773,773,7,1,1,3)
Required to determine outgoing transmissions and incoming deferred responses.
"^DD",773,773,7,1,1,"%D",0)
^.101^7^7^3031202^^^^
"^DD",773,773,7,1,1,"%D",1,0)
This cross-references is used to determine outgoing transmission for a
"^DD",773,773,7,1,1,"%D",2,0)
Logical Link; ^HLMA("AC","O",LL,DA).  The background job for the LL will
"^DD",773,773,7,1,1,"%D",3,0)
use this x-ref and delete it as each message is transmitted.
"^DD",773,773,7,1,1,"%D",4,0)
It is also used to process incoming messages that have a deferred response;
"^DD",773,773,7,1,1,"%D",5,0)
^HLMA("AC","I",LL,DA).  The incoming filer will check this x-ref and delete
"^DD",773,773,7,1,1,"%D",6,0)
it as it processes each message.
"^DD",773,773,7,1,1,"%D",7,0)

"^DD",773,773,7,1,1,"DT")
3031202
"^DD",773,773,7,3)
The link that will be used to transmit this message over.
"^DD",773,773,7,21,0)
^^4^4^2980923^^
"^DD",773,773,7,21,1,0)
This is a pointer to the Logical Link file (#870).  This link is used
"^DD",773,773,7,21,2,0)
to transmit messages to an external receiving application.  This field
"^DD",773,773,7,21,3,0)
is not filled in when messages are exchanged between DHCP applications
"^DD",773,773,7,21,4,0)
on the same system.
"^DD",773,773,7,"DT")
3031202
"^DD",773,773,8,0)
SUBSCRIBER PROTOCOL^P101'^ORD(101,^0;8^Q
"^DD",773,773,8,3)
The Protocol related to this message.
"^DD",773,773,8,21,0)
^^1^1^2980505^
"^DD",773,773,8,21,1,0)
The Protocol related to this message.
"^DD",773,773,8,"DT")
2980706
"^DD",773,773,9,0)
SECURITY^F^^0;9^K:$L(X)>40!($L(X)<1) X
"^DD",773,773,9,3)
Answer must be 1-40 characters in length.
"^DD",773,773,9,21,0)
^^1^1^2980526^
"^DD",773,773,9,21,1,0)
The value to use in the Security field of the Message Header segment.
"^DD",773,773,9,"DT")
2980526
"^DD",773,773,10,0)
DON'T PURGE^S^1:DON'T PURGE;0:TO PURGE;^2;1^Q
"^DD",773,773,10,3)
When set to 1, the message will never be purged by HL7.
"^DD",773,773,10,21,0)
^^4^4^2980505^
"^DD",773,773,10,21,1,0)
When this field is set to 1, the message wil never be purged by the HL7
"^DD",773,773,10,21,2,0)
"Purge Message Text File Entries" option.
"^DD",773,773,10,21,3,0)
However, when this field is set to 0 or is empty, the message is allowed
"^DD",773,773,10,21,4,0)
to be purged by the HL7 "Purge Message Text Entries" option.
"^DD",773,773,10,"DT")
2980505
"^DD",773,773,11,0)
CONTINUATION POINTER^F^^1;1^K:$L(X)>180!($L(X)<1) X
"^DD",773,773,11,3)
Answer must be 1-180 characters in length.
"^DD",773,773,11,21,0)
^^2^2^2980526^
"^DD",773,773,11,21,1,0)
The value to use in the Continuation Pointer field of the Message
"^DD",773,773,11,21,2,0)
Header segment.
"^DD",773,773,11,"DT")
2980526
"^DD",773,773,12,0)
ACKNOWLEDGEMENT TO^P773'^HLMA(^0;10^Q
"^DD",773,773,12,21,0)
^^2^2^2981208^
"^DD",773,773,12,21,1,0)
This field points to the message that the MSA segment in the
"^DD",773,773,12,21,2,0)
current message is acknowledging.
"^DD",773,773,12,"DT")
2981208
"^DD",773,773,13,0)
SENDING APPLICATION^P771'^HL(771,^0;11^Q
"^DD",773,773,13,21,0)
^^1^1^2980811^
"^DD",773,773,13,21,1,0)
The application that is sending the message.
"^DD",773,773,13,"DT")
2980811
"^DD",773,773,14,0)
RECEIVING APPLICATION^P771'^HL(771,^0;12^Q
"^DD",773,773,14,1,0)
^.1
"^DD",773,773,14,1,1,0)
773^AE^MUMPS
"^DD",773,773,14,1,1,1)
S:$P($G(^HLMA(DA,0)),U,2)]"" ^HLMA("AH",X,$P(^(0),U,2),DA)=""
"^DD",773,773,14,1,1,2)
K:$P($G(^HLMA(DA,0)),U,2)]"" ^HLMA("AH",X,$P(^(0),U,2),DA)
"^DD",773,773,14,1,1,3)
This x-reference is used in conjunction with the 'AH' on field 2.
"^DD",773,773,14,1,1,"%D",0)
^^2^2^2980811^
"^DD",773,773,14,1,1,"%D",1,0)
This x-reference is used to look up the original message when processing
"^DD",773,773,14,1,1,"%D",2,0)
a response.
"^DD",773,773,14,1,1,"DT")
2980811
"^DD",773,773,14,21,0)
^^1^1^2980811^
"^DD",773,773,14,21,1,0)
The application that is receiving this message.
"^DD",773,773,14,"DT")
2980811
"^DD",773,773,15,0)
MESSAGE TYPE^P771.2'^HL(771.2,^0;13^Q
"^DD",773,773,15,3)

"^DD",773,773,15,21,0)
^^1^1^2980811^
"^DD",773,773,15,21,1,0)
This is the Message type from the HL7 standard.
"^DD",773,773,15,"DT")
2980812
"^DD",773,773,16,0)
EVENT TYPE^P779.001'^HL(779.001,^0;14^Q
"^DD",773,773,16,3)

"^DD",773,773,16,21,0)
^^1^1^2980811^
"^DD",773,773,16,21,1,0)
This is the Event Type from the HL7 standard.
"^DD",773,773,16,"DT")
2980812
"^DD",773,773,17,0)
LOGICAL LINK - IN QUEUE^P870'^HLCS(870,^0;17^Q
"^DD",773,773,17,3)
The logical link for this message's subscriber protocol is set into this field.
"^DD",773,773,17,"DT")
3040128
"^DD",773,773,20,0)
STATUS^RP771.6'^HL(771.6,^P;1^Q
"^DD",773,773,20,1,0)
^.1
"^DD",773,773,20,1,1,0)
773^AG
"^DD",773,773,20,1,1,1)
S ^HLMA("AG",$E(X,1,30),DA)=""
"^DD",773,773,20,1,1,2)
K ^HLMA("AG",$E(X,1,30),DA)
"^DD",773,773,20,1,1,"DT")
2990302
"^DD",773,773,20,3)
The current status of this message.
"^DD",773,773,20,21,0)
^.001^1^1^3010906^^
"^DD",773,773,20,21,1,0)
The status currently assigned to this message.
"^DD",773,773,20,"DT")
3030804
"^DD",773,773,21,0)
STATUS UPDATE DATE/TIME^D^^P;2^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",773,773,21,1,0)
^.1^^0
"^DD",773,773,21,3)
The date and time the Status was updated.
"^DD",773,773,21,21,0)
^^1^1^2980526^^^
"^DD",773,773,21,21,1,0)
The date and time the Status field was last updated for this message.
"^DD",773,773,21,"DT")
2980526
"^DD",773,773,22,0)
ERROR MESSAGE^F^^P;3^K:$L(X)>200!($L(X)<3) X
"^DD",773,773,22,3)
Answer must be 3-200 characters in length.
"^DD",773,773,22,21,0)
^^2^2^2980505^
"^DD",773,773,22,21,1,0)
If there was an error in sending or receiving this message,
"^DD",773,773,22,21,2,0)
this field will contain the error message.
"^DD",773,773,22,"DT")
2980505
"^DD",773,773,23,0)
ERROR TYPE^P771.7'^HL(771.7,^P;4^Q
"^DD",773,773,23,21,0)
^^1^1^2980505^
"^DD",773,773,23,21,1,0)
A description of the type of error that occured.
"^DD",773,773,23,"DT")
2980505
"^DD",773,773,24,0)
TRANSMISSION ATTEMPTS^NJ3,0^^P;5^K:+X'=X!(X>999)!(X<1)!(X?.E1"."1N.N) X
"^DD",773,773,24,3)
Type a Number between 1 and 999.
"^DD",773,773,24,21,0)
^^2^2^3000330^^
"^DD",773,773,24,21,1,0)
This field contains the number of transmission attempts for this outgoing
"^DD",773,773,24,21,2,0)
message.
"^DD",773,773,24,"DT")
3000330
"^DD",773,773,25,0)
OPEN ATTEMPTS^NJ3,0^^P;6^K:+X'=X!(X>999)!(X<0)!(X?.E1"."1.N) X
"^DD",773,773,25,3)
Type a number between 0 and 999, 0 Decimal Digits
"^DD",773,773,25,21,0)
^^2^2^3000330^
"^DD",773,773,25,21,1,0)
This field contains the number of attempts to open a TCP connections for
"^DD",773,773,25,21,2,0)
this outgoing message.
"^DD",773,773,25,"DT")
3000330
"^DD",773,773,26,0)
ACK TIMEOUT^NJ3,0^^P;7^K:+X'=X!(X>600)!(X<0)!(X?.E1"."1.N) X
"^DD",773,773,26,3)
Type a number between 0 and 600, 0 Decimal Digits
"^DD",773,773,26,21,0)
^^3^3^3000330^
"^DD",773,773,26,21,1,0)
The number of seconds the Lower Layer Protocol waits for an
"^DD",773,773,26,21,2,0)
acknowledgement from the receiving application. This field will
"^DD",773,773,26,21,3,0)
override the ACK TIMEOUT of the Logical Link for this message.
"^DD",773,773,26,"DT")
3000330
"^DD",773,773,50,0)
MESSAGE SIZE^CJ12,0^^ ; ^S X=$$MSGSIZE^HLCSUTL(D0) S X=$J(X,0,0)
"^DD",773,773,50,9)
^
"^DD",773,773,50,9.01)

"^DD",773,773,50,9.1)
S X=$$MSGSIZE^HLCSUTL(D0)
"^DD",773,773,50,21,0)
^^2^2^3000601^
"^DD",773,773,50,21,1,0)
This computed field returns the number of character in a message.
"^DD",773,773,50,21,2,0)
It includes the message header and body.
"^DD",773,773,90.01,0)
HLP-SUBSCRIBER PROTOCOL^F^^90;1^K:$L(X)>45!($L(X)<1) X
"^DD",773,773,90.01,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-45 characters)
"^DD",773,773,90.01,21,0)
^^22^22^3021210^
"^DD",773,773,90.01,21,1,0)
This field holds the SUBSCRIBER PROTOCOL that was on the 1st piece of the
"^DD",773,773,90.01,21,2,0)
HLP("SUBSCRIBER"[,#]) subscriber entry.  (If the HLP("SUBSCRIBER") entry
"^DD",773,773,90.01,21,3,0)
was used to reset the MSH segment fields, this field will be null.)
"^DD",773,773,90.01,21,4,0)
 
"^DD",773,773,90.01,21,5,0)
 
"^DD",773,773,90.01,21,6,0)
Additional Comments on ^HLMA(ien,90) Node
"^DD",773,773,90.01,21,7,0)
-----------------------------------------
"^DD",773,773,90.01,21,8,0)
When the MSH segment fields are successfully reset using either 
"^DD",773,773,90.01,21,9,0)
HLP("SUBSCRIBER") or HLP("SUBSCRIBER",#), the entire HLP("SUBSCRIBER") or
"^DD",773,773,90.01,21,10,0)
HLP("SUBSCRIBER",#) array entry is stored on the ^HLMA(#,90) node.  There
"^DD",773,773,90.01,21,11,0)
are eight pieces in the HLP("SUBSCRIBER"[,#]) array, and there are eight
"^DD",773,773,90.01,21,12,0)
fields on the ^HLMA(ien,90) node.  The eight pieces of
"^DD",773,773,90.01,21,13,0)
HLP("SUBSCRIBER"[,#]) and the eight ^HLMA(ien,90) fields exactly
"^DD",773,773,90.01,21,14,0)
correspond to each other.
"^DD",773,773,90.01,21,15,0)
 
"^DD",773,773,90.01,21,16,0)
Note:  When ^HLMA(ien,90) is created, it is set equal to the entire
"^DD",773,773,90.01,21,17,0)
       value of the HLP("SUBSCRIBER"[,#]) array entry.  The fields on
"^DD",773,773,90.01,21,18,0)
       the ^HLMA(ien,90) node are not set separately!  (So, if the
"^DD",773,773,90.01,21,19,0)
       application developer creates an invalid HLP("SUBSCRIBER"[,#])
"^DD",773,773,90.01,21,20,0)
       array, with invalid data stored in one or more of the eight
"^DD",773,773,90.01,21,21,0)
       pieces, the ^HLMA(ien,90) node will similarly hold invalid
"^DD",773,773,90.01,21,22,0)
       data.)
"^DD",773,773,90.01,"DT")
3021022
"^DD",773,773,90.02,0)
HLP-SENDING APPLICATION^F^^90;2^K:$L(X)>45!($L(X)<1) X
"^DD",773,773,90.02,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-45 characters)
"^DD",773,773,90.02,21,0)
^.001^5^5^3021210^^
"^DD",773,773,90.02,21,1,0)
This field holds the SENDING APPLICATION that was on the 2nd piece of the 
"^DD",773,773,90.02,21,2,0)
HLP("SUBSCRIBER"[,#]) subscriber entry.  
"^DD",773,773,90.02,21,3,0)
 
"^DD",773,773,90.02,21,4,0)
(See the 'Additional Comments on ^HLMA(ien,90) Node' section in the 
"^DD",773,773,90.02,21,5,0)
description for field # 90.01.)
"^DD",773,773,90.02,"DT")
3021022
"^DD",773,773,90.03,0)
HLP-SENDING FACILITY^F^^90;3^K:$L(X)>30!($L(X)<1) X
"^DD",773,773,90.03,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-30 characters)
"^DD",773,773,90.03,21,0)
^^5^5^3021210^
"^DD",773,773,90.03,21,1,0)
This field holds the SENDING FACILITY that was on the 3rd piece of the
"^DD",773,773,90.03,21,2,0)
HLP("SUBSCRIBER"[,#]) subscriber entry.  
"^DD",773,773,90.03,21,3,0)
 
"^DD",773,773,90.03,21,4,0)
(See the 'Additional Comments on ^HLMA(ien,90) Node' section in the 
"^DD",773,773,90.03,21,5,0)
description for field # 90.01.)
"^DD",773,773,90.03,"DT")
3021022
"^DD",773,773,90.04,0)
HLP-RECEIVING APPLICATION^F^^90;4^K:$L(X)>45!($L(X)<1) X
"^DD",773,773,90.04,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-45 characters)
"^DD",773,773,90.04,21,0)
^^5^5^3021210^
"^DD",773,773,90.04,21,1,0)
This field holds the RECEIVING APPLICATION that was on the 4th piece of
"^DD",773,773,90.04,21,2,0)
the HLP("SUBSCRIBER"[,#]) subscriber entry.
"^DD",773,773,90.04,21,3,0)
 
"^DD",773,773,90.04,21,4,0)
(See the 'Additional Comments on ^HLMA(ien,90) Node' section in the 
"^DD",773,773,90.04,21,5,0)
description for field # 90.01.)
"^DD",773,773,90.04,"DT")
3021022
"^DD",773,773,90.05,0)
HLP-RECEIVING FACILITY^F^^90;5^K:$L(X)>30!($L(X)<1) X
"^DD",773,773,90.05,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-30 characters)
"^DD",773,773,90.05,21,0)
^^5^5^3021210^
"^DD",773,773,90.05,21,1,0)
This field holds the RECEIVING FACILITY that was on the 5th piece of the
"^DD",773,773,90.05,21,2,0)
HLP("SUBSCRIBER"[,#]) subscriber entry.
"^DD",773,773,90.05,21,3,0)
 
"^DD",773,773,90.05,21,4,0)
(See the 'Additional Comments on ^HLMA(ien,90) Node' section in the 
"^DD",773,773,90.05,21,5,0)
description for field # 90.01.)
"^DD",773,773,90.05,"DT")
3021022
"^DD",773,773,90.06,0)
HLP-SUBROUTINE^F^^90;6^K:$L(X)>8!($L(X)<1) X
"^DD",773,773,90.06,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-8 characters)
"^DD",773,773,90.06,21,0)
^^1^1^3021210^
"^DD",773,773,90.06,21,1,0)
See the description for the HLP-ROUTINE field (#90.07).
"^DD",773,773,90.06,"DT")
3021022
"^DD",773,773,90.07,0)
HLP-ROUTINE^F^^90;7^K:$L(X)>8!($L(X)<1) X
"^DD",773,773,90.07,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-8 characters)
"^DD",773,773,90.07,21,0)
^^4^4^3021210^
"^DD",773,773,90.07,21,1,0)
Application developers may pass a reference to M code in the 
"^DD",773,773,90.07,21,2,0)
HLP("SUBSCRIBER"[,#]) subscriber entry.  When this is done, the 
"^DD",773,773,90.07,21,3,0)
subroutine being referenced is stored in the HLP-SUBROUTINE field 
"^DD",773,773,90.07,21,4,0)
(#90.06), and the routine is stored in this field.
"^DD",773,773,90.07,"DT")
3021022
"^DD",773,773,90.08,0)
HLP-DEBUG^F^^90;8^K:$L(X)>12!($L(X)<1) X
"^DD",773,773,90.08,3)
This field's source is the HLP("SUBSCRIBER"[,#]) array (1-12 characters)
"^DD",773,773,90.08,21,0)
^^28^28^3021210^
"^DD",773,773,90.08,21,1,0)
The application developer can control what type of debugging data is 
"^DD",773,773,90.08,21,2,0)
stored when MSH segment fields are reset by the HLP("SUBSCRIBER"[,#]) 
"^DD",773,773,90.08,21,3,0)
entry.  This field holds the data on the eighth piece of the 
"^DD",773,773,90.08,21,4,0)
HLP("SUBSCRIBER"[,#]) entry, which also specifies which debugging data 
"^DD",773,773,90.08,21,5,0)
should be stored.
"^DD",773,773,90.08,21,6,0)
 
"^DD",773,773,90.08,21,7,0)
Types Debug Data:
"^DD",773,773,90.08,21,8,0)
-----------------
"^DD",773,773,90.08,21,9,0)
There are three types of debug data:
"^DD",773,773,90.08,21,10,0)
 
"^DD",773,773,90.08,21,11,0)
  - Node ^HLMA(ien,90) data.  (See global map of this file for fields.)
"^DD",773,773,90.08,21,12,0)
  - Node ^HLMA(ien,91) data.  (See global map of this file for fields.)
"^DD",773,773,90.08,21,13,0)
  - ^XTMP("HLCSHDR3 ien") data.  (See patch documentation for 
"^DD",773,773,90.08,21,14,0)
    explanation.)
"^DD",773,773,90.08,21,15,0)
 
"^DD",773,773,90.08,21,16,0)
Syntax:  
"^DD",773,773,90.08,21,17,0)
-------
"^DD",773,773,90.08,21,18,0)
The syntax for the eight piece of the HLP("SUBSCRIBER"[,#]) array entry, 
"^DD",773,773,90.08,21,19,0)
(which is also the value for this field), is:
"^DD",773,773,90.08,21,20,0)
 
"^DD",773,773,90.08,21,21,0)
   [1]-[1]-[1]      
"^DD",773,773,90.08,21,22,0)
 
"^DD",773,773,90.08,21,23,0)
The [brackets] above indicate optionality; any of the three 
"^DD",773,773,90.08,21,24,0)
dash-delimited pieces may be null.
"^DD",773,773,90.08,21,25,0)
 
"^DD",773,773,90.08,21,26,0)
Examples:  1-1-1 -> ^HLMA(ien,90), ^HLMA(ien,91) and ^XTMP data captured.
"^DD",773,773,90.08,21,27,0)
           1--1 -> ^HLMA(ien,90 and ^XTMP data captured.
"^DD",773,773,90.08,21,28,0)
           --1 -> Only ^XTMP data captured.
"^DD",773,773,90.08,"DT")
3021022
"^DD",773,773,91.01,0)
ORIGINAL SND APP^F^^91;1^K:$L(X)>45!($L(X)<1) X
"^DD",773,773,91.01,3)
This field contains the value of the SENDING APPLICATION before overwrite.
"^DD",773,773,91.01,21,0)
^^6^6^3021210^
"^DD",773,773,91.01,21,1,0)
The value of the SENDING APPLICATION is calculated from the event driver
"^DD",773,773,91.01,21,2,0)
protocol.  If this value is overwritten by a HLP("SUBSCRIBER"[,#]) entry,
"^DD",773,773,91.01,21,3,0)
the value before overwrite is stored in this field.
"^DD",773,773,91.01,21,4,0)
 
"^DD",773,773,91.01,21,5,0)
Note:  Fields 91.03, 91.05, and 91.07 similarly hold the pre-overwrite
"^DD",773,773,91.01,21,6,0)
       values for their respective fields.
"^DD",773,773,91.01,"DT")
3030123
"^DD",773,773,91.02,0)
ORIGINAL SND APP-SOURCE^S^A:ARRAY;M:M CODE;^91;2^Q
"^DD",773,773,91.02,3)
This field records whether the overwrite was created by the HLP("SUBSCRIBER"[,#]) array, or by M code.
"^DD",773,773,91.02,21,0)
^^5^5^3021210^
"^DD",773,773,91.02,21,1,0)
MSH segment fields can be overwritten by free-text values on pieces 2 
"^DD",773,773,91.02,21,2,0)
through 5 of the HLP("SUBSCRIBER"[,#]) node, or by M code referenced in 
"^DD",773,773,91.02,21,3,0)
this node.  If the HLP-ORIGINAL SND APP field (#91.01) is overwritten by 
"^DD",773,773,91.02,21,4,0)
free-text data, this field will hold an "A" (for array.)  If overwritten 
"^DD",773,773,91.02,21,5,0)
by M code this field will hold "M".
"^DD",773,773,91.02,"DT")
3030123
"^DD",773,773,91.03,0)
ORIGINAL SND FAC^F^^91;3^K:$L(X)>30!($L(X)<1) X
"^DD",773,773,91.03,3)
This field contains the value of the SENDING FACILITY before overwrite.
"^DD",773,773,91.03,21,0)
^.001^3^3^3021210^^
"^DD",773,773,91.03,21,1,0)
The value of the SENDING FACILITY is calculated from the event driver
"^DD",773,773,91.03,21,2,0)
protocol.  If this value is overwritten by a HLP("SUBSCRIBER"[,#]) entry,
"^DD",773,773,91.03,21,3,0)
the value before overwrite is stored in this field.
"^DD",773,773,91.03,"DT")
3030123
"^DD",773,773,91.04,0)
ORIGINAL SND FAC-SOURCE^S^A:ARRAY;M:M CODE;^91;4^Q
"^DD",773,773,91.04,3)
This field records whether the overwrite was created by the HLP("SUBSCRIBER"[,#]) array, or by M code.
"^DD",773,773,91.04,21,0)
^^5^5^3021210^
"^DD",773,773,91.04,21,1,0)
MSH segment fields can be overwritten by free-text values on pieces 2 
"^DD",773,773,91.04,21,2,0)
through 5 of the HLP("SUBSCRIBER"[,#]) node, or by M code referenced in 
"^DD",773,773,91.04,21,3,0)
this node.  If the HLP-ORIGINAL SND FAC field (#91.03) is overwritten by 
"^DD",773,773,91.04,21,4,0)
free-text data, this field will hold an "A" (for array.)  If overwritten 
"^DD",773,773,91.04,21,5,0)
by M code this field will hold "M".
"^DD",773,773,91.04,"DT")
3030123
"^DD",773,773,91.05,0)
ORIGINAL REC APP^F^^91;5^K:$L(X)>45!($L(X)<1) X
"^DD",773,773,91.05,3)
This field contains the value of the RECEIVING APPLICATION before overwrite.
"^DD",773,773,91.05,21,0)
^^3^3^3021210^
"^DD",773,773,91.05,21,1,0)
The value of the RECEIVING APPLICATION is calculated from the subscriber
"^DD",773,773,91.05,21,2,0)
protocol.  If this value is overwritten by a HLP("SUBSCRIBER"[,#]) entry,
"^DD",773,773,91.05,21,3,0)
the value before overwrite is stored in this field.
"^DD",773,773,91.05,"DT")
3030123
"^DD",773,773,91.06,0)
ORIGINAL REC APP-SOURCE^S^A:ARRAY;M:M CODE;^91;6^Q
"^DD",773,773,91.06,3)
This field records whether the overwrite was created by the HLP("SUBSCRIBER"[,#]) array, or by M code.
"^DD",773,773,91.06,21,0)
^^5^5^3021210^
"^DD",773,773,91.06,21,1,0)
MSH segment fields can be overwritten by free-text values on pieces 2 
"^DD",773,773,91.06,21,2,0)
through 5 of the HLP("SUBSCRIBER"[,#]) node, or by M code referenced in 
"^DD",773,773,91.06,21,3,0)
this node.  If the HLP-ORIGINAL REC APP field (#91.05) is overwritten by 
"^DD",773,773,91.06,21,4,0)
free-text data, this field will hold an "A" (for array.)  If overwritten 
"^DD",773,773,91.06,21,5,0)
by M code this field will hold "M".
"^DD",773,773,91.06,"DT")
3030123
"^DD",773,773,91.07,0)
ORIGINAL REC FAC^F^^91;7^K:$L(X)>30!($L(X)<1) X
"^DD",773,773,91.07,3)
This field contains the value of the SENDING FACILITY before overwrite.
"^DD",773,773,91.07,21,0)
^^3^3^3021210^
"^DD",773,773,91.07,21,1,0)
The value of the RECEIVING FACILITY is calculated from the subscriber
"^DD",773,773,91.07,21,2,0)
protocol. If this value is overwritten by a HLP("SUBSCRIBER"[,#]) entry,
"^DD",773,773,91.07,21,3,0)
the value before overwrite is stored in this field.
"^DD",773,773,91.07,"DT")
3030321
"^DD",773,773,91.08,0)
ORIGINAL REC FAC-SOURCE^S^A:ARRAY;M:M CODE;^91;8^Q
"^DD",773,773,91.08,3)
This field records whether the overwrite was created by the HLP("SUBSCRIBER"[,#]) array, or by M code.
"^DD",773,773,91.08,21,0)
^^5^5^3021210^
"^DD",773,773,91.08,21,1,0)
MSH segment fields can be overwritten by free-text values on pieces 2 
"^DD",773,773,91.08,21,2,0)
through 5 of the HLP("SUBSCRIBER"[,#]) node, or by M code referenced in 
"^DD",773,773,91.08,21,3,0)
this node.  If the HLP-ORIGINAL REC FAC field (#91.07) is overwritten by 
"^DD",773,773,91.08,21,4,0)
free-text data, this field will hold an "A" (for array.)  If overwritten 
"^DD",773,773,91.08,21,5,0)
by M code this field will hold "M".
"^DD",773,773,91.08,"DT")
3030321
"^DD",773,773,100,0)
DATE/TIME PROCESSED^D^^S;1^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",773,773,100,1,0)
^.1^^-1
"^DD",773,773,100,1,1,0)
773^AD^MUMPS
"^DD",773,773,100,1,1,1)
S ^HLMA("AD",X,DA)="" N %,%1 S %=$G(^HLMA(DA,0)),%1=$P(%,U,3),%=$P(%,U,7) K:%1]""&% ^HLMA("AC",%1,%,DA)
"^DD",773,773,100,1,1,2)
K ^HLMA("AD",X,DA)
"^DD",773,773,100,1,1,3)
Required to determine if a message has been processed.
"^DD",773,773,100,1,1,"%D",0)
^.101^2^2^3031208^^^^
"^DD",773,773,100,1,1,"%D",1,0)
This cross-reference is used to remove messages from the 'AC' x-ref. after
"^DD",773,773,100,1,1,"%D",2,0)
they have been processed.  It also set the 'AD' x-ref for the date processed.
"^DD",773,773,100,1,1,"DT")
3031208
"^DD",773,773,100,3)
The date and time this transmission was processed.
"^DD",773,773,100,21,0)
^^4^4^2980526^
"^DD",773,773,100,21,1,0)
The date and time this message was processed (sent or received).
"^DD",773,773,100,21,2,0)
For outgoing messages, it is the time the message was actually
"^DD",773,773,100,21,3,0)
transmitted.  For incoming messages, it is the time the application
"^DD",773,773,100,21,4,0)
processed the message.
"^DD",773,773,100,"DT")
3031208
"^DD",773,773,200,0)
MSH^773.01^^MSH;0
"^DD",773,773.01,0)
MSH SUB-FIELD^^.01^1
"^DD",773,773.01,0,"DT")
2980423
"^DD",773,773.01,0,"NM","MSH")

"^DD",773,773.01,0,"UP")
773
"^DD",773,773.01,.01,0)
MSH^WL^^0;1^Q
"^DD",773,773.01,.01,21,0)
^^1^1^2980423^
"^DD",773,773.01,.01,21,1,0)
This is the message header, MSH, for this message.
"^DD",773,773.01,.01,"DT")
2980423
"^DD",776,776,0)
FIELD^^52^13
"^DD",776,776,0,"DT")
3030805
"^DD",776,776,0,"IX","B",776,.01)

"^DD",776,776,0,"IX","M",776,3)

"^DD",776,776,0,"NM","HL7 MONITOR JOB")

"^DD",776,776,0,"VRPK")
HL
"^DD",776,776,.01,0)
START TIME^RD^^0;1^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",776,776,.01,1,0)
^.1
"^DD",776,776,.01,1,1,0)
776^B
"^DD",776,776,.01,1,1,1)
S ^HLEV(776,"B",$E(X,1,30),DA)=""
"^DD",776,776,.01,1,1,2)
K ^HLEV(776,"B",$E(X,1,30),DA)
"^DD",776,776,.01,1,1,"%D",0)
^^2^2^3040112^
"^DD",776,776,.01,1,1,"%D",1,0)
This cross-reference holds the time when the monitor started (was queued
"^DD",776,776,.01,1,1,"%D",2,0)
as a background job.)
"^DD",776,776,.01,3)

"^DD",776,776,.01,21,0)
^^2^2^3031014^
"^DD",776,776,.01,21,1,0)
This field holds the time when the HL7 Monitor Job file (#776) entry was
"^DD",776,776,.01,21,2,0)
created.
"^DD",776,776,.01,"DT")
3030518
"^DD",776,776,2,0)
COMPLETION TIME^D^^0;2^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",776,776,2,21,0)
^^1^1^3030822^
"^DD",776,776,2,21,1,0)
This field holds the time the background job finished.
"^DD",776,776,2,"DT")
3030822
"^DD",776,776,3,0)
MONITOR-PTR^P776.1'^HLEV(776.1,^0;3^Q
"^DD",776,776,3,1,0)
^.1
"^DD",776,776,3,1,1,0)
776^M
"^DD",776,776,3,1,1,1)
S ^HLEV(776,"M",$E(X,1,30),DA)=""
"^DD",776,776,3,1,1,2)
K ^HLEV(776,"M",$E(X,1,30),DA)
"^DD",776,776,3,1,1,"%D",0)
^^13^13^3040112^
"^DD",776,776,3,1,1,"%D",1,0)
With each Monitor Master Job run, the master job checks every monitor entry
"^DD",776,776,3,1,1,"%D",2,0)
in the HL Event Monitor file (#776.1).  If it is "time" for the monitor
"^DD",776,776,3,1,1,"%D",3,0)
to be queued, a background job is queued to run that monitor.  At the
"^DD",776,776,3,1,1,"%D",4,0)
time of queueing an entry is created in this file holding (among other
"^DD",776,776,3,1,1,"%D",5,0)
values) the internal entry number of the monitor entry in file 776.1.
"^DD",776,776,3,1,1,"%D",6,0)
The IEN is stored in the Monitor field (#3), and this M cross-reference
"^DD",776,776,3,1,1,"%D",7,0)
holds the IEN of the monitor.
"^DD",776,776,3,1,1,"%D",8,0)
 
"^DD",776,776,3,1,1,"%D",9,0)
Note: The Monitor field does not point to the monitor, strictly speaking,
"^DD",776,776,3,1,1,"%D",10,0)
      because this field is a free-text field.  However, since it holds
"^DD",776,776,3,1,1,"%D",11,0)
      the IEN, it is a "functional pointer" to the monitor file.
"^DD",776,776,3,1,1,"%D",12,0)
      (The field was created this way to enable monitors to be deleted
"^DD",776,776,3,1,1,"%D",13,0)
      at will without worry about dangling pointers.)
"^DD",776,776,3,1,1,"DT")
3030521
"^DD",776,776,3,21,0)
^^2^2^3030822^
"^DD",776,776,3,21,1,0)
This field holds the internal entry number of the monitor entry in the HL 
"^DD",776,776,3,21,2,0)
Event Monitor file (#776.1).
"^DD",776,776,3,"DT")
3030822
"^DD",776,776,4,0)
STATUS-RUNTIME^S^E:ERROR;F:FINISHED;Q:QUEUED;R:RUNNING;^0;4^Q
"^DD",776,776,4,21,0)
^^1^1^3030822^
"^DD",776,776,4,21,1,0)
This field holds the run-time status of the background job.
"^DD",776,776,4,"DT")
3030518
"^DD",776,776,5,0)
STATUS-APPLICATION^F^^0;5^K:$L(X)>10!($L(X)<1) X
"^DD",776,776,5,3)
Answer must be 1-10 characters in length.
"^DD",776,776,5,21,0)
^^2^2^3030822^
"^DD",776,776,5,21,1,0)
This field holds the status provided by the application.  Entry of this 
"^DD",776,776,5,21,2,0)
field is optional.
"^DD",776,776,5,"DT")
3030518
"^DD",776,776,6,0)
TIMESTAMP^D^^0;6^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",776,776,6,21,0)
^^2^2^3030822^
"^DD",776,776,6,21,1,0)
Periodically, during the running of the job, this field is updated with 
"^DD",776,776,6,21,2,0)
the time "now", which is stored in this field.
"^DD",776,776,6,"DT")
3030518
"^DD",776,776,7,0)
MAILMAN PTR^NJ12,0^^0;7^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",776,776,7,3)
Type a Number between 1 and 999999999999, 0 Decimal Digits
"^DD",776,776,7,21,0)
^^2^2^3030822^
"^DD",776,776,7,21,1,0)
When the job finishes, if a notification Mailman message is sent, it's 
"^DD",776,776,7,21,2,0)
internal entry number if stored in this field.
"^DD",776,776,7,"DT")
3030714
"^DD",776,776,8,0)
TASK NUMBER^NJ12,0^^0;8^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",776,776,8,3)
Type a Number between 1 and 999999999999, 0 Decimal Digits
"^DD",776,776,8,21,0)
^^1^1^3030822^
"^DD",776,776,8,21,1,0)
This field holds the task number for the background job.
"^DD",776,776,8,"DT")
3030523
"^DD",776,776,9,0)
MASTER JOB PTR^P776.2'^HLEV(776.2,^0;9^Q
"^DD",776,776,9,21,0)
^^4^4^3031014^
"^DD",776,776,9,21,1,0)
The master job checks all monitors, and where appropriate queues 
"^DD",776,776,9,21,2,0)
background jobs for each monitor.  These background jobs are linked to 
"^DD",776,776,9,21,3,0)
this file, and to entries in this file.  This field holds the master job 
"^DD",776,776,9,21,4,0)
internal entry number in the HL7 Monitor Master Job file (#776.2).
"^DD",776,776,9,"DT")
3030523
"^DD",776,776,10,0)
QUEUE TIME^D^^0;10^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",776,776,10,21,0)
^^3^3^3030822^
"^DD",776,776,10,21,1,0)
Normally, a background monitor job is queued to run now.  However, at 
"^DD",776,776,10,21,2,0)
times a monitor job is queued to a future time.  When this occurs, the 
"^DD",776,776,10,21,3,0)
future queue time is stored in this field.
"^DD",776,776,10,"DT")
3030610
"^DD",776,776,50,0)
RUN DIARY^776.001^^50;0
"^DD",776,776,50,21,0)
^^3^3^3030822^
"^DD",776,776,50,21,1,0)
Text is placed in this word processing field using the RUNDIARY^HLEVAPI 
"^DD",776,776,50,21,2,0)
API.  The contents of this field is under complete control by the using 
"^DD",776,776,50,21,3,0)
application.
"^DD",776,776,51,0)
MESSAGE TEXT^776.002^^51;0
"^DD",776,776,51,21,0)
^^3^3^3030822^
"^DD",776,776,51,21,1,0)
Text is placed in this word processing field using the MSGTEXT^HLEVAPI
"^DD",776,776,51,21,2,0)
API.  The contents of this field is under complete control by the using
"^DD",776,776,51,21,3,0)
application.
"^DD",776,776,51,"DT")
3030529
"^DD",776,776,52,0)
VARIABLE VALUE^776.003A^^52;0
"^DD",776,776,52,21,0)
^^2^2^3030822^
"^DD",776,776,52,21,1,0)
This field holds the variable names and values declared by the calling 
"^DD",776,776,52,21,2,0)
application.
"^DD",776,776.001,0)
RUN DIARY SUB-FIELD^^.01^1
"^DD",776,776.001,0,"DT")
3030518
"^DD",776,776.001,0,"NM","RUN DIARY")

"^DD",776,776.001,0,"UP")
776
"^DD",776,776.001,.01,0)
RUN DIARY^WL^^0;1^Q
"^DD",776,776.001,.01,"DT")
3030518
"^DD",776,776.002,0)
MESSAGE TEXT SUB-FIELD^^.01^1
"^DD",776,776.002,0,"DT")
3030520
"^DD",776,776.002,0,"NM","MESSAGE TEXT")

"^DD",776,776.002,0,"UP")
776
"^DD",776,776.002,.01,0)
MESSAGE TEXT^WL^^0;1^Q
"^DD",776,776.002,.01,"DT")
3030529
"^DD",776,776.003,0)
VARIABLE VALUE SUB-FIELD^^52^3
"^DD",776,776.003,0,"DT")
3030523
"^DD",776,776.003,0,"IX","B",776.003,.01)

"^DD",776,776.003,0,"NM","VARIABLE VALUE")

"^DD",776,776.003,0,"UP")
776
"^DD",776,776.003,.01,0)
VARIABLE^F^^0;1^K:$L(X)>30!($L(X)<1) X
"^DD",776,776.003,.01,1,0)
^.1
"^DD",776,776.003,.01,1,1,0)
776.003^B
"^DD",776,776.003,.01,1,1,1)
S ^HLEV(776,DA(1),52,"B",$E(X,1,30),DA)=""
"^DD",776,776.003,.01,1,1,2)
K ^HLEV(776,DA(1),52,"B",$E(X,1,30),DA)
"^DD",776,776.003,.01,3)
Answer must be 1-30 characters in length.
"^DD",776,776.003,.01,"DT")
3030523
"^DD",776,776.003,2,0)
EXPLANATION^F^^0;2^K:$L(X)>30!($L(X)<1) X
"^DD",776,776.003,2,3)
Answer must be 1-30 characters in length.
"^DD",776,776.003,2,"DT")
3030523
"^DD",776,776.003,52,0)
VALUE^F^^52;E1,240^K:$L(X)>240!($L(X)<1) X
"^DD",776,776.003,52,3)
Answer must be 1-240 characters in length.
"^DD",776,776.003,52,"DT")
3030523
"^DD",776.1,776.1,0)
FIELD^^53^12
"^DD",776.1,776.1,0,"DT")
3030807
"^DD",776.1,776.1,0,"IX","B",776.1,.01)

"^DD",776.1,776.1,0,"NM","HL7 MONITOR")

"^DD",776.1,776.1,0,"PT",776,3)

"^DD",776.1,776.1,0,"VRPK")
HL
"^DD",776.1,776.1,.01,0)
NAME^RFX^^0;1^K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E)!($D(^HLEV(776.1,"B",X))) X
"^DD",776.1,776.1,.01,1,0)
^.1
"^DD",776.1,776.1,.01,1,1,0)
776.1^B
"^DD",776.1,776.1,.01,1,1,1)
S ^HLEV(776.1,"B",$E(X,1,30),DA)=""
"^DD",776.1,776.1,.01,1,1,2)
K ^HLEV(776.1,"B",$E(X,1,30),DA)
"^DD",776.1,776.1,.01,1,1,"%D",0)
^^2^2^3040112^
"^DD",776.1,776.1,.01,1,1,"%D",1,0)
The name of a monitor is stored on the Name field (#.01), and the B xref
"^DD",776.1,776.1,.01,1,1,"%D",2,0)
is created based on the value of the Name field.
"^DD",776.1,776.1,.01,3)
NAME MUST BE 3-30 CHARACTERS, NOT NUMERIC OR STARTING WITH PUNCTUATION
"^DD",776.1,776.1,.01,21,0)
^^1^1^3030822^
"^DD",776.1,776.1,.01,21,1,0)
This field holds the free-text name of the monitor.
"^DD",776.1,776.1,.01,"DT")
3030520
"^DD",776.1,776.1,2,0)
STATUS^S^A:ACTIVE;I:INACTIVE;^0;2^Q
"^DD",776.1,776.1,2,21,0)
^^3^3^3030822^
"^DD",776.1,776.1,2,21,1,0)
The values for this set of code field are ACTIVE and INACTIVE.  If set to 
"^DD",776.1,776.1,2,21,2,0)
ACTIVE the master job will queue background monitor jobs for the 
"^DD",776.1,776.1,2,21,3,0)
monitor.  If set to INACTIVE the master job will ignore the entry.
"^DD",776.1,776.1,2,"DT")
3030518
"^DD",776.1,776.1,3,0)
SHORT DESCRIPTION^F^^0;3^K:$L(X)>40!($L(X)<3) X
"^DD",776.1,776.1,3,3)
Answer must be 3-40 characters in length.
"^DD",776.1,776.1,3,21,0)
^^1^1^3030822^
"^DD",776.1,776.1,3,21,1,0)
This field holds a short description of the monitor.  
"^DD",776.1,776.1,3,"DT")
3030518
"^DD",776.1,776.1,4,0)
REQUEUE MIN-MONITOR^NJ7,0^^0;4^K:+X'=X!(X>9999999)!(X<0)!(X?.E1"."1N.N) X
"^DD",776.1,776.1,4,3)
Type a Number between 0 and 9999999, 0 Decimal Digits
"^DD",776.1,776.1,4,21,0)
^^8^8^3031014^
"^DD",776.1,776.1,4,21,1,0)
Whenever the master job runs it checks every entry in this HL7 Monitor
"^DD",776.1,776.1,4,21,2,0)
file (#776.1).  If an entry is active, a secondary check is made whether
"^DD",776.1,776.1,4,21,3,0)
"it is time" to start a background job for the monitor.  If the active
"^DD",776.1,776.1,4,21,4,0)
monitor has never been run, a background job is started.  If the monitor
"^DD",776.1,776.1,4,21,5,0)
has been run, then the next "time to run" is calculated by adding the
"^DD",776.1,776.1,4,21,6,0)
number of minutes specified in this field to the time the monitor was last
"^DD",776.1,776.1,4,21,7,0)
run.  If the next "time to run" is now (or earlier), a background job for
"^DD",776.1,776.1,4,21,8,0)
the monitor is started.
"^DD",776.1,776.1,4,"DT")
3030521
"^DD",776.1,776.1,5,0)
REMOTE REQUESTABLE^S^0:NO;1:YES;^0;5^Q
"^DD",776.1,776.1,5,21,0)
^^1^1^3030822^
"^DD",776.1,776.1,5,21,1,0)
This field is not currently in use.
"^DD",776.1,776.1,5,"DT")
3030617
"^DD",776.1,776.1,6,0)
M STARTUP^F^^0;6^K:$L(X)>17!($L(X)<3)!'(X?1.8E1"~"1.8E) X
"^DD",776.1,776.1,6,3)
Enter the M location for event startup in the format SUBROUTINE~ROUTINE.  (E.g., START~HLEVAPI.)
"^DD",776.1,776.1,6,21,0)
^^3^3^3030822^
"^DD",776.1,776.1,6,21,1,0)
Background tasks, started by the master job, are queued to the API 
"^DD",776.1,776.1,6,21,2,0)
specified in this field.  (The value of this field must be in the format 
"^DD",776.1,776.1,6,21,3,0)
of TAG~ROUTINE, which is converted to TAG^ROUTINE at run time.)
"^DD",776.1,776.1,6,"DT")
3030520
"^DD",776.1,776.1,7,0)
M START CHECK^F^^0;7^K:$L(X)>19!($L(X)<3)!'(X?1"$$"1.8E1"~"1.8E) X
"^DD",776.1,776.1,7,3)
Must be an extrinsic function in the format of $$TAG^ROUTINE
"^DD",776.1,776.1,7,21,0)
^^9^9^3030822^
"^DD",776.1,776.1,7,21,1,0)
Normally, the only test made by the master job to determine whether a 
"^DD",776.1,776.1,7,21,2,0)
monitor job should be started is STATUS (it must be ACTIVE) and the 
"^DD",776.1,776.1,7,21,3,0)
requeue minutes.  However, if this field is filled in with an extrinsic 
"^DD",776.1,776.1,7,21,4,0)
function that returns a positive or null value, it can be used as an 
"^DD",776.1,776.1,7,21,5,0)
additional test.
"^DD",776.1,776.1,7,21,6,0)
 
"^DD",776.1,776.1,7,21,7,0)
Let's say that the extrinsic fuction $$RUNOW^ROUTINE returns a 1 if a 
"^DD",776.1,776.1,7,21,8,0)
background job should be started, or null if not.  In this case, 
"^DD",776.1,776.1,7,21,9,0)
"$$RUNOW^ROUTINE" should be entered in this field.
"^DD",776.1,776.1,7,"DT")
3030807
"^DD",776.1,776.1,41,0)
TECHNICAL DESCRIPTION^776.1041^^41;0
"^DD",776.1,776.1,41,21,0)
^^2^2^3030822^
"^DD",776.1,776.1,41,21,1,0)
This field holds any additional technical notes deemed necessary by the 
"^DD",776.1,776.1,41,21,2,0)
monitor creator.
"^DD",776.1,776.1,41,"DT")
3030523
"^DD",776.1,776.1,50,0)
EVENT DESCRIPTION^776.101^^50;0
"^DD",776.1,776.1,50,21,0)
^^4^4^3030822^
"^DD",776.1,776.1,50,21,1,0)
This field should be used by the application developer to describe the 
"^DD",776.1,776.1,50,21,2,0)
monitor, and how it is used.  (If desired, the application developer may 
"^DD",776.1,776.1,50,21,3,0)
add additional, more technical notes in the TECHNICAL DESCRIPTION word 
"^DD",776.1,776.1,50,21,4,0)
processing field.)
"^DD",776.1,776.1,51,0)
MAIL GROUPS^776.106P^^60;0
"^DD",776.1,776.1,51,21,0)
^^16^16^3030822^
"^DD",776.1,776.1,51,21,1,0)
When a monitor runs, the M code can conditionally send a mail message to 
"^DD",776.1,776.1,51,21,2,0)
recipients.  This field, and other fields, are used to determine the 
"^DD",776.1,776.1,51,21,3,0)
recipients.  In addition, recipients can be added by M code immediately 
"^DD",776.1,776.1,51,21,4,0)
before the sending of the message.
"^DD",776.1,776.1,51,21,5,0)
 
"^DD",776.1,776.1,51,21,6,0)
The fields used to determine mail message recipients are:
"^DD",776.1,776.1,51,21,7,0)
 
"^DD",776.1,776.1,51,21,8,0)
* MAIL GROUPS (#60) - pointer to the Mail Group file (#3.8.)
"^DD",776.1,776.1,51,21,9,0)
* RECIPIENTS (#61) - pointer to the New Person file (#200.)
"^DD",776.1,776.1,51,21,10,0)
* REMOTES (#62) - free-text remote recipient addresses.
"^DD",776.1,776.1,51,21,11,0)
 
"^DD",776.1,776.1,51,21,12,0)
And, remember that additional recipients can be added (by populating the 
"^DD",776.1,776.1,51,21,13,0)
XMY array) on-the-fly at the time the message is sent.
"^DD",776.1,776.1,51,21,14,0)
 
"^DD",776.1,776.1,51,21,15,0)
Please refer to the documentation included with patch HL*1.6*106 for 
"^DD",776.1,776.1,51,21,16,0)
additional explanation.
"^DD",776.1,776.1,52,0)
RECIPIENTS^776.1061P^^61;0
"^DD",776.1,776.1,52,21,0)
^^1^1^3030822^
"^DD",776.1,776.1,52,21,1,0)
See documentation for the MAIL GROUPS field.
"^DD",776.1,776.1,53,0)
REMOTES^776.1062^^62;0
"^DD",776.1,776.1,53,21,0)
^^1^1^3030822^
"^DD",776.1,776.1,53,21,1,0)
See documentation for the MAIL GROUPS field.
"^DD",776.1,776.101,0)
EVENT DESCRIPTION SUB-FIELD^^.01^1
"^DD",776.1,776.101,0,"DT")
3030518
"^DD",776.1,776.101,0,"NM","EVENT DESCRIPTION")

"^DD",776.1,776.101,0,"UP")
776.1
"^DD",776.1,776.101,.01,0)
EVENT DESCRIPTION^WL^^0;1^Q
"^DD",776.1,776.101,.01,"DT")
3030518
"^DD",776.1,776.1041,0)
TECHNICAL DESCRIPTION SUB-FIELD^^.01^1
"^DD",776.1,776.1041,0,"DT")
3030518
"^DD",776.1,776.1041,0,"NM","TECHNICAL DESCRIPTION")

"^DD",776.1,776.1041,0,"UP")
776.1
"^DD",776.1,776.1041,.01,0)
TECHNICAL DESCRIPTION^WL^^0;1^Q
"^DD",776.1,776.1041,.01,"DT")
3030523
"^DD",776.1,776.106,0)
MAIL GROUPS SUB-FIELD^^.01^1
"^DD",776.1,776.106,0,"DT")
3030601
"^DD",776.1,776.106,0,"IX","B",776.106,.01)

"^DD",776.1,776.106,0,"NM","MAIL GROUPS")

"^DD",776.1,776.106,0,"UP")
776.1
"^DD",776.1,776.106,.01,0)
MAIL GROUPS^MP3.8'^XMB(3.8,^0;1^Q
"^DD",776.1,776.106,.01,1,0)
^.1
"^DD",776.1,776.106,.01,1,1,0)
776.106^B
"^DD",776.1,776.106,.01,1,1,1)
S ^HLEV(776.1,DA(1),60,"B",$E(X,1,30),DA)=""
"^DD",776.1,776.106,.01,1,1,2)
K ^HLEV(776.1,DA(1),60,"B",$E(X,1,30),DA)
"^DD",776.1,776.106,.01,"DT")
3030601
"^DD",776.1,776.1061,0)
RECIPIENTS SUB-FIELD^^.01^1
"^DD",776.1,776.1061,0,"DT")
3030601
"^DD",776.1,776.1061,0,"IX","B",776.1061,.01)

"^DD",776.1,776.1061,0,"NM","RECIPIENTS")

"^DD",776.1,776.1061,0,"UP")
776.1
"^DD",776.1,776.1061,.01,0)
RECIPIENTS^MP200'^VA(200,^0;1^Q
"^DD",776.1,776.1061,.01,1,0)
^.1
"^DD",776.1,776.1061,.01,1,1,0)
776.1061^B
"^DD",776.1,776.1061,.01,1,1,1)
S ^HLEV(776.1,DA(1),61,"B",$E(X,1,30),DA)=""
"^DD",776.1,776.1061,.01,1,1,2)
K ^HLEV(776.1,DA(1),61,"B",$E(X,1,30),DA)
"^DD",776.1,776.1061,.01,"DT")
3030601
"^DD",776.1,776.1062,0)
REMOTES SUB-FIELD^^.01^1
"^DD",776.1,776.1062,0,"DT")
3030601
"^DD",776.1,776.1062,0,"IX","B",776.1062,.01)

"^DD",776.1,776.1062,0,"NM","REMOTES")

"^DD",776.1,776.1062,0,"UP")
776.1
"^DD",776.1,776.1062,.01,0)
REMOTES^MF^^0;1^K:$L(X)>80!($L(X)<3)!'(X?1.E1"@"1.E) X
"^DD",776.1,776.1062,.01,1,0)
^.1
"^DD",776.1,776.1062,.01,1,1,0)
776.1062^B
"^DD",776.1,776.1062,.01,1,1,1)
S ^HLEV(776.1,DA(1),62,"B",$E(X,1,30),DA)=""
"^DD",776.1,776.1062,.01,1,1,2)
K ^HLEV(776.1,DA(1),62,"B",$E(X,1,30),DA)
"^DD",776.1,776.1062,.01,3)
Enter email address of remote recipient for this monitor.  (Format is 'name@address'.)
"^DD",776.1,776.1062,.01,"DT")
3030601
"^DD",776.2,776.2,0)
FIELD^^51^10
"^DD",776.2,776.2,0,"DT")
3030807
"^DD",776.2,776.2,0,"IX","B",776.2,.01)

"^DD",776.2,776.2,0,"NM","HL7 MONITOR MASTER JOB")

"^DD",776.2,776.2,0,"PT",776,9)

"^DD",776.2,776.2,0,"VRPK")
HL
"^DD",776.2,776.2,.01,0)
CREATION TIME^RD^^0;1^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",776.2,776.2,.01,1,0)
^.1
"^DD",776.2,776.2,.01,1,1,0)
776.2^B
"^DD",776.2,776.2,.01,1,1,1)
S ^HLEV(776.2,"B",$E(X,1,30),DA)=""
"^DD",776.2,776.2,.01,1,1,2)
K ^HLEV(776.2,"B",$E(X,1,30),DA)
"^DD",776.2,776.2,.01,1,1,"%D",0)
^^5^5^3040112^
"^DD",776.2,776.2,.01,1,1,"%D",1,0)
On a parameter-controlled frequency, a master job is run to determine 
"^DD",776.2,776.2,.01,1,1,"%D",2,0)
whether individual monitors should be run.  When these master jobs start,
"^DD",776.2,776.2,.01,1,1,"%D",3,0)
an entry is made in the HL Event Master Job file (#776.2).   The .01
"^DD",776.2,776.2,.01,1,1,"%D",4,0)
field of this file is Creation Time, and this B xref is created based
"^DD",776.2,776.2,.01,1,1,"%D",5,0)
on the date/time value in this field.
"^DD",776.2,776.2,.01,3)

"^DD",776.2,776.2,.01,21,0)
^^2^2^3030822^
"^DD",776.2,776.2,.01,21,1,0)
This field holds the time when the entry in this file was created (at the 
"^DD",776.2,776.2,.01,21,2,0)
beginning of the running of the background master job.)
"^DD",776.2,776.2,.01,"DT")
3030601
"^DD",776.2,776.2,2,0)
COMPLETION TIME^D^^0;2^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",776.2,776.2,2,21,0)
^^1^1^3030822^
"^DD",776.2,776.2,2,21,1,0)
This field holds the time when the master job completed.
"^DD",776.2,776.2,2,"DT")
3030518
"^DD",776.2,776.2,3,0)
TIMESTAMP^D^^0;3^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",776.2,776.2,3,21,0)
^^3^3^3030822^
"^DD",776.2,776.2,3,21,1,0)
Periodically, when the master job is running, this timestamp is 
"^DD",776.2,776.2,3,21,2,0)
refreshed.  Normally, this timestamp will be equal to the completion time 
"^DD",776.2,776.2,3,21,3,0)
of the master job.
"^DD",776.2,776.2,3,"DT")
3030518
"^DD",776.2,776.2,4,0)
STATUS^S^E:ERRORED;F:FINISHED;Q:QUEUED;R:RUNNING;P:PARAMETER STOP;S:STOP REQUESTED;A:ABORTED-NOT RUN;^0;4^Q
"^DD",776.2,776.2,4,21,0)
^^1^1^3030822^
"^DD",776.2,776.2,4,21,1,0)
This field holds the status of the master job.
"^DD",776.2,776.2,4,"DT")
3030601
"^DD",776.2,776.2,5,0)
TASK NUMBER^NJ12,0^^0;5^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",776.2,776.2,5,3)
Type a Number between 1 and 999999999999, 0 Decimal Digits
"^DD",776.2,776.2,5,21,0)
^^1^1^3030822^
"^DD",776.2,776.2,5,21,1,0)
This field holds the task number for the background master job.
"^DD",776.2,776.2,5,"DT")
3030518
"^DD",776.2,776.2,6,0)
QUEUE TIME^D^^0;6^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",776.2,776.2,6,21,0)
^^4^4^3030822^
"^DD",776.2,776.2,6,21,1,0)
When the master job starts, as it's first action, it queues the next 
"^DD",776.2,776.2,6,21,2,0)
master job for a future time REQUEUE MINUTES in the future.  At that 
"^DD",776.2,776.2,6,21,3,0)
time, an entry is made in this file and the "future time" recorded in 
"^DD",776.2,776.2,6,21,4,0)
this field.
"^DD",776.2,776.2,6,"DT")
3030518
"^DD",776.2,776.2,7,0)
QUEUE PERSON^P200'^VA(200,^0;7^Q
"^DD",776.2,776.2,7,21,0)
^^3^3^3030822^
"^DD",776.2,776.2,7,21,1,0)
This field holds the DUZ of the person who started the master job the 
"^DD",776.2,776.2,7,21,2,0)
first time.  (From that time on, that person's DUZ will remain associated 
"^DD",776.2,776.2,7,21,3,0)
with all future master jobs.)
"^DD",776.2,776.2,7,"DT")
3030521
"^DD",776.2,776.2,8,0)
START TIME^D^^0;8^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",776.2,776.2,8,21,0)
^^2^2^3030822^
"^DD",776.2,776.2,8,21,1,0)
Master jobs are queued to a future time.  When these jobs activate, the 
"^DD",776.2,776.2,8,21,2,0)
time "now" is recorded in this field.
"^DD",776.2,776.2,8,"DT")
3030601
"^DD",776.2,776.2,50,0)
RUN DIARY^776.201^^50;0
"^DD",776.2,776.2,50,21,0)
^^2^2^3030822^
"^DD",776.2,776.2,50,21,1,0)
This field holds information about the master job process, and cannot be 
"^DD",776.2,776.2,50,21,2,0)
modified by non-VistA HL7 applications.
"^DD",776.2,776.2,51,0)
EVENTS CHECKED^776.2051A^^51;0
"^DD",776.2,776.2,51,21,0)
^^4^4^3030822^
"^DD",776.2,776.2,51,21,1,0)
When the master job runs, it checks all existing event monitors in the HL 
"^DD",776.2,776.2,51,21,2,0)
Event Monitor file (#776.1).  One entry in this Events Checked multiple is
"^DD",776.2,776.2,51,21,3,0)
made for every monitor found.  (See the fields in this multiple for 
"^DD",776.2,776.2,51,21,4,0)
additional information.)
"^DD",776.2,776.201,0)
RUN DIARY SUB-FIELD^^.01^1
"^DD",776.2,776.201,0,"DT")
3030518
"^DD",776.2,776.201,0,"NM","RUN DIARY")

"^DD",776.2,776.201,0,"UP")
776.2
"^DD",776.2,776.201,.01,0)
RUN DIARY^WL^^0;1^Q
"^DD",776.2,776.201,.01,"DT")
3030518
"^DD",776.2,776.2051,0)
EVENTS CHECKED SUB-FIELD^^8^8
"^DD",776.2,776.2051,0,"DT")
3030807
"^DD",776.2,776.2051,0,"IX","B",776.2051,.01)

"^DD",776.2,776.2051,0,"NM","EVENTS CHECKED")

"^DD",776.2,776.2051,0,"UP")
776.2
"^DD",776.2,776.2051,.01,0)
EVENT MONITOR IEN (Free-Text)^F^^0;1^K:$L(X)>12!($L(X)<1) X
"^DD",776.2,776.2051,.01,1,0)
^.1
"^DD",776.2,776.2051,.01,1,1,0)
776.2051^B
"^DD",776.2,776.2051,.01,1,1,1)
S ^HLEV(776.2,DA(1),51,"B",$E(X,1,30),DA)=""
"^DD",776.2,776.2051,.01,1,1,2)
K ^HLEV(776.2,DA(1),51,"B",$E(X,1,30),DA)
"^DD",776.2,776.2051,.01,3)
Answer must be 1-12 characters in length.
"^DD",776.2,776.2051,.01,21,0)
^^5^5^3030822^
"^DD",776.2,776.2051,.01,21,1,0)
This field holds the internal entry number of the monitor entry in the HL 
"^DD",776.2,776.2051,.01,21,2,0)
Event Monitor file (#776.1).  
"^DD",776.2,776.2051,.01,21,3,0)
 
"^DD",776.2,776.2051,.01,21,4,0)
NOTE: This is a free-text field, and not a pointer field!  This was done 
"^DD",776.2,776.2051,.01,21,5,0)
to ensure that monitors could be deleted without creating broken pointers.
"^DD",776.2,776.2051,.01,"DT")
3030523
"^DD",776.2,776.2051,2,0)
ACTION^S^E:TOO EARLY;I:INACTIVE;Q:QD NEW JOB;X:ERROR;R:RUNNING;M:M CHK FAIL;^0;2^Q
"^DD",776.2,776.2051,2,21,0)
^^6^6^3030822^
"^DD",776.2,776.2051,2,21,1,0)
When a monitor is checked, the master job either starts a background job 
"^DD",776.2,776.2051,2,21,2,0)
for the monitor, or it doesn't.  If it does, record is made of the fact 
"^DD",776.2,776.2051,2,21,3,0)
in this field.  If a monitor job is not started, the reason is also 
"^DD",776.2,776.2051,2,21,4,0)
recorded in this field.  (The Results field (#5) often holds additional 
"^DD",776.2,776.2051,2,21,5,0)
information about the action taken by the master job for a specific 
"^DD",776.2,776.2051,2,21,6,0)
monitor.)
"^DD",776.2,776.2051,2,"DT")
3030807
"^DD",776.2,776.2051,3,0)
CHECK/QUEUE TIME^D^^0;3^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",776.2,776.2051,3,21,0)
^^1^1^3030822^
"^DD",776.2,776.2051,3,21,1,0)
This field holds the time the master job checked the monitor.
"^DD",776.2,776.2051,3,"DT")
3030521
"^DD",776.2,776.2051,4,0)
TASK NUMBER^NJ14,0^^0;4^K:+X'=X!(X>99999999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",776.2,776.2051,4,3)
Type a Number between 1 and 99999999999999, 0 Decimal Digits
"^DD",776.2,776.2051,4,21,0)
^^2^2^3030822^
"^DD",776.2,776.2051,4,21,1,0)
This field holds the task number of the queued monitor job created by the 
"^DD",776.2,776.2051,4,21,2,0)
master job.
"^DD",776.2,776.2051,4,"DT")
3030521
"^DD",776.2,776.2051,5,0)
RESULTS^S^XE:ERROR-OTHER;XM:ERROR-M CODE;F:FINISHED;XL:ERROR-LOCK;^0;5^Q
"^DD",776.2,776.2051,5,21,0)
^^2^2^3030822^
"^DD",776.2,776.2051,5,21,1,0)
This field holds the additional information about the action taken by the 
"^DD",776.2,776.2051,5,21,2,0)
master job for the specific monitor recorded in multiple entries.
"^DD",776.2,776.2051,5,"DT")
3030711
"^DD",776.2,776.2051,6,0)
RESULTS TIME^D^^0;6^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",776.2,776.2051,6,21,0)
^^1^1^3030822^
"^DD",776.2,776.2051,6,21,1,0)
This field holds the time the RESULTS field is populated.
"^DD",776.2,776.2051,6,"DT")
3030521
"^DD",776.2,776.2051,7,0)
ERROR REASON^F^^0;7^K:$L(X)>30!($L(X)<3) X
"^DD",776.2,776.2051,7,3)
Answer must be 3-30 characters in length.
"^DD",776.2,776.2051,7,21,0)
^^2^2^3030822^
"^DD",776.2,776.2051,7,21,1,0)
This field holds optional free-text data that further illuminates the 
"^DD",776.2,776.2051,7,21,2,0)
actions taken by the master job.
"^DD",776.2,776.2051,7,"DT")
3030521
"^DD",776.2,776.2051,8,0)
EVENT JOB IEN (Free-Text)^F^^0;8^K:$L(X)>12!($L(X)<1) X
"^DD",776.2,776.2051,8,3)
Answer must be 1-12 characters in length.
"^DD",776.2,776.2051,8,21,0)
^^4^4^3030822^
"^DD",776.2,776.2051,8,21,1,0)
This field holds the task number of the background job created by the 
"^DD",776.2,776.2051,8,21,2,0)
master job for a specific monitor.  When monitor jobs complete, their 
"^DD",776.2,776.2051,8,21,3,0)
record is deleted by Taskman.  For this reason, this field is a free-text 
"^DD",776.2,776.2051,8,21,4,0)
field, avoiding broken pointers.
"^DD",776.2,776.2051,8,"DT")
3030523
"^DD",776.3,776.3,0)
FIELD^^.1^14
"^DD",776.3,776.3,0,"DDA")
N
"^DD",776.3,776.3,0,"DT")
3031211
"^DD",776.3,776.3,0,"ID",4.01)
W:$D(^(4)) "   ",$P(^(4),U,1)
"^DD",776.3,776.3,0,"IX","B",776.3,.01)

"^DD",776.3,776.3,0,"NM","HL7 MONITOR EVENT TYPE")

"^DD",776.3,776.3,0,"PT",776.4,.02)

"^DD",776.3,776.3,0,"PT",776.52,.01)

"^DD",776.3,776.3,0,"VRPK")
HL
"^DD",776.3,776.3,.01,0)
CODE^RF^^0;1^K:$L(X)>14!($L(X)<1)!'(X'?1P.E) X
"^DD",776.3,776.3,.01,.1)
MONITOR EVENT TYPE CODE
"^DD",776.3,776.3,.01,1,0)
^.1
"^DD",776.3,776.3,.01,1,1,0)
776.3^B
"^DD",776.3,776.3,.01,1,1,1)
S ^HLEV(776.3,"B",$E(X,1,30),DA)=""
"^DD",776.3,776.3,.01,1,1,2)
K ^HLEV(776.3,"B",$E(X,1,30),DA)
"^DD",776.3,776.3,.01,3)
Answer must be 1-14 characters in length. A suggested guidline is to prefex the code with the namespace fo the package creating the new code.
"^DD",776.3,776.3,.01,21,0)
^.001^2^2^3030717^^
"^DD",776.3,776.3,.01,21,1,0)
This is the code assigned by an application to a particular type of event.
"^DD",776.3,776.3,.01,21,2,0)
The combination of fields, Code and Assigning Package, should be unique.
"^DD",776.3,776.3,.01,"DT")
3031027
"^DD",776.3,776.3,.02,0)
PACKAGE^RP9.4'^DIC(9.4,^0;2^Q
"^DD",776.3,776.3,.02,.1)
ASSIGNING PACKAGE
"^DD",776.3,776.3,.02,3)
What package is creating this new code?
"^DD",776.3,776.3,.02,"DT")
3031027
"^DD",776.3,776.3,.03,0)
CATEGORY^RS^1:HL7 SYSTEM MESSAGE ERROR;2:APPLICATION MESSAGE ERROR;3:OPERATIONAL ERROR;4:EVENT MONITOR NOTIFICATION;^0;3^Q
"^DD",776.3,776.3,.03,.1)
MONITOR EVENT TYPE CATEGORY
"^DD",776.3,776.3,.03,3)
What category best describes the event type?
"^DD",776.3,776.3,.03,21,0)
^.001^9^9^3030709^^
"^DD",776.3,776.3,.03,21,1,0)
HL7 System Message Errors are errors discovered by the HL7 system while
"^DD",776.3,776.3,.03,21,2,0)
processing a particular message.
"^DD",776.3,776.3,.03,21,3,0)
Application Message Errors are errors discovered by an appication while
"^DD",776.3,776.3,.03,21,4,0)
processing a particular message.  This type of error is defined by the
"^DD",776.3,776.3,.03,21,5,0)
application and usually involve application-specific business rules.
"^DD",776.3,776.3,.03,21,6,0)
Operational Errors are not related to a specific message, rather,they are
"^DD",776.3,776.3,.03,21,7,0)
related to a site.  An common example is a logical link that fails.
"^DD",776.3,776.3,.03,21,8,0)
An Event Monitor Notification is any sort of status update message that
"^DD",776.3,776.3,.03,21,9,0)
may be posted by the Event Monitors.
"^DD",776.3,776.3,.03,"DT")
3030710
"^DD",776.3,776.3,.04,0)
URGENT^S^0:NO;1:YES;2:URGENT IF ACTION FAILS;^0;4^Q
"^DD",776.3,776.3,.04,3)
Is it urgent that this events of this type be reviewed?
"^DD",776.3,776.3,.04,"DT")
3030722
"^DD",776.3,776.3,.05,0)
CONGLOMERATE^S^0:NO;1:YES;^0;5^Q
"^DD",776.3,776.3,.05,3)
Should events of this type be counted over a particular time period and reported as a single event?
"^DD",776.3,776.3,.05,21,0)
^.001^6^6^3030715^^
"^DD",776.3,776.3,.05,21,1,0)
This field determines whether or not discrete events of this type are
"^DD",776.3,776.3,.05,21,2,0)
counted over a defined period of time and reported as a single event
"^DD",776.3,776.3,.05,21,3,0)
along with the count.
"^DD",776.3,776.3,.05,21,4,0)

"^DD",776.3,776.3,.05,21,5,0)
Events that are conglomerated can not store application-specific data
"^DD",776.3,776.3,.05,21,6,0)
with the event.
"^DD",776.3,776.3,.05,"DT")
3030709
"^DD",776.3,776.3,.06,0)
HOURS COVERED^NJ4,0^^0;6^K:+X'=X!(X>9999)!(X<.1)!(X?.E1"."1.N) X
"^DD",776.3,776.3,.06,.1)
PERIOD IN HOURS TO CONGLOMERATE
"^DD",776.3,776.3,.06,3)
What period in number of hours should this event type cover?
"^DD",776.3,776.3,.06,21,0)
^^2^2^3030709^
"^DD",776.3,776.3,.06,21,1,0)
If events of this type are to be conglomerated, this field defines the
"^DD",776.3,776.3,.06,21,2,0)
period in hours over which the events of this type are to be counted.
"^DD",776.3,776.3,.06,"DT")
3030805
"^DD",776.3,776.3,.07,0)
REVIEW^S^0:NOT REQUIRED;1:REQUIRED;2:ONLY IF ACTION FAILS;^0;7^Q
"^DD",776.3,776.3,.07,.1)
REVIEW EVENTS OF THIS TYPE?
"^DD",776.3,776.3,.07,3)
Should this type of event be reviewed?
"^DD",776.3,776.3,.07,"DT")
3030714
"^DD",776.3,776.3,.08,0)
PACKAGE NAME^F^^0;8^K:$L(X)>30!($L(X)<3) X
"^DD",776.3,776.3,.08,3)
Answer with the exact name of the package as found in the Package file.
"^DD",776.3,776.3,.08,21,0)
^^3^3^3031027^
"^DD",776.3,776.3,.08,21,1,0)
This field will be used in the key definition rather then the field PACKAGE
"^DD",776.3,776.3,.08,21,2,0)
because KIDS will not resolve the pointers in the PACKAGE file if the field
"^DD",776.3,776.3,.08,21,3,0)
is part of the key.
"^DD",776.3,776.3,.08,"DT")
3031027
"^DD",776.3,776.3,.09,0)
DAYS TILL PURGE^RNJ3,0^^0;9^K:+X'=X!(X>999)!(X<1)!(X?.E1"."1N.N) X
"^DD",776.3,776.3,.09,.1)
DAYS TO KEEP BEFORE PURGING
"^DD",776.3,776.3,.09,3)
How many days should events of this type be tracked before they are purged?
"^DD",776.3,776.3,.09,"DT")
3030725
"^DD",776.3,776.3,.1,0)
ACTIVE^S^0:NO;1:YES;^0;10^Q
"^DD",776.3,776.3,.1,3)
Should events of this type be logged?
"^DD",776.3,776.3,.1,21,0)
^^4^4^3031211^
"^DD",776.3,776.3,.1,21,1,0)
This field can be used to disable a particular event type.  It is a safety
"^DD",776.3,776.3,.1,21,2,0)
feature - if large numbers of events of a particular tye are generated and
"^DD",776.3,776.3,.1,21,3,0)
it is discovered that logging them is not useful then the logging can be
"^DD",776.3,776.3,.1,21,4,0)
turned off via this field.
"^DD",776.3,776.3,.1,"DT")
3031211
"^DD",776.3,776.3,1,0)
ACTION^FX^^1;E1,20^K:'$L($T(@X)) X
"^DD",776.3,776.3,1,.1)
AUTOMATIC ACTION FOR EVENT TYPE
"^DD",776.3,776.3,1,3)
What routine, in the format <tag>^<routine>, should be executed when events of this type occur?
"^DD",776.3,776.3,1,21,0)
^.001^2^2^3030710^^^^
"^DD",776.3,776.3,1,21,1,0)
The action will be executed when the event occurs.  For conglomerated
"^DD",776.3,776.3,1,21,2,0)
events, the action is executed when the time period expires.
"^DD",776.3,776.3,1,"DT")
3030710
"^DD",776.3,776.3,2,0)
SERVER LOCATIONS^776.32P^^2;0
"^DD",776.3,776.3,2,"DT")
3030710
"^DD",776.3,776.3,3,0)
FULL DESCRIPTION^776.33^^3;0
"^DD",776.3,776.3,3,"DT")
3030722
"^DD",776.3,776.3,4.01,0)
BRIEF DESCRIPTION^F^^4;1^K:$L(X)>80!($L(X)<1) X
"^DD",776.3,776.3,4.01,3)
Answer must be 1-80 characters in length
"^DD",776.3,776.3,4.01,"DT")
3030722
"^DD",776.3,776.32,0)
SERVER LOCATIONS SUB-FIELD^^2^2
"^DD",776.3,776.32,0,"DT")
3031002
"^DD",776.3,776.32,0,"IX","B",776.32,.01)

"^DD",776.3,776.32,0,"NM","SERVER LOCATIONS")

"^DD",776.3,776.32,0,"UP")
776.3
"^DD",776.3,776.32,.01,0)
DOMAIN^MP4.2'^DIC(4.2,^0;1^Q
"^DD",776.3,776.32,.01,.1)
SERVER LOCATION FOR EVENT TYPE
"^DD",776.3,776.32,.01,1,0)
^.1
"^DD",776.3,776.32,.01,1,1,0)
776.32^B
"^DD",776.3,776.32,.01,1,1,1)
S ^HLEV(776.3,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",776.3,776.32,.01,1,1,2)
K ^HLEV(776.3,DA(1),2,"B",$E(X,1,30),DA)
"^DD",776.3,776.32,.01,3)
What locations will monitor servers be located for this event type?
"^DD",776.3,776.32,.01,21,0)
^.001^2^2^3030710^^
"^DD",776.3,776.32,.01,21,1,0)
This will be a list of Mailman Domains where events of this type should be 
"^DD",776.3,776.32,.01,21,2,0)
sent for centralized monitoring.
"^DD",776.3,776.32,.01,"DT")
3030710
"^DD",776.3,776.32,2,0)
SCREEN^K^^1;E1,245^K:$L(X)>245 X D:$D(X) ^DIM
"^DD",776.3,776.32,2,3)
Enter MUMPS code to be Xecuted when an event of this type occurs.  It should set $T to 1 if the event should be sent to this remote location.  
"^DD",776.3,776.32,2,21,0)
^^12^12^3031002^^
"^DD",776.3,776.32,2,21,1,0)
This field provides a method for application developers to screen which events
"^DD",776.3,776.32,2,21,2,0)
are sent to a remote server.  At the point at which an event occurs, 
"^DD",776.3,776.32,2,21,3,0)
Event Logging determines what remoted locations to send the event.  If an
"^DD",776.3,776.32,2,21,4,0)
application wishes to provide remoted viewing of its events then for those
"^DD",776.3,776.32,2,21,5,0)
Event Types for which it is concerned it should make an entry in the Server
"^DD",776.3,776.32,2,21,6,0)
Locations multiple. It can further screen which events to send by associating
"^DD",776.3,776.32,2,21,7,0)
a MUMPS screen with that SERVER LOCATION.  When Xecuted, the screen should set
"^DD",776.3,776.32,2,21,8,0)
$T=1 if the event should be sent to the remote server, 0 otherwise.  The
"^DD",776.3,776.32,2,21,9,0)
HLEVENT() array is defined at the point at which the screen is
"^DD",776.3,776.32,2,21,10,0)
executed.  A complete description of that array is provided for the
"^DD",776.3,776.32,2,21,11,0)
$$EVENT^HLEME() API that is provide for application developers using the
"^DD",776.3,776.32,2,21,12,0)
HL7 package.
"^DD",776.3,776.32,2,"DT")
3031002
"^DD",776.3,776.33,0)
FULL DESCRIPTION SUB-FIELD^^.01^1
"^DD",776.3,776.33,0,"DT")
3030717
"^DD",776.3,776.33,0,"NM","FULL DESCRIPTION")

"^DD",776.3,776.33,0,"UP")
776.3
"^DD",776.3,776.33,.01,0)
FULL DESCRIPTION^W^^0;1^Q
"^DD",776.3,776.33,.01,3)
Enter a complete description of what this events of this type signfy.
"^DD",776.3,776.33,.01,"DT")
3030722
"^DD",776.4,776.4,0)
FIELD^^3^20
"^DD",776.4,776.4,0,"DT")
3030925
"^DD",776.4,776.4,0,"ID",.02)
S %I=Y,Y=$S('$D(^(0)):"",$D(^HLEV(776.3,+$P(^(0),U,2),0))#2:$P(^(0),U,1),1:""),C=$P(^DD(776.3,.01,0),U,2) D Y^DIQ:Y]"" W "   ",Y,@("$E("_DIC_"%I,0),0)") S Y=%I K %I
"^DD",776.4,776.4,0,"ID",.04)
W "   ",$P(^(0),U,4)
"^DD",776.4,776.4,0,"IX","B",776.4,.01)

"^DD",776.4,776.4,0,"NM","HL7 MONITOR EVENT")

"^DD",776.4,776.4,0,"VRPK")
HL
"^DD",776.4,776.4,.01,0)
DT/TM^RD^^0;1^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",776.4,776.4,.01,.1)
DATE/TIME OF OCCURENCE
"^DD",776.4,776.4,.01,1,0)
^.1
"^DD",776.4,776.4,.01,1,1,0)
776.4^B
"^DD",776.4,776.4,.01,1,1,1)
S ^HLEV(776.4,"B",$E(X,1,30),DA)=""
"^DD",776.4,776.4,.01,1,1,2)
K ^HLEV(776.4,"B",$E(X,1,30),DA)
"^DD",776.4,776.4,.01,1,1,"%D",0)
^^3^3^3040112^
"^DD",776.4,776.4,.01,1,1,"%D",1,0)
There is only one entry in the HL Event Parameters file (#776.999).  The 
"^DD",776.4,776.4,.01,1,1,"%D",2,0)
entry's name is stored on the Name field (#.01), which is 
"^DD",776.4,776.4,.01,1,1,"%D",3,0)
cross-referenced in this B xref.
"^DD",776.4,776.4,.01,3)
When exactly did the even occur?
"^DD",776.4,776.4,.01,21,0)
^.001^1^1^3030717^^
"^DD",776.4,776.4,.01,21,1,0)
The date and time the event occurred.
"^DD",776.4,776.4,.01,"DT")
3030821
"^DD",776.4,776.4,.02,0)
TYPE^RP776.3'^HLEV(776.3,^0;2^Q
"^DD",776.4,776.4,.02,.1)
HL7 MONITOR EVENT TYPE
"^DD",776.4,776.4,.02,3)
What type of event is this?
"^DD",776.4,776.4,.02,"DT")
3030821
"^DD",776.4,776.4,.03,0)
SITE^RP4'^DIC(4,^0;3^Q
"^DD",776.4,776.4,.03,.1)
SITE OF EVENT OCCURRENCE
"^DD",776.4,776.4,.03,3)
Where did the event occur?
"^DD",776.4,776.4,.03,21,0)
^^1^1^3030710^
"^DD",776.4,776.4,.03,21,1,0)
This is the location of the event.
"^DD",776.4,776.4,.03,"DT")
3030723
"^DD",776.4,776.4,.04,0)
ID^F^^0;4^K:$L(X)>12!($L(X)<5) X
"^DD",776.4,776.4,.04,3)
Should begin with a prefix consisting of the station number followed by a hyphen.
"^DD",776.4,776.4,.04,21,0)
^^1^1^3030714^
"^DD",776.4,776.4,.04,21,1,0)
This will uniquely identify the event across the entire VHA.
"^DD",776.4,776.4,.04,"DT")
3030714
"^DD",776.4,776.4,.05,0)
ACTION STATUS^RS^0:ACTION NOT REQUIRED;1:NOT YET INITIATED;2:IN PROGRESS;3:SUCCESS;4:FAILURE;^0;5^Q
"^DD",776.4,776.4,.05,3)
What is the status of the action?
"^DD",776.4,776.4,.05,"DT")
3030722
"^DD",776.4,776.4,.06,0)
REVIEW STATUS^RS^0:NOT REQUIRED;1:REQUIRED;2:IF ACTION FAILS;3:PENDING;4:COMPLETED;^0;6^Q
"^DD",776.4,776.4,.06,3)
Is a review needed?  Has it been completed?  Enter the most appropriate status.
"^DD",776.4,776.4,.06,"DT")
3030820
"^DD",776.4,776.4,.07,0)
DT/TM REVIEWED^D^^0;7^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",776.4,776.4,.07,.1)
DATE/TIME REVIEWED
"^DD",776.4,776.4,.07,3)
When was this event reviewed?
"^DD",776.4,776.4,.07,21,0)
^^2^2^3030710^
"^DD",776.4,776.4,.07,21,1,0)
This documents when the event was manually reviewed.  If never reviewed,
"^DD",776.4,776.4,.07,21,2,0)
the field is blank.
"^DD",776.4,776.4,.07,"DT")
3030711
"^DD",776.4,776.4,.08,0)
REVIEWER^P200'^VA(200,^0;8^Q
"^DD",776.4,776.4,.08,3)
Who reviewed this event?
"^DD",776.4,776.4,.08,"DT")
3030710
"^DD",776.4,776.4,.09,0)
DT/TM ACTION^D^^0;9^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",776.4,776.4,.09,.1)
DATE/TIME OF AUTOMATED ACTION
"^DD",776.4,776.4,.09,3)
When was the autmated action executed?
"^DD",776.4,776.4,.09,"DT")
3030711
"^DD",776.4,776.4,.1,0)
HL7 ID^F^^0;10^K:$L(X)>20!($L(X)<1) X
"^DD",776.4,776.4,.1,.1)
HL7 MESSAGE ID
"^DD",776.4,776.4,.1,3)
If the event is associated with a particular HL7 message, enter the unique HL7 Message ID.
"^DD",776.4,776.4,.1,"DT")
3030715
"^DD",776.4,776.4,.11,0)
COUNT^NJ8,0^^0;11^K:+X'=X!(X>99999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",776.4,776.4,.11,3)
For conglomerated events, enter the count of discrete events included in this event.
"^DD",776.4,776.4,.11,21,0)
^^2^2^3030715^
"^DD",776.4,776.4,.11,21,1,0)
This field pertains only to conglomerated events, that is, events that represent
"^DD",776.4,776.4,.11,21,2,0)
a count of discrete events over some spefcific time period.
"^DD",776.4,776.4,.11,"DT")
3030723
"^DD",776.4,776.4,.12,0)
URGENT^S^0:NO;1:YES;2:URGENT IF ACTION FAILS;^0;12^Q
"^DD",776.4,776.4,.12,3)
Is it urgent that this event be reviewed?
"^DD",776.4,776.4,.12,"DT")
3030722
"^DD",776.4,776.4,.13,0)
MESSAGE TYPE^F^^0;13^K:$L(X)>3!($L(X)<3) X
"^DD",776.4,776.4,.13,3)
Answer with the 3 character HL7 message type code.
"^DD",776.4,776.4,.13,"DT")
3030722
"^DD",776.4,776.4,.14,0)
HL7 EVENT TYPE^F^^0;14^K:$L(X)>3!($L(X)<3) X
"^DD",776.4,776.4,.14,3)
Answer with the 3 character HL7 event type code
"^DD",776.4,776.4,.14,"DT")
3030722
"^DD",776.4,776.4,.15,0)
LINK^F^^0;15^K:$L(X)>10!($L(X)<1) X
"^DD",776.4,776.4,.15,3)
Answer with the name of the HL Logical Link over which the message was transmitted.
"^DD",776.4,776.4,.15,"DT")
3030722
"^DD",776.4,776.4,.16,0)
SENDING APPLICATION^F^^0;16^K:$L(X)>15!($L(X)<3) X
"^DD",776.4,776.4,.16,3)
Answer with the name of the HL7 Application Parameter that represents the application that sent the message.
"^DD",776.4,776.4,.16,"DT")
3030924
"^DD",776.4,776.4,.17,0)
CREATE DT/TM^D^^0;17^S %DT="ESTXR" D ^%DT S X=Y K:X<1 X
"^DD",776.4,776.4,.17,3)
Enter the exact date and time that this record was created.
"^DD",776.4,776.4,.17,"DT")
3030924
"^DD",776.4,776.4,1,0)
NOTES^776.41^^1;0
"^DD",776.4,776.4,2,0)
MAIL^776.42^^2;0
"^DD",776.4,776.4,2,"DT")
3030715
"^DD",776.4,776.4,3,0)
APPLICATION DATA^776.43^^3;0
"^DD",776.4,776.4,3,21,0)
^^2^2^3030728^^^
"^DD",776.4,776.4,3,21,1,0)
This allows an application to store its own information relevant to
"^DD",776.4,776.4,3,21,2,0)
resolving the event along with the event.
"^DD",776.4,776.41,0)
NOTES SUB-FIELD^^.01^1
"^DD",776.4,776.41,0,"DT")
3030710
"^DD",776.4,776.41,0,"NM","NOTES")

"^DD",776.4,776.41,0,"UP")
776.4
"^DD",776.4,776.41,.01,0)
NOTES^W^^0;1^Q
"^DD",776.4,776.41,.01,3)
Enter your comments and actions taken.
"^DD",776.4,776.41,.01,"DT")
3030710
"^DD",776.4,776.42,0)
MAIL SUB-FIELD^^.01^1
"^DD",776.4,776.42,0,"DT")
3030925
"^DD",776.4,776.42,0,"IX","B",776.42,.01)

"^DD",776.4,776.42,0,"NM","MAIL")

"^DD",776.4,776.42,0,"UP")
776.4
"^DD",776.4,776.42,.01,0)
MAIL^MF^^0;1^K:$L(X)>15!($L(X)<1) X
"^DD",776.4,776.42,.01,.1)
MAIL MESSAGE
"^DD",776.4,776.42,.01,1,0)
^.1
"^DD",776.4,776.42,.01,1,1,0)
776.42^B
"^DD",776.4,776.42,.01,1,1,1)
S ^HLEV(776.4,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",776.4,776.42,.01,1,1,2)
K ^HLEV(776.4,DA(1),2,"B",$E(X,1,30),DA)
"^DD",776.4,776.42,.01,3)
This is a pointer to the Message file (#3.9) stored as free text.
"^DD",776.4,776.42,.01,"DT")
3030925
"^DD",776.4,776.43,0)
APPLICATION DATA SUB-FIELD^^2^2
"^DD",776.4,776.43,0,"DT")
3030728
"^DD",776.4,776.43,0,"IX","B",776.43,.01)

"^DD",776.4,776.43,0,"NM","APPLICATION DATA")

"^DD",776.4,776.43,0,"UP")
776.4
"^DD",776.4,776.43,.01,0)
SUBSCRIPTED VARIABLE^MF^^0;1^K:$L(X)>230!($L(X)<3) X
"^DD",776.4,776.43,.01,1,0)
^.1
"^DD",776.4,776.43,.01,1,1,0)
776.43^B
"^DD",776.4,776.43,.01,1,1,1)
S ^HLEV(776.4,DA(1),3,"B",$E(X,1,230),DA)=""
"^DD",776.4,776.43,.01,1,1,2)
K ^HLEV(776.4,DA(1),3,"B",$E(X,1,230),DA)
"^DD",776.4,776.43,.01,3)
Enter the name of the variable to save, including any subscripts.
"^DD",776.4,776.43,.01,21,0)
^^8^8^3030728^^
"^DD",776.4,776.43,.01,21,1,0)
This is the name of the variable, which may or may not include subcripts.
"^DD",776.4,776.43,.01,21,2,0)
Examples are:
"^DD",776.4,776.43,.01,21,3,0)

"^DD",776.4,776.43,.01,21,4,0)
"DUZ"
"^DD",776.4,776.43,.01,21,5,0)
"ICN"
"^DD",776.4,776.43,.01,21,6,0)
"MYDATA(1)"
"^DD",776.4,776.43,.01,21,7,0)
"MYDATA(2)"
"^DD",776.4,776.43,.01,21,8,0)
"MYDATA(""PATIENTS"",33)"
"^DD",776.4,776.43,.01,"DT")
3030728
"^DD",776.4,776.43,2,0)
VALUE^F^^2;1^K:$L(X)>245!($L(X)<1) X
"^DD",776.4,776.43,2,3)
What is the value?  Enter a string 1-245 characters in length.
"^DD",776.4,776.43,2,"DT")
3030710
"^DD",776.5,776.5,0)
FIELD^^.09^13
"^DD",776.5,776.5,0,"DDA")
N
"^DD",776.5,776.5,0,"DT")
3030725
"^DD",776.5,776.5,0,"IX","B",776.5,.01)

"^DD",776.5,776.5,0,"NM","HL7 MONITOR EVENTS PROFILE")

"^DD",776.5,776.5,.01,0)
USER^RP200'^VA(200,^0;1^Q
"^DD",776.5,776.5,.01,1,0)
^.1
"^DD",776.5,776.5,.01,1,1,0)
776.5^B
"^DD",776.5,776.5,.01,1,1,1)
S ^HLEV(776.5,"B",$E(X,1,30),DA)=""
"^DD",776.5,776.5,.01,1,1,2)
K ^HLEV(776.5,"B",$E(X,1,30),DA)
"^DD",776.5,776.5,.01,3)
Who is this profile for?
"^DD",776.5,776.5,.01,21,0)
^.001^1^1^3030724^^
"^DD",776.5,776.5,.01,21,1,0)
This is the owner of the profile.
"^DD",776.5,776.5,.01,"DT")
3030725
"^DD",776.5,776.5,.02,0)
PROFILE NAME^RF^^0;2^K:$L(X)>30!($L(X)<1) X
"^DD",776.5,776.5,.02,3)
What name do you want to give to this profile?
"^DD",776.5,776.5,.02,"DT")
3030724
"^DD",776.5,776.5,.03,0)
DEFAULT?^S^0:NO;1:YES;^0;3^Q
"^DD",776.5,776.5,.03,3)
Is this your default profile, i.e., should it be used each time you initially enter the event log?
"^DD",776.5,776.5,.03,"DT")
3030725
"^DD",776.5,776.5,.04,0)
ALL SITES?^S^0:NO;1:YES;^0;4^Q
"^DD",776.5,776.5,.04,3)
Should this profile include events from all sites?
"^DD",776.5,776.5,.04,21,0)
^^3^3^3030724^
"^DD",776.5,776.5,.04,21,1,0)
This field indicates whether or not events should be screened based on a 
"^DD",776.5,776.5,.04,21,2,0)
list of particular sites.  If YES,  events from all sites will be 
"^DD",776.5,776.5,.04,21,3,0)
included in the Event Log display.
"^DD",776.5,776.5,.04,"DT")
3030724
"^DD",776.5,776.5,.05,0)
ALL EVENT TYPES?^S^0:NO;1:YES;^0;5^Q
"^DD",776.5,776.5,.05,3)
Do you want to see all HL7 Monitor Event Types in this profile?
"^DD",776.5,776.5,.05,"DT")
3030725
"^DD",776.5,776.5,.06,0)
ALL SENDING APPLICATIONS?^S^0:NO;1:YES;^0;6^Q
"^DD",776.5,776.5,.06,3)
Do you want to view messages from all applications in this profile?
"^DD",776.5,776.5,.06,"DT")
3030725
"^DD",776.5,776.5,.07,0)
ALL REVIEW STATUSES?^S^0:NO;1:YES;^0;7^Q
"^DD",776.5,776.5,.07,3)
Do you want to view all messages regardless of their review status?
"^DD",776.5,776.5,.07,"DT")
3030725
"^DD",776.5,776.5,.08,0)
TIME PERIOD^S^1:PRIOR HOUR;2:PRIOR 2 HOURS;3:PRIOR 6 HOURS;4:TODAY;5:LAST 24 HOURS;6:TODAY AND YESTERDAY;7:LAST 48 HOURS;8:LAST 72 HOURS;9:LAST 7 DAYS;0:ALL;^0;8^Q
"^DD",776.5,776.5,.08,3)
Select the time period you would like to view.
"^DD",776.5,776.5,.08,"DT")
3030725
"^DD",776.5,776.5,.09,0)
ONLY URGENT?^S^0:NO;1:YES;^0;9^Q
"^DD",776.5,776.5,.09,3)
Should only urgent events be displayed?
"^DD",776.5,776.5,.09,"DT")
3030725
"^DD",776.5,776.5,1,0)
SITES^776.51P^^1;0
"^DD",776.5,776.5,1,21,0)
^.001^2^2^3030724^^
"^DD",776.5,776.5,1,21,1,0)
This is a list of sites that should be included in displays based on this
"^DD",776.5,776.5,1,21,2,0)
profile.
"^DD",776.5,776.5,2,0)
EVENT TYPES^776.52P^^2;0
"^DD",776.5,776.5,3,0)
SENDING APPLICATIONS?^776.53P^^3;0
"^DD",776.5,776.5,4,0)
REVEIW STATUS CODES^776.54S^^4;0
"^DD",776.5,776.51,0)
SITES SUB-FIELD^^.01^1
"^DD",776.5,776.51,0,"DT")
3030724
"^DD",776.5,776.51,0,"IX","B",776.51,.01)

"^DD",776.5,776.51,0,"NM","SITES")

"^DD",776.5,776.51,0,"UP")
776.5
"^DD",776.5,776.51,.01,0)
SITES^MP4'^DIC(4,^0;1^Q
"^DD",776.5,776.51,.01,1,0)
^.1
"^DD",776.5,776.51,.01,1,1,0)
776.51^B
"^DD",776.5,776.51,.01,1,1,1)
S ^HLEV(776.5,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",776.5,776.51,.01,1,1,2)
K ^HLEV(776.5,DA(1),1,"B",$E(X,1,30),DA)
"^DD",776.5,776.51,.01,3)
Enter sites who's events should be included in your display of the HL7 Monitor Events Log.
"^DD",776.5,776.51,.01,"DT")
3030724
"^DD",776.5,776.52,0)
EVENT TYPES SUB-FIELD^^.01^1
"^DD",776.5,776.52,0,"DT")
3030725
"^DD",776.5,776.52,0,"IX","B",776.52,.01)

"^DD",776.5,776.52,0,"NM","EVENT TYPES")

"^DD",776.5,776.52,0,"UP")
776.5
"^DD",776.5,776.52,.01,0)
EVENT TYPES^MP776.3'^HLEV(776.3,^0;1^Q
"^DD",776.5,776.52,.01,1,0)
^.1
"^DD",776.5,776.52,.01,1,1,0)
776.52^B
"^DD",776.5,776.52,.01,1,1,1)
S ^HLEV(776.5,DA(1),2,"B",$E(X,1,30),DA)=""
"^DD",776.5,776.52,.01,1,1,2)
K ^HLEV(776.5,DA(1),2,"B",$E(X,1,30),DA)
"^DD",776.5,776.52,.01,3)
What HL7 Monitor Event Types would you like to view in this profile?
"^DD",776.5,776.52,.01,"DT")
3030725
"^DD",776.5,776.53,0)
SENDING APPLICATIONS? SUB-FIELD^^.01^1
"^DD",776.5,776.53,0,"DT")
3030725
"^DD",776.5,776.53,0,"IX","B",776.53,.01)

"^DD",776.5,776.53,0,"NM","SENDING APPLICATIONS?")

"^DD",776.5,776.53,0,"UP")
776.5
"^DD",776.5,776.53,.01,0)
SENDING APPLICATIONS?^MP771'^HL(771,^0;1^Q
"^DD",776.5,776.53,.01,1,0)
^.1
"^DD",776.5,776.53,.01,1,1,0)
776.53^B
"^DD",776.5,776.53,.01,1,1,1)
S ^HLEV(776.5,DA(1),3,"B",$E(X,1,30),DA)=""
"^DD",776.5,776.53,.01,1,1,2)
K ^HLEV(776.5,DA(1),3,"B",$E(X,1,30),DA)
"^DD",776.5,776.53,.01,3)
What sendign applications would you like to include in this profile?
"^DD",776.5,776.53,.01,"DT")
3030725
"^DD",776.5,776.54,0)
REVEIW STATUS CODES SUB-FIELD^^.01^1
"^DD",776.5,776.54,0,"DT")
3030725
"^DD",776.5,776.54,0,"IX","B",776.54,.01)

"^DD",776.5,776.54,0,"NM","REVEIW STATUS CODES")

"^DD",776.5,776.54,0,"UP")
776.5
"^DD",776.5,776.54,.01,0)
REVEIW STATUS CODES^MS^0:NOT REQUIRED;1:REQUIRED;2:ONLY IF ACTION FAILS;3:PENDING;4:COMPLETED;^0;1^Q
"^DD",776.5,776.54,.01,1,0)
^.1
"^DD",776.5,776.54,.01,1,1,0)
776.54^B
"^DD",776.5,776.54,.01,1,1,1)
S ^HLEV(776.5,DA(1),4,"B",$E(X,1,30),DA)=""
"^DD",776.5,776.54,.01,1,1,2)
K ^HLEV(776.5,DA(1),4,"B",$E(X,1,30),DA)
"^DD",776.5,776.54,.01,3)
What review statuses would you like to view?
"^DD",776.5,776.54,.01,"DT")
3030725
"^DD",776.999,776.999,0)
FIELD^^6^5
"^DD",776.999,776.999,0,"DT")
3030808
"^DD",776.999,776.999,0,"IX","B",776.999,.01)

"^DD",776.999,776.999,0,"NM","HL7 MONITOR PARAMETERS")

"^DD",776.999,776.999,0,"VRPK")
HL
"^DD",776.999,776.999,.01,0)
NAME^RF^^0;1^K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E) X
"^DD",776.999,776.999,.01,1,0)
^.1
"^DD",776.999,776.999,.01,1,1,0)
776.999^B
"^DD",776.999,776.999,.01,1,1,1)
S ^HLEV(776.999,"B",$E(X,1,30),DA)=""
"^DD",776.999,776.999,.01,1,1,2)
K ^HLEV(776.999,"B",$E(X,1,30),DA)
"^DD",776.999,776.999,.01,3)
NAME MUST BE 3-30 CHARACTERS, NOT NUMERIC OR STARTING WITH PUNCTUATION
"^DD",776.999,776.999,.01,21,0)
^^3^3^3030825^
"^DD",776.999,776.999,.01,21,1,0)
This field holds the name of the parameter entry.  (Only one entry, 
"^DD",776.999,776.999,.01,21,2,0)
internal entry number 1 should exist.)  The value of this field has no
"^DD",776.999,776.999,.01,21,3,0)
affect on software execution.
"^DD",776.999,776.999,2,0)
STATUS-MASTER^S^A:ACTIVE;I:INACTIVE;^0;2^Q
"^DD",776.999,776.999,2,21,0)
^^6^6^3030825^
"^DD",776.999,776.999,2,21,1,0)
This field should be set to ACTIVE if the master job should run, and 
"^DD",776.999,776.999,2,21,2,0)
INACTIVE if the master job should not run.  This field also controls
"^DD",776.999,776.999,2,21,3,0)
individual monitor jobs.  (Note that setting this field has no affect
"^DD",776.999,776.999,2,21,4,0)
on queued future Taskman jobs - either the master job or the monitor
"^DD",776.999,776.999,2,21,5,0)
jobst - until these jobs start.  If this field is set to INACTIVE,
"^DD",776.999,776.999,2,21,6,0)
when queued jobs start they check this field and immediately stop.)
"^DD",776.999,776.999,2,"DT")
3030518
"^DD",776.999,776.999,3,0)
REQUEUE MIN-MASTER JOB^NJ4,0^^0;3^K:+X'=X!(X>1440)!(X<5)!(X?.E1"."1N.N) X
"^DD",776.999,776.999,3,3)
Type a Number between 5 and 1440, 0 Decimal Digits
"^DD",776.999,776.999,3,21,0)
^^3^3^3030825^
"^DD",776.999,776.999,3,21,1,0)
When a master job runs, it's first action is to queue a new master job
"^DD",776.999,776.999,3,21,2,0)
task in the future.  This field is used to determine the number minutes
"^DD",776.999,776.999,3,21,3,0)
in the future that the task is queued.
"^DD",776.999,776.999,3,"DT")
3030808
"^DD",776.999,776.999,4,0)
PURGE HOURS^NJ5,0^^0;4^K:+X'=X!(X>12000)!(X<2)!(X?.E1"."1N.N) X
"^DD",776.999,776.999,4,3)
Type a Number between 2 and 12000, 0 Decimal Digits
"^DD",776.999,776.999,4,21,0)
^^2^2^3030825^
"^DD",776.999,776.999,4,21,1,0)
The Event Monitor system purges itself, retaining data in it's files
"^DD",776.999,776.999,4,21,2,0)
for the number hours specified by this field.
"^DD",776.999,776.999,4,"DT")
3030528
"^DD",776.999,776.999,6,0)
STATUS-EVENT^S^A:ACTIVE;I:INACTIVE;^0;6^Q
"^DD",776.999,776.999,6,21,0)
^^5^5^3030825^
"^DD",776.999,776.999,6,21,1,0)
This field is similar to the STATUS-MASTER field, (and you should read 
"^DD",776.999,776.999,6,21,2,0)
the description of that field), but only controls individual monitor
"^DD",776.999,776.999,6,21,3,0)
jobs.  If this field is set to INACTIVE, no new monitor jobs will be queued.
"^DD",776.999,776.999,6,21,4,0)
And, if any monitor jobs are already queued, they will stop immediately
"^DD",776.999,776.999,6,21,5,0)
when they start.
"^DD",776.999,776.999,6,"DT")
3030518
"^DD",869.3,869.3,44,0)
PURGE ERROR STATUS MESSAGES^NJ3,0^^4;4^K:+X'=X!(X>999)!(X<1)!(X?.E1"."1N.N) X
"^DD",869.3,869.3,44,3)
Type a Number to represent the days to keep error status messages messages.  The default number of days is 90.
"^DD",869.3,869.3,44,21,0)
^^4^4^3030210^
"^DD",869.3,869.3,44,21,1,0)
The number of days error status messages are retained before they are 
"^DD",869.3,869.3,44,21,2,0)
purged.  90 days is used as the actual value when the "Purge Messages" 
"^DD",869.3,869.3,44,21,3,0)
option is scheduled through TaskMan, and as the default when run 
"^DD",869.3,869.3,44,21,4,0)
interactively.
"^DD",869.3,869.3,44,"DT")
3030210
"^DD",869.3,869.3,772,0)
LAST IEN, FILE 772^NJ10,0^^772;1^K:+X'=X!(X>9999999999)!(X<0)!(X?.E1"."1.N) X
"^DD",869.3,869.3,772,3)
Enter the last ien used for file 772.
"^DD",869.3,869.3,772,21,0)
^^2^2^3031104^
"^DD",869.3,869.3,772,21,1,0)
The node 772 should have no other fields.  It is used as a counter to assign
"^DD",869.3,869.3,772,21,2,0)
an ien to a new record.
"^DD",869.3,869.3,772,"DT")
3031104
"^DD",869.3,869.3,773,0)
LAST IEN, FILE 773^NJ10,0^^773;1^K:+X'=X!(X>9999999999)!(X<0)!(X?.E1"."1.N) X
"^DD",869.3,869.3,773,3)
Enter the last ien used for file 773.
"^DD",869.3,869.3,773,21,0)
^^2^2^3031104^
"^DD",869.3,869.3,773,21,1,0)
The node 773 should have no other fields.  It is used as a counter to assign
"^DD",869.3,869.3,773,21,2,0)
an ien to a new record.
"^DD",869.3,869.3,773,"DT")
3031104
"^DIC",773,773,0)
HL7 MESSAGE ADMINISTRATION^773P
"^DIC",773,773,0,"GL")
^HLMA(
"^DIC",773,773,"%",0)
^1.005^^0
"^DIC",773,773,"%D",0)
^^2^2^2950103^^
"^DIC",773,773,"%D",1,0)
This file is used to create and maintain unique message IDs.  It also
"^DIC",773,773,"%D",2,0)
contains a date/time when each ID was created.
"^DIC",773,"B","HL7 MESSAGE ADMINISTRATION",773)

"^DIC",776,776,0)
HL7 MONITOR JOB^776
"^DIC",776,776,0,"GL")
^HLEV(776,
"^DIC",776,"B","HL7 MONITOR JOB",776)

"^DIC",776.1,776.1,0)
HL7 MONITOR^776.1
"^DIC",776.1,776.1,0,"GL")
^HLEV(776.1,
"^DIC",776.1,"B","HL7 MONITOR",776.1)

"^DIC",776.2,776.2,0)
HL7 MONITOR MASTER JOB^776.2
"^DIC",776.2,776.2,0,"GL")
^HLEV(776.2,
"^DIC",776.2,"B","HL7 MONITOR MASTER JOB",776.2)

"^DIC",776.3,776.3,0)
HL7 MONITOR EVENT TYPE^776.3
"^DIC",776.3,776.3,0,"GL")
^HLEV(776.3,
"^DIC",776.3,776.3,"%",0)
^1.005^^0
"^DIC",776.3,"B","HL7 MONITOR EVENT TYPE",776.3)

"^DIC",776.4,776.4,0)
HL7 MONITOR EVENT^776.4
"^DIC",776.4,776.4,0,"GL")
^HLEV(776.4,
"^DIC",776.4,"B","HL7 MONITOR EVENT",776.4)

"^DIC",776.5,776.5,0)
HL7 MONITOR EVENTS PROFILE^776.5
"^DIC",776.5,776.5,0,"GL")
^HLEV(776.5,
"^DIC",776.5,776.5,"%",0)
^1.005^^
"^DIC",776.5,776.5,"%D",0)
^^2^2^3040113^^
"^DIC",776.5,776.5,"%D",1,0)
This file contains personal profiles for displaying events in the HL7 
"^DIC",776.5,776.5,"%D",2,0)
Monitor Event Log.
"^DIC",776.5,"B","HL7 MONITOR EVENTS PROFILE",776.5)

"^DIC",776.999,776.999,0)
HL7 MONITOR PARAMETERS^776.999
"^DIC",776.999,776.999,0,"GL")
^HLEV(776.999,
"^DIC",776.999,"B","HL7 MONITOR PARAMETERS",776.999)

**END**
**END**
